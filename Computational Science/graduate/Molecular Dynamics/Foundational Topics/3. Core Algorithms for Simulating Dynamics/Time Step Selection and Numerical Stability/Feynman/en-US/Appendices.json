{
    "hands_on_practices": [
        {
            "introduction": "The cornerstone of selecting a time step in any molecular dynamics simulation is understanding the relationship between the integrator's stability and the fastest motions in the system. This first practice provides a direct, hands-on exploration of this principle by modeling the fastest vibration, such as an O-H bond stretch, as a simple harmonic oscillator. By computationally searching for the critical time step $\\Delta t_{\\text{crit}}$ at which the widely-used velocity Verlet algorithm becomes unstable, you will empirically verify the fundamental stability limit and build a concrete intuition for why high-frequency motions constrain our choice of $\\Delta t$. ",
            "id": "3455229",
            "problem": "Consider a discrete-time Molecular Dynamics (MD) integrator for a single dominant curvature mode that approximates the fastest internal motion in a Simple Point Charge Extended (SPC/E) water model. The maximum force curvature mode can be modeled as a one-dimensional harmonic oscillator with position $x(t)$ governed by Newton's second law $m\\,\\ddot{x}(t) = -k\\,x(t)$, where $m$ is the mass and $k$ is the curvature of the potential at equilibrium. Defining the angular frequency by $\\omega = \\sqrt{k/m}$, one can discretize the equations of motion using the velocity Verlet scheme with a time step $\\Delta t$. The empirical stability boundary of this scheme can be explored by progressively increasing $\\Delta t$ and observing whether the numerical oscillations remain bounded or diverge.\n\nYour task is to write a program that:\n- Treats the dominant curvature mode as a single harmonic oscillator $x''(t) + \\omega^2 x(t) = 0$, where $x''(t)$ denotes the second time derivative of $x(t)$.\n- Uses the velocity Verlet algorithm to numerically step the equations forward in time for a fixed number of steps $N$, starting from small initial conditions, and detects instability when the numerical amplitude grows beyond a prescribed bound.\n- Empirically locates the largest stable time step $\\Delta t_{\\text{crit}}$ for which the numerical solution remains bounded, by scanning $\\Delta t$ from small to large values and refining the boundary via bisection.\n- Relates the observed threshold $\\Delta t_{\\text{crit}}$ to the characteristic angular frequency $\\omega$ by reporting the dimensionless ratio $\\rho = \\Delta t_{\\text{crit}}\\,\\omega / 2$.\n\nScientific realism and units:\n- In a rigid SPC/E water model, constraints remove the O–H stretching degree of freedom, so the highest frequency is typically associated with bending or librational modes. Without constraints, the highest frequency is dominated by the O–H stretch. To ensure scientific plausibility, use characteristic mode frequencies specified in wavenumbers (inverse centimeters) and convert each to angular frequency in radians per second using $\\omega = 2\\pi c\\,\\tilde{\\nu}$, where $c = 2.99792458 \\times 10^{10}$ centimeters per second and $\\tilde{\\nu}$ is the wavenumber in $\\text{cm}^{-1}$.\n- Express the final empirical critical time steps in femtoseconds (fs). One femtosecond equals $10^{-15}$ seconds.\n\nAlgorithmic requirements:\n- Implement the velocity Verlet update for the harmonic oscillator $x''(t) + \\omega^2 x(t) = 0$ with unit mass $m = 1$ and stiffness $k = \\omega^2$, so that the acceleration is $a(t) = -\\omega^2 x(t)$ at each step.\n- Initialize with $x(0) = \\varepsilon$ and $v(0) = 0$, where $\\varepsilon$ is a small amplitude (choose a reasonable value to avoid overflow and maintain numerical precision).\n- Define instability detection as the event when the absolute value of the position $|x|$ exceeds a fixed multiple of the initial amplitude at any step within the run. Choose a bound that is large enough to avoid false positives yet finite enough to detect true growth.\n- Use a scan that increases $\\Delta t$ until instability is detected, then refine the boundary via bisection to produce a robust estimate of $\\Delta t_{\\text{crit}}$.\n\nTest suite:\nUse the following set of wavenumbers $\\tilde{\\nu}$ in $\\text{cm}^{-1}$ to define five test cases that cover unconstrained and constrained scenarios, typical, high, and lower-frequency limits:\n1. $\\tilde{\\nu} = 3600$ (unconstrained O–H stretch, typical flexible model).\n2. $\\tilde{\\nu} = 4000$ (unconstrained O–H stretch, stiffer variant).\n3. $\\tilde{\\nu} = 1600$ (constrained highest mode approximated by bending).\n4. $\\tilde{\\nu} = 600$ (constrained highest mode approximated by libration).\n5. $\\tilde{\\nu} = 1800$ (constrained intermediate case).\n\nRequired outputs:\n- For each test case, compute $\\Delta t_{\\text{crit}}$ in femtoseconds and the dimensionless ratio $\\rho = \\Delta t_{\\text{crit}}\\,\\omega / 2$.\n- Round $\\Delta t_{\\text{crit}}$ to three decimal places (in fs) and $\\rho$ to six decimal places.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list should contain, for each test case in order, the pair $\\Delta t_{\\text{crit}}$ (fs) followed by $\\rho$, flattened into a single list. For example, for two cases the format would be $[\\Delta t_{\\text{crit,1}}, \\rho_1, \\Delta t_{\\text{crit,2}}, \\rho_2]$.\n\nConstraints:\n- The program must be fully self-contained, require no input, and rely only on the specified runtime environment.\n- The program must implement the empirical scan and bisection logic described above to determine $\\Delta t_{\\text{crit}}$ for each case, without using any closed-form stability condition in the decision logic.\n\nAnswer units:\n- Express $\\Delta t_{\\text{crit}}$ in femtoseconds, rounded to three decimal places.\n- Express $\\rho$ as a decimal rounded to six places.\n\nFinal output format:\n- A single line with a comma-separated list enclosed in square brackets as described above, aggregating all test cases in order: $[\\Delta t_{\\text{crit,1}},\\rho_1,\\Delta t_{\\text{crit,2}},\\rho_2,\\ldots,\\Delta t_{\\text{crit,5}},\\rho_5]$.",
            "solution": "The problem requires the empirical determination of the critical time step, $\\Delta t_{\\text{crit}}$, for the velocity Verlet integration scheme applied to a one-dimensional harmonic oscillator. This serves as a model for the highest frequency internal motion in a molecule, a crucial factor in selecting a stable time step for Molecular Dynamics (MD) simulations. The stability is to be evaluated for a set of characteristic vibrational frequencies, and the result is to be expressed as a dimensionless ratio that relates the critical time step to the oscillator's natural period.\n\nThe fundamental system under consideration is a harmonic oscillator, whose equation of motion is given by Newton's second law for a restoring force $F = -k x$:\n$$\nm \\frac{d^2x(t)}{dt^2} = -k x(t)\n$$\nwhere $m$ is the mass, $x(t)$ is the position, and $k$ is the force constant. By defining the angular frequency $\\omega = \\sqrt{k/m}$, this equation is rewritten in its canonical form:\n$$\n\\frac{d^2x(t)}{dt^2} + \\omega^2 x(t) = 0\n$$\nThe problem specifies using unit mass, $m=1$, so the acceleration at any time $t$ is simply $a(t) = -\\omega^2 x(t)$.\n\nFor the numerical integration, we employ the velocity Verlet algorithm, a symplectic and time-reversible integrator widely used in MD. Given the position $x_n$, velocity $v_n$, and acceleration $a_n = -\\omega^2 x_n$ at time step $n$, the state at step $n+1$ is calculated as follows, using a time step $\\Delta t$:\n\n1.  Calculate the velocity at the half-step:\n    $$\n    v_{n+1/2} = v_n + a_n \\frac{\\Delta t}{2}\n    $$\n2.  Update the position to the full-step:\n    $$\n    x_{n+1} = x_n + v_{n+1/2} \\Delta t\n    $$\n3.  Compute the new acceleration based on the new position:\n    $$\n    a_{n+1} = -\\omega^2 x_{n+1}\n    $$\n4.  Update the velocity to the full-step using the new acceleration:\n    $$\n    v_{n+1} = v_{n+1/2} + a_{n+1} \\frac{\\Delta t}{2}\n    $$\n\nThe primary task is to find the stability boundary of this algorithm. A numerical integration scheme is considered stable if small perturbations in the initial conditions lead to bounded, non-divergent solutions. For the harmonic oscillator, a stable numerical trajectory will have its total energy (and thus its amplitude) remain approximately constant, exhibiting small, bounded oscillations around the true conserved energy. An unstable trajectory will show a systematic, unbounded growth in energy and amplitude. The critical time step, $\\Delta t_{\\text{crit}}$, is the largest value of $\\Delta t$ for which the numerical solution remains bounded.\n\nTo empirically determine $\\Delta t_{\\text{crit}}$, we will implement a numerical search procedure for each given angular frequency $\\omega$. This procedure consists of two main parts: a simulation function and a search algorithm.\n\nThe simulation function, let's call it `is_stable(Δt, ω)`, will perform the following steps:\n1.  Initialize the system at $t=0$ with $x_0 = \\varepsilon$ and $v_0 = 0$. We can use a simple value like $\\varepsilon=1$ since the harmonic oscillator equation is linear.\n2.  Iterate the velocity Verlet algorithm for a large, fixed number of steps, $N$. A value of $N=20000$ is sufficient to allow any potential instability to manifest.\n3.  At each step $n$, check for divergence. Instability is declared if the position's magnitude, $|x_n|$, exceeds a predefined multiple of the initial amplitude, $|x_n| > M \\cdot \\varepsilon$. A multiplier of $M=100$ serves as a robust threshold for detecting exponential growth.\n4.  If the simulation completes all $N$ steps without the amplitude exceeding the threshold, the time step $\\Delta t$ is considered stable for the given $\\omega$. The function returns `True`. Otherwise, it returns `False`.\n\nThe search for $\\Delta t_{\\text{crit}}$ proceeds as follows:\n1.  **Bracketing:** We first find an interval $[\\Delta t_{\\text{lower}}, \\Delta t_{\\text{upper}}]$ that contains $\\Delta t_{\\text{crit}}$. This is done by starting with a very small, known-stable $\\Delta t$ (e.g., $10^{-18}\\,\\text{s}$) and repeatedly doubling it until `is_stable` returns `False`. The last stable value becomes $\\Delta t_{\\text{lower}}$ and the first unstable value becomes $\\Delta t_{\\text{upper}}$.\n2.  **Bisection:** With the stability boundary bracketed, we use the bisection method to refine our estimate of $\\Delta t_{\\text{crit}}$. We repeatedly test the midpoint $\\Delta t_{\\text{mid}} = (\\Delta t_{\\text{lower}} + \\Delta t_{\\text{upper}})/2$. If $\\Delta t_{\\text{mid}}$ is stable, we set $\\Delta t_{\\text{lower}} = \\Delta t_{\\text{mid}}$; otherwise, we set $\\Delta t_{\\text{upper}} = \\Delta t_{\\text{mid}}$. This process is repeated for a fixed number of iterations (e.g., $100$) to achieve high precision. The final value of $\\Delta t_{\\text{lower}}$ is our empirical $\\Delta t_{\\text{crit}}$.\n\nThe problem specifies five test cases defined by wavenumbers $\\tilde{\\nu}$ ($\\text{cm}^{-1}$): $\\{3600, 4000, 1600, 600, 1800\\}$. The angular frequency $\\omega$ for each case is calculated using the relation $\\omega = 2\\pi c \\tilde{\\nu}$, with the speed of light $c = 2.99792458 \\times 10^{10} \\text{ cm/s}$. The resulting $\\Delta t_{\\text{crit}}$ in seconds is converted to femtoseconds ($1\\,\\text{fs} = 10^{-15}\\,\\text{s}$).\n\nFinally, we compute the dimensionless ratio $\\rho = \\Delta t_{\\text{crit}}\\,\\omega / 2$. Analytically, the stability condition for the velocity Verlet algorithm applied to a harmonic oscillator is known to be $\\Delta t \\cdot \\omega \\le 2$. This implies that the theoretical critical time step is $\\Delta t_{\\text{crit}} = 2/\\omega$. Therefore, the theoretical value of the ratio is $\\rho = (2/\\omega) \\cdot \\omega / 2 = 1$. Our empirical procedure should yield values of $\\rho$ that are very close to $1$ for all test cases, providing a powerful validation of the implementation.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It determines the critical time step for a velocity Verlet integrator\n    applied to a harmonic oscillator model of molecular vibrations.\n    \"\"\"\n\n    # --- Constants and Simulation Parameters ---\n\n    # Speed of light in cm/s as specified\n    C_CMS = 2.99792458e10\n\n    # Simulation parameters for stability check\n    NUM_STEPS = 20000  # Number of steps to run the simulation\n    # Initial condition for position. Velocity is 0. Since the system is linear,\n    # the exact value is not critical, so 1.0 is convenient.\n    X_INITIAL = 1.0\n    # Instability threshold: if |x| exceeds this multiple of the initial\n    # amplitude, the simulation is considered unstable.\n    INSTABILITY_MULTIPLIER = 100.0\n    # Number of bisection iterations for refining the critical time step\n    BISECTION_ITERATIONS = 100\n\n    # Test suite: wavenumbers in cm^-1\n    wavenumbers_cm_inv = [3600.0, 4000.0, 1600.0, 600.0, 1800.0]\n\n    # --- Helper Functions ---\n\n    def get_omega(wavenumber_cm_inv):\n        \"\"\"Converts wavenumber (cm^-1) to angular frequency (rad/s).\"\"\"\n        return 2.0 * np.pi * C_CMS * wavenumber_cm_inv\n\n    def is_stable(delta_t, omega):\n        \"\"\"\n        Runs a velocity Verlet simulation for a given dt and omega to check for stability.\n        Returns True if stable, False if unstable.\n        \"\"\"\n        x = X_INITIAL\n        v = 0.0\n        a = -omega**2 * x\n        \n        instability_threshold = X_INITIAL * INSTABILITY_MULTIPLIER\n\n        for _ in range(NUM_STEPS):\n            # Velocity Verlet algorithm\n            v_half_step = v + 0.5 * a * delta_t\n            x = x + v_half_step * delta_t\n            a = -omega**2 * x\n            v = v_half_step + 0.5 * a * delta_t\n\n            if abs(x) > instability_threshold:\n                return False\n        \n        return True\n\n    def find_critical_dt(omega):\n        \"\"\"\n        Finds the critical time step dt_crit for a given omega using a search algorithm.\n        \"\"\"\n        # 1. Bracketing the root\n        # Start with a very small dt and double it until it becomes unstable.\n        dt_lower = 1e-18  # A small, known-stable step in seconds\n        \n        # Check if the initial guess is stable. If not, this is an issue.\n        if not is_stable(dt_lower, omega):\n            # This case should not be reached with a sufficiently small initial dt.\n            raise RuntimeError(\"Initial time step is unstable.\")\n\n        dt_upper = dt_lower\n        while is_stable(dt_upper, omega):\n            dt_lower = dt_upper\n            dt_upper *= 2.0\n        \n        # Now we have a bracket [dt_lower, dt_upper] where lower is stable and upper is not.\n\n        # 2. Bisection to refine dt_crit\n        for _ in range(BISECTION_ITERATIONS):\n            dt_mid = (dt_lower + dt_upper) / 2.0\n            if is_stable(dt_mid, omega):\n                dt_lower = dt_mid\n            else:\n                dt_upper = dt_mid\n        \n        # The critical time step is the largest value that remains stable\n        return dt_lower\n\n    # --- Main Logic ---\n\n    results = []\n    for nu_tilde in wavenumbers_cm_inv:\n        # 1. Calculate angular frequency\n        omega = get_omega(nu_tilde)\n        \n        # 2. Empirically find the critical time step in seconds\n        dt_crit_s = find_critical_dt(omega)\n        \n        # 3. Convert dt_crit to femtoseconds and round\n        dt_crit_fs = dt_crit_s * 1e15\n        \n        # 4. Calculate the dimensionless ratio rho\n        rho = dt_crit_s * omega / 2.0\n        \n        # 5. Round results to the required precision\n        dt_crit_fs_rounded = round(dt_crit_fs, 3)\n        rho_rounded = round(rho, 6)\n        \n        results.append(dt_crit_fs_rounded)\n        results.append(rho_rounded)\n\n    # --- Final Output ---\n    # Convert all results to string for joining\n    str_results = [f\"{x:.3f}\" if i % 2 == 0 else f\"{x:.6f}\" for i, x in enumerate(results)]\n    print(f\"[{','.join(str_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While avoiding catastrophic numerical blow-ups is essential, a successful simulation must also be physically faithful. A time step that is technically stable may still be too large to accurately capture the subtle, long-term dynamics of a complex nonlinear system. This exercise delves into this crucial distinction by using the classic Fermi-Pasta-Ulam-Tsingou (FPU) chain to investigate how $\\Delta t$ affects the timescale of energy thermalization, a key physical property that emerges from nonlinearity. You will learn to use quantitative diagnostics to assess not just stability, but the *fidelity* of your simulation. ",
            "id": "3455232",
            "problem": "Consider a one-dimensional Fermi–Pasta–Ulam–Tsingou chain of $N$ point masses with fixed boundary conditions at both ends. Each interior mass has position $x_i(t)$ for $i \\in \\{1,\\dots,N\\}$. The dynamics are governed by Newton's Second Law of Motion and the potential energy is a sum of a linear term and a cubic nonlinear term. Let the mass of each particle be $m$ and the linear spring constant be $k$. Let the cubic nonlinearity coefficient be $\\alpha$. Define the bond extension $\\Delta_i(t) = x_{i+1}(t) - x_{i}(t)$ for $i \\in \\{0,\\dots,N\\}$ with $x_0(t) = 0$ and $x_{N+1}(t) = 0$. The total potential energy is\n$$\nV(x) = \\sum_{i=0}^{N} \\left( \\frac{k}{2} \\Delta_i^2 + \\frac{\\alpha}{3} \\Delta_i^3 \\right),\n$$\nand the equations of motion are\n$$\nm \\frac{d^2 x_i}{dt^2} = F_i(x),\n$$\nwith the force on site $i$ given by\n$$\nF_i(x) = k\\left(\\Delta_i - \\Delta_{i-1}\\right) + \\alpha \\left(\\Delta_i^2 - \\Delta_{i-1}^2\\right),\n$$\nfor $i \\in \\{1,\\dots,N\\}$ and the fixed boundary conditions imply $x_0 = 0$ and $x_{N+1} = 0$.\n\nIn a purely linear chain ($\\alpha = 0$), the normal modes are sinusoidal with frequencies\n$$\n\\omega_r = 2 \\sqrt{\\frac{k}{m}} \\sin\\left(\\frac{r \\pi}{2 (N+1)}\\right), \\quad r \\in \\{1,\\dots,N\\},\n$$\nand the orthonormal mode shapes\n$$\n\\phi_{r,i} = \\sqrt{\\frac{2}{N+1}} \\sin\\left(\\frac{r \\pi i}{N+1}\\right).\n$$\nIn the nonlinear chain ($\\alpha \\neq 0$), these linear modes can still be used to define a diagnostic of energy sharing by projecting the instantaneous configuration and velocity onto the linear modes. Define $a_r(t) = \\sum_{i=1}^{N} \\phi_{r,i} x_i(t)$ and $p_r(t) = \\sum_{i=1}^{N} \\phi_{r,i} \\dot{x}_i(t)$, and the per-mode energies\n$$\nE_r(t) = \\frac{1}{2}\\left(p_r(t)^2 + \\omega_r^2 a_r(t)^2\\right), \\quad r \\in \\{1,\\dots,N\\}.\n$$\nLet $E_{\\mathrm{tot}}(t) = \\sum_{r=1}^{N} E_r(t)$ and the normalized energy distribution across modes be $p_r(t) = \\frac{E_r(t)}{E_{\\mathrm{tot}}(t)}$. Define the entropy of the modal energy distribution by $H(t) = - \\sum_{r=1}^{N} p_r(t) \\ln p_r(t)$ and the normalized equipartition indicator\n$$\nQ(t) = \\frac{\\exp\\left(H(t)\\right)}{N}.\n$$\nThis indicator satisfies $Q(t) = 1$ when energy is shared equally among all $N$ modes, and $Q(t) \\ll 1$ when energy is localized in a few modes.\n\nConsider discrete-time numerical integration schemes for these equations, such as the Velocity Verlet method and the Fourth-Order Runge–Kutta (RK4) method. The time step $\\Delta t$ affects both numerical stability and the preservation of qualitative features such as metastable energy sharing in the nonlinear chain. Your task is to implement a program that, for several parameter sets, determines the smallest $\\Delta t$ at which the observed timescale of equipartition changes nonphysically relative to a baseline with a small $\\Delta t$. Formally, for each parameter set, compute the equipartition time $T_{\\mathrm{eq}}(\\Delta t)$ defined as the first time $t$ at which $Q(t)$ exceeds a fixed threshold $Q_{\\mathrm{th}}$, within a simulation time horizon $T_{\\max}$. Use the smallest $\\Delta t$ in a given grid as the baseline $\\Delta t_{\\min}$ and its equipartition time $T_{\\mathrm{eq}}(\\Delta t_{\\min})$ as the reference. For larger $\\Delta t$ values in the grid, declare a nonphysical change when the ratio\n$$\nR(\\Delta t) = \\frac{T_{\\mathrm{eq}}(\\Delta t)}{T_{\\mathrm{eq}}(\\Delta t_{\\min})}\n$$\nfalls outside a tolerance band $\\left[\\frac{1}{\\rho}, \\rho\\right]$ for a prescribed factor $\\rho > 1$. Report the smallest $\\Delta t$ in the grid at which this occurs. If no $\\Delta t$ in the grid causes such a deviation, report $-1$.\n\nUse nondimensional units: set $m = 1$ and $k = 1$. All times, including $\\Delta t$ and $T_{\\mathrm{eq}}$, must be expressed in these natural time units and reported as floating-point numbers. Angles inside trigonometric functions are in radians. The equipartition threshold must be set to $Q_{\\mathrm{th}} = 0.75$, and the tolerance factor must be set to $\\rho = 1.5$. The initial condition for all test cases must place all energy into the first linear mode with amplitude $A$ by setting $x_i(0) = A \\, \\phi_{1,i}$ and $\\dot{x}_i(0) = 0$.\n\nYour program must implement both the Velocity Verlet and Fourth-Order Runge–Kutta (RK4) integrators and use them as specified per test case. The simulation must compute $Q(t)$ at regular sampling intervals and determine $T_{\\mathrm{eq}}$ as the first crossing time of $Q(t) \\ge Q_{\\mathrm{th}}$ or set $T_{\\mathrm{eq}} = T_{\\max}$ if no crossing occurs by time $T_{\\max}$.\n\nTest Suite:\nFor comprehensive coverage, use the following three parameter sets. For each case, search over the specified grid of $\\Delta t$ values in ascending order and find the smallest $\\Delta t$ where $R(\\Delta t)$ exits the tolerance band; if none exit, return $-1$.\n\nCase $1$ (general behavior, symplectic scheme):\n- $N = 8$\n- $\\alpha = 0.25$\n- $A = 0.20$\n- Integrator: Velocity Verlet\n- $T_{\\max} = 200$\n- $\\Delta t$ grid: $\\{0.0025, 0.005, 0.01, 0.02, 0.04\\}$\n\nCase $2$ (larger chain, non-symplectic scheme):\n- $N = 16$\n- $\\alpha = 0.10$\n- $A = 0.10$\n- Integrator: Fourth-Order Runge–Kutta (RK4)\n- $T_{\\max} = 200$\n- $\\Delta t$ grid: $\\{0.00125, 0.0025, 0.005, 0.01, 0.02\\}$\n\nCase $3$ (weak nonlinearity, boundary case):\n- $N = 8$\n- $\\alpha = 0.05$\n- $A = 0.05$\n- Integrator: Velocity Verlet\n- $T_{\\max} = 150$\n- $\\Delta t$ grid: $\\{0.005, 0.01, 0.02\\}$\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for the three cases in the order above. Each entry must be the smallest $\\Delta t$ in the case’s grid that causes a nonphysical change according to the criterion, or $-1$ if none do. For example, the output must look like\n$[d_1,d_2,d_3]$\nwith $d_1$, $d_2$, and $d_3$ being floating-point values in time units or the integer $-1$.",
            "solution": "The problem requires an analysis of the numerical stability and physical fidelity of simulations of a one-dimensional Fermi–Pasta–Ulam–Tsingou (FPU) chain. Specifically, it asks to determine the largest numerical integration time step, $\\Delta t$, at which the computed timescale of energy equipartition deviates nonphysically from a high-fidelity baseline simulation.\n\nThe system consists of a chain of $N$ particles of mass $m$, connected by nonlinear springs. The ends of the chain are fixed, corresponding to boundary conditions $x_0(t) = 0$ and $x_{N+1}(t) = 0$. The potential energy $V$ of the system is given by the sum of harmonic and cubic terms for each bond extension, $\\Delta_i = x_{i+1} - x_i$:\n$$\nV(x) = \\sum_{i=0}^{N} \\left( \\frac{k}{2} \\Delta_i^2 + \\frac{\\alpha}{3} \\Delta_i^3 \\right)\n$$\nwhere $k$ is the linear spring constant and $\\alpha$ is the coefficient of the cubic nonlinearity. The force on the $i$-th particle is derived from the potential, $F_i = -\\frac{\\partial V}{\\partial x_i}$, which yields:\n$$\nF_i(x) = k\\left(\\Delta_i - \\Delta_{i-1}\\right) + \\alpha \\left(\\Delta_i^2 - \\Delta_{i-1}^2\\right), \\quad \\text{for } i \\in \\{1, \\dots, N\\}\n$$\nThe dynamics are governed by Newton's second law, $m \\frac{d^2 x_i}{dt^2} = F_i(x)$. For this analysis, we use nondimensional units where $m=1$ and $k=1$.\n\nTo diagnose the system's state, we project its configuration and velocity onto the linear normal modes of the corresponding harmonic chain ($\\alpha=0$). The frequencies $\\omega_r$ and orthonormal mode shapes $\\phi_{r,i}$ for these modes are:\n$$\n\\omega_r = 2 \\sqrt{\\frac{k}{m}} \\sin\\left(\\frac{r \\pi}{2 (N+1)}\\right), \\quad \\phi_{r,i} = \\sqrt{\\frac{2}{N+1}} \\sin\\left(\\frac{r \\pi i}{N+1}\\right)\n$$\nfor modes $r \\in \\{1,\\dots,N\\}$ and particles $i \\in \\{1,\\dots,N\\}$. The modal amplitudes $a_r(t)$ and modal momenta $p_r(t)$ are calculated by projection:\n$$\na_r(t) = \\sum_{i=1}^{N} \\phi_{r,i} x_i(t), \\quad p_r(t) = \\sum_{i=1}^{N} \\phi_{r,i} \\dot{x}_i(t)\n$$\nThe energy associated with each linear mode is then approximated as:\n$$\nE_r(t) = \\frac{1}{2}\\left(p_r(t)^2 + \\omega_r^2 a_r(t)^2\\right)\n$$\nThe total modal energy is $E_{\\mathrm{tot}}(t) = \\sum_{r=1}^{N} E_r(t)$. The distribution of energy is described by the normalized per-mode energies $p_r(t) = \\frac{E_r(t)}{E_{\\mathrm{tot}}(t)}$.\n\nThe degree of energy sharing, or thermalization, is quantified using an entropy-based measure. The modal energy entropy is $H(t) = - \\sum_{r=1}^{N} p_r(t) \\ln p_r(t)$. This leads to the normalized equipartition indicator, $Q(t)$:\n$$\nQ(t) = \\frac{\\exp\\left(H(t)\\right)}{N}\n$$\nThis indicator ranges from $Q(t) \\approx 1/N$ when energy is concentrated in a single mode to $Q(t)=1$ at perfect equipartition (energy shared equally among all $N$ modes). The equipartition time, $T_{\\mathrm{eq}}(\\Delta t)$, is defined as the first time $t$ at which $Q(t)$ surpasses a threshold $Q_{\\mathrm{th}} = 0.75$.\n\nThe core of the problem is to investigate how $T_{\\mathrm{eq}}$ is affected by the choice of integration time step $\\Delta t$. We use the simulation with the smallest time step, $\\Delta t_{\\min}$, from a given grid to establish a baseline equipartition time, $T_{\\mathrm{eq}}(\\Delta t_{\\min})$. A larger time step $\\Delta t$ is considered to produce nonphysical results if the ratio $R(\\Delta t) = \\frac{T_{\\mathrm{eq}}(\\Delta t)}{T_{\\mathrm{eq}}(\\Delta t_{\\min})}$ falls outside the tolerance band $[\\frac{1}{\\rho}, \\rho]$, where the tolerance factor is $\\rho = 1.5$. We must find the smallest $\\Delta t$ from the grid for which this condition is met.\n\nThe numerical integration of the equations of motion is performed using two specified methods:\n$1$. The **Velocity Verlet** method, a second-order symplectic integrator well-suited for Hamiltonian systems due to its long-term energy stability. For a step from time $t$ to $t+\\Delta t$, with positions $x(t)$, velocities $v(t)$, and accelerations $a(t) = F(x(t))/m$, the algorithm is:\n   a. $v(t + \\frac{\\Delta t}{2}) = v(t) + a(t) \\frac{\\Delta t}{2}$\n   b. $x(t + \\Delta t) = x(t) + v(t + \\frac{\\Delta t}{2}) \\Delta t$\n   c. Calculate $a(t + \\Delta t)$ using the new positions $x(t + \\Delta t)$.\n   d. $v(t + \\Delta t) = v(t + \\frac{\\Delta t}{2}) + a(t + \\Delta t) \\frac{\\Delta t}{2}$\n\n$2$. The **Fourth-Order Runge–Kutta (RK4)** method, a general-purpose, high-accuracy, but non-symplectic integrator. For a system of first-order ODEs $\\frac{dY}{dt} = f(t, Y)$, where $Y = [x_1, \\dots, x_N, \\dot{x}_1, \\dots, \\dot{x}_N]$, one step is:\n   a. $k_1 = \\Delta t \\cdot f(t, Y(t))$\n   b. $k_2 = \\Delta t \\cdot f(t + \\frac{\\Delta t}{2}, Y(t) + \\frac{k_1}{2})$\n   c. $k_3 = \\Delta t \\cdot f(t + \\frac{\\Delta t}{2}, Y(t) + \\frac{k_2}{2})$\n   d. $k_4 = \\Delta t \\cdot f(t + \\Delta t, Y(t) + k_3)$\n   e. $Y(t + \\Delta t) = Y(t) + \\frac{1}{6}(k_1 + 2k_2 + 2k_3 + k_4)$\n\nThe overall procedure for each test case is as follows:\n$1$. Set up the system with the specified parameters ($N, \\alpha, A$) and constants ($m=1, k=1$). The initial condition is $x_i(0) = A \\phi_{1,i}$ and $\\dot{x}_i(0) = 0$, populating only the lowest-frequency mode.\n$2$. Pre-compute the mode shapes $\\phi_{r,i}$ and squared frequencies $\\omega_r^2$.\n$3$. For each $\\Delta t$ in the provided grid, run a simulation up to $T_{\\max}$ using the specified integrator.\n$4$. In each simulation, monitor $Q(t)$ and record the equipartition time $T_{\\mathrm{eq}}(\\Delta t)$. If $Q(t)$ does not reach $Q_{\\mathrm{th}}$, set $T_{\\mathrm{eq}}(\\Delta t) = T_{\\max}$.\n$5$. Identify the baseline $T_{\\mathrm{eq}}(\\Delta t_{\\min})$ from the run with the smallest $\\Delta t$.\n$6$. Iterate through the remaining $\\Delta t$ values in ascending order. Calculate the ratio $R(\\Delta t)$. The first $\\Delta t$ for which $R(\\Delta t) < 1/1.5$ or $R(\\Delta t) > 1.5$ is the answer for that case. If no such $\\Delta t$ is found, the answer is $-1$.\n\nThis procedure is implemented for the three test cases provided. The calculations are vectorized using `numpy` for efficiency, particularly for the force evaluation and the modal projections.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function to run all test cases and print the final result.\n    \"\"\"\n\n    def calculate_forces(x, alpha, k, n_particles):\n        \"\"\"\n        Calculates the forces on each particle in the FPU chain.\n        \"\"\"\n        x_ext = np.zeros(n_particles + 2)\n        x_ext[1:-1] = x\n        \n        delta = np.diff(x_ext)\n        delta_sq = delta**2\n        \n        forces = k * (delta[1:] - delta[:-1]) + alpha * (delta_sq[1:] - delta_sq[:-1])\n        return forces\n\n    def velocity_verlet_step(x, v, dt, alpha, k, n_particles):\n        \"\"\"\n        Performs a single step of the Velocity Verlet algorithm.\n        m=1 is assumed.\n        \"\"\"\n        a = calculate_forces(x, alpha, k, n_particles)\n        v_half = v + 0.5 * a * dt\n        x_new = x + v_half * dt\n        a_new = calculate_forces(x_new, alpha, k, n_particles)\n        v_new = v_half + 0.5 * a_new * dt\n        return x_new, v_new\n\n    def rk4_step(x, v, dt, alpha, k, n_particles):\n        \"\"\"\n        Performs a single step of the Fourth-Order Runge–Kutta algorithm.\n        m=1 is assumed.\n        \"\"\"\n        def f(pos, vel):\n            dxdt = vel\n            dvdt = calculate_forces(pos, alpha, k, n_particles)\n            return dxdt, dvdt\n\n        k1_x, k1_v = f(x, v)\n        k2_x, k2_v = f(x + 0.5 * dt * k1_x, v + 0.5 * dt * k1_v)\n        k3_x, k3_v = f(x + 0.5 * dt * k2_x, v + 0.5 * dt * k2_v)\n        k4_x, k4_v = f(x + dt * k3_x, v + dt * k3_v)\n\n        x_new = x + (dt / 6.0) * (k1_x + 2*k2_x + 2*k3_x + k4_x)\n        v_new = v + (dt / 6.0) * (k1_v + 2*k2_v + 2*k3_v + k4_v)\n        return x_new, v_new\n\n    def calculate_Q(x, v, phi_matrix, omega_sq_vec, n_particles):\n        \"\"\"\n        Calculates the equipartition indicator Q.\n        \"\"\"\n        # Modal projection\n        a = phi_matrix @ x\n        p = phi_matrix @ v\n        \n        # Modal energies\n        E_r = 0.5 * (p**2 + omega_sq_vec * a**2)\n        E_tot = np.sum(E_r)\n        \n        if E_tot < 1e-12:\n            return 1.0 / n_particles\n\n        # Normalized energy distribution\n        p_r_norm = E_r / E_tot\n        \n        # Entropy\n        p_r_positive = p_r_norm[p_r_norm > 1e-12]\n        H = -np.sum(p_r_positive * np.log(p_r_positive))\n        \n        # Equipartition indicator\n        Q = np.exp(H) / n_particles\n        return Q\n\n    def get_equip_time(params):\n        \"\"\"\n        Runs a single simulation and finds the equipartition time.\n        \"\"\"\n        N = params['N']\n        alpha = params['alpha']\n        A = params['A']\n        integrator_name = params['integrator']\n        T_max = params['T_max']\n        dt = params['dt']\n        Q_th = 0.75\n        m, k = 1.0, 1.0\n\n        # Pre-compute linear modes\n        r_vals = np.arange(1, N + 1)\n        i_vals = np.arange(1, N + 1)\n        \n        omega_vec = 2 * np.sqrt(k / m) * np.sin(r_vals * np.pi / (2 * (N + 1)))\n        omega_sq_vec = omega_vec**2\n        \n        phi_matrix = np.sqrt(2 / (N + 1)) * np.sin(np.outer(r_vals, i_vals * np.pi / (N + 1)))\n        \n        # Initial conditions\n        x = A * phi_matrix[0, :]\n        v = np.zeros(N)\n\n        n_steps = int(T_max / dt)\n        \n        if integrator_name == \"Velocity Verlet\":\n            integrator_step = velocity_verlet_step\n        else: # RK4\n            integrator_step = rk4_step\n        \n        for step in range(n_steps):\n            x, v = integrator_step(x, v, dt, alpha, k, N)\n            current_time = (step + 1) * dt\n            \n            # Sample Q at each step\n            q_val = calculate_Q(x, v, phi_matrix, omega_sq_vec, N)\n            \n            if q_val >= Q_th:\n                return current_time\n        \n        return T_max\n\n    def find_critical_dt(case_params):\n        \"\"\"\n        For a given test case, finds the smallest dt that causes non-physical change.\n        \"\"\"\n        dt_grid = case_params['dt_grid']\n        rho = 1.5\n        \n        T_eq_results = {}\n        for dt in dt_grid:\n            sim_params = case_params.copy()\n            sim_params['dt'] = dt\n            T_eq_results[dt] = get_equip_time(sim_params)\n\n        dt_min = dt_grid[0]\n        T_eq_baseline = T_eq_results[dt_min]\n        \n        if T_eq_baseline == 0: # Should not happen with given ICs, but for robustness\n            return -1.0\n            \n        for dt in dt_grid[1:]:\n            T_eq_current = T_eq_results[dt]\n            ratio = T_eq_current / T_eq_baseline\n            if ratio > rho or ratio < 1.0 / rho:\n                return dt\n                \n        return -1.0\n\n    test_cases = [\n        {\n            \"N\": 8, \"alpha\": 0.25, \"A\": 0.20, \"integrator\": \"Velocity Verlet\",\n            \"T_max\": 200, \"dt_grid\": [0.0025, 0.005, 0.01, 0.02, 0.04]\n        },\n        {\n            \"N\": 16, \"alpha\": 0.10, \"A\": 0.10, \"integrator\": \"Fourth-Order Runge–Kutta (RK4)\",\n            \"T_max\": 200, \"dt_grid\": [0.00125, 0.0025, 0.005, 0.01, 0.02]\n        },\n        {\n            \"N\": 8, \"alpha\": 0.05, \"A\": 0.05, \"integrator\": \"Velocity Verlet\",\n            \"T_max\": 150, \"dt_grid\": [0.005, 0.01, 0.02]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        critical_dt = find_critical_dt(case)\n        results.append(critical_dt)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "To overcome the stringent time step limitations imposed by fast vibrations, simulators often turn to multiple time-step (MTS) methods like the Reference System Propagator Algorithm (RESPA). These powerful techniques use different time steps for different force components, but they introduce their own unique stability challenges, most notably resonance instabilities. In this practice, you will use the elegant formalism of propagator matrices to analytically investigate the stability of a RESPA integrator, learning how to predict and understand the resonance conditions where the interplay between the chosen time steps and the system's natural frequencies can lead to non-physical energy growth. ",
            "id": "3455272",
            "problem": "Consider a single Cartesian degree of freedom with coordinate $q$ and momentum $p$ and mass $m$, subject to a potential split into a fast and a slow quadratic component given by $U(q) = \\tfrac{1}{2} k_f q^2 + \\tfrac{1}{2} k_s q^2$, where $k_f \\gg k_s$. Define the fast angular frequency $\\omega_f = \\sqrt{k_f/m}$ and the slow angular frequency $\\omega_s = \\sqrt{k_s/m}$, and write the ratio $r = \\omega_f/\\omega_s$. The full system obeys Newton's second law $m \\ddot{q} = -\\partial U/\\partial q$ and Hamilton's equations $\\dot{q} = \\partial H/\\partial p$, $\\dot{p} = -\\partial H/\\partial q$ with $H = \\tfrac{p^2}{2m} + U(q)$.\n\nA multiple time-step splitting integrator of the Reference System Propagator Algorithm (RESPA) type advances the state over one outer step of size $\\Delta t_{\\text{outer}}$ by:\n- Applying a slow force half-kick, then\n- Performing $N$ inner substeps that integrate only the fast force, and finally\n- Applying a slow force half-kick again.\nThe inner substep size is $\\Delta t_{\\text{inner}} = \\Delta t_{\\text{outer}}/N$. Each operation is linear for a quadratic potential and can be represented by a $2 \\times 2$ matrix acting on the column vector $(q,p)^\\top$.\n\nYour tasks are:\n1. Starting from $m \\ddot{q} = -k_f q - k_s q$, derive, in terms of $m$, $k_f$, $k_s$, and the time increment, the linear map for a slow half-kick that advances $(q,p)$ by $\\Delta t_{\\text{outer}}/2$ using only the slow force, and the linear map for one inner substep that advances $(q,p)$ by $\\Delta t_{\\text{inner}}$ using only the fast force via a symmetric position Verlet update.\n2. Compose these maps to obtain the single-step propagator matrix $M$ for one full outer step of the RESPA scheme described above. Explain how to use the eigenvalues of $M$ to define linear stability over one outer step. Specifically, state a precise spectral condition on the eigenvalues of $M$ that must hold to avoid exponential growth of $(q,p)$ norms in the linearized map.\n3. Implement a program that, for each parameter set in the test suite below, constructs $M$, computes its eigenvalues, and returns a Boolean indicating stability of the one-step map, as a function of the ratio $r = \\omega_f/\\omega_s$ and outer time step $\\Delta t_{\\text{outer}}$.\n\nUse the following test suite, where time must be expressed in seconds ($s$), mass in kilograms ($\\mathrm{kg}$), and spring constants in newtons per meter ($\\mathrm{N}/\\mathrm{m}$). For each case, compute the Boolean stability result defined in task $2$:\n\n- Case $1$: $m = 1$ $\\mathrm{kg}$, $k_f = 10^4$ $\\mathrm{N}/\\mathrm{m}$, $k_s = 10^2$ $\\mathrm{N}/\\mathrm{m}$, $N = 10$, $\\Delta t_{\\text{outer}} = 0.020$ $s$.\n- Case $2$: $m = 1$ $\\mathrm{kg}$, $k_f = 10^4$ $\\mathrm{N}/\\mathrm{m}$, $k_s = 10^2$ $\\mathrm{N}/\\mathrm{m}$, $N = 10$, $\\Delta t_{\\text{outer}} = \\pi/100$ $s$.\n- Case $3$: $m = 1$ $\\mathrm{kg}$, $k_f = 10^4$ $\\mathrm{N}/\\mathrm{m}$, $k_s = 1$ $\\mathrm{N}/\\mathrm{m}$, $N = 10$, $\\Delta t_{\\text{outer}} = \\pi/100$ $s$.\n- Case $4$: $m = 1$ $\\mathrm{kg}$, $k_f = 10^4$ $\\mathrm{N}/\\mathrm{m}$, $k_s = 10^2$ $\\mathrm{N}/\\mathrm{m}$, $N = 10$, $\\Delta t_{\\text{outer}} = 0.005$ $s$.\n- Case $5$: $m = 1$ $\\mathrm{kg}$, $k_f = 10^4$ $\\mathrm{N}/\\mathrm{m}$, $k_s = 10^2$ $\\mathrm{N}/\\mathrm{m}$, $N = 10$, $\\Delta t_{\\text{outer}} = 0.200$ $s$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[result_1,result_2,result_3,result_4,result_5]$), where each $result_i$ is either $\\mathrm{True}$ or $\\mathrm{False}$ according to the stability criterion devised in task $2$.",
            "solution": "### Problem Validation\n\n**Step 1: Extract Givens**\n\n- **System:** A single Cartesian degree of freedom with coordinate $q$, momentum $p$, and mass $m$.\n- **Potential Energy:** $U(q) = \\tfrac{1}{2} k_f q^2 + \\tfrac{1}{2} k_s q^2$, with $k_f \\gg k_s$.\n- **Forces:** Fast force $F_f = -k_f q$, Slow force $F_s = -k_s q$. Total force $F = - (k_f + k_s) q$.\n- **Frequencies:** Fast angular frequency $\\omega_f = \\sqrt{k_f/m}$, slow angular frequency $\\omega_s = \\sqrt{k_s/m}$. Ratio $r = \\omega_f/\\omega_s$.\n- **Hamiltonian:** $H = \\tfrac{p^2}{2m} + U(q)$.\n- **Integrator:** A multiple time-step RESPA integrator.\n    - Outer time step: $\\Delta t_{\\text{outer}}$.\n    - Inner substeps: $N$.\n    - Inner time step: $\\Delta t_{\\text{inner}} = \\Delta t_{\\text{outer}}/N$.\n    - Algorithm sequence over one outer step:\n        1. Half-step kick with slow force over $\\Delta t_{\\text{outer}}/2$.\n        2. $N$ inner substeps, each integrating the fast force over $\\Delta t_{\\text{inner}}$ using a symmetric position Verlet update.\n        3. Half-step kick with slow force over $\\Delta t_{\\text{outer}}/2$.\n- **Representation:** Each step is a linear map (a $2 \\times 2$ matrix) acting on the state vector $(q, p)^\\top$.\n\n**Step 2: Validate Using Extracted Givens**\n\n- **Scientifically Grounded:** The problem is firmly rooted in the classical mechanics of harmonic oscillators and the numerical analysis of ordinary differential equations. RESPA is a standard and widely used algorithm in molecular dynamics for systems with multiple time scales. The model and the algorithm are scientifically valid.\n- **Well-Posed:** The problem provides all necessary parameters and definitions. The tasks are specific and mathematical: derive propagator matrices, compose them, define a stability criterion based on their spectral properties, and apply this to a given set of parameters. A unique, stable, and meaningful solution exists.\n- **Objective:** The problem is stated in precise, objective mathematical language, free from subjective or ambiguous terms.\n\nThe problem does not exhibit any of the flaws listed in the validation checklist (e.g., scientific unsoundness, incompleteness, ambiguity). It is a standard and well-formulated problem in computational physics.\n\n**Step 3: Verdict and Action**\n\nThe problem is valid. A complete solution will be provided.\n\n---\n\n### Solution\n\nThe solution proceeds by addressing the three tasks outlined in the problem statement. We represent the state of the system by the column vector $\\mathbf{x} = (q, p)^\\top$. Each step of the integrator is a linear transformation $\\mathbf{x}_{\\text{new}} = M_i \\mathbf{x}_{\\text{old}}$ for some matrix $M_i$.\n\n#### Task 1: Derivation of Linear Maps\n\n**1. Linear Map for the Slow Force Half-Kick**\n\nThe slow force kick is governed by the equations of motion involving only the slow potential, $U_s(q) = \\tfrac{1}{2} k_s q^2$. The corresponding Hamiltonian is $H_s = \\tfrac{p^2}{2m} + U_s(q)$. For a pure potential-dependent term, Hamilton's equations are $\\dot{q} = 0$ and $\\dot{p} = -\\partial U_s/\\partial q = -k_s q$.\n\nIn an operator splitting context, this \"kick\" step updates the momentum based on the force at the current position, while leaving the position unchanged. Over a time interval $\\Delta t$, the transformation is:\n$$q(t_0 + \\Delta t) = q(t_0)$$\n$$p(t_0 + \\Delta t) = p(t_0) + \\int_{t_0}^{t_0+\\Delta t} (-k_s q(\\tau)) d\\tau = p(t_0) - k_s q(t_0) \\Delta t$$\n\nFor a half-kick of duration $\\Delta t = \\Delta t_{\\text{outer}}/2$, the transformation is:\n$$q_{\\text{new}} = q_{\\text{old}}$$\n$$p_{\\text{new}} = p_{\\text{old}} - k_s q_{\\text{old}} \\frac{\\Delta t_{\\text{outer}}}{2}$$\n\nIn matrix form, this is $\\mathbf{x}_{\\text{new}} = M_{\\text{kick,s}} \\mathbf{x}_{\\text{old}}$, where the slow-kick propagator $M_{\\text{kick,s}}$ is:\n$$M_{\\text{kick,s}} = \\begin{pmatrix} 1 & 0 \\\\ -k_s \\frac{\\Delta t_{\\text{outer}}}{2} & 1 \\end{pmatrix}$$\n\n**2. Linear Map for the Fast Force Inner Substep (Position Verlet)**\n\nThe inner substeps integrate the dynamics due to the fast potential, $U_f(q) = \\tfrac{1}{2} k_f q^2$, over a time step $\\Delta t_{\\text{inner}}$. The equation of motion is $m\\ddot{q} = -k_f q$. The symmetric position Verlet update for a state $(q_n, p_n)$ is a composition of three steps:\n1. Half-step momentum kick: $p_{n+1/2} = p_n + F(q_n) \\frac{\\Delta t_{\\text{inner}}}{2} = p_n - k_f q_n \\frac{\\Delta t_{\\text{inner}}}{2}$.\n2. Full-step position drift: $q_{n+1} = q_n + \\frac{p_{n+1/2}}{m} \\Delta t_{\\text{inner}} = q_n + \\frac{1}{m} \\left( p_n - k_f q_n \\frac{\\Delta t_{\\text{inner}}}{2} \\right) \\Delta t_{\\text{inner}} = \\left(1 - \\frac{k_f \\Delta t_{\\text{inner}}^2}{2m}\\right)q_n + \\frac{\\Delta t_{\\text{inner}}}{m}p_n$.\n3. Half-step momentum kick: $p_{n+1} = p_{n+1/2} + F(q_{n+1}) \\frac{\\Delta t_{\\text{inner}}}{2} = p_{n+1/2} - k_f q_{n+1} \\frac{\\Delta t_{\\text{inner}}}{2}$.\n\nSubstituting the expressions for $p_{n+1/2}$ and $q_{n+1}$:\n$$p_{n+1} = \\left(p_n - k_f q_n \\frac{\\Delta t_{\\text{inner}}}{2}\\right) - k_f \\left[ \\left(1 - \\frac{k_f \\Delta t_{\\text{inner}}^2}{2m}\\right)q_n + \\frac{\\Delta t_{\\text{inner}}}{m}p_n \\right] \\frac{\\Delta t_{\\text{inner}}}{2}$$\n$$p_{n+1} = p_n - k_f q_n \\frac{\\Delta t_{\\text{inner}}}{2} - k_f q_n \\frac{\\Delta t_{\\text{inner}}}{2} + \\frac{k_f^2 \\Delta t_{\\text{inner}}^3}{4m} q_n - \\frac{k_f \\Delta t_{\\text{inner}}^2}{2m} p_n$$\n$$p_{n+1} = -k_f \\Delta t_{\\text{inner}} \\left( 1 - \\frac{k_f \\Delta t_{\\text{inner}}^2}{4m} \\right) q_n + \\left( 1 - \\frac{k_f \\Delta t_{\\text{inner}}^2}{2m} \\right) p_n$$\n\nThe complete transformation $\\mathbf{x}_{n+1} = M_{\\text{inner}} \\mathbf{x}_n$ is thus given by the matrix:\n$$M_{\\text{inner}} = \\begin{pmatrix} 1 - \\frac{k_f \\Delta t_{\\text{inner}}^2}{2m} & \\frac{\\Delta t_{\\text{inner}}}{m} \\\\ -k_f \\Delta t_{\\text{inner}} \\left(1 - \\frac{k_f \\Delta t_{\\text{inner}}^2}{4m}\\right) & 1 - \\frac{k_f \\Delta t_{\\text{inner}}^2}{2m} \\end{pmatrix}$$\nThis can be expressed using the fast angular frequency $\\omega_f^2 = k_f/m$:\n$$M_{\\text{inner}} = \\begin{pmatrix} 1 - \\frac{(\\omega_f \\Delta t_{\\text{inner}})^2}{2} & \\frac{\\Delta t_{\\text{inner}}}{m} \\\\ -m\\omega_f^2 \\Delta t_{\\text{inner}} \\left(1 - \\frac{(\\omega_f \\Delta t_{\\text{inner}})^2}{4}\\right) & 1 - \\frac{(\\omega_f \\Delta t_{\\text{inner}})^2}{2} \\end{pmatrix}$$\n\n#### Task 2: Propagator Composition and Stability Analysis\n\nThe propagator for a full outer step, $M$, is the product of the matrices for each operation in sequence. The state vector is post-multiplied, so the order of matrix multiplication is reversed relative to the sequence of operations:\n$$M = M_{\\text{kick,s}} \\cdot (M_{\\text{inner}})^N \\cdot M_{\\text{kick,s}}$$\n\nThe evolution of the system over $K$ outer steps is given by $\\mathbf{x}_K = M^K \\mathbf{x}_0$. The system is considered linearly stable if the norm of the state vector, $||\\mathbf{x}_K||$, does not grow exponentially as $K \\to \\infty$. This behavior is determined by the eigenvalues, $\\lambda_i$, of the one-step propagator matrix $M$. The system is stable if and only if the spectral radius of $M$, defined as $\\rho(M) = \\max_i |\\lambda_i|$, is less than or equal to $1$.\n\nThe matrices $M_{\\text{kick,s}}$ and $M_{\\text{inner}}$ are symplectic, meaning they preserve phase space volume. A key property is that their determinant is $1$.\n$$\\det(M_{\\text{kick,s}}) = 1 \\cdot 1 - 0 = 1$$\n$$\\det(M_{\\text{inner}}) = \\left(1 - \\frac{(\\omega_f \\Delta t_{\\text{inner}})^2}{2}\\right)^2 + \\frac{\\Delta t_{\\text{inner}}}{m} \\cdot m\\omega_f^2 \\Delta t_{\\text{inner}} \\left(1 - \\frac{(\\omega_f \\Delta t_{\\text{inner}})^2}{4}\\right) = 1$$\nSince the determinant of a product of matrices is the product of their determinants, $\\det(M) = \\det(M_{\\text{kick,s}}) \\cdot (\\det(M_{\\text{inner}}))^N \\cdot \\det(M_{\\text{kick,s}}) = 1$.\n\nThe eigenvalues $\\lambda$ of a $2 \\times 2$ matrix $M$ are the roots of the characteristic polynomial $\\lambda^2 - \\text{Tr}(M)\\lambda + \\det(M) = 0$. Since $\\det(M)=1$, this becomes:\n$$\\lambda^2 - \\text{Tr}(M)\\lambda + 1 = 0$$\nThe roots are $\\lambda_{1,2} = \\frac{\\text{Tr}(M) \\pm \\sqrt{\\text{Tr}(M)^2 - 4}}{2}$.\n\n- If $|\\text{Tr}(M)| < 2$, the discriminant is negative. The eigenvalues are a complex conjugate pair, $\\lambda_{1,2} = \\frac{\\text{Tr}(M)}{2} \\pm i \\frac{\\sqrt{4 - \\text{Tr}(M)^2}}{2}$. Their magnitude is $|\\lambda| = \\sqrt{(\\frac{\\text{Tr}(M)}{2})^2 + (\\frac{\\sqrt{4 - \\text{Tr}(M)^2}}{2})^2} = 1$. This corresponds to stable, oscillatory motion.\n- If $|\\text{Tr}(M)| > 2$, the discriminant is positive. The eigenvalues are real and reciprocal, $\\lambda_1 = 1/\\lambda_2$. One eigenvalue will have a magnitude greater than $1$, leading to exponential growth of the solution. This is the unstable regime.\n- If $|\\text{Tr}(M)| = 2$, the eigenvalues are degenerate: $\\lambda_1 = \\lambda_2 = \\pm 1$. This is a marginally stable case, which can lead to linear (secular) growth in amplitude if the matrix is not diagonalizable. For avoiding exponential growth, this boundary is included in the stable region.\n\n**Stability Criterion:** The precise spectral condition for stability (avoiding exponential growth) is that the magnitude of all eigenvalues of $M$ must be less than or equal to $1$. For a $2 \\times 2$ symplectic matrix, this is equivalent to the condition:\n$$|\\text{Tr}(M)| \\le 2$$\n\n#### Task 3: Implementation and Results\nThe provided Python code implements this stability analysis. For each set of test parameters, it constructs the matrices $M_{\\text{kick,s}}$ and $M_{\\text{inner}}$, computes the full propagator $M = M_{\\text{kick,s}} (M_{\\text{inner}})^N M_{\\text{kick,s}}$, calculates its trace $\\text{Tr}(M)$, and returns `True` if $|\\text{Tr}(M)| \\le 2$ and `False` otherwise.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Analyzes the linear stability of a RESPA integrator for a harmonic oscillator\n    with two frequency scales.\n    \"\"\"\n    \n    # Define test cases where time is in s, mass in kg, and spring constants in N/m.\n    test_cases = [\n        # (m, k_f, k_s, N, dt_outer)\n        (1.0, 1.0e4, 1.0e2, 10, 0.020),     # Case 1\n        (1.0, 1.0e4, 1.0e2, 10, np.pi/100), # Case 2\n        (1.0, 1.0e4, 1.0,   10, np.pi/100), # Case 3\n        (1.0, 1.0e4, 1.0e2, 10, 0.005),     # Case 4\n        (1.0, 1.0e4, 1.0e2, 10, 0.200),     # Case 5\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        m, k_f, k_s, N, dt_outer = case\n        \n        # 1. Calculate time steps and define propagator for the slow kick.\n        dt_inner = dt_outer / N\n        \n        # Matrix for a half-step kick with the slow force.\n        # This updates momentum p based on the slow force F_s = -k_s * q.\n        # q_new = q_old\n        # p_new = p_old - k_s * q_old * (dt_outer / 2)\n        M_kick_s = np.array([\n            [1.0, 0.0],\n            [-k_s * dt_outer / 2.0, 1.0]\n        ])\n\n        # 2. Define the propagator for a single inner substep (fast force).\n        # This uses a symmetric position Verlet update for the fast dynamics.\n        w_f_sq = k_f / m\n        term_inner = w_f_sq * dt_inner**2\n        \n        # Diagonal element of the Verlet propagator matrix for a harmonic oscillator.\n        diag_val = 1.0 - term_inner / 2.0\n        \n        # Upper-right element (q dependence on p).\n        ur_val = dt_inner / m\n        \n        # Lower-left element (p dependence on q).\n        ll_val = -k_f * dt_inner * (1.0 - term_inner / 4.0)\n\n        M_inner = np.array([\n            [diag_val, ur_val],\n            [ll_val, diag_val]\n        ])\n\n        # 3. Compose the full one-step propagator matrix M.\n        # The RESPA scheme is (slow half-kick) -> (N inner steps) -> (slow half-kick).\n        # The matrix for N inner steps is M_inner raised to the power of N.\n        M_inner_N = np.linalg.matrix_power(M_inner, N)\n        \n        # The full propagator M = M_kick_s * M_inner_N * M_kick_s\n        M = M_kick_s @ M_inner_N @ M_kick_s\n        \n        # 4. Apply the stability criterion.\n        # For a 2x2 symplectic matrix (det=1), stability requires |Tr(M)| <= 2.\n        trace_M = np.trace(M)\n        is_stable = np.abs(trace_M) <= 2.0\n        results.append(is_stable)\n\n    # Format and print the final results as a single line.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}