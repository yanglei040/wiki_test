{
    "hands_on_practices": [
        {
            "introduction": "本练习旨在通过经验性方法，验证积分时间步长与系统最高振动频率之间的基本关系。通过将分子中最快的振动（如O-H键伸缩）简化为谐振子模型，您将亲手发现广泛使用的速度Verlet算法的稳定性边界，从而为选择合适的时间步长建立起核心直觉。",
            "id": "3455229",
            "problem": "考虑一个离散时间的分子动力学（MD）积分器，该积分器用于模拟一个主导曲率模式，该模式近似于简单点电荷扩展（SPC/E）水模型中最快的内运动。最大力曲率模式可以建模为一个一维谐振子，其位置 $x(t)$ 遵循牛顿第二定律 $m\\,\\ddot{x}(t) = -k\\,x(t)$，其中 $m$ 是质量，$k$ 是势能在平衡位置的曲率。定义角频率为 $\\omega = \\sqrt{k/m}$，可以使用时间步长为 $\\Delta t$ 的速度 Verlet 格式对运动方程进行离散化。该格式的经验稳定性边界可以通过逐步增加 $\\Delta t$ 并观察数值振荡是保持有界还是发散来探索。\n\n您的任务是编写一个程序，该程序：\n- 将主导曲率模式视为单个谐振子 $x''(t) + \\omega^2 x(t) = 0$，其中 $x''(t)$ 表示 $x(t)$ 的二阶时间导数。\n- 使用速度 Verlet 算法在时间上对微分方程进行数值步进，执行固定的步数 $N$，从微小的初始条件开始，并在数值振幅增长超过预设界限时检测不稳定性。\n- 通过从小到大扫描 $\\Delta t$ 值，并通过二分法精化边界，经验性地定位使数值解保持有界的最大稳定时间步长 $\\Delta t_{\\text{crit}}$。\n- 通过报告无量纲比率 $\\rho = \\Delta t_{\\text{crit}}\\,\\omega / 2$，将观测到的阈值 $\\Delta t_{\\text{crit}}$ 与特征角频率 $\\omega$ 相关联。\n\n科学真实性与单位：\n- 在刚性 SPC/E 水模型中，约束移除了 O–H 伸缩自由度，因此最高频率通常与弯曲或摆动模式相关。在没有约束的情况下，最高频率由 O–H 伸缩主导。为确保科学合理性，请使用以波数（反厘米）指定的特征模式频率，并使用 $\\omega = 2\\pi c\\,\\tilde{\\nu}$ 将其转换为角频率（单位为弧度/秒），其中 $c = 2.99792458\\times 10^{10}$ 厘米/秒，$\\tilde{\\nu}$ 是以 $\\text{cm}^{-1}$ 为单位的波数。\n- 以飞秒（fs）表示最终的经验临界时间步长。一飞秒等于 $10^{-15}$ 秒。\n\n算法要求：\n- 为谐振子 $x''(t) + \\omega^2 x(t) = 0$ 实现速度 Verlet 更新，其中单位质量 $m = 1$，刚度 $k = \\omega^2$，因此每一步的加速度为 $a(t) = -\\omega^2 x(t)$。\n- 使用 $x(0) = \\varepsilon$ 和 $v(0) = 0$ 进行初始化，其中 $\\varepsilon$ 是一个小振幅（选择一个合理的值以避免溢出并保持数值精度）。\n- 将不稳定性检测定义为在运行过程中的任何步骤，位置的绝对值 $|x|$ 超过初始振幅的固定倍数的事件。选择一个足够大以避免假阳性，但又足够有限以检测真实增长的界限。\n- 使用一种扫描方法，增加 $\\Delta t$ 直到检测到不稳定性，然后通过二分法精化边界，以产生 $\\Delta t_{\\text{crit}}$ 的鲁棒估计。\n\n测试套件：\n使用以下一组以 $\\text{cm}^{-1}$ 为单位的波数 $\\tilde{\\nu}$ 来定义五个测试用例，这些用例涵盖无约束和有约束的场景，以及典型、高频和低频极限：\n1. $\\tilde{\\nu} = 3600$（无约束的 O–H 伸缩，典型的柔性模型）。\n2. $\\tilde{\\nu} = 4000$（无约束的 O–H 伸缩，更硬的变体）。\n3. $\\tilde{\\nu} = 1600$（约束下由弯曲近似的最高模式）。\n4. $\\tilde{\\nu} = 600$（约束下由摆动近似的最高模式）。\n5. $\\tilde{\\nu} = 1800$（约束下的中间情况）。\n\n所需输出：\n- 对于每个测试用例，计算以飞秒为单位的 $\\Delta t_{\\text{crit}}$ 和无量纲比率 $\\rho = \\Delta t_{\\text{crit}}\\,\\omega / 2$。\n- 将 $\\Delta t_{\\text{crit}}$ 四舍五入到三位小数（单位为 fs），并将 $\\rho$ 四舍五入到六位小数。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果。该列表应按顺序包含每个测试用例的 $\\Delta t_{\\text{crit}}$ (fs) 后跟 $\\rho$ 的值对，展平为单个列表。例如，对于两个用例，格式将是 $[\\Delta t_{\\text{crit,1}}, \\rho_1, \\Delta t_{\\text{crit,2}}, \\rho_2]$。\n\n约束条件：\n- 程序必须是完全自包含的，不需要任何输入，并且仅依赖于指定的运行时环境。\n- 程序必须实现上述经验性扫描和二分法逻辑来确定每个用例的 $\\Delta t_{\\text{crit}}$，在决策逻辑中不使用任何闭式稳定性条件。\n\n答案单位：\n- 以飞秒表示 $\\Delta t_{\\text{crit}}$，四舍五入到三位小数。\n- 以小数表示 $\\rho$，四舍五入到六位小数。\n\n最终输出格式：\n- 单行文本，包含一个用方括号括起来的逗号分隔列表，按顺序汇总所有测试用例：$[\\Delta t_{\\text{crit,1}},\\rho_1,\\Delta t_{\\text{crit,2}},\\rho_2,\\ldots,\\Delta t_{\\text{crit,5}},\\rho_5]$。",
            "solution": "该问题要求经验性地确定应用于一维谐振子的速度 Verlet 积分格式的临界时间步长 $\\Delta t_{\\text{crit}}$。这作为一个分子中最高频率内运动的模型，是在分子动力学（MD）模拟中选择稳定时间步长的关键因素。需要对一组特征振动频率评估其稳定性，并将结果表示为一个无量纲比率，该比率将临界时间步长与振子的自然周期相关联。\n\n所考虑的基本系统是一个谐振子，其运动方程由恢复力 $F = -k x$ 的牛顿第二定律给出：\n$$\nm \\frac{d^2x(t)}{dt^2} = -k x(t)\n$$\n其中 $m$ 是质量，$x(t)$ 是位置，$k$ 是力常数。通过定义角频率 $\\omega = \\sqrt{k/m}$，该方程被重写为其典范形式：\n$$\n\\frac{d^2x(t)}{dt^2} + \\omega^2 x(t) = 0\n$$\n问题指定使用单位质量 $m=1$，因此在任何时间 $t$ 的加速度就是 $a(t) = -\\omega^2 x(t)$。\n\n对于数值积分，我们采用速度 Verlet 算法，这是一种在分子动力学中广泛使用的辛可积和时间可逆的积分器。给定在时间步 $n$ 的位置 $x_n$、速度 $v_n$ 和加速度 $a_n = -\\omega^2 x_n$，使用时间步长 $\\Delta t$ 计算第 $n+1$ 步的状态如下：\n\n1.  计算半步速度：\n    $$\n    v_{n+1/2} = v_n + a_n \\frac{\\Delta t}{2}\n    $$\n2.  将位置更新到完整步：\n    $$\n    x_{n+1} = x_n + v_{n+1/2} \\Delta t\n    $$\n3.  根据新位置计算新加速度：\n    $$\n    a_{n+1} = -\\omega^2 x_{n+1}\n    $$\n4.  使用新加速度将速度更新到完整步：\n    $$\n    v_{n+1} = v_{n+1/2} + a_{n+1} \\frac{\\Delta t}{2}\n    $$\n\n主要任务是找到此算法的稳定性边界。如果初始条件的微小扰动导致有界的、不发散的解，则认为数值积分格式是稳定的。对于谐振子，稳定的数值轨迹的总能量（及其振幅）将保持近似恒定，围绕真实的守恒能量表现出微小、有界的振荡。不稳定的轨迹将显示出能量和振幅的系统性、无界增长。临界时间步长 $\\Delta t_{\\text{crit}}$ 是使数值解保持有界的最大 $\\Delta t$ 值。\n\n为了经验性地确定 $\\Delta t_{\\text{crit}}$，我们将为每个给定的角频率 $\\omega$ 实现一个数值搜索过程。这个过程包括两个主要部分：一个模拟函数和一个搜索算法。\n\n模拟函数，我们称之为 `is_stable(Δt, ω)`，将执行以下步骤：\n1.  在 $t=0$ 时用 $x_0 = \\varepsilon$ 和 $v_0 = 0$ 初始化系统。由于谐振子方程是线性的，我们可以使用一个简单的值，如 $\\varepsilon=1$。\n2.  对速度 Verlet 算法迭代一个大的固定步数 $N$。$N=20000$ 的值足以让任何潜在的不稳定性显现出来。\n3.  在每一步 $n$，检查是否发散。如果位置的量值 $|x_n|$ 超过初始振幅的预定义倍数，即 $|x_n| > M \\cdot \\varepsilon$，则宣告为不稳定。$M=100$ 的乘数可作为检测指数增长的鲁棒阈值。\n4.  如果模拟完成所有 $N$ 步而振幅未超过阈值，则认为时间步长 $\\Delta t$ 对给定的 $\\omega$ 是稳定的。函数返回 `True`。否则，返回 `False`。\n\n搜索 $\\Delta t_{\\text{crit}}$ 的过程如下：\n1.  **区间限定：** 我们首先找到一个包含 $\\Delta t_{\\text{crit}}$ 的区间 $[\\Delta t_{\\text{lower}}, \\Delta t_{\\text{upper}}]$。这是通过从一个非常小的、已知稳定的 $\\Delta t$（例如，$10^{-18}\\,\\text{s}$）开始，并反复将其加倍，直到 `is_stable` 返回 `False` 来完成的。最后一个稳定的值成为 $\\Delta t_{\\text{lower}}$，第一个不稳定的值成为 $\\Delta t_{\\text{upper}}$。\n2.  **二分法：** 在稳定性边界被限定在区间内后，我们使用二分法来精化我们对 $\\Delta t_{\\text{crit}}$ 的估计。我们反复测试中点 $\\Delta t_{\\text{mid}} = (\\Delta t_{\\text{lower}} + \\Delta t_{\\text{upper}})/2$。如果 $\\Delta t_{\\text{mid}}$ 是稳定的，我们设置 $\\Delta t_{\\text{lower}} = \\Delta t_{\\text{mid}}$；否则，我们设置 $\\Delta t_{\\text{upper}} = \\Delta t_{\\text{mid}}$。这个过程重复一个固定的迭代次数（例如，$100$ 次）以达到高精度。$\\Delta t_{\\text{lower}}$ 的最终值就是我们的经验性 $\\Delta t_{\\text{crit}}$。\n\n问题指定了由波数 $\\tilde{\\nu}$（单位 $\\text{cm}^{-1}$）定义的五个测试用例：$\\{3600, 4000, 1600, 600, 1800\\}$。每个用例的角频率 $\\omega$ 使用关系式 $\\omega = 2\\pi c \\tilde{\\nu}$ 计算，其中光速 $c = 2.99792458 \\times 10^{10} \\text{ cm/s}$。得到的以秒为单位的 $\\Delta t_{\\text{crit}}$ 将被转换为飞秒（$1\\,\\text{fs} = 10^{-15}\\,\\text{s}$）。\n\n最后，我们计算无量纲比率 $\\rho = \\Delta t_{\\text{crit}}\\,\\omega / 2$。从解析上讲，应用于谐振子的速度 Verlet 算法的稳定性条件已知为 $\\Delta t \\cdot \\omega \\le 2$。这意味着理论上的临界时间步长是 $\\Delta t_{\\text{crit}} = 2/\\omega$。因此，该比率的理论值是 $\\rho = (2/\\omega) \\cdot \\omega / 2 = 1$。我们的经验性过程应该对所有测试用例都得出非常接近 $1$ 的 $\\rho$ 值，从而为实现提供了有力的验证。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It determines the critical time step for a velocity Verlet integrator\n    applied to a harmonic oscillator model of molecular vibrations.\n    \"\"\"\n\n    # --- Constants and Simulation Parameters ---\n\n    # Speed of light in cm/s as specified\n    C_CMS = 2.99792458e10\n\n    # Simulation parameters for stability check\n    NUM_STEPS = 20000  # Number of steps to run the simulation\n    # Initial condition for position. Velocity is 0. Since the system is linear,\n    # the exact value is not critical, so 1.0 is convenient.\n    X_INITIAL = 1.0\n    # Instability threshold: if |x| exceeds this multiple of the initial\n    # amplitude, the simulation is considered unstable.\n    INSTABILITY_MULTIPLIER = 100.0\n    # Number of bisection iterations for refining the critical time step\n    BISECTION_ITERATIONS = 100\n\n    # Test suite: wavenumbers in cm^-1\n    wavenumbers_cm_inv = [3600.0, 4000.0, 1600.0, 600.0, 1800.0]\n\n    # --- Helper Functions ---\n\n    def get_omega(wavenumber_cm_inv):\n        \"\"\"Converts wavenumber (cm^-1) to angular frequency (rad/s).\"\"\"\n        return 2.0 * np.pi * C_CMS * wavenumber_cm_inv\n\n    def is_stable(delta_t, omega):\n        \"\"\"\n        Runs a velocity Verlet simulation for a given dt and omega to check for stability.\n        Returns True if stable, False if unstable.\n        \"\"\"\n        x = X_INITIAL\n        v = 0.0\n        a = -omega**2 * x\n        \n        instability_threshold = X_INITIAL * INSTABILITY_MULTIPLIER\n\n        for _ in range(NUM_STEPS):\n            # Velocity Verlet algorithm\n            v_half_step = v + 0.5 * a * delta_t\n            x = x + v_half_step * delta_t\n            a = -omega**2 * x\n            v = v_half_step + 0.5 * a * delta_t\n\n            if abs(x) > instability_threshold:\n                return False\n        \n        return True\n\n    def find_critical_dt(omega):\n        \"\"\"\n        Finds the critical time step dt_crit for a given omega using a search algorithm.\n        \"\"\"\n        # 1. Bracketing the root\n        # Start with a very small dt and double it until it becomes unstable.\n        dt_lower = 1e-18  # A small, known-stable step in seconds\n        \n        # Check if the initial guess is stable. If not, this is an issue.\n        if not is_stable(dt_lower, omega):\n            # This case should not be reached with a sufficiently small initial dt.\n            raise RuntimeError(\"Initial time step is unstable.\")\n\n        dt_upper = dt_lower\n        while is_stable(dt_upper, omega):\n            dt_lower = dt_upper\n            dt_upper *= 2.0\n        \n        # Now we have a bracket [dt_lower, dt_upper] where lower is stable and upper is not.\n\n        # 2. Bisection to refine dt_crit\n        for _ in range(BISECTION_ITERATIONS):\n            dt_mid = (dt_lower + dt_upper) / 2.0\n            if is_stable(dt_mid, omega):\n                dt_lower = dt_mid\n            else:\n                dt_upper = dt_mid\n        \n        # The critical time step is the largest value that remains stable\n        return dt_lower\n\n    # --- Main Logic ---\n\n    results = []\n    for nu_tilde in wavenumbers_cm_inv:\n        # 1. Calculate angular frequency\n        omega = get_omega(nu_tilde)\n        \n        # 2. Empirically find the critical time step in seconds\n        dt_crit_s = find_critical_dt(omega)\n        \n        # 3. Convert dt_crit to femtoseconds and round\n        dt_crit_fs = dt_crit_s * 1e15\n        \n        # 4. Calculate the dimensionless ratio rho\n        rho = dt_crit_s * omega / 2.0\n        \n        # 5. Round results to the required precision\n        dt_crit_fs_rounded = round(dt_crit_fs, 3)\n        rho_rounded = round(rho, 6)\n        \n        results.append(dt_crit_fs_rounded)\n        results.append(rho_rounded)\n\n    # --- Final Output ---\n    # Convert all results to string for joining\n    str_results = [f\"{x:.3f}\" if i % 2 == 0 else f\"{x:.6f}\" for i, x in enumerate(results)]\n    print(f\"[{','.join(str_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在真实分子系统中，不同类型的运动（如快速的键振动和缓慢的构象变化）发生在迥异的时间尺度上。本练习将引导您探索一种高效处理此类问题的高级技术——参考系统传播算法（RESPA）。通过一个简化的双模谐振子模型，您将构建RESPA积分器，并分析其可能出现的共振不稳定性，这是所有分子动力学实践者都必须警惕的现象。",
            "id": "3455272",
            "problem": "考虑一个单一的笛卡尔自由度，其坐标为 $q$，动量为 $p$，质量为 $m$。该系统处在一个可分裂为快慢二次分量的势场中，其表达式为 $U(q) = \\tfrac{1}{2} k_f q^2 + \\tfrac{1}{2} k_s q^2$，其中 $k_f \\gg k_s$。定义快角频率 $\\omega_f = \\sqrt{k_f/m}$ 和慢角频率 $\\omega_s = \\sqrt{k_s/m}$，并写出比率 $r = \\omega_f/\\omega_s$。整个系统遵循牛顿第二定律 $m \\ddot{q} = -\\partial U/\\partial q$ 和哈密顿方程 $\\dot{q} = \\partial H/\\partial p$、$\\dot{p} = -\\partial H/\\partial q$，其中 $H = \\tfrac{p^2}{2m} + U(q)$。\n\n一个参考系统传播算法（RESPA）类型的多时间步长分裂积分器通过以下步骤，将状态推进一个大小为 $\\Delta t_{\\text{outer}}$ 的外层步长：\n- 施加一个慢力半踢，然后\n- 执行 $N$ 个内层子步，每个子步仅对快力进行积分，最后\n- 再次施加一个慢力半踢。\n内层子步的大小为 $\\Delta t_{\\text{inner}} = \\Delta t_{\\text{outer}}/N$。对于二次势，每个操作都是线性的，并且可以用一个作用在列向量 $(q,p)^\\top$ 上的 $2 \\times 2$ 矩阵表示。\n\n任务如下：\n1. 从 $m \\ddot{q} = -k_f q - k_s q$ 出发，推导以下线性映射（用 $m$、$k_f$、$k_s$ 和时间增量表示）：一个仅使用慢力将 $(q,p)$ 推进 $\\Delta t_{\\text{outer}}/2$ 的慢力半踢的线性映射，以及一个通过对称位置Verlet更新、仅使用快力将 $(q,p)$ 推进 $\\Delta t_{\\text{inner}}$ 的内层子步的线性映射。\n2. 组合这些映射，得到上述RESPA方案一个完整外层步长的单步传播矩阵 $M$。解释如何使用 $M$ 的特征值来定义一个外层步长的线性稳定性。具体来说，陈述一个 $M$ 的特征值必须满足的精确谱条件，以避免在线性化映射中 $(q,p)$ 范数发生指数增长。\n3. 实现一个程序，对于下面测试套件中的每一组参数，该程序都能够构建矩阵 $M$，计算其特征值，并返回一个布尔值，该布尔值指示单步映射的稳定性，作为比率 $r = \\omega_f/\\omega_s$ 和外层时间步长 $\\Delta t_{\\text{outer}}$ 的函数。\n\n使用以下测试套件，其中时间必须以秒（$s$）表示，质量以千克（$\\mathrm{kg}$）表示，弹簧常数以牛顿/米（$\\mathrm{N}/\\mathrm{m}$）表示。对于每种情况，计算任务2中定义的布尔稳定性结果：\n\n- 情况1：$m = 1$ $\\mathrm{kg}$，$k_f = 10^4$ $\\mathrm{N}/\\mathrm{m}$，$k_s = 10^2$ $\\mathrm{N}/\\mathrm{m}$，$N = 10$，$\\Delta t_{\\text{outer}} = 0.020$ $s$。\n- 情况2：$m = 1$ $\\mathrm{kg}$，$k_f = 10^4$ $\\mathrm{N}/\\mathrm{m}$，$k_s = 10^2$ $\\mathrm{N}/\\mathrm{m}$，$N = 10$，$\\Delta t_{\\text{outer}} = \\pi/100$ $s$。\n- 情况3：$m = 1$ $\\mathrm{kg}$，$k_f = 10^4$ $\\mathrm{N}/\\mathrm{m}$，$k_s = 1$ $\\mathrm{N}/\\mathrm{m}$，$N = 10$，$\\Delta t_{\\text{outer}} = \\pi/100$ $s$。\n- 情况4：$m = 1$ $\\mathrm{kg}$，$k_f = 10^4$ $\\mathrm{N}/\\mathrm{m}$，$k_s = 10^2$ $\\mathrm{N}/\\mathrm{m}$，$N = 10$，$\\Delta t_{\\text{outer}} = 0.005$ $s$。\n- 情况5：$m = 1$ $\\mathrm{kg}$，$k_f = 10^4$ $\\mathrm{N}/\\mathrm{m}$，$k_s = 10^2$ $\\mathrm{N}/\\mathrm{m}$，$N = 10$，$\\Delta t_{\\text{outer}} = 0.200$ $s$。\n\n您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[result_1,result_2,result_3,result_4,result_5]$），其中每个 $result_i$ 根据任务2中设计的稳定性判据为 $\\mathrm{True}$ 或 $\\mathrm{False}$。",
            "solution": "### 解决方案\n\n解决方案通过处理问题陈述中概述的三个任务来进行。我们将系统状态表示为列向量 $\\mathbf{x} = (q, p)^\\top$。积分器的每一步都是一个线性变换 $\\mathbf{x}_{\\text{new}} = M_i \\mathbf{x}_{\\text{old}}$，其中 $M_i$ 是某个矩阵。\n\n#### 任务1：推导线性映射\n\n**1. 慢力半踢的线性映射**\n\n慢力踢由仅涉及慢势 $U_s(q) = \\tfrac{1}{2} k_s q^2$ 的运动方程控制。相应的哈密顿量是 $H_s = \\tfrac{p^2}{2m} + U_s(q)$。对于一个纯粹依赖于势的项，哈密顿方程为 $\\dot{q} = 0$ 和 $\\dot{p} = -\\partial U_s/\\partial q = -k_s q$。\n\n在算符分裂的背景下，这个“踢”步骤根据当前位置的力来更新动量，而位置保持不变。在一个时间间隔 $\\Delta t$ 内，变换是：\n$$q(t_0 + \\Delta t) = q(t_0)$$\n$$p(t_0 + \\Delta t) = p(t_0) + \\int_{t_0}^{t_0+\\Delta t} (-k_s q(\\tau)) d\\tau = p(t_0) - k_s q(t_0) \\Delta t$$\n\n对于一个持续时间为 $\\Delta t = \\Delta t_{\\text{outer}}/2$ 的半踢，变换是：\n$$q_{\\text{new}} = q_{\\text{old}}$$\n$$p_{\\text{new}} = p_{\\text{old}} - k_s q_{\\text{old}} \\frac{\\Delta t_{\\text{outer}}}{2}$$\n\n以矩阵形式，这是 $\\mathbf{x}_{\\text{new}} = M_{\\text{kick,s}} \\mathbf{x}_{\\text{old}}$，其中慢踢传播矩阵 $M_{\\text{kick,s}}$ 是：\n$$M_{\\text{kick,s}} = \\begin{pmatrix} 1  & 0 \\\\ -k_s \\frac{\\Delta t_{\\text{outer}}}{2}  & 1 \\end{pmatrix}$$\n\n**2. 快力内层子步的线性映射（位置Verlet）**\n\n内层子步积分由快势 $U_f(q) = \\tfrac{1}{2} k_f q^2$ 引起的动力学，时间步长为 $\\Delta t_{\\text{inner}}$。运动方程为 $m\\ddot{q} = -k_f q$。对于状态 $(q_n, p_n)$ 的对称位置Verlet更新是三个步骤的组合：\n1. 半步动量踢：$p_{n+1/2} = p_n + F(q_n) \\frac{\\Delta t_{\\text{inner}}}{2} = p_n - k_f q_n \\frac{\\Delta t_{\\text{inner}}}{2}$。\n2. 整步位置漂移：$q_{n+1} = q_n + \\frac{p_{n+1/2}}{m} \\Delta t_{\\text{inner}} = q_n + \\frac{1}{m} \\left( p_n - k_f q_n \\frac{\\Delta t_{\\text{inner}}}{2} \\right) \\Delta t_{\\text{inner}} = \\left(1 - \\frac{k_f \\Delta t_{\\text{inner}}^2}{2m}\\right)q_n + \\frac{\\Delta t_{\\text{inner}}}{m}p_n$。\n3. 半步动量踢：$p_{n+1} = p_{n+1/2} + F(q_{n+1}) \\frac{\\Delta t_{\\text{inner}}}{2} = p_{n+1/2} - k_f q_{n+1} \\frac{\\Delta t_{\\text{inner}}}{2}$。\n\n代入 $p_{n+1/2}$ 和 $q_{n+1}$ 的表达式：\n$$p_{n+1} = \\left(p_n - k_f q_n \\frac{\\Delta t_{\\text{inner}}}{2}\\right) - k_f \\left[ \\left(1 - \\frac{k_f \\Delta t_{\\text{inner}}^2}{2m}\\right)q_n + \\frac{\\Delta t_{\\text{inner}}}{m}p_n \\right] \\frac{\\Delta t_{\\text{inner}}}{2}$$\n$$p_{n+1} = p_n - k_f q_n \\frac{\\Delta t_{\\text{inner}}}{2} - k_f q_n \\frac{\\Delta t_{\\text{inner}}}{2} + \\frac{k_f^2 \\Delta t_{\\text{inner}}^3}{4m} q_n - \\frac{k_f \\Delta t_{\\text{inner}}^2}{2m} p_n$$\n$$p_{n+1} = -k_f \\Delta t_{\\text{inner}} \\left( 1 - \\frac{k_f \\Delta t_{\\text{inner}}^2}{4m} \\right) q_n + \\left( 1 - \\frac{k_f \\Delta t_{\\text{inner}}^2}{2m} \\right) p_n$$\n\n因此，完整的变换 $\\mathbf{x}_{n+1} = M_{\\text{inner}} \\mathbf{x}_n$ 由以下矩阵给出：\n$$M_{\\text{inner}} = \\begin{pmatrix} 1 - \\frac{k_f \\Delta t_{\\text{inner}}^2}{2m}  & \\frac{\\Delta t_{\\text{inner}}}{m} \\\\ -k_f \\Delta t_{\\text{inner}} \\left(1 - \\frac{k_f \\Delta t_{\\text{inner}}^2}{4m}\\right)  & 1 - \\frac{k_f \\Delta t_{\\text{inner}}^2}{2m} \\end{pmatrix}$$\n这可以用快角频率 $\\omega_f^2 = k_f/m$ 来表示：\n$$M_{\\text{inner}} = \\begin{pmatrix} 1 - \\frac{(\\omega_f \\Delta t_{\\text{inner}})^2}{2}  & \\frac{\\Delta t_{\\text{inner}}}{m} \\\\ -m\\omega_f^2 \\Delta t_{\\text{inner}} \\left(1 - \\frac{(\\omega_f \\Delta t_{\\text{inner}})^2}{4}\\right)  & 1 - \\frac{(\\omega_f \\Delta t_{\\text{inner}})^2}{2} \\end{pmatrix}$$\n\n#### 任务2：传播矩阵组合与稳定性分析\n\n一个完整外层步长的传播矩阵 $M$ 是按序列中每个操作对应矩阵的乘积。状态向量是后乘的，所以矩阵乘法的顺序与操作序列的顺序相反：\n$$M = M_{\\text{kick,s}} \\cdot (M_{\\text{inner}})^N \\cdot M_{\\text{kick,s}}$$\n\n系统在 $K$ 个外层步长后的演化由 $\\mathbf{x}_K = M^K \\mathbf{x}_0$ 给出。如果状态向量的范数 $||\\mathbf{x}_K||$ 在 $K \\to \\infty$ 时不发生指数增长，则系统被认为是线性稳定的。这种行为由单步传播矩阵 $M$ 的特征值 $\\lambda_i$ 决定。系统稳定的充要条件是 $M$ 的谱半径 $\\rho(M) = \\max_i |\\lambda_i|$ 小于或等于 $1$。\n\n矩阵 $M_{\\text{kick,s}}$ 和 $M_{\\text{inner}}$ 是辛的，这意味着它们保持相空间体积。一个关键属性是它们的行列式为 $1$。\n$$\\det(M_{\\text{kick,s}}) = 1 \\cdot 1 - 0 = 1$$\n$$\\det(M_{\\text{inner}}) = \\left(1 - \\frac{(\\omega_f \\Delta t_{\\text{inner}})^2}{2}\\right)^2 + \\frac{\\Delta t_{\\text{inner}}}{m} \\cdot m\\omega_f^2 \\Delta t_{\\text{inner}} \\left(1 - \\frac{(\\omega_f \\Delta t_{\\text{inner}})^2}{4}\\right) = 1$$\n由于矩阵乘积的行列式是它们行列式的乘积，所以 $\\det(M) = \\det(M_{\\text{kick,s}}) \\cdot (\\det(M_{\\text{inner}}))^N \\cdot \\det(M_{\\text{kick,s}}) = 1$。\n\n$2 \\times 2$ 矩阵 $M$ 的特征值 $\\lambda$ 是特征多项式 $\\lambda^2 - \\text{Tr}(M)\\lambda + \\det(M) = 0$ 的根。由于 $\\det(M)=1$，方程变为：\n$$\\lambda^2 - \\text{Tr}(M)\\lambda + 1 = 0$$\n根为 $\\lambda_{1,2} = \\frac{\\text{Tr}(M) \\pm \\sqrt{\\text{Tr}(M)^2 - 4}}{2}$。\n\n- 如果 $|\\text{Tr}(M)|  2$，判别式为负。特征值为一对共轭复数，$\\lambda_{1,2} = \\frac{\\text{Tr}(M)}{2} \\pm i \\frac{\\sqrt{4 - \\text{Tr}(M)^2}}{2}$。它们的模为 $|\\lambda| = \\sqrt{(\\frac{\\text{Tr}(M)}{2})^2 + (\\frac{\\sqrt{4 - \\text{Tr}(M)^2}}{2})^2} = 1$。这对应于稳定的振荡运动。\n- 如果 $|\\text{Tr}(M)|  2$，判别式为正。特征值为实数且互为倒数，$\\lambda_1 = 1/\\lambda_2$。其中一个特征值的模将大于 $1$，导致解的指数增长。这是不稳定区域。\n- 如果 $|\\text{Tr}(M)| = 2$，特征值是简并的：$\\lambda_1 = \\lambda_2 = \\pm 1$。这是一个临界稳定情况，如果矩阵不可对角化，可能导致振幅的线性（长期）增长。为了避免指数增长，这个边界被包含在稳定区域内。\n\n**稳定性判据：** 稳定性（避免指数增长）的精确谱条件是 $M$ 的所有特征值的模必须小于或等于 $1$。对于一个 $2 \\times 2$ 辛矩阵，这等价于条件：\n$$|\\text{Tr}(M)| \\le 2$$\n\n#### 任务3：实现与结果\n提供的Python代码实现了这一稳定性分析。对于每组测试参数，它构建矩阵 $M_{\\text{kick,s}}$ 和 $M_{\\text{inner}}$，计算完整的传播矩阵 $M = M_{\\text{kick,s}} (M_{\\text{inner}})^N M_{\\text{kick,s}}$，计算其迹 $\\text{Tr}(M)$，如果 $|\\text{Tr}(M)| \\le 2$ 则返回 `True`，否则返回 `False`。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Analyzes the linear stability of a RESPA integrator for a harmonic oscillator\n    with two frequency scales.\n    \"\"\"\n    \n    # Define test cases where time is in s, mass in kg, and spring constants in N/m.\n    test_cases = [\n        # (m, k_f, k_s, N, dt_outer)\n        (1.0, 1.0e4, 1.0e2, 10, 0.020),     # Case 1\n        (1.0, 1.0e4, 1.0e2, 10, np.pi/100), # Case 2\n        (1.0, 1.0e4, 1.0,   10, np.pi/100), # Case 3\n        (1.0, 1.0e4, 1.0e2, 10, 0.005),     # Case 4\n        (1.0, 1.0e4, 1.0e2, 10, 0.200),     # Case 5\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        m, k_f, k_s, N, dt_outer = case\n        \n        # 1. Calculate time steps and define propagator for the slow kick.\n        dt_inner = dt_outer / N\n        \n        # Matrix for a half-step kick with the slow force.\n        # This updates momentum p based on the slow force F_s = -k_s * q.\n        # q_new = q_old\n        # p_new = p_old - k_s * q_old * (dt_outer / 2)\n        M_kick_s = np.array([\n            [1.0, 0.0],\n            [-k_s * dt_outer / 2.0, 1.0]\n        ])\n\n        # 2. Define the propagator for a single inner substep (fast force).\n        # This uses a symmetric position Verlet update for the fast dynamics.\n        w_f_sq = k_f / m\n        term_inner = w_f_sq * dt_inner**2\n        \n        # Diagonal element of the Verlet propagator matrix for a harmonic oscillator.\n        diag_val = 1.0 - term_inner / 2.0\n        \n        # Upper-right element (q dependence on p).\n        ur_val = dt_inner / m\n        \n        # Lower-left element (p dependence on q).\n        ll_val = -k_f * dt_inner * (1.0 - term_inner / 4.0)\n\n        M_inner = np.array([\n            [diag_val, ur_val],\n            [ll_val, diag_val]\n        ])\n\n        # 3. Compose the full one-step propagator matrix M.\n        # The RESPA scheme is (slow half-kick) -> (N inner steps) -> (slow half-kick).\n        # The matrix for N inner steps is M_inner raised to the power of N.\n        M_inner_N = np.linalg.matrix_power(M_inner, N)\n        \n        # The full propagator M = M_kick_s * M_inner_N * M_kick_s\n        M = M_kick_s @ M_inner_N @ M_kick_s\n        \n        # 4. Apply the stability criterion.\n        # For a 2x2 symplectic matrix (det=1), stability requires |Tr(M)| = 2.\n        trace_M = np.trace(M)\n        is_stable = np.abs(trace_M) = 2.0\n        results.append(is_stable)\n\n    # Format and print the final results as a single line.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "一个稳定（即能量不发散）的时间步长不一定能保证模拟结果的物理真实性。本练习将带您深入探讨模拟质量的更高标准，使用经典的费米-帕斯塔-乌拉姆-秦（FPU）晶格模型，研究积分时间步长如何影响能量均分等复杂的物理过程。通过这个实践，您将学会批判性地评估模拟的保真度，而不仅仅是其数值稳定性。",
            "id": "3455232",
            "problem": "考虑一个一维 Fermi–Pasta–Ulam–Tsingou 链，由 $N$ 个质点组成，两端采用固定边界条件。每个内部质点的位置为 $x_i(t)$，其中 $i \\in \\{1,\\dots,N\\}$。其动力学由牛顿第二运动定律决定，势能是线性项和三次非线性项之和。设每个粒子的质量为 $m$，线性弹簧常数为 $k$。设三次非线性系数为 $\\alpha$。定义键伸长量 $\\Delta_i(t) = x_{i+1}(t) - x_{i}(t)$，其中 $i \\in \\{0,\\dots,N\\}$，且 $x_0(t) = 0$ 和 $x_{N+1}(t) = 0$。总势能为\n$$\nV(x) = \\sum_{i=0}^{N} \\left( \\frac{k}{2} \\Delta_i^2 + \\frac{\\alpha}{3} \\Delta_i^3 \\right),\n$$\n运动方程为\n$$\nm \\frac{d^2 x_i}{dt^2} = F_i(x),\n$$\n其中位置 $i$ 上的力由下式给出\n$$\nF_i(x) = k\\left(\\Delta_i - \\Delta_{i-1}\\right) + \\alpha \\left(\\Delta_i^2 - \\Delta_{i-1}^2\\right),\n$$\n对于 $i \\in \\{1,\\dots,N\\}$，固定边界条件意味着 $x_0 = 0$ 和 $x_{N+1} = 0$。\n\n在纯线性链（$\\alpha = 0$）中，简正模是正弦形式的，其频率为\n$$\n\\omega_r = 2 \\sqrt{\\frac{k}{m}} \\sin\\left(\\frac{r \\pi}{2 (N+1)}\\right), \\quad r \\in \\{1,\\dots,N\\},\n$$\n正交归一的模态振型为\n$$\n\\phi_{r,i} = \\sqrt{\\frac{2}{N+1}} \\sin\\left(\\frac{r \\pi i}{N+1}\\right).\n$$\n在非线性链（$\\alpha \\neq 0$）中，这些线性模态仍可用于定义能量均分的诊断量，方法是将瞬时位形和速度投影到线性模态上。定义 $a_r(t) = \\sum_{i=1}^{N} \\phi_{r,i} x_i(t)$ 和 $p_r(t) = \\sum_{i=1}^{N} \\phi_{r,i} \\dot{x}_i(t)$，以及每个模态的能量\n$$\nE_r(t) = \\frac{1}{2}\\left(p_r(t)^2 + \\omega_r^2 a_r(t)^2\\right), \\quad r \\in \\{1,\\dots,N\\}.\n$$\n设 $E_{\\mathrm{tot}}(t) = \\sum_{r=1}^{N} E_r(t)$，模态间的归一化能量分布为 $p_r(t) = \\frac{E_r(t)}{E_{\\mathrm{tot}}(t)}$。通过 $H(t) = - \\sum_{r=1}^{N} p_r(t) \\ln p_r(t)$ 定义模态能量分布的熵，以及归一化的均分指示器\n$$\nQ(t) = \\frac{\\exp\\left(H(t)\\right)}{N}.\n$$\n当能量在所有 $N$ 个模态中均等共享时，该指示器满足 $Q(t) = 1$；当能量局域在少数几个模态中时，该指示器满足 $Q(t) \\ll 1$。\n\n考虑这些方程的离散时间数值积分方案，例如速度 Verlet 方法和四阶龙格–库塔 (RK4) 方法。时间步长 $\\Delta t$ 既影响数值稳定性，也影响非线性链中亚稳态能量均分等定性特征的保持。你的任务是实现一个程序，对于几组参数集，确定观测到的均分时间尺度相对于一个采用小 $\\Delta t$ 的基准发生非物理性变化的最小 $\\Delta t$。形式上，对于每组参数，计算均分时间 $T_{\\mathrm{eq}}(\\Delta t)$，其定义为在模拟时间上限 $T_{\\max}$ 内，$Q(t)$ 首次超过固定阈值 $Q_{\\mathrm{th}}$ 的时间 $t$。使用给定网格中的最小 $\\Delta t$ 作为基准 $\\Delta t_{\\min}$，其均分时间 $T_{\\mathrm{eq}}(\\Delta t_{\\min})$ 作为参考。对于网格中更大的 $\\Delta t$ 值，当比率\n$$\nR(\\Delta t) = \\frac{T_{\\mathrm{eq}}(\\Delta t)}{T_{\\mathrm{eq}}(\\Delta t_{\\min})}\n$$\n对于一个给定的因子 $\\rho  1$，落在一个容差带 $\\left[\\frac{1}{\\rho}, \\rho\\right]$ 之外时，则声明发生了非物理性变化。报告网格中发生这种情况的最小 $\\Delta t$。如果网格中没有 $\\Delta t$ 引起这种偏差，则报告 $-1$。\n\n使用无量纲单位：设 $m = 1$ 和 $k = 1$。所有时间，包括 $\\Delta t$ 和 $T_{\\mathrm{eq}}$，都必须用这些自然时间单位表示，并以浮点数形式报告。三角函数内的角度以弧度为单位。均分阈值必须设为 $Q_{\\mathrm{th}} = 0.75$，容差因子必须设为 $\\rho = 1.5$。所有测试用例的初始条件必须通过设置 $x_i(0) = A \\, \\phi_{1,i}$ 和 $\\dot{x}_i(0) = 0$，将所有能量置于振幅为 $A$ 的第一个线性模态中。\n\n你的程序必须实现速度 Verlet 和四阶龙格–库塔 (RK4) 两种积分器，并根据每个测试用例的指定来使用它们。模拟必须以规则的采样间隔计算 $Q(t)$，并将 $T_{\\mathrm{eq}}$ 确定为 $Q(t) \\ge Q_{\\mathrm{th}}$ 的首次穿越时间，如果在时间 $T_{\\max}$ 之前没有发生穿越，则设 $T_{\\mathrm{eq}} = T_{\\max}$。\n\n测试套件：\n为实现全面覆盖，请使用以下三组参数。对于每种情况，按升序搜索指定的 $\\Delta t$ 值网格，并找到使 $R(\\Delta t)$ 超出容差带的最小 $\\Delta t$；如果均未超出，则返回 $-1$。\n\n情况 1（一般行为，辛几何方案）：\n- $N = 8$\n- $\\alpha = 0.25$\n- $A = 0.20$\n- 积分器：速度 Verlet\n- $T_{\\max} = 200$\n- $\\Delta t$ 网格：$\\{0.0025, 0.005, 0.01, 0.02, 0.04\\}$\n\n情况 2（更长的链，非辛几何方案）：\n- $N = 16$\n- $\\alpha = 0.10$\n- $A = 0.10$\n- 积分器：四阶龙格–库塔 (RK4)\n- $T_{\\max} = 200$\n- $\\Delta t$ 网格：$\\{0.00125, 0.0025, 0.005, 0.01, 0.02\\}$\n\n情况 3（弱非线性，边界情况）：\n- $N = 8$\n- $\\alpha = 0.05$\n- $A = 0.05$\n- 积分器：速度 Verlet\n- $T_{\\max} = 150$\n- $\\Delta t$ 网格：$\\{0.005, 0.01, 0.02\\}$\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按上述顺序表示三种情况的结果。每个条目必须是该情况下网格中根据标准导致非物理性变化的最小 $\\Delta t$，如果没有，则为 $-1$。例如，输出必须如下所示：\n$[d_1,d_2,d_3]$\n其中 $d_1$、$d_2$ 和 $d_3$ 是时间单位的浮点值或整数 $-1$。",
            "solution": "该问题要求分析一维 Fermi–Pasta–Ulam–Tsingou (FPU) 链模拟的数值稳定性和物理保真度。具体来说，它要求确定在哪个最大的数值积分时间步长 $\\Delta t$ 下，计算出的能量均分时间尺度会非物理地偏离高保真度基准模拟的结果。\n\n该系统由一条包含 $N$ 个质量为 $m$ 的粒子链组成，它们由非线性弹簧连接。链的两端是固定的，对应于边界条件 $x_0(t) = 0$ 和 $x_{N+1}(t) = 0$。系统的势能 $V$ 由每个键伸长量 $\\Delta_i = x_{i+1} - x_i$ 的谐波项和三次项之和给出：\n$$\nV(x) = \\sum_{i=0}^{N} \\left( \\frac{k}{2} \\Delta_i^2 + \\frac{\\alpha}{3} \\Delta_i^3 \\right)\n$$\n其中 $k$ 是线性弹簧常数，$\\alpha$ 是三次非线性的系数。第 $i$ 个粒子上的力由势能导出，$F_i = -\\frac{\\partial V}{\\partial x_i}$，得出：\n$$\nF_i(x) = k\\left(\\Delta_i - \\Delta_{i-1}\\right) + \\alpha \\left(\\Delta_i^2 - \\Delta_{i-1}^2\\right), \\quad \\text{for } i \\in \\{1, \\dots, N\\}\n$$\n动力学由牛顿第二定律 $m \\frac{d^2 x_i}{dt^2} = F_i(x)$ 决定。对于本分析，我们使用无量纲单位，其中 $m=1$ 和 $k=1$。\n\n为了诊断系统状态，我们将其位形和速度投影到相应谐振链（$\\alpha=0$）的线性简正模上。这些模态的频率 $\\omega_r$ 和正交归一的模态振型 $\\phi_{r,i}$ 为：\n$$\n\\omega_r = 2 \\sqrt{\\frac{k}{m}} \\sin\\left(\\frac{r \\pi}{2 (N+1)}\\right), \\quad \\phi_{r,i} = \\sqrt{\\frac{2}{N+1}} \\sin\\left(\\frac{r \\pi i}{N+1}\\right)\n$$\n对于模态 $r \\in \\{1,\\dots,N\\}$ 和粒子 $i \\in \\{1,\\dots,N\\}$。模态振幅 $a_r(t)$ 和模态动量 $p_r(t)$ 通过投影计算：\n$$\na_r(t) = \\sum_{i=1}^{N} \\phi_{r,i} x_i(t), \\quad p_r(t) = \\sum_{i=1}^{N} \\phi_{r,i} \\dot{x}_i(t)\n$$\n与每个线性模态相关的能量则近似为：\n$$\nE_r(t) = \\frac{1}{2}\\left(p_r(t)^2 + \\omega_r^2 a_r(t)^2\\right)\n$$\n总模态能量为 $E_{\\mathrm{tot}}(t) = \\sum_{r=1}^{N} E_r(t)$。能量的分布由归一化的各模态能量 $p_r(t) = \\frac{E_r(t)}{E_{\\mathrm{tot}}(t)}$ 描述。\n\n能量共享或热化的程度，使用一种基于熵的度量来量化。模态能量熵为 $H(t) = - \\sum_{r=1}^{N} p_r(t) \\ln p_r(t)$。这引出了归一化均分指示器 $Q(t)$：\n$$\nQ(t) = \\frac{\\exp\\left(H(t)\\right)}{N}\n$$\n该指示器的范围从能量集中在单个模态时的 $Q(t) \\approx 1/N$ 到完美均分（能量在所有 $N$ 个模态中均等共享）时的 $Q(t)=1$。均分时间 $T_{\\mathrm{eq}}(\\Delta t)$ 定义为 $Q(t)$ 首次超过阈值 $Q_{\\mathrm{th}} = 0.75$ 的时间 $t$。\n\n问题的核心是研究 $T_{\\mathrm{eq}}$ 如何受到积分时间步长 $\\Delta t$ 选择的影响。我们使用给定网格中最小时间步长 $\\Delta t_{\\min}$ 的模拟来建立基准均分时间 $T_{\\mathrm{eq}}(\\Delta t_{\\min})$。如果比率 $R(\\Delta t) = \\frac{T_{\\mathrm{eq}}(\\Delta t)}{T_{\\mathrm{eq}}(\\Delta t_{\\min})}$ 落在了容差带 $[\\frac{1}{\\rho}, \\rho]$ 之外，则认为较大的时间步长 $\\Delta t$ 产生了非物理结果，其中容差因子 $\\rho = 1.5$。我们必须从网格中找到满足此条件的最小 $\\Delta t$。\n\n运动方程的数值积分使用两种指定的方法进行：\n$1$. **速度 Verlet** 方法，一种二阶辛积分法，因其长期能量稳定性而非常适用于哈密顿系统。对于从时间 $t$到 $t+\\Delta t$ 的一步，位置为 $x(t)$、速度为 $v(t)$、加速度为 $a(t) = F(x(t))/m$，算法如下：\n   a. $v(t + \\frac{\\Delta t}{2}) = v(t) + a(t) \\frac{\\Delta t}{2}$\n   b. $x(t + \\Delta t) = x(t) + v(t + \\frac{\\Delta t}{2}) \\Delta t$\n   c. 使用新位置 $x(t + \\Delta t)$ 计算 $a(t + \\Delta t)$。\n   d. $v(t + \\Delta t) = v(t + \\frac{\\Delta t}{2}) + a(t + \\Delta t) \\frac{\\Delta t}{2}$\n\n$2$. **四阶龙格–库塔 (RK4)** 方法，一种通用、高精度但非辛的积分法。对于一阶常微分方程组 $\\frac{dY}{dt} = f(t, Y)$，其中 $Y = [x_1, \\dots, x_N, \\dot{x}_1, \\dots, \\dot{x}_N]$，一步计算为：\n   a. $k_1 = \\Delta t \\cdot f(t, Y(t))$\n   b. $k_2 = \\Delta t \\cdot f(t + \\frac{\\Delta t}{2}, Y(t) + \\frac{k_1}{2})$\n   c. $k_3 = \\Delta t \\cdot f(t + \\frac{\\Delta t}{2}, Y(t) + \\frac{k_2}{2})$\n   d. $k_4 = \\Delta t \\cdot f(t + \\Delta t, Y(t) + k_3)$\n   e. $Y(t + \\Delta t) = Y(t) + \\frac{1}{6}(k_1 + 2k_2 + 2k_3 + k_4)$\n\n每个测试用例的总体流程如下：\n$1$. 使用指定的参数（$N, \\alpha, A$）和常数（$m=1, k=1$）设置系统。初始条件为 $x_i(0) = A \\phi_{1,i}$ 和 $\\dot{x}_i(0) = 0$，仅激发最低频率的模态。\n$2$. 预先计算模态振型 $\\phi_{r,i}$ 和频率的平方 $\\omega_r^2$。\n$3$. 对于所提供网格中的每个 $\\Delta t$，使用指定的积分器运行模拟直到 $T_{\\max}$。\n$4$. 在每次模拟中，监测 $Q(t)$ 并记录均分时间 $T_{\\mathrm{eq}}(\\Delta t)$。如果 $Q(t)$ 未达到 $Q_{\\mathrm{th}}$，则设 $T_{\\mathrm{eq}}(\\Delta t) = T_{\\max}$。\n$5$. 从使用最小 $\\Delta t$ 的运行中确定基准 $T_{\\mathrm{eq}}(\\Delta t_{\\min})$。\n$6$. 按升序遍历剩余的 $\\Delta t$ 值。计算比率 $R(\\Delta t)$。第一个使得 $R(\\Delta t)  1/1.5$ 或 $R(\\Delta t)  1.5$ 的 $\\Delta t$ 即为该情况的答案。如果找不到这样的 $\\Delta t$，答案为 $-1$。\n\n此过程针对所提供的三个测试用例实施。为了效率，计算过程使用 `numpy` 进行了向量化处理，特别是在力评估和模态投影方面。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function to run all test cases and print the final result.\n    \"\"\"\n\n    def calculate_forces(x, alpha, k, n_particles):\n        \"\"\"\n        Calculates the forces on each particle in the FPU chain.\n        \"\"\"\n        x_ext = np.zeros(n_particles + 2)\n        x_ext[1:-1] = x\n        \n        delta = np.diff(x_ext)\n        delta_sq = delta**2\n        \n        forces = k * (delta[1:] - delta[:-1]) + alpha * (delta_sq[1:] - delta_sq[:-1])\n        return forces\n\n    def velocity_verlet_step(x, v, dt, alpha, k, n_particles):\n        \"\"\"\n        Performs a single step of the Velocity Verlet algorithm.\n        m=1 is assumed.\n        \"\"\"\n        a = calculate_forces(x, alpha, k, n_particles)\n        v_half = v + 0.5 * a * dt\n        x_new = x + v_half * dt\n        a_new = calculate_forces(x_new, alpha, k, n_particles)\n        v_new = v_half + 0.5 * a_new * dt\n        return x_new, v_new\n\n    def rk4_step(x, v, dt, alpha, k, n_particles):\n        \"\"\"\n        Performs a single step of the Fourth-Order Runge–Kutta algorithm.\n        m=1 is assumed.\n        \"\"\"\n        def f(pos, vel):\n            dxdt = vel\n            dvdt = calculate_forces(pos, alpha, k, n_particles)\n            return dxdt, dvdt\n\n        k1_x, k1_v = f(x, v)\n        k2_x, k2_v = f(x + 0.5 * dt * k1_x, v + 0.5 * dt * k1_v)\n        k3_x, k3_v = f(x + 0.5 * dt * k2_x, v + 0.5 * dt * k2_v)\n        k4_x, k4_v = f(x + dt * k3_x, v + dt * k3_v)\n\n        x_new = x + (dt / 6.0) * (k1_x + 2*k2_x + 2*k3_x + k4_x)\n        v_new = v + (dt / 6.0) * (k1_v + 2*k2_v + 2*k3_v + k4_v)\n        return x_new, v_new\n\n    def calculate_Q(x, v, phi_matrix, omega_sq_vec, n_particles):\n        \"\"\"\n        Calculates the equipartition indicator Q.\n        \"\"\"\n        # Modal projection\n        a = phi_matrix @ x\n        p = phi_matrix @ v\n        \n        # Modal energies\n        E_r = 0.5 * (p**2 + omega_sq_vec * a**2)\n        E_tot = np.sum(E_r)\n        \n        if E_tot  1e-12:\n            return 1.0 / n_particles\n\n        # Normalized energy distribution\n        p_r_norm = E_r / E_tot\n        \n        # Entropy\n        p_r_positive = p_r_norm[p_r_norm > 1e-12]\n        H = -np.sum(p_r_positive * np.log(p_r_positive))\n        \n        # Equipartition indicator\n        Q = np.exp(H) / n_particles\n        return Q\n\n    def get_equip_time(params):\n        \"\"\"\n        Runs a single simulation and finds the equipartition time.\n        \"\"\"\n        N = params['N']\n        alpha = params['alpha']\n        A = params['A']\n        integrator_name = params['integrator']\n        T_max = params['T_max']\n        dt = params['dt']\n        Q_th = 0.75\n        m, k = 1.0, 1.0\n\n        # Pre-compute linear modes\n        r_vals = np.arange(1, N + 1)\n        i_vals = np.arange(1, N + 1)\n        \n        omega_vec = 2 * np.sqrt(k / m) * np.sin(r_vals * np.pi / (2 * (N + 1)))\n        omega_sq_vec = omega_vec**2\n        \n        phi_matrix = np.sqrt(2 / (N + 1)) * np.sin(np.outer(r_vals, i_vals * np.pi / (N + 1)))\n        \n        # Initial conditions\n        x = A * phi_matrix[0, :]\n        v = np.zeros(N)\n\n        n_steps = int(T_max / dt)\n        \n        if integrator_name == \"Velocity Verlet\":\n            integrator_step = velocity_verlet_step\n        else: # RK4\n            integrator_step = rk4_step\n        \n        for step in range(n_steps):\n            x, v = integrator_step(x, v, dt, alpha, k, N)\n            current_time = (step + 1) * dt\n            \n            # Sample Q at each step\n            q_val = calculate_Q(x, v, phi_matrix, omega_sq_vec, N)\n            \n            if q_val >= Q_th:\n                return current_time\n        \n        return T_max\n\n    def find_critical_dt(case_params):\n        \"\"\"\n        For a given test case, finds the smallest dt that causes non-physical change.\n        \"\"\"\n        dt_grid = case_params['dt_grid']\n        rho = 1.5\n        \n        T_eq_results = {}\n        for dt in dt_grid:\n            sim_params = case_params.copy()\n            sim_params['dt'] = dt\n            T_eq_results[dt] = get_equip_time(sim_params)\n\n        dt_min = dt_grid[0]\n        T_eq_baseline = T_eq_results[dt_min]\n        \n        if T_eq_baseline == 0: # Should not happen with given ICs, but for robustness\n            return -1.0\n            \n        for dt in dt_grid[1:]:\n            T_eq_current = T_eq_results[dt]\n            ratio = T_eq_current / T_eq_baseline\n            if ratio > rho or ratio  1.0 / rho:\n                return dt\n                \n        return -1.0\n\n    test_cases = [\n        {\n            \"N\": 8, \"alpha\": 0.25, \"A\": 0.20, \"integrator\": \"Velocity Verlet\",\n            \"T_max\": 200, \"dt_grid\": [0.0025, 0.005, 0.01, 0.02, 0.04]\n        },\n        {\n            \"N\": 16, \"alpha\": 0.10, \"A\": 0.10, \"integrator\": \"Fourth-Order Runge–Kutta (RK4)\",\n            \"T_max\": 200, \"dt_grid\": [0.00125, 0.0025, 0.005, 0.01, 0.02]\n        },\n        {\n            \"N\": 8, \"alpha\": 0.05, \"A\": 0.05, \"integrator\": \"Velocity Verlet\",\n            \"T_max\": 150, \"dt_grid\": [0.005, 0.01, 0.02]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        critical_dt = find_critical_dt(case)\n        results.append(critical_dt)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}