{
    "hands_on_practices": [
        {
            "introduction": "理论上，牛顿运动定律描述的系统会守恒总能量，但其数值近似解往往无法做到这一点。本练习将使用显式欧拉方法（一种最简单的积分器）来模拟一个 Lennard-Jones 双原子系统。通过亲手实现并观察到系统能量的持续增长，你将直观地理解为什么像欧拉这样的非辛方法不适用于可靠的分子动力学模拟，并定量地分析其误差如何随时间步长 $\\Delta t$ 变化。",
            "id": "3412384",
            "problem": "考虑在三维空间中，通过Lennard-Jones势相互作用的两个质量为 $m$ 的相同点状粒子，在简化的Lennar-Jones单位制（其中 $m=1$, $\\varepsilon=1$, $\\sigma=1$）下进行建模。在此单位制中，自然时间单位为 $\\tau=\\sigma\\sqrt{m/\\varepsilon}=1$。Lennard-Jones势定义为\n$$\nU(r) = 4\\varepsilon\\left[\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^6\\right],\n$$\n并且粒子2对粒子1产生的对力由下式给出\n$$\n\\mathbf{F}_{12} = -\\nabla U(r) = 24\\varepsilon\\left[2\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^6\\right]\\frac{\\mathbf{r}}{r^2},\n$$\n其中 $\\mathbf{r}=\\mathbf{x}_1-\\mathbf{x}_2$ 且 $r=\\|\\mathbf{r}\\|$。系统根据牛顿第二定律演化，其总能量为\n$$\nE(t) = \\sum_{i=1}^{2}\\frac{1}{2}m\\|\\mathbf{v}_i(t)\\|^2 + U(\\|\\mathbf{x}_1(t)-\\mathbf{x}_2(t)\\|).\n$$\n你将使用用于经典动力学的显式欧拉有限差分法来近似动力学过程：\n$$\n\\mathbf{x}_i^{n+1} = \\mathbf{x}_i^n + \\Delta t\\,\\mathbf{v}_i^n,\\quad\n\\mathbf{v}_i^{n+1} = \\mathbf{v}_i^n + \\Delta t\\,\\mathbf{a}_i(\\mathbf{x}_1^n,\\mathbf{x}_2^n),\n$$\n其中 $\\mathbf{a}_i=\\mathbf{F}_i/m$，$\\Delta t$ 是时间步长。\n\n初始化：设 $r_{\\mathrm{eq}}=2^{1/6}\\sigma$ 为Lennard-Jones势能最小值处的平衡间距。沿 $x$ 轴对称设置初始位置，以使质心位于原点，\n$$\n\\mathbf{x}_1(0)=\\left(\\frac{r_0}{2},0,0\\right),\\quad \\mathbf{x}_2(0)=\\left(-\\frac{r_0}{2},0,0\\right),\n$$\n其中 $r_0=r_{\\mathrm{eq}}(1+a)$ 且 $a=0.02$。将初始速度设置为零，即 $\\mathbf{v}_1(0)=\\mathbf{0}$ 和 $\\mathbf{v}_2(0)=\\mathbf{0}$。始终使用简化单位制 $m=1$, $\\varepsilon=1$ 和 $\\sigma=1$。将系统演化总物理时间 $T=50\\tau$。\n\n任务：对于每个指定的时间步长 $\\Delta t$，使用上面定义的显式欧拉方法对系统从 $t=0$ 积分到 $t=T$。计算单位时间内的全局能量漂移，\n$$\nD(\\Delta t) = \\frac{E(T)-E(0)}{T},\n$$\n结果以 $\\varepsilon/\\tau$ 为单位表示。报告 $D(\\Delta t)$，结果保留六位有效数字。\n\n从第一性原理出发，并在势能最小值附近进行适当的线性化，解释你所观察到的 $D(\\Delta t)$ 对 $\\Delta t$ 的依赖关系。\n\n测试集：使用以下时间步长，均以 $\\tau$ 为单位，\n- $\\Delta t_1=5\\times 10^{-5}$，\n- $\\Delta t_2=2\\times 10^{-4}$，\n- $\\Delta t_3=8\\times 10^{-4}$，\n- $\\Delta t_4=1.2\\times 10^{-3}$。\n\n最终输出格式：你的程序应产生单行输出，包含计算出的漂移 $[D(\\Delta t_1),D(\\Delta t_2),D(\\Delta t_3),D(\\Delta t_4)]$，形式为一个用逗号分隔、并用方括号括起来的列表，每个条目保留六位有效数字，且值以 $\\varepsilon/\\tau$ 为单位表示。",
            "solution": "出发点是牛顿第二定律，适用于两个质量为 $m$、通过中心势 $U(r)$ 相互作用的相同粒子，\n$$\nm\\ddot{\\mathbf{x}}_1 = \\mathbf{F}_{12},\\quad m\\ddot{\\mathbf{x}}_2 = \\mathbf{F}_{21}=-\\mathbf{F}_{12},\n$$\n其中 $\\mathbf{F}_{12}=-\\nabla U(r)$ 且 $r=\\|\\mathbf{x}_1-\\mathbf{x}_2\\|$。Lennard-Jones势为\n$$\nU(r)=4\\varepsilon\\left[\\left(\\frac{\\sigma}{r}\\right)^{12}-\\left(\\frac{\\sigma}{r}\\right)^6\\right],\n$$\n所以其径向导数为\n$$\n\\frac{dU}{dr}=4\\varepsilon\\left(-12\\frac{\\sigma^{12}}{r^{13}}+6\\frac{\\sigma^6}{r^7}\\right),\n$$\n并且力矢量可由 $\\mathbf{F}=-\\frac{dU}{dr}\\frac{\\mathbf{r}}{r}$ 导出为\n$$\n\\mathbf{F}_{12}=4\\varepsilon\\left(12\\frac{\\sigma^{12}}{r^{14}}-6\\frac{\\sigma^6}{r^8}\\right)\\mathbf{r} = 24\\varepsilon\\left[2\\left(\\frac{\\sigma}{r}\\right)^{12}-\\left(\\frac{\\sigma}{r}\\right)^6\\right]\\frac{\\mathbf{r}}{r^2}.\n$$\n总能量是动能和势能之和，\n$$\nE(t) = \\frac{1}{2}m\\|\\mathbf{v}_1(t)\\|^2 + \\frac{1}{2}m\\|\\mathbf{v}_2(t)\\|^2 + U(\\|\\mathbf{x}_1(t)-\\mathbf{x}_2(t)\\|).\n$$\n在连续时间和精确动力学下，由于力是保守力，$E(t)$ 是守恒的。当使用显式欧拉法进行离散化时，更新步骤为\n$$\n\\mathbf{x}_i^{n+1} = \\mathbf{x}_i^n + \\Delta t\\,\\mathbf{v}_i^n,\\quad \\mathbf{v}_i^{n+1} = \\mathbf{v}_i^n + \\Delta t\\,\\frac{\\mathbf{F}_i(\\mathbf{x}_1^n,\\mathbf{x}_2^n)}{m}.\n$$\n显式欧拉法是一种一阶方法，它不是辛方法，并且不保持哈密顿系统的能量守恒；因此预计会出现系统性的能量漂移。\n\n为了分析在平衡点附近对 $\\Delta t$ 的依赖关系，在Lennard-Jones势能最小值处（即间距 $r_{\\mathrm{eq}}=2^{1/6}\\sigma$ 处，在该处 $U'(r_{\\mathrm{eq}})=0$）对动力学进行线性化。对于小位移 $q=r-r_{\\mathrm{eq}}$，泰勒展开得到\n$$\nU(r) \\approx U(r_{\\mathrm{eq}}) + \\frac{1}{2}k\\,q^2,\\quad k=U''(r_{\\mathrm{eq}}).\n$$\n在 $m=1$ 和 $\\sigma=\\varepsilon=1$ 的简化单位制中，相对坐标服从有效的一维小振荡方程。对于两个相等质量的粒子，相对坐标 $\\mathbf{r}=\\mathbf{x}_1-\\mathbf{x}_2$ 满足\n$$\n\\ddot{\\mathbf{r}} = \\frac{2}{m}\\mathbf{F}(\\mathbf{r}) \\approx -\\omega^2 \\mathbf{q},\\quad \\omega^2 = \\frac{k}{\\mu},\\quad \\mu=\\frac{m}{2}.\n$$\n此处，$\\mu$ 是约化质量，$\\mathbf{q}$ 是沿两粒子中心连线的平衡位置偏离量。对于谐振子 $\\ddot{q}=-\\omega^2 q$，将显式欧拉法应用于一阶系统\n$$\n\\dot{q}=v,\\quad \\dot{v}=-\\omega^2 q\n$$\n的更新方式如下\n$$\n\\begin{pmatrix} q^{n+1} \\\\ v^{n+1} \\end{pmatrix}\n=\n\\begin{pmatrix}\n1  \\Delta t \\\\\n-\\omega^2 \\Delta t  1\n\\end{pmatrix}\n\\begin{pmatrix} q^{n} \\\\ v^{n} \\end{pmatrix}.\n$$\n该更新矩阵的特征值为\n$$\n\\lambda_{\\pm} = 1 \\pm i\\,\\omega\\,\\Delta t,\n$$\n其模为\n$$\n|\\lambda_{\\pm}| = \\sqrt{1+\\omega^2\\Delta t^2} = 1 + \\frac{1}{2}\\omega^2\\Delta t^2 + \\mathcal{O}(\\Delta t^4).\n$$\n因此，每个步长振幅增加因子 $|\\lambda|$，能量（在谐振子近似下与振幅平方成正比）每个步长增加因子\n$$\n|\\lambda|^2 = 1 + \\omega^2\\Delta t^2 + \\mathcal{O}(\\Delta t^4).\n$$\n因此，每步的能量增量为\n$$\n\\Delta E_{\\text{step}} \\approx \\omega^2 \\Delta t^2\\, E.\n$$\n在 $N=T/\\Delta t$ 个步长内，总能量变化近似满足\n$$\nE(T) - E(0) \\approx N\\,\\Delta E_{\\text{step}} \\approx \\frac{T}{\\Delta t}\\,\\omega^2\\Delta t^2\\,E(0) = \\omega^2 E(0)\\, T\\, \\Delta t,\n$$\n此处不计高阶修正项和积分过程中 $E$ 的缓慢变化。除以 $T$ 得到单位时间内的全局能量漂移，\n$$\nD(\\Delta t) = \\frac{E(T)-E(0)}{T} \\approx \\omega^2 E(0)\\,\\Delta t,\n$$\n对于足够小的 $\\Delta t$，该值与 $\\Delta t$ 呈线性关系。这一论证依赖于在最小值附近的线性化以及显式欧拉法的一阶性质；该方法的全局截断误差为 $\\mathcal{O}(\\Delta t)$，并且非辛离散化导致了能量的长期增长。\n\n算法设计：\n- 使用简化的Lennard-Jones单位制 $m=\\varepsilon=\\sigma=1$，使得力和能量无量纲，时间以 $\\tau=1$ 的倍数计量。\n- 对称地初始化两个粒子，位置在 $r_0=r_{\\mathrm{eq}}(1+a)$ (其中 $a=0.02$) 处，速度为零，确保质心位于原点。\n- 实现显式欧拉法：\n  - 计算分离矢量 $\\mathbf{r}$、其模 $r$ 以及Lennard-Jones力 $\\mathbf{F}_{12}$。\n  - 通过 $\\mathbf{x}_i^{n+1}=\\mathbf{x}_i^n+\\Delta t\\,\\mathbf{v}_i^n$ 更新位置。\n  - 通过 $\\mathbf{v}_1^{n+1}=\\mathbf{v}_1^n+\\Delta t\\,\\mathbf{F}_{12}/m$ 和 $\\mathbf{v}_2^{n+1}=\\mathbf{v}_2^n-\\Delta t\\,\\mathbf{F}_{12}/m$ 更新速度。\n- 计算 $t=0$ 和 $t=T$ 时的总能量，并报告 $D(\\Delta t)$ 为 $(E(T)-E(0))/T$。\n- 对测试集 $\\Delta t\\in\\{5\\times 10^{-5}, 2\\times 10^{-4}, 8\\times 10^{-4}, 1.2\\times 10^{-3}\\}$ 重复上述过程。\n- 将每个 $D(\\Delta t)$ 四舍五入到六位有效数字，并以 $\\varepsilon/\\tau$ 为单位输出。\n\n结果解释：\n- 对于最小的 $\\Delta t$，$D(\\Delta t)$ 应该非常小，并且与 $\\Delta t$ 近似线性相关，这与从谐振子近似和显式欧拉方案性质推导出的单位时间 $\\mathcal{O}(\\Delta t)$ 全局能量漂移一致。\n- 在小步长范围内，随着 $\\Delta t$ 的增加，$D(\\Delta t)$ 近似与 $\\Delta t$ 成比例增加，从而验证了理论上的依赖关系。在较大的 $\\Delta t$ 下可能会出现偏差，这是由于线性近似的失效和振荡幅度的增长，但该趋势仍然表明了该方法的一阶、非辛特性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef lj_force(r_vec, epsilon=1.0, sigma=1.0):\n    \"\"\"\n    Compute the Lennard-Jones force vector on particle 1 due to particle 2.\n    r_vec: separation vector r = x1 - x2\n    \"\"\"\n    r2 = np.dot(r_vec, r_vec)\n    r = np.sqrt(r2)\n    # Avoid division by zero; if r is extremely small, cap the force direction\n    if r == 0.0:\n        return np.zeros_like(r_vec)\n    inv_r2 = 1.0 / r2\n    inv_r6 = (sigma**2 * inv_r2)**3  # (sigma/r)^6\n    inv_r12 = inv_r6**2              # (sigma/r)^12\n    # Force magnitude factor for vector form:\n    # F = 24*epsilon * [2*(sigma/r)^12 - (sigma/r)^6] * r_vec / r^2\n    factor = 24.0 * epsilon * (2.0 * inv_r12 - inv_r6) * inv_r2\n    return factor * r_vec\n\ndef lj_potential(r, epsilon=1.0, sigma=1.0):\n    \"\"\"\n    Compute Lennard-Jones potential U(r).\n    \"\"\"\n    inv_r6 = (sigma / r)**6\n    inv_r12 = inv_r6**2\n    return 4.0 * epsilon * (inv_r12 - inv_r6)\n\ndef total_energy(x1, v1, x2, v2, epsilon=1.0, sigma=1.0, m=1.0):\n    \"\"\"\n    Compute total energy: kinetic + potential.\n    \"\"\"\n    ke = 0.5 * m * np.dot(v1, v1) + 0.5 * m * np.dot(v2, v2)\n    r = np.linalg.norm(x1 - x2)\n    pe = lj_potential(r, epsilon=epsilon, sigma=sigma)\n    return ke + pe\n\ndef energy_drift_per_unit_time(dt, T=50.0, a=0.02, epsilon=1.0, sigma=1.0, m=1.0):\n    \"\"\"\n    Integrate the Lennard-Jones dimer with explicit Euler and compute\n    the global energy drift per unit time (E(T) - E(0)) / T.\n    Units: epsilon/tau, with tau=1 in reduced units.\n    \"\"\"\n    # Equilibrium separation for LJ minimum\n    r_eq = 2.0**(1.0/6.0) * sigma\n    r0 = r_eq * (1.0 + a)\n\n    # Initial positions and velocities (center of mass at origin)\n    x1 = np.array([0.5 * r0, 0.0, 0.0], dtype=float)\n    x2 = np.array([-0.5 * r0, 0.0, 0.0], dtype=float)\n    v1 = np.zeros(3, dtype=float)\n    v2 = np.zeros(3, dtype=float)\n\n    E0 = total_energy(x1, v1, x2, v2, epsilon=epsilon, sigma=sigma, m=m)\n\n    # Number of steps\n    N = int(np.floor(T / dt))\n    # Time integration via explicit Euler\n    for _ in range(N):\n        # Compute force on particle 1 due to particle 2\n        r_vec = x1 - x2\n        F12 = lj_force(r_vec, epsilon=epsilon, sigma=sigma)\n\n        # Update positions\n        x1 = x1 + dt * v1\n        x2 = x2 + dt * v2\n\n        # Update velocities\n        v1 = v1 + dt * (F12 / m)\n        v2 = v2 - dt * (F12 / m)\n\n    E_end = total_energy(x1, v1, x2, v2, epsilon=epsilon, sigma=sigma, m=m)\n    drift = (E_end - E0) / T  # Units: epsilon/tau in reduced units\n    return drift\n\ndef solve():\n    # Define the test cases from the problem statement (time steps in tau units).\n    test_cases = [\n        5e-5,\n        2e-4,\n        8e-4,\n        1.2e-3,\n    ]\n\n    results = []\n    for dt in test_cases:\n        d = energy_drift_per_unit_time(dt)\n        # Round to six significant figures as specified\n        results.append(f\"{d:.6g}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "速度 Verlet 算法是一种性能优越的辛积分器，以其出色的长期能量守恒性而闻名。然而，本练习将带你探索一个关键的细节：这种守恒特性仅在作用力是某个势能函数的精确梯度时才成立。通过使用不同的有限差分格式从一个列表化的势能数据中计算力，你将发现非对称的力计算方法（如前向或后向差分）会如何重新引入能量漂移，即便使用的是辛积分器。这个实践突显了在整个模拟过程中保持对称性的重要性。",
            "id": "3412357",
            "problem": "考虑一个质量为 $m$ 的单个经典粒子在一维空间中标量势能函数 $V_{\\text{true}}(r)$ 下运动。其运动遵循牛顿第二定律 $m\\,d^2 r/dt^2 = F(r)$，其中 $F(r)$ 是作为位置 $r$ 函数的力。在分子动力学中，力通常是通过有限差分法，根据网格上 $V(r)$ 的列表值计算得出。您的任务是实现并比较三种基于列表化势能构建的有限差分力估算器，然后使用速度 Verlet (VV) 方法对运动方程进行积分，以量化由非对称力离散化引起的系统性能量漂移。\n\n使用以下物理上合理且平滑的双阱势作为参考势：\n$$\nV_{\\text{true}}(r) = \\tfrac{1}{4}\\,r^4 - \\tfrac{1}{2}\\,r^2.\n$$\n\n将此势在均匀网格 $r_i = r_{\\min} + i\\,h$（对于 $i=0,1,\\dots,n-1$）上进行列表化，其中 $r_{\\min}=-2$，$r_{\\max}=2$，间距 $h$ 由每个测试用例指定。列表值为 $V_i = V_{\\text{true}}(r_i)$。对于积分过程中遇到的任何非网格位置 $r$，定义单元格索引\n$$\ni = \\left\\lfloor \\frac{r - r_{\\min}}{h} \\right\\rfloor,\n$$\n并约束数组访问，使其在每种方案的有效索引范围内。根据列表化的 $V_i$，定义以下三种力估算器 $F_{\\text{fd}}(r)$：\n- 向前差分（当前单元格 $[r_i,r_{i+1})$ 上的分段恒定斜率）：\n$$\nF_{\\text{fwd}}(r) = -\\frac{V_{i+1} - V_{i}}{h}.\n$$\n- 向后差分（前一个单元格 $[r_{i-1},r_{i})$ 上的斜率）：\n$$\nF_{\\text{bwd}}(r) = -\\frac{V_{i} - V_{i-1}}{h}.\n$$\n- 中心差分（跨越 $[r_{i-1},r_{i+1}]$ 的对称两点斜率）：\n$$\nF_{\\text{cen}}(r) = -\\frac{V_{i+1} - V_{i-1}}{2h}.\n$$\n\n使用速度 Verlet (VV) 算法对运动方程进行积分，该算法由牛顿第二定律和速度定义 $v = dr/dt$ 构建，以恒定的时间步长 $\\Delta t$（由每个测试用例指定）来推进位置 $r$ 和速度 $v$。在 VV 更新中使用选定的 $F_{\\text{fd}}(r)$ 计算加速度 $a(r) = F_{\\text{fd}}(r)/m$。在整个模拟过程中，使用参考势计算瞬时总能量，\n$$\nE(t) = \\tfrac{1}{2}\\,m\\,v(t)^2 + V_{\\text{true}}(r(t)).\n$$\n通过对整个模拟轨迹上的 $E(t)$ 与 $t$ 进行普通最小二乘线性回归来量化系统性能量漂移，并报告每个测试用例的最佳拟合斜率 $dE/dt$（作为单个标量）。每个报告的斜率以单位时间的能量单位表示。\n\n以下测试套件指定了所有参数。对于每个用例，使用 $m=1$（无量纲质量）、初始位置 $r(0)=1.2$ 和初始速度 $v(0)=0$。对于所有用例，取 $r_{\\min}=-2$ 和 $r_{\\max}=2$。对于每个用例，模拟 $N_{\\text{steps}}$ 个时间步，步长为 $\\Delta t$，并如上所述计算最小二乘斜率 $dE/dt$。\n\n- 用例 $1$（理想情况，细网格，对称力）：方案 $=$ 中心差分，$h=0.02$，$\\Delta t = 0.02$，$N_{\\text{steps}}=30000$。\n- 用例 $2$（细网格，非对称向前差分力）：方案 $=$ 向前差分，$h=0.02$，$\\Delta t = 0.02$，$N_{\\text{steps}}=30000$。\n- 用例 $3$（细网格，非对称向后差分力）：方案 $=$ 向后差分，$h=0.02$，$\\Delta t = 0.02$，$N_{\\text{steps}}=30000$。\n- 用例 $4$（粗网格，对称力）：方案 $=$ 中心差分，$h=0.20$，$\\Delta t = 0.02$，$N_{\\text{steps}}=30000$。\n- 用例 $5$（粗网格，非对称向前差分力）：方案 $=$ 向前差分，$h=0.20$，$\\Delta t = 0.02$，$N_{\\text{steps}}=30000$。\n- 用例 $6$（粗网格，非对称向后差分力）：方案 $=$ 向后差分，$h=0.20$，$\\Delta t = 0.02$，$N_{\\text{steps}}=30000$。\n\n您的程序必须完全按照定义实现列表化和力估算器，使用从牛顿定律推导出的标准速度 Verlet 算法，并为每个用例计算最小二乘斜率。如果由于数值误差 $r$ 离开了列表化区间 $[r_{\\min}, r_{\\max}]$，则约束有限差分索引以使数组访问保持有效，并继续积分；不要施加任何额外的边界力。\n\n最终输出格式要求：\n- 生成单行输出，包含从用例 $1$ 到用例 $6$ 的六个漂移率，以单位时间的能量单位表示。该行必须是用方括号括起来的逗号分隔列表，例如 $[x_1,x_2,x_3,x_4,x_5,x_6]$。允许使用科学记数法。不得打印任何其他文本。",
            "solution": "该问题要求研究速度 Verlet 积分算法与不同有限差分方案结合用于力计算时的长期能量守恒特性。我们将模拟一个经典粒子的一维运动，并量化由数值不准确性（特别是由力估算器的不对称性）引起的系统性能量漂移。\n\n粒子质量为 $m$，其运动遵循牛顿第二定律 $m\\ddot{r} = F(r)$，其中 $r$ 是位置，$F(r)$ 是力。真实的物理系统由一个平滑、连续的势能函数 $V_{\\text{true}}(r) = \\tfrac{1}{4}r^4 - \\tfrac{1}{2}r^2$ 定义。相应的真实力为 $F_{\\text{true}}(r) = -dV_{\\text{true}}/dr = - (r^3 - r)$。在这个精确的物理系统中，总能量 $E(t) = \\tfrac{1}{2}m v(t)^2 + V_{\\text{true}}(r(t))$ 是一个守恒量，即 $dE/dt = 0$。\n\n在典型的数值模拟中，力不是解析已知的，而是从一个在离散网格上列表化的势能面推导出来的。我们给定一个网格点 $r_i = r_{\\min} + i h$（对于 $i=0, \\dots, n-1$），其上的势能值为 $V_i = V_{\\text{true}}(r_i)$。那么，粒子在任意位置 $r$ 受到的力必须从这些列表值中估算。问题指定了三种常见的有限差分估算器。对于位于网格单元 $[r_i, r_{i+1})$ 中的粒子，其位置为 $r$，其中 $i = \\lfloor (r - r_{\\min})/h \\rfloor$，估算器如下：\n\n1.  **向前差分**：$F_{\\text{fwd}}(r) = -\\frac{V_{i+1} - V_{i}}{h}$。该估算器基于粒子当前所在单元格上的势能斜率。它是对真实导数的一阶精确近似，误差为 $\\mathcal{O}(h)$ 量级。它本质上是非对称的。\n2.  **向后差分**：$F_{\\text{bwd}}(r) = -\\frac{V_{i} - V_{i-1}}{h}$。该估算器使用粒子刚离开的单元格上的斜率。它也是一阶精确的，误差为 $\\mathcal{O}(h)$，并且是非对称的。\n3.  **中心差分**：$F_{\\text{cen}}(r) = -\\frac{V_{i+1} - V_{i-1}}{2h}$。该估算器对称地使用当前单元格基点 $r_i$ 两侧的点。它是一个二阶精确近似，误差为 $\\mathcal{O}(h^2)$ 量级。\n\n粒子的轨迹是通过对运动方程进行数值积分生成的。问题指定了速度 Verlet (VV) 算法，这是分子动力学中的一个标准选择，因其出色的稳定性和长期能量守恒特性而著称。给定时间 $t$ 时的位置 $r(t)$、速度 $v(t)$ 和加速度 $a(t) = F_{\\text{fd}}(r(t))/m$，时间 $t+\\Delta t$ 时的状态计算如下：\n$$\nr(t+\\Delta t) = r(t) + v(t)\\Delta t + \\tfrac{1}{2}a(t)(\\Delta t)^2\n$$\n$$\na(t+\\Delta t) = F_{\\text{fd}}(r(t+\\Delta t))/m\n$$\n$$\nv(t+\\Delta t) = v(t) + \\tfrac{1}{2}\\left[ a(t) + a(t+\\Delta t) \\right] \\Delta t\n$$\nVV 算法是时间可逆和辛的。当与一个作为某个势的精确梯度（即保守力）的力计算相结合时，VV 算法能精确地保守一个邻近的“影子”哈密顿量，从而导致能量在一个恒定值附近有界地波动。然而，这里定义的有限差分力是分段常数，并且通常不是单个平滑势能函数的梯度。因此，能量守恒的质量取决于力近似的性质。对称的中心差分方案预计会产生更优的能量守恒（最小的系统性漂移），而非对称的向前和向后差分方案预计会产生非零的系统性漂移，导致能量随时间稳定增加或减少。这种效应的幅度在更粗的网格（更大的 $h$）上应该更为显著。\n\n我们的实现将对每个测试用例按以下步骤进行：\n1.  **系统设置**：设置参数 $m=1$，$r_{\\min}=-2$，$r_{\\max}=2$，以及初始条件 $r(0)=1.2$，$v(0)=0$。选择该用例特定的方案、网格间距 $h$ 和时间步长 $\\Delta t$。\n2.  **势能列表化**：创建一个从 $r_{\\min}$ 到 $r_{\\max}$，间距为 $h$ 的位置网格 $r_i$。对每个网格点计算并存储势能 $V_{\\text{true}}(r_i)$，创建表格 $V_i$。网格点数为 $n = (r_{\\max} - r_{\\min}) / h + 1$。\n3.  **力函数**：实现一个函数来计算力 $F_{\\text{fd}}(r)$。该函数首先确定网格索引 $i = \\lfloor(r - r_{\\min})/h\\rfloor$。然后进行索引钳制，以确保对 $V_i$ 表的所有查找都在有效范围 $[0, n-1]$ 内。例如，对于中心差分方案，$i$ 被钳制在范围 $[1, n-2]$ 内，以确保 $i-1$ 和 $i+1$ 是有效索引。然后使用钳制后的索引应用相应的有限差分公式。\n4.  **数值积分**：一个循环运行 $N_{\\text{steps}}$ 次迭代。在每次迭代中，速度 Verlet 算法使用步骤3中函数计算出的力来更新粒子的位置和速度。每步之后，使用真实的、连续的势能函数计算总能量 $E(t) = \\tfrac{1}{2}m v^2 + V_{\\text{true}}(r)$。存储时间和对应的能量。\n5.  **漂移分析**：模拟完成后，我们得到一个总能量值的时间序列 $\\{E(t_k)\\}$。对这些数据与时间进行普通最小二乘线性回归，拟合模型 $E(t) = at+b$。得到的斜率 $a = dE/dt$ 为系统性能量漂移提供了一个定量度量。此斜率是每个用例的最终结果。\n\n通过比较得出的漂移率，我们将经验性地验证理论预期，即对称的力离散化对于辛积分方案中的长期能量守恒至关重要。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print the results.\n    \"\"\"\n    \n    # Define physical constants and initial conditions as per the problem.\n    M_PARTICLE = 1.0\n    R_MIN = -2.0\n    R_MAX = 2.0\n    R_INITIAL = 1.2\n    V_INITIAL = 0.0\n\n    # Define the reference potential energy function.\n    def V_true(r):\n        \"\"\"\n        Calculates the true potential energy V_true(r) = 1/4*r^4 - 1/2*r^2.\n        \"\"\"\n        return 0.25 * r**4 - 0.5 * r**2\n\n    def run_simulation(scheme, h, dt, n_steps):\n        \"\"\"\n        Runs a single molecular dynamics simulation for a given set of parameters.\n\n        Args:\n            scheme (str): The force estimation scheme ('centered', 'forward', 'backward').\n            h (float): The grid spacing for the potential tabulation.\n            dt (float): The time step for the Velocity Verlet integrator.\n            n_steps (int): The total number of integration steps.\n\n        Returns:\n            float: The slope of the energy vs. time, representing the energy drift rate.\n        \"\"\"\n        # 1. Tabulate the potential on a uniform grid.\n        # Use round() to avoid float precision issues in calculating n_grid.\n        n_grid = int(round((R_MAX - R_MIN) / h)) + 1\n        r_grid = np.linspace(R_MIN, R_MAX, n_grid)\n        V_grid = V_true(r_grid)\n\n        # 2. Define the force calculation function based on the tabulated potential.\n        def get_force(r_pos):\n            \"\"\"\n            Calculates the force at position r_pos using a finite-difference scheme.\n            Includes index clamping to handle boundary conditions.\n            \"\"\"\n            # Determine the grid cell index for the current position.\n            i_float = (r_pos - R_MIN) / h\n            i = int(np.floor(i_float))\n\n            # Apply index clamping to ensure array access is always valid.\n            if scheme == 'centered':\n                i = np.clip(i, 1, n_grid - 2)\n                force = -(V_grid[i + 1] - V_grid[i - 1]) / (2.0 * h)\n            elif scheme == 'forward':\n                i = np.clip(i, 0, n_grid - 2)\n                force = -(V_grid[i + 1] - V_grid[i]) / h\n            elif scheme == 'backward':\n                i = np.clip(i, 1, n_grid - 1)\n                force = -(V_grid[i] - V_grid[i - 1]) / h\n            else:\n                # This case should not be reached with valid problem inputs.\n                raise ValueError(f\"Unknown scheme: {scheme}\")\n            \n            return force\n\n        # 3. Initialize simulation variables.\n        r = R_INITIAL\n        v = V_INITIAL\n        \n        times = np.arange(n_steps + 1) * dt\n        energies = np.zeros(n_steps + 1)\n        \n        # Store initial energy.\n        energies[0] = 0.5 * M_PARTICLE * v**2 + V_true(r)\n        \n        # Calculate initial acceleration.\n        a = get_force(r) / M_PARTICLE\n\n        # 4. Perform the Velocity Verlet integration.\n        for step in range(n_steps):\n            # Update position.\n            r_new = r + v * dt + 0.5 * a * dt**2\n            \n            # Update force/acceleration at the new position.\n            a_new = get_force(r_new) / M_PARTICLE\n            \n            # Update velocity.\n            v_new = v + 0.5 * (a + a_new) * dt\n            \n            # Update state for the next iteration.\n            r, v, a = r_new, v_new, a_new\n            \n            # Calculate and store the total energy using the true potential.\n            energies[step + 1] = 0.5 * M_PARTICLE * v**2 + V_true(r)\n\n        # 5. Quantify energy drift via linear regression.\n        # np.polyfit(x, y, 1) returns [slope, intercept] for a linear fit.\n        slope, _ = np.polyfit(times, energies, 1)\n        \n        return slope\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (happy path, fine grid, symmetric force)\n        {'scheme': 'centered', 'h': 0.02, 'dt': 0.02, 'n_steps': 30000},\n        # Case 2 (fine grid, asymmetric forward force)\n        {'scheme': 'forward',  'h': 0.02, 'dt': 0.02, 'n_steps': 30000},\n        # Case 3 (fine grid, asymmetric backward force)\n        {'scheme': 'backward', 'h': 0.02, 'dt': 0.02, 'n_steps': 30000},\n        # Case 4 (coarse grid, symmetric force)\n        {'scheme': 'centered', 'h': 0.20, 'dt': 0.02, 'n_steps': 30000},\n        # Case 5 (coarse grid, asymmetric forward force)\n        {'scheme': 'forward',  'h': 0.20, 'dt': 0.02, 'n_steps': 30000},\n        # Case 6 (coarse grid, asymmetric backward force)\n        {'scheme': 'backward', 'h': 0.20, 'dt': 0.02, 'n_steps': 30000},\n    ]\n\n    results = []\n    for case in test_cases:\n        drift_rate = run_simulation(case['scheme'], case['h'], case['dt'], case['n_steps'])\n        results.append(drift_rate)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.6e}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了稳健的速度 Verlet 方法之后，这个高级实践将解决一个实际挑战：如何选择最优的时间步长。你将实现一个自适应步长方案，该方案通过控制局部误差来动态调整 $\\Delta t$。通过这个过程，你将揭示几何积分中的一个深刻概念：改变时间步长会破坏算法的辛性，从而牺牲了卓越的长期能量守恒性来换取局部精度控制。这个练习阐明了在模拟中效率、准确性和基本守恒定律之间的微妙平衡。",
            "id": "3412413",
            "problem": "您将使用速度 Verlet (VV) 方法，实现并分析经典动力学的自适应时间步长方法。从牛顿第二运动定律出发，在分子动力学中典型的简化无量纲单位制下进行研究，其中质量和势能参数均被归一化。您的任务结合了原理推导、算法设计以及对长时间能量行为的定量评估。\n\n使用以下物理设置和单位约定：\n- 该系统是一个一维谐振子，其质量为 $m$，弹簧常数为 $k$，受力满足 $F(x) = -kx$，并且在简化单位制下 $m=1$，$k=1$。\n- 系统的状态由位置 $x(t)$ 和速度 $v(t)$ 描述，总能量在无量纲单位下为 $E(t) = \\tfrac{1}{2} m v(t)^2 + \\tfrac{1}{2} k x(t)^2$。\n\n必需的算法组件：\n1. 从 $m \\ddot{x} = F(x)$ 推导出速度 Verlet (VV) 积分器的显式更新规则，然后实现它。\n2. 通过比较一个大小为 $\\Delta t$ 的完整 VV 步和两个大小为 $\\Delta t/2$ 的连续 VV 半步（两者均从相同的当前状态 $(x,v)$ 开始），实现一个局部误差估计器。将局部误差定义为状态空间范数\n$$ e = \\sqrt{\\left(x_{\\mathrm{full}} - x_{\\mathrm{half}}\\right)^2 + \\left(\\Delta t(v_{\\mathrm{full}} - v_{\\mathrm{half}})\\right)^2} $$,\n该范数使用当前的 $\\Delta t$ 来平衡位置和速度的差异，使得两项都具有位置的单位。\n3. 实现一个由估计的局部误差 $e$ 和容差 $\\varepsilon$ 驱动的自适应时间步长控制器：\n   - 如果 $e \\le \\varepsilon$，则接受该步，并将时间推进 $\\Delta t$。使用两个半步得到的状态 $(x_{\\mathrm{half}},v_{\\mathrm{half}})$ 作为接受的下一状态。\n   - 如果 $e > \\varepsilon$，则拒绝该步，将 $\\Delta t$ 减小一个因子 $r_{\\downarrow}$，并从相同的当前状态重新计算，时间不推进。\n   - 在接受一个步长后，如果 $e  \\varepsilon/2$，则为下一次提议将 $\\Delta t$ 增加一个因子 $r_{\\uparrow}$；否则，保持 $\\Delta t$ 不变。\n   - 在任何时候都强制要求 $\\Delta t \\in [\\Delta t_{\\min}, \\Delta t_{\\max}]$。\n4. 与此同时，运行一个基准的固定步长 VV 模拟，使用初始步长 $\\Delta t_0$，不进行任何自适应调整。\n5. 通过对整个模拟区间内的 $E(t)$ 与 $t$ 的关系进行直线拟合，并取斜率的绝对值，来量化自适应和固定步长两种运行方式的长时间能量漂移。即，计算最小二乘拟合参数 $(\\alpha,\\beta)$ 以最小化 $\\sum_i \\left(E(t_i) - (\\alpha t_i + \\beta)\\right)^2$，并将 $D = |\\alpha|$ 作为单位时间内的能量漂移率（无量纲）进行报告。\n6. 在您的解决方案中，讨论当 $\\Delta t$ 变化时破坏辛性的代价，并将其与观察到的能量漂移联系起来。\n\n模拟与单位：\n- 使用 $m=1$ 和 $k=1$ 的简化无量纲单位制，因此时间、位置、速度和能量都是无量纲的。\n- 以无量纲能量每单位时间表示最终的能量漂移率 $D$。\n\n测试套件：\n对于每个测试用例，从相同的初始条件 $(x(0),v(0))$ 和总模拟时间 $T$ 开始，运行自适应和固定步长两种模拟，并报告下面指定的三个指标。使用以下参数集：\n\n- 测试用例 1：$T=200$, $x(0)=1$, $v(0)=0$, $\\Delta t_0=0.1$, $\\varepsilon=10^{-5}$, $\\Delta t_{\\min}=10^{-4}$, $\\Delta t_{\\max}=0.3$, $r_{\\uparrow}=1.25$, $r_{\\downarrow}=0.5$。\n- 测试用例 2：$T=50$, $x(0)=1$, $v(0)=0$, $\\Delta t_0=0.05$, $\\varepsilon=10^{-8}$, $\\Delta t_{\\min}=10^{-5}$, $\\Delta t_{\\max}=0.2$, $r_{\\uparrow}=1.25$, $r_{\\downarrow}=0.5$。\n- 测试用例 3：$T=200$, $x(0)=1$, $v(0)=0$, $\\Delta t_0=0.1$, $\\varepsilon=10^{-3}$, $\\Delta t_{\\min}=10^{-4}$, $\\Delta t_{\\max}=0.5$, $r_{\\uparrow}=1.25$, $r_{\\downarrow}=0.5$。\n- 测试用例 4：$T=200$, $x(0)=1$, $v(0)=0$, $\\Delta t_0=0.2$, $\\varepsilon=5\\times 10^{-4}$, $\\Delta t_{\\min}=10^{-4}$, $\\Delta t_{\\max}=0.8$, $r_{\\uparrow}=1.25, r_{\\downarrow}=0.5$。\n\n最终输出格式：\n- 对于每个测试用例 $j$，计算：\n  1. $D_{\\mathrm{adapt}}^{(j)}$：自适应 VV 运行的绝对能量漂移率。\n  2. $D_{\\mathrm{fixed}}^{(j)}$：固定步长 VV 运行的绝对能量漂移率。\n  3. $\\langle \\Delta t \\rangle^{(j)}$：自适应 VV 运行中的平均接受步长。\n- 您的程序应生成单行输出，其中包含所有结果，形式为一个逗号分隔的列表，包含在方括号内，并按测试用例 $j=1,2,3,4$ 的顺序展开：\n$$ \\bigl[D_{\\mathrm{adapt}}^{(1)},\\,D_{\\mathrm{fixed}}^{(1)},\\,\\langle \\Delta t \\rangle^{(1)},\\,D_{\\mathrm{adapt}}^{(2)},\\,D_{\\mathrm{fixed}}^{(2)},\\,\\langle \\Delta t \\rangle^{(2)},\\,D_{\\mathrm{adapt}}^{(3)},\\,D_{\\mathrm{fixed}}^{(3)},\\,\\langle \\Delta t \\rangle^{(3)},\\,D_{\\mathrm{adapt}}^{(4)},\\,D_{\\mathrm{fixed}}^{(4)},\\,\\langle \\Delta t \\rangle^{(4)}\\bigr] $$,.\n所有量都是无量纲浮点数。",
            "solution": "该问题要求实现并分析应用于一维谐振子的速度 Verlet (VV) 积分器的自适应时间步长方案。该自adaptive方案的性能将与标准的固定步长 VV 模拟进行比较，重点关注长期能量守恒。\n\n该系统是一个质量为 $m=1$ 的粒子，在简化的无量纲单位制中受到线性恢复力 $F(x) = -kx$（弹簧常数 $k=1$）的作用。总能量是动能和势能之和：\n$$\nE(t) = \\frac{1}{2} m v(t)^2 + \\frac{1}{2} k x(t)^2 = \\frac{1}{2} v(t)^2 + \\frac{1}{2} x(t)^2\n$$\n\n首先，我们推导速度 Verlet 积分器的更新规则。该算法源于位置 $x(t)$ 和速度 $v(t)$ 的泰勒级数展开。\n位置在时间 $t+\\Delta t$ 的二阶展开式为：\n$$\nx(t+\\Delta t) = x(t) + v(t)\\Delta t + \\frac{1}{2} a(t) \\Delta t^2 + \\mathcal{O}(\\Delta t^3)\n$$\n其中 $v(t) = \\dot{x}(t)$ 是速度，$a(t) = \\ddot{x}(t) = F(x(t))/m$ 是加速度。\n\n速度更新的构造是时间对称的，这是该算法稳定性及其辛特性的关键。我们使用梯形法则来近似速度积分，对时间步开始和结束时的加速度进行平均：\n$$\nv(t+\\Delta t) = v(t) + \\int_{t}^{t+\\Delta t} a(\\tau) d\\tau \\approx v(t) + \\frac{1}{2}\\left[ a(t) + a(t+\\Delta t) \\right] \\Delta t\n$$\n其中 $a(t+\\Delta t) = F(x(t+\\Delta t))/m$。这导出了以下广泛使用的单步速度 Verlet 实现：\n1.  从时间 $t_n=t$ 的状态计算新位置 $x_{n+1} = x(t+\\Delta t)$：\n    $$x_{n+1} = x_n + v_n \\Delta t + \\frac{1}{2} a_n \\Delta t^2$$\n2.  使用新位置计算新加速度 $a_{n+1}$：\n    $$a_{n+1} = \\frac{F(x_{n+1})}{m}$$\n3.  计算新速度 $v_{n+1} = v(t+\\Delta t)$：\n    $$v_{n+1} = v_n + \\frac{1}{2} (a_n + a_{n+1}) \\Delta t$$\n该算法是时间可逆的，并且对于固定的步长 $\\Delta t$，是辛的。\n\n接下来，我们设计自适应时间步长方案。核心思想是估计单步的局部截断误差，并调整 $\\Delta t$ 以使该误差低于指定的容差 $\\varepsilon$。一种常见的误差估计方法是比较一个大小为 $\\Delta t$ 的步长的结果与两个大小为 $\\Delta t/2$ 的步长的结果。\n设时间 $t$ 的状态为 $(x, v)$。\n-   一个大小为 $\\Delta t$ 的“完整”步长产生状态 $(x_{\\mathrm{full}}, v_{\\mathrm{full}})$。\n-   两个连续的大小为 $\\Delta t/2$ 的“半”步长产生状态 $(x_{\\mathrm{half}}, v_{\\mathrm{half}})$。\n两个半步的结果更精确。这两个计算出的状态之间的差异提供了局部误差的估计。问题定义了一个特定的标量误差度量 $e$：\n$$\ne = \\sqrt{\\left(x_{\\mathrm{full}} - x_{\\mathrm{half}}\\right)^2 + \\left(\\Delta t(v_{\\mathrm{full}} - v_{\\mathrm{half}})\\right)^2}\n$$\n速度项中的因子 $\\Delta t$ 确保两项都具有位置的单位，从而提供了一个平衡的状态空间误差范数。\n\n对于一个提议的步长 $\\Delta t$，步长控制器按以下方式操作：\n1.  如果估计误差 $e$ 大于容差 $\\varepsilon$ ($e > \\varepsilon$)，则拒绝该步。时间步长减小，$\\Delta t \\to \\Delta t \\times r_{\\downarrow}$，并从相同的初始状态重新尝试该步。时间不前进。\n2.  如果误差在容差范围内 ($e \\le \\varepsilon$)，则接受该步。系统状态推进到更精确的半步结果，$(x, v) \\to (x_{\\mathrm{half}}, v_{\\mathrm{half}})$，时间前进 $\\Delta t$。\n3.  在接受一个步长后，会调整下一次提议的步长。如果误差足够小，$e  \\varepsilon/2$，则增加步长：$\\Delta t \\to \\Delta t \\times r_{\\uparrow}$。否则，保持不变。\n4.  在任何时候，步长都被限制在范围 $[\\Delta t_{\\min}, \\Delta t_{\\max}]$ 内。\n\n该问题的一个关键方面是局部精度和长期稳定性之间的权衡。固定步长的速度 Verlet 积分器是辛的。对于哈密顿系统，这意味着它精确地守恒一个“影子”哈密顿量 $H_{\\Delta t}$，它接近于真实的哈密顿量 $H$。此特性导致在非常长的模拟中，能量在一个恒定值附近有界波动，并且没有系统性的能量漂移。当时间步长 $\\Delta t$ 如我们的自适应方案中那样变化时，积分器在每一步都在不同的辛映射之间切换，每个辛映射对应一个不同的影子哈密頓量。这些映射的复合不再是辛的。因此，没有单一的影子哈密顿量被守恒，从而丧失了优异的长期能量守恒性。这通常表现为总能量的系统性线性漂移，即使每一步的局部误差都得到了控制。\n\n为了量化这一点，我们将自适应模拟与使用初始步长 $\\Delta t_0$ 的基准固定步长模拟进行比较。对于这两种运行方式，我们通过对能量数据 $E(t_i)$ 与时间 $t_i$ 进行线性最小二乘拟合来计算能量漂移率 $D$。漂移 $D$ 是此拟合斜率的绝对值，$D=|\\alpha|$，其中拟合公式为 $E(t) = \\alpha t + \\beta$。我们预期 $D_{\\mathrm{fixed}}$ 会非常接近于零（反映了有界振荡），而 $D_{\\mathrm{adapt}}$ 会更大，这表明了破坏辛性引起的能量漂移。我们还计算自适应运行的平均接受时间步长 $\\langle \\Delta t \\rangle$ 以评估其效率。\n\n该实现将对每个测试用例模拟系统，运行自适应和固定步长两种方案。然后它将计算指定的三个指标 ($D_{\\mathrm{adapt}}$, $D_{\\mathrm{fixed}}$, $\\langle \\Delta t \\rangle$) 并按要求的格式报告它们。线性拟合使用 NumPy 的 `polyfit` 函数执行。所有模拟都在指定的无量纲单位制下进行。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy is not needed, numpy.polyfit is sufficient.\n\ndef solve():\n    \"\"\"\n    Main function to run the simulations and print the final results.\n    \"\"\"\n    # Define physical constants in reduced units\n    M_MASS = 1.0\n    K_SPRING = 1.0\n\n    def force(x):\n        \"\"\"Calculates the force F(x) = -kx for the harmonic oscillator.\"\"\"\n        return -K_SPRING * x\n\n    def energy(x, v):\n        \"\"\"Calculates the total energy E = 1/2*m*v^2 + 1/2*k*x^2.\"\"\"\n        return 0.5 * M_MASS * v**2 + 0.5 * K_SPRING * x**2\n\n    def vv_step(x, v, dt):\n        \"\"\"\n        Performs a single step of the Velocity Verlet algorithm.\n        \"\"\"\n        a = force(x) / M_MASS\n        x_new = x + v * dt + 0.5 * a * dt**2\n        a_new = force(x_new) / M_MASS\n        v_new = v + 0.5 * (a + a_new) * dt\n        return x_new, v_new\n\n    def run_fixed_step(x0, v0, T, dt0):\n        \"\"\"\n        Runs a simulation with a fixed time step.\n        \"\"\"\n        t = 0.0\n        x, v = x0, v0\n        \n        times = [t]\n        energies = [energy(x, v)]\n        \n        while t  T:\n            # Ensure the last step hits T exactly\n            current_dt = min(dt0, T - t)\n            if current_dt  1e-12: break\n            \n            x, v = vv_step(x, v, current_dt)\n            t += current_dt\n            \n            times.append(t)\n            energies.append(energy(x, v))\n            \n        return np.array(times), np.array(energies)\n\n    def run_adaptive_step(x0, v0, T, dt0, eps, dt_min, dt_max, r_up, r_down):\n        \"\"\"\n        Runs a simulation with an adaptive time step.\n        \"\"\"\n        t = 0.0\n        x, v = x0, v0\n        dt = dt0\n        \n        times = [t]\n        energies = [energy(x, v)]\n        accepted_dts = []\n\n        while t  T:\n            actual_dt = min(dt, T - t)\n            \n            # Failsafe for the very last, potentially tiny step\n            if actual_dt  1e-12:\n                break\n\n            step_accepted = False\n            while not step_accepted:\n                # One full step\n                x_full, v_full = vv_step(x, v, actual_dt)\n                \n                # Two half steps\n                x_mid, v_mid = vv_step(x, v, actual_dt / 2.0)\n                x_half, v_half = vv_step(x_mid, v_mid, actual_dt / 2.0)\n\n                # Calculate local error\n                error = np.sqrt((x_full - x_half)**2 + (actual_dt * (v_full - v_half))**2)\n\n                if error = eps:  # Accept step\n                    step_accepted = True\n                    \n                    # Advance to new state using more accurate half-step result\n                    t += actual_dt\n                    x, v = x_half, v_half\n                    \n                    times.append(t)\n                    energies.append(energy(x, v))\n                    accepted_dts.append(actual_dt)\n                    \n                    # Update dt for the NEXT proposal\n                    if error  eps / 2.0 and dt  dt_max:\n                        dt_proposal = dt * r_up\n                    else:\n                        dt_proposal = dt\n                    \n                    dt = min(dt_max, dt_proposal)\n\n                else:  # Reject step\n                    dt_proposal = dt * r_down\n                    dt = max(dt_min, dt_proposal)\n                    actual_dt = min(dt, T - t) # Update dt for retry\n                    if actual_dt  1e-12: # Avoid infinite loop if dt becomes too small\n                        step_accepted = True # effectively give up and finish\n                        t = T \n\n        return np.array(times), np.array(energies), np.array(accepted_dts)\n\n    def calculate_drift(times, energies):\n        \"\"\"\n        Calculates the energy drift rate |alpha| from a linear fit E(t) = alpha*t + beta.\n        \"\"\"\n        if len(times)  2:\n            return 0.0\n        slope, _ = np.polyfit(times, energies, 1)\n        return abs(slope)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # T, x0, v0, dt0, eps, dt_min, dt_max, r_up, r_down\n        (200.0, 1.0, 0.0, 0.1, 1e-5, 1e-4, 0.3, 1.25, 0.5),\n        (50.0, 1.0, 0.0, 0.05, 1e-8, 1e-5, 0.2, 1.25, 0.5),\n        (200.0, 1.0, 0.0, 0.1, 1e-3, 1e-4, 0.5, 1.25, 0.5),\n        (200.0, 1.0, 0.0, 0.2, 5e-4, 1e-4, 0.8, 1.25, 0.5),\n    ]\n\n    results = []\n    for case in test_cases:\n        T, x0, v0, dt0, eps, dt_min, dt_max, r_up, r_down = case\n        \n        # Adaptive run\n        t_adapt, E_adapt, dts_adapt = run_adaptive_step(x0, v0, T, dt0, eps, dt_min, dt_max, r_up, r_down)\n        D_adapt = calculate_drift(t_adapt, E_adapt)\n        avg_dt = np.mean(dts_adapt) if len(dts_adapt) > 0 else 0.0\n\n        # Fixed-step run\n        t_fixed, E_fixed = run_fixed_step(x0, v0, T, dt0)\n        D_fixed = calculate_drift(t_fixed, E_fixed)\n        \n        results.extend([D_adapt, D_fixed, avg_dt])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}