{
    "hands_on_practices": [
        {
            "introduction": "任何数值积分方案的基础分析都是评估其局部精度。本练习将通过经典的泰勒级数展开法，引导你推导Beeman积分器在单个时间步长内的局部截断误差。通过将积分器的公式与真实轨迹的精确展开进行比较，我们可以量化其误差项，从而确定其精度阶数。这项基本技能对于理解为何Beeman这类积分器在局部精度上优于更简单的方法（如Verlet算法）至关重要 。",
            "id": "3396862",
            "problem": "考虑一个质量为 $m$ 的单个经典粒子在一维空间中演化，其受一个光滑力 $F(x,t)$ 的作用，因此牛顿第二定律给出 $m\\,\\ddot{x}(t)=F(x(t),t)$。定义加速度 $a(t)=\\ddot{x}(t)$、加加速度（jerk）$j(t)=\\dot{a}(t)$ 和加加加速度（snap）$s(t)=\\ddot{a}(t)$。假设 $a(t)$ 足够光滑，以至于所有达到所需阶数的时间导数都存在且有界。分子动力学中使用的 Beeman 积分器是一种两步预测-校正方案。在其常用的校正形式中，位置和速度在一个恒定时间步长 $h0$ 内的更新由下式给出：\n$$\nx_{\\mathrm{B}}(t+h)=x(t)+v(t)\\,h+\\left(\\frac{2}{3}\\,a(t)-\\frac{1}{6}\\,a(t-h)\\right)h^{2},\n$$\n$$\nv_{\\mathrm{B}}(t+h)=v(t)+\\frac{h}{6}\\left(2\\,a(t+h)+5\\,a(t)-a(t-h)\\right),\n$$\n其中 $v(t)=\\dot{x}(t)$，$a(\\cdot)$ 是根据指定时间的力计算得出的。为了进行局部截断误差分析，将 $a(t\\pm h)$ 理解为在精确轨迹上 $t\\pm h$ 时刻的精确加速度。\n\n仅使用牛顿第二定律、定义 $v=\\dot{x}$、$a=\\ddot{x}$、$j=\\dot{a}$、$s=\\ddot{a}$ 以及关于时间 $t$ 的泰勒展开，推导位置和速度更新的主阶局部截断误差，它们分别定义为：\n$$\n\\Delta x_{\\mathrm{loc}}=x(t+h)-x_{\\mathrm{B}}(t+h),\\qquad \\Delta v_{\\mathrm{loc}}=v(t+h)-v_{\\mathrm{B}}(t+h),\n$$\n用加加加速度 $s(t)$ 表示，直到并包括 $h$ 的幂次中的第一个非零项。然后，提取由下式定义的相应无量纲误差常数 $C_{x}$ 和 $C_{v}$：\n$$\n\\Delta x_{\\mathrm{loc}}=C_{x}\\,s(t)\\,h^{4}+\\mathcal{O}\\!\\left(h^{5}\\right),\\qquad \\Delta v_{\\mathrm{loc}}=C_{v}\\,s(t)\\,h^{3}+\\mathcal{O}\\!\\left(h^{4}\\right).\n$$\n以有序对 $\\left(C_{x},\\,C_{v}\\right)$ 的形式报告您的最终答案。无需进行数值计算。按规定将最终答案表示为单个复合表达式。如果您引入任何中间截断级数，请保持常数为符号形式，不要代入方案中已存在的数值以外的任何数值。最终答案必须以一对精确有理数的形式给出。误差常数不需要单位。",
            "solution": "用户希望我扮演一位一丝不苟的STEM教授。我的任务是首先验证所给的问题陈述。如果有效，我必须提供详细的解答。如果无效，我必须解释其缺陷。整个输出必须遵守严格的格式规则，特别是对所有数学实体使用LaTeX。\n\n### 问题验证\n\n**第 1 步：提取已知条件**\n\n*   粒子质量：$m$\n*   力：$F(x, t)$\n*   运动方程：$m\\,\\ddot{x}(t)=F(x(t),t)$\n*   时间导数的定义：$v(t)=\\dot{x}(t)$, $a(t)=\\ddot{x}(t)$, $j(t)=\\dot{a}(t)$, $s(t)=\\ddot{a}(t)$\n*   光滑性假设：$a(t)$ 足够光滑，以使所需阶数的导数存在且有界。\n*   时间步长：$h0$ 是一个常数。\n*   Beeman 积分器位置更新：$x_{\\mathrm{B}}(t+h)=x(t)+v(t)\\,h+\\left(\\frac{2}{3}\\,a(t)-\\frac{1}{6}\\,a(t-h)\\right)h^{2}$\n*   Beeman 积分器速度更新：$v_{\\mathrm{B}}(t+h)=v(t)+\\frac{h}{6}\\left(2\\,a(t+h)+5\\,a(t)-a(t-h)\\right)$\n*   局部截断误差分析假设：$a(t\\pm h)$ 是在 $t\\pm h$ 时刻的精确加速度。\n*   局部截断误差定义：$\\Delta x_{\\mathrm{loc}}=x(t+h)-x_{\\mathrm{B}}(t+h)$ 和 $\\Delta v_{\\mathrm{loc}}=v(t+h)-v_{\\mathrm{B}}(t+h)$。\n*   目标：推导截断误差的主阶项，即在表达式 $\\Delta x_{\\mathrm{loc}}=C_{x}\\,s(t)\\,h^{4}+\\mathcal{O}\\!\\left(h^{5}\\right)$ 和 $\\Delta v_{\\mathrm{loc}}=C_{v}\\,s(t)\\,h^{3}+\\mathcal{O}\\!\\left(h^{4}\\right)$ 中找到无量纲常数 $C_{x}$ 和 $C_{v}$。\n\n**第 2 步：使用提取的已知条件进行验证**\n\n*   **科学基础：** 该问题牢固地植根于经典力学和数值分析。Beeman 积分器是分子动力学模拟的标准算法，其通过泰勒级数进行的局部截断误差分析是经典程序。\n*   **适定性：** 该问题是适定的。它提供了积分器的具体形式，定义了所有术语，并指定了所需答案的确切形式。误差常数存在唯一解。\n*   **客观性：** 该问题以精确、客观的数学语言陈述，没有歧义或主观论断。\n*   **完整性和一致性：** 所有必要信息均已提供。将 $a(t\\pm h)$ 视为精确值的明确指令适当地简化了分析，以便检查校正步骤的内在误差。不存在矛盾。\n\n**第 3 步：结论与行动**\n\n该问题是**有效的**，因为它在科学上是合理的、适定的、客观的和自洽的。我现在将继续推导解答。\n\n### 截断误差的推导\n\n目标是确定 Beeman 积分器给出的位置和速度的局部截断误差。这通过将精确解的泰勒级数展开与数值方案的展开进行比较来实现。\n\n我们首先写出精确位置 $x(t+h)$ 和精确速度 $v(t+h)$ 在时间 $t$ 附近的泰勒级数展开。使用所给的定义，我们有：\n$\\dot{x}(t) = v(t)$\n$\\ddot{x}(t) = a(t)$\n$\\dddot{x}(t) = \\dot{a}(t) = j(t)$\n$x^{(4)}(t) = \\ddot{a}(t) = s(t)$\n$x^{(5)}(t) = \\dot{s}(t)$\n\n精确位置的展开式为：\n$$x(t+h) = x(t) + h\\dot{x}(t) + \\frac{h^2}{2!}\\ddot{x}(t) + \\frac{h^3}{3!}\\dddot{x}(t) + \\frac{h^4}{4!}x^{(4)}(t) + \\mathcal{O}(h^5)$$\n$$x(t+h) = x(t) + v(t)h + \\frac{1}{2}a(t)h^2 + \\frac{1}{6}j(t)h^3 + \\frac{1}{24}s(t)h^4 + \\mathcal{O}(h^5)$$\n\n类似地，对于精确速度：\n$\\dot{v}(t) = a(t)$\n$\\ddot{v}(t) = \\dot{a}(t) = j(t)$\n$\\dddot{v}(t) = \\ddot{a}(t) = s(t)$\n\n精确速度的展开式为：\n$$v(t+h) = v(t) + h\\dot{v}(t) + \\frac{h^2}{2!}\\ddot{v}(t) + \\frac{h^3}{3!}\\dddot{v}(t) + \\mathcal{O}(h^4)$$\n$$v(t+h) = v(t) + a(t)h + \\frac{1}{2}j(t)h^2 + \\frac{1}{6}s(t)h^3 + \\mathcal{O}(h^4)$$\n\n接下来，我们展开 Beeman 积分器更新中的各项。\n\n**位置误差分析**\nBeeman 位置更新公式为：\n$$x_{\\mathrm{B}}(t+h) = x(t)+v(t)\\,h+\\left(\\frac{2}{3}\\,a(t)-\\frac{1}{6}\\,a(t-h)\\right)h^{2}$$\n为分析此式，我们需要 $a(t-h)$ 在 $t$ 附近的泰勒展开：\n$$a(t-h) = a(t) - j(t)h + \\frac{1}{2}s(t)h^2 + \\mathcal{O}(h^3)$$\n将此代入 $x_{\\mathrm{B}}(t+h)$ 表达式的括号项中：\n$$\\left(\\frac{2}{3}\\,a(t)-\\frac{1}{6}\\,a(t-h)\\right) = \\frac{2}{3}a(t) - \\frac{1}{6}\\left(a(t) - j(t)h + \\frac{1}{2}s(t)h^2 + \\mathcal{O}(h^3)\\right)$$\n$$= \\frac{2}{3}a(t) - \\frac{1}{6}a(t) + \\frac{1}{6}j(t)h - \\frac{1}{12}s(t)h^2 + \\mathcal{O}(h^3)$$\n$$= \\left(\\frac{4-1}{6}\\right)a(t) + \\frac{1}{6}j(t)h - \\frac{1}{12}s(t)h^2 + \\mathcal{O}(h^3)$$\n$$= \\frac{1}{2}a(t) + \\frac{1}{6}j(t)h - \\frac{1}{12}s(t)h^2 + \\mathcal{O}(h^3)$$\n现在，我们将其乘以 $h^2$ 并代回 $x_{\\mathrm{B}}(t+h)$ 的表达式中：\n$$x_{\\mathrm{B}}(t+h) = x(t) + v(t)h + \\left(\\frac{1}{2}a(t) + \\frac{1}{6}j(t)h - \\frac{1}{12}s(t)h^2 + \\mathcal{O}(h^3)\\right)h^2$$\n$$x_{\\mathrm{B}}(t+h) = x(t) + v(t)h + \\frac{1}{2}a(t)h^2 + \\frac{1}{6}j(t)h^3 - \\frac{1}{12}s(t)h^4 + \\mathcal{O}(h^5)$$\n位置的局部截断误差为 $\\Delta x_{\\mathrm{loc}} = x(t+h) - x_{\\mathrm{B}}(t+h)$。\n$$\\Delta x_{\\mathrm{loc}} = \\left(x(t) + v(t)h + \\frac{1}{2}a(t)h^2 + \\frac{1}{6}j(t)h^3 + \\frac{1}{24}s(t)h^4 + \\mathcal{O}(h^5)\\right) - \\left(x(t) + v(t)h + \\frac{1}{2}a(t)h^2 + \\frac{1}{6}j(t)h^3 - \\frac{1}{12}s(t)h^4 + \\mathcal{O}(h^5)\\right)$$\n逐项相减，我们发现直到 $h^3$ 阶的项都抵消了。\n$$\\Delta x_{\\mathrm{loc}} = \\left(\\frac{1}{24}s(t)h^4\\right) - \\left(-\\frac{1}{12}s(t)h^4\\right) + \\mathcal{O}(h^5)$$\n$$\\Delta x_{\\mathrm{loc}} = \\left(\\frac{1}{24} + \\frac{2}{24}\\right)s(t)h^4 + \\mathcal{O}(h^5) = \\frac{3}{24}s(t)h^4 + \\mathcal{O}(h^5)$$\n$$\\Delta x_{\\mathrm{loc}} = \\frac{1}{8}s(t)h^4 + \\mathcal{O}(h^5)$$\n通过与所需形式 $\\Delta x_{\\mathrm{loc}}=C_{x}\\,s(t)\\,h^{4}+\\mathcal{O}(h^{5})$ 比较，我们确定常数 $C_x$ 为：\n$$C_x = \\frac{1}{8}$$\n\n**速度误差分析**\nBeeman 速度更新公式为：\n$$v_{\\mathrm{B}}(t+h) = v(t)+\\frac{h}{6}\\left(2\\,a(t+h)+5\\,a(t)-a(t-h)\\right)$$\n为分析此式，我们需要 $a(t+h)$ 和 $a(t-h)$ 在 $t$ 附近的泰勒展开：\n$$a(t+h) = a(t) + j(t)h + \\frac{1}{2}s(t)h^2 + \\mathcal{O}(h^3)$$\n$$a(t-h) = a(t) - j(t)h + \\frac{1}{2}s(t)h^2 + \\mathcal{O}(h^3)$$\n将这些代入 $v_{\\mathrm{B}}(t+h)$ 表达式的括号项中：\n$$2a(t+h)+5a(t)-a(t-h) = 2\\left(a(t) + j(t)h + \\frac{1}{2}s(t)h^2\\right) + 5a(t) - \\left(a(t) - j(t)h + \\frac{1}{2}s(t)h^2\\right) + \\mathcal{O}(h^3)$$\n我们按 $a(t)$ 的导数对各项进行分组：\n$a(t)$ 的系数：$2+5-1 = 6$\n$j(t)h$ 的系数：$2 - (-1) = 3$\n$s(t)h^2$ 的系数：$2 \\cdot \\frac{1}{2} - \\frac{1}{2} = 1 - \\frac{1}{2} = \\frac{1}{2}$\n因此该表达式变为：\n$$6a(t) + 3j(t)h + \\frac{1}{2}s(t)h^2 + \\mathcal{O}(h^3)$$\n现在，我们将其代回 $v_{\\mathrm{B}}(t+h)$ 的公式中：\n$$v_{\\mathrm{B}}(t+h) = v(t) + \\frac{h}{6}\\left(6a(t) + 3j(t)h + \\frac{1}{2}s(t)h^2 + \\mathcal{O}(h^3)\\right)$$\n$$v_{\\mathrm{B}}(t+h) = v(t) + a(t)h + \\frac{3}{6}j(t)h^2 + \\frac{1}{12}s(t)h^3 + \\mathcal{O}(h^4)$$\n$$v_{\\mathrm{B}}(t+h) = v(t) + a(t)h + \\frac{1}{2}j(t)h^2 + \\frac{1}{12}s(t)h^3 + \\mathcal{O}(h^4)$$\n速度的局部截断误差为 $\\Delta v_{\\mathrm{loc}} = v(t+h) - v_{\\mathrm{B}}(t+h)$。\n$$\\Delta v_{\\mathrm{loc}} = \\left(v(t) + a(t)h + \\frac{1}{2}j(t)h^2 + \\frac{1}{6}s(t)h^3 + \\mathcal{O}(h^4)\\right) - \\left(v(t) + a(t)h + \\frac{1}{2}j(t)h^2 + \\frac{1}{12}s(t)h^3 + \\mathcal{O}(h^4)\\right)$$\n逐项相减，我们发现直到 $h^2$ 阶的项都抵消了。\n$$\\Delta v_{\\mathrm{loc}} = \\left(\\frac{1}{6}s(t)h^3\\right) - \\left(\\frac{1}{12}s(t)h^3\\right) + \\mathcal{O}(h^4)$$\n$$\\Delta v_{\\mathrm{loc}} = \\left(\\frac{2}{12} - \\frac{1}{12}\\right)s(t)h^3 + \\mathcal{O}(h^4)$$\n$$\\Delta v_{\\mathrm{loc}} = \\frac{1}{12}s(t)h^3 + \\mathcal{O}(h^4)$$\n通过与所需形式 $\\Delta v_{\\mathrm{loc}}=C_{v}\\,s(t)\\,h^{3}+\\mathcal{O}(h^{4})$ 比较，我们确定常数 $C_v$ 为：\n$$C_v = \\frac{1}{12}$$\n\n无量纲误差常数的有序对为 $\\left(C_{x},\\,C_{v}\\right) = \\left(\\frac{1}{8},\\,\\frac{1}{12}\\right)$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{1}{8}  \\frac{1}{12}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "局部高精度并不总能保证在长时间模拟中的良好表现，尤其是在要求能量守恒的微正则系综（NVE）模拟中。本练习将探讨一个更深层次的几何性质：辛性，它与相空间体积的守恒直接相关。通过分析Beeman积分器在谐振子这一基本模型上的作用，并计算其增强相空间映射的雅可比行列式，你将揭示该算法一个深刻的结构特性，并理解其对长期能量漂移的影响 。",
            "id": "3396840",
            "problem": "考虑一个质量为 $m$、弹簧常数为 $k$ 的一维 ($1$D) 谐振子，其遵循牛顿第二定律 $m \\ddot{x}(t) = -k x(t)$。令 $\\omega \\equiv \\sqrt{k/m}$ 且 $a(t) \\equiv \\ddot{x}(t)$，因此有 $a(t) = -\\omega^{2} x(t)$。在一个具有固定时间步长 $\\Delta t$ 的分子动力学 (MD) 时间离散化中，应用标准的 Beeman 预测-校正方案，该方案根据加速度历史来更新位置和速度：\n$$\nx_{n+1} = x_{n} + v_{n} \\Delta t + \\frac{2}{3} a_{n} \\Delta t^{2} - \\frac{1}{6} a_{n-1} \\Delta t^{2},\n$$\n$$\nv_{n+1} = v_{n} + \\frac{1}{3} a_{n+1} \\Delta t + \\frac{5}{6} a_{n} \\Delta t - \\frac{1}{6} a_{n-1} \\Delta t,\n$$\n其中 $a_{n} = -\\omega^{2} x_{n}$ 且 $a_{n+1} = -\\omega^{2} x_{n+1}$。为了使单步映射具有马尔可夫性，引入增广状态向量 $y_{n} \\equiv (x_{n}, v_{n}, x_{n-1})^{\\top}$，从而 $y_{n+1} = \\Phi(y_{n})$ 是一个线性更新。\n\n仅从牛顿第二定律和给定的 Beeman 方案出发，推导该谐振子单步映射的雅可比矩阵 $J \\equiv \\partial y_{n+1} / \\partial y_{n}$，并计算其行列式 $\\det J$ 作为 $\\Delta t$ 和 $\\omega$ 的显式函数。然后，根据您的结果，讨论每一步相空间体积变化的含义，以及该方案对分子动力学中微正则（粒子数、体积和能量恒定；NVE）采样的适用性。\n\n请给出 $\\det J$ 的闭合形式表达式作为最终答案。最终答案中无需讨论。该行列式是无量纲的，因此不需要单位。无需四舍五入。",
            "solution": "用户希望我分析一维谐振子的 Beeman 积分方案。\n\n这是我的计划：\n1.  **验证问题陈述。**\n    *   **已知条件：**\n        *   系统：质量为 $m$、弹簧常数为 $k$ 的一维谐振子。\n        *   运动方程：$m \\ddot{x}(t) = -k x(t)$。\n        *   定义：$\\omega \\equiv \\sqrt{k/m}$ 和 $a(t) \\equiv \\ddot{x}(t)$。\n        *   加速度关系：$a(t) = -\\omega^{2} x(t)$。\n        *   离散化：固定时间步长 $\\Delta t$。\n        *   Beeman 位置更新：$x_{n+1} = x_{n} + v_{n} \\Delta t + \\frac{2}{3} a_{n} \\Delta t^{2} - \\frac{1}{6} a_{n-1} \\Delta t^{2}$。\n        *   Beeman 速度更新：$v_{n+1} = v_{n} + \\frac{1}{3} a_{n+1} \\Delta t + \\frac{5}{6} a_{n} \\Delta t - \\frac{1}{6} a_{n-1} \\Delta t$。\n        *   离散化加速度：$a_{n} = -\\omega^{2} x_{n}$ 和 $a_{n+1} = -\\omega^{2} x_{n+1}$。\n        *   增广状态向量：$y_{n} \\equiv (x_{n}, v_{n}, x_{n-1})^{\\top}$。\n        *   单步映射：$y_{n+1} = \\Phi(y_{n})$。\n    *   **任务：**\n        1.  推导雅可比矩阵 $J \\equiv \\partial y_{n+1} / \\partial y_{n}$。\n        2.  计算其行列式 $\\det J$ 作为 $\\Delta t$ 和 $\\omega$ 的函数。\n        3.  讨论对相空间体积变化和 NVE 采样适用性的影响。\n    *   **验证：**\n        *   **科学或事实不健全性：** 该问题在科学上是合理的。谐振子是一个基本的物理模型。所提供的 Beeman 积分器方程是分子动力学中使用的标准、正确的公式。\n        *   **非形式化或不相关：** 该问题是一个明确定义的数学任务，与分子动力学中数值积分器的主题直接相关。\n        *   **设置不完整或矛盾：** 该问题是自洽的，并提供了继续进行所需的所有方程和定义。\n        *   **不现实或不可行：** 该问题是计算物理学中的一个标准理论练习。它既现实又可行。\n        *   **不适定或结构不良：** 该问题是适定的。从给定的线性映射推导雅可比矩阵及其行列式是一个直接且唯一的过程。\n    *   **结论：** 问题有效。我将继续进行解答。\n\n2.  **推导更新映射和雅可比矩阵 $J$。**\n    在时间步长 $n$ 的增广状态向量为 $y_{n} = (x_{n}, v_{n}, x_{n-1})^{\\top}$。下一个时间步长的状态向量为 $y_{n+1} = (x_{n+1}, v_{n+1}, x_{n})^{\\top}$。我们必须将 $y_{n+1}$ 的分量表示为 $y_{n}$ 分量的线性函数。为简化符号，我们定义 $\\alpha \\equiv \\omega^2 \\Delta t^2$。\n\n    **$y_{n+1}$ 的第一个分量：$x_{n+1}$**\n    位置更新公式为：\n    $$\n    x_{n+1} = x_{n} + v_{n} \\Delta t + \\frac{2}{3} a_{n} \\Delta t^{2} - \\frac{1}{6} a_{n-1} \\Delta t^{2}\n    $$\n    代入 $a_{n} = -\\omega^{2} x_{n}$ 和 $a_{n-1} = -\\omega^{2} x_{n-1}$：\n    $$\n    x_{n+1} = x_{n} + v_{n} \\Delta t - \\frac{2}{3} \\omega^{2} x_{n} \\Delta t^{2} + \\frac{1}{6} \\omega^{2} x_{n-1} \\Delta t^{2}\n    $$\n    按 $y_n$ 的分量对各项进行分组：\n    $$\n    x_{n+1} = \\left(1 - \\frac{2}{3} \\omega^{2} \\Delta t^{2}\\right) x_{n} + (\\Delta t) v_{n} + \\left(\\frac{1}{6} \\omega^{2} \\Delta t^{2}\\right) x_{n-1}\n    $$\n\n    **$y_{n+1}$ 的第二个分量：$v_{n+1}$**\n    速度更新公式为：\n    $$\n    v_{n+1} = v_{n} + \\frac{1}{3} a_{n+1} \\Delta t + \\frac{5}{6} a_{n} \\Delta t - \\frac{1}{6} a_{n-1} \\Delta t\n    $$\n    首先，代入与 $x_n$ 和 $x_{n-1}$ 相关的加速度项：\n    $$\n    v_{n+1} = v_{n} + \\frac{1}{3} a_{n+1} \\Delta t - \\frac{5}{6} \\omega^{2} x_{n} \\Delta t + \\frac{1}{6} \\omega^{2} x_{n-1} \\Delta t\n    $$\n    现在，代入 $a_{n+1} = -\\omega^{2} x_{n+1}$：\n    $$\n    v_{n+1} = v_{n} - \\frac{1}{3} \\omega^{2} x_{n+1} \\Delta t - \\frac{5}{6} \\omega^{2} x_{n} \\Delta t + \\frac{1}{6} \\omega^{2} x_{n-1} \\Delta t\n    $$\n    为了使其成为 $y_n$ 的显式函数，我们必须代入上面推导出的 $x_{n+1}$ 的表达式：\n    $$\n    v_{n+1} = v_{n} - \\frac{1}{3} \\omega^{2} \\Delta t \\left[ \\left(1 - \\frac{2}{3} \\omega^{2} \\Delta t^{2}\\right) x_{n} + (\\Delta t) v_{n} + \\left(\\frac{1}{6} \\omega^{2} \\Delta t^{2}\\right) x_{n-1} \\right] - \\frac{5}{6} \\omega^{2} x_{n} \\Delta t + \\frac{1}{6} \\omega^{2} x_{n-1} \\Delta t\n    $$\n    现在我们按 $x_n$、$v_n$ 和 $x_{n-1}$ 对各项进行分组：\n    *   $x_n$ 的系数：\n    $$\n    -\\frac{1}{3} \\omega^{2} \\Delta t \\left(1 - \\frac{2}{3} \\omega^{2} \\Delta t^{2}\\right) - \\frac{5}{6} \\omega^{2} \\Delta t = -\\frac{1}{3} \\omega^{2} \\Delta t + \\frac{2}{9} \\omega^{4} \\Delta t^{3} - \\frac{5}{6} \\omega^{2} \\Delta t = \\left(-\\frac{2}{6} - \\frac{5}{6}\\right)\\omega^{2} \\Delta t + \\frac{2}{9} \\omega^{4} \\Delta t^{3} = -\\frac{7}{6} \\omega^{2} \\Delta t + \\frac{2}{9} \\omega^{4} \\Delta t^{3}\n    $$\n    *   $v_n$ 的系数：\n    $$\n    1 - \\frac{1}{3} \\omega^{2} \\Delta t (\\Delta t) = 1 - \\frac{1}{3} \\omega^{2} \\Delta t^{2}\n    $$\n    *   $x_{n-1}$ 的系数：\n    $$\n    -\\frac{1}{3} \\omega^{2} \\Delta t \\left(\\frac{1}{6} \\omega^{2} \\Delta t^{2}\\right) + \\frac{1}{6} \\omega^{2} \\Delta t = \\frac{1}{6} \\omega^{2} \\Delta t - \\frac{1}{18} \\omega^{4} \\Delta t^{3}\n    $$\n    因此，$v_{n+1}$ 的表达式为：\n    $$\n    v_{n+1} = \\left(-\\frac{7}{6} \\omega^{2} \\Delta t + \\frac{2}{9} \\omega^{4} \\Delta t^{3}\\right) x_{n} + \\left(1 - \\frac{1}{3} \\omega^{2} \\Delta t^{2}\\right) v_{n} + \\left(\\frac{1}{6} \\omega^{2} \\Delta t - \\frac{1}{18} \\omega^{4} \\Delta t^{3}\\right) x_{n-1}\n    $$\n\n    **$y_{n+1}$ 的第三个分量：$x_{n}$**\n    第三个分量是平凡的 $x_n = 1 \\cdot x_n + 0 \\cdot v_n + 0 \\cdot x_{n-1}$。\n\n    **构建雅可比矩阵 $J$**\n    更新具有线性形式 $y_{n+1} = J y_{n}$。雅可比矩阵 $J = \\partial y_{n+1} / \\partial y_{n}$ 是我们刚刚推导出的系数矩阵。对于 $y_{n+1}=(x_{n+1},v_{n+1},x_{n})^\\top$ 和 $y_{n}=(x_{n},v_{n},x_{n-1})^\\top$：\n    $$\n    J = \\begin{pmatrix} \\frac{\\partial x_{n+1}}{\\partial x_{n}}  \\frac{\\partial x_{n+1}}{\\partial v_{n}}  \\frac{\\partial x_{n+1}}{\\partial x_{n-1}} \\\\ \\frac{\\partial v_{n+1}}{\\partial x_{n}}  \\frac{\\partial v_{n+1}}{\\partial v_{n}}  \\frac{\\partial v_{n+1}}{\\partial x_{n-1}} \\\\ \\frac{\\partial x_{n}}{\\partial x_{n}}  \\frac{\\partial x_{n}}{\\partial v_{n}}  \\frac{\\partial x_{n}}{\\partial x_{n-1}} \\end{pmatrix}\n    $$\n    代入系数：\n    $$\n    J = \\begin{pmatrix}\n    1 - \\frac{2}{3} \\omega^{2} \\Delta t^{2}  \\Delta t  \\frac{1}{6} \\omega^{2} \\Delta t^{2} \\\\\n    -\\frac{7}{6} \\omega^{2} \\Delta t + \\frac{2}{9} \\omega^{4} \\Delta t^{3}  1 - \\frac{1}{3} \\omega^{2} \\Delta t^{2}  \\frac{1}{6} \\omega^{2} \\Delta t - \\frac{1}{18} \\omega^{4} \\Delta t^{3} \\\\\n    1  0  0\n    \\end{pmatrix}\n    $$\n    \n3.  **计算 $J$ 的行列式。**\n    我们沿第三行进行代数余子式展开来计算 $J$ 的行列式，这是最简单的方法。\n    $$\n    \\det J = (1) \\cdot \\det \\begin{pmatrix} \\Delta t  \\frac{1}{6} \\omega^{2} \\Delta t^{2} \\\\ 1 - \\frac{1}{3} \\omega^{2} \\Delta t^{2}  \\frac{1}{6} \\omega^{2} \\Delta t - \\frac{1}{18} \\omega^{4} \\Delta t^{3} \\end{pmatrix} - (0) \\cdot (...) + (0) \\cdot (...)\n    $$\n    $$\n    \\det J = (\\Delta t) \\left( \\frac{1}{6} \\omega^{2} \\Delta t - \\frac{1}{18} \\omega^{4} \\Delta t^{3} \\right) - \\left( \\frac{1}{6} \\omega^{2} \\Delta t^{2} \\right) \\left( 1 - \\frac{1}{3} \\omega^{2} \\Delta t^{2} \\right)\n    $$\n    让我们展开这两项。\n    第一项：\n    $$\n    (\\Delta t) \\left( \\frac{1}{6} \\omega^{2} \\Delta t - \\frac{1}{18} \\omega^{4} \\Delta t^{3} \\right) = \\frac{1}{6} \\omega^{2} \\Delta t^{2} - \\frac{1}{18} \\omega^{4} \\Delta t^{4}\n    $$\n    第二项：\n    $$\n    \\left( \\frac{1}{6} \\omega^{2} \\Delta t^{2} \\right) \\left( 1 - \\frac{1}{3} \\omega^{2} \\Delta t^{2} \\right) = \\frac{1}{6} \\omega^{2} \\Delta t^{2} - \\frac{1}{18} \\omega^{4} \\Delta t^{4}\n    $$\n    行列式是这两个相同表达式的差：\n    $$\n    \\det J = \\left(\\frac{1}{6} \\omega^{2} \\Delta t^{2} - \\frac{1}{18} \\omega^{4} \\Delta t^{4}\\right) - \\left(\\frac{1}{6} \\omega^{2} \\Delta t^{2} - \\frac{1}{18} \\omega^{4} \\Delta t^{4}\\right) = 0\n    $$\n    该单步映射的雅可比矩阵行列式恰好为零。\n\n4.  **讨论。**\n    雅可比行列式 $\\det J$ 描述了状态空间中的一个无穷小体积元在该映射下的变换方式。在本例中，状态空间是坐标为 $(x, v, x_{prev})$ 的增广三维空间。一个无穷小体积元 $dV_n = dx_n \\, dv_n \\, dx_{n-1}$ 变换为 $dV_{n+1} = |\\det J| \\, dV_n$。\n    我们的结果 $\\det J = 0$ 意味着无论初始体积 $dV_n$ 如何，$dV_{n+1} = 0$。这意味着 Beeman 算法，当被视为此增广相空间中的单步映射时，是一个奇异变换。它将整个三维状态空间坍缩到一个较低维的流形上（在本例中，由于 $J$ 的秩为 $2$，是一个二维平面）。这展示了该算法的一个深刻的结构特性。\n\n    对于微正则 (NVE) 模拟，数值积分器理想情况下应生成停留在由初始条件定义的恒定能量面上的轨迹。根据刘维尔定理，在真实哈密顿量下的时间演化会保持相空间体积元 $dx \\, dp$ 不变。具备此性质的数值积分器被称为**辛积分器**。一个映射是辛映射的必要条件是其雅可比矩阵的行列式必须恰好为 $1$。这类积分器，如 Verlet 算法，表现出卓越的长期能量守恒性，能量在初始能量值附近有界波动。\n\n    我们发现 Beeman 算法增广映射的 $\\det J = 0$，这清楚地表明它**不是辛算法**。这个值甚至不接近 $1$；它就是 $0$。增广相空间体积的不守恒是一个明确的指标，表明该算法不尊重哈密顿动力学的几何结构。因此，Beeman 算法在长时间模拟中不会守恒能量；它通常表现出总能量的长期漂移。\n\n    因此，尽管 Beeman 积分器在每个时间步长的位置和速度精度上比 Verlet 等更简单的方法要高，但其缺乏辛性使其不适用于能量守恒是主要要求的长期 NVE 分子动力学模拟。计算出的行列式为这种不适用性提供了严格的数学证明。",
            "answer": "$$\n\\boxed{0}\n$$"
        },
        {
            "introduction": "在分析了标准积分器的优缺点之后，我们转向积分器的设计与实现。这个综合性练习要求你不再仅仅分析一个给定的方案，而是亲手设计一个“完美”的预测-校正积分器，使其对于谐振子模型能够精确保持能量守恒。通过强制数值格式重现相空间中的精确旋转动力学，你将校准出一个专门的积分器，并通过编程实践来检验它在非谐振势下的性能表现和局限性。这个练习深刻地揭示了通用算法与专用算法之间的权衡 。",
            "id": "3396786",
            "problem": "您需要设计、分析并实现一个单步预测-校正分子动力学积分器，其系数经过校准，以使得对于由牛顿第二定律 $m \\, x''(t) = - k \\, x(t)$ 控制的谐振子（其中 $m = 1$ 和 $k = \\omega^2$），离散时间更新能够在稳定性限制内的任何时间步长 $\\Delta t$ 下，精确地守恒连续时间机械能 $E = \\tfrac{1}{2} \\, v^2 + \\tfrac{1}{2} \\, \\omega^2 x^2$，然后测试其对弱非谐性的迁移能力。在一维空间中进行计算，质量为单位质量，所有角度均使用弧度。\n\n您的推导必须仅从以下基本原理出发：\n- 牛顿第二定律 $x''(t) = a(x)$，其中 $a(x) = - \\partial V/\\partial x$。\n- 速度 $v = dx/dt$ 和加速度 $a = dv/dt$ 的定义。\n- 对于谐振子 $V(x) = \\tfrac{1}{2} \\, \\omega^2 x^2$，其精确解是相空间中角增量为 $\\theta = \\omega \\, \\Delta t$ 的旋转，这意味着一个线性的、保范数的映射。\n- 对于弱非谐性，使用 $V(x) = \\tfrac{1}{2} \\, \\omega^2 x^2 + \\tfrac{\\varepsilon}{4} x^4$，其中 $\\varepsilon$ 很小，且 $a(x) = - \\omega^2 x - \\varepsilon x^3$。\n\n您的任务：\n- 校准一个形式为“预测位置，评估预测加速度，使用当前和预测加速度的线性组合校正速度和位置”的预测-校正器，以便对于谐振子，所得到的单步映射对于满足稳定性要求的任何 $\\Delta t$ 都是精确能量守恒的。校准可以依赖于 $\\theta = \\omega \\, \\Delta t$。\n- 用 $\\theta$ 来说明稳定性极限，并解释为什么谐振子允许一个旋转类型的能量守恒离散映射。\n- 实现您校准的预测-校正积分器，并作为对比，实现 Beeman 积分器作为基准预测-校正器，该积分器使用 $a_{n-1}$、$a_n$ 和一个预测的 $a_{n+1}$。\n- 对于每个测试，模拟系统指定的步数，并计算最大相对能量偏差 $\\max_{0 \\le n \\le N} \\lvert E_n - E_0 \\rvert / \\lvert E_0 \\rvert$，结果为一个浮点数（无单位）。所有能量必须以焦耳计算，位置以米，速度以米/秒，角频率以弧度/秒，时间以秒计算。\n\n测试套件：\n- 测试 $1$ (谐振子，“理想路径”)：$V(x) = \\tfrac{1}{2} \\, \\omega^2 x^2$，其中 $\\omega = 3.0 \\ \\text{rad/s}$，$\\Delta t = 0.2 \\ \\text{s}$，$N = 2000$ 步，初始状态 $x_0 = 1.0 \\ \\text{m}$，$v_0 = 0.0 \\ \\text{m/s}$。输出您的校准预测-校正器的最大相对能量偏差，格式为浮点数。\n- 测试 $2$ (谐振子，基准)：与测试 $1$ 参数相同，但使用 Beeman 积分器输出最大相对能量偏差，格式为浮点数。\n- 测试 $3$ (谐振子，接近稳定性极限的边界情况)：$V(x) = \\tfrac{1}{2} \\, \\omega^2 x^2$，其中 $\\omega = 2.0 \\ \\text{rad/s}$，$\\Delta t = 0.99 \\, \\pi / \\omega \\ \\text{s}$，$N = 500$ 步，初始状态 $x_0 = 1.0 \\ \\text{m}$，$v_0 = 0.0 \\ \\text{m/s}$。输出您的校准预测-校正器的最大相对能量偏差，格式为浮点数。\n- 测试 $4$ (弱非谐性，迁移性检查 I)：$V(x) = \\tfrac{1}{2} \\, \\omega^2 x^2 + \\tfrac{\\varepsilon}{4} x^4$，其中 $\\omega = 1.0 \\ \\text{rad/s}$，$\\varepsilon = 1.0 \\times 10^{-3} \\ \\text{m}^{-2} \\ \\text{s}^{-2}$，$\\Delta t = 0.2 \\ \\text{s}$，$N = 2000$ 步，初始状态 $x_0 = 0.5 \\ \\text{m}$，$v_0 = 0.0 \\ \\text{m/s}$。输出一个双元素列表 $[e_{\\text{cal}}, e_{\\text{bee}}]$，分别包含您的校准预测-校正器和 Beeman 积分器的最大相对能量偏差。\n- 测试 $5$ (中度非谐性，迁移性检查 II)：$V(x) = \\tfrac{1}{2} \\, \\omega^2 x^2 + \\tfrac{\\varepsilon}{4} x^4$，其中 $\\omega = 1.0 \\ \\text{rad/s}$，$\\varepsilon = 5.0 \\times 10^{-2} \\ \\text{m}^{-2} \\ \\text{s}^{-2}$，$\\Delta t = 0.05 \\ \\text{s}$，$N = 2000$ 步，初始状态 $x_0 = 0.5 \\ \\text{m}$，$v_0 = 0.0 \\ \\text{m/s}$。输出一个如测试 $4$ 的双元素列表 $[e_{\\text{cal}}, e_{\\text{bee}}]$。\n\n最终输出格式：\n- 您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表，顺序如下：\n$[ \\text{Test1}, \\text{Test2}, \\text{Test3}, \\text{Test4\\_cal}, \\text{Test4\\_bee}, \\text{Test5\\_cal}, \\text{Test5\\_bee} ]$。\n所有输出必须是浮点数。对于测试4和测试5，您必须将双元素结果展开到上述指定的单个列表中。",
            "solution": "我们从单位质量的牛顿第二定律 $x''(t) = a(x)$ 开始，其中 $a(x) = - \\partial V/\\partial x$。对于势能为 $V(x) = \\tfrac{1}{2} \\, \\omega^2 x^2$ 的谐振子，在一个时间步长 $\\Delta t$ 内的精确流是相空间中角度为 $\\theta = \\omega \\, \\Delta t$ 的旋转：\n$$\n\\begin{pmatrix} x_{n+1} \\\\ v_{n+1} \\end{pmatrix}\n=\n\\begin{pmatrix}\n\\cos \\theta  \\frac{\\sin \\theta}{\\omega} \\\\\n- \\omega \\sin \\theta  \\cos \\theta\n\\end{pmatrix}\n\\begin{pmatrix} x_n \\\\ v_n \\end{pmatrix}.\n$$\n这个映射精确地守恒二次型能量 $E = \\tfrac{1}{2} \\, v^2 + \\tfrac{1}{2} \\, \\omega^2 x^2$，因为它相对于该二次型所导出的度量是正交的。谐振子的稳定性要求 $\\lvert \\cos \\theta \\rvert \\le 1$，因此 $0 \\le \\theta \\le \\pi$，或者等价地 $0 \\le \\Delta t \\le \\pi / \\omega$。\n\n我们寻求一个具有以下结构的预测-校正器（单步，在预测位置进行单次力评估后是显式的）：\n- 使用当前加速度预测位置：\n$$\nx_{n+1}^{\\mathrm{p}} = x_n + \\Delta t \\, v_n + c_{\\mathrm{p}} \\, a_n \\, \\Delta t^2,\n$$\n其中 $a_n = a(x_n)$ 且下标 $\\mathrm{p}$ 表示预测值。\n- 评估预测加速度 $a_{n+1}^{\\mathrm{p}} = a(x_{n+1}^{\\mathrm{p}})$。\n- 用当前和预测加速度的仿射组合校正速度和位置：\n$$\nv_{n+1} = v_n + \\Delta t \\, \\big( \\alpha \\, a_{n+1}^{\\mathrm{p}} + \\beta \\, a_n \\big), \\quad\nx_{n+1} = x_n + \\Delta t \\, v_n + \\Delta t^2 \\, \\big( \\alpha' \\, a_{n+1}^{\\mathrm{p}} + \\beta' \\, a_n \\big).\n$$\n\n针对谐振子的校准。对于 $a(x) = - \\omega^2 x$，我们要求这个显式预测-校正器对任意 $\\theta = \\omega \\, \\Delta t$ 都能复现精确的旋转映射。写出谐振子的预测器：\n$$\nx_{n+1}^{\\mathrm{p}} = x_n + \\Delta t \\, v_n - c_{\\mathrm{p}} \\, \\omega^2 \\, x_n \\, \\Delta t^2.\n$$\n因此，\n$$\na_{n+1}^{\\mathrm{p}} = - \\omega^2 x_{n+1}^{\\mathrm{p}} = - \\omega^2 x_n - \\omega^2 \\Delta t \\, v_n + c_{\\mathrm{p}} \\, \\omega^4 \\, x_n \\, \\Delta t^2.\n$$\n将 $a_{n+1}^{\\mathrm{p}}$ 代入速度校正器：\n$$\nv_{n+1}\n=\nv_n + \\Delta t \\left[ \\alpha \\left( - \\omega^2 x_n - \\omega^2 \\Delta t \\, v_n + c_{\\mathrm{p}} \\, \\omega^4 \\, x_n \\, \\Delta t^2 \\right) + \\beta \\left( - \\omega^2 x_n \\right) \\right].\n$$\n按 $v_n$ 和 $x_n$ 收集项，并强制其与精确旋转相等：\n$$\nv_{n+1} = \\cos \\theta \\, v_n - \\omega \\sin \\theta \\, x_n.\n$$\n令系数相等可得\n$$\n1 - \\alpha \\, \\omega^2 \\Delta t^2 = \\cos \\theta, \\qquad\n- (\\alpha + \\beta) \\, \\omega^2 + \\alpha \\, c_{\\mathrm{p}} \\, \\omega^4 \\Delta t^2 = - \\omega^2 \\, \\frac{\\sin \\theta}{\\theta}.\n$$\n用 $\\theta = \\omega \\Delta t$ 表示，这变成\n$$\n\\alpha = \\frac{1 - \\cos \\theta}{\\theta^2}, \\qquad\n\\alpha \\, c_{\\mathrm{p}} \\, \\theta^2 - (\\alpha + \\beta) = - \\frac{\\sin \\theta}{\\theta}.\n$$\n对于位置校正器，将 $a_{n+1}^{\\mathrm{p}}$ 代入\n$$\nx_{n+1} = x_n + \\Delta t \\, v_n + \\Delta t^2 \\left[ \\alpha' \\left( - \\omega^2 x_n - \\omega^2 \\Delta t \\, v_n + c_{\\mathrm{p}} \\, \\omega^4 \\, x_n \\, \\Delta t^2 \\right) + \\beta' \\left( - \\omega^2 x_n \\right) \\right],\n$$\n并强制\n$$\nx_{n+1} = \\cos \\theta \\, x_n + \\frac{\\sin \\theta}{\\omega} \\, v_n.\n$$\n匹配 $v_n$ 的系数可得\n$$\n\\Delta t \\left( 1 - \\alpha' \\, \\omega^2 \\Delta t^2 \\right) = \\frac{\\sin \\theta}{\\omega} \\ \\ \\Rightarrow \\ \\ \\alpha' = \\frac{1 - (\\sin \\theta)/\\theta}{\\theta^2}.\n$$\n匹配 $x_n$ 的系数可得\n$$\n1 - (\\alpha' + \\beta') \\, \\theta^2 + \\alpha' \\, c_{\\mathrm{p}} \\, \\theta^4 = \\cos \\theta \\ \\ \\Rightarrow \\ \\ \\alpha' \\, c_{\\mathrm{p}} \\, \\theta^2 - (\\alpha' + \\beta') = \\frac{\\cos \\theta - 1}{\\theta^2} = - \\alpha.\n$$\n我们现在选择一个一致且精确的预测器系数 $c_{\\mathrm{p}} = \\tfrac{1}{2}$，使得当 $\\theta \\to 0$ 时，预测位置与二阶泰勒展开相匹配。当 $c_{\\mathrm{p}} = \\tfrac{1}{2}$ 时，其余系数被唯一确定：\n$$\n\\alpha = \\frac{1 - \\cos \\theta}{\\theta^2}, \\qquad\n\\alpha' = \\frac{1 - (\\sin \\theta)/\\theta}{\\theta^2},\n$$\n$$\n\\beta = \\frac{\\sin \\theta}{\\theta} + \\frac{1 - \\cos \\theta}{2} - \\alpha, \\qquad\n\\beta' = \\frac{1}{2} \\, \\alpha' \\, \\theta^2 + \\alpha - \\alpha'.\n$$\n小 $\\theta$ 渐近式确保了数值稳定性：\n$$\n\\alpha = \\frac{1}{2} - \\frac{\\theta^2}{24} + \\mathcal{O}(\\theta^4), \\quad\n\\alpha' = \\frac{1}{6} - \\frac{\\theta^2}{120} + \\mathcal{O}(\\theta^4),\n$$\n$$\n\\beta = \\frac{1}{2} + \\frac{\\theta^2}{8} - \\frac{\\theta^4}{72} + \\mathcal{O}(\\theta^6), \\quad\n\\beta' = \\frac{1}{3} + \\frac{\\theta^2}{20} - \\frac{\\theta^4}{336} + \\mathcal{O}(\\theta^6).\n$$\n使用这些系数，对于谐振子，预测-校正器复现了精确的旋转映射；因此，它在稳定性区间 $[0, \\pi]$ 内对任何 $\\theta$ 都守恒精确的连续能量 $E$。这是因为对于二次型 $V$，所得到的离散更新等于 $(x, v)$ 相平面中的精确正交映射。\n\n对弱非谐性的迁移性。对于 $V(x) = \\tfrac{1}{2} \\, \\omega^2 x^2 + \\tfrac{\\varepsilon}{4} x^4$ 且 $\\varepsilon$ 很小，力为 $a(x) = - \\omega^2 x - \\varepsilon x^3$。校准后的系数仍然是 $\\theta = \\omega \\, \\Delta t$ 的函数，基于谐振子参考系构建。此时该方法不再精确能量守恒，但在主阶上保持时间可逆性，并且对于足够小的 $\\varepsilon$ 和适当小的 $\\Delta t$ 表现出良好的能量行为。Beeman 方法，一个经典的预测-校正器，提供了一个基准：\n- 使用 $a_{n-1}$ 和 $a_n$ 更新位置：\n$$\nx_{n+1} = x_n + v_n \\, \\Delta t + \\left( \\frac{2}{3} a_n - \\frac{1}{6} a_{n-1} \\right) \\Delta t^2.\n$$\n- 从 $x_{n+1}$ 预测 $a_{n+1}$ 并校正速度：\n$$\nv_{n+1} = v_n + \\left( \\frac{1}{3} a_{n+1} + \\frac{5}{6} a_n - \\frac{1}{6} a_{n-1} \\right) \\Delta t.\n$$\n可以使用像速度 Verlet 这样的单步方法来启动 Beeman 的第一步（以避免临时的 $a_{-1}$）。\n\n算法设计摘要：\n- 给定 $(x_n, v_n)$，计算 $a_n = - \\omega^2 x_n - \\varepsilon x_n^3$。\n- 设置 $\\theta = \\omega \\, \\Delta t$ 并根据上述公式计算 $(\\alpha, \\beta, \\alpha', \\beta')$，对小 $\\theta$ 使用级数展开以避免抵消误差。\n- 预测器：$x_{n+1}^{\\mathrm{p}} = x_n + \\Delta t \\, v_n + \\tfrac{1}{2} a_n \\, \\Delta t^2$；在 $x_{n+1}^{\\mathrm{p}}$ 处计算 $a_{n+1}^{\\mathrm{p}}$。\n- 校正器：\n$$\nv_{n+1} = v_n + \\Delta t \\, \\big( \\alpha \\, a_{n+1}^{\\mathrm{p}} + \\beta \\, a_n \\big), \\qquad\nx_{n+1} = x_n + \\Delta t \\, v_n + \\Delta t^2 \\, \\big( \\alpha' \\, a_{n+1}^{\\mathrm{p}} + \\beta' \\, a_n \\big).\n$$\n- 能量监测：$E_n = \\tfrac{1}{2} v_n^2 + \\tfrac{1}{2} \\omega^2 x_n^2 + \\tfrac{\\varepsilon}{4} x_n^4$。\n- 对于 Beeman 基准，先用一个速度 Verlet 步来获得 $(x_1, v_1, a_1)$，然后应用 Beeman 更新。\n\n谐振子情况下的稳定性和精确性：\n- 校准后的系数强制执行谐波动力学的精确旋转映射，因此对于 $0 \\le \\theta \\le \\pi$ 的任何 $\\theta$ 都精确守恒能量 $E$。\n- 在边界 $\\theta \\lesssim \\pi$ 附近，$x_{n+1} \\approx - x_{n-1}$ 且能量保持恒定；数值舍入误差表现为微小的波动。\n\n程序实现了两种积分器，运行规定的测试套件，并按要求顺序以单行方括号列表的形式报告最大相对能量偏差，结果为浮点数。所有角度均以弧度为单位，时间以秒为单位。输出是无单位的相对误差，以小数形式表示。",
            "answer": "```python\nimport numpy as np\n\ndef coeffs_calibrated(theta):\n    \"\"\"\n    Compute calibrated predictor-corrector coefficients (alpha, beta, alpha', beta')\n    as functions of theta = omega * dt, using stable series for small theta.\n    \"\"\"\n    th = theta\n    abs_th = abs(th)\n    if abs_th  1e-6:\n        # Series expansions\n        th2 = th * th\n        th4 = th2 * th2\n        alpha = 0.5 - th2/24.0 + th4/720.0\n        alpha_p = 1.0/6.0 - th2/120.0 + th4/5040.0  # alpha'\n        beta = 0.5 + th2/8.0 - th4/72.0\n        beta_p = 1.0/3.0 + th2/20.0 - th4/336.0     # beta'\n    else:\n        sinth = np.sin(th)\n        costh = np.cos(th)\n        # Direct formulas\n        alpha = (1.0 - costh) / (th * th)\n        alpha_p = (1.0 - (sinth / th)) / (th * th)\n        beta = (sinth / th) + 0.5 * (1.0 - costh) - alpha\n        beta_p = 0.5 * alpha_p * (th * th) + alpha - alpha_p\n    return alpha, beta, alpha_p, beta_p\n\ndef accel(x, omega, eps):\n    # a(x) = -dV/dx = -omega^2 x - eps x^3\n    return - (omega * omega) * x - eps * (x ** 3)\n\ndef energy(x, v, omega, eps):\n    # E = 1/2 v^2 + 1/2 omega^2 x^2 + eps/4 x^4\n    return 0.5 * v * v + 0.5 * (omega * omega) * x * x + 0.25 * eps * (x ** 4)\n\ndef integrate_calibrated(x0, v0, omega, eps, dt, steps):\n    \"\"\"\n    Calibrated predictor-corrector integrator.\n    Returns timeseries of energies for monitoring.\n    \"\"\"\n    theta = omega * dt\n    alpha, beta, alpha_p, beta_p = coeffs_calibrated(theta)\n    x = x0\n    v = v0\n    a = accel(x, omega, eps)\n    energies = [energy(x, v, omega, eps)]\n    for _ in range(steps):\n        # Predictor for position\n        x_pred = x + dt * v + 0.5 * a * dt * dt\n        a_pred = accel(x_pred, omega, eps)\n        # Correctors\n        v_new = v + dt * (alpha * a_pred + beta * a)\n        x_new = x + dt * v + (dt * dt) * (alpha_p * a_pred + beta_p * a)\n        x, v = x_new, v_new\n        a = accel(x, omega, eps)\n        energies.append(energy(x, v, omega, eps))\n    return np.array(energies)\n\ndef integrate_beeman(x0, v0, omega, eps, dt, steps):\n    \"\"\"\n    Beeman integrator with velocity Verlet startup.\n    Returns timeseries of energies for monitoring.\n    \"\"\"\n    # Startup with velocity Verlet for one step\n    x = x0\n    v = v0\n    a = accel(x, omega, eps)\n    energies = [energy(x, v, omega, eps)]\n    # One velocity Verlet step to get a previous acceleration consistent\n    x1 = x + dt * v + 0.5 * a * dt * dt\n    a1 = accel(x1, omega, eps)\n    v1 = v + 0.5 * (a + a1) * dt\n\n    # Record first step\n    x_prev = x\n    a_prev = a\n    x = x1\n    v = v1\n    a = a1\n    energies.append(energy(x, v, omega, eps))\n\n    for _ in range(steps - 1):\n        # Beeman position\n        x_next = x + dt * v + ((2.0/3.0) * a - (1.0/6.0) * a_prev) * dt * dt\n        a_next = accel(x_next, omega, eps)\n        # Beeman velocity\n        v_next = v + ((1.0/3.0) * a_next + (5.0/6.0) * a - (1.0/6.0) * a_prev) * dt\n\n        # Shift\n        x_prev = x\n        a_prev = a\n        x, v = x_next, v_next\n        a = a_next\n        energies.append(energy(x, v, omega, eps))\n\n    return np.array(energies)\n\ndef max_relative_energy_error(energies):\n    E0 = energies[0]\n    errs = np.abs(energies - E0) / (abs(E0) if E0 != 0.0 else 1.0)\n    return float(np.max(errs))\n\ndef solve():\n    results = []\n\n    # Test 1: Harmonic, happy path\n    omega = 3.0\n    dt = 0.2\n    N = 2000\n    x0 = 1.0\n    v0 = 0.0\n    eps = 0.0\n    E_cal = integrate_calibrated(x0, v0, omega, eps, dt, N)\n    err1 = max_relative_energy_error(E_cal)\n    results.append(err1)\n\n    # Test 2: Harmonic, Beeman baseline\n    E_bee = integrate_beeman(x0, v0, omega, eps, dt, N)\n    err2 = max_relative_energy_error(E_bee)\n    results.append(err2)\n\n    # Test 3: Harmonic, near stability limit\n    omega = 2.0\n    dt = 0.99 * np.pi / omega\n    N = 500\n    x0 = 1.0\n    v0 = 0.0\n    eps = 0.0\n    E_cal = integrate_calibrated(x0, v0, omega, eps, dt, N)\n    err3 = max_relative_energy_error(E_cal)\n    results.append(err3)\n\n    # Test 4: Weak anharmonicity\n    omega = 1.0\n    eps = 1.0e-3\n    dt = 0.2\n    N = 2000\n    x0 = 0.5\n    v0 = 0.0\n    E_cal = integrate_calibrated(x0, v0, omega, eps, dt, N)\n    E_bee = integrate_beeman(x0, v0, omega, eps, dt, N)\n    err4_cal = max_relative_energy_error(E_cal)\n    err4_bee = max_relative_energy_error(E_bee)\n    results.append(err4_cal)\n    results.append(err4_bee)\n\n    # Test 5: Moderate anharmonicity\n    omega = 1.0\n    eps = 5.0e-2\n    dt = 0.05\n    N = 2000\n    x0 = 0.5\n    v0 = 0.0\n    E_cal = integrate_calibrated(x0, v0, omega, eps, dt, N)\n    E_bee = integrate_beeman(x0, v0, omega, eps, dt, N)\n    err5_cal = max_relative_energy_error(E_cal)\n    err5_bee = max_relative_energy_error(E_bee)\n    results.append(err5_cal)\n    results.append(err5_bee)\n\n    # Final print in required flattened list format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}