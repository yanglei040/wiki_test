{
    "hands_on_practices": [
        {
            "introduction": "伪随机数生成器（PRNG）是模拟的基石，但即使是设计良好的生成器也可能隐藏着非随机性的陷阱。本练习将引导你通过数学分析，揭示一种经典PRNG——线性同余生成器（LCG）——其低位比特中存在的显著相关性。理解这种基础缺陷是避免在复杂模拟中出现微妙但严重偏差的第一步。",
            "id": "3439293",
            "problem": "考虑一个用于分子动力学模拟中生成伪随机整数以进行均匀变量映射的线性同余生成器（LCG; Linear Congruential Generator），其定义为递推关系 $X_{n+1} = (a X_{n} + c) \\bmod 2^{w}$，其中 $w \\geq 2$，$a$ 是奇数，且 $c$ 是奇数。在许多代码中，整数通过缩放 $U_{n} = X_{n} / 2^{w}$ 映射为双精度浮点数，因此 $X_{n}$ 低位比特中的任何非随机结构都会在高级精度下降低所生成的 $U_{n}$ 的均匀性和独立性。\n\n从模算术和平稳二元过程的滞后-1自相关的定义出发，完成以下任务：\n\n1. 推导最低有效位 $b_{n} = X_{n} \\bmod 2$ 的演化方程，并计算二元序列 $\\{b_{n}\\}$ 在 LCG 模 $2$ 的一个完整周期内的滞后-1自相关系数 $\\rho_{b}$。\n\n2. 为了在映射到双精度浮点数之前修复低位比特结构，考虑通过输出变换 $Y_{n} = X_{n} \\oplus (X_{n} \\gg 1)$ 进行比特置乱，其中 $\\oplus$ 表示按位异或，$\\gg$ 表示右移。在附加假设 $a \\equiv 1 \\pmod{4}$ 和 $c \\equiv 1 \\pmod{2}$ 的条件下，推导两个最低有效位 $t_{n} = X_{n} \\bmod 4$ 的演化，并计算置乱后的最低有效位 $s_{n} = Y_{n} \\bmod 2$ 在模 $4$ 的一个完整周期内的滞后-1自相关系数 $\\rho_{s}$。\n\n提供有序对 $(\\rho_{b}, \\rho_{s})$ 作为你的最终答案。无需四舍五入。答案必须是两个实数。",
            "solution": "问题陈述已经过验证，被认为是有效的。它具有科学依据，问题提出得当且客观。提供了唯一解所需的所有信息，该问题是伪随机数生成器分析中的一个非平凡练习。\n\n该问题要求计算从线性同余生成器（LCG）派生的二元序列的两个滞后-1自相关系数 $\\rho_{b}$ 和 $\\rho_{s}$。\n\n**第1部分：最低有效位的自相关**\n\nLCG 由以下递推关系定义：\n$$X_{n+1} = (a X_{n} + c) \\bmod 2^{w}$$\n其中 $w \\geq 2$，乘数 $a$ 和增量 $c$ 均为奇数。\n\n$X_{n}$ 的最低有效位（LSB）由 $b_{n} = X_{n} \\bmod 2$ 给出。为了找到序列 $\\{b_{n}\\}$ 的演化方程，我们将 LCG 递推关系模 $2$。由于 $w \\geq 2$，我们有：\n$$X_{n+1} \\bmod 2 = ((a X_{n} + c) \\bmod 2^{w}) \\bmod 2$$\n$$X_{n+1} \\bmod 2 = (a X_{n} + c) \\bmod 2$$\n代入 $b_{n}$ 的定义，我们得到：\n$$b_{n+1} = (a (X_{n} \\bmod 2) + (c \\bmod 2)) \\bmod 2$$\n$$b_{n+1} = (a b_{n} + c) \\bmod 2$$\n已知 $a$ 和 $c$ 是奇数，它们模 $2$ 的值为 $a \\equiv 1 \\pmod{2}$ 和 $c \\equiv 1 \\pmod{2}$。LSB 序列的演化方程简化为：\n$$b_{n+1} = (1 \\cdot b_{n} + 1) \\bmod 2 = (b_{n} + 1) \\bmod 2$$\n这个递推关系生成一个纯粹的交替序列。如果 $b_{0}=0$，序列为 $\\{0, 1, 0, 1, \\dots\\}$。如果 $b_{0}=1$，序列为 $\\{1, 0, 1, 0, \\dots\\}$。无论哪种情况，该序列都是周期性的，周期为 $P_{b}=2$。\n\n我们现在计算这个平稳二元过程在一个完整周期内的滞后-1自相关系数 $\\rho_{b}$。让我们考虑一个周期内的序列为 $\\{0, 1\\}$。\n序列 $\\{b_{n}\\}$ 的均值为：\n$$\\mu_{b} = \\frac{1}{P_{b}} \\sum_{n=0}^{P_{b}-1} b_{n} = \\frac{1}{2}(0+1) = \\frac{1}{2}$$\n序列的方差为：\n$$\\sigma_{b}^{2} = \\frac{1}{P_{b}} \\sum_{n=0}^{P_{b}-1} (b_{n} - \\mu_{b})^{2} = \\frac{1}{2} \\left[ \\left(0 - \\frac{1}{2}\\right)^{2} + \\left(1 - \\frac{1}{2}\\right)^{2} \\right] = \\frac{1}{2} \\left( \\frac{1}{4} + \\frac{1}{4} \\right) = \\frac{1}{4}$$\n滞后-1自协方差 $C_{b}(1)$ 定义为：\n$$C_{b}(1) = \\frac{1}{P_{b}} \\sum_{n=0}^{P_{b}-1} (b_{n} - \\mu_{b})(b_{n+1} - \\mu_{b})$$\n利用序列的周期性（$b_{2} = b_{0}$）：\n$$C_{b}(1) = \\frac{1}{2} \\left[ (b_{0} - \\mu_{b})(b_{1} - \\mu_{b}) + (b_{1} - \\mu_{b})(b_{2} - \\mu_{b}) \\right]$$\n$$C_{b}(1) = \\frac{1}{2} \\left[ \\left(0 - \\frac{1}{2}\\right)\\left(1 - \\frac{1}{2}\\right) + \\left(1 - \\frac{1}{2}\\right)\\left(0 - \\frac{1}{2}\\right) \\right]$$\n$$C_{b}(1) = \\frac{1}{2} \\left[ \\left(-\\frac{1}{2}\\right)\\left(\\frac{1}{2}\\right) + \\left(\\frac{1}{2}\\right)\\left(-\\frac{1}{2}\\right) \\right] = \\frac{1}{2} \\left( -\\frac{1}{4} - \\frac{1}{4} \\right) = -\\frac{1}{4}$$\n滞后-1自相关系数是自协方差与方差的比值：\n$$\\rho_{b} = \\frac{C_{b}(1)}{\\sigma_{b}^{2}} = \\frac{-1/4}{1/4} = -1$$\n\n**第2部分：置乱后最低有效位的自相关**\n\n对于这部分，我们考虑附加假设 $a \\equiv 1 \\pmod{4}$ 和 $c$ 是奇数（$c \\equiv 1 \\pmod{2}$）。我们首先推导由 $t_{n} = X_{n} \\bmod 4$ 表示的两个最低有效位的演化。将 LCG 递推关系模 $4$（因为 $w \\geq 2$）：\n$$X_{n+1} \\bmod 4 = (a X_{n} + c) \\bmod 4$$\n$$t_{n+1} = (a t_{n} + c) \\bmod 4$$\n代入 $a \\equiv 1 \\pmod{4}$，方程变为：\n$$t_{n+1} = (t_{n} + c) \\bmod 4$$\n由于 $c$ 是奇数，所以 $c$ 模 $4$ 可能同余于 $1$ 或 $3$。\n情况1：$c \\equiv 1 \\pmod{4}$。序列为 $t_{n+1} = (t_{n} + 1) \\bmod 4$。从任何值开始，这都会生成一个长度为 $4$ 的循环，例如 $\\{0, 1, 2, 3, \\dots\\}$。\n情况2：$c \\equiv 3 \\pmod{4}$。序列为 $t_{n+1} = (t_{n} + 3) \\bmod 4$。这也会生成一个长度为 $4$ 的循环，例如 $\\{0, 3, 2, 1, \\dots\\}$。\n序列 $\\{t_{n}\\}$ 的周期是 $P_{t}=4$。\n\n置乱后的输出是 $Y_{n} = X_{n} \\oplus (X_{n} \\gg 1)$，其中 $\\oplus$ 是按位异或，$\\gg$ 是右移。置乱后的 LSB 是 $s_{n} = Y_{n} \\bmod 2$。假设 $X_{n}$ 的二进制表示为 $\\dots b_{n,1}b_{n,0}$。$Y_{n}$ 的 LSB 是 $X_{n}$ 的两个最低有效位的异或：\n$$s_{n} = b_{n,0} \\oplus b_{n,1}$$\n我们可以从 $t_{n} = 2 b_{n,1} + b_{n,0}$ 确定 $s_{n}$ 的值：\n- 如果 $t_{n}=0=(00)_{2}$，则 $b_{n,1}=0, b_{n,0}=0 \\implies s_{n} = 0 \\oplus 0 = 0$。\n- 如果 $t_{n}=1=(01)_{2}$，则 $b_{n,1}=0, b_{n,0}=1 \\implies s_{n} = 1 \\oplus 0 = 1$。\n- 如果 $t_{n}=2=(10)_{2}$，则 $b_{n,1}=1, b_{n,0}=0 \\implies s_{n} = 0 \\oplus 1 = 1$。\n- 如果 $t_{n}=3=(11)_{2}$，则 $b_{n,1}=1, b_{n,0}=1 \\implies s_{n} = 1 \\oplus 1 = 0$。\n\n现在我们计算序列 $\\{s_{n}\\}$ 在一个长度为 $P_{s}=4$ 的周期内的滞后-1自相关系数 $\\rho_{s}$。\n如果 $c \\equiv 1 \\pmod{4}$，$\\{t_{n}\\}$ 的一个周期是 $\\{0, 1, 2, 3\\}$。对应的序列 $\\{s_{n}\\}$ 是 $\\{0, 1, 1, 0\\}$。\n如果 $c \\equiv 3 \\pmod{4}$，$\\{t_{n}\\}$ 的一个周期是 $\\{0, 3, 2, 1\\}$。对应的序列 $\\{s_{n}\\}$ 是 $\\{0, 0, 1, 1\\}$。\n$\\rho_{s}$ 的计算对于这两个序列是相同的，因为其中一个是另一个的循环移位。我们使用序列 $\\{0, 1, 1, 0\\}$。\n序列 $\\{s_{n}\\}$ 的均值为：\n$$\\mu_{s} = \\frac{1}{4}(0+1+1+0) = \\frac{1}{2}$$\n方差为：\n$$\\sigma_{s}^{2} = \\frac{1}{4} \\left[ \\left(0 - \\frac{1}{2}\\right)^{2} + \\left(1 - \\frac{1}{2}\\right)^{2} + \\left(1 - \\frac{1}{2}\\right)^{2} + \\left(0 - \\frac{1}{2}\\right)^{2} \\right] = \\frac{1}{4} \\left( \\frac{1}{4} + \\frac{1}{4} + \\frac{1}{4} + \\frac{1}{4} \\right) = \\frac{1}{4}$$\n滞后-1自协方差 $C_{s}(1)$ 是：\n$$C_{s}(1) = \\frac{1}{4} \\sum_{n=0}^{3} (s_{n} - \\mu_{s})(s_{n+1} - \\mu_{s})$$\n$$C_{s}(1) = \\frac{1}{4} \\left[ \\left(0-\\frac{1}{2}\\right)\\left(1-\\frac{1}{2}\\right) + \\left(1-\\frac{1}{2}\\right)\\left(1-\\frac{1}{2}\\right) + \\left(1-\\frac{1}{2}\\right)\\left(0-\\frac{1}{2}\\right) + \\left(0-\\frac{1}{2}\\right)\\left(0-\\frac{1}{2}\\right) \\right]$$\n这些项对应于 $s_0, s_1, s_2, s_3$ 和 $s_4=s_0$。\n$$C_{s}(1) = \\frac{1}{4} \\left[ \\left(-\\frac{1}{2}\\right)\\left(\\frac{1}{2}\\right) + \\left(\\frac{1}{2}\\right)\\left(\\frac{1}{2}\\right) + \\left(\\frac{1}{2}\\right)\\left(-\\frac{1}{2}\\right) + \\left(-\\frac{1}{2}\\right)\\left(-\\frac{1}{2}\\right) \\right]$$\n$$C_{s}(1) = \\frac{1}{4} \\left[ -\\frac{1}{4} + \\frac{1}{4} - \\frac{1}{4} + \\frac{1}{4} \\right] = 0$$\n滞后-1自相关系数是：\n$$\\rho_{s} = \\frac{C_{s}(1)}{\\sigma_{s}^{2}} = \\frac{0}{1/4} = 0$$\n比特置乱成功地消除了最低有效位的滞后-1自相关。\n\n最终答案是有序对 $(\\rho_{b}, \\rho_{s})$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix} -1  0 \\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "理论上的缺陷在实际应用中会造成多大的破坏？这个练习通过一个具体的模拟场景——使用安德森恒温器——来回答这个问题 。你将看到，在特定条件下，直接使用LCG的低位比特来决定稀有随机事件，会导致模拟结果完全偏离物理现实，这个发人深省的例子强调了在使用PRNG时，不仅要关心其整体统计特性，还需警惕其内部结构缺陷。",
            "id": "3439356",
            "problem": "考虑一个应用于三维空间中分子动力学系统的安德森恒温器，其中随机碰撞被建模为每个粒子具有恒定速率参数 $\\nu$ 的泊松过程。在一个时间步长为 $\\Delta t$ 的时间离散积分器中，给定粒子在一步内经历一次碰撞的概率为 $p = 1 - \\exp(-\\nu \\Delta t)$。假设 $\\nu$ 和 $\\Delta t$ 的选择使得 $p = 2^{-10}$ 精确成立。\n\n所有粒子和时间步均使用一个单一共享的伪随机数生成器 (PRNG)，该生成器实现为模数为 $2^{32}$、乘数为 $a$、增量为 $c$ 的线性同余生成器 (LCG)，\n$$\nx_{n+1} = a x_n + c \\pmod{2^{32}},\n$$\n其中 $a \\equiv 1 \\pmod{4}$ 且 $c$ 为奇数。代码通过从PRNG状态的最低10位形成一个整数 $b_t = x_{n_t} \\bmod 2^{10}$ 来决定在时间步 $t$ 一个粒子是否发生碰撞，并且当且仅当 $b_t  T$ 时宣布发生碰撞，其中 $T = \\lfloor p \\cdot 2^{10} \\rfloor$。代码结构以固定块的方式推进PRNG，使得对于整个模拟中的连续时间步，$n_t = n_0 + t s$，步长为 $s = 2^{11}$。\n\n请从第一性原理和经过科学充分检验的事实出发，回答以下问题：\n- 仅使用模数为2的幂的LCG的性质，推导序列 $\\{b_t\\}$ 对于此步长是否关于 $t$ 不变。利用此结果确定在一个初始种子满足 $x_{n_0} \\bmod 2^{10} \\neq 0$ 的典型运行中，实现的每步碰撞率 $R_{\\text{biased}}$。\n- 提出一个由 $y_n = x_n \\oplus (x_n \\gg 16)$ 定义的特定位混合修正方法，其中 $\\oplus$ 表示按位异或，$\\gg$ 表示逻辑右移，并将决策规则切换为 $d_t = y_{n_t} \\bmod 2^{10}$，当且仅当 $d_t  T$ 时发生碰撞。分析此混合方法是否恢复了预期的事件率，并计算实现的每步碰撞率 $R_{\\text{mixed}}$。\n\n将最终答案表示为一个包含 $R_{\\text{biased}}$ 和 $R_{\\text{mixed}}$ 的两元行矩阵，使用精确分数形式，不要进行舍入。最终数值无需物理单位。",
            "solution": "此问题需经过验证。\n\n### 步骤1：提取给定条件\n-   **系统**：三维空间中的分子动力学。\n-   **恒温器**：Anderson恒温器。\n-   **随机碰撞模型**：每个粒子速率为 $\\nu$ 的泊松过程。\n-   **时间步长**：$\\Delta t$。\n-   **碰撞概率**：一个粒子在单个时间步内发生碰撞的概率为 $p = 1 - \\exp(-\\nu \\Delta t)$。\n-   **指定概率**：$p = 2^{-10}$。\n-   **伪随机数生成器 (PRNG)**：线性同余生成器 (LCG)。\n-   **LCG 定义**：$x_{n+1} = a x_n + c \\pmod{2^{32}}$。\n-   **LCG 参数**：\n    -   模数：$m = 2^{32}$。\n    -   乘数：$a \\equiv 1 \\pmod{4}$。\n    -   增量：$c$ 是一个奇整数。\n-   **初始碰撞决策规则**：\n    -   从PRNG状态 $x_{n_t}$ 的最低10位生成一个随机整数 $b_t = x_{n_t} \\bmod 2^{10}$。\n    -   当且仅当 $b_t  T$ 时发生碰撞。\n-   **阈值**：$T = \\lfloor p \\cdot 2^{10} \\rfloor$。\n-   **PRNG状态索引**：用于时间步 $t=0, 1, 2, \\dots$ 的PRNG状态序列在索引 $n_t = n_0 + t s$ 处采样。\n-   **步长**：$s = 2^{11}$。\n-   **初始条件**：一次典型运行以一个初始种子开始，该种子满足 $x_{n_0} \\bmod 2^{10} \\neq 0$。\n-   **修正方案**：\n    -   定义一个新的随机变量：$y_n = x_n \\oplus (x_n \\gg 16)$，其中 $\\oplus$ 是按位异或，$\\gg$ 是逻辑右移。\n    -   决策规则更改为使用 $d_t = y_{n_t} \\bmod 2^{10}$。\n    -   当且仅当 $d_t  T$ 时发生碰撞。\n-   **任务**：\n    1.  推导序列 $\\{b_t\\}$ 是否关于 $t$ 不变。\n    2.  确定初始规则下实现的每步碰撞率 $R_{\\text{biased}}$。\n    3.  分析修正方案是否恢复了预期速率。\n    4.  计算新规则下实现的每步碰撞率 $R_{\\text{mixed}}$。\n    5.  将最终答案表示为一个两元行矩阵 $[R_{\\text{biased}}, R_{\\text{mixed}}]$。\n\n### 步骤2：使用提取的给定条件进行验证\n-   **科学依据**：该问题在伪随机数生成的既定理论及其在计算物理学中的应用方面有充分的依据。模数为2的幂的LCG的性质是数值分析和计算机科学中的一个经典课题。所描述的缺陷（低位的相关性）和提议的修正方法（通过异或移位进行位混合）都是标准概念。\n-   **适定性**：该问题是自洽的，并提供了执行分析所需的所有必要参数（$m$、关于 $a$ 和 $c$ 的条件、$p$、$s$）和定义。问题是精确的，并导向一个唯一的数学解。\n-   **客观性**：该问题以正式、客观的语言陈述，没有任何主观或模糊的术语。\n\n### 步骤3：结论与行动\n该问题在科学上是合理的、适定的和客观的。它被判定为**有效**。将提供完整的解答。\n\n### 解答推导\n\n首先，我们确定碰撞阈值 $T$。给定碰撞概率 $p = 2^{-10}$，阈值为：\n$$\nT = \\lfloor p \\cdot 2^{10} \\rfloor = \\lfloor 2^{-10} \\cdot 2^{10} \\rfloor = \\lfloor 1 \\rfloor = 1\n$$\n如果生成的随机整数小于1，则发生碰撞，这意味着该整数必须为0。\n\n#### 第一部分：有偏率 $R_{\\text{biased}}$ 的分析\n\n第一个实现使用序列 $b_t = x_{n_t} \\bmod 2^{10}$。LCG由 $x_{n+1} = (a x_n + c) \\pmod{2^{32}}$ 定义，其中 $a \\equiv 1 \\pmod{4}$ 且 $c$ 为奇数。$a$ 和 $c$ 的这些条件确保了LCG具有 $2^{32}$ 的完整周期。\n\n模数为2的幂 $m = 2^k$ 的LCG的一个基本性质是，其低 $j$ 位序列 $z_n = x_n \\bmod 2^j$（对于 $j \\le k$）本身是周期性的。序列 $\\{z_n\\}$ 由 $z_{n+1} = (a z_n + c) \\pmod{2^j}$ 生成，并且对于给定的 $a$ 和 $c$ 的条件，其周期恰好为 $2^j$。\n\n在我们的案例中，我们关心的是最低10位的序列，所以我们考虑 $j=10$。序列 $\\{x_n \\bmod 2^{10}\\}$ 是周期性的，周期为 $2^{10}$。\n\n模拟代码不使用来自LCG的连续值。相反，它以步长 $s = 2^{11}$ 在索引 $n_t = n_0 + ts$ 处对LCG状态进行采样。我们分析在这些特定索引处的低位序列：\n$$\nb_t = x_{n_t} \\bmod 2^{10} = x_{n_0 + ts} \\bmod 2^{10}\n$$\n步长为 $s = 2^{11} = 2 \\cdot 2^{10}$。此步长是低10位序列周期的整数倍。因此，对于任何整数 $t \\ge 0$：\n$$\nx_{n_0 + ts} \\equiv x_{n_0} \\pmod{2^{10}}\n$$\n这意味着对于所有的 $t$，$b_t = x_{n_0} \\bmod 2^{10} = b_0$。序列 $\\{b_t\\}$ 在时间上是不变的；它是一个常数序列。\n\n问题指定模拟以一个种子启动，使得 $x_{n_0} \\bmod 2^{10} \\neq 0$。这意味着 $b_0 \\neq 0$。由于对于所有后续时间步 $b_t = b_0$，我们有对于所有的 $t$，$b_t \\neq 0$。\n\n当且仅当 $b_t = 0$ 时发生碰撞。由于这个条件永远不会满足，所以永远不会发生碰撞。因此，实现的每步碰撞率为零。\n$$\nR_{\\text{biased}} = 0\n$$\n\n#### 第二部分：混合率 $R_{\\text{mixed}}$ 的分析\n\n提议的修正方法使用一个新的随机变量 $y_n = x_n \\oplus (x_n \\gg 16)$，其中 $\\oplus$ 是按位异或，$\\gg$ 是逻辑右移16位。决策基于 $d_t = y_{n_t} \\bmod 2^{10}$。\n\n让我们将32位整数 $x_n$ 分解为其高16位和低16位部分：\n$H_n = \\lfloor x_n / 2^{16} \\rfloor$ (高位)\n$L_n = x_n \\bmod 2^{16}$ (低位)\n因此，$x_n = H_n \\cdot 2^{16} + L_n$。\n操作 $x_n \\gg 16$ 产生整数 $H_n$。\n按位异或操作 $y_n = x_n \\oplus H_n$ 产生一个数，其高16位为 $H_n \\oplus 0 = H_n$，其低16位为 $L_n \\oplus H_n$。\n$y_n = H_n \\cdot 2^{16} + (L_n \\oplus H_n)$。\n\n决策规则使用 $d_t = y_{n_t} \\bmod 2^{10}$。该值取决于 $y_{n_t}$ 的低16位部分的最低10位：\n$$\nd_t = (L_{n_t} \\oplus H_{n_t}) \\bmod 2^{10}\n$$\n令 $l_t = L_{n_t} \\bmod 2^{10}$ 且 $h_t = H_{n_t} \\bmod 2^{10}$。我们可以将 $d_t$ 写为：\n$$\nd_t = l_t \\oplus h_t\n$$\n值 $l_t$ 来自 $x_{n_t}$ 的低位。具体来说，$l_t = (x_{n_t} \\bmod 2^{16}) \\bmod 2^{10} = x_{n_t} \\bmod 2^{10}$。正如在第一部分中确立的，这个序列是常数：$l_t = l_0 = x_{n_0} \\bmod 2^{10}$。\n\n值 $h_t$ 来自 $x_{n_t}$ 的高位。已知全周期LCG的高位序列表现出良好的统计特性，非常接近均匀分布。LCG序列本身以一个大步长 $s=2^{11}$ 进行采样，该步长不是全周期 $2^{32}$ 的倍数，从而确保采样状态 $x_{n_t}$ 不是平凡相关的。一个标准且有科学依据的假设是，由此产生的高位序列 $\\{H_{n_t}\\}$ 及其截断 $\\{h_t\\}$ 在集合 $\\{0, 1, \\dots, 2^{10}-1\\}$ 上是均匀分布的。\n\n现在考虑序列 $d_t = l_0 \\oplus h_t$。我们将一个均匀分布的序列 $\\{h_t\\}$ 与一个常数值 $l_0$ 进行异或运算。函数 $f(z) = l_0 \\oplus z$ 是集合 $\\{0, 1, \\dots, 2^{10}-1\\}$ 上的一个双射。对一个均匀分布序列的双射变换会得到一个均匀分布的序列。因此，序列 $\\{d_t\\}$ 在 $\\{0, 1, \\dots, 2^{10}-1\\}$ 上是均匀分布的。\n\n$d_t$ 在其范围内取任何特定值 $k$ 的概率是：\n$$\nP(d_t = k) = \\frac{1}{2^{10}}\n$$\n碰撞条件是 $d_t  T=1$，即 $d_t=0$。此事件的概率是：\n$$\nP(d_t = 0) = \\frac{1}{2^{10}}\n$$\n这个概率就是实现的每步碰撞率 $R_{\\text{mixed}}$。\n$$\nR_{\\text{mixed}} = \\frac{1}{2^{10}} = \\frac{1}{1024}\n$$\n此速率与预期的碰撞率 $p=2^{-10}$ 相匹配，因此位混合修正方法成功地恢复了所需的统计行为。\n\n最终答案将两个结果按指定格式组合。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 0  \\frac{1}{1024} \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "认识到PRNG可能存在的缺陷后，下一步是学习如何系统性地验证它们在具体模拟中的表现。这个综合性练习要求你构建一个嵌入式的迷你测试套件，在郎之万动力学模拟的生产运行中，实时诊断随机数的质量。通过实施诸如柯尔莫哥洛夫-斯米尔诺夫检验、游程检验和周期图检验等标准统计测试，你将学会如何量化PRNG的性能，并确保模拟的物理保真度。",
            "id": "3439285",
            "problem": "您的任务是编写一个完整、可运行的程序，将一个小型测试套件嵌入到一个简单的分子动力学（MD）工作流中，通过在恒温动力学分析中常用的诊断性统计检验来评估伪随机数生成器（PRNG）。该程序必须实现一个在谐振子势中的单个粒子的三维朗之万动力学模拟（使用无量纲单位），检验所生成的随机序列的统计特性，并根据通过率及其对测量可观测量的影响对 PRNG 进行排名。\n\n其理论基础是质量为 $m$、位置为 $\\mathbf{x}$、速度为 $\\mathbf{v}$ 的粒子在力常数为 $k$ 的谐振子势中的朗之万方程，其形式为\n$$ m \\frac{d\\mathbf{v}}{dt} = - \\gamma m \\mathbf{v} - \\nabla U(\\mathbf{x}) + \\sqrt{2 \\gamma m k_{\\mathrm{B}} T} \\, \\boldsymbol{\\eta}(t), $$\n其中 $U(\\mathbf{x}) = \\frac{1}{2} k \\lVert \\mathbf{x} \\rVert^2$，$\\gamma$ 是摩擦系数，$T$ 是温度，$k_{\\mathrm{B}}$ 是玻尔兹曼常数，$\\boldsymbol{\\eta}(t)$ 是一个零均值、单位方差且在时间上具有 delta 相关性的高斯白噪声。程序必须使用随机速度 Verlet 积分器的一个科学上合理的变体来离散化动力学过程，该变体在时间步长 $\\Delta t$ 上使用精确的 Ornstein–Uhlenbeck 速度更新，通常组织为“BAOAB”序列：确定性半步速度更新、确定性半步位置更新、随机速度更新、确定性半步位置更新以及确定性半步速度更新。\n\n需要执行的诊断检验：\n1. 柯尔莫哥洛夫-斯米尔诺夫（K–S）检验：对每个速度分量 $v_x$、$v_y$、$v_z$，检验零假设，即抽样分量服从均值为 $0$、方差为 $\\sigma^2 = k_{\\mathrm{B}} T / m$ 的高斯分布。在显著性水平 $\\alpha = 0.05$ 下使用单样本 K–S 检验，如果 $p$ 值 $\\ge 0.05$，则记录为通过。\n2. 对恒温器冲击的游程检验：考虑在随机 Ornstein–Uhlenbeck 速度更新（即“恒温器冲击”）中内部使用的一个选定分量的标准正态变量序列。通过将样本分类为“大于零”或“小于零”（若有精确零值则舍弃）将此序列转换为二进制序列，计算游程数 $R$（即相同分类的连续子序列的数量），并评估大样本 $z$ 分数\n   $$ z = \\frac{R - \\mathbb{E}[R]}{\\sqrt{\\mathrm{Var}[R]}}, \\quad \\mathbb{E}[R] = \\frac{2 n_+ n_-}{n} + 1, \\quad \\mathrm{Var}[R] = \\frac{2 n_+ n_- (2 n_+ n_- - n)}{n^2 (n - 1)}, $$\n   其中 $n_+$ 是正数个数，$n_-$ 是负数个数，$n = n_+ + n_-$。如果 $\\lvert z \\rvert \\le 2.0$，则记录为通过；如果 $n_+ = 0$ 或 $n_- = 0$，则记录为不通过。\n3. 对随机力的周期图检验：为一个选定分量构建离散随机力冲量序列，形式为 $F_n^{\\mathrm{noise}} = m \\Delta v_n^{\\mathrm{noise}} / \\Delta t$，其中 $\\Delta v_n^{\\mathrm{noise}}$ 是第 $n$ 步的随机速度增量。通过对去均值序列进行离散傅里叶变换来计算周期图，并使用最小二乘线性回归估计非零频率下频率与功率之间对数-对数关系的斜率 $s$。如果 $\\lvert s \\rvert \\le 0.15$，则记录为通过。\n\n需要测量的可观测量：\n- 动能温度误差：对于每个测试用例，计算目标温度与测得的动能温度之间的绝对误差，\n  $$ T_{\\mathrm{meas}} = \\frac{m}{3 k_{\\mathrm{B}}} \\left\\langle v_x^2 + v_y^2 + v_z^2 \\right\\rangle, \\quad \\Delta T = \\lvert T_{\\mathrm{meas}} - T \\rvert, $$\n  其中平均值 $\\langle \\cdot \\rangle$ 是对生产运行中所有记录的时间步进行平均。使用 $k_{\\mathrm{B}} = 1$。\n\n程序要求：\n- 实现一个三维模拟，恒温器步骤采用 BAOAB 序列和在 $\\Delta t$ 上的精确 Ornstein–Uhlenbeck 速度更新；$c = e^{-\\gamma \\Delta t}$ 是速度衰减因子，每个分量的随机增量的标准差为 $\\sqrt{(k_{\\mathrm{B}} T / m) (1 - c^2)}$。\n- 丢弃前 $10\\%$ 的步数作为平衡阶段，使用剩余的步数进行诊断和可观测量测量。\n- 使用三种 PRNG：$0$ 代表“MT19937”，$1$ 代表“PCG64”，$2$ 代表“Philox”。每个 PRNG 必须使用特定于该测试用例的种子进行实例化。\n- 对于每个测试用例，执行上述三种诊断检验，得出五个通过/不通过的结果（三个 K–S 分量检验，一个游程检验，一个周期图检验）。将测试用例的通过率定义为这五个结果中通过的比例。\n- 根据所有测试用例的平均通过率对 PRNG 进行排名。如果出现平局，则通过比较 PRNG 在所有测试用例中的平均动能温度误差来打破平局，误差较小者排名靠前。\n\n测试套件：\n- 使用以下九个测试用例，每个用例是一个元组 $(\\mathrm{prng\\_id}, T, \\gamma, k, m, \\Delta t, N, \\mathrm{seed})$，其中 $k_{\\mathrm{B}} = 1$：\n  1. $(0, 1.0, 1.0, 1.0, 1.0, 0.001, 20000, 12345)$\n  2. $(1, 1.0, 1.0, 1.0, 1.0, 0.001, 20000, 12346)$\n  3. $(2, 1.0, 1.0, 1.0, 1.0, 0.001, 20000, 12347)$\n  4. $(0, 1.0, 1.0, 1.0, 1.0, 0.001, 6000, 22345)$\n  5. $(1, 1.0, 1.0, 1.0, 1.0, 0.001, 6000, 22346)$\n  6. $(2, 1.0, 1.0, 1.0, 1.0, 0.001, 6000, 22347)$\n  7. $(0, 1.0, 2.0, 10.0, 1.0, 0.001, 20000, 32345)$\n  8. $(1, 1.0, 2.0, 10.0, 1.0, 0.001, 20000, 32346)$\n  9. $(2, 1.0, 2.0, 10.0, 1.0, 0.001, 20000, 32347)$\n\n最终输出规范：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，内容和顺序如下：\n  1. 三个整数，给出按标识符 $(0, 1, 2)$ 排名的 PRNG 顺序，如前所述（排在第一位的最好）。\n  2. 三个浮点数，给出 PRNG $0$、$1$ 和 $2$ 在所有九个测试用例中的平均通过率。\n  3. 三个浮点数，给出 PRNG $0$、$1$ 和 $2$ 在所有九个测试用例中的平均绝对动能温度误差 $\\Delta T$。\n  4. 九个布尔值，按上述测试套件的顺序，给出每个测试用例是否通过了所有五个诊断检验（如果全部五个都通过则为 true，否则为 false）。\n\n示例格式（非实际值）：$[2,1,0,0.84,0.82,0.80,0.02,0.03,0.05,True,False,True,True,True,False,True,True,True]$。\n\n除了上述无量纲规范外，不需要任何物理单位。不使用角度。所有数值量必须根据需要以浮点数运算表示。",
            "solution": "该问题被评估为有效，因为它具有科学依据、问题陈述清晰，并包含足够的信息来构建一个唯一且有意义的解决方案。该任务要求在分子动力学背景下实现一个计算测试套件，以评估伪随机数生成器（PRNG），这是计算科学中确保模拟保真度的标准做法。\n\n解决方案的结构如下：\n首先，一个主函数遍历一组预定义的九个测试用例。每个测试用例指定了要使用的 PRNG、朗之万动力学模拟的物理参数以及模拟控制参数。对于每个用例，一个专用函数执行模拟、进行统计诊断，并计算一个关键的物理可观测量。然后汇总结果，以对 PRNG 进行排名，并按规定格式化最终输出。\n\n程序的核心是一个三维朗之万动力学模拟，模拟一个质量为 $m$ 的粒子在谐振子势 $U(\\mathbf{x}) = \\frac{1}{2} k \\lVert \\mathbf{x} \\rVert^2$ 中的运动，其受力为 $\\mathbf{F}(\\mathbf{x}) = -\\nabla U(\\mathbf{x}) = -k\\mathbf{x}$。动力学过程使用针对随机微分方程的 BAOAB 分裂方案进行传播。这个积分器序列包含在时间步长 $\\Delta t$ 内应用的五个步骤：\n1.  **B（速度半步）：** 速度 $\\mathbf{v}$ 在确定性力作用下更新 $\\Delta t / 2$。给定时间步开始时的速度 $\\mathbf{v}_n$，更新公式为 $\\mathbf{v}_{n+1/4} = \\mathbf{v}_n + \\frac{\\mathbf{F}(\\mathbf{x}_n)}{m} \\frac{\\Delta t}{2}$。\n2.  **A（位置半步）：** 位置 $\\mathbf{x}$ 使用新速度更新 $\\Delta t / 2$：$\\mathbf{x}_{n+1/2} = \\mathbf{x}_n + \\mathbf{v}_{n+1/4} \\frac{\\Delta t}{2}$。\n3.  **O（随机速度步）：** 速度根据 Ornstein-Uhlenbeck 过程在整个时间步长 $\\Delta t$ 上的精确解进行更新。此步骤模拟了摩擦和随机热浴的影响。每个速度分量的更新公式为 $v' = c v + \\sigma_v \\xi$，其中 $c = e^{-\\gamma \\Delta t}$ 是由摩擦 $\\gamma$ 引起的速度衰减因子，$\\xi$ 是从标准正态分布 $\\mathcal{N}(0, 1)$ 中抽取的随机数，$\\sigma_v = \\sqrt{(k_{\\mathrm{B}} T / m) (1 - c^2)}$ 是热冲击的标准差。这里 $k_{\\mathrm{B}}$ 是玻尔兹曼常数（设为 $1$），$T$ 是目标温度。此步骤将速度从 $\\mathbf{v}_{n+1/4}$ 更新到 $\\mathbf{v}_{n+3/4}$。\n4.  **A（位置半步）：** 位置使用恒温后的速度再更新 $\\Delta t / 2$：$\\mathbf{x}_{n+1} = \\mathbf{x}_{n+1/2} + \\mathbf{v}_{n+3/4} \\frac{\\Delta t}{2}$。\n5.  **B（速度半步）：** 最后，使用新位置处的力进行 $\\Delta t / 2$ 的确定性速度更新，完成该步骤：$\\mathbf{v}_{n+1} = \\mathbf{v}_{n+3/4} + \\frac{\\mathbf{F}(\\mathbf{x}_{n+1})}{m} \\frac{\\Delta t}{2}$。\n\n在每次模拟（总共运行 $N$ 步）期间，会记录几个数据序列。轨迹的前 $10\\%$ 作为平衡阶段被丢弃。剩下的 $90\\%$（生产运行）用于分析。对这些数据执行三个诊断检验，产生五个通过/不通过的结果：\n\n1.  **柯尔莫哥洛夫-斯米尔诺夫（K–S）检验：** 对于每个速度分量（$v_x, v_y, v_z$），将采样速度的经验分布与理论上的麦克斯韦-玻尔兹曼分布进行比较，后者是均值为 $0$、方差为 $\\sigma^2 = k_{\\mathrm{B}} T / m$ 的高斯分布。使用 `scipy.stats` 中的单样本 K-S 检验。如果得到的 $p$ 值大于或等于显著性水平 $\\alpha = 0.05$，则认为检验通过。\n\n2.  **游程检验：** 该检验评估恒温器中使用的随机数的序列独立性。将在 O 步中为一个分量（例如，$x$）抽样的标准正态变量序列 $\\{\\xi_i\\}$，根据样本相对于零的符号转换为二进制序列。计算游程数 $R$（相同符号的连续子序列的数量）。使用期望值 $\\mathbb{E}[R]$ 和方差 $\\mathrm{Var}[R]$ 的大样本近似值计算 $z$ 分数，$z = (R - \\mathbb{E}[R]) / \\sqrt{\\mathrm{Var}[R]}$。如果 $|z| \\le 2.0$（对应约 $95\\%$ 的置信水平），则检验通过。如果序列只包含一种符号的变量，则检验不通过。\n\n3.  **周期图检验：** 该检验检查随机力的行为是否像白噪声，白噪声应具有平坦的功率谱。分析一个分量的离散随机力冲量序列 $F_n^{\\mathrm{noise}} = m \\Delta v_n^{\\mathrm{noise}} / \\Delta t$，其中 $\\Delta v_n^{\\mathrm{noise}} = \\sigma_v \\xi_n$。通过快速傅里叶变换计算功率谱密度（周期图）。对于白噪声，功率与频率的对数-对数图的斜率应接近于零。对非零频率的对数-对数数据进行线性回归。如果斜率的绝对值 $|s|$ 小于或等于 $0.15$，则检验通过。\n\n对于每个测试用例，通过率是这五个诊断检验中通过的比例。此外，通过对生产运行进行平均，计算测得的动能温度 $T_{\\mathrm{meas}} = \\frac{m}{3 k_{\\mathrm{B}}} \\langle v_x^2 + v_y^2 + v_z^2 \\rangle$。计算绝对误差 $\\Delta T = |T_{\\mathrm{meas}} - T|$。\n\n最后，对 PRNG 进行排名。主要排名标准是每个 PRNG 在其特定测试用例中的平均通过率。平均通过率越高越好。如果出现平局，平均动能温度误差 $\\Delta T$ 较低的 PRNG 排名更高。然后程序打印出排好序的 PRNG 标识符、每个 PRNG 的平均通过率和温度误差（按固定顺序 $0, 1, 2$），以及针对九个测试用例中每一个的布尔值，该值指示是否所有五个诊断都已通过。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import kstest, norm, linregress\n\ndef _run_single_test(test_case):\n    \"\"\"\n    Runs a single MD simulation and performs all diagnostics.\n    \"\"\"\n    prng_id, T, gamma, k, m, dt, N, seed = test_case\n    kB = 1.0\n\n    # Initialize the PRNG based on the provided ID and seed\n    prng_map = {0: np.random.MT19937, 1: np.random.PCG64, 2: np.random.Philox}\n    rng = np.random.Generator(prng_map[prng_id](seed))\n\n    # Initialize particle state (position and velocity)\n    x = np.zeros(3, dtype=np.float64)\n    v = np.zeros(3, dtype=np.float64)\n\n    # Pre-calculate constants for the BAOAB integrator\n    c = np.exp(-gamma * dt)\n    stoch_std = np.sqrt((kB * T / m) * (1 - c**2))\n\n    # Allocate history arrays for analysis\n    vel_history = np.zeros((N, 3), dtype=np.float64)\n    xi_x_history = np.zeros(N, dtype=np.float64)\n    f_noise_x_history = np.zeros(N, dtype=np.float64)\n\n    # Main simulation loop\n    for n in range(N):\n        # B-step: half-step velocity update\n        force = -k * x\n        v += 0.5 * dt * force / m\n\n        # A-step: half-step position update\n        x += 0.5 * dt * v\n\n        # O-step: full-step stochastic velocity update\n        xi = rng.normal(size=3)\n        stoch_increment = stoch_std * xi\n        v = c * v + stoch_increment\n        \n        # Store data for diagnostics\n        xi_x_history[n] = xi[0]\n        f_noise_x_history[n] = m * stoch_increment[0] / dt\n\n        # A-step: second half-step position update\n        x += 0.5 * dt * v\n\n        # B-step: second half-step velocity update\n        force = -k * x\n        v += 0.5 * dt * force / m\n\n        vel_history[n, :] = v\n\n    # Discard equilibration steps (first 10%)\n    equil_steps = int(0.1 * N)\n    prod_vel = vel_history[equil_steps:]\n    prod_xi_x = xi_x_history[equil_steps:]\n    prod_f_noise_x = f_noise_x_history[equil_steps:]\n\n    total_passes = 0\n    \n    # Diagnostic 1: Kolmogorov–Smirnov test (3 outcomes)\n    ks_passes = 0\n    target_v_std = np.sqrt(kB * T / m)\n    for i in range(3):\n        _stat, p_value = kstest(prod_vel[:, i], 'norm', args=(0, target_v_std))\n        if p_value >= 0.05:\n            ks_passes += 1\n    total_passes += ks_passes\n    \n    # Diagnostic 2: Runs test (1 outcome)\n    runs_pass = False\n    seq = prod_xi_x[prod_xi_x != 0]\n    n_plus = np.sum(seq > 0)\n    n_minus = len(seq) - n_plus\n    n = n_plus + n_minus\n    \n    if n_plus > 0 and n_minus > 0 and n > 1:\n        R = np.sum(np.diff(seq > 0) != 0) + 1\n        E_R = (2 * n_plus * n_minus / n) + 1\n        var_R_num = 2 * n_plus * n_minus * (2 * n_plus * n_minus - n)\n        var_R_den = n**2 * (n - 1)\n        \n        if var_R_den > 0:\n            var_R = var_R_num / var_R_den\n            if var_R > 0:\n                z = (R - E_R) / np.sqrt(var_R)\n                if np.abs(z) = 2.0:\n                    runs_pass = True\n    if runs_pass:\n        total_passes += 1\n\n    # Diagnostic 3: Periodogram test (1 outcome)\n    periodogram_pass = False\n    f_demeaned = prod_f_noise_x - np.mean(prod_f_noise_x)\n    n_fft = len(f_demeaned)\n\n    if n_fft >= 2:\n        freqs = np.fft.rfftfreq(n_fft, d=dt)\n        power = np.abs(np.fft.rfft(f_demeaned))**2\n        valid_indices = (freqs > 0)  (power > 0)\n        \n        if np.sum(valid_indices) >= 2:\n            log_freqs = np.log(freqs[valid_indices])\n            log_power = np.log(power[valid_indices])\n            res = linregress(log_freqs, log_power)\n            if np.abs(res.slope) = 0.15:\n                periodogram_pass = True\n    if periodogram_pass:\n        total_passes += 1\n\n    pass_rate = total_passes / 5.0\n    all_passed = (total_passes == 5)\n    \n    # Observable: Kinetic temperature error\n    v_sq_sum = np.sum(prod_vel**2, axis=1)\n    mean_v_sq_sum = np.mean(v_sq_sum)\n    T_meas = (m / (3 * kB)) * mean_v_sq_sum\n    temp_error = np.abs(T_meas - T)\n\n    return pass_rate, temp_error, all_passed\n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (prng_id, T, gamma, k, m, dt, N, seed)\n        (0, 1.0, 1.0, 1.0, 1.0, 0.001, 20000, 12345),\n        (1, 1.0, 1.0, 1.0, 1.0, 0.001, 20000, 12346),\n        (2, 1.0, 1.0, 1.0, 1.0, 0.001, 20000, 12347),\n        (0, 1.0, 1.0, 1.0, 1.0, 0.001, 6000, 22345),\n        (1, 1.0, 1.0, 1.0, 1.0, 0.001, 6000, 22346),\n        (2, 1.0, 1.0, 1.0, 1.0, 0.001, 6000, 22347),\n        (0, 1.0, 2.0, 10.0, 1.0, 0.001, 20000, 32345),\n        (1, 1.0, 2.0, 10.0, 1.0, 0.001, 20000, 32346),\n        (2, 1.0, 2.0, 10.0, 1.0, 0.001, 20000, 32347),\n    ]\n\n    results_by_prng = {0: [], 1: [], 2: []}\n    all_tests_passed_flags = []\n\n    for case in test_cases:\n        prng_id = case[0]\n        pass_rate, temp_error, all_passed = _run_single_test(case)\n        results_by_prng[prng_id].append((pass_rate, temp_error))\n        all_tests_passed_flags.append(all_passed)\n        \n    # Calculate average statistics for each PRNG\n    avg_pass_rates = {}\n    avg_temp_errors = {}\n    for prng_id in [0, 1, 2]:\n        rates = [r[0] for r in results_by_prng[prng_id]]\n        errors = [r[1] for r in results_by_prng[prng_id]]\n        avg_pass_rates[prng_id] = np.mean(rates) if rates else 0.0\n        avg_temp_errors[prng_id] = np.mean(errors) if errors else 0.0\n\n    # Rank PRNGs: primary key is pass rate (desc), secondary is temp error (asc)\n    ranking_data = [\n        (avg_pass_rates[i], avg_temp_errors[i], i) for i in [0, 1, 2]\n    ]\n    ranking_data.sort(key=lambda x: (-x[0], x[1]))\n    ranked_prng_ids = [item[2] for item in ranking_data]\n\n    # Assemble the final output list in the specified order\n    final_output_list = []\n    final_output_list.extend(ranked_prng_ids)\n    final_output_list.extend([avg_pass_rates[0], avg_pass_rates[1], avg_pass_rates[2]])\n    final_output_list.extend([avg_temp_errors[0], avg_temp_errors[1], avg_temp_errors[2]])\n    final_output_list.extend(all_tests_passed_flags)\n\n    # Format and print the final output string\n    print(f\"[{','.join(map(str, final_output_list))}]\")\n\nsolve()\n```"
        }
    ]
}