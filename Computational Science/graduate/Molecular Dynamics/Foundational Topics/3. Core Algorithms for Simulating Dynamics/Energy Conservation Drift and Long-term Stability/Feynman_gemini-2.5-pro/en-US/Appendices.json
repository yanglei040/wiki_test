{
    "hands_on_practices": [
        {
            "introduction": "Theoretical knowledge comes to life through application. This first exercise provides a foundational, hands-on comparison between a symplectic integrator (velocity Verlet) and a non-symplectic one (classical fourth-order Runge-Kutta). By implementing and running these integrators on simple, well-understood physical systems, you will compute key diagnostics that quantify energy drift, fluctuation, and time-reversibility, offering a clear, practical demonstration of their distinct long-term stability properties .",
            "id": "3409941",
            "problem": "Consider a deterministic, closed classical system in molecular dynamics with a Hamiltonian $H(q,p) = T(p) + U(q)$, where $q$ denotes positions, $p$ denotes momenta, $T(p)$ is the kinetic energy, and $U(q)$ is the potential energy. The exact dynamics follow Newton's second law and Hamilton's equations, ensuring that the total energy $E(t) = H(q(t),p(t))$ is conserved, i.e., $dE/dt = 0$ for the continuous trajectory. In a discrete-time numerical simulation with time step $\\Delta t$, the numerical flow depends on the integrator. Symplectic, time-reversible integrators (for example, the velocity Verlet method) are known to exhibit near-conservation of a modified (shadow) Hamiltonian over long times, while generic non-symplectic integrators (for example, the classical fourth-order Runge–Kutta method) may exhibit secular energy drift. Energy audits and diagnostics quantify energy conservation, drift, and long-term stability of an algorithm on a given system.\n\nYour task is to implement two numerical integrators for two systems, run long trajectories, and compute three diagnostics for each test case:\n\n- A linear energy drift rate $s$ defined by the slope of the least-squares fit of $\\Delta E(t) = E(t) - E(0)$ as a function of $t$.\n- The root-mean-square fluctuation amplitude $R$ of $\\Delta E(t)$ after subtracting the best-fit line, i.e., the square root of the mean of the squared residuals of the fit.\n- A time-reversibility error $J$ computed by integrating forward for $N$ steps, reversing velocities, integrating for another $N$ steps, and measuring the Euclidean phase-space error between the final state and the initial state.\n\nBase your work on the following fundamental laws and definitions only:\n- Newton's second law: $m \\, \\ddot{q} = F(q)$ with $F(q) = - \\nabla U(q)$.\n- Kinematics: $\\dot{q} = v$, $\\dot{v} = a(q)$ with $a(q) = F(q)/m$.\n- Kinetic and potential energy definitions appropriate to each system.\n- Standard, widely used numerical schemes (velocity Verlet and classical fourth-order Runge–Kutta) applied to the first-order system in $(q,v)$.\n\nImplement both integrators for two closed systems in reduced units:\n\nSystem A (one-dimensional harmonic oscillator):\n- Mass $m = 1$.\n- Spring constant $k = 1$.\n- Force $F(x) = -k x$.\n- Energy $E = \\tfrac{1}{2} m v^2 + \\tfrac{1}{2} k x^2$.\n\nSystem B (two-particle Lennard–Jones dimer in three dimensions):\n- Two identical particles with mass $m = 1$.\n- Lennard–Jones parameters $\\varepsilon = 1$, $\\sigma = 1$. The pair potential for interparticle distance $r$ is $U(r) = 4 \\varepsilon \\left[ (\\sigma/r)^{12} - (\\sigma/r)^6 \\right]$.\n- Forces are central and equal in magnitude and opposite in direction on the two particles.\n- Energy $E = \\sum_{i=1}^{2} \\tfrac{1}{2} m \\|v_i\\|^2 + U(\\|r_1 - r_2\\|)$.\n\nDiagnostics to compute for each test case:\n- Fit $\\Delta E(t)$ to a straight line $\\Delta E(t) \\approx s \\, t + b$ by least squares over the full trajectory including $t = 0$, and report the fitted slope $s$.\n- Report $R = \\sqrt{\\tfrac{1}{M} \\sum_{j=1}^{M} [\\Delta E(t_j) - (s \\, t_j + b)]^2}$ where $M$ is the number of sampled time points.\n- For time reversibility, start at $(q_0,v_0)$, integrate forward $N$ steps to $(q_N, v_N)$, set $(q^*, v^*) = (q_N, -v_N)$, integrate forward another $N$ steps to $(\\tilde{q}, \\tilde{v})$, and report $J = \\sqrt{\\| \\tilde{q} - q_0 \\|^2 + \\| \\tilde{v} - v_0 \\|^2}$.\n\nUse the following test suite. All quantities are specified in reduced units, and all outputs must be reported as decimal floats in reduced energy units per unit time for $s$, in reduced energy units for $R$, and in reduced units for $J$.\n\nTest case $1$ (System A, velocity Verlet):\n- Initial condition: $x(0) = 1$, $v(0) = 0$.\n- Time step: $\\Delta t = 0.1$.\n- Number of steps: $N = 20000$.\n\nTest case $2$ (System A, classical fourth-order Runge–Kutta):\n- Initial condition: $x(0) = 1$, $v(0) = 0$.\n- Time step: $\\Delta t = 0.1$.\n- Number of steps: $N = 20000$.\n\nTest case $3$ (System B, velocity Verlet):\n- Initial positions: $r_1(0) = (-0.65, 0, 0)$, $r_2(0) = (0.65, 0, 0)$ so that the initial separation is $r(0) = 1.3$.\n- Initial velocities: $v_1(0) = (0, 0, 0)$, $v_2(0) = (0, 0, 0)$.\n- Time step: $\\Delta t = 0.002$.\n- Number of steps: $N = 20000$.\n\nTest case $4$ (System A, velocity Verlet, near stability boundary):\n- Initial condition: $x(0) = 1$, $v(0) = 0$.\n- Time step: $\\Delta t = 1.9$.\n- Number of steps: $N = 5000$.\n\nNumerical requirements:\n- Implement both the velocity Verlet and the classical fourth-order Runge–Kutta integrators applied to the first-order system in $(q,v)$.\n- Use double-precision arithmetic.\n- Sample and use the energy at every integer multiple of $\\Delta t$ from $t = 0$ to $t = N \\Delta t$, inclusive, for the regression.\n- The least-squares fit must include an intercept $b$.\n- The time-reversibility test uses the same $\\Delta t$ and $N$ as the energy audit for each case.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to a test case and is itself a three-element list $[s,R,J]$ in that order. For example, produce a line of the form $[[s_1,R_1,J_1],[s_2,R_2,J_2],[s_3,R_3,J_3],[s_4,R_4,J_4]]$ with no embedded spaces.",
            "solution": "The problem posed requires a numerical investigation into the properties of two common integration algorithms used in molecular dynamics: the velocity Verlet method and the classical fourth-order Runge-Kutta (RK4) method. The investigation will be conducted on two representative physical systems: a one-dimensional harmonic oscillator and a three-dimensional two-particle Lennard-Jones system. The core of the task is to quantify three critical performance metrics for these integrators: the long-term energy drift rate ($s$), the amplitude of energy fluctuations ($R$), and the time-reversibility error ($J$). This analysis highlights the fundamental differences between symplectic, time-reversible integrators and general-purpose, non-symplectic ones in the context of long-term simulations of conservative systems.\n\n**Numerical Integration Algorithms**\n\nThe dynamics of the systems are governed by Newton's second law, which can be expressed as a system of first-order ordinary differential equations (ODEs):\n$$\n\\frac{d\\mathbf{q}}{dt} = \\mathbf{v}\n$$\n$$\n\\frac{d\\mathbf{v}}{dt} = \\mathbf{a}(\\mathbf{q}) = \\frac{\\mathbf{F}(\\mathbf{q})}{m}\n$$\nwhere $\\mathbf{q}$, $\\mathbf{v}$, and $\\mathbf{a}$ are the generalized positions, velocities, and accelerations, respectively, and $m$ is the mass.\n\n**Velocity Verlet Integrator**\nThe velocity Verlet algorithm is a geometric integrator, specifically designed for Hamiltonian systems. It advances the state from time $t$ to $t+\\Delta t$ through the following sequence:\n$1$. Update velocity to a half-step:\n$$\n\\mathbf{v}(t + \\tfrac{1}{2}\\Delta t) = \\mathbf{v}(t) + \\tfrac{1}{2}\\mathbf{a}(t)\\Delta t\n$$\n$2$. Update position to the full step:\n$$\n\\mathbf{q}(t + \\Delta t) = \\mathbf{q}(t) + \\mathbf{v}(t + \\tfrac{1}{2}\\Delta t)\\Delta t\n$$\n$3$. Compute the new acceleration $\\mathbf{a}(t+\\Delta t)$ from the force at the new position $\\mathbf{q}(t+\\Delta t)$.\n$4$. Complete the velocity update to the full step:\n$$\n\\mathbf{v}(t + \\Delta t) = \\mathbf{v}(t + \\tfrac{1}{2}\\Delta t) + \\tfrac{1}{2}\\mathbf{a}(t + \\Delta t)\\Delta t\n$$\nThe key properties of the velocity Verlet method are that it is both symplectic and time-reversible. Symplecticity ensures that the integrator exactly preserves a \"shadow\" Hamiltonian, a conserved quantity that is a close approximation to the true Hamiltonian of the system. This leads to bounded oscillations of the measured energy $E(t)$ around its initial value and precludes systematic, long-term energy drift. Time-reversibility ensures that integrating backward in time perfectly undoes a forward integration step, a property crucial for long-term stability.\n\n**Classical Fourth-Order Runge-Kutta (RK4) Integrator**\nThe RK4 method is a widely used, high-accuracy, general-purpose ODE solver. For a first-order system $\\dot{\\mathbf{y}} = f(\\mathbf{y})$, where the state vector is $\\mathbf{y} = (\\mathbf{q}, \\mathbf{v})$ and the time-independent derivative is $f(\\mathbf{y}) = (\\mathbf{v}, \\mathbf{a}(\\mathbf{q}))$, a single step from $\\mathbf{y}_n$ to $\\mathbf{y}_{n+1}$ is given by:\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{\\Delta t}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n$$\nThe intermediate stage vectors $\\mathbf{k}_i$ are calculated as:\n$$\n\\begin{aligned}\n\\mathbf{k}_1 = f(\\mathbf{y}_n) \\\\\n\\mathbf{k}_2 = f(\\mathbf{y}_n + \\tfrac{1}{2}\\Delta t \\mathbf{k}_1) \\\\\n\\mathbf{k}_3 = f(\\mathbf{y}_n + \\tfrac{1}{2}\\Delta t \\mathbf{k}_2) \\\\\n\\mathbf{k}_4 = f(\\mathbf{y}_n + \\Delta t \\mathbf{k}_3)\n\\end{aligned}\n$$\nWhile RK4 has a high local accuracy (step error of order $O(\\Delta t^5)$), it is not a symplectic algorithm. As a result, it does not conserve a shadow Hamiltonian and, for Hamiltonian systems, typically introduces a secular (systematic) drift in the total energy over long simulation times. It is also not time-reversible, which is another contributor to its poor long-term stability in this context.\n\n**Physical Systems**\n\n**System A: 1D Harmonic Oscillator**\nThis is a fundamental linear system with mass $m=1$ and spring constant $k=1$.\n- Potential energy: $U(x) = \\tfrac{1}{2} k x^2 = \\tfrac{1}{2} x^2$\n- Force: $F(x) = -\\frac{dU}{dx} = -k x = -x$\n- Acceleration: $a(x) = F(x)/m = -x$\n- Total energy: $E = T + U = \\tfrac{1}{2} m v^2 + \\tfrac{1}{2} k x^2 = \\tfrac{1}{2} v^2 + \\tfrac{1}{2} x^2$\n\n**System B: 3D Lennard-Jones Dimer**\nThis system consists of two identical particles of mass $m=1$ interacting via the Lennard-Jones potential with parameters $\\varepsilon=1$ and $\\sigma=1$. Let $\\mathbf{r}_1, \\mathbf{r}_2$ be the position vectors and $\\mathbf{v}_1, \\mathbf{v}_2$ be the velocity vectors. The inter-particle separation vector is $\\mathbf{r}_{12} = \\mathbf{r}_1 - \\mathbf{r}_2$ and its magnitude is $r = \\|\\mathbf{r}_{12}\\|_2$.\n- Potential energy: $U(r) = 4\\varepsilon [(\\frac{\\sigma}{r})^{12} - (\\frac{\\sigma}{r})^6] = 4(r^{-12} - r^{-6})$\n- The force on particle $1$ is $\\mathbf{F}_1 = -\\nabla_{\\mathbf{r}_1} U(r) = -\\frac{dU}{dr} \\frac{\\mathbf{r}_{12}}{r}$. The derivative of the potential is $\\frac{dU}{dr} = 24\\varepsilon(\\sigma^6 r^{-7} - 2\\sigma^{12} r^{-13})$. With the given parameters, this becomes:\n$$\n\\mathbf{F}_1 = -24(r^{-7} - 2r^{-13}) \\frac{\\mathbf{r}_{12}}{r} = 24(2r^{-14} - r^{-8})\\mathbf{r}_{12}\n$$\n- By Newton's third law, the force on particle $2$ is $\\mathbf{F}_2 = -\\mathbf{F}_1$.\n- Accelerations are $\\mathbf{a}_1 = \\mathbf{F}_1/m = \\mathbf{F}_1$ and $\\mathbf{a}_2 = \\mathbf{F}_2/m = \\mathbf{F}_2$.\n- Total energy: $E = \\sum_{i=1}^2 \\tfrac{1}{2}m_i \\|\\mathbf{v}_i\\|^2 + U(r) = \\tfrac{1}{2}(\\|\\mathbf{v}_1\\|^2 + \\|\\mathbf{v}_2\\|^2) + 4(r^{-12} - r^{-6})$.\n\n**Diagnostic Metrics**\n\nFor each of the $4$ test cases, three diagnostics are computed to assess the performance of the integrator.\n1.  **Energy Drift Rate ($s$) and Fluctuation Amplitude ($R$)**: The change in total energy from its initial value, $\\Delta E(t_j) = E(t_j) - E(0)$, is calculated at each time step $t_j = j \\Delta t$ for $j \\in [0, N]$. A linear model $\\Delta E(t) \\approx s t + b$ is fitted to this data via least squares. The resulting slope $s$ is the energy drift rate. The root-mean-square of the residuals of this fit, $R = \\sqrt{\\frac{1}{M} \\sum_{j=0}^{N} [\\Delta E(t_j) - (s t_j + b)]^2}$ (where $M=N+1$), quantifies the amplitude of energy fluctuations around the fitted drift line.\n2.  **Time-Reversibility Error ($J$)**: This metric quantifies the deviation from perfect time-reversibility. First, a simulation is run forward for $N$ steps, from an initial state $(\\mathbf{q}_0, \\mathbf{v}_0)$ to a final state $(\\mathbf{q}_N, \\mathbf{v}_N)$. The velocities are then inverted, $(\\mathbf{q}_N, -\\mathbf{v}_N)$, and the simulation is run forward again for another $N$ steps to reach a state $(\\tilde{\\mathbf{q}}, \\tilde{\\mathbf{v}})$. The error is the Euclidean distance in phase space between the final and initial states:\n    $$\n    J = \\sqrt{\\| \\tilde{\\mathbf{q}} - \\mathbf{q}_0 \\|^2 + \\| \\tilde{\\mathbf{v}} - \\mathbf{v}_0 \\|^2}\n    $$\n    For a perfectly time-reversible integrator and exact arithmetic, $J$ would be zero.\n\n**Implementation Strategy**\nThe solution is implemented in Python using the `numpy` library for efficient vectorized computations. A main `solve` function orchestrates the $4$ test cases. For each case, a simulation is executed by repeatedly calling the appropriate integration step function (`step_verlet` or `step_rk4`). These stepper functions are designed to be general, taking the current state and an acceleration function as input. System-specific functions (`acc_ho`, `energy_ho`, `acc_lj`, `energy_lj`) provide the physics. After generating the energy trajectory, a linear regression is performed using `numpy.polyfit` to determine $s$ and $b$, from which $R$ is calculated. A separate simulation is run for the time-reversibility test to compute $J$. All calculations are performed in double-precision arithmetic. The results are collected and formatted into the specified string output.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy is not needed, numpy is sufficient as allowed.\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n\n    # --- System A: 1D Harmonic Oscillator ---\n    def acc_ho(q, m=1.0, k=1.0):\n        \"\"\"Acceleration for 1D harmonic oscillator.\"\"\"\n        return -k * q / m\n\n    def energy_ho(q, v, m=1.0, k=1.0):\n        \"\"\"Total energy for 1D harmonic oscillator.\"\"\"\n        return 0.5 * m * v**2 + 0.5 * k * q**2\n\n    # --- System B: 3D Lennard-Jones Dimer ---\n    def acc_lj(q, m=1.0, epsilon=1.0, sigma=1.0):\n        \"\"\"Acceleration for 3D LJ dimer.\"\"\"\n        r1, r2 = q.reshape(2, 3)\n        r12 = r1 - r2\n        dist_sq = np.sum(r12**2)\n        \n        # Protective check for particle overlap\n        if dist_sq == 0:\n            return np.zeros_like(q)\n\n        inv_dist_sq = 1.0 / dist_sq\n        inv_dist_6 = inv_dist_sq**3\n        \n        # Force calculation based on dU/dr\n        # F1 = 24 * epsilon * (2 * sigma^12 * r^-14 - sigma^6 * r^-8) * r12\n        force_mag_term = 24.0 * epsilon * (2.0 * (sigma**12) * inv_dist_6**2 * inv_dist_sq - (sigma**6) * inv_dist_6 * inv_dist_sq)\n        f1 = force_mag_term * r12\n        f2 = -f1\n        \n        # Since mass is 1 for both particles\n        a1 = f1 / m\n        a2 = f2 / m\n        \n        return np.array([a1, a2]).flatten()\n\n    def energy_lj(q, v, m=1.0, epsilon=1.0, sigma=1.0):\n        \"\"\"Total energy for 3D LJ dimer.\"\"\"\n        r1, r2 = q.reshape(2, 3)\n        v1, v2 = v.reshape(2, 3)\n        \n        ke = 0.5 * m * (np.sum(v1**2) + np.sum(v2**2))\n        \n        r12 = r1 - r2\n        dist_sq = np.sum(r12**2)\n        \n        # Protective check\n        if dist_sq == 0:\n            pe = np.inf\n        else:\n            inv_dist_sq = 1.0 / dist_sq\n            inv_dist_6 = inv_dist_sq**3\n            pe = 4.0 * epsilon * (inv_dist_6**2 - inv_dist_6)\n\n        return ke + pe\n\n    # --- Numerical Integrators ---\n    def step_verlet(q, v, dt, acc_func):\n        \"\"\"A single step of the velocity Verlet integrator.\"\"\"\n        a = acc_func(q)\n        v_half = v + 0.5 * dt * a\n        q_next = q + dt * v_half\n        a_next = acc_func(q_next)\n        v_next = v_half + 0.5 * dt * a_next\n        return q_next, v_next\n\n    def step_rk4(q, v, dt, acc_func):\n        \"\"\"A single step of the classical 4th-order Runge-Kutta integrator.\"\"\"\n        # k1\n        k1_q = v\n        k1_v = acc_func(q)\n        # k2\n        k2_q = v + 0.5 * dt * k1_v\n        k2_v = acc_func(q + 0.5 * dt * k1_q)\n        # k3\n        k3_q = v + 0.5 * dt * k2_v\n        k3_v = acc_func(q + 0.5 * dt * k2_q)\n        # k4\n        k4_q = v + dt * k3_v\n        k4_v = acc_func(q + dt * k3_q)\n        # update\n        q_next = q + (dt / 6.0) * (k1_q + 2.0 * k2_q + 2.0 * k3_q + k4_q)\n        v_next = v + (dt / 6.0) * (k1_v + 2.0 * k2_v + 2.0 * k3_v + k4_v)\n        return q_next, v_next\n\n    # --- Simulation and Diagnostics ---\n    def run_simulation(q0, v0, dt, N, step_func, acc_func, energy_func):\n        \"\"\"Runs a simulation and returns diagnostic metrics.\"\"\"\n        q, v = np.copy(q0), np.copy(v0)\n        \n        # Energy audit\n        energies = np.zeros(N + 1, dtype=np.float64)\n        energies[0] = energy_func(q, v)\n        \n        for i in range(1, N + 1):\n            q, v = step_func(q, v, dt, acc_func)\n            energies[i] = energy_func(q, v)\n\n        times = np.arange(N + 1) * dt\n        e0 = energies[0]\n        delta_e = energies - e0\n        \n        # Calculate s and R\n        s, b = np.polyfit(times, delta_e, 1)\n        residuals = delta_e - (s * times + b)\n        R = np.sqrt(np.mean(residuals**2))\n\n        # Time-reversibility test\n        q, v = np.copy(q0), np.copy(v0)\n        for _ in range(N):\n            q, v = step_func(q, v, dt, acc_func)\n        \n        # Reverse and integrate back\n        v = -v\n        for _ in range(N):\n            q, v = step_func(q, v, dt, acc_func)\n        \n        q_tilde, v_tilde = q, v\n        \n        # Calculate J\n        q_error = np.linalg.norm(q_tilde - q0)\n        v_error = np.linalg.norm(v_tilde - v0)\n        J = np.sqrt(q_error**2 + v_error**2)\n        \n        return s, R, J\n\n    test_cases = [\n        # Case 1: System A, Verlet\n        dict(q0=np.array([1.0]), v0=np.array([0.0]), dt=0.1, N=20000, \n             step_func=step_verlet, acc_func=acc_ho, energy_func=energy_ho),\n        # Case 2: System A, RK4\n        dict(q0=np.array([1.0]), v0=np.array([0.0]), dt=0.1, N=20000, \n             step_func=step_rk4, acc_func=acc_ho, energy_func=energy_ho),\n        # Case 3: System B, Verlet\n        dict(q0=np.array([-0.65, 0, 0, 0.65, 0, 0]), \n             v0=np.array([0, 0, 0, 0, 0, 0]), \n             dt=0.002, N=20000, \n             step_func=step_verlet, acc_func=acc_lj, energy_func=energy_lj),\n        # Case 4: System A, Verlet, near stability boundary\n        dict(q0=np.array([1.0]), v0=np.array([0.0]), dt=1.9, N=5000, \n             step_func=step_verlet, acc_func=acc_ho, energy_func=energy_ho),\n    ]\n\n    results = []\n    for case in test_cases:\n        s, R, J = run_simulation(case['q0'], case['v0'], case['dt'], case['N'], \n                                   case['step_func'], case['acc_func'], case['energy_func'])\n        results.append([s, R, J])\n        \n    def format_list(lst):\n        return '[' + ','.join(f'{x:.8e}' for x in lst) + ']'\n    \n    # Custom formatting to remove spaces\n    result_str = '[' + ','.join(map(format_list, results)) + ']'\n    print(result_str)\n\nsolve()\n```"
        },
        {
            "introduction": "Beyond the errors inherent in discretizing time, the finite precision of computer arithmetic introduces another source of deviation in long-term simulations. This practice delves into the impact of round-off error by tasking you with running simulations using both single-precision (float32) and double-precision (float64) arithmetic. By analyzing the resulting energy drift and fluctuation growth rates, you will gain a deeper appreciation for how hardware limitations interact with algorithmic choices to determine the ultimate fidelity of a molecular dynamics trajectory .",
            "id": "3409958",
            "problem": "Consider the one-dimensional harmonic oscillator defined by Newton’s second law $m \\, d^{2}x/dt^{2} = -k \\, x$, where $m$ is the mass and $k$ is the stiffness. Use dimensionless units such that $m = 1$ and $k = 1$, so the governing equations reduce to $d^{2}x/dt^{2} = -x$. The total energy is $E(t) = \\frac{1}{2} v(t)^{2} + \\frac{1}{2} x(t)^{2}$, where $v = dx/dt$. The initial condition is $x(0) = 1$ and $v(0) = 0$. You will investigate how finite precision arithmetic and integrator choice affect long-term energy conservation, drift, and stability in Molecular Dynamics (MD).\n\nStarting from fundamental principles (Newton’s second law and definitions of velocity and energy), implement and compare two time-integration schemes:\n- The symplectic velocity-Verlet method (second order), which advances position and velocity over a time step $\\Delta t$ using accelerations given by $a(x) = -x$.\n- The classical fourth-order Runge–Kutta method, which advances the state by combining four stage evaluations of the right-hand side of the first-order system $dx/dt = v$, $dv/dt = -x$.\n\nYou must simulate numerically using finite-precision arithmetic. For each simulation, the state update operations must be performed using a specified floating-point precision: either single precision (IEEE $32$-bit, hereafter “float32”) or double precision (IEEE $64$-bit, hereafter “float64”). Measurement of energy and any statistical post-processing can be done in higher precision, but the state updates at each step must occur at the specified finite precision.\n\nFor each simulation, compute the following two quantitative diagnostics over the entire trajectory:\n- The normalized linear drift rate $r$, defined as the slope of the least-squares linear fit of $E(t)$ versus $t$, divided by the initial energy $E(0)$. This has units of inverse time and quantitatively measures systematic energy drift.\n- The normalized mean-square deviation growth rate $d$, defined as the slope of the least-squares linear fit of $Y(t) = \\left(E(t) - E(0)\\right)^{2}$ versus $t$, divided by $E(0)^{2}$. This approximates a diffusion-like growth rate of energy fluctuations induced by discretization and roundoff.\n\nBoth slopes must be computed using all sampled times and energies from $t = 0$ through the final time $T = N \\, \\Delta t$, where $N$ is the number of steps. Use the standard least-squares regression formula based on sums over all observed pairs $(t_{i}, E_{i})$ and $(t_{i}, Y_{i})$. The diagnostics $r$ and $d$ must be returned as real numbers.\n\nImplement the following test suite, each case specified as a tuple $(\\text{integrator}, \\text{precision}, \\Delta t, N)$:\n- Case A (happy path, symplectic, double precision, small time step): $(\\text{VV}, \\text{float64}, 0.01, 120000)$.\n- Case B (roundoff sensitivity, symplectic, single precision, small time step): $(\\text{VV}, \\text{float32}, 0.01, 120000)$.\n- Case C (non-symplectic, double precision, small time step): $(\\text{RK4}, \\text{float64}, 0.01, 120000)$.\n- Case D (non-symplectic, single precision, small time step): $(\\text{RK4}, \\text{float32}, 0.01, 120000)$.\n- Case E (boundary stability exploration, symplectic, coarse time step near linear stability limit): $(\\text{VV}, \\text{float64}, 1.9, 10000)$.\n- Case F (coarser step but well within stability, symplectic, double precision): $(\\text{VV}, \\text{float64}, 0.2, 50000)$.\n\nIn all cases, the initial conditions are $x(0) = 1$ and $v(0) = 0$. Use dimensionless units. The required outputs from your program are, for each test case in the order A through F, the pair $[r, d]$ as defined above. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets and grouped per case. The final output must have the form\n$[[r_{A}, d_{A}], [r_{B}, d_{B}], [r_{C}, d_{C}], [r_{D}, d_{D}], [r_{E}, d_{E}], [r_{F}, d_{F}]]$,\nprinted as a single line with no additional text.\n\nNotes and constraints:\n- All state updates during time stepping must be carried out in the specified finite precision. Casting the time step $\\Delta t$ and all intermediate arithmetic to the target precision is required at each update.\n- The least-squares slopes must be computed using sums over all samples from $t = 0$ to $t = T$. Do not discard any samples.\n- No random numbers may be used. The simulation must be deterministic.\n- Since the units are dimensionless by construction, report $r$ and $d$ as real numbers without units. The output values must be printed in the order of the test suite as a single line in the exact required format.",
            "solution": "The user wishes to investigate the effects of integrator choice and finite-precision arithmetic on energy conservation in a numerical simulation of a one-dimensional harmonic oscillator. The problem is well-posed and scientifically sound, involving standard numerical methods (Velocity-Verlet and RK4) and diagnostics (energy drift and fluctuation growth). We will proceed with a solution.\n\n### Principle-Based Design\n\nThe problem revolves around numerically integrating the equations of motion for a simple harmonic oscillator and analyzing the long-term behavior of the total energy. The core principles are Newton's second law, the definition of total energy for a conservative system, and the properties of numerical integration schemes.\n\n**1. The Physical System**\n\nThe system is a one-dimensional harmonic oscillator with mass $m=1$ and stiffness $k=1$. The equation of motion is Newton's second law, $F = ma$, which becomes:\n$$\n\\frac{d^2x}{dt^2} = -x\n$$\nThis second-order ordinary differential equation (ODE) can be expressed as a system of two first-order ODEs by defining velocity $v = dx/dt$:\n$$\n\\begin{cases}\n\\frac{dx}{dt} = v \\\\\n\\frac{dv}{dt} = -x\n\\end{cases}\n$$\nThis system can be written in vector form as $\\frac{d\\mathbf{y}}{dt} = \\mathbf{f}(t, \\mathbf{y})$, where $\\mathbf{y}(t) = [x(t), v(t)]^T$ and $\\mathbf{f}(\\mathbf{y}) = [v, -x]^T$.\n\nThe total energy $E$ of the system is the sum of kinetic and potential energy:\n$$\nE(t) = \\frac{1}{2}mv(t)^2 + \\frac{1}{2}kx(t)^2 = \\frac{1}{2}v(t)^2 + \\frac{1}{2}x(t)^2\n$$\nFor the exact analytical solution, the total energy is a conserved quantity. The initial conditions are $x(0) = 1$ and $v(0) = 0$, giving an initial energy of $E(0) = \\frac{1}{2}(0)^2 + \\frac{1}{2}(1)^2 = 0.5$.\n\n**2. Numerical Integration Schemes**\n\nWe will implement two different algorithms to advance the state $(x, v)$ from time $t_n$ to $t_{n+1} = t_n + \\Delta t$. The choice of integrator significantly impacts the long-term stability and energy conservation properties of the simulation.\n\n**a) Velocity-Verlet (VV) Integrator**\n\nThe Velocity-Verlet algorithm is a second-order, symplectic integrator. Symplectic integrators are particularly well-suited for Hamiltonian systems (like the harmonic oscillator) because they conserve a \"shadow\" Hamiltonian, which is a quantity that is very close to the true energy. This leads to excellent long-term energy stability, with bounded energy fluctuations but no systematic drift in exact arithmetic.\n\nThe update equations for a time step $\\Delta t$ are:\n1. Update position: $x_{n+1} = x_n + v_n \\Delta t + \\frac{1}{2} a_n (\\Delta t)^2$.\n2. Calculate the new acceleration: $a_{n+1} = a(x_{n+1})$. For our system, this is $a_{n+1} = -x_{n+1}$.\n3. Update velocity: $v_{n+1} = v_n + \\frac{1}{2} (a_n + a_{n+1}) \\Delta t$.\n\nSubstituting $a_n = -x_n$ and $a_{n+1} = -x_{n+1}$, the steps become:\n$$\nx_{n+1} = x_n + v_n \\Delta t - \\frac{1}{2} x_n (\\Delta t)^2\n$$\n$$\nv_{n+1} = v_n - \\frac{1}{2} (x_n + x_{n+1}) \\Delta t\n$$\n\n**b) Classical Fourth-Order Runge-Kutta (RK4) Integrator**\n\nThe RK4 method is a general-purpose, high-accuracy (fourth-order) integrator. However, it is not symplectic. Consequently, when applied to Hamiltonian systems, it typically exhibits a slow, systematic energy drift over long simulations, even in exact arithmetic.\n\nFor the system $\\frac{d\\mathbf{y}}{dt} = \\mathbf{f}(\\mathbf{y})$, the RK4 update is:\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{\\Delta t}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n$$\nwhere the stages $\\mathbf{k}_i$ are:\n$$\n\\begin{aligned}\n\\mathbf{k}_1 = \\mathbf{f}(\\mathbf{y}_n) = [v_n, -x_n]^T \\\\\n\\mathbf{k}_2 = \\mathbf{f}(\\mathbf{y}_n + \\frac{\\Delta t}{2}\\mathbf{k}_1) \\\\\n\\mathbf{k}_3 = \\mathbf{f}(\\mathbf{y}_n + \\frac{\\Delta t}{2}\\mathbf{k}_2) \\\\\n\\mathbf{k}_4 = \\mathbf{f}(\\mathbf{y}_n + \\Delta t \\mathbf{k}_3)\n\\end{aligned}\n$$\n\n**3. Finite-Precision Arithmetic**\n\nThe core of the problem is to perform the state updates ($x_{n+1}, v_{n+1}$) using a specified floating-point precision, either single (`float32`) or double (`float64`). This is achieved by ensuring that all variables and constants ($x_n, v_n, \\Delta t$, and numerical coefficients like $0.5, 2, 6$) involved in the update formulas are represented in the target precision. This constraint models the roundoff errors inherent in real-world computer simulations.\n\n**4. Diagnostic Measures**\n\nAfter running a simulation for $N$ steps, we analyze the resulting energy trajectory $E_i = E(t_i)$ for $i=0, \\dots, N$. All post-simulation analysis will be performed in double precision (`float64`) for maximum accuracy, as permitted.\n\n**a) Normalized Linear Drift Rate ($r$)**\n\nThis metric quantifies systematic energy gain or loss. We perform a simple linear regression to find the slope $b_E$ of the best-fit line to the data pairs $(t_i, E_i)$. The formula for the slope is:\n$$\nb_E = \\frac{(N+1) \\sum_{i=0}^N (t_i E_i) - (\\sum_{i=0}^N t_i)(\\sum_{i=0}^N E_i)}{(N+1) \\sum_{i=0}^N t_i^2 - (\\sum_{i=0}^N t_i)^2}\n$$\nThe normalized drift rate $r$ is then:\n$$\nr = \\frac{b_E}{E(0)}\n$$\n\n**b) Normalized Mean-Square Deviation Growth Rate ($d$)**\n\nThis metric quantifies the growth of energy fluctuations, which can be thought of as a diffusion-like process in energy space. We first compute the squared deviation from the initial energy, $Y_i = (E_i - E(0))^2$. We then find the slope $b_Y$ of the best-fit line to the data pairs $(t_i, Y_i)$ using the same regression formula. The normalized growth rate $d$ is:\n$$\nd = \\frac{b_Y}{E(0)^2}\n$$\n\nThe implementation will consist of a main simulation driver that iterates through the specified test cases. For each case, it will call the appropriate integrator for $N$ steps, storing the trajectory. It will then compute the energy time series and pass it to a diagnostics function that calculates $r$ and $d$ using the least-squares formulas above.",
            "answer": "```python\nimport numpy as np\n\ndef vv_step(x, v, dt, dtype):\n    \"\"\"Performs a single Velocity-Verlet step with specified precision.\"\"\"\n    # The acceleration is a(x) = -x.\n    # All arithmetic must be performed at the specified precision.\n    # Constants are explicitly cast to the target data type.\n    const_half = dtype(0.5)\n    \n    # 1. Update position\n    # x_{n+1} = x_n + v_n*dt + 0.5*a_n*dt^2\n    a_n = -x\n    x_new = x + v * dt + const_half * a_n * dt**2\n    \n    # 2. Get new acceleration\n    # a_{n+1} = -x_{n+1}\n    a_new = -x_new\n    \n    # 3. Update velocity\n    # v_{n+1} = v_n + 0.5*(a_n + a_{n+1})*dt\n    v_new = v + const_half * (a_n + a_new) * dt\n    \n    return x_new, v_new\n\ndef rk4_step(x, v, dt, dtype):\n    \"\"\"Performs a single classical RK4 step with specified precision.\"\"\"\n    # The system is y' = f(y), where y = [x, v] and f(y) = [v, -x].\n    # All arithmetic must be performed at the specified precision.\n    const_half = dtype(0.5)\n    const_2 = dtype(2.0)\n    const_6 = dtype(6.0)\n    \n    # Define the vector function f(y) ensuring output is of correct dtype\n    def f(y_vec):\n        return np.array([y_vec[1], -y_vec[0]], dtype=dtype)\n\n    y = np.array([x, v], dtype=dtype)\n    \n    k1 = f(y)\n    k2 = f(y + k1 * dt * const_half)\n    k3 = f(y + k2 * dt * const_half)\n    k4 = f(y + k3 * dt)\n    \n    y_new = y + (k1 + const_2 * k2 + const_2 * k3 + k4) * (dt / const_6)\n    \n    return y_new[0], y_new[1]\n\ndef compute_slope(x_data, y_data):\n    \"\"\"Computes the slope of a simple linear regression.\"\"\"\n    # Using standard formula, all calculations in float64 for accuracy.\n    n_pts = float(len(x_data))\n    sum_x = np.sum(x_data)\n    sum_y = np.sum(y_data)\n    sum_xy = np.sum(x_data * y_data)\n    sum_x2 = np.sum(x_data**2)\n    \n    numerator = n_pts * sum_xy - sum_x * sum_y\n    denominator = n_pts * sum_x2 - sum_x**2\n    \n    if denominator == 0.0:\n        return 0.0\n    \n    return numerator / denominator\n\ndef run_simulation(integrator_str, precision_str, dt_val, n_steps):\n    \"\"\"Runs a single simulation and computes the diagnostics r and d.\"\"\"\n    \n    # 1. Set up simulation parameters\n    dtype = np.float32 if precision_str == 'float32' else np.float64\n    \n    x = dtype(1.0)\n    v = dtype(0.0)\n    dt = dtype(dt_val)\n\n    if integrator_str == 'VV':\n        integrator_func = vv_step\n    elif integrator_str == 'RK4':\n        integrator_func = rk4_step\n    else:\n        raise ValueError(\"Unknown integrator\")\n\n    # 2. Run simulation and store trajectory at specified precision\n    x_traj = np.zeros(n_steps + 1, dtype=dtype)\n    v_traj = np.zeros(n_steps + 1, dtype=dtype)\n    x_traj[0], v_traj[0] = x, v\n    \n    for i in range(n_steps):\n        x, v = integrator_func(x, v, dt, dtype)\n        x_traj[i+1] = x\n        v_traj[i+1] = v\n\n    # 3. Post-processing and diagnostics (in float64)\n    x_traj_64 = x_traj.astype(np.float64)\n    v_traj_64 = v_traj.astype(np.float64)\n    \n    # Calculate energy time series\n    energy = 0.5 * v_traj_64**2 + 0.5 * x_traj_64**2\n    e0 = energy[0]\n    \n    # Create time array\n    times = np.arange(n_steps + 1, dtype=np.float64) * dt_val\n    \n    # Calculate diagnostics\n    # Normalized linear drift rate 'r'\n    slope_e = compute_slope(times, energy)\n    r = slope_e / e0 if e0 != 0.0 else 0.0\n    \n    # Normalized mean-square deviation growth rate 'd'\n    energy_sq_dev = (energy - e0)**2\n    slope_y = compute_slope(times, energy_sq_dev)\n    d = slope_y / (e0**2) if e0 != 0.0 else 0.0\n    \n    return [r, d]\n\ndef solve():\n    \"\"\"Main function to run the test suite and print results.\"\"\"\n    # Test cases: (integrator, precision, dt, N)\n    test_cases = [\n        ('VV', 'float64', 0.01, 120000),   # Case A\n        ('VV', 'float32', 0.01, 120000),   # Case B\n        ('RK4', 'float64', 0.01, 120000),  # Case C\n        ('RK4', 'float32', 0.01, 120000),  # Case D\n        ('VV', 'float64', 1.9, 10000),     # Case E\n        ('VV', 'float64', 0.2, 50000)      # Case F\n    ]\n\n    results = []\n    for case in test_cases:\n        integrator, precision, dt, N = case\n        result_pair = run_simulation(integrator, precision, dt, N)\n        results.append(result_pair)\n    \n    # Format the output as a single-line string\n    output_str = \"[\" + \", \".join([f\"[{r:.12e}, {d:.12e}]\" for r, d in results]) + \"]\"\n    print(output_str.replace(\" \", \"\"))\n\nsolve()\n\n```"
        },
        {
            "introduction": "We have observed that symplectic integrators exhibit remarkable long-term energy stability, but why? This advanced practice moves from observation to explanation by investigating the concept of the \"shadow Hamiltonian\"—a modified energy quantity that the numerical method conserves exactly. You will perform simulations and use the results to empirically fit the parameters of this shadow Hamiltonian, comparing your findings to theoretical predictions from backward error analysis and thereby confirming the beautiful underlying reason for the stability of symplectic methods .",
            "id": "3409974",
            "problem": "Construct a complete, runnable program that investigates the identification of a shadow Hamiltonian for a symplectic molecular dynamics integrator through a polynomial fit in the time step to the measured energy time series, and compares the fitted coefficients to those predicted by theoretical backward error analysis. Use the one-dimensional harmonic oscillator as the model system, with unit mass and angular frequency $\\omega$. The fundamental starting point is Newton's second law and Hamiltonian dynamics: $\\dot{q} = \\partial H / \\partial p$, $\\dot{p} = -\\partial H / \\partial q$, with Hamiltonian $H(q,p) = \\frac{1}{2} p^2 + \\frac{1}{2} \\omega^2 q^2$. The numerical integrator is the time-reversible symplectic velocity Verlet method, applied with time step $\\Delta t$:\n- $p_{n+\\frac{1}{2}} = p_n - \\frac{\\Delta t}{2} \\, \\omega^2 q_n$,\n- $q_{n+1} = q_n + \\Delta t \\, p_{n+\\frac{1}{2}}$,\n- $p_{n+1} = p_{n+\\frac{1}{2}} - \\frac{\\Delta t}{2} \\, \\omega^2 q_{n+1}$.\n\nThe aim is to empirically detect the shadow Hamiltonian $\\tilde{H}$ that the symplectic method nearly preserves by fitting the deviation of the time-averaged true energy from its initial value as a polynomial in $\\Delta t^2$, and then compare against a theoretical prediction obtained from backward error analysis.\n\nYour program must implement the following steps based on first principles:\n1. For each specified $\\Delta t$, simulate the harmonic oscillator using the velocity Verlet scheme for a prescribed number of steps $N$, from specified initial conditions $(q_0, p_0)$. At each discrete time $t_n = n \\, \\Delta t$, compute and accumulate the true energy $E_n = \\frac{1}{2} p_n^2 + \\frac{1}{2} \\omega^2 q_n^2$. Compute the time average $\\overline{E}(\\Delta t) = \\frac{1}{N} \\sum_{n=0}^{N-1} E_n$.\n2. For the set of $\\Delta t$ values in the case, form the data pairs $\\left(u, y\\right)$ with $u = (\\Delta t)^2$ and $y = \\overline{E}(\\Delta t) - E_0$, where $E_0 = \\frac{1}{2} p_0^2 + \\frac{1}{2} \\omega^2 q_0^2$ is the initial true energy. Fit the model $y \\approx c_2^{\\mathrm{emp}} \\, u + c_4^{\\mathrm{emp}} \\, u^2$ by least squares over the provided $u$ values to obtain empirical coefficients $c_2^{\\mathrm{emp}}$ and $c_4^{\\mathrm{emp}}$.\n3. Independently derive the theoretical prediction for the leading shadow Hamiltonian correction coefficients using backward error analysis. For the velocity Verlet method applied to the quadratic Hamiltonian of the harmonic oscillator, there exists an exact quadratic invariant (the shadow energy) $\\tilde{E}(q,p; \\Delta t) = \\frac{1}{2} p^2 + \\frac{1}{2} \\omega^2 \\left(1 - \\frac{\\omega^2 (\\Delta t)^2}{4}\\right) q^2$ that is conserved by the discrete map. Expanding $\\tilde{E} - E$ in powers of $(\\Delta t)$ gives $\\tilde{E} - E = -\\frac{\\omega^4 q^2}{8} (\\Delta t)^2 + \\mathcal{O}((\\Delta t)^4)$. Therefore, the theoretical coefficients for the polynomial approximation of the energy deviation are $c_2^{\\mathrm{th}} = -\\frac{\\omega^4 q_0^2}{8}$ and $c_4^{\\mathrm{th}} = 0$.\n4. Compute and report, for each test case, the absolute errors $\\left|c_2^{\\mathrm{emp}} - c_2^{\\mathrm{th}}\\right|$ and $\\left|c_4^{\\mathrm{emp}} - c_4^{\\mathrm{th}}\\right|$.\n\nAll quantities are dimensionless; do not include physical units.\n\nTest suite:\n- Case 1 (general small-step regime): $\\omega = 1.0$, $q_0 = 1.0$, $p_0 = 0.0$, $N = 20000$, $\\Delta t \\in \\{0.01, 0.02, 0.05, 0.10, 0.15, 0.20\\}$.\n- Case 2 (edge with zero initial position): $\\omega = 1.5$, $q_0 = 0.0$, $p_0 = 1.0$, $N = 20000$, $\\Delta t \\in \\{0.01, 0.02, 0.03, 0.05, 0.08, 0.10\\}$.\n- Case 3 (mixed initial conditions, broader $\\Delta t$ spread well within stability): $\\omega = 0.7$, $q_0 = 0.8$, $p_0 = -0.6$, $N = 20000$, $\\Delta t \\in \\{0.01, 0.03, 0.05, 0.08, 0.10, 0.20, 0.40, 0.60\\}$.\n- Case 4 (near the stability boundary, large steps): $\\omega = 1.0$, $q_0 = 0.5$, $p_0 = 0.2$, $N = 20000$, $\\Delta t \\in \\{0.40, 0.80, 1.20, 1.60, 1.80\\}$. The stability condition for velocity Verlet on this system is $\\omega \\, \\Delta t  2$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain, in order, for each case, the two floats $\\left|c_2^{\\mathrm{emp}} - c_2^{\\mathrm{th}}\\right|$ and $\\left|c_4^{\\mathrm{emp}} - c_4^{\\mathrm{th}}\\right|$. For example, the format must be $[e_{2,1},e_{4,1},e_{2,2},e_{4,2},e_{2,3},e_{4,3},e_{2,4},e_{4,4}]$ where $e_{2,i}$ and $e_{4,i}$ denote the absolute errors for case $i$.",
            "solution": "The problem requires an investigation into the concept of a shadow Hamiltonian for a symplectic numerical integrator by comparing empirically fitted coefficients against their theoretical predictions. The physical system is the one-dimensional simple harmonic oscillator, and the integrator is the velocity Verlet method.\n\nThe core principle rests on the properties of symplectic integrators in Hamiltonian mechanics. While these integrators do not perfectly conserve the true Hamiltonian (energy) $H$, they exactly conserve a nearby, modified Hamiltonian, often called a shadow Hamiltonian, $\\tilde{H}$. This property ensures long-term stability and prevents systematic energy drift, which are hallmarks of high-quality geometric integrators. For the specific case of the velocity Verlet method applied to the simple harmonic oscillator, a rare and convenient property emerges: the shadow Hamiltonian is not just a formal infinite series but a simple, exact quadratic invariant of the discrete map.\n\nThe Hamiltonian for the system is given by:\n$$\nH(q,p) = \\frac{1}{2} p^2 + \\frac{1}{2} \\omega^2 q^2\n$$\nwhere $q$ is the position, $p$ is the momentum, and $\\omega$ is the angular frequency. The mass is taken to be unity. The equations of motion are $\\dot{q} = p$ and $\\dot{p} = -\\omega^2 q$.\n\nThe velocity Verlet algorithm advances the system from time $t_n = n \\Delta t$ to $t_{n+1} = (n+1) \\Delta t$. To verify the formulas given in the problem, we start from the fundamental definition of the algorithm in terms of force. The force is derived from the potential energy $V(q) = \\frac{1}{2}\\omega^2 q^2$, which gives $F(q) = -\\frac{dV}{dq} = -\\omega^2 q$. The three steps of the algorithm are:\n1.  Update momentum to the midpoint: $p_{n+1/2} = p_n + F(q_n) \\frac{\\Delta t}{2}$. Substituting the force, this becomes:\n    $$p_{n+1/2} = p_n + (-\\omega^2 q_n) \\frac{\\Delta t}{2} = p_n - \\frac{\\Delta t}{2} \\omega^2 q_n$$\n2.  Update position to the next step, using the half-step momentum (and unit mass):\n    $$q_{n+1} = q_n + \\Delta t \\, p_{n+1/2}$$\n3.  Update momentum from the midpoint to the full step, using the force at the new position $q_{n+1}$:\n    $$p_{n+1} = p_{n+1/2} + F(q_{n+1}) \\frac{\\Delta t}{2} = p_{n+1/2} - \\frac{\\Delta t}{2} \\omega^2 q_{n+1}$$\nThese derived steps exactly match the formulas provided in the problem description, confirming their correctness.\n\nThe methodology involves the following computational steps:\n\nFirst, for each set of parameters provided in a test case, we perform a series of numerical simulations. Each simulation corresponds to a specific value of the time step $\\Delta t$ from the given set. Starting from initial conditions $(q_0, p_0)$, the system is evolved for $N$ steps using the velocity Verlet algorithm. During the simulation, the true energy $E_n = H(q_n, p_n)$ is calculated at each step $n$. After the simulation is complete, the time-averaged energy is computed:\n$$\n\\overline{E}(\\Delta t) = \\frac{1}{N} \\sum_{n=0}^{N-1} E_n\n$$\n\nSecond, we analyze the deviation of this time-averaged energy from the initial energy $E_0 = H(q_0, p_0)$. According to backward error analysis, this deviation should be an even-powered series in $\\Delta t$. We form data pairs $(u, y)$ where $u = (\\Delta t)^2$ and $y = \\overline{E}(\\Delta t) - E_0$. We then fit this data to a quadratic polynomial model:\n$$\ny(u) \\approx c_2^{\\mathrm{emp}} u + c_4^{\\mathrm{emp}} u^2\n$$\nThe coefficients $c_2^{\\mathrm{emp}}$ and $c_4^{\\mathrm{emp}}$ are determined by a linear least-squares fit. This can be expressed as a matrix problem $\\mathbf{Ac} = \\mathbf{y}$, where $\\mathbf{y}$ is the vector of observed energy deviations, $\\mathbf{c} = [c_2^{\\mathrm{emp}}, c_4^{\\mathrm{emp}}]^T$ is the vector of coefficients to be found, and $\\mathbf{A}$ is the design matrix with rows $[u_i, u_i^2]$ for each $\\Delta t_i$. The solution is given by $\\mathbf{c} = (\\mathbf{A}^T\\mathbf{A})^{-1}\\mathbf{A}^T\\mathbf{y}$.\n\nThird, we compute the theoretical benchmark coefficients. The problem states that for this system and integrator, there exists an exact quadratic invariant (the shadow energy):\n$$\n\\tilde{E}(q,p; \\Delta t) = \\frac{1}{2} p^2 + \\frac{1}{2} \\omega^2 \\left(1 - \\frac{\\omega^2 (\\Delta t)^2}{4}\\right) q^2\n$$\nThis shadow energy $\\tilde{E}$ is exactly conserved by the discrete dynamics, meaning $\\tilde{E}(q_n, p_n) = \\tilde{E}(q_0, p_0)$ for all $n$.\nThe problem defines the theoretical coefficients based on the initial deviation between the shadow and true energies:\n$$\n\\tilde{E}(q_0, p_0) - E_0 = \\left[ \\frac{1}{2} p_0^2 + \\frac{1}{2} \\omega^2 q_0^2 - \\frac{\\omega^4 q_0^2}{8} (\\Delta t)^2 \\right] - \\left[ \\frac{1}{2} p_0^2 + \\frac{1}{2} \\omega^2 q_0^2 \\right] = -\\frac{\\omega^4 q_0^2}{8} (\\Delta t)^2\n$$\nFrom this, the problem defines the theoretical coefficients for the fit of $\\overline{E} - E_0$ as:\n$$\nc_2^{\\mathrm{th}} = -\\frac{\\omega^4 q_0^2}{8} \\quad \\text{and} \\quad c_4^{\\mathrm{th}} = 0\n$$\nIt is a subtle but important point that this theoretical value is derived from the initial state $(q_0, p_0)$ alone, whereas the empirical fit is based on the time-averaged energy $\\overline{E}$. The actual theoretical coefficient for the time-averaged deviation $\\overline{E}-E_0$ is $\\frac{\\omega^4}{8}(\\overline{q^2}-q_0^2)$, which depends on the time-averaged position-squared over the numerical trajectory. The problem's definition sets up a specific, well-defined comparison between the empirical result for the time average and a theoretical prediction based on the initial conditions, which is a valid and instructive numerical experiment.\n\nFinally, for each test case, we compute the absolute errors between the empirically fitted and theoretically defined coefficients: $|c_2^{\\mathrm{emp}} - c_2^{\\mathrm{th}}|$ and $|c_4^{\\mathrm{emp}} - c_4^{\\mathrm{th}}|$. The collection of these errors for all test cases constitutes the final result.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Investigates the shadow Hamiltonian for a symplectic integrator by fitting\n    the energy time series of a harmonic oscillator and comparing with theory.\n    \"\"\"\n    \n    test_cases = [\n        # Case 1: General small-step regime\n        {\n            \"omega\": 1.0, \"q0\": 1.0, \"p0\": 0.0, \"N\": 20000,\n            \"dts\": np.array([0.01, 0.02, 0.05, 0.10, 0.15, 0.20])\n        },\n        # Case 2: Edge with zero initial position\n        {\n            \"omega\": 1.5, \"q0\": 0.0, \"p0\": 1.0, \"N\": 20000,\n            \"dts\": np.array([0.01, 0.02, 0.03, 0.05, 0.08, 0.10])\n        },\n        # Case 3: Mixed initial conditions, broad dt spread\n        {\n            \"omega\": 0.7, \"q0\": 0.8, \"p0\": -0.6, \"N\": 20000,\n            \"dts\": np.array([0.01, 0.03, 0.05, 0.08, 0.10, 0.20, 0.40, 0.60])\n        },\n        # Case 4: Near the stability boundary\n        {\n            \"omega\": 1.0, \"q0\": 0.5, \"p0\": 0.2, \"N\": 20000,\n            \"dts\": np.array([0.40, 0.80, 1.20, 1.60, 1.80])\n        },\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        omega = case[\"omega\"]\n        q0 = case[\"q0\"]\n        p0 = case[\"p0\"]\n        N = case[\"N\"]\n        dts = case[\"dts\"]\n        \n        u_values = []\n        y_values = []\n        \n        E0 = 0.5 * p0**2 + 0.5 * omega**2 * q0**2\n        \n        for dt in dts:\n            q, p = q0, p0\n            total_energy = 0.0\n            \n            # Pre-calculate constant factor for force\n            force_factor = omega**2\n            \n            # Simulation loop\n            for _ in range(N):\n                # Calculate and accumulate energy for the current step (q_n, p_n)\n                current_energy = 0.5 * p**2 + 0.5 * force_factor * q**2\n                total_energy += current_energy\n                \n                # Velocity Verlet integration step\n                # p_{n+1/2} = p_n - (dt/2) * omega^2 * q_n\n                p_half = p - 0.5 * dt * force_factor * q\n                # q_{n+1} = q_n + dt * p_{n+1/2}\n                q_next = q + dt * p_half\n                # p_{n+1} = p_{n+1/2} - (dt/2) * omega^2 * q_{n+1}\n                p_next = p_half - 0.5 * dt * force_factor * q_next\n                \n                q, p = q_next, p_next\n            \n            # Calculate time-averaged energy and its deviation from initial\n            E_avg = total_energy / N\n            y = E_avg - E0\n            \n            # Store u = dt^2 and y for fitting\n            u_values.append(dt**2)\n            y_values.append(y)\n            \n        # Perform least-squares fit: y = c2*u + c4*u^2\n        u_vals = np.array(u_values)\n        y_vals = np.array(y_values)\n        \n        # Design matrix A for the fit Ax = y\n        # Column 1 is u, Column 2 is u^2\n        A = np.vstack([u_vals, u_vals**2]).T\n        \n        # Solve for coefficients [c2, c4]\n        coeffs, _, _, _ = np.linalg.lstsq(A, y_vals, rcond=None)\n        c2_emp, c4_emp = coeffs[0], coeffs[1]\n        \n        # Calculate theoretical coefficients\n        # c2_th fromtilde{E} - E evaluated at t=0\n        c2_th = - (omega**4 * q0**2) / 8.0\n        c4_th = 0.0\n        \n        # Calculate absolute errors\n        error_c2 = np.abs(c2_emp - c2_th)\n        error_c4 = np.abs(c4_emp - c4_th)\n        \n        results.extend([error_c2, error_c4])\n\n    print(f\"[{','.join(f'{x:.6f}' for x in results)}]\")\n\nsolve()\n```"
        }
    ]
}