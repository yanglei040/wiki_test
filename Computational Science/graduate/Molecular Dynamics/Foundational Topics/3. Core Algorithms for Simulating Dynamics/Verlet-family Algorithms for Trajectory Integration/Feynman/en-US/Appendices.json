{
    "hands_on_practices": [
        {
            "introduction": "A critical choice in any molecular dynamics simulation is the integration time step, $\\Delta t$. If chosen too large, the numerical solution can diverge catastrophically, a phenomenon known as numerical instability. This exercise grounds the abstract concept of stability in a concrete calculation by asking you to perform a linear stability analysis for the simple harmonic oscillator, which serves as a crucial model for vibrational modes in molecules. By deriving the famous stability bound for the Verlet method , you will gain a fundamental and practical understanding of the constraints governing the choice of $\\Delta t$.",
            "id": "3460453",
            "problem": "Consider a one-dimensional harmonic oscillator governed by Newton’s second law, $m\\,\\frac{d^{2}x}{dt^{2}} = -k\\,x$, equivalently $\\frac{d^{2}x}{dt^{2}} = -\\omega^{2}\\,x$ with $\\omega = \\sqrt{k/m}$. In Molecular Dynamics (MD), the Störmer–Verlet (also called position–Verlet) algorithm advances positions using the two-step update\n$$\nx_{n+1} = 2\\,x_{n} - x_{n-1} + a(x_{n})\\,(\\Delta t)^{2},\n$$\nwhere $a(x) = \\frac{d^{2}x}{dt^{2}}$ is the acceleration and $\\Delta t$ is the constant time step. For the harmonic oscillator, $a(x) = -\\omega^{2} x$.\n\nStarting from this discrete update and the harmonic force law, perform a linear stability analysis of the discrete dynamics. Use a mode ansatz to determine the amplification behavior of the method and identify the condition on the time step $\\Delta t$ under which the numerical solution remains bounded for all $n$. Report the largest admissible time step $\\Delta t_{\\mathrm{max}}$ as a closed-form expression in terms of $\\omega$. Your final answer must be a single analytical expression. Do not include units. Do not round.",
            "solution": "The problem requires a linear stability analysis of the Störmer-Verlet algorithm applied to a one-dimensional harmonic oscillator. The goal is to find the maximum time step $\\Delta t_{\\mathrm{max}}$ for which the numerical solution remains bounded.\n\nThe equation of motion for the harmonic oscillator is given by\n$$\n\\frac{d^{2}x}{dt^{2}} = -\\omega^{2}\\,x\n$$\nwhere $\\omega = \\sqrt{k/m}$ is the angular frequency. The acceleration at position $x$ is thus $a(x) = -\\omega^{2}\\,x$.\n\nThe Störmer-Verlet algorithm provides a discrete update rule for the position $x_n$ at time $t_n = n\\,\\Delta t$:\n$$\nx_{n+1} = 2\\,x_{n} - x_{n-1} + a(x_{n})\\,(\\Delta t)^{2}\n$$\nwhere $\\Delta t$ is the constant time step.\n\nFirst, we substitute the specific expression for the acceleration of the harmonic oscillator, $a(x_n) = -\\omega^{2}\\,x_n$, into the update equation:\n$$\nx_{n+1} = 2\\,x_{n} - x_{n-1} - \\omega^{2}\\,x_{n}\\,(\\Delta t)^{2}\n$$\nThis equation can be rearranged into a linear homogeneous second-order difference equation by gathering all terms on one side:\n$$\nx_{n+1} - \\left(2 - (\\omega\\,\\Delta t)^{2}\\right)x_{n} + x_{n-1} = 0\n$$\nTo analyze the stability of this difference equation, we use a mode ansatz, as suggested by the problem statement. We assume a solution of the form\n$$\nx_n = g^{n}\n$$\nwhere $g$ is a complex number known as the amplification factor. Substituting this ansatz into the difference equation yields:\n$$\ng^{n+1} - \\left(2 - (\\omega\\,\\Delta t)^{2}\\right)g^{n} + g^{n-1} = 0\n$$\nAssuming a non-trivial solution ($g \\neq 0$), we can divide the entire equation by $g^{n-1}$ to obtain the characteristic equation for $g$:\n$$\ng^{2} - \\left(2 - (\\omega\\,\\Delta t)^{2}\\right)g + 1 = 0\n$$\nThis is a quadratic equation for the amplification factor $g$. The general solution to the difference equation is a linear combination of the powers of the roots of this characteristic equation, $x_n = c_1 g_1^n + c_2 g_2^n$. For the numerical solution $x_n$ to remain bounded for all $n \\to \\infty$, the magnitude of the roots must not exceed unity, i.e., $|g_{1,2}| \\le 1$. If $|g| > 1$ for any root, the corresponding term $g^n$ will grow exponentially, leading to numerical instability.\n\nWe solve the characteristic equation for $g$ using the quadratic formula $g = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}$, with $a=1$, $b = -\\left(2 - (\\omega\\,\\Delta t)^{2}\\right)$, and $c=1$:\n$$\ng = \\frac{\\left(2 - (\\omega\\,\\Delta t)^{2}\\right) \\pm \\sqrt{\\left(2 - (\\omega\\,\\Delta t)^{2}\\right)^{2} - 4}}{2}\n$$\nThe behavior of the roots depends on the sign of the discriminant $\\Delta = \\left(2 - (\\omega\\,\\Delta t)^{2}\\right)^{2} - 4$.\n\nCase 1: Stability region ($\\Delta \\le 0$)\nThe solution is stable if the roots are complex or repeated real roots with magnitude $1$. This occurs when the discriminant is non-positive.\n$$\n\\left(2 - (\\omega\\,\\Delta t)^{2}\\right)^{2} - 4 \\le 0\n$$\n$$\n\\left(2 - (\\omega\\,\\Delta t)^{2}\\right)^{2} \\le 4\n$$\nTaking the square root of both sides gives:\n$$\n|2 - (\\omega\\,\\Delta t)^{2}| \\le 2\n$$\nThis inequality is equivalent to the two conditions:\n$$\n-2 \\le 2 - (\\omega\\,\\Delta t)^{2} \\le 2\n$$\nLet's analyze the two parts of the inequality.\nThe right-hand side: $2 - (\\omega\\,\\Delta t)^{2} \\le 2 \\implies -(\\omega\\,\\Delta t)^{2} \\le 0$, which is always true since $(\\omega\\,\\Delta t)^{2} \\ge 0$.\nThe left-hand side: $-2 \\le 2 - (\\omega\\,\\Delta t)^{2} \\implies (\\omega\\,\\Delta t)^{2} \\le 4$.\nSince $\\omega > 0$ and $\\Delta t$ is a positive time step, this simplifies to:\n$$\n\\omega\\,\\Delta t \\le 2\n$$\nWhen $0 < \\omega\\,\\Delta t < 2$, the discriminant is negative, and the roots are a complex conjugate pair. Let the roots be $g$ and $g^*$. For a quadratic equation $g^2+b'g+c'=0$, the product of the roots is $g_1 g_2 = c'/a'$. In our case, the product is $g g^* = |g|^2 = 1/1 = 1$. Thus, the magnitude of the roots is exactly $|g|=1$. This corresponds to a stable, oscillatory, energy-conserving numerical solution.\nWhen $\\omega\\,\\Delta t = 2$, the discriminant is $\\Delta = (2 - 4)^2 - 4 = 0$. The roots are real and repeated: $g = \\frac{-(-2)}{2} = -1$. Since $|g|=1$, the solution is also stable.\n\nCase 2: Instability region ($\\Delta > 0$)\nThe solution becomes unstable if the discriminant is positive, which implies that the roots are real and distinct.\n$$\n\\Delta = \\left(2 - (\\omega\\,\\Delta t)^{2}\\right)^{2} - 4 > 0\n$$\nThis corresponds to $(\\omega\\,\\Delta t)^2 > 4$, or $\\omega\\,\\Delta t > 2$.\nIn this case, the roots are real and their product is $g_1 g_2 = 1$. If two real numbers multiply to $1$ and are not equal, one must have a magnitude greater than $1$ and the other a magnitude less than $1$. For instance, if $\\omega \\Delta t = 3$, the characteristic equation is $g^2 + 7g + 1 = 0$, with roots $g = \\frac{-7 \\pm \\sqrt{45}}{2}$. One root, $\\frac{-7-\\sqrt{45}}{2}$, has a magnitude much greater than $1$. The presence of a root with magnitude greater than $1$ leads to an exponentially growing, unstable solution.\n\nTherefore, the condition for the numerical stability of the Störmer-Verlet algorithm for the harmonic oscillator is:\n$$\n\\omega\\,\\Delta t \\le 2\n$$\nThis gives the condition on the time step $\\Delta t$:\n$$\n\\Delta t \\le \\frac{2}{\\omega}\n$$\nThe largest admissible time step, $\\Delta t_{\\mathrm{max}}$, is the upper bound of this stability range.\n$$\n\\Delta t_{\\mathrm{max}} = \\frac{2}{\\omega}\n$$\nThis critical time step corresponds to the Nyquist-Shannon sampling theorem, where one must sample at least twice per period of the highest frequency oscillation to capture its dynamics. The period of the oscillator is $T = 2\\pi/\\omega$, so $\\Delta t_{\\mathrm{max}} = T/\\pi$.",
            "answer": "$$\n\\boxed{\\frac{2}{\\omega}}\n$$"
        },
        {
            "introduction": "Beyond just being stable, a good integrator for molecular dynamics should conserve the total energy over long timescales, a property tied to its time-reversibility and symplectic nature. The key to this behavior lies in the specific structure of the method's truncation error. This practice delves into the local truncation error of the position-Verlet method , revealing that its dominant error is a slight shift in the oscillation frequency (a phase error) rather than a systematic energy gain or loss, which explains its excellent long-term performance.",
            "id": "3460485",
            "problem": "In molecular dynamics, the position-Verlet (also called Störmer-Verlet) scheme is widely used to integrate Newton’s equations of motion due to its symplectic and time-reversible structure. Consider the linear harmonic oscillator governed by Newton’s second law,\n$$\n\\frac{d^{2}x}{dt^{2}}(t) \\;=\\; -\\,\\omega^{2}\\,x(t), \\qquad \\omega \\;>\\; 0,\n$$\nand let the positions be advanced on a uniform time grid with spacing $\\Delta t$ by the standard two-step position-Verlet update, which in residual form can be written as the defect obtained by substituting the exact solution into the discrete equation,\n$$\n\\tau(t;\\Delta t) \\;=\\; x(t+\\Delta t) \\;-\\; 2\\,x(t) \\;+\\; x(t-\\Delta t) \\;+\\; \\omega^{2}\\,\\Delta t^{2}\\,x(t).\n$$\nStarting only from Newton’s second law, the definition of the local truncation error $\\tau(t;\\Delta t)$ above, and Taylor’s theorem for smooth functions, derive the leading nonvanishing term in the expansion of $\\tau(t;\\Delta t)$ and thus determine the coefficient multiplying the $O(\\Delta t^{4})$ contribution for this problem. Then, interpret how this specific truncation term alters the phase accuracy by determining the leading $O(\\Delta t^{2})$ correction to the continuous angular frequency in the modified equation sense and stating whether the method exhibits a phase lead or lag.\n\nProvide your final answer as the single closed-form analytic expression for the $O(\\Delta t^{4})$ term of $\\tau(t;\\Delta t)$, expressed in terms of $\\omega$, $\\Delta t$, and $x(t)$. No numerical rounding is required. Do not include units in your final answer.",
            "solution": "We consider the local truncation error $\\tau(t;\\Delta t)$ defined by inserting the exact solution $x(t)$ of the second-order ordinary differential equation into the discrete position-Verlet update. The residual is\n$$\n\\tau(t;\\Delta t) \\;=\\; x(t+\\Delta t) \\;-\\; 2\\,x(t) \\;+\\; x(t-\\Delta t) \\;+\\; \\omega^{2}\\,\\Delta t^{2}\\,x(t).\n$$\nTo extract the leading-order behavior, we use Taylor expansions about time $t$ for a smooth function $x(t)$:\n\\begin{align*}\nx(t+\\Delta t) &= x(t) \\;+\\; \\frac{dx}{dt}(t)\\,\\Delta t \\;+\\; \\frac{1}{2}\\frac{d^{2}x}{dt^{2}}(t)\\,\\Delta t^{2} \\;+\\; \\frac{1}{6}\\frac{d^{3}x}{dt^{3}}(t)\\,\\Delta t^{3} \\;+\\; \\frac{1}{24}\\frac{d^{4}x}{dt^{4}}(t)\\,\\Delta t^{4} \\;+\\; O(\\Delta t^{5}),\\\\\nx(t-\\Delta t) &= x(t) \\;-\\; \\frac{dx}{dt}(t)\\,\\Delta t \\;+\\; \\frac{1}{2}\\frac{d^{2}x}{dt^{2}}(t)\\,\\Delta t^{2} \\;-\\; \\frac{1}{6}\\frac{d^{3}x}{dt^{3}}(t)\\,\\Delta t^{3} \\;+\\; \\frac{1}{24}\\frac{d^{4}x}{dt^{4}}(t)\\,\\Delta t^{4} \\;+\\; O(\\Delta t^{5}).\n\\end{align*}\nAdding these and subtracting $2\\,x(t)$ yields the standard centered second-difference expansion:\n$$\nx(t+\\Delta t) \\;-\\; 2\\,x(t) \\;+\\; x(t-\\Delta t) \\;=\\; \\frac{d^{2}x}{dt^{2}}(t)\\,\\Delta t^{2} \\;+\\; \\frac{1}{12}\\frac{d^{4}x}{dt^{4}}(t)\\,\\Delta t^{4} \\;+\\; O(\\Delta t^{6}).\n$$\nTherefore, the residual becomes\n$$\n\\tau(t;\\Delta t) \\;=\\; \\left[\\frac{d^{2}x}{dt^{2}}(t)\\;+\\;\\omega^{2}\\,x(t)\\right]\\Delta t^{2} \\;+\\; \\frac{1}{12}\\frac{d^{4}x}{dt^{4}}(t)\\,\\Delta t^{4} \\;+\\; O(\\Delta t^{6}).\n$$\nSince $x(t)$ satisfies the harmonic oscillator equation $\\frac{d^{2}x}{dt^{2}}(t) = -\\,\\omega^{2}\\,x(t)$, the bracketed $\\Delta t^{2}$ term cancels exactly, leaving\n$$\n\\tau(t;\\Delta t) \\;=\\; \\frac{1}{12}\\,\\frac{d^{4}x}{dt^{4}}(t)\\,\\Delta t^{4} \\;+\\; O(\\Delta t^{6}).\n$$\nFor the harmonic oscillator, repeated differentiation gives\n$$\n\\frac{d^{2}x}{dt^{2}}(t) \\;=\\; -\\,\\omega^{2}\\,x(t), \n\\qquad \\frac{d^{3}x}{dt^{3}}(t) \\;=\\; -\\,\\omega^{2}\\,\\frac{dx}{dt}(t),\n\\qquad \\frac{d^{4}x}{dt^{4}}(t) \\;=\\; \\omega^{4}\\,x(t).\n$$\nSubstituting this into the residual yields the leading truncation term:\n$$\n\\tau(t;\\Delta t) \\;=\\; \\frac{1}{12}\\,\\omega^{4}\\,\\Delta t^{4}\\,x(t) \\;+\\; O(\\Delta t^{6}).\n$$\nThus the $O(\\Delta t^{4})$ term is $\\frac{1}{12}\\,\\omega^{4}\\,\\Delta t^{4}\\,x(t)$.\n\nTo interpret its effect on phase accuracy, we form the modified equation associated with the discrete scheme. Using the operator form of the central difference,\n$$\nx(t+\\Delta t) \\;-\\; 2\\,x(t) \\;+\\; x(t-\\Delta t) \\;=\\; \\Delta t^{2}\\,\\frac{d^{2}x}{dt^{2}}(t) \\;+\\; \\frac{1}{12}\\,\\Delta t^{4}\\,\\frac{d^{4}x}{dt^{4}}(t) \\;+\\; O(\\Delta t^{6}),\n$$\nthe discrete equation enforces\n$$\n\\frac{d^{2}x}{dt^{2}}(t) \\;+\\; \\omega^{2} x(t) \\;+\\; \\frac{1}{12}\\,\\Delta t^{2}\\,\\frac{d^{4}x}{dt^{4}}(t) \\;+\\; O(\\Delta t^{4}) \\;=\\; 0.\n$$\nAssuming the solution remains close to a sinusoid, we can replace $\\frac{d^{4}x}{dt^{4}}(t)$ by $\\Omega^{4} x(t)$, where $\\Omega$ is the effective angular frequency of the nearby continuous system $x''(t) = -\\,\\Omega^{2} x(t)$. At leading order this gives\n$$\n\\Omega^{2} \\;=\\; \\omega^{2} \\;+\\; \\frac{1}{12}\\,\\Delta t^{2}\\,\\Omega^{4} \\;+\\; O(\\Delta t^{4}),\n$$\nwhose perturbative solution yields\n$$\n\\Omega^{2} \\;=\\; \\omega^{2} \\;+\\; \\frac{1}{12}\\,\\omega^{4}\\,\\Delta t^{2} \\;+\\; O(\\Delta t^{4}), \n\\qquad\n\\Omega \\;=\\; \\omega \\left(1 \\;+\\; \\frac{1}{24}\\,\\omega^{2}\\,\\Delta t^{2} \\;+\\; O(\\Delta t^{4})\\right).\n$$\nTherefore, the position-Verlet scheme exhibits a phase lead: its effective angular frequency is larger than the true $\\omega$ by a relative amount $\\frac{1}{24}\\,\\omega^{2}\\,\\Delta t^{2} + O(\\Delta t^{4})$. This phase behavior is consistent with and directly implied by the computed truncation error term.\n\nThe requested final answer is the $O(\\Delta t^{4})$ term of the local truncation error:\n$$\n\\frac{1}{12}\\,\\omega^{4}\\,\\Delta t^{4}\\,x(t).\n$$",
            "answer": "$$\\boxed{\\frac{1}{12}\\,\\omega^{4}\\,\\Delta t^{4}\\,x(t)}$$"
        },
        {
            "introduction": "Theoretical analysis often relies on simplified models like the harmonic oscillator, so it is essential to verify that these predictions hold in more realistic scenarios. This final practice challenges you to bridge theory and application by implementing a velocity-Verlet integrator for a Lennard-Jones dimer, a standard model for non-bonded atomic interactions . By simulating this system and analyzing how the energy conservation error scales with the time step $\\Delta t$, you will empirically confirm the method's predicted second-order accuracy, a cornerstone skill in computational science.",
            "id": "3460497",
            "problem": "Consider a system composed of $2$ particles of equal mass interacting through the Lennard-Jones potential in reduced Lennard-Jones units, where the characteristic length $\\sigma$, depth $\\epsilon$, and mass $m$ are set to $1$. In these units, the natural time scale is $\\tau = \\sqrt{m \\sigma^{2} / \\epsilon} = 1$, and all dynamical variables are dimensionless. The fundamental laws governing the dynamics are Newton's second law, written for particle $i$ as $$m \\frac{d^{2} \\mathbf{r}_{i}}{dt^{2}} = \\mathbf{F}_{i},$$ where $\\mathbf{F}_{i}$ is the sum of forces on particle $i$. The pairwise Lennard-Jones potential between particles separated by a distance $r$ is $$U(r) = 4 \\epsilon \\left[\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^{6}\\right],$$ and the corresponding force magnitude along the interparticle axis is $$F(r) = -\\frac{dU}{dr} = 24 \\epsilon \\left[\\frac{2 \\sigma^{12}}{r^{13}} - \\frac{\\sigma^{6}}{r^{7}}\\right],$$ so that the vector force is aligned with the interparticle vector.\n\nStarting from these principles, you must implement a velocity-Verlet integrator (a member of the Verlet-family algorithms) to propagate the trajectories of a Lennard-Jones dimer. Define the Lennard-Jones equilibrium separation as $$r_{0} = 2^{1/6} \\sigma.$$ Initialize the two particles at positions $\\mathbf{r}_{1}(0) = \\left(-\\frac{r}{2}, 0, 0\\right)$ and $\\mathbf{r}_{2}(0) = \\left(\\frac{r}{2}, 0, 0\\right)$ with $r = r_{0} + A$, and set initial velocities to zero so that the center of mass remains at the origin. For each trajectory, compute the instantaneous total energy $$E(t) = \\sum_{i=1}^{2} \\frac{1}{2} m \\left\\|\\mathbf{v}_{i}(t)\\right\\|^{2} + U\\left(\\left\\|\\mathbf{r}_{2}(t) - \\mathbf{r}_{1}(t)\\right\\|\\right),$$ and define the empirical error metric over a fixed simulation duration $T$ as the root-mean-square energy deviation from the initial energy $$e(\\Delta t) = \\sqrt{\\frac{1}{N} \\sum_{n=1}^{N} \\left(E(t_{n}) - E(0)\\right)^{2}},$$ where $t_{n} = n \\Delta t$ and $N = \\left\\lfloor T / \\Delta t \\right\\rfloor$. Use the velocity-Verlet scheme to update positions and velocities at each time step $\\Delta t$.\n\nYour empirical procedure must estimate the scaling of $e(\\Delta t)$ with $\\Delta t$ by fitting a straight line to the log-transformed data using base-$10$ logarithms. Specifically, for each set of measurements $\\{\\Delta t_{k}, e(\\Delta t_{k})\\}$, fit $$\\log_{10} e(\\Delta t) \\approx s \\, \\log_{10} \\Delta t + c,$$ and report the slope $s$ as the empirical scaling exponent. In addition, use principled reasoning about the order of accuracy of the velocity-Verlet method to predict the asymptotic slope $s$ for smooth potentials.\n\nAll simulations must be performed in reduced Lennard-Jones units as defined above, and all reported quantities are dimensionless with no physical units attached. Angles, if any, must be in radians, although this system uses only translational motion. The final output must be rounded to three decimal places.\n\nTest suite specification:\n- Use total simulation time $T = 50$.\n- Use three initial amplitude values $A \\in \\{0.05, 0.2, 0.5\\}$, where $A$ controls the initial separation $r = r_{0} + A$.\n- For $A = 0.05$ and $A = 0.2$, use the time step set $$\\Delta t \\in \\{0.002, 0.005, 0.01, 0.02, 0.04, 0.08\\}.$$\n- For $A = 0.5$, use a larger-step set to probe the edge of stability $$\\Delta t \\in \\{0.004, 0.008, 0.016, 0.032, 0.064, 0.12\\}.$$\n\nYour program must:\n- Implement the velocity-Verlet integrator for the Lennard-Jones dimer using the equations described.\n- For each test case, compute $e(\\Delta t)$ for all specified $\\Delta t$ values, fit the log–log slope $s$, and collect these slopes.\n- Predict the theoretical asymptotic slope based on the integrator's order and include it in the final output as an additional value.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain four floats rounded to three decimal places: the three empirical slopes for $A = 0.05$, $A = 0.2$, and $A = 0.5$ in that order, followed by the predicted theoretical slope. For example, output of the form $$[s_{0.05}, s_{0.2}, s_{0.5}, s_{\\mathrm{pred}}].$$\n\nThe answer for each test case and the predicted slope must be a float. The output is dimensionless and unitless by construction.",
            "solution": "The problem requires the implementation of a velocity-Verlet integrator to simulate the dynamics of a two-particle system (a dimer) interacting via the Lennard-Jones potential. The primary goal is to empirically determine the scaling of energy conservation error with the integration time step, $\\Delta t$, and compare it to the theoretical prediction for the algorithm.\n\n**Theoretical Framework and System Definition**\n\nThe system consists of two particles, indexed $i=1, 2$, each with mass $m=1$ in reduced Lennard-Jones units. The dynamics are governed by Newton's second law:\n$$ m \\frac{d^2\\mathbf{r}_i}{dt^2} = \\mathbf{F}_i $$\nSince $m=1$, the acceleration is simply equal to the force, $\\mathbf{a}_i = \\mathbf{F}_i$. The force $\\mathbf{F}_i$ on particle $i$ is the vector sum of forces exerted by other particles. In this two-particle system, the forces are internal and form an action-reaction pair: $\\mathbf{F}_1 = -\\mathbf{F}_2$.\n\nThe interaction is described by the Lennard-Jones (LJ) potential, which in reduced units ($\\epsilon=1, \\sigma=1$) is a function of the interparticle distance $r = \\|\\mathbf{r}_2 - \\mathbf{r}_1\\|$:\n$$ U(r) = 4 \\left( \\frac{1}{r^{12}} - \\frac{1}{r^6} \\right) $$\nThe magnitude of the force is derived from the potential, $F(r) = -dU/dr$:\n$$ F(r) = 24 \\left( \\frac{2}{r^{13}} - \\frac{1}{r^7} \\right) $$\nThe force on particle $2$ due to particle $1$, $\\mathbf{F}_2$, is $\\mathbf{F}_2 = F(r) \\hat{\\mathbf{r}}$, where $\\hat{\\mathbf{r}} = (\\mathbf{r}_2 - \\mathbf{r}_1)/r$ is the unit vector pointing from particle $1$ to particle $2$. Correspondingly, $\\mathbf{F}_1 = - \\mathbf{F}_2$.\n\nThe particles are initialized symmetrically about the origin with zero initial velocity. This ensures that the center of mass, $\\mathbf{R} = (\\mathbf{r}_1 + \\mathbf{r}_2)/2$, remains fixed at the origin for all time. The initial positions are $\\mathbf{r}_1(0) = (-r/2, 0, 0)$ and $\\mathbf{r}_2(0) = (r/2, 0, 0)$, where the initial separation is $r = r_0 + A$. Here, $r_0 = 2^{1/6}\\sigma = 2^{1/6}$ is the equilibrium separation of the LJ potential, and $A$ is a given displacement amplitude. Due to the initial conditions and forces being directed along the interparticle axis, the motion is confined to one dimension (the x-axis).\n\n**Numerical Integration: The Velocity-Verlet Algorithm**\n\nThe velocity-Verlet algorithm is a numerical method used to integrate Newton's equations of motion. It is a member of the Verlet family of algorithms, valued in molecular dynamics for its time-reversibility, symplectic nature, and good long-term energy stability. The algorithm proceeds in discrete time steps of size $\\Delta t$. For each particle, the update from time $t$ to $t+\\Delta t$ is performed as follows:\n\n1.  Update the position:\n    $$ \\mathbf{r}(t + \\Delta t) = \\mathbf{r}(t) + \\mathbf{v}(t)\\Delta t + \\frac{1}{2}\\mathbf{a}(t)\\Delta t^2 $$\n2.  Calculate the new force $\\mathbf{F}(t+\\Delta t)$ and acceleration $\\mathbf{a}(t+\\Delta t) = \\mathbf{F}(t+\\Delta t)/m$ using the new positions $\\mathbf{r}(t+\\Delta t)$.\n3.  Update the velocity:\n    $$ \\mathbf{v}(t + \\Delta t) = \\mathbf{v}(t) + \\frac{1}{2}\\left[ \\mathbf{a}(t) + \\mathbf{a}(t+\\Delta t) \\right] \\Delta t $$\n\nThis scheme is applied to both particles at each time step.\n\n**Error Analysis and Predicted Scaling**\n\nThe velocity-Verlet algorithm has a local truncation error of $O(\\Delta t^4)$ for positions and a global error of $O(\\Delta t^2)$. For a conservative system, a key feature of symplectic integrators like velocity-Verlet is that they do not conserve the true Hamiltonian (energy) $E$, but rather a \"shadow\" Hamiltonian that is close to the true one. Consequently, the computed total energy $E(t)$ does not drift but oscillates around the initial energy $E(0)$. The amplitude of these oscillations is a measure of the integrator's error.\n\nFor the velocity-Verlet method, the magnitude of the energy fluctuation, $|E(t) - E(0)|$, is known to scale with the square of the time step for sufficiently small $\\Delta t$:\n$$ |E(t) - E(0)| \\propto (\\Delta t)^2 $$\nThe problem asks for the scaling of the root-mean-square energy deviation, defined as:\n$$ e(\\Delta t) = \\sqrt{\\frac{1}{N} \\sum_{n=1}^{N} \\left(E(t_{n}) - E(0)\\right)^{2}} $$\nwhere $t_n = n \\Delta t$. Given that each term $E(t_n) - E(0)$ is of order $O((\\Delta t)^2)$, the squared term $(E(t_n) - E(0))^2$ is of order $O((\\Delta t)^4)$. The mean of these terms will also be of order $O((\\Delta t)^4)$. Taking the square root gives the scaling of $e(\\Delta t)$:\n$$ e(\\Delta t) \\propto \\sqrt{O((\\Delta t)^4)} = O((\\Delta t)^2) $$\nThis implies a scaling relationship $e(\\Delta t) = C (\\Delta t)^s$ with an exponent $s=2$. To find this exponent from data, we use a log-log plot:\n$$ \\log_{10} e(\\Delta t) = s \\log_{10} \\Delta t + \\log_{10} C $$\nThis is a linear equation of the form $y = sx + c$. The slope of the line fit to the data points $(\\log_{10} \\Delta t_k, \\log_{10} e(\\Delta t_k))$ gives the empirical scaling exponent $s$. Based on the theoretical properties of the velocity-Verlet algorithm, the predicted asymptotic slope is $s_{\\text{pred}} = 2$.\n\n**Implementation Plan**\n\nThe solution is implemented by a Python script following these steps:\n1.  **Define Constants and Functions**: Set up LJ reduced units ($m=1, \\sigma=1, \\epsilon=1$) and functions for the LJ potential and force magnitude. The equilibrium distance is $r_0 = 2^{1/6}$.\n2.  **Main Simulation Loop**: A function `run_simulation(A, dt, T)` is created.\n    - It initializes the two particles' positions and velocities based on the given amplitude $A$.\n    - It computes the initial forces, accelerations, and total energy $E(0)$.\n    - It iterates for $N = \\lfloor T/\\Delta t \\rfloor$ steps, applying the velocity-Verlet update rules at each step for both particles.\n    - At each step $n$, it computes the current total energy $E(t_n)$ and stores the squared deviation $(E(t_n) - E(0))^2$.\n    - After the loop, it calculates the RMS error $e(\\Delta t)$ and returns it.\n3.  **Data Generation and Analysis**:\n    - A main function iterates through the three specified test cases (values of $A$).\n    - For each $A$, it calls `run_simulation` for each corresponding $\\Delta t$ in the specified set to generate a list of error values $e(\\Delta t_k)$.\n    - The lists of $\\Delta t_k$ and $e(\\Delta t_k)$ are log-10 transformed.\n    - A linear regression is performed on the transformed data points $(\\log_{10} \\Delta t, \\log_{10} e)$ using `numpy.polyfit` to determine the slope $s$.\n4.  **Output**: The three empirical slopes ($s_{0.05}, s_{0.2}, s_{0.5}$) and the predicted theoretical slope ($s_{\\text{pred}}=2.0$) are collected and formatted into the required output string, with each value rounded to three decimal places.\n\nThis procedure systematically evaluates the performance of the velocity-Verlet integrator for the given physical system and confirms its theoretical order of accuracy by analyzing the scaling of energy conservation error.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef lj_potential(r):\n    \"\"\"Calculates the Lennard-Jones potential in reduced units.\"\"\"\n    if r == 0:\n        return np.inf\n    r_inv6 = (1.0 / r)**6\n    return 4.0 * (r_inv6**2 - r_inv6)\n\ndef lj_force_magnitude(r):\n    \"\"\"Calculates the magnitude of the Lennard-Jones force in reduced units.\"\"\"\n    if r == 0:\n        return np.inf\n    r_inv7 = (1.0 / r)**7\n    return 24.0 * (2.0 * r_inv7 * (1.0 / r)**6 - r_inv7)\n\ndef get_accelerations(pos1, pos2):\n    \"\"\"\n    Calculates the acceleration vectors for two particles.\n    In reduced units, mass m=1, so acceleration a = F.\n    \"\"\"\n    r_vec = pos2 - pos1\n    r = np.linalg.norm(r_vec)\n    f_mag = lj_force_magnitude(r)\n    f_vec = f_mag * (r_vec / r)\n    \n    # By Newton's third law, F_12 = -F_21\n    # a_2 is due to force from 1 on 2 (F_21)\n    # a_1 is due to force from 2 on 1 (F_12)\n    accel2 = f_vec\n    accel1 = -f_vec\n    return accel1, accel2\n\ndef run_simulation(A, dt, T):\n    \"\"\"\n    Runs a single molecular dynamics simulation for a Lennard-Jones dimer.\n    Returns the root-mean-square energy deviation e(dt).\n    \"\"\"\n    r0 = 2**(1/6.0)\n    r_initial_separation = r0 + A\n\n    # Initialize positions and velocities\n    pos1 = np.array([-r_initial_separation / 2.0, 0.0, 0.0])\n    pos2 = np.array([r_initial_separation / 2.0, 0.0, 0.0])\n    vel1 = np.zeros(3)\n    vel2 = np.zeros(3)\n\n    # Calculate initial state\n    accel1, accel2 = get_accelerations(pos1, pos2)\n    \n    # Calculate initial total energy E(0)\n    ke = 0.5 * (np.sum(vel1**2) + np.sum(vel2**2)) # m=1\n    pe = lj_potential(np.linalg.norm(pos2 - pos1))\n    e_initial = ke + pe\n    \n    energy_deviations_sq = []\n    num_steps = int(T / dt)\n\n    for _ in range(num_steps):\n        # Velocity-Verlet Step 1: Update positions\n        pos1_new = pos1 + vel1 * dt + 0.5 * accel1 * dt**2\n        pos2_new = pos2 + vel2 * dt + 0.5 * accel2 * dt**2\n\n        # Velocity-Verlet Step 2: Calculate new accelerations\n        accel1_new, accel2_new = get_accelerations(pos1_new, pos2_new)\n\n        # Velocity-Verlet Step 3: Update velocities\n        vel1_new = vel1 + 0.5 * (accel1 + accel1_new) * dt\n        vel2_new = vel2 + 0.5 * (accel2 + accel2_new) * dt\n\n        # Update state for the next iteration\n        pos1, pos2 = pos1_new, pos2_new\n        vel1, vel2 = vel1_new, vel2_new\n        accel1, accel2 = accel1_new, accel2_new\n\n        # Calculate current total energy E(t_n) and deviation\n        ke_current = 0.5 * (np.sum(vel1**2) + np.sum(vel2**2))\n        pe_current = lj_potential(np.linalg.norm(pos2 - pos1))\n        e_current = ke_current + pe_current\n        \n        energy_deviations_sq.append((e_current - e_initial)**2)\n\n    # Calculate the final empirical error metric e(dt)\n    if not energy_deviations_sq:\n        return 0.0\n    \n    e_dt = np.sqrt(np.mean(energy_deviations_sq))\n    return e_dt\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and produce the final output.\n    \"\"\"\n    T = 50.0\n\n    test_cases = [\n        (0.05, [0.002, 0.005, 0.01, 0.02, 0.04, 0.08]),\n        (0.2,  [0.002, 0.005, 0.01, 0.02, 0.04, 0.08]),\n        (0.5,  [0.004, 0.008, 0.016, 0.032, 0.064, 0.12])\n    ]\n\n    results = []\n    for A, dt_values in test_cases:\n        e_values = [run_simulation(A, dt, T) for dt in dt_values]\n        \n        # Handle cases where error might be zero to avoid log(0)\n        # and ensure arrays are correctly typed for polyfit\n        dt_array = np.array(dt_values, dtype=float)\n        e_array = np.array(e_values, dtype=float)\n\n        # Filter out any non-positive values before taking log\n        valid_indices = e_array > 0\n        if np.sum(valid_indices) < 2:\n            # Not enough data for a fit, append a placeholder (e.g., NaN)\n            # or handle as an error. For this problem, a valid slope is expected.\n            # We assume results will be well-behaved.\n            slope = np.nan \n        else:\n            log_dt = np.log10(dt_array[valid_indices])\n            log_e = np.log10(e_array[valid_indices])\n\n            # Perform linear regression to find the slope s\n            # s = slope, c = intercept\n            s, _ = np.polyfit(log_dt, log_e, 1)\n        \n        results.append(s)\n    \n    # Add the predicted theoretical slope\n    s_pred = 2.0\n    results.append(s_pred)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.3f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}