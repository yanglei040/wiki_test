{
    "hands_on_practices": [
        {
            "introduction": "在分子动力学模拟中，时间步长 $\\Delta t$ 的选择至关重要。过大的时间步长会导致数值不稳定性，使模拟结果发散而毫无意义。本练习  将指导您完成一项基础分析，通过对应用于简谐振子的Störmer-Verlet算法进行线性稳定性分析，揭示控制其数值稳定性的基本条件，从而理解时间步长的选择上限。",
            "id": "3460453",
            "problem": "考虑一个一维谐振子，其运动遵循牛顿第二定律 $m\\,\\frac{d^{2}x}{dt^{2}} = -k\\,x$，等效于 $\\frac{d^{2}x}{dt^{2}} = -\\omega^{2}\\,x$，其中 $\\omega = \\sqrt{k/m}$。在分子动力学 (MD) 中，Störmer-Verlet (也称为位置 Verlet) 算法使用以下两步更新来推进位置\n$$\nx_{n+1} = 2\\,x_{n} - x_{n-1} + a(x_{n})\\,(\\Delta t)^{2},\n$$\n其中 $a(x) = \\frac{d^{2}x}{dt^{2}}$ 是加速度，$\\Delta t$ 是恒定的时间步长。对于谐振子，有 $a(x) = -\\omega^{2} x$。\n\n从这个离散更新和谐振子力定律出发，对离散动力学进行线性稳定性分析。使用一个模式试探解来确定该方法的放大行为，并找出时间步长 $\\Delta t$ 需满足的条件，在该条件下，数值解对所有 $n$ 保持有界。以 $\\omega$ 的闭式表达式报告最大允许时间步长 $\\Delta t_{\\mathrm{max}}$。你的最终答案必须是单个解析表达式。不要包含单位。不要四舍五入。",
            "solution": "该问题要求对应用于一维谐振子的 Störmer-Verlet 算法进行线性稳定性分析。目标是找到使数值解保持有界的最大时间步长 $\\Delta t_{\\mathrm{max}}$。\n\n谐振子的运动方程由下式给出\n$$\n\\frac{d^{2}x}{dt^{2}} = -\\omega^{2}\\,x\n$$\n其中 $\\omega = \\sqrt{k/m}$ 是角频率。因此，位置 $x$ 处的加速度为 $a(x) = -\\omega^{2}\\,x$。\n\nStörmer-Verlet 算法为时刻 $t_n = n\\,\\Delta t$ 的位置 $x_n$ 提供了离散更新规则：\n$$\nx_{n+1} = 2\\,x_{n} - x_{n-1} + a(x_{n})\\,(\\Delta t)^{2}\n$$\n其中 $\\Delta t$ 是恒定的时间步长。\n\n首先，我们将谐振子加速度的具体表达式 $a(x_n) = -\\omega^{2}\\,x_n$ 代入更新方程：\n$$\nx_{n+1} = 2\\,x_{n} - x_{n-1} - \\omega^{2}\\,x_{n}\\,(\\Delta t)^{2}\n$$\n通过将所有项移到一边，该方程可以重排为一个线性齐次二阶差分方程：\n$$\nx_{n+1} - \\left(2 - (\\omega\\,\\Delta t)^{2}\\right)x_{n} + x_{n-1} = 0\n$$\n为了分析该差分方程的稳定性，我们按照题目建议使用一个模式试探解 (mode ansatz)。我们假设解的形式为\n$$\nx_n = g^{n}\n$$\n其中 $g$ 是一个复数，称为放大因子。将此试探解代入差分方程，得到：\n$$\ng^{n+1} - \\left(2 - (\\omega\\,\\Delta t)^{2}\\right)g^{n} + g^{n-1} = 0\n$$\n假设存在非平凡解 ($g \\neq 0$)，我们可以将整个方程除以 $g^{n-1}$，得到关于 $g$ 的特征方程：\n$$\ng^{2} - \\left(2 - (\\omega\\,\\Delta t)^{2}\\right)g + 1 = 0\n$$\n这是一个关于放大因子 $g$ 的二次方程。该差分方程的通解是其特征方程根的幂的线性组合，$x_n = c_1 g_1^n + c_2 g_2^n$。要使数值解 $x_n$ 在 $n \\to \\infty$ 时保持有界，根的模必须不超过 1，即 $|g_{1,2}| \\le 1$。如果任一根的模 $|g| > 1$，对应的项 $g^n$ 将会指数级增长，导致数值不稳定。\n\n我们使用二次公式 $g = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}$ 求解关于 $g$ 的特征方程，其中 $a=1$，$b = -\\left(2 - (\\omega\\,\\Delta t)^{2}\\right)$，$c=1$：\n$$\ng = \\frac{\\left(2 - (\\omega\\,\\Delta t)^{2}\\right) \\pm \\sqrt{\\left(2 - (\\omega\\,\\Delta t)^{2}\\right)^{2} - 4}}{2}\n$$\n根的行为取决于判别式 $\\Delta = \\left(2 - (\\omega\\,\\Delta t)^{2}\\right)^{2} - 4$ 的符号。\n\n情况 1：稳定区域 ($\\Delta \\le 0$)\n如果根是模为 1 的复数或重实根，则解是稳定的。这在判别式非正时发生。\n$$\n\\left(2 - (\\omega\\,\\Delta t)^{2}\\right)^{2} - 4 \\le 0\n$$\n$$\n\\left(2 - (\\omega\\,\\Delta t)^{2}\\right)^{2} \\le 4\n$$\n两边取平方根，得到：\n$$\n|2 - (\\omega\\,\\Delta t)^{2}| \\le 2\n$$\n该不等式等价于以下两个条件：\n$$\n-2 \\le 2 - (\\omega\\,\\Delta t)^{2} \\le 2\n$$\n我们来分析这个不等式的两部分。\n右半边：$2 - (\\omega\\,\\Delta t)^{2} \\le 2 \\implies -(\\omega\\,\\Delta t)^{2} \\le 0$，因为 $(\\omega\\,\\Delta t)^{2} \\ge 0$，所以此式恒成立。\n左半边：$-2 \\le 2 - (\\omega\\,\\Delta t)^{2} \\implies (\\omega\\,\\Delta t)^{2} \\le 4$。\n由于 $\\omega > 0$ 且 $\\Delta t$ 是一个正的时间步长，这可以简化为：\n$$\n\\omega\\,\\Delta t \\le 2\n$$\n当 $0  \\omega\\,\\Delta t  2$ 时，判别式为负，根是一对共轭复数。设根为 $g$ 和 $g^*$。对于二次方程 $g^2+b'g+c'=0$，根的乘积是 $g_1 g_2 = c'/a'$。在我们的例子中，乘积是 $g g^* = |g|^2 = 1/1 = 1$。因此，根的模恰好为 $|g|=1$。这对应于一个稳定的、振荡的、能量守恒的数值解。\n当 $\\omega\\,\\Delta t = 2$ 时，判别式为 $\\Delta = (2 - 4)^2 - 4 = 0$。根是实数且为重根：$g = \\frac{-(-2)}{2} = -1$。由于 $|g|=1$，解也是稳定的。\n\n情况 2：不稳定区域 ($\\Delta > 0$)\n如果判别式为正，解变得不稳定，这意味着根是相异的实数。\n$$\n\\Delta = \\left(2 - (\\omega\\,\\Delta t)^{2}\\right)^{2} - 4 > 0\n$$\n这对应于 $(\\omega\\,\\Delta t)^2 > 4$，即 $\\omega\\,\\Delta t > 2$。\n在这种情况下，根是实数，且它们的乘积为 $g_1 g_2 = 1$。如果两个不相等的实数相乘得 1，那么其中一个的模必须大于 1，另一个的模必须小于 1。例如，如果 $\\omega \\Delta t = 3$，特征方程是 $g^2 + 7g + 1 = 0$，其根为 $g = \\frac{-7 \\pm \\sqrt{45}}{2}$。其中一个根 $\\frac{-7-\\sqrt{45}}{2}$ 的模远大于 1。存在模大于 1 的根会导致指数增长的不稳定解。\n\n因此，Störmer-Verlet 算法对于谐振子的数值稳定性条件是：\n$$\n\\omega\\,\\Delta t \\le 2\n$$\n这给出了对时间步长 $\\Delta t$ 的条件：\n$$\n\\Delta t \\le \\frac{2}{\\omega}\n$$\n最大允许时间步长 $\\Delta t_{\\mathrm{max}}$ 是这个稳定范围的上界。\n$$\n\\Delta t_{\\mathrm{max}} = \\frac{2}{\\omega}\n$$\n这个临界时间步长对应于 Nyquist-Shannon 采样定理，即必须在最高频率振荡的每个周期内至少采样两次才能捕捉其动力学特性。振荡器的周期是 $T = 2\\pi/\\omega$，因此 $\\Delta t_{\\mathrm{max}} = T/\\pi$。",
            "answer": "$$\n\\boxed{\\frac{2}{\\omega}}\n$$"
        },
        {
            "introduction": "一个数值积分方案仅仅保持稳定是不够的，我们还希望深入了解它所引入误差的性质。通过分析局部截断误差，我们可以揭示数值方案如何系统性地偏离真实动力学轨迹。在此练习  中，您将推导位置 Verlet方法的主导误差项，并探究它如何体现为一种“相位误差”，即导致数值轨迹的振荡频率略高于真实物理系统的频率。",
            "id": "3460485",
            "problem": "在分子动力学中，位置 Verlet（也称为Störmer-Verlet）格式因其辛性和时间可逆结构而被广泛用于积分牛顿运动方程。考虑由牛顿第二定律控制的线性谐振子，\n$$\n\\frac{d^{2}x}{dt^{2}}(t) \\;=\\; -\\,\\omega^{2}\\,x(t), \\qquad \\omega \\;>\\; 0,\n$$\n设位置在时间步长为 $\\Delta t$ 的均匀时间网格上通过标准的两步位置 Verlet更新方法进行推进，其残差形式可以写为将精确解代入离散方程得到的离差，\n$$\n\\tau(t;\\Delta t) \\;=\\; x(t+\\Delta t) \\;-\\; 2\\,x(t) \\;+\\; x(t-\\Delta t) \\;+\\; \\omega^{2}\\,\\Delta t^{2}\\,x(t).\n$$\n仅从牛顿第二定律、上述局部截断误差 $\\tau(t;\\Delta t)$ 的定义以及光滑函数的泰勒定理出发，推导 $\\tau(t;\\Delta t)$ 展开式中的首个非零项，从而确定此问题中 $O(\\Delta t^{4})$ 贡献项的系数。然后，通过在修正方程意义下确定连续角频率的首个 $O(\\Delta t^{2})$ 修正项，并说明该方法表现出相位超前还是相位滞后，来解释此特定截断项如何改变相位精度。\n\n请以 $\\omega$、$\\Delta t$ 和 $x(t)$ 表示的 $\\tau(t;\\Delta t)$ 的 $O(\\Delta t^{4})$ 项的单个闭式解析表达式作为您的最终答案。不需要进行数值舍入。最终答案中不要包含单位。",
            "solution": "我们考虑通过将二阶常微分方程的精确解 $x(t)$ 代入离散的位置 Verlet更新格式来定义的局部截断误差 $\\tau(t;\\Delta t)$。其残差为\n$$\n\\tau(t;\\Delta t) \\;=\\; x(t+\\Delta t) \\;-\\; 2\\,x(t) \\;+\\; x(t-\\Delta t) \\;+\\; \\omega^{2}\\,\\Delta t^{2}\\,x(t).\n$$\n为提取其主阶行为，我们对光滑函数 $x(t)$ 在时间 $t$ 附近进行泰勒展开：\n\\begin{align*}\nx(t+\\Delta t) = x(t) \\;+\\; \\frac{dx}{dt}(t)\\,\\Delta t \\;+\\; \\frac{1}{2}\\frac{d^{2}x}{dt^{2}}(t)\\,\\Delta t^{2} \\;+\\; \\frac{1}{6}\\frac{d^{3}x}{dt^{3}}(t)\\,\\Delta t^{3} \\;+\\; \\frac{1}{24}\\frac{d^{4}x}{dt^{4}}(t)\\,\\Delta t^{4} \\;+\\; O(\\Delta t^{5}),\\\\\nx(t-\\Delta t) = x(t) \\;-\\; \\frac{dx}{dt}(t)\\,\\Delta t \\;+\\; \\frac{1}{2}\\frac{d^{2}x}{dt^{2}}(t)\\,\\Delta t^{2} \\;-\\; \\frac{1}{6}\\frac{d^{3}x}{dt^{3}}(t)\\,\\Delta t^{3} \\;+\\; \\frac{1}{24}\\frac{d^{4}x}{dt^{4}}(t)\\,\\Delta t^{4} \\;+\\; O(\\Delta t^{5}).\n\\end{align*}\n将这两式相加再减去 $2\\,x(t)$，得到标准的中心二阶差分展开式：\n$$\nx(t+\\Delta t) \\;-\\; 2\\,x(t) \\;+\\; x(t-\\Delta t) \\;=\\; \\frac{d^{2}x}{dt^{2}}(t)\\,\\Delta t^{2} \\;+\\; \\frac{1}{12}\\frac{d^{4}x}{dt^{4}}(t)\\,\\Delta t^{4} \\;+\\; O(\\Delta t^{6}).\n$$\n因此，残差变为\n$$\n\\tau(t;\\Delta t) \\;=\\; \\left[\\frac{d^{2}x}{dt^{2}}(t)\\;+\\;\\omega^{2}\\,x(t)\\right]\\Delta t^{2} \\;+\\; \\frac{1}{12}\\frac{d^{4}x}{dt^{4}}(t)\\,\\Delta t^{4} \\;+\\; O(\\Delta t^{6}).\n$$\n由于 $x(t)$ 满足谐振子方程 $\\frac{d^{2}x}{dt^{2}}(t) = -\\,\\omega^{2}\\,x(t)$，方括号内的 $\\Delta t^{2}$ 项正好抵消，剩下\n$$\n\\tau(t;\\Delta t) \\;=\\; \\frac{1}{12}\\,\\frac{d^{4}x}{dt^{4}}(t)\\,\\Delta t^{4} \\;+\\; O(\\Delta t^{6}).\n$$\n对于谐振子，重复求导可得\n$$\n\\frac{d^{2}x}{dt^{2}}(t) \\;=\\; -\\,\\omega^{2}\\,x(t), \n\\qquad \\frac{d^{3}x}{dt^{3}}(t) \\;=\\; -\\,\\omega^{2}\\,\\frac{dx}{dt}(t),\n\\qquad \\frac{d^{4}x}{dt^{4}}(t) \\;=\\; \\omega^{4}\\,x(t).\n$$\n将此代入残差，得到首项截断项：\n$$\n\\tau(t;\\Delta t) \\;=\\; \\frac{1}{12}\\,\\omega^{4}\\,\\Delta t^{4}\\,x(t) \\;+\\; O(\\Delta t^{6}).\n$$\n因此 $O(\\Delta t^{4})$ 项为 $\\frac{1}{12}\\,\\omega^{4}\\,\\Delta t^{4}\\,x(t)$。\n\n为解释其对相位精度的影响，我们构建与该离散格式相关联的修正方程。使用中心差分的算子形式，\n$$\nx(t+\\Delta t) \\;-\\; 2\\,x(t) \\;+\\; x(t-\\Delta t) \\;=\\; \\Delta t^{2}\\,\\frac{d^{2}x}{dt^{2}}(t) \\;+\\; \\frac{1}{12}\\,\\Delta t^{4}\\,\\frac{d^{4}x}{dt^{4}}(t) \\;+\\; O(\\Delta t^{6}),\n$$\n离散方程强制要求\n$$\n\\frac{d^{2}x}{dt^{2}}(t) \\;+\\; \\omega^{2} x(t) \\;+\\; \\frac{1}{12}\\,\\Delta t^{2}\\,\\frac{d^{4}x}{dt^{4}}(t) \\;+\\; O(\\Delta t^{4}) \\;=\\; 0.\n$$\n假设解近似于一个正弦函数，我们可以用 $\\Omega^{4} x(t)$ 替换 $\\frac{d^{4}x}{dt^{4}}(t)$，其中 $\\Omega$ 是邻近连续系统 $x''(t) = -\\,\\Omega^{2} x(t)$ 的有效角频率。在主阶上，这给出\n$$\n\\Omega^{2} \\;=\\; \\omega^{2} \\;+\\; \\frac{1}{12}\\,\\Delta t^{2}\\,\\Omega^{4} \\;+\\; O(\\Delta t^{4}),\n$$\n其微扰解为\n$$\n\\Omega^{2} \\;=\\; \\omega^{2} \\;+\\; \\frac{1}{12}\\,\\omega^{4}\\,\\Delta t^{2} \\;+\\; O(\\Delta t^{4}), \n\\qquad\n\\Omega \\;=\\; \\omega \\left(1 \\;+\\; \\frac{1}{24}\\,\\omega^{2}\\,\\Delta t^{2} \\;+\\; O(\\Delta t^{4})\\right).\n$$\n因此，位置 Verlet格式表现出相位超前：其有效角频率比真实的 $\\omega$ 大，相对量为 $\\frac{1}{24}\\,\\omega^{2}\\,\\Delta t^{2} + O(\\Delta t^{4})$。这种相位行为与计算出的截断误差项是一致的，并且是其直接推论。\n\n所要求的最终答案是局部截断误差的 $O(\\Delta t^{4})$ 项：\n$$\n\\frac{1}{12}\\,\\omega^{4}\\,\\Delta t^{4}\\,x(t).\n$$",
            "answer": "$$\\boxed{\\frac{1}{12}\\,\\omega^{4}\\,\\Delta t^{4}\\,x(t)}$$"
        },
        {
            "introduction": "关于算法性能的理论预测，最终必须通过实际编程实现来加以验证。积分器的精度阶数决定了其误差如何随着时间步长 $\\Delta t$ 的变化而缩放，这是一个核心的理论属性。本编码练习  要求您为一个Lennard-Jones二聚体系统构建一个模拟程序，并通过经验性测量来检验能量误差的缩放行为，从而直接验证速度Verlet积分器的二阶精度特性。",
            "id": "3460497",
            "problem": "考虑一个由2个等质量粒子组成的系统，它们通过Lennard-Jones势相互作用。系统采用简化的Lennard-Jones单位制，其中特征长度 $\\sigma$、势阱深度 $\\epsilon$ 和质量 $m$ 均设为1。在此单位制中，自然时间标度为 $\\tau = \\sqrt{m \\sigma^{2} / \\epsilon} = 1$，且所有动力学变量都是无量纲的。控制动力学的基本法则是牛顿第二定律，对粒子 $i$ 可写作 $$m \\frac{d^{2} \\mathbf{r}_{i}}{dt^{2}} = \\mathbf{F}_{i},$$ 其中 $\\mathbf{F}_{i}$ 是作用在粒子 $i$ 上的合力。相距为 $r$ 的粒子之间的Lennard-Jones对势为 $$U(r) = 4 \\epsilon \\left[\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^{6}\\right],$$ 沿粒子间轴线的相应力的大小为 $$F(r) = -\\frac{dU}{dr} = 24 \\epsilon \\left[\\frac{2 \\sigma^{12}}{r^{13}} - \\frac{\\sigma^{6}}{r^{7}}\\right],$$ 因此力矢量与粒子间矢量共线。\n\n从这些原理出发，你必须实现一个velocity-Verlet积分器（Verlet族算法的一员），以传播一个Lennard-Jones二聚体的轨迹。将Lennard-Jones平衡距离定义为 $$r_{0} = 2^{1/6} \\sigma.$$ 将两个粒子初始化在位置 $\\mathbf{r}_{1}(0) = \\left(-\\frac{r}{2}, 0, 0\\right)$ 和 $\\mathbf{r}_{2}(0) = \\left(\\frac{r}{2}, 0, 0\\right)$，其中 $r = r_{0} + A$，并将初始速度设为零，以使质心保持在原点。对每条轨迹，计算瞬时总能量 $$E(t) = \\sum_{i=1}^{2} \\frac{1}{2} m \\left\\|\\mathbf{v}_{i}(t)\\right\\|^{2} + U\\left(\\left\\|\\mathbf{r}_{2}(t) - \\mathbf{r}_{1}(t)\\right\\|\\right),$$ 并在固定的模拟时长 $T$ 上，将经验误差度量定义为能量相对于初始能量的均方根偏差 $$e(\\Delta t) = \\sqrt{\\frac{1}{N} \\sum_{n=1}^{N} \\left(E(t_{n}) - E(0)\\right)^{2}},$$ 其中 $t_{n} = n \\Delta t$ 且 $N = \\left\\lfloor T / \\Delta t \\right\\rfloor$。在每个时间步长 $\\Delta t$ 使用velocity-Verlet方案来更新位置和速度。\n\n你的经验性程序必须通过对使用以10为底的对数进行对数转换后的数据拟合一条直线，来估计 $e(\\Delta t)$ 随 $\\Delta t$ 的标度关系。具体来说，对每组测量值 $\\{\\Delta t_{k}, e(\\Delta t_{k})\\}$，拟合 $$\\log_{10} e(\\Delta t) \\approx s \\, \\log_{10} \\Delta t + c,$$ 并将斜率 $s$ 作为经验标度指数报告。此外，使用关于velocity-Verlet方法精度阶数的原理性推理，来预测对于光滑势的渐近斜率 $s$。\n\n所有模拟都必须在如上定义的简化Lennard-Jones单位制中进行，且所有报告的量都是无量纲的，不附带物理单位。角度（如果有的话）必须以弧度为单位，尽管该系统只涉及平移运动。最终输出必须四舍五入到三位小数。\n\n测试套件规范：\n- 使用总模拟时间 $T = 50$。\n- 使用三个初始振幅值 $A \\in \\{0.05, 0.2, 0.5\\}$，其中 $A$ 控制初始间距 $r = r_{0} + A$。\n- 对于 $A = 0.05$ 和 $A = 0.2$，使用时间步长集合 $$\\Delta t \\in \\{0.002, 0.005, 0.01, 0.02, 0.04, 0.08\\}.$$\n- 对于 $A = 0.5$，使用一个更大的步长集合来探测稳定性的边缘 $$\\Delta t \\in \\{0.004, 0.008, 0.016, 0.032, 0.064, 0.12\\}.$$\n\n你的程序必须：\n- 使用所描述的方程为Lennard-Jones二聚体实现velocity-Verlet积分器。\n- 对每个测试用例，为所有指定的 $\\Delta t$ 值计算 $e(\\Delta t)$，拟合对数-对数斜率 $s$，并收集这些斜率。\n- 根据积分器的阶数预测理论渐近斜率，并将其作为一个附加值包含在最终输出中。\n\n最终输出格式：\n- 你的程序应产生单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。该列表必须包含四个浮点数，四舍五入到三位小数：按顺序分别为 $A = 0.05$、$A = 0.2$ 和 $A = 0.5$ 的三个经验斜率，后面跟着预测的理论斜率。例如，形如 $$[s_{0.05}, s_{0.2}, s_{0.5}, s_{\\mathrm{pred}}]$$ 的输出。\n\n每个测试用例的答案和预测的斜率都必须是浮点数。根据设计，输出是无量纲和无单位的。",
            "solution": "该问题要求实现一个velocity-Verlet积分器，以模拟通过Lennard-Jones势相互作用的双粒子系统（一个二聚体）的动力学。主要目标是经验性地确定能量守恒误差随积分时间步长 $\\Delta t$ 的标度关系，并将其与算法的理论预测进行比较。\n\n**理论框架和系统定义**\n\n该系统由两个粒子组成，索引为 $i=1, 2$，在简化的Lennard-Jones单位制中，每个粒子的质量均为 $m=1$。动力学由牛顿第二定律控制：\n$$ m \\frac{d^2\\mathbf{r}_i}{dt^2} = \\mathbf{F}_i $$\n由于 $m=1$，加速度就等于力，$\\mathbf{a}_i = \\mathbf{F}_i$。作用在粒子 $i$ 上的力 $\\mathbf{F}_i$ 是由其他粒子施加的力的矢量和。在这个双粒子系统中，力是内力，并形成一个作用-反作用力对：$\\mathbf{F}_1 = -\\mathbf{F}_2$。\n\n相互作用由Lennard-Jones（LJ）势描述，在简化单位（$\\epsilon=1, \\sigma=1$）下，它是粒子间距离 $r = \\|\\mathbf{r}_2 - \\mathbf{r}_1\\|$ 的函数：\n$$ U(r) = 4 \\left( \\frac{1}{r^{12}} - \\frac{1}{r^6} \\right) $$\n力的大小由势能导出，$F(r) = -dU/dr$：\n$$ F(r) = 24 \\left( \\frac{2}{r^{13}} - \\frac{1}{r^7} \\right) $$\n粒子1对粒子2的力 $\\mathbf{F}_2$ 是 $\\mathbf{F}_2 = F(r) \\hat{\\mathbf{r}}$，其中 $\\hat{\\mathbf{r}} = (\\mathbf{r}_2 - \\mathbf{r}_1)/r$ 是从粒子1指向粒子2的单位矢量。相应地，$\\mathbf{F}_1 = - \\mathbf{F}_2$。\n\n粒子被对称地初始化在原点两侧，初始速度为零。这确保了质心 $\\mathbf{R} = (\\mathbf{r}_1 + \\mathbf{r}_2)/2$ 始终固定在原点。初始位置为 $\\mathbf{r}_1(0) = (-r/2, 0, 0)$ 和 $\\mathbf{r}_2(0) = (r/2, 0, 0)$，其中初始间距为 $r = r_0 + A$。这里，$r_0 = 2^{1/6}\\sigma = 2^{1/6}$ 是LJ势的平衡距离，$A$ 是给定的位移振幅。由于初始条件和力都沿着粒子间轴线方向，运动被限制在一维（x轴）上。\n\n**数值积分：Velocity-Verlet算法**\n\nvelocity-Verlet算法是一种用于积分牛顿运动方程的数值方法。它是Verlet算法族的一员，在分子动力学中因其时间可逆性、辛性和良好的长期能量稳定性而备受推崇。该算法以大小为 $\\Delta t$ 的离散时间步进行。对每个粒子，从时间 $t$ 到 $t+\\Delta t$ 的更新按以下方式执行：\n\n1.  更新位置：\n    $$ \\mathbf{r}(t + \\Delta t) = \\mathbf{r}(t) + \\mathbf{v}(t)\\Delta t + \\frac{1}{2}\\mathbf{a}(t)\\Delta t^2 $$\n2.  使用新位置 $\\mathbf{r}(t+\\Delta t)$ 计算新的力 $\\mathbf{F}(t+\\Delta t)$ 和加速度 $\\mathbf{a}(t+\\Delta t) = \\mathbf{F}(t+\\Delta t)/m$。\n3.  更新速度：\n    $$ \\mathbf{v}(t + \\Delta t) = \\mathbf{v}(t) + \\frac{1}{2}\\left[ \\mathbf{a}(t) + \\mathbf{a}(t+\\Delta t) \\right] \\Delta t $$\n\n此方案在每个时间步应用于两个粒子。\n\n**误差分析和预测标度**\n\nvelocity-Verlet算法的位置局部截断误差为 $O(\\Delta t^4)$，全局误差为 $O(\\Delta t^2)$。对于一个保守系统，像velocity-Verlet这样的辛积分器的一个关键特征是，它们不守恒真实的哈密顿量（能量）$E$，而是守恒一个与真实哈密顿量接近的“影子”哈密顿量。因此，计算出的总能量 $E(t)$ 不会漂移，而是在初始能量 $E(0)$ 附近振荡。这些振荡的幅度是积分器误差的一种度量。\n\n对于velocity-Verlet方法，已知能量涨落的大小 $|E(t) - E(0)|$ 在 $\\Delta t$ 足够小的情况下，与时间步长的平方成比例：\n$$ |E(t) - E(0)| \\propto (\\Delta t)^2 $$\n问题要求的是均方根能量偏差的标度关系，其定义为：\n$$ e(\\Delta t) = \\sqrt{\\frac{1}{N} \\sum_{n=1}^{N} \\left(E(t_{n}) - E(0)\\right)^{2}} $$\n其中 $t_n = n \\Delta t$。鉴于每一项 $E(t_n) - E(0)$ 的阶为 $O((\\Delta t)^2)$，平方项 $(E(t_n) - E(0))^2$ 的阶为 $O((\\Delta t)^4)$。这些项的平均值也将是 $O((\\Delta t)^4)$ 阶。取平方根得到 $e(\\Delta t)$ 的标度关系：\n$$ e(\\Delta t) \\propto \\sqrt{O((\\Delta t)^4)} = O((\\Delta t)^2) $$\n这意味着存在一个标度关系 $e(\\Delta t) = C (\\Delta t)^s$，其中指数 $s=2$。为了从数据中找出这个指数，我们使用对数-对数图：\n$$ \\log_{10} e(\\Delta t) = s \\log_{10} \\Delta t + \\log_{10} C $$\n这是一个 $y = sx + c$ 形式的线性方程。拟合数据点 $(\\log_{10} \\Delta t_k, \\log_{10} e(\\Delta t_k))$ 的直线的斜率给出了经验标度指数 $s$。基于velocity-Verlet算法的理论性质，预测的渐近斜率为 $s_{\\text{pred}} = 2$。\n\n**实现计划**\n\n该解决方案通过一个遵循以下步骤的Python脚本实现：\n1.  **定义常量和函数**：设置LJ简化单位（$m=1, \\sigma=1, \\epsilon=1$），并定义用于LJ势和力大小的函数。平衡距离为 $r_0 = 2^{1/6}$。\n2.  **主模拟循环**：创建一个函数 `run_simulation(A, dt, T)`。\n    - 它根据给定的振幅 $A$ 初始化两个粒子的位置和速度。\n    - 它计算初始力、加速度和总能量 $E(0)$。\n    - 它迭代 $N = \\lfloor T/\\Delta t \\rfloor$ 步，在每一步对两个粒子应用velocity-Verlet更新规则。\n    - 在每一步 $n$，它计算当前的总能量 $E(t_n)$ 并存储平方偏差 $(E(t_n) - E(0))^2$。\n    - 循环结束后，它计算均方根误差 $e(\\Delta t)$ 并返回它。\n3.  **数据生成与分析**：\n    - 一个主函数遍历三个指定的测试用例（$A$ 的值）。\n    - 对每个 $A$，它为指定集合中的每个相应 $\\Delta t$ 调用 `run_simulation`，以生成一个误差值列表 $e(\\Delta t_k)$。\n    - $\\Delta t_k$ 和 $e(\\Delta t_k)$ 的列表被进行以10为底的对数转换。\n    - 使用 `numpy.polyfit` 对转换后的数据点 $(\\log_{10} \\Delta t, \\log_{10} e)$ 进行线性回归，以确定斜率 $s$。\n4.  **输出**：收集三个经验斜率（$s_{0.05}, s_{0.2}, s_{0.5}$）和预测的理论斜率（$s_{\\text{pred}}=2.0$），并格式化为所需的输出字符串，每个值都四舍五入到三位小数。\n\n此过程系统地评估了velocity-Verlet积分器对于给定物理系统的性能，并通过分析能量守恒误差的标度关系来确认其理论精度阶数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef lj_potential(r):\n    \"\"\"Calculates the Lennard-Jones potential in reduced units.\"\"\"\n    if r == 0:\n        return np.inf\n    r_inv6 = (1.0 / r)**6\n    return 4.0 * (r_inv6**2 - r_inv6)\n\ndef lj_force_magnitude(r):\n    \"\"\"Calculates the magnitude of the Lennard-Jones force in reduced units.\"\"\"\n    if r == 0:\n        return np.inf\n    r_inv7 = (1.0 / r)**7\n    return 24.0 * (2.0 * r_inv7 * (1.0 / r)**6 - r_inv7)\n\ndef get_accelerations(pos1, pos2):\n    \"\"\"\n    Calculates the acceleration vectors for two particles.\n    In reduced units, mass m=1, so acceleration a = F.\n    \"\"\"\n    r_vec = pos2 - pos1\n    r = np.linalg.norm(r_vec)\n    f_mag = lj_force_magnitude(r)\n    f_vec = f_mag * (r_vec / r)\n    \n    # By Newton's third law, F_12 = -F_21\n    # a_2 is due to force from 1 on 2 (F_21)\n    # a_1 is due to force from 2 on 1 (F_12)\n    accel2 = f_vec\n    accel1 = -f_vec\n    return accel1, accel2\n\ndef run_simulation(A, dt, T):\n    \"\"\"\n    Runs a single molecular dynamics simulation for a Lennard-Jones dimer.\n    Returns the root-mean-square energy deviation e(dt).\n    \"\"\"\n    r0 = 2**(1/6.0)\n    r_initial_separation = r0 + A\n\n    # Initialize positions and velocities\n    pos1 = np.array([-r_initial_separation / 2.0, 0.0, 0.0])\n    pos2 = np.array([r_initial_separation / 2.0, 0.0, 0.0])\n    vel1 = np.zeros(3)\n    vel2 = np.zeros(3)\n\n    # Calculate initial state\n    accel1, accel2 = get_accelerations(pos1, pos2)\n    \n    # Calculate initial total energy E(0)\n    ke = 0.5 * (np.sum(vel1**2) + np.sum(vel2**2)) # m=1\n    pe = lj_potential(np.linalg.norm(pos2 - pos1))\n    e_initial = ke + pe\n    \n    energy_deviations_sq = []\n    num_steps = int(T / dt)\n\n    for _ in range(num_steps):\n        # Velocity-Verlet Step 1: Update positions\n        pos1_new = pos1 + vel1 * dt + 0.5 * accel1 * dt**2\n        pos2_new = pos2 + vel2 * dt + 0.5 * accel2 * dt**2\n\n        # Velocity-Verlet Step 2: Calculate new accelerations\n        accel1_new, accel2_new = get_accelerations(pos1_new, pos2_new)\n\n        # Velocity-Verlet Step 3: Update velocities\n        vel1_new = vel1 + 0.5 * (accel1 + accel1_new) * dt\n        vel2_new = vel2 + 0.5 * (accel2 + accel2_new) * dt\n\n        # Update state for the next iteration\n        pos1, pos2 = pos1_new, pos2_new\n        vel1, vel2 = vel1_new, vel2_new\n        accel1, accel2 = accel1_new, accel2_new\n\n        # Calculate current total energy E(t_n) and deviation\n        ke_current = 0.5 * (np.sum(vel1**2) + np.sum(vel2**2))\n        pe_current = lj_potential(np.linalg.norm(pos2 - pos1))\n        e_current = ke_current + pe_current\n        \n        energy_deviations_sq.append((e_current - e_initial)**2)\n\n    # Calculate the final empirical error metric e(dt)\n    if not energy_deviations_sq:\n        return 0.0\n    \n    e_dt = np.sqrt(np.mean(energy_deviations_sq))\n    return e_dt\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and produce the final output.\n    \"\"\"\n    T = 50.0\n\n    test_cases = [\n        (0.05, [0.002, 0.005, 0.01, 0.02, 0.04, 0.08]),\n        (0.2,  [0.002, 0.005, 0.01, 0.02, 0.04, 0.08]),\n        (0.5,  [0.004, 0.008, 0.016, 0.032, 0.064, 0.12])\n    ]\n\n    results = []\n    for A, dt_values in test_cases:\n        e_values = [run_simulation(A, dt, T) for dt in dt_values]\n        \n        # Handle cases where error might be zero to avoid log(0)\n        # and ensure arrays are correctly typed for polyfit\n        dt_array = np.array(dt_values, dtype=float)\n        e_array = np.array(e_values, dtype=float)\n\n        # Filter out any non-positive values before taking log\n        valid_indices = e_array > 0\n        if np.sum(valid_indices) < 2:\n            # Not enough data for a fit, append a placeholder (e.g., NaN)\n            # or handle as an error. For this problem, a valid slope is expected.\n            # We assume results will be well-behaved.\n            slope = np.nan \n        else:\n            log_dt = np.log10(dt_array[valid_indices])\n            log_e = np.log10(e_array[valid_indices])\n\n            # Perform linear regression to find the slope s\n            # s = slope, c = intercept\n            s, _ = np.polyfit(log_dt, log_e, 1)\n        \n        results.append(s)\n    \n    # Add the predicted theoretical slope\n    s_pred = 2.0\n    results.append(s_pred)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.3f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}