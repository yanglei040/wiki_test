{
    "hands_on_practices": [
        {
            "introduction": "在深入研究相空间轨迹的数值模拟之前，我们必须首先掌握支配其演化的基本数学框架。泊松括号是经典哈密顿力学的核心，它不仅描述了任意物理可观测量随时间的演化，还揭示了不同可观测量之间的内在代数关系。本练习通过计算角动量分量的泊松括号，让您亲手验证一个经典结果，从而巩固您对相空间动力学基础结构的理解，并体会其与对称性和守恒律的深刻联系。",
            "id": "3435414",
            "problem": "考虑一个在三维(3D)笛卡尔相空间中进行经典分子动力学(MD)演化的单个粒子，其正则位置坐标为$q_{x}$、$q_{y}$、$q_{z}$，正则动量坐标为$p_{x}$、$p_{y}$、$p_{z}$。轨道角动量分量定义为 $L_{x} = q_{y} p_{z} - q_{z} p_{y}$、$L_{y} = q_{z} p_{x} - q_{x} p_{z}$ 和 $L_{z} = q_{x} p_{y} - q_{y} p_{x}$。两个相空间函数 $A(q,p)$ 和 $B(q,p)$ 的泊松括号定义为\n$$\n\\{A,B\\} = \\sum_{i \\in \\{x,y,z\\}} \\left( \\frac{\\partial A}{\\partial q_{i}} \\frac{\\partial B}{\\partial p_{i}} - \\frac{\\partial A}{\\partial p_{i}} \\frac{\\partial B}{\\partial q_{i}} \\right)\n$$\n您的任务是计算角动量分量之间的泊松括号 $\\{L_i, L_j\\}$。请使用指标表示法和爱因斯坦求和约定，并利用列维-奇维塔符号 $\\epsilon_{ijk}$ 将最终结果表示为一个紧凑的解析表达式。无需进行数值计算或报告单位。",
            "solution": "该问题要求计算在三维笛卡尔相空间中单个粒子的轨道角动量各分量之间的泊松括号。最终结果需要用紧凑的指标表示法表示。\n\n首先，我们用指标表示法来表达给定的量，并对重复指标采用爱因斯坦求和约定。正则坐标用 $q_i$ 和 $p_i$ 表示，其中指标 $i$ 可以是 $1$、$2$ 或 $3$（对应于 $x$、$y$ 和 $z$）。\n\n角动量矢量 $\\vec{L} = \\vec{q} \\times \\vec{p}$ 的第 $i$ 个分量由列维-奇维塔符号 $\\epsilon_{ijk}$ 给出：\n$$\nL_i = \\epsilon_{ijk} q_j p_k\n$$\n例如，对于 $i=1$（$x$ 分量），我们有 $L_1 = \\epsilon_{1jk} q_j p_k = \\epsilon_{123} q_2 p_3 + \\epsilon_{132} q_3 p_2 = q_2 p_3 - q_3 p_2$，这与所提供的 $L_x = q_y p_z - q_z p_y$ 定义一致。\n\n相空间上两个函数 $A$ 和 $B$ 的泊松括号在指标表示法中为：\n$$\n\\{A,B\\} = \\frac{\\partial A}{\\partial q_{m}} \\frac{\\partial B}{\\partial p_{m}} - \\frac{\\partial A}{\\partial p_{m}} \\frac{\\partial B}{\\partial q_{m}}\n$$\n其中，对求和指标 $m$ 采用了爱因斯坦求和约定。\n\n我们需要计算任意分量 $i$ 和 $j$ 的泊松括号 $\\{L_i, L_j\\}$。我们将 $A = L_i = \\epsilon_{ik\\ell} q_k p_\\ell$ 和 $B = L_j = \\epsilon_{jmn} q_m p_n$ 代入定义中。\n首先，我们计算所需的偏导数，利用基本正则关系 $\\frac{\\partial q_a}{\\partial q_b} = \\delta_{ab}$ 和 $\\frac{\\partial p_a}{\\partial p_b} = \\delta_{ab}$，其中 $\\delta_{ab}$ 是克罗内克 delta。\n$$\n\\frac{\\partial L_i}{\\partial q_s} = \\frac{\\partial}{\\partial q_s} (\\epsilon_{ik\\ell} q_k p_\\ell) = \\epsilon_{ik\\ell} \\delta_{ks} p_\\ell = \\epsilon_{is\\ell} p_\\ell\n$$\n$$\n\\frac{\\partial L_i}{\\partial p_s} = \\frac{\\partial}{\\partial p_s} (\\epsilon_{ik\\ell} q_k p_\\ell) = \\epsilon_{ik\\ell} q_k \\delta_{\\ell s} = \\epsilon_{iks} q_k\n$$\n将这些导数代入泊松括号的定义中（用 $s$ 作为求和指标）：\n$$\n\\{L_i, L_j\\} = \\frac{\\partial L_i}{\\partial q_s} \\frac{\\partial L_j}{\\partial p_s} - \\frac{\\partial L_i}{\\partial p_s} \\frac{\\partial L_j}{\\partial q_s} = (\\epsilon_{is\\ell} p_\\ell)(\\epsilon_{jms} q_m) - (\\epsilon_{iks} q_k)(\\epsilon_{jsn} p_n)\n$$\n现在我们分别计算这两项。\n第一项：$\\epsilon_{is\\ell} \\epsilon_{jms} q_m p_\\ell$。我们使用两个列维-奇维塔符号乘积并对一个共享指标求和的恒等式：$\\sum_s \\epsilon_{sab} \\epsilon_{scd} = \\delta_{ac}\\delta_{bd} - \\delta_{ad}\\delta_{bc}$。为了应用此恒等式，我们重新排列符号：\n$$\n\\sum_s \\epsilon_{is\\ell} \\epsilon_{jms} = \\sum_s (-\\epsilon_{si\\ell}) (-\\epsilon_{smj}) = \\sum_s \\epsilon_{si\\ell} \\epsilon_{smj} = \\delta_{im}\\delta_{\\ell j} - \\delta_{ij}\\delta_{\\ell m}\n$$\n将此结果代入第一项的表达式中：\n$$\n(\\delta_{im}\\delta_{\\ell j} - \\delta_{ij}\\delta_{\\ell m}) q_m p_\\ell = q_i p_j - \\delta_{ij} q_m p_m = q_i p_j - \\delta_{ij} (\\vec{q} \\cdot \\vec{p})\n$$\n第二项：$\\epsilon_{iks} \\epsilon_{jsn} q_k p_n$。同样，我们对指标 $s$ 求和：\n$$\n\\sum_s \\epsilon_{iks} \\epsilon_{jsn} = \\sum_s (-\\epsilon_{kis}) (-\\epsilon_{jns}) = \\sum_s \\epsilon_{kis} \\epsilon_{jns} = \\delta_{kj}\\delta_{in} - \\delta_{kn}\\delta_{ij}\n$$\n将此结果代入第二项的表达式中：\n$$\n(\\delta_{kj}\\delta_{in} - \\delta_{kn}\\delta_{ij}) q_k p_n = q_j p_i - \\delta_{ij} q_k p_k = q_j p_i - \\delta_{ij} (\\vec{q} \\cdot \\vec{p})\n$$\n现在，我们将两项组合起来（第一项减去第二项）：\n$$\n\\{L_i, L_j\\} = (q_i p_j - \\delta_{ij} (\\vec{q} \\cdot \\vec{p})) - (q_j p_i - \\delta_{ij} (\\vec{q} \\cdot \\vec{p})) = q_i p_j - q_j p_i\n$$\n最后，我们需要将这个结果用 $L_k$ 表示。我们来计算 $\\epsilon_{ijk} L_k$：\n$$\n\\epsilon_{ijk} L_k = \\epsilon_{ijk} (\\epsilon_{k\\ell m} q_\\ell p_m)\n$$\n我们再次使用列维-奇维塔恒等式，这次对指标 $k$ 进行缩并：$\\sum_k \\epsilon_{ijk} \\epsilon_{k\\ell m} = \\sum_k \\epsilon_{kij} \\epsilon_{k\\ell m} = \\delta_{i\\ell}\\delta_{jm} - \\delta_{im}\\delta_{j\\ell}$。\n$$\n\\epsilon_{ijk} L_k = (\\delta_{i\\ell}\\delta_{jm} - \\delta_{im}\\delta_{j\\ell}) q_\\ell p_m = q_i p_j - q_j p_i\n$$\n我们发现 $\\{L_i, L_j\\}$ 和 $\\epsilon_{ijk} L_k$ 的计算结果都等于 $q_i p_j - q_j p_i$。因此，它们是相等的。\n角动量分量之间的泊松括号关系为：\n$$\n\\{L_i, L_j\\} = \\epsilon_{ijk} L_k\n$$\n这个结果在经典力学中是基础性的，它表明角动量分量在泊松括号下的代数是一个李代数，即三维旋转群的代数 $\\mathfrak{so}(3)$。",
            "answer": "$$\n\\boxed{\\{L_i, L_j\\} = \\epsilon_{ijk} L_k}\n$$"
        },
        {
            "introduction": "从连续的理论转向离散的计算机模拟时，我们面临一个核心挑战：如何确保数值算法能忠实地反映真实物理。刘维尔定理指出，对于哈密顿系统，相空间中的体积在时间演化中是守恒的，这一性质对模拟的长期稳定性至关重要。本实践旨在通过编码，让您亲手检验不同数值积分方法（如辛算法和非辛算法）在保持相空间体积方面的表现。通过数值计算单步积分映射的雅可比行列式，您将直观地理解为何像Verlet这样的辛积分方法是分子动力学模拟的基石。",
            "id": "3435418",
            "problem": "考虑一个用于分子动力学（MD）的哈密顿系统，其中相空间状态为 $x = (q, p) \\in \\mathbb{R}^{2N}$，坐标为 $q \\in \\mathbb{R}^{N}$，动量为 $p \\in \\mathbb{R}^{N}$。哈密顿量为 $H(q,p) = \\sum_{i=1}^{N} \\frac{p_i^2}{2 m_i} + V(q)$，其中质量 $m_i > 0$，势 $V(q)$ 是光滑的。精确的哈密顿流映射 $\\Phi_t : \\mathbb{R}^{2N} \\to \\mathbb{R}^{2N}$ 根据哈密顿方程 $\\dot{q}_i = \\partial H / \\partial p_i$ 和 $\\dot{p}_i = -\\partial H / \\partial q_i$ 来演化状态 $x(t) = \\Phi_t(x(0))$。刘维尔定理指出，精确流保持相空间体积，等价地，其雅可比行列式 $J(t) = \\det(D \\Phi_t(x))$ 对所有 $t$ 满足 $J(t) = 1$。在微正则 MD（恒定能量）中，通常使用数值积分器来近似计算一个微小时间步长 $\\Delta t$ 下的 $\\Phi_{\\Delta t}$。在离散化设定中，单步映射 $\\Phi_{\\Delta t}$ 是否精确保持相空间体积，取决于积分器是否是辛的。\n\n您的任务是编写一个完整的程序，该程序在每个时间步使用中心有限差分法，数值估算离散单步流映射在当前状态 $x$ 周围的雅可比行列式 $J = \\det(D \\Phi_{\\Delta t}(x))$，然后计算在固定步数内最大绝对偏差 $\\max_{n} |J_n - 1|$。您必须实现三种单步积分器：速度Verlet（辛积分器）、经典四阶龙格－库塔和前向欧拉（两者通常都是非辛的）。对于下面指定的每种积分器和势，您将模拟固定步数的离散动力学，并报告每步雅可比行列式与 1 的最大绝对偏差。\n\n在整个过程中使用无量纲单位。雅可比矩阵 $D \\Phi_{\\Delta t}(x) \\in \\mathbb{R}^{2N \\times 2N}$ 必须通过中心有限差分进行数值估算：对于一个小的扰动大小 $\\varepsilon > 0$ 和标准基向量 $e_j \\in \\mathbb{R}^{2N}$，第 $j$ 列通过以下方式估算\n$$\n[D \\Phi_{\\Delta t}(x)]_{\\cdot j} \\approx \\frac{\\Phi_{\\Delta t}(x + \\varepsilon e_j) - \\Phi_{\\Delta t}(x - \\varepsilon e_j)}{2 \\varepsilon}.\n$$\n然后使用标准行列式例程计算 $J = \\det(D \\Phi_{\\Delta t}(x))$。在每个时间步 $n$，记录 $|J_n - 1|$，更新状态 $x \\leftarrow \\Phi_{\\Delta t}(x)$，然后继续。\n\n系统由哈密顿方程 $\\dot{q} = p / m$ 和 $\\dot{p} = -\\nabla V(q)$ 定义，其中除法 $p/m$ 对于 $p \\in \\mathbb{R}^{N}$ 和 $m \\in \\mathbb{R}^{N}$ 是逐元素的。实现以下势 $V(q)$ 及其梯度 $\\nabla V(q)$：\n\n- 1 维谐振子：$V(q) = \\tfrac{1}{2} k q^2$，梯度为 $\\nabla V(q) = k q$。\n- 2 维耦合谐振子：$V(q_1,q_2) = \\tfrac{1}{2} k (q_1^2 + q_2^2) + \\alpha q_1 q_2$，梯度为 $\\nabla V(q) = (k q_1 + \\alpha q_2, k q_2 + \\alpha q_1)$。\n- 1 维四次加二次势：$V(q) = \\tfrac{1}{2} k q^2 + \\tfrac{1}{4} \\lambda q^4$，梯度为 $\\nabla V(q) = k q + \\lambda q^3$。\n\n为状态 $x = (q,p)$ 实现以下单步积分器：\n\n- 速度Verlet：$p_{n+\\frac{1}{2}} = p_n - \\frac{\\Delta t}{2} \\nabla V(q_n)$, $q_{n+1} = q_n + \\Delta t \\, p_{n+\\frac{1}{2}}/m$, $p_{n+1} = p_{n+\\frac{1}{2}} - \\frac{\\Delta t}{2} \\nabla V(q_{n+1})$。\n- 应用于一阶系统 $\\dot{q} = p/m$, $\\dot{p} = -\\nabla V(q)$ 的经典四阶龙格－库塔。\n- 前向欧拉：$q_{n+1} = q_n + \\Delta t \\, p_n/m$, $p_{n+1} = p_n - \\Delta t \\, \\nabla V(q_n)$。\n\n为了数值的稳定性和准确性，在当前状态下单步映射的雅可比估算中使用一个小的步长 $\\varepsilon$ 进行中心有限差分。\n\n测试套件：\n您必须实现以下四个测试用例，并为每个用例计算单个标量输出 $\\max_{0 \\le n  N_{\\text{steps}}} |J_n - 1|$，其中 $J_n$ 是在第 $n$ 步估算的雅可比行列式。\n\n- 用例 1：$N = 1$， $m = 1$，谐振子势，$k = 1$，速度Verlet积分器，$\\Delta t = 0.01$，$N_{\\text{steps}} = 1000$，初始状态 $(q_0, p_0) = (1.0, 0.0)$，有限差分 $\\varepsilon = 10^{-8}$。\n- 用例 2：$N = 1$，$m = 1$，谐振子势，$k = 1$，经典四阶龙格－库塔积分器，$\\Delta t = 0.05$，$N_{\\text{steps}} = 200$，初始状态 $(q_0, p_0) = (1.0, 0.0)$，有限差分 $\\varepsilon = 10^{-8}$。\n- 用例 3：$N = 2$，$m = (1, 1)$，耦合谐振子势，$k = 1$，$\\alpha = 0.1$，速度Verlet积分器，$\\Delta t = 0.01$，$N_{\\text{steps}} = 500$，初始状态 $(q_0, p_0) = ((0.5, -0.5), (0.0, 0.0))$，有限差分 $\\varepsilon = 10^{-8}$。\n- 用例 4：$N = 1$，$m = 1$，四次加二次势，$k = 1$，$\\lambda = 0.5$，前向欧拉积分器，$\\Delta t = 0.01$，$N_{\\text{steps}} = 300$，初始状态 $(q_0, p_0) = (0.2, 0.5)$，有限差分 $\\varepsilon = 10^{-8}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按测试用例 1 到 4 的顺序列出结果。每个条目必须是一个浮点数，等于该测试用例在指定步数内每步雅可比行列式与 1 的最大绝对偏差。例如，输出格式必须为 $[r_1,r_2,r_3,r_4]$ 的形式，其中每个 $r_i$ 是您的程序计算出的浮点数。",
            "solution": "该问题要求对分子动力学中使用的三种不同数值积分方案的相空间体积保持特性进行数值研究。根据哈密顿系统的刘维尔定理，精确的时间演化流 $\\Phi_t$ 是保体积的。这意味着其雅可比矩阵的行列式 $J(t) = \\det(D\\Phi_t)$ 在所有时间 $t$ 内都恒等于 1。数值积分器提供了在小时间步长 $\\Delta t$ 上对该流的近似 $\\Phi_{\\Delta t}$。能够精确保持此性质的积分器，即其单步映射的雅可比行列式为 1 的积分器，被称为辛积分器。此性质对于分子动力学模拟的长期稳定性和准确性至关重要，尤其是在总能量应守恒的微正则系综中。\n\n本解决方案将实现指定的积分器，并在模拟的每一步数值估算其单步映射的雅可比行列式。主要关注的度量是在指定步数 $N_{\\text{steps}}$ 的轨迹上，该行列式与 1 的最大绝对偏差 $\\max_{n} |J_n - 1|$。\n\n### 状态表示与雅可比估算\n具有 $N$ 个自由度的系统的状态由一个向量 $x = (q, p) \\in \\mathbb{R}^{2N}$ 表示，其中 $q \\in \\mathbb{R}^N$ 是广义坐标，$p \\in \\mathbb{R}^N$ 是共轭动量。在实现时，此状态存储为长度为 $2N$ 的单个扁平数组。\n\n单步映射的雅可比矩阵 $D\\Phi_{\\Delta t}(x)$ 是一个 $2N \\times 2N$ 的矩阵。我们使用中心有限差分法来估算该矩阵。对于每个标准基向量 $e_j \\in \\mathbb{R}^{2N}$（其中 $e_j$ 在索引 $j$ 处为 1，其他位置为 0），雅可比矩阵的第 $j$ 列近似为：\n$$\n[D \\Phi_{\\Delta t}(x)]_{\\cdot j} \\approx \\frac{\\Phi_{\\Delta t}(x + \\varepsilon e_j) - \\Phi_{\\Delta t}(x - \\varepsilon e_j)}{2 \\varepsilon}\n$$\n此处，$\\Phi_{\\Delta t}$ 表示某个数值积分器在一个时间步长 $\\Delta t$ 内的作用，$\\varepsilon$ 是一个小的扰动参数。一旦逐列构建出完整的雅可比矩阵，就使用标准的数值线性代数例程计算其行列式 $J = \\det(D \\Phi_{\\Delta t}(x))$。\n\n### 哈密顿系统与势\n系统动力学由形式为 $H(q,p) = K(p) + V(q)$ 的哈密顿量控制，该哈密顿量可分离为动能项 $K(p) = \\sum_{i=1}^{N} \\frac{p_i^2}{2 m_i}$ 和势能项 $V(q)$。运动方程由哈密顿方程给出：\n$$\n\\dot{q} = \\frac{\\partial H}{\\partial p} = \\frac{p}{m} \\quad \\text{和} \\quad \\dot{p} = -\\frac{\\partial H}{\\partial q} = -\\nabla V(q)\n$$\n测试用例所需的具体势及其梯度如下：\n1.  **谐振子 ($N=1$):**\n    $V(q) = \\frac{1}{2} k q^2$\n    $\\nabla V(q) = k q$\n\n2.  **耦合谐振子 ($N=2$):**\n    $V(q_1, q_2) = \\frac{1}{2} k (q_1^2 + q_2^2) + \\alpha q_1 q_2$\n    $\\nabla V(q) = \\begin{pmatrix} k q_1 + \\alpha q_2 \\\\ k q_2 + \\alpha q_1 \\end{pmatrix}$\n\n3.  **四次加二次势 ($N=1$):**\n    $V(q) = \\frac{1}{2} k q^2 + \\frac{1}{4} \\lambda q^4$\n    $\\nabla V(q) = k q + \\lambda q^3$\n\n### 数值积分器\n实现了三种单步积分器 $\\Phi_{\\Delta t}$，用于将状态从 $x_n = (q_n, p_n)$ 推进到 $x_{n+1} = (q_{n+1}, p_{n+1})$。\n\n1.  **速度Verlet**：这是一种用于可分离哈密顿系统的二阶辛积分器。其辛性意味着其精确映射（无浮点误差）的雅可比行列式为 1。更新规则为：\n    $$\n    p_{n+\\frac{1}{2}} = p_n - \\frac{\\Delta t}{2} \\nabla V(q_n) \\\\\n    q_{n+1} = q_n + \\Delta t \\, \\frac{p_{n+\\frac{1}{2}}}{m} \\\\\n    p_{n+1} = p_{n+\\frac{1}{2}} - \\frac{\\Delta t}{2} \\nabla V(q_{n+1})\n    $$\n\n2.  **经典四阶龙格－库塔 (RK4)**：这是一种通用、高阶但非辛的积分器。对于自治系统 $\\dot{y} = f(y)$，更新规则为：\n    $$\n    k_1 = \\Delta t \\cdot f(y_n) \\\\\n    k_2 = \\Delta t \\cdot f(y_n + \\frac{1}{2} k_1) \\\\\n    k_3 = \\Delta t \\cdot f(y_n + \\frac{1}{2} k_2) \\\\\n    k_4 = \\Delta t \\cdot f(y_n + k_3) \\\\\n    y_{n+1} = y_n + \\frac{1}{6}(k_1 + 2k_2 + 2k_3 + k_4)\n    $$\n    在我们的例子中，状态为 $y=x=(q,p)$，导数函数为 $f(x) = (\\frac{p}{m}, -\\nabla V(q))$。尽管 RK4 对于单步计算非常精确，但其非辛性导致雅可比行列式不等于 1。\n\n3.  **前向欧拉**：这是一种一阶、显式且非辛的积分器。它很简单，但由于其较差的稳定性和能量守恒特性，通常不适用于长期的哈密顿动力学。其更新规则为：\n    $$\n    q_{n+1} = q_n + \\Delta t \\, \\frac{p_n}{m} \\\\\n    p_{n+1} = p_n - \\Delta t \\, \\nabla V(q_n)\n    $$\n    预计该方法将显示出对体积保持性的显著偏离。\n\n### 模拟与分析算法\n对于四个测试用例中的每一个，执行以下过程：\n1.  初始化状态 $x_0 = (q_0, p_0)$、模拟参数（$\\Delta t, N_{\\text{steps}}, \\varepsilon$）以及系统属性（$m$，势参数）。\n2.  选择合适的积分器 $\\Phi_{\\Delta t}$ 和梯度函数 $\\nabla V(q)$。\n3.  初始化一个变量 `max_deviation = 0`。\n4.  对 $n$ 从 $0$ 到 $N_{\\text{steps}}-1$ 进行循环：\n    a. 在当前状态 $x_n$，使用中心有限差分公式构建雅可比矩阵 $D\\Phi_{\\Delta t}(x_n)$。\n    b. 计算其行列式 $J_n = \\det(D\\Phi_{\\Delta t}(x_n))$。\n    c. 用 $\\max(\\text{max\\_deviation}, |J_n - 1|)$ 更新 `max_deviation`。\n    d. 将状态推进到下一步：$x_{n+1} = \\Phi_{\\Delta t}(x_n)$。\n5.  循环终止后，`max_deviation` 的最终值即为该测试用例的结果。\n\n预期结果是，对于辛积分器速度Verlet（用例 1 和 3），计算出的偏差将处于机器精度的量级，这是由浮点运算和有限差分近似误差造成的。对于非辛的 RK4 和前向欧拉积分器（用例 2 和 4），预计偏差会大得多，这反映了这些算法固有的体积扭曲性质。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# --- Potential Gradients ---\n\ndef harmonic_gradient(q, k):\n    \"\"\"Gradient of the 1D harmonic potential.\"\"\"\n    return k * q\n\ndef coupled_harmonic_gradient(q, k, alpha):\n    \"\"\"Gradient of the 2D coupled harmonic potential.\"\"\"\n    q1, q2 = q\n    grad1 = k * q1 + alpha * q2\n    grad2 = k * q2 + alpha * q1\n    return np.array([grad1, grad2])\n\ndef quartic_gradient(q, k, lam):\n    \"\"\"Gradient of the 1D quartic-plus-quadratic potential.\"\"\"\n    return k * q + lam * q**3\n\n# --- Numerical Integrators (One-Step Maps) ---\n\ndef velocity_verlet(x, N, dt, m, grad_V_func):\n    \"\"\"Velocity Verlet integrator for one time step.\"\"\"\n    q = x[:N]\n    p = x[N:]\n    \n    p_half = p - (dt / 2.0) * grad_V_func(q)\n    q_new = q + dt * p_half / m\n    p_new = p_half - (dt / 2.0) * grad_V_func(q_new)\n    \n    return np.concatenate((q_new, p_new))\n\ndef forward_euler(x, N, dt, m, grad_V_func):\n    \"\"\"Forward Euler integrator for one time step.\"\"\"\n    q = x[:N]\n    p = x[N:]\n    \n    q_new = q + dt * p / m\n    p_new = p - dt * grad_V_func(q)\n    \n    return np.concatenate((q_new, p_new))\n\ndef rk4(x, N, dt, m, grad_V_func):\n    \"\"\"Classical fourth-order Runge-Kutta integrator for one time step.\"\"\"\n    \n    def f(state):\n        _q = state[:N]\n        _p = state[N:]\n        return np.concatenate((_p / m, -grad_V_func(_q)))\n\n    k1 = dt * f(x)\n    k2 = dt * f(x + 0.5 * k1)\n    k3 = dt * f(x + 0.5 * k2)\n    k4 = dt * f(x + k3)\n    \n    x_new = x + (k1 + 2*k2 + 2*k3 + k4) / 6.0\n    return x_new\n\n# --- Jacobian Estimation ---\n\ndef estimate_jacobian_determinant(one_step_map, x, N, eps):\n    \"\"\"\n    Estimates the Jacobian determinant of a one-step map using central finite differences.\n    - one_step_map: A function representing the integrator, Phi_dt(x).\n    - x: The current state vector [q, p].\n    - N: The number of spatial dimensions.\n    - eps: The finite difference perturbation size.\n    \"\"\"\n    dim = 2 * N\n    jacobian_matrix = np.zeros((dim, dim))\n    \n    for j in range(dim):\n        x_plus = x.copy()\n        x_minus = x.copy()\n        \n        x_plus[j] += eps\n        x_minus[j] -= eps\n        \n        phi_plus = one_step_map(x_plus)\n        phi_minus = one_step_map(x_minus)\n        \n        # This is the j-th column of the Jacobian\n        jacobian_matrix[:, j] = (phi_plus - phi_minus) / (2.0 * eps)\n        \n    return np.linalg.det(jacobian_matrix)\n\n# --- Simulation Runner ---\n\ndef run_simulation(case):\n    \"\"\"\n    Runs a single simulation case and computes the max Jacobian determinant deviation.\n    \"\"\"\n    N = case['N']\n    m = np.array(case['m'])\n    q0 = np.array(case['q0'])\n    p0 = np.array(case['p0'])\n    dt = case['dt']\n    n_steps = case['n_steps']\n    eps = case['eps']\n    \n    # Set up integrator function\n    integrators = {\n        'verlet': velocity_verlet,\n        'rk4': rk4,\n        'euler': forward_euler\n    }\n    integrator_func = integrators[case['integrator_name']]\n    \n    # Set up potential gradient function with its parameters\n    if case['potential_name'] == 'harmonic':\n        grad_V_func = lambda q: harmonic_gradient(q, k=case['params']['k'])\n    elif case['potential_name'] == 'coupled_harmonic':\n        grad_V_func = lambda q: coupled_harmonic_gradient(q, k=case['params']['k'], alpha=case['params']['alpha'])\n    elif case['potential_name'] == 'quartic':\n        grad_V_func = lambda q: quartic_gradient(q, k=case['params']['k'], lam=case['params']['lambda'])\n\n    # Create the one-step map as a function of state only\n    one_step_map = lambda state: integrator_func(state, N, dt, m, grad_V_func)\n\n    # Main simulation loop\n    x = np.concatenate((q0, p0))\n    max_deviation = 0.0\n    \n    for _ in range(n_steps):\n        # Estimate Jacobian determinant at the current state x\n        J_n = estimate_jacobian_determinant(one_step_map, x, N, eps)\n        \n        # Update max deviation\n        deviation = abs(J_n - 1.0)\n        if deviation > max_deviation:\n            max_deviation = deviation\n            \n        # Advance the state for the next step\n        x = one_step_map(x)\n        \n    return max_deviation\n\n# --- Main Solver ---\ndef solve():\n    \"\"\"\n    Defines and runs the test cases specified in the problem statement.\n    \"\"\"\n    test_cases = [\n        {\n            'N': 1, 'm': [1.0], 'potential_name': 'harmonic', 'params': {'k': 1.0},\n            'integrator_name': 'verlet', 'dt': 0.01, 'n_steps': 1000,\n            'q0': [1.0], 'p0': [0.0], 'eps': 1e-8\n        },\n        {\n            'N': 1, 'm': [1.0], 'potential_name': 'harmonic', 'params': {'k': 1.0},\n            'integrator_name': 'rk4', 'dt': 0.05, 'n_steps': 200,\n            'q0': [1.0], 'p0': [0.0], 'eps': 1e-8\n        },\n        {\n            'N': 2, 'm': [1.0, 1.0], 'potential_name': 'coupled_harmonic', 'params': {'k': 1.0, 'alpha': 0.1},\n            'integrator_name': 'verlet', 'dt': 0.01, 'n_steps': 500,\n            'q0': [0.5, -0.5], 'p0': [0.0, 0.0], 'eps': 1e-8\n        },\n        {\n            'N': 1, 'm': [1.0], 'potential_name': 'quartic', 'params': {'k': 1.0, 'lambda': 0.5},\n            'integrator_name': 'euler', 'dt': 0.01, 'n_steps': 300,\n            'q0': [0.2], 'p0': [0.5], 'eps': 1e-8\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_simulation(case)\n        results.append(result)\n\n    # Format the output as specified\n    print(f\"[{','.join(f'{r:.16f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "掌握了理论基础和计算工具后，我们便可以将它们应用于一个具有深刻物理意义的模型：双势阱系统，这是理解化学反应动力学的经典范例。在相空间中，势能面的结构决定了轨迹的命运，其中存在着被称为“分界线”（separatrix）的关键边界，它将不同类型的动力学行为（如在单个阱内振动或在两阱之间穿越）分隔开来。本练习引导您通过分析和模拟来描绘这一相空间“地图”，从而将抽象的相空间几何与化学反应中的反应坐标、过渡态等具体概念联系起来，并培养对复杂动力学中初始条件敏感性的直观认识。",
            "id": "3435429",
            "problem": "考虑一个单位质量的经典粒子，在一维空间中的对称双势阱中根据哈密顿动力学运动。哈密顿量为 $H(x,p) = \\dfrac{p^2}{2} + V(x)$，其中质量 $m=1$，势为 $V(x) = \\dfrac{(x^2 - 1)^2}{4}$。所有量均为无量纲；不使用物理单位。运动方程源于牛顿第二定律和哈密顿方程，即 $\\dot{x} = \\dfrac{\\partial H}{\\partial p}$ 和 $\\dot{p} = -\\dfrac{\\partial H}{\\partial x}$。相空间分界线将始终束缚在单个势阱中的初始条件与在两个势阱之间穿梭的初始条件分开。您的目标是根据基本原理确定分界线，然后数值上描绘出跨越此边界的轨迹作为初始条件的函数的长期演化归宿。\n\n任务：\n- 从定义出发，通过 $V'(x) = 0$ 确定 $V(x)$ 的驻点，通过 $V''(x)$ 判断其稳定性，并利用不稳定驻点处的哈密顿量来定义分界线能量 $E_{\\mathrm{sep}}$，从而确定相空间分界线能量。不要使用任何已知的或简便的公式；直接从 $V(x)$ 确定驻点及其性质。\n- 基于基本原理（例如，从哈密顿方程推导的速度-Verlet格式）实现一个辛时间积分器，以从指定的初始条件 $(x_0,p_0)$ 出发，在长时间内演化轨迹。使用固定时间步长 $\\Delta t = 10^{-3}$ 并积分至总时间 $T = 200$。\n- 对每条轨迹，仅根据模拟的时间序列对其长期演化归宿进行如下分类。设 $f_L$ 为 $x(t)  0$ 的步数比例，$f_R$ 为 $x(t) > 0$ 的步数比例，忽略 $|x(t)|$ 位于分界线坐标 $x=0$ 附近的一个小缓冲区域 $\\delta_x = 10^{-3}$ 内的步数。如果轨迹停留在鞍点的一个微小邻域内（通过 $\\max_t |x(t)|  \\delta_x$ 和 $\\max_t |p(t)|  \\delta_p$ 检测，其中 $\\delta_p = 10^{-6}$），则将其分类为“卡在分界线上”。否则，如果 $f_L > 0.95$ 且 $f_R  0.05$，则分类为“束缚在左势阱”；如果 $f_R > 0.95$ 且 $f_L  0.05$，则分类为“束缚在右势阱”；否则分类为“在势阱间漫游”。\n- 将每条轨迹的分类编码为一个整数代码 $c$：束缚在左势阱 $c=-1$，束缚在右势阱 $c=+1$，漫游 $c=0$，卡在分界线上 $c=2$。\n\n测试集：\n模拟以下初始条件 $(x_0,p_0)$，表示为实数序对：\n$(-1.2,0.0)$、$(1.2,0.0)$、$(0.0,1.0)$、$(0.0,0.0)$、$(0.01,0.0)$、$(-0.01,0.0)$、$(0.01,0.2)$。\n这些案例共同探测了每个势阱中的理想路径束缚情况、越过势垒的漫游情况、精确的鞍点以及分界线两侧的近分界线敏感性。\n\n最终输出规范：\n您的程序应生成单行输出，其中包含测试集的分类结果，顺序与上面列出的一致，形式为用方括号括起来的逗号分隔的整数列表（例如 $[c_1,c_2,\\dots]$）。不应打印任何额外文本。所有计算均需按上文所述以无量纲形式进行。要求的输出是无单位的，并且只包含整数。本问题不涉及角度。唯一可接受的输出是布尔值、整数、浮点数或它们的列表；此处，要求的输出是一个整数列表。",
            "solution": "该问题要求对粒子在一维双势阱中的运动进行分析和数值模拟。解决方案分三步进行：首先，对系统的关键特征（如平衡点和分界线能量）进行解析表征；其次，制定合适的数值积分方案；第三，实现一个分类算法来确定轨迹的长期演化归宿。\n\n该系统由哈密顿量 $H(x,p) = \\frac{p^2}{2m} + V(x)$ 描述，其中质量 $m=1$，势为 $V(x) = \\frac{1}{4}(x^2 - 1)^2$。所有量均为无量纲。运动方程由哈密顿方程导出：\n$$ \\dot{x} = \\frac{\\partial H}{\\partial p} = \\frac{p}{m} = p $$\n$$ \\dot{p} = -\\frac{\\partial H}{\\partial x} = -\\frac{dV}{dx} $$\n\n首先，我们必须确定相空间分界线，它由不稳定平衡点（相空间中的鞍点）的能级定义。我们通过确定势 $V(x)$ 的驻点来找到平衡位置，在这些点上力 $F(x) = -V'(x)$ 为零。\n势为 $V(x) = \\frac{1}{4}(x^4 - 2x^2 + 1)$。\n其一阶导数为：\n$$ V'(x) = \\frac{d}{dx} \\left[ \\frac{1}{4}(x^4 - 2x^2 + 1) \\right] = \\frac{1}{4}(4x^3 - 4x) = x^3 - x $$\n令 $V'(x)=0$ 以寻找驻点：\n$$ x^3 - x = x(x^2 - 1) = x(x-1)(x+1) = 0 $$\n驻点位于 $x = -1$、$x = 0$ 和 $x = +1$。\n\n为了判断这些点的稳定性，我们考察势的二阶导数 $V''(x)$:\n$$ V''(x) = \\frac{d}{dx}(x^3 - x) = 3x^2 - 1 $$\n我们在每个驻点处计算 $V''(x)$ 的值：\n- 在 $x = -1$ 处：$V''(-1) = 3(-1)^2 - 1 = 2 > 0$。这表示一个局域势能极小值，对应于稳定平衡。\n- 在 $x = +1$ 处：$V''(+1) = 3(1)^2 - 1 = 2 > 0$。这也表示一个局域势能极小值，一个稳定平衡。\n- 在 $x = 0$ 处：$V''(0) = 3(0)^2 - 1 = -1  0$。这表示一个局域势能极大值，对应于不稳定平衡。\n\n分界线是穿过不稳定平衡点的轨迹。在相空间中，该点为 $(x,p) = (0,0)$，因为粒子在势垒顶峰必须处于静止状态。这条轨迹的能量定义了分界线能量 $E_{\\mathrm{sep}}$：\n$$ E_{\\mathrm{sep}} = H(0,0) = \\frac{0^2}{2} + V(0) = \\frac{(0^2 - 1)^2}{4} = \\frac{1}{4} = 0.25 $$\n总能量 $E  E_{\\mathrm{sep}}$ 的轨迹被限制在一个势阱中，而能量 $E > E_{\\mathrm{sep}}$ 的轨迹可以在两个势阱之间漫游。能量 $E = E_{\\mathrm{sep}}$ 的轨迹位于分界线本身。\n\n为了模拟轨迹，我们采用一个辛积分器，特别是速度-Verlet算法，该算法因其良好的能量守恒特性而非常适合哈密顿系统的长期积分。对于质量 $m=1$ 的粒子，该算法由位置的泰勒展开推导而来，对于一个时间步长 $\\Delta t$，包括以下步骤：\n1. 更新位置：$x(t + \\Delta t) = x(t) + p(t)\\Delta t + \\frac{1}{2} F(x(t)) \\Delta t^2$。\n2. 计算新位置处的力：$F(x(t + \\Delta t)) = -V'(x(t + \\Delta t))$。\n3. 更新动量：$p(t + \\Delta t) = p(t) + \\frac{1}{2} [F(x(t)) + F(x(t + \\Delta t))] \\Delta t$。\n此处，力为 $F(x) = -V'(x) = -(x^3 - x) = x - x^3$。模拟将从 $t=0$ 运行到 $T=200$，时间步长为 $\\Delta t = 10^{-3}$。\n\n最后，必须对每个由时间序列 $\\{x(t_i), p(t_i)\\}$ 表示的模拟轨迹进行分类。分类根据一套预定规则执行。\n首先，我们检查轨迹是否“卡”在鞍点 $(0,0)$。如果在整个模拟过程中，最大绝对位置和动量值低于指定的阈值：$\\max_t |x(t)|  \\delta_x$ 和 $\\max_t |p(t)|  \\delta_p$，其中 $\\delta_x = 10^{-3}$ 和 $\\delta_p = 10^{-6}$，则情况如此。若是，该轨迹被赋予代码 $c=2$。\n\n如果轨迹没有卡住，我们分析它在两个势阱中的分布。我们计算粒子在左势阱（$x(t)  0$）和右势阱（$x(t) > 0$）中花费的时间步数比例，忽略粒子位于原点周围的小缓冲区域内（即 $|x(t)| \\le \\delta_x$）的任何步数。设 $N_L$ 为 $x(t)  -\\delta_x$ 的步数计数，$N_R$ 为 $x(t) > \\delta_x$ 的步数计数。相关总步数为 $N_{total} = N_L + N_R$。那么比例为 $f_L = N_L / N_{total}$ 和 $f_R = N_R / N_{total}$。\n分类规则如下：\n- 束缚在左势阱 ($c=-1$)：如果 $f_L > 0.95$ 且 $f_R  0.05$。\n- 束缚在右势阱 ($c=+1$)：如果 $f_R > 0.95$ 且 $f_L  0.05$。\n- 漫游 ($c=0$)：其他情况。\n\n以下 Python 代码实现了这整个过程，将其应用于指定的初始条件组，并生成要求的输出格式。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of classifying trajectories in a double-well potential.\n    \"\"\"\n\n    def run_simulation(x0, p0, dt, T):\n        \"\"\"\n        Integrates a trajectory using the velocity-Verlet algorithm.\n        \n        Args:\n            x0 (float): Initial position.\n            p0 (float): Initial momentum.\n            dt (float): Time step.\n            T (float): Total integration time.\n\n        Returns:\n            tuple: A tuple containing arrays for the position and momentum trajectories.\n        \"\"\"\n        num_steps = int(T / dt)\n        x = float(x0)\n        p = float(p0)\n        \n        x_traj = np.zeros(num_steps + 1)\n        p_traj = np.zeros(num_steps + 1)\n        x_traj[0] = x\n        p_traj[0] = p\n        \n        def force(pos):\n            \"\"\"Calculates the force F(x) = -V'(x) = x - x^3.\"\"\"\n            return pos - pos**3\n\n        for i in range(num_steps):\n            F_current = force(x)\n            # Update position\n            x_next = x + p * dt + 0.5 * F_current * dt**2\n            # Update force\n            F_next = force(x_next)\n            # Update momentum\n            p_next = p + 0.5 * (F_current + F_next) * dt\n            \n            x = x_next\n            p = p_next\n            \n            x_traj[i+1] = x\n            p_traj[i+1] = p\n            \n        return x_traj, p_traj\n\n    def classify_trajectory(x_traj, p_traj):\n        \"\"\"\n        Classifies a trajectory based on its long-term behavior.\n\n        Args:\n            x_traj (np.array): Array of position values over time.\n            p_traj (np.array): Array of momentum values over time.\n\n        Returns:\n            int: Classification code (-1, 1, 0, or 2).\n        \"\"\"\n        delta_x = 1e-3\n        delta_p = 1e-6\n\n        # Rule 1: Check for separatrix-stuck condition\n        if np.max(np.abs(x_traj))  delta_x and np.max(np.abs(p_traj))  delta_p:\n            return 2\n\n        # Rules 2-4: Analyze well-trapping vs. roaming\n        # Ignore points within the buffer zone |x| = delta_x\n        relevant_x_points = x_traj[np.abs(x_traj) > delta_x]\n        \n        if relevant_x_points.size == 0:\n            # Trajectory stayed entirely within the x buffer but didn't meet the 'stuck'\n            # momentum requirement. This is an edge case, but most consistent to classify\n            # as roaming, as it is neither definitively left nor right trapped.\n            return 0\n            \n        count_L = np.sum(relevant_x_points  0)\n        count_R = np.sum(relevant_x_points > 0)\n        count_total = relevant_x_points.size\n\n        f_L = count_L / count_total\n        f_R = count_R / count_total\n\n        if f_L > 0.95 and f_R  0.05:\n            return -1  # Left-well trapped\n        elif f_R > 0.95 and f_L  0.05:\n            return 1   # Right-well trapped\n        else:\n            return 0   # Roaming\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (-1.2, 0.0),\n        (1.2, 0.0),\n        (0.0, 1.0),\n        (0.0, 0.0),\n        (0.01, 0.0),\n        (-0.01, 0.0),\n        (0.01, 0.2),\n    ]\n\n    # Simulation parameters\n    dt = 1e-3\n    T = 200.0\n\n    results = []\n    for x0, p0 in test_cases:\n        x_trajectory, p_trajectory = run_simulation(x0, p0, dt, T)\n        classification = classify_trajectory(x_trajectory, p_trajectory)\n        results.append(classification)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}