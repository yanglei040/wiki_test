{
    "hands_on_practices": [
        {
            "introduction": "At the heart of every molecular dynamics simulation lies the numerical integration of Newton's equations of motion. The velocity Verlet algorithm is a cornerstone of the field, prized for its time-reversibility and symplectic nature, which grants it excellent long-term energy stability. This first practice invites you to implement this fundamental integrator for the Morse potential, a realistic model for a diatomic bond, and to critically analyze how the choice of the timestep $\\Delta t$ affects the conservation of total energy . Mastering this relationship is the first step toward building stable and reliable simulations.",
            "id": "3401300",
            "problem": "Consider a single particle of mass $m$ moving in one spatial dimension under the Morse potential, a standard model for diatomic molecular vibrations. The Morse potential $V(r)$ is defined as\n$$\nV(r) = D_e \\left(1 - e^{-a (r - r_e)}\\right)^2,\n$$\nwhere $D_e$ is the well depth (in joules), $a$ is a range parameter (in $\\text{m}^{-1}$), and $r_e$ is the equilibrium bond length (in meters). The motion obeys Newton's second law, namely $m \\,\\ddot{r} = F(r)$ with $F(r) = -\\frac{dV}{dr}$, and energy $E(r, \\dot{r}) = \\frac{1}{2} m \\dot{r}^2 + V(r)$ is conserved for exact dynamics.\n\nYour task is to write a complete program that:\n- Implements the velocity Verlet integrator (without using external libraries beyond those permitted) to advance the dynamics in time for the above system.\n- Computes the fastest small-amplitude vibrational angular frequency $\\omega_{\\max}$ around the minimum of the Morse potential by using the curvature at the minimum,\n$$\n\\omega_{\\max} = \\sqrt{\\frac{k}{m}}, \\quad k = \\left.\\frac{d^2 V}{dr^2}\\right|_{r = r_e}.\n$$\n- Uses a set of timesteps $\\Delta t$ constructed as fractions $s$ of the fundamental period $T = \\frac{2\\pi}{\\omega_{\\max}}$, namely $\\Delta t = s\\,T$.\n- For each timestep, integrates the dynamics for a total duration equal to $N_{\\text{periods}}$ full periods, starting from initial position $r(0) = r_e + x_0$ and initial velocity $\\dot{r}(0) = 0$, with $x_0$ a small displacement to remain in the near-harmonic regime.\n- Reports, for each timestep, the maximum relative energy error attained during the integration, defined as\n$$\n\\varepsilon_{\\max} = \\max_{0 \\le t \\le N_{\\text{periods}} T} \\frac{\\left|E(t) - E(0)\\right|}{E(0)}.\n$$\n\nUse the following parameter values (in International System of Units):\n- $D_e = 3.0 \\,\\text{eV}$ converted to joules using $1\\,\\text{eV} = 1.602176634 \\times 10^{-19}\\,\\text{J}$, so that $D_e = 3.0 \\times 1.602176634 \\times 10^{-19}\\,\\text{J}$,\n- $a = 2.0 \\times 10^{10}\\,\\text{m}^{-1}$,\n- $r_e = 1.0 \\times 10^{-10}\\,\\text{m}$,\n- $m = 1.0 \\times 10^{-26}\\,\\text{kg}$,\n- $x_0 = 2.0 \\times 10^{-12}\\,\\text{m}$,\n- $N_{\\text{periods}} = 50$.\n\nTest suite specification (each test case is one $s$ value, which defines $\\Delta t = s\\,T$):\n- $s = 0.01$ (small timestep),\n- $s = 0.05$ (moderate timestep),\n- $s = 0.10$ (larger timestep),\n- $s = 0.20$ (near the limit of practical accuracy),\n- $s = \\frac{1.9}{2\\pi}$ (a boundary case close to the harmonic stability threshold $\\Delta t \\,\\omega \\approx 2$).\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list of floating-point numbers enclosed in square brackets, in the order of the test suite above. For example, the output should be formatted as $[x_1,x_2,x_3,x_4,x_5]$, where each $x_i$ is the maximum relative energy error $\\varepsilon_{\\max}$ for the corresponding $s$.\n- The reported values are dimensionless floats; no physical units are required in the output.",
            "solution": "The problem is valid as it is scientifically grounded in classical mechanics and computational physics, well-posed with a complete set of parameters and clear objectives, and formulated objectively. We can therefore proceed with a solution.\n\nThe motion of a particle of mass $m$ in one dimension is governed by the Morse potential $V(r)$, given by:\n$$\nV(r) = D_e \\left(1 - e^{-a (r - r_e)}\\right)^2\n$$\nHere, $D_e$ is the potential well depth, $a$ is a parameter controlling the width of the potential, and $r_e$ is the equilibrium position corresponding to the potential minimum.\n\nThe force $F(r)$ acting on the particle is the negative gradient of the potential energy:\n$$\nF(r) = -\\frac{dV}{dr}\n$$\nUsing the chain rule, with $u(r) = 1 - e^{-a(r-r_e)}$, we have $\\frac{dV}{dr} = \\frac{d(D_e u^2)}{du} \\frac{du}{dr}$.\nThe derivatives are $\\frac{d(D_e u^2)}{du} = 2D_e u = 2D_e(1 - e^{-a(r-r_e)})$ and $\\frac{du}{dr} = -e^{-a(r-r_e)}(-a) = a e^{-a(r-r_e)}$.\nCombining these gives:\n$$\n\\frac{dV}{dr} = 2a D_e \\left(1 - e^{-a(r-r_e)}\\right) e^{-a(r-r_e)}\n$$\nThus, the force is:\n$$\nF(r) = -2a D_e \\left(1 - e^{-a(r-r_e)}\\right) e^{-a(r-r_e)} = -2a D_e \\left(e^{-a(r-r_e)} - e^{-2a(r-r_e)}\\right)\n$$\n\nFor small displacements around the equilibrium position $r_e$, the potential can be approximated by a harmonic potential $V(r) \\approx \\frac{1}{2} k (r-r_e)^2$, where $k$ is the spring constant. The spring constant is determined by the curvature of the potential at the minimum:\n$$\nk = \\left.\\frac{d^2 V}{dr^2}\\right|_{r = r_e}\n$$\nDifferentiating the expression for $\\frac{dV}{dr}$:\n$$\n\\frac{d^2 V}{dr^2} = \\frac{d}{dr} \\left[ 2a D_e \\left(e^{-a(r-r_e)} - e^{-2a(r-r_e)}\\right) \\right] = 2a D_e \\left( -a e^{-a(r-r_e)} - (-2a) e^{-2a(r-r_e)} \\right)\n$$\n$$\n\\frac{d^2 V}{dr^2} = 2a^2 D_e \\left( 2e^{-2a(r-r_e)} - e^{-a(r-r_e)} \\right)\n$$\nEvaluating this at $r=r_e$:\n$$\nk = 2a^2 D_e \\left( 2e^0 - e^0 \\right) = 2a^2 D_e (2 - 1) = 2a^2 D_e\n$$\nThe angular frequency of small-amplitude oscillations is then:\n$$\n\\omega_{\\max} = \\sqrt{\\frac{k}{m}} = \\sqrt{\\frac{2a^2 D_e}{m}} = a\\sqrt{\\frac{2D_e}{m}}\n$$\nThe corresponding period of oscillation is $T = \\frac{2\\pi}{\\omega_{\\max}}$.\n\nTo simulate the dynamics, we employ the velocity Verlet integration algorithm. This is a time-reversible and symplectic integrator, which leads to good conservation of total energy over long simulation times. For a given timestep $\\Delta t$, the position $r$, velocity $v$, and acceleration $acc = F/m$ are updated as follows:\n1. Update position: $r(t + \\Delta t) = r(t) + v(t)\\Delta t + \\frac{1}{2} acc(t) (\\Delta t)^2$\n2. Calculate new force and acceleration: $F(t+\\Delta t)=F(r(t+\\Delta t))$ and $acc(t+\\Delta t) = F(t+\\Delta t)/m$.\n3. Update velocity: $v(t + \\Delta t) = v(t) + \\frac{1}{2} \\left[ acc(t) + acc(t+\\Delta t) \\right] \\Delta t$\n\nThe simulation starts from the initial conditions $r(0) = r_e + x_0$ and $\\dot{r}(0) = v(0) = 0$. The initial total energy $E(0)$ is purely potential energy:\n$$\nE(0) = \\frac{1}{2} m v(0)^2 + V(r(0)) = V(r_e + x_0) = D_e \\left(1 - e^{-a x_0}\\right)^2\n$$\nThe simulation runs for a total duration of $N_{\\text{periods}}T$, using a timestep $\\Delta t = sT$. The number of integration steps is therefore $N_{\\text{steps}} = \\frac{N_{\\text{periods}} T}{sT} = \\frac{N_{\\text{periods}}}{s}$. At each step $i$, we compute the total energy $E(t_i) = \\frac{1}{2} m v(t_i)^2 + V(r(t_i))$ and the relative energy error $\\varepsilon_i = \\frac{|E(t_i) - E(0)|}{E(0)}$. The final reported quantity is the maximum relative error observed throughout the simulation:\n$$\n\\varepsilon_{\\max} = \\max_{i} \\varepsilon_i\n$$\n\nThe procedure for each given value of $s$ is:\n1. Calculate the constants $k$, $\\omega_{\\max}$, and $T$.\n2. Determine the timestep $\\Delta t = sT$ and the total number of steps $N_{\\text{steps}} = \\text{round}(N_{\\text{periods}}/s)$.\n3. Initialize position $r$, velocity $v$, and acceleration $acc$ according to the initial conditions. Compute the initial energy $E(0)$.\n4. Loop for $N_{\\text{steps}}$ iterations, applying the velocity Verlet update rules at each step.\n5. In each iteration, calculate the current energy $E(t)$ and update the maximum observed relative error $\\varepsilon_{\\max}$.\n6. After the loop, the final value of $\\varepsilon_{\\max}$ is the result for the given $s$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the molecular dynamics problem for a particle in a Morse potential\n    using the velocity Verlet integrator and calculates the maximum relative\n    energy error for different timesteps.\n    \"\"\"\n\n    # --- Problem Parameters (SI units) ---\n    EV_TO_JOULE = 1.602176634e-19\n    D_e = 3.0 * EV_TO_JOULE  # Well depth (J)\n    a = 2.0e10               # Range parameter (m^-1)\n    r_e = 1.0e-10            # Equilibrium distance (m)\n    m = 1.0e-26              # Mass (kg)\n    x_0 = 2.0e-12            # Initial displacement (m)\n    N_periods = 50.0         # Number of periods to simulate\n\n    # --- Test Suite ---\n    # Each value 's' defines a timestep dt = s * T\n    s_values = [0.01, 0.05, 0.10, 0.20, 1.9 / (2 * np.pi)]\n\n    # --- Helper Functions for Physics ---\n    def potential(r, D_e_val, a_val, r_e_val):\n        \"\"\"Calculates the Morse potential energy.\"\"\"\n        return D_e_val * (1.0 - np.exp(-a_val * (r - r_e_val)))**2\n\n    def force(r, D_e_val, a_val, r_e_val):\n        \"\"\"Calculates the force derived from the Morse potential.\"\"\"\n        # This form is slightly more efficient as it computes exp once.\n        # F(r) = -2*a*D_e * (exp(-a(r-re)) - exp(-2a(r-re)))\n        exp_term = np.exp(-a_val * (r - r_e_val))\n        return -2.0 * a_val * D_e_val * (exp_term - exp_term**2)\n\n    def total_energy(r, v, m_val, D_e_val, a_val, r_e_val):\n        \"\"\"Calculates the total energy (kinetic + potential).\"\"\"\n        kinetic = 0.5 * m_val * v**2\n        potential_e = potential(r, D_e_val, a_val, r_e_val)\n        return kinetic + potential_e\n\n    # --- Derived Harmonic Quantities ---\n    # Stiffness k = d^2V/dr^2 at r=r_e\n    k = 2.0 * a**2 * D_e\n    # Harmonic angular frequency omega_max = sqrt(k/m)\n    omega_max = np.sqrt(k / m)\n    # Harmonic period T = 2*pi / omega_max\n    T = 2.0 * np.pi / omega_max\n\n    results = []\n\n    # --- Main Loop over Test Cases ---\n    for s in s_values:\n        # --- Simulation Setup ---\n        dt = s * T\n        num_steps = int(round(N_periods / s))\n\n        # --- Initial Conditions ---\n        r = r_e + x_0\n        v = 0.0\n        acc = force(r, D_e, a, r_e) / m\n\n        # --- Initial Energy Calculation ---\n        E0 = total_energy(r, v, m, D_e, a, r_e)\n        if E0 == 0:\n            # This case should not be reached with the given parameters\n            # but is a safeguard against division by zero.\n            max_rel_error = 0.0\n        else:\n            max_rel_error = 0.0\n\n            # --- Velocity Verlet Integration Loop ---\n            for _ in range(num_steps):\n                # 1. Update position\n                r = r + v * dt + 0.5 * acc * dt**2\n                \n                # 2. Calculate new force and acceleration\n                acc_new = force(r, D_e, a, r_e) / m\n                \n                # 3. Update velocity\n                v = v + 0.5 * (acc + acc_new) * dt\n                \n                # Update acceleration for the next step\n                acc = acc_new\n\n                # 4. Calculate energy drift\n                E_t = total_energy(r, v, m, D_e, a, r_e)\n                rel_error = np.abs((E_t - E0) / E0)\n                \n                # 5. Update maximum relative error\n                if rel_error > max_rel_error:\n                    max_rel_error = rel_error\n\n        results.append(max_rel_error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{err:.15e}' for err in results)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "While free dynamics form a theoretical baseline, practical molecular models often employ holonomic constraints, such as fixed bond lengths, to eliminate stiff, high-frequency vibrations and allow for larger timesteps. This introduces a significant challenge: how does one correctly evolve a system confined to a specific submanifold in phase space? This exercise  guides you through a comparison of the rigorous, continuous-time solution provided by the Dirac bracket formalism against the workhorse discrete-time algorithms, SHAKE and RATTLE, used in modern simulation packages. By analyzing their geometric properties and computational trade-offs, you will gain a deep appreciation for why methods like RATTLE, which preserve the symplectic structure, are essential for stable and accurate constrained dynamics.",
            "id": "3401341",
            "problem": "Consider a classical two-particle system in three spatial dimensions with positions $r_1 \\in \\mathbb{R}^3$, $r_2 \\in \\mathbb{R}^3$, canonical momenta $p_1 \\in \\mathbb{R}^3$, $p_2 \\in \\mathbb{R}^3$, and masses $m_1>0$, $m_2>0$. Let the Hamiltonian be $H(r_1,r_2,p_1,p_2)=\\frac{\\lVert p_1\\rVert^2}{2 m_1}+\\frac{\\lVert p_2\\rVert^2}{2 m_2}+U(r_1,r_2)$, where $U$ is a smooth potential that does not depend on time. Impose a holonomic constraint that fixes the interatomic distance at a constant $a>0$, namely $\\phi(r_1,r_2)=\\lVert r_1-r_2\\rVert^2-a^2=0$. Let $R=r_1-r_2$ and define the secondary (velocity-level) constraint $\\psi(r_1,r_2,p_1,p_2)=R\\cdot\\left(\\frac{p_1}{m_1}-\\frac{p_2}{m_2}\\right)=0$, which is required to ensure the constraint manifold is invariant under the dynamics.\n\nIn the Dirac constrained Hamiltonian framework, define the set of second-class constraints $\\chi_1=\\phi$, $\\chi_2=\\psi$, the standard canonical Poisson bracket $\\{f,g\\}=\\sum_{i=1}^{2}\\left(\\frac{\\partial f}{\\partial r_i}\\cdot\\frac{\\partial g}{\\partial p_i}-\\frac{\\partial f}{\\partial p_i}\\cdot\\frac{\\partial g}{\\partial r_i}\\right)$, the $2\\times 2$ constraint matrix $C_{ij}=\\{\\chi_i,\\chi_j\\}$, and the Dirac bracket $\\{f,g\\}_D=\\{f,g\\}-\\{f,\\chi_i\\}(C^{-1})_{ij}\\{\\chi_j,g\\}$, where repeated indices are summed. The exact constrained continuous-time evolution is generated by $H$ using $\\{\\cdot,\\cdot\\}_D$, and preserves $\\phi=0$ and $\\psi=0$ for all time.\n\nIn computational molecular dynamics, the SHAKE algorithm is a position-correction method that enforces holonomic constraints at discrete time steps by iteratively adjusting positions to satisfy $\\phi=0$ after an unconstrained update. The RATTLE algorithm augments SHAKE by additionally correcting velocities so that both position and velocity-level constraints are satisfied at the end of each step when used, for example, in combination with velocity Verlet integration.\n\nUsing first principles of Hamiltonian mechanics, constrained dynamics, and the definitions above, analyze the geometric and computational properties of Dirac-bracket evolution versus SHAKE and RATTLE for the diatomic constraint described. Which of the following statements are correct?\n\nA. Under the fixed-bond constraint, Dirac-bracket evolution projects the relative momentum onto the tangent space of the constraint manifold, exactly removing the radial component, and preserves the constrained symplectic form; consequently, for time-independent $H$, the continuous-time energy is conserved exactly.\n\nB. In the standard position-only SHAKE correction applied with velocity Verlet integration, the holonomic constraint $\\phi=0$ is satisfied at discrete times, but the secondary constraint $\\psi=0$ is not generally enforced; hence radial momentum components can remain nonzero and are only indirectly reduced by subsequent position corrections.\n\nC. The RATTLE algorithm, when constraints are solved to machine precision at each step, yields a symplectic and time-reversible discrete map for holonomic constraints; therefore it exhibits bounded long-time energy error but does not conserve energy exactly.\n\nD. Computing the Dirac bracket for this diatomic constraint requires inverting a $6\\times 6$ matrix at every step, making it asymptotically more expensive than SHAKE and RATTLE even when there is only a single bond-length constraint.\n\nE. For the diatomic constraint, the Dirac matrix reduces to a scalar, so both Dirac-bracket evolution and RATTLE compute the same Lagrange multiplier, implying these methods are algebraically equivalent and produce identical discrete trajectories for any time step.\n\nSelect all that apply.",
            "solution": "The problem statement has been validated and found to be scientifically grounded, well-posed, and objective. It presents a standard scenario in advanced classical mechanics and computational molecular dynamics, with all terms and formalisms correctly defined. We may proceed with the analysis.\n\nThe system is described by the Hamiltonian $H=\\frac{\\lVert p_1\\rVert^2}{2 m_1}+\\frac{\\lVert p_2\\rVert^2}{2 m_2}+U(r_1,r_2)$ subject to a set of second-class constraints $\\chi_1 = \\phi(r_1,r_2)=\\lVert r_1-r_2\\rVert^2-a^2=0$ and $\\chi_2 = \\psi(r_1,r_2,p_1,p_2)=R\\cdot\\left(\\frac{p_1}{m_1}-\\frac{p_2}{m_2}\\right)=0$, where $R=r_1-r_2$. The constraint $\\chi_2 = 0$ arises from the requirement that $\\chi_1$ be conserved by the time evolution, i.e., $\\dot{\\chi}_1 = \\{\\chi_1, H\\} = 0$. A direct calculation yields:\n$$\n\\{\\chi_1, H\\} = \\left\\{ \\lVert R \\rVert^2, \\frac{\\lVert p_1\\rVert^2}{2 m_1} + \\frac{\\lVert p_2\\rVert^2}{2 m_2} \\right\\} = \\sum_{k=1}^2 \\frac{\\partial \\lVert R \\rVert^2}{\\partial r_k} \\cdot \\frac{\\partial T}{\\partial p_k} = (2R) \\cdot \\frac{p_1}{m_1} + (-2R) \\cdot \\frac{p_2}{m_2} = 2 R \\cdot \\left(\\frac{p_1}{m_1}-\\frac{p_2}{m_2}\\right) = 2\\chi_2\n$$\nFor $\\dot{\\chi}_1=0$, we must enforce $\\chi_2=0$. The constraints $(\\chi_1, \\chi_2)$ are second-class because their Poisson bracket matrix $C_{ij} = \\{\\chi_i, \\chi_j\\}$ is invertible. The elements are $C_{11}=\\{\\chi_1, \\chi_1\\}=0$, $C_{22}=\\{\\chi_2, \\chi_2\\}=0$, and\n$$\nC_{12} = \\{\\chi_1, \\chi_2\\} = \\left\\{ \\lVert R \\rVert^2, R \\cdot \\left(\\frac{p_1}{m_1}-\\frac{p_2}{m_2}\\right) \\right\\} = \\sum_{k=1}^2 \\frac{\\partial \\chi_1}{\\partial r_k} \\cdot \\frac{\\partial \\chi_2}{\\partial p_k} = (2R) \\cdot \\frac{R}{m_1} + (-2R) \\cdot \\left(-\\frac{R}{m_2}\\right) = 2 \\lVert R \\rVert^2 \\left(\\frac{1}{m_1}+\\frac{1}{m_2}\\right)\n$$\nOn the constraint manifold $\\lVert R \\rVert^2 = a^2$, so $C_{12} = 2 a^2 (\\frac{1}{m_1}+\\frac{1}{m_2})$. Since $m_1, m_2, a > 0$, $C_{12} \\neq 0$. The determinant of $C = \\begin{pmatrix} 0 & C_{12} \\\\ -C_{12} & 0 \\end{pmatrix}$ is $C_{12}^2 \\neq 0$, so $C$ is invertible.\n\nNow we analyze each option.\n\n**A. Under the fixed-bond constraint, Dirac-bracket evolution projects the relative momentum onto the tangent space of the constraint manifold, exactly removing the radial component, and preserves the constrained symplectic form; consequently, for time-independent $H$, the continuous-time energy is conserved exactly.**\nThe constraint $\\chi_1 = \\lVert R \\rVert^2 - a^2 = 0$ defines a sphere of radius $a$ in the relative coordinate space. The tangent space to this manifold at a point $R$ is the set of vectors orthogonal to $R$. The constraint $\\chi_2=R\\cdot(\\dot{r}_1-\\dot{r}_2)=R\\cdot\\dot{R}=0$ explicitly states that the relative velocity vector, $\\dot{R}$, is orthogonal to the relative position vector $R$. This means $\\dot{R}$ lies in the tangent space. Since relative momentum is proportional to relative velocity ($p_{rel} = \\mu \\dot{R}$, where $\\mu$ is the reduced mass), this constraint enforces that the radial component of relative momentum is zero. The Dirac-bracket formalism, by construction, generates dynamics that respect all second-class constraints at all times. So the first part of the statement is correct.\nThe Dirac bracket defines a Poisson structure on the constrained submanifold. The associated non-degenerate $2$-form is a symplectic form, and the time evolution according to $\\dot{F}=\\{F,H\\}_D$ is a Hamiltonian flow that preserves this constrained symplectic form. This is a fundamental result of the Dirac formalism. So the second part is correct.\nFor a time-independent Hamiltonian $H$, the change in energy is given by $\\frac{dH}{dt} = \\{H, H\\}_D$. Using the definition of the Dirac bracket, $\\{f,g\\}_D = \\{f,g\\} - \\{f,\\chi_i\\}(C^{-1})_{ij}\\{\\chi_j,g\\}$:\n$$\n\\{H, H\\}_D = \\{H,H\\} - \\{H,\\chi_i\\}(C^{-1})_{ij}\\{\\chi_j,H\\}\n$$\nThe first term $\\{H,H\\}=0$. The expression is therefore:\n$$\n\\{H, H\\}_D = - \\begin{pmatrix} \\{H, \\chi_1\\} & \\{H, \\chi_2\\} \\end{pmatrix} \\frac{1}{C_{12}} \\begin{pmatrix} 0 & -1 \\\\ 1 & 0 \\end{pmatrix} \\begin{pmatrix} \\{\\chi_1, H\\} \\\\ \\{\\chi_2, H\\} \\end{pmatrix}\n$$\nUsing $\\{H, \\chi_j\\} = -\\{\\chi_j, H\\}$, this becomes:\n$$\n\\{H, H\\}_D = - \\frac{1}{C_{12}} \\begin{pmatrix} -\\{\\chi_1, H\\} & -\\{\\chi_2, H\\} \\end{pmatrix} \\begin{pmatrix} -\\{\\chi_2, H\\} \\\\ \\{\\chi_1, H\\} \\end{pmatrix} = -\\frac{1}{C_{12}} ( \\{\\chi_1, H\\}\\{\\chi_2, H\\} - \\{\\chi_2, H\\}\\{\\chi_1, H\\} ) = 0\n$$\nThus, $\\frac{dH}{dt}=0$, and energy is conserved exactly. All parts of the statement are consistent with the principles of Hamiltonian mechanics.\n**Verdict: Correct.**\n\n**B. In the standard position-only SHAKE correction applied with velocity Verlet integration, the holonomic constraint $\\phi=0$ is satisfied at discrete times, but the secondary constraint $\\psi=0$ is not generally enforced; hence radial momentum components can remain nonzero and are only indirectly reduced by subsequent position corrections.**\nThe velocity Verlet algorithm involves the sequence:\n1. Update positions: $r(t+\\Delta t) = r(t) + v(t)\\Delta t + \\frac{1}{2}a(t)(\\Delta t)^2$.\n2. Apply SHAKE: Modify $r(t+\\Delta t)$ to $r'(t+\\Delta t)$ such that $\\phi(r'(t+\\Delta t))=0$.\n3. Compute new forces/accelerations: $a'(t+\\Delta t) = F(r'(t+\\Delta t))/m$.\n4. Update velocities: $v'(t+\\Delta t) = v(t) + \\frac{1}{2}(a(t)+a'(t+\\Delta t))\\Delta t$.\nThe key point is that SHAKE corrects only the positions. The velocities are then computed using the standard Verlet formula based on accelerations at times $t$ and $t+\\Delta t$. There is no step in this procedure that explicitly projects the velocities $v'(t+\\Delta t)$ to satisfy the velocity-level constraint $\\psi(t+\\Delta t) = R'(t+\\Delta t) \\cdot (\\frac{p'_1(t+\\Delta t)}{m_1} - \\frac{p'_2(t+\\Delta t)}{m_2}) = 0$. Because this condition is not enforced, the radial component of the relative velocity (and momentum) is generally non-zero at the end of a step. While enforcing $\\phi(t)=0$ and $\\phi(t+\\Delta t)=0$ implies that the time-averaged radial velocity over the interval must be very small, it does not guarantee that the instantaneous radial velocity at $t+\\Delta t$ is zero. The subsequent SHAKE correction at $t+2\\Delta t$ will prevent the particles from flying apart, thus \"indirectly reducing\" the effect of any radial velocity, but it does not eliminate it at each step. This deficiency is precisely what the RATTLE algorithm was designed to fix.\n**Verdict: Correct.**\n\n**C. The RATTLE algorithm, when constraints are solved to machine precision at each step, yields a symplectic and time-reversible discrete map for holonomic constraints; therefore it exhibits bounded long-time energy error but does not conserve energy exactly.**\nThe RATTLE algorithm extends SHAKE by adding a second correction step. After the SHAKE position correction and the first half-step of the velocity update, RATTLE performs a velocity correction to enforce the velocity-level constraint $\\psi=0$. The full velocity Verlet with RATTLE is:\n1. Velocity half-step: $v(t+\\Delta t/2) = v(t) + \\frac{1}{2}a(t)\\Delta t$.\n2. Position full-step: $r(t+\\Delta t) = r(t) + v(t+\\Delta t/2)\\Delta t$.\n3. Position correction (SHAKE part): Solve for Lagrange multipliers to adjust $r(t+\\Delta t)$ to satisfy $\\phi(t+\\Delta t)=0$.\n4. Velocity correction (RATTLE part): The half-step velocities $v(t+\\Delta t/2)$ are inconsistent with the corrected positions. One first computes the final velocities without the constraint force contribution, and then solves for another set of Lagrange multipliers to project the final velocities to satisfy $\\psi(t+\\Delta t)=0.\nThis algorithm is a geometric integrator. It is known from the literature of numerical analysis of differential equations that RATTLE is a symplectic integrator. This means it exactly preserves a discrete analogue of the symplectic $2$-form on the constrained phase space. It is also constructed symmetrically in time, which makes it time-reversible. A fundamental property of symplectic integrators when applied to Hamiltonian systems is that they do not exactly conserve the original Hamiltonian $H$. Instead, they exactly conserve a modified, or \"shadow,\" Hamiltonian $H'$ that is close to $H$. This ensures that the error in the original energy, $H(t)-H(0)$, remains bounded over very long simulation times, rather than exhibiting a secular drift. Thus, RATTLE provides excellent long-term stability at the cost of not conserving energy exactly.\n**Verdict: Correct.**\n\n**D. Computing the Dirac bracket for this diatomic constraint requires inverting a $6\\times 6$ matrix at every step, making it asymptotically more expensive than SHAKE and RATTLE even when there is only a single bond-length constraint.**\nThe calculation of the Dirac bracket $\\{f,g\\}_D = \\{f,g\\} - \\{f,\\chi_i\\}(C^{-1})_{ij}\\{\\chi_j,g\\}$ requires the inversion of the constraint matrix $C_{ij} = \\{\\chi_i, \\chi_j\\}$. The size of this matrix is determined by the number of second-class constraints. For the given problem, we have two second-class constraints, $\\chi_1 = \\phi$ and $\\chi_2 = \\psi$. Therefore, the indices $i,j$ run from $1$ to $2$, and $C$ is a $2 \\times 2$ matrix. The premise that a $6 \\times 6$ matrix must be inverted is false. The number $6$ likely stems from a confusion with the number of position coordinates ($2$ particles $\\times$ $3$ dimensions). Since the premise is false, the conclusion about the relative computational cost is unfounded. Inverting a $2 \\times 2$ matrix is computationally trivial.\n**Verdict: Incorrect.**\n\n**E. For the diatomic constraint, the Dirac matrix reduces to a scalar, so both Dirac-bracket evolution and RATTLE compute the same Lagrange multiplier, implying these methods are algebraically equivalent and produce identical discrete trajectories for any time step.**\nThis statement contains several errors. First, as established in the analysis of option D, the constraint matrix $C$ (the \"Dirac matrix\") is a $2 \\times 2$ matrix, not a scalar. Second, Dirac-bracket evolution is a formalism for the exact, *continuous-time* dynamics. RATTLE is an algorithm that generates an approximate *discrete-time* trajectory. A discrete-time approximation cannot be algebraically equivalent to the exact continuous solution for any finite time step $\\Delta t > 0$. The trajectory from RATTLE only converges to the exact trajectory in the limit $\\Delta t \\to 0$. Third, while both methods use Lagrange multipliers conceptually, the multipliers in the continuous formalism are functions of the continuous phase-space variables, while the multipliers in RATTLE are numerical values calculated at each discrete step to satisfy algebraic equations that depend on $\\Delta t$. They are not the same quantities and will not have the same values.\n**Verdict: Incorrect.**",
            "answer": "$$\\boxed{ABC}$$"
        },
        {
            "introduction": "To connect simulations with real-world experiments, which are typically conducted at constant temperature, we must move beyond the microcanonical ($NVE$) ensemble to the canonical ($NVT$) ensemble. This requires coupling the system to a thermostat. This hands-on problem  focuses on Langevin dynamics, a physically grounded model of a system interacting with a solvent, and its numerical integration using the powerful BAOAB splitting scheme. Your task is not only to implement this state-of-the-art integrator but also to perform a rigorous validation of its properties, distinguishing between its weak accuracy for reproducing average quantities and its strong accuracy for generating the correct equilibrium Boltzmann distribution. This practice provides essential skills for any researcher aiming to perform correct statistical sampling.",
            "id": "3401323",
            "problem": "Implement a numerical integrator based on classical mechanics for molecular dynamics that advances the one-dimensional Langevin dynamics of a particle in a harmonic potential using the BAOAB splitting. Then, quantify its weak order of accuracy for the mean of the position and its configurational sampling accuracy at finite timestep by analyzing the invariant configurational variance. Use nondimensional reduced units with Boltzmann constant equal to one, that is, set $k_{\\mathrm{B}}=1$ and treat all quantities as dimensionless. No physical unit conversion is required.\n\nThe dynamics is governed by the Langevin equations for position $x(t)$ and velocity $v(t)$ for a particle of mass $m$ in the harmonic potential $U(x)=\\tfrac{1}{2} k x^2$ with friction coefficient $\\gamma$ and temperature $T$:\n$$\nm \\,\\mathrm{d} v(t)= -\\nabla U\\bigl(x(t)\\bigr)\\,\\mathrm{d} t - \\gamma m\\, v(t)\\,\\mathrm{d} t + \\sqrt{2 \\gamma m k_{\\mathrm{B}} T}\\,\\mathrm{d} W_t,\\qquad \\mathrm{d} x(t)= v(t)\\,\\mathrm{d} t,\n$$\nwhere $W_t$ is a standard Wiener process. In reduced units, take $k_{\\mathrm{B}}=1$ and treat $m$, $k$, $\\gamma$, $T$, and the timestep $h$ as dimensionless.\n\nThe BAOAB splitting over a single timestep $h$ consists of the sequence of substeps: a half-step momentum update by the conservative force (denoted $B$), a half-step drift of positions (denoted $A$), a full-step stochastic Ornstein–Uhlenbeck (OU) thermostat for velocities (denoted $O$), followed by another half-step $A$ and a final half-step $B$. Concretely, for the harmonic force $F(x)=-\\partial_x U(x)=-k x$, in one timestep $h$ the substeps are applied in the order $B\\to A\\to O\\to A\\to B$. You must implement this BAOAB propagator.\n\nYour tasks:\n\n$1.$ Weak order assessment for the mean position. For fixed $m$, $k$, $\\gamma$, $T$, and initial condition $(x_0,v_0)$, consider the mean position $\\mathbb{E}[x(t_f)]$ at a final time $t_f$ under BAOAB. The expectation of the stochastic OU noise is zero, so the evolution of the mean under BAOAB is obtained by replacing the stochastic OU substep by its noise-free mean map. Define the numerical weak error for a timestep $h$ as\n$$\ne(h) = \\bigl|\\mathbb{E}[x_{h}(t_f)] - x_{\\mathrm{exact}}(t_f)\\bigr|,\n$$\nwhere $\\mathbb{E}[x_{h}(t_f)]$ is the mean propagated by the BAOAB mean map over $t_f$ using steps of size $h$, and $x_{\\mathrm{exact}}(t_f)$ is the exact mean position from the continuous Langevin dynamics. Since $\\mathbb{E}[W_t]=0$, the exact mean solves the deterministic damped harmonic oscillator equation\n$$\nm \\ddot{x}(t) + \\gamma m \\dot{x}(t) + k x(t) = 0,\n$$\nwith the given initial condition $(x_0,v_0)$. Compute the error ratio\n$$\nR = \\frac{e(h)}{e(h/2)}\n$$\nfor two pairs of timesteps as specified in the test suite. A second-order weak method should produce $R\\approx 4$.\n\n$2.$ Configurational sampling accuracy at finite timestep. The BAOAB integrator defines a linear Markov chain for $(x_n,v_n)$ with an affine Gaussian noise injection originating from the OU substep. For the harmonic potential, the invariant distribution of the continuous dynamics has configurational variance $\\mathrm{Var}(x)=T/k$. The BAOAB chain has an invariant covariance matrix $\\Sigma$ that solves the discrete Lyapunov equation\n$$\n\\Sigma = M \\Sigma M^\\top + Q,\n$$\nwhere $M$ is the $2\\times 2$ deterministic mean map of one full BAOAB step for $(x,v)$ and $Q$ is the $2\\times 2$ covariance contribution from one step’s OU noise transported through the surrounding $A$ and $B$ substeps. Compute $\\Sigma$ by solving this discrete Lyapunov equation exactly in double precision using linear algebra (do not use Monte Carlo sampling for this part), and report the absolute configurational variance error\n$$\n\\varepsilon_{\\mathrm{conf}} = \\bigl|\\Sigma_{11} - T/k\\bigr|,\n$$\nfor the specified parameter sets.\n\nImplementation notes and constraints:\n\n- Use only the fundamental statement of the Langevin dynamics and the BAOAB splitting description. Do not use any pre-derived shortcut formulas in the problem statement. Any necessary formulas should be derived from first principles in your solution.\n- For the weak error, ensure that $t_f$ is an integer multiple of $h$ so that a whole number of steps is taken. Propagate the mean using the BAOAB mean map without sampling noise.\n- For the invariant covariance, construct the one-step affine Gaussian map and solve the discrete Lyapunov equation for $\\Sigma$ via vectorization using the Kronecker product approach, i.e., solve\n$$\n\\mathrm{vec}(\\Sigma) = \\bigl(I - M \\otimes M \\bigr)^{-1} \\mathrm{vec}(Q).\n$$\n\nTest suite and required outputs:\n\nYour program must compute the following eight quantities for the four test cases below and print them as a single line containing a comma-separated list enclosed in square brackets, in the order specified. The list elements are:\n\n$1.$ For Test A (underdamped weak-order check): the weak error ratio $R_A$ as a floating-point number, followed by a boolean indicating whether $R_A \\in [3.5, 4.5]$.\n\n$2.$ For Test B (configurational variance at finite timestep, moderate damping): the absolute variance error $\\varepsilon_{\\mathrm{conf},B}$ as a floating-point number, followed by a boolean indicating whether $\\varepsilon_{\\mathrm{conf},B} \\le 10^{-12}$.\n\n$3.$ For Test C (critical damping weak-order check): the weak error ratio $R_C$ as a floating-point number, followed by a boolean indicating whether $R_C \\in [3.5, 4.5]$.\n\n$4.$ For Test D (configurational variance at finite timestep, overdamped): the absolute variance error $\\varepsilon_{\\mathrm{conf},D}$ as a floating-point number, followed by a boolean indicating whether $\\varepsilon_{\\mathrm{conf},D} \\le 10^{-12}$.\n\nUse the following test parameters:\n\n- Test A (underdamped weak-order check): $m=1$, $k=1$, $\\gamma=0.5$, $T=1$, $(x_0,v_0)=(1,0)$, $t_f=10$, $h=0.08$ and $h/2=0.04$.\n\n- Test B (configurational variance at finite timestep): $m=1$, $k=3$, $\\gamma=0.5$, $T=2$, $h=0.4$.\n\n- Test C (critical damping weak-order check): $m=1$, $k=1$, $\\gamma=2$, $T=1$, $(x_0,v_0)=(1,1)$, $t_f=3$, $h=0.05$ and $h/2=0.025$.\n\n- Test D (overdamped configurational variance): $m=1$, $k=1$, $\\gamma=5$, $T=1$, $h=0.1$.\n\nFinal output format:\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in this exact order:\n$$\n\\bigl[ R_A,\\ \\text{bool}(R_A\\in[3.5,4.5]),\\ \\varepsilon_{\\mathrm{conf},B},\\ \\text{bool}(\\varepsilon_{\\mathrm{conf},B}\\le 10^{-12}),\\ R_C,\\ \\text{bool}(R_C\\in[3.5,4.5]),\\ \\varepsilon_{\\mathrm{conf},D},\\ \\text{bool}(\\varepsilon_{\\mathrm{conf},D}\\le 10^{-12}) \\bigr].\n$$",
            "solution": "The problem is valid as it is scientifically grounded in classical and statistical mechanics, well-posed with all necessary parameters and clear objectives, and objective in its formulation. We will proceed with a full solution.\n\nThe problem requires the implementation and analysis of the BAOAB splitting integrator for one-dimensional Langevin dynamics in a harmonic potential. We are tasked with two distinct analyses: assessing the weak order of accuracy for the mean position and quantifying the finite-timestep error in the invariant configurational variance. All calculations are performed in nondimensional reduced units with the Boltzmann constant $k_{\\mathrm{B}}=1$.\n\nLet the state of the particle be represented by the vector $z(t) = (x(t), v(t))^\\top$. The dynamics are governed by the Langevin equation for a particle of mass $m$ in a harmonic potential $U(x) = \\frac{1}{2} k x^2$:\n$$\n\\begin{cases}\n\\mathrm{d}x(t) &= v(t)\\,\\mathrm{d}t \\\\\nm\\,\\mathrm{d}v(t) &= -k x(t)\\,\\mathrm{d}t - \\gamma m\\, v(t)\\,\\mathrm{d}t + \\sqrt{2 \\gamma m T}\\,\\mathrm{d}W_t\n\\end{cases}\n$$\nThe force is $F(x) = -\\nabla U(x) = -k x$. The BAOAB integrator splits the dynamics into three parts, which are solved in sequence over a timestep $h$:\n- **B**: Update velocity under the conservative force: $m\\,\\mathrm{d}v = F(x)\\,\\mathrm{d}t$.\n- **A**: Update position: $\\mathrm{d}x = v\\,\\mathrm{d}t$.\n- **O**: Update velocity under the Ornstein-Uhlenbeck (OU) process: $m\\,\\mathrm{d}v = -\\gamma m v\\,\\mathrm{d}t + \\sqrt{2 \\gamma m T}\\,\\mathrm{d}W_t$.\n\nThe BAOAB scheme applies these steps in the symmetric sequence B(h/2), A(h/2), O(h), A(h/2), B(h/2). Since the force is linear and the OU process is linear, each substep can be represented by a matrix operator. Let $z_n = (x_n, v_n)^\\top$ be the state at time $t_n$.\n\n**1. Derivation of Substep Propagators**\n\n**Substep B (Force):** Integration of $\\dot{v} = F(x)/m = - (k/m) x$ for a duration $\\delta t = h/2$, treating $x$ as constant (Verlet scheme):\n$v_{n+1} = v_n - (k/m) x_n \\delta t$. The position $x_n$ is unchanged.\nThe operator $M_B$ is:\n$$\nz \\mapsto M_B z, \\quad M_B = \\begin{pmatrix} 1 & 0 \\\\ - \\frac{k h}{2m} & 1 \\end{pmatrix}\n$$\n\n**Substep A (Drift):** Integration of $\\dot{x} = v$ for a duration $\\delta t = h/2$, treating $v$ as constant:\n$x_{n+1} = x_n + v_n \\delta t$. The velocity $v_n$ is unchanged.\nThe operator $M_A$ is:\n$$\nz \\mapsto M_A z, \\quad M_A = \\begin{pmatrix} 1 & \\frac{h}{2} \\\\ 0 & 1 \\end{pmatrix}\n$$\n\n**Substep O (Thermostat):** The OU process $\\mathrm{d}v = -\\gamma v\\,\\mathrm{d}t + \\sqrt{2 \\gamma T/m}\\,\\mathrm{d}W_t$ is solved exactly over a duration $h$. The position $x$ is unchanged.\n$v_{n+1} = v_n e^{-\\gamma h} + \\sqrt{\\frac{T}{m}(1 - e^{-2\\gamma h})} R_n$, where $R_n \\sim \\mathcal{N}(0,1)$ is a standard normal random variable.\nThis is an affine transformation:\n$$\nz \\mapsto M_O z + \\xi_O, \\quad M_O = \\begin{pmatrix} 1 & 0 \\\\ 0 & e^{-\\gamma h} \\end{pmatrix}, \\quad \\xi_O = \\begin{pmatrix} 0 \\\\ \\sigma_v R_n \\end{pmatrix}\n$$\nwhere $\\sigma_v = \\sqrt{\\frac{T}{m}(1 - e^{-2\\gamma h})}$.\n\n**Full BAOAB Step:** The state $z_{n+1}$ is obtained by composing these operations:\n$z_{n+1} = M_B(M_A(M_O(M_A(M_B z_n)) + \\xi_O))$.\nExpanding gives the affine map for one full step:\n$$\nz_{n+1} = (M_B M_A M_O M_A M_B) z_n + (M_B M_A) \\xi_O = M z_n + \\xi\n$$\nwhere $M = M_B M_A M_O M_A M_B$ is the deterministic mean map, and $\\xi = M_B M_A \\xi_O$ is the effective noise vector for the full step.\n\n**Task 1: Weak Order Assessment**\n\nThe mean of the state, $\\bar{z}_n = \\mathbb{E}[z_n]$, evolves according to $\\bar{z}_{n+1} = M \\bar{z}_n$, since $\\mathbb{E}[\\xi_O]=0$. Starting from $z_0 = (x_0, v_0)^\\top$, the mean state after $N = t_f/h$ steps is $\\bar{z}_N = M^N z_0$. The numerical mean position is $\\mathbb{E}[x_h(t_f)] = (\\bar{z}_N)_1$.\n\nThe exact mean dynamics follows the deterministic equation $m \\ddot{x} + \\gamma m \\dot{x} + k x = 0$, or $\\ddot{x} + \\gamma \\dot{x} + \\omega_0^2 x = 0$ with $\\omega_0^2 = k/m$. The characteristic equation is $r^2 + \\gamma r + \\omega_0^2 = 0$. The solution depends on the discriminant $\\Delta = \\gamma^2 - 4\\omega_0^2$.\n- **Underdamped ($\\Delta < 0$):** Test A ($m=1, k=1, \\gamma=0.5 \\implies \\Delta = -3.75$).\n  The solution is $x(t) = e^{-\\gamma t/2} (C_1 \\cos(\\omega_d t) + C_2 \\sin(\\omega_d t))$, with $\\omega_d = \\sqrt{\\omega_0^2 - (\\gamma/2)^2}$.\n  Given $(x_0, v_0)$, we find $C_1 = x_0$ and $C_2 = (v_0 + \\gamma x_0/2)/\\omega_d$.\n- **Critically Damped ($\\Delta = 0$):** Test C ($m=1, k=1, \\gamma=2 \\implies \\Delta = 0$).\n  The solution is $x(t) = (C_1 + C_2 t) e^{-\\gamma t/2}$.\n  Given $(x_0, v_0)$, we find $C_1 = x_0$ and $C_2 = v_0 + \\gamma x_0/2$.\n\nThe weak error is $e(h) = |\\mathbb{E}[x_h(t_f)] - x_{\\mathrm{exact}}(t_f)|$. A method with weak order $p$ has $e(h) \\propto h^p$. Thus, the ratio $R = e(h)/e(h/2)$ should be approximately $2^p$. For BAOAB, which is second-order weak, we expect $R \\approx 4$.\n\n**Task 2: Configurational Sampling Accuracy**\n\nThe BAOAB integrator generates a linear Markov chain whose invariant distribution is Gaussian with a certain covariance matrix $\\Sigma = \\mathbb{E}[(z-\\bar{z})(z-\\bar{z})^\\top]$. This matrix is the stationary solution to the discrete Lyapunov equation:\n$$\n\\Sigma = M \\Sigma M^\\top + Q\n$$\nHere, $Q = \\mathbb{E}[\\xi \\xi^\\top]$ is the covariance matrix of the effective noise vector $\\xi = M_B M_A \\xi_O$.\nLet $C = M_B M_A$. The noise is $\\xi = C \\xi_O$.\nThe covariance of the OU noise is $Q_O = \\mathbb{E}[\\xi_O \\xi_O^\\top] = \\mathrm{diag}(0, \\sigma_v^2)$.\nThus, $Q = C Q_O C^\\top$.\nThis Lyapunov equation can be solved for $\\Sigma$ using vectorization. Let $\\sigma = \\mathrm{vec}(\\Sigma)$ and $q = \\mathrm{vec}(Q)$, where $\\mathrm{vec}(\\cdot)$ flattens a matrix into a vector column by column. The equation becomes:\n$$\n\\sigma = (M \\otimes M)\\sigma + q\n$$\nwhere $\\otimes$ is the Kronecker product. This is a standard linear system for $\\sigma$:\n$$\n(I - M \\otimes M)\\sigma = q \\implies \\sigma = (I - M \\otimes M)^{-1}q\n$$\nAfter solving for the vector $\\sigma$, it is reshaped back into the $2 \\times 2$ matrix $\\Sigma$. The configurational variance from the simulation is $\\Sigma_{11}$.\n\nFor the continuous dynamics, the invariant distribution is the Gibbs-Boltzmann distribution, whose configurational part is a Gaussian with variance $\\mathrm{Var}(x) = k_B T/k = T/k$. The BAOAB scheme is known to preserve this configurational marginal exactly for linear forces. The absolute configurational variance error, $\\varepsilon_{\\mathrm{conf}} = |\\Sigma_{11} - T/k|$, should therefore be close to machine precision, reflecting only floating-point arithmetic errors.\n\nThe following Python code implements these calculations for the specified test cases. It first defines functions to compute the BAOAB propagator matrices, the exact mean position for the damped harmonic oscillator, the numerical mean position via the propagator, and the invariant covariance matrix by solving the Lyapunov equation. These functions are then applied to the four test cases.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef get_baoab_matrices(m, k, gamma, h):\n    \"\"\"\n    Constructs the matrix operators for the BAOAB substeps.\n    \n    Returns:\n        M_A (np.ndarray): Matrix for the A (position drift) substep.\n        M_B (np.ndarray): Matrix for the B (force) substep.\n        M_O (np.ndarray): Matrix for the O (thermostat) substep's mean map.\n    \"\"\"\n    # B step matrix for a timestep of h/2\n    M_B = np.array([[1, 0], [-k * h / (2 * m), 1]])\n    \n    # A step matrix for a timestep of h/2\n    M_A = np.array([[1, h / 2], [0, 1]])\n    \n    # O step matrix (mean map) for a timestep of h\n    M_O = np.array([[1, 0], [0, np.exp(-gamma * h)]])\n    \n    return M_A, M_B, M_O\n\ndef get_exact_mean_pos(m, k, gamma, x0, v0, tf):\n    \"\"\"\n    Computes the exact mean position for the damped harmonic oscillator.\n    \"\"\"\n    omega0_sq = k / m\n    delta = gamma**2 - 4 * omega0_sq\n\n    if np.abs(delta) < 1e-15:  # Critically damped case\n        alpha = gamma / 2\n        c1 = x0\n        c2 = v0 + alpha * x0\n        x_exact = (c1 + c2 * tf) * np.exp(-alpha * tf)\n    elif delta < 0:  # Underdamped case\n        alpha = gamma / 2\n        omega_d = np.sqrt(omega0_sq - alpha**2)\n        c1 = x0\n        c2 = (v0 + alpha * x0) / omega_d\n        x_exact = np.exp(-alpha * tf) * (c1 * np.cos(omega_d * tf) + c2 * np.sin(omega_d * tf))\n    else:  # Overdamped case\n        # Not needed for the specific test cases in this problem, but included for completeness.\n        sqrt_delta = np.sqrt(delta)\n        r1 = (-gamma + sqrt_delta) / 2\n        r2 = (-gamma - sqrt_delta) / 2\n        c2 = (v0 - r1 * x0) / (r2 - r1)\n        c1 = x0 - c2\n        x_exact = c1 * np.exp(r1 * tf) + c2 * np.exp(r2 * tf)\n        \n    return x_exact\n\ndef get_numerical_mean_pos(m, k, gamma, x0, v0, tf, h):\n    \"\"\"\n    Computes the numerical mean position by propagating the mean map.\n    \"\"\"\n    if not np.isclose(tf % h, 0, atol=1e-9) and not np.isclose(tf % h, h, atol=1e-9):\n        raise ValueError(\"tf must be an integer multiple of h.\")\n    num_steps = int(round(tf / h))\n    \n    M_A, M_B, M_O = get_baoab_matrices(m, k, gamma, h)\n    \n    # Full BAOAB deterministic mean map M\n    M = M_B @ M_A @ M_O @ M_A @ M_B\n    \n    # Propagate for N steps\n    M_N = np.linalg.matrix_power(M, num_steps)\n    z0 = np.array([x0, v0])\n    zf = M_N @ z0\n    \n    return zf[0]\n\ndef calculate_weak_error_ratio(params):\n    \"\"\"\n    Calculates the weak error ratio R = e(h)/e(h/2).\n    \"\"\"\n    m, k, gamma, _, x0, v0, tf, h = params.values()\n    \n    x_exact = get_exact_mean_pos(m, k, gamma, x0, v0, tf)\n    \n    # Error for timestep h\n    x_num_h = get_numerical_mean_pos(m, k, gamma, x0, v0, tf, h)\n    e_h = np.abs(x_num_h - x_exact)\n    \n    # Error for timestep h/2\n    x_num_h2 = get_numerical_mean_pos(m, k, gamma, x0, v0, tf, h / 2)\n    e_h2 = np.abs(x_num_h2 - x_exact)\n    \n    if e_h2 == 0:\n        return np.inf if e_h != 0 else 1.0\n\n    return e_h / e_h2\n\ndef calculate_configurational_variance_error(params):\n    \"\"\"\n    Calculates the configurational variance error at finite timestep.\n    \"\"\"\n    m, k, gamma, T, h = params.values()\n    \n    # 1. Get the BAOAB mean map M\n    M_A, M_B, M_O = get_baoab_matrices(m, k, gamma, h)\n    M = M_B @ M_A @ M_O @ M_A @ M_B\n    \n    # 2. Get the noise covariance matrix Q\n    sigma_v_sq = (T / m) * (1 - np.exp(-2 * gamma * h))\n    Q_O = np.array([[0, 0], [0, sigma_v_sq]])\n    C = M_B @ M_A\n    Q = C @ Q_O @ C.T\n    \n    # 3. Solve the discrete Lyapunov equation using Kronecker product\n    dim = M.shape[0]\n    Id_kronsq = np.eye(dim**2)\n    M_kron_M = np.kron(M, M)\n    A_lyap = Id_kronsq - M_kron_M\n    \n    q_vec = Q.flatten('F') # Use Fortran order for vec operator\n    \n    sigma_vec = np.linalg.solve(A_lyap, q_vec)\n    \n    Sigma = sigma_vec.reshape((dim, dim), order='F')\n\n    # 4. Compute the error\n    Sigma_11 = Sigma[0, 0]\n    var_exact = T / k\n    error = np.abs(Sigma_11 - var_exact)\n    \n    return error\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = {\n        'A': {'m': 1, 'k': 1, 'gamma': 0.5, 'T': 1, 'x0': 1, 'v0': 0, 'tf': 10, 'h': 0.08},\n        'B': {'m': 1, 'k': 3, 'gamma': 0.5, 'T': 2, 'h': 0.4},\n        'C': {'m': 1, 'k': 1, 'gamma': 2, 'T': 1, 'x0': 1, 'v0': 1, 'tf': 3, 'h': 0.05},\n        'D': {'m': 1, 'k': 1, 'gamma': 5, 'T': 1, 'h': 0.1},\n    }\n\n    results = []\n\n    # Test A: Weak order (underdamped)\n    params_A = test_cases['A']\n    R_A = calculate_weak_error_ratio(params_A)\n    results.append(R_A)\n    results.append(3.5 <= R_A and R_A <= 4.5)\n\n    # Test B: Configurational variance (moderate damping)\n    params_B = test_cases['B']\n    eps_conf_B = calculate_configurational_variance_error(params_B)\n    results.append(eps_conf_B)\n    results.append(eps_conf_B <= 1e-12)\n\n    # Test C: Weak order (critical damping)\n    params_C = test_cases['C']\n    R_C = calculate_weak_error_ratio(params_C)\n    results.append(R_C)\n    results.append(3.5 <= R_C and R_C <= 4.5)\n\n    # Test D: Configurational variance (overdamped)\n    params_D = test_cases['D']\n    eps_conf_D = calculate_configurational_variance_error(params_D)\n    results.append(eps_conf_D)\n    results.append(eps_conf_D <= 1e-12)\n    \n    # Format a boolean as a lowercase string \"true\" or \"false\" for printing\n    def format_bool(b):\n        return 'true' if b else 'false'\n\n    # Prepare string representations for each result item\n    str_results = []\n    for i, item in enumerate(results):\n        if isinstance(item, bool):\n            str_results.append(format_bool(item))\n        else:\n            str_results.append(str(item))\n\n    print(f\"[{','.join(str_results)}]\")\n\nsolve()\n```"
        }
    ]
}