{
    "hands_on_practices": [
        {
            "introduction": "To truly master the application of Poisson brackets, we begin with a foundational exercise in their algebraic properties. Before analyzing the dynamics governed by a full Hamiltonian, it is crucial to understand the commutation relations of fundamental observables like angular momentum. This practice requires deriving the Poisson bracket between different components of the total angular momentum vector, a classic calculation that reveals the underlying Lie algebra structure associated with the group of rotations. Completing this derivation from first principles reinforces the definition of the Poisson bracket and provides a cornerstone result used throughout classical and quantum mechanics .",
            "id": "3435750",
            "problem": "Consider a classical Molecular Dynamics (MD) system of $N$ point particles in three spatial dimensions, with particle labels $a \\in \\{1,\\dots,N\\}$. Let the canonical coordinates be the positions $\\mathbf{r}_{a} \\in \\mathbb{R}^{3}$ and canonical momenta $\\mathbf{p}_{a} \\in \\mathbb{R}^{3}$, with the fundamental Poisson bracket definition\n$$\n\\{A,B\\} \\equiv \\sum_{a=1}^{N} \\sum_{i=1}^{3} \\left( \\frac{\\partial A}{\\partial r_{a,i}} \\frac{\\partial B}{\\partial p_{a,i}} - \\frac{\\partial A}{\\partial p_{a,i}} \\frac{\\partial B}{\\partial r_{a,i}} \\right),\n$$\nwhere $r_{a,i}$ and $p_{a,i}$ are the Cartesian components of $\\mathbf{r}_{a}$ and $\\mathbf{p}_{a}$, respectively. The Hamiltonian is\n$$\nH(\\{\\mathbf{r}_{a},\\mathbf{p}_{a}\\}) \\equiv \\sum_{a=1}^{N} \\frac{|\\mathbf{p}_{a}|^{2}}{2 m_{a}} + \\sum_{1 \\le a < b \\le N} V\\!\\left(|\\mathbf{r}_{a}-\\mathbf{r}_{b}|\\right),\n$$\nwhere $m_{a}>0$ are particle masses and $V$ is a smooth pair potential that depends only on interparticle distances. Define the total angular momentum\n$$\n\\mathbf{L} \\equiv \\sum_{a=1}^{N} \\mathbf{r}_{a} \\times \\mathbf{p}_{a},\n$$\nand denote by $\\varepsilon_{ijk}$ the Levi-Civita symbol with $\\varepsilon_{123}=+1$. Let $\\mathbf{a}, \\mathbf{b} \\in \\mathbb{R}^{3}$ be fixed, time-independent vectors.\n\nUsing only the fundamental definition of the Poisson bracket above and the canonical structure implied by it, compute the Poisson bracket $\\{ \\mathbf{L} \\cdot \\mathbf{a}, \\mathbf{L} \\cdot \\mathbf{b} \\}$ and express your final answer solely as a compact analytic expression involving only $\\mathbf{L}$, $\\mathbf{a}$, and $\\mathbf{b}$ (and standard vector operations on them). Do not introduce any additional variables or assumptions beyond those stated here. Your answer must be a single closed-form expression. No numerical approximation is required and no units are to be reported.",
            "solution": "Let the quantities of interest be $A \\equiv \\mathbf{L} \\cdot \\mathbf{a}$ and $B \\equiv \\mathbf{L} \\cdot \\mathbf{b}$. We wish to compute $\\{A, B\\}$. In terms of Cartesian components, we can write:\n$$\nA = \\sum_{j=1}^{3} L_j a_j \\quad \\text{and} \\quad B = \\sum_{k=1}^{3} L_k b_k\n$$\nwhere $L_j$, $a_j$, and $b_k$ are the $j$-th and $k$-th components of the vectors $\\mathbf{L}$, $\\mathbf{a}$, and $\\mathbf{b}$, respectively.\n\nThe Poisson bracket is a bilinear operator. Since the components $a_j$ and $b_k$ of the vectors $\\mathbf{a}$ and $\\mathbf{b}$ are fixed constants, they can be factored out of the Poisson bracket:\n$$\n\\{A, B\\} = \\left\\{ \\sum_{j=1}^{3} L_j a_j, \\sum_{k=1}^{3} L_k b_k \\right\\} = \\sum_{j,k=1}^{3} a_j b_k \\{L_j, L_k\\}\n$$\nThe core of the problem reduces to calculating the Poisson bracket between the components of the total angular momentum, $\\{L_j, L_k\\}$. The $j$-th component of the total angular momentum is $L_j = \\sum_{a=1}^{N} (\\mathbf{r}_a \\times \\mathbf{p}_a)_j = \\sum_{a=1}^{N} \\sum_{l,m=1}^{3} \\varepsilon_{jlm} r_{a,l} p_{a,m}$.\n\nUsing the fundamental definition of the Poisson bracket, a direct calculation yields the fundamental commutation relation for the components of angular momentum. We find the partial derivatives of $L_j$ with respect to the coordinates $r_{c,s}$ and momenta $p_{c,s}$ of a particle $c$:\n$$\n\\frac{\\partial L_j}{\\partial r_{c,s}} = \\sum_{m=1}^{3} \\varepsilon_{jsm} p_{c,m}, \\qquad \\frac{\\partial L_j}{\\partial p_{c,s}} = \\sum_{l=1}^{3} \\varepsilon_{jls} r_{c,l}\n$$\nSubstituting these into the Poisson bracket definition gives:\n$$\n\\{L_j, L_k\\} = \\sum_{c=1}^{N} \\sum_{s=1}^{3} \\left[ \\left(\\sum_{m=1}^{3} \\varepsilon_{jsm} p_{c,m}\\right) \\left(\\sum_{l=1}^{3} \\varepsilon_{kls} r_{c,l}\\right) - \\left(\\sum_{l=1}^{3} \\varepsilon_{jls} r_{c,l}\\right) \\left(\\sum_{m=1}^{3} \\varepsilon_{ksm} p_{c,m}\\right) \\right]\n$$\nUsing the Levi-Civita tensor contraction identity $\\sum_s \\varepsilon_{s\\alpha\\beta}\\varepsilon_{s\\gamma\\delta} = \\delta_{\\alpha\\gamma}\\delta_{\\beta\\delta} - \\delta_{\\alpha\\delta}\\delta_{\\beta\\gamma}$, the term in the square brackets simplifies to $\\sum_{l,m} (\\delta_{jl}\\delta_{mk} - \\delta_{jk}\\delta_{ml}) r_{c,l} p_{c,m}$. Summing over $l$ and $m$ yields:\n$$\n\\{L_j, L_k\\} = \\sum_{c=1}^{N} (r_{c,j}p_{c,k} - r_{c,k}p_{c,j})\n$$\nThis expression is the $s$-th component of the total angular momentum vector $\\mathbf{L}$, where $s$ is the index completing the cyclic permutation of $(j,k)$. More formally, using the Levi-Civita symbol, we can write $\\sum_{c=1}^{N} (r_{c,j} p_{c,k} - r_{c,k} p_{c,j}) = \\sum_{s=1}^{3} \\varepsilon_{jks} L_s$. This gives the fundamental angular momentum algebra relation:\n$$\n\\{L_j, L_k\\} = \\sum_{s=1}^{3} \\varepsilon_{jks} L_s\n$$\nFinally, we substitute this result back into our expression for $\\{A,B\\}$:\n$$\n\\{ \\mathbf{L} \\cdot \\mathbf{a}, \\mathbf{L} \\cdot \\mathbf{b} \\} = \\sum_{j,k=1}^{3} a_j b_k \\{L_j, L_k\\} = \\sum_{j,k,s=1}^{3} a_j b_k \\varepsilon_{jks} L_s\n$$\nWe can rearrange the summations:\n$$\n\\{ \\mathbf{L} \\cdot \\mathbf{a}, \\mathbf{L} \\cdot \\mathbf{b} \\} = \\sum_{s=1}^{3} L_s \\left( \\sum_{j,k=1}^{3} \\varepsilon_{jks} a_j b_k \\right)\n$$\nUsing the cyclic property of the Levi-Civita symbol, $\\varepsilon_{jks} = -\\varepsilon_{sjk}$:\n$$\n\\{ \\mathbf{L} \\cdot \\mathbf{a}, \\mathbf{L} \\cdot \\mathbf{b} \\} = \\sum_{s=1}^{3} L_s \\left( -\\sum_{j,k=1}^{3} \\varepsilon_{sjk} a_j b_k \\right)\n$$\nThe term in the parenthesis is the negative of the $s$-th component of the cross product $\\mathbf{a} \\times \\mathbf{b}$:\n$$\n(\\mathbf{a} \\times \\mathbf{b})_s = \\sum_{j,k=1}^{3} \\varepsilon_{sjk} a_j b_k\n$$\nTherefore, the expression becomes a dot product:\n$$\n\\{ \\mathbf{L} \\cdot \\mathbf{a}, \\mathbf{L} \\cdot \\mathbf{b} \\} = \\sum_{s=1}^{3} L_s \\left( -(\\mathbf{a} \\times \\mathbf{b})_s \\right) = -\\mathbf{L} \\cdot (\\mathbf{a} \\times \\mathbf{b})\n$$\nThis is the final compact analytical expression.",
            "answer": "$$\n\\boxed{-\\mathbf{L} \\cdot (\\mathbf{a} \\times \\mathbf{b})}\n$$"
        },
        {
            "introduction": "Building on the algebraic foundation, this practice connects the abstract formalism of Poisson brackets to tangible physical dynamics. By calculating the Poisson bracket of the total angular momentum $\\mathbf{L}$ with the system's Hamiltonian $H$, you will prove the fundamental relationship $\\frac{d\\mathbf{L}}{dt} = \\{\\mathbf{L}, H\\} = \\boldsymbol{\\tau}_{\\text{total}}$, where $\\boldsymbol{\\tau}$ is the total torque. This exercise demonstrates how conservation laws arise from symmetries in the Hamiltonian; for instance, a system with only central forces possesses full rotational symmetry, resulting in zero total torque and the conservation of all components of $\\mathbf{L}$. Through a combination of analytical derivation and numerical implementation, you will explore how introducing external potentials that break this symmetry leads to the non-conservation of specific angular momentum components, providing a direct and intuitive link between symmetry, torque, and constants of motion .",
            "id": "3435765",
            "problem": "Consider a system of $N$ classical point particles with positions $\\mathbf{r}_i \\in \\mathbb{R}^3$ and momenta $\\mathbf{p}_i \\in \\mathbb{R}^3$, for $i = 1, \\dots, N$. The Hamiltonian is\n$$\nH(\\{\\mathbf{r}_i\\}, \\{\\mathbf{p}_i\\}) = \\sum_{i=1}^N \\frac{\\mathbf{p}_i^2}{2 m_i} + \\sum_{1 \\le i<j \\le N} V\\!\\left(\\left\\|\\mathbf{r}_i - \\mathbf{r}_j\\right\\|\\right) + \\sum_{i=1}^N U_{\\text{ext}}(\\mathbf{r}_i),\n$$\nwhere $m_i$ are masses, $V(r)$ is a central pair potential depending only on the scalar separation $r = \\|\\mathbf{r}_i - \\mathbf{r}_j\\|$, and $U_{\\text{ext}}$ is an external single-particle potential. Define the total angular momentum\n$$\n\\mathbf{L} = \\sum_{i=1}^N \\mathbf{r}_i \\times \\mathbf{p}_i.\n$$\nThe Poisson bracket of two scalar functions $A(\\{\\mathbf{r}_i\\}, \\{\\mathbf{p}_i\\})$ and $B(\\{\\mathbf{r}_i\\}, \\{\\mathbf{p}_i\\})$ is\n$$\n\\{A, B\\} = \\sum_{i=1}^N \\left( \\frac{\\partial A}{\\partial \\mathbf{r}_i} \\cdot \\frac{\\partial B}{\\partial \\mathbf{p}_i} - \\frac{\\partial A}{\\partial \\mathbf{p}_i} \\cdot \\frac{\\partial B}{\\partial \\mathbf{r}_i} \\right),\n$$\nwhere $\\partial/\\partial \\mathbf{r}_i$ and $\\partial/\\partial \\mathbf{p}_i$ denote gradients with respect to $\\mathbf{r}_i$ and $\\mathbf{p}_i$. The goal is to reason from first principles to determine when components of $\\mathbf{L}$ are constants of motion, quantify the failure of conservation under anisotropic perturbations, and implement a program that computes the vector Poisson bracket $\\{\\mathbf{L}, H\\}$ for specified configurations.\n\nStart from the fundamental laws and core definitions of Hamiltonian mechanics: the Hamiltonian flow, the definition of Poisson brackets, and the definition of angular momentum. Do not assume any shortcut identities not derivable from these bases. Use well-tested formulas such as the Lennard-Jones pair potential\n$$\nV_{\\text{LJ}}(r) = 4\\epsilon\\left[\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^6\\right],\n$$\nand its derivative with respect to $r$. Consider external potentials that model anisotropic walls and uniform field gradients:\n- Anisotropic quadratic confinement,\n$$\nU_{\\text{quad}}(\\mathbf{r}) = \\frac{1}{2}\\left(k_x x^2 + k_y y^2 + k_z z^2\\right),\n$$\n- Uniform field gradient,\n$$\nU_{\\text{lin}}(\\mathbf{r}) = -\\mathbf{g}\\cdot\\mathbf{r}.\n$$\n\nYou must:\n- Derive, in purely mathematical terms, how $\\{\\mathbf{L}, H\\}$ reduces to a torque-like sum involving gradients of the potential.\n- Explain, using symmetry arguments grounded in the definitions, why central pair potentials imply $\\{\\mathbf{L}, H\\}=\\mathbf{0}$, and identify perturbations where specific components (e.g., $L_z$) remain conserved or fail to be conserved.\n- Implement a program that computes $\\{\\mathbf{L}, H\\}$ numerically for given particle configurations by evaluating the gradients entering the Poisson bracket. The computation must be done in reduced Lennard-Jones units, with distances measured in units of $\\sigma$, energy in units of $\\epsilon$, masses $m_i$ in units where $m_i = 1$, momenta in units of $\\sqrt{m\\epsilon}$, and time in units of $\\sigma\\sqrt{m/\\epsilon}$. All outputs must be expressed in these dimensionless units.\n\nTest Suite:\nProvide a program that evaluates the following five test cases. In each case, compute the vector Poisson bracket $\\{\\mathbf{L}, H\\}$ and report conservation booleans as specified below. Use $\\epsilon = 1$ and $\\sigma = 1$.\n\n- Test case $1$ (central pair potential, no external field): Two particles with pairwise $V_{\\text{LJ}}$ only.\n  - Parameters: $N=2$, $m_1=m_2=1$,\n    $\\mathbf{r}_1 = (0.45,-0.30,0.50)$, $\\mathbf{r}_2 = (-0.15,0.80,0.10)$,\n    $\\mathbf{p}_1 = (0.20,0.15,-0.10)$, $\\mathbf{p}_2 = (-0.25,0.05,0.30)$,\n    $U_{\\text{ext}} \\equiv 0$.\n  - Expected: full rotational symmetry implies all components conserved. Report booleans for $(L_x,L_y,L_z)$.\n\n- Test case $2$ (axis-symmetric anisotropic walls): One particle with $U_{\\text{quad}}$ having $k_x=k_y\\ne k_z$ (cylindrical symmetry about the $z$-axis).\n  - Parameters: $N=1$, $m_1=1$,\n    $\\mathbf{r}_1 = (0.60,-0.40,0.30)$, $\\mathbf{p}_1 = (0.10,0.20,-0.15)$,\n    $(k_x,k_y,k_z) = (30.0,30.0,50.0)$,\n    no pair potential.\n  - Expected: $L_z$ conserved, $L_x$ and $L_y$ not conserved. Report booleans for $(L_x,L_y,L_z)$.\n\n- Test case $3$ (fully anisotropic walls): One particle with $U_{\\text{quad}}$ having $k_x \\ne k_y \\ne k_z$ (no rotational symmetry).\n  - Parameters: $N=1$, $m_1=1$,\n    $\\mathbf{r}_1 = (0.60,0.50,-0.25)$, $\\mathbf{p}_1 = (-0.30,0.40,0.10)$,\n    $(k_x,k_y,k_z) = (20.0,30.0,40.0)$,\n    no pair potential.\n  - Expected: no component conserved. Report booleans for $(L_x,L_y,L_z)$.\n\n- Test case $4$ (central pair plus uniform field along $z$): Two particles with pairwise $V_{\\text{LJ}}$ and $U_{\\text{lin}}$ with $\\mathbf{g} = (0,0,2.0)$.\n  - Parameters: $N=2$, $m_1=m_2=1$,\n    $\\mathbf{r}_1 = (0.25,-0.35,0.45)$, $\\mathbf{r}_2 = (-0.40,0.15,0.20)$,\n    $\\mathbf{p}_1 = (0.35,-0.10,0.25)$, $\\mathbf{p}_2 = (-0.15,0.30,-0.20)$,\n    $\\mathbf{g}=(0,0,2.0)$.\n  - Expected: cylindrical symmetry about $z$ implies $L_z$ conserved. Report booleans for $(L_x,L_y,L_z)$.\n\n- Test case $5$ (central pair plus uniform field along a general direction): Two particles with pairwise $V_{\\text{LJ}}$ and $U_{\\text{lin}}$ with $\\mathbf{g} = (1.0,2.0,3.0)$.\n  - Parameters: $N=2$, $m_1=m_2=1$,\n    $\\mathbf{r}_1 = (0.10,0.20,0.30)$, $\\mathbf{r}_2 = (-0.25,0.05,0.15)$,\n    $\\mathbf{p}_1 = (0.05,-0.10,0.20)$, $\\mathbf{p}_2 = (-0.30,0.25,-0.05)$,\n    $\\mathbf{g}=(1.0,2.0,3.0)$.\n  - Expected: rotational symmetry about the $\\mathbf{g}$-axis implies conservation of the component $L_{\\parallel} = \\mathbf{L}\\cdot \\hat{\\mathbf{g}}$ (equivalently, $\\{ \\mathbf{L}\\cdot \\mathbf{g}, H\\}=0$). Report a single boolean for this conserved quantity.\n\nNumerical evaluation details:\n- Compute $\\{\\mathbf{L}, H\\}$ using the definition of the Poisson bracket and gradients of $H$ with respect to positions and momenta; do not assume any hidden identities beyond those derivable from the core definitions.\n- For the Lennard-Jones potential with $\\epsilon=1$ and $\\sigma=1$, use its radial derivative $\\mathrm{d}V_{\\text{LJ}}/\\mathrm{d}r$ to assemble $\\nabla_{\\mathbf{r}_i} H$.\n- Use an absolute tolerance $\\tau = 10^{-12}$ in reduced units to decide conservation booleans: a component is considered conserved if the absolute value of the corresponding component of $\\{\\mathbf{L}, H\\}$ is less than or equal to $\\tau$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each element corresponds to one test case. For test cases $1$–$4$, each element must be a list of length $6$ in the order $[\\{\\mathbf{L},H\\}_x, \\{\\mathbf{L},H\\}_y, \\{\\mathbf{L},H\\}_z, \\text{cons}_x, \\text{cons}_y, \\text{cons}_z]$. For test case $5$, the element must be a list of length $4$ in the order $[\\{\\mathbf{L},H\\}_x, \\{\\mathbf{L},H\\}_y, \\{\\mathbf{L},H\\}_z, \\text{cons}_{\\mathbf{g}}]$. All floats must be expressed in reduced Lennard-Jones units as specified above, and booleans must be either $\\text{True}$ or $\\text{False}$.",
            "solution": "The problem is to analyze the conservation of the total angular momentum, $\\mathbf{L}$, of a system of $N$ particles described by a given Hamiltonian, $H$. A quantity is a constant of motion if its Poisson bracket with the Hamiltonian is zero. We must first formally derive the expression for the vector Poisson bracket $\\{\\mathbf{L}, H\\}$, then use this result to discuss conservation under various potentials, and finally implement a numerical calculation for specific test cases.\n\n### Step 1: Derivation of $\\{\\mathbf{L}, H\\}$\n\nThe Hamiltonian for the system is given by:\n$$\nH(\\{\\mathbf{r}_i\\}, \\{\\mathbf{p}_i\\}) = \\sum_{i=1}^N \\frac{\\mathbf{p}_i^2}{2 m_i} + \\sum_{1 \\le i<j \\le N} V\\!\\left(\\left\\|\\mathbf{r}_i - \\mathbf{r}_j\\right\\|\\right) + \\sum_{i=1}^N U_{\\text{ext}}(\\mathbf{r}_i) = T + V_{\\text{pair}} + U_{\\text{pot}}\n$$\nThe total angular momentum is:\n$$\n\\mathbf{L} = \\sum_{i=1}^N \\mathbf{r}_i \\times \\mathbf{p}_i\n$$\nThe Poisson bracket of two functions $A$ and $B$ is:\n$$\n\\{A, B\\} = \\sum_{k=1}^N \\left( \\frac{\\partial A}{\\partial \\mathbf{r}_k} \\cdot \\frac{\\partial B}{\\partial \\mathbf{p}_k} - \\frac{\\partial A}{\\partial \\mathbf{p}_k} \\cdot \\frac{\\partial B}{\\partial \\mathbf{r}_k} \\right)\n$$\nWe wish to compute the vector Poisson bracket $\\{\\mathbf{L}, H\\}$, which is a vector whose components are the scalar Poisson brackets $\\{L_x, H\\}$, $\\{L_y, H\\}$, and $\\{L_z, H\\}$. Let us compute the bracket for an arbitrary component $L_a$, where $a \\in \\{x, y, z\\}$.\n\nFirst, we compute the necessary gradients of $L_a$ and $H$. The partial derivatives are taken with respect to the coordinates of a single particle, say particle $k$.\n\nGradients of $L_a$:\nThe $a$-th component of $\\mathbf{L}$ is $L_a = \\sum_{i=1}^N (\\mathbf{r}_i \\times \\mathbf{p}_i)_a$. The derivatives with respect to particle $k$'s coordinates only act on the $i=k$ term.\nFor the position gradient $\\frac{\\partial L_a}{\\partial \\mathbf{r}_k}$:\n$$\n\\frac{\\partial L_a}{\\partial \\mathbf{r}_k} = \\frac{\\partial}{\\partial \\mathbf{r}_k} (\\mathbf{r}_k \\times \\mathbf{p}_k)_a\n$$\nLet's take $a=x$ as an example: $L_x = \\sum_i (y_i p_{z_i} - z_i p_{y_i})$.\n$$\n\\frac{\\partial L_x}{\\partial \\mathbf{r}_k} = \\frac{\\partial}{\\partial \\mathbf{r}_k} (y_k p_{z_k} - z_k p_{y_k}) = p_{z_k} \\hat{\\mathbf{y}}_k - p_{y_k} \\hat{\\mathbf{z}}_k = (0, p_{z_k}, -p_{y_k})\n$$\nFor the momentum gradient $\\frac{\\partial L_a}{\\partial \\mathbf{p}_k}$:\n$$\n\\frac{\\partial L_x}{\\partial \\mathbf{p}_k} = \\frac{\\partial}{\\partial \\mathbf{p}_k} (y_k p_{z_k} - z_k p_{y_k}) = y_k \\hat{\\mathbf{p}}_{z_k} - z_k \\hat{\\mathbf{p}}_{y_k} = (0, -z_k, y_k) = \\hat{\\mathbf{x}} \\times \\mathbf{r}_k\n$$\nIn general, for any component $a$, we find: $\\frac{\\partial L_a}{\\partial \\mathbf{p}_k} = \\hat{\\mathbf{e}}_a \\times \\mathbf{r}_k$.\n\nGradients of $H$:\n$$\n\\frac{\\partial H}{\\partial \\mathbf{p}_k} = \\frac{\\partial}{\\partial \\mathbf{p}_k} \\left(\\frac{\\mathbf{p}_k^2}{2m_k}\\right) = \\frac{\\mathbf{p}_k}{m_k} = \\mathbf{v}_k\n$$\n$$\n\\frac{\\partial H}{\\partial \\mathbf{r}_k} = \\frac{\\partial V_{\\text{pair}}}{\\partial \\mathbf{r}_k} + \\frac{\\partial U_{\\text{pot}}}{\\partial \\mathbf{r}_k} = -\\mathbf{F}_k^{\\text{int}} - \\mathbf{F}_k^{\\text{ext}} = -\\mathbf{F}_k\n$$\nwhere $\\mathbf{F}_k$ is the total force on particle $k$.\n\nNow, we assemble the Poisson bracket for $L_a$:\n$$\n\\{L_a, H\\} = \\sum_{k=1}^N \\left( \\frac{\\partial L_a}{\\partial \\mathbf{r}_k} \\cdot \\frac{\\mathbf{p}_k}{m_k} - \\left(\\frac{\\partial L_a}{\\partial \\mathbf{p}_k}\\right) \\cdot \\frac{\\partial H}{\\partial \\mathbf{r}_k} \\right)\n$$\nThe first term is:\n$$\n\\sum_{k=1}^N \\frac{\\partial L_a}{\\partial \\mathbf{r}_k} \\cdot \\frac{\\mathbf{p}_k}{m_k} = \\sum_{k=1}^N \\frac{1}{m_k} (p_{z_k} \\hat{\\mathbf{y}}_k - p_{y_k} \\hat{\\mathbf{z}}_k) \\cdot (p_{x_k}, p_{y_k}, p_{z_k}) \\quad (\\text{for } a=x)\n$$\n$$\n= \\sum_{k=1}^N \\frac{1}{m_k} (p_{z_k} p_{y_k} - p_{y_k} p_{z_k}) = 0\n$$\nThis term is zero for all components of $\\mathbf{L}$. Thus, the Poisson bracket simplifies to the second term:\n$$\n\\{L_a, H\\} = - \\sum_{k=1}^N \\left(\\frac{\\partial L_a}{\\partial \\mathbf{p}_k}\\right) \\cdot \\frac{\\partial H}{\\partial \\mathbf{r}_k} = - \\sum_{k=1}^N (\\hat{\\mathbf{e}}_a \\times \\mathbf{r}_k) \\cdot (-\\mathbf{F}_k) = \\sum_{k=1}^N (\\hat{\\mathbf{e}}_a \\times \\mathbf{r}_k) \\cdot \\mathbf{F}_k\n$$\nUsing the scalar triple product identity $\\mathbf{A} \\cdot (\\mathbf{B} \\times \\mathbf{C}) = (\\mathbf{A} \\times \\mathbf{B}) \\cdot \\mathbf{C}$, we can write $(\\hat{\\mathbf{e}}_a \\times \\mathbf{r}_k) \\cdot \\mathbf{F}_k = \\hat{\\mathbf{e}}_a \\cdot (\\mathbf{r}_k \\times \\mathbf{F}_k)$.\nLet $\\boldsymbol{\\tau}_k = \\mathbf{r}_k \\times \\mathbf{F}_k$ be the torque on particle $k$. Then:\n$$\n\\{L_a, H\\} = \\sum_{k=1}^N \\hat{\\mathbf{e}}_a \\cdot \\boldsymbol{\\tau}_k = \\hat{\\mathbf{e}}_a \\cdot \\left(\\sum_{k=1}^N \\boldsymbol{\\tau}_k\\right) = (\\boldsymbol{\\tau}_{\\text{total}})_a\n$$\nThis is true for any component $a$. Therefore, we arrive at the vector relation:\n$$\n\\{\\mathbf{L}, H\\} = \\sum_{k=1}^N \\mathbf{r}_k \\times \\mathbf{F}_k = \\boldsymbol{\\tau}_{\\text{total}}\n$$\nThis is a fundamental result from Hamiltonian mechanics, stating that the time evolution of the angular momentum is given by the total torque on the system. Since $\\frac{d\\mathbf{L}}{dt} = \\{\\mathbf{L}, H\\}$, this is the analogue of Newton's second law for rotation. Angular momentum is conserved if and only if the total torque is zero.\n\n### Step 2: Symmetry Arguments and Conservation\n\nThe total torque $\\boldsymbol{\\tau}_{\\text{total}}$ can be split into contributions from internal pair forces and external forces:\n$$\n\\boldsymbol{\\tau}_{\\text{total}} = \\boldsymbol{\\tau}_{\\text{int}} + \\boldsymbol{\\tau}_{\\text{ext}} = \\sum_{k=1}^N \\mathbf{r}_k \\times \\mathbf{F}_k^{\\text{int}} + \\sum_{k=1}^N \\mathbf{r}_k \\times \\mathbf{F}_k^{\\text{ext}}\n$$\n\n**Contribution from Central Pair Potentials:**\nThe internal force on particle $i$ is $\\mathbf{F}_i^{\\text{int}} = \\sum_{j \\ne i} \\mathbf{F}_{ij}$, where $\\mathbf{F}_{ij}$ is the force on $i$ due to $j$. For a central potential $V(r_{ij})$, the force is $\\mathbf{F}_{ij} = -V'(r_{ij}) \\frac{\\mathbf{r}_{ij}}{r_{ij}}$, where $\\mathbf{r}_{ij} = \\mathbf{r}_i - \\mathbf{r}_j$. The internal torque is:\n$$\n\\boldsymbol{\\tau}_{\\text{int}} = \\sum_{i} \\mathbf{r}_i \\times \\left(\\sum_{j \\ne i} \\mathbf{F}_{ij}\\right) = \\sum_{i<j} (\\mathbf{r}_i \\times \\mathbf{F}_{ij} + \\mathbf{r}_j \\times \\mathbf{F}_{ji})\n$$\nBy Newton's third law, $\\mathbf{F}_{ji} = -\\mathbf{F}_{ij}$.\n$$\n\\boldsymbol{\\tau}_{\\text{int}} = \\sum_{i<j} (\\mathbf{r}_i \\times \\mathbf{F}_{ij} - \\mathbf{r}_j \\times \\mathbf{F}_{ij}) = \\sum_{i<j} (\\mathbf{r}_i - \\mathbf{r}_j) \\times \\mathbf{F}_{ij}\n$$\nSince $\\mathbf{F}_{ij}$ is parallel to the separation vector $\\mathbf{r}_i - \\mathbf{r}_j$, their cross product is identically zero. Thus, $\\boldsymbol{\\tau}_{\\text{int}} = \\mathbf{0}$.\nThis confirms that any system with only central pair potentials conserves total angular momentum, as the internal forces produce no net torque. This is why for Test Case 1, with only a Lennard-Jones potential, $\\{\\mathbf{L}, H\\} = \\mathbf{0}$ and all components of $\\mathbf{L}$ are conserved. The system possesses full rotational symmetry.\n\n**Contribution from External Potentials:**\nConservation of $\\mathbf{L}$ or its components depends entirely on the external potential $U_{\\text{ext}}$.\n$$\n\\{\\mathbf{L}, H\\} = \\boldsymbol{\\tau}_{\\text{ext}} = \\sum_i \\mathbf{r}_i \\times \\mathbf{F}_i^{\\text{ext}} = -\\sum_i \\mathbf{r}_i \\times \\nabla_{\\mathbf{r}_i} U_{\\text{ext}}(\\mathbf{r}_i)\n$$\n- **Anisotropic quadratic confinement ($U_{\\text{quad}}$):** For a single particle, $\\mathbf{F}^{\\text{ext}} = -(k_x x, k_y y, k_z z)$. The torque is:\n$$\n\\boldsymbol{\\tau}_{\\text{ext}} = -\\mathbf{r} \\times (k_x x, k_y y, k_z z) = (y z(k_y - k_z), z x(k_z - k_x), x y(k_x - k_y))\n$$\n  - In Test Case 2, $k_x = k_y \\ne k_z$. The potential $U_{\\text{quad}} = \\frac{1}{2} k_x(x^2+y^2) + \\frac{1}{2} k_z z^2$ is symmetric under rotations about the $z$-axis. The torque's $z$-component is $\\tau_z = xy(k_x - k_y) = 0$. Hence, $\\{L_z, H\\} = 0$ and $L_z$ is conserved, while $L_x$ and $L_y$ are not.\n  - In Test Case 3, $k_x \\ne k_y \\ne k_z$. The potential has no continuous rotational symmetry. In general, all components of the torque are non-zero, so no component of $\\mathbf{L}$ is conserved.\n\n- **Uniform field gradient ($U_{\\text{lin}}$):** $U_{\\text{lin}}(\\mathbf{r}) = -\\mathbf{g}\\cdot\\mathbf{r}$. The external force on each particle $i$ is $\\mathbf{F}_i^{\\text{ext}} = -\\nabla_{\\mathbf{r}_i} (-\\mathbf{g}\\cdot\\mathbf{r}_i) = \\mathbf{g}$. The total external torque is:\n$$\n\\boldsymbol{\\tau}_{\\text{ext}} = \\sum_i \\mathbf{r}_i \\times \\mathbf{g} = \\left(\\sum_i \\mathbf{r}_i\\right) \\times \\mathbf{g}\n$$\n  - In Test Case 4, $\\mathbf{g}$ is along the $z$-axis, $\\mathbf{g} = (0, 0, g_z)$. The potential is symmetric under rotations about the $z$-axis. The torque is $\\boldsymbol{\\tau}_{\\text{ext}} = (\\sum_i \\mathbf{r}_i) \\times (0, 0, g_z)$, whose $z$-component is zero. Thus, $\\{L_z, H\\} = 0$ and $L_z$ is conserved.\n  - In Test Case 5, $\\mathbf{g}$ is a general vector. The potential $U_{\\text{pot}} = -\\mathbf{g} \\cdot (\\sum_i \\mathbf{r}_i)$ is symmetric under rotations about the axis defined by $\\mathbf{g}$. The conserved quantity is the component of angular momentum along this axis, $L_\\parallel = \\mathbf{L} \\cdot \\hat{\\mathbf{g}}$. To verify this, we compute its Poisson bracket with $H$:\n  $$\n  \\{L_\\parallel, H\\} = \\{\\mathbf{L} \\cdot \\hat{\\mathbf{g}}, H\\} = \\hat{\\mathbf{g}} \\cdot \\{\\mathbf{L}, H\\} = \\hat{\\mathbf{g}} \\cdot \\boldsymbol{\\tau}_{\\text{ext}}\n  $$\n  $$\n  = \\hat{\\mathbf{g}} \\cdot \\left(\\left(\\sum_i \\mathbf{r}_i\\right) \\times \\mathbf{g}\\right) = \\frac{1}{\\|\\mathbf{g}\\|} \\mathbf{g} \\cdot \\left(\\left(\\sum_i \\mathbf{r}_i\\right) \\times \\mathbf{g}\\right)\n  $$\n  The scalar triple product $\\mathbf{a} \\cdot (\\mathbf{b} \\times \\mathbf{a})$ is always zero because $\\mathbf{b} \\times \\mathbf{a}$ is a vector orthogonal to $\\mathbf{a}$. Thus, $\\{L_\\parallel, H\\} = 0$, and the component of $\\mathbf{L}$ along $\\mathbf{g}$ is always conserved.\n\n### Step 3: Numerical Implementation\n\nThe program will implement the derived formula $\\{\\mathbf{L}, H\\} = \\boldsymbol{\\tau}_{\\text{total}}$. For each particle, it will compute the total force $\\mathbf{F}_k$ (sum of internal and external forces) and then the torque $\\boldsymbol{\\tau}_k = \\mathbf{r}_k \\times \\mathbf{F}_k$. The sum of these torques gives the final vector. This is mathematically equivalent to the definition of the Poisson bracket but is computationally more direct.\n\n- For the Lennard-Jones potential $V_{\\text{LJ}}(r) = 4\\epsilon\\left[(\\sigma/r)^{12} - (\\sigma/r)^6\\right]$, with $\\epsilon=1, \\sigma=1$, the radial derivative is $V'_{\\text{LJ}}(r) = 4(-12r^{-13} + 6r^{-7}) = 24(r^{-7} - 2r^{-13})$. The force is $\\mathbf{F}_{ij} = -V'_{\\text{LJ}}(r_{ij}) \\frac{\\mathbf{r}_{ij}}{r_{ij}}$.\n- For the external potentials, forces are computed as $\\mathbf{F}^{\\text{ext}} = -\\nabla U_{\\text{ext}}$.\n- Conservation is checked by comparing the absolute value of the computed Poisson bracket component against the tolerance $\\tau = 10^{-12}$.\n\nThe following program calculates $\\{\\mathbf{L}, H\\}$ and the corresponding conservation booleans for the five test cases specified.",
            "answer": "```python\nimport numpy as np\n\ndef v_lj_derivative(r):\n    \"\"\"\n    Computes the derivative of the Lennard-Jones potential dV/dr in reduced units.\n    V(r) = 4 * (r^-12 - r^-6)\n    dV/dr = 4 * (-12*r^-13 - (-6)*r^-7) = 24 * (r^-7 - 2*r^-13)\n    \"\"\"\n    if r == 0:\n        return np.inf\n    r_inv = 1.0 / r\n    r7_inv = r_inv**7\n    r13_inv = r_inv**13\n    return 24.0 * (r7_inv - 2.0 * r13_inv)\n\ndef compute_poisson_bracket(N, masses, positions, pair_potential, ext_potential_params):\n    \"\"\"\n    Computes the vector Poisson bracket {L, H} which equals the total torque.\n    \n    Args:\n        N (int): Number of particles.\n        masses (list): List of particle masses.\n        positions (np.ndarray): (N, 3) array of particle positions.\n        pair_potential (str or None): Type of pair potential ('LJ' or None).\n        ext_potential_params (dict): Parameters for the external potential.\n\n    Returns:\n        np.ndarray: The 3D vector {L, H}.\n    \"\"\"\n    total_torque = np.zeros(3, dtype=float)\n    \n    for i in range(N):\n        force_i = np.zeros(3, dtype=float)\n        \n        # Internal forces (from pair potential)\n        if pair_potential == 'LJ':\n            for j in range(N):\n                if i == j:\n                    continue\n                r_ij_vec = positions[i] - positions[j]\n                r_ij_mag = np.linalg.norm(r_ij_vec)\n                \n                if r_ij_mag > 0:\n                    dv_dr = v_lj_derivative(r_ij_mag)\n                    force_ij = -dv_dr * (r_ij_vec / r_ij_mag)\n                    force_i += force_ij\n\n        # External forces\n        if 'type' in ext_potential_params:\n            if ext_potential_params['type'] == 'quad':\n                k_vec = ext_potential_params['k']\n                force_ext = -k_vec * positions[i]\n                force_i += force_ext\n            \n            elif ext_potential_params['type'] == 'lin':\n                g_vec = ext_potential_params['g']\n                force_ext = g_vec\n                force_i += force_ext\n\n        torque_i = np.cross(positions[i], force_i)\n        total_torque += torque_i\n        \n    return total_torque\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # Case 1: Two-particle Lennard-Jones system\n        {\n            \"N\": 2, \"masses\": [1.0, 1.0],\n            \"positions\": np.array([[0.45, -0.30, 0.50], [-0.15, 0.80, 0.10]]),\n            \"pair_potential\": \"LJ\",\n            \"ext_potential_params\": {},\n            \"case_type\": \"components\"\n        },\n        # Case 2: Axis-symmetric quadratic potential\n        {\n            \"N\": 1, \"masses\": [1.0],\n            \"positions\": np.array([[0.60, -0.40, 0.30]]),\n            \"pair_potential\": None,\n            \"ext_potential_params\": {\"type\": \"quad\", \"k\": np.array([30.0, 30.0, 50.0])},\n            \"case_type\": \"components\"\n        },\n        # Case 3: Fully anisotropic quadratic potential\n        {\n            \"N\": 1, \"masses\": [1.0],\n            \"positions\": np.array([[0.60, 0.50, -0.25]]),\n            \"pair_potential\": None,\n            \"ext_potential_params\": {\"type\": \"quad\", \"k\": np.array([20.0, 30.0, 40.0])},\n            \"case_type\": \"components\"\n        },\n        # Case 4: Two-particle LJ with a linear field along z\n        {\n            \"N\": 2, \"masses\": [1.0, 1.0],\n            \"positions\": np.array([[0.25, -0.35, 0.45], [-0.40, 0.15, 0.20]]),\n            \"pair_potential\": \"LJ\",\n            \"ext_potential_params\": {\"type\": \"lin\", \"g\": np.array([0.0, 0.0, 2.0])},\n            \"case_type\": \"components\"\n        },\n        # Case 5: Two-particle LJ with a general linear field\n        {\n            \"N\": 2, \"masses\": [1.0, 1.0],\n            \"positions\": np.array([[0.10, 0.20, 0.30], [-0.25, 0.05, 0.15]]),\n            \"pair_potential\": \"LJ\",\n            \"ext_potential_params\": {\"type\": \"lin\", \"g\": np.array([1.0, 2.0, 3.0])},\n            \"case_type\": \"projection\"\n        }\n    ]\n\n    TOLERANCE = 1e-12\n    results = []\n\n    for case in test_cases:\n        poisson_bracket_L_H = compute_poisson_bracket(\n            case[\"N\"],\n            case[\"masses\"],\n            case[\"positions\"],\n            case[\"pair_potential\"],\n            case[\"ext_potential_params\"]\n        )\n        \n        pb_x, pb_y, pb_z = poisson_bracket_L_H\n\n        if case[\"case_type\"] == \"components\":\n            cons_x = abs(pb_x) <= TOLERANCE\n            cons_y = abs(pb_y) <= TOLERANCE\n            cons_z = abs(pb_z) <= TOLERANCE\n            case_result = [pb_x, pb_y, pb_z, cons_x, cons_y, cons_z]\n            results.append(f\"[{','.join(map(str, case_result))}]\")\n\n        elif case[\"case_type\"] == \"projection\":\n            g_vec = case[\"ext_potential_params\"]['g']\n            # {L.g, H} = g . {L, H}\n            pb_L_dot_g_H = np.dot(g_vec, poisson_bracket_L_H)\n            cons_g = abs(pb_L_dot_g_H) <= TOLERANCE\n            case_result = [pb_x, pb_y, pb_z, cons_g]\n            results.append(f\"[{','.join(map(str, case_result))}]\")\n    \n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "This final practice elevates the concept of the Poisson bracket from a verification tool to a powerful discovery engine in computational physics. In complex systems, constants of motion beyond the obvious ones (energy, momentum) may not be immediately apparent. This exercise guides you to implement an algorithm that numerically evaluates the condition $\\{C, H\\} \\approx 0$ for a list of candidate observables $C$ along a microcanonical trajectory generated by a molecular dynamics simulation. By designing a robust, normalized diagnostic, you can systematically scan for \"hidden\" or approximate constants of motion directly from simulation data, a technique that mirrors modern research practices for analyzing the dynamics of complex systems .",
            "id": "3435703",
            "problem": "Consider a finite cluster of $N$ identical point particles in three spatial dimensions interacting through the Lennard-Jones pair potential in reduced Lennard-Jones units (all quantities are dimensionless). The Hamiltonian is\n$$\nH(\\mathbf r,\\mathbf p) \\;=\\; \\sum_{i=1}^{N} \\frac{\\mathbf p_i^2}{2} \\;+\\; \\sum_{1\\le i<j\\le N} 4\\left[\\left(\\frac{1}{r_{ij}}\\right)^{12} - \\left(\\frac{1}{r_{ij}}\\right)^{6}\\right],\n$$\nwhere $\\mathbf r=(\\mathbf r_1,\\dots,\\mathbf r_N)$, $\\mathbf p=(\\mathbf p_1,\\dots,\\mathbf p_N)$, $\\mathbf r_i\\in\\mathbb R^3$, $\\mathbf p_i\\in\\mathbb R^3$, and $r_{ij}=\\|\\mathbf r_i-\\mathbf r_j\\|_2$. Let the equations of motion be Hamilton’s equations, integrated numerically by a symplectic scheme to generate a microcanonical trajectory.\n\nGiven a candidate scalar collective variable $C(\\mathbf r,\\mathbf p)$, recall the Poisson bracket\n$$\n\\{C,H\\} \\;=\\; \\sum_{i=1}^{N}\\left(\\frac{\\partial C}{\\partial \\mathbf r_i}\\cdot\\frac{\\partial H}{\\partial \\mathbf p_i} \\;-\\; \\frac{\\partial C}{\\partial \\mathbf p_i}\\cdot\\frac{\\partial H}{\\partial \\mathbf r_i}\\right).\n$$\nA fundamental property is that along the Hamiltonian flow, the total time derivative satisfies $\\frac{\\mathrm d C}{\\mathrm dt}=\\{C,H\\}$. Therefore, if $\\{C,H\\}=0$ identically, then $C$ is a constant of motion. In numerical trajectories, exact equality is replaced by an approximate criterion evaluated along the trajectory.\n\nYour task is to write a complete program that, for a fixed list of candidate collective variables $C_k(\\mathbf r,\\mathbf p)$, computes an *a posteriori* diagnostic of “hidden” constants of motion by evaluating the normalized instantaneous Poisson bracket magnitude along microcanonical trajectories and flagging those $C_k$ for which this diagnostic remains small over long times. The normalization must be based only on quantities available from the definitions (no oracle data), and the diagnostic must be aggregated over time by a robust statistic to mitigate outliers.\n\nUse the following normalization at each time $t$:\n$$\nb_k(t) \\;=\\; \\left|\\{C_k,H\\}(t)\\right|,\\qquad\nB_k(t) \\;=\\; \\sum_{i=1}^{N}\\Big(\\big\\|\\nabla_{\\mathbf r_i} C_k\\big\\|_2\\,\\big\\|\\tfrac{\\partial H}{\\partial \\mathbf p_i}\\big\\|_2 \\;+\\; \\big\\|\\nabla_{\\mathbf p_i} C_k\\big\\|_2\\,\\big\\|\\tfrac{\\partial H}{\\partial \\mathbf r_i}\\big\\|_2\\Big),\n$$\nand the instantaneous normalized violation\n$$\n\\rho_k(t) \\;=\\; \\frac{b_k(t)}{B_k(t)+\\varepsilon},\n$$\nwhere $\\varepsilon$ is a small positive scalar to avoid division by zero when both gradients vanish. Aggregate $\\rho_k(t)$ over the second half of the trajectory by the median,\n$$\n\\widehat{\\rho}_k \\;=\\; \\operatorname{median}\\{\\rho_k(t_j): t_j \\text{ in the second half of sampled times}\\}.\n$$\nFlag $C_k$ as an approximate constant of motion if $\\widehat{\\rho}_k < \\tau$, where $\\tau$ is a user-specified threshold.\n\nImplement the algorithm with the following fixed candidate list, each indexed by $k$ and defined for any $N$:\n- $k=0$: total energy $C_0=H$.\n- $k=1$: squared total linear momentum $C_1=\\|\\sum_{i=1}^{N}\\mathbf p_i\\|_2^2$.\n- $k=2$: squared total angular momentum $C_2=\\|\\sum_{i=1}^{N}\\mathbf r_i\\times \\mathbf p_i\\|_2^2$.\n- $k=3$: $x$-component of the center-of-mass position $C_3=\\frac{1}{N}\\sum_{i=1}^{N} (\\mathbf r_i)_x$.\n- $k=4$: the virial $C_4=\\sum_{i=1}^{N}\\mathbf r_i\\cdot \\mathbf p_i$.\n- $k=5$: the sum of squared pair distances $C_5=\\sum_{1\\le i<j\\le N}\\|\\mathbf r_i-\\mathbf r_j\\|_2^2$.\n- $k=6$: kinetic energy $C_6=\\sum_{i=1}^{N}\\frac{\\mathbf p_i^2}{2}$.\n- $k=7$: potential energy $C_7=\\sum_{1\\le i<j\\le N} 4\\left[\\left(\\frac{1}{r_{ij}}\\right)^{12} - \\left(\\frac{1}{r_{ij}}\\right)^{6}\\right]$.\n- $k=8$: moment of inertia about the center of mass $C_8=\\sum_{i=1}^{N}\\|\\mathbf r_i-\\mathbf R_{\\mathrm{cm}}\\|_2^2$ with $\\mathbf R_{\\mathrm{cm}}=\\frac{1}{N}\\sum_{i=1}^{N}\\mathbf r_i$.\n\nYou must:\n- Integrate the equations of motion by the velocity-Verlet scheme with time step $\\Delta t$ and number of steps $S$.\n- Compute $\\{C_k,H\\}$ using analytic gradients of $C_k$ and $H$ with respect to $\\mathbf r$ and $\\mathbf p$ at each sampled step.\n- Use $\\varepsilon=10^{-12}$ and threshold $\\tau=10^{-8}$.\n- Use reduced Lennard-Jones units (dimensionless).\n- Initialize positions by placing particles at random in a cube and rejecting any new particle closer than a minimum separation to existing ones; initialize momenta by sampling independent standard normal components. For cases that require vanishing total momentum, remove the center-of-mass momentum exactly by subtracting the mean momentum from each particle. Use fixed random seeds to ensure reproducibility.\n\nDesign a test suite with three cases that exercise the detection logic:\n- Case A (happy path with center-of-mass at rest): $N=4$, $S=4000$, $\\Delta t=5\\times 10^{-3}$, seed $=42$, center-of-mass momentum removed.\n- Case B (center-of-mass drifting): $N=3$, $S=4000$, $\\Delta t=5\\times 10^{-3}$, seed $=7$, center-of-mass momentum not removed.\n- Case C (shorter trajectory): $N=4$, $S=3000$, $\\Delta t=2\\times 10^{-3}$, seed $=123$, center-of-mass momentum removed.\n\nFor each case, run the simulation, evaluate $\\widehat{\\rho}_k$ for all $k\\in\\{0,1,2,3,4,5,6,7,8\\}$, and return the list of indices $k$ that are flagged as approximate constants of motion according to the rule $\\widehat{\\rho}_k<\\tau$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is the list of flagged indices for one case, in the order A, B, C. For example, the output format must be exactly like\n$[ [k_{A,1},k_{A,2},\\dots], [k_{B,1},k_{B,2},\\dots], [k_{C,1},k_{C,2},\\dots] ]$\nwith no spaces between numbers or lists. No external inputs are allowed and no units other than reduced Lennard-Jones units are used. Angles, if any appear implicitly in cross products, are in radians but you should not output angles.\n\nThe final output type must be a list of lists of integers. The program must be a complete, runnable program that outputs only this single line.",
            "solution": "The user-provided problem is a well-defined task in computational physics, asking for the implementation of a numerical diagnostic to identify approximate constants of motion in a molecular dynamics simulation. The problem is scientifically grounded in Hamiltonian mechanics, methodologically sound, and provides all necessary parameters for a reproducible solution. All given equations and definitions are standard and correct. Therefore, the problem is deemed valid.\n\nThe solution proceeds as follows:\n\n1.  **Theoretical Foundation**: The core of the problem lies in the Poisson bracket, $\\{C, H\\}$, which governs the time evolution of any observable $C$ under a Hamiltonian $H$. A quantity $C$ is a constant of motion if and only if $\\{C, H\\} = 0$. For an isolated system of particles interacting via central forces, fundamental principles guarantee the conservation of total energy ($H$), total linear momentum ($\\mathbf{P} = \\sum_i \\mathbf{p}_i$), and total angular momentum ($\\mathbf{L} = \\sum_i \\mathbf{r}_i \\times \\mathbf{p}_i$). The candidates $C_0=H$, $C_1=\\|\\mathbf{P}\\|^2$, and $C_2=\\|\\mathbf{L}\\|^2$ are therefore expected to be constants of motion. Other candidates are generally not conserved, though some, like $C_3$ (a component of the center-of-mass position), may be conserved under specific conditions (i.e., vanishing total momentum).\n\n2.  **Numerical Integration**: The particle trajectories are generated by integrating Hamilton's equations of motion. The specified velocity-Verlet algorithm is used, which is a symplectic integrator known for its excellent long-term stability and good (though not exact) energy conservation. For a system with mass $m=1$ in reduced units, the update scheme is:\n    $$\n    \\begin{align*}\n    \\mathbf{r}(t+\\Delta t) &= \\mathbf{r}(t) + \\mathbf{p}(t)\\Delta t + \\frac{1}{2}\\mathbf{F}(t)\\Delta t^2 \\\\\n    \\mathbf{F}(t+\\Delta t) &= -\\nabla_{\\mathbf r} V(\\mathbf{r}(t+\\Delta t)) \\\\\n    \\mathbf{p}(t+\\Delta t) &= \\mathbf{p}(t) + \\frac{1}{2}\\left(\\mathbf{F}(t) + \\mathbf{F}(t+\\Delta t)\\right)\\Delta t\n    \\end{align*}\n    $$\n    where $\\mathbf{F}_i$ is the force on particle $i$, and $V$ is the Lennard-Jones potential.\n\n3.  **Diagnostic Calculation**: At each sampled time step in the second half of the trajectory, we must evaluate the normalized Poisson bracket violation, $\\rho_k(t)$. This requires the analytical gradients of the Hamiltonian $H$ and each candidate function $C_k$ with respect to all particle positions $\\mathbf{r}_i$ and momenta $\\mathbf{p}_i$.\n\n    **Gradients of the Hamiltonian ($H$):**\n    $$\n    \\frac{\\partial H}{\\partial \\mathbf{p}_i} = \\mathbf{p}_i \\quad (\\text{since } m=1)\n    $$\n    $$\n    \\frac{\\partial H}{\\partial \\mathbf{r}_i} = \\frac{\\partial V}{\\partial \\mathbf{r}_i} = -\\mathbf{F}_i = \\sum_{j \\neq i} 24\\left(2r_{ij}^{-14} - r_{ij}^{-8}\\right)(\\mathbf{r}_i - \\mathbf{r}_j)\n    $$\n\n    **Gradients of the Candidates ($C_k$):** The gradients for each of the nine candidates are derived analytically. For example:\n    -   $C_1 = \\|\\sum_j \\mathbf{p}_j\\|^2$: $\\nabla_{\\mathbf{r}_i} C_1 = \\mathbf{0}$, $\\nabla_{\\mathbf{p}_i} C_1 = 2 \\sum_j \\mathbf{p}_j$.\n    -   $C_2 = \\|\\sum_j \\mathbf{r}_j \\times \\mathbf{p}_j\\|^2$: Let $\\mathbf{L} = \\sum_j \\mathbf{r}_j \\times \\mathbf{p}_j$. Then $\\nabla_{\\mathbf{r}_i} C_2 = 2(\\mathbf{p}_i \\times \\mathbf{L})$ and $\\nabla_{\\mathbf{p}_i} C_2 = 2(\\mathbf{L} \\times \\mathbf{r}_i)$.\n    -   $C_3 = \\frac{1}{N}\\sum_j (\\mathbf{r}_j)_x$: $\\nabla_{\\mathbf{r}_i} C_3 = \\frac{1}{N}\\hat{\\mathbf{x}}$, $\\nabla_{\\mathbf{p}_i} C_3 = \\mathbf{0}$.\n    (The full set of gradients is implemented in the code.)\n\n4.  **Poisson Bracket and Normalization**: With these gradients, the Poisson bracket $\\{C_k, H\\}$ and the normalization factor $B_k(t)$ are computed at each time step $t$:\n    $$\n    \\{C_k,H\\}(t) = \\sum_{i=1}^{N}\\left(\\nabla_{\\mathbf r_i} C_k \\cdot \\frac{\\partial H}{\\partial \\mathbf p_i} - \\nabla_{\\mathbf p_i} C_k \\cdot \\frac{\\partial H}{\\partial \\mathbf r_i}\\right)\n    $$\n    $$\n    B_k(t) = \\sum_{i=1}^{N}\\left(\\|\\nabla_{\\mathbf r_i} C_k\\|_2 \\|\\frac{\\partial H}{\\partial \\mathbf p_i}\\|_2 + \\|\\nabla_{\\mathbf p_i} C_k\\|_2 \\|\\frac{\\partial H}{\\partial \\mathbf r_i}\\|_2\\right)\n    $$\n    The instantaneous violation is $\\rho_k(t) = \\frac{|\\{C_k, H\\}|}{B_k(t) + \\varepsilon}$ with $\\varepsilon=10^{-12}$. The normalization $B_k(t)$ is designed based on the triangle and Cauchy-Schwarz inequalities to be an upper bound for $|\\{C_k,H\\}|$, ensuring $\\rho_k(t) \\in [0, 1]$.\n\n5.  **Aggregation and Flagging**: The time-series $\\{\\rho_k(t_j)\\}$ for the second half of the simulation is aggregated using the median, a robust statistic, to obtain $\\widehat{\\rho}_k$. A candidate $C_k$ is flagged as an approximate constant of motion if its median violation $\\widehat{\\rho}_k$ is below the threshold $\\tau=10^{-8}$.\n\n6.  **Implementation**: A Python script using `NumPy` is developed. It encapsulates the simulation logic in a function that takes simulation parameters as input. The script is structured to run the three specified test cases, perform the analysis for all nine candidate functions in each case, and format the final output as a single-line list of lists of flagged indices, as requested. The implementation uses `float64` for precision and fixed random seeds for reproducibility.\n    - **Case A** ($N=4$, $\\mathbf{P}=\\mathbf{0}$): Expected to flag $k=0,1,2,3$.\n    - **Case B** ($N=3$, $\\mathbf{P}\\neq\\mathbf{0}$): Expected to flag $k=0,1,2$. $C_3$ is not conserved as $\\{C_3, H\\} = P_x/N \\neq 0$.\n    - **Case C** ($N=4$, $\\mathbf{P}=\\mathbf{0}$): Expected to flag $k=0,1,2,3$.\n\nThe final code implements this complete workflow.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Global constants as per problem statement\nEPSILON = 1e-12\nTAU = 1e-8\n\n\ndef lennard_jones_forces(r):\n    \"\"\"Computes forces for all particles and total potential energy.\"\"\"\n    N = r.shape[0]\n    forces = np.zeros_like(r)\n    potential_energy = 0.0\n    for i in range(N):\n        for j in range(i + 1, N):\n            rij_vec = r[i] - r[j]\n            r_sq = np.dot(rij_vec, rij_vec)\n            \n            # Avoid division by zero for overlapping particles\n            if r_sq < 1e-16: continue\n                \n            r_inv2 = 1.0 / r_sq\n            r_inv6 = r_inv2**3\n            r_inv12 = r_inv6**2\n            \n            potential_energy += 4.0 * (r_inv12 - r_inv6)\n            \n            force_mag = 24.0 * (2.0 * r_inv12 - r_inv6) * r_inv2\n            force_vec = force_mag * rij_vec\n            \n            forces[i] += force_vec\n            forces[j] -= force_vec\n            \n    return forces, potential_energy\n\ndef initialize_system(N, seed, remove_com_p):\n    \"\"\"Initializes particle positions and momenta.\"\"\"\n    rng = np.random.default_rng(seed)\n    \n    # Initialize positions randomly in a cube with a minimum separation\n    L = 4.0  # Cube side length\n    min_dist_sq = 1.0**2\n    r = np.zeros((N, 3), dtype=np.float64)\n    \n    max_attempts = 1000\n    for attempt in range(max_attempts):\n        r = rng.uniform(0, L, size=(N, 3))\n        valid = True\n        for i in range(N):\n            for j in range(i + 1, N):\n                dist_sq = np.sum((r[i] - r[j])**2)\n                if dist_sq < min_dist_sq:\n                    valid = False\n                    break\n            if not valid:\n                break\n        if valid:\n            break\n    if not valid:\n        # Fallback for rare cases where initialization fails\n        raise RuntimeError(\"Could not initialize non-overlapping particle positions.\")\n            \n    # Initialize momenta from a standard normal distribution\n    p = rng.normal(0, 1, size=(N, 3)).astype(np.float64)\n    \n    if remove_com_p:\n        p_com = np.mean(p, axis=0)\n        p -= p_com\n        \n    return r, p\n\ndef get_candidate_gradients(r, p, forces):\n    \"\"\"\n    Computes gradients for all 9 candidate functions w.r.t r and p.\n    \"\"\"\n    N = r.shape[0]\n    \n    grad_r_C_list = [np.zeros((N, 3)) for _ in range(9)]\n    grad_p_C_list = [np.zeros((N, 3)) for _ in range(9)]\n    \n    # Common quantities\n    grad_r_H = -forces\n    P_tot = np.sum(p, axis=0)\n    L_tot = np.sum(np.cross(r, p), axis=0)\n    R_cm = np.mean(r, axis=0)\n\n    # C0 = H\n    grad_r_C_list[0] = grad_r_H\n    grad_p_C_list[0] = p\n    \n    # C1 = ||P_tot||^2\n    grad_p_C_list[1] = np.tile(2 * P_tot, (N, 1))\n\n    # C2 = ||L_tot||^2\n    grad_r_C_list[2] = 2 * np.cross(p, np.tile(L_tot, (N, 1)))\n    grad_p_C_list[2] = 2 * np.cross(np.tile(L_tot, (N, 1)), r)\n\n    # C3 = R_cm_x\n    grad_r_C_list[3][:, 0] = 1.0 / N\n\n    # C4 = sum(r_i . p_i)\n    grad_r_C_list[4] = p\n    grad_p_C_list[4] = r\n\n    # C5 = sum_{i<j} ||r_i - r_j||^2\n    grad_r_C_list[5] = 2 * N * (r - R_cm)\n    \n    # C6 = Kinetic Energy\n    grad_p_C_list[6] = p\n    \n    # C7 = Potential Energy\n    grad_r_C_list[7] = grad_r_H\n    \n    # C8 = Moment of inertia about CM\n    grad_r_C_list[8] = 2 * (r - R_cm)\n\n    return grad_r_C_list, grad_p_C_list\n\ndef run_simulation(N, S, dt, seed, remove_com_p):\n    \"\"\"Runs a single MD simulation and computes diagnostics.\"\"\"\n    r, p = initialize_system(N, seed, remove_com_p)\n    forces, _ = lennard_jones_forces(r)\n    \n    rho_trajectories = [[] for _ in range(9)]\n    start_sampling_step = S // 2\n    \n    for step in range(S):\n        # Velocity-Verlet integrator\n        r += p * dt + 0.5 * forces * dt**2\n        forces_new, _ = lennard_jones_forces(r)\n        p += 0.5 * (forces + forces_new) * dt\n        forces = forces_new\n\n        # Sample diagnostics in the second half of the trajectory\n        if step >= start_sampling_step:\n            grad_r_H = -forces\n            grad_p_H = p\n            \n            grad_r_C_list, grad_p_C_list = get_candidate_gradients(r, p, forces)\n            \n            for k in range(9):\n                grad_r_Ck = grad_r_C_list[k]\n                grad_p_Ck = grad_p_C_list[k]\n                \n                # Compute Poisson Bracket {C_k, H}\n                pb_terms = np.sum(grad_r_Ck * grad_p_H, axis=1) - np.sum(grad_p_Ck * grad_r_H, axis=1)\n                pb = np.sum(pb_terms)\n                b_k = np.abs(pb)\n                \n                # Compute normalization factor B_k\n                norm_grad_r_Ck = np.linalg.norm(grad_r_Ck, axis=1)\n                norm_grad_p_Ck = np.linalg.norm(grad_p_Ck, axis=1)\n                norm_grad_r_H = np.linalg.norm(grad_r_H, axis=1)\n                norm_grad_p_H = np.linalg.norm(grad_p_H, axis=1)\n                \n                B_k = np.sum(norm_grad_r_Ck * norm_grad_p_H + norm_grad_p_Ck * norm_grad_r_H)\n                \n                rho_k = b_k / (B_k + EPSILON)\n                rho_trajectories[k].append(rho_k)\n                \n    # Aggregate results and flag constants of motion\n    flagged_indices = []\n    for k in range(9):\n        if rho_trajectories[k]:\n            rho_hat = np.median(rho_trajectories[k])\n            if rho_hat < TAU:\n                flagged_indices.append(k)\n                \n    return flagged_indices\n\ndef solve():\n    \"\"\"Main function to run all test cases and print results.\"\"\"\n    test_cases = [\n        # Case A: N=4, S=4000, dt=5e-3, seed=42, COM momentum removed\n        {'N': 4, 'S': 4000, 'dt': 5e-3, 'seed': 42, 'remove_com_p': True},\n        # Case B: N=3, S=4000, dt=5e-3, seed=7, COM momentum not removed\n        {'N': 3, 'S': 4000, 'dt': 5e-3, 'seed': 7, 'remove_com_p': False},\n        # Case C: N=4, S=3000, dt=2e-3, seed=123, COM momentum removed\n        {'N': 4, 'S': 3000, 'dt': 2e-3, 'seed': 123, 'remove_com_p': True},\n    ]\n\n    all_results = []\n    for params in test_cases:\n        result = run_simulation(**params)\n        all_results.append(result)\n\n    # Format the output string exactly as required, with no spaces\n    result_str = ','.join([f\"[{','.join(map(str, sorted(res)))}]\" for res in all_results])\n    print(f\"[{result_str}]\")\n\nsolve()\n```"
        }
    ]
}