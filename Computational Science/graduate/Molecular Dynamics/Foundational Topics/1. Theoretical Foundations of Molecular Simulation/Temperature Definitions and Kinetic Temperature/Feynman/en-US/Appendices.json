{
    "hands_on_practices": [
        {
            "introduction": "The kinetic temperature $T_{\\mathrm{kin}}$ is fundamentally linked to the system's kinetic energy $K$ through the equipartition theorem, $\\langle K \\rangle = \\frac{f}{2} k_{\\mathrm{B}} T_{\\mathrm{kin}}$. The accuracy of this definition critically depends on the correct determination of $f$, the number of active quadratic degrees of freedom. This first exercise provides a hands-on derivation of $f$ for a general system subject to both internal holonomic constraints and the removal of global rigid-body motion, a foundational skill for analyzing any constrained simulation .",
            "id": "3451703",
            "problem": "Consider a three-dimensional atomistic molecular dynamics simulation of a generic, non-degenerate gas-phase cluster of $N$ particles with masses $m_i$, positions $\\mathbf{r}_i$, and velocities $\\mathbf{v}_i$, where $i \\in \\{1,\\dots,N\\}$. Suppose $C$ independent holonomic constraints $\\phi_{\\alpha}(\\mathbf{r}) = 0$, with $\\alpha \\in \\{1,\\dots,C\\}$, are enforced at all times by a holonomic constraint algorithm such as the SHAKE method, so that the motion is confined to the constraint manifold. The kinetic energy is $K = \\frac{1}{2}\\sum_{i=1}^{N} m_i |\\mathbf{v}_i|^2$, and the kinetic temperature $T_{\\mathrm{kin}}$ is defined by equipartition through $\\langle K \\rangle = \\frac{f}{2} k_{\\mathrm{B}} T_{\\mathrm{kin}}$, where $k_{\\mathrm{B}}$ is the Boltzmann constant and $f$ is the number of active quadratic degrees of freedom contributing to $K$.\n\nIn addition to the holonomic constraints, the integrator enforces zero total linear momentum and possibly zero total angular momentum about the instantaneous center of mass at every time step. Specifically, the following linear velocity constraints may be imposed:\n- Zero total linear momentum: $\\mathbf{P} \\equiv \\sum_{i=1}^{N} m_i \\mathbf{v}_i = \\mathbf{0}$.\n- Zero total angular momentum: $\\mathbf{L} \\equiv \\sum_{i=1}^{N} \\mathbf{r}_i \\times (m_i \\mathbf{v}_i) = \\mathbf{0}$.\n\nAssume the inertia tensor of the cluster is full rank and that the holonomic constraints are independent of global translations and rotations, so they do not themselves fix the center of mass or the overall orientation.\n\nStarting from Newton’s laws with holonomic constraints enforced via Lagrange multipliers, the equipartition theorem, and basic linear algebra on constrained velocity spaces, derive the dimension of the subspace of velocities that is dynamically accessible under all constraints. From this, determine the correct count $f$ of active quadratic degrees of freedom entering the definition of $T_{\\mathrm{kin}}$. Introduce indicator variables $\\chi_t$ and $\\chi_r$ to encode whether the global velocity constraints are enforced: $\\chi_t = 1$ if zero total linear momentum is imposed and $\\chi_t = 0$ otherwise; $\\chi_r = 1$ if zero total angular momentum is imposed and $\\chi_r = 0$ otherwise. Finally, identify $d_{\\mathrm{rigid}}$, the total number of rigid-body degrees of freedom removed by these global constraints, in terms of $\\chi_t$ and $\\chi_r$.\n\nReport your final result as a two-entry row vector $(f, d_{\\mathrm{rigid}})$. No numerical evaluation is required. Express your answer as a closed-form analytic expression.",
            "solution": "The problem requires the determination of the number of active quadratic degrees of freedom, $f$, and the number of removed rigid-body degrees of freedom, $d_{\\mathrm{rigid}}$, for a system of $N$ particles subject to various constraints. The solution is derived by systematically counting the dimensions of the accessible velocity space.\n\nThe state of the system at any given time can be described by the positions $\\mathbf{r}_i$ and velocities $\\mathbf{v}_i$ of the $N$ particles in three-dimensional space. The total number of velocity components is $3N$, which corresponds to the dimension of the unconstrained velocity space. The number of active quadratic degrees of freedom, $f$, is the dimension of the subspace of velocities that are dynamically accessible to the system under all imposed constraints.\n\n1.  **Initial Degrees of Freedom**: For a system of $N$ free particles in $3$-dimensional space, there are $3N$ translational degrees of freedom, each corresponding to a component of a particle's velocity vector $\\mathbf{v}_i$. The total kinetic energy is a quadratic function of these $3N$ velocity components. In the absence of any constraints, we would have $f = 3N$.\n\n2.  **Holonomic Constraints**: The system is subject to $C$ independent holonomic constraints of the form $\\phi_{\\alpha}(\\mathbf{r}_1, \\dots, \\mathbf{r}_N) = 0$ for $\\alpha \\in \\{1, \\dots, C\\}$. For these constraints to be maintained at all times, their time derivatives must be zero. This imposes constraints on the particle velocities:\n    $$ \\frac{d\\phi_{\\alpha}}{dt} = \\sum_{i=1}^{N} \\frac{\\partial \\phi_{\\alpha}}{\\partial \\mathbf{r}_i} \\cdot \\frac{d\\mathbf{r}_i}{dt} = \\sum_{i=1}^{N} (\\nabla_{\\mathbf{r}_i} \\phi_{\\alpha}) \\cdot \\mathbf{v}_i = 0 $$\n    Each of these $C$ equations represents a linear constraint on the $3N$ velocity components. As the problem states these constraints are independent, they define $C$ linearly independent hyperplanes in the $3N$-dimensional velocity space. The intersection of these hyperplanes reduces the dimension of the accessible velocity subspace by $C$.\n    Number of degrees of freedom after holonomic constraints: $3N - C$.\n\n3.  **Global Translational Constraint**: The constraint of zero total linear momentum, $\\mathbf{P} = \\mathbf{0}$, is given by:\n    $$ \\mathbf{P} = \\sum_{i=1}^{N} m_i \\mathbf{v}_i = \\mathbf{0} $$\n    This is a vector equation, equivalent to three independent scalar linear constraints on the velocity components:\n    $$ \\sum_{i=1}^{N} m_i v_{i,x} = 0 $$\n    $$ \\sum_{i=1}^{N} m_i v_{i,y} = 0 $$\n    $$ \\sum_{i=1}^{N} m_i v_{i,z} = 0 $$\n    These constraints remove the $3$ degrees of freedom corresponding to the collective motion of the center of mass. The indicator variable $\\chi_t$ determines if these constraints are applied. Thus, they reduce the number of degrees of freedom by $3\\chi_t$.\n\n4.  **Global Rotational Constraint**: The constraint of zero total angular momentum about the center of mass, $\\mathbf{L} = \\mathbf{0}$, is given by:\n    $$ \\mathbf{L} = \\sum_{i=1}^{N} (\\mathbf{r}_i - \\mathbf{R}_{\\mathrm{CM}}) \\times (m_i \\mathbf{v}_i) = \\mathbf{0} $$\n    where $\\mathbf{R}_{\\mathrm{CM}}$ is the position of the center of mass. (Note: Using $\\mathbf{r}_i$ directly as in the problem statement is valid if the origin is chosen as the center of mass, which is a common convention when removing center-of-mass motion). This vector equation is equivalent to three independent scalar linear constraints on the velocity components, removing the $3$ degrees of freedom corresponding to the rigid-body rotation of the cluster as a whole. The indicator variable $\\chi_r$ determines if these constraints are applied. Thus, they reduce the number of degrees of freedom by $3\\chi_r$.\n\n5.  **Independence of Constraints**: The problem states that the holonomic constraints are independent of global translations and rotations. This is a crucial condition. It means that the $C$ internal constraints (e.g., fixing bond lengths) do not conflict with or predetermine the constraints on the overall momentum or angular momentum. Furthermore, for a generic non-degenerate cluster (i.e., not all particles are collinear), the translational and rotational constraints are mutually independent. Therefore, the total number of independent constraints is the sum of the counts from each category.\n\n6.  **Calculation of $f$**: The final number of active quadratic degrees of freedom, $f$, is the initial total, $3N$, minus the total number of independent constraints.\n    $$ f = 3N - C - 3\\chi_t - 3\\chi_r $$\n    This is the dimension of the dynamically accessible velocity subspace, and it is this number that correctly enters the equipartition formula for the kinetic temperature: $\\langle K \\rangle = \\frac{f}{2} k_{\\mathrm{B}} T_{\\mathrm{kin}}$.\n\n7.  **Calculation of $d_{\\mathrm{rigid}}$**: The problem defines $d_{\\mathrm{rigid}}$ as the total number of rigid-body degrees of freedom removed by the global constraints on linear and angular momentum.\n    - The number of translational degrees of freedom removed is $3$ if $\\chi_t=1$ and $0$ if $\\chi_t=0$. This is $3\\chi_t$.\n    - The number of rotational degrees of freedom removed is $3$ if $\\chi_r=1$ and $0$ if $\\chi_r=0$. This is $3\\chi_r$.\n    The total number of removed rigid-body degrees of freedom is the sum of these two quantities:\n    $$ d_{\\mathrm{rigid}} = 3\\chi_t + 3\\chi_r $$\n    This allows us to write $f$ more compactly as $f = 3N - C - d_{\\mathrm{rigid}}$, which clearly separates the contributions from internal constraints ($C$) and rigid-body constraints ($d_{\\mathrm{rigid}}$).\n\nThe final result is the pair of expressions for $f$ and $d_{\\mathrm{rigid}}$.",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 3N - C - 3\\chi_t - 3\\chi_r & 3\\chi_t + 3\\chi_r \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "Building upon the correct theoretical framework, we now investigate the tangible impact of an incorrect degrees-of-freedom count—a frequent pitfall in post-processing simulation data. This exercise presents a realistic scenario involving a simulation of rigid water, where a naive temperature calculation yields a biased result. By quantifying this bias and calculating the corrected temperature, you will develop a practical intuition for the magnitude of such errors and the importance of rigorous analysis .",
            "id": "3451676",
            "problem": "A classical Molecular Dynamics (MD) simulation is carried out for a rigid three-site water model in the microcanonical ensemble. The system contains $N_{\\mathrm{mol}} = 1000$ water molecules, each with $3$ atoms. The geometry of each water molecule is maintained by $3$ holonomic constraints per molecule, and the total linear momentum of the system is removed, eliminating $3$ global degrees of freedom. The kinetic temperature is defined via the kinetic energy and the number of active degrees of freedom. However, a naive post-processing script computed the kinetic temperature using a degrees-of-freedom count that ignores the removal of constrained degrees of freedom, while still accounting for the removal of total linear momentum.\n\nSuppose the naive script reports a kinetic temperature of $T_{\\mathrm{kin}}^{\\mathrm{naive}} = 200 \\ \\mathrm{K}$, obtained from the instantaneous kinetic energy of the trajectory using a degrees-of-freedom count $f_{\\mathrm{naive}} = 3 N_{\\mathrm{atoms}} - 3$, where $N_{\\mathrm{atoms}} = 3 N_{\\mathrm{mol}}$. Using first-principles reasoning appropriate to classical MD and rigid constraints, determine:\n- the signed bias $\\Delta T$ in the naive kinetic temperature defined as $\\Delta T = T_{\\mathrm{kin}}^{\\mathrm{naive}} - T_{\\mathrm{kin}}^{\\mathrm{corr}}$, and\n- the corrected kinetic temperature $T_{\\mathrm{kin}}^{\\mathrm{corr}}$ that consistently accounts for the constrained degrees of freedom.\n\nAssume that the instantaneous kinetic energy is the same in both definitions of kinetic temperature and that the only difference arises from the degrees-of-freedom count. Express both $\\Delta T$ and $T_{\\mathrm{kin}}^{\\mathrm{corr}}$ in Kelvin. Round your answers to four significant figures.",
            "solution": "The problem requires us to find the corrected kinetic temperature $T_{\\mathrm{kin}}^{\\mathrm{corr}}$ and the signed bias $\\Delta T = T_{\\mathrm{kin}}^{\\mathrm{naive}} - T_{\\mathrm{kin}}^{\\mathrm{corr}}$. The core of the problem is the correct calculation of the number of degrees of freedom, $f$.\n\nThe kinetic temperature is defined from the total kinetic energy $E_k$ and the number of degrees of freedom $f$ via the equipartition theorem:\n$$ E_k = \\frac{f}{2} k_{\\mathrm{B}} T_{\\mathrm{kin}} $$\nSince $E_k$ and $k_{\\mathrm{B}}$ are the same for both the naive and corrected calculations, we have the relationship:\n$$ f_{\\mathrm{naive}} T_{\\mathrm{kin}}^{\\mathrm{naive}} = f_{\\mathrm{corr}} T_{\\mathrm{kin}}^{\\mathrm{corr}} $$\n\nFirst, we determine the number of atoms in the system:\n- Number of molecules, $N_{\\mathrm{mol}} = 1000$.\n- Atoms per molecule = 3.\n- Total atoms, $N_{\\mathrm{atoms}} = N_{\\mathrm{mol}} \\times 3 = 1000 \\times 3 = 3000$.\n\nNext, we calculate the naive number of degrees of freedom, $f_{\\mathrm{naive}}$, using the formula provided in the problem statement:\n$$ f_{\\mathrm{naive}} = 3 N_{\\mathrm{atoms}} - 3 = 3(3000) - 3 = 8997 $$\nThis count only subtracts the 3 degrees of freedom for the center-of-mass motion.\n\nNow, we calculate the corrected number of degrees of freedom, $f_{\\mathrm{corr}}$. We start with the total possible degrees of freedom, $3 N_{\\mathrm{atoms}}$, and subtract all constraints.\n- Number of holonomic constraints for rigidity: 3 constraints/molecule $\\times$ 1000 molecules = 3000 constraints.\n- Number of global degrees of freedom removed (total linear momentum): 3.\n$$ f_{\\mathrm{corr}} = 3 N_{\\mathrm{atoms}} - (\\text{holonomic constraints}) - (\\text{global constraints}) $$\n$$ f_{\\mathrm{corr}} = 3(3000) - 3000 - 3 = 9000 - 3003 = 5997 $$\nAlternatively, a rigid non-linear molecule (like water) has 3 translational and 3 rotational degrees of freedom, for a total of 6 per molecule. For $N_{\\mathrm{mol}}$ molecules, this is $6 N_{\\mathrm{mol}}$ degrees of freedom. After removing the 3 degrees of freedom for the overall center-of-mass translation, we get:\n$$ f_{\\mathrm{corr}} = 6 N_{\\mathrm{mol}} - 3 = 6(1000) - 3 = 5997 $$\nBoth methods yield the same correct number of degrees of freedom.\n\nNow we can calculate the corrected temperature $T_{\\mathrm{kin}}^{\\mathrm{corr}}$:\n$$ T_{\\mathrm{kin}}^{\\mathrm{corr}} = T_{\\mathrm{kin}}^{\\mathrm{naive}} \\left( \\frac{f_{\\mathrm{naive}}}{f_{\\mathrm{corr}}} \\right) = 200 \\, \\mathrm{K} \\times \\left( \\frac{8997}{5997} \\right) \\approx 300.050025... \\, \\mathrm{K} $$\nRounding to four significant figures, we get $T_{\\mathrm{kin}}^{\\mathrm{corr}} = 300.1 \\, \\mathrm{K}$.\n\nFinally, we calculate the signed bias $\\Delta T$:\n$$ \\Delta T = T_{\\mathrm{kin}}^{\\mathrm{naive}} - T_{\\mathrm{kin}}^{\\mathrm{corr}} = 200 \\, \\mathrm{K} - 300.1 \\, \\mathrm{K} = -100.1 \\, \\mathrm{K} $$\nThe naive script, by overcounting the degrees of freedom, significantly underestimated the system's temperature.",
            "answer": "$$\\boxed{\\begin{pmatrix}-100.1 & 300.1\\end{pmatrix}}$$"
        },
        {
            "introduction": "Beyond the statistical definition, the temperature measured in a simulation is also influenced by the numerical artifacts of the integration algorithm, specifically the finite time-step $h$. This practice introduces a powerful data analysis technique to systematically correct for this discretization error and estimate the true continuum-limit ($h \\to 0$) temperature. You will apply a multi-point Richardson extrapolation via weighted least-squares fitting, a sophisticated method essential for producing high-precision results in computational science .",
            "id": "3451698",
            "problem": "In molecular dynamics (MD), the kinetic temperature is defined from the equipartition theorem as the scalar $T$ that satisfies $K = \\frac{f}{2} k_{\\mathrm{B}} T$, where $K$ is the kinetic energy averaged over a trajectory sample, $f$ is the number of quadratic degrees of freedom, and $k_{\\mathrm{B}}$ is Boltzmann's constant. When a trajectory is generated by a finite time-step integrator that approximates Newton's laws, finite-step discretization biases the measured time-averaged kinetic temperature. For a consistent, $p$-th order accurate time-reversible integrator, it is well established that the bias of smooth observables admits an asymptotic expansion in powers of the time step $h$, with leading term proportional to $h^{p}$ for even $p$. In particular, assume that the measured kinetic temperature as a function of the time step is well modeled by\n$$\nT(h) = T_0 + c\\, h^{p} + \\varepsilon(h),\n$$\nwhere $T_0$ is the continuum ($h \\to 0$) kinetic temperature in Kelvin, $c$ is an unknown coefficient, and $\\varepsilon(h)$ represents higher-order truncation error terms and measurement noise. You are given, for several test datasets, a set of measured time steps $h_i$ (in femtoseconds), measured kinetic temperatures $T_i$ (in Kelvin), the known order $p$ of the integrator, and independent $1$-standard-deviation uncertainties $\\sigma_i$ (in Kelvin) for each $T_i$. Assume the $\\varepsilon(h)$ realizations are independent, zero-mean Gaussian with variances $\\sigma_i^2$, and that higher-order truncation terms are negligible at the provided $h_i$.\n\nTask: Implement a program that, for each dataset, performs a Richardson-style extrapolation to estimate $T_0$ and quantifies its $1$-standard-deviation uncertainty. Use a statistically principled approach consistent with the model $T(h) = T_0 + c\\, h^p + \\text{noise}$:\n- For $n \\ge 2$ data points, fit the linear model $y_i = a + b x_i$ with $x_i = h_i^{p}$ and $y_i = T_i$ by weighted least squares with weights $w_i = 1/\\sigma_i^2$, to obtain $a$ (estimate of $T_0$) and its standard uncertainty from the estimator covariance. This multi-point linear fit implements a multi-point Richardson extrapolation by eliminating the leading-order term in the sense of a best linear unbiased estimator. If only two points are given, this reduces to the two-point elimination of the $h^p$ term and yields the same $T_0$ as the two-point Richardson formula.\n- The estimator for $(a,b)$ is\n$$\n\\hat{\\beta} = \\begin{bmatrix} \\hat{a} \\\\ \\hat{b} \\end{bmatrix} = \\left(X^\\top W X\\right)^{-1} X^\\top W y,\n$$\nwhere $X$ is the $n \\times 2$ design matrix with rows $[1, x_i]$, $W = \\mathrm{diag}(w_1,\\dots,w_n)$, and $y$ is the vector of $y_i$ values. The covariance of $\\hat{\\beta}$ is\n$$\n\\mathrm{Cov}(\\hat{\\beta}) = \\left(X^\\top W X\\right)^{-1},\n$$\nso the $1$-standard-deviation uncertainty of $T_0$ is $u_{T_0} = \\sqrt{\\left[\\mathrm{Cov}(\\hat{\\beta})\\right]_{11}}$ (the square root of the $(1,1)$ entry).\n- Report $T_0$ and $u_{T_0}$, both in Kelvin, rounded to three decimal places.\n\nInput is embedded in the program; no external input is required. Use the following test suite of datasets, each specified by the triplet $(p,\\{h_i\\},\\{T_i\\},\\{\\sigma_i\\})$:\n- Dataset A (second-order integrator, three points, homoscedastic): $p = 2$, $h = [4, 2, 1]$ (femtoseconds), $T = [308.1, 301.8, 300.6]$ (Kelvin), $\\sigma = [0.2, 0.2, 0.2]$ (Kelvin).\n- Dataset B (second-order integrator, two points, homoscedastic): $p = 2$, $h = [3, 1.5]$ (femtoseconds), $T = [305.0, 301.3]$ (Kelvin), $\\sigma = [0.1, 0.1]$ (Kelvin).\n- Dataset C (second-order integrator, three points, heteroscedastic): $p = 2$, $h = [5, 2, 1]$ (femtoseconds), $T = [319.4, 303.5, 301.1]$ (Kelvin), $\\sigma = [0.5, 0.2, 0.1]$ (Kelvin).\n- Dataset D (fourth-order integrator, three points, homoscedastic): $p = 4$, $h = [4, 2, 1]$ (femtoseconds), $T = [302.5, 300.2, 300.0]$ (Kelvin), $\\sigma = [0.05, 0.05, 0.05]$ (Kelvin).\n\nAngle units do not apply. All temperatures must be expressed in Kelvin. Your program should produce a single line of output containing the results as a comma-separated list of lists, each inner list containing $[T_0, u_{T_0}]$ for one dataset, both rounded to three decimal places, in the order A, B, C, D. For example, the output format must be exactly like\n$[[T_{0,A},u_{A}],[T_{0,B},u_{B}],[T_{0,C},u_{C}],[T_{0,D},u_{D}]]$.",
            "solution": "The user wants to solve a problem. The user is a bot. The user wants me to solve this problem.\n\n### Problem Validation\n\nThe problem is valid.\n- **Scientifically Grounded:** The presented model, $T(h) = T_0 + c h^p + \\varepsilon(h)$, is a standard asymptotic expansion for the error of observables computed from trajectories generated by a symmetric $p$-th order numerical integrator. This is a well-established result in the field of geometric numerical integration, particularly relevant to molecular dynamics (MD). The use of weighted least squares (WLS) to fit this model to data with known heteroscedastic noise is a statistically rigorous and standard approach for parameter estimation. Richardson extrapolation, framed here as a linear fit, is a classical technique in numerical analysis. The setup is entirely consistent with established principles of physics, numerical analysis, and statistics.\n- **Well-Posed:** The problem is clearly defined. The data ($h_i, T_i, \\sigma_i, p$), model, and estimation method (WLS) are all explicitly provided. For each dataset, there are at least two data points ($n \\ge 2$), and the independent variables $x_i = h_i^p$ are distinct, which ensures that the matrix $X^\\top W X$ is invertible. Therefore, a unique solution for the parameters and their uncertainties exists.\n- **Objective:** The problem is phrased in objective, mathematical language. All quantities are precisely defined, and the task is to apply a specified algorithm to given data. There are no subjective elements.\n- **Completeness:** The problem provides all necessary information to proceed with the calculation for each of the four datasets.\n- **Consistency:** The provided formulas for the WLS estimator and its covariance matrix are correct under the given statistical assumptions.\n\nThe problem is deemed valid and a full solution will be provided.\n\n### Principle-Based Solution Design\n\nThe core task is to estimate the continuum temperature $T_0$ and its uncertainty from a set of MD simulation results obtained at different time steps $h$. The problem provides a model for how the measured temperature $T(h)$ depends on the time step:\n\n$$\nT_i = T_0 + c h_i^p + \\varepsilon_i\n$$\n\nwhere $T_i = T(h_i)$ is the measured temperature at time step $h_i$, $p$ is the order of the integrator, $T_0$ and $c$ are unknown constants, and $\\varepsilon_i$ is a random error term. The errors $\\varepsilon_i$ are assumed to be independent and normally distributed with zero mean and known variances $\\sigma_i^2$.\n\nThis model can be reframed as a linear regression problem. By defining a new independent variable $x_i = h_i^p$ and dependent variable $y_i = T_i$, the model becomes:\n\n$$\ny_i = a + b x_i + \\varepsilon_i\n$$\n\nHere, the intercept $a$ corresponds to the desired continuum temperature $T_0$, and the slope $b$ corresponds to the coefficient $c$.\n\nSince the measurement uncertainties $\\sigma_i$ are not uniform across all data points (heteroscedastic noise), the most appropriate method for fitting this linear model is Weighted Least Squares (WLS). The weight for each data point $(x_i, y_i)$ is chosen to be the inverse of the variance of the corresponding error term, $w_i = 1/\\sigma_i^2$. This choice gives more influence to the more precise measurements and yields the best linear unbiased estimator (BLUE) for the parameters $(a, b)$.\n\nThe WLS solution is found by solving the normal equations in matrix form. The parameters $\\hat{\\beta} = \\begin{bmatrix} \\hat{a} \\\\ \\hat{b} \\end{bmatrix}$ are estimated as:\n\n$$\n\\hat{\\beta} = \\left(X^\\top W X\\right)^{-1} X^\\top W y\n$$\n\nwhere:\n- $y$ is the column vector of observed temperatures $T_i$.\n- $X$ is the $n \\times 2$ design matrix, where the $i$-th row is $[1, x_i] = [1, h_i^p]$.\n- $W$ is the $n \\times n$ diagonal matrix of weights, with $W_{ii} = w_i = 1/\\sigma_i^2$.\n\nThe statistical uncertainty of the estimated parameters is captured by the covariance matrix, which is given by:\n\n$$\n\\mathrm{Cov}(\\hat{\\beta}) = \\left(X^\\top W X\\right)^{-1}\n$$\n\nThe estimate for $T_0$ is $\\hat{a}$, the first element of the vector $\\hat{\\beta}$. The variance of this estimate, $\\mathrm{Var}(\\hat{a})$, is the top-left element of the covariance matrix, $[\\mathrm{Cov}(\\hat{\\beta})]_{11}$. The one-standard-deviation uncertainty of $T_0$, denoted $u_{T_0}$, is the square root of this variance:\n\n$$\nu_{T_0} = \\sqrt{[\\mathrm{Cov}(\\hat{\\beta})]_{11}}\n$$\n\nThe implementation will proceed as follows for each dataset:\n1.  Construct the vectors $h$, $T$, and $\\sigma$ from the provided data.\n2.  Define the order $p$.\n3.  Compute the transformed variable $x_i = h_i^p$.\n4.  Construct the design matrix $X$ and the weight matrix $W$.\n5.  Use matrix algebra, preferably with a robust library like `NumPy`, to compute $\\hat{\\beta}$ and $\\mathrm{Cov}(\\hat{\\beta})$ using the formulas above.\n6.  Extract the estimate $\\hat{a}$ for $T_0$ and calculate its uncertainty $u_{T_0}$.\n7.  Round the final results to three decimal places as required.\n8.  Collect the results for all datasets and format the output according to the specified format.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Dataset A: 2nd-order, 3 points, homoscedastic\n        {'p': 2, 'h': [4, 2, 1], 'T': [308.1, 301.8, 300.6], 'sigma': [0.2, 0.2, 0.2]},\n        # Dataset B: 2nd-order, 2 points, homoscedastic\n        {'p': 2, 'h': [3, 1.5], 'T': [305.0, 301.3], 'sigma': [0.1, 0.1]},\n        # Dataset C: 2nd-order, 3 points, heteroscedastic\n        {'p': 2, 'h': [5, 2, 1], 'T': [319.4, 303.5, 301.1], 'sigma': [0.5, 0.2, 0.1]},\n        # Dataset D: 4th-order, 3 points, homoscedastic\n        {'p': 4, 'h': [4, 2, 1], 'T': [302.5, 300.2, 300.0], 'sigma': [0.05, 0.05, 0.05]}\n    ]\n\n    results = []\n    for case in test_cases:\n        # Pass the parameters of each case to the solver function.\n        result = calculate_extrapolation(\n            p=case['p'],\n            h_data=case['h'],\n            T_data=case['T'],\n            sigma_data=case['sigma']\n        )\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The string representation of a list of lists is already in the correct format.\n    # We remove whitespace to make it compact as per the example.\n    print(str(results).replace(\" \", \"\"))\n\ndef calculate_extrapolation(p, h_data, T_data, sigma_data):\n    \"\"\"\n    Performs weighted least squares fitting to estimate T0 and its uncertainty.\n\n    Args:\n        p (int): The order of the integrator.\n        h_data (list of float): Measured time steps.\n        T_data (list of float): Measured kinetic temperatures.\n        sigma_data (list of float): Uncertainties for each temperature measurement.\n\n    Returns:\n        list: A list containing [T0, u_T0], rounded to three decimal places.\n    \"\"\"\n    # Convert input lists to NumPy arrays for vectorized operations.\n    # Using float64 for better precision in matrix calculations.\n    h = np.array(h_data, dtype=np.float64)\n    T = np.array(T_data, dtype=np.float64)\n    sigma = np.array(sigma_data, dtype=np.float64)\n\n    # 1. Transform variables for the linear model y = a + b*x\n    #    y = T_i, x = h_i^p, a = T0, b = c\n    x = h**p\n    y = T\n\n    # 2. Construct matrices for Weighted Least Squares (WLS).\n    # The weight matrix W is diagonal with weights w_i = 1/sigma_i^2.\n    weights = 1.0 / sigma**2\n    W = np.diag(weights)\n\n    # The design matrix X has a column of ones for the intercept and a column for x.\n    X = np.vstack([np.ones(len(x)), x]).T\n\n    # 3. Solve for the parameters using the WLS normal equations.\n    # The parameter vector beta_hat = [a, b] is given by:\n    # beta_hat = (X^T * W * X)^(-1) * (X^T * W * y)\n    \n    # Calculate the matrix (X^T * W * X)\n    XTWX = X.T @ W @ X\n    \n    # Calculate the vector (X^T * W * y)\n    XTWy = X.T @ W @ y\n\n    # The covariance matrix of the parameters is the inverse of XTWX.\n    # Using np.linalg.inv is numerically stable and robust.\n    cov_beta = np.linalg.inv(XTWX)\n\n    # The parameter estimates are found by multiplying cov_beta by XTWy.\n    beta_hat = cov_beta @ XTWy\n\n    # 4. Extract results for T0.\n    # The estimate for T0 is the intercept 'a', which is the first element of beta_hat.\n    T0_estimate = beta_hat[0]\n\n    # The uncertainty in T0 is the square root of the corresponding diagonal element\n    # of the covariance matrix, which is cov_beta[0, 0].\n    uncertainty_T0 = np.sqrt(cov_beta[0, 0])\n    \n    # 5. Round the results to three decimal places as required.\n    T0_rounded = round(T0_estimate, 3)\n    u_T0_rounded = round(uncertainty_T0, 3)\n\n    return [T0_rounded, u_T0_rounded]\n\n# Execute the main function when the script is run.\nsolve()\n```"
        }
    ]
}