{
    "hands_on_practices": [
        {
            "introduction": "While atomic point charges are a cornerstone of molecular force fields, the true electrostatic potential around a molecule is continuous and anisotropic. This exercise bridges the gap between the rigorous multipole expansion of the potential and these simplified point-charge models . By deriving the potential from dipole and quadrupole moments and then fitting a point-charge model to it, you will gain hands-on experience with the approximations underlying modern force fields and the methods used to parameterize them.",
            "id": "3409576",
            "problem": "Consider a neutral, rigid molecule that is represented by fixed lower-order multipole moments placed at the origin: a permanent dipole vector $\\mathbf{p} \\in \\mathbb{R}^3$ and a traceless symmetric quadrupole tensor $\\mathbf{Q} \\in \\mathbb{R}^{3 \\times 3}$ with $\\mathrm{tr}(\\mathbf{Q}) = 0$. Starting from Coulomb’s law and a Taylor expansion of the Green’s function, derive from first principles an explicit expression for the far-field electrostatic potential $\\Phi(\\mathbf{r})$ at a field point $\\mathbf{r} \\in \\mathbb{R}^3 \\setminus \\{\\mathbf{0}\\}$, truncated at quadrupolar order, in terms of $\\mathbf{p}$ and $\\mathbf{Q}$. The derivation must begin from the fundamental statement that the potential of a set of point charges is $\\Phi(\\mathbf{r}) = \\dfrac{1}{4 \\pi \\varepsilon_0} \\sum_a \\dfrac{q_a}{\\lVert \\mathbf{r} - \\mathbf{r}_a \\rVert}$, use a valid far-field expansion for $\\lVert \\mathbf{r} \\rVert \\gg \\max_a \\lVert \\mathbf{r}_a \\rVert$, and employ the standard Cartesian definitions $\\mathbf{p} = \\sum_a q_a \\mathbf{r}_a$ and $\\mathbf{Q} = \\sum_a q_a \\left( 3 \\,\\mathbf{r}_a \\mathbf{r}_a^{\\mathsf{T}} - \\lVert \\mathbf{r}_a \\rVert^2 \\mathbf{I} \\right)$ where $\\mathbf{I}$ is the identity tensor and the trace-free condition $\\mathrm{tr}(\\mathbf{Q})=0$. Your derived expression must be suitable for numerical evaluation for $\\lVert \\mathbf{r} \\rVert  0$.\n\nThen, using your derived expression, compute the electrostatic potential on a three-dimensional Cartesian grid and compare it to a least-squares best-fit point-charge representation that uses fixed charge locations and enforces net neutrality. The comparison must be quantified by the Root-Mean-Square Error (RMSE) between the potentials on the grid. The computational setup and evaluation requirements are:\n\n- Physical constants and units:\n  - Use the vacuum permittivity $\\varepsilon_0 = 8.8541878128 \\times 10^{-12}\\,\\mathrm{F/m}$.\n  - All distances must be expressed in $\\mathrm{m}$, dipole moments in $\\mathrm{C \\cdot m}$, quadrupole moments in $\\mathrm{C \\cdot m^2}$, and the electrostatic potential in $\\mathrm{V}$.\n  - Where a conversion from Debye is relevant, use $1\\,\\mathrm{D} = 3.33564 \\times 10^{-30}\\,\\mathrm{C \\cdot m}$.\n- Grid specification:\n  - Define a uniform Cartesian grid with coordinates $x,y,z \\in \\{-0.8, -0.6, -0.4, -0.2, 0.0, 0.2, 0.4, 0.6, 0.8\\}\\,\\mathrm{nm}$ converted to $\\mathrm{m}$.\n  - Exclude any grid point with radial distance $\\lVert \\mathbf{r} \\rVert  0.3\\,\\mathrm{nm}$ to avoid the near-field singular region.\n- Multipole potential:\n  - Evaluate the dipole-plus-quadrupole potential $\\Phi_{\\text{MQ}}(\\mathbf{r})$ at each included grid point using your derived expression.\n- Point-charge representation:\n  - Use six fixed charge sites located at $\\pm a$ along each Cartesian axis, with $a = 0.1\\,\\mathrm{nm}$ converted to $\\mathrm{m}$, i.e., positions $\\{\\pm a \\,\\hat{\\mathbf{x}}, \\pm a \\,\\hat{\\mathbf{y}}, \\pm a \\,\\hat{\\mathbf{z}}\\}$.\n  - Determine the charges $\\{q_j\\}_{j=1}^6$ by minimizing the least-squares discrepancy between the point-charge potential $\\Phi_{\\text{PC}}(\\mathbf{r}) = \\dfrac{1}{4 \\pi \\varepsilon_0} \\sum_{j=1}^{6} \\dfrac{q_j}{\\lVert \\mathbf{r} - \\mathbf{R}_j \\rVert}$ and $\\Phi_{\\text{MQ}}(\\mathbf{r})$ over all grid points, subject to the linear constraint $\\sum_{j=1}^{6} q_j = 0$ (net neutrality). Angles, if any, must be expressed in radians.\n  - The fit must be performed by solving the corresponding constrained normal equations derived from the method of Lagrange multipliers.\n- Error metric:\n  - Compute the Root-Mean-Square Error (RMSE) defined as $\\mathrm{RMSE} = \\sqrt{\\dfrac{1}{N} \\sum_{i=1}^{N} \\left( \\Phi_{\\text{PC}}(\\mathbf{r}_i) - \\Phi_{\\text{MQ}}(\\mathbf{r}_i) \\right)^2 }$ in $\\mathrm{V}$, where $N$ is the number of included grid points.\n\nImplement your solution as a complete, runnable program that performs the following three test cases and outputs their RMSE values:\n\n- Test case $1$ (pure dipole): $\\mathbf{p} = [0, 0, p_z]^{\\mathsf{T}}$ with $p_z = 2\\,\\mathrm{D}$ converted to $\\mathrm{C \\cdot m}$; $\\mathbf{Q} = \\mathbf{0}$.\n- Test case $2$ (pure quadrupole, rotated principal axis): $\\mathbf{p} = \\mathbf{0}$; $\\mathbf{Q}$ has principal values $\\mathrm{diag}\\left(-Q_0/2,\\,-Q_0/2,\\,Q_0\\right)$ with $Q_0 = 2.0 \\times 10^{-40}\\,\\mathrm{C \\cdot m^2}$, rotated by an angle $\\theta = \\pi/6\\,\\mathrm{rad}$ about the $y$-axis.\n- Test case $3$ (combined, off-axis): $\\mathbf{p}$ has magnitude $p = 3\\,\\mathrm{D}$ directed along the unit vector proportional to $[1,1,1]^{\\mathsf{T}}$; $\\mathbf{Q}$ has principal values $\\mathrm{diag}\\left(Q_1,\\,-Q_1/2,\\,-Q_1/2\\right)$ with $Q_1 = 1.0 \\times 10^{-40}\\,\\mathrm{C \\cdot m^2}$, rotated by an angle $\\varphi = \\pi/4\\,\\mathrm{rad}$ about the $z$-axis.\n\nYour program should produce a single line of output containing the RMSE for the three test cases as a comma-separated list enclosed in square brackets, with each value formatted in scientific notation with six significant digits, for example, $[\\text{rmse}_1,\\text{rmse}_2,\\text{rmse}_3]$. The numerical answers must be in $\\mathrm{V}$ and rounded to six significant digits via scientific notation formatting.",
            "solution": "The problem requires the derivation of the far-field electrostatic potential from a multipole expansion and its subsequent use in a numerical comparison against a fitted point-charge model. We will first validate the problem, then proceed with the derivation and computational methodology.\n\n### Problem Validation\nThe problem statement has been evaluated and is determined to be **valid**. It is scientifically grounded in classical electrostatics, well-posed, objective, and internally consistent. It provides all necessary data, constants, and definitions to derive and compute a unique, verifiable solution. The tasks are standard exercises in theoretical and computational physics.\n\n### Part 1: Derivation of the Multipole-Quadrupole Potential $\\Phi_{\\text{MQ}}(\\mathbf{r})$\n\nThe electrostatic potential $\\Phi(\\mathbf{r})$ at a position $\\mathbf{r}$ due to a discrete set of point charges $\\{q_a\\}$ located at positions $\\{\\mathbf{r}_a\\}$ is given by Coulomb's law:\n$$\n\\Phi(\\mathbf{r}) = \\dfrac{1}{4 \\pi \\varepsilon_0} \\sum_a \\dfrac{q_a}{\\lVert \\mathbf{r} - \\mathbf{r}_a \\rVert}\n$$\nwhere $\\varepsilon_0$ is the vacuum permittivity. We seek a far-field approximation, valid for $\\lVert \\mathbf{r} \\rVert \\gg \\max_a \\lVert \\mathbf{r}_a \\rVert$. To achieve this, we perform a Taylor expansion of the term $1 / \\lVert \\mathbf{r} - \\mathbf{r}_a \\rVert$ for small $\\lVert \\mathbf{r}_a \\rVert$ around $\\mathbf{r}_a = \\mathbf{0}$. Let $f(\\mathbf{x}) = 1/\\lVert\\mathbf{x}\\rVert$. We expand $f(\\mathbf{r}-\\mathbf{r}_a)$ around $\\mathbf{r}_a = \\mathbf{0}$:\n$$\nf(\\mathbf{r}-\\mathbf{r}_a) \\approx f(\\mathbf{r}) - \\sum_i (r_a)_i \\dfrac{\\partial f}{\\partial x_i}(\\mathbf{r}) + \\dfrac{1}{2} \\sum_{i,j} (r_a)_i (r_a)_j \\dfrac{\\partial^2 f}{\\partial x_i \\partial x_j}(\\mathbf{r}) + \\mathcal{O}(\\lVert \\mathbf{r}_a \\rVert^3)\n$$\nwhere $(r_a)_i$ and $x_i$ are the Cartesian components of $\\mathbf{r}_a$ and $\\mathbf{r}$, respectively. Let $R = \\lVert \\mathbf{r} \\rVert = \\sqrt{x_1^2 + x_2^2 + x_3^2}$. The necessary derivatives are:\n$$\n\\dfrac{\\partial f}{\\partial x_i} = \\dfrac{\\partial}{\\partial x_i} \\left( \\dfrac{1}{R} \\right) = -\\dfrac{1}{R^2} \\dfrac{\\partial R}{\\partial x_i} = -\\dfrac{x_i}{R^3}\n$$\n$$\n\\dfrac{\\partial^2 f}{\\partial x_i \\partial x_j} = \\dfrac{\\partial}{\\partial x_j} \\left( -\\dfrac{x_i}{R^3} \\right) = -\\dfrac{\\delta_{ij}}{R^3} + 3\\dfrac{x_i}{R^4}\\dfrac{\\partial R}{\\partial x_j} = -\\dfrac{\\delta_{ij}}{R^3} + \\dfrac{3 x_i x_j}{R^5} = \\dfrac{3 x_i x_j - \\delta_{ij}R^2}{R^5}\n$$\nwhere $\\delta_{ij}$ is the Kronecker delta.\n\nSubstituting these derivatives into the expansion gives:\n$$\n\\dfrac{1}{\\lVert \\mathbf{r} - \\mathbf{r}_a \\rVert} \\approx \\dfrac{1}{R} - \\sum_i (r_a)_i \\left(-\\dfrac{x_i}{R^3}\\right) + \\dfrac{1}{2} \\sum_{i,j} (r_a)_i (r_a)_j \\left(\\dfrac{3 x_i x_j - \\delta_{ij}R^2}{R^5}\\right)\n$$\n$$\n\\dfrac{1}{\\lVert \\mathbf{r} - \\mathbf{r}_a \\rVert} \\approx \\dfrac{1}{R} + \\dfrac{\\mathbf{r} \\cdot \\mathbf{r}_a}{R^3} + \\dfrac{1}{2R^5} \\sum_{i,j} (r_a)_i (r_a)_j (3 x_i x_j - \\delta_{ij}R^2)\n$$\nNow, substitute this back into the expression for $\\Phi(\\mathbf{r})$ and sum over all charges $q_a$:\n$$\n\\Phi(\\mathbf{r}) \\approx \\dfrac{1}{4 \\pi \\varepsilon_0} \\sum_a q_a \\left[ \\dfrac{1}{R} + \\dfrac{\\mathbf{r} \\cdot \\mathbf{r}_a}{R^3} + \\dfrac{1}{2R^5} \\sum_{i,j} (3 x_i x_j - \\delta_{ij}R^2) (r_a)_i (r_a)_j \\right]\n$$\nWe can group terms by the properties of the charge distribution:\n$$\n\\Phi(\\mathbf{r}) \\approx \\dfrac{1}{4 \\pi \\varepsilon_0} \\left[ \\dfrac{1}{R} \\left(\\sum_a q_a\\right) + \\dfrac{1}{R^3} \\mathbf{r} \\cdot \\left(\\sum_a q_a \\mathbf{r}_a\\right) + \\dfrac{1}{2R^5} \\sum_{i,j} (3 x_i x_j - \\delta_{ij}R^2) \\left(\\sum_a q_a (r_a)_i (r_a)_j\\right) \\right]\n$$\nThe terms correspond to the multipole moments:\n\\begin{itemize}\n    \\item Monopole moment: $q = \\sum_a q_a$. The problem specifies a neutral molecule, so $q=0$.\n    \\item Dipole moment: $\\mathbf{p} = \\sum_a q_a \\mathbf{r}_a$.\n    \\item Quadrupole moment: The final term involves the second moment of the charge distribution. The problem provides the definition for the traceless quadrupole tensor $\\mathbf{Q}$:\n    $$\n    Q_{ij} = \\sum_a q_a \\left( 3 (r_a)_i (r_a)_j - \\lVert \\mathbf{r}_a \\rVert^2 \\delta_{ij} \\right)\n    $$\n\\end{itemize}\nLet's relate the third term in the potential expansion to this definition of $\\mathbf{Q}$. Consider the quadratic form $\\mathbf{r}^\\mathsf{T} \\mathbf{Q} \\mathbf{r}$:\n$$\n\\mathbf{r}^\\mathsf{T} \\mathbf{Q} \\mathbf{r} = \\sum_{i,j} x_i Q_{ij} x_j = \\sum_{i,j} x_i x_j \\sum_a q_a \\left( 3 (r_a)_i (r_a)_j - \\lVert \\mathbf{r}_a \\rVert^2 \\delta_{ij} \\right)\n$$\nRearranging the summation:\n$$\n= \\sum_a q_a \\left[ \\sum_{i,j} 3 x_i x_j (r_a)_i (r_a)_j - \\sum_{i,j} x_i x_j \\lVert \\mathbf{r}_a \\rVert^2 \\delta_{ij} \\right]\n$$\n$$\n= \\sum_a q_a \\left[ 3 \\left(\\sum_i x_i (r_a)_i\\right) \\left(\\sum_j x_j (r_a)_j\\right) - \\lVert \\mathbf{r}_a \\rVert^2 \\left(\\sum_i x_i^2\\right) \\right]\n$$\n$$\n= \\sum_a q_a \\left[ 3 (\\mathbf{r} \\cdot \\mathbf{r}_a)^2 - \\lVert \\mathbf{r}_a \\rVert^2 \\lVert \\mathbf{r} \\rVert^2 \\right] = \\sum_a q_a \\left[ 3 (\\mathbf{r} \\cdot \\mathbf{r}_a)^2 - R^2 \\lVert \\mathbf{r}_a \\rVert^2 \\right]\n$$\nNow, consider the quadrupole term from our expansion of $\\Phi(\\mathbf{r})$ again, which involves $\\sum_a q_a \\sum_{i,j} (3 x_i x_j - \\delta_{ij}R^2) (r_a)_i (r_a)_j$:\n$$\n= \\sum_a q_a \\left[ 3 \\sum_{i,j} x_i x_j (r_a)_i (r_a)_j - R^2 \\sum_{i,j} \\delta_{ij} (r_a)_i (r_a)_j \\right]\n$$\n$$\n= \\sum_a q_a \\left[ 3 (\\mathbf{r} \\cdot \\mathbf{r}_a)^2 - R^2 \\lVert \\mathbf{r}_a \\rVert^2 \\right]\n$$\nThis is precisely $\\mathbf{r}^\\mathsf{T} \\mathbf{Q} \\mathbf{r}$. Thus, the third term in the potential is $\\frac{1}{2R^5} (\\mathbf{r}^\\mathsf{T} \\mathbf{Q} \\mathbf{r})$.\nCombining the dipole and quadrupole terms (since monopole is zero), we obtain the desired expression for the potential truncated at quadrupolar order:\n$$\n\\Phi_{\\text{MQ}}(\\mathbf{r}) = \\dfrac{1}{4 \\pi \\varepsilon_0} \\left( \\dfrac{\\mathbf{p} \\cdot \\mathbf{r}}{\\lVert \\mathbf{r} \\rVert^3} + \\dfrac{\\mathbf{r}^\\mathsf{T} \\mathbf{Q} \\mathbf{r}}{2 \\lVert \\mathbf{r} \\rVert^5} \\right)\n$$\nThis expression will be used to compute the target potential on the grid.\n\n### Part 2: Constrained Least-Squares Fit for Point-Charge Model\n\nThe goal is to find a set of six charges $\\{q_j\\}_{j=1}^6$ for fixed positions $\\{\\mathbf{R}_j\\}_{j=1}^6$ that best reproduces the multipole potential $\\Phi_{\\text{MQ}}$ on a grid of $N$ points $\\{\\mathbf{r}_i\\}_{i=1}^N$. The potential from the point charges is:\n$$\n\\Phi_{\\text{PC}}(\\mathbf{r}_i) = \\dfrac{1}{4 \\pi \\varepsilon_0} \\sum_{j=1}^{6} \\dfrac{q_j}{\\lVert \\mathbf{r}_i - \\mathbf{R}_j \\rVert}\n$$\nWe wish to minimize the sum of squared errors $S$, subject to a neutrality constraint:\n$$\nS = \\sum_{i=1}^{N} \\left( \\Phi_{\\text{PC}}(\\mathbf{r}_i) - \\Phi_{\\text{MQ}}(\\mathbf{r}_i) \\right)^2 \\quad \\text{subject to} \\quad \\sum_{j=1}^{6} q_j = 0\n$$\nThis is a constrained linear least-squares problem. Let $k_e = 1/(4\\pi\\varepsilon_0)$, $\\mathbf{y}$ be an $N$-dimensional vector with elements $y_i = \\Phi_{\\text{MQ}}(\\mathbf{r}_i)$, and $\\mathbf{q}$ be a $6$-dimensional vector of the unknown charges $q_j$. We define an $N \\times 6$ matrix $\\mathbf{A}$ such that $A_{ij} = k_e / \\lVert \\mathbf{r}_i - \\mathbf{R}_j \\rVert$. The point-charge potential vector is then $\\mathbf{\\Phi}_{\\text{PC}} = \\mathbf{A}\\mathbf{q}$. The problem becomes:\n$$\n\\text{Minimize } \\lVert \\mathbf{A}\\mathbf{q} - \\mathbf{y} \\rVert^2 \\quad \\text{subject to} \\quad \\mathbf{C}\\mathbf{q} = d\n$$\nwhere $\\mathbf{C} = [1, 1, 1, 1, 1, 1]$ is a $1 \\times 6$ row vector and $d=0$ is a scalar.\n\nWe use the method of Lagrange multipliers. The Lagrangian function is:\n$$\n\\mathcal{L}(\\mathbf{q}, \\lambda) = (\\mathbf{A}\\mathbf{q} - \\mathbf{y})^\\mathsf{T}(\\mathbf{A}\\mathbf{q} - \\mathbf{y}) + 2\\lambda (\\mathbf{C}\\mathbf{q} - d)\n$$\nTaking the partial derivatives with respect to $\\mathbf{q}$ and the Lagrange multiplier $\\lambda$ and setting them to zero yields the Karush-Kuhn-Tucker (KKT) conditions:\n$$\n\\dfrac{\\partial \\mathcal{L}}{\\partial \\mathbf{q}} = 2\\mathbf{A}^\\mathsf{T}(\\mathbf{A}\\mathbf{q} - \\mathbf{y}) + 2\\lambda \\mathbf{C}^\\mathsf{T} = \\mathbf{0} \\implies \\mathbf{A}^\\mathsf{T}\\mathbf{A}\\mathbf{q} + \\lambda \\mathbf{C}^\\mathsf{T} = \\mathbf{A}^\\mathsf{T}\\mathbf{y}\n$$\n$$\n\\dfrac{\\partial \\mathcal{L}}{\\partial \\lambda} = 2(\\mathbf{C}\\mathbf{q} - d) = \\mathbf{0} \\implies \\mathbf{C}\\mathbf{q} = d\n$$\nThese two equations form a system of linear equations for the unknowns $\\mathbf{q}$ and $\\lambda$. We can write this system in a block matrix form:\n$$\n\\begin{pmatrix}\n\\mathbf{A}^\\mathsf{T}\\mathbf{A}  \\mathbf{C}^\\mathsf{T} \\\\\n\\mathbf{C}  0\n\\end{pmatrix}\n\\begin{pmatrix}\n\\mathbf{q} \\\\\n\\lambda\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\mathbf{A}^\\mathsf{T}\\mathbf{y} \\\\\nd\n\\end{pmatrix}\n$$\nThis is a $(6+1) \\times (6+1)$ system. The solution vector gives the optimal charges $q_1, \\dots, q_6$.\n\n### Part 3: Computational Algorithm\n\nThe overall numerical procedure is as follows:\n1.  Initialize physical constants and conversion factors.\n2.  Define the Cartesian grid coordinates and generate the full set of grid points $\\{\\mathbf{r}_i\\}$.\n3.  Filter the grid points to exclude any point with $\\lVert \\mathbf{r}_i \\rVert  0.3\\,\\mathrm{nm}$.\n4.  Define the fixed locations $\\{\\mathbf{R}_j\\}$ of the six point charges.\n5.  Construct the matrix $\\mathbf{A}$ based on the filtered grid points and charge locations.\n6.  For each of the three test cases:\n    a. Construct the dipole vector $\\mathbf{p}$ and quadrupole tensor $\\mathbf{Q}$ according to the case specifications, performing necessary unit conversions and rotations.\n    b. Calculate the target potential $\\Phi_{\\text{MQ}}(\\mathbf{r}_i)$ at each filtered grid point to form the vector $\\mathbf{y}$.\n    c. Assemble the block KKT matrix and the right-hand-side vector for the constrained least-squares system.\n    d. Solve the linear system to find the optimal charges $\\mathbf{q}$.\n    e. Calculate the fitted potential vector $\\mathbf{\\Phi}_{\\text{PC}} = \\mathbf{A}\\mathbf{q}$.\n    f. Compute the Root-Mean-Square Error (RMSE) between $\\mathbf{\\Phi}_{\\text{PC}}$ and $\\mathbf{y}$:\n       $$\n       \\mathrm{RMSE} = \\sqrt{\\dfrac{1}{N} \\sum_{i=1}^{N} (\\Phi_{\\text{PC}}(\\mathbf{r}_i) - \\Phi_{\\text{MQ}}(\\mathbf{r}_i))^2}\n       $$\n7.  Format the RMSE values from the three cases into the required output string.",
            "answer": "```python\nimport numpy as np\nfrom scipy.spatial.transform import Rotation\n\ndef solve():\n    \"\"\"\n    Solves the electrostatic potential fitting problem for three test cases.\n    \"\"\"\n    \n    # Physical constants and unit conversions\n    EPSILON_0 = 8.8541878128e-12  # F/m\n    K_E = 1.0 / (4 * np.pi * EPSILON_0)  # Coulomb's constant\n    DEBYE_TO_CM = 3.33564e-30  # 1 Debye in C*m\n    NM_TO_M = 1e-9\n\n    # Grid specification\n    grid_coords_1d = np.array([-0.8, -0.6, -0.4, -0.2, 0.0, 0.2, 0.4, 0.6, 0.8]) * NM_TO_M\n    grid_points = np.array(np.meshgrid(grid_coords_1d, grid_coords_1d, grid_coords_1d)).T.reshape(-1, 3)\n    \n    # Filter grid points\n    min_radius = 0.3 * NM_TO_M\n    norms = np.linalg.norm(grid_points, axis=1)\n    # Add a small epsilon to avoid floating point issues with norms_sq == 0\n    valid_indices = norms >= min_radius\n    r_vectors = grid_points[valid_indices]\n    r_norms = norms[valid_indices]\n    num_grid_points = len(r_vectors)\n\n    # Point-charge representation setup\n    a = 0.1 * NM_TO_M\n    R_vectors = np.array([\n        [a, 0, 0], [-a, 0, 0],\n        [0, a, 0], [0, -a, 0],\n        [0, 0, a], [0, 0, -a]\n    ])\n    num_charges = len(R_vectors)\n\n    # Construct the A matrix for the linear system\n    # A_ij = k_e / ||r_i - R_j||\n    A = np.zeros((num_grid_points, num_charges))\n    for i in range(num_grid_points):\n        for j in range(num_charges):\n            dist = np.linalg.norm(r_vectors[i] - R_vectors[j])\n            A[i, j] = K_E / dist\n\n    # --- Constrained Least Squares Setup ---\n    # We solve the system:\n    # [[A^T A, C^T], [C, 0]] * [q, lambda]^T = [A^T y, d]^T\n    # Here, C = [1, 1, 1, 1, 1, 1] and d = 0.\n\n    AtA = A.T @ A\n    C = np.ones((1, num_charges))\n    \n    # KKT matrix (7x7)\n    KKT_matrix = np.zeros((num_charges + 1, num_charges + 1))\n    KKT_matrix[:num_charges, :num_charges] = AtA\n    KKT_matrix[num_charges, :num_charges] = C\n    KKT_matrix[:num_charges, num_charges] = C.T.flatten()\n\n    def get_mq_potential(p_vec, Q_mat, r_vecs, r_norms):\n        \"\"\"Calculates the multipole potential (dipole + quadrupole) on the grid.\"\"\"\n        phi_mq = np.zeros(len(r_vecs))\n        \n        # Dipole term: p . r / R^3\n        if not np.all(p_vec == 0):\n            dipole_term = np.dot(r_vecs, p_vec) / (r_norms**3)\n            phi_mq += dipole_term\n            \n        # Quadrupole term: (r^T Q r) / (2 * R^5)\n        if not np.all(Q_mat == 0):\n            # Using einsum for efficiency: r_i Q_ij r_j\n            quadrupole_term = np.einsum('...i,ij,...j', r_vecs, Q_mat, r_vecs) / (2 * r_norms**5)\n            phi_mq += quadrupole_term\n            \n        return K_E * phi_mq\n\n    def calculate_rmse(p_vec, Q_mat):\n        \"\"\"Performs the constrained fit and calculates RMSE.\"\"\"\n        \n        # 1. Calculate target potential vector y (Phi_MQ)\n        y = get_mq_potential(p_vec, Q_mat, r_vectors, r_norms)\n        \n        # 2. Setup and solve the KKT system\n        At_y = A.T @ y\n        rhs = np.append(At_y, 0)\n        \n        try:\n            solution = np.linalg.solve(KKT_matrix, rhs)\n        except np.linalg.LinAlgError:\n            return np.nan # Should not happen with this problem setup\n\n        q_fit = solution[:num_charges]\n        \n        # 3. Calculate the fitted potential Phi_PC\n        phi_pc = A @ q_fit\n        \n        # 4. Compute RMSE\n        rmse = np.sqrt(np.mean((phi_pc - y)**2))\n        return rmse\n\n    # --- Test Cases ---\n    results = []\n\n    # Case 1: Pure dipole\n    p_vec_1 = np.array([0, 0, 2.0 * DEBYE_TO_CM])\n    Q_mat_1 = np.zeros((3, 3))\n    results.append(calculate_rmse(p_vec_1, Q_mat_1))\n\n    # Case 2: Pure quadrupole, rotated\n    p_vec_2 = np.zeros(3)\n    Q0 = 2.0e-40  # C*m^2\n    Q_diag_2 = np.diag([-Q0 / 2, -Q0 / 2, Q0])\n    theta = np.pi / 6\n    rot_y = Rotation.from_euler('y', theta, degrees=False)\n    R_mat_2 = rot_y.as_matrix()\n    Q_mat_2 = R_mat_2 @ Q_diag_2 @ R_mat_2.T\n    results.append(calculate_rmse(p_vec_2, Q_mat_2))\n    \n    # Case 3: Combined, off-axis\n    p_mag_3 = 3.0 * DEBYE_TO_CM\n    p_dir_3 = np.array([1, 1, 1]) / np.sqrt(3)\n    p_vec_3 = p_mag_3 * p_dir_3\n    \n    Q1 = 1.0e-40 # C*m^2\n    Q_diag_3 = np.diag([Q1, -Q1 / 2, -Q1 / 2])\n    phi = np.pi / 4\n    rot_z = Rotation.from_euler('z', phi, degrees=False)\n    R_mat_3 = rot_z.as_matrix()\n    Q_mat_3 = R_mat_3 @ Q_diag_3 @ R_mat_3.T\n    results.append(calculate_rmse(p_vec_3, Q_mat_3))\n    \n    # Format and print the final output\n    formatted_results = [\"{:.6e}\".format(r) for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "When simulating systems with periodic boundary conditions, calculating electrostatic interactions presents a major challenge due to the long-range nature of the Coulomb potential, which leads to a conditionally convergent sum. The Ewald summation method is the canonical solution, elegantly splitting the interaction into a short-range part calculated in real space and a long-range part calculated in reciprocal space . This practice guides you through implementing the Ewald sum from first principles, providing a fundamental understanding of how long-range forces are correctly handled in simulations of periodic systems like liquids and crystals.",
            "id": "3409609",
            "problem": "Consider a set of point charges in a three-dimensional periodic cubic cell of side length $L$ under periodic boundary conditions. The total electrostatic energy of this system is defined by superposition from Coulomb’s law and is to be computed using a decomposition that introduces a Gaussian screening characterized by parameter $\\alpha$. The decomposition partitions the energy into a short-range real-space part truncated at a cutoff $r_c$, a long-range reciprocal-space part truncated at a wave-vector magnitude bound $k_{\\max}$, and a self-interaction correction. The physical model assumes conducting boundary conditions and reduced units where $1/(4\\pi\\varepsilon_0)=1$, so the resulting energy is dimensionless. Your task is to implement the necessary calculations from first principles, starting from the definitions of electrostatic potential and Fourier analysis of periodic functions, and produce numerical errors associated with finite truncations for different values of $\\alpha$.\n\nFundamental basis to use:\n- Coulomb’s law for point charges, superposition, and periodic boundary conditions in a cubic cell of side length $L$.\n- Representation of periodic functions using Fourier series, where reciprocal vectors are $\\mathbf{k}=\\frac{2\\pi}{L}\\mathbf{n}$ with $\\mathbf{n}\\in\\mathbb{Z}^3$.\n- Gaussian screening to separate short-range and long-range contributions consistently in real space and reciprocal space.\n- The energy contribution arising from the screening procedure includes a self-interaction correction for each charge.\n\nSystem specification (reduced, dimensionless units):\n- Box length: $L=1.0$.\n- Number of charges: $N=4$.\n- Charges: $\\{q_i\\}_{i=1}^4 = \\{+1.0,-1.0,+1.0,-1.0\\}$ (net charge is zero).\n- Positions in the box, in Cartesian coordinates with each component in $[0,L)$:\n  - $\\mathbf{r}_1 = (0.10, 0.10, 0.10)$\n  - $\\mathbf{r}_2 = (0.90, 0.10, 0.10)$\n  - $\\mathbf{r}_3 = (0.50, 0.60, 0.20)$\n  - $\\mathbf{r}_4 = (0.20, 0.70, 0.80)$\n\nComputation requirements:\n- Real-space part: sum over all distinct pairs $(i,j)$ with $ij$, and over all lattice translations $\\mathbf{T}=L\\mathbf{n}$ where $\\mathbf{n}\\in\\mathbb{Z}^3$, but only include terms whose pair separation $r_{ij,\\mathbf{T}}=\\lVert(\\mathbf{r}_j-\\mathbf{r}_i)+\\mathbf{T}\\rVert$ satisfies $r_{ij,\\mathbf{T}}\\le r_c$. You must numerically implement the short-range screened interaction corresponding to Gaussian screening characterized by $\\alpha$; the necessary explicit functional forms are to be derived and justified in your solution using the stated fundamental basis, not assumed.\n- Reciprocal-space part: sum over all nonzero reciprocal lattice vectors $\\mathbf{k}=\\frac{2\\pi}{L}\\mathbf{n}$ with $\\lVert\\mathbf{k}\\rVert\\le k_{\\max}$, using the structure factor $S(\\mathbf{k})=\\sum_{i=1}^N q_i e^{i\\mathbf{k}\\cdot\\mathbf{r}_i}$ and the long-range screened interaction consistent with the same Gaussian screening characterized by $\\alpha$. The required reciprocal-space expression must be derived from first principles in your solution and then implemented.\n- Self-interaction correction: include the appropriate self term implied by the Gaussian screening decomposition, derived from first principles in your solution and then implemented.\n- Conducting boundary (tin-foil) conditions must be assumed; no additional surface-term correction is to be included.\n\nError analysis protocol:\n- Define a high-accuracy reference energy using a single fixed screening parameter and sufficiently large truncations in both real and reciprocal space. Use the following values for the reference: $\\alpha_{\\text{ref}}=5.0$, $r_{c,\\text{ref}}=2.0$, and $k_{\\max,\\text{ref}}=30\\pi$.\n- For each test case listed below, compute the approximate energy using its $(\\alpha,r_c,k_{\\max})$ and report the absolute error as a float, defined as $\\lvert E_{\\text{approx}}-E_{\\text{ref}}\\rvert$, in the same reduced, dimensionless units.\n\nTest suite:\n- Case $1$: $\\alpha=4.0$, $r_c=0.49$, $k_{\\max}=24\\pi$.\n- Case $2$: $\\alpha=8.0$, $r_c=0.30$, $k_{\\max}=12\\pi$.\n- Case $3$: $\\alpha=1.5$, $r_c=0.20$, $k_{\\max}=40\\pi$.\n- Case $4$ (edge, no reciprocal-space): $\\alpha=3.0$, $r_c=0.49$, $k_{\\max}=0$.\n- Case $5$ (edge, no real-space): $\\alpha=3.0$, $r_c=0.00$, $k_{\\max}=40\\pi$.\n\nYour program must implement the above and produce the specified errors for the given test suite. The final numerical answers are dimensionless floats. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[x_1,x_2,x_3,x_4,x_5]$).",
            "solution": "### Derivation of Ewald Summation Formulas\n\nThe total electrostatic energy $E$ of a system of $N$ point charges $q_i$ at positions $\\mathbf{r}_i$ within a primary cubic cell of side $L$, interacting with all their periodic images, is given by pairwise superposition according to Coulomb's law. In reduced units where the Coulomb constant $1/(4\\pi\\varepsilon_0)=1$, this is:\n$$ E = \\frac{1}{2} \\sum_{i=1}^{N} \\sum_{j=1}^{N} \\sum_{\\mathbf{n} \\in \\mathbb{Z}^3}' \\frac{q_i q_j}{|\\mathbf{r}_i - \\mathbf{r}_j - \\mathbf{T_n}|} $$\nHere, $\\mathbf{T_n} = L\\mathbf{n}$ is a lattice translation vector for an integer vector $\\mathbf{n}=(n_x, n_y, n_z)$. The primed summation excludes self-interaction terms, i.e., pairs where $i=j$ and $\\mathbf{n}=\\mathbf{0}$ simultaneously. This sum is conditionally convergent and converges very slowly.\n\nThe Ewald method accelerates convergence by splitting the $1/r$ interaction into two parts using an arbitrary screening parameter $\\alpha > 0$ and the identity $\\text{erf}(x) + \\text{erfc}(x) = 1$:\n$$ \\frac{1}{r} = \\underbrace{\\frac{\\text{erfc}(\\alpha r)}{r}}_{\\text{short-range}} + \\underbrace{\\frac{\\text{erf}(\\alpha r)}{r}}_{\\text{long-range}} $$\nThe first term, involving the complementary error function $\\text{erfc}$, decays rapidly in real space. The second term, involving the error function $\\text{erf}$, is a smooth, long-ranged function that is suitable for treatment in reciprocal (Fourier) space.\n\nSubstituting this identity into the energy expression splits the total energy into three components: a real-space sum $E_{\\text{real}}$, a reciprocal-space sum $E_{\\text{recip}}$, and a self-interaction correction $E_{\\text{self}}$.\n$$ E = E_{\\text{real}} + E_{\\text{recip}} + E_{\\text{self}} $$\n\n#### 1. Real-Space Energy ($E_{\\text{real}}$)\nThe short-range contribution gives the real-space energy. Due to the rapid decay of $\\text{erfc}(\\alpha r)/r$, this sum can be truncated at a cutoff radius $r_c$ with controlled error. The sum includes interactions between all pairs of particles $i$ and $j$ over all periodic images $\\mathbf{n}$, excluding the $i=j, \\mathbf{n}=\\mathbf{0}$ term.\n$$ E_{\\text{real}}(r_c) = \\frac{1}{2}\\sum_{i=1}^N\\sum_{j=1}^N q_i q_j \\sum_{\\mathbf{n} \\in \\mathbb{Z}^3}' \\left[ \\frac{\\text{erfc}(\\alpha |\\mathbf{r}_j - \\mathbf{r}_i + L\\mathbf{n}|)}{|\\mathbf{r}_j - \\mathbf{r}_i + L\\mathbf{n}|} \\right]_{|\\mathbf{r}_j-\\mathbf{r}_i+L\\mathbf{n}|\\le r_c} $$\nThe prime on the sum indicates that for $i=j$, the $\\mathbf{n}=\\mathbf{0}$ term is omitted.\n\n#### 2. Reciprocal-Space Energy ($E_{\\text{recip}}$)\nThe long-range contribution is handled in reciprocal space. This term corresponds to the energy of a periodic lattice of Gaussian charge distributions. The potential energy of such a system is most readily calculated using Fourier series. The charge density of the periodic system of Gaussians can be expanded in a Fourier series, and using Poisson's equation $\\nabla^2 \\phi = -4\\pi\\rho$ (in given units) and Parseval's theorem, the energy is expressed as a sum over reciprocal lattice vectors $\\mathbf{k} = \\frac{2\\pi}{L}\\mathbf{m}$ for integer vectors $\\mathbf{m} \\in \\mathbb{Z}^3$.\nThe Fourier transform of the long-range potential term $\\text{erf}(\\alpha r)/r$ is $\\frac{4\\pi}{k^2}e^{-k^2/(4\\alpha^2)}$. This leads to the reciprocal-space energy:\n$$ E_{\\text{recip}} = \\frac{1}{2V} \\sum_{\\mathbf{k} \\ne \\mathbf{0}} \\frac{4\\pi}{k^2} e^{-k^2/(4\\alpha^2)} \\left| \\sum_{j=1}^{N} q_j e^{i\\mathbf{k} \\cdot \\mathbf{r}_j} \\right|^2 $$\nwhere $V=L^3$ is the cell volume. The term $\\sum_j q_j e^{i\\mathbf{k} \\cdot \\mathbf{r}_j}$ is the structure factor $S(\\mathbf{k})$. The $\\mathbf{k}=\\mathbf{0}$ term is excluded. For a charge-neutral system ($\\sum q_i = 0$), $S(\\mathbf{0})=0$, so this term would be zero anyway. Its omission is also consistent with the specified conducting (tin-foil) boundary conditions. Truncating the sum at a maximum wave-vector magnitude $k_{\\max}$, the final expression is:\n$$ E_{\\text{recip}}(k_{\\max}) = \\frac{2\\pi}{L^3} \\sum_{\\substack{0  |\\mathbf{k}| \\le k_{\\max} \\\\ \\mathbf{k} = \\frac{2\\pi}{L}\\mathbf{m}}} \\frac{e^{-k^2/(4\\alpha^2)}}{k^2} |S(\\mathbf{k})|^2 $$\n\n#### 3. Self-Interaction Correction ($E_{\\text{self}}$)\nThe decomposition introduces an artificial self-interaction term that must be corrected. The real-space sum correctly excludes the infinite self-energy of a point charge. The reciprocal-space sum, however, is derived from smooth Gaussian charge distributions, which have a finite self-energy. This correction arises from removing the $i=j$ term from the long-range part of the original sum:\n$$ E_{\\text{correction}} = -\\frac{1}{2} \\sum_{i=1}^{N} q_i^2 \\lim_{r \\to 0} \\frac{\\text{erf}(\\alpha r)}{r} $$\nUsing the Taylor expansion of $\\text{erf}(x) = \\frac{2}{\\sqrt{\\pi}}(x - \\frac{x^3}{3} + \\dots)$, the limit is evaluated as:\n$$ \\lim_{r \\to 0} \\frac{\\text{erf}(\\alpha r)}{r} = \\lim_{r \\to 0} \\frac{ (2/\\sqrt{\\pi})(\\alpha r) }{r} = \\frac{2\\alpha}{\\sqrt{\\pi}} $$\nThus, the self-interaction correction term is:\n$$ E_{\\text{self}} = -\\frac{1}{2} \\sum_{i=1}^{N} q_i^2 \\left(\\frac{2\\alpha}{\\sqrt{\\pi}}\\right) = -\\frac{\\alpha}{\\sqrt{\\pi}} \\sum_{i=1}^{N} q_i^2 $$\n\nThe total energy is the sum of these three components, each truncated according to its respective cutoff parameter. The implementation will compute these three terms for the given system parameters to find the total electrostatic energy.",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import erfc\n\ndef calculate_energy(alpha, rc, kmax, charges, positions, L):\n    \"\"\"\n    Calculates the electrostatic energy of a periodic system of charges\n    using the Ewald summation method.\n    \n    Args:\n        alpha (float): Ewald screening parameter.\n        rc (float): Real-space cutoff radius.\n        kmax (float): Reciprocal-space cutoff magnitude.\n        charges (np.ndarray): Array of charges of shape (N,).\n        positions (np.ndarray): Array of particle positions of shape (N, 3).\n        L (float): Side length of the cubic periodic cell.\n        \n    Returns:\n        float: The total electrostatic energy.\n    \"\"\"\n    N = len(charges)\n    V = L**3\n    \n    # --- Real-space energy ---\n    E_real = 0.0\n    if rc > 0:\n        # Determine the maximum number of image cells to check\n        nmax_real = int(np.ceil(rc / L))\n        \n        for i in range(N):\n            for j in range(N):\n                for nx in range(-nmax_real, nmax_real + 1):\n                    for ny in range(-nmax_real, nmax_real + 1):\n                        for nz in range(-nmax_real, nmax_real + 1):\n                            # Exclude self-interaction at n=(0,0,0)\n                            if i == j and nx == 0 and ny == 0 and nz == 0:\n                                continue\n                            \n                            r_vec = positions[j] - positions[i] + np.array([nx, ny, nz]) * L\n                            r_mag = np.linalg.norm(r_vec)\n                            \n                            if r_mag = rc:\n                                E_real += charges[i] * charges[j] * erfc(alpha * r_mag) / r_mag\n\n    E_real *= 0.5 # Correct for double counting\n\n    # --- Reciprocal-space energy ---\n    E_recip = 0.0\n    if kmax > 0:\n        # Determine the maximum integer indices for k-vectors\n        m_max_recip = int(np.ceil(kmax * L / (2 * np.pi)))\n        \n        for mx in range(-m_max_recip, m_max_recip + 1):\n            for my in range(-m_max_recip, m_max_recip + 1):\n                for mz in range(-m_max_recip, m_max_recip + 1):\n                    # Exclude k=0 vector\n                    if mx == 0 and my == 0 and mz == 0:\n                        continue\n                    \n                    m_vec = np.array([mx, my, mz])\n                    k_vec = (2 * np.pi / L) * m_vec\n                    k_sq = np.dot(k_vec, k_vec)\n                    \n                    if np.sqrt(k_sq) = kmax:\n                        # Structure factor S(k)\n                        S_k = np.sum(charges * np.exp(1j * np.dot(positions, k_vec)))\n                        S_k_mag_sq = np.abs(S_k)**2\n                        \n                        E_recip += (np.exp(-k_sq / (4 * alpha**2)) / k_sq) * S_k_mag_sq\n    \n    E_recip *= (2 * np.pi / V)\n\n    # --- Self-interaction correction ---\n    sum_q_sq = np.sum(charges**2)\n    E_self = - (alpha / np.sqrt(np.pi)) * sum_q_sq\n    \n    return E_real + E_recip + E_self\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem as specified.\n    \"\"\"\n    # System specification\n    L = 1.0\n    charges = np.array([1.0, -1.0, 1.0, -1.0])\n    positions = np.array([\n        [0.10, 0.10, 0.10],\n        [0.90, 0.10, 0.10],\n        [0.50, 0.60, 0.20],\n        [0.20, 0.70, 0.80]\n    ])\n\n    # Reference calculation parameters\n    alpha_ref = 5.0\n    rc_ref = 2.0\n    kmax_ref = 30.0 * np.pi\n\n    # Calculate high-accuracy reference energy\n    E_ref = calculate_energy(alpha_ref, rc_ref, kmax_ref, charges, positions, L)\n\n    # Test suite parameters\n    test_cases = [\n        {'alpha': 4.0, 'rc': 0.49, 'kmax': 24.0 * np.pi},\n        {'alpha': 8.0, 'rc': 0.30, 'kmax': 12.0 * np.pi},\n        {'alpha': 1.5, 'rc': 0.20, 'kmax': 40.0 * np.pi},\n        {'alpha': 3.0, 'rc': 0.49, 'kmax': 0.0},\n        {'alpha': 3.0, 'rc': 0.00, 'kmax': 40.0 * np.pi},\n    ]\n\n    results = []\n    for case in test_cases:\n        E_approx = calculate_energy(case['alpha'], case['rc'], case['kmax'], charges, positions, L)\n        error = np.abs(E_approx - E_ref)\n        results.append(error)\n    \n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Ideal algorithms are often modified in practice to achieve the performance necessary for large-scale simulations. The Particle Mesh Ewald (PME) method, a fast implementation of the Ewald sum, relies on neighbor lists to efficiently compute the real-space part, but these lists must be periodically rebuilt, introducing a trade-off between accuracy and computational speed . This exercise allows you to quantify the numerical errors, such as energy drift, that arise from using a \"stale\" neighbor list, offering critical insight into the practical compromises made in molecular dynamics software.",
            "id": "3409615",
            "problem": "Consider a system of $N$ point charges in a cubic box with Periodic Boundary Conditions (PBC). The electrostatic interaction is modeled via Coulomb’s law, and the system uses the Particle Mesh Ewald (PME) method, which splits the interaction into a short-range real-space part and a long-range reciprocal-space part. The simulation uses a neighbor list for the real-space pairs built at discrete times, and the list is not continually rebuilt at every timestep. This causes errors when particles move into the cutoff region after the neighbor list was last built. Your task is to quantify the error introduced by infrequent neighbor list rebuilds by mapping the rebuild period to two metrics: total energy drift and instantaneous force error.\n\nStart from the following fundamental bases and facts:\n- Coulomb’s law for point charges in vacuum under classical mechanics, with the force proportional to the product of charges and inversely proportional to the square of the separation distance.\n- Newton’s second law of motion in a classical Molecular Dynamics setting, with continuous positions and velocities.\n- The PME splitting framework, which expresses the electrostatic potential energy of periodic systems as a sum of short-range (real-space) and long-range (reciprocal-space) contributions, augmented by a self-energy correction for point charges.\n- The neighbor list method for the real-space interaction under a cutoff and a nonzero skin distance.\n\nAssume the following definitions and conventions:\n- The box is cubic with edge length $L$ in nanometers (nm).\n- The PME splitting uses a screening parameter $\\alpha$ in inverse nanometers ($\\mathrm{nm}^{-1}$) and truncates the reciprocal-space sum at a maximum integer wave index $k_{\\max}$ in each Cartesian direction.\n- The real-space interaction uses a cutoff radius $r_c$ in nanometers and a neighbor-list skin distance $s$ in nanometers. The neighbor list is built at time $t = 0$ from all pairs with minimum-image separation less than or equal to $r_c + s$.\n- Positions evolve linearly as $\\mathbf{r}_i(t) = \\mathbf{r}_i(0) + \\mathbf{v}_i t$, with velocities in nanometers per picosecond ($\\mathrm{nm} / \\mathrm{ps}$), and are wrapped into the box using PBC.\n- The reciprocal-space force and energy are computed exactly within the PME truncation for the given $\\alpha$ and $k_{\\max}$ and do not depend on the neighbor list. The neighbor list affects only the real-space part.\n- The system is net-neutral, that is, $\\sum_i q_i = 0$.\n\nFor this problem:\n- Use $N = 8$ charges with values $q_i \\in \\{-1, +1\\}$ in elementary charge units, specifically four charges with $+1$ and four with $-1$.\n- Use edge length $L = 3.0$ nm, cutoff $r_c = 1.0$ nm, screening parameter $\\alpha = 3.5$ $\\mathrm{nm}^{-1}$, and maximum wave index $k_{\\max} = 4$.\n- Use Coulomb’s constant in Molecular Dynamics units as $k_C = 138.935456$ $\\mathrm{kJ} \\, \\mathrm{mol}^{-1} \\, \\mathrm{nm} \\, e^{-2}$.\n- Generate initial positions uniformly in $[0, L)$ in each Cartesian dimension and velocities from a normal distribution with zero mean and standard deviation $0.2$ $\\mathrm{nm}/\\mathrm{ps}$, using a fixed pseudorandom seed of $42$ to ensure reproducibility. Wrap positions at all times using PBC.\n\nDefine:\n- The “true” PME energy at time $t$ as the sum of the real-space energy (over all pairs within the cutoff $r_c$ at time $t$, using the minimum-image convention), the reciprocal-space energy truncated at $k_{\\max}$, and the self-energy correction. The “true” force is the sum of the corresponding real-space and reciprocal-space forces.\n- The “approximate” energy at time $t$ uses the same reciprocal-space energy and self-energy as the “true” energy, but the real-space energy is computed only over those pairs that were included in the neighbor list constructed at $t = 0$ (i.e., pairs with separation less than or equal to $r_c + s$ at $t = 0$) and that are within the cutoff $r_c$ at time $t$. The “approximate” force is computed analogously.\n\nAt a given rebuild period $T$ (in picoseconds), evaluate the following at time $t = T$:\n- The total energy drift defined as the absolute difference between the “approximate” and “true” total energies, expressed in kilojoules per mole ($\\mathrm{kJ}/\\mathrm{mol}$) and rounded to six decimal places.\n- The instantaneous force error defined as the root-mean-square (RMS) of the per-particle Euclidean norm of the difference between the “approximate” and “true” total forces, expressed in $\\mathrm{kJ} \\, \\mathrm{mol}^{-1} \\, \\mathrm{nm}^{-1}$ and rounded to six decimal places.\n\nUse the following test suite of neighbor-list rebuild periods $T$ (in picoseconds) and skin distances $s$ (in nanometers):\n- Case $1$: $T = 0.0$, $s = 0.20$.\n- Case $2$: $T = 0.10$, $s = 0.05$.\n- Case $3$: $T = 0.25$, $s = 0.10$.\n- Case $4$: $T = 0.50$, $s = 0.10$.\n\nYour program should:\n- Construct the neighbor list at $t = 0$ from all pairs with separation less than or equal to $r_c + s$.\n- Propagate positions to $t = T$ under linear motion with the given velocities, wrapped with PBC.\n- Compute the “true” energy and forces at $t = T$ under PME with the given truncation parameters.\n- Compute the “approximate” energy and forces at $t = T$ using the stale neighbor list for the real-space part.\n- Produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with entries ordered as $[\\text{drift}_1,\\text{force\\_error}_1,\\text{drift}_2,\\text{force\\_error}_2,\\text{drift}_3,\\text{force\\_error}_3,\\text{drift}_4,\\text{force\\_error}_4]$, where each drift is in $\\mathrm{kJ}/\\mathrm{mol}$ and each force error is in $\\mathrm{kJ} \\, \\mathrm{mol}^{-1} \\, \\mathrm{nm}^{-1}$, both rounded to six decimal places.",
            "solution": "### 1. Theoretical Framework\n\nThe problem asks for an analysis of errors arising from infrequent updates of a neighbor list in the context of a Particle Mesh Ewald (PME) electrostatic calculation. The PME method partitions the total electrostatic energy $E$ of a periodic system of charges into three components: a short-range real-space term ($E_{\\text{real}}$), a long-range reciprocal-space term ($E_{\\text{recip}}$), and a self-interaction correction ($E_{\\text{self}}$).\n\n$$ E = E_{\\text{real}} + E_{\\text{recip}} + E_{\\text{self}} $$\n\nThe problem defines \"true\" and \"approximate\" models for energy and forces. The key distinction lies in the real-space component, which is computed using a cutoff radius $r_c$. The reciprocal-space and self-energy terms are independent of the neighbor list and are assumed to be computed identically in both models. Consequently, when calculating the energy drift ($\\Delta E$) and force error ($\\Delta \\mathbf{F}_i$), these terms cancel out:\n\n$$ \\Delta E = |E_{\\text{approx}} - E_{\\text{true}}| = |(E_{\\text{real,approx}} + E_{\\text{recip}} + E_{\\text{self}}) - (E_{\\text{real,true}} + E_{\\text{recip}} + E_{\\text{self}})| = |E_{\\text{real,approx}} - E_{\\text{real,true}}| $$\n$$ \\Delta \\mathbf{F}_i = \\mathbf{F}_{\\text{approx},i} - \\mathbf{F}_{\\text{true},i} = (\\mathbf{F}_{\\text{real,approx},i} + \\mathbf{F}_{\\text{recip},i}) - (\\mathbf{F}_{\\text{real,true},i} + \\mathbf{F}_{\\text{recip},i}) = \\mathbf{F}_{\\text{real,approx},i} - \\mathbf{F}_{\\text{real,true},i} $$\n\nThis crucial simplification means we only need to implement the real-space contributions to energy and forces.\n\nThe real-space potential energy between two charges $q_i$ and $q_j$ separated by a minimum-image distance $r_{ij}$ is given by a screened Coulomb potential:\n$$ U_{\\text{real}}(r_{ij}) = k_C \\frac{q_i q_j \\text{erfc}(\\alpha r_{ij})}{r_{ij}} $$\nwhere $k_C$ is Coulomb's constant, $\\alpha$ is the Ewald screening parameter, and $\\text{erfc}$ is the complementary error function. The total real-space energy is the sum over all unique pairs $(i, j)$ with $i  j$ whose separation $r_{ij}$ is within the cutoff $r_c$:\n$$ E_{\\text{real}} = \\sum_{ij, r_{ij} \\le r_c} U_{\\text{real}}(r_{ij}) $$\n\nThe corresponding force on particle $i$ due to particle $j$ is $\\mathbf{F}_{ij} = -\\nabla_{\\mathbf{r}_i} U_{\\text{real}}(r_{ij})$. This evaluates to:\n$$ \\mathbf{F}_{ij} = k_C q_i q_j \\left( \\frac{\\text{erfc}(\\alpha r_{ij})}{r_{ij}^3} + \\frac{2\\alpha}{\\sqrt{\\pi}} \\frac{\\exp(-\\alpha^2 r_{ij}^2)}{r_{ij}^2} \\right) \\mathbf{r}_{ij} $$\nwhere $\\mathbf{r}_{ij} = \\mathbf{r}_i - \\mathbf{r}_j$ is the minimum-image separation vector. The total real-space force on particle $i$ is $\\mathbf{F}_{\\text{real},i} = \\sum_{j \\neq i, r_{ij} \\le r_c} \\mathbf{F}_{ij}$.\n\n### 2. Algorithmic Implementation\n\nThe solution proceeds by implementing the logic for the \"true\" and \"approximate\" real-space calculations for each test case.\n\n**Step 1: Initialization**\nWe begin by setting the physical constants and system parameters as specified: $N=8$, $L=3.0\\,\\text{nm}$, $r_c=1.0\\,\\text{nm}$, $\\alpha=3.5\\,\\text{nm}^{-1}$, and $k_C = 138.935456\\,\\mathrm{kJ} \\, \\mathrm{mol}^{-1} \\, \\mathrm{nm} \\, e^{-2}$. The charges are set to four $+1\\,e$ and four $-1\\,e$. Initial positions $\\mathbf{r}_i(0)$ and velocities $\\mathbf{v}_i$ are generated from the specified distributions using a fixed pseudorandom seed of $42$ to ensure reproducibility.\n\n**Step 2: Time Evolution**\nFor each test case with rebuild period $T$, particle positions are propagated linearly to time $t=T$:\n$$ \\mathbf{r}_i(T) = \\mathbf{r}_i(0) + \\mathbf{v}_i T $$\nThe resulting positions are then wrapped back into the primary cubic box $[0, L)^3$ to enforce periodic boundary conditions. The minimum image convention is applied to all pair separations $\\mathbf{r}_{ij} = \\mathbf{r}_i - \\mathbf{r}_j$, using the formula $\\mathbf{d}_{\\text{mic}} = \\mathbf{d} - L \\cdot \\text{round}(\\mathbf{d}/L)$.\n\n**Step 3: \"True\" and \"Approximate\" Calculations**\nA single loop over all unique pairs of particles $(i, j)$ with $i  j$ is used to compute both \"true\" and \"approximate\" contributions efficiently.\n\nFor each pair $(i, j)$:\n1.  The separation distance $r_{ij}(0)$ at time $t=0$ is computed. This determines if the pair belongs to the neighbor list, i.e., if $r_{ij}(0) \\le r_c + s$.\n2.  The separation distance $r_{ij}(T)$ at time $t=T$ is computed. This determines if the pair is currently a candidate for interaction, i.e., if $r_{ij}(T) \\le r_c$.\n\n-   **True Calculation**: A pair contributes to $E_{\\text{real,true}}$ and $\\mathbf{F}_{\\text{real,true}}$ if and only if its separation at time $T$ satisfies $r_{ij}(T) \\le r_c$.\n-   **Approximate Calculation**: A pair contributes to $E_{\\text{real,approx}}$ and $\\mathbf{F}_{\\text{real,approx}}$ if and only if it was in the neighbor list from $t=0$ (i.e., $r_{ij}(0) \\le r_c + s$) AND its separation at time $T$ satisfies $r_{ij}(T) \\le r_c$.\n\nThe energy and force contributions for an interacting pair are calculated using the formulas provided in the theoretical framework.\n\n**Step 4: Error Metrics**\nAfter iterating through all pairs, the total real-space energies ($E_{\\text{real,true}}, E_{\\text{real,approx}}$) and force vectors ($\\mathbf{F}_{\\text{real,true}}, \\mathbf{F}_{\\text{real,approx}}$) are fully assembled. The required metrics are then calculated.\n\n-   **Total Energy Drift**: This is the absolute difference between the approximate and true real-space energies.\n    $$ \\text{drift} = |E_{\\text{real,approx}} - E_{\\text{real,true}}| $$\n-   **Instantaneous Force Error**: This is the root-mean-square of the Euclidean norm of the per-particle force differences.\n    $$ \\text{force\\_error} = \\sqrt{\\frac{1}{N} \\sum_{i=1}^N ||\\mathbf{F}_{\\text{real,approx},i} - \\mathbf{F}_{\\text{real,true},i}||^2} $$\n\nThis procedure is repeated for all four test cases defined in the problem, and the results are collected and formatted. For the case $T=0.0$, the positions do not change, so any pair with $r_{ij}(0) \\le r_c$ will also satisfy the neighbor list condition $r_{ij}(0) \\le r_c + s$ (for $s \\ge 0$). Thus, the \"true\" and \"approximate\" interaction sets are identical, leading to zero drift and error, which serves as a validation of the algorithm.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import erfc\n\ndef solve():\n    \"\"\"\n    Calculates the energy drift and force error due to infrequent neighbor list\n    rebuilds in a PME simulation.\n    \"\"\"\n    # Define system parameters and constants from the problem statement.\n    N = 8\n    L = 3.0  # Box edge length in nm\n    rc = 1.0  # Real-space cutoff in nm\n    alpha = 3.5  # Ewald screening parameter in nm^-1\n    kC = 138.935456  # Coulomb's constant in kJ mol^-1 nm e^-2\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (Rebuild period T in ps, skin distance s in nm)\n        (0.0, 0.20),\n        (0.10, 0.05),\n        (0.25, 0.10),\n        (0.50, 0.10),\n    ]\n\n    # Generate initial positions and velocities using a fixed seed for reproducibility.\n    rng = np.random.default_rng(seed=42)\n    charges = np.array([1.0] * 4 + [-1.0] * 4)  # 4x +1e, 4x -1e\n    pos_0 = rng.uniform(0, L, size=(N, 3))\n    vel = rng.normal(loc=0.0, scale=0.2, size=(N, 3))  # nm/ps\n\n    results = []\n\n    def calculate_pair_interaction(q_i, q_j, r_vec, r_norm):\n        \"\"\"\n        Calculates the real-space PME energy and force for a single pair.\n        \"\"\"\n        if r_norm == 0:\n            return 0.0, np.zeros(3)\n\n        qiqj = q_i * q_j\n        erfc_alpha_r = erfc(alpha * r_norm)\n\n        # Energy contribution\n        energy = kC * qiqj * erfc_alpha_r / r_norm\n\n        # Force contribution (vector)\n        f_scalar_part = kC * qiqj * (\n            erfc_alpha_r / r_norm**3 +\n            (2 * alpha / np.sqrt(np.pi)) * np.exp(-alpha**2 * r_norm**2) / r_norm**2\n        )\n        force_vec = f_scalar_part * r_vec\n\n        return energy, force_vec\n\n    # Process each test case\n    for T, s in test_cases:\n        # Propagate positions linearly to time T\n        pos_T = pos_0 + vel * T\n        # Apply periodic boundary conditions (wrap positions into [0, L))\n        pos_T = pos_T - L * np.floor(pos_T / L)\n\n        E_true = 0.0\n        F_true = np.zeros((N, 3))\n        E_approx = 0.0\n        F_approx = np.zeros((N, 3))\n\n        # Iterate over all unique pairs to calculate contributions\n        for i in range(N):\n            for j in range(i + 1, N):\n                # Minimum Image Convention for separation vector at t=0\n                r_vec_0 = pos_0[i] - pos_0[j]\n                r_vec_0 -= L * np.round(r_vec_0 / L)\n                r_norm_0 = np.linalg.norm(r_vec_0)\n\n                # Minimum Image Convention for separation vector at t=T\n                r_vec_T = pos_T[i] - pos_T[j]\n                r_vec_T -= L * np.round(r_vec_T / L)\n                r_norm_T = np.linalg.norm(r_vec_T)\n                \n                # Check for interaction at t=T and compute contributions\n                if r_norm_T > 0 and r_norm_T = rc:\n                    energy, force = calculate_pair_interaction(charges[i], charges[j], r_vec_T, r_norm_T)\n                    \n                    # Always add to \"true\" calculation if within cutoff at t=T\n                    E_true += energy\n                    F_true[i] += force\n                    F_true[j] -= force\n\n                    # Add to \"approximate\" calculation only if also in neighbor list from t=0\n                    is_in_nl = (r_norm_0 = rc + s)\n                    if is_in_nl:\n                        E_approx += energy\n                        F_approx[i] += force\n                        F_approx[j] -= force\n\n        # Calculate final metrics for the current case\n        energy_drift = abs(E_approx - E_true)\n        force_difference_vectors = F_approx - F_true\n        \n        # RMS of the per-particle Euclidean norm of the force difference\n        rms_force_error = np.sqrt(np.mean(np.sum(force_difference_vectors**2, axis=1)))\n\n        results.extend([round(energy_drift, 6), round(rms_force_error, 6)])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}