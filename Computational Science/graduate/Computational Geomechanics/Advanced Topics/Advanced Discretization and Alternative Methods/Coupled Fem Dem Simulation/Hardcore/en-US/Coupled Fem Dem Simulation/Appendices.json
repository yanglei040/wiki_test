{
    "hands_on_practices": [
        {
            "introduction": "A primary challenge in coupled FEM-DEM simulations is ensuring that fundamental physical laws, like conservation of mass and momentum, are respected across the entire model. When a volume is represented by both a continuum mesh and discrete particles, it is easy to inadvertently \"double-count\" body forces such as gravity. This exercise provides a hands-on method for correctly partitioning these forces to maintain global static equilibrium, a non-negotiable prerequisite for any physically meaningful simulation. By deriving the partitioning scheme from first principles, you will gain a foundational understanding of how to construct a consistent and stable coupled model .",
            "id": "3512677",
            "problem": "A prismatic soil specimen is modeled in a coupled Finite Element Method (FEM) and Discrete Element Method (DEM) simulation. The specimen is a rectangular block of dimensions $L_{x} = 2\\,\\mathrm{m}$, $L_{y} = 3\\,\\mathrm{m}$, and $L_{z} = 1\\,\\mathrm{m}$, so its total volume is $V = L_{x} L_{y} L_{z}$. The bulk density of the soil is uniform and equal to $\\rho = 1700\\,\\mathrm{kg/m^{3}}$. Gravity acts in the negative $y$-direction with magnitude $g = 9.81\\,\\mathrm{m/s^{2}}$. The base at $y=0$ is perfectly rigid, frictionless, and provides the sole vertical reaction. No other external loads act on the specimen.\n\nTo capture grain-scale response in a subregion, a rectangular subvolume $V_{p}$ of dimensions $a = 1\\,\\mathrm{m}$, $b = 2\\,\\mathrm{m}$, and $c = 1\\,\\mathrm{m}$ is simultaneously represented by $N_{p} = 1600$ DEM particles, each with mass $m_{p} = 0.375\\,\\mathrm{kg}$. The DEM particles experience their own gravitational forces $m_{p} g$. The FEM continuum spans the entire specimen, including $V_{p}$. To avoid double counting of body forces in $V_{p}$, the FEM body-force density there is scaled by an unknown constant factor $\\alpha \\in [0,1]$, while outside $V_{p}$ the FEM uses the full body-force density $\\rho g$. The Discrete Element Method (DEM) particles are coupled to the continuum in the overlap through kinematic/contact constraints but do not alter $g$.\n\nStarting only from Newton's second law and the definition of body force as the integral of $\\rho \\mathbf{g}$ over volume, derive the condition on $\\alpha$ that enforces global static equilibrium in the vertical direction and thereby avoids double counting of gravity in the overlap. Then, using that condition, compute the vertical reaction at the base (the total compressive support force) under gravity loading for the described configuration.\n\nReport only the final base reaction magnitude in $\\mathrm{kN}$, rounded to four significant figures.",
            "solution": "The problem asks for the vertical reaction at the base of a prismatic soil specimen under gravity loading, as modeled by a coupled Finite Element Method (FEM) and Discrete Element Method (DEM) simulation. The solution requires first establishing the condition for consistent representation of gravitational forces across the coupled domains and then applying static equilibrium.\n\nAccording to Newton's second law, for a system in static equilibrium, the vector sum of all external forces is zero. Let the vertical direction be the $y$-axis. The external forces acting on the soil specimen are the total gravitational force, $\\mathbf{W}_{total}$, acting in the negative $y$-direction, and the base reaction force, $\\mathbf{F}_{R}$, acting in the positive $y$-direction. The problem states that the base provides the sole vertical reaction. Therefore, for static equilibrium in the vertical direction, we have:\n$$ \\sum F_{y} = F_{R} - W_{total} = 0 $$\nwhere $F_{R}$ and $W_{total}$ are the magnitudes of the respective forces. This implies that the magnitude of the base reaction is equal to the total weight of the system:\n$$ F_{R} = W_{total} $$\n\nThe core of the problem is to determine the correct total weight, $W_{total}$, that the coupled FEM/DEM model must represent. For the numerical simulation to be physically meaningful, the total gravitational force it calculates must be identical to the gravitational force acting on the physical object it models. The physical object is a prismatic soil specimen of total volume $V$ and uniform bulk density $\\rho$. Its total mass is $M = \\rho V$, and its total weight is $W_{physical} = M g = \\rho V g$. Thus, we must enforce the condition that the total weight calculated from the numerical model, $W_{model}$, equals this physical weight:\n$$ W_{model} = W_{physical} = \\rho V g $$\n\nThe total weight in the numerical model, $W_{model}$, is the sum of the gravitational forces applied in the FEM domain ($W_{FEM}$) and the DEM domain ($W_{DEM}$):\n$$ W_{model} = W_{FEM} + W_{DEM} $$\n\nThe DEM contribution consists of the gravitational forces acting on the $N_{p}$ discrete particles within the subvolume $V_{p}$. Each particle has a mass $m_{p}$. The total weight of all DEM particles is:\n$$ W_{DEM} = N_{p} m_{p} g $$\n\nThe FEM contribution is the integral of the body-force density over the entire volume $V$. The body-force density is defined piecewise. The specimen volume $V$ is composed of the subvolume $V_{p}$ and the remaining volume $V_{out} = V - V_{p}$.\nThe gravitational force from the FEM continuum outside the overlap region is calculated using the full body-force density $\\rho g$:\n$$ W_{FEM, out} = \\int_{V_{out}} \\rho g \\,dV = \\rho g V_{out} = \\rho g (V - V_{p}) $$\nInside the overlap region $V_{p}$, the FEM body-force density is scaled by a factor $\\alpha$:\n$$ W_{FEM, in} = \\int_{V_{p}} \\alpha \\rho g \\,dV = \\alpha \\rho g V_{p} $$\nThe total FEM weight is the sum of these two parts:\n$$ W_{FEM} = W_{FEM, out} + W_{FEM, in} = \\rho g (V - V_{p}) + \\alpha \\rho g V_{p} $$\n\nNow, we can assemble the expression for the total modeled weight:\n$$ W_{model} = W_{FEM} + W_{DEM} = \\left[ \\rho g (V - V_{p}) + \\alpha \\rho g V_{p} \\right] + N_{p} m_{p} g $$\n\nTo avoid double counting of gravity in the overlap region $V_p$ and ensure physical consistency, we enforce $W_{model} = W_{physical}$:\n$$ \\rho g (V - V_{p}) + \\alpha \\rho g V_{p} + N_{p} m_{p} g = \\rho g V $$\nSince $g \\neq 0$, we can divide all terms by $g$:\n$$ \\rho (V - V_{p}) + \\alpha \\rho V_{p} + N_{p} m_{p} = \\rho V $$\nExpanding the first term:\n$$ \\rho V - \\rho V_{p} + \\alpha \\rho V_{p} + N_{p} m_{p} = \\rho V $$\nSubtracting $\\rho V$ from both sides and rearranging to solve for $\\alpha$:\n$$ -\\rho V_{p} + \\alpha \\rho V_{p} + N_{p} m_{p} = 0 $$\n$$ \\alpha \\rho V_{p} = \\rho V_{p} - N_{p} m_{p} $$\n$$ \\alpha = \\frac{\\rho V_{p} - N_{p} m_{p}}{\\rho V_{p}} = 1 - \\frac{N_{p} m_{p}}{\\rho V_{p}} $$\nThis equation is the condition on $\\alpha$ that ensures the gravitational force is correctly partitioned between the FEM and DEM representations, so that their sum equals the true physical weight.\n\nThe problem asks for the vertical reaction force at the base, $F_{R}$. As established from static equilibrium, $F_{R} = W_{total}$. The entire purpose of the derived coupling scheme is to ensure that the total weight of the model, $W_{model}$, equals the physical weight of the soil specimen, $W_{physical} = \\rho V g$. Therefore, the total downward force to be balanced by the base is simply the physical weight of the entire soil block.\n\nWe now calculate this value using the given data:\nThe dimensions of the specimen are $L_{x} = 2\\,\\mathrm{m}$, $L_{y} = 3\\,\\mathrm{m}$, and $L_{z} = 1\\,\\mathrm{m}$.\nThe total volume is $V = L_{x} L_{y} L_{z} = (2\\,\\mathrm{m}) (3\\,\\mathrm{m}) (1\\,\\mathrm{m}) = 6\\,\\mathrm{m^3}$.\nThe bulk density is $\\rho = 1700\\,\\mathrm{kg/m^{3}}$.\nThe gravitational acceleration is $g = 9.81\\,\\mathrm{m/s^{2}}$.\n\nThe total weight of the physical specimen, and thus the required base reaction, is:\n$$ F_{R} = \\rho V g = (1700\\,\\mathrm{kg/m^3}) \\times (6\\,\\mathrm{m^3}) \\times (9.81\\,\\mathrm{m/s^2}) $$\n$$ F_{R} = (10200\\,\\mathrm{kg}) \\times (9.81\\,\\mathrm{m/s^2}) = 100062\\,\\mathrm{N} $$\n\nThe problem requires the answer in kilonewtons ($\\mathrm{kN}$), rounded to four significant figures.\n$$ F_{R} = 100.062\\,\\mathrm{kN} $$\nRounding to four significant figures gives $100.1\\,\\mathrm{kN}$.",
            "answer": "$$\\boxed{100.1}$$"
        },
        {
            "introduction": "Having established global consistency, we now turn to the micro-scale physics governing the interaction between discrete particles and the continuum boundary. Realistic geomechanical behavior, from soil shearing to rock fracture, is critically dependent on the stick-slip nature of frictional contact. This practice guides you through the implementation of a return mapping algorithm, a cornerstone of computational contact mechanics, to update tangential forces under a Coulomb friction law. Mastering this predictor-corrector scheme is essential for accurately capturing history-dependent phenomena and the dissipation of energy at interfaces in coupled simulations .",
            "id": "3512619",
            "problem": "Consider a single contact between a Discrete Element Method (DEM) particle and a Finite Element Method (FEM) boundary in computational geomechanics. The contact follows a Coulomb friction law in the tangential direction and a linear elastic law in the tangential direction, with history dependence through a stored elastic tangential displacement. Let the state variable be the elastic tangential displacement vector $\\boldsymbol{\\delta}_t \\in \\mathbb{R}^d$ in the local tangential plane, and let the tangential contact force be given by Hooke's law $\\mathbf{f}_t = k_t \\boldsymbol{\\delta}_t$, where $k_t > 0$ is the tangential contact stiffness. The Coulomb friction constraint requires that the tangential force magnitude satisfies the inequality $\\|\\mathbf{f}_t\\| \\le \\mu f_n$, where $\\mu \\ge 0$ is the friction coefficient and $f_n \\ge 0$ is the compressive normal contact force magnitude. The incremental tangential relative displacement over a time step is $\\Delta \\mathbf{u}_t \\in \\mathbb{R}^d$. The update must be history-dependent: the new elastic tangential displacement depends on the previous state and the increment.\n\nStarting from fundamental principles and core definitions relevant to contact mechanics:\n- Newton's second law,\n- Hooke's law in tangential direction $\\mathbf{f}_t = k_t \\boldsymbol{\\delta}_t$,\n- The Coulomb friction law represented by the admissible set $\\{\\mathbf{f}_t \\in \\mathbb{R}^d \\mid \\|\\mathbf{f}_t\\| \\le \\mu f_n\\}$,\n- Kinematic additivity of increments for the elastic part of tangential displacement under stick,\n\nderive a predictor-corrector incremental update rule for the tangential contact force that enforces $\\|\\mathbf{f}_t\\| \\le \\mu f_n$ at the end of the step. The predictor should assume purely elastic stick behavior, and the corrector should minimally adjust the elastic tangential displacement to satisfy the Coulomb constraint when violated (stick-slip transition). Your update must:\n- Use the elastic trial state to predict $\\boldsymbol{\\delta}_t^{\\text{trial}}$ and $\\mathbf{f}_t^{\\text{trial}}$,\n- Decide stick versus slip by checking the Coulomb admissibility of the trial force,\n- In stick, accept the trial state,\n- In slip, correct the elastic tangential displacement so that the updated force lies on the boundary $\\|\\mathbf{f}_t\\| = \\mu f_n$ in the direction of the trial state, ensuring minimal change needed to restore admissibility.\n\nImplement a program that computes, for each test case, the updated tangential force magnitude $\\|\\mathbf{f}_t^{n+1}\\|$ in Newtons and a stick indicator as an integer equal to $1$ for stick and $0$ for slip. The program must accept the following parameters for each test case: previous elastic tangential displacement $\\boldsymbol{\\delta}_t^n$ in meters, increment $\\Delta \\mathbf{u}_t$ in meters, tangential stiffness $k_t$ in Newtons per meter, friction coefficient $\\mu$ (dimensionless), and normal force magnitude $f_n$ in Newtons. Assume the tangential space is two-dimensional, i.e., $d = 2$.\n\nExpress the final tangential force magnitude in Newtons and the stick indicator as an integer. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case result is represented as a list $\\left[\\|\\mathbf{f}_t^{n+1}\\|, s\\right]$ with $s \\in \\{0,1\\}$.\n\nUse the following test suite of six parameter sets to exercise the update rule, covering a general case, slip, boundary equality, zero normal force, nonzero history, and mixed-direction slip. For each set, list the parameters $\\left(\\boldsymbol{\\delta}_t^n, \\Delta \\mathbf{u}_t, k_t, \\mu, f_n\\right)$:\n\n- Test $1$ (general stick): $\\boldsymbol{\\delta}_t^n = [0, 0]$ meters, $\\Delta \\mathbf{u}_t = [0.002, 0]$ meters, $k_t = 100000$ Newtons per meter, $\\mu = 0.6$, $f_n = 1000$ Newtons.\n- Test $2$ (general slip): $\\boldsymbol{\\delta}_t^n = [0, 0]$ meters, $\\Delta \\mathbf{u}_t = [0.01, 0]$ meters, $k_t = 100000$ Newtons per meter, $\\mu = 0.6$, $f_n = 1000$ Newtons.\n- Test $3$ (boundary equality): $\\boldsymbol{\\delta}_t^n = [0, 0]$ meters, $\\Delta \\mathbf{u}_t = [0.006, 0]$ meters, $k_t = 100000$ Newtons per meter, $\\mu = 0.6$, $f_n = 1000$ Newtons.\n- Test $4$ (zero normal force): $\\boldsymbol{\\delta}_t^n = [0, 0]$ meters, $\\Delta \\mathbf{u}_t = [0.01, 0]$ meters, $k_t = 100000$ Newtons per meter, $\\mu = 0.6$, $f_n = 0$ Newtons.\n- Test $5$ (nonzero history leading to slip): $\\boldsymbol{\\delta}_t^n = [0.005, 0]$ meters, $\\Delta \\mathbf{u}_t = [0.003, 0]$ meters, $k_t = 100000$ Newtons per meter, $\\mu = 0.6$, $f_n = 1000$ Newtons.\n- Test $6$ (mixed-direction slip): $\\boldsymbol{\\delta}_t^n = [0.002, 0.002]$ meters, $\\Delta \\mathbf{u}_t = [0.004, -0.003]$ meters, $k_t = 100000$ Newtons per meter, $\\mu = 0.6$, $f_n = 1000$ Newtons.\n\nYour program must compute the updated tangential force magnitude $\\|\\mathbf{f}_t^{n+1}\\|$ for each test case in Newtons and the stick indicator as an integer. The program must output a single line containing a comma-separated list of the six results in the format $\\left[ [\\|\\mathbf{f}_t^{n+1}\\|, s], \\ldots \\right]$.",
            "solution": "The problem statement is valid as it presents a well-posed, scientifically grounded problem in computational contact mechanics, providing all necessary data for its resolution. The task is to derive and implement a predictor-corrector algorithm, also known as a return mapping algorithm, for updating the tangential contact force under a Coulomb friction law.\n\nThe state of the contact at the beginning of a time step, denoted by the superscript $n$, is characterized by the elastic tangential displacement vector $\\boldsymbol{\\delta}_t^n$. The objective is to compute the updated state at the end of the time step, $n+1$, given the incremental relative tangential displacement $\\Delta \\mathbf{u}_t$ that occurs during the step. The fundamental equations governing the contact are Hooke's law for the tangential force, $\\mathbf{f}_t = k_t \\boldsymbol{\\delta}_t$, and the Coulomb friction constraint, $\\|\\mathbf{f}_t\\| \\le \\mu f_n$.\n\nThe derivation proceeds in three stages: a predictor stage assuming elastic behavior, an admissibility check against the friction criterion, and a corrector stage to enforce the criterion if it is violated.\n\n**1. Predictor: Elastic Trial State**\n\nThe predictor step assumes the contact patch \"sticks,\" meaning the incremental relative displacement $\\Delta \\mathbf{u}_t$ is entirely accommodated by a change in the elastic tangential displacement. The trial elastic tangential displacement at the end of the step, $\\boldsymbol{\\delta}_t^{\\text{trial}}$, is calculated by adding the displacement increment to the previous elastic displacement:\n$$\n\\boldsymbol{\\delta}_t^{\\text{trial}} = \\boldsymbol{\\delta}_t^n + \\Delta \\mathbf{u}_t\n$$\nwhere $\\boldsymbol{\\delta}_t^n$ is the elastic tangential displacement at the start of the time step.\n\nUsing Hooke's law, the corresponding trial tangential contact force, $\\mathbf{f}_t^{\\text{trial}}$, is:\n$$\n\\mathbf{f}_t^{\\text{trial}} = k_t \\boldsymbol{\\delta}_t^{\\text{trial}}\n$$\n\n**2. Admissibility Check: Coulomb's Friction Law**\n\nThe Coulomb friction law defines a convex set of admissible tangential forces. A tangential force $\\mathbf{f}_t$ is admissible if and only if its magnitude does not exceed the maximum static friction force, which is proportional to the normal contact force magnitude $f_n$. Let $f_{t,\\text{max}}$ be this maximum magnitude:\n$$\nf_{t,\\text{max}} = \\mu f_n\n$$\nwhere $\\mu$ is the coefficient of friction. Note that the problem provides $f_n$ as the normal force magnitude for the current step, which we interpret as $f_n^{n+1}$. The admissibility condition is:\n$$\n\\|\\mathbf{f}_t\\| \\le f_{t,\\text{max}}\n$$\nWe evaluate this condition for the trial force $\\mathbf{f}_t^{\\text{trial}}$.\n\n**3. Corrector: State Update**\n\nThe update rule depends on the outcome of the admissibility check.\n\n**Case A: Stick Condition**\n\nIf the magnitude of the trial force is within the admissible limit, i.e.,\n$$\n\\|\\mathbf{f}_t^{\\text{trial}}\\| \\le f_{t,\\text{max}}\n$$\nthe initial \"stick\" assumption is validated. The contact does not slip. The final state at the end of the time step, $n+1$, is identical to the trial state. The stick indicator, $s$, is set to $1$.\n- Updated elastic tangential displacement: $\\boldsymbol{\\delta}_t^{n+1} = \\boldsymbol{\\delta}_t^{\\text{trial}}$\n- Updated tangential force: $\\mathbf{f}_t^{n+1} = \\mathbf{f}_t^{\\text{trial}}$\n- Updated tangential force magnitude: $\\|\\mathbf{f}_t^{n+1}\\| = \\|\\mathbf{f}_t^{\\text{trial}}\\|$\n- Stick indicator: $s = 1$\n\nThis case also correctly handles the boundary condition where $\\|\\mathbf{f}_t^{\\text{trial}}\\| = f_{t,\\text{max}}$.\n\n**Case B: Slip Condition**\n\nIf the magnitude of the trial force exceeds the admissible limit, i.e.,\n$$\n\\|\\mathbf{f}_t^{\\text{trial}}\\| > f_{t,\\text{max}}\n$$\nthe \"stick\" assumption is invalid. The contact must slip, and plastic (irreversible) deformation occurs. The updated tangential force $\\mathbf{f}_t^{n+1}$ must lie on the boundary of the admissible region (the friction circle). The principle of minimal change (or, more formally, the principle of maximum plastic dissipation) dictates that the correction is made by returning the trial force radially to the friction circle. This means the final force vector $\\mathbf{f}_t^{n+1}$ has the same direction as the trial force vector $\\mathbf{f}_t^{\\text{trial}}$, but its magnitude is scaled down to $f_{t,\\text{max}}$. The stick indicator, $s$, is set to $0$.\n\nThe updated force is calculated as:\n$$\n\\mathbf{f}_t^{n+1} = f_{t,\\text{max}} \\frac{\\mathbf{f}_t^{\\text{trial}}}{\\|\\mathbf{f}_t^{\\text{trial}}\\|}\n$$\nThis can be expressed using a scaling factor $\\gamma$:\n$$\n\\gamma = \\frac{f_{t,\\text{max}}}{\\|\\mathbf{f}_t^{\\text{trial}}\\|}\n$$\nwhere, for the slip case, $0 \\le \\gamma < 1$. The updated state variables are:\n- Updated tangential force: $\\mathbf{f}_t^{n+1} = \\gamma \\mathbf{f}_t^{\\text{trial}}$\n- Updated elastic tangential displacement: $\\boldsymbol{\\delta}_t^{n+1} = \\gamma \\boldsymbol{\\delta}_t^{\\text{trial}}$\n- Updated tangential force magnitude: $\\|\\mathbf{f}_t^{n+1}\\| = f_{t,\\text{max}} = \\mu f_n$\n- Stick indicator: $s = 0$\n\nThis radial return formulation ensures a unique and physically consistent solution. It also correctly handles the case where $f_n = 0$, which implies $f_{t,\\text{max}} = 0$. Any non-zero trial force will result in slip, and the final force magnitude will be correctly updated to $0$.\n\nThe implementation will follow this algorithmic logic for each provided test case.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the updated tangential contact force and stick/slip status\n    for a series of test cases based on a predictor-corrector algorithm\n    for Coulomb friction.\n    \"\"\"\n    # Test cases defined as tuples of:\n    # (delta_t_n, delta_u_t, k_t, mu, f_n)\n    # where delta_t_n and delta_u_t are 2D vectors.\n    test_cases = [\n        (np.array([0.0, 0.0]), np.array([0.002, 0.0]), 100000.0, 0.6, 1000.0),\n        (np.array([0.0, 0.0]), np.array([0.01, 0.0]), 100000.0, 0.6, 1000.0),\n        (np.array([0.0, 0.0]), np.array([0.006, 0.0]), 100000.0, 0.6, 1000.0),\n        (np.array([0.0, 0.0]), np.array([0.01, 0.0]), 100000.0, 0.6, 0.0),\n        (np.array([0.005, 0.0]), np.array([0.003, 0.0]), 100000.0, 0.6, 1000.0),\n        (np.array([0.002, 0.002]), np.array([0.004, -0.003]), 100000.0, 0.6, 1000.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        delta_t_n, delta_u_t, k_t, mu, f_n = case\n\n        # Step 1: Predictor (Elastic Trial State)\n        # Assume pure stick behavior where the incremental displacement is purely elastic.\n        delta_t_trial = delta_t_n + delta_u_t\n        f_t_trial = k_t * delta_t_trial\n\n        # Step 2: Admissibility Check\n        # Calculate the magnitude of the trial force and the maximum allowable friction force.\n        f_t_trial_norm = np.linalg.norm(f_t_trial)\n        f_t_max = mu * f_n\n\n        # Step 3: Corrector (Update based on stick/slip condition)\n        if f_t_trial_norm <= f_t_max:\n            # Case A: Stick condition is met.\n            # The trial state is the final state.\n            f_t_final_norm = f_t_trial_norm\n            stick_indicator = 1\n        else:\n            # Case B: Slip condition.\n            # The force is corrected by scaling it back to the friction circle.\n            # The magnitude of the final force is the maximum allowable friction force.\n            f_t_final_norm = f_t_max\n            stick_indicator = 0\n        \n        results.append([f_t_final_norm, stick_indicator])\n\n    # Format the final output string as a list of lists.\n    # Each inner list is formatted as [force_magnitude, stick_indicator].\n    formatted_results = [f\"[{res[0]}, {res[1]}]\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A coupled model is only useful if its discrete component, upon averaging, correctly reproduces the behavior of the continuum it replaces. This principle is formally verified using a patch test, a fundamental procedure in computational mechanics for validating element formulations and coupling schemes. In this exercise, you will construct a DEM assembly, homogenize its stress response under a prescribed strain, and compare it to the analytical continuum stress. This process demonstrates how micro-scale bond mechanics scale up to macro-scale elasticity, providing a powerful method to calibrate and verify the consistency of your multiscale model .",
            "id": "3512644",
            "problem": "Consider a two-dimensional, plane strain patch test in computational geomechanics for a coupled Finite Element Method (FEM) and Discrete Element Method (DEM) simulation. A Discrete Element Method (DEM) assembly of bonded circular grains is embedded within a single square Finite Element Method (FEM) element. The domain is a square of side length $h$ (in meters) and unit thickness (in meters), so the volume is $V = h^2 \\times 1$. The grains form a hexagonal (triangular) lattice with center-to-center spacing equal to the particle diameter $d$ (in meters). Each pair of neighboring grains is connected by a cohesive, linear, vector-valued bond that resists relative translation. The displacement field imposed on both the FEM and DEM models is the uniform small-strain field $u(x) = \\boldsymbol{\\varepsilon}\\, x$, where the plane strain tensor $ \\boldsymbol{\\varepsilon} $ represents a pure shear with engineering shear magnitude $ \\gamma $, given by\n$$\n\\boldsymbol{\\varepsilon} = \\begin{bmatrix} 0 & \\gamma/2 \\\\ \\gamma/2 & 0 \\end{bmatrix}.\n$$\n\nThe bonded DEM force on contact $c$ connecting grain centers at positions $x_i$ and $x_j$ is modeled by a linear spring law\n$$\n\\boldsymbol{f}_c = k_b \\left( \\boldsymbol{u}(x_j) - \\boldsymbol{u}(x_i) \\right) = k_b \\left( \\boldsymbol{\\varepsilon}\\, \\boldsymbol{l}_c \\right),\n$$\nwhere $k_b$ is the bond stiffness (in Newtons per meter), and the branch vector is $\\boldsymbol{l}_c = x_j - x_i$ (in meters). The homogenized DEM stress uses the Love–Weber formula\n$$\n\\boldsymbol{\\sigma}_{\\mathrm{DEM}} = \\frac{1}{V} \\sum_{c} \\boldsymbol{f}_c \\otimes \\boldsymbol{l}_c = \\frac{k_b}{V}\\, \\boldsymbol{\\varepsilon}\\, \\boldsymbol{S}, \\quad \\text{with} \\quad \\boldsymbol{S} = \\sum_{c} \\boldsymbol{l}_c \\otimes \\boldsymbol{l}_c.\n$$\n\nThe FEM stress for an isotropic, linear elastic material in plane strain with Young’s modulus $E$ (in Pascals) and Poisson’s ratio $\\nu$ is\n$$\n\\boldsymbol{\\sigma}_{\\mathrm{FEM}} = \\boldsymbol{C} : \\boldsymbol{\\varepsilon} = 2 \\mu\\, \\boldsymbol{\\varepsilon} + \\lambda \\, \\mathrm{tr}(\\boldsymbol{\\varepsilon}) \\boldsymbol{I},\n$$\nwith Lamé parameters $ \\mu = \\dfrac{E}{2(1+\\nu)} $ and $ \\lambda = \\dfrac{\\nu E}{(1+\\nu)(1-2\\nu)} $. For the specified pure shear ($\\mathrm{tr}(\\boldsymbol{\\varepsilon}) = 0$), this reduces to\n$$\n\\boldsymbol{\\sigma}_{\\mathrm{FEM}} = 2 \\mu\\, \\boldsymbol{\\varepsilon}.\n$$\n\nTo consistently couple the DEM assembly to the FEM material in shear, calibrate $k_b$ using the DEM geometry through the trace of $\\boldsymbol{S}$, which satisfies $\\mathrm{tr}(\\boldsymbol{S}) = \\sum_c \\|\\boldsymbol{l}_c\\|^2$, by enforcing the shear modulus match in the isotropic limit:\n$$\nk_b = \\frac{4 \\mu V}{\\mathrm{tr}(\\boldsymbol{S})}.\n$$\n\nYour task is to implement a complete program that:\n- Constructs the DEM hexagonal lattice inside the square domain of side length $h$ with particle spacing $d$.\n- Builds bonds between lattice neighbors to approximate six directions per interior grain.\n- Computes the DEM geometry tensor $\\boldsymbol{S}$ and calibrates $k_b$ via the formula $k_b = \\dfrac{4 \\mu V}{\\mathrm{tr}(\\boldsymbol{S})}$.\n- Computes $\\boldsymbol{\\sigma}_{\\mathrm{DEM}} = \\dfrac{k_b}{V}\\, \\boldsymbol{\\varepsilon}\\, \\boldsymbol{S}$ and $\\boldsymbol{\\sigma}_{\\mathrm{FEM}} = 2\\mu\\, \\boldsymbol{\\varepsilon}$.\n- Evaluates the relative Frobenius norm error\n$$\ne_{\\mathrm{rel}} = \\frac{\\| \\boldsymbol{\\sigma}_{\\mathrm{DEM}} - \\boldsymbol{\\sigma}_{\\mathrm{FEM}} \\|_F}{\\| \\boldsymbol{\\sigma}_{\\mathrm{FEM}} \\|_F},\n$$\nand checks whether $e_{\\mathrm{rel}}$ is less than or equal to a specified tolerance.\n\nPhysical units and numerical specifications:\n- Use $E$ in Pascals, $\\nu$ dimensionless, $h$ and $d$ in meters, $\\gamma$ dimensionless, stresses in Pascals.\n- The error $e_{\\mathrm{rel}}$ must be reported as a decimal ratio, not a percentage.\n\nTest suite:\nProvide results for the following parameter sets, each expressed in the units specified:\n1. $E = 100\\times 10^{6}$, $\\nu = 0.25$, $h = 0.1$, $d = 0.01$, $\\gamma = 1\\times 10^{-3}$, tolerance $= 0.02$.\n2. $E = 100\\times 10^{6}$, $\\nu = 0.25$, $h = 0.1$, $d = 0.0333333333$, $\\gamma = 1\\times 10^{-3}$, tolerance $= 0.05$.\n3. $E = 100\\times 10^{6}$, $\\nu = 0.25$, $h = 0.05$, $d = 0.01$, $\\gamma = 1\\times 10^{-3}$, tolerance $= 0.03$.\n4. $E = 100\\times 10^{6}$, $\\nu = 0.25$, $h = 0.1$, $d = 0.05$, $\\gamma = 1\\times 10^{-3}$, tolerance $= 0.10$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4]\"), where each result is a boolean indicating whether the DEM homogenized stress matches the FEM stress within the specified tolerance for that test case.",
            "solution": "The problem statement is assessed to be valid. It is scientifically grounded in the principles of computational continuum and discrete mechanics, well-posed with a clear and deterministic objective, and formulated using precise, objective language. The task is to perform a numerical patch test for a coupled Finite Element Method (FEM) and Discrete Element Method (DEM) model, which is a standard verification procedure in the field.\n\nThe solution proceeds as follows: First, the theoretical framework for both the FEM and DEM stress calculations is established. Second, the coupling condition and the analytical expression for the relative error are derived. Third, the computational algorithm for constructing the DEM assembly and evaluating the error is detailed.\n\nThe objective is to compare the homogenized stress tensor from a DEM simulation, $\\boldsymbol{\\sigma}_{\\mathrm{DEM}}$, with the corresponding stress tensor from a continuum FEM formulation, $\\boldsymbol{\\sigma}_{\\mathrm{FEM}}$, for a system under a prescribed pure shear deformation.\n\nThe continuum stress is given for a linear elastic, isotropic material in a state of plane strain. The constitutive relation is $\\boldsymbol{\\sigma}_{\\mathrm{FEM}} = 2 \\mu\\, \\boldsymbol{\\varepsilon} + \\lambda \\, \\mathrm{tr}(\\boldsymbol{\\varepsilon}) \\boldsymbol{I}$, where $\\boldsymbol{\\varepsilon}$ is the strain tensor, $\\boldsymbol{I}$ is the identity tensor, and $\\mu$ and $\\lambda$ are the Lamé parameters. The parameters are defined in terms of Young's modulus $E$ and Poisson's ratio $\\nu$ as $\\mu = \\frac{E}{2(1+\\nu)}$ and $\\lambda = \\frac{\\nu E}{(1+\\nu)(1-2\\nu)}$. The problem specifies a pure shear strain field given by the tensor $\\boldsymbol{\\varepsilon} = \\begin{bmatrix} 0 & \\gamma/2 \\\\ \\gamma/2 & 0 \\end{bmatrix}$. Since the trace of this strain tensor, $\\mathrm{tr}(\\boldsymbol{\\varepsilon})$, is zero, the constitutive law simplifies to $\\boldsymbol{\\sigma}_{\\mathrm{FEM}} = 2 \\mu\\, \\boldsymbol{\\varepsilon}$.\n\nThe discrete particle assembly is represented by a set of grain centers arranged in a hexagonal lattice within a square domain of side length $h$. The domain has a volume $V = h^2$, assuming a unit thickness of $1$ meter. Neighboring grains, separated by a distance equal to their diameter $d$, are connected by linear elastic bonds. For a prescribed uniform displacement field $\\boldsymbol{u}(x) = \\boldsymbol{\\varepsilon}\\, x$, the force in a bond connecting particles at positions $x_i$ and $x_j$ is $\\boldsymbol{f}_c = k_b (\\boldsymbol{u}(x_j) - \\boldsymbol{u}(x_i))$. With the branch vector $\\boldsymbol{l}_c = x_j - x_i$, this simplifies to $\\boldsymbol{f}_c = k_b \\boldsymbol{\\varepsilon} \\boldsymbol{l}_c$. The homogenized stress for the DEM assembly is calculated using the Love-Weber formula:\n$$\n\\boldsymbol{\\sigma}_{\\mathrm{DEM}} = \\frac{1}{V} \\sum_{c} \\boldsymbol{f}_c \\otimes \\boldsymbol{l}_c\n$$\nwhere the sum is over all bonds $c$ in the assembly. Substituting the expression for $\\boldsymbol{f}_c$ and using the tensor identity $(\\boldsymbol{A}\\boldsymbol{b}) \\otimes \\boldsymbol{c} = \\boldsymbol{A}(\\boldsymbol{b} \\otimes \\boldsymbol{c})$, we obtain:\n$$\n\\boldsymbol{\\sigma}_{\\mathrm{DEM}} = \\frac{1}{V} \\sum_{c} (k_b \\boldsymbol{\\varepsilon} \\boldsymbol{l}_c) \\otimes \\boldsymbol{l}_c = \\frac{k_b}{V} \\boldsymbol{\\varepsilon} \\left( \\sum_{c} \\boldsymbol{l}_c \\otimes \\boldsymbol{l}_c \\right)\n$$\nThis is expressed as $\\boldsymbol{\\sigma}_{\\mathrm{DEM}} = \\frac{k_b}{V} \\boldsymbol{\\varepsilon} \\boldsymbol{S}$, where $\\boldsymbol{S} = \\sum_{c} \\boldsymbol{l}_c \\otimes \\boldsymbol{l}_c$ is the geometric or fabric tensor of the DEM assembly.\n\nTo ensure consistency between the two models, the bond stiffness $k_b$ is calibrated to match the macroscopic shear response. The provided calibration rule, $k_b = \\frac{4 \\mu V}{\\mathrm{tr}(\\boldsymbol{S})}$, is based on matching the trace of the stiffness tensors in an isotropic limit. For an isotropic material, the fabric tensor would be proportional to the identity matrix, $\\boldsymbol{S} = c\\boldsymbol{I}$, which implies $S_{11}=S_{22}$ and $S_{12}=0$. The calibration aims to match the shear modulus $\\mu$.\n\nThe discrepancy between the two stress tensors arises because the finite DEM assembly, truncated by the square boundaries, is not perfectly isotropic. The fabric tensor $\\boldsymbol{S}$ will generally have $S_{11} \\neq S_{22}$ and $S_{12} \\neq 0$. The measure of this discrepancy is the relative error in the Frobenius norm:\n$$\ne_{\\mathrm{rel}} = \\frac{\\|\\boldsymbol{\\sigma}_{\\mathrm{DEM}} - \\boldsymbol{\\sigma}_{\\mathrm{FEM}}\\|_F}{\\|\\boldsymbol{\\sigma}_{\\mathrm{FEM}}\\|_F}\n$$\nWe can derive a simplified expression for this error. Substituting the expressions for the stresses and the calibration for $k_b$:\n$$\n\\frac{k_b}{V} = \\frac{4 \\mu}{\\mathrm{tr}(\\boldsymbol{S})} = \\frac{4 \\mu}{S_{11}+S_{22}}\n$$\n$$\n\\boldsymbol{\\sigma}_{\\mathrm{DEM}} = \\frac{4 \\mu}{S_{11}+S_{22}} \\boldsymbol{\\varepsilon} \\boldsymbol{S} = \\frac{4 \\mu}{S_{11}+S_{22}} \\begin{bmatrix} 0 & \\gamma/2 \\\\ \\gamma/2 & 0 \\end{bmatrix} \\begin{bmatrix} S_{11} & S_{12} \\\\ S_{12} & S_{22} \\end{bmatrix} = \\frac{2 \\mu \\gamma}{S_{11}+S_{22}} \\begin{bmatrix} S_{12} & S_{22} \\\\ S_{11} & S_{12} \\end{bmatrix}\n$$\n$$\n\\boldsymbol{\\sigma}_{\\mathrm{FEM}} = 2 \\mu \\boldsymbol{\\varepsilon} = \\mu \\gamma \\begin{bmatrix} 0 & 1 \\\\ 1 & 0 \\end{bmatrix}\n$$\nThe error tensor $\\Delta\\boldsymbol{\\sigma} = \\boldsymbol{\\sigma}_{\\mathrm{DEM}} - \\boldsymbol{\\sigma}_{\\mathrm{FEM}}$ is:\n$$\n\\Delta\\boldsymbol{\\sigma} = \\mu \\gamma \\left( \\frac{2}{S_{11}+S_{22}} \\begin{bmatrix} S_{12} & S_{22} \\\\ S_{11} & S_{12} \\end{bmatrix} - \\begin{bmatrix} 0 & 1 \\\\ 1 & 0 \\end{bmatrix} \\right) = \\frac{\\mu \\gamma}{S_{11}+S_{22}} \\begin{bmatrix} 2S_{12} & S_{22}-S_{11} \\\\ S_{11}-S_{22} & 2S_{12} \\end{bmatrix}\n$$\nThe Frobenius norm of the FEM stress is $\\|\\boldsymbol{\\sigma}_{\\mathrm{FEM}}\\|_F = \\sqrt{(\\mu\\gamma)^2 + (\\mu\\gamma)^2} = \\mu\\gamma\\sqrt{2}$. The Frobenius norm of the error tensor is $\\|\\Delta\\boldsymbol{\\sigma}\\|_F = \\frac{\\mu\\gamma}{S_{11}+S_{22}} \\sqrt{(2S_{12})^2 + (S_{22}-S_{11})^2 + (S_{11}-S_{22})^2 + (2S_{12})^2} = \\frac{\\mu\\gamma\\sqrt{2}}{S_{11}+S_{22}}\\sqrt{(S_{11}-S_{22})^2 + (2S_{12})^2}$.\nThe relative error simplifies to:\n$$\ne_{\\mathrm{rel}} = \\frac{\\sqrt{(S_{11}-S_{22})^2 + (2S_{12})^2}}{S_{11}+S_{22}}\n$$\nThis pivotal result shows that the relative error depends only on the components of the geometric tensor $\\boldsymbol{S}$. It is a measure of the anisotropy of the DEM particle fabric, independent of the material properties ($E, \\nu$) and the applied strain magnitude ($\\gamma$). The error is expected to decrease as the ratio $h/d$ increases, as boundary effects become less pronounced relative to the bulk, and the assembly's fabric becomes more isotropic.\n\nThe computational algorithm proceeds as follows:\n1.  For a given side length $h$ and particle diameter $d$, generate the positions of particles in a hexagonal lattice that lie within the square domain defined by $[0, h] \\times [0, h]$. The lattice is constructed using basis vectors $\\boldsymbol{a}_1 = (d, 0)$ and $\\boldsymbol{a}_2 = (d/2, d\\sqrt{3}/2)$, with particle centers at integer combinations $i\\boldsymbol{a}_1+j\\boldsymbol{a}_2$.\n2.  Identify all unique bonds. A bond connects any two particles whose centers are separated by a distance approximately equal to $d$.\n3.  For each bond, form the branch vector $\\boldsymbol{l}_c$.\n4.  Initialize a $2 \\times 2$ matrix $\\boldsymbol{S}$ to zeros. Sum the outer products $\\boldsymbol{l}_c \\otimes \\boldsymbol{l}_c$ for all identified bonds to compute $\\boldsymbol{S}$.\n5.  Calculate the relative error $e_{\\mathrm{rel}}$ using the derived formula, which depends only on the components of $\\boldsymbol{S}$.\n6.  Compare the computed error $e_{\\mathrm{rel}}$ to the given tolerance. If $e_{\\mathrm{rel}}$ is less than or equal to the tolerance, the test passes for that parameter set.\nThe results for the provided test suite are generated by implementing this algorithm.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the patch test for all specified test cases.\n    \"\"\"\n\n    test_cases = [\n        {'E': 100e6, 'nu': 0.25, 'h': 0.1, 'd': 0.01, 'gamma': 1e-3, 'tolerance': 0.02},\n        {'E': 100e6, 'nu': 0.25, 'h': 0.1, 'd': 1.0/30.0, 'gamma': 1e-3, 'tolerance': 0.05},\n        {'E': 100e6, 'nu': 0.25, 'h': 0.05, 'd': 0.01, 'gamma': 1e-3, 'tolerance': 0.03},\n        {'E': 100e6, 'nu': 0.25, 'h': 0.1, 'd': 0.05, 'gamma': 1e-3, 'tolerance': 0.10},\n    ]\n\n    results = []\n    for case in test_cases:\n        passes = run_patch_test(**case)\n        results.append(passes)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_patch_test(E, nu, h, d, gamma, tolerance):\n    \"\"\"\n    Performs the coupled FEM/DEM patch test for a single set of parameters.\n\n    The function calculates the relative error between the homogenized DEM stress\n    and the analytical FEM stress. As derived in the solution, this error\n    depends only on the geometric tensor S, which is determined by h and d.\n    \"\"\"\n\n    # Step 1: Generate hexagonal lattice points\n    particles = generate_hexagonal_lattice(h, d)\n    \n    # Step 2: Build bonds and compute the geometric tensor S\n    S = compute_geometric_tensor(particles, d)\n\n    # Step 3: Compute the relative error\n    # The error depends only on the anisotropy of the S tensor.\n    # e_rel = ||dev(S_normalized)||_F, where S_normalized = S / tr(S)\n    # The derived formula is used for direct computation.\n    S_11, S_12 = S[0, 0], S[0, 1]\n    S_22 = S[1, 1]\n    \n    trace_S = S_11 + S_22\n\n    if trace_S == 0:\n        # This occurs if no bonds are formed (e.g., h < d). In this case,\n        # DEM stress is zero, FEM stress is non-zero, error is 1.\n        e_rel = 1.0\n    else:\n        numerator = np.sqrt((S_11 - S_22)**2 + (2 * S_12)**2)\n        e_rel = numerator / trace_S\n\n    # Step 4: Check if the error is within tolerance\n    return e_rel <= tolerance\n\ndef generate_hexagonal_lattice(h, d):\n    \"\"\"\n    Generates particle coordinates for a hexagonal lattice within a square domain [0, h] x [0, h].\n    \"\"\"\n    particles = []\n    \n    # Basis vectors for the hexagonal lattice\n    a1 = np.array([d, 0.0])\n    a2 = np.array([d / 2.0, d * np.sqrt(3.0) / 2.0])\n\n    # Efficiently determine the range of integer indices j and i\n    j_max = int(np.floor(h / a2[1]))\n    for j in range(j_max + 1):\n        # Determine range for i based on j\n        i_min = int(np.ceil(-j * a2[0] / a1[0]))\n        i_max = int(np.floor((h - j * a2[0]) / a1[0]))\n        \n        for i in range(i_min, i_max + 1):\n            pos = i * a1 + j * a2\n            # Although the loop bounds should guarantee this, a final check is robust.\n            if 0 <= pos[0] <= h and 0 <= pos[1] <= h:\n                particles.append(pos)\n                \n    return np.array(particles)\n\ndef compute_geometric_tensor(particles, d):\n    \"\"\"\n    Computes the geometric tensor S by summing the outer product of branch vectors.\n    \"\"\"\n    num_particles = len(particles)\n    S = np.zeros((2, 2))\n    \n    # Iterate over unique pairs of particles\n    for i in range(num_particles):\n        for j in range(i + 1, num_particles):\n            p_i = particles[i]\n            p_j = particles[j]\n            \n            # Check if particles are neighbors (distance is d)\n            # np.isclose is used for robust floating point comparison\n            if np.isclose(np.linalg.norm(p_j - p_i), d):\n                l_c = p_j - p_i\n                S += np.outer(l_c, l_c)\n                \n    return S\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}