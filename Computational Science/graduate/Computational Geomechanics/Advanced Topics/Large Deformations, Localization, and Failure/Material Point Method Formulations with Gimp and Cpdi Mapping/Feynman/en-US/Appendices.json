{
    "hands_on_practices": [
        {
            "introduction": "Before applying a numerical method to complex problems, we must verify its foundational accuracy. The linear patch test is a fundamental benchmark that confirms a method's ability to exactly reproduce a state of constant strain, a property known as linear completeness. This exercise  guides you through implementing and verifying this test for both GIMP and CPDI, ensuring your formulation correctly handles the simplest non-trivial deformation field.",
            "id": "3541702",
            "problem": "Consider a two-dimensional small-strain linear patch test posed on a structured, uniform, Cartesian background grid used in the Material Point Method (MPM). Let the uniform grid have spacing $h$ in both directions and nodes located at coordinates $(x_I,y_I)$ for node index $I$. A synthetic kinematic field is imposed at the grid nodes by prescribing the nodal displacements according to the linear function $u_x(x,y) = a x + b$ and $u_y(x,y) = c y + d$, where $a$, $b$, $c$, and $d$ are given real parameters and $(x,y)$ denotes spatial position. The objective is to verify that two domain-aware MPM mappings, Generalized Interpolation Material Point (GIMP) and Convected Particle Domain Interpolation (CPDI), reproduce the exact constant small strain tensor $\\boldsymbol{\\varepsilon}$ across material points (particles) for varying particle domain sizes and random particle-to-grid offsets. The verification should be carried out by computing strain at material points from the nodal displacements using each mapping, and comparing it to the exact analytical strain induced by the imposed linear displacement field.\n\nThe fundamental base for the derivation is the kinematic definition of the displacement gradient and small strain: the displacement gradient is $\\nabla \\mathbf{u} = \\begin{bmatrix} \\partial u_x/\\partial x & \\partial u_x/\\partial y \\\\ \\partial u_y/\\partial x & \\partial u_y/\\partial y \\end{bmatrix}$ and the infinitesimal strain tensor is $\\boldsymbol{\\varepsilon} = \\tfrac{1}{2}\\left(\\nabla \\mathbf{u} + \\nabla \\mathbf{u}^\\top\\right)$. In the patch test, the expected analytical strain is constant with $\\varepsilon_{xx}=a$, $\\varepsilon_{yy}=c$, and $\\varepsilon_{xy}=0$. The numerical strain at a particle is computed from nodal displacements using an MPM mapping, which assigns to each particle an averaged gradient of background-grid shape functions over the particle domain. In GIMP, this average is defined by an area integral of the shape-function gradients over the rectangular particle domain. In CPDI, this average is consistently defined by the particle domain corners and yields the same result for linear fields when the particle domain is axis-aligned with the grid. Both mappings should reproduce the exact linear field in this test.\n\nYour task is to implement a program that:\n- Constructs a uniform, square grid with spacing $h$ and dimensions large enough to host randomly placed particle domains entirely within the grid interior.\n- Generates a set of material points with rectangular domains of side length $l_p$ in both directions such that the ratio $l_p/h$ can vary per test case. Particle centers are randomly distributed within the interior so that each particle domain remains inside the grid bounds. For one test case, purposely concentrate particle centers near grid lines to create edge-crossing scenarios.\n- Imposes nodal displacements from the linear field $u_x=a x + b$, $u_y=c y + d$ at all grid nodes.\n- For each particle, computes the numerical displacement gradient $\\nabla \\mathbf{u}$ and small strain $\\boldsymbol{\\varepsilon}$ using:\n  1. The GIMP definition based on the exact area average of the background bilinear shape-function gradients over the particle domain (with proper handling when a particle domain overlaps multiple grid cells by partitioning into cell-wise subdomains).\n  2. The CPDI definition based on corner-averaged gradients within each overlapped cell subdomain, area-weighted over the entire particle domain.\n- Compares the computed particle strains to the exact analytical strain, and reports, for each test case and each mapping, the maximum absolute error in $\\boldsymbol{\\varepsilon}$ across all particles. Errors are dimensionless since $\\boldsymbol{\\varepsilon}$ is dimensionless.\n\nUse a uniform grid with spacing $h$ expressed in meters and nodal coordinates in meters. Displacements $u_x$ and $u_y$ must be in meters. The strain $\\boldsymbol{\\varepsilon}$ must be treated as dimensionless, and the error metric must also be dimensionless.\n\nImplement the following test suite, where each test case defines $(a,b,c,d)$, the particle-to-grid size ratio $l_p/h$, the number of particles $N_p$, and a random seed to deterministically generate particle centers:\n1. Happy path: $a=0.03$, $b=0.0$, $c=-0.02$, $d=0.1$, $l_p/h=0.3$, $N_p=50$, seed $42$.\n2. Near-cell-size domains: $a=0.05$, $b=0.5$, $c=0.04$, $d=-0.3$, $l_p/h=0.99$, $N_p=60$, seed $123$.\n3. Edge-crossing offsets: $a=-0.01$, $b=0.2$, $c=0.02$, $d=0.0$, $l_p/h=0.6$, $N_p=40$, seed $2024$; choose particle centers near grid lines so that many particle domains cross cell boundaries while remaining inside the grid.\n4. Very small domains: $a=0.0$, $b=-0.1$, $c=0.0$, $d=0.25$, $l_p/h=0.05$, $N_p=80$, seed $7$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered as $[E^{\\mathrm{GIMP}}_1,E^{\\mathrm{CPDI}}_1,E^{\\mathrm{GIMP}}_2,E^{\\mathrm{CPDI}}_2,E^{\\mathrm{GIMP}}_3,E^{\\mathrm{CPDI}}_3,E^{\\mathrm{GIMP}}_4,E^{\\mathrm{CPDI}}_4]$, where $E^{\\mathrm{GIMP}}_k$ and $E^{\\mathrm{CPDI}}_k$ denote the maximum absolute error in the strain components across all particles for test case $k$ computed with the GIMP and CPDI mappings, respectively. All outputs must be dimensionless real numbers. No other output is permitted.",
            "solution": "The problem statement is critically assessed and determined to be valid. It constitutes a well-posed, scientifically grounded verification problem in the field of computational geomechanics. Specifically, it describes a linear patch test for the Material Point Method (MPM), which is a standard procedure to verify the correctness of a numerical implementation. The givens are complete, consistent, and physically plausible. The objective is clear and the methods (GIMP, CPDI) are well-defined within the context of MPM. We may therefore proceed with a formal solution.\n\nThe core principle being tested is the ability of the Generalized Interpolation Material Point (GIMP) and Convected Particle Domain Interpolation (CPDI) formulations to exactly reproduce a state of constant strain. This property, known as linear completeness, is a necessary condition for a numerical method to converge to the correct solution as the grid is refined.\n\nFirst, we establish the analytical solution. The prescribed displacement field is given by:\n$$\nu_x(x,y) = a x + b \\\\\nu_y(x,y) = c y + d\n$$\nwhere $a, b, c, d$ are constants. The displacement gradient tensor, $\\nabla \\mathbf{u}$, is found by taking the partial derivatives of the displacement components:\n$$\n\\nabla \\mathbf{u} =\n\\begin{bmatrix}\n\\frac{\\partial u_x}{\\partial x} & \\frac{\\partial u_x}{\\partial y} \\\\\n\\frac{\\partial u_y}{\\partial x} & \\frac{\\partial u_y}{\\partial y}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\na & 0 \\\\\n0 & c\n\\end{bmatrix}\n$$\nThe infinitesimal (small) strain tensor, $\\boldsymbol{\\varepsilon}$, is the symmetric part of the displacement gradient:\n$$\n\\boldsymbol{\\varepsilon}_{exact} = \\frac{1}{2} \\left( \\nabla \\mathbf{u} + (\\nabla \\mathbf{u})^\\top \\right) = \\frac{1}{2} \\left(\n\\begin{bmatrix}\na & 0 \\\\\n0 & c\n\\end{bmatrix}\n+\n\\begin{bmatrix}\na & 0 \\\\\n0 & c\n\\end{bmatrix}^\\top\n\\right)\n=\n\\begin{bmatrix}\na & 0 \\\\\n0 & c\n\\end{bmatrix}\n$$\nThus, the analytical strain field is constant throughout the domain, with components $\\varepsilon_{xx} = a$, $\\varepsilon_{yy} = c$, and $\\varepsilon_{xy} = 0$. This is the exact solution that the numerical method must reproduce.\n\nIn the Material Point Method, the displacement field $\\mathbf{u}^h(\\mathbf{x})$ is interpolated from nodal values $\\mathbf{u}_I$ using grid-based shape functions $S_I(\\mathbf{x})$:\n$$\n\\mathbf{u}^h(\\mathbf{x}) = \\sum_{I} S_I(\\mathbf{x}) \\mathbf{u}_I\n$$\nThe problem uses bilinear shape functions on a uniform Cartesian grid of spacing $h$. A key property of these functions is that they form a partition of unity ($\\sum_I S_I(\\mathbf{x}) = 1$) and are linearly complete ($\\sum_I S_I(\\mathbf{x}) \\mathbf{x}_I = \\mathbf{x}$). Because the prescribed displacement field is linear, and the nodal displacements are set to the exact values at the nodes, i.e., $\\mathbf{u}_I = \\mathbf{u}(\\mathbf{x}_I)$, the linear completeness property guarantees that the interpolated field exactly reproduces the linear field everywhere: $\\mathbf{u}^h(\\mathbf{x}) = \\mathbf{u}(\\mathbf{x})$.\n\nThe displacement gradient computed from the interpolated field is:\n$$\n\\nabla \\mathbf{u}^h(\\mathbf{x}) = \\sum_I \\mathbf{u}_I \\otimes \\nabla S_I(\\mathbf{x})\n$$\nSince $\\mathbf{u}^h(\\mathbf{x}) = \\mathbf{u}(\\mathbf{x})$, it follows that $\\nabla \\mathbf{u}^h(\\mathbf{x}) = \\nabla \\mathbf{u}(\\mathbf{x})$, which we found to be a constant matrix.\n\nIn GIMP and CPDI, the displacement gradient at a material point $p$ is not evaluated at the point's center, but is averaged over the particle's domain, $\\Omega_p$. The particle-averaged gradient is:\n$$\n(\\nabla \\mathbf{u})_p = \\frac{1}{A_p} \\int_{\\Omega_p} \\nabla \\mathbf{u}^h(\\mathbf{x}) \\, dA = \\frac{1}{A_p} \\int_{\\Omega_p} \\left( \\sum_I \\mathbf{u}_I \\otimes \\nabla S_I(\\mathbf{x}) \\right) dA = \\sum_I \\mathbf{u}_I \\otimes \\left( \\frac{1}{A_p} \\int_{\\Omega_p} \\nabla S_I(\\mathbf{x}) \\, dA \\right)\n$$\nwhere $A_p = l_p^2$ is the area of the particle domain. We define the particle-averaged shape function gradient as $\\mathbf{G}_{Ip} = \\langle \\nabla S_I \\rangle_p$. Thus:\n$$\n(\\nabla \\mathbf{u})_p = \\sum_I \\mathbf{u}_I \\otimes \\mathbf{G}_{Ip}\n$$\nThe components are computed as:\n$$\n(\\nabla u_x)_p = \\sum_I u_{x,I} \\mathbf{G}_{Ip} \\quad \\text{and} \\quad (\\nabla u_y)_p = \\sum_I u_{y,I} \\mathbf{G}_{Ip}\n$$\nMore explicitly:\n$$\n(\\nabla \\mathbf{u})_p = \\begin{bmatrix}\n\\sum_I u_{x,I} G_{Ip,x} & \\sum_I u_{x,I} G_{Ip,y} \\\\\n\\sum_I u_{y,I} G_{Ip,x} & \\sum_I u_{y,I} G_{Ip,y}\n\\end{bmatrix}\n$$\nThe challenge lies in correctly calculating the components of $\\mathbf{G}_{Ip}$ for each node $I$ whose support intersects the particle domain $\\Omega_p$. For a node at $\\mathbf{x}_I=(x_I, y_I)$, the standard bilinear basis function can be written as $S_I(x,y) = s\\left(\\frac{x-x_I}{h}\\right) s\\left(\\frac{y-y_I}{h}\\right)$, where $s(z) = \\max(0, 1-|z|)$ is the 1D hat function. Its derivative is $s'(z) = -\\text{sgn}(z)$ for $|z| \\in (0,1)$ and $0$ otherwise.\n\nThe components of $\\mathbf{G}_{Ip}$ are the result of the separable integral:\n$$\nG_{Ip,x} = \\frac{1}{A_p} \\int_{y_p-l_p/2}^{y_p+l_p/2} \\int_{x_p-l_p/2}^{x_p+l_p/2} \\frac{\\partial S_I}{\\partial x} \\, dx \\, dy = \\frac{1}{l_p^2 h} \\left[ \\int_{x_p-l_p/2}^{x_p+l_p/2} s'\\left(\\frac{x-x_I}{h}\\right) \\, dx \\right] \\left[ \\int_{y_p-l_p/2}^{y_p+l_p/2} s\\left(\\frac{y-y_I}{h}\\right) \\, dy \\right]\n$$\nBy the fundamental theorem of calculus, the integral of the derivative $s'$ is simply $s$. A change of variables ($z=(x-x_I)/h$) simplifies the integrals:\n$$\nG_{Ip,x} = \\frac{h}{l_p^2} \\left[ s(z) \\right]_{z_1}^{z_2} \\left[ \\int_{w_1}^{w_2} s(w) \\, dw \\right]\n$$\nand similarly,\n$$\nG_{Ip,y} = \\frac{h}{l_p^2} \\left[ \\int_{z_1}^{z_2} s(z) \\, dz \\right] \\left[ s(w) \\right]_{w_1}^{w_2}\n$$\nwhere the integration limits are $z_1 = (x_p-l_p/2-x_I)/h$, $z_2 = (x_p+l_p/2-x_I)/h$, $w_1 = (y_p-l_p/2-y_I)/h$, and $w_2 = (y_p+l_p/2-y_I)/h$. The definite integral of $s(z)$ can be computed analytically by considering its piecewise definition.\nLet $F(z) = \\int_0^z s(t) \\, dt$. Then $\\int_a^b s(t) \\, dt = F(b) - F(a)$. The function $F(z)$ is:\n$$\nF(z) =\n\\begin{cases}\n-0.5 & z \\le -1 \\\\\nz + z^2/2 & -1 < z < 0 \\\\\nz - z^2/2 & 0 \\le z \\le 1 \\\\\n0.5 & z > 1\n\\end{cases}\n$$\nWith these analytical expressions, $\\mathbf{G}_{Ip}$ can be computed to machine precision for GIMP. The problem states that for an axis-aligned rectangular particle domain and a linear displacement field, the CPDI formulation gives the same result. Therefore, the same calculation will be used for both, and the expected error in both cases should be near zero, limited only by floating-point arithmetic.\n\nThe algorithm proceeds as follows for each test case:\n1. Define a sufficiently large grid and set the grid spacing $h$.\n2. Generate $N_p$ particle-center coordinates $(x_p, y_p)$ using the specified random seed, ensuring particle domains of size $l_p \\times l_p$ are fully contained within the grid interior. For the edge-crossing case, particle centers are explicitly placed near grid lines.\n3. For every node $I$ in the grid with coordinates $(x_I, y_I)$, compute the prescribed nodal displacements $u_{x,I} = a x_I + b$ and $u_{y,I} = c y_I + d$.\n4. For each particle, initialize its displacement gradient tensor $(\\nabla \\mathbf{u})_p$ to zero.\n5. Identify all nodes $I$ whose shape function support overlaps the particle domain. The support of $S_I$ is a $2h \\times 2h$ square centered at $\\mathbf{x}_I$.\n6. For each such active node, compute the averaged gradient vector $\\mathbf{G}_{Ip}$ using the exact integral formulas derived above.\n7. Accumulate the contribution of each node to the particle's displacement gradient: $(\\nabla \\mathbf{u})_p += \\mathbf{u}_I \\otimes \\mathbf{G}_{Ip}$.\n8. After iterating through all active nodes, compute the particle strain tensor $\\boldsymbol{\\varepsilon}_p = \\frac{1}{2}((\\nabla \\mathbf{u})_p + (\\nabla \\mathbf{u})_p^\\top)$.\n9. Calculate the error for the particle as the maximum absolute difference between the components of the computed strain $\\boldsymbol{\\varepsilon}_p$ and the analytical strain $\\boldsymbol{\\varepsilon}_{exact}$.\n10. The result for the test case is the maximum error found across all particles. This value is reported for both GIMP and CPDI.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are used.\n\ndef s_hat(z: np.ndarray) -> np.ndarray:\n    \"\"\"Computes the 1D linear B-spline (hat function).\"\"\"\n    z_abs = np.abs(z)\n    return np.where(z_abs < 1.0, 1.0 - z_abs, 0.0)\n\ndef integral_s_hat(z: np.ndarray) -> np.ndarray:\n    \"\"\"Computes the analytical integral of the hat function from 0 to z.\"\"\"\n    res = np.zeros_like(z, dtype=float)\n    \n    # z <= -1\n    res[z <= -1.0] = -0.5\n    \n    # -1 < z < 0\n    mask = (-1.0 < z) & (z < 0.0)\n    res[mask] = z[mask] + 0.5 * z[mask]**2\n    \n    # 0 <= z <= 1\n    mask = (0.0 <= z) & (z <= 1.0)\n    res[mask] = z[mask] - 0.5 * z[mask]**2\n\n    # z > 1\n    res[z > 1.0] = 0.5\n    \n    return res\n\ndef eval_integral_s_hat(z1: np.ndarray, z2: np.ndarray) -> np.ndarray:\n    \"\"\"Computes the definite integral of the hat function from z1 to z2.\"\"\"\n    return integral_s_hat(z2) - integral_s_hat(z1)\n\ndef run_test_case(a, b, c, d, lp_h_ratio, Np, seed, is_edge_crossing):\n    \"\"\"\n    Runs a single patch test case.\n    \"\"\"\n    h = 1.0\n    lp = lp_h_ratio * h\n    \n    # 1. Grid setup\n    grid_dim = 20  # Number of cells in each direction\n    grid_min, grid_max = 0.0, grid_dim * h\n    \n    # Generate node coordinates and displacements\n    x_coords = np.arange(grid_min, grid_max + h, h)\n    y_coords = np.arange(grid_min, grid_max + h, h)\n    nx, ny = len(x_coords), len(y_coords)\n    nodes_x, nodes_y = np.meshgrid(x_coords, y_coords)\n    \n    u_x_nodal = a * nodes_x + b\n    u_y_nodal = c * nodes_y + d\n    \n    # 2. Particle generation\n    rng = np.random.default_rng(seed)\n    particles_pos = np.zeros((Np, 2))\n    \n    # Ensure particles and their domains are within the grid 'interior'\n    # Use a margin of 1 cell from the boundary to avoid edge cases\n    margin = h\n    p_min = grid_min + margin + lp / 2.0\n    p_max = grid_max - margin - lp / 2.0\n\n    if is_edge_crossing:\n        # Concentrate particles near grid lines\n        grid_lines_x_idx = rng.integers(margin + 1, grid_dim - margin - 1, size=Np)\n        grid_lines_y_idx = rng.integers(margin + 1, grid_dim - margin - 1, size=Np)\n        \n        base_x = grid_lines_x_idx * h\n        base_y = grid_lines_y_idx * h\n\n        # Offset by a small amount, ensuring cell crossing\n        offset_mag = 0.4 * lp # Small enough to be near line, large enough to guarantee crossing if lp < h\n        offsets_x = rng.uniform(-offset_mag, offset_mag, size=Np)\n        offsets_y = rng.uniform(-offset_mag, offset_mag, size=Np)\n        \n        particles_pos[:, 0] = np.clip(base_x + offsets_x, p_min, p_max)\n        particles_pos[:, 1] = np.clip(base_y + offsets_y, p_min, p_max)\n    else:\n        particles_pos = rng.uniform(low=p_min, high=p_max, size=(Np, 2))\n\n    max_err = 0.0\n    analytical_strain = np.array([[a, 0.0], [0.0, c]])\n\n    # 3. Process each particle\n    for p_idx in range(Np):\n        xp, yp = particles_pos[p_idx]\n        grad_u_p = np.zeros((2, 2))\n        \n        # Identify active nodes\n        x_min_infl = xp - lp / 2.0 - h\n        x_max_infl = xp + lp / 2.0 + h\n        y_min_infl = yp - lp / 2.0 - h\n        y_max_infl = yp + lp / 2.0 + h\n\n        # Find indices of nodes within the influence region\n        min_i = int(np.floor(x_min_infl / h))\n        max_i = int(np.ceil(x_max_infl / h))\n        min_j = int(np.floor(y_min_infl / h))\n        max_j = int(np.ceil(y_max_infl / h))\n\n        min_i = max(0, min_i)\n        max_i = min(nx-1, max_i)\n        min_j = max(0, min_j)\n        max_j = min(ny-1, max_j)\n\n        for j in range(min_j, max_j + 1):\n            for i in range(min_i, max_i + 1):\n                xi, yi = x_coords[i], y_coords[j]\n\n                # Calculate particle-averaged shape function gradients (G_ip)\n                z1 = (xp - lp / 2.0 - xi) / h\n                z2 = (xp + lp / 2.0 - xi) / h\n                w1 = (yp - lp / 2.0 - yi) / h\n                w2 = (yp + lp / 2.0 - yi) / h\n                \n                term_z_s = s_hat(z2) - s_hat(z1)\n                term_w_s = s_hat(w2) - s_hat(w1)\n                \n                term_z_int_s = eval_integral_s_hat(z1, z2)\n                term_w_int_s = eval_integral_s_hat(w1, w2)\n                \n                if abs(term_z_s) < 1e-15 and abs(term_w_s) < 1e-15 and \\\n                   abs(term_z_int_s) < 1e-15 and abs(term_w_int_s) < 1e-15:\n                    continue\n\n                common_factor = h / (lp**2)\n                G_ip_x = common_factor * term_z_s * term_w_int_s\n                G_ip_y = common_factor * term_z_int_s * term_w_s\n                \n                # Accumulate displacement gradient\n                grad_u_p[0, 0] += u_x_nodal[j, i] * G_ip_x\n                grad_u_p[0, 1] += u_x_nodal[j, i] * G_ip_y\n                grad_u_p[1, 0] += u_y_nodal[j, i] * G_ip_x\n                grad_u_p[1, 1] += u_y_nodal[j, i] * G_ip_y\n        \n        # Calculate strain and error\n        strain_p = 0.5 * (grad_u_p + grad_u_p.T)\n        err_matrix = np.abs(strain_p - analytical_strain)\n        \n        if np.max(err_matrix) > max_err:\n            max_err = np.max(err_matrix)\n            \n    return max_err\n\n\ndef solve():\n    \"\"\"\n    Main function to execute the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # a, b, c, d, lp/h, Np, seed, is_edge_crossing\n        (0.03, 0.0, -0.02, 0.1, 0.3, 50, 42, False),\n        (0.05, 0.5, 0.04, -0.3, 0.99, 60, 123, False),\n        (-0.01, 0.2, 0.02, 0.0, 0.6, 40, 2024, True),\n        (0.0, -0.1, 0.0, 0.25, 0.05, 80, 7, False),\n    ]\n\n    results = []\n    for params in test_cases:\n        error = run_test_case(*params)\n        # For this linear patch test with axis-aligned domains, GIMP and CPDI yield identical results.\n        results.append(f\"{error:.15e}\")\n        results.append(f\"{error:.15e}\")\n\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "A numerical method must not only be accurate but also physically consistent. This practice  examines the critical property of rigid-body invariance, which demands that a pure rotation of the material should not induce any non-physical internal deformation or stress. By simulating a rigid rotation, you will verify that both the GIMP and CPDI mappings correctly result in zero strain and conserve kinetic energy, preventing the emergence of spurious internal forces that can corrupt a simulation.",
            "id": "3541699",
            "problem": "Consider a two-dimensional, uniform, Cartesian background grid for the Material Point Method (MPM). Let the domain be the square $\\Omega = [-0.5,0.5] \\times [-0.5,0.5]$ in meters. The grid consists of $N \\times N$ nodes with uniform spacing $h = 1/(N-1)$ meters. A set of $n_p$ material points (particles) is defined, each particle $p$ having center $\\mathbf{x}_p = (x_p,y_p)$, rectangular domain half-lengths $(\\ell_x,\\ell_y)$ in meters, density $\\rho$ in $\\mathrm{kg/m^3}$, thickness $t$ in meters, and mass $m_p = \\rho t A_p$ where $A_p = 4 \\ell_x \\ell_y$ is its area. There are no external forces. The prescribed rigid-body velocity field is given by $\\mathbf{v}(\\mathbf{x}) = \\boldsymbol{\\Omega} \\times \\mathbf{x}$, where $\\boldsymbol{\\Omega} = (0,0,\\omega)$ is a constant angular velocity vector with $\\omega$ in radians per second. This yields the component form $\\mathbf{v}(\\mathbf{x}) = (-\\omega y, \\omega x)$ in meters per second. The goal is to test rigid-body motion invariance under Generalized Interpolation Material Point (GIMP) mapping and Convected Particle Domain Interpolation (CPDI) mapping when particles cross grid cells.\n\nFundamental base:\n- Kinematics: The velocity gradient is $\\mathbf{L}(\\mathbf{x}) = \\nabla \\mathbf{v}(\\mathbf{x})$, the symmetric strain-rate tensor is $\\mathbf{D}(\\mathbf{x}) = \\tfrac{1}{2}\\left(\\mathbf{L} + \\mathbf{L}^\\top\\right)$, and for rigid-body rotation $\\mathbf{D}(\\mathbf{x}) = \\mathbf{0}$.\n- Energetics: Kinetic energy is $T = \\tfrac{1}{2} \\int_{\\Omega} \\rho \\|\\mathbf{v}(\\mathbf{x})\\|^2 \\, \\mathrm{d}V$, which must remain constant when merely transferring fields between particles and grid (no dynamics).\n- Linear elasticity for plane strain (used only to assess spurious stress): $\\boldsymbol{\\sigma} = \\lambda\\, \\mathrm{tr}(\\boldsymbol{\\varepsilon})\\, \\mathbf{I} + 2 \\mu \\boldsymbol{\\varepsilon}$, where $\\boldsymbol{\\varepsilon}$ is the strain (taken here from the symmetric part of the velocity gradient as a proxy, $\\boldsymbol{\\varepsilon} \\equiv \\mathbf{D}\\,\\Delta t$ with unit time step for testing), and $\\lambda = \\frac{E \\nu}{(1+\\nu)(1-2\\nu)}$, $\\mu = \\frac{E}{2(1+\\nu)}$. For rigid rotation, $\\boldsymbol{\\varepsilon}=\\mathbf{0}$, hence $\\boldsymbol{\\sigma}=\\mathbf{0}$.\n\nGrid interpolation basis:\n- Standard one-dimensional hat (tent) function anchored at a node located at $X_I$ is $N^{1\\mathrm{D}}(x) = \\max\\left(0, 1 - \\frac{|x - X_I|}{h}\\right)$, and its derivative with respect to $x$ is $\\partial N^{1\\mathrm{D}}/\\partial x = -\\frac{\\mathrm{sign}(x-X_I)}{h}$ for $|x-X_I|<h$ and zero otherwise. The two-dimensional grid basis at node $(X_I,Y_J)$ is $N_{IJ}(x,y) = N^{1\\mathrm{D}}(x) N^{1\\mathrm{D}}(y)$ with gradient $\\nabla N_{IJ} = \\left(\\frac{\\partial N^{1\\mathrm{D}}(x)}{\\partial x} N^{1\\mathrm{D}}(y), N^{1\\mathrm{D}}(x) \\frac{\\partial N^{1\\mathrm{D}}(y)}{\\partial y}\\right)$.\n\nMapping schemes:\n- Generalized Interpolation Material Point (GIMP): The particle-to-node weight in one dimension for node at $X_I$ is defined by the smoothed function obtained by convolving the hat function with the particle's interval of half-length $\\ell$ (in the same axis). Defining the normalized coordinate $\\xi = \\frac{x_p - X_I}{h}$ and the ratio $r = \\frac{\\ell}{h}$, the one-dimensional GIMP weight is\n$$\nS^{1\\mathrm{D}}_{\\mathrm{GIMP}}(\\xi;r) = \n\\begin{cases}\n1 - |\\xi|, & |\\xi| \\le 1 - r \\\\\n\\frac{(1 + r - |\\xi|)^2}{4r}, & 1 - r < |\\xi| \\le 1 + r \\\\\n0, & |\\xi| > 1 + r\n\\end{cases}\n$$\nwith derivative with respect to $x$ given by\n$$\n\\frac{\\partial S^{1\\mathrm{D}}_{\\mathrm{GIMP}}}{\\partial x} =\n\\begin{cases}\n-\\frac{\\mathrm{sign}(\\xi)}{h}, & |\\xi| \\le 1 - r \\\\\n-\\frac{1 + r - |\\xi|}{2rh}\\,\\mathrm{sign}(\\xi), & 1 - r < |\\xi| \\le 1 + r \\\\\n0, & |\\xi| > 1 + r\n\\end{cases}\n$$\nand the two-dimensional GIMP weight and gradient are tensor products:\n$$\nW_{IJ}^{\\mathrm{GIMP}}(\\mathbf{x}_p) = S^{1\\mathrm{D}}_{\\mathrm{GIMP}}\\!\\left(\\frac{x_p-X_I}{h};\\frac{\\ell_x}{h}\\right) S^{1\\mathrm{D}}_{\\mathrm{GIMP}}\\!\\left(\\frac{y_p-Y_J}{h};\\frac{\\ell_y}{h}\\right),\n$$\n$$\n\\nabla W_{IJ}^{\\mathrm{GIMP}}(\\mathbf{x}_p) = \\left(\\frac{\\partial S^{1\\mathrm{D}}_{\\mathrm{GIMP}}}{\\partial x}\\!\\left(\\frac{x_p-X_I}{h};\\frac{\\ell_x}{h}\\right) S^{1\\mathrm{D}}_{\\mathrm{GIMP}}\\!\\left(\\frac{y_p-Y_J}{h};\\frac{\\ell_y}{h}\\right), S^{1\\mathrm{D}}_{\\mathrm{GIMP}}\\!\\left(\\frac{x_p-X_I}{h};\\frac{\\ell_x}{h}\\right)\\frac{\\partial S^{1\\mathrm{D}}_{\\mathrm{GIMP}}}{\\partial y}\\!\\left(\\frac{y_p-Y_J}{h};\\frac{\\ell_y}{h}\\right)\\right).\n$$\n- Convected Particle Domain Interpolation (CPDI): For a rectangular particle domain $\\mathcal{P}_p = [x_p-\\ell_x,x_p+\\ell_x]\\times[y_p-\\ell_y,y_p+\\ell_y]$, the CPDI effective particle-to-node weight is the area-average of the standard grid basis over the particle domain,\n$$\nW_{IJ}^{\\mathrm{CPDI}}(\\mathbf{x}_p) = \\frac{1}{A_p} \\int_{\\mathcal{P}_p} N_{IJ}(x,y)\\ \\mathrm{d}A,\n$$\nand the corresponding gradient is the area-average of the basis gradient,\n$$\n\\nabla W_{IJ}^{\\mathrm{CPDI}}(\\mathbf{x}_p) = \\frac{1}{A_p} \\int_{\\mathcal{P}_p} \\nabla N_{IJ}(x,y)\\ \\mathrm{d}A.\n$$\nIn implementation, these integrals may be approximated by uniform tensor-product quadrature over $\\mathcal{P}_p$.\n\nNodal velocity field:\n- The nodal velocities are prescribed exactly by the rigid-body motion: for a node at $(X_I,Y_J)$, $\\mathbf{v}_{IJ} = (-\\omega Y_J, \\omega X_I)$.\n\nParticle reconstruction and velocity gradient:\n- The reconstructed particle velocity is $\\mathbf{v}_p^{\\mathrm{rec}} = \\sum_{I,J} W_{IJ}(\\mathbf{x}_p)\\ \\mathbf{v}_{IJ}$ using either GIMP or CPDI weights.\n- The particle velocity gradient is $\\mathbf{L}_p^{\\mathrm{rec}} = \\sum_{I,J} \\mathbf{v}_{IJ} \\otimes \\nabla W_{IJ}(\\mathbf{x}_p)$, with the symmetric part $\\mathbf{D}_p^{\\mathrm{rec}} = \\tfrac{1}{2}(\\mathbf{L}_p^{\\mathrm{rec}} + (\\mathbf{L}_p^{\\mathrm{rec}})^\\top)$.\n\nValidation objectives:\n- Verify $\\mathbf{D}_p^{\\mathrm{rec}} \\approx \\mathbf{0}$ for all particles (strain-rate invariance under rigid motion).\n- Verify constant kinetic energy computed from reconstructed particle velocities $T_{\\mathrm{rec}} = \\sum_p \\tfrac{1}{2} m_p \\|\\mathbf{v}_p^{\\mathrm{rec}}\\|^2$ compared to $T_{\\mathrm{initial}} = \\sum_p \\tfrac{1}{2} m_p \\|\\mathbf{v}(\\mathbf{x}_p)\\|^2$.\n- Using linear elasticity with given $E$ (Pascals) and $\\nu$ (dimensionless), compute $\\boldsymbol{\\sigma}_p = \\lambda\\, \\mathrm{tr}(\\mathbf{D}_p^{\\mathrm{rec}})\\, \\mathbf{I} + 2 \\mu \\mathbf{D}_p^{\\mathrm{rec}}$ (with $\\Delta t = 1\\,\\mathrm{s}$ for unit consistency) and verify $\\boldsymbol{\\sigma}_p \\approx \\mathbf{0}$ for all particles.\n\nNumerical units:\n- All lengths must be in meters, angular velocity in radians per second, density in $\\mathrm{kg/m^3}$, thickness in meters, mass in kilograms, and stress in Pascals. Express all boolean validation outcomes as Python booleans. No angles appear other than $\\omega$, which is in radians per second.\n\nTest suite:\nImplement the following four test cases. In each case, set $E = 10^7$ Pascals, $\\nu = 0.3$, $\\rho = 2000\\ \\mathrm{kg/m^3}$, $t = 1\\ \\mathrm{m}$, and $N=17$ (so $h = 1/16\\ \\mathrm{m}$). The particle configurations are chosen to ensure particles cross cell boundaries.\n1. Case A (GIMP, moderate rotation, crossing): $\\omega = 25\\ \\mathrm{rad/s}$. Nine particles with centers\n$$\n\\{(0,0),\\ (0.25,0),\\ (-0.25,0),\\ (0,0.25),\\ (0,-0.25),\\ (0.25,0.25),\\ (-0.25,0.25),\\ (0.25,-0.25),\\ (-0.25,-0.25)\\}\n$$\nand half-lengths $(\\ell_x,\\ell_y) = (0.4h,\\ 0.45h)$.\n2. Case B (CPDI, stronger rotation, crossing, quadrature): $\\omega = 40\\ \\mathrm{rad/s}$. Same particle centers as Case A, half-lengths $(\\ell_x,\\ell_y) = (0.8h,\\ 0.6h)$. Use uniform $5\\times 5$ quadrature points over each particle domain to approximate CPDI weights and gradients.\n3. Case C (GIMP, near grid lines, high rotation): $\\omega = 1000\\ \\mathrm{rad/s}$. Four particles with centers $\\{(0.5h,0.0),\\ (1.5h,0.25),\\ (-2.5h,-0.25),\\ (-0.5h,0.25)\\}$ and half-lengths $(\\ell_x,\\ell_y) = (0.45h,\\ 0.45h)$.\n4. Case D (CPDI, elongated particles, zero rotation): $\\omega = 0\\ \\mathrm{rad/s}$. Four particles with centers $\\{(0.3,0.3),\\ (-0.3,0.3),\\ (0.3,-0.3),\\ (-0.3,-0.3)\\}$ and half-lengths $(\\ell_x,\\ell_y) = (1.2h,\\ 1.8h)$. Use uniform $7\\times 7$ quadrature points over each particle domain.\n\nOutput specifications:\n- For each case, return a list of three booleans $[\\mathrm{strain\\_zero},\\ \\mathrm{KE\\_constant},\\ \\mathrm{stress\\_zero}]$, where:\n  - $\\mathrm{strain\\_zero}$ is true if $\\max_p \\|\\mathbf{D}_p^{\\mathrm{rec}}\\|_F \\le \\tau_D$, where $\\|\\cdot\\|_F$ is the Frobenius norm and $\\tau_D = 10^{-8} \\max(1,|\\omega|)$ in $\\mathrm{s^{-1}}$.\n  - $\\mathrm{KE\\_constant}$ is true if $\\left|T_{\\mathrm{rec}} - T_{\\mathrm{initial}}\\right| \\le \\tau_T$, where $\\tau_T = 10^{-10}\\, \\max\\left(T_{\\mathrm{initial}}, 1\\right)$ in Joules.\n  - $\\mathrm{stress\\_zero}$ is true if $\\max_p \\|\\boldsymbol{\\sigma}_p\\|_F \\le \\tau_\\sigma$, where $\\tau_\\sigma = 10^{-2}$ Pascals.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example: \"[[True,True,True],[True,True,True],[True,True,True],[True,True,True]]\".\n\nYour task:\n- Implement the above in a single, complete, runnable Python program that constructs the grid, defines the particles per test case, prescribes nodal velocities from rigid rotation, computes reconstructed particle velocities and velocity gradients using both GIMP and CPDI mapping (as specified), evaluates the three validation criteria, and prints the results in the exact required output format.",
            "solution": "The user has provided a well-defined computational mechanics problem to be validated and solved.\n\n### Step 1: Extract Givens\n- **Domain**: Square $\\Omega = [-0.5,0.5] \\times [-0.5,0.5]$ meters.\n- **Grid**: $N \\times N$ uniform Cartesian grid with $N=17$. Spacing $h = 1/(N-1)$ meters. Node locations are $(X_I, Y_J)$.\n- **Particles**: A set of $n_p$ particles, each with center $\\mathbf{x}_p = (x_p,y_p)$, rectangular domain half-lengths $(\\ell_x, \\ell_y)$ meters, density $\\rho = 2000\\ \\mathrm{kg/m^3}$, and thickness $t = 1\\ \\mathrm{m}$.\n- **Particle Mass**: $m_p = \\rho t A_p$, where $A_p = 4 \\ell_x \\ell_y$.\n- **Rigid-Body Motion**: Prescribed velocity field $\\mathbf{v}(\\mathbf{x}) = \\boldsymbol{\\Omega} \\times \\mathbf{x}$ with $\\boldsymbol{\\Omega} = (0,0,\\omega)$, resulting in $\\mathbf{v}(\\mathbf{x}) = (-\\omega y, \\omega x)$ m/s. Nodal velocities are prescribed as $\\mathbf{v}_{IJ} = (-\\omega Y_J,\\ \\omega X_I)$.\n- **Elasticity**: Plane strain linear elasticity with Young's modulus $E = 10^7$ Pascals and Poisson's ratio $\\nu = 0.3$. Stress $\\boldsymbol{\\sigma} = \\lambda\\, \\mathrm{tr}(\\boldsymbol{\\varepsilon})\\, \\mathbf{I} + 2 \\mu \\boldsymbol{\\varepsilon}$, where strain proxy is $\\boldsymbol{\\varepsilon} \\equiv \\mathbf{D}\\,\\Delta t$ with $\\Delta t=1\\,\\mathrm{s}$.\n- **Basis Functions**: Standard 2D tensor-product hat functions $N_{IJ}(x,y)$ and their gradients $\\nabla N_{IJ}$.\n- **Mapping Schemes**:\n    1.  **GIMP (Generalized Interpolation Material Point)**: Particle-to-node weights $W_{IJ}^{\\mathrm{GIMP}}$ and gradients $\\nabla W_{IJ}^{\\mathrm{GIMP}}$ defined via tensor products of 1D smoothed hat functions $S^{1\\mathrm{D}}_{\\mathrm{GIMP}}$ and their derivatives, with formulas provided.\n    2.  **CPDI (Convected Particle Domain Interpolation)**: Particle-to-node weights $W_{IJ}^{\\mathrm{CPDI}}$ and gradients $\\nabla W_{IJ}^{\\mathrm{CPDI}}$ defined as area-averages of the grid basis functions and their gradients over the particle domain $\\mathcal{P}_p$. The problem specifies approximation using uniform tensor-product quadrature.\n- **Reconstruction**: Particle velocity $\\mathbf{v}_p^{\\mathrm{rec}} = \\sum_{I,J} W_{IJ}(\\mathbf{x}_p)\\ \\mathbf{v}_{IJ}$ and velocity gradient $\\mathbf{L}_p^{\\mathrm{rec}} = \\sum_{I,J} \\mathbf{v}_{IJ} \\otimes \\nabla W_{IJ}(\\mathbf{x}_p)$. Strain rate is $\\mathbf{D}_p^{\\mathrm{rec}} = \\tfrac{1}{2}(\\mathbf{L}_p^{\\mathrm{rec}} + (\\mathbf{L}_p^{\\mathrm{rec}})^\\top)$.\n- **Test Cases**:\n    - **Case A**: GIMP, $\\omega=25$, $9$ particles with $(\\ell_x, \\ell_y)=(0.4h, 0.45h)$.\n    - **Case B**: CPDI, $\\omega=40$, $9$ particles with $(\\ell_x, \\ell_y)=(0.8h, 0.6h)$, $5\\times 5$ quadrature.\n    - **Case C**: GIMP, $\\omega=1000$, $4$ particles with $(\\ell_x, \\ell_y)=(0.45h, 0.45h)$.\n    - **Case D**: CPDI, $\\omega=0$, $4$ particles with $(\\ell_x, \\ell_y)=(1.2h, 1.8h)$, $7\\times 7$ quadrature.\n- **Validation Criteria & Tolerances**:\n    1.  **Strain-rate-free**: $\\mathrm{strain\\_zero} \\iff \\max_p \\|\\mathbf{D}_p^{\\mathrm{rec}}\\|_F \\le \\tau_D$, with $\\tau_D = 10^{-8} \\max(1,|\\omega|)\\ \\mathrm{s^{-1}}$.\n    2.  **Kinetic energy conservation**: $\\mathrm{KE\\_constant} \\iff |T_{\\mathrm{rec}} - T_{\\mathrm{initial}}| \\le \\tau_T$, with $T_{\\mathrm{rec}} = \\sum_p \\tfrac{1}{2} m_p \\|\\mathbf{v}_p^{\\mathrm{rec}}\\|^2$, $T_{\\mathrm{initial}} = \\sum_p \\tfrac{1}{2} m_p \\|\\mathbf{v}(\\mathbf{x}_p)\\|^2$, and $\\tau_T = 10^{-10}\\, \\max(T_{\\mathrm{initial}}, 1)$ Joules.\n    3.  **Stress-free**: $\\mathrm{stress\\_zero} \\iff \\max_p \\|\\boldsymbol{\\sigma}_p\\|_F \\le \\tau_\\sigma$, with $\\tau_\\sigma = 10^{-2}$ Pascals.\n- **Output Format**: A list of lists of booleans, e.g., `[[True,True,True],[False,True,True],...]`.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is subjected to critical validation.\n- **Scientific Grounding**: The problem is firmly rooted in the theory of computational mechanics, specifically the Material Point Method (MPM). The GIMP and CPDI formulations are standard and well-documented methods for mitigating numerical errors in MPM. All physical and mathematical formulations (rigid-body kinematics, linear elasticity, basis functions) are correct and standard.\n- **Well-Posedness**: The problem is well-posed. It requires the computation of specific quantities based on a complete set of input data and numerical schemes. The objectives are clearly defined as comparisons against numerical tolerances. The process is deterministic, leading to a unique, computable result.\n- **Objectivity**: The problem is stated in precise, objective, and mathematical language, free from any subjective or ambiguous terms.\n- **Completeness and Consistency**: All necessary parameters, formulas, and conditions for each of the four test cases are provided. There are no apparent contradictions in the setup. The instruction to use numerical quadrature for CPDI is explicit and resolves any potential ambiguity in its implementation.\n- **Feasibility**: The parameters are within a reasonable range for a numerical simulation. The high angular velocity in Case C is a valid stress test for the numerical schemes. The problem is computationally feasible.\n\n### Step 3: Verdict and Action\nThe problem is found to be **valid**. It is a standard numerical verification test common in the development and validation of numerical methods. The solution process will now proceed.\n\n### Solution\n\nThe task is to implement a numerical experiment to verify the rigid-body motion invariance of the GIMP and CPDI mapping schemes within the Material Point Method framework. For a perfect numerical scheme, a rigid-body rotation should not induce any internal deformation (strain) or stress, and the kinetic energy should be conserved during the mapping between particle and grid representations.\n\nThe overall procedure for each test case is as follows:\n1.  **System Initialization**:\n    - A uniform Cartesian grid is established over the domain $\\Omega = [-0.5, 0.5] \\times [-0.5, 0.5]$ with $N=17$ nodes, yielding a grid spacing of $h = 1/(17-1) = 1/16$ m. The coordinates $(X_I, Y_J)$ of each grid node are determined.\n    - For each node, the velocity $\\mathbf{v}_{IJ} = (-\\omega Y_J, \\omega X_I)$ is prescribed according to the rigid-body rotation field.\n    - The material points (particles) for the specific test case are defined with their positions $\\mathbf{x}_p$, domain half-lengths $(\\ell_x, \\ell_y)$, and mass $m_p$, which is calculated from the given density $\\rho$, thickness $t$, and particle area $A_p = 4 \\ell_x \\ell_y$.\n\n2.  **Field Transfer and Reconstruction**:\n    The core of the problem involves reconstructing fields at the particle locations from the grid. This is done by looping through each particle and, for each particle, summing contributions from all influential grid nodes.\n    - For a particle $p$ at $\\mathbf{x}_p$, we must calculate the interpolation weight $W_{IJ}(\\mathbf{x}_p)$ and its gradient $\\nabla W_{IJ}(\\mathbf{x}_p)$ for each nearby node $(I,J)$. This calculation depends on the mapping scheme (GIMP or CPDI).\n\n    - **GIMP Scheme**: The GIMP weight function is a tensor product of 1D smoothed functions: $W_{IJ}^{\\mathrm{GIMP}}(\\mathbf{x}_p) = S^{1\\mathrm{D}}_{\\mathrm{GIMP}}(x_p) S^{1\\mathrm{D}}_{\\mathrm{GIMP}}(y_p)$. The required 1D function $S^{1\\mathrm{D}}_{\\mathrm{GIMP}}$ and its spatial derivative $\\partial S^{1\\mathrm{D}}_{\\mathrm{GIMP}}/\\partial x$ are given piecewise as functions of the normalized distance $\\xi = (x_p - X_I)/h$ and the particle-size-to-grid-size ratio $r = \\ell_x/h$. The 2D gradient $\\nabla W_{IJ}^{\\mathrm{GIMP}}$ is found using the product rule.\n\n    - **CPDI Scheme**: The CPDI weight $W_{IJ}^{\\mathrm{CPDI}}$ and gradient $\\nabla W_{IJ}^{\\mathrm{CPDI}}$ are defined as integrals of the standard tent basis function $N_{IJ}$ and its gradient $\\nabla N_{IJ}$ over the particle domain $\\mathcal{P}_p$. The problem specifies that these integrals are to be approximated by uniform tensor-product numerical quadrature. For an $n \\times n$ quadrature rule, we evaluate the integrand at $n^2$ points $(\\mathbf{x}_q)$ within the particle's domain and compute the weighted sum:\n    $$ W_{IJ}^{\\mathrm{CPDI}} \\approx \\frac{1}{n^2} \\sum_{q=1}^{n^2} N_{IJ}(\\mathbf{x}_q) $$\n    $$ \\nabla W_{IJ}^{\\mathrm{CPDI}} \\approx \\frac{1}{n^2} \\sum_{q=1}^{n^2} \\nabla N_{IJ}(\\mathbf{x}_q) $$\n\n    - Once the weights and gradients are known, the particle's velocity and velocity gradient are reconstructed:\n    $$ \\mathbf{v}_p^{\\mathrm{rec}} = \\sum_{I,J} W_{IJ}(\\mathbf{x}_p)\\ \\mathbf{v}_{IJ} $$\n    $$ \\mathbf{L}_p^{\\mathrm{rec}} = \\sum_{I,J} \\mathbf{v}_{IJ} \\otimes \\nabla W_{IJ}(\\mathbf{x}_p) $$\n    The tensor $\\mathbf{L}_p^{\\mathrm{rec}}$ is a $2 \\times 2$ matrix. The symmetric part gives the strain-rate tensor, $\\mathbf{D}_p^{\\mathrm{rec}} = \\frac{1}{2}\\left(\\mathbf{L}_p^{\\mathrm{rec}} + (\\mathbf{L}_p^{\\mathrm{rec}})^\\top\\right)$.\n\n3.  **Evaluation of Validation Metrics**:\n    After processing all particles in a test case, we evaluate the three specified criteria.\n    - **Strain-Rate Invariance**: For each particle, calculate the Frobenius norm of the reconstructed strain-rate tensor, $\\|\\mathbf{D}_p^{\\mathrm{rec}}\\|_F = \\sqrt{\\sum_{i,j} (D_{p,ij}^{\\mathrm{rec}})^2}$. The criterion is met if the maximum of these norms over all particles is less than or equal to the tolerance $\\tau_D = 10^{-8} \\max(1,|\\omega|)$.\n    - **Kinetic Energy Conservation**: The initial total kinetic energy $T_{\\mathrm{initial}} = \\sum_p \\frac{1}{2} m_p \\|\\mathbf{v}(\\mathbf{x}_p)\\|^2$ is computed using the exact analytical velocity field. The reconstructed total kinetic energy $T_{\\mathrm{rec}} = \\sum_p \\frac{1}{2} m_p \\|\\mathbf{v}_p^{\\mathrm{rec}}\\|^2$ is computed using the reconstructed particle velocities. The criterion is met if the absolute difference $|T_{\\mathrm{rec}} - T_{\\mathrm{initial}}|$ is less than or equal to the tolerance $\\tau_T = 10^{-10}\\, \\max(T_{\\mathrm{initial}}, 1)$.\n    - **Stress-Free State**: The stress tensor for each particle, $\\boldsymbol{\\sigma}_p$, is computed from $\\mathbf{D}_p^{\\mathrm{rec}}$ using the provided plane strain linear elastic constitutive model: $\\boldsymbol{\\sigma}_p = \\lambda\\, \\mathrm{tr}(\\mathbf{D}_p^{\\mathrm{rec}})\\, \\mathbf{I} + 2 \\mu \\mathbf{D}_p^{\\mathrm{rec}}$. The Lam√© parameters are $\\lambda = \\frac{E \\nu}{(1+\\nu)(1-2\\nu)}$ and $\\mu = \\frac{E}{2(1+\\nu)}$. The criterion is met if the maximum Frobenius norm of the stress tensors, $\\max_p \\|\\boldsymbol{\\sigma}_p\\|_F$, is less than or equal to the tolerance $\\tau_\\sigma = 10^{-2}$ Pa.\n\nThe boolean result of each of these three checks is recorded for each of the four test cases. A final list of lists containing these booleans is then formatted for output.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases for MPM rigid-body motion invariance\n    and produce the final output.\n    \"\"\"\n\n    # Helper functions for 1D basis functions and their derivatives\n    def N_1d(x, x_node, h):\n        \"\"\"Standard 1D linear hat (tent) function.\"\"\"\n        val = 1.0 - np.abs(x - x_node) / h\n        return np.maximum(0.0, val)\n\n    def dN_1d_dx(x, x_node, h):\n        \"\"\"Derivative of the 1D linear hat function w.r.t. x.\"\"\"\n        if np.abs(x - x_node) < h:\n            return -np.sign(x - x_node) / h\n        return 0.0\n\n    # Helper functions for GIMP 1D shape functions and their derivatives\n    def S_gimp_1d(xp, x_node, h, l):\n        \"\"\"GIMP 1D shape function value.\"\"\"\n        if l == 0: return 0.0\n        r = l / h\n        xi = (xp - x_node) / h\n        abs_xi = np.abs(xi)\n        \n        if abs_xi <= 1.0 - r:\n            return 1.0 - abs_xi\n        elif abs_xi <= 1.0 + r:\n            return (1.0 + r - abs_xi)**2 / (4.0 * r)\n        else:\n            return 0.0\n\n    def dS_gimp_1d_dx(xp, x_node, h, l):\n        \"\"\"GIMP 1D shape function derivative w.r.t. xp.\"\"\"\n        if l == 0: return 0.0\n        r = l / h\n        xi = (xp - x_node) / h\n        abs_xi = np.abs(xi)\n        sign_xi = np.sign(xi)\n\n        if abs_xi <= 1.0 - r:\n            return -sign_xi / h\n        elif abs_xi <= 1.0 + r:\n            return -(1.0 + r - abs_xi) / (2.0 * r * h) * sign_xi\n        else:\n            return 0.0\n\n    h_val = 1.0 / 16.0\n    test_cases_def = [\n        {\n            'name': 'A', 'map_type': 'GIMP', 'omega': 25.0,\n            'particles': {\n                'centers': np.array([\n                    (0,0), (0.25,0), (-0.25,0), (0,0.25), (0,-0.25), \n                    (0.25,0.25), (-0.25,0.25), (0.25,-0.25), (-0.25,-0.25)\n                ]),\n                'l_xy_factor': (0.4, 0.45),\n            },\n            'quad_points': 0 \n        },\n        {\n            'name': 'B', 'map_type': 'CPDI', 'omega': 40.0,\n            'particles': {\n                'centers': np.array([\n                    (0,0), (0.25,0), (-0.25,0), (0,0.25), (0,-0.25), \n                    (0.25,0.25), (-0.25,0.25), (0.25,-0.25), (-0.25,-0.25)\n                ]),\n                'l_xy_factor': (0.8, 0.6),\n            },\n            'quad_points': 5\n        },\n        {\n            'name': 'C', 'map_type': 'GIMP', 'omega': 1000.0,\n            'particles': {\n                'centers': np.array([\n                    (0.5*h_val, 0.0), (1.5*h_val, 0.25), \n                    (-2.5*h_val, -0.25), (-0.5*h_val, 0.25)\n                ]),\n                'l_xy_factor': (0.45, 0.45),\n            },\n            'quad_points': 0 \n        },\n        {\n            'name': 'D', 'map_type': 'CPDI', 'omega': 0.0,\n            'particles': {\n                'centers': np.array([\n                    (0.3, 0.3), (-0.3, 0.3), (0.3, -0.3), (-0.3, -0.3)\n                ]),\n                'l_xy_factor': (1.2, 1.8),\n            },\n            'quad_points': 7\n        },\n    ]\n\n    all_results = []\n    for case in test_cases_def:\n        # --- System Parameters ---\n        N = 17\n        E = 1.0e7\n        nu = 0.3\n        rho = 2000.0\n        t = 1.0\n        h = 1.0 / (N - 1)\n        domain_min = -0.5\n        \n        map_type = case['map_type']\n        omega = case['omega']\n        particle_centers = case['particles']['centers']\n        lx_factor, ly_factor = case['particles']['l_xy_factor']\n        lx, ly = lx_factor * h, ly_factor * h\n        n_p = len(particle_centers)\n        \n        # --- Grid Setup ---\n        grid_coords_1d = np.linspace(domain_min, -domain_min, N)\n        grid_x, grid_y = np.meshgrid(grid_coords_1d, grid_coords_1d, indexing='ij')\n        \n        v_nodes = np.zeros((N, N, 2))\n        v_nodes[:, :, 0] = -omega * grid_y\n        v_nodes[:, :, 1] = omega * grid_x\n\n        # --- Material Properties ---\n        lamb = (E * nu) / ((1 + nu) * (1 - 2 * nu))\n        mu = E / (2 * (1 + nu))\n\n        # --- Metric Initialization ---\n        total_ke_initial = 0.0\n        total_ke_reconstructed = 0.0\n        max_D_norm = 0.0\n        max_sigma_norm = 0.0\n        \n        for p_idx in range(n_p):\n            xp, yp = particle_centers[p_idx]\n            Ap = 4 * lx * ly\n            mp = rho * t * Ap\n\n            v_initial = np.array([-omega * yp, omega * xp])\n            ke_initial = 0.5 * mp * np.dot(v_initial, v_initial)\n            total_ke_initial += ke_initial\n\n            vp_rec = np.zeros(2)\n            Lp_rec = np.zeros((2, 2))\n\n            # Determine influential nodes based on the mapping scheme's support\n            if map_type == 'GIMP':\n                support_radius_x = (1.0 + lx / h) * h\n                support_radius_y = (1.0 + ly / h) * h\n            else: # CPDI\n                support_radius_x = lx + h\n                support_radius_y = ly + h\n            \n            min_I = max(0, int(np.floor((xp - support_radius_x - domain_min) / h)))\n            max_I = min(N, int(np.ceil((xp + support_radius_x - domain_min) / h)) + 1)\n            min_J = max(0, int(np.floor((yp - support_radius_y - domain_min) / h)))\n            max_J = min(N, int(np.ceil((yp + support_radius_y - domain_min) / h)) + 1)\n            \n            for I in range(min_I, max_I):\n                for J in range(min_J, max_J):\n                    x_node, y_node = grid_x[I, J], grid_y[I, J]\n                    W_ij, grad_W_ij = 0.0, np.zeros(2)\n\n                    if map_type == 'GIMP':\n                        Sx = S_gimp_1d(xp, x_node, h, lx)\n                        Sy = S_gimp_1d(yp, y_node, h, ly)\n                        if Sx > 0 and Sy > 0:\n                            dSx_dx = dS_gimp_1d_dx(xp, x_node, h, lx)\n                            dSy_dy = dS_gimp_1d_dx(yp, y_node, h, ly)\n                            W_ij = Sx * Sy\n                            grad_W_ij[0] = dSx_dx * Sy\n                            grad_W_ij[1] = Sx * dSy_dy\n                        \n                    elif map_type == 'CPDI':\n                        nq = case['quad_points']\n                        quad_pts_1d = np.linspace(-1.0, 1.0, nq)\n                        xq_pts = xp + lx * quad_pts_1d\n                        yq_pts = yp + ly * quad_pts_1d\n                        weight = 1.0 / (nq * nq)\n                        \n                        W_ij_sum, grad_W_ij_x_sum, grad_W_ij_y_sum = 0.0, 0.0, 0.0\n                        for xq in xq_pts:\n                            for yq in yq_pts:\n                                Nx = N_1d(xq, x_node, h)\n                                Ny = N_1d(yq, y_node, h)\n                                if Nx > 0 and Ny > 0:\n                                    dNx_dx = dN_1d_dx(xq, x_node, h)\n                                    dNy_dy = dN_1d_dx(yq, y_node, h)\n                                    W_ij_sum += Nx * Ny\n                                    grad_W_ij_x_sum += dNx_dx * Ny\n                                    grad_W_ij_y_sum += Nx * dNy_dy\n                        \n                        W_ij = weight * W_ij_sum\n                        grad_W_ij = weight * np.array([grad_W_ij_x_sum, grad_W_ij_y_sum])\n\n                    if W_ij > 1e-15:\n                        v_node = v_nodes[I, J, :]\n                        vp_rec += W_ij * v_node\n                        Lp_rec += np.outer(v_node, grad_W_ij)\n            \n            ke_reconstructed = 0.5 * mp * np.dot(vp_rec, vp_rec)\n            total_ke_reconstructed += ke_reconstructed\n\n            Dp_rec = 0.5 * (Lp_rec + Lp_rec.T)\n            Dp_norm = np.linalg.norm(Dp_rec, 'fro')\n            max_D_norm = max(max_D_norm, Dp_norm)\n            \n            trace_D = np.trace(Dp_rec)\n            sigma_p = lamb * trace_D * np.identity(2) + 2 * mu * Dp_rec\n            sigma_norm = np.linalg.norm(sigma_p, 'fro')\n            max_sigma_norm = max(max_sigma_norm, sigma_norm)\n\n        # --- Final Validation ---\n        tau_D = 1e-8 * max(1.0, abs(omega))\n        tau_T = 1e-10 * max(1.0, total_ke_initial)\n        tau_sigma = 1e-2\n\n        strain_zero = bool(max_D_norm <= tau_D)\n        ke_constant = bool(abs(total_ke_reconstructed - total_ke_initial) <= tau_T)\n        stress_zero = bool(max_sigma_norm <= tau_sigma)\n        \n        all_results.append([strain_zero, ke_constant, stress_zero])\n\n    # --- Format and Print Final Output ---\n    result_strings = [f\"[{r[0]},{r[1]},{r[2]}]\".lower() for r in all_results]\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While linear momentum is conserved by design in most MPM formulations, the conservation of angular momentum is a more subtle property that depends on the symmetry of the discrete operators. Asymmetric mappings can introduce spurious internal torques, leading to incorrect rotational dynamics, a significant issue in problems with complex motion. This advanced exercise  explores this very issue, tasking you with quantifying the artificial torque from a naive mapping and demonstrating how the carefully constructed CPDI formulation correctly conserves angular momentum.",
            "id": "3541779",
            "problem": "Consider a two-dimensional material point method on a uniform Cartesian grid for computational geomechanics, in which a single material point (particle) interacts with grid nodes through mapping operators. The goal is to analyze the discrete balance of angular momentum for internal forces induced by a uniform, symmetric Cauchy stress and to quantify mapping-induced torque under two particle-to-grid mappings: a corner-averaged gradient mapping that serves as a proxy for a naive Generalized Interpolation Material Point (GIMP) approach, and the Convected Particle Domain Interpolation (CPDI) mapping. You will then implement a symmetric correction that removes the spurious torque while preserving linear momentum.\n\nStart from the following fundamental base:\n\n- Continuum linear momentum balance for a material subdomain: the internal force density is given by the divergence of the Cauchy stress, and the nodal internal force arising from a particle discretization is a quadrature of the stress divergence against gradients of grid shape functions.\n- Continuum angular momentum balance requires the Cauchy stress to be symmetric and implies that the net internal couple (torque) is zero in the absence of external couples.\n- In a discrete grid formulation, the internal nodal force at grid node $i$ due to a particle $p$ of area $V_p$ and Cauchy stress $\\boldsymbol{\\sigma}_p$ is assembled as\n$$\n\\mathbf{f}^{\\text{int}}_i \\;=\\; -\\sum_{p} V_p\\, \\boldsymbol{\\sigma}_p \\cdot \\nabla S_{ip},\n$$\nwhere $\\nabla S_{ip}$ is the mapped gradient weight associated with node $i$ and particle $p$. The discrete internal torque about the origin is\n$$\n\\tau_z \\;=\\; \\sum_{i} \\big(\\mathbf{x}_i \\times \\mathbf{f}^{\\text{int}}_i\\big)\\cdot \\mathbf{e}_z,\n$$\nwhere $\\mathbf{x}_i$ is the position of node $i$, $\\times$ is the three-dimensional cross product, and $\\mathbf{e}_z$ is the unit vector out of the plane.\n\nDefinitions and assumptions to be used in this problem:\n\n- Use a uniform Cartesian grid with spacing $h = 1$ in meters. Grid nodes are located at $(i\\,h, j\\,h)$ for integers $i$ and $j$.\n- Within any grid cell, use standard bilinear finite element basis functions. For a cell with lower-left corner at $(x_0, y_0)$ and local coordinates $\\xi = (x-x_0)/h$ and $\\eta = (y-y_0)/h$, the shape functions attached to the four cell vertices are\n  - $N_{00} = (1-\\xi)(1-\\eta)$, $N_{10} = \\xi (1-\\eta)$, $N_{01} = (1-\\xi)\\eta$, $N_{11} = \\xi \\eta$,\n  with corresponding physical gradients\n  $$\n  \\nabla N_{00} = \\left[-\\frac{1-\\eta}{h}, -\\frac{1-\\xi}{h}\\right],\\;\n  \\nabla N_{10} = \\left[ \\frac{1-\\eta}{h}, -\\frac{\\xi}{h}\\right],\\;\n  \\nabla N_{01} = \\left[-\\frac{\\eta}{h}, \\frac{1-\\xi}{h}\\right],\\;\n  \\nabla N_{11} = \\left[ \\frac{\\eta}{h}, \\frac{\\xi}{h}\\right].\n  $$\n- The particle $p$ has center $\\mathbf{x}_p \\in \\mathbb{R}^2$, axis-aligned half-dimensions $a = L_x/2$, $b = L_y/2$ in meters, and in-plane rotation by angle $\\theta$ in radians. Its four corners are\n$$\n\\mathbf{x}_p^{(c)} \\;=\\; \\mathbf{x}_p + \\mathbf{R}(\\theta)\\,\\mathbf{q}^{(c)},\\quad \\text{with}\\quad \\mathbf{q}^{(c)} \\in \\{(\\pm a, \\pm b)\\},\n$$\nordered counter-clockwise, $\\mathbf{R}(\\theta)$ is the planar rotation matrix, and the area is $A_p = L_x L_y$.\n- The Cauchy stress is uniform and isotropic, $\\boldsymbol{\\sigma}_p = p\\,\\mathbf{I}$ with $p$ in pascals and $\\mathbf{I}$ the identity tensor. There are no body couples and no external tractions on the grid nodes; only internal forces are considered.\n- Three particle-to-grid gradient mappings $\\nabla S_{ip}$ will be compared:\n  1. A naive corner-averaged gradient mapping (proxy for a naive Generalized Interpolation Material Point approach): \n     $$\n     \\nabla S_{ip}^{\\text{naive}} \\;=\\; \\frac{1}{4}\\sum_{c=1}^{4} \\nabla N_i\\!\\left(\\mathbf{x}_p^{(c)}\\right),\n     $$\n     where each corner $\\mathbf{x}_p^{(c)}$ is evaluated in its containing cell and contributes to the four nodes of that cell.\n  2. Convected Particle Domain Interpolation (CPDI-1) mapping:\n     $$\n     \\nabla S_{ip}^{\\text{CPDI}} \\;=\\; \\frac{1}{A_p}\\sum_{c=1}^{4} N_i\\!\\left(\\mathbf{x}_p^{(c)}\\right)\\,\\mathbf{r}^{(c)},\n     $$\n     where the corner vector is \n     $$\n     \\mathbf{r}^{(c)} \\;=\\; \\frac{1}{2}\\,\\begin{bmatrix}\n     y_p^{(c+1)} - y_p^{(c-1)} \\\\\n     -\\left(x_p^{(c+1)} - x_p^{(c-1)}\\right)\n     \\end{bmatrix},\n     $$\n     using cyclic indexing on corners. This is the standard CPDI-1 boundary-integral-based gradient for a convex quadrilateral particle domain.\n  3. A symmetric correction applied a posteriori to any assembled internal nodal forces $\\{\\mathbf{f}^{\\text{int}}_i\\}$ to remove the net internal torque while preserving net internal force. Let the arithmetic mean of supporting node positions be $\\bar{\\mathbf{x}} = \\frac{1}{n}\\sum_i \\mathbf{x}_i$ and let $J$ be the $\\pi/2$ rotation in the plane, $J[x, y]^\\top = [-y, x]^\\top$. Define\n     $$\n     \\lambda \\;=\\; -\\,\\frac{\\tau_z}{\\sum_i \\|\\mathbf{x}_i - \\bar{\\mathbf{x}}\\|^2},\\qquad\n     \\delta\\mathbf{f}_i \\;=\\; \\lambda\\,J\\left(\\mathbf{x}_i - \\bar{\\mathbf{x}}\\right),\n     $$\n     and corrected forces $\\mathbf{f}^{\\text{corr}}_i = \\mathbf{f}^{\\text{int}}_i + \\delta\\mathbf{f}_i$. This construction preserves $\\sum_i \\mathbf{f}^{\\text{corr}}_i = \\sum_i \\mathbf{f}^{\\text{int}}_i$ and enforces zero net internal torque.\n\nYour tasks:\n\n- Implement the bilinear shape evaluation and gradient within the containing grid cell of any query point, consistent with the above grid and basis.\n- For a given particle, assemble internal nodal forces $\\mathbf{f}^{\\text{int}}_i = - V_p\\, p\\, \\nabla S_{ip}$ using each mapping $\\nabla S_{ip}$ described above. Include all nodes that are vertices of any cell that contains at least one particle corner.\n- Compute the scalar out-of-plane torque in newton-meters,\n$$\n\\tau_z \\;=\\; \\sum_{i} \\left( x_i\\, f^{\\text{int}}_{i,y} - y_i\\, f^{\\text{int}}_{i,x} \\right),\n$$\nfor the naive corner-averaged mapping, for the CPDI mapping, and for the symmetric-corrected forces applied to the naive mapping. Round the output to reasonable floating-point representation; units must be in newton-meters.\n\nDesign a test suite with three cases that probe different facets of the mapping-induced torque:\n\n- Case A (happy path, particle inside one cell): $\\mathbf{x}_p = (0.5,\\,0.5)$ meters, $(L_x, L_y) = (0.4,\\,0.4)$ meters, $\\theta = 0$ radians.\n- Case B (edge case, domain straddles multiple cells): $\\mathbf{x}_p = (0.75,\\,0.5)$ meters, $(L_x, L_y) = (1.2,\\,0.6)$ meters, $\\theta = 0$ radians.\n- Case C (rotated, domain straddles multiple cells): $\\mathbf{x}_p = (0.5,\\,0.5)$ meters, $(L_x, L_y) = (1.2,\\,0.6)$ meters, $\\theta = \\pi/6$ radians.\n\nUse $h = 1$ meter, $p = 1000$ pascals, and $V_p = A_p = L_x L_y$ in square meters. Angles must be in radians. All answers for torque must be expressed in newton-meters as floats.\n\nFinal output format:\n\n- Your program should produce a single line of output containing the $9$ results as a comma-separated list enclosed in square brackets, ordered as\n$[\\tau^{\\text{naive}}_{\\text{A}},\\;\\tau^{\\text{CPDI}}_{\\text{A}},\\;\\tau^{\\text{corr}}_{\\text{A}},\\;\\tau^{\\text{naive}}_{\\text{B}},\\;\\tau^{\\text{CPDI}}_{\\text{B}},\\;\\tau^{\\text{corr}}_{\\text{B}},\\;\\tau^{\\text{naive}}_{\\text{C}},\\;\\tau^{\\text{CPDI}}_{\\text{C}},\\;\\tau^{\\text{corr}}_{\\text{C}}]$.\nNo other text should be printed. All values must be in newton-meters.",
            "solution": "The problem requires an analysis of mapping-induced spurious torque in the Material Point Method (MPM) for a two-dimensional domain on a uniform Cartesian grid. We will implement and compare three approaches for computing internal nodal forces and the resulting net internal torque for a single particle subjected to a uniform isotropic stress state: a naive corner-averaged gradient mapping (a proxy for a naive GIMP), the Convected Particle Domain Interpolation (CPDI) mapping, and a symmetric a posteriori correction applied to the naive mapping.\n\nThe fundamental principle is the balance of linear and angular momentum. In the continuum, for a body subjected to a symmetric Cauchy stress tensor $\\boldsymbol{\\sigma}$ with no body couples, the net internal torque is zero. In a discrete MPM formulation, this property is not always preserved, leading to numerical errors. The discrete internal force at a grid node $i$ from a particle $p$ with volume $V_p$ and stress $\\boldsymbol{\\sigma}_p$ is given by:\n$$\n\\mathbf{f}^{\\text{int}}_i = - V_p\\, \\boldsymbol{\\sigma}_p \\cdot \\nabla S_{ip}\n$$\nwhere $\\nabla S_{ip}$ is the particle-to-grid mapped gradient of the grid basis function $S_i$. Given the problem specifies a uniform isotropic stress $\\boldsymbol{\\sigma}_p = p\\,\\mathbf{I}$, where $p$ is a constant pressure and $\\mathbf{I}$ is the identity tensor, this simplifies to:\n$$\n\\mathbf{f}^{\\text{int}}_i = - V_p\\, p\\, \\nabla S_{ip}\n$$\nThe total internal torque about the origin is the sum of the moments of these nodal forces:\n$$\n\\tau_z = \\sum_{i} \\big(\\mathbf{x}_i \\times \\mathbf{f}^{\\text{int}}_i\\big)\\cdot \\mathbf{e}_z = \\sum_{i} \\left( x_i\\, f^{\\text{int}}_{i,y} - y_i\\, f^{\\text{int}}_{i,x} \\right)\n$$\nwhere $\\mathbf{x}_i = [x_i, y_i]^\\top$ is the position of node $i$, and $\\mathbf{f}^{\\text{int}}_i = [f^{\\text{int}}_{i,x}, f^{\\text{int}}_{i,y}]^\\top$. The problem is set in two dimensions on a grid with spacing $h=1$ m. A single particle is considered, for which the volume $V_p$ is taken to be its area $A_p = L_x L_y$. The pressure is given as $p=1000$ Pa.\n\nOur computational procedure is as follows:\nFirst, we establish geometric and finite element utilities. For any point $\\mathbf{x} \\in \\mathbb{R}^2$, we must identify its containing grid cell and evaluate the bilinear shape functions $N_i(\\mathbf{x})$ and their gradients $\\nabla N_i(\\mathbf{x})$ associated with the cell's four vertices. The provided formulas for $N_i$ and $\\nabla N_i$ in local coordinates $\\xi, \\eta$ are implemented.\n\nSecond, for each of the three test cases, we define the particle's geometry. Given its center $\\mathbf{x}_p$, dimensions $(L_x, L_y)$, and rotation angle $\\theta$, we compute the world coordinates of its four corners, $\\mathbf{x}_p^{(c)}$, and its area, $A_p$.\n\nThird, we implement the three distinct methods to compute nodal forces and torque.\n\n1.  **Naive Corner-Averaged Mapping**:\n    The gradient weight is an average of the standard finite element shape function gradients evaluated at the particle's four corners:\n    $$\n    \\nabla S_{ip}^{\\text{naive}} = \\frac{1}{4}\\sum_{c=1}^{4} \\nabla N_i\\!\\left(\\mathbf{x}_p^{(c)}\\right)\n    $$\n    We identify the set of all unique grid nodes that are vertices of any cell containing one or more particle corners. For each such node $i$, we sum the gradient contributions from each corner and then average. The internal force $\\mathbf{f}^{\\text{int}}_i$ is then computed and the total torque $\\tau_z^{\\text{naive}}$ is summed. This method does not generally conserve angular momentum, and we expect a non-zero torque when the particle is not symmetrically aligned with the grid.\n\n2.  **Convected Particle Domain Interpolation (CPDI) Mapping**:\n    The CPDI gradient mapping is designed to be variationally consistent and is known to conserve both linear and angular momentum exactly for uniform stress states, even for general quadrilateral particle domains. The gradient is defined as:\n    $$\n    \\nabla S_{ip}^{\\text{CPDI}} = \\frac{1}{A_p}\\sum_{c=1}^{4} N_i\\!\\left(\\mathbf{x}_p^{(c)}\\right)\\,\\mathbf{r}^{(c)}\n    $$\n    where $\\mathbf{r}^{(c)}$ are geometric vectors derived from the particle corner coordinates:\n    $$\n    \\mathbf{r}^{(c)} = \\frac{1}{2}\\,\\begin{bmatrix} y_p^{(c+1)} - y_p^{(c-1)} \\\\ -\\left(x_p^{(c+1)} - x_p^{(c-1)}\\right) \\end{bmatrix}\n    $$\n    The procedure involves first calculating the four vectors $\\mathbf{r}^{(c)}$ using cyclic indexing on the corners. Then, for each corner, we evaluate the shape functions $N_i$ at its location and accumulate the weighted sums for $\\nabla S_{ip}^{\\text{CPDI}}$. Forces and the resulting torque $\\tau_z^{\\text{CPDI}}$ are then computed. We theoretically expect $\\tau_z^{\\text{CPDI}} = 0$ for all test cases.\n\n3.  **Symmetric Correction**:\n    This method provides a way to enforce angular momentum balance a posteriori. Starting with a set of internal forces $\\{\\mathbf{f}^{\\text{int}}_i\\}$ (in our case, those from the naive mapping) that produce a non-zero torque $\\tau_z$, we compute a set of corrective nodal forces $\\{\\delta\\mathbf{f}_i\\}$ that have a zero net force but a net torque of $-\\tau_z$. The correction is defined as:\n    $$\n    \\delta\\mathbf{f}_i = \\lambda\\,J\\left(\\mathbf{x}_i - \\bar{\\mathbf{x}}\\right) \\quad \\text{with} \\quad \\lambda = -\\,\\frac{\\tau_z}{\\sum_j \\|\\mathbf{x}_j - \\bar{\\mathbf{x}}\\|^2}\n    $$\n    Here, $\\bar{\\mathbf{x}}$ is the centroid of the supporting node positions, and $J$ is the operator for a $\\pi/2$ rotation. The corrected forces are $\\mathbf{f}^{\\text{corr}}_i = \\mathbf{f}^{\\text{int}}_i + \\delta\\mathbf{f}_i$. By construction, $\\sum_i \\mathbf{f}^{\\text{corr}}_i = \\sum_i \\mathbf{f}^{\\text{int}}_i$ (preserving linear momentum balance if it existed), and the new total torque $\\tau_z^{\\text{corr}}$ is zero (up to floating-point precision).\n\nWe apply this three-step analysis to each test case (A, B, and C) and collect the nine resulting torque values for the final output. The calculations are performed using double-precision floating-point arithmetic.\n-   **Case A**: A small, unrotated particle fully inside one cell. Due to complete symmetry, we expect all three methods to yield zero torque.\n-   **Case B**: A larger, unrotated particle straddling a cell boundary. This asymmetry is expected to produce a non-zero torque for the naive mapping.\n-   **Case C**: A large, rotated particle centered in a cell but spanning multiple cells. This complex geometry is also expected to induce a spurious torque in the naive mapping.\n\nFor both CPDI and the corrected method, the theoretical result for torque is $0$. The implementation should yield values very close to zero, reflecting the limits of floating-point arithmetic.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the calculations for all test cases.\n    \"\"\"\n    H = 1.0  # Grid spacing\n    P = 1000.0  # Pressure\n\n    # (center, (Lx, Ly), theta)\n    test_cases = [\n        # Case A\n        ((0.5, 0.5), (0.4, 0.4), 0.0),\n        # Case B\n        ((0.75, 0.5), (1.2, 0.6), 0.0),\n        # Case C\n        ((0.5, 0.5), (1.2, 0.6), np.pi / 6.0),\n    ]\n\n    results = []\n    for xp, L, theta in test_cases:\n        particle = Particle(xp, L, theta)\n\n        # 1. Naive corner-averaged mapping\n        naive_forces = calculate_naive_forces(particle, P, H)\n        tau_naive = calculate_torque(naive_forces)\n\n        # 2. CPDI mapping\n        cpdi_forces = calculate_cpdi_forces(particle, P, H)\n        tau_cpdi = calculate_torque(cpdi_forces)\n\n        # 3. Symmetric correction on naive forces\n        _, tau_corr = apply_correction(naive_forces, tau_naive)\n\n        results.extend([tau_naive, tau_cpdi, tau_corr])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef get_shape_info(point, h=1.0):\n    \"\"\"\n    Calculates shape functions and gradients for a point in a Cartesian grid.\n\n    Args:\n        point (np.ndarray): The (x, y) coordinates of the query point.\n        h (float): The grid cell spacing.\n\n    Returns:\n        dict: A dictionary mapping node coordinates (tuples) to their\n              shape function values ('N') and gradients ('gradN').\n    \"\"\"\n    x, y = point\n    x0 = np.floor(x / h) * h\n    y0 = np.floor(y / h) * h\n\n    xi = (x - x0) / h\n    eta = (y - y0) / h\n\n    # Node coordinates for the cell, ordered to match N00, N10, N01, N11\n    nodes_coords = [\n        (x0, y0),          # For N00\n        (x0 + h, y0),      # For N10\n        (x0, y0 + h),      # For N01\n        (x0 + h, y0 + h),  # For N11\n    ]\n\n    # Shape function values\n    N_vals = [\n        (1 - xi) * (1 - eta),  # N00\n        xi * (1 - eta),        # N10\n        (1 - xi) * eta,        # N01\n        xi * eta,              # N11\n    ]\n\n    # Shape function gradients\n    grad_N_vals = [\n        np.array([-(1 - eta) / h, -(1 - xi) / h]),  # gradN00\n        np.array([(1 - eta) / h, -xi / h]),         # gradN10\n        np.array([-eta / h, (1 - xi) / h]),        # gradN01\n        np.array([eta / h, xi / h]),               # gradN11\n    ]\n\n    info = {}\n    for i in range(4):\n        info[nodes_coords[i]] = {'N': N_vals[i], 'gradN': grad_N_vals[i]}\n    return info\n\nclass Particle:\n    \"\"\"\n    Represents a 2D rectangular material point (particle).\n    \"\"\"\n\n    def __init__(self, xp, L, theta):\n        \"\"\"\n        Initializes the particle's geometry.\n\n        Args:\n            xp (tuple): Center coordinates (x, y).\n            L (tuple): Dimensions (Lx, Ly).\n            theta (float): Rotation angle in radians.\n        \"\"\"\n        self.xp = np.array(xp)\n        self.Lx, self.Ly = L\n        self.theta = theta\n        self.Ap = self.Lx * self.Ly\n\n        a = self.Lx / 2.0\n        b = self.Ly / 2.0\n\n        # Local corner coordinates, ordered CCW for r_c calculation\n        q_local = [\n            np.array([a, -b]),\n            np.array([a, b]),\n            np.array([-a, b]),\n            np.array([-a, -b]),\n        ]\n\n        c, s = np.cos(theta), np.sin(theta)\n        R = np.array([[c, -s], [s, c]])\n\n        self.corners = [self.xp + R @ qc for qc in q_local]\n\ndef calculate_naive_forces(particle, p, h):\n    \"\"\"\n    Computes internal nodal forces using the naive corner-averaged mapping.\n    \"\"\"\n    grad_S = {}\n    \n    for c_idx in range(4):\n        corner_pos = particle.corners[c_idx]\n        shape_info = get_shape_info(corner_pos, h)\n        \n        for node_coord, info in shape_info.items():\n            if node_coord not in grad_S:\n                grad_S[node_coord] = np.zeros(2)\n            grad_S[node_coord] += info['gradN']\n            \n    forces = {}\n    for node_coord, summed_grad in grad_S.items():\n        avg_grad = summed_grad / 4.0\n        # Force is -Vp*p*gradS; problem states Vp = Ap\n        forces[node_coord] = -particle.Ap * p * avg_grad\n\n    return forces\n\ndef calculate_cpdi_forces(particle, p, h):\n    \"\"\"\n    Computes internal nodal forces using the CPDI mapping.\n    \"\"\"\n    corners = particle.corners\n    r_c = []\n    for c_idx in range(4):\n        c_prev = (c_idx - 1 + 4) % 4\n        c_next = (c_idx + 1) % 4\n        \n        xp_prev, yp_prev = corners[c_prev]\n        xp_next, yp_next = corners[c_next]\n        \n        r_vec = 0.5 * np.array([yp_next - yp_prev, -(xp_next - xp_prev)])\n        r_c.append(r_vec)\n        \n    grad_S = {}\n    for c_idx in range(4):\n        corner_pos = corners[c_idx]\n        shape_info = get_shape_info(corner_pos, h)\n        r_vec = r_c[c_idx]\n        \n        for node_coord, info in shape_info.items():\n            if node_coord not in grad_S:\n                grad_S[node_coord] = np.zeros(2, dtype=float)\n            grad_S[node_coord] += info['N'] * r_vec\n            \n    forces = {}\n    for node_coord, summed_N_r in grad_S.items():\n        grad = summed_N_r / particle.Ap\n        # Force is -Vp*sigma.gradS = -Vp*p*gradS; Vp=Ap\n        forces[node_coord] = -particle.Ap * p * grad\n\n    return forces\n\ndef calculate_torque(forces):\n    \"\"\"\n    Computes the total 2D torque about the origin from a set of nodal forces.\n    \"\"\"\n    tau_z = 0.0\n    for node_coord, f_int in forces.items():\n        x_i, y_i = node_coord\n        f_x, f_y = f_int\n        tau_z += x_i * f_y - y_i * f_x\n    return tau_z\n\ndef apply_correction(forces, tau_z):\n    \"\"\"\n    Applies the symmetric correction to a set of forces to nullify torque.\n    \"\"\"\n    if np.isclose(tau_z, 0.0):\n        return forces, 0.0\n        \n    node_coords_list = list(forces.keys())\n    node_coords = np.array(node_coords_list)\n    \n    if len(node_coords) < 2:\n        return forces, tau_z\n\n    x_bar = np.mean(node_coords, axis=0)\n    \n    sum_sq_dist = np.sum((node_coords - x_bar)**2)\n        \n    if np.isclose(sum_sq_dist, 0.0):\n        return forces, tau_z\n\n    lambda_corr = -tau_z / sum_sq_dist\n    \n    corr_forces = {}\n    for node_coord_tuple in node_coords_list:\n        node_coord = np.array(node_coord_tuple)\n        d_i = node_coord - x_bar\n        # delta_f_i = lambda * J(d_i) where J(d_i) = [-d_i_y, d_i_x]\n        delta_f_i = lambda_corr * np.array([-d_i[1], d_i[0]])\n        corr_forces[node_coord_tuple] = forces[node_coord_tuple] + delta_f_i\n        \n    new_tau = calculate_torque(corr_forces)\n    \n    return corr_forces, new_tau\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}