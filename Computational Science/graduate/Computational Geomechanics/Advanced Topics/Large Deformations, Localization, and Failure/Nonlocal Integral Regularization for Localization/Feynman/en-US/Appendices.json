{
    "hands_on_practices": [
        {
            "introduction": "The first step in mastering nonlocal models is translating the continuous integral definition into a concrete numerical algorithm. This practice guides you through the process of discretizing the one-dimensional nonlocal averaging operator. By implementing this operator and testing it against several cases, you will build intuition for its fundamental properties, such as its ability to smooth sharp gradients and how its behavior depends on the internal length scale, $\\ell$ .",
            "id": "3546153",
            "problem": "Consider a one-dimensional continuum model used in computational geomechanics to regularize strain localization via a nonlocal integral average. In strain-softening materials, purely local constitutive laws can lead to ill-posed boundary value problems, where infinitesimal perturbations yield unbounded localization in vanishingly small zones. A common remedy is nonlocal integral regularization: the local driving variable (for example, the equivalent strain) is replaced by an integral average over a finite neighborhood weighted by a kernel. Starting from the conservation of linear momentum and standard small-strain kinematics, the constitutive law is augmented by a nonlocal equivalent strain that enters the softening law. The nonlocal equivalent strain field $\\bar{\\varepsilon}_{\\mathrm{eq}}(x)$ is defined by\n$$\n\\bar{\\varepsilon}_{\\mathrm{eq}}(x) \\;=\\; \\dfrac{\\displaystyle \\int_{\\Omega} \\alpha\\!\\left(\\lVert x-\\xi\\rVert\\right)\\, \\varepsilon_{\\mathrm{eq}}(\\xi)\\, \\mathrm{d}\\xi}{\\displaystyle \\int_{\\Omega} \\alpha\\!\\left(\\lVert x-\\xi\\rVert\\right)\\, \\mathrm{d}\\xi},\n$$\nwhere $\\Omega$ is the domain, $\\varepsilon_{\\mathrm{eq}}(\\xi)$ is the local equivalent strain, and $\\alpha(r)$ is a positive, decaying kernel that introduces an internal length scale and is used to regularize the problem. You will implement a numerical discretization of this nonlocal operator for a one-dimensional bar.\n\nAssume a one-dimensional bar occupying the interval $[0,L]$ with length $L$ measured in meters. Let the domain be discretized into $N$ equally spaced nodes $\\{x_i\\}_{i=1}^N$ with spacing $h = L/(N-1)$. Let the kernel be the exponential function\n$$\n\\alpha(r) \\;=\\; \\exp\\!\\left(-\\dfrac{r}{\\ell}\\right),\n$$\nwhere $\\ell$ is the internal length scale measured in meters. Approximate the integrals with the composite trapezoidal rule, i.e., use quadrature weights $w_1 = w_N = h/2$ and $w_i = h$ for $i=2,\\dots,N-1$. The discrete nonlocal average at node $x_j$ is\n$$\n\\bar{\\varepsilon}_{\\mathrm{eq}}(x_j) \\;\\approx\\; \\dfrac{\\displaystyle \\sum_{i=1}^N \\alpha\\!\\left(\\lvert x_j - x_i\\rvert\\right)\\, \\varepsilon_{\\mathrm{eq}}(x_i)\\, w_i}{\\displaystyle \\sum_{i=1}^N \\alpha\\!\\left(\\lvert x_j - x_i\\rvert\\right)\\, w_i}.\n$$\n\nImplement a complete, runnable program that:\n- Constructs the nodes $\\{x_i\\}$ and trapezoidal weights $\\{w_i\\}$ for given $L$ (in meters) and $N$.\n- Given a specified local equivalent strain field $\\varepsilon_{\\mathrm{eq}}(x)$, computes the discrete nonlocal average $\\bar{\\varepsilon}_{\\mathrm{eq}}(x_j)$ at all nodes for a given internal length $\\ell$ (in meters).\n- Uses the exponential kernel as specified.\n- Produces results for the following test suite of cases. All strains are dimensionless. All lengths and the internal length $\\ell$ are in meters.\n\nTest Case A (uniform invariance):\n- Parameters: $L = 1$, $N = 101$, $\\ell = 0.05$.\n- Local field: $\\varepsilon_{\\mathrm{eq}}(x) = 0.01$ for all $x \\in [0,1]$.\n- Required output: the maximum absolute deviation $\\max_j \\lvert \\bar{\\varepsilon}_{\\mathrm{eq}}(x_j) - 0.01 \\rvert$ as a float.\n\nTest Case B (localized top-hat, center value):\n- Parameters: $L = 1$, $N = 1001$, $\\ell = 0.1$.\n- Local field: $\\varepsilon_{\\mathrm{eq}}(x) = 0.02$ for $x \\in [0.4, 0.6]$ and $\\varepsilon_{\\mathrm{eq}}(x) = 0$ otherwise.\n- Required output: the value of $\\bar{\\varepsilon}_{\\mathrm{eq}}(x_c)$ at $x_c = 0.5$ as a float.\n\nTest Case C (large internal length, approach to mean):\n- Parameters: $L = 1$, $N = 1001$, $\\ell = 1.0$.\n- Local field: same as Test Case B.\n- Theoretical mean value for large $\\ell$: $\\varepsilon_{\\mathrm{mean}} = 0.02 \\times \\dfrac{0.6 - 0.4}{1} = 0.004$.\n- Required output: the absolute difference $\\lvert \\bar{\\varepsilon}_{\\mathrm{eq}}(0.5) - 0.004 \\rvert$ as a float.\n\nTest Case D (near-local limit at center):\n- Parameters: $L = 1$, $N = 1001$, $\\ell = h = L/(N-1)$.\n- Local field: same as Test Case B.\n- Required output: the absolute difference $\\lvert \\bar{\\varepsilon}_{\\mathrm{eq}}(0.5) - 0.02 \\rvert$ as a float.\n\nTest Case E (boundary effect for a gradient):\n- Parameters: $L = 1$, $N = 201$, $\\ell = 0.1$.\n- Local field: $\\varepsilon_{\\mathrm{eq}}(x) = x/L$ for all $x \\in [0,1]$.\n- Required output: the value $\\bar{\\varepsilon}_{\\mathrm{eq}}(0)$ at the left boundary as a float.\n\nYour program should produce a single line of output containing the results for Test Cases A through E, in order, as a comma-separated list enclosed in square brackets (for example, $[r_A,r_B,r_C,r_D,r_E]$). No units are attached to the printed numbers because all outputs are dimensionless. The program must not read any external input.\n\nThe implementation must be scientifically consistent and numerically robust. The discretization must follow the stated trapezoidal quadrature, and the nonlocal average must use the exponential kernel with the internal length scale. Carefully manage boundary normalization via the denominator in the discrete formula to avoid artificial bias near the domain boundaries.",
            "solution": "The problem requires the implementation of a numerical algorithm to compute a nonlocal integral average, a technique used in computational geomechanics to regularize mathematical models of strain localization in materials. The solution will be constructed by discretizing the governing integral equation and applying it to a series of well-defined test cases.\n\nThe continuous one-dimensional nonlocal equivalent strain $\\bar{\\varepsilon}_{\\mathrm{eq}}(x)$ is defined as a weighted average of the local equivalent strain field $\\varepsilon_{\\mathrm{eq}}(\\xi)$ over the domain $\\Omega = [0, L]$:\n$$\n\\bar{\\varepsilon}_{\\mathrm{eq}}(x) \\;=\\; \\dfrac{\\displaystyle \\int_{0}^{L} \\alpha\\!\\left(\\lvert x-\\xi\\rvert\\right)\\, \\varepsilon_{\\mathrm{eq}}(\\xi)\\, \\mathrm{d}\\xi}{\\displaystyle \\int_{0}^{L} \\alpha\\!\\left(\\lvert x-\\xi\\rvert\\right)\\, \\mathrm{d}\\xi}\n$$\nThe kernel function $\\alpha(r)$ is given by the exponential decay model:\n$$\n\\alpha(r) \\;=\\; \\exp\\!\\left(-\\dfrac{r}{\\ell}\\right)\n$$\nwhere $r = \\lvert x-\\xi\\rvert$ is the distance and $\\ell$ is the characteristic internal length scale. The denominator in the definition of $\\bar{\\varepsilon}_{\\mathrm{eq}}(x)$ ensures that the weights sum to unity, which is particularly important near the boundaries of the domain where the integral is truncated.\n\nTo solve this problem numerically, we first discretize the domain $\\Omega = [0, L]$ into a set of $N$ equally spaced nodes, $\\{x_i\\}_{i=1}^N$. The nodes are located at $x_i = (i-1)h$ for $i = 1, \\dots, N$, where $h = L/(N-1)$ is the constant grid spacing.\n\nWe approximate the integrals in the definition of $\\bar{\\varepsilon}_{\\mathrm{eq}}(x)$ using the composite trapezoidal rule. The integral of a function $f(\\xi)$ over $[0, L]$ is approximated as:\n$$\n\\int_0^L f(\\xi) \\, \\mathrm{d}\\xi \\approx \\sum_{i=1}^N f(x_i) w_i\n$$\nThe quadrature weights $\\{w_i\\}$ for the trapezoidal rule are $w_1 = w_N = h/2$ and $w_i = h$ for all interior nodes $i=2, \\dots, N-1$.\n\nApplying this numerical quadrature to the nonlocal averaging formula at a specific node $x_j$ yields the discrete approximation:\n$$\n\\bar{\\varepsilon}_{\\mathrm{eq}}(x_j) \\;\\approx\\; \\dfrac{\\displaystyle \\sum_{i=1}^N \\alpha\\!\\left(\\lvert x_j - x_i\\rvert\\right)\\, \\varepsilon_{\\mathrm{eq}}(x_i)\\, w_i}{\\displaystyle \\sum_{i=1}^N \\alpha\\!\\left(\\lvert x_j - x_i\\rvert\\right)\\, w_i}\n$$\nThis expression must be computed for each node $j=1, \\dots, N$.\n\nThe implementation will be vectorized for computational efficiency. Let $\\mathbf{x}$ be the column vector of node coordinates, $\\mathbf{w}$ be the vector of trapezoidal weights, and $\\boldsymbol{\\varepsilon}_{\\mathrm{eq}}$ be the vector of local strain values at the nodes. The core of the calculation involves constructing a kernel matrix $\\mathbf{A}$ of size $N \\times N$, where each element $A_{ji}$ is given by:\n$$\nA_{ji} = \\alpha(\\lvert x_j - x_i \\rvert) = \\exp\\left(-\\frac{\\lvert x_j - x_i \\rvert}{\\ell}\\right)\n$$\nThe vector of nonlocal equivalent strains, $\\bar{\\boldsymbol{\\varepsilon}}_{\\mathrm{eq}}$, is then computed as follows:\n1.  Define the node vector $\\mathbf{x} = [x_1, \\dots, x_N]^T$.\n2.  Define the weight vector $\\mathbf{w} = [w_1, \\dots, w_N]^T$.\n3.  Evaluate the local strain field at the nodes to get $\\boldsymbol{\\varepsilon}_{\\mathrm{eq}} = [\\varepsilon_{\\mathrm{eq}}(x_1), \\dots, \\varepsilon_{\\mathrm{eq}}(x_N)]^T$.\n4.  Construct the matrix of distances $\\mathbf{D}$ with elements $D_{ji} = \\lvert x_j - x_i \\rvert$.\n5.  Construct the kernel matrix $\\mathbf{A} = \\exp(-\\mathbf{D}/\\ell)$.\n6.  Compute the numerator vector $\\mathbf{n} = \\mathbf{A} (\\boldsymbol{\\varepsilon}_{\\mathrm{eq}} \\odot \\mathbf{w})$, where $\\odot$ denotes the element-wise (Hadamard) product. This corresponds to the sum in the numerator for each $j$.\n7.  Compute the denominator vector $\\mathbf{d} = \\mathbf{A} \\mathbf{w}$. This corresponds to the sum in the denominator for each $j$.\n8.  The final result is obtained by element-wise division: $\\bar{\\boldsymbol{\\varepsilon}}_{\\mathrm{eq}} = \\mathbf{n} \\oslash \\mathbf{d}$.\n\nThis procedure is applied to each of the specified test cases.\n-   **Test Case A** verifies the fundamental property that a nonlocal operator should preserve a constant field. The deviation from the constant value should be on the order of machine precision.\n-   **Test Case B** demonstrates the primary function of the nonlocal operator: smoothing a sharp discontinuity (a top-hat function). The value at the center of the hat will be less than the local peak value due to averaging with the surrounding zero-strain regions.\n-   **Test Case C** examines the limit where the internal length $\\ell$ is large compared to the domain size $L$. In this limit, the exponential kernel $\\alpha(r)$ becomes nearly constant over the domain, and the nonlocal average should converge to the simple spatial mean of the local field, calculated as $\\varepsilon_{\\mathrm{mean}} = \\frac{1}{L}\\int_0^L \\varepsilon_{\\mathrm{eq}}(x) \\mathrm{d}x$.\n-   **Test Case D** examines the opposite limit where the internal length $\\ell$ is small, on the order of the grid spacing $h$. The kernel becomes highly peaked, approximating a Dirac delta function, and the nonlocal value should converge to the local value.\n-   **Test Case E** is designed to probe boundary effects. For a point $x_j$ near a boundary (e.g., $x_1=0$), the integral is truncated. For a non-constant field like the linear gradient $\\varepsilon_{\\mathrm{eq}}(x) = x/L$, this truncation will cause the nonlocal average to differ significantly from the local value. Specifically at $x=0$, the average only includes contributions from $\\xi \\ge 0$, resulting in a positive value even though the local strain is $\\varepsilon_{\\mathrm{eq}}(0)=0$.\n\nThe algorithm is implemented in a Python script using the NumPy library for efficient array operations, following the vectorized strategy outlined above. Each test case is executed sequentially, and the results are collected and formatted as specified.",
            "answer": "```python\nimport numpy as np\n\ndef compute_nonlocal_average(L, N, ell, local_eps_func):\n    \"\"\"\n    Computes the discrete nonlocal average for a 1D bar.\n\n    Args:\n        L (float): Length of the bar.\n        N (int): Number of discretization nodes.\n        ell (float): Internal length scale.\n        local_eps_func (callable): A function that takes a numpy array of node\n                                   positions `x` and returns the local strain field.\n\n    Returns:\n        tuple: A tuple containing:\n            - x_nodes (np.ndarray): The positions of the domain nodes.\n            - eps_nonlocal (np.ndarray): The computed nonlocal equivalent strain at each node.\n    \"\"\"\n    # 1. Discretize the domain and define grid spacing\n    x_nodes = np.linspace(0, L, N)\n    if N > 1:\n        h = L / (N - 1)\n    else:\n        h = 0.0 # Handle case N=1\n\n    # 2. Define trapezoidal integration weights\n    w_weights = np.full(N, h)\n    if N > 1:\n        w_weights[0] = h / 2.0\n        w_weights[-1] = h / 2.0\n\n    # 3. Evaluate the local strain field at the nodes\n    eps_local = local_eps_func(x_nodes)\n\n    # 4. Construct the kernel matrix from distances\n    # Use broadcasting to create the distance matrix |x_j - x_i| for all j, i\n    dist_matrix = np.abs(x_nodes[:, np.newaxis] - x_nodes)\n    alpha_matrix = np.exp(-dist_matrix / ell)\n\n    # 5. Compute the nonlocal average using vectorized operations\n    # Numerator: sum_i(alpha_ji * eps_i * w_i) for each j\n    numerator = alpha_matrix @ (eps_local * w_weights)\n    \n    # Denominator: sum_i(alpha_ji * w_i) for each j\n    denominator = alpha_matrix @ w_weights\n\n    # Element-wise division to get the nonlocal strain at each node\n    # Add a small epsilon to the denominator to prevent division by zero in pathological cases,\n    # though not strictly necessary for an exponential kernel over a non-zero domain.\n    eps_nonlocal = numerator / (denominator + 1e-18)\n    \n    return x_nodes, eps_nonlocal\n\ndef solve():\n    \"\"\"\n    Runs all test cases and prints the results in the required format.\n    \"\"\"\n    results = []\n\n    # Test Case A: Uniform invariance\n    L_A, N_A, ell_A = 1.0, 101, 0.05\n    local_eps_A = lambda x: np.full_like(x, 0.01)\n    _, eps_nonlocal_A = compute_nonlocal_average(L_A, N_A, ell_A, local_eps_A)\n    result_A = np.max(np.abs(eps_nonlocal_A - 0.01))\n    results.append(result_A)\n\n    # Test Case B: Localized top-hat, center value\n    L_B, N_B, ell_B = 1.0, 1001, 0.1\n    # Use a small tolerance for floating point comparisons at boundaries\n    local_eps_B = lambda x: 0.02 * ((x >= 0.4 - 1e-9) & (x <= 0.6 + 1e-9))\n    x_nodes_B, eps_nonlocal_B = compute_nonlocal_average(L_B, N_B, ell_B, local_eps_B)\n    center_index_B = (N_B - 1) // 2 # N is odd, index corresponds to x=0.5\n    result_B = eps_nonlocal_B[center_index_B]\n    results.append(result_B)\n\n    # Test Case C: Large internal length, approach to mean\n    L_C, N_C, ell_C = 1.0, 1001, 1.0\n    local_eps_C = local_eps_B  # Same local field as B\n    x_nodes_C, eps_nonlocal_C = compute_nonlocal_average(L_C, N_C, ell_C, local_eps_C)\n    center_index_C = (N_C - 1) // 2\n    theoretical_mean = 0.004\n    result_C = np.abs(eps_nonlocal_C[center_index_C] - theoretical_mean)\n    results.append(result_C)\n\n    # Test Case D: Near-local limit at center\n    L_D, N_D = 1.0, 1001\n    h_D = L_D / (N_D - 1)\n    ell_D = h_D\n    local_eps_D = local_eps_B  # Same local field as B\n    x_nodes_D, eps_nonlocal_D = compute_nonlocal_average(L_D, N_D, ell_D, local_eps_D)\n    center_index_D = (N_D - 1) // 2\n    local_center_value_D = 0.02\n    result_D = np.abs(eps_nonlocal_D[center_index_D] - local_center_value_D)\n    results.append(result_D)\n\n    # Test Case E: Boundary effect for a gradient\n    L_E, N_E, ell_E = 1.0, 201, 0.1\n    local_eps_E = lambda x: x / L_E\n    x_nodes_E, eps_nonlocal_E = compute_nonlocal_average(L_E, N_E, ell_E, local_eps_E)\n    result_E = eps_nonlocal_E[0]  # Value at the left boundary, x=0\n    results.append(result_E)\n\n    # Format and print the final output\n    print(f\"[{','.join(f'{r:.15g}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A robust numerical implementation requires not just correctness but also a clear understanding of its accuracy. This exercise focuses on a cornerstone of computational science: the convergence analysis. You will investigate how the error of your discrete nonlocal operator decreases as the mesh is refined, confirming that the numerical solution properly approaches the true continuous result .",
            "id": "3546150",
            "problem": "Consider a one-dimensional bar occupying the interval $\\Omega = [0,L]$ with $L > 0$ measured in meters. Let the equivalent strain field be a localized, nonuniform, deterministic function $\\varepsilon(\\xi)$ defined for $\\xi \\in \\Omega$ by\n$$\n\\varepsilon(\\xi) = \\varepsilon_0 \\exp\\!\\left(-\\frac{|\\xi - x_0|}{\\beta}\\right),\n$$\nwhere $\\varepsilon_0 > 0$ is a dimensionless peak strain, $x_0 \\in (0,L)$ is the band center in meters, and $\\beta > 0$ is a localization width in meters. To regularize strain localization in Computational Geomechanics, the nonlocal integral average $\\bar{\\varepsilon}(x)$ at a point $x \\in \\Omega$ is defined as the truncated, renormalized convolution\n$$\n\\bar{\\varepsilon}(x) = \\frac{\\displaystyle \\int_{0}^{L} \\alpha(x,\\xi)\\,\\varepsilon(\\xi)\\,d\\xi}{\\displaystyle \\int_{0}^{L} \\alpha(x,\\xi)\\,d\\xi},\n$$\nwhere $\\alpha(x,\\xi)$ is a nonnegative weight function (kernel), and the denominator enforces exact normalization on the truncated domain. Use a Gaussian kernel with characteristic length $\\ell > 0$,\n$$\n\\alpha(x,\\xi) = \\exp\\!\\left(-\\frac{(x-\\xi)^2}{2\\ell^2}\\right),\n$$\nwhere $\\ell$ is in meters. The strain $\\varepsilon(\\xi)$ is dimensionless, hence $\\bar{\\varepsilon}(x)$ is dimensionless.\n\nYou are to study convergence under mesh refinement of the discrete nonlocal operator that approximates the above integrals by uniform Riemann sums based on a one-dimensional mesh of $N$ equal elements (with $N \\in \\mathbb{N}$). Specifically, define the discrete approximation on a mesh with spacing $h = L/N$ and element centers $\\xi_i = (i+\\tfrac{1}{2})h$ for $i = 0,1,\\dots,N-1$:\n$$\n\\bar{\\varepsilon}_N(x) = \\frac{\\displaystyle \\sum_{i=0}^{N-1} \\alpha(x,\\xi_i)\\,\\varepsilon(\\xi_i)\\,h}{\\displaystyle \\sum_{i=0}^{N-1} \\alpha(x,\\xi_i)\\,h}.\n$$\nTreat the above as the composite midpoint rule applied to both numerator and denominator. For a reference (baseline) value at the same evaluation point $x$, compute $\\bar{\\varepsilon}_{N_{\\mathrm{ref}}}(x)$ using the same discrete formula with a very fine mesh of $N_{\\mathrm{ref}}$ elements. Define the absolute discretization error\n$$\ne_N(x) = \\big|\\bar{\\varepsilon}_N(x) - \\bar{\\varepsilon}_{N_{\\mathrm{ref}}}(x)\\big|.\n$$\n\nStarting from the core definitions of nonlocal averaging and numerical quadrature (Riemann sums), implement a program that, for each test case below, computes the absolute error $e_N(x)$ using the specified parameters. All strains are dimensionless, so $e_N(x)$ must be reported as a dimensionless decimal number.\n\nUse the following fixed parameters for all test cases:\n- $L = 1.0$ meters,\n- $\\varepsilon_0 = 0.02$,\n- $x_0 = 0.5$ meters,\n- $\\beta = 0.01$ meters,\n- $N_{\\mathrm{ref}} = 100000$.\n\nThe test suite consists of the following six cases, each given as a tuple $(\\ell, N, x)$ with $\\ell$ in meters, $N$ an integer number of elements, and $x$ in meters:\n1. $(0.05, 20, 0.5)$ interior evaluation with moderate kernel and coarse mesh,\n2. $(0.05, 40, 0.5)$ interior evaluation with moderate kernel and refined mesh,\n3. $(0.05, 20, 0.02)$ near-boundary evaluation to test renormalization,\n4. $(0.005, 20, 0.5)$ small characteristic length poorly resolved by the mesh,\n5. $(0.005, 400, 0.5)$ small characteristic length well resolved by refinement,\n6. $(0.05, 40, 0.8)$ evaluation away from the localization center.\n\nYour program must:\n- Implement the nonlocal average as stated, using the composite midpoint rule on uniform partitions for both the coarse mesh with $N$ elements and the reference mesh with $N_{\\mathrm{ref}}$ elements,\n- Compute $e_N(x)$ for each test case,\n- Produce a single line of output containing the six results as a comma-separated list enclosed in square brackets, in the order of the test cases above. Each result must be a decimal number (floating point). For example, a valid output format is like $[r_1,r_2,r_3,r_4,r_5,r_6]$.\n\nAngles are not involved. No physical units appear in the final numerical outputs because strain is dimensionless and the error $e_N(x)$ is dimensionless. The values must be computed as specified with no additional scaling. The final output line must match the exact required format.",
            "solution": "The problem is well-posed and scientifically sound, asking for the implementation and evaluation of a numerical method used in computational mechanics for strain localization. I will proceed with the solution.\n\nThe problem requires the computation of the discretization error for a numerical approximation of a nonlocal integral operator. This operator is used in computational geomechanics to regularize solutions that exhibit strain localization, a phenomenon where deformation concentrates in a narrow band. The nonlocal formulation replaces a local quantity (strain) at a point with a weighted average of that quantity over a finite neighborhood, which mathematically corresponds to a convolution integral.\n\nFirst, let us define the fundamental quantities. The local, one-dimensional equivalent strain field $\\varepsilon(\\xi)$ is given by\n$$\n\\varepsilon(\\xi) = \\varepsilon_0 \\exp\\!\\left(-\\frac{|\\xi - x_0|}{\\beta}\\right)\n$$\nfor $\\xi$ in the domain $\\Omega = [0, L]$. Here, $\\varepsilon_0 = 0.02$ is the dimensionless peak strain, $x_0 = 0.5$ m is the center of the localization band, and $\\beta = 0.01$ m is the characteristic width of this band. The domain length is $L=1.0$ m.\n\nThe nonlocal average strain $\\bar{\\varepsilon}(x)$ at a point $x \\in \\Omega$ is defined by a renormalized convolution:\n$$\n\\bar{\\varepsilon}(x) = \\frac{\\displaystyle \\int_{0}^{L} \\alpha(x,\\xi)\\,\\varepsilon(\\xi)\\,d\\xi}{\\displaystyle \\int_{0}^{L} \\alpha(x,\\xi)\\,d\\xi}\n$$\nThe weight function $\\alpha(x,\\xi)$ is a Gaussian kernel with characteristic length $\\ell$:\n$$\n\\alpha(x,\\xi) = \\exp\\!\\left(-\\frac{(x-\\xi)^2}{2\\ell^2}\\right)\n$$\nThe denominator in the expression for $\\bar{\\varepsilon}(x)$ is a normalization factor. It ensures that the averaging property is maintained despite the integral being truncated to the finite domain $[0, L]$. This is particularly important when the evaluation point $x$ is close to a boundary, where a significant portion of the Gaussian kernel's support might lie outside the domain.\n\nThe problem requires us to approximate these integrals using the composite midpoint rule. For a mesh of $N$ uniform elements, the domain $[0, L]$ is partitioned into $N$ subintervals, each of width $h = L/N$. The midpoint of the $i$-th element (for $i=0, \\dots, N-1$) is $\\xi_i = (i+\\frac{1}{2})h$. The integral of a generic function $f(\\xi)$ is then approximated as:\n$$\n\\int_0^L f(\\xi) d\\xi \\approx \\sum_{i=0}^{N-1} f(\\xi_i) h\n$$\nApplying this numerical quadrature rule to both the numerator and the denominator of the expression for $\\bar{\\varepsilon}(x)$ gives the discrete nonlocal average $\\bar{\\varepsilon}_N(x)$:\n$$\n\\bar{\\varepsilon}_N(x) = \\frac{\\displaystyle \\sum_{i=0}^{N-1} \\alpha(x,\\xi_i)\\,\\varepsilon(\\xi_i)\\,h}{\\displaystyle \\sum_{i=0}^{N-1} \\alpha(x,\\xi_i)\\,h}\n$$\nThe mesh spacing $h$ is a constant factor in both the numerator and denominator sums, so it can be canceled out. This simplifies the discrete formula to a weighted average of the strain values evaluated at the element centers:\n$$\n\\bar{\\varepsilon}_N(x) = \\frac{\\displaystyle \\sum_{i=0}^{N-1} \\alpha(x,\\xi_i)\\,\\varepsilon(\\xi_i)}{\\displaystyle \\sum_{i=0}^{N-1} \\alpha(x,\\xi_i)}\n$$\nThe core of the task is to implement a function based on this formula. This function will take the mesh size $N$ and the physical parameters $(\\ell, x)$ as input and return the value of $\\bar{\\varepsilon}_N(x)$.\n\nTo quantify the accuracy of this approximation, we define the absolute discretization error $e_N(x)$. As an analytical solution for $\\bar{\\varepsilon}(x)$ is not readily available, we use a common numerical analysis technique: comparison against a highly refined numerical solution. We compute a reference value $\\bar{\\varepsilon}_{N_{\\mathrm{ref}}}(x)$ using the same discrete formula but with a very large number of elements, $N_{\\mathrm{ref}} = 100000$. This value is assumed to be a close approximation of the true continuous result. The error is then defined as:\n$$\ne_N(x) = \\big|\\bar{\\varepsilon}_N(x) - \\bar{\\varepsilon}_{N_{\\mathrm{ref}}}(x)\\big|\n$$\nThe algorithm to solve the problem for each test case $(\\ell, N, x)$ is as follows:\n1.  Define a function `calculate_nonlocal_average` that implements the formula for $\\bar{\\varepsilon}_N(x)$. This function will:\n    a. Calculate the mesh spacing $h = L/N$.\n    b. Generate an array of $N$ element midpoints $\\xi_i$.\n    c. Evaluate $\\varepsilon(\\xi_i)$ and $\\alpha(x, \\xi_i)$ for all points in the array.\n    d. Compute the numerator sum $\\sum \\alpha(x,\\xi_i)\\,\\varepsilon(\\xi_i)$ and the denominator sum $\\sum \\alpha(x,\\xi_i)$.\n    e. Return the ratio of the two sums.\n2.  For each given test case $(\\ell, N, x)$:\n    a. Call `calculate_nonlocal_average` with the specified $N$ to compute $\\bar{\\varepsilon}_N(x)$.\n    b. Call `calculate_nonlocal_average` with $N_{\\mathrm{ref}}$ to compute the reference value $\\bar{\\varepsilon}_{N_{\\mathrm{ref}}}(x)$.\n    c. Calculate the absolute error $e_N(x)$.\n3.  Collect the errors from all test cases into a list.\n4.  Format and print the list of errors according to the specified output format. This process will be repeated for all six test cases provided.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_nonlocal_average(N, L, x, epsilon_0, x_0, beta, ell):\n    \"\"\"\n    Computes the discrete nonlocal average strain using the composite midpoint rule.\n\n    Args:\n        N (int): Number of elements in the mesh.\n        L (float): Length of the 1D bar.\n        x (float): Evaluation point for the nonlocal average.\n        epsilon_0 (float): Peak strain.\n        x_0 (float): Center of the strain localization band.\n        beta (float): Width of the strain localization band.\n        ell (float): Characteristic length of the Gaussian kernel.\n\n    Returns:\n        float: The calculated discrete nonlocal average strain.\n    \"\"\"\n    # 1. Generate the mesh\n    # Mesh spacing\n    h = L / N\n    # Element centers (midpoints)\n    xi_points = (np.arange(N) + 0.5) * h\n\n    # 2. Evaluate the strain field and the weight function at the mesh points\n    # Local strain field values\n    epsilon_vals = epsilon_0 * np.exp(-np.abs(xi_points - x_0) / beta)\n    \n    # Weight function values\n    alpha_vals = np.exp(-(x - xi_points)**2 / (2 * ell**2))\n\n    # 3. Compute the sums for the numerator and denominator\n    # The term 'h' from the Riemann sum cancels out.\n    numerator = np.sum(alpha_vals * epsilon_vals)\n    denominator = np.sum(alpha_vals)\n\n    # 4. Compute the nonlocal average\n    # The denominator should not be zero for a non-zero domain and Gaussian kernel.\n    # A check is included for numerical robustness.\n    if denominator == 0.0:\n        return 0.0\n\n    return numerator / denominator\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and compute the discretization errors.\n    \"\"\"\n    # Define the fixed parameters from the problem statement.\n    L = 1.0\n    epsilon_0 = 0.02\n    x_0 = 0.5\n    beta = 0.01\n    N_ref = 100000\n\n    # Define the test cases as tuples of (ell, N, x).\n    test_cases = [\n        (0.05, 20, 0.5),    # 1. Interior evaluation, moderate kernel, coarse mesh\n        (0.05, 40, 0.5),    # 2. Interior evaluation, moderate kernel, refined mesh\n        (0.05, 20, 0.02),   # 3. Near-boundary evaluation\n        (0.005, 20, 0.5),   # 4. Small kernel, poorly resolved\n        (0.005, 400, 0.5),  # 5. Small kernel, well resolved\n        (0.05, 40, 0.8),    # 6. Evaluation away from localization center\n    ]\n\n    results = []\n    for ell, N, x in test_cases:\n        # Calculate the approximate value with N elements\n        eps_bar_N = calculate_nonlocal_average(N, L, x, epsilon_0, x_0, beta, ell)\n        \n        # Calculate the reference value with N_ref elements\n        eps_bar_N_ref = calculate_nonlocal_average(N_ref, L, x, epsilon_0, x_0, beta, ell)\n        \n        # Compute the absolute discretization error\n        error = np.abs(eps_bar_N - eps_bar_N_ref)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Moving from numerical verification to physical application, this practice challenges you to use nonlocal regularization to solve a practical problem in geomechanics. You will predict the width of a shear band, a classic localization phenomenon, and compare the performance of the integral model against an alternative regularization technique. This advanced exercise demonstrates how linear stability analysis connects model parameters to physical predictions and introduces the critical engineering task of model selection and validation against observed data and energetic constraints .",
            "id": "3546155",
            "problem": "Consider a one-dimensional representation of a plane strain direct shear test along a spatial coordinate $x \\in \\mathbb{R}$, where the shear strain field is denoted by $\\gamma(x)$. A scalar damage-type constitutive model is used in which the stress response softens with a negative tangent (softening) slope $H<0$ governed by a nonlocal equivalent strain $\\bar{\\gamma}(x)$, while the undamaged shear modulus is $G>0$. Two regularization approaches are considered: an integral nonlocal model and a gradient damage model. The objective is to determine, for given material and loading parameters, which regularization more accurately reproduces an observed shear band width, while controlling for the fracture energy per unit area, the internal length, and the softening slope.\n\nFundamental base and definitions:\n- In the integral nonlocal model, the nonlocal equivalent strain is defined by a normalized convolution\n$$\n\\bar{\\gamma}(x) = \\int_{-\\infty}^{\\infty} w_n(|x-y|)\\,\\gamma(y)\\,\\mathrm{d}y,\n$$\nwhere the normalized Gaussian weight function is\n$$\nw_n(r) = \\frac{\\exp\\!\\left[-(r/\\ell)^2\\right]}{\\int_{-\\infty}^{\\infty}\\exp\\!\\left[-(s/\\ell)^2\\right]\\mathrm{d}s} = \\frac{1}{\\sqrt{\\pi}\\,\\ell}\\,\\exp\\!\\left[-(r/\\ell)^2\\right],\n$$\nand $\\ell>0$ is the internal length scale. The Fourier transform of $w_n(r)$ is\n$$\n\\widehat{w_n}(k) = \\int_{-\\infty}^{\\infty} w_n(r)\\,e^{-i k r}\\,\\mathrm{d}r = \\exp\\!\\left[-\\left(\\frac{k\\,\\ell}{2}\\right)^2\\right],\n$$\nwhere $k \\ge 0$ is the wavenumber of a harmonic perturbation $\\delta\\gamma(x)=A\\,e^{i k x}$.\n\n- In the gradient damage model, the Helmholtz-type nonlocality is given in Fourier space by the relation\n$$\n\\widehat{\\bar{\\gamma}}(k) = \\frac{\\widehat{\\gamma}(k)}{1 + \\ell^2 k^2},\n$$\nwhich is the Fourier symbol of the differential operator $(1 - \\ell^2 \\partial_{xx})^{-1}$ applied to $\\gamma(x)$ under vanishing gradients at infinity.\n\nLinear stability analysis of localization:\n- Consider an infinitesimal harmonic perturbation $\\delta\\gamma(x)=A e^{i k x}$ to a homogeneous base state. The effective incremental shear modulus in softening depends on the nonlocal filtering of $\\delta\\gamma$:\n    - For the integral nonlocal model, the filtered perturbation is $\\delta\\bar{\\gamma} = \\widehat{w_n}(k)\\,\\delta\\gamma$, giving an effective tangent\n    $$\n    G_{\\text{eff,int}}(k) = G + H\\,\\widehat{w_n}(k).\n    $$\n    - For the gradient damage model, the filtered perturbation is $\\delta\\bar{\\gamma} = \\delta\\gamma/(1+\\ell^2 k^2)$, giving an effective tangent\n    $$\n    G_{\\text{eff,grad}}(k) = G + \\frac{H}{1 + \\ell^2 k^2}.\n    $$\n- The onset of localization (loss of ellipticity) is identified when the effective tangent first reaches zero for some $k \\ge 0$.\n    - Integral nonlocal: solve $G + H \\exp\\!\\left[-(k \\ell/2)^2\\right] = 0$ for $k$, which yields, provided $|H| \\ge G$,\n    $$\n    \\exp\\!\\left[-\\left(\\frac{k\\,\\ell}{2}\\right)^2\\right] = \\frac{G}{|H|} \\quad \\Rightarrow \\quad k_{\\text{int}} = \\frac{2}{\\ell}\\,\\sqrt{-\\ln\\!\\left(\\frac{G}{|H|}\\right)}.\n    $$\n    If $|H|<G$, no real solution exists and localization is not predicted. If $|H|=G$, then $k_{\\text{int}}=0$ and the predicted width is infinite.\n    - Gradient damage: solve $G + H/(1+\\ell^2 k^2) = 0$ for $k$, which yields, provided $|H| \\ge G$,\n    $$\n    1 + \\ell^2 k^2 = \\frac{|H|}{G} \\quad \\Rightarrow \\quad k_{\\text{grad}} = \\frac{1}{\\ell}\\,\\sqrt{\\frac{|H|}{G}-1}.\n    $$\n    If $|H|<G$, no real solution exists; if $|H|=G$, then $k_{\\text{grad}}=0$ and the predicted width is infinite.\n\nDefinition of shear band width:\n- For a dominant sinusoidal localization mode of wavenumber $k$, define the shear band width as the half-wavelength\n$$\nw = \\frac{\\pi}{k}.\n$$\nThus $w_{\\text{int}} = \\pi/k_{\\text{int}}$ and $w_{\\text{grad}} = \\pi/k_{\\text{grad}}$, with $w=\\infty$ when $k=0$ and $w$ not defined when no real $k$ exists.\n\nFracture energy consistency:\n- For linear softening of shear stress from peak shear strength $\\tau_p>0$ to zero with constant negative slope $H<0$ as a function of the nonlocal equivalent strain, the local energy dissipated per unit volume is\n$$\ng_{\\text{loc}} = \\frac{1}{2}\\,\\tau_p\\,\\Delta\\gamma = \\frac{1}{2}\\,\\frac{\\tau_p^2}{|H|},\n$$\nwhere $\\Delta\\gamma = \\tau_p/|H|$. Assuming a unit thickness in the out-of-plane direction, the fracture energy per unit area implied by a band of width $w$ is\n$$\nG_{f,\\text{pred}} = g_{\\text{loc}}\\,w = \\frac{1}{2}\\,\\frac{\\tau_p^2}{|H|}\\,w.\n$$\nGiven an observed fracture energy $G_f>0$, one may assess the consistency of a predicted width $w$ via the relative error in $G_{f,\\text{pred}}$.\n\nTask:\n- For each test case, given the parameters $(G, H, \\ell, \\tau_p, G_f, w_{\\text{obs}})$, compute $w_{\\text{int}}$ and $w_{\\text{grad}}$ using the formulas above. If $|H|<G$, treat the corresponding width as not-a-number. If $|H|=G$, set the width to infinity.\n- For each model, compute the relative width error $e_w = \\left| \\frac{w_{\\text{model}}}{w_{\\text{obs}}} - 1 \\right|$ and the fracture energy relative error $e_g = \\left| \\frac{G_{f,\\text{pred}}}{G_f} - 1 \\right|$, where $G_{f,\\text{pred}} = \\frac{1}{2}\\,\\frac{\\tau_p^2}{|H|}\\,w_{\\text{model}}$.\n- Define the combined error $E = e_w + e_g$.\n- Decision rule per test case:\n    - If both models predict no localization or infinite width, return $-1$.\n    - If only one model yields a finite width, select that model.\n    - Otherwise, select the model with the smaller combined error $E$. Return $0$ for the integral nonlocal model and $1$ for the gradient damage model.\n\nPhysical units:\n- Use Pascals for stresses ($\\tau_p$ and $G$, in $\\mathrm{Pa}$), meters for lengths ($\\ell$ and $w_{\\text{obs}}$, in $\\mathrm{m}$), and Joules per square meter for fracture energy ($G_f$, in $\\mathrm{J}/\\mathrm{m}^2$).\n\nTest suite:\n- Case $1$: $G=1.0\\times 10^{10}\\,\\mathrm{Pa}$, $H=-2.0\\times 10^{10}\\,\\mathrm{Pa}$, $\\ell=0.01\\,\\mathrm{m}$, $\\tau_p=5.0\\times 10^{7}\\,\\mathrm{Pa}$, $G_f=5000\\,\\mathrm{J}/\\mathrm{m}^2$, $w_{\\text{obs}}=0.025\\,\\mathrm{m}$.\n- Case $2$ (threshold): $G=1.0\\times 10^{10}\\,\\mathrm{Pa}$, $H=-1.0\\times 10^{10}\\,\\mathrm{Pa}$, $\\ell=0.02\\,\\mathrm{m}$, $\\tau_p=6.0\\times 10^{7}\\,\\mathrm{Pa}$, $G_f=4000\\,\\mathrm{J}/\\mathrm{m}^2$, $w_{\\text{obs}}=0.03\\,\\mathrm{m}$.\n- Case $3$ (no localization): $G=1.5\\times 10^{10}\\,\\mathrm{Pa}$, $H=-7.5\\times 10^{9}\\,\\mathrm{Pa}$, $\\ell=0.015\\,\\mathrm{m}$, $\\tau_p=4.0\\times 10^{7}\\,\\mathrm{Pa}$, $G_f=3000\\,\\mathrm{J}/\\mathrm{m}^2$, $w_{\\text{obs}}=0.02\\,\\mathrm{m}$.\n- Case $4$ (strong softening, small width): $G=1.0\\times 10^{10}\\,\\mathrm{Pa}$, $H=-5.0\\times 10^{10}\\,\\mathrm{Pa}$, $\\ell=0.005\\,\\mathrm{m}$, $\\tau_p=8.0\\times 10^{7}\\,\\mathrm{Pa}$, $G_f=8000\\,\\mathrm{J}/\\mathrm{m}^2$, $w_{\\text{obs}}=0.01\\,\\mathrm{m}$.\n- Case $5$ (small internal length): $G=1.0\\times 10^{10}\\,\\mathrm{Pa}$, $H=-3.0\\times 10^{10}\\,\\mathrm{Pa}$, $\\ell=0.002\\,\\mathrm{m}$, $\\tau_p=7.0\\times 10^{7}\\,\\mathrm{Pa}$, $G_f=6000\\,\\mathrm{J}/\\mathrm{m}^2$, $w_{\\text{obs}}=0.006\\,\\mathrm{m}$.\n- Case $6$ (consistency favoring integral): $G=1.0\\times 10^{10}\\,\\mathrm{Pa}$, $H=-2.0\\times 10^{10}\\,\\mathrm{Pa}$, $\\ell=0.01\\,\\mathrm{m}$, $\\tau_p=5.0\\times 10^{7}\\,\\mathrm{Pa}$, $G_f=1200\\,\\mathrm{J}/\\mathrm{m}^2$, $w_{\\text{obs}}=0.0189\\,\\mathrm{m}$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list of integers enclosed in square brackets, in the same order as the test suite (for example, $[0,1,-1,1,0,1]$).",
            "solution": "The user-provided problem is assessed as valid. It is scientifically grounded in the principles of continuum damage mechanics and strain localization, specifically using nonlocal regularization techniques. All definitions, models, and parameters are provided, rendering the problem self-contained and well-posed. The task is an objective, quantitative comparison between two standard models based on clear, mathematical criteria. The provided physical parameters are realistic for applications in geomechanics.\n\nThe solution proceeds by implementing the specified calculation for each test case. The overall procedure for a single test case with parameters $(G, H, \\ell, \\tau_p, G_f, w_{\\text{obs}})$ is as follows:\n\n1.  **Check for Localization**: The first step is to evaluate the condition for the onset of localization, which is $|H| \\ge G$. The parameters $G$ and $H$ are the elastic shear modulus and the softening modulus, respectively.\n    *   If $|H| < G$, strain localization does not occur in either model. The characteristic wavenumber $k$ is not a real number, and thus the shear band width $w$ is undefined. In the implementation, this is represented by not-a-number ($NaN$).\n    *   If $|H| = G$, this is the bifurcation threshold. The analysis yields a characteristic wavenumber $k=0$ for both models, corresponding to an infinite shear band width, $w = \\infty$.\n    *   If $|H| > G$, localization occurs with a finite, non-zero wavenumber $k > 0$, resulting in a finite shear band width $w$.\n\n2.  **Calculate Predicted Shear Band Widths**: If localization with a finite width is predicted ($|H| > G$), the shear band widths for the integral nonlocal model ($w_{\\text{int}}$) and the gradient damage model ($w_{\\text{grad}}$) are computed.\n    *   The wavenumber for the integral model is given by\n        $$\n        k_{\\text{int}} = \\frac{2}{\\ell}\\,\\sqrt{-\\ln\\!\\left(\\frac{G}{|H|}\\right)}\n        $$\n        And the corresponding width is $w_{\\text{int}} = \\pi/k_{\\text{int}}$.\n    *   The wavenumber for the gradient model is given by\n        $$\n        k_{\\text{grad}} = \\frac{1}{\\ell}\\,\\sqrt{\\frac{|H|}{G}-1}\n        $$\n        And the corresponding width is $w_{\\text{grad}} = \\pi/k_{\\text{grad}}$.\n\n3.  **Evaluate Model Performance**: For each model that yields a finite, positive width, two error metrics are computed: the relative width error ($e_w$) and the relative fracture energy error ($e_g$).\n    *   The relative width error measures the deviation of the predicted width $w_{\\text{model}}$ from the observed width $w_{\\text{obs}}$:\n        $$\n        e_w = \\left| \\frac{w_{\\text{model}}}{w_{\\text{obs}}} - 1 \\right|\n        $$\n    *   The fracture energy error compares the model-predicted fracture energy $G_{f,\\text{pred}}$ to the observed fracture energy $G_f$. The predicted fracture energy is calculated by integrating the local energy dissipated per unit volume, $g_{\\text{loc}}$, over the band width $w_{\\text{model}}$:\n        $$\n        G_{f,\\text{pred}} = g_{\\text{loc}} \\cdot w_{\\text{model}} = \\left(\\frac{1}{2}\\,\\frac{\\tau_p^2}{|H|}\\right) w_{\\text{model}}\n        $$\n        The relative error is then:\n        $$\n        e_g = \\left| \\frac{G_{f,\\text{pred}}}{G_f} - 1 \\right|\n        $$\n    *   A combined error metric, $E$, is defined as the sum of these two errors:\n        $$\n        E = e_w + e_g\n        $$\n\n4.  **Apply Decision Rule**: A final decision is made based on the computed widths and errors for each test case.\n    *   If both models predict an undefined ($NaN$) or infinite width, the result is $-1$.\n    *   If only one model predicts a finite, positive width, that model is chosen. A result of $0$ indicates the integral model, and $1$ indicates the gradient model.\n    *   If both models predict finite, positive widths, the model with the lower combined error $E$ is selected. The return value is again $0$ for the integral model or $1$ for the gradient model.\n\nThis procedure is applied to each of the six test cases provided, and the results are compiled into a final list.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_case(G, H, l, tau_p, G_f, w_obs):\n    \"\"\"\n    Solves a single test case for the nonlocal regularization problem.\n\n    Args:\n        G (float): Shear modulus (Pa).\n        H (float): Softening slope (Pa).\n        l (float): Internal length (m).\n        tau_p (float): Peak shear strength (Pa).\n        G_f (float): Observed fracture energy (J/m^2).\n        w_obs (float): Observed shear band width (m).\n\n    Returns:\n        int: -1 for no unique finite solution, 0 for integral model, 1 for gradient model.\n    \"\"\"\n    abs_H = np.abs(H)\n\n    # Initialize widths to NaN (Not a Number)\n    w_int = np.nan\n    w_grad = np.nan\n\n    # Check localization condition: |H| must be >= G\n    if abs_H < G:\n        # No localization predicted by either model\n        w_int = np.nan\n        w_grad = np.nan\n    elif abs_H == G:\n        # Bifurcation threshold, infinite wavelength/width\n        w_int = np.inf\n        w_grad = np.inf\n    else: # abs_H > G, finite width localization\n        # Integral model\n        ratio_int = G / abs_H\n        k_int = (2 / l) * np.sqrt(-np.log(ratio_int))\n        if k_int > 0:\n            w_int = np.pi / k_int\n        else: # Should not happen if abs_H > G\n            w_int = np.inf\n\n        # Gradient model\n        ratio_grad = abs_H / G\n        k_grad = (1 / l) * np.sqrt(ratio_grad - 1)\n        if k_grad > 0:\n            w_grad = np.pi / k_grad\n        else: # Should not happen if abs_H > G\n            w_grad = np.inf\n\n    # Check validity of predicted widths\n    is_int_valid = np.isfinite(w_int) and w_int > 0\n    is_grad_valid = np.isfinite(w_grad) and w_grad > 0\n\n    # Apply decision rules\n    if not is_int_valid and not is_grad_valid:\n        return -1\n    elif is_int_valid and not is_grad_valid:\n        return 0\n    elif not is_int_valid and is_grad_valid:\n        return 1\n    else: # Both are valid, compare combined error E\n        # Local energy dissipation per unit volume\n        g_loc = 0.5 * (tau_p**2) / abs_H\n\n        # Errors for integral model\n        G_f_pred_int = g_loc * w_int\n        e_w_int = np.abs(w_int / w_obs - 1)\n        e_g_int = np.abs(G_f_pred_int / G_f - 1)\n        E_int = e_w_int + e_g_int\n\n        # Errors for gradient model\n        G_f_pred_grad = g_loc * w_grad\n        e_w_grad = np.abs(w_grad / w_obs - 1)\n        e_g_grad = np.abs(G_f_pred_grad / G_f - 1)\n        E_grad = e_w_grad + e_g_grad\n        \n        return 0 if E_int < E_grad else 1\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # (G, H, l, tau_p, G_f, w_obs)\n    test_cases = [\n        (1.0e10, -2.0e10, 0.01, 5.0e7, 5000, 0.025),\n        (1.0e10, -1.0e10, 0.02, 6.0e7, 4000, 0.03),\n        (1.5e10, -7.5e9, 0.015, 4.0e7, 3000, 0.02),\n        (1.0e10, -5.0e10, 0.005, 8.0e7, 8000, 0.01),\n        (1.0e10, -3.0e10, 0.002, 7.0e7, 6000, 0.006),\n        (1.0e10, -2.0e10, 0.01, 5.0e7, 1200, 0.0189),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_case(*case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}