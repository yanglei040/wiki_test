{
    "hands_on_practices": [
        {
            "introduction": "To truly understand the penalty method, we must first implement it in its simplest form. This initial practice guides you through the process for a one-dimensional elastic bar, a foundational scenario in mechanics. By coding the solution for a single finite element making contact under gravity and prescribed displacement, you will master the core logic of the active-set strategy and the algebraic manipulation required to enforce penalty constraints .",
            "id": "3549068",
            "problem": "Consider a quasi-static, one-dimensional vertical elastic bar modeled by a single two-node linear Finite Element Method (FEM) element. The bar has length $L$, cross-sectional area $A$, elastic modulus $E$, and mass density $\\rho$. The bar is oriented so that displacement $u$ is measured downward (positive in the downward direction). The top node displacement $u_2$ is prescribed along a monotone load path (a sequence of settlements) $\\{s_j\\}$, with $u_2 = s_j$ at load step $j$. Gravity acts downward with gravitational acceleration $g_{\\mathrm{acc}}$, producing a uniform body force per unit length $w = \\rho A g_{\\mathrm{acc}}$; the consistent nodal load vector for the two-node linear element is $(wL/2)[1;1]$.\n\nThe bottom node may come into unilateral frictionless contact with a rigid horizontal obstacle positioned at an initial downward gap $g_0$ below the bottom node. Let the gap function be $g(u_1) = g_0 - u_1$, where $u_1$ is the bottom node displacement. The unilateral contact constraints are $g(u_1) \\ge 0$, contact pressure $p \\ge 0$, and complementarity $p \\, g(u_1) = 0$. Using the penalty method, approximate the contact by introducing a penalty parameter $\\epsilon > 0$ and defining the contact reaction at the bottom node as $p_\\epsilon(u_1) = \\epsilon \\langle u_1 - g_0 \\rangle$, where $\\langle x \\rangle = \\max(x, 0)$ denotes the Macaulay bracket. The reaction acts upward at the bottom node.\n\nThe internal elastic force is governed by linear elasticity. For the two-node bar, the stiffness matrix is $$ K = \\frac{EA}{L}\\begin{bmatrix}1 & -1 \\\\ -1 & 1\\end{bmatrix} $$. The quasi-static equilibrium at each load step is obtained by requiring stationarity of the total potential energy or, equivalently, solving the residual equations for displacements $u = [u_1, u_2]^\\top$ subject to the Dirichlet boundary condition $u_2 = s_j$ and the penalty-regularized contact reaction at node $1$. No inertial effects are present, and there is no damping.\n\nYour task is to implement a program that, for each specified test case, marches through the given load path $\\{s_j\\}$ and computes the final-step contact reaction $p_\\epsilon$ at the bottom node. The program must correctly enforce the unilateral constraint via the penalty method and obtain the quasi-static equilibrium at each step using a mathematically sound algorithm that respects the complementarity structure through the penalty regularization. The computation must reflect the combined effects of gravity and the prescribed top settlement.\n\nExpress all outputs in Newtons ($\\mathrm{N}$). The final output for each test case is a single floating-point number equal to the contact reaction $p_\\epsilon$ at the final load step. Your program should produce a single line of output containing the results for all test cases as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,r_3,r_4]$).\n\nUse the following test suite, which exercises different regimes and edge conditions:\n\nTest Case $1$ (happy path with activation):\n- $E = 25 \\times 10^9$ $\\mathrm{Pa}$, $A = 0.05$ $\\mathrm{m}^2$, $L = 2$ $\\mathrm{m}$, $\\rho = 2000$ $\\mathrm{kg/m}^3$, $g_{\\mathrm{acc}} = 9.81$ $\\mathrm{m/s}^2$, $g_0 = 0.01$ $\\mathrm{m}$, $\\epsilon = 1 \\times 10^9$ $\\mathrm{N/m}$, load path $\\{s_j\\} = [0.0, 0.006, 0.010, 0.013]$ $\\mathrm{m}$.\n\nTest Case $2$ (boundary consistency at first activation threshold):\n- $E = 25 \\times 10^9$ $\\mathrm{Pa}$, $A = 0.05$ $\\mathrm{m}^2$, $L = 2$ $\\mathrm{m}$, $\\rho = 2000$ $\\mathrm{kg/m}^3$, $g_{\\mathrm{acc}} = 9.81$ $\\mathrm{m/s}^2$, $g_0 = 0.01$ $\\mathrm{m}$, $\\epsilon = 1 \\times 10^9$ $\\mathrm{N/m}$, load path $\\{s_j\\} = [s^\\star]$ $\\mathrm{m}$, where $s^\\star = g_0 - \\dfrac{(\\rho A g_{\\mathrm{acc}})L}{2} \\dfrac{1}{EA/L}$.\n\nTest Case $3$ (soft penalty with activation):\n- $E = 25 \\times 10^9$ $\\mathrm{Pa}$, $A = 0.05$ $\\mathrm{m}^2$, $L = 2$ $\\mathrm{m}$, $\\rho = 2000$ $\\mathrm{kg/m}^3$, $g_{\\mathrm{acc}} = 9.81$ $\\mathrm{m/s}^2$, $g_0 = 0.01$ $\\mathrm{m}$, $\\epsilon = 1 \\times 10^5$ $\\mathrm{N/m}$, load path $\\{s_j\\} = [0.0, 0.010, 0.020]$ $\\mathrm{m}$.\n\nTest Case $4$ (no activation due to large gap):\n- $E = 25 \\times 10^9$ $\\mathrm{Pa}$, $A = 0.05$ $\\mathrm{m}^2$, $L = 2$ $\\mathrm{m}$, $\\rho = 2000$ $\\mathrm{kg/m}^3$, $g_{\\mathrm{acc}} = 9.81$ $\\mathrm{m/s}^2$, $g_0 = 0.05$ $\\mathrm{m}$, $\\epsilon = 1 \\times 10^9$ $\\mathrm{N/m}$, load path $\\{s_j\\} = [0.0, 0.010, 0.020]$ $\\mathrm{m}$.\n\nThe program must:\n- Implement the penalty method for the unilateral contact at the bottom node as specified.\n- For each load step $s_j$ in a test case, solve for the bottom node displacement $u_1$ at quasi-static equilibrium using only fundamental definitions and well-tested formulas, without assuming any shortcut formulas.\n- After completing all steps in a test case, output the final contact reaction $p_\\epsilon$ at the bottom node in $\\mathrm{N}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The outputs correspond to Test Case $1$, Test Case $2$, Test Case $3$, and Test Case $4$, in that order.",
            "solution": "The problem requires the calculation of the contact reaction force at the final step of a prescribed displacement path for a one-dimensional elastic bar. The bar is modeled using a single two-node finite element, and a unilateral contact constraint is regularized using the penalty method. The analysis is quasi-static, meaning inertial effects are ignored, and each load step is solved as an independent static equilibrium problem.\n\nThe governing system of equations for the two-node bar element is derived from the principle of virtual work or by enforcing nodal force equilibrium. The system relates the nodal displacements $\\boldsymbol{u} = [u_1, u_2]^\\top$ to the nodal forces:\n$$\n\\boldsymbol{F}_{\\text{int}} = \\boldsymbol{F}_{\\text{ext}}\n$$\nwhere $\\boldsymbol{F}_{\\text{int}}$ is the vector of internal elastic forces and $\\boldsymbol{F}_{\\text{ext}}$ is the vector of external applied forces.\n\nThe internal force vector is given by $\\boldsymbol{F}_{\\text{int}} = \\boldsymbol{K} \\boldsymbol{u}$, where $\\boldsymbol{K}$ is the element stiffness matrix. The problem provides $\\boldsymbol{K}$:\n$$\n\\boldsymbol{K} = \\frac{EA}{L} \\begin{bmatrix} 1 & -1 \\\\ -1 & 1 \\end{bmatrix}\n$$\nLet's define the axial stiffness as $k = \\frac{EA}{L}$. Then the matrix becomes $\\boldsymbol{K} = k \\begin{bmatrix} 1 & -1 \\\\ -1 & 1 \\end{bmatrix}$.\n\nThe external force vector $\\boldsymbol{F}_{\\text{ext}}$ is the sum of forces due to gravity and the contact reaction.\n1.  **Gravity Force**: The body force per unit length is $w = \\rho A g_{\\mathrm{acc}}$. For a linear two-node element, the consistent nodal load vector distributes this total weight $wL$ equally to the two nodes. Since the positive displacement direction is downward, the gravity force is positive:\n    $$\n    \\boldsymbol{F}_{\\text{grav}} = \\frac{wL}{2} \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix} = \\frac{\\rho A g_{\\mathrm{acc}} L}{2} \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix}\n    $$\n2.  **Contact Force**: The penalty method introduces a reaction force $p_\\epsilon(u_1)$ at the bottom node (node 1) that is a function of its displacement $u_1$. The reaction is defined as $p_\\epsilon(u_1) = \\epsilon \\langle u_1 - g_0 \\rangle$, where $\\langle x \\rangle = \\max(x, 0)$ is the Macaulay bracket, $g_0$ is the initial gap, and $\\epsilon$ is the penalty parameter. The problem states this reaction acts *upward*. Since the positive axis is downward, the force applied to node 1 is negative. No contact occurs at node 2. Thus, the contact force vector is:\n    $$\n    \\boldsymbol{F}_{\\text{contact}} = \\begin{bmatrix} -p_\\epsilon(u_1) \\\\ 0 \\end{bmatrix} = \\begin{bmatrix} -\\epsilon \\langle u_1 - g_0 \\rangle \\\\ 0 \\end{bmatrix}\n    $$\n\nThe full system of equilibrium equations is:\n$$\nk \\begin{bmatrix} 1 & -1 \\\\ -1 & 1 \\end{bmatrix} \\begin{bmatrix} u_1 \\\\ u_2 \\end{bmatrix} = \\frac{\\rho A g_{\\mathrm{acc}} L}{2} \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix} + \\begin{bmatrix} -\\epsilon \\langle u_1 - g_0 \\rangle \\\\ 0 \\end{bmatrix} + \\boldsymbol{F}_{\\text{reac, BC}}\n$$\nThe term $\\boldsymbol{F}_{\\text{reac, BC}}$ represents the reaction force at the prescribed boundary. At any given load step $j$, the displacement of the top node is prescribed: $u_2 = s_j$. This is a Dirichlet boundary condition. We only need to solve for the unknown displacement $u_1$. The second equation in the system would be used to find the reaction force at node 2, which is not required.\n\nLet's expand the first row of the matrix equation:\n$$\nk u_1 - k u_2 = \\frac{\\rho A g_{\\mathrm{acc}} L}{2} - \\epsilon \\langle u_1 - g_0 \\rangle\n$$\nSubstituting the known value $u_2 = s_j$ and letting $F_g = \\frac{\\rho A g_{\\mathrm{acc}} L}{2}$ for brevity:\n$$\nk u_1 - k s_j = F_g - \\epsilon \\langle u_1 - g_0 \\rangle\n$$\nRearranging to place all terms involving the unknown $u_1$ on one side:\n$$\nk u_1 + \\epsilon \\langle u_1 - g_0 \\rangle = k s_j + F_g\n$$\nThis is a non-linear algebraic equation for $u_1$ due to the piecewise-linear nature of the Macaulay bracket. We can solve it by considering two mutually exclusive cases.\n\n**Case A: No Contact Penetration ($u_1 \\le g_0$)**\nIf the displacement of the bottom node does not exceed the gap, $u_1 \\le g_0$, then $u_1 - g_0 \\le 0$. By definition of the Macaulay bracket, $\\langle u_1 - g_0 \\rangle = 0$. The equilibrium equation simplifies to a linear one:\n$$\nk u_1 = k s_j + F_g\n$$\nThe solution for $u_1$ is:\n$$\nu_{1, \\text{trial}} = s_j + \\frac{F_g}{k}\n$$\nThis solution is valid only if it is consistent with the initial assumption, i.e., if $u_{1, \\text{trial}} \\le g_0$. If this condition holds, then $u_1 = u_{1, \\text{trial}}$ is the correct displacement, and the contact reaction is $p_\\epsilon = \\epsilon \\langle u_1 - g_0 \\rangle = 0$.\n\n**Case B: Contact Penetration ($u_1 > g_0$)**\nIf the displacement of the bottom node exceeds the gap, $u_1 > g_0$, then $u_1 - g_0 > 0$. The Macaulay bracket simplifies to $\\langle u_1 - g_0 \\rangle = u_1 - g_0$. The equilibrium equation becomes:\n$$\nk u_1 + \\epsilon (u_1 - g_0) = k s_j + F_g\n$$\nThis is again a linear equation for $u_1$:\n$$\n(k + \\epsilon) u_1 = k s_j + F_g + \\epsilon g_0\n$$\nThe solution for $u_1$ is:\n$$\nu_1 = \\frac{k s_j + F_g + \\epsilon g_0}{k + \\epsilon}\n$$\nThis solution is valid if it satisfies the assumption $u_1 > g_0$. Should the \"no contact\" trial displacement $u_{1, \\text{trial}}$ from Case A be greater than $g_0$, it signifies that the no-contact assumption is false, and one must use this formula for $u_1$. The resulting contact reaction is $p_\\epsilon = \\epsilon (u_1 - g_0)$.\n\n**Algorithmic Procedure**\nFor each test case, the problem asks for the contact reaction $p_\\epsilon$ at the final prescribed settlement, let's call it $s_{\\text{final}}$. The quasi-static nature of the problem means we can solve for the state at $s_{\\text{final}}$ directly, without computing intermediate steps.\n\n1.  Calculate the constant parameters: $k = \\frac{EA}{L}$ and $F_g = \\frac{\\rho A g_{\\mathrm{acc}} L}{2}$.\n2.  Take the final settlement from the given load path, $s_j = s_{\\text{final}}$.\n3.  Calculate the \"trial\" displacement assuming no contact: $u_{1, \\text{trial}} = s_{\\text{final}} + \\frac{F_g}{k}$.\n4.  If $u_{1, \\text{trial}} \\le g_0$:\n    The system is in the no-contact state. The final reaction is $p_\\epsilon = 0$.\n5.  If $u_{1, \\text{trial}} > g_0$:\n    The system is in the contact state. Calculate the actual displacement:\n    $$\n    u_1 = \\frac{k s_{\\text{final}} + F_g + \\epsilon g_0}{k + \\epsilon}\n    $$\n    Then calculate the final reaction:\n    $$\n    p_\\epsilon = \\epsilon (u_1 - g_0)\n    $$\nThis procedure is applied to each of the four test cases specified. For Test Case 2, the value $s^\\star$ is pre-calculated according to its definition, which corresponds to the exact threshold of contact, $u_{1, \\text{trial}} = g_0$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n\n    def calculate_final_reaction(E, A, L, rho, g_acc, g0, epsilon, s_path):\n        \"\"\"\n        Calculates the contact reaction at the final load step for a single test case.\n\n        The quasi-static equilibrium for the bottom node (node 1) is:\n        k * u1 + epsilon * <u1 - g0> = k * s_j + Fg\n        where:\n        k = EA/L (axial stiffness)\n        u1 = displacement of node 1\n        epsilon = penalty parameter\n        g0 = initial gap\n        s_j = prescribed displacement of node 2 (top)\n        Fg = gravitational force component at a node = rho * A * g_acc * L / 2\n        <x> = Macaulay bracket, max(x, 0)\n        \n        This function solves this equation for u1 at the final s_j and computes the\n        reaction p_epsilon = epsilon * <u1 - g0>.\n        \"\"\"\n\n        # 1. Calculate constant parameters\n        k = (E * A) / L\n        Fg = (rho * A * g_acc * L) / 2.0\n\n        # Since the problem is quasi-static and elastic (no history dependence),\n        # we only need to solve for the final state using the final settlement.\n        s_final = s_path[-1]\n\n        # 2. Calculate the trial displacement assuming no contact (p_epsilon = 0)\n        # k * u1_trial = k * s_final + Fg\n        u1_trial = s_final + Fg / k\n\n        # 3. Check for contact activation and compute final reaction\n        if u1_trial <= g0:\n            # No contact. The assumption was correct.\n            # p_epsilon = epsilon * <u1 - g0> = epsilon * 0 = 0\n            p_epsilon = 0.0\n        else:\n            # Contact is active. The no-contact assumption was wrong.\n            # Solve the full equation: (k + epsilon) * u1 = k * s_final + Fg + epsilon * g0\n            u1 = (k * s_final + Fg + epsilon * g0) / (k + epsilon)\n            \n            # Calculate the penalty reaction force\n            # Since we are in this branch, u1 > g0, so <u1 - g0> = u1 - g0\n            p_epsilon = epsilon * (u1 - g0)\n            \n        return p_epsilon\n\n    # Define test cases\n    # Common parameters for most cases\n    E_common = 25e9   # Pa\n    A_common = 0.05   # m^2\n    L_common = 2.0    # m\n    rho_common = 2000 # kg/m^3\n    g_acc_common = 9.81 # m/s^2\n\n    test_cases = [\n        {\n            \"name\": \"Test Case 1\",\n            \"E\": E_common, \"A\": A_common, \"L\": L_common, \"rho\": rho_common, \"g_acc\": g_acc_common,\n            \"g0\": 0.01,\n            \"epsilon\": 1e9,\n            \"s_path\": [0.0, 0.006, 0.010, 0.013]\n        },\n        {\n            \"name\": \"Test Case 2\",\n            \"E\": E_common, \"A\": A_common, \"L\": L_common, \"rho\": rho_common, \"g_acc\": g_acc_common,\n            \"g0\": 0.01,\n            \"epsilon\": 1e9,\n            \"s_path\": None # To be calculated\n        },\n        {\n            \"name\": \"Test Case 3\",\n            \"E\": E_common, \"A\": A_common, \"L\": L_common, \"rho\": rho_common, \"g_acc\": g_acc_common,\n            \"g0\": 0.01,\n            \"epsilon\": 1e5,\n            \"s_path\": [0.0, 0.010, 0.020]\n        },\n        {\n            \"name\": \"Test Case 4\",\n            \"E\": E_common, \"A\": A_common, \"L\": L_common, \"rho\": rho_common, \"g_acc\": g_acc_common,\n            \"g0\": 0.05,\n            \"epsilon\": 1e9,\n            \"s_path\": [0.0, 0.010, 0.020]\n        }\n    ]\n\n    # Special calculation for Test Case 2's s_path\n    tc2 = test_cases[1]\n    k2 = (tc2[\"E\"] * tc2[\"A\"]) / tc2[\"L\"]\n    Fg2 = (tc2[\"rho\"] * tc2[\"A\"] * tc2[\"g_acc\"] * tc2[\"L\"]) / 2.0\n    s_star = tc2[\"g0\"] - Fg2 / k2\n    tc2[\"s_path\"] = [s_star]\n\n    results = []\n    for case in test_cases:\n        result = calculate_final_reaction(\n            case[\"E\"], case[\"A\"], case[\"L\"], case[\"rho\"], case[\"g_acc\"],\n            case[\"g0\"], case[\"epsilon\"], case[\"s_path\"]\n        )\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A correct implementation is only the first step; we must also understand the physical accuracy of the penalty model itself. This exercise shifts our focus from numerical implementation to model fidelity by comparing the penalty method to the classic Hertzian theory for spherical contact. You will learn how to calibrate the penalty stiffness $k_n$ to match an analytical solution at a specific load and then quantify the inherent errors in force and contact area that arise at other loads, revealing the nature of the penalty method as a stiff spring approximation .",
            "id": "3549056",
            "problem": "You are tasked with constructing a verification and estimation program for normal contact using the penalty method within computational geomechanics. The verification is against a Hertzian-type elastic half-space response and the estimation concerns penetrations and contact radii produced by a penalty (Winkler-type) representation of contact stiffness. The scenario is a rigid sphere of radius $R$ indenting a linear elastic half-space characterized by an effective modulus $E^*$, with unilateral normal contact enforced via a penalty stiffness per unit area $k_n$. All quantities must be expressed in International System of Units (SI), with indentation expressed in meters ($\\mathrm{m}$), load in Newtons ($\\mathrm{N}$), stiffness in Pascal ($\\mathrm{Pa}$), and radii in meters ($\\mathrm{m}$). Angles do not appear. The final numeric comparison metrics are dimensionless.\n\nBegin from the following fundamental bases:\n- Unilateral contact kinematics: the normal gap $g_n(\\mathbf{x}) \\ge 0$ at a point $\\mathbf{x}$ on the potential contact surface, and penetration $\\gamma(\\mathbf{x}) = \\max(0, -g_n(\\mathbf{x}))$.\n- Penalty enforcement of the contact constraint with normal traction $t_n(\\mathbf{x}) = k_n \\, \\gamma(\\mathbf{x})$.\n- Axisymmetric geometry of a rigid spherical indenter of radius $R$ against a flat surface, with local geometric overlap approximated by a paraboloid of revolution for small slopes.\n- Elastic half-space response for axisymmetric normal contact (Hertzian contact) as a well-tested fact in classical elasticity for small strains, with the effective modulus $E^* = \\dfrac{E}{1-\\nu^2}$ for an isotropic half-space having Young's modulus $E$ and Poisson's ratio $\\nu$.\n\nYour task is to:\n1. Derive from first principles the relationship between the total load $P$ and the indentation $\\delta$ under a penalty (Winkler-type) foundation model for the rigid spherical indenter. Treat the local geometric overlap as $\\gamma(r)$ where $r$ is the radial coordinate, and apply the penalty traction $t_n(r) = k_n \\gamma(r)$ over the contact domain. Integrate the traction to obtain the net load $P$ as a function of $\\delta$, $R$, and $k_n$, and derive the expression for the penalty-method contact radius $a$ in terms of $\\delta$ and $R$. Clearly state all assumptions.\n2. Use the classical elastic half-space (Hertzian-type) contact to relate the indentation $\\delta$ to the load $P$ for a rigid sphere with radius $R$ indenting a half-space with effective modulus $E^*$. Invert this relationship to compute $\\delta$ from a given $P$, $E^*$, and $R$. Also give the Hertzian contact radius $a$ in terms of $R$ and $\\delta$.\n3. Calibrate $k_n$ such that the penalty indentation matches the Hertzian indentation at a chosen calibration load $P_\\mathrm{cal}$. Then, for other loads, compute the relative indentation error and the relative contact radius error between the penalty model and the Hertzian model.\n4. Verify the scaling exponents of indentation with respect to load under both models by computing the slope of $\\log \\delta$ versus $\\log P$ across two representative loads, and check whether the slopes agree with the expected power-law exponents. Return a boolean indicating whether both slopes match their expected values within a tolerance.\n\nImplement the following test suite. For all tests, use the stated $R$ and $E^*$, and compute $k_n$ using the calibration load $P_\\mathrm{cal}$ as described above. Then evaluate errors at the specified evaluation load $P_\\mathrm{eval}$. All parameter values are given in SI units.\n- Test case $1$ (calibration consistency check):\n  - $R = 0.05\\,\\mathrm{m}$\n  - $E^* = 2.0\\times 10^{8}\\,\\mathrm{Pa}$\n  - $P_\\mathrm{cal} = 5.0\\times 10^{3}\\,\\mathrm{N}$\n  - $P_\\mathrm{eval} = 5.0\\times 10^{3}\\,\\mathrm{N}$\n- Test case $2$ (higher-load evaluation, same calibration):\n  - $R = 0.05\\,\\mathrm{m}$\n  - $E^* = 2.0\\times 10^{8}\\,\\mathrm{Pa}$\n  - $P_\\mathrm{cal} = 5.0\\times 10^{3}\\,\\mathrm{N}$\n  - $P_\\mathrm{eval} = 2.0\\times 10^{4}\\,\\mathrm{N}$\n- Test case $3$ (lower-load evaluation, calibration at higher load):\n  - $R = 0.10\\,\\mathrm{m}$\n  - $E^* = 1.0\\times 10^{9}\\,\\mathrm{Pa}$\n  - $P_\\mathrm{cal} = 5.0\\times 10^{4}\\,\\mathrm{N}$\n  - $P_\\mathrm{eval} = 5.0\\times 10^{3}\\,\\mathrm{N}$\n- Test case $4$ (scaling exponent verification, use the same calibration as Test case $2$):\n  - $R = 0.05\\,\\mathrm{m}$\n  - $E^* = 2.0\\times 10^{8}\\,\\mathrm{Pa}$\n  - $P_\\mathrm{cal} = 5.0\\times 10^{3}\\,\\mathrm{N}$\n  - Evaluate slopes using $P_1 = 1.0\\times 10^{3}\\,\\mathrm{N}$ and $P_2 = 1.0\\times 10^{6}\\,\\mathrm{N}$.\n\nFor each of Test cases $1$–$3$, compute and return a pair of floats:\n- The relative indentation error $e_\\delta = \\dfrac{\\delta_\\mathrm{pen} - \\delta_\\mathrm{H}}{\\delta_\\mathrm{H}}$ (dimensionless).\n- The relative contact radius error $e_a = \\dfrac{a_\\mathrm{pen} - a_\\mathrm{H}}{a_\\mathrm{H}}$ (dimensionless).\n\nFor Test case $4$, compute a boolean indicating whether both measured slopes equal their expected values within a tolerance of $1.0\\times 10^{-3}$, where the expected slopes are $1/2$ for the penalty model and $2/3$ for the Hertzian model.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, consisting of three inner lists (each of two floats) followed by a boolean. For example, the output format must be like:\n`[[err_d1, err_a1], [err_d2, err_a2], [err_d3, err_a3], true]`",
            "solution": "The problem statement is a valid and well-posed exercise in computational contact mechanics. It is scientifically grounded in the principles of classical elasticity and standard numerical methods, is self-contained, and uses precise, objective language. All necessary parameters and definitions for a unique solution are provided. We may therefore proceed with the derivation and solution.\n\nThe objective is to compare a simplified penalty-based contact model (a Winkler foundation) with the classical analytical solution for elastic contact (Hertzian theory) for a rigid sphere indenting an elastic half-space. The comparison involves calibrating the penalty model at a specific load and then evaluating its accuracy in predicting indentation and contact radius at other loads, as well as verifying the load-indentation scaling laws for both models.\n\n**Part 1: Penalty (Winkler-type) Model Derivation**\n\nWe begin by deriving the relationship between the total applied load $P$ and the maximum indentation $\\delta$ for a rigid sphere of radius $R$ indenting a surface modeled as a Winkler foundation with a penalty stiffness per unit area $k_n$.\n\n**Assumptions:**\n1.  The indentation depth $\\delta$ is much smaller than the sphere's radius $R$ (i.e., $\\delta \\ll R$). This allows the geometry of the spherical indenter to be approximated by a paraboloid of revolution near the contact point.\n2.  The contact area is defined by the region of geometric overlap between the undeformed indenter and the undeformed surface.\n3.  The contact pressure (traction) $t_n$ at any point is linearly proportional to the local penetration $\\gamma$ at that point, with a constant of proportionality $k_n$. This is the Winkler model: $t_n = k_n \\gamma$.\n\nThe vertical profile of the sphere near the apex can be described by $z(r) = R - \\sqrt{R^2 - r^2}$, where $r$ is the radial distance from the axis of symmetry. Using a Taylor expansion for $r \\ll R$:\n$$z(r) = R - R\\left(1 - \\frac{r^2}{R^2}\\right)^{1/2} \\approx R - R\\left(1 - \\frac{r^2}{2R^2}\\right) = \\frac{r^2}{2R}$$\nWhen the sphere's center indents the surface by a depth $\\delta$, the local penetration (or geometric overlap) at a radial position $r$ is given by:\n$$\\gamma(r) = \\delta - z(r) = \\delta - \\frac{r^2}{2R}$$\nContact occurs where $\\gamma(r) > 0$. The edge of the contact patch, with radius $a_\\mathrm{pen}$, is where the penetration becomes zero:\n$$\\gamma(a_\\mathrm{pen}) = \\delta - \\frac{a_\\mathrm{pen}^2}{2R} = 0 \\implies a_\\mathrm{pen} = \\sqrt{2R\\delta}$$\nThis is the expression for the contact radius in the penalty model, based purely on geometric interference.\n\nThe contact traction according to the penalty law is:\n$$t_n(r) = k_n \\gamma(r) = k_n \\left(\\delta - \\frac{r^2}{2R}\\right)$$\nThe total normal load $P_\\mathrm{pen}$ is obtained by integrating this traction over the circular contact area of radius $a_\\mathrm{pen}$:\n$$P_\\mathrm{pen} = \\int_0^{a_\\mathrm{pen}} t_n(r) \\, 2\\pi r \\, dr = \\int_0^{a_\\mathrm{pen}} k_n \\left(\\delta - \\frac{r^2}{2R}\\right) 2\\pi r \\, dr$$\n$$P_\\mathrm{pen} = 2\\pi k_n \\left[ \\frac{\\delta r^2}{2} - \\frac{r^4}{8R} \\right]_0^{a_\\mathrm{pen}} = 2\\pi k_n \\left( \\frac{\\delta a_\\mathrm{pen}^2}{2} - \\frac{a_\\mathrm{pen}^4}{8R} \\right)$$\nSubstituting $a_\\mathrm{pen}^2 = 2R\\delta$:\n$$P_\\mathrm{pen} = 2\\pi k_n \\left( \\frac{\\delta (2R\\delta)}{2} - \\frac{(2R\\delta)^2}{8R} \\right) = 2\\pi k_n \\left( R\\delta^2 - \\frac{4R^2\\delta^2}{8R} \\right) = 2\\pi k_n \\left( R\\delta^2 - \\frac{R\\delta^2}{2} \\right)$$\n$$P_\\mathrm{pen} = \\pi k_n R \\delta^2$$\nDenoting the indentation in the penalty model as $\\delta_\\mathrm{pen}$, we have the load-indentation relationship: $P_\\mathrm{pen} = \\pi k_n R \\delta_\\mathrm{pen}^2$.\nInverting this to find indentation from load gives:\n$$\\delta_\\mathrm{pen} = \\sqrt{\\frac{P_\\mathrm{pen}}{\\pi k_n R}}$$\nThis shows that for the penalty model, indentation scales with load as $\\delta_\\mathrm{pen} \\propto P_\\mathrm{pen}^{1/2}$. The scaling exponent is $m_\\mathrm{pen} = 1/2$.\n\n**Part 2: Hertzian Elastic Half-Space Model**\n\nFor the case of a rigid sphere indenting a linear elastic half-space, the relationship between load $P_\\mathrm{H}$ and indentation $\\delta_\\mathrm{H}$ is given by the classical Hertzian contact theory. The equations are stated here as established facts.\n\nThe load-indentation relation is:\n$$P_\\mathrm{H} = \\frac{4}{3} E^* \\sqrt{R} \\, \\delta_\\mathrm{H}^{3/2}$$\nwhere $E^*$ is the effective modulus of the half-space, given by $E^* = E/(1-\\nu^2)$ for Young's modulus $E$ and Poisson's ratio $\\nu$.\nInverting for indentation gives:\n$$\\delta_\\mathrm{H} = \\left( \\frac{3P_\\mathrm{H}}{4E^*\\sqrt{R}} \\right)^{2/3}$$\nThis shows that for the Hertzian model, $\\delta_\\mathrm{H} \\propto P_\\mathrm{H}^{2/3}$. The scaling exponent is $m_\\mathrm{H} = 2/3$.\n\nThe contact radius $a_\\mathrm{H}$ in Hertzian theory is related to the indentation by:\n$$a_\\mathrm{H} = \\sqrt{R\\delta_\\mathrm{H}}$$\nIt is crucial to note the difference in the relationship between radius and indentation compared to the penalty model. The Hertzian result $a_\\mathrm{H} = \\sqrt{R\\delta_\\mathrm{H}}$ arises from the specific elastic deformation field under the indenter, whereas the penalty model's $a_\\mathrm{pen} = \\sqrt{2R\\delta_\\mathrm{pen}}$ is a simpler geometric consequence of the undeformed shapes interfering.\n\n**Part 3: Calibration and Error Analysis**\n\nThe penalty stiffness $k_n$ is a parameter of the numerical model and must be calibrated. A common approach is to enforce that the penalty model produces the same indentation as the analytical solution at a chosen calibration load, $P_\\mathrm{cal}$.\nAt $P = P_\\mathrm{cal}$, we set $\\delta_\\mathrm{pen} = \\delta_\\mathrm{H}$. Let this common indentation be $\\delta_\\mathrm{cal}$.\nFirst, we find the Hertzian indentation at the calibration load:\n$$\\delta_\\mathrm{cal} = \\left( \\frac{3P_\\mathrm{cal}}{4E^*\\sqrt{R}} \\right)^{2/3}$$\nThen, we use the penalty model's load-indentation equation to solve for $k_n$:\n$$P_\\mathrm{cal} = \\pi k_n R \\delta_\\mathrm{cal}^2 \\implies k_n = \\frac{P_\\mathrm{cal}}{\\pi R \\delta_\\mathrm{cal}^2}$$\nWith this calibrated $k_n$, we can evaluate the performance of the penalty model at a different load, $P_\\mathrm{eval}$. We compute the relative errors for indentation and contact radius.\nThe relative indentation error $e_\\delta$ is:\n$$e_\\delta = \\frac{\\delta_\\mathrm{pen}(P_\\mathrm{eval}) - \\delta_\\mathrm{H}(P_\\mathrm{eval})}{\\delta_\\mathrm{H}(P_\\mathrm{eval})}$$\nThe relative contact radius error $e_a$ is:\n$$e_a = \\frac{a_\\mathrm{pen}(P_\\mathrm{eval}) - a_\\mathrm{H}(P_\\mathrm{eval})}{a_\\mathrm{H}(P_\\mathrm{eval})}$$\n\n**Part 4: Scaling Exponent Verification**\n\nA power-law relationship of the form $\\delta = C P^m$ becomes linear on a log-log plot: $\\log(\\delta) = \\log(C) + m \\log(P)$. The exponent $m$ is the slope of this line. We can numerically estimate the slope between two points $(P_1, \\delta_1)$ and $(P_2, \\delta_2)$ as:\n$$m = \\frac{\\log(\\delta_2) - \\log(\\delta_1)}{\\log(P_2) - \\log(P_1)} = \\frac{\\log(\\delta_2/\\delta_1)}{\\log(P_2/P_1)}$$\nFor the Hertzian model, we expect to find $m_\\mathrm{H} = 2/3$. For the penalty model, we expect $m_\\mathrm{pen} = 1/2$. The task is to compute these slopes numerically using two specified loads, $P_1$ and $P_2$, and verify if they match the theoretical exponents within a given tolerance of $1.0\\times 10^{-3}$. The calculation will use the value of $k_n$ calibrated as per the specified test case conditions.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to execute the verification and estimation program for normal contact\n    using the penalty method, compared against the Hertzian analytical solution.\n    \"\"\"\n\n    # Helper functions for the physical models\n    def get_hertz_indentation(P, E_star, R):\n        \"\"\"Computes Hertzian indentation.\"\"\"\n        if P == 0:\n            return 0.0\n        return (3 * P / (4 * E_star * np.sqrt(R)))**(2/3)\n\n    def get_hertz_radius(delta_H, R):\n        \"\"\"Computes Hertzian contact radius.\"\"\"\n        return np.sqrt(R * delta_H)\n\n    def get_penalty_indentation(P, k_n, R):\n        \"\"\"Computes penalty method indentation.\"\"\"\n        if P == 0:\n            return 0.0\n        return np.sqrt(P / (np.pi * k_n * R))\n\n    def get_penalty_radius(delta_pen, R):\n        \"\"\"Computes penalty method contact radius based on geometric overlap.\"\"\"\n        return np.sqrt(2 * R * delta_pen)\n\n    # Define the test cases from the problem statement for error analysis\n    test_cases_error = [\n        # (R, E_star, P_cal, P_eval) for Test Cases 1-3\n        (0.05, 2.0e8, 5.0e3, 5.0e3),  # Test Case 1\n        (0.05, 2.0e8, 5.0e3, 2.0e4),  # Test Case 2\n        (0.10, 1.0e9, 5.0e4, 5.0e3),  # Test Case 3\n    ]\n\n    error_results = []\n    # Process Test Cases 1-3\n    for case in test_cases_error:\n        R, E_star, P_cal, P_eval = case\n\n        # Step 1: Calibrate k_n using P_cal\n        delta_cal_H = get_hertz_indentation(P_cal, E_star, R)\n        k_n = P_cal / (np.pi * R * delta_cal_H**2)\n\n        # Step 2: Evaluate both models at P_eval\n        # Hertzian model predictions at P_eval\n        delta_H = get_hertz_indentation(P_eval, E_star, R)\n        a_H = get_hertz_radius(delta_H, R)\n\n        # Penalty model predictions at P_eval\n        delta_pen = get_penalty_indentation(P_eval, k_n, R)\n        a_pen = get_penalty_radius(delta_pen, R)\n\n        # Step 3: Compute relative errors\n        e_delta = (delta_pen - delta_H) / delta_H if delta_H != 0 else 0.0\n        e_a = (a_pen - a_H) / a_H if a_H != 0 else 0.0\n        \n        error_results.append([e_delta, e_a])\n\n    # Define parameters for Test Case 4 for scaling exponent verification\n    params_4 = {\n        'R': 0.05, 'E_star': 2.0e8, 'P_cal': 5.0e3,\n        'P1': 1.0e3, 'P2': 1.0e6, 'tol': 1.0e-3\n    }\n    \n    # Process Test Case 4\n    R = params_4['R']\n    E_star = params_4['E_star']\n    P_cal = params_4['P_cal']\n    P1 = params_4['P1']\n    P2 = params_4['P2']\n    tolerance = params_4['tol']\n\n    # Calibrate k_n using the specified calibration load\n    delta_cal_H_4 = get_hertz_indentation(P_cal, E_star, R)\n    k_n_4 = P_cal / (np.pi * R * delta_cal_H_4**2)\n\n    # Hertzian scaling exponent calculation\n    delta_H1 = get_hertz_indentation(P1, E_star, R)\n    delta_H2 = get_hertz_indentation(P2, E_star, R)\n    m_H = np.log(delta_H2 / delta_H1) / np.log(P2 / P1)\n    \n    # Penalty scaling exponent calculation\n    delta_pen1 = get_penalty_indentation(P1, k_n_4, R)\n    delta_pen2 = get_penalty_indentation(P2, k_n_4, R)\n    m_pen = np.log(delta_pen2 / delta_pen1) / np.log(P2 / P1)\n\n    # Verification against expected exponents\n    expected_m_H = 2/3\n    expected_m_pen = 1/2\n    \n    check_H = np.abs(m_H - expected_m_H) < tolerance\n    check_pen = np.abs(m_pen - expected_m_pen) < tolerance\n    \n    scaling_verified = bool(check_H and check_pen)\n\n    # Format the final output string to match the exact requirement\n    # e.g., [[err_d1, err_a1], [err_d2, err_a2], [err_d3, err_a3], true]\n    res_1_str = f\"[{error_results[0][0]},{error_results[0][1]}]\"\n    res_2_str = f\"[{error_results[1][0]},{error_results[1][1]}]\"\n    res_3_str = f\"[{error_results[2][0]},{error_results[2][1]}]\"\n    bool_4_str = str(scaling_verified).lower()\n    \n    final_output_str = f\"[{res_1_str},{res_2_str},{res_3_str},{bool_4_str}]\"\n    \n    print(final_output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "Finally, every robust computational tool must undergo rigorous verification to ensure it is free of implementation errors. This practice introduces the concept of patch testing, a cornerstone of verification in the finite element method. By subjecting a multi-element bar model to specific load cases where the exact solution is known, you will verify that your implementation correctly reproduces fundamental physical behaviors and is insensitive to mesh discretization for problems it should solve exactly, thereby building confidence in your code's reliability .",
            "id": "3549064",
            "problem": "Consider a prismatic, linearly elastic bar of length $L$ and constant cross-sectional area $A$ aligned with the $x$-axis, occupying the interval $x \\in [0,L]$ in its stress-free reference configuration. The bar has Young’s modulus $E$ and undergoes small displacements $u(x)$ under quasi-static conditions. The bar’s left end at $x=0$ can come into unilateral frictionless contact with a rigid wall located at the same position. The contact is enforced by the penalty method. The right end at $x=L$ is subjected to a prescribed axial displacement $u(L)=U$, and there are no body forces or tractions acting on the bar. All quantities must be expressed in the International System of Units (SI): $E$ in pascals (Pa), $A$ in square meters (m$^2$), $L$ in meters (m), $U$ in meters (m), and the penalty parameter $k_p$ in newtons per meter (N/m). Any reaction force reported must be in newtons (N).\n\nStarting from first principles and core definitions:\n- The infinitesimal axial strain is $\\varepsilon(x)=\\dfrac{du}{dx}$ and the Cauchy stress is $\\sigma(x)=E\\,\\varepsilon(x)$.\n- The Principle of Virtual Work for the bar with possible contact at $x=0$ reads\n$$\n\\int_{0}^{L} E\\,A\\,\\frac{du}{dx}\\,\\frac{dv}{dx}\\,dx \\;+\\; \\delta \\Pi_c(u;v) \\;=\\; 0 \\quad \\text{for all admissible virtual displacements } v(x),\n$$\nwhere $\\Pi_c$ is the penalty contact potential and $\\delta \\Pi_c$ is its first variation with respect to $u$ in the direction $v$.\n- In the penalty method, introduce the normal gap $g_n=u(0)$, with the unilateral contact condition $g_n \\ge 0$. Define the penalty contact potential\n$$\n\\Pi_c(u) \\;=\\; \\tfrac{1}{2}\\,k_p\\,\\langle -g_n \\rangle^2 \\quad \\text{with} \\quad \\langle z \\rangle = \\max(0,z),\n$$\nwhich yields the penalty reaction $R = k_p\\,\\langle -g_n \\rangle$ at $x=0$. The reaction is zero if $g_n \\ge 0$.\n\nDiscretize the bar with $N$ equal two-node linear finite elements (Finite Element (FE) method) of size $h=L/N$. Assemble the standard linear-elastic global stiffness matrix from element contributions. Impose the essential boundary condition $u(L)=U$ using partitioning. Implement an active-set strategy for the contact constraint at $x=0$:\n1. Solve the linear system without contact enforcement to obtain a trial displacement vector and a trial gap $g_n$ at $x=0$.\n2. If $g_n \\ge 0$, accept the solution with zero reaction.\n3. If $g_n < 0$, activate contact by adding the penalty stiffness $k_p$ to the global stiffness at the left boundary degree of freedom, re-solve, and compute the reaction $R=k_p\\,(-u(0))$.\n\nVerification and patch tests:\n- For uniform tensile or zero end displacement, the exact solution is a uniform strain that does not violate the contact constraint. This is a patch test that should produce zero contact reaction.\n- For compression with sufficiently large $k_p$, the reaction should approximate the exact continuum reaction obtained by enforcing $u(0)=0$ exactly.\n- For mesh refinement, the computed reaction should be invariant to the number of elements when $k_p$ is sufficiently large.\n- For moderate $k_p$, model the system as a series connection of the bar axial stiffness $k_{\\text{bar}}=E\\,A/L$ and the penalty spring $k_p$ to obtain an analytical reaction for verification.\n\nImplementation requirements:\n- Build a program that, given $(E,A,L,N,k_p,U)$, assembles the FE system, enforces the displacement at $x=L$, performs the active-set penalty contact step at $x=0$, and returns the contact reaction $R$ in newtons.\n- For the following test suite, compute and return the requested quantitative metrics. Angles are not involved. The required results must be floats.\n\nTest suite (all values in SI units):\n1. Open/tension patch test (no contact should occur): $E=2.10\\times 10^{11}$, $A=3.0\\times 10^{-4}$, $L=2.0$, $N=4$, $k_p=1.0\\times 10^{12}$, $U=+1.0\\times 10^{-3}$. Report the absolute reaction magnitude $|R|$ in newtons.\n2. Compression with large penalty (approximate exact continuum contact): $E=5.0\\times 10^{10}$, $A=1.0\\times 10^{-3}$, $L=1.0$, $N=8$, $k_p=1.0\\times 10^{15}$, $U=-2.0\\times 10^{-5}$. Let $R^\\star$ denote the exact continuum reaction obtained by enforcing $u(0)=0$ exactly. Report the relative error $|R-R^\\star|/R^\\star$ as a float.\n3. Mesh invariance under compression: Use the same parameters $E=7.0\\times 10^{10}$, $A=2.0\\times 10^{-3}$, $L=3.0$, $k_p=1.0\\times 10^{14}$, $U=-6.0\\times 10^{-5}$, but solve twice: once with $N_{\\text{coarse}}=1$ and once with $N_{\\text{fine}}=10$. Let $R_{\\text{c}}$ and $R_{\\text{f}}$ be the two reactions, and let $R^\\star$ be the exact continuum reaction. Report the relative discrepancy $|R_{\\text{c}}-R_{\\text{f}}|/R^\\star$ as a float.\n4. Moderate penalty verification (series stiffness model): $E=3.0\\times 10^{10}$, $A=5.0\\times 10^{-4}$, $L=1.2$, $N=6$, $k_p=4.0\\times 10^{8}$, $U=-1.0\\times 10^{-4}$. Define $k_{\\text{bar}}=E\\,A/L$ and the analytical series stiffness $k_{\\text{eq}} = \\dfrac{k_p\\,k_{\\text{bar}}}{k_p + k_{\\text{bar}}}$. For compression, the analytical reaction is $R_{\\text{an}} = k_{\\text{eq}}\\,|U|$. Report the relative error $|R-R_{\\text{an}}|/R_{\\text{an}}$ as a float.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the four tests above, for example, \"[r1,r2,r3,r4]\".\n- The first entry corresponds to test 1 and must be the absolute reaction magnitude in newtons. The remaining three entries must be the requested relative errors (dimensionless decimals).",
            "solution": "The problem requires the computation of the contact reaction force at one end of a linearly elastic bar using the finite element (FE) method and a penalty-based active-set strategy. We begin by establishing the discrete FE system of equations, then outline the contact algorithm, and finally detail the calculations for each test case.\n\nThe bar is discretized into $N$ two-node linear finite elements of equal length $h=L/N$. For a single element spanning from local node $1$ to node $2$, the displacement field is $u(x)$. The strain is $\\varepsilon = du/dx$. For linear elements, the strain-displacement matrix $\\mathbf{B}$ is constant, $\\mathbf{B} = \\frac{1}{h}[-1, 1]$. The element stiffness matrix $\\mathbf{k}^{(e)}$ is given by:\n$$ \\mathbf{k}^{(e)} = \\int_0^h \\mathbf{B}^T E A \\mathbf{B} \\,dx = \\frac{EA}{h} \\begin{bmatrix} 1 & -1 \\\\ -1 & 1 \\end{bmatrix} $$\nAssembling these element matrices for the $N+1$ nodes (numbered $0$ to $N$) results in a global stiffness matrix $\\mathbf{K}$ of size $(N+1) \\times (N+1)$ and a global displacement vector $\\mathbf{d} = [u_0, u_1, \\dots, u_N]^T$. The global system is $\\mathbf{K}\\mathbf{d} = \\mathbf{F}$, where $\\mathbf{F}$ contains nodal forces.\n\nThe prescribed displacement $u(L)=U$ corresponds to the nodal displacement $u_N=U$. We handle this essential boundary condition by partitioning the system. The degrees of freedom (DOFs) are split into free DOFs, $\\mathbf{d}_f = [u_0, \\dots, u_{N-1}]^T$, and the prescribed DOF, $\\mathbf{d}_p = [u_N] = [U]$. The partitioned system is:\n$$ \\begin{bmatrix} \\mathbf{K}_{ff} & \\mathbf{K}_{fp} \\\\ \\mathbf{K}_{pf} & \\mathbf{K}_{pp} \\end{bmatrix} \\begin{Bmatrix} \\mathbf{d}_f \\\\ \\mathbf{d}_p \\end{Bmatrix} = \\begin{Bmatrix} \\mathbf{F}_f \\\\ \\mathbf{F}_p \\end{Bmatrix} $$\nGiven no external body forces or tractions, the force vector on the free DOFs, $\\mathbf{F}_f$, is initially zero. The equation for the free DOFs is $\\mathbf{K}_{ff} \\mathbf{d}_f + \\mathbf{K}_{fp} \\mathbf{d}_p = \\mathbf{0}$, which we rearrange to solve for $\\mathbf{d}_f$:\n$$ \\mathbf{K}_{ff} \\mathbf{d}_f = -\\mathbf{K}_{fp} \\mathbf{d}_p $$\nHere, $\\mathbf{K}_{ff}$ is the $N \\times N$ submatrix of $\\mathbf{K}$ corresponding to DOFs $0, \\dots, N-1$. $\\mathbf{K}_{fp}$ is the $N \\times 1$ submatrix coupling free DOFs to the prescribed DOF $N$. The structure of $\\mathbf{K}$ shows that only DOF $N-1$ is coupled to DOF $N$, with $K_{N-1,N} = -EA/h$. Thus, the right-hand side, which we term the effective force vector $\\mathbf{F}_{\\text{eff}} = -\\mathbf{K}_{fp} \\mathbf{d}_p$, is a zero vector except for its last entry: $F_{\\text{eff}, N-1} = -(-EA/h)U = (EA/h)U$.\n\nThe active-set algorithm proceeds as follows:\n1.  **Trial Step**: We first solve the system assuming no contact. The system for the trial displacements $\\mathbf{d}_f^{\\text{trial}}$ is $\\mathbf{K}_{ff} \\mathbf{d}_f^{\\text{trial}} = \\mathbf{F}_{\\text{eff}}$. We then inspect the trial gap at the wall, $g_n^{\\text{trial}} = u_0^{\\text{trial}}$, which is the first component of $\\mathbf{d}_f^{\\text{trial}}$.\n\n2.  **Contact Check**:\n    - If $g_n^{\\text{trial}} \\ge 0$, no contact occurs (the bar does not penetrate the wall). The trial solution is the final solution, and the contact reaction $R$ is zero.\n    - If $g_n^{\\text{trial}} < 0$, the bar penetrates the wall, so contact must be enforced.\n\n3.  **Contact Enforcement**: In the penalty method, activation of contact is equivalent to introducing a spring of stiffness $k_p$ at node $0$. This adds the penalty stiffness $k_p$ to the diagonal entry of the global stiffness matrix corresponding to $u_0$, which is the $(0,0)$ entry of $\\mathbf{K}_{ff}$. The modified system is:\n    $$ \\mathbf{K}_{ff}' \\mathbf{d}_f = \\mathbf{F}_{\\text{eff}} \\quad \\text{where} \\quad (\\mathbf{K}_{ff}')_{0,0} = (\\mathbf{K}_{ff})_{0,0} + k_p $$\n    We solve this system for the final displacement vector $\\mathbf{d}_f$. The contact reaction force magnitude $R$ is then calculated as specified, $R = k_p \\langle -g_n \\rangle = k_p(-u_0)$, since $u_0$ will be negative.\n\nA crucial insight for this problem is that the exact analytical solution to the underlying continuum problem, both with and without the penalty regularization, is a linear function of $x$. A finite element model using linear elements can represent any linear field exactly. Therefore, the nodal displacements computed by the FE method will be identical to the values of the exact continuum solution at the nodal coordinates. This implies that the computed reaction force will be independent of the number of elements $N$ used for discretization.\n\nThe implementation proceeds by creating a function that executes these steps for a given set of parameters $(E,A,L,N,k_p,U)$.\n\n- **Test 1**: $U > 0$, representing tension. The trial displacement at the wall is $u_0^\\text{trial}=U > 0$. The contact condition $g_n \\ge 0$ is not violated. Thus, the reaction force $R$ is $0$.\n\n- **Test 2**: $U < 0$, representing compression. The trial step yields $u_0^\\text{trial}=U < 0$, activating contact. The numerical reaction $R$ is computed and compared to the exact continuum reaction for perfect contact ($u(0)=0$), which is $R^\\star = EA|U|/L$. The relative error $|R - R^\\star| / R^\\star$ is reported. For large $k_p$, $R$ should closely approximate $R^\\star$.\n\n- **Test 3**: $U < 0$, activating contact. Based on the principle that the linear FE solution is exact for this problem, the computed reactions $R_{\\text{c}}$ (for $N=1$) and $R_{\\text{f}}$ (for $N=10$) must be identical. Therefore, the relative discrepancy $|R_{\\text{c}} - R_{\\text{f}}| / R^\\star$ is expected to be $0$ (or a value on the order of machine precision).\n\n- **Test 4**: $U < 0$, activating contact. The analytical reaction for the series-spring model is $R_{\\text{an}} = k_{\\text{eq}}|U|$, where $k_{\\text{eq}} = (k_p k_{\\text{bar}})/(k_p + k_{\\text{bar}})$ and $k_{\\text{bar}}=EA/L$. As established, the FE solution should exactly match the analytical solution of the penalty-regularized continuum problem. Thus, the numerically computed reaction $R$ should equal $R_{\\text{an}}$, and the relative error $|R - R_{\\text{an}}| / R_{\\text{an}}$ is expected to be $0$.\n\nThe program implements this logic for each test case, calculates the specified metrics, and prints them in the required format.",
            "answer": "```python\nimport numpy as np\n\ndef solve_reaction(E, A, L, N, kp, U):\n    \"\"\"\n    Computes the contact reaction for a 1D elastic bar using the FE method.\n\n    Args:\n        E (float): Young's modulus (Pa)\n        A (float): Cross-sectional area (m^2)\n        L (float): Length of the bar (m)\n        N (int): Number of finite elements\n        kp (float): Penalty stiffness (N/m)\n        U (float): Prescribed displacement at x=L (m)\n\n    Returns:\n        float: Contact reaction force R (N).\n    \"\"\"\n    if N == 0:\n        return 0.0\n\n    h = L / N\n    k_elem = E * A / h\n\n    # Assemble the K_ff stiffness matrix for free DOFs (0 to N-1)\n    K_ff = np.zeros((N, N))\n    if N > 0:\n        diag = np.full(N, 2.0 * k_elem)\n        diag[0] = k_elem\n        K_ff += np.diag(diag)\n    if N > 1:\n        off_diag = np.full(N - 1, -k_elem)\n        K_ff += np.diag(off_diag, k=1)\n        K_ff += np.diag(off_diag, k=-1)\n    \n    # Assemble the effective force vector F_eff = -K_fp * d_p\n    F_eff = np.zeros(N)\n    if N > 0:\n        # The coupling force comes from the element between nodes N-1 and N.\n        # F_eff_{N-1} = -K_{N-1,N} * u_N = -(-k_elem) * U\n        F_eff[N-1] = k_elem * U\n\n    # --- Active-set strategy ---\n    # 1. Trial solve (no contact)\n    d_f_trial = np.linalg.solve(K_ff, F_eff)\n    u0_trial = d_f_trial[0]\n\n    # 2. Check for contact\n    if u0_trial >= 0:\n        return 0.0  # No contact, reaction is zero\n    else:\n        # 3. Contact is active, re-solve with penalty stiffness\n        K_ff_contact = K_ff.copy()\n        K_ff_contact[0, 0] += kp\n        \n        d_f_contact = np.linalg.solve(K_ff_contact, F_eff)\n        u0_contact = d_f_contact[0]\n        \n        # Reaction is R = k_p * < -u(0) > = -k_p * u(0) for u(0)<0\n        reaction = -kp * u0_contact\n        return reaction\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        {'E': 2.10e11, 'A': 3.0e-4, 'L': 2.0, 'N': 4, 'kp': 1.0e12, 'U': +1.0e-3},\n        {'E': 5.0e10, 'A': 1.0e-3, 'L': 1.0, 'N': 8, 'kp': 1.0e15, 'U': -2.0e-5},\n        {'E': 7.0e10, 'A': 2.0e-3, 'L': 3.0, 'kp': 1.0e14, 'U': -6.0e-5, 'N_coarse': 1, 'N_fine': 10},\n        {'E': 3.0e10, 'A': 5.0e-4, 'L': 1.2, 'N': 6, 'kp': 4.0e8, 'U': -1.0e-4},\n    ]\n\n    results = []\n\n    # Test 1: Open/tension patch test\n    p1 = test_cases[0]\n    R1 = solve_reaction(p1['E'], p1['A'], p1['L'], p1['N'], p1['kp'], p1['U'])\n    results.append(abs(R1))\n\n    # Test 2: Compression with large penalty\n    p2 = test_cases[1]\n    R2_num = solve_reaction(p2['E'], p2['A'], p2['L'], p2['N'], p2['kp'], p2['U'])\n    R2_star = (p2['E'] * p2['A'] / p2['L']) * abs(p2['U'])\n    err2 = abs(R2_num - R2_star) / R2_star\n    results.append(err2)\n\n    # Test 3: Mesh invariance under compression\n    p3 = test_cases[2]\n    R_c = solve_reaction(p3['E'], p3['A'], p3['L'], p3['N_coarse'], p3['kp'], p3['U'])\n    R_f = solve_reaction(p3['E'], p3['A'], p3['L'], p3['N_fine'], p3['kp'], p3['U'])\n    R3_star = (p3['E'] * p3['A'] / p3['L']) * abs(p3['U'])\n    disc3 = abs(R_c - R_f) / R3_star if R3_star != 0 else 0.0\n    results.append(disc3)\n\n    # Test 4: Moderate penalty verification\n    p4 = test_cases[3]\n    R4_num = solve_reaction(p4['E'], p4['A'], p4['L'], p4['N'], p4['kp'], p4['U'])\n    k_bar = (p4['E'] * p4['A']) / p4['L']\n    k_eq = (p4['kp'] * k_bar) / (p4['kp'] + k_bar)\n    R4_an = k_eq * abs(p4['U'])\n    err4 = abs(R4_num - R4_an) / R4_an if R4_an != 0 else 0.0\n    results.append(err4)\n\n    # Format and print the final output\n    print(f\"[{','.join(f'{r:.15g}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}