{
    "hands_on_practices": [
        {
            "introduction": "扩展有限元法 (XFEM) 的核心在于修改系统的刚度矩阵以模拟不连续性。本练习专注于单个含裂纹单元，这是最基本的构建模块。通过使用子单元积分来推导和计算增强自由度的刚度贡献，您将亲身体验 XFEM 在标准有限元框架内表示强不连续性的核心机制 。",
            "id": "3523124",
            "problem": "考虑一个二维小应变、各向同性、线性弹性平面应变条件下的单个线性三角形有限元，该单元被一个由水平集场隐式表示的直线裂纹所贯穿。使用带有偏移富集函数的 Heaviside 富集来捕捉单元内裂纹两侧的位移跳跃。裂纹由一个分段线性标量场的零水平集表示，该标量场由节点值指定。假设裂纹是无牵引力的，并且 Heaviside 函数在由水平集符号定义的每个积分子域内是恒定的。\n\n对于每个测试用例，您必须使用子单元积分法，计算仅与富集自由度相关的单元级刚度贡献。积分在对应于正负水平集区域的两个积分子域上进行。每个测试用例的结果是按行主序展开的富集-富集刚度子矩阵。\n\n基于第一性原理进行推导和实现：\n- 使用虚功原理，其中双线性形式涉及应变-位移和本构算子的乘积在域上的积分。假设平面应变弹性，厚度为 $t$。\n- 使用标准的线性三角形形函数，其空间梯度在整个单元上是恒定的。\n- 通过水平集函数 $\\phi(\\mathbf{x})$ 表示裂纹，该函数根据其节点值在单元上呈线性变化。将 Heaviside 函数定义为：当 $\\phi \\ge 0$ 时 $H(\\phi) = +1$，当 $\\phi  0$ 时 $H(\\phi) = -1$。采用 $H(0)=+1$ 的约定。\n- 在节点 $i$ 处使用偏移 Heaviside 富集，其形式为 $H(\\phi(\\mathbf{x})) - H(\\phi_i)$，其中 $\\phi_i$ 是节点 $i$ 处的水平集值。\n\n积分要求：\n- 通过直线 $\\phi(\\mathbf{x})=0$ 对三角形进行裁剪，将其划分为两个积分子域。该直线是通过沿每条边对 $\\phi$ 进行线性插值得到的。正子域为 $\\{\\mathbf{x} \\mid \\phi(\\mathbf{x}) \\ge 0\\}$，负子域为 $\\{\\mathbf{x} \\mid \\phi(\\mathbf{x})  0\\}$。在这两个子域上分别进行积分，并假设 Heaviside 函数在每个子域内是恒定的。\n- 使用基于沿边线性插值的精确多边形裁剪来找到子域多边形及其面积。由于是线性三角形，最终的刚度贡献可以表示为子域面积和恒定应变-位移矩阵的函数。\n\n材料和运动学数据：\n- 杨氏模量 $E$ 和泊松比 $\\nu$ 定义了平面应变本构矩阵。\n- 单元厚度 $t$ 作为刚度的乘数。\n- 该单元有三个节点，其坐标为 $(x_i,y_i)$，节点水平集值为 $\\phi_i$。\n\n富集和输出：\n- 使用上述的偏移 Heaviside 富集，对所有三个单元节点的两个位移分量（水平和垂直）进行富集。\n- 组装一个 $6 \\times 6$ 的富集-富集刚度子矩阵，该矩阵对应于三个节点上的富集自由度，顺序为 $[u_{1x}^{\\mathrm{enr}}, u_{1y}^{\\mathrm{enr}}, u_{2x}^{\\mathrm{enr}}, u_{2y}^{\\mathrm{enr}}, u_{3x}^{\\mathrm{enr}}, u_{3y}^{\\mathrm{enr}}]$。\n\n物理单位：\n- 使用国际单位制（SI）。输入长度单位为米， $E$ 的单位为帕斯卡，厚度 $t$ 的单位为米。\n- 刚度矩阵各项的单位表示为牛顿/米 $[\\mathrm{N/m}]$。\n\n测试套件：\n实现您的程序，为以下三种情况计算富集-富集刚度子矩阵。在每种情况下，使用指定的节点坐标 $(x_i,y_i)$ 和水平集值 $\\phi_i$，所有三种情况的材料参数和厚度都相同。\n\n- 情况 1 (理想情况):\n  - 节点: $(x_1,y_1) = (0,0)$, $(x_2,y_2) = (2,0)$, $(x_3,y_3) = (0,1)$。\n  - 水平集值: $\\phi_1 = -0.2$, $\\phi_2 = +0.3$, $\\phi_3 = +0.4$。\n- 情况 2 (边界条件，一个顶点在裂纹上):\n  - 节点: $(x_1,y_1) = (0,0)$, $(x_2,y_2) = (1.5,0)$, $(x_3,y_3) = (0.5,1.0)$。\n  - 水平集值: $\\phi_1 = 0.0$, $\\phi_2 = +0.5$, $\\phi_3 = -0.5$。\n- 情况 3 (边缘情况，切割面积非常小):\n  - 节点: $(x_1,y_1) = (0,0)$, $(x_2,y_2) = (2,0)$, $(x_3,y_3) = (0,1)$。\n  - 水平集值: $\\phi_1 = -0.001$, $\\phi_2 = +0.001$, $\\phi_3 = +0.001$。\n\n所有情况的材料参数和厚度：\n- 杨氏模量: $E = 30 \\times 10^{9}\\ \\mathrm{Pa}$。\n- 泊松比: $\\nu = 0.25$。\n- 厚度: $t = 1.0\\ \\mathrm{m}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含结果，格式为逗号分隔的列表的列表。每个内部列表是对应测试用例的按行主序展开的富集-富集刚度子矩阵。例如，输出格式必须完全是：\n  - $[ [k_{11}, k_{12}, \\ldots, k_{16}, \\ldots, k_{66}], [\\ldots], [\\ldots] ]$\n- 各项必须是浮点数，表示单位为 $[\\mathrm{N/m}]$ 的刚度。",
            "solution": "该问题要求计算一个被直线裂纹贯穿的平面应变条件下单个线性三角形有限元的富集-富集刚度子矩阵，记为 $\\mathbf{K}^{\\mathrm{bb}}$。裂纹由分段线性水平集函数 $\\phi(\\mathbf{x})$ 隐式表示。该公式基于扩展有限元法（XFEM），并使用偏移 Heaviside 富集。\n\n刚度矩阵由虚功原理推导得出，该原理指出内功的变分等于外功的变分。对于线性弹性体，内虚功通过包含应变 $\\boldsymbol{\\epsilon}$ 和应力 $\\boldsymbol{\\sigma}$ 的双线性形式表示：\n$$ a(\\delta \\mathbf{u}, \\mathbf{u}) = \\int_{\\Omega^e} \\boldsymbol{\\epsilon}(\\delta \\mathbf{u})^T \\boldsymbol{\\sigma}(\\mathbf{u}) \\, d\\Omega = \\int_{\\Omega^e} \\boldsymbol{\\epsilon}(\\delta \\mathbf{u})^T \\mathbf{D} \\, \\boldsymbol{\\epsilon}(\\mathbf{u}) \\, d\\Omega $$\n其中 $\\delta \\mathbf{u}$ 是虚位移场，$\\mathbf{u}$ 是位移场，$\\boldsymbol{\\epsilon}$ 是应变向量（采用 Voigt 记法），$\\mathbf{D}$ 是材料本构矩阵，$\\Omega^e$ 是单元域。对于此问题，我们还必须乘以单元厚度 $t$。\n\n单元内的位移场 $\\mathbf{u}(\\mathbf{x})$ 使用 XFEM 框架进行近似。它包含一个标准部分和一个富集部分：\n$$ \\mathbf{u}(\\mathbf{x}) = \\sum_{i=1}^{3} N_i(\\mathbf{x})\\mathbf{u}_i + \\sum_{j=1}^{3} N_j(\\mathbf{x}) F_j(\\mathbf{x}) \\mathbf{b}_j $$\n这里，$N_i(\\mathbf{x})$ 是标准的线性三角形形函数，$\\mathbf{u}_i$ 是标准节点位移向量，$\\mathbf{b}_j$ 是富集节点位移向量。节点 $j$ 的富集函数是偏移 Heaviside 函数，定义为 $F_j(\\mathbf{x}) = H(\\phi(\\mathbf{x})) - H(\\phi_j)$，其中 $\\phi_j$ 是节点 $j$ 的水平集值。Heaviside 函数定义为：当 $\\phi \\ge 0$ 时 $H(\\phi)=+1$，当 $\\phi  0$ 时 $H(\\phi)=-1$。\n\n我们只关心来自富集自由度 $\\mathbf{b}_j$ 的刚度贡献。对应于位移富集部分 $\\mathbf{u}^{\\mathrm{b}}(\\mathbf{x}) = \\sum_{j=1}^{3} N_j(\\mathbf{x}) F_j(\\mathbf{x}) \\mathbf{b}_j$ 的应变场，是通过应用微分应变-位移算子得到的，其矩阵形式为 $\\boldsymbol{\\epsilon}^{\\mathrm{b}} = \\sum_{j=1}^{3} \\mathbf{B}_j^{\\mathrm{b}} \\mathbf{b}_j$。\n\n问题陈述中指出，积分在两个子域 $\\Omega^+ = \\{\\mathbf{x} \\in \\Omega^e \\mid \\phi(\\mathbf{x}) \\ge 0\\}$ 和 $\\Omega^- = \\{\\mathbf{x} \\in \\Omega^e \\mid \\phi(\\mathbf{x})  0\\}$ 上执行，并且在每个子域内，Heaviside 函数 $H(\\phi(\\mathbf{x}))$ 被假定为常数。在 $\\Omega^+$ 中，$H(\\phi(\\mathbf{x}))=+1$；在 $\\Omega^-$ 中，$H(\\phi(\\mathbf{x}))=-1$。这意味着富集函数的梯度 $\\nabla F_j(\\mathbf{x})$ 在每个子域内为零。因此，富集部分的应变-位移矩阵 $\\mathbf{B}_j^{\\mathrm{b}}$ 被简化为：\n$$ \\mathbf{B}_j^{\\mathrm{b}}(\\mathbf{x}) = \\nabla_s (N_j(\\mathbf{x}) F_j(\\mathbf{x})) = (\\nabla N_j) F_j(\\mathbf{x}) + N_j (\\nabla F_j) \\approx (\\nabla N_j) F_j(\\mathbf{x}) $$\n对于线性三角形，形函数梯度 $\\nabla N_j$ 是恒定的。节点 $j$ 的标准应变-位移矩阵 $\\mathbf{B}_j$ 也是恒定的。因此，$\\mathbf{B}_j^{\\mathrm{b}}(\\mathbf{x}) = \\mathbf{B}_j F_j(\\mathbf{x})$。\n\n富集-富集刚度矩阵中耦合节点 $i$ 和 $j$ 的富集自由度的 $2 \\times 2$ 子块 $\\mathbf{K}_{ij}^{\\mathrm{bb}}$ 由以下公式给出：\n$$ \\mathbf{K}_{ij}^{\\mathrm{bb}} = t \\int_{\\Omega^e} (\\mathbf{B}_i^{\\mathrm{b}})^T \\mathbf{D} \\, \\mathbf{B}_j^{\\mathrm{b}} \\, d\\Omega = t \\int_{\\Omega^e} (\\mathbf{B}_i F_i(\\mathbf{x}))^T \\mathbf{D} \\, (\\mathbf{B}_j F_j(\\mathbf{x})) \\, d\\Omega $$\n由于 $\\mathbf{B}_i$、$\\mathbf{B}_j$ 和 $\\mathbf{D}$ 是常数矩阵，它们可以从积分中提出：\n$$ \\mathbf{K}_{ij}^{\\mathrm{bb}} = t \\, (\\mathbf{B}_i)^T \\mathbf{D} \\, \\mathbf{B}_j \\int_{\\Omega^e} F_i(\\mathbf{x}) F_j(\\mathbf{x}) \\, d\\Omega $$\n通过划分域来计算积分项：\n$$ I_{ij} = \\int_{\\Omega^e} F_i(\\mathbf{x}) F_j(\\mathbf{x}) \\, d\\Omega = \\int_{\\Omega^+} F_i(\\mathbf{x})F_j(\\mathbf{x}) \\, d\\Omega + \\int_{\\Omega^-} F_i(\\mathbf{x})F_j(\\mathbf{x}) \\, d\\Omega $$\n在每个子域内，富集函数是常数。设 $H_k = H(\\phi_k)$。\n在 $\\Omega^+$ 中，$F_k(\\mathbf{x}) = +1 - H_k$。\n在 $\\Omega^-$ 中，$F_k(\\mathbf{x}) = -1 - H_k$。\n我们定义系数 $s_k^+$ 和 $s_k^-$：\n如果 $\\phi_k \\ge 0$，则 $H_k = +1$。这意味着在 $\\Omega^+$ 中 $F_k(\\mathbf{x}) = 1-1=0$，在 $\\Omega^-$ 中 $F_k(\\mathbf{x}) = -1-1=-2$。所以，$s_k^+=0$ 且 $s_k^-=-2$。\n如果 $\\phi_k  0$，则 $H_k = -1$。这意味着在 $\\Omega^+$ 中 $F_k(\\mathbf{x}) = 1-(-1)=2$，在 $\\Omega^-$ 中 $F_k(\\mathbf{x}) = -1-(-1)=0$。所以，$s_k^+=2$ 且 $s_k^-=0$。\n积分变为：\n$$ I_{ij} = s_i^+ s_j^+ \\int_{\\Omega^+} d\\Omega + s_i^- s_j^- \\int_{\\Omega^-} d\\Omega = (s_i^+ s_j^+) A^+ + (s_i^- s_j^-) A^- $$\n其中 $A^+$ 和 $A^-$ 分别是正子域和负子域的面积。\n\n计算流程如下：\n1.  对于给定的具有节点 $(\\mathbf{x}_1, \\mathbf{x}_2, \\mathbf{x}_3)$ 的三角形单元，计算其总面积 $A$ 和 $i=1,2,3$ 时的恒定应变-位移矩阵 $\\mathbf{B}_i$：\n    $$ A = \\frac{1}{2} |x_1(y_2-y_3) + x_2(y_3-y_1) + x_3(y_1-y_2)| $$\n    $$ \\mathbf{B}_i = \\frac{1}{2A} \\begin{bmatrix} y_j-y_k  0 \\\\ 0  x_k-x_j \\\\ x_k-x_j  y_j-y_k \\end{bmatrix} \\quad \\text{for cyclic } (i,j,k) $$\n2.  计算平面应变本构矩阵 $\\mathbf{D}$：\n    $$ \\mathbf{D} = \\frac{E(1-\\nu)}{(1+\\nu)(1-2\\nu)} \\begin{bmatrix} 1  \\frac{\\nu}{1-\\nu}  0 \\\\ \\frac{\\nu}{1-\\nu}  1  0 \\\\ 0  0  \\frac{1-2\\nu}{2(1-\\nu)} \\end{bmatrix} $$\n3.  通过用直线 $\\phi(\\mathbf{x})=0$ 裁剪三角形来确定子域 $\\Omega^+$ 和 $\\Omega^-$。该直线通过节点 $\\phi_i$ 值的线性插值找到。计算面积 $A^+$ 和 $A^-$。如果单元未被裂纹切割（即所有 $\\phi_i$ 的符号状态相同），则一个面积为 $A$，另一个为 $0$。如果单元被切割，直线 $\\phi(\\mathbf{x})=0$ 会与两条边相交，将三角形分割成一个较小的三角形和一个四边形。计算这些多边形的面积。\n4.  对每个节点 $i=1,2,3$，根据 $\\phi_i$ 的符号确定系数 $s_i^+$ 和 $s_i^-$。\n5.  从其 $i,j \\in \\{1,2,3\\}$ 的 $2 \\times 2$ 子块 $\\mathbf{K}_{ij}^{\\mathrm{bb}}$ 组装完整的 $6 \\times 6$ 矩阵 $\\mathbf{K}^{\\mathrm{bb}}$：\n    $$ \\mathbf{K}_{ij}^{\\mathrm{bb}} = t \\, \\left( (s_i^+ s_j^+) A^+ + (s_i^- s_j^-) A^- \\right) \\, (\\mathbf{B}_i)^T \\mathbf{D} \\, \\mathbf{B}_j $$\n    将这些子块放置在矩阵中，对应于自由度顺序 $[u_{1x}^{\\mathrm{enr}}, u_{1y}^{\\mathrm{enr}}, u_{2x}^{\\mathrm{enr}}, u_{2y}^{\\mathrm{enr}}, u_{3x}^{\\mathrm{enr}}, u_{3y}^{\\mathrm{enr}}]$。\n6.  最终结果是 $6 \\times 6$ 矩阵 $\\mathbf{K}^{\\mathrm{bb}}$ 按行主序展开成的向量。此过程将应用于每个测试用例。",
            "answer": "```python\nimport numpy as np\n\ndef compute_stiffness_submatrix(nodes, phis, E, nu, t):\n    \"\"\"\n    Computes the enriched-enriched stiffness submatrix for a cracked linear triangle.\n\n    Args:\n        nodes (list of tuples): Coordinates of the 3 element nodes [(x1,y1), (x2,y2), (x3,y3)].\n        phis (tuple): Nodal level set values (phi1, phi2, phi3).\n        E (float): Young's modulus.\n        nu (float): Poisson's ratio.\n        t (float): Element thickness.\n\n    Returns:\n        list: The 6x6 enriched-enriched stiffness matrix, flattened in row-major order.\n    \"\"\"\n    node_coords = np.array(nodes, dtype=float)\n    x = node_coords[:, 0]\n    y = node_coords[:, 1]\n\n    # 1. Compute element geometric properties (Area A, B matrices)\n    A_total = 0.5 * np.abs(x[0]*(y[1]-y[2]) + x[1]*(y[2]-y[0]) + x[2]*(y[0]-y[1]))\n    if A_total == 0:\n        return [0.0] * 36\n\n    # Gradients of shape functions\n    dN_dx = np.array([y[1]-y[2], y[2]-y[0], y[0]-y[1]]) / (2 * A_total)\n    dN_dy = np.array([x[2]-x[1], x[0]-x[2], x[1]-x[0]]) / (2 * A_total)\n\n    # B matrices\n    B_matrices = []\n    for i in range(3):\n        B_i = np.array([\n            [dN_dx[i], 0],\n            [0, dN_dy[i]],\n            [dN_dy[i], dN_dx[i]]\n        ])\n        B_matrices.append(B_i)\n\n    # 2. Compute plane strain constitutive matrix D\n    d_const = E * (1 - nu) / ((1 + nu) * (1 - 2 * nu))\n    D = d_const * np.array([\n        [1, nu / (1 - nu), 0],\n        [nu / (1 - nu), 1, 0],\n        [0, 0, (1 - 2 * nu) / (2 * (1 - nu))]\n    ])\n\n    # 3. Determine subdomain areas A+ and A-\n    pos_nodes_idx = [i for i, phi in enumerate(phis) if phi >= 0]\n    neg_nodes_idx = [i for i, phi in enumerate(phis) if phi  0]\n\n    A_pos, A_neg = 0.0, 0.0\n\n    if len(pos_nodes_idx) == 3:\n        A_pos = A_total\n    elif len(neg_nodes_idx) == 3:\n        A_neg = A_total\n    else:  # Element is cut\n        # This function interpolates to find the point on an edge where phi=0\n        def get_intersection(p1_idx, p2_idx):\n            phi1, phi2 = phis[p1_idx], phis[p2_idx]\n            pt1, pt2 = node_coords[p1_idx], node_coords[p2_idx]\n            # using formula p = (phi2*p1 - phi1*p2) / (phi2-phi1) for robustness even if one is 0\n            return (phi2 * pt1 - phi1 * pt2) / (phi2 - phi1)\n\n        def polygon_area(verts):\n            if len(verts)  3:\n                return 0.0\n            # Shoelace formula\n            area = 0.0\n            for i in range(len(verts)):\n                p1 = verts[i]\n                p2 = verts[(i + 1) % len(verts)]\n                area += p1[0] * p2[1] - p2[0] * p1[1]\n            return 0.5 * np.abs(area)\n        \n        # Identify the single node and the two other nodes\n        if len(neg_nodes_idx) == 1:\n            single_node_idx = neg_nodes_idx[0]\n            other_nodes_idx = pos_nodes_idx\n            is_single_node_neg = True\n        else: # len(pos_nodes_idx) == 1\n            single_node_idx = pos_nodes_idx[0]\n            other_nodes_idx = neg_nodes_idx\n            is_single_node_neg = False\n            \n        p_s = node_coords[single_node_idx]\n        \n        p_int1 = get_intersection(single_node_idx, other_nodes_idx[0])\n        p_int2 = get_intersection(single_node_idx, other_nodes_idx[1])\n        \n        small_poly_verts = [p_s, p_int1, p_int2]\n        small_area = polygon_area(small_poly_verts)\n\n        if is_single_node_neg:\n            A_neg = small_area\n            A_pos = A_total - A_neg\n        else:\n            A_pos = small_area\n            A_neg = A_total - A_pos\n\n    # 4. Determine s factors\n    s_pos, s_neg = [], []\n    for phi in phis:\n        if phi >= 0: # Node on positive side or on crack\n            s_pos.append(0)\n            s_neg.append(-2)\n        else: # Node on negative side\n            s_pos.append(2)\n            s_neg.append(0)\n\n    # 5. Assemble K_bb\n    K_bb = np.zeros((6, 6))\n    M_ij_cache = {} # Cache for (Bi^T * D * Bj)\n\n    for i in range(3):\n        for j in range(3):\n            # Calculate integral term I_ij\n            I_ij = (s_pos[i] * s_pos[j]) * A_pos + (s_neg[i] * s_neg[j]) * A_neg\n            \n            if I_ij == 0:\n                continue\n\n            # Calculate matrix product part (Bi^T * D * Bj)\n            # Use symmetry to reduce calculations\n            if (i, j) in M_ij_cache:\n                M_ij = M_ij_cache[(i,j)]\n            elif (j,i) in M_ij_cache:\n                M_ij = M_ij_cache[(j,i)].T\n            else:\n                M_ij = B_matrices[i].T @ D @ B_matrices[j]\n                M_ij_cache[(i,j)] = M_ij\n\n            K_ij_block = t * I_ij * M_ij\n\n            # Place block in the 6x6 matrix\n            row_start, col_start = 2 * i, 2 * j\n            K_bb[row_start:row_start+2, col_start:col_start+2] = K_ij_block\n\n    # 6. Flatten and return\n    return K_bb.flatten().tolist()\n\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    # Material and geometry parameters\n    E = 30.0e9  # Pa\n    nu = 0.25\n    t = 1.0     # m\n\n    # Test suite\n    test_cases = [\n        {\n            \"nodes\": ((0.0, 0.0), (2.0, 0.0), (0.0, 1.0)),\n            \"phis\": (-0.2, 0.3, 0.4)\n        },\n        {\n            \"nodes\": ((0.0, 0.0), (1.5, 0.0), (0.5, 1.0)),\n            \"phis\": (0.0, 0.5, -0.5)\n        },\n        {\n            \"nodes\": ((0.0, 0.0), (2.0, 0.0), (0.0, 1.0)),\n            \"phis\": (-0.001, 0.001, 0.001)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        stiffness_flat = compute_stiffness_submatrix(case[\"nodes\"], case[\"phis\"], E, nu, t)\n        results.append(stiffness_flat)\n\n    # Format output as specified\n    formatted_results = \"[\" + \",\".join([str(res) for res in results]) + \"]\"\n    print(formatted_results)\n\nsolve()\n\n```"
        },
        {
            "introduction": "尽管增强近似空间功能强大，但它可能导致数值伪影，特别是在邻近增强区域的单元（混合单元）中，这通常是由于单位分解性质的破坏所致。本实践设计了一个 $L^2$ 投影的数值实验，以分离和研究这种“污染”效应，并比较了简单的移动增强函数与旨在恢复单位分解性质的更复杂的斜坡函数修正增强 。通过分析这两种策略的收敛速度，您将能更深入地理解 XFEM 的理论基础，并学会如何设计数值实验来验证和比较不同的裂尖奇异性增强技术。",
            "id": "3523114",
            "problem": "您需要设计并实现一个最小富集投影实验，该实验用于在线性弹性断裂力学的二维标量代理模型中，分离并量化扩展有限元法（XFEM）中混合模式裂纹的混合单元污染问题。实验的目标是测试当裂纹尖端经过单元角点附近时，基于斜坡函数的混合修正是否能消除单位分解污染，并评估其在混合模式加载下对收敛率的影响。\n\n请从以下公认的基函数和定义开始。\n\n- 有限元法使用单位分解特性：如果 $\\{N_i(\\boldsymbol{x})\\}$ 是网格上的节点形函数，那么对于域中所有的 $\\boldsymbol{x}$，都有 $\\sum_i N_i(\\boldsymbol{x}) = 1$。在扩展有限元法（XFEM）中，一个富集试探空间通过将标准空间与 $N_i(\\boldsymbol{x})$ 和与水平集表示的裂纹相关的不连续或奇异函数 $F_k(\\boldsymbol{x})$ 的乘积来增强。\n- 一个从尖端点 $\\boldsymbol{x}_t$ 以方向角 $\\varphi$（弧度）延伸的直裂纹，通过一个局部极坐标系 $(r,\\theta)$ 的水平集来表示。该坐标系是通过将全局坐标系围绕 $\\boldsymbol{x}_t$ 旋转 $-\\varphi$ 得到的。在标量代理模型中，近尖端混合模式渐近富集基可取为 $F_1(\\boldsymbol{x}) = \\sqrt{r(\\boldsymbol{x})}\\cos\\left(\\theta(\\boldsymbol{x})/2\\right)$ 和 $F_2(\\boldsymbol{x}) = \\sqrt{r(\\boldsymbol{x})}\\sin\\left(\\theta(\\boldsymbol{x})/2\\right)$，由于 $\\theta$ 在 $(-\\pi,\\pi]$ 上的分支，这些函数是有界的，但在裂纹线上是不连续的。\n- 在与富集区域相邻的混合单元中，单位分解无法将富集项分离出来，这会污染近似质量。两种常见的修正是：\n  1. 位移富集：对每个坐标为 $\\boldsymbol{x}_i$ 的富集节点 $i$，使用 $N_i(\\boldsymbol{x}) \\left(F_k(\\boldsymbol{x}) - F_k(\\boldsymbol{x}_i)\\right)$。\n  2. 斜坡函数修正：将位移富集乘以一个斜坡函数 $R(\\boldsymbol{x}) = \\sum_{j \\in \\mathcal{E}_e} N_j(\\boldsymbol{x})$，其中 $\\mathcal{E}_e$ 是当前单元的富集节点集合，得到 $N_i(\\boldsymbol{x}) R(\\boldsymbol{x}) \\left(F_k(\\boldsymbol{x}) - F_k(\\boldsymbol{x}_i)\\right)$。该斜坡函数在富集片区的边界上消失，从而消除了混合单元中的单位分解污染。\n\n您的任务是在单位正方形域 $\\Omega = [0,1]^2$ 上实现一个 $L^2$ 投影实验，比较两种富集策略的收敛性：\n\n- 策略 A（仅位移）：标准双线性基加上无斜坡函数的位移尖端富集。\n- 策略 B（斜坡函数修正）：标准双线性基加上乘以斜坡函数的位移尖端富集。\n\n您不需要求解一个边值问题。相反，您将通过最小化 $L^2$ 误差，将一个已知的混合模式“目标”场 $u^\\star(\\boldsymbol{x})$ 投影到每个离散空间上，然后在网格细化和改变裂纹尖端与网格角点邻近度的情况下，测量收敛率。\n\n实验定义：\n\n- 网格：一个由尺寸为 $h = 1/N$ 的双线性四边形单元组成的均匀张量积网格，其中 $N \\in \\mathbb{N}$ 是沿每个轴的单元数。每个单元上使用标准双线性形函数 $N_1,\\dots,N_4$。\n- 富集节点：距离裂纹尖端 $\\boldsymbol{x}_t$ 半径 $r_e = \\alpha h$ 范围内的节点，其中 $\\alpha = 2$。富集节点每个节点携带两个富集自由度，与 $F_1$ 和 $F_2$ 相关。\n- 目标场：对于系数 $a_{\\mathrm{I}}$ 和 $a_{\\mathrm{II}}$，定义\n  $$u^\\star(\\boldsymbol{x}) = a_{\\mathrm{I}} F_1(\\boldsymbol{x}) + a_{\\mathrm{II}} F_2(\\boldsymbol{x}).$$\n  角度必须以弧度计算。局部极坐标由以下公式定义\n  $$\\begin{pmatrix} x' \\\\ y' \\end{pmatrix} = \\begin{pmatrix} \\cos\\varphi  \\sin\\varphi \\\\ -\\sin\\varphi  \\cos\\varphi \\end{pmatrix} \\left(\\begin{pmatrix} x \\\\ y \\end{pmatrix} - \\begin{pmatrix} x_t \\\\ y_t \\end{pmatrix}\\right), \\quad r = \\sqrt{(x')^2 + (y')^2}, \\quad \\theta = \\operatorname{atan2}(y',x').$$\n- 离散空间：\n  - 令 $\\mathcal{S}_h$ 表示由所有网格节点形函数张成的标准双线性空间。\n  - 令 $\\mathcal{S}_h^{\\mathrm{A}}$ 为 $\\mathcal{S}_h$ 增强后的空间，对于每个富集节点 $i$ 和每个 $k \\in \\{1,2\\}$，增加了函数 $N_i(\\boldsymbol{x})\\left(F_k(\\boldsymbol{x}) - F_k(\\boldsymbol{x}_i)\\right)$。\n  - 令 $\\mathcal{S}_h^{\\mathrm{B}}$ 为 $\\mathcal{S}_h$ 增强后的空间，增加了函数 $N_i(\\boldsymbol{x}) R(\\boldsymbol{x})\\left(F_k(\\boldsymbol{x}) - F_k(\\boldsymbol{x}_i)\\right)$，其中在单元级别上 $R(\\boldsymbol{x}) = \\sum_{j \\in \\mathcal{E}_e} N_j(\\boldsymbol{x})$。\n- 投影问题：在所选的离散空间中找到 $u_h$，使得\n  $$J(u_h) = \\int_{\\Omega} \\left(u_h(\\boldsymbol{x}) - u^\\star(\\boldsymbol{x})\\right)^2 \\, \\mathrm{d}\\boldsymbol{x}$$\n  最小化。这等价于求解法方程 $M \\boldsymbol{c} = \\boldsymbol{b}$，其中\n  $$M_{pq} = \\int_{\\Omega} \\Phi_p(\\boldsymbol{x}) \\, \\Phi_q(\\boldsymbol{x}) \\, \\mathrm{d}\\boldsymbol{x}, \\quad b_p = \\int_{\\Omega} \\Phi_p(\\boldsymbol{x}) \\, u^\\star(\\boldsymbol{x}) \\, \\mathrm{d}\\boldsymbol{x},$$\n  $\\{\\Phi_p\\}$ 是所选离散空间的全局基函数。数值积分使用每个单元至少 $4 \\times 4$ 点的高斯求积。如果为了数值稳定性需要，可以向 $M$ 添加一个 Tikhonov 正则化项 $\\epsilon I$，其中 $\\epsilon = 10^{-12}$。\n- 误差与收敛率：计算 $L^2$ 误差\n  $$E(h) = \\left(\\int_{\\Omega} \\left(u_h(\\boldsymbol{x}) - u^\\star(\\boldsymbol{x})\\right)^2 \\, \\mathrm{d}\\boldsymbol{x}\\right)^{1/2}。$$\n  对于网格尺寸为 $h_1,h_2,h_3$ 的细化序列，通过对 $\\left(\\log h_j, \\log E(h_j)\\right)$ 进行线性回归来计算经验收敛率 $p$。\n\n您的程序必须实现策略 A 和 B，并对以下三个测试案例中的每一个评估经验收敛率。在所有案例中，域为 $\\Omega = [0,1]^2$，裂纹尖端位于 $\\boldsymbol{x}_t = \\left(0.5 + \\delta,\\, 0.5 + \\delta\\right)$，经过网格节点 $\\left(0.5,\\, 0.5\\right)$ 附近。使用细化序列 $N \\in \\{8,16,24\\}$（因此 $h \\in \\{1/8,1/16,1/24\\}$）。角度必须为弧度。\n\n- 测试案例 1（理想情况，均衡混合模式，中等邻近度）：\n  - $\\delta = 0.02$\n  - $\\varphi = \\pi/6$\n  - $a_{\\mathrm{I}} = 1.0$\n  - $a_{\\mathrm{II}} = 1.0$\n- 测试案例 2（边缘邻近度，模式混合倾斜）：\n  - $\\delta = 0.005$\n  - $\\varphi = \\pi/3$\n  - $a_{\\mathrm{I}} = 1.0$\n  - $a_{\\mathrm{II}} = 0.3$\n- 测试案例 3（不同方向，反向混合，中等邻近度）：\n  - $\\delta = 0.03$\n  - $\\varphi = -\\pi/4$\n  - $a_{\\mathrm{I}} = 0.7$\n  - $a_{\\mathrm{II}} = 1.3$\n\n最终要求的输出格式：\n\n- 对每个测试案例，分别计算策略 A 和 B 的经验收敛率 $p_{\\mathrm{A}}$ 和 $p_{\\mathrm{B}}$，以及改进量 $\\Delta p = p_{\\mathrm{B}} - p_{\\mathrm{A}}$。\n- 您的程序应生成单行输出，其中包含一个浮点数列表的列表形式的结果，每个内部列表对应一个测试案例，按上述测试案例的顺序排列，其中每个内部列表为 $[p_{\\mathrm{A}}, p_{\\mathrm{B}}, \\Delta p]$。例如，一个带有占位符的有效输出是 $[[0.9,1.3,0.4],[\\dots],[\\dots]]$。\n\n所有量均为无量纲。角度必须为弧度。没有物理单位。确保数值积分和组装在科学上是合理且自洽的。程序必须是完整的，并能按规定运行。不要读取任何输入；只需计算并打印最终列表。不要对任何数值进行四舍五入；按计算产生的原始浮点数打印。",
            "solution": "用户要求设计并实现一个数值实验，以研究扩展有限元法（XFEM）中的混合单元污染问题。该问题是自洽的，在计算力学和数值分析原理方面具有扎实的科学基础，并提供了一套完整而明确的规范。所有必需的参数、数学定义和程序都已清晰说明，使得该问题有效且可解。\n\n问题的核心是将一个已知的解析场 $u^\\star(\\boldsymbol{x})$ 进行 $L^2$ 投影到两个不同的 XFEM 离散空间上。这使得可以在与求解偏微分方程的其他方面相分离的情况下，评估这些空间的近似质量。这两个空间，表示为 $\\mathcal{S}_h^{\\mathrm{A}}$ 和 $\\mathcal{S}_h^{\\mathrm{B}}$，代表了在混合单元（即与裂纹尖端富集区域相邻的单元）中构造富集基函数的两种常用策略。\n\n- **策略 A** 使用“位移”富集，其中基函数的形式为 $N_i(\\boldsymbol{x}) \\left(F_k(\\boldsymbol{x}) - F_k(\\boldsymbol{x}_i)\\right)$。这里，$N_i$ 是节点 $i$ 的标准有限元形函数，$F_k$ 是一个渐近裂纹尖端函数。减去节点处的函数值 $F_k(\\boldsymbol{x}_i)$ 确保了富集项在节点 $i$ 处为零，这是一个理想属性。然而，这种构造不能保证单位分解特性 $\\sum_i N_i(\\boldsymbol{x}) = 1$ 可以被分离出来，从而导致所谓的“污染”或近似能力的损失。\n\n- **策略 B** 引入了一个“斜坡”函数 $R(\\boldsymbol{x})$，它乘以位移富集项。基函数为 $N_i(\\boldsymbol{x}) R(\\boldsymbol{x})\\left(F_k(\\boldsymbol{x}) - F_k(\\boldsymbol{x}_i)\\right)$。斜坡函数 $R(\\boldsymbol{x}) = \\sum_{j \\in \\mathcal{E}_e} N_j(\\boldsymbol{x})$ 在每个单元上定义为仅对应于该单元富集节点 $\\mathcal{E}_e$ 的形函数之和。这个斜坡函数在富集节点处等于 $1$，并在富集单元片区的边界上平滑地趋于 $0$。此特性有效地消除了混合单元中的单位分解污染。\n\n该实验旨在通过考察网格细化时 $L^2$ 误差的经验收敛率，来量化策略 B 相对于策略 A 的改进效果。\n\n实现将按以下步骤进行：\n\n1.  **网格与离散化**：在单位正方形 $\\Omega = [0,1]^2$ 上定义一个均匀的 $N \\times N$ 双线性四边形单元网格。如果节点位于裂纹尖端 $\\boldsymbol{x}_t$ 的指定半径 $r_e = \\alpha h$ 内，则将其识别为“富集”节点。\n\n2.  **基函数**：构造全局基函数集 $\\{\\Phi_p\\}$。它包括：\n    a. 网格中所有节点 $i$ 的标准双线性形函数 $N_i(\\boldsymbol{x})$。\n    b. 每个富集节点的富集函数，对应于两个裂纹尖端渐近函数 $F_1(\\boldsymbol{x}) = \\sqrt{r}\\cos(\\theta/2)$ 和 $F_2(\\boldsymbol{x}) = \\sqrt{r}\\sin(\\theta/2)$。具体形式取决于所选的策略（A 或 B）。\n\n3.  **$L^2$ 投影**：为在离散空间中找到 $u^\\star$ 的最佳近似 $u_h$，我们必须解法方程 $M \\boldsymbol{c} = \\boldsymbol{b}$。\n    - 组装质量矩阵 $M_{pq} = \\int_{\\Omega} \\Phi_p(\\boldsymbol{x}) \\Phi_q(\\boldsymbol{x}) \\, \\mathrm{d}\\boldsymbol{x}$ 和右端向量 $b_p = \\int_{\\Omega} \\Phi_p(\\boldsymbol{x}) u^\\star(\\boldsymbol{x}) \\, \\mathrm{d}\\boldsymbol{x}$。\n    - 这涉及到遍历网格中的每个单元，并在每个单元上使用高斯求积（按规定每个单元 $4 \\times 4$ 点）对基函数的乘积进行数值积分。然后将单元级矩阵和向量组装到全局系统中。\n\n4.  **误差与收敛**：求解系数向量 $\\boldsymbol{c}$ 后，平方 $L^2$ 误差可以通过关系式 $E^2 = \\int_{\\Omega} (u^\\star)^2 \\mathrm{d}\\boldsymbol{x} - \\boldsymbol{c}^T \\boldsymbol{b}$ 高效计算。对一系列网格细化（$N = 8, 16, 24$）重复此过程。然后通过对误差与网格尺寸的对数-对数图，即 $(\\log h_j, \\log E(h_j))$，进行线性回归来确定经验收敛率 $p$。\n\n5.  **测试案例**：对三个不同的测试案例执行整个过程，每个案例具有不同的裂纹尖端位置、方向和目标场 $u^\\star$ 的混合模式系数。这测试了方法在不同条件下的鲁棒性，特别是裂纹尖端与单元边界的邻近程度，在这些地方污染效应最为显著。\n\n最终输出将是一个列表，其中包含每个测试案例计算出的收敛率（$p_{\\mathrm{A}}$，$p_{\\mathrm{B}}$）及其差异（$\\Delta p = p_{\\mathrm{B}} - p_{\\mathrm{A}}$），并精确遵循指定的格式。",
            "answer": "```python\nimport numpy as np\n\ndef get_polar_coords(x, y, x_t, y_t, phi):\n    \"\"\"Computes local polar coordinates (r, theta) for a point (x, y).\"\"\"\n    dx = x - x_t\n    dy = y - y_t\n    c, s = np.cos(phi), np.sin(phi)\n    \n    x_prime = dx * c + dy * s\n    y_prime = -dx * s + dy * c\n    \n    r = np.sqrt(x_prime**2 + y_prime**2)\n    theta = np.arctan2(y_prime, x_prime)\n    return r, theta\n\ndef F1_func(r, theta):\n    \"\"\"Enrichment function F1.\"\"\"\n    return np.sqrt(r) * np.cos(theta / 2.0)\n\ndef F2_func(r, theta):\n    \"\"\"Enrichment function F2.\"\"\"\n    return np.sqrt(r) * np.sin(theta / 2.0)\n\ndef u_star_func(x, y, x_t, y_t, phi, a_I, a_II):\n    \"\"\"Target field u*.\"\"\"\n    if (x == x_t and y == y_t): # Avoid singularity at the tip\n        return 0.0\n    r, theta = get_polar_coords(x, y, x_t, y_t, phi)\n    return a_I * F1_func(r, theta) + a_II * F2_func(r, theta)\n\ndef calculate_convergence_rate(hs, errors):\n    \"\"\"Computes empirical convergence rate p from log(h) vs log(E).\"\"\"\n    log_h = np.log(np.array(hs))\n    log_E = np.log(np.array(errors))\n    \n    # Linear regression for p (slope)\n    n = len(log_h)\n    sum_x = np.sum(log_h)\n    sum_y = np.sum(log_E)\n    sum_xy = np.sum(log_h * log_E)\n    sum_x2 = np.sum(log_h**2)\n    \n    denominator = n * sum_x2 - sum_x**2\n    if denominator == 0:\n        return np.nan\n    \n    p = (n * sum_xy - sum_x * sum_y) / denominator\n    return p\n\ndef run_projection(N, delta, phi, a_I, a_II, strategy):\n    \"\"\"\n    Performs the L2-projection for a given mesh and strategy.\n    Returns the L2 norm of the error.\n    \"\"\"\n    h = 1.0 / N\n    x_t, y_t = 0.5 + delta, 0.5 + delta\n    alpha = 2.0\n    r_e = alpha * h\n    epsilon = 1.0e-12\n    \n    # Quadrature setup (4x4 points)\n    num_quad_pts_1d = 4\n    quad_pts_1d, quad_wts_1d = np.polynomial.legendre.leggauss(num_quad_pts_1d)\n\n    # Node and DOF Management\n    num_nodes = (N + 1)**2\n    nodes = np.array([(i * h, j * h) for j in range(N + 1) for i in range(N + 1)])\n    \n    distances_to_tip = np.sqrt((nodes[:, 0] - x_t)**2 + (nodes[:, 1] - y_t)**2)\n    enriched_node_indices = np.where(distances_to_tip = r_e)[0]\n    \n    num_enriched = len(enriched_node_indices)\n    enriched_idx_map = {node_idx: i for i, node_idx in enumerate(enriched_node_indices)}\n    \n    num_dofs = num_nodes + 2 * num_enriched\n\n    M = np.zeros((num_dofs, num_dofs))\n    b = np.zeros(num_dofs)\n    u_star_sq_integral = 0.0\n\n    F_at_nodes = {}\n    for node_idx in enriched_node_indices:\n        nx, ny = nodes[node_idx]\n        r_n, theta_n = get_polar_coords(nx, ny, x_t, y_t, phi)\n        F_at_nodes[node_idx] = (F1_func(r_n, theta_n), F2_func(r_n, theta_n))\n\n    # Element assembly loop\n    for j_el in range(N):\n        for i_el in range(N):\n            n0_idx = j_el * (N + 1) + i_el\n            n1_idx = n0_idx + 1\n            n2_idx = (j_el + 1) * (N + 1) + i_el + 1\n            n3_idx = (j_el + 1) * (N + 1) + i_el\n            elem_nodes = [n0_idx, n1_idx, n2_idx, n3_idx]\n            \n            elem_enriched_nodes_indices = [idx for idx in elem_nodes if idx in enriched_idx_map]\n\n            local_to_global_dof = []\n            local_to_global_dof.extend(elem_nodes)\n            for node_idx in elem_nodes:\n                if node_idx in enriched_idx_map:\n                    enriched_local_idx = enriched_idx_map[node_idx]\n                    local_to_global_dof.append(num_nodes + enriched_local_idx)\n                    local_to_global_dof.append(num_nodes + num_enriched + enriched_local_idx)\n            \n            num_elem_dofs = len(local_to_global_dof)\n            Me = np.zeros((num_elem_dofs, num_elem_dofs))\n            be = np.zeros(num_elem_dofs)\n\n            x_min, y_min = i_el * h, j_el * h\n            \n            for j_q in range(num_quad_pts_1d):\n                for i_q in range(num_quad_pts_1d):\n                    xi, eta = quad_pts_1d[i_q], quad_pts_1d[j_q]\n                    weight = quad_wts_1d[i_q] * quad_wts_1d[j_q]\n                    \n                    x_q = x_min + (1 + xi) / 2.0 * h\n                    y_q = y_min + (1 + eta) / 2.0 * h\n                    dArea = (h / 2.0)**2 * weight\n                    \n                    u_star_val = u_star_func(x_q, y_q, x_t, y_t, phi, a_I, a_II)\n                    u_star_sq_integral += u_star_val**2 * dArea\n                    \n                    N_vals = np.array([\n                        0.25 * (1 - xi) * (1 - eta), 0.25 * (1 + xi) * (1 - eta),\n                        0.25 * (1 + xi) * (1 + eta), 0.25 * (1 - xi) * (1 + eta)\n                    ])\n                    \n                    r_q, theta_q = get_polar_coords(x_q, y_q, x_t, y_t, phi)\n                    F1_q, F2_q = F1_func(r_q, theta_q), F2_func(r_q, theta_q)\n                    \n                    ramp_val = 1.0\n                    if strategy == 'B':\n                        ramp_val = 0.0\n                        for i_node, node_idx in enumerate(elem_nodes):\n                            if node_idx in elem_enriched_nodes_indices:\n                                ramp_val += N_vals[i_node]\n                    \n                    phi_vals = np.zeros(num_elem_dofs)\n                    dof_counter = 0\n\n                    phi_vals[:4] = N_vals\n                    dof_counter = 4\n\n                    for i_node, node_idx in enumerate(elem_nodes):\n                        if node_idx in enriched_idx_map:\n                            F1_n, F2_n = F_at_nodes[node_idx]\n                            phi_vals[dof_counter] = N_vals[i_node] * ramp_val * (F1_q - F1_n)\n                            dof_counter += 1\n                            phi_vals[dof_counter] = N_vals[i_node] * ramp_val * (F2_q - F2_n)\n                            dof_counter += 1\n                    \n                    Me += np.outer(phi_vals, phi_vals) * dArea\n                    be += phi_vals * u_star_val * dArea\n            \n            ix = np.ix_(local_to_global_dof, local_to_global_dof)\n            M[ix] += Me\n            b[local_to_global_dof] += be\n\n    # Solve and Compute Error\n    M += epsilon * np.eye(num_dofs)\n    \n    try:\n        c = np.linalg.solve(M, b)\n        error_sq = u_star_sq_integral - np.dot(c, b)\n        error = np.sqrt(max(0, error_sq))\n    except np.linalg.LinAlgError:\n        error = np.nan\n\n    return error\n\ndef solve():\n    \"\"\"\n    Main orchestrator for the XFEM projection experiment.\n    Defines test cases, computes convergence rates for each strategy, and prints the results.\n    \"\"\"\n    test_cases = [\n        (0.02, np.pi/6, 1.0, 1.0),\n        (0.005, np.pi/3, 1.0, 0.3),\n        (0.03, -np.pi/4, 0.7, 1.3)\n    ]\n    N_values = [8, 16, 24]\n    all_results = []\n\n    for case_params in test_cases:\n        delta, phi, a_I, a_II = case_params\n        \n        hs = [1.0 / N for N in N_values]\n        \n        errors_A = [run_projection(N, delta, phi, a_I, a_II, 'A') for N in N_values]\n        p_A = calculate_convergence_rate(hs, errors_A)\n\n        errors_B = [run_projection(N, delta, phi, a_I, a_II, 'B') for N in N_values]\n        p_B = calculate_convergence_rate(hs, errors_B)\n\n        delta_p = p_B - p_A\n        all_results.append([p_A, p_B, delta_p])\n\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在岩土力学中，真实的非连续面（如节理和断层）表现出复杂的非线性行为，如接触、黏聚和摩擦。模拟这些行为需要在 XFEM 框架中集成复杂的本构模型。本练习从裂纹的几何表示转向界面上的力学行为，您将为黏聚-摩擦接触定律推导一致算法切线，这是求解非线性问题的 Newton-Raphson 方法的基石 。掌握这种理论推导对于实现稳定且快速收敛的隐式求解方案至关重要，它将巩固您对局部本构更新如何线性化并集成到全局非线性求解器中的理解。",
            "id": "3523088",
            "problem": "考虑一个二维小变形固体，其内部的位移不连续由一个符号距离函数 $\\phi(\\mathbf{x})=0$ 的零水平集隐式表示。在扩展有限元法 (XFEM) 中，位移场通过亥维赛函数 (Heaviside function) 进行增强，使得增强部分在 $\\phi=0$ 上产生位移跳跃。关注界面上的单个积分点 $\\mathbf{x}^{\\star}$，其单位法向量为 $\\mathbf{n}$，单位切向量为 $\\mathbf{t}$。局部-位移跳跃 $\\mathbf{g}=\\begin{pmatrix} g_{n} \\\\ g_{t} \\end{pmatrix}$ 定义为将增强位移差投影到 $(\\mathbf{n},\\mathbf{t})$ 上。假设由于在 $\\mathbf{x}^{\\star}$ 点的局部形函数插值，间隙 $\\mathbf{g}$ 与该点的增强自由度向量重合，因此从增强自由度到 $\\mathbf{g}$ 的映射是单位映射。假设准静态条件，并且接触在压缩状态下激活，其中 $g_{n}\\ge 0$ 且无张开。\n\n在界面上，牵引力向量 $\\mathbf{t}=\\begin{pmatrix} t_{n} \\\\ t_{t} \\end{pmatrix}$ 在局部坐标系 $(\\mathbf{n},\\mathbf{t})$ 中由一个黏性摩擦定律控制：\n- 法向响应：$t_{n}=k_{n}\\,g_{n}$，其中 $k_{n}0$。\n- 切向响应：一个带有罚参数 $k_{t}0$ 的弹性预测器，以及一个库仑 (Coulomb) 型的摩擦屈服函数 $f=\\lvert t_{t}\\rvert - \\mu\\,t_{n} - H\\,p \\le 0$，其中摩擦系数 $\\mu0$，关于累积滑移 $p$ 的线性各向同性硬化模量 $H0$，以及相关联的切向塑性流动 $dp=\\lvert d\\lambda\\rvert$, $dg_{t}^{p}=d\\lambda\\,\\operatorname{sign}(t_{t})$，其中 $d\\lambda\\ge 0$ 是塑性乘子增量。假设在一个给定的牛顿 (Newton) 步内 $\\operatorname{sign}(t_{t})$ 保持不变。在粘滞状态下，$f0$ 且 $t_{t}=k_{t}\\,g_{t}$。在滑移状态下，$f=0$ 且一致性条件成立。\n\n你正在使用牛顿法 (Newton’s method) 求解 $\\mathbf{x}^{\\star}$ 点的局部界面平衡方程，以求得间隙 $\\mathbf{g}$，该方法应用于残差 $\\mathbf{r}(\\mathbf{g})=\\mathbf{t}(\\mathbf{g})-\\boldsymbol{\\tau}^{\\star}=\\mathbf{0}$，其中 $\\boldsymbol{\\tau}^{\\star}$ 是周围体在 $\\mathbf{x}^{\\star}$ 点所要求的牵引力。牛顿法由在当前状态下评估的一致性线性化（算法切线）$\\mathbf{C}=\\partial \\mathbf{t}/\\partial \\mathbf{g}$ 驱动。\n\n任务：\n1) 从上述本构定义出发，并在滑移情况下强制执行一致性条件，推导粘滞和滑移两种情况的一致性算法切线 $\\mathbf{C}=\\partial \\mathbf{t}/\\partial \\mathbf{g}$，并以 $(\\mathbf{n},\\mathbf{t})$ 基下的 $2\\times 2$ 矩阵形式表示。你的推导必须消去塑性乘子增量 $d\\lambda$ 和累积滑移增量 $dp$，以微分量 $dg_{n}$ 和 $dg_{t}$ 表示。\n2) 使用你的结果解释为什么当激活集（粘滞或滑移）不变时，采用此一致性切线的牛顿法对增强界面问题表现出二次局部收敛性，尽管界面上存在位移跳跃且其他位置可能发生粘滑转换。\n3) 现在具体到一个滑移点，其 $\\operatorname{sign}(t_{t})=+1$，参数为 $k_{n}=2.0\\times 10^{8}$、$k_{t}=1.0\\times 10^{8}$、$\\mu=0.6$ 和 $H=5.0\\times 10^{7}$（所有单位均一致）。使用任务1中得到的一致性切线，将牛顿迭代应用于 $\\mathbf{r}(\\mathbf{g})=\\mathbf{t}(\\mathbf{g})-\\boldsymbol{\\tau}^{\\star}$。计算与此滑移状态相关解处的线性化牛顿误差传播算子的谱半径 $\\rho$。将你的最终答案表示为一个无单位的实数。无需四舍五入。",
            "solution": "该问题要求推导黏性摩擦界面定律的一致性算法切线，解释相关牛顿-拉夫逊 (Newton-Raphson) 格式的收敛特性，并计算一个特定情况下的谱半径。\n\n局部问题是找到间隙向量 $\\mathbf{g} = \\begin{pmatrix} g_n \\\\ g_t \\end{pmatrix}$，使其解出平衡方程 $\\mathbf{r}(\\mathbf{g}) = \\mathbf{t}(\\mathbf{g}) - \\boldsymbol{\\tau}^{\\star} = \\mathbf{0}$，其中 $\\mathbf{t}(\\mathbf{g}) = \\begin{pmatrix} t_n(g_n) \\\\ t_t(g_n, g_t) \\end{pmatrix}$ 是由本构律得到的牵引力向量，而 $\\boldsymbol{\\tau}^{\\star}$ 是给定的外部牵引力。这个问题用牛顿法求解，该方法需要残差的雅可比矩阵，即 $\\mathbf{C} = \\frac{\\partial \\mathbf{r}}{\\partial \\mathbf{g}} = \\frac{\\partial \\mathbf{t}}{\\partial \\mathbf{g}}$，这被称为一致性算法切线。\n\n### 任务 1：一致性算法切线的推导\n\n我们寻求一个 $2 \\times 2$ 矩阵 $\\mathbf{C}$，使得 $d\\mathbf{t} = \\mathbf{C}d\\mathbf{g}$，其中 $d\\mathbf{t} = \\begin{pmatrix} dt_n \\\\ dt_t \\end{pmatrix}$ 且 $d\\mathbf{g} = \\begin{pmatrix} dg_n \\\\ dg_t \\end{pmatrix}$。\n\n法向牵引力 $t_n$ 由线性关系 $t_n = k_n g_n$ 给出。其微分是直接的：\n$$dt_n = k_n dg_n$$\n这决定了 $\\mathbf{C}$ 的第一行：$\\frac{\\partial t_n}{\\partial g_n} = k_n$ 且 $\\frac{\\partial t_n}{\\partial g_t} = 0$。\n\n切向响应是弹塑性的。总切向间隙增量 $dg_t$ 加性分解为一个弹性部分 $dg_t^e$ 和一个塑性部分 $dg_t^p$：\n$$dg_t = dg_t^e + dg_t^p$$\n切向牵引力通过罚刚度 $k_t$ 与间隙的弹性部分相关联：\n$$t_t = k_t g_t^e$$\n微分形式为 $dt_t = k_t dg_t^e$。代入 $dg_t^e = dg_t - dg_t^p$，我们得到：\n$$dt_t = k_t (dg_t - dg_t^p)$$\n塑性流动法则给出为 $dg_t^p = d\\lambda \\operatorname{sign}(t_t)$，其中 $d\\lambda \\ge 0$ 是塑性乘子增量。令 $s_t = \\operatorname{sign}(t_t)$。则：\n$$dt_t = k_t (dg_t - s_t d\\lambda)$$\n这个关系是通用的。$d\\lambda$ 的值区分了粘滞和滑移两种情况。\n\n**情况 1：粘滞**\n在粘滞状态下，屈服函数未激活，$f  0$。对于足够小的载荷增量，状态保持弹性，没有塑性流动。\n$$d\\lambda = 0$$\n因此，$dg_t^p=0$，牵引力增量是纯弹性的：\n$$dt_t = k_t dg_t$$\n在这种情况下，切向牵引力不依赖于法向间隙，所以 $\\frac{\\partial t_t}{\\partial g_n} = 0$。导数为 $\\frac{\\partial t_t}{\\partial g_n} = 0$ 和 $\\frac{\\partial t_t}{\\partial g_t} = k_t$。\n粘滞情况的一致性切线 $\\mathbf{C}_{\\text{stick}}$ 是对角弹性切线矩阵：\n$$\\mathbf{C}_{\\text{stick}} = \\begin{pmatrix} k_n  0 \\\\ 0  k_t \\end{pmatrix}$$\n\n**情况 2：滑移**\n在滑移状态下，牵引力状态位于屈服面上，$f=0$，并在进一步加载时保持在该面上，这意味着一致性条件 $df=0$ 成立。屈服函数为：\n$$f = |t_t| - \\mu t_n - H p = s_t t_t - \\mu t_n - H p = 0$$\n微分形式的一致性条件是：\n$$df = s_t dt_t - \\mu dt_n - H dp = 0$$\n累积滑移增量为 $dp = |d\\lambda| = d\\lambda$。代入 $dt_t$、$dt_n$ 和 $dp$ 的表达式：\n$$s_t \\left( k_t (dg_t - s_t d\\lambda) \\right) - \\mu (k_n dg_n) - H (d\\lambda) = 0$$\n$$s_t k_t dg_t - k_t s_t^2 d\\lambda - \\mu k_n dg_n - H d\\lambda = 0$$\n由于 $s_t^2 = 1$，我们可以合并项来解出 $d\\lambda$：\n$$(k_t + H) d\\lambda = s_t k_t dg_t - \\mu k_n dg_n$$\n$$d\\lambda = \\frac{s_t k_t dg_t - \\mu k_n dg_n}{k_t + H}$$\n现在，我们将 $d\\lambda$ 的这个表达式代回到 $dt_t$ 的关系式中：\n$$dt_t = k_t(dg_t - s_t d\\lambda) = k_t \\left( dg_t - s_t \\frac{s_t k_t dg_t - \\mu k_n dg_n}{k_t + H} \\right)$$\n$$dt_t = k_t \\left( \\frac{(k_t + H)dg_t - (s_t^2 k_t dg_t - s_t \\mu k_n dg_n)}{k_t + H} \\right)$$\n$$dt_t = \\frac{k_t}{k_t + H} \\left( k_t dg_t + H dg_t - k_t dg_t + s_t \\mu k_n dg_n \\right)$$\n$$dt_t = \\frac{k_t s_t \\mu k_n}{k_t + H} dg_n + \\frac{k_t H}{k_t + H} dg_t$$\n从这个表达式和 $dt_n = k_n dg_n + 0 \\cdot dg_t$ 中，我们可以确定滑移情况的一致性切线矩阵 $\\mathbf{C}_{\\text{slide}}$ 的分量：\n$$\\frac{\\partial t_t}{\\partial g_n} = \\frac{s_t \\mu k_n k_t}{k_t + H} \\quad \\text{和} \\quad \\frac{\\partial t_t}{\\partial g_t} = \\frac{k_t H}{k_t + H}$$\n完整的矩阵是：\n$$\\mathbf{C}_{\\text{slide}} = \\begin{pmatrix} k_n  0 \\\\ \\frac{s_t \\mu k_n k_t}{k_t + H}  \\frac{k_t H}{k_t + H} \\end{pmatrix}$$\n这个矩阵是非对称的，这在具有非关联流动法则的塑性模型中，或者像本例这样，在不同分量（法向弹性和切向塑性）之间存在耦合的情况下很常见。\n\n### 任务 2：二次收敛性的解释\n\n牛顿-拉夫逊 (Newton-Raphson) 方法用于寻找残差方程 $\\mathbf{r}(\\mathbf{g})=\\mathbf{0}$ 的根 $\\mathbf{g}^*$。该方法的一次迭代形式如下：\n$$\\mathbf{g}_{k+1} = \\mathbf{g}_k - [\\mathbf{J}_{\\mathbf{r}}(\\mathbf{g}_k)]^{-1} \\mathbf{r}(\\mathbf{g}_k)$$\n其中 $\\mathbf{J}_{\\mathbf{r}}(\\mathbf{g}_k)$ 是在当前迭代点 $\\mathbf{g}_k$ 处评估的残差函数 $\\mathbf{r}$ 的雅可比矩阵。在我们的问题中，$\\mathbf{J}_{\\mathbf{r}}(\\mathbf{g}) = \\frac{\\partial \\mathbf{r}}{\\partial \\mathbf{g}} = \\frac{\\partial \\mathbf{t}}{\\partial \\mathbf{g}} = \\mathbf{C}(\\mathbf{g})$。因此，迭代过程为：\n$$\\mathbf{g}_{k+1} = \\mathbf{g}_k - [\\mathbf{C}(\\mathbf{g}_k)]^{-1} \\mathbf{r}(\\mathbf{g}_k)$$\n牛顿-拉夫逊方法的收敛速度取决于其迭代映射函数 $\\mathbf{F}(\\mathbf{g}) = \\mathbf{g} - [\\mathbf{C}(\\mathbf{g})]^{-1} \\mathbf{r}(\\mathbf{g})$ 的性质。第 $k+1$ 次迭代的误差与第 $k$ 次迭代的误差通过在解 $\\mathbf{g}^*$ 附近对 $\\mathbf{F}$ 进行泰勒展开相关联。此展开中的一阶项由该映射的雅可比矩阵 $\\mathbf{J}_{\\mathbf{F}}(\\mathbf{g}^*) = \\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{g}}|_{\\mathbf{g}^*}$ 决定。\n让我们计算这个雅可比矩阵：\n$$\\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{g}} = \\frac{\\partial}{\\partial \\mathbf{g}} \\left( \\mathbf{g} - [\\mathbf{C}(\\mathbf{g})]^{-1} \\mathbf{r}(\\mathbf{g}) \\right) = \\mathbf{I} - \\frac{\\partial}{\\partial \\mathbf{g}} \\left( [\\mathbf{C}(\\mathbf{g})]^{-1} \\mathbf{r}(\\mathbf{g}) \\right)$$\n使用乘法法则：\n$$\\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{g}} = \\mathbf{I} - \\left( \\frac{\\partial([\\mathbf{C}(\\mathbf{g})]^{-1})}{\\partial \\mathbf{g}} \\mathbf{r}(\\mathbf{g}) + [\\mathbf{C}(\\mathbf{g})]^{-1} \\frac{\\partial \\mathbf{r}(\\mathbf{g})}{\\partial \\mathbf{g}} \\right)$$\n我们知道 $\\frac{\\partial \\mathbf{r}}{\\partial \\mathbf{g}} = \\mathbf{C}(\\mathbf{g})$。所以第二项简化为 $[\\mathbf{C}(\\mathbf{g})]^{-1} \\mathbf{C}(\\mathbf{g}) = \\mathbf{I}$。\n$$\\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{g}} = \\mathbf{I} - \\left( \\frac{\\partial([\\mathbf{C}(\\mathbf{g})]^{-1})}{\\partial \\mathbf{g}} \\mathbf{r}(\\mathbf{g}) + \\mathbf{I} \\right) = - \\frac{\\partial([\\mathbf{C}(\\mathbf{g})]^{-1})}{\\partial \\mathbf{g}} \\mathbf{r}(\\mathbf{g})$$\n为了获得局部收敛速度，我们在解 $\\mathbf{g}^*$ 处评估此雅可比矩阵。根据定义，$\\mathbf{r}(\\mathbf{g}^*) = \\mathbf{0}$。因此：\n$$\\mathbf{J}_{\\mathbf{F}}(\\mathbf{g}^*) = - \\frac{\\partial([\\mathbf{C}(\\mathbf{g})]^{-1})}{\\partial \\mathbf{g}}\\bigg|_{\\mathbf{g}^*} \\mathbf{r}(\\mathbf{g}^*) = \\mathbf{0}$$\n牛顿迭代映射的雅可比矩阵在解处为零矩阵。这是至少二次收敛的条件。这个结果成立是因为牛顿更新中使用的切线 $\\mathbf{C}$ 是算法残差的*精确*或*一致*雅可比矩阵。限定条件“当激活集（粘滞或滑移）不变时”至关重要，因为它确保了函数 $\\mathbf{r}(\\mathbf{g})$ 在解的邻域内是连续可微的，这是进行泰勒级数分析的先决条件。通过问题的假设，XFEM 和全局问题的复杂性被解耦，使得二次收敛成为局部本构求解器的一个性质。\n\n### 任务 3：谱半径的计算\n\n“线性化牛顿误差传播算子”是在解 $\\mathbf{g}^*$ 处评估的牛顿迭代映射 $\\mathbf{F}(\\mathbf{g})$ 的雅可比矩阵。该算子，我们记为 $\\mathbf{G}$，对于小误差控制着误差 $\\mathbf{e}_k = \\mathbf{g}_k - \\mathbf{g}^*$ 的传播：$\\mathbf{e}_{k+1} \\approx \\mathbf{G} \\mathbf{e}_k$。\n如任务2中所推导，该算子为：\n$$\\mathbf{G} = \\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{g}}\\bigg|_{\\mathbf{g}^*} = \\mathbf{0}$$\n该算子是 $2 \\times 2$ 的零矩阵。零矩阵的特征值全为零。谱半径 $\\rho(\\mathbf{G})$ 定义为特征值绝对值的最大值。\n对于零矩阵，特征值为 $\\lambda_1 = 0$ 和 $\\lambda_2 = 0$。因此，谱半径为：\n$$\\rho(\\mathbf{G}) = \\max(|0|, |0|) = 0$$\n这个结果是标准牛顿-拉夫逊方法的一个基本性质，也是其二次收敛率的数学原因。具体的数值 $k_n$、$k_t$、$\\mu$ 和 $H$ 对于计算切线矩阵 $\\mathbf{C}_{\\text{slide}}$ 本身是必需的，但对于确定解处的误差传播算子的谱半径则不是必需的，因为当使用一致性切线且激活集稳定时，该谱半径始终为零。",
            "answer": "$$\n\\boxed{0}\n$$"
        }
    ]
}