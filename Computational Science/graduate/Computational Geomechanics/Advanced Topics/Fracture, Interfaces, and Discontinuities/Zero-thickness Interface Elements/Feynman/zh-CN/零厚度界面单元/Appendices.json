{
    "hands_on_practices": [
        {
            "introduction": "掌握界面单元的第一步是构建其最简单的形式：线性弹性单元。本练习将指导您从虚功原理出发，为二维零厚度界面单元推导其单元残差向量 $\\mathbf{r}_e$ 和一致切线刚度矩阵 $\\mathbf{K}_e$。更重要的是，您将通过编写一套基准测试来验证您的实现，这是任何有限元开发中的关键步骤。通过这些测试，例如对称性和坐标系无关性检验，您将确保您的单元在数值上是正确且稳健的 。",
            "id": "3571998",
            "problem": "考虑一个二维空间中的零厚度界面单元，它连接了两个重合的线段。该界面单元有两个几何节点，每个几何节点都被复制以表示负侧和正侧的运动学特性。因此，该单元总共有四个节点和八个位移自由度，按节点 $1$（负侧）、节点 $2$（负侧）、节点 $3$（正侧）和节点 $4$（正侧）的顺序排列，每个节点都有 $x$ 和 $y$ 方向的全局位移矢量分量。该单元是直的，长度为 $L$，具有一个与单元对齐的常数单位切向矢量 $\\mathbf{t}$ 和一个从负侧指向正侧的单位法向矢量 $\\mathbf{n}$。其方位由一个角度 $\\theta$（以弧度为单位）定义，使得全局切向矢量为 $\\mathbf{t} = [\\cos \\theta,\\ \\sin \\theta]^{\\top}$，全局法向矢量为 $\\mathbf{n} = [-\\sin \\theta,\\ \\cos \\theta]^{\\top}$。从局部坐标到全局坐标的旋转矩阵是 $2 \\times 2$ 矩阵 $\\mathbf{R} = [\\mathbf{n}\\ \\mathbf{t}]$，其列为 $\\mathbf{n}$ 和 $\\mathbf{t}$。从全局坐标到局部坐标的映射由 $\\mathbf{R}^{\\top}$ 给出。假设为小位移。\n\n界面牵引-分离法则是线性弹性的，并且在局部法向和切向方向上是解耦的。设局部相对位移矢量为 $\\mathbf{g} = [g_{n},\\ g_{t}]^{\\top}$，其中 $g_{n}$ 是张开位移（沿 $\\mathbf{n}$ 方向的拉伸为正），$g_{t}$ 是滑移位移（沿 $\\mathbf{t}$ 方向为正）。局部牵引矢量为 $\\mathbf{t}^{\\text{loc}} = [t_{n},\\ t_{t}]^{\\top}$。本构关系为\n$$\n\\mathbf{t}^{\\text{loc}} = \\mathbf{C}\\ \\mathbf{g}, \\quad \\mathbf{C} = \\begin{bmatrix} k_{n} & 0 \\\\ 0 & k_{t} \\end{bmatrix},\n$$\n其中 $k_{n} \\ge 0$ 和 $k_{t} \\ge 0$ 是法向和切向刚度参数（在本问题中为无量纲）。\n\n设 $\\xi \\in [-1, 1]$ 表示沿界面的等参坐标。使用线性形函数 $N_{1}(\\xi) = \\frac{1 - \\xi}{2}$ 和 $N_{2}(\\xi) = \\frac{1 + \\xi}{2}$。在任意点 $\\xi$，局部相对位移可通过节点的全局位移计算得出\n$$\n\\mathbf{g}(\\xi) = \\mathbf{R}^{\\top} \\sum_{i=1}^{2} N_{i}(\\xi) \\left( \\mathbf{u}^{+}_{i} - \\mathbf{u}^{-}_{i} \\right),\n$$\n其中 $\\mathbf{u}^{-}_{i}$ 和 $\\mathbf{u}^{+}_{i}$ 是几何节点 $i$ 在负侧和正侧复制节点上的全局位移矢量。\n\n从界面的虚功原理和基本的有限元插值出发，\n$$\n\\delta W_{\\text{int}} = \\int_{\\Gamma} \\delta \\mathbf{g}^{\\top} \\mathbf{t}^{\\text{loc}}\\ \\mathrm{d}\\Gamma, \\quad \\mathbf{t}^{\\text{loc}} = \\mathbf{C}\\ \\mathbf{g},\n$$\n使用在 $\\xi = 0$ 处的单点Gauss求积（权重 $w = 2$）和精确的雅可比 $J = L/2$，推导出单元残差矢量 $\\mathbf{r}_{e}$ 和一致切向刚度矩阵 $\\mathbf{K}_{e}$ 的代数表达式。具体来说，使用映射\n$$\n\\mathbf{g}(0) = \\mathbf{B}\\ \\mathbf{u}_{e}, \\quad \\mathbf{B} = \\begin{bmatrix} -\\tfrac{1}{2}\\mathbf{R}^{\\top} & -\\tfrac{1}{2}\\mathbf{R}^{\\top} & \\tfrac{1}{2}\\mathbf{R}^{\\top} & \\tfrac{1}{2}\\mathbf{R}^{\\top} \\end{bmatrix},\n$$\n其中 $\\mathbf{u}_{e} \\in \\mathbb{R}^{8}$ 按 $\\{1x, 1y, 2x, 2y, 3x, 3y, 4x, 4y\\}$ 的顺序堆叠了四个节点的全局位移。从第一性原理出发，用 $L$、$\\mathbf{B}$ 和 $\\mathbf{C}$ 表示 $\\mathbf{r}_{e}$ 和 $\\mathbf{K}_{e}$，并解释为什么单元刚度是半正定的。\n\n然后，实现一个程序，为给定的参数集和节点位移计算 $\\mathbf{r}_{e}$ 和 $\\mathbf{K}_{e}$，并使用它们通过以下测试套件对单元进行验证和基准测试。使用无量纲量；不需要物理单位。所有角度必须以弧度为单位。\n\n测试套件参数集：\n\n- 测试 $1$（均匀局部间隙下的解析力分布）：\n  - $L = 2$, $\\theta = 0$, $k_{n} = 1000$, $k_{t} = 500$。\n  - 通过设置 $\\mathbf{u}^{-}_{1} = \\mathbf{u}^{-}_{2} = \\mathbf{0}$ 和 $\\mathbf{u}^{+}_{1} = \\mathbf{u}^{+}_{2} = \\mathbf{R}\\ [g_{n},\\ g_{t}]^{\\top}$（其中 $g_{n} = 0.01$ 和 $g_{t} = -0.02$）来指定一个均匀的局部间隙。\n  - 计算单元内力矢量 $\\mathbf{r}_{e}$，并将其与由线性动量平衡和均匀局部牵引的本构律所蕴含的精确节点力模式进行比较。以浮点数形式报告相对误差。\n\n- 测试 $2$（刚度对称性检查）：\n  - $L = 1.3$, $\\theta = 0.37$, $k_{n} = 800$, $k_{t} = 1200$。\n  - 使用 $\\mathbf{u}^{-}_{1} = \\mathbf{u}^{-}_{2} = \\mathbf{0}$ 和 $\\mathbf{u}^{+}_{1} = \\mathbf{u}^{+}_{2} = \\mathbf{R}\\ [0.013,\\ -0.007]^{\\top}$。\n  - 计算 $\\mathbf{K}_{e}$ 并以浮点数形式报告相对对称性缺陷 $\\|\\mathbf{K}_{e} - \\mathbf{K}_{e}^{\\top}\\|_{F} / \\|\\mathbf{K}_{e}\\|_{F}$。\n\n- 测试 $3$（旋转下的标架不变性）：\n  - $L = 2$, $\\theta_{0} = 0$, $\\theta_{1} = \\pi/3$, $k_{n} = 900$, $k_{t} = 300$。\n  - 对两种方位使用相同的均匀局部间隙矢量 $[g_{n},\\ g_{t}]^{\\top} = [0.02,\\ 0.01]^{\\top}$，通过对每个 $\\theta \\in \\{\\theta_{0}, \\theta_{1}\\}$ 设置 $\\mathbf{u}^{-}_{i} = \\mathbf{0}$ 和 $\\mathbf{u}^{+}_{i} = \\mathbf{R}(\\theta)\\ [g_{n},\\ g_{t}]^{\\top}$。\n  - 计算 $\\mathbf{r}_{e}(\\theta_{0})$ 和 $\\mathbf{r}_{e}(\\theta_{1})$。令 $\\mathbf{T} = \\mathbf{R}(\\theta_{1})\\ \\mathbf{R}(\\theta_{0})^{\\top}$ 和 $\\mathbf{Q} = \\mathrm{diag}(\\mathbf{T}, \\mathbf{T}, \\mathbf{T}, \\mathbf{T})$。以浮点数形式报告相对差异 $\\|\\mathbf{r}_{e}(\\theta_{1}) - \\mathbf{Q}\\ \\mathbf{r}_{e}(\\theta_{0})\\|_{2} / \\|\\mathbf{r}_{e}(\\theta_{1})\\|_{2}$。\n\n- 测试 $4$（切向刚度为零的边界情况）：\n  - $L = 3$, $\\theta = 0.5$, $k_{n} = 700$, $k_{t} = 0$。\n  - 使用纯滑移间隙，$g_{n} = 0$ 和 $g_{t} = 0.05$，通过设置 $\\mathbf{u}^{-}_{i} = \\mathbf{0}$ 和 $\\mathbf{u}^{+}_{i} = \\mathbf{R}\\ [0,\\ 0.05]^{\\top}$。\n  - 计算 $\\mathbf{r}_{e}$ 并以浮点数形式报告其欧几里得范数 $\\|\\mathbf{r}_{e}\\|_{2}$。\n\n- 测试 $5$（半正定性基准测试）：\n  - $L = 1$, $\\theta = 0.2$, $k_{n} = 1000$, $k_{t} = 500$。\n  - 计算 $\\mathbf{K}_{e}$ 的特征值，并以浮点数形式报告最小特征值。\n\n最终输出格式规范：您的程序应生成单行输出，其中包含五个测试的结果，形式为方括号括起来的逗号分隔列表（例如，$[r_{1}, r_{2}, r_{3}, r_{4}, r_{5}]$），其中每个 $r_{i}$ 是上述顺序中测试 $i$ 所需的浮点数。不应产生任何其他输出。角度必须以弧度为单位。全部使用无量纲数。所有计算必须使用上述从虚功原理和线性动量平衡出发的定义和推导进行。您的实现必须是完全自包含的，不需要输入，并且必须按规定使用带有精确雅可比的单点Gauss求积。",
            "solution": "该问题要求推导并实现一个四节点、二维、零厚度的界面单元。解决方案分两个阶段进行：首先，从第一性原理出发，对单元的残差矢量 $\\mathbf{r}_e$ 和切向刚度矩阵 $\\mathbf{K}_e$ 进行理论推导；其次，在程序中实现这些公式，以执行一系列验证测试。\n\n### 单元公式推导\n\n该公式基于界面的虚功原理：\n$$\n\\delta W_{\\text{int}} = \\int_{\\Gamma} \\delta \\mathbf{g}^{\\top} \\mathbf{t}^{\\text{loc}}\\ \\mathrm{d}\\Gamma = \\delta \\mathbf{u}_e^{\\top} \\mathbf{r}_e\n$$\n其中 $\\delta W_{\\text{int}}$ 是内部虚功，$\\Gamma$ 是界面表面，$\\mathbf{g}$ 是局部相对位移矢量，$\\mathbf{t}^{\\text{loc}}$ 是局部牵引矢量，$\\delta \\mathbf{u}_e$ 是虚节点位移矢量，$\\mathbf{r}_e$ 是单元残差（内力）矢量。\n\n问题指定了线性本构关系 $\\mathbf{t}^{\\text{loc}} = \\mathbf{C} \\mathbf{g}$，并提供了从单元的全局节点位移 $\\mathbf{u}_e \\in \\mathbb{R}^8$ 到单元中心（等参坐标 $\\xi=0$）的局部相对位移 $\\mathbf{g} \\in \\mathbb{R}^2$ 的特定映射：\n$$\n\\mathbf{g}(0) = \\mathbf{B}\\ \\mathbf{u}_{e}\n$$\n其中 $\\mathbf{B}$ 是 $2 \\times 8$ 的应变-位移矩阵：\n$$\n\\mathbf{B} = \\begin{bmatrix} -\\tfrac{1}{2}\\mathbf{R}^{\\top} & -\\tfrac{1}{2}\\mathbf{R}^{\\top} & \\tfrac{1}{2}\\mathbf{R}^{\\top} & \\tfrac{1}{2}\\mathbf{R}^{\\top} \\end{bmatrix}\n$$\n这里，$\\mathbf{R}$ 是 $2 \\times 2$ 的局部到全局坐标变换矩阵。相对位移的变分同样为 $\\delta\\mathbf{g}(0) = \\mathbf{B}\\ \\delta\\mathbf{u}_{e}$。\n\n对单元长度 $L$ 的积分使用单点Gauss求积进行评估。积分点在 $\\xi=0$，权重为 $w=2$，从等参域 $[-1, 1]$ 到物理域 $[0, L]$ 的映射的雅可比为 $J = L/2$。长度微分元为 $\\mathrm{d}\\Gamma = J \\mathrm{d}\\xi$。\n$$\n\\int_{\\Gamma} (\\cdot)\\ \\mathrm{d}\\Gamma = \\int_{-1}^{1} (\\cdot) J \\mathrm{d}\\xi \\approx (\\cdot)|_{\\xi=0} \\cdot J \\cdot w = (\\cdot)|_{\\xi=0} \\cdot (L/2) \\cdot 2 = (\\cdot)|_{\\xi=0} \\cdot L\n$$\n将离散化的量代入虚功原理：\n$$\n\\delta W_{\\text{int}} \\approx \\left[ \\delta \\mathbf{g}(0)^{\\top} \\mathbf{t}^{\\text{loc}}(0) \\right] L\n$$\n$$\n\\delta \\mathbf{u}_e^{\\top} \\mathbf{r}_e = \\left[ (\\mathbf{B} \\delta \\mathbf{u}_e)^{\\top} (\\mathbf{C} \\mathbf{B} \\mathbf{u}_e) \\right] L\n$$\n$$\n\\delta \\mathbf{u}_e^{\\top} \\mathbf{r}_e = \\left[ \\delta \\mathbf{u}_e^{\\top} \\mathbf{B}^{\\top} \\mathbf{C} \\mathbf{B} \\mathbf{u}_e \\right] L = \\delta \\mathbf{u}_e^{\\top} \\left( L \\mathbf{B}^{\\top} \\mathbf{C} \\mathbf{B} \\mathbf{u}_e \\right)\n$$\n由于此等式必须对任意虚位移 $\\delta \\mathbf{u}_e$ 成立，我们可以确定残差矢量 $\\mathbf{r}_e$：\n$$\n\\mathbf{r}_e = L \\mathbf{B}^{\\top} \\mathbf{C} \\mathbf{B} \\mathbf{u}_e\n$$\n一致切向刚度矩阵 $\\mathbf{K}_e$ 定义为残差矢量关于节点位移 $\\mathbf{u}_e$ 的导数：\n$$\n\\mathbf{K}_e = \\frac{\\partial \\mathbf{r}_e}{\\partial \\mathbf{u}_e} = \\frac{\\partial}{\\partial \\mathbf{u}_e} \\left( L \\mathbf{B}^{\\top} \\mathbf{C} \\mathbf{B} \\mathbf{u}_e \\right)\n$$\n对于这个线性问题，导数就是：\n$$\n\\mathbf{K}_e = L \\mathbf{B}^{\\top} \\mathbf{C} \\mathbf{B}\n$$\n值得注意的是，这意味着 $\\mathbf{r}_e = \\mathbf{K}_e \\mathbf{u}_e$，这是线性系统的特征。\n\n### $\\mathbf{K}_e$ 的半正定性\n刚度矩阵 $\\mathbf{K}_e$ 必须是半正定的，这对应于单元应变需要非负能量的物理要求。为了证明这一点，我们考察对于任意位移矢量 $\\mathbf{v} \\in \\mathbb{R}^8$ 的二次型 $\\mathbf{v}^{\\top} \\mathbf{K}_e \\mathbf{v}$。\n$$\n\\mathbf{v}^{\\top} \\mathbf{K}_e \\mathbf{v} = \\mathbf{v}^{\\top} (L \\mathbf{B}^{\\top} \\mathbf{C} \\mathbf{B}) \\mathbf{v} = L (\\mathbf{Bv})^{\\top} \\mathbf{C} (\\mathbf{Bv})\n$$\n令 $\\mathbf{w} = \\mathbf{Bv}$。这个 $2 \\times 1$ 的矢量 $\\mathbf{w} = [w_n, w_t]^\\top$ 代表了与节点位移 $\\mathbf{v}$ 对应的局部相对位移。二次型变为：\n$$\n\\mathbf{v}^{\\top} \\mathbf{K}_e \\mathbf{v} = L \\mathbf{w}^{\\top} \\mathbf{C} \\mathbf{w} = L \\begin{bmatrix} w_n & w_t \\end{bmatrix} \\begin{bmatrix} k_n & 0 \\\\ 0 & k_t \\end{bmatrix} \\begin{bmatrix} w_n \\\\ w_t \\end{bmatrix} = L (k_n w_n^2 + k_t w_t^2)\n$$\n鉴于单元长度 $L > 0$ 且刚度参数 $k_n, k_t \\ge 0$，项 $L (k_n w_n^2 + k_t w_t^2)$ 总是非负的。因此，$\\mathbf{v}^{\\top} \\mathbf{K}_e \\mathbf{v} \\ge 0$，这证明了 $\\mathbf{K}_e$ 是半正定的。该矩阵不是正定的，因为对应于刚体运动的非零位移矢量 $\\mathbf{v}$ 会导致零相对位移（$\\mathbf{w}=\\mathbf{0}$），从而产生零应变能。这些矢量构成了 $\\mathbf{K}_e$ 的零空间，导致零特征值。\n\n### 实现与验证\n推导出的 $\\mathbf{r}_e$ 和 $\\mathbf{K}_e$ 公式在 Python 中实现。程序构建了必要的矩阵（$\\mathbf{R}$, $\\mathbf{C}$, $\\mathbf{B}$），然后计算 $\\mathbf{K}_e$ 和 $\\mathbf{r}_e$。这个核心计算随后应用于问题陈述中指定的五个测试案例。\n\n- **测试1（解析力分布）：** 应用一个均匀间隙。计算出的内力矢量 $\\mathbf{r}_e$ 与基于静力平衡解析推导的力矢量进行比较。对于这种情况，单点求积是精确的，因此相对误差预期接近机器精度。\n- **测试2（刚度对称性检查）：** 刚度矩阵 $\\mathbf{K}_e = L \\mathbf{B}^\\top \\mathbf{C} \\mathbf{B}$ 因其构造而是对称的，因为本构矩阵 $\\mathbf{C}$ 是对称的。该测试通过计算相对对称性缺陷来数值确认这一点，该缺陷应接近于零。\n- **测试3（标架不变性）：** 此测试验证了客观性。针对两种不同的单元方位但相同的物理变形，计算内力矢量。第二种方位下的力矢量 $\\mathbf{r}_e(\\theta_1)$ 必须等效于从第一种方位旋转而来的力矢量 $\\mathbf{Q} \\mathbf{r}_e(\\theta_0)$。计算其相对差异，预期接近于零。\n- **测试4（零切向刚度）：** 在 $k_t=0$ 的情况下应用纯滑移变形。在这种情况下，由于法向张开位移 $g_n$ 为零，本构关系产生零牵引力（$\\mathbf{t}^{\\text{loc}}=\\mathbf{0}$）。因此，内力矢量 $\\mathbf{r}_e$ 必须为零。该测试通过计算 $\\mathbf{r}_e$ 的范数来证实这一点。\n- **测试5（半正定性）：** 计算 $\\mathbf{K}_e$ 的特征值。如前所证，该矩阵是半正定的，意味着所有特征值都必须是非负的。由于刚体模态的存在，该矩阵有一个零空间。$\\mathbf{K}_e$ 的秩最多为 $2$，因此对于一个 $8 \\times 8$ 的矩阵，至少有 $6$ 个特征值必须为零。测试报告了最小特征值，预期其为零（在浮点容差范围内）。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_element_properties(L, theta, kn, kt):\n    \"\"\"\n    Computes matrices required for the interface element.\n    :param L: Length of the element\n    :param theta: Orientation angle in radians\n    :param kn: Normal stiffness\n    :param kt: Tangential stiffness\n    :return: R, C, B, Ke matrices\n    \"\"\"\n    c, s = np.cos(theta), np.sin(theta)\n    # Local-to-global rotation matrix\n    R = np.array([[-s, c], [c, s]])\n    \n    # Constitutive matrix\n    C = np.array([[kn, 0], [0, kt]])\n    \n    # B matrix for one-point quadrature, relates global u_e to local g\n    # B has shape (2, 8)\n    B_block = 0.5 * R.T\n    B = np.hstack([-B_block, -B_block, B_block, B_block])\n    \n    # Stiffness matrix Ke = L * B.T @ C @ B\n    Ke = L * (B.T @ C @ B)\n    \n    return R, C, B, Ke\n\ndef test1():\n    \"\"\"Analytical force distribution under uniform local gap.\"\"\"\n    L, theta, kn, kt = 2.0, 0.0, 1000.0, 500.0\n    g_local = np.array([0.01, -0.02])\n    \n    R, C, B, Ke = compute_element_properties(L, theta, kn, kt)\n    \n    # Define prescribed nodal displacements\n    u_plus_global = R @ g_local\n    u_e = np.zeros(8)\n    u_e[4:6] = u_plus_global  # Node 3 (+ side)\n    u_e[6:8] = u_plus_global  # Node 4 (+ side)\n    \n    # Compute residual vector from implementation\n    r_e_computed = Ke @ u_e\n    \n    # Analytical verification\n    t_loc = C @ g_local\n    # Formula r_e = L * B.T @ t_loc\n    r_e_exact = L * (B.T @ t_loc)\n\n    norm_exact = np.linalg.norm(r_e_exact)\n    if norm_exact == 0:\n        return 0.0 if np.linalg.norm(r_e_computed) == 0 else 1.0\n    \n    relative_error = np.linalg.norm(r_e_computed - r_e_exact) / norm_exact\n    return relative_error\n\ndef test2():\n    \"\"\"Stiffness symmetry check.\"\"\"\n    L, theta, kn, kt = 1.3, 0.37, 800.0, 1200.0\n    g_local = np.array([0.013, -0.007])\n    \n    R, C, B, Ke = compute_element_properties(L, theta, kn, kt)\n    \n    norm_Ke = np.linalg.norm(Ke, 'fro')\n    if norm_Ke == 0:\n        return 0.0\n        \n    symmetry_defect = np.linalg.norm(Ke - Ke.T, 'fro') / norm_Ke\n    return symmetry_defect\n\ndef test3():\n    \"\"\"Frame invariance under rotation.\"\"\"\n    L, kn, kt = 2.0, 900.0, 300.0\n    theta0, theta1 = 0.0, np.pi/3.0\n    g_local = np.array([0.02, 0.01])\n\n    # Case 0: theta = theta0\n    R0, C0, B0, Ke0 = compute_element_properties(L, theta0, kn, kt)\n    u_plus0 = R0 @ g_local\n    u_e0 = np.zeros(8)\n    u_e0[4:6], u_e0[6:8] = u_plus0, u_plus0\n    r_e0 = Ke0 @ u_e0\n\n    # Case 1: theta = theta1\n    R1, C1, B1, Ke1 = compute_element_properties(L, theta1, kn, kt)\n    u_plus1 = R1 @ g_local\n    u_e1 = np.zeros(8)\n    u_e1[4:6], u_e1[6:8] = u_plus1, u_plus1\n    r_e1 = Ke1 @ u_e1\n\n    # Transformation matrices\n    T = R1 @ R0.T\n    Q = np.kron(np.eye(4), T)\n    \n    r_e0_rotated = Q @ r_e0\n    \n    norm_r1 = np.linalg.norm(r_e1)\n    if norm_r1 == 0:\n        return 0.0 if np.linalg.norm(r_e0_rotated) == 0 else 1.0\n        \n    relative_diff = np.linalg.norm(r_e1 - r_e0_rotated) / norm_r1\n    return relative_diff\n\ndef test4():\n    \"\"\"Edge case with zero tangential stiffness.\"\"\"\n    L, theta, kn, kt = 3.0, 0.5, 700.0, 0.0\n    g_local = np.array([0.0, 0.05])\n\n    R, C, B, Ke = compute_element_properties(L, theta, kn, kt)\n    \n    u_plus = R @ g_local\n    u_e = np.zeros(8)\n    u_e[4:6], u_e[6:8] = u_plus, u_plus\n    \n    r_e = Ke @ u_e\n    return np.linalg.norm(r_e)\n\ndef test5():\n    \"\"\"Positive semidefiniteness benchmark.\"\"\"\n    L, theta, kn, kt = 1.0, 0.2, 1000.0, 500.0\n    \n    R, C, B, Ke = compute_element_properties(L, theta, kn, kt)\n    \n    eigenvalues = np.linalg.eigvalsh(Ke)\n    return np.min(eigenvalues)\n\ndef solve():\n    \"\"\"\n    Executes the test suite for the zero-thickness interface element.\n    \"\"\"\n    test_cases = [\n        test1,\n        test2,\n        test3,\n        test4,\n        test5\n    ]\n\n    results = []\n    for test_func in test_cases:\n        result = test_func()\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # High precision is used to show values are close to zero.\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "真实世界的岩土界面行为，如节理和断层，是高度非线性的，其中摩擦起着主导作用。本练习将带领您从线性弹性模型过渡到经典的库仑摩擦模型，这是一个典型的非光滑本构关系。您将学习如何为这种在粘着（stick）和滑动（slip）状态之间转换的非光滑问题推导一致的广义雅可比矩阵，并将其应用于半光滑牛顿法 (Semi-Smooth Newton method) 中，从而掌握解决复杂接触问题的强大数值技术 。",
            "id": "3571923",
            "problem": "考虑计算岩土力学中的一个零厚度界面单元，在压缩法向接触下承受切向加载。该界面有两个几何上重合的节点，界面上的相对切向位移由向量 $\\,\\mathbf{u}_t \\in \\mathbb{R}^2\\,$ 表示。假设法向接触是完全闭合的，具有给定的压缩法向牵引力 $\\,t_n > 0\\,$。切向行为遵循经典的库仑摩擦定律：切向牵引力的大小 $\\,\\|\\mathbf{t}_t\\|\\,$ 以 $\\,\\mu\\, t_n\\,$ 为界，其中 $\\,\\mu > 0\\,$ 是摩擦系数，并且当发生滑动时，$\\,\\mathbf{t}_t\\,$ 的方向与试探切向牵引力的方向一致。\n\n该界面附着在一个线性弹性体上，其有效剪切刚度为 $\\,k_b > 0\\,$，使得远场施加的剪切位移 $\\,\\mathbf{w} \\in \\mathbb{R}^2\\,$ 由界面响应来平衡。在粘滞状态下，界面的切向弹性刚度为 $\\,k_t > 0\\,$。关于未知量 $\\,\\mathbf{u}_t\\,$ 的界面控制平衡方程为\n$$\n\\mathbf{R}(\\mathbf{u}_t) \\equiv \\mathbf{K}_b \\left(\\mathbf{w} - \\mathbf{u}_t\\right) - \\mathbf{t}_t(\\mathbf{u}_t) = \\mathbf{0},\n$$\n其中 $\\,\\mathbf{K}_b = k_b \\mathbf{I}\\,$ 且 $\\,\\mathbf{I}\\,$ 是 $\\,2\\times2\\,$ 单位矩阵。切向牵引力映射 $\\,\\mathbf{t}_t(\\mathbf{u}_t)\\,$ 由一个弹性预测步骤和一个随后的库仑投影定义：\n1. 计算弹性试探牵引力 $\\,\\mathbf{t}_t^{\\text{trial}} = k_t\\,\\mathbf{u}_t\\,$。\n2. 如果 $\\,\\left\\|\\mathbf{t}_t^{\\text{trial}}\\right\\| \\le \\mu t_n\\,$ (粘滞)，则 $\\,\\mathbf{t}_t = \\mathbf{t}_t^{\\text{trial}}\\,$。\n3. 如果 $\\,\\left\\|\\mathbf{t}_t^{\\text{trial}}\\right\\| > \\mu t_n\\,$ (滑动)，则 $\\,\\mathbf{t}_t = \\mu t_n \\,\\dfrac{\\mathbf{t}_t^{\\text{trial}}}{\\left\\|\\mathbf{t}_t^{\\text{trial}}\\right\\|}\\,$。\n\n从基本平衡原理和库仑定律出发，推导应用半光滑牛顿 (SSN) 法所需的一致切线算子，即推导适用于粘滑转换的 $\\,\\mathbf{R}(\\mathbf{u}_t)\\,$ 的广义雅可比矩阵 $\\,\\mathbf{J}(\\mathbf{u}_t)\\,$。实现一个 SSN 算法，该算法：\n- 在每次迭代中组装 $\\,\\mathbf{R}(\\mathbf{u}_t)\\,$ 和一致广义导数 $\\,\\mathbf{J}(\\mathbf{u}_t)\\,$。\n- 当 $\\,\\mathbf{J}\\,$ 是病态时，使用带有回退策略的鲁棒线性求解器。\n- 如果需要，可选择应用简单的回溯线搜索以确保残差减小。\n- 当欧几里得范数 $\\,\\|\\mathbf{R}(\\mathbf{u}_t)\\|\\,$ 低于某个容差时终止。\n\n通过报告每个测试用例的以下内容来量化收敛行为：\n- 直至收敛的 SSN 迭代次数（整数）。\n- 根据最后两次可用迭代计算的观测 q-线性收敛率，即比率 $\\,\\|\\mathbf{R}_{k+1}\\| / \\|\\mathbf{R}_k\\|\\,$（浮点数；如果迭代次数少于两次，则使用 $\\,0.0\\,$）。\n- 一个布尔值，指示是否在最大允许迭代次数内实现收敛。\n- 收敛解的最终状态码：$\\,0\\,$ 表示粘滞，$\\,1\\,$ 表示滑动。\n\n您必须以无量纲单位作答；所有参数和输出都是无量纲的。对于向量归一化隐式要求的任何方向计算，请使用弧度。\n\n您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果本身就是一个列表 $\\,[$iterations, rate, converged, regime$]$。例如，输出格式必须类似于 $\\,\\left[ [i_1,r_1,c_1,s_1],[i_2,r_2,c_2,s_2],\\dots \\right]\\,$。\n\n测试套件。为以下参数集实现并运行您的求解器，以测试不同的状态，包括理想路径、边界情况以及具有大摩擦跳跃的边缘情况：\n\n- A 例（粘滞主导）：$\\,k_b=500\\,$, $\\,k_t=1000\\,$, $\\,\\mu=0.3\\,$, $\\,t_n=100\\,$, $\\,\\mathbf{w}=(0.05,\\,0.02)\\,$。\n- B 例（带大跳跃的滑动）：$\\,k_b=500\\,$, $\\,k_t=1000\\,$, $\\,\\mu=0.3\\,$, $\\,t_n=100\\,$, $\\,\\mathbf{w}=(0.5,\\,0.3)\\,$。\n- C 例（近边界，高摩擦能力）：$\\,k_b=500\\,$, $\\,k_t=1000\\,$, $\\,\\mu=2.0\\,$, $\\,t_n=100\\,$, $\\,\\mathbf{w}=(0.5,\\,0.3)\\,$。\n- D 例（方向翻转，滑动）：$\\,k_b=500\\,$, $\\,k_t=1000\\,$, $\\,\\mu=0.3\\,$, $\\,t_n=100\\,$, $\\,\\mathbf{w}=(-0.6,\\,0.0)\\,$。\n- E 例（单向精确边界值）：$\\,k_b=500\\,$, $\\,k_t=1000\\,$, $\\,\\mu=0.3\\,$, $\\,t_n=100\\,$, $\\,\\mathbf{w}=(0.09,\\,0.0)\\,$。\n\n您的实现必须是一个完整的、可运行的程序，该程序为所有测试用例计算所要求的输出，并以指定格式打印单行结果。",
            "solution": "我们从简化为离散界面平衡的线性动量平衡出发。零厚度界面单元具有重合的节点，并且仅在界面上承受牵引力。切向位移跳跃为 $\\,\\mathbf{u}_t \\in \\mathbb{R}^2\\,$，压缩法向牵引力为 $\\,t_n > 0\\,$，摩擦遵循库仑定律：$\\,\\|\\mathbf{t}_t\\| \\le \\mu t_n\\,$，其中 $\\,\\mu > 0\\,$ 为摩擦系数。弹性体的剪切响应由线性关系 $\\,\\mathbf{K}_b(\\mathbf{w}-\\mathbf{u}_t)\\,$ 表示，其中 $\\,\\mathbf{K}_b = k_b \\mathbf{I}\\,$，施加的位移为 $\\,\\mathbf{w}\\,$。在粘滞状态下，界面的切向刚度为 $\\,k_t > 0\\,$。\n\n基本定律和核心定义。界面上的离散平衡来自于强制实现弹性体和界面之间的牵引力平衡：\n$$\n\\mathbf{R}(\\mathbf{u}_t) \\equiv \\mathbf{K}_b \\left(\\mathbf{w} - \\mathbf{u}_t\\right) - \\mathbf{t}_t(\\mathbf{u}_t) = \\mathbf{0}.\n$$\n摩擦牵引力映射 $\\,\\mathbf{t}_t(\\mathbf{u}_t)\\,$ 由库仑定律定义，包含一个弹性预测值 $\\,\\mathbf{t}_t^{\\text{trial}} = k_t \\mathbf{u}_t\\,$ 和一个到半径为 $\\,\\mu t_n\\,$ 的摩擦圆盘上的投影：\n- 粘滞：如果 $\\,\\left\\|\\mathbf{t}_t^{\\text{trial}}\\right\\| \\le \\mu t_n\\,$，则 $\\,\\mathbf{t}_t = \\mathbf{t}_t^{\\text{trial}} = k_t \\mathbf{u}_t\\,$。\n- 滑动：如果 $\\,\\left\\|\\mathbf{t}_t^{\\text{trial}}\\right\\| > \\mu t_n\\,$，则 $\\,\\mathbf{t}_t = \\mu t_n \\,\\dfrac{\\mathbf{t}_t^{\\text{trial}}}{\\left\\|\\mathbf{t}_t^{\\text{trial}}\\right\\|}\\,$。\n\n半光滑公式。由于在粘滑边界处的投影算子，残差 $\\,\\mathbf{R}(\\mathbf{u}_t)\\,$ 是非光滑的。半光滑牛顿 (SSN) 法使用广义雅可比矩阵（在 Clarke 的意义上）的元素来构建搜索方向。我们分段推导一个一致的广义导数 $\\,\\mathbf{J}(\\mathbf{u}_t) = \\dfrac{\\partial \\mathbf{R}}{\\partial \\mathbf{u}_t}\\,$。\n\n粘滞状态下的一致切线算子。在粘滞状态下，我们有 $\\,\\mathbf{t}_t(\\mathbf{u}_t) = k_t \\mathbf{u}_t\\,$。因此，\n$$\n\\frac{\\partial \\mathbf{t}_t}{\\partial \\mathbf{u}_t} = k_t \\mathbf{I},\n\\qquad\n\\frac{\\partial \\mathbf{R}}{\\partial \\mathbf{u}_t} = -\\mathbf{K}_b - k_t \\mathbf{I} = -(k_b + k_t)\\mathbf{I}.\n$$\n这个导数是对称且负定的，因为 $\\,k_b > 0\\,$ 且 $\\,k_t > 0\\,$。\n\n滑动状态下的一致切线算子。在滑动状态下，定义试探牵引力 $\\,\\mathbf{q} \\equiv \\mathbf{t}_t^{\\text{trial}} = k_t \\mathbf{u}_t\\,$，其大小为 $\\,q \\equiv \\|\\mathbf{q}\\|\\,$，单位方向为 $\\,\\mathbf{n} \\equiv \\dfrac{\\mathbf{q}}{q}\\,$。投影后的牵引力为 $\\,\\mathbf{t}_t = \\mu t_n \\mathbf{n}\\,$。$\\,\\mathbf{n}\\,$ 相对于 $\\,\\mathbf{q}\\,$ 的变分为\n$$\nd\\mathbf{n} = \\frac{1}{q} \\left( \\mathbf{I} - \\mathbf{n}\\mathbf{n}^\\top \\right) d\\mathbf{q}.\n$$\n当 $\\,\\mathbf{q} = k_t \\mathbf{u}_t\\,$ 时，我们有 $\\,d\\mathbf{q} = k_t\\, d\\mathbf{u}_t\\,$，因此\n$$\nd\\mathbf{t}_t = \\mu t_n\\, d\\mathbf{n} = \\mu t_n \\frac{1}{q} \\left( \\mathbf{I} - \\mathbf{n}\\mathbf{n}^\\top \\right) k_t\\, d\\mathbf{u}_t.\n$$\n因此，在滑动状态下的一致广义导数为\n$$\n\\frac{\\partial \\mathbf{t}_t}{\\partial \\mathbf{u}_t} = \\frac{\\mu t_n\\, k_t}{\\|\\mathbf{t}_t^{\\text{trial}}\\|} \\left( \\mathbf{I} - \\mathbf{n}\\mathbf{n}^\\top \\right),\n\\qquad\n\\frac{\\partial \\mathbf{R}}{\\partial \\mathbf{u}_t} = -\\mathbf{K}_b - \\frac{\\mu t_n\\, k_t}{\\|\\mathbf{t}_t^{\\text{trial}}\\|} \\left( \\mathbf{I} - \\mathbf{n}\\mathbf{n}^\\top \\right).\n$$\n注意，在滑动状态下，沿 $\\,\\mathbf{n}\\,$ 方向的导数为零，这反映了牵引力的大小固定为 $\\,\\mu t_n\\,$，只有其方向随 $\\,\\mathbf{u}_t\\,$ 变化。矩阵 $\\,\\left( \\mathbf{I} - \\mathbf{n}\\mathbf{n}^\\top \\right)\\,$ 是一个投影到与 $\\,\\mathbf{n}\\,$ 正交的子空间上的投影算子。\n\n半光滑牛顿 (SSN) 法的算法设计。在第 $\\,k\\,$ 次迭代，当前估计值为 $\\,\\mathbf{u}_t^{(k)}\\,$ 时：\n1. 计算 $\\,\\mathbf{q}^{(k)} = k_t \\mathbf{u}_t^{(k)}\\,$，$\\,q^{(k)} = \\|\\mathbf{q}^{(k)}\\|\\,$，以及当 $\\,q^{(k)} > 0\\,$ 时的 $\\,\\mathbf{n}^{(k)} = \\dfrac{\\mathbf{q}^{(k)}}{q^{(k)}}\\,$。\n2. 通过与 $\\,\\mu t_n\\,$ 的粘滑判断来计算牵引力 $\\,\\mathbf{t}_t^{(k)}\\,$。\n3. 组装残差 $\\,\\mathbf{R}^{(k)} = \\mathbf{K}_b\\left(\\mathbf{w} - \\mathbf{u}_t^{(k)}\\right) - \\mathbf{t}_t^{(k)}\\,$。\n4. 使用上面推导的粘滞或滑动公式组装广义雅可比矩阵 $\\,\\mathbf{J}^{(k)} = \\dfrac{\\partial \\mathbf{R}}{\\partial \\mathbf{u}_t}\\,$。如果在滑动状态下 $\\,q^{(k)} \\approx 0\\,$，则通过在分母中使用一个小的 $\\,\\epsilon > 0\\,$ 进行正则化。\n5. 求解线性系统 $\\,\\mathbf{J}^{(k)} \\Delta \\mathbf{u}_t^{(k)} = -\\mathbf{R}^{(k)}\\,$。如果 $\\,\\mathbf{J}^{(k)}\\,$ 是病态的，则采用回退策略，例如最速下降步 $\\,\\Delta \\mathbf{u}_t^{(k)} = -\\mathbf{R}^{(k)}\\,$。\n6. 可选地执行回溯线搜索以确保残差减小：选择 $\\,\\alpha \\in (0,1]\\,$ 并更新 $\\,\\mathbf{u}_t^{(k+1)} = \\mathbf{u}_t^{(k)} + \\alpha \\Delta \\mathbf{u}_t^{(k)}\\,$，如果 $\\,\\|\\mathbf{R}^{(k+1)}\\|\\,$ 增加，则减小 $\\,\\alpha\\,$。\n7. 当 $\\,\\|\\mathbf{R}^{(k)}\\| \\le \\text{tol}\\,$ 时停止，否则继续迭代直至达到最大迭代次数。\n\n收敛性量化。q-线性收敛率 $\\,\\rho_k = \\|\\mathbf{R}^{(k+1)}\\| / \\|\\mathbf{R}^{(k)}\\|\\,$ 是通过最后两次可用迭代的比值来观测的。在光滑的粘滞状态下，导数是常数，对于线性系统，牛顿法应该是一步收敛的；在滑动状态下，广义导数在非光滑边界附近导致线性收敛，但由于投影算子结构，在远离拐点时通常表现出超线性行为。大的摩擦跳跃（例如，当 $\\,\\|\\mathbf{t}_t^{\\text{trial}}\\|\\,$ 和 $\\,\\mu t_n\\,$ 相差几个数量级时）对鲁棒性构成了挑战，我们通过报告在迭代上限内是否成功收敛来评估这一点。\n\n实现细节。我们使用 $\\,\\mathbf{K}_b = k_b \\mathbf{I}\\,$ 和 $\\,\\mathbf{K}_t = k_t \\mathbf{I}\\,$，从 $\\,\\mathbf{u}_t^{(0)} = \\mathbf{0}\\,$ 开始，在滑动状态下采用一个小的正则化参数 $\\,\\epsilon = 10^{-14}\\,$ 以避免在 $\\,q\\,$ 中出现除以零的情况，并将迭代次数上限设为 $\\,50\\,$。残差范数阈值设为 $\\,10^{-12}\\,$。我们为每个测试用例返回：迭代次数、最终的 q-线性收敛率、表示收敛的布尔值，以及最终的状态码（$\\,0\\,$ 表示粘滞，$\\,1\\,$ 表示滑动），该状态码通过在收敛解 $\\,\\mathbf{u}_t^{\\star}\\,$ 处评估 $\\,\\left\\|k_t \\mathbf{u}_t^{\\star}\\right\\| \\le \\mu t_n\\,$ 来确定。\n\n将该算法应用于提供的测试套件，会以单行列表格式 $\\,\\left[ [i_1,r_1,c_1,s_1],[i_2,r_2,c_2,s_2],\\dots \\right]\\,$ 产生输出，满足所要求的设计规范。所有量均为无量纲。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef friction_traction_and_tangent(u, k_t, mu, p_n, eps=1e-14):\n    \"\"\"\n    Compute tangential traction and consistent generalized tangent for a Coulomb interface.\n    u: 2-vector of tangential displacement jump.\n    Returns (t, D, regime) where:\n      t: 2-vector traction,\n      D: 2x2 consistent generalized derivative dt/du,\n      regime: 0 for stick, 1 for slip.\n    \"\"\"\n    # Elastic trial traction\n    q = k_t * u\n    qnorm = np.linalg.norm(q)\n    limit = mu * p_n\n\n    if qnorm <= limit + 0.0:  # stick\n        t = q.copy()\n        D = k_t * np.eye(2)\n        regime = 0\n    else:  # slip\n        # Project onto friction disc\n        n = q / (qnorm + eps)\n        t = limit * n\n        # Consistent generalized derivative in slip:\n        # D = (limit * k_t / qnorm) * (I - n n^T)\n        # Regularize denominator\n        denom = max(qnorm, eps)\n        projector = np.eye(2) - np.outer(n, n)\n        D = (limit * k_t / denom) * projector\n        regime = 1\n    return t, D, regime\n\ndef semi_smooth_newton(w, k_b, k_t, mu, p_n, tol=1e-12, max_iter=50):\n    \"\"\"\n    Solve K_b (w - u) - t(u) = 0 for u using Semi-Smooth Newton with consistent tangent.\n    Returns dict with iteration count, final rate, converged, regime, and solution u.\n    \"\"\"\n    Kb = k_b * np.eye(2)\n    u = np.zeros(2)\n    residual_norms = []\n\n    converged = False\n    regime_final = None\n\n    for it in range(max_iter):\n        t, Dt, regime = friction_traction_and_tangent(u, k_t, mu, p_n)\n        R = Kb @ (w - u) - t\n        rn = float(np.linalg.norm(R))\n        residual_norms.append(rn)\n        if rn <= tol:\n            converged = True\n            regime_final = regime\n            break\n\n        # Generalized Jacobian of residual: J = -Kb - Dt\n        J = -Kb - Dt\n\n        # Check conditioning; if ill-conditioned, fallback to steepest-descent step\n        try:\n            condJ = np.linalg.cond(J)\n        except Exception:\n            condJ = np.inf\n\n        if not np.isfinite(condJ) or condJ > 1e12:\n            delta = -R\n        else:\n            try:\n                delta = np.linalg.solve(J, -R)\n            except np.linalg.LinAlgError:\n                delta = -R\n\n        # Backtracking line search to ensure residual decrease\n        alpha = 1.0\n        Rnorm_old = rn\n        # Limit backtracking attempts to avoid infinite loop\n        for _ in range(12):\n            u_trial = u + alpha * delta\n            t_trial, Dt_trial, _ = friction_traction_and_tangent(u_trial, k_t, mu, p_n)\n            R_trial = Kb @ (w - u_trial) - t_trial\n            Rnorm_trial = float(np.linalg.norm(R_trial))\n            if Rnorm_trial <= Rnorm_old:\n                u = u_trial\n                break\n            alpha *= 0.5\n        else:\n            # If no decrease found, take the last trial step anyway to progress\n            u = u_trial\n\n    # Determine final regime based on converged or last state\n    if regime_final is None:\n        # Evaluate regime at last iterate\n        _, _, regime_final = friction_traction_and_tangent(u, k_t, mu, p_n)\n\n    # q-linear rate from last two iterations\n    if len(residual_norms) >= 2 and residual_norms[-2] > 0:\n        rate = residual_norms[-1] / residual_norms[-2]\n    else:\n        rate = 0.0\n\n    return {\n        \"iterations\": (len(residual_norms) - 1) if converged else max_iter,\n        \"rate\": rate,\n        \"converged\": converged,\n        \"regime\": regime_final,\n        \"u\": u,\n        \"residual_norms\": residual_norms,\n    }\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (stick-dominated)\n        {\"w\": np.array([0.05, 0.02]), \"k_b\": 500.0, \"k_t\": 1000.0, \"mu\": 0.3, \"p_n\": 100.0},\n        # Case B (slip with large jump)\n        {\"w\": np.array([0.5, 0.3]), \"k_b\": 500.0, \"k_t\": 1000.0, \"mu\": 0.3, \"p_n\": 100.0},\n        # Case C (near-boundary, high friction capacity)\n        {\"w\": np.array([0.5, 0.3]), \"k_b\": 500.0, \"k_t\": 1000.0, \"mu\": 2.0, \"p_n\": 100.0},\n        # Case D (direction flip, slip)\n        {\"w\": np.array([-0.6, 0.0]), \"k_b\": 500.0, \"k_t\": 1000.0, \"mu\": 0.3, \"p_n\": 100.0},\n        # Case E (exact-boundary magnitude in one direction)\n        {\"w\": np.array([0.09, 0.0]), \"k_b\": 500.0, \"k_t\": 1000.0, \"mu\": 0.3, \"p_n\": 100.0},\n    ]\n\n    results = []\n    for case in test_cases:\n        out = semi_smooth_newton(case[\"w\"], case[\"k_b\"], case[\"k_t\"], case[\"mu\"], case[\"p_n\"])\n        # Prepare per-case result: [iterations, rate, converged, regime]\n        # Round rate for compact output\n        rate_rounded = float(np.round(out[\"rate\"], 6))\n        results.append([out[\"iterations\"], rate_rounded, out[\"converged\"], out[\"regime\"]])\n\n    # Final print statement in the exact required format.\n    # Ensure booleans and numbers are printed in a clean list-of-lists representation.\n    def format_item(item):\n        if isinstance(item, bool):\n            return \"True\" if item else \"False\"\n        elif isinstance(item, (int, float)):\n            # Represent floats with up to 6 decimal places without trailing zeros\n            if isinstance(item, float):\n                return str(item)\n            return str(item)\n        else:\n            return str(item)\n\n    formatted = []\n    for res in results:\n        formatted.append(\"[\" + \",\".join(format_item(x) for x in res) + \"]\")\n    print(f\"[{','.join(formatted)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "除了摩擦，断裂和损伤累积是界面力学行为的另一个关键方面。本练习将深入探讨内聚区模型 (cohesive zone model)，这是一种模拟裂纹萌生和扩展的强大工具。您将为一个复杂的混合模式内聚损伤本构关系推导其一致的切线算子，这对于确保牛顿-拉弗森 (Newton-Raphson) 求解器在处理材料软化等非线性行为时达到二次收敛速度至关重要。通过这个实践，您将能够对复杂的材料失效过程进行精确建模 。",
            "id": "3571995",
            "problem": "考虑一个由耦合混合模式粘聚损伤模型控制的零厚度界面单元的单个积分点。目标是推导用于本构更新的一致算法切线算子，并评估在经历软化和潜在回弹的循环剪切下的 Newton–Raphson 收敛性。假设小变形和由光滑演化律正则化的率无关损伤。\n\n单位面积的界面自由能密度定义为\n$$\n\\psi(\\boldsymbol{\\delta}, d) = \\tfrac{1}{2}\\,(1-d)\\,\\boldsymbol{\\delta}^{\\mathsf{T}}\\,\\mathbf{K}\\,\\boldsymbol{\\delta},\n$$\n其中 $\\boldsymbol{\\delta} = \\begin{bmatrix}\\delta_n & \\delta_t\\end{bmatrix}^{\\mathsf{T}}$ 集合了法向和切向的位移跳跃（$\\delta_n$ 在张开时为正），$d \\in [0,1)$ 是一个标量损伤变量，$\\mathbf{K} \\in \\mathbb{R}^{2\\times 2}$ 是一个带耦合的对称正定弹性刚度矩阵，\n$$\n\\mathbf{K} = \\begin{bmatrix} K_n & K_{nt} \\\\ K_{nt} & K_t \\end{bmatrix},\\quad K_{nt} = \\alpha\\,\\sqrt{K_n\\,K_t},\\quad |\\alpha| < 1.\n$$\n牵引力由能量共轭关系得出：\n$$\n\\mathbf{t}(\\boldsymbol{\\delta}, d) = \\frac{\\partial \\psi}{\\partial \\boldsymbol{\\delta}} = (1-d)\\,\\mathbf{K}\\,\\boldsymbol{\\delta},\\quad \\mathbf{t} = \\begin{bmatrix} t_n \\\\ t_t \\end{bmatrix}.\n$$\n\n混合模式损伤由等效分离量驱动\n$$\nq(\\boldsymbol{\\delta}) = \\sqrt{\\boldsymbol{\\delta}^{\\mathsf{T}}\\,\\mathbf{M}\\,\\boldsymbol{\\delta}},\\quad \\mathbf{M} = \\begin{bmatrix} \\Delta_n^{-2} & \\rho\\,(\\Delta_n\\,\\Delta_t)^{-1} \\\\ \\rho\\,(\\Delta_n\\,\\Delta_t)^{-1} & \\gamma\\,\\Delta_t^{-2} \\end{bmatrix},\n$$\n其中 $\\gamma \\ge 0$ 和 $|\\rho| < 1$ 的选择应使 $\\mathbf{M}$ 为正定。历史变量 $\\kappa$ 通过以下方式强制不可逆性\n$$\n\\kappa = \\max\\{\\kappa_{\\text{prev}},\\,q(\\boldsymbol{\\delta})\\},\n$$\n受制于率无关损伤的标准 Kuhn–Tucker 条件。光滑损伤演化律为\n$$\nd(\\kappa) = \\begin{cases}\n0, & \\kappa \\le \\kappa_0,\\\\\n1 - \\dfrac{\\kappa_0}{\\kappa}\\,\\exp\\!\\Big(-\\dfrac{\\kappa - \\kappa_0}{S}\\Big), & \\kappa > \\kappa_0,\n\\end{cases}\n$$\n其中阈值 $\\kappa_0 > 0$，软化尺度 $S > 0$（两者都无量纲，因为 $\\kappa$ 是无量纲的）。该定律在 $\\kappa$ 上严格递增，并且当 $\\kappa \\to \\infty$ 时 $d \\to 1$。为符合物理真实性，所有分离量 $\\delta_n$ 和 $\\delta_t$ 以米表示，所有牵引力 $t_n$ 和 $t_t$ 以帕斯卡表示。\n\n任务 A（推导）：从自由能定义出发，推导一致算法切线矩阵\n$$\n\\mathbf{C} := \\frac{\\partial \\mathbf{t}}{\\partial \\boldsymbol{\\delta}} \\in \\mathbb{R}^{2\\times 2}\n$$\n该矩阵对于固定 $\\kappa_{\\text{prev}}$ 时的局部本构 Newton–Raphson 更新是精确的。您的推导必须仅使用链式法则、$q(\\boldsymbol{\\delta})$ 的定义、历史更新 $\\kappa = \\max\\{\\kappa_{\\text{prev}}, q\\}$ 以及给定的 $d(\\kappa)$。\n\n任务 B（算法设计）：考虑在力控制下，剪切方向上材料点的标量平衡，法向张开 $\\delta_n$ 固定：\n$$\nR(\\delta_t) = t_t(\\delta_n, \\delta_t) - T_{\\text{ext}} = 0,\n$$\n其中 $T_{\\text{ext}}$ 是外部施加的剪切牵引力，单位为帕斯卡。用残差 $R(\\delta_t)$ 和雅可比矩阵\n$$\nJ(\\delta_t) = \\frac{\\mathrm{d} R}{\\mathrm{d} \\delta_t} = \\mathbf{e}_t^{\\mathsf{T}}\\,\\mathbf{C}(\\boldsymbol{\\delta})\\,\\mathbf{e}_t,\\quad \\mathbf{e}_t = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix},\n$$\n构建一个 Newton–Raphson 迭代，同时在每次残差评估中一致地更新历史变量 $\\kappa$。声明一个基于绝对残差（单位为帕斯卡）的停止准则。\n\n任务 C（实现与测试）：实现一个程序，对下面列出的每个测试用例，按一系列载荷增量步进，并在每个增量中使用任务 A 中得到的一致算法切线为 $\\delta_t$ 执行标量 Newton–Raphson 求解。计算在最大迭代次数内收敛的增量数量。对于未收敛的增量，保留前一个收敛状态作为下一个增量的初始猜测值，而不更新 $\\kappa$。程序必须输出一行，将所有测试用例的收敛计数聚合为一个用方括号括起来的逗号分隔列表。\n\n使用以下固定的材料参数和单位：\n- $K_n = 5.0 \\times 10^{12}\\,\\text{Pa/m}$, $K_t = 2.0 \\times 10^{12}\\,\\text{Pa/m}$, $\\alpha$ 根据每个测试指定，因此 $K_{nt} = \\alpha\\,\\sqrt{K_n K_t}$。\n- $\\Delta_n = 5.0 \\times 10^{-6}\\,\\text{m}$, $\\Delta_t = 5.0 \\times 10^{-6}\\,\\text{m}$, $\\gamma$ 和 $\\rho$ 根据每个测试指定。\n- 损伤参数：$\\kappa_0 = 1.0$（无量纲），$S = 0.25$（无量纲）。\n- 初始历史变量为 $\\kappa_{\\text{prev}} = 0$。\n\n将在纯剪切起始下的峰值剪切牵引力定义为\n$$\nT_{\\text{peak}} = \\frac{K_t\\,\\kappa_0\\,\\Delta_t}{\\sqrt{\\gamma}} \\quad \\text{(帕斯卡)}.\n$$\n\n构建以下测试套件，其中 $N$ 是载荷步数，外部牵引力在每个阶段线性增加，求解器容差和迭代上限在所有测试中保持不变：\n- 测试 1（理想路径，低于峰值的单调加载，纯剪切）：$\\delta_n = 0$, $\\alpha = 0.2$, $\\gamma = 1.0$, $\\rho = 0.0$, $T_{\\max} = 0.8\\,T_{\\text{peak}}$，在 $N = 50$ 步内从 $0$ 单调斜坡加载至 $T_{\\max}$。\n- 测试 2（超过峰值的单调加载，纯剪切）：$\\delta_n = 0$, $\\alpha = 0.2$, $\\gamma = 1.0$, $\\rho = 0.0$, $T_{\\max} = 1.2\\,T_{\\text{peak}}$，在 $N = 50$ 步内从 $0$ 单调斜坡加载至 $T_{\\max}$。\n- 测试 3（超过峰值的循环加载，纯剪切）：$\\delta_n = 0$, $\\alpha = 0.2$, $\\gamma = 1.0$, $\\rho = 0.0$, $T_{\\max} = 1.1\\,T_{\\text{peak}}$，在 $N/2$ 步内从 $0$ 加载至 $T_{\\max}$，然后在 $N$ 步内加载至 $-T_{\\max}$，再在 $N/2$ 步内返回至 $0$，整个循环总步数为 $N = 60$。\n- 测试 4（带张开的混合模式耦合）：$\\delta_n = 2.0 \\times 10^{-6}\\,\\text{m}$（恒定），$\\alpha = 0.6$, $\\gamma = 1.0$, $\\rho = 0.3$（确保 $\\mathbf{M}$ 为正定），$T_{\\max} = 0.9\\,T_{\\text{peak}}$，在 $N = 50$ 步内从 $0$ 单调斜坡加载至 $T_{\\max}$。\n\n所有测试的数值设置：\n- Newton 容差：当 $|R(\\delta_t)| \\le 1.0 \\times 10^{3}\\,\\text{Pa}$ 时，宣告收敛。\n- 每增量最大迭代次数：$30$。\n- 第一个增量的初始猜测值：$\\delta_t^{(0)} = 0$。\n- 初始历史：$\\kappa = 0$。\n\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4\\right]$），其中每个 $\\text{result}_i$ 是一个整数，等于上面列出的相应测试用例的收敛增量数。",
            "solution": "### 任务A：一致算法切线的推导\n\n目标是推导一致算法切线矩阵 $\\mathbf{C} := \\dfrac{\\partial \\mathbf{t}}{\\partial \\boldsymbol{\\delta}}$。牵引力向量由 $\\mathbf{t} = (1-d)\\,\\mathbf{K}\\,\\boldsymbol{\\delta}$ 给出。\n对位移跳跃向量 $\\boldsymbol{\\delta}$ 应用乘积法则求导得到：\n$$\n\\mathbf{C} = \\frac{\\partial \\mathbf{t}}{\\partial \\boldsymbol{\\delta}} = (1-d)\\,\\mathbf{K} - \\frac{\\partial d}{\\partial \\boldsymbol{\\delta}} \\otimes (\\mathbf{K}\\,\\boldsymbol{\\delta})\n$$\n其中 $\\otimes$ 表示外积，即对于两个向量 $\\mathbf{a}$ 和 $\\mathbf{b}$，$(\\mathbf{a} \\otimes \\mathbf{b})_{ij} = a_i b_j$。因此，该表达式可以写成矩阵形式 $\\mathbf{C} = (1-d)\\,\\mathbf{K} - (\\mathbf{K}\\,\\boldsymbol{\\delta})\\left(\\dfrac{\\partial d}{\\partial \\boldsymbol{\\delta}}\\right)^{\\mathsf{T}}$。\n\n下一步是求损伤变量的导数 $\\dfrac{\\partial d}{\\partial \\boldsymbol{\\delta}}$。损伤 $d$ 是历史变量 $\\kappa$ 的函数，而 $\\kappa$ 又依赖于 $\\boldsymbol{\\delta}$。使用链式法则：\n$$\n\\frac{\\partial d}{\\partial \\boldsymbol{\\delta}} = \\frac{\\mathrm{d}d}{\\mathrm{d}\\kappa} \\frac{\\partial \\kappa}{\\partial \\boldsymbol{\\delta}}\n$$\n\n历史变量 $\\kappa$ 的更新规则由率无关塑性/损伤的 Kuhn-Tucker (KT) 条件控制，该条件将响应分为两种情况：\n\n**1. 弹性加载/卸载：**\n当当前的等效分离量 $q(\\boldsymbol{\\delta})$ 不超过先前存储的最大值时，即 $q(\\boldsymbol{\\delta}) \\le \\kappa_{\\text{prev}}$，发生此情况。在此情况下，$\\kappa = \\kappa_{\\text{prev}}$，它相对于当前的试探位移 $\\boldsymbol{\\delta}$ 是一个常数。\n因此，$\\dfrac{\\partial \\kappa}{\\partial \\boldsymbol{\\delta}} = \\mathbf{0}$，这意味着 $\\dfrac{\\partial d}{\\partial \\boldsymbol{\\delta}} = \\mathbf{0}$。切线矩阵简化为损伤弹性刚度：\n$$\n\\mathbf{C}_{\\text{elastic}} = (1-d)\\,\\mathbf{K} \\quad \\text{其中 } d = d(\\kappa_{\\text{prev}})\n$$\n这是一个对称矩阵。\n\n**2. 损伤加载：**\n当 $q(\\boldsymbol{\\delta}) > \\kappa_{\\text{prev}}$ 时，发生此情况。历史变量被主动更新，$\\kappa = q(\\boldsymbol{\\delta})$。我们必须计算链式法则表达式中的两项。\n\n首先，$\\dfrac{\\partial \\kappa}{\\partial \\boldsymbol{\\delta}} = \\dfrac{\\partial q}{\\partial \\boldsymbol{\\delta}}$。给定 $q(\\boldsymbol{\\delta}) = \\sqrt{\\boldsymbol{\\delta}^{\\mathsf{T}}\\,\\mathbf{M}\\,\\boldsymbol{\\delta}}$，我们可以对 $q^2 = \\boldsymbol{\\delta}^{\\mathsf{T}}\\,\\mathbf{M}\\,\\boldsymbol{\\delta}$ 进行微分。\n$$\n2q\\,\\frac{\\partial q}{\\partial \\boldsymbol{\\delta}} = 2\\,\\mathbf{M}\\,\\boldsymbol{\\delta} \\implies \\frac{\\partial q}{\\partial \\boldsymbol{\\delta}} = \\frac{1}{q}\\,\\mathbf{M}\\,\\boldsymbol{\\delta}\n$$\n由于在加载期间 $\\kappa = q$，我们有 $\\dfrac{\\partial \\kappa}{\\partial \\boldsymbol{\\delta}} = \\dfrac{1}{\\kappa}\\,\\mathbf{M}\\,\\boldsymbol{\\delta}$。\n\n其次，我们需要损伤演化律的导数 $d'(\\kappa) = \\dfrac{\\mathrm{d}d}{\\mathrm{d}\\kappa}$。对于 $\\kappa > \\kappa_0$：\n$$\nd(\\kappa) = 1 - \\frac{\\kappa_0}{\\kappa}\\,\\exp\\!\\left(-\\frac{\\kappa - \\kappa_0}{S}\\right)\n$$\n对 $\\kappa$ 求导：\n$$\nd'(\\kappa) = -\\left[ \\left(-\\frac{\\kappa_0}{\\kappa^2}\\right)\\exp\\!\\left(-\\frac{\\kappa - \\kappa_0}{S}\\right) + \\frac{\\kappa_0}{\\kappa}\\exp\\!\\left(-\\frac{\\kappa - \\kappa_0}{S}\\right)\\left(-\\frac{1}{S}\\right) \\right]\n= \\frac{\\kappa_0}{\\kappa^2}\\exp\\!\\left(-\\dots\\right) + \\frac{\\kappa_0}{\\kappa S}\\exp\\!\\left(-\\dots\\right)\n$$\n提出因子 $(1 - d(\\kappa)) = \\frac{\\kappa_0}{\\kappa}\\exp(-\\dots)$：\n$$\nd'(\\kappa) = \\frac{1-d(\\kappa)}{\\kappa} + \\frac{1-d(\\kappa)}{S} = (1-d(\\kappa))\\left(\\frac{1}{\\kappa} + \\frac{1}{S}\\right)\n$$\n对于 $\\kappa \\le \\kappa_0$，$d(\\kappa)=0$ 且 $d'(\\kappa)=0$。\n\n将这些结果组合用于损伤加载情况（$\\kappa = q(\\boldsymbol{\\delta}) > \\kappa_{\\text{prev}}$）：\n$$\n\\frac{\\partial d}{\\partial \\boldsymbol{\\delta}} = d'(\\kappa) \\frac{1}{\\kappa}\\,\\mathbf{M}\\,\\boldsymbol{\\delta}\n$$\n将此代入 $\\mathbf{C}$ 的表达式中：\n$$\n\\mathbf{C}_{\\text{loading}} = (1-d)\\,\\mathbf{K} - (\\mathbf{K}\\,\\boldsymbol{\\delta}) \\left(d'(\\kappa) \\frac{1}{\\kappa}\\,\\mathbf{M}\\,\\boldsymbol{\\delta}\\right)^{\\mathsf{T}} = (1-d)\\,\\mathbf{K} - \\frac{d'(\\kappa)}{\\kappa} (\\mathbf{K}\\,\\boldsymbol{\\delta}) \\otimes (\\mathbf{M}\\,\\boldsymbol{\\delta})\n$$\n该切线通常是非对称的，因为外积项 $(\\mathbf{K}\\,\\boldsymbol{\\delta})(\\mathbf{M}\\,\\boldsymbol{\\delta})^{\\mathsf{T}}$ 不是对称的。如果损伤不活跃（$\\kappa \\le \\kappa_0$），则 $d=0$ 且 $d'=0$，所以 $\\mathbf{C} = \\mathbf{K}$。\n\n### 任务B：Newton-Raphson 公式\n\n我们的目标是在固定的法向张开 $\\delta_n$ 和外部剪切牵引力 $T_{\\text{ext}}$ 下，求解标量平衡方程 $R(\\delta_t) = 0$ 以得到 $\\delta_t$。\n$$\nR(\\delta_t) = t_t(\\delta_n, \\delta_t) - T_{\\text{ext}}\n$$\n其中 $t_t = \\mathbf{e}_t^{\\mathsf{T}}\\,\\mathbf{t}(\\boldsymbol{\\delta})$，$\\mathbf{e}_t = \\begin{bmatrix}0\\\\1\\end{bmatrix}^{\\mathsf{T}}$ 且 $\\boldsymbol{\\delta} = \\begin{bmatrix}\\delta_n & \\delta_t\\end{bmatrix}^{\\mathsf{T}}$。对于第 $k$ 次迭代的 Newton-Raphson 迭代方案是：\n$$\n\\delta_t^{(k+1)} = \\delta_t^{(k)} - \\frac{R(\\delta_t^{(k)})}{J(\\delta_t^{(k)})}\n$$\n雅可比矩阵 $J(\\delta_t)$ 是残差对 $\\delta_t$ 的导数：\n$$\nJ(\\delta_t) = \\frac{\\mathrm{d} R}{\\mathrm{d} \\delta_t} = \\frac{\\mathrm{d} t_t}{\\mathrm{d} \\delta_t}\n$$\n使用链式法则，并注意到 $\\dfrac{\\partial \\boldsymbol{\\delta}}{\\partial \\delta_t} = \\mathbf{e}_t$：\n$$\nJ(\\delta_t) = \\frac{\\partial t_t}{\\partial \\boldsymbol{\\delta}} \\frac{\\partial \\boldsymbol{\\delta}}{\\partial \\delta_t} = \\mathbf{e}_t^{\\mathsf{T}} \\frac{\\partial \\mathbf{t}}{\\partial \\boldsymbol{\\delta}} \\mathbf{e}_t = \\mathbf{e}_t^{\\mathsf{T}}\\,\\mathbf{C}\\,\\mathbf{e}_t = C_{22}\n$$\n雅可比矩阵是任务A中推导的一致切线矩阵 $\\mathbf{C}$ 的 $(2,2)$ 分量。\n\n对于目标牵引力为 $T_{\\text{ext}}$ 的单个载荷增量的算法如下：\n1. 初始化迭代 $k=0$ 和猜测值 $\\delta_t^{(0)}$（来自前一个收敛步）。历史变量 $\\kappa_{\\text{prev}}$ 也取自前一个收敛状态。\n2. 对 $k = 0, 1, \\dots, \\text{max_iter}-1$ 进行 **循环**：\n   a. 形成位移跳跃向量 $\\boldsymbol{\\delta}^{(k)} = [\\delta_n, \\delta_t^{(k)}]^{\\mathsf{T}}$。\n   b. 评估状态：计算 $q^{(k)} = q(\\boldsymbol{\\delta}^{(k)})$，更新 $\\kappa^{(k)} = \\max\\{\\kappa_{\\text{prev}}, q^{(k)}\\}$，并找到 $d^{(k)} = d(\\kappa^{(k)})$。\n   c. 计算残差：$\\mathbf{t}^{(k)} = (1-d^{(k)})\\,\\mathbf{K}\\,\\boldsymbol{\\delta}^{(k)}$，以及 $R^{(k)} = t_t^{(k)} - T_{\\text{ext}}$。\n   d. 检查收敛：如果 $|R^{(k)}| \\le 1.0 \\times 10^3\\,\\text{Pa}$，则该增量已收敛。跳出循环。\n   e. 计算雅可比矩阵：根据在状态 $\\boldsymbol{\\delta}^{(k)}$ 下是加载还是卸载来评估 $\\mathbf{C}^{(k)}$，并取 $J^{(k)} = C_{22}^{(k)}$。\n   f. 更新：$\\delta_t^{(k+1)} = \\delta_t^{(k)} - R^{(k)}/J^{(k)}$。\n3. 如果收敛，则为下一个增量更新全局状态变量：$\\delta_t^{\\text{next\\_guess}} \\gets \\delta_t^{(k+1)}$ 和 $\\kappa_{\\text{prev}} \\gets \\kappa^{(k)}$。\n4. 如果未收敛，状态不更新，前一个收敛状态将再次用作下一个载荷增量的起点。\n\n### 任务C：实现与测试用例分析\n\n该算法在 Python 中实现。一个中心函数管理每个载荷步的 Newton-Raphson 迭代。每个测试用例的载荷历史被预先计算。\n\n- **测试 1**：纯剪切下单调加载至 $0.8\\,T_{\\text{peak}}$。由于载荷保持在峰值牵引力以下，模型始终处于稳定的硬化阶段。因此，所有 $50$ 个增量预计都能顺利收敛。\n\n- **测试 2**：纯剪切下单调加载至 $1.2\\,T_{\\text{peak}}$。模型在达到 $T_{\\text{peak}}$ 后表现出软化。在力控制设置中，对于 $T_{\\text{ext}} > T_{\\text{peak}}$ 不存在平衡解。只有当 $T_{\\text{ext},i} \\le T_{\\text{peak}}$ 时，增量才会收敛。对于 $T_{\\text{ext},i} = \\frac{i}{50} \\times 1.2\\,T_{\\text{peak}}$，此条件在 $i \\le 50/1.2 \\approx 41.67$ 时成立。因此，预计增量 $1$ 到 $41$ 会收敛，其余的则失败。预期计数为 $41$。\n\n- **测试 3**：纯剪切下循环加载，振幅为 $1.1\\,T_{\\text{peak}}$。载荷路径在 $60$ 步内包含三个阶段：加载到 $1.1\\,T_{\\text{peak}}$（15步），反向加载到 $-1.1\\,T_{\\text{peak}}$（30步），然后返回到零（15步）。\n    - 阶段 1 ($0 \\to 1.1\\,T_{\\text{peak}}$)：当 $T_{\\text{ext}} > T_{\\text{peak}}$ 时，步骤失败。这发生在第 14 和 15 步。收敛：$13$ 步。\n    - 阶段 2 ($1.1\\,T_{\\text{peak}} \\to -1.1\\,T_{\\text{peak}}$)：初始步骤也因 $|T_{\\text{ext}}| > T_{\\text{peak}}$ 而失败。收敛从第 17 步开始（当 $|T_{\\text{ext}}|$ 降至 $T_{\\text{peak}}$ 以下时）并在第 43 步结束（在负向上 $|T_{\\text{ext}}|$ 超过 $T_{\\text{peak}}$ 之前）。收敛：$27$ 步。\n    - 阶段 3 ($-1.1\\,T_{\\text{peak}} \\to 0$)：类似地，一旦 $|T_{\\text{ext}}|$ 降至 $T_{\\text{peak}}$ 以下，收敛从第 47 步开始。所有后续步骤均收敛。收敛：$14$ 步。\n    总收敛增量数：$13 + 27 + 14 = 54$。\n\n- **测试 4**：具有恒定法向张开的混合模式加载。最大施加的剪切牵引力为 $0.9\\,T_{\\text{peak}}$。尽管混合模式条件改变了详细响应，但施加的载荷远在稳定区域内，并未接近混合模式极限牵引力。因此，预计所有 $50$ 个增量都能实现鲁棒收敛。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and implements a cohesive damage model to solve four test cases.\n    The main function orchestrates the setup and execution of each test,\n    collecting the number of converged increments as the result.\n    \"\"\"\n    \n    # Define fixed material parameters and numerical settings\n    Kn = 5.0e12  # Pa/m\n    Kt = 2.0e12  # Pa/m\n    delta_n_char = 5.0e-6  # m\n    delta_t_char = 5.0e-6  # m\n    kappa_0 = 1.0  # dimensionless\n    S = 0.25  # dimensionless\n    \n    TOL = 1.0e3  # Pa\n    MAX_ITER = 30\n    \n    # Test case definitions\n    test_cases_params = [\n        # Test 1: Monotonic below peak, pure shear\n        {'delta_n': 0.0, 'alpha': 0.2, 'gamma': 1.0, 'rho': 0.0, 'T_max_factor': 0.8, 'path_spec': [ (1.0, 50) ]},\n        # Test 2: Monotonic beyond peak, pure shear\n        {'delta_n': 0.0, 'alpha': 0.2, 'gamma': 1.0, 'rho': 0.0, 'T_max_factor': 1.2, 'path_spec': [ (1.0, 50) ]},\n        # Test 3: Cyclic beyond peak, pure shear (15 up, 30 reverse, 15 unload)\n        {'delta_n': 0.0, 'alpha': 0.2, 'gamma': 1.0, 'rho': 0.0, 'T_max_factor': 1.1, 'path_spec': [ (1.0, 15), (-1.0, 30), (0.0, 15) ]},\n        # Test 4: Mixed-mode with opening\n        {'delta_n': 2.0e-6, 'alpha': 0.6, 'gamma': 1.0, 'rho': 0.3, 'T_max_factor': 0.9, 'path_spec': [ (1.0, 50) ]},\n    ]\n\n    results = []\n\n    for params in test_cases_params:\n        # Unpack parameters and set up matrices\n        delta_n = params['delta_n']\n        alpha = params['alpha']\n        gamma = params['gamma']\n        rho = params['rho']\n        \n        K_nt = alpha * np.sqrt(Kn * Kt)\n        K = np.array([[Kn, K_nt], [K_nt, Kt]])\n\n        M = np.array([\n            [1.0 / delta_n_char**2, rho / (delta_n_char * delta_t_char)],\n            [rho / (delta_n_char * delta_t_char), gamma / delta_t_char**2]\n        ])\n\n        # Generate load path\n        T_peak = (Kt * kappa_0 * delta_t_char) / np.sqrt(gamma);\n        T_max = params['T_max_factor'] * T_peak\n        \n        load_path = []\n        T_current = 0.0\n        for T_target_factor, num_steps in params['path_spec']:\n            T_target = T_target_factor * T_max\n            # For the cyclic case, T_target can be 0.0, but a factor is needed. Let's adjust target.\n            if T_target_factor == 0.0: T_target = 0.0\n\n            T_vals = np.linspace(T_current, T_target, num_steps + 1)[1:]\n            load_path.extend(T_vals)\n            T_current = T_target\n\n        # Initialize state variables\n        kappa_prev = 0.0\n        delta_t_converged = 0.0\n        converged_count = 0\n\n        # Loop over load increments\n        for t_ext in load_path:\n            delta_t = delta_t_converged  # Initial guess is the last converged state\n            converged = False\n            \n            for _ in range(MAX_ITER):\n                delta = np.array([delta_n, delta_t])\n                \n                q_squared = delta.T @ M @ delta\n                q = np.sqrt(q_squared) if q_squared > 1e-30 else 0.0\n\n                kappa = max(kappa_prev, q)\n                \n                # Compute damage and derivative\n                if kappa <= kappa_0:\n                    d = 0.0\n                else:\n                    d = 1.0 - (kappa_0 / kappa) * np.exp(-(kappa - kappa_0) / S)\n                \n                t = (1.0 - d) * (K @ delta)\n                R = t[1] - t_ext\n                \n                if abs(R) <= TOL:\n                    converged = True\n                    break\n\n                # Compute Jacobian J = C[1,1]\n                is_loading = (q > kappa_prev) and (q > 1e-12)\n\n                if not is_loading:\n                    J = (1.0 - d) * K[1, 1]\n                else: # Damage loading\n                    if kappa <= kappa_0:\n                        J = K[1, 1]\n                    else:\n                        d_prime = (1.0 - d) * (1.0 / kappa + 1.0 / S) if kappa > 0 else 0.0\n                        Kd = K @ delta\n                        Md = M @ delta\n                        J = (1.0 - d) * K[1, 1] - (d_prime / kappa) * Kd[1] * Md[1]\n\n                if abs(J) < 1e-9: # Singular Jacobian\n                    break\n\n                delta_t -= R / J\n            \n            # Post-increment processing\n            if converged:\n                converged_count += 1\n                delta_t_converged = delta_t\n                \n                # Update history variable based on final converged state\n                delta_final = np.array([delta_n, delta_t_converged])\n                q_final_sq = delta_final.T @ M @ delta_final\n                q_final = np.sqrt(q_final_sq) if q_final_sq > 0 else 0.0\n                kappa_prev = max(kappa_prev, q_final)\n            # else: per problem, state is not updated, guess for next step remains the same.\n\n        results.append(converged_count)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}