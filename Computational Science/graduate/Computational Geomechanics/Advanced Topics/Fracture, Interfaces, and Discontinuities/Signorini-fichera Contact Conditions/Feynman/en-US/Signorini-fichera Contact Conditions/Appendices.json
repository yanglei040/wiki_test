{
    "hands_on_practices": [
        {
            "introduction": "This practice provides a foundational exercise in implementing and verifying numerical methods for unilateral contact. By analyzing a one-dimensional elastic bar, you will derive an exact analytical solution and then use it as a benchmark to evaluate the accuracy and convergence of two widely used techniques: the penalty method and Nitsche's method. This exercise is crucial for developing a core understanding of how contact constraints are translated into finite element formulations and for building essential skills in code verification. ",
            "id": "3558634",
            "problem": "Consider a one-dimensional, static, linear elastic bar on the interval $[0,L]$ with Young’s modulus $E$, cross-sectional area $A$, and a uniform body force per unit length $f_0$. The unknown displacement field is $u(x)$ along the bar axis, measured in meters. The left end at $x=0$ is fixed, so $u(0)=0$. The right end at $x=L$ is in unilateral frictionless contact with a rigid stop located at a gap $g$ measured in meters. The governing equilibrium is the one-dimensional linear momentum balance $-(E A u')' = f_0$ on $(0,L)$ together with the Signorini-Fichera contact conditions at $x=L$,\n$$\nu(L) - g \\le 0,\\quad t(L) \\le 0,\\quad t(L)\\,\\big(u(L) - g\\big) = 0,\n$$\nwhere $t(L)$ denotes the normal traction at $x=L$ (with compression taken as nonpositive).\n\nYour task is to:\n- Derive an analytic, piecewise solution $u(x)$ consistent with $-(E A u')' = f_0$, $u(0)=0$, and the Signorini-Fichera boundary conditions.\n- Construct and implement two computational approximations within the Finite Element Method (FEM) using continuous, piecewise-linear basis functions on a uniform mesh:\n  1. A penalty method that enforces the unilateral contact by augmenting the weak formulation with a boundary penalty depending on a penalty parameter $\\alpha > 0$.\n  2. A symmetric Nitsche-type stabilization method for unilateral contact that weakly enforces the boundary constraint on the active set using a stabilization parameter $\\gamma > 0$ scaled by the local mesh size at $x=L$.\n- For each method, compute the approximate displacement field $u_h(x)$ and the error in the displacement measured in the $L^2$ norm over $[0,L]$, that is $\\lVert u - u_h \\rVert_{L^2(0,L)}$, in meters, using Gaussian quadrature that is exact for polynomials up to degree two.\n- As a function of the uniform mesh size $h=L/N$ for $N$ elements, estimate the observed convergence rate $p$ defined by the slope obtained from a linear regression of $\\log(\\lVert u - u_h \\rVert_{L^2})$ versus $\\log(h)$, assuming a power-law relationship $\\lVert u - u_h \\rVert_{L^2} \\approx C h^p$ for some constant $C>0$.\n\nImplement a complete program that:\n- Assembles the standard stiffness matrix for the one-dimensional bar using piecewise-linear elements and the body force $f_0$.\n- Enforces the essential boundary condition at $x=0$ strongly.\n- Decides contact active or inactive by first computing the unconstrained solution and evaluating the gap condition at $x=L$; if active, applies the chosen method’s boundary terms only on the active set; if inactive, leaves the right boundary natural.\n- Computes the $L^2$ error by element-wise Gauss quadrature on each mesh.\n- For each test case, evaluates the errors at multiple mesh sizes and returns the regression-based convergence rate $p$ for both the penalty and Nitsche methods.\n\nUse the following scientifically plausible parameter values that form the test suite:\n- Material and geometry for all tests: $L=1.0\\,\\mathrm{m}$, $E=30\\times 10^9\\,\\mathrm{Pa}$, $A=0.01\\,\\mathrm{m}^2$, uniform body force $f_0=1.0\\times 10^5\\,\\mathrm{N/m}$.\n- Mesh sizes for each test: $N\\in\\{10,20,40\\}$ (so $h=L/N$).\n- Test Case 1 (inactive contact, happy path): $g=2.0\\times 10^{-4}\\,\\mathrm{m}$, penalty parameter $\\alpha=1.0\\times 10^9$, Nitsche stabilization parameter $\\gamma=10.0$.\n- Test Case 2 (active contact, moderate gap): $g=1.0\\times 10^{-4}\\,\\mathrm{m}$, penalty parameter $\\alpha=1.0\\times 10^7$, Nitsche stabilization parameter $\\gamma=10.0$.\n- Test Case 3 (active contact, rigid stop at the boundary): $g=0.0\\,\\mathrm{m}$, penalty parameter $\\alpha=1.0\\times 10^6$, Nitsche stabilization parameter $\\gamma=10.0$.\n\nYour program should produce a single line of output containing the six convergence rates as a comma-separated list enclosed in square brackets, ordered as $[p_{\\text{pen},1},p_{\\text{nit},1},p_{\\text{pen},2},p_{\\text{nit},2},p_{\\text{pen},3},p_{\\text{nit},3}]$, where $p_{\\text{pen},k}$ and $p_{\\text{nit},k}$ correspond to the penalty and Nitsche methods respectively for Test Case $k$. The rates $p$ are dimensionless floats.\n\nNo user input is allowed; the program must run as-is and compute these quantities exactly for the specified test suite.",
            "solution": "The user wants to solve a one-dimensional unilateral contact problem for a linear elastic bar and analyze the convergence of two different Finite Element Method (FEM) formulations: the penalty method and a symmetric Nitsche's method.\n\n### Step 1: Analytical Solution\n\nThe governing ordinary differential equation (ODE) for the displacement $u(x)$ is $-(E A u'(x))' = f_0$, where $E$, $A$, and $f_0$ are constants. Integrating twice with respect to $x$ yields the general solution:\n$$\nu(x) = -\\frac{f_0}{2EA} x^2 + C_1 x + C_2\n$$\nThe constants of integration, $C_1$ and $C_2$, are determined by the boundary conditions. The left end is fixed, $u(0)=0$, which implies $C_2=0$.\n$$\nu(x) = -\\frac{f_0}{2EA} x^2 + C_1 x\n$$\nThe right end at $x=L$ is subject to the Signorini-Fichera conditions:\n1.  $u(L) - g \\le 0$ (non-penetration)\n2.  $t(L) \\le 0$ (compressive or zero traction), where $t(L) = E u'(L)$\n3.  $t(L)(u(L) - g) = 0$ (complementarity)\n\nThere are two possible states for the contact.\n\n**Case 1: Inactive Contact (Gap remains open)**\nThis state occurs when the bar, under a free boundary condition at $x=L$, does not reach the stop. A free boundary implies zero traction, $t(L)=0$.\n$t(L) = E u'(L) = E \\left(-\\frac{f_0 L}{EA} + C_1\\right) = -\\frac{f_0 L}{A} + E C_1 = 0 \\implies C_1 = \\frac{f_0 L}{EA}$.\nThe displacement field is $u_{\\text{free}}(x) = \\frac{f_0}{EA} (Lx - \\frac{x^2}{2})$.\nThe displacement at the end is $u_{\\text{free}}(L) = \\frac{f_0 L^2}{2EA}$.\nThis solution is valid if it satisfies the Signorini conditions. $t(L)=0 \\le 0$ is satisfied. The complementarity condition is satisfied. The non-penetration condition $u(L) \\le g$ requires $\\frac{f_0 L^2}{2EA} \\le g$.\n\n**Case 2: Active Contact (Gap closes)**\nThis state occurs if the free-end displacement would exceed the gap, i.e., $\\frac{f_0 L^2}{2EA} > g$. In this case, the non-penetration condition becomes binding: $u(L)=g$.\nUsing this to find $C_1$:\n$u(L) = g = -\\frac{f_0 L^2}{2EA} + C_1 L \\implies C_1 = \\frac{g}{L} + \\frac{f_0 L}{2EA}$.\nThe displacement field is $u(x) = \\left(\\frac{g}{L} + \\frac{f_0 L}{2EA}\\right)x - \\frac{f_0 x^2}{2EA}$.\nThis solution is valid if $t(L) \\le 0$.\n$t(L) = E u'(L) = E \\left( \\frac{g}{L} + \\frac{f_0 L}{2EA} - \\frac{f_0 L}{EA} \\right) = \\frac{Eg}{L} - \\frac{f_0 L}{2A}$.\nThe condition $t(L) \\le 0$ is equivalent to $\\frac{Eg}{L} \\le \\frac{f_0 L}{2A}$, which simplifies to $g \\le \\frac{f_0 L^2}{2EA}$, confirming the condition for contact activation. The complementarity is satisfied because $u(L)-g=0$.\n\nLet $u_{\\text{max}} = \\frac{f_0 L^2}{2EA}$. The complete analytical solution is:\n$$\nu(x) =\n\\begin{cases}\n    \\frac{f_0}{2EA}(2Lx - x^2)  \\text{if } g \\ge u_{\\text{max}} \\quad (\\text{inactive}) \\\\\n    \\frac{g}{L}x + \\frac{f_0}{2EA}(Lx - x^2)  \\text{if } g  u_{\\text{max}} \\quad (\\text{active})\n\\end{cases}\n$$\n\n### Step 2: Finite Element Weak Formulation\n\nThe starting point is the weak form of the equilibrium equation. For a test function $v$ with $v(0)=0$:\n$$\n\\int_0^L EA u' v' dx = \\int_0^L f_0 v dx + T(L) v(L)\n$$\nwhere $T(L) = A t(L)$ is the reaction force at the contact. Discretizing with piecewise linear elements on a uniform mesh of size $h=L/N$, we obtain a system of algebraic equations $K\\mathbf{u} = \\mathbf{F}$. We employ an active-set strategy: first, solve with $T(L)=0$ (natural boundary condition) to get $u_h^{\\text{free}}$. If $u_h^{\\text{free}}(L) > g$, we resolve the system with contact constraints.\n\n**Penalty Method (Active Contact)**\nThe unilateral constraint is approximated by adding a penalty energy term $\\frac{1}{2}\\alpha(u(L)-g)^2$ to the total potential energy, where $\\alpha \\gg 0$ is a penalty parameter. The variation of this term adds $\\alpha (u(L)-g) v(L)$ to the weak form. This modifies only the last equation of the FEM system (corresponding to node $N$ at $x=L$). The stiffness matrix entry $K_{NN}$ and force vector entry $F_N$ are modified:\n$$\nK_{NN} \\to K_{NN} + \\alpha, \\quad F_N \\to F_N + \\alpha g\n$$\n\n**Symmetric Nitsche's Method (Active Contact)**\nThis method enforces the Dirichlet-type condition $u(L)=g$ weakly without large penalty parameters. It modifies the weak form by adding terms that enforce the constraint in a consistent and stable manner. The symmetric formulation is:\nFind $u_h \\in V_h$ such that for all $v_h \\in V_h$:\n$$\na_h(u_h, v_h) = \\ell_h(v_h)\n$$\nwhere\n$$\na_h(u, v) = \\int_0^L EA u'v' dx - (EA u'(L))v(L) - (EA v'(L))u(L) + \\frac{\\gamma EA}{h} u(L)v(L)\n$$\n$$\n\\ell_h(v) = \\int_0^L f_0 v dx - (EA v'(L))g + \\frac{\\gamma EA}{h} gv(L)\n$$\nHere, $\\gamma > 0$ is a dimensionless stabilization parameter. With piecewise linear elements, the derivatives $u_h'(L)$ and $v_h'(L)$ are the constant derivatives on the last element $[x_{N-1}, L]$. These modifications affect the last two rows and columns of the FEM system matrix. The resulting modified entries in the $N \\times N$ system (for DoFs $u_1, ..., u_N$) are:\n$$\nK_{N-1, N} \\to 0, \\quad K_{N, N-1} \\to 0\n$$\n$$\nK_{N, N} \\to (\\gamma-1)\\frac{EA}{h}\n$$\n$$\nF_{N-1} \\to F_{N-1} + \\frac{EAg}{h}, \\quad F_{N} \\to F_{N} + (\\gamma-1)\\frac{EAg}{h}\n$$\n\n### Step 3: Numerical Implementation and Convergence Analysis\n\nThe program implements these steps for the given test cases.\n1.  **Assembly**: The standard $N \\times N$ stiffness matrix and force vector for a fixed-free bar are assembled.\n2.  **Active Set**: The unconstrained solution is computed to determine if contact is active.\n3.  **Solution**: If contact is inactive, the unconstrained solution is used. If active, the appropriate modifications for the penalty or Nitsche method are applied to the matrix and vector, and the system is solved again.\n4.  **Error Calculation**: The $L^2$ error $\\lVert u - u_h \\rVert_{L^2}$ is computed by summing element-wise contributions calculated using two-point Gaussian quadrature.\n5.  **Convergence Rate**: The error is computed for meshes with $N=10, 20, 40$. A linear regression is performed on the log-log plot of error versus mesh size $h$. The slope of the line gives the observed convergence rate $p$. This process is repeated for both methods across all three test cases.\n\nThe expected convergence rate for both methods with linear elements is $p=2$, as the exact solution is piecewise smooth and the error is measured in the $L^2$ norm.",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import solve as solve_linear_system\n\ndef solve():\n    \"\"\"\n    Solves a 1D unilateral contact problem for an elastic bar using FEM,\n    comparing penalty and Nitsche methods for convergence analysis.\n    \"\"\"\n    \n    # --- Problem Parameters ---\n    L = 1.0       # m\n    E = 30.0e9    # Pa\n    A = 0.01      # m^2\n    f0 = 1.0e5    # N/m\n    EA = E * A\n\n    # --- Test Cases ---\n    test_cases = [\n        {'g': 2.0e-4, 'alpha': 1.0e9, 'gamma': 10.0, 'id': '1 (inactive)'},\n        {'g': 1.0e-4, 'alpha': 1.0e7, 'gamma': 10.0, 'id': '2 (active)'},\n        {'g': 0.0,    'alpha': 1.0e6, 'gamma': 10.0, 'id': '3 (active)'},\n    ]\n    \n    mesh_Ns = [10, 20, 40]\n    all_rates = []\n\n    # --- Gaussian Quadrature (2-point) ---\n    gauss_points = np.array([-1.0/np.sqrt(3.0), 1.0/np.sqrt(3.0)])\n    gauss_weights = np.array([1.0, 1.0])\n\n    # --- Analytical Solution ---\n    u_max_free = f0 * L**2 / (2 * EA)\n\n    def get_analytic_solution(g_val):\n        if g_val = u_max_free: # Inactive contact\n            def u_exact(x):\n                return (f0 / (2 * EA)) * (2 * L * x - x**2)\n        else: # Active contact\n            def u_exact(x):\n                return (g_val / L) * x + (f0 / (2 * EA)) * (L * x - x**2)\n        return u_exact\n\n    for case in test_cases:\n        g = case['g']\n        alpha = case['alpha']\n        gamma = case['gamma']\n        \n        u_exact_func = get_analytic_solution(g)\n\n        for method in ['penalty', 'nitsche']:\n            h_values = []\n            l2_errors = []\n\n            for N in mesh_Ns:\n                h = L / N\n                nodes = np.linspace(0, L, N + 1)\n                \n                # Assemble system for unknown DOFs u_1, ..., u_N (size N x N)\n                K_unconstrained = np.zeros((N, N))\n                F_unconstrained = np.zeros(N)\n\n                # Stiffness matrix with natural BC at x=L\n                diag0 = np.full(N, 2 * EA / h)\n                diag1 = np.full(N - 1, -EA / h)\n                K_unconstrained += np.diag(diag0) + np.diag(diag1, k=1) + np.diag(diag1, k=-1)\n                K_unconstrained[N - 1, N - 1] = EA / h\n                \n                # Force vector\n                F_unconstrained[:] = f0 * h\n                F_unconstrained[N-1] = f0 * h / 2.0\n\n                # --- Active Set Strategy ---\n                u_free = solve_linear_system(K_unconstrained, F_unconstrained)\n                u_N_free = u_free[-1]\n                is_active = (u_N_free  g)\n\n                K, F = K_unconstrained.copy(), F_unconstrained.copy()\n                if is_active:\n                    if method == 'penalty':\n                        K[N-1, N-1] += alpha\n                        F[N-1] += alpha * g\n                    elif method == 'nitsche':\n                        # The modifications implement the derived symmetric Nitsche form\n                        F[N-2] += EA * g / h\n                        F[N-1] += (gamma - 1) * EA * g / h\n                        \n                        K[N-2, N-1] = 0.0\n                        K[N-1, N-2] = 0.0\n                        K[N-1, N-1] = (gamma-1) * EA / h\n\n                u_h_dofs = solve_linear_system(K, F)\n                # Full solution vector including the fixed DoF u_0 = 0\n                u_h_full = np.concatenate(([0.0], u_h_dofs))\n\n                # --- Error Calculation (L2 norm) ---\n                total_error_sq = 0.0\n                for i in range(N):\n                    elem_nodes = nodes[i:i+2]\n                    elem_dofs = u_h_full[i:i+2]\n                    \n                    x_gauss = elem_nodes[0] + (h / 2.0) * (1.0 + gauss_points)\n                    u_exact_vals = u_exact_func(x_gauss)\n                    \n                    shape_func_vals_at_gauss = 0.5 * np.array([1.0 - gauss_points, 1.0 + gauss_points])\n                    u_h_vals = elem_dofs @ shape_func_vals_at_gauss\n                    \n                    integrand = (u_exact_vals - u_h_vals)**2\n                    elem_error_sq = (h / 2.0) * np.sum(gauss_weights * integrand)\n                    total_error_sq += elem_error_sq\n                \n                l2_error = np.sqrt(total_error_sq)\n                h_values.append(h)\n                l2_errors.append(l2_error)\n            \n            # --- Convergence Rate Calculation ---\n            log_h = np.log(h_values)\n            log_err = np.log(l2_errors)\n            p, _ = np.polyfit(log_h, log_err, 1)\n            all_rates.append(p)\n\n    print(f\"[{','.join(f'{rate:.10f}' for rate in all_rates)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Building on the enforcement of contact, this practice explores a more advanced and robust solution algorithm based on complementarity functions. You will reformulate the Signorini-Fichera conditions into a system of semismooth equations using the Fischer-Burmeister function, which can be solved efficiently with a generalized Newton method. This exercise is invaluable for understanding the mathematical underpinnings of modern contact solvers and for learning how to handle the non-smooth nature of complementarity directly and elegantly. ",
            "id": "3558641",
            "problem": "Consider a single-degree-of-freedom, frictionless, unilateral contact problem between an elastic node and a rigid obstacle, modeled within the framework of computational geomechanics. Let $u \\in \\mathbb{R}$ denote the nodal displacement measured along the inward normal toward the obstacle, and let $k \\in \\mathbb{R}_{0}$ denote the linear elastic stiffness of the support. Let $f \\in \\mathbb{R}$ denote the applied external load in the positive direction, and let $\\lambda \\in \\mathbb{R}_{\\ge 0}$ denote the normal contact pressure (Lagrange multiplier) acting on the node. Let the normal gap function be $g(u) = c - u$, where $c \\in \\mathbb{R}$ is the initial clearance (positive when the obstacle is not initially touching the node). The Signorini-Fichera contact conditions express the unilateral impenetrability and contact pressure non-negativity as $g(u) \\ge 0$, $\\lambda \\ge 0$, and $g(u)\\,\\lambda = 0$.\n\nStarting from the following fundamental base:\n- Linear momentum balance for the quasi-static one-degree-of-freedom elastic system: $k\\,u + \\lambda = f$.\n- The Signorini-Fichera complementarity conditions: $g(u) \\ge 0$, $\\lambda \\ge 0$, and $g(u)\\,\\lambda = 0$.\n- The Fischer–Burmeister function (FB) $\\phi:\\mathbb{R}\\times\\mathbb{R}\\to\\mathbb{R}$ defined by $\\phi(a,b) = \\sqrt{a^2 + b^2} - a - b$.\n\nYour tasks are:\n1. Derive a semismooth reformulation of the normal complementarity conditions by replacing $0 \\le g(u) \\perp \\lambda \\ge 0$ with the single equation $\\phi(g(u),\\lambda) = 0$. Combine this with equilibrium to define a residual mapping $R:\\mathbb{R}^2 \\to \\mathbb{R}^2$ suitable for use in a Newton-type method. Do not assume any differentiability of the FB function at the origin a priori; instead, use semismooth analysis concepts to justify your residual and its generalized derivative.\n2. Derive a generalized Jacobian suitable for a semismooth Newton step by computing partial derivatives of the FB function at points $(a,b) \\ne (0,0)$ and selecting a consistent element of the Clarke subdifferential at $(a,b) = (0,0)$.\n3. Implement a damped semismooth Newton-type solver that, given $(k,c,f)$ and an initial guess $(u_0,\\lambda_0)$, computes an approximate solution $(u^\\star,\\lambda^\\star)$ to the system $R(u,\\lambda) = 0$, terminating when the Euclidean norm of the residual is less than $10^{-10}$ or after a maximum of $50$ iterations. Use a simple backtracking line search on the residual norm to promote global convergence.\n4. For each test case below, run the solver with $(u_0,\\lambda_0) = (0,0)$ and report three dimensionless numbers per case: $u^\\star$, $\\lambda^\\star$, and the Euclidean norm of the final residual $\\lVert R(u^\\star,\\lambda^\\star) \\rVert_2$. All quantities in this problem are nondimensional; report all outputs as dimensionless numbers.\n\nUse the following test suite, chosen to cover a typical case, an active-contact case, the degenerate nonsmooth point, and a boundary case:\n- Test case $1$ (no contact expected): $k = 1000$, $c = 0.15$, $f = 100$.\n- Test case $2$ (active contact expected): $k = 1000$, $c = 0.05$, $f = 400$.\n- Test case $3$ (degenerate at the origin): $k = 1000$, $c = 0$, $f = 0$.\n- Test case $4$ (boundary case with $f = k\\,c$): $k = 800$, $c = 0.2$, $f = 160$.\n\nYour program must:\n- Implement the residual $R(u,\\lambda)$ from first principles based on the above foundations and the specified semismooth reformulation.\n- Implement a consistent generalized Jacobian using a principled selection at $(a,b) = (0,0)$.\n- Apply a damped semismooth Newton method with a backtracking line search that reduces the step length by a factor of $1/2$ until sufficient decrease in the residual norm is observed or a minimum step length of $2^{-20}$ is reached.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list of floats enclosed in square brackets, in the order $[u_1^\\star,\\lambda_1^\\star,\\lVert R_1\\rVert_2, u_2^\\star,\\lambda_2^\\star,\\lVert R_2\\rVert_2, u_3^\\star,\\lambda_3^\\star,\\lVert R_3\\rVert_2, u_4^\\star,\\lambda_4^\\star,\\lVert R_4\\rVert_2]$, where the subscript denotes the test case index.\n- Print each float with exactly $10$ digits after the decimal point.",
            "solution": "The problem requires the formulation and implementation of a semismooth Newton method for a single-degree-of-freedom unilateral contact problem. The process involves deriving a residual function based on a Fischer-Burmeister reformulation of the contact conditions, computing a corresponding generalized Jacobian, and implementing a damped Newton-type solver.\n\n### Step 1: Semismooth Reformulation and Residual Mapping\n\nThe mechanical system is governed by a set of equations and inequalities. The equilibrium of the node is described by the linear momentum balance:\n$$k\\,u + \\lambda = f$$\nwhere $k \\in \\mathbb{R}_{>0}$ is the stiffness, $u \\in \\mathbb{R}$ is the displacement, $\\lambda \\in \\mathbb{R}_{\\ge 0}$ is the contact pressure (a Lagrange multiplier), and $f \\in \\mathbb{R}$ is the external load.\n\nThe contact itself is described by the Signorini-Fichera conditions, which enforce impenetrability ($g(u) \\ge 0$), non-tensile contact pressure ($\\lambda \\ge 0$), and the fact that pressure can only exist when the gap is closed ($g(u)\\,\\lambda=0$). With the gap function defined as $g(u) = c - u$, where $c$ is the initial clearance, these conditions are expressed concisely as a complementarity problem:\n$$0 \\le (c - u) \\perp \\lambda \\ge 0$$\n\nTo solve this system numerically, we replace the non-smooth complementarity condition with a single, equivalent, non-differentiable equation using the Fischer-Burmeister (FB) function $\\phi: \\mathbb{R}\\times\\mathbb{R} \\to \\mathbb{R}$, defined as:\n$$\\phi(a,b) = \\sqrt{a^2 + b^2} - a - b$$\nThe property $\\phi(a,b) = 0$ is equivalent to the complementarity condition $0 \\le a \\perp b \\ge 0$. By setting $a = g(u) = c-u$ and $b = \\lambda$, we reformulate the contact law as a single equation:\n$$\\phi(c-u, \\lambda) = \\sqrt{(c-u)^2 + \\lambda^2} - (c-u) - \\lambda = 0$$\n\nCombining this with the equilibrium equation, we obtain a system of two nonlinear equations for the two unknowns $(u, \\lambda)$. We define a residual mapping $R: \\mathbb{R}^2 \\to \\mathbb{R}^2$ such that a solution $(u^\\star, \\lambda^\\star)$ satisfies $R(u^\\star, \\lambda^\\star) = 0$:\n$$R(u, \\lambda) = \\begin{pmatrix} R_1(u, \\lambda) \\\\ R_2(u, \\lambda) \\end{pmatrix} = \\begin{pmatrix} k\\,u + \\lambda - f \\\\ \\sqrt{(c-u)^2 + \\lambda^2} - c + u - \\lambda \\end{pmatrix}$$\nThe function $R(u, \\lambda)$ is continuous everywhere but not differentiable at points where $(c-u, \\lambda) = (0,0)$ due to the square root term. However, the function is semismooth, which allows the use of a generalized Newton method that converges locally superlinearly.\n\n### Step 2: Derivation of the Generalized Jacobian\n\nA semismooth Newton method for solving $R(x)=0$ follows the iteration $x_{k+1} = x_k - V_k^{-1} R(x_k)$, where $x=(u, \\lambda)$ and $V_k$ is an element of the generalized Jacobian (e.g., the Clarke subdifferential $\\partial_C R(x_k)$) of $R$ at $x_k$.\n\nThe Jacobian matrix $J_R$ consists of the partial derivatives of the components of $R$:\n$$J_R(u, \\lambda) = \\begin{pmatrix} \\frac{\\partial R_1}{\\partial u}  \\frac{\\partial R_1}{\\partial \\lambda} \\\\ \\frac{\\partial R_2}{\\partial u}  \\frac{\\partial R_2}{\\partial \\lambda} \\end{pmatrix}$$\n\nThe derivatives of the first component, $R_1(u, \\lambda) = k\\,u + \\lambda - f$, are straightforward:\n$$\\frac{\\partial R_1}{\\partial u} = k, \\quad \\frac{\\partial R_1}{\\partial \\lambda} = 1$$\n\nFor the second component, $R_2(u, \\lambda) = \\phi(c-u, \\lambda)$, we use the chain rule. For any point where $(c-u, \\lambda) \\ne (0,0)$, the partial derivatives of $\\phi(a,b)$ are:\n$$\\frac{\\partial \\phi}{\\partial a} = \\frac{a}{\\sqrt{a^2+b^2}} - 1, \\quad \\frac{\\partial \\phi}{\\partial b} = \\frac{b}{\\sqrt{a^2+b^2}} - 1$$\nApplying the chain rule with $a=c-u$ and $b=\\lambda$:\n$$\\frac{\\partial R_2}{\\partial u} = \\frac{\\partial \\phi}{\\partial a}\\frac{\\partial a}{\\partial u} = -\\frac{\\partial \\phi}{\\partial a} = 1 - \\frac{c-u}{\\sqrt{(c-u)^2+\\lambda^2}}$$\n$$\\frac{\\partial R_2}{\\partial \\lambda} = \\frac{\\partial \\phi}{\\partial b}\\frac{\\partial b}{\\partial \\lambda} = \\frac{\\partial \\phi}{\\partial b} = \\frac{\\lambda}{\\sqrt{(c-u)^2+\\lambda^2}} - 1$$\nLetting $N = \\sqrt{(c-u)^2+\\lambda^2}$, the Jacobian for the non-singular case ($N > 0$) is:\n$$J_R(u, \\lambda) = \\begin{pmatrix} k  1 \\\\ 1 - \\frac{c-u}{N}  \\frac{\\lambda}{N} - 1 \\end{pmatrix} \\quad (\\text{for } (c-u, \\lambda) \\ne (0,0))$$\n\nAt the singular point $(c-u, \\lambda) = (0,0)$, the function is not differentiable. We must select an element from the generalized Jacobian. The Clarke subdifferential $\\partial_C \\phi(a,b)$ at $(0,0)$ for the feasible region ($a \\ge 0, b \\ge 0$) is the convex hull of the set of limit points of the gradient, which is $\\{(\\cos\\theta-1, \\sin\\theta-1) | \\theta \\in [0, \\pi/2]\\}$. Any element from this convex set constitutes a valid choice for a semismooth Newton method. We choose a principled element from the Bouligand (or B-) subdifferential, which corresponds to the limit of the Jacobian along a path to the singularity. Taking the limit along the \"active contact\" path ($(u_k, \\lambda_k) \\to (c, 0)$ with $u_k=c$ and $\\lambda_k \\to 0^+$) gives:\n$$\\lim_{\\lambda \\to 0^+} \\nabla_x R_2(c, \\lambda) = \\lim_{\\lambda \\to 0^+} \\left(1, \\frac{\\lambda}{|\\lambda|}-1 \\right) = (1, 0)$$\nThis leads to the following choice for the generalized Jacobian at the singular point $(u,\\lambda)=(c,0)$:\n$$V(c, 0) = \\begin{pmatrix} k  1 \\\\ 1  0 \\end{pmatrix}$$\nThis matrix is invertible for $k>0$, ensuring the Newton step is well-defined.\n\n### Step 3: Algorithmic Design: Damped Semismooth Newton Method\n\nThe solver implements a damped semismooth Newton-Raphson algorithm to find the root of $R(u,\\lambda)=0$. Let $x_k = (u_k, \\lambda_k)^T$ be the vector of unknowns at iteration $k$.\n\nThe algorithm proceeds as follows for $k=0, 1, 2, \\ldots$:\n1.  **Initialization**: Start with an initial guess $x_0 = (u_0, \\lambda_0) = (0,0)$.\n2.  **Termination Check**: Compute the residual $R_k = R(x_k)$. If its Euclidean norm $\\lVert R_k \\rVert_2$ is less than a tolerance $\\epsilon = 10^{-10}$, or if the maximum number of iterations ($50$) is reached, the algorithm terminates.\n3.  **Newton Step Calculation**:\n    a.  Assemble the generalized Jacobian matrix $V_k = V(x_k)$ using the expressions derived above. A small numerical tolerance is used to distinguish the singular case from the regular one.\n    b.  Solve the linear system $V_k \\Delta x_k = -R_k$ for the search direction $\\Delta x_k = (\\Delta u_k, \\Delta \\lambda_k)^T$.\n4.  **Line Search**: To promote global convergence, a backtracking line search is used to find an appropriate step size $\\alpha_k \\in (0, 1]$.\n    a.  Start with a full step, $\\alpha = 1$.\n    b.  Calculate the trial point $x_{trial} = x_k + \\alpha \\Delta x_k$.\n    c.  Evaluate the norm of the residual at the trial point, $\\lVert R(x_{trial}) \\rVert_2$.\n    d.  If $\\lVert R(x_{trial}) \\rVert_2  \\lVert R_k \\rVert_2$, the step is accepted ($\\alpha_k = \\alpha$).\n    e.  Otherwise, the step size is reduced ($\\alpha \\leftarrow \\alpha/2$) and the check is repeated. This continues until a sufficient decrease is observed or the step size falls below a minimum threshold $\\alpha_{min} = 2^{-20}$.\n5.  **Update**: The solution is updated: $x_{k+1} = x_k + \\alpha_k \\Delta x_k$.\nThe final output consists of the converged solution $(u^\\star, \\lambda^\\star)$ and the final residual norm $\\lVert R(u^\\star, \\lambda^\\star) \\rVert_2$.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the series of contact problems and print the results.\n    \"\"\"\n    # Test cases defined in the problem statement\n    test_cases = [\n        (1000.0, 0.15, 100.0),  # Case 1: No contact expected\n        (1000.0, 0.05, 400.0),  # Case 2: Active contact expected\n        (1000.0, 0.0, 0.0),     # Case 3: Degenerate at the origin\n        (800.0, 0.2, 160.0),   # Case 4: Boundary case f = k*c\n    ]\n\n    results = []\n    for k, c, f in test_cases:\n        u_star, lambda_star, final_residual_norm = run_solver(k, c, f)\n        results.extend([u_star, lambda_star, final_residual_norm])\n\n    # Format the final output string\n    formatted_results = [f\"{val:.10f}\" for val in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n\ndef run_solver(k, c, f, u0=0.0, lam0=0.0, max_iter=50, tol=1e-10, min_alpha=2**-20):\n    \"\"\"\n    Implements a damped semismooth Newton solver for the unilateral contact problem.\n\n    Args:\n        k (float): Stiffness coefficient.\n        c (float): Initial clearance.\n        f (float): Applied external load.\n        u0 (float): Initial guess for displacement.\n        lam0 (float): Initial guess for contact pressure.\n        max_iter (int): Maximum number of iterations.\n        tol (float): Convergence tolerance for the residual norm.\n        min_alpha (float): Minimum step size for the line search.\n\n    Returns:\n        tuple: A tuple containing the final displacement (u), contact pressure (lam),\n               and the Euclidean norm of the final residual.\n    \"\"\"\n    u, lam = u0, lam0\n    \n    # Small tolerance for checking singularity in Jacobian\n    jac_tol = 1e-12\n\n    for _ in range(max_iter):\n        # 1. Compute Residual R(u, lam)\n        gap = c - u\n        \n        # Fischer-Burmeister part of the residual\n        norm_val = np.sqrt(gap**2 + lam**2)\n        r1 = k * u + lam - f\n        r2 = norm_val - gap - lam\n        \n        R_vec = np.array([r1, r2])\n        res_norm = np.linalg.norm(R_vec)\n\n        # 2. Check for convergence\n        if res_norm  tol:\n            break\n\n        # 3. Compute Generalized Jacobian J(u, lam)\n        J = np.zeros((2, 2))\n        J[0, 0] = k\n        J[0, 1] = 1.0\n\n        if norm_val  jac_tol:\n            # Regular case (not at the non-differentiable point)\n            J[1, 0] = 1.0 - gap / norm_val\n            J[1, 1] = lam / norm_val - 1.0\n        else:\n            # Singular case: (c-u, lam) = (0,0). Use an element from the B-subdifferential.\n            # This choice corresponds to the limit from the active contact side.\n            J[1, 0] = 1.0\n            J[1, 1] = 0.0\n\n        # 4. Solve the linear system J * delta_x = -R for the Newton step\n        try:\n            delta_x = np.linalg.solve(J, -R_vec)\n        except np.linalg.LinAlgError:\n            # Jacobian is singular, can't proceed with this step\n            break\n\n        # 5. Backtracking Line Search\n        alpha = 1.0\n        while alpha  min_alpha:\n            u_new = u + alpha * delta_x[0]\n            lam_new = lam + alpha * delta_x[1]\n            \n            # Evaluate residual at the new trial point\n            gap_new = c - u_new\n            norm_val_new = np.sqrt(gap_new**2 + lam_new**2)\n            r1_new = k * u_new + lam_new - f\n            r2_new = norm_val_new - gap_new - lam_new\n            \n            res_norm_new = np.linalg.norm([r1_new, r2_new])\n            \n            # Check for sufficient decrease\n            if res_norm_new  res_norm:\n                break\n            \n            # Reduce step size\n            alpha /= 2.0\n        \n        if alpha = min_alpha and res_norm_new = res_norm:\n             # Line search failed to find a better point, stop iterating\n             break\n\n        # 6. Update solution\n        u = u + alpha * delta_x[0]\n        lam = lam + alpha * delta_x[1]\n\n    # Evaluate final residual at the returned point\n    final_gap = c - u\n    final_norm_val = np.sqrt(final_gap**2 + lam**2)\n    final_r1 = k * u + lam - f\n    final_r2 = final_norm_val - final_gap - lam\n    final_res_norm = np.linalg.norm([final_r1, final_r2])\n\n    return u, lam, final_res_norm\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "This final practice extends the Signorini-Fichera framework to a more realistic and complex scenario typical in geomechanics: an anisotropic, frictional rock joint. You will move beyond simple normal contact to calibrate a sophisticated constitutive model from simulated experimental data, accounting for direction-dependent friction and shear-induced dilatancy. This problem bridges theory and application, demonstrating how the fundamental contact conditions serve as a building block for data-driven modeling of complex geological interfaces. ",
            "id": "3558632",
            "problem": "Consider a planar rock joint subjected to unilateral contact and frictional sliding. The normal contact follows the Signorini-Fichera conditions: the normal gap $g_n$ and the normal contact pressure $p_n$ satisfy $g_n \\ge 0$, $p_n \\ge 0$, and $g_n \\, p_n = 0$. The tangential (shear) behavior is anisotropic due to joint roughness. Assume that, at a given normal compression $\\sigma_n$ (expressed in $\\mathrm{MPa}$), the admissible tangential traction vector $\\boldsymbol{t}_t = \\tau \\, \\boldsymbol{s}$, where $\\tau \\ge 0$ is the shear magnitude and $\\boldsymbol{s} = [\\cos \\varphi, \\sin \\varphi]^\\top$ is the unit slip direction in the laboratory frame with angle $\\varphi$ (in degrees), is constrained by a convex elliptical friction inequality in the material frame. In principal roughness directions, the friction coefficients are $\\mu_1$ and $\\mu_2$ (dimensionless), and the material frame is rotated by an angle $\\theta_0$ (in degrees) relative to the laboratory frame. The admissible set is the interior of the ellipse\n$$\\left(\\frac{t_1}{\\mu_1 \\, \\sigma_n}\\right)^2 + \\left(\\frac{t_2}{\\mu_2 \\, \\sigma_n}\\right)^2 \\le 1,$$\nwhere $[t_1, t_2]^\\top$ are the components of $\\boldsymbol{t}_t$ in the material frame. The Signorini-Fichera friction complementarity is enforced by the Kuhn-Tucker conditions for the anisotropic yield function $F(\\boldsymbol{t}_t, \\sigma_n) \\le 0$, a Lagrange multiplier for sliding $\\lambda_s \\ge 0$, and $\\lambda_s \\, F = 0$.\n\nFrom the above fundamental base, derive the shear strength envelope along a given laboratory shear direction $\\varphi$ under known $\\sigma_n$ and show that the maximum admissible shear magnitude $\\tau_{\\max}(\\varphi, \\sigma_n)$ can be expressed in terms of $\\mu_1$, $\\mu_2$, and $\\theta_0$ by transforming the direction $\\boldsymbol{s}$ to the material frame and evaluating the ellipse. Then, calibrate the anisotropic friction parameters $(\\mu_1, \\mu_2, \\theta_0)$ by minimizing the sum of squared residuals between measured peak shears and the derived $\\tau_{\\max}$ over a provided set of direct-shear tests. After calibration, validate the contact model in two ways: classify given trial states as stick or sliding by checking admissibility and complementarity with respect to the calibrated ellipse, and predict shear dilatancy angles using a nonassociated flow rule where the dilation depends on normal stress and anisotropy.\n\nAll angles in the input data below are given in degrees. All stresses are given in $\\mathrm{MPa}$. Your program must adhere to the following tasks and test suite. Any angle that you compute must be expressed in degrees in the final output, rounded as specified.\n\nTask A. Parameter calibration from direct-shear data:\n- Start from the complementarity-based contact model and the elliptical anisotropic friction law described above. Derive the expression of $\\tau_{\\max}(\\varphi, \\sigma_n)$ based on the geometry of the ellipse in the material frame and the rotation by $\\theta_0$.\n- Using nonlinear least squares, calibrate $(\\mu_1, \\mu_2, \\theta_0)$ from the following measured peak shears under constant normal stress. Use the convention that the unit slip direction is $\\boldsymbol{s} = [\\cos \\varphi, \\sin \\varphi]^\\top$ in the laboratory frame, and the material frame is obtained by rotating by $\\theta_0$.\n\nCalibration dataset A (each tuple is $(\\varphi, \\sigma_n, \\tau_{\\text{meas}})$):\n- $(0, 2, 2.000000)$, $(0, 5, 5.000000)$, $(0, 10, 10.000000)$\n- $(45, 2, 1.264911)$, $(45, 5, 3.162278)$, $(45, 10, 6.324555)$\n- $(90, 2, 1.000000)$, $(90, 5, 2.500000)$, $(90, 10, 5.000000)$\n\nReport the calibrated $\\mu_1$ and $\\mu_2$ (dimensionless) rounded to three decimals, and $\\theta_0$ in degrees rounded to two decimals.\n\nTask B. Stick-versus-sliding classification via Signorini-Fichera inequality:\n- For each of the following trial states, use the calibrated parameters from dataset A to determine whether the state is sliding (boolean true) or sticking (boolean false). Use the Signorini-Fichera admissibility condition with the anisotropic ellipse; declare “sliding” if the trial shear magnitude $\\tau_{\\text{trial}}$ violates the admissible set or lies exactly on its boundary, and “sticking” if it is strictly inside the admissible set.\n\nClassification test states (each tuple is $(\\varphi, \\sigma_n, \\tau_{\\text{trial}})$):\n- $(45, 5, 3.500000)$\n- $(90, 5, 2.200000)$\n- $(0, 2, 2.000000)$\n\nOutput three booleans in this order.\n\nTask C. Dilation prediction under varying normal stress:\n- Assume a nonassociated flow in which the plastic normal slip increment $d\\delta_n$ and plastic tangential slip increment $d\\delta_t$ satisfy $d\\delta_n/d\\delta_t = \\tan \\psi$, where the dilation angle $\\psi$ depends on anisotropy and normal stress as\n$$ \\tan \\psi(\\varphi, \\sigma_n) = \\gamma \\, \\mu_{\\mathrm{eff}}(\\varphi) \\, \\frac{\\sigma_{\\mathrm{ref}}}{\\sigma_{\\mathrm{ref}} + \\sigma_n}, $$\nwith $\\gamma$ a dimensionless constant, $\\sigma_{\\mathrm{ref}} > 0$ in $\\mathrm{MPa}$, and $\\mu_{\\mathrm{eff}}(\\varphi)$ the directional effective friction that you derive from the ellipse and the rotation. Use $\\gamma = 1.2$ and $\\sigma_{\\mathrm{ref}} = 5.0$.\n- Using the calibrated parameters from dataset A, compute $\\psi$ (in degrees) for the following cases and round each to two decimals:\n    - $(\\varphi, \\sigma_n) = (0, 2)$\n    - $(\\varphi, \\sigma_n) = (45, 5)$\n    - $(\\varphi, \\sigma_n) = (90, 10)$\n\nTask D. Near-isotropy edge case:\n- Calibrate $(\\mu_1, \\mu_2, \\theta_0)$ from the following dataset B, which is nearly isotropic, using the same least-squares procedure. Report the anisotropy ratio defined as $\\mu_{\\max}/\\mu_{\\min}$ rounded to three decimals.\n\nCalibration dataset B (each tuple is $(\\varphi, \\sigma_n, \\tau_{\\text{meas}})$):\n- $(0, 3, 2.400000)$, $(0, 6, 4.800000)$\n- $(45, 3, 2.371137)$, $(45, 6, 4.742274)$\n- $(90, 3, 2.340000)$, $(90, 6, 4.680000)$\n\nTask E. Normal complementarity checks:\n- For each pair $(g_n, p_n)$ below, verify the Signorini-Fichera normal contact conditions $g_n \\ge 0$, $p_n \\ge 0$, and $g_n \\, p_n = 0$ within a numerically reasonable tolerance; output a boolean that is true if and only if the triplet of conditions holds. Use the tolerance that a product is considered zero if its absolute value is less than $10^{-9}$.\n\nNormal test pairs $(g_n, p_n)$ (units: $g_n$ in $\\mathrm{m}$, $p_n$ in $\\mathrm{MPa}$):\n- $(0, 5)$\n- $(0.001, 0)$\n- $(0.001, 2)$\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must be, in order:\n    - $\\mu_1$ (dataset A, rounded to three decimals),\n    - $\\mu_2$ (dataset A, rounded to three decimals),\n    - $\\theta_0$ in degrees (dataset A, rounded to two decimals),\n    - three booleans for Task B in the order given,\n    - three dilation angles in degrees for Task C, each rounded to two decimals,\n    - the anisotropy ratio $\\mu_{\\max}/\\mu_{\\min}$ for dataset B (rounded to three decimals),\n    - three booleans for Task E in the order given.\n- Angles must be in degrees. Stresses must be handled in $\\mathrm{MPa}$ internally as provided. The final output must be printed as a single line, for example: $[\\mu_1,\\mu_2,\\theta_0,\\text{bool}_1,\\text{bool}_2,\\text{bool}_3,\\psi_1,\\psi_2,\\psi_3,\\text{ratio},\\text{bool}_4,\\text{bool}_5,\\text{bool}_6]$.",
            "solution": "The problem requires an analysis of anisotropic frictional contact on a planar rock joint, governed by the Signorini-Fichera conditions for normal contact and an elliptical yield criterion for tangential slip. The analysis involves several tasks: deriving the expression for shear strength, calibrating model parameters from experimental data, classifying contact states, and predicting ancillary phenomena like dilatancy.\n\nThe theoretical bedrock for this problem lies in continuum mechanics, specifically in the areas of contact mechanics and plasticity theory. The normal contact is described by the complementarity conditions $g_n \\ge 0$, $p_n \\ge 0$, and $g_n p_n = 0$, where $g_n$ is the normal gap and $p_n$ is the normal contact pressure. These are the classical Signorini-Fichera conditions for a non-penetrating, non-adhesive interface. The tangential behavior is modeled using an anisotropic friction law, a concept from plasticity where the yield surface (in stress space) is not isotropic.\n\nThe core of the analytical work is deriving the shear strength, $\\tau_{\\max}$, along a given direction in the laboratory frame. This requires a coordinate transformation. The laboratory frame is the reference frame for the experiment, where the slip direction is defined by the angle $\\varphi$. The material frame is aligned with the principal directions of the joint's surface roughness, rotated by an angle $\\theta_0$ relative to the lab frame.\n\nA traction vector $\\boldsymbol{v}$ with components $[v_x, v_y]^\\top$ in the laboratory frame has components $[v_1, v_2]^\\top$ in the material frame given by the rotation:\n$$\n\\begin{pmatrix} v_1 \\\\ v_2 \\end{pmatrix} = \\mathbf{R}(-\\theta_0) \\begin{pmatrix} v_x \\\\ v_y \\end{pmatrix} = \\begin{pmatrix} \\cos\\theta_0  \\sin\\theta_0 \\\\ -\\sin\\theta_0  \\cos\\theta_0 \\end{pmatrix} \\begin{pmatrix} v_x \\\\ v_y \\end{pmatrix}\n$$\nThe shear traction vector in the laboratory frame is $\\boldsymbol{t}_t = [\\tau \\cos\\varphi, \\tau \\sin\\varphi]^\\top$. Applying the transformation, its components in the material frame are:\n$$\nt_1 = \\tau (\\cos\\varphi \\cos\\theta_0 + \\sin\\varphi \\sin\\theta_0) = \\tau \\cos(\\varphi - \\theta_0)\n$$\n$$\nt_2 = \\tau (-\\cos\\varphi \\sin\\theta_0 + \\sin\\varphi \\cos\\theta_0) = \\tau \\sin(\\varphi - \\theta_0)\n$$\nThe admissible set for tangential traction is defined by the elliptical inequality in the material frame:\n$$\nF(\\boldsymbol{t}_t, \\sigma_n) = \\left(\\frac{t_1}{\\mu_1 \\sigma_n}\\right)^2 + \\left(\\frac{t_2}{\\mu_2 \\sigma_n}\\right)^2 - 1 \\le 0\n$$\nwhere $\\mu_1$ and $\\mu_2$ are the principal friction coefficients and $\\sigma_n$ is the applied normal stress. Sliding occurs when the yield function $F = 0$. By substituting the expressions for $t_1$ and $t_2$ and setting $\\tau = \\tau_{\\max}$, we obtain the condition for the shear strength:\n$$\n\\left(\\frac{\\tau_{\\max} \\cos(\\varphi - \\theta_0)}{\\mu_1 \\sigma_n}\\right)^2 + \\left(\\frac{\\tau_{\\max} \\sin(\\varphi - \\theta_0)}{\\mu_2 \\sigma_n}\\right)^2 = 1\n$$\nSolving for $\\tau_{\\max}$ yields the expression for the shear strength envelope:\n$$\n\\tau_{\\max}(\\varphi, \\sigma_n) = \\sigma_n \\left[ \\frac{\\cos^2(\\varphi - \\theta_0)}{\\mu_1^2} + \\frac{\\sin^2(\\varphi - \\theta_0)}{\\mu_2^2} \\right]^{-1/2}\n$$\nThe directional effective friction coefficient is then $\\mu_{\\text{eff}}(\\varphi) = \\tau_{\\max}(\\varphi, \\sigma_n) / \\sigma_n$.\n\nWith this foundation, the tasks are executed as follows:\n\n**Task A: Parameter Calibration.** The parameters $(\\mu_1, \\mu_2, \\theta_0)$ are calibrated by minimizing the sum of squared residuals (SSR) between the measured shear strengths, $\\tau_{\\text{meas}}$, and the model's predictions, $\\tau_{\\max}$.\n$$\n\\text{SSR}(\\mu_1, \\mu_2, \\theta_0) = \\sum_{i} \\left( \\tau_{\\text{meas}, i} - \\tau_{\\max}(\\varphi_i, \\sigma_{n,i}; \\mu_1, \\mu_2, \\theta_0) \\right)^2\n$$\nThis is a nonlinear least-squares problem, which will be solved numerically for the provided dataset A.\n\n**Task B: Stick-versus-Sliding Classification.** Using the calibrated parameters from Task A, the shear strength $\\tau_{\\max}$ is computed for each trial state. A state is classified as \"sliding\" if the trial shear stress $\\tau_{\\text{trial}}$ is greater than or equal to the strength, $\\tau_{\\text{trial}} \\ge \\tau_{\\max}$, and \"sticking\" if it is strictly less, $\\tau_{\\text{trial}}  \\tau_{\\max}$.\n\n**Task C: Dilation Prediction.** The dilation angle $\\psi$ is computed using the given nonassociated flow rule. First, the effective friction $\\mu_{\\text{eff}}(\\varphi)$ is calculated with the calibrated parameters. Then, the formula is applied:\n$$\n\\tan \\psi(\\varphi, \\sigma_n) = \\gamma \\, \\mu_{\\mathrm{eff}}(\\varphi) \\, \\frac{\\sigma_{\\mathrm{ref}}}{\\sigma_{\\mathrm{ref}} + \\sigma_n}\n$$\nThe angle $\\psi$ is obtained by taking the arctangent of this value.\n\n**Task D: Near-Isotropy Edge Case.** The calibration procedure from Task A is repeated for dataset B. The anisotropy ratio is then computed from the resulting calibrated principal friction coefficients, $\\mu_{1,B}$ and $\\mu_{2,B}$, as $\\mu_{\\max}/\\mu_{\\min} = \\max(\\mu_{1,B}, \\mu_{2,B}) / \\min(\\mu_{1,B}, \\mu_{2,B})$.\n\n**Task E: Normal Complementarity Checks.** Each pair of normal gap $g_n$ and normal pressure $p_n$ is evaluated against the three Signorini-Fichera conditions: $g_n \\ge 0$, $p_n \\ge 0$, and the complementarity product $|g_n \\cdot p_n|  10^{-9}$. A boolean true indicates all three conditions are satisfied.",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Solves a multi-part problem in computational geomechanics involving\n    anisotropic friction, contact mechanics, and parameter calibration.\n    \"\"\"\n\n    # --- Model Functions ---\n\n    def get_tau_max(params, phi_deg, sigma_n):\n        \"\"\"Calculates the maximum admissible shear stress (shear strength).\"\"\"\n        mu1, mu2, theta0_deg = params\n        phi_rad = np.deg2rad(phi_deg)\n        theta0_rad = np.deg2rad(theta0_deg)\n\n        term1 = (np.cos(phi_rad - theta0_rad) / mu1)**2\n        term2 = (np.sin(phi_rad - theta0_rad) / mu2)**2\n        if term1 + term2 == 0:\n            return 0.0\n        \n        mu_eff = 1.0 / np.sqrt(term1 + term2)\n        return sigma_n * mu_eff\n\n    def ssr_objective(params, data):\n        \"\"\"Sum of Squared Residuals objective function for optimization.\"\"\"\n        mu1, mu2, theta0_deg = params\n        if mu1 = 0 or mu2 = 0:\n            return np.inf  # Enforce positive friction coefficients\n        \n        residuals = []\n        for phi_deg, sigma_n, tau_meas in data:\n            tau_pred = get_tau_max(params, phi_deg, sigma_n)\n            residuals.append((tau_pred - tau_meas)**2)\n        return np.sum(residuals)\n\n    # --- Task A: Parameter calibration from direct-shear data ---\n\n    calibration_data_A = [\n        (0, 2, 2.000000), (0, 5, 5.000000), (0, 10, 10.000000),\n        (45, 2, 1.264911), (45, 5, 3.162278), (45, 10, 6.324555),\n        (90, 2, 1.000000), (90, 5, 2.500000), (90, 10, 5.000000)\n    ]\n    \n    initial_guess_A = [1.0, 0.5, 0.0]\n    bounds_A = [(1e-6, None), (1e-6, None), (-90, 90)]\n    \n    result_A = minimize(\n        ssr_objective,\n        initial_guess_A,\n        args=(calibration_data_A,),\n        method='L-BFGS-B',\n        bounds=bounds_A\n    )\n    \n    mu1_A, mu2_A, theta0_A = result_A.x\n    calibrated_params_A = [mu1_A, mu2_A, theta0_A]\n\n    # --- Task B: Stick-versus-sliding classification ---\n\n    classification_states = [\n        (45, 5, 3.500000),\n        (90, 5, 2.200000),\n        (0, 2, 2.000000)\n    ]\n    \n    classif_results = []\n    for phi_deg, sigma_n, tau_trial in classification_states:\n        tau_lim = get_tau_max(calibrated_params_A, phi_deg, sigma_n)\n        is_sliding = tau_trial = tau_lim\n        classif_results.append(is_sliding)\n\n    # --- Task C: Dilation prediction ---\n    \n    def get_dilation_angle(params, phi_deg, sigma_n, gamma, sigma_ref):\n        \"\"\"Computes the dilation angle psi in degrees.\"\"\"\n        mu1, mu2, theta0_deg = params\n        tau_lim = get_tau_max(params, phi_deg, sigma_n)\n        if sigma_n == 0:\n            mu_eff = 0\n        else:\n            mu_eff = tau_lim / sigma_n\n        \n        tan_psi = gamma * mu_eff * (sigma_ref / (sigma_ref + sigma_n))\n        psi_rad = np.arctan(tan_psi)\n        return np.rad2deg(psi_rad)\n\n    dilation_cases = [\n        (0, 2),\n        (45, 5),\n        (90, 10)\n    ]\n    gamma = 1.2\n    sigma_ref = 5.0\n    \n    dilation_results = []\n    for phi_deg, sigma_n in dilation_cases:\n        psi = get_dilation_angle(calibrated_params_A, phi_deg, sigma_n, gamma, sigma_ref)\n        dilation_results.append(psi)\n\n    # --- Task D: Near-isotropy edge case ---\n\n    calibration_data_B = [\n        (0, 3, 2.400000), (0, 6, 4.800000),\n        (45, 3, 2.371137), (45, 6, 4.742274),\n        (90, 3, 2.340000), (90, 6, 4.680000)\n    ]\n    \n    initial_guess_B = [0.8, 0.78, 0.0]\n    bounds_B = [(1e-6, None), (1e-6, None), (-90, 90)]\n\n    result_B = minimize(\n        ssr_objective,\n        initial_guess_B,\n        args=(calibration_data_B,),\n        method='L-BFGS-B',\n        bounds=bounds_B\n    )\n    \n    mu1_B, mu2_B, _ = result_B.x\n    anisotropy_ratio = max(mu1_B, mu2_B) / min(mu1_B, mu2_B)\n\n    # --- Task E: Normal complementarity checks ---\n\n    normal_test_pairs = [\n        (0, 5),\n        (0.001, 0),\n        (0.001, 2)\n    ]\n    \n    complementarity_results = []\n    tolerance = 1e-9\n    for g_n, p_n in normal_test_pairs:\n        cond1 = g_n = 0\n        cond2 = p_n = 0\n        cond3 = abs(g_n * p_n)  tolerance\n        holds = cond1 and cond2 and cond3\n        complementarity_results.append(holds)\n\n    # --- Final Output Formatting ---\n    \n    output_list = [\n        f\"{mu1_A:.3f}\",\n        f\"{mu2_A:.3f}\",\n        f\"{theta0_A:.2f}\",\n        str(classif_results[0]),\n        str(classif_results[1]),\n        str(classif_results[2]),\n        f\"{dilation_results[0]:.2f}\",\n        f\"{dilation_results[1]:.2f}\",\n        f\"{dilation_results[2]:.2f}\",\n        f\"{anisotropy_ratio:.3f}\",\n        str(complementarity_results[0]),\n        str(complementarity_results[1]),\n        str(complementarity_results[2])\n    ]\n    \n    print(f\"[{','.join(output_list)}]\")\n\nsolve()\n```"
        }
    ]
}