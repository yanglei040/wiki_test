{
    "hands_on_practices": [
        {
            "introduction": "Understanding the augmented Lagrangian method begins with contrasting it against the simpler penalty method. This foundational exercise uses a one-dimensional model to demonstrate how the iterative multiplier update in the augmented Lagrangian scheme systematically eliminates penetration error, a weakness inherent in the pure penalty approach. By implementing both methods, you will gain direct insight into the mechanism that allows the augmented Lagrangian method to enforce contact constraints with high fidelity without requiring numerically prohibitive penalty parameters .",
            "id": "3501911",
            "problem": "Consider a one-dimensional frictionless unilateral contact model in computational geomechanics. A single node with scalar displacement $u$ is constrained by a rigid obstacle located at the origin such that the non-penetration condition requires $u \\le 0$. The node is connected to a linear elastic spring of stiffness $k$ and is subjected to a compressive external load $P$ acting in the positive direction (toward the obstacle). The equilibrium must satisfy the force balance and the contact complementarity conditions derived from the fundamental principles: linear elasticity for the spring force, contact reaction enforcing the constraint, and the Karush–Kuhn–Tucker (KKT) conditions for unilateral contact.\n\nStarting from the base:\n- Linear spring behavior: internal force is $k u$.\n- External load: the generalized force is $P$ (positive values push the node toward the obstacle).\n- Unilateral constraint: the feasible set is defined by $u \\le 0$.\n- Contact reaction force $N \\ge 0$ opposes penetration and obeys the complementarity condition $N u = 0$.\n\nUse the augmented Lagrangian method to solve the constrained static problem. The inequality constraint is written as $c(u) \\le 0$ with $c(u) = u$. Introduce a Lagrange multiplier $\\lambda \\ge 0$ associated with the constraint and augment with a quadratic penalty on the positive part of the constraint violation. The augmented functional is the sum of the elastic energy, the external work, the Lagrange term, and a quadratic term on the positive part of the constraint, which must be handled in a piecewise manner due to non-smoothness at the constraint boundary. The augmented Lagrangian algorithm alternates between:\n- A primal step that enforces stationarity with respect to $u$ for a fixed multiplier $\\lambda$ on the piecewise-smooth augmented functional.\n- A projected multiplier update appropriate for an inequality constraint $c(u) \\le 0$.\n\nYour task is to:\n1. Implement the augmented Lagrangian iteration for this one-degree-of-freedom contact problem. At each iteration, solve exactly the scalar primal stationarity condition for $u$ under the piecewise definition induced by the positive part of $c(u)$, and then update the multiplier with the appropriate projection for $c(u) \\le 0$. Use a stopping criterion that detects satisfaction of the contact conditions by checking both small penetration magnitude and force balance consistency.\n2. Implement the pure penalty method for the same problem by minimizing the energy composed of the elastic energy, the external work, and the quadratic penalty on the positive part of the constraint violation, without any multiplier term or update.\n3. For both methods, report the penetration magnitude defined as $\\max(u,0)$, in meters, rounded to six decimal places.\n4. Use the following test suite of physically plausible parameters (all constants are strictly positive except where explicitly stated). Stiffness $k$ is in Newton per meter ($\\mathrm{N/m}$), load $P$ is in Newton ($\\mathrm{N}$), penalty parameter $\\rho$ is in Newton per meter ($\\mathrm{N/m}$), and the initial multiplier $\\lambda_0$ is in Newton ($\\mathrm{N}$). For each test case, also specify the maximum number of iterations $n_{\\max}$ and the tolerance $t$ for the augmented Lagrangian method:\n   - Test case $1$: $k = 5 \\times 10^{6}\\ \\mathrm{N/m}$, $P = 1 \\times 10^{4}\\ \\mathrm{N}$, $\\rho = 5 \\times 10^{6}\\ \\mathrm{N/m}$, $\\lambda_0 = 0\\ \\mathrm{N}$, $n_{\\max} = 20$, $t = 1 \\times 10^{-12}$.\n   - Test case $2$: $k = 5 \\times 10^{6}\\ \\mathrm{N/m}$, $P = 1 \\times 10^{4}\\ \\mathrm{N}$, $\\rho = 2 \\times 10^{4}\\ \\mathrm{N/m}$, $\\lambda_0 = 0\\ \\mathrm{N}$, $n_{\\max} = 300$, $t = 1 \\times 10^{-12}$.\n   - Test case $3$: $k = 2 \\times 10^{6}\\ \\mathrm{N/m}$, $P = 8 \\times 10^{3}\\ \\mathrm{N}$, $\\rho = 2 \\times 10^{5}\\ \\mathrm{N/m}$, $\\lambda_0 = 1.2 \\times 10^{4}\\ \\mathrm{N}$, $n_{\\max} = 100$, $t = 1 \\times 10^{-12}$.\n   - Test case $4$: $k = 1 \\times 10^{6}\\ \\mathrm{N/m}$, $P = 0\\ \\mathrm{N}$, $\\rho = 1 \\times 10^{5}\\ \\mathrm{N/m}$, $\\lambda_0 = 0\\ \\mathrm{N}$, $n_{\\max} = 10$, $t = 1 \\times 10^{-12}$.\n\nFor each test case, your program must compute:\n- The penetration magnitude using the augmented Lagrangian method, in meters, rounded to six decimal places.\n- The penetration magnitude using the pure penalty method, in meters, rounded to six decimal places.\n- The number of iterations actually performed by the augmented Lagrangian method (an integer).\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered as $[\\text{aug\\_pen}_{1}, \\text{pen\\_only}_{1}, \\text{iters}_{1}, \\text{aug\\_pen}_{2}, \\text{pen\\_only}_{2}, \\text{iters}_{2}, \\text{aug\\_pen}_{3}, \\text{pen\\_only}_{3}, \\text{iters}_{3}, \\text{aug\\_pen}_{4}, \\text{pen\\_only}_{4}, \\text{iters}_{4}]$, where each $\\text{aug\\_pen}_{i}$ and $\\text{pen\\_only}_{i}$ is a float in meters rounded to six decimals, and each $\\text{iters}_{i}$ is an integer.",
            "solution": "The essential ingredients are the fundamental contact conditions and a consistent augmented Lagrangian formulation. In one dimension, linear elasticity yields the internal force $k u$. A compressive external load $P$ in the positive direction acts to push the node toward the obstacle. The rigid obstacle enforces non-penetration $u \\le 0$, with a contact reaction force $N \\ge 0$ satisfying the complementarity condition $N u = 0$ and ensuring the static force balance. This is encoded by the Karush–Kuhn–Tucker (KKT) system:\n$$\nu \\le 0,\\quad \\lambda \\ge 0,\\quad \\lambda u = 0,\\quad k u - P + \\lambda = 0,\n$$\nwhere $\\lambda$ is the Lagrange multiplier representing the contact reaction force.\n\nTo mitigate the ill-conditioning associated with a pure penalty method, the augmented Lagrangian introduces a Lagrange multiplier and a quadratic penalty on the positive part of the inequality constraint. For the inequality $c(u) \\le 0$, with $c(u) = u$, define the augmented functional\n$$\n\\mathcal{L}_\\rho(u,\\lambda) = \\frac{1}{2} k u^2 - P u + \\lambda\\, c(u) + \\frac{\\rho}{2} \\big(c(u)\\big)_+^2,\n$$\nwhere $(x)_+ = \\max(x,0)$ and $\\rho  0$ is the penalty parameter. The primal stationarity condition is obtained by setting the derivative with respect to $u$ to zero, handling the piecewise nature of $(c(u))_+$:\n$$\n\\frac{\\partial \\mathcal{L}_\\rho}{\\partial u} = k u - P + \\lambda + \\rho (u)_+.\n$$\nThis gives a piecewise linear equation:\n- If $u  0$, then $(u)_+ = u$ and\n$$\nk u - P + \\lambda + \\rho u = 0 \\quad \\Rightarrow \\quad (k+\\rho) u = P - \\lambda \\quad \\Rightarrow \\quad u = \\frac{P - \\lambda}{k+\\rho}.\n$$\n- If $u \\le 0$, then $(u)_+ = 0$ and\n$$\nk u - P + \\lambda = 0 \\quad \\Rightarrow \\quad u = \\frac{P - \\lambda}{k}.\n$$\nThe consistency conditions are $u  0$ if and only if $\\lambda  P$, and $u \\le 0$ if and only if $\\lambda \\ge P$. Therefore, the scalar primal update is exactly\n$$\nu^{k+1} =\n\\begin{cases}\n\\dfrac{P - \\lambda^k}{k+\\rho},  \\text{if } \\lambda^k  P, \\\\\n\\dfrac{P - \\lambda^k}{k},  \\text{if } \\lambda^k \\ge P,\n\\end{cases}\n$$\nand the projected multiplier update for the inequality $c(u) \\le 0$ is\n$$\n\\lambda^{k+1} = \\max\\big(0,\\, \\lambda^k + \\rho\\, c(u^{k+1})\\big) = \\max\\big(0,\\, \\lambda^k + \\rho\\, u^{k+1}\\big).\n$$\nThese two steps define the augmented Lagrangian iteration.\n\nConvergence and mitigation of penetration follow from analyzing the multiplier recursion. When $\\lambda^k  P$, one gets\n$$\n\\lambda^{k+1} = \\lambda^k + \\rho \\frac{P - \\lambda^k}{k+\\rho} = \\left(1 - \\frac{\\rho}{k+\\rho}\\right) \\lambda^k + \\frac{\\rho}{k+\\rho} P = \\frac{k}{k+\\rho}\\, \\lambda^k + \\frac{\\rho}{k+\\rho}\\, P.\n$$\nThis is a contraction mapping toward $P$ with contraction factor $\\frac{k}{k+\\rho} \\in (0,1)$. Consequently $u^{k+1} = \\frac{P - \\lambda^k}{k+\\rho}$ decreases geometrically, and the penetration magnitude $\\max(u^{k+1},0)$ vanishes as $\\lambda^k \\to P$. When $\\lambda^k \\ge P$, one has\n$$\n\\lambda^{k+1} = \\lambda^k + \\rho \\frac{P - \\lambda^k}{k} = \\left(1 - \\frac{\\rho}{k}\\right)\\lambda^k + \\frac{\\rho}{k} P,\n$$\nwhich also contracts toward $P$ provided $\\rho \\in (0,k]$. In practice, choosing $\\rho$ comparable to $k$ yields rapid reduction of penetration without requiring excessively large $\\rho$. This demonstrates the core mitigation mechanism: the multiplier update provides the necessary reaction force, while the augmented term regularizes the primal solve.\n\nFor the pure penalty method, the multiplier is omitted and the energy is\n$$\n\\Pi_\\rho(u) = \\frac{1}{2} k u^2 - P u + \\frac{\\rho}{2} (u)_+^2,\n$$\nwith stationarity\n$$\nk u - P + \\rho (u)_+ = 0.\n$$\nFor $P \\ge 0$ the solution is $u = \\frac{P}{k+\\rho}  0$, leading to a penetration magnitude that is strictly positive unless $\\rho \\to \\infty$. Hence, unlike the augmented Lagrangian method, the pure penalty method requires very large $\\rho$ to effectively suppress penetration, which is numerically undesirable.\n\nAlgorithmic design for one-degree-of-freedom:\n- Input $(k,P,\\rho,\\lambda_0,n_{\\max},t)$.\n- Initialize $\\lambda \\leftarrow \\lambda_0$.\n- For $n$ from $1$ to $n_{\\max}$:\n  - If $\\lambda  P$, set $u \\leftarrow \\frac{P - \\lambda}{k+\\rho}$; else set $u \\leftarrow \\frac{P - \\lambda}{k}$.\n  - Update $\\lambda \\leftarrow \\max(0, \\lambda + \\rho u)$.\n  - Define penetration magnitude $p \\leftarrow \\max(u,0)$.\n  - Define residual $r \\leftarrow k u - P + \\lambda$.\n  - Stop if $p \\le t$ and $|r| \\le t$.\n- Return $p$ and the number of iterations performed.\n- For the penalty-only method, solve $u = \\frac{P}{k+\\rho}$ (for $P \\ge 0$), and return $p = \\max(u,0)$.\n\nUnits and outputs:\n- Report penetration magnitudes in meters (rounded to six decimals).\n- Report iteration counts as integers.\n- Apply the above test suite parameters and print the single-line comma-separated list in the specified order.\n\nThis construction rigorously demonstrates that the augmented term plus multiplier update mitigates penetration without requiring excessively large $\\rho$, by converging the multiplier to the contact reaction $P$ and driving the gap to zero, whereas the pure penalty method leaves a residual penetration proportional to $\\frac{P}{k+\\rho}$ when $\\rho$ is moderate.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef augmented_contact_1d(k, P, rho, lambda0, max_iter, tol):\n    \"\"\"\n    Augmented Lagrangian for 1D unilateral contact with constraint u = 0.\n    Returns penetration magnitude max(u, 0) and iterations performed.\n    \"\"\"\n    lam = float(lambda0)\n    u = 0.0\n    iters = 0\n    for it in range(1, max_iter + 1):\n        # Primal update based on piecewise stationarity\n        if lam  P:\n            u = (P - lam) / (k + rho)\n        else:\n            u = (P - lam) / k\n        # Multiplier update with projection for c(u) = 0\n        lam = max(0.0, lam + rho * u)\n        # Penetration magnitude and residual\n        pen = max(u, 0.0)\n        residual = k * u - P + lam\n        iters = it\n        # Stopping: small penetration and near force balance\n        if pen = tol and abs(residual) = tol:\n            break\n    return pen, iters\n\ndef penalty_only_1d(k, P, rho):\n    \"\"\"\n    Pure penalty solution for 1D unilateral contact with constraint u = 0.\n    For P = 0, the minimizer is u = P/(k+rho)  0; report penetration magnitude.\n    \"\"\"\n    if P == 0.0:\n        return 0.0\n    # For compressive load P = 0, closed-form solution\n    u = P / (k + rho)\n    return max(u, 0.0)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (k [N/m], P [N], rho [N/m], lambda0 [N], max_iter, tol)\n    test_cases = [\n        (5e6, 1e4, 5e6, 0.0, 20, 1e-12),       # Test case 1\n        (5e6, 1e4, 2e4, 0.0, 300, 1e-12),      # Test case 2\n        (2e6, 8e3, 2e5, 1.2e4, 100, 1e-12),    # Test case 3\n        (1e6, 0.0, 1e5, 0.0, 10, 1e-12),       # Test case 4\n    ]\n\n    results = []\n    for k, P, rho, lambda0, max_iter, tol in test_cases:\n        aug_pen, iters = augmented_contact_1d(k, P, rho, lambda0, max_iter, tol)\n        pen_only = penalty_only_1d(k, P, rho)\n        # Round penetrations to six decimals as required; iterations are integers\n        results.append(f\"{aug_pen:.6f}\")\n        results.append(f\"{pen_only:.6f}\")\n        results.append(str(iters))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "After establishing the core mechanism of the augmented Lagrangian method, we can now quantitatively assess its accuracy and convergence properties. This practice employs a mesh refinement study, a standard technique in finite element analysis, to compare the convergence of interface tractions computed by both the penalty and augmented Lagrangian methods. You will investigate the concept of superconvergence, where the augmented Lagrangian method can recover the exact contact traction to machine precision, a powerful theoretical advantage over the penalty method for certain classes of problems .",
            "id": "3501910",
            "problem": "Consider a $1$-dimensional, small-strain, linear elastic bar of length $L$ with constant Young’s modulus $E$ and cross-sectional area $A$. The axial displacement field is $u(x)$ with $x \\in [0,L]$. The left end at $x=0$ is subject to a prescribed displacement $u(0)=\\bar u0$. The right end at $x=L$ may come into frictionless unilateral contact with a rigid, immovable obstacle located at zero displacement. The nonpenetration constraint is $u(L) \\le 0$. Let the interface traction multiplier (reaction) at $x=L$ be $\\lambda \\ge 0$. The Signorini conditions at $x=L$ are $u(L) \\le 0$, $\\lambda \\ge 0$, and $\\lambda\\,u(L)=0$. The exact continuum solution (if contact is active) is a uniform compressive state with linear displacement $u(x)=\\bar u\\left(1-\\frac{x}{L}\\right)$, contact gap $u(L)=0$, and exact interface traction magnitude $\\lambda^\\star = \\frac{E A}{L}\\,\\bar u$. All forces must be interpreted in newtons (N), displacements in meters (m), and all inputs and outputs must be consistent with these units.\n\nYou will approximate this problem using a standard linear finite element method with $N$ equally sized elements of length $h=L/N$ and nodal unknowns $u_i$, $i=0,\\dots,N$. The global stiffness matrix is assembled from the elemental stiffness $k_e = \\frac{E A}{h}\\begin{bmatrix}1  -1\\\\ -1  1\\end{bmatrix}$. The Dirichlet condition is $u_0=\\bar u$. The contact constraint is at node $N$.\n\nTwo numerical strategies must be implemented and compared for approximating the traction multiplier $\\lambda$:\n\n- Penalty method. Replace the unilateral constraint at node $N$ by adding a boundary penalty spring of stiffness $k_p \\ge 0$ that penalizes positive displacement $u_N0$. The resulting algebraic system for the unknown free nodal vector (nodes $1$ to $N$) reads\n$$\nK_{ff}\\,u_f = -K_{f0}\\,\\bar u, \\quad \\text{with} \\quad K_{NN} \\leftarrow K_{NN} + k_p,\n$$\nand the penalty traction approximation is\n$$\n\\lambda_p = k_p\\,\\max(u_N,0).\n$$\nUse the canonical stabilization $k_p = \\alpha\\,\\frac{E A}{h}$ when $\\alpha \\ge 0$. Additionally, to test a fixed-penalty edge case, if $\\alpha0$ set $k_p = (-\\alpha)\\,\\frac{E A}{L}$ (constant with respect to $h$).\n\n- Augmented Lagrangian method (ALM) with Uzawa iterations. Introduce the Lagrange multiplier $\\lambda$ at node $N$ and an augmentation parameter $\\rho0$. Given $\\lambda^{(k)}$, solve the linear equilibrium subproblem\n$$\nK_{ff}\\,u_f^{(k)} = -K_{f0}\\,\\bar u - e_N\\,\\lambda^{(k)},\n$$\nwhere $e_N \\in \\mathbb{R}^{N}$ is the unit vector selecting the last free degree of freedom (node $N$). Then update the multiplier by the projected Uzawa step\n$$\n\\lambda^{(k+1)} = \\max\\big(0,\\;\\lambda^{(k)} + \\rho\\,u_N^{(k)}\\big).\n$$\nIterate until convergence. For testing, set $\\rho = \\gamma\\,\\frac{E A}{L}$ with a given scalar $\\gamma0$.\n\nTask. For a prescribed set of test scenarios (specified below), and for each scenario a refinement sequence $N \\in \\{4,8,16,32,64\\}$, implement both methods to compute the approximate interface traction $\\lambda_p$ (penalty) and $\\lambda_{\\text{ALM}}$ (augmented Lagrangian) and compare them to the exact $\\lambda^\\star=\\frac{E A}{L}\\,\\bar u$. For each $N$, compute the relative error\n$$\n\\varepsilon_{\\text{method}}(N) = \\frac{|\\lambda_{\\text{method}}(N) - \\lambda^\\star|}{\\lambda^\\star}.\n$$\nFor the penalty method, estimate the observed convergence rate $p$ with respect to $h$ by linear least-squares fitting of $\\log\\big(\\varepsilon_{\\text{penalty}}(N)\\big)$ against $\\log(h)$ over the entire refinement set. For the augmented Lagrangian method, compute the maximum relative error over the refinement set, $\\max_N \\varepsilon_{\\text{ALM}}(N)$, and also check the boolean predicate “superconvergent” defined here as $\\max_N \\varepsilon_{\\text{ALM}}(N) \\le 10^{-10}$.\n\nScientific basis. Begin from the small-strain linear elastic potential energy, the principle of virtual work, and the Signorini conditions at the contact boundary. The penalty approximation replaces the inequality by a compliant constraint that is exact only as $k_p \\to \\infty$, whereas the augmented Lagrangian restores consistency by enforcing complementarity through a dual update with augmentation $\\rho$.\n\nNumerical units and consistency. All inputs must be interpreted with $E$ in pascals (Pa), $A$ in square meters ($\\mathrm{m}^2$), $L$ in meters (m), and $\\bar u$ in meters (m). The exact and approximate tractions are in newtons (N). Relative errors are dimensionless. Angles do not appear and thus require no unit.\n\nTest suite. Use the following scenarios; for each of them, compute over the refinement set $N \\in \\{4,8,16,32,64\\}$:\n\n- Test $1$ (happy path): $E=30\\times 10^{9}\\,\\mathrm{Pa}$, $A=1\\times 10^{-2}\\,\\mathrm{m}^2$, $L=2\\,\\mathrm{m}$, $\\bar u=5\\times 10^{-3}\\,\\mathrm{m}$, $\\alpha=10$ (so $k_p=\\alpha\\,EA/h$), $\\gamma=1$ (so $\\rho=\\gamma\\,EA/L$).\n\n- Test $2$ (milder penalty and slower dual step): $E=70\\times 10^{9}\\,\\mathrm{Pa}$, $A=5\\times 10^{-3}\\,\\mathrm{m}^2$, $L=3\\,\\mathrm{m}$, $\\bar u=2\\times 10^{-3}\\,\\mathrm{m}$, $\\alpha=1$, $\\gamma=0.5$.\n\n- Test $3$ (edge case with fixed penalty): $E=50\\times 10^{9}\\,\\mathrm{Pa}$, $A=2\\times 10^{-2}\\,\\mathrm{m}^2$, $L=1.5\\,\\mathrm{m}$, $\\bar u=1\\times 10^{-3}\\,\\mathrm{m}$, $\\alpha=-1$ (so $k_p=(-\\alpha)\\,EA/L$ fixed in $h$), $\\gamma=1.5$.\n\nAlgorithmic details to be respected:\n\n- Assemble the global stiffness $K \\in \\mathbb{R}^{(N+1)\\times(N+1)}$ from linear elements of size $h=L/N$ with $k_e=\\frac{EA}{h}\\begin{bmatrix}1  -1\\\\ -1  1\\end{bmatrix}$.\n\n- Impose $u_0=\\bar u$ strongly by eliminating the first row and column. The reduced right-hand side must include the contribution from the prescribed displacement.\n\n- Penalty method: if $\\alpha \\ge 0$, set $k_p=\\alpha\\,EA/h$; if $\\alpha0$, set $k_p=(-\\alpha)\\,EA/L$. Add $k_p$ to the reduced matrix entry corresponding to node $N$ (last free degree of freedom). Then compute $\\lambda_p = k_p\\,\\max(u_N,0)$.\n\n- Augmented Lagrangian method: initialize $\\lambda^{(0)}=0$, set $\\rho=\\gamma\\,EA/L$, and iterate\n    - Solve $K_{ff}\\,u_f^{(k)} = -K_{f0}\\,\\bar u - e_N\\,\\lambda^{(k)}$,\n    - Update $\\lambda^{(k+1)}=\\max\\big(0,\\lambda^{(k)} + \\rho\\,u_N^{(k)}\\big)$,\n  until $|u_N^{(k)}| \\le 10^{-12}$ or a maximum of $1000$ iterations.\n\n- Exact traction: $\\lambda^\\star=\\frac{EA}{L}\\,\\bar u$.\n\nFinal output format. Your program should produce a single line of output containing a list with one entry per test scenario, where each entry is itself a list of three items: the fitted penalty convergence rate $p$ (float), the maximum augmented Lagrangian relative error over refinements (float), and a boolean indicating whether the augmented Lagrangian is superconvergent (as defined above). Concretely, the output must look like\n$$\n[\\,[p_1,\\,\\text{maxErrALM}_1,\\,\\text{isSuper}_1],\\,[p_2,\\,\\text{maxErrALM}_2,\\,\\text{isSuper}_2],\\,[p_3,\\,\\text{maxErrALM}_3,\\,\\text{isSuper}_3]\\,],\n$$\nprinted as a single line using standard Python list formatting.",
            "solution": "The user has provided a problem statement in computational mechanics, specifically focusing on the finite element analysis of a 1D elastic bar with unilateral contact. The task is to implement and compare two common algorithms for enforcing contact constraints: the penalty method and the augmented Lagrangian method (ALM).\n\n### Step 1: Extract Givens\n\n- **Physical System**: 1D linear elastic bar.\n- **Parameters**: Length $L$, Young’s modulus $E$, cross-sectional area $A$.\n- **Displacement Field**: $u(x)$ for $x \\in [0,L]$.\n- **Boundary Conditions**:\n    - Prescribed displacement at $x=0$: $u(0) = \\bar u  0$.\n    - Unilateral frictionless contact at $x=L$:\n        - Non-penetration: $u(L) \\le 0$.\n        - Reaction force (traction multiplier): $\\lambda \\ge 0$.\n        - Complementarity: $\\lambda\\,u(L)=0$.\n- **Exact Solution**:\n    - Displacement: $u(x)=\\bar u\\left(1-\\frac{x}{L}\\right)$.\n    - Reaction force: $\\lambda^\\star = \\frac{E A}{L}\\,\\bar u$.\n- **Finite Element Discretization**:\n    - $N$ equally sized linear elements of length $h=L/N$.\n    - Nodal unknowns $u_i$ for $i=0,\\dots,N$.\n    - Elemental stiffness matrix: $k_e = \\frac{E A}{h}\\begin{bmatrix}1  -1\\\\ -1  1\\end{bmatrix}$.\n    - Strong enforcement of Dirichlet condition: $u_0=\\bar u$.\n- **Penalty Method**:\n    - System to solve: $K_{ff}\\,u_f = -K_{f0}\\,\\bar u$, with $K_{NN} \\leftarrow K_{NN} + k_p$.\n    - Penalty parameter $k_p$:\n        - If $\\alpha \\ge 0$: $k_p = \\alpha\\,\\frac{E A}{h}$.\n        - If $\\alpha  0$: $k_p = (-\\alpha)\\,\\frac{E A}{L}$.\n    - Traction approximation: $\\lambda_p = k_p\\,\\max(u_N,0)$.\n- **Augmented Lagrangian Method (ALM)**:\n    - Iterative scheme with augmentation parameter $\\rho = \\gamma\\,\\frac{E A}{L}$.\n    - Initialization: $\\lambda^{(0)}=0$.\n    - Subproblem: Solve for $u_f^{(k)}$ from $K_{ff}\\,u_f^{(k)} = -K_{f0}\\,\\bar u - e_N\\,\\lambda^{(k)}$.\n    - Update: $\\lambda^{(k+1)} = \\max\\big(0,\\;\\lambda^{(k)} + \\rho\\,u_N^{(k)}\\big)$.\n    - Convergence: Iterate until $|u_N^{(k)}| \\le 10^{-12}$ or max 1000 iterations.\n- **Task**:\n    - For given test scenarios and refinement levels $N \\in \\{4,8,16,32,64\\}$:\n        1. Compute approximate tractions $\\lambda_p$ and $\\lambda_{\\text{ALM}}$.\n        2. Compute relative error $\\varepsilon_{\\text{method}}(N) = \\frac{|\\lambda_{\\text{method}}(N) - \\lambda^\\star|}{\\lambda^\\star}$.\n        3. For the penalty method, estimate convergence rate $p$ from a linear least-squares fit of $\\log(\\varepsilon_p)$ vs. $\\log(h)$.\n        4. For ALM, find maximum relative error $\\max_N \\varepsilon_{\\text{ALM}}(N)$ and check if it is \"superconvergent\" ($\\le 10^{-10}$).\n- **Test Scenarios**:\n    1. $E=30\\times 10^{9}\\,\\mathrm{Pa}$, $A=10^{-2}\\,\\mathrm{m}^2$, $L=2\\,\\mathrm{m}$, $\\bar u=5\\times 10^{-3}\\,\\mathrm{m}$, $\\alpha=10$, $\\gamma=1$.\n    2. $E=70\\times 10^{9}\\,\\mathrm{Pa}$, $A=5\\times 10^{-3}\\,\\mathrm{m}^2$, $L=3\\,\\mathrm{m}$, $\\bar u=2\\times 10^{-3}\\,\\mathrm{m}$, $\\alpha=1$, $\\gamma=0.5$.\n    3. $E=50\\times 10^{9}\\,\\mathrm{Pa}$, $A=2\\times 10^{-2}\\,\\mathrm{m}^2$, $L=1.5\\,\\mathrm{m}$, $\\bar u=1\\times 10^{-3}\\,\\mathrm{m}$, $\\alpha=-1$, $\\gamma=1.5$.\n- **Output Format**: A list of lists: $[\\,[p_1,\\,\\text{maxErrALM}_1,\\,\\text{isSuper}_1], \\dots]$.\n\n### Step 2: Validate Using Extracted Givens\n\n- **Scientifically Grounded**: The problem is based on fundamental principles of linear elasticity, the finite element method, and standard computational contact mechanics (Signorini conditions, penalty method, augmented Lagrangian method). All concepts are well-established in the field of computational geomechanics and solid mechanics.\n- **Well-Posed**: The problem is well-posed. The physical setup of a compressed bar hitting a rigid wall has a unique solution. The numerical methods are standard, and the parameters for the iterative ALM method ($\\gamma \\in \\{1, 0.5, 1.5\\}$) are chosen within the theoretical convergence domain ($\\gamma  2$). The tasks are clearly defined algorithms to be executed for a specified output.\n- **Objective**: The problem is stated in precise, objective mathematical and engineering language. There are no subjective or opinion-based elements.\n- **Completeness and Consistency**: All necessary data, parameters, and algorithmic details are provided. The units are consistent. The description of the FE assembly and the resulting linear systems is unambiguous. The problem is self-contained.\n- **Realism**: The physical parameters are realistic for materials like rock or concrete. The problem itself serves as a canonical benchmark for contact algorithms.\n\n### Step 3: Verdict and Action\nThe problem is valid. It is a well-defined, scientifically sound computational task based on established principles. I will now proceed to construct the solution.\n\n### Principle-Based Design and Solution\n\nThe solution will be developed by first discretizing the continuum problem using the Finite Element Method (FEM), and then implementing the two specified numerical strategies for handling the contact constraint.\n\n#### 1. Finite Element Discretization\nThe continuous displacement field $u(x)$ is approximated by a piecewise linear function over $N$ elements. The nodal displacements are collected in a vector $\\mathbf{u} \\in \\mathbb{R}^{N+1}$. The principle of virtual work leads to the global system of linear equations $K\\mathbf{u} = \\mathbf{f}$, where $K$ is the global stiffness matrix and $\\mathbf{f}$ contains nodal forces.\n\nThe global stiffness matrix $K$ is assembled by summing the contributions from each element's stiffness matrix $k_e = \\frac{EA}{h}\\begin{pmatrix}1  -1 \\\\ -1  1\\end{pmatrix}$. This results in a symmetric, tridiagonal matrix.\n\nThe prescribed displacement $u_0 = \\bar u$ is enforced by partitioning the system. The full system is written as:\n$$\n\\begin{pmatrix} K_{00}  K_{0f} \\\\ K_{f0}  K_{ff} \\end{pmatrix}\n\\begin{pmatrix} u_0 \\\\ \\mathbf{u}_f \\end{pmatrix}\n=\n\\begin{pmatrix} f_0 \\\\ \\mathbf{f}_f \\end{pmatrix}\n$$\nwhere $\\mathbf{u}_f = [u_1, u_2, \\dots, u_N]^T$ is the vector of unknown free nodal displacements. The equation for the free unknowns is $K_{ff}\\mathbf{u}_f = \\mathbf{f}_f - K_{f0}u_0$. Since $u_0=\\bar u$ and the external mechanical forces on the free nodes are represented by the contact reaction $\\lambda$ at node $N$, this becomes:\n$$\nK_{ff}\\mathbf{u}_f = -K_{f0}\\bar u - \\lambda \\mathbf{e}_N\n$$\nwhere $\\mathbf{e}_N$ is the standard basis vector of size $N$ with a $1$ in the last position. The contact force appears with a negative sign because it is a reaction force, acting in the direction opposite to the positive displacement.\n\n#### 2. Penalty Method\nThe penalty method replaces the hard contact constraint with a stiff spring. The reaction force is approximated as $\\lambda \\approx k_p u_N$ for $u_N  0$. Substituting this into the equilibrium equation gives:\n$$\nK_{ff}\\mathbf{u}_f \\approx -K_{f0}\\bar u - k_p u_N \\mathbf{e}_N\n$$\nRearranging the terms yields the system to be solved:\n$$\n(K_{ff} + k_p \\mathbf{e}_N \\mathbf{e}_N^T) \\mathbf{u}_f = -K_{f0}\\bar u\n$$\nThis is equivalent to adding the penalty stiffness $k_p$ to the last diagonal entry of $K_{ff}$. After solving for $\\mathbf{u}_f$, the penalized displacement $u_N$ is found. The approximate reaction force is then recovered as $\\lambda_p = k_p \\max(u_N, 0)$. This method is approximate and converges to the exact solution only as $k_p \\to \\infty$. The analysis of the relative error $\\varepsilon_p = \\frac{1}{1 + k_p C_N}$, where $C_N = L/(EA)$ is the exact compliance of the bar, predicts a convergence rate of $p=1$ when $k_p \\propto 1/h$ and $p=0$ when $k_p$ is constant.\n\n#### 3. Augmented Lagrangian Method (ALM)\nThe ALM is an iterative method that combines the Lagrange multiplier approach with a penalty-like term (the augmentation). It seeks a saddle point of the augmented Lagrangian functional. The problem provides the Uzawa algorithm, a common iterative scheme for this purpose.\n\nFor a given estimate of the Lagrange multiplier $\\lambda^{(k)}$, a standard linear elastic problem is solved for the displacements $\\mathbf{u}_f^{(k)}$:\n$$\nK_{ff}\\mathbf{u}_f^{(k)} = -K_{f0}\\bar u - \\lambda^{(k)}\\mathbf{e}_N\n$$\nThe resulting contact gap/penetration, $u_N^{(k)}$, measures the violation of the constraint for the current $\\lambda^{(k)}$. This violation is used to update the multiplier in a manner analogous to an integral controller:\n$$\n\\lambda^{(k+1)} = \\text{proj}_{\\ge 0} \\left( \\lambda^{(k)} + \\rho u_N^{(k)} \\right) = \\max(0, \\lambda^{(k)} + \\rho u_N^{(k)})\n$$\nThe projection $\\max(0, \\cdot)$ enforces the constraint $\\lambda \\ge 0$. The augmentation parameter $\\rho$ controls the convergence speed. For this problem, the iteration converges to the exact discrete solution $\\lambda^\\star$ provided the step size is appropriate (specifically for $\\rho  2/C_N = 2EA/L$, which corresponds to $\\gamma  2$). Since linear finite elements exactly represent the linear displacement field of the exact solution, the converged $\\lambda_{\\text{ALM}}$ should match $\\lambda^\\star$ to within machine precision and the iteration tolerance, independent of the mesh size $N$. This is the \"superconvergent\" behavior tested.\n\n#### 4. Implementation and Analysis\nThe implementation follows the logic above. For each test case, a loop over the refinement levels $N$ is performed. In each step, both methods are executed to find $\\lambda_p$ and $\\lambda_{\\text{ALM}}$. The relative errors $\\varepsilon_p$ and $\\varepsilon_{\\text{ALM}}$ are stored. After the loop, the collected data is analyzed:\n- For the penalty method, `numpy.polyfit` is used on the log-log data ($\\log(\\varepsilon_p)$ vs. $\\log(h)$) to determine the convergence rate $p$.\n- For the ALM, the maximum of the stored errors is computed and compared against the $10^{-10}$ threshold to determine the `isSuperconvergent` flag.\n\nThe final results for each test case are compiled into the required list of lists format for the final output.",
            "answer": "```python\nimport numpy as np\n\ndef assemble_and_partition(N, L, E, A):\n    \"\"\"\n    Assembles the global stiffness matrix K for a 1D bar with N elements,\n    and partitions it into K_ff and K_f0 for the free DOFs.\n    \"\"\"\n    h = L / N\n    # The total number of nodes is N+1, so K is (N+1)x(N+1)\n    K = np.zeros((N + 1, N + 1))\n    # Elemental stiffness matrix\n    ke = (E * A / h) * np.array([[1, -1], [-1, 1]])\n\n    # Assemble global K from elemental contributions\n    for i in range(N):\n        K[i:i+2, i:i+2] += ke\n    \n    # Partition K. Node 0 is prescribed. Nodes 1 to N are free.\n    # K_ff corresponds to free DOFs (nodes 1 to N)\n    K_ff = K[1:, 1:]\n    # K_f0 is the coupling between free and prescribed DOFs\n    K_f0 = K[1:, 0]\n    \n    return K_ff, K_f0\n\ndef solve_penalty(N, L, E, A, u_bar, alpha, K_ff, K_f0):\n    \"\"\"\n    Solves the contact problem using the penalty method.\n    \"\"\"\n    h = L / N\n    \n    # Define penalty parameter k_p based on alpha\n    if alpha = 0:\n        k_p = alpha * E * A / h\n    else:  # Edge case for fixed penalty\n        k_p = (-alpha) * E * A / L\n        \n    K_prime_ff = K_ff.copy()\n    # Add penalty stiffness to the diagonal entry for the contact node (node N)\n    K_prime_ff[-1, -1] += k_p\n    \n    # RHS vector from prescribed displacement\n    # K_f0 is a 1D array, so we reshape for matrix multiplication later if needed,\n    # but here direct multiplication with scalar u_bar works element-wise.\n    b = -K_f0 * u_bar\n    \n    # Solve for free displacements\n    u_f = np.linalg.solve(K_prime_ff, b)\n    u_N = u_f[-1]\n    \n    # Calculate approximate traction\n    lambda_p = k_p * max(u_N, 0)\n    return lambda_p\n\ndef solve_alm(N, L, E, A, u_bar, gamma, K_ff, K_f0):\n    \"\"\"\n    Solves the contact problem using the Augmented Lagrangian Method (ALM)\n    with Uzawa iterations.\n    \"\"\"\n    rho = gamma * E * A / L\n    lambda_alm = 0.0\n    \n    # RHS contribution from prescribed displacement\n    b_const = -K_f0 * u_bar\n    # Unit vector to select the last DOF (node N)\n    e_N = np.zeros(N)\n    e_N[-1] = 1.0\n    \n    # Max iterations and tolerance\n    max_iter = 1000\n    tol = 1e-12\n\n    for _ in range(max_iter):\n        # Full RHS for the current iteration\n        b_alm = b_const - e_N * lambda_alm\n        # Solve for displacements\n        u_f = np.linalg.solve(K_ff, b_alm)\n        u_N = u_f[-1]\n        \n        # Check for convergence on primal feasibility (gap closure)\n        if abs(u_N) = tol:\n            break\n            \n        # Update Lagrange multiplier (projected Uzawa step)\n        lambda_alm = max(0, lambda_alm + rho * u_N)\n\n    return lambda_alm\n\ndef solve():\n    \"\"\"\n    Main function to run all test scenarios and produce the final output.\n    \"\"\"\n    test_cases = [\n        # E (Pa), A (m^2), L (m), u_bar (m), alpha, gamma\n        (30e9, 1e-2, 2.0, 5e-3, 10.0, 1.0),\n        (70e9, 5e-3, 3.0, 2e-3, 1.0, 0.5),\n        (50e9, 2e-2, 1.5, 1e-3, -1.0, 1.5),\n    ]\n    refinement_N = [4, 8, 16, 32, 64]\n\n    all_results = []\n\n    for E, A, L, u_bar, alpha, gamma in test_cases:\n        # Exact traction magnitude\n        lambda_star = E * A * u_bar / L\n        \n        penalty_errors = []\n        alm_errors = []\n        h_values = []\n\n        for N in refinement_N:\n            h = L / N\n            h_values.append(h)\n            \n            K_ff, K_f0 = assemble_and_partition(N, L, E, A)\n\n            # --- Penalty Method ---\n            lambda_p = solve_penalty(N, L, E, A, u_bar, alpha, K_ff, K_f0)\n            # Avoid division by zero if lambda_star is zero\n            err_p = abs(lambda_p - lambda_star) / lambda_star if lambda_star != 0 else abs(lambda_p)\n            penalty_errors.append(err_p)\n            \n            # --- Augmented Lagrangian Method ---\n            lambda_alm = solve_alm(N, L, E, A, u_bar, gamma, K_ff, K_f0)\n            err_alm = abs(lambda_alm - lambda_star) / lambda_star if lambda_star != 0 else abs(lambda_alm)\n            alm_errors.append(err_alm)\n\n        # --- Post-processing for the current test case ---\n        \n        # 1. Penalty convergence rate\n        # Using np.polyfit for linear least-squares on log-log data\n        # log(err) = p * log(h) + c\n        log_h = np.log(np.array(h_values))\n        log_err_p = np.log(np.array(penalty_errors))\n        # polyfit returns [slope, intercept] for degree 1\n        p, _ = np.polyfit(log_h, log_err_p, 1)\n\n        # 2. ALM max error and superconvergence check\n        max_err_alm = np.max(alm_errors)\n        is_super = max_err_alm = 1e-10\n\n        all_results.append([p, max_err_alm, is_super])\n\n    # Print the final result in the exact specified format\n    print(all_results)\n\nsolve()\n```"
        },
        {
            "introduction": "Moving from simple normal contact to more realistic scenarios requires handling friction. The classical Coulomb friction law is non-smooth, which presents a challenge for the Newton-based solvers often used within an augmented Lagrangian framework. This exercise tackles this practical issue by exploring common techniques for smoothing the friction cone, such as $p$-norm or Huber-type surrogates, and quantifying the trade-off between the smoothness of the approximation and the accuracy of the stick-slip prediction .",
            "id": "3501885",
            "problem": "Consider a single local contact point in computational geomechanics with a two-dimensional ($2$D) tangential traction vector $\\mathbf{t}^{\\mathrm{tr}} = (t_1, t_2)$ measured in Pascal (Pa), a positive normal compression $p_n$ in Pascal (Pa), and a dimensionless friction coefficient $\\mu$. The classical Coulomb friction cone is defined as the set $\\mathcal{C} = \\{ \\mathbf{t} \\in \\mathbb{R}^2 \\, | \\, \\| \\mathbf{t} \\|_2 \\le \\mu p_n \\}$, where $\\| \\cdot \\|_2$ denotes the Euclidean norm. The stick outcome is characterized by $\\| \\mathbf{t}^{\\mathrm{tr}} \\|_2 \\le \\mu p_n$, while slip occurs when $\\| \\mathbf{t}^{\\mathrm{tr}} \\|_2  \\mu p_n$. In an augmented Lagrangian setting, projection of $\\mathbf{t}^{\\mathrm{tr}}$ onto $\\mathcal{C}$ is a key substep guiding the update of Lagrange multipliers and penalized constraints.\n\nTo investigate smooth approximations of the friction cone used inside augmented Lagrangian contact updates, define two families of smooth surrogate norms $\\phi_{\\epsilon}(\\mathbf{t})$ parameterized by a smoothness parameter $\\epsilon  0$:\n\n- A $p$-norm surrogate with $\\epsilon$ controlling the exponent $p$:\n$$\n\\phi_{\\epsilon}^{\\mathrm{pnorm}}(\\mathbf{t}) = \\left( |t_1|^{p} + |t_2|^{p} \\right)^{1/p}, \\quad \\text{where } p = 2 + \\epsilon.\n$$\n\n- A Huber-type surrogate for the Euclidean norm with threshold $\\epsilon$:\n$$\n\\phi_{\\epsilon}^{\\mathrm{Huber}}(\\mathbf{t}) =\n\\begin{cases}\n\\dfrac{r^2}{2\\epsilon},  \\text{if } r \\le \\epsilon, \\\\\nr - \\dfrac{\\epsilon}{2},  \\text{if } r  \\epsilon,\n\\end{cases}\n\\quad \\text{where } r = \\sqrt{t_1^2 + t_2^2}.\n$$\n\nUsing a surrogate $\\phi_{\\epsilon}$, define a smoothing-based stick–slip classifier by the condition $\\phi_{\\epsilon}(\\mathbf{t}^{\\mathrm{tr}}) \\le \\mu p_n$ for stick and $\\phi_{\\epsilon}(\\mathbf{t}^{\\mathrm{tr}})  \\mu p_n$ for slip. Define the corresponding smoothing-based projection of the traction magnitude used within an augmented Lagrangian update as follows: if $\\phi_{\\epsilon}(\\mathbf{t}^{\\mathrm{tr}}) \\le \\mu p_n$, set the projected magnitude equal to the trial magnitude, $\\| \\mathbf{t}^{\\mathrm{sm}} \\|_2 = \\| \\mathbf{t}^{\\mathrm{tr}} \\|_2$; otherwise, shrink the magnitude along the current direction to meet the smoothed boundary, $\\| \\mathbf{t}^{\\mathrm{sm}} \\|_2 = \\| \\mathbf{t}^{\\mathrm{tr}} \\|_2 \\cdot \\dfrac{\\mu p_n}{\\phi_{\\epsilon}(\\mathbf{t}^{\\mathrm{tr}})}$. For an exact Coulomb cone projection, the projected magnitude is $\\| \\mathbf{t}^{\\mathrm{ex}} \\|_2 = \\min\\left( \\| \\mathbf{t}^{\\mathrm{tr}} \\|_2, \\mu p_n \\right)$.\n\nYour tasks are:\n\n$1.$ Starting from the Coulomb friction definition and the idea of constraint enforcement through augmented Lagrangian methods, formulate the stick–slip decision rule and projection scheme in purely mathematical terms for both the exact cone and the smoothed surrogates defined above.\n\n$2.$ Implement a program that, for each test case below, computes:\n- The exact stick–slip classification by comparing $\\| \\mathbf{t}^{\\mathrm{tr}} \\|_2$ to $\\mu p_n$,\n- The smoothing-based stick–slip classification by comparing $\\phi_{\\epsilon}(\\mathbf{t}^{\\mathrm{tr}})$ to $\\mu p_n$,\n- The normalized traction magnitude error\n$$\nE = \\dfrac{\\left| \\| \\mathbf{t}^{\\mathrm{sm}} \\|_2 - \\| \\mathbf{t}^{\\mathrm{ex}} \\|_2 \\right|}{\\mu p_n},\n$$\nwhich is dimensionless,\n- The misclassification indicator\n$$\nI =\n\\begin{cases}\n1,  \\text{if exact and smoothing-based stick–slip classifications differ}, \\\\\n0,  \\text{otherwise}.\n\\end{cases}\n$$\n\n$3.$ Quantify the trade-off between the smoothness parameter $\\epsilon$ and the accuracy of stick–slip transitions by reporting $E$ and $I$ for each case. All stresses and tractions must be handled in Pascal (Pa). The outputs $E$ and $I$ are dimensionless.\n\nUse the following test suite. For all cases, take $\\mu = 0.6$ and $p_n = 1.0 \\times 10^{6}$ Pa. Each case specifies the surrogate type, the smoothing parameter $\\epsilon$, and the components of $\\mathbf{t}^{\\mathrm{tr}}$ in Pascal (Pa):\n\n$1.$ $\\left( \\text{pnorm}, \\epsilon = 0.0, t_1 = 0.30 \\times 10^{6}, t_2 = 0.20 \\times 10^{6} \\right)$\n\n$2.$ $\\left( \\text{pnorm}, \\epsilon = 1.0, t_1 = 0.45 \\times 10^{6}, t_2 = 0.45 \\times 10^{6} \\right)$\n\n$3.$ $\\left( \\text{pnorm}, \\epsilon = 0.5, t_1 = 0.80 \\times 10^{6}, t_2 = 0.40 \\times 10^{6} \\right)$\n\n$4.$ $\\left( \\text{pnorm}, \\epsilon = 1.0, t_1 = 0.60 \\times 10^{6}, t_2 = 0.00 \\times 10^{6} \\right)$\n\n$5.$ $\\left( \\text{Huber}, \\epsilon = 1.0 \\times 10^{5}, t_1 = 0.59 \\times 10^{6}, t_2 = 0.05 \\times 10^{6} \\right)$\n\n$6.$ $\\left( \\text{Huber}, \\epsilon = 2.0 \\times 10^{5}, t_1 = 0.45 \\times 10^{6}, t_2 = 0.45 \\times 10^{6} \\right)$\n\n$7.$ $\\left( \\text{Huber}, \\epsilon = 1.0 \\times 10^{3}, t_1 = 0.80 \\times 10^{6}, t_2 = 0.40 \\times 10^{6} \\right)$\n\n$8.$ $\\left( \\text{Huber}, \\epsilon = 1.0 \\times 10^{5}, t_1 = 0.00 \\times 10^{6}, t_2 = 0.00 \\times 10^{6} \\right)$\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered as $[E_1, I_1, E_2, I_2, \\dots, E_8, I_8]$, where $E_k$ is the normalized traction magnitude error for test case $k$ and $I_k$ is the misclassification indicator for test case $k$.",
            "solution": "The fundamental basis is the classical Coulomb friction law and the augmented Lagrangian method for constrained optimization. Coulomb friction at a contact point states that the tangential traction vector $\\mathbf{t} \\in \\mathbb{R}^2$ must lie within the friction cone defined by $\\| \\mathbf{t} \\|_2 \\le \\mu p_n$, where $\\mu  0$ is the friction coefficient and $p_n  0$ is the normal compression. Stick occurs when the unconstrained trial traction $\\mathbf{t}^{\\mathrm{tr}}$ already satisfies the bound, $\\| \\mathbf{t}^{\\mathrm{tr}} \\|_2 \\le \\mu p_n$, while slip occurs when $\\| \\mathbf{t}^{\\mathrm{tr}} \\|_2  \\mu p_n$ and the traction must be projected back onto the boundary of the cone.\n\nThe augmented Lagrangian method enforces constraints by augmenting the Lagrangian with penalty terms and iteratively updating primal and dual variables through substeps that include projection onto feasible sets. Consider a local frictional subproblem where, for a known $\\mathbf{t}^{\\mathrm{tr}}$, one performs a projection onto the feasible friction cone. The exact projection preserves direction and limits the magnitude to the threshold $\\mu p_n$. This leads to the exact projected magnitude\n$$\n\\| \\mathbf{t}^{\\mathrm{ex}} \\|_2 = \\min \\left( \\| \\mathbf{t}^{\\mathrm{tr}} \\|_2, \\mu p_n \\right).\n$$\nThis definition arises from the minimal change in traction in Euclidean norm consistent with the Coulomb constraint, which is the classical radial return mapping in the tangential traction space. The stick–slip decision rule is then\n$$\n\\text{stick if } \\| \\mathbf{t}^{\\mathrm{tr}} \\|_2 \\le \\mu p_n, \\quad \\text{slip otherwise}.\n$$\n\nTo accommodate differentiability and numerical robustness within augmented Lagrangian iterations, smooth surrogates of the friction cone boundary are introduced via $\\phi_{\\epsilon}(\\mathbf{t}) \\approx \\| \\mathbf{t} \\|_2$. Two specific surrogates are considered:\n\n$1.$ The $p$-norm surrogate\n$$\n\\phi_{\\epsilon}^{\\mathrm{pnorm}}(\\mathbf{t}) = \\left( |t_1|^{p} + |t_2|^{p} \\right)^{1/p}, \\quad p = 2 + \\epsilon,\n$$\nwhere the parameter $\\epsilon$ controls the deviation of $p$ from $2$. As $\\epsilon \\to 0$, $p \\to 2$ and $\\phi_{\\epsilon}^{\\mathrm{pnorm}}$ converges to the Euclidean norm. For $\\epsilon  0$, $p  2$ yields a norm that reduces the contribution of smaller components, which tends to underestimate the Euclidean norm for mixed-component vectors while remaining exact on axes.\n\n$2.$ The Huber-type surrogate\n$$\n\\phi_{\\epsilon}^{\\mathrm{Huber}}(\\mathbf{t}) =\n\\begin{cases}\n\\dfrac{r^2}{2\\epsilon},  \\text{if } r \\le \\epsilon, \\\\\nr - \\dfrac{\\epsilon}{2},  \\text{if } r  \\epsilon,\n\\end{cases}\n\\quad r = \\sqrt{t_1^2 + t_2^2},\n$$\nwhich is smooth near $\\mathbf{t} = \\mathbf{0}$ and approaches the Euclidean norm for $r \\gg \\epsilon$. This surrogate underestimates the norm for $r$ small relative to $\\epsilon$, which can expand the apparent stick region in classification.\n\nWith a surrogate in place, the smoothing-based stick–slip decision is formulated as\n$$\n\\text{stick if } \\phi_{\\epsilon}(\\mathbf{t}^{\\mathrm{tr}}) \\le \\mu p_n, \\quad \\text{slip otherwise}.\n$$\nThis rule modifies the boundary via the smooth surrogate region and serves as a proxy within augmented Lagrangian updates that require differentiable measures of constraint violations.\n\nFor the projection step consistent with augmented Lagrangian enforcement, we preserve the trial direction and adjust only the magnitude. If the smoothing-based classifier indicates stick, no change is made:\n$$\n\\| \\mathbf{t}^{\\mathrm{sm}} \\|_2 = \\| \\mathbf{t}^{\\mathrm{tr}} \\|_2.\n$$\nIf it indicates slip, we shrink the magnitude to reach the surrogate boundary level by scaling the trial magnitude according to the ratio of the threshold to the surrogate norm,\n$$\n\\| \\mathbf{t}^{\\mathrm{sm}} \\|_2 = \\| \\mathbf{t}^{\\mathrm{tr}} \\|_2 \\cdot \\frac{\\mu p_n}{\\phi_{\\epsilon}(\\mathbf{t}^{\\mathrm{tr}})}.\n$$\nThis scaling aligns the surrogate measure with the threshold $\\mu p_n$, paralleling the radial return in the exact case but replacing the Euclidean norm with the surrogate. The exact projected magnitude is\n$$\n\\| \\mathbf{t}^{\\mathrm{ex}} \\|_2 = \\min \\left( \\| \\mathbf{t}^{\\mathrm{tr}} \\|_2, \\mu p_n \\right).\n$$\n\nTo quantify the trade-off between smoothing parameter $\\epsilon$ and stick–slip accuracy, we compute for each test case:\n- The normalized traction magnitude error\n$$\nE = \\frac{\\left| \\| \\mathbf{t}^{\\mathrm{sm}} \\|_2 - \\| \\mathbf{t}^{\\mathrm{ex}} \\|_2 \\right|}{\\mu p_n},\n$$\nwhich is dimensionless, and\n- The misclassification indicator\n$$\nI =\n\\begin{cases}\n1,  \\text{if } \\left( \\| \\mathbf{t}^{\\mathrm{tr}} \\|_2 \\le \\mu p_n \\right) \\text{ xor } \\left( \\phi_{\\epsilon}(\\mathbf{t}^{\\mathrm{tr}}) \\le \\mu p_n \\right), \\\\\n0,  \\text{otherwise}.\n\\end{cases}\n$$\n\nAlgorithmically, for each test case:\n$1.$ Compute $r = \\| \\mathbf{t}^{\\mathrm{tr}} \\|_2$.\n$2.$ Compute $\\phi_{\\epsilon}(\\mathbf{t}^{\\mathrm{tr}})$ using the specified surrogate.\n$3.$ Determine exact stick–slip by comparing $r$ to $\\mu p_n$.\n$4.$ Determine surrogate stick–slip by comparing $\\phi_{\\epsilon}$ to $\\mu p_n$.\n$5.$ Compute $\\| \\mathbf{t}^{\\mathrm{ex}} \\|_2 = \\min(r, \\mu p_n)$.\n$6.$ Compute $\\| \\mathbf{t}^{\\mathrm{sm}} \\|_2 = r$ if surrogate stick, else $\\| \\mathbf{t}^{\\mathrm{sm}} \\|_2 = r \\cdot \\dfrac{\\mu p_n}{\\phi_{\\epsilon}}$.\n$7.$ Compute $E$ by normalization with $\\mu p_n$.\n$8.$ Compute $I$ by comparing exact and surrogate classifications.\n\nThe test suite spans:\n- A general case strictly inside the cone (happy path),\n- A symmetric case near and beyond the threshold where $p$-norm smoothing with $p  2$ can underestimate the Euclidean norm and misclassify,\n- A case well outside the cone (clear slip),\n- A boundary case exactly on the cone,\n- Huber smoothing with moderate $\\epsilon$ near the threshold,\n- Huber smoothing with larger $\\epsilon$ that significantly underestimates the norm and can misclassify slip as stick,\n- Huber smoothing with small $\\epsilon$ closely matching the Euclidean norm,\n- A zero-traction edge case.\n\nThe final program aggregates $E$ and $I$ for all test cases into a single list printed as a single line in the requested format, with all values dimensionless. This quantifies both continuous error in projected traction magnitude and discrete misclassification induced by the smoothing parameter $\\epsilon$ for each surrogate.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef norm2(t):\n    \"\"\"Euclidean norm of a 2D vector.\"\"\"\n    return float(np.sqrt(t[0]**2 + t[1]**2))\n\ndef phi_pnorm(t, epsilon):\n    \"\"\"\n    p-norm surrogate with p = 2 + epsilon.\n    For epsilon = 0.0, this equals the Euclidean norm.\n    \"\"\"\n    p = 2.0 + float(epsilon)\n    # Use absolute values to define the p-norm.\n    return float((abs(t[0])**p + abs(t[1])**p) ** (1.0 / p))\n\ndef phi_huber(t, epsilon):\n    \"\"\"\n    Huber-type surrogate of the Euclidean norm with threshold epsilon  0.\n    For r = epsilon: r^2 / (2*epsilon)\n    For r   epsilon: r - epsilon/2\n    \"\"\"\n    r = norm2(t)\n    eps = float(epsilon)\n    if eps = 0.0:\n        # Degenerate case: fallback to Euclidean norm.\n        return r\n    if r = eps:\n        return (r**2) / (2.0 * eps)\n    else:\n        return r - 0.5 * eps\n\ndef classify_exact(t, mu, p_n):\n    \"\"\"Exact stick-slip classification under Coulomb cone.\"\"\"\n    r = norm2(t)\n    return r = mu * p_n\n\ndef classify_smooth(t, mu, p_n, kind, epsilon):\n    \"\"\"Smoothing-based stick-slip classification using surrogate phi_epsilon.\"\"\"\n    if kind == 'pnorm':\n        phi = phi_pnorm(t, epsilon)\n    elif kind == 'huber':\n        phi = phi_huber(t, epsilon)\n    else:\n        raise ValueError(\"Unknown smoothing kind.\")\n    return phi = mu * p_n\n\ndef project_exact_magnitude(t, mu, p_n):\n    \"\"\"Exact projected magnitude onto Coulomb cone.\"\"\"\n    r = norm2(t)\n    return min(r, mu * p_n)\n\ndef project_smooth_magnitude(t, mu, p_n, kind, epsilon):\n    \"\"\"\n    Smoothing-based projection magnitude:\n    - If surrogate classifies stick, keep magnitude r.\n    - If slip, scale magnitude by (mu*p_n)/phi to meet the surrogate boundary.\n    \"\"\"\n    r = norm2(t)\n    if kind == 'pnorm':\n        phi = phi_pnorm(t, epsilon)\n    elif kind == 'huber':\n        phi = phi_huber(t, epsilon)\n    else:\n        raise ValueError(\"Unknown smoothing kind.\")\n    # Stick region: do not change traction\n    if phi = mu * p_n:\n        return r\n    # Slip region: shrink along direction to surrogate boundary\n    # Protect against division by zero in pathological cases\n    denom = phi if phi  0.0 else 1e-16\n    scale = (mu * p_n) / denom\n    return r * scale\n\ndef solve():\n    # Define global parameters: friction coefficient and normal compression (Pa)\n    mu = 0.6\n    p_n = 1.0e6  # Pa\n\n    # Test cases: (kind, epsilon, t1, t2)\n    test_cases = [\n        ('pnorm', 0.0, 0.30e6, 0.20e6),   # 1: inside cone (happy path)\n        ('pnorm', 1.0, 0.45e6, 0.45e6),   # 2: symmetric near threshold, potential misclassification\n        ('pnorm', 0.5, 0.80e6, 0.40e6),   # 3: outside cone (clear slip)\n        ('pnorm', 1.0, 0.60e6, 0.00e6),   # 4: exactly on boundary\n        ('huber', 1.0e5, 0.59e6, 0.05e6), # 5: near threshold, moderate epsilon\n        ('huber', 2.0e5, 0.45e6, 0.45e6), # 6: larger epsilon, potential misclassification\n        ('huber', 1.0e3, 0.80e6, 0.40e6), # 7: small epsilon, close to exact\n        ('huber', 1.0e5, 0.00e6, 0.00e6), # 8: zero traction edge case\n    ]\n\n    results = []\n    for kind, epsilon, t1, t2 in test_cases:\n        t = (t1, t2)\n        # Exact classification and projection\n        stick_exact = classify_exact(t, mu, p_n)\n        mag_exact = project_exact_magnitude(t, mu, p_n)\n        # Smoothing-based classification and projection\n        stick_smooth = classify_smooth(t, mu, p_n, kind, epsilon)\n        mag_smooth = project_smooth_magnitude(t, mu, p_n, kind, epsilon)\n        # Normalized magnitude error\n        E = abs(mag_smooth - mag_exact) / (mu * p_n)\n        # Misclassification indicator\n        I = 1 if (stick_exact != stick_smooth) else 0\n        results.append(E)\n        results.append(I)\n\n    # Format floats with a reasonable precision; integers as-is.\n    formatted = []\n    for val in results:\n        if isinstance(val, float):\n            formatted.append(f\"{val:.8f}\")\n        else:\n            formatted.append(str(int(val)))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted)}]\")\n\nsolve()\n```"
        }
    ]
}