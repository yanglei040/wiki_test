{
    "hands_on_practices": [
        {
            "introduction": "本练习旨在通过一个最简单的单自由度接触模型，直观地揭示增广拉格朗日方法的核心优势。通过与经典的罚函数法进行直接比较，您将亲手实现并验证增广拉格朗日法如何在不引入极端罚参数导致数值病态的情况下，有效控制接触面上的穿透问题。这项基础实践是理解更复杂接触算法的基石。",
            "id": "3501911",
            "problem": "考虑一个计算地质力学中的一维无摩擦单边接触模型。一个具有标量位移 $u$ 的单节点受到位于原点的刚性障碍物的约束，非侵入条件要求 $u \\le 0$。该节点连接到一个刚度为 $k$ 的线性弹性弹簧，并受到一个作用在正方向（朝向障碍物）的压缩外载荷 $P$。平衡状态必须满足力平衡和接触互补条件，这些条件源于基本原理：弹簧力的线性弹性、强制执行约束的接触反力以及单边接触的 Karush–Kuhn–Tucker (KKT) 条件。\n\n从基础出发：\n- 线性弹簧行为：内力为 $k u$。\n- 外载荷：广义力为 $P$（正值将节点推向障碍物）。\n- 单边约束：可行集由 $u \\le 0$ 定义。\n- 接触反力 $N \\ge 0$ 抵抗侵入，并遵循互补条件 $N u = 0$。\n\n使用增广拉格朗日方法求解该约束静态问题。不等式约束写作 $c(u) \\le 0$，其中 $c(u) = u$。引入与该约束相关的拉格朗日乘子 $\\lambda \\ge 0$，并对约束违反正值部分增加一个二次罚项。增广泛函是弹性势能、外力功、拉格朗日项以及约束正值部分的二次项之和，由于在约束边界处的非光滑性，必须分段处理。增广拉格朗日算法交替执行以下步骤：\n- 一个主问题步骤，对于固定的乘子 $\\lambda$，在分段光滑的增广泛函上强制关于 $u$ 的驻定性。\n- 一个适用于不等式约束 $c(u) \\le 0$ 的投影乘子更新步骤。\n\n你的任务是：\n1. 实现此单自由度接触问题的增广拉格朗日迭代。在每次迭代中，根据 $c(u)$ 正值部分引起的分段定义，精确求解关于 $u$ 的标量主问题驻定条件，然后使用适用于 $c(u) \\le 0$ 的适当投影更新乘子。使用一个停止准则，通过检查小的侵入量级和力平衡一致性来检测接触条件是否满足。\n2. 对同一问题实现纯罚函数法，通过最小化由弹性势能、外力功和约束违反正值部分的二次罚项组成的能量，不含任何乘子项或更新。\n3. 对于两种方法，报告以米为单位的侵入量级，定义为 $\\max(u,0)$，四舍五入到六位小数。\n4. 使用以下物理上合理的参数测试套件（所有常数除非明确说明均为严格正值）。刚度 $k$ 的单位是牛顿/米 ($\\mathrm{N/m}$)，载荷 $P$ 的单位是牛顿 ($\\mathrm{N}$)，罚参数 $\\rho$ 的单位是牛顿/米 ($\\mathrm{N/m}$)，初始乘子 $\\lambda_0$ 的单位是牛顿 ($\\mathrm{N}$)。对于每个测试用例，还需指定增广拉格朗日法的最大迭代次数 $n_{\\max}$ 和容差 $t$：\n   - 测试用例 1：$k = 5 \\times 10^{6}\\ \\mathrm{N/m}$，$P = 1 \\times 10^{4}\\ \\mathrm{N}$，$\\rho = 5 \\times 10^{6}\\ \\mathrm{N/m}$，$\\lambda_0 = 0\\ \\mathrm{N}$，$n_{\\max} = 20$，$t = 1 \\times 10^{-12}$。\n   - 测试用例 2：$k = 5 \\times 10^{6}\\ \\mathrm{N/m}$，$P = 1 \\times 10^{4}\\ \\mathrm{N}$，$\\rho = 2 \\times 10^{4}\\ \\mathrm{N/m}$，$\\lambda_0 = 0\\ \\mathrm{N}$，$n_{\\max} = 300$，$t = 1 \\times 10^{-12}$。\n   - 测试用例 3：$k = 2 \\times 10^{6}\\ \\mathrm{N/m}$，$P = 8 \\times 10^{3}\\ \\mathrm{N}$，$\\rho = 2 \\times 10^{5}\\ \\mathrm{N/m}$，$\\lambda_0 = 1.2 \\times 10^{4}\\ \\mathrm{N}$，$n_{\\max} = 100$，$t = 1 \\times 10^{-12}$。\n   - 测试用例 4：$k = 1 \\times 10^{6}\\ \\mathrm{N/m}$，$P = 0\\ \\mathrm{N}$，$\\rho = 1 \\times 10^{5}\\ \\mathrm{N/m}$，$\\lambda_0 = 0\\ \\mathrm{N}$，$n_{\\max} = 10$，$t = 1 \\times 10^{-12}$。\n\n对于每个测试用例，你的程序必须计算：\n- 使用增广拉格朗日方法计算的侵入量级，以米为单位，四舍五入到六位小数。\n- 使用纯罚函数法计算的侵入量级，以米为单位，四舍五入到六位小数。\n- 增广拉格朗日方法实际执行的迭代次数（一个整数）。\n\n最终输出格式：\n- 你的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表，其顺序为 `[`aug_pen_1`, `pen_only_1`, `iters_1`, `aug_pen_2`, `pen_only_2`, `iters_2`, `aug_pen_3`, `pen_only_3`, `iters_3`, `aug_pen_4`, `pen_only_4`, `iters_4`]`, 其中每个 `aug_pen_i` 和 `pen_only_i` 是以米为单位、四舍五入到六位小数的浮点数，每个 `iters_i` 是一个整数。",
            "solution": "基本要素是基本的接触条件和一致的增广拉格朗日公式。在一维情况下，线性弹性产生的内力为 $k u$。一个作用在正方向的压缩外载荷 $P$ 将节点推向障碍物。刚性障碍物强制实现非侵入 $u \\le 0$，接触反力 $N \\ge 0$ 满足互补条件 $N u = 0$ 并确保静态力平衡。这可以由 Karush–Kuhn–Tucker (KKT) 系统编码：\n$$\nu \\le 0,\\quad \\lambda \\ge 0,\\quad \\lambda u = 0,\\quad k u - P + \\lambda = 0,\n$$\n其中 $\\lambda$ 是表示接触反力的拉格朗日乘子。\n\n为了减轻与纯罚函数法相关的病态问题，增广拉格朗日方法引入了一个拉格朗日乘子和对不等式约束正值部分的二次罚项。对于不等式 $c(u) \\le 0$，其中 $c(u) = u$，定义增广泛函\n$$\n\\mathcal{L}_\\rho(u,\\lambda) = \\frac{1}{2} k u^2 - P u + \\lambda\\, c(u) + \\frac{\\rho}{2} \\big(c(u)\\big)_+^2,\n$$\n其中 $(x)_+ = \\max(x,0)$ 且 $\\rho > 0$ 是罚参数。主问题驻定条件通过将关于 $u$ 的导数设为零来获得，同时处理 $(c(u))_+$ 的分段性质：\n$$\n\\frac{\\partial \\mathcal{L}_\\rho}{\\partial u} = k u - P + \\lambda + \\rho (u)_+.\n$$\n这给出了一个分段线性方程：\n- 如果 $u > 0$，则 $(u)_+ = u$ 并且\n$$\nk u - P + \\lambda + \\rho u = 0 \\quad \\Rightarrow \\quad (k+\\rho) u = P - \\lambda \\quad \\Rightarrow \\quad u = \\frac{P - \\lambda}{k+\\rho}.\n$$\n- 如果 $u \\le 0$，则 $(u)_+ = 0$ 并且\n$$\nk u - P + \\lambda = 0 \\quad \\Rightarrow \\quad u = \\frac{P - \\lambda}{k}.\n$$\n一致性条件是 $u > 0$ 当且仅当 $\\lambda < P$，以及 $u \\le 0$ 当且仅当 $\\lambda \\ge P$。因此，标量主问题更新精确地为\n$$\nu^{k+1} =\n\\begin{cases}\n\\dfrac{P - \\lambda^k}{k+\\rho},  &\\text{if } \\lambda^k < P, \\\\\n\\dfrac{P - \\lambda^k}{k},  &\\text{if } \\lambda^k \\ge P,\n\\end{cases}\n$$\n并且对于不等式 $c(u) \\le 0$ 的投影乘子更新为\n$$\n\\lambda^{k+1} = \\max\\big(0,\\, \\lambda^k + \\rho\\, c(u^{k+1})\\big) = \\max\\big(0,\\, \\lambda^k + \\rho\\, u^{k+1}\\big).\n$$\n这两个步骤定义了增广拉格朗日迭代。\n\n收敛性和侵入的减缓可以通过分析乘子递归来得出。当 $\\lambda^k < P$ 时，可得\n$$\n\\lambda^{k+1} = \\lambda^k + \\rho \\frac{P - \\lambda^k}{k+\\rho} = \\left(1 - \\frac{\\rho}{k+\\rho}\\right) \\lambda^k + \\frac{\\rho}{k+\\rho} P = \\frac{k}{k+\\rho}\\, \\lambda^k + \\frac{\\rho}{k+\\rho}\\, P.\n$$\n这是一个向 $P$ 收缩的压缩映射，压缩因子为 $\\frac{k}{k+\\rho} \\in (0,1)$。因此，$u^{k+1} = \\frac{P - \\lambda^k}{k+\\rho}$ 呈几何级数递减，并且随着 $\\lambda^k \\to P$，侵入量级 $\\max(u^{k+1},0)$ 趋于零。当 $\\lambda^k \\ge P$ 时，有\n$$\n\\lambda^{k+1} = \\lambda^k + \\rho \\frac{P - \\lambda^k}{k} = \\left(1 - \\frac{\\rho}{k}\\right)\\lambda^k + \\frac{\\rho}{k} P,\n$$\n只要 $\\rho \\in (0, 2k]$，这个式子也向 $P$ 收缩。在实践中，选择与 $k$ 相当的 $\\rho$ 值可以在不要求过大 $\\rho$ 的情况下快速减少侵入。这展示了核心的缓解机制：乘子更新提供了必要的反作用力，而增广项则对主问题的求解进行正则化。\n\n对于纯罚函数法，乘子被省略，能量为\n$$\n\\Pi_\\rho(u) = \\frac{1}{2} k u^2 - P u + \\frac{\\rho}{2} (u)_+^2,\n$$\n其驻定条件为\n$$\nk u - P + \\rho (u)_+ = 0.\n$$\n对于 $P \\ge 0$，解为 $u = \\frac{P}{k+\\rho} > 0$，这导致一个严格为正的侵入量级，除非 $\\rho \\to \\infty$。因此，与增广拉格朗日方法不同，纯罚函数法需要非常大的 $\\rho$ 才能有效抑制侵入，这在数值上是不可取的。\n\n单自由度算法设计：\n- 输入 $(k,P,\\rho,\\lambda_0,n_{\\max},t)$。\n- 初始化 $\\lambda \\leftarrow \\lambda_0$。\n- 对于从 $1$ 到 $n_{\\max}$ 的 $n$：\n  - 如果 $\\lambda < P$，则设置 $u \\leftarrow \\frac{P - \\lambda}{k+\\rho}$；否则设置 $u \\leftarrow \\frac{P - \\lambda}{k}$。\n  - 更新 $\\lambda \\leftarrow \\max(0, \\lambda + \\rho u)$。\n  - 定义侵入量级 $p \\leftarrow \\max(u,0)$。\n  - 定义残差 $r \\leftarrow k u - P + \\lambda$。\n  - 如果 $p \\le t$ 且 $|r| \\le t$，则停止。\n- 返回 $p$ 和执行的迭代次数。\n- 对于纯罚函数法，求解 $u = \\frac{P}{k+\\rho}$（对于 $P \\ge 0$），并返回 $p = \\max(u,0)$。\n\n单位和输出：\n- 以米为单位报告侵入量级（四舍五入到六位小数）。\n- 以整数形式报告迭代次数。\n- 应用上述测试套件参数，并按指定顺序打印单行逗号分隔列表。\n\n这一构造严谨地证明了，增广项加上乘子更新通过将乘子收敛到接触反力 $P$ 并将间隙驱动至零，从而在不要求过大 $\\rho$ 的情况下减缓了侵入，而纯罚函数法在 $\\rho$ 为中等大小时，会留下一个与 $\\frac{P}{k+\\rho}$ 成正比的残余侵入。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef augmented_contact_1d(k, P, rho, lambda0, max_iter, tol):\n    \"\"\"\n    Augmented Lagrangian for 1D unilateral contact with constraint u = 0.\n    Returns penetration magnitude max(u, 0) and iterations performed.\n    \"\"\"\n    lam = float(lambda0)\n    u = 0.0\n    iters = 0\n    for it in range(1, max_iter + 1):\n        # Primal update based on piecewise stationarity\n        if lam  P:\n            u = (P - lam) / (k + rho)\n        else:\n            u = (P - lam) / k\n        # Multiplier update with projection for c(u) = 0\n        lam_new = max(0.0, lam + rho * u)\n        # Penetration magnitude and residual\n        pen = max(u, 0.0)\n        # The residual is checked with the NEW multiplier value\n        residual = k * u - P + lam_new\n        iters = it\n        # Stopping: small penetration and near force balance\n        if pen = tol and abs(residual) = tol:\n            break\n        lam = lam_new\n    return pen, iters\n\ndef penalty_only_1d(k, P, rho):\n    \"\"\"\n    Pure penalty solution for 1D unilateral contact with constraint u = 0.\n    For P >= 0, the minimizer is u = P/(k+rho) > 0; report penetration magnitude.\n    \"\"\"\n    if P = 0.0:\n        return 0.0\n    # For compressive load P > 0, closed-form solution\n    u = P / (k + rho)\n    return max(u, 0.0)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (k [N/m], P [N], rho [N/m], lambda0 [N], max_iter, tol)\n    test_cases = [\n        (5e6, 1e4, 5e6, 0.0, 20, 1e-12),       # Test case 1\n        (5e6, 1e4, 2e4, 0.0, 300, 1e-12),      # Test case 2\n        (2e6, 8e3, 2e5, 1.2e4, 100, 1e-12),    # Test case 3\n        (1e6, 0.0, 1e5, 0.0, 10, 1e-12),       # Test case 4\n    ]\n\n    results = []\n    for k, P, rho, lambda0, max_iter, tol in test_cases:\n        aug_pen, iters = augmented_contact_1d(k, P, rho, lambda0, max_iter, tol)\n        pen_only = penalty_only_1d(k, P, rho)\n        # Round penetrations to six decimals as required; iterations are integers\n        results.append(f\"{aug_pen:.6f}\")\n        results.append(f\"{pen_only:.6f}\")\n        results.append(str(iters))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了基本原理后，我们将问题从单个节点扩展到由有限元离散化的连续体。本练习将指导您研究不同接触算法在网格细化过程中的收敛行为，特别是接触力（即拉格朗日乘子）的计算精度。通过编码实践，您将探索增广拉格朗日法所展现的“超收敛”特性，即在不进行后处理的情况下也能获得高精度的接触力，这在实际工程分析中至关重要。",
            "id": "3501910",
            "problem": "考虑一根长度为 $L$ 的一维、小应变、线性弹性杆，其杨氏模量 $E$ 和横截面积 $A$ 为常数。轴向位移场为 $u(x)$，其中 $x \\in [0,L]$。位于 $x=0$ 的左端承受一个给定的位移 $u(0)=\\bar u  0$。位于 $x=L$ 的右端可能会与一个位于零位移处的刚性、不可移动障碍物发生无摩擦单边接触。不可穿透约束为 $u(L) \\le 0$。设 $x=L$ 处的界面牵引力乘子（反力）为 $\\lambda \\ge 0$。$x=L$ 处的 Signorini 条件为 $u(L) \\le 0$，$\\lambda \\ge 0$ 和 $\\lambda\\,u(L)=0$。精确的连续介质解（如果接触被激活）是一个均匀的压缩状态，其位移呈线性分布 $u(x)=\\bar u\\left(1-\\frac{x}{L}\\right)$，接触间隙 $u(L)=0$，精确的界面牵引力大小为 $\\lambda^\\star = \\frac{E A}{L}\\,\\bar u$。所有力必须以牛顿（N）为单位进行解释，位移以米（m）为单位，所有输入和输出必须与这些单位保持一致。\n\n您将使用标准的线性有限元方法来近似此问题，该方法使用 $N$ 个长度为 $h=L/N$ 的等尺寸单元和节点未知数 $u_i$，$i=0,\\dots,N$。全局刚度矩阵由单元刚度 $k_e = \\frac{E A}{h}\\begin{bmatrix}1  -1\\\\ -1  1\\end{bmatrix}$ 组装而成。Dirichlet 条件为 $u_0=\\bar u$。接触约束位于节点 $N$。\n\n必须实现并比较两种数值策略来近似牵引力乘子 $\\lambda$：\n\n- 罚函数法。通过增加一个刚度为 $k_p \\ge 0$ 的边界罚弹簧来替换节点 $N$ 处的单边约束，该弹簧惩罚正位移 $u_N  0$。得到的未知自由节点向量（节点 $1$ 到 $N$）的代数系统为\n$$\nK_{ff}\\,u_f = -K_{f0}\\,\\bar u, \\quad \\text{其中} \\quad K_{NN} \\leftarrow K_{NN} + k_p,\n$$\n罚函数牵引力近似为\n$$\n\\lambda_p = k_p\\,\\max(u_N,0).\n$$\n当 $\\alpha \\ge 0$ 时，使用规范化稳定 $k_p = \\alpha\\,\\frac{E A}{h}$。此外，为了测试固定罚值的边界情况，如果 $\\alpha  0$，则设置 $k_p = (-\\alpha)\\,\\frac{E A}{L}$（相对于 $h$ 是常数）。\n\n- 带有 Uzawa 迭代的增广拉格朗日法（ALM）。在节点 $N$ 引入拉格朗日乘子 $\\lambda$ 和一个增广参数 $\\rho  0$。给定 $\\lambda^{(k)}$，求解线性平衡子问题\n$$\nK_{ff}\\,u_f^{(k)} = -K_{f0}\\,\\bar u - e_N\\,\\lambda^{(k)},\n$$\n其中 $e_N \\in \\mathbb{R}^{N}$ 是选择最后一个自由自由度（节点 $N$）的单位向量。然后通过投影 Uzawa 步更新乘子\n$$\n\\lambda^{(k+1)} = \\max\\big(0,\\;\\lambda^{(k)} + \\rho\\,u_N^{(k)}\\big).\n$$\n迭代直至收敛。为了测试，设置 $\\rho = \\gamma\\,\\frac{E A}{L}$，其中 $\\gamma  0$ 是一个给定的标量。\n\n任务。对于一组给定的测试场景（如下所述），以及每个场景的加密序列 $N \\in \\{4,8,16,32,64\\}$，实现两种方法来计算近似的界面牵引力 $\\lambda_p$（罚函数法）和 $\\lambda_{\\text{ALM}}$（增广拉格朗日法），并将它们与精确值 $\\lambda^\\star=\\frac{E A}{L}\\,\\bar u$ 进行比较。对于每个 $N$，计算相对误差\n$$\n\\varepsilon_{\\text{method}}(N) = \\frac{|\\lambda_{\\text{method}}(N) - \\lambda^\\star|}{\\lambda^\\star}.\n$$\n对于罚函数法，通过对整个加密集上的 $\\log\\big(\\varepsilon_{\\text{penalty}}(N)\\big)$ 与 $\\log(h)$ 进行线性最小二乘拟合，来估计观测到的相对于 $h$ 的收敛率 $p$。对于增广拉格朗日法，计算加密集上的最大相对误差 $\\max_N \\varepsilon_{\\text{ALM}}(N)$，并检查布尔谓词“超收敛”是否成立，这里定义为 $\\max_N \\varepsilon_{\\text{ALM}}(N) \\le 10^{-10}$。\n\n科学基础。从从小应变线性弹性势能、虚功原理以及接触边界处的 Signorini 条件出发。罚函数近似通过一个柔性约束来替代不等式，该约束仅在 $k_p \\to \\infty$ 时才精确，而增广拉格朗日法通过对偶更新（带有增广参数 $\\rho$）来强制执行互补性，从而恢复了一致性。\n\n数值单位与一致性。所有输入必须以 $E$ 为帕斯卡（Pa），$A$ 为平方米（$\\mathrm{m}^2$），$L$ 为米（m），以及 $\\bar u$ 为米（m）进行解释。精确和近似的牵引力单位为牛顿（N）。相对误差是无量纲的。角度不出现，因此不需要单位。\n\n测试套件。使用以下场景；对于每个场景，在加密集 $N \\in \\{4,8,16,32,64\\}$ 上进行计算：\n\n- 测试 $1$（理想情况）：$E=30\\times 10^{9}\\,\\mathrm{Pa}$，$A=1\\times 10^{-2}\\,\\mathrm{m}^2$，$L=2\\,\\mathrm{m}$，$\\bar u=5\\times 10^{-3}\\,\\mathrm{m}$，$\\alpha=10$（因此 $k_p=\\alpha\\,EA/h$），$\\gamma=1$（因此 $\\rho=\\gamma\\,EA/L$）。\n\n- 测试 $2$（较弱的罚函数和较慢的对偶步）：$E=70\\times 10^{9}\\,\\mathrm{Pa}$，$A=5\\times 10^{-3}\\,\\mathrm{m}^2$，$L=3\\,\\mathrm{m}$，$\\bar u=2\\times 10^{-3}\\,\\mathrm{m}$，$\\alpha=1$，$\\gamma=0.5$。\n\n- 测试 $3$（固定罚值的边界情况）：$E=50\\times 10^{9}\\,\\mathrm{Pa}$，$A=2\\times 10^{-2}\\,\\mathrm{m}^2$，$L=1.5\\,\\mathrm{m}$，$\\bar u=1\\times 10^{-3}\\,\\mathrm{m}$，$\\alpha=-1$（因此 $k_p=(-\\alpha)\\,EA/L$ 且不随 $h$ 变化），$\\gamma=1.5$。\n\n需要遵守的算法细节：\n\n- 从大小为 $h=L/N$ 且 $k_e=\\frac{EA}{h}\\begin{bmatrix}1  -1\\\\ -1  1\\end{bmatrix}$ 的线性单元组装全局刚度矩阵 $K \\in \\mathbb{R}^{(N+1)\\times(N+1)}$。\n\n- 通过消除第一行和第一列来强加 $u_0=\\bar u$。简化的右端项必须包括来自给定区域的贡献。\n\n- 罚函数法：如果 $\\alpha \\ge 0$，设置 $k_p=\\alpha\\,EA/h$；如果 $\\alpha  0$，设置 $k_p=(-\\alpha)\\,EA/L$。将 $k_p$ 加到对应于节点 $N$（最后一个自由自由度）的简化矩阵项上。然后计算 $\\lambda_p = k_p\\,\\max(u_N,0)$。\n\n- 增广拉格朗日法：初始化 $\\lambda^{(0)}=0$，设置 $\\rho=\\gamma\\,EA/L$，并迭代\n    - 求解 $K_{ff}\\,u_f^{(k)} = -K_{f0}\\,\\bar u - e_N\\,\\lambda^{(k)}$，\n    - 更新 $\\lambda^{(k+1)}=\\max\\big(0,\\lambda^{(k)} + \\rho\\,u_N^{(k)}\\big)$，\n  直到 $|u_N^{(k)}| \\le 10^{-12}$ 或达到最大迭代次数 $1000$ 次。\n\n- 精确牵引力：$\\lambda^\\star=\\frac{EA}{L}\\,\\bar u$。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个列表，每个测试场景对应一个条目。每个条目本身是一个包含三项的列表：拟合的罚函数收敛率 $p$（浮点数），增广拉格朗日法在所有加密级别上的最大相对误差（浮点数），以及一个布尔值，指示增广拉格朗日法是否超收敛（如上定义）。具体来说，输出必须如下所示\n`[[p_1, maxErrALM_1, isSuper_1], [p_2, maxErrALM_2, isSuper_2], [p_3, maxErrALM_3, isSuper_3]]`,\n并使用标准的 Python 列表格式打印为单行。",
            "solution": "用户提供了一个计算力学领域的问题陈述，具体聚焦于一维弹性杆单边接触的有限元分析。任务是实现并比较两种常用的接触约束施加算法：罚函数法和增广拉格朗日法（ALM）。\n\n### 步骤 1：提取已知条件\n\n- **物理系统**：一维线性弹性杆。\n- **参数**：长度 $L$，杨氏模量 $E$，横截面积 $A$。\n- **位移场**：$u(x)$，其中 $x \\in [0,L]$。\n- **边界条件**：\n    - $x=0$ 处的给定区域：$u(0) = \\bar u  0$。\n    - $x=L$ 处的单边无摩擦接触：\n        - 不可穿透性：$u(L) \\le 0$。\n        - 反力（牵引力乘子）：$\\lambda \\ge 0$。\n        - 互补性：$\\lambda\\,u(L)=0$。\n- **精确解**：\n    - 位移：$u(x)=\\bar u\\left(1-\\frac{x}{L}\\right)$。\n    - 反力：$\\lambda^\\star = \\frac{E A}{L}\\,\\bar u$。\n- **有限元离散化**：\n    - $N$ 个长度为 $h=L/N$ 的等尺寸线性单元。\n    - 节点未知数 $u_i$，其中 $i=0,\\dots,N$。\n    - 单元刚度矩阵：$k_e = \\frac{E A}{h}\\begin{bmatrix}1  -1\\\\ -1  1\\end{bmatrix}$。\n    - Dirichlet 条件的强施加：$u_0=\\bar u$。\n- **罚函数法**：\n    - 待解系统：$K_{ff}\\,u_f = -K_{f0}\\,\\bar u$，其中 $K_{NN} \\leftarrow K_{NN} + k_p$。\n    - 罚参数 $k_p$：\n        - 如果 $\\alpha \\ge 0$：$k_p = \\alpha\\,\\frac{E A}{h}$。\n        - 如果 $\\alpha  0$：$k_p = (-\\alpha)\\,\\frac{E A}{L}$。\n    - 牵引力近似：$\\lambda_p = k_p\\,\\max(u_N,0)$。\n- **增广拉格朗日法（ALM）**：\n    - 采用增广参数 $\\rho = \\gamma\\,\\frac{E A}{L}$ 的迭代方案。\n    - 初始化：$\\lambda^{(0)}=0$。\n    - 子问题：求解 $u_f^{(k)}$，方程为 $K_{ff}\\,u_f^{(k)} = -K_{f0}\\,\\bar u - e_N\\,\\lambda^{(k)}$。\n    - 更新：$\\lambda^{(k+1)} = \\max\\big(0,\\;\\lambda^{(k)} + \\rho\\,u_N^{(k)}\\big)$。\n    - 收敛：迭代直至 $|u_N^{(k)}| \\le 10^{-12}$ 或达到最大迭代次数 1000 次。\n- **任务**：\n    - 对于给定的测试场景和加密级别 $N \\in \\{4,8,16,32,64\\}$：\n        1. 计算近似牵引力 $\\lambda_p$ 和 $\\lambda_{\\text{ALM}}$。\n        2. 计算相对误差 $\\varepsilon_{\\text{method}}(N) = \\frac{|\\lambda_{\\text{method}}(N) - \\lambda^\\star|}{\\lambda^\\star}$。\n        3. 对于罚函数法，通过对 $\\log(\\varepsilon_p)$ vs. $\\log(h)$ 进行线性最小二乘拟合，估计收敛率 $p$。\n        4. 对于 ALM，找到最大相对误差 $\\max_N \\varepsilon_{\\text{ALM}}(N)$ 并检查其是否“超收敛”（$\\le 10^{-10}$）。\n- **测试场景**：\n    1. $E=30\\times 10^{9}\\,\\mathrm{Pa}$，$A=10^{-2}\\,\\mathrm{m}^2$，$L=2\\,\\mathrm{m}$，$\\bar u=5\\times 10^{-3}\\,\\mathrm{m}$，$\\alpha=10$，$\\gamma=1$。\n    2. $E=70\\times 10^{9}\\,\\mathrm{Pa}$，$A=5\\times 10^{-3}\\,\\mathrm{m}^2$，$L=3\\,\\mathrm{m}$，$\\bar u=2\\times 10^{-3}\\,\\mathrm{m}$，$\\alpha=1$，$\\gamma=0.5$。\n    3. $E=50\\times 10^{9}\\,\\mathrm{Pa}$，$A=2\\times 10^{-2}\\,\\mathrm{m}^2$，$L=1.5\\,\\mathrm{m}$，$\\bar u=1\\times 10^{-3}\\,\\mathrm{m}$，$\\alpha=-1$，$\\gamma=1.5$。\n- **输出格式**：一个列表的列表：`[[p_1, maxErrALM_1, isSuper_1], ...]`。\n\n### 步骤 2：使用提取的已知条件进行验证\n\n- **科学基础**：该问题基于线性弹性力学、有限元方法和标准计算接触力学（Signorini 条件、罚函数法、增广拉格朗日法）的基本原理。所有概念在计算地质力学和固体力学领域都是成熟的。\n- **适定性**：该问题是适定的。受压杆撞击刚性墙的物理设置具有唯一解。数值方法是标准的，ALM 迭代方法的参数（$\\gamma \\in \\{1, 0.5, 1.5\\}$）选择在理论收敛域内（$\\gamma  2$）。任务是为指定的输出执行明确定义的算法。\n- **客观性**：问题以精确、客观的数学和工程语言陈述。没有主观或基于意见的元素。\n- **完整性与一致性**：所有必要的数据、参数和算法细节都已提供。单位是一致的。有限元组装和所得线性系统的描述是明确的。问题是自洽的。\n- **现实性**：物理参数对于像岩石或混凝土这样的材料是现实的。问题本身可作为接触算法的规范基准测试。\n\n### 步骤 3：结论与行动\n问题有效。这是一个定义明确、科学合理的计算任务，基于既定原理。我现在将着手构建解决方案。\n\n### 基于原理的设计与求解\n\n解决方案将首先使用有限元方法（FEM）对连续介质问题进行离散化，然后实现两种指定的数值策略来处理接触约束。\n\n#### 1. 有限元离散化\n连续位移场 $u(x)$ 在 $N$ 个单元上被一个分段线性函数所近似。节点位移被收集在一个向量 $\\mathbf{u} \\in \\mathbb{R}^{N+1}$ 中。虚功原理导出了全局线性方程组 $K\\mathbf{u} = \\mathbf{f}$，其中 $K$ 是全局刚度矩阵，$\\mathbf{f}$ 包含节点力。\n\n全局刚度矩阵 $K$ 是通过对每个单元的刚度矩阵 $k_e = \\frac{EA}{h}\\begin{pmatrix}1  -1 \\\\ -1  1\\end{pmatrix}$ 的贡献求和来组装的。这会得到一个对称的三对角矩阵。\n\n通过划分系统来强制施加给定位移 $u_0 = \\bar u$。完整的系统写作：\n$$\n\\begin{pmatrix} K_{00}  K_{0f} \\\\ K_{f0}  K_{ff} \\end{pmatrix}\n\\begin{pmatrix} u_0 \\\\ \\mathbf{u}_f \\end{pmatrix}\n=\n\\begin{pmatrix} f_0 \\\\ \\mathbf{f}_f \\end{pmatrix}\n$$\n其中 $\\mathbf{u}_f = [u_1, u_2, \\dots, u_N]^T$ 是未知自由节点位移的向量。自由未知数的方程是 $K_{ff}\\mathbf{u}_f = \\mathbf{f}_f - K_{f0}u_0$。由于 $u_0=\\bar u$ 且自由节点上的外力由节点 $N$ 处的接触反力 $\\lambda$ 表示，这变为：\n$$\nK_{ff}\\mathbf{u}_f = -K_{f0}\\bar u - \\lambda \\mathbf{e}_N\n$$\n其中 $\\mathbf{e}_N$ 是大小为 $N$ 的标准基向量，其最后一个位置为 $1$。接触力带负号出现，因为它是一个反力，作用方向与正位移方向相反。\n\n#### 2. 罚函数法\n罚函数法用一个刚性弹簧替换硬接触约束。反力近似为 $\\lambda \\approx k_p u_N$（对于 $u_N  0$）。将此代入平衡方程得到：\n$$\nK_{ff}\\mathbf{u}_f \\approx -K_{f0}\\bar u - k_p u_N \\mathbf{e}_N\n$$\n整理各项得到待解系统：\n$$\n(K_{ff} + k_p \\mathbf{e}_N \\mathbf{e}_N^T) \\mathbf{u}_f = -K_{f0}\\bar u\n$$\n这等效于将罚刚度 $k_p$ 加到 $K_{ff}$ 的最后一个对角线元素上。求解出 $\\mathbf{u}_f$ 后，可以找到罚位移 $u_N$。然后，近似反力可恢复为 $\\lambda_p = k_p \\max(u_N, 0)$。该方法是近似的，只有当 $k_p \\to \\infty$ 时才收敛到精确解。对相对误差 $\\varepsilon_p = \\frac{1}{1 + k_p C_N}$ 的分析（其中 $C_N = L/(EA)$ 是杆的精确柔度）预测，当 $k_p \\propto 1/h$ 时收敛率为 $p=1$，当 $k_p$ 为常数时收敛率为 $p=0$。\n\n#### 3. 增广拉格朗日法（ALM）\nALM 是一种迭代方法，它将拉格朗日乘子法与一个类罚项（增广项）相结合。它寻求增广拉格朗日泛函的鞍点。问题提供了 Uzawa 算法，这是用于此目的的常用迭代方案。\n\n对于给定的拉格朗日乘子估计值 $\\lambda^{(k)}$，求解一个标准的线弹性问题以获得位移 $\\mathbf{u}_f^{(k)}$：\n$$\nK_{ff}\\mathbf{u}_f^{(k)} = -K_{f0}\\bar u - \\lambda^{(k)}\\mathbf{e}_N\n$$\n得到的接触间隙/穿透量 $u_N^{(k)}$ 衡量了当前 $\\lambda^{(k)}$ 对约束的违反程度。该违反量用于以类似于积分控制器的方式更新乘子：\n$$\n\\lambda^{(k+1)} = \\text{proj}_{\\ge 0} \\left( \\lambda^{(k)} + \\rho u_N^{(k)} \\right) = \\max(0, \\lambda^{(k)} + \\rho u_N^{(k)})\n$$\n投影 $\\max(0, \\cdot)$ 强制执行约束 $\\lambda \\ge 0$。增广参数 $\\rho$ 控制收敛速度。对于此问题，只要步长合适（具体为 $\\rho  2/C_N = 2EA/L$，对应于 $\\gamma  2$），迭代就会收敛到精确的离散解 $\\lambda^\\star$。由于线性有限元能够精确表示精确解的线性位移场，收敛后的 $\\lambda_{\\text{ALM}}$ 应该在机器精度和迭代容差范围内与 $\\lambda^\\star$ 相匹配，且与网格大小 $N$ 无关。这就是所要测试的“超收敛”行为。\n\n#### 4. 实现与分析\n实现遵循上述逻辑。对每个测试案例，执行一个关于加密级别 $N$ 的循环。在每一步中，执行两种方法以找到 $\\lambda_p$ 和 $\\lambda_{\\text{ALM}}$。相对误差 $\\varepsilon_p$ 和 $\\varepsilon_{\\text{ALM}}$ 被存储起来。循环结束后，对收集到的数据进行分析：\n- 对于罚函数法，在对数-对数数据（$\\log(\\varepsilon_p)$ vs. $\\log(h)$）上使用 `numpy.polyfit` 来确定收敛率 $p$。\n- 对于 ALM，计算存储误差的最大值，并与 $10^{-10}$ 的阈值进行比较，以确定 `isSuperconvergent` 标志。\n\n每个测试案例的最终结果被编译成最终输出所需的列表的列表格式。",
            "answer": "```python\nimport numpy as np\n\ndef assemble_and_partition(N, L, E, A):\n    \"\"\"\n    Assembles the global stiffness matrix K for a 1D bar with N elements,\n    and partitions it into K_ff and K_f0 for the free DOFs.\n    \"\"\"\n    h = L / N\n    # The total number of nodes is N+1, so K is (N+1)x(N+1)\n    K = np.zeros((N + 1, N + 1))\n    # Elemental stiffness matrix\n    ke = (E * A / h) * np.array([[1, -1], [-1, 1]])\n\n    # Assemble global K from elemental contributions\n    for i in range(N):\n        K[i:i+2, i:i+2] += ke\n    \n    # Partition K. Node 0 is prescribed. Nodes 1 to N are free.\n    # K_ff corresponds to free DOFs (nodes 1 to N)\n    K_ff = K[1:, 1:]\n    # K_f0 is the coupling between free and prescribed DOFs\n    K_f0 = K[1:, 0]\n    \n    return K_ff, K_f0\n\ndef solve_penalty(N, L, E, A, u_bar, alpha, K_ff, K_f0):\n    \"\"\"\n    Solves the contact problem using the penalty method.\n    \"\"\"\n    h = L / N\n    \n    # Define penalty parameter k_p based on alpha\n    if alpha >= 0:\n        k_p = alpha * E * A / h\n    else:  # Edge case for fixed penalty\n        k_p = (-alpha) * E * A / L\n        \n    K_prime_ff = K_ff.copy()\n    # Add penalty stiffness to the diagonal entry for the contact node (node N)\n    K_prime_ff[-1, -1] += k_p\n    \n    # RHS vector from prescribed displacement\n    # K_f0 is a 1D array, so we reshape for matrix multiplication later if needed,\n    # but here direct multiplication with scalar u_bar works element-wise.\n    b = -K_f0 * u_bar\n    \n    # Solve for free displacements\n    u_f = np.linalg.solve(K_prime_ff, b)\n    u_N = u_f[-1]\n    \n    # Calculate approximate traction\n    lambda_p = k_p * max(u_N, 0)\n    return lambda_p\n\ndef solve_alm(N, L, E, A, u_bar, gamma, K_ff, K_f0):\n    \"\"\"\n    Solves the contact problem using the Augmented Lagrangian Method (ALM)\n    with Uzawa iterations.\n    \"\"\"\n    rho = gamma * E * A / L\n    lambda_alm = 0.0\n    \n    # RHS contribution from prescribed displacement\n    b_const = -K_f0 * u_bar\n    # Unit vector to select the last DOF (node N)\n    e_N = np.zeros(N)\n    e_N[-1] = 1.0\n    \n    # Max iterations and tolerance\n    max_iter = 1000\n    tol = 1e-12\n\n    for _ in range(max_iter):\n        # Full RHS for the current iteration\n        b_alm = b_const - e_N * lambda_alm\n        # Solve for displacements\n        u_f = np.linalg.solve(K_ff, b_alm)\n        u_N = u_f[-1]\n        \n        # Check for convergence on primal feasibility (gap closure)\n        if abs(u_N) = tol:\n            break\n            \n        # Update Lagrange multiplier (projected Uzawa step)\n        lambda_alm = max(0, lambda_alm + rho * u_N)\n\n    return lambda_alm\n\ndef solve():\n    \"\"\"\n    Main function to run all test scenarios and produce the final output.\n    \"\"\"\n    test_cases = [\n        # E (Pa), A (m^2), L (m), u_bar (m), alpha, gamma\n        (30e9, 1e-2, 2.0, 5e-3, 10.0, 1.0),\n        (70e9, 5e-3, 3.0, 2e-3, 1.0, 0.5),\n        (50e9, 2e-2, 1.5, 1e-3, -1.0, 1.5),\n    ]\n    refinement_N = [4, 8, 16, 32, 64]\n\n    all_results = []\n\n    for E, A, L, u_bar, alpha, gamma in test_cases:\n        # Exact traction magnitude\n        lambda_star = E * A * u_bar / L\n        \n        penalty_errors = []\n        alm_errors = []\n        h_values = []\n\n        for N in refinement_N:\n            h = L / N\n            h_values.append(h)\n            \n            K_ff, K_f0 = assemble_and_partition(N, L, E, A)\n\n            # --- Penalty Method ---\n            lambda_p = solve_penalty(N, L, E, A, u_bar, alpha, K_ff, K_f0)\n            # Avoid division by zero if lambda_star is zero\n            err_p = abs(lambda_p - lambda_star) / lambda_star if lambda_star != 0 else abs(lambda_p)\n            penalty_errors.append(err_p)\n            \n            # --- Augmented Lagrangian Method ---\n            lambda_alm = solve_alm(N, L, E, A, u_bar, gamma, K_ff, K_f0)\n            err_alm = abs(lambda_alm - lambda_star) / lambda_star if lambda_star != 0 else abs(lambda_alm)\n            alm_errors.append(err_alm)\n\n        # --- Post-processing for the current test case ---\n        \n        # 1. Penalty convergence rate\n        # Using np.polyfit for linear least-squares on log-log data\n        # log(err) = p * log(h) + c\n        # Filter out non-positive errors before taking log\n        valid_indices = [i for i, err in enumerate(penalty_errors) if err > 0]\n        if len(valid_indices) > 1:\n            log_h = np.log(np.array(h_values)[valid_indices])\n            log_err_p = np.log(np.array(penalty_errors)[valid_indices])\n            # polyfit returns [slope, intercept] for degree 1\n            p, _ = np.polyfit(log_h, log_err_p, 1)\n        else:\n            p = 0.0 # Not enough data to fit\n\n        # 2. ALM max error and superconvergence check\n        max_err_alm = np.max(alm_errors) if alm_errors else 0.0\n        is_super = max_err_alm = 1e-10\n\n        all_results.append([p, max_err_alm, is_super])\n\n    # Print the final result in the exact specified format\n    print(all_results)\n\nsolve()\n```"
        },
        {
            "introduction": "真实世界中的接触问题几乎总是伴随着摩擦。本练习将挑战您处理经典的、非光滑的库仑摩擦模型，这是在接触算法中实现鲁棒牛顿迭代的一大难点。您将探索并实现两种常用的摩擦锥光滑化方法，并通过量化分析，深入理解光滑化参数 $\\epsilon$ 与计算精度之间的权衡关系。",
            "id": "3501885",
            "problem": "考虑计算岩土力学中的单个局部接触点，其具有一个二维($2$D)切向牵引力向量 $\\mathbf{t}^{\\mathrm{tr}} = (t_1, t_2)$（单位为帕斯卡 Pa）、一个正法向压力 $p_n$（单位为帕斯卡 Pa）以及一个无量纲摩擦系数 $\\mu$。经典库仑摩擦锥定义为集合 $\\mathcal{C} = \\{ \\mathbf{t} \\in \\mathbb{R}^2 \\, | \\, \\| \\mathbf{t} \\|_2 \\le \\mu p_n \\}$，其中 $\\| \\cdot \\|_2$ 表示欧几里得范数。粘着状态的特征是 $\\| \\mathbf{t}^{\\mathrm{tr}} \\|_2 \\le \\mu p_n$，而当 $\\| \\mathbf{t}^{\\mathrm{tr}} \\|_2  \\mu p_n$ 时则发生滑移。在增广拉格朗日框架中，将 $\\mathbf{t}^{\\mathrm{tr}}$ 投影到 $\\mathcal{C}$ 上是指导拉格朗日乘子和罚约束更新的一个关键子步骤。\n\n为研究在增广拉格朗日接触更新中使用的摩擦锥光滑近似，定义由光滑参数 $\\epsilon  0$ 参数化的两族光滑代理范数 $\\phi_{\\epsilon}(\\mathbf{t})$：\n\n- 一个$p$-范数代理，其中 $\\epsilon$ 控制指数 $p$：\n$$\n\\phi_{\\epsilon}^{\\mathrm{pnorm}}(\\mathbf{t}) = \\left( |t_1|^{p} + |t_2|^{p} \\right)^{1/p}, \\quad \\text{其中 } p = 2 + \\epsilon.\n$$\n\n- 一个用于欧几里得范数的Huber型代理，其阈值为 $\\epsilon$：\n$$\n\\phi_{\\epsilon}^{\\mathrm{Huber}}(\\mathbf{t}) =\n\\begin{cases}\n\\dfrac{r^2}{2\\epsilon},  \\text{如果 } r \\le \\epsilon, \\\\\nr - \\dfrac{\\epsilon}{2},  \\text{如果 } r  \\epsilon,\n\\end{cases}\n\\quad \\text{其中 } r = \\sqrt{t_1^2 + t_2^2}.\n$$\n\n使用代理范数 $\\phi_{\\epsilon}$，通过条件 $\\phi_{\\epsilon}(\\mathbf{t}^{\\mathrm{tr}}) \\le \\mu p_n$ 判断为粘着，通过条件 $\\phi_{\\epsilon}(\\mathbf{t}^{\\mathrm{tr}})  \\mu p_n$ 判断为滑移，来定义一个基于光滑化的粘着-滑移分类器。按如下方式定义在增广拉格朗日更新中使用的、相应的基于光滑化的牵引力大小投影：如果 $\\phi_{\\epsilon}(\\mathbf{t}^{\\mathrm{tr}}) \\le \\mu p_n$，则将投影后的大小设为试探大小，即 $\\| \\mathbf{t}^{\\mathrm{sm}} \\|_2 = \\| \\mathbf{t}^{\\mathrm{tr}} \\|_2$；否则，沿当前方向收缩大小以满足光滑边界，即 $\\| \\mathbf{t}^{\\mathrm{sm}} \\|_2 = \\| \\mathbf{t}^{\\mathrm{tr}} \\|_2 \\cdot \\dfrac{\\mu p_n}{\\phi_{\\epsilon}(\\mathbf{t}^{\\mathrm{tr}})}$。对于精确的库仑锥投影，投影后的大小为 $\\| \\mathbf{t}^{\\mathrm{ex}} \\|_2 = \\min\\left( \\| \\mathbf{t}^{\\mathrm{tr}} \\|_2, \\mu p_n \\right)$。\n\n您的任务是：\n\n$1.$ 从库仑摩擦定义和通过增广拉格朗日方法施加约束的思想出发，为精确锥和上文定义的光滑代理，用纯数学术语表述粘着-滑移判定准则和投影方案。\n\n$2.$ 实现一个程序，该程序针对下方的每个测试用例计算：\n- 通过比较 $\\| \\mathbf{t}^{\\mathrm{tr}} \\|_2$ 和 $\\mu p_n$ 进行精确的粘着-滑移分类，\n- 通过比较 $\\phi_{\\epsilon}(\\mathbf{t}^{\\mathrm{tr}})$ 和 $\\mu p_n$ 进行基于光滑化的粘着-滑移分类，\n- 归一化牵引力大小误差\n$$\nE = \\dfrac{\\left| \\| \\mathbf{t}^{\\mathrm{sm}} \\|_2 - \\| \\mathbf{t}^{\\mathrm{ex}} \\|_2 \\right|}{\\mu p_n},\n$$\n该值为无量纲，\n- 错分指示符\n$$\nI =\n\\begin{cases}\n1,  \\text{如果精确分类与基于光滑化的分类结果不同}, \\\\\n0,  \\text{否则}.\n\\end{cases}\n$$\n\n$3.$ 通过报告每个用例的 $E$ 和 $I$，量化光滑参数 $\\epsilon$ 与粘着-滑移转换准确性之间的权衡。所有应力和牵引力必须以帕斯卡 (Pa) 为单位处理。输出 $E$ 和 $I$ 是无量纲的。\n\n使用以下测试套件。对所有用例，取 $\\mu = 0.6$ 和 $p_n = 1.0 \\times 10^{6}$ Pa。每个用例指定代理类型、光滑参数 $\\epsilon$ 以及 $\\mathbf{t}^{\\mathrm{tr}}$ 的分量（单位为帕斯卡 Pa）：\n\n$1.$ $\\left( \\text{pnorm}, \\epsilon = 0.0, t_1 = 0.30 \\times 10^{6}, t_2 = 0.20 \\times 10^{6} \\right)$\n\n$2.$ $\\left( \\text{pnorm}, \\epsilon = 1.0, t_1 = 0.45 \\times 10^{6}, t_2 = 0.45 \\times 10^{6} \\right)$\n\n$3.$ $\\left( \\text{pnorm}, \\epsilon = 0.5, t_1 = 0.80 \\times 10^{6}, t_2 = 0.40 \\times 10^{6} \\right)$\n\n$4.$ $\\left( \\text{pnorm}, \\epsilon = 1.0, t_1 = 0.60 \\times 10^{6}, t_2 = 0.00 \\times 10^{6} \\right)$\n\n$5.$ $\\left( \\text{Huber}, \\epsilon = 1.0 \\times 10^{5}, t_1 = 0.59 \\times 10^{6}, t_2 = 0.05 \\times 10^{6} \\right)$\n\n$6.$ $\\left( \\text{Huber}, \\epsilon = 2.0 \\times 10^{5}, t_1 = 0.45 \\times 10^{6}, t_2 = 0.45 \\times 10^{6} \\right)$\n\n$7.$ $\\left( \\text{Huber}, \\epsilon = 1.0 \\times 10^{3}, t_1 = 0.80 \\times 10^{6}, t_2 = 0.40 \\times 10^{6} \\right)$\n\n$8.$ $\\left( \\text{Huber}, \\epsilon = 1.0 \\times 10^{5}, t_1 = 0.00 \\times 10^{6}, t_2 = 0.00 \\times 10^{6} \\right)$\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，顺序为 `[`E_1`, `I_1`, `E_2`, `I_2`, ..., `E_8`, `I_8`]`, 其中 `E_k` 是测试用例 $k$ 的归一化牵引力大小误差，`I_k` 是测试用例 $k$ 的错分指示符。",
            "solution": "基本依据是经典库仑摩擦定律和用于约束优化的增广拉格朗日方法。接触点上的库仑摩擦定律指出，切向牵引力向量 $\\mathbf{t} \\in \\mathbb{R}^2$ 必须位于由 $\\| \\mathbf{t} \\|_2 \\le \\mu p_n$ 定义的摩擦锥内，其中 $\\mu  0$ 是摩擦系数，$p_n  0$ 是法向压力。当无约束的试探牵引力 $\\mathbf{t}^{\\mathrm{tr}}$ 已满足边界条件 $\\| \\mathbf{t}^{\\mathrm{tr}} \\|_2 \\le \\mu p_n$ 时，发生粘着；而当 $\\| \\mathbf{t}^{\\mathrm{tr}} \\|_2  \\mu p_n$ 时，发生滑移，此时必须将牵引力投影回锥的边界上。\n\n增广拉格朗日方法通过用罚项增广拉格朗日函数，并通过包含向可行集投影的子步骤来迭代更新原始变量和对偶变量，从而施加约束。考虑一个局部摩擦子问题，其中对于已知的 $\\mathbf{t}^{\\mathrm{tr}}$，执行一个到可行摩擦锥上的投影。精确投影保持方向不变，并将大小限制在阈值 $\\mu p_n$ 内。这得到精确的投影后大小\n$$\n\\| \\mathbf{t}^{\\mathrm{ex}} \\|_2 = \\min \\left( \\| \\mathbf{t}^{\\mathrm{tr}} \\|_2, \\mu p_n \\right).\n$$\n这个定义源于与库仑约束一致的、在欧几里得范数意义下牵引力的最小变化，这即是切向牵引力空间中的经典径向返回映射。于是，粘着-滑移判定准则为\n$$\n\\text{如果 } \\| \\mathbf{t}^{\\mathrm{tr}} \\|_2 \\le \\mu p_n \\text{ 则粘着，否则滑移}。\n$$\n\n为了在增广拉格朗日迭代中兼顾可微性和数值鲁棒性，通过 $\\phi_{\\epsilon}(\\mathbf{t}) \\approx \\| \\mathbf{t} \\|_2$ 引入了摩擦锥边界的光滑代理。考虑两种特定的代理：\n\n$1.$ $p$-范数代理\n$$\n\\phi_{\\epsilon}^{\\mathrm{pnorm}}(\\mathbf{t}) = \\left( |t_1|^{p} + |t_2|^{p} \\right)^{1/p}, \\quad p = 2 + \\epsilon,\n$$\n其中参数 $\\epsilon$ 控制 $p$ 相对于 $2$ 的偏离。当 $\\epsilon \\to 0$ 时，$p \\to 2$ 且 $\\phi_{\\epsilon}^{\\mathrm{pnorm}}$ 收敛于欧几里得范数。对于 $\\epsilon  0$，$p  2$ 会产生一个减小较小分量贡献的范数，这对于具有混合分量的向量倾向于低估欧几里得范数，但在坐标轴上保持精确。\n\n$2.$ Huber型代理\n$$\n\\phi_{\\epsilon}^{\\mathrm{Huber}}(\\mathbf{t}) =\n\\begin{cases}\n\\dfrac{r^2}{2\\epsilon},  \\text{如果 } r \\le \\epsilon, \\\\\nr - \\dfrac{\\epsilon}{2},  \\text{如果 } r  \\epsilon,\n\\end{cases}\n\\quad r = \\sqrt{t_1^2 + t_2^2},\n$$\n其在 $\\mathbf{t} = \\mathbf{0}$ 附近是光滑的，并且当 $r \\gg \\epsilon$ 时接近欧几里得范数。当 $r$ 相对于 $\\epsilon$ 较小时，该代理会低估范数，这可能在分类中扩大表观的粘着区域。\n\n有了代理之后，基于光滑化的粘着-滑移判定被表述为\n$$\n\\text{如果 } \\phi_{\\epsilon}(\\mathbf{t}^{\\mathrm{tr}}) \\le \\mu p_n \\text{ 则粘着，否则滑移}。\n$$\n该准则通过光滑代理区域修改了边界，并在需要可微的约束违反度量的增广拉格朗日更新中充当代理。\n\n对于与增广拉格朗日强制执行一致的投影步骤，我们保留试探方向，仅调整其大小。如果基于光滑化的分类器指示为粘着，则不作任何改变：\n$$\n\\| \\mathbf{t}^{\\mathrm{sm}} \\|_2 = \\| \\mathbf{t}^{\\mathrm{tr}} \\|_2.\n$$\n如果指示为滑移，我们通过根据阈值与代理范数之比来缩放试探大小，从而收缩大小以达到代理边界水平，\n$$\n\\| \\mathbf{t}^{\\mathrm{sm}} \\|_2 = \\| \\mathbf{t}^{\\mathrm{tr}} \\|_2 \\cdot \\frac{\\mu p_n}{\\phi_{\\epsilon}(\\mathbf{t}^{\\mathrm{tr}})}.\n$$\n这种缩放使代理度量与阈值 $\\mu p_n$ 对齐，与精确情况下的径向返回相似，但用代理替换了欧几里得范数。精确的投影后大小为\n$$\n\\| \\mathbf{t}^{\\mathrm{ex}} \\|_2 = \\min \\left( \\| \\mathbf{t}^{\\mathrm{tr}} \\|_2, \\mu p_n \\right).\n$$\n\n为了量化光滑参数 $\\epsilon$ 与粘着-滑移准确性之间的权衡，我们为每个测试用例计算：\n- 归一化牵引力大小误差\n$$\nE = \\frac{\\left| \\| \\mathbf{t}^{\\mathrm{sm}} \\|_2 - \\| \\mathbf{t}^{\\mathrm{ex}} \\|_2 \\right|}{\\mu p_n},\n$$\n该值为无量纲，以及\n- 错分指示符\n$$\nI =\n\\begin{cases}\n1,  \\text{如果 } \\left( \\| \\mathbf{t}^{\\mathrm{tr}} \\|_2 \\le \\mu p_n \\right) \\text{ xor } \\left( \\phi_{\\epsilon}(\\mathbf{t}^{\\mathrm{tr}}) \\le \\mu p_n \\right), \\\\\n0,  \\text{否则}.\n\\end{cases}\n$$\n\n从算法上讲，对每个测试用例：\n$1.$ 计算 $r = \\| \\mathbf{t}^{\\mathrm{tr}} \\|_2$。\n$2.$ 使用指定的代理计算 $\\phi_{\\epsilon}(\\mathbf{t}^{\\mathrm{tr}})$。\n$3.$ 通过比较 $r$ 与 $\\mu p_n$ 来确定精确的粘着-滑移状态。\n$4.$ 通过比较 $\\phi_{\\epsilon}$ 与 $\\mu p_n$ 来确定代理的粘着-滑移状态。\n$5.$ 计算 $\\| \\mathbf{t}^{\\mathrm{ex}} \\|_2 = \\min(r, \\mu p_n)$。\n$6.$ 如果代理判定为粘着，则计算 $\\| \\mathbf{t}^{\\mathrm{sm}} \\|_2 = r$，否则计算 $\\| \\mathbf{t}^{\\mathrm{sm}} \\|_2 = r \\cdot \\dfrac{\\mu p_n}{\\phi_{\\epsilon}}$。\n$7.$ 通过用 $\\mu p_n$ 归一化来计算 $E$。\n$8.$ 通过比较精确分类和代理分类来计算 $I$。\n\n测试套件涵盖：\n- 严格在锥内的一般情况（理想路径），\n- 一个在阈值附近及以外的对称情况，其中 $p  2$ 的 $p$-范数光滑化可能低估欧几里得范数并导致错分，\n- 远在锥外的情况（明确滑移），\n- 恰好在锥边界上的情况，\n- 在阈值附近使用中等 $\\epsilon$ 的Huber光滑化，\n- 使用较大 $\\epsilon$ 的Huber光滑化，这会显著低估范数并可能将滑移错分为粘着，\n- 使用较小 $\\epsilon$ 的Huber光滑化，其与欧几里得范数紧密匹配，\n- 零牵引力的边界情况。\n\n最终程序将所有测试用例的 $E$ 和 $I$ 聚合到单个列表中，并以请求的格式单行打印，所有值均为无量纲。这量化了投影牵引力大小的连续误差以及由每个代理的光滑参数 $\\epsilon$ 引起的离散错分。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef norm2(t):\n    \"\"\"Euclidean norm of a 2D vector.\"\"\"\n    return float(np.sqrt(t[0]**2 + t[1]**2))\n\ndef phi_pnorm(t, epsilon):\n    \"\"\"\n    p-norm surrogate with p = 2 + epsilon.\n    For epsilon = 0.0, this equals the Euclidean norm.\n    \"\"\"\n    p = 2.0 + float(epsilon)\n    # Use absolute values to define the p-norm.\n    return float((abs(t[0])**p + abs(t[1])**p) ** (1.0 / p))\n\ndef phi_huber(t, epsilon):\n    \"\"\"\n    Huber-type surrogate of the Euclidean norm with threshold epsilon > 0.\n    For r = epsilon: r^2 / (2*epsilon)\n    For r >  epsilon: r - epsilon/2\n    \"\"\"\n    r = norm2(t)\n    eps = float(epsilon)\n    if eps = 0.0:\n        # Degenerate case: fallback to Euclidean norm.\n        return r\n    if r = eps:\n        return (r**2) / (2.0 * eps)\n    else:\n        return r - 0.5 * eps\n\ndef classify_exact(t, mu, p_n):\n    \"\"\"Exact stick-slip classification under Coulomb cone.\"\"\"\n    r = norm2(t)\n    return r = mu * p_n\n\ndef classify_smooth(t, mu, p_n, kind, epsilon):\n    \"\"\"Smoothing-based stick-slip classification using surrogate phi_epsilon.\"\"\"\n    if kind == 'pnorm':\n        phi = phi_pnorm(t, epsilon)\n    elif kind == 'huber':\n        phi = phi_huber(t, epsilon)\n    else:\n        raise ValueError(\"Unknown smoothing kind.\")\n    return phi = mu * p_n\n\ndef project_exact_magnitude(t, mu, p_n):\n    \"\"\"Exact projected magnitude onto Coulomb cone.\"\"\"\n    r = norm2(t)\n    return min(r, mu * p_n)\n\ndef project_smooth_magnitude(t, mu, p_n, kind, epsilon):\n    \"\"\"\n    Smoothing-based projection magnitude:\n    - If surrogate classifies stick, keep magnitude r.\n    - If slip, scale magnitude by (mu*p_n)/phi to meet the surrogate boundary.\n    \"\"\"\n    r = norm2(t)\n    if kind == 'pnorm':\n        phi = phi_pnorm(t, epsilon)\n    elif kind == 'huber':\n        phi = phi_huber(t, epsilon)\n    else:\n        raise ValueError(\"Unknown smoothing kind.\")\n    # Stick region: do not change traction\n    if phi = mu * p_n:\n        return r\n    # Slip region: shrink along direction to surrogate boundary\n    # Protect against division by zero in pathological cases\n    denom = phi if phi > 0.0 else 1e-16\n    scale = (mu * p_n) / denom\n    return r * scale\n\ndef solve():\n    # Define global parameters: friction coefficient and normal compression (Pa)\n    mu = 0.6\n    p_n = 1.0e6  # Pa\n\n    # Test cases: (kind, epsilon, t1, t2)\n    test_cases = [\n        ('pnorm', 0.0, 0.30e6, 0.20e6),   # 1: inside cone (happy path)\n        ('pnorm', 1.0, 0.45e6, 0.45e6),   # 2: symmetric near threshold, potential misclassification\n        ('pnorm', 0.5, 0.80e6, 0.40e6),   # 3: outside cone (clear slip)\n        ('pnorm', 1.0, 0.60e6, 0.00e6),   # 4: exactly on boundary\n        ('huber', 1.0e5, 0.59e6, 0.05e6), # 5: near threshold, moderate epsilon\n        ('huber', 2.0e5, 0.45e6, 0.45e6), # 6: larger epsilon, potential misclassification\n        ('huber', 1.0e3, 0.80e6, 0.40e6), # 7: small epsilon, close to exact\n        ('huber', 1.0e5, 0.00e6, 0.00e6), # 8: zero traction edge case\n    ]\n\n    results = []\n    for kind, epsilon, t1, t2 in test_cases:\n        t = (t1, t2)\n        # Exact classification and projection\n        stick_exact = classify_exact(t, mu, p_n)\n        mag_exact = project_exact_magnitude(t, mu, p_n)\n        # Smoothing-based classification and projection\n        stick_smooth = classify_smooth(t, mu, p_n, kind, epsilon)\n        mag_smooth = project_smooth_magnitude(t, mu, p_n, kind, epsilon)\n        # Normalized magnitude error\n        E = abs(mag_smooth - mag_exact) / (mu * p_n)\n        # Misclassification indicator\n        I = 1 if (stick_exact != stick_smooth) else 0\n        results.append(E)\n        results.append(I)\n\n    # Format floats with a reasonable precision; integers as-is.\n    formatted = []\n    for val in results:\n        if isinstance(val, float):\n            formatted.append(f\"{val:.8f}\")\n        else:\n            formatted.append(str(int(val)))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted)}]\")\n\nsolve()\n```"
        }
    ]
}