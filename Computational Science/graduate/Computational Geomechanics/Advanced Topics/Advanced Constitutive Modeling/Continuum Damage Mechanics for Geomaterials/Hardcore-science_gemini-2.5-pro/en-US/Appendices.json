{
    "hands_on_practices": [
        {
            "introduction": "A fundamental challenge in standard continuum damage models is their pathological mesh dependency upon strain softening, where damage localizes into a zone of zero width. To address this, we can introduce a non-local formulation, such as a gradient-enhanced model, which incorporates an internal length scale $l$ to regularize the problem. This practice  guides you through the process of numerically solving the resulting boundary value problem for a 1D bar, allowing you to directly investigate how the internal length scale governs the size of the damage localization band.",
            "id": "3510328",
            "problem": "Consider a one-dimensional bar occupying the interval $x \\in [0,L]$ under monotonically increasing tension. The scalar damage variable $D(x)$ satisfies $D(x) \\in [0,1]$, where $D(x) = 0$ denotes undamaged material and $D(x) = 1$ denotes fully damaged material. In a regularized gradient damage framework, the quasi-static steady state of $D(x)$ is obtained by minimizing a quadratic energy functional that penalizes gradients of $D(x)$ to introduce an internal length scale. Let the prescribed energy release rate field be $Y(x)$ and the material strength parameter be $Y_c  0$. Define the normalized driving term $s(x)$ by\n$$\ns(x) = \\min\\left\\{1,\\ \\frac{Y(x)}{Y_c}\\right\\}.\n$$\nAdopt the regularized energy functional\n$$\n\\Pi[D] = \\int_{0}^{L} \\left( \\frac{1}{2}\\left(D(x) - s(x)\\right)^2 + \\frac{l^2}{2}\\left(\\frac{dD}{dx}(x)\\right)^2 \\right)\\, dx,\n$$\nwhere $l  0$ is the internal length parameter that controls the width of the damage localization zone.\n\nYour tasks are:\n- Starting from the above functional and using the calculus of variations, derive the necessary condition for stationarity of $\\Pi[D]$ under arbitrary admissible variations of $D(x)$, and obtain both the governing differential equation for $D(x)$ and the natural boundary conditions on $[0,L]$.\n- For a given $Y(x)$, solve the derived steady-state equation numerically to obtain $D(x)$ and quantify the characteristic width of the localization zone as the Full Width at Half Maximum (FWHM) of $D(x)$, i.e., the distance between the two points where $D(x)$ equals one-half of its maximum value. If the half-maximum level is not crossed within the domain, define the FWHM to be $L$.\n- Implement a uniform finite-difference scheme on a grid of $N$ nodes with $N = 1001$ uniformly spaced points over $[0,L]$. Use the natural boundary conditions that arise from the variational derivation.\n- Use the following test suite, in which the prescribed energy release rate is a centered Gaussian:\n$$\nY(x) = Y_{\\max}\\, \\exp\\!\\left(-\\frac{(x - L/2)^2}{2\\,a^2}\\right),\n$$\nwith $L = 1$, $Y_c = 1$, and with $(Y_{\\max}, a, l)$ taking the following combinations:\n    - Test $1$: $Y_{\\max} = 1.5$, $a = 0.06$, $l = 0.02$.\n    - Test $2$: $Y_{\\max} = 1.5$, $a = 0.06$, $l = 0.005$.\n    - Test $3$: $Y_{\\max} = 1.5$, $a = 0.06$, $l = 0.08$.\n    - Test $4$: $Y_{\\max} = 0.9$, $a = 0.06$, $l = 0.02$.\n- For each test, compute the damage profile $D(x)$ and the FWHM of $D(x)$. Report the normalized FWHM $\\tilde{w} = \\mathrm{FWHM}/L$ (dimensionless, no physical units), rounded to six decimal places.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of Tests $1$ through $4$. For example, the output should look like\n$[r_1,r_2,r_3,r_4]$,\nwhere each $r_i$ is the normalized FWHM for Test $i$, rounded to six decimal places.",
            "solution": "The problem asks for the derivation of the governing equation for a scalar damage variable $D(x)$ from a given energy functional, a numerical solution of the resulting boundary value problem, and the calculation of the full width at half maximum (FWHM) for several test cases.\n\n### Part 1: Variational Derivation\n\nThe analysis begins with the provided energy functional $\\Pi[D]$, which is defined over the domain $x \\in [0,L]$:\n$$\n\\Pi[D] = \\int_{0}^{L} \\mathcal{L}\\left(x, D(x), D'(x)\\right) \\, dx\n$$\nwhere $D'(x) = \\frac{dD}{dx}(x)$ and the Lagrangian density $\\mathcal{L}$ is given by:\n$$\n\\mathcal{L}\\left(x, D, D'\\right) = \\frac{1}{2}\\left(D(x) - s(x)\\right)^2 + \\frac{l^2}{2}\\left(D'(x)\\right)^2\n$$\nHere, $s(x) = \\min\\left\\{1, Y(x)/Y_c\\right\\}$ is the normalized driving term, and $l  0$ is the internal length parameter.\n\nTo find the steady-state damage profile $D(x)$, we seek the function that minimizes this energy functional. The necessary condition for stationarity of $\\Pi[D]$ is that its first variation, $\\delta \\Pi$, must vanish for any arbitrary admissible variation $\\delta D(x)$. The first variation is given by:\n$$\n\\delta \\Pi = \\int_{0}^{L} \\left( \\frac{\\partial \\mathcal{L}}{\\partial D} \\delta D + \\frac{\\partial \\mathcal{L}}{\\partial D'} \\delta D' \\right) dx = 0\n$$\nThe partial derivatives of the Lagrangian $\\mathcal{L}$ with respect to $D$ and $D'$ are:\n$$\n\\frac{\\partial \\mathcal{L}}{\\partial D} = D(x) - s(x)\n$$\n$$\n\\frac{\\partial \\mathcal{L}}{\\partial D'} = l^2 D'(x)\n$$\nSubstituting these into the expression for $\\delta \\Pi$ yields:\n$$\n\\delta \\Pi = \\int_{0}^{L} \\left( \\left(D(x) - s(x)\\right) \\delta D(x) + l^2 D'(x) \\delta D'(x) \\right) dx = 0\n$$\nTo eliminate $\\delta D'$, we integrate the second term by parts, where $\\int u \\, dv = [uv] - \\int v \\, du$. Let $u = l^2 D'(x)$ and $dv = \\delta D'(x) \\, dx$, so that $du = l^2 D''(x) \\, dx$ and $v = \\delta D(x)$. This gives:\n$$\n\\int_{0}^{L} l^2 D'(x) \\delta D'(x) \\, dx = \\left[ l^2 D'(x) \\delta D(x) \\right]_{0}^{L} - \\int_{0}^{L} l^2 D''(x) \\delta D(x) \\, dx\n$$\nSubstituting this back into the expression for $\\delta \\Pi$:\n$$\n\\delta \\Pi = \\int_{0}^{L} \\left( D(x) - s(x) - l^2 D''(x) \\right) \\delta D(x) \\, dx + \\left[ l^2 D'(x) \\delta D(x) \\right]_{0}^{L} = 0\n$$\nThis equation must hold for all admissible variations $\\delta D(x)$. By the fundamental lemma of calculus of variations, for the integral term to be zero for any $\\delta D(x)$ in the open interval $(0, L)$, the integrand multiplying $\\delta D(x)$ must be zero. This yields the Euler-Lagrange equation, which is the governing differential equation for $D(x)$:\n$$\nD(x) - s(x) - l^2 D''(x) = 0\n$$\nRearranging gives a linear, second-order ordinary differential equation (a form of the Helmholtz equation):\n$$\n-l^2 \\frac{d^2D}{dx^2} + D(x) = s(x)\n$$\nFurthermore, the boundary term must also vanish:\n$$\n\\left[ l^2 D'(x) \\delta D(x) \\right]_{0}^{L} = l^2 D'(L) \\delta D(L) - l^2 D'(0) \\delta D(0) = 0\n$$\nSince no specific values for $D(0)$ and $D(L)$ are prescribed (i.e., no essential boundary conditions are imposed), the variations $\\delta D(0)$ and $\\delta D(L)$ are arbitrary. For the boundary term to be zero, their coefficients must be zero. This provides the **natural boundary conditions**:\n$$\n\\frac{dD}{dx}(0) = 0 \\quad \\text{and} \\quad \\frac{dD}{dx}(L) = 0\n$$\nThese are homogeneous Neumann boundary conditions, implying that the damage gradient is zero at the ends of the bar.\n\n### Part 2: Numerical Implementation Strategy\n\nThe derived boundary value problem is solved numerically using a finite-difference method on a uniform grid.\n\n**Discretization:**\nThe domain $[0,L]$ is discretized into $N$ equally spaced nodes $x_i = i \\cdot \\Delta x$ for $i=0, 1, \\dots, N-1$, where the grid spacing is $\\Delta x = L/(N-1)$. Let $D_i = D(x_i)$ and $s_i = s(x_i)$.\n\n**Finite-Difference Approximation:**\nThe second derivative $D''(x)$ at an interior node $x_i$ ($1 \\le i \\le N-2$) is approximated using a second-order central difference scheme:\n$$\n\\frac{d^2D}{dx^2}(x_i) \\approx \\frac{D_{i-1} - 2D_i + D_{i+1}}{(\\Delta x)^2}\n$$\nSubstituting this into the governing ODE gives the discretized equation for an interior node:\n$$\n-l^2 \\left( \\frac{D_{i-1} - 2D_i + D_{i+1}}{(\\Delta x)^2} \\right) + D_i = s_i\n$$\nRearranging a bit, we get:\n$$\n\\left(-\\frac{l^2}{(\\Delta x)^2}\\right) D_{i-1} + \\left(1 + \\frac{2l^2}{(\\Delta x)^2}\\right) D_i + \\left(-\\frac{l^2}{(\\Delta x)^2}\\right) D_{i+1} = s_i\n$$\n\n**Boundary Conditions:**\nThe Neumann boundary conditions $D'(0)=0$ and $D'(L)=0$ are handled using ghost points and central differences to maintain second-order accuracy.\nAt the left boundary ($x_0=0$), $D'(0) \\approx \\frac{D_1 - D_{-1}}{2\\Delta x} = 0$, which implies $D_{-1} = D_1$. Applying the discretized ODE at $i=0$ and substituting $D_{-1}=D_1$:\n$$\n\\left(1 + \\frac{2l^2}{(\\Delta x)^2}\\right) D_0 + \\left(-\\frac{2l^2}{(\\Delta x)^2}\\right) D_1 = s_0\n$$\nAt the right boundary ($x_{N-1}=L$), $D'(L) \\approx \\frac{D_N - D_{N-2}}{2\\Delta x} = 0$, which implies $D_N = D_{N-2}$. Applying the discretized ODE at $i=N-1$ and substituting $D_N=D_{N-2}$:\n$$\n\\left(-\\frac{2l^2}{(\\Delta x)^2}\\right) D_{N-2} + \\left(1 + \\frac{2l^2}{(\\Delta x)^2}\\right) D_{N-1} = s_{N-1}\n$$\n\n**Linear System:**\nThese equations form a system of $N$ linear algebraic equations in the $N$ unknowns $D_0, D_1, \\dots, D_{N-1}$, which can be written in matrix form as $\\mathbf{A}\\mathbf{D} = \\mathbf{s}$. The matrix $\\mathbf{A}$ is a symmetric, tridiagonal matrix with modified entries in the first and last rows to account for the boundary conditions. This system can be solved using standard linear algebra routines.\n\n### Part 3: FWHM Calculation\n\nOnce the discrete solution vector $\\mathbf{D}$ is obtained, the FWHM is calculated as follows:\n1.  Find the maximum damage value, $D_{\\max} = \\max_i(D_i)$.\n2.  Calculate the half-maximum value, $D_{\\text{half}} = D_{\\max} / 2$.\n3.  As per the problem statement, if the damage profile does not cross the $D_{\\text{half}}$ level (which occurs if $D_0 \\ge D_{\\text{half}}$), the FWHM is defined as $L$.\n4.  Otherwise, find the two locations $x_{\\text{left}}$ and $x_{\\text{right}}$ where $D(x) = D_{\\text{half}}$. This is done by finding the grid indices $k$ where the sign of $(D_k - D_{\\text{half}})$ changes. Two such crossings are expected due to the symmetric nature of the problem.\n5.  Linear interpolation is used between the adjacent grid points at each crossing to find $x_{\\text{left}}$ and $x_{\\text{right}}$ with sub-grid accuracy. For a crossing between $x_k$ and $x_{k+1}$:\n    $$\n    x_{\\text{cross}} = x_k + \\Delta x \\frac{D_{\\text{half}} - D_k}{D_{k+1} - D_k}\n    $$\n6.  The FWHM is then computed as $\\mathrm{FWHM} = x_{\\text{right}} - x_{\\text{left}}$.\n7.  Finally, the normalized FWHM is $\\tilde{w} = \\mathrm{FWHM}/L$.\n\nThis procedure is applied to each test case to compute the required values.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the gradient-damage problem for a 1D bar and computes the FWHM of the damage profile.\n    \"\"\"\n    # Define the common parameters and test cases from the problem statement.\n    L = 1.0\n    Y_c = 1.0\n    N = 1001\n\n    test_cases = [\n        # (Y_max, a, l)\n        (1.5, 0.06, 0.02),   # Test 1\n        (1.5, 0.06, 0.005),  # Test 2\n        (1.5, 0.06, 0.08),   # Test 3\n        (0.9, 0.06, 0.02),   # Test 4\n    ]\n\n    results = []\n\n    # Discretize the domain\n    dx = L / (N - 1)\n    x = np.linspace(0.0, L, N)\n\n    for Y_max, a, l in test_cases:\n        # 1. Calculate the normalized driving term s(x)\n        Y = Y_max * np.exp(-(x - L/2)**2 / (2 * a**2))\n        s = np.minimum(1.0, Y / Y_c)\n\n        # 2. Set up the linear system of equations AD = s for the finite difference scheme\n        A = np.zeros((N, N))\n        \n        # Coefficients from the discretized ODE\n        c1 = -l**2 / dx**2\n        c2 = 1.0 - 2.0 * c1\n\n        # Assemble the matrix A\n        # Diagonal elements\n        main_diag = np.full(N, c2)\n        off_diag = np.full(N - 1, c1)\n        \n        A += np.diag(main_diag)\n        A += np.diag(off_diag, k=1)\n        A += np.diag(off_diag, k=-1)\n\n        # Apply natural boundary conditions (D'=0) by modifying the first and last rows\n        # D'_0 = 0 - D_{-1} = D_1\n        A[0, 1] = 2.0 * c1\n        # D'_{N-1} = 0 - D_N = D_{N-2}\n        A[N - 1, N - 2] = 2.0 * c1\n        \n        # 3. Solve the linear system for the damage profile D\n        D = np.linalg.solve(A, s)\n\n        # 4. Calculate the Full Width at Half Maximum (FWHM)\n        D_max = np.max(D)\n        D_half = D_max / 2.0\n        \n        # Check for the edge case where the half-maximum level is not crossed\n        if D[0] = D_half:\n            fwhm = L\n        else:\n            # Find indices where the profile crosses the half-maximum level\n            # These are the indices k where the sign of (D - D_half) changes between k and k+1\n            cross_indices = np.where(np.diff(np.sign(D - D_half)) != 0)[0]\n            \n            if len(cross_indices)  2:\n                # Should not happen for the given symmetric profiles unless D_max is close to D at boundary\n                fwhm = L\n            else:\n                # Left crossing\n                k_left = cross_indices[0]\n                # Linear interpolation for x_left\n                x_left = x[k_left] + dx * (D_half - D[k_left]) / (D[k_left + 1] - D[k_left])\n                \n                # Right crossing\n                k_right = cross_indices[-1] # Use last found crossing\n                # Linear interpolation for x_right\n                x_right = x[k_right] + dx * (D_half - D[k_right]) / (D[k_right + 1] - D[k_right])\n                \n                fwhm = x_right - x_left\n        \n        # Normalize FWHM and round to six decimal places\n        normalized_fwhm = round(fwhm / L, 6)\n        results.append(normalized_fwhm)\n\n    # Format the final output as a comma-separated list in brackets\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "When modeling dynamic events, the interplay between inertial forces and material degradation becomes crucial. This exercise  transitions from static analysis to the dynamic regime by exploring a damageable oscillator, a simple yet powerful model for understanding material behavior under dynamic loading. You will implement a stable explicit time-stepping algorithm, tackling key numerical challenges such as stability constraints and the enforcement of physical bounds on the damage variable.",
            "id": "3510336",
            "problem": "Consider a single-degree-of-freedom one-dimensional oscillator representing a small segment of a geomaterial with stiffness degraded by a scalar damage variable. Let the displacement be $x(t)$, the velocity be $v(t)$, the mass be $m$, the undamaged linear stiffness be $k_0$, and the linear viscous damping be $c$. The scalar damage variable $D(t)$ is dimensionless and represents stiffness degradation such that the effective stiffness is $k(D) = (1 - D)\\,k_0$. The governing equation of motion is derived from Newton's Second Law as\n$$\nm\\,\\ddot{x}(t) + c\\,\\dot{x}(t) + k(D(t))\\,x(t) = 0,\n$$\nwith initial conditions $x(0) = x_0$ and $v(0) = v_0$. The damage driving force is taken as the undamaged spring strain energy,\n$$\nY(t) = \\tfrac{1}{2}\\,k_0\\,x(t)^2,\n$$\nand the damage evolution is given by the ordinary differential equation\n$$\n\\dot{D}(t) = \\alpha\\,\\max\\big(0,\\,Y(t) - Y_0\\big)\\,\\big(1 - D(t)\\big)^p,\n$$\nwhere $\\alpha$ is a material parameter with units of $(\\text{second} \\cdot \\text{joule})^{-1}$, $Y_0$ is a threshold energy in joules, and $p  0$ is an exponent controlling the saturation rate as $D \\to 1$. The damage must remain bounded in the physically admissible interval $0 \\le D \\le 1$.\n\nYour task is to implement an explicit time-stepping algorithm over a fixed time horizon using a velocity-Verlet-like scheme adapted to viscous damping, together with a return-mapping-like projection of the damage update to enforce $0 \\le D \\le 1$. At each time step $t_n \\to t_{n+1} = t_n + \\Delta t$, do the following:\n1. Use the current state $(x_n, v_n, D_n)$ to compute the acceleration $a_n = \\ddot{x}_n$ from the equation of motion with stiffness $k(D_n)$.\n2. Update the velocity to a half-step $v_{n+\\frac{1}{2}} = v_n + \\tfrac{\\Delta t}{2}\\,a_n$.\n3. Predict the next displacement $x_{n+1} = x_n + \\Delta t\\,v_{n+\\frac{1}{2}}$.\n4. Compute a trial damage update using explicit Euler with the updated displacement in the driving force,\n$$\nD_{n+1}^{\\text{trial}} = D_n + \\Delta t\\,\\alpha\\,\\max\\Big(0,\\,\\tfrac{1}{2}k_0\\,x_{n+1}^2 - Y_0\\Big)\\,\\big(1 - D_n\\big)^p.\n$$\n5. Enforce bounds through a return-mapping-like nearest-point projection onto the admissible set $[0,1]$,\n$$\nD_{n+1} = \\begin{cases}\n0  \\text{if } D_{n+1}^{\\text{trial}}  0,\\\\\nD_{n+1}^{\\text{trial}}  \\text{if } 0 \\le D_{n+1}^{\\text{trial}} \\le 1,\\\\\n1  \\text{if } D_{n+1}^{\\text{trial}}  1,\n\\end{cases}\n$$\nand set the effective stiffness $k_{n+1} = (1 - D_{n+1})\\,k_0$.\n6. Finalize the velocity using an implicit correction consistent with the damping force at $t_{n+1}$ that preserves linearity of the update. With $a_{n+1} = -\\frac{c}{m}\\,v_{n+1} - \\frac{k_{n+1}}{m}\\,x_{n+1}$, solve\n$$\nv_{n+1} = v_{n+\\frac{1}{2}} + \\tfrac{\\Delta t}{2}\\,a_{n+1}\n$$\nfor $v_{n+1}$ to obtain\n$$\nv_{n+1} = \\frac{v_{n+\\frac{1}{2}} - \\tfrac{\\Delta t}{2}\\,\\frac{k_{n+1}}{m}\\,x_{n+1}}{1 + \\tfrac{\\Delta t}{2}\\,\\frac{c}{m}}.\n$$\n\nThe damping $c$ must be selected from a specified damping ratio $\\zeta$ using the undamaged natural frequency $\\omega_0 = \\sqrt{k_0/m}$ as $c = 2\\,m\\,\\zeta\\,\\omega_0$. You must simulate the system for a given total time $T$, uniform time step $\\Delta t$, and specified parameters. At the end of the simulation, quantify the following:\n- The boundedness of the dynamics as a boolean $\\mathsf{stable}$, defined as true if and only if the maximum absolute displacement over the simulation satisfies $\\max_n |x_n| \\le X_{\\text{lim}}$, the maximum absolute velocity satisfies $\\max_n |v_n| \\le V_{\\text{lim}}$, and no numerical NaN or infinity occurred.\n- The enforcement of damage bounds as a boolean $\\mathsf{in\\_bounds}$, defined as true if and only if $D_n \\in [0,1]$ for all time steps.\n- The final damage $D_{\\text{final}} = D_N$ as a float, where $N$ is the last time index.\n- The maximum absolute displacement $\\max_n |x_n|$ as a float in meters.\n\nAll quantities involving physical units must be expressed using the following units: mass in kilograms (kg), stiffness in newtons per meter (N/m), damping in newton-seconds per meter (N·s/m), time in seconds (s), displacements in meters (m), velocities in meters per second (m/s), energy in joules (J), and the damage parameter $\\alpha$ in $(\\text{second} \\cdot \\text{joule})^{-1}$. Angles are not used in this problem.\n\nImplement the algorithm and evaluate the following test suite, which covers a general case, a near-boundary large time step, and an extreme large time step with rapid damage evolution:\n\n- Test Case 1 (general stable regime):\n    - $m = 1000\\,\\text{kg}$, $k_0 = 1.0\\times 10^7\\,\\text{N/m}$, $\\zeta = 0.02$, $\\Delta t = 0.005\\,\\text{s}$, $T = 1.0\\,\\text{s}$.\n    - $\\alpha = 1.0\\times 10^{-7}\\,(\\text{s}\\cdot\\text{J})^{-1}$, $Y_0 = 5000\\,\\text{J}$, $p = 1.0$.\n    - $x_0 = 0.05\\,\\text{m}$, $v_0 = 0.0\\,\\text{m/s}$.\n    - Boundedness thresholds: $X_{\\text{lim}} = 0.5\\,\\text{m}$, $V_{\\text{lim}} = 2.0\\,\\text{m/s}$.\n\n- Test Case 2 (near stability limit for undamaged stiffness):\n    - $m = 1000\\,\\text{kg}$, $k_0 = 1.0\\times 10^7\\,\\text{N/m}$, $\\zeta = 0.01$, $\\Delta t = 0.019\\,\\text{s}$, $T = 1.0\\,\\text{s}$.\n    - $\\alpha = 5.0\\times 10^{-7}\\,(\\text{s}\\cdot\\text{J})^{-1}$, $Y_0 = 2000\\,\\text{J}$, $p = 1.0$.\n    - $x_0 = 0.05\\,\\text{m}$, $v_0 = 0.0\\,\\text{m/s}$.\n    - Boundedness thresholds: $X_{\\text{lim}} = 0.5\\,\\text{m}$, $V_{\\text{lim}} = 5.0\\,\\text{m/s}$.\n\n- Test Case 3 (extreme large time step with rapid damage):\n    - $m = 1000\\,\\text{kg}$, $k_0 = 1.0\\times 10^7\\,\\text{N/m}$, $\\zeta = 0.20$, $\\Delta t = 0.050\\,\\text{s}$, $T = 1.0\\,\\text{s}$.\n    - $\\alpha = 5.0\\times 10^{-5}\\,(\\text{s}\\cdot\\text{J})^{-1}$, $Y_0 = 1000\\,\\text{J}$, $p = 1.0$.\n    - $x_0 = 0.10\\,\\text{m}$, $v_0 = 0.0\\,\\text{m/s}$.\n    - Boundedness thresholds: $X_{\\text{lim}} = 1.0\\,\\text{m}$, $V_{\\text{lim}} = 10.0\\,\\text{m/s}$.\n\nYour program should produce a single line of output containing the aggregated results from all test cases as a comma-separated list enclosed in square brackets. Each test case contributes four entries in the order $[\\mathsf{stable},\\mathsf{in\\_bounds},D_{\\text{final}},\\max |x|]$, so the final output line must have twelve entries, ordered by the test cases as listed. For example, the output format must be\n$[\\mathsf{stable}_1,\\mathsf{in\\_bounds}_1,D_{\\text{final},1},\\max |x|_1,\\mathsf{stable}_2,\\mathsf{in\\_bounds}_2,D_{\\text{final},2},\\max |x|_2,\\mathsf{stable}_3,\\mathsf{in\\_bounds}_3,D_{\\text{final},3},\\max |x|_3]$.",
            "solution": "The derivation starts from a fundamental base: Newton's Second Law of Motion and the internal variable concept in continuum damage mechanics. The one-dimensional equation of motion for a mass-spring-damper system with damage-degraded stiffness is\n$$\nm\\,\\ddot{x}(t) + c\\,\\dot{x}(t) + k(D(t))\\,x(t) = 0,\n$$\nwith $k(D) = (1 - D)\\,k_0$, where the damage variable $D \\in [0,1]$ reduces the stored stiffness. The internal variable $D$ evolves in time according to a rate equation driven by a thermodynamically consistent measure of strain energy. For concreteness and to maintain scientific realism, we adopt the undamaged spring energy $Y(t) = \\frac{1}{2}k_0 x(t)^2$ and the damage rate\n$$\n\\dot{D}(t) = \\alpha\\,\\max\\big(0,\\,Y(t) - Y_0\\big)\\,\\big(1 - D(t)\\big)^p,\n$$\nwhich ensures $\\dot{D}(t) \\ge 0$ whenever the stored energy exceeds the threshold $Y_0$, and provides saturation as $D \\to 1$ through the $(1-D)^p$ factor.\n\nTo construct an algorithm suited to dynamic simulations and testing stability under large time steps, we employ a velocity-Verlet-like scheme adapted for viscous damping. The classical velocity Verlet update for conservative systems is symplectic and second-order accurate. In the presence of velocity-proportional damping, we modify the final velocity update by solving a one-step linear equation, thereby preserving the explicit nature while accounting for damping at the end of the step.\n\nDenote $t_n = n\\,\\Delta t$ and the discrete states $(x_n, v_n, D_n)$. The acceleration at step $n$ is\n$$\na_n = \\ddot{x}_n = -\\frac{c}{m}\\,v_n - \\frac{k(D_n)}{m}\\,x_n.\n$$\nThe velocity half-step update is\n$$\nv_{n+\\frac{1}{2}} = v_n + \\frac{\\Delta t}{2}\\,a_n.\n$$\nThe displacement update is\n$$\nx_{n+1} = x_n + \\Delta t\\,v_{n+\\frac{1}{2}}.\n$$\nThe damage update uses explicit Euler with the updated displacement in the driving force to reduce numerical lag:\n$$\nD_{n+1}^{\\text{trial}} = D_n + \\Delta t\\,\\alpha\\,\\max\\Big(0,\\,\\tfrac{1}{2}k_0\\,x_{n+1}^2 - Y_0\\Big)\\,\\big(1 - D_n\\big)^p.\n$$\nBecause the admissible set for the damage variable is the closed interval $[0,1]$, we enforce bounds via a return-mapping-like projection onto this convex set, defined as the nearest-point projection in the Euclidean norm:\n$$\nD_{n+1} = \\Pi_{[0,1]}\\big(D_{n+1}^{\\text{trial}}\\big) = \\min\\big(1,\\,\\max(0,\\,D_{n+1}^{\\text{trial}})\\big).\n$$\nThis projection is consistent with standard practices in inelasticity for enforcing constraints (similar in philosophy to return mapping in plasticity), and ensures that $D$ remains within physical bounds.\n\nWith the updated damage, set the effective stiffness for the next acceleration evaluation:\n$$\nk_{n+1} = (1 - D_{n+1})\\,k_0.\n$$\nFor the final velocity, we recognize that the acceleration at $t_{n+1}$ depends on $v_{n+1}$ due to damping:\n$$\na_{n+1} = -\\frac{c}{m}\\,v_{n+1} - \\frac{k_{n+1}}{m}\\,x_{n+1}.\n$$\nThe velocity update formula is\n$$\nv_{n+1} = v_{n+\\frac{1}{2}} + \\frac{\\Delta t}{2}\\,a_{n+1}.\n$$\nSubstituting $a_{n+1}$ and solving for $v_{n+1}$ yields a scalar linear equation:\n$$\nv_{n+1} + \\frac{\\Delta t}{2}\\frac{c}{m}v_{n+1} = v_{n+\\frac{1}{2}} - \\frac{\\Delta t}{2}\\frac{k_{n+1}}{m}x_{n+1}.\n$$\nTherefore,\n$$\nv_{n+1} = \\frac{v_{n+\\frac{1}{2}} - \\frac{\\Delta t}{2}\\frac{k_{n+1}}{m}x_{n+1}}{1 + \\frac{\\Delta t}{2}\\frac{c}{m}}.\n$$\nThis closed-form update retains explicitness while incorporating the damping consistently at the end of the step.\n\nThe damping coefficient is specified via the damping ratio using the undamaged natural frequency,\n$$\n\\omega_0 = \\sqrt{\\frac{k_0}{m}}, \\quad c = 2\\,m\\,\\zeta\\,\\omega_0.\n$$\nThe stability of explicit schemes for linear undamped oscillators is traditionally constrained by $\\Delta t \\le \\frac{2}{\\omega_0}$; here, we deliberately test scenarios near and beyond that limit to observe boundedness under damping and damage-induced stiffness degradation. Because damage reduces stiffness, the instantaneous natural frequency may decrease in time, potentially relaxing the stability condition after sufficient damage develops. However, the early-time response still depends on the undamaged stiffness. Therefore, the selected test cases include:\n- A small time step well within the stability bound;\n- A large time step near the critical bound for the undamaged system;\n- An extreme large time step exceeding the bound, tempered by significant damping and rapid damage evolution.\n\nAlgorithmic checks ensure numerical robustness. The boundedness boolean $\\mathsf{stable}$ is defined to be true if the displacement and velocity amplitudes do not exceed specified thresholds and if no NaN or infinity appears in the simulation. The $\\mathsf{in\\_bounds}$ boolean confirms $D_n \\in [0,1]$ at all steps, guaranteed by the projection but still verified numerically with a small tolerance. The final damage and maximum absolute displacement are recorded as floats.\n\nImplementation steps:\n1. For each test case, read parameters $(m, k_0, \\zeta, \\Delta t, T, \\alpha, Y_0, p, x_0, v_0, X_{\\text{lim}}, V_{\\text{lim}})$.\n2. Compute $\\omega_0 = \\sqrt{k_0/m}$ and $c = 2\\,m\\,\\zeta\\,\\omega_0$.\n3. Initialize $(x, v, D) = (x_0, v_0, 0)$ and maxima $(x_{\\max}, v_{\\max})$.\n4. Loop over $N = \\lfloor T/\\Delta t \\rfloor$ steps using the described update scheme.\n5. Track maxima and check boundedness and damage bounds.\n6. Aggregate results per test case into $[\\mathsf{stable}, \\mathsf{in\\_bounds}, D_{\\text{final}}, x_{\\max}]$.\n7. Print all results from the test suite in a single list as specified.\n\nScientific realism and unit consistency are ensured by using physical units throughout, adopting a plausible damage evolution law, and selecting parameters that reflect typical geomaterial stiffness and mass scales. The projection ensures the physical constraint $0 \\le D \\le 1$ even under aggressive time stepping, while the damping and damage interact to influence stability. The test suite includes a general case, a near-boundary case, and an extreme case to provide coverage for different dynamical regimes.\n\nThe final program adheres to the required output format by printing a single line composed of the concatenated results from the three test cases, each contributing four entries in the prescribed order.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef simulate_case(m, k0, zeta, dt, T, alpha, Y0, p, x0, v0, X_lim, V_lim):\n    \"\"\"\n    Simulate the damage-degrading oscillator using a velocity-Verlet-like scheme with damping\n    and a return-mapping-like projection for the damage variable.\n    \"\"\"\n    # Undamaged natural frequency and damping\n    omega0 = np.sqrt(k0 / m)\n    c = 2.0 * m * zeta * omega0\n\n    # Initial conditions\n    x = float(x0)\n    v = float(v0)\n    D = 0.0  # start undamaged\n\n    # Tracking maxima and flags\n    max_abs_x = abs(x)\n    max_abs_v = abs(v)\n    in_bounds = True\n    finite_values = True\n\n    # Number of time steps\n    n_steps = int(np.floor(T / dt))\n\n    # Time-stepping loop\n    for _ in range(n_steps):\n        # Effective stiffness at current step\n        k_eff_n = (1.0 - D) * k0\n\n        # Acceleration at current step\n        a_n = -(c / m) * v - (k_eff_n / m) * x\n\n        # Velocity half-step\n        v_half = v + 0.5 * dt * a_n\n\n        # Displacement update\n        x_new = x + dt * v_half\n\n        # Damage trial update using explicit Euler and undamaged energy at x_new\n        Y_new = 0.5 * k0 * (x_new ** 2)\n        damage_rate = alpha * max(0.0, Y_new - Y0) * ((1.0 - D) ** p)\n        D_trial = D + dt * damage_rate\n\n        # Return-mapping-like projection onto [0, 1]\n        D_new = min(1.0, max(0.0, D_trial))\n\n        # Effective stiffness for next step\n        k_eff_np1 = (1.0 - D_new) * k0\n\n        # Finalize velocity with damping-consistent correction:\n        # v_{n+1} = (v_half - (dt/2)*(k_eff/m)*x_new) / (1 + (dt/2)*(c/m))\n        denom = 1.0 + 0.5 * dt * (c / m)\n        v_new = (v_half - 0.5 * dt * (k_eff_np1 / m) * x_new) / denom\n\n        # Update state\n        x, v, D = x_new, v_new, D_new\n\n        # Track maxima\n        ax = abs(x)\n        av = abs(v)\n        if ax  max_abs_x:\n            max_abs_x = ax\n        if av  max_abs_v:\n            max_abs_v = av\n\n        # Check bounds and finiteness with tolerance\n        if not (D = -1e-12 and D = 1.0 + 1e-12):\n            in_bounds = False\n        if not (np.isfinite(x) and np.isfinite(v) and np.isfinite(D)):\n            finite_values = False\n            break  # stop early if numerical failure\n\n    # Stability check against provided limits and finiteness\n    stable = (max_abs_x = X_lim) and (max_abs_v = V_lim) and finite_values\n\n    return stable, in_bounds, D, max_abs_x\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1\n        {\n            \"m\": 1000.0, \"k0\": 1.0e7, \"zeta\": 0.02, \"dt\": 0.005, \"T\": 1.0,\n            \"alpha\": 1.0e-7, \"Y0\": 5000.0, \"p\": 1.0,\n            \"x0\": 0.05, \"v0\": 0.0,\n            \"X_lim\": 0.5, \"V_lim\": 2.0\n        },\n        # Test Case 2\n        {\n            \"m\": 1000.0, \"k0\": 1.0e7, \"zeta\": 0.01, \"dt\": 0.019, \"T\": 1.0,\n            \"alpha\": 5.0e-7, \"Y0\": 2000.0, \"p\": 1.0,\n            \"x0\": 0.05, \"v0\": 0.0,\n            \"X_lim\": 0.5, \"V_lim\": 5.0\n        },\n        # Test Case 3\n        {\n            \"m\": 1000.0, \"k0\": 1.0e7, \"zeta\": 0.20, \"dt\": 0.050, \"T\": 1.0,\n            \"alpha\": 5.0e-5, \"Y0\": 1000.0, \"p\": 1.0,\n            \"x0\": 0.10, \"v0\": 0.0,\n            \"X_lim\": 1.0, \"V_lim\": 10.0\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        stable, in_bounds, D_final, max_abs_x = simulate_case(\n            m=case[\"m\"], k0=case[\"k0\"], zeta=case[\"zeta\"],\n            dt=case[\"dt\"], T=case[\"T\"],\n            alpha=case[\"alpha\"], Y0=case[\"Y0\"], p=case[\"p\"],\n            x0=case[\"x0\"], v0=case[\"v0\"],\n            X_lim=case[\"X_lim\"], V_lim=case[\"V_lim\"]\n        )\n        # Append in the specified order: [stable, in_bounds, D_final, max_abs_x]\n        results.extend([stable, in_bounds, D_final, max_abs_x])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "For many geomaterials, inelastic behavior involves a complex interplay between permanent plastic deformation and stiffness degradation from damage. This capstone practice  challenges you to implement a state-of-the-art coupled damage-plasticity model, a cornerstone of modern computational geomechanics. You will derive and code a fully implicit return-mapping algorithm, which requires solving the local constitutive equations with a Newton-Raphson scheme to ensure accuracy and robustness.",
            "id": "3510309",
            "problem": "Consider a small-strain, isotropic, combined damage–plasticity model for a geomaterial under isothermal, quasi-static conditions. The kinematic variable is the infinitesimal strain tensor $\\boldsymbol{\\varepsilon}$, and the Cauchy stress tensor is $\\boldsymbol{\\sigma}$. Adopt the strain equivalence hypothesis so that the undamaged (effective) stress is $\\tilde{\\boldsymbol{\\sigma}}$ and the nominal stress is $\\boldsymbol{\\sigma} = (1 - D)\\,\\tilde{\\boldsymbol{\\sigma}}$, where $D \\in [0,1)$ is a scalar isotropic damage variable. Let the undamaged elastic response be linear and isotropic with Young’s modulus $E$ and Poisson’s ratio $\\nu$, with shear modulus $G = \\dfrac{E}{2(1+\\nu)}$ and bulk modulus $K = \\dfrac{E}{3(1 - 2\\nu)}$. Define the volumetric strain $\\varepsilon_v = \\mathrm{tr}(\\boldsymbol{\\varepsilon})$ and the deviatoric strain $\\boldsymbol{\\varepsilon}^{\\mathrm{dev}} = \\boldsymbol{\\varepsilon} - \\dfrac{1}{3}\\varepsilon_v \\boldsymbol{I}$, where $\\boldsymbol{I}$ is the second-order identity tensor.\n\nThe effective stress obeys Hooke’s law with an additive split between elastic and plastic parts, $\\boldsymbol{\\varepsilon} = \\boldsymbol{\\varepsilon}^e + \\boldsymbol{\\varepsilon}^p$, such that the effective stress is\n$$\n\\tilde{\\boldsymbol{\\sigma}} = 2G \\left( \\boldsymbol{\\varepsilon}^{\\mathrm{dev}} - \\boldsymbol{\\varepsilon}^{p,\\mathrm{dev}} \\right) + K\\,\\varepsilon_v\\,\\boldsymbol{I}.\n$$\nThe plasticity model is $J_2$ (von Mises) with linear isotropic hardening in terms of the internal variable $\\kappa$ (equivalent plastic strain) such that the yield function for the effective stress is\n$$\nf(\\tilde{\\boldsymbol{\\sigma}},\\kappa) = q(\\tilde{\\boldsymbol{\\sigma}}) - \\sqrt{\\frac{2}{3}}\\left(\\sigma_{y0} + H \\kappa\\right),\n$$\nwhere $q(\\tilde{\\boldsymbol{\\sigma}}) = \\sqrt{\\frac{3}{2}}\\,\\|\\tilde{\\boldsymbol{s}}\\|$ and $\\tilde{\\boldsymbol{s}} = \\tilde{\\boldsymbol{\\sigma}} - \\dfrac{1}{3}\\mathrm{tr}(\\tilde{\\boldsymbol{\\sigma}})\\boldsymbol{I}$ is the deviatoric part of the effective stress. The associative flow rule states\n$$\n\\dot{\\boldsymbol{\\varepsilon}}^p = \\dot{\\gamma}\\,\\frac{\\partial f}{\\partial \\tilde{\\boldsymbol{\\sigma}}}, \\quad \\dot{\\kappa} = \\sqrt{\\frac{2}{3}}\\,\\dot{\\gamma},\n$$\nwhere $\\dot{\\gamma} \\ge 0$ is the plastic multiplier rate. The Kuhn–Tucker conditions and consistency condition apply to $f$.\n\nDamage is isotropic and governed by a monotonic law linked to the hardening variable:\n$$\nD = g(\\kappa) = 1 - \\exp(-a\\,\\kappa),\n$$\nwith $a  0$. Assume $D$ does not alter the yield function (effective stress concept), but degrades the nominal stress through $\\boldsymbol{\\sigma} = (1-D)\\,\\tilde{\\boldsymbol{\\sigma}}$.\n\nYour task is to derive a consistent return-mapping algorithm for a single increment from a known previous state $(\\boldsymbol{\\varepsilon}^p_n, \\kappa_n, D_n)$ to $(\\boldsymbol{\\varepsilon}^p_{n+1}, \\kappa_{n+1}, D_{n+1})$ under a prescribed total strain $\\boldsymbol{\\varepsilon}_{n+1}$. Start from the following fundamental bases:\n- Small-strain kinematics and isotropic linear elasticity with the given moduli.\n- Definition of the $J_2$ equivalent stress and associative flow rule.\n- Kuhn–Tucker conditions and consistency condition for plasticity.\n- The damage evolution relation $D = g(\\kappa)$ and strain equivalence $\\boldsymbol{\\sigma} = (1-D)\\,\\tilde{\\boldsymbol{\\sigma}}$.\n\nDerive the residual equations for a single-step, fully implicit update that solves simultaneously for the plastic multiplier increment $\\Delta\\gamma$, the updated hardening variable $\\kappa_{n+1}$, and the updated damage $D_{n+1}$ in one Newton iteration, together with the consistent update of the stress $\\boldsymbol{\\sigma}_{n+1}$. The derivation must show how the deviatoric trial effective stress is constructed, how the consistency condition enters the residual, the coupling between $\\Delta\\gamma$ and $\\kappa_{n+1}$, and the damage residual. Explain clearly how the stress is finally updated and how the nominal equivalent von Mises stress is computed from $\\boldsymbol{\\sigma}_{n+1}$.\n\nImplement the derived algorithm in a program that processes the following test suite. Each test case specifies $(E, \\nu, \\sigma_{y0}, H, a)$ and a prescribed strain in Voigt ordering with engineering shear components as $[ \\varepsilon_{11}, \\varepsilon_{22}, \\varepsilon_{33}, \\varepsilon_{12}, \\varepsilon_{23}, \\varepsilon_{13} ]$. The initial state for all cases is $\\boldsymbol{\\varepsilon}^p_n = \\boldsymbol{0}$, $\\kappa_n = 0$, $D_n = 0$. Units: $E$, $\\sigma_{y0}$, and $H$ must be in $\\mathrm{MPa}$; strains are dimensionless; the nominal equivalent von Mises stress must be reported in $\\mathrm{MPa}$.\n\nTest suite:\n- Case $1$: $(E, \\nu, \\sigma_{y0}, H, a) = (1500, 0.25, 60, 80, 2.0)$, strain $[0, 0, 0, 0.06, 0, 0]$.\n- Case $2$: $(E, \\nu, \\sigma_{y0}, H, a) = (1500, 0.25, 60, 80, 2.0)$, strain $[0, 0, 0, 0.02, 0, 0]$.\n- Case $3$: $(E, \\nu, \\sigma_{y0}, H, a) = (1000, 0.30, 20, 10, 10.0)$, strain $[0, 0, 0, 0.125, 0, 0]$.\n- Case $4$: $(E, \\nu, \\sigma_{y0}, H, a) = (1000, 0.30, 50, 100, 2.0)$, strain $[-0.01, -0.01, -0.01, 0, 0, 0]$.\n\nFor each case, compute and return the following quantities after convergence: the updated nominal equivalent von Mises stress $q_{n+1}$ in $\\mathrm{MPa}$, the plastic multiplier increment $\\Delta\\gamma$ (dimensionless), the updated hardening variable $\\kappa_{n+1}$ (dimensionless), and the updated damage $D_{n+1}$ (dimensionless). The program must implement a Newton iteration that simultaneously solves for $\\Delta\\gamma$, $\\kappa_{n+1}$, and $D_{n+1}$ and then updates $\\boldsymbol{\\sigma}_{n+1}$ consistently. Use a convergence tolerance of $10^{-12}$ on the Euclidean norm of the residual vector and a maximum of $50$ iterations.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, flattening the results across the test cases in the order $[q_1,\\Delta\\gamma_1,\\kappa_1,D_1,q_2,\\Delta\\gamma_2,\\kappa_2,D_2,\\ldots]$. All floating-point numbers must be rounded to six decimal places. For example, an output with two test cases would be of the form $[q_1,\\Delta\\gamma_1,\\kappa_1,D_1,q_2,\\Delta\\gamma_2,\\kappa_2,D_2]$ with each value printed to six decimal places.",
            "solution": "### Derivation of the Consistent Return-Mapping Algorithm\n\nThe objective is to formulate a return-mapping algorithm for a coupled isotropic damage-plasticity model. Given the state at step $n$ $(\\boldsymbol{\\varepsilon}^p_n, \\kappa_n)$ and a prescribed total strain $\\boldsymbol{\\varepsilon}_{n+1}$, we seek to find the state at step $n+1$ $(\\boldsymbol{\\varepsilon}^p_{n+1}, \\kappa_{n+1}, D_{n+1}, \\boldsymbol{\\sigma}_{n+1})$. The algorithm follows an elastic-predictor, plastic-corrector structure.\n\n#### 1. Fundamental Equations\n\nThe model is defined by the following set of equations:\n- **Strain decomposition**: $\\boldsymbol{\\varepsilon} = \\boldsymbol{\\varepsilon}^e + \\boldsymbol{\\varepsilon}^p$.\n- **Effective stress**: $\\tilde{\\boldsymbol{\\sigma}} = \\mathbb{C} : \\boldsymbol{\\varepsilon}^e$, where $\\mathbb{C}$ is the isotropic linear elastic stiffness tensor. This can be written using the bulk modulus $K = \\frac{E}{3(1-2\\nu)}$ and shear modulus $G = \\frac{E}{2(1+\\nu)}$ as:\n$$ \\tilde{\\boldsymbol{\\sigma}} = K\\,\\mathrm{tr}(\\boldsymbol{\\varepsilon}^e)\\,\\boldsymbol{I} + 2G\\,\\mathrm{dev}(\\boldsymbol{\\varepsilon}^e) $$\nSince plastic strain is isochoric for $J_2$ plasticity ($\\mathrm{tr}(\\boldsymbol{\\varepsilon}^p) = 0$), we have $\\mathrm{tr}(\\boldsymbol{\\varepsilon}^e) = \\mathrm{tr}(\\boldsymbol{\\varepsilon}) = \\varepsilon_v$. The effective stress is:\n$$ \\tilde{\\boldsymbol{\\sigma}} = K\\,\\varepsilon_v\\,\\boldsymbol{I} + 2G(\\boldsymbol{\\varepsilon}^{\\text{dev}} - \\boldsymbol{\\varepsilon}^{p,\\text{dev}}) $$\n- **Nominal stress (Strain Equivalence)**: $\\boldsymbol{\\sigma} = (1 - D)\\,\\tilde{\\boldsymbol{\\sigma}}$.\n- **Yield function**: $f(\\tilde{\\boldsymbol{\\sigma}},\\kappa) = q(\\tilde{\\boldsymbol{\\sigma}}) - \\sigma_y(\\kappa) = 0$, where:\n  - Equivalent effective stress: $q(\\tilde{\\boldsymbol{\\sigma}}) = \\sqrt{\\frac{3}{2}\\tilde{\\boldsymbol{s}}:\\tilde{\\boldsymbol{s}}} = \\sqrt{\\frac{3}{2}}\\|\\tilde{\\boldsymbol{s}}\\|$, with $\\tilde{\\boldsymbol{s}} = \\mathrm{dev}(\\tilde{\\boldsymbol{\\sigma}})$.\n  - Yield strength: $\\sigma_y(\\kappa) = \\sqrt{\\frac{2}{3}}(\\sigma_{y0} + H\\kappa)$.\n- **Flow rule (associative)**: $\\dot{\\boldsymbol{\\varepsilon}}^p = \\dot{\\gamma}\\,\\frac{\\partial f}{\\partial \\tilde{\\boldsymbol{\\sigma}}}$, where $\\dot{\\gamma}$ is the plastic multiplier. The gradient is $\\frac{\\partial f}{\\partial \\tilde{\\boldsymbol{\\sigma}}} = \\frac{\\partial q}{\\partial \\tilde{\\boldsymbol{\\sigma}}} = \\sqrt{\\frac{3}{2}}\\frac{\\tilde{\\boldsymbol{s}}}{\\|\\tilde{\\boldsymbol{s}}\\|}$.\n- **Hardening law**: $\\dot{\\kappa} = \\sqrt{\\frac{2}{3}}\\,\\dot{\\gamma}$.\n- **Damage evolution law**: $D = g(\\kappa) = 1 - \\exp(-a\\,\\kappa)$.\n- **Kuhn-Tucker conditions**: $\\dot{\\gamma} \\ge 0$, $f \\le 0$, $\\dot{\\gamma}f = 0$.\n\n#### 2. Elastic Predictor\n\nFirst, assume the increment is purely elastic ($\\Delta\\gamma = 0$). The internal variables do not change: $\\boldsymbol{\\varepsilon}^p_{n+1} = \\boldsymbol{\\varepsilon}^p_n$ and $\\kappa_{n+1} = \\kappa_n$.\nThe trial effective stress, $\\tilde{\\boldsymbol{\\sigma}}^{\\text{trial}}_{n+1}$, is computed based on the total strain $\\boldsymbol{\\varepsilon}_{n+1}$:\n$$ \\tilde{\\boldsymbol{\\sigma}}^{\\text{trial}}_{n+1} = \\mathbb{C} : (\\boldsymbol{\\varepsilon}_{n+1} - \\boldsymbol{\\varepsilon}^p_n) $$\nThe deviatoric part of the trial effective stress is:\n$$ \\tilde{\\boldsymbol{s}}^{\\text{trial}}_{n+1} = 2G(\\boldsymbol{\\varepsilon}^{\\text{dev}}_{n+1} - \\boldsymbol{\\varepsilon}^{p,\\text{dev}}_n) $$\nNext, check for yielding by evaluating the yield function with the trial stress and the state from step $n$:\n$$ f^{\\text{trial}} = q(\\tilde{\\boldsymbol{\\sigma}}^{\\text{trial}}_{n+1}) - \\sigma_y(\\kappa_n) $$\nIf $f^{\\text{trial}} \\le 0$, the assumption was correct. The step is elastic. The state is updated as:\n$$ \\Delta\\gamma=0, \\quad \\kappa_{n+1} = \\kappa_n, \\quad D_{n+1} = D_n, \\quad \\tilde{\\boldsymbol{\\sigma}}_{n+1} = \\tilde{\\boldsymbol{\\sigma}}^{\\text{trial}}_{n+1}, \\quad \\boldsymbol{\\sigma}_{n+1} = (1-D_n)\\tilde{\\boldsymbol{\\sigma}}_{n+1} $$\n\n#### 3. Plastic Corrector (Return Mapping)\n\nIf $f^{\\text{trial}}  0$, plastic flow occurs, and a correction is needed. We use a fully implicit backward Euler integration scheme for the evolution equations over the increment $\\Delta t$:\n$$ \\Delta\\boldsymbol{\\varepsilon}^p = \\boldsymbol{\\varepsilon}^p_{n+1} - \\boldsymbol{\\varepsilon}^p_n = \\Delta\\gamma \\frac{\\partial f}{\\partial \\tilde{\\boldsymbol{\\sigma}}}\\bigg|_{n+1} $$\n$$ \\kappa_{n+1} = \\kappa_n + \\sqrt{\\frac{2}{3}}\\Delta\\gamma $$\n$$ D_{n+1} = 1 - \\exp(-a\\kappa_{n+1}) $$\nThe state must satisfy the consistency condition at the end of the step: $f(\\tilde{\\boldsymbol{\\sigma}}_{n+1}, \\kappa_{n+1}) = 0$.\n\nThe updated effective deviatoric stress is:\n$$ \\tilde{\\boldsymbol{s}}_{n+1} = 2G(\\boldsymbol{\\varepsilon}^{\\text{dev}}_{n+1} - \\boldsymbol{\\varepsilon}^{p,\\text{dev}}_{n+1}) = 2G(\\boldsymbol{\\varepsilon}^{\\text{dev}}_{n+1} - \\boldsymbol{\\varepsilon}^{p,\\text{dev}}_n - \\Delta\\boldsymbol{\\varepsilon}^p) = \\tilde{\\boldsymbol{s}}^{\\text{trial}}_{n+1} - 2G\\Delta\\boldsymbol{\\varepsilon}^p $$\nSubstituting the flow rule:\n$$ \\tilde{\\boldsymbol{s}}_{n+1} = \\tilde{\\boldsymbol{s}}^{\\text{trial}}_{n+1} - 2G\\Delta\\gamma \\sqrt{\\frac{3}{2}} \\frac{\\tilde{\\boldsymbol{s}}_{n+1}}{\\|\\tilde{\\boldsymbol{s}}_{n+1}\\|} = \\tilde{\\boldsymbol{s}}^{\\text{trial}}_{n+1} - 3G\\Delta\\gamma \\frac{\\tilde{\\boldsymbol{s}}_{n+1}}{q(\\tilde{\\boldsymbol{\\sigma}}_{n+1})} $$\nThis implies that $\\tilde{\\boldsymbol{s}}_{n+1}$ is collinear with $\\tilde{\\boldsymbol{s}}^{\\text{trial}}_{n+1}$. Taking the norm and multiplying by $\\sqrt{3/2}$ yields the standard radial return equation for the equivalent stress:\n$$ q_{n+1} = q^\\text{trial}_{n+1} - 3G\\Delta\\gamma $$\n\n#### 4. Simultaneous Solution with Newton-Raphson\n\nThe problem requires a simultaneous solution for the unknowns $(\\Delta\\gamma, \\kappa_{n+1}, D_{n+1})$. This set of unknowns, along with the governing equations, forms a non-linear system that can be solved using the Newton-Raphson method. Let the vector of unknowns be $\\mathbf{x} = [\\Delta\\gamma, \\kappa_{n+1}, D_{n+1}]^T$. We formulate a system of three residual equations $\\mathbf{R}(\\mathbf{x}) = \\mathbf{0}$.\n\n1.  **Hardening Residual ($R_1$)**: From the discrete hardening law:\n    $$ R_1(\\mathbf{x}) = \\kappa_{n+1} - \\kappa_n - \\sqrt{\\frac{2}{3}}\\Delta\\gamma = 0 $$\n2.  **Damage Residual ($R_2$)**: From the damage evolution law:\n    $$ R_2(\\mathbf{x}) = D_{n+1} - (1 - \\exp(-a\\kappa_{n+1})) = D_{n+1} + \\exp(-a\\kappa_{n+1}) - 1 = 0 $$\n3.  **Consistency Residual ($R_3$)**: From the consistency condition $f_{n+1} = 0$, substituting the radial return formula:\n    $$ q_{n+1} - \\sigma_y(\\kappa_{n+1}) = 0 \\implies (q^\\text{trial}_{n+1} - 3G\\Delta\\gamma) - \\sqrt{\\frac{2}{3}}(\\sigma_{y0} + H\\kappa_{n+1}) = 0 $$\n    $$ R_3(\\mathbf{x}) = q^\\text{trial}_{n+1} - 3G\\Delta\\gamma - \\sqrt{\\frac{2}{3}}(\\sigma_{y0} + H\\kappa_{n+1}) = 0 $$\n\nThe Newton-Raphson method iteratively solves for the correction $\\delta\\mathbf{x}$ to the current guess $\\mathbf{x}^{(i)}$ by solving the linear system $\\mathbf{J}(\\mathbf{x}^{(i)})\\delta\\mathbf{x} = -\\mathbf{R}(\\mathbf{x}^{(i)})$, where $\\mathbf{J}$ is the Jacobian matrix $J_{ij} = \\frac{\\partial R_i}{\\partial x_j}$.\n\nThe Jacobian matrix for our system is:\n$$\n\\mathbf{J} =\n\\begin{pmatrix}\n\\frac{\\partial R_1}{\\partial \\Delta\\gamma}  \\frac{\\partial R_1}{\\partial \\kappa_{n+1}}  \\frac{\\partial R_1}{\\partial D_{n+1}} \\\\\n\\frac{\\partial R_2}{\\partial \\Delta\\gamma}  \\frac{\\partial R_2}{\\partial \\kappa_{n+1}}  \\frac{\\partial R_2}{\\partial D_{n+1}} \\\\\n\\frac{\\partial R_3}{\\partial \\Delta\\gamma}  \\frac{\\partial R_3}{\\partial \\kappa_{n+1}}  \\frac{\\partial R_3}{\\partial D_{n+1}}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n-\\sqrt{2/3}  1  0 \\\\\n0  -a \\exp(-a\\kappa_{n+1})  1 \\\\\n-3G  -\\sqrt{2/3} H  0\n\\end{pmatrix}\n$$\nThe iteration proceeds as $\\mathbf{x}^{(i+1)} = \\mathbf{x}^{(i)} + \\delta\\mathbf{x}$ until the norm of the residual vector $\\|\\mathbf{R}\\|$ is below a specified tolerance.\n\n#### 5. Final State Update\n\nOnce converged values for $(\\Delta\\gamma, \\kappa_{n+1}, D_{n+1})$ are found, the remaining state variables are updated:\n- **Effective stress**:\n  $$ \\tilde{\\boldsymbol{s}}_{n+1} = \\tilde{\\boldsymbol{s}}^{\\text{trial}}_{n+1}\\left(1 - \\frac{3G\\Delta\\gamma}{q^\\text{trial}_{n+1}}\\right) $$\n  $$ \\tilde{p}_{n+1} = -K\\,\\varepsilon_v = -K\\,\\mathrm{tr}(\\boldsymbol{\\varepsilon}_{n+1}) $$\n  $$ \\tilde{\\boldsymbol{\\sigma}}_{n+1} = \\tilde{\\boldsymbol{s}}_{n+1} - \\tilde{p}_{n+1}\\boldsymbol{I} $$\n- **Nominal stress**:\n  $$ \\boldsymbol{\\sigma}_{n+1} = (1-D_{n+1})\\tilde{\\boldsymbol{\\sigma}}_{n+1} $$\n- **Nominal equivalent von Mises stress**: This is the final quantity of interest.\n  $$ q_{nom, n+1} = \\sqrt{\\frac{3}{2}\\boldsymbol{s}_{n+1}:\\boldsymbol{s}_{n+1}} = \\sqrt{\\frac{3}{2}} \\|(1-D_{n+1})\\tilde{\\boldsymbol{s}}_{n+1}\\| = (1-D_{n+1})q_{n+1} $$\n  From the consistency condition, we know $q_{n+1} = \\sigma_y(\\kappa_{n+1}) = \\sqrt{\\frac{2}{3}}(\\sigma_{y0} + H\\kappa_{n+1})$. Therefore:\n  $$ q_{nom, n+1} = (1-D_{n+1})\\sqrt{\\frac{2}{3}}(\\sigma_{y0} + H\\kappa_{n+1}) $$\nThis provides a direct way to compute the final required output once the internal variables are known.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the damage-plasticity problem for all test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1: (E, nu, sigma_y0, H, a), strain\n        ((1500, 0.25, 60, 80, 2.0), np.array([0, 0, 0, 0.06, 0, 0])),\n        # Case 2: (E, nu, sigma_y0, H, a), strain\n        ((1500, 0.25, 60, 80, 2.0), np.array([0, 0, 0, 0.02, 0, 0])),\n        # Case 3: (E, nu, sigma_y0, H, a), strain\n        ((1000, 0.30, 20, 10, 10.0), np.array([0, 0, 0, 0.125, 0, 0])),\n        # Case 4: (E, nu, sigma_y0, H, a), strain\n        ((1000, 0.30, 50, 100, 2.0), np.array([-0.01, -0.01, -0.01, 0, 0, 0])),\n    ]\n\n    results = []\n    for params, strain_voigt in test_cases:\n        res = solve_case(params, strain_voigt)\n        results.extend([f\"{v:.6f}\" for v in res])\n\n    print(f\"[{','.join(results)}]\")\n\ndef voigt_to_tensor(voigt_vec):\n    \"\"\"Converts a 6x1 Voigt strain vector to a 3x3 tensor.\"\"\"\n    eps = np.zeros((3, 3))\n    eps[0, 0] = voigt_vec[0]\n    eps[1, 1] = voigt_vec[1]\n    eps[2, 2] = voigt_vec[2]\n    # In this problem, Voigt input is given with tensor shear components\n    eps[0, 1] = eps[1, 0] = voigt_vec[3]\n    eps[1, 2] = eps[2, 1] = voigt_vec[4]\n    eps[0, 2] = eps[2, 0] = voigt_vec[5]\n    return eps\n\ndef solve_case(params, strain_voigt_n1):\n    \"\"\"\n    Solves a single load increment for the coupled damage-plasticity model.\n    \"\"\"\n    E, nu, sigma_y0, H, a = params\n    \n    # Material properties\n    G = E / (2.0 * (1.0 + nu))\n    K = E / (3.0 * (1.0 - 2.0 * nu))\n\n    # Initial state (step n) - all start from zero\n    eps_p_n_tensor = np.zeros((3, 3))\n    kappa_n = 0.0\n    # D_n = 1.0 - np.exp(-a * kappa_n) # D_n = 0\n\n    # Prescribed state (step n+1)\n    eps_n1_tensor = voigt_to_tensor(strain_voigt_n1)\n\n    # Elastic predictor\n    eps_v_n1 = np.trace(eps_n1_tensor)\n    eps_dev_n1_tensor = eps_n1_tensor - (eps_v_n1 / 3.0) * np.identity(3)\n    \n    # Trial effective deviatoric stress\n    s_eff_trial_n1_tensor = 2.0 * G * (eps_dev_n1_tensor - eps_p_n_tensor)\n    \n    # Trial equivalent stress (von Mises)\n    s_eff_trial_n1_norm = np.sqrt(np.sum(s_eff_trial_n1_tensor * s_eff_trial_n1_tensor))\n    q_eff_trial_n1 = np.sqrt(3.0 / 2.0) * s_eff_trial_n1_norm\n\n    # Yield stress at step n\n    sigma_y_n = np.sqrt(2.0/3.0) * (sigma_y0 + H * kappa_n)\n\n    # Yield check\n    f_trial = q_eff_trial_n1 - sigma_y_n\n    \n    # Tolerance for floating point comparisons\n    TOL_f = 1e-12\n\n    if f_trial = TOL_f:\n        # --- Elastic step ---\n        delta_gamma = 0.0\n        kappa_n1 = kappa_n\n        D_n1 = 1.0 - np.exp(-a * kappa_n1)\n\n        # In an elastic step, deviatoric stress is just the trial value.\n        # Volumetric stress for all cases here is 0 except Case 4.\n        # For Case 4, strain is purely volumetric, so trial deviatoric stress is 0,\n        # leading to q_eff_trial = 0, and thus an elastic step.\n        q_eff_n1 = q_eff_trial_n1\n        q_nom_n1 = (1.0 - D_n1) * q_eff_n1\n\n        return q_nom_n1, delta_gamma, kappa_n1, D_n1\n\n    # --- Plastic step (Return Mapping) ---\n    \n    # Newton-Raphson for [delta_gamma, kappa_n1, D_n1]\n    # Initial guess:\n    x = np.array([0.0, kappa_n, 1.0 - np.exp(-a * kappa_n)]) # [delta_gamma, kappa_n1, D_n1]\n    \n    max_iter = 50\n    TOL_R = 1e-12\n    sqrt_2_3 = np.sqrt(2.0 / 3.0)\n\n    for i in range(max_iter):\n        delta_gamma_i, kappa_n1_i, D_n1_i = x\n\n        # Residual vector R\n        R = np.zeros(3)\n        R[0] = kappa_n1_i - kappa_n - sqrt_2_3 * delta_gamma_i\n        R[1] = D_n1_i + np.exp(-a * kappa_n1_i) - 1.0\n        R[2] = q_eff_trial_n1 - 3.0 * G * delta_gamma_i - sqrt_2_3 * (sigma_y0 + H * kappa_n1_i)\n\n        if np.linalg.norm(R)  TOL_R:\n            break\n\n        # Jacobian matrix J\n        J = np.zeros((3, 3))\n        J[0, 0] = -sqrt_2_3\n        J[0, 1] = 1.0\n        # J[0,2] = 0\n        # J[1,0] = 0\n        J[1, 1] = -a * np.exp(-a * kappa_n1_i)\n        J[1, 2] = 1.0\n        J[2, 0] = -3.0 * G\n        J[2, 1] = -sqrt_2_3 * H\n        # J[2,2] = 0\n\n        # Solve for increment and update\n        delta_x = np.linalg.solve(J, -R)\n        x += delta_x\n    \n    delta_gamma, kappa_n1, D_n1 = x\n    \n    # Post-convergence calculation\n    # Final nominal equivalent von Mises stress\n    q_nom_n1 = (1.0 - D_n1) * sqrt_2_3 * (sigma_y0 + H * kappa_n1)\n\n    return q_nom_n1, delta_gamma, kappa_n1, D_n1\n\nsolve()\n```"
        }
    ]
}