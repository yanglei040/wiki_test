{
    "hands_on_practices": [
        {
            "introduction": "分析单桩的沉降是基础工程设计中的一项基本任务。本练习将总沉降分解为两个关键部分：桩身的弹性压缩和桩端下方土体的变形。通过从基本原理出发实现这一简化模型，您将清楚地理解如何结合结构响应和岩土响应来预测基础的性能。",
            "id": "3499728",
            "problem": "一根细长的圆柱桩被垂直打入一个占据半无限半空间的均质、各向同性、线性弹性土中。该桩承受轴向压缩荷载，且忽略桩身的侧向阻力，以分离出桩端的响应效应。桩被建模为一维弹性杆，其轴向力沿其长度不变。土体被建模为经典弹性半空间。桩端为平面圆形，其与土体的接触被建模为无摩擦接触，这与弹性半空间上的刚性圆形压头模型一致。\n\n从线性弹性和固体力学的基本定律和核心定义出发，推导计算给定轴向荷载下桩头沉降所需的控制关系式。对桩使用一维轴向杆理论，对桩端-土体接触使用弹性半空间理论。不得使用任何未经基本原理解释的简化公式或预先推导的表达式。\n\n您的任务是编写一个完整的、可运行的程序，根据一组给定的参数，计算以米为单位的桩头沉降。杆身的压缩量必须根据胡克定律和轴向平衡从基本原理计算得出。桩端压缩量必须根据刚性圆形压头的弹性半空间解来计算。桩头总沉降是杆身压缩量和桩端压缩量之和。必须一致地使用以下定义和物理量：\n\n- 桩的轴向荷载 $P$，单位为牛顿。\n- 桩长 $L$，单位为米。\n- 桩的横截面积 $A$，单位为平方米。\n- 桩的杨氏模量 $E_\\mathrm{p}$，单位为帕斯卡。\n- 土的杨氏模量 $E_\\mathrm{s}$，单位为帕斯卡。\n- 土的泊松比 $\\nu_\\mathrm{s}$（无量纲）。\n- 桩端半径 $a$，单位为米。\n- 土的剪切模量 $G_\\mathrm{s}$ 定义为 $G_\\mathrm{s} = \\dfrac{E_\\mathrm{s}}{2\\left(1+\\nu_\\mathrm{s}\\right)}$。\n\n您的程序必须为每个测试用例计算以下量：\n1. 杆身压缩量 $\\,\\delta_\\mathrm{bar}\\,$，单位为米。\n2. 基于桩端荷载下弹性半空间响应的桩端压缩量 $\\,\\delta_\\mathrm{tip}\\,$，单位为米。\n3. 桩头总沉降 $\\,s\\,$，单位为米，定义为 $\\,s = \\delta_\\mathrm{bar} + \\delta_\\mathrm{tip}\\,$。\n\n所有沉降均以米为单位，表示为浮点数。\n\n测试套件：\n使用以下参数集，每个元组按 $\\left(P, L, A, E_\\mathrm{p}, a, E_\\mathrm{s}, \\nu_\\mathrm{s}\\right)$ 的顺序列出，单位和定义如上所述。\n\n- 情况 1 (一般情况)：$\\left(2.0\\times10^6,\\; 12.0,\\; 0.25,\\; 3.0\\times10^{10},\\; 0.40,\\; 1.0\\times10^8,\\; 0.30\\right)$。\n- 情况 2 (高刚度桩)：$\\left(2.0\\times10^6,\\; 12.0,\\; 0.25,\\; 2.0\\times10^{11},\\; 0.40,\\; 1.0\\times10^8,\\; 0.30\\right)$。\n- 情况 3 (大桩端半径和较硬土)：$\\left(3.0\\times10^6,\\; 20.0,\\; 0.25,\\; 3.0\\times10^{10},\\; 0.75,\\; 1.5\\times10^8,\\; 0.35\\right)$。\n- 情况 4 (近乎不可压缩的土)：$\\left(2.0\\times10^6,\\; 12.0,\\; 0.25,\\; 3.0\\times10^{10},\\; 0.40,\\; 1.0\\times10^9,\\; 0.49\\right)$。\n- 情况 5 (长桩)：$\\left(2.0\\times10^6,\\; 80.0,\\; 0.25,\\; 3.0\\times10^{10},\\; 0.40,\\; 1.0\\times10^8,\\; 0.30\\right)$。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含上述测试用例的桩头总沉降（以米为单位），格式为方括号内以逗号分隔的列表。例如：“[$s_1,s_2,s_3,s_4,s_5$]”。每个沉降值都必须以米为单位表示。不应打印任何额外文本。",
            "solution": "该问题要求计算竖向加载桩的总沉降 $s$。总沉降是两种不同物理现象的总和：桩身本身的弹性压缩量 $\\delta_{\\mathrm{bar}}$，以及桩端下方土体的沉降量 $\\delta_{\\mathrm{tip}}$。问题指定了一个简化模型，其中忽略了桩身的侧摩阻力，这意味着施加于桩头的全部轴向荷载 $P$ 都传递到了桩端。因此，该系统可被分解为两个子问题，并可使用固体力学的基本原理进行独立分析。总沉降表示为：\n$$ s = \\delta_{\\mathrm{bar}} + \\delta_{\\mathrm{tip}} $$\n\n首先，我们推导桩身弹性压缩量 $\\delta_{\\mathrm{bar}}$ 的表达式。\n桩被建模为长度为 $L$、恒定横截面积为 $A$、杨氏模量为 $E_{\\mathrm{p}}$ 的一维弹性杆。根据问题陈述和静力平衡原理，轴向力沿桩身长度是恒定的。这是忽略侧向阻力的直接结果。因此，任何横截面上的内部轴向力都等于施加的荷载 $P$。\n\n轴向应力 $\\sigma$ 定义为单位面积上的力。由于内力是均匀的，应力沿桩身也是均匀的：\n$$ \\sigma = \\frac{P}{A} $$\n轴向应变 $\\epsilon$ 定义为单位长度的变形量。对于单轴加载下的线性弹性材料，胡克定律指出应力与应变成正比：\n$$ \\sigma = E_{\\mathrm{p}} \\epsilon $$\n其中 $E_{\\mathrm{p}}$ 是桩材料的杨氏模量。通过组合这两个基本方程，我们求解桩中的应变：\n$$ \\epsilon = \\frac{\\sigma}{E_{\\mathrm{p}}} = \\frac{P}{A E_{\\mathrm{p}}} $$\n应变表示位移沿桩轴线的局部变化率。桩的总压缩量 $\\delta_{\\mathrm{bar}}$，通过将应变沿桩的整个长度 $L$ 进行积分得到：\n$$ \\delta_{\\mathrm{bar}} = \\int_{0}^{L} \\epsilon \\, dz $$\n由于材料是均质的，且横截面和力是恒定的，所以应变 $\\epsilon$ 也是恒定的。因此积分简化为：\n$$ \\delta_{\\mathrm{bar}} = \\epsilon L $$\n代入 $\\epsilon$ 的表达式，我们得到桩压缩量的最终公式：\n$$ \\delta_{\\mathrm{bar}} = \\frac{P L}{A E_{\\mathrm{p}}} $$\n\n接下来，我们推导桩端土体沉降量 $\\delta_{\\mathrm{tip}}$ 的表达式。\n问题陈述土体是均质、各向同性、线性弹性的半空间。桩端被建模为半径为 $a$ 的刚性、平面、圆形压头，它将荷载 $P$ 施加到土体表面。接触被认为是无摩擦的。刚性圆形压头在弹性半空间上的沉降是弹性理论中的一个经典解，该解源于 Boussinesq 的点荷载解。虽然从弹性力学的控制微分方程（Navier-Cauchy 方程）进行完整推导非常繁琐，但其既定结果是针对此特定边值问题的基本原理。压头下方的均匀竖向位移（沉降）$\\delta_{\\mathrm{tip}}$ 由以下公认的公式给出：\n$$ \\delta_{\\mathrm{tip}} = \\frac{P (1 - \\nu_{\\mathrm{s}}^2)}{2 a E_{\\mathrm{s}}} $$\n其中 $P$ 是由桩端传递的总荷载，$a$ 是圆形桩端的半径，$E_{\\mathrm{s}}$ 和 $\\nu_{\\mathrm{s}}$ 分别是弹性半空间（土体）的杨氏模量和泊松比。问题还提供了土体剪切模量的定义，$G_{\\mathrm{s}} = \\dfrac{E_{\\mathrm{s}}}{2\\left(1+\\nu_{\\mathrm{s}}\\right)}$，这允许使用另一种表达式。通过将 $E_{\\mathrm{s}} = 2 G_{\\mathrm{s}} (1+\\nu_{\\mathrm{s}})$ 代入沉降公式，我们可以验证其等价性：\n$$ \\delta_{\\mathrm{tip}} = \\frac{P (1 - \\nu_{\\mathrm{s}})(1 + \\nu_{\\mathrm{s}})}{2 a \\cdot 2G_{\\mathrm{s}}(1+\\nu_{\\mathrm{s}})} = \\frac{P(1-\\nu_{\\mathrm{s}})}{4 a G_{\\mathrm{s}}} $$\n在计算中，使用 $E_{\\mathrm{s}}$ 和 $\\nu_{\\mathrm{s}}$ 的公式更为直接，因为这些是测试套件中提供的参数。\n\n最后，桩头总沉降 $s$ 是桩的结构压缩量和桩端土体变形的线性叠加：\n$$ s = \\delta_{\\mathrm{bar}} + \\delta_{\\mathrm{tip}} = \\frac{P L}{A E_{\\mathrm{p}}} + \\frac{P (1 - \\nu_{\\mathrm{s}}^2)}{2 a E_{\\mathrm{s}}} $$\n该方程综合了模型的两个部分，并将被用于计算每个给定测试用例的总沉降。所有参数均以一致的国际单位制（SI）单位提供，确保最终的沉降 $s$ 以米为单位。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the total settlement of an axially loaded pile based on a composite model.\n\n    The total settlement is the sum of the pile's elastic compression and the tip \n    settlement on an elastic half-space.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each tuple is ordered as (P, L, A, E_p, a, E_s, nu_s) with SI units.\n    # P: Pile axial load (N)\n    # L: Pile length (m)\n    # A: Pile cross-sectional area (m^2)\n    # E_p: Pile Young's modulus (Pa)\n    # a: Pile tip radius (m)\n    # E_s: Soil Young's modulus (Pa)\n    # nu_s: Soil Poisson's ratio (dimensionless)\n    test_cases = [\n        (2.0e6, 12.0, 0.25, 3.0e10, 0.40, 1.0e8, 0.30),\n        (2.0e6, 12.0, 0.25, 2.0e11, 0.40, 1.0e8, 0.30),\n        (3.0e6, 20.0, 0.25, 3.0e10, 0.75, 1.5e8, 0.35),\n        (2.0e6, 12.0, 0.25, 3.0e10, 0.40, 1.0e9, 0.49),\n        (2.0e6, 80.0, 0.25, 3.0e10, 0.40, 1.0e8, 0.30)\n    ]\n\n    results = []\n    for case in test_cases:\n        P, L, A, E_p, a, E_s, nu_s = case\n        \n        # 1. Compute axial bar elongation (compression)\n        # Formula: delta_bar = (P * L) / (A * E_p)\n        delta_bar = (P * L) / (A * E_p)\n        \n        # 2. Compute tip compression (settlement)\n        # Formula: delta_tip = (P * (1 - nu_s^2)) / (2 * a * E_s)\n        delta_tip = (P * (1 - nu_s**2)) / (2 * a * E_s)\n        \n        # 3. Compute total pile head settlement\n        # Formula: s = delta_bar + delta_tip\n        total_settlement = delta_bar + delta_tip\n        \n        results.append(total_settlement)\n\n    # Final print statement in the exact required format.\n    # The output is a comma-separated list of floating-point numbers in a string.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "桩筏基础是一种先进的系统，它结合了浅基础和深基础的优点。本练习基于平衡和变形协调条件，使用系统刚度法来模拟筏、桩和土之间的复杂相互作用。解决这个问题将使您掌握一种分析混合基础系统中荷载分布的方法，并理解相互作用效应的重要性。",
            "id": "3499751",
            "problem": "一个刚性桩筏基础被理想化为一个单竖向自由度系统，其中刚性筏板与一组嵌入弹性地基的竖向桩头弹簧并联。筏板下方的地基由连续的、线弹性反力来表示，其特征为分布式的地基反力模量。桩群由一个对称的相互作用刚度矩阵表示，该矩阵捕捉了单桩的轴向桩头刚度以及通过周围土壤在桩头之间发生的弹性相互作用。假设应变很小，材料为线弹性，且处于准静态条件下。筏板的抗弯刚度足够大，其竖向位移在空间上是均匀的。\n\n从以下基本依据出发：(i) 线性动量平衡（静力平衡），即反力之和等于施加的荷载；(ii) 刚性筏板的运动学协调条件，即所有桩头和筏板经历相同的竖向位移；以及 (iii) 弹簧的线弹性本构关系，推导一个计算程序，用于确定均匀沉降以及在筏板-土接触面和桩群之间的荷载分布。\n\n需使用的模型定义：\n- 筏板-土接触面被建模为一个分布式的线性弹簧，单位面积的地基反力模量为 $k_s$（单位：$\\mathrm{MN/m^3}$）。对于一个平面面积为 $A$（单位：$\\mathrm{m^2}$）的筏板，等效的筏板-土竖向刚度为 $K_r = k_s \\times 10^6 \\times A$（单位：$\\mathrm{N/m}$）。\n- 由 $n$ 根桩组成的桩群由一个对称的相互作用刚度矩阵 $K_p \\in \\mathbb{R}^{n \\times n}$（单位：$\\mathrm{GN/m}$）建模；通过乘以 $10^9$ 将每个条目转换为 $\\mathrm{N/m}$。对角线元素代表独立的单桩桩头轴向刚度，非对角线元素代表成对的相互作用项。\n- 总施加的竖向荷载为 $Q$（单位：$\\mathrm{kN}$）；通过乘以 $10^3$ 转换为 $\\mathrm{N}$。\n- 每根桩 $i$ 的容许承载力为 $C_i$（单位：$\\mathrm{kN}$）。\n\n您的程序必须：\n- 仅使用平衡和协调条件来获得均匀沉降 $u$（单位：$\\mathrm{m}$）、筏板反力 $Q_r$（单位：$\\mathrm{N}$）和桩荷载向量 $\\mathbf{q}$（单位：$\\mathrm{N}$）的表达式。\n- 对每个测试案例，转换并报告以下内容：沉降（单位：$\\mathrm{mm}$，保留三位小数），筏板分担的荷载（单位：$\\mathrm{kN}$，保留两位小数），桩荷载列表（单位：$\\mathrm{kN}$，保留两位小数），以及一个布尔值，指示所有桩是否满足 $q_i \\le C_i$（对 $q_i$ 和 $C_i$ 使用相同单位 $\\mathrm{kN}$ 进行比较）。如果没有桩，则将桩荷载列表视为空列表，布尔值视为真。\n- 使用指定的转换确保内部单位的一致性。\n\n角度单位不适用。请用指定的单位表示所有要求的物理量。\n\n测试套件（每个案例都是独立的）。对于每个案例，输入按 $(Q,\\;A,\\;k_s,\\;K_p,\\;\\{C_i\\})$ 的形式提供，单位已如上文指定：\n- 案例1（正常路径，中等相互作用，四根桩）：\n  - $Q = 60000$\n  - $A = 400$\n  - $k_s = 30$\n  - $K_p$（单位：$\\mathrm{GN/m}$）：\n    - $4 \\times 4$ 矩阵，对角线元素为 $0.8$，非对角线元素为 $0.16$\n  - 承载力 $\\{C_i\\}$（单位：$\\mathrm{kN}$）：$\\{6000, 6000, 6000, 6000\\}$\n- 案例2（边界情况，无桩）：\n  - $Q = 20000$\n  - $A = 300$\n  - $k_s = 15$\n  - $K_p$：空（无桩）\n  - 承载力：空\n- 案例3（非均质桩群和桩承担主要荷载）：\n  - $Q = 50000$\n  - $A = 200$\n  - $k_s = 5$\n  - $K_p$（单位：$\\mathrm{GN/m}$）：\n    - $\n      \\begin{bmatrix}\n      1.5  0.25  0.15 \\\\\n      0.25  1.2  0.20 \\\\\n      0.15  0.20  0.9\n      \\end{bmatrix}\n      $\n  - 承载力 $\\{C_i\\}$（单位：$\\mathrm{kN}$）：$\\{17000, 14000, 9500\\}$\n- 案例4（强相互作用，两根桩）：\n  - $Q = 10000$\n  - $A = 250$\n  - $k_s = 10$\n  - $K_p$（单位：$\\mathrm{GN/m}$）：\n    - $\n      \\begin{bmatrix}\n      0.6  0.54 \\\\\n      0.54  0.6\n      \\end{bmatrix}\n      $\n  - 承载力 $\\{C_i\\}$（单位：$\\mathrm{kN}$）：$\\{2500, 2500\\}$\n\n最终输出格式要求：\n- 您的程序应生成单行输出，其中包含所有测试案例的结果，形式为一个用方括号括起来的逗号分隔列表。每个测试案例的结果本身必须是一个形如 $[u_{\\mathrm{mm}},\\;Q_{r,\\mathrm{kN}},\\;[q_{1,\\mathrm{kN}},\\dots,q_{n,\\mathrm{kN}}],\\;\\text{safe}]$ 的列表，其中 $u_{\\mathrm{mm}}$ 是沉降（单位：mm），$Q_{r,\\mathrm{kN}}$ 是筏板荷载（单位：kN），内部列表包含桩荷载（单位：kN），$\\text{safe}$ 是布尔值安全指示符。例如，总体输出必须类似于 $[[\\cdot,\\cdot,[\\cdot],\\cdot],[\\cdot,\\cdot,[\\cdot],\\cdot],\\dots]$，不含任何附加文本。",
            "solution": "经评估，用户提供的问题是**有效**的。该问题在科学上是合理的、适定的、客观的，并包含了获得唯一解所需的所有必要信息。该问题是计算岩土力学中的一个标准练习，特别是关于桩筏基础的线性弹性分析。我们现在将进行解的正式推导，然后执行计算程序的实现。\n\n推导基于指定的三个基本原则：(i) 静力平衡，(ii) 运动学协调，以及 (iii) 线性弹性本构关系。在推导过程中，所有量均以国际单位制（牛顿，米）表示。\n\n设 $u$ 为刚性筏板的均匀竖向沉降，单位为米 [$\\mathrm{m}$]。\n设 $Q$ 为总施加的竖向荷载，单位为牛顿 [$\\mathrm{N}$]。\n设 $A$ 为筏板平面面积，单位为平方米 [$\\mathrm{m}^2$]。\n设 $k_s$ 为地基反力模量，单位为帕斯卡每米 [$\\mathrm{N/m^3}$]。\n设 $K_r$ 为筏板-土接触面的等效竖向刚度，单位为牛顿每米 [$\\mathrm{N/m}$]。\n设 $n$ 为桩的数量。对于 $n>0$，设 $K_p \\in \\mathbb{R}^{n \\times n}$ 为桩群相互作用刚度矩阵，单位为牛顿每米 [$\\mathrm{N/m}$]。\n\n问题是要求解沉降 $u$、筏板-土接触面承载的荷载 $Q_r$ 以及桩的荷载向量 $\\mathbf{q} = [q_1, q_2, \\dots, q_n]^T$。\n\n**1. 运动学协调**\n问题陈述筏板是刚性的，并发生均匀的竖向位移 $u$。由于桩与筏板相连，所有桩头必须经历相同的沉降。设 $\\mathbf{u}_p$ 为桩头位移向量。\n则，\n$$ \\mathbf{u}_p = \\begin{bmatrix} u \\\\ u \\\\ \\vdots \\\\ u \\end{bmatrix} = u \\cdot \\mathbf{1} $$\n其中 $\\mathbf{1}$ 是一个大小为 $n$ 的列向量，所有元素均为 $1$。\n\n**2. 本构关系**\n系统组件被建模为线性弹性弹簧。\n- **筏板-土接触**：来自筏板下方土壤的反作用力 $Q_r$ 与沉降 $u$ 成正比。\n  根据问题定义，等效的筏板-土刚度为 $K_r = k_s \\cdot A$。本构定律为：\n  $$ Q_r = K_r \\cdot u $$\n\n- **桩群**：桩头力向量 $\\mathbf{q}$ 通过桩群刚度矩阵 $K_p$ 与桩头位移向量 $\\mathbf{u}_p$ 相关联。\n  $$ \\mathbf{q} = K_p \\mathbf{u}_p $$\n  将协调条件 $\\mathbf{u}_p = u \\cdot \\mathbf{1}$ 代入此关系式中，得到：\n  $$ \\mathbf{q} = K_p (u \\cdot \\mathbf{1}) = u (K_p \\mathbf{1}) $$\n  该方程给出了每根桩 $i$ 上的荷载 $q_i$ 作为未知沉降 $u$ 的函数。项 $K_p \\mathbf{1}$ 是一个向量，其第 $i$ 个元素是 $K_p$ 矩阵第 $i$ 行中所有刚度系数的总和，即 $\\sum_{j=1}^{n} K_{p,ij}$。\n\n整个桩群承载的总荷载 $Q_p$ 是各个桩荷载的总和：\n$$ Q_p = \\sum_{i=1}^{n} q_i = \\mathbf{1}^T \\mathbf{q} $$\n代入 $\\mathbf{q}$ 的表达式：\n$$ Q_p = \\mathbf{1}^T (u K_p \\mathbf{1}) = u (\\mathbf{1}^T K_p \\mathbf{1}) $$\n标量 $K_{p,group} = \\mathbf{1}^T K_p \\mathbf{1} = \\sum_{i=1}^{n} \\sum_{j=1}^{n} K_{p,ij}$ 代表了桩群在受到均匀位移时，其整体刚度。它通过对矩阵 $K_p$ 的所有元素求和来计算。因此，桩群的总荷载为：\n$$ Q_p = K_{p,group} \\cdot u $$\n如果没有桩 ($n=0$)，则 $K_{p,group}=0$ 且 $Q_p=0$。\n\n**3. 静力平衡**\n为了使桩筏系统处于静力平衡状态，总施加荷载 $Q$ 必须由地基所有向上反力的总和来平衡。这些反力是筏板-土接触力 $Q_r$ 和桩群总作用力 $Q_p$。\n$$ Q = Q_r + Q_p $$\n将 $Q_r$ 和 $Q_p$ 的本构关系代入平衡方程：\n$$ Q = (K_r \\cdot u) + (K_{p,group} \\cdot u) $$\n提取公因子沉降 $u$：\n$$ Q = (K_r + K_{p,group}) \\cdot u $$\n这是该单自由度系统的控制方程。项 $K_{total} = K_r + K_{p,group}$ 是桩筏基础的总刚度。\n\n**4. 计算算法**\n基于上述推导，计算步骤如下：\n\n- **步骤1：单位转换和刚度计算。**\n  - 将所有输入参数转换为国际单位制（N, m）。\n    - $Q\\;[\\mathrm{N}] = Q\\;[\\mathrm{kN}] \\times 10^3$\n    - $k_s\\;[\\mathrm{N/m^3}] = k_s\\;[\\mathrm{MN/m^3}] \\times 10^6$\n    - $K_p\\;[\\mathrm{N/m}] = K_p\\;[\\mathrm{GN/m}] \\times 10^9$\n  - 计算筏板刚度：$K_r = k_s \\cdot A$。\n  - 计算桩群刚度：如果 $n > 0$，则 $K_{p,group} = \\sum_{i,j} K_{p,ij}$。如果 $n=0$，则 $K_{p,group} = 0$。\n  - 计算系统总刚度：$K_{total} = K_r + K_{p,group}$。\n\n- **步骤2：求解沉降。**\n  - 均匀沉降 $u$ 由控制平衡方程计算得出：\n    $$ u = \\frac{Q}{K_{total}} $$\n\n- **步骤3：确定荷载分布。**\n  - 筏板-土接触荷载：$Q_r = K_r \\cdot u$。\n  - 桩荷载：如果 $n > 0$，则桩荷载向量 $\\mathbf{q}$ 计算为 $\\mathbf{q} = u (K_p \\mathbf{1})$。如果 $n=0$，则桩荷载向量为空。\n\n- **步骤4：进行安全性校核。**\n  - 对每根桩 $i$，将其计算出的荷载 $q_i$ 与其容许承载力 $C_i$ 进行比较。注意，两者必须使用相同的单位（例如，$\\mathrm{kN}$）才能进行有效比较。\n  - 如果对所有桩都满足 $q_i \\le C_i$，则认为基础是“安全的”。对于没有桩的基础，此条件自然成立。\n\n- **步骤5：格式化输出。**\n  - 将计算出的沉降 $u$ 转换为毫米（$u \\times 1000$），筏板荷载 $Q_r$ 转换为千牛（$Q_r / 1000$），桩荷载 $q_i$ 转换为千牛（$q_i / 1000$）。\n  - 将数值四舍五入到指定的小数位数。\n  - 将结果组装成所需的列表格式。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final output.\n    \"\"\"\n    \n    # Test suite definition\n    test_cases = [\n        # Case 1: (Q, A, k_s, K_p, {C_i})\n        (60000, 400, 30, \n         [[0.8, 0.16, 0.16, 0.16], \n          [0.16, 0.8, 0.16, 0.16], \n          [0.16, 0.16, 0.8, 0.16], \n          [0.16, 0.16, 0.16, 0.8]], \n         [6000, 6000, 6000, 6000]),\n        # Case 2: No piles\n        (20000, 300, 15, [], []),\n        # Case 3: Heterogeneous group\n        (50000, 200, 5, \n         [[1.5, 0.25, 0.15], \n          [0.25, 1.2, 0.20], \n          [0.15, 0.20, 0.9]], \n         [17000, 14000, 9500]),\n        # Case 4: High interaction\n        (10000, 250, 10, \n         [[0.6, 0.54], \n          [0.54, 0.6]], \n         [2500, 2500])\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_case(*case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The str() representation of a list of lists is the desired format.\n    print(f\"{results}\".replace(\"'\", \"\").replace(\" \", \"\"))\n\ndef calculate_case(Q_kN, A_m2, ks_MN_m3, Kp_GN_m, C_kN):\n    \"\"\"\n    Calculates settlement and load distribution for a single piled raft case.\n\n    Args:\n        Q_kN (float): Total applied load in kN.\n        A_m2 (float): Raft plan area in m^2.\n        ks_MN_m3 (float): Subgrade modulus in MN/m^3.\n        Kp_GN_m (list of lists): Pile group stiffness matrix in GN/m.\n        C_kN (list of float): Pile capacities in kN.\n\n    Returns:\n        list: [settlement_mm, raft_load_kN, pile_loads_kN_list, is_safe_boolean]\n    \"\"\"\n    # Unit conversions to base SI units (N, m)\n    Q_N = Q_kN * 1e3\n    ks_N_m3 = ks_MN_m3 * 1e6\n\n    # Step 1: Calculate Stiffnesses\n    # Raft-soil contact stiffness\n    Kr_N_m = ks_N_m3 * A_m2\n\n    # Pile group stiffness\n    if not Kp_GN_m:\n        n_piles = 0\n        Kp_group_N_m = 0.0\n        Kp_N_m = np.array([])\n    else:\n        Kp_GN_m_np = np.array(Kp_GN_m)\n        n_piles = Kp_GN_m_np.shape[0]\n        Kp_N_m = Kp_GN_m_np * 1e9\n        # Equivalent group stiffness is the sum of all elements in the matrix\n        Kp_group_N_m = np.sum(Kp_N_m)\n    \n    # Total system stiffness\n    K_total_N_m = Kr_N_m + Kp_group_N_m\n\n    # Step 2: Calculate Settlement\n    # Safeguard against non-positive stiffness, though physically not expected\n    if K_total_N_m == 0:\n        return [0.0, 0.0, [], False]\n\n    u_m = Q_N / K_total_N_m\n    u_mm = u_m * 1e3\n\n    # Step 3: Determine Load Distribution\n    # Raft-soil contact load\n    Qr_N = Kr_N_m * u_m\n    Qr_kN = Qr_N / 1e3\n\n    # Pile loads\n    q_kN_list = []\n    is_safe = True\n    if n_piles > 0:\n        # q = u * (K_p * 1), where K_p*1 is a vector of row sums\n        row_sums_N_m = np.sum(Kp_N_m, axis=1)\n        q_N_vector = u_m * row_sums_N_m\n        q_kN_vector = q_N_vector / 1e3\n        \n        q_kN_list = [round(q, 2) for q in q_kN_vector]\n        \n        # Step 4: Perform Safety Check\n        C_kN_np = np.array(C_kN)\n        # Using a small tolerance for floating point comparisons\n        is_safe = np.all(q_kN_vector = C_kN_np + 1e-9)\n    else: # n_piles == 0\n        is_safe = True\n        q_kN_list = []\n\n    # Step 5: Format Output\n    u_mm_rounded = round(u_mm, 3)\n    Qr_kN_rounded = round(Qr_kN, 2)\n    \n    return [u_mm_rounded, Qr_kN_rounded, q_kN_list, bool(is_safe)]\n\n\nsolve()\n```"
        },
        {
            "introduction": "深基础的精确数值模拟依赖于对桩土界面的真实本构模拟。本练习要求您实现一个经典的、包含库仑摩擦的弹塑性接触模型，这是计算接触力学的基石。通过编写本构积分和一致切线刚度的代码，您将掌握岩土工程非线性有限元分析中使用的核心技术。",
            "id": "3499747",
            "problem": "您的任务是为一个代表桩与周围土体相互作用的二维界面模型，实现其本构积分和一致切线算子。界面运动学被理想化为桩表面与相邻土体之间的位移跳跃矢量 $\\boldsymbol{w} = [w_n, w_t]^T$，该矢量分解为法向分量 $w_n$ 和切向分量 $w_t$。相应的牵引力矢量为 $\\boldsymbol{t} = [t_n, t_t]^T$，其中 $t_n$ 为法向牵引力（压为正），$t_t$ 为切向牵引力。在法向和切向方向上使用罚函数正则化，其弹性刚度分别为 $k_n^e$ 和 $k_t^e$，并在受压状态下考虑带有黏聚力参数 $c$ 的库仑摩擦。张开（受拉）接触不传递牵引力。\n\n从以下基本原理和定义出发：\n- 界面在法向实施单边接触，在切向实施库仑摩擦。这通过一个抵抗相互贯入并在受拉时消失的法向牵引力 $t_n$，以及一个在受压时受摩擦界限限制的切向牵引力 $t_t$ 来建模。\n- 弹性试探状态源于罚弹性理论：$t_n^{\\text{trial}} = -k_n^e w_n$ 和 $t_t^{\\text{trial}} = k_t^e w_t$。\n- 接触张开法则：对于 $w_n \\ge 0$（张开，受拉），界面不传递牵引力，即 $t_n = 0$ 和 $t_t = 0$。\n- 接触压缩法则：对于 $w_n  0$，法向牵引力是压缩性的，由 $t_n = -k_n^e w_n  0$ 给出。\n- 受压下的带黏聚力的摩擦极限：当 $w_n  0$ 时，容许的切向牵引力受限于 $|t_t| \\le \\mu t_n + c$，其中 $\\mu$ 是摩擦系数，$c$ 是黏聚力。如果 $|t_t^{\\text{trial}}| \\le \\mu t_n + c$，切向响应为弹性黏滞；如果 $|t_t^{\\text{trial}}|  \\mu t_n + c$，则发生滑移，更新后的切向牵引力为 $t_t = \\operatorname{sign}(t_t^{\\text{trial}})\\,(\\mu t_n + c)$。\n\n您的程序必须：\n1. 实现本构积分，通过应用所述的弹性预测、接触张开法则和受压下的摩擦返回映射，将给定的位移跳跃 $\\boldsymbol{w}$ 映射到界面牵引力 $\\boldsymbol{t}$。\n2. 计算一致算法切线矩阵 $\\boldsymbol{K} = \\partial \\boldsymbol{t} / \\partial \\boldsymbol{w}$，这是一个 $2 \\times 2$ 的矩阵，其分量为 $K_{nn} = \\partial t_n / \\partial w_n$，$K_{nt} = \\partial t_n / \\partial w_t$，$K_{tn} = \\partial t_t / \\partial w_n$ 和 $K_{tt} = \\partial t_t / \\partial w_t$，由相同的本构模型导出。在张开状态下（$w_n \\ge 0$），设置 $\\boldsymbol{K} = \\boldsymbol{0}$。在压缩状态下（$w_n  0$），对于弹性黏滞，设置 $K_{nn} = -k_n^e$，$K_{tt} = k_t^e$，$K_{nt} = K_{tn} = 0$。对于滑移状态，设置 $K_{nn} = -k_n^e$，$K_{tt} = 0$，$K_{nt} = 0$，$K_{tn} = \\operatorname{sign}(w_t)\\,\\mu\\,(-k_n^e)$。\n\n物理单位和输出要求：\n- 刚度 $k_n^e$ 和 $k_t^e$ 的单位是 $\\text{Pa}/\\text{m}$。\n- 摩擦系数 $\\mu$ 是无量纲的，黏聚力 $c$ 的单位是 $\\text{Pa}$。\n- 位移跳跃 $w_n$ 和 $w_t$ 的单位是 $\\text{m}$。\n- $t_n$ 和 $t_t$ 以 $\\text{Pa}$ 表示，切线矩阵的各项以 $\\text{Pa}/\\text{m}$ 表示。\n\n您的程序应处理以下参数集和位移跳跃的测试套件，其中材料参数固定为 $k_n^e = 10^9\\,\\text{Pa}/\\text{m}$，$k_t^e = 5 \\times 10^8\\,\\text{Pa}/\\text{m}$，$\\mu = 0.4$，$c = 5 \\times 10^4\\,\\text{Pa}$：\n- 测试用例 1 (压缩，黏滞): $w_n = -1\\times 10^{-4}\\,\\text{m}$, $w_t = 1\\times 10^{-4}\\,\\text{m}$。\n- 测试用例 2 (压缩，滑移): $w_n = -1\\times 10^{-4}\\,\\text{m}$, $w_t = 3\\times 10^{-4}\\,\\text{m}$。\n- 测试用例 3 (张开，无牵引力): $w_n = +1\\times 10^{-4}\\,\\text{m}$, $w_t = 2\\times 10^{-4}\\,\\text{m}$。\n- 测试用例 4 (压缩，负切向跳跃下滑移): $w_n = -2\\times 10^{-4}\\,\\text{m}$, $w_t = -1\\times 10^{-3}\\,\\text{m}$。\n- 测试用例 5 (摩擦极限边界情况，视为黏滞): $w_n = -1\\times 10^{-4}\\,\\text{m}$, $w_t = 1.8\\times 10^{-4}\\,\\text{m}$。\n\n对于每个测试用例，计算以指定单位表示的列表 $[t_n, t_t, K_{nn}, K_{nt}, K_{tn}, K_{tt}]$。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，该列表包含所有结果。其中每个元素对应一个测试用例，本身也是一个使用 Python 列表表示法的 $[t_n, t_t, K_{nn}, K_{nt}, K_{tn}, K_{tt}]$ 形式的列表。所有数值输出必须是浮点数。",
            "solution": "该问题要求为一个二维桩-土界面模型实现一个本构积分算法。该算法必须针对给定的位移跳跃矢量 $\\boldsymbol{w} = [w_n, w_t]^T$，计算界面牵引力矢量 $\\boldsymbol{t} = [t_n, t_t]^T$ 和相应的一致算法切线矩阵 $\\boldsymbol{K} = \\partial \\boldsymbol{t} / \\partial \\boldsymbol{w}$。该模型在法向包含单边接触，在切向包含带黏聚力的库仑摩擦。\n\n该算法通过分析基于法向位移跳跃 $w_n$ 的接触状态来运行。其逻辑分为两个主要情况：接触张开（$w_n \\ge 0$）和接触压缩（$w_n  0$）。\n\n**情况1：接触张开 ($w_n \\ge 0$)**\n\n根据指定的张开法则，处于受拉状态（$w_n  0$）或法向位移为零（$w_n = 0$）的界面不能承受任何牵引力。\n\n- **牵引力更新**：法向和切向牵引力均为零。\n$$\nt_n = 0\n$$\n$$\nt_t = 0\n$$\n- **一致切线更新**：由于在此整个状态下牵引力是常数（零），它们相对于位移跳跃的导数也为零。一致切线矩阵是零矩阵。\n$$\n\\boldsymbol{K} = \\frac{\\partial \\boldsymbol{t}}{\\partial \\boldsymbol{w}} = \\begin{pmatrix} 0  0 \\\\ 0  0 \\end{pmatrix}\n$$\n\n**情况2：接触压缩 ($w_n  0$)**\n\n当界面处于压缩状态时，会激活一个更复杂的弹塑性框架。该过程遵循标准的预测-校正方案。\n\n**步骤2.1：弹性预测（试探状态）**\n\n首先，我们假设一个纯弹性响应来计算试探状态。\n- **法向牵引力**：法向牵引力是压缩性的，由罚刚度 $k_n^e$ 决定。压缩为正和相互贯入的 $w_n$ 为负的符号约定导致：\n$$\nt_n = -k_n^e w_n\n$$\n注意，由于 $w_n  0$ 和 $k_n^e  0$，法向牵引力 $t_n$ 为正，这与压缩的定义一致。该关系在受压状态下的黏滞和滑移情况下都成立。\n\n- **试探切向牵引力**：试探切向牵引力使用切向罚刚度 $k_t^e$ 进行弹性计算：\n$$\nt_t^{\\text{trial}} = k_t^e w_t\n$$\n\n**步骤2.2：摩擦屈服检查**\n\n必须根据摩擦准则检查试探切向牵引力。切向牵引力的最大容许量值由带黏聚力的库仑摩擦定律定义，该定律取决于当前的法向牵引力 $t_n$：\n$$\n\\Phi_{\\text{limit}} = \\mu t_n + c\n$$\n保持在弹性（黏滞）状态的条件是：\n$$\n|t_t^{\\text{trial}}| \\le \\Phi_{\\text{limit}}\n$$\n如果这个不等式被违反，就会发生塑性滑移（滑动）。\n\n**步骤2.3：状态确定和更新**\n\n根据屈服检查，确定最终的牵引力和一致切线。\n\n**子情况2.3.a：弹性黏滞 ($|t_t^{\\text{trial}}| \\le \\Phi_{\\text{limit}}$)**\n\n试探状态是容许的。响应是弹性的。\n\n- **牵引力更新**：最终的切向牵引力等于其试探值。\n$$\nt_t = t_t^{\\text{trial}} = k_t^e w_t\n$$\n- **一致切线更新**：通过对弹性本构关系 $t_n = -k_n^e w_n$ 和 $t_t = k_t^e w_t$ 求导来导出切线矩阵。响应是解耦的。\n$$\nK_{nn} = \\frac{\\partial t_n}{\\partial w_n} = -k_n^e\n$$\n$$\nK_{nt} = \\frac{\\partial t_n}{\\partial w_t} = 0\n$$\n$$\nK_{tn} = \\frac{\\partial t_t}{\\partial w_n} = 0\n$$\n$$\nK_{tt} = \\frac{\\partial t_t}{\\partial w_t} = k_t^e\n$$\n切线矩阵是对角的：$\\boldsymbol{K}^{\\text{stick}} = \\begin{pmatrix} -k_n^e  0 \\\\ 0  k_t^e \\end{pmatrix}$。\n\n**子情况2.3.b：滑移 ($|t_t^{\\text{trial}}|  \\Phi_{\\text{limit}}$)**\n\n试探状态是不可容许的。应用塑性校正器（或返回映射）来强制满足屈服条件。\n\n- **牵引力更新**：将切向牵引力返回到屈服面上，同时保持试探步的方向。\n$$\nt_t = \\operatorname{sign}(t_t^{\\text{trial}}) \\Phi_{\\text{limit}} = \\operatorname{sign}(k_t^e w_t) (\\mu t_n + c)\n$$\n由于 $k_t^e  0$，这可简化为：\n$$\nt_t = \\operatorname{sign}(w_t) (\\mu (-k_n^e w_n) + c)\n$$\n- **一致切线更新**：切线矩阵从滑移状态的激活本构关系导出。出现了一个非零的非对角项 $K_{tn}$，表明存在耦合。\n$$\nK_{nn} = \\frac{\\partial t_n}{\\partial w_n} = -k_n^e\n$$\n$$\nK_{nt} = \\frac{\\partial t_n}{\\partial w_t} = 0\n$$\n$$\nK_{tn} = \\frac{\\partial t_t}{\\partial w_n} = \\frac{\\partial}{\\partial w_n} \\left[ \\operatorname{sign}(w_t) (\\mu (-k_n^e w_n) + c) \\right] = \\operatorname{sign}(w_t) \\mu (-k_n^e)\n$$\n$$\nK_{tt} = \\frac{\\partial t_t}{\\partial w_t} = \\frac{\\partial}{\\partial w_t} \\left[ \\operatorname{sign}(w_t) (\\mu (-k_n^e w_n) + c) \\right] = 0\n$$\n对于 $w_t \\ne 0$，$\\operatorname{sign}(w_t)$ 的导数为零。切线矩阵是非对称的：$\\boldsymbol{K}^{\\text{slide}} = \\begin{pmatrix} -k_n^e  0 \\\\ \\operatorname{sign}(w_t) \\mu (-k_n^e)  0 \\end{pmatrix}$。\n\n该实现将把此逻辑应用于每个测试用例，使用提供的材料参数，为每个用例计算列表 $[t_n, t_t, K_{nn}, K_{nt}, K_{tn}, K_{tt}]$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_interface_response(wn: float, wt: float, kn_e: float, kt_e: float, mu: float, c: float) -> list[float]:\n    \"\"\"\n    Computes the interface traction and consistent tangent matrix for a given displacement jump.\n\n    Args:\n        wn: Normal displacement jump (m).\n        wt: Tangential displacement jump (m).\n        kn_e: Normal elastic stiffness (Pa/m).\n        kt_e: Tangential elastic stiffness (Pa/m).\n        mu: Friction coefficient (dimensionless).\n        c: Cohesion (Pa).\n\n    Returns:\n        A list containing [tn, tt, Knn, Knt, Ktn, Ktt].\n    \"\"\"\n    tn, tt = 0.0, 0.0\n    Knn, Knt, Ktn, Ktt = 0.0, 0.0, 0.0, 0.0\n\n    # Case 1: Contact Opening (wn >= 0)\n    if wn >= 0:\n        # Tractions and tangent matrix are zero.\n        # Initial values are already correct.\n        pass\n    # Case 2: Contact Compression (wn  0)\n    else:\n        # Normal traction (always elastic in compression)\n        tn = -kn_e * wn\n\n        # Trial tangential traction (elastic predictor)\n        tt_trial = kt_e * wt\n\n        # Frictional limit\n        phi_limit = mu * tn + c\n\n        # Check for sticking vs. sliding\n        if abs(tt_trial) = phi_limit:\n            # Sub-case 2.3.a: Elastic-Sticking\n            tt = tt_trial\n            Knn = -kn_e\n            Ktt = kt_e\n            # Knt and Ktn remain 0.0\n        else:\n            # Sub-case 2.3.b: Sliding (return mapping)\n            sign_wt = np.sign(wt)\n            tt = sign_wt * phi_limit\n            \n            Knn = -kn_e\n            Ktn = sign_wt * mu * (-kn_e)\n            # Knt and Ktt remain 0.0\n\n    return [tn, tt, Knn, Knt, Ktn, Ktt]\n\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n    # Fixed material parameters\n    kn_e = 1e9    # Pa/m\n    kt_e = 5e8    # Pa/m\n    mu = 0.4      # dimensionless\n    c = 5e4       # Pa\n\n    # Test suite: list of tuples (wn, wt) in meters\n    test_cases = [\n        # Test case 1 (compression, sticking)\n        (-1e-4, 1e-4),\n        # Test case 2 (compression, sliding)\n        (-1e-4, 3e-4),\n        # Test case 3 (opening, no traction)\n        (1e-4, 2e-4),\n        # Test case 4 (compression, sliding with negative tangential jump)\n        (-2e-4, -1e-3),\n        # Test case 5 (boundary case at friction limit, treat as sticking)\n        (-1e-4, 1.8e-4),\n    ]\n\n    all_results = []\n    for wn, wt in test_cases:\n        result_vector = calculate_interface_response(wn, wt, kn_e, kt_e, mu, c)\n        # Convert the list to its string representation for the final output format\n        all_results.append(str(result_vector))\n\n    # The final print must be a single line containing a list of lists.\n    # Joining the string representations of each list achieves this.\n    print(f\"[{','.join(all_results)}]\")\n\n\nsolve()\n```"
        }
    ]
}