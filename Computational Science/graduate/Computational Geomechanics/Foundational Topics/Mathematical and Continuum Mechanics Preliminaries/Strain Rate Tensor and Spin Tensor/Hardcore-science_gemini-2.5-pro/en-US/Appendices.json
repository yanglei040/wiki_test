{
    "hands_on_practices": [
        {
            "introduction": "Understanding the motion of a deformable body begins with decomposing its velocity field into pure deformation and pure rigid-body rotation. This exercise provides a foundational workout in applying these core concepts. By starting with a simple, analytical velocity field, you will directly compute the strain rate tensor $D$ and the spin tensor $W$, and use their magnitudes to develop a physical intuition for how these mathematical objects describe whether a material point is primarily stretching or spinning .",
            "id": "3563983",
            "problem": "In small-strain kinematics for plane strain in computational geomechanics, consider a two-dimensional velocity field given by $v(x,y)=\\big(\\kappa\\, y,\\ \\lambda\\, x\\big)$, where $\\kappa$ and $\\lambda$ are spatially uniform constants with units of $\\mathrm{s}^{-1}$. Starting from the fundamental definition of the velocity gradient tensor $L$, with components $L_{ij}=\\partial v_{i}/\\partial x_{j}$, derive the strain rate tensor $D$ and the spin tensor $W$ for this motion using the standard kinematic decomposition of $L$ into its symmetric and skew-symmetric parts. Then, using the Frobenius norm defined by $\\|A\\|_{F}=\\sqrt{\\sum_{i,j}A_{ij}^{2}}$, assess whether the motion is dominated by shear (represented by $D$) or by rigid-body rotation (represented by $W$) by comparing $\\|D\\|_{F}$ and $\\|W\\|_{F}$. \n\nReport as your final answer the single scalar ratio $\\|W\\|_{F}/\\|D\\|_{F}$ as a closed-form analytic expression in terms of $\\kappa$ and $\\lambda$. No rounding is required, and the ratio is dimensionless. Provide $D$ and $W$ and the interpretive comparison in your working, but only the scalar ratio is to be reported as the final answer.",
            "solution": "The problem is deemed valid. It is scientifically grounded in the principles of continuum mechanics, specifically small-strain kinematics. The problem is well-posed, objective, and self-contained, providing all necessary definitions and data to derive a unique, meaningful analytical solution. There are no contradictions, ambiguities, or violations of physical laws.\n\nThe given two-dimensional velocity field is $\\vec{v} = (v_1, v_2)$ with components given by:\n$$v_1(x_1, x_2) = \\kappa x_2$$\n$$v_2(x_1, x_2) = \\lambda x_1$$\nwhere we have used the notation $x_1 = x$ and $x_2 = y$. The parameters $\\kappa$ and $\\lambda$ are constants.\n\nThe velocity gradient tensor, $L$, is defined by its components $L_{ij} = \\frac{\\partial v_i}{\\partial x_j}$. We compute the four components of $L$ for this $2D$ flow:\n$$L_{11} = \\frac{\\partial v_1}{\\partial x_1} = \\frac{\\partial (\\kappa x_2)}{\\partial x_1} = 0$$\n$$L_{12} = \\frac{\\partial v_1}{\\partial x_2} = \\frac{\\partial (\\kappa x_2)}{\\partial x_2} = \\kappa$$\n$$L_{21} = \\frac{\\partial v_2}{\\partial x_1} = \\frac{\\partial (\\lambda x_1)}{\\partial x_1} = \\lambda$$\n$$L_{22} = \\frac{\\partial v_2}{\\partial x_2} = \\frac{\\partial (\\lambda x_1)}{\\partial x_2} = 0$$\n\nIn matrix form, the velocity gradient tensor $L$ is:\n$$L = \\begin{pmatrix} 0  \\kappa \\\\ \\lambda  0 \\end{pmatrix}$$\n\nThe velocity gradient tensor can be decomposed into a symmetric part, the strain rate tensor $D$, and a skew-symmetric part, the spin tensor $W$, such that $L = D + W$.\n\nThe strain rate tensor $D$ is given by $D = \\frac{1}{2}(L + L^T)$. First, we find the transpose of $L$, denoted $L^T$:\n$$L^T = \\begin{pmatrix} 0  \\lambda \\\\ \\kappa  0 \\end{pmatrix}$$\nNow, we can compute $D$:\n$$D = \\frac{1}{2} \\left[ \\begin{pmatrix} 0  \\kappa \\\\ \\lambda  0 \\end{pmatrix} + \\begin{pmatrix} 0  \\lambda \\\\ \\kappa  0 \\end{pmatrix} \\right] = \\frac{1}{2} \\begin{pmatrix} 0  \\kappa + \\lambda \\\\ \\kappa + \\lambda  0 \\end{pmatrix} = \\begin{pmatrix} 0  \\frac{\\kappa + \\lambda}{2} \\\\ \\frac{\\kappa + \\lambda}{2}  0 \\end{pmatrix}$$\nThe tensor $D$ represents the rate of deformation (straining) of the material element.\n\nThe spin tensor $W$ is given by $W = \\frac{1}{2}(L - L^T)$:\n$$W = \\frac{1}{2} \\left[ \\begin{pmatrix} 0  \\kappa \\\\ \\lambda  0 \\end{pmatrix} - \\begin{pmatrix} 0  \\lambda \\\\ \\kappa  0 \\end{pmatrix} \\right] = \\frac{1}{2} \\begin{pmatrix} 0  \\kappa - \\lambda \\\\ \\lambda - \\kappa  0 \\end{pmatrix} = \\begin{pmatrix} 0  \\frac{\\kappa - \\lambda}{2} \\\\ -\\frac{\\kappa - \\lambda}{2}  0 \\end{pmatrix}$$\nThe tensor $W$ represents the rate of rigid-body rotation (vorticity) of the material element.\n\nNext, we compute the magnitude of these tensors using the Frobenius norm, defined as $\\|A\\|_{F} = \\sqrt{\\sum_{i,j}A_{ij}^2}$.\n\nFor the strain rate tensor $D$:\n$$\\|D\\|_{F} = \\sqrt{D_{11}^2 + D_{12}^2 + D_{21}^2 + D_{22}^2}$$\n$$\\|D\\|_{F} = \\sqrt{0^2 + \\left(\\frac{\\kappa + \\lambda}{2}\\right)^2 + \\left(\\frac{\\kappa + \\lambda}{2}\\right)^2 + 0^2} = \\sqrt{2 \\left(\\frac{\\kappa + \\lambda}{2}\\right)^2} = \\sqrt{\\frac{(\\kappa + \\lambda)^2}{2}}$$\n$$\\|D\\|_{F} = \\frac{|\\kappa + \\lambda|}{\\sqrt{2}}$$\nThis scalar quantity represents the overall intensity of the straining motion.\n\nFor the spin tensor $W$:\n$$\\|W\\|_{F} = \\sqrt{W_{11}^2 + W_{12}^2 + W_{21}^2 + W_{22}^2}$$\n$$\\|W\\|_{F} = \\sqrt{0^2 + \\left(\\frac{\\kappa - \\lambda}{2}\\right)^2 + \\left(-\\frac{\\kappa - \\lambda}{2}\\right)^2 + 0^2} = \\sqrt{2 \\left(\\frac{\\kappa - \\lambda}{2}\\right)^2} = \\sqrt{\\frac{(\\kappa - \\lambda)^2}{2}}$$\n$$\\|W\\|_{F} = \\frac{|\\kappa - \\lambda|}{\\sqrt{2}}$$\nThis scalar quantity represents the overall intensity of the rotational motion.\n\nThe problem asks for an assessment of whether the motion is dominated by shear (deformation) or rigid-body rotation by comparing $\\|D\\|_{F}$ and $\\|W\\|_{F}$.\n- If $\\|D\\|_{F}  \\|W\\|_{F}$, i.e., $|\\kappa + \\lambda|  |\\kappa - \\lambda|$, the motion is dominated by straining. This inequality holds if and only if $\\kappa \\lambda  0$.\n- If $\\|W\\|_{F}  \\|D\\|_{F}$, i.e., $|\\kappa - \\lambda|  |\\kappa + \\lambda|$, the motion is dominated by rotation. This inequality holds if and only if $\\kappa \\lambda  0$.\n- If $\\|W\\|_{F} = \\|D\\|_{F}$, i.e., $|\\kappa - \\lambda| = |\\kappa + \\lambda|$, the straining and rotational components are of equal magnitude. This occurs if $\\kappa \\lambda = 0$, which corresponds to a simple shear flow.\n\nThe final task is to compute the dimensionless scalar ratio $\\frac{\\|W\\|_{F}}{\\|D\\|_{F}}$. This ratio provides a quantitative measure of the dominance of rotation over deformation.\n$$\\frac{\\|W\\|_{F}}{\\|D\\|_{F}} = \\frac{\\frac{|\\kappa - \\lambda|}{\\sqrt{2}}}{\\frac{|\\kappa + \\lambda|}{\\sqrt{2}}} = \\frac{|\\kappa - \\lambda|}{|\\kappa + \\lambda|}$$\nThis can be written more compactly as:\n$$\\frac{\\|W\\|_{F}}{\\|D\\|_{F}} = \\left|\\frac{\\kappa - \\lambda}{\\kappa + \\lambda}\\right|$$\nThis expression is the general solution. It is well-defined provided that the denominator is non-zero, i.e., $\\kappa + \\lambda \\neq 0$. If $\\kappa + \\lambda = 0$ (meaning $\\kappa = -\\lambda \\neq 0$), then $\\|D\\|_{F} = 0$ while $\\|W\\|_{F}  0$, corresponding to a pure rigid-body rotation where the ratio is undefined (infinite).",
            "answer": "$$\\boxed{\\left|\\frac{\\kappa - \\lambda}{\\kappa + \\lambda}\\right|}$$"
        },
        {
            "introduction": "Theoretical concepts become powerful tools when they can be implemented in a computational framework. This practice bridges the gap between continuum theory and the finite element method, a cornerstone of modern geomechanics. You will derive and compute the velocity gradient tensor within a single finite element, using discrete nodal velocities and shape functions, which is exactly how kinematic quantities are calculated in simulation software . This exercise is essential for understanding how the smooth fields of theory are translated into the piecewise approximations of numerical models.",
            "id": "3564019",
            "problem": "In computational geomechanics, constitutive updates frequently require the velocity gradient, the strain rate tensor, and the spin tensor evaluated at quadrature points within a finite element. Starting from first principles, formulate an expression for the velocity gradient at a quadrature point in a finite element that uses continuous displacement and velocity interpolation ($C^{0}$ continuity). Your derivation must begin from the definition of the velocity field and a standard finite element interpolation, and it must proceed by applying appropriate differential operators to obtain the velocity gradient in terms of nodal velocities and shape function gradients. Then, for a specific two-dimensional linear triangular element, compute the discrete velocity gradient at the centroid quadrature point.\n\nElement specification:\n- Nodes at physical coordinates $($node $1)$ $\\left(x_{1},y_{1}\\right)=\\left(0,0\\right)$, $($node $2)$ $\\left(x_{2},y_{2}\\right)=\\left(2,0\\right)$, and $($node $3)$ $\\left(x_{3},y_{3}\\right)=\\left(0,1\\right)$.\n- Nodal velocities in meters per second: $($node $1)$ $\\boldsymbol{v}_{1}=\\left(0.1,-0.05\\right)$, $($node $2)$ $\\boldsymbol{v}_{2}=\\left(0.2,0.00\\right)$, and $($node $3)$ $\\boldsymbol{v}_{3}=\\left(-0.05,0.15\\right)$.\n\nAssume a single-point Gaussian quadrature at the element centroid and use the standard linear triangular shape functions. After deriving the general expression, evaluate the discrete velocity gradient matrix at the centroid for the given element. In addition, identify the symmetric and skew-symmetric parts of the velocity gradient, and discuss the accuracy implications of using $C^{0}$ interpolation for these kinematic measures, including conditions under which the discrete gradient is exact within an element.\n\nRound all reported numerical components to four significant figures. Express the velocity gradient, strain rate, and spin components in $\\mathrm{s}^{-1}$. For the final answer, report only the discrete velocity gradient matrix evaluated at the centroid.",
            "solution": "The problem is valid as it is scientifically grounded in continuum mechanics and the finite element method, is well-posed with sufficient data, and is expressed in objective, formal language. We proceed with the solution.\n\nThe derivation begins from the fundamental principles of finite element interpolation for a velocity field $\\boldsymbol{v}$ within a single element. For a finite element with $n$ nodes, the velocity field $\\boldsymbol{v}(\\boldsymbol{x})$ at any point $\\boldsymbol{x}$ within the element can be approximated by interpolating the nodal velocities $\\boldsymbol{v}_i$ using shape functions $N_i(\\boldsymbol{x})$:\n$$\n\\boldsymbol{v}(\\boldsymbol{x}) = \\sum_{i=1}^{n} N_i(\\boldsymbol{x}) \\boldsymbol{v}_i\n$$\nwhere $\\boldsymbol{v}_i$ is the velocity vector at node $i$. For a two-dimensional problem, $\\boldsymbol{v} = (v_x, v_y)^T$ and $\\boldsymbol{x} = (x, y)^T$.\n\nThe velocity gradient tensor, denoted by $\\boldsymbol{L}$, is defined as the spatial gradient of the velocity field:\n$$\n\\boldsymbol{L} = \\nabla \\boldsymbol{v} = \\begin{pmatrix} \\frac{\\partial v_x}{\\partial x}  \\frac{\\partial v_x}{\\partial y} \\\\ \\frac{\\partial v_y}{\\partial x}  \\frac{\\partial v_y}{\\partial y} \\end{pmatrix}\n$$\nThe components of $\\boldsymbol{L}$ are $L_{jk} = \\frac{\\partial v_j}{\\partial x_k}$. Applying the gradient operator to the interpolated velocity field gives:\n$$\n\\boldsymbol{L} = \\nabla \\left( \\sum_{i=1}^{n} N_i(\\boldsymbol{x}) \\boldsymbol{v}_i \\right) = \\sum_{i=1}^{n} (\\nabla N_i(\\boldsymbol{x})) \\otimes \\boldsymbol{v}_i\n$$\nwhere $\\otimes$ denotes the outer product. In component form, this is:\n$$\nL_{jk} = \\frac{\\partial v_j}{\\partial x_k} = \\frac{\\partial}{\\partial x_k} \\left( \\sum_{i=1}^{n} N_i(\\boldsymbol{x}) v_{ij} \\right) = \\sum_{i=1}^{n} \\frac{\\partial N_i}{\\partial x_k} v_{ij}\n$$\nwhere $v_{ij}$ is the $j$-th component of the velocity vector at node $i$.\n\nFor a two-dimensional element, the components of the velocity gradient are:\n$$\n\\frac{\\partial v_x}{\\partial x} = \\sum_{i=1}^{n} \\frac{\\partial N_i}{\\partial x} v_{ix}, \\quad \\frac{\\partial v_x}{\\partial y} = \\sum_{i=1}^{n} \\frac{\\partial N_i}{\\partial y} v_{ix}\n$$\n$$\n\\frac{\\partial v_y}{\\partial x} = \\sum_{i=1}^{n} \\frac{\\partial N_i}{\\partial x} v_{iy}, \\quad \\frac{\\partial v_y}{\\partial y} = \\sum_{i=1}^{n} \\frac{\\partial N_i}{\\partial y} v_{iy}\n$$\nThis can be written in matrix form as:\n$$\n\\boldsymbol{L} = \\begin{pmatrix} \\sum \\frac{\\partial N_i}{\\partial x} v_{ix}  \\sum \\frac{\\partial N_i}{\\partial y} v_{ix} \\\\ \\sum \\frac{\\partial N_i}{\\partial x} v_{iy}  \\sum \\frac{\\partial N_i}{\\partial y} v_{iy} \\end{pmatrix}\n$$\nThe expressions depend on the gradients of the shape functions, $\\nabla N_i = (\\frac{\\partial N_i}{\\partial x}, \\frac{\\partial N_i}{\\partial y})^T$.\n\nFor the specific two-dimensional linear triangular element (also known as a Constant Strain Triangle, or CST), the shape functions are linear functions of the spatial coordinates $(x,y)$. A key property of this element is that the gradients of its shape functions are constant throughout the element. Consequently, the velocity gradient tensor $\\boldsymbol{L}$ is also constant within the element. This means its value is independent of the evaluation point, so the value at the centroid is the same as at any other point in the element.\n\nThe shape function gradients for a linear triangle with nodal coordinates $(x_1, y_1)$, $(x_2, y_2)$, and $(x_3, y_3)$ are given by:\n$$\n\\frac{\\partial N_1}{\\partial x} = \\frac{y_2 - y_3}{2A}, \\quad \\frac{\\partial N_1}{\\partial y} = \\frac{x_3 - x_2}{2A}\n$$\n$$\n\\frac{\\partial N_2}{\\partial x} = \\frac{y_3 - y_1}{2A}, \\quad \\frac{\\partial N_2}{\\partial y} = \\frac{x_1 - x_3}{2A}\n$$\n$$\n\\frac{\\partial N_3}{\\partial x} = \\frac{y_1 - y_2}{2A}, \\quad \\frac{\\partial N_3}{\\partial y} = \\frac{x_2 - x_1}{2A}\n$$\nwhere $A$ is the area of the element, calculated as $A = \\frac{1}{2} \\det \\begin{pmatrix} x_1  y_1  1 \\\\ x_2  y_2  1 \\\\ x_3  y_3  1 \\end{pmatrix}$.\n\nGiven the nodal coordinates: node $1: (0,0)$; node $2: (2,0)$; node $3: (0,1)$.\nThe area $A$ is:\n$$\nA = \\frac{1}{2} |x_1(y_2-y_3) + x_2(y_3-y_1) + x_3(y_1-y_2)| = \\frac{1}{2} |0(0-1) + 2(1-0) + 0(0-0)| = \\frac{1}{2}(2) = 1\n$$\nNow, we compute the shape function gradients:\nFor node $1$:\n$\\frac{\\partial N_1}{\\partial x} = \\frac{0 - 1}{2(1)} = -0.5$, $\\frac{\\partial N_1}{\\partial y} = \\frac{0 - 2}{2(1)} = -1.0$\nFor node $2$:\n$\\frac{\\partial N_2}{\\partial x} = \\frac{1 - 0}{2(1)} = 0.5$, $\\frac{\\partial N_2}{\\partial y} = \\frac{0 - 0}{2(1)} = 0.0$\nFor node $3$:\n$\\frac{\\partial N_3}{\\partial x} = \\frac{0 - 0}{2(1)} = 0.0$, $\\frac{\\partial N_3}{\\partial y} = \\frac{2 - 0}{2(1)} = 1.0$\n\nThe nodal velocities are:\n$\\boldsymbol{v}_{1} = (0.1, -0.05)^T \\ \\mathrm{m/s}$\n$\\boldsymbol{v}_{2} = (0.2, 0.00)^T \\ \\mathrm{m/s}$\n$\\boldsymbol{v}_{3} = (-0.05, 0.15)^T \\ \\mathrm{m/s}$\n\nWe can now compute the components of the velocity gradient tensor $\\boldsymbol{L}$ in units of $\\mathrm{s}^{-1}$:\n$L_{11} = \\frac{\\partial v_x}{\\partial x} = \\sum_{i=1}^{3} \\frac{\\partial N_i}{\\partial x} v_{ix} = (-0.5)(0.1) + (0.5)(0.2) + (0.0)(-0.05) = -0.05 + 0.1 = 0.05$\n$L_{12} = \\frac{\\partial v_x}{\\partial y} = \\sum_{i=1}^{3} \\frac{\\partial N_i}{\\partial y} v_{ix} = (-1.0)(0.1) + (0.0)(0.2) + (1.0)(-0.05) = -0.1 - 0.05 = -0.15$\n$L_{21} = \\frac{\\partial v_y}{\\partial x} = \\sum_{i=1}^{3} \\frac{\\partial N_i}{\\partial x} v_{iy} = (-0.5)(-0.05) + (0.5)(0.00) + (0.0)(0.15) = 0.025$\n$L_{22} = \\frac{\\partial v_y}{\\partial y} = \\sum_{i=1}^{3} \\frac{\\partial N_i}{\\partial y} v_{iy} = (-1.0)(-0.05) + (0.0)(0.00) + (1.0)(0.15) = 0.05 + 0.15 = 0.20$\n\nRounding to four significant figures, the discrete velocity gradient matrix at the centroid (and everywhere within the element) is:\n$$\n\\boldsymbol{L} = \\begin{pmatrix} 0.05000  -0.1500 \\\\ 0.02500  0.2000 \\end{pmatrix} \\ \\mathrm{s}^{-1}\n$$\n\nThe velocity gradient tensor $\\boldsymbol{L}$ is decomposed into its symmetric part, the strain rate tensor $\\boldsymbol{D}$, and its skew-symmetric part, the spin tensor $\\boldsymbol{W}$:\n$\\boldsymbol{D} = \\frac{1}{2}(\\boldsymbol{L} + \\boldsymbol{L}^T)$\n$\\boldsymbol{W} = \\frac{1}{2}(\\boldsymbol{L} - \\boldsymbol{L}^T)$\n\nFirst, we find the transpose of $\\boldsymbol{L}$:\n$$\n\\boldsymbol{L}^T = \\begin{pmatrix} 0.05000  0.02500 \\\\ -0.1500  0.2000 \\end{pmatrix}\n$$\nThe strain rate tensor $\\boldsymbol{D}$ is:\n$$\n\\boldsymbol{D} = \\frac{1}{2} \\begin{pmatrix} 0.05000+0.05000  -0.1500+0.02500 \\\\ 0.02500-0.1500  0.2000+0.2000 \\end{pmatrix} = \\frac{1}{2} \\begin{pmatrix} 0.1000  -0.1250 \\\\ -0.1250  0.4000 \\end{pmatrix}\n$$\n$$\n\\boldsymbol{D} = \\begin{pmatrix} 0.05000  -0.06250 \\\\ -0.06250  0.2000 \\end{pmatrix} \\ \\mathrm{s}^{-1}\n$$\nThe spin tensor $\\boldsymbol{W}$ is:\n$$\n\\boldsymbol{W} = \\frac{1}{2} \\begin{pmatrix} 0.05000-0.05000  -0.1500-0.02500 \\\\ 0.02500-(-0.1500)  0.2000-0.2000 \\end{pmatrix} = \\frac{1}{2} \\begin{pmatrix} 0  -0.1750 \\\\ 0.1750  0 \\end{pmatrix}\n$$\n$$\n\\boldsymbol{W} = \\begin{pmatrix} 0  -0.08750 \\\\ 0.08750  0 \\end{pmatrix} \\ \\mathrm{s}^{-1}\n$$\n\n**Accuracy Implications and Conditions for Exactness**\nThe use of $C^0$ continuous shape functions, such as those in a linear triangular element, ensures that the interpolated velocity field is continuous across element boundaries. However, its spatial derivatives—the velocity gradient, strain rate, and spin—are not. For a linear element, these quantities are constant within each element but exhibit jumps across element boundaries. This represents a piecewise-constant approximation of the true, generally smooth, gradient field. This low-order approximation is a primary source of discretization error in simulations.\n\nThis element is known to perform poorly in bending-dominated problems and can exhibit \"locking\" phenomena. The accuracy of the solution generally improves with mesh refinement (h-refinement, using smaller elements) or by using higher-order elements (p-refinement) which allow for non-constant gradients within the element.\n\nThe discrete gradient, as computed here, is exact under one specific condition: if the true underlying velocity field is a linear function of the spatial coordinates within the domain spanned by the element. A linear velocity field can be written as $\\boldsymbol{v}(\\boldsymbol{x}) = \\boldsymbol{A} \\boldsymbol{x} + \\boldsymbol{b}$, where $\\boldsymbol{A}$ is a constant matrix and $\\boldsymbol{b}$ is a constant vector. The velocity gradient of such a field is $\\nabla \\boldsymbol{v} = \\boldsymbol{A}$, which is constant. A linear finite element can exactly represent a linear field. If the nodal velocities provided are exact samples from such a linear field, the finite element interpolation will reproduce the field exactly, and the computed constant velocity gradient will be the exact gradient everywhere in the element. For any velocity field that is of higher order (e.g., quadratic), the linear element's constant gradient is only an approximation.",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 0.05000  -0.1500 \\\\ 0.02500  0.2000 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "When simulating realistic geomechanical phenomena like landslides or soil-structure interaction, materials undergo large deformations and rotations. A critical challenge is ensuring that the constitutive model (the material's \"rules\" of behavior) is independent of the observer's viewpoint—a property known as objectivity. This advanced practice confronts this challenge head-on by having you implement a corotational stress update using the Jaumann rate, where the spin tensor $W$ plays a crucial role in correcting for rigid body rotations. By comparing the results to a naive, non-objective formulation, you will see firsthand why frame indifference is not just a theoretical subtlety but a practical necessity for accurate and robust simulations .",
            "id": "3564053",
            "problem": "Design and implement a validation program for a corotational constitutive update in computational geomechanics that highlights the role of the strain rate tensor and the spin tensor. Work in three dimensions with small strains but allow for large rotations through an objective stress rate. The fundamental base must be the kinematic definition of the spatial velocity gradient and the Cauchy stress rate in a corotational framework, combined with standard isotropic linear elasticity and a rate-independent Drucker–Prager plasticity model with a non-associated plastic potential.\n\nYou must use the following foundational definitions and facts as the only starting point:\n- The spatial velocity gradient is defined as $\\boldsymbol{L} = \\nabla \\boldsymbol{v}$, with its symmetric part the strain rate tensor $\\boldsymbol{D} = \\tfrac{1}{2}(\\boldsymbol{L} + \\boldsymbol{L}^{\\mathsf{T}})$ and its skew-symmetric part the spin tensor $\\boldsymbol{W} = \\tfrac{1}{2}(\\boldsymbol{L} - \\boldsymbol{L}^{\\mathsf{T}})$.\n- The Cauchy stress tensor $\\boldsymbol{\\sigma}$ must be updated using an objective (frame-indifferent) corotational stress rate, specifically the Jaumann rate, which is defined by the relation $\\overset{\\triangle}{\\boldsymbol{\\sigma}} = \\dot{\\boldsymbol{\\sigma}} + \\boldsymbol{\\sigma}\\boldsymbol{W} - \\boldsymbol{W}\\boldsymbol{\\sigma}$.\n- The elastoplastic constitutive relation is posed in rate form as $\\overset{\\triangle}{\\boldsymbol{\\sigma}} = \\mathbb{C} : (\\boldsymbol{D} - \\boldsymbol{D}^{\\mathrm{p}})$, where $\\mathbb{C}$ is the fourth-order isotropic elasticity tensor with bulk modulus $K$ and shear modulus $G$, and $\\boldsymbol{D}^{\\mathrm{p}}$ is the plastic part of the rate of deformation tensor.\n- For rate-independent Drucker–Prager plasticity, the yield function is $f(\\boldsymbol{\\sigma}) = \\alpha I_1 + \\sqrt{J_2} - k$, where $I_1 = \\operatorname{tr}(\\boldsymbol{\\sigma})$ and $J_2 = \\tfrac{1}{2}\\,\\boldsymbol{s}:\\boldsymbol{s}$ with deviatoric stress $\\boldsymbol{s} = \\boldsymbol{\\sigma} - \\tfrac{I_1}{3}\\boldsymbol{I}$. The non-associated plastic potential $g(\\boldsymbol{\\sigma}) = \\alpha_{\\psi} I_1 + \\sqrt{J_2}$ defines the flow direction $\\boldsymbol{N} = \\partial g/\\partial \\boldsymbol{\\sigma}$.\n- Use the material parameterization in terms of friction angle $\\varphi$ (in radians), dilation angle $\\psi$ (in radians), and cohesion $c$ by $\\alpha = \\dfrac{2\\sin \\varphi}{\\sqrt{3}\\,(3 - \\sin \\varphi)}$, $k = \\dfrac{6 c \\cos \\varphi}{\\sqrt{3}\\,(3 - \\sin \\varphi)}$, and $\\alpha_{\\psi} = \\dfrac{2\\sin \\psi}{\\sqrt{3}\\,(3 - \\sin \\psi)}$.\n\nImplement an explicit time-stepping algorithm that, at each step, forms an elastic trial stress increment and applies a Drucker–Prager return correction if the trial state violates $f \\le 0$. For the corotational algorithm, the Jaumann terms must be included in the stress update. For comparison, implement an uncorrected algorithm in which the Jaumann terms are omitted and the raw material time derivative $\\dot{\\boldsymbol{\\sigma}}$ is integrated directly.\n\nAll physical quantities must be handled with the following units and conventions:\n- Stresses in kilopascals (kPa).\n- Time in seconds ($\\mathrm{s}$).\n- Angular measures in radians.\n- Adopt the standard sign convention that tensile stress is positive; a compressive hydrostatic confining stress therefore has negative trace.\n\nYour program must execute the following test suite and aggregate the results.\n\nMaterial parameters common to all tests:\n- Young’s modulus $E = 3.0\\times 10^{4}\\,\\mathrm{kPa}$, Poisson’s ratio $\\nu = 0.3$, so that $G = \\dfrac{E}{2(1+\\nu)}$ and $K = \\dfrac{E}{3(1 - 2\\nu)}$.\n- Drucker–Prager parameters: $\\varphi = 30\\,\\text{degrees}$, $\\psi = 5\\,\\text{degrees}$, $c = 5\\,\\mathrm{kPa}$, converted to radians for $\\varphi$ and $\\psi$ before computing $\\alpha$, $\\alpha_{\\psi}$, and $k$.\n\nTest 1 (pure rigid-body rotation, edge case for objectivity):\n- Initial stress: $\\boldsymbol{\\sigma}_0 = \\operatorname{diag}(200,\\,100,\\,100)\\,\\mathrm{kPa}$.\n- Impose a pure spin about the $z$-axis with constant angular speed $\\omega = \\pi/2\\,\\mathrm{rad}\\,\\mathrm{s}^{-1}$ for total time $T = 1.0\\,\\mathrm{s}$, so that the total rotation is $\\theta = \\pi/2$. Use time step $\\Delta t = 0.005\\,\\mathrm{s}$.\n- The velocity gradient is $\\boldsymbol{L}(t) = \\boldsymbol{W}$ with $\\boldsymbol{W} = \\begin{bmatrix}0  -\\omega  0\\\\ \\omega  0  0\\\\ 0  0  0\\end{bmatrix}$ and $\\boldsymbol{D} = \\boldsymbol{0}$.\n- Compute the final numerical stress $\\boldsymbol{\\sigma}^{\\mathrm{obj}}(T)$ with the corotational (Jaumann) algorithm and $\\boldsymbol{\\sigma}^{\\mathrm{unc}}(T)$ with the uncorrected algorithm. Also compute the exact rotated stress $\\boldsymbol{\\sigma}^{\\mathrm{exact}}(T) = \\boldsymbol{R}(\\theta)\\,\\boldsymbol{\\sigma}_0\\,\\boldsymbol{R}^{\\mathsf{T}}(\\theta)$, where $\\boldsymbol{R}(\\theta)$ is the in-plane rotation matrix about the $z$-axis through angle $\\theta$. Report the ratio $r_1 = \\dfrac{\\lVert \\boldsymbol{\\sigma}^{\\mathrm{obj}}(T) - \\boldsymbol{\\sigma}^{\\mathrm{exact}}(T)\\rVert_{\\mathrm{F}}}{\\lVert \\boldsymbol{\\sigma}^{\\mathrm{unc}}(T) - \\boldsymbol{\\sigma}^{\\mathrm{exact}}(T)\\rVert_{\\mathrm{F}}}$ as a dimensionless float rounded to six decimal places.\n\nTest 2 (simple shear, rotating principal stress path):\n- Initial stress: isotropic confining state $\\boldsymbol{\\sigma}_0 = -100\\,\\boldsymbol{I}\\,\\mathrm{kPa}$.\n- Impose a constant simple shear rate $\\dot{\\gamma} = 0.01\\,\\mathrm{s}^{-1}$ by prescribing the velocity gradient $\\boldsymbol{L} = \\begin{bmatrix}0  \\dot{\\gamma}  0\\\\ 0  0  0\\\\ 0  0  0\\end{bmatrix}$ held constant over $T = 50\\,\\mathrm{s}$ with time step $\\Delta t = 0.1\\,\\mathrm{s}$. Then $\\boldsymbol{D} = \\tfrac{1}{2}\\begin{bmatrix}0  \\dot{\\gamma}  0\\\\ \\dot{\\gamma}  0  0\\\\ 0  0  0\\end{bmatrix}$ and $\\boldsymbol{W} = \\tfrac{1}{2}\\begin{bmatrix}0  \\dot{\\gamma}  0\\\\ -\\dot{\\gamma}  0  0\\\\ 0  0  0\\end{bmatrix}$.\n- Integrate the constitutive update with and without the Jaumann terms. Report the final shear stress components $\\tau^{\\mathrm{obj}} = \\sigma^{\\mathrm{obj}}_{12}(T)$ and $\\tau^{\\mathrm{unc}} = \\sigma^{\\mathrm{unc}}_{12}(T)$, each in $\\mathrm{kPa}$ rounded to six decimal places.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the order $[r_1,\\tau^{\\mathrm{obj}},\\tau^{\\mathrm{unc}}]$, for example \"[0.012345,12.345678,-9.876543]\". Each number must be rounded to six decimal places.",
            "solution": "The user has requested the design and implementation of a computational geomechanics validation program. The program must implement an explicit time-stepping constitutive update for a material governed by isotropic elasticity and Drucker-Prager plasticity. A key requirement is to compare a corotational stress update using the Jaumann rate against an uncorrected update that omits the objective rate terms. This comparison highlights the role of the strain rate tensor, $\\boldsymbol{D}$, and the spin tensor, $\\boldsymbol{W}$.\n\nFirst, the problem statement is validated. All required physical models, material parameters, initial conditions, loading paths, and numerical procedures are explicitly defined. The models ($\\boldsymbol{L} = \\boldsymbol{D} + \\boldsymbol{W}$, Jaumann rate $\\overset{\\triangle}{\\boldsymbol{\\sigma}}$, Drucker-Prager plasticity) are standard and scientifically sound within continuum mechanics. The two test cases are classical benchmarks: pure rigid-body rotation to test for frame-indifference (objectivity), and simple shear to test behavior under a combination of straining and rotation. The initial stress state for Test 1, $\\boldsymbol{\\sigma}_0 = \\operatorname{diag}(200,\\,100,\\,100)\\,\\mathrm{kPa}$, violates the Drucker-Prager yield criterion for the given material properties. While physically anomalous (such a state would relax instantaneously), in a numerical context it is a valid, albeit challenging, input. The problem requests the implementation of a specific algorithm (explicit forward-Euler with a return-map correction), and the result is the output of this well-defined procedure on the given data. The problem is thus deemed valid, complete, and well-posed.\n\nThe algorithmic core of the solution is the constitutive update routine, which advances the Cauchy stress tensor $\\boldsymbol{\\sigma}$ from time $t_n$ to $t_{n+1} = t_n + \\Delta t$.\n\n**1. Preliminary Calculations**\nThe material properties provided are Young's modulus $E$ and Poisson's ratio $\\nu$, along with the Drucker-Prager parameters: friction angle $\\varphi$, dilation angle $\\psi$, and cohesion $c$. From these, we first derive the necessary computational parameters:\n- Shear modulus: $G = \\dfrac{E}{2(1+\\nu)}$\n- Bulk modulus: $K = \\dfrac{E}{3(1 - 2\\nu)}$\n- Drucker-Prager friction parameter: $\\alpha = \\dfrac{2\\sin \\varphi}{\\sqrt{3}\\,(3 - \\sin \\varphi)}$\n- Drucker-Prager cohesion parameter: $k = \\dfrac{6 c \\cos \\varphi}{\\sqrt{3}\\,(3 - \\sin \\varphi)}$\n- Drucker-Prager dilation parameter: $\\alpha_{\\psi} = \\dfrac{2\\sin \\psi}{\\sqrt{3}\\,(3 - \\sin \\psi)}$\n\n**2. Kinematic Decomposition**\nAt each time step, the given spatial velocity gradient $\\boldsymbol{L}$ is decomposed into its symmetric part, the rate of deformation tensor $\\boldsymbol{D}$, and its skew-symmetric part, the spin tensor $\\boldsymbol{W}$:\n$$\n\\boldsymbol{D} = \\frac{1}{2}(\\boldsymbol{L} + \\boldsymbol{L}^{\\mathsf{T}})\n$$\n$$\n\\boldsymbol{W} = \\frac{1}{2}(\\boldsymbol{L} - \\boldsymbol{L}^{\\mathsf{T}})\n$$\n\n**3. Elastic Trial Step**\nAn explicit forward-Euler integration scheme is used. The first step is to compute an elastic trial stress, $\\boldsymbol{\\sigma}_{n+1}^{\\text{trial}}$, which assumes the material behaves elastically over the increment $\\Delta t$.\nThe constitutive law in rate form is $\\overset{\\triangle}{\\boldsymbol{\\sigma}} = \\mathbb{C} : (\\boldsymbol{D} - \\boldsymbol{D}^{\\mathrm{p}})$. For the elastic trial step, we assume the plastic strain rate $\\boldsymbol{D}^{\\mathrm{p}} = \\boldsymbol{0}$, so $\\overset{\\triangle}{\\boldsymbol{\\sigma}}^{\\text{el}} = \\mathbb{C}:\\boldsymbol{D}$. For isotropic elasticity, this is:\n$$\n\\overset{\\triangle}{\\boldsymbol{\\sigma}}^{\\text{el}} = 2G \\left(\\boldsymbol{D} - \\frac{1}{3}\\operatorname{tr}(\\boldsymbol{D})\\boldsymbol{I}\\right) + K \\operatorname{tr}(\\boldsymbol{D})\\boldsymbol{I}\n$$\nThe trial stress is computed differently for the two algorithms:\n\n- **Uncorrected Algorithm:** This algorithm directly integrates the material time derivative $\\dot{\\boldsymbol{\\sigma}}$ and ignores the spin terms. The update is:\n$$\n\\boldsymbol{\\sigma}_{n+1}^{\\text{trial}} = \\boldsymbol{\\sigma}_n + (\\mathbb{C}:\\boldsymbol{D}) \\Delta t\n$$\n\n- **Corotational (Jaumann) Algorithm:** This algorithm uses the objective Jaumann rate, $\\overset{\\triangle}{\\boldsymbol{\\sigma}} = \\dot{\\boldsymbol{\\sigma}} + \\boldsymbol{\\sigma}\\boldsymbol{W} - \\boldsymbol{W}\\boldsymbol{\\sigma}$. Rearranging for the material time derivative gives $\\dot{\\boldsymbol{\\sigma}} = \\overset{\\triangle}{\\boldsymbol{\\sigma}} - (\\boldsymbol{\\sigma}\\boldsymbol{W} - \\boldsymbol{W}\\boldsymbol{\\sigma})$. The explicit update is:\n$$\n\\boldsymbol{\\sigma}_{n+1}^{\\text{trial}} = \\boldsymbol{\\sigma}_n + \\left( \\mathbb{C}:\\boldsymbol{D} - (\\boldsymbol{\\sigma}_n\\boldsymbol{W} - \\boldsymbol{W}\\boldsymbol{\\sigma}_n) \\right) \\Delta t\n$$\nHere, the spin-related terms are evaluated at time $t_n$.\n\n**4. Plasticity Check and Correction (Return Mapping)**\nThe trial stress is checked against the Drucker-Prager yield criterion: $f(\\boldsymbol{\\sigma}) = \\alpha I_1 + \\sqrt{J_2} - k \\le 0$, where $I_1 = \\operatorname{tr}(\\boldsymbol{\\sigma})$ and $J_2 = \\frac{1}{2}\\boldsymbol{s}:\\boldsymbol{s}$ for the deviatoric stress $\\boldsymbol{s}$.\nWe evaluate $f^{\\text{trial}} = f(\\boldsymbol{\\sigma}_{n+1}^{\\text{trial}})$.\n- If $f^{\\text{trial}} \\le 0$, the step is elastic, and the final stress is the trial stress: $\\boldsymbol{\\sigma}_{n+1} = \\boldsymbol{\\sigma}_{n+1}^{\\text{trial}}$.\n- If $f^{\\text{trial}}  0$, the trial stress lies outside the yield surface, and a plastic correction is required. The stress must be \"returned\" to the yield surface.\n\nThe plastic strain rate is given by the non-associated flow rule $\\boldsymbol{D}^{\\mathrm{p}} = \\dot{\\lambda} \\boldsymbol{N}$, where $\\dot{\\lambda}$ is the plastic multiplier rate and $\\boldsymbol{N} = \\partial g/\\partial \\boldsymbol{\\sigma}$ is the flow direction derived from the plastic potential $g(\\boldsymbol{\\sigma}) = \\alpha_{\\psi} I_1 + \\sqrt{J_2}$. The final stress is found by correcting the trial stress:\n$$\n\\boldsymbol{\\sigma}_{n+1} = \\boldsymbol{\\sigma}_{n+1}^{\\text{trial}} - \\Delta\\lambda (\\mathbb{C}:\\boldsymbol{N})\n$$\nwhere $\\Delta\\lambda = \\dot{\\lambda}\\Delta t$ is the plastic multiplier increment. By substituting this expression into the yield condition $f(\\boldsymbol{\\sigma}_{n+1}) = 0$ and solving for $\\Delta\\lambda$, we obtain an explicit expression for the multiplier:\n$$\n\\Delta\\lambda = \\frac{f^{\\text{trial}}}{G + 9K\\alpha\\alpha_{\\psi}}\n$$\nThe corrected stress is then calculated:\n$$\n\\boldsymbol{\\sigma}_{n+1} = \\boldsymbol{\\sigma}_{n+1}^{\\text{trial}} - \\Delta\\lambda \\left( \\frac{G}{\\sqrt{J_2^{\\text{trial}}}} \\boldsymbol{s}^{\\text{trial}} + 3K\\alpha_{\\psi}\\boldsymbol{I} \\right)\n$$\nThis completes the update for a single time step. This procedure is repeated for the specified number of steps in each test case.\n\n**Test Execution**\n- **Test 1 (Pure Rotation):** Here, $\\boldsymbol{D} = \\boldsymbol{0}$ and $\\boldsymbol{W} \\ne \\boldsymbol{0}$. The uncorrected algorithm, having no spin terms, predicts no change in stress, $\\boldsymbol{\\sigma}^{\\mathrm{unc}}(T) = \\boldsymbol{\\sigma}_0$. (Note: due to the out-of-yield initial condition, the code will actually apply a plastic correction, causing $\\boldsymbol{\\sigma}^{\\mathrm{unc}}$ to shrink but not rotate). The corotational algorithm correctly accounts for the rotation, and the resulting stress $\\boldsymbol{\\sigma}^{\\mathrm{obj}}(T)$ should closely approximate the analytically rotated stress $\\boldsymbol{\\sigma}^{\\mathrm{exact}}(T) = \\boldsymbol{R}(\\theta)\\boldsymbol{\\sigma}_0\\boldsymbol{R}^{\\mathsf{T}}(\\theta)$. The ratio $r_1$ quantifies the superior accuracy of the objective formulation. The non-zero error in the objective case arises from the explicit integration scheme and the spurious plastic flow triggered by the problematic initial condition.\n- **Test 2 (Simple Shear):** Here, both $\\boldsymbol{D} \\ne \\boldsymbol{0}$ and $\\boldsymbol{W} \\ne \\boldsymbol{0}$. The material is initially elastic but yields as shear stress builds. Both algorithms will predict plastic flow, but the stress paths will diverge. The spin tensor continuously rotates the principal stress axes, a physical effect that the Jaumann rate captures but the uncorrected rate ignores, leading to different final shear stress values, $\\tau^{\\mathrm{obj}}$ and $\\tau^{\\mathrm{unc}}$.\n\nThe final program implements this logic, executes the two tests, and formats the output as required.",
            "answer": "```python\n# language: Python\n# version: 3.12\n# libraries:\n#   name: numpy\n#   version: 1.23.5\n\nimport numpy as np\n\ndef calculate_material_params(E, nu, phi_deg, psi_deg, c):\n    \"\"\"\n    Calculates derived material parameters for the Drucker-Prager model.\n\n    Args:\n        E (float): Young's modulus in kPa.\n        nu (float): Poisson's ratio.\n        phi_deg (float): Friction angle in degrees.\n        psi_deg (float): Dilation angle in degrees.\n        c (float): Cohesion in kPa.\n\n    Returns:\n        tuple: G, K, alpha, k, alpha_psi\n    \"\"\"\n    phi_rad = np.deg2rad(phi_deg)\n    psi_rad = np.deg2rad(psi_deg)\n    \n    G = E / (2 * (1 + nu))\n    K = E / (3 * (1 - 2 * nu))\n    \n    sin_phi = np.sin(phi_rad)\n    cos_phi = np.cos(phi_rad)\n    alpha_denom = np.sqrt(3) * (3 - sin_phi)\n    alpha = (2 * sin_phi) / alpha_denom\n    k = (6 * c * cos_phi) / alpha_denom\n    \n    sin_psi = np.sin(psi_rad)\n    if np.abs(sin_psi)  1e-9:\n        alpha_psi = 0.0\n    else:\n        alpha_psi_denom = np.sqrt(3) * (3 - sin_psi)\n        alpha_psi = (2 * sin_psi) / alpha_psi_denom\n\n    return G, K, alpha, k, alpha_psi\n\ndef constitutive_update(sigma_n, L, dt, use_jaumann, G, K, alpha, k, alpha_psi):\n    \"\"\"\n    Performs one step of the elastoplastic constitutive update.\n\n    Args:\n        sigma_n (np.ndarray): Stress tensor at the start of the step.\n        L (np.ndarray): Velocity gradient tensor.\n        dt (float): Time step size.\n        use_jaumann (bool): Flag to use the corotational (Jaumann) rate.\n        G, K, alpha, k, alpha_psi (float): Material parameters.\n\n    Returns:\n        np.ndarray: Updated stress tensor at the end of the step.\n    \"\"\"\n    \n    # 1. Decompose velocity gradient\n    D = 0.5 * (L + L.T)\n    W = 0.5 * (L - L.T)\n    \n    # 2. Elastic trial step\n    tr_D = np.trace(D)\n    D_dev = D - (tr_D / 3.0) * np.identity(3)\n    \n    sigma_dot_el = 2 * G * D_dev + K * tr_D * np.identity(3)\n    \n    if use_jaumann:\n        jaumann_term = sigma_n @ W - W @ sigma_n\n        sigma_trial = sigma_n + (sigma_dot_el - jaumann_term) * dt\n    else:\n        sigma_trial = sigma_n + sigma_dot_el * dt\n        \n    # 3. Plasticity check\n    I1_trial = np.trace(sigma_trial)\n    s_trial = sigma_trial - (I1_trial / 3.0) * np.identity(3)\n    J2_trial = 0.5 * np.sum(s_trial * s_trial)\n\n    sqrt_J2_trial = np.sqrt(J2_trial) if J2_trial  1e-12 else 0.0\n      \n    f_trial = alpha * I1_trial + sqrt_J2_trial - k\n    \n    # 4. Plastic corrector (if needed)\n    if f_trial  0:\n        hardening_param = G + 9 * K * alpha * alpha_psi\n        delta_lambda = f_trial / hardening_param if hardening_param  1e-12 else 0.0\n        \n        if sqrt_J2_trial  1e-12:\n            s_trial_norm_factor = G / sqrt_J2_trial\n        else:\n            s_trial_norm_factor = 0.0\n\n        sigma_corr = delta_lambda * (s_trial_norm_factor * s_trial + 3 * K * alpha_psi * np.identity(3))\n        sigma_next = sigma_trial - sigma_corr\n    else:\n        sigma_next = sigma_trial\n        \n    return sigma_next\n\ndef run_test1(params):\n    G, K, alpha, k, alpha_psi = params\n    \n    sigma0 = np.diag([200.0, 100.0, 100.0])\n    omega = np.pi / 2.0\n    T = 1.0\n    dt = 0.005\n    \n    L = np.array([[0, -omega, 0], [omega,  0, 0], [0, 0, 0]])\n    \n    sigma_obj = np.copy(sigma0)\n    sigma_unc = np.copy(sigma0)\n    \n    num_steps = int(round(T / dt))\n    for _ in range(num_steps):\n        sigma_obj = constitutive_update(sigma_obj, L, dt, True, G, K, alpha, k, alpha_psi)\n        sigma_unc = constitutive_update(sigma_unc, L, dt, False, G, K, alpha, k, alpha_psi)\n\n    theta = omega * T\n    R = np.array([\n        [np.cos(theta), -np.sin(theta), 0],\n        [np.sin(theta),  np.cos(theta), 0],\n        [0,              0,             1]\n    ])\n    sigma_exact = R @ sigma0 @ R.T\n    \n    norm_err_obj = np.linalg.norm(sigma_obj - sigma_exact, 'fro')\n    norm_err_unc = np.linalg.norm(sigma_unc - sigma_exact, 'fro')\n    \n    return norm_err_obj / norm_err_unc if norm_err_unc  1e-9 else 0.0\n\ndef run_test2(params):\n    G, K, alpha, k, alpha_psi = params\n\n    sigma0 = -100.0 * np.identity(3)\n    gamma_dot = 0.01\n    T = 50.0\n    dt = 0.1\n    \n    L = np.array([[0, gamma_dot, 0], [0, 0, 0], [0, 0, 0]])\n    \n    sigma_obj = np.copy(sigma0)\n    sigma_unc = np.copy(sigma0)\n    \n    num_steps = int(round(T / dt))\n    for _ in range(num_steps):\n        sigma_obj = constitutive_update(sigma_obj, L, dt, True, G, K, alpha, k, alpha_psi)\n        sigma_unc = constitutive_update(sigma_unc, L, dt, False, G, K, alpha, k, alpha_psi)\n\n    tau_obj = sigma_obj[0, 1]\n    tau_unc = sigma_unc[0, 1]\n    \n    return tau_obj, tau_unc\n    \ndef solve():\n    \"\"\"Main solver function to execute the test suite and print results.\"\"\"\n    \n    # Material parameters common to all tests\n    E = 3.0e4  # kPa\n    nu = 0.3\n    phi_deg = 30.0\n    psi_deg = 5.0\n    c = 5.0  # kPa\n    \n    params = calculate_material_params(E, nu, phi_deg, psi_deg, c)\n    \n    # Run tests and collect results\n    r1 = run_test1(params)\n    tau_obj, tau_unc = run_test2(params)\n    \n    # Format results to six decimal places\n    results = [round(r1, 6), round(tau_obj, 6), round(tau_unc, 6)]\n    \n    # Print in the specified single-line format\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}