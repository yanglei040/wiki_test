{
    "hands_on_practices": [
        {
            "introduction": "在构建数值模拟的信任时，第一步是验证其核心组件（如散度算子）的行为是否正确。本练习将介绍“分片检验”（patch test），这是一种基础技术，用于验证离散算子能否精确地再现已知的简单解。你将从高斯定理的积分形式出发，推导出一个离散的应力散度算子，并在一个线性应力场上进行测试，理论上该算子在此情况下应能得到精确解。",
            "id": "3517016",
            "problem": "考虑一个二维连续介质域，其空间坐标表示为 $x$ 和 $y$，并令柯西应力张量场为 $\\boldsymbol{\\sigma}(x,y)\\in\\mathbb{R}^{2\\times 2}$。应用于二阶张量的散度微分算子是按行定义的：对于第 $i$ 行（$i\\in\\{1,2\\}$），其散度为 $(\\nabla\\cdot\\boldsymbol{\\sigma})_i=\\sum_{j=1}^{2}\\frac{\\partial \\sigma_{ij}}{\\partial x_j}$，其中 $x_1=x$ 和 $x_2=y$，并且每个 $\\sigma_{ij}$ 都是 $x$ 和 $y$ 的分量函数。高斯散度定理指出，对于任何足够光滑的矢量场 $\\mathbf{a}(x,y)$，\n$$\n\\int_{\\Omega} \\nabla\\cdot \\mathbf{a}\\, \\mathrm{d}A \\;=\\; \\int_{\\partial\\Omega} \\mathbf{a}\\cdot\\mathbf{n}\\,\\mathrm{d}s,\n$$\n其中 $\\Omega\\subset\\mathbb{R}^2$ 是一个具有分段光滑边界 $\\partial\\Omega$ 的开集，$\\mathbf{n}$ 是 $\\partial\\Omega$ 上的外法向单位矢量，$\\mathrm{d}A$ 是面积测度，$\\mathrm{d}s$ 是线测度。在连续介质力学中，从 $\\boldsymbol{\\sigma}$ 导出的、作用在具有单位法向量 $\\mathbf{n}$ 的边界上的面力矢量的分量为 $t_i=\\sum_{j=1}^{2}\\sigma_{ij} n_j$，将高斯散度定理按行应用，对每个 $i\\in\\{1,2\\}$ 可得，\n$$\n\\int_{\\Omega} (\\nabla\\cdot\\boldsymbol{\\sigma})_i\\, \\mathrm{d}A \\;=\\; \\int_{\\partial\\Omega} \\left(\\sum_{j=1}^{2}\\sigma_{ij} n_j\\right)\\,\\mathrm{d}s.\n$$\n\n任务：\n1. 从导数的定义和上述散度的按行定义出发，证明对于一个空间常数应力场 $\\boldsymbol{\\sigma}(x,y)=\\boldsymbol{\\sigma}_0$（其中每个 $\\sigma_{ij}$ 都与 $x$ 和 $y$ 无关），其散度 $\\nabla\\cdot\\boldsymbol{\\sigma}$ 在域内处处为零。\n\n2. 基于高斯散度定理，为矩形网格构建一个离散散度算子。考虑一个单独的矩形单元，其在 $x$ 方向的边长为 $h_x$，在 $y$ 方向的边长为 $h_y$，面积为 $A=h_x h_y$，并有四个面：左面和右面（法向量分别为 $(-1,0)$ 和 $(1,0)$）以及底面和顶面（法向量分别为 $(0,-1)$ 和 $(0,1)$）。通过对面力分量 $t_i=\\sum_{j=1}^{2}\\sigma_{ij}n_j$ 在每个面上进行中点取值来近似边界积分，将四个面的贡献相加，再除以单元面积 $A$，从而定义每个单元中的离散散度。在覆盖整个域的均匀结构化网格上实现这个离散算子。\n\n3. 在计算地质力学中，“斑块检验” (patch test) 用于验证离散算子是否能精确再现特定的多项式场。构建并验证一个斑块检验，其中体力被一个应力场精确平衡，该应力场的分量至多是 $x$ 和 $y$ 的线性函数。具体来说，使用以下形式的应力张量：\n$$\n\\boldsymbol{\\sigma}(x,y) \\;=\\;\n\\begin{bmatrix}\na_{11} x + b_{11} y + c_{11}  a_{12} x + b_{12} y + c_{12} \\\\\na_{21} x + b_{21} y + c_{21}  a_{22} x + b_{22} y + c_{22}\n\\end{bmatrix},\n$$\n其中所有 $a_{ij}$ 和 $b_{ij}$ 的单位为 $\\mathrm{Pa/m}$，所有 $c_{ij}$ 的单位为 $\\mathrm{Pa}$。由 $\\nabla\\cdot\\boldsymbol{\\sigma}$ 蕴含的单位体积解析体力（单位为 $\\mathrm{N/m^3}$）在空间上是常数，并由下式给出：\n$$\n\\mathbf{b} \\;=\\;\n\\begin{bmatrix}\n\\frac{\\partial \\sigma_{11}}{\\partial x} + \\frac{\\partial \\sigma_{12}}{\\partial y} \\\\\n\\frac{\\partial \\sigma_{21}}{\\partial x} + \\frac{\\partial \\sigma_{22}}{\\partial y}\n\\end{bmatrix}\n\\;=\\;\n\\begin{bmatrix}\na_{11} + b_{12} \\\\\na_{21} + b_{22}\n\\end{bmatrix}.\n$$\n使用任务2中的离散算子，对以下测试套件验证每个单元计算出的离散散度是否与 $\\mathbf{b}$ 精确匹配。\n\n测试套件规格和单位：\n- 所有域均为矩形，长度单位为米 ($\\mathrm{m}$)。网格数 $N_x$ 和 $N_y$ 为整数。所有应力系数 $a_{ij}$、$b_{ij}$ 的单位为 $\\mathrm{Pa/m}$，所有 $c_{ij}$ 的单位为 $\\mathrm{Pa}$。误差度量必须以 $\\mathrm{N/m^3}$ 为单位报告。本问题不使用角度。\n- 计算离散散度与解析 $\\mathbf{b}$ 之间在所有单元和两个散度分量上的最大绝对差异，记为 $E$（单位为 $\\mathrm{N/m^3}$）。同时，通过输出一个布尔值来报告斑块检验是否在容差 $\\varepsilon=10^{-12}\\,\\mathrm{N/m^3}$ 内被精确满足：如果 $E\\le\\varepsilon$，则输出 $\\mathrm{True}$，否则输出 $\\mathrm{False}$。\n\n提供以下三个测试用例：\n- 用例 $1$（常数应力场；边界条件合理性检查）：\n  - 域：$L_x=2\\,\\mathrm{m}$，$L_y=1\\,\\mathrm{m}$，网格：$N_x=4$，$N_y=2$。\n  - 系数：对所有 $i,j$，$a_{ij}=0\\,\\mathrm{Pa/m}$ 且 $b_{ij}=0\\,\\mathrm{Pa/m}$；$c_{11}=1000\\,\\mathrm{Pa}$，$c_{12}=-500\\,\\mathrm{Pa}$，$c_{21}=-500\\,\\mathrm{Pa}$，$c_{22}=2000\\,\\mathrm{Pa}$。\n  - 预期解析散度：恒为零；计算 $E_1$。\n\n- 用例 $2$（一般线性应力；内部斑块检验）：\n  - 域：$L_x=3\\,\\mathrm{m}$，$L_y=2\\,\\mathrm{m}$，网格：$N_x=3$，$N_y=2$。\n  - 系数：\n    - $a_{11}=300\\,\\mathrm{Pa/m}$，$b_{11}=50\\,\\mathrm{Pa/m}$，$c_{11}=100\\,\\mathrm{Pa}$，\n    - $a_{12}=-20\\,\\mathrm{Pa/m}$，$b_{12}=10\\,\\mathrm{Pa/m}$，$c_{12}=30\\,\\mathrm{Pa}$，\n    - $a_{21}=45\\,\\mathrm{Pa/m}$，$b_{21}=-15\\,\\mathrm{Pa/m}$，$c_{21}=5\\,\\mathrm{Pa}$，\n    - $a_{22}=-60\\,\\mathrm{Pa/m}$，$b_{22}=25\\,\\mathrm{Pa/m}$，$c_{22}=70\\,\\mathrm{Pa}$。\n  - 解析体力：$\\mathbf{b}=\\begin{bmatrix}310\\\\70\\end{bmatrix}\\,\\mathrm{N/m^3}$；计算 $E_2$ 和布尔值 $B_2$（指示 $E_2\\le \\varepsilon$ 是否成立）。\n\n- 用例 $3$（各向异性网格与边界单元；混合零值线性应力）：\n  - 域：$L_x=5\\,\\mathrm{m}$，$L_y=0.5\\,\\mathrm{m}$，网格：$N_x=5$，$N_y=1$。\n  - 系数：\n    - $a_{11}=0\\,\\mathrm{Pa/m}$，$b_{11}=200\\,\\mathrm{Pa/m}$，$c_{11}=10\\,\\mathrm{Pa}$，\n    - $a_{12}=0\\,\\mathrm{Pa/m}$，$b_{12}=5\\,\\mathrm{Pa/m}$，$c_{12}=20\\,\\mathrm{Pa}$，\n    - $a_{21}=-80\\,\\mathrm{Pa/m}$，$b_{21}=0\\,\\mathrm{Pa/m}$，$c_{21}=15\\,\\mathrm{Pa}$，\n    - $a_{22}=0\\,\\mathrm{Pa/m}$，$b_{22}=0\\,\\mathrm{Pa/m}$，$c_{22}=40\\,\\mathrm{Pa}$。\n  - 解析体力：$\\mathbf{b}=\\begin{bmatrix}5\\\\-80\\end{bmatrix}\\,\\mathrm{N/m^3}$；计算 $E_3$ 和布尔值 $B_3$（指示 $E_3\\le \\varepsilon$ 是否成立）。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按以下顺序排列：\n  - $[E_1,E_2,B_2,E_3,B_3]$,\n其中 $E_1$、$E_2$ 和 $E_3$ 是浮点数，表示以 $\\mathrm{N/m^3}$ 为单位的误差，而 $B_2$ 和 $B_3$ 是布尔值。不得打印任何其他文本。",
            "solution": "所提供的问题是有效的。它在连续介质力学和数值分析方面有科学依据，是适定的，具有唯一且可验证的解，并且所有术语和条件都已完整且无歧义地给出。\n\n解答将分三部分呈现，对应于问题陈述中的任务。\n\n### 任务1：常数应力场的散度\n\n第一个任务是证明空间常数应力场 $\\boldsymbol{\\sigma}(x,y) = \\boldsymbol{\\sigma}_0$ 的散度为零。$\\boldsymbol{\\sigma}_0$ 的分量是常数，我们记为 $\\sigma_{ij,0}$。张量散度的按行定义如下：\n$$ (\\nabla\\cdot\\boldsymbol{\\sigma})_i = \\sum_{j=1}^{2} \\frac{\\partial \\sigma_{ij}}{\\partial x_j} = \\frac{\\partial \\sigma_{i1}}{\\partial x} + \\frac{\\partial \\sigma_{i2}}{\\partial y} $$\n其中 $x_1=x$ 且 $x_2=y$。\n\n对于常数应力场，每个分量 $\\sigma_{ij}(x,y) = \\sigma_{ij,0}$ 都是一个常数值，与空间坐标 $x$ 和 $y$ 无关。常数对任何变量的偏导数都为零。\n$$ \\frac{\\partial \\sigma_{ij,0}}{\\partial x} = 0 \\quad \\text{和} \\quad \\frac{\\partial \\sigma_{ij,0}}{\\partial y} = 0 $$\n对所有 $i,j \\in \\{1,2\\}$。\n\n将这些代入第一个分量（$i=1$）的散度定义中：\n$$ (\\nabla\\cdot\\boldsymbol{\\sigma})_1 = \\frac{\\partial \\sigma_{11,0}}{\\partial x} + \\frac{\\partial \\sigma_{12,0}}{\\partial y} = 0 + 0 = 0 $$\n对于第二个分量（$i=2$）：\n$$ (\\nabla\\cdot\\boldsymbol{\\sigma})_2 = \\frac{\\partial \\sigma_{21,0}}{\\partial x} + \\frac{\\partial \\sigma_{22,0}}{\\partial y} = 0 + 0 = 0 $$\n因此，对于任何常数应力场，其散度矢量都是零矢量，即 $\\nabla\\cdot\\boldsymbol{\\sigma} = \\mathbf{0}$。\n\n### 任务2：离散散度算子的构建\n\n第二个任务是利用高斯散度定理的积分形式，为矩形单元构建一个离散散度算子。将该定理按行应用于单元域 $\\Omega_c$ 上的应力张量 $\\boldsymbol{\\sigma}$，可得：\n$$ \\int_{\\Omega_c} (\\nabla\\cdot\\boldsymbol{\\sigma})_i \\, \\mathrm{d}A = \\int_{\\partial\\Omega_c} (\\boldsymbol{\\sigma}\\mathbf{n})_i \\, \\mathrm{d}s $$\n其中 $(\\boldsymbol{\\sigma}\\mathbf{n})_i = \\sum_{j=1}^2 \\sigma_{ij}n_j$ 是面力矢量的第 $i$ 个分量。\n\n我们可以通过假设左侧被积函数在单元上为常数，来近似单元平均散度，我们称之为离散散度 $(\\nabla\\cdot\\boldsymbol{\\sigma})_{i,c}$：\n$$ (\\nabla\\cdot\\boldsymbol{\\sigma})_{i,c} \\cdot A_c \\approx \\int_{\\Omega_c} (\\nabla\\cdot\\boldsymbol{\\sigma})_i \\, \\mathrm{d}A $$\n其中 $A_c = h_x h_y$ 是矩形单元的面积。这引出了如下定义：\n$$ (\\nabla\\cdot\\boldsymbol{\\sigma})_{i,c} = \\frac{1}{A_c} \\int_{\\partial\\Omega_c} \\left(\\sum_{j=1}^{2}\\sigma_{ij} n_j\\right) \\, \\mathrm{d}s $$\n边界积分通过对单元四个面——右(R)、左(L)、顶(T)和底(B)——的贡献求和来计算。设单元中心位于 $(x_c, y_c)$。各面中点分别位于 $(x_c+h_x/2, y_c)$、$(x_c-h_x/2, y_c)$、$(x_c, y_c+h_y/2)$ 和 $(x_c, y_c-h_y/2)$。我们使用中点法则来近似每个面上的积分。\n\n让我们推导第一个分量 ($i=1$) 的表达式：\n- **右面 (R)**：法向量 $\\mathbf{n}=(1,0)$，长度 $h_y$。面力分量 $t_1 = \\sigma_{11}n_1 + \\sigma_{12}n_2 = \\sigma_{11}(1) + \\sigma_{12}(0) = \\sigma_{11}$。积分近似为 $\\sigma_{11}(x_c+h_x/2, y_c) \\cdot h_y$。\n- **左面 (L)**：法向量 $\\mathbf{n}=(-1,0)$，长度 $h_y$。面力分量 $t_1 = \\sigma_{11}(-1) + \\sigma_{12}(0) = -\\sigma_{11}$。积分近似为 $-\\sigma_{11}(x_c-h_x/2, y_c) \\cdot h_y$。\n- **顶面 (T)**：法向量 $\\mathbf{n}=(0,1)$，长度 $h_x$。面力分量 $t_1 = \\sigma_{11}(0) + \\sigma_{12}(1) = \\sigma_{12}$。积分近似为 $\\sigma_{12}(x_c, y_c+h_y/2) \\cdot h_x$。\n- **底面 (B)**：法向量 $\\mathbf{n}=(0,-1)$，长度 $h_x$。面力分量 $t_1 = \\sigma_{11}(0) + \\sigma_{12}(-1) = -\\sigma_{12}$。积分近似为 $-\\sigma_{12}(x_c, y_c-h_y/2) \\cdot h_x$。\n\n将这些贡献相加并除以 $A_c = h_x h_y$：\n$$ (\\nabla\\cdot\\boldsymbol{\\sigma})_{1,c} = \\frac{1}{h_x h_y} \\left[ \\sigma_{11}(x_c+\\frac{h_x}{2}, y_c)h_y - \\sigma_{11}(x_c-\\frac{h_x}{2}, y_c)h_y + \\sigma_{12}(x_c, y_c+\\frac{h_y}{2})h_x - \\sigma_{12}(x_c, y_c-\\frac{h_y}{2})h_x \\right] $$\n$$ (\\nabla\\cdot\\boldsymbol{\\sigma})_{1,c} = \\frac{\\sigma_{11}(x_c+\\frac{h_x}{2}, y_c) - \\sigma_{11}(x_c-\\frac{h_x}{2}, y_c)}{h_x} + \\frac{\\sigma_{12}(x_c, y_c+\\frac{h_y}{2}) - \\sigma_{12}(x_c, y_c-\\frac{h_y}{2})}{h_y} $$\n这是在单元中心对 $(\\nabla\\cdot\\boldsymbol{\\sigma})_1$ 的一个标准二阶中心差分近似。\n\n通过对第二个分量 ($i=2$) 进行相同的过程，我们得到：\n$$ (\\nabla\\cdot\\boldsymbol{\\sigma})_{2,c} = \\frac{\\sigma_{21}(x_c+\\frac{h_x}{2}, y_c) - \\sigma_{21}(x_c-\\frac{h_x}{2}, y_c)}{h_x} + \\frac{\\sigma_{22}(x_c, y_c+\\frac{h_y}{2}) - \\sigma_{22}(x_c, y_c-\\frac{h_y}{2})}{h_y} $$\n\n### 任务3：斑块检验验证\n\n第三个任务是验证该离散算子能精确再现分量为 $x$ 和 $y$ 的线性函数 $\\sigma_{ij}(x,y) = a_{ij}x+b_{ij}y+c_{ij}$ 的应力场的散度。解析散度为 $\\mathbf{b} = [a_{11}+b_{12}, a_{21}+b_{22}]^T$。\n\n让我们使用线性应力场来计算离散散度的第一个分量。\n第一项是 $\\sigma_{11}(x,y) = a_{11}x+b_{11}y+c_{11}$ 的有限差分：\n$$ \\frac{\\sigma_{11}(x_c+\\frac{h_x}{2}, y_c) - \\sigma_{11}(x_c-\\frac{h_x}{2}, y_c)}{h_x} = \\frac{[a_{11}(x_c+\\frac{h_x}{2}) + b_{11}y_c + c_{11}] - [a_{11}(x_c-\\frac{h_x}{2}) + b_{11}y_c + c_{11}]}{h_x} $$\n$$ = \\frac{a_{11}(x_c+\\frac{h_x}{2} - (x_c-\\frac{h_x}{2}))}{h_x} = \\frac{a_{11}h_x}{h_x} = a_{11} $$\n第二项是 $\\sigma_{12}(x,y) = a_{12}x+b_{12}y+c_{12}$ 的有限差分：\n$$ \\frac{\\sigma_{12}(x_c, y_c+\\frac{h_y}{2}) - \\sigma_{12}(x_c, y_c-\\frac{h_y}{2})}{h_y} = \\frac{[a_{12}x_c + b_{12}(y_c+\\frac{h_y}{2}) + c_{12}] - [a_{12}x_c + b_{12}(y_c-\\frac{h_y}{2}) + c_{12}]}{h_y} $$\n$$ = \\frac{b_{12}(y_c+\\frac{h_y}{2} - (y_c-\\frac{h_y}{2}))}{h_y} = \\frac{b_{12}h_y}{h_y} = b_{12} $$\n将这两个结果相加，我们得到离散散度的第一个分量：\n$$ (\\nabla\\cdot\\boldsymbol{\\sigma})_{1,c} = a_{11} + b_{12} $$\n这与解析散度矢量 $\\mathbf{b}$ 的第一个分量完全匹配。该结果与单元的位置 $(x_c, y_c)$ 和尺寸 $(h_x, h_y)$ 无关。\n\n对第二个分量 $(\\nabla\\cdot\\boldsymbol{\\sigma})_{2,c}$ 重复此过程，使用 $\\sigma_{21}$ 和 $\\sigma_{22}$：\n$$ (\\nabla\\cdot\\boldsymbol{\\sigma})_{2,c} = \\frac{\\sigma_{21}(\\dots) - \\sigma_{21}(\\dots)}{h_x} + \\frac{\\sigma_{22}(\\dots) - \\sigma_{22}(\\dots)}{h_y} = a_{21} + b_{22} $$\n这也与解析结果完全匹配。\n\n这证实了从高斯散度定理和面积分的中点法则近似构建的离散散度算子，能够通过线性应力场的斑块检验。计算出的离散散度与解析值之间的任何差异都将归因于浮点运算的限制，而不是方法的缺陷。\n\n下面的 Python 代码实现了这一验证。`run_patch_test` 函数根据推导出的公式计算网格中每个单元的离散散度。然后，它计算所有单元和两个分量上，计算值与解析散度之间的最大绝对差。将此误差与给定的容差 $\\varepsilon=10^{-12}$ 进行比较，以确定检验是否通过。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the patch test verification for all given cases.\n    \"\"\"\n    epsilon = 1e-12\n\n    # Case 1: constant stress field\n    case1_params = {\n        \"Lx\": 2.0, \"Ly\": 1.0, \"Nx\": 4, \"Ny\": 2,\n        \"coeffs\": {\n            \"c11\": 1000.0, \"c12\": -500.0, \"c21\": -500.0, \"c22\": 2000.0\n        }\n    }\n    E1 = run_patch_test(**case1_params)\n\n    # Case 2: general linear stress\n    case2_params = {\n        \"Lx\": 3.0, \"Ly\": 2.0, \"Nx\": 3, \"Ny\": 2,\n        \"coeffs\": {\n            \"a11\": 300.0, \"b11\": 50.0, \"c11\": 100.0,\n            \"a12\": -20.0, \"b12\": 10.0, \"c12\": 30.0,\n            \"a21\": 45.0, \"b21\": -15.0, \"c21\": 5.0,\n            \"a22\": -60.0, \"b22\": 25.0, \"c22\": 70.0,\n        }\n    }\n    E2 = run_patch_test(**case2_params)\n    B2 = E2 = epsilon\n\n    # Case 3: anisotropic grid with mixed-zero linear stress\n    case3_params = {\n        \"Lx\": 5.0, \"Ly\": 0.5, \"Nx\": 5, \"Ny\": 1,\n        \"coeffs\": {\n            \"a11\": 0.0, \"b11\": 200.0, \"c11\": 10.0,\n            \"a12\": 0.0, \"b12\": 5.0, \"c12\": 20.0,\n            \"a21\": -80.0, \"b21\": 0.0, \"c21\": 15.0,\n            \"a22\": 0.0, \"b22\": 0.0, \"c22\": 40.0,\n        }\n    }\n    E3 = run_patch_test(**case3_params)\n    B3 = E3 = epsilon\n\n    results = [E1, E2, B2, E3, B3]\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_patch_test(Lx, Ly, Nx, Ny, coeffs):\n    \"\"\"\n    Computes discrete divergence on a grid and returns the maximum error.\n\n    Args:\n        Lx (float): Domain length in x-direction.\n        Ly (float): Domain length in y-direction.\n        Nx (int): Number of cells in x-direction.\n        Ny (int): Number of cells in y-direction.\n        coeffs (dict): Dictionary of stress coefficients a_ij, b_ij, c_ij.\n\n    Returns:\n        float: The maximum absolute error between discrete and analytical divergence.\n    \"\"\"\n    hx = Lx / Nx\n    hy = Ly / Ny\n\n    # Define stress component functions based on coefficients\n    # Use .get(key, 0.0) to handle missing coefficients (implicitly zero)\n    def s11(x, y): return coeffs.get('a11', 0.0)*x + coeffs.get('b11', 0.0)*y + coeffs.get('c11', 0.0)\n    def s12(x, y): return coeffs.get('a12', 0.0)*x + coeffs.get('b12', 0.0)*y + coeffs.get('c12', 0.0)\n    def s21(x, y): return coeffs.get('a21', 0.0)*x + coeffs.get('b21', 0.0)*y + coeffs.get('c21', 0.0)\n    def s22(x, y): return coeffs.get('a22', 0.0)*x + coeffs.get('b22', 0.0)*y + coeffs.get('c22', 0.0)\n\n    # Calculate analytical body force (divergence) vector\n    b_analytical_1 = coeffs.get('a11', 0.0) + coeffs.get('b12', 0.0)\n    b_analytical_2 = coeffs.get('a21', 0.0) + coeffs.get('b22', 0.0)\n\n    max_error = 0.0\n\n    # Iterate over all cells in the grid\n    for iy in range(Ny):\n        for ix in range(Nx):\n            # Coordinates of cell face midpoints\n            x_center = (ix + 0.5) * hx\n            y_center = (iy + 0.5) * hy\n            \n            x_right_face_mid_x = (ix + 1.0) * hx\n            x_left_face_mid_x = ix * hx\n            y_top_face_mid_y = (iy + 1.0) * hy\n            y_bottom_face_mid_y = iy * hy\n\n            # Evaluate stress components at face midpoints\n            # Use midpoints of faces, not cell center for x/y in other directions\n            s11_r = s11(x_right_face_mid_x, y_center)\n            s11_l = s11(x_left_face_mid_x, y_center)\n            s12_t = s12(x_center, y_top_face_mid_y)\n            s12_b = s12(x_center, y_bottom_face_mid_y)\n\n            s21_r = s21(x_right_face_mid_x, y_center)\n            s21_l = s21(x_left_face_mid_x, y_center)\n            s22_t = s22(x_center, y_top_face_mid_y)\n            s22_b = s22(x_center, y_bottom_face_mid_y)\n\n\n            # Compute discrete divergence for the cell\n            div_s_1 = (s11_r - s11_l) / hx + (s12_t - s12_b) / hy\n            div_s_2 = (s21_r - s21_l) / hx + (s22_t - s22_b) / hy\n\n            # Calculate error for this cell\n            error1 = abs(div_s_1 - b_analytical_1)\n            error2 = abs(div_s_2 - b_analytical_2)\n\n            # Update maximum error\n            max_error = max(max_error, error1, error2)\n\n    return max_error\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "真实的岩土力学区域很少是简单的。隧道、洞穴或地质包体都会形成“多连通”区域（即带有孔洞的区域）。本实践将高斯散度定理的应用扩展到此类几何形状上，并强调边界方向定义的关键作用。你将为一个包含内部空腔的区域实施该定理，学习如何正确计算外边界和内边界上的通量。",
            "id": "3516962",
            "problem": "考虑一个二维多连通域，它有一个外边界和零个或多个内空腔边界。在计算地质力学中，体积通量密度场由一个至少连续可微的向量场 $\\mathbf{v}(x,y)$ 表示，散度算子 $\\nabla \\cdot \\mathbf{v}$ 代表局部体积源密度。从质量守恒的积分表述和适用于单连通域（无空腔）的高斯（散度）定理出发，通过切除子域并将该原理应用于每一部分，推导当域包含空腔时边界通量的正确符号结构，并注意外法线的定义。证明多连通域上的散度积分等于通过外边界的向外通量减去通过每个空腔边界的向外通量，当这些空腔边界取与外边界相同的几何方向时。解释符号反转为何产生于相对于域，外法线指向空腔内部。\n\n然后，您必须设计一个算法，对于任何多边形外边界和多边形空腔边界，计算仿射（线性）向量场 $\\mathbf{v}(x,y) = \\big(a x + b y + c,\\; d x + e y + f\\big)$（其散度为常数 $\\nabla \\cdot \\mathbf{v} = a + e$）的两个量：\n- 面积分 $\\iint_{\\Omega} \\nabla \\cdot \\mathbf{v}\\, dA$，根据有符号多边形面积计算。\n- 边界通量积分 $\\oint_{\\partial \\Omega} \\mathbf{v}\\cdot \\mathbf{n}\\, ds$，使用单位外法向量 $\\mathbf{n}$ 和弧长 $ds$ 为多边形链计算。\n\n您的算法必须仅依赖于基本定义，不得假定任何预先推导出的用于多连通域的公式。对于一个正向（逆时针）的简单闭合曲线 $\\Gamma$，向外通量积分可以表示为\n$$\n\\oint_{\\Gamma} \\mathbf{v}\\cdot \\mathbf{n}\\, ds \\;=\\; \\oint_{\\Gamma} \\big(v_x\\, dy - v_y\\, dx\\big),\n$$\n其中 $v_x$ 和 $v_y$ 表示 $\\mathbf{v}$ 的分量，$dx$ 和 $dy$ 是微分位移，且曲线以逆时针方向参数化。仅在从第一性原理证明后才能使用此恒等式。对于顶点按顺序为 $(x_i,y_i)$ 的多边形链，通过沿每条直线段积分来精确计算该积分。\n\n所有量都是无量纲的，下文出现的所有角度均应解释为弧度。\n\n实现一个程序来评估以下测试套件。对于每个测试用例，计算两个实数：\n- 面积分 $\\iint_{\\Omega} \\nabla \\cdot \\mathbf{v}\\, dA$ 与正确定向的边界通量之间的绝对差，其中内空腔边界的方向相对于外边界（逆时针）反转，使其外法线相对于域是向外的。\n- 面积分 $\\iint_{\\Omega} \\nabla \\cdot \\mathbf{v}\\, dA$ 与错误定向的边界通量之间的绝对差，其中内空腔边界采用与外边界相同的逆时针方向（即，未反转），这用于测试对内边界方向的敏感性。\n\n测试用例 A（含两个空腔的岩溶型示例）：\n- 向量场：$\\mathbf{v}(x,y) = \\big(2 x + y + 1,\\; -x + 4 y - 2\\big)$，因此 $\\nabla \\cdot \\mathbf{v} = 2 + 4 = 6$。\n- 外边界多边形（逆时针）：$(0,0)\\to(4,0)\\to(4,2)\\to(0,2)$。\n- 空腔 1：一个中心在 $(1,1)$、半径为 $0.3$ 的正八边形，顶点由 $(1 + 0.3 \\cos \\theta_k,\\; 1 + 0.3 \\sin \\theta_k)$ 给出，对于 $\\theta_k = k \\pi/4$, $k \\in \\{0,1,2,3,4,5,6,7\\}$，按 $k$ 递增（逆时针）列出。\n- 空腔 2：一个中心在 $(3,1)$、半径为 $0.25$ 的正八边形，顶点由 $(3 + 0.25 \\cos \\theta_k,\\; 1 + 0.25 \\sin \\theta_k)$ 给出，对于 $\\theta_k = k \\pi/4$, $k \\in \\{0,1,2,3,4,5,6,7\\}$，按 $k$ 递增（逆时针）列出。\n\n测试用例 B（零散度场）：\n- 向量场：$\\mathbf{v}(x,y) = \\big(-y,\\; x\\big)$，因此 $\\nabla \\cdot \\mathbf{v} = 0 + 0 = 0$。\n- 外边界多边形（逆时针）：$(0,0)\\to(2,0)\\to(2,2)\\to(0,2)$。\n- 空腔 1：正方形 $(0.5,0.5)\\to(1.5,0.5)\\to(1.5,1.5)\\to(0.5,1.5)$，按逆时针列出。\n\n测试用例 C（含一个空腔的非凸外边界）：\n- 向量场：$\\mathbf{v}(x,y) = \\big(x + 2,\\; y - 1\\big)$，因此 $\\nabla \\cdot \\mathbf{v} = 1 + 1 = 2$。\n- 外边界多边形（逆时针，L形）：$(0,0)\\to(3,0)\\to(3,1)\\to(1,1)\\to(1,3)\\to(0,3)$。\n- 空腔 1（三角形，逆时针）：$(0.3,2.2)\\to(0.8,2.1)\\to(0.6,2.6)$。\n\n您的程序必须：\n- 使用有符号的鞋带公式计算外边界和每个空腔的多边形面积，并将域面积取为外边界面积减去空腔面积之和。\n- 使用分段积分 $\\int (v_x\\, dy - v_y\\, dx)$（对于仿射场 $\\mathbf{v}$ 在直线段上是精确的）计算每个多边形边界上向外通量的精确线积分。\n- 将正确定向的总边界通量构造为外边界通量加上所有取反转方向的空腔边界通量之和（等效地，作为外边界通量减去所有取逆时针方向的空腔边界通量之和）。\n- 将错误定向的总边界通量构造为外边界通量加上所有取逆时针方向的空腔边界通量之和（即，未反转）。\n- 为每个测试用例报告两个浮点数：分别对应于正确和错误方向的绝对误差。\n\n最终输出格式：您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按顺序包含六个浮点数：\n$[\\text{A\\_correct}, \\text{A\\_incorrect}, \\text{B\\_correct}, \\text{B\\_incorrect}, \\text{C\\_correct}, \\text{C\\_incorrect}]$,\n其中每个条目是为相应测试用例定义的绝对差。",
            "solution": "本问题要求推导多连通域上的散度定理，并设计一个算法，用于在多边形域上验证仿射向量场的该定理。\n\n### 第一部分：理论推导\n\n二维高斯散度定理，也称为散度形式的格林公式，为域内向量场的总散度与穿过其边界的场通量之间提供了基本关系。对于一个单连通域 $\\Omega_s \\subset \\mathbb{R}^2$，其边界 $\\partial\\Omega_s$ 为分段光滑、正向（逆时针，CCW）定向，且向量场 $\\mathbf{v}(x,y) = \\big(v_x(x,y), v_y(x,y)\\big)$ 连续可微，该定理表述为：\n$$\n\\iint_{\\Omega_s} (\\nabla \\cdot \\mathbf{v}) \\, dA = \\oint_{\\partial\\Omega_s} \\mathbf{v} \\cdot \\mathbf{n} \\, ds\n$$\n其中 $\\nabla \\cdot \\mathbf{v} = \\frac{\\partial v_x}{\\partial x} + \\frac{\\partial v_y}{\\partial y}$ 是 $\\mathbf{v}$ 的散度，$\\mathbf{n}$ 是指向边界 $\\partial\\Omega_s$ 外部的单位法向量。量 $\\mathbf{v} \\cdot \\mathbf{n}$ 表示垂直于边界的通量密度分量，线积分给出了流出该域的总通量。\n\n问题考虑一个多连通域 $\\Omega$，它由一个外边界 $\\Gamma_0$ 和 $M$ 个不重叠的内空腔边界 $\\Gamma_1, \\Gamma_2, \\dots, \\Gamma_M$ 定义。域 $\\Omega$ 是由 $\\Gamma_0$ 包围但在所有 $\\Gamma_i$ ($i=1, \\dots, M$) 之外的区域。散度定理的基本形式不直接适用于 $\\Omega$，因为它不是单连通的。\n\n为了应用该定理，我们将 $\\Omega$ 转换为一个单连通域。这可以通过引入一组不相交的“切口”来实现，这些切口连接各个边界。对于每个内边界 $\\Gamma_i$，我们引入一个由两条无限接近的路径 $C_i^+$ 和 $C_i^-$ 定义的狭窄通道，将其连接到外边界 $\\Gamma_0$（或连接到另一个已经连接的内边界）。通过切除这些通道，我们获得一个新的单连通域 $\\Omega'$。$\\Omega'$ 的面积与 $\\Omega$ 的面积相同。\n\n这个新域的边界 $\\partial\\Omega'$ 由原始外边界 $\\Gamma_0$、内边界 $\\Gamma_i$ 以及构成切口的路径组成。让我们将 $\\Gamma_0$ 定向为逆时针（CCW），所有内边界 $\\Gamma_i$ 也定向为CCW。$\\Omega'$ 的边界必须以$\\Omega'$域始终在左侧的方式遍历。这意味着：\n- $\\Gamma_0$ 沿着其原始的CCW方向遍历。\n- 从 $\\Gamma_0$ 到 $\\Gamma_i$ 的每个切口被遍历，例如沿着 $C_i^+$。\n- 每个内边界 $\\Gamma_i$ 沿顺时针（CW）方向遍历。\n- 每个切口从 $\\Gamma_i$ 沿 $C_i^-$ 返回到 $\\Gamma_0$。\n\n对单连通域 $\\Omega'$ 应用散度定理，得到：\n$$\n\\iint_{\\Omega'} (\\nabla \\cdot \\mathbf{v}) \\, dA = \\oint_{\\partial\\Omega'} \\mathbf{v} \\cdot \\mathbf{n} \\, ds\n$$\n由于 $\\text{Area}(\\Omega') = \\text{Area}(\\Omega)$，左侧即为 $\\iint_{\\Omega} (\\nabla \\cdot \\mathbf{v}) \\, dA$。右侧的边界积分可以分解为：\n$$\n\\oint_{\\partial\\Omega'} \\mathbf{v} \\cdot \\mathbf{n} \\, ds = \\oint_{\\Gamma_0} \\mathbf{v} \\cdot \\mathbf{n} \\, ds + \\sum_{i=1}^M \\left( \\oint_{\\Gamma_i} \\mathbf{v} \\cdot \\mathbf{n} \\, ds + \\int_{C_i^+} \\mathbf{v} \\cdot \\mathbf{n} \\, ds + \\int_{C_i^-} \\mathbf{v} \\cdot \\mathbf{n} \\, ds \\right)\n$$\n当路径 $C_i^+$ 和 $C_i^-$ 变得无限接近时，它们沿着相同的几何线但方向相反。这些路径上的外法向量也指向相反方向。因此，它们对积分的贡献相互抵消：$\\int_{C_i^+} \\mathbf{v} \\cdot \\mathbf{n} \\, ds + \\int_{C_i^-} \\mathbf{v} \\cdot \\mathbf{n} \\, ds = 0$。\n\n这将定理简化为：\n$$\n\\iint_{\\Omega} (\\nabla \\cdot \\mathbf{v}) \\, dA = \\oint_{\\Gamma_0, \\text{CCW}} \\mathbf{v} \\cdot \\mathbf{n}_{\\text{out}} \\, ds + \\sum_{i=1}^M \\oint_{\\Gamma_i, \\text{CW}} \\mathbf{v} \\cdot \\mathbf{n}_{\\text{out}} \\, ds\n$$\n这里，$\\mathbf{n}_{\\text{out}}$ 是从域 $\\Omega$ 向外指的法向量。\n- 对于外边界 $\\Gamma_0$（CCW定向），$\\mathbf{n}_{\\text{out}}$ 是标准的外法线。\n- 对于内边界 $\\Gamma_i$，域 $\\Omega$ 位于空腔的外部。因此，外法线 $\\mathbf{n}_{\\text{out}}$ 从 $\\Omega$ 指向空腔内部。\n\n如果我们为任意简单闭合曲线 $\\Gamma$ 定义一个标准通量，即通过其以标准CCW定向的边界的通量，记作 $\\text{Flux}(\\Gamma, \\text{CCW})$。此标准定义下的外法线指向远离 $\\Gamma$ 所包围区域的方向。对于内边界 $\\Gamma_i$，这个标准法线与 $\\mathbf{n}_{\\text{out}}$（指向空腔内部）方向相反。因此，$\\oint_{\\Gamma_i, \\text{CW}} \\mathbf{v} \\cdot \\mathbf{n}_{\\text{out}} \\, ds = -\\oint_{\\Gamma_i, \\text{CCW}} \\mathbf{v} \\cdot (-\\mathbf{n}_{\\text{out}}) \\, ds$。同样，反转路径积分方向会使积分值变号：$\\oint_{\\text{CW}} = - \\oint_{\\text{CCW}}$。\n\n设 $\\text{Flux}(\\Gamma_i, \\text{CCW})$ 是穿过CCW定向的 $\\Gamma_i$ 的通量，使用的法线指向远离空腔中心。那么，在 $\\Gamma_i$ 上相对于 $\\Omega$ 的通量是 $-\\text{Flux}(\\Gamma_i, \\text{CCW})$。这就解释了符号反转的原因。总通量是流出外边界的通量减去从空腔流入域内的通量（这对应于流出空腔的通量）。\n多连通域的最终正确公式为：\n$$\n\\iint_{\\Omega} (\\nabla \\cdot \\mathbf{v}) \\, dA = \\text{Flux}(\\Gamma_0, \\text{CCW}) - \\sum_{i=1}^M \\text{Flux}(\\Gamma_i, \\text{CCW})\n$$\n这与所要求的结构相符，即首先使用一致的CCW方向计算所有边界的通量，然后用适当的符号将它们组合起来。\n\n为方便计算，我们使用恒等式 $\\oint_{\\Gamma} \\mathbf{v} \\cdot \\mathbf{n} \\, ds = \\oint_{\\Gamma} (v_x dy - v_y dx)$，其中 $\\Gamma$ 是CCW定向的曲线。这可以通过弧长 $s$ 参数化曲线来证明，$\\mathbf{r}(s) = (x(s), y(s))$。单位切向量是 $\\mathbf{t} = d\\mathbf{r}/ds = (dx/ds, dy/ds)$。对于CCW曲线，外法向量是 $\\mathbf{n} = (dy/ds, -dx/ds)$。点积为 $\\mathbf{v} \\cdot \\mathbf{n} = v_x(dy/ds) - v_y(dx/ds)$。对 $s$ 积分得到 $\\int (v_x(dy/ds) - v_y(dx/ds))ds = \\oint (v_x dy - v_y dx)$。\n\n### 第二部分：算法设计\n\n该算法必须为给定的仿射向量场 $\\mathbf{v}(x,y) = (ax + by + c, dx + ey + f)$ 和由多边形边界定义的域 $\\Omega$ 计算推导出的定理的两边。\n\n**1. 面积分计算：**\n仿射场 $\\mathbf{v}$ 的散度是一个常数：$\\nabla \\cdot \\mathbf{v} = a + e$。\n因此，面积分为：\n$$\nI_A = \\iint_{\\Omega} (\\nabla \\cdot \\mathbf{v}) \\, dA = (a+e) \\iint_{\\Omega} dA = (a+e) \\cdot \\text{Area}(\\Omega)\n$$\n多连通域 $\\Omega$ 的面积是外多边形 $\\Gamma_0$ 的面积减去空腔多边形 $\\Gamma_i$ 的面积之和。\n$$\n\\text{Area}(\\Omega) = \\text{Area}(\\Gamma_0) - \\sum_{i=1}^M \\text{Area}(\\Gamma_i)\n$$\n顶点按CCW顺序排列的简单多边形 $(x_0, y_0), (x_1, y_1), \\dots, (x_{N-1}, y_{N-1})$ 的面积使用鞋带公式计算，该公式给出正的有符号面积：\n$$\n\\text{Area}(\\text{polygon}) = \\frac{1}{2} \\sum_{j=0}^{N-1} (x_j y_{j+1} - x_{j+1} y_j), \\quad \\text{with } (x_N, y_N) = (x_0, y_0)\n$$\n由于所有给定的多边形都是CCW定向的，用此公式计算的面积将为正值，相减后得到 $\\Omega$ 的正确面积。\n\n**2. 边界通量积分计算：**\n总边界通量通过对每个边界多边形以正确方向的贡献求和来计算。我们使用恒等式 $\\oint (v_x dy - v_y dx)$。对于多边形边界，该积分变为其各直线段上积分的总和。\n考虑从 $P_j = (x_j, y_j)$ 到 $P_{j+1} = (x_{j+1}, y_{j+1})$ 的单个线段。我们可以将其参数化为 $\\mathbf{r}(t) = (x_j + t\\Delta x_j, y_j + t\\Delta y_j)$，对于 $t \\in [0,1]$，其中 $\\Delta x_j = x_{j+1}-x_j$ 且 $\\Delta y_j = y_{j+1}-y_j$。微分量为 $dx = \\Delta x_j dt$ 和 $dy = \\Delta y_j dt$。\n该线段的积分为：\n$$\n\\int_{P_j}^{P_{j+1}} (v_x dy - v_y dx) = \\int_0^1 [v_x(\\mathbf{r}(t)) \\Delta y_j - v_y(\\mathbf{r}(t)) \\Delta x_j] dt\n$$\n由于 $\\mathbf{v}$ 是仿射的，分量 $v_x$ 和 $v_y$ 是 $x$ 和 $y$ 的线性函数。因此，被积函数 $v_x(\\mathbf{r}(t)) \\Delta y_j - v_y(\\mathbf{r}(t)) \\Delta x_j$ 是参数 $t$ 的线性函数。线性函数在区间上的积分恰好等于该区间中点处的值乘以区间长度。在此参数化中，中点对应于 $t=1/2$，区间长度为1。线段的中点坐标为 $(\\bar{x}_j, \\bar{y}_j) = (\\frac{x_j+x_{j+1}}{2}, \\frac{y_j+y_{j+1}}{2})$。\n因此，该线段的通量贡献的精确值为：\n$$\n\\text{Flux}_j = v_x(\\bar{x}_j, \\bar{y}_j) \\Delta y_j - v_y(\\bar{x}_j, \\bar{y}_j) \\Delta x_j\n$$\n一个多边形的总通量 $\\text{Flux}(\\Gamma, \\text{CCW})$ 是其所有边上这些线段通量的总和。\n\n**3. 验证：**\n对于每个测试用例，算法计算：\n- 面积分：$I_A = (a+e) \\left( \\text{Area}(\\Gamma_0) - \\sum \\text{Area}(\\Gamma_i) \\right)$。\n- 每个边界（外边界 $\\Gamma_0$ 和空腔 $\\Gamma_i$）使用CCW方向的通量：$I_{B,0}, I_{B,i}$。\n- 正确定向的总边界通量：$I_{B,\\text{correct}} = I_{B,0} - \\sum I_{B,i}$。\n- 错误定向的总边界通量：$I_{B,\\text{incorrect}} = I_{B,0} + \\sum I_{B,i}$。\n最后，它计算绝对差：\n- $\\text{Error}_{\\text{correct}} = | I_A - I_{B,\\text{correct}} |$\n- $\\text{Error}_{\\text{incorrect}} = | I_A - I_{B,\\text{incorrect}} |$\n\n$\\text{Error}_{\\text{correct}}$ 的值预期为零（或在浮点容差范围内），从而验证该定理。$\\text{Error}_{\\text{incorrect}}$ 的值通常为非零，突显了边界方向的关键作用。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ... (scipy is not required for this problem)\n\ndef solve():\n    \"\"\"\n    Solves the problem by defining test cases, computing integrals,\n    and reporting the specified differences.\n    \"\"\"\n\n    def polygon_area(vertices):\n        \"\"\"\n        Calculates the signed area of a polygon using the shoelace formula.\n        Assumes vertices are given in order (e.g., counter-clockwise).\n        \"\"\"\n        area = 0.0\n        n = len(vertices)\n        for i in range(n):\n            j = (i + 1) % n\n            area += vertices[i, 0] * vertices[j, 1]\n            area -= vertices[j, 0] * vertices[i, 1]\n        return area / 2.0\n\n    def calculate_flux(polygon_vertices, v_params):\n        \"\"\"\n        Calculates the CCW boundary flux integral for a single polygon.\n        The integral is computed exactly for an affine vector field by summing\n        segment-wise contributions evaluated at the midpoint of each segment.\n        \"\"\"\n        a, b, c, d, e, f = v_params\n        total_flux = 0.0\n        n = len(polygon_vertices)\n        for i in range(n):\n            p1 = polygon_vertices[i]\n            p2 = polygon_vertices[(i + 1) % n]\n            \n            x1, y1 = p1\n            x2, y2 = p2\n            \n            dx = x2 - x1\n            dy = y2 - y1\n            \n            # Midpoint of the segment\n            mid_x = (x1 + x2) / 2.0\n            mid_y = (y1 + y2) / 2.0\n            \n            # Evaluate vector field components at the midpoint\n            v_x_mid = a * mid_x + b * mid_y + c\n            v_y_mid = d * mid_x + e * mid_y + f\n            \n            # Add segment contribution to the total flux\n            segment_flux = v_x_mid * dy - v_y_mid * dx\n            total_flux += segment_flux\n            \n        return total_flux\n\n    def generate_regular_polygon_vertices(center, radius, n_vertices):\n        \"\"\"Generates vertices for a regular polygon.\"\"\"\n        cx, cy = center\n        vertices = []\n        for k in range(n_vertices):\n            # The problem specifies k*pi/4 for an octagon, which is 2*pi*k/8.\n            theta = k * 2.0 * np.pi / n_vertices\n            x = cx + radius * np.cos(theta)\n            y = cy + radius * np.sin(theta)\n            vertices.append((x, y))\n        return np.array(vertices)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"name\": \"A\",\n            \"v_params\": (2, 1, 1, -1, 4, -2),  # a,b,c, d,e,f\n            \"outer_poly\": np.array([(0., 0.), (4., 0.), (4., 2.), (0., 2.)]),\n            \"cavity_polys\": [\n                generate_regular_polygon_vertices(center=(1.0, 1.0), radius=0.3, n_vertices=8),\n                generate_regular_polygon_vertices(center=(3.0, 1.0), radius=0.25, n_vertices=8)\n            ]\n        },\n        {\n            \"name\": \"B\",\n            \"v_params\": (0, -1, 0, 1, 0, 0),\n            \"outer_poly\": np.array([(0., 0.), (2., 0.), (2., 2.), (0., 2.)]),\n            \"cavity_polys\": [\n                np.array([(0.5, 0.5), (1.5, 0.5), (1.5, 1.5), (0.5, 1.5)])\n            ]\n        },\n        {\n            \"name\": \"C\",\n            \"v_params\": (1, 0, 2, 0, 1, -1),\n            \"outer_poly\": np.array([(0., 0.), (3., 0.), (3., 1.), (1., 1.), (1., 3.), (0., 3.)]),\n            \"cavity_polys\": [\n                np.array([(0.3, 2.2), (0.8, 2.1), (0.6, 2.6)])\n            ]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        v_params = case[\"v_params\"]\n        outer_poly = case[\"outer_poly\"]\n        cavity_polys = case[\"cavity_polys\"]\n\n        # 1. Compute Area Integral\n        divergence = v_params[0] + v_params[4]  # a + e\n        \n        area_outer = polygon_area(outer_poly)\n        area_cavities = sum(polygon_area(cavity) for cavity in cavity_polys)\n        domain_area = area_outer - area_cavities\n        \n        area_integral = divergence * domain_area\n\n        # 2. Compute Boundary Flux Integral\n        flux_outer = calculate_flux(outer_poly, v_params)\n        flux_cavities = [calculate_flux(cavity, v_params) for cavity in cavity_polys]\n        sum_flux_cavities = sum(flux_cavities)\n\n        # Correctly oriented flux (Outer - Cavities)\n        flux_correct = flux_outer - sum_flux_cavities\n        \n        # Incorrectly oriented flux (Outer + Cavities)\n        flux_incorrect = flux_outer + sum_flux_cavities\n\n        # 3. Compute absolute differences\n        diff_correct = abs(area_integral - flux_correct)\n        diff_incorrect = abs(area_integral - flux_incorrect)\n        \n        results.extend([diff_correct, diff_incorrect])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.12f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "虽然分片检验等验证性测试可以确认基线的正确性，但真实的模拟涉及复杂的场和不完美的网格，此时离散算子并非完全精确。最后的这个实践将从“验证”转向“精度分析”。你将设计一个数值实验，在一个畸变的网格单元上测量离散高斯定理的误差，从而深入理解网格质量如何影响模拟的准确性。",
            "id": "3516994",
            "problem": "您的任务是设计并实现一个数值实验，以在具有各向异性渗透率的多孔介质中的达西流背景下，评估高斯散度定理的一个离散版本。目标是量化对于单个多面体控制体，随着控制体畸变程度的增加，达西通量散度的近似体积分与通过该控制体边界面通量的近似总和之间的差异。\n\n从以下基础出发：\n- 多孔介质中稳定不可压缩流的达西定律：比流量（达西通量）由 $\\boldsymbol{q} = -\\boldsymbol{K}\\,\\nabla h$ 给出，其中 $\\boldsymbol{K}$ 是对称正定渗透率张量，而 $h$ 是水头。\n- 散度定理：对于控制体 $K \\subset \\mathbb{R}^3$ 上的一个足够光滑的矢量场 $\\boldsymbol{q}$，其单位外法向量为 $\\boldsymbol{n}$，\n$$\n\\int_K \\nabla\\cdot\\boldsymbol{q}\\,dV \\;=\\; \\int_{\\partial K} \\boldsymbol{q}\\cdot \\boldsymbol{n}\\,dA \\;=\\; \\sum_{f\\subset\\partial K} \\int_f \\boldsymbol{q}\\cdot\\boldsymbol{n}\\,dA.\n$$\n\n实验设计（必须严格遵守以确保普适性和可测试性）：\n1. 几何与畸变：\n   - 将控制体 $K_{\\delta}$ 表示为参考立方体 $[0,1]^3$ 的仿射像，通过 $x(\\boldsymbol{\\xi}) = \\boldsymbol{A}(\\delta)\\,\\boldsymbol{\\xi} + \\boldsymbol{b}$，其中 $\\boldsymbol{\\xi}\\in[0,1]^3$，$\\boldsymbol{b}=\\boldsymbol{0}$，且\n     $$\n     \\boldsymbol{A}(\\delta) \\;=\\; \\begin{bmatrix} 1  \\delta  0 \\\\ 0  1  \\delta \\\\ 0  0  1 \\end{bmatrix}.\n     $$\n     此处 $\\delta\\ge 0$ 是一个畸变参数；$\\delta=0$ 对应单位立方体，更大的 $\\delta$ 会产生剪切（因而畸变）程度更高的多面体。其体积为 $|K_{\\delta}| = \\det(\\boldsymbol{A}(\\delta))$。\n   - $K_{\\delta}$ 的六个面对应于 $i\\in\\{1,2,3\\}$ 的平面 $\\xi_i=0$ 和 $\\xi_i=1$。对于具有固定索引 $i$ 的面，按循环顺序列出其他索引为 $(j,k)$，使得 $(i,j,k)$ 是 $(1,2,3)$ 的一个轮换。\n\n2. 各向异性渗透率与通量：\n   - 设 $\\boldsymbol{K}$ 为常数且各向异性，通过旋转一个具有特征值 $k_10$、$k_20$、$k_30$ 的对角张量来构建。具体定义为\n     $$\n     \\boldsymbol{K}(\\theta, r) \\;=\\; \\boldsymbol{R}(\\theta)\\,\\mathrm{diag}(r,\\;1,\\;r^{-1})\\,\\boldsymbol{R}(\\theta)^{\\top},\n     $$\n     其中 $\\theta$ 是围绕固定单位轴 $\\boldsymbol{u} = \\frac{1}{\\sqrt{1^2+2^2+3^2}}[1,2,3]^{\\top}$ 的旋转角（以弧度为单位），$r\\ge 1$ 是各向异性比。旋转矩阵 $\\boldsymbol{R}(\\theta)$ 应使用罗德里格斯公式构建，并且必须是行列式为 $+1$ 的正交矩阵。\n   - 将水头场定义为三次多项式\n     $$\n     h(x,y,z) \\;=\\; \\alpha\\,x^3 + \\beta\\,y^3 + \\gamma\\,z^3 + \\delta_h\\, x\\,y\\,z,\n     $$\n     具有固定系数 $\\alpha=0.7$，$\\beta=-0.2$，$\\gamma=0.5$，$\\delta_h=0.3$。达西通量为 $\\boldsymbol{q}(x) = -\\boldsymbol{K}\\,\\nabla h(x)$。\n\n3. 实验所需的微分算子：\n   - 梯度为\n     $$\n     \\nabla h(x,y,z) \\;=\\; \\begin{bmatrix} 3\\alpha\\,x^2 + \\delta_h\\,y\\,z \\\\ 3\\beta\\,y^2 + \\delta_h\\,x\\,z \\\\ 3\\gamma\\,z^2 + \\delta_h\\,x\\,y \\end{bmatrix}.\n     $$\n   - 海森矩阵为\n     $$\n     \\nabla^2 h(x,y,z) \\;=\\; \\begin{bmatrix}\n     6\\alpha\\,x  \\delta_h\\,z  \\delta_h\\,y \\\\\n     \\delta_h\\,z  6\\beta\\,y  \\delta_h\\,x \\\\\n     \\delta_h\\,y  \\delta_h\\,x  6\\gamma\\,z\n     \\end{bmatrix}.\n     $$\n   - 由于 $\\boldsymbol{K}$ 在空间上是常数，达西通量的散度为\n     $$\n     \\nabla\\cdot\\boldsymbol{q}(x) \\;=\\; -\\mathrm{tr}\\big(\\boldsymbol{K}\\,\\nabla^2 h(x)\\big),\n     $$\n     这是一个关于 $x$ 的仿射（线性）函数。\n\n4. 待比较的离散近似：\n   - 在 $K_{\\delta}$ 的形心 $x_c$ 处使用单点法则来近似体积分：\n     $$\n     \\int_{K_{\\delta}} \\nabla\\cdot\\boldsymbol{q}\\,dV \\;\\approx\\; |K_{\\delta}| \\,\\big(\\nabla\\cdot\\boldsymbol{q}\\big)(x_c), \\quad x_c = \\boldsymbol{A}(\\delta)\\,\\begin{bmatrix} \\tfrac12 \\\\ \\tfrac12 \\\\ \\tfrac12 \\end{bmatrix}.\n     $$\n   - 在物理面中心使用单点法则来近似每个面积分。对于面 $\\xi_i=c$（其中 $c\\in\\{0,1\\}$），使用 $\\boldsymbol{\\xi}$-中心 $\\boldsymbol{\\xi}_f = (1/2,1/2,1/2)^{\\top}$（将其第 $i$ 个分量替换为 $c$），并将其映射到 $x_f=\\boldsymbol{A}(\\delta)\\,\\boldsymbol{\\xi}_f$。该面的有向面积矢量为\n     $$\n     \\boldsymbol{a}_{i,c} \\;=\\; s_{i,c}\\,\\big(\\partial_{\\xi_j}x \\times \\partial_{\\xi_k}x\\big) \\;=\\; s_{i,c}\\,\\big(\\boldsymbol{A}\\,\\boldsymbol{e}_j \\times \\boldsymbol{A}\\,\\boldsymbol{e}_k\\big),\n     $$\n     其中对于 $c=1$， $s_{i,c}=+1$；对于 $c=0$，$s_{i,c}=-1$，并且 $(i,j,k)$ 是循环的，使得 $\\boldsymbol{e}_j \\times \\boldsymbol{e}_k = \\boldsymbol{e}_i$。离散面通量为 $\\boldsymbol{q}(x_f)\\cdot \\boldsymbol{a}_{i,c}$。离散曲面和是这六个面贡献的总和。\n\n5. 误差度量：\n   - 定义标量差异\n     $$\n     E \\;=\\; \\frac{\\big|\\;|K_{\\delta}|\\,(\\nabla\\cdot\\boldsymbol{q})(x_c) \\;-\\; \\sum_{f\\subset\\partial K_{\\delta}} \\boldsymbol{q}(x_f)\\cdot \\boldsymbol{a}_f\\;\\big|}{\\max\\big(1,\\;\\big|\\,|K_{\\delta}|\\,(\\nabla\\cdot\\boldsymbol{q})(x_c)\\,\\big|\\big)}.\n     $$\n     这是一个无量纲量。答案中无需物理单位。\n\n您的程序必须实现上述内容，并为下面的测试套件中的每个测试用例计算 $E$。在指定的地方使用项目1-4中的精确公式，并按规定使用单点法则。不要使用任何外部网格或数据文件。角度必须以弧度为单位进行解释。\n\n测试套件：\n- 用例1（基准，无几何畸变，对齐的各向异性）：$\\delta=0.0$, $r=10.0$, $\\theta=0.0$.\n- 用例2（中等畸变，旋转的各向异性）：$\\delta=0.5$, $r=10.0$, $\\theta=0.7$.\n- 用例3（强畸变，旋转的各向异性）：$\\delta=1.0$, $r=10.0$, $\\theta=1.4$.\n- 用例4（极端畸变，旋转的各向异性）：$\\delta=2.0$, $r=10.0$, $\\theta=2.1$.\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，“[result1,result2,result3,result4]”）。每个结果必须是等于该用例的 $E$ 的浮点数。不应打印任何额外文本。所有计算都必须遵循上述定义，并且不允许进行超出指定单点法则的数值积分。",
            "solution": "所提出的问题要求设计并实现一个数值实验，以评估应用于多孔介质中达西流的高斯散度定理离散公式的准确性。任务的核心是计算通量散度的体积分的单点求积，与一个多面体控制体边界面上通量的单点求积之和之间的差异。这个差异将作为施加于控制体的几何畸变的函数进行研究。\n\n该问题在计算上是明确定义的，在科学上基于流体力学和数值分析的原理，并提供了所有必要的参数和方程。它代表了计算科学中一个有效且重要的练习。以下步骤详细说明了得出解决方案的理论基础和计算策略。\n\n首先，我们建立物理和数学背景。流动由达西定律控制，该定律通过渗透率张量 $\\boldsymbol{K}$ 将比流量（达西通量）$\\boldsymbol{q}$ 与水头 $h$ 联系起来：\n$$\n\\boldsymbol{q} = -\\boldsymbol{K}\\,\\nabla h\n$$\n渗透率张量 $\\boldsymbol{K}$ 被指定为一个常数、对称、正定的矩阵。散度定理将通量散度在一个体积 $K_{\\delta}$ 上的积分与通量穿过其边界 $\\partial K_{\\delta}$ 的积分联系起来：\n$$\n\\int_{K_{\\delta}} \\nabla\\cdot\\boldsymbol{q}\\,dV = \\int_{\\partial K_{\\delta}} \\boldsymbol{q}\\cdot \\boldsymbol{n}\\,dA\n$$\n该实验旨在量化通过使用低阶数值求积法则近似此方程两边所引入的误差。\n\n控制体 $K_{\\delta}$ 是一个多面体，定义为参考单位立方体 $[0,1]^3$ 的仿射像。该映射由 $\\boldsymbol{x}(\\boldsymbol{\\xi}) = \\boldsymbol{A}(\\delta)\\,\\boldsymbol{\\xi}$ 给出，其中 $\\boldsymbol{\\xi} \\in [0,1]^3$ 是参考坐标，$\\boldsymbol{x}$ 是物理坐标。变换矩阵为\n$$\n\\boldsymbol{A}(\\delta) = \\begin{bmatrix} 1  \\delta  0 \\\\ 0  1  \\delta \\\\ 0  0  1 \\end{bmatrix}\n$$\n参数 $\\delta \\ge 0$ 控制剪切畸变的程度。对于所有 $\\delta$，控制体的体积为 $|K_{\\delta}| = \\det(\\boldsymbol{A}(\\delta)) = 1$。\n\n水头 $h$ 是一个给定的三次多项式：\n$$\nh(x,y,z) = \\alpha\\,x^3 + \\beta\\,y^3 + \\gamma\\,z^3 + \\delta_h\\, x\\,y\\,z\n$$\n具有给定的系数 $\\alpha=0.7$，$\\beta=-0.2$，$\\gamma=0.5$，和 $\\delta_h=0.3$。\n渗透率张量 $\\boldsymbol{K}$ 是各向异性的，定义为\n$$\n\\boldsymbol{K}(\\theta, r) = \\boldsymbol{R}(\\theta)\\,\\mathrm{diag}(r,\\;1,\\;r^{-1})\\,\\boldsymbol{R}(\\theta)^{\\top}\n$$\n其中 $r \\ge 1$ 是各向异性比，$\\boldsymbol{R}(\\theta)$ 是对应于围绕固定轴 $\\boldsymbol{u} = (1/\\sqrt{14})[1, 2, 3]^{\\top}$ 旋转角度 $\\theta$ 的旋转矩阵。矩阵 $\\boldsymbol{R}(\\theta)$ 使用罗德里格斯旋转公式构建：\n$$\n\\boldsymbol{R}(\\theta) = \\boldsymbol{I}\\cos\\theta + (1-\\cos\\theta)(\\boldsymbol{u} \\otimes \\boldsymbol{u}) + \\sin\\theta\\,[\\boldsymbol{u}]_{\\times}\n$$\n其中 $\\boldsymbol{I}$ 是单位矩阵，$\\boldsymbol{u} \\otimes \\boldsymbol{u}$ 是外积，$[\\boldsymbol{u}]_{\\times}$ 是 $\\boldsymbol{u}$ 的叉积矩阵。\n\n由于 $\\boldsymbol{K}$ 是常数，通量的散度为 $\\nabla\\cdot\\boldsymbol{q} = -\\nabla\\cdot(\\boldsymbol{K}\\nabla h) = -\\mathrm{tr}(\\boldsymbol{K}\\nabla^2 h)$，其中 $\\nabla^2 h$ 是 $h$ 的海森矩阵。$\\nabla^2 h$ 的条目是坐标 $(x,y,z)$ 的线性函数，这使得 $\\nabla\\cdot\\boldsymbol{q}$ 成为位置的线性函数。\n\n待比较的离散散度定理的两个项是：\n$1$. 体积分的近似，$I_V = \\int_{K_{\\delta}} \\nabla\\cdot\\boldsymbol{q}\\,dV$。这通过在物理单元形心 $\\boldsymbol{x}_c = \\boldsymbol{A}(\\delta) [1/2, 1/2, 1/2]^{\\top}$ 处的单点求积法则来近似：\n$$\nI_V \\approx \\tilde{I}_V = |K_{\\delta}| \\,(\\nabla\\cdot\\boldsymbol{q})(\\boldsymbol{x}_c)\n$$\n一个关键的观察是，在形心处评估的单点求积法则对于任意体积上线性函数的积分都是精确的。由于 $\\nabla\\cdot\\boldsymbol{q}$ 在 $\\boldsymbol{x}$ 中是线性的，这个“近似”会得到体积分的精确值，即 $\\tilde{I}_V = I_V$。\n\n$2$. 曲面积分的近似，$I_S = \\int_{\\partial K_{\\delta}} \\boldsymbol{q}\\cdot \\boldsymbol{n}\\,dA$。这是 $K_\\delta$ 六个面上的通量之和：\n$$\nI_S \\approx \\tilde{I}_S = \\sum_{f\\subset\\partial K_{\\delta}} \\boldsymbol{q}(\\boldsymbol{x}_f)\\cdot \\boldsymbol{a}_f\n$$\n此处，$\\boldsymbol{x}_f$ 是面 $f$ 的中心，$\\boldsymbol{a}_f$ 是其有向面积矢量。对于对应于 $\\xi_i=c$（其中 $c \\in \\{0,1\\}$）的面，其中心是 $\\boldsymbol{x}_f = \\boldsymbol{A}(\\delta)\\boldsymbol{\\xi}_f$，其中 $\\boldsymbol{\\xi}_f$ 是 $[1/2, 1/2, 1/2]^{\\top}$ 且第 $i$ 个分量设为 $c$。有向面积矢量为 $\\boldsymbol{a}_{i,c} = s_{i,c}(\\boldsymbol{A}\\boldsymbol{e}_j \\times \\boldsymbol{A}\\boldsymbol{e}_k)$，其中 $(i,j,k)$ 是 $(1,2,3)$ 的轮换，使得 $\\boldsymbol{e}_j \\times \\boldsymbol{e}_k = \\boldsymbol{e}_i$，且对于 $c=0$，$s_{i,c}$ 为 $-1$，对于 $c=1$，$s_{i,c}$ 为 $+1$。通量 $\\boldsymbol{q}(\\boldsymbol{x})$ 是位置的二次函数，因此这个用于曲面积分的单点求积通常不是精确的。\n\n离散定理两边之间的全部差异源于曲面积分近似中的误差。误差度量 $E$ 定义为：\n$$\nE = \\frac{|\\tilde{I}_V - \\tilde{I}_S|}{\\max(1, |\\tilde{I}_V|)} = \\frac{|I_V - \\tilde{I}_S|}{\\max(1, |I_V|)}\n$$\n该度量通过精确体积分的量级（如果积分很小，则为1）来归一化曲面积分近似的绝对误差。\n\n每个测试用例 $(\\delta, r, \\theta)$ 的计算过程如下：\n$1$. 构建矩阵 $\\boldsymbol{A}(\\delta)$ 和 $\\boldsymbol{K}(\\theta, r)$。\n$2$. 计算精确的体积分项 $\\tilde{I}_V$：找到单元形心 $\\boldsymbol{x}_c$，评估海森矩阵 $\\nabla^2 h(\\boldsymbol{x}_c)$，计算散度 $\\nabla\\cdot\\boldsymbol{q}(\\boldsymbol{x}_c) = -\\mathrm{tr}(\\boldsymbol{K}\\nabla^2 h(\\boldsymbol{x}_c))$，并按体积 $|K_{\\delta}|=1$ 缩放。\n$3$. 计算近似的曲面积分项 $\\tilde{I}_S$：遍历六个面... 对于每个面，确定其中心 $\\boldsymbol{x}_f$ 和有向面积矢量 $\\boldsymbol{a}_f$。评估通量矢量 $\\boldsymbol{q}(\\boldsymbol{x}_f) = -\\boldsymbol{K}\\nabla h(\\boldsymbol{x}_f)$ 并计算点积... 将这些贡献相加。\n$4$. 使用上述公式计算最终的误差度量 $E$。\n\n将为四个指定的测试用例实现并执行此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef get_rotation_matrix(axis, angle):\n    \"\"\"\n    Returns the rotation matrix for a rotation around a given axis by a given angle,\n    using Rodrigues' rotation formula.\n    \n    Args:\n        axis (np.ndarray): The 3D rotation axis (must be a unit vector).\n        angle (float): The rotation angle in radians.\n        \n    Returns:\n        np.ndarray: The 3x3 rotation matrix.\n    \"\"\"\n    c = np.cos(angle)\n    s = np.sin(angle)\n    t = 1 - c\n    x, y, z = axis\n    \n    # Cross-product matrix of the axis vector\n    K_cross = np.array([[0, -z, y],\n                        [z, 0, -x],\n                        [-y, x, 0]])\n    \n    # Rodrigues' formula: R = c*I + t*(u u^T) + s*[u]_x\n    R = c * np.identity(3) + t * np.outer(axis, axis) + s * K_cross\n    return R\n\ndef solve():\n    \"\"\"\n    Solves the numerical experiment problem by calculating the discrepancy E\n    for a set of test cases.\n    \"\"\"\n    # Define problem constants\n    alpha = 0.7\n    beta = -0.2\n    gamma = 0.5\n    delta_h = 0.3\n    # Rotation axis must be a unit vector\n    rot_axis_u = np.array([1.0, 2.0, 3.0]) / np.sqrt(1**2 + 2**2 + 3**2)\n\n    # Test suite from the problem statement\n    test_cases = [\n        # (delta, r, theta)\n        (0.0, 10.0, 0.0),\n        (0.5, 10.0, 0.7),\n        (1.0, 10.0, 1.4),\n        (2.0, 10.0, 2.1),\n    ]\n\n    results = []\n    \n    # Function definitions for head gradient and Hessian\n    def grad_h(p):\n        x, y, z = p\n        return np.array([\n            3 * alpha * x**2 + delta_h * y * z,\n            3 * beta * y**2 + delta_h * x * z,\n            3 * gamma * z**2 + delta_h * x * y\n        ])\n\n    def hessian_h(p):\n        x, y, z = p\n        return np.array([\n            [6 * alpha * x, delta_h * z,   delta_h * y],\n            [delta_h * z,   6 * beta * y,  delta_h * x],\n            [delta_h * y,   delta_h * x,   6 * gamma * z]\n        ])\n\n    for delta, r, theta in test_cases:\n        # Step 1: Define Geometry and Permeability\n        A = np.array([[1.0, delta, 0.0],\n                      [0.0, 1.0,   delta],\n                      [0.0, 0.0,   1.0]])\n        \n        # Volume of the sheared cube is det(A) = 1\n        vol_K_delta = 1.0\n\n        # Construct permeability tensor K\n        R = get_rotation_matrix(rot_axis_u, theta)\n        D = np.diag([r, 1.0, 1.0/r])\n        K = R @ D @ R.T\n\n        # Step 2: Calculate Volume Integral Term (this approximation is exact)\n        xi_c = np.array([0.5, 0.5, 0.5])\n        x_c = A @ xi_c\n        \n        div_q_at_xc = -np.trace(K @ hessian_h(x_c))\n        vol_integral_term = vol_K_delta * div_q_at_xc\n\n        # Step 3: Calculate Surface Integral Term\n        surface_integral_term = 0.0\n        \n        # Loop over faces, defined by axis index i (0-based) and side c (0 or 1)\n        for i in range(3):\n            # Cyclic permutation for j, k\n            j = (i + 1) % 3\n            k = (i + 2) % 3\n            \n            for c in range(2):  # side c=0 or c=1\n                s_ic = -1.0 if c == 0 else 1.0\n                \n                # Oriented area vector a_f = s * (A_ej x A_ek)\n                A_col_j = A[:, j]\n                A_col_k = A[:, k]\n                area_vec = s_ic * np.cross(A_col_j, A_col_k)\n                \n                # Physical location of the face center x_f\n                xi_f = np.array([0.5, 0.5, 0.5])\n                xi_f[i] = float(c)\n                x_f = A @ xi_f\n                \n                # Flux q at the face center x_f\n                q_at_xf = -K @ grad_h(x_f)\n                \n                # Add flux through the face to the sum\n                surface_integral_term += np.dot(q_at_xf, area_vec)\n        \n        # Step 4: Compute the Error Metric E\n        numerator = np.abs(vol_integral_term - surface_integral_term)\n        denominator = np.max([1.0, np.abs(vol_integral_term)])\n        error = numerator / denominator\n        \n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}