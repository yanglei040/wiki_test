{
    "hands_on_practices": [
        {
            "introduction": "In computational mechanics, continuous differential operators must be translated into discrete forms that computers can solve. A critical quality benchmark for any discrete operator is its ability to exactly reproduce the behavior of simple, fundamental physical states. This practice guides you through the construction of a discrete divergence operator from the Gauss divergence theorem and its verification using the \"patch test,\" which confirms the scheme's exactness for linear stress fields—a cornerstone for building reliable numerical models .",
            "id": "3517016",
            "problem": "Consider a two-dimensional continuum domain with spatial coordinates denoted by $x$ and $y$, and let the Cauchy stress tensor field be $\\boldsymbol{\\sigma}(x,y)\\in\\mathbb{R}^{2\\times 2}$. The differential operator divergence applied to a second-order tensor is defined row-wise: for row $i\\in\\{1,2\\}$, the divergence is $(\\nabla\\cdot\\boldsymbol{\\sigma})_i=\\sum_{j=1}^{2}\\frac{\\partial \\sigma_{ij}}{\\partial x_j}$, where $x_1=x$ and $x_2=y$, and where each $\\sigma_{ij}$ is a component function of $x$ and $y$. The Gauss divergence theorem states that for any sufficiently smooth vector field $\\mathbf{a}(x,y)$,\n$$\n\\int_{\\Omega} \\nabla\\cdot \\mathbf{a}\\, \\mathrm{d}A \\;=\\; \\int_{\\partial\\Omega} \\mathbf{a}\\cdot\\mathbf{n}\\,\\mathrm{d}s,\n$$\nwhere $\\Omega\\subset\\mathbb{R}^2$ is an open set with piecewise smooth boundary $\\partial\\Omega$, $\\mathbf{n}$ is the outward unit normal on $\\partial\\Omega$, $\\mathrm{d}A$ is an area measure, and $\\mathrm{d}s$ is a line measure. In continuum mechanics, the traction vector on a boundary with unit normal $\\mathbf{n}$ derived from $\\boldsymbol{\\sigma}$ has components $t_i=\\sum_{j=1}^{2}\\sigma_{ij} n_j$, and the Gauss divergence theorem applied row-wise yields, for each $i\\in\\{1,2\\}$,\n$$\n\\int_{\\Omega} (\\nabla\\cdot\\boldsymbol{\\sigma})_i\\, \\mathrm{d}A \\;=\\; \\int_{\\partial\\Omega} \\left(\\sum_{j=1}^{2}\\sigma_{ij} n_j\\right)\\,\\mathrm{d}s.\n$$\n\nTasks:\n1. Starting from the definition of the derivative and the above row-wise definition of the divergence, demonstrate that for a spatially constant stress field $\\boldsymbol{\\sigma}(x,y)=\\boldsymbol{\\sigma}_0$ (where each $\\sigma_{ij}$ is independent of $x$ and $y$), the divergence $\\nabla\\cdot\\boldsymbol{\\sigma}$ vanishes everywhere in the domain.\n\n2. Construct a discrete divergence operator for a rectangular grid that is derived from the Gauss divergence theorem. Consider a single rectangular cell with side lengths $h_x$ in the $x$-direction and $h_y$ in the $y$-direction, area $A=h_x h_y$, and four faces: left and right (with normals $(-1,0)$ and $(1,0)$, respectively) and bottom and top (with normals $(0,-1)$ and $(0,1)$, respectively). Define the discrete divergence in each cell by approximating the boundary integral on each face via the midpoint evaluation of the traction components $t_i=\\sum_{j=1}^{2}\\sigma_{ij}n_j$, summing the four face contributions, and dividing by the cell area $A$. Implement this discrete operator on a uniform structured grid covering the domain.\n\n3. In computational geomechanics, a \"patch test\" verifies that a discrete operator reproduces exactly certain polynomial fields. Construct and verify a patch test in which body forces are balanced exactly by a stress field whose entries are at most linear in $x$ and $y$. Specifically, use a stress tensor of the form\n$$\n\\boldsymbol{\\sigma}(x,y) \\;=\\;\n\\begin{bmatrix}\na_{11} x + b_{11} y + c_{11}  a_{12} x + b_{12} y + c_{12} \\\\\na_{21} x + b_{21} y + c_{21}  a_{22} x + b_{22} y + c_{22}\n\\end{bmatrix},\n$$\nwhere all $a_{ij}$ and $b_{ij}$ have units of $\\mathrm{Pa/m}$ and all $c_{ij}$ have units of $\\mathrm{Pa}$. The analytical body force per unit volume (with units $\\mathrm{N/m^3}$) implied by $\\nabla\\cdot\\boldsymbol{\\sigma}$ is spatially constant and given by\n$$\n\\mathbf{b} \\;=\\;\n\\begin{bmatrix}\n\\frac{\\partial \\sigma_{11}}{\\partial x} + \\frac{\\partial \\sigma_{12}}{\\partial y} \\\\\n\\frac{\\partial \\sigma_{21}}{\\partial x} + \\frac{\\partial \\sigma_{22}}{\\partial y}\n\\end{bmatrix}\n\\;=\\;\n\\begin{bmatrix}\na_{11} + b_{12} \\\\\na_{21} + b_{22}\n\\end{bmatrix}.\n$$\nUsing the discrete operator from Task $2$, verify that the discrete divergence computed per cell exactly matches $\\mathbf{b}$ for the following test suite.\n\nTest suite specifications and units:\n- All domains are rectangular with lengths specified in meters ($\\mathrm{m}$). Grid counts $N_x$ and $N_y$ are integers. All stress coefficients $a_{ij}$, $b_{ij}$ are in $\\mathrm{Pa/m}$, all $c_{ij}$ are in $\\mathrm{Pa}$. Error measures must be reported in $\\mathrm{N/m^3}$. Angles are not used in this problem.\n- Compute the maximum absolute discrepancy across all cells and both divergence components, denoted $E$ (with units $\\mathrm{N/m^3}$), between the discrete divergence and the analytical $\\mathbf{b}$. Also report whether the patch test is satisfied exactly within a tolerance $\\varepsilon=10^{-12}\\,\\mathrm{N/m^3}$, by outputting a boolean value that is $\\mathrm{True}$ if $E\\le\\varepsilon$ and $\\mathrm{False}$ otherwise.\n\nProvide the following three test cases:\n- Case $1$ (constant stress field; boundary condition sanity check):\n  - Domain: $L_x=2\\,\\mathrm{m}$, $L_y=1\\,\\mathrm{m}$, grid: $N_x=4$, $N_y=2$.\n  - Coefficients: $a_{ij}=0\\,\\mathrm{Pa/m}$ and $b_{ij}=0\\,\\mathrm{Pa/m}$ for all $i,j$; $c_{11}=1000\\,\\mathrm{Pa}$, $c_{12}=-500\\,\\mathrm{Pa}$, $c_{21}=-500\\,\\mathrm{Pa}$, $c_{22}=2000\\,\\mathrm{Pa}$.\n  - Expected analytical divergence: identically zero; compute $E_1$.\n\n- Case $2$ (general linear stress; interior patch test):\n  - Domain: $L_x=3\\,\\mathrm{m}$, $L_y=2\\,\\mathrm{m}$, grid: $N_x=3$, $N_y=2$.\n  - Coefficients:\n    - $a_{11}=300\\,\\mathrm{Pa/m}$, $b_{11}=50\\,\\mathrm{Pa/m}$, $c_{11}=100\\,\\mathrm{Pa}$,\n    - $a_{12}=-20\\,\\mathrm{Pa/m}$, $b_{12}=10\\,\\mathrm{Pa/m}$, $c_{12}=30\\,\\mathrm{Pa}$,\n    - $a_{21}=45\\,\\mathrm{Pa/m}$, $b_{21}=-15\\,\\mathrm{Pa/m}$, $c_{21}=5\\,\\mathrm{Pa}$,\n    - $a_{22}=-60\\,\\mathrm{Pa/m}$, $b_{22}=25\\,\\mathrm{Pa/m}$, $c_{22}=70\\,\\mathrm{Pa}$.\n  - Analytical body force: $\\mathbf{b}=\\begin{bmatrix}310\\\\70\\end{bmatrix}\\,\\mathrm{N/m^3}$; compute $E_2$ and the boolean $B_2$ indicating whether $E_2\\le \\varepsilon$.\n\n- Case $3$ (anisotropic grid with boundary faces; mixed-zero linear stress):\n  - Domain: $L_x=5\\,\\mathrm{m}$, $L_y=0.5\\,\\mathrm{m}$, grid: $N_x=5$, $N_y=1$.\n  - Coefficients:\n    - $a_{11}=0\\,\\mathrm{Pa/m}$, $b_{11}=200\\,\\mathrm{Pa/m}$, $c_{11}=10\\,\\mathrm{Pa}$,\n    - $a_{12}=0\\,\\mathrm{Pa/m}$, $b_{12}=5\\,\\mathrm{Pa/m}$, $c_{12}=20\\,\\mathrm{Pa}$,\n    - $a_{21}=-80\\,\\mathrm{Pa/m}$, $b_{21}=0\\,\\mathrm{Pa/m}$, $c_{21}=15\\,\\mathrm{Pa}$,\n    - $a_{22}=0\\,\\mathrm{Pa/m}$, $b_{22}=0\\,\\mathrm{Pa/m}$, $c_{22}=40\\,\\mathrm{Pa}$.\n  - Analytical body force: $\\mathbf{b}=\\begin{bmatrix}5\\\\-80\\end{bmatrix}\\,\\mathrm{N/m^3}$; compute $E_3$ and the boolean $B_3$ indicating whether $E_3\\le \\varepsilon$.\n\nRequired final output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the following order:\n  - $[E_1,E_2,B_2,E_3,B_3]$,\nwhere $E_1$, $E_2$, and $E_3$ are floats representing errors in $\\mathrm{N/m^3}$, and $B_2$ and $B_3$ are boolean values. No other text must be printed.",
            "solution": "The supplied problem is valid. It is scientifically grounded in continuum mechanics and numerical analysis, well-posed with a unique and verifiable solution, and all terms and conditions are specified completely and unambiguously.\n\nThe solution will be presented in three parts, corresponding to the tasks in the problem statement.\n\n### Task 1: Divergence of a Constant Stress Field\n\nThe first task is to demonstrate that the divergence of a spatially constant stress field, $\\boldsymbol{\\sigma}(x,y) = \\boldsymbol{\\sigma}_0$, is zero. The components of $\\boldsymbol{\\sigma}_0$ are constants, which we denote as $\\sigma_{ij,0}$. The row-wise definition of the tensor divergence is given as:\n$$ (\\nabla\\cdot\\boldsymbol{\\sigma})_i = \\sum_{j=1}^{2} \\frac{\\partial \\sigma_{ij}}{\\partial x_j} = \\frac{\\partial \\sigma_{i1}}{\\partial x} + \\frac{\\partial \\sigma_{i2}}{\\partial y} $$\nwhere $x_1=x$ and $x_2=y$.\n\nFor a constant stress field, each component $\\sigma_{ij}(x,y) = \\sigma_{ij,0}$ is a constant value, independent of the spatial coordinates $x$ and $y$. The partial derivative of a constant with respect to any variable is zero.\n$$ \\frac{\\partial \\sigma_{ij,0}}{\\partial x} = 0 \\quad \\text{and} \\quad \\frac{\\partial \\sigma_{ij,0}}{\\partial y} = 0 $$\nfor all $i,j \\in \\{1,2\\}$.\n\nSubstituting these into the definition of the divergence for the first component ($i=1$):\n$$ (\\nabla\\cdot\\boldsymbol{\\sigma})_1 = \\frac{\\partial \\sigma_{11,0}}{\\partial x} + \\frac{\\partial \\sigma_{12,0}}{\\partial y} = 0 + 0 = 0 $$\nAnd for the second component ($i=2$):\n$$ (\\nabla\\cdot\\boldsymbol{\\sigma})_2 = \\frac{\\partial \\sigma_{21,0}}{\\partial x} + \\frac{\\partial \\sigma_{22,0}}{\\partial y} = 0 + 0 = 0 $$\nTherefore, the divergence vector is the zero vector, $\\nabla\\cdot\\boldsymbol{\\sigma} = \\mathbf{0}$, for any constant stress field.\n\n### Task 2: Construction of the Discrete Divergence Operator\n\nThe second task is to construct a discrete divergence operator for a rectangular cell using the integral form of the Gauss divergence theorem. The theorem applied row-wise to the stress tensor $\\boldsymbol{\\sigma}$ over a cell domain $\\Omega_c$ is:\n$$ \\int_{\\Omega_c} (\\nabla\\cdot\\boldsymbol{\\sigma})_i \\, \\mathrm{d}A = \\int_{\\partial\\Omega_c} (\\boldsymbol{\\sigma}\\mathbf{n})_i \\, \\mathrm{d}s $$\nwhere $(\\boldsymbol{\\sigma}\\mathbf{n})_i = \\sum_{j=1}^2 \\sigma_{ij}n_j$ is the $i$-th component of the traction vector.\n\nWe can approximate the cell-averaged divergence, which we call the discrete divergence $(\\nabla\\cdot\\boldsymbol{\\sigma})_{i,c}$, by assuming the integrand on the left is constant over the cell:\n$$ (\\nabla\\cdot\\boldsymbol{\\sigma})_{i,c} \\cdot A_c \\approx \\int_{\\Omega_c} (\\nabla\\cdot\\boldsymbol{\\sigma})_i \\, \\mathrm{d}A $$\nwhere $A_c = h_x h_y$ is the area of the rectangular cell. This leads to the definition:\n$$ (\\nabla\\cdot\\boldsymbol{\\sigma})_{i,c} = \\frac{1}{A_c} \\int_{\\partial\\Omega_c} \\left(\\sum_{j=1}^{2}\\sigma_{ij} n_j\\right) \\, \\mathrm{d}s $$\nThe boundary integral is evaluated by summing the contributions from the four faces of the cell: right (R), left (L), top (T), and bottom (B). Let the cell be centered at $(x_c, y_c)$. The face midpoints are located at $(x_c+h_x/2, y_c)$, $(x_c-h_x/2, y_c)$, $(x_c, y_c+h_y/2)$, and $(x_c, y_c-h_y/2)$, respectively. We use the midpoint rule to approximate the integral over each face.\n\nLet's derive the expression for the first component ($i=1$):\n- **Right Face (R)**: Normal $\\mathbf{n}=(1,0)$. Length $h_y$. Traction component $t_1 = \\sigma_{11}n_1 + \\sigma_{12}n_2 = \\sigma_{11}(1) + \\sigma_{12}(0) = \\sigma_{11}$. The integral is approximated as $\\sigma_{11}(x_c+h_x/2, y_c) \\cdot h_y$.\n- **Left Face (L)**: Normal $\\mathbf{n}=(-1,0)$. Length $h_y$. Traction component $t_1 = \\sigma_{11}(-1) + \\sigma_{12}(0) = -\\sigma_{11}$. The integral is approximated as $-\\sigma_{11}(x_c-h_x/2, y_c) \\cdot h_y$.\n- **Top Face (T)**: Normal $\\mathbf{n}=(0,1)$. Length $h_x$. Traction component $t_1 = \\sigma_{11}(0) + \\sigma_{12}(1) = \\sigma_{12}$. The integral is approximated as $\\sigma_{12}(x_c, y_c+h_y/2) \\cdot h_x$.\n- **Bottom Face (B)**: Normal $\\mathbf{n}=(0,-1)$. Length $h_x$. Traction component $t_1 = \\sigma_{11}(0) + \\sigma_{12}(-1) = -\\sigma_{12}$. The integral is approximated as $-\\sigma_{12}(x_c, y_c-h_y/2) \\cdot h_x$.\n\nSumming these contributions and dividing by $A_c = h_x h_y$:\n$$ (\\nabla\\cdot\\boldsymbol{\\sigma})_{1,c} = \\frac{1}{h_x h_y} \\left[ \\sigma_{11}(x_c+\\frac{h_x}{2}, y_c)h_y - \\sigma_{11}(x_c-\\frac{h_x}{2}, y_c)h_y + \\sigma_{12}(x_c, y_c+\\frac{h_y}{2})h_x - \\sigma_{12}(x_c, y_c-\\frac{h_y}{2})h_x \\right] $$\n$$ (\\nabla\\cdot\\boldsymbol{\\sigma})_{1,c} = \\frac{\\sigma_{11}(x_c+\\frac{h_x}{2}, y_c) - \\sigma_{11}(x_c-\\frac{h_x}{2}, y_c)}{h_x} + \\frac{\\sigma_{12}(x_c, y_c+\\frac{h_y}{2}) - \\sigma_{12}(x_c, y_c-\\frac{h_y}{2})}{h_y} $$\nThis is a standard second-order central difference approximation of $(\\nabla\\cdot\\boldsymbol{\\sigma})_1$ at the cell center.\n\nBy an identical procedure for the second component ($i=2$), we find:\n$$ (\\nabla\\cdot\\boldsymbol{\\sigma})_{2,c} = \\frac{\\sigma_{21}(x_c+\\frac{h_x}{2}, y_c) - \\sigma_{21}(x_c-\\frac{h_x}{2}, y_c)}{h_x} + \\frac{\\sigma_{22}(x_c, y_c+\\frac{h_y}{2}) - \\sigma_{22}(x_c, y_c-\\frac{h_y}{2})}{h_y} $$\n\n### Task 3: Patch Test Verification\n\nThe third task is to verify that this discrete operator exactly reproduces the divergence of a stress field whose components are linear functions of $x$ and $y$: $\\sigma_{ij}(x,y) = a_{ij}x+b_{ij}y+c_{ij}$. The analytical divergence is $\\mathbf{b} = [a_{11}+b_{12}, a_{21}+b_{22}]^T$.\n\nLet's evaluate the first component of the discrete divergence using the linear stress field.\nThe first term is a finite difference of $\\sigma_{11}(x,y) = a_{11}x+b_{11}y+c_{11}$:\n$$ \\frac{\\sigma_{11}(x_c+\\frac{h_x}{2}, y_c) - \\sigma_{11}(x_c-\\frac{h_x}{2}, y_c)}{h_x} = \\frac{[a_{11}(x_c+\\frac{h_x}{2}) + b_{11}y_c + c_{11}] - [a_{11}(x_c-\\frac{h_x}{2}) + b_{11}y_c + c_{11}]}{h_x} $$\n$$ = \\frac{a_{11}(x_c+\\frac{h_x}{2} - (x_c-\\frac{h_x}{2}))}{h_x} = \\frac{a_{11}h_x}{h_x} = a_{11} $$\nThe second term is a finite difference of $\\sigma_{12}(x,y) = a_{12}x+b_{12}y+c_{12}$:\n$$ \\frac{\\sigma_{12}(x_c, y_c+\\frac{h_y}{2}) - \\sigma_{12}(x_c, y_c-\\frac{h_y}{2})}{h_y} = \\frac{[a_{12}x_c + b_{12}(y_c+\\frac{h_y}{2}) + c_{12}] - [a_{12}x_c + b_{12}(y_c-\\frac{h_y}{2}) + c_{12}]}{h_y} $$\n$$ = \\frac{b_{12}(y_c+\\frac{h_y}{2} - (y_c-\\frac{h_y}{2}))}{h_y} = \\frac{b_{12}h_y}{h_y} = b_{12} $$\nSumming these two results, we get the first component of the discrete divergence:\n$$ (\\nabla\\cdot\\boldsymbol{\\sigma})_{1,c} = a_{11} + b_{12} $$\nThis exactly matches the first component of the analytical divergence vector $\\mathbf{b}$. The result is independent of the cell's location $(x_c, y_c)$ and dimensions $(h_x, h_y)$.\n\nRepeating this for the second component, $(\\nabla\\cdot\\boldsymbol{\\sigma})_{2,c}$, using $\\sigma_{21}$ and $\\sigma_{22}$:\n$$ (\\nabla\\cdot\\boldsymbol{\\sigma})_{2,c} = \\frac{\\sigma_{21}(\\dots) - \\sigma_{21}(\\dots)}{h_x} + \\frac{\\sigma_{22}(\\dots) - \\sigma_{22}(\\dots)}{h_y} = a_{21} + b_{22} $$\nThis also exactly matches the analytical result.\n\nThis confirms that the discrete divergence operator, constructed from the Gauss divergence theorem with a midpoint rule approximation for face integrals, passes the patch test for linear stress fields. Any difference between the computed discrete divergence and the analytical value will be due to floating-point arithmetic limitations, not a deficiency in the method.\n\nThe following Python code implements this verification. The `run_patch_test` function computes the discrete divergence for each cell in a grid according to the derived formula. It then calculates the maximum absolute difference between the computed and analytical divergence across all cells and both components. This error is compared against the given tolerance $\\varepsilon=10^{-12}$ to determine if the test is passed.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the patch test verification for all given cases.\n    \"\"\"\n    epsilon = 1e-12\n\n    # Case 1: constant stress field\n    case1_params = {\n        \"Lx\": 2.0, \"Ly\": 1.0, \"Nx\": 4, \"Ny\": 2,\n        \"coeffs\": {\n            \"c11\": 1000.0, \"c12\": -500.0, \"c21\": -500.0, \"c22\": 2000.0\n        }\n    }\n    E1 = run_patch_test(**case1_params)\n\n    # Case 2: general linear stress\n    case2_params = {\n        \"Lx\": 3.0, \"Ly\": 2.0, \"Nx\": 3, \"Ny\": 2,\n        \"coeffs\": {\n            \"a11\": 300.0, \"b11\": 50.0, \"c11\": 100.0,\n            \"a12\": -20.0, \"b12\": 10.0, \"c12\": 30.0,\n            \"a21\": 45.0, \"b21\": -15.0, \"c21\": 5.0,\n            \"a22\": -60.0, \"b22\": 25.0, \"c22\": 70.0,\n        }\n    }\n    E2 = run_patch_test(**case2_params)\n    B2 = E2 = epsilon\n\n    # Case 3: anisotropic grid with mixed-zero linear stress\n    case3_params = {\n        \"Lx\": 5.0, \"Ly\": 0.5, \"Nx\": 5, \"Ny\": 1,\n        \"coeffs\": {\n            \"a11\": 0.0, \"b11\": 200.0, \"c11\": 10.0,\n            \"a12\": 0.0, \"b12\": 5.0, \"c12\": 20.0,\n            \"a21\": -80.0, \"b21\": 0.0, \"c21\": 15.0,\n            \"a22\": 0.0, \"b22\": 0.0, \"c22\": 40.0,\n        }\n    }\n    E3 = run_patch_test(**case3_params)\n    B3 = E3 = epsilon\n\n    results = [E1, E2, B2, E3, B3]\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_patch_test(Lx, Ly, Nx, Ny, coeffs):\n    \"\"\"\n    Computes discrete divergence on a grid and returns the maximum error.\n\n    Args:\n        Lx (float): Domain length in x-direction.\n        Ly (float): Domain length in y-direction.\n        Nx (int): Number of cells in x-direction.\n        Ny (int): Number of cells in y-direction.\n        coeffs (dict): Dictionary of stress coefficients a_ij, b_ij, c_ij.\n\n    Returns:\n        float: The maximum absolute error between discrete and analytical divergence.\n    \"\"\"\n    hx = Lx / Nx\n    hy = Ly / Ny\n\n    # Define stress component functions based on coefficients\n    # Use .get(key, 0.0) to handle missing coefficients (implicitly zero)\n    def s11(x, y): return coeffs.get('a11', 0.0)*x + coeffs.get('b11', 0.0)*y + coeffs.get('c11', 0.0)\n    def s12(x, y): return coeffs.get('a12', 0.0)*x + coeffs.get('b12', 0.0)*y + coeffs.get('c12', 0.0)\n    def s21(x, y): return coeffs.get('a21', 0.0)*x + coeffs.get('b21', 0.0)*y + coeffs.get('c21', 0.0)\n    def s22(x, y): return coeffs.get('a22', 0.0)*x + coeffs.get('b22', 0.0)*y + coeffs.get('c22', 0.0)\n\n    # Calculate analytical body force (divergence) vector\n    b_analytical_1 = coeffs.get('a11', 0.0) + coeffs.get('b12', 0.0)\n    b_analytical_2 = coeffs.get('a21', 0.0) + coeffs.get('b22', 0.0)\n\n    max_error = 0.0\n\n    # Iterate over all cells in the grid\n    for iy in range(Ny):\n        for ix in range(Nx):\n            # Coordinates of cell face midpoints\n            x_center = (ix + 0.5) * hx\n            y_center = (iy + 0.5) * hy\n            \n            x_right_face = (ix + 1.0) * hx\n            x_left_face = ix * hx\n            y_top_face = (iy + 1.0) * hy\n            y_bottom_face = iy * hy\n\n            # Evaluate stress components at face midpoints\n            s11_r = s11(x_right_face, y_center)\n            s11_l = s11(x_left_face, y_center)\n            s12_t = s12(x_center, y_top_face)\n            s12_b = s12(x_center, y_bottom_face)\n\n            s21_r = s21(x_right_face, y_center)\n            s21_l = s21(x_left_face, y_center)\n            s22_t = s22(x_center, y_top_face)\n            s22_b = s22(x_center, y_bottom_face)\n\n            # Compute discrete divergence for the cell\n            div_s_1 = (s11_r - s11_l) / hx + (s12_t - s12_b) / hy\n            div_s_2 = (s21_r - s21_l) / hx + (s22_t - s22_b) / hy\n\n            # Calculate error for this cell\n            error1 = abs(div_s_1 - b_analytical_1)\n            error2 = abs(div_s_2 - b_analytical_2)\n\n            # Update maximum error\n            max_error = max(max_error, error1, error2)\n\n    return max_error\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "Real-world geomechanical systems rarely consist of simple, solid domains; they often feature tunnels, boreholes, or natural cavities. This exercise extends the application of the Gauss divergence theorem to these more complex, \"multiply connected\" geometries. You will develop an algorithm that correctly calculates the total flux by properly accounting for the orientation of internal boundaries, a crucial skill for accurately modeling phenomena like fluid flow in fractured rock or stress distributions around underground openings .",
            "id": "3516962",
            "problem": "Consider a two-dimensional, multiply connected domain with one outer boundary and zero or more interior cavity boundaries. In computational geomechanics, the volumetric flux density field is represented by a vector field $\\mathbf{v}(x,y)$ that is at least continuously differentiable, and the divergence operator $\\nabla \\cdot \\mathbf{v}$ represents the local volumetric source density. Starting from the integral statement of mass conservation and the Gauss (divergence) theorem for a simply connected domain (no cavities), derive the correct sign structure for the boundary fluxes when the domain contains cavities by excising subdomains and applying the principle to each piece, taking care with the definition of the outward normal. Show that the integral of the divergence over the multiply connected domain equals the outward flux through the outer boundary minus the outward fluxes through each cavity boundary when those cavity boundaries are taken with the same geometric orientation as the outer boundary. Explain why the sign reversal arises from the outward normal pointing into the cavities relative to the domain.\n\nYou must then design an algorithm that, for any polygonal outer boundary and polygonal cavity boundaries, evaluates two quantities for an affine (linear) vector field $\\mathbf{v}(x,y) = \\big(a x + b y + c,\\; d x + e y + f\\big)$ with constant divergence $\\nabla \\cdot \\mathbf{v} = a + e$:\n- The area integral $\\iint_{\\Omega} \\nabla \\cdot \\mathbf{v}\\, dA$, computed from the signed polygonal areas, and\n- The boundary flux integral $\\oint_{\\partial \\Omega} \\mathbf{v}\\cdot \\mathbf{n}\\, ds$, computed for polygonal chains using the outward unit normal $\\mathbf{n}$ and arc length $ds$.\n\nYour algorithm must rely only on fundamental definitions and must not assume any pre-derived formulas for multiply connected domains. For a positively oriented (counterclockwise) simple closed curve $\\Gamma$, the outward flux integral can be expressed as\n$$\n\\oint_{\\Gamma} \\mathbf{v}\\cdot \\mathbf{n}\\, ds \\;=\\; \\oint_{\\Gamma} \\big(v_x\\, dy - v_y\\, dx\\big),\n$$\nwhere $v_x$ and $v_y$ denote the components of $\\mathbf{v}$, $dx$ and $dy$ are the differential displacements, and the curve is parameterized in the counterclockwise direction. Use this identity only after it has been justified from first principles. For a polygonal chain with vertices $(x_i,y_i)$ in order, evaluate the integral exactly by integrating along each straight segment.\n\nAll quantities are nondimensional, and all angles appearing below are to be interpreted in radians.\n\nImplement a program that evaluates the following test suite. For each test case, compute two real numbers:\n- The absolute difference between the area integral $\\iint_{\\Omega} \\nabla \\cdot \\mathbf{v}\\, dA$ and the correctly oriented boundary flux, where inner cavity boundaries are taken with their orientation reversed relative to the outer boundary (which is counterclockwise), so that their outward normals are outward with respect to the domain.\n- The absolute difference between the area integral $\\iint_{\\Omega} \\nabla \\cdot \\mathbf{v}\\, dA$ and the incorrectly oriented boundary flux, where inner cavity boundaries are taken with the same counterclockwise orientation as the outer boundary (i.e., not reversed), which tests sensitivity to inner-boundary orientation.\n\nTest case A (karst-type example with two cavities):\n- Vector field: $\\mathbf{v}(x,y) = \\big(2 x + y + 1,\\; -x + 4 y - 2\\big)$ so that $\\nabla \\cdot \\mathbf{v} = 2 + 4 = 6$.\n- Outer boundary polygon (counterclockwise): $(0,0)\\to(4,0)\\to(4,2)\\to(0,2)$.\n- Cavity $1$: a regular octagon centered at $(1,1)$ with radius $0.3$ and vertices given by $(1 + 0.3 \\cos \\theta_k,\\; 1 + 0.3 \\sin \\theta_k)$ for $\\theta_k = k \\pi/4$, $k \\in \\{0,1,2,3,4,5,6,7\\}$, listed in increasing $k$ (counterclockwise).\n- Cavity $2$: a regular octagon centered at $(3,1)$ with radius $0.25$ and vertices given by $(3 + 0.25 \\cos \\theta_k,\\; 1 + 0.25 \\sin \\theta_k)$ for $\\theta_k = k \\pi/4$, $k \\in \\{0,1,2,3,4,5,6,7\\}$, listed in increasing $k$ (counterclockwise).\n\nTest case B (zero-divergence field):\n- Vector field: $\\mathbf{v}(x,y) = \\big(-y,\\; x\\big)$ so that $\\nabla \\cdot \\mathbf{v} = 0 + 0 = 0$.\n- Outer boundary polygon (counterclockwise): $(0,0)\\to(2,0)\\to(2,2)\\to(0,2)$.\n- Cavity $1$: square $(0.5,0.5)\\to(1.5,0.5)\\to(1.5,1.5)\\to(0.5,1.5)$, listed counterclockwise.\n\nTest case C (nonconvex outer boundary with one cavity):\n- Vector field: $\\mathbf{v}(x,y) = \\big(x + 2,\\; y - 1\\big)$ so that $\\nabla \\cdot \\mathbf{v} = 1 + 1 = 2$.\n- Outer boundary polygon (counterclockwise, L-shaped): $(0,0)\\to(3,0)\\to(3,1)\\to(1,1)\\to(1,3)\\to(0,3)$.\n- Cavity $1$ (triangle, counterclockwise): $(0.3,2.2)\\to(0.8,2.1)\\to(0.6,2.6)$.\n\nYour program must:\n- Compute the polygonal area of the outer boundary and each cavity using the signed shoelace formula and take the domain area as the outer area minus the sum of cavity areas.\n- Compute the exact line integral for the outward flux on each polygonal boundary using segment-wise integration of $\\int (v_x\\, dy - v_y\\, dx)$, which is exact for affine $\\mathbf{v}$ on straight segments.\n- Form the correctly oriented total boundary flux as the sum of the outer boundary flux plus the fluxes of all cavity boundaries taken with reversed orientation (equivalently, as the outer boundary flux minus the fluxes of the cavity boundaries taken counterclockwise).\n- Form the incorrectly oriented total boundary flux as the sum of the outer boundary flux plus the fluxes of the cavity boundaries taken counterclockwise (i.e., not reversed).\n- Report for each test case two floats: the absolute errors corresponding to the correct and the incorrect orientations, respectively.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain exactly six floats in the order\n$[\\text{A\\_correct}, \\text{A\\_incorrect}, \\text{B\\_correct}, \\text{B\\_incorrect}, \\text{C\\_correct}, \\text{C\\_incorrect}]$,\nwhere each entry is the absolute difference defined above for the corresponding test case.",
            "solution": "The problem requires a derivation of the divergence theorem for a multiply connected domain and the design of an algorithm to verify it for affine vector fields over polygonal domains.\n\n### Part 1: Theoretical Derivation\n\nThe Gauss divergence theorem in two dimensions, also known as Green's theorem in divergence form, provides a fundamental relationship between the total divergence of a vector field within a domain and the flux of the field across its boundary. For a simply connected domain $\\Omega_s \\subset \\mathbb{R}^2$ with a piecewise smooth, positively oriented (counter-clockwise, CCW) boundary $\\partial\\Omega_s$, and a continuously differentiable vector field $\\mathbf{v}(x,y) = \\big(v_x(x,y), v_y(x,y)\\big)$, the theorem states:\n$$\n\\iint_{\\Omega_s} (\\nabla \\cdot \\mathbf{v}) \\, dA = \\oint_{\\partial\\Omega_s} \\mathbf{v} \\cdot \\mathbf{n} \\, ds\n$$\nwhere $\\nabla \\cdot \\mathbf{v} = \\frac{\\partial v_x}{\\partial x} + \\frac{\\partial v_y}{\\partial y}$ is the divergence of $\\mathbf{v}$, and $\\mathbf{n}$ is the outward-pointing unit normal vector to the boundary $\\partial\\Omega_s$. The quantity $\\mathbf{v} \\cdot \\mathbf{n}$ represents the component of the flux density normal to the boundary, and the line integral gives the total flux out of the domain.\n\nThe problem considers a multiply connected domain $\\Omega$, defined by an outer boundary $\\Gamma_0$ and $M$ non-overlapping inner cavity boundaries $\\Gamma_1, \\Gamma_2, \\dots, \\Gamma_M$. The domain $\\Omega$ is the region enclosed by $\\Gamma_0$ but exterior to all $\\Gamma_i$ for $i=1, \\dots, M$. The divergence theorem in its basic form does not directly apply to $\\Omega$ as it is not simply connected.\n\nTo adapt the theorem, we transform $\\Omega$ into a simply connected domain. This can be achieved by introducing a set of non-intersecting \"cuts\" that connect the boundaries. For each inner boundary $\\Gamma_i$, we introduce a narrow channel, defined by two infinitesimally close paths $C_i^+$ and $C_i^-$, connecting it to the outer boundary $\\Gamma_0$ (or to another inner boundary that is already connected). By excising these channels, we obtain a new, simply connected domain $\\Omega'$. The area of $\\Omega'$ is identical to that of $\\Omega$.\n\nThe boundary $\\partial\\Omega'$ of this new domain consists of the original outer boundary $\\Gamma_0$, the inner boundaries $\\Gamma_i$, and the paths forming the cuts. Let us orient $\\Gamma_0$ counter-clockwise (CCW) and all inner boundaries $\\Gamma_i$ also CCW. The boundary of $\\Omega'$ must be traversed such that the domain $\\Omega'$ is always on the left. This means:\n- $\\Gamma_0$ is traversed in its original CCW direction.\n- Each cut from $\\Gamma_0$ to $\\Gamma_i$ is traversed, let's say along $C_i^+$.\n- Each inner boundary $\\Gamma_i$ is traversed in the clockwise (CW) direction.\n- Each cut is traversed back from $\\Gamma_i$ to $\\Gamma_0$, along $C_i^-$.\n\nApplying the divergence theorem to the simply connected domain $\\Omega'$ yields:\n$$\n\\iint_{\\Omega'} (\\nabla \\cdot \\mathbf{v}) \\, dA = \\oint_{\\partial\\Omega'} \\mathbf{v} \\cdot \\mathbf{n} \\, ds\n$$\nSince $\\text{Area}(\\Omega') = \\text{Area}(\\Omega)$, the left-hand side is $\\iint_{\\Omega} (\\nabla \\cdot \\mathbf{v}) \\, dA$. The boundary integral on the right-hand side can be decomposed:\n$$\n\\oint_{\\partial\\Omega'} \\mathbf{v} \\cdot \\mathbf{n} \\, ds = \\oint_{\\Gamma_0} \\mathbf{v} \\cdot \\mathbf{n} \\, ds + \\sum_{i=1}^M \\left( \\oint_{\\Gamma_i} \\mathbf{v} \\cdot \\mathbf{n} \\, ds + \\int_{C_i^+} \\mathbf{v} \\cdot \\mathbf{n} \\, ds + \\int_{C_i^-} \\mathbf{v} \\cdot \\mathbf{n} \\, ds \\right)\n$$\nAs the paths $C_i^+$ and $C_i^-$ become infinitesimally close, they trace the same geometric line but in opposite directions. The outward normal vectors on these paths are also oppositely directed. Consequently, their contributions to the integral cancel out: $\\int_{C_i^+} \\mathbf{v} \\cdot \\mathbf{n} \\, ds + \\int_{C_i^-} \\mathbf{v} \\cdot \\mathbf{n} \\, ds = 0$.\n\nThis simplifies the theorem to:\n$$\n\\iint_{\\Omega} (\\nabla \\cdot \\mathbf{v}) \\, dA = \\oint_{\\Gamma_0, \\text{CCW}} \\mathbf{v} \\cdot \\mathbf{n}_{\\text{out}} \\, ds + \\sum_{i=1}^M \\oint_{\\Gamma_i, \\text{CW}} \\mathbf{v} \\cdot \\mathbf{n}_{\\text{out}} \\, ds\n$$\nHere, $\\mathbf{n}_{\\text{out}}$ is the normal vector pointing outward from the domain $\\Omega$.\n- For the outer boundary $\\Gamma_0$ (oriented CCW), $\\mathbf{n}_{\\text{out}}$ is the standard outward normal.\n- For an inner boundary $\\Gamma_i$, the domain $\\Omega$ is exterior to the cavity. Thus, the outward normal $\\mathbf{n}_{\\text{out}}$ points from $\\Omega$ into the cavity.\n\nIf we define a standard flux for any simple closed curve $\\Gamma$ as the flux through its boundary with the standard CCW orientation, let's denote this $\\text{Flux}(\\Gamma, \\text{CCW})$. The outward normal for this standard definition points away from the region enclosed by $\\Gamma$. For the inner boundaries $\\Gamma_i$, this standard normal is opposite to $\\mathbf{n}_{\\text{out}}$ (which points into the cavity). Therefore, $\\oint_{\\Gamma_i, \\text{CW}} \\mathbf{v} \\cdot \\mathbf{n}_{\\text{out}} \\, ds = -\\oint_{\\Gamma_i, \\text{CCW}} \\mathbf{v} \\cdot (-\\mathbf{n}_{\\text{out}}) \\, ds$. It is also true that reversing the direction of path integration negates the integral's value: $\\oint_{\\text{CW}} = - \\oint_{\\text{CCW}}$.\n\nLet $\\text{Flux}(\\Gamma_i, \\text{CCW})$ be the flux across $\\Gamma_i$ oriented CCW, using the normal that points away from the cavity's center. Then the flux with respect to $\\Omega$ on $\\Gamma_i$ is $-\\text{Flux}(\\Gamma_i, \\text{CCW})$. This explains the sign reversal. The total flux is the flux out of the exterior boundary minus the flux into the domain from the cavities (which corresponds to flux out of the cavities).\nThe final, correct formulation for a multiply connected domain is:\n$$\n\\iint_{\\Omega} (\\nabla \\cdot \\mathbf{v}) \\, dA = \\text{Flux}(\\Gamma_0, \\text{CCW}) - \\sum_{i=1}^M \\text{Flux}(\\Gamma_i, \\text{CCW})\n$$\nThis matches the structure requested, where fluxes for all boundaries are first calculated using a consistent CCW orientation, and then combined with the appropriate signs.\n\nTo facilitate computation, we use the identity $\\oint_{\\Gamma} \\mathbf{v} \\cdot \\mathbf{n} \\, ds = \\oint_{\\Gamma} (v_x dy - v_y dx)$ for a CCW-oriented curve $\\Gamma$. This is justified by parameterizing the curve by arc length $s$, $\\mathbf{r}(s) = (x(s), y(s))$. The unit tangent vector is $\\mathbf{t} = d\\mathbf{r}/ds = (dx/ds, dy/ds)$. The outward normal vector for a CCW curve is $\\mathbf{n} = (dy/ds, -dx/ds)$. The dot product is $\\mathbf{v} \\cdot \\mathbf{n} = v_x(dy/ds) - v_y(dx/ds)$. Integrating over $s$ gives $\\int (v_x(dy/ds) - v_y(dx/ds))ds = \\oint (v_x dy - v_y dx)$.\n\n### Part 2: Algorithmic Design\n\nThe algorithm must evaluate both sides of the derived theorem for a given affine vector field $\\mathbf{v}(x,y) = (ax + by + c, dx + ey + f)$ and a domain $\\Omega$ defined by polygonal boundaries.\n\n**1. Area Integral Evaluation:**\nThe divergence of the affine field $\\mathbf{v}$ is a constant: $\\nabla \\cdot \\mathbf{v} = a + e$.\nThe area integral is therefore:\n$$\nI_A = \\iint_{\\Omega} (\\nabla \\cdot \\mathbf{v}) \\, dA = (a+e) \\iint_{\\Omega} dA = (a+e) \\cdot \\text{Area}(\\Omega)\n$$\nThe area of the multiply connected domain $\\Omega$ is the area of the outer polygon $\\Gamma_0$ minus the sum of the areas of the cavity polygons $\\Gamma_i$.\n$$\n\\text{Area}(\\Omega) = \\text{Area}(\\Gamma_0) - \\sum_{i=1}^M \\text{Area}(\\Gamma_i)\n$$\nThe area of a simple polygon with vertices $(x_0, y_0), (x_1, y_1), \\dots, (x_{N-1}, y_{N-1})$ ordered CCW is computed using the shoelace formula, which gives a positive signed area:\n$$\n\\text{Area}(\\text{polygon}) = \\frac{1}{2} \\sum_{j=0}^{N-1} (x_j y_{j+1} - x_{j+1} y_j), \\quad \\text{with } (x_N, y_N) = (x_0, y_0)\n$$\nSince all given polygons are oriented CCW, their areas calculated by this formula will be positive, and the subtraction yields the correct area for $\\Omega$.\n\n**2. Boundary Flux Integral Evaluation:**\nThe total boundary flux is computed by summing the contributions from each boundary polygon with the correct orientation. We use the identity $\\oint (v_x dy - v_y dx)$. For a polygonal boundary, this integral becomes a sum of integrals over its straight-line segments.\nConsider a single segment from $P_j = (x_j, y_j)$ to $P_{j+1} = (x_{j+1}, y_{j+1})$. We can parameterize it as $\\mathbf{r}(t) = (x_j + t\\Delta x_j, y_j + t\\Delta y_j)$ for $t \\in [0,1]$, where $\\Delta x_j = x_{j+1}-x_j$ and $\\Delta y_j = y_{j+1}-y_j$. The differentials are $dx = \\Delta x_j dt$ and $dy = \\Delta y_j dt$.\nThe integral for this segment is:\n$$\n\\int_{P_j}^{P_{j+1}} (v_x dy - v_y dx) = \\int_0^1 [v_x(\\mathbf{r}(t)) \\Delta y_j - v_y(\\mathbf{r}(t)) \\Delta x_j] dt\n$$\nSince $\\mathbf{v}$ is affine, the components $v_x$ and $v_y$ are linear in $x$ and $y$. Therefore, the integrand $v_x(\\mathbf{r}(t)) \\Delta y_j - v_y(\\mathbf{r}(t)) \\Delta x_j$ is a linear function of the parameter $t$. The integral of a linear function over an interval is exactly the value at the midpoint of the interval multiplied by the length of the interval. In this parameterization, the midpoint corresponds to $t=1/2$, and the interval length is $1$. The segment's midpoint coordinates are $(\\bar{x}_j, \\bar{y}_j) = (\\frac{x_j+x_{j+1}}{2}, \\frac{y_j+y_{j+1}}{2})$.\nThe exact value of the segment's flux contribution is therefore:\n$$\n\\text{Flux}_j = v_x(\\bar{x}_j, \\bar{y}_j) \\Delta y_j - v_y(\\bar{x}_j, \\bar{y}_j) \\Delta x_j\n$$\nThe total flux for a polygon, $\\text{Flux}(\\Gamma, \\text{CCW})$, is the sum of these segment fluxes over all its edges.\n\n**3. Verification:**\nFor each test case, the algorithm computes:\n- The area integral: $I_A = (a+e) \\left( \\text{Area}(\\Gamma_0) - \\sum \\text{Area}(\\Gamma_i) \\right)$.\n- The flux for each boundary (outer $\\Gamma_0$ and cavities $\\Gamma_i$) using CCW orientation: $I_{B,0}, I_{B,i}$.\n- The correctly oriented total boundary flux: $I_{B,\\text{correct}} = I_{B,0} - \\sum I_{B,i}$.\n- The incorrectly oriented total boundary flux: $I_{B,\\text{incorrect}} = I_{B,0} + \\sum I_{B,i}$.\nFinally, it computes the absolute differences:\n- $\\text{Error}_{\\text{correct}} = | I_A - I_{B,\\text{correct}} |$\n- $\\text{Error}_{\\text{incorrect}} = | I_A - I_{B,\\text{incorrect}} |$\n\nThe value of $\\text{Error}_{\\text{correct}}$ is expected to be zero (or within floating-point tolerance), validating the theorem. The value of $\\text{Error}_{\\text{incorrect}}$ will generally be non-zero, highlighting the critical role of boundary orientation.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by defining test cases, computing integrals,\n    and reporting the specified differences.\n    \"\"\"\n\n    def polygon_area(vertices):\n        \"\"\"\n        Calculates the signed area of a polygon using the shoelace formula.\n        Assumes vertices are given in order (e.g., counter-clockwise).\n        \"\"\"\n        area = 0.0\n        n = len(vertices)\n        for i in range(n):\n            j = (i + 1) % n\n            area += vertices[i, 0] * vertices[j, 1]\n            area -= vertices[j, 0] * vertices[i, 1]\n        return area / 2.0\n\n    def calculate_flux(polygon_vertices, v_params):\n        \"\"\"\n        Calculates the CCW boundary flux integral for a single polygon.\n        The integral is computed exactly for an affine vector field by summing\n        segment-wise contributions evaluated at the midpoint of each segment.\n        \"\"\"\n        a, b, c, d, e, f = v_params\n        total_flux = 0.0\n        n = len(polygon_vertices)\n        for i in range(n):\n            p1 = polygon_vertices[i]\n            p2 = polygon_vertices[(i + 1) % n]\n            \n            x1, y1 = p1\n            x2, y2 = p2\n            \n            dx = x2 - x1\n            dy = y2 - y1\n            \n            # Midpoint of the segment\n            mid_x = (x1 + x2) / 2.0\n            mid_y = (y1 + y2) / 2.0\n            \n            # Evaluate vector field components at the midpoint\n            v_x_mid = a * mid_x + b * mid_y + c\n            v_y_mid = d * mid_x + e * mid_y + f\n            \n            # Add segment contribution to the total flux\n            segment_flux = v_x_mid * dy - v_y_mid * dx\n            total_flux += segment_flux\n            \n        return total_flux\n\n    def generate_regular_polygon_vertices(center, radius, n_vertices):\n        \"\"\"Generates vertices for a regular polygon.\"\"\"\n        cx, cy = center\n        vertices = []\n        for k in range(n_vertices):\n            # The problem specifies k*pi/4 for an octagon, which is 2*pi*k/8.\n            theta = k * 2.0 * np.pi / n_vertices\n            x = cx + radius * np.cos(theta)\n            y = cy + radius * np.sin(theta)\n            vertices.append((x, y))\n        return np.array(vertices)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"name\": \"A\",\n            \"v_params\": (2, 1, 1, -1, 4, -2),  # a,b,c, d,e,f\n            \"outer_poly\": np.array([(0., 0.), (4., 0.), (4., 2.), (0., 2.)]),\n            \"cavity_polys\": [\n                generate_regular_polygon_vertices(center=(1.0, 1.0), radius=0.3, n_vertices=8),\n                generate_regular_polygon_vertices(center=(3.0, 1.0), radius=0.25, n_vertices=8)\n            ]\n        },\n        {\n            \"name\": \"B\",\n            \"v_params\": (0, -1, 0, 1, 0, 0),\n            \"outer_poly\": np.array([(0., 0.), (2., 0.), (2., 2.), (0., 2.)]),\n            \"cavity_polys\": [\n                np.array([(0.5, 0.5), (1.5, 0.5), (1.5, 1.5), (0.5, 1.5)])\n            ]\n        },\n        {\n            \"name\": \"C\",\n            \"v_params\": (1, 0, 2, 0, 1, -1),\n            \"outer_poly\": np.array([(0., 0.), (3., 0.), (3., 1.), (1., 1.), (1., 3.), (0., 3.)]),\n            \"cavity_polys\": [\n                np.array([(0.3, 2.2), (0.8, 2.1), (0.6, 2.6)])\n            ]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        v_params = case[\"v_params\"]\n        outer_poly = case[\"outer_poly\"]\n        cavity_polys = case[\"cavity_polys\"]\n\n        # 1. Compute Area Integral\n        divergence = v_params[0] + v_params[4]  # a + e\n        \n        area_outer = polygon_area(outer_poly)\n        area_cavities = sum(polygon_area(cavity) for cavity in cavity_polys)\n        domain_area = area_outer - area_cavities\n        \n        area_integral = divergence * domain_area\n\n        # 2. Compute Boundary Flux Integral\n        flux_outer = calculate_flux(outer_poly, v_params)\n        flux_cavities = [calculate_flux(cavity, v_params) for cavity in cavity_polys]\n        sum_flux_cavities = sum(flux_cavities)\n\n        # Correctly oriented flux (Outer - Cavities)\n        flux_correct = flux_outer - sum_flux_cavities\n        \n        # Incorrectly oriented flux (Outer + Cavities)\n        flux_incorrect = flux_outer + sum_flux_cavities\n\n        # 3. Compute absolute differences\n        diff_correct = abs(area_integral - flux_correct)\n        diff_incorrect = abs(area_integral - flux_incorrect)\n        \n        results.extend([diff_correct, diff_incorrect])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.12f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While numerical methods may be exact for simple polynomial fields, their performance on more complex problems is a question of accuracy, not exactness. This hands-on numerical experiment explores how the accuracy of a discrete Gauss's theorem is affected by practical challenges like distorted mesh elements and anisotropic material properties. By quantifying the numerical error, you will gain insight into how mesh quality and material complexity influence the fidelity of computational simulations in geomechanics .",
            "id": "3516994",
            "problem": "You are tasked with designing and implementing a numerical experiment to assess a discrete version of Gauss’s divergence theorem in the context of Darcy flow in porous media with anisotropic permeability. The goal is to quantify, for a single polyhedral control volume, the discrepancy between an approximate volume integral of the divergence of the Darcy flux and an approximate sum of fluxes through the control volume’s boundary faces as the control volume becomes increasingly distorted.\n\nStart from the following foundational base:\n- Darcy’s law for steady incompressible flow in porous media: the specific discharge (Darcy flux) is given by $\\boldsymbol{q} = -\\boldsymbol{K}\\,\\nabla h$, where $\\boldsymbol{K}$ is the symmetric positive definite permeability tensor and $h$ is the hydraulic head.\n- The divergence theorem: for a sufficiently smooth vector field $\\boldsymbol{q}$ on a control volume $K \\subset \\mathbb{R}^3$ with outer unit normal $\\boldsymbol{n}$,\n$$\n\\int_K \\nabla\\cdot\\boldsymbol{q}\\,dV \\;=\\; \\int_{\\partial K} \\boldsymbol{q}\\cdot \\boldsymbol{n}\\,dA \\;=\\; \\sum_{f\\subset\\partial K} \\int_f \\boldsymbol{q}\\cdot\\boldsymbol{n}\\,dA.\n$$\n\nExperiment design (must be followed exactly to ensure universality and testability):\n1. Geometry and distortion:\n   - Represent the control volume $K_{\\delta}$ as the affine image of the reference cube $[0,1]^3$ by $x(\\boldsymbol{\\xi}) = \\boldsymbol{A}(\\delta)\\,\\boldsymbol{\\xi} + \\boldsymbol{b}$ with $\\boldsymbol{\\xi}\\in[0,1]^3$, $\\boldsymbol{b}=\\boldsymbol{0}$, and\n     $$\n     \\boldsymbol{A}(\\delta) \\;=\\; \\begin{bmatrix} 1  \\delta  0 \\\\[4pt] 0  1  \\delta \\\\[4pt] 0  0  1 \\end{bmatrix}.\n     $$\n     Here $\\delta\\ge 0$ is a distortion parameter; $\\delta=0$ gives the unit cube and larger $\\delta$ produces increasingly sheared (and thus distorted) polyhedra. The volume is $|K_{\\delta}| = \\det(\\boldsymbol{A}(\\delta))$.\n   - The six faces of $K_{\\delta}$ correspond to the planes $\\xi_i=0$ and $\\xi_i=1$ for $i\\in\\{1,2,3\\}$. For the face with fixed index $i$, denote the other indices in cyclic order by $(j,k)$ so that $(i,j,k)$ is a cyclic permutation of $(1,2,3)$.\n\n2. Anisotropic permeability and flux:\n   - Let $\\boldsymbol{K}$ be constant and anisotropic, constructed by rotating a diagonal tensor with eigenvalues $k_10$, $k_20$, $k_30$. Specifically, define\n     $$\n     \\boldsymbol{K}(\\theta, r) \\;=\\; \\boldsymbol{R}(\\theta)\\,\\mathrm{diag}(r,\\;1,\\;r^{-1})\\,\\boldsymbol{R}(\\theta)^{\\top},\n     $$\n     where $\\theta$ is a rotation angle (in radians) about the fixed unit axis $\\boldsymbol{u} = \\frac{1}{\\sqrt{1^2+2^2+3^2}}[1,2,3]^{\\top}$, and $r\\ge 1$ is an anisotropy ratio. The rotation matrix $\\boldsymbol{R}(\\theta)$ should be formed with the Rodrigues formula and must be orthogonal with determinant $+1$.\n   - Define the hydraulic head field as the cubic polynomial\n     $$\n     h(x,y,z) \\;=\\; \\alpha\\,x^3 + \\beta\\,y^3 + \\gamma\\,z^3 + \\delta_h\\, x\\,y\\,z,\n     $$\n     with fixed coefficients $\\alpha=0.7$, $\\beta=-0.2$, $\\gamma=0.5$, $\\delta_h=0.3$. The Darcy flux is $\\boldsymbol{q}(x) = -\\boldsymbol{K}\\,\\nabla h(x)$.\n\n3. Differential operators needed for the experiment:\n   - The gradient is\n     $$\n     \\nabla h(x,y,z) \\;=\\; \\begin{bmatrix} 3\\alpha\\,x^2 + \\delta_h\\,y\\,z \\\\[4pt] 3\\beta\\,y^2 + \\delta_h\\,x\\,z \\\\[4pt] 3\\gamma\\,z^2 + \\delta_h\\,x\\,y \\end{bmatrix}.\n     $$\n   - The Hessian matrix is\n     $$\n     \\nabla^2 h(x,y,z) \\;=\\; \\begin{bmatrix}\n     6\\alpha\\,x  \\delta_h\\,z  \\delta_h\\,y \\\\\n     \\delta_h\\,z  6\\beta\\,y  \\delta_h\\,x \\\\\n     \\delta_h\\,y  \\delta_h\\,x  6\\gamma\\,z\n     \\end{bmatrix}.\n     $$\n   - Since $\\boldsymbol{K}$ is constant in space, the divergence of the Darcy flux is\n     $$\n     \\nabla\\cdot\\boldsymbol{q}(x) \\;=\\; -\\mathrm{tr}\\big(\\boldsymbol{K}\\,\\nabla^2 h(x)\\big),\n     $$\n     which is an affine (linear) function of $x$.\n\n4. Discrete approximations to be compared:\n   - Approximate the volume integral by a one-point rule at the centroid $x_c$ of $K_{\\delta}$:\n     $$\n     \\int_{K_{\\delta}} \\nabla\\cdot\\boldsymbol{q}\\,dV \\;\\approx\\; |K_{\\delta}| \\,\\big(\\nabla\\cdot\\boldsymbol{q}\\big)(x_c), \\quad x_c = \\boldsymbol{A}(\\delta)\\,\\begin{bmatrix} \\tfrac12 \\\\ \\tfrac12 \\\\ \\tfrac12 \\end{bmatrix}.\n     $$\n   - Approximate each face integral by a one-point rule at the physical face center. For face $\\xi_i=c$ with $c\\in\\{0,1\\}$, use the $\\boldsymbol{\\xi}$-center $\\boldsymbol{\\xi}_f = (1/2,1/2,1/2)^{\\top}$ with the $i$-th component replaced by $c$, and map it to $x_f=\\boldsymbol{A}(\\delta)\\,\\boldsymbol{\\xi}_f$. The oriented area vector for that face is\n     $$\n     \\boldsymbol{a}_{i,c} \\;=\\; s_{i,c}\\,\\big(\\partial_{\\xi_j}x \\times \\partial_{\\xi_k}x\\big) \\;=\\; s_{i,c}\\,\\big(\\boldsymbol{A}\\,\\boldsymbol{e}_j \\times \\boldsymbol{A}\\,\\boldsymbol{e}_k\\big),\n     $$\n     where $s_{i,c}=+1$ for $c=1$ and $s_{i,c}=-1$ for $c=0$, and $(i,j,k)$ is cyclic so that $\\boldsymbol{e}_j \\times \\boldsymbol{e}_k = \\boldsymbol{e}_i$. The discrete face flux is $\\boldsymbol{q}(x_f)\\cdot \\boldsymbol{a}_{i,c}$. The discrete surface sum is the sum of these six face contributions.\n\n5. Error metric:\n   - Define the scalar discrepancy\n     $$\n     E \\;=\\; \\frac{\\big|\\;|K_{\\delta}|\\,(\\nabla\\cdot\\boldsymbol{q})(x_c) \\;-\\; \\sum_{f\\subset\\partial K_{\\delta}} \\boldsymbol{q}(x_f)\\cdot \\boldsymbol{a}_f\\;\\big|}{\\max\\big(1,\\;\\big|\\,|K_{\\delta}|\\,(\\nabla\\cdot\\boldsymbol{q})(x_c)\\,\\big|\\big)}.\n     $$\n     This is a dimensionless quantity. No physical units are required in the answer.\n\nYour program must implement the above and compute $E$ for each test case in the test suite below. Use the exact formulas from items 1–4 where indicated, with the one-point rules as stated. Do not use any external meshes or data files. Angles must be interpreted in radians.\n\nTest suite:\n- Case 1 (baseline, no geometric distortion, aligned anisotropy): $\\delta=0.0$, $r=10.0$, $\\theta=0.0$.\n- Case 2 (moderate distortion, rotated anisotropy): $\\delta=0.5$, $r=10.0$, $\\theta=0.7$.\n- Case 3 (strong distortion, rotated anisotropy): $\\delta=1.0$, $r=10.0$, $\\theta=1.4$.\n- Case 4 (extreme distortion, rotated anisotropy): $\\delta=2.0$, $r=10.0$, $\\theta=2.1$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4]\"). Each result must be a floating-point number equal to $E$ for that case. No additional text should be printed. All computations must follow the definitions above, and no numerical integration beyond the specified one-point rules is permitted.",
            "solution": "The problem presented requires the design and implementation of a numerical experiment to evaluate the accuracy of a discrete formulation of Gauss's divergence theorem applied to Darcy flow in a porous medium. The core of the task is to compute the discrepancy between a single-point quadrature for the volume integral of the flux divergence and a sum of single-point quadratures for the flux over the boundary faces of a polyhedral control volume. This discrepancy is to be studied as a function of geometric distortion applied to the control volume.\n\nThe problem is computationally well-defined, scientifically grounded in the principles of fluid mechanics and numerical analysis, and all necessary parameters and equations are provided. It represents a valid and non-trivial exercise in computational science. The following steps detail the theoretical basis and computational strategy for arriving at the solution.\n\nFirst, we establish the physical and mathematical context. The flow is governed by Darcy's law, which relates the specific discharge (Darcy flux) $\\boldsymbol{q}$ to the hydraulic head $h$ via the permeability tensor $\\boldsymbol{K}$:\n$$\n\\boldsymbol{q} = -\\boldsymbol{K}\\,\\nabla h\n$$\nThe permeability tensor $\\boldsymbol{K}$ is specified as a constant, symmetric, and positive definite matrix. The divergence theorem connects the integral of the divergence of the flux over a volume $K_{\\delta}$ to the integral of the flux across its boundary $\\partial K_{\\delta}$:\n$$\n\\int_{K_{\\delta}} \\nabla\\cdot\\boldsymbol{q}\\,dV = \\int_{\\partial K_{\\delta}} \\boldsymbol{q}\\cdot \\boldsymbol{n}\\,dA\n$$\nThe experiment is designed to quantify the error introduced by approximating both sides of this equation with low-order numerical quadrature rules.\n\nThe control volume $K_{\\delta}$ is a polyhedron defined as the affine image of the reference unit cube $[0,1]^3$. The mapping is given by $\\boldsymbol{x}(\\boldsymbol{\\xi}) = \\boldsymbol{A}(\\delta)\\,\\boldsymbol{\\xi}$, where $\\boldsymbol{\\xi} \\in [0,1]^3$ are the reference coordinates and $\\boldsymbol{x}$ are the physical coordinates. The transformation matrix is\n$$\n\\boldsymbol{A}(\\delta) = \\begin{bmatrix} 1  \\delta  0 \\\\ 0  1  \\delta \\\\ 0  0  1 \\end{bmatrix}\n$$\nThe parameter $\\delta \\ge 0$ controls the degree of shearing distortion. The volume of the control volume is $|K_{\\delta}| = \\det(\\boldsymbol{A}(\\delta)) = 1$ for all $\\delta$.\n\nThe hydraulic head $h$ is a prescribed cubic polynomial:\n$$\nh(x,y,z) = \\alpha\\,x^3 + \\beta\\,y^3 + \\gamma\\,z^3 + \\delta_h\\, x\\,y\\,z\n$$\nwith given coefficients $\\alpha=0.7$, $\\beta=-0.2$, $\\gamma=0.5$, and $\\delta_h=0.3$.\nThe permeability tensor $\\boldsymbol{K}$ is anisotropic, defined by\n$$\n\\boldsymbol{K}(\\theta, r) = \\boldsymbol{R}(\\theta)\\,\\mathrm{diag}(r,\\;1,\\;r^{-1})\\,\\boldsymbol{R}(\\theta)^{\\top}\n$$\nwhere $r \\ge 1$ is an anisotropy ratio and $\\boldsymbol{R}(\\theta)$ is a rotation matrix corresponding to a rotation by an angle $\\theta$ around the fixed axis $\\boldsymbol{u} = (1/\\sqrt{14})[1, 2, 3]^{\\top}$. The matrix $\\boldsymbol{R}(\\theta)$ is constructed using Rodrigues' rotation formula:\n$$\n\\boldsymbol{R}(\\theta) = \\boldsymbol{I}\\cos\\theta + (1-\\cos\\theta)(\\boldsymbol{u} \\otimes \\boldsymbol{u}) + \\sin\\theta\\,[\\boldsymbol{u}]_{\\times}\n$$\nwhere $\\boldsymbol{I}$ is the identity matrix, $\\boldsymbol{u} \\otimes \\boldsymbol{u}$ is the outer product, and $[\\boldsymbol{u}]_{\\times}$ is the cross-product matrix of $\\boldsymbol{u}$.\n\nSince $\\boldsymbol{K}$ is constant, the divergence of the flux is $\\nabla\\cdot\\boldsymbol{q} = -\\nabla\\cdot(\\boldsymbol{K}\\nabla h) = -\\mathrm{tr}(\\boldsymbol{K}\\nabla^2 h)$, where $\\nabla^2 h$ is the Hessian matrix of $h$. The entries of $\\nabla^2 h$ are linear functions of the coordinates $(x,y,z)$, making $\\nabla\\cdot\\boldsymbol{q}$ a linear function of position.\n\nThe two terms of the discrete divergence theorem to be compared are:\n$1$. The approximation of the volume integral, $I_V = \\int_{K_{\\delta}} \\nabla\\cdot\\boldsymbol{q}\\,dV$. This is approximated by a one-point quadrature rule at the centroid of the physical cell, $\\boldsymbol{x}_c = \\boldsymbol{A}(\\delta) [1/2, 1/2, 1/2]^{\\top}$:\n$$\nI_V \\approx \\tilde{I}_V = |K_{\\delta}| \\,(\\nabla\\cdot\\boldsymbol{q})(\\boldsymbol{x}_c)\n$$\nA crucial observation is that the one-point quadrature rule evaluated at the centroid is exact for any integral of a linear function over an arbitrary volume. Since $\\nabla\\cdot\\boldsymbol{q}$ is linear in $\\boldsymbol{x}$, this \"approximation\" yields the exact value of the volume integral, i.e., $\\tilde{I}_V = I_V$.\n\n$2$. The approximation of the surface integral, $I_S = \\int_{\\partial K_{\\delta}} \\boldsymbol{q}\\cdot \\boldsymbol{n}\\,dA$. This is the sum of fluxes over the six faces of $K_\\delta$:\n$$\nI_S \\approx \\tilde{I}_S = \\sum_{f\\subset\\partial K_{\\delta}} \\boldsymbol{q}(\\boldsymbol{x}_f)\\cdot \\boldsymbol{a}_f\n$$\nHere, $\\boldsymbol{x}_f$ is the center of a face $f$, and $\\boldsymbol{a}_f$ is its oriented area vector. For a face corresponding to $\\xi_i=c$ (with $c \\in \\{0,1\\}$), its center is $\\boldsymbol{x}_f = \\boldsymbol{A}(\\delta)\\boldsymbol{\\xi}_f$, where $\\boldsymbol{\\xi}_f$ is $[1/2, 1/2, 1/2]^{\\top}$ with the $i$-th component set to $c$. The oriented area vector is $\\boldsymbol{a}_{i,c} = s_{i,c}(\\boldsymbol{A}\\boldsymbol{e}_j \\times \\boldsymbol{A}\\boldsymbol{e}_k)$, where $(i,j,k)$ is a cyclic permutation of $(1,2,3)$ such that $\\boldsymbol{e}_j \\times \\boldsymbol{e}_k = \\boldsymbol{e}_i$, and $s_{i,c}$ is $-1$ for $c=0$ and $+1$ for $c=1$. The flux $\\boldsymbol{q}(\\boldsymbol{x})$ is a quadratic function of position, so this one-point quadrature for the surface integral is generally not exact.\n\nThe entire discrepancy between the two sides of the discrete theorem arises from the error in the surface integral approximation. The error metric $E$ is defined as:\n$$\nE = \\frac{|\\tilde{I}_V - \\tilde{I}_S|}{\\max(1, |\\tilde{I}_V|)} = \\frac{|I_V - \\tilde{I}_S|}{\\max(1, |I_V|)}\n$$\nThis metric normalizes the absolute error of the surface integral approximation by the magnitude of the exact volume integral (or $1$ if the integral is small).\n\nThe computational procedure for each test case $(\\delta, r, \\theta)$ is as follows:\n$1$. Construct the matrices $\\boldsymbol{A}(\\delta)$ and $\\boldsymbol{K}(\\theta, r)$.\n$2$. Compute the exact volume integral term $\\tilde{I}_V$: find the cell centroid $\\boldsymbol{x}_c$, evaluate the Hessian $\\nabla^2 h(\\boldsymbol{x}_c)$, compute the divergence $\\nabla\\cdot\\boldsymbol{q}(\\boldsymbol{x}_c) = -\\mathrm{tr}(\\boldsymbol{K}\\nabla^2 h(\\boldsymbol{x}_c))$, and scale by the volume $|K_{\\delta}|=1$.\n$3$. Compute the approximate surface integral term $\\tilde{I}_S$: iterate through the six faces of the control volume. For each face, determine its center $\\boldsymbol{x}_f$ and oriented area vector $\\boldsymbol{a}_f$. Evaluate the flux vector $\\boldsymbol{q}(\\boldsymbol{x}_f) = -\\boldsymbol{K}\\nabla h(\\boldsymbol{x}_f)$ and compute the dot product with the area vector. Sum these contributions.\n$4$. Calculate the final error metric $E$ using the formula above.\n\nThis procedure will be implemented and executed for the four specified test cases.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef get_rotation_matrix(axis, angle):\n    \"\"\"\n    Returns the rotation matrix for a rotation around a given axis by a given angle,\n    using Rodrigues' rotation formula.\n    \n    Args:\n        axis (np.ndarray): The 3D rotation axis (must be a unit vector).\n        angle (float): The rotation angle in radians.\n        \n    Returns:\n        np.ndarray: The 3x3 rotation matrix.\n    \"\"\"\n    c = np.cos(angle)\n    s = np.sin(angle)\n    t = 1 - c\n    x, y, z = axis\n    \n    # Cross-product matrix of the axis vector\n    K = np.array([[0, -z, y],\n                  [z, 0, -x],\n                  [-y, x, 0]])\n    \n    # Rodrigues' formula: R = c*I + t*(u u^T) + s*[u]_x\n    R = c * np.identity(3) + t * np.outer(axis, axis) + s * K\n    return R\n\ndef solve():\n    \"\"\"\n    Solves the numerical experiment problem by calculating the discrepancy E\n    for a set of test cases.\n    \"\"\"\n    # Define problem constants\n    alpha = 0.7\n    beta = -0.2\n    gamma = 0.5\n    delta_h = 0.3\n    # Rotation axis must be a unit vector\n    rot_axis_u = np.array([1.0, 2.0, 3.0]) / np.sqrt(1**2 + 2**2 + 3**2)\n\n    # Test suite from the problem statement\n    test_cases = [\n        # (delta, r, theta)\n        (0.0, 10.0, 0.0),\n        (0.5, 10.0, 0.7),\n        (1.0, 10.0, 1.4),\n        (2.0, 10.0, 2.1),\n    ]\n\n    results = []\n    \n    # Function definitions for head gradient and Hessian\n    def grad_h(p):\n        x, y, z = p\n        return np.array([\n            3 * alpha * x**2 + delta_h * y * z,\n            3 * beta * y**2 + delta_h * x * z,\n            3 * gamma * z**2 + delta_h * x * y\n        ])\n\n    def hessian_h(p):\n        x, y, z = p\n        return np.array([\n            [6 * alpha * x, delta_h * z,   delta_h * y],\n            [delta_h * z,   6 * beta * y,  delta_h * x],\n            [delta_h * y,   delta_h * x,   6 * gamma * z]\n        ])\n\n    for delta, r, theta in test_cases:\n        # Step 1: Define Geometry and Permeability\n        A = np.array([[1.0, delta, 0.0],\n                      [0.0, 1.0,   delta],\n                      [0.0, 0.0,   1.0]])\n        \n        # Volume of the sheared cube is det(A) = 1\n        vol_K_delta = 1.0\n\n        # Construct permeability tensor K\n        R = get_rotation_matrix(rot_axis_u, theta)\n        D = np.diag([r, 1.0, 1.0/r])\n        K = R @ D @ R.T\n\n        # Step 2: Calculate Volume Integral Term (this approximation is exact)\n        xi_c = np.array([0.5, 0.5, 0.5])\n        x_c = A @ xi_c\n        \n        div_q_at_xc = -np.trace(K @ hessian_h(x_c))\n        vol_integral_term = vol_K_delta * div_q_at_xc\n\n        # Step 3: Calculate Surface Integral Term\n        surface_integral_term = 0.0\n        \n        # Loop over faces, defined by axis index i (1-based) and side c (0 or 1)\n        for i_ax in range(1, 4):\n            if i_ax == 1:\n                j_ax, k_ax = 2, 3\n            elif i_ax == 2:\n                j_ax, k_ax = 3, 1\n            else:  # i_ax == 3\n                j_ax, k_ax = 1, 2\n            \n            # Convert to 0-based indices for numpy array access\n            i, j, k = i_ax - 1, j_ax - 1, k_ax - 1\n\n            for c in range(2):  # side c=0 or c=1\n                s_ic = -1.0 if c == 0 else 1.0\n                \n                # Oriented area vector a_f = s * (A_ej x A_ek)\n                A_col_j = A[:, j]\n                A_col_k = A[:, k]\n                area_vec = s_ic * np.cross(A_col_j, A_col_k)\n                \n                # Physical location of the face center x_f\n                xi_f = np.array([0.5, 0.5, 0.5])\n                xi_f[i] = float(c)\n                x_f = A @ xi_f\n                \n                # Flux q at the face center x_f\n                q_at_xf = -K @ grad_h(x_f)\n                \n                # Add flux through the face to the sum\n                surface_integral_term += np.dot(q_at_xf, area_vec)\n        \n        # Step 4: Compute the Error Metric E\n        numerator = np.abs(vol_integral_term - surface_integral_term)\n        denominator = np.max([1.0, np.abs(vol_integral_term)])\n        error = numerator / denominator\n        \n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}