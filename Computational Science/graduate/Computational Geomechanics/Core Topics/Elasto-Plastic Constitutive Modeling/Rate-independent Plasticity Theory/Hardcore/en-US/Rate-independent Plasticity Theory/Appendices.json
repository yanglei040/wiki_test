{
    "hands_on_practices": [
        {
            "introduction": "This exercise strips plasticity down to its essential mechanics using a simple one-dimensional model. By analyzing a uniaxial bar, you will derive the evolution of elastic and plastic strains from first principles, solidifying your understanding of the additive strain decomposition, the role of the yield function, and the consistency condition that governs plastic flow. Mastering this foundational case  is a crucial first step before tackling the complexities of three-dimensional geomechanical models.",
            "id": "3554857",
            "problem": "Consider a prismatic uniaxial bar made of a homogeneous geomaterial under small-strain, isothermal conditions. The material follows a rate-independent, perfectly plastic model in one dimension with the additive strain decomposition $\\epsilon = \\epsilon^{e} + \\epsilon^{p}$, linear elasticity $\\sigma = E\\epsilon^{e}$, and a yield function $f(\\sigma) = |\\sigma| - Y$ with constant yield stress $Y > 0$. The plastic flow is associated and rate-independent with Kuhn–Tucker conditions $\\lambda \\ge 0$, $f(\\sigma) \\le 0$, $\\lambda f(\\sigma) = 0$, and the plastic strain rate $\\dot{\\epsilon}^{p} = \\lambda\\,\\partial f/\\partial \\sigma$. Assume a monotonic tensile strain history so that $\\sigma \\ge 0$ and $\\partial f/\\partial \\sigma = 1$ during plastic loading.\n\nThe total strain is prescribed as $\\epsilon(t) = \\alpha t$ for $t \\in [0,T]$ with $\\epsilon(0) = 0$. The parameters are $E = 100$ MPa, $Y = 1$ MPa, $\\alpha = 0.005$ s⁻¹, and $T = 10$ s. The initial plastic strain is zero, $\\epsilon^{p}(0) = 0$.\n\nUsing only the definitions above and the rate-independent plasticity principles, derive from first principles:\n- the piecewise evolution of $\\epsilon^{e}(t)$ and $\\epsilon^{p}(t)$ over $t \\in [0,T]$,\n- the onset time $t_{y}$ of plasticity and the consistency condition at yield,\n- and then compute the final plastic strain $\\epsilon^{p}(T)$.\n\nExpress the final answer as the single number $\\epsilon^{p}(T)$ (dimensionless). Round your answer to four significant figures.",
            "solution": "The problem statement is evaluated for validity prior to attempting a solution.\n\n### Step 1: Extract Givens\n- **Constitutive Model**: Rate-independent, perfectly plastic, 1D, small-strain, isothermal conditions.\n- **Strain Decomposition**: $\\epsilon = \\epsilon^{e} + \\epsilon^{p}$.\n- **Elastic Law**: $\\sigma = E\\epsilon^{e}$.\n- **Yield Function**: $f(\\sigma) = |\\sigma| - Y$, with a constant yield stress $Y > 0$.\n- **Flow Rule (Kuhn–Tucker conditions)**: $\\lambda \\ge 0$, $f(\\sigma) \\le 0$, $\\lambda f(\\sigma) = 0$.\n- **Plastic Strain Rate**: $\\dot{\\epsilon}^{p} = \\lambda \\frac{\\partial f}{\\partial \\sigma}$.\n- **Loading Assumption**: Monotonic tensile strain, implying $\\sigma \\ge 0$ and thus $\\frac{\\partial f}{\\partial \\sigma} = 1$.\n- **Prescribed Total Strain**: $\\epsilon(t) = \\alpha t$ for $t \\in [0,T]$.\n- **Initial Conditions**: $\\epsilon(0) = 0$, $\\epsilon^{p}(0) = 0$.\n- **Parameters**: $E = 100$ MPa, $Y = 1$ MPa, $\\alpha = 0.005$ s⁻¹, $T = 10$ s.\n- **Objective**: Derive the evolution of $\\epsilon^{e}(t)$ and $\\epsilon^{p}(t)$, find the onset time of plasticity $t_{y}$, explain the consistency condition, and compute the final plastic strain $\\epsilon^{p}(T)$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is well-defined and scientifically grounded.\n- **Scientifically Grounded**: The problem describes the canonical 1D elastoplastic model, which is a fundamental concept in solid mechanics and geomechanics. All equations and conditions (additive strain decomposition, Hooke's law, von Mises-like yield criterion in 1D, associated flow rule, Kuhn-Tucker conditions) are standard components of rate-independent plasticity theory.\n- **Well-Posed**: The problem provides a complete set of material parameters ($E, Y$), a well-defined loading history ($\\epsilon(t) = \\alpha t$), and necessary initial conditions ($\\epsilon^p(0) = 0$). This ensures a unique solution can be determined.\n- **Objective**: The problem is stated using precise, standard, and unambiguous terminology from continuum mechanics.\n- **Consistency**: The provided data are dimensionally and physically consistent. The setup does not contain contradictions.\n\n### Step 3: Verdict and Action\nThe problem is valid. A solution will be derived from first principles as requested.\n\n### Derivation\n\nThe analysis is divided into two phases: the initial elastic phase and the subsequent plastic phase.\n\n**1. Elastic Phase: $t \\in [0, t_y]$**\n\nInitially, the material is unstressed. As strain is applied, the response is purely elastic. In this regime, there is no plastic deformation, so $\\epsilon^{p}(t) = 0$ and its rate $\\dot{\\epsilon}^{p}(t) = 0$.\n\nFrom the flow rule, $\\dot{\\epsilon}^{p} = \\lambda \\frac{\\partial f}{\\partial \\sigma}$. Since $\\frac{\\partial f}{\\partial \\sigma} = 1$ for tensile loading, we have $\\dot{\\epsilon}^{p} = \\lambda$. Thus, $\\lambda = 0$ during the elastic phase.\nThe Kuhn-Tucker conditions require $\\lambda f(\\sigma) = 0$ and $f(\\sigma) \\le 0$. Since $\\lambda = 0$, the condition must be $f(\\sigma)  0$ for a strictly elastic response. For tensile loading ($\\sigma \\ge 0$), this is $f(\\sigma) = \\sigma - Y  0$, which implies $\\sigma  Y$.\n\nThe strain evolution is governed by:\n- Total strain (given): $\\epsilon(t) = \\alpha t$.\n- Strain decomposition: $\\epsilon(t) = \\epsilon^{e}(t) + \\epsilon^{p}(t)$. With $\\epsilon^{p}(t) = 0$, we have $\\epsilon^{e}(t) = \\epsilon(t) = \\alpha t$.\n- Elastic law: $\\sigma(t) = E\\epsilon^{e}(t) = E\\alpha t$.\n\nThe elastic phase ends and plastic yielding begins at the time $t_{y}$ when the stress reaches the yield strength $Y$.\n$$ \\sigma(t_y) = Y $$\n$$ E\\alpha t_{y} = Y $$\nSolving for the onset time of plasticity, $t_{y}$:\n$$ t_{y} = \\frac{Y}{E\\alpha} $$\nAt this time, the total strain is the yield strain, $\\epsilon_y$:\n$$ \\epsilon_y = \\epsilon(t_y) = \\alpha t_y = \\frac{Y}{E} $$\nFor $t \\le t_y$, the evolution of the strain components is:\n$$ \\epsilon^{e}(t) = \\alpha t $$\n$$ \\epsilon^{p}(t) = 0 $$\n\n**2. Plastic Phase: $t \\in [t_y, T]$**\n\nFor $t  t_y$, the material undergoes plastic deformation. According to the Kuhn-Tucker conditions, if plastic flow occurs ($\\lambda  0$), then the yield condition must be continuously satisfied, i.e., $f(\\sigma) = 0$. For tensile loading, this means:\n$$ \\sigma(t) = Y \\quad \\text{for all } t \\ge t_y $$\nThis is the state of perfect plasticity, where stress remains constant at the yield value during plastic flow.\n\nThe **consistency condition** requires that the stress state remains on the yield surface during plastic loading. In rate form, this means $\\dot{f} = 0$. For our problem, this implies $\\dot{\\sigma} = 0$.\nLet's use this to find the strain rates. Differentiating the elastic law with respect to time gives $\\dot{\\sigma} = E\\dot{\\epsilon}^{e}$. Since $\\dot{\\sigma}=0$ in the plastic phase, it follows that:\n$$ \\dot{\\epsilon}^{e}(t) = 0 \\quad \\text{for } t  t_y $$\nThis means the elastic strain remains constant at the value it had at the onset of yield:\n$$ \\epsilon^{e}(t) = \\epsilon^{e}(t_y) = \\frac{\\sigma(t_y)}{E} = \\frac{Y}{E} \\quad \\text{for all } t \\ge t_y $$\nNow we analyze the total strain rate. The prescribed total strain is $\\epsilon(t) = \\alpha t$, so its rate is constant:\n$$ \\dot{\\epsilon}(t) = \\alpha $$\nUsing the additive decomposition of strain rates, $\\dot{\\epsilon} = \\dot{\\epsilon}^{e} + \\dot{\\epsilon}^{p}$, we can find the plastic strain rate:\n$$ \\alpha = 0 + \\dot{\\epsilon}^{p}(t) $$\n$$ \\dot{\\epsilon}^{p}(t) = \\alpha \\quad \\text{for } t  t_y $$\nTo find the plastic strain $\\epsilon^{p}(t)$, we integrate its rate from the onset of plasticity $t_{y}$, where $\\epsilon^{p}(t_{y})=0$:\n$$ \\epsilon^{p}(t) = \\int_{t_y}^{t} \\dot{\\epsilon}^{p}(\\tau) d\\tau = \\int_{t_y}^{t} \\alpha d\\tau = \\alpha(t - t_y) $$\nSubstituting the expression for $t_y$:\n$$ \\epsilon^{p}(t) = \\alpha t - \\alpha t_y = \\alpha t - \\frac{Y}{E} $$\nThis expression is valid for $t \\ge t_y$.\n\n**Summary of Piecewise Evolution for $t \\in [0, T]$**:\n- The onset time of plasticity is $t_y = \\frac{Y}{E\\alpha}$.\n- For $t \\in [0, t_y]$ (Elastic Regime):\n  $$ \\epsilon^{e}(t) = \\alpha t $$\n  $$ \\epsilon^{p}(t) = 0 $$\n- For $t \\in [t_y, T]$ (Plastic Regime):\n  $$ \\epsilon^{e}(t) = \\frac{Y}{E} $$\n  $$ \\epsilon^{p}(t) = \\alpha \\left( t - t_y \\right) = \\alpha t - \\frac{Y}{E} $$\n\n**3. Final Calculation**\n\nWe are asked to compute the final plastic strain $\\epsilon^{p}(T)$. First, we must calculate $t_{y}$ to confirm that plasticity occurs within the given time interval $T = 10$ s.\nUsing the given parameters: $E = 100$ MPa, $Y = 1$ MPa, $\\alpha = 0.005$ s⁻¹.\n$$ t_{y} = \\frac{1\\,\\mathrm{MPa}}{(100\\,\\mathrm{MPa}) \\times (0.005\\,\\mathrm{s}^{-1})} = \\frac{1}{0.5}\\,\\mathrm{s} = 2\\,\\mathrm{s} $$\nSince $t_y = 2$ s $ T = 10$ s, the material does enter the plastic regime.\n\nWe can now calculate the final plastic strain $\\epsilon^{p}(T)$ using the derived expression for the plastic phase:\n$$ \\epsilon^{p}(T) = \\alpha (T - t_{y}) $$\nSubstituting the numerical values:\n$$ \\epsilon^{p}(10) = 0.005\\,\\mathrm{s}^{-1} \\times (10\\,\\mathrm{s} - 2\\,\\mathrm{s}) $$\n$$ \\epsilon^{p}(10) = 0.005 \\times 8 $$\n$$ \\epsilon^{p}(10) = 0.04 $$\nThe final plastic strain is a dimensionless quantity. The problem asks for the answer to be rounded to four significant figures. The exact value is $0.04$. Expressed with four significant figures, this is $0.04000$.",
            "answer": "$$\\boxed{0.04000}$$"
        },
        {
            "introduction": "Moving from one to three dimensions requires a robust way to describe the stress state, independent of the chosen coordinate system. This practice introduces the use of stress invariants—the mean stress $p$, deviatoric stress $q$, and Lode angle $\\theta$—to characterize a general triaxial stress state. You will apply these concepts to the industry-standard Mohr-Coulomb yield criterion to determine if a soil element is in an elastic state or has reached the point of plastic failure , a fundamental skill for any geomechanical analysis.",
            "id": "3554932",
            "problem": "Consider a geomaterial modeled by rate-independent plasticity using the Mohr–Coulomb (MC) yield criterion. Adopt the geomechanics sign convention in which compressive stresses are positive. A specimen is subjected to an axisymmetric triaxial stress state with principal stresses $\\sigma_1$, $\\sigma_2$, and $\\sigma_3$, where $\\sigma_2 = \\sigma_3$. The applied stresses are $\\sigma_1 = 650$ kPa and $\\sigma_2 = \\sigma_3 = 220$ kPa. The material parameters are the friction angle $\\phi = 30^{\\circ}$ and the cohesion $c = 5$ kPa.\n\nStarting from the fundamental definitions of the mean stress $p$ and the deviatoric stress tensor $\\mathbf{s}$, as well as the second and third invariants $J_2$ and $J_3$ of $\\mathbf{s}$, derive expressions for the stress invariants and compute the scalar measures $p$, $q$ (defined via $J_2$), and the Lode angle $\\theta$ for this stress state. Based on the computed $\\theta$, identify the active meridian (triaxial compression versus triaxial extension). Using the appropriate meridian of the Mohr–Coulomb yield surface in the $(p,q)$-invariants representation, evaluate the plastic admissibility measure $f$ (the yield function value) at the given stress state.\n\nExpress the final value of $f$ in kilopascals (kPa) and round your answer to four significant figures. The Lode angle must be reported in degrees within your derivation. Your submission must provide the single numerical value of $f$ only as the final answer.",
            "solution": "The problem is evaluated to be valid as it is scientifically grounded, well-posed, objective, and contains all necessary information for a unique solution.\n\nThe objective is to evaluate the Mohr-Coulomb yield function, $f$, for a given axisymmetric triaxial stress state. The geomechanics sign convention, where compressive stresses are positive, is adopted.\n\nFirst, we list the given data:\nThe principal stresses are $\\sigma_1 = 650$ kPa and $\\sigma_2 = \\sigma_3 = 220$ kPa.\nThe material parameters are the friction angle $\\phi = 30^{\\circ}$ and cohesion $c = 5$ kPa.\n\nThe solution proceeds by first computing the stress invariants $p$, $q$, and the Lode angle $\\theta$, and then using these to evaluate the yield function.\n\n1.  **Calculation of Stress Invariants**\n\nThe mean stress, $p$, is defined as the first invariant of the stress tensor $\\boldsymbol{\\sigma}$, divided by three:\n$$p = \\frac{1}{3} \\text{tr}(\\boldsymbol{\\sigma}) = \\frac{1}{3}(\\sigma_1 + \\sigma_2 + \\sigma_3)$$\nSubstituting the given values:\n$$p = \\frac{1}{3}(650 + 220 + 220) \\text{ kPa} = \\frac{1090}{3} \\text{ kPa}$$\n\nThe deviatoric stress tensor, $\\mathbf{s}$, is defined as $\\mathbf{s} = \\boldsymbol{\\sigma} - p\\mathbf{I}$, where $\\mathbf{I}$ is the identity tensor. Its principal components are:\n$$s_i = \\sigma_i - p$$\n$$s_1 = 650 - \\frac{1090}{3} = \\frac{1950 - 1090}{3} = \\frac{860}{3} \\text{ kPa}$$\n$$s_2 = s_3 = 220 - \\frac{1090}{3} = \\frac{660 - 1090}{3} = -\\frac{430}{3} \\text{ kPa}$$\n\nThe second invariant of the deviatoric stress tensor, $J_2$, is:\n$$J_2 = \\frac{1}{2}\\text{tr}(\\mathbf{s}^2) = \\frac{1}{2}(s_1^2 + s_2^2 + s_3^2)$$\n$$J_2 = \\frac{1}{2}\\left[\\left(\\frac{860}{3}\\right)^2 + \\left(-\\frac{430}{3}\\right)^2 + \\left(-\\frac{430}{3}\\right)^2\\right] = \\frac{1}{18}\\left(860^2 + 2 \\cdot 430^2\\right)$$\nSince $860 = 2 \\cdot 430$, we have:\n$$J_2 = \\frac{1}{18}\\left((2 \\cdot 430)^2 + 2 \\cdot 430^2\\right) = \\frac{1}{18}\\left(4 \\cdot 430^2 + 2 \\cdot 430^2\\right) = \\frac{6 \\cdot 430^2}{18} = \\frac{430^2}{3} \\text{ (kPa)}^2$$\n\nThe deviatoric stress measure, $q$, is defined via $J_2$ as:\n$$q = \\sqrt{3J_2}$$\n$$q = \\sqrt{3 \\cdot \\frac{430^2}{3}} = \\sqrt{430^2} = 430 \\text{ kPa}$$\nFor an axisymmetric stress state, this is equivalent to $q = |\\sigma_1 - \\sigma_3| = |650 - 220| = 430$ kPa.\n\nThe third invariant of the deviatoric stress tensor, $J_3$, is:\n$$J_3 = \\det(\\mathbf{s}) = s_1 s_2 s_3$$\n$$J_3 = \\left(\\frac{860}{3}\\right)\\left(-\\frac{430}{3}\\right)\\left(-\\frac{430}{3}\\right) = \\frac{2 \\cdot 430 \\cdot 430^2}{27} = \\frac{2 \\cdot 430^3}{27} \\text{ (kPa)}^3$$\n\nThe Lode angle, $\\theta$, characterizes the type of deviatoric stress state. A standard definition is:\n$$\\sin(3\\theta) = \\frac{3\\sqrt{3}}{2} \\frac{J_3}{J_2^{3/2}}$$\nWe have $J_2^{3/2} = \\left(\\frac{430^2}{3}\\right)^{3/2} = \\frac{430^3}{3\\sqrt{3}}$. Substituting $J_2^{3/2}$ and $J_3$:\n$$\\sin(3\\theta) = \\frac{3\\sqrt{3}}{2} \\frac{2 \\cdot 430^3 / 27}{430^3 / (3\\sqrt{3})} = \\frac{3\\sqrt{3}}{2} \\cdot \\frac{2 \\cdot 430^3}{27} \\cdot \\frac{3\\sqrt{3}}{430^3} = \\frac{3 \\cdot \\sqrt{3} \\cdot 2 \\cdot 3 \\cdot \\sqrt{3}}{2 \\cdot 27} = \\frac{54}{54} = 1$$\nThus, $\\sin(3\\theta) = 1$, which implies $3\\theta = 90^{\\circ}$, and therefore $\\theta = 30^{\\circ}$.\n\n2.  **Identification of Active Meridian**\n\nThe Lode angle $\\theta = 30^{\\circ}$ corresponds to the triaxial compression (TXC) meridian, which is consistent with the given stress state where $\\sigma_1 > \\sigma_2 = \\sigma_3$.\n\n3.  **Evaluation of the Mohr-Coulomb Yield Function**\n\nThe Mohr-Coulomb yield criterion can be expressed in terms of the invariants $p, q, \\theta$. A common form of the yield function $f$ is:\n$$f(p, q, \\theta) = q - q_y$$\nwhere $q_y$ is the yield value of the deviatoric stress measure. For the Mohr-Coulomb model, $q_y$ is given by:\n$$q_y = m(\\theta) \\left( p + c \\cot\\phi \\right)$$\nThe function $m(\\theta)$ depends on the Lode angle and material friction angle:\n$$m(\\theta) = \\frac{6\\sin\\phi}{3 - \\sin\\phi\\sin(3\\theta)}$$\nSince the active stress path is on the TXC meridian, we use $\\theta = 30^{\\circ}$, for which $\\sin(3\\theta) = 1$. The function $m(\\theta)$ simplifies to $m_c$:\n$$m_c = m(30^{\\circ}) = \\frac{6\\sin\\phi}{3 - \\sin\\phi}$$\nThe yield function for the TXC meridian is thus:\n$$f = q - \\frac{6\\sin\\phi}{3 - \\sin\\phi} \\left( p + c \\cot\\phi \\right)$$\nNow we substitute the known values:\n$p = \\frac{1090}{3}$ kPa\n$q = 430$ kPa\n$\\phi = 30^{\\circ} \\implies \\sin\\phi = \\frac{1}{2}$, $\\cot\\phi = \\sqrt{3}$\n$c = 5$ kPa\n\nFirst, we calculate the slope parameter $m_c$:\n$$m_c = \\frac{6 \\cdot (1/2)}{3 - 1/2} = \\frac{3}{5/2} = \\frac{6}{5} = 1.2$$\nNext, we evaluate the term in the parentheses:\n$$p + c\\cot\\phi = \\frac{1090}{3} + 5\\sqrt{3} \\text{ kPa}$$\nNow, we can compute the value of the yield function $f$:\n$$f = 430 - 1.2 \\left( \\frac{1090}{3} + 5\\sqrt{3} \\right)$$\n$$f = 430 - \\left( 1.2 \\cdot \\frac{1090}{3} + 1.2 \\cdot 5\\sqrt{3} \\right)$$\n$$f = 430 - \\left( 0.4 \\cdot 1090 + 6\\sqrt{3} \\right)$$\n$$f = 430 - \\left( 436 + 6\\sqrt{3} \\right)$$\n$$f = 430 - 436 - 6\\sqrt{3}$$\n$$f = -6 - 6\\sqrt{3} \\text{ kPa}$$\nUsing the approximation $\\sqrt{3} \\approx 1.73205$:\n$$f \\approx -6 - 6(1.73205) = -6 - 10.3923 = -16.3923 \\text{ kPa}$$\nThe negative value indicates that the stress state is inside the yield surface, i.e., in the elastic region.\nRounding the result to four significant figures as requested:\n$$f \\approx -16.39 \\text{ kPa}$$",
            "answer": "$$\\boxed{-16.39}$$"
        },
        {
            "introduction": "This final practice bridges the gap between analytical theory and computational practice, challenging you to implement a complete stress update algorithm. You will develop a \"return mapping\" scheme for the non-smooth Mohr-Coulomb yield surface, a core component of modern finite element software. This hands-on coding exercise  will require you to translate the concepts of yield functions, non-associated plastic flow, and consistency conditions into a robust active-set algorithm that correctly handles the complexities of edges and corners on the yield surface.",
            "id": "3554851",
            "problem": "You are tasked with designing and implementing an algorithmic stress update for rate-independent elastoplasticity in computational geomechanics under the Mohr–Coulomb model. The update must operate in principal stress space and rigorously handle non-smoothness at corners and the apex via subdifferentials of the yield function. The program you write must produce the updated principal stresses for a fixed set of test cases.\n\nBegin from the following fundamental base of small-strain elastoplasticity:\n- The Cauchy stress tensor is denoted by $\\boldsymbol{\\sigma}$ and its principal values by $(\\sigma_1,\\sigma_2,\\sigma_3)$.\n- Linear isotropic elasticity relates stress increments to elastic strain increments via the fourth-order elasticity tensor $\\mathbb{D} = K \\,\\boldsymbol{I}\\otimes\\boldsymbol{I} + 2G\\,\\mathbb{I}^{\\text{dev}}$, where $K$ is the bulk modulus and $G$ is the shear modulus, $\\boldsymbol{I}$ is the second-order identity, and $\\mathbb{I}^{\\text{dev}}$ is the fourth-order deviatoric projector.\n- Rate-independent plasticity is governed by the Karush–Kuhn–Tucker (KKT) conditions with a yield function $f(\\boldsymbol{\\sigma}) \\le 0$, a plastic multiplier $\\lambda \\ge 0$, and consistency $\\lambda f(\\boldsymbol{\\sigma}) = 0$, and the flow rule $d\\boldsymbol{\\varepsilon}^{p} = \\lambda\\,\\partial g(\\boldsymbol{\\sigma})$, where $g(\\boldsymbol{\\sigma})$ is the plastic potential and $\\partial g$ is its subdifferential when $g$ is non-smooth.\n- Assume small strains, isotropy, and that principal directions remain coaxial during the return mapping.\n\nWithin this base, derive and implement:\n- A Mohr–Coulomb yield function $f(\\boldsymbol{\\sigma})$ expressed in principal stress space $(\\sigma_1,\\sigma_2,\\sigma_3)$ that is piecewise-linear and non-smooth at Lode angle values defining corners and edges. Treat compression as positive. The yield depends on friction angle $\\varphi$ and cohesion $c$. You must explicitly represent the non-smooth yield as the pointwise maximum of a finite set of linear forms in $(\\sigma_1,\\sigma_2,\\sigma_3)$, and construct its subdifferential $\\partial f(\\boldsymbol{\\sigma})$ via the convex hull of the gradients of the active linear forms (those attaining the maximum).\n- A non-associative plastic potential $g(\\boldsymbol{\\sigma})$ with dilation angle $\\psi$ that mirrors the yield in structure (face-wise linear forms), and whose gradient or subgradient provides the plastic flow direction.\n\nAlgorithmic requirements:\n- Implement an active-set return-mapping algorithm in principal stress space to correct a given elastic trial stress $\\boldsymbol{\\sigma}^{\\text{tr}}$ to the admissible set $f(\\boldsymbol{\\sigma}) \\le 0$. Use the flow direction from $\\partial g(\\boldsymbol{\\sigma})$ and the elasticity tensor $\\mathbb{D}$ to derive the stress correction $\\Delta\\boldsymbol{\\sigma} = -\\lambda\\,\\mathbb{D}:\\boldsymbol{n}$, where $\\boldsymbol{n} \\in \\partial g(\\boldsymbol{\\sigma})$ is a subgradient consistent with the active set. Enforce the yield equalities for the active faces and KKT conditions. At corners and the apex, treat $\\boldsymbol{n}$ as a convex combination of active face normals and solve for the convex weights and $\\lambda$ so that the corrected stress lies exactly on the intersection defined by the active faces. Use a robust tolerance to detect multiple active faces.\n- Explicitly handle faces (one active linear form), edges (two active linear forms), and the apex (all principal stresses equal with multiple active forms). At the apex, recognize the subdifferential as the convex hull of all face normals and ensure the algorithm remains well-defined even when no plastic correction is required.\n\nYou must also compute the Lode angle $\\theta$ from the principal stresses via the second and third invariants of the deviatoric stress, and ensure that the active-set logic is consistent with non-smoothness at the Lode angle boundaries. Angle units must be radians.\n\nNumerical and physical units must be specified and used consistently:\n- Use stress in megapascals (MPa).\n- Use angles in radians.\n\nTest suite and output specification:\n- Implement your algorithm and apply it to the following test cases, all with isotropic linear elasticity and compression-positive sign convention:\n    1. Smooth-face return, parameters: friction angle $\\varphi = \\pi/6$ (i.e., $0.5235987756$ radians), dilation angle $\\psi = \\pi/18$ (i.e., $0.1745329252$ radians), cohesion $c = 5$ MPa, bulk modulus $K = 5000$ MPa, shear modulus $G = 3000$ MPa, trial principal stresses $(\\sigma_1^{\\text{tr}},\\sigma_2^{\\text{tr}},\\sigma_3^{\\text{tr}}) = (150,90,30)$ MPa.\n    2. Edge-case return with two equal principal stresses to trigger two active faces: friction angle $\\varphi = \\pi/6$, dilation angle $\\psi = \\pi/18$, cohesion $c = 5$ MPa, bulk modulus $K = 5000$ MPa, shear modulus $G = 3000$ MPa, trial principal stresses $(\\sigma_1^{\\text{tr}},\\sigma_2^{\\text{tr}},\\sigma_3^{\\text{tr}}) = (200,60,60)$ MPa.\n    3. Apex boundary case with all principal stresses equal (no plastic correction expected but subdifferential must be well-defined): friction angle $\\varphi = \\pi/6$, dilation angle $\\psi = \\pi/18$, cohesion $c = 0$ MPa, bulk modulus $K = 5000$ MPa, shear modulus $G = 3000$ MPa, trial principal stresses $(\\sigma_1^{\\text{tr}},\\sigma_2^{\\text{tr}},\\sigma_3^{\\text{tr}}) = (80,80,80)$ MPa.\n- For each test case, compute the updated principal stresses $(\\sigma_1,\\sigma_2,\\sigma_3)$ in MPa.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each item is itself a list of the updated principal stresses rounded to three decimal places, for example: $[\\,[\\sigma_1,\\sigma_2,\\sigma_3],\\,[\\sigma_1,\\sigma_2,\\sigma_3],\\,[\\sigma_1,\\sigma_2,\\sigma_3]\\,]$.\n\nEnsure scientific realism and numerical robustness, including reasonable stopping tolerances and handling of degenerate cases. No user input is permitted; all parameters and test cases must be embedded in the program. The final output must strictly follow the specified format.",
            "solution": "We begin from small-strain rate-independent elastoplasticity with isotropic linear elasticity. The elasticity tensor is $\\mathbb{D} = K \\,\\boldsymbol{I}\\otimes\\boldsymbol{I} + 2G\\,\\mathbb{I}^{\\text{dev}}$, so for any symmetric second-order tensor $\\boldsymbol{A}$, the action of $\\mathbb{D}$ is\n$$\n\\mathbb{D}:\\boldsymbol{A} = K\\,\\text{tr}(\\boldsymbol{A})\\,\\boldsymbol{I} + 2G\\left(\\boldsymbol{A} - \\tfrac{1}{3}\\text{tr}(\\boldsymbol{A})\\,\\boldsymbol{I}\\right).\n$$\nThe Mohr–Coulomb yield function is non-smooth and can be represented in principal stress space as the pointwise maximum of a finite set of linear forms that capture the frictional failure planes. Under compression-positive convention, a convenient representation is\n$$\nf(\\boldsymbol{\\sigma}) = \\max_{i\\neq j} \\left\\{\\, (1-\\sin\\varphi)\\,\\sigma_i - (1+\\sin\\varphi)\\,\\sigma_j - 2c\\cos\\varphi \\,\\right\\},\n$$\nwhere $(i,j)\\in\\{(1,2),(1,3),(2,1),(2,3),(3,1),(3,2)\\}$. This form encodes six planar faces in the $(\\sigma_1,\\sigma_2,\\sigma_3)$ space, and the overall yield surface is their upper envelope. The non-differentiability arises when multiple faces are simultaneously active, i.e., attain the maximum.\n\nThe plastic potential $g(\\boldsymbol{\\sigma})$ for non-associative flow is defined analogously, but with the dilation angle $\\psi$ in place of $\\varphi$:\n$$\ng(\\boldsymbol{\\sigma}) = \\max_{i\\neq j} \\left\\{\\, (1-\\sin\\psi)\\,\\sigma_i - (1+\\sin\\psi)\\,\\sigma_j - 2c\\cos\\psi \\,\\right\\}.\n$$\nFor a single active face $(i,j)$, the gradient of the plastic potential with respect to principal stresses is the vector\n$$\n\\boldsymbol{n}^{(i,j)} = \\left(n_1,n_2,n_3\\right),\\quad n_k =\n\\begin{cases}\n(1-\\sin\\psi)  \\text{if } k=i,\\\\\n-(1+\\sin\\psi)  \\text{if } k=j,\\\\\n0  \\text{otherwise.}\n\\end{cases}\n$$\nAt non-smooth points (edges and apex), the subdifferential $\\partial g(\\boldsymbol{\\sigma})$ is the convex hull of the gradients of all active faces. If two faces are active, any $\\boldsymbol{n}$ in $\\partial g(\\boldsymbol{\\sigma})$ can be written as $\\boldsymbol{n} = \\alpha\\,\\boldsymbol{n}^{(i_1,j_1)} + (1-\\alpha)\\,\\boldsymbol{n}^{(i_2,j_2)}$ with $\\alpha\\in[0,1]$. If three or more faces are active (the apex case when $\\sigma_1=\\sigma_2=\\sigma_3$), we have $\\boldsymbol{n} = \\sum_{r=1}^m \\alpha_r\\,\\boldsymbol{n}^{(i_r,j_r)}$ with $\\alpha_r\\ge 0$ and $\\sum_r \\alpha_r = 1$.\n\nThe rate-independent flow rule is $d\\boldsymbol{\\varepsilon}^{p} = \\lambda\\,\\boldsymbol{n}$ with $\\boldsymbol{n}\\in\\partial g(\\boldsymbol{\\sigma})$. The stress correction in a return-mapping step is obtained by enforcing elastoplastic consistency with the elasticity tensor. For a given trial stress $\\boldsymbol{\\sigma}^{\\text{tr}}$, the corrected stress is\n$$\n\\boldsymbol{\\sigma} = \\boldsymbol{\\sigma}^{\\text{tr}} - \\lambda\\,\\mathbb{D}:\\boldsymbol{n}.\n$$\nWriting in principal components and letting $t = \\text{tr}(\\boldsymbol{n})$, the principal stress corrections per unit plastic multiplier are\n$$\n\\Delta\\sigma_k' \\equiv \\frac{d\\sigma_k}{d\\lambda} = -\\left[\\,K\\,t + 2G\\left(n_k - \\tfrac{1}{3}t\\right)\\,\\right],\\quad k\\in\\{1,2,3\\}.\n$$\nFor a single active face $(i,j)$, elastoplastic consistency requires $f^{(i,j)}(\\boldsymbol{\\sigma})=0$, namely\n$$\n(1-\\sin\\varphi)\\,\\sigma_i - (1+\\sin\\varphi)\\,\\sigma_j - 2c\\cos\\varphi = 0.\n$$\nSubstituting $\\boldsymbol{\\sigma} = \\boldsymbol{\\sigma}^{\\text{tr}} + \\lambda\\,\\Delta\\boldsymbol{\\sigma}'$ we obtain a linear equation in $\\lambda$:\n$$\n(1-\\sin\\varphi)\\,\\sigma_i^{\\text{tr}} - (1+\\sin\\varphi)\\,\\sigma_j^{\\text{tr}} - 2c\\cos\\varphi + \\lambda\\left[(1-\\sin\\varphi)\\,\\Delta\\sigma_i' - (1+\\sin\\varphi)\\,\\Delta\\sigma_j'\\right] = 0,\n$$\nwhich yields\n$$\n\\lambda = \\frac{(1-\\sin\\varphi)\\,\\sigma_i^{\\text{tr}} - (1+\\sin\\varphi)\\,\\sigma_j^{\\text{tr}} - 2c\\cos\\varphi}{-\\left[(1-\\sin\\varphi)\\,\\Delta\\sigma_i' - (1+\\sin\\varphi)\\,\\Delta\\sigma_j'\\right]}.\n$$\nAt an edge with two active faces $(i_1,j_1)$ and $(i_2,j_2)$, we construct $\\boldsymbol{n}(\\alpha) = \\alpha\\,\\boldsymbol{n}^{(i_1,j_1)} + (1-\\alpha)\\,\\boldsymbol{n}^{(i_2,j_2)}$. The per-unit multiplier stress correction is then $\\Delta\\boldsymbol{\\sigma}'(\\alpha) = \\alpha\\,\\Delta\\boldsymbol{\\sigma}'^{(1)} + (1-\\alpha)\\,\\Delta\\boldsymbol{\\sigma}'^{(2)}$, where $\\Delta\\boldsymbol{\\sigma}'^{(r)}$ is computed from $\\boldsymbol{n}^{(i_r,j_r)}$. Enforcing both active faces yields two linear equalities:\n$$\n(1-\\sin\\varphi)\\,\\sigma_{i_r}^{\\text{tr}} - (1+\\sin\\varphi)\\,\\sigma_{j_r}^{\\text{tr}} - 2c\\cos\\varphi + \\lambda\\left[(1-\\sin\\varphi)\\,\\Delta\\sigma_{i_r}'(\\alpha) - (1+\\sin\\varphi)\\,\\Delta\\sigma_{j_r}'(\\alpha)\\right] = 0,\\quad r=1,2.\n$$\nThese can be combined to eliminate $\\lambda$ by forming the ratio\n$$\n\\frac{(1-\\sin\\varphi)\\,\\Delta\\sigma_{i_1}'(\\alpha) - (1+\\sin\\varphi)\\,\\Delta\\sigma_{j_1}'(\\alpha)}{(1-\\sin\\varphi)\\,\\Delta\\sigma_{i_2}'(\\alpha) - (1+\\sin\\varphi)\\,\\Delta\\sigma_{j_2}'(\\alpha)} = \\frac{(1-\\sin\\varphi)\\,\\sigma_{i_1}^{\\text{tr}} - (1+\\sin\\varphi)\\,\\sigma_{j_1}^{\\text{tr}} - 2c\\cos\\varphi}{(1-\\sin\\varphi)\\,\\sigma_{i_2}^{\\text{tr}} - (1+\\sin\\varphi)\\,\\sigma_{j_2}^{\\text{tr}} - 2c\\cos\\varphi}.\n$$\nThe left-hand side is linear in $\\alpha$ because $\\Delta\\boldsymbol{\\sigma}'(\\alpha)$ is linear in $\\boldsymbol{n}(\\alpha)$, giving a simple linear equation for $\\alpha$. Once $\\alpha$ is found, $\\lambda$ is obtained from either face equality, and the corrected stress follows as $\\boldsymbol{\\sigma} = \\boldsymbol{\\sigma}^{\\text{tr}} + \\lambda\\,\\Delta\\boldsymbol{\\sigma}'(\\alpha)$.\n\nAt the apex when $\\sigma_1 = \\sigma_2 = \\sigma_3$, all faces produce equal values, and the subdifferential $\\partial g(\\boldsymbol{\\sigma})$ is the convex hull of all face normals. However, for Mohr–Coulomb without a cap, hydrostatic states are typically elastic for $c\\ge 0$ (the face forms depend on differences of principal stresses and a constant offset due to cohesion), so no plastic correction is required. The algorithm must still be able to detect multiple active faces and remain well-defined.\n\nTo rigorously handle non-smoothness at specific Lode angle values, we compute the Lode angle $\\theta$ from the principal stresses. Let $p = (\\sigma_1 + \\sigma_2 + \\sigma_3)/3$ be the mean stress and $\\boldsymbol{s} = \\boldsymbol{\\sigma} - p\\,\\boldsymbol{I}$ the deviatoric stress. Then\n$$\nJ_2 = \\tfrac{1}{2}\\left(s_1^2 + s_2^2 + s_3^2\\right),\\quad J_3 = s_1 s_2 s_3,\n$$\nand the Lode angle is defined by\n$$\n\\sin(3\\theta) = \\frac{3\\sqrt{3}}{2}\\,\\frac{J_3}{J_2^{3/2}},\\quad \\theta = \\tfrac{1}{3}\\arcsin\\left(\\sin(3\\theta)\\right),\n$$\nwith the understanding that $J_2 \\to 0$ leads to an indeterminate $\\theta$ at the apex. In practice, non-smoothness at $\\theta$ near $\\pm \\pi/6$ corresponds to edges where two faces are active; our active-set strategy identifies these cases by detecting ties in the face maxima within a tolerance.\n\nAlgorithmic design:\n- Compute all face values $f^{(i,j)}(\\boldsymbol{\\sigma}^{\\text{tr}})$.\n- If $\\max f^{(i,j)} \\le 0$ within tolerance, the state is elastic; return $\\boldsymbol{\\sigma}^{\\text{tr}}$.\n- Otherwise, form the active set $\\mathcal{A}$ as all faces that attain the maximum within a tolerance. If $|\\mathcal{A}|=1$, perform single-face return by solving for $\\lambda$ and updating $\\boldsymbol{\\sigma}$. If $|\\mathcal{A}|\\ge 2$, select two faces from $\\mathcal{A}$ and solve for the convex weight $\\alpha$ and $\\lambda$ as above; if the computed $\\alpha$ lies outside $[0,1]$ or the denominator degenerates, fall back to the dominant single face. Iterate the active-set update: recompute $f^{(i,j)}(\\boldsymbol{\\sigma})$, update $\\mathcal{A}$, and repeat until the maximum face value is driven to zero within tolerance or the active set stabilizes. At the apex, either no correction occurs (elastic) or the algorithm trivially terminates because all face values are equal yet non-positive.\n\nNumerical choices:\n- Use a tolerance of $10^{-9}$ for tie detection and yield satisfaction.\n- Angles are in radians; stresses are in MPa.\n- Round the final principal stresses to three decimal places in the output.\n\nTest case discussion:\n- Case $1$ produces an overstress primarily on a single face; the active-set algorithm finds one active face and performs a single-face return.\n- Case $2$ has $\\sigma_2 = \\sigma_3$, leading to two faces $(1,2)$ and $(1,3)$ being equally active; the algorithm computes a convex combination of face normals and returns to the intersection (edge).\n- Case $3$ has $\\sigma_1 = \\sigma_2 = \\sigma_3$ and $c = 0$ MPa; all face values are equal and non-positive, so the state is elastic; the algorithm detects the apex and returns the trial stresses unchanged while maintaining a well-defined subdifferential.\n\nThe implemented program carries out these steps for the specified test suite and prints a single line with the updated principal stresses for each case, enclosed in brackets and rounded to three decimal places.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef lode_angle(principals):\n    # Compute Lode angle theta from principal stresses\n    s = np.array(principals, dtype=float)\n    p = np.mean(s)\n    dev = s - p\n    J2 = 0.5 * np.sum(dev**2)\n    if J2 = 1e-16:\n        return 0.0  # Apex: undefined; return 0 by convention\n    J3 = dev[0]*dev[1]*dev[2]\n    sin3theta = (3.0*np.sqrt(3.0)/2.0) * (J3 / (J2**1.5))\n    # Clamp to [-1,1] for numerical safety\n    sin3theta = max(-1.0, min(1.0, sin3theta))\n    return (1.0/3.0) * np.arcsin(sin3theta)\n\ndef face_pairs():\n    # All ordered pairs (i,j), i != j\n    return [(0,1),(0,2),(1,0),(1,2),(2,0),(2,1)]\n\ndef yield_face_value(sig, phi, c, pair):\n    i,j = pair\n    sphi = np.sin(phi)\n    cphi = np.cos(phi)\n    return (1.0 - sphi)*sig[i] - (1.0 + sphi)*sig[j] - 2.0*c*cphi\n\ndef yield_face_coeff_vector(phi, pair):\n    # y vector for yield plane linear form: y · sigma - 2c cos(phi)\n    i,j = pair\n    sphi = np.sin(phi)\n    y = np.zeros(3)\n    y[i] = (1.0 - sphi)\n    y[j] = -(1.0 + sphi)\n    return y\n\ndef potential_normal_vector(psi, pair):\n    # n vector (gradient of plastic potential) for a given face\n    i,j = pair\n    spsi = np.sin(psi)\n    n = np.zeros(3)\n    n[i] = (1.0 - spsi)\n    n[j] = -(1.0 + spsi)\n    return n\n\ndef D_contract_n(K, G, n):\n    # Compute D : n (principal components), then negate for per-unit lambda correction\n    t = np.sum(n)\n    # principal components: K*t + 2G*(n_k - t/3)\n    corr = np.empty(3)\n    for k in range(3):\n        corr[k] = K*t + 2.0*G*(n[k] - t/3.0)\n    # Stress correction per unit lambda is -corr\n    return -corr\n\ndef active_set_update_sigma(sig_trial, phi, psi, c, K, G, tol=1e-9, max_iter=50):\n    sig = np.array(sig_trial, dtype=float)\n    pairs = face_pairs()\n    # Iterative active-set loop\n    for _ in range(max_iter):\n        # Compute face values\n        fvals = np.array([yield_face_value(sig, phi, c, pr) for pr in pairs])\n        fmax = np.max(fvals)\n        # Elastic check\n        if fmax = tol:\n            return sig\n        # Active set within tolerance\n        active_indices = [idx for idx, fv in enumerate(fvals) if fv = fmax - tol]\n        # Compute n vectors and D:n corrections for active faces\n        n_list = [potential_normal_vector(psi, pairs[idx]) for idx in active_indices]\n        d_list = [D_contract_n(K, G, n) for n in n_list]\n        y_list = [yield_face_coeff_vector(phi, pairs[idx]) for idx in active_indices]\n        # Single-face return\n        if len(active_indices) == 1:\n            y = y_list[0]\n            d = d_list[0]\n            # Compute denominator: y · d restricted to the two nonzero components automatically handled by dot\n            denom = np.dot(y, d)\n            num = fvals[active_indices[0]]\n            # If denom nearly zero, fallback to small step; else compute lambda\n            if abs(denom)  1e-20:\n                # Fallback: tiny step to avoid stagnation\n                lam = 0.0\n            else:\n                lam = -num / denom\n            if lam  0.0:\n                # If negative due to numerical issues, clamp to zero\n                lam = 0.0\n            sig_new = sig + lam * d\n            sig = sig_new\n            # Continue loop to check if satisfied\n            continue\n        # Two-face edge return (use first two active faces)\n        # Construct linear functions A1(alpha) and A2(alpha) for denominators\n        idx1, idx2 = active_indices[0], active_indices[1]\n        y1, y2 = y_list[0], y_list[1]\n        d1, d2 = d_list[0], d_list[1]\n        # A_r(alpha) = y_r · (alpha d1 + (1-alpha) d2) = alpha y_r·d1 + (1-alpha) y_r·d2\n        a1 = np.dot(y1, d1) - np.dot(y1, d2)\n        b1 = np.dot(y1, d2)\n        a2 = np.dot(y2, d1) - np.dot(y2, d2)\n        b2 = np.dot(y2, d2)\n        # Ratio r = f1 / f2 (note fvals positive if overstressed)\n        f1 = fvals[idx1]\n        f2 = fvals[idx2]\n        # Solve for alpha from (a1 alpha + b1) = (f1/f2) (a2 alpha + b2)\n        # Handle degenerate f2 ~ 0\n        if abs(f2)  1e-20:\n            # Fallback to single-face return on idx1\n            y = y1\n            d = d1\n            denom = np.dot(y, d)\n            num = f1\n            lam = 0.0 if abs(denom)  1e-20 else -num / denom\n            if lam  0.0:\n                lam = 0.0\n            sig = sig + lam * d\n            continue\n        r = f1 / f2\n        denom_alpha = (a1 - r * a2)\n        if abs(denom_alpha)  1e-20:\n            # Degenerate: choose alpha = 0.5\n            alpha = 0.5\n        else:\n            alpha = (r * b2 - b1) / denom_alpha\n        # Clamp alpha to [0,1]; if out of bounds, fallback to nearer single face\n        if alpha  0.0 - 1e-12 or alpha  1.0 + 1e-12:\n            # Choose the face with larger fval\n            if f1 = f2:\n                y = y1\n                d = d1\n                num = f1\n            else:\n                y = y2\n                d = d2\n                num = f2\n            denom = np.dot(y, d)\n            lam = 0.0 if abs(denom)  1e-20 else -num / denom\n            if lam  0.0:\n                lam = 0.0\n            sig = sig + lam * d\n            continue\n        # Compute combined correction and lambda\n        d_comb = alpha * d1 + (1.0 - alpha) * d2\n        A1 = a1 * alpha + b1\n        lam = 0.0 if abs(A1)  1e-20 else -f1 / A1\n        if lam  0.0:\n            lam = 0.0\n        sig = sig + lam * d_comb\n        # Continue to next iteration\n    # If not converged within max_iter, return last state\n    return sig\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Smooth-face return\n        {\n            \"phi\": np.pi/6,      # radians\n            \"psi\": np.pi/18,     # radians\n            \"c\": 5.0,            # MPa\n            \"K\": 5000.0,         # MPa\n            \"G\": 3000.0,         # MPa\n            \"sigma_trial\": np.array([150.0, 90.0, 30.0])  # MPa\n        },\n        # Case 2: Edge-case return with sigma2 = sigma3\n        {\n            \"phi\": np.pi/6,\n            \"psi\": np.pi/18,\n            \"c\": 5.0,\n            \"K\": 5000.0,\n            \"G\": 3000.0,\n            \"sigma_trial\": np.array([200.0, 60.0, 60.0])\n        },\n        # Case 3: Apex boundary case, c = 0\n        {\n            \"phi\": np.pi/6,\n            \"psi\": np.pi/18,\n            \"c\": 0.0,\n            \"K\": 5000.0,\n            \"G\": 3000.0,\n            \"sigma_trial\": np.array([80.0, 80.0, 80.0])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        sig_tr = case[\"sigma_trial\"]\n        phi = case[\"phi\"]\n        psi = case[\"psi\"]\n        c = case[\"c\"]\n        K = case[\"K\"]\n        G = case[\"G\"]\n        sig_upd = active_set_update_sigma(sig_tr, phi, psi, c, K, G, tol=1e-9, max_iter=50)\n        # Round to three decimals\n        sig_rounded = [float(f\"{x:.3f}\") for x in sig_upd]\n        results.append(sig_rounded)\n\n    # Final print statement in the exact required format.\n    # Format: [[s11,s12,s13],[s21,s22,s23],[s31,s32,s33]]\n    formatted = \"[\" + \",\".join(\"[\" + \",\".join(f\"{x:.3f}\" for x in res) + \"]\" for res in results) + \"]\"\n    print(formatted)\n\nsolve()\n```"
        }
    ]
}