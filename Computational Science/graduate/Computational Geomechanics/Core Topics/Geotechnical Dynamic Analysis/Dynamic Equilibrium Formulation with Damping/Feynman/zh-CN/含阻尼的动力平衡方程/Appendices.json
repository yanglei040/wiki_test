{
    "hands_on_practices": [
        {
            "introduction": "瑞利阻尼是岩土力学动力分析中一种广泛应用的简化模型。本练习将引导你通过模态分析，从多自由度系统的动力平衡方程出发，推导出每个振动模态的等效阻尼比。掌握这一推导过程，对于深刻理解瑞利阻尼参数 $\\alpha$ 和 $\\beta$ 如何影响系统各阶模态的能量耗散至关重要。",
            "id": "3519848",
            "problem": "考虑一个通过有限元(FE)法离散化的小应变、线性弹性土壤域，得到如下半离散的动力平衡方程：\n$$\n\\mathbf{M}\\,\\ddot{\\mathbf{u}}(t) + \\mathbf{C}\\,\\dot{\\mathbf{u}}(t) + \\mathbf{K}\\,\\mathbf{u}(t) = \\mathbf{0},\n$$\n其中 $\\mathbf{M}$ 是对称正定质量矩阵，$\\mathbf{K}$ 是对称正定刚度矩阵，$\\mathbf{C}$ 是阻尼矩阵，$\\mathbf{u}(t)$ 是节点位移向量。假设存在比例（瑞利）阻尼，使得\n$$\n\\mathbf{C} = \\alpha\\,\\mathbf{M} + \\beta\\,\\mathbf{K},\n$$\n其中 $\\alpha > 0$ 且 $\\beta > 0$。设无阻尼振型特性由以下广义特征值问题定义：\n$$\n\\mathbf{K}\\,\\boldsymbol{\\phi}_n = \\omega_n^{2}\\,\\mathbf{M}\\,\\boldsymbol{\\phi}_n,\n$$\n其中 $\\boldsymbol{\\phi}_n$ 是第 $n$ 阶振型，$\\omega_n$ 是其无阻尼自振圆频率。从半离散形式的牛顿第二定律和瑞利阻尼的定义出发，进行振型变换，并利用无阻尼振型的基本正交性关系，来获得任意振型 $n$ 的标量振型方程。从该标量方程中，推导出第 $n$ 阶振型的阻尼比 $\\zeta_n$ 和有阻尼自振圆频率 $\\omega_{d,n}$，并用 $\\alpha$、$\\beta$ 和 $\\omega_n$ 表示，除了线性和比例阻尼之外，不引入任何额外的本构或唯象假设。以符号形式表达您的最终答案，并将其呈现为一个单行矩阵，其中按顺序包含 $\\zeta_n$ 和 $\\omega_{d,n}$ 的两个解析表达式。无需进行数值计算。如果引入任何辅助振型量，它们必须在最终表达式中被消除，以使表达式中仅出现 $\\alpha$、$\\beta$ 和 $\\omega_n$。使用 LaTeX 的 $\\mathrm{pmatrix}$ 环境提供最终答案，并且不要在最终的方框表达式中包含单位。",
            "solution": "首先根据既定准则对问题进行验证。\n\n### 步骤1：提取已知条件\n-   线性弹性土壤域的半离散动力平衡方程为：\n    $$\n    \\mathbf{M}\\,\\ddot{\\mathbf{u}}(t) + \\mathbf{C}\\,\\dot{\\mathbf{u}}(t) + \\mathbf{K}\\,\\mathbf{u}(t) = \\mathbf{0}\n    $$\n-   $\\mathbf{M}$ 是对称正定质量矩阵。\n-   $\\mathbf{K}$ 是对称正定刚度矩阵。\n-   $\\mathbf{C}$ 是阻尼矩阵。\n-   $\\mathbf{u}(t)$ 是节点位移向量。\n-   阻尼为比例（瑞利）类型：\n    $$\n    \\mathbf{C} = \\alpha\\,\\mathbf{M} + \\beta\\,\\mathbf{K}\n    $$\n-   瑞利阻尼系数满足 $\\alpha > 0$ 和 $\\beta > 0$。\n-   无阻尼广义特征值问题为：\n    $$\n    \\mathbf{K}\\,\\boldsymbol{\\phi}_n = \\omega_n^{2}\\,\\mathbf{M}\\,\\boldsymbol{\\phi}_n\n    $$\n-   $\\boldsymbol{\\phi}_n$ 是第 $n$ 阶振型（特征向量）。\n-   $\\omega_n$ 是第 $n$ 阶无阻尼自振圆频率（与特征值相关）。\n\n### 步骤2：使用提取的已知条件进行验证\n-   **科学性**：该问题基于结构动力学的基本原理以及应用于岩土力学的有限元方法。动力平衡、瑞利阻尼和振型分析的方程都是标准且成熟的。\n-   **适定性**：该问题表述清晰。它提供了进行所要求推导所需的所有方程和定义。所求量存在唯一的解析解。\n-   **客观性**：语言精确、数学化，不含任何主观或非科学内容。\n\n问题陈述满足所有有效性准则。它科学合理、适定且客观，没有明显缺陷。因此，该问题被判定为**有效**。\n\n### 解答推导\n\n解答从半离散的运动方程开始：\n$$\n\\mathbf{M}\\,\\ddot{\\mathbf{u}}(t) + \\mathbf{C}\\,\\dot{\\mathbf{u}}(t) + \\mathbf{K}\\,\\mathbf{u}(t) = \\mathbf{0}\n$$\n振型分析的核心是使用振型作为基，将耦合的微分方程组转换为一组解耦的标量方程。位移向量 $\\mathbf{u}(t)$ 表示为振型 $\\boldsymbol{\\phi}_j$ 的线性组合，由随时间变化的振型坐标 $q_j(t)$ 加权：\n$$\n\\mathbf{u}(t) = \\sum_{j=1}^{N} \\boldsymbol{\\phi}_j \\, q_j(t)\n$$\n其中 $N$ 是自由度数。将此振型展开式代入运动方程，得到：\n$$\n\\mathbf{M} \\sum_{j=1}^{N} \\boldsymbol{\\phi}_j \\, \\ddot{q}_j(t) + \\mathbf{C} \\sum_{j=1}^{N} \\boldsymbol{\\phi}_j \\, \\dot{q}_j(t) + \\mathbf{K} \\sum_{j=1}^{N} \\boldsymbol{\\phi}_j \\, q_j(t) = \\mathbf{0}\n$$\n根据矩阵乘法的线性性质，我们可以写出：\n$$\n\\sum_{j=1}^{N} \\left( \\mathbf{M} \\boldsymbol{\\phi}_j \\, \\ddot{q}_j(t) + \\mathbf{C} \\boldsymbol{\\phi}_j \\, \\dot{q}_j(t) + \\mathbf{K} \\boldsymbol{\\phi}_j \\, q_j(t) \\right) = \\mathbf{0}\n$$\n为分离出任意振型 $n$ 的方程，我们用第 $n$ 阶振型的转置 $\\boldsymbol{\\phi}_n^T$ 左乘整个方程：\n$$\n\\sum_{j=1}^{N} \\left( \\boldsymbol{\\phi}_n^T \\mathbf{M} \\boldsymbol{\\phi}_j \\, \\ddot{q}_j(t) + \\boldsymbol{\\phi}_n^T \\mathbf{C} \\boldsymbol{\\phi}_j \\, \\dot{q}_j(t) + \\boldsymbol{\\phi}_n^T \\mathbf{K} \\boldsymbol{\\phi}_j \\, q_j(t) \\right) = \\mathbf{0}\n$$\n无阻尼系统的振型 $\\boldsymbol{\\phi}_n$ 相对于质量矩阵 $\\mathbf{M}$ 和刚度矩阵 $\\mathbf{K}$ 具有基本的正交性。这些性质由以下公式给出：\n$$\n\\boldsymbol{\\phi}_n^T \\mathbf{M} \\boldsymbol{\\phi}_j = M_n \\delta_{nj}\n$$\n$$\n\\boldsymbol{\\phi}_n^T \\mathbf{K} \\boldsymbol{\\phi}_j = K_n \\delta_{nj}\n$$\n其中 $\\delta_{nj}$ 是克罗内克符号，$M_n = \\boldsymbol{\\phi}_n^T \\mathbf{M} \\boldsymbol{\\phi}_n$ 是第 $n$ 阶振型的振型质量，$K_n = \\boldsymbol{\\phi}_n^T \\mathbf{K} \\boldsymbol{\\phi}_n$ 是第 $n$ 阶振型的振型刚度。由于克罗内克符号的存在，求和中除了 $j=n$ 的项之外，所有其他项均为零。因此，方程组解耦，对于振型 $n$，我们有：\n$$\nM_n \\ddot{q}_n(t) + \\left( \\boldsymbol{\\phi}_n^T \\mathbf{C} \\boldsymbol{\\phi}_n \\right) \\dot{q}_n(t) + K_n q_n(t) = 0\n$$\n项 $C_n = \\boldsymbol{\\phi}_n^T \\mathbf{C} \\boldsymbol{\\phi}_n$ 代表振型阻尼。现在，我们代入给定的瑞利阻尼表达式 $\\mathbf{C} = \\alpha \\mathbf{M} + \\beta \\mathbf{K}$：\n$$\nC_n = \\boldsymbol{\\phi}_n^T (\\alpha \\mathbf{M} + \\beta \\mathbf{K}) \\boldsymbol{\\phi}_n = \\alpha (\\boldsymbol{\\phi}_n^T \\mathbf{M} \\boldsymbol{\\phi}_n) + \\beta (\\boldsymbol{\\phi}_n^T \\mathbf{K} \\boldsymbol{\\phi}_n) = \\alpha M_n + \\beta K_n\n$$\n将这个 $C_n$ 的表达式代回振型方程中：\n$$\nM_n \\ddot{q}_n(t) + (\\alpha M_n + \\beta K_n) \\dot{q}_n(t) + K_n q_n(t) = 0\n$$\n为将此方程归一化为标准形式，我们两边同除以振型质量 $M_n$（由于 $\\mathbf{M}$ 是正定的且 $\\boldsymbol{\\phi}_n$ 是非零向量，所以 $M_n$ 非零）：\n$$\n\\ddot{q}_n(t) + \\left(\\alpha + \\beta \\frac{K_n}{M_n}\\right) \\dot{q}_n(t) + \\frac{K_n}{M_n} q_n(t) = 0\n$$\n从广义特征值问题 $\\mathbf{K}\\boldsymbol{\\phi}_n = \\omega_n^2 \\mathbf{M}\\boldsymbol{\\phi}_n$ 出发，我们用 $\\boldsymbol{\\phi}_n^T$ 左乘，得到 $\\boldsymbol{\\phi}_n^T \\mathbf{K}\\boldsymbol{\\phi}_n = \\omega_n^2 \\boldsymbol{\\phi}_n^T \\mathbf{M}\\boldsymbol{\\phi}_n$，即 $K_n = \\omega_n^2 M_n$。这给出了关键关系：\n$$\n\\frac{K_n}{M_n} = \\omega_n^2\n$$\n将此关系代入归一化的振型方程，我们得到振型 $n$ 的最终标量振型方程：\n$$\n\\ddot{q}_n(t) + (\\alpha + \\beta \\omega_n^2) \\dot{q}_n(t) + \\omega_n^2 q_n(t) = 0\n$$\n此方程是有阻尼谐振子的标准形式：\n$$\n\\ddot{x}(t) + 2\\zeta_n \\omega_n \\dot{x}(t) + \\omega_n^2 x(t) = 0\n$$\n通过比较 $\\dot{q}_n(t)$ 项的系数，我们可以确定 $2\\zeta_n\\omega_n$：\n$$\n2\\zeta_n \\omega_n = \\alpha + \\beta \\omega_n^2\n$$\n解出第 $n$ 阶振型的阻尼比 $\\zeta_n$：\n$$\n\\zeta_n = \\frac{\\alpha + \\beta \\omega_n^2}{2\\omega_n} = \\frac{\\alpha}{2\\omega_n} + \\frac{\\beta \\omega_n}{2}\n$$\n有阻尼自振圆频率 $\\omega_{d,n}$ 通过欠阻尼振子（$\\zeta_n  1$）的著名公式与无阻尼自振频率 $\\omega_n$ 和阻尼比 $\\zeta_n$ 相关联：\n$$\n\\omega_{d,n} = \\omega_n \\sqrt{1 - \\zeta_n^2}\n$$\n题目要求此表达式用 $\\alpha$、$\\beta$ 和 $\\omega_n$ 表示。我们代入推导出的 $\\zeta_n$ 的表达式：\n$$\n\\omega_{d,n} = \\omega_n \\sqrt{1 - \\left( \\frac{\\alpha + \\beta \\omega_n^2}{2\\omega_n} \\right)^2}\n$$\n这些就是振型阻尼比和有阻尼自振圆频率的最终表达式。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} \\dfrac{\\alpha}{2\\omega_n} + \\dfrac{\\beta \\omega_n}{2}  \\omega_n \\sqrt{1 - \\left( \\dfrac{\\alpha + \\beta \\omega_n^2}{2\\omega_n} \\right)^2} \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "直接时间积分法是求解动力学方程的通用数值方法，而Newmark-beta方法是其中最具代表性的算法之一。本练习要求你从基本运动学假设出发，推导并实现Newmark积分方案，以求解带阻尼系统的动力响应。通过亲手编写代码，你将掌握将连续时间微分方程转化为离散代数方程组求解的核心技术，并直观地观察不同阻尼模型对系统行为的影响。",
            "id": "3519826",
            "problem": "一个具有多自由度 (DOF) 的岩土力学系统的线性半离散动态平衡由牛顿第二定律支配，即净力等于质量乘以加速度。用矩阵-向量形式，该平衡可以写作 $ \\boldsymbol{M}\\ddot{\\boldsymbol{u}} + \\boldsymbol{C}\\dot{\\boldsymbol{u}} + \\boldsymbol{K}\\boldsymbol{u} = \\boldsymbol{f}(t) $，其中 $ \\boldsymbol{M} $ 是相容质量矩阵（单位 $ \\mathrm{kg} $），$ \\boldsymbol{C} $ 是阻尼矩阵（单位 $ \\mathrm{N\\cdot s/m} $），$ \\boldsymbol{K} $ 是刚度矩阵（单位 $ \\mathrm{N/m} $），$ \\boldsymbol{u} $ 是位移向量（单位 $ \\mathrm{m} $），$ \\dot{\\boldsymbol{u}} $ 是速度向量（单位 $ \\mathrm{m/s} $），$ \\ddot{\\boldsymbol{u}} $ 是加速度向量（单位 $ \\mathrm{m/s^2} $），$ \\boldsymbol{f}(t) $ 是外力向量（单位 $ \\mathrm{N} $）。在计算岩土力学中，通常使用 Newmark 族时间积分方案来随时间推进求解，同时不牺牲线性系统的数值稳定性。您必须从第一性原理出发，推导如何为未知量 $ \\boldsymbol{u}_{n+1} $、$ \\dot{\\boldsymbol{u}}_{n+1} $ 和 $ \\ddot{\\boldsymbol{u}}_{n+1} $ 构建一个从时间 $ t_n $ 到 $ t_{n+1} = t_n + \\Delta t $ 的单步更新。推导过程仅需基于基本的运动学和动力学：应用于半离散系统的牛顿第二定律以及速度和加速度作为时间导数的定义。使用通用的 Newmark 参数 $ \\gamma $ 和 $ \\beta $ 以及恒定的时间步长 $ \\Delta t $，推导求解 $ \\boldsymbol{u}_{n+1} $ 所需的离散线性系统，确定其有效刚度矩阵 $ \\boldsymbol{K}_{\\mathrm{eff}} $，并推导在 $ t_{n+1} $ 时刻强制实现动态平衡的相应有效载荷向量 $ \\boldsymbol{r}_{\\mathrm{eff}} $。完成此推导后，实施所得算法以对系统进行数值积分，在每个时间步计算 $ \\boldsymbol{K}_{\\mathrm{eff}} $ 和 $ \\boldsymbol{r}_{\\mathrm{eff}} $，并推进求解。\n\n您的程序必须使用以下测试套件。对于所有正弦载荷，角度必须以弧度为单位。位移大小以米报告。\n\n测试套件：\n$1.$ 单自由度 (SDOF)，无阻尼，恒定载荷：\n- $ \\boldsymbol{M} = [\\,1.0\\,]\\,\\mathrm{kg} $\n- $ \\boldsymbol{K} = [\\,400.0\\,]\\,\\mathrm{N/m} $\n- $ \\boldsymbol{C} = [\\,0.0\\,]\\,\\mathrm{N\\cdot s/m} $\n- $ \\boldsymbol{f}(t) = [\\,100.0\\,]\\,\\mathrm{N} $ 对于所有 $ t $\n- $ \\boldsymbol{u}_0 = [\\,0.0\\,]\\,\\mathrm{m} $，$ \\dot{\\boldsymbol{u}}_0 = [\\,0.0\\,]\\,\\mathrm{m/s} $\n- $ \\Delta t = 0.001\\,\\mathrm{s} $，$ T = 0.5\\,\\mathrm{s} $，$ \\gamma = 0.5 $，$ \\beta = 0.25 $\n\n$2.$ 单自由度 (SDOF)，具有指定阻尼比的粘性阻尼，阶跃载荷：\n- $ \\boldsymbol{M} = [\\,1.5\\,]\\,\\mathrm{kg} $\n- $ \\boldsymbol{K} = [\\,600.0\\,]\\,\\mathrm{N/m} $\n- 阻尼比 $ \\zeta = 0.05 $ 和粘性阻尼 $ \\boldsymbol{C} = [\\,2\\,\\zeta\\,\\sqrt{\\boldsymbol{K}\\boldsymbol{M}}\\,] = [\\,2 \\times 0.05 \\times \\sqrt{600.0 \\times 1.5}\\,]\\,\\mathrm{N\\cdot s/m} $\n- $ \\boldsymbol{f}(t) = [\\,150.0\\,]\\,\\mathrm{N} $ 对于所有 $ t $\n- $ \\boldsymbol{u}_0 = [\\,0.0\\,]\\,\\mathrm{m} $，$ \\dot{\\boldsymbol{u}}_0 = [\\,0.0\\,]\\,\\mathrm{m/s} $\n- $ \\Delta t = 0.001\\,\\mathrm{s} $，$ T = 0.8\\,\\mathrm{s} $，$ \\gamma = 0.5 $，$ \\beta = 0.25 $\n\n$3.$ 双自由度 (two-DOF)，Rayleigh 阻尼，在第一个自由度上施加谐波载荷：\n- $ \\boldsymbol{M} = \\mathrm{diag}([\\,2.0,\\,1.0\\,])\\,\\mathrm{kg} $\n- $ \\boldsymbol{K} = \\begin{bmatrix} 600.0  -200.0 \\\\ -200.0  400.0 \\end{bmatrix}\\,\\mathrm{N/m} $\n- Rayleigh 阻尼 $ \\boldsymbol{C} = \\alpha \\boldsymbol{M} + \\beta_r \\boldsymbol{K} $，其中 $ \\alpha = 0.1\\,\\mathrm{s^{-1}} $，$ \\beta_r = 0.0005\\,\\mathrm{s} $\n- $ \\boldsymbol{f}(t) = [\\,50.0 \\sin(15.0\\, t),\\, 0.0\\,]\\,\\mathrm{N} $，对于 $ 0 \\le t \\le T $\n- $ \\boldsymbol{u}_0 = [\\,0.0,\\,0.0\\,]\\,\\mathrm{m} $，$ \\dot{\\boldsymbol{u}}_0 = [\\,0.0,\\,0.0\\,]\\,\\mathrm{m/s} $\n- $ \\Delta t = 0.001\\,\\mathrm{s} $，$ T = 2.0\\,\\mathrm{s} $，$ \\gamma = 0.5 $，$ \\beta = 0.25 $\n\n$4.$ 单自由度 (SDOF)，具有非零初始速度的临界阻尼自由振动：\n- $ \\boldsymbol{M} = [\\,1.0\\,]\\,\\mathrm{kg} $\n- $ \\boldsymbol{K} = [\\,100.0\\,]\\,\\mathrm{N/m} $\n- 临界粘性阻尼 $ \\boldsymbol{C} = [\\,2 \\sqrt{100.0 \\times 1.0}\\,] = [\\,20.0\\,]\\,\\mathrm{N\\cdot s/m} $\n- $ \\boldsymbol{f}(t) = [\\,0.0\\,]\\,\\mathrm{N} $ 对于所有 $ t $\n- $ \\boldsymbol{u}_0 = [\\,0.0\\,]\\,\\mathrm{m} $，$ \\dot{\\boldsymbol{u}}_0 = [\\,1.0\\,]\\,\\mathrm{m/s} $\n- $ \\Delta t = 0.001\\,\\mathrm{s} $，$ T = 1.0\\,\\mathrm{s} $，$ \\gamma = 0.5 $，$ \\beta = 0.25 $\n\n计算任务：\n$1.$ 从速度和加速度的定义以及牛顿第二定律出发，推导 Newmark 更新关系式，并展示如何将其代入 $ t_{n+1} $ 时刻的动态平衡方程，从而得到一个关于 $ \\boldsymbol{u}_{n+1} $ 的代数系统，该系统具有有效刚度 $ \\boldsymbol{K}_{\\mathrm{eff}} $ 和有效载荷 $ \\boldsymbol{r}_{\\mathrm{eff}} $。请用 $ \\boldsymbol{M} $、$ \\boldsymbol{C} $、$ \\boldsymbol{K} $、$ \\Delta t $、$ \\gamma $、$ \\beta $ 和 $ t_n $ 时刻的已知状态明确表示 $ \\boldsymbol{K}_{\\mathrm{eff}} $ 和 $ \\boldsymbol{r}_{\\mathrm{eff}} $。\n$2.$ 实施所得的单步算法，为每个测试用例从 $ t = 0 $ 积分到 $ t = T $。在每个步骤中，构建 $ \\boldsymbol{K}_{\\mathrm{eff}} $ 和 $ \\boldsymbol{r}_{\\mathrm{eff}} $，求解 $ \\boldsymbol{u}_{n+1} $，然后恢复 $ \\ddot{\\boldsymbol{u}}_{n+1} $ 和 $ \\dot{\\boldsymbol{u}}_{n+1} $。\n$3.$ 对于每个测试用例，输出最终位移向量的欧几里得范数 $ \\lVert \\boldsymbol{u}(T) \\rVert_2 $（单位为米），并四舍五入到六位小数。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，例如 $ [\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4] $，其中每个条目是一个浮点数，代表 $ \\lVert \\boldsymbol{u}(T) \\rVert_2 $（单位为 $ \\mathrm{m} $），并四舍五入到六位小数。",
            "solution": "该问题是有效的。它在科学上基于经典力学和数值分析的原理，特别是关于结构的动态分析。该问题是适定的，为 Newmark 时间积分方案提供了所有必需的矩阵、初始条件和参数。语言是客观的，要求可以形式化为一个计算算法。\n\n推导和实现过程如下。\n\n### 第 1 部分：Newmark 积分方案的推导\n\n控制半离散线性系统动态平衡的基本方程是牛顿第二定律，以矩阵形式表示为：\n$$ \\boldsymbol{M}\\ddot{\\boldsymbol{u}}(t) + \\boldsymbol{C}\\dot{\\boldsymbol{u}}(t) + \\boldsymbol{K}\\boldsymbol{u}(t) = \\boldsymbol{f}(t) $$\n其中 $\\boldsymbol{M}$、$\\boldsymbol{C}$ 和 $\\boldsymbol{K}$ 分别是质量、阻尼和刚度矩阵。向量 $\\boldsymbol{u}$、$\\dot{\\boldsymbol{u}}$ 和 $\\ddot{\\boldsymbol{u}}$ 分别代表位移、速度和加速度，$\\boldsymbol{f}(t)$ 是外力向量。\n\nNewmark 族方法提供了一种基于系统在时间 $t_n$ 的状态来近似其在时间 $t_{n+1} = t_n + \\Delta t$ 状态的方法。该方法的核心在于两个运动学假设，这两个假设关联了在一个时间步长 $\\Delta t$ 内的位移、速度和加速度：\n$$ \\dot{\\boldsymbol{u}}_{n+1} = \\dot{\\boldsymbol{u}}_n + (1 - \\gamma) \\Delta t \\ddot{\\boldsymbol{u}}_n + \\gamma \\Delta t \\ddot{\\boldsymbol{u}}_{n+1} \\quad (1) $$\n$$ \\boldsymbol{u}_{n+1} = \\boldsymbol{u}_n + \\Delta t \\dot{\\boldsymbol{u}}_n + \\frac{(\\Delta t)^2}{2} \\left[ (1 - 2\\beta) \\ddot{\\boldsymbol{u}}_n + 2\\beta \\ddot{\\boldsymbol{u}}_{n+1} \\right] \\quad (2) $$\n这里，$\\gamma$ 和 $\\beta$ 是控制该方法精度和稳定性的 Newmark 积分参数。时间 $t_n$ 的状态变量 $(\\boldsymbol{u}_n, \\dot{\\boldsymbol{u}}_n, \\ddot{\\boldsymbol{u}}_n)$ 是已知的。目标是求解时间 $t_{n+1}$ 的状态变量 $(\\boldsymbol{u}_{n+1}, \\dot{\\boldsymbol{u}}_{n+1}, \\ddot{\\boldsymbol{u}}_{n+1})$。\n\n在隐式格式中，主要未知量是下一个时间步的位移 $\\boldsymbol{u}_{n+1}$。为了求解它，我们必须用 $\\boldsymbol{u}_{n+1}$ 和第 $n$ 步的已知量来表示 $\\dot{\\boldsymbol{u}}_{n+1}$ 和 $\\ddot{\\boldsymbol{u}}_{n+1}$。\n\n首先，我们重新排列方程 $(2)$ 以求解时间 $t_{n+1}$ 的加速度 $\\ddot{\\boldsymbol{u}}_{n+1}$：\n$$ 2\\beta \\frac{(\\Delta t)^2}{2} \\ddot{\\boldsymbol{u}}_{n+1} = \\boldsymbol{u}_{n+1} - \\boldsymbol{u}_n - \\Delta t \\dot{\\boldsymbol{u}}_n - (1 - 2\\beta) \\frac{(\\Delta t)^2}{2} \\ddot{\\boldsymbol{u}}_n $$\n$$ \\beta (\\Delta t)^2 \\ddot{\\boldsymbol{u}}_{n+1} = \\boldsymbol{u}_{n+1} - \\boldsymbol{u}_n - \\Delta t \\dot{\\boldsymbol{u}}_n - (\\frac{1}{2} - \\beta)(\\Delta t)^2 \\ddot{\\boldsymbol{u}}_n $$\n分离出 $\\ddot{\\boldsymbol{u}}_{n+1}$ 可得：\n$$ \\ddot{\\boldsymbol{u}}_{n+1} = \\frac{1}{\\beta (\\Delta t)^2} (\\boldsymbol{u}_{n+1} - \\boldsymbol{u}_n) - \\frac{1}{\\beta \\Delta t} \\dot{\\boldsymbol{u}}_n - \\left(\\frac{1}{2\\beta} - 1\\right) \\ddot{\\boldsymbol{u}}_n \\quad (3) $$\n\n接下来，将这个 $\\ddot{\\boldsymbol{u}}_{n+1}$ 的表达式代入方程 $(1)$，以 $\\boldsymbol{u}_{n+1}$ 表示 $\\dot{\\boldsymbol{u}}_{n+1}$：\n$$ \\dot{\\boldsymbol{u}}_{n+1} = \\dot{\\boldsymbol{u}}_n + (1 - \\gamma) \\Delta t \\ddot{\\boldsymbol{u}}_n + \\gamma \\Delta t \\left[ \\frac{1}{\\beta (\\Delta t)^2} (\\boldsymbol{u}_{n+1} - \\boldsymbol{u}_n) - \\frac{1}{\\beta \\Delta t} \\dot{\\boldsymbol{u}}_n - \\left(\\frac{1}{2\\beta} - 1\\right) \\ddot{\\boldsymbol{u}}_n \\right] $$\n$$ \\dot{\\boldsymbol{u}}_{n+1} = \\frac{\\gamma}{\\beta \\Delta t} (\\boldsymbol{u}_{n+1} - \\boldsymbol{u}_n) + \\left(1 - \\frac{\\gamma}{\\beta}\\right) \\dot{\\boldsymbol{u}}_n + \\Delta t \\left(1 - \\gamma - \\gamma\\left(\\frac{1}{2\\beta} - 1\\right)\\right) \\ddot{\\boldsymbol{u}}_n $$\n简化含 $\\ddot{\\boldsymbol{u}}_n$ 的项：\n$$ \\Delta t \\left(1 - \\gamma - \\frac{\\gamma}{2\\beta} + \\gamma \\right) \\ddot{\\boldsymbol{u}}_n = \\Delta t \\left(1 - \\frac{\\gamma}{2\\beta}\\right) \\ddot{\\boldsymbol{u}}_n $$\n这种形式更简单且足够。现在，我们在时间 $t_{n+1}$ 强制执行动态平衡：\n$$ \\boldsymbol{M}\\ddot{\\boldsymbol{u}}_{n+1} + \\boldsymbol{C}\\dot{\\boldsymbol{u}}_{n+1} + \\boldsymbol{K}\\boldsymbol{u}_{n+1} = \\boldsymbol{f}_{n+1} $$\n将方程 $(3)$ 和 $(4)$ 代入平衡方程。为了简化符号，我们定义以下仅依赖于 $\\Delta t$、$\\gamma$ 和 $\\beta$ 的常数：\n$ a_0 = \\frac{1}{\\beta (\\Delta t)^2} $\n$ a_1 = \\frac{\\gamma}{\\beta \\Delta t} $\n$ a_2 = \\frac{1}{\\beta \\Delta t} $\n$ a_3 = \\frac{1}{2\\beta} - 1 $\n\n方程 $(3)$ 变为：$\\ddot{\\boldsymbol{u}}_{n+1} = a_0(\\boldsymbol{u}_{n+1} - \\boldsymbol{u}_n) - a_2 \\dot{\\boldsymbol{u}}_n - a_3 \\ddot{\\boldsymbol{u}}_n$。\n将此代入方程 $(4)$ 求 $\\dot{\\boldsymbol{u}}_{n+1}$：\n$\\dot{\\boldsymbol{u}}_{n+1} = \\dot{\\boldsymbol{u}}_n + \\Delta t(1-\\gamma)\\ddot{\\boldsymbol{u}}_n + \\gamma \\Delta t \\ddot{\\boldsymbol{u}}_{n+1} = a_1(\\boldsymbol{u}_{n+1} - \\boldsymbol{u}_n) - (\\frac{\\gamma}{\\beta}-1)\\dot{\\boldsymbol{u}}_n - \\frac{\\Delta t}{2}(\\frac{\\gamma}{\\beta}-2)\\ddot{\\boldsymbol{u}}_n$。\n一个更直接的路径是将 $\\ddot{\\boldsymbol{u}}_{n+1}$ 和 $\\dot{\\boldsymbol{u}}_{n+1}$ 的表达式以 $\\boldsymbol{u}_{n+1}$ 和已知预测量的形式代入平衡方程。\n让我们将 $(3)$ 中的 $\\ddot{\\boldsymbol{u}}_{n+1}$ 和 $(4)$ 中的 $\\dot{\\boldsymbol{u}}_{n+1}$ 代入平衡方程：\n$$ \\boldsymbol{M}\\ddot{\\boldsymbol{u}}_{n+1} + \\boldsymbol{C}(\\dot{\\boldsymbol{u}}_n + \\Delta t (1 - \\gamma) \\ddot{\\boldsymbol{u}}_n + \\gamma \\Delta t \\ddot{\\boldsymbol{u}}_{n+1}) + \\boldsymbol{K}\\boldsymbol{u}_{n+1} = \\boldsymbol{f}_{n+1} $$\n将含有未知数 $\\ddot{\\boldsymbol{u}}_{n+1}$ 的项组合在一起：\n$$ (\\boldsymbol{M} + \\gamma \\Delta t \\boldsymbol{C}) \\ddot{\\boldsymbol{u}}_{n+1} + \\boldsymbol{K}\\boldsymbol{u}_{n+1} = \\boldsymbol{f}_{n+1} - \\boldsymbol{C}(\\dot{\\boldsymbol{u}}_n + \\Delta t (1 - \\gamma) \\ddot{\\boldsymbol{u}}_n) $$\n现在，代入方程 $(3)$ 中 $\\ddot{\\boldsymbol{u}}_{n+1}$ 的表达式：\n$$ (\\boldsymbol{M} + \\gamma \\Delta t \\boldsymbol{C}) \\left[ \\frac{1}{\\beta (\\Delta t)^2}(\\boldsymbol{u}_{n+1} - \\boldsymbol{u}_n - \\Delta t \\dot{\\boldsymbol{u}}_n) - (\\frac{1}{2\\beta} - 1) \\ddot{\\boldsymbol{u}}_n \\right] + \\boldsymbol{K}\\boldsymbol{u}_{n+1} = \\boldsymbol{f}_{n+1} - \\boldsymbol{C}(\\dot{\\boldsymbol{u}}_n + \\Delta t(1-\\gamma)\\ddot{\\boldsymbol{u}}_n) $$\n目标是分离出 $\\boldsymbol{u}_{n+1}$。让我们将所有乘以 $\\boldsymbol{u}_{n+1}$ 的项收集到左侧 (LHS)，并将所有其他项移到右侧 (RHS)。\n\n从左侧：\n$$ \\left[ \\frac{1}{\\beta (\\Delta t)^2} (\\boldsymbol{M} + \\gamma \\Delta t \\boldsymbol{C}) + \\boldsymbol{K} \\right] \\boldsymbol{u}_{n+1} = \\dots $$\n展开乘以 $\\boldsymbol{M} + \\gamma \\Delta t \\boldsymbol{C}$ 的项：\n$$ \\left[ (\\frac{1}{\\beta (\\Delta t)^2} \\boldsymbol{M} + \\frac{\\gamma}{\\beta \\Delta t} \\boldsymbol{C}) + \\boldsymbol{K} \\right] \\boldsymbol{u}_{n+1} = \\dots $$\n这就确定了有效刚度矩阵 $\\boldsymbol{K}_{\\mathrm{eff}}$：\n$$ \\boldsymbol{K}_{\\mathrm{eff}} = \\boldsymbol{K} + \\frac{\\gamma}{\\beta \\Delta t} \\boldsymbol{C} + \\frac{1}{\\beta (\\Delta t)^2} \\boldsymbol{M} $$\n\n现在，我们将所有其他项收集到右侧，以构成有效载荷向量 $\\boldsymbol{r}_{\\mathrm{eff}}$：\n$$ \\boldsymbol{r}_{\\mathrm{eff}} = \\boldsymbol{f}_{n+1} + (\\boldsymbol{M} + \\gamma \\Delta t \\boldsymbol{C}) \\left[ \\frac{1}{\\beta (\\Delta t)^2}(\\boldsymbol{u}_n + \\Delta t \\dot{\\boldsymbol{u}}_n) + (\\frac{1}{2\\beta} - 1) \\ddot{\\boldsymbol{u}}_n \\right] - \\boldsymbol{C}(\\dot{\\boldsymbol{u}}_n + \\Delta t(1-\\gamma)\\ddot{\\boldsymbol{u}}_n) $$\n让我们按 $\\boldsymbol{u}_n$、$\\dot{\\boldsymbol{u}}_n$ 和 $\\ddot{\\boldsymbol{u}}_n$ 展开并分组各项：\n$ \\boldsymbol{r}_{\\mathrm{eff}} = \\boldsymbol{f}_{n+1} + \\boldsymbol{M}\\left[ \\frac{1}{\\beta (\\Delta t)^2} \\boldsymbol{u}_n + \\frac{1}{\\beta \\Delta t} \\dot{\\boldsymbol{u}}_n + (\\frac{1}{2\\beta}-1)\\ddot{\\boldsymbol{u}}_n \\right] + \\boldsymbol{C}\\left[ \\frac{\\gamma}{\\beta \\Delta t}\\boldsymbol{u}_n + (\\frac{\\gamma}{\\beta}-1)\\dot{\\boldsymbol{u}}_n + \\Delta t (\\frac{\\gamma}{2\\beta}-1)\\ddot{\\boldsymbol{u}}_n \\right] $\n每个时间步需要求解的最终代数系统是：\n$$ \\boldsymbol{K}_{\\mathrm{eff}} \\boldsymbol{u}_{n+1} = \\boldsymbol{r}_{\\mathrm{eff}} $$\n\n### 第 2 部分：算法流程\n\n数值积分过程如下：\n1.  **初始化 ($n=0$)**：\n    a. 给定初始条件 $\\boldsymbol{u}_0$ 和 $\\dot{\\boldsymbol{u}}_0$。\n    b. 从 $t=0$ 时的运动方程求解初始加速度 $\\ddot{\\boldsymbol{u}}_0$：\n       $$ \\boldsymbol{M}\\ddot{\\boldsymbol{u}}_0 = \\boldsymbol{f}(0) - \\boldsymbol{C}\\dot{\\boldsymbol{u}}_0 - \\boldsymbol{K}\\boldsymbol{u}_0 $$\n2.  **时间步进循环 (对于 $n = 0, 1, 2, \\dots, N-1$，其中 $N = T/\\Delta t$)**：\n    a. 计算有效刚度矩阵，对于具有恒定 $\\Delta t$ 的线性系统，该矩阵是常数：\n       $$ \\boldsymbol{K}_{\\mathrm{eff}} = \\boldsymbol{K} + \\frac{\\gamma}{\\beta \\Delta t} \\boldsymbol{C} + \\frac{1}{\\beta (\\Delta t)^2} \\boldsymbol{M} $$\n    b. 计算时间 $t_{n+1}$ 的有效载荷向量：\n       $$ \\boldsymbol{r}_{\\mathrm{eff}} = \\boldsymbol{f}_{n+1} + \\boldsymbol{M}\\left(a_0 \\boldsymbol{u}_n + a_2 \\dot{\\boldsymbol{u}}_n + a_3 \\ddot{\\boldsymbol{u}}_n\\right) + \\boldsymbol{C}\\left(a_1 \\boldsymbol{u}_n + a_4 \\dot{\\boldsymbol{u}}_n + a_5 \\ddot{\\boldsymbol{u}}_n\\right) $$\n       使用以下常数：$a_0 = \\frac{1}{\\beta (\\Delta t)^2}$，$a_1 = \\frac{\\gamma}{\\beta \\Delta t}$，$a_2 = \\frac{1}{\\beta \\Delta t}$，$a_3=\\frac{1}{2\\beta}-1$，$a_4=\\frac{\\gamma}{\\beta}-1$，$a_5=\\frac{\\Delta t}{2}(\\frac{\\gamma}{\\beta}-2)$。\n    c. 求解线性系统以获得下一个时间步的位移：\n       $$ \\boldsymbol{u}_{n+1} = \\boldsymbol{K}_{\\mathrm{eff}}^{-1} \\boldsymbol{r}_{\\mathrm{eff}} $$\n    d. 更新时间 $t_{n+1}$ 的加速度和速度：\n       $$ \\ddot{\\boldsymbol{u}}_{n+1} = a_0 (\\boldsymbol{u}_{n+1} - \\boldsymbol{u}_n) - a_2 \\dot{\\boldsymbol{u}}_n - a_3 \\ddot{\\boldsymbol{u}}_n $$\n       $$ \\dot{\\boldsymbol{u}}_{n+1} = \\dot{\\boldsymbol{u}}_n + (1 - \\gamma)\\Delta t \\ddot{\\boldsymbol{u}}_n + \\gamma \\Delta t \\ddot{\\boldsymbol{u}}_{n+1} $$\n3.  **最终结果**：循环完成后，最终位移向量为 $\\boldsymbol{u}_{N}$。要求的输出是其欧几里得范数 $\\lVert \\boldsymbol{u}_N \\rVert_2$。所提供的测试用例使用 $\\gamma=0.5$ 和 $\\beta=0.25$，这对应于常数平均加速度法，是一种对线性系统无条件稳定的方案。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef integrate_newmark(M, C, K, f_func, u0, u_dot0, dt, T, gamma, beta):\n    \"\"\"\n    Integrates a linear dynamic system using the Newmark-beta method.\n\n    Args:\n        M (np.ndarray): Mass matrix.\n        C (np.ndarray): Damping matrix.\n        K (np.ndarray): Stiffness matrix.\n        f_func (callable): Function of time t that returns the force vector f(t).\n        u0 (np.ndarray): Initial displacement vector.\n        u_dot0 (np.ndarray): Initial velocity vector.\n        dt (float): Time step.\n        T (float): Total integration time.\n        gamma (float): Newmark parameter.\n        beta (float): Newmark parameter.\n\n    Returns:\n        np.ndarray: The final displacement vector u(T).\n    \"\"\"\n    num_steps = int(round(T / dt))\n    \n    # Initialize state vectors\n    u = u0.copy()\n    u_dot = u_dot0.copy()\n    \n    # Calculate initial acceleration: M*u_ddot_0 = f(0) - C*u_dot_0 - K*u_0\n    f0 = f_func(0.0)\n    try:\n        u_ddot = np.linalg.solve(M, f0 - C @ u_dot - K @ u)\n    except np.linalg.LinAlgError:\n        # Handle singular mass matrix (though not in test cases)\n        # Or if M is scalar for SDOF\n        if M.shape == (1, 1):\n             u_ddot = (f0 - C @ u_dot - K @ u) / M[0, 0]\n        else:\n            raise\n\n    # Newmark constants based on the derived effective system\n    a0 = 1.0 / (beta * dt**2)\n    a1 = gamma / (beta * dt)\n    a2 = 1.0 / (beta * dt)\n    a3 = 1.0 / (2.0 * beta) - 1.0\n    a4 = gamma / beta - 1.0\n    a5 = dt / 2.0 * (gamma / beta - 2.0)\n    a6 = dt * (1.0 - gamma)\n    a7 = dt * gamma\n    \n    # Form effective stiffness matrix (constant for linear problems)\n    K_eff = K + a1 * C + a0 * M\n    \n    # Time stepping loop\n    for n in range(num_steps):\n        t_next = (n + 1) * dt\n        \n        # Form effective load vector\n        f_next = f_func(t_next)\n        r_eff = f_next + M @ (a0 * u + a2 * u_dot + a3 * u_ddot) + \\\n                      C @ (a1 * u + a4 * u_dot + a5 * u_ddot)\n        \n        # Solve for displacement at t_{n+1}\n        u_next = np.linalg.solve(K_eff, r_eff)\n        \n        # Update acceleration and velocity at t_{n+1}\n        u_ddot_next = a0 * (u_next - u) - a2 * u_dot - a3 * u_ddot\n        u_dot_next = u_dot + a6 * u_ddot + a7 * u_ddot_next\n        \n        # Update state for the next iteration\n        u = u_next\n        u_dot = u_dot_next\n        u_ddot = u_ddot_next\n        \n    return u\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"M\": np.array([[1.0]]),\n            \"K\": np.array([[400.0]]),\n            \"C\": np.array([[0.0]]),\n            \"f_func\": lambda t: np.array([100.0]),\n            \"u0\": np.array([0.0]),\n            \"u_dot0\": np.array([0.0]),\n            \"dt\": 0.001, \"T\": 0.5, \"gamma\": 0.5, \"beta\": 0.25\n        },\n        {\n            \"M\": np.array([[1.5]]),\n            \"K\": np.array([[600.0]]),\n            \"C\": np.array([[2.0 * 0.05 * np.sqrt(600.0 * 1.5)]]),\n            \"f_func\": lambda t: np.array([150.0]),\n            \"u0\": np.array([0.0]),\n            \"u_dot0\": np.array([0.0]),\n            \"dt\": 0.001, \"T\": 0.8, \"gamma\": 0.5, \"beta\": 0.25\n        },\n        {\n            \"M\": np.diag([2.0, 1.0]),\n            \"K\": np.array([[600.0, -200.0], [-200.0, 400.0]]),\n            \"C\": 0.1 * np.diag([2.0, 1.0]) + 0.0005 * np.array([[600.0, -200.0], [-200.0, 400.0]]),\n            \"f_func\": lambda t: np.array([50.0 * np.sin(15.0 * t), 0.0]),\n            \"u0\": np.array([0.0, 0.0]),\n            \"u_dot0\": np.array([0.0, 0.0]),\n            \"dt\": 0.001, \"T\": 2.0, \"gamma\": 0.5, \"beta\": 0.25\n        },\n        {\n            \"M\": np.array([[1.0]]),\n            \"K\": np.array([[100.0]]),\n            \"C\": np.array([[2.0 * np.sqrt(100.0 * 1.0)]]),\n            \"f_func\": lambda t: np.array([0.0]),\n            \"u0\": np.array([0.0]),\n            \"u_dot0\": np.array([1.0]),\n            \"dt\": 0.001, \"T\": 1.0, \"gamma\": 0.5, \"beta\": 0.25\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        u_final = integrate_newmark(\n            M=case[\"M\"],\n            C=case[\"C\"],\n            K=case[\"K\"],\n            f_func=case[\"f_func\"],\n            u0=case[\"u0\"],\n            u_dot0=case[\"u_dot0\"],\n            dt=case[\"dt\"],\n            T=case[\"T\"],\n            gamma=case[\"gamma\"],\n            beta=case[\"beta\"]\n        )\n        \n        norm_u_final = np.linalg.norm(u_final)\n        results.append(f\"{norm_u_final:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在有限元分析中，建模选择（如质量矩阵的构造）会对动力响应预测产生微妙而重要的影响。本高级实践将带你探究集总质量矩阵与一致质量矩阵对高频模态阻尼特性的影响。通过编程计算并比较这两种情况下最高阶模态的频率和瑞利阻尼比，你将深入理解离散化策略如何影响与峰值加速度等关键指标相关的高频响应预测。",
            "id": "3519874",
            "problem": "你需要研究质量矩阵选择对一个理想化的三维盆地中高频模态阻尼的影响，该盆地用于反平面剪切（标量位移）动力学分析。使用线性弹性离散系统的动力平衡方程，该方程由二阶常微分方程$\\,\\mathbf{M}\\,\\ddot{\\mathbf{u}}(t) + \\mathbf{C}\\,\\dot{\\mathbf{u}}(t) + \\mathbf{K}\\,\\mathbf{u}(t) = \\mathbf{0}\\,$给出，其中瑞利阻尼$\\,\\mathbf{C} = \\alpha\\,\\mathbf{M} + \\beta\\,\\mathbf{K}\\,$, $\\,\\mathbf{M}\\,$是质量矩阵, $\\,\\mathbf{K}\\,$是刚度矩阵, $\\,\\alpha\\,$是质量比例阻尼系数, $\\,\\beta\\,$是刚度比例阻尼系数。假设小变形和线性材料响应。\n\n为一个代表具有标量位移$\\,u\\,$（反平面剪切）的三维盆地的规则六面体网格构建$\\,\\mathbf{M}\\,$和$\\,\\mathbf{K}\\,$。将域离散为$\\,n_x \\times n_y \\times n_z\\,$个尺寸均为$\\,h \\times h \\times h\\,$的三线性六面体单元，节点自由度位于网格顶点。除底面外，所有表面均为自由表面；在底面平面$\\,z=0\\,$上施加齐次狄利克雷（Dirichlet）边界条件$\\,u=0\\,$。材料属性是均匀的：恒定的质量密度$\\,\\rho\\,$（单位为$\\mathrm{kg/m^3}$）和恒定的剪切模量$\\,G\\,$（单位为$\\mathrm{Pa}$）。\n\n定义两种可选的质量矩阵：\n- 一致质量矩阵$\\,\\mathbf{M}_{\\mathrm{con}}\\,$是通过组装标量场的三线性六面体单元的单元级$\\,8 \\times 8\\,$一致质量矩阵得到的。对于单个体积为$\\,V = h^3\\,$的单元，其单元质量矩阵为$\\,\\mathbf{M}_e = \\rho \\int_{\\Omega_e} \\mathbf{N}^\\top \\mathbf{N}\\,\\mathrm{d}\\Omega\\,$。在参考立方体$\\,[-1,1]^3\\,$的仿射映射上，这等于$\\,\\mathbf{M}_e = \\rho\\,\\dfrac{V}{8}\\,\\mathbf{E}\\,$，其中$\\,\\mathbf{E}\\,$的第$(i,j)$个条目是$\\,E_{ij} = \\prod_{d \\in \\{x,y,z\\}} I_d(i,j)\\,$，一维积分$\\,I_d(i,j) \\in \\{\\,\\frac{2}{3},\\,\\frac{1}{3}\\,\\}\\,$的值取决于局部节点索引$\\,i\\,$和$\\,j\\,$在坐标$\\,d\\,$上是重合还是不同。等效地，如果$\\,m\\,$是局部索引$\\,i\\,$和$\\,j\\,$匹配的坐标数量，则$\\,E_{ij} = \\left(\\frac{2}{3}\\right)^{m}\\left(\\frac{1}{3}\\right)^{3-m}\\,$。\n- 集中质量矩阵$\\,\\mathbf{M}_{\\mathrm{lmp}}\\,$是对角矩阵，通过将单元质量的八分之一分配给每个节点来组装，即每个单元为其$\\,8\\,$个节点各自贡献一个$\\,\\rho\\,V/8\\,$的对角项。\n\n通过在节点图上组装沿$\\,x\\,$-, $\\,y\\,$和$\\,z\\,$方向连接相邻节点的最近邻轴向弹簧来定义刚度矩阵$\\,\\mathbf{K}\\,$。对于沿方向$\\,d \\in \\{x,y,z\\}\\,$相距为$\\,h\\,$的一对相邻节点，使用线性弹簧刚度$\\,k_d = G\\,A_d/L_d\\,$，其中$\\,A_x = A_y = A_z = h^2\\,$且$\\,L_x = L_y = L_z = h\\,$，因此$\\,k_x = k_y = k_z = G\\,h\\,$。每个弹簧为$\\,\\mathbf{K}\\,$中相应的$\\,2 \\times 2\\,$子矩阵贡献$\\,k\\begin{bmatrix}1  -1\\\\ -1  1\\end{bmatrix}\\,$。通过消除$\\,z=0\\,$平面上的自由度来应用底部边界条件。\n\n对于无外力作用的振动，考虑广义特征值问题$\\,\\mathbf{K}\\,\\boldsymbol{\\phi}_i = \\omega_i^2\\,\\mathbf{M}\\,\\boldsymbol{\\phi}_i\\,$，其中$\\,\\omega_i  0\\,$是自振圆频率（单位为$\\mathrm{rad/s}$），$\\,\\boldsymbol{\\phi}_i\\,$是质量归一化的振型。根据瑞利阻尼模型，每个振型都经历一个标量的、有效的模态阻尼比$\\,\\xi_i\\,$，它取决于$\\,\\alpha\\,$、$\\,\\beta\\,$和$\\,\\omega_i\\,$。你必须从第一性原理推导出这个$\\,\\xi_i\\,$。\n\n重点关注最高频率的模态（具有最大$\\,\\omega_i\\,$的模态），因为已知这类模态会影响瞬态响应中的峰值加速度。对于每个测试用例，计算两个数：\n- $\\,\\xi_{\\max}^{\\mathrm{con}}\\,$：当使用$\\,\\mathbf{M}=\\mathbf{M}_{\\mathrm{con}}\\,$时，最高频率模态的有效模态阻尼比，\n- $\\,\\xi_{\\max}^{\\mathrm{lmp}}\\,$：当使用$\\,\\mathbf{M}=\\mathbf{M}_{\\mathrm{lmp}}\\,$时，最高频率模态的有效模态阻尼比，\n\n然后计算相对差异\n$$\n\\Delta = \\frac{\\xi_{\\max}^{\\mathrm{lmp}} - \\xi_{\\max}^{\\mathrm{con}}}{\\xi_{\\max}^{\\mathrm{con}}}\\,,\n$$\n以无量纲的小数形式报告（无单位）。所有中间物理量必须使用国际单位制处理：长度单位为$\\mathrm{m}$，密度单位为$\\mathrm{kg/m^3}$，剪切模量单位为$\\mathrm{Pa}$，$\\,\\alpha\\,$单位为$\\mathrm{s^{-1}}$，$\\,\\beta\\,$单位为$\\mathrm{s}$，角频率单位为$\\mathrm{rad/s}$。最终输出是以下参数测试套件的$\\,\\Delta\\,$值：\n\n- 测试$\\,1\\,$（基准混合瑞利阻尼）：$\\,n_x=2\\,$, $\\,n_y=2\\,$, $\\,n_z=2\\,$, $\\,h=50\\,$, $\\,\\rho=2000\\,$, $\\,G=1.0\\times 10^{8}\\,$, $\\,\\alpha=0.5\\,$, $\\,\\beta=5.0\\times 10^{-4}\\,$。\n- 测试$\\,2\\,$（仅质量比例阻尼）：$\\,n_x=2\\,$, $\\,n_y=2\\,$, $\\,n_z=2\\,$, $\\,h=50\\,$, $\\,\\rho=2000\\,$, $\\,G=1.0\\times 10^{8}\\,$, $\\,\\alpha=5.0\\,$, $\\,\\beta=0.0\\,$。\n- 测试$\\,3\\,$（仅刚度比例阻尼）：$\\,n_x=2\\,$, $\\,n_y=2\\,$, $\\,n_z=2\\,$, $\\,h=50\\,$, $\\,\\rho=2000\\,$, $\\,G=1.0\\times 10^{8}\\,$, $\\,\\alpha=0.0\\,$, $\\,\\beta=2.0\\times 10^{-3}\\,$。\n- 测试$\\,4\\,$（更大网格，混合瑞利阻尼）：$\\,n_x=3\\,$, $\\,n_y=3\\,$, $\\,n_z=2\\,$, $\\,h=40\\,$, $\\,\\rho=1800\\,$, $\\,G=8.0\\times 10^{7}\\,$, $\\,\\alpha=0.2\\,$, $\\,\\beta=1.0\\times 10^{-3}\\,$。\n\n你的程序必须：\n- 为每个测试的网格和材料参数组装一次$\\,\\mathbf{K}\\,$，\n- 为相同的网格和材料参数组装$\\,\\mathbf{M}_{\\mathrm{con}}\\,$和$\\,\\mathbf{M}_{\\mathrm{lmp}}\\,$，\n- 通过消除$\\,z=0\\,$处受约束的自由度来应用边界条件，\n- 对每种质量矩阵选择求解广义特征值问题，以获得正的$\\,\\omega_i\\,$集合并确定$\\,\\omega_{\\max}\\,$，\n- 在瑞利阻尼下，确定$\\,\\omega_{\\max}\\,$对应的有效模态阻尼比$\\,\\xi_{\\max}\\,$，\n- 计算如上定义的$\\,\\Delta\\,$。\n\n最终输出格式：你的程序应生成单行输出，其中包含四个测试的结果，以逗号分隔的列表形式包含在方括号中，按测试$\\,1\\,$到$\\,4\\,$的顺序排列，例如$\\,\\left[\\Delta_1,\\Delta_2,\\Delta_3,\\Delta_4\\right]\\,$。每个$\\,\\Delta\\,$必须是浮点小数。",
            "solution": "问题陈述经过了严格验证，被认为是可靠、适定且计算上可行的。它基于计算力学和结构动力学的既定原理，提供了一套完整的参数和定义，并要求一个可验证的数值结果。\n\n解决方案如下：首先，我们建立瑞利阻尼模型与有效模态阻尼比之间的理论关系。其次，我们详细说明构建刚度矩阵和质量矩阵的数值程序。第三，我们概述求解广义特征值问题并计算最终要求的量——最高频率模态阻尼比的相对差异的过程。\n\n**1. 瑞利阻尼下的模态阻尼比**\n\n离散系统动力平衡的控制方程由下式给出：\n$$ \\mathbf{M}\\,\\ddot{\\mathbf{u}}(t) + \\mathbf{C}\\,\\dot{\\mathbf{u}}(t) + \\mathbf{K}\\,\\mathbf{u}(t) = \\mathbf{0} $$\n其中$\\mathbf{M}$是质量矩阵，$\\mathbf{C}$是阻尼矩阵，$\\mathbf{K}$是刚度矩阵，$\\mathbf{u}(t)$是节点位移向量。瑞利阻尼模型将阻尼矩阵定义为质量矩阵和刚度矩阵的线性组合：\n$$ \\mathbf{C} = \\alpha\\,\\mathbf{M} + \\beta\\,\\mathbf{K} $$\n其中$\\alpha$和$\\beta$是标量系数。\n\n为了分析系统的响应，我们采用模态分析。通过求解广义特征值问题来找到无阻尼自由振动的特性：\n$$ \\mathbf{K}\\,\\boldsymbol{\\phi}_i = \\omega_i^2\\,\\mathbf{M}\\,\\boldsymbol{\\phi}_i $$\n在这里，$\\omega_i$是自振圆频率，$\\boldsymbol{\\phi}_i$是相应的振型向量。振型对于质量矩阵和刚度矩阵都具有关键的正交性。对于质量归一化的特征向量（$\\boldsymbol{\\phi}_i^\\top \\mathbf{M} \\boldsymbol{\\phi}_i = 1$），这些性质是：\n$$ \\boldsymbol{\\phi}_j^\\top \\mathbf{M} \\boldsymbol{\\phi}_i = \\delta_{ij} $$\n$$ \\boldsymbol{\\phi}_j^\\top \\mathbf{K} \\boldsymbol{\\phi}_i = \\omega_i^2 \\delta_{ij} $$\n其中$\\delta_{ij}$是克罗内克δ（Kronecker delta）。\n\n假设阻尼矩阵$\\mathbf{C}$满足正交性条件（瑞利阻尼确实满足），耦合方程组可以转换为模态坐标$q_i(t)$下的一组解耦的单自由度（SDOF）方程，其中$\\mathbf{u}(t) = \\sum_i \\boldsymbol{\\phi}_i q_i(t)$。第$i$阶模态的单自由度方程是：\n$$ \\ddot{q}_i(t) + 2\\xi_i\\omega_i \\dot{q}_i(t) + \\omega_i^2 q_i(t) = 0 $$\n项$2\\xi_i\\omega_i$是模态阻尼系数，通过将阻尼矩阵投影到模态基上获得：\n$$ 2\\xi_i\\omega_i = \\boldsymbol{\\phi}_i^\\top \\mathbf{C} \\boldsymbol{\\phi}_i = \\boldsymbol{\\phi}_i^\\top (\\alpha\\mathbf{M} + \\beta\\mathbf{K}) \\boldsymbol{\\phi}_i = \\alpha(\\boldsymbol{\\phi}_i^\\top \\mathbf{M} \\boldsymbol{\\phi}_i) + \\beta(\\boldsymbol{\\phi}_i^\\top \\mathbf{K} \\boldsymbol{\\phi}_i) $$\n使用质量归一化振型的正交关系，这可以简化为：\n$$ 2\\xi_i\\omega_i = \\alpha(1) + \\beta(\\omega_i^2) = \\alpha + \\beta\\omega_i^2 $$\n求解有效模态阻尼比$\\xi_i$，我们得到此问题的基本关系式：\n$$ \\xi_i = \\frac{\\alpha}{2\\omega_i} + \\frac{\\beta\\omega_i}{2} $$\n该方程表明，每个模态的阻尼比取决于其自振频率$\\omega_i$和瑞利系数$\\alpha$、$\\beta$。\n\n**2. 矩阵组装和系统构建**\n\n域是一个由$n_x \\times n_y \\times n_z$个六面体单元组成的规则网格。节点总数为$(n_x+1)(n_y+1)(n_z+1)$。每个节点有一个标量自由度（DOF），$u$。为每个网格点$(i,j,k)$分配一个全局节点索引，其中$i \\in [0, n_x]$，$j \\in [0, n_y]$，$k \\in [0, n_z]$。\n\n在底面$z=0$（对应于$k=0$）上的边界条件$u=0$通过静力凝聚法施加。首先为所有自由度组装系统矩阵，然后通过仅保留与自由自由度（其中$k  0$）相对应的行和列来缩减矩阵。\n\n**刚度矩阵（$\\mathbf{K}$）：**\n刚度矩阵是基于一个类有限差分模型构建的，其中相邻节点由线性弹簧连接。连接相距为$h$的两个节点的弹簧刚度由$k = G A/L = G h^2/h = Gh$给出。对于任意两个全局索引为$p$和$q$的相邻节点，弹簧向全局刚度矩阵$\\mathbf{K}$的$(p,p)$、$(p,q)$、$(q,p)$和$(q,q)$位置贡献一个$2 \\times 2$的矩阵$Gh \\begin{psmallmatrix} 1  -1 \\\\ -1  1 \\end{psmallmatrix}$。这个组装过程通过迭代$x, y, z$方向上的所有内部网格线来完成。\n\n**质量矩阵（$\\mathbf{M}_{\\mathrm{lmp}}$和$\\mathbf{M}_{\\mathrm{con}}$）：**\n两种质量矩阵都是通过对$n_x n_y n_z$个单元的贡献求和来组装的。\n\n- **集中质量矩阵（$\\mathbf{M}_{\\mathrm{lmp}}$）：** 这是一个对角矩阵。对于每个体积为$V = h^3$的单元，其总质量$\\rho V$被平均分配给其$8$个节点。因此，这$8$个节点中的每一个都获得$\\rho h^3 / 8$的质量贡献，该贡献被加到全局矩阵$\\mathbf{M}_{\\mathrm{lmp}}$的相应对角线元素上。\n\n- **一致质量矩阵（$\\mathbf{M}_{\\mathrm{con}}$）：** 这是一个非对角或满秩的质量矩阵，它反映了单元形函数所假设的运动学耦合。单元一致质量矩阵$\\mathbf{M}_e$是一个$8 \\times 8$的矩阵。其条目由以下公式给出：\n$$ (\\mathbf{M}_e)_{pq} = \\rho \\frac{h^3}{8} \\left(\\frac{2}{3}\\right)^{m} \\left(\\frac{1}{3}\\right)^{3-m} $$\n其中$p$和$q$是局部节点索引（从$0$到$7$），$m$是节点$p$和$q$相同的局部笛卡尔坐标（$x, y, z$）的数量。例如，如果$p$和$q$是同一个节点，$m=3$；如果它们沿一条边相邻，$m=2$；如果它们在同一个面上但对角相对，$m=1$；如果它们在六面体的对角顶点上，$m=0$。这些单元矩阵被组装成全局矩阵$\\mathbf{M}_{\\mathrm{con}}$。\n\n**3. 数值求解过程**\n\n对于问题中定义的每个测试用例，执行以下步骤：\n1.  定义网格参数（$n_x, n_y, n_z$）和材料/阻尼属性（$h, \\rho, G, \\alpha, \\beta$）。\n2.  构建全局刚度矩阵$\\mathbf{K}$和两个全局质量矩阵$\\mathbf{M}_{\\mathrm{lmp}}$和$\\mathbf{M}_{\\mathrm{con}}$。为提高效率，这些矩阵最初创建为稀疏矩阵。\n3.  识别自由自由度的索引（$k0$的节点）。\n4.  通过使用自由自由度的索引对全局矩阵进行切片，提取缩减后的矩阵$\\mathbf{K}_{\\mathrm{red}}$、$\\mathbf{M}_{\\mathrm{lmp,red}}$和$\\mathbf{M}_{\\mathrm{con,red}}$。\n5.  求解两个独立的广义特征值问题：\n    - $\\mathbf{K}_{\\mathrm{red}}\\,\\boldsymbol{\\phi} = \\lambda^{\\mathrm{con}}\\,\\mathbf{M}_{\\mathrm{con,red}}\\,\\boldsymbol{\\phi}$\n    - $\\mathbf{K}_{\\mathrm{red}}\\,\\boldsymbol{\\phi} = \\lambda^{\\mathrm{lmp}}\\,\\mathbf{M}_{\\mathrm{lmp,red}}\\,\\boldsymbol{\\phi}$\n    其中$\\lambda = \\omega^2$。我们使用一个为对称矩阵优化的数值求解器（`scipy.linalg.eigh`）。\n6.  从得到的特征值集合中，分别确定每种情况下的最大值$\\lambda_{\\max}^{\\mathrm{con}}$和$\\lambda_{\\max}^{\\mathrm{lmp}}$。\n7.  计算相应的最高自振频率：$\\omega_{\\max}^{\\mathrm{con}} = \\sqrt{\\lambda_{\\max}^{\\mathrm{con}}}$ 和 $\\omega_{\\max}^{\\mathrm{lmp}} = \\sqrt{\\lambda_{\\max}^{\\mathrm{lmp}}}$。\n8.  使用导出的$\\xi_i$公式计算这些最高频率模态的阻尼比：\n    - $\\xi_{\\max}^{\\mathrm{con}} = \\dfrac{\\alpha}{2\\omega_{\\max}^{\\mathrm{con}}} + \\dfrac{\\beta\\omega_{\\max}^{\\mathrm{con}}}{2}$\n    - $\\xi_{\\max}^{\\mathrm{lmp}} = \\dfrac{\\alpha}{2\\omega_{\\max}^{\\mathrm{lmp}}} + \\dfrac{\\beta\\omega_{\\max}^{\\mathrm{lmp}}}{2}$\n9.  最后，计算相对差异$\\Delta$：\n    $$ \\Delta = \\frac{\\xi_{\\max}^{\\mathrm{lmp}} - \\xi_{\\max}^{\\mathrm{con}}}{\\xi_{\\max}^{\\mathrm{con}}} $$\n对所有四个测试用例重复此过程，并收集结果。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import eigh\nfrom scipy.sparse import lil_matrix\n\ndef solve():\n    \"\"\"\n    Solves the computational geomechanics problem for all test cases.\n    \"\"\"\n    test_cases = [\n        # Test 1 (baseline)\n        (2, 2, 2, 50.0, 2000.0, 1.0e8, 0.5, 5.0e-4),\n        # Test 2 (mass-proportional)\n        (2, 2, 2, 50.0, 2000.0, 1.0e8, 5.0, 0.0),\n        # Test 3 (stiffness-proportional)\n        (2, 2, 2, 50.0, 2000.0, 1.0e8, 0.0, 2.0e-3),\n        # Test 4 (larger grid)\n        (3, 3, 2, 40.0, 1800.0, 8.0e7, 0.2, 1.0e-3),\n    ]\n\n    results = []\n    for params in test_cases:\n        delta = calculate_delta(*params)\n        results.append(delta)\n\n    print(f\"[{','.join(f'{r:.7f}' for r in results)}]\")\n\n\ndef assemble_matrices_and_solve(nx, ny, nz, h, rho, G, alpha, beta):\n    \"\"\"\n    Assembles matrices, applies BCs, solves eigenvalue problems, \n    and returns the relative difference in modal damping.\n    \"\"\"\n    # Grid dimensions\n    Nx, Ny, Nz = nx + 1, ny + 1, nz + 1\n    num_nodes = Nx * Ny * Nz\n    num_elements = nx * ny * nz\n\n    # Map (i, j, k) grid indices to a single node index\n    def get_node_idx(i, j, k):\n        return i + j * Nx + k * Nx * Ny\n\n    # --- Matrix Assembly ---\n    K = lil_matrix((num_nodes, num_nodes), dtype=np.float64)\n    M_lmp = lil_matrix((num_nodes, num_nodes), dtype=np.float64)\n    M_con = lil_matrix((num_nodes, num_nodes), dtype=np.float64)\n    \n    # 1. Stiffness Matrix K\n    k_spring = G * h\n    spring_mat = k_spring * np.array([[1, -1], [-1, 1]])\n    \n    for k in range(Nz):\n        for j in range(Ny):\n            for i in range(nx):\n                n1 = get_node_idx(i, j, k)\n                n2 = get_node_idx(i + 1, j, k)\n                K[[[n1],[n2]], [n1, n2]] += spring_mat\n    \n    for k in range(Nz):\n        for i in range(Nx):\n            for j in range(ny):\n                n1 = get_node_idx(i, j, k)\n                n2 = get_node_idx(i, j + 1, k)\n                K[[[n1],[n2]], [n1, n2]] += spring_mat\n                \n    for j in range(Ny):\n        for i in range(Nx):\n            for k in range(nz):\n                n1 = get_node_idx(i, j, k)\n                n2 = get_node_idx(i, j, k + 1)\n                K[[[n1],[n2]], [n1, n2]] += spring_mat\n\n    # 2. Mass Matrices M_lmp and M_con\n    element_mass = rho * h**3\n    lumped_mass_per_node = element_mass / 8.0\n\n    # Local node coordinates in an element {0,1}^3\n    local_coords = [\n        (0, 0, 0), (1, 0, 0), (1, 1, 0), (0, 1, 0),\n        (0, 0, 1), (1, 0, 1), (1, 1, 1), (0, 1, 1)\n    ]\n    \n    # Pre-calculate 8x8 element consistent mass matrix\n    Me_con = np.zeros((8, 8), dtype=np.float64)\n    for p in range(8):\n        for q in range(8):\n            m_matches = sum(c1 == c2 for c1, c2 in zip(local_coords[p], local_coords[q]))\n            Me_con[p, q] = (element_mass / 8.0) * (2.0/3.0)**m_matches * (1.0/3.0)**(3 - m_matches)\n\n    # Assemble global mass matrices by iterating through elements\n    for k_el in range(nz):\n        for j_el in range(ny):\n            for i_el in range(nx):\n                # Global indices of the 8 nodes of the element\n                global_indices = [get_node_idx(i_el + dc[0], j_el + dc[1], k_el + dc[2]) for dc in local_coords]\n                \n                # Assembly for M_lmp\n                for idx in global_indices:\n                    M_lmp[idx, idx] += lumped_mass_per_node\n                \n                # Assembly for M_con\n                idx_grid = np.ix_(global_indices, global_indices)\n                M_con[idx_grid] += Me_con\n\n    # --- Boundary Conditions ---\n    # Homogeneous Dirichlet at z=0 (k=0)\n    fixed_dofs = [get_node_idx(i, j, 0) for i in range(Nx) for j in range(Ny)]\n    all_dofs = np.arange(num_nodes)\n    free_dofs = np.setdiff1d(all_dofs, fixed_dofs, assume_unique=True)\n\n    # Reduce matrices to free DOFs\n    K_red = K[free_dofs, :][:, free_dofs].toarray()\n    M_lmp_red = M_lmp[free_dofs, :][:, free_dofs].toarray()\n    M_con_red = M_con[free_dofs, :][:, free_dofs].toarray()\n\n    # --- Eigenvalue Problem ---\n    # Solve K*phi = lambda*M*phi for lambda = omega^2\n    # We only need eigenvalues, so we can use eigvals_only=True for speed.\n    eigvals_lmp = eigh(K_red, M_lmp_red, eigvals_only=True)\n    eigvals_con = eigh(K_red, M_con_red, eigvals_only=True)\n    \n    # Filter out potential near-zero eigenvalues from rigid body modes if any\n    # (not expected here due to BCs but good practice)\n    tol = 1e-9\n    eigvals_lmp = eigvals_lmp[eigvals_lmp > tol]\n    eigvals_con = eigvals_con[eigvals_con > tol]\n\n    # Highest natural frequencies\n    omega_max_lmp = np.sqrt(np.max(eigvals_lmp))\n    omega_max_con = np.sqrt(np.max(eigvals_con))\n\n    # --- Damping Ratio Calculation ---\n    def get_xi(omega, alpha_damp, beta_damp):\n        if omega == 0: return np.inf\n        # Handle cases where alpha or beta are zero to avoid division by zero or unnecessary calcs\n        xi = 0.0\n        if alpha_damp > 0:\n            xi += alpha_damp / (2.0 * omega)\n        if beta_damp > 0:\n            xi += beta_damp * omega / 2.0\n        return xi\n\n    xi_max_lmp = get_xi(omega_max_lmp, alpha, beta)\n    xi_max_con = get_xi(omega_max_con, alpha, beta)\n    \n    if xi_max_con == 0:\n        return 0.0 if xi_max_lmp == 0.0 else np.inf\n\n    delta = (xi_max_lmp - xi_max_con) / xi_max_con\n    return delta\n\ndef calculate_delta(nx, ny, nz, h, rho, G, alpha, beta):\n    \"\"\"Wrapper function to call the main solver.\"\"\"\n    return assemble_matrices_and_solve(nx, ny, nz, h, rho, G, alpha, beta)\n\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}