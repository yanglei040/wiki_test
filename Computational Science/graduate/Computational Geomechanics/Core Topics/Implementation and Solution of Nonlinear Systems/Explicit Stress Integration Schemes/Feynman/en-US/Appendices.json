{
    "hands_on_practices": [
        {
            "introduction": "The cornerstone of any explicit stress integration algorithm is the elastic predictor step. This initial calculation assumes the material responds purely elastically to a given strain increment, providing a 'trial' stress state. This exercise () focuses on deriving and applying this mapping for a plane strain condition, a common idealization in geomechanics, and clarifies how kinematic constraints influence the full stress tensor.",
            "id": "3523455",
            "problem": "Consider an isotropic, linear elastic geomaterial under small strains in a plane strain setting, where the kinematic constraint enforces zero out-of-plane strain. In an explicit stress integration scheme, the elastic predictor step maps a given strain increment to a trial Cauchy stress state prior to any plastic correction. Starting from the three-dimensional small-strain, isotropic linear elasticity constitutive law, construct the elastic predictor mapping that takes the in-plane strain increment vector $\\Delta\\varepsilon = (\\Delta\\varepsilon_{xx},\\,\\Delta\\varepsilon_{yy},\\,0,\\,\\Delta\\gamma_{xy})$ to the trial stress vector $\\sigma^{tr} = (\\sigma^{tr}_{xx},\\,\\sigma^{tr}_{yy},\\,\\sigma^{tr}_{zz},\\,\\tau^{tr}_{xy})$ in plane strain. Explicitly identify how the constrained out-of-plane strain contributes to $\\sigma^{tr}_{zz}$ in the elastic predictor.\n\nAssume the material has Young’s modulus $E = 1200\\,\\text{MPa}$ and Poisson’s ratio $\\nu = 0.30$. The incremental strain state is\n$$\n\\Delta\\varepsilon_{xx} = 1.5\\times 10^{-3},\\quad \\Delta\\varepsilon_{yy} = -5.0\\times 10^{-4},\\quad \\Delta\\gamma_{xy} = 2.0\\times 10^{-3}.\n$$\nAssume the previous stress state is zero, so that the elastic predictor trial stress equals the stress increment. Using the constructed mapping, compute the numerical values of $\\sigma^{tr}_{xx}$, $\\sigma^{tr}_{yy}$, $\\sigma^{tr}_{zz}$, and $\\tau^{tr}_{xy}$. Express the final stress components in megapascals (MPa) and round each to four significant figures.",
            "solution": "The problem is valid as it is scientifically grounded in linear elasticity theory, well-posed with sufficient data, and objectively formulated. We shall proceed with the solution.\n\nThe starting point is the three-dimensional, isotropic, linear elastic constitutive law (Hooke's Law) for small strains, which relates the Cauchy stress tensor $\\sigma_{ij}$ to the strain tensor $\\varepsilon_{ij}$:\n$$\n\\sigma_{ij} = \\lambda \\delta_{ij} \\varepsilon_{kk} + 2G \\varepsilon_{ij}\n$$\nHere, $\\delta_{ij}$ is the Kronecker delta, $\\varepsilon_{kk} = \\varepsilon_{xx} + \\varepsilon_{yy} + \\varepsilon_{zz}$ is the trace of the strain tensor (volumetric strain), and $\\lambda$ and $G$ are the Lamé parameters. These are related to Young's modulus $E$ and Poisson's ratio $\\nu$ by:\n$$\nG = \\frac{E}{2(1+\\nu)} \\quad \\text{and} \\quad \\lambda = \\frac{E\\nu}{(1+\\nu)(1-2\\nu)}\n$$\nThe elastic predictor step in an explicit integration scheme calculates a trial stress increment $\\Delta\\sigma^{tr}$ assuming a fully elastic response to a given strain increment $\\Delta\\varepsilon$. When the previous stress state is zero, the trial stress $\\sigma^{tr}$ is equal to the stress increment $\\Delta\\sigma$. The incremental form of the constitutive law is:\n$$\n\\Delta\\sigma_{ij} = \\lambda \\delta_{ij} \\Delta\\varepsilon_{kk} + 2G \\Delta\\varepsilon_{ij}\n$$\nThe problem specifies a plane strain condition, which imposes the kinematic constraint that there is no strain in the out-of-plane direction ($z$-direction). This means $\\Delta\\varepsilon_{zz} = 0$. Additionally, the out-of-plane shear strains are zero, $\\Delta\\gamma_{xz} = 2\\Delta\\varepsilon_{xz} = 0$ and $\\Delta\\gamma_{yz} = 2\\Delta\\varepsilon_{yz} = 0$.\n\nApplying these constraints, the incremental volumetric strain becomes $\\Delta\\varepsilon_{kk} = \\Delta\\varepsilon_{xx} + \\Delta\\varepsilon_{yy}$. We can now write the components of the trial stress increment:\nFor the in-plane normal stresses:\n$$\n\\sigma^{tr}_{xx} = \\Delta\\sigma_{xx} = \\lambda(\\Delta\\varepsilon_{xx} + \\Delta\\varepsilon_{yy}) + 2G \\Delta\\varepsilon_{xx} = (\\lambda + 2G)\\Delta\\varepsilon_{xx} + \\lambda\\Delta\\varepsilon_{yy}\n$$\n$$\n\\sigma^{tr}_{yy} = \\Delta\\sigma_{yy} = \\lambda(\\Delta\\varepsilon_{xx} + \\Delta\\varepsilon_{yy}) + 2G \\Delta\\varepsilon_{yy} = \\lambda\\Delta\\varepsilon_{xx} + (\\lambda + 2G)\\Delta\\varepsilon_{yy}\n$$\nFor the in-plane shear stress (using engineering shear strain $\\Delta\\gamma_{xy} = 2\\Delta\\varepsilon_{xy}$):\n$$\n\\tau^{tr}_{xy} = \\Delta\\sigma_{xy} = 2G\\Delta\\varepsilon_{xy} = G\\Delta\\gamma_{xy}\n$$\nFor the out-of-plane normal stress:\n$$\n\\sigma^{tr}_{zz} = \\Delta\\sigma_{zz} = \\lambda(\\Delta\\varepsilon_{xx} + \\Delta\\varepsilon_{yy}) + 2G \\Delta\\varepsilon_{zz} = \\lambda(\\Delta\\varepsilon_{xx} + \\Delta\\varepsilon_{yy})\n$$\nThe out-of-plane shear stresses are zero since the corresponding shear strains are zero:\n$$\n\\tau^{tr}_{xz} = 0, \\quad \\tau^{tr}_{yz} = 0\n$$\nThis set of equations constitutes the elastic predictor mapping for plane strain.\n\nThe contribution of the constrained out-of-plane strain to $\\sigma^{tr}_{zz}$ is explained by the equation $\\sigma^{tr}_{zz} = \\lambda(\\Delta\\varepsilon_{xx} + \\Delta\\varepsilon_{yy})$. Physically, the in-plane strains $\\Delta\\varepsilon_{xx}$ and $\\Delta\\varepsilon_{yy}$ would induce an out-of-plane strain $\\Delta\\varepsilon_{zz}'$ through the Poisson effect. To enforce the kinematic constraint $\\Delta\\varepsilon_{zz} = 0$, a normal stress $\\sigma_{zz}^{tr}$ must develop to counteract this tendency. An alternative expression for $\\sigma_{zz}^{tr}$ is $\\sigma_{zz}^{tr} = \\nu(\\sigma_{xx}^{tr} + \\sigma_{yy}^{tr})$. The equivalence of these two expressions is a hallmark of the plane strain formulation and can be verified by substituting the expressions for $\\sigma_{xx}^{tr}$ and $\\sigma_{yy}^{tr}$ into the second form and using the definitions of $\\lambda$ and $G$.\n\nNow, we compute the numerical values. The given material properties are $E = 1200\\,\\text{MPa}$ and $\\nu = 0.30$.\nFirst, calculate the Lamé parameters:\n$$\nG = \\frac{1200\\,\\text{MPa}}{2(1+0.30)} = \\frac{1200}{2.6}\\,\\text{MPa} = \\frac{6000}{13}\\,\\text{MPa} \\approx 461.538\\,\\text{MPa}\n$$\n$$\n\\lambda = \\frac{1200\\,\\text{MPa} \\times 0.30}{(1+0.30)(1 - 2 \\times 0.30)} = \\frac{360}{1.3 \\times 0.4}\\,\\text{MPa} = \\frac{360}{0.52}\\,\\text{MPa} = \\frac{9000}{13}\\,\\text{MPa} \\approx 692.308\\,\\text{MPa}\n$$\nThe plane strain modulus is:\n$$\n\\lambda + 2G = \\frac{9000}{13}\\,\\text{MPa} + 2\\left(\\frac{6000}{13}\\right)\\,\\text{MPa} = \\frac{21000}{13}\\,\\text{MPa} \\approx 1615.385\\,\\text{MPa}\n$$\nThe incremental strain components are given as:\n$\\Delta\\varepsilon_{xx} = 1.5\\times 10^{-3}$\n$\\Delta\\varepsilon_{yy} = -5.0\\times 10^{-4} = -0.5\\times 10^{-3}$\n$\\Delta\\gamma_{xy} = 2.0\\times 10^{-3}$\n\nUsing the derived mapping, we compute the trial stress components:\n$$\n\\sigma^{tr}_{xx} = \\left(\\frac{21000}{13}\\right)(1.5 \\times 10^{-3}) + \\left(\\frac{9000}{13}\\right)(-0.5 \\times 10^{-3}) = \\frac{10^{-3}}{13}(31500 - 4500) = \\frac{27000}{13} \\times 10^{-3} = \\frac{27}{13}\\,\\text{MPa}\n$$\n$$\n\\sigma^{tr}_{xx} \\approx 2.076923\\,\\text{MPa}\n$$\nRounding to four significant figures gives $\\sigma^{tr}_{xx} = 2.077\\,\\text{MPa}$.\n\n$$\n\\sigma^{tr}_{yy} = \\left(\\frac{9000}{13}\\right)(1.5 \\times 10^{-3}) + \\left(\\frac{21000}{13}\\right)(-0.5 \\times 10^{-3}) = \\frac{10^{-3}}{13}(13500 - 10500) = \\frac{3000}{13} \\times 10^{-3} = \\frac{3}{13}\\,\\text{MPa}\n$$\n$$\n\\sigma^{tr}_{yy} \\approx 0.230769\\,\\text{MPa}\n$$\nRounding to four significant figures gives $\\sigma^{tr}_{yy} = 0.2308\\,\\text{MPa}$.\n\n$$\n\\sigma^{tr}_{zz} = \\left(\\frac{9000}{13}\\right)(\\Delta\\varepsilon_{xx} + \\Delta\\varepsilon_{yy}) = \\left(\\frac{9000}{13}\\right)(1.5 \\times 10^{-3} - 0.5 \\times 10^{-3}) = \\left(\\frac{9000}{13}\\right)(1.0 \\times 10^{-3}) = \\frac{9}{13}\\,\\text{MPa}\n$$\n$$\n\\sigma^{tr}_{zz} \\approx 0.692307\\,\\text{MPa}\n$$\nRounding to four significant figures gives $\\sigma^{tr}_{zz} = 0.6923\\,\\text{MPa}$.\n\n$$\n\\tau^{tr}_{xy} = G\\Delta\\gamma_{xy} = \\left(\\frac{6000}{13}\\right)(2.0 \\times 10^{-3}) = \\frac{12000}{13} \\times 10^{-3} = \\frac{12}{13}\\,\\text{MPa}\n$$\n$$\n\\tau^{tr}_{xy} \\approx 0.923076\\,\\text{MPa}\n$$\nRounding to four significant figures gives $\\tau^{tr}_{xy} = 0.9231\\,\\text{MPa}$.\n\nThe computed trial stress components, rounded to four significant figures, are: $\\sigma^{tr}_{xx} = 2.077\\,\\text{MPa}$, $\\sigma^{tr}_{yy} = 0.2308\\,\\text{MPa}$, $\\sigma^{tr}_{zz} = 0.6923\\,\\text{MPa}$, and $\\tau^{tr}_{xy} = 0.9231\\,\\text{MPa}$.",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 2.077 & 0.2308 & 0.6923 & 0.9231 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "Moving from a single step to a complete algorithm, this practice involves implementing a full elastic predictor-plastic corrector scheme for a Drucker–Prager material. A key challenge with explicit methods is the potential for 'spurious plasticity'—non-physical plastic deformation computed during load reversals. This exercise () guides you through implementing a robust unloading check to prevent this artifact, a critical skill for developing reliable geomechanical simulation tools.",
            "id": "3523530",
            "problem": "Design and implement a complete, runnable program that performs explicit stress integration with an elastic predictor and a plastic corrector for a Drucker–Prager (DP) type, small-strain, isotropic, elasto-plastic material in three dimensions. The integration scheme must include a robust unloading detection based on the sign of the incremental plastic work. The goal is to quantify spurious plasticity under explicit integration when the loading alternates between loading and unloading at every step.\n\nThe program must be purely algorithmic and use the following fundamental basis.\n\n- Small-strain, linear, isotropic elasticity, expressed as the second-order stress tensor update\n$$\n\\boldsymbol{\\sigma}_{\\text{trial}} = \\boldsymbol{\\sigma}_n + \\lambda \\, \\mathrm{tr}(\\Delta\\boldsymbol{\\epsilon}) \\, \\boldsymbol{I} + 2 G \\, \\Delta\\boldsymbol{\\epsilon},\n$$\nwhere $ \\boldsymbol{\\sigma}_n $ is the stress at the start of the increment, $ \\Delta\\boldsymbol{\\epsilon} $ is the strain increment tensor, $ \\lambda $ is the first Lamé parameter, $ G $ is the shear modulus, $ \\boldsymbol{I} $ is the identity tensor, and $ \\mathrm{tr}(\\cdot) $ denotes the trace. The bulk modulus $ K $ and $ \\lambda $ satisfy $ K = \\lambda + \\tfrac{2}{3} G $.\n\n- Drucker–Prager yield function with associated flow defined using the second deviatoric stress invariant and the mean stress under the tension-positive sign convention:\n$$\nf(\\boldsymbol{\\sigma}, \\kappa) = \\sqrt{J_2(\\boldsymbol{\\sigma})} + \\eta \\, p(\\boldsymbol{\\sigma}) - \\left(k_0 + H \\kappa \\right),\n$$\nwhere $ \\kappa $ is a scalar hardening variable, $ H $ is the plastic modulus (isotropic hardening slope), $ k_0 $ is the initial size of the yield surface, $ \\eta $ is a dimensionless friction parameter, $ \\boldsymbol{s} = \\boldsymbol{\\sigma} - \\tfrac{1}{3} \\mathrm{tr}(\\boldsymbol{\\sigma}) \\boldsymbol{I} $ is the deviatoric stress, $ J_2(\\boldsymbol{\\sigma}) = \\tfrac{1}{2} \\, \\boldsymbol{s} : \\boldsymbol{s} $, and the mean compressive stress $ p(\\boldsymbol{\\sigma}) = -\\tfrac{1}{3} \\mathrm{tr}(\\boldsymbol{\\sigma}) $ so that $ p > 0 $ in compression. The associated flow direction is $ \\boldsymbol{n} = \\partial f / \\partial \\boldsymbol{\\sigma} $.\n\n- Unloading detection must be based on the sign of the incremental plastic work indicator computed with the elastic predictor:\n$$\n\\boldsymbol{n}_{\\text{trial}} : \\mathbb{C} : \\Delta\\boldsymbol{\\epsilon} < 0 \\quad \\Rightarrow \\quad \\text{unloading, bypass plastic corrector},\n$$\nwhere $ \\mathbb{C} $ is the fourth-order isotropic elasticity tensor and $ \\boldsymbol{n}_{\\text{trial}} = \\left. \\partial f / \\partial \\boldsymbol{\\sigma} \\right|_{\\boldsymbol{\\sigma}_{\\text{trial}}} $. When unloading is detected, update stress elastically and do not update the plastic variables.\n\n- When unloading is not detected and the trial state violates yield, i.e., $ f(\\boldsymbol{\\sigma}_{\\text{trial}}, \\kappa_n) > 0 $, apply an explicit plastic corrector obtained by a first-order Taylor linearization of the consistency condition $ f(\\boldsymbol{\\sigma}, \\kappa) = 0 $ over the increment. All stresses are in megapascals (MPa), strains are dimensionless.\n\nYou must implement a loading program that toggles between loading and unloading every step. Use the tension-positive sign convention. In each case below, start from $ \\boldsymbol{\\sigma}_0 = \\boldsymbol{0} $ and $ \\kappa_0 = 0 $. Run two simulations per case:\n1. A baseline explicit integration without unloading detection (plastic corrector applied whenever $ f_{\\text{trial}} > 0 $).\n2. The same explicit integration with unloading detection (bypass plastic corrector whenever $ \\boldsymbol{n}_{\\text{trial}} : \\mathbb{C} : \\Delta\\boldsymbol{\\epsilon} < 0 $).\n\nQuantify spurious plasticity as the difference in accumulated hardening variable at the end of the simulation,\n$$\n\\Delta \\kappa_{\\text{spurious}} = \\kappa_{\\text{no-unloading-check}} - \\kappa_{\\text{with-unloading-check}},\n$$\nexpressed as a decimal number.\n\nTest suite and units:\n- Material parameters are $ G $ in MPa, $ K $ in MPa, $ \\eta $ dimensionless, $ H $ in MPa, $ k_0 $ in MPa.\n- Strain increments are second-order tensors $ \\Delta\\boldsymbol{\\epsilon} $ with components in the tension-positive sign convention; strains are dimensionless.\n- Angles are not used; do not include any angle units.\n- The program must compute and report $ \\Delta \\kappa_{\\text{spurious}} $ for each case as floats.\n\nProvide the following three cases as the test suite:\n\n- Case 1 (deviatoric toggle, typical loading): $ G = 1000 \\, \\mathrm{MPa}, K = 2000 \\, \\mathrm{MPa}, \\eta = 0.1, H = 100 \\, \\mathrm{MPa}, k_0 = 0.05 \\, \\mathrm{MPa} $. Number of steps $ N = 200 $. At step $ k $, apply a pure shear strain increment alternating sign: $ \\Delta\\boldsymbol{\\epsilon}_k $ with $ \\epsilon_{12} = \\epsilon_{21} = (-1)^k \\, \\varepsilon_s $ and all other components zero, with $ \\varepsilon_s = 5 \\times 10^{-5} $.\n\n- Case 2 (boundary case near zero loading): same material parameters as Case 1, but $ N = 50 $ and $ \\varepsilon_s = 10^{-8} $.\n\n- Case 3 (volumetric toggle, friction-dominated): $ G = 1000 \\, \\mathrm{MPa}, K = 2000 \\, \\mathrm{MPa}, \\eta = 0.3, H = 100 \\, \\mathrm{MPa}, k_0 = 0.05 \\, \\mathrm{MPa} $. Number of steps $ N = 200 $. At step $ k $, apply a purely volumetric strain increment alternating sign: $ \\Delta\\boldsymbol{\\epsilon}_k = \\tfrac{1}{3} (-1)^k \\, \\Delta\\varepsilon_v \\, \\boldsymbol{I} $ with $ \\Delta\\varepsilon_v = 10^{-4} $.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3]\"), where each result is $ \\Delta \\kappa_{\\text{spurious}} $ for the corresponding case as a float. All stresses must be internally computed and used in MPa; the reported $ \\Delta \\kappa_{\\text{spurious}} $ values are dimensionless decimals.",
            "solution": "The solution requires implementing a step-by-step stress integration algorithm for the Drucker-Prager material model. For each time step, given the state $(\\boldsymbol{\\sigma}_n, \\kappa_n)$ and the strain increment $\\Delta\\boldsymbol{\\epsilon}$, the new state $(\\boldsymbol{\\sigma}_{n+1}, \\kappa_{n+1})$ is computed. The algorithm proceeds as follows.\n\n**1. Elastic Predictor**\nFirst, a trial stress, $\\boldsymbol{\\sigma}_{\\text{trial}}$, is computed assuming the entire strain increment is elastic:\n$$\n\\boldsymbol{\\sigma}_{\\text{trial}} = \\boldsymbol{\\sigma}_n + (K - \\tfrac{2}{3}G) \\, \\mathrm{tr}(\\Delta\\boldsymbol{\\epsilon}) \\, \\boldsymbol{I} + 2 G \\, \\Delta\\boldsymbol{\\epsilon}\n$$\n\n**2. Yield Condition Check**\nThe yield function is evaluated at the trial state, using the hardening state from the beginning of the step, $\\kappa_n$:\n$$\nf_{\\text{trial}} = f(\\boldsymbol{\\sigma}_{\\text{trial}}, \\kappa_n) = \\sqrt{J_{2,\\text{trial}}} + \\eta \\, p_{\\text{trial}} - (k_0 + H \\kappa_n)\n$$\nwhere $p_{\\text{trial}} = -\\frac{1}{3}\\mathrm{tr}(\\boldsymbol{\\sigma}_{\\text{trial}})$ and $J_{2,\\text{trial}} = \\frac{1}{2}\\boldsymbol{s}_{\\text{trial}}:\\boldsymbol{s}_{\\text{trial}}$ with $\\boldsymbol{s}_{\\text{trial}} = \\boldsymbol{\\sigma}_{\\text{trial}} + p_{\\text{trial}}\\boldsymbol{I}$. If $f_{\\text{trial}} \\le 0$, the step is elastic, and the state is updated as $\\boldsymbol{\\sigma}_{n+1} = \\boldsymbol{\\sigma}_{\\text{trial}}$ and $\\kappa_{n+1} = \\kappa_n$. If $f_{\\text{trial}} > 0$, yielding has occurred and a plastic corrector step may be necessary.\n\n**3. Unloading Check (where applicable)**\nFor the simulation variant with unloading detection, the indicator $I_{unload} = \\boldsymbol{n}_{\\text{trial}} : \\mathbb{C} : \\Delta\\boldsymbol{\\epsilon}$ is computed when $f_{\\text{trial}} > 0$. The gradient of the yield function at the trial stress, $\\boldsymbol{n}_{\\text{trial}} = \\left. \\partial f / \\partial \\boldsymbol{\\sigma} \\right|_{\\boldsymbol{\\sigma}_{\\text{trial}}}$, is:\n$$\n\\boldsymbol{n}_{\\text{trial}} = \\frac{\\boldsymbol{s}_{\\text{trial}}}{2\\sqrt{J_{2,\\text{trial}}}} - \\frac{\\eta}{3}\\boldsymbol{I}\n$$\nThe unloading indicator simplifies to:\n$$\nI_{unload} = \\frac{G \\, (\\boldsymbol{s}_{\\text{trial}} : \\Delta\\boldsymbol{\\epsilon})}{\\sqrt{J_{2,\\text{trial}}}} - \\eta K \\, \\mathrm{tr}(\\Delta\\boldsymbol{\\epsilon})\n$$\nIf $I_{unload}  0$, the step is treated as elastic (unloading), even though the trial stress is outside the yield surface.\n\n**4. Explicit Plastic Corrector**\nIf $f_{\\text{trial}} > 0$ and the unloading check (if active) is not triggered, a plastic correction is applied. The plastic multiplier increment, $\\Delta\\gamma$, is derived from a first-order Taylor expansion of the consistency condition, yielding:\n$$\n\\Delta\\gamma = \\frac{f_{\\text{trial}}}{\\boldsymbol{n}_{\\text{trial}} : \\mathbb{C} : \\boldsymbol{n}_{\\text{trial}} + H}\n$$\nFor the Drucker-Prager model, the denominator simplifies to a constant, $\\boldsymbol{n}_{\\text{trial}} : \\mathbb{C} : \\boldsymbol{n}_{\\text{trial}} = G + K\\eta^2$, giving the explicit formula:\n$$\n\\Delta\\gamma = \\frac{f_{\\text{trial}}}{G + K\\eta^2 + H}\n$$\nThe state variables are then updated. The hardening variable evolves as $\\kappa_{n+1} = \\kappa_n + \\Delta\\gamma$, and the stress is corrected via:\n$$\n\\boldsymbol{\\sigma}_{n+1} = \\boldsymbol{\\sigma}_{\\text{trial}} - \\Delta\\gamma \\, (\\mathbb{C} : \\boldsymbol{n}_{\\text{trial}})\n$$\nwhere the correction term is $\\mathbb{C} : \\boldsymbol{n}_{\\text{trial}} = -K\\eta\\boldsymbol{I} + \\frac{G \\boldsymbol{s}_{\\text{trial}}}{\\sqrt{J_{2,\\text{trial}}}}$.\n\n**5. Simulation and Quantification**\nThis algorithm is implemented in a loop for two scenarios: one with the unloading check and one without. The difference in the final accumulated hardening variable, $\\Delta \\kappa_{\\text{spurious}} = \\kappa_{N, \\text{no-check}} - \\kappa_{N, \\text{with-check}}$, quantifies the spurious plasticity. For Case 3, the purely volumetric strain generates only hydrostatic stress. The yield condition is never met for tensile volumetric strain ($p \\le 0$) because $k_0>0$. Thus, both simulations are purely elastic, resulting in zero accumulated plasticity and $\\Delta\\kappa_{\\text{spurious}} = 0$.",
            "answer": "```python\nimport numpy as np\n\ndef run_simulation(G, K, eta, H, k0, N, get_deps_k, use_unloading_check):\n    \"\"\"\n    Performs an explicit stress integration for a Drucker-Prager material.\n\n    Args:\n        G (float): Shear modulus (MPa).\n        K (float): Bulk modulus (MPa).\n        eta (float): Friction parameter.\n        H (float): Hardening modulus (MPa).\n        k0 (float): Initial cohesion (MPa).\n        N (int): Number of steps.\n        get_deps_k (function): Function that returns the strain increment tensor\n                               for a given step k.\n        use_unloading_check (bool): If True, enables the unloading check.\n\n    Returns:\n        float: The final accumulated hardening variable kappa.\n    \"\"\"\n    sigma = np.zeros((3, 3))\n    kappa = 0.0\n    \n    # Pre-compute constants\n    lame_lambda = K - 2.0 / 3.0 * G\n    I = np.identity(3)\n    tol = 1e-12 # Tolerance for floating point comparisons\n    \n    # Denominator for plastic multiplier is constant for this model\n    denom_dgamma = G + K * eta**2 + H\n    \n    for k in range(N):\n        delta_eps = get_deps_k(k)\n        \n        # 1. Elastic predictor\n        tr_delta_eps = np.trace(delta_eps)\n        sigma_trial = sigma + lame_lambda * tr_delta_eps * I + 2 * G * delta_eps\n        \n        # 2. Yield check\n        tr_sigma_trial = np.trace(sigma_trial)\n        p_trial = -tr_sigma_trial / 3.0\n        s_trial = sigma_trial - (tr_sigma_trial / 3.0) * I\n        \n        J2_trial = 0.5 * np.sum(s_trial * s_trial)\n        sqrt_J2_trial = np.sqrt(J2_trial) if J2_trial > 0 else 0.0\n        \n        yield_surface_size = k0 + H * kappa\n        f_trial = sqrt_J2_trial + eta * p_trial - yield_surface_size\n        \n        is_plastic = f_trial > tol\n        \n        # 3. Unloading check (if applicable)\n        if is_plastic and use_unloading_check:\n            s_trial_dot_deps = np.sum(s_trial * delta_eps)\n            \n            unload_indicator = -eta * K * tr_delta_eps\n            if sqrt_J2_trial > tol:\n                unload_indicator += G * s_trial_dot_deps / sqrt_J2_trial\n            \n            if unload_indicator  0:\n                is_plastic = False\n\n        # 4. Plastic corrector (if plastic) or elastic update\n        if is_plastic:\n            # Calculate plastic multiplier\n            d_gamma = f_trial / denom_dgamma\n            \n            # Update hardening\n            kappa += d_gamma\n            \n            # Update stress\n            C_n_dev = np.zeros((3, 3))\n            if sqrt_J2_trial > tol:\n                C_n_dev = G * s_trial / sqrt_J2_trial\n            \n            C_n = -K * eta * I + C_n_dev\n            sigma = sigma_trial - d_gamma * C_n\n        else:\n            # Elastic update (or unloading detected)\n            sigma = sigma_trial\n            # kappa remains unchanged\n            \n    return kappa\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and compute spurious plasticity.\n    \"\"\"\n    # Case 1: Deviatoric toggle, typical loading\n    case1_params = {\n        'G': 1000.0, 'K': 2000.0, 'eta': 0.1, 'H': 100.0, 'k0': 0.05,\n        'N': 200, 'eps_s': 5e-5\n    }\n    def get_deps_c1(k):\n        deps = np.zeros((3, 3))\n        val = ((-1)**k) * case1_params['eps_s']\n        deps[0, 1] = deps[1, 0] = val\n        return deps\n\n    # Case 2: Deviatoric toggle, near zero loading\n    case2_params = {\n        'G': 1000.0, 'K': 2000.0, 'eta': 0.1, 'H': 100.0, 'k0': 0.05,\n        'N': 50, 'eps_s': 1e-8\n    }\n    def get_deps_c2(k):\n        deps = np.zeros((3, 3))\n        val = ((-1)**k) * case2_params['eps_s']\n        deps[0, 1] = deps[1, 0] = val\n        return deps\n\n    # Case 3: Volumetric toggle, friction-dominated\n    case3_params = {\n        'G': 1000.0, 'K': 2000.0, 'eta': 0.3, 'H': 100.0, 'k0': 0.05,\n        'N': 200, 'delta_eps_v': 1e-4\n    }\n    def get_deps_c3(k):\n        val = (1.0/3.0) * ((-1)**k) * case3_params['delta_eps_v']\n        return val * np.identity(3)\n\n    test_cases = [\n        (case1_params, get_deps_c1),\n        (case2_params, get_deps_c2),\n        (case3_params, get_deps_c3),\n    ]\n\n    results = []\n    for params, get_deps_func in test_cases:\n        # Run baseline simulation without unloading check\n        kappa_no_check = run_simulation(\n            params['G'], params['K'], params['eta'], params['H'], params['k0'],\n            params['N'], get_deps_func, use_unloading_check=False\n        )\n        \n        # Run simulation with unloading check\n        kappa_with_check = run_simulation(\n            params['G'], params['K'], params['eta'], params['H'], params['k0'],\n            params['N'], get_deps_func, use_unloading_check=True\n        )\n        \n        delta_kappa_spurious = kappa_no_check - kappa_with_check\n        results.append(delta_kappa_spurious)\n    \n    # Format and print the final results\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A correct implementation must not only follow the algorithm but also produce physically meaningful results. This verification exercise introduces a powerful check based on a fundamental thermodynamic principle: plastic dissipation must be non-negative. By programming a routine to track the accumulated plastic work (), you will learn to detect non-physical energy generation, a clear sign of integration errors or algorithmic flaws.",
            "id": "3523470",
            "problem": "You are tasked with implementing and verifying a plastic work accumulation check for an explicit stress integration scheme composed of an elastic predictor and plastic corrector in small-strain computational geomechanics. The verification step must detect nonphysical energy gain due to integration errors by examining the plastic dissipation per step and the accumulated plastic work.\n\nStart from the following fundamental base. In the small-strain setting, the rate of stress power is given by $P = \\boldsymbol{\\sigma} : \\dot{\\boldsymbol{\\varepsilon}}$, where $\\boldsymbol{\\sigma}$ is the Cauchy stress tensor and $\\dot{\\boldsymbol{\\varepsilon}}$ is the strain-rate tensor. Decompose the strain-rate into elastic and plastic parts as $\\dot{\\boldsymbol{\\varepsilon}} = \\dot{\\boldsymbol{\\varepsilon}}^e + \\dot{\\boldsymbol{\\varepsilon}}^p$. The plastic dissipation rate is defined by $D = \\boldsymbol{\\sigma} : \\dot{\\boldsymbol{\\varepsilon}}^p$. For associative, rate-independent plasticity with a convex yield function, the flow rule is $\\dot{\\boldsymbol{\\varepsilon}}^p = \\dot{\\lambda}\\,\\partial f/\\partial \\boldsymbol{\\sigma}$ with $\\dot{\\lambda} \\ge 0$, and the Karush–Kuhn–Tucker conditions enforce $D \\ge 0$ under physically admissible evolution.\n\nYour verification step must implement the following logic:\n- For each time increment $k$, given the corrected stress $\\boldsymbol{\\sigma}_{n+1}^{(k)}$ and the plastic strain increment $\\Delta \\boldsymbol{\\varepsilon}^p{}^{(k)}$, compute the plastic work increment\n$$\n\\Delta W_p^{(k)} = \\boldsymbol{\\sigma}_{n+1}^{(k)} : \\Delta \\boldsymbol{\\varepsilon}^p{}^{(k)} = \\sum_{i=1}^3 \\sum_{j=1}^3 \\sigma_{n+1,ij}^{(k)} \\,\\Delta \\varepsilon^p{}_{ij}^{(k)}.\n$$\n- Accumulate the total plastic work\n$$\nW_p = \\sum_{k=1}^{N} \\Delta W_p^{(k)}.\n$$\n- To account for finite precision, use a per-step relative tolerance\n$$\n\\mathrm{tol}^{(k)} = r_{\\text{tol}}\\;\\|\\boldsymbol{\\sigma}_{n+1}^{(k)}\\|_F\\;\\|\\Delta \\boldsymbol{\\varepsilon}^p{}^{(k)}\\|_F,\n$$\nwhere $\\|\\cdot\\|_F$ denotes the Frobenius norm and $r_{\\text{tol}}$ is a given small scalar. In this task, set $r_{\\text{tol}} = 10^{-12}$.\n- Flag nonphysical energy gain if either:\n    1. There exists a step $k$ such that $\\Delta W_p^{(k)}  -\\mathrm{tol}^{(k)}$, or\n    2. The final accumulated $W_p  -\\sum_{k=1}^{N} \\mathrm{tol}^{(k)}$.\n\nAll stresses $\\boldsymbol{\\sigma}$ are specified in Pascals (SI unit $\\mathrm{Pa}$) and all strains are dimensionless. The plastic work and tolerances are energy densities in joules per cubic meter ($\\mathrm{J/m^3}$). These units do not need to be printed; the program output will be booleans only.\n\nImplement a program that evaluates the following test suite. Each test case consists of a sequence of steps; each step provides a symmetric $3\\times 3$ stress tensor $\\boldsymbol{\\sigma}_{n+1}^{(k)}$ and a symmetric $3\\times 3$ plastic strain increment $\\Delta \\boldsymbol{\\varepsilon}^p{}^{(k)}$.\n\nTest Case $1$ (happy path: strictly nonnegative dissipation each step):\n- Step $1$:\n$$\n\\boldsymbol{\\sigma}_{n+1}^{(1)} =\n\\begin{bmatrix}\n150\\times 10^6  5\\times 10^6  0 \\\\\n5\\times 10^6  120\\times 10^6  0 \\\\\n0  0  90\\times 10^6\n\\end{bmatrix},\\quad\n\\Delta \\boldsymbol{\\varepsilon}^p{}^{(1)} =\n\\begin{bmatrix}\n1.0\\times 10^{-5}  2.0\\times 10^{-6}  0 \\\\\n2.0\\times 10^{-6}  -5.0\\times 10^{-6}  0 \\\\\n0  0  -5.0\\times 10^{-6}\n\\end{bmatrix}.\n$$\n- Step $2$:\n$$\n\\boldsymbol{\\sigma}_{n+1}^{(2)} =\n\\begin{bmatrix}\n160\\times 10^6  4\\times 10^6  1\\times 10^6 \\\\\n4\\times 10^6  115\\times 10^6  0.5\\times 10^6 \\\\\n1\\times 10^6  0.5\\times 10^6  85\\times 10^6\n\\end{bmatrix},\\quad\n\\Delta \\boldsymbol{\\varepsilon}^p{}^{(2)} =\n\\begin{bmatrix}\n0.8\\times 10^{-5}  1.0\\times 10^{-6}  0.2\\times 10^{-6} \\\\\n1.0\\times 10^{-6}  -4.0\\times 10^{-6}  0.1\\times 10^{-6} \\\\\n0.2\\times 10^{-6}  0.1\\times 10^{-6}  -4.0\\times 10^{-6}\n\\end{bmatrix}.\n$$\n- Step $3$:\n$$\n\\boldsymbol{\\sigma}_{n+1}^{(3)} =\n\\begin{bmatrix}\n165\\times 10^6  3\\times 10^6  2\\times 10^6 \\\\\n3\\times 10^6  110\\times 10^6  1\\times 10^6 \\\\\n2\\times 10^6  1\\times 10^6  80\\times 10^6\n\\end{bmatrix},\\quad\n\\Delta \\boldsymbol{\\varepsilon}^p{}^{(3)} =\n\\begin{bmatrix}\n0.7\\times 10^{-5}  1.5\\times 10^{-6}  0.3\\times 10^{-6} \\\\\n1.5\\times 10^{-6}  -3.5\\times 10^{-6}  0.2\\times 10^{-6} \\\\\n0.3\\times 10^{-6}  0.2\\times 10^{-6}  -3.5\\times 10^{-6}\n\\end{bmatrix}.\n$$\n\nTest Case $2$ (boundary case: isotropic stress with trace-free plastic strain increments, yielding zero dissipation):\n- Step $1$:\n$$\n\\boldsymbol{\\sigma}_{n+1}^{(1)} =\n\\begin{bmatrix}\n50\\times 10^6  0  0 \\\\\n0  50\\times 10^6  0 \\\\\n0  0  50\\times 10^6\n\\end{bmatrix},\\quad\n\\Delta \\boldsymbol{\\varepsilon}^p{}^{(1)} =\n\\begin{bmatrix}\n1.0\\times 10^{-6}  0  0 \\\\\n0  -0.5\\times 10^{-6}  0 \\\\\n0  0  -0.5\\times 10^{-6}\n\\end{bmatrix}.\n$$\n- Step $2$:\n$$\n\\boldsymbol{\\sigma}_{n+1}^{(2)} =\n\\begin{bmatrix}\n50\\times 10^6  0  0 \\\\\n0  50\\times 10^6  0 \\\\\n0  0  50\\times 10^6\n\\end{bmatrix},\\quad\n\\Delta \\boldsymbol{\\varepsilon}^p{}^{(2)} =\n\\begin{bmatrix}\n2.0\\times 10^{-6}  0  0 \\\\\n0  -1.0\\times 10^{-6}  0 \\\\\n0  0  -1.0\\times 10^{-6}\n\\end{bmatrix}.\n$$\n\nTest Case $3$ (error case: negative dissipation due to misaligned increments, should be flagged):\n- Step $1$:\n$$\n\\boldsymbol{\\sigma}_{n+1}^{(1)} =\n\\begin{bmatrix}\n100\\times 10^6  40\\times 10^6  0 \\\\\n40\\times 10^6  100\\times 10^6  0 \\\\\n0  0  100\\times 10^6\n\\end{bmatrix},\\quad\n\\Delta \\boldsymbol{\\varepsilon}^p{}^{(1)} =\n\\begin{bmatrix}\n-1.0\\times 10^{-5}  4.0\\times 10^{-6}  0 \\\\\n4.0\\times 10^{-6}  -1.0\\times 10^{-5}  0 \\\\\n0  0  -1.0\\times 10^{-5}\n\\end{bmatrix}.\n$$\n\nTest Case $4$ (edge cases: zero stress or zero plastic strain increments, yielding zero dissipation):\n- Step $1$:\n$$\n\\boldsymbol{\\sigma}_{n+1}^{(1)} =\n\\begin{bmatrix}\n0  0  0 \\\\\n0  0  0 \\\\\n0  0  0\n\\end{bmatrix},\\quad\n\\Delta \\boldsymbol{\\varepsilon}^p{}^{(1)} =\n\\begin{bmatrix}\n1.0\\times 10^{-6}  -0.5\\times 10^{-6}  0 \\\\\n-0.5\\times 10^{-6}  0  0 \\\\\n0  0  -0.5\\times 10^{-6}\n\\end{bmatrix}.\n$$\n- Step $2$:\n$$\n\\boldsymbol{\\sigma}_{n+1}^{(2)} =\n\\begin{bmatrix}\n80\\times 10^6  0  0 \\\\\n0  80\\times 10^6  0 \\\\\n0  0  80\\times 10^6\n\\end{bmatrix},\\quad\n\\Delta \\boldsymbol{\\varepsilon}^p{}^{(2)} =\n\\begin{bmatrix}\n0  0  0 \\\\\n0  0  0 \\\\\n0  0  0\n\\end{bmatrix}.\n$$\n\nYour program must implement the verification logic described above, evaluate each test case, and produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test cases, where each entry is a boolean indicating whether a nonphysical energy gain was flagged for that test case (e.g., $[\\text{result1},\\text{result2},\\text{result3},\\text{result4}]$).",
            "solution": "The solution requires implementing a verification step to ensure that the plastic dissipation computed during the stress integration is physically admissible. The Second Law of Thermodynamics, when applied to plasticity, requires that the plastic dissipation rate $D = \\boldsymbol{\\sigma} : \\dot{\\boldsymbol{\\varepsilon}}^p$ must be non-negative for an admissible evolution under associative flow. The verification algorithm checks this condition at each step.\n\nThe algorithmic logic is as follows:\n1.  For each increment $k$, the plastic work increment is computed using the corrected stress $\\boldsymbol{\\sigma}_{n+1}^{(k)}$ and the plastic strain increment $\\Delta \\boldsymbol{\\varepsilon}^p{}^{(k)}$:\n    $$\n    \\Delta W_p^{(k)} = \\boldsymbol{\\sigma}_{n+1}^{(k)} : \\Delta \\boldsymbol{\\varepsilon}^p{}^{(k)} = \\sum_{i=1}^3 \\sum_{j=1}^3 \\sigma_{n+1,ij}^{(k)} \\,\\Delta \\varepsilon^p{}_{ij}^{(k)}.\n    $$\n2.  The total plastic work, $W_p = \\sum_{k=1}^N \\Delta W_p^{(k)}$, is accumulated over all steps.\n3.  To account for floating-point inaccuracies, a scale-aware relative tolerance is defined for each step:\n    $$\n    \\mathrm{tol}^{(k)} = r_{\\text{tol}}\\;\\|\\boldsymbol{\\sigma}_{n+1}^{(k)}\\|_F\\;\\|\\Delta \\boldsymbol{\\varepsilon}^p{}^{(k)}\\|_F,\n    $$\n    with the given relative tolerance $r_{\\text{tol}} = 10^{-12}$.\n4.  A nonphysical energy gain is flagged if either of two conditions is met:\n    -   A per-step violation: $\\Delta W_p^{(k)}  -\\mathrm{tol}^{(k)}$ for any step $k$.\n    -   A cumulative violation: $W_p  -\\sum_{k=1}^N \\mathrm{tol}^{(k)}$.\n\nAnalyzing the provided test suite with this logic:\n-   **Test Case 1**: The stress and plastic strain tensors at each step produce a strictly positive plastic work increment (e.g., $\\Delta W_p^{(1)} \\approx 470\\;\\mathrm{J/m^3}$). As all $\\Delta W_p^{(k)}$ are positive, no flag is raised.\n-   **Test Case 2**: The stress is isotropic ($\\boldsymbol{\\sigma} = p\\,\\boldsymbol{I}$) and the plastic strain increments are trace-free ($\\mathrm{tr}(\\Delta \\boldsymbol{\\varepsilon}^p{}^{(k)}) = 0$). The plastic work, $\\Delta W_p^{(k)} = p\\,\\mathrm{tr}(\\Delta \\boldsymbol{\\varepsilon}^p{}^{(k)})$, is therefore exactly zero for each step. No flag is raised.\n-   **Test Case 3**: The tensors are constructed such that their double contraction is significantly negative ($\\Delta W_p^{(1)} \\approx -2680\\;\\mathrm{J/m^3}$). This value is far below the negative tolerance, so the per-step check will flag a nonphysical result.\n-   **Test Case 4**: The first step has zero stress and the second has zero plastic strain increment. In both cases, the plastic work increment is exactly zero. No flag is raised.\n\nBased on this analysis, the verification routine will flag an error only for Test Case 3.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef frobenius_norm(mat: np.ndarray) - float:\n    \"\"\"Compute Frobenius norm of a 3x3 matrix.\"\"\"\n    return float(np.linalg.norm(mat, 'fro'))\n\ndef double_contraction(a: np.ndarray, b: np.ndarray) - float:\n    \"\"\"Compute the double contraction a:b for 3x3 matrices.\"\"\"\n    return float(np.sum(a * b))\n\ndef evaluate_case(steps, rtol=1e-12) - bool:\n    \"\"\"\n    Evaluate one test case (sequence of steps), returning True if a nonphysical\n    energy gain is flagged, else False.\n\n    Steps: list of tuples (sigma, deps_p), each 3x3 symmetric arrays.\n    \"\"\"\n    total_wp = 0.0\n    tol_sum = 0.0\n    for sigma, deps_p in steps:\n        ns = frobenius_norm(sigma)\n        ne = frobenius_norm(deps_p)\n        tol = rtol * ns * ne\n        tol_sum += tol\n        dwp = double_contraction(sigma, deps_p)\n        # Step-level check\n        if dwp  -tol:\n            return True\n        total_wp += dwp\n    # Final accumulation check\n    if total_wp  -tol_sum:\n        return True\n    return False\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case is a list of (sigma, deps_p) steps, with 3x3 numpy arrays.\n    test_cases = []\n\n    # Test Case 1: happy path (positive dissipation per step)\n    tc1 = [\n        (\n            np.array([[150e6, 5e6, 0.0],\n                      [5e6, 120e6, 0.0],\n                      [0.0, 0.0, 90e6]]),\n            np.array([[1.0e-5, 2.0e-6, 0.0],\n                      [2.0e-6, -5.0e-6, 0.0],\n                      [0.0, 0.0, -5.0e-6]])\n        ),\n        (\n            np.array([[160e6, 4e6, 1e6],\n                      [4e6, 115e6, 0.5e6],\n                      [1e6, 0.5e6, 85e6]]),\n            np.array([[0.8e-5, 1.0e-6, 0.2e-6],\n                      [1.0e-6, -4.0e-6, 0.1e-6],\n                      [0.2e-6, 0.1e-6, -4.0e-6]])\n        ),\n        (\n            np.array([[165e6, 3e6, 2e6],\n                      [3e6, 110e6, 1e6],\n                      [2e6, 1e6, 80e6]]),\n            np.array([[0.7e-5, 1.5e-6, 0.3e-6],\n                      [1.5e-6, -3.5e-6, 0.2e-6],\n                      [0.3e-6, 0.2e-6, -3.5e-6]])\n        ),\n    ]\n    test_cases.append(tc1)\n\n    # Test Case 2: boundary case (isotropic stress, trace-free plastic strain increments)\n    tc2 = [\n        (\n            np.array([[50e6, 0.0, 0.0],\n                      [0.0, 50e6, 0.0],\n                      [0.0, 0.0, 50e6]]),\n            np.array([[1.0e-6, 0.0, 0.0],\n                      [0.0, -0.5e-6, 0.0],\n                      [0.0, 0.0, -0.5e-6]])\n        ),\n        (\n            np.array([[50e6, 0.0, 0.0],\n                      [0.0, 50e6, 0.0],\n                      [0.0, 0.0, 50e6]]),\n            np.array([[2.0e-6, 0.0, 0.0],\n                      [0.0, -1.0e-6, 0.0],\n                      [0.0, 0.0, -1.0e-6]])\n        ),\n    ]\n    test_cases.append(tc2)\n\n    # Test Case 3: error case (negative dissipation)\n    tc3 = [\n        (\n            np.array([[100e6, 40e6, 0.0],\n                      [40e6, 100e6, 0.0],\n                      [0.0, 0.0, 100e6]]),\n            np.array([[-1.0e-5, 4.0e-6, 0.0],\n                      [4.0e-6, -1.0e-5, 0.0],\n                      [0.0, 0.0, -1.0e-5]])\n        ),\n    ]\n    test_cases.append(tc3)\n\n    # Test Case 4: edge cases (zero stress or zero plastic strain increments)\n    tc4 = [\n        (\n            np.zeros((3, 3)),\n            np.array([[1.0e-6, -0.5e-6, 0.0],\n                      [-0.5e-6, 0.0, 0.0],\n                      [0.0, 0.0, -0.5e-6]])\n        ),\n        (\n            np.array([[80e6, 0.0, 0.0],\n                      [0.0, 80e6, 0.0],\n                      [0.0, 0.0, 80e6]]),\n            np.zeros((3, 3))\n        ),\n    ]\n    test_cases.append(tc4)\n\n    results = []\n    for case in test_cases:\n        flag = evaluate_case(case, rtol=1e-12)\n        results.append(flag)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}