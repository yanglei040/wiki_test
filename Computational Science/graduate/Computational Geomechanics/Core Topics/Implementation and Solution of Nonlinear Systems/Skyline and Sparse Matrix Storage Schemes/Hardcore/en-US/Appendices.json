{
    "hands_on_practices": [
        {
            "introduction": "Understanding the efficiency of a storage scheme begins with quantifying its memory footprint. The skyline storage format is designed to reduce memory usage by storing only the 'profile' of non-zero entries in a symmetric matrix. This first practice provides a direct, hands-on calculation to appreciate these savings by comparing the storage required by the skyline scheme against that of a naive lower-triangular storage method for a given matrix profile .",
            "id": "3559724",
            "problem": "A linear, isotropic, small-strain $3$-dimensional elasticity problem is discretized using the Finite Element (FE) method on a structured mesh, leading to a global stiffness matrix $K \\in \\mathbb{R}^{n \\times n}$. Owing to the symmetry of the elastic energy bilinear form, $K$ is Symmetric Positive Definite (SPD). In a skyline storage scheme, the nonzero structure in each column $j$ is assumed to be contiguous from the diagonal entry in that column down to the first nonzero in that column. Let the skyline height $h_j$ denote, by definition, the count of stored entries in column $j$ in the lower triangular part, including the diagonal entry.\n\nConsider an ordering that yields the following skyline heights for $n=12$: $\\{h_j\\}_{j=1}^{12} = \\{1,\\,2,\\,4,\\,5,\\,6,\\,6,\\,5,\\,5,\\,4,\\,3,\\,2,\\,1\\}$. Using only the symmetry of $K$ and the definition of skyline storage, derive the exact total number of stored floating-point entries under skyline storage and contrast it with the count required to store the entire lower triangle of $K$.\n\nReport the storage reduction factor $R$, defined as the ratio of the skyline storage entry count to the full lower-triangular storage entry count, as a single exact simplified fraction. No rounding is required.",
            "solution": "The problem statement has been validated and is deemed sound. It is a well-posed, self-contained problem grounded in standard principles of computational mechanics and numerical linear algebra. We may proceed with the solution.\n\nThe problem requires us to compute the storage reduction factor $R$ for a given sparse matrix structure. This factor is defined as the ratio of the number of entries stored using a skyline scheme to the number of entries stored in a full lower-triangular representation. The matrix in question is the global stiffness matrix $K \\in \\mathbb{R}^{n \\times n}$, where $n=12$. The matrix $K$ is symmetric, which is the fundamental property that allows for storage-efficient schemes like skyline storage, where only the lower (or upper) triangle, including the diagonal, needs to be stored.\n\nFirst, let us calculate the total number of stored floating-point entries under the specified skyline storage scheme, which we denote by $N_{\\text{sky}}$. The problem defines the skyline height for each column $j$, denoted by $h_j$, as the number of stored entries in that column within the lower triangular part of the matrix, inclusive of the diagonal element $K_{jj}$. The total number of stored entries is therefore the sum of the skyline heights over all columns.\nGiven the dimension $n=12$ and the sequence of skyline heights $\\{h_j\\}_{j=1}^{12} = \\{1,\\,2,\\,4,\\,5,\\,6,\\,6,\\,5,\\,5,\\,4,\\,3,\\,2,\\,1\\}$, the total number of stored entries is:\n$$N_{\\text{sky}} = \\sum_{j=1}^{n} h_j$$\nSubstituting the given values:\n$$N_{\\text{sky}} = 1 + 2 + 4 + 5 + 6 + 6 + 5 + 5 + 4 + 3 + 2 + 1$$\nPerforming the summation:\n$$N_{\\text{sky}} = (1+2+4+5+6) + (6+5+5+4+3+2+1)$$\n$$N_{\\text{sky}} = 18 + 26$$\n$$N_{\\text{sky}} = 44$$\nThus, the skyline storage scheme requires storing $44$ floating-point numbers.\n\nNext, we calculate the number of entries required to store the entire lower triangle of the matrix $K$, including the main diagonal. We denote this count by $N_{\\text{full}}$. For a general $n \\times n$ matrix, the number of elements in the lower triangle is the sum of the lengths of the columns from $j=1$ to $j=n$. The $j$-th column has $j$ elements in the lower triangle (from row $j$ down to row $1$, or, as conventionally indexed, from row $1$ to row $j$ ending at the diagonal $K_{jj}$, for storage purposes). This means we sum the integers from $1$ to $n$.\n$$N_{\\text{full}} = \\sum_{j=1}^{n} j$$\nThis is the sum of an arithmetic progression, given by the formula:\n$$N_{\\text{full}} = \\frac{n(n+1)}{2}$$\nFor the given matrix dimension $n=12$:\n$$N_{\\text{full}} = \\frac{12(12+1)}{2} = \\frac{12 \\times 13}{2} = 6 \\times 13 = 78$$\nSo, storing the full lower triangle of the $12 \\times 12$ matrix requires $78$ floating-point numbers.\n\nFinally, we compute the storage reduction factor $R$, which is defined as the ratio of the skyline storage count to the full lower-triangular storage count.\n$$R = \\frac{N_{\\text{sky}}}{N_{\\text{full}}}$$\nSubstituting the calculated values for $N_{\\text{sky}}$ and $N_{\\text{full}}$:\n$$R = \\frac{44}{78}$$\nTo provide the answer as an exact simplified fraction, we find the greatest common divisor of the numerator and the denominator. Both $44$ and $78$ are even numbers.\n$$R = \\frac{2 \\times 22}{2 \\times 39} = \\frac{22}{39}$$\nThe prime factorization of the numerator is $22 = 2 \\times 11$. The prime factorization of the denominator is $39 = 3 \\times 13$. Since there are no common prime factors, the fraction $\\frac{22}{39}$ is in its simplest form.\n\nThe storage reduction factor $R$ represents the efficiency of the skyline storage scheme for this specific matrix structure compared to a naive storage of the lower triangle. A value of $R  1$ indicates a reduction in storage requirements. Here, $R = \\frac{22}{39} \\approx 0.564$, indicating that the skyline scheme uses approximately $56.4\\%$ of the storage that a full lower-triangular scheme would require.",
            "answer": "$$\\boxed{\\frac{22}{39}}$$"
        },
        {
            "introduction": "While the previous exercise assumed a known skyline profile, in practice, this profile must be determined from the underlying physical model, such as a finite element mesh. This problem asks you to develop an efficient algorithm that computes the skyline heights directly from element connectivity data, a fundamental task in setting up a solver . Mastering this demonstrates a deeper understanding of how matrix structures arise from computational mechanics principles and how to process them efficiently.",
            "id": "3559651",
            "problem": "You are given a global, symmetric, positive definite stiffness matrix arising from a finite element discretization in computational geomechanics. The matrix is not provided explicitly. Instead, you are given only the element-to-global Degree of Freedom (DOF) connectivity. In skyline storage, for each column $j$ (using $1$-based indexing), one stores the diagonal entry and all entries from the lowest nonzero row $r_j$ up to row $j$. The skyline height for column $j$ is $h_j = j - r_j$. Your task is to design and implement an algorithm that computes the full array of skyline heights $\\{h_j\\}_{j=1}^N$ directly from the element connectivity, without first forming a graph adjacency matrix. Ground your algorithm and its correctness in the fundamental law of finite element assembly: each element stiffness matrix contributes nonzeros to the global matrix for all pairs of its local DOFs.\n\nStarting from the foundational fact that a typical finite element with local DOF index set $\\mathcal{G}_e \\subset \\{1,\\dots,N\\}$ contributes nonzero entries $K_{ij}$ for all $i \\in \\mathcal{G}_e$ and $j \\in \\mathcal{G}_e$ (by symmetry, the lower triangle is sufficient), derive a principle-based algorithm to compute $r_j$ for all $j \\in \\{1,\\dots,N\\}$ using only the element connectivity sets. Do not form an adjacency matrix or any explicit graph; reason directly from the assembly rule. Analyze the algorithmic complexity in terms of the number of elements $E$ and the local DOF counts $p_e = |\\mathcal{G}_e|$. Your analysis must include a comparison to a baseline approach that enumerates all element DOF pairs $(i,j)$ with $i \\le j$ to update $r_j$.\n\nYour program must implement the derived algorithm and also compute simple operation counts that reflect the asymptotic complexity. Use the following operation model to make the analysis concrete and testable:\n- Initialize an array of length $N$ for $r_j$ values and set each to $j$: count this as $N$ primitive operations.\n- For each element $e$, let $p_e$ be the number of local DOFs. Compute the minimum DOF $m_e = \\min \\mathcal{G}_e$ using a $p_e$-iteration scan: count this as $p_e$ primitive operations.\n- For each element $e$ and each $j \\in \\mathcal{G}_e$, attempt to update $r_j \\leftarrow \\min(r_j, m_e)$: count this as $p_e$ primitive operations (one per attempt), regardless of whether the value changes.\n- After all elements are processed, compute the skyline heights $h_j = j - r_j$ with a single pass: count this as $N$ primitive operations.\n- Compute the maximum height $\\max_j h_j$ with a single pass: count this as $N$ primitive operations.\n\nFor the baseline pair-enumeration approach, define its operation count as:\n- Initialize an array of length $N$ for $r_j$ values as above: $N$ operations.\n- For each element $e$ with $p_e$ local DOFs, enumerate all lower-triangular pairs $(i,j)$ with $i \\le j$, and perform $r_j \\leftarrow \\min(r_j, i)$: count this as $p_e(p_e+1)/2$ primitive operations.\n- Compute $\\{h_j\\}_{j=1}^N$ and $\\max_j h_j$ each with a pass: $N + N$ operations.\n\nYour program must, for each test case, compute:\n- The skyline heights $h_j$ for all $j \\in \\{1,\\dots,N\\}$.\n- The maximum skyline height $\\max_j h_j$.\n- The bandwidth, defined as $\\max_j h_j + 1$.\n- The total skyline storage length $L = \\sum_{j=1}^N (h_j + 1)$.\n- The measured primitive operation count for your algorithm as specified.\n- The baseline primitive operation count as specified.\n\nYour implementation must not form any adjacency matrix or global sparse matrix. It must compute the skyline heights only from the element connectivity, justified by finite element assembly.\n\nTest suite. Use the following four test cases. Each case is specified by $N$ and a list of element connectivity sets, each being a set of global DOF indices. All indices are $1$-based and lie in $\\{1,\\dots,N\\}$.\n\n- Case A (happy path, chain of overlapping elements): $N = 7$, elements $\\{\\{1,2,3\\},\\{3,4,5\\},\\{5,6,7\\}\\}$.\n- Case B (overlap with varying local sizes): $N = 10$, elements $\\{\\{2,3,5,7\\},\\{1,4,5\\},\\{5,8,9\\},\\{6,9,10\\}\\}$.\n- Case C (single large element, boundary case): $N = 6$, elements $\\{\\{1,2,3,4,5,6\\}\\}$.\n- Case D (disconnected DOFs present, edge case): $N = 8$, elements $\\{\\{2,3\\},\\{5,7\\}\\}$.\n\nFinal output format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with no spaces. Each test case result must itself be a list of six integers in the following order:\n$[N,\\max_j h_j,\\max_j h_j + 1,L,\\text{measured},\\text{baseline}]$.\nTherefore the final printout must look like\n$[[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot]]$\nwith the four case results in the order A, B, C, D.",
            "solution": "The problem is valid as it is scientifically grounded in the principles of the Finite Element Method (FEM), is well-posed with a clear objective and sufficient data, and uses precise, objective language. We can thus proceed with the derivation and implementation of the solution.\n\n### Principle-Based Algorithm Derivation\n\nThe core of the problem is to determine the skyline profile of a global stiffness matrix $K$ directly from the element connectivity data. The matrix $K$ is an $N \\times N$ symmetric, positive definite matrix, where $N$ is the total number of Degrees of Freedom (DOFs).\n\nThe fundamental principle of FEM assembly states that the global stiffness matrix is formed by the summation of element stiffness matrices. A non-zero entry $K_{ij}$ exists in the global matrix if and only if there is at least one element $e$ that couples DOF $i$ and DOF $j$. For a standard element formulation, all DOFs within that element are coupled. Let $\\mathcal{G}_e \\subset \\{1, 2, \\dots, N\\}$ be the set of global DOF indices associated with element $e$. Then, for any two DOFs $i, j \\in \\mathcal{G}_e$, the entry $K_{ij}$ (and $K_{ji}$ by symmetry) receives a non-zero contribution from element $e$'s stiffness matrix. Consequently, $K_{ij} \\neq 0$ if and only if there exists an element $e$ such that $\\{i, j\\} \\subseteq \\mathcal{G}_e$.\n\nThe skyline storage scheme for a column $j$ requires storing all entries from the first non-zero row, $r_j$, up to the diagonal, $j$. The value $r_j$ is formally defined as:\n$$\nr_j = \\min \\{ i \\mid 1 \\le i \\le j \\text{ and } K_{ij} \\neq 0 \\}\n$$\nThe condition $K_{jj} \\neq 0$ (due to positive definiteness) ensures that $r_j$ is well-defined and $r_j \\le j$. Combining the definitions, we can express $r_j$ in terms of element connectivity:\n$$\nr_j = \\min \\left( \\{j\\} \\cup \\{ i \\mid 1 \\le i  j \\text{ and } \\exists e \\text{ s.t. } \\{i, j\\} \\subseteq \\mathcal{G}_e \\} \\right)\n$$\n\n**Baseline Algorithm Analysis**\n\nA straightforward interpretation of this definition leads to the baseline algorithm. We initialize an array for the row indices, let's call it $\\mathbf{r}$, such that $r_j = j$ for all $j \\in \\{1, \\dots, N\\}$. Then, for each element $e$, we iterate through all pairs of DOFs $(i, j) \\in \\mathcal{G}_e \\times \\mathcal{G}_e$ with $i \\le j$. For each such pair, we have a known non-zero entry $K_{ij}$, which implies the row index for column $j$ is at most $i$. We therefore perform the update:\n$$\nr_j \\leftarrow \\min(r_j, i)\n$$\nIf an element has $p_e = |\\mathcal{G}_e|$ DOFs, there are $p_e(p_e+1)/2$ such pairs $(i,j)$ with $i \\le j$. Summing over all $E$ elements, the total number of such updates is $\\sum_{e=1}^E p_e(p_e+1)/2$. The complexity of the core loop is $O(\\sum_e p_e^2)$. The total operation count as per the problem's model is $3N + \\sum_{e=1}^E \\frac{p_e(p_e+1)}{2}$.\n\n**Proposed Algorithm Derivation**\n\nWe can derive a more efficient algorithm by re-examining the update rule from a different perspective. For any given element $e$, it contributes non-zero stiffness terms for all pairs of its DOFs. This means that for any specific DOF $j \\in \\mathcal{G}_e$, it is connected to all other DOFs $i \\in \\mathcal{G}_e$.\n\nLet $m_e = \\min \\mathcal{G}_e$ be the minimum DOF index within element $e$. Since $m_e \\in \\mathcal{G}_e$, it is connected to every other DOF $j \\in \\mathcal{G}_e$. This implies that for each $j \\in \\mathcal{G}_e$, there exists a non-zero entry $K_{m_e, j}$ (assuming $m_e \\le j$) or $K_{j, m_e}$ (assuming $j \\le m_e$). When considering the lower triangle of the matrix for column $j$, the non-zero entry involving $m_e$ will be at row $\\min(j, m_e)$.\n\nCritically, for any column $j \\in \\mathcal{G}_e$, the smallest row index that element $e$ can *possibly* contribute is $m_e$. No other DOF $i \\in \\mathcal{G}_e$ can provide a smaller row index for column $j$, because by definition $m_e \\le i$. Therefore, for every $j \\in \\mathcal{G}_e$, we can update its minimum row index based *only* on the minimum DOF of its parent element:\n$$\nr_j \\leftarrow \\min(r_j, m_e)\n$$\nApplying this update for all $j \\in \\mathcal{G}_e$ and repeating for every element $e$ results in the correct final values for all $r_j$.\n\nThe resulting algorithm proceeds as follows:\n1. Initialize an array $\\mathbf{r}$ of length $N$ such that $r_j = j$ for $j=1, \\dots, N$.\n2. For each element $e=1, \\dots, E$:\n   a. Find the minimum DOF index in the element: $m_e = \\min \\mathcal{G}_e$.\n   b. For each DOF $j \\in \\mathcal{G}_e$, perform the update: $r_j \\leftarrow \\min(r_j, m_e)$.\n3. After processing all elements, compute the skyline heights: $h_j = j - r_j$.\n\n**Complexity Analysis of Proposed Algorithm**\n\nFor each element $e$, this algorithm performs two steps: finding the minimum of $p_e$ DOFs, and then performing $p_e$ updates. Both steps take $O(p_e)$ time. The total work over all $E$ elements is therefore $\\sum_{e=1}^E O(p_e) = O(\\sum_e p_e)$. The overall complexity, including initialization and final computations, is $O(N + \\sum_e p_e)$. The operation count as per the problem's model is $N$ (init) $+ \\sum_e (p_e + p_e)$ (loops) $+ N$ (heights) $+ N$ (max height) $= 3N + 2\\sum_{e=1}^E p_e$.\n\nThis is asymptotically superior to the baseline algorithm's $O(N + \\sum_e p_e^2)$ complexity. The proposed algorithm's cost is linear in the total number of elemental DOFs, whereas the baseline is quadratic in element size. This advantage is significant for high-order finite elements where $p_e$ is large. For small $p_e$ (e.g., $p_e=2$), the baseline can be slightly more efficient as its operation count per element, $p_e(p_e+1)/2$, may be less than the $2 p_e$ count of the proposed method (which includes the cost of finding the minimum). Specifically, $p_e(p_e+1)/2  2p_e$ for $p_e  3$. For $p_e=3$, the counts are equal. For $p_e  3$, the proposed algorithm is superior.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Test suite using 1-based indexing as given in the problem.\n    test_cases_1_based = [\n        {'N': 7, 'elements': [{1, 2, 3}, {3, 4, 5}, {5, 6, 7}]},\n        {'N': 10, 'elements': [{2, 3, 5, 7}, {1, 4, 5}, {5, 8, 9}, {6, 9, 10}]},\n        {'N': 6, 'elements': [{1, 2, 3, 4, 5, 6}]},\n        {'N': 8, 'elements': [{2, 3}, {5, 7}]}\n    ]\n\n    all_results_str = []\n    for case in test_cases_1_based:\n        N = case['N']\n        # Convert 1-based element DOFs to 0-based for numpy array indexing.\n        elements_0_based = [\n            [dof - 1 for dof in sorted(list(elem))] for elem in case['elements']\n        ]\n        result_metrics = compute_skyline_metrics(N, elements_0_based)\n        # Format the individual case result as a string: \"[m1,m2,...,m7]\"\n        result_str = f\"[{','.join(map(str, result_metrics))}]\"\n        all_results_str.append(result_str)\n\n    # Final print statement in the exact required format: \"[[r1],[r2],[r3],[r4]]\"\n    print(f\"[{','.join(all_results_str)}]\")\n\ndef compute_skyline_metrics(N, elements):\n    \"\"\"\n    Computes skyline metrics for a single test case.\n\n    Args:\n        N (int): The total number of Degrees of Freedom (DOFs).\n        elements (list of list of int): A list of element connectivity sets,\n                                        using 0-based indexing.\n\n    Returns:\n        list: A list of integers [N, max_h, bandwidth, L, measured_ops, baseline_ops].\n    \"\"\"\n    if N == 0:\n        return [0, 0, 1, 0, 0, 0]\n\n    # --- Proposed Algorithm Implementation ---\n    \n    # Initialize r_j = j.\n    # In 0-based indexing, this corresponds to r[j] = j for j = 0 to N-1.\n    r = np.arange(N)\n    \n    # Per the problem's operation counting model:\n    # 1. Initialize 'r' array: N operations\n    measured_ops = N\n    \n    p_e_list = []\n    for elem_dofs in elements:\n        p_e = len(elem_dofs)\n        p_e_list.append(p_e)\n        if p_e == 0:\n            continue\n            \n        # 2a. Compute m_e = min(G_e): p_e operations\n        m_e = elem_dofs[0]  # Assumes elements are pre-sorted\n        measured_ops += p_e\n        \n        # 2b. Update r_j for each j in G_e: p_e operations\n        for j in elem_dofs:\n            r[j] = min(r[j], m_e)\n        measured_ops += p_e\n\n    # 3. Compute skyline heights h_j = j - r_j: N operations\n    h = np.arange(N) - r\n    measured_ops += N\n    \n    # 4. Compute max skyline height: N operations\n    if h.size > 0:\n        max_h = int(np.max(h))\n    else:\n        max_h = 0\n    measured_ops += N\n    \n    # --- Calculation of Other Metrics ---\n\n    # Bandwidth = max_h + 1\n    bandwidth = max_h + 1\n    \n    # Total skyline storage length L = sum(h_j + 1)\n    L = int(np.sum(h + 1))\n    \n    # --- Baseline Operation Count Calculation ---\n    \n    # Initialization: N ops\n    baseline_ops = N\n    # Loop over elements: sum(p_e * (p_e + 1) / 2) ops\n    for p_e in p_e_list:\n        baseline_ops += p_e * (p_e + 1) // 2\n    # Final steps: N + N ops\n    baseline_ops += N + N\n\n    return [N, max_h, bandwidth, L, int(measured_ops), int(baseline_ops)]\n\nif __name__ == \"__main__\":\n    solve()\n\n```"
        },
        {
            "introduction": "This final exercise explores the practical trade-offs between skyline and the widely-used Compressed Sparse Row (CSR) format. By implementing a conversion algorithm, you will gain insight into the memory implications of each scheme, specifically the balance between floating-point storage for values and integer storage for indexing information . This is crucial for making informed decisions when choosing a data structure for a particular problem.",
            "id": "3559665",
            "problem": "Consider a linear system arising from the Finite Element Method (FEM) in computational geomechanics, where the assembled global stiffness matrix is assumed to be symmetric and structured, often Symmetric Positive Definite (SPD). Efficient storage is crucial. Two common schemes are skyline profile storage and Compressed Sparse Row (CSR). In skyline storage, for each column $j$ ($0$-based indexing), a contiguous segment of the lower triangle entries from the first stored row in that column up to the diagonal is stored. In Compressed Sparse Row (CSR), a sparse matrix is stored by three arrays: a row pointer array, an array of column indices, and an array of values, with only the structurally nonzero entries recorded.\n\nTask: Construct a mapping algorithm that takes a symmetric matrix stored in skyline format (lower triangle only) and converts it to CSR format for the lower triangle only, while excluding any entries that are numerically zero (i.e., without profile padding). Then, analyze the storage differences by counting the number of floating-point and integer slots required in each format, under the following storage accounting assumptions:\n\n- Skyline storage maintains:\n  - A float array of values of length equal to the sum of the per-column skyline heights.\n  - A single integer pointer array of length $n+1$ that demarcates the starting index of each column segment in the float array.\n- Compressed Sparse Row (CSR) storage for the lower triangle maintains:\n  - A float array of values of length equal to the number of stored lower-triangular nonzeros (after excluding numerical zeros).\n  - A row pointer integer array of length $n+1$.\n  - A column index integer array of length equal to the number of stored lower-triangular nonzeros (after excluding numerical zeros).\n\nBase definitions:\n- A skyline specification for an $n \\times n$ symmetric matrix is given by an integer vector $h \\in \\mathbb{N}^n$, where $h_j$ is the number of stored entries in column $j$ within the lower triangle, including the diagonal. The segment in column $j$ spans rows from $j - h_j + 1$ to $j$ inclusive. The concatenation of all column segments in increasing $j$ order forms the float values array $a$.\n- A CSR specification for the lower triangle is defined by three arrays: $r$ (row pointer), $c$ (column indices), and $v$ (values), constructed row-wise from the lower triangle entries with $i \\leq j$, omitting numerical zeros.\n\nYour implementation should:\n- Accept a set of test cases, each defined by a tuple $\\left(n, h, a\\right)$, where $n$ is the dimension, $h$ is the skyline heights vector, and $a$ is the skyline values array (concatenated by columns from $j = 0$ to $j = n-1$). Use the provided test suite below.\n- Map the skyline-stored lower triangle into CSR for the lower triangle only, dropping entries whose numerical value equals $0$.\n- Compute the following per-test-case metrics:\n  1. The number of lower-triangular nonzeros in CSR, denoted $nnz_{\\mathrm{lower}}$.\n  2. The number of float slots in skyline, denoted $F_{\\mathrm{sky}}$.\n  3. The number of float slots in CSR, denoted $F_{\\mathrm{csr}}$.\n  4. The number of integer slots in skyline, denoted $I_{\\mathrm{sky}}$, taken as $n+1$ (the column start pointer array length).\n  5. The number of integer slots in CSR, denoted $I_{\\mathrm{csr}}$, taken as $(n+1) + nnz_{\\mathrm{lower}}$ (row pointer plus column indices).\n  6. The additional integer slots required by CSR relative to skyline, $\\Delta I = I_{\\mathrm{csr}} - I_{\\mathrm{sky}}$.\n  7. The change in float slots when moving from skyline to CSR, $\\Delta F = F_{\\mathrm{csr}} - F_{\\mathrm{sky}}$.\n\nScientific and algorithmic constraints:\n- All indexing is $0$-based.\n- The matrix is symmetric; only the lower triangle is stored and considered.\n- A numerically zero value in the skyline array $a$ is to be treated as a structural zero and must be excluded from CSR storage.\n\nTest suite (each test case is $\\left(n, h, a\\right)$):\n- Case $1$: $n = 5$, $h = [1,2,3,2,1]$, $a = [4.0, 0.0, 5.0, 1.0, 0.0, 6.0, 2.0, 7.0, 8.0]$.\n- Case $2$: $n = 4$, $h = [1,2,3,4]$, $a = [10.0, 3.0, 9.0, 5.0, 4.0, 8.0, 2.0, 1.0, 6.0, 7.0]$.\n- Case $3$: $n = 4$, $h = [1,1,1,1]$, $a = [11.0, 12.0, 13.0, 14.0]$.\n- Case $4$: $n = 6$, $h = [1,2,1,4,2,1]$, $a = [15.0, 0.0, 10.0, 9.0, 0.0, 5.5, 0.0, 3.3, 0.0, 2.2, 1.1]$.\n\nFinal output format:\nYour program should produce a single line of output containing the per-test-case results aggregated as a comma-separated list enclosed in square brackets, where each test case result is itself a comma-separated list enclosed in square brackets, in the exact order:\n$[nnz_{\\mathrm{lower}}, F_{\\mathrm{sky}}, F_{\\mathrm{csr}}, I_{\\mathrm{sky}}, I_{\\mathrm{csr}}, \\Delta I, \\Delta F]$.\nFor example, the overall output should look like $[[r_1],[r_2],[r_3],[r_4]]$ with no spaces anywhere.",
            "solution": "The user-provided problem has been analyzed and validated.\n\n### Step 1: Extract Givens\n\n-   **System**: A linear system from the Finite Element Method (FEM) with a symmetric, structured global stiffness matrix.\n-   **Storage Schemes**: Skyline profile storage and Compressed Sparse Row (CSR).\n-   **Task**:\n    1.  Construct a mapping algorithm to convert a symmetric matrix from skyline format (lower triangle) to CSR format (lower triangle), excluding numerical zeros.\n    2.  Analyze storage differences by counting floating-point and integer slots.\n-   **Storage Accounting Assumptions**:\n    -   Skyline: $1$ float array for values, $1$ integer array of length $n+1$ for column pointers.\n    -   CSR (lower triangle): $1$ float array for values, $1$ integer row pointer array of length $n+1$, $1$ integer column index array.\n-   **Base Definitions**:\n    -   **Skyline Specification**: An $n \\times n$ symmetric matrix is defined by an integer vector $h \\in \\mathbb{N}^n$ and a float values array $a$.\n        -   $h_j$: Number of stored entries in column $j$ in the lower triangle, including the diagonal.\n        -   The segment in column $j$ spans rows from $j - h_j + 1$ to $j$ inclusive.\n        -   The array $a$ is the concatenation of all column segments.\n    -   **CSR Specification**: Defined by three arrays $r$ (row pointer), $c$ (column indices), and $v$ (values), constructed row-wise from lower triangle entries, omitting numerical zeros.\n-   **Implementation Requirements**:\n    -   Accept test cases as tuples $(n, h, a)$.\n    -   Map skyline (lower triangle) to CSR (lower triangle), dropping numerical zeros.\n    -   Compute metrics: $nnz_{\\mathrm{lower}}$, $F_{\\mathrm{sky}}$, $F_{\\mathrm{csr}}$, $I_{\\mathrm{sky}}$, $I_{\\mathrm{csr}}$, $\\Delta I = I_{\\mathrm{csr}} - I_{\\mathrm{sky}}$, $\\Delta F = F_{\\mathrm{csr}} - F_{\\mathrm{sky}}$.\n-   **Constraints**:\n    -   $0$-based indexing.\n    -   Matrix is symmetric; only the lower triangle is considered.\n    -   Numerical zeros in $a$ are excluded from CSR.\n-   **Test Suite**:\n    -   Case $1$: $n = 5$, $h = [1,2,3,2,1]$, $a = [4.0, 0.0, 5.0, 1.0, 0.0, 6.0, 2.0, 7.0, 8.0]$.\n    -   Case $2$: $n = 4$, $h = [1,2,3,4]$, $a = [10.0, 3.0, 9.0, 5.0, 4.0, 8.0, 2.0, 1.0, 6.0, 7.0]$.\n    -   Case $3$: $n = 4$, $h = [1,1,1,1]$, $a = [11.0, 12.0, 13.0, 14.0]$.\n    -   Case $4$: $n = 6$, $h = [1,2,1,4,2,1]$, $a = [15.0, 0.0, 10.0, 9.0, 0.0, 5.5, 0.0, 3.3, 0.0, 2.2, 1.1]$.\n-   **Output Format**: A single line string `[[r1],[r2],...]` where `r_i` is a comma-separated list of the 7 metrics for test case $i$.\n\n### Step 2: Validate Using Extracted Givens\n\nThe problem statement is assessed against the validation criteria.\n\n-   **Scientific Grounding**: The problem is well-grounded in computational linear algebra and its application in FEM, which is a standard technique in computational geomechanics. Skyline and CSR are established sparse matrix storage formats. The problem is scientifically sound.\n-   **Well-Posedness  Consistency**: There is a potential ambiguity in the problem statement. It states that skyline storage is for the \"lower triangle,\" but then defines the stored segment in column $j$ to span rows from $j - h_j + 1$ to $j$. For any $h_j  1$, this range includes row indices $i  j$, which correspond to the upper triangle. For example, for column $j$ and height $h_j=2$, the rows are $j-1$ and $j$, so the entries are $(j-1, j)$ and $(j, j)$. The entry $(j-1, j)$ is in the upper triangle. This contradicts the \"lower triangle\" descriptor for skyline storage.\n\n    However, this ambiguity can be resolved by adhering to the precise mathematical definition provided over the colloquial descriptor. The standard convention for column-wise skyline storage is indeed for the upper triangle. The problem also specifies that the matrix is symmetric and the target CSR format is for the *lower triangle*. Therefore, the only logical and consistent interpretation is that the provided skyline data represents the upper triangle, and one must leverage the matrix symmetry (i.e., $A_{ij} = A_{ji}$) to construct the CSR representation of the lower triangle. With this interpretation, the problem is well-posed and consistent.\n-   **Objectivity**: The problem is objective, quantitative, and free of subjective statements.\n\n### Step 3: Verdict and Action\n\nThe problem is **valid** under the interpretation that the skyline format definition provided describes the upper triangle, and symmetry is to be used for the conversion to a lower-triangle CSR representation. The solution will proceed based on this interpretation.\n\n### Principle-Based Design of the Solution\n\nThe core of the problem is a format conversion that involves a change in data traversal order (from column-major skyline to row-major CSR) and a transposition of matrix indices (from upper triangle to lower triangle). The solution is designed in three logical stages.\n\n**Stage 1: Deconstruction of Skyline Storage**\n\nThe input is a matrix $A$ of dimension $n \\times n$ stored in the upper-triangular skyline format specified by the height vector $h$ and the value array $a$. The first step is to reconstruct the matrix entry coordinates $(i, j)$ for each value in $a$.\n\nThe values in $a$ are concatenated segments from each column $j=0, \\dots, n-1$. To locate the segment for column $j$, we first compute a column pointer array, let's call it $P_{\\text{sky}}$, of length $n+1$. This is the integer array mentioned in the problem's storage accounting. It is defined by the cumulative sum of the heights:\n$$P_{\\text{sky}}[0] = 0$$\n$$P_{\\text{sky}}[j+1] = P_{\\text{sky}}[j] + h_j = \\sum_{k=0}^{j} h_k \\quad \\text{for } j = 0, \\dots, n-1$$\nThe values for column $j$ are stored in the slice $a[P_{\\text{sky}}[j] : P_{\\text{sky}}[j+1]]$.\n\nFor each column $j$, the height $h_j$ determines the range of row indices stored, from $i_{\\text{start}} = j - h_j + 1$ to $i_{\\text{end}} = j$. We can iterate through each value in the slice of $a$ corresponding to column $j$ and determine its row index $i$. If a value is numerically non-zero, we store the triplet $(i, j, \\text{value})$, which represents an entry $A_{ij}$ in the upper triangle or on the diagonal. This process creates an intermediate coordinate list (COO) of the non-zero entries of the upper triangle.\n\n**Stage 2: Transformation to Lower Triangle and Sorting**\n\nThe goal is to create a CSR representation for the *lower triangle* of the symmetric matrix. Given a non-zero upper-triangular entry $A_{ij}$ (where $i \\le j$) with value $v$, the corresponding lower-triangular entry is $A_{ji}$ with the same value $v$. Therefore, for each triplet $(i, j, v)$ generated in Stage 1, we create a new triplet $(j, i, v)$. This new set of triplets represents the non-zero entries in the lower triangle.\n\nThe CSR format requires entries to be ordered by row. Thus, this list of lower-triangle triplets must be sorted. The primary sort key is the row index, and the secondary sort key is the column index.\n\n**Stage 3: Computation of Storage Metrics**\n\nAfter producing the sorted list of non-zero lower-triangular triplets, we can compute the required metrics. The full construction of the CSR arrays ($r, c, v$) is not strictly necessary for this task, as we only need their intended lengths.\n\nLet $N_{nz}$ be the number of non-zero lower-triangular entries, which is simply the length of the sorted triplet list from Stage 2.\n1.  $nnz_{\\mathrm{lower}} = N_{nz}$.\n2.  $F_{\\mathrm{sky}}$ (float slots in skyline): This is the total number of entries stored in the skyline profile, which is the length of the array $a$. $F_{\\mathrm{sky}} = \\text{length}(a) = \\sum_{j=0}^{n-1} h_j$.\n3.  $F_{\\mathrm{csr}}$ (float slots in CSR): This is the number of non-zero values stored. $F_{\\mathrm{csr}} = N_{nz}$.\n4.  $I_{\\mathrm{sky}}$ (integer slots in skyline): The length of the column pointer array, which is $n+1$.\n5.  $I_{\\mathrm{csr}}$ (integer slots in CSR): The sum of the lengths of the row pointer array ($n+1$) and the column index array ($N_{nz}$). Thus, $I_{\\mathrm{csr}} = (n+1) + N_{nz}$.\n6.  $\\Delta I$ (change in integer slots): $\\Delta I = I_{\\mathrm{csr}} - I_{\\mathrm{sky}} = ((n+1) + N_{nz}) - (n+1) = N_{nz}$.\n7.  $\\Delta F$ (change in float slots): $\\Delta F = F_{\\mathrm{csr}} - F_{\\mathrm{sky}} = N_{nz} - \\text{length}(a)$.\n\nThis algorithmic procedure systematically transforms the data from the given skyline representation to the target CSR representation (conceptually) and calculates the specified storage metrics by comparing the resource requirements of each format. The change in float storage, $\\Delta F$, will be non-positive, reflecting the savings from omitting zero-padded entries in the skyline. The change in integer storage, $\\Delta I$, will be non-negative, reflecting the overhead of storing a column index for each non-zero element in CSR.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef analyze_storage_conversion(n, h, a):\n    \"\"\"\n    Converts a matrix from skyline storage (upper triangle) to CSR (lower triangle)\n    and computes storage metrics.\n\n    Args:\n        n (int): The dimension of the symmetric matrix.\n        h (list of int): The skyline heights vector of length n.\n        a (list of float): The skyline values array.\n\n    Returns:\n        list of int: A list containing the seven computed metrics:\n                     [nnz_lower, F_sky, F_csr, I_sky, I_csr, Delta_I, Delta_F].\n    \"\"\"\n    # Stage 1: Deconstruction of Skyline Storage (Upper Triangle)\n    # The problem defines skyline storage in a column-wise manner for what is\n    # mathematically the upper triangle (rows i = j). We first extract the\n    # non-zero triplets (i, j, value) from this format.\n\n    # Create the skyline column pointer array\n    col_ptr_sky = np.zeros(n + 1, dtype=int)\n    col_ptr_sky[1:] = np.cumsum(h)\n\n    # Extract non-zero triplets (i, j, val) from the upper triangle\n    upper_triplets = []\n    for j in range(n):\n        height = h[j]\n        start_row = j - height + 1\n        for p in range(height):\n            # linear index in the 'a' array\n            k = col_ptr_sky[j] + p\n            val = a[k]\n            if val != 0.0:\n                # row index 'i' for the entry a[k] in column 'j'\n                i = start_row + p\n                upper_triplets.append((i, j, val))\n\n    # Stage 2: Transformation to Lower Triangle\n    # Since the matrix is symmetric, an entry (i, j, val) in the upper triangle\n    # corresponds to an entry (j, i, val) in the lower triangle.\n    # While CSR format requires sorting, we only need the count of non-zeros (nnz)\n    # for the metric calculations, so full sorting is not performed to save computation.\n    # The number of non-zeros remains the same after transposition.\n    nnz_lower = len(upper_triplets)\n\n    # Stage 3: Computation of Storage Metrics\n    \n    # 1. Number of lower-triangular non-zeros in CSR\n    # nnz_lower is already calculated.\n\n    # 2. Number of float slots in skyline\n    F_sky = len(a)\n\n    # 3. Number of float slots in CSR\n    F_csr = nnz_lower\n\n    # 4. Number of integer slots in skyline\n    I_sky = n + 1\n\n    # 5. Number of integer slots in CSR\n    I_csr = (n + 1) + nnz_lower\n\n    # 6. Additional integer slots required by CSR\n    delta_I = I_csr - I_sky\n\n    # 7. Change in float slots\n    delta_F = F_csr - F_sky\n\n    return [nnz_lower, F_sky, F_csr, I_sky, I_csr, delta_I, delta_F]\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results in the required format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        (5, [1, 2, 3, 2, 1], [4.0, 0.0, 5.0, 1.0, 0.0, 6.0, 2.0, 7.0, 8.0]),\n        # Case 2\n        (4, [1, 2, 3, 4], [10.0, 3.0, 9.0, 5.0, 4.0, 8.0, 2.0, 1.0, 6.0, 7.0]),\n        # Case 3\n        (4, [1, 1, 1, 1], [11.0, 12.0, 13.0, 14.0]),\n        # Case 4\n        (6, [1, 2, 1, 4, 2, 1], [15.0, 0.0, 10.0, 9.0, 0.0, 5.5, 0.0, 3.3, 0.0, 2.2, 1.1]),\n    ]\n\n    all_results_str = []\n    for case in test_cases:\n        n, h, a = case\n        result_metrics = analyze_storage_conversion(n, h, a)\n        # Format the individual case result as a string: \"[m1,m2,...,m7]\"\n        result_str = f\"[{','.join(map(str, result_metrics))}]\"\n        all_results_str.append(result_str)\n\n    # Final print statement in the exact required format: \"[[r1],[r2],[r3],[r4]]\"\n    print(f\"[{','.join(all_results_str)}]\")\n\nsolve()\n```"
        }
    ]
}