{
    "hands_on_practices": [
        {
            "introduction": "实践始于一个经典的一维固结问题，这是许多地球力学和传热问题的原型。通过将后向欧拉法应用于此扩散方程，您将练习如何将偏微分方程（PDE）离散化为常微分方程组（ODE），并用隐式方法求解。这个练习的核心是量化数值方法的关键特性：通过与解析解的比较，您不仅将验证该方法的一阶时间精度，还将探索其固有的数值耗散效应。",
            "id": "3525360",
            "problem": "考虑一个厚度为 $H$ 的完全饱和、均质土层，在初始均匀超孔隙水压力 $u_0$ 作用下的单向固结问题，其在 $z=0$ 和 $z=H$ 处为完全排水边界。在小变形、系数恒定和达西流动的假设下，质量守恒和达西定律的结合得出了关于超孔隙水压力 $u(z,t)$ 的扩散方程，其中固结系数 $c_v$ 被视为已知常数。该数学模型是一个初边值问题：求解在 $z\\in[0,H]$，$t\\ge 0$ 上的 $u(z,t)$，使其满足控制方程、初始条件和边界条件。\n\n您的任务是研究后向（隐式）欧拉法在应用于此模型问题时的时程积分精度和数值扩散，该方法是在通过中心有限差分进行空间离散化之后应用的。具体而言，您必须：\n\n1) 从质量守恒和达西定律所蕴含的扩散方程形式出发，使用一个包含 $N$ 个相等分段的均匀空间网格，并对 $z$ 的空间二阶导数使用中心二阶有限差分，推导出从时间层 $t^n$推进到 $t^{n+1}=t^n+\\Delta t$ 的后向欧拉全离散系统。您必须明确指出确定内部节点值向量 $u^{n+1}$ （以 $u^n$ 表示）的线性系统。\n\n2) 对于同一模型问题，推导在排水边界和均匀初始条件 $u(z,0)=u_0$ 下 $u(z,t)$ 的经典傅里叶级数解析解。使用此闭合形式的级数表示来计算任意 $t0$ 时的 $u(z,t)$，并进行充分的截断以确保精度。\n\n3) 实现一个程序，该程序：\n- 在一个有 $N$ 个分段（即 $N+1$ 个节点）的均匀网格上组装中心有限差分算子，施加齐次 Dirichlet 边界条件 $u(0,t)=u(H,t)=0$，并使用后向欧拉法以时间步长 $\\Delta t$ 进行时间推进。\n- 通过计算相对 $L^2$ 误差，将固定最终时间 $t_{\\mathrm{final}}$ 的数值解与解析解进行比较\n$$\nE(\\Delta t;N) \\equiv \\frac{\\left(\\int_0^H \\left[u_{\\mathrm{num}}(z,t_{\\mathrm{final}})-u_{\\mathrm{exact}}(z,t_{\\mathrm{final}})\\right]^2\\,\\mathrm{d}z\\right)^{1/2}}{\\left(\\int_0^H \\left[u_{\\mathrm{exact}}(z,t_{\\mathrm{final}})\\right]^2\\,\\mathrm{d}z\\right)^{1/2}},\n$$\n该积分在所选网格上使用梯形法则进行近似。\n- 通过计算最小二乘斜率来量化观测到的时间误差相对于 $\\Delta t$ 的衰减率\n$$\np \\equiv \\operatorname{slope}\\left(\\log E \\text{ vs. } \\log \\Delta t\\right),\n$$\n计算是在固定 $N$ 和固定 $t_{\\mathrm{final}}$ 的情况下，在一系列加密的时间步长上进行的。在空间误差占主导地位之前，后向欧拉法的期望值约为 $p\\approx 1$。\n- 通过将最终解投影到基频正弦模态 $\\sin\\!\\left(\\pi z/H\\right)$ 上，并报告比率\n$$\nR \\equiv \\frac{A_{1,\\mathrm{num}}(t_{\\mathrm{final}})}{A_{1,\\mathrm{exact}}(t_{\\mathrm{final}})},\n$$\n来量化后向欧拉法相对于解析解的数值扩散，其中\n$\nA_{1,\\mathrm{num}}(t) \\equiv \\frac{2}{H}\\int_0^H u_{\\mathrm{num}}(z,t)\\,\\sin\\!\\left(\\pi z/H\\right)\\,\\mathrm{d}z\n$\n通过梯形法则计算，并且\n$\nA_{1,\\mathrm{exact}}(t) \\equiv \\frac{4u_0}{\\pi}\\exp\\!\\left(-\\pi^2 c_v t/H^2\\right).\n$\n值 $R1$ 反映了后向欧拉法在有限 $\\Delta t$ 下引入的过度扩散。\n\n使用以下测试套件。在所有情况下，取 $H=1.0\\,\\mathrm{m}$，$c_v=1.0\\times 10^{-6}\\,\\mathrm{m}^2/\\mathrm{s}$，以及 $u_0=1.0\\,\\mathrm{Pa}$。最终时间由无量纲时间因子 $T_v \\equiv c_v t_{\\mathrm{final}}/H^2$ 指定。对于每个测试用例，使用指定的空间分段数 $N$ 并通过为所提供列表中的每个 $M$ 设置 $\\Delta t = t_{\\mathrm{final}}/M$ 来执行时间步长加密。对于数值扩散比 $R$，报告为最粗糙的时间步长（即列表中最小的 $M$）计算的值。\n\n- 测试用例 A (理想路径):\n  - $T_v = 0.2$, $N=400$, $M\\in\\{100,200,400,800\\}$。\n- 测试用例 B (受空间误差影响):\n  - $T_v = 0.2$, $N=40$, $M\\in\\{100,200,400,800\\}$。\n- 测试用例 C (更长的最终时间):\n  - $T_v = 0.8$, $N=400$, $M\\in\\{400,800,1600,3200\\}$。\n\n实现要求：\n- 三角函数内部的角度以弧度为单位。\n- 所有物理参数（$H$、$c_v$、$t_{\\mathrm{final}}$、$\\Delta t$）必须使用国际单位制（SI）处理。输出量 $p$ 和 $R$ 是无量纲的。您的程序必须只输出无量纲数。\n- 使用足够截断的傅里叶级数来表示解析解，以使对于给定的测试套件，截断误差相对于离散化误差可以忽略不计。在您的代码注释中清楚地记录您使用的任何截断策略。\n- 在空间网格上使用梯形法则来近似所有空间积分。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含结果，格式为一个逗号分隔的包含三个双元素列表的列表，每个测试用例一个，顺序为 A、B、C。每个双元素列表必须按此顺序包含 $p$ 和 $R$。每个浮点数打印小数点后恰好六位数字。确切要求的格式是：\n$$\n\\texttt{[[p\\_A,R\\_A],[p\\_B,R\\_B],[p\\_C,R\\_C]]}\n$$\n该行中任何地方都没有空格。\n\n您的程序必须是完全自包含的，并且不能要求任何输入。它必须在内部为指定的测试套件计算所有必需的量，并以上述确切格式打印最终结果。输出值 $p$ 和 $R$ 必须是实数（浮点数）。",
            "solution": "该问题是有效的，因为它在科学上基于固结理论，在数学上是适定的、客观的，并为其求解提供了一套完整且一致的数据和指令。\n\n### 第1部分：后向欧拉全离散系统的推导\n\n一维固结的控制偏微分方程（PDE）是关于超孔隙水压力 $u(z,t)$ 的扩散方程：\n$$\n\\frac{\\partial u}{\\partial t} = c_v \\frac{\\partial^2 u}{\\partial z^2}\n$$\n该方程在 $z \\in (0, H)$ 和 $t  0$ 时成立。初始条件为 $u(z,0) = u_0$，边界条件为 $u(0,t) = 0$ 和 $u(H,t) = 0$。\n\n为了构建数值解，我们首先将空间域 $[0, H]$ 离散化为 $N$ 个长度为 $\\Delta z = H/N$ 的相等分段。这定义了一个包含 $N+1$ 个点 $z_j = j \\Delta z$（其中 $j=0, 1, \\dots, N$）的网格。令 $u_j(t)$ 表示 $u(z_j, t)$ 的数值近似。在内部节点 $z_j$ （其中 $j=1, \\dots, N-1$）处的空间二阶导数使用二阶精度的中心有限差分进行近似：\n$$\n\\frac{\\partial^2 u}{\\partial z^2}\\bigg|_{z=z_j} \\approx \\frac{u_{j-1}(t) - 2u_j(t) + u_{j+1}(t)}{(\\Delta z)^2}\n$$\n将此近似代入PDE，将其转换为一个由 $N-1$ 个耦合常微分方程（ODE）组成的系统，每个内部节点对应一个方程：\n$$\n\\frac{d u_j}{d t} = \\frac{c_v}{(\\Delta z)^2} \\left( u_{j-1}(t) - 2u_j(t) + u_{j+1}(t) \\right), \\quad j=1, \\dots, N-1\n$$\n边界条件意味着对于所有 $t \\ge 0$，$u_0(t)=0$ 和 $u_N(t)=0$。\n\n接下来，我们对时间域进行离散化。令 $t^n = n \\Delta t$（其中 $n=0, 1, 2, \\dots$），$\\Delta t$ 是时间步长。令 $u_j^n$ 为 $u(z_j, t^n)$ 的近似值。我们使用后向（隐式）欧拉法，它在未来的时间层 $t^{n+1}$ 处近似时间导数：\n$$\n\\frac{d u_j}{d t}\\bigg|_{t=t^{n+1}} \\approx \\frac{u_j^{n+1} - u_j^n}{\\Delta t}\n$$\n将此应用于ODE系统，并在时间层 $n+1$ 处计算空间导数项，得到全离散格式：\n$$\n\\frac{u_j^{n+1} - u_j^n}{\\Delta t} = \\frac{c_v}{(\\Delta z)^2} \\left( u_{j-1}^{n+1} - 2u_j^{n+1} + u_{j+1}^{n+1} \\right)\n$$\n为了确定新时间步的未知值 $u_j^{n+1}$，我们重新整理方程，将所有涉及 $u^{n+1}$ 的项放在左侧，将已知的 $u^n$ 项放在右侧。\n$$\nu_j^{n+1} - \\frac{c_v \\Delta t}{(\\Delta z)^2} \\left( u_{j-1}^{n+1} - 2u_j^{n+1} + u_{j+1}^{n+1} \\right) = u_j^n\n$$\n定义无量纲傅里叶数（或扩散数）$\\alpha = \\frac{c_v \\Delta t}{(\\Delta z)^2}$，则每个内部节点 $j$ 的方程变为：\n$$\n-\\alpha u_{j-1}^{n+1} + (1 + 2\\alpha) u_j^{n+1} - \\alpha u_{j+1}^{n+1} = u_j^n\n$$\n这构成了一个包含 $N-1$ 个线性代数方程的系统。令 $\\mathbf{u}^{n+1} = [u_1^{n+1}, u_2^{n+1}, \\dots, u_{N-1}^{n+1}]^T$ 为时间 $t^{n+1}$ 的未知节点值向量，$\\mathbf{u}^{n}$ 为 $t^n$ 的已知值向量，则该系统可以写成矩阵形式：\n$$\n\\mathbf{B} \\, \\mathbf{u}^{n+1} = \\mathbf{u}^{n}\n$$\n这里，$\\mathbf{B}$ 是一个 $(N-1) \\times (N-1)$ 的对称三对角矩阵，必须对其进行求逆（或求解一个系统）以推进解。其元素由下式给出：\n$$\n\\mathbf{B}_{ij} =\n\\begin{cases}\n1 + 2\\alpha  \\text{若 } i = j \\\\\n-\\alpha  \\text{若 } |i - j| = 1 \\\\\n0  \\text{其他情况}\n\\end{cases}\n$$\n在每个时间步，求解这个线性系统以得到 $\\mathbf{u}^{n+1}$。\n\n### 第2部分：解析解\n\n该初边值问题的解析解可以通过分离变量法推导。我们假设解的形式为 $u(z,t) = Z(z)T(t)$。将此代入PDE并分离变量，得到两个由分离常数（我们记为 $-\\lambda^2$）联系起来的ODE：\n$$\nZ''(z) + \\lambda^2 Z(z) = 0 \\quad \\text{和} \\quad T'(t) + c_v \\lambda^2 T(t) = 0\n$$\n关于 $Z(z)$ 的空间方程，连同边界条件 $Z(0)=0$ 和 $Z(H)=0$，构成一个Sturm-Liouville问题。其解是特征函数 $Z_m(z) = \\sin(\\lambda_m z)$，对应的特征值为 $\\lambda_m = \\frac{m\\pi}{H}$，其中 $m = 1, 2, 3, \\dots$ 是正整数。对于每个特征值，相应的时间解为 $T_m(t) = \\exp(-c_v \\lambda_m^2 t)$。\n\n通解是这些基本解的叠加，形成一个傅里叶级数：\n$$\nu(z,t) = \\sum_{m=1}^{\\infty} B_m \\sin\\left(\\frac{m\\pi z}{H}\\right) \\exp\\left(-\\frac{c_v m^2 \\pi^2 t}{H^2}\\right)\n$$\n傅里叶系数 $B_m$ 由初始条件 $u(z,0) = u_0$ 确定。利用正弦函数在区间 $[0,H]$ 上的正交性，我们发现：\n$$\nB_m = \\frac{2}{H} \\int_0^H u_0 \\sin\\left(\\frac{m\\pi z}{H}\\right) dz = \\frac{2u_0}{m\\pi}\\left(1 - \\cos(m\\pi)\\right)\n$$\n当 $m$ 为奇数时，该式值为 $B_m = \\frac{4u_0}{m\\pi}$；当 $m$ 为偶数时，$B_m = 0$。因此，最终的解析解为：\n$$\nu_{\\mathrm{exact}}(z,t) = \\sum_{k=0}^{\\infty} \\frac{4u_0}{(2k+1)\\pi} \\sin\\left(\\frac{(2k+1)\\pi z}{H}\\right) \\exp\\left(-\\frac{c_v (2k+1)^2 \\pi^2 t}{H^2}\\right)\n$$\n\n### 第3部分：计算策略\n\n实现过程首先定义一个辅助函数，用于执行单个测试用例的模拟和分析。该函数接受参数 $T_v$、$N$ 和 $M$ 值列表作为输入。\n1.  **初始化**：计算 $t_{\\mathrm{final}}$、$\\Delta z$ 和空间网格 $z$。还定义一个函数，通过对其截断的傅里叶级数求和来计算解析解。截断点选择得足够大（例如100项），以确保级数截断误差可以忽略不计。\n2.  **时间步长加密循环**：该函数遍历指定的 $M$ 值。在每次迭代中：\n    *   计算 $\\Delta t = t_{\\mathrm{final}}/M$。\n    *   通过将内部节点值初始化为 $u_0$，然后向前推进 $M$ 次来计算数值解。在每个步骤中，使用SciPy库中的带状矩阵求解器高效地求解三对角系统 $\\mathbf{B} \\mathbf{u}^{n+1} = \\mathbf{u}^{n}$。\n    *   将最终的数值解 $u_{\\mathrm{num}}(z, t_{\\mathrm{final}})$ 与解析解 $u_{\\mathrm{exact}}(z, t_{\\mathrm{final}})$ 进行比较。\n    *   使用梯形法则计算积分，从而计算相对 $L^2$ 误差 $E$，并存储 $E$ 和 $\\Delta t$ 的对数。\n    *   对于第一个（最粗糙的）时间步，计算数值扩散比 $R$。这涉及使用梯形法则计算数值解在基频正弦模态上的投影，并除以已知的解析振幅。\n3.  **后处理**：循环结束后，通过对收集的 $\\log E$ 对 $\\log \\Delta t$ 数据点进行线性最小二乘拟合来确定时间收敛率 $p$。该函数返回计算出的 $p$ 和 $R$ 值。\n4.  **主执行部分**：程序的主体部分定义了三个测试用例，并为每个用例调用辅助函数。然后收集结果并将其格式化为所需的单行字符串输出。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef run_case(Tv, N, M_list, H, cv, u0):\n    \"\"\"\n    Runs a single test case for the 1D consolidation problem.\n\n    Args:\n        Tv (float): Dimensionless time factor.\n        N (int): Number of spatial segments.\n        M_list (list of int): List of time step counts for refinement study.\n        H (float): Layer thickness.\n        cv (float): Consolidation coefficient.\n        u0 (float): Initial excess pore pressure.\n\n    Returns:\n        tuple: (p, R), where p is the temporal convergence rate and R is the \n               numerical diffusion ratio for the coarsest time step.\n    \"\"\"\n    t_final = Tv * H**2 / cv\n    dz = H / N\n    z_grid = np.linspace(0, H, N + 1)\n\n    log_E_list = []\n    log_dt_list = []\n    R_case = 0.0\n\n    def u_exact(z_vec, t):\n        \"\"\"\n        Computes the analytical solution using a truncated Fourier series.\n        The series converges rapidly for t  0. Using 100 terms is\n        sufficiently accurate for the parameters in this problem.\n        \"\"\"\n        num_terms = 100 \n        sol = np.zeros_like(z_vec, dtype=float)\n        for k in range(num_terms):\n            m = 2 * k + 1\n            exp_term = np.exp(-cv * (m * np.pi / H)**2 * t)\n            term = (4 * u0 / (m * np.pi)) * np.sin(m * np.pi * z_vec / H) * exp_term\n            sol += term\n        return sol\n\n    for i, M in enumerate(M_list):\n        dt = t_final / M\n        \n        # --- Numerical Solution using Backward Euler ---\n        # Initial condition for interior nodes\n        u_n = u0 * np.ones(N - 1)\n        \n        alpha = cv * dt / dz**2\n        \n        # Setup the tridiagonal matrix B for the system B*u_n+1 = u_n\n        # using the format required by scipy.linalg.solve_banded\n        ab = np.zeros((3, N - 1))\n        ab[0, 1:] = -alpha      # Super-diagonal\n        ab[1, :] = 1 + 2 * alpha  # Main diagonal\n        ab[2, :-1] = -alpha     # Sub-diagonal\n        \n        # Time-stepping loop\n        for _ in range(M):\n            u_n = solve_banded((1, 1), ab, u_n, check_finite=False)\n            \n        # Reconstruct full solution vector including boundaries\n        u_num_final = np.concatenate(([0], u_n, [0]))\n        \n        # --- Analytical Solution ---\n        u_exact_final = u_exact(z_grid, t_final)\n        \n        # --- Error Calculation ---\n        integrand_num = (u_num_final - u_exact_final)**2\n        integrand_den = u_exact_final**2\n        \n        # Use trapezoidal rule for L2 norm approximation\n        L2_norm_diff = np.sqrt(np.trapz(integrand_num, z_grid))\n        L2_norm_exact = np.sqrt(np.trapz(integrand_den, z_grid))\n        \n        # Avoid division by zero if exact solution is zero (not the case here)\n        E = L2_norm_diff / L2_norm_exact if L2_norm_exact  0 else 0.0\n\n        log_E_list.append(np.log(E))\n        log_dt_list.append(np.log(dt))\n        \n        # --- Numerical Diffusion Ratio R (for coarsest time step) ---\n        if i == 0:\n            # A_1_num: Projection of numerical solution onto the fundamental mode\n            integrand_A1_num = u_num_final * np.sin(np.pi * z_grid / H)\n            A1_num = (2.0 / H) * np.trapz(integrand_A1_num, z_grid)\n            \n            # A_1_exact: Analytical amplitude of the fundamental mode\n            A1_exact = (4.0 * u0 / np.pi) * np.exp(-np.pi**2 * Tv)\n            \n            R_case = A1_num / A1_exact\n\n    # --- Convergence Rate p ---\n    # Calculate slope of log(E) vs log(dt) using least squares (polyfit)\n    p = np.polyfit(log_dt_list, log_E_list, 1)[0]\n    \n    return p, R_case\n\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final result.\n    \"\"\"\n    # Global parameters\n    H = 1.0  # m\n    cv = 1.0e-6 # m^2/s\n    u0 = 1.0   # Pa\n\n    # Test suite definition\n    test_cases = [\n        # (Tv, N, M_list)\n        (0.2, 400, [100, 200, 400, 800]),      # Test Case A\n        (0.2, 40, [100, 200, 400, 800]),       # Test Case B\n        (0.8, 400, [400, 800, 1600, 3200]),    # Test Case C\n    ]\n\n    results = []\n    for Tv, N, M_list in test_cases:\n        p, R = run_case(Tv, N, M_list, H, cv, u0)\n        results.append(f\"[{p:.6f},{R:.6f}]\")\n\n    # Print the final output in the exact required format\n    print(f\"[{','.join(results)}]\")\n\n# Execute the solution\nsolve()\n\n```"
        },
        {
            "introduction": "从线性问题过渡到非线性领域，我们来研究一个描述颗粒柱坍塌的简化但极具代表性的非线性常微分方程（ODE）。这个问题的刚度（stiffness）会随着状态变量趋近于零而变得无穷大，这对数值方法提出了严峻的挑战。通过此练习，您将亲眼见证显式的前向欧拉法如何轻易地破坏物理约束（例如，孔隙比不能为负），而隐式的后向欧拉法却能自然地保持这种约束，从而揭示了隐式方法在鲁棒性方面的深刻优势。",
            "id": "3525390",
            "problem": "考虑一个用于模拟快速颗粒柱坍塌过程中压实现象的无量纲集总模型。设状态变量为孔隙比 $e(t)$，其物理上允许的约束为 $e(t) \\ge 0$。假设压实过程主要由刚性摩擦流变特性主导，在集总模型层面，该过程由以下一阶常微分方程 (ODE) 表示：\n$$\n\\frac{de}{dt} = - \\sigma \\sqrt{e(t)}, \\quad t \\in [0,T], \\quad e(0) = e_0,\n$$\n其中 $\\sigma  0$ 是一个无量纲参数，用于表征颗粒骨架中摩擦阻力的强度。该常微分方程是良定义的，并且对于任意非负初始条件 $e_0 \\ge 0$，都存在非负的精确解。所有量均为无量纲，无需物理单位。\n\n您的任务是：\n- 从第一性原理出发，推导该常微分方程在区间 $[0,T]$ 上，从初始条件 $e(0) = e_0$ 开始并满足不等式约束 $e(t) \\ge 0$ 的解析解 $e(t)$。\n- 在 $[0,T]$ 上实现两种时间积分格式：\n  - 前向欧拉法 (Forward Euler, FE)，一种显式单步法。\n  - 后向欧拉法 (Backward Euler, BE)，一种隐式单步法，在每个时间步需要求解一个标量非线性方程。\n- 使用一个恒定的名义步长 $\\Delta t$，并将 $[0,T]$ 划分为多个子步，使得每个子步的步长 $h$ 满足 $0  h \\le \\Delta t$，并且最后一步恰好在 $T$ 结束（即，如果 $T - t  \\Delta t$，则最后一步的步长为 $h = T - t$）。\n- 在显式 FE 更新中，不对状态变量施加任何临时的投影或钳位操作：如果显式更新导致离散状态 $e_n$ 变为负值，应允许其发生。但是，为避免未定义的计算，当从一个 $e_n  0$ 的状态开始计算右侧项时，应将平方根计算为 $\\sqrt{\\max(e_n,0)}$。\n- 在隐式 BE 更新中，每一步都应精确且唯一地求解下一个状态 $e_{n+1}$，不进行任何人为的投影。您可以使用任何数学上正确的方法来求解这个标量非线性方程。\n- 对每次模拟，计算：\n  1. 一个布尔标志，指示离散 FE 轨迹是否曾违反约束，即是否存在任何步骤使得 $e_n  0$。\n  2. 一个布尔标志，指示离散 BE 轨迹是否曾违反约束，即是否存在任何步骤使得 $e_n  0$。\n  3. FE 在最终时刻的绝对误差，定义为 $|e_{\\text{FE}}(T) - e_{\\text{exact}}(T)|$。\n  4. BE 在最终时刻的绝对误差，定义为 $|e_{\\text{BE}}(T) - e_{\\text{exact}}(T)|$。\n\n测试套件。对以下参数集 $(e_0,\\sigma,T,\\Delta t)$ 运行上述过程：\n- 情况 A（理想路径，精细时间步长）：$(e_0,\\sigma,T,\\Delta t) = (\\,1.0,\\,10.0,\\,0.1,\\,0.01\\,)$。\n- 情况 B（粗略步长，引发显式不稳定性及约束违反）：$(e_0,\\sigma,T,\\Delta t) = (\\,1.0,\\,10.0,\\,0.3,\\,0.15\\,)$。\n- 情况 C（边界情况，精确解在 $T$ 时刻达到零，且显式格式恰好落在约束上）：$(e_0,\\sigma,T,\\Delta t) = (\\,1.0,\\,10.0,\\,0.2,\\,0.1\\,)$。\n- 情况 D（非常粗略的单步积分，突显鲁棒性与准确性的对比）：$(e_0,\\sigma,T,\\Delta t) = (\\,1.0,\\,10.0,\\,0.2,\\,0.2\\,)$。\n\n要求的最终输出格式。您的程序应生成单行输出，其中包含一个逗号分隔的扁平列表，对于 A、B、C、D 中的每种情况，按顺序包含四元组 $[\\text{FE\\_violated},\\text{BE\\_violated},\\text{FE\\_abs\\_err},\\text{BE\\_abs\\_err}]$。\n因此，最终输出有 $16$ 个条目，排序如下：\n$$\n[\\text{A:FE\\_violated},\\text{A:BE\\_violated},\\text{A:FE\\_abs\\_err},\\text{A:BE\\_abs\\_err},\\ldots,\\text{D:FE\\_violated},\\text{D:BE\\_violated},\\text{D:FE\\_abs\\_err},\\text{D:BE\\_abs\\_err}].\n$$\n所有布尔值必须打印为 $\\text{True}$ 或 $\\text{False}$，所有误差必须打印为十进制数。您的程序必须是自包含的，并且不需要用户输入。该单行输出必须严格按照 Python 列表字面量的形式打印，例如，对于一种情况，输出为 $[\\text{True},\\text{False},0.123,0.045]$（但您的程序必须按规定汇总所有四种情况）。",
            "solution": "问题陈述已经过验证，被认为是有效的。它具有科学依据、良定、客观，并包含推导出唯一且可验证解所需的所有必要信息。\n\n任务是分析描述颗粒压实集总模型的一阶常微分方程 (ODE)，该方程由下式给出：\n$$\n\\frac{de}{dt} = - \\sigma \\sqrt{e(t)}, \\quad t \\in [0,T]\n$$\n其初始条件为 $e(0) = e_0 \\ge 0$，物理约束为 $e(t) \\ge 0$。参数 $\\sigma  0$ 是一个常数。我们将首先推导解析解，然后构建前向和后向欧拉数值格式，最后实现这些格式来解决指定的测试用例。\n\n### 1. 解析解\n\n该常微分方程是一个可分离的非线性方程。对于 $e(t)  0$，我们可以分离变量 $e$ 和 $t$：\n$$\n\\frac{de}{\\sqrt{e}} = -\\sigma \\, dt\n$$\n我们从初始状态 $(0, e_0)$ 到一般状态 $(t, e(t))$ 对两边进行积分：\n$$\n\\int_{e_0}^{e(t)} u^{-1/2} \\, du = \\int_0^t -\\sigma \\, ds\n$$\n计算积分得出：\n$$\n[2\\sqrt{u}]_{e_0}^{e(t)} = [-\\sigma s]_0^t\n$$\n$$\n2\\sqrt{e(t)} - 2\\sqrt{e_0} = -\\sigma t\n$$\n求解 $\\sqrt{e(t)}$，我们得到：\n$$\n\\sqrt{e(t)} = \\sqrt{e_0} - \\frac{\\sigma t}{2}\n$$\n由于左侧的 $\\sqrt{e(t)}$ 必须为非负值，所以此表达式仅在右侧也为非负值时有效。该条件在 $t \\le t^*$ 时成立，其中 $t^*$ 是孔隙比达到零的时刻：\n$$\n\\sqrt{e_0} - \\frac{\\sigma t^*}{2} = 0 \\implies t^* = \\frac{2\\sqrt{e_0}}{\\sigma}\n$$\n对于 $t \\le t^*$，我们可以对两边进行平方以求得 $e(t)$：\n$$\ne(t) = \\left(\\sqrt{e_0} - \\frac{\\sigma t}{2}\\right)^2\n$$\n对于 $t  t^*$，孔隙比不能变为负值。一旦 $e$ 达到 $0$，其导数 $\\frac{de}{dt} = -\\sigma \\sqrt{0}$ 变为 $0$，因此孔隙比保持为 $0$。所以，完整的解析解是：\n$$\ne(t) = \\begin{cases} \\left(\\sqrt{e_0} - \\frac{\\sigma t}{2}\\right)^2  \\text{if } t \\le \\frac{2\\sqrt{e_0}}{\\sigma} \\\\ 0  \\text{if } t  \\frac{2\\sqrt{e_0}}{\\sigma} \\end{cases}\n$$\n这可以紧凑地表示为 $e(t) = \\left( \\max\\left(0, \\sqrt{e_0} - \\frac{\\sigma t}{2}\\right) \\right)^2$。\n\n### 2. 数值格式\n\n我们将时间区间 $[0,T]$ 离散化为多个步。设 $e_n$ 是 $e(t_n)$ 的数值近似。从 $t_n$ 到 $t_{n+1}$ 的步长为 $h = t_{n+1} - t_n$。问题指定了一种时间步进策略，其中对于名义步长 $\\Delta t$，有 $h = \\min(\\Delta t, T-t_n)$。\n\n#### 前向欧拉法 (FE)\n前向欧拉法是一种显式单步格式。其更新规则源自于在 $t_n$ 附近的一阶泰勒展开：\n$$\ne_{n+1} = e_n + h \\frac{de}{dt}\\bigg|_{t_n} = e_n + h f(e_n)\n$$\n对于我们特定的常微分方程，$f(e_n)=-\\sigma\\sqrt{e_n}$。问题指定了一种修改方式，以处理数值格式可能产生的潜在 $e_n$ 负值：\n$$\ne_{n+1} = e_n - h \\sigma \\sqrt{\\max(0, e_n)}\n$$\n这是一个显式更新，因为 $e_{n+1}$ 是直接从已知状态 $e_n$ 计算得出的。该格式的稳定性是有条件的。线性化稳定性分析表明，步长 $h$ 必须满足 $h \\le \\frac{4\\sqrt{e_n}}{\\sigma}$ 以避免振荡和非物理的负解。如果违反此条件，$e_{n+1}$ 可能变为负值，从而违反物理约束 $e(t) \\ge 0$。模拟需要追踪是否发生了这种违反。\n\n#### 后向欧拉法 (BE)\n后向欧拉法是一种隐式单步格式。其更新规则是：\n$$\ne_{n+1} = e_n + h \\frac{de}{dt}\\bigg|_{t_{n+1}} = e_n + h f(e_{n+1})\n$$\n对于我们的常微分方程，这给出了一个关于 $e_{n+1}$ 的非线性代数方程：\n$$\ne_{n+1} = e_n - h \\sigma \\sqrt{e_{n+1}}\n$$\n为了求解 $e_{n+1}$，令 $x = \\sqrt{e_{n+1}}$。由于我们寻求 $e_{n+1} \\ge 0$，因此必须有 $x \\ge 0$。该方程变为关于 $x$ 的一个二次方程：\n$$\nx^2 + h\\sigma x - e_n = 0\n$$\n对 $x$ 应用二次方程求根公式：\n$$\nx = \\frac{-h\\sigma \\pm \\sqrt{(h\\sigma)^2 - 4(1)(-e_n)}}{2} = \\frac{-h\\sigma \\pm \\sqrt{(h\\sigma)^2 + 4e_n}}{2}\n$$\n由于 $x$ 必须为非负，并且假设该格式保持正性（$e_n \\ge 0$），我们必须选择正根：\n$$\n\\sqrt{e_{n+1}} = x = \\frac{-h\\sigma + \\sqrt{(h\\sigma)^2 + 4e_n}}{2}\n$$\n对于任何 $h  0$、$\\sigma  0$ 和 $e_n \\ge 0$，这个 $x$ 的解总是实数且非负的，因为判别式 $(h\\sigma)^2 + 4e_n$ 是非负的，并且 $\\sqrt{(h\\sigma)^2 + 4e_n} \\ge \\sqrt{(h\\sigma)^2} = h\\sigma$。\n因此，从 $e_0 \\ge 0$ 开始，BE 格式保证对所有 $n \\ge 0$ 都有 $e_n \\ge 0$。此性质被称为无条件保正性。对于此问题，BE 方法永远不会违反物理约束。$e_{n+1}$ 的更新通过对 $x$ 平方得到：\n$$\ne_{n+1} = \\left(\\frac{-h\\sigma + \\sqrt{(h\\sigma)^2 + 4e_n}}{2}\\right)^2\n$$\n这在每一步都提供了一个精确、唯一且物理上允许的解，无需迭代。\n\n下面的 Python 实现将对四个测试用例执行这些格式，并计算所需的度量指标：指示约束违反的布尔标志和在最终时刻 $T$ 的绝对误差。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run simulations for all test cases and print the results.\n    \"\"\"\n    # Test Suite: (e0, sigma, T, dt_nominal)\n    test_cases = [\n        # Case A (happy path, fine time step)\n        (1.0, 10.0, 0.1, 0.01),\n        # Case B (coarse step inducing explicit instability)\n        (1.0, 10.0, 0.3, 0.15),\n        # Case C (boundary case where exact solution reaches zero)\n        (1.0, 10.0, 0.2, 0.1),\n        # Case D (very coarse single-step integration)\n        (1.0, 10.0, 0.2, 0.2),\n    ]\n\n    results = []\n    for params in test_cases:\n        case_results = run_simulation(*params)\n        results.extend(case_results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_simulation(e0, sigma, T, dt_nominal):\n    \"\"\"\n    Performs a single simulation for a given parameter set.\n\n    Args:\n        e0 (float): Initial void ratio.\n        sigma (float): Frictional resistance parameter.\n        T (float): Final time.\n        dt_nominal (float): Nominal time step size.\n\n    Returns:\n        tuple: A tuple containing (FE_violated, BE_violated, FE_abs_err, BE_abs_err).\n    \"\"\"\n\n    # --- Analytical Solution ---\n    def e_exact(t, e0_loc, sigma_loc):\n        val = np.sqrt(e0_loc) - sigma_loc * t / 2.0\n        return np.power(np.maximum(0.0, val), 2)\n\n    # --- Forward Euler (FE) Simulation ---\n    t_fe = 0.0\n    e_fe = e0\n    fe_violated = False\n    while t_fe  T:\n        h = min(dt_nominal, T - t_fe)\n        # Update rule with special handling for RHS\n        e_fe_next = e_fe - h * sigma * np.sqrt(np.maximum(0.0, e_fe))\n        e_fe = e_fe_next\n        t_fe += h\n        if e_fe  0.0:\n            fe_violated = True\n    \n    # --- Backward Euler (BE) Simulation ---\n    t_be = 0.0\n    e_be = e0\n    be_violated = False # Will remain False as BE is positivity-preserving\n    while t_be  T:\n        h = min(dt_nominal, T - t_be)\n        # Solve quadratic equation for sqrt(e_next)\n        # x^2 + h*sigma*x - e_be = 0\n        b_quad = h * sigma\n        c_quad = -e_be\n        sqrt_e_next = (-b_quad + np.sqrt(b_quad**2 - 4 * c_quad)) / 2.0\n        e_be_next = sqrt_e_next**2\n        \n        e_be = e_be_next\n        t_be += h\n        if e_be  0.0:\n            # This should never happen based on the derivation\n            be_violated = True\n\n    # --- Calculate Final Errors ---\n    e_final_exact = e_exact(T, e0, sigma)\n    fe_abs_err = abs(e_fe - e_final_exact)\n    be_abs_err = abs(e_be - e_final_exact)\n\n    return (fe_violated, be_violated, fe_abs_err, be_abs_err)\n\nif __name__ == \"__main__\":\n    solve()\n\n```"
        },
        {
            "introduction": "在掌握了隐式方法的基本原理后，我们进入一个更高级也更实际的主题：如何求解隐式格式中产生的非线性代数方程组。此练习以一个高度非线性的软化材料模型为背景，这是计算固体力学中的核心问题。您将为后向欧拉步推导牛顿-拉夫逊（Newton-Raphson）求解器，并分析时间步长 $\\Delta t$ 如何直接影响求解器的收敛性。最终，您将开发一种自适应时间步长策略，这正是现代计算力学软件中确保计算既高效又可靠的关键技术。",
            "id": "3525394",
            "problem": "考虑一个标量率相关软化模型，其灵感来源于计算岩土力学中的非弹性本构更新。令 $t \\in [0,T]$ 表示时间，$\\epsilon(t)$ 为给定的总应变历史。内变量 $p(t)$ 代表一个累积的非弹性量度（例如，粘塑性应变类物理量），并根据以下非线性常微分方程 (ODE) 演化\n$$\n\\frac{dp}{dt} = \\frac{1}{\\eta}\\,\\left[\\max\\!\\left(0,\\,f(p,\\epsilon(t))\\right)\\right]^m,\n$$\n其中粘度参数 $\\eta0$，非线性指数 $m \\ge 2$，过应力函数表现出软化特性\n$$\nf(p,\\epsilon) = E\\,(\\epsilon - p) - \\sigma_{y0}\\,\\bigl(1 - c\\,p\\bigr).\n$$\n此处 $E0$ 是刚度标度，$\\sigma_{y0}0$ 是初始屈服应力标度，$c0$ 控制强度的软化。给定的应变为一个线性斜坡\n$$\n\\epsilon(t) = \\epsilon_{\\max}\\,\\frac{t}{T},\n$$\n其中 $\\epsilon_{\\max}0$ 且 $T0$。初始条件为 $p(0)=0$。假设所有物理量均为无量纲。\n\n要求您使用前向欧拉法和后向欧拉法的基本离散思想，为此初值问题分析并实现一个时间积分器，并阐明时间步长、不动点非线性与牛顿-拉夫逊 (NR) 收敛行为之间的联系。您的推导必须从该常微分方程的前向和后向欧拉时间离散化定义以及求解非线性代数方程的牛顿-拉夫逊方法定义开始。\n\n1. 从该常微分方程和后向欧拉法的定义出发，推导单个时间步 $t_n \\to t_{n+1}$ 中关于未知数 $p_{n+1}$ 的非线性残差，并用 $p_n$、$\\Delta t = t_{n+1}-t_n$ 和 $\\epsilon_{n+1} = \\epsilon(t_{n+1})$ 表示。然后，通过计算残差对 $p_{n+1}$ 的导数，推导牛顿-拉夫逊线性化形式。\n\n2. 通过分析您推导的牛顿-拉夫逊更新，获得一个关于 $\\Delta t$ 的充分局部条件，该条件在非弹性机制被激活时（即当 $f(p_{n+1},\\epsilon_{n+1})0$ 时）能促进牛顿法收敛。您的条件应使用常微分方程右端项关于 $p$ 的局部斜率来表示，并应清楚地说明增大 $\\Delta t$ 会如何破坏隐式不动点映射的单调性或收缩性，从而阻碍牛顿法收敛。\n\n3. 使用第 2 项中的充分条件，推导一种用于自适应时间步长缩减的启发式方法，该方法可在牛顿残差减小停滞时应用。该启发式方法必须提供一个公式，用于根据已知的步前状态 $(t_n,p_n)$ 和输入的 $\\epsilon_{n+1}$，仅使用局部可用信息（如 $p_n$、$\\epsilon_{n+1}$ 及其导出的右端项对 $p$ 的局部导数估计值）来计算缩减后的试探时间步长 $\\Delta t_{\\text{new}}$。请陈述您的启发式方法并包含一个安全系数，并简要解释其合理性。\n\n4. 编写一个程序，对上述模型使用后向欧拉法进行时间步进，并在每一步中使用牛顿-拉夫逊法。实现两个驱动程序：\n   - 一个固定步长驱动程序，该程序尝试使用指定的 $\\Delta t$ 进行步进，如果牛顿-拉夫逊法未能在最大迭代次数内收敛到容差，或者如果残差在几次迭代中没有显著减小（残差停滞），则宣告步长失败。\n   - 一个自适应驱动程序，该程序在固定步长失败时，调用您的启发式方法来减小 $\\Delta t$ 并重试，直到成功或达到最小时间步长阈值。\n\n对于数值测试，使用以下无量纲参数，这些参数会产生一个高度非线性的软化区域：\n- $E=1$, $\\sigma_{y0}=1$, $c=2$, $\\eta=1$, $m=3$, $T=1$, $\\epsilon_{\\max}=1.5$.\n- 初始条件 $p(0)=0$。\n- 牛顿-拉夫逊绝对残差容差为 $10^{-10}$，每步最大迭代次数为 $10$ 次，超过则宣告失败。\n- 残差停滞检测：如果在任意连续 $3$ 次迭代窗口内，当绝对残差仍高于容差时，其减小幅度未能达到 $0.5$ 倍，则视为停滞。\n\n您的程序必须实现以下测试套件，并输出所要求的数值结果：\n\n- 测试 A（小步长下的精度）：在 $[0,1]$ 区间上使用固定步长 $\\Delta t = 2\\times 10^{-3}$ 的后向欧拉法。计算最终值 $p_{\\text{BE}}(T)$，并与使用后向欧拉法和 $\\Delta t_{\\text{ref}}=10^{-4}$ 计算出的参考解 $p_{\\text{ref}}(T)$ 进行比较，计算其绝对误差。以浮点数形式返回此误差。\n\n- 测试 B（中等步长下的牛顿法鲁棒性）：在 $[0,1]$ 区间上使用固定步长 $\\Delta t = 2\\times 10^{-2}$ 的后向欧拉法。报告是否有任何步因牛顿法不收敛或停滞而失败，如有失败则编码为整数 $1$，否则为 $0$。\n\n- 测试 C（大步长下的牛顿法鲁棒性）：在 $[0,1]$ 区间上使用固定步长 $\\Delta t = 2\\times 10^{-1}$ 的后向欧拉法。报告是否有任何步因牛顿法不收敛或停滞而失败，如有失败则编码为整数 $1$，否则为 $0$。\n\n- 测试 D（自适应缩减的有效性）：在 $[0,1]$ 区间上使用初始试探步长 $\\Delta t_{\\text{init}} = 2\\times 10^{-1}$ 和第 3 项中的启发式方法的自适应后向欧拉法。报告执行的时间步长削减（即 $\\Delta t$ 的缩减）总次数，结果为一个非负整数。\n\n所有输出均为无量纲。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按以下顺序排列：$[\\text{测试 A 结果}, \\text{测试 B 结果}, \\text{测试 C 结果}, \\text{测试 D 结果}]$。",
            "solution": "该问题要求为一个标量率相关软化模型推导并实现数值方法，这是计算岩土力学中的一个常见范式。对问题陈述的验证证实了其科学合理性、自洽性和适定性。因此，我们可以着手进行求解。\n\n控制内变量 $p(t)$ 的常微分方程 (ODE) 是：\n$$\n\\frac{dp}{dt} = \\frac{1}{\\eta}\\,\\left[\\max\\!\\left(0,\\,f(p,\\epsilon(t))\\right)\\right]^m\n$$\n初始条件为 $p(0)=0$。过应力函数 $f$ 和应变历史 $\\epsilon(t)$ 由下式给出：\n$$\nf(p,\\epsilon) = E\\,(\\epsilon - p) - \\sigma_{y0}\\,\\bigl(1 - c\\,p\\bigr)\n$$\n$$\n\\epsilon(t) = \\epsilon_{\\max}\\,\\frac{t}{T}\n$$\n对于具体参数 $E=1$、$\\sigma_{y0}=1$、$c=2$、$\\eta=1$、$m=3$、$\\epsilon_{\\max}=1.5$ 和 $T=1$，这些函数简化为：\n$$\nf(p,\\epsilon) = 1(\\epsilon-p) - 1(1-2p) = \\epsilon + p - 1\n$$\n$$\n\\epsilon(t) = 1.5t\n$$\n$$\n\\frac{dp}{dt} = \\left[\\max\\!\\left(0,\\,\\epsilon(t) + p - 1\\right)\\right]^3\n$$\n为清晰和高效起见，实现中将使用这种简化形式。\n\n### 1. 后向欧拉残差和牛顿-拉夫逊线性化\n\n后向欧拉 (BE) 法将常微分方程在一个时间步 $\\Delta t = t_{n+1} - t_n$ 上离散化为：\n$$\n\\frac{p_{n+1} - p_n}{\\Delta t} = \\left.\\frac{dp}{dt}\\right|_{t=t_{n+1}}\n$$\n将常微分方程的右端项在未知状态 $(p_{n+1}, t_{n+1})$ 处的值代入，得到隐式方程：\n$$\np_{n+1} = p_n + \\frac{\\Delta t}{\\eta} \\left[ \\max(0, f(p_{n+1}, \\epsilon_{n+1})) \\right]^m\n$$\n其中 $\\epsilon_{n+1} = \\epsilon(t_{n+1})$。为使用牛顿-拉夫逊 (NR) 方法求解 $p_{n+1}$，我们定义一个残差函数 $R(p_{n+1})$，其根即为解：\n$$\nR(p_{n+1}) = p_{n+1} - p_n - \\frac{\\Delta t}{\\eta} \\left[ \\max(0, f(p_{n+1}, \\epsilon_{n+1})) \\right]^m = 0\n$$\nNR 方法需要残差对未知数 $p_{n+1}$ 的导数，该导数通常称为切线。\n$$\nR'(p_{n+1}) = \\frac{dR}{dp_{n+1}} = 1 - \\frac{\\Delta t}{\\eta} \\frac{d}{dp_{n+1}} \\left( \\left[ \\max(0, f(p_{n+1}, \\epsilon_{n+1})) \\right]^m \\right)\n$$\n该导数取决于系统是处于弹性状态 ($f \\le 0$) 还是塑性/非弹性状态 ($f  0$)。\n如果 $f(p_{n+1}, \\epsilon_{n+1}) \\le 0$，则 max 项为零，其导数也为零。因此，$R'(p_{n+1}) = 1$。\n如果 $f(p_{n+1}, \\epsilon_{n+1})  0$，则非弹性机制被激活。我们应用链式法则：\n$$\n\\frac{d}{dp_{n+1}} \\left[ f(p_{n+1}, \\epsilon_{n+1}) \\right]^m = m \\left[ f(p_{n+1}, \\epsilon_{n+1}) \\right]^{m-1} \\frac{\\partial f}{\\partial p_{n+1}}\n$$\n$f$ 对 $p$ 的偏导数为：\n$$\n\\frac{\\partial f}{\\partial p} = \\frac{\\partial}{\\partial p} \\left( E(\\epsilon - p) - \\sigma_{y0}(1 - cp) \\right) = -E + \\sigma_{y0}c\n$$\n对于给定参数，$\\frac{\\partial f}{\\partial p} = -1 + 1(2) = 1$。\n因此，对于激活情况，切线为：\n$$\nR'(p_{n+1}) = 1 - \\frac{\\Delta t}{\\eta} m \\left[ f(p_{n+1}, \\epsilon_{n+1}) \\right]^{m-1} (\\sigma_{y0}c - E)\n$$\n则第 $(k)$ 次迭代中对 $p_{n+1}$ 的牛顿-拉夫逊更新为 $p_{n+1}^{(k+1)} = p_{n+1}^{(k)} - R(p_{n+1}^{(k)}) / R'(p_{n+1}^{(k)})$。\n\n### 2. 牛顿-拉夫逊收敛的充分条件\n\n后向欧拉方程可以写成一个不动点问题 $p_{n+1} = G(p_{n+1})$，其中映射 $G(p) = p_n + \\Delta t \\, \\mathcal{F}(p, \\epsilon_{n+1})$，而 $\\mathcal{F}$ 是常微分方程的右端项。不动点迭代收敛的一个充分条件是该映射为压缩映射，即 $|G'(p)|  1$。这也是 NR 方法稳健收敛的一个强有力指标。\n该映射的导数为 $G'(p) = \\Delta t \\, \\frac{\\partial \\mathcal{F}}{\\partial p}(p, \\epsilon_{n+1})$。从第 1 部分可知，$R'(p) = 1 - G'(p)$。残差单调性条件 $R'(p)>0$ 等价于 $G'(p)  1$。由于 $\\sigma_{y0}c - E  0$，我们有 $\\frac{\\partial \\mathcal{F}}{\\partial p}  0$，因此 $G'(p)0$。于是，条件变为：\n$$\nG'(p) = \\Delta t \\, \\frac{\\partial \\mathcal{F}}{\\partial p}  1 \\implies \\Delta t  \\frac{1}{\\frac{\\partial \\mathcal{F}}{\\partial p}}\n$$\n在激活情况下代入导数的表达式：\n$$\n\\frac{\\partial \\mathcal{F}}{\\partial p} = \\frac{m (\\sigma_{y0}c - E)}{\\eta} \\left[ f(p, \\epsilon_{n+1}) \\right]^{m-1}\n$$\n因此，关于 $\\Delta t$ 的充分局部条件为：\n$$\n\\Delta t  \\frac{\\eta}{m (\\sigma_{y0}c - E) \\left[ f(p_{n+1}, \\epsilon_{n+1}) \\right]^{m-1}}\n$$\n从物理上看，$\\frac{\\partial \\mathcal{F}}{\\partial p}$ 项代表了常微分方程演化相对于状态变量 $p$ 的“刚度”。随着软化的进行，$p$ 增加，导致 $f$ 增大，这又会急剧增加 $\\frac{\\partial \\mathcal{F}}{\\partial p}$（由于指数 $m-1 \\ge 1$）。如果 $\\Delta t$ 过大，$\\Delta t \\frac{\\partial \\mathcal{F}}{\\partial p}$ 项可能会超过 $1$。这会导致不动点映射 $G$ 失去其收缩性，NR 残差 $R$ 失去单调性 ($R'  0$)。基于负切线的 NR 步可能会过冲真实解，导致振荡或发散。\n\n### 3. 自适应时间步长启发式方法\n\n当 NR 解法在给定的时间步长 $\\Delta t_{old}$ 下失败时，通常表明违反了第 2 部分中推导的条件。我们可以设计一种启发式方法，通过使用局部可用信息估计关键项，来计算一个更小、更安全的时间步长 $\\Delta t_{new}$。我们不知道解 $p_{n+1}$，因此我们使用步长开始时的状态 $(p_n, t_n)$ 和试探步结束时的应变 $\\epsilon_{n+1} = \\epsilon(t_n + \\Delta t_{old})$。\n\n该启发式方法如下：\n1. 估计常微分方程右端项的局部斜率：\n$$\nk_{\\text{local}} = \\frac{\\partial \\mathcal{F}}{\\partial p}(p_n, \\epsilon_{n+1}) = \\frac{m (\\sigma_{y0}c - E)}{\\eta} \\left[\\max(0, f(p_n, \\epsilon_{n+1}))\\right]^{m-1}\n$$\n2. 如果 $k_{\\text{local}}  0$，根据稳定性条件计算一个“安全”时间步长，其中包含一个安全系数 $\\alpha \\in (0,1)$，例如 $\\alpha=0.8$：\n$$\n\\Delta t_{\\text{safe}} = \\frac{\\alpha}{k_{\\text{local}}}\n$$\n3. 新的时间步长应该是对旧步长的缩减。一个稳健的公式将此估计与简单的二分法结合起来：\n$$\n\\Delta t_{\\text{new}} = \\min(0.5 \\cdot \\Delta t_{\\text{old}}, \\Delta t_{\\text{safe}})\n$$\n如果 $k_{\\text{local}} \\le 0$，则失败可能不是由这种特定的不稳定性机制引起的，此时采用简单的二分法 $\\Delta t_{new} = 0.5 \\cdot \\Delta t_{old}$ 是一个合理的回退策略。\n\n这种启发式方法是合理的，因为它通过确保新的时间步长遵循系统的局部特征时间尺度 $1/k_{\\text{local}}$，直接针对了数值不稳定性的根源。\n\n### 4. 实现与数值测试\n\n以下部分展示了针对指定的后向欧拉-牛顿拉夫逊格式的固定步长和自适应驱动程序的 Python 实现，以及四个要求测试的执行过程。",
            "answer": "此处是完整且可运行的 Python 3 代码。\n导入的模块必须符合指定的执行环境。\n```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# --- Model and Numerical Parameters ---\n# Model Parameters (dimensionless)\nE = 1.0\nSIGMA_Y0 = 1.0\nC = 2.0\nETA = 1.0\nM = 3.0\nT_FINAL = 1.0\nEPS_MAX = 1.5\n\n# Numerical Parameters for Solvers\nNR_TOL = 1e-10\nNR_MAX_ITER = 10\nNR_STALL_FACTOR = 0.5\nNR_STALL_WINDOW = 3\nADAPTIVE_SAFETY_FACTOR = 0.8\nMIN_DT = 1e-8\n\n\n# --- Constitutive and Model Functions ---\n\ndef epsilon(t: float) - float:\n    \"\"\"Computes the prescribed total strain at a given time.\"\"\"\n    # Ensure time doesn't exceed the final time for epsilon calculation\n    t_clamped = min(t, T_FINAL)\n    return EPS_MAX * t_clamped / T_FINAL\n\ndef f_overstress(p: float, eps: float) - float:\n    \"\"\"Computes the overstress function f(p, eps).\"\"\"\n    # Using simplified form from derivation: eps + p - 1\n    return eps + p - 1.0\n\ndef df_dp(p: float, eps: float) - float:\n    \"\"\"Computes the partial derivative of f with respect to p.\"\"\"\n    # Using simplified form from derivation: 1.0\n    return 1.0\n\n\n# --- Core Numerical Solvers ---\n\ndef solve_step_be(p_n: float, t_n: float, dt: float) - tuple[float, str]:\n    \"\"\"\n    Solves a single time step using Backward Euler and Newton-Raphson.\n\n    Args:\n        p_n: Value of p at the beginning of the step.\n        t_n: Time at the beginning of the step.\n        dt: Time step size.\n\n    Returns:\n        A tuple containing the new value of p and a status string \n        ('success', 'failure_stall', 'failure_singular', 'failure_max_iter').\n    \"\"\"\n    t_np1 = t_n + dt\n    eps_np1 = epsilon(t_np1)\n    \n    x_k = p_n  # Initial guess for p_{n+1}\n    res_hist = []\n\n    for k in range(NR_MAX_ITER):\n        f_val = f_overstress(x_k, eps_np1)\n        \n        if f_val = 0:  # Elastic case\n            residual = x_k - p_n\n            tangent = 1.0\n        else:  # Plastic case\n            f_pow_m = f_val**M\n            f_pow_m1 = f_val**(M - 1.0)\n            residual = x_k - p_n - (dt / ETA) * f_pow_m\n            tangent = 1.0 - (dt / ETA) * M * f_pow_m1 * df_dp(x_k, eps_np1)\n\n        abs_res = abs(residual)\n        res_hist.append(abs_res)\n        \n        if abs_res  NR_TOL:\n            return x_k, 'success'\n        \n        if k >= NR_STALL_WINDOW:\n            if res_hist[k] >= NR_STALL_FACTOR * res_hist[k - NR_STALL_WINDOW]:\n                return p_n, 'failure_stall'\n\n        if abs(tangent)  1e-12: # Avoid division by zero\n            return p_n, 'failure_singular'\n\n        x_k -= residual / tangent\n\n    return p_n, 'failure_max_iter'\n\n\ndef get_adaptive_dt(p_n: float, t_n: float, dt_old: float) - float:\n    \"\"\"Computes a reduced time step using the derived heuristic.\"\"\"\n    eps_np1 = epsilon(t_n + dt_old)\n    f_est = f_overstress(p_n, eps_np1)\n    \n    if f_est = 0:\n        return 0.5 * dt_old\n\n    k_local = (M * df_dp(p_n, eps_np1) / ETA) * (f_est**(M - 1.0))\n    \n    if k_local  1e-12: # If stiffness is negligible, just bisect\n        return 0.5 * dt_old\n    \n    dt_safe = ADAPTIVE_SAFETY_FACTOR / k_local\n    return min(0.5 * dt_old, dt_safe)\n\n\n# --- Driver Functions for Tests ---\n\ndef run_fixed_step_solver(dt: float) - tuple[float, int]:\n    \"\"\"Runs the simulation with a fixed time step.\"\"\"\n    t = 0.0\n    p = 0.0\n    num_failures = 0\n    \n    while t  T_FINAL:\n        current_dt = min(dt, T_FINAL - t)\n        if current_dt  1e-12: break\n\n        p_new, status = solve_step_be(p, t, current_dt)\n        \n        if status != 'success':\n            num_failures += 1\n        \n        t += current_dt\n        p = p_new\n        \n    return p, num_failures\n\n\ndef run_adaptive_solver(dt_init: float) - int:\n    \"\"\"Runs the simulation with adaptive time stepping.\"\"\"\n    t = 0.0\n    p = 0.0\n    dt = dt_init\n    num_cuts = 0\n\n    while t  T_FINAL:\n        current_dt_trial = min(dt, T_FINAL - t)\n        if current_dt_trial  MIN_DT:\n            break\n\n        step_succeeded = False\n        while not step_succeeded:\n            if current_dt_trial  MIN_DT:\n                raise RuntimeError(\"Adaptive time step fell below minimum threshold.\")\n\n            p_new, status = solve_step_be(p, t, current_dt_trial)\n            \n            if status == 'success':\n                t += current_dt_trial\n                p = p_new\n                dt = current_dt_trial  # Use successful step for next trial\n                step_succeeded = True\n            else:\n                num_cuts += 1\n                dt_new = get_adaptive_dt(p, t, current_dt_trial)\n                current_dt_trial = dt_new\n                \n    return num_cuts\n\ndef solve():\n    \"\"\"\n    Main function to execute all tests and print the final results.\n    \"\"\"\n    # Test A: Accuracy check against a reference solution\n    p_ref, _ = run_fixed_step_solver(dt=1e-4)\n    p_test_a, _ = run_fixed_step_solver(dt=2e-3)\n    result_a = abs(p_test_a - p_ref)\n\n    # Test B: Robustness check with medium fixed step\n    _, failures_b = run_fixed_step_solver(dt=2e-2)\n    result_b = 1 if failures_b > 0 else 0\n\n    # Test C: Robustness check with large fixed step\n    _, failures_c = run_fixed_step_solver(dt=2e-1)\n    result_c = 1 if failures_c > 0 else 0\n    \n    # Test D: Effectiveness of adaptive stepping\n    result_d = run_adaptive_solver(dt_init=2e-1)\n\n    results = [result_a, result_b, result_c, result_d]\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the solution\nif __name__ == \"__main__\":\n    solve()\n\n```"
        }
    ]
}