{
    "hands_on_practices": [
        {
            "introduction": "Accurately integrating the constitutive equations over a large strain increment is a core challenge in computational plasticity, as the material's response can be highly nonlinear. This first exercise provides hands-on experience with adaptive substepping, the standard technique for controlling this integration error. You will implement and compare two classic criteria for accepting a substep: one based on the stationarity of the plastic flow direction and another on the magnitude of the yield function residual, offering direct insight into how different error metrics affect algorithmic efficiency and accuracy. ",
            "id": "3566154",
            "problem": "You are tasked with designing and implementing two adaptive substepping termination criteria for integrating an associated Drucker–Prager elastoplastic model under small strains. The two criteria are: stationarity of the plastic flow direction and residual yield function magnitude. Your program must simulate the stress update over a single prescribed total strain increment using each criterion and report the number of accepted substeps and the difference in the final stress states. All quantities must be expressed in megapascal units for stress and dimensionless units for strain.\n\nUse the following context and base definitions, which are fundamental in computational geomechanics and small-strain elastoplasticity.\n\n1. The constitutive behavior is linear elastic with isotropy up to yield. For small strains, the stress increment is given by\n$$\n\\Delta \\boldsymbol{\\sigma} = \\lambda \\, \\mathrm{tr}(\\Delta \\boldsymbol{\\varepsilon}) \\, \\boldsymbol{I} + 2 \\mu \\, \\mathrm{dev}(\\Delta \\boldsymbol{\\varepsilon}),\n$$\nwhere $\\lambda$ and $\\mu$ are the Lamé constants, $\\boldsymbol{I}$ is the identity tensor, $\\mathrm{tr}(\\cdot)$ denotes the trace, and $\\mathrm{dev}(\\cdot)$ denotes the deviatoric projection. The Lamé constants are related to Young’s modulus $E$ and Poisson’s ratio $\\nu$ by\n$$\n\\lambda = \\frac{E \\nu}{(1+\\nu)(1-2\\nu)}, \\quad \\mu = \\frac{E}{2(1+\\nu)}.\n$$\n\n2. The associated Drucker–Prager yield function with isotropic hardening is\n$$\nf(\\boldsymbol{\\sigma}, \\kappa) = \\alpha \\, I_1 + \\sqrt{J_2} - \\left(\\sigma_{y0} + H \\kappa \\right),\n$$\nwhere $I_1 = \\mathrm{tr}(\\boldsymbol{\\sigma})$, $J_2 = \\tfrac{1}{2} \\, \\mathrm{dev}(\\boldsymbol{\\sigma}) : \\mathrm{dev}(\\boldsymbol{\\sigma})$, $\\alpha$ is a given friction parameter, $\\sigma_{y0}$ is the initial yield stress, $H$ is the isotropic hardening modulus, and $\\kappa$ is the internal hardening variable that accumulates as plastic flow proceeds. The plastic flow direction for associated flow is defined by the gradient of the yield function with respect to stress,\n$$\n\\boldsymbol{m}(\\boldsymbol{\\sigma}) = \\frac{\\partial f}{\\partial \\boldsymbol{\\sigma}} = \\alpha \\boldsymbol{I} + \\frac{\\mathrm{dev}(\\boldsymbol{\\sigma})}{2 \\sqrt{J_2}},\n$$\nand its normalized form\n$$\n\\boldsymbol{n}(\\boldsymbol{\\sigma}) = \\frac{\\boldsymbol{m}(\\boldsymbol{\\sigma})}{\\|\\boldsymbol{m}(\\boldsymbol{\\sigma})\\|_F},\n$$\nwhere $\\|\\cdot\\|_F$ is the Frobenius norm. When $J_2$ is sufficiently small, regularize $\\sqrt{J_2}$ with a small positive threshold to avoid division by zero.\n\n3. Consider the substepping framework in which the total strain increment $\\Delta \\boldsymbol{\\varepsilon}_{\\mathrm{tot}}$ is partitioned into substeps of size $\\Delta \\boldsymbol{\\varepsilon}_i = \\xi_i \\, \\Delta \\boldsymbol{\\varepsilon}_{\\mathrm{tot}}$ with $0 < \\xi_i \\leq 1$ and $\\sum_i \\xi_i = 1$. Within each substep, adopt a constant-direction approximation for the plastic flow: freeze the gradient $\\boldsymbol{m}$ at the beginning of the substep. With $\\boldsymbol{m}_i = \\boldsymbol{m}(\\boldsymbol{\\sigma}_i)$ fixed over substep $i$, the stress update is\n$$\n\\boldsymbol{\\sigma}_{i+1} = \\boldsymbol{\\sigma}_{i} + \\lambda \\, \\mathrm{tr}(\\Delta \\boldsymbol{\\varepsilon}_i) \\, \\boldsymbol{I} + 2 \\mu \\, \\mathrm{dev}(\\Delta \\boldsymbol{\\varepsilon}_i) - d\\lambda_i \\left[\\lambda \\, \\mathrm{tr}(\\boldsymbol{m}_i) \\, \\boldsymbol{I} + 2 \\mu \\, \\mathrm{dev}(\\boldsymbol{m}_i)\\right],\n$$\nwhere $d\\lambda_i \\geq 0$ is the plastic multiplier increment for the substep and the hardening update is $\\kappa_{i+1} = \\kappa_i + d\\lambda_i$. The consistency condition $f(\\boldsymbol{\\sigma}_{i+1}, \\kappa_{i+1}) = 0$ for plastic loading in substep $i$ defines a scalar nonlinear equation for $d\\lambda_i$; use a Newton method to solve it. If the trial elastic predictor at the end of the substep satisfies $f \\leq 0$, then $d\\lambda_i = 0$ and the substep is purely elastic.\n\n4. Implement the two acceptance criteria for substeps:\n   - Stationarity of flow direction: accept the substep when the change in the normalized flow direction between the beginning and end of the substep satisfies\n     $$\n     \\left\\|\\boldsymbol{n}_{i+1} - \\boldsymbol{n}_{i} \\right\\|_F < \\varepsilon_n,\n     $$\n     where $\\varepsilon_n$ is a specified tolerance. The first substep is accepted unconditionally. If the condition fails, reduce the substep size (e.g., halve $\\xi_i$) and retry from the same state.\n   - Yield-residual based: accept the substep when the evaluated yield function magnitude at the end satisfies\n     $$\n     f(\\boldsymbol{\\sigma}_{i+1}, \\kappa_{i+1}) \\leq 0 \\quad \\text{or} \\quad \\left| f(\\boldsymbol{\\sigma}_{i+1}, \\kappa_{i+1}) \\right| < \\varepsilon_f,\n     $$\n     where $\\varepsilon_f$ is a specified tolerance. If the condition fails, reduce the substep size and retry. Use the same Newton method for $d\\lambda_i$ in plastic substeps.\n\n5. Start from $\\boldsymbol{\\sigma}_0 = \\boldsymbol{0}$ and $\\kappa_0 = 0$ in each simulation. Use the material parameters in megapascal units: $E$ in $\\mathrm{MPa}$, $\\nu$ dimensionless, $\\alpha$ dimensionless, $\\sigma_{y0}$ in $\\mathrm{MPa}$, and $H$ in $\\mathrm{MPa}$. Use the following tolerances: $\\varepsilon_n = 10^{-3}$ for the stationarity criterion and $\\varepsilon_f = 10^{-6} \\,\\mathrm{MPa}$ for the yield-residual criterion. Use a Newton solver tolerance of $10^{-8} \\,\\mathrm{MPa}$ for solving the consistency equation in each plastic substep, with a maximum of $50$ iterations and step damping if needed. In substepping adaptation, if the substep size becomes smaller than a minimum fraction of $10^{-6}$ of the total increment, force accept to avoid infinite loops.\n\nTest Suite. For each case, the strain increment $\\Delta \\boldsymbol{\\varepsilon}_{\\mathrm{tot}}$ is a symmetric $3 \\times 3$ tensor (dimensionless). Material parameters are as listed for each case. All stresses computed and reported must be in $\\mathrm{MPa}$.\n\n- Case A (general deviatoric loading, expected plastic): $E = 10000 \\,\\mathrm{MPa}$, $\\nu = 0.3$, $\\alpha = 0.2$, $\\sigma_{y0} = 50 \\,\\mathrm{MPa}$, $H = 200 \\,\\mathrm{MPa}$, and\n  $$\n  \\Delta \\boldsymbol{\\varepsilon}_{\\mathrm{tot}} = \\begin{bmatrix}\n  0 & 0.01 & 0 \\\\\n  0.01 & 0 & 0 \\\\\n  0 & 0 & 0\n  \\end{bmatrix}.\n  $$\n\n- Case B (hydrostatic tension, expected plastic): $E = 10000 \\,\\mathrm{MPa}$, $\\nu = 0.3$, $\\alpha = 0.2$, $\\sigma_{y0} = 50 \\,\\mathrm{MPa}$, $H = 200 \\,\\mathrm{MPa}$, and\n  $$\n  \\Delta \\boldsymbol{\\varepsilon}_{\\mathrm{tot}} = \\begin{bmatrix}\n  0.004 & 0 & 0 \\\\\n  0 & 0.004 & 0 \\\\\n  0 & 0 & 0.004\n  \\end{bmatrix}.\n  $$\n\n- Case C (mixed loading, large path): $E = 10000 \\,\\mathrm{MPa}$, $\\nu = 0.3$, $\\alpha = 0.2$, $\\sigma_{y0} = 50 \\,\\mathrm{MPa}$, $H = 200 \\,\\mathrm{MPa}$, and\n  $$\n  \\Delta \\boldsymbol{\\varepsilon}_{\\mathrm{tot}} = \\begin{bmatrix}\n  0.006 & 0.004 & 0 \\\\\n  0.004 & -0.002 & 0 \\\\\n  0 & 0 & -0.001\n  \\end{bmatrix}.\n  $$\n\n- Case D (small shear, expected elastic): $E = 10000 \\,\\mathrm{MPa}$, $\\nu = 0.3$, $\\alpha = 0.2$, $\\sigma_{y0} = 50 \\,\\mathrm{MPa}$, $H = 200 \\,\\mathrm{MPa}$, and\n  $$\n  \\Delta \\boldsymbol{\\varepsilon}_{\\mathrm{tot}} = \\begin{bmatrix}\n  0 & 0.0002 & 0 \\\\\n  0.0002 & 0 & 0 \\\\\n  0 & 0 & 0\n  \\end{bmatrix}.\n  $$\n\nRequired outputs. For each case, run the full increment integration twice: once with the stationarity criterion and once with the yield-residual criterion. Record: the number of accepted substeps for stationarity ($N_n$), the number for yield-residual ($N_f$), and the Frobenius norm of the difference between the two final stress tensors in $\\mathrm{MPa}$, $\\|\\boldsymbol{\\sigma}^{(n)} - \\boldsymbol{\\sigma}^{(f)}\\|_F$. Your program should produce a single line of output containing the $12$ values for Cases A–D, in the order\n$$\n\\left[ N_n^{A}, N_f^{A}, \\|\\boldsymbol{\\sigma}^{(n)} - \\boldsymbol{\\sigma}^{(f)}\\|_F^{A}, N_n^{B}, N_f^{B}, \\|\\boldsymbol{\\sigma}^{(n)} - \\boldsymbol{\\sigma}^{(f)}\\|_F^{B}, N_n^{C}, N_f^{C}, \\|\\boldsymbol{\\sigma}^{(n)} - \\boldsymbol{\\sigma}^{(f)}\\|_F^{C}, N_n^{D}, N_f^{D}, \\|\\boldsymbol{\\sigma}^{(n)} - \\boldsymbol{\\sigma}^{(f)}\\|_F^{D} \\right],\n$$\nprinted exactly as a Python list literal with commas separating values. The counts must be integers and the norms must be floating-point numbers in $\\mathrm{MPa}$.",
            "solution": "The problem is assessed as valid. It is scientifically grounded in the theory of computational plasticity, is well-posed with all necessary parameters and conditions provided, and is expressed in objective, formal language. The problem requires the implementation and comparison of two adaptive substepping strategies for integrating the constitutive response of a Drucker-Prager elastoplastic material. We will proceed with a detailed solution.\n\n### 1. Theoretical Framework\n\nThe problem describes a material model combining linear elasticity with Drucker-Prager plasticity under the assumption of small strains.\n\n**Elastic Behavior**: The relationship between the stress increment tensor $\\Delta\\boldsymbol{\\sigma}$ and the strain increment tensor $\\Delta\\boldsymbol{\\varepsilon}$ is given by a specific, albeit non-standard, isotropic linear elastic law:\n$$\n\\Delta \\boldsymbol{\\sigma} = \\lambda \\, \\mathrm{tr}(\\Delta \\boldsymbol{\\varepsilon}) \\, \\boldsymbol{I} + 2 \\mu \\, \\mathrm{dev}(\\Delta \\boldsymbol{\\varepsilon})\n$$\nwhere $\\boldsymbol{I}$ is the second-order identity tensor, $\\mathrm{tr}(\\cdot)$ is the trace operator, and $\\mathrm{dev}(\\cdot)$ is the deviatoric projection operator. The Lamé parameters $\\lambda$ and $\\mu$ are defined in terms of Young's modulus $E$ and Poisson's ratio $\\nu$ as:\n$$\n\\lambda = \\frac{E \\nu}{(1+\\nu)(1-2\\nu)}, \\quad \\mu = \\frac{E}{2(1+\\nu)}\n$$\nThis structure implies that for any second-order tensor $\\boldsymbol{X}$, the fourth-order elasticity tensor $\\mathbf{C}$ acts as $\\mathbf{C}:\\boldsymbol{X} = \\lambda \\, \\mathrm{tr}(\\boldsymbol{X}) \\, \\boldsymbol{I} + 2 \\mu \\, \\mathrm{dev}(\\boldsymbol{X})$.\n\n**Plastic Behavior**: Plastic yielding and flow are governed by the associated Drucker-Prager model with isotropic hardening.\nThe yield function $f$ defines the boundary of the elastic domain:\n$$\nf(\\boldsymbol{\\sigma}, \\kappa) = \\alpha \\, I_1 + \\sqrt{J_2} - \\left(\\sigma_{y0} + H \\kappa \\right)\n$$\nwhere $I_1 = \\mathrm{tr}(\\boldsymbol{\\sigma})$ is the first invariant of the stress tensor, $J_2 = \\frac{1}{2} \\mathrm{dev}(\\boldsymbol{\\sigma}) : \\mathrm{dev}(\\boldsymbol{\\sigma})$ is the second invariant of the deviatoric stress, $\\alpha$ is a material friction parameter, $\\sigma_{y0}$ is the initial yield stress, $H$ is the hardening modulus, and $\\kappa$ is the accumulated plastic strain (internal hardening variable).\n\nFor associated plasticity, the plastic flow direction $\\boldsymbol{m}$ is given by the gradient of the yield function with respect to stress:\n$$\n\\boldsymbol{m}(\\boldsymbol{\\sigma}) = \\frac{\\partial f}{\\partial \\boldsymbol{\\sigma}} = \\alpha \\boldsymbol{I} + \\frac{\\mathrm{dev}(\\boldsymbol{\\sigma})}{2 \\sqrt{J_2}}\n$$\nTo handle the case where $J_2 \\to 0$ (i.e., states on the hydrostatic axis), the term involving $\\sqrt{J_2}$ is regularized by setting the deviatoric component of $\\boldsymbol{m}$ to zero if $J_2$ is below a small numerical threshold. The normalized flow direction is $\\boldsymbol{n}(\\boldsymbol{\\sigma}) = \\boldsymbol{m}(\\boldsymbol{\\sigma}) / \\|\\boldsymbol{m}(\\boldsymbol{\\sigma})\\|_F$, where $\\|\\cdot\\|_F$ is the Frobenius norm.\n\n### 2. Numerical Integration Scheme\n\nThe total strain increment $\\Delta\\boldsymbol{\\varepsilon}_{\\mathrm{tot}}$ is applied over a single load step, which is divided into multiple smaller substeps. The integration within each substep is performed using an explicit-type, constant-direction approximation.\n\n**Substepping**: The total strain increment is partitioned as $\\Delta\\boldsymbol{\\varepsilon}_{\\mathrm{tot}} = \\sum_i \\Delta\\boldsymbol{\\varepsilon}_i$, where $\\Delta\\boldsymbol{\\varepsilon}_i = \\xi_i \\Delta\\boldsymbol{\\varepsilon}_{\\mathrm{tot}}$ and $\\xi_i$ is the size of substep $i$. The state $(\\boldsymbol{\\sigma}_i, \\kappa_i)$ is updated to $(\\boldsymbol{\\sigma}_{i+1}, \\kappa_{i+1})$.\n\n**Stress Update**: For each substep, a trial elastic stress is first computed:\n$$\n\\boldsymbol{\\sigma}^{\\text{trial}}_{i+1} = \\boldsymbol{\\sigma}_i + \\Delta\\boldsymbol{\\sigma}^{\\text{e}}_i = \\boldsymbol{\\sigma}_i + \\lambda \\, \\mathrm{tr}(\\Delta \\boldsymbol{\\varepsilon}_i) \\, \\boldsymbol{I} + 2 \\mu \\, \\mathrm{dev}(\\Delta \\boldsymbol{\\varepsilon}_i)\n$$\nIf $f(\\boldsymbol{\\sigma}^{\\text{trial}}_{i+1}, \\kappa_i) \\leq 0$, the substep is elastic, and $\\boldsymbol{\\sigma}_{i+1} = \\boldsymbol{\\sigma}^{\\text{trial}}_{i+1}$, $\\kappa_{i+1} = \\kappa_i$.\n\nIf $f(\\boldsymbol{\\sigma}^{\\text{trial}}_{i+1}, \\kappa_i) > 0$, the substep is plastic. A plastic correction is required. The constant-direction approximation freezes the flow direction $\\boldsymbol{m}_i = \\boldsymbol{m}(\\boldsymbol{\\sigma}_i)$ at the beginning of the substep. The final stress is given by:\n$$\n\\boldsymbol{\\sigma}_{i+1} = \\boldsymbol{\\sigma}^{\\text{trial}}_{i+1} - d\\lambda_i \\left( \\mathbf{C} : \\boldsymbol{m}_i \\right)\n$$\nwhere $d\\lambda_i$ is the plastic multiplier increment for the substep, and the term $\\mathbf{C} : \\boldsymbol{m}_i$ is specified as:\n$$\n\\mathbf{C} : \\boldsymbol{m}_i = \\lambda \\, \\mathrm{tr}(\\boldsymbol{m}_i) \\, \\boldsymbol{I} + 2 \\mu \\, \\mathrm{dev}(\\boldsymbol{m}_i)\n$$\nThe hardening variable is updated as $\\kappa_{i+1} = \\kappa_i + d\\lambda_i$. The unknown $d\\lambda_i$ is found by enforcing the consistency condition $f(\\boldsymbol{\\sigma}_{i+1}, \\kappa_{i+1}) = 0$. This forms a scalar nonlinear equation for $d\\lambda_i$, which we solve using a Newton-Raphson method. The iterative update for $d\\lambda_i$ is:\n$$\nd\\lambda_i^{(k+1)} = d\\lambda_i^{(k)} - \\frac{g(d\\lambda_i^{(k)})}{g'(d\\lambda_i^{(k)})}\n$$\nwhere $g(d\\lambda_i) = f(\\boldsymbol{\\sigma}_{i+1}(d\\lambda_i), \\kappa_{i+1}(d\\lambda_i))$ and $g'(d\\lambda_i) = \\frac{\\partial f}{\\partial \\boldsymbol{\\sigma}}\\Big|_{\\boldsymbol{\\sigma}_{i+1}} : \\frac{d\\boldsymbol{\\sigma}_{i+1}}{d(d\\lambda_i)} + \\frac{\\partial f}{\\partial \\kappa}\\frac{d\\kappa_{i+1}}{d(d\\lambda_i)} = -\\boldsymbol{m}(\\boldsymbol{\\sigma}_{i+1}) : (\\mathbf{C}:\\boldsymbol{m}_i) - H$.\n\n### 3. Adaptive Substep Control\n\nTwo criteria for accepting a completed substep are implemented and compared. If a substep is rejected, its size $\\xi_i$ is halved, and the calculation is retried from state $(\\boldsymbol{\\sigma}_i, \\kappa_i)$. A substep is forcibly accepted if its size falls below a minimum threshold ($10^{-6}$ of the total increment) to prevent infinite loops.\n\n**1. Stationarity of Flow Direction**: A substep is accepted if the plastic flow direction does not change significantly. This is measured by the Frobenius norm of the difference in the normalized flow direction at the beginning and end of the substep.\n$$\n\\left\\|\\boldsymbol{n}_{i+1} - \\boldsymbol{n}_{i} \\right\\|_F < \\varepsilon_n\n$$\nwhere $\\boldsymbol{n}_i = \\boldsymbol{n}(\\boldsymbol{\\sigma}_i)$, $\\boldsymbol{n}_{i+1} = \\boldsymbol{n}(\\boldsymbol{\\sigma}_{i+1})$, and the tolerance is $\\varepsilon_n = 10^{-3}$. The very first substep of the simulation is accepted unconditionally.\n\n**2. Yield-Residual Based**: A substep is accepted if the final state is elastic or if the final stress state lies sufficiently close to the yield surface.\n$$\nf(\\boldsymbol{\\sigma}_{i+1}, \\kappa_{i+1}) \\leq 0 \\quad \\text{or} \\quad \\left| f(\\boldsymbol{\\sigma}_{i+1}, \\kappa_{i+1}) \\right| < \\varepsilon_f\n$$\nThe tolerance is $\\varepsilon_f = 10^{-6} \\, \\mathrm{MPa}$.\n\n### 4. Simulation Execution\n\nFor each test case, the material and numerical parameters specified in the problem are initialized. The simulation starts from a zero-stress, zero-hardening state ($\\boldsymbol{\\sigma}_0 = \\boldsymbol{0}$, $\\kappa_0=0$). The integration process is executed twice: once using the stationarity criterion and a second time using the yield-residual criterion. The number of accepted substeps ($N_n$, $N_f$) and the Frobenius norm of the difference between the final stress tensors, $\\|\\boldsymbol{\\sigma}^{(n)} - \\boldsymbol{\\sigma}^{(f)}\\|_F$, are recorded for each case. The results from all cases are then aggregated into a single list for the final output.",
            "answer": "```python\nimport numpy as np\n\n# A small value for J2 regularization to prevent division by zero\nJ2_REG = 1e-20  # MPa^2\n\n# ---------- Tensor and Constitutive Utilities ----------\n\ndef dev(tensor):\n    \"\"\"Computes the deviatoric part of a 3x3 tensor.\"\"\"\n    return tensor - (1/3) * np.trace(tensor) * np.eye(3)\n\ndef lame_lambda(E, nu):\n    \"\"\"Calculates Lamé's first parameter.\"\"\"\n    return (E * nu) / ((1 + nu) * (1 - 2 * nu))\n\ndef lame_mu(E, nu):\n    \"\"\"Calculates Lamé's second parameter (shear modulus).\"\"\"\n    return E / (2 * (1 + nu))\n\ndef elastic_stress_inc(deps, lam, mu):\n    \"\"\"\n    Calculates the elastic stress increment based on the problem's specific formula.\n    Δσ = λ tr(Δε) I + 2μ dev(Δε)\n    \"\"\"\n    tr_deps = np.trace(deps)\n    dev_deps = dev(deps)\n    return lam * tr_deps * np.eye(3) + 2 * mu * dev_deps\n\ndef C_colon_tensor(tensor, lam, mu):\n    \"\"\"\n    Applies the constitutive operator to a second-order tensor, following the problem's definition.\n    C:T = λ tr(T) I + 2μ dev(T)\n    \"\"\"\n    return lam * np.trace(tensor) * np.eye(3) + 2 * mu * dev(tensor)\n\n# ---------- Drucker-Prager Model Functions ----------\n\ndef get_invariants(sigma):\n    \"\"\"Computes stress invariants I1 and J2.\"\"\"\n    I1 = np.trace(sigma)\n    s = dev(sigma)\n    J2 = 0.5 * np.sum(s * s)\n    return I1, J2\n\ndef yield_function(sigma, kappa, alpha, sig_y0, H):\n    \"\"\"Computes the Drucker-Prager yield function value.\"\"\"\n    I1, J2 = get_invariants(sigma)\n    sqrt_J2 = np.sqrt(J2)\n    return alpha * I1 + sqrt_J2 - (sig_y0 + H * kappa)\n\ndef flow_direction_m(sigma, alpha):\n    \"\"\"Computes the plastic flow direction m = ∂f/∂σ with regularization.\"\"\"\n    s = dev(sigma)\n    J2 = 0.5 * np.sum(s * s)\n    if J2 < J2_REG:\n        # For states on/near hydrostatic axis, deviatoric part of flow is zero\n        dev_m_term = np.zeros((3, 3))\n    else:\n        dev_m_term = s / (2 * np.sqrt(J2))\n    return alpha * np.eye(3) + dev_m_term\n\ndef normalized_flow_direction_n(sigma, alpha):\n    \"\"\"Computes the normalized plastic flow direction n.\"\"\"\n    m = flow_direction_m(sigma, alpha)\n    norm_m = np.linalg.norm(m, 'fro')\n    if norm_m < 1e-12: # Avoid division by zero if m is effectively zero\n        return np.zeros((3,3))\n    return m / norm_m\n\n# ---------- Newton Solver for Plastic Multiplier ----------\n\ndef solve_d_lambda(sigma_trial, kappa_i, m_i, params):\n    \"\"\"\n    Solves for the plastic multiplier increment d_lambda using Newton's method.\n    \"\"\"\n    lam, mu, alpha, sig_y0, H = params['lam'], params['mu'], params['alpha'], params['sig_y0'], params['H']\n    newton_tol = params['newton_tol']\n    max_iter = params['newton_max_iter']\n\n    C_m = C_colon_tensor(m_i, lam, mu)\n    d_lambda = 0.0\n\n    for _ in range(max_iter):\n        sigma_k = sigma_trial - d_lambda * C_m\n        kappa_k = kappa_i + d_lambda\n\n        # Calculate residual g(d_lambda)\n        g = yield_function(sigma_k, kappa_k, alpha, sig_y0, H)\n\n        if abs(g) < newton_tol:\n            return d_lambda if d_lambda > 0 else 0.0\n\n        # Calculate derivative g'(d_lambda)\n        m_k = flow_direction_m(sigma_k, alpha)\n        g_prime = -np.sum(m_k * C_m) - H\n\n        if abs(g_prime) < 1e-12:\n            return d_lambda if d_lambda > 0 else 0.0\n\n        # Newton update with simple line search/damping\n        delta_d_lambda = -g / g_prime\n        damp = 1.0\n        for _ in range(5):\n            d_lambda_new = d_lambda + damp * delta_d_lambda\n            if d_lambda_new < 0: # Multiplier must be non-negative\n                damp /= 2.0\n                continue\n            \n            sigma_new = sigma_trial - d_lambda_new * C_m\n            kappa_new = kappa_i + d_lambda_new\n            g_new = yield_function(sigma_new, kappa_new, alpha, sig_y0, H)\n            \n            if abs(g_new) < abs(g) * (1 - 1e-4 * damp): # Armijo-like condition\n                d_lambda = d_lambda_new\n                break\n            damp /= 2.0\n        else: # Damping failed, so no update this iteration\n            return d_lambda if d_lambda > 0 else 0.0\n\n    return d_lambda if d_lambda > 0 else 0.0\n\n# ---------- Main Substepping Algorithm ----------\n\ndef run_simulation(params, criterion):\n    \"\"\"\n    Runs a single simulation for a total strain increment with adaptive substepping.\n    \"\"\"\n    sigma = np.zeros((3, 3))\n    kappa = 0.0\n    \n    total_strain_inc = params['deps_tot']\n    lam, mu, alpha, sig_y0, H = params['lam'], params['mu'], params['alpha'], params['sig_y0'], params['H']\n    eps_n, eps_f, min_xi_frac = params['eps_n'], params['eps_f'], params['min_xi_frac']\n    \n    accumulated_xi = 0.0\n    substep_count = 0\n\n    while accumulated_xi < 1.0 - 1e-9: # Loop until full strain increment is applied\n        xi = 1.0 - accumulated_xi\n        is_first_substep = (substep_count == 0)\n\n        while True: # Substep reduction loop\n            deps_substep = xi * total_strain_inc\n            sigma_trial = sigma + elastic_stress_inc(deps_substep, lam, mu)\n            f_trial = yield_function(sigma_trial, kappa, alpha, sig_y0, H)\n            \n            is_plastic_substep = f_trial > 0\n\n            if is_plastic_substep:\n                m_i = flow_direction_m(sigma, alpha)\n                d_lambda = solve_d_lambda(sigma_trial, kappa, m_i, params)\n                \n                if d_lambda > 0:\n                    C_m = C_colon_tensor(m_i, lam, mu)\n                    sigma_next = sigma_trial - d_lambda * C_m\n                    kappa_next = kappa + d_lambda\n                else: # Newton found no plastic strain, so step is effectively elastic\n                    sigma_next = sigma_trial\n                    kappa_next = kappa\n                    is_plastic_substep = False\n            else: # Elastic substep\n                sigma_next = sigma_trial\n                kappa_next = kappa\n\n            # Substep acceptance check\n            accepted = False\n            if criterion == 'stationarity':\n                if is_first_substep:\n                    accepted = True\n                else:\n                    n_i = normalized_flow_direction_n(sigma, alpha)\n                    n_next = normalized_flow_direction_n(sigma_next, alpha)\n                    norm_diff = np.linalg.norm(n_next - n_i, 'fro')\n                    if norm_diff < eps_n:\n                        accepted = True\n            elif criterion == 'yield_residual':\n                if not is_plastic_substep:\n                    accepted = True\n                else:\n                    f_end = yield_function(sigma_next, kappa_next, alpha, sig_y0, H)\n                    if abs(f_end) < eps_f:\n                        accepted = True\n            \n            if not accepted and xi < min_xi_frac:\n                accepted = True\n                \n            if accepted:\n                sigma = sigma_next\n                kappa = kappa_next\n                accumulated_xi += xi\n                substep_count += 1\n                break\n            else:\n                xi /= 2.0\n                \n    return sigma, substep_count\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final output.\n    \"\"\"\n    test_cases_spec = {\n        'A': {'deps_tot': np.array([[0.0, 0.01, 0.0], [0.01, 0.0, 0.0], [0.0, 0.0, 0.0]])},\n        'B': {'deps_tot': np.array([[0.004, 0.0, 0.0], [0.0, 0.004, 0.0], [0.0, 0.0, 0.004]])},\n        'C': {'deps_tot': np.array([[0.006, 0.004, 0.0], [0.004, -0.002, 0.0], [0.0, 0.0, -0.001]])},\n        'D': {'deps_tot': np.array([[0.0, 0.0002, 0.0], [0.0002, 0.0, 0.0], [0.0, 0.0, 0.0]])}\n    }\n    \n    base_material_params = {'E': 10000.0, 'nu': 0.3, 'alpha': 0.2, 'sig_y0': 50.0, 'H': 200.0}\n    common_numerical_params = {\n        'eps_n': 1e-3, 'eps_f': 1e-6, 'newton_tol': 1e-8,\n        'newton_max_iter': 50, 'min_xi_frac': 1e-6\n    }\n\n    results = []\n    case_order = ['A', 'B', 'C', 'D']\n\n    for case_id in case_order:\n        params = base_material_params.copy()\n        params.update(test_cases_spec[case_id])\n        params.update(common_numerical_params)\n        \n        params['lam'] = lame_lambda(params['E'], params['nu'])\n        params['mu'] = lame_mu(params['E'], params['nu'])\n\n        sigma_n, N_n = run_simulation(params, 'stationarity')\n        sigma_f, N_f = run_simulation(params, 'yield_residual')\n\n        stress_diff_norm = np.linalg.norm(sigma_n - sigma_f, 'fro')\n\n        results.extend([N_n, N_f, stress_diff_norm])\n        \n    print(f\"[{','.join(f'{v:.6f}' if isinstance(v, float) else str(v) for v in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Standard error controls are effective, but more sophisticated strategies can be designed by tailoring the substepping to the specific material model. This practice challenges you to develop such a model-aware scheme for the Modified Cam-Clay model, a cornerstone of critical state soil mechanics. By creating a partition that aligns substeps with the magnitude of the yield function's gradient, you will concentrate computational effort in regions of high plastic 'activity,' demonstrating how physical insight into a constitutive model can lead to more elegant and efficient numerical algorithms. ",
            "id": "3566113",
            "problem": "Consider small-strain elastoplastic integration with an associated flow rule for a soil described by the Modified Cam-Clay (MCC) yield function. Let the Cauchy stress tensor be denoted by $\\boldsymbol{\\sigma} \\in \\mathbb{R}^{3 \\times 3}$, with the mean stress $p = \\tfrac{1}{3} I_1 = \\tfrac{1}{3} \\operatorname{tr}(\\boldsymbol{\\sigma})$ and the second invariant of the deviatoric stress $J_2 = \\tfrac{1}{2} \\boldsymbol{s}:\\boldsymbol{s}$, where $\\boldsymbol{s} = \\boldsymbol{\\sigma} - p \\boldsymbol{I}$ and $\\boldsymbol{I}$ is the identity tensor. Define the invariant $q = \\sqrt{3 J_2}$, and consider the Modified Cam-Clay (MCC) yield function $f(p,q,p_c) = \\dfrac{q^2}{M^2} + p(p - p_c)$, where $M > 0$ is the slope of the critical state line in $p$-$q$ space and $p_c > 0$ is the preconsolidation pressure. Assume an associated flow rule with plastic potential equal to the yield function, which implies $\\Delta \\boldsymbol{\\varepsilon}^p \\propto \\nabla_{\\boldsymbol{\\sigma}} f(\\boldsymbol{\\sigma})$, and the plastic strain increment direction is given by $\\dfrac{\\Delta \\boldsymbol{\\varepsilon}^p}{\\|\\Delta \\boldsymbol{\\varepsilon}^p\\|}$.\n\nYou will study a prescribed stress-path constrained to remain exactly on the yield surface, parameterized by $t \\in [0,1]$:\n- The mean stress is $p(t) = p_c \\sin^2\\left(\\dfrac{\\pi t}{2}\\right)$.\n- The deviatoric invariant is $q(t) = M \\sqrt{-p(t) \\left(p(t) - p_c\\right)}$.\n- The deviatoric direction rotates as $\\boldsymbol{s}_{\\mathrm{dir}}(t) = \\cos\\left(\\theta(t)\\right) \\, \\boldsymbol{E}_1 + \\sin\\left(\\theta(t)\\right) \\, \\boldsymbol{E}_2$, where $\\boldsymbol{E}_1 = \\dfrac{1}{\\sqrt{3}} \\operatorname{diag}(2,-1,-1)$ and $\\boldsymbol{E}_2$ is the symmetric shear tensor with components $(\\boldsymbol{E}_2)_{12} = (\\boldsymbol{E}_2)_{21} = 1$ and zeros elsewhere. Choose $\\theta(t)$ according to the specific test case. Construct the deviatoric stress as $\\boldsymbol{s}(t) = \\sqrt{J_2(t)} \\, \\boldsymbol{s}_{\\mathrm{dir}}(t)$, where $J_2(t) = \\dfrac{q(t)^2}{3}$, and the full stress $\\boldsymbol{\\sigma}(t) = p(t) \\boldsymbol{I} + \\boldsymbol{s}(t)$.\n\nStarting from the core definitions of invariants, the MCC yield function, and the associated flow rule, derive the gradient $\\nabla_{\\boldsymbol{\\sigma}} f(\\boldsymbol{\\sigma}(t))$ and its Frobenius norm $\\left\\|\\nabla_{\\boldsymbol{\\sigma}} f(\\boldsymbol{\\sigma}(t))\\right\\|_F$ along the path. Then, propose and implement a substep partitioning of the parameter $t \\in [0,1]$ that aligns with the path of maximal gradient norm, in the following sense:\n- Let $w(t) = \\left\\|\\nabla_{\\boldsymbol{\\sigma}} f(\\boldsymbol{\\sigma}(t))\\right\\|_F$ be a nonnegative weight function over $[0,1]$.\n- Given a fixed number of substeps $N$, define substep boundaries $0 = t_0 < t_1 < \\dots < t_N = 1$ such that each subinterval carries equal measure of the cumulative weight $\\int_0^{t_k} w(\\tau) \\, d\\tau$, i.e., $\\int_0^{t_k} w(\\tau) \\, d\\tau = \\dfrac{k}{N} \\int_0^1 w(\\tau) \\, d\\tau$ for $k = 0,1,\\dots,N$.\n\nFor each partition (uniform and the proposed gradient-norm-aligned partition), approximate the net plastic strain direction over the path by midpoint quadrature:\n- On each subinterval $[t_{k-1}, t_k]$, evaluate $\\nabla_{\\boldsymbol{\\sigma}} f$ at $t_{k-1/2} = \\dfrac{t_{k-1} + t_k}{2}$, form the incremental contribution $\\boldsymbol{d}_k = \\nabla_{\\boldsymbol{\\sigma}} f\\left(\\boldsymbol{\\sigma}(t_{k-1/2})\\right) \\, \\Delta t_k$ with $\\Delta t_k = t_k - t_{k-1}$, then sum $\\boldsymbol{D} = \\sum_{k=1}^N \\boldsymbol{d}_k$. The approximated direction is $\\widehat{\\boldsymbol{D}} = \\dfrac{\\boldsymbol{D}}{\\|\\boldsymbol{D}\\|_F}$, where $\\|\\cdot\\|_F$ is the Frobenius norm on $\\mathbb{R}^{3 \\times 3}$.\n- Compute a high-fidelity reference direction $\\widehat{\\boldsymbol{D}}_{\\mathrm{ref}}$ using a fine partition of $[0,1]$ into $N_{\\mathrm{ref}}$ uniform subintervals with midpoint quadrature (take $N_{\\mathrm{ref}} = 5000$).\n\nDefine the direction error for an approximation $\\widehat{\\boldsymbol{D}}$ as $e = \\left\\|\\widehat{\\boldsymbol{D}} - \\widehat{\\boldsymbol{D}}_{\\mathrm{ref}}\\right\\|_F$.\n\nTest Suite:\n- Case $1$: $M = 1.2$, $p_c = 250$, $N = 12$, $\\theta(t) = \\dfrac{\\pi}{2} t$ (deviatoric direction rotates). Angles must be in radians.\n- Case $2$: $M = 1.2$, $p_c = 250$, $N = 4$, $\\theta(t) = \\dfrac{\\pi}{2} t$ (coarser stepping). Angles must be in radians.\n- Case $3$: $M = 0.9$, $p_c = 250$, $N = 12$, $\\theta(t) = \\dfrac{\\pi}{4}$ (constant deviatoric direction). Angles must be in radians.\n\nFor each case, compute two errors: $e_{\\mathrm{unif}}$ for uniform substeps $t_k = \\dfrac{k}{N}$, and $e_{\\mathrm{grad}}$ for the gradient-norm-aligned substeps defined by equal cumulative weight. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets of the form $[e_{\\mathrm{unif,1}}, e_{\\mathrm{grad,1}}, e_{\\mathrm{unif,2}}, e_{\\mathrm{grad,2}}, e_{\\mathrm{unif,3}}, e_{\\mathrm{grad,3}}]$, where each entry is a floating-point number. No physical units are required in the output; angles must be in radians.",
            "solution": "The problem requires the comparison of two numerical integration schemes for determining the net plastic strain direction in a Modified Cam-Clay (MCC) material subjected to a prescribed stress path. The first scheme uses uniform subintervals, while the second employs a physically-motivated partitioning strategy that aligns subintervals with the magnitude of the yield surface gradient. The core of the task involves deriving the gradient, defining the partitioning schemes, performing the numerical integration, and quantifying the accuracy of each scheme against a high-fidelity reference solution.\n\nThe solution proceeds in four principal steps:\n1.  Analytical derivation of the gradient of the MCC yield function, $\\nabla_{\\boldsymbol{\\sigma}} f$, which is proportional to the plastic strain increment direction.\n2.  Analytical derivation of the Frobenius norm of this gradient, $\\left\\|\\nabla_{\\boldsymbol{\\sigma}} f\\right\\|_F$, which serves as a weight function $w(t)$ for the adaptive partitioning.\n3.  Specification of the two partitioning schemes: a uniform partition and a gradient-norm-aligned partition. The latter is constructed by ensuring each subinterval contributes equally to the total cumulative weight, $\\int w(t) dt$.\n4.  Implementation of a numerical quadrature (midpoint rule) to approximate the integrated plastic strain direction vector for each scheme and calculation of the approximation error relative to a reference solution.\n\nLet us begin with the necessary derivations.\n\n**1. Derivation of the Plastic Flow Direction Vector**\n\nThe plastic flow is governed by an associated flow rule, meaning the increment of plastic strain, $\\Delta\\boldsymbol{\\varepsilon}^p$, is normal to the yield surface $f(\\boldsymbol{\\sigma}) = 0$. The direction of plastic flow is therefore given by the gradient of the yield function with respect to stress, $\\nabla_{\\boldsymbol{\\sigma}} f$. The yield function is given as $f(p,q,p_c) = \\dfrac{q^2}{M^2} + p(p - p_c)$. Since $f$ is expressed in terms of stress invariants $p$ and $q$, we use the chain rule:\n$$\n\\nabla_{\\boldsymbol{\\sigma}} f = \\frac{\\partial f}{\\partial \\boldsymbol{\\sigma}} = \\frac{\\partial f}{\\partial p} \\frac{\\partial p}{\\partial \\boldsymbol{\\sigma}} + \\frac{\\partial f}{\\partial q} \\frac{\\partial q}{\\partial \\boldsymbol{\\sigma}}\n$$\nThe partial derivatives of $f$ with respect to the invariants are:\n$$\n\\frac{\\partial f}{\\partial p} = 2p - p_c \\quad \\text{and} \\quad \\frac{\\partial f}{\\partial q} = \\frac{2q}{M^2}\n$$\nThe derivatives of the invariants with respect to the stress tensor $\\boldsymbol{\\sigma}$ are standard results in continuum mechanics. For the mean stress $p = \\frac{1}{3}\\operatorname{tr}(\\boldsymbol{\\sigma}) = \\frac{1}{3}\\boldsymbol{I}:\\boldsymbol{\\sigma}$, we have:\n$$\n\\frac{\\partial p}{\\partial \\boldsymbol{\\sigma}} = \\frac{1}{3}\\boldsymbol{I}\n$$\nFor the deviatoric invariant $q = \\sqrt{3J_2}$, where $J_2 = \\frac{1}{2}\\boldsymbol{s}:\\boldsymbol{s}$ and $\\boldsymbol{s} = \\boldsymbol{\\sigma} - p\\boldsymbol{I}$ is the deviatoric stress, we find:\n$$\n\\frac{\\partial q}{\\partial \\boldsymbol{\\sigma}} = \\frac{\\partial q}{\\partial J_2} \\frac{\\partial J_2}{\\partial \\boldsymbol{s}} : \\frac{\\partial \\boldsymbol{s}}{\\partial \\boldsymbol{\\sigma}} = \\left(\\frac{\\sqrt{3}}{2\\sqrt{J_2}}\\right) (\\boldsymbol{s}) : \\left(\\mathbb{I} - \\frac{1}{3}\\boldsymbol{I} \\otimes \\boldsymbol{I}\\right) = \\frac{3}{2q} \\boldsymbol{s}\n$$\nwhere $\\mathbb{I}$ is the fourth-order symmetric identity tensor and we used $\\operatorname{tr}(\\boldsymbol{s}) = 0$. This result is valid for $q \\neq 0$.\n\nSubstituting these components back into the chain rule expression yields the gradient:\n$$\n\\nabla_{\\boldsymbol{\\sigma}} f = (2p - p_c)\\left(\\frac{1}{3}\\boldsymbol{I}\\right) + \\left(\\frac{2q}{M^2}\\right)\\left(\\frac{3}{2q}\\boldsymbol{s}\\right) = \\frac{2p - p_c}{3}\\boldsymbol{I} + \\frac{3}{M^2}\\boldsymbol{s}\n$$\nThis tensor, $\\nabla_{\\boldsymbol{\\sigma}} f$, represents the direction of the plastic strain increment at a given stress state $\\boldsymbol{\\sigma}$.\n\n**2. Derivation of the Gradient Norm (Weight Function)**\n\nThe proposed substepping strategy uses the magnitude of the gradient vector, quantified by its Frobenius norm, as a weight function $w(t) = \\left\\|\\nabla_{\\boldsymbol{\\sigma}} f(\\boldsymbol{\\sigma}(t))\\right\\|_F$. The gradient is a sum of two orthogonal tensors: a volumetric part proportional to the identity tensor $\\boldsymbol{I}$ and a deviatoric part proportional to $\\boldsymbol{s}$. Their orthogonality is confirmed by the Frobenius inner product: $\\boldsymbol{I}:\\boldsymbol{s} = \\operatorname{tr}(\\boldsymbol{s}) = 0$.\nThe squared Frobenius norm is therefore the sum of the squared norms of the two parts:\n$$\n\\left\\|\\nabla_{\\boldsymbol{\\sigma}} f\\right\\|_F^2 = \\left\\|\\frac{2p - p_c}{3}\\boldsymbol{I}\\right\\|_F^2 + \\left\\|\\frac{3}{M^2}\\boldsymbol{s}\\right\\|_F^2 = \\left(\\frac{2p - p_c}{3}\\right)^2 \\|\\boldsymbol{I}\\|_F^2 + \\left(\\frac{3}{M^2}\\right)^2 \\|\\boldsymbol{s}\\|_F^2\n$$\nThe norms of the basis tensors are $\\|\\boldsymbol{I}\\|_F^2 = 3$ and $\\|\\boldsymbol{s}\\|_F^2 = \\boldsymbol{s}:\\boldsymbol{s} = 2J_2 = \\frac{2}{3}q^2$. Substituting these gives:\n$$\n\\left\\|\\nabla_{\\boldsymbol{\\sigma}} f\\right\\|_F^2 = \\frac{(2p - p_c)^2}{9} \\cdot 3 + \\frac{9}{M^4} \\cdot \\frac{2}{3}q^2 = \\frac{(2p - p_c)^2}{3} + \\frac{6q^2}{M^4}\n$$\nNow, we express this norm as a function of the parameter $t$ by substituting the prescribed stress path definitions:\n$p(t) = p_c \\sin^2\\left(\\frac{\\pi t}{2}\\right)$\n$q(t) = M \\sqrt{p(t)(p_c - p(t))} = M p_c \\sin\\left(\\frac{\\pi t}{2}\\right)\\cos\\left(\\frac{\\pi t}{2}\\right) = \\frac{M p_c}{2}\\sin(\\pi t)$\nThe terms in the norm expression become:\n$2p(t) - p_c = 2 p_c \\sin^2\\left(\\frac{\\pi t}{2}\\right) - p_c = -p_c\\left(1 - 2\\sin^2\\left(\\frac{\\pi t}{2}\\right)\\right) = -p_c \\cos(\\pi t)$\n$q(t)^2 = \\frac{M^2 p_c^2}{4}\\sin^2(\\pi t)$\nSubstituting these into the norm equation provides the final expression for the weight function squared:\n$$\nw(t)^2 = \\left\\|\\nabla_{\\boldsymbol{\\sigma}} f(t)\\right\\|_F^2 = \\frac{(-p_c \\cos(\\pi t))^2}{3} + \\frac{6}{M^4}\\left(\\frac{M^2 p_c^2}{4}\\sin^2(\\pi t)\\right) = \\frac{p_c^2 \\cos^2(\\pi t)}{3} + \\frac{3 p_c^2}{2M^2}\\sin^2(\\pi t)\n$$\nThus, the weight function is $w(t) = p_c \\sqrt{\\frac{1}{3}\\cos^2(\\pi t) + \\frac{3}{2M^2}\\sin^2(\\pi t)}$.\n\n**3. Substep Partitioning Schemes**\n\nGiven $N$ substeps, we define a partition $0 = t_0 < t_1 < \\dots < t_N = 1$.\n\n- **Uniform Partition**: This is the simplest scheme, where each subinterval has equal width in the parameter $t$. The nodes are given by $t_k = \\frac{k}{N}$ for $k = 0, 1, \\dots, N$.\n\n- **Gradient-Norm-Aligned Partition**: This scheme aims to distribute the numerical effort according to the \"activity\" of the plastic flow, measured by $w(t)$. The partition nodes $t_k$ are chosen such that each subinterval $[t_{k-1}, t_k]$ contains an equal amount of the total integrated weight. Let $H(t) = \\int_0^t w(\\tau) d\\tau$ be the cumulative weight function. The condition is:\n$$\nH(t_k) = \\frac{k}{N} H(1) \\quad \\text{for } k = 1, \\dots, N\n$$\nSince $H(t)$ does not have a simple closed-form antiderivative, we must solve for each $t_k$ numerically. For a given $k$, we find the root of the equation $g(t) = H(t) - \\frac{k}{N}H(1) = 0$. This is achieved by first computing the total integral $H(1) = \\int_0^1 w(\\tau) d\\tau$ using numerical quadrature (e.g., `scipy.integrate.quad`) and then using a root-finding algorithm (e.g., `scipy.optimize.brentq`) to find each $t_k$ in the interval $(t_{k-1}, 1]$.\n\n**4. Numerical Approximation and Error Metric**\n\nThe net plastic strain direction over the path is proportional to the integral $\\int_0^1 \\nabla_{\\boldsymbol{\\sigma}} f(\\boldsymbol{\\sigma}(t)) dt$. We approximate this integral, denoted by the tensor $\\boldsymbol{D}$, using a midpoint quadrature rule over a given partition $\\{t_k\\}_{k=0}^N$:\n$$\n\\boldsymbol{D} = \\sum_{k=1}^N \\nabla_{\\boldsymbol{\\sigma}} f\\left(\\boldsymbol{\\sigma}(t_{k-1/2})\\right) \\Delta t_k\n$$\nwhere $\\Delta t_k = t_k - t_{k-1}$ and $t_{k-1/2} = \\frac{t_{k-1} + t_k}{2}$. The final approximated direction is the normalized tensor $\\widehat{\\boldsymbol{D}} = \\frac{\\boldsymbol{D}}{\\|\\boldsymbol{D}\\|_F}$.\n\nTo assess accuracy, a high-fidelity reference direction, $\\widehat{\\boldsymbol{D}}_{\\mathrm{ref}}$, is computed using the same midpoint rule but on a very fine uniform partition of $N_{\\mathrm{ref}} = 5000$ subintervals. The error of an approximation $\\widehat{\\boldsymbol{D}}$ is then calculated as the Frobenius norm of the difference:\n$$\ne = \\left\\|\\widehat{\\boldsymbol{D}} - \\widehat{\\boldsymbol{D}}_{\\mathrm{ref}}\\right\\|_F\n$$\nThis procedure is applied to both the uniform and gradient-norm-aligned partitions for each test case, yielding the errors $e_{\\mathrm{unif}}$ and $e_{\\mathrm{grad}}$ respectively. The expectation is that $e_{\\mathrm{grad}} < e_{\\mathrm{unif}}$, demonstrating the superiority of the adaptive scheme.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate, optimize\n\ndef solve():\n    \"\"\"\n    Solves the problem of comparing substepping strategies for plasticity\n    integration with the Modified Cam-Clay model.\n    \"\"\"\n\n    # --- Constants and Basis Tensors ---\n    E1 = (1 / np.sqrt(3)) * np.diag([2.0, -1.0, -1.0])\n    E2 = np.array([[0.0, 1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 0.0, 0.0]])\n    ID_TENSOR = np.eye(3)\n    N_REF = 5000\n\n    # --- Path-dependent Helper Functions ---\n    def p_func(t, pc):\n        \"\"\"Mean stress p as a function of t.\"\"\"\n        return pc * np.sin(0.5 * np.pi * t)**2\n\n    def q_func(t, M, pc):\n        \"\"\"Deviatoric invariant q as a function of t.\"\"\"\n        return (M * pc / 2.0) * np.sin(np.pi * t)\n\n    def theta_func(t, theta_type):\n        \"\"\"Deviatoric rotation angle theta as a function of t.\"\"\"\n        if theta_type == 'pi/2*t':\n            return 0.5 * np.pi * t\n        elif theta_type == 'pi/4':\n            # This is a constant function of t\n            return 0.25 * np.pi\n        else:\n            raise ValueError(f\"Unknown theta function type: {theta_type}\")\n\n    def get_stress_and_gradient(t, M, pc, theta_type):\n        \"\"\"\n        Computes stress tensor and gradient of yield function at a given t.\n        \"\"\"\n        p_val = p_func(t, pc)\n        q_val = q_func(t, M, pc)\n        \n        # Deviatoric stress s\n        theta_val = theta_func(t, theta_type)\n        s_dir_val = np.cos(theta_val) * E1 + np.sin(theta_val) * E2\n        s_val = (q_val / np.sqrt(3.0)) * s_dir_val\n        \n        # Gradient of yield function\n        grad_f = ((2.0 * p_val - pc) / 3.0) * ID_TENSOR + (3.0 / M**2) * s_val\n        \n        return grad_f\n\n    def w_func(t, M, pc):\n        \"\"\"\n        Weight function: Frobenius norm of the yield function gradient.\n        This is the analytical simplified form.\n        \"\"\"\n        if -1e-9 < t < 1e-9 or 1-1e-9 < t < 1+1e-9:\n             return pc / np.sqrt(3.0)\n\n        cos_pit = np.cos(np.pi * t)\n        sin_pit = np.sin(np.pi * t)\n        \n        term1 = cos_pit**2 / 3.0\n        term2 = (3.0 / (2.0 * M**2)) * sin_pit**2\n        \n        return pc * np.sqrt(term1 + term2)\n\n    def compute_D_hat(partition, M, pc, theta_type):\n        \"\"\"\n        Approximates the integrated plastic strain direction tensor using\n        midpoint quadrature over a given partition.\n        \"\"\"\n        D_sum = np.zeros((3, 3))\n        for k in range(1, len(partition)):\n            t_k_minus_1 = partition[k-1]\n            t_k = partition[k]\n            dt_k = t_k - t_k_minus_1\n            t_mid = 0.5 * (t_k_minus_1 + t_k)\n            \n            grad_mid = get_stress_and_gradient(t_mid, M, pc, theta_type)\n            D_sum += grad_mid * dt_k\n            \n        D_norm = np.linalg.norm(D_sum, 'fro')\n        if D_norm < 1e-15:\n            # This case should not be reached with the given paths\n            return D_sum\n        return D_sum / D_norm\n\n    # --- Test Suite ---\n    test_cases = [\n        {'M': 1.2, 'pc': 250.0, 'N': 12, 'theta_type': 'pi/2*t'},\n        {'M': 1.2, 'pc': 250.0, 'N': 4,  'theta_type': 'pi/2*t'},\n        {'M': 0.9, 'pc': 250.0, 'N': 12, 'theta_type': 'pi/4'}\n    ]\n    \n    results = []\n    \n    for case_params in test_cases:\n        M = case_params['M']\n        pc = case_params['pc']\n        N = case_params['N']\n        theta_type = case_params['theta_type']\n\n        # 1. Compute Reference Solution\n        t_ref_partition = np.linspace(0.0, 1.0, N_REF + 1)\n        D_hat_ref = compute_D_hat(t_ref_partition, M, pc, theta_type)\n\n        # 2. Uniform Partition Calculation\n        t_unif_partition = np.linspace(0.0, 1.0, N + 1)\n        D_hat_unif = compute_D_hat(t_unif_partition, M, pc, theta_type)\n        error_unif = np.linalg.norm(D_hat_unif - D_hat_ref, 'fro')\n        results.append(error_unif)\n        \n        # 3. Gradient-Norm-Aligned Partition Calculation\n        integrand = lambda t: w_func(t, M, pc)\n        total_weight, _ = integrate.quad(integrand, 0, 1)\n\n        t_grad_partition = [0.0]\n        \n        def root_func(t, target_weight):\n            res, _ = integrate.quad(integrand, 0.0, t)\n            return res - target_weight\n        \n        for k in range(1, N):\n            target_weight_k = (k / N) * total_weight\n            # The root must be between the last point and 1\n            t_k = optimize.brentq(root_func, t_grad_partition[-1], 1.0, args=(target_weight_k,))\n            t_grad_partition.append(t_k)\n            \n        t_grad_partition.append(1.0)\n        t_grad_partition = np.array(t_grad_partition)\n\n        D_hat_grad = compute_D_hat(t_grad_partition, M, pc, theta_type)\n        error_grad = np.linalg.norm(D_hat_grad - D_hat_ref, 'fro')\n        results.append(error_grad)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Beyond being a tool for error control, substepping provides a powerful framework for conducting numerical experiments that illuminate complex material behaviors. This exercise uses this framework to explore the crucial concept of path-dependency in materials with non-associated plastic flow, where the flow direction is not normal to the yield surface. By integrating the plastic response along a prescribed path using different sequences of non-normal flow, you will numerically demonstrate that the final accumulated plastic strain is sensitive to the history of loading, highlighting how numerical methods can serve as a virtual laboratory for understanding profound physical principles. ",
            "id": "3566159",
            "problem": "Consider a two-dimensional, plane-stress idealization of a convex yield surface and a plastic flow rule with controlled non-normality at the substep level. Let the yield function be defined as $F(\\boldsymbol{\\sigma}) = \\sqrt{\\sigma_1^2 + \\beta\\,\\sigma_2^2} - \\sigma_y$, where $\\boldsymbol{\\sigma} = (\\sigma_1,\\sigma_2)$ is the stress vector, $\\beta > 0$ is a shape parameter, and $\\sigma_y > 0$ is the yield stress. The outward unit normal to the yield surface at a point $\\boldsymbol{\\sigma}$ is $\\boldsymbol{n}(\\boldsymbol{\\sigma}) = \\dfrac{\\nabla F(\\boldsymbol{\\sigma})}{\\|\\nabla F(\\boldsymbol{\\sigma})\\|}$, where $\\nabla F$ is the gradient of $F$ with respect to $\\boldsymbol{\\sigma}$, and $\\|\\cdot\\|$ denotes the Euclidean norm. Parameterize the yield surface by an angle $\\theta \\in [0,2\\pi)$ via the mapping $\\boldsymbol{\\sigma}(\\theta) = \\left(\\sigma_y \\cos\\theta,\\,\\dfrac{\\sigma_y}{\\sqrt{\\beta}}\\sin\\theta\\right)$, so that $F(\\boldsymbol{\\sigma}(\\theta)) = 0$ holds identically. From the definition of $F$, the gradient at $\\boldsymbol{\\sigma}(\\theta)$ is $\\nabla F(\\boldsymbol{\\sigma}(\\theta)) = \\left(\\dfrac{\\sigma_1}{\\sigma_y},\\,\\dfrac{\\beta\\,\\sigma_2}{\\sigma_y}\\right) = \\left(\\cos\\theta,\\,\\sqrt{\\beta}\\,\\sin\\theta\\right)$, and the corresponding unit normal is $\\boldsymbol{n}(\\theta) = \\dfrac{\\left(\\cos\\theta,\\,\\sqrt{\\beta}\\,\\sin\\theta\\right)}{\\sqrt{\\cos^2\\theta + \\beta\\,\\sin^2\\theta}}$.\n\nA large plastic-loading increment is idealized as a traversal along the yield surface from an initial parametric angle $\\theta_0$ to a final angle $\\theta_T$, partitioned into $N$ equal substeps. Denote the uniform parametric increment per substep by $\\Delta\\theta = \\dfrac{\\theta_T - \\theta_0}{N}$, and the substep angles by $\\theta_j = \\theta_0 + j\\,\\Delta\\theta$ for $j = 0,1,\\dots,N-1$. At each substep $j$, enforce a controlled non-normality by constraining the angle between the plastic strain increment direction $\\Delta\\boldsymbol{\\varepsilon}^p_j$ and the current unit normal $\\boldsymbol{n}(\\theta_j)$ to a prescribed deviation $\\delta_j$ satisfying $|\\delta_j| \\le \\alpha_{\\max}$, where $\\alpha_{\\max} \\ge 0$ is given. Model the plastic strain increment direction as a rotation of the normal by $\\delta_j$ in the stress-plane using the planar rotation matrix\n$$\n\\boldsymbol{R}(\\delta_j) = \\begin{bmatrix}\n\\cos\\delta_j & -\\sin\\delta_j \\\\\n\\sin\\delta_j & \\cos\\delta_j\n\\end{bmatrix},\n$$\nand let the plastic strain increment be\n$$\n\\Delta\\boldsymbol{\\varepsilon}^p_j = w_j\\,\\boldsymbol{R}(\\delta_j)\\,\\boldsymbol{n}(\\theta_j),\n$$\nwith a positive weight $w_j = \\Delta\\theta$. The cumulative plastic strain increment over the large increment is then\n$$\n\\Delta\\boldsymbol{\\varepsilon}^p_{\\text{tot}} = \\sum_{j=0}^{N-1} \\Delta\\boldsymbol{\\varepsilon}^p_j = \\sum_{j=0}^{N-1} \\Delta\\theta\\,\\boldsymbol{R}(\\delta_j)\\,\\boldsymbol{n}(\\theta_j).\n$$\nDefine the final unit normal as $\\boldsymbol{n}_T = \\boldsymbol{n}(\\theta_T)$. Quantify the cumulative deviation of the integrated plastic flow from normality by the angle\n$$\n\\varphi = \\arccos\\left( \\dfrac{\\Delta\\boldsymbol{\\varepsilon}^p_{\\text{tot}} \\cdot \\boldsymbol{n}_T}{\\left\\|\\Delta\\boldsymbol{\\varepsilon}^p_{\\text{tot}}\\right\\|\\,\\left\\|\\boldsymbol{n}_T\\right\\|} \\right).\n$$\nAll angles must be expressed in radians. The goal is to analyze how the sequencing of the deviations $\\{\\delta_j\\}$, under the constraint $|\\delta_j| \\le \\alpha_{\\max}$ for each substep, affects the final angle $\\varphi$ after a large increment.\n\nImplement a program that, for each test case below, constructs the sequence $\\{\\delta_j\\}$ according to the specified pattern, computes $\\Delta\\boldsymbol{\\varepsilon}^p_{\\text{tot}}$ and then $\\varphi$, and returns the value of $\\varphi$ rounded to six decimal places. Treat all quantities as dimensionless.\n\nUse the following test suite, each case specified as $(\\beta, \\sigma_y, \\theta_0, \\theta_T, N, \\alpha_{\\max}, \\text{sequence\\_type}, \\text{seed})$, with $\\text{seed}$ used only for random sequencing:\n\n- Case $1$ (happy path, sustained non-normality): $(2.0,\\,100.0,\\,0.0,\\,\\dfrac{\\pi}{2},\\,40,\\,0.35,\\,\\text{constant},\\,\\text{None})$, where $\\delta_j = +\\alpha_{\\max}$ for all $j$.\n- Case $2$ (edge case, associated flow): $(2.0,\\,100.0,\\,0.0,\\,\\dfrac{\\pi}{2},\\,40,\\,0.0,\\,\\text{constant},\\,\\text{None})$, where $\\delta_j = 0$ for all $j$.\n- Case $3$ (sequencing with cancellation, alternating): $(2.0,\\,100.0,\\,0.0,\\,\\dfrac{\\pi}{2},\\,40,\\,0.35,\\,\\text{alternating},\\,\\text{None})$, where $\\delta_j = +\\alpha_{\\max}$ for even $j$ and $\\delta_j = -\\alpha_{\\max}$ for odd $j$.\n- Case $4$ (sequencing with cancellation, blocked): $(2.0,\\,100.0,\\,0.0,\\,\\dfrac{\\pi}{2},\\,40,\\,0.35,\\,\\text{blocked},\\,\\text{None})$, where $\\delta_j = +\\alpha_{\\max}$ for $j \\in \\{0,1,\\dots,\\dfrac{N}{2}-1\\}$ and $\\delta_j = -\\alpha_{\\max}$ for $j \\in \\{\\dfrac{N}{2},\\dots,N-1\\}$.\n- Case $5$ (randomized sequencing with zero mean deviation): $(2.0,\\,100.0,\\,0.0,\\,\\dfrac{\\pi}{2},\\,40,\\,0.35,\\,\\text{random},\\,42)$, where the multiset $\\{\\delta_j\\}$ contains exactly $\\dfrac{N}{2}$ entries equal to $+\\alpha_{\\max}$ and $\\dfrac{N}{2}$ entries equal to $-\\alpha_{\\max}$, randomly permuted using the given seed.\n\nYour program should produce a single line of output containing the five results $\\varphi$ as a comma-separated list enclosed in square brackets (for example, $[\\text{result1},\\text{result2},\\text{result3},\\text{result4},\\text{result5}]$), in radians, each rounded to six decimal places.",
            "solution": "The problem is valid as it is scientifically grounded in the principles of computational plasticity, well-posed with a clear and complete set of definitions and data, and objectively formulated. The goal is to compute the cumulative deviation angle, $\\varphi$, of a plastic strain path from the final normal direction for several loading scenarios characterized by different sequences of non-normality. This requires a numerical integration of plastic strain increments along a prescribed trajectory on an anisotropic yield surface.\n\nThe algorithmic procedure to compute $\\varphi$ for each test case is as follows:\n\n1.  **Problem Discretization**: The continuous plastic loading path along the yield surface, parameterized by an angle $\\theta$ from an initial angle $\\theta_0$ to a final angle $\\theta_T$, is discretized into $N$ uniform substeps. The parametric increment for each substep is $\\Delta\\theta = \\dfrac{\\theta_T - \\theta_0}{N}$. The discrete angles along the path are given by $\\theta_j = \\theta_0 + j\\,\\Delta\\theta$ for $j = 0, 1, \\dots, N-1$.\n\n2.  **Substep Plastic Strain Increment Calculation**: For each substep $j$, the plastic strain increment $\\Delta\\boldsymbol{\\varepsilon}^p_j$ is computed. This involves several components:\n    a.  **Unit Normal Vector**: The direction of associative plastic flow is defined by the outward unit normal to the yield surface, $\\boldsymbol{n}$. At a point on the yield surface parameterized by $\\theta_j$, the gradient vector is given as $\\nabla F(\\boldsymbol{\\sigma}(\\theta_j)) = \\left(\\cos\\theta_j, \\sqrt{\\beta}\\sin\\theta_j\\right)$. The corresponding unit normal vector $\\boldsymbol{n}(\\theta_j)$ is found by normalizing this gradient:\n        $$\n        \\boldsymbol{n}(\\theta_j) = \\frac{\\left(\\cos\\theta_j, \\sqrt{\\beta}\\sin\\theta_j\\right)}{\\left\\|\\left(\\cos\\theta_j, \\sqrt{\\beta}\\sin\\theta_j\\right)\\right\\|} = \\frac{\\left(\\cos\\theta_j, \\sqrt{\\beta}\\sin\\theta_j\\right)}{\\sqrt{\\cos^2\\theta_j + \\beta\\sin^2\\theta_j}}\n        $$\n    b.  **Non-Normality**: The non-associativity of the flow rule is introduced by rotating the unit normal vector $\\boldsymbol{n}(\\theta_j)$ by a prescribed angle $\\delta_j$. The sequence of deviations $\\{\\delta_j\\}$ is determined by the `sequence_type` specified in each test case, with the constraint $|\\delta_j| \\le \\alpha_{\\max}$. The rotation is performed using the $2$D rotation matrix $\\boldsymbol{R}(\\delta_j)$:\n        $$\n        \\boldsymbol{R}(\\delta_j) = \\begin{bmatrix}\n        \\cos\\delta_j & -\\sin\\delta_j \\\\\n        \\sin\\delta_j & \\cos\\delta_j\n        \\end{bmatrix}\n        $$\n    c.  **Plastic Strain Increment**: The plastic strain increment for the substep is then calculated as the rotated normal vector scaled by a weight $w_j$, which is defined as the parametric step size $\\Delta\\theta$:\n        $$\n        \\Delta\\boldsymbol{\\varepsilon}^p_j = w_j\\,\\boldsymbol{R}(\\delta_j)\\,\\boldsymbol{n}(\\theta_j) = \\Delta\\theta\\,\\boldsymbol{R}(\\delta_j)\\,\\boldsymbol{n}(\\theta_j)\n        $$\n\n3.  **Cumulative Plastic Strain Increment**: The total plastic strain increment over the entire loading path, $\\Delta\\boldsymbol{\\varepsilon}^p_{\\text{tot}}$, is obtained by numerically integrating (i.e., summing) the increments from all substeps:\n    $$\n    \\Delta\\boldsymbol{\\varepsilon}^p_{\\text{tot}} = \\sum_{j=0}^{N-1} \\Delta\\boldsymbol{\\varepsilon}^p_j = \\Delta\\theta \\sum_{j=0}^{N-1} \\boldsymbol{R}(\\delta_j)\\,\\boldsymbol{n}(\\theta_j)\n    $$\n    Note that the parameter $\\sigma_y$ defines the size of the yield surface but does not influence the orientation of the unit normal vector or the final dimensionless angle $\\varphi$. Therefore, its value of $100.0$ does not affect the final results.\n\n4.  **Final Deviation Angle Calculation**: To quantify the cumulative effect of non-normality, the angle $\\varphi$ between the total plastic strain increment vector $\\Delta\\boldsymbol{\\varepsilon}^p_{\\text{tot}}$ and the unit normal at the end of the path, $\\boldsymbol{n}_T = \\boldsymbol{n}(\\theta_T)$, is computed. The angle is found using the definition of the dot product:\n    $$\n    \\varphi = \\arccos\\left( \\frac{\\Delta\\boldsymbol{\\varepsilon}^p_{\\text{tot}} \\cdot \\boldsymbol{n}_T}{\\left\\|\\Delta\\boldsymbol{\\varepsilon}^p_{\\text{tot}}\\right\\|\\,\\left\\|\\boldsymbol{n}_T\\right\\|} \\right)\n    $$\n    Since $\\boldsymbol{n}_T$ is a unit vector, its norm $\\left\\|\\boldsymbol{n}_T\\right\\|$ is $1$. The argument of the arccosine function must be clipped to the range $[-1, 1]$ to prevent domain errors arising from floating-point inaccuracies.\n\nThis computational procedure is applied to each of the five test cases, with the sequence of deviations $\\{\\delta_j\\}$ constructed as specified by the `sequence_type` parameter. The resulting values of $\\varphi$ are then rounded and reported. The different sequences (`constant`, `alternating`, `blocked`, `random`) are designed to investigate the path-dependent nature of the final accumulated plastic strain and its deviation from normality.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the cumulative deviation angle for plastic flow based on several\n    substepping strategies for non-normality.\n    \"\"\"\n    test_cases = [\n        # (beta, sigma_y, theta_0, theta_T, N, alpha_max, sequence_type, seed)\n        (2.0, 100.0, 0.0, np.pi / 2, 40, 0.35, 'constant', None),\n        (2.0, 100.0, 0.0, np.pi / 2, 40, 0.0, 'constant', None),\n        (2.0, 100.0, 0.0, np.pi / 2, 40, 0.35, 'alternating', None),\n        (2.0, 100.0, 0.0, np.pi / 2, 40, 0.35, 'blocked', None),\n        (2.0, 100.0, 0.0, np.pi / 2, 40, 0.35, 'random', 42),\n    ]\n\n    results = []\n\n    for case in test_cases:\n        beta, sigma_y, theta_0, theta_T, N, alpha_max, seq_type, seed = case\n\n        # Calculate uniform parametric increment per substep\n        delta_theta = (theta_T - theta_0) / N\n\n        # Generate the sequence of deviations {delta_j} based on the sequence type\n        deltas = np.zeros(N)\n        if seq_type == 'constant':\n            # For Case 1, delta_j = +alpha_max. For Case 2, alpha_max is 0, so delta_j = 0.\n            deltas.fill(alpha_max)\n        elif seq_type == 'alternating':\n            deltas[0::2] = alpha_max\n            deltas[1::2] = -alpha_max\n        elif seq_type == 'blocked':\n            half_N = N // 2\n            deltas[0:half_N] = alpha_max\n            deltas[half_N:] = -alpha_max\n        elif seq_type == 'random':\n            half_N = N // 2\n            # Create a multiset with N/2 positive and N/2 negative deviations\n            base_deltas = np.concatenate([np.full(half_N, alpha_max), np.full(half_N, -alpha_max)])\n            # Permute the multiset randomly using the specified seed\n            rng = np.random.default_rng(seed)\n            deltas = rng.permutation(base_deltas)\n\n        # Initialize the cumulative plastic strain increment\n        delta_eps_p_tot = np.array([0.0, 0.0])\n\n        # Sum increments over all substeps\n        for j in range(N):\n            theta_j = theta_0 + j * delta_theta\n            delta_j = deltas[j]\n\n            # 1. Compute the unit normal vector n(theta_j)\n            grad_F = np.array([np.cos(theta_j), np.sqrt(beta) * np.sin(theta_j)])\n            norm_grad_F = np.linalg.norm(grad_F)\n            n_j = grad_F / norm_grad_F\n\n            # 2. Construct the rotation matrix R(delta_j)\n            cos_d = np.cos(delta_j)\n            sin_d = np.sin(delta_j)\n            R_j = np.array([[cos_d, -sin_d], [sin_d, cos_d]])\n\n            # 3. Compute the plastic strain increment for the substep\n            # The weight w_j is given as delta_theta\n            delta_eps_p_j = delta_theta * np.dot(R_j, n_j)\n\n            # 4. Accumulate the total plastic strain increment\n            delta_eps_p_tot += delta_eps_p_j\n\n        # Compute the final deviation angle phi\n        # First, compute the final unit normal vector n_T = n(theta_T)\n        grad_F_T = np.array([np.cos(theta_T), np.sqrt(beta) * np.sin(theta_T)])\n        norm_grad_F_T = np.linalg.norm(grad_F_T)\n        n_T = grad_F_T / norm_grad_F_T\n\n        # Calculate phi using the dot product formula\n        dot_product = np.dot(delta_eps_p_tot, n_T)\n        norm_total_strain = np.linalg.norm(delta_eps_p_tot)\n        norm_nT = np.linalg.norm(n_T)  # This is 1.0 by definition\n\n        # Clip argument of arccos to [-1.0, 1.0] to handle potential floating-point errors\n        cos_phi = np.clip(dot_product / (norm_total_strain * norm_nT), -1.0, 1.0)\n        \n        phi = np.arccos(cos_phi)\n\n        results.append(round(phi, 6))\n    \n    # Print the final results in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}