{
    "hands_on_practices": [
        {
            "introduction": "一个天真的、单步的积分方案可能会完全错过应变增量内部发生的材料行为转变（从弹性到塑性）。本练习  采用一个简明的一维模型，通过量化“人为弹性间隙”来清晰地揭示这种积分失败。通过这个实践，您将理解为何事件检测是子步法最基本的形式，以及为何子步法对于保证计算精度至关重要，而不仅仅是一种优化手段。",
            "id": "3566116",
            "problem": "考虑一种岩土材料的小应变、率无关、一维弹塑性问题，该材料具有线性各向同性弹性和线性各向同性硬化特性。柯西应力用 $\\sigma$ 表示，总应变用 $\\varepsilon$ 表示，塑性应变用 $\\varepsilon^{p}$ 表示，标量累积塑性应变用 $\\kappa$ 表示。弹性定律为 $\\sigma = E \\, (\\varepsilon - \\varepsilon^{p})$，其中 $E$ 是弹性模量。屈服函数取为 $f(\\sigma,\\kappa) = \\lvert \\sigma \\rvert - (\\sigma_{y0} + H \\kappa)$，其中 $\\sigma_{y0}$ 是初始屈服应力，$H \\ge 0$ 是线性各向同性硬化模量。假设 Kuhn-Tucker 条件成立：$f \\le 0$，$\\dot{\\gamma} \\ge 0$，$f \\, \\dot{\\gamma} = 0$，其中 $\\dot{\\gamma}$ 是塑性乘子，并且 $\\dot{\\kappa} = \\lvert \\dot{\\varepsilon}^{p} \\rvert$。\n\n您必须在一个应变增量上对本构方程进行数值积分，该积分从一个已知的先前状态 $\\left( \\sigma_n, \\kappa_n \\right)$ 开始，并施加一个应变增量 $\\Delta \\varepsilon = \\varepsilon_{n+1} - \\varepsilon_n$。考虑两种时间积分策略：\n\n- 策略 $\\mathcal{U}$（非分裂单步显式分类）：根据先前的状态对整个增量进行分类。如果 $f(\\sigma_n,\\kappa_n) \\le 0$，则将整个步长视为弹性，即对整个增量设置 $\\Delta \\varepsilon^{p} = 0$。如果 $f(\\sigma_n,\\kappa_n)  0$，则以同样的方式将整个步长视为塑性。此策略不检测严格发生在增量内部的进入或离开塑性区的转换。\n\n- 策略 $\\mathcal{S}$（带 $f=0$ 事件检测的子步法）：检测增量内部最早的屈服面穿越点，并在参数 $\\lambda^\\star \\in [0,1]$ 处（此处 $f$ 等于 $0$）分割增量。在区间 $\\lambda \\in [0,\\lambda^\\star]$ 上，以 $\\Delta \\varepsilon^{p} = 0$ 进行弹性积分；然后在区间 $\\lambda \\in (\\lambda^\\star,1]$ 上，当且仅当穿越后 $f  0$ 时，（与弹塑性本构律一致地）进行塑性积分。在单个增量内，弹性试探应力按 $\\sigma(\\lambda) = \\sigma_n + E \\, \\Delta \\varepsilon \\, \\lambda$ 演化，而 $\\kappa$ 保持为 $\\kappa_n$ 直到塑性激活。\n\n将一个增量的人为弹性间隙定义为增量中真实响应为塑性（由策略 $\\mathcal{S}$ 确定）而策略 $\\mathcal{U}$ 错误地保持响应为弹性的那部分子集的应变长度（以 $\\varepsilon$ 为单位）；等效地，它是在 $f(\\sigma_n,\\kappa_n) \\le 0$ 时，集合 $\\{ \\lambda \\in [0,1] \\mid f(\\sigma(\\lambda),\\kappa_n)  0\\}$ 未被 $\\mathcal{U}$ 检测到的测度（以 $\\varepsilon$ 为单位）。策略 $\\mathcal{S}$ 相对于 $\\mathcal{U}$ 实现的人为弹性间隙的减小量，就是 $\\mathcal{U}$ 下的间隙与 $\\mathcal{S}$ 下的间隙之差（后者根据构造为零）。\n\n从上述基本定义出发，不调用任何预先推导的塑性积分公式，通过求解满足 $f(\\sigma(\\lambda^\\star),\\kappa_n) = 0$ 的最小 $\\lambda^\\star \\in [0,1]$（其中 $\\sigma(\\lambda) = \\sigma_n + E \\, \\Delta \\varepsilon \\, \\lambda$）来推导增量内部最早屈服面穿越的事件检测条件。当 $f(\\sigma_n,\\kappa_n) \\le 0$ 且 $f(\\sigma_n + E \\, \\Delta \\varepsilon,\\kappa_n)  0$ 时，用此条件计算 $\\lambda$ 的塑性子区间长度为 $\\max(0,1 - \\lambda^\\star)$，否则将其设为零。策略 $\\mathcal{U}$ 的人为弹性间隙是塑性子区间长度乘以 $\\lvert \\Delta \\varepsilon \\rvert$；策略 $\\mathcal{S}$ 的人为弹性间隙为零。每个测试用例要求的输出是人为弹性间隙的减小量，以应变单位（无量纲）表示的浮点数。\n\n实现一个完整的、可运行的程序，该程序为每个测试用例计算并返回如上定义的间隙减小量。使用以下测试套件，其中每个测试用例是一个元组 $\\left( E, \\sigma_{y0}, H, \\sigma_n, \\kappa_n, \\Delta \\varepsilon \\right)$：\n\n- 测试 A（正常路径，在接近结束时进入塑性区）：$\\left( E = 10000, \\, \\sigma_{y0} = 100, \\, H = 0, \\, \\sigma_n = 0, \\, \\kappa_n = 0, \\, \\Delta \\varepsilon = 0.015 \\right)$。\n- 测试 B（边界情况，在结束时恰好触及屈服面）：$\\left( E = 10000, \\, \\sigma_{y0} = 100, \\, H = 0, \\, \\sigma_n = 0, \\, \\kappa_n = 0, \\, \\Delta \\varepsilon = 0.010 \\right)$。\n- 测试 C（在结束时处于深度塑性状态）：$\\left( E = 10000, \\, \\sigma_{y0} = 100, \\, H = 0, \\, \\sigma_n = 0, \\, \\kappa_n = 0, \\, \\Delta \\varepsilon = 0.030 \\right)$。\n- 测试 D（初始应力非零且在弹性域内）：$\\left( E = 10000, \\, \\sigma_{y0} = 100, \\, H = 0, \\, \\sigma_n = 50, \\, \\kappa_n = 0, \\, \\Delta \\varepsilon = 0.010 \\right)$。\n- 测试 E（反向加载进入压缩区）：$\\left( E = 10000, \\, \\sigma_{y0} = 100, \\, H = 0, \\, \\sigma_n = 0, \\, \\kappa_n = 0, \\, \\Delta \\varepsilon = -0.025 \\right)$。\n- 测试 F（有硬化和先前的塑性历史）：$\\left( E = 10000, \\, \\sigma_{y0} = 100, \\, H = 1000, \\, \\sigma_n = 120, \\, \\kappa_n = 0.05, \\, \\Delta \\varepsilon = 0.050 \\right)$。\n- 测试 G（无穿越，全程保持弹性）：$\\left( E = 10000, \\, \\sigma_{y0} = 100, \\, H = 1000, \\, \\sigma_n = 120, \\, \\kappa_n = 0.05, \\, \\Delta \\varepsilon = 0.002 \\right)$。\n- 测试 H（零增量边缘情况）：$\\left( E = 10000, \\, \\sigma_{y0} = 100, \\, H = 0, \\, \\sigma_n = 0, \\, \\kappa_n = 0, \\, \\Delta \\varepsilon = 0.000 \\right)$。\n\n您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔的结果列表（例如，$\\left[ \\text{result}_1, \\text{result}_2, \\dots \\right]$）。每个结果必须是一个浮点数，表示以应变单位计的人为弹性间隙减小量，并按语言的默认字符串转换方式进行舍入。",
            "solution": "该问题要求推导并实现一个公式，用于计算从单步显式积分方案（策略 $\\mathcal{U}$）转向带事件检测的子步法方案（策略 $\\mathcal{S}$）时，人为弹性间隙的减小量。根据定义，策略 $\\mathcal{S}$ 的人为弹性间隙根据其构造为零。因此，所要求的减小量就是策略 $\\mathcal{U}$ 的人为弹性间隙。\n\n在策略 $\\mathcal{U}$ 下，只有当它错误地将本应是塑性的部分应变增量处理为弹性时，才会出现人为弹性间隙。这发生在以下一组特定条件下：\n1.  在增量开始时（时刻 $t_n$），状态必须是弹性的或位于屈服面上，即 $f(\\sigma_n, \\kappa_n) \\le 0$。如果状态已经是塑性的（$f(\\sigma_n, \\kappa_n)  0$），策略 $\\mathcal{U}$ 会正确地将增量处理为塑性，不会产生人为的*弹性*间隙。\n2.  在增量结束时（时刻 $t_{n+1}$），纯弹性试探状态必须位于屈服面之外。如果试探状态保持弹性，那么整个增量确实是弹性的，策略 $\\mathcal{U}$ 的分类将是正确的。\n\n分析过程是通过将这些条件形式化并推导出被错误处理为弹性的部分的大小来进行的。\n\n首先，我们定义相关量。增量开始时的屈服应力是先前累积塑性应变 $\\kappa_n$ 的函数：\n$$\n\\sigma_{y,n} = \\sigma_{y0} + H \\kappa_n\n$$\n因此，应力的弹性域是区间 $[-\\sigma_{y,n}, \\sigma_{y,n}]$。如果 $|\\sigma_n| \\le \\sigma_{y,n}$，则初始状态是弹性的。\n\n在一个弹性试探步中，应力随着跨越应变增量 $\\Delta\\varepsilon$ 的参数 $\\lambda \\in [0, 1]$ 线性演化：\n$$\n\\sigma(\\lambda) = \\sigma_n + E \\Delta\\varepsilon \\lambda\n$$\n增量结束时的试探应力对应于 $\\lambda=1$：\n$$\n\\sigma_{n+1}^{\\mathrm{trial}} = \\sigma(\\lambda=1) = \\sigma_n + E \\Delta\\varepsilon\n$$\n当且仅当 $|\\sigma_n| \\le \\sigma_{y,n}$ 且 $|\\sigma_{n+1}^{\\mathrm{trial}}|  \\sigma_{y,n}$ 时，存在人为弹性间隙。如果不满足这些条件，则间隙为零。\n\n假设满足产生间隙的条件，我们必须找到初始屈服点。这是应力路径 $\\sigma(\\lambda)$ 与屈服面相交的最小 $\\lambda^\\star \\in [0, 1]$ 值。屈服条件为 $f(\\sigma(\\lambda), \\kappa_n) = 0$，这等价于 $|\\sigma(\\lambda)| = \\sigma_{y,n}$。代入 $\\sigma(\\lambda)$ 的表达式：\n$$\n|\\sigma_n + E \\Delta\\varepsilon \\lambda^\\star| = \\sigma_{y,n}\n$$\n这个绝对值方程产生两个关于 $\\lambda^\\star$ 的线性方程：\n1.  $\\sigma_n + E \\Delta\\varepsilon \\lambda^\\star = \\sigma_{y,n} \\quad \\implies \\quad \\lambda_1^\\star = \\frac{\\sigma_{y,n} - \\sigma_n}{E \\Delta\\varepsilon}$\n2.  $\\sigma_n + E \\Delta\\varepsilon \\lambda^\\star = -\\sigma_{y,n} \\quad \\implies \\quad \\lambda_2^\\star = \\frac{-\\sigma_{y,n} - \\sigma_n}{E \\Delta\\varepsilon}$\n\n我们需要 $\\lambda^\\star$ 的最小非负解。初始状态是弹性的，所以 $-\\sigma_{y,n} \\le \\sigma_n \\le \\sigma_{y,n}$。这意味着 $\\sigma_{y,n} - \\sigma_n \\ge 0$ 且 $-\\sigma_{y,n} - \\sigma_n \\le 0$。如果 $E \\Delta\\varepsilon  0$，则 $\\lambda_1^\\star \\ge 0$ 且 $\\lambda_2^\\star \\le 0$。在正向“时间”（$\\lambda  0$）中唯一有效的穿越点是 $\\lambda_1^\\star$。如果 $E \\Delta\\varepsilon  0$，则 $\\lambda_1^\\star \\le 0$ 且 $\\lambda_2^\\star \\ge 0$。唯一有效的穿越点是 $\\lambda_2^\\star$。当 $\\Delta\\varepsilon = 0$ 时，$\\sigma_{n+1}^{\\mathrm{trial}} = \\sigma_n$，所以 $|\\sigma_{n+1}^{\\mathrm{trial}}| \\le \\sigma_{y,n}$，间隙为零。我们此后假设 $\\Delta\\varepsilon \\neq 0$。\n\n$\\lambda^\\star$ 的值必须在 $[0,1]$ 内。由于在步长结束前发生屈服（$|\\sigma_{n+1}^{\\mathrm{trial}}|  \\sigma_{y,n}$），可以保证 $\\lambda^\\star \\in [0,1)$。\n\n增量在 $\\lambda \\in [0, \\lambda^\\star]$ 区间是弹性的，在 $\\lambda \\in (\\lambda^\\star, 1]$ 区间变为塑性。策略 $\\mathcal{U}$ 假定整个增量是弹性的，因此在第二个子区间上产生了误差。这个塑性子区间的长度（用参数 $\\lambda$ 表示）是：\n$$\nL_\\lambda = 1 - \\lambda^\\star\n$$\n问题将人为弹性间隙 $G$ 定义为该长度乘以应变增量的大小 $|\\Delta\\varepsilon|$：\n$$\nG = (1 - \\lambda^\\star) |\\Delta\\varepsilon|\n$$\n\n我们现在代入 $\\lambda^\\star$ 的表达式：\n\n情况 1：受拉屈服（$\\sigma_{n+1}^{\\mathrm{trial}}  \\sigma_{y,n}$）。这意味着 $E \\Delta\\varepsilon  0$，所以如果 $E0$，则 $|\\Delta\\varepsilon| = \\Delta\\varepsilon$。\n$$\n\\lambda^\\star = \\lambda_1^\\star = \\frac{\\sigma_{y,n} - \\sigma_n}{E \\Delta\\varepsilon}\n$$\n$$\nG = \\left(1 - \\frac{\\sigma_{y,n} - \\sigma_n}{E \\Delta\\varepsilon}\\right) \\Delta\\varepsilon = \\frac{E \\Delta\\varepsilon - (\\sigma_{y,n} - \\sigma_n)}{E \\Delta\\varepsilon} \\Delta\\varepsilon = \\frac{\\sigma_n + E \\Delta\\varepsilon - \\sigma_{y,n}}{E} = \\frac{\\sigma_{n+1}^{\\mathrm{trial}} - \\sigma_{y,n}}{E}\n$$\n\n情况 2：受压屈服（$\\sigma_{n+1}^{\\mathrm{trial}}  -\\sigma_{y,n}$）。这意味着 $E \\Delta\\varepsilon  0$，所以如果 $E0$，则 $|\\Delta\\varepsilon| = -\\Delta\\varepsilon$。\n$$\n\\lambda^\\star = \\lambda_2^\\star = \\frac{-\\sigma_{y,n} - \\sigma_n}{E \\Delta\\varepsilon}\n$$\n$$\nG = \\left(1 - \\frac{-\\sigma_{y,n} - \\sigma_n}{E \\Delta\\varepsilon}\\right) (-\\Delta\\varepsilon) = \\frac{E \\Delta\\varepsilon - (-\\sigma_{y,n} - \\sigma_n)}{E \\Delta\\varepsilon} (-\\Delta\\varepsilon) = -\\frac{\\sigma_n + E \\Delta\\varepsilon + \\sigma_{y,n}}{E} = \\frac{-(\\sigma_{n+1}^{\\mathrm{trial}} + \\sigma_{y,n})}{E}\n$$\n由于 $\\sigma_{n+1}^{\\mathrm{trial}}  -\\sigma_{y,n}$，分子为正。\n\n两种情况都可以用一个使用绝对值的紧凑公式表示：\n$$\nG = \\frac{|\\sigma_{n+1}^{\\mathrm{trial}}| - \\sigma_{y,n}}{E}\n$$\n这巧妙地表示了与试探应力“超越”屈服面的那部分相对应的应变。\n\n计算每个测试用例的人为弹性间隙减小量的最终算法如下：\n1.  读取参数 $(E, \\sigma_{y0}, H, \\sigma_n, \\kappa_n, \\Delta\\varepsilon)$。\n2.  计算当前状态的屈服应力：$\\sigma_{y,n} = \\sigma_{y0} + H \\kappa_n$。\n3.  检查初始状态是否为塑性：如果 $|\\sigma_n|  \\sigma_{y,n}$，则间隙为 $0$。\n4.  如果初始状态是弹性的或在屈服面上，计算增量结束时的弹性试探应力：$\\sigma_{n+1}^{\\mathrm{trial}} = \\sigma_n + E \\Delta\\varepsilon$。\n5.  检查试探应力状态是否保持弹性：如果 $|\\sigma_{n+1}^{\\mathrm{trial}}| \\le \\sigma_{y,n}$，则间隙为 $0$。\n6.  如果试探应力状态是塑性的（$|\\sigma_{n+1}^{\\mathrm{trial}}|  \\sigma_{y,n}$），使用推导出的公式计算间隙：$G = (|\\sigma_{n+1}^{\\mathrm{trial}}| - \\sigma_{y,n}) / E$。\n7.  该测试用例的结果是 $G$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the reduction in artificial elastic gap for a series of\n    elastoplasticity test cases.\n    \"\"\"\n    # Test cases are tuples of (E, sigma_y0, H, sigma_n, kappa_n, delta_eps)\n    test_cases = [\n        # Test A: happy path, enters plastic near the end\n        (10000.0, 100.0, 0.0, 0.0, 0.0, 0.015),\n        # Test B: boundary, just touches yield at the end\n        (10000.0, 100.0, 0.0, 0.0, 0.0, 0.010),\n        # Test C: deeply plastic at the end\n        (10000.0, 100.0, 0.0, 0.0, 0.0, 0.030),\n        # Test D: nonzero initial stress within elastic domain\n        (10000.0, 100.0, 0.0, 50.0, 0.0, 0.010),\n        # Test E: reverse loading into compression\n        (10000.0, 100.0, 0.0, 0.0, 0.0, -0.025),\n        # Test F: with hardening and prior plastic history\n        (10000.0, 100.0, 1000.0, 120.0, 0.05, 0.050),\n        # Test G: no crossing, remains elastic throughout\n        (10000.0, 100.0, 1000.0, 120.0, 0.05, 0.002),\n        # Test H: zero increment edge case\n        (10000.0, 100.0, 0.0, 0.0, 0.0, 0.000),\n    ]\n\n    results = []\n    for case in test_cases:\n        E, sigma_y0, H, sigma_n, kappa_n, delta_eps = case\n\n        # 1. Calculate the yield stress for the current state n.\n        sigma_y_n = sigma_y0 + H * kappa_n\n\n        # 2. Check if the initial state is plastic. If so, strategy U is correct,\n        #    so the artificial elastic gap is zero.\n        if np.abs(sigma_n)  sigma_y_n:\n            gap = 0.0\n        else:\n            # 3. Calculate the elastic trial stress at the end of the increment.\n            sigma_trial_n_plus_1 = sigma_n + E * delta_eps\n\n            # 4. The artificial elastic gap exists only if the trial state is plastic.\n            #    The magnitude of the gap is the strain corresponding to the stress \"overshoot\".\n            #    f_trial represents the value of the yield function for the trial stress.\n            f_trial = np.abs(sigma_trial_n_plus_1) - sigma_y_n\n\n            if f_trial  0:\n                gap = f_trial / E\n            else:\n                # If f_trial = 0, the entire step is elastic, so no gap.\n                gap = 0.0\n        \n        results.append(gap)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "认识到子步法的必要性之后，下一个核心问题是如何高效地执行它。本练习  将您置于一个采用Drucker-Prager模型的真实三维情境中，要求您实现并比较两种常见的自适应子步策略。这两种策略分别基于屈服函数残差 $f$ 的大小和塑性流动方向 $\\boldsymbol{n}$ 的平稳性。通过这个练习，您将获得构建自适应算法的核心实践经验，并对不同误差度量在各种加载条件下的表现形成直观的认识。",
            "id": "3566154",
            "problem": "您的任务是设计并实现两种自适应子步终止准则，用于在小应变条件下积分一个相关联的 Drucker–Prager 弹塑性模型。这两种准则分别是：塑性流动方向的平稳性和残余屈服函数值。您的程序必须使用每种准则模拟在单个给定的总应变增量下的应力更新，并报告接受的子步数量以及最终应力状态的差异。所有量中，应力必须以兆帕（MPa）为单位表示，应变则为无量纲单位。\n\n请使用以下在计算岩土力学和小应变弹塑性领域中的基本背景和定义。\n\n1. 本构行为在屈服前为各向同性线弹性。对于小应变，应力增量由下式给出\n$$\n\\Delta \\boldsymbol{\\sigma} = \\lambda \\, \\mathrm{tr}(\\Delta \\boldsymbol{\\varepsilon}) \\, \\boldsymbol{I} + 2 \\mu \\, \\mathrm{dev}(\\Delta \\boldsymbol{\\varepsilon}),\n$$\n其中 $\\lambda$ 和 $\\mu$ 是拉梅 (Lamé) 常数，$\\boldsymbol{I}$ 是单位张量，$\\mathrm{tr}(\\cdot)$ 表示迹，$\\mathrm{dev}(\\cdot)$ 表示偏量投影。拉梅常数通过杨氏模量 (Young’s modulus) $E$ 和泊松比 (Poisson’s ratio) $\\nu$ 关系表示为\n$$\n\\lambda = \\frac{E \\nu}{(1+\\nu)(1-2\\nu)}, \\quad \\mu = \\frac{E}{2(1+\\nu)}.\n$$\n\n2. 带有各向同性硬化的相关联 Drucker–Prager 屈服函数为\n$$\nf(\\boldsymbol{\\sigma}, \\kappa) = \\alpha \\, I_1 + \\sqrt{J_2} - \\left(\\sigma_{y0} + H \\kappa \\right),\n$$\n其中 $I_1 = \\mathrm{tr}(\\boldsymbol{\\sigma})$，$J_2 = \\tfrac{1}{2} \\, \\mathrm{dev}(\\boldsymbol{\\sigma}) : \\mathrm{dev}(\\boldsymbol{\\sigma})$，$\\alpha$ 是给定的摩擦参数，$\\sigma_{y0}$ 是初始屈服应力，$H$ 是各向同性硬化模量，$\\kappa$ 是随塑性流动的进行而累积的内硬化变量。对于相关联流动，塑性流动方向由屈服函数对应力的梯度定义，\n$$\n\\boldsymbol{m}(\\boldsymbol{\\sigma}) = \\frac{\\partial f}{\\partial \\boldsymbol{\\sigma}} = \\alpha \\boldsymbol{I} + \\frac{\\mathrm{dev}(\\boldsymbol{\\sigma})}{2 \\sqrt{J_2}},\n$$\n其归一化形式为\n$$\n\\boldsymbol{n}(\\boldsymbol{\\sigma}) = \\frac{\\boldsymbol{m}(\\boldsymbol{\\sigma})}{\\|\\boldsymbol{m}(\\boldsymbol{\\sigma})\\|_F},\n$$\n其中 $\\|\\cdot\\|_F$ 是 Frobenius 范数。当 $J_2$ 足够小时，用一个小的正阈值来正则化 $\\sqrt{J_2}$，以避免除以零。\n\n3. 考虑子步框架，其中总应变增量 $\\Delta \\boldsymbol{\\varepsilon}_{\\mathrm{tot}}$ 被划分为多个子步，其大小为 $\\Delta \\boldsymbol{\\varepsilon}_i = \\xi_i \\, \\Delta \\boldsymbol{\\varepsilon}_{\\mathrm{tot}}$，其中 $0  \\xi_i \\leq 1$ 且 $\\sum_i \\xi_i = 1$。在每个子步内，对塑性流动采用方向恒定的近似：在子步开始时冻结梯度 $\\boldsymbol{m}$。在子步 $i$ 中固定 $\\boldsymbol{m}_i = \\boldsymbol{m}(\\boldsymbol{\\sigma}_i)$，则应力更新为\n$$\n\\boldsymbol{\\sigma}_{i+1} = \\boldsymbol{\\sigma}_{i} + \\lambda \\, \\mathrm{tr}(\\Delta \\boldsymbol{\\varepsilon}_i) \\, \\boldsymbol{I} + 2 \\mu \\, \\mathrm{dev}(\\Delta \\boldsymbol{\\varepsilon}_i) - d\\lambda_i \\left[\\lambda \\, \\mathrm{tr}(\\boldsymbol{m}_i) \\, \\boldsymbol{I} + 2 \\mu \\, \\mathrm{dev}(\\boldsymbol{m}_i)\\right],\n$$\n其中 $d\\lambda_i \\geq 0$ 是该子步的塑性乘子增量，硬化更新为 $\\kappa_{i+1} = \\kappa_i + d\\lambda_i$。在子步 $i$ 中塑性加载的一致性条件 $f(\\boldsymbol{\\sigma}_{i+1}, \\kappa_{i+1}) = 0$ 定义了一个关于 $d\\lambda_i$ 的标量非线性方程；使用牛顿法 (Newton method) 求解它。如果子步结束时的弹性试探预测值满足 $f \\leq 0$，则 $d\\lambda_i = 0$，该子步为纯弹性。\n\n4. 实现两种子步的接受准则：\n   - 流动方向的平稳性：当子步开始和结束时归一化流动方向的变化满足以下条件时，接受该子步\n     $$\n     \\left\\|\\boldsymbol{n}_{i+1} - \\boldsymbol{n}_{i} \\right\\|_F  \\varepsilon_n,\n     $$\n     其中 $\\varepsilon_n$ 是指定的容差。第一个子步无条件接受。如果条件不满足，则减小子步大小（例如，将 $\\xi_i$ 减半）并从同一状态重试。\n   - 基于屈服残差：当结束时计算出的屈服函数值满足以下条件时，接受该子步\n     $$\n     f(\\boldsymbol{\\sigma}_{i+1}, \\kappa_{i+1}) \\leq 0 \\quad \\text{或} \\quad \\left| f(\\boldsymbol{\\sigma}_{i+1}, \\kappa_{i+1}) \\right|  \\varepsilon_f,\n     $$\n     其中 $\\varepsilon_f$ 是指定的容差。如果条件不满足，则减小子步大小并重试。在塑性子步中，使用相同的牛顿法求解 $d\\lambda_i$。\n\n5. 在每次模拟中，从 $\\boldsymbol{\\sigma}_0 = \\boldsymbol{0}$ 和 $\\kappa_0 = 0$ 开始。使用以兆帕为单位的材料参数：$E$ 的单位为 $\\mathrm{MPa}$，$\\nu$ 无量纲，$\\alpha$ 无量纲，$\\sigma_{y0}$ 的单位为 $\\mathrm{MPa}$，$H$ 的单位为 $\\mathrm{MPa}$。使用以下容差：平稳性准则的 $\\varepsilon_n = 10^{-3}$，屈服残差准则的 $\\varepsilon_f = 10^{-6} \\,\\mathrm{MPa}$。在每个塑性子步中，使用牛顿求解器求解一致性方程，容差为 $10^{-8} \\,\\mathrm{MPa}$，最大迭代次数为 50 次，并在需要时使用步长阻尼。在子步自适应过程中，如果子步大小变得小于总增量的 $10^{-6}$ 的最小分数，则强制接受以避免无限循环。\n\n测试套件。对于每个案例，应变增量 $\\Delta \\boldsymbol{\\varepsilon}_{\\mathrm{tot}}$ 是一个对称的 $3 \\times 3$ 张量（无量纲）。材料参数如各案例所列。所有计算和报告的应力必须以 $\\mathrm{MPa}$ 为单位。\n\n- 案例 A（一般偏量加载，预期为塑性）：$E = 10000 \\,\\mathrm{MPa}$，$\\nu = 0.3$，$\\alpha = 0.2$，$\\sigma_{y0} = 50 \\,\\mathrm{MPa}$，$H = 200 \\,\\mathrm{MPa}$，以及\n  $$\n  \\Delta \\boldsymbol{\\varepsilon}_{\\mathrm{tot}} = \\begin{bmatrix}\n  0  0.01  0 \\\\\n  0.01  0  0 \\\\\n  0  0  0\n  \\end{bmatrix}.\n  $$\n\n- 案例 B（静水拉伸，预期为塑性）：$E = 10000 \\,\\mathrm{MPa}$，$\\nu = 0.3$，$\\alpha = 0.2$，$\\sigma_{y0} = 50 \\,\\mathrm{MPa}$，$H = 200 \\,\\mathrm{MPa}$，以及\n  $$\n  \\Delta \\boldsymbol{\\varepsilon}_{\\mathrm{tot}} = \\begin{bmatrix}\n  0.004  0  0 \\\\\n  0  0.004  0 \\\\\n  0  0  0.004\n  \\end{bmatrix}.\n  $$\n\n- 案例 C（混合加载，大路径，预期为塑性）：$E = 10000 \\,\\mathrm{MPa}$，$\\nu = 0.3$，$\\alpha = 0.2$，$\\sigma_{y0} = 50 \\,\\mathrm{MPa}$，$H = 200 \\,\\mathrm{MPa}$，以及\n  $$\n  \\Delta \\boldsymbol{\\varepsilon}_{\\mathrm{tot}} = \\begin{bmatrix}\n  0.006  0.004  0 \\\\\n  0.004  -0.002  0 \\\\\n  0  0  -0.001\n  \\end{bmatrix}.\n  $$\n\n- 案例 D（小剪切，预期为弹性）：$E = 10000 \\,\\mathrm{MPa}$，$\\nu = 0.3$，$\\alpha = 0.2$，$\\sigma_{y0} = 50 \\,\\mathrm{MPa}$，$H = 200 \\,\\mathrm{MPa}$，以及\n  $$\n  \\Delta \\boldsymbol{\\varepsilon}_{\\mathrm{tot}} = \\begin{bmatrix}\n  0  0.0002  0 \\\\\n  0.0002  0  0 \\\\\n  0  0  0\n  \\end{bmatrix}.\n  $$\n\n要求输出。对于每个案例，将完整增量积分运行两次：一次使用平稳性准则，一次使用屈服残差准则。记录：平稳性准则接受的子步数（$N_n$），屈服残差准则接受的子步数（$N_f$），以及两个最终应力张量之差的 Frobenius 范数（单位为 $\\mathrm{MPa}$），即 $\\|\\boldsymbol{\\sigma}^{(n)} - \\boldsymbol{\\sigma}^{(f)}\\|_F$。您的程序应生成单行输出，包含案例 A–D 的 12 个值，顺序如下：\n$$\n\\left[ N_n^{A}, N_f^{A}, \\|\\boldsymbol{\\sigma}^{(n)} - \\boldsymbol{\\sigma}^{(f)}\\|_F^{A}, N_n^{B}, N_f^{B}, \\|\\boldsymbol{\\sigma}^{(n)} - \\boldsymbol{\\sigma}^{(f)}\\|_F^{B}, N_n^{C}, N_f^{C}, \\|\\boldsymbol{\\sigma}^{(n)} - \\boldsymbol{\\sigma}^{(f)}\\|_F^{C}, N_n^{D}, N_f^{D}, \\|\\boldsymbol{\\sigma}^{(n)} - \\boldsymbol{\\sigma}^{(f)}\\|_F^{D} \\right],\n$$\n以 Python 列表字面量的形式精确打印，值之间用逗号分隔。计数值必须是整数，范数必须是 $\\mathrm{MPa}$ 单位的浮点数。",
            "solution": "该问题被评估为有效。其科学基础为计算塑性力学理论，问题提法完善，提供了所有必要的参数和条件，并以客观、正式的语言表述。该问题要求实现并比较两种自适应子步策略，用于积分 Drucker-Prager 弹塑性材料的本构响应。我们将进行详细的解答。\n\n### 1. 理论框架\n\n该问题描述了一个在小应变假设下，结合了线弹性与 Drucker-Prager 塑性的材料模型。\n\n**弹性行为**：应力增量张量 $\\Delta\\boldsymbol{\\sigma}$ 和应变增量张量 $\\Delta\\boldsymbol{\\varepsilon}$ 之间的关系由一个特定但非标准的各向同性线弹性定律给出：\n$$\n\\Delta \\boldsymbol{\\sigma} = \\lambda \\, \\mathrm{tr}(\\Delta \\boldsymbol{\\varepsilon}) \\, \\boldsymbol{I} + 2 \\mu \\, \\mathrm{dev}(\\Delta \\boldsymbol{\\varepsilon})\n$$\n其中 $\\boldsymbol{I}$ 是二阶单位张量，$\\mathrm{tr}(\\cdot)$ 是迹算子，$\\mathrm{dev}(\\cdot)$ 是偏量投影算子。拉梅 (Lamé) 参数 $\\lambda$ 和 $\\mu$ 通过杨氏模量 $E$ 和泊松比 $\\nu$ 定义如下：\n$$\n\\lambda = \\frac{E \\nu}{(1+\\nu)(1-2\\nu)}, \\quad \\mu = \\frac{E}{2(1+\\nu)}\n$$\n此结构意味着，对于任意二阶张量 $\\boldsymbol{X}$，四阶弹性张量 $\\mathbf{C}$ 的作用方式为 $\\mathbf{C}:\\boldsymbol{X} = \\lambda \\, \\mathrm{tr}(\\boldsymbol{X}) \\, \\boldsymbol{I} + 2 \\mu \\, \\mathrm{dev}(\\boldsymbol{X})$。\n\n**塑性行为**：塑性屈服和流动由带有各向同性硬化的相关联 Drucker-Prager 模型控制。\n屈服函数 $f$ 定义了弹性域的边界：\n$$\nf(\\boldsymbol{\\sigma}, \\kappa) = \\alpha \\, I_1 + \\sqrt{J_2} - \\left(\\sigma_{y0} + H \\kappa \\right)\n$$\n其中 $I_1 = \\mathrm{tr}(\\boldsymbol{\\sigma})$ 是应力张量的第一不变量，$J_2 = \\frac{1}{2} \\mathrm{dev}(\\boldsymbol{\\sigma}) : \\mathrm{dev}(\\boldsymbol{\\sigma})$ 是偏应力张量的第二不变量，$\\alpha$ 是材料摩擦参数，$\\sigma_{y0}$ 是初始屈服应力，$H$ 是硬化模量，$\\kappa$ 是累积塑性应变（内硬化变量）。\n\n对于相关联塑性，塑性流动方向 $\\boldsymbol{m}$ 由屈服函数对应力的梯度给出：\n$$\n\\boldsymbol{m}(\\boldsymbol{\\sigma}) = \\frac{\\partial f}{\\partial \\boldsymbol{\\sigma}} = \\alpha \\boldsymbol{I} + \\frac{\\mathrm{dev}(\\boldsymbol{\\sigma})}{2 \\sqrt{J_2}}\n$$\n为处理 $J_2 \\to 0$ 的情况（即静水压力轴上的状态），如果 $J_2$ 低于一个小的数值阈值，则通过将 $\\boldsymbol{m}$ 的偏量分量设为零来对包含 $\\sqrt{J_2}$ 的项进行正则化。归一化的流动方向是 $\\boldsymbol{n}(\\boldsymbol{\\sigma}) = \\boldsymbol{m}(\\boldsymbol{\\sigma}) / \\|\\boldsymbol{m}(\\boldsymbol{\\sigma})\\|_F$，其中 $\\|\\cdot\\|_F$ 是 Frobenius 范数。\n\n### 2. 数值积分方案\n\n总应变增量 $\\Delta\\boldsymbol{\\varepsilon}_{\\mathrm{tot}}$ 在一个加载步中施加，该加载步被划分为多个更小的子步。每个子步内的积分采用显式类型的方向恒定近似方法执行。\n\n**子步法**：总应变增量被划分为 $\\Delta\\boldsymbol{\\varepsilon}_{\\mathrm{tot}} = \\sum_i \\Delta\\boldsymbol{\\varepsilon}_i$，其中 $\\Delta\\boldsymbol{\\varepsilon}_i = \\xi_i \\Delta\\boldsymbol{\\varepsilon}_{\\mathrm{tot}}$，$\\xi_i$ 是子步 $i$ 的大小。状态 $(\\boldsymbol{\\sigma}_i, \\kappa_i)$ 被更新为 $(\\boldsymbol{\\sigma}_{i+1}, \\kappa_{i+1})$。\n\n**应力更新**：对于每个子步，首先计算一个试探弹性应力：\n$$\n\\boldsymbol{\\sigma}^{\\text{trial}}_{i+1} = \\boldsymbol{\\sigma}_i + \\Delta\\boldsymbol{\\sigma}^{\\text{e}}_i = \\boldsymbol{\\sigma}_i + \\lambda \\, \\mathrm{tr}(\\Delta \\boldsymbol{\\varepsilon}_i) \\, \\boldsymbol{I} + 2 \\mu \\, \\mathrm{dev}(\\Delta \\boldsymbol{\\varepsilon}_i)\n$$\n如果 $f(\\boldsymbol{\\sigma}^{\\text{trial}}_{i+1}, \\kappa_i) \\leq 0$，该子步是弹性的，此时 $\\boldsymbol{\\sigma}_{i+1} = \\boldsymbol{\\sigma}^{\\text{trial}}_{i+1}$，$\\kappa_{i+1} = \\kappa_i$。\n\n如果 $f(\\boldsymbol{\\sigma}^{\\text{trial}}_{i+1}, \\kappa_i)  0$，该子步是塑性的。需要进行塑性修正。方向恒定近似冻结了子步开始时的流动方向 $\\boldsymbol{m}_i = \\boldsymbol{m}(\\boldsymbol{\\sigma}_i)$。最终应力由下式给出：\n$$\n\\boldsymbol{\\sigma}_{i+1} = \\boldsymbol{\\sigma}^{\\text{trial}}_{i+1} - d\\lambda_i \\left( \\mathbf{C} : \\boldsymbol{m}_i \\right)\n$$\n其中 $d\\lambda_i$ 是该子步的塑性乘子增量，而项 $\\mathbf{C} : \\boldsymbol{m}_i$ 被指定为：\n$$\n\\mathbf{C} : \\boldsymbol{m}_i = \\lambda \\, \\mathrm{tr}(\\boldsymbol{m}_i) \\, \\boldsymbol{I} + 2 \\mu \\, \\mathrm{dev}(\\boldsymbol{m}_i)\n$$\n硬化变量更新为 $\\kappa_{i+1} = \\kappa_i + d\\lambda_i$。未知数 $d\\lambda_i$ 通过施加一致性条件 $f(\\boldsymbol{\\sigma}_{i+1}, \\kappa_{i+1}) = 0$ 来求得。这就构成了一个关于 $d\\lambda_i$ 的标量非线性方程，我们使用牛顿-拉夫逊 (Newton-Raphson) 方法求解。$d\\lambda_i$ 的迭代更新为：\n$$\nd\\lambda_i^{(k+1)} = d\\lambda_i^{(k)} - \\frac{g(d\\lambda_i^{(k)})}{g'(d\\lambda_i^{(k)})}\n$$\n其中 $g(d\\lambda_i) = f(\\boldsymbol{\\sigma}_{i+1}(d\\lambda_i), \\kappa_{i+1}(d\\lambda_i))$ 且 \n$$\ng'(d\\lambda_i) = \\frac{\\partial f}{\\partial \\boldsymbol{\\sigma}}\\Big|_{\\boldsymbol{\\sigma}_{i+1}} : \\frac{d\\boldsymbol{\\sigma}_{i+1}}{d(d\\lambda_i)} + \\frac{\\partial f}{\\partial \\kappa}\\frac{d\\kappa_{i+1}}{d(d\\lambda_i)} = -\\boldsymbol{m}(\\boldsymbol{\\sigma}_{i+1}) : (\\mathbf{C}:\\boldsymbol{m}_i) - H\n$$\n\n### 3. 自适应子步控制\n\n实现并比较了两种用于接受已完成子步的准则。如果一个子步被拒绝，其大小 $\\xi_i$ 将减半，并从状态 $(\\boldsymbol{\\sigma}_i, \\kappa_i)$ 重新开始计算。如果子步的大小低于一个最小阈值（总增量的 $10^{-6}$），则强制接受该子步，以防止无限循环。\n\n**1. 流动方向的平稳性**：如果塑性流动方向没有显著变化，则接受一个子步。这通过子步开始和结束时归一化流动方向之差的 Frobenius 范数来衡量。\n$$\n\\left\\|\\boldsymbol{n}_{i+1} - \\boldsymbol{n}_{i} \\right\\|_F  \\varepsilon_n\n$$\n其中 $\\boldsymbol{n}_i = \\boldsymbol{n}(\\boldsymbol{\\sigma}_i)$，$\\boldsymbol{n}_{i+1} = \\boldsymbol{n}(\\boldsymbol{\\sigma}_{i+1})$，容差为 $\\varepsilon_n = 10^{-3}$。模拟的第一个子步无条件接受。\n\n**2. 基于屈服残差**：如果最终状态是弹性的，或者最终应力状态足够接近屈服面，则接受一个子步。\n$$\nf(\\boldsymbol{\\sigma}_{i+1}, \\kappa_{i+1}) \\leq 0 \\quad \\text{或} \\quad \\left| f(\\boldsymbol{\\sigma}_{i+1}, \\kappa_{i+1}) \\right|  \\varepsilon_f\n$$\n容差为 $\\varepsilon_f = 10^{-6} \\, \\mathrm{MPa}$。\n\n### 4. 模拟执行\n\n对于每个测试案例，初始化问题中指定的材料和数值参数。模拟从零应力、零硬化状态（$\\boldsymbol{\\sigma}_0 = \\boldsymbol{0}$，$\\kappa_0=0$）开始。积分过程执行两次：一次使用平稳性准则，第二次使用屈服残差准则。记录每个案例中接受的子步数（$N_n$， $N_f$）以及最终应力张量之差的 Frobenius 范数 $\\|\\boldsymbol{\\sigma}^{(n)} - \\boldsymbol{\\sigma}^{(f)}\\|_F$。然后将所有案例的结果汇总到一个列表中，作为最终输出。",
            "answer": "```python\nimport numpy as np\n\n# A small value for J2 regularization to prevent division by zero\nJ2_REG = 1e-20  # MPa^2\n\n# ---------- Tensor and Constitutive Utilities ----------\n\ndef dev(tensor):\n    \"\"\"Computes the deviatoric part of a 3x3 tensor.\"\"\"\n    return tensor - (1/3) * np.trace(tensor) * np.eye(3)\n\ndef lame_lambda(E, nu):\n    \"\"\"Calculates Lamé's first parameter.\"\"\"\n    return (E * nu) / ((1 + nu) * (1 - 2 * nu))\n\ndef lame_mu(E, nu):\n    \"\"\"Calculates Lamé's second parameter (shear modulus).\"\"\"\n    return E / (2 * (1 + nu))\n\ndef elastic_stress_inc(deps, lam, mu):\n    \"\"\"\n    Calculates the elastic stress increment based on the problem's specific formula.\n    Δσ = λ tr(Δε) I + 2μ dev(Δε)\n    \"\"\"\n    tr_deps = np.trace(deps)\n    dev_deps = dev(deps)\n    return lam * tr_deps * np.eye(3) + 2 * mu * dev_deps\n\ndef C_colon_tensor(tensor, lam, mu):\n    \"\"\"\n    Applies the constitutive operator to a second-order tensor, following the problem's definition.\n    C:T = λ tr(T) I + 2μ dev(T)\n    \"\"\"\n    return lam * np.trace(tensor) * np.eye(3) + 2 * mu * dev(tensor)\n\n# ---------- Drucker-Prager Model Functions ----------\n\ndef get_invariants(sigma):\n    \"\"\"Computes stress invariants I1 and J2.\"\"\"\n    I1 = np.trace(sigma)\n    s = dev(sigma)\n    J2 = 0.5 * np.sum(s * s)\n    return I1, J2\n\ndef yield_function(sigma, kappa, alpha, sig_y0, H):\n    \"\"\"Computes the Drucker-Prager yield function value.\"\"\"\n    I1, J2 = get_invariants(sigma)\n    sqrt_J2 = np.sqrt(J2)\n    return alpha * I1 + sqrt_J2 - (sig_y0 + H * kappa)\n\ndef flow_direction_m(sigma, alpha):\n    \"\"\"Computes the plastic flow direction m = ∂f/∂σ with regularization.\"\"\"\n    s = dev(sigma)\n    J2 = 0.5 * np.sum(s * s)\n    if J2  J2_REG:\n        # For states on/near hydrostatic axis, deviatoric part of flow is zero\n        dev_m_term = np.zeros((3, 3))\n    else:\n        dev_m_term = s / (2 * np.sqrt(J2))\n    return alpha * np.eye(3) + dev_m_term\n\ndef normalized_flow_direction_n(sigma, alpha):\n    \"\"\"Computes the normalized plastic flow direction n.\"\"\"\n    m = flow_direction_m(sigma, alpha)\n    norm_m = np.linalg.norm(m, 'fro')\n    if norm_m  1e-12: # Avoid division by zero if m is effectively zero\n        return np.zeros((3,3))\n    return m / norm_m\n\n# ---------- Newton Solver for Plastic Multiplier ----------\n\ndef solve_d_lambda(sigma_trial, kappa_i, m_i, params):\n    \"\"\"\n    Solves for the plastic multiplier increment d_lambda using Newton's method.\n    \"\"\"\n    lam, mu, alpha, sig_y0, H = params['lam'], params['mu'], params['alpha'], params['sig_y0'], params['H']\n    newton_tol = params['newton_tol']\n    max_iter = params['newton_max_iter']\n\n    C_m = C_colon_tensor(m_i, lam, mu)\n    d_lambda = 0.0\n\n    for _ in range(max_iter):\n        sigma_k = sigma_trial - d_lambda * C_m\n        kappa_k = kappa_i + d_lambda\n\n        # Calculate residual g(d_lambda)\n        g = yield_function(sigma_k, kappa_k, alpha, sig_y0, H)\n\n        if abs(g)  newton_tol:\n            return d_lambda if d_lambda > 0 else 0.0\n\n        # Calculate derivative g'(d_lambda)\n        m_k = flow_direction_m(sigma_k, alpha)\n        g_prime = -np.sum(m_k * C_m) - H\n\n        if abs(g_prime)  1e-12:\n            return d_lambda if d_lambda > 0 else 0.0\n\n        # Newton update with simple line search/damping\n        delta_d_lambda = -g / g_prime\n        damp = 1.0\n        for _ in range(5):\n            d_lambda_new = d_lambda + damp * delta_d_lambda\n            if d_lambda_new  0: # Multiplier must be non-negative\n                damp /= 2.0\n                continue\n            \n            sigma_new = sigma_trial - d_lambda_new * C_m\n            kappa_new = kappa_i + d_lambda_new\n            g_new = yield_function(sigma_new, kappa_new, alpha, sig_y0, H)\n            \n            if abs(g_new)  abs(g) * (1 - 1e-4 * damp): # Armijo-like condition\n                d_lambda = d_lambda_new\n                break\n            damp /= 2.0\n        else: # Damping failed, so no update this iteration\n            return d_lambda if d_lambda > 0 else 0.0\n\n    return d_lambda if d_lambda > 0 else 0.0\n\n# ---------- Main Substepping Algorithm ----------\n\ndef run_simulation(params, criterion):\n    \"\"\"\n    Runs a single simulation for a total strain increment with adaptive substepping.\n    \"\"\"\n    sigma = np.zeros((3, 3))\n    kappa = 0.0\n    \n    total_strain_inc = params['deps_tot']\n    lam, mu, alpha, sig_y0, H = params['lam'], params['mu'], params['alpha'], params['sig_y0'], params['H']\n    eps_n, eps_f, min_xi_frac = params['eps_n'], params['eps_f'], params['min_xi_frac']\n    \n    accumulated_xi = 0.0\n    substep_count = 0\n\n    while accumulated_xi  1.0 - 1e-9: # Loop until full strain increment is applied\n        xi = 1.0 - accumulated_xi\n        is_first_substep = (substep_count == 0)\n\n        while True: # Substep reduction loop\n            deps_substep = xi * total_strain_inc\n            sigma_trial = sigma + elastic_stress_inc(deps_substep, lam, mu)\n            f_trial = yield_function(sigma_trial, kappa, alpha, sig_y0, H)\n            \n            is_plastic_substep = f_trial > 0\n\n            if is_plastic_substep:\n                m_i = flow_direction_m(sigma, alpha)\n                d_lambda = solve_d_lambda(sigma_trial, kappa, m_i, params)\n                \n                if d_lambda > 0:\n                    C_m = C_colon_tensor(m_i, lam, mu)\n                    sigma_next = sigma_trial - d_lambda * C_m\n                    kappa_next = kappa + d_lambda\n                else: # Newton found no plastic strain, so step is effectively elastic\n                    sigma_next = sigma_trial\n                    kappa_next = kappa\n                    is_plastic_substep = False\n            else: # Elastic substep\n                sigma_next = sigma_trial\n                kappa_next = kappa\n\n            # Substep acceptance check\n            accepted = False\n            if criterion == 'stationarity':\n                if not is_plastic_substep: # Always accept elastic steps\n                    accepted = True\n                elif is_first_substep:\n                    accepted = True\n                else:\n                    n_i = normalized_flow_direction_n(sigma, alpha)\n                    n_next = normalized_flow_direction_n(sigma_next, alpha)\n                    norm_diff = np.linalg.norm(n_next - n_i, 'fro')\n                    if norm_diff  eps_n:\n                        accepted = True\n            elif criterion == 'yield_residual':\n                if not is_plastic_substep:\n                    accepted = True\n                else:\n                    f_end = yield_function(sigma_next, kappa_next, alpha, sig_y0, H)\n                    if abs(f_end)  eps_f:\n                        accepted = True\n            \n            if not accepted and xi  min_xi_frac:\n                accepted = True\n                \n            if accepted:\n                sigma = sigma_next\n                kappa = kappa_next\n                accumulated_xi += xi\n                substep_count += 1\n                break\n            else:\n                xi /= 2.0\n                \n    return sigma, substep_count\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final output.\n    \"\"\"\n    test_cases_spec = {\n        'A': {'deps_tot': np.array([[0.0, 0.01, 0.0], [0.01, 0.0, 0.0], [0.0, 0.0, 0.0]])},\n        'B': {'deps_tot': np.array([[0.004, 0.0, 0.0], [0.0, 0.004, 0.0], [0.0, 0.0, 0.004]])},\n        'C': {'deps_tot': np.array([[0.006, 0.004, 0.0], [0.004, -0.002, 0.0], [0.0, 0.0, -0.001]])},\n        'D': {'deps_tot': np.array([[0.0, 0.0002, 0.0], [0.0002, 0.0, 0.0], [0.0, 0.0, 0.0]])}\n    }\n    \n    base_material_params = {'E': 10000.0, 'nu': 0.3, 'alpha': 0.2, 'sig_y0': 50.0, 'H': 200.0}\n    common_numerical_params = {\n        'eps_n': 1e-3, 'eps_f': 1e-6, 'newton_tol': 1e-8,\n        'newton_max_iter': 50, 'min_xi_frac': 1e-6\n    }\n\n    results = []\n    case_order = ['A', 'B', 'C', 'D']\n\n    for case_id in case_order:\n        params = base_material_params.copy()\n        params.update(test_cases_spec[case_id])\n        params.update(common_numerical_params)\n        \n        params['lam'] = lame_lambda(params['E'], params['nu'])\n        params['mu'] = lame_mu(params['E'], params['nu'])\n\n        sigma_n, N_n = run_simulation(params, 'stationarity')\n        sigma_f, N_f = run_simulation(params, 'yield_residual')\n\n        stress_diff_norm = np.linalg.norm(sigma_n - sigma_f, 'fro')\n\n        results.extend([N_n, N_f, stress_diff_norm])\n        \n    print(f\"[{','.join(f'{v:.6f}' if isinstance(v, float) else str(v) for v in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "子步法不仅是控制误差的工具，其本质是准确地积分一个路径依赖的过程，这一点对于具有非关联流动（在岩土力学中很常见）的材料尤为关键。本高级练习  设计了一个受控的数值实验，以探究在大的应变增量中，一系列局部非关联塑性流动偏差的*顺序*如何影响最终的累积结果。通过比较不同顺序的非正常流动子步，您将深入理解塑性的路径依赖特性，以及积分方案在捕捉正确宏观响应方面所扮演的关键角色。",
            "id": "3566159",
            "problem": "考虑一个凸屈服面的二维平面应力理想化，以及一个在子步层面具有受控非关联性的塑性流动法则。设屈服函数定义为 $F(\\boldsymbol{\\sigma}) = \\sqrt{\\sigma_1^2 + \\beta\\,\\sigma_2^2} - \\sigma_y$，其中 $\\boldsymbol{\\sigma} = (\\sigma_1,\\sigma_2)$ 是应力向量，$\\beta  0$ 是一个形状参数，$\\sigma_y  0$ 是屈服应力。在一点 $\\boldsymbol{\\sigma}$ 处，屈服面的外法向单位向量为 $\\boldsymbol{n}(\\boldsymbol{\\sigma}) = \\dfrac{\\nabla F(\\boldsymbol{\\sigma})}{\\|\\nabla F(\\boldsymbol{\\sigma})\\|}$，其中 $\\nabla F$ 是 $F$ 相对于 $\\boldsymbol{\\sigma}$ 的梯度，$\\|\\cdot\\|$ 表示欧几里得范数。通过映射 $\\boldsymbol{\\sigma}(\\theta) = \\left(\\sigma_y \\cos\\theta,\\,\\dfrac{\\sigma_y}{\\sqrt{\\beta}}\\sin\\theta\\right)$ 将屈服面用角度 $\\theta \\in [0,2\\pi)$ 参数化，使得 $F(\\boldsymbol{\\sigma}(\\theta)) = 0$ 恒成立。根据 $F$ 的定义，在 $\\boldsymbol{\\sigma}(\\theta)$ 处的梯度为 $\\nabla F(\\boldsymbol{\\sigma}(\\theta)) = \\left(\\dfrac{\\sigma_1}{\\sigma_y},\\,\\dfrac{\\beta\\,\\sigma_2}{\\sigma_y}\\right) = \\left(\\cos\\theta,\\,\\sqrt{\\beta}\\,\\sin\\theta\\right)$，相应的单位法向量为 $\\boldsymbol{n}(\\theta) = \\dfrac{\\left(\\cos\\theta,\\,\\sqrt{\\beta}\\,\\sin\\theta\\right)}{\\sqrt{\\cos^2\\theta + \\beta\\,\\sin^2\\theta}}$。\n\n一个大的塑性加载增量被理想化为沿屈服面从初始参数角 $\\theta_0$ 到最终角 $\\theta_T$ 的一次遍历，该过程被划分为 $N$ 个相等的子步。将每个子步的均匀参数增量记为 $\\Delta\\theta = \\dfrac{\\theta_T - \\theta_0}{N}$，子步角记为 $\\theta_j = \\theta_0 + j\\,\\Delta\\theta$，其中 $j = 0,1,\\dots,N-1$。在每个子步 $j$ 中，通过约束塑性应变增量方向 $\\Delta\\boldsymbol{\\varepsilon}^p_j$ 与当前单位法向量 $\\boldsymbol{n}(\\theta_j)$ 之间的夹角为一个满足 $|\\delta_j| \\le \\alpha_{\\max}$ 的预设偏差 $\\delta_j$ 来施加受控的非关联性，其中 $\\alpha_{\\max} \\ge 0$ 为给定值。使用平面旋转矩阵，将塑性应变增量方向建模为法向量在应力平面内旋转 $\\delta_j$ 角\n$$\n\\boldsymbol{R}(\\delta_j) = \\begin{bmatrix}\n\\cos\\delta_j  -\\sin\\delta_j \\\\\n\\sin\\delta_j  \\cos\\delta_j\n\\end{bmatrix},\n$$\n并令塑性应变增量为\n$$\n\\Delta\\boldsymbol{\\varepsilon}^p_j = w_j\\,\\boldsymbol{R}(\\delta_j)\\,\\boldsymbol{n}(\\theta_j),\n$$\n权重 $w_j = \\Delta\\theta$ 为正值。则该大增量上的累积塑性应变增量为\n$$\n\\Delta\\boldsymbol{\\varepsilon}^p_{\\text{tot}} = \\sum_{j=0}^{N-1} \\Delta\\boldsymbol{\\varepsilon}^p_j = \\sum_{j=0}^{N-1} \\Delta\\theta\\,\\boldsymbol{R}(\\delta_j)\\,\\boldsymbol{n}(\\theta_j).\n$$\n定义最终单位法向量为 $\\boldsymbol{n}_T = \\boldsymbol{n}(\\theta_T)$。通过角度\n$$\n\\varphi = \\arccos\\left( \\dfrac{\\Delta\\boldsymbol{\\varepsilon}^p_{\\text{tot}} \\cdot \\boldsymbol{n}_T}{\\left\\|\\Delta\\boldsymbol{\\varepsilon}^p_{\\text{tot}}\\right\\|\\,\\left\\|\\boldsymbol{n}_T\\right\\|} \\right)\n$$\n来量化积分塑性流相对关联性的累积偏差。所有角度必须以弧度表示。目标是分析在每个子步满足约束 $|\\delta_j| \\le \\alpha_{\\max}$ 的条件下，偏差序列 $\\{\\delta_j\\}$ 的排列方式如何影响一个大增量后的最终角度 $\\varphi$。\n\n实现一个程序，对下方的每个测试用例，根据指定的模式构建序列 $\\{\\delta_j\\}$，计算 $\\Delta\\boldsymbol{\\varepsilon}^p_{\\text{tot}}$ 和 $\\varphi$，并返回保留六位小数的 $\\varphi$ 值。将所有量视为无量纲量。\n\n使用以下测试套件，每个用例指定为 $(\\beta, \\sigma_y, \\theta_0, \\theta_T, N, \\alpha_{\\max}, \\text{sequence\\_type}, \\text{seed})$，其中 $\\text{seed}$ 仅用于随机序列生成：\n\n- 用例 1 (理想路径，持续非关联性): $(2.0,\\,100.0,\\,0.0,\\,\\dfrac{\\pi}{2},\\,40,\\,0.35,\\,\\text{constant},\\,\\text{None})$，其中对于所有 $j$，$\\delta_j = +\\alpha_{\\max}$。\n- 用例 2 (边界情况，关联流动): $(2.0,\\,100.0,\\,0.0,\\,\\dfrac{\\pi}{2},\\,40,\\,0.0,\\,\\text{constant},\\,\\text{None})$，其中对于所有 $j$，$\\delta_j = 0$。\n- 用例 3 (带抵消的序列，交替): $(2.0,\\,100.0,\\,0.0,\\,\\dfrac{\\pi}{2},\\,40,\\,0.35,\\,\\text{alternating},\\,\\text{None})$，其中对于偶数 $j$，$\\delta_j = +\\alpha_{\\max}$；对于奇数 $j$，$\\delta_j = -\\alpha_{\\max}$。\n- 用例 4 (带抵消的序列，分块): $(2.0,\\,100.0,\\,0.0,\\,\\dfrac{\\pi}{2},\\,40,\\,0.35,\\,\\text{blocked},\\,\\text{None})$，其中对于 $j \\in \\{0,1,\\dots,\\dfrac{N}{2}-1\\}$，$\\delta_j = +\\alpha_{\\max}$；对于 $j \\in \\{\\dfrac{N}{2},\\dots,N-1\\}$，$\\delta_j = -\\alpha_{\\max}$。\n- 用例 5 (零均值偏差的随机序列): $(2.0,\\,100.0,\\,0.0,\\,\\dfrac{\\pi}{2},\\,40,\\,0.35,\\,\\text{random},\\,42)$，其中多重集 $\\{\\delta_j\\}$ 包含恰好 $\\dfrac{N}{2}$ 个等于 $+\\alpha_{\\max}$ 的项和 $\\dfrac{N}{2}$ 个等于 $-\\alpha_{\\max}$ 的项，使用给定的种子进行随机排列。\n\n您的程序应生成单行输出，其中包含五个 $\\varphi$ 的结果，以逗号分隔并用方括号括起（例如，$[\\text{result1},\\text{result2},\\text{result3},\\text{result4},\\text{result5}]$），单位为弧度，每个结果保留六位小数。",
            "solution": "该问题是有效的，因为它科学地基于计算塑性力学的原理，定义和数据清晰完整，表述客观，是一个适定问题。目标是针对几种由不同非关联性序列为特征的加载情景，计算塑性应变路径相对于最终法线方向的累积偏差角 $\\varphi$。这需要在各向异性屈服面上，沿指定轨迹对塑性应变增量进行数值积分。\n\n计算每个测试用例的 $\\varphi$ 的算法步骤如下：\n\n1.  **问题离散化**：沿屈服面的连续塑性加载路径（由角度 $\\theta$ 从初始角 $\\theta_0$ 到最终角 $\\theta_T$ 参数化）被离散为 $N$ 个均匀子步。每个子步的参数增量为 $\\Delta\\theta = \\dfrac{\\theta_T - \\theta_0}{N}$。路径上的离散角度由 $\\theta_j = \\theta_0 + j\\,\\Delta\\theta$ 给出，其中 $j = 0, 1, \\dots, N-1$。\n\n2.  **子步塑性应变增量计算**：对于每个子步 $j$，计算塑性应变增量 $\\Delta\\boldsymbol{\\varepsilon}^p_j$。这涉及几个部分：\n    a.  **单位法向量**：关联塑性流动的方向由屈服面的外法向单位向量 $\\boldsymbol{n}$ 定义。在由 $\\theta_j$ 参数化的屈服面上一点，梯度向量为 $\\nabla F(\\boldsymbol{\\sigma}(\\theta_j)) = \\left(\\cos\\theta_j, \\sqrt{\\beta}\\sin\\theta_j\\right)$。相应的单位法向量 $\\boldsymbol{n}(\\theta_j)$ 通过将此梯度归一化得到：\n        $$\n        \\boldsymbol{n}(\\theta_j) = \\frac{\\left(\\cos\\theta_j, \\sqrt{\\beta}\\sin\\theta_j\\right)}{\\left\\|\\left(\\cos\\theta_j, \\sqrt{\\beta}\\sin\\theta_j\\right)\\right\\|} = \\frac{\\left(\\cos\\theta_j, \\sqrt{\\beta}\\sin\\theta_j\\right)}{\\sqrt{\\cos^2\\theta_j + \\beta\\sin^2\\theta_j}}\n        $$\n    b.  **非关联性**：通过将单位法向量 $\\boldsymbol{n}(\\theta_j)$ 旋转一个预设角度 $\\delta_j$ 来引入流动法则的非关联性。偏差序列 $\\{\\delta_j\\}$ 由每个测试用例中指定的 `sequence_type` 决定，并满足约束 $|\\delta_j| \\le \\alpha_{\\max}$。旋转使用二维旋转矩阵 $\\boldsymbol{R}(\\delta_j)$ 执行：\n        $$\n        \\boldsymbol{R}(\\delta_j) = \\begin{bmatrix}\n        \\cos\\delta_j  -\\sin\\delta_j \\\\\n        \\sin\\delta_j  \\cos\\delta_j\n        \\end{bmatrix}\n        $$\n    c.  **塑性应变增量**：该子步的塑性应变增量被计算为旋转后的法向量乘以一个权重 $w_j$，该权重定义为参数步长 $\\Delta\\theta$：\n        $$\n        \\Delta\\boldsymbol{\\varepsilon}^p_j = w_j\\,\\boldsymbol{R}(\\delta_j)\\,\\boldsymbol{n}(\\theta_j) = \\Delta\\theta\\,\\boldsymbol{R}(\\delta_j)\\,\\boldsymbol{n}(\\theta_j)\n        $$\n\n3.  **累积塑性应变增量**：整个加载路径上的总塑性应变增量 $\\Delta\\boldsymbol{\\varepsilon}^p_{\\text{tot}}$ 通过数值积分（即求和）所有子步的增量获得：\n    $$\n    \\Delta\\boldsymbol{\\varepsilon}^p_{\\text{tot}} = \\sum_{j=0}^{N-1} \\Delta\\boldsymbol{\\varepsilon}^p_j = \\Delta\\theta \\sum_{j=0}^{N-1} \\boldsymbol{R}(\\delta_j)\\,\\boldsymbol{n}(\\theta_j)\n    $$\n    注意，参数 $\\sigma_y$ 定义了屈服面的大小，但不影响单位法向量的方向或最终的无量纲角 $\\varphi$。因此，其值 $100.0$ 不影响最终结果。\n\n4.  **最终偏差角计算**：为了量化非关联性的累积效应，计算总塑性应变增量向量 $\\Delta\\boldsymbol{\\varepsilon}^p_{\\text{tot}}$ 与路径终点处的单位法向量 $\\boldsymbol{n}_T = \\boldsymbol{n}(\\theta_T)$ 之间的夹角 $\\varphi$。该角度使用点积的定义求得：\n    $$\n    \\varphi = \\arccos\\left( \\frac{\\Delta\\boldsymbol{\\varepsilon}^p_{\\text{tot}} \\cdot \\boldsymbol{n}_T}{\\left\\|\\Delta\\boldsymbol{\\varepsilon}^p_{\\text{tot}}\\right\\|\\,\\left\\|\\boldsymbol{n}_T\\right\\|} \\right)\n    $$\n    由于 $\\boldsymbol{n}_T$ 是单位向量，其范数 $\\left\\|\\boldsymbol{n}_T\\right\\|$ 为 $1$。反余弦函数的参数必须被裁剪到 $[-1, 1]$ 范围内，以防止由浮点不精确性引起的定义域错误。\n\n此计算过程应用于五个测试用例中的每一个，其中偏差序列 $\\{\\delta_j\\}$ 根据 `sequence_type` 参数的指定来构建。然后将得到的 $\\varphi$ 值四舍五入并报告。不同的序列（`constant`, `alternating`, `blocked`, `random`）旨在研究最终累积塑性应变及其与关联性偏差的路径相关性。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the cumulative deviation angle for plastic flow based on several\n    substepping strategies for non-normality.\n    \"\"\"\n    test_cases = [\n        # (beta, sigma_y, theta_0, theta_T, N, alpha_max, sequence_type, seed)\n        (2.0, 100.0, 0.0, np.pi / 2, 40, 0.35, 'constant', None),\n        (2.0, 100.0, 0.0, np.pi / 2, 40, 0.0, 'constant', None),\n        (2.0, 100.0, 0.0, np.pi / 2, 40, 0.35, 'alternating', None),\n        (2.0, 100.0, 0.0, np.pi / 2, 40, 0.35, 'blocked', None),\n        (2.0, 100.0, 0.0, np.pi / 2, 40, 0.35, 'random', 42),\n    ]\n\n    results = []\n\n    for case in test_cases:\n        beta, sigma_y, theta_0, theta_T, N, alpha_max, seq_type, seed = case\n\n        # Calculate uniform parametric increment per substep\n        delta_theta = (theta_T - theta_0) / N\n\n        # Generate the sequence of deviations {delta_j} based on the sequence type\n        deltas = np.zeros(N)\n        if seq_type == 'constant':\n            # For Case 1, delta_j = +alpha_max. For Case 2, alpha_max is 0, so delta_j = 0.\n            deltas.fill(alpha_max)\n        elif seq_type == 'alternating':\n            deltas[0::2] = alpha_max\n            deltas[1::2] = -alpha_max\n        elif seq_type == 'blocked':\n            half_N = N // 2\n            deltas[0:half_N] = alpha_max\n            deltas[half_N:] = -alpha_max\n        elif seq_type == 'random':\n            half_N = N // 2\n            # Create a multiset with N/2 positive and N/2 negative deviations\n            base_deltas = np.concatenate([np.full(half_N, alpha_max), np.full(half_N, -alpha_max)])\n            # Permute the multiset randomly using the specified seed\n            rng = np.random.default_rng(seed)\n            deltas = rng.permutation(base_deltas)\n\n        # Initialize the cumulative plastic strain increment\n        delta_eps_p_tot = np.array([0.0, 0.0])\n\n        # Sum increments over all substeps\n        for j in range(N):\n            theta_j = theta_0 + j * delta_theta\n            delta_j = deltas[j]\n\n            # 1. Compute the unit normal vector n(theta_j)\n            grad_F = np.array([np.cos(theta_j), np.sqrt(beta) * np.sin(theta_j)])\n            norm_grad_F = np.linalg.norm(grad_F)\n            n_j = grad_F / norm_grad_F\n\n            # 2. Construct the rotation matrix R(delta_j)\n            cos_d = np.cos(delta_j)\n            sin_d = np.sin(delta_j)\n            R_j = np.array([[cos_d, -sin_d], [sin_d, cos_d]])\n\n            # 3. Compute the plastic strain increment for the substep\n            # The weight w_j is given as delta_theta\n            delta_eps_p_j = delta_theta * np.dot(R_j, n_j)\n\n            # 4. Accumulate the total plastic strain increment\n            delta_eps_p_tot += delta_eps_p_j\n\n        # Compute the final deviation angle phi\n        # First, compute the final unit normal vector n_T = n(theta_T)\n        grad_F_T = np.array([np.cos(theta_T), np.sqrt(beta) * np.sin(theta_T)])\n        norm_grad_F_T = np.linalg.norm(grad_F_T)\n        n_T = grad_F_T / norm_grad_F_T\n\n        # Calculate phi using the dot product formula\n        dot_product = np.dot(delta_eps_p_tot, n_T)\n        norm_total_strain = np.linalg.norm(delta_eps_p_tot)\n        norm_nT = np.linalg.norm(n_T)  # This is 1.0 by definition\n        \n        # This check avoids division by zero if total strain is zero\n        if norm_total_strain  1e-12:\n            phi = 0.0\n        else:\n            # Clip argument of arccos to [-1.0, 1.0] to handle potential floating-point errors\n            cos_phi = np.clip(dot_product / (norm_total_strain * norm_nT), -1.0, 1.0)\n            phi = np.arccos(cos_phi)\n\n        results.append(round(phi, 6))\n    \n    # Print the final results in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}