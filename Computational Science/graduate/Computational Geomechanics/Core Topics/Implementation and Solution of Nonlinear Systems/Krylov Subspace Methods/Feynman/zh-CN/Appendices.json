{
    "hands_on_practices": [
        {
            "introduction": "要掌握克雷洛夫子空间法，首先需要理解理想情况下的收敛行为，这为预处理器的设计提供了理论目标。该练习通过一个理想化的多孔弹性问题，分析了一个完美块状预处理器对系统算子谱结构的影响。通过推导预处理后算子的特征值，您将亲眼见证通用最小残差法(GMRES)如何在理论上仅需两次迭代即可收敛，从而深刻理解高效预处理的威力 。",
            "id": "3537468",
            "problem": "在饱和多孔介质的准静态线性孔隙弹性 (Biot) 模型中，一个稳定的混合有限元离散化导致了形式如下的对称不定块状系统\n$$\nA \\begin{pmatrix} u \\\\ p \\end{pmatrix} = \\begin{pmatrix} f \\\\ g \\end{pmatrix}, \\quad A := \\begin{pmatrix} K  G^{\\top} \\\\ G  -C \\end{pmatrix},\n$$\n其中 $u \\in \\mathbb{R}^{n}$ 是位移未知量，$p \\in \\mathbb{R}^{m}$ 是孔隙压力未知量。块 $K \\in \\mathbb{R}^{n \\times n}$ 是对称正定的，$G \\in \\mathbb{R}^{m \\times n}$ 是行满秩的离散散度算子，而 $C \\in \\mathbb{R}^{m \\times m}$ 是表示可压缩性和储存项的对称半正定矩阵。考虑由下式定义的精确舒尔补\n$$\nS := -C - G K^{-1} G^{\\top},\n$$\n并假设 $C + G K^{-1} G^{\\top}$ 是可逆的，从而 $S$ 也是可逆的。定义理想的下三角块预条件子\n$$\nM_{L} := \\begin{pmatrix} K  0 \\\\ G  -S \\end{pmatrix}.\n$$\n假设广义最小残差 (GMRES) 方法应用于左预处理系统 $M_{L}^{-1} A \\, z = M_{L}^{-1} b$，其中 $z \\in \\mathbb{R}^{n+m}$ 并且 $b \\in \\mathbb{R}^{n+m}$ 是给定的右端项。\n\n从上面的块定义出发，计算预处理算子 $M_{L}^{-1} A$ 的谱，并推导出其最小多项式。利用这些结果来解释当采用理想预条件子时对 GMRES 收敛性的影响。最后，以单个数字的形式报告 $M_{L}^{-1} A$ 的不同特征值的数量。不需要四舍五入。请将最终答案表示为不带单位的纯数字。",
            "solution": "该问题要求分析由孔隙弹性模型的有限元离散化产生的预处理线性系统 $M_{L}^{-1} A z = M_{L}^{-1} b$。目标是确定预处理算子 $M_{L}^{-1} A$ 的谱和最小多项式，并将这些性质与 GMRES 方法的收敛性联系起来。\n\n给定的矩阵是：\n$$\nA = \\begin{pmatrix} K  G^{\\top} \\\\ G  -C \\end{pmatrix}, \\quad M_{L} = \\begin{pmatrix} K  0 \\\\ G  -S \\end{pmatrix}\n$$\n其中 $K \\in \\mathbb{R}^{n \\times n}$ 是对称正定 (SPD) 的，$G \\in \\mathbb{R}^{m \\times n}$ 是行满秩的，$C \\in \\mathbb{R}^{m \\times m}$ 是对称半正定 (SPSD) 的，而 $S$ 是精确舒尔补，定义为 $S := -C - G K^{-1} G^{\\top}$。问题假设 $S$ 是可逆的。这是一个一致的假设，因为 $K$ 是对称正定的（SPD），这意味着 $K^{-1}$ 也是对称正定的。由于 $G$ 是行满秩的，矩阵 $G K^{-1} G^{\\top}$ 是对称正定的。矩阵 $C$ 是对称半正定的（SPSD）。一个对称正定矩阵（$G K^{-1} G^{\\top}$）和一个对称半正定矩阵（$C$）的和是对称正定的。因此，$C + G K^{-1} G^{\\top}$ 是对称正定的，特别是可逆的。这意味着 $S = -(C + G K^{-1} G^{\\top})$ 是对称负定的，因此是可逆的。\n\n首先，我们计算预条件子 $M_L$ 的逆。由于 $M_L$ 是一个下三角块矩阵，其逆 $M_{L}^{-1}$ 也是下三角块矩阵。令\n$$\nM_{L}^{-1} = \\begin{pmatrix} X  Y \\\\ Z  W \\end{pmatrix}\n$$\n条件 $M_L M_L^{-1} = I$ 给出块方程组：\n$$\n\\begin{pmatrix} K  0 \\\\ G  -S \\end{pmatrix} \\begin{pmatrix} X  Y \\\\ Z  W \\end{pmatrix} = \\begin{pmatrix} I_n  0 \\\\ 0  I_m \\end{pmatrix}\n$$\n这导致：\n1. $KX = I_n \\implies X = K^{-1}$（因为 $K$ 是可逆的）。\n2. $KY = 0 \\implies Y = 0$（因为 $K$ 是可逆的）。\n3. $GX - SZ = 0 \\implies SZ = GX = GK^{-1} \\implies Z = S^{-1}GK^{-1}$（因为 $S$ 是可逆的）。\n4. $GY - SW = I_m \\implies -SW = I_m \\implies W = -S^{-1}$。\n\n所以，预条件子的逆是：\n$$\nM_{L}^{-1} = \\begin{pmatrix} K^{-1}  0 \\\\ S^{-1}GK^{-1}  -S^{-1} \\end{pmatrix}\n$$\n接下来，我们计算预处理算子 $M_{L}^{-1} A$：\n$$\nM_{L}^{-1} A = \\begin{pmatrix} K^{-1}  0 \\\\ S^{-1}GK^{-1}  -S^{-1} \\end{pmatrix} \\begin{pmatrix} K  G^{\\top} \\\\ G  -C \\end{pmatrix}\n$$\n我们逐块计算乘积：\n$(1,1)$ 块是 $K^{-1}K + 0 \\cdot G = I_n$。\n$(1,2)$ 块是 $K^{-1}G^{\\top} + 0 \\cdot (-C) = K^{-1}G^{\\top}$。\n$(2,1)$ 块是 $(S^{-1}GK^{-1})K + (-S^{-1})G = S^{-1}G - S^{-1}G = 0$。\n$(2,2)$ 块是 $(S^{-1}GK^{-1})G^{\\top} + (-S^{-1})(-C) = S^{-1}GK^{-1}G^{\\top} + S^{-1}C = S^{-1}(GK^{-1}G^{\\top} + C)$。\n使用舒尔补的定义 $S = -C - GK^{-1}G^{\\top}$，我们有 $GK^{-1}G^{\\top} + C = -S$。\n将此代入 $(2,2)$ 块的表达式中，得到 $S^{-1}(-S) = -I_m$。\n\n因此，预处理算子是一个上三角块矩阵：\n$$\nM_{L}^{-1} A = \\begin{pmatrix} I_n  K^{-1}G^{\\top} \\\\ 0  -I_m \\end{pmatrix}\n$$\n一个三角块矩阵的谱（特征值集合）是其对角块谱的并集。对角块是单位矩阵 $I_n \\in \\mathbb{R}^{n \\times n}$ 和负单位矩阵 $-I_m \\in \\mathbb{R}^{m \\times m}$。\n$I_n$ 的特征值全部为 $1$（代数重数为 $n$）。\n$-I_m$ 的特征值全部为 $-1$（代数重数为 $m$）。\n因此，$M_{L}^{-1} A$ 的谱为 $\\sigma(M_L^{-1} A) = \\{1, -1\\}$。\n\n现在，我们确定 $M_{L}^{-1} A$ 的最小多项式。最小多项式必须以所有不同的特征值为根，所以它的根必须是 $1$ 和 $-1$。最简单的此类多项式是 $q(\\lambda) = (\\lambda - 1)(\\lambda + 1) = \\lambda^2 - 1$。我们检查这个多项式是否零化矩阵 $P = M_{L}^{-1} A$。\n$$\nP^2 = \\begin{pmatrix} I_n  K^{-1}G^{\\top} \\\\ 0  -I_m \\end{pmatrix} \\begin{pmatrix} I_n  K^{-1}G^{\\top} \\\\ 0  -I_m \\end{pmatrix} = \\begin{pmatrix} I_n \\cdot I_n + K^{-1}G^{\\top} \\cdot 0  & I_n \\cdot K^{-1}G^{\\top} + K^{-1}G^{\\top} \\cdot (-I_m) \\\\ 0 \\cdot I_n + (-I_m) \\cdot 0  & 0 \\cdot K^{-1}G^{\\top} + (-I_m) \\cdot (-I_m) \\end{pmatrix}\n$$\n$$\nP^2 = \\begin{pmatrix} I_n  & K^{-1}G^{\\top} - K^{-1}G^{\\top} \\\\ 0  & I_m \\end{pmatrix} = \\begin{pmatrix} I_n  & 0 \\\\ 0  & I_m \\end{pmatrix} = I_{n+m}\n$$\n所以，$P^2 - I = 0$。多项式 $q(\\lambda) = \\lambda^2 - 1$ 零化 $P$。最小多项式必须整除 $q(\\lambda)$。其因式为 $(\\lambda - 1)$ 和 $(\\lambda+1)$。\n多项式 $(\\lambda - 1)$ 不能是最小多项式，除非 $P - I = 0$，而这通常不成立，因为 $K^{-1}G^{\\top} \\neq 0$ 并且 $-I_m \\neq I_m$。\n多项式 $(\\lambda + 1)$ 不能是最小多项式，除非 $P + I = 0$，这同样不成立。\n因此，$M_{L}^{-1} A$ 的最小多项式是 $q(\\lambda) = \\lambda^2 - 1$。\n\nGMRES 方法的收敛性由算子的性质决定，特别是其谱和最小多项式。GMRES 的一个关键性质是，它保证在最多等于系统矩阵最小多项式次数的迭代次数内找到精确解（在精确算术下）。\n由于 $M_{L}^{-1} A$ 的最小多项式的次数是 $2$，应用于预处理系统的 GMRES 方法将在最多 $2$ 次迭代内收敛到精确解。这表明理想预条件子 $M_L$ 导致了一个极其高效的求解过程。\n\n最后，问题要求给出 $M_L^{-1} A$ 的不同特征值的数量。谱为 $\\{1, -1\\}$。这是两个不同的值。",
            "answer": "$$\n\\boxed{2}\n$$"
        },
        {
            "introduction": "然而，在实际应用中，数值不稳定性是常见的挑战，理想的收敛性并非总能实现。本练习将视角从理想转向现实，通过一个精心设计的 $4 \\times 4$ 小尺度问题，揭示稳定双共轭梯度法 (BiCGSTAB) 中可能出现的“准崩溃”现象。您将通过计算发现，一个关键参数 $\\omega_k$ 的微小取值会导致算法停滞，并学习如何通过“残差替换”这一实用技术来恢复算法的稳健收敛性 。",
            "id": "3537402",
            "problem": "在一个具有轻微跨层通量的层状土壤的二维稳态渗流分析中，孔隙压力的对流-扩散算子的上风稳定有限体积离散化可以产生一个小的非对称系统，该系统捕捉了四个控制体积之间的局部模板相互作用。考虑离散算子矩阵 $A$ 的以下理想化的局部 $4 \\times 4$ 块及其对应的载荷向量 $b$：\n$$\nA \\;=\\; \\begin{pmatrix}\n\\varepsilon  1  0  0\\\\\n-1  \\varepsilon  1  0\\\\\n0  -1  \\varepsilon  1\\\\\n0  0  -1  \\varepsilon\n\\end{pmatrix},\n\\qquad\nb \\;=\\; \\begin{pmatrix} 1\\\\ 1\\\\ 1\\\\ 1 \\end{pmatrix},\n$$\n其中 $\\varepsilon = 10^{-3}$。初始猜测为 $x_0 = 0$，用于双共轭的影子（左）残差选择为 $\\hat{r} = r_0$，其中 $r_0 = b - A x_0 = b$。双共轭梯度稳定法（Bi-Conjugate Gradient Stabilized (BiCGSTAB)）的一个步骤包括两个子步骤：一个双共轭步骤，选择一个标量 $\\,\\alpha_0\\,$ 使得更新后的中间残差 $\\,s_0 = r_0 - \\alpha_0 A p_0\\,$（其中 $p_0 = r_0$）满足关于 $\\hat{r}$ 的Petrov-Galerkin条件；以及一个局部平滑步骤，选择 $\\,\\omega_0\\,$ 以最小化第二阶段残差 $\\,r_1 = s_0 - \\omega_0 A s_0\\,$ 的欧几里得范数。除非下面另有说明，否则假设浮点运算采用精确算术。\n\n任务：\n1) 从残差、Krylov搜索方向以及BiCG类方法所使用的正交性/最小化特征的定义出发，推导以由 $\\,A, b\\,$ 构造的向量的内积表示的 $\\,\\alpha_0\\,$ 和 $\\,\\omega_0\\,$ 的表达式，并根据以上数据显式计算它们。证明 $\\,\\omega_0\\,$ 很小，并识别接近失效的机制。\n\n2) 使用步骤1)的结果，精确地构造更新后的残差 $\\,r_1 = s_0 - \\omega_0 A s_0\\,$。为了模拟当 $\\,\\omega_0\\,$ 非常小时递归残差更新中灾难性抵消的有害影响，假设递归累积的残差被一个加性扰动\n$$\n\\delta \\;=\\; 10^{-8} \\begin{pmatrix} -1\\\\ 0\\\\ 0\\\\ 1 \\end{pmatrix},\n$$\n污染，使得报告的残差变为 $\\,\\tilde{r}_1 = r_1 + \\delta\\,$。一个标准的残差替换策略是从当前迭代中重新计算真实残差，即 $\\,r_1^{\\mathrm{repl}} = b - A x_1\\,$，其中 $\\,x_1 = x_0 + \\alpha_0 p_0 + \\omega_0 s_0\\,$，并用 $\\,r_1^{\\mathrm{repl}}\\,$ 替换 $\\,\\tilde{r}_1\\,$ 以恢复正确的收敛趋势。\n\n计算给定 $\\,A, b, \\varepsilon\\,$ 下的欧几里得范数 $\\,\\|r_1^{\\mathrm{repl}}\\|_2\\,$。将你的答案四舍五入到四位有效数字。最终答案以纯数字形式表示，不带单位。",
            "solution": "我们按顺序解决这两个任务。\n\n**任务1：$\\alpha_0$ 和 $\\omega_0$ 的推导与计算，以及接近失效的分析。**\n\n首先，我们确定系数 $\\alpha_0$。BiCGSTAB方法的双共轭步骤要求中间残差 $s_0 = r_0 - \\alpha_0 A p_0$ 与影子残差 $\\hat{r}$ 正交。这就是Petrov-Galerkin条件：\n$$\n\\hat{r}^T s_0 = 0\n$$\n代入 $s_0$ 的表达式：\n$$\n\\hat{r}^T (r_0 - \\alpha_0 A p_0) = 0 \\implies \\hat{r}^T r_0 - \\alpha_0 \\hat{r}^T A p_0 = 0\n$$\n解出 $\\alpha_0$ 可得：\n$$\n\\alpha_0 = \\frac{\\hat{r}^T r_0}{\\hat{r}^T A p_0}\n$$\n给定初始条件 $x_0 = 0$， $r_0 = b - A x_0 = b$。我们还知道 $\\hat{r} = r_0$ 和 $p_0 = r_0$。因此，$\\alpha_0$ 的表达式简化为：\n$$\n\\alpha_0 = \\frac{r_0^T r_0}{r_0^T A r_0}\n$$\n我们计算必要的量。初始残差为 $r_0 = b = \\begin{pmatrix} 1 & 1 & 1 & 1 \\end{pmatrix}^T$。\n分子是 $r_0$ 的范数的平方：\n$$\nr_0^T r_0 = 1^2 + 1^2 + 1^2 + 1^2 = 4\n$$\n对于分母，我们首先计算乘积 $A r_0$：\n$$\nA r_0 = \\begin{pmatrix} \\varepsilon  1  0  0\\\\ -1  \\varepsilon  1  0\\\\ 0  -1  \\varepsilon  1\\\\ 0  0  -1  \\varepsilon \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} \\varepsilon+1 \\\\ -1+\\varepsilon+1 \\\\ -1+\\varepsilon+1 \\\\ -1+\\varepsilon \\end{pmatrix} = \\begin{pmatrix} 1+\\varepsilon \\\\ \\varepsilon \\\\ \\varepsilon \\\\ \\varepsilon-1 \\end{pmatrix}\n$$\n然后我们计算内积 $r_0^T A r_0$：\n$$\nr_0^T A r_0 = \\begin{pmatrix} 1 & 1 & 1 & 1 \\end{pmatrix} \\begin{pmatrix} 1+\\varepsilon \\\\ \\varepsilon \\\\ \\varepsilon \\\\ \\varepsilon-1 \\end{pmatrix} = (1+\\varepsilon) + \\varepsilon + \\varepsilon + (\\varepsilon-1) = 4\\varepsilon\n$$\n因此，$\\alpha_0$ 是：\n$$\n\\alpha_0 = \\frac{4}{4\\varepsilon} = \\frac{1}{\\varepsilon}\n$$\n当 $\\varepsilon = 10^{-3}$ 时，我们有 $\\alpha_0 = 1000$。\n\n接下来，我们确定系数 $\\omega_0$。这是通过最小化下一个残差 $r_1 = s_0 - \\omega_0 A s_0$ 的欧几里得范数来找到的。这是一个关于标量 $\\omega_0$ 的线性最小二乘问题。为了找到 $\\|r_1\\|_2^2$ 的最小值，我们将关于 $\\omega_0$ 的导数设为零：\n$$\n\\frac{d}{d\\omega_0} \\|s_0 - \\omega_0 A s_0\\|_2^2 = \\frac{d}{d\\omega_0} \\left( (s_0 - \\omega_0 A s_0)^T (s_0 - \\omega_0 A s_0) \\right) = 0\n$$\n$$\n\\frac{d}{d\\omega_0} \\left( s_0^T s_0 - 2\\omega_0 s_0^T A s_0 + \\omega_0^2 (A s_0)^T A s_0 \\right) = -2 s_0^T A s_0 + 2\\omega_0 (A s_0)^T A s_0 = 0\n$$\n解出 $\\omega_0$ 得到：\n$$\n\\omega_0 = \\frac{s_0^T A s_0}{(A s_0)^T A s_0} = \\frac{s_0^T (A s_0)}{\\|A s_0\\|_2^2}\n$$\n为了计算这个，我们首先需要找到 $s_0 = r_0 - \\alpha_0 A r_0$：\n$$\ns_0 = \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\\\ 1 \\end{pmatrix} - \\frac{1}{\\varepsilon} \\begin{pmatrix} 1+\\varepsilon \\\\ \\varepsilon \\\\ \\varepsilon \\\\ \\varepsilon-1 \\end{pmatrix} = \\begin{pmatrix} 1 - \\frac{1}{\\varepsilon} - 1 \\\\ 1-1 \\\\ 1-1 \\\\ 1 - \\frac{\\varepsilon-1}{\\varepsilon} \\end{pmatrix} = \\begin{pmatrix} -1/\\varepsilon \\\\ 0 \\\\ 0 \\\\ 1/\\varepsilon \\end{pmatrix}\n$$\n现在我们计算 $A s_0$：\n$$\nA s_0 = \\begin{pmatrix} \\varepsilon  1  0  0\\\\ -1  \\varepsilon  1  0\\\\ 0  -1  \\varepsilon  1\\\\ 0  0  -1  \\varepsilon \\end{pmatrix} \\begin{pmatrix} -1/\\varepsilon \\\\ 0 \\\\ 0 \\\\ 1/\\varepsilon \\end{pmatrix} = \\begin{pmatrix} \\varepsilon(-1/\\varepsilon) \\\\ -1(-1/\\varepsilon) \\\\ 1(1/\\varepsilon) \\\\ \\varepsilon(1/\\varepsilon) \\end{pmatrix} = \\begin{pmatrix} -1 \\\\ 1/\\varepsilon \\\\ 1/\\varepsilon \\\\ 1 \\end{pmatrix}\n$$\n现在我们可以计算 $\\omega_0$ 的内积。分子是：\n$$\ns_0^T A s_0 = \\begin{pmatrix} -1/\\varepsilon & 0 & 0 & 1/\\varepsilon \\end{pmatrix} \\begin{pmatrix} -1 \\\\ 1/\\varepsilon \\\\ 1/\\varepsilon \\\\ 1 \\end{pmatrix} = (-1/\\varepsilon)(-1) + (1/\\varepsilon)(1) = \\frac{2}{\\varepsilon}\n$$\n分母是：\n$$\n(A s_0)^T (A s_0) = \\begin{pmatrix} -1 & 1/\\varepsilon & 1/\\varepsilon & 1 \\end{pmatrix} \\begin{pmatrix} -1 \\\\ 1/\\varepsilon \\\\ 1/\\varepsilon \\\\ 1 \\end{pmatrix} = (-1)^2 + (1/\\varepsilon)^2 + (1/\\varepsilon)^2 + 1^2 = 2 + \\frac{2}{\\varepsilon^2}\n$$\n所以，$\\omega_0$ 是：\n$$\n\\omega_0 = \\frac{2/\\varepsilon}{2 + 2/\\varepsilon^2} = \\frac{2/\\varepsilon}{2(1 + 1/\\varepsilon^2)} = \\frac{1/\\varepsilon}{ \\frac{\\varepsilon^2+1}{\\varepsilon^2} } = \\frac{\\varepsilon}{\\varepsilon^2+1}\n$$\n对于 $\\varepsilon = 10^{-3}$，我们有 $\\omega_0 = \\frac{10^{-3}}{(10^{-3})^2+1} = \\frac{10^{-3}}{1.000001} \\approx 10^{-3}$。这个值确实很小。\n\n接近失效（或停滞）的机制通过 $s_0$ 和 $A s_0$ 之间的关系揭示出来。$\\omega_0$ 的选择是沿 $A s_0$ 方向进行类似最速下降法最小化的最优步长。此步骤的有效性取决于 $s_0$ 和 $A s_0$ 的对齐程度。它们之间夹角 $\\theta$ 的余弦由下式给出：\n$$\n\\cos(\\theta) = \\frac{s_0^T A s_0}{\\|s_0\\|_2 \\|A s_0\\|_2}\n$$\n我们有 $\\|s_0\\|_2 = \\sqrt{(-1/\\varepsilon)^2 + (1/\\varepsilon)^2} = \\frac{\\sqrt{2}}{\\varepsilon}$ 和 $\\|A s_0\\|_2 = \\sqrt{2 + \\frac{2}{\\varepsilon^2}} = \\frac{\\sqrt{2\\varepsilon^2+2}}{\\varepsilon}$。\n$$\n\\cos(\\theta) = \\frac{2/\\varepsilon}{ (\\frac{\\sqrt{2}}{\\varepsilon}) (\\frac{\\sqrt{2\\varepsilon^2+2}}{\\varepsilon}) } = \\frac{2/\\varepsilon}{ \\frac{2\\sqrt{\\varepsilon^2+1}}{\\varepsilon^2} } = \\frac{\\varepsilon}{\\sqrt{\\varepsilon^2+1}}\n$$\n对于小的 $\\varepsilon$，$\\cos(\\theta) \\approx \\varepsilon$。当 $\\varepsilon \\to 0$ 时，$\\cos(\\theta) \\to 0$，这意味着 $\\theta \\to \\pi/2$。向量 $s_0$ 和 $A s_0$ 几乎正交。最小化步骤试图通过减去 $A s_0$ 的一个倍数来减小残差 $s_0$。由于 $A s_0$ 与 $s_0$ 几乎正交，只有 $s_0$ 的一个非常小的分量位于 $A s_0$ 的方向上。因此，最优步长 $\\omega_0$ 很小，残差范数的减小也很小，从而导致停滞。\n\n**任务2：计算 $\\|r_1^{\\mathrm{repl}}\\|_2$。**\n\n问题陈述指出，残差可能被舍入误差污染，并使用了一种替换策略。我们被要求计算精确重新计算的残差 $r_1^{\\mathrm{repl}} = b - A x_1$ 的欧几里得范数。\n首先，我们计算更新后的迭代 $x_1$：\n$$\nx_1 = x_0 + \\alpha_0 p_0 + \\omega_0 s_0\n$$\n当 $x_0 = 0, p_0 = r_0 = b$ 时，这变为：\n$$\nx_1 = \\alpha_0 b + \\omega_0 s_0 = \\frac{1}{\\varepsilon} \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\\\ 1 \\end{pmatrix} + \\frac{\\varepsilon}{1+\\varepsilon^2} \\begin{pmatrix} -1/\\varepsilon \\\\ 0 \\\\ 0 \\\\ 1/\\varepsilon \\end{pmatrix} = \\begin{pmatrix} 1/\\varepsilon \\\\ 1/\\varepsilon \\\\ 1/\\varepsilon \\\\ 1/\\varepsilon \\end{pmatrix} + \\begin{pmatrix} -1/(1+\\varepsilon^2) \\\\ 0 \\\\ 0 \\\\ 1/(1+\\varepsilon^2) \\end{pmatrix}\n$$\n$$\nx_1 = \\begin{pmatrix} \\frac{1}{\\varepsilon} - \\frac{1}{1+\\varepsilon^2} \\\\ \\frac{1}{\\varepsilon} \\\\ \\frac{1}{\\varepsilon} \\\\ \\frac{1}{\\varepsilon} + \\frac{1}{1+\\varepsilon^2} \\end{pmatrix}\n$$\n接下来，我们计算 $A x_1$。一种更简单的方法是使用 $r_1^{\\mathrm{repl}}$ 的定义，它等于精确算术下的 $r_1 = s_0 - \\omega_0 A s_0$。\n$r_1^{\\mathrm{repl}} = r_1 = s_0 - \\omega_0 A s_0 = \\begin{pmatrix} -1/\\varepsilon \\\\ 0 \\\\ 0 \\\\ 1/\\varepsilon \\end{pmatrix} - \\frac{\\varepsilon}{1+\\varepsilon^2} \\begin{pmatrix} -1 \\\\ 1/\\varepsilon \\\\ 1/\\varepsilon \\\\ 1 \\end{pmatrix}$\n$$\nr_1^{\\mathrm{repl}} = \\begin{pmatrix} -1/\\varepsilon + \\varepsilon/(1+\\varepsilon^2) \\\\ -1/(1+\\varepsilon^2) \\\\ -1/(1+\\varepsilon^2) \\\\ 1/\\varepsilon - \\varepsilon/(1+\\varepsilon^2) \\end{pmatrix}\n$$\n简化第一和第四个分量：\n\\begin{itemize}\n    \\item 第1行：$\\frac{-(1+\\varepsilon^2) + \\varepsilon^2}{\\varepsilon(1+\\varepsilon^2)} = \\frac{-1}{\\varepsilon(1+\\varepsilon^2)}$\n    \\item 第4行：$\\frac{1+\\varepsilon^2 - \\varepsilon^2}{\\varepsilon(1+\\varepsilon^2)} = \\frac{1}{\\varepsilon(1+\\varepsilon^2)}$\n\\end{itemize}\n所以，替换后的残差是：\n$$\nr_1^{\\mathrm{repl}} = \\begin{pmatrix} -1/(\\varepsilon(1+\\varepsilon^2)) \\\\ -1/(1+\\varepsilon^2) \\\\ -1/(1+\\varepsilon^2) \\\\ 1/(\\varepsilon(1+\\varepsilon^2)) \\end{pmatrix}\n$$\n最后，我们计算它的欧几里得范数 $\\|r_1^{\\mathrm{repl}}\\|_2$：\n$$\n\\|r_1^{\\mathrm{repl}}\\|_2^2 = \\left(\\frac{-1}{\\varepsilon(1+\\varepsilon^2)}\\right)^2 + \\left(\\frac{-1}{1+\\varepsilon^2}\\right)^2 + \\left(\\frac{-1}{1+\\varepsilon^2}\\right)^2 + \\left(\\frac{1}{\\varepsilon(1+\\varepsilon^2)}\\right)^2\n$$\n$$\n\\|r_1^{\\mathrm{repl}}\\|_2^2 = \\frac{1}{\\varepsilon^2(1+\\varepsilon^2)^2} + \\frac{1}{(1+\\varepsilon^2)^2} + \\frac{1}{(1+\\varepsilon^2)^2} + \\frac{1}{\\varepsilon^2(1+\\varepsilon^2)^2}\n$$\n$$\n\\|r_1^{\\mathrm{repl}}\\|_2^2 = \\frac{2}{\\varepsilon^2(1+\\varepsilon^2)^2} + \\frac{2}{(1+\\varepsilon^2)^2} = \\frac{2(1+\\varepsilon^2)}{\\varepsilon^2(1+\\varepsilon^2)^2} = \\frac{2}{\\varepsilon^2(1+\\varepsilon^2)}\n$$\n$$\n\\|r_1^{\\mathrm{repl}}\\|_2 = \\sqrt{\\frac{2}{\\varepsilon^2(1+\\varepsilon^2)}} = \\frac{\\sqrt{2}}{|\\varepsilon|\\sqrt{1+\\varepsilon^2}}\n$$\n代入 $\\varepsilon = 10^{-3}$：\n$$\n\\|r_1^{\\mathrm{repl}}\\|_2 = \\frac{\\sqrt{2}}{10^{-3}\\sqrt{1+(10^{-3})^2}} = \\frac{\\sqrt{2}}{10^{-3}\\sqrt{1.000001}}\n$$\n数值上，这是：\n$$\n\\|r_1^{\\mathrm{repl}}\\|_2 \\approx 1000 \\times \\frac{1.41421356}{1.0000005} \\approx 1414.21285\n$$\n四舍五入到四位有效数字得到 $1414$。",
            "answer": "$$\\boxed{1414}$$"
        },
        {
            "introduction": "将理论知识与计算实践相结合是计算地球力学研究的最终目标。这项综合性练习要求您从零开始，编写一个灵活通用最小残差法 (FGMRES) 求解器，并将其应用于一个模拟分层土体行为的实际问题。您不仅需要构建有限差分模型，还需实现一种先进的混合精度预处理策略，这模拟了在现代计算架构（如CPU+GPU）上求解问题的真实场景。这项实践将全面考验您将算法理论转化为高效、稳健代码的能力 。",
            "id": "3537429",
            "problem": "考虑单位正方形域上的准静态、小应变、标量代理的土壤力学问题，其中离散的线性动量平衡可简化为线性系统 $A x = b$，其中 $A \\in \\mathbb{R}^{n \\times n}$ 是对称正定矩阵。矩阵 $A$ 是由变系数扩散算子 $-\\nabla \\cdot (k(\\mathbf{x}) \\nabla u)$ 产生的类刚度矩阵，整个边界上施加零狄利克雷边界条件。系数 $k(\\mathbf{x})$ 代表有效的刚度代理，在水平层内是分段常数，以模拟层间具有刚度差异的土壤。\n\n以双精度实现一个灵活的广义最小残差 (FGMRES) 算法作为外层求解器，以近似求解 $A x = b$，并使用一个在单精度下应用的右预条件子 $M^{-1}$。预条件子必须是在单精度算术下计算和应用的对角（雅可比）预条件子，而所有外层 FGMRES 向量运算和残差最小化必须在双精度算术下执行。这模拟了一种混合精度策略，其中预处理以单精度卸载到图形处理单元 (GPU) 上，而 Krylov 子空间操作则在中央处理单元 (CPU) 上以双精度执行。FGMRES 的实现必须从第一性原理出发，使用带有 Givens 旋转的 Arnoldi 过程，并且必须支持重启。\n\n你必须在均匀网格上通过有限差分法构建 $A$，该网格在 $x$ 方向有 $N_x$ 个节点，在 $y$ 方向有 $N_y$ 个节点，并使用针对变系数算子的标准五点模板。设未知数仅定义在内部节点上，因此未知数的数量为 $(N_x-2)(N_y-2)$。设网格间距为 $h_x = 1/(N_x-1)$ 和 $h_y = 1/(N_y-1)$，且 $h_x = h_y$。对界面系数使用调和平均以确保对称性和强制性：如果 $k_i$ 和 $k_j$ 是跨一个面的相邻单元中的系数，则面系数为 $k_f = 2 k_i k_j / (k_i + k_j)$。右端项必须是与均匀体积荷载 $f = 1$ 相对应的 $b$，并根据有限差分格式进行一致的缩放。\n\n定义一个在 $y = 0.5$ 处有水平分层的土壤。设刚度代理在上半部分（$y  0.5$）取值为 $k_{\\text{soft}} = 1$，在下半部分（$y \\ge 0.5$）取值为 $k_{\\text{stiff}} = \\rho$，其中 $\\rho$ 是刚度对比度。对比度 $\\rho$ 控制着 $A$ 的条件数，从而影响 Krylov 方法的收敛行为。\n\n你必须评估在固定的计算预算下，刚度对比度如何影响可实现的残差缩减，对于每个测试用例，报告在使用具有指定重启长度的 FGMRES 算法，并耗尽等于给定最大迭代预算的矩阵向量积总数后，比率 $\\|r_k\\|_2 / \\|r_0\\|_2$ 的值。其中，$r_k = b - A x_k$ 是第 $k$ 次迭代的残差，而 $x_0 = 0$ 是初始猜测。\n\n使用的基本原理：\n- 在均匀网格上对 $-\\nabla \\cdot (k(\\mathbf{x}) \\nabla u) = f$ 进行有限差分格式离散化，采用零狄利克雷边界条件和系数的调和平均。\n- Krylov 子空间的定义以及用于构建标准正交基和相关上 Hessenberg 矩阵的 Arnoldi 过程，该过程产生一个可通过 Givens 旋转最小化的最小二乘问题。\n- 预处理概念 $M \\approx A$ 和右预处理 FGMRES，要求预处理以单精度应用，而外层 FGMRES 以双精度应用。\n\n你不能使用任何外部输入。所有实现都需自包含，并返回一行输出，其中包含用方括号括起来的、以逗号分隔的测试套件结果。\n\n测试套件：\n- 案例 1：$(N_x, N_y, \\rho, m, K_{\\max}) = (34, 34, 1, 30, 60)$。\n- 案例 2：$(N_x, N_y, \\rho, m, K_{\\max}) = (34, 34, 10^3, 30, 60)$。\n- 案例 3：$(N_x, N_y, \\rho, m, K_{\\max}) = (34, 34, 10^6, 30, 60)$。\n- 案例 4（测试极端对比度下短重启的边缘情况）：$(N_x, N_y, \\rho, m, K_{\\max}) = (34, 34, 10^6, 10, 20)$。\n\n算法要求：\n- 使用跨面的调和平均构建稀疏矩阵 $A$，未知数仅位于内部节点上。使用与均匀施加于内部节点上的 $f=1$ 相对应的 $b$，并按单元面积进行适当缩放。\n- 实现带重启 $m$ 和最大总预算 $K_{\\max}$ 次矩阵向量积的右预处理 FGMRES。使用 $x_0 = 0$。\n- 预条件子 $M^{-1}$ 必须是 $A$ 的对角逆，并在单精度下计算和应用。也就是说，如果 $D = \\operatorname{diag}(A)$，则使用单精度算术应用 $z = D^{-1} r$，将输入转换为单精度，并将输出转回双精度。\n- 在算法完成允许的预算后，记录最终的残差缩减 $\\|r_k\\|_2 / \\|r_0\\|_2$。\n\n最终输出格式：\n- 你的程序应生成一行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如，\"[result1,result2,result3,result4]\"）。\n- 每个结果必须是一个以科学记数法表示的浮点数，小数点后恰好有六位数字（例如，\"1.234567e-08\"）。\n- 不涉及单位；报告纯无量纲比率。\n\n你的程序将根据正确性、鲁棒性、对混合精度约束和指定输出格式的遵守情况进行评判。不允许用户输入，也不应使用随机化，以确保结果是确定性的。",
            "solution": "该问题要求实现一种灵活、混合精度、预处理的广义最小残差 (FGMRES) 方法，以求解线性方程组 $A x = b$。该系统源于变系数扩散方程的有限差分格式离散化，该方程可作为准静态土壤力学的标量代理。目标是评估在分层土壤模型中，求解器在不同刚度对比度下的性能。\n\n### 1. 数学模型与离散化\n\n该物理问题由单位正方形域 $\\Omega = (0,1) \\times (0,1)$ 上的偏微分方程 (PDE) 建模：\n$$ -\\nabla \\cdot (k(\\mathbf{x}) \\nabla u(\\mathbf{x})) = f(\\mathbf{x}) $$\n并带有零狄利克雷边界条件，$u(\\mathbf{x}) = 0$ on $\\partial\\Omega$。系数 $k(\\mathbf{x})$ 代表土壤刚度的代理，并且是分段常数。对于在 $y=0.5$ 处的水平界面，$k(\\mathbf{x})$ 在 $y  0.5$ 时为 $k_{\\text{soft}} = 1$，在 $y \\ge 0.5$ 时为 $k_{\\text{stiff}} = \\rho$，其中 $\\rho$ 是刚度对比度。源项 $f(\\mathbf{x}) = 1$ 对应于均匀的体积荷载。\n\n我们使用五点有限差分模板在一个具有 $N_x \\times N_y$ 个节点和网格间距 $h = h_x = h_y = 1/(N_x-1)$ 的均匀网格上离散化此偏微分方程。未知数 $u_{i,j}$位于内部节点 $(x_i, y_j)$ 上，其中 $i,j \\in \\{1, \\dots, N_x-2\\}$。在每个节点 $(i,j)$ 周围的面积为 $h^2$ 的控制体积上对偏微分方程进行积分，得到离散线性系统 $Ax=b$。\n\n对应于节点 $p$ 和 $q$ 之间相互作用的矩阵项 $A_{pq}$ 是从通量项 $-k_f \\nabla u \\cdot \\mathbf{n}$ 导出的，其中 $k_f$ 是单元之间面上的系数。为确保所得矩阵 $A$ 是对称正定 (SPD) 的，我们对单元面上的系数使用调和平均。对于刚度为 $k_1$ 和 $k_2$ 的单元之间的面，面刚度为 $k_f = 2 k_1 k_2 / (k_1 + k_2)$。\n\n对应于网格点 $(i,j)$ 的内部节点 $p$ 的模板是：\n$$ A_{p,p} u_{i,j} + A_{p,p_W} u_{i-1,j} + A_{p,p_E} u_{i+1,j} + A_{p,p_S} u_{i,j-1} + A_{p,p_N} u_{i,j+1} = b_p $$\n其中系数由面刚度给出：\n- 对角线：$A_{p,p} = k_{i-1/2,j} + k_{i+1/2,j} + k_{i,j-1/2} + k_{i,j+1/2}$\n- 非对角线：$A_{p,p_W} = -k_{i-1/2,j}$，$A_{p,p_E} = -k_{i+1/2,j}$，等。\n右端项是 $b_p = f_{i,j} h^2 = h^2$，因为 $f=1$。未知数通过行主序映射从二维网格索引排列到一个大小为 $n = (N_x-2)(N_y-2)$ 的向量 $x$ 中。\n\n### 2. 带有混合精度预处理的灵活 GMRES (FGMRES)\n\n这个大型稀疏线性系统 $A x = b$ 通过迭代方法求解。我们使用重启的 FGMRES 方法，这是一种 Krylov 子空间方法，适用于每一步都可能变化或非线性的预条件子。这种“灵活性”对于我们的混合精度策略至关重要。\n\n**算法概述**：FGMRES(m) 在一个维度为 $m$ 的 Krylov 子空间中迭代地寻找近似解。经过 $m$ 次迭代后，求解器将重启，使用当前解作为下一个周期的初始猜测。\n\n1.  **初始化**：从初始猜测 $x_0 = 0$ 开始。初始残差为 $r_0 = b - A x_0 = b$。\n2.  **重启周期**：一个周期由 $m$ 步 Arnoldi 过程组成。\n    -   在周期开始时，将当前残差 $r$ 归一化，形成新 Krylov 子空间的第一个基向量：$v_1 = r / \\|r\\|_2$。\n    -   **Arnoldi 过程**：对于 $j=1, \\dots, m$：\n        a.  **预处理**：将预条件子应用于当前基向量：$z_j = M^{-1}v_j$。这是灵活的步骤；标准的 GMRES 会为固定的算子 $AM^{-1}$ 构建 Krylov 空间。\n        b.  **矩阵向量积**：计算 $w = A z_j$。这是计算成本最高的操作。\n        c.  **正交化**：使用修正的 Gram-Schmidt 过程将 $w$ 与现有基向量 $\\{v_1, \\dots, v_j\\}$ 正交化。这会产生新的基向量 $v_{j+1}$ 和一个 $(m+1) \\times m$ 上 Hessenberg 矩阵 $\\bar{H}_m$ 的第 $j$ 列。Arnoldi 过程生成一个标准正交基 $V_{m+1} = [v_1, \\dots, v_{m+1}]$ 和一个预处理向量矩阵 $Z_m = [z_1, \\dots, z_m]$，使得 $A Z_m = V_{m+1} \\bar{H}_m$。\n3.  **最小二乘问题**：通过求解一个小的最小二乘问题来找到周期内的解增量：寻找 $y_m \\in \\mathbb{R}^m$ 使 $\\| \\|r\\|_2 e_1 - \\bar{H}_m y_m \\|_2$ 最小化。该问题通过使用 Givens 旋转被高效地即时解决，Givens 旋转将 $\\bar{H}_m$ 转换为一个上三角矩阵 $R_m$，并将右端项 $\\|r\\|_2 e_1$ 转换为一个新向量 $g$。\n4.  **解的更新**：通过回代法求解三角系统 $R_m y_m = g_{1:m}$ 以得到 $y_m$。然后更新解：$x \\leftarrow x + Z_m y_m$。\n5.  **终止条件**：该过程会持续多个重启周期，直到耗尽矩阵向量积的最大预算 $K_{\\max}$。\n\n### 3. 混合精度雅可比预条件子\n\n预处理用于通过将系统转换为更易于求解的系统来加速收敛。我们使用一个简单的右预条件子 $M^{-1}$，其中 $M$ 是 $A$ 的对角线（雅可比预条件子）。预处理后的系统是 $A M^{-1} (M x) = b$。\n\n关键要求是混合精度：\n-   外层 FGMRES 循环（向量运算、内积、范数）以**双精度**（`numpy.float64`）执行。\n-   预条件子应用，$z=M^{-1}r$，以**单精度**（`numpy.float32`）执行。这模拟了将这个计算密集但通常对精度要求不高的任务卸载到像 GPU 这样擅长单精度算术的硬件上。\n\n预处理步骤 $z = M^{-1}r$ 的实现如下：\n1.  存储为 $D = \\operatorname{diag}(A)$ 的 $A$ 的对角线被转换为单精度。\n2.  输入的残差向量 $r$（双精度）被转换为单精度。\n3.  按元素进行的除法 $z_i = r_i / D_i$ 以单精度执行。\n4.  结果向量 $z$ 在 FGMRES 算法中使用之前被转回双精度。\n\n这种精度转换使预条件子成为一个非线性算子，因此有必要使用像 FGMRES 这样的灵活方法。\n\n### 4. 最终评估\n\n在 FGMRES 算法耗尽 $K_{\\max}$ 次矩阵向量积的总预算后，得到最终解向量 $x_{K_{\\max}}$。通过计算最终的真实残差 $r_{K_{\\max}} = b - A x_{K_{\\max}}$ 并报告相对残差范数缩减来评估性能：$\\|r_{K_{\\max}}\\|_2 / \\|r_0\\|_2$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import lil_matrix, csr_matrix\nfrom scipy.linalg import solve_triangular\nimport math\n\ndef build_stiffness_matrix(Nx, Ny, rho):\n    \"\"\"\n    Builds the finite difference stiffness matrix A for the variable-coefficient\n    diffusion problem and the corresponding right-hand side vector b.\n\n    Args:\n        Nx (int): Number of grid points in the x-direction.\n        Ny (int): Number of grid points in the y-direction.\n        rho (float): Stiffness contrast ratio.\n\n    Returns:\n        tuple: A CSR sparse matrix (A) and a NumPy array (b).\n    \"\"\"\n    if Nx != Ny:\n        raise ValueError(\"Grid must be square (Nx=Ny).\")\n    h = 1.0 / (Nx - 1)\n    n_int_x = Nx - 2\n    n_int_y = Ny - 2\n    n_unknowns = n_int_x * n_int_y\n\n    y_coords = np.linspace(0, 1, Ny, dtype=np.float64)\n    k_vals_at_nodes = np.ones(Ny, dtype=np.float64)\n    k_vals_at_nodes[y_coords >= 0.5] = rho\n    \n    k_grid = np.ones((Nx, Ny), dtype=np.float64) * k_vals_at_nodes[np.newaxis, :].T\n\n    A = lil_matrix((n_unknowns, n_unknowns), dtype=np.float64)\n    b = np.full(n_unknowns, h * h, dtype=np.float64)\n\n    def harmonic_mean(k1, k2):\n        if k1 + k2 == 0: return 0.0\n        return 2.0 * k1 * k2 / (k1 + k2)\n\n    for j_node in range(1, Ny - 1):\n        for i_node in range(1, Nx - 1):\n            p = (j_node - 1) * n_int_x + (i_node - 1)\n\n            k_center = k_grid[i_node, j_node]\n            k_W = harmonic_mean(k_center, k_grid[i_node - 1, j_node])\n            k_E = harmonic_mean(k_center, k_grid[i_node + 1, j_node])\n            k_S = harmonic_mean(k_center, k_grid[i_node, j_node - 1])\n            k_N = harmonic_mean(k_center, k_grid[i_node, j_node + 1])\n\n            A[p, p] = k_W + k_E + k_S + k_N\n            \n            if i_node > 1: A[p, p - 1] = -k_W\n            if i_node  n_int_x: A[p, p + 1] = -k_E\n            if j_node > 1: A[p, p - n_int_x] = -k_S\n            if j_node  n_int_y: A[p, p + n_int_x] = -k_N\n                \n    return A.tocsr(), b\n\ndef fgmres(A, b, x0, m, K_max, preconditioner):\n    \"\"\"\n    Implements a right-preconditioned Flexible GMRES (FGMRES) method.\n\n    Args:\n        A (scipy.sparse.csr_matrix): The system matrix.\n        b (np.ndarray): The right-hand side vector.\n        x0 (np.ndarray): The initial guess.\n        m (int): The restart length.\n        K_max (int): Maximum number of matrix-vector products.\n        preconditioner (callable): The preconditioning function.\n\n    Returns:\n        tuple: The final solution vector (x) and the initial residual norm (r0_norm).\n    \"\"\"\n    n = A.shape[0]\n    x = x0.copy().astype(np.float64)\n    \n    # K_max is budget for Arnoldi matvecs, initial residual is separate\n    if np.any(x0):\n        r = b - A @ x\n    else:\n        r = b.copy()\n\n    r0_norm = np.linalg.norm(r)\n    if r0_norm == 0:\n        return x, r0_norm\n\n    total_mv = 0\n    while total_mv  K_max:\n        m_cycle = min(m, K_max - total_mv)\n        if m_cycle = 0: break\n\n        beta = np.linalg.norm(r)\n        if beta / r0_norm  1e-12: break # converged\n\n        V = [r / beta]\n        Z = []\n        H = np.zeros((m_cycle + 1, m_cycle), dtype=np.float64)\n        \n        breakdown_j = -1\n        # Arnoldi process\n        for j in range(m_cycle):\n            z_j = preconditioner(V[j])\n            Z.append(z_j)\n            w = A @ z_j\n            total_mv += 1\n\n            w_ortho = w.copy()\n            for i in range(j + 1):\n                H[i, j] = np.dot(V[i], w_ortho)\n                w_ortho -= H[i, j] * V[i]\n            \n            H[j + 1, j] = np.linalg.norm(w_ortho)\n            if H[j + 1, j]  1e-15:\n                breakdown_j = j\n                break\n            \n            V.append(w_ortho / H[j + 1, j])\n        \n        if breakdown_j != -1:\n            m_cycle = breakdown_j + 1\n            H = H[:m_cycle + 1, :m_cycle]\n\n        # Solve Least Squares via Givens rotations\n        g = np.zeros(m_cycle + 1, dtype=np.float64)\n        g[0] = beta\n        H_qr = H.copy()\n\n        for j in range(m_cycle):\n            c, s = givens_rotation(H_qr[j, j], H_qr[j + 1, j])\n            rot_mat = np.array([[c, s], [-s, c]])\n            H_qr[j:j+2, j:] = rot_mat @ H_qr[j:j+2, j:]\n            g[j:j+2] = rot_mat @ g[j:j+2]\n            \n        y = solve_triangular(H_qr[:m_cycle, :m_cycle], g[:m_cycle], check_finite=False)\n        \n        # Update solution vector x\n        for i in range(m_cycle):\n            x += y[i] * Z[i]\n\n        # Efficiently update residual for the next restart cycle\n        res_in_V_basis = beta * np.eye(m_cycle + 1, 1).flatten() - H @ y\n        r = np.zeros_like(b, dtype=np.float64)\n        for i in range(m_cycle + 1):\n            r += res_in_V_basis[i] * V[i]\n        \n        if breakdown_j != -1:\n            break\n            \n    return x, r0_norm\n\ndef solve():\n    test_cases = [\n        (34, 34, 1.0, 30, 60),\n        (34, 34, 1e3, 30, 60),\n        (34, 34, 1e6, 30, 60),\n        (34, 34, 1e6, 10, 20),\n    ]\n\n    results = []\n    for Nx, Ny, rho, m, K_max in test_cases:\n        A, b = build_stiffness_matrix(Nx, Ny, rho)\n        n_unknowns = (Nx-2) * (Ny-2)\n        x0 = np.zeros(n_unknowns, dtype=np.float64)\n        \n        # Define the mixed-precision preconditioner\n        D_single = A.diagonal().astype(np.float32)\n        def jacobi_preconditioner_sp(res_dp):\n            res_sp = res_dp.astype(np.float32)\n            z_sp = res_sp / D_single\n            return z_sp.astype(np.float64)\n        \n        # Run FGMRES\n        x_final, r0_norm = fgmres(A, b, x0, m, K_max, jacobi_preconditioner_sp)\n        \n        # Calculate final residual ratio for reporting\n        r_final = b - A @ x_final\n        final_ratio = np.linalg.norm(r_final) / r0_norm if r0_norm > 0 else 0.0\n        results.append(f\"{final_ratio:.6e}\")\n        \n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}