{
    "hands_on_practices": [
        {
            "introduction": "This first practice is a cornerstone exercise in computational mechanics. By building a small finite element solver from scratch, you will directly observe the phenomenon of volumetric locking, where simple elements become excessively stiff when modeling nearly incompressible materials. This exercise  highlights the performance differences between the basic Constant Strain Triangle (CST) and the higher-order Linear Strain Triangle (LST), providing a tangible understanding of why element choice is critical in geomechanics simulations involving clays, undrained soils, or rock under high confinement.",
            "id": "3569137",
            "problem": "You are to implement from first principles a small-strain, two-dimensional, plane-strain, linear elastic finite element solver using triangular elements to numerically measure the hydrostatic bulk modulus under uniform compressive tractions on a square domain. Your solver must support both the constant-strain triangle (CST) and the six-node quadratic triangle (Lagrange six-node triangle, often called LST). The computational task is to assemble the global stiffness matrix from element contributions, apply uniform compressive tractions on all four sides, constrain the rigid body modes minimally, solve for the displacement field, and post-process the numerical bulk modulus as the ratio of averaged hydrostatic mean stress magnitude to averaged volumetric strain magnitude. The aim is to compare sensitivity to Poisson’s ratio and to identify volumetric locking via overprediction of the numerical bulk modulus for nearly incompressible materials.\n\nStart from the following fundamentals and definitions:\n- Small-strain kinematics: the in-plane strain tensor components are $ \\varepsilon_{xx} = \\partial u/\\partial x $, $ \\varepsilon_{yy} = \\partial v/\\partial y $, and $ \\gamma_{xy} = \\partial u/\\partial y + \\partial v/\\partial x $, where $ u $ and $ v $ are the displacement components in the $ x $ and $ y $ directions, respectively.\n- Linear momentum balance in weak form for a body of thickness $ t $ and domain $ \\Omega $ with boundary $ \\partial \\Omega $ on which tractions $ \\mathbf{t} $ are prescribed: find $ \\mathbf{u} \\in \\mathcal{V} $ such that $ \\int_{\\Omega} \\boldsymbol{\\varepsilon}(\\mathbf{u}) : \\mathbf{C} : \\boldsymbol{\\varepsilon}(\\mathbf{w})\\, d\\Omega = \\int_{\\partial \\Omega_t} \\mathbf{t} \\cdot \\mathbf{w}\\, d\\Gamma $ for all virtual displacements $ \\mathbf{w} \\in \\mathcal{V}_0 $, where $ \\mathbf{C} $ is the fourth-order elasticity tensor and $ \\boldsymbol{\\varepsilon}(\\cdot) $ is the symmetric gradient.\n- Constitutive law (isotropic linear elasticity) under the plane-strain assumption: $ \\boldsymbol{\\sigma} = \\mathbf{D}_{\\text{ps}} \\boldsymbol{\\varepsilon} $, where $ \\mathbf{D}_{\\text{ps}} $ is the $ 3 \\times 3 $ plane-strain elasticity matrix depending on Young’s modulus $ E $ and Poisson’s ratio $ \\nu $. Use small-strain isotropic elasticity consistent with plane strain.\n- Hydrostatic mean stress (three-dimensional) is defined as $ p = -\\tfrac{1}{3}(\\sigma_{xx} + \\sigma_{yy} + \\sigma_{zz}) $. Under plane strain, $ \\varepsilon_{zz} = 0 $ and $ \\sigma_{zz} $ is nonzero and must be included in $ p $ for a consistent bulk modulus measurement.\n- Volumetric strain (three-dimensional) is $ \\varepsilon_v = \\varepsilon_{xx} + \\varepsilon_{yy} + \\varepsilon_{zz} $. Under plane strain, $ \\varepsilon_{zz} = 0 $, thus $ \\varepsilon_v = \\varepsilon_{xx} + \\varepsilon_{yy} $.\n\nProblem geometry and loading:\n- Domain: a unit square of side length $ L = 1\\,\\text{m} $ and thickness $ t = 1\\,\\text{m} $.\n- Material: homogeneous, isotropic with Young’s modulus $ E = 100\\,\\text{MPa} $ and variable Poisson’s ratio $ \\nu $.\n- Boundary tractions: uniform compressive traction of magnitude $ p_0 = 1\\,\\text{MPa} $ applied on all four sides, i.e., $ \\mathbf{t} = -p_0 \\mathbf{n} $ where $ \\mathbf{n} $ is the outward unit normal on each boundary segment.\n- Kinematics: plane strain.\n- Rigid body constraints: eliminate rigid body motions by fixing the displacement $ (u,v) = (0,0) $ at the bottom-left corner node $ (x,y) = (0,0) $ and additionally fixing the horizontal displacement $ u = 0 $ at the bottom-right corner node $ (x,y) = (1,0) $.\n\nFinite element discretization requirements:\n- Use a structured grid of $ N_x \\times N_y $ rectangular cells subdivided into two triangles per cell.\n- Implement two element types:\n  1. CST: three-node linear triangle with constant strain.\n  2. LST: six-node quadratic triangle with mid-side nodes on each edge. Use isoparametric mapping from the reference triangle with local coordinates $ (\\xi,\\eta) $ and the standard quadratic Lagrange shape functions.\n- Use exact or appropriate Gaussian quadrature: for CST, constant-strain integration is exact with a single evaluation; for LST, use a quadrature that integrates polynomials up to degree $ 2 $ on the reference triangle.\n- Apply boundary tractions as consistent nodal forces on boundary edges:\n  - For a two-node boundary edge with length $ \\ell $, distribute the traction as $ \\ell/2 $ to each node (vectorially).\n  - For a three-node boundary edge (quadratic) with length $ \\ell $, use weights $ [\\ell/6,\\; 2\\ell/3,\\; \\ell/6] $ at the start, midside, and end nodes, respectively.\n- Assemble the global stiffness matrix and solve the linear system for nodal displacements.\n\nPost-processing definition of the numerical bulk modulus:\n- Compute the area-averaged volumetric strain $ \\overline{\\varepsilon}_v $ as the area-weighted average of $ \\varepsilon_{xx} + \\varepsilon_{yy} $ over $ \\Omega $.\n- Compute the area-averaged hydrostatic mean stress $ \\overline{p} $ as the area-weighted average of $ p = -\\tfrac{1}{3}(\\sigma_{xx} + \\sigma_{yy} + \\sigma_{zz}) $ over $ \\Omega $. Under plane strain, $ \\sigma_{zz} $ must be evaluated consistently from the three-dimensional isotropic law using $ \\varepsilon_{zz} = 0 $ together with the computed in-plane strains.\n- Define the numerical hydrostatic bulk modulus as $ K_h = \\dfrac{\\overline{p}}{-\\overline{\\varepsilon}_v} $. Report $ K_h $ as a positive quantity.\n- Express $ K_h $ in megapascals (MPa), rounded to six decimal places.\n\nTest suite and required output:\n- Use the following four test cases, each specified as $ (\\text{element}, N_x, N_y, \\nu) $:\n  1. $ (\\text{CST},\\; 8,\\; 8,\\; 0.25) $\n  2. $ (\\text{LST},\\; 8,\\; 8,\\; 0.25) $\n  3. $ (\\text{CST},\\; 8,\\; 8,\\; 0.49) $\n  4. $ (\\text{LST},\\; 8,\\; 8,\\; 0.49) $\n- For all cases, take $ E = 100\\,\\text{MPa} $, $ p_0 = 1\\,\\text{MPa} $, $ L = 1\\,\\text{m} $, and $ t = 1\\,\\text{m} $.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the same order as above, for example $ [k_1,k_2,k_3,k_4] $. Each $ k_i $ must be a floating-point number in megapascals, rounded to six decimal places.\n\nScientific expectations:\n- For moderate $ \\nu $ (e.g., $ \\nu = 0.25 $), both CST and LST should approximate the continuum bulk modulus well if the mesh is sufficiently refined.\n- For nearly incompressible materials (e.g., $ \\nu = 0.49 $) under full integration, CST is expected to exhibit volumetric locking, leading to an overpredicted $ K_h $ relative to the continuum value, while LST should alleviate locking and be closer to the continuum value.\n\nFinal deliverable:\n- Write a complete, runnable program that implements the above, with no external input. The final printout must be exactly one line formatted as described, containing $ K_h $ in MPa for the four test cases in order.",
            "solution": "The user has provided a well-posed problem in computational solid mechanics, requiring the implementation of a two-dimensional finite element method (FEM) solver for linear elasticity under plane-strain conditions. The objective is to compute the hydrostatic bulk modulus, $K_h$, for a square domain subjected to uniform compression, using both Constant-Strain Triangle (CST) and six-node quadratic (LST) elements. The problem is scientifically sound, contains all necessary data, and is a standard validation exercise for demonstrating element performance, particularly the phenomenon of volumetric locking in nearly incompressible materials. I will proceed with a detailed solution.\n\nThe solution is developed from first principles, following these main steps:\n1.  **Discretization**: Generation of the finite element mesh, including nodal coordinates and element connectivity, for both CST and LST element types.\n2.  **Element Formulation**: Derivation and computation of the element stiffness matrix ($k_e$) for each element type.\n3.  **System Assembly**: Construction of the global stiffness matrix ($K$) and global force vector ($F$) from element-level contributions.\n4.  **Application of Boundary Conditions**: Incorporation of prescribed tractions as consistent nodal forces and enforcement of essential boundary conditions (fixed displacements).\n5.  **Solution**: Solving the linear system of equations $K\\mathbf{d} = F$ to find the nodal displacement vector $\\mathbf{d}$.\n6.  **Post-processing**: Computation of the numerical hydrostatic bulk modulus ($K_h$) from the displacement solution by averaging stresses and strains over the domain.\n\n**1. Discretization and Mesh Generation**\n\nThe domain is a unit square ($L=1\\,\\text{m}$). It is discretized into a structured grid of $N_x \\times N_y$ rectangular cells, with each cell subdivided into two triangular elements.\n-   **For CST elements**: The mesh consists of $(N_x+1) \\times (N_y+1)$ nodes. Each cell, defined by four corner nodes, is split into two 3-node triangles.\n-   **For LST elements**: Midside nodes are added. The mesh comprises $(2N_x+1) \\times (2N_y+1)$ nodes. Each cell is split into two 6-node quadratic triangles. The connectivity for each LST element is defined by its three corner nodes and three midside nodes. The node ordering is consistent with the standard Lagrange shape function definitions for a reference element. For a triangle with corner nodes $1, 2, 3$, the midside nodes are ordered as mid(1-2), mid(2-3), mid(3-1).\n\n**2. Isotropic Linear Elasticity and Element Formulation**\n\nThe constitutive behavior is governed by the plane-strain linear elasticity matrix, $D_{ps}$, which relates the in-plane stress vector $\\boldsymbol{\\sigma} = [\\sigma_{xx}, \\sigma_{yy}, \\tau_{xy}]^T$ to the engineering strain vector $\\boldsymbol{\\varepsilon} = [\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}]^T$:\n$$ \\boldsymbol{\\sigma} = \\mathbf{D}_{\\text{ps}} \\boldsymbol{\\varepsilon} \\quad \\text{where} \\quad \\mathbf{D}_{\\text{ps}} = \\frac{E}{(1+\\nu)(1-2\\nu)} \\begin{pmatrix} 1-\\nu & \\nu & 0 \\\\ \\nu & 1-\\nu & 0 \\\\ 0 & 0 & \\frac{1-2\\nu}{2} \\end{pmatrix} $$\nThe strain-displacement relationship is given by $\\boldsymbol{\\varepsilon} = \\mathbf{B} \\mathbf{d}_e$, where $\\mathbf{B}$ is the strain-displacement matrix and $\\mathbf{d}_e$ is the vector of nodal displacements for an element. The element stiffness matrix, $k_e$, of thickness $t$ is computed by integrating over the element's area $A_e$:\n$$ k_e = \\int_{A_e} \\mathbf{B}^T \\mathbf{D}_{\\text{ps}} \\mathbf{B} \\, dA \\cdot t $$\n\n**Constant-Strain Triangle (CST)**\nThe CST element has a linear displacement field. This results in a constant strain (and stress) throughout the element. The $\\mathbf{B}$ matrix is therefore constant:\n$$ \\mathbf{B}_{\\text{CST}} = \\frac{1}{2A_e} \\begin{pmatrix} y_{23} & 0 & y_{31} & 0 & y_{12} & 0 \\\\ 0 & x_{32} & 0 & x_{13} & 0 & x_{21} \\\\ x_{32} & y_{23} & x_{13} & y_{31} & x_{21} & y_{12} \\end{pmatrix} $$\nwhere $(x_i, y_i)$ are the coordinates of the element's nodes and $A_e$ is its area. The integration is trivial:\n$$ k_e^{\\text{CST}} = \\mathbf{B}_{\\text{CST}}^T \\mathbf{D}_{\\text{ps}} \\mathbf{B}_{\\text{CST}} A_e t $$\n\n**Quadratic-Strain Triangle (LST)**\nThe LST element uses quadratic shape functions $N_i(\\xi, \\eta)$ on a reference element with local coordinates $(\\xi, \\eta)$. An isoparametric mapping relates the global coordinates $(x,y)$ to the local coordinates: $x = \\sum N_i x_i$, $y = \\sum N_i y_i$. The derivatives of shape functions with respect to global coordinates are found using the Jacobian of this mapping, $J$:\n$$ \\begin{pmatrix} \\partial N_i / \\partial x \\\\ \\partial N_i / \\partial y \\end{pmatrix} = J^{-1} \\begin{pmatrix} \\partial N_i / \\partial \\xi \\\\ \\partial N_i / \\partial \\eta \\end{pmatrix} $$\nThe $\\mathbf{B}$ matrix is now a function of $(\\xi, \\eta)$. For each of the six nodes $i$, the corresponding block in the B matrix is $\\mathbf{B}_i = \\begin{pmatrix} \\partial N_i/\\partial x & 0 \\\\ 0 & \\partial N_i/\\partial y \\\\ \\partial N_i/\\partial y & \\partial N_i/\\partial x \\end{pmatrix}$. The element stiffness matrix requires numerical integration, typically using Gaussian quadrature. For the quadratic element geometry generated by the mesher, the Jacobian matrix is constant, and the integrand $\\mathbf{B}^T \\mathbf{D}_{\\text{ps}} \\mathbf{B}$ is a quadratic polynomial in $(\\xi, \\eta)$. Therefore, a 3-point quadrature rule is sufficient for exact integration.\n$$ k_e^{\\text{LST}} = t \\int_{A_{ref}} \\mathbf{B}(\\xi,\\eta)^T \\mathbf{D}_{\\text{ps}} \\mathbf{B}(\\xi,\\eta) \\det(J) \\, d\\xi d\\eta \\approx t \\sum_{q=1}^{3} w_q \\left[ \\mathbf{B}(\\xi_q, \\eta_q)^T \\mathbf{D}_{\\text{ps}} \\mathbf{B}(\\xi_q, \\eta_q) \\det(J) \\right] $$\nwhere $(\\xi_q, \\eta_q)$ and $w_q$ are the quadrature points and weights.\n\n**3. System Assembly and Solution**\n\nThe global stiffness matrix $K$ and force vector $F$ are initialized to zero. The code then iterates through each element, computes its $k_e$, and assembles it into the appropriate locations in $K$ based on the element's global node indices.\n\n**Boundary Conditions**\n-   **Natural (Traction) BCs**: The uniform compressive traction $\\mathbf{t}=-p_0\\mathbf{n}$ is converted to consistent nodal forces by integrating the shape functions over the boundary edges. For a linear edge of length $\\ell$, the force is distributed as $[\\ell/2, \\ell/2]$ to the nodes. For a quadratic edge, the distribution is $[\\ell/6, 2\\ell/3, \\ell/6]$. These nodal forces are added to the global force vector $F$.\n-   **Essential (Displacement) BCs**: To eliminate rigid body motion, displacements are fixed: $(u,v)=(0,0)$ at node $(0,0)$ and $u=0$ at node $(1,0)$. This is enforced by modifying the global system. The rows and columns of $K$ corresponding to the fixed degrees of freedom (DOFs) are zeroed out, a $1$ is placed on the diagonal ($K_{ii}=1$), and the corresponding entry in $F$ is set to the prescribed displacement value ($F_i=0$).\n\nThe resulting system $K\\mathbf{d}=F$ is then solved for the global displacement vector $\\mathbf{d}$ using a direct solver.\n\n**4. Post-processing and Bulk Modulus Calculation**\n\nThe numerical hydrostatic bulk modulus $K_h$ is defined as the ratio of the area-averaged hydrostatic mean stress $\\overline{p}$ to the negative of the area-averaged volumetric strain $-\\overline{\\varepsilon}_v$.\n$$ K_h = \\frac{\\overline{p}}{-\\overline{\\varepsilon}_v} $$\nThe area-averaged quantities are computed as:\n$$ \\overline{p} = \\frac{1}{A_{total}} \\sum_e \\int_{A_e} p(x,y) \\, dA \\quad \\text{and} \\quad \\overline{\\varepsilon}_v = \\frac{1}{A_{total}} \\sum_e \\int_{A_e} \\varepsilon_v(x,y) \\, dA $$\nFor each element, the local strains are found from nodal displacements ($\\boldsymbol{\\varepsilon} = \\mathbf{B}\\mathbf{d}_e$). The stresses are then computed from the constitutive law. The out-of-plane stress $\\sigma_{zz}$ is recovered using the plane-strain condition: $\\sigma_{zz} = \\nu(\\sigma_{xx} + \\sigma_{yy})$. The hydrostatic stress $p = -(\\sigma_{xx} + \\sigma_{yy} + \\sigma_{zz})/3$ and volumetric strain $\\varepsilon_v = \\varepsilon_{xx} + \\varepsilon_{yy}$ are calculated. The integrals are evaluated numerically over each element (exactly for CST, via 3-point quadrature for LST) and summed up. The final value $K_h$ is converted to megapascals (MPa).\n\nThe provided Python code implements this entire procedure. It is structured to handle the specified test cases, comparing the performance of CST and LST elements for both moderate and near-incompressible Poisson's ratio values. As expected from theory, the results will demonstrate the superior performance of the LST element in avoiding volumetric locking for $\\nu \\approx 0.5$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the FEM simulations for the specified test cases\n    and print the results in the required format.\n    \"\"\"\n    \n    class LagrangeTriangle:\n        \"\"\"Shape functions and derivatives for a 6-node quadratic triangle.\"\"\"\n        QUAD_POINTS = np.array([[1/6, 1/6], [2/3, 1/6], [1/6, 2/3]])\n        QUAD_WEIGHTS = np.array([1/6, 1/6, 1/6])\n\n        @staticmethod\n        def shape_derivatives(xi, eta):\n            \"\"\"Derivatives of N w.r.t. xi and eta.\"\"\"\n            L1, L2, L3 = 1.0 - xi - eta, xi, eta\n            dN_dxi = np.array([\n                -4 * L1 + 1,\n                 4 * L2 - 1,\n                 0,\n                 4 * (L1 - L2),\n                 4 * L3,\n                -4 * L3\n            ])\n            dN_deta = np.array([\n                -4 * L1 + 1,\n                 0,\n                 4 * L3 - 1,\n                -4 * L2,\n                 4 * L2,\n                 4 * (L1 - L3)\n            ])\n            return np.vstack((dN_dxi, dN_deta)).T\n\n    def run_fem_simulation(elem_type, Nx, Ny, nu):\n        \"\"\"Core FEM solver for a given set of parameters.\"\"\"\n        E = 100e6  # Pa\n        p0 = 1e6   # Pa\n        L = 1.0    # m\n        t = 1.0    # m\n\n        # 1. Mesh Generation\n        if elem_type == 'CST':\n            num_nodes_x, num_nodes_y = Nx + 1, Ny + 1\n            node_pitch_x = L / Nx\n            node_pitch_y = L / Ny\n        else: # LST\n            num_nodes_x, num_nodes_y = 2 * Nx + 1, 2 * Ny + 1\n            node_pitch_x = L / (2 * Nx)\n            node_pitch_y = L / (2 * Ny)\n\n        num_nodes = num_nodes_x * num_nodes_y\n        nodes = np.array([[i * node_pitch_x, j * node_pitch_y]\n                          for j in range(num_nodes_y) for i in range(num_nodes_x)])\n\n        num_elements = 2 * Nx * Ny\n        if elem_type == 'CST':\n            elements = np.zeros((num_elements, 3), dtype=int)\n        else: # LST\n            elements = np.zeros((num_elements, 6), dtype=int)\n\n        elem_idx = 0\n        for j in range(Ny):\n            for i in range(Nx):\n                if elem_type == 'CST':\n                    n1 = j * num_nodes_x + i\n                    n2 = j * num_nodes_x + i + 1\n                    n3 = (j + 1) * num_nodes_x + i + 1\n                    n4 = (j + 1) * num_nodes_x + i\n                    elements[elem_idx] = [n1, n2, n3]\n                    elements[elem_idx + 1] = [n1, n3, n4]\n                else: # LST\n                    # Tri 1: BL, BR, TR\n                    bl, br, tr, tl = (2*j)*num_nodes_x + (2*i), (2*j)*num_nodes_x + (2*i+2), (2*j+2)*num_nodes_x + (2*i+2), (2*j+2)*num_nodes_x + (2*i)\n                    mid_b, mid_r, mid_t, mid_l = (2*j)*num_nodes_x + (2*i+1), (2*j+1)*num_nodes_x + (2*i+2), (2*j+2)*num_nodes_x + (2*i+1), (2*j+1)*num_nodes_x + (2*i)\n                    mid_diag = (2*j+1)*num_nodes_x + (2*i+1)\n                    elements[elem_idx] = [bl, br, tr, mid_b, mid_r, mid_diag]\n                    elements[elem_idx + 1] = [bl, tr, tl, mid_diag, mid_t, mid_l]\n                elem_idx += 2\n\n        # 2. Assembly\n        num_dofs = 2 * num_nodes\n        K = np.zeros((num_dofs, num_dofs))\n        D_ps = (E / ((1 + nu) * (1 - 2 * nu))) * np.array([[1 - nu, nu, 0], [nu, 1 - nu, 0], [0, 0, (1 - 2 * nu) / 2]])\n\n        for el_nodes_idx in elements:\n            el_nodes_coords = nodes[el_nodes_idx]\n            dofs = np.array([[2 * n, 2 * n + 1] for n in el_nodes_idx]).ravel()\n            \n            if elem_type == 'CST':\n                c = el_nodes_coords\n                area = 0.5 * np.linalg.det(np.array([[1, c[0,0], c[0,1]], [1, c[1,0], c[1,1]], [1, c[2,0], c[2,1]]]))\n                y23, y31, y12 = c[1,1]-c[2,1], c[2,1]-c[0,1], c[0,1]-c[1,1]\n                x32, x13, x21 = c[2,0]-c[1,0], c[0,0]-c[2,0], c[1,0]-c[0,0]\n                B = (1/(2*area)) * np.array([[y23,0,y31,0,y12,0], [0,x32,0,x13,0,x21], [x32,y23,x13,y31,x21,y12]])\n                Ke = B.T @ D_ps @ B * area * t\n            else: # LST\n                Ke = np.zeros((12, 12))\n                for i in range(len(LagrangeTriangle.QUAD_POINTS)):\n                    xi, eta = LagrangeTriangle.QUAD_POINTS[i]\n                    dN_dxi_eta = LagrangeTriangle.shape_derivatives(xi, eta)\n                    J = dN_dxi_eta.T @ el_nodes_coords\n                    detJ = np.linalg.det(J)\n                    invJ = np.linalg.inv(J)\n                    dN_dxy = invJ @ dN_dxi_eta.T\n                    \n                    B = np.zeros((3, 12))\n                    for node_i in range(6):\n                        B[0, 2*node_i], B[1, 2*node_i+1] = dN_dxy[0, node_i], dN_dxy[1, node_i]\n                        B[2, 2*node_i], B[2, 2*node_i+1] = dN_dxy[1, node_i], dN_dxy[0, node_i]\n                    Ke += B.T @ D_ps @ B * detJ * LagrangeTriangle.QUAD_WEIGHTS[i] * t\n            K[np.ix_(dofs, dofs)] += Ke\n            \n        # 3. Boundary forces\n        F = np.zeros(num_dofs)\n        hx, hy = L/Nx, L/Ny\n        \n        for i in range(Nx): # Bottom (y=0, t=(0,p0)), Top (y=L, t=(0,-p0))\n            if elem_type == 'CST':\n                nodes_b = [i, i+1];                  nodes_t = [Ny*num_nodes_x+i, Ny*num_nodes_x+i+1]\n                w = [hx/2, hx/2]\n            else:\n                nodes_b = [2*i, 2*i+2, 2*i+1];     nodes_t = [(2*Ny)*num_nodes_x+2*i, (2*Ny)*num_nodes_x+2*i+2, (2*Ny)*num_nodes_x+2*i+1]\n                w = [hx/6, hx/6, 2*hx/3]\n            for n_idx, weight in zip(nodes_b, w): F[2*n_idx+1] += p0 * weight * t\n            for n_idx, weight in zip(nodes_t, w): F[2*n_idx+1] -= p0 * weight * t\n        \n        for j in range(Ny): # Left (x=0, t=(p0,0)), Right (x=L, t=(-p0,0))\n            if elem_type == 'CST':\n                nodes_l = [j*num_nodes_x, (j+1)*num_nodes_x]; nodes_r = [j*num_nodes_x+Nx, (j+1)*num_nodes_x+Nx]\n                w = [hy/2, hy/2]\n            else:\n                nodes_l = [(2*j)*num_nodes_x, (2*j+2)*num_nodes_x, (2*j+1)*num_nodes_x]; nodes_r = [(2*j)*num_nodes_x+2*Nx, (2*j+2)*num_nodes_x+2*Nx, (2*j+1)*num_nodes_x+2*Nx]\n                w = [hy/6, hy/6, 2*hy/3]\n            for n_idx, weight in zip(nodes_l, w): F[2*n_idx] += p0 * weight * t\n            for n_idx, weight in zip(nodes_r, w): F[2*n_idx] -= p0 * weight * t\n\n        # 4. Displacement BCs\n        fixed_dofs = [0, 1] \n        fixed_dofs.append(2 * (Nx if elem_type == 'CST' else 2*Nx)) # u at (1,0)\n        for dof in fixed_dofs:\n            K[dof, :], K[:, dof], F[dof] = 0, 0, 0\n            K[dof, dof] = 1\n\n        # 5. Solve\n        displacements = np.linalg.solve(K, F)\n\n        # 6. Post-processing\n        total_p_integral, total_ev_integral = 0, 0\n        for el_nodes_idx in elements:\n            el_nodes_coords = nodes[el_nodes_idx]\n            dofs = np.array([[2 * n, 2 * n + 1] for n in el_nodes_idx]).ravel()\n            el_disps = displacements[dofs]\n\n            if elem_type == 'CST':\n                c = el_nodes_coords\n                area = 0.5 * abs(np.linalg.det(np.array([[1, c[0,0], c[0,1]], [1, c[1,0], c[1,1]], [1, c[2,0], c[2,1]]])))\n                y23, y31, y12 = c[1,1]-c[2,1], c[2,1]-c[0,1], c[0,1]-c[1,1]\n                x32, x13, x21 = c[2,0]-c[1,0], c[0,0]-c[2,0], c[1,0]-c[0,0]\n                B = (1/(2*area)) * np.array([[y23,0,y31,0,y12,0], [0,x32,0,x13,0,x21], [x32,y23,x13,y31,x21,y12]])\n                strain = B @ el_disps\n                eps_xx, eps_yy = strain[0], strain[1]\n                stress_xy = D_ps @ strain\n                sig_xx, sig_yy = stress_xy[0], stress_xy[1]\n                sig_zz = nu * (sig_xx + sig_yy)\n                p = -1/3 * (sig_xx + sig_yy + sig_zz)\n                ev = eps_xx + eps_yy\n                total_p_integral += p * area\n                total_ev_integral += ev * area\n            else: # LST\n                for i in range(len(LagrangeTriangle.QUAD_POINTS)):\n                    xi, eta = LagrangeTriangle.QUAD_POINTS[i]\n                    dN_dxi_eta = LagrangeTriangle.shape_derivatives(xi, eta)\n                    J = dN_dxi_eta.T @ el_nodes_coords\n                    detJ = np.linalg.det(J)\n                    invJ = np.linalg.inv(J)\n                    dN_dxy = invJ @ dN_dxi_eta.T\n                    \n                    B = np.zeros((3, 12))\n                    for node_i in range(6):\n                        B[0, 2*node_i], B[1, 2*node_i+1] = dN_dxy[0, node_i], dN_dxy[1, node_i]\n                        B[2, 2*node_i], B[2, 2*node_i+1] = dN_dxy[1, node_i], dN_dxy[0, node_i]\n\n                    strain = B @ el_disps\n                    eps_xx, eps_yy = strain[0], strain[1]\n                    stress_xy = D_ps @ strain\n                    sig_xx, sig_yy = stress_xy[0], stress_xy[1]\n                    sig_zz = nu * (sig_xx + sig_yy)\n                    p, ev = -1/3 * (sig_xx + sig_yy + sig_zz), eps_xx + eps_yy\n                    integral_weight = detJ * LagrangeTriangle.QUAD_WEIGHTS[i]\n                    total_p_integral += p * integral_weight\n                    total_ev_integral += ev * integral_weight\n\n        avg_p, avg_ev = total_p_integral / (L*L), total_ev_integral / (L*L)\n        \n        K_h = avg_p / (-avg_ev) if avg_ev < 0 else np.nan\n        return K_h / 1e6 # Return in MPa\n\n    test_cases = [\n        ('CST', 8, 8, 0.25),\n        ('LST', 8, 8, 0.25),\n        ('CST', 8, 8, 0.49),\n        ('LST', 8, 8, 0.49),\n    ]\n\n    results = []\n    for case in test_cases:\n        elem_type, Nx, Ny, nu = case\n        result = run_fem_simulation(elem_type, Nx, Ny, nu)\n        results.append(result)\n    \n    results_str = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Having observed volumetric locking, a common temptation is to use \"under-integration\"—a numerical shortcut that can sometimes alleviate the issue. Before attempting this in code, it is crucial to understand the theoretical consequences through a critical thought experiment. This exercise  challenges you to analyze the rank of the element stiffness matrix and discover the hidden danger of spurious zero-energy modes, which can destroy the stability of a simulation and render results meaningless.",
            "id": "3569129",
            "problem": "Consider a single two-dimensional, homogeneous, isotropic triangular finite element of the Linear Strain Triangle (LST) type with $n=6$ nodes and $2$ displacement degrees of freedom per node, used for small-strain plane stress in computational geomechanics. The element displacement field is interpolated by quadratic polynomials in the area (barycentric) coordinates, and the corresponding strain field is the symmetric gradient of the displacement. The material is characterized by Young’s modulus $E$ and Poisson’s ratio $\\nu$, assembled in the $3\\times 3$ elasticity matrix $\\mathbf{D}$ for plane stress. The consistent element stiffness matrix is defined by the domain integral\n$$\n\\mathbf{K}_e=\\int_{\\Omega_e} \\mathbf{B}(\\mathbf{x})^{\\mathsf{T}}\\mathbf{D}\\,\\mathbf{B}(\\mathbf{x})\\,\\mathrm{d}\\Omega,\n$$\nwhere $\\mathbf{B}(\\mathbf{x})$ is the strain–displacement matrix obtained from the derivatives of the quadratic shape functions.\n\nYou are to reason from first principles about (i) the polynomial degree of the integrand in $\\mathbf{K}_e$, (ii) the exactness requirements of triangular numerical quadrature to evaluate $\\mathbf{K}_e$ without integration error, and (iii) the rank properties of under-integrated stiffness matrices. In particular, consider a generic $m$-point triangular quadrature with positive weights $w_j>0$ and distinct interior points $\\mathbf{x}_j\\in\\Omega_e$, producing the approximation\n$$\n\\widetilde{\\mathbf{K}}_e=\\sum_{j=1}^{m} w_j\\,\\mathbf{B}(\\mathbf{x}_j)^{\\mathsf{T}}\\mathbf{D}\\,\\mathbf{B}(\\mathbf{x}_j).\n$$\nAssume $\\mathbf{D}$ is positive definite and the triangle is non-degenerate. The physically correct nullspace of $\\mathbf{K}_e$ contains exactly the $k=3$ rigid-body modes (two translations and one in-plane rotation), so the exact $\\mathbf{K}_e$ is positive semidefinite of rank $r_\\text{phys}=2n-k=12-3=9$.\n\nWhich of the following statements are true?\n\nA. For the LST element, the polynomial degree of the integrand $\\mathbf{B}^{\\mathsf{T}}\\mathbf{D}\\mathbf{B}$ is quadratic in the spatial coordinates, so any triangular quadrature that is exact for polynomials up to degree $2$ yields an exact $\\mathbf{K}_e$ with rank $9$ (i.e., only the $3$ rigid-body modes are in the nullspace).\n\nB. For under-integration with $m<3$ points (e.g., $m=1$ centroid rule), $\\widetilde{\\mathbf{K}}_e$ necessarily has rank strictly less than $9$ and exhibits spurious zero-energy deformation modes in addition to the $3$ rigid-body modes; the consequence is not merely a small integration error but an intrinsic rank deficiency.\n\nC. If $m=3$ interior points are used with positive weights but the quadrature is not polynomially exact (the weights are perturbed away from exact values), then generically $\\widetilde{\\mathbf{K}}_e$ retains rank $9$ (no spurious modes) while the stiffness coefficients incur integration error; this is a benign accuracy error rather than a failure of kinematic constraint representation.\n\nD. Because both the Constant Strain Triangle (CST) and the LST produce constant strains over the element, one-point integration is exact for both; therefore, using the centroid rule for LST does not change rank or accuracy in any essential way.\n\nE. In near-incompressible geomechanics, deliberately using one-point under-integration for LST alleviates volumetric locking without risking spurious zero-energy modes, so it is a safe and generally recommended practice for stability.\n\nSelect all that apply.",
            "solution": "The user wants me to validate and solve a problem concerning the properties of the stiffness matrix for a 6-node Linear Strain Triangle (LST) finite element.\n\n### **Problem Validation**\n\n**Step 1: Extract Givens**\n-   **Element Type**: A single two-dimensional, homogeneous, isotropic triangular finite element of the Linear Strain Triangle (LST) type.\n-   **Nodes**: $n=6$ nodes.\n-   **Degrees of Freedom (DOFs)**: $2$ displacement DOFs per node, for a total of $2n=12$ DOFs.\n-   **Analysis Type**: Small-strain plane stress.\n-   **Displacement Field**: Interpolated by quadratic polynomials, $u(\\mathbf{x}) = \\sum_{i=1}^6 N_i(\\mathbf{x}) u_i$, $v(\\mathbf{x}) = \\sum_{i=1}^6 N_i(\\mathbf{x}) v_i$, where $N_i$ are quadratic shape functions.\n-   **Strain Field**: The symmetric gradient of the displacement field, $\\boldsymbol{\\epsilon} = \\mathbf{L}\\mathbf{u}$, where $\\mathbf{L}$ is the differential operator. This results in a strain field that is linear in the spatial coordinates.\n-   **Material Properties**: Characterized by Young's modulus $E$ and Poisson's ratio $\\nu$. The $3 \\times 3$ elasticity matrix $\\mathbf{D}$ for plane stress is constant and positive definite.\n-   **Strain-Displacement Matrix**: $\\mathbf{B}(\\mathbf{x})$ is derived from a single differentiation of the quadratic shape functions, so its entries are linear functions of the spatial coordinates $\\mathbf{x}$.\n-   **Exact Stiffness Matrix**: $\\mathbf{K}_e = \\int_{\\Omega_e} \\mathbf{B}(\\mathbf{x})^{\\mathsf{T}}\\mathbf{D}\\,\\mathbf{B}(\\mathbf{x})\\,\\mathrm{d}\\Omega$.\n-   **Numerically Integrated Stiffness Matrix**: $\\widetilde{\\mathbf{K}}_e = \\sum_{j=1}^{m} w_j\\,\\mathbf{B}(\\mathbf{x}_j)^{\\mathsf{T}}\\mathbf{D}\\,\\mathbf{B}(\\mathbf{x}_j)$, with $m$ points, positive weights $w_j>0$, and distinct interior points $\\mathbf{x}_j$.\n-   **Assumptions**: The triangle is non-degenerate.\n-   **Physical Properties of $\\mathbf{K}_e$**: The nullspace of the exact $\\mathbf{K}_e$ has dimension $k=3$, corresponding to rigid-body modes. The rank 얼굴 $r_\\text{phys} = 2n-k = 12-3=9$.\n\n**Step 2: Validate Using Extracted Givens**\n-   **Scientific Grounding**: The problem is based on the standard and widely accepted theory of the Finite Element Method (FEM) for linear elasticity. All concepts, including LST elements, quadratic shape functions, linear strain, stiffness matrix integration, numerical quadrature, rank deficiency, and spurious modes, are foundational to computational mechanics. The described properties are factually correct.\n-   **Well-Posedness**: The problem is well-posed. It provides a clear and complete setup and asks for an assessment of several statements based on this setup. The information is sufficient to derive a definitive conclusion for each statement.\n-   **Objectivity**: The language is precise, technical, and devoid of ambiguity or subjectivity. All terms are standard within the field.\n\n**Step 3: Verdict and Action**\nThe problem statement is **valid**. It is a well-formulated question in computational mechanics. I will now proceed with a detailed derivation and evaluation of each option.\n\n### **Derivation and Option Analysis**\n\nThe problem concerns the $12 \\times 12$ stiffness matrix $\\mathbf{K}_e$ for a 6-node LST element. The nodal displacement vector is $\\mathbf{d} \\in \\mathbb{R}^{12}$. The strain field is given by $\\boldsymbol{\\epsilon}(\\mathbf{x}) = \\mathbf{B}(\\mathbf{x})\\mathbf{d}$. Since the displacement field is quadratic, its derivatives are linear. Thus, the entries of the $3 \\times 12$ strain-displacement matrix $\\mathbf{B}(\\mathbf{x})$ are linear functions of the spatial coordinates $(x, y)$.\n\nThe integrand for the stiffness matrix is $\\mathbf{B}(\\mathbf{x})^{\\mathsf{T}}\\mathbf{D}\\,\\mathbf{B}(\\mathbf{x})$. Since $\\mathbf{B}(\\mathbf{x})$ has entries that are polynomials of degree $1$ and $\\mathbf{D}$ is a constant matrix, the entries of the integrand are products of linear polynomials, resulting in polynomials of degree $2$.\n\nThe rank of the stiffness matrix is crucial. The nullspace of $\\mathbf{K}_e$ or $\\widetilde{\\mathbf{K}}_e$ consists of nodal displacement vectors $\\mathbf{d}$ that result in zero strain energy.\nFor the exact matrix, $U_e = \\frac{1}{2}\\mathbf{d}^{\\mathsf{T}}\\mathbf{K}_e\\mathbf{d} = \\frac{1}{2}\\int_{\\Omega_e} (\\mathbf{B}\\mathbf{d})^{\\mathsf{T}}\\mathbf{D}(\\mathbf{B}\\mathbf{d})\\,\\mathrm{d}\\Omega = 0$. Since $\\mathbf{D}$ is positive definite, this requires $\\mathbf{B}(\\mathbf{x})\\mathbf{d} = \\mathbf{0}$ for all $\\mathbf{x} \\in \\Omega_e$. The only nodal displacement vectors $\\mathbf{d}$ that produce zero strain everywhere are the three rigid-body modes. Thus, the nullspace has dimension $3$, and the rank is $12-3=9$.\n\nFor the numerically integrated matrix, $U_e \\approx \\frac{1}{2}\\mathbf{d}^{\\mathsf{T}}\\widetilde{\\mathbf{K}}_e\\mathbf{d} = \\frac{1}{2}\\sum_{j=1}^{m} w_j (\\mathbf{B}(\\mathbf{x}_j)\\mathbf{d})^{\\mathsf{T}}\\mathbf{D}(\\mathbf{B}(\\mathbf{x}_j)\\mathbf{d}) = 0$. With $w_j>0$ and positive definite $\\mathbf{D}$, this requires $\\mathbf{B}(\\mathbf{x}_j)\\mathbf{d} = \\mathbf{0}$ for all integration points $j=1, \\dots, m$.\n\nLet's evaluate each statement.\n\n**A. For the LST element, the polynomial degree of the integrand $\\mathbf{B}^{\\mathsf{T}}\\mathbf{D}\\mathbf{B}$ is quadratic in the spatial coordinates, so any triangular quadrature that is exact for polynomials up to degree $2$ yields an exact $\\mathbf{K}_e$ with rank $9$ (i.e., only the $3$ rigid-body modes are in the nullspace).**\n\nAs established, the entries of $\\mathbf{B}(\\mathbf{x})$ are linear in coordinates. The integrand $\\mathbf{B}(\\mathbf{x})^{\\mathsf{T}}\\mathbf{D}\\,\\mathbf{B}(\\mathbf{x})$ is a $12 \\times 12$ matrix whose entries are quadratic polynomials. To compute the integral of a quadratic polynomial场 over a triangle exactly, a numerical quadrature scheme must be exact for polynomials of at least degree $2$. Standard triangular quadrature rules, such as the 3-point rule at the midpoints of the sides, satisfy this condition. If the integration is performed exactly, the resulting stiffness matrix $\\mathbf{K}_e$ will possess the correct physical properties, including a nullspace मौसम by a basis of the $3$ rigid-body modes. Consequently, its rank will be $12 - 3 = 9$. The statement is fully consistent with the theory of FEM.\n\nVerdict: **Correct**.\n\n**B. For under-integration with $m<3$ points (e.g., $m=1$ centroid rule), $\\widetilde{\\mathbf{K}}_e$ necessarily has rank strictly less than $9$ and exhibits spurious zero-energy deformation modes in addition to the $3$ rigid-body modes; the consequence is not merely a small integration error but an intrinsic rank deficiency.**\n\nUnder-integration means using a quadrature rule декоративные is not exact for the integrand's polynomial degree. For a quadratic integrand, any rule with $m<3$ points is typically an under-integration.\nLet's analyze the nullspace of $\\widetilde{\\mathbf{K}}_e$. A vector $\\mathbf{d}$ is in the nullspace if $\\mathbf{B}(\\mathbf{x}_j)\\mathbf{d} = \\mathbf{0}$ for all $j=1, \\dots, m$.\nEach condition $\\mathbf{B}(\\mathbf{x}_j)\\mathbf{d} = \\mathbf{0}$ represents $3$ linear equations for the $12$ components of $\\mathbf{d}$ (since $\\mathbf{B}$ is $3 \\times 12$).\n- If $m=1$ (e.g., centroid rule), we have $3$ equations. The matrix $\\mathbf{B}(\\mathbf{x}_1)$ has rank $3$ (for a non-degenerate element). By the rank-nullity theorem, the dimension of the nullspace of $\\mathbf{B}(\\mathbf{x}_1)$ is $12 - \\text{rank}(\\mathbf{B}(\\mathbf{x}_1)) = 12 - 3 = 9$. The rank of $\\widetilde{\\mathbf{K}}_e$ is $12 - 9 = 3$. Since $3 < 9$, the matrix is rank-deficient. The nullspace has dimension $9$, which is $6$ more than the $3$ physical rigid-body modes. These $6$ additional modes are spurious, non-physical zero-energy modes.\n- If $m=2$, we have $6$ equations, given by the stacked matrix $\\begin{pmatrix} \\mathbf{B}(\\mathbf{x}_1) \\\\ \\mathbf{B}(\\mathbf{x}_2) \\end{pmatrix}\\mathbf{d} = \\mathbf{0}$. For distinct points in a non-degenerate triangle, this $6 \\times 12$ matrix will have rank $6$. The nullspace dimension is $12 - 6 = 6$. The rank of $\\widetilde{\\mathbf{K}}_e$ is $12-6=6$. This is also strictly less than $9$, and there are $6-3=3$ spurious modes.\nIn both cases ($m=1, 2$), the rank is strictly less than $9$, and spurious modes are introduced. This is a fundamental \"rank deficiency\", not just a minor inaccuracy.\n\nVerdict: **Correct**.\n\n**C. If $m=3$ interior points are used with positive weights but the quadrature is not polynomially exact (the weights are perturbed away from exact values), then generically $\\widetilde{\\mathbf{K}}_e$ retains rank $9$ (no spurious modes) while the stiffness coefficients incur integration error; this is a benign accuracy error rather than a failure of kinematic constraint representation.**\n\nThe nullspace of $\\widetilde{\\mathbf{K}}_e$ is determined by the set of integration *points* $\\mathbf{x}_j$, not the *weights* $w_j$ (as long as $w_j>0$). The condition for a vector $\\mathbf{d}$ to be in the nullspace is $\\mathbf{B}(\\mathbf{x}_j)\\mathbf{d} = \\mathbf{0}$ for $j=1, 2, 3$. This is a system of $3 \\times 3 = 9$ linear equations for $12$ unknowns. The system matrix is the $9 \\times 12$ matrix formed by stacking $\\mathbf{B}(\\mathbf{x}_1)$, $\\mathbf{B}(\\mathbfx_2)$, and $\\mathbf{B}(\\mathbf{x}_3)$. For a 3-point rule sufficient to integrate quadratics, the points are typically chosen at the midpoints of the sides or the midpoints of the medial triangle. For any set of $3$ non-collinear points, the $9$ rows of this matrix are linearly independent. Thus, the rank of the system matrix is $9$. The dimension of the nullspace is $12 - 9 = 3$. These three modes are the rigid-body modes, which produce zero strain at all points, including the integration points. Therefore, $\\widetilde{\\mathbf{K}}_e$ has a nullspace soluções $3$ and rank $9$. There are no spurious modes. However, if the weights $w_j$ are not the correct ones for a quadratically-exact rule, the integral will be approximated, and the entries of $\\widetilde{\\mathbfK}_e$ will contain some error compared to the exact $\\mathbf{K}_e$. This is an accuracy issue, not a stability (rank) issue.\n\nVerdict: **Correct**.\n\n**D. Because both the Constant Strain Triangle (CST) and the LST produce constant strains over the element, one-point integration is exact for both; therefore, using the centroid rule for LST does not change rank or accuracy in any essential way.**\n\nThis statement is built on a false premise. The Constant Strain Triangle (CST, 3-node, linear displacement) has a constant strain field. The Linear Strain Triangle (LST, 6-node, quadratic displacement) has a linear strain field, not constant. Because the LST's strain field is linear, the integrand for its stiffness matrix, $\\mathbf{B}^{\\mathsf{T}}\\mathbf{D}\\mathbf{B}$, is quadratic. One-point integration (e.g., at the centroid) is exact only for linear (or constant) integrands. It is not exact for a quadratic integrand. As shown in the analysis of statement B, using one-point integration for the LST element leads to a severe rank deficiency (rank drops from $9$ to $3$) and introduces $6$ spurious zero-energy modes. This is a catastrophic failure, changing the rank and stability in a very essential way.\n\nVerdict: **Incorrect**.\n\n**E. In near-incompressible geomechanics, deliberately using one-point under-integration for LST alleviates volumetric locking without risking spurious zero-energy modes, so it is a safe and generally recommended practice for stability.**\n\nWhile reduced integration is a technique used to alleviate volumetric locking in near-incompressible materials, this statement's claim about safety and stability is false. As demonstrated in the analysis of statement B, one-point integration of the LST element introduces $6$ spurious zero-energy modes. These modes, often called 'hourglass modes', can propagate through a mesh of elements, leading to a singular or poorly-conditioned global stiffness matrix and producing meaningless, oscillatory displacement fields. The presence of these spurious modes makes the element kinematically unstable. Therefore, while it might alleviate locking, it does so at the cost of stability, making it an unsafe and not-recommended practice for this element type. Specific hourglass control schemes would be required to stabilize the element, but the statement claims it can be done \"without risking\" these modes, which is false.\n\nVerdict: **Incorrect**.",
            "answer": "$$\\boxed{ABC}$$"
        },
        {
            "introduction": "Armed with a clear understanding of locking and the dangers of naive fixes, we now turn to a modern and robust solution. The Edge-based Smoothed Finite Element Method (ES-FEM) is a powerful technique that modifies the strain calculation to soften the element response without introducing spurious instabilities. In this final hands-on practice , you will implement ES-FEM and quantitatively demonstrate its superiority over the standard CST for nearly incompressible problems, observing significant improvements in both global stiffness and local stress accuracy.",
            "id": "3569108",
            "problem": "Implement a complete program that compares the Constant Strain Triangle (CST) finite element method to the Edge-based Smoothed Finite Element Method (ES-FEM) for nearly incompressible clays under plane strain. Your program must assemble the global stiffness matrix for both formulations on the same mesh, solve for displacements under prescribed displacement boundary conditions, and quantitatively compare an apparent horizontal stiffness and a stress accuracy metric between CST and ES-FEM.\n\nYou must derive your implementation from first principles appropriate to computational geomechanics with triangular elements as follows.\n\n- Use the Principle of Virtual Work, which for linear elasticity in the absence of body forces states that the internal virtual work equals the external virtual work for all kinematically admissible virtual displacements. In discretized form, this leads to a symmetric positive-definite global stiffness system.\n- Adopt the plane strain linear elastic constitutive law. For Young’s modulus $E$ and Poisson’s ratio $\\nu$, the stress-strain relation is linear, with the constitutive matrix depending on $E$ and $\\nu$.\n- For CST, use the constant strain approximation within each triangular element, with gradients of shape functions constant over each element. Assemble the global stiffness matrix by summing element contributions.\n- For ES-FEM (Edge-based Smoothed Finite Element Method), define an edge-based smoothing domain as the union of the two adjacent triangles sharing an interior edge (or the single triangle for a boundary edge). Over each smoothing domain $\\Omega_{S}$, define the smoothed strain by smoothing the gradients of the shape functions via the divergence theorem applied to the union-of-triangles domain:\n  - The smoothed gradient of a nodal shape function $N_{i}$ on $\\Omega_{S}$ is\n    $$\\nabla \\tilde{N}_{i} = \\frac{1}{A_{S}} \\int_{\\Omega_{S}} \\nabla N_{i} \\, \\mathrm{d}\\Omega,$$\n    which, for piecewise-constant $\\nabla N_{i}$ on each triangle, becomes the area-weighted average over the adjacent elements. Here $A_{S}$ denotes the area of $\\Omega_{S}$.\n  - Form the smoothed $B$-matrix on $\\Omega_{S}$ by arranging the components of $\\nabla \\tilde{N}_{i}$ into the standard plane strain form, and assemble a smoothing-domain stiffness contribution\n    $$\\mathbf{K}_{S} = \\int_{\\Omega_{S}} \\mathbf{B}_{S}^{\\top} \\mathbf{D} \\mathbf{B}_{S} \\, \\mathrm{d}\\Omega \\approx A_{S} \\, \\mathbf{B}_{S}^{\\top} \\mathbf{D} \\mathbf{B}_{S},$$\n    then sum over all edges to obtain the ES-FEM global stiffness matrix.\n\nGeometry, loading, and boundary conditions to enforce a well-posed and analytically benchmarkable problem:\n\n- Consider a rectangular domain of width $W$ and height $H$, under plane strain, with unit thickness. Discretize it into a structured grid of $N_{x} \\times N_{y}$ nodes, and split each rectangular cell into two triangles by a consistent diagonal. All coordinates are in the same consistent length unit.\n- Impose essential (Dirichlet) boundary conditions: on the left boundary $x=0$, enforce $u_{x} = 0$ and $u_{y} = 0$; on the right boundary $x = W$, enforce $u_{x} = u_{0}$ and $u_{y} = 0$. Do not apply any tractions or body forces. This produces a uniform exact solution with axial strain $\\varepsilon_{x} = u_{0}/W$, $\\varepsilon_{y} = 0$, and $\\gamma_{xy} = 0$.\n- Use the plane strain constitutive matrix with modulus $E$ and Poisson’s ratio $\\nu$. The exact uniform stress corresponding to the exact uniform strain is $\\boldsymbol{\\sigma}_{\\mathrm{exact}} = \\mathbf{D} \\, [u_{0}/W, 0, 0]^{\\top}$, with exact axial stress $\\sigma_{x,\\mathrm{exact}} = D_{11} \\, (u_{0}/W)$, where $D_{11}$ is the first diagonal entry of the plane strain constitutive matrix $\\mathbf{D}$.\n- Define the apparent horizontal stiffness $K_{h}$ as the ratio of the total horizontal reaction force on the right boundary to the imposed displacement $u_{0}$. The exact value for this setup is\n  $$K_{h,\\mathrm{exact}} = D_{11} \\, \\frac{H}{W}.$$\n\nNumerical tasks to implement:\n\n1. Mesh generation:\n   - Generate nodal coordinates and triangular connectivity for the rectangle $[0,W] \\times [0,H]$ with $N_{x} \\times N_{y}$ nodes, splitting each cell into two triangles with consistent orientation.\n2. CST assembly:\n   - For each triangle, compute area $A_{e}$ and the constant-strain matrix $\\mathbf{B}_{e}$ from shape function gradients, assemble $\\mathbf{K}^{\\mathrm{CST}}$.\n3. ES-FEM assembly:\n   - Enumerate all edges and find their adjacent triangles. For each edge-based domain $\\Omega_{S}$, compute the smoothed gradients $\\nabla \\tilde{N}_{i}$ as the area-weighted average of element gradients over adjacent triangles. Construct $\\mathbf{B}_{S}$, assemble $\\mathbf{K}^{\\mathrm{ES}} = \\sum_{S} A_{S} \\, \\mathbf{B}_{S}^{\\top} \\mathbf{D} \\mathbf{B}_{S}$.\n4. Apply boundary conditions and solve:\n   - Construct the right-hand side vector as zero. Impose essential boundary conditions and solve the linear system for displacements for both $\\mathbf{K}^{\\mathrm{CST}}$ and $\\mathbf{K}^{\\mathrm{ES}}$.\n   - Recover reactions as $\\mathbf{r} = \\mathbf{K} \\mathbf{u}$; sum horizontal reactions at right boundary nodes to obtain $R_{x}$ for each method.\n   - Compute $K_{h} = R_{x}/u_{0}$ for each method.\n5. Stress computation and error metric:\n   - For each triangular element, compute the constant strain $\\boldsymbol{\\varepsilon}_{e}$ and stress $\\boldsymbol{\\sigma}_{e}$ using the method’s displacement field and the element’s CST $\\mathbf{B}_{e}$. Use the axial stress component $\\sigma_{x,e}$.\n   - Compute the $L^{2}$-type relative error over the domain using\n     $$e_{\\sigma} = \\frac{\\left(\\sum_{e} A_{e}\\,(\\sigma_{x,e} - \\sigma_{x,\\mathrm{exact}})^{2}\\right)^{1/2}}{\\left(|\\sigma_{x,\\mathrm{exact}}| \\, \\sqrt{\\sum_{e} A_{e}}\\right)}.$$\n\nTest suite and outputs:\n\n- Use the following test cases with the given parameters:\n  - Case 1 (happy path): $W=1.0$, $H=1.0$, $N_{x}=4$, $N_{y}=4$, $E=1000.0$, $\\nu=0.3$, $u_{0}=0.001$.\n  - Case 2 (nearly incompressible, coarse): $W=1.0$, $H=1.0$, $N_{x}=4$, $N_{y}=4$, $E=1000.0$, $\\nu=0.4999$, $u_{0}=0.001$.\n  - Case 3 (nearly incompressible, refined): $W=1.0$, $H=1.0$, $N_{x}=10$, $N_{y}=10$, $E=1000.0$, $\\nu=0.4999$, $u_{0}=0.001$.\n- For each case, compute:\n  - The relative error in apparent horizontal stiffness for CST and ES-FEM:\n    $$\\mathrm{err}_{K}^{\\mathrm{CST}} = \\left|\\frac{K_{h}^{\\mathrm{CST}} - K_{h,\\mathrm{exact}}}{K_{h,\\mathrm{exact}}}\\right|, \\quad \\mathrm{err}_{K}^{\\mathrm{ES}} = \\left|\\frac{K_{h}^{\\mathrm{ES}} - K_{h,\\mathrm{exact}}}{K_{h,\\mathrm{exact}}}\\right|.$$\n  - The relative $L^{2}$ errors in axial stress $\\sigma_{x}$ for CST and ES-FEM, denoted $\\mathrm{err}_{\\sigma}^{\\mathrm{CST}}$ and $\\mathrm{err}_{\\sigma}^{\\mathrm{ES}}$, computed as $e_{\\sigma}$ above using each method’s displacement field.\n- Final output format:\n  - Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each case, output four floating-point numbers in the order\n    $[\\mathrm{err}_{K}^{\\mathrm{CST}}, \\mathrm{err}_{K}^{\\mathrm{ES}}, \\mathrm{err}_{\\sigma}^{\\mathrm{CST}}, \\mathrm{err}_{\\sigma}^{\\mathrm{ES}}]$,\n    and concatenate across the three cases into one flat list of twelve numbers. For example, a syntactically valid output would be like\n    $$[\\alpha_{1},\\beta_{1},\\gamma_{1},\\delta_{1},\\alpha_{2},\\beta_{2},\\gamma_{2},\\delta_{2},\\alpha_{3},\\beta_{3},\\gamma_{3},\\delta_{3}],$$\n    where each symbol denotes a floating-point value. No units are required in the output since all reported quantities are dimensionless relative errors.",
            "solution": "The problem requires the implementation and comparison of the Constant Strain Triangle (CST) and the Edge-based Smoothed Finite Element Method (ES-FEM) for a plane strain linear elastic problem, particularly focusing on nearly incompressible materials. The validation confirms the problem is well-posed, scientifically grounded, and computationally tractable. We proceed with a solution derived from first principles.\n\nThe governing equation for static linear elasticity, derived from the Principle of Virtual Work, is the system of linear equations $\\mathbf{K}\\mathbf{u} = \\mathbf{f}$, where $\\mathbf{K}$ is the global stiffness matrix, $\\mathbf{u}$ is the vector of nodal displacements, and $\\mathbf{f}$ is the vector of nodal forces. In this problem, external body forces and surface tractions are absent, so the initial force vector $\\mathbf{f}$ is zero; non-zero forces will arise on the right-hand side of the final system of equations due to the prescribed displacement boundary conditions.\n\nThe material behavior is governed by the linear elastic constitutive law for plane strain, $\\boldsymbol{\\sigma} = \\mathbf{D}\\boldsymbol{\\varepsilon}$, where $\\boldsymbol{\\sigma} = [\\sigma_{xx}, \\sigma_{yy}, \\tau_{xy}]^\\top$ is the stress vector and $\\boldsymbol{\\varepsilon} = [\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}]^\\top$ is the engineering strain vector. The constitutive matrix $\\mathbf{D}$ is given by:\n$$\n\\mathbf{D} = \\frac{E}{(1+\\nu)(1-2\\nu)}\n\\begin{pmatrix}\n1-\\nu & \\nu & 0 \\\\\n\\nu & 1-\\nu & 0 \\\\\n0 & 0 & \\frac{1-2\\nu}{2}\n\\end{pmatrix}\n$$\nwhere $E$ is Young's modulus and $\\nu$ is Poisson's ratio.\n\nThe displacement field $\\mathbf{u}(x,y)$ within an element is interpolated from the nodal displacements $\\mathbf{u}_e$ using shape functions $\\mathbf{N}$: $\\mathbf{u}(x,y) = \\mathbf{N}(x,y) \\mathbf{u}_e$. The strain is derived from displacements via the differential operator $\\boldsymbol{\\partial}$, such that $\\boldsymbol{\\varepsilon} = \\boldsymbol{\\partial} \\mathbf{u} = (\\boldsymbol{\\partial} \\mathbf{N}) \\mathbf{u}_e = \\mathbf{B} \\mathbf{u}_e$. The matrix $\\mathbf{B}$ is the strain-displacement matrix.\n\n**Mesh Generation**\nA structured mesh is generated for a rectangular domain $[0, W] \\times [0, H]$ with $N_x \\times N_y$ nodes. The nodes are indexed row-wise. Each rectangular cell formed by four adjacent nodes is divided into two triangular elements using a consistent diagonal, ensuring a well-structured and repeatable discretization.\n\n**Constant Strain Triangle (CST) Formulation**\nFor a three-node triangular element, the shape functions $N_i$ are linear in spatial coordinates. Consequently, their gradients are constant within the element. The strain-displacement matrix $\\mathbf{B}_e$ for an element $e$ is constant and is derived from the gradients of the shape functions. For an element with nodes $(x_1, y_1), (x_2, y_2), (x_3, y_3)$ ordered counter-clockwise and area $A_e$, $\\mathbf{B}_e$ is:\n$$\n\\mathbf{B}_e = \\frac{1}{2A_e}\n\\begin{pmatrix}\ny_2-y_3 & 0 & y_3-y_1 & 0 & y_1-y_2 & 0 \\\\\n0 & x_3-x_2 & 0 & x_1-x_3 & 0 & x_2-x_1 \\\\\nx_3-x_2 & y_2-y_3 & x_1-x_3 & y_3-y_1 & x_2-x_1 & y_1-y_2\n\\end{pmatrix}\n$$\nThe element stiffness matrix $\\mathbf{K}_e$ is computed by integrating over the element volume (area in 2D with unit thickness):\n$$\n\\mathbf{K}_e = \\int_{\\Omega_e} \\mathbf{B}_e^\\top \\mathbf{D} \\mathbf{B}_e \\, \\mathrm{d}\\Omega = A_e \\mathbf{B}_e^\\top \\mathbf{D} \\mathbf{B}_e\n$$\nThe global stiffness matrix $\\mathbf{K}^{\\mathrm{CST}}$ is assembled by summing the contributions from all elements, mapping local degrees of freedom (DOFs) to their corresponding global DOFs.\n\n**Edge-based Smoothed Finite Element Method (ES-FEM) Formulation**\nES-FEM aims to soften the overly stiff behavior of CST elements, especially in nearly incompressible scenarios ($\\nu \\to 0.5$). This is achieved by creating smoothing domains $\\Omega_S$ associated with each edge of the mesh. An interior edge is shared by two triangles, so its smoothing domain is the union of these two triangles. A boundary edge belongs to only one triangle, which then constitutes its smoothing domain.\n\nWithin each smoothing domain $\\Omega_S$ with area $A_S$, a smoothed gradient of a shape function $N_i$ is defined as the area-weighted average of its standard (piecewise-constant) gradient over the constituent triangles:\n$$\n\\nabla \\tilde{N}_{i} = \\frac{1}{A_{S}} \\int_{\\Omega_{S}} \\nabla N_{i} \\, \\mathrm{d}\\Omega = \\frac{1}{A_S} \\sum_{e \\in \\Omega_S} A_e (\\nabla N_{i})|_{\\Omega_e}\n$$\nThese smoothed gradients are used to form a smoothed strain-displacement matrix $\\mathbf{B}_S$ for the set of nodes belonging to the smoothing domain. The stiffness contribution from this smoothing domain, $\\mathbf{K}_S$, is then computed as:\n$$\n\\mathbf{K}_S = \\int_{\\Omega_S} \\mathbf{B}_S^\\top \\mathbf{D} \\mathbf{B}_S \\, \\mathrm{d}\\Omega \\approx A_S \\mathbf{B}_S^\\top \\mathbf{D} \\mathbf{B}_S\n$$\nThe global stiffness matrix $\\mathbf{K}^{\\mathrm{ES}}$ is assembled by summing the stiffness contributions $\\mathbf{K}_S$ from all smoothing domains (i.e., all edges) in the mesh.\n\n**Boundary Conditions and Solution**\nThe problem involves prescribed displacements on the left ($x=0$) and right ($x=W$) boundaries. This is handled by partitioning the global system of equations $\\mathbf{K}\\mathbf{u}=\\mathbf{f}$ into free and constrained DOFs:\n$$\n\\begin{pmatrix} \\mathbf{K}_{ff} & \\mathbf{K}_{fc} \\\\ \\mathbf{K}_{cf} & \\mathbf{K}_{cc} \\end{pmatrix} \\begin{pmatrix} \\mathbf{u}_f \\\\ \\mathbf{u}_c \\end{pmatrix} = \\begin{pmatrix} \\mathbf{f}_f \\\\ \\mathbf{f}_c \\end{pmatrix}\n$$\nWith no external forces, $\\mathbf{f}_f = \\mathbf{0}$. The unknown displacements $\\mathbf{u}_f$ are found by solving the reduced system:\n$$\n\\mathbf{K}_{ff} \\mathbf{u}_f = -\\mathbf{K}_{fc} \\mathbf{u}_c\n$$\nwhere $\\mathbf{u}_c$ is the vector of known prescribed displacements. After solving for $\\mathbf{u}_f$, the full displacement vector $\\mathbf{u}$ is constructed. The reaction forces are then calculated as $\\mathbf{r} = \\mathbf{K}\\mathbf{u}$.\n\n**Analysis of Results**\nThe performance of each method is evaluated using two metrics:\n\n1.  **Apparent Horizontal Stiffness ($K_h$)**: This global metric is the total horizontal reaction force on the right boundary divided by the imposed displacement $u_0$. The relative error is $|(K_h - K_{h,\\mathrm{exact}})/K_{h,\\mathrm{exact}}|$, where $K_{h,\\mathrm{exact}} = D_{11} H/W$.\n\n2.  **Stress Accuracy ($e_\\sigma$)**: This local metric measures the deviation of the computed axial stress $\\sigma_{x,e}$ from the exact uniform stress $\\sigma_{x,\\mathrm{exact}} = D_{11} u_0/W$. The stress $\\sigma_{x,e}$ is computed for each element using its standard CST $\\mathbf{B}_e$ matrix and the nodal displacements obtained from the respective global solution (CST or ES-FEM). The $L^2$-type relative error is:\n    $$\n    e_{\\sigma} = \\frac{\\left(\\sum_{e} A_{e}\\,(\\sigma_{x,e} - \\sigma_{x,\\mathrm{exact}})^{2}\\right)^{1/2}}{|\\sigma_{x,\\mathrm{exact}}| \\, \\sqrt{\\sum_{e} A_{e}}}\n    $$\nThese metrics allow for a quantitative comparison of locking behavior. Locking in CST elements manifests as an overly stiff response ($K_h \\gg K_{h,\\mathrm{exact}}$) and poor stress predictions, especially for $\\nu \\approx 0.5$. ES-FEM is expected to yield significantly lower errors in these cases.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Main driver function to run the FEM comparison for all test cases.\n    \"\"\"\n    test_cases = [\n        # W, H, Nx, Ny, E, nu, u0\n        (1.0, 1.0, 4, 4, 1000.0, 0.3, 0.001),\n        (1.0, 1.0, 4, 4, 1000.0, 0.4999, 0.001),\n        (1.0, 1.0, 10, 10, 1000.0, 0.4999, 0.001),\n    ]\n\n    all_results = []\n\n    for W, H, Nx, Ny, E, nu, u0 in test_cases:\n        # 1. Mesh Generation\n        nodes, elements = _generate_mesh(W, H, Nx, Ny)\n\n        # 2. Constitutive Matrix\n        D = _get_constitutive_matrix(E, nu)\n\n        # 3. Exact Solution values\n        D11 = D[0, 0]\n        K_exact = D11 * H / W\n        sigma_x_exact = D11 * u0 / W\n        \n        # Pre-compute element properties (area and B-matrix) to avoid recalculations\n        elem_props = [_get_element_properties(nodes[elem]) for elem in elements]\n\n        # 4. CST Analysis\n        K_cst = _assemble_stiffness_cst(nodes, elements, D, elem_props)\n        u_cst, r_cst = _solve_system(K_cst, nodes, W, H, Nx, Ny, u0)\n        err_K_cst, err_sigma_cst = _calculate_metrics(u_cst, r_cst, K_exact, sigma_x_exact,\n                                                      nodes, elements, D, W, H, u0, Nx, Ny, elem_props)\n\n        # 5. ES-FEM Analysis\n        K_esfem = _assemble_stiffness_esfem(nodes, elements, D, elem_props)\n        u_esfem, r_esfem = _solve_system(K_esfem, nodes, W, H, Nx, Ny, u0)\n        err_K_esfem, err_sigma_esfem = _calculate_metrics(u_esfem, r_esfem, K_exact, sigma_x_exact,\n                                                          nodes, elements, D, W, H, u0, Nx, Ny, elem_props)\n\n        all_results.extend([err_K_cst, err_K_esfem, err_sigma_cst, err_sigma_esfem])\n\n    # Final print statement\n    print(f\"[{','.join(f'{x:.7f}' for x in all_results)}]\")\n\ndef _generate_mesh(W, H, Nx, Ny):\n    \"\"\"Generates nodes and triangular element connectivity for a rectangular domain.\"\"\"\n    x = np.linspace(0, W, Nx)\n    y = np.linspace(0, H, Ny)\n    xv, yv = np.meshgrid(x, y)\n    nodes = np.vstack([xv.ravel(), yv.ravel()]).T\n    \n    elements = []\n    for j in range(Ny - 1):\n        for i in range(Nx - 1):\n            n_bl = j * Nx + i\n            n_br = j * Nx + i + 1\n            n_ul = (j + 1) * Nx + i\n            n_ur = (j + 1) * Nx + i + 1\n            # Consistent diagonal split\n            elements.append([n_bl, n_br, n_ur])\n            elements.append([n_bl, n_ur, n_ul])\n    return nodes, np.array(elements)\n\ndef _get_constitutive_matrix(E, nu):\n    \"\"\"Returns the plane strain constitutive matrix D.\"\"\"\n    factor = E / ((1 + nu) * (1 - 2 * nu))\n    return factor * np.array([\n        [1 - nu, nu, 0],\n        [nu, 1 - nu, 0],\n        [0, 0, (1 - 2 * nu) / 2]\n    ])\n\ndef _get_element_properties(node_coords):\n    \"\"\"Computes area and components for the B-matrix for one element.\"\"\"\n    (x1, y1), (x2, y2), (x3, y3) = node_coords\n    \n    # Ensure CCW ordering for positive area\n    area = 0.5 * ((x2 - x1)*(y3 - y1) - (x3 - x1)*(y2 - y1))\n    if area < 0: # Flip nodes if CW\n        (x1, y1), (x2, y2), (x3, y3) = (x1, y1), (x3, y3), (x2, y2)\n        area = -area\n\n    b = np.array([y2 - y3, y3 - y1, y1 - y2])\n    c = np.array([x3 - x2, x1 - x3, x2 - x1])\n    \n    B = np.zeros((3, 6))\n    for i in range(3):\n        B[0, 2*i] = b[i]\n        B[1, 2*i+1] = c[i]\n        B[2, 2*i] = c[i]\n        B[2, 2*i+1] = b[i]\n    \n    B /= (2 * area)\n    return {'area': area, 'B': B}\n\ndef _assemble_stiffness_cst(nodes, elements, D, elem_props):\n    \"\"\"Assembles the global stiffness matrix for CST.\"\"\"\n    num_nodes = len(nodes)\n    K_global = np.zeros((2 * num_nodes, 2 * num_nodes))\n    \n    for i, elem in enumerate(elements):\n        props = elem_props[i]\n        A_e, B_e = props['area'], props['B']\n        \n        K_e = A_e * B_e.T @ D @ B_e\n        \n        dofs = np.array([[2*n, 2*n+1] for n in elem]).flatten()\n        ix_ = np.ix_(dofs, dofs)\n        K_global[ix_] += K_e\n        \n    return K_global\n\ndef _assemble_stiffness_esfem(nodes, elements, D, elem_props):\n    \"\"\"Assembles the global stiffness matrix for ES-FEM.\"\"\"\n    num_nodes = len(nodes)\n    K_global = np.zeros((2 * num_nodes, 2 * num_nodes))\n    \n    # Build edge-to-element mapping\n    edge_to_elements = {}\n    for i, elem in enumerate(elements):\n        for j in range(3):\n            n1, n2 = elem[j], elem[(j + 1) % 3]\n            edge = tuple(sorted((n1, n2)))\n            edge_to_elements.setdefault(edge, []).append(i)\n\n    # Iterate over each smoothing domain (edge)\n    for edge, adj_elem_indices in edge_to_elements.items():\n        domain_nodes = set()\n        domain_area = 0.0\n        for elem_idx in adj_elem_indices:\n            domain_nodes.update(elements[elem_idx])\n            domain_area += elem_props[elem_idx]['area']\n\n        sorted_domain_nodes = sorted(list(domain_nodes))\n        num_domain_nodes = len(sorted_domain_nodes)\n        \n        B_s = np.zeros((3, 2 * num_domain_nodes))\n        \n        # Compute smoothed gradient for each node in the domain\n        for i, node_k in enumerate(sorted_domain_nodes):\n            grad_N_k_sum = np.zeros(2) # [sum(A*dN/dx), sum(A*dN/dy)]\n            for elem_idx in adj_elem_indices:\n                elem_nodes = elements[elem_idx]\n                if node_k in elem_nodes:\n                    A_e = elem_props[elem_idx]['area']\n                    B_e = elem_props[elem_idx]['B']\n                    local_node_idx = list(elem_nodes).index(node_k)\n                    \n                    # dN/dx and dN/dy from B matrix\n                    dn_dx = B_e[0, 2*local_node_idx]\n                    dn_dy = B_e[1, 2*local_node_idx+1]\n                    \n                    grad_N_k_sum += A_e * np.array([dn_dx, dn_dy])\n            \n            smoothed_grad = grad_N_k_sum / domain_area\n            b_tilde_k, c_tilde_k = smoothed_grad[0], smoothed_grad[1]\n            \n            B_s[0, 2*i] = b_tilde_k\n            B_s[1, 2*i+1] = c_tilde_k\n            B_s[2, 2*i] = c_tilde_k\n            B_s[2, 2*i+1] = b_tilde_k\n\n        K_s = domain_area * B_s.T @ D @ B_s\n        \n        dofs = np.array([[2*n, 2*n+1] for n in sorted_domain_nodes]).flatten()\n        ix_ = np.ix_(dofs, dofs)\n        K_global[ix_] += K_s\n        \n    return K_global\n\ndef _solve_system(K, nodes, W, H, Nx, Ny, u0):\n    \"\"\"Applies BCs and solves the linear system.\"\"\"\n    num_nodes = len(nodes)\n    num_dofs = 2 * num_nodes\n    \n    # Identify constrained DOFs\n    left_nodes = [j * Nx for j in range(Ny)]\n    right_nodes = [j * Nx + (Nx - 1) for j in range(Ny)]\n    \n    constrained_dofs = []\n    prescribed_vals = []\n    \n    # Left boundary: u_x = 0, u_y = 0\n    for node_idx in left_nodes:\n        constrained_dofs.extend([2 * node_idx, 2 * node_idx + 1])\n        prescribed_vals.extend([0.0, 0.0])\n        \n    # Right boundary: u_x = u0, u_y = 0\n    for node_idx in right_nodes:\n        constrained_dofs.extend([2 * node_idx, 2 * node_idx + 1])\n        prescribed_vals.extend([u0, 0.0])\n    \n    u_c = np.array(prescribed_vals)\n    \n    all_dofs = np.arange(num_dofs)\n    free_dofs = np.setdiff1d(all_dofs, constrained_dofs)\n    \n    # Partitioning method to solve\n    K_ff = K[np.ix_(free_dofs, free_dofs)]\n    K_fc = K[np.ix_(free_dofs, constrained_dofs)]\n    \n    rhs = -K_fc @ u_c\n    \n    try:\n         u_f = linalg.solve(K_ff, rhs)\n    except linalg.LinAlgError:\n         # Fallback to pseudo-inverse for singular matrices (can happen with locking)\n         u_f = linalg.pinv(K_ff) @ rhs\n\n    u = np.zeros(num_dofs)\n    u[free_dofs] = u_f\n    u[constrained_dofs] = u_c\n    \n    # Calculate reaction forces\n    r = K @ u\n    \n    return u, r\n\ndef _calculate_metrics(u, r, K_exact, sigma_x_exact, nodes, elements, D, W, H, u0, Nx, Ny, elem_props):\n    \"\"\"Calculates apparent stiffness error and stress L2 error.\"\"\"\n    # 1. Apparent Stiffness Error\n    right_dofs_x = [2 * (j * Nx + (Nx - 1)) for j in range(Ny)]\n    R_x = np.sum(r[right_dofs_x])\n    K_h_fem = R_x / u0\n    err_K = np.abs((K_h_fem - K_exact) / K_exact)\n    \n    # 2. Stress Error\n    total_area = W * H\n    numerator_sum = 0.0\n    \n    for i, elem in enumerate(elements):\n        props = elem_props[i]\n        A_e, B_e = props['area'], props['B']\n        \n        dofs = np.array([[2*n, 2*n+1] for n in elem]).flatten()\n        u_e = u[dofs]\n        \n        eps_e = B_e @ u_e\n        sigma_e = D @ eps_e\n        sigma_x_e = sigma_e[0]\n        \n        numerator_sum += A_e * (sigma_x_e - sigma_x_exact)**2\n    \n    denominator = np.abs(sigma_x_exact) * np.sqrt(total_area) if np.abs(sigma_x_exact) > 1e-12 else 1.0\n    err_sigma = np.sqrt(numerator_sum) / denominator\n    \n    return err_K, err_sigma\n\nif __name__ == '__main__':\n    solve()\n\n```"
        }
    ]
}