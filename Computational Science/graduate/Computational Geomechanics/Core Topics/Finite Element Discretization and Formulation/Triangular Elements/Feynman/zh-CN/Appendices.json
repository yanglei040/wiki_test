{
    "hands_on_practices": [
        {
            "introduction": "为了精确模拟隧道或弯曲土层等复杂几何形状，我们需要从简单的直线边三角形单元发展到高阶单元。本练习将引导您体验等参映射的核心机制，这是一种基本技术，它使用相同的形函数来描述单元的几何形状及其内部的位移场。通过计算雅可比矩阵（Jacobian matrix）并应用数值积分，您将掌握在扭曲的真实单元形状上进行积分的基本步骤，这是高阶有限元分析的一项核心技能。",
            "id": "3569080",
            "problem": "在计算地质力学中，等参三角形单元使用相同的形函数来插值几何形状和场，从而将参考三角形映射到物理三角形。考虑一个六节点二次等参线性应变三角形（LST），其物理节点坐标（单位为米）如下\n$$\n(x_{1},y_{1})=(0,0),\\quad (x_{2},y_{2})=(3,0),\\quad (x_{3},y_{3})=(0,2),\\quad (x_{4},y_{4})=(1.5,0.05),\\quad (x_{5},y_{5})=(1.5,1.0),\\quad (x_{6},y_{6})=(0.0,1.0).\n$$\n设参考三角形由自然坐标 $(\\xi,\\eta)$ 定义，其顶点位于 $(0,0)$、$(1,0)$ 和 $(0,1)$，并设面积（重心）坐标为\n$$\nL_{1}=1-\\xi-\\eta,\\quad L_{2}=\\xi,\\quad L_{3}=\\eta,\\quad L_{1}+L_{2}+L_{3}=1.\n$$\n二次LST形函数用面积坐标表示为\n$$\nN_{1}=L_{1}(2L_{1}-1),\\quad N_{2}=L_{2}(2L_{2}-1),\\quad N_{3}=L_{3}(2L_{3}-1),\\quad N_{4}=4L_{1}L_{2},\\quad N_{5}=4L_{2}L_{3},\\quad N_{6}=4L_{3}L_{1}.\n$$\n等参映射为\n$$\nx(\\xi,\\eta)=\\sum_{i=1}^{6}N_{i}(\\xi,\\eta)\\,x_{i},\\qquad y(\\xi,\\eta)=\\sum_{i=1}^{6}N_{i}(\\xi,\\eta)\\,y_{i}.\n$$\n在参考三角形上使用 Dunavant 2次求积法则，其求积点和权重以重心坐标形式由下式给出\n$$\n(L_{1},L_{2},L_{3})\\in\\left\\{\\left(\\tfrac{2}{3},\\tfrac{1}{6},\\tfrac{1}{6}\\right),\\ \\left(\\tfrac{1}{6},\\tfrac{2}{3},\\tfrac{1}{6}\\right),\\ \\left(\\tfrac{1}{6},\\tfrac{1}{6},\\tfrac{2}{3}\\right)\\right\\},\\qquad w=\\tfrac{1}{6}\\ \\text{for each point}.\n$$\n假设节点排序保持方向，使得雅可比行列式在整个单元上为正。从以上定义出发，执行以下操作：\n\n- 通过等参映射，将每个 Dunavant 求积点从重心坐标 $(L_{1},L_{2},L_{3})$ 映射到物理坐标 $(x,y)$。\n- 计算雅可比矩阵\n$$\n\\mathbf{J}(\\xi,\\eta)=\\begin{pmatrix}\\dfrac{\\partial x}{\\partial \\xi} & \\dfrac{\\partial x}{\\partial \\eta} \\\\[6pt] \\dfrac{\\partial y}{\\partial \\xi} & \\dfrac{\\partial y}{\\partial \\eta}\\end{pmatrix}\n$$\n及其在每个求积点处的行列式。\n- 在每个点处构成经雅可比行列式缩放的求积权重 $w_{i}\\,\\det\\mathbf{J}(\\xi_{i},\\eta_{i})$。\n\n然后，使用这些雅可比权重通过在参考三角形上使用 Dunavant 求积法来计算面积分\n$$\n\\int_{\\Omega_{e}}1\\,\\mathrm{d}\\Omega=\\int_{\\hat{\\Omega}}\\det\\mathbf{J}(\\xi,\\eta)\\,\\mathrm{d}\\xi\\,\\mathrm{d}\\eta\n$$\n以平方米表示最终面积。提供一个单一的最终答案，除非无法精确计算，否则不需要四舍五入。",
            "solution": "用户希望执行一系列与六节点二次等参三角形单元相关的计算，最终使用 Dunavant 2次求积法则来评估单元的面积。\n\n### 步骤 0：问题验证\n\n**已知条件提取：**\n- 单元类型：六节点二次等参线性应变三角形（LST）。\n- 物理节点坐标 $(x_i, y_i)$，单位为米：\n  - $(x_1, y_1) = (0, 0)$\n  - $(x_2, y_2) = (3, 0)$\n  - $(x_3, y_3) = (0, 2)$\n  - $(x_4, y_4) = (1.5, 0.05)$\n  - $(x_5, y_5) = (1.5, 1.0)$\n  - $(x_6, y_6) = (0.0, 1.0)$\n- 自然坐标 $(\\xi, \\eta)$ 中的参考三角形顶点：$(0,0)$、$(1,0)$ 和 $(0,1)$。\n- 面积（重心）坐标：$L_{1}=1-\\xi-\\eta$，$L_{2}=\\xi$，$L_{3}=\\eta$。\n- 二次形函数 $N_i$：\n  - $N_{1}=L_{1}(2L_{1}-1)$\n  - $N_{2}=L_{2}(2L_{2}-1)$\n  - $N_{3}=L_{3}(2L_{3}-1)$\n  - $N_{4}=4L_{1}L_{2}$\n  - $N_{5}=4L_{2}L_{3}$\n  - $N_{6}=4L_{3}L_{1}$\n- 等参映射：$x(\\xi,\\eta)=\\sum_{i=1}^{6}N_{i}(\\xi,\\eta)x_{i}$，$y(\\xi,\\eta)=\\sum_{i=1}^{6}N_{i}(\\xi,\\eta)y_{i}$。\n- Dunavant 2次求积法则：\n  - 重心坐标 $(L_1, L_2, L_3)$ 中的求积点：$(\\frac{2}{3}, \\frac{1}{6}, \\frac{1}{6})$, $(\\frac{1}{6}, \\frac{2}{3}, \\frac{1}{6})$, $(\\frac{1}{6}, \\frac{1}{6}, \\frac{2}{3})$。\n  - 每个点的权重：$w = \\frac{1}{6}$。\n- 雅可比矩阵定义：$\\mathbf{J}(\\xi,\\eta)=\\begin{pmatrix} \\partial x/\\partial\\xi & \\partial x/\\partial\\eta \\\\ \\partial y/\\partial\\xi & \\partial y/\\partial\\eta \\end{pmatrix}$。\n- 面积分定义：$\\int_{\\Omega_{e}}1\\,\\mathrm{d}\\Omega=\\int_{\\hat{\\Omega}}\\det\\mathbf{J}(\\xi,\\eta)\\,\\mathrm{d}\\xi\\,\\mathrm{d}\\eta$。\n\n**验证：**\n1.  **科学依据：** 该问题是有限元法（FEM）在等参映射和数值积分方面的标准应用，这些是计算力学的核心概念。所有定义和公式都是标准且正确的。\n2.  **适定性：** 所有必要的数据（节点坐标、形函数、求积法则）都已提供。任务定义清晰，并导向唯一的解。\n3.  **客观性：** 问题陈述纯粹是数学性和程序性的，没有任何主观或模糊的语言。\n4.  **自洽性与一致性：** 所提供的信息足以解决问题。没有内部矛盾。例如，形函数之和为 $\\sum N_i = 1$，求积权重之和 $3 \\times \\frac{1}{6} = \\frac{1}{2}$ 对应于参考三角形的面积，表明求积法则的定义是一致的。\n\n**结论：** 问题是有效的。\n\n### 步骤 1：映射求积点\n\n首先，我们使用关系式 $L_2 = \\xi$ 和 $L_3 = \\eta$ 将求积点（QP）的重心坐标 $(L_1, L_2, L_3)$ 转换为自然坐标 $(\\xi, \\eta)$。\n- **求积点1：** $(L_1, L_2, L_3) = (\\frac{2}{3}, \\frac{1}{6}, \\frac{1}{6}) \\implies (\\xi_1, \\eta_1) = (\\frac{1}{6}, \\frac{1}{6})$。\n- **求积点2：** $(L_1, L_2, L_3) = (\\frac{1}{6}, \\frac{2}{3}, \\frac{1}{6}) \\implies (\\xi_2, \\eta_2) = (\\frac{2}{3}, \\frac{1}{6})$。\n- **求积点3：** $(L_1, L_2, L_3) = (\\frac{1}{6}, \\frac{1}{6}, \\frac{2}{3}) \\implies (\\xi_3, \\eta_3) = (\\frac{1}{6}, \\frac{2}{3})$。\n\n对于每个求积点，我们计算形函数 $N_i$，然后使用等参映射找到物理坐标 $(x, y)$。\n\n**对于求积点1： $(L_1, L_2, L_3) = (\\frac{2}{3}, \\frac{1}{6}, \\frac{1}{6})$**\n- 形函数：\n  $N_1 = \\frac{2}{3}(2\\cdot\\frac{2}{3}-1) = \\frac{2}{9}$\n  $N_2 = \\frac{1}{6}(2\\cdot\\frac{1}{6}-1) = -\\frac{1}{9}$\n  $N_3 = \\frac{1}{6}(2\\cdot\\frac{1}{6}-1) = -\\frac{1}{9}$\n  $N_4 = 4(\\frac{2}{3})(\\frac{1}{6}) = \\frac{4}{9}$\n  $N_5 = 4(\\frac{1}{6})(\\frac{1}{6}) = \\frac{1}{9}$\n  $N_6 = 4(\\frac{1}{6})(\\frac{2}{3}) = \\frac{4}{9}$\n- 物理坐标：\n  $x_1 = \\sum N_i x_i = (-\\frac{1}{9})(3) + (\\frac{4}{9})(1.5) + (\\frac{1}{9})(1.5) = \\frac{-3+6+1.5}{9} = \\frac{4.5}{9} = \\frac{1}{2}$\n  $y_1 = \\sum N_i y_i = (-\\frac{1}{9})(2) + (\\frac{4}{9})(0.05) + (\\frac{1}{9})(1) + (\\frac{4}{9})(1) = \\frac{-2+0.2+1+4}{9} = \\frac{3.2}{9} = \\frac{16}{45}$\n- 映射点 1： $(x,y) = (\\frac{1}{2}, \\frac{16}{45})$。\n\n**对于求积点2： $(L_1, L_2, L_3) = (\\frac{1}{6}, \\frac{2}{3}, \\frac{1}{6})$**\n- 形函数：\n  $N_1 = -\\frac{1}{9}$, $N_2 = \\frac{2}{9}$, $N_3 = -\\frac{1}{9}$, $N_4 = \\frac{4}{9}$, $N_5 = \\frac{4}{9}$, $N_6 = \\frac{1}{9}$\n- 物理坐标：\n  $x_2 = (\\frac{2}{9})(3) + (\\frac{4}{9})(1.5) + (\\frac{4}{9})(1.5) = \\frac{6+6+6}{9} = \\frac{18}{9} = 2$\n  $y_2 = (-\\frac{1}{9})(2) + (\\frac{4}{9})(0.05) + (\\frac{4}{9})(1) + (\\frac{1}{9})(1) = \\frac{-2+0.2+4+1}{9} = \\frac{3.2}{9} = \\frac{16}{45}$\n- 映射点 2： $(x,y) = (2, \\frac{16}{45})$。\n\n**对于求积点3： $(L_1, L_2, L_3) = (\\frac{1}{6}, \\frac{1}{6}, \\frac{2}{3})$**\n- 形函数：\n  $N_1 = -\\frac{1}{9}$, $N_2 = -\\frac{1}{9}$, $N_3 = \\frac{2}{9}$, $N_4 = \\frac{1}{9}$, $N_5 = \\frac{4}{9}$, $N_6 = \\frac{4}{9}$\n- 物理坐标：\n  $x_3 = (-\\frac{1}{9})(3) + (\\frac{1}{9})(1.5) + (\\frac{4}{9})(1.5) = \\frac{-3+1.5+6}{9} = \\frac{4.5}{9} = \\frac{1}{2}$\n  $y_3 = (\\frac{2}{9})(2) + (\\frac{1}{9})(0.05) + (\\frac{4}{9})(1) + (\\frac{4}{9})(1) = \\frac{4+0.05+4+4}{9} = \\frac{12.05}{9} = \\frac{241}{180}$\n- 映射点 3： $(x,y) = (\\frac{1}{2}, \\frac{241}{180})$。\n\n### 步骤 2：计算雅可比矩阵和行列式\n\n雅可比矩阵 $\\mathbf{J}$ 的分量通过对等参映射函数求导得到。\n$\\frac{\\partial x}{\\partial\\xi} = \\sum_{i=1}^{6} \\frac{\\partial N_i}{\\partial\\xi} x_i$，$\\frac{\\partial x}{\\partial\\eta} = \\sum_{i=1}^{6} \\frac{\\partial N_i}{\\partial\\eta} x_i$，等等。\n形函数关于自然坐标的导数通过链式法则求得，例如 $\\frac{\\partial N_i}{\\partial\\xi} = \\sum_{j=1}^{3} \\frac{\\partial N_i}{\\partial L_j} \\frac{\\partial L_j}{\\partial\\xi}$。\n导数 $\\partial L_j/\\partial\\xi$ 和 $\\partial L_j/\\partial\\eta$ 是常数：\n$\\frac{\\partial L_1}{\\partial\\xi}=-1, \\frac{\\partial L_1}{\\partial\\eta}=-1$; $\\frac{\\partial L_2}{\\partial\\xi}=1, \\frac{\\partial L_2}{\\partial\\eta}=0$; $\\frac{\\partial L_3}{\\partial\\xi}=0, \\frac{\\partial L_3}{\\partial\\eta}=1$。\n\n对于这个特定问题，一个更直接的方法是推导雅可比分量的解析表达式。\n节点坐标的选择简化了 $x$ 的映射：$x(\\xi,\\eta)=3\\xi$。这可以通过检查所有六个节点都满足 $x_i = 3\\xi_i$ 来验证。因此，在单元内处处都有 $\\frac{\\partial x}{\\partial\\xi} = 3$ 和 $\\frac{\\partial x}{\\partial\\eta} = 0$。\n\n$y$ 的导数必须被计算。\n$\\frac{\\partial y}{\\partial\\xi} = \\sum \\frac{\\partial N_i}{\\partial\\xi} y_i$ 且 $\\frac{\\partial y}{\\partial\\eta} = \\sum \\frac{\\partial N_i}{\\partial\\eta} y_i$。\n在将表达式 $\\frac{\\partial N_i}{\\partial\\xi}$ 和 $\\frac{\\partial N_i}{\\partial\\eta}$ 推导为 $\\xi$ 和 $\\eta$ 的线性函数，并代入节点 $y_i$ 坐标后，我们得到：\n$\\frac{\\partial y}{\\partial\\xi}(\\xi, \\eta) = 0.2 - 0.4\\xi - 0.2\\eta = \\frac{1}{5} - \\frac{2}{5}\\xi - \\frac{1}{5}\\eta$\n$\\frac{\\partial y}{\\partial\\eta}(\\xi, \\eta) = 2 - 0.2\\xi = 2 - \\frac{1}{5}\\xi$\n雅可比矩阵为 $\\mathbf{J}(\\xi, \\eta) = \\begin{pmatrix} 3 & 0 \\\\ \\frac{1}{5} - \\frac{2}{5}\\xi - \\frac{1}{5}\\eta & 2 - \\frac{1}{5}\\xi \\end{pmatrix}$。\n行列式为 $\\det\\mathbf{J}(\\xi, \\eta) = 3(2 - \\frac{1}{5}\\xi) = 6 - \\frac{3}{5}\\xi$。\n\n现在我们在每个求积点处计算雅可比矩阵及其行列式。\n\n**对于求积点1： $(\\xi_1, \\eta_1) = (\\frac{1}{6}, \\frac{1}{6})$**\n- 雅可比矩阵：\n  $J_{11}=3$, $J_{12}=0$\n  $J_{21} = \\frac{1}{5} - \\frac{2}{5}(\\frac{1}{6}) - \\frac{1}{5}(\\frac{1}{6}) = \\frac{1}{5} - \\frac{3}{30} = \\frac{1}{5} - \\frac{1}{10} = \\frac{1}{10}$\n  $J_{22} = 2 - \\frac{1}{5}(\\frac{1}{6}) = 2 - \\frac{1}{30} = \\frac{59}{30}$\n  $\\mathbf{J}_1 = \\begin{pmatrix} 3 & 0 \\\\ 1/10 & 59/30 \\end{pmatrix}$\n- 行列式：\n  $\\det\\mathbf{J}_1 = 6 - \\frac{3}{5}(\\frac{1}{6}) = 6 - \\frac{1}{10} = \\frac{59}{10} = 5.9$\n\n**对于求积点2： $(\\xi_2, \\eta_2) = (\\frac{2}{3}, \\frac{1}{6})$**\n- 雅可比矩阵：\n  $J_{11}=3$, $J_{12}=0$\n  $J_{21} = \\frac{1}{5} - \\frac{2}{5}(\\frac{2}{3}) - \\frac{1}{5}(\\frac{1}{6}) = \\frac{1}{5} - \\frac{4}{15} - \\frac{1}{30} = \\frac{6-8-1}{30} = -\\frac{3}{30} = -\\frac{1}{10}$\n  $J_{22} = 2 - \\frac{1}{5}(\\frac{2}{3}) = 2 - \\frac{2}{15} = \\frac{28}{15}$\n  $\\mathbf{J}_2 = \\begin{pmatrix} 3 & 0 \\\\ -1/10 & 28/15 \\end{pmatrix}$\n- 行列式：\n  $\\det\\mathbf{J}_2 = 6 - \\frac{3}{5}(\\frac{2}{3}) = 6 - \\frac{2}{5} = \\frac{28}{5} = 5.6$\n\n**对于求积点3： $(\\xi_3, \\eta_3) = (\\frac{1}{6}, \\frac{2}{3})$**\n- 雅可比矩阵：\n  $J_{11}=3$, $J_{12}=0$\n  $J_{21} = \\frac{1}{5} - \\frac{2}{5}(\\frac{1}{6}) - \\frac{1}{5}(\\frac{2}{3}) = \\frac{1}{5} - \\frac{1}{15} - \\frac{2}{15} = \\frac{1}{5} - \\frac{3}{15} = \\frac{1}{5} - \\frac{1}{5} = 0$\n  $J_{22} = 2 - \\frac{1}{5}(\\frac{1}{6}) = 2 - \\frac{1}{30} = \\frac{59}{30}$\n  $\\mathbf{J}_3 = \\begin{pmatrix} 3 & 0 \\\\ 0 & 59/30 \\end{pmatrix}$\n- 行列式：\n  $\\det\\mathbf{J}_3 = 6 - \\frac{3}{5}(\\frac{1}{6}) = 6 - \\frac{1}{10} = \\frac{59}{10} = 5.9$\n\n### 步骤 3：构成经雅可比行列式缩放的求积权重\n\n每个求积点的权重 $w$ 给出为 $\\frac{1}{6}$。经雅可比行列式缩放的权重是 $w \\det\\mathbf{J}$。\n- 权重 1： $w_1 \\det\\mathbf{J}_1 = \\frac{1}{6} \\times \\frac{59}{10} = \\frac{59}{60}$\n- 权重 2： $w_2 \\det\\mathbf{J}_2 = \\frac{1}{6} \\times \\frac{28}{5} = \\frac{28}{30} = \\frac{14}{15}$\n- 权重 3： $w_3 \\det\\mathbf{J}_3 = \\frac{1}{6} \\times \\frac{59}{10} = \\frac{59}{60}$\n\n### 步骤 4：计算面积分\n\n物理单元 $\\Omega_e$ 的面积由积分 $\\int_{\\Omega_e} 1\\,\\mathrm{d}\\Omega$ 给出。将该积分变换到参考单元 $\\hat{\\Omega}$ 上，得到 $\\int_{\\hat{\\Omega}}\\det\\mathbf{J}(\\xi,\\eta)\\,\\mathrm{d}\\xi\\,\\mathrm{d}\\eta$。\n我们使用给定的 Dunavant 求积法则来近似这个积分：\n面积 $\\approx \\sum_{i=1}^{3} w_i \\det\\mathbf{J}(\\xi_i, \\eta_i)$\n该和由上一步中计算的经雅可比行列式缩放的权重构成。\n面积 $\\approx \\frac{59}{60} + \\frac{14}{15} + \\frac{59}{60} = \\frac{59}{60} + \\frac{56}{60} + \\frac{59}{60} = \\frac{59+56+59}{60} = \\frac{174}{60} = \\frac{29}{10} = 2.9$\n\n由于被积函数 $\\det\\mathbf{J} = 6 - \\frac{3}{5}\\xi$ 是关于 $\\xi$ 和 $\\eta$ 的线性多项式，2次求积法则（对最高为2次的多项式是精确的）会得到精确面积。\n精确面积 $= \\int_{0}^{1} \\int_{0}^{1-\\xi} (6 - \\frac{3}{5}\\xi) d\\eta d\\xi = \\int_{0}^{1} (6 - \\frac{3}{5}\\xi)(1-\\xi) d\\xi$\n$= \\int_{0}^{1} (6 - 6\\xi - \\frac{3}{5}\\xi + \\frac{3}{5}\\xi^2) d\\xi = \\int_{0}^{1} (\\frac{3}{5}\\xi^2 - \\frac{33}{5}\\xi + 6) d\\xi$\n$= [\\frac{1}{5}\\xi^3 - \\frac{33}{10}\\xi^2 + 6\\xi]_0^1 = \\frac{1}{5} - \\frac{33}{10} + 6 = \\frac{2-33+60}{10} = \\frac{29}{10} = 2.9$。\n数值求积的结果是精确的。",
            "answer": "$$\n\\boxed{2.9}\n$$"
        },
        {
            "introduction": "单元的理论优势最好通过实际应用来理解，尤其是在其局限性受到挑战时。本练习要求您构建一个小型有限元求解器，以研究一个关键的数值问题：在饱和黏土等近乎不可压缩材料中出现的体积锁定（volumetric locking）现象。通过在静水压力下比较简单常应变三角形单元（CST）与更高级的线性应变三角形单元（LST）的性能，您将直接观察到单元选择如何影响求解精度，并理解为何高阶单元对于可靠的分析至关重要。",
            "id": "3569137",
            "problem": "您需要从基本原理出发，实现一个使用三角形单元的小应变、二维、平面应变、线性弹性有限元求解器，用于在方形域上受均匀压缩面力作用下，数值测量静水体积模量。您的求解器必须同时支持常应变三角形（CST）和六节点二次三角形（Lagrange 六节点三角形，通常称为 LST）。计算任务是：根据单元贡献组装全局刚度矩阵，在所有四个边上施加均匀压缩面力，以最小方式约束刚体模态，求解位移场，并通过后处理计算数值体积模量，其定义为平均静水平均应力大小与平均体积应变大小之比。其目的是比较对泊松比的敏感性，并通过对近不可压缩材料的数值体积模量的过高预测来识别体积自锁现象。\n\n从以下基本原理和定义开始：\n- 小应变运动学：平面内应变张量分量为 $ \\varepsilon_{xx} = \\partial u/\\partial x $，$ \\varepsilon_{yy} = \\partial v/\\partial y $，以及 $ \\gamma_{xy} = \\partial u/\\partial y + \\partial v/\\partial x $，其中 $ u $ 和 $ v $ 分别是 $ x $ 和 $ y $ 方向上的位移分量。\n- 对于厚度为 $ t $、域为 $ \\Omega $、边界为 $ \\partial \\Omega $（其上规定了面力 $ \\mathbf{t} $）的物体，其线性动量平衡的弱形式为：寻找 $ \\mathbf{u} \\in \\mathcal{V} $，使得对于所有虚位移 $ \\mathbf{w} \\in \\mathcal{V}_0 $，均满足 $ \\int_{\\Omega} \\boldsymbol{\\varepsilon}(\\mathbf{u}) : \\mathbf{C} : \\boldsymbol{\\varepsilon}(\\mathbf{w})\\, d\\Omega = \\int_{\\partial \\Omega_t} \\mathbf{t} \\cdot \\mathbf{w}\\, d\\Gamma $，其中 $ \\mathbf{C} $ 是四阶弹性张量，$ \\boldsymbol{\\varepsilon}(\\cdot) $ 是对称梯度。\n- 本构关系（各向同性线弹性）在平面应变假设下为：$ \\boldsymbol{\\sigma} = \\mathbf{D}_{\\text{ps}} \\boldsymbol{\\varepsilon} $，其中 $ \\mathbf{D}_{\\text{ps}} $ 是一个 $ 3 \\times 3 $ 的平面应变弹性矩阵，依赖于杨氏模量 $ E $ 和泊松比 $ \\nu $。使用与平面应变一致的小应变各向同性弹性理论。\n- 静水平均应力（三维）定义为 $ p = -\\tfrac{1}{3}(\\sigma_{xx} + \\sigma_{yy} + \\sigma_{zz}) $。在平面应变条件下，$ \\varepsilon_{zz} = 0 $ 且 $ \\sigma_{zz} $ 不为零，为了得到一致的体积模量测量值，必须将 $ \\sigma_{zz} $ 包含在 $ p $ 的计算中。\n- 体积应变（三维）为 $ \\varepsilon_v = \\varepsilon_{xx} + \\varepsilon_{yy} + \\varepsilon_{zz} $。在平面应变条件下，$ \\varepsilon_{zz} = 0 $，因此 $ \\varepsilon_v = \\varepsilon_{xx} + \\varepsilon_{yy} $。\n\n问题几何与加载：\n- 域：边长为 $ L = 1\\,\\text{m} $、厚度为 $ t = 1\\,\\text{m} $ 的单位正方形。\n- 材料：均匀、各向同性，杨氏模量 $ E = 100\\,\\text{MPa} $，泊松比 $ \\nu $ 可变。\n- 边界面力：在所有四个边上施加大小为 $ p_0 = 1\\,\\text{MPa} $ 的均匀压缩面力，即 $ \\mathbf{t} = -p_0 \\mathbf{n} $，其中 $ \\mathbf{n} $ 是每个边界段上的外法向单位向量。\n- 运动学：平面应变。\n- 刚体约束：通过在左下角节点 $ (x,y) = (0,0) $ 处固定位移 $ (u,v) = (0,0) $，并额外在右下角节点 $ (x,y) = (1,0) $ 处固定水平位移 $ u = 0 $ 来消除刚体运动。\n\n有限元离散化要求：\n- 使用一个由 $ N_x \\times N_y $ 个矩形单元构成的结构化网格，每个矩形单元再细分为两个三角形。\n- 实现两种单元类型：\n  1. CST：三节点线性三角形，具有常应变。\n  2. LST：六节点二次三角形，每条边上均有中点节点。使用从带有局部坐标 $ (\\xi,\\eta) $ 的参考三角形到全局坐标的等参映射，并使用标准的二次 Lagrange 形函数。\n- 使用精确或适当的高斯求积：对于 CST，常应变积分通过一次求值即可得到精确结果；对于 LST，使用能在参考三角形上精确积分最高二次多项式的求积法则。\n- 将边界面力作为边界边上的一致节点力施加：\n  - 对于长度为 $ \\ell $ 的双节点边界边，将面力以 $ \\ell/2 $ 的比例（矢量）分配给每个节点。\n  - 对于长度为 $ \\ell $ 的三节点边界边（二次），分别在起始节点、中点节点和结束节点处使用权重 $ [\\ell/6,\\; 2\\ell/3,\\; \\ell/6] $。\n- 组装全局刚度矩阵并求解线性系统以获得节点位移。\n\n数值体积模量的后处理定义：\n- 计算面积平均体积应变 $ \\overline{\\varepsilon}_v $，即 $ \\varepsilon_{xx} + \\varepsilon_{yy} $ 在 $ \\Omega $ 上的面积加权平均值。\n- 计算面积平均静水平均应力 $ \\overline{p} $，即 $ p = -\\tfrac{1}{3}(\\sigma_{xx} + \\sigma_{yy} + \\sigma_{zz}) $ 在 $ \\Omega $ 上的面积加权平均值。在平面应变条件下，必须根据三维各向同性定律，利用 $ \\varepsilon_{zz} = 0 $ 和已计算出的平面内应变，来一致地计算 $ \\sigma_{zz} $。\n- 将数值静水体积模量定义为 $ K_h = \\dfrac{\\overline{p}}{-\\overline{\\varepsilon}_v} $。报告的 $ K_h $ 应为正值。\n- 将 $ K_h $ 以兆帕（MPa）为单位表示，并四舍五入到六位小数。\n\n测试套件和要求输出：\n- 使用以下四个测试用例，每个用例指定为 $ (\\text{element}, N_x, N_y, \\nu) $：\n  1. $ (\\text{CST},\\; 8,\\; 8,\\; 0.25) $\n  2. $ (\\text{LST},\\; 8,\\; 8,\\; 0.25) $\n  3. $ (\\text{CST},\\; 8,\\; 8,\\; 0.49) $\n  4. $ (\\text{LST},\\; 8,\\; 8,\\; 0.49) $\n- 对于所有用例，取 $ E = 100\\,\\text{MPa} $、$ p_0 = 1\\,\\text{MPa} $、$ L = 1\\,\\text{m} $ 和 $ t = 1\\,\\text{m} $。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果顺序与上述用例顺序相同，例如 $ [k_1,k_2,k_3,k_4] $。每个 $ k_i $ 都必须是以兆帕为单位的浮点数，并四舍五入到六位小数。\n\n科学预期：\n- 对于中等泊松比 $ \\nu $（例如，$ \\nu = 0.25 $），如果网格足够细化，CST 和 LST 都应能很好地逼近连续介质的体积模量。\n- 对于近不可压缩材料（例如，$ \\nu = 0.49 $），在完全积分下，CST 预计会表现出体积自锁，导致相对于连续介质值的 $ K_h $ 被过高预测，而 LST 则应能缓解自锁现象，其结果更接近连续介质值。\n\n最终交付物：\n- 编写一个完整、可运行的程序来实现上述要求，程序无外部输入。最终打印输出必须是严格按照所述格式的一行内容，按顺序包含四个测试用例的 $ K_h $ 值（单位为 MPa）。",
            "solution": "用户提供了一个定义明确的计算固体力学问题，要求实现一个用于平面应变条件下线弹性问题的二维有限元方法（FEM）求解器。目标是使用常应变三角形（CST）和六节点二次三角形（LST）单元，计算在均匀压缩下的方形域的静水体积模量 $K_h$。该问题在科学上是合理的，包含了所有必要的数据，并且是展示单元性能的标准验证练习，特别是近不可压缩材料中的体积自锁现象。我将继续提供详细的解决方案。\n\n该解决方案从基本原理出发，遵循以下主要步骤：\n1.  **离散化**：为 CST 和 LST 两种单元类型生成有限元网格，包括节点坐标和单元连接关系。\n2.  **单元公式**：推导和计算每种单元类型的单元刚度矩阵（$k_e$）。\n3.  **系统组装**：根据单元级贡献构建全局刚度矩阵（$K$）和全局力向量（$F$）。\n4.  **施加边界条件**：将规定的面力合并为一致节点力，并强制施加本质边界条件（固定位移）。\n5.  **求解**：求解线性方程组 $K\\mathbf{d} = F$ 以找到节点位移向量 $\\mathbf{d}$。\n6.  **后处理**：通过对域上的应力和应变进行平均，从位移解中计算数值静水体积模量（$K_h$）。\n\n**1. 离散化与网格生成**\n\n域是一个单位正方形（$L=1\\,\\text{m}$）。它被离散化为一个由 $N_x \\times N_y$ 个矩形单元组成的结构化网格，每个单元再细分为两个三角形单元。\n-   **对于 CST 单元**：网格包含 $(N_x+1) \\times (N_y+1)$ 个节点。每个由四个角节点定义的单元被分割成两个三节点三角形。\n-   **对于 LST 单元**：添加了边中节点。网格包含 $(2N_x+1) \\times (2N_y+1)$ 个节点。每个单元被分割成两个六节点二次三角形。每个 LST 单元的连接关系由其三个角节点和三个边中节点定义。节点排序与参考单元的标准 Lagrange 形函数定义一致。对于一个角节点为 $1, 2, 3$ 的三角形，边中节点的排序为 mid(1-2)、mid(2-3)、mid(3-1)。\n\n**2. 各向同性线弹性与单元公式**\n\n本构行为由平面应变线弹性矩阵 $D_{ps}$ 控制，该矩阵将平面内应力向量 $\\boldsymbol{\\sigma} = [\\sigma_{xx}, \\sigma_{yy}, \\tau_{xy}]^T$ 与工程应变向量 $\\boldsymbol{\\varepsilon} = [\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}]^T$ 联系起来：\n$$ \\boldsymbol{\\sigma} = \\mathbf{D}_{\\text{ps}} \\boldsymbol{\\varepsilon} \\quad \\text{where} \\quad \\mathbf{D}_{\\text{ps}} = \\frac{E}{(1+\\nu)(1-2\\nu)} \\begin{pmatrix} 1-\\nu & \\nu & 0 \\\\ \\nu & 1-\\nu & 0 \\\\ 0 & 0 & \\frac{1-2\\nu}{2} \\end{pmatrix} $$\n应变-位移关系由 $\\boldsymbol{\\varepsilon} = \\mathbf{B} \\mathbf{d}_e$ 给出，其中 $\\mathbf{B}$ 是应变-位移矩阵，$\\mathbf{d}_e$ 是单元的节点位移向量。厚度为 $t$ 的单元刚度矩阵 $k_e$ 通过对单元面积 $A_e$ 进行积分计算得出：\n$$ k_e = \\int_{A_e} \\mathbf{B}^T \\mathbf{D}_{\\text{ps}} \\mathbf{B} \\, dA \\cdot t $$\n\n**常应变三角形 (CST)**\nCST 单元具有线性位移场。这导致整个单元内的应变（和应力）是恒定的。因此 $\\mathbf{B}$ 矩阵是常数：\n$$ \\mathbf{B}_{\\text{CST}} = \\frac{1}{2A_e} \\begin{pmatrix} y_{23} & 0 & y_{31} & 0 & y_{12} & 0 \\\\ 0 & x_{32} & 0 & x_{13} & 0 & x_{21} \\\\ x_{32} & y_{23} & x_{13} & y_{31} & x_{21} & y_{12} \\end{pmatrix} $$\n其中 $(x_i, y_i)$ 是单元节点的坐标，$A_e$ 是其面积。积分为：\n$$ k_e^{\\text{CST}} = \\mathbf{B}_{\\text{CST}}^T \\mathbf{D}_{\\text{ps}} \\mathbf{B}_{\\text{CST}} A_e t $$\n\n**二次应变三角形 (LST)**\nLST 单元在具有局部坐标 $(\\xi, \\eta)$ 的参考单元上使用二次形函数 $N_i(\\xi, \\eta)$。等参映射将全局坐标 $(x,y)$ 与局部坐标关联起来：$x = \\sum N_i x_i$, $y = \\sum N_i y_i$。形函数对全局坐标的导数通过此映射的雅可比矩阵 $J$ 求得：\n$$ \\begin{pmatrix} \\partial N_i / \\partial x \\\\ \\partial N_i / \\partial y \\end{pmatrix} = J^{-1} \\begin{pmatrix} \\partial N_i / \\partial \\xi \\\\ \\partial N_i / \\partial \\eta \\end{pmatrix} $$\n现在，$\\mathbf{B}$ 矩阵是 $(\\xi, \\eta)$ 的函数。对于六个节点中的每一个节点 $i$，B 矩阵中对应的块是 $\\mathbf{B}_i = \\begin{pmatrix} \\partial N_i/\\partial x & 0 \\\\ 0 & \\partial N_i/\\partial y \\\\ \\partial N_i/\\partial y & \\partial N_i/\\partial x \\end{pmatrix}$。单元刚度矩阵需要数值积分，通常使用高斯求积。对于网格生成器产生的二次单元几何形状，雅可比矩阵是常数，被积函数 $\\mathbf{B}^T \\mathbf{D}_{\\text{ps}} \\mathbf{B}$ 是 $(\\xi, \\eta)$ 的二次多项式。因此，一个 3 点求积法则足以进行精确积分。\n$$ k_e^{\\text{LST}} = t \\int_{A_{ref}} \\mathbf{B}(\\xi,\\eta)^T \\mathbf{D}_{\\text{ps}} \\mathbf{B}(\\xi,\\eta) \\det(J) \\, d\\xi d\\eta \\approx t \\sum_{q=1}^{3} w_q \\left[ \\mathbf{B}(\\xi_q, \\eta_q)^T \\mathbf{D}_{\\text{ps}} \\mathbf{B}(\\xi_q, \\eta_q) \\det(J) \\right] $$\n其中 $(\\xi_q, \\eta_q)$ 和 $w_q$ 是求积点和权重。\n\n**3. 系统组装与求解**\n\n全局刚度矩阵 $K$ 和力向量 $F$ 初始化为零。然后，代码遍历每个单元，计算其 $k_e$，并根据单元的全局节点索引将其组装到 $K$ 中的适当位置。\n\n**边界条件**\n-   **自然（面力）边界条件**：通过在边界边上对形函数进行积分，将均匀压缩面力 $\\mathbf{t}=-p_0\\mathbf{n}$ 转换为一致节点力。对于长度为 $\\ell$ 的线性边，力以 $[\\ell/2, \\ell/2]$ 的比例分配给节点。对于二次边，分布为 $[\\ell/6, 2\\ell/3, \\ell/6]$。这些节点力被添加到全局力向量 $F$ 中。\n-   **本质（位移）边界条件**：为消除刚体运动，固定位移：节点 $(0,0)$ 处的位移为 $(u,v)=(0,0)$，节点 $(1,0)$ 处的位移为 $u=0$。这通过修改全局系统来强制执行。将 $K$ 中对应于固定自由度（DOFs）的行和列清零，在对角线上放置一个 $1$（$K_{ii}=1$），并将 $F$ 中的相应条目设置为规定的位移值（$F_i=0$）。\n\n然后使用直接求解器求解所得系统 $K\\mathbf{d}=F$，以获得全局位移向量 $\\mathbf{d}$。\n\n**4. 后处理与体积模量计算**\n\n数值静水体积模量 $K_h$ 定义为面积平均静水平均应力 $\\overline{p}$ 与面积平均体积应变的负值 $-\\overline{\\varepsilon}_v$ 之比。\n$$ K_h = \\frac{\\overline{p}}{-\\overline{\\varepsilon}_v} $$\n面积平均量计算如下：\n$$ \\overline{p} = \\frac{1}{A_{total}} \\sum_e \\int_{A_e} p(x,y) \\, dA \\quad \\text{and} \\quad \\overline{\\varepsilon}_v = \\frac{1}{A_{total}} \\sum_e \\int_{A_e} \\varepsilon_v(x,y) \\, dA $$\n对于每个单元，从节点位移中找到局部应变（$\\boldsymbol{\\varepsilon} = \\mathbf{B}\\mathbf{d}_e$）。然后根据本构关系计算应力。使用平面应变条件恢复平面外应力：$\\sigma_{zz} = \\nu(\\sigma_{xx} + \\sigma_{yy})$。计算静水应力 $p = -(\\sigma_{xx} + \\sigma_{yy} + \\sigma_{zz})/3$ 和体积应变 $\\varepsilon_v = \\varepsilon_{xx} + \\varepsilon_{yy}$。在每个单元上对积分进行数值计算（对于 CST 是精确的，对于 LST 通过 3 点求积）并求和。最终值 $K_h$ 转换为兆帕（MPa）。\n\n所提供的 Python 代码实现了这整个过程。其结构用于处理指定的测试用例，比较 CST 和 LST 单元在中等和近不可压缩泊松比值下的性能。正如理论所预期的，结果将证明 LST 单元在避免 $\\nu \\approx 0.5$ 时的体积自锁方面具有优越的性能。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the FEM simulations for the specified test cases\n    and print the results in the required format.\n    \"\"\"\n    \n    class LagrangeTriangle:\n        \"\"\"Shape functions and derivatives for a 6-node quadratic triangle.\"\"\"\n        QUAD_POINTS = np.array([[1/6, 1/6], [2/3, 1/6], [1/6, 2/3]])\n        QUAD_WEIGHTS = np.array([1/6, 1/6, 1/6])\n\n        @staticmethod\n        def shape_derivatives(xi, eta):\n            \"\"\"Derivatives of N w.r.t. xi and eta.\"\"\"\n            L1, L2, L3 = 1.0 - xi - eta, xi, eta\n            dN_dxi = np.array([\n                -4 * L1 + 1,\n                 4 * L2 - 1,\n                 0,\n                 4 * (L1 - L2),\n                 4 * L3,\n                -4 * L3\n            ])\n            dN_deta = np.array([\n                -4 * L1 + 1,\n                 0,\n                 4 * L3 - 1,\n                -4 * L2,\n                 4 * L2,\n                 4 * (L1 - L3)\n            ])\n            return np.vstack((dN_dxi, dN_deta)).T\n\n    def run_fem_simulation(elem_type, Nx, Ny, nu):\n        \"\"\"Core FEM solver for a given set of parameters.\"\"\"\n        E = 100e6  # Pa\n        p0 = 1e6   # Pa\n        L = 1.0    # m\n        t = 1.0    # m\n\n        # 1. Mesh Generation\n        if elem_type == 'CST':\n            num_nodes_x, num_nodes_y = Nx + 1, Ny + 1\n            node_pitch_x = L / Nx\n            node_pitch_y = L / Ny\n        else: # LST\n            num_nodes_x, num_nodes_y = 2 * Nx + 1, 2 * Ny + 1\n            node_pitch_x = L / (2 * Nx)\n            node_pitch_y = L / (2 * Ny)\n\n        num_nodes = num_nodes_x * num_nodes_y\n        nodes = np.array([[i * node_pitch_x, j * node_pitch_y]\n                          for j in range(num_nodes_y) for i in range(num_nodes_x)])\n\n        num_elements = 2 * Nx * Ny\n        if elem_type == 'CST':\n            elements = np.zeros((num_elements, 3), dtype=int)\n        else: # LST\n            elements = np.zeros((num_elements, 6), dtype=int)\n\n        elem_idx = 0\n        for j in range(Ny):\n            for i in range(Nx):\n                if elem_type == 'CST':\n                    n1 = j * num_nodes_x + i\n                    n2 = j * num_nodes_x + i + 1\n                    n3 = (j + 1) * num_nodes_x + i + 1\n                    n4 = (j + 1) * num_nodes_x + i\n                    elements[elem_idx] = [n1, n2, n3]\n                    elements[elem_idx + 1] = [n1, n3, n4]\n                else: # LST\n                    # Tri 1: BL, BR, TR\n                    bl, br, tr, tl = (2*j)*num_nodes_x + (2*i), (2*j)*num_nodes_x + (2*i+2), (2*j+2)*num_nodes_x + (2*i+2), (2*j+2)*num_nodes_x + (2*i)\n                    mid_b, mid_r, mid_t, mid_l = (2*j)*num_nodes_x + (2*i+1), (2*j+1)*num_nodes_x + (2*i+2), (2*j+2)*num_nodes_x + (2*i+1), (2*j+1)*num_nodes_x + (2*i)\n                    mid_diag = (2*j+1)*num_nodes_x + (2*i+1)\n                    elements[elem_idx] = [bl, br, tr, mid_b, mid_r, mid_diag]\n                    elements[elem_idx + 1] = [bl, tr, tl, mid_diag, mid_t, mid_l]\n                elem_idx += 2\n\n        # 2. Assembly\n        num_dofs = 2 * num_nodes\n        K = np.zeros((num_dofs, num_dofs))\n        D_ps = (E / ((1 + nu) * (1 - 2 * nu))) * np.array([[1 - nu, nu, 0], [nu, 1 - nu, 0], [0, 0, (1 - 2 * nu) / 2]])\n\n        for el_nodes_idx in elements:\n            el_nodes_coords = nodes[el_nodes_idx]\n            dofs = np.array([[2 * n, 2 * n + 1] for n in el_nodes_idx]).ravel()\n            \n            if elem_type == 'CST':\n                c = el_nodes_coords\n                area = 0.5 * np.linalg.det(np.array([[1, c[0,0], c[0,1]], [1, c[1,0], c[1,1]], [1, c[2,0], c[2,1]]]))\n                y23, y31, y12 = c[1,1]-c[2,1], c[2,1]-c[0,1], c[0,1]-c[1,1]\n                x32, x13, x21 = c[2,0]-c[1,0], c[0,0]-c[2,0], c[1,0]-c[0,0]\n                B = (1/(2*area)) * np.array([[y23,0,y31,0,y12,0], [0,x32,0,x13,0,x21], [x32,y23,x13,y31,x21,y12]])\n                Ke = B.T @ D_ps @ B * area * t\n            else: # LST\n                Ke = np.zeros((12, 12))\n                for i in range(len(LagrangeTriangle.QUAD_POINTS)):\n                    xi, eta = LagrangeTriangle.QUAD_POINTS[i]\n                    dN_dxi_eta = LagrangeTriangle.shape_derivatives(xi, eta)\n                    J = dN_dxi_eta.T @ el_nodes_coords\n                    detJ = np.linalg.det(J)\n                    invJ = np.linalg.inv(J)\n                    dN_dxy = invJ @ dN_dxi_eta.T\n                    \n                    B = np.zeros((3, 12))\n                    for node_i in range(6):\n                        B[0, 2*node_i], B[1, 2*node_i+1] = dN_dxy[0, node_i], dN_dxy[1, node_i]\n                        B[2, 2*node_i], B[2, 2*node_i+1] = dN_dxy[1, node_i], dN_dxy[0, node_i]\n                    Ke += B.T @ D_ps @ B * detJ * LagrangeTriangle.QUAD_WEIGHTS[i] * t\n            K[np.ix_(dofs, dofs)] += Ke\n            \n        # 3. Boundary forces\n        F = np.zeros(num_dofs)\n        hx, hy = L/Nx, L/Ny\n        \n        for i in range(Nx): # Bottom (y=0, t=(0,p0)), Top (y=L, t=(0,-p0))\n            if elem_type == 'CST':\n                nodes_b = [i, i+1];                  nodes_t = [Ny*num_nodes_x+i, Ny*num_nodes_x+i+1]\n                w = [hx/2, hx/2]\n            else:\n                nodes_b = [2*i, 2*i+2, 2*i+1];     nodes_t = [(2*Ny)*num_nodes_x+2*i, (2*Ny)*num_nodes_x+2*i+2, (2*Ny)*num_nodes_x+2*i+1]\n                w = [hx/6, hx/6, 2*hx/3]\n            for n_idx, weight in zip(nodes_b, w): F[2*n_idx+1] += p0 * weight * t\n            for n_idx, weight in zip(nodes_t, w): F[2*n_idx+1] -= p0 * weight * t\n        \n        for j in range(Ny): # Left (x=0, t=(p0,0)), Right (x=L, t=(-p0,0))\n            if elem_type == 'CST':\n                nodes_l = [j*num_nodes_x, (j+1)*num_nodes_x]; nodes_r = [j*num_nodes_x+Nx, (j+1)*num_nodes_x+Nx]\n                w = [hy/2, hy/2]\n            else:\n                nodes_l = [(2*j)*num_nodes_x, (2*j+2)*num_nodes_x, (2*j+1)*num_nodes_x]; nodes_r = [(2*j)*num_nodes_x+2*Nx, (2*j+2)*num_nodes_x+2*Nx, (2*j+1)*num_nodes_x+2*Nx]\n                w = [hy/6, hy/6, 2*hy/3]\n            for n_idx, weight in zip(nodes_l, w): F[2*n_idx] += p0 * weight * t\n            for n_idx, weight in zip(nodes_r, w): F[2*n_idx] -= p0 * weight * t\n\n        # 4. Displacement BCs\n        fixed_dofs = [0, 1] \n        fixed_dofs.append(2 * (Nx if elem_type == 'CST' else 2*Nx)) # u at (1,0)\n        for dof in fixed_dofs:\n            K[dof, :], K[:, dof], F[dof] = 0, 0, 0\n            K[dof, dof] = 1\n\n        # 5. Solve\n        displacements = np.linalg.solve(K, F)\n\n        # 6. Post-processing\n        total_p_integral, total_ev_integral = 0, 0\n        for el_nodes_idx in elements:\n            el_nodes_coords = nodes[el_nodes_idx]\n            dofs = np.array([[2 * n, 2 * n + 1] for n in el_nodes_idx]).ravel()\n            el_disps = displacements[dofs]\n\n            if elem_type == 'CST':\n                c = el_nodes_coords\n                area = 0.5 * abs(np.linalg.det(np.array([[1, c[0,0], c[0,1]], [1, c[1,0], c[1,1]], [1, c[2,0], c[2,1]]])))\n                y23, y31, y12 = c[1,1]-c[2,1], c[2,1]-c[0,1], c[0,1]-c[1,1]\n                x32, x13, x21 = c[2,0]-c[1,0], c[0,0]-c[2,0], c[1,0]-c[0,0]\n                B = (1/(2*area)) * np.array([[y23,0,y31,0,y12,0], [0,x32,0,x13,0,x21], [x32,y23,x13,y31,x21,y12]])\n                strain = B @ el_disps\n                eps_xx, eps_yy = strain[0], strain[1]\n                stress_xy = D_ps @ strain\n                sig_xx, sig_yy = stress_xy[0], stress_xy[1]\n                sig_zz = nu * (sig_xx + sig_yy)\n                p = -1/3 * (sig_xx + sig_yy + sig_zz)\n                ev = eps_xx + eps_yy\n                total_p_integral += p * area\n                total_ev_integral += ev * area\n            else: # LST\n                for i in range(len(LagrangeTriangle.QUAD_POINTS)):\n                    xi, eta = LagrangeTriangle.QUAD_POINTS[i]\n                    dN_dxi_eta = LagrangeTriangle.shape_derivatives(xi, eta)\n                    J = dN_dxi_eta.T @ el_nodes_coords\n                    detJ = np.linalg.det(J)\n                    invJ = np.linalg.inv(J)\n                    dN_dxy = invJ @ dN_dxi_eta.T\n                    \n                    B = np.zeros((3, 12))\n                    for node_i in range(6):\n                        B[0, 2*node_i], B[1, 2*node_i+1] = dN_dxy[0, node_i], dN_dxy[1, node_i]\n                        B[2, 2*node_i], B[2, 2*node_i+1] = dN_dxy[1, node_i], dN_dxy[0, node_i]\n\n                    strain = B @ el_disps\n                    eps_xx, eps_yy = strain[0], strain[1]\n                    stress_xy = D_ps @ strain\n                    sig_xx, sig_yy = stress_xy[0], stress_xy[1]\n                    sig_zz = nu * (sig_xx + sig_yy)\n                    p, ev = -1/3 * (sig_xx + sig_yy + sig_zz), eps_xx + eps_yy\n                    integral_weight = detJ * LagrangeTriangle.QUAD_WEIGHTS[i]\n                    total_p_integral += p * integral_weight\n                    total_ev_integral += ev * integral_weight\n\n        avg_p, avg_ev = total_p_integral / (L*L), total_ev_integral / (L*L)\n        \n        K_h = avg_p / (-avg_ev) if avg_ev < 0 else np.nan\n        return K_h / 1e6 # Return in MPa\n\n    test_cases = [\n        ('CST', 8, 8, 0.25),\n        ('LST', 8, 8, 0.25),\n        ('CST', 8, 8, 0.49),\n        ('LST', 8, 8, 0.49),\n    ]\n\n    results = []\n    for case in test_cases:\n        elem_type, Nx, Ny, nu = case\n        result = run_fem_simulation(elem_type, Nx, Ny, nu)\n        results.append(result)\n    \n    results_str = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "如果我们能够提升简单、计算成本低的单元的性能，使其媲美高阶单元，那将如何？本练习将向您介绍基于边的平滑有限元法（Edge-based Smoothed Finite Element Method, ES-FEM），这是一种旨在“软化”常应变三角形（CST）单元过刚行为的先进技术。通过实施ES-FEM并将其结果与标准CST在近乎不可压缩材料问题中的表现进行对比，您将亲身体验一种能够有效缓解体积锁定并提高应力精度的强大方法，从而展示一种开发稳健有限元的现代思路。",
            "id": "3569108",
            "problem": "实现一个完整的程序，用于在平面应变条件下，比较恒应变三角形 (CST) 有限元法与基于边的光滑有限元法 (ES-FEM) 在处理近乎不可压缩黏土问题上的表现。您的程序必须在相同的网格上为两种方法组装全局刚度矩阵，在给定的位移边界条件下求解位移，并定量比较表观水平刚度和应力精度度量。\n\n您必须根据计算岩土力学中适用于三角形单元的基本原理来推导您的实现，如下所示。\n\n- 使用虚功原理，对于线性弹性体，在没有体力的情况下，该原理指出，对于所有运动学容许的虚位移，内虚功等于外虚功。在其离散形式中，这会导出一个对称正定的全局刚度系统。\n- 采用平面应变线性弹性本构律。对于杨氏模量 $E$ 和泊松比 $\\nu$，应力-应变关系是线性的，其本构矩阵取决于 $E$ 和 $\\nu$。\n- 对于CST，在每个三角形单元内使用恒应变近似，形函数的梯度在每个单元上为常数。通过对单元贡献求和来组装全局刚度矩阵。\n- 对于ES-FEM（基于边的光滑有限元法），将基于边的光滑域定义为共享一条内部边的两个相邻三角形的并集（对于边界边，则为单个三角形）。在每个光滑域 $\\Omega_{S}$ 上，通过将散度定理应用于三角形并集域，对形函数的梯度进行平滑化，从而定义平滑应变：\n  - 节点形函数 $N_{i}$ 在光滑域 $\\Omega_{S}$ 上的平滑梯度为\n    $$\\nabla \\tilde{N}_{i} = \\frac{1}{A_{S}} \\int_{\\Omega_{S}} \\nabla N_{i} \\, \\mathrm{d}\\Omega,$$\n    对于每个三角形上分段常数的 $\\nabla N_{i}$，这成为相邻单元上梯度的面积加权平均值。这里 $A_{S}$ 表示 $\\Omega_{S}$ 的面积。\n  - 通过将 $\\nabla \\tilde{N}_{i}$ 的分量排列成标准的平面应变形式，在 $\\Omega_{S}$ 上构建平滑的 $B$ 矩阵，并组装光滑域的刚度贡献\n    $$\\mathbf{K}_{S} = \\int_{\\Omega_{S}} \\mathbf{B}_{S}^{\\top} \\mathbf{D} \\mathbf{B}_{S} \\, \\mathrm{d}\\Omega \\approx A_{S} \\, \\mathbf{B}_{S}^{\\top} \\mathbf{D} \\mathbf{B}_{S},$$\n    然后对所有边求和，得到 ES-FEM 的全局刚度矩阵。\n\n为确保问题适定且可进行解析基准测试，采用以下几何、加载和边界条件：\n\n- 考虑一个宽度为 $W$、高度为 $H$ 的矩形域，处于平面应变状态，单位厚度。将其离散化为 $N_{x} \\times N_{y}$ 个节点的结构化网格，并通过一致的对角线将每个矩形单元分割成两个三角形。所有坐标均采用一致的长度单位。\n- 施加本质（Dirichlet）边界条件：在左边界 $x=0$ 上，强制 $u_{x} = 0$ 和 $u_{y} = 0$；在右边界 $x = W$ 上，强制 $u_{x} = u_{0}$ 和 $u_{y} = 0$。不施加任何面力或体力。这将产生一个均匀的精确解，其轴向应变为 $\\varepsilon_{x} = u_{0}/W$，$\\varepsilon_{y} = 0$，且 $\\gamma_{xy} = 0$。\n- 使用具有模量 $E$ 和泊松比 $\\nu$ 的平面应变本构矩阵。与精确均匀应变对应的精确均匀应力为 $\\boldsymbol{\\sigma}_{\\mathrm{exact}} = \\mathbf{D} \\, [u_{0}/W, 0, 0]^{\\top}$，其精确轴向应力为 $\\sigma_{x,\\mathrm{exact}} = D_{11} \\, (u_{0}/W)$，其中 $D_{11}$ 是平面应变本构矩阵 $\\mathbf{D}$ 的第一个对角线元素。\n- 将表观水平刚度 $K_{h}$ 定义为右边界上总水平反力与施加位移 $u_{0}$ 的比值。对于此设置，其精确值为\n  $$K_{h,\\mathrm{exact}} = D_{11} \\, \\frac{H}{W}.$$\n\n需要实现的数值任务：\n\n1. 网格生成：\n   - 为矩形域 $[0,W] \\times [0,H]$ 生成节点坐标和三角形连接关系，该域具有 $N_{x} \\times N_{y}$ 个节点，并将每个单元以一致的方向分割成两个三角形。\n2. CST 组装：\n   - 对每个三角形，计算面积 $A_{e}$ 和由形函数梯度得出的恒应变矩阵 $\\mathbf{B}_{e}$，组装 $\\mathbf{K}^{\\mathrm{CST}}$。\n3. ES-FEM 组装：\n   - 枚举所有边并找到其相邻的三角形。对于每个基于边的光滑域 $\\Omega_{S}$，计算平滑梯度 $\\nabla \\tilde{N}_{i}$ 作为相邻三角形上单元梯度的面积加权平均值。构建 $\\mathbf{B}_{S}$，组装 $\\mathbf{K}^{\\mathrm{ES}} = \\sum_{S} A_{S} \\, \\mathbf{B}_{S}^{\\top} \\mathbf{D} \\mathbf{B}_{S}$。\n4. 施加边界条件并求解：\n   - 构建右侧向量为零。施加本质边界条件并求解线性系统以获得 $\\mathbf{K}^{\\mathrm{CST}}$ 和 $\\mathbf{K}^{\\mathrm{ES}}$ 的位移。\n   - 通过 $\\mathbf{r} = \\mathbf{K} \\mathbf{u}$ 恢复反力；对每种方法，将右边界节点的水平反力求和以获得 $R_{x}$。\n   - 对每种方法，计算 $K_{h} = R_{x}/u_{0}$。\n5. 应力计算和误差度量：\n   - 对每个三角形单元，使用该方法的位移场和单元的 CST $\\mathbf{B}_{e}$ 矩阵计算恒定应变 $\\boldsymbol{\\varepsilon}_{e}$ 和应力 $\\boldsymbol{\\sigma}_{e}$。使用轴向应力分量 $\\sigma_{x,e}$。\n   - 使用以下公式计算域上的 $L^{2}$ 型相对误差\n     $$e_{\\sigma} = \\frac{\\left(\\sum_{e} A_{e}\\,(\\sigma_{x,e} - \\sigma_{x,\\mathrm{exact}})^{2}\\right)^{1/2}}{\\left(|\\sigma_{x,\\mathrm{exact}}| \\, \\sqrt{\\sum_{e} A_{e}}\\right)}.$$\n\n测试套件和输出：\n\n- 使用以下给定参数的测试用例：\n  - 用例 1（理想情况）：$W=1.0$, $H=1.0$, $N_{x}=4$, $N_{y}=4$, $E=1000.0$, $\\nu=0.3$, $u_{0}=0.001$。\n  - 用例 2（近乎不可压缩，粗网格）：$W=1.0$, $H=1.0$, $N_{x}=4$, $N_{y}=4$, $E=1000.0$, $\\nu=0.4999$, $u_{0}=0.001$。\n  - 用例 3（近乎不可压缩，细网格）：$W=1.0$, $H=1.0$, $N_{x}=10$, $N_{y}=10$, $E=1000.0$, $\\nu=0.4999$, $u_{0}=0.001$。\n- 对每个用例，计算：\n  - CST 和 ES-FEM 的表观水平刚度相对误差：\n    $$\\mathrm{err}_{K}^{\\mathrm{CST}} = \\left|\\frac{K_{h}^{\\mathrm{CST}} - K_{h,\\mathrm{exact}}}{K_{h,\\mathrm{exact}}}\\right|, \\quad \\mathrm{err}_{K}^{\\mathrm{ES}} = \\left|\\frac{K_{h}^{\\mathrm{ES}} - K_{h,\\mathrm{exact}}}{K_{h,\\mathrm{exact}}}\\right|.$$\n  - CST 和 ES-FEM 的轴向应力 $\\sigma_{x}$ 的相对 $L^{2}$ 误差，记为 $\\mathrm{err}_{\\sigma}^{\\mathrm{CST}}$ 和 $\\mathrm{err}_{\\sigma}^{\\mathrm{ES}}$，使用每种方法的位移场按照上述 $e_{\\sigma}$ 的公式计算。\n- 最终输出格式：\n  - 您的程序应生成一行输出，包含用方括号括起来的逗号分隔的结果列表。对每个用例，按顺序输出四个浮点数\n    $[\\mathrm{err}_{K}^{\\mathrm{CST}}, \\mathrm{err}_{K}^{\\mathrm{ES}}, \\mathrm{err}_{\\sigma}^{\\mathrm{CST}}, \\mathrm{err}_{\\sigma}^{\\mathrm{ES}}]$，\n    并将三个用例的结果连接成一个包含十二个数字的扁平列表。例如，一个语法上有效的输出应类似于\n    $$[\\alpha_{1},\\beta_{1},\\gamma_{1},\\delta_{1},\\alpha_{2},\\beta_{2},\\gamma_{2},\\delta_{2},\\alpha_{3},\\beta_{3},\\gamma_{3},\\delta_{3}],$$\n    其中每个符号表示一个浮点值。输出中不需要单位，因为所有报告的量都是无量纲的相对误差。",
            "solution": "该问题要求实现并比较恒应变三角形（CST）和基于边的光滑有限元法（ES-FEM）在一个平面应变线性弹性问题中的表现，特别关注近乎不可压缩的材料。验证证实了该问题是适定的、有科学依据的，并且在计算上是可行的。我们从第一性原理出发进行求解。\n\n源自虚功原理的静态线性弹性控制方程是一个线性方程组 $\\mathbf{K}\\mathbf{u} = \\mathbf{f}$，其中 $\\mathbf{K}$ 是全局刚度矩阵，$\\mathbf{u}$ 是节点位移向量，$\\mathbf{f}$ 是节点力向量。在此问题中，不存在外部体力或表面面力，因此初始力向量 $\\mathbf{f}$ 为零；由于给定的位移边界条件，最终方程组的右侧将出现非零力。\n\n材料行为由平面应变的线性弹性本构律 $\\boldsymbol{\\sigma} = \\mathbf{D}\\boldsymbol{\\varepsilon}$ 控制，其中 $\\boldsymbol{\\sigma} = [\\sigma_{xx}, \\sigma_{yy}, \\tau_{xy}]^\\top$ 是应力向量，$\\boldsymbol{\\varepsilon} = [\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}]^\\top$ 是工程应变向量。本构矩阵 $\\mathbf{D}$ 由下式给出：\n$$\n\\mathbf{D} = \\frac{E}{(1+\\nu)(1-2\\nu)}\n\\begin{pmatrix}\n1-\\nu & \\nu & 0 \\\\\n\\nu & 1-\\nu & 0 \\\\\n0 & 0 & \\frac{1-2\\nu}{2}\n\\end{pmatrix}\n$$\n其中 $E$ 是杨氏模量，$\\nu$ 是泊松比。\n\n单元内的位移场 $\\mathbf{u}(x,y)$ 通过形函数 $\\mathbf{N}$ 从节点位移 $\\mathbf{u}_e$ 插值得到：$\\mathbf{u}(x,y) = \\mathbf{N}(x,y) \\mathbf{u}_e$。应变通过微分算子 $\\boldsymbol{\\partial}$ 从位移导出，即 $\\boldsymbol{\\varepsilon} = \\boldsymbol{\\partial} \\mathbf{u} = (\\boldsymbol{\\partial} \\mathbf{N}) \\mathbf{u}_e = \\mathbf{B} \\mathbf{u}_e$。矩阵 $\\mathbf{B}$ 是应变-位移矩阵。\n\n**网格生成**\n为一个矩形域 $[0, W] \\times [0, H]$ 生成具有 $N_x \\times N_y$ 个节点的结构化网格。节点按行索引。由四个相邻节点形成的每个矩形单元通过一致的对角线被划分为两个三角形单元，确保了结构良好且可重复的离散化。\n\n**恒应变三角形 (CST) 公式**\n对于一个三节点三角形单元，形函数 $N_i$ 是空间坐标的线性函数。因此，它们的梯度在单元内是恒定的。单元 $e$ 的应变-位移矩阵 $\\mathbf{B}_e$ 是常数，由形函数的梯度导出。对于一个节点按逆时针顺序排列为 $(x_1, y_1), (x_2, y_2), (x_3, y_3)$ 且面积为 $A_e$ 的单元，$\\mathbf{B}_e$ 为：\n$$\n\\mathbf{B}_e = \\frac{1}{2A_e}\n\\begin{pmatrix}\ny_2-y_3 & 0 & y_3-y_1 & 0 & y_1-y_2 & 0 \\\\\n0 & x_3-x_2 & 0 & x_1-x_3 & 0 & x_2-x_1 \\\\\nx_3-x_2 & y_2-y_3 & x_1-x_3 & y_3-y_1 & x_2-x_1 & y_1-y_2\n\\end{pmatrix}\n$$\n单元刚度矩阵 $\\mathbf{K}_e$ 通过在单元体积（二维中为面积，单位厚度）上积分计算得出：\n$$\n\\mathbf{K}_e = \\int_{\\Omega_e} \\mathbf{B}_e^\\top \\mathbf{D} \\mathbf{B}_e \\, \\mathrm{d}\\Omega = A_e \\mathbf{B}_e^\\top \\mathbf{D} \\mathbf{B}_e\n$$\n全局刚度矩阵 $\\mathbf{K}^{\\mathrm{CST}}$ 通过将所有单元的贡献相加来组装，将局部自由度（DOF）映射到其相应的全局自由度。\n\n**基于边的光滑有限元法 (ES-FEM) 公式**\nES-FEM旨在软化CST单元的过刚行为，尤其是在近乎不可压缩的情况下（$\\nu \\to 0.5$）。这是通过创建与网格的每条边相关联的光滑域 $\\Omega_S$ 来实现的。一条内部边被两个三角形共享，因此其光滑域是这两个三角形的并集。一条边界边仅属于一个三角形，该三角形即构成其光滑域。\n\n在每个面积为 $A_S$ 的光滑域 $\\Omega_S$ 内，形函数 $N_i$ 的平滑梯度被定义为其标准（分段常数）梯度在组成三角形上的面积加权平均值：\n$$\n\\nabla \\tilde{N}_{i} = \\frac{1}{A_{S}} \\int_{\\Omega_{S}} \\nabla N_{i} \\, \\mathrm{d}\\Omega = \\frac{1}{A_S} \\sum_{e \\in \\Omega_S} A_e (\\nabla N_{i})|_{\\Omega_e}\n$$\n这些平滑梯度用于为属于该光滑域的节点集构建一个平滑的应变-位移矩阵 $\\mathbf{B}_S$。然后，该光滑域的刚度贡献 $\\mathbf{K}_S$ 计算如下：\n$$\n\\mathbf{K}_S = \\int_{\\Omega_S} \\mathbf{B}_S^\\top \\mathbf{D} \\mathbf{B}_S \\, \\mathrm{d}\\Omega \\approx A_S \\mathbf{B}_S^\\top \\mathbf{D} \\mathbf{B}_S\n$$\n全局刚度矩阵 $\\mathbf{K}^{\\mathrm{ES}}$ 通过将网格中所有光滑域（即所有边）的刚度贡献 $\\mathbf{K}_S$ 相加来组装。\n\n**边界条件和求解**\n该问题涉及在左边界（$x=0$）和右边界（$x=W$）上施加指定位移。这通过将全局方程组 $\\mathbf{K}\\mathbf{u}=\\mathbf{f}$ 划分为自由自由度和约束自由度来处理：\n$$\n\\begin{pmatrix} \\mathbf{K}_{ff} & \\mathbf{K}_{fc} \\\\ \\mathbf{K}_{cf} & \\mathbf{K}_{cc} \\end{pmatrix} \\begin{pmatrix} \\mathbf{u}_f \\\\ \\mathbf{u}_c \\end{pmatrix} = \\begin{pmatrix} \\mathbf{f}_f \\\\ \\mathbf{f}_c \\end{pmatrix}\n$$\n在没有外力的情况下，$\\mathbf{f}_f = \\mathbf{0}$。未知位移 $\\mathbf{u}_f$ 通过求解简化系统得到：\n$$\n\\mathbf{K}_{ff} \\mathbf{u}_f = -\\mathbf{K}_{fc} \\mathbf{u}_c\n$$\n其中 $\\mathbf{u}_c$ 是已知的指定位移向量。求解出 $\\mathbf{u}_f$ 后，构建完整的位移向量 $\\mathbf{u}$。然后计算反作用力 $\\mathbf{r} = \\mathbf{K}\\mathbf{u}$。\n\n**结果分析**\n每种方法的性能通过两个度量进行评估：\n\n1.  **表观水平刚度 ($K_h$)**：这个全局度量是右边界上的总水平反力除以施加的位移 $u_0$。相对误差为 $|(K_h - K_{h,\\mathrm{exact}})/K_{h,\\mathrm{exact}}|$，其中 $K_{h,\\mathrm{exact}} = D_{11} H/W$。\n\n2.  **应力精度 ($e_\\sigma$)**：这个局部度量衡量计算出的轴向应力 $\\sigma_{x,e}$ 与精确均匀应力 $\\sigma_{x,\\mathrm{exact}} = D_{11} u_0/W$ 的偏差。每个单元的应力 $\\sigma_{x,e}$ 使用其标准的 CST $\\mathbf{B}_e$ 矩阵和从相应全局解（CST 或 ES-FEM）获得的节点位移来计算。$L^2$ 型相对误差为：\n    $$\n    e_{\\sigma} = \\frac{\\left(\\sum_{e} A_{e}\\,(\\sigma_{x,e} - \\sigma_{x,\\mathrm{exact}})^{2}\\right)^{1/2}}{|\\sigma_{x,\\mathrm{exact}}| \\, \\sqrt{\\sum_{e} A_{e}}}\n    $$\n这些度量允许对闭锁行为进行定量比较。CST单元中的闭锁表现为过刚响应（$K_h \\gg K_{h,\\mathrm{exact}}$）和不准确的应力预测，尤其是在 $\\nu \\approx 0.5$ 时。预计ES-FEM在这些情况下会产生显著更低的误差。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Main driver function to run the FEM comparison for all test cases.\n    \"\"\"\n    test_cases = [\n        # W, H, Nx, Ny, E, nu, u0\n        (1.0, 1.0, 4, 4, 1000.0, 0.3, 0.001),\n        (1.0, 1.0, 4, 4, 1000.0, 0.4999, 0.001),\n        (1.0, 1.0, 10, 10, 1000.0, 0.4999, 0.001),\n    ]\n\n    all_results = []\n\n    for W, H, Nx, Ny, E, nu, u0 in test_cases:\n        # 1. Mesh Generation\n        nodes, elements = _generate_mesh(W, H, Nx, Ny)\n\n        # 2. Constitutive Matrix\n        D = _get_constitutive_matrix(E, nu)\n\n        # 3. Exact Solution values\n        D11 = D[0, 0]\n        K_exact = D11 * H / W\n        sigma_x_exact = D11 * u0 / W\n        \n        # Pre-compute element properties (area and B-matrix) to avoid recalculations\n        elem_props = [_get_element_properties(nodes[elem]) for elem in elements]\n\n        # 4. CST Analysis\n        K_cst = _assemble_stiffness_cst(nodes, elements, D, elem_props)\n        u_cst, r_cst = _solve_system(K_cst, nodes, W, H, Nx, Ny, u0)\n        err_K_cst, err_sigma_cst = _calculate_metrics(u_cst, r_cst, K_exact, sigma_x_exact,\n                                                      nodes, elements, D, W, H, u0, Nx, Ny, elem_props)\n\n        # 5. ES-FEM Analysis\n        K_esfem = _assemble_stiffness_esfem(nodes, elements, D, elem_props)\n        u_esfem, r_esfem = _solve_system(K_esfem, nodes, W, H, Nx, Ny, u0)\n        err_K_esfem, err_sigma_esfem = _calculate_metrics(u_esfem, r_esfem, K_exact, sigma_x_exact,\n                                                          nodes, elements, D, W, H, u0, Nx, Ny, elem_props)\n\n        all_results.extend([err_K_cst, err_K_esfem, err_sigma_cst, err_sigma_esfem])\n\n    # Final print statement\n    print(f\"[{','.join(f'{x:.7f}' for x in all_results)}]\")\n\ndef _generate_mesh(W, H, Nx, Ny):\n    \"\"\"Generates nodes and triangular element connectivity for a rectangular domain.\"\"\"\n    x = np.linspace(0, W, Nx)\n    y = np.linspace(0, H, Ny)\n    xv, yv = np.meshgrid(x, y)\n    nodes = np.vstack([xv.ravel(), yv.ravel()]).T\n    \n    elements = []\n    for j in range(Ny - 1):\n        for i in range(Nx - 1):\n            n_bl = j * Nx + i\n            n_br = j * Nx + i + 1\n            n_ul = (j + 1) * Nx + i\n            n_ur = (j + 1) * Nx + i + 1\n            # Consistent diagonal split\n            elements.append([n_bl, n_br, n_ur])\n            elements.append([n_bl, n_ur, n_ul])\n    return nodes, np.array(elements)\n\ndef _get_constitutive_matrix(E, nu):\n    \"\"\"Returns the plane strain constitutive matrix D.\"\"\"\n    factor = E / ((1 + nu) * (1 - 2 * nu))\n    return factor * np.array([\n        [1 - nu, nu, 0],\n        [nu, 1 - nu, 0],\n        [0, 0, (1 - 2 * nu) / 2]\n    ])\n\ndef _get_element_properties(node_coords_in):\n    \"\"\"Computes area and components for the B-matrix for one element.\"\"\"\n    node_coords = np.copy(node_coords_in)\n    (x1, y1), (x2, y2), (x3, y3) = node_coords\n    \n    # Ensure CCW ordering for positive area\n    area = 0.5 * ((x2 - x1)*(y3 - y1) - (x3 - x1)*(y2 - y1))\n    if area < 0: # Flip nodes if CW\n        node_coords[[1, 2]] = node_coords[[2, 1]]\n        area = -area\n\n    (x1, y1), (x2, y2), (x3, y3) = node_coords\n    b = np.array([y2 - y3, y3 - y1, y1 - y2])\n    c = np.array([x3 - x2, x1 - x3, x2 - x1])\n    \n    B = np.zeros((3, 6))\n    for i in range(3):\n        B[0, 2*i] = b[i]\n        B[1, 2*i+1] = c[i]\n        B[2, 2*i] = c[i]\n        B[2, 2*i+1] = b[i]\n    \n    B /= (2 * area)\n    return {'area': area, 'B': B}\n\ndef _assemble_stiffness_cst(nodes, elements, D, elem_props):\n    \"\"\"Assembles the global stiffness matrix for CST.\"\"\"\n    num_nodes = len(nodes)\n    K_global = np.zeros((2 * num_nodes, 2 * num_nodes))\n    \n    for i, elem in enumerate(elements):\n        props = elem_props[i]\n        A_e, B_e = props['area'], props['B']\n        \n        K_e = A_e * B_e.T @ D @ B_e\n        \n        dofs = np.array([[2*n, 2*n+1] for n in elem]).flatten()\n        ix_ = np.ix_(dofs, dofs)\n        K_global[ix_] += K_e\n        \n    return K_global\n\ndef _assemble_stiffness_esfem(nodes, elements, D, elem_props):\n    \"\"\"Assembles the global stiffness matrix for ES-FEM.\"\"\"\n    num_nodes = len(nodes)\n    K_global = np.zeros((2 * num_nodes, 2 * num_nodes))\n    \n    # Build edge-to-element mapping\n    edge_to_elements = {}\n    for i, elem in enumerate(elements):\n        for j in range(3):\n            n1, n2 = elem[j], elem[(j + 1) % 3]\n            edge = tuple(sorted((n1, n2)))\n            edge_to_elements.setdefault(edge, []).append(i)\n\n    # Iterate over each smoothing domain (edge)\n    for edge, adj_elem_indices in edge_to_elements.items():\n        domain_nodes = set()\n        domain_area = 0.0\n        for elem_idx in adj_elem_indices:\n            domain_nodes.update(elements[elem_idx])\n            domain_area += elem_props[elem_idx]['area']\n\n        sorted_domain_nodes = sorted(list(domain_nodes))\n        num_domain_nodes = len(sorted_domain_nodes)\n        \n        B_s = np.zeros((3, 2 * num_domain_nodes))\n        \n        # Compute smoothed gradient for each node in the domain\n        for i, node_k in enumerate(sorted_domain_nodes):\n            grad_N_k_sum = np.zeros(2) # [sum(A*dN/dx), sum(A*dN/dy)]\n            for elem_idx in adj_elem_indices:\n                elem_nodes = elements[elem_idx]\n                if node_k in elem_nodes:\n                    A_e = elem_props[elem_idx]['area']\n                    B_e = elem_props[elem_idx]['B']\n                    local_node_idx = list(elem_nodes).index(node_k)\n                    \n                    # dN/dx and dN/dy from B matrix\n                    dn_dx = B_e[0, 2*local_node_idx]\n                    dn_dy = B_e[1, 2*local_node_idx+1]\n                    \n                    grad_N_k_sum += A_e * np.array([dn_dx, dn_dy])\n            \n            smoothed_grad = grad_N_k_sum / domain_area\n            b_tilde_k, c_tilde_k = smoothed_grad[0], smoothed_grad[1]\n            \n            B_s[0, 2*i] = b_tilde_k\n            B_s[1, 2*i+1] = c_tilde_k\n            B_s[2, 2*i] = c_tilde_k\n            B_s[2, 2*i+1] = b_tilde_k\n\n        K_s = domain_area * B_s.T @ D @ B_s\n        \n        dofs = np.array([[2*n, 2*n+1] for n in sorted_domain_nodes]).flatten()\n        ix_ = np.ix_(dofs, dofs)\n        K_global[ix_] += K_s\n        \n    return K_global\n\ndef _solve_system(K, nodes, W, H, Nx, Ny, u0):\n    \"\"\"Applies BCs and solves the linear system.\"\"\"\n    num_nodes = len(nodes)\n    num_dofs = 2 * num_nodes\n    \n    # Identify constrained DOFs\n    left_nodes = [j * Nx for j in range(Ny)]\n    right_nodes = [j * Nx + (Nx - 1) for j in range(Ny)]\n    \n    constrained_dofs = []\n    prescribed_vals = []\n    \n    # Left boundary: u_x = 0, u_y = 0\n    for node_idx in left_nodes:\n        constrained_dofs.extend([2 * node_idx, 2 * node_idx + 1])\n        prescribed_vals.extend([0.0, 0.0])\n        \n    # Right boundary: u_x = u0, u_y = 0\n    for node_idx in right_nodes:\n        constrained_dofs.extend([2 * node_idx, 2 * node_idx + 1])\n        prescribed_vals.extend([u0, 0.0])\n    \n    u_c = np.array(prescribed_vals)\n    \n    all_dofs = np.arange(num_dofs)\n    free_dofs = np.setdiff1d(all_dofs, constrained_dofs)\n    \n    # Partitioning method to solve\n    K_ff = K[np.ix_(free_dofs, free_dofs)]\n    K_fc = K[np.ix_(free_dofs, constrained_dofs)]\n    \n    rhs = -K_fc @ u_c\n    \n    try:\n         u_f = linalg.solve(K_ff, rhs)\n    except linalg.LinAlgError:\n         # Fallback to pseudo-inverse for singular matrices (can happen with locking)\n         u_f = linalg.pinv(K_ff) @ rhs\n\n    u = np.zeros(num_dofs)\n    u[free_dofs] = u_f\n    u[constrained_dofs] = u_c\n    \n    # Calculate reaction forces\n    r = K @ u\n    \n    return u, r\n\ndef _calculate_metrics(u, r, K_exact, sigma_x_exact, nodes, elements, D, W, H, u0, Nx, Ny, elem_props):\n    \"\"\"Calculates apparent stiffness error and stress L2 error.\"\"\"\n    # 1. Apparent Stiffness Error\n    right_dofs_x = [2 * (j * Nx + (Nx - 1)) for j in range(Ny)]\n    R_x = np.sum(r[right_dofs_x])\n    K_h_fem = R_x / u0\n    err_K = np.abs((K_h_fem - K_exact) / K_exact)\n    \n    # 2. Stress Error\n    total_area = W * H\n    numerator_sum = 0.0\n    \n    for i, elem in enumerate(elements):\n        props = elem_props[i]\n        A_e, B_e = props['area'], props['B']\n        \n        dofs = np.array([[2*n, 2*n+1] for n in elem]).flatten()\n        u_e = u[dofs]\n        \n        eps_e = B_e @ u_e\n        sigma_e = D @ eps_e\n        sigma_x_e = sigma_e[0]\n        \n        numerator_sum += A_e * (sigma_x_e - sigma_x_exact)**2\n    \n    denominator = np.abs(sigma_x_exact) * np.sqrt(total_area) if np.abs(sigma_x_exact) > 1e-12 else 1.0\n    err_sigma = np.sqrt(numerator_sum) / denominator\n    \n    return err_K, err_sigma\n\nif __name__ == '__main__':\n    solve()\n\n```"
        }
    ]
}