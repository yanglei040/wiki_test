{
    "hands_on_practices": [
        {
            "introduction": "The defining characteristic of a rigid body motion is the absence of deformation. In continuum mechanics, this translates to a zero rate-of-deformation tensor, $\\boldsymbol{D}=\\boldsymbol{0}$. This exercise  provides a practical, computational method to verify if a given velocity field represents a rigid motion by numerically checking this fundamental condition and its direct consequences, such as zero divergence and spatially constant vorticity. It is an essential skill for validating simulation results and debugging numerical models.",
            "id": "3596983",
            "problem": "Design and implement a program that verifies whether a numerically sampled planar velocity (or displacement-per-unit-time) field represents a rigid body motion by testing three invariants derived from first principles: the vanishing of the rate-of-deformation tensor, the vanishing of the divergence, and the spatial constancy of the vorticity (curl). The program must construct several test fields on a uniform grid, compute numerical derivatives using finite differences, evaluate the invariants, and then decide per field whether it should be classified as rigid within a prescribed tolerance.\n\nThe fundamental base for the derivation is:\n- Newtonian kinematics and the definition of instantaneous velocity field $\\boldsymbol{v}(\\boldsymbol{x},t)$.\n- The velocity gradient $\\boldsymbol{L} := \\nabla \\boldsymbol{v}$, the rate-of-deformation tensor $\\boldsymbol{D} := \\dfrac{1}{2}\\left(\\boldsymbol{L} + \\boldsymbol{L}^{\\mathsf{T}}\\right)$, and the vorticity (curl) $\\boldsymbol{\\omega} := \\nabla \\times \\boldsymbol{v}$.\n- For a rigid body motion, the spatial velocity field has the form $\\boldsymbol{v}(\\boldsymbol{x}) = \\boldsymbol{c} + \\boldsymbol{\\Omega}\\,\\boldsymbol{x}$ with $\\boldsymbol{\\Omega}$ skew-symmetric, which implies the identities $\\boldsymbol{D} = \\boldsymbol{0}$ and $\\nabla \\cdot \\boldsymbol{v} = \\mathrm{tr}(\\boldsymbol{L}) = 0$, and yields spatially constant vorticity $\\boldsymbol{\\omega}$.\n\nYour program must:\n- Work in two spatial dimensions on a rectangular grid. Let the domain be $[-1,1]\\times[-0.9,0.9]$ with $N_x = 41$ points uniformly spaced in the $x$-direction and $N_y = 37$ points uniformly spaced in the $y$-direction. Thus the spacings are $\\Delta x = \\dfrac{2}{40} = 0.05$ and $\\Delta y = \\dfrac{1.8}{36} = 0.05$.\n- Represent the velocity field as $\\boldsymbol{v}(x,y) = \\left(v_x(x,y), v_y(x,y)\\right)$ sampled on the grid.\n- Compute numerical partial derivatives using finite differences:\n  - At interior grid points, use second-order central differences for $\\dfrac{\\partial (\\cdot)}{\\partial x}$ and $\\dfrac{\\partial (\\cdot)}{\\partial y}$.\n  - At boundary grid points, use first-order one-sided differences consistent with the grid spacing.\n- Assemble the velocity gradient $\\boldsymbol{L}(x,y)$ with entries $L_{11} = \\dfrac{\\partial v_x}{\\partial x}$, $L_{12} = \\dfrac{\\partial v_x}{\\partial y}$, $L_{21} = \\dfrac{\\partial v_y}{\\partial x}$, $L_{22} = \\dfrac{\\partial v_y}{\\partial y}$.\n- Form the rate-of-deformation tensor $\\boldsymbol{D} = \\dfrac{1}{2}\\left(\\boldsymbol{L} + \\boldsymbol{L}^{\\mathsf{T}}\\right)$ pointwise. For two dimensions, the Frobenius norm of $\\boldsymbol{D}$ at each grid point is $||\\boldsymbol{D}||_F = \\sqrt{D_{11}^2 + 2 D_{12}^2 + D_{22}^2}$.\n- Compute the divergence $\\nabla \\cdot \\boldsymbol{v} = L_{11} + L_{22}$ pointwise.\n- Compute the scalar out-of-plane vorticity (two-dimensional curl) $\\omega_z = \\dfrac{\\partial v_y}{\\partial x} - \\dfrac{\\partial v_x}{\\partial y}$ pointwise. For a rigid motion in the plane, $\\omega_z$ is spatially constant (possibly zero), and equals twice the scalar angular velocity. Degrees or radians do not directly enter the computation; treat all quantities as dimensionless and angles as measured in radians.\n\nDefine the following decision metrics over the grid:\n- $E_D := \\max\\limits_{\\text{grid}} ||\\boldsymbol{D}||_F$,\n- $E_{\\mathrm{div}} := \\max\\limits_{\\text{grid}} \\left|\\nabla \\cdot \\boldsymbol{v}\\right|$,\n- $E_{\\mathrm{curlvar}} := \\max\\limits_{\\text{grid}} \\left|\\omega_z - \\overline{\\omega}_z\\right|$, where $\\overline{\\omega}_z$ is the spatial mean of $\\omega_z$ over the grid.\n\nUse the tolerances:\n- $T_D = 5\\times 10^{-3}$,\n- $T_{\\mathrm{div}} = 5\\times 10^{-3}$,\n- $T_{\\mathrm{curlvar}} = 5\\times 10^{-3}$.\n\nClassify a field as rigid if and only if all three conditions hold:\n- $E_D \\leq T_D$,\n- $E_{\\mathrm{div}} \\leq T_{\\mathrm{div}}$,\n- $E_{\\mathrm{curlvar}} \\leq T_{\\mathrm{curlvar}}$.\n\nImplement the following test suite, each defined by a closed-form velocity field sampled on the grid:\n- Test $1$ (pure translation): $\\boldsymbol{v}(x,y) = \\left(a, b\\right)$ with $a = 0.3$, $b = -0.2$. Expected to be rigid.\n- Test $2$ (pure rotation about the origin): $\\boldsymbol{v}(x,y) = \\omega \\left(-y, x\\right)$ with $\\omega = 1.7$. Expected to be rigid.\n- Test $3$ (rotation plus translation): $\\boldsymbol{v}(x,y) = \\omega \\left(-y, x\\right) + \\left(a, b\\right)$ with $\\omega = -0.8$, $a = 0.05$, $b = -0.04$. Expected to be rigid.\n- Test $4$ (simple shear, nonrigid): $\\boldsymbol{v}(x,y) = \\left(\\gamma y, 0\\right)$ with $\\gamma = 0.3$. Expected to be nonrigid.\n- Test $5$ (rotation plus small noise): $\\boldsymbol{v}(x,y) = \\omega \\left(-y, x\\right) + \\varepsilon \\,\\boldsymbol{\\eta}(x,y)$ with $\\omega = 0.6$, $\\varepsilon = 10^{-4}$, and $\\boldsymbol{\\eta}$ a zero-mean random field with independent components and unit variance; fix a deterministic seed so the result is reproducible. Expected to be rigid under the given tolerances.\n- Test $6$ (isotropic expansion, nonrigid): $\\boldsymbol{v}(x,y) = \\alpha \\left(x, y\\right)$ with $\\alpha = 10^{-2}$. Expected to be nonrigid.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of tests $1$ through $6$, with each entry a boolean literal of your programming language indicating whether the field is classified as rigid. For example, an output could look like $[\\mathrm{True},\\mathrm{False},\\dots]$.\n\nNo user input is required and no external files may be used. All random quantities must be generated with a fixed seed to ensure reproducibility. Angles are in radians. No physical units are required in the final output. The output type for each test is boolean, and the final output must be exactly one line in the specified format.",
            "solution": "The problem requires the design and implementation of a numerical procedure to classify two-dimensional velocity fields as representing rigid body motions. This validation is based on three fundamental kinematic invariants of rigid motion. The entire process, from grid generation to the final classification, is detailed below.\n\n### I. Kinematic Principles of Rigid Body Motion\n\nThe motion of a continuum is described by a velocity field $\\boldsymbol{v}(\\boldsymbol{x}, t)$, which assigns a velocity vector to each point $\\boldsymbol{x}$ in space at time $t$. For this problem, we consider steady (time-independent) planar velocity fields, $\\boldsymbol{v}(\\boldsymbol{x}) = (v_x(x,y), v_y(x,y))$.\n\nThe local behavior of the flow is characterized by the velocity gradient tensor, $\\boldsymbol{L}$, defined as:\n$$\n\\boldsymbol{L} = \\nabla \\boldsymbol{v} = \\begin{pmatrix} \\dfrac{\\partial v_x}{\\partial x} & \\dfrac{\\partial v_x}{\\partial y} \\\\ \\dfrac{\\partial v_y}{\\partial x} & \\dfrac{\\partial v_y}{\\partial y} \\end{pmatrix}\n$$\nThe tensor $\\boldsymbol{L}$ can be uniquely decomposed into its symmetric and skew-symmetric parts:\n$$\n\\boldsymbol{L} = \\boldsymbol{D} + \\boldsymbol{W}\n$$\nwhere $\\boldsymbol{D}$ is the rate-of-deformation (or strain rate) tensor and $\\boldsymbol{W}$ is the spin (or vorticity) tensor:\n$$\n\\boldsymbol{D} = \\frac{1}{2}(\\boldsymbol{L} + \\boldsymbol{L}^{\\mathsf{T}}) \\quad \\text{and} \\quad \\boldsymbol{W} = \\frac{1}{2}(\\boldsymbol{L} - \\boldsymbol{L}^{\\mathsf{T}})\n$$\nA motion is defined as rigid if and only if the distance between any two material points remains constant over time. This kinematic constraint implies that the rate-of-deformation tensor must be identically zero throughout the body, i.e., $\\boldsymbol{D} = \\boldsymbol{0}$. The velocity field for a general rigid body motion has the form $\\boldsymbol{v}(\\boldsymbol{x}) = \\boldsymbol{c} + \\boldsymbol{\\Omega}\\,\\boldsymbol{x}$, where $\\boldsymbol{c}$ is a constant translational velocity vector and $\\boldsymbol{\\Omega}$ is a constant skew-symmetric tensor representing angular velocity. For such a field, the velocity gradient is $\\boldsymbol{L} = \\boldsymbol{\\Omega}$, which is constant and skew-symmetric.\n\nFrom the condition $\\boldsymbol{D} = \\boldsymbol{0}$, two further invariants are derived:\n1.  **Zero Divergence**: The divergence of the velocity field, which represents the rate of volume change per unit volume, must be zero. The divergence is the trace of the velocity gradient, $\\nabla \\cdot \\boldsymbol{v} = \\mathrm{tr}(\\boldsymbol{L}) = \\mathrm{tr}(\\boldsymbol{D}) + \\mathrm{tr}(\\boldsymbol{W})$. Since $\\boldsymbol{W}$ is skew-symmetric, its trace is zero, so $\\nabla \\cdot \\boldsymbol{v} = \\mathrm{tr}(\\boldsymbol{D})$. Thus, if $\\boldsymbol{D} = \\boldsymbol{0}$, then $\\nabla \\cdot \\boldsymbol{v} = 0$.\n2.  **Spatially Constant Vorticity**: The vorticity vector, $\\boldsymbol{\\omega} = \\nabla \\times \\boldsymbol{v}$, measures the local angular velocity of a fluid element. For a 2D field $\\boldsymbol{v} = (v_x, v_y, 0)$, the vorticity has only one non-zero component, $\\omega_z = \\frac{\\partial v_y}{\\partial x} - \\frac{\\partial v_x}{\\partial y}$. This is related to the spin tensor via $\\omega_z = 2W_{21}$. For a rigid motion, $\\boldsymbol{L} = \\boldsymbol{\\Omega}$ is constant, which means $\\boldsymbol{W}$ is constant, and therefore the vorticity $\\omega_z$ must be spatially constant.\n\nThese three conditions form the basis of our numerical verification:\n- Condition 1: The magnitude of the rate-of-deformation tensor $\\boldsymbol{D}$ is zero.\n- Condition 2: The divergence $\\nabla \\cdot \\boldsymbol{v}$ is zero.\n- Condition 3: The scalar vorticity $\\omega_z$ is spatially constant.\n\n### II. Numerical Implementation\n\nWe are given a rectangular domain $[-1,1]\\times[-0.9,0.9]$ discretized into a uniform grid of $N_x = 41 \\times N_y = 37$ points. The grid spacings are $\\Delta x = \\frac{1 - (-1)}{41 - 1} = 0.05$ and $\\Delta y = \\frac{0.9 - (-0.9)}{37 - 1} = 0.05$. The velocity components $v_x(x,y)$ and $v_y(x,y)$ are sampled at each grid point $(x_j, y_i)$.\n\n**A. Numerical Differentiation**\n\nThe partial derivatives required for the velocity gradient $\\boldsymbol{L}$ are computed using finite differences. For a function $f(x,y)$ sampled on the grid as $f_{i,j} = f(x_j, y_i)$:\n- At interior points ($1 \\le j \\le N_x-2$), a second-order central difference scheme is used for accuracy:\n  $$ \\frac{\\partial f}{\\partial x}\\bigg|_{i,j} \\approx \\frac{f_{i,j+1} - f_{i,j-1}}{2\\Delta x} $$\n- At boundary points ($j=0$ and $j=N_x-1$), first-order one-sided differences are used:\n  $$ \\frac{\\partial f}{\\partial x}\\bigg|_{i,0} \\approx \\frac{f_{i,1} - f_{i,0}}{\\Delta x} \\quad \\text{and} \\quad \\frac{\\partial f}{\\partial x}\\bigg|_{i,N_x-1} \\approx \\frac{f_{i,N_x-1} - f_{i,N_x-2}}{\\Delta x} $$\nAnalogous formulas are applied for the partial derivative with respect to $y$. This hybrid scheme provides a complete field of derivatives.\n\n**B. Calculation of Metrics**\n\nFor each of the six test velocity fields, we perform the following steps:\n1.  **Sample the Field**: The analytic functions for $v_x(x,y)$ and $v_y(x,y)$ are evaluated on the grid coordinates to produce two arrays, $\\boldsymbol{V}_x$ and $\\boldsymbol{V}_y$, of shape $(N_y, N_x)$. For the stochastic case, a fixed-seed random number generator is used to ensure reproducibility.\n2.  **Compute Velocity Gradient**: The numerical differentiation scheme is applied to $\\boldsymbol{V}_x$ and $\\boldsymbol{V}_y$ to compute the four components of the velocity gradient tensor $\\boldsymbol{L}$ at each grid point: $L_{11} = \\frac{\\partial v_x}{\\partial x}$, $L_{12} = \\frac{\\partial v_x}{\\partial y}$, $L_{21} = \\frac{\\partial v_y}{\\partial x}$, and $L_{22} = \\frac{\\partial v_y}{\\partial y}$.\n3.  **Evaluate Invariants**: At each grid point, we compute:\n    - The rate-of-deformation tensor components: $D_{11} = L_{11}$, $D_{22} = L_{22}$, and $D_{12} = \\frac{1}{2}(L_{12} + L_{21})$.\n    - The Frobenius norm of $\\boldsymbol{D}$: $||\\boldsymbol{D}||_F = \\sqrt{D_{11}^2 + 2 D_{12}^2 + D_{22}^2}$.\n    - The divergence: $\\nabla \\cdot \\boldsymbol{v} = L_{11} + L_{22}$.\n    - The scalar vorticity: $\\omega_z = L_{21} - L_{12}$.\n4.  **Compute Decision Metrics**: The spatially distributed fields of the invariants are reduced to single scalar metrics by taking the maximum value over the entire grid:\n    - $E_D = \\max_{\\text{grid}} ||\\boldsymbol{D}||_F$\n    - $E_{\\mathrm{div}} = \\max_{\\text{grid}} |\\nabla \\cdot \\boldsymbol{v}|$\n    - $E_{\\mathrm{curlvar}} = \\max_{\\text{grid}} |\\omega_z - \\overline{\\omega}_z|$, where $\\overline{\\omega}_z$ is the mean of $\\omega_z$ over all grid points.\n\n**C. Classification**\n\nA given velocity field is classified as 'rigid' if and only if all three of its computed metrics fall below their respective predefined tolerances:\n- $E_D \\leq T_D$, with $T_D = 5 \\times 10^{-3}$\n- $E_{\\mathrm{div}} \\leq T_{\\mathrm{div}}$, with $T_{\\mathrm{div}} = 5 \\times 10^{-3}$\n- $E_{\\mathrm{curlvar}} \\leq T_{\\mathrm{curlvar}}$, with $T_{\\mathrm{curlvar}} = 5 \\times 10^{-3}$\n\nAnalytically, the first three test cases represent true rigid body motions, so their metrics should be zero up to machine precision and numerical discretization error. The fourth (simple shear) and sixth (isotropic expansion) cases are non-rigid, and their metrics $E_D$ and/or $E_{\\mathrm{div}}$ are expected to be significantly larger than the tolerances. The fifth case, a rigid rotation with small additive noise, is designed to test the robustness of the method; the metrics are expected to be proportional to the noise amplitude $\\varepsilon$ divided by the grid spacing $\\Delta x$, which evaluates to an order of magnitude smaller than the tolerances, thus correctly classifying it as rigid. The implemented program executes this logic for each test case and reports the boolean classification.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_derivatives(F, dx, dy):\n    \"\"\"\n    Computes partial derivatives of a 2D field F using finite differences.\n    - 2nd-order central differences for interior points.\n    - 1st-order one-sided differences for boundary points.\n    \n    Args:\n        F (np.ndarray): The 2D field of shape (Ny, Nx).\n        dx (float): Grid spacing in the x-direction.\n        dy (float): Grid spacing in the y-direction.\n    \n    Returns:\n        tuple[np.ndarray, np.ndarray]: A tuple (dF_dx, dF_dy).\n    \"\"\"\n    Ny, Nx = F.shape\n    dF_dx = np.zeros_like(F)\n    dF_dy = np.zeros_like(F)\n\n    # Compute dF/dx\n    # Interior points (central difference)\n    dF_dx[:, 1:-1] = (F[:, 2:] - F[:, :-2]) / (2 * dx)\n    # Boundary points (one-sided differences)\n    dF_dx[:, 0] = (F[:, 1] - F[:, 0]) / dx\n    dF_dx[:, -1] = (F[:, -1] - F[:, -2]) / dx\n\n    # Compute dF/dy\n    # Interior points (central difference)\n    dF_dy[1:-1, :] = (F[2:, :] - F[:-2, :]) / (2 * dy)\n    # Boundary points (one-sided differences)\n    dF_dy[0, :] = (F[1, :] - F[0, :]) / dy\n    dF_dy[-1, :] = (F[-1, :] - F[-2, :]) / dy\n\n    return dF_dx, dF_dy\n\ndef verify_field(vx, vy, dx, dy, tolerances):\n    \"\"\"\n    Verifies if a velocity field (vx, vy) represents a rigid body motion.\n\n    Args:\n        vx (np.ndarray): The x-component of the velocity field.\n        vy (np.ndarray): The y-component of the velocity field.\n        dx (float): Grid spacing in x.\n        dy (float): Grid spacing in y.\n        tolerances (dict): A dictionary with keys 'T_D', 'T_div', 'T_curlvar'.\n\n    Returns:\n        bool: True if the field is classified as rigid, False otherwise.\n    \"\"\"\n    # 1. Compute components of the velocity gradient tensor L\n    dvx_dx, dvx_dy = compute_derivatives(vx, dx, dy)\n    dvy_dx, dvy_dy = compute_derivatives(vy, dx, dy)\n    \n    L11 = dvx_dx\n    L12 = dvx_dy\n    L21 = dvy_dx\n    L22 = dvy_dy\n\n    # 2. Compute invariants\n    # Rate-of-deformation tensor D\n    D11 = L11\n    D22 = L22\n    D12 = 0.5 * (L12 + L21)\n    \n    # Frobenius norm of D, pointwise\n    norm_D_F = np.sqrt(D11**2 + 2 * D12**2 + D22**2)\n    \n    # Divergence\n    div_v = L11 + L22\n\n    # Vorticity (scalar z-component)\n    omega_z = L21 - L12\n\n    # 3. Compute decision metrics\n    E_D = np.max(norm_D_F)\n    E_div = np.max(np.abs(div_v))\n    \n    mean_omega_z = np.mean(omega_z)\n    E_curlvar = np.max(np.abs(omega_z - mean_omega_z))\n\n    # 4. Classify the field\n    T_D = tolerances['T_D']\n    T_div = tolerances['T_div']\n    T_curlvar = tolerances['T_curlvar']\n\n    is_rigid = (E_D = T_D) and (E_div = T_div) and (E_curlvar = T_curlvar)\n    \n    return is_rigid\n\ndef solve():\n    # Define grid parameters\n    Nx = 41\n    Ny = 37\n    x_min, x_max = -1.0, 1.0\n    y_min, y_max = -0.9, 0.9\n    \n    dx = (x_max - x_min) / (Nx - 1)\n    dy = (y_max - y_min) / (Ny - 1)\n\n    # Create grid\n    x = np.linspace(x_min, x_max, Nx)\n    y = np.linspace(y_min, y_max, Ny)\n    xx, yy = np.meshgrid(x, y, indexing='xy')\n\n    # Define tolerances\n    tolerances = {\n        'T_D': 5e-3,\n        'T_div': 5e-3,\n        'T_curlvar': 5e-3\n    }\n\n    # Define test cases\n    test_cases = [\n        # Test 1: Pure translation\n        lambda xx, yy: (0.3 * np.ones_like(xx), -0.2 * np.ones_like(yy)),\n        # Test 2: Pure rotation\n        lambda xx, yy: (1.7 * (-yy), 1.7 * xx),\n        # Test 3: Rotation plus translation\n        lambda xx, yy: (-0.8 * (-yy) + 0.05, -0.8 * xx - 0.04),\n        # Test 4: Simple shear (non-rigid)\n        lambda xx, yy: (0.3 * yy, np.zeros_like(xx)),\n        # Test 5: Rotation plus small noise\n        lambda xx, yy: (\n            lambda omega=0.6, eps=1e-4, seed=42: (\n                (rng := np.random.default_rng(seed)),\n                (omega * (-yy) + eps * rng.standard_normal(xx.shape), \n                 omega * xx + eps * rng.standard_normal(xx.shape))\n            )[1]\n        )(xx, yy),\n        # Test 6: Isotropic expansion (non-rigid)\n        lambda xx, yy: (1e-2 * xx, 1e-2 * yy)\n    ]\n\n    results = []\n    for test_func in test_cases:\n        vx, vy = test_func(xx, yy)\n        is_rigid = verify_field(vx, vy, dx, dy, tolerances)\n        results.append(is_rigid)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "When simulating materials undergoing large rotations, a crucial requirement for any constitutive model is objectivityâ€”the material response must be independent of the observer's reference frame. This principle has profound implications for how we numerically accumulate strain. This exercise  demonstrates how a naive integration of a corotational strain rate can lead to spurious, non-physical strains, violating objectivity, while a properly formulated total strain measure, like the Hencky strain, correctly registers zero deformation for a pure rigid body rotation.",
            "id": "3597009",
            "problem": "You are tasked to design and implement a computational experiment in the field of computational solid mechanics to assess algorithmic objectivity under large rigid body rotations. Consider a deformation solely induced by a time-dependent rigid rotation, where the deformation gradient is $F(t) = R(t)$ with $R(t) \\in \\mathrm{SO}(3)$, and $\\det(R(t)) = 1$. The spatial velocity gradient is $L(t) = \\dot{F}(t) F(t)^{-1}$ and, under pure rotation, satisfies $L(t) = \\dot{R}(t) R(t)^{\\mathsf{T}} = W(t)$, where $W(t)$ is a skew-symmetric spin tensor. The rate-of-deformation tensor is $D(t) = \\frac{1}{2} \\left( L(t) + L(t)^{\\mathsf{T}} \\right) = 0$ for all $t$ under rigid rotation. The rotation evolves according to the fundamental kinematic relation $\\dot{R}(t) = W(t) R(t)$ with $W(t)$ generated by a time-varying angular velocity vector $\\omega(t)$ via $W(t) = \\mathrm{skew}(\\omega(t))$, where $\\mathrm{skew}(\\omega)$ is the $3 \\times 3$ skew-symmetric matrix such that $W(t) x = \\omega(t) \\times x$ for any vector $x$.\n\nStarting from these core definitions and laws, derive and implement two distinct algorithmic strain updates for the pure rotation path $F(t) = R(t)$:\n\n1) A discrete update consistent with the Jaumann corotational approach for small-strain accumulation in a rotating frame, constructed by working in the current corotational frame at time $t_n$ and additively accumulating the symmetric incremental mapping from $t_n$ to $t_{n+1}$. This update must be derived from first principles using the above kinematic bases and must express the accumulated strain tensor after $N$ steps as a sum of symmetric increments that depend on the discrete rotation between steps.\n\n2) A discrete update consistent with the logarithmic rate associated with the Hencky strain (logarithmic strain), where the strain increment is derived from the spectral definition of the right stretch tensor, extracted from the polar decomposition $F = R U$. Under pure rotation, use the fundamental fact that $U(t) = I$ and the Hencky strain is defined by the matrix logarithm $E(t) = \\log(U(t))$. Derive the discrete update and show how it is computed step by step.\n\nDefine the artificial shear magnitude $\\tau(t)$ at time $t$ as the Euclidean norm of the off-diagonal components of the accumulated strain tensor in the spatial frame, that is, for a symmetric strain tensor $E(t)$ define\n$$\n\\tau(t) = \\sqrt{E_{12}(t)^2 + E_{13}(t)^2 + E_{23}(t)^2}.\n$$\nYour program must:\n- Construct $R(t)$ by integrating $\\dot{R}(t) = W(t) R(t)$ with $R(0) = I$, where the angular velocity is $\\omega(t) = \\Omega \\, n(t)$, with constant magnitude $\\Omega$ and a time-varying unit axis $n(t)$ defined by a fixed polar angle $\\vartheta$ and a precession rate $\\beta$ by\n$$\nn(t) = \\big[ \\cos(\\beta t) \\sin(\\vartheta), \\; \\sin(\\beta t) \\sin(\\vartheta), \\; \\cos(\\vartheta) \\big]^{\\mathsf{T}}.\n$$\n- Integrate the rotation in discrete time using a fixed time step $\\Delta t$ and $N = T / \\Delta t$ steps, with the incremental rotation over a step obtained from the angular velocity at the beginning of the step.\n- Implement both updates (Jaumann and logarithmic rate), accumulate the strain tensors over the steps, and compute $\\tau(T)$ for each update at final time $T$.\n\nYou must report how $\\tau(T)$ depends on the norm of the rotation rate and the time step. In your derivation, relate the Frobenius norm $\\|\\dot{R}(t)\\|_{\\mathrm{F}}$ to the angular speed $\\|\\omega(t)\\|$ under pure rotation. Use angles in radians. Time is in seconds. The angular speed $\\Omega$ and precession rate $\\beta$ are in radians per second. The artificial shear magnitude $\\tau(T)$ is dimensionless.\n\nTest Suite:\nUse the following parameter sets, each defined by $(\\Omega,\\beta,\\vartheta,T,\\Delta t)$:\n- Case $1$: $(\\Omega,\\beta,\\vartheta,T,\\Delta t) = (5.0, 3.0, \\pi/4, 1.0, 1.0 \\times 10^{-3})$.\n- Case $2$: $(\\Omega,\\beta,\\vartheta,T,\\Delta t) = (5.0, 3.0, \\pi/4, 1.0, 1.0 \\times 10^{-4})$.\n- Case $3$: $(\\Omega,\\beta,\\vartheta,T,\\Delta t) = (20.0, 7.0, \\pi/3, 0.5, 5.0 \\times 10^{-3})$.\n- Case $4$: $(\\Omega,\\beta,\\vartheta,T,\\Delta t) = (0.0, 5.0, \\pi/4, 1.0, 1.0 \\times 10^{-3})$.\n- Case $5$: $(\\Omega,\\beta,\\vartheta,T,\\Delta t) = (5.0, 3.0, \\pi/4, 1.0, 2.0 \\times 10^{-2})$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain, in order, the artificial shear magnitudes at final time $T$ for the Jaumann update for Cases $1$ through $5$, followed by the artificial shear magnitudes at final time $T$ for the logarithmic rate update for Cases $1$ through $5$. For example, the output must be of the form\n$$\n[\\tau^{\\mathrm{J}}_1,\\tau^{\\mathrm{J}}_2,\\tau^{\\mathrm{J}}_3,\\tau^{\\mathrm{J}}_4,\\tau^{\\mathrm{J}}_5,\\tau^{\\log}_1,\\tau^{\\log}_2,\\tau^{\\log}_3,\\tau^{\\log}_4,\\tau^{\\log}_5].\n$$\nAll angles are in radians, and the reported $\\tau$ values are dimensionless floats.",
            "solution": "The core of the problem is to analyze the behavior of two strain accumulation schemes under a pure rigid body rotation. Analytically, a pure rigid body motion induces no deformation or strain. Therefore, any non-zero strain computed by a numerical algorithm is an artifact, often termed \"spurious strain.\" The objective is to quantify this artifact for a Jaumann rate-based update and contrast it with a total Lagrangian update based on the Hencky (logarithmic) strain.\n\n**1. Kinematic Preliminaries**\n\nThe deformation is a pure rigid body rotation described by the deformation gradient $F(t) = R(t)$, where $R(t) \\in \\mathrm{SO}(3)$ is a proper orthogonal rotation matrix at time $t$. The initial state is undeformed, so $R(0) = I$, the identity matrix.\n\nThe spatial velocity gradient is $L(t) = \\dot{F}(t) F(t)^{-1} = \\dot{R}(t) R(t)^{\\mathsf{T}}$. Since $R(t) R(t)^{\\mathsf{T}} = I$, differentiating with respect to time gives $\\dot{R}(t) R(t)^{\\mathsf{T}} + R(t) \\dot{R}(t)^{\\mathsf{T}} = 0$. This implies that $L(t) + L(t)^{\\mathsf{T}} = 0$, meaning $L(t)$ is a skew-symmetric tensor. This tensor is the spin tensor, $W(t) = L(t)$.\n\nThe rate-of-deformation tensor, $D(t)$, is the symmetric part of $L(t)$:\n$$\nD(t) = \\frac{1}{2} \\left( L(t) + L(t)^{\\mathsf{T}} \\right) = \\frac{1}{2} \\left( W(t) + W(t)^{\\mathsf{T}} \\right) = 0\n$$\nSince $D(t)$ is identically zero, there is no physical rate of straining.\n\nThe kinematics are governed by the relation $\\dot{R}(t) = W(t) R(t)$, where $W(t)$ is generated from the angular velocity vector $\\omega(t)$ via the skew-symmetric operator, $W(t) = \\mathrm{skew}(\\omega(t))$.\n\nThe problem asks to relate the Frobenius norm of $\\dot{R}(t)$ to the norm of $\\omega(t)$.\n$$\n\\|\\dot{R}(t)\\|_{\\mathrm{F}}^2 = \\mathrm{Tr}(\\dot{R}(t)^{\\mathsf{T}}\\dot{R}(t)) = \\mathrm{Tr}\\left( (W(t)R(t))^{\\mathsf{T}} (W(t)R(t)) \\right) = \\mathrm{Tr}(R(t)^{\\mathsf{T}}W(t)^{\\mathsf{T}}W(t)R(t))\n$$\nUsing the cyclic property of the trace, $\\mathrm{Tr}(ABC) = \\mathrm{Tr}(CAB)$, we have:\n$$\n\\|\\dot{R}(t)\\|_{\\mathrm{F}}^2 = \\mathrm{Tr}(W(t)^{\\mathsf{T}}W(t)R(t)R(t)^{\\mathsf{T}}) = \\mathrm{Tr}(W(t)^{\\mathsf{T}}W(t))\n$$\nLet $\\omega = [\\omega_1, \\omega_2, \\omega_3]^{\\mathsf{T}}$. The Frobenius norm of $W = \\mathrm{skew}(\\omega)$ is $\\|W\\|_{\\mathrm{F}}^2 = 2(\\omega_1^2 + \\omega_2^2 + \\omega_3^2) = 2\\|\\omega\\|^2$. Since $\\mathrm{Tr}(W^{\\mathsf{T}}W) = \\|W\\|_{\\mathrm{F}}^2$, we have $\\|\\dot{R}(t)\\|_{\\mathrm{F}}^2 = 2\\|\\omega(t)\\|^2$. Thus, $\\|\\dot{R}(t)\\|_{\\mathrm{F}} = \\sqrt{2}\\|\\omega(t)\\|$. Given $\\|\\omega(t)\\| = \\Omega$, a constant, we get $\\|\\dot{R}(t)\\|_{\\mathrm{F}} = \\sqrt{2}\\Omega$.\n\n**2. Numerical Integration of Rotation**\n\nThe evolution equation $\\dot{R}(t) = W(t) R(t)$ is integrated over discrete time steps of size $\\Delta t$. We use a first-order explicit integrator on the Lie group $\\mathrm{SO}(3)$. Given $R_n = R(t_n)$, the rotation at the next step $R_{n+1} = R(t_{n+1})$ is found by:\n$$\nR_{n+1} = \\Delta R_n R_n \n$$\nwhere $\\Delta R_n$ is the incremental rotation over $[t_n, t_{n+1}]$. This increment is approximated using the angular velocity at the start of the interval, $\\omega_n = \\omega(t_n)$, and the matrix exponential:\n$$\n\\Delta R_n = \\exp(\\Delta t \\, W_n) \\quad \\text{where} \\quad W_n = \\mathrm{skew}(\\omega_n)\n$$\nThe matrix exponential of a skew-symmetric matrix $\\mathrm{skew}(w)$ is a rotation matrix given by Rodrigues' formula:\n$$\n\\exp(\\mathrm{skew}(w)) = I + \\frac{\\sin \\theta}{\\theta} \\mathrm{skew}(w) + \\frac{1 - \\cos \\theta}{\\theta^2} (\\mathrm{skew}(w))^2\n$$\nwhere $\\theta = \\|w\\|$. In our case, $w = \\Delta t \\, \\omega_n$ and $\\theta = \\Delta t \\|\\omega_n\\| = \\Delta t \\Omega$. This numerical scheme correctly preserves the orthogonality of the rotation matrix, i.e., if $R_n \\in \\mathrm{SO}(3)$, then $R_{n+1} \\in \\mathrm{SO}(3)$.\n\n**3. Derivation of the Jaumann Corotational Update**\n\nThe Jaumann rate of a symmetric strain tensor $E$ is given by $E^\\nabla = \\dot{E} - WE + EW$. For a hypoelastic material, this objective rate is related to the rate of deformation, $E^\\nabla = D$. Since $D(t) = 0$ for pure rotation, we have $\\dot{E} = WE - EW$.\n\nA seemingly straightforward discretization is $E_{n+1} = E_n + \\Delta t (W_n E_n - E_n W_n)$. However, this scheme fails to preserve the symmetry of $E$. The problem stems from the fact that in a discrete setting, the rate-of-deformation $D$ is not exactly zero. An effective rate-of-deformation, $D_n$, arises from the approximation of the kinematics.\nLet the incremental deformation be $\\Delta R_n = \\exp(\\Delta t W_n)$. The average spatial velocity gradient over the interval is $L_{avg} \\approx \\frac{1}{\\Delta t} (\\Delta R_n - I)$.\nThe corresponding rate-of-deformation tensor is approximated as:\n$$\nD_n = \\text{symm}(L_{avg}) = \\frac{1}{2\\Delta t} (\\Delta R_n + \\Delta R_n^{\\mathsf{T}} - 2I)\n$$\nUsing Rodrigues' formula for $\\Delta R_n = \\exp(\\Delta t W_n)$ and $\\Delta R_n^{\\mathsf{T}} = \\exp(-\\Delta t W_n)$:\n$$\n\\Delta R_n + \\Delta R_n^{\\mathsf{T}} = 2I + 2 \\frac{1-\\cos(\\theta_n)}{\\theta_n^2} (\\Delta t W_n)^2\n$$\nwhere $\\theta_n = \\Delta t \\Omega$. Substituting this into the expression for $D_n$:\n$$\nD_n = \\frac{1}{2\\Delta t} \\left( 2 \\frac{1-\\cos(\\theta_n)}{\\theta_n^2} (\\Delta t W_n)^2 \\right) = \\frac{1-\\cos(\\Delta t \\Omega)}{\\Delta t \\Omega^2} W_n^2\n$$\nThis numerical rate-of-deformation $D_n$ is non-zero for $\\Omega > 0$ and $\\Delta t > 0$. The Jaumann update accumulates strain increments based on this spurious rate-of-deformation. The problem specifies an \"additive accumulation\" of \"symmetric incremental mappings.\" This corresponds to the simplest possible update scheme:\n$$\nE_{n+1}^{\\mathrm{J}} = E_{n}^{\\mathrm{J}} + \\Delta E_n\n$$\nwhere the strain increment $\\Delta E_n$ is $\\Delta t D_n$.\n$$\n\\Delta E_n = \\Delta t D_n = \\frac{1 - \\cos(\\Delta t \\Omega)}{\\Omega^2} W_n^2\n$$\nThis update is performed at each step, starting with $E_0^{\\mathrm{J}} = 0$. The accumulated strain $E_N^{\\mathrm{J}}$ at the final time $T=N\\Delta t$ will be non-zero, leading to a non-zero artificial shear magnitude $\\tau^{\\mathrm{J}}(T)$. Note that if $\\Omega=0$, then $W_n=0$ and $\\Delta E_n=0$, correctly yielding zero strain.\n\n**4. Derivation of the Logarithmic Strain Update**\n\nThe Hencky strain (logarithmic strain) is defined from the total deformation. First, the right Cauchy-Green tensor is computed: $C(t) = F(t)^{\\mathsf{T}} F(t)$. Then, the right stretch tensor $U(t) = \\sqrt{C(t)}$ is found via spectral decomposition. Finally, the Hencky strain is $E(t) = \\log(U(t))$, where $\\log$ is the matrix logarithm.\n\nIn the case of pure rigid body rotation, the deformation gradient at any time $t$ is $F(t) = R(t)$. Since $R(t)$ is a rotation matrix, $R(t)^{\\mathsf{T}} R(t) = I$.\nThe calculation proceeds as follows:\n$1$. $C(t) = F(t)^{\\mathsf{T}} F(t) = R(t)^{\\mathsf{T}} R(t) = I$.\n$2$. $U(t) = \\sqrt{C(t)} = \\sqrt{I} = I$.\n$3$. $E^{\\log}(t) = \\log(U(t)) = \\log(I) = 0$.\n\nThis holds true for the discrete numerical scheme as well. The rotation matrix is updated via $R_{n+1} = \\Delta R_n R_n$. Since $\\Delta R_n$ and $R_n$ are both rotation matrices (elements of $\\mathrm{SO}(3)$), their product $R_{n+1}$ is also a rotation matrix. Therefore, at any step $n$ of the simulation, we have $F_n = R_n \\in \\mathrm{SO}(3)$.\nThe discrete strain calculation at the final time $T$ yields:\n$1$. $F_N = R_N$.\n$2$. $C_N = F_N^{\\mathsf{T}} F_N = R_N^{\\mathsf{T}} R_N = I$.\n$3$. $U_N = I$.\n$4$. $E_N^{\\log} = 0$.\n\nThe \"step-by-step update\" for this strain measure is simply the re-evaluation of the strain from the total deformation gradient at any given time. As it is always zero, the accumulated strain is trivially zero. This demonstrates the objectivity of the Hencky strain measure; it correctly registers zero strain for a pure rigid body motion, regardless of the path or magnitude of rotation.\n\n**5. Computation of Artificial Shear Magnitude**\n\nFor each update scheme, the artificial shear magnitude $\\tau(T)$ is computed from the final accumulated strain tensor $E(T)$:\n$$\n\\tau(T) = \\sqrt{(E_{12}(T))^2 + (E_{13}(T))^2 + (E_{23}(T))^2}\n$$\nFor the Jaumann update, this will be a non-zero value that depends on the problem parameters, particularly $\\Omega$ and $\\Delta t$. For the logarithmic strain update, $\\tau^{\\log}(T)$ will be zero for all test cases.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the computational solid mechanics problem to assess algorithmic objectivity\n    under large rigid body rotations for Jaumann and logarithmic strain updates.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (Omega, beta, vartheta, T, dt)\n    test_cases = [\n        # Case 1\n        (5.0, 3.0, np.pi/4, 1.0, 1.0e-3),\n        # Case 2\n        (5.0, 3.0, np.pi/4, 1.0, 1.0e-4),\n        # Case 3\n        (20.0, 7.0, np.pi/3, 0.5, 5.0e-3),\n        # Case 4\n        (0.0, 5.0, np.pi/4, 1.0, 1.0e-3),\n        # Case 5\n        (5.0, 3.0, np.pi/4, 1.0, 2.0e-2),\n    ]\n\n    results_jaumann = []\n    results_log = []\n\n    for case in test_cases:\n        Omega, beta, vartheta, T, dt = case\n        \n        # Use a robust method to calculate the number of steps\n        num_steps = int(round(T / dt))\n\n        # --- Jaumann Corotational Update Calculation ---\n        # Initialize the accumulated strain tensor\n        E_jaumann = np.zeros((3, 3))\n        \n        # Pre-calculate constant values for the loop\n        sin_vartheta = np.sin(vartheta)\n        cos_vartheta = np.cos(vartheta)\n\n        # The factor multiplying W^2 in the strain increment formula\n        # Handle the case Omega = 0 to avoid division by zero.\n        # This is the stable evaluation of (1-cos(x))/x^2 for x=dt*Omega\n        if abs(Omega) > 1e-12:\n            factor = (1.0 - np.cos(dt * Omega)) / (Omega**2)\n        else:\n            factor = 0.0  # As Omega -> 0, the increment is zero.\n\n        for n in range(num_steps):\n            t_n = n * dt\n            \n            # If the factor is zero (e.g., Omega=0), no strain accumulates.\n            if factor == 0.0:\n                break\n                \n            # Define the time-varying rotation axis n(t)\n            nx = np.cos(beta * t_n) * sin_vartheta\n            ny = np.sin(beta * t_n) * sin_vartheta\n            nz = cos_vartheta\n            \n            # Angular velocity vector omega(t) = Omega * n(t)\n            omega_n = Omega * np.array([nx, ny, nz])\n            \n            # Skew-symmetric spin tensor W(t)\n            W_n = np.array([[0.0, -omega_n[2], omega_n[1]],\n                            [omega_n[2], 0.0, -omega_n[0]],\n                            [-omega_n[1], omega_n[0], 0.0]])\n            \n            # Square of the spin tensor\n            W2_n = W_n @ W_n\n            \n            # Calculate the spurious strain increment\n            delta_E = factor * W2_n\n            \n            # Additively accumulate the strain increment\n            E_jaumann += delta_E\n        \n        # Calculate artificial shear magnitude from off-diagonal components\n        # tau = sqrt(E12^2 + E13^2 + E23^2)\n        tau_jaumann = np.sqrt(E_jaumann[0, 1]**2 + E_jaumann[0, 2]**2 + E_jaumann[1, 2]**2)\n        results_jaumann.append(tau_jaumann)\n\n        # --- Logarithmic Strain Update Calculation ---\n        # As derived in the solution, for a pure rigid body rotation, the Hencky\n        # strain is identically zero. Therefore, the artificial shear is zero.\n        results_log.append(0.0)\n    \n    # Combine results into the final list as specified\n    final_results = results_jaumann + results_log\n\n    # Final print statement in the exact required format.\n    # The format specifier ensures consistent floating point representation.\n    print(f\"[{','.join(f'{r:.10f}' for r in final_results)}]\")\n\n# Execute the main function\nsolve()\n```"
        },
        {
            "introduction": "Accurately integrating the orientation of a rigid body over time is fundamental to dynamics simulation, robotics, and computer graphics. While rotation matrices are intuitive, their direct numerical integration can lead to a loss of orthogonality, a phenomenon known as numerical drift. This practice  compares a simple forward Euler scheme for rotation matrices with a geometric integrator based on unit quaternions, highlighting how the choice of mathematical representation and integration algorithm is critical for preserving the geometric structure of the rotation group $\\mathrm{SO}(3)$.",
            "id": "3596985",
            "problem": "Consider planar-free rigid body rotations in three dimensions, characterized by the Special Orthogonal Group $\\mathrm{SO}(3)$ and unit quaternions. Let the body angular velocity be represented by the vector $\\boldsymbol{\\omega}(t) \\in \\mathbb{R}^3$ in radians per second, and the rotation matrix by $\\mathbf{R}(t) \\in \\mathrm{SO}(3)$. The rigid body kinematic equation is the first-order linear matrix ordinary differential equation $\\dot{\\mathbf{R}} = [\\boldsymbol{\\omega}]_{\\times} \\mathbf{R}$, where $[\\boldsymbol{\\omega}]_{\\times}$ is the skew-symmetric cross-product matrix. A unit quaternion $\\mathbf{q}(t) \\in \\mathbb{R}^4$ with scalar-first convention encodes the same rotation with the kinematic equation $\\dot{\\mathbf{q}} = \\tfrac{1}{2} \\mathbf{S}(\\boldsymbol{\\omega}) \\mathbf{q}$, where $\\mathbf{S}(\\boldsymbol{\\omega}) \\in \\mathbb{R}^{4 \\times 4}$ is skew-symmetric.\n\nYour task is to implement, analyze, and compare two discrete time-stepping schemes over constant time steps of size $\\Delta t$:\n\n1. A midpoint update for unit quaternions defined by applying the implicit midpoint rule to $\\dot{\\mathbf{q}} = \\tfrac{1}{2} \\mathbf{S}(\\boldsymbol{\\omega}) \\mathbf{q}$ with piecewise-constant $\\boldsymbol{\\omega}$ over each time step. This yields a linear update of the form $\\mathbf{q}_{n+1} = \\mathbf{C} \\, \\mathbf{q}_n$ for some matrix $\\mathbf{C}$ derived from $\\mathbf{S}(\\boldsymbol{\\omega})$ and $\\Delta t$. You must derive this update from the implicit midpoint rule using only fundamental definitions.\n\n2. A direct matrix forward Euler update for the rotation matrix defined by $\\mathbf{R}_{n+1} = \\mathbf{R}_n + \\Delta t \\, [\\boldsymbol{\\omega}]_{\\times} \\mathbf{R}_n$ without any re-orthonormalization.\n\nStarting from only the rigid body kinematic equations and the definition of the implicit midpoint rule, derive the quaternion midpoint update and justify whether it preserves the unit norm of $\\mathbf{q}$. Also, analyze whether the direct matrix forward Euler update preserves orthogonality of $\\mathbf{R}$. The analysis must explicitly quantify the orthogonality error of the matrix scheme and the norm error of the quaternion scheme.\n\nFor numerical evaluation, implement a program that for each specified test case integrates both schemes for $N$ uniform steps of size $\\Delta t$ with constant angular velocity $\\boldsymbol{\\omega}$ over each step. The quaternion scheme should be applied to $\\mathbf{q}$ and the direct matrix scheme to $\\mathbf{R}$. Construct $\\mathbf{R}_0$ from the initial quaternion $\\mathbf{q}_0$ using the standard scalar-first quaternion-to-rotation mapping. For each test case, compute the following two scalar metrics at the final time $t_N = N \\Delta t$:\n\n- The quaternion unit-norm deviation $e_q = \\lvert \\lVert \\mathbf{q}_N \\rVert_2 - 1 \\rvert$.\n- The matrix orthogonality deviation $e_R = \\lVert \\mathbf{R}_N^{\\top} \\mathbf{R}_N - \\mathbf{I} \\rVert_F$, where $\\lVert \\cdot \\rVert_F$ is the Frobenius norm.\n\nAll angles must be in radians and all times in seconds. Ensure that $\\boldsymbol{\\omega}$ is expressed in radians per second. Report each metric as a floating-point number rounded to $10$ decimal places.\n\nUse the following test suite, which explores a typical case, stress cases, a boundary case, and long-horizon accumulation:\n\n- Test A: $\\mathbf{q}_0 = [1, 0, 0, 0]^{\\top}$, $\\boldsymbol{\\omega} = [0.2, -0.1, 0.05]^{\\top}$ radians per second, $\\Delta t = 0.01$ seconds, $N = 1000$.\n- Test B: $\\mathbf{q}_0$ from axis-angle with axis $\\mathbf{a} = [1, 1, 1]^{\\top}/\\lVert [1, 1, 1]^{\\top} \\rVert_2$ and angle $\\theta = 1.7$ radians, that is $\\mathbf{q}_0 = [\\cos(\\theta/2), \\sin(\\theta/2)\\,\\mathbf{a}^{\\top}]^{\\top}$; $\\boldsymbol{\\omega} = [50, 0, 25]^{\\top}$ radians per second, $\\Delta t = 0.02$ seconds, $N = 10$.\n- Test C: $\\mathbf{q}_0$ from axis-angle with axis $\\mathbf{a} = [0, 1, 0]^{\\top}$ and angle $\\theta = 0.3$ radians; $\\boldsymbol{\\omega} = [0, 0, 0]^{\\top}$ radians per second, $\\Delta t = 0.05$ seconds, $N = 50$.\n- Test D: $\\mathbf{q}_0 = [1, 0, 0, 0]^{\\top}$, $\\boldsymbol{\\omega} = [1000, 0, 0]^{\\top}$ radians per second, $\\Delta t = 0.001$ seconds, $N = 100$.\n- Test E: $\\mathbf{q}_0$ from axis-angle with axis proportional to $[3, -1, 2]^{\\top}$ normalized to unit length and angle $\\theta = 2.2$ radians; $\\boldsymbol{\\omega} = [3, 4, 5]^{\\top}$ radians per second, $\\Delta t = 0.005$ seconds, $N = 2000$.\n\nYour program must:\n\n- Implement the quaternion midpoint update exactly as implied by the implicit midpoint rule for $\\dot{\\mathbf{q}} = \\tfrac{1}{2} \\mathbf{S}(\\boldsymbol{\\omega}) \\mathbf{q}$ with constant $\\boldsymbol{\\omega}$ over each step.\n- Implement the direct matrix forward Euler update for $\\dot{\\mathbf{R}} = [\\boldsymbol{\\omega}]_{\\times} \\mathbf{R}$.\n- Use the scalar-first quaternion convention $\\mathbf{q} = [q_0, q_1, q_2, q_3]^{\\top}$.\n- Construct rotation matrices from quaternions via $\\mathbf{R}(\\mathbf{q}) = (q_0^2 - \\lVert \\mathbf{v} \\rVert_2^2) \\mathbf{I} + 2 \\mathbf{v}\\mathbf{v}^{\\top} + 2 q_0 [\\mathbf{v}]_{\\times}$ with $\\mathbf{v} = [q_1, q_2, q_3]^{\\top}$.\n- For each test case, produce a two-element list $[e_q, e_R]$ rounded to $10$ decimal places.\n- Final Output Format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to a test case and is itself a two-element list with no spaces. For example, the output format must be like $[[x_1,y_1],[x_2,y_2],\\dots]$.\n\nNo additional text should be printed. The numeric computations must be self-contained without requiring any user input or external files.",
            "solution": "The motion of a rigid body is described by its orientation in space. This orientation can be represented by a rotation matrix $\\mathbf{R}(t) \\in \\mathrm{SO}(3)$ or a unit quaternion $\\mathbf{q}(t) \\in \\mathbb{R}^4$. The evolution of these quantities is governed by first-order ordinary differential equations (ODEs). Given the body's angular velocity vector $\\boldsymbol{\\omega}(t) \\in \\mathbb{R}^3$, the kinematic equations are:\n\nFor the rotation matrix:\n$$\n\\dot{\\mathbf{R}} = [\\boldsymbol{\\omega}]_{\\times} \\mathbf{R} \\quad (1)\n$$\nwhere $[\\boldsymbol{\\omega}]_{\\times}$ is the $3 \\times 3$ skew-symmetric matrix representing the cross-product operation with $\\boldsymbol{\\omega}$.\n\nFor the unit quaternion, using the scalar-first convention $\\mathbf{q} = [q_0, q_1, q_2, q_3]^{\\top}$:\n$$\n\\dot{\\mathbf{q}} = \\frac{1}{2} \\mathbf{S}(\\boldsymbol{\\omega}) \\mathbf{q} \\quad (2)\n$$\nwhere $\\mathbf{S}(\\boldsymbol{\\omega})$ is the $4 \\times 4$ skew-symmetric matrix:\n$$\n\\mathbf{S}(\\boldsymbol{\\omega}) = \\begin{pmatrix}\n0  -\\omega_1  -\\omega_2  -\\omega_3 \\\\\n\\omega_1  0  -\\omega_3  \\omega_2 \\\\\n\\omega_2  \\omega_3  0  -\\omega_1 \\\\\n\\omega_3  -\\omega_2  \\omega_1  0\n\\end{pmatrix}\n$$\nThe problem requires an analysis of two discrete time-stepping schemes for these equations.\n\n### 1. Analysis of the Quaternion Midpoint Scheme\n\nThe first scheme is the implicit midpoint rule applied to the quaternion kinematic equation, Eq. ($2$). Let $\\mathbf{A} = \\frac{1}{2}\\mathbf{S}(\\boldsymbol{\\omega})$. Since $\\boldsymbol{\\omega}$ is constant over the time step $\\Delta t$, $\\mathbf{A}$ is a constant matrix. The ODE is a linear system $\\dot{\\mathbf{q}} = \\mathbf{A}\\mathbf{q}$.\n\nThe implicit midpoint rule for an ODE $\\dot{\\mathbf{y}} = f(t, \\mathbf{y})$ is given by:\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + \\Delta t \\, f\\left(t_n + \\frac{\\Delta t}{2}, \\frac{\\mathbf{y}_n + \\mathbf{y}_{n+1}}{2}\\right)\n$$\nApplying this to our linear system $\\dot{\\mathbf{q}} = \\mathbf{A}\\mathbf{q}$, we have:\n$$\n\\mathbf{q}_{n+1} = \\mathbf{q}_n + \\Delta t \\, \\mathbf{A} \\left(\\frac{\\mathbf{q}_n + \\mathbf{q}_{n+1}}{2}\\right)\n$$\nWe must now solve for $\\mathbf{q}_{n+1}$:\n$$\n\\mathbf{q}_{n+1} = \\mathbf{q}_n + \\frac{\\Delta t}{2} \\mathbf{A} \\mathbf{q}_n + \\frac{\\Delta t}{2} \\mathbf{A} \\mathbf{q}_{n+1}\n$$\n$$\n\\mathbf{q}_{n+1} - \\frac{\\Delta t}{2} \\mathbf{A} \\mathbf{q}_{n+1} = \\mathbf{q}_n + \\frac{\\Delta t}{2} \\mathbf{A} \\mathbf{q}_n\n$$\n$$\n\\left(\\mathbf{I} - \\frac{\\Delta t}{2} \\mathbf{A}\\right) \\mathbf{q}_{n+1} = \\left(\\mathbf{I} + \\frac{\\Delta t}{2} \\mathbf{A}\\right) \\mathbf{q}_n\n$$\nThis yields the explicit update rule $\\mathbf{q}_{n+1} = \\mathbf{C} \\mathbf{q}_n$, where the update matrix $\\mathbf{C}$ is:\n$$\n\\mathbf{C} = \\left(\\mathbf{I} - \\frac{\\Delta t}{2} \\mathbf{A}\\right)^{-1} \\left(\\mathbf{I} + \\frac{\\Delta t}{2} \\mathbf{A}\\right)\n$$\nThis expression is known as the Cayley transform of the matrix $\\frac{\\Delta t}{2}\\mathbf{A}$.\n\nNext, we analyze whether this scheme preserves the unit norm of the quaternion. A property of the continuous dynamics is that if $\\lVert \\mathbf{q}(0) \\rVert_2 = 1$, then $\\lVert \\mathbf{q}(t) \\rVert_2 = 1$ for all $t > 0$. This is because the generator matrix $\\mathbf{A}$ is skew-symmetric ($\\mathbf{A}^\\top = -\\mathbf{A}$), which implies $\\frac{d}{dt}(\\mathbf{q}^\\top\\mathbf{q}) = \\dot{\\mathbf{q}}^\\top\\mathbf{q} + \\mathbf{q}^\\top\\dot{\\mathbf{q}} = (\\mathbf{A}\\mathbf{q})^\\top\\mathbf{q} + \\mathbf{q}^\\top(\\mathbf{A}\\mathbf{q}) = \\mathbf{q}^\\top\\mathbf{A}^\\top\\mathbf{q} + \\mathbf{q}^\\top\\mathbf{A}\\mathbf{q} = \\mathbf{q}^\\top(-\\mathbf{A})\\mathbf{q} + \\mathbf{q}^\\top\\mathbf{A}\\mathbf{q} = 0$.\n\nA numerical scheme that preserves this property is called a geometric integrator. For the midpoint scheme, norm preservation is equivalent to the update matrix $\\mathbf{C}$ being orthogonal, i.e., $\\mathbf{C}^\\top\\mathbf{C} = \\mathbf{I}$. Let $\\mathbf{B} = \\frac{\\Delta t}{2}\\mathbf{A}$. Since $\\mathbf{A}$ is skew-symmetric, $\\mathbf{B}$ is also skew-symmetric ($\\mathbf{B}^\\top = -\\mathbf{B}$).\nWe have $\\mathbf{C} = (\\mathbf{I} - \\mathbf{B})^{-1} (\\mathbf{I} + \\mathbf{B})$. The transpose is:\n$$\n\\mathbf{C}^\\top = \\left((\\mathbf{I} - \\mathbf{B})^{-1} (\\mathbf{I} + \\mathbf{B})\\right)^\\top = (\\mathbf{I} + \\mathbf{B})^\\top \\left((\\mathbf{I} - \\mathbf{B})^{-1}\\right)^\\top = (\\mathbf{I} + \\mathbf{B}^\\top) (\\mathbf{I} - \\mathbf{B}^\\top)^{-1}\n$$\nSubstituting $\\mathbf{B}^\\top = -\\mathbf{B}$:\n$$\n\\mathbf{C}^\\top = (\\mathbf{I} - \\mathbf{B}) (\\mathbf{I} + \\mathbf{B})^{-1}\n$$\nNow, we compute $\\mathbf{C}^\\top\\mathbf{C}$:\n$$\n\\mathbf{C}^\\top\\mathbf{C} = \\left[(\\mathbf{I} - \\mathbf{B}) (\\mathbf{I} + \\mathbf{B})^{-1}\\right] \\left[(\\mathbf{I} - \\mathbf{B})^{-1} (\\mathbf{I} + \\mathbf{B})\\right]\n$$\nThe matrices $(\\mathbf{I} + \\mathbf{B})^{-1}$ and $(\\mathbf{I} - \\mathbf{B})$ commute. This can be shown as $(\\mathbf{I} - \\mathbf{B})(\\mathbf{I} + \\mathbf{B})^{-1} = (\\mathbf{I} + \\mathbf{B} - 2\\mathbf{B})(\\mathbf{I} + \\mathbf{B})^{-1} = \\mathbf{I} - 2\\mathbf{B}(\\mathbf{I} + \\mathbf{B})^{-1}$, and $(\\mathbf{I} + \\mathbf{B})^{-1}(\\mathbf{I} - \\mathbf{B}) = (\\mathbf{I} + \\mathbf{B})^{-1}(\\mathbf{I} + \\mathbf{B} - 2\\mathbf{B}) = \\mathbf{I} - 2(\\mathbf{I} + \\mathbf{B})^{-1}\\mathbf{B}$. Since $\\mathbf{B}$ and $(\\mathbf{I} + \\mathbf{B})^{-1}$ commute, these expressions are equal.\nTherefore, we can rearrange the product:\n$$\n\\mathbf{C}^\\top\\mathbf{C} = (\\mathbf{I} - \\mathbf{B}) \\left[(\\mathbf{I} + \\mathbf{B})^{-1} (\\mathbf{I} - \\mathbf{B})^{-1}\\right] (\\mathbf{I} + \\mathbf{B})\n$$\nUsing the property $(\\mathbf{M}\\mathbf{N})^{-1} = \\mathbf{N}^{-1}\\mathbf{M}^{-1}$:\n$$\n\\mathbf{C}^\\top\\mathbf{C} = (\\mathbf{I} - \\mathbf{B}) \\left[(\\mathbf{I} - \\mathbf{B})(\\mathbf{I} + \\mathbf{B})\\right]^{-1} (\\mathbf{I} + \\mathbf{B}) = (\\mathbf{I} - \\mathbf{B}) [\\mathbf{I} - \\mathbf{B}^2]^{-1} (\\mathbf{I} + \\mathbf{B})\n$$\nThis path is complicated. A more direct proof is to show that $\\mathbf{C} \\mathbf{C}^\\top = \\mathbf{I}$:\n$$\n\\mathbf{C}\\mathbf{C}^\\top = \\left[(\\mathbf{I} - \\mathbf{B})^{-1} (\\mathbf{I} + \\mathbf{B})\\right] \\left[(\\mathbf{I} - \\mathbf{B}) (\\mathbf{I} + \\mathbf{B})^{-1}\\right] = (\\mathbf{I} - \\mathbf{B})^{-1} (\\mathbf{I} + \\mathbf{B}) (\\mathbf{I} - \\mathbf{B}) (\\mathbf{I} + \\mathbf{B})^{-1}\n$$\nSince $(\\mathbf{I}+\\mathbf{B})$ and $(\\mathbf{I}-\\mathbf{B})$ commute, the inner terms can be swapped:\n$$\n\\mathbf{C}\\mathbf{C}^\\top = (\\mathbf{I} - \\mathbf{B})^{-1} (\\mathbf{I} - \\mathbf{B}) (\\mathbf{I} + \\mathbf{B}) (\\mathbf{I} + \\mathbf{B})^{-1} = \\mathbf{I} \\cdot \\mathbf{I} = \\mathbf{I}\n$$\nThus, the update matrix $\\mathbf{C}$ is orthogonal. This guarantees that the norm of the quaternion is exactly preserved at each step:\n$$\n\\lVert \\mathbf{q}_{n+1} \\rVert_2^2 = \\mathbf{q}_{n+1}^\\top \\mathbf{q}_{n+1} = (\\mathbf{C}\\mathbf{q}_n)^\\top (\\mathbf{C}\\mathbf{q}_n) = \\mathbf{q}_n^\\top \\mathbf{C}^\\top \\mathbf{C} \\mathbf{q}_n = \\mathbf{q}_n^\\top \\mathbf{I} \\mathbf{q}_n = \\lVert \\mathbf{q}_n \\rVert_2^2\n$$\nThe quaternion unit-norm deviation $e_q = \\lvert \\lVert \\mathbf{q}_N \\rVert_2 - 1 \\rvert$ is therefore theoretically zero. Any observed deviation will be due solely to floating-point representation and arithmetic errors, which are expected to be on the order of machine precision.\n\n### 2. Analysis of the Matrix Forward Euler Scheme\n\nThe second scheme is the direct forward Euler update applied to Eq. ($1$):\n$$\n\\mathbf{R}_{n+1} = \\mathbf{R}_n + \\Delta t \\, \\dot{\\mathbf{R}}_n = \\mathbf{R}_n + \\Delta t \\, [\\boldsymbol{\\omega}]_{\\times} \\mathbf{R}_n = (\\mathbf{I} + \\Delta t \\, [\\boldsymbol{\\omega}]_{\\times}) \\mathbf{R}_n\n$$\nLet the update matrix be $\\mathbf{U} = \\mathbf{I} + \\Delta t [\\boldsymbol{\\omega}]_{\\times}$. We analyze if this scheme preserves the orthogonality of the rotation matrix $\\mathbf{R}$. Assuming $\\mathbf{R}_n$ is orthogonal ($\\mathbf{R}_n^\\top\\mathbf{R}_n = \\mathbf{I}$), we check if $\\mathbf{R}_{n+1}$ is orthogonal.\n$$\n\\mathbf{R}_{n+1}^\\top \\mathbf{R}_{n+1} = \\left(\\mathbf{U} \\mathbf{R}_n\\right)^\\top \\left(\\mathbf{U} \\mathbf{R}_n\\right) = \\mathbf{R}_n^\\top \\mathbf{U}^\\top \\mathbf{U} \\mathbf{R}_n\n$$\nSince $\\mathbf{R}_n$ is orthogonal, for $\\mathbf{R}_{n+1}$ to be orthogonal, $\\mathbf{U}$ must be orthogonal, i.e., $\\mathbf{U}^\\top\\mathbf{U} = \\mathbf{I}$.\nThe matrix $[\\boldsymbol{\\omega}]_{\\times}$ is skew-symmetric, so $[\\boldsymbol{\\omega}]_{\\times}^\\top = -[\\boldsymbol{\\omega}]_{\\times}$. The transpose of $\\mathbf{U}$ is:\n$$\n\\mathbf{U}^\\top = (\\mathbf{I} + \\Delta t [\\boldsymbol{\\omega}]_{\\times})^\\top = \\mathbf{I} - \\Delta t [\\boldsymbol{\\omega}]_{\\times}\n$$\nNow we compute $\\mathbf{U}^\\top\\mathbf{U}$:\n$$\n\\mathbf{U}^\\top\\mathbf{U} = (\\mathbf{I} - \\Delta t [\\boldsymbol{\\omega}]_{\\times}) (\\mathbf{I} + \\Delta t [\\boldsymbol{\\omega}]_{\\times}) = \\mathbf{I} - (\\Delta t)^2 [\\boldsymbol{\\omega}]_{\\times}^2\n$$\nThis quantity is not equal to $\\mathbf{I}$ unless $\\Delta t = 0$ or $\\boldsymbol{\\omega} = \\mathbf{0}$. Therefore, the forward Euler scheme does not preserve orthogonality. The matrix $\\mathbf{R}_n$ will progressively lose its orthogonality.\n\nThe orthogonality error after one step, starting from an orthogonal $\\mathbf{R}_n$, is:\n$$\n\\mathbf{R}_{n+1}^\\top\\mathbf{R}_{n+1} - \\mathbf{I} = \\mathbf{R}_n^\\top \\mathbf{U}^\\top\\mathbf{U} \\mathbf{R}_n - \\mathbf{R}_n^\\top\\mathbf{I}\\mathbf{R}_n = \\mathbf{R}_n^\\top (\\mathbf{U}^\\top\\mathbf{U} - \\mathbf{I}) \\mathbf{R}_n = -(\\Delta t)^2 \\mathbf{R}_n^\\top [\\boldsymbol{\\omega}]_{\\times}^2 \\mathbf{R}_n\n$$\nThe error matrix after one step is of order $(\\Delta t)^2$. Over $N$ steps, these errors accumulate. The total time of integration is $T = N\\Delta t$. The final error is expected to be proportional to $N(\\Delta t)^2 = (N\\Delta t)\\Delta t = T\\Delta t$. This first-order global error in orthogonality is a significant drawback of this simple scheme. The matrix orthogonality deviation $e_R = \\lVert \\mathbf{R}_N^{\\top} \\mathbf{R}_N - \\mathbf{I} \\rVert_F$ will therefore grow significantly with simulation time and step size, unlike the quaternion scheme where the error remains near machine precision.\n\n### 3. Numerical Implementation Strategy\n\nThe numerical evaluation proceeds by implementing both schemes and applying them to the specified test cases. Key components of the implementation are:\n- A function to convert an axis-angle representation to a scalar-first unit quaternion.\n- A function to convert a scalar-first quaternion to a $3 \\times 3$ rotation matrix using the provided formula.\n- For each test case:\n    1. Initialize $\\mathbf{q}_0$ and compute the corresponding $\\mathbf{R}_0$.\n    2. Pre-compute the constant update matrices for both schemes: $\\mathbf{C}$ for the quaternion midpoint method and $\\mathbf{U}$ for the matrix forward Euler method. This is efficient as $\\boldsymbol{\\omega}$ is constant.\n    3. Loop $N$ times, applying the respective update rules: $\\mathbf{q}_{n+1} = \\mathbf{C}\\mathbf{q}_n$ and $\\mathbf{R}_{n+1} = \\mathbf{U}\\mathbf{R}_n$.\n    4. After the loop, compute the final error metrics $e_q$ and $e_R$.\n    5. Store the results, rounded to $10$ decimal places as required.\n- Finally, format the collected results into the specified string format. This systematic approach will concretely demonstrate the analytical findings.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# No other libraries are required or permitted.\n\ndef skew(v):\n    \"\"\"\n    Constructs the 3x3 skew-symmetric matrix for a 3-vector v.\n    [v]_x\n    \"\"\"\n    return np.array([\n        [0, -v[2], v[1]],\n        [v[2], 0, -v[0]],\n        [-v[1], v[0], 0]\n    ])\n\ndef S_omega(omega):\n    \"\"\"\n    Constructs the 4x4 skew-symmetric matrix S(omega) for scalar-first\n    quaternion kinematics.\n    \"\"\"\n    w1, w2, w3 = omega\n    return np.array([\n        [0, -w1, -w2, -w3],\n        [w1, 0, -w3, w2],\n        [w2, w3, 0, -w1],\n        [w3, -w2, w1, 0]\n    ])\n\ndef q_to_R(q):\n    \"\"\"\n    Converts a scalar-first quaternion q = [q0, q1, q2, q3] to a 3x3\n    rotation matrix R.\n    \"\"\"\n    q0, q1, q2, q3 = q\n    v = np.array([q1, q2, q3])\n    # The formula is R = (q0^2 - ||v||^2)I + 2vv^T + 2q0[v]_x\n    # For a unit quaternion, q0^2 + ||v||^2 = 1, so q0^2 - ||v||^2 = 2q0^2 - 1.\n    R = (q0**2 - np.dot(v, v)) * np.identity(3) + 2 * np.outer(v, v) + 2 * q0 * skew(v)\n    return R\n\ndef aa_to_q(axis, angle):\n    \"\"\"\n    Converts an axis-angle representation to a scalar-first unit quaternion.\n    \"\"\"\n    axis = np.asarray(axis, dtype=float)\n    norm = np.linalg.norm(axis)\n    if norm  1e-12:\n        return np.array([1.0, 0.0, 0.0, 0.0])\n    axis = axis / norm\n    \n    theta_half = angle / 2.0\n    q0 = np.cos(theta_half)\n    v = axis * np.sin(theta_half)\n    return np.array([q0, v[0], v[1], v[2]])\n\ndef solve():\n    \"\"\"\n    Main function to run the simulations and compute error metrics.\n    \"\"\"\n    test_cases = [\n        # Test A: Typical case\n        {'q0_params': [1.0, 0.0, 0.0, 0.0], 'omega': [0.2, -0.1, 0.05], 'dt': 0.01, 'N': 1000},\n        # Test B: Stress case (high ang. vel. briefly)\n        {'q0_params': (([1, 1, 1], 1.7)), 'omega': [50, 0, 25], 'dt': 0.02, 'N': 10},\n        # Test C: Boundary case (zero ang. vel.)\n        {'q0_params': (([0, 1, 0], 0.3)), 'omega': [0, 0, 0], 'dt': 0.05, 'N': 50},\n        # Test D: Stress case (extreme ang. vel.)\n        {'q0_params': [1.0, 0.0, 0.0, 0.0], 'omega': [1000, 0, 0], 'dt': 0.001, 'N': 100},\n        # Test E: Long-horizon accumulation\n        {'q0_params': (([3, -1, 2], 2.2)), 'omega': [3, 4, 5], 'dt': 0.005, 'N': 2000}\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        q0_params = case['q0_params']\n        omega = np.array(case['omega'], dtype=float)\n        dt = case['dt']\n        N = case['N']\n\n        # --- Initial Conditions ---\n        if isinstance(q0_params, list):\n            q0 = np.array(q0_params, dtype=float)\n        else:  # Tuple (axis, angle)\n            axis, angle = q0_params\n            q0 = aa_to_q(axis, angle)\n        \n        R0 = q_to_R(q0)\n\n        # --- Quaternion Midpoint Integration ---\n        q = q0.copy()\n        A = 0.5 * S_omega(omega)\n        Id4 = np.identity(4)\n        # Pre-compute update matrix C = (I - dt/2 * A)^-1 * (I + dt/2 * A)\n        C = np.linalg.inv(Id4 - (dt / 2.0) * A) @ (Id4 + (dt / 2.0) * A)\n        \n        for _ in range(N):\n            q = C @ q\n        \n        q_N = q\n        # Compute quaternion unit-norm deviation\n        e_q = np.abs(np.linalg.norm(q_N) - 1.0)\n\n        # --- Matrix Forward Euler Integration ---\n        R = R0.copy()\n        Id3 = np.identity(3)\n        omega_cross = skew(omega)\n        # Pre-compute update matrix U = I + dt * [omega]_x\n        U = Id3 + dt * omega_cross\n\n        for _ in range(N):\n            R = U @ R\n            \n        R_N = R\n        # Compute matrix orthogonality deviation\n        e_R = np.linalg.norm(R_N.T @ R_N - Id3, 'fro')\n\n        results.append([e_q, e_R])\n\n    # --- Final Output Formatting ---\n    # The output format must be exactly [[e_q1,e_R1],[e_q2,e_R2],...]\n    # Using f-string formatting handles rounding to 10 decimal places.\n    result_strings = [f\"[{res[0]:.10f},{res[1]:.10f}]\" for res in results]\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```"
        }
    ]
}