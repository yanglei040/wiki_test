{
    "hands_on_practices": [
        {
            "introduction": "要真正掌握主拉伸和主方向的概念，必须首先从第一性原理出发，建立对这些量如何从变形梯度中产生的深刻理解。本练习将引导您完成一个基础的解析推导过程，在二维情况下，您将从变形梯度 $\\boldsymbol{F}$ 出发，通过构建右柯西-格林变形张量 $\\boldsymbol{C}$ 并求解其特征多项式，最终得到主拉伸的闭合表达式。完成此练习有助于巩固变形、应变和主值之间基础的运动学和代数学联系。",
            "id": "3590880",
            "problem": "考虑一个均匀的二维（平面）变形，其变形梯度 $\\boldsymbol{F} \\in \\mathbb{R}^{2 \\times 2}$ 由下式给出\n$$\n\\boldsymbol{F}=\\begin{pmatrix} a  b \\\\ c  d \\end{pmatrix},\n$$\n其中 $\\det \\boldsymbol{F}0$。设右柯西-格林变形张量定义为 $\\boldsymbol{C}=\\boldsymbol{F}^{\\top}\\boldsymbol{F}$。主伸长定义为右伸长张量 $\\boldsymbol{U}$ 的正特征值，其中 $\\boldsymbol{F}$ 具有极分解 $\\boldsymbol{F}=\\boldsymbol{R}\\,\\boldsymbol{U}$，$\\boldsymbol{R}$ 为真正交矩阵，$\\boldsymbol{U}$ 为对称正定矩阵。仅使用这些基本定义，通过应用 $\\boldsymbol{C}$ 的特征多项式，推导两个主伸长关于 $a$、$b$、$c$ 和 $d$ 的闭式解析表达式。按非递减顺序列出这两个主伸长。最终答案以无单位的符号形式表示。",
            "solution": "所述问题具有科学依据，提法恰当，客观，并包含唯一解所需的所有必要信息。所提供的定义和关系是连续介质力学中的标准内容。因此，我们可以进行推导。\n\n变形梯度 $\\boldsymbol{F}$ 是一个具有实数分量的 $2 \\times 2$ 矩阵：\n$$\n\\boldsymbol{F} = \\begin{pmatrix} a  b \\\\ c  d \\end{pmatrix}\n$$\n问题指出 $\\det \\boldsymbol{F}  0$，这确保了变形是保向的。\n\n右柯西-格林变形张量 $\\boldsymbol{C}$ 定义为 $\\boldsymbol{C} = \\boldsymbol{F}^{\\top}\\boldsymbol{F}$。首先，我们计算 $\\boldsymbol{F}$ 的转置：\n$$\n\\boldsymbol{F}^{\\top} = \\begin{pmatrix} a  c \\\\ b  d \\end{pmatrix}\n$$\n现在，我们计算矩阵乘积 $\\boldsymbol{F}^{\\top}\\boldsymbol{F}$：\n$$\n\\boldsymbol{C} = \\boldsymbol{F}^{\\top}\\boldsymbol{F} = \\begin{pmatrix} a  c \\\\ b  d \\end{pmatrix} \\begin{pmatrix} a  b \\\\ c  d \\end{pmatrix} = \\begin{pmatrix} a^2 + c^2  ab + cd \\\\ ab + cd  b^2 + d^2 \\end{pmatrix}\n$$\n所得张量 $\\boldsymbol{C}$ 是对称的，正如预期。\n\n主伸长（我们记为 $\\lambda_1$ 和 $\\lambda_2$）是右伸长张量 $\\boldsymbol{U}$ 的特征值。张量 $\\boldsymbol{U}$ 出现在 $\\boldsymbol{F}$ 的极分解 $\\boldsymbol{F}=\\boldsymbol{R}\\boldsymbol{U}$ 中，其中 $\\boldsymbol{R}$ 是一个真正交张量（$\\boldsymbol{R}^{\\top}\\boldsymbol{R}=\\boldsymbol{I}$, $\\det \\boldsymbol{R} = 1$），$\\boldsymbol{U}$ 是一个对称正定张量。\n\n$\\boldsymbol{C}$ 和 $\\boldsymbol{U}$ 之间的关系由它们的定义导出：\n$$\n\\boldsymbol{C} = \\boldsymbol{F}^{\\top}\\boldsymbol{F} = (\\boldsymbol{R}\\boldsymbol{U})^{\\top}(\\boldsymbol{R}\\boldsymbol{U}) = \\boldsymbol{U}^{\\top}\\boldsymbol{R}^{\\top}\\boldsymbol{R}\\boldsymbol{U}\n$$\n由于 $\\boldsymbol{R}$ 是正交的，$\\boldsymbol{R}^{\\top}\\boldsymbol{R}=\\boldsymbol{I}$，其中 $\\boldsymbol{I}$ 是单位张量。因此，\n$$\n\\boldsymbol{C} = \\boldsymbol{U}^{\\top}\\boldsymbol{U}\n$$\n因为 $\\boldsymbol{U}$ 是对称的（$\\boldsymbol{U}^{\\top}=\\boldsymbol{U}$），这可以简化为：\n$$\n\\boldsymbol{C} = \\boldsymbol{U}^2\n$$\n这个关系意味着 $\\boldsymbol{C}$ 的特征值是 $\\boldsymbol{U}$ 的特征值的平方。设 $\\mathbf{n}$ 是一个主方向，即对应于主伸长 $\\lambda$ 的 $\\boldsymbol{U}$ 的特征向量。那么，根据定义：\n$$\n\\boldsymbol{U}\\mathbf{n} = \\lambda \\mathbf{n}\n$$\n将张量 $\\boldsymbol{C}$ 应用于该特征向量 $\\mathbf{n}$，我们得到：\n$$\n\\boldsymbol{C}\\mathbf{n} = \\boldsymbol{U}^2 \\mathbf{n} = \\boldsymbol{U}(\\boldsymbol{U}\\mathbf{n}) = \\boldsymbol{U}(\\lambda\\mathbf{n}) = \\lambda(\\boldsymbol{U}\\mathbf{n}) = \\lambda(\\lambda\\mathbf{n}) = \\lambda^2 \\mathbf{n}\n$$\n这表明如果 $\\lambda$ 是 $\\boldsymbol{U}$ 的一个特征值，那么 $\\mu = \\lambda^2$就是 $\\boldsymbol{C}$ 的一个特征值。主伸长 $\\lambda$ 定义为正值，所以 $\\lambda = \\sqrt{\\mu}$。\n\n为了求主伸长，我们必须首先通过求解其特征方程 $\\det(\\boldsymbol{C} - \\mu \\boldsymbol{I}) = 0$ 来找到 $\\boldsymbol{C}$ 的特征值。\n$$\n\\boldsymbol{C} - \\mu \\boldsymbol{I} = \\begin{pmatrix} a^2 + c^2 - \\mu  ab + cd \\\\ ab + cd  b^2 + d^2 - \\mu \\end{pmatrix}\n$$\n行列式为：\n$$\n\\det(\\boldsymbol{C} - \\mu \\boldsymbol{I}) = (a^2 + c^2 - \\mu)(b^2 + d^2 - \\mu) - (ab + cd)^2 = 0\n$$\n展开此表达式得到关于 $\\mu$ 的特征多项式：\n$$\n\\mu^2 - ((a^2 + c^2) + (b^2 + d^2))\\mu + (a^2 + c^2)(b^2 + d^2) - (ab + cd)^2 = 0\n$$\n这个二次方程的系数与 $\\boldsymbol{C}$ 的不变量有关。$\\mu$ 的一次项系数是 $\\boldsymbol{C}$ 的迹的相反数：\n$$\n\\text{tr}(\\boldsymbol{C}) = a^2 + c^2 + b^2 + d^2\n$$\n常数项是 $\\boldsymbol{C}$ 的行列式：\n$$\n\\det(\\boldsymbol{C}) = (a^2 + c^2)(b^2 + d^2) - (ab + cd)^2 \\\\\n= a^2b^2 + a^2d^2 + c^2b^2 + c^2d^2 - (a^2b^2 + 2abcd + c^2d^2) \\\\\n= a^2d^2 - 2abcd + c^2b^2 \\\\\n= (ad - bc)^2\n$$\n我们注意到 $ad-bc$ 就是 $\\det \\boldsymbol{F}$，所以 $\\det \\boldsymbol{C} = (\\det \\boldsymbol{F})^2$。特征方程简化为：\n$$\n\\mu^2 - \\text{tr}(\\boldsymbol{C})\\mu + \\det(\\boldsymbol{C}) = 0\n$$\n将迹和行列式用 $a,b,c,d$ 的表达式代入：\n$$\n\\mu^2 - (a^2 + b^2 + c^2 + d^2)\\mu + (ad - bc)^2 = 0\n$$\n我们使用二次方程求根公式求解这个关于特征值 $\\mu$ 的二次方程：\n$$\n\\mu = \\frac{-[-(a^2+b^2+c^2+d^2)] \\pm \\sqrt{(-(a^2+b^2+c^2+d^2))^2 - 4(1)((ad-bc)^2)}}{2(1)}\n$$\n$$\n\\mu_{1,2} = \\frac{1}{2} \\left( (a^2+b^2+c^2+d^2) \\pm \\sqrt{(a^2+b^2+c^2+d^2)^2 - 4(ad-bc)^2} \\right)\n$$\n张量 $\\boldsymbol{C}$ 是对称且正定的（因为 $\\det \\boldsymbol{C} = (\\det \\boldsymbol{F})^2  0$），所以其特征值 $\\mu_1$ 和 $\\mu_2$ 是实数且为正。主伸长是这些特征值的正平方根，即 $\\lambda_1 = \\sqrt{\\mu_1}$ 和 $\\lambda_2 = \\sqrt{\\mu_2}$。\n\n为了按非递减顺序列出它们，我们将 $\\lambda_1$ 赋为较小的值，$\\lambda_2$ 赋为较大的值。这对应于 $\\mu_1$ 使用减号，$\\mu_2$ 使用加号。\n\n较小的主伸长 $\\lambda_1$ 是：\n$$\n\\lambda_1 = \\sqrt{\\frac{1}{2} \\left( (a^2+b^2+c^2+d^2) - \\sqrt{(a^2+b^2+c^2+d^2)^2 - 4(ad-bc)^2} \\right)}\n$$\n较大的主伸长 $\\lambda_2$ 是：\n$$\n\\lambda_2 = \\sqrt{\\frac{1}{2} \\left( (a^2+b^2+c^2+d^2) + \\sqrt{(a^2+b^2+c^2+d^2)^2 - 4(ad-bc)^2} \\right)}\n$$\n这些就是两个主伸长关于变形梯度 $\\boldsymbol{F}$ 各分量的闭式解析表达式。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} \\sqrt{\\frac{1}{2} \\left( a^2+b^2+c^2+d^2 - \\sqrt{(a^2+b^2+c^2+d^2)^2 - 4(ad-bc)^2} \\right)}  \\sqrt{\\frac{1}{2} \\left( a^2+b^2+c^2+d^2 + \\sqrt{(a^2+b^2+c^2+d^2)^2 - 4(ad-bc)^2} \\right)} \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "在从解析理论转向数值计算时，我们必须面对有限精度运算带来的挑战。理论上，$\\boldsymbol{C}$ 张量是理想的对称正定矩阵，但在实际代码中，计算误差可能引入微小的不对称性或导致其丧失正定性。本练习要求您设计一个稳健的算法，它不仅能计算主拉伸和主方向，还包含了一系列关键的“防御性”编程措施，例如强制对称化、确保正定性的特征值“地板”处理，以及为特征向量建立确定性的符号约定。这些技术对于开发稳定可靠的计算力学软件至关重要。",
            "id": "3590872",
            "problem": "您的任务是设计并实现一种稳健的算法，用于从右柯西-格林(Cauchy–Green)变形张量计算主伸长和材料主方向。目标是在存在由有限精度或建模伪影导致的小的不对称性和接近失去正定性的情况下，确保数值稳健性。您的实现必须是一个完整的、可运行的程序，该程序能为提供的测试套件生成指定的输出。\n\n基本依据和定义：\n- 令变形梯度表示为 $\\boldsymbol{F} \\in \\mathbb{R}^{3 \\times 3}$。右柯西-格林(Cauchy–Green)变形张量定义为 $\\boldsymbol{C} = \\boldsymbol{F}^{\\mathsf{T}} \\boldsymbol{F}$。\n- 对于任何对称正定(SPD)张量 $\\boldsymbol{C}$，谱定理保证存在一个标准正交特征基 $\\{\\boldsymbol{N}_i\\}_{i=1}^3$ 和非负特征值 $\\{\\mu_i\\}_{i=1}^3$，使得 $\\boldsymbol{C} = \\sum_{i=1}^3 \\mu_i \\, \\boldsymbol{N}_i \\otimes \\boldsymbol{N}_i$。\n- 主伸长 $\\{\\lambda_i\\}_{i=1}^3$ 定义为 $\\lambda_i = \\sqrt{\\mu_i}$，材料主方向是 $\\boldsymbol{C}$ 的特征向量 $\\{\\boldsymbol{N}_i\\}$。\n- 主方向必须是标准正交的，并且可以选择它们以形成一个右手系。\n\n算法要求：\n1. 输入处理：\n   - 给定一个 $3 \\times 3$ 矩阵，该矩阵可以是变形梯度 $\\boldsymbol{F}$ 或所谓的右柯西-格林(Cauchy–Green)张量 $\\boldsymbol{C}$，按如下方式构造 $\\boldsymbol{C}$：\n     - 如果输入是 $\\boldsymbol{F}$，则计算 $\\boldsymbol{C} = \\boldsymbol{F}^{\\mathsf{T}} \\boldsymbol{F}$。\n     - 如果输入是 $\\boldsymbol{C}$，则直接使用它。\n   - 通过 $\\boldsymbol{C} \\leftarrow \\frac{1}{2}(\\boldsymbol{C} + \\boldsymbol{C}^{\\mathsf{T}})$ 强制实现精确对称性。\n2. 对称正定(SPD)保障措施：\n   - 使用对称特征求解器计算对称化后 $\\boldsymbol{C}$ 的特征分解，以获得特征值 $\\{\\tilde{\\mu}_i\\}$ 和特征向量 $\\{\\tilde{\\boldsymbol{N}}_i\\}$。\n   - 定义一个下限参数 $\\varepsilon = \\max\\!\\left(10^{-12},\\,10^{-8}\\,\\lVert \\boldsymbol{C} \\rVert_2\\right)$，其中 $\\lVert \\cdot \\rVert_2$ 是谱范数。\n   - 构造修正后的特征值 $\\mu_i = \\max(\\tilde{\\mu}_i, \\varepsilon)$，并重构SPD张量 $\\boldsymbol{C}_{\\text{spd}} = \\sum_{i=1}^3 \\mu_i \\, \\tilde{\\boldsymbol{N}}_i \\otimes \\tilde{\\boldsymbol{N}}_i$。\n3. 主伸长和主方向：\n   - 计算 $\\lambda_i = \\sqrt{\\mu_i}$。\n   - 将三元组 $\\{(\\lambda_i, \\tilde{\\boldsymbol{N}}_i)\\}$ 按 $\\lambda_i$ 的非递增顺序排序。\n   - 对特征向量强制执行确定性的符号约定：\n     - 对于每个特征向量，使其绝对值最大的分量为正。\n     - 此调整后，如果特征向量矩阵的行列式为负，则翻转与最小 $\\lambda_i$ 相关联的特征向量的符号，以确保得到一个右手基。\n4. 重构与诊断：\n   - 使用调整和排序后的特征对重构 $\\widehat{\\boldsymbol{C}} = \\sum_{i=1}^3 \\lambda_i^2 \\, \\boldsymbol{N}_i \\otimes \\boldsymbol{N}_i$，并计算最大绝对重构残差 $e_{\\max} = \\max_{j,k} \\left| \\widehat{\\boldsymbol{C}}_{jk} - (\\boldsymbol{C}_{\\text{spd}})_{jk} \\right|$。\n   - 同时，计算SPD修正前对称化输入的最小原始特征值 $\\tilde{\\mu}_{\\min} = \\min_i \\tilde{\\mu}_i$，作为一项诊断指标，以揭示SPD修正是否被激活。\n\n角度单位说明：\n- 测试套件中的所有旋转角度均以弧度为单位。\n\n测试套件：\n您的程序必须在以下五个案例上评估该算法，每个案例由确定变形梯度 $\\boldsymbol{F}$ 或原始张量 $\\boldsymbol{C}$ 的参数定义。旋转是通过轴-角公式构造的。对于任何轴向量 $a \\in \\mathbb{R}^3$，使用归一化的单位轴 $\\hat{a} = a/\\lVert a \\rVert$，并通过罗德里格斯(Rodrigues)公式定义旋转矩阵：\n$$\n\\boldsymbol{R}(\\hat{a},\\theta) = \\cos\\theta \\, \\boldsymbol{I} + \\sin\\theta \\, [\\hat{a}]_{\\times} + (1-\\cos\\theta)\\,\\hat{a}\\hat{a}^{\\mathsf{T}},\n$$\n其中 $[\\hat{a}]_{\\times}$ 是与 $\\hat{a}$ 的叉积相关联的反对称矩阵。\n\n- 案例1 (一般情况，良态，输入为 $\\boldsymbol{F}$):\n  - 伸长: $s = [1.3,\\,0.85,\\,1.1]$。\n  - $\\boldsymbol{Q}_1 = \\boldsymbol{R}([1,2,3],\\,0.7)$。\n  - $\\boldsymbol{U}_1 = \\boldsymbol{Q}_1 \\,\\mathrm{diag}(s)\\, \\boldsymbol{Q}_1^{\\mathsf{T}}$。\n  - $\\boldsymbol{R}_1 = \\boldsymbol{R}([0.5,-1,0.3],\\,-0.4)$。\n  - 输入 $\\boldsymbol{F} = \\boldsymbol{R}_1 \\boldsymbol{U}_1$。\n\n- 案例2 (近乎重复的特征值，输入为 $\\boldsymbol{F}$):\n  - 伸长: $s = [1.0,\\,1.0,\\,1.000001]$。\n  - $\\boldsymbol{Q}_2 = \\boldsymbol{R}([1,0,0],\\,1.2)$。\n  - $\\boldsymbol{U}_2 = \\boldsymbol{Q}_2 \\,\\mathrm{diag}(s)\\, \\boldsymbol{Q}_2^{\\mathsf{T}}$。\n  - $\\boldsymbol{R}_2 = \\boldsymbol{R}([0,1,0],\\,0.3)$。\n  - 输入 $\\boldsymbol{F} = \\boldsymbol{R}_2 \\boldsymbol{U}_2$。\n\n- 案例3 (含噪声且轻微不定的输入，输入为 $\\boldsymbol{C}$):\n  - 真实伸长: $s = [1.5,\\,1.2,\\,0.7]$。\n  - $\\boldsymbol{Q}_3 = \\boldsymbol{R}([-0.2,1,0.7],\\,1.0)$。\n  - $\\boldsymbol{C}_{\\text{true}} = \\boldsymbol{Q}_3 \\,\\mathrm{diag}(s^2)\\, \\boldsymbol{Q}_3^{\\mathsf{T}}$。\n  - 令 $v_{\\min}$ 为与最小特征值 $0.7^2$ 相关联的 $\\boldsymbol{C}_{\\text{true}}$ 的特征向量。\n  - 构造 $\\boldsymbol{C}_{\\text{bad}} = \\boldsymbol{C}_{\\text{true}} - 0.5\\, v_{\\min} v_{\\min}^{\\mathsf{T}} + \\Delta$，其中 $\\Delta$ 是一个反对称扰动，其元素数量级为 $10^{-8}$，由一个固定的种子生成以保证可复现性。\n  - 输入 $\\boldsymbol{C} = \\boldsymbol{C}_{\\text{bad}}$。\n\n- 案例4 (类平面应变 $\\boldsymbol{F}$):\n  - 输入\n    $$\n    \\boldsymbol{F} = \\begin{bmatrix}\n    1.2  0.3  0 \\\\\n    0.1  0.9  0 \\\\\n    0  0  1.0\n    \\end{bmatrix}.\n    $$\n\n- 案例5 (带旋转的各向同性伸长，输入为 $\\boldsymbol{F}$):\n  - 各向同性伸长因子 $\\alpha = 1.05$。\n  - $\\boldsymbol{R}_5 = \\boldsymbol{R}([1,-1,0.5],\\,0.9)$。\n  - 输入 $\\boldsymbol{F} = \\alpha \\, \\boldsymbol{R}_5$。\n\n要求的输出与格式：\n- 对于每个案例，计算：\n  - 主伸长 $\\lambda_1 \\ge \\lambda_2 \\ge \\lambda_3$。\n  - 如上定义的最大绝对重构残差 $e_{\\max}$。\n  - SPD修正前的最小原始特征值 $\\tilde{\\mu}_{\\min}$。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个案例对应一个形如 $[\\lambda_1,\\lambda_2,\\lambda_3,e_{\\max},\\tilde{\\mu}_{\\min}]$ 的子列表。\n- 所有数字必须打印小数点后恰好 $8$ 位，行内任何地方都不能有空格。\n- 总输出结构示例：\n  - $[[\\lambda_{1}^{(1)},\\lambda_{2}^{(1)},\\lambda_{3}^{(1)},e_{\\max}^{(1)},\\tilde{\\mu}_{\\min}^{(1)}],[\\lambda_{1}^{(2)},\\lambda_{2}^{(2)},\\lambda_{3}^{(2)},e_{\\max}^{(2)},\\tilde{\\mu}_{\\min}^{(2)}],\\dots]$。\n\n注意：\n- 在此问题中，伸长没有物理单位；它们是无量纲的。\n- 所有角度均使用弧度。\n- 通过遵循上述SPD保障措施和确定性特征向量定向规则来确保数值稳健性。",
            "solution": "该问题提出了一个在计算固体力学领域内有效且适定的任务。它要求设计并实现一种算法，用于从给定的变形张量计算主伸长及其对应的材料方向，并特别强调实现数值稳健性。问题陈述具有科学依据，内容自洽，并提供了一个清晰、确定性的操作流程。\n\n问题的核心在于对右柯西-格林(Cauchy–Green)变形张量 $\\boldsymbol{C}$ 的谱分析。我们现在将阐述其求解的理论原理和相应的算法步骤。\n\n**1. 理论基础**\n\n在连续介质力学中，物体的变形被描述为物质点从参考构型到当前构型的映射。该映射的局部性质由变形梯度张量 $\\boldsymbol{F} \\in \\mathbb{R}^{3 \\times 3}$ 捕捉。\n\n右柯西-格林(Cauchy–Green)变形张量定义为：\n$$\n\\boldsymbol{C} = \\boldsymbol{F}^{\\mathsf{T}} \\boldsymbol{F}\n$$\n根据此定义，$\\boldsymbol{C}$ 是对称的，因为 $\\boldsymbol{C}^{\\mathsf{T}} = (\\boldsymbol{F}^{\\mathsf{T}} \\boldsymbol{F})^{\\mathsf{T}} = \\boldsymbol{F}^{\\mathsf{T}} (\\boldsymbol{F}^{\\mathsf{T}})^{\\mathsf{T}} = \\boldsymbol{F}^{\\mathsf{T}} \\boldsymbol{F} = \\boldsymbol{C}$。此外，对于任何非零向量 $\\boldsymbol{X} \\in \\mathbb{R}^3$，二次型 $\\boldsymbol{X}^{\\mathsf{T}} \\boldsymbol{C} \\boldsymbol{X} = \\boldsymbol{X}^{\\mathsf{T}} \\boldsymbol{F}^{\\mathsf{T}} \\boldsymbol{F} \\boldsymbol{X} = (\\boldsymbol{F}\\boldsymbol{X})^{\\mathsf{T}} (\\boldsymbol{F}\\boldsymbol{X}) = \\lVert \\boldsymbol{F}\\boldsymbol{X} \\rVert^2 \\ge 0$。如果 $\\boldsymbol{F}$ 可逆（即 $\\det(\\boldsymbol{F})  0$，这是对物理变形的标准要求），那么对于 $\\boldsymbol{X} \\neq \\boldsymbol{0}$，有 $\\boldsymbol{F}\\boldsymbol{X} \\neq \\boldsymbol{0}$，这意味着 $\\boldsymbol{X}^{\\mathsf{T}} \\boldsymbol{C} \\boldsymbol{X}  0$。因此，$\\boldsymbol{C}$ 是一个对称正定(SPD)张量。\n\n对称矩阵的谱定理保证 $\\boldsymbol{C}$ 有一组三个实特征值 $\\{\\mu_i\\}_{i=1}^3$ 和一个相应的标准正交特征向量基 $\\{\\boldsymbol{N}_i\\}_{i=1}^3$。$\\boldsymbol{C}$ 的谱分解为：\n$$\n\\boldsymbol{C} = \\sum_{i=1}^3 \\mu_i \\, \\boldsymbol{N}_i \\otimes \\boldsymbol{N}_i\n$$\n其中 $\\boldsymbol{N}_i \\otimes \\boldsymbol{N}_i$ 表示外积 $\\boldsymbol{N}_i \\boldsymbol{N}_i^{\\mathsf{T}}$。由于 $\\boldsymbol{C}$ 是正定的，其所有特征值 $\\mu_i$ 都是严格为正的。\n\n主伸长，记为 $\\lambda_i$，是 $\\boldsymbol{C}$ 的特征值的正平方根：\n$$\n\\lambda_i = \\sqrt{\\mu_i}\n$$\n物理上，主伸长代表了无限小线元沿主方向被拉伸的因子。材料主方向是 $\\boldsymbol{C}$ 的特征向量 $\\{\\boldsymbol{N}_i\\}$。这些方向构成一个固定在材料参考构型中的标准正交三轴系，在变形时，它们之间仅发生拉伸而无相对旋转。\n\n**2. 算法实现与稳健性**\n\n问题指定了一个精确的算法以确保数值稳健性，我们现在将对此进行详细说明。\n\n**步骤2.1：张量构造与对称化**\n输入是变形梯度 $\\boldsymbol{F}$ 或一个所谓的张量 $\\boldsymbol{C}$。\n- 如果提供的是 $\\boldsymbol{F}$，我们计算 $\\boldsymbol{C} = \\boldsymbol{F}^{\\mathsf{T}} \\boldsymbol{F}$。\n- 如果提供的是原始的 $\\boldsymbol{C}$，我们直接使用它。\n\n在浮点运算中，计算出的或提供的 $\\boldsymbol{C}$ 可能存在微小的不对称性。为确保对称矩阵特征求解器的适用性，我们显式地强制对称性：\n$$\n\\boldsymbol{C}_{\\text{sym}} \\leftarrow \\frac{1}{2}(\\boldsymbol{C} + \\boldsymbol{C}^{\\mathsf{T}})\n$$\n此操作将近对称张量投影到对称张量空间上，移除了任何反对称分量。\n\n**步骤2.2：对称正定(SPD)保障措施**\n数值误差可能导致理论上为SPD的矩阵出现小的负特征值。这将妨碍实值主伸长($\\lambda_i = \\sqrt{\\mu_i}$)的计算。因此，保障措施是必要的。\n\n首先，我们对对称化后的张量 $\\boldsymbol{C}_{\\text{sym}}$ 进行特征分解：\n$$\n\\boldsymbol{C}_{\\text{sym}} \\boldsymbol{N}_i = \\tilde{\\mu}_i \\boldsymbol{N}_i\n$$\n这会产生“原始”特征值 $\\{\\tilde{\\mu}_i\\}$ 及其对应的特征向量 $\\{\\tilde{\\boldsymbol{N}}_i\\}$。为此，我们使用专门的对称特征求解器，例如 `numpy.linalg.eigh` 提供的求解器。\n\n接着，我们定义一个下限值 $\\varepsilon$ 来强制特征值的正性：\n$$\n\\varepsilon = \\max\\left(10^{-12}, \\, 10^{-8} \\lVert \\boldsymbol{C}_{\\text{sym}} \\rVert_2\\right)\n$$\n其中 $\\lVert \\boldsymbol{C}_{\\text{sym}} \\rVert_2$ 是 $\\boldsymbol{C}_{\\text{sym}}$ 的谱范数，等于其最大的绝对特征值。这种混合的绝对/相对容差可防止特征值变为非正值。我们按如下方式计算修正后的特征值 $\\mu_i$：\n$$\n\\mu_i = \\max(\\tilde{\\mu}_i, \\varepsilon)\n$$\n一个关键的诊断量 $\\tilde{\\mu}_{\\min} = \\min_i(\\tilde{\\mu}_i)$ 被保留下来，以追踪此修正是否被激活。\n\n使用这些修正后的特征值，我们可以定义一个严格的SPD张量 $\\boldsymbol{C}_{\\text{spd}}$：\n$$\n\\boldsymbol{C}_{\\text{spd}} = \\sum_{i=1}^3 \\mu_i \\, \\tilde{\\boldsymbol{N}}_i \\otimes \\tilde{\\boldsymbol{N}}_i\n$$\n在某些度量标准下，该张量是与原始 $\\boldsymbol{C}_{\\text{sym}}$ 最接近的SPD近似，并作为后续计算的基础。\n\n**步骤2.3：主伸长和主方向**\n主伸长由修正后的特征值计算得出：\n$$\n\\lambda_i = \\sqrt{\\mu_i}\n$$\n为了建立一个规范的表示，我们将(伸长, 方向)的三元组，即 $\\{(\\lambda_i, \\tilde{\\boldsymbol{N}}_i)\\}$，按照伸长值的非递增顺序进行排序，得到 $(\\lambda_1, \\boldsymbol{N}_1)$、$(\\lambda_2, \\boldsymbol{N}_2)$、$(\\lambda_3, \\boldsymbol{N}_3)$，使得 $\\lambda_1 \\ge \\lambda_2 \\ge \\lambda_3$。\n\n特征向量的唯一性只到符号为止。为确保结果的确定性，我们强制执行一个符号约定。\n1. 对于每个排序后的特征向量 $\\boldsymbol{N}_i$，我们找到其绝对值最大的分量。如果该分量为负，则翻转整个特征向量的符号 ($\\boldsymbol{N}_i \\leftarrow -\\boldsymbol{N}_i$)。\n2. 调整完所有三个特征向量后，我们通过计算矩阵 $[\\boldsymbol{N}_1 \\, \\boldsymbol{N}_2 \\, \\boldsymbol{N}_3]$ 的行列式来检查它们是否构成一个右手系。如果行列式为负（接近-1），我们就翻转与最小伸长相关联的特征向量 $\\boldsymbol{N}_3$ 的符号，即 $\\boldsymbol{N}_3 \\leftarrow -\\boldsymbol{N}_3$。这确保了基 $\\{\\boldsymbol{N}_1, \\boldsymbol{N}_2, \\boldsymbol{N}_3\\}$ 是右手的。\n\n**步骤2.4：重构与诊断**\n最后，计算两个诊断量。\n首先，我们根据最终的、经过排序和定向的主伸长与主方向来重构张量 $\\widehat{\\boldsymbol{C}}$：\n$$\n\\widehat{\\boldsymbol{C}} = \\sum_{i=1}^3 \\lambda_i^2 \\, \\boldsymbol{N}_i \\otimes \\boldsymbol{N}_i\n$$\n最大绝对重构残差 $e_{\\max}$ 衡量了此重构张量与经过保障措施处理的SPD张量之间的差异：\n$$\ne_{\\max} = \\max_{j,k} \\left| \\widehat{\\boldsymbol{C}}_{jk} - (\\boldsymbol{C}_{\\text{spd}})_{jk} \\right|\n$$\n理论上，这个残差应该在机器精度内为零，因为对特征向量的符号翻转操作不会改变外积 $\\boldsymbol{N}_i \\boldsymbol{N}_i^{\\mathsf{T}}$。这个检查验证了特征分解和重构过程的内部一致性。\n\n第二项诊断是 $\\tilde{\\mu}_{\\min}$，即SPD修正前的最小原始特征值。一个负的 $\\tilde{\\mu}_{\\min}$ 值表明初始张量不是正定的，且保障措施至关重要。\n\n这个全面、分步的程序提供了一种稳健且确定性的方法来计算主伸长和主方向，适用于在计算力学代码中实现。所提供的测试套件允许在从行为良好的案例到具有近乎重复的特征值和失去正定性等数值挑战的各种场景中进行验证。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to compute principal stretches and directions for a suite of test cases.\n    \"\"\"\n\n    def skew(v):\n        \"\"\"\n        Returns the skew-symmetric matrix for a 3D vector.\n        \"\"\"\n        return np.array([[0, -v[2], v[1]],\n                         [v[2], 0, -v[0]],\n                         [-v[1], v[0], 0]])\n\n    def rodrigues_formula(axis, angle):\n        \"\"\"\n        Computes the rotation matrix using Rodrigues' formula.\n        R(a, theta) = cos(theta)*I + sin(theta)*[a]x + (1-cos(theta))*a*a^T\n        \"\"\"\n        a = np.asarray(axis)\n        a = a / np.linalg.norm(a)\n        \n        I = np.identity(3)\n        K = skew(a)\n        \n        # Using the formulation with the outer product for clarity\n        # R = np.cos(angle) * I + np.sin(angle) * K + (1 - np.cos(angle)) * np.outer(a, a)\n        \n        # Using the K@K = a*a^T - I formulation\n        R = I + np.sin(angle) * K + (1 - np.cos(angle)) * (K @ K)\n        return R\n\n    def process_tensor(tensor, is_F):\n        \"\"\"\n        Performs the full analysis on a given tensor (F or C).\n        \"\"\"\n        # Step 1: Input handling and Symmetrization\n        if is_F:\n            F = tensor\n            C = F.T @ F\n        else:\n            C = tensor\n        \n        C_sym = 0.5 * (C + C.T)\n\n        # Step 2: SPD Safeguard\n        # Compute eigen-decomposition of symmetrized C\n        # np.linalg.eigh returns eigenvalues in ascending order\n        raw_mu, raw_N = np.linalg.eigh(C_sym)\n        mu_min_raw = raw_mu[0] # Smallest raw eigenvalue\n\n        # Define floor parameter epsilon\n        norm_C = np.max(np.abs(raw_mu))\n        epsilon = max(1e-12, 1e-8 * norm_C)\n\n        # Form corrected eigenvalues\n        mu = np.maximum(raw_mu, epsilon)\n\n        # Reconstruct the SPD tensor\n        C_spd = raw_N @ np.diag(mu) @ raw_N.T\n\n        # Step 3: Principal Stretches and Directions\n        # Compute principal stretches\n        lambdas = np.sqrt(mu)\n\n        # Sort triplets {lambda_i, N_i} in non-increasing order of lambda_i\n        # eigh sorts eigenvalues ascending, so we reverse the order.\n        sorted_indices = np.argsort(lambdas)[::-1]\n        lambdas_sorted = lambdas[sorted_indices]\n        N_sorted = raw_N[:, sorted_indices]\n\n        # Enforce deterministic sign convention on eigenvectors\n        for i in range(3):\n            vec = N_sorted[:, i]\n            max_abs_idx = np.argmax(np.abs(vec))\n            if vec[max_abs_idx]  0:\n                N_sorted[:, i] *= -1\n\n        # Enforce right-handed basis\n        if np.linalg.det(N_sorted)  0:\n            # Flip sign of the eigenvector associated with the smallest lambda\n            N_sorted[:, 2] *= -1\n\n        # Step 4: Reconstruction and Diagnostics\n        # Reconstruct C_hat\n        lambda_sq = lambdas_sorted**2\n        C_hat = N_sorted @ np.diag(lambda_sq) @ N_sorted.T\n\n        # Compute max absolute reconstruction residual\n        e_max = np.max(np.abs(C_hat - C_spd))\n        \n        l1, l2, l3 = lambdas_sorted\n        return [l1, l2, l3, e_max, mu_min_raw]\n\n    # --- Test Suite ---\n    \n    # Case 1: General, well-conditioned, input as F\n    s1 = np.array([1.3, 0.85, 1.1])\n    Q1 = rodrigues_formula([1, 2, 3], 0.7)\n    U1 = Q1 @ np.diag(s1) @ Q1.T\n    R1 = rodrigues_formula([0.5, -1, 0.3], -0.4)\n    F1 = R1 @ U1\n    \n    # Case 2: Nearly repeated eigenvalues, input as F\n    s2 = np.array([1.0, 1.0, 1.000001])\n    Q2 = rodrigues_formula([1, 0, 0], 1.2)\n    U2 = Q2 @ np.diag(s2) @ Q2.T\n    R2 = rodrigues_formula([0, 1, 0], 0.3)\n    F2 = R2 @ U2\n    \n    # Case 3: Noisy and slightly indefinite input as C\n    s3 = np.array([1.5, 1.2, 0.7])\n    Q3 = rodrigues_formula([-0.2, 1, 0.7], 1.0)\n    C_true = Q3 @ np.diag(s3**2) @ Q3.T\n    mu_true, N_true = np.linalg.eigh(C_true)\n    v_min = N_true[:, 0] # Eigenvector for smallest eigenvalue\n    # Create reproducible antisymmetric perturbation\n    np.random.seed(0)\n    D_rand = np.random.rand(3, 3) * 1e-8\n    Delta = D_rand - D_rand.T\n    C_bad = C_true - 0.5 * np.outer(v_min, v_min) + Delta\n\n    # Case 4: Plane strain-like F\n    F4 = np.array([[1.2, 0.3, 0],\n                   [0.1, 0.9, 0],\n                   [0, 0, 1.0]])\n\n    # Case 5: Isotropic stretch with rotation, input as F\n    alpha5 = 1.05\n    R5 = rodrigues_formula([1, -1, 0.5], 0.9)\n    F5 = alpha5 * R5\n\n    test_cases = [\n        (F1, True),\n        (F2, True),\n        (C_bad, False),\n        (F4, True),\n        (F5, True)\n    ]\n    \n    results = []\n    for tensor, is_F in test_cases:\n        case_result = process_tensor(tensor, is_F)\n        results.append(case_result)\n\n    # Format output\n    result_strings = []\n    for res in results:\n        formatted_res = \",\".join([f\"{x:.8f}\" for x in res])\n        result_strings.append(f\"[{formatted_res}]\")\n    \n    final_output = f\"[{','.join(result_strings)}]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "在上一个练习中，我们为单个单元开发了一个稳健的计算方法，但当我们将视角扩展到整个有限元网格时，新的挑战便出现了。由于特征向量固有地存在符号模糊性（如果 $\\mathbf{n}$ 是一个特征向量，那么 $-\\mathbf{n}$ 也是），天真的求解器可能会在相邻单元间产生不连续的主方向场。本练习通过一个实际的编程任务来解决此问题，您将实现一个基于图遍历的算法来强制主方向场的连续性。这项实践对于正确模拟各项异性材料（如生物组织中的纤维增强）至关重要，因为在这些模型中，物理响应直接依赖于材料方向的连续性。",
            "id": "3590949",
            "problem": "您将获得实现离散体中主方向的稳健方向连续性校正的程序和数据。从以下基本概念开始：变形梯度 $\\mathbf{F}$、右柯西-格林张量 $\\mathbf{C} = \\mathbf{F}^{\\mathsf{T}} \\mathbf{F}$，以及通过 $\\mathbf{C}$ 的谱分解定义的主伸长和主方向。对于每个单元 $e$，设 $\\mathbf{C}^{(e)}$ 为对称正定矩阵，其特征对为 $\\left(\\mu_i^{(e)}, \\mathbf{n}_i^{(e)}\\right)$，其中 $\\mu_i^{(e)}  0$ 是特征值，$\\mathbf{n}_i^{(e)}$ 是相关的单位特征向量。定义主伸长为 $\\lambda_i^{(e)} = \\sqrt{\\mu_i^{(e)}}$，并对特征对进行排序，使得 $\\lambda_1^{(e)} \\ge \\lambda_2^{(e)} \\ge \\lambda_3^{(e)}$。回想一下，特征向量的定义只到符号为止：如果 $\\mathbf{n}_i^{(e)}$ 是一个特征向量，那么 $-\\mathbf{n}_i^{(e)}$ 也是。在网格计算中，这种符号模糊性可能导致相邻单元之间主方向的定向不连续，必须对其进行校正，以获得一致的基于纤维的模型项。\n\n您的任务是实现一个程序，为每个提供的测试用例完成以下操作：\n- 从 $\\mathbf{C}^{(e)}$ 计算每个单元 $e$ 的主导主方向 $\\mathbf{n}_1^{(e)}$。\n- 应用指定的人工符号掩码 $s^{(e)} \\in \\{-1, +1\\}$ 以模拟来自朴素特征求解器的符号模糊性，产生 $\\tilde{\\mathbf{n}}_1^{(e)} = s^{(e)} \\mathbf{n}_1^{(e)}$。\n- 使用基于邻接关系的图遍历，在网格单元间执行符号连续性校正，当与已定向邻居的点积为负时，翻转 $\\tilde{\\mathbf{n}}_1^{(e)} \\mapsto -\\tilde{\\mathbf{n}}_1^{(e)}$，以强制实现局部连续性。使用广度优先搜索，从索引最低的非简并单元开始作为根参考。如果相对谱隙低于阈值 $\\tau$，则单元 $e$ 被认为是方向简并的，即如果\n$$\n\\frac{\\lambda_1^{(e)} - \\lambda_2^{(e)}}{\\max\\left(\\lambda_1^{(e)}, \\varepsilon\\right)}  \\tau,\n$$\n在这种情况下，该方向不可靠，不应用于向其邻居传播方向，其符号也不应被连续性算法改变。取 $\\tau = 10^{-6}$ 和 $\\varepsilon = 10^{-12}$。\n- 量化符号翻转对两类依赖于纤维的项的影响：\n    1. 一个二次依赖于 $\\mathbf{n}_1^{(e)}$ 的偶数项，您必须使用\n       $$\n       p^{(e)} = \\left(\\tilde{\\mathbf{n}}_1^{(e)}\\right)^{\\mathsf{T}} \\mathbf{C}^{(e)} \\tilde{\\mathbf{n}}_1^{(e)},\n       $$\n       并确认此量在符号校正下在数值容差范围内是不变的。\n    2. 一个线性依赖于 $\\mathbf{n}_1^{(e)}$ 的奇数项，您必须使用主动纤维牵引矢量\n       $$\n       \\mathbf{t}^{(e)} = t_0 \\tilde{\\mathbf{n}}_1^{(e)},\n       $$\n       并将连续性校正引起的总变化度量为\n       $$\n       \\Delta_{\\text{odd}} = \\sum_{e} \\left\\| \\mathbf{t}^{(e)}_{\\text{corrected}} - \\mathbf{t}^{(e)}_{\\text{naive}} \\right\\|_2.\n       $$\n在此任务中，符号连续性算法必须仅对主导主方向 $\\mathbf{n}_1^{(e)}$ 操作。在每个测试用例中，使用相同的邻接关系遍历所有单元。将所有量视为无量纲。\n\n对于每个测试用例，您的程序必须返回一个包含三个条目的列表：\n- 一个布尔值，指示偶数项在符号校正下是否不变，定义为 $\\max_e \\left| p^{(e)}_{\\text{corrected}} - p^{(e)}_{\\text{naive}} \\right|  10^{-10}$。\n- 一个整数，等于连续性算法对主导主方向执行的单元级符号翻转总数。\n- 一个浮点数，等于上面定义的 $\\Delta_{\\text{odd}}$。\n\n您的程序必须处理以下测试套件。在所有情况下，单元索引从 $0$ 开始，邻接关系以单元索引之间的无向边形式给出。所有矩阵均为 $3 \\times 3$，所有向量均为 $3 \\times 1$。\n\n测试用例 1（链状，各向异性，带模拟符号翻转）：\n- 单元数量：$5$。\n- 邻接边：$(0,1)$, $(1,2)$, $(2,3)$, $(3,4)$。\n- 变形梯度 $\\mathbf{F}^{(e)}$:\n  $$\n  \\mathbf{F}^{(0)} = \\begin{bmatrix} 1.2  -0.10  0.0 \\\\ 0.0  0.8333333333333334  0.0 \\\\ 0.0  0.0  1.0 \\end{bmatrix},\\quad\n  \\mathbf{F}^{(1)} = \\begin{bmatrix} 1.2  -0.05  0.0 \\\\ 0.0  0.8333333333333334  0.02 \\\\ 0.0  0.0  1.0 \\end{bmatrix},\\\\\n  \\mathbf{F}^{(2)} = \\begin{bmatrix} 1.2  0.0  0.0 \\\\ 0.0  0.8333333333333334  0.04 \\\\ 0.0  0.0  1.0 \\end{bmatrix},\\quad\n  \\mathbf{F}^{(3)} = \\begin{bmatrix} 1.2  0.05  0.0 \\\\ 0.0  0.8333333333333334  0.06 \\\\ 0.0  0.0  1.0 \\end{bmatrix},\\quad\n  \\mathbf{F}^{(4)} = \\begin{bmatrix} 1.2  0.10  0.0 \\\\ 0.0  0.8333333333333334  0.08 \\\\ 0.0  0.0  1.0 \\end{bmatrix}.\n  $$\n- 主导方向的人工符号掩码 $s^{(e)}$：$[+1,-1,+1,-1,+1]$。\n- 主动牵引振幅 $t_0 = 1.0$。\n\n测试用例 2（链状，强各向异性但无模拟翻转）：\n- 单元数量：$4$。\n- 邻接边：$(0,1)$, $(1,2)$, $(2,3)$。\n- 变形梯度 $\\mathbf{F}^{(e)}$:\n  $$\n  \\mathbf{F}^{(0)} = \\mathbf{F}^{(1)} = \\mathbf{F}^{(2)} = \\mathbf{F}^{(3)} = \\begin{bmatrix} 1.5  0.0  0.0 \\\\ 0.0  0.9  0.0 \\\\ 0.0  0.0  1.1 \\end{bmatrix}.\n  $$\n- 主导方向的人工符号掩码 $s^{(e)}$：$[+1,+1,+1,+1]$。\n- 主动牵引振幅 $t_0 = 1.3$。\n\n测试用例 3（二维网格邻接，各向异性，带模拟符号翻转）：\n- 单元数量：4，具有 2 x 2 连接性。\n- 邻接边：$(0,1)$, $(0,2)$, $(1,3)$, $(2,3)$。\n- 变形梯度 $\\mathbf{F}^{(e)}$:\n  $$\n  \\mathbf{F}^{(0)} = \\begin{bmatrix} 1.4  0.05  0.0 \\\\ 0.0  0.95  0.0 \\\\ 0.0  0.0  1.05 \\end{bmatrix},\\quad\n  \\mathbf{F}^{(1)} = \\begin{bmatrix} 1.38  -0.04  0.0 \\\\ 0.0  0.95  0.02 \\\\ 0.0  0.0  1.05 \\end{bmatrix},\\\\\n  \\mathbf{F}^{(2)} = \\begin{bmatrix} 1.42  0.06  0.0 \\\\ 0.0  0.95  -0.02 \\\\ 0.0  0.0  1.05 \\end{bmatrix},\\quad\n  \\mathbf{F}^{(3)} = \\begin{bmatrix} 1.39  0.00  0.0 \\\\ 0.0  0.95  0.0 \\\\ 0.0  0.0  1.05 \\end{bmatrix}.\n  $$\n- 主导方向的人工符号掩码 $s^{(e)}$：$[-1,+1,-1,+1]$。\n- 主动牵引振幅 $t_0 = 0.7$。\n\n定义和计算要求：\n- 对每个单元 $e$，计算 $\\mathbf{C}^{(e)} = \\left(\\mathbf{F}^{(e)}\\right)^{\\mathsf{T}} \\mathbf{F}^{(e)}$。\n- 计算 $\\mathbf{C}^{(e)}$ 的特征对，按 $\\lambda_i^{(e)} = \\sqrt{\\mu_i^{(e)}}$ 降序排序，并选择 $\\mathbf{n}_1^{(e)}$。\n- 形成朴素方向 $\\tilde{\\mathbf{n}}_1^{(e)} = s^{(e)} \\mathbf{n}_1^{(e)}$。\n- 使用广度优先搜索沿网格应用符号连续性校正，从相对谱隙大于 $\\tau = 10^{-6}$ 的索引最低的非简并单元开始。如果所有单元都是简并的，则不进行校正。\n- 计算校正前后的偶数项 $p^{(e)}$，并验证其在 $10^{-10}$ 容差内的不变性。\n- 计算 $\\Delta_{\\text{odd}}$，即牵引矢量 $\\mathbf{t}^{(e)}$ 变化的欧几里得范数在所有单元上的总和。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含三个测试用例的结果，格式为一个由方括号括起来的逗号分隔列表，其中每个测试用例的结果本身是一个方括号括起来的逗号分隔列表，顺序为 $\\left[\\text{even\\_ok}, \\text{flips\\_corrected}, \\Delta_{\\text{odd}}\\right]$。布尔值必须打印为 True 或 False，整数为十进制数字，浮点数为十进制小数。例如，一个包含三个测试用例的有效输出格式为 $[\\,[\\text{True},2,4.000000],[\\text{True},0,0.000000],[\\text{True},1,1.400000]\\,]$。不应打印任何其他文本。",
            "solution": "所提出的问题是计算固体力学中一个明确定义的练习，专注于有限元分析中特征向量符号模糊性的实际问题。任务是实现一种算法，以在离散化域上强制主材料方向的定向连续性。该问题在科学上是合理的，在算法上是明确的，并且提供了解决该问题所需的所有数据。因此，它被认为是有效的。\n\n该解决方案是通过遵循源于连续介质力学和图论原理的一系列步骤来实现的。\n\n### 第 1 部分：单元运动学和谱分析\n\n首先，对于网格中的每个单元 $e$，我们分析其变形状态。变形由变形梯度张量 $\\mathbf{F}^{(e)}$ 描述。由此，我们计算右柯西-格林张量 $\\mathbf{C}^{(e)}$，它是一个对称正定张量，表征材料参考构型中的局部应变。\n\n$$\n\\mathbf{C}^{(e)} = \\left(\\mathbf{F}^{(e)}\\right)^{\\mathsf{T}} \\mathbf{F}^{(e)}\n$$\n\n主伸长 $\\lambda_i^{(e)}$ 和主方向 $\\mathbf{n}_i^{(e)}$ 是描述最大、最小和中间拉伸的大小和方向的基本运动学量。它们通过 $\\mathbf{C}^{(e)}$ 的谱分解获得：\n\n$$\n\\mathbf{C}^{(e)} \\mathbf{n}_i^{(e)} = \\mu_i^{(e)} \\mathbf{n}_i^{(e)}\n$$\n\n这里，$\\mu_i^{(e)}$ 是特征值，$\\mathbf{n}_i^{(e)}$ 是相应的标准正交特征向量。主伸长是特征值的平方根：$\\lambda_i^{(e)} = \\sqrt{\\mu_i^{(e)}}$。对于这个问题，我们关心的是与最大主伸长相对应的主导主方向。特征对被排序以使得 $\\lambda_1^{(e)} \\ge \\lambda_2^{(e)} \\ge \\lambda_3^{(e)}$。因此，主导主方向是 $\\mathbf{n}_1^{(e)}$。\n\n数值特征求解器将返回一组标准正交特征向量。然而，对于任何特征向量 $\\mathbf{n}_i^{(e)}$，向量 $-\\mathbf{n}_i^{(e)}$ 也是一个有效的特征向量。这种符号模糊性是固有的。虽然特定的特征求解器可能对给定矩阵产生确定性输出，但在比较相邻单元的略有不同的矩阵的结果时，符号可能看起来是随机的。为了模拟这一点，问题提供了一个人工符号掩码 $s^{(e)} \\in \\{-1, +1\\}$，应用于计算出的主导方向以生成一组“朴素”的方向：\n\n$$\n\\tilde{\\mathbf{n}}_{1, \\text{naive}}^{(e)} = s^{(e)} \\mathbf{n}_1^{(e)}\n$$\n\n### 第 2 部分：简并条件\n\n唯一主导主方向的概念仅在最大主伸长明显大于第二大主伸长时才具有物理和数值意义。如果 $\\lambda_1^{(e)} \\approx \\lambda_2^{(e)}$，则材料在由 $\\mathbf{n}_1^{(e)}$ 和 $\\mathbf{n}_2^{(e)}$ 张成的平面内是近各向同性的，并且该平面中的任何方向几乎都是主方向。此时计算出的 $\\mathbf{n}_1^{(e)}$ 在数值上是敏感的，不可靠于定义材料纤维方向。\n\n我们使用提供的相对谱隙准则来识别此类“简并”单元。如果满足以下条件，则单元 $e$ 被认为是简并的：\n$$\n\\frac{\\lambda_1^{(e)} - \\lambda_2^{(e)}}{\\max\\left(\\lambda_1^{(e)}, \\varepsilon\\right)}  \\tau\n$$\n其中 $\\tau = 10^{-6}$ 是一个小阈值，$\\varepsilon = 10^{-12}$ 是一个防止除以零的正则化参数。简并单元被排除在符号校正逻辑之外；它们的方向不用于影响邻居，也不会被邻居改变。\n\n### 第 3 部分：通过广度优先搜索 (BFS) 进行符号连续性校正\n\n为了解决人工符号不连续性，应用了一种校正算法。单元网格被视为一个无向图，其中单元是节点，邻接关系定义了边。广度优先搜索 (BFS) 遍历确保方向从参考单元系统地传播。\n\n1.  **初始化**：校正后的方向数组 $\\tilde{\\mathbf{n}}_{1, \\text{corrected}}^{(e)}$ 用朴素方向进行初始化。一个布尔数组跟踪已访问的单元。一个符号翻转计数器初始化为零。\n2.  **根选择**：遍历从单个根单元开始，以建立参考方向。根被选为索引最低的非简并单元。如果所有单元都是简并的，则算法终止，不执行任何校正。\n3.  **遍历**：BFS 算法按以下方式进行：\n    a. 将根单元添加到队列中并标记为已访问。\n    b. 当队列不为空时, 出队一个单元 $u$。其方向 $\\tilde{\\mathbf{n}}_{1, \\text{corrected}}^{(u)}$ 现在被视为其局部邻域的参考。\n    c. 对于 $u$ 的每个未访问的非简并邻居 $v$：\n        i. 将邻居 $v$ 入队并标记为已访问。\n        ii. 使用点积进行一致性检查：$d = \\tilde{\\mathbf{n}}_{1, \\text{corrected}}^{(u)} \\cdot \\tilde{\\mathbf{n}}_{1, \\text{naive}}^{(v)}$。\n        iii. 如果 $d  0$，则方向是反平行的，表示方向不连续。翻转单元 $v$ 的方向向量的符号：$\\tilde{\\mathbf{n}}_{1, \\text{corrected}}^{(v)} = -\\tilde{\\mathbf{n}}_{1, \\text{naive}}^{(v)}$。翻转计数器递增。\n        iv. 如果 $d \\ge 0$，则方向是一致的，无需任何操作。\n\n此过程确保网格中所有可达的非简并单元的主导主方向相对于所选根的方向都将保持一致。\n\n### 第 4 部分：符号校正效果分析\n\n最后一步是量化符号校正对依赖于主方向的物理量的影响。\n\n1.  **偶数项不变性**：我们检查一个二次依赖于主方向的量，例如沿纤维的应变能分量，或如指定的，$p^{(e)} = (\\tilde{\\mathbf{n}}_1^{(e)})^{\\mathsf{T}} \\mathbf{C}^{(e)} \\tilde{\\mathbf{n}}_1^{(e)}$。由于 $\\mathbf{C}^{(e)}\\tilde{\\mathbf{n}}_1^{(e)} = \\mu_1^{(e)}\\tilde{\\mathbf{n}}_1^{(e)}$，这可以简化为：\n    $$\n    p^{(e)} = (\\tilde{\\mathbf{n}}_1^{(e)})^{\\mathsf{T}} (\\mu_1^{(e)} \\tilde{\\mathbf{n}}_1^{(e)}) = \\mu_1^{(e)} \\left\\| \\tilde{\\mathbf{n}}_1^{(e)} \\right\\|_2^2 = \\mu_1^{(e)}\n    $$\n    $p^{(e)}$ 的值就是 $\\mathbf{C}^{(e)}$ 的最大特征值。它与特征向量 $\\tilde{\\mathbf{n}}_1^{(e)}$ 的符号无关。因此，我们预期最大差值 $| p^{(e)}_{\\text{corrected}} - p^{(e)}_{\\text{naive}} |$ 在数值精度范围内为零。检查 $\\max_e | p^{(e)}_{\\text{corrected}} - p^{(e)}_{\\text{naive}} |  10^{-10}$ 应评估为 `True`。\n\n2.  **奇数项变化**：我们考虑一个线性依赖于主方向的项，即主动纤维牵引矢量 $\\mathbf{t}^{(e)} = t_0 \\tilde{\\mathbf{n}}_1^{(e)}$。该项对 $\\tilde{\\mathbf{n}}_1^{(e)}$ 的符号敏感。由于校正而产生的总变化由 $\\Delta_{\\text{odd}}$ 度量：\n    $$\n    \\Delta_{\\text{odd}} = \\sum_{e} \\left\\| \\mathbf{t}^{(e)}_{\\text{corrected}} - \\mathbf{t}^{(e)}_{\\text{naive}} \\right\\|_2\n    $$\n    对于符号未翻转的单元 $e$，其对总和的贡献为零。如果符号被翻转，则 $\\tilde{\\mathbf{n}}_{1, \\text{corrected}}^{(e)} = -\\tilde{\\mathbf{n}}_{1, \\text{naive}}^{(e)}$。贡献为：\n    $$\n    \\left\\| t_0 (-\\tilde{\\mathbf{n}}_{1, \\text{naive}}^{(e)}) - t_0 \\tilde{\\mathbf{n}}_{1, \\text{naive}}^{(e)} \\right\\|_2 = \\left\\| -2 t_0 \\tilde{\\mathbf{n}}_{1, \\text{naive}}^{(e)} \\right\\|_2 = 2 |t_0| \\left\\| \\tilde{\\mathbf{n}}_{1, \\text{naive}}^{(e)} \\right\\|_2 = 2 t_0\n    $$\n    因为 $\\tilde{\\mathbf{n}}_1^{(e)}$ 是单位向量且 $t_0  0$。因此，$\\Delta_{\\text{odd}}$ 是 $2t_0$ 乘以执行的符号翻转总数。\n\n这就完成了解决问题的理论和算法过程。最终的实现将为每个提供的测试用例执行这些步骤。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import deque\n\ndef solve():\n    \"\"\"\n    Main function to process all test cases for principal direction continuity correction.\n    \"\"\"\n    \n    # Define constants from the problem statement.\n    TAU = 1e-6\n    EPS = 1e-12\n    INVARIANCE_TOL = 1e-10\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"num_elements\": 5,\n            \"adjacency_edges\": [(0, 1), (1, 2), (2, 3), (3, 4)],\n            \"F_matrices\": [\n                np.array([[1.2, -0.10, 0.0], [0.0, 0.8333333333333334, 0.0], [0.0, 0.0, 1.0]]),\n                np.array([[1.2, -0.05, 0.0], [0.0, 0.8333333333333334, 0.02], [0.0, 0.0, 1.0]]),\n                np.array([[1.2, 0.0, 0.0], [0.0, 0.8333333333333334, 0.04], [0.0, 0.0, 1.0]]),\n                np.array([[1.2, 0.05, 0.0], [0.0, 0.8333333333333334, 0.06], [0.0, 0.0, 1.0]]),\n                np.array([[1.2, 0.10, 0.0], [0.0, 0.8333333333333334, 0.08], [0.0, 0.0, 1.0]])\n            ],\n            \"sign_mask\": [+1, -1, +1, -1, +1],\n            \"t0\": 1.0\n        },\n        {\n            \"num_elements\": 4,\n            \"adjacency_edges\": [(0, 1), (1, 2), (2, 3)],\n            \"F_matrices\": [\n                np.array([[1.5, 0.0, 0.0], [0.0, 0.9, 0.0], [0.0, 0.0, 1.1]]),\n                np.array([[1.5, 0.0, 0.0], [0.0, 0.9, 0.0], [0.0, 0.0, 1.1]]),\n                np.array([[1.5, 0.0, 0.0], [0.0, 0.9, 0.0], [0.0, 0.0, 1.1]]),\n                np.array([[1.5, 0.0, 0.0], [0.0, 0.9, 0.0], [0.0, 0.0, 1.1]])\n            ],\n            \"sign_mask\": [+1, +1, +1, +1],\n            \"t0\": 1.3\n        },\n        {\n            \"num_elements\": 4,\n            \"adjacency_edges\": [(0, 1), (0, 2), (1, 3), (2, 3)],\n            \"F_matrices\": [\n                np.array([[1.4, 0.05, 0.0], [0.0, 0.95, 0.0], [0.0, 0.0, 1.05]]),\n                np.array([[1.38, -0.04, 0.0], [0.0, 0.95, 0.02], [0.0, 0.0, 1.05]]),\n                np.array([[1.42, 0.06, 0.0], [0.0, 0.95, -0.02], [0.0, 0.0, 1.05]]),\n                np.array([[1.39, 0.00, 0.0], [0.0, 0.95, 0.0], [0.0, 0.0, 1.05]])\n            ],\n            \"sign_mask\": [-1, +1, -1, +1],\n            \"t0\": 0.7\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        N = case[\"num_elements\"]\n        F_list = case[\"F_matrices\"]\n        adj_edges = case[\"adjacency_edges\"]\n        sign_mask = case[\"sign_mask\"]\n        t0 = case[\"t0\"]\n\n        # Build adjacency list\n        adj = {i: [] for i in range(N)}\n        for u, v in adj_edges:\n            adj[u].append(v)\n            adj[v].append(u)\n\n        # 1. Element-wise computations and degeneracy check\n        C_list = []\n        base_n1_dirs = []\n        is_degenerate = [False] * N\n\n        for e in range(N):\n            F = F_list[e]\n            C = F.T @ F\n            C_list.append(C)\n\n            # Eigendecomposition of C\n            # np.linalg.eigh returns eigenvalues in ascending order\n            mu_vals, n_vecs = np.linalg.eigh(C)\n            \n            # Sort eigenvalues/stretches descending: lambda_1 = lambda_2 = lambda_3\n            lambda_1 = np.sqrt(mu_vals[2])\n            lambda_2 = np.sqrt(mu_vals[1])\n            \n            # The dominant principal direction n_1 corresponds to the largest eigenvalue mu_1\n            n_1 = n_vecs[:, 2]\n            base_n1_dirs.append(n_1)\n\n            # Degeneracy check\n            spectral_gap = (lambda_1 - lambda_2) / max(lambda_1, EPS)\n            if spectral_gap  TAU:\n                is_degenerate[e] = True\n\n        # 2. Form naive directions using the sign mask\n        naive_n1_dirs = [s * n for s, n in zip(sign_mask, base_n1_dirs)]\n\n        # 3. Sign-continuity correction algorithm\n        corrected_n1_dirs = [d.copy() for d in naive_n1_dirs]\n        flips_corrected = 0\n        \n        # Find root for BFS: lowest-indexed non-degenerate element\n        start_node = -1\n        for i in range(N):\n            if not is_degenerate[i]:\n                start_node = i\n                break\n        \n        if start_node != -1:\n            q = deque([start_node])\n            visited = {start_node}\n            \n            while q:\n                u = q.popleft()\n                ref_dir = corrected_n1_dirs[u]\n                \n                for v in adj[u]:\n                    if v not in visited and not is_degenerate[v]:\n                        visited.add(v)\n                        q.append(v)\n                        \n                        # Check for orientation consistency\n                        dot_product = ref_dir @ naive_n1_dirs[v]\n                        if dot_product  0:\n                            corrected_n1_dirs[v] *= -1\n                            flips_corrected += 1\n        \n        # 4. Quantify effects\n        # Even term invariance\n        p_naive = np.array([d.T @ C_list[i] @ d for i, d in enumerate(naive_n1_dirs)])\n        p_corrected = np.array([d.T @ C_list[i] @ d for i, d in enumerate(corrected_n1_dirs)])\n        max_diff = np.max(np.abs(p_corrected - p_naive))\n        even_ok = max_diff  INVARIANCE_TOL\n\n        # Odd term change\n        delta_odd = 0.0\n        for i in range(N):\n            t_naive = t0 * naive_n1_dirs[i]\n            t_corrected = t0 * corrected_n1_dirs[i]\n            delta_odd += np.linalg.norm(t_corrected - t_naive)\n            \n        results.append([even_ok, flips_corrected, delta_odd])\n\n    # Final print statement in the exact required format.\n    result_strings = [f'[{r[0]},{r[1]},{r[2]:.6f}]' for r in results]\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n\n```"
        }
    ]
}