{
    "hands_on_practices": [
        {
            "introduction": "要应用圣维南原理，首先必须精确理解“静力等效”的含义。本练习将引导你通过推导，将一个分布式的边界牵引力替换为一个等效的集中力和力偶，以便进行远场分析。这个过程是圣维南原理在工程简化中应用的数学基石，它构成了所有远场分析的基础。",
            "id": "3597318",
            "problem": "一个占据区域 $\\Omega \\subset \\mathbb{R}^{3}$ 的有界、均匀、各向同性的线性弹性体，其边界为 $\\Gamma$，外法向单位向量为 $\\boldsymbol{n}$。在边界 $\\Gamma$ 上的一个特征直径为 $a$ 的光滑小块 $\\Gamma_{0} \\subset \\Gamma$ 上，施加了两种可供选择的面力场 $\\boldsymbol{t}_{1}(\\boldsymbol{x})$ 和 $\\boldsymbol{t}_{2}(\\boldsymbol{x})$，而边界其余部分 $\\Gamma \\setminus \\Gamma_{0}$ 上的边界条件是相同的。假设两种面力场产生的合力以及关于原点 $\\boldsymbol{O}$ 的合力矩均相同，即\n$$\n\\boldsymbol{R} \\;=\\; \\int_{\\Gamma_{0}} \\boldsymbol{t}_{i}(\\boldsymbol{x})\\,\\mathrm{d}S, \n\\qquad\n\\boldsymbol{M} \\;=\\; \\int_{\\Gamma_{0}} \\boldsymbol{x} \\times \\boldsymbol{t}_{i}(\\boldsymbol{x})\\,\\mathrm{d}S,\n\\qquad i \\in \\{1,2\\}.\n$$\n选择一个与 $\\Gamma_{0}$ 相关的任意参考点 $\\boldsymbol{x}_{c} \\in \\mathbb{R}^{3}$，例如 $\\Gamma_{0}$ 的形心。仅使用全局线动量守恒、全局角动量守恒以及 Saint-Venant 原理的内容，构建一个由单个集中力和一个自由力偶组成的静力等效对，二者均作用于 $\\boldsymbol{x}_{c}$，用于在远场分析中替换任一面力场。你的构建必须满足以下条件：对于满足 $r = |\\boldsymbol{x}-\\boldsymbol{x}_{c}| \\gg a$ 的场点 $\\boldsymbol{x}$，该力对能够匹配弹性场的主导项和次主导项贡献。\n\n推导等效集中力 $\\boldsymbol{F}_{c}$ 和等效力偶 $\\boldsymbol{C}_{c}$ 关于 $\\boldsymbol{R}$、$\\boldsymbol{M}$ 和 $\\boldsymbol{x}_{c}$ 的显式表达式。将最终答案表示为一个包含两个元素的单行矩阵，第一个元素是 $\\boldsymbol{F}_{c}$，第二个元素是 $\\boldsymbol{C}_{c}$。无需进行数值计算，最终表达式中不应包含单位。最终答案必须是单个闭式解析表达式。",
            "solution": "任务是用一个集中载荷系统替换边界小块上的分布面力场，以复现相同的远场响应。合适的出发点是线动量和角动量的全局守恒定律，以及 Saint-Venant 原理。该原理指出，如果两个不同的载荷系统是静力等效的，那么它们所产生的应力场和位移场之差，在远离载荷施加区域时会快速衰减。\n\n首先，定义作用于 $\\Gamma_{0}$ 上的面力场 $\\boldsymbol{t}(\\boldsymbol{x})$ 关于原点的全局合力和全局合力矩：\n$$\n\\boldsymbol{R} \\;=\\; \\int_{\\Gamma_{0}} \\boldsymbol{t}(\\boldsymbol{x})\\,\\mathrm{d}S,\n\\qquad\n\\boldsymbol{M} \\;=\\; \\int_{\\Gamma_{0}} \\boldsymbol{x} \\times \\boldsymbol{t}(\\boldsymbol{x})\\,\\mathrm{d}S.\n$$\n这些积分直接源于全局线动量和角动量守恒：由边界面力传递的总力为 $\\boldsymbol{R}$，关于原点的总力矩为 $\\boldsymbol{M}$。根据假设，$\\boldsymbol{t}_{1}$ 和 $\\boldsymbol{t}_{2}$ 具有相同的 $\\boldsymbol{R}$ 和 $\\boldsymbol{M}$。\n\n对于远场等效性，只需将面力分布的前两个非平凡矩与一个静力等效的离散系统相匹配即可。这可由 Saint-Venant 原理和弹性场的多极子观点推断得出：在线性弹性理论中，由局部载荷分布产生的远场主导项由净力（单极子）决定，而下一项由净力矩（偶极子）决定，后者可以表示为一个自由力偶加上力关于所选参考点的力矩。\n\n考虑一个集中力 $\\boldsymbol{F}_{c}$ 和一个自由力偶 $\\boldsymbol{C}_{c}$，二者均作用于所选参考点 $\\boldsymbol{x}_{c}$。该离散系统的总合力为\n$$\n\\boldsymbol{R}_{\\mathrm{disc}} \\;=\\; \\boldsymbol{F}_{c}.\n$$\n该离散系统关于原点的总力矩是集中力关于原点的力矩与所施加力偶之和：\n$$\n\\boldsymbol{M}_{\\mathrm{disc}} \\;=\\; \\boldsymbol{x}_{c} \\times \\boldsymbol{F}_{c} \\;+\\; \\boldsymbol{C}_{c}.\n$$\n为保证与原面力系统静力等效，我们要求\n$$\n\\boldsymbol{R}_{\\mathrm{disc}} \\;=\\; \\boldsymbol{R},\n\\qquad\n\\boldsymbol{M}_{\\mathrm{disc}} \\;=\\; \\boldsymbol{M}.\n$$\n将 $\\boldsymbol{R}_{\\mathrm{disc}}$ 和 $\\boldsymbol{M}_{\\mathrm{disc}}$ 的表达式代入，得到方程组\n$$\n\\boldsymbol{F}_{c} \\;=\\; \\boldsymbol{R},\n\\qquad\n\\boldsymbol{x}_{c} \\times \\boldsymbol{F}_{c} \\;+\\; \\boldsymbol{C}_{c} \\;=\\; \\boldsymbol{M}.\n$$\n使用 $\\boldsymbol{F}_{c}=\\boldsymbol{R}$ 消去 $\\boldsymbol{F}_{c}$，得到所需力偶的显式形式：\n$$\n\\boldsymbol{C}_{c} \\;=\\; \\boldsymbol{M} \\;-\\; \\boldsymbol{x}_{c} \\times \\boldsymbol{R}.\n$$\n这个力对匹配了全局合力和全局合力矩。根据线性弹性理论背景下的 Saint-Venant 原理，匹配这两个不变量可确保对于距离 $\\boldsymbol{x}_{c}$ 为 $r \\gg a$ 的场点，由原始面力分布和离散载荷系统引起的弹性场之差比保留项衰减得更快，因为面力分布的所有高阶矩都以 $r$ 的更高次负幂形式贡献，并在远场近似中被忽略。\n\n因此，要施加于 $\\boldsymbol{x}_{c}$ 的静力等效集中载荷和力偶为\n$$\n\\boldsymbol{F}_{c} \\;=\\; \\boldsymbol{R},\n\\qquad\n\\boldsymbol{C}_{c} \\;=\\; \\boldsymbol{M} \\;-\\; \\boldsymbol{x}_{c} \\times \\boldsymbol{R},\n$$\n这就完成了构建。",
            "answer": "$$\\boxed{\\begin{pmatrix}\\boldsymbol{R}  \\boldsymbol{M}-\\boldsymbol{x}_{c}\\times\\boldsymbol{R}\\end{pmatrix}}$$"
        },
        {
            "introduction": "在有限元等计算方法中，我们常常需要将分布载荷离散化为节点载荷。本练习探讨了两种常见的处理方式——集总加载与一致加载，并运用圣维南原理来解释为何在远离加载区域时，这两种不同的静力等效加载方式对解的影响很小。通过这个实践，你将能深刻体会到圣维南原理在评估和简化数值模型时的实际价值。",
            "id": "3597346",
            "problem": "考虑一根长度为 $L$、抗弯刚度为 $EI$ 的等截面欧拉-伯努利梁。该梁两端简支（$w(0)=0$ 和 $w(L)=0$，转动自由），并在从左端算起的局部区域 $x \\in [0,a]$ 上承受大小为 $q_0$ 的均匀横向表面牵引力。\n\n使用 $N$ 个等长的双节点单元对梁进行一维有限元离散化建模。在每个单元内，横向位移场由三次 Hermite 形函数近似，每个节点的节点自由度为横向位移 $w$ 和转角 $\\theta$。\n\n您的任务是使用兩種不同的单元级局部牵引加载表示方法，计算并比较跨中横向挠度：\n- 集中节点加载：將每个部分或完全覆盖单元中的分布式牵引力仅转换为竖向节点力，节点弯矩为零。对于仅在其左端附近被部分覆盖的单元，将单元的全部局部载荷分配给左节点；对于被完全覆盖的单元，将单元总载荷在两个节点之间平分。\n- 一致性节点加载：根据虚功原理，通过在单元的覆盖部分上对牵引力与单元形函数的乘积进行积分，来推导单元载荷向量，从而产生與插值函数一致的节点力和节点弯矩。\n\n从欧拉-伯努利梁弯曲的运动学和虚功原理出发，执行以下步骤：\n- 推导与双节点三次 Hermite 插值相关的单元刚度矩阵，用 $EI$ 和单元长度表示。\n- 推导由单元内任意子区间上的均匀横向牵引力产生的一致性单元载荷向量，通过在该子区间上对单元形函数进行积分来表示。不要假设载荷覆盖整个单元；您的推导必须适用于从单元左节点开始的部分覆盖情况。\n- 描述如何根据上述规则构造集中节点加载近似，以在忽略节点弯矩的同时保持总力平衡。\n- 为两种加载表示方法组集全局刚度矩阵和全局载荷向量，施加简支边界条件（$w(0)=0$ 和 $w(L)=0$），并求解每种情况下的节点自由度。\n- 计算每種加载表示方法下的跨中挠度 $w(L/2)$，并报告它们之间的绝对差值。挠度差值以米为单位，表示为浮点数。\n\n根据圣维南原理对结果进行解释：说明为什么当局部载荷区域远离跨中时，这两种不同但静力等效的局部载荷表示方法在 $w(L/2)$ 上的差异倾向于较小，以及为什么当载荷延伸到整个结构或离散化较粗时，差异可能更为显著。\n\n必须严格遵守物理单位：$L$ 和 $a$ 的单位为米， $E$ 的单位为帕斯卡， $I$ 的单位为 $\\mathrm{m}^4$， $q_0$ 的单位为 $\\mathrm{N/m}$，转角的单位为弧度，挠度的单位为米。角度应以弧度处理。最终输出必须是跨中挠度的绝对差值，单位为米。\n\n实现一个完整的、可运行的程序，对以下参数集测试套件执行这些计算：\n- 案例1 (正常路径, 局部载荷): $L=10$, $a=1$, $q_0=1000$, $E=210\\times 10^9$, $I=8\\times 10^{-6}$, $N=20$.\n- 案例2 (边界情况, 载荷覆盖全梁): $L=10$, $a=10$, $q_0=1000$, $E=210\\times 10^9$, $I=8\\times 10^{-6}$, $N=20$.\n- 案例3 (边缘情况, 极小局部载荷): $L=10$, $a=0.2$, $q_0=1000$, $E=210\\times 10^9$, $I=8\\times 10^{-6}$, $N=20$.\n- 案例4 (离散化敏感性, 粗网格): $L=10$, $a=1$, $q_0=1000$, $E=210\\times 10^9$, $I=8\\times 10^{-6}$, $N=4$.\n\n您的程序应生成单行输出，其中包含这些案例的跨中挠度绝对差值，形式为逗号分隔的列表，并用方括号括起来，例如 $\\texttt{[d_1,d_2,d_3,d_4]}$，其中每个 $d_i$ 是一个以米为单位的浮点数。不得打印任何额外文本。",
            "solution": "该问题要求使用两种不同的有限元加载模型（集中式和一致性）计算和比较简支欧拉-伯努利梁在局部载荷作用下的跨中挠度。此分析将结合圣维南原理进行。该问题是适定的，其科学基础是计算固体力学的原理，并为获得唯一解提供了所有必要信息。\n\n### 1. 欧拉-伯努利梁的有限元列式\n\n我们使用 $N$ 个长度为 $h = L/N$ 的双节点有限元来模拟长度为 $L$、抗弯刚度为 $EI$ 的梁。梁的行为由欧拉-伯努利方程 $EI \\frac{d^4 w}{dx^4} = q(x)$ 控制，其中 $w(x)$ 是横向位移，$q(x)$ 是分布式横向载荷。\n\n#### 运动学与形函数\n在每个单元内，横向位移场 $w(\\xi)$（其中 $\\xi \\in [0, h]$ 是局部坐标）是从节点自由度 (DOF) 插值得到的。对于双节点梁单元，自由度是每个节点的位移 $w$ 和转角 $\\theta = dw/d\\xi$。单元的节点位移向量为 $\\mathbf{d}_e = [w_1, \\theta_1, w_2, \\theta_2]^T$。\n\n位移使用三次 Hermite 形函数 $\\mathbf{N}(\\xi) = [N_1(\\xi), N_2(\\xi), N_3(\\xi), N_4(\\xi)]$ 进行近似：\n$$w(\\xi) = \\mathbf{N}(\\xi) \\mathbf{d}_e$$\n形函数为：\n- $N_1(\\xi) = 1 - 3(\\xi/h)^2 + 2(\\xi/h)^3$\n- $N_2(\\xi) = \\xi - 2\\xi^2/h + \\xi^3/h^2$\n- $N_3(\\xi) = 3(\\xi/h)^2 - 2(\\xi/h)^3$\n- $N_4(\\xi) = -\\xi^2/h + \\xi^3/h^2$\n\n#### 单元刚度矩阵\n单元刚度矩阵 $\\mathbf{k}_e$ 是从梁的应变能 $U_e$ 推导出来的：\n$$U_e = \\frac{1}{2} \\int_0^h EI \\left( \\frac{d^2w}{d\\xi^2} \\right)^2 d\\xi$$\n曲率为 $\\frac{d^2w}{d\\xi^2} = \\frac{d^2\\mathbf{N}}{d\\xi^2} \\mathbf{d}_e = \\mathbf{B}(\\xi) \\mathbf{d}_e$。应变能可以写成 $U_e = \\frac{1}{2} \\mathbf{d}_e^T \\left( EI \\int_0^h \\mathbf{B}(\\xi)^T \\mathbf{B}(\\xi) d\\xi \\right) \\mathbf{d}_e$。括号中的项即为单元刚度矩阵 $\\mathbf{k}_e$：\n$$\\mathbf{k}_e = EI \\int_0^h \\mathbf{B}(\\xi)^T \\mathbf{B}(\\xi) d\\xi = \\frac{EI}{h^3} \\begin{bmatrix} 12  6h  -12  6h \\\\ 6h  4h^2  -6h  2h^2 \\\\ -12  -6h  12  -6h \\\\ 6h  2h^2  -6h  4h^2 \\end{bmatrix}$$\n\n### 2. 单元载荷向量的列式\n\n外部载荷是在区域 $[0, a]$ 上的均匀牵引力 $q_0$。对于一个起始于全局坐标 $x_e$ 的单元，其局部坐标系 $\\xi$ 中的受载部分是 $[0, s]$，其中 $s = \\max(0, \\min(a, x_e+h) - x_e)$。\n\n#### 一致性载荷向量\n一致性载荷向量 $\\mathbf{f}_{e, \\text{cons}}$ 是根据虚功原理推导的。牵引力 $q_0$ 所做的虚功为 $\\delta W_e = \\int_0^s q_0 \\delta w(\\xi) d\\xi$。由于 $\\delta w(\\xi) = \\mathbf{N}(\\xi) \\delta \\mathbf{d}_e$，我们有 $\\delta W_e = \\delta \\mathbf{d}_e^T \\left( \\int_0^s q_0 \\mathbf{N}(\\xi)^T d\\xi \\right)$。\n因此，一致性载荷向量是：\n$$\\mathbf{f}_{e, \\text{cons}} = q_0 \\int_0^s \\mathbf{N}(\\xi)^T d\\xi$$\n每个分量是相应形函数在受载长度 $s$ 上的积分：\n- $f_1 = q_0 \\int_0^s N_1(\\xi) d\\xi = q_0 \\left[s - \\frac{s^3}{h^2} + \\frac{s^4}{2h^3}\\right]$\n- $f_2 = q_0 \\int_0^s N_2(\\xi) d\\xi = q_0 \\left[\\frac{s^2}{2} - \\frac{2s^3}{3h} + \\frac{s^4}{4h^2}\\right]$\n- $f_3 = q_0 \\int_0^s N_3(\\xi) d\\xi = q_0 \\left[\\frac{s^3}{h^2} - \\frac{s^4}{2h^3}\\right]$\n- $f_4 = q_0 \\int_0^s N_4(\\xi) d\\xi = q_0 \\left[-\\frac{s^3}{3h} + \\frac{s^4}{4h^2}\\right]$\n该列式生成了与假定的三次位移场在能量上一致的节点力和弯矩。对于一个完全加载的单元（$s=h$），这将得到经典载荷向量 $\\mathbf{f}_{e, \\text{cons}} = q_0 [h/2, h^2/12, h/2, -h^2/12]^T$。\n\n#### 集中载荷向量\n集中载荷向量 $\\mathbf{f}_{e, \\text{lump}}$ 是一个简化模型，它保持单元上的总力不变，但忽略节点弯矩。单元上的总力为 $F_{\\text{total}} = q_0 s$。指定的规则是：\n- 如果单元被完全覆盖（$s=h$），载荷将被平均分配：$\\mathbf{f}_{e, \\text{lump}} = [q_0 h/2, 0, q_0 h/2, 0]^T$。\n- 如果单元从左侧被部分覆盖（$0  s  h$），全部载荷将分配给左节点：$\\mathbf{f}_{e, \\text{lump}} = [q_0 s, 0, 0, 0]^T$。\n该模型在合力方面与分布式载荷静力等效，但在合力矩方面则不等效。\n\n### 3. 全局系统与求解\n\n单元刚度矩阵和载荷向量被组集到全局方程组 $\\mathbf{K} \\mathbf{D} = \\mathbf{F}$ 中，其中 $\\mathbf{K}$ 是全局刚度矩阵，$\\mathbf{D}$ 是全局节点自由度向量，$\\mathbf{F}$ 是全局载荷向量（$\\mathbf{F}_{\\text{cons}}$ 或 $\\mathbf{F}_{\\text{lump}}$）。\n\n施加简支边界条件 $w(0)=0$ 和 $w(L)=0$。这对应于将第一个节点（索引 0）和最后一个节点（索引 $N$）的位移自由度约束为零。两端的转动自由度保持自由。施加这些约束后，求解两个线性系统 $\\mathbf{K} \\mathbf{D}_{\\text{cons}} = \\mathbf{F}_{\\text{cons}}$ 和 $\\mathbf{K} \\mathbf{D}_{\\text{lump}} = \\mathbf{F}_{\\text{lump}}$，以找到每种加载模型下的节点位移和转角。\n\n### 4. 跨中挠度与解释\n\n然后计算跨中挠度 $w(L/2)$。对于所提供的测试案例，$N$ 总是偶数，这意味着跨中 $x=L/2$ 与节点 $N/2$ 重合。因此，挠度直接由全局解向量中的节点位移值 $D[2 \\times (N/2)] = D[N]$ 给出。绝对差值 $|w_{\\text{cons}}(L/2) - w_{\\text{lump}}(L/2)|$ 量化了模型之间的差异。\n\n这种差异可以用圣维南原理来解释，该原理指出静力等效载荷的影响是局部的。在远离载荷作用区域的地方，结构响应（应力、应变、位移）仅取决于载荷的净合力（总力和总力矩），而不取决于其详细分布。\n\n- **案例1和3（局部载荷）：** 载荷区域很小，位于梁的一端，远离跨中。圣维南原理预测，跨中挠度应该对集中模型和一致性模型之间的局部差异不敏感。梁结构有效地“平滑掉”了这些差异。因此，预计挠度的绝对差值会很小。\n\n- **案例2（全局载荷）：** 载荷覆盖整个梁（$a=L$）。载荷不是局部的，因此没有“远场”区域。圣维南原理的先验假设不成立。加载模型之间的差异应用于整个结构。一致性模型正确地捕捉了每个单元上分布式载荷产生的功共轭力矩，而集中模型则忽略了它们。这种根本的建模差异预计会在全局位移场（包括跨中位置）产生显著的差异。\n\n- **案例4（粗糙离散化）：** 粗网格（$N=4$）意味着每个单元都很大（$h=L/4=2.5$ m）。将载荷集中在节点上的集中模型，与细网格相比，成为对分布式载荷的一个更粗糙的近似。每个点载荷的“近场”更大，并且在粗单元的尺度上，结构的平滑效应效果较差。集中模型中这种增大的近似误差预计会比其对应的细网格情况（案例1）导致更大的差异。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the beam problem for all test cases and print the results.\n    \"\"\"\n\n    def get_element_stiffness(EI, h):\n        \"\"\"Returns the 4x4 element stiffness matrix for an Euler-Bernoulli beam.\"\"\"\n        return (EI / h**3) * np.array([\n            [12, 6 * h, -12, 6 * h],\n            [6 * h, 4 * h**2, -6 * h, 2 * h**2],\n            [-12, -6 * h, 12, -6 * h],\n            [6 * h, 2 * h**2, -6 * h, 4 * h**2]\n        ])\n\n    def get_consistent_load_vector(q0, s, h):\n        \"\"\"Calculates the consistent load vector for a load over [0, s] in local coords.\"\"\"\n        if s  1e-12: # Tolerance for zero length\n            return np.zeros(4)\n        \n        # Indefinite integrals of shape functions, evaluated at s.\n        f = np.zeros(4)\n        f[0] = s - s**3/h**2 + s**4/(2*h**3)\n        f[1] = s**2/2 - 2*s**3/(3*h) + s**4/(4*h**2)\n        f[2] = s**3/h**2 - s**4/(2*h**3)\n        f[3] = -s**3/(3*h) + s**4/(4*h**2)\n        \n        return q0 * f\n\n    def get_lumped_load_vector(q0, s, h):\n        \"\"\"Calculates the lumped load vector for a load over [0, s] in local coords.\"\"\"\n        if s  1e-12: # Tolerance for zero length\n            return np.zeros(4)\n        \n        total_force = q0 * s\n        f_lump = np.zeros(4)\n        \n        # Using a small tolerance for floating point comparison of s and h\n        if np.isclose(s, h):  # Fully loaded element\n            f_lump[0] = total_force / 2\n            f_lump[2] = total_force / 2\n        else:  # Partially loaded element from the left\n            f_lump[0] = total_force\n            \n        return f_lump\n    \n    def shape_functions(xi, h):\n        \"\"\"Calculates cubic Hermite shape functions at a given local coordinate xi.\"\"\"\n        N = np.zeros(4)\n        N[0] = 1 - 3*(xi/h)**2 + 2*(xi/h)**3\n        N[1] = xi - 2*xi**2/h + xi**3/h**2\n        N[2] = 3*(xi/h)**2 - 2*(xi/h)**3\n        N[3] = -xi**2/h + xi**3/h**2\n        return N\n\n    def solve_beam_case(L, a, q0, E, I, N):\n        \"\"\"Solves a single instance of the beam problem.\"\"\"\n        h = L / N\n        EI = E * I\n        num_dofs = 2 * (N + 1)\n        \n        K = np.zeros((num_dofs, num_dofs))\n        F_cons = np.zeros(num_dofs)\n        F_lump = np.zeros(num_dofs)\n        \n        k_e = get_element_stiffness(EI, h)\n        \n        for e in range(N):\n            x_e = e * h\n            # Calculate the length of the loaded portion 's' for the current element\n            s = max(0, min(a, x_e + h) - x_e)\n            \n            if s > 1e-12:\n                f_e_cons = get_consistent_load_vector(q0, s, h)\n                f_e_lump = get_lumped_load_vector(q0, s, h)\n                \n                # Assemble load vectors\n                dof_map = np.array([2*e, 2*e + 1, 2*(e+1), 2*(e+1) + 1])\n                F_cons[dof_map] += f_e_cons\n                F_lump[dof_map] += f_e_lump\n\n            # Assemble stiffness matrix\n            dof_map = np.array([2*e, 2*e+1, 2*(e+1), 2*(e+1)+1])\n            K[np.ix_(dof_map, dof_map)] += k_e\n\n        # Apply boundary conditions w(0)=0 and w(L)=0 using the penalty method\n        K_mod = K.copy()\n        # A large number relative to stiffness matrix diagonal values\n        penalty = 1e12 * np.max(np.diag(K)) if N > 0 else 1e12\n        \n        # DOF for w(0) is 0\n        K_mod[0, 0] += penalty\n        # DOF for w(L) is 2*N\n        K_mod[2*N, 2*N] += penalty\n        \n        # Solve for nodal displacements for both loading cases\n        D_cons = np.linalg.solve(K_mod, F_cons)\n        D_lump = np.linalg.solve(K_mod, F_lump)\n        \n        w_mid_cons = 0.0\n        w_mid_lump = 0.0\n        \n        if N % 2 == 0:  # N is even, midspan L/2 is at node N/2\n            midspan_dof_idx = N\n            w_mid_cons = D_cons[midspan_dof_idx]\n            w_mid_lump = D_lump[midspan_dof_idx]\n        else:  # N is odd, midspan is inside an element\n            e_mid = int(L/2 / h)\n            x_e_mid = e_mid * h\n            xi = L/2 - x_e_mid\n            \n            N_mid = shape_functions(xi, h)\n            dof_map_mid = np.array([2*e_mid, 2*e_mid+1, 2*(e_mid+1), 2*(e_mid+1)+1])\n            \n            d_cons_local = D_cons[dof_map_mid]\n            d_lump_local = D_lump[dof_map_mid]\n            \n            w_mid_cons = N_mid.dot(d_cons_local)\n            w_mid_lump = N_mid.dot(d_lump_local)\n            \n        return abs(w_mid_cons - w_mid_lump)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (L, a, q0, E, I, N)\n        (10.0, 1.0, 1000.0, 210e9, 8e-6, 20),\n        (10.0, 10.0, 1000.0, 210e9, 8e-6, 20),\n        (10.0, 0.2, 1000.0, 210e9, 8e-6, 20),\n        (10.0, 1.0, 1000.0, 210e9, 8e-6, 4),\n    ]\n\n    results = []\n    for case in test_cases:\n        difference = solve_beam_case(*case)\n        results.append(difference)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}