{
    "hands_on_practices": [
        {
            "introduction": "The foundation of Saint-Venant's principle lies in the concept of static equivalence. This exercise provides a fundamental, hands-on derivation to formalize this idea by replacing a complex, distributed traction field with a much simpler concentrated force and couple. Mastering this transformation is the first critical skill in leveraging Saint-Venant's principle to simplify mechanical models for far-field analysis. ",
            "id": "3597318",
            "problem": "A bounded, homogeneous, isotropic, linearly elastic body occupying a domain $\\Omega \\subset \\mathbb{R}^{3}$ has boundary $\\Gamma$ with outward unit normal $\\boldsymbol{n}$. On a smooth patch $\\Gamma_{0} \\subset \\Gamma$ of characteristic diameter $a$, two alternative traction fields $\\boldsymbol{t}_{1}(\\boldsymbol{x})$ and $\\boldsymbol{t}_{2}(\\boldsymbol{x})$ are prescribed, while the remainder of the boundary conditions on $\\Gamma \\setminus \\Gamma_{0}$ are identical. Assume both traction fields produce the same resultant force and the same resultant moment about the origin $\\boldsymbol{O}$, namely\n$$\n\\boldsymbol{R} \\;=\\; \\int_{\\Gamma_{0}} \\boldsymbol{t}_{i}(\\boldsymbol{x})\\,\\mathrm{d}S, \n\\qquad\n\\boldsymbol{M} \\;=\\; \\int_{\\Gamma_{0}} \\boldsymbol{x} \\times \\boldsymbol{t}_{i}(\\boldsymbol{x})\\,\\mathrm{d}S,\n\\qquad i \\in \\{1,2\\}.\n$$\nSelect an arbitrary reference point $\\boldsymbol{x}_{c} \\in \\mathbb{R}^{3}$ associated with $\\Gamma_{0}$, for example the area centroid of $\\Gamma_{0}$. Using only the global balance of linear momentum, the global balance of angular momentum, and the content of Saint-Venant’s principle, construct a statically equivalent pair consisting of a single concentrated force and a free couple, both applied at $\\boldsymbol{x}_{c}$, that replaces either traction field for far-field analysis. Your construction must be such that, for field points $\\boldsymbol{x}$ with $r = |\\boldsymbol{x}-\\boldsymbol{x}_{c}| \\gg a$, the leading and next-to-leading contributions to the elastic field are matched by this pair.\n\nDerive explicit expressions for the equivalent concentrated force $\\boldsymbol{F}_{c}$ and the equivalent couple $\\boldsymbol{C}_{c}$ in terms of $\\boldsymbol{R}$, $\\boldsymbol{M}$, and $\\boldsymbol{x}_{c}$. Express your final answer as a single row matrix with two entries, the first being $\\boldsymbol{F}_{c}$ and the second being $\\boldsymbol{C}_{c}$. No numerical evaluation is required, and no units should be included in the final expression. The final answer must be a single closed-form analytic expression.",
            "solution": "The task is to replace a distributed traction field on a boundary patch by a concentrated load system that reproduces the same far-field response. The appropriate starting point is the global balance laws for linear and angular momentum, together with Saint-Venant's principle, which asserts that if two different load systems are statically equivalent, then the difference in the resulting stress and displacement fields decays rapidly away from the region of load application.\n\nFirst, define the global resultant force and global resultant moment about the origin for a traction field $\\boldsymbol{t}(\\boldsymbol{x})$ supported on $\\Gamma_{0}$:\n$$\n\\boldsymbol{R} \\;=\\; \\int_{\\Gamma_{0}} \\boldsymbol{t}(\\boldsymbol{x})\\,\\mathrm{d}S,\n\\qquad\n\\boldsymbol{M} \\;=\\; \\int_{\\Gamma_{0}} \\boldsymbol{x} \\times \\boldsymbol{t}(\\boldsymbol{x})\\,\\mathrm{d}S.\n$$\nThese integrals follow directly from the global balance of linear and angular momentum: the total force transmitted by the boundary tractions is $\\boldsymbol{R}$, and the total moment about the origin is $\\boldsymbol{M}$. By assumption, $\\boldsymbol{t}_{1}$ and $\\boldsymbol{t}_{2}$ have the same $\\boldsymbol{R}$ and $\\boldsymbol{M}$.\n\nFor far-field equivalence, it suffices to match the first two nontrivial moments of the traction distribution with a statically equivalent discrete system. This follows from Saint-Venant's principle and a multipole viewpoint of the elastic field: in linear elasticity, the leading far-field term generated by a localized load distribution is governed by the net force (the monopole), and the next term is governed by the net moment (the dipole), which can be represented as a free couple plus the moment of the force about the chosen reference point.\n\nConsider a concentrated force $\\boldsymbol{F}_{c}$ and a free couple $\\boldsymbol{C}_{c}$, both applied at the chosen reference point $\\boldsymbol{x}_{c}$. The total resultant force of this discrete system is\n$$\n\\boldsymbol{R}_{\\mathrm{disc}} \\;=\\; \\boldsymbol{F}_{c}.\n$$\nThe total moment of this discrete system about the origin is the sum of the moment of the concentrated force about the origin and the applied couple:\n$$\n\\boldsymbol{M}_{\\mathrm{disc}} \\;=\\; \\boldsymbol{x}_{c} \\times \\boldsymbol{F}_{c} \\;+\\; \\boldsymbol{C}_{c}.\n$$\nTo ensure static equivalence with the original traction system, we enforce\n$$\n\\boldsymbol{R}_{\\mathrm{disc}} \\;=\\; \\boldsymbol{R},\n\\qquad\n\\boldsymbol{M}_{\\mathrm{disc}} \\;=\\; \\boldsymbol{M}.\n$$\nSubstituting the expressions for $\\boldsymbol{R}_{\\mathrm{disc}}$ and $\\boldsymbol{M}_{\\mathrm{disc}}$ yields the equations\n$$\n\\boldsymbol{F}_{c} \\;=\\; \\boldsymbol{R},\n\\qquad\n\\boldsymbol{x}_{c} \\times \\boldsymbol{F}_{c} \\;+\\; \\boldsymbol{C}_{c} \\;=\\; \\boldsymbol{M}.\n$$\nEliminating $\\boldsymbol{F}_{c}$ using $\\boldsymbol{F}_{c}=\\boldsymbol{R}$ gives the explicit form of the required couple:\n$$\n\\boldsymbol{C}_{c} \\;=\\; \\boldsymbol{M} \\;-\\; \\boldsymbol{x}_{c} \\times \\boldsymbol{R}.\n$$\nThis pair matches the global resultant and the global moment. By Saint-Venant's principle in the context of linear elasticity, matching these two invariants ensures that for field points at distances $r \\gg a$ from $\\boldsymbol{x}_{c}$, the difference between the elastic fields due to the original traction distribution and the discrete load system decays faster than the retained terms, because all higher-order moments of the traction distribution contribute at higher inverse powers of $r$ and are neglected in the far-field approximation.\n\nTherefore, the statically equivalent concentrated load and couple to be applied at $\\boldsymbol{x}_{c}$ are\n$$\n\\boldsymbol{F}_{c} \\;=\\; \\boldsymbol{R},\n\\qquad\n\\boldsymbol{C}_{c} \\;=\\; \\boldsymbol{M} \\;-\\; \\boldsymbol{x}_{c} \\times \\boldsymbol{R},\n$$\nwhich completes the construction.",
            "answer": "$$\\boxed{\\begin{pmatrix}\\boldsymbol{R} & \\boldsymbol{M}-\\boldsymbol{x}_{c}\\times\\boldsymbol{R}\\end{pmatrix}}$$"
        },
        {
            "introduction": "This practice bridges abstract theory to everyday computational modeling, addressing a common question in finite element analysis (FEA). By comparing lumped versus consistent nodal loads, you will numerically investigate how two statically equivalent load representations can produce different local results but converge in the far-field. This exercise offers direct insight into why Saint-Venant's principle is not just a theoretical curiosity but a vital tool for interpreting and validating FEA results. ",
            "id": "3597346",
            "problem": "Consider a prismatic Euler–Bernoulli beam of length $L$, bending rigidity $EI$, simply supported at both ends ($w(0)=0$ and $w(L)=0$ with rotations free), and subject to a uniform transverse surface traction of magnitude $q_0$ acting only over a patch region $x \\in [0,a]$ measured from the left end. Model the beam using a one-dimensional finite element discretization with $N$ equal two-node elements. Let the transverse displacement field be approximated within each element by cubic Hermite shape functions, with nodal degrees of freedom given by the transverse displacement $w$ and rotation $\\theta$ at each node. \n\nYour task is to compute and compare the midspan transverse deflection using two distinct representations of the element-level traction loading over the patch:\n- Lumped nodal loading: convert the distributed traction in each partially or fully covered element into vertical nodal forces only, with zero nodal moments. For an element that is only partially covered near its left end, assign the entire element’s patch load to the left node; for an element fully covered by the patch, split the total element load equally between the two nodes.\n- Consistent nodal loading: derive the element load vector using the principle of virtual work by integrating the product of the traction and the element shape functions over the covered portion of the element, thus producing both nodal forces and nodal moments consistent with the interpolation.\n\nStarting from the kinematics of Euler–Bernoulli beam bending and the principle of virtual work, carry out the following steps:\n- Derive the element stiffness matrix associated with the two-node cubic Hermite interpolation in terms of $EI$ and the element length.\n- Derive the consistent element load vector produced by a uniform transverse traction over an arbitrary sub-interval within the element, expressed through integrals of the element shape functions over that sub-interval. Do not assume the load covers the entire element; your derivation must apply to a partial coverage beginning at the element’s left node.\n- Describe how the lumped nodal loading approximation is constructed to preserve total force balance while ignoring nodal moments, following the rule specified above.\n- Assemble the global stiffness matrix and global load vectors for both loading representations, enforce simply supported boundary conditions ($w(0)=0$ and $w(L)=0$), and solve for the nodal degrees of freedom in each case.\n- Compute the midspan deflection $w(L/2)$ for each loading representation and report the absolute difference between them. Express the deflection difference in meters, as a floating-point number.\n\nInterpret the outcome in light of Saint-Venant's principle: explain why the difference in $w(L/2)$ between these two different but statically equivalent representations of the localized patch load tends to be small when the patch is remote from the midspan and why differences may be more pronounced when the load extends across the whole structure or when the discretization is coarse.\n\nPhysical units must be strictly adhered to: $L$ and $a$ in meters, $E$ in pascals, $I$ in $\\mathrm{m}^4$, $q_0$ in $\\mathrm{N/m}$, rotations in radians, and deflections in meters. Angles are to be treated in radians. The final outputs must be the absolute differences in midspan deflection in meters.\n\nImplement a complete, runnable program that performs these computations for the following test suite of parameter sets:\n- Case 1 (happy path, localized patch): $L=10$, $a=1$, $q_0=1000$, $E=210\\times 10^9$, $I=8\\times 10^{-6}$, $N=20$.\n- Case 2 (boundary case, patch covers entire beam): $L=10$, $a=10$, $q_0=1000$, $E=210\\times 10^9$, $I=8\\times 10^{-6}$, $N=20$.\n- Case 3 (edge case, very small patch): $L=10$, $a=0.2$, $q_0=1000$, $E=210\\times 10^9$, $I=8\\times 10^{-6}$, $N=20$.\n- Case 4 (discretization sensitivity, coarse mesh): $L=10$, $a=1$, $q_0=1000$, $E=210\\times 10^9$, $I=8\\times 10^{-6}$, $N=4$.\n\nYour program should produce a single line of output containing the absolute differences in midspan deflection for these cases, as a comma-separated list enclosed in square brackets, for example, $\\texttt{[d_1,d_2,d_3,d_4]}$, where each $d_i$ is a floating-point number in meters. No additional text may be printed.",
            "solution": "The problem requires the computation and comparison of the midspan deflection of a simply supported Euler-Bernoulli beam under a localized patch load using two different finite element loading models: lumped and consistent. This analysis will be contextualized by Saint-Venant's principle. The problem is well-posed, scientifically grounded in the principles of computational solid mechanics, and provides all necessary information for a unique solution.\n\n### 1. Finite Element Formulation for an Euler-Bernoulli Beam\n\nWe model the beam of length $L$ and bending rigidity $EI$ using $N$ two-node finite elements, each of length $h = L/N$. The behavior of the beam is governed by the Euler-Bernoulli equation, $EI \\frac{d^4 w}{dx^4} = q(x)$, where $w(x)$ is the transverse displacement and $q(x)$ is the distributed transverse load.\n\n#### Kinematics and Shape Functions\nWithin each element, the transverse displacement field $w(\\xi)$, where $\\xi \\in [0, h]$ is the local coordinate, is interpolated from the nodal degrees of freedom (DOFs). For a two-node beam element, the DOFs are the displacement $w$ and rotation $\\theta = dw/d\\xi$ at each node. The element's nodal displacement vector is $\\mathbf{d}_e = [w_1, \\theta_1, w_2, \\theta_2]^T$.\n\nThe displacement is approximated using cubic Hermite shape functions $\\mathbf{N}(\\xi) = [N_1(\\xi), N_2(\\xi), N_3(\\xi), N_4(\\xi)]$:\n$$w(\\xi) = \\mathbf{N}(\\xi) \\mathbf{d}_e$$\nThe shape functions are:\n- $N_1(\\xi) = 1 - 3(\\xi/h)^2 + 2(\\xi/h)^3$\n- $N_2(\\xi) = \\xi - 2\\xi^2/h + \\xi^3/h^2$\n- $N_3(\\xi) = 3(\\xi/h)^2 - 2(\\xi/h)^3$\n- $N_4(\\xi) = -\\xi^2/h + \\xi^3/h^2$\n\n#### Element Stiffness Matrix\nThe element stiffness matrix, $\\mathbf{k}_e$, is derived from the beam's strain energy, $U_e$:\n$$U_e = \\frac{1}{2} \\int_0^h EI \\left( \\frac{d^2w}{d\\xi^2} \\right)^2 d\\xi$$\nThe curvature is $\\frac{d^2w}{d\\xi^2} = \\frac{d^2\\mathbf{N}}{d\\xi^2} \\mathbf{d}_e = \\mathbf{B}(\\xi) \\mathbf{d}_e$. The strain energy can be written as $U_e = \\frac{1}{2} \\mathbf{d}_e^T \\left( EI \\int_0^h \\mathbf{B}(\\xi)^T \\mathbf{B}(\\xi) d\\xi \\right) \\mathbf{d}_e$. The term in the parenthesis is the element stiffness matrix $\\mathbf{k}_e$:\n$$\\mathbf{k}_e = EI \\int_0^h \\mathbf{B}(\\xi)^T \\mathbf{B}(\\xi) d\\xi = \\frac{EI}{h^3} \\begin{bmatrix} 12 & 6h & -12 & 6h \\\\ 6h & 4h^2 & -6h & 2h^2 \\\\ -12 & -6h & 12 & -6h \\\\ 6h & 2h^2 & -6h & 4h^2 \\end{bmatrix}$$\n\n### 2. Element Load Vector Formulation\n\nThe external load is a uniform traction $q_0$ over the patch $[0, a]$. For an element starting at global coordinate $x_e$, the loaded portion in its local coordinate system $\\xi$ is $[0, s]$, where $s = \\max(0, \\min(a, x_e+h) - x_e)$.\n\n#### Consistent Load Vector\nThe consistent load vector, $\\mathbf{f}_{e, \\text{cons}}$, is derived from the principle of virtual work. The virtual work done by the traction $q_0$ is $\\delta W_e = \\int_0^s q_0 \\delta w(\\xi) d\\xi$. Since $\\delta w(\\xi) = \\mathbf{N}(\\xi) \\delta \\mathbf{d}_e$, we have $\\delta W_e = \\delta \\mathbf{d}_e^T \\left( \\int_0^s q_0 \\mathbf{N}(\\xi)^T d\\xi \\right)$.\nThus, the consistent load vector is:\n$$\\mathbf{f}_{e, \\text{cons}} = q_0 \\int_0^s \\mathbf{N}(\\xi)^T d\\xi$$\nEach component is the integral of the corresponding shape function over the loaded length $s$:\n- $f_1 = q_0 \\int_0^s N_1(\\xi) d\\xi = q_0 \\left[s - \\frac{s^3}{h^2} + \\frac{s^4}{2h^3}\\right]$\n- $f_2 = q_0 \\int_0^s N_2(\\xi) d\\xi = q_0 \\left[\\frac{s^2}{2} - \\frac{2s^3}{3h} + \\frac{s^4}{4h^2}\\right]$\n- $f_3 = q_0 \\int_0^s N_3(\\xi) d\\xi = q_0 \\left[\\frac{s^3}{h^2} - \\frac{s^4}{2h^3}\\right]$\n- $f_4 = q_0 \\int_0^s N_4(\\xi) d\\xi = q_0 \\left[-\\frac{s^3}{3h} + \\frac{s^4}{4h^2}\\right]$\nThis formulation generates both nodal forces and moments that are energetically consistent with the assumed cubic displacement field. For a fully loaded element ($s=h$), this yields the classic load vector $\\mathbf{f}_{e, \\text{cons}} = q_0 [h/2, h^2/12, h/2, -h^2/12]^T$.\n\n#### Lumped Load Vector\nThe lumped load vector, $\\mathbf{f}_{e, \\text{lump}}$, is a simplified model that preserves the total force on the element but ignores nodal moments. The total force on the element is $F_{\\text{total}} = q_0 s$. The rules specified are:\n- If the element is fully covered ($s=h$), the load is split equally: $\\mathbf{f}_{e, \\text{lump}} = [q_0 h/2, 0, q_0 h/2, 0]^T$.\n- If the element is partially covered from the left ($0 < s < h$), the entire load is assigned to the left node: $\\mathbf{f}_{e, \\text{lump}} = [q_0 s, 0, 0, 0]^T$.\nThis model is statically equivalent to the distributed load in terms of resultant force but not resultant moment.\n\n### 3. Global System and Solution\n\nThe element stiffness matrices and load vectors are assembled into a global system of equations $\\mathbf{K} \\mathbf{D} = \\mathbf{F}$, where $\\mathbf{K}$ is the global stiffness matrix, $\\mathbf{D}$ is the global vector of nodal DOFs, and $\\mathbf{F}$ is the global load vector (either $\\mathbf{F}_{\\text{cons}}$ or $\\mathbf{F}_{\\text{lump}}$).\n\nThe simply supported boundary conditions, $w(0)=0$ and $w(L)=0$, are enforced. These correspond to constraining the displacement DOFs at the first node (index $0$) and the last node (index $N$) to zero. The rotational DOFs at the ends remain free. After applying these constraints, the two linear systems, $\\mathbf{K} \\mathbf{D}_{\\text{cons}} = \\mathbf{F}_{\\text{cons}}$ and $\\mathbf{K} \\mathbf{D}_{\\text{lump}} = \\mathbf{F}_{\\text{lump}}$, are solved to find the nodal displacements and rotations for each loading model.\n\n### 4. Midspan Deflection and Interpretation\n\nThe midspan deflection $w(L/2)$ is then computed. For the test cases provided, $N$ is always even, which means the midspan $x=L/2$ coincides with node $N/2$. The deflection is therefore directly given by the nodal displacement value $D[2 \\times (N/2)] = D[N]$ from the global solution vector. The absolute difference $|w_{\\text{cons}}(L/2) - w_{\\text{lump}}(L/2)|$ quantifies the discrepancy between the models.\n\nThis discrepancy can be interpreted using Saint-Venant's principle, which states that the effects of a statically equivalent load are localized. Far from the region of load application, the structural response (stress, strain, displacement) depends only on the load's net resultant (total force and moment), not its detailed distribution.\n\n- **Case 1 & 3 (Localized Load):** The load patch is small and located at one end of the beam, far from the midspan. Saint-Venant's principle predicts that the midspan deflection should be insensitive to the local differences between the lumped and consistent models. The beam structure effectively \"smooths out\" these differences. Therefore, the absolute difference in deflections is expected to be small.\n\n- **Case 2 (Global Load):** The load covers the entire beam ($a=L$). The load is not localized, so there is no \"far-field\" region. The a-priori assumption of Saint-Venant's principle does not hold. The differences between the loading models are applied over the entire structure. The consistent model correctly captures work-conjugate moments from the distributed load on each element, while the lumped model omits them. This fundamental modeling difference is expected to produce a noticeable discrepancy in the global displacement field, including at the midspan.\n\n- **Case 4 (Coarse Discretization):** A coarse mesh ($N=4$) means each element is large ($h=L/4=2.5$ m). The lumped model, which concentrates the load at nodes, becomes a much cruder approximation of the distributed load compared to a fine mesh. The \"near-field\" of each point load is larger, and the smoothing effect of the structure is less effective over the scale of the coarse elements. This increased approximation error in the lumped model is expected to cause a larger difference compared to its fine-mesh counterpart (Case 1).",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the beam problem for all test cases and print the results.\n    \"\"\"\n\n    def get_element_stiffness(EI, h):\n        \"\"\"Returns the 4x4 element stiffness matrix for an Euler-Bernoulli beam.\"\"\"\n        return (EI / h**3) * np.array([\n            [12, 6 * h, -12, 6 * h],\n            [6 * h, 4 * h**2, -6 * h, 2 * h**2],\n            [-12, -6 * h, 12, -6 * h],\n            [6 * h, 2 * h**2, -6 * h, 4 * h**2]\n        ])\n\n    def get_consistent_load_vector(q0, s, h):\n        \"\"\"Calculates the consistent load vector for a load over [0, s] in local coords.\"\"\"\n        if s <= 1e-12: # Tolerance for zero length\n            return np.zeros(4)\n        \n        # Indefinite integrals of shape functions, evaluated at s.\n        f = np.zeros(4)\n        f[0] = s - s**3/h**2 + s**4/(2*h**3)\n        f[1] = s**2/2 - 2*s**3/(3*h) + s**4/(4*h**2)\n        f[2] = s**3/h**2 - s**4/(2*h**3)\n        f[3] = -s**3/(3*h) + s**4/(4*h**2)\n        \n        return q0 * f\n\n    def get_lumped_load_vector(q0, s, h):\n        \"\"\"Calculates the lumped load vector for a load over [0, s] in local coords.\"\"\"\n        if s <= 1e-12: # Tolerance for zero length\n            return np.zeros(4)\n        \n        total_force = q0 * s\n        f_lump = np.zeros(4)\n        \n        # Using a small tolerance for floating point comparison of s and h\n        if np.isclose(s, h):  # Fully loaded element\n            f_lump[0] = total_force / 2\n            f_lump[2] = total_force / 2\n        else:  # Partially loaded element from the left\n            f_lump[0] = total_force\n            \n        return f_lump\n    \n    def shape_functions(xi, h):\n        \"\"\"Calculates cubic Hermite shape functions at a given local coordinate xi.\"\"\"\n        N = np.zeros(4)\n        N[0] = 1 - 3*(xi/h)**2 + 2*(xi/h)**3\n        N[1] = xi - 2*xi**2/h + xi**3/h**2\n        N[2] = 3*(xi/h)**2 - 2*(xi/h)**3\n        N[3] = -xi**2/h + xi**3/h**2\n        return N\n\n    def solve_beam_case(L, a, q0, E, I, N):\n        \"\"\"Solves a single instance of the beam problem.\"\"\"\n        h = L / N\n        EI = E * I\n        num_dofs = 2 * (N + 1)\n        \n        K = np.zeros((num_dofs, num_dofs))\n        F_cons = np.zeros(num_dofs)\n        F_lump = np.zeros(num_dofs)\n        \n        k_e = get_element_stiffness(EI, h)\n        \n        for e in range(N):\n            x_e = e * h\n            # Calculate the length of the loaded portion 's' for the current element\n            s = max(0, min(a, x_e + h) - x_e)\n            \n            if s > 0:\n                f_e_cons = get_consistent_load_vector(q0, s, h)\n                f_e_lump = get_lumped_load_vector(q0, s, h)\n                \n                # Assemble load vectors\n                dof_map = np.array([2*e, 2*e + 1, 2*(e+1), 2*(e+1) + 1])\n                F_cons[dof_map] += f_e_cons\n                F_lump[dof_map] += f_e_lump\n\n            # Assemble stiffness matrix\n            dof_map = np.array([2*e, 2*e+1, 2*(e+1), 2*(e+1)+1])\n            K[np.ix_(dof_map, dof_map)] += k_e\n\n        # Apply boundary conditions w(0)=0 and w(L)=0 using the penalty method\n        K_mod = K.copy()\n        # A large number relative to stiffness matrix diagonal values\n        penalty = 1e12 * np.max(np.diag(K)) if N > 0 else 1e12\n        \n        # DOF for w(0) is 0\n        K_mod[0, 0] += penalty\n        # DOF for w(L) is 2*N\n        K_mod[2*N, 2*N] += penalty\n        \n        # Solve for nodal displacements for both loading cases\n        D_cons = np.linalg.solve(K_mod, F_cons)\n        D_lump = np.linalg.solve(K_mod, F_lump)\n        \n        w_mid_cons = 0.0\n        w_mid_lump = 0.0\n        \n        if N % 2 == 0:  # N is even, midspan L/2 is at node N/2\n            midspan_dof_idx = N\n            w_mid_cons = D_cons[midspan_dof_idx]\n            w_mid_lump = D_lump[midspan_dof_idx]\n        else:  # N is odd, midspan is inside an element\n            e_mid = int(L/2 / h)\n            x_e_mid = e_mid * h\n            xi = L/2 - x_e_mid\n            \n            N_mid = shape_functions(xi, h)\n            dof_map_mid = np.array([2*e_mid, 2*e_mid+1, 2*(e_mid+1), 2*(e_mid+1)+1])\n            \n            d_cons_local = D_cons[dof_map_mid]\n            d_lump_local = D_lump[dof_map_mid]\n            \n            w_mid_cons = N_mid.dot(d_cons_local)\n            w_mid_lump = N_mid.dot(d_lump_local)\n            \n        return abs(w_mid_cons - w_mid_lump)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (L, a, q0, E, I, N)\n        (10.0, 1.0, 1000.0, 210e9, 8e-6, 20),\n        (10.0, 10.0, 1000.0, 210e9, 8e-6, 20),\n        (10.0, 0.2, 1000.0, 210e9, 8e-6, 20),\n        (10.0, 1.0, 1000.0, 210e9, 8e-6, 4),\n    ]\n\n    results = []\n    for case in test_cases:\n        difference = solve_beam_case(*case)\n        results.append(difference)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Moving beyond isotropic assumptions, this advanced problem explores the nuanced, directional nature of Saint-Venant decay in anisotropic materials. You will investigate how the decay of stress disturbances is not uniform but is instead governed by the principal directions of the material's stiffness. This practice combines analytical derivation with numerical verification to reveal the deeper connection between a material's constitutive law and the far-field response, a key concept in modeling composite materials and other complex structures. ",
            "id": "3597322",
            "problem": "Consider a two-dimensional antiplane shear model for a homogeneous, linear elastic, orthotropic solid. Let $w(x,y)$ denote the out-of-plane displacement. The equilibrium equation in the absence of body forces is governed by the divergence of anisotropic shear stiffness, and when localized loads are present it can be written as $C_x \\frac{\\partial^2 w}{\\partial x^2} + C_y \\frac{\\partial^2 w}{\\partial y^2} = -q(x,y)$, where $C_x>0$ and $C_y>0$ are constant effective stiffnesses along the $x$ and $y$ directions, and $q(x,y)$ is a load distribution that is localized near the origin. This scalar anisotropic antiplane model is a standard surrogate used to reason from first principles about Saint-Venant's principle for orthotropic media. Two loadings are said to be equivalent when they produce the same resultant and the same first moments about the origin.\n\nYour task is to use these foundations to analyze, compute, and verify the directional decay of far-field differences between two equivalent loadings in a strongly anisotropic material, mapping the observed decay rates to the anisotropic Green’s function implied by the governing equilibrium equation and verifying numerically that Saint-Venant’s principle holds directionally. Proceed as follows.\n\n1. Starting from the equilibrium equation $C_x \\frac{\\partial^2 w}{\\partial x^2} + C_y \\frac{\\partial^2 w}{\\partial y^2} = -q(x,y)$, derive the anisotropic Green’s function $G(x,y)$ for a unit point source at the origin and express $G$ in terms of the anisotropic “elliptic radius” defined by a coordinate scaling that reduces the operator to the isotropic Laplacian. Explain why, for two equivalent loadings with zero net difference in resultant and first moments, the far-field difference $w_{\\Delta}(x,y)$ decays faster than the field produced by a single point source, and identify the leading multipolar order governing this decay.\n\n2. Consider two loadings:\n   - Loading $A$: a single point source of strength $Q$ at the origin, $q_A(x,y) = Q\\,\\delta(x)\\delta(y)$.\n   - Loading $B$: two point sources each of strength $Q/2$ at $(x,y)=(a,0)$ and $(x,y)=(-a,0)$, $q_B(x,y) = \\frac{Q}{2}\\,\\delta(x-a)\\delta(y) + \\frac{Q}{2}\\,\\delta(x+a)\\delta(y)$.\n   These loadings are equivalent in resultant and first moments about the origin. Let $w_A$ and $w_B$ be the corresponding displacements. Define the difference field $w_{\\Delta}(x,y) = w_B(x,y) - w_A(x,y)$, and determine its leading-order far-field asymptotic directional decay as $r \\to \\infty$ along rays of fixed angle. Here $r$ is the Euclidean distance and angles are to be measured in radians. Show that the leading decay of $w_{\\Delta}$ is governed by a quadrupolar term that depends on the anisotropy through the elliptic metric, and express the directional dependence using the angle in the scaled coordinates.\n\n3. Implement a program that computes $w_{\\Delta}(x,y)$ numerically via superposition of the derived anisotropic Green’s function for the above loadings. Along each specified ray of direction $\\varphi$ (angle in radians measured from the $x$-axis in the physical coordinates), sample radii $r$ between $r_{\\min}$ and $r_{\\max}$, and:\n   - Estimate the decay exponent by fitting $\\log|w_{\\Delta}(r,\\varphi)|$ versus $\\log r$ over the far-field subset and extracting the slope.\n   - Compute the far-field amplitude consistency by comparing the numerically observed value of $w_{\\Delta}(r,\\varphi)\\,r^2$ at the largest $r$ to the analytical leading-order amplitude you derived in terms of anisotropy and direction. Quantify the agreement as a ratio and check if it is close to $1$ within a specified tolerance.\n\n4. Use the following test suite of parameter values to assess the behavior in different regimes, including isotropy, strong anisotropy, and extreme anisotropy. All spatial quantities are to be interpreted in meters, stiffnesses in consistent units, and angles in radians. The outputs are dimensionless. Let $r_{\\min} = 10\\,a$ and $r_{\\max} = 100\\,a$ with a logarithmically spaced sampling of $50$ points per ray, and use linear regression for slope estimation over the far-field half of the samples. For each direction and test case, produce two outputs: a float equal to the estimated decay slope, followed by a boolean that is true if and only if the slope is within a tolerance of $\\pm 0.05$ from the theoretical value and the amplitude ratio at $r_{\\max}$ is within $\\pm 0.05$ of $1$.\n   - Case 1 (isotropy, baseline): $C_x = 1.0$, $C_y = 1.0$, $a = 0.1$, $Q = 1.0$, directions $\\varphi \\in \\{0.0,\\pi/3,\\pi/2\\}$.\n   - Case 2 (strong anisotropy): $C_x = 100.0$, $C_y = 1.0$, $a = 0.1$, $Q = 1.0$, directions $\\varphi \\in \\{0.0,\\pi/6,\\pi/2\\}$.\n   - Case 3 (extreme anisotropy): $C_x = 1000.0$, $C_y = 1.0$, $a = 0.1$, $Q = 1.0$, directions $\\varphi \\in \\{0.0,0.08726646259971647,1.4835298641951802\\}$, corresponding to $5^\\circ$ and $85^\\circ$ in radians.\n\n5. Final output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain, for each direction in each case and in the order given above, the estimated slope (float) followed immediately by the boolean verification result (true if both the slope and amplitude checks pass, false otherwise). For example, an output with $9$ directional checks would look like $[s_1,b_1,s_2,b_2,\\dots,s_9,b_9]$.\n\nAdhere to the following requirements:\n- All angles must be expressed and used in radians.\n- If a check requires a tolerance, use $0.05$ for both the slope tolerance and the amplitude ratio tolerance.\n- The program must be self-contained and require no user input.",
            "solution": "The problem is assessed to be valid as it is scientifically grounded in the principles of linear elasticity and computational mechanics, is well-posed with a clear and objective formulation, and contains a complete and consistent set of data and constraints. The problem poses a standard, albeit non-trivial, exercise in applying fundamental concepts (Green's functions, multipole expansions, Saint-Venant's principle) to a specific physical model (anisotropic antiplane shear) and verifying the results numerically.\n\n### Part 1: Anisotropic Green's Function and Far-Field Decay\n\nThe governing equilibrium equation for the out-of-plane displacement $w(x,y)$ in a homogeneous, linear elastic, orthotropic solid under antiplane shear is given by:\n$$\nC_x \\frac{\\partial^2 w}{\\partial x^2} + C_y \\frac{\\partial^2 w}{\\partial y^2} = -q(x,y)\n$$\nwhere $C_x > 0$ and $C_y > 0$ are the effective shear stiffnesses and $q(x,y)$ is the distributed load.\n\nThe Green's function $G(x,y)$ is the solution for a unit point source at the origin, i.e., $q(x,y) = \\delta(x)\\delta(y)$. It satisfies the equation:\n$$\nC_x \\frac{\\partial^2 G}{\\partial x^2} + C_y \\frac{\\partial^2 G}{\\partial y^2} = -\\delta(x)\\delta(y)\n$$\nTo solve this, we introduce a coordinate scaling that transforms the anisotropic operator into the standard isotropic Laplacian. Let the scaled coordinates $(\\tilde{x}, \\tilde{y})$ be defined as:\n$$\n\\tilde{x} = \\frac{x}{\\sqrt{C_x}}, \\quad \\tilde{y} = \\frac{y}{\\sqrt{C_y}}\n$$\nUsing the chain rule, the partial derivatives transform as $\\frac{\\partial^2}{\\partial x^2} = \\frac{1}{C_x}\\frac{\\partial^2}{\\partial \\tilde{x}^2}$ and $\\frac{\\partial^2}{\\partial y^2} = \\frac{1}{C_y}\\frac{\\partial^2}{\\partial \\tilde{y}^2}$. The Dirac delta function transforms according to $\\delta(ax) = \\frac{1}{|a|}\\delta(x)$, so $\\delta(x)\\delta(y) = \\delta(\\sqrt{C_x}\\tilde{x})\\delta(\\sqrt{C_y}\\tilde{y}) = \\frac{1}{\\sqrt{C_x C_y}}\\delta(\\tilde{x})\\delta(\\tilde{y})$.\n\nSubstituting these into the Green's function equation yields:\n$$\nC_x \\left(\\frac{1}{C_x}\\frac{\\partial^2 G}{\\partial \\tilde{x}^2}\\right) + C_y \\left(\\frac{1}{C_y}\\frac{\\partial^2 G}{\\partial \\tilde{y}^2}\\right) = -\\frac{1}{\\sqrt{C_x C_y}}\\delta(\\tilde{x})\\delta(\\tilde{y})\n$$\n$$\n\\frac{\\partial^2 G}{\\partial \\tilde{x}^2} + \\frac{\\partial^2 G}{\\partial \\tilde{y}^2} \\equiv \\tilde{\\nabla}^2 G = -\\frac{1}{\\sqrt{C_x C_y}}\\delta(\\tilde{x})\\delta(\\tilde{y})\n$$\nThis is the Poisson equation for the 2D isotropic Laplacian operator $\\tilde{\\nabla}^2$. The fundamental solution to $\\tilde{\\nabla}^2 G_{iso} = -\\delta(\\tilde{x})\\delta(\\tilde{y})$ is $G_{iso}(\\tilde{x},\\tilde{y}) = -\\frac{1}{2\\pi}\\ln(\\tilde{r})$, where $\\tilde{r} = \\sqrt{\\tilde{x}^2 + \\tilde{y}^2}$ is the radial distance in the scaled coordinate system. By linearity, the solution for $G$ is:\n$$\nG(\\tilde{x}, \\tilde{y}) = \\frac{1}{\\sqrt{C_x C_y}} G_{iso}(\\tilde{x},\\tilde{y}) = -\\frac{1}{2\\pi\\sqrt{C_x C_y}} \\ln(\\tilde{r})\n$$\nTransforming back to the physical coordinates $(x,y)$, we obtain the anisotropic Green's function:\n$$\nG(x,y) = -\\frac{1}{2\\pi\\sqrt{C_x C_y}} \\ln\\left(\\sqrt{\\frac{x^2}{C_x} + \\frac{y^2}{C_y}}\\right) = -\\frac{1}{4\\pi\\sqrt{C_x C_y}} \\ln\\left(\\frac{x^2}{C_x} + \\frac{y^2}{C_y}\\right)\n$$\nThe quantity $R_{ellip} = \\sqrt{x^2/C_x + y^2/C_y}$ is the anisotropic \"elliptic radius\" mentioned in the problem.\n\nFor two equivalent loadings $q_1$ and $q_2$, their difference $q_{\\Delta} = q_2 - q_1$ has zero net resultant force and zero net first moments about the origin. The displacement field $w_\\Delta$ due to $q_\\Delta$ is found by convolution with the Green's function, $w_\\Delta(\\mathbf{x}) = \\int G(\\mathbf{x}-\\mathbf{x'}) q_\\Delta(\\mathbf{x'}) d\\mathbf{x'}$. For a far-field point $\\mathbf{x}$ (i.e., $|\\mathbf{x}| \\gg |\\mathbf{x'}|$), we can Taylor-expand the Green's function:\n$$\nG(\\mathbf{x}-\\mathbf{x'}) \\approx G(\\mathbf{x}) - \\mathbf{x'} \\cdot \\nabla G(\\mathbf{x}) + \\frac{1}{2} (\\mathbf{x'} \\cdot \\nabla)^2 G(\\mathbf{x}) + \\dots\n$$\nIntegrating term by term gives the multipole expansion of the displacement field:\n$$\nw_\\Delta(\\mathbf{x}) \\approx G(\\mathbf{x})\\int q_\\Delta d\\mathbf{x'} - \\nabla G(\\mathbf{x}) \\cdot \\int \\mathbf{x'} q_\\Delta d\\mathbf{x'} + \\frac{1}{2}\\sum_{i,j} \\frac{\\partial^2 G(\\mathbf{x})}{\\partial x_i \\partial x_j} \\int x'_i x'_j q_\\Delta d\\mathbf{x'} + \\dots\n$$\nThe first integral is the total force (monopole moment), and the second is the first moment (dipole moment vector). Since the loadings are equivalent, both of these moments of $q_\\Delta$ are zero. Thus, the monopole and dipole terms vanish. The leading-order contribution to the far-field displacement is from the quadrupole moment tensor, with components $Q_{ij} = \\int x'_i x'_j q_\\Delta d\\mathbf{x'}$. The Green's function $G(x,y)$ decays logarithmically, $\\sim\\ln r$. Its first derivatives (dipole field) decay as $\\sim 1/r$, and its second derivatives (quadrupole field) decay as $\\sim 1/r^2$. Therefore, the difference field $w_\\Delta$ decays as $O(r^{-2})$, which is faster than the field of a single point source, demonstrating Saint-Venant's principle. The leading multipolar order is quadrupolar.\n\n### Part 2: Asymptotic Decay for Specific Loadings\n\nWe are given:\n- Loading A: $q_A(x,y) = Q\\,\\delta(x)\\delta(y)$\n- Loading B: $q_B(x,y) = \\frac{Q}{2}\\,\\delta(x-a)\\delta(y) + \\frac{Q}{2}\\,\\delta(x+a)\\delta(y)$\nThe difference loading is $q_\\Delta = q_B - q_A$. Let's compute its quadrupole moments:\n$$\nQ_{xx} = \\int x^2 q_\\Delta(x,y) dx dy = \\frac{Q}{2}(a)^2 + \\frac{Q}{2}(-a)^2 - Q(0)^2 = Qa^2\n$$\n$$\nQ_{xy} = \\int xy q_\\Delta(x,y) dx dy = 0\n$$\n$$\nQ_{yy} = \\int y^2 q_\\Delta(x,y) dx dy = 0\n$$\nThe far-field displacement difference is dominated by the $Q_{xx}$ component:\n$$\nw_\\Delta(x,y) \\approx \\frac{1}{2} Q_{xx} \\frac{\\partial^2 G}{\\partial x^2}(x,y) = \\frac{Qa^2}{2} \\frac{\\partial^2 G}{\\partial x^2}(x,y)\n$$\nWe compute the second partial derivative of $G$:\n$$\n\\frac{\\partial G}{\\partial x} = -\\frac{1}{2\\pi\\sqrt{C_x C_y}} \\frac{x/C_x}{(x^2/C_x + y^2/C_y)}\n$$\n$$\n\\frac{\\partial^2 G}{\\partial x^2} = -\\frac{1}{2\\pi C_x \\sqrt{C_x C_y}} \\frac{(x^2/C_x + y^2/C_y) - x(2x/C_x)}{(x^2/C_x + y^2/C_y)^2} = \\frac{1}{2\\pi C_x \\sqrt{C_x C_y}} \\frac{x^2/C_x - y^2/C_y}{(x^2/C_x + y^2/C_y)^2}\n$$\nSubstituting this into the expression for $w_\\Delta$:\n$$\nw_\\Delta(x,y) \\approx \\frac{Qa^2}{4\\pi C_x \\sqrt{C_x C_y}} \\frac{x^2/C_x - y^2/C_y}{(x^2/C_x + y^2/C_y)^2}\n$$\nTo analyze the directional dependence, we use physical polar coordinates $(r, \\varphi)$ where $x=r\\cos\\varphi, y=r\\sin\\varphi$. The decay is clearly $O(r^{-2})$, so the theoretical slope of $\\log|w_\\Delta|$ vs. $\\log r$ is $-2$.\nThe leading-order amplitude coefficient is $A_{th}(\\varphi) = w_\\Delta(r,\\varphi) r^2$:\n$$\nA_{th}(\\varphi) = \\frac{Qa^2}{4\\pi C_x \\sqrt{C_x C_y}} \\frac{r^2(\\cos^2\\varphi/C_x - \\sin^2\\varphi/C_y)}{[r^2(\\cos^2\\varphi/C_x + \\sin^2\\varphi/C_y)]^2} = \\frac{Qa^2}{4\\pi C_x \\sqrt{C_x C_y}} \\frac{\\cos^2\\varphi/C_x - \\sin^2\\varphi/C_y}{(\\cos^2\\varphi/C_x + \\sin^2\\varphi/C_y)^2}\n$$\nThis expression shows the dependence on anisotropy through $C_x$ and $C_y$, and on direction through $\\varphi$. To express this using the angle $\\tilde{\\varphi}$ in the scaled coordinates, we note that $\\tilde{x} = \\tilde{r}\\cos\\tilde{\\varphi}$ and $\\tilde{y} = \\tilde{r}\\sin\\tilde{\\varphi}$. We have $\\cos^2\\tilde{\\varphi} = \\frac{\\tilde{x}^2}{\\tilde{r}^2} = \\frac{x^2/C_x}{x^2/C_x+y^2/C_y}$ and $\\sin^2\\tilde{\\varphi} = \\frac{y^2/C_y}{x^2/C_x+y^2/C_y}$. The directional part of the amplitude can be written as:\n$$\n\\frac{\\cos^2\\varphi/C_x - \\sin^2\\varphi/C_y}{(\\cos^2\\varphi/C_x + \\sin^2\\varphi/C_y)^2} = \\frac{\\cos^2\\tilde{\\varphi} - \\sin^2\\tilde{\\varphi}}{(\\cos^2\\varphi/C_x + \\sin^2\\varphi/C_y)} = \\frac{\\cos(2\\tilde{\\varphi})}{(\\cos^2\\varphi/C_x + \\sin^2\\varphi/C_y)}\n$$\nwhere $\\tilde{\\varphi} = \\operatorname{atan2}(\\tilde{y}, \\tilde{x}) = \\operatorname{atan2}(y/\\sqrt{C_y}, x/\\sqrt{C_x})$.\n\n### Part 3: Numerical Implementation and Verification\n\nThe numerical part involves computing $w_\\Delta(x,y)$ directly from the superposition of Green's functions and comparing its far-field behavior to the derived asymptotic formula.\nThe exact displacement difference is:\n$$\nw_\\Delta(x,y) = w_B(x,y) - w_A(x,y) = \\frac{Q}{2}[G(x-a, y) + G(x+a, y)] - QG(x,y)\n$$\nSubstituting the expression for $G$ and using logarithm properties, we get the form for computation:\n$$\nw_\\Delta(x,y) = -\\frac{Q}{8\\pi\\sqrt{C_x C_y}} \\ln\\left[ \\frac{\\left(\\frac{(x-a)^2}{C_x} + \\frac{y^2}{C_y}\\right)\\left(\\frac{(x+a)^2}{C_x} + \\frac{y^2}{C_y}\\right)}{\\left(\\frac{x^2}{C_x} + \\frac{y^2}{C_y}\\right)^2} \\right]\n$$\nThe procedure for each test case and direction $\\varphi$ is:\n1.  Generate $N=50$ points for the radius $r$ logarithmically spaced between $r_{\\min}=10a$ and $r_{\\max}=100a$.\n2.  For each $r$, compute the Cartesian coordinates $(x,y)=(r\\cos\\varphi, r\\sin\\varphi)$ and evaluate $w_\\Delta(x,y)$ using the formula above.\n3.  Take the far-field subset of the data, which corresponds to the last $N/2 = 25$ points.\n4.  Perform a linear regression on $\\log|w_\\Delta|$ versus $\\log r$ for this subset. The slope of this fit is the estimated decay exponent.\n5.  Verify the slope: check if it is within $\\pm 0.05$ of the theoretical value of $-2$.\n6.  Compute the numerical amplitude at the largest radius: $A_{num} = |w_\\Delta(r_{\\max}, \\varphi)| \\cdot r_{\\max}^2$.\n7.  Compute the theoretical amplitude $A_{th}(\\varphi)$ using the derived formula:\n    $$\n    A_{th}(\\varphi) = \\left| \\frac{Qa^2}{4\\pi C_x \\sqrt{C_x C_y}} \\frac{\\cos^2\\varphi/C_x - \\sin^2\\varphi/C_y}{(\\cos^2\\varphi/C_x + \\sin^2\\varphi/C_y)^2} \\right|\n    $$\n8.  Verify the amplitude: compute the ratio $A_{num}/A_{th}$ and check if it is within $\\pm 0.05$ of $1$.\n9.  The final boolean result for the direction is `True` if and only if both the slope and amplitude verifications pass.\n\nThis process will be automated in the provided Python script.",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import linregress\n\ndef solve():\n    \"\"\"\n    Computes and verifies the directional decay of far-field displacement differences\n    between two equivalent loadings in an anisotropic elastic solid.\n    \"\"\"\n    \n    test_suite = [\n        {\n            \"case_name\": \"Isotropy\",\n            \"params\": {\"Cx\": 1.0, \"Cy\": 1.0, \"a\": 0.1, \"Q\": 1.0},\n            \"directions_rad\": [0.0, np.pi/3, np.pi/2],\n        },\n        {\n            \"case_name\": \"Strong Anisotropy\",\n            \"params\": {\"Cx\": 100.0, \"Cy\": 1.0, \"a\": 0.1, \"Q\": 1.0},\n            \"directions_rad\": [0.0, np.pi/6, np.pi/2],\n        },\n        {\n            \"case_name\": \"Extreme Anisotropy\",\n            \"params\": {\"Cx\": 1000.0, \"Cy\": 1.0, \"a\": 0.1, \"Q\": 1.0},\n            \"directions_rad\": [0.0, 0.08726646259971647, 1.4835298641951802], # 0, 5, 85 degrees\n        },\n    ]\n\n    r_min_factor = 10.0\n    r_max_factor = 100.0\n    num_points = 50\n    slope_tolerance = 0.05\n    amplitude_tolerance = 0.05\n    theoretical_slope = -2.0\n\n    all_results = []\n\n    for case in test_suite:\n        params = case[\"params\"]\n        Cx, Cy, a, Q = params[\"Cx\"], params[\"Cy\"], params[\"a\"], params[\"Q\"]\n        \n        r_min = r_min_factor * a\n        r_max = r_max_factor * a\n        \n        radii = np.logspace(np.log10(r_min), np.log10(r_max), num_points)\n        log_radii = np.log(radii)\n\n        for phi in case[\"directions_rad\"]:\n            # --- 1. Compute numerical w_delta ---\n            x = radii * np.cos(phi)\n            y = radii * np.sin(phi)\n\n            # Argument for the logarithm in the w_delta formula\n            term_xa_sq = (x - a)**2 / Cx + y**2 / Cy\n            term_xpa_sq = (x + a)**2 / Cx + y**2 / Cy\n            term_x_sq = x**2 / Cx + y**2 / Cy\n            \n            # To avoid log(0) or issues at the origin if calculated there\n            # We filter for valid terms, which is always true for r > 0\n            valid_mask = (term_xa_sq > 0) & (term_xpa_sq > 0) & (term_x_sq > 0)\n            \n            w_delta_vals = np.zeros_like(radii)\n            if np.any(valid_mask):\n                log_arg = (term_xa_sq[valid_mask] * term_xpa_sq[valid_mask]) / (term_x_sq[valid_mask]**2)\n                \n                prefactor = -Q / (8.0 * np.pi * np.sqrt(Cx * Cy))\n                w_delta_vals[valid_mask] = prefactor * np.log(log_arg)\n\n            # --- 2. Estimate decay slope ---\n            far_field_start_index = num_points // 2\n            \n            log_w_delta_abs = np.log(np.abs(w_delta_vals[far_field_start_index:]))\n            log_radii_far_field = log_radii[far_field_start_index:]\n            \n            regression_result = linregress(log_radii_far_field, log_w_delta_abs)\n            estimated_slope = regression_result.slope\n\n            # --- 3. Check amplitude consistency ---\n            # Numerical amplitude at r_max\n            A_num = np.abs(w_delta_vals[-1]) * radii[-1]**2\n\n            # Theoretical amplitude\n            cos_phi_sq = np.cos(phi)**2\n            sin_phi_sq = np.sin(phi)**2\n            \n            term_cos = cos_phi_sq / Cx\n            term_sin = sin_phi_sq / Cy\n            \n            amp_num_term = np.abs(term_cos - term_sin)\n            amp_den_term = (term_cos + term_sin)**2\n            \n            # Handle cases where denominator is zero (not expected for given inputs)\n            if amp_den_term == 0:\n                amplitude_ratio = np.inf\n            else:\n                A_th_prefactor = (Q * a**2) / (4 * np.pi * Cx * np.sqrt(Cx * Cy))\n                A_th = A_th_prefactor * amp_num_term / amp_den_term\n                \n                if A_th == 0:\n                  # If theory predicts zero amp, and numerical is small, ratio is ill-defined but consistent\n                  amplitude_ratio = 1.0 if np.isclose(A_num, 0) else np.inf\n                else:\n                  amplitude_ratio = A_num / A_th\n\n            # --- 4. Perform verification checks ---\n            slope_check = np.abs(estimated_slope - theoretical_slope) <= slope_tolerance\n            amplitude_check = np.abs(amplitude_ratio - 1.0) <= amplitude_tolerance\n            verification_passed = slope_check and amplitude_check\n            \n            all_results.append(f\"{estimated_slope:.8f}\")\n            all_results.append(str(verification_passed).lower())\n\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```"
        }
    ]
}