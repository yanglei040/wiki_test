{
    "hands_on_practices": [
        {
            "introduction": "在连续介质力学中，二阶张量的双点积 $A:B$ 和矩阵乘积的迹 $\\operatorname{tr}(AB)$ 是两个基础的标量不变量。虽然当其中至少一个张量为对称张量时（例如应力张量和应变张量），这两个运算是等价的，但对于一般的非对称张量，它们是截然不同的。本练习旨在通过构建一个具体的反例来加深对这一区别的精确理解，以避免在处理非对称张量（例如在极分解或非对称应力测量中出现的张量）时陷入常见误区 。",
            "id": "3604877",
            "problem": "考虑定义在三维欧几里得体上的两个二阶张量 $A$ 和 $B$，该欧几里得体具有一组标准正交基。$A$ 和 $B$ 的双点积定义为 $A:B = \\sum_{i=1}^{3}\\sum_{j=1}^{3} A_{ij} B_{ij}$，其乘积的迹定义为 $\\operatorname{tr}(AB) = \\sum_{i=1}^{3} (AB)_{ii} = \\sum_{i=1}^{3}\\sum_{j=1}^{3} A_{ij} B_{ji}$。在计算固体力学中，等式 $A:B = \\operatorname{tr}(AB)$ 常在对称性假设下使用。从上述核心定义出发，在不假设对称性的情况下，提供一个分量形式的反例，以证明 $A:B \\neq \\operatorname{tr}(AB)$。\n\n使用以下具体张量\n$$\nA = \\begin{pmatrix}\n0  2  0 \\\\\n0  0  0 \\\\\n0  0  0\n\\end{pmatrix},\\qquad\nB = \\begin{pmatrix}\n0  0  0 \\\\\n3  0  0 \\\\\n0  0  0\n\\end{pmatrix}.\n$$\n直接根据定义计算 $A:B$ 和 $\\operatorname{tr}(AB)$，并将标量差 $A:B - \\operatorname{tr}(AB)$ 报告为一个实数。最终答案无需单位。",
            "solution": "该问题经验证是自洽、科学上合理且提法得当的。目标是为给定的非对称二阶张量 $A$ 和 $B$ 计算标量差 $A:B - \\operatorname{tr}(AB)$。\n\n给定的具体张量是：\n$$\nA = \\begin{pmatrix}\n0  2  0 \\\\\n0  0  0 \\\\\n0  0  0\n\\end{pmatrix},\\qquad\nB = \\begin{pmatrix}\n0  0  0 \\\\\n3  0  0 \\\\\n0  0  0\n\\end{pmatrix}.\n$$\n以分量形式表示，张量 $A$ 的唯一非零分量是 $A_{12} = 2$。张量 $B$ 的唯一非零分量是 $B_{21} = 3$。对于 $(i,j) \\in \\{1, 2, 3\\} \\times \\{1, 2, 3\\}$，所有其他分量 $A_{ij}$ 和 $B_{ij}$ 均等于 $0$。\n\n首先，我们使用给定的定义计算双点积 $A:B$：\n$$\nA:B = \\sum_{i=1}^{3}\\sum_{j=1}^{3} A_{ij} B_{ij}\n$$\n这个运算，也称为弗罗贝尼乌斯内积，涉及将两个张量对应分量的乘积求和。我们可以展开这个和：\n$$\nA:B = A_{11}B_{11} + A_{12}B_{12} + A_{13}B_{13} + A_{21}B_{21} + A_{22}B_{22} + A_{23}B_{23} + A_{31}B_{31} + A_{32}B_{32} + A_{33}B_{33}\n$$\n代入 $A$ 和 $B$ 的分量值：\n$$\nA:B = (0)(0) + (2)(0) + (0)(0) + (0)(3) + (0)(0) + (0)(0) + (0)(0) + (0)(0) + (0)(0)\n$$\n求和中的每一项都为零。例如，涉及非零分量 $A_{12}=2$ 的项是 $A_{12}B_{12}$，但 $B_{12}=0$。同样，涉及非零分量 $B_{21}=3$ 的项是 $A_{21}B_{21}$，但 $A_{21}=0$。\n因此，双点积为：\n$$\nA:B = 0\n$$\n\n接下来，我们计算张量积 $AB$ 的迹，记为 $\\operatorname{tr}(AB)$。给出的定义是：\n$$\n\\operatorname{tr}(AB) = \\sum_{i=1}^{3}\\sum_{j=1}^{3} A_{ij} B_{ji}\n$$\n该求和操作包括将分量 $A_{ij}$ 与分量 $B_{ji}$（注意 $B$ 的转置索引）相乘，并对所有 $i$ 和 $j$ 求和。我们来检查这个求和中的各项。$A$ 的唯一非零分量是 $A_{12} = 2$。因此，在整个双重求和中，唯一可能非零的项是当 $i=1$ 和 $j=2$ 时的项。该项为 $A_{12}B_{21}$。所有其他项都将为零，因为当 $(i,j) \\neq (1,2)$ 时 $A_{ij}=0$。\n\n我们来计算这个唯一的非零项：\n$$\nA_{12}B_{21} = (2)(3) = 6\n$$\n由于和中的所有其他项都为零，迹的值完全由这一项确定：\n$$\n\\operatorname{tr}(AB) = \\sum_{i=1}^{3}\\sum_{j=1}^{3} A_{ij} B_{ji} = A_{12}B_{21} + \\sum_{(i,j) \\neq (1,2)} A_{ij}B_{ji} = 6 + 0 = 6\n$$\n或者，可以先计算矩阵乘积 $C = AB$：\n$$\nC = AB = \\begin{pmatrix} 0  2  0 \\\\ 0  0  0 \\\\ 0  0  0 \\end{pmatrix} \\begin{pmatrix} 0  0  0 \\\\ 3  0  0 \\\\ 0  0  0 \\end{pmatrix} = \\begin{pmatrix} (0)(0)+(2)(3)+(0)(0)  (0)(0)+(2)(0)+(0)(0)  (0)(0)+(2)(0)+(0)(0) \\\\ 0  0  0 \\\\ 0  0  0 \\end{pmatrix}\n$$\n$$\nC = \\begin{pmatrix} 6  0  0 \\\\ 0  0  0 \\\\ 0  0  0 \\end{pmatrix}\n$$\n迹是 $C$ 的对角元素之和：\n$$\n\\operatorname{tr}(AB) = \\operatorname{tr}(C) = C_{11} + C_{22} + C_{33} = 6 + 0 + 0 = 6\n$$\n两种方法得到相同的结果。\n\n最后，我们计算所需的标量差 $A:B - \\operatorname{tr}(AB)$：\n$$\nA:B - \\operatorname{tr}(AB) = 0 - 6 = -6\n$$\n这个反例表明，对于非对称张量，双点积 $A:B$ 通常不等于其乘积的迹 $\\operatorname{tr}(AB)$。仅当至少一个张量是对称时，等式才成立，而本例中并非如此。",
            "answer": "$$\\boxed{-6}$$"
        },
        {
            "introduction": "在计算固体力学中，为了提高存储和计算效率，对称张量（如应力和应变张量）通常使用 Voigt 记法表示为向量形式。然而，一个核心挑战是确保这种记法上的转换为保持物理不变量，例如代表能量或功的双点积。本练习将引导您验证为何“工程”Voigt 约定（即为剪切项引入因子2）是保持能量共轭性（例如 $\\sigma:\\dot{\\epsilon}$）所必需的，并通过与朴素映射的对比来量化由此产生的误差 。",
            "id": "3604891",
            "problem": "考虑三维空间中的两个对称二阶张量 $A$ 和 $B$，因此对于所有指标 $i,j \\in \\{1,2,3\\}$，都有 $A_{ij} = A_{ji}$ 和 $B_{ij} = B_{ji}$。$A$ 和 $B$ 之间的Frobenius积根据基本原理定义为\n$$\nA : B = \\sum_{i=1}^{3}\\sum_{j=1}^{3} A_{ij} B_{ij}.\n$$\n在计算固体力学中，对称二阶张量通常以Voigt标记法表示为$6$分量向量。在Voigt标记法中，有多种处理剪切分量的约定。一种约定（普通Voigt）将张量分量直接映射到一个向量，不对剪切项施加任何因子。另一种约定（工程Voigt）将类应变量的剪切分量加倍，以在欧几里得点积下保持与类应力量的能量等价性。本任务是根据上述Frobenius积的定义和映射约定，验证当计算Voigt向量之间的点积时，Frobenius积 $A:B$ 是否保持不变，并在忽略工程剪切因子的情况下量化误差。\n\n仅从Frobenius积的定义和张量的对称性出发，按算法执行以下步骤：\n- 实现一个函数，直接从完整的 $3 \\times 3$ 张量表示计算 $A:B$。\n- 对任意对称张量 $T$，实现一个普通Voigt映射 $v_{\\text{plain}}(T)$，定义为\n$$\nv_{\\text{plain}}(T) = \\begin{bmatrix} T_{11} \\\\ T_{22} \\\\ T_{33} \\\\ T_{23} \\\\ T_{13} \\\\ T_{12} \\end{bmatrix}.\n$$\n- 实现一个工程Voigt映射 $v_{\\text{eng}}(T;\\text{role})$，该映射取决于 $T$ 的预期角色：\n    - 对于类应力张量（role = stress），映射时不带剪切因子，\n    $$\n    v_{\\text{eng}}(T;\\text{stress}) = \\begin{bmatrix} T_{11} \\\\ T_{22} \\\\ T_{33} \\\\ T_{23} \\\\ T_{13} \\\\ T_{12} \\end{bmatrix}.\n    $$\n    - 对于类应变张量（role = strain），映射时剪切分量加倍，\n    $$\n    v_{\\text{eng}}(T;\\text{strain}) = \\begin{bmatrix} T_{11} \\\\ T_{22} \\\\ T_{33} \\\\ 2 T_{23} \\\\ 2 T_{13} \\\\ 2 T_{12} \\end{bmatrix}.\n    $$\n- 对于下面的每个测试用例，计算：\n    1. 来自完整张量的真实Frobenius积 $A:B$。\n    2. 点积 $v_{\\text{eng}}(A;\\text{stress}) \\cdot v_{\\text{eng}}(B;\\text{strain})$。\n    3. 点积 $v_{\\text{plain}}(A) \\cdot v_{\\text{plain}}(B)$。\n- 通过检查 $\\left| A:B - v_{\\text{eng}}(A;\\text{stress}) \\cdot v_{\\text{eng}}(B;\\text{strain}) \\right| \\le \\varepsilon$ 是否成立（容差 $\\varepsilon = 10^{-12}$）来验证其保持性，并通过报告以下内容来量化忽略工程因子时的误差：\n    - 绝对误差 $\\left| A:B - v_{\\text{plain}}(A) \\cdot v_{\\text{plain}}(B) \\right|$。\n    - 相对误差，定义为 $\\left| A:B - v_{\\text{plain}}(A) \\cdot v_{\\text{plain}}(B) \\right| / \\left| A:B \\right|$（若 $A:B \\ne 0$），若 $A:B = 0$ 则定义为 $0$。\n\n测试套件由以下对称张量对 $(A,B)$ 组成：\n- 测试用例1（法向和剪切混合的一般对称张量）：\n$$\nA = \\begin{bmatrix}\n3.0  -2.0  1.0 \\\\\n-2.0  0.5  4.0 \\\\\n1.0  4.0  -1.0\n\\end{bmatrix}, \\quad\nB = \\begin{bmatrix}\n1.2  0.8  -1.1 \\\\\n0.8  -0.5  2.3 \\\\\n-1.1  2.3  0.7\n\\end{bmatrix}.\n$$\n- 测试用例2（仅对角张量）：\n$$\nA = \\begin{bmatrix}\n2.0  0.0  0.0 \\\\\n0.0  -1.0  0.0 \\\\\n0.0  0.0  3.0\n\\end{bmatrix}, \\quad\nB = \\begin{bmatrix}\n-4.0  0.0  0.0 \\\\\n0.0  0.5  0.0 \\\\\n0.0  0.0  2.0\n\\end{bmatrix}.\n$$\n- 测试用例3（纯剪切张量）：\n$$\nA = \\begin{bmatrix}\n0.0  5.0  3.0 \\\\\n5.0  0.0  -2.0 \\\\\n3.0  -2.0  0.0\n\\end{bmatrix}, \\quad\nB = \\begin{bmatrix}\n0.0  -1.0  0.5 \\\\\n-1.0  0.0  4.0 \\\\\n0.5  4.0  0.0\n\\end{bmatrix}.\n$$\n- 测试用例4（用于探测数值容差的近零量级）：\n$$\nA = \\begin{bmatrix}\n1.0 \\times 10^{-12}  2.0 \\times 10^{-12}  -3.0 \\times 10^{-12} \\\\\n2.0 \\times 10^{-12}  -1.0 \\times 10^{-12}  5.0 \\times 10^{-13} \\\\\n-3.0 \\times 10^{-12}  5.0 \\times 10^{-13}  -2.0 \\times 10^{-12}\n\\end{bmatrix}, \\quad\nB = \\begin{bmatrix}\n-4.0 \\times 10^{-12}  7.0 \\times 10^{-13}  1.0 \\times 10^{-12} \\\\\n7.0 \\times 10^{-13}  3.0 \\times 10^{-12}  -2.0 \\times 10^{-12} \\\\\n1.0 \\times 10^{-12}  -2.0 \\times 10^{-12}  5.0 \\times 10^{-13}\n\\end{bmatrix}.\n$$\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个元素对应一个测试用例，并且本身是一个包含三个基本类型元素的列表：\n$$\n[\\,[\\text{preserved},\\, \\text{abs\\_error\\_plain},\\, \\text{rel\\_error\\_plain}],\\, \\ldots\\,]\n$$\n此处，$\\text{preserved}$ 是一个布尔值，指示在容差 $\\varepsilon = 10^{-12}$ 内是否保持不变，$\\text{abs\\_error\\_plain}$ 是一个浮点数，$\\text{rel\\_error\\_plain}$ 也是一个浮点数。此问题不涉及物理单位。",
            "solution": "该问题要求对对称二阶张量的Frobenius张量积 $A:B$ 与其对应的Voigt向量表示的欧几里得点积之间的关系进行算法验证。我们将首先建立解析关系，然后实现一个数值程序，以对给定的测试用例进行验证。\n\n设 $A$ 和 $B$ 是三维空间中的两个对称二阶张量。其分量分别表示为 $A_{ij}$ 和 $B_{ij}$，其中指标 $i, j$ 的范围为 $1$ 到 $3$。对称性意味着 $A_{ij} = A_{ji}$ 且 $B_{ij} = B_{ji}$。\n\nFrobenius积，也称为双点积，定义为相应分量乘积之和：\n$$\nA : B = \\sum_{i=1}^{3}\\sum_{j=1}^{3} A_{ij} B_{ij}\n$$\n此运算在连续介质力学中是基础，例如，在内功密度率的表达式 $\\dot{W} = \\sigma : \\dot{\\epsilon}$ 中，$\\sigma$ 是应力张量，$\\dot{\\epsilon}$ 是应变率张量。\n\n由于张量的对称性，我们可以展开求和并对各项进行分组。对角项 ($i=j$) 出现一次，而非对角项 ($i \\ne j$) 出现两次（例如，$A_{12}B_{12}$ 和 $A_{21}B_{21}$）。\n$$\nA : B = (A_{11}B_{11} + A_{22}B_{22} + A_{33}B_{33}) + (A_{12}B_{12} + A_{21}B_{21}) + (A_{13}B_{13} + A_{31}B_{31}) + (A_{23}B_{23} + A_{32}B_{32})\n$$\n利用对称性（$A_{ij} = A_{ji}$ 和 $B_{ij} = B_{ji}$），我们可以将其简化为：\n$$\nA : B = A_{11}B_{11} + A_{22}B_{22} + A_{33}B_{33} + 2A_{12}B_{12} + 2A_{13}B_{13} + 2A_{23}B_{23}\n$$\n该表达式是我们计算乘积正确值的基准。\n\n现在，我们分析Voigt标记法。Voigt标记法是一种将对称张量表示为向量的方法，可减少存储并简化某些运算。但是，必须注意确保像Frobenius积这样的标量不变量得以保持。\n\n首先，考虑普通Voigt映射 $v_{\\text{plain}}(T)$，它将张量分量直接映射到一个向量：\n$$\nv_{\\text{plain}}(A) = \\begin{bmatrix} A_{11} \\\\ A_{22} \\\\ A_{33} \\\\ A_{23} \\\\ A_{13} \\\\ A_{12} \\end{bmatrix}, \\quad\nv_{\\text{plain}}(B) = \\begin{bmatrix} B_{11} \\\\ B_{22} \\\\ B_{33} \\\\ B_{23} \\\\ B_{13} \\\\ B_{12} \\end{bmatrix}\n$$\n这两个向量的标准欧几里得点积为：\n$$\nv_{\\text{plain}}(A) \\cdot v_{\\text{plain}}(B) = A_{11}B_{11} + A_{22}B_{22} + A_{33}B_{33} + A_{23}B_{23} + A_{13}B_{13} + A_{12}B_{12}\n$$\n将其与完整的Frobenius积进行比较，我们观察到一个差异：剪切项（$A_{12}B_{12}$，$A_{13}B_{13}$，$A_{23}B_{23}$）没有乘以因子 $2$。因此，通常情况下，$A:B \\ne v_{\\text{plain}}(A) \\cdot v_{\\text{plain}}(B)$。误差恰好是缺失的剪切项乘积之和：$|A:B - v_{\\text{plain}}(A) \\cdot v_{\\text{plain}}(B)| = |A_{12}B_{12} + A_{13}B_{13} + A_{23}B_{23}|$。\n\n为了修正这一点，工程Voigt标记法 $v_{\\text{eng}}(T)$ 为乘积中其中一个张量的剪切分量引入了因子 $2$。该约定区分了“类应力”和“类应变”量。设 $A$ 为类应力量，$B$ 为类应变量。\n$$\nv_{\\text{eng}}(A;\\text{stress}) = \\begin{bmatrix} A_{11} \\\\ A_{22} \\\\ A_{33} \\\\ A_{23} \\\\ A_{13} \\\\ A_{12} \\end{bmatrix}, \\quad\nv_{\\text{eng}}(B;\\text{strain}) = \\begin{bmatrix} B_{11} \\\\ B_{22} \\\\ B_{33} \\\\ 2B_{23} \\\\ 2B_{13} \\\\ 2B_{12} \\end{bmatrix}\n$$\n这些向量的点积为：\n$$\nv_{\\text{eng}}(A;\\text{stress}) \\cdot v_{\\text{eng}}(B;\\text{strain}) = A_{11}B_{11} + A_{22}B_{22} + A_{33}B_{33} + A_{23}(2B_{23}) + A_{13}(2B_{13}) + A_{12}(2B_{12})\n$$\n$$\n= A_{11}B_{11} + A_{22}B_{22} + A_{33}B_{33} + 2A_{23}B_{23} + 2A_{13}B_{13} + 2A_{12}B_{12}\n$$\n此表达式在代数上与Frobenius积 $A:B$ 的展开式相同。这表明工程Voigt约定是专门为保持功共轭性而设计的，即 $A:B = v_{\\text{eng}}(A;\\text{stress}) \\cdot v_{\\text{eng}}(B;\\text{strain})$。这两个量之间的任何数值差异都应仅归因于浮点精度误差。\n\n算法流程如下：\n$1$. 使用分量求和 $\\sum_{i,j} A_{ij}B_{ij}$ 实现一个计算真实Frobenius积 $A:B$ 的函数。\n$2$. 按照定义实现普通和工程Voigt映射的函数。\n$3$. 对每个测试用例，计算三个量：真实积、工程Voigt点积和普通Voigt点积。\n$4$. 验证真实积与工程积之间的绝对差在给定容差 $\\varepsilon = 10^{-12}$ 之内。\n$5$. 计算使用普通Voigt点积替代真实Frobenius积所产生的绝对误差和相对误差。\n$6$. 按指定格式收集并格式化结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the tensor contraction problem by comparing the Frobenius product\n    with dot products of Voigt vector representations.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\n            np.array([\n                [3.0, -2.0, 1.0],\n                [-2.0, 0.5, 4.0],\n                [1.0, 4.0, -1.0]\n            ]),\n            np.array([\n                [1.2, 0.8, -1.1],\n                [0.8, -0.5, 2.3],\n                [-1.1, 2.3, 0.7]\n            ])\n        ),\n        (\n            np.array([\n                [2.0, 0.0, 0.0],\n                [0.0, -1.0, 0.0],\n                [0.0, 0.0, 3.0]\n            ]),\n            np.array([\n                [-4.0, 0.0, 0.0],\n                [0.0, 0.5, 0.0],\n                [0.0, 0.0, 2.0]\n            ])\n        ),\n        (\n            np.array([\n                [0.0, 5.0, 3.0],\n                [5.0, 0.0, -2.0],\n                [3.0, -2.0, 0.0]\n            ]),\n            np.array([\n                [0.0, -1.0, 0.5],\n                [-1.0, 0.0, 4.0],\n                [0.5, 4.0, 0.0]\n            ])\n        ),\n        (\n            np.array([\n                [1.0e-12, 2.0e-12, -3.0e-12],\n                [2.0e-12, -1.0e-12, 5.0e-13],\n                [-3.0e-12, 5.0e-13, -2.0e-12]\n            ]),\n            np.array([\n                [-4.0e-12, 7.0e-13, 1.0e-12],\n                [7.0e-13, 3.0e-12, -2.0e-12],\n                [1.0e-12, -2.0e-12, 5.0e-13]\n            ])\n        )\n    ]\n\n    def compute_frobenius_product(tensor_A, tensor_B):\n        \"\"\"Computes the Frobenius product A:B = sum(A_ij * B_ij).\"\"\"\n        return np.sum(tensor_A * tensor_B)\n\n    def map_to_plain_voigt(tensor_T):\n        \"\"\"Maps a 3x3 symmetric tensor to its 6-component plain Voigt vector.\"\"\"\n        return np.array([\n            tensor_T[0, 0], tensor_T[1, 1], tensor_T[2, 2],\n            tensor_T[1, 2], tensor_T[0, 2], tensor_T[0, 1]\n        ])\n\n    def map_to_engineering_voigt(tensor_T, role):\n        \"\"\"\n        Maps a 3x3 symmetric tensor to its 6-component engineering Voigt vector.\n        'stress' role has no factors.\n        'strain' role has factors of 2 on shear terms.\n        \"\"\"\n        if role not in ['stress', 'strain']:\n            raise ValueError(\"Role must be 'stress' or 'strain'.\")\n        \n        shear_factor = 2.0 if role == 'strain' else 1.0\n        return np.array([\n            tensor_T[0, 0], tensor_T[1, 1], tensor_T[2, 2],\n            shear_factor * tensor_T[1, 2], \n            shear_factor * tensor_T[0, 2], \n            shear_factor * tensor_T[0, 1]\n        ])\n\n    results = []\n    tolerance = 1e-12\n\n    for A, B in test_cases:\n        # 1. Compute the true Frobenius product from full tensors.\n        true_product = compute_frobenius_product(A, B)\n\n        # 2. Compute the dot product using engineering Voigt notation.\n        v_A_eng = map_to_engineering_voigt(A, role='stress')\n        v_B_eng = map_to_engineering_voigt(B, role='strain')\n        eng_product = np.dot(v_A_eng, v_B_eng)\n\n        # 3. Compute the dot product using plain Voigt notation.\n        v_A_plain = map_to_plain_voigt(A)\n        v_B_plain = map_to_plain_voigt(B)\n        plain_product = np.dot(v_A_plain, v_B_plain)\n\n        # Validate preservation for engineering Voigt.\n        preserved = abs(true_product - eng_product) = tolerance\n\n        # Quantify error for plain Voigt.\n        abs_error_plain = abs(true_product - plain_product)\n        \n        if abs(true_product) == 0:\n            rel_error_plain = 0.0\n        else:\n            rel_error_plain = abs_error_plain / abs(true_product)\n            \n        results.append([preserved, abs_error_plain, rel_error_plain])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "将张量分解为体积部分（保持形状）和偏量部分（引起形状畸变）是连续介质力学，尤其是塑性理论的基石。双点积在定义提取张量偏量部分的投影算子中起着核心作用，而该算子具有一个称为“幂等性”的基本数学性质。本练习将代数工具——双点积——与深刻的物理概念联系起来，您将实现偏量算子，计算对 von Mises 等屈服准则至关重要的偏量能，并数值验证该算子的幂等性 。",
            "id": "3604892",
            "problem": "请使用一种现代编程语言，设计并实现一个完整的算法，用于计算一个标量偏能量度量，并为一个给定的二阶张量验证偏投影的幂等性。使用以下来自连续介质力学的核心定义，所有计算均限于三维二阶张量。\n\n设 Cauchy 应力张量表示为 $\\sigma \\in \\mathbb{R}^{3 \\times 3}$。二阶单位张量表示为 $I \\in \\mathbb{R}^{3 \\times 3}$，其双缩并 $I:I=3$。两个二阶张量 $A$ 和 $B$ 的双点积（也称为双缩并）定义为 $A:B=\\sum_{i=1}^{3}\\sum_{j=1}^{3}A_{ij}B_{ij}$。偏应力算子定义为 $dev(\\sigma)=\\sigma-\\dfrac{1}{3}(\\sigma:I)I$，它将 $\\sigma$ 映射到其无迹部分。\n\n从这些基本定义出发，您必须：\n\n1. 从第一性原理推导为何 $dev(dev(\\sigma))=dev(\\sigma)$，推导过程需明确使用 $I:I=3$ 和双点积的性质，并设计一个算法测试，通过将差值 $dev(dev(\\sigma))-dev(\\sigma)$ 的 Frobenius 范数 $\\|A\\|_{F}=\\sqrt{A:A}$ 与一个小的容差（使用 $10^{-10}$ 作为容差）进行比较，从而对给定输入进行数值化的幂等性验证。\n2. 将偏能量度量 $E_{dev}(\\sigma)$ 定义为标量 $E_{dev}(\\sigma)=\\dfrac{1}{2}\\,dev(\\sigma):dev(\\sigma)$，并实现其计算。所有输入和输出均为无量纲；将输出的能量值表示为浮点数。\n\n您的实现必须是完全自包含的，并为以下数值指定的应力张量测试套件（每个都是对称的 $3 \\times 3$ 矩阵）生成结果：\n\n- 一般情况（非零迹和剪切）：\n  $\\sigma_{A}=\\begin{bmatrix}120  -30  45 \\\\ -30  80  0 \\\\ 45  0  -10\\end{bmatrix}$。\n- 纯静水压情况：$\\sigma_{B}=50\\,I=\\begin{bmatrix}50  0  0 \\\\ 0  50  0 \\\\ 0  0  50\\end{bmatrix}$。\n- 纯偏应力情况（零迹带剪切）：\n  $\\sigma_{C}=\\begin{bmatrix}30  -6  0 \\\\ -6  -15  0 \\\\ 0  0  -15\\end{bmatrix}$。\n- 零张量（边界情况）：\n  $\\sigma_{D}=\\begin{bmatrix}0  0  0 \\\\ 0  0  0 \\\\ 0  0  0\\end{bmatrix}$。\n- 微小量级偏应力情况（边缘情况）：\n  $\\sigma_{E}=\\begin{bmatrix}10^{-12}  2\\cdot 10^{-12}  -3\\cdot 10^{-12} \\\\ 2\\cdot 10^{-12}  -10^{-12}  4\\cdot 10^{-12} \\\\ -3\\cdot 10^{-12}  4\\cdot 10^{-12}  0\\end{bmatrix}$。\n\n为每个测试用例计算：\n- 标量偏能量 $E_{dev}(\\sigma)$，以浮点数表示。\n- 一个布尔标志，指示数值上幂等性是否成立，定义为 $\\|dev(dev(\\sigma))-dev(\\sigma)\\|_{F}  10^{-10}$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。每个元素对应一个测试用例，并且其本身是一个包含浮点数偏能量和布尔幂等性标志的双元素列表。例如，输出格式必须为 $[[E_{A},\\text{flag}_{A}],[E_{B},\\text{flag}_{B}],\\dots]$ 的形式，方括号列表前后不得有任何额外文本。",
            "solution": "问题陈述经评估为 **有效**。它在科学上基于连续介质力学的原理，提法恰当，包含了所有必要的定义和数据，并以客观、正式的语言表述。其中没有矛盾、歧义或事实性错误。因此，我们可以着手提供解决方案。\n\n解决方案需要两个主要部分：对偏应力算子幂等性属性的正式推导，以及设计一个算法来为一组给定的测试用例计算所需的量。\n\n### 第 1 部分：偏应力算子幂等性的推导\n\n偏应力算子 $dev(\\cdot)$ 将一个二阶张量 $\\sigma$ 映射到其无迹部分。其定义如下：\n$$\ndev(\\sigma) = \\sigma - \\frac{1}{3}(\\sigma:I)I\n$$\n其中 $\\sigma$ 是一个二阶张量，$I$ 是二阶单位张量，$A:B$ 表示两个张量 $A$ 和 $B$ 的双点积（或双缩并），定义为 $A:B = \\sum_{i}\\sum_{j}A_{ij}B_{ij}$。项 $\\sigma:I$ 是 $\\sigma$ 的迹，记作 $\\operatorname{tr}(\\sigma)$。\n\n如果一个算子 $P$ 应用两次与应用一次的效果相同，即 $P(P(x)) = P(x)$，则该算子是幂等的。对于偏应力算子，我们必须证明 $dev(dev(\\sigma)) = dev(\\sigma)$。\n\n让我们定义张量 $\\sigma'$ 为对 $\\sigma$ 应用偏应力算子的结果：\n$$\n\\sigma' = dev(\\sigma) = \\sigma - \\frac{1}{3}(\\sigma:I)I\n$$\n现在，我们对 $\\sigma'$ 应用偏应力算子：\n$$\ndev(\\sigma') = \\sigma' - \\frac{1}{3}(\\sigma':I)I\n$$\n为继续推导，我们必须计算项 $\\sigma':I$，即偏张量 $\\sigma'$ 的迹。我们将 $\\sigma'$ 的定义代入此表达式中：\n$$\n\\sigma':I = \\left(\\sigma - \\frac{1}{3}(\\sigma:I)I\\right):I\n$$\n双点积是一种双线性形式，因此我们可以将其分配到减法上：\n$$\n\\sigma':I = (\\sigma:I) - \\left(\\frac{1}{3}(\\sigma:I)I\\right):I\n$$\n项 $\\frac{1}{3}(\\sigma:I)$ 是一个标量。标量可以从双点积运算中提出：\n$$\n\\sigma':I = (\\sigma:I) - \\frac{1}{3}(\\sigma:I)(I:I)\n$$\n问题陈述提供了基本恒等式，即对于三维空间中的二阶单位张量，$I:I=3$。我们也可以从定义中验证这一点：$I:I = \\sum_{i,j} \\delta_{ij}\\delta_{ij} = \\sum_{i} \\delta_{ii} = \\delta_{11} + \\delta_{22} + \\delta_{33} = 1 + 1 + 1 = 3$。将此结果代入我们的方程中：\n$$\n\\sigma':I = (\\sigma:I) - \\frac{1}{3}(\\sigma:I)(3)\n$$\n$$\n\\sigma':I = (\\sigma:I) - (\\sigma:I) = 0\n$$\n这证明了一个关键性质：任何由偏应力算子产生的张量都是无迹的。\n\n现在我们将此结果 $\\sigma':I = 0$ 代回到 $dev(\\sigma')$ 的表达式中：\n$$\ndev(\\sigma') = \\sigma' - \\frac{1}{3}(0)I\n$$\n$$\ndev(\\sigma') = \\sigma' - 0 = \\sigma'\n$$\n由于我们最初定义了 $\\sigma' = dev(\\sigma)$，我们成功地证明了：\n$$\ndev(dev(\\sigma)) = dev(\\sigma)\n$$\n证明完毕。偏应力算子确实是一个幂等算子，这是投影算子的一个特征。它将一个张量从二阶张量的一般空间投影到无迹（偏）张量的子空间上。\n\n### 第 2 部分：算法设计与实现\n\n基于上述经过验证的原理和推导，我们设计一个算法来执行所需的计算。\n\n**1. 数据表示：**\n所有二阶张量，如 Cauchy 应力 $\\sigma$ 和单位张量 $I$，都表示为 $3 \\times 3$ 的数值数组。\n\n**2. 核心操作：**\n\n*   **双点积：** 一个函数将计算双点积 $A:B = \\sum_{i,j} A_{ij}B_{ij}$。这对应于对两个数组进行逐元素乘法，然后对结果数组中的所有元素求和。\n\n*   **偏应力算子：** 一个函数 `dev(tensor)` 将实现公式 $dev(\\sigma) = \\sigma - \\frac{1}{3}(\\sigma:I)I$。它将使用双点积函数来计算迹 $\\operatorname{tr}(\\sigma) = \\sigma:I$。\n\n**3. 所需计算：**\n\n*   **偏能量度量：** 计算标量偏能量 $E_{dev}(\\sigma) = \\frac{1}{2}dev(\\sigma):dev(\\sigma)$。首先，计算偏张量 $\\sigma' = dev(\\sigma)$。然后，计算它与自身的双点积 $\\sigma':\\sigma'$，并乘以 $\\frac{1}{2}$。\n\n*   **幂等性验证：** 为了在数值上测试属性 $dev(dev(\\sigma)) = dev(\\sigma)$，我们计算方程两边的差值：$D = dev(dev(\\sigma)) - dev(\\sigma)$。由于浮点运算，这个差值可能不完全为零。因此，我们使用 Frobenius 范数 $\\|D\\|_F = \\sqrt{D:D}$ 来量化其大小。如果此范数小于指定的小容差 $10^{-10}$，则认为幂等性在数值上成立。结果是一个布尔标志。\n\n**4. 整体流程：**\n主算法将对每个提供的输入应力张量执行以下步骤：\n1.  接收输入张量 $\\sigma$。\n2.  计算其偏量部分：$\\sigma' = dev(\\sigma)$。\n3.  计算偏能量：$E_{dev} = \\frac{1}{2} (\\sigma':\\sigma')$。\n4.  计算偏应力算子的第二次应用：$\\sigma'' = dev(\\sigma')$。\n5.  计算用于幂等性检查的差值张量：$D = \\sigma'' - \\sigma'$。\n6.  计算差值的 Frobenius 范数：$\\|D\\|_F = \\sqrt{D:D}$。\n7.  将范数与容差进行比较以获得布尔标志：$\\text{flag} = (\\|D\\|_F  10^{-10})$。\n8.  存储数据对 $[E_{dev}, \\text{flag}]$。\n\n处理完所有测试用例后，收集到的结果将按照问题规定格式化为单个字符串，例如 `[[E_A, flag_A], [E_B, flag_B], ...]]`，并打印到标准输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes a scalar deviatoric energy measure and verifies the idempotence\n    of the deviatoric projection for a given suite of second-order stress tensors.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # sigma_A: General case\n        np.array([[120.0, -30.0, 45.0], \n                  [-30.0, 80.0, 0.0], \n                  [45.0, 0.0, -10.0]]),\n        \n        # sigma_B: Pure hydrostatic case\n        np.array([[50.0, 0.0, 0.0], \n                  [0.0, 50.0, 0.0], \n                  [0.0, 0.0, 50.0]]),\n        \n        # sigma_C: Pure deviatoric case\n        np.array([[30.0, -6.0, 0.0], \n                  [-6.0, -15.0, 0.0], \n                  [0.0, 0.0, -15.0]]),\n        \n        # sigma_D: Zero tensor\n        np.array([[0.0, 0.0, 0.0], \n                  [0.0, 0.0, 0.0], \n                  [0.0, 0.0, 0.0]]),\n\n        # sigma_E: Tiny-magnitude deviatoric case\n        np.array([[1e-12, 2e-12, -3e-12],\n                  [2e-12, -1e-12, 4e-12],\n                  [-3e-12, 4e-12, 0.0]])\n    ]\n\n    results = []\n    \n    # Define the second-order identity tensor in 3D\n    identity_tensor = np.identity(3)\n    \n    # Define tolerance for the idempotence check\n    tolerance = 1e-10\n\n    def double_dot_product(tensor_A, tensor_B):\n        \"\"\"\n        Computes the double dot product A:B = sum(A_ij * B_ij).\n        \"\"\"\n        return np.sum(tensor_A * tensor_B)\n\n    def deviatoric_operator(tensor):\n        \"\"\"\n        Computes the deviatoric part of a tensor: dev(T) = T - 1/3 * tr(T) * I.\n        \"\"\"\n        trace = double_dot_product(tensor, identity_tensor)\n        return tensor - (trace / 3.0) * identity_tensor\n\n    for sigma in test_cases:\n        # 1. Compute the deviatoric part of the stress tensor\n        dev_sigma = deviatoric_operator(sigma)\n        \n        # 2. Compute the scalar deviatoric energy\n        # E_dev = 1/2 * dev(sigma):dev(sigma)\n        deviatoric_energy = 0.5 * double_dot_product(dev_sigma, dev_sigma)\n        \n        # 3. Verify the idempotence property: dev(dev(sigma)) = dev(sigma)\n        # We compute dev(dev(sigma))\n        dev_dev_sigma = deviatoric_operator(dev_sigma)\n        \n        # Calculate the difference tensor D = dev(dev(sigma)) - dev(sigma)\n        difference_tensor = dev_dev_sigma - dev_sigma\n        \n        # Calculate the Frobenius norm of the difference: ||D||_F = sqrt(D:D)\n        norm_of_difference = np.sqrt(double_dot_product(difference_tensor, difference_tensor))\n        \n        # Check if the norm is within the specified tolerance\n        idempotence_holds = norm_of_difference  tolerance\n        \n        # Append the result pair to the list\n        results.append([deviatoric_energy, idempotence_holds])\n\n    # Convert each two-element list result into its string representation\n    # e.g., [7358.333, True] becomes \"[7358.333333333333, True]\"\n    # Using python's boolean string representation 'True'/'False' directly.\n    string_results = [str(res) for res in results]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(string_results)}]\")\n\nsolve()\n```"
        }
    ]
}