{
    "hands_on_practices": [
        {
            "introduction": "To begin our exploration, we will solidify our understanding of the double dot product's fundamental definition. This first practice  tackles a frequent source of error by directly contrasting the double contraction $A:B$ with the trace of the matrix product, $\\mathrm{tr}(AB)$. By working through a simple, non-symmetric counterexample, you will gain a crucial appreciation for the conditions under which these two operations are equivalent, reinforcing the importance of tensor symmetry in continuum mechanics formulations.",
            "id": "3604877",
            "problem": "Consider second-order tensors $A$ and $B$ defined on a three-dimensional Euclidean body with an orthonormal basis. The double contraction of $A$ and $B$ is defined by $A:B = \\sum_{i=1}^{3}\\sum_{j=1}^{3} A_{ij} B_{ij}$, and the trace of their product is defined by $\\mathrm{tr}(AB) = \\sum_{i=1}^{3} (AB)_{ii} = \\sum_{i=1}^{3}\\sum_{j=1}^{3} A_{ij} B_{ji}$. In computational solid mechanics, the equality $A:B = \\mathrm{tr}(AB)$ is often used under symmetry assumptions. Starting from the above core definitions, and without assuming symmetry, provide a componentwise counterexample that demonstrates $A:B \\neq \\mathrm{tr}(AB)$.\n\nUse the specific tensors\n$$\nA = \\begin{pmatrix}\n0 & 2 & 0 \\\\\n0 & 0 & 0 \\\\\n0 & 0 & 0\n\\end{pmatrix},\\qquad\nB = \\begin{pmatrix}\n0 & 0 & 0 \\\\\n3 & 0 & 0 \\\\\n0 & 0 & 0\n\\end{pmatrix}.\n$$\nCompute $A:B$ and $\\mathrm{tr}(AB)$ directly from the definitions and report the scalar difference $A:B - \\mathrm{tr}(AB)$ as a single real number. Express the final answer without units.",
            "solution": "The problem is validated as self-contained, scientifically sound, and well-posed. The objective is to compute the scalar difference $A:B - \\mathrm{tr}(AB)$ for the given non-symmetric second-order tensors $A$ and $B$.\n\nThe specific tensors provided are:\n$$\nA = \\begin{pmatrix}\n0 & 2 & 0 \\\\\n0 & 0 & 0 \\\\\n0 & 0 & 0\n\\end{pmatrix},\\qquad\nB = \\begin{pmatrix}\n0 & 0 & 0 \\\\\n3 & 0 & 0 \\\\\n0 & 0 & 0\n\\end{pmatrix}.\n$$\nIn component form, the only non-zero component of tensor $A$ is $A_{12} = 2$. The only non-zero component of tensor $B$ is $B_{21} = 3$. All other components $A_{ij}$ and $B_{ij}$ for $(i,j) \\in \\{1, 2, 3\\} \\times \\{1, 2, 3\\}$ are equal to $0$.\n\nFirst, we compute the double contraction $A:B$ using the provided definition:\n$$\nA:B = \\sum_{i=1}^{3}\\sum_{j=1}^{3} A_{ij} B_{ij}\n$$\nThis operation, also known as the Frobenius inner product, involves summing the products of corresponding components of the two tensors. We can expand the sum:\n$$\nA:B = A_{11}B_{11} + A_{12}B_{12} + A_{13}B_{13} + A_{21}B_{21} + A_{22}B_{22} + A_{23}B_{23} + A_{31}B_{31} + A_{32}B_{32} + A_{33}B_{33}\n$$\nSubstituting the component values of $A$ and $B$:\n$$\nA:B = (0)(0) + (2)(0) + (0)(0) + (0)(3) + (0)(0) + (0)(0) + (0)(0) + (0)(0) + (0)(0)\n$$\nEvery term in the summation is zero. For example, the term involving the non-zero component $A_{12}=2$ is $A_{12}B_{12}$, but $B_{12}=0$. Similarly, the term involving the non-zero component $B_{21}=3$ is $A_{21}B_{21}$, but $A_{21}=0$.\nTherefore, the double contraction is:\n$$\nA:B = 0\n$$\n\nNext, we compute the trace of the tensor product $AB$, denoted as $\\mathrm{tr}(AB)$. The definition provided is:\n$$\n\\mathrm{tr}(AB) = \\sum_{i=1}^{3}\\sum_{j=1}^{3} A_{ij} B_{ji}\n$$\nThis sum involves multiplying the component $A_{ij}$ by the component $B_{ji}$ (note the transposed indices for $B$) and summing over all $i$ and $j$. Let's examine the terms in this summation. The only non-zero component of $A$ is $A_{12} = 2$. Therefore, the only potentially non-zero term in the entire double summation is the one where $i=1$ and $j=2$. This term is $A_{12}B_{21}$. All other terms will be zero because $A_{ij}=0$ for $(i,j) \\neq (1,2)$.\n\nLet's evaluate the single non-zero term:\n$$\nA_{12}B_{21} = (2)(3) = 6\n$$\nSince all other terms in the sum are zero, the value of the trace is determined entirely by this term:\n$$\n\\mathrm{tr}(AB) = \\sum_{i=1}^{3}\\sum_{j=1}^{3} A_{ij} B_{ji} = A_{12}B_{21} + \\sum_{(i,j) \\neq (1,2)} A_{ij}B_{ji} = 6 + 0 = 6\n$$\nAlternatively, one can first compute the matrix product $C = AB$:\n$$\nC = AB = \\begin{pmatrix} 0 & 2 & 0 \\\\ 0 & 0 & 0 \\\\ 0 & 0 & 0 \\end{pmatrix} \\begin{pmatrix} 0 & 0 & 0 \\\\ 3 & 0 & 0 \\\\ 0 & 0 & 0 \\end{pmatrix} = \\begin{pmatrix} (0)(0)+(2)(3)+(0)(0) & (0)(0)+(2)(0)+(0)(0) & (0)(0)+(2)(0)+(0)(0) \\\\ 0 & 0 & 0 \\\\ 0 & 0 & 0 \\end{pmatrix}\n$$\n$$\nC = \\begin{pmatrix} 6 & 0 & 0 \\\\ 0 & 0 & 0 \\\\ 0 & 0 & 0 \\end{pmatrix}\n$$\nThe trace is the sum of the diagonal elements of $C$:\n$$\n\\mathrm{tr}(AB) = \\mathrm{tr}(C) = C_{11} + C_{22} + C_{33} = 6 + 0 + 0 = 6\n$$\nBoth methods yield the same result.\n\nFinally, we compute the required scalar difference $A:B - \\mathrm{tr}(AB)$:\n$$\nA:B - \\mathrm{tr}(AB) = 0 - 6 = -6\n$$\nThis counterexample demonstrates that for non-symmetric tensors, the double contraction $A:B$ is not, in general, equal to the trace of their product $\\mathrm{tr}(AB)$. The equality holds if at least one of the tensors is symmetric, which is not the case here.",
            "answer": "$$\\boxed{-6}$$"
        },
        {
            "introduction": "Building on a solid definitional foundation, we now turn to a critical aspect of computational implementation: the efficient representation of symmetric tensors. This exercise  explores the widely-used Voigt notation and investigates why different conventions exist for stress-like and strain-like quantities. You will algorithmically validate how the \"engineering\" Voigt convention, with its characteristic factors of two on shear terms, is precisely what is required to preserve the energetic equivalence represented by the double dot product.",
            "id": "3604891",
            "problem": "Consider two second-order tensors $A$ and $B$ in three dimensions that are symmetric, so that $A_{ij} = A_{ji}$ and $B_{ij} = B_{ji}$ for all indices $i,j \\in \\{1,2,3\\}$. The Frobenius product between $A$ and $B$ is defined from first principles as\n$$\nA : B = \\sum_{i=1}^{3}\\sum_{j=1}^{3} A_{ij} B_{ij}.\n$$\nIn computational solid mechanics, symmetric second-order tensors are often represented in Voigt notation as $6$-component vectors. There are multiple conventions for handling shear components in Voigt notation. One convention (plain Voigt) maps the tensor components directly to a vector without any factors on the shear terms. Another convention (engineering Voigt) doubles the shear components for strain-like quantities to preserve energetic equivalence with stress-like quantities under the Euclidean dot product. The task is to validate, from the above definition of the Frobenius product and the mapping conventions, whether the Frobenius product $A:B$ is preserved when computing a dot product between Voigt vectors, and to quantify the error if engineering shear factors are omitted.\n\nStarting only from the definition of the Frobenius product and the symmetry of the tensors, perform the following steps algorithmically:\n- Implement a function that computes $A:B$ directly from the full $3 \\times 3$ tensor representations.\n- Implement a plain Voigt mapping $v_{\\text{plain}}(T)$ for any symmetric tensor $T$, defined by\n$$\nv_{\\text{plain}}(T) = \\begin{bmatrix} T_{11} \\\\ T_{22} \\\\ T_{33} \\\\ T_{23} \\\\ T_{13} \\\\ T_{12} \\end{bmatrix}.\n$$\n- Implement an engineering Voigt mapping $v_{\\text{eng}}(T;\\text{role})$ that depends on the intended role of $T$:\n    - For stress-like tensors (role = stress), map without shear factors,\n    $$\n    v_{\\text{eng}}(T;\\text{stress}) = \\begin{bmatrix} T_{11} \\\\ T_{22} \\\\ T_{33} \\\\ T_{23} \\\\ T_{13} \\\\ T_{12} \\end{bmatrix}.\n    $$\n    - For strain-like tensors (role = strain), map with doubled shear components,\n    $$\n    v_{\\text{eng}}(T;\\text{strain}) = \\begin{bmatrix} T_{11} \\\\ T_{22} \\\\ T_{33} \\\\ 2 T_{23} \\\\ 2 T_{13} \\\\ 2 T_{12} \\end{bmatrix}.\n    $$\n- For each test case below, compute:\n    1. The true Frobenius product $A:B$ from the full tensors.\n    2. The dot product $v_{\\text{eng}}(A;\\text{stress}) \\cdot v_{\\text{eng}}(B;\\text{strain})$.\n    3. The dot product $v_{\\text{plain}}(A) \\cdot v_{\\text{plain}}(B)$.\n- Validate preservation by checking whether $\\left| A:B - v_{\\text{eng}}(A;\\text{stress}) \\cdot v_{\\text{eng}}(B;\\text{strain}) \\right| \\le \\varepsilon$ with the tolerance $\\varepsilon = 10^{-12}$, and quantify the error if engineering factors are omitted by reporting:\n    - The absolute error $\\left| A:B - v_{\\text{plain}}(A) \\cdot v_{\\text{plain}}(B) \\right|$.\n    - The relative error, defined as $\\left| A:B - v_{\\text{plain}}(A) \\cdot v_{\\text{plain}}(B) \\right| / \\left| A:B \\right|$ if $A:B \\ne 0$, and defined to be $0$ if $A:B = 0$.\n\nThe test suite consists of the following symmetric pairs $(A,B)$:\n- Test case $1$ (general symmetric with mixed normal and shear):\n$$\nA = \\begin{bmatrix}\n3.0 & -2.0 & 1.0 \\\\\n-2.0 & 0.5 & 4.0 \\\\\n1.0 & 4.0 & -1.0\n\\end{bmatrix}, \\quad\nB = \\begin{bmatrix}\n1.2 & 0.8 & -1.1 \\\\\n0.8 & -0.5 & 2.3 \\\\\n-1.1 & 2.3 & 0.7\n\\end{bmatrix}.\n$$\n- Test case $2$ (diagonal-only):\n$$\nA = \\begin{bmatrix}\n2.0 & 0.0 & 0.0 \\\\\n0.0 & -1.0 & 0.0 \\\\\n0.0 & 0.0 & 3.0\n\\end{bmatrix}, \\quad\nB = \\begin{bmatrix}\n-4.0 & 0.0 & 0.0 \\\\\n0.0 & 0.5 & 0.0 \\\\\n0.0 & 0.0 & 2.0\n\\end{bmatrix}.\n$$\n- Test case $3$ (pure shear):\n$$\nA = \\begin{bmatrix}\n0.0 & 5.0 & 3.0 \\\\\n5.0 & 0.0 & -2.0 \\\\\n3.0 & -2.0 & 0.0\n\\end{bmatrix}, \\quad\nB = \\begin{bmatrix}\n0.0 & -1.0 & 0.5 \\\\\n-1.0 & 0.0 & 4.0 \\\\\n0.5 & 4.0 & 0.0\n\\end{bmatrix}.\n$$\n- Test case $4$ (near-zero magnitudes to probe numerical tolerance):\n$$\nA = \\begin{bmatrix}\n1.0 \\times 10^{-12} & 2.0 \\times 10^{-12} & -3.0 \\times 10^{-12} \\\\\n2.0 \\times 10^{-12} & -1.0 \\times 10^{-12} & 5.0 \\times 10^{-13} \\\\\n-3.0 \\times 10^{-12} & 5.0 \\times 10^{-13} & -2.0 \\times 10^{-12}\n\\end{bmatrix}, \\quad\nB = \\begin{bmatrix}\n-4.0 \\times 10^{-12} & 7.0 \\times 10^{-13} & 1.0 \\times 10^{-12} \\\\\n7.0 \\times 10^{-13} & 3.0 \\times 10^{-12} & -2.0 \\times 10^{-12} \\\\\n1.0 \\times 10^{-12} & -2.0 \\times 10^{-12} & 5.0 \\times 10^{-13}\n\\end{bmatrix}.\n$$\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case and is itself a list of three elements of fundamental types:\n$$\n[\\,[\\text{preserved},\\, \\text{abs\\_error\\_plain},\\, \\text{rel\\_error\\_plain}],\\, \\ldots\\,]\n$$\nHere, $\\text{preserved}$ is a boolean indicating whether preservation holds within the tolerance $\\varepsilon = 10^{-12}$, $\\text{abs\\_error\\_plain}$ is a float, and $\\text{rel\\_error\\_plain}$ is a float. There are no physical units involved in this problem.",
            "solution": "The problem requires an algorithmic validation of the relationship between the Frobenius tensor product $A:B$ and the Euclidean dot product of the corresponding Voigt vector representations for symmetric second-order tensors. We will first establish the analytical relationship and then implement a numerical procedure to verify it for the given test cases.\n\nLet $A$ and $B$ be two symmetric second-order tensors in a $3$-dimensional space. Their components are denoted by $A_{ij}$ and $B_{ij}$ respectively, where the indices $i, j$ range from $1$ to $3$. The symmetry property implies $A_{ij} = A_{ji}$ and $B_{ij} = B_{ji}$.\n\nThe Frobenius product, also known as the double dot product, is defined as the sum of the products of corresponding components:\n$$\nA : B = \\sum_{i=1}^{3}\\sum_{j=1}^{3} A_{ij} B_{ij}\n$$\nThis operation is fundamental in continuum mechanics, for instance, in the expression for the rate of internal work density, $\\dot{W} = \\boldsymbol{\\sigma} : \\dot{\\boldsymbol{\\epsilon}}$, where $\\boldsymbol{\\sigma}$ is the stress tensor and $\\dot{\\boldsymbol{\\epsilon}}$ is the strain rate tensor.\n\nDue to the symmetry of the tensors, we can expand the sum and group terms. The diagonal terms ($i=j$) appear once, while the off-diagonal terms ($i \\ne j$) appear twice (e.g., $A_{12}B_{12}$ and $A_{21}B_{21}$).\n$$\nA : B = (A_{11}B_{11} + A_{22}B_{22} + A_{33}B_{33}) + (A_{12}B_{12} + A_{21}B_{21}) + (A_{13}B_{13} + A_{31}B_{31}) + (A_{23}B_{23} + A_{32}B_{32})\n$$\nUsing the symmetry property ($A_{ij} = A_{ji}$ and $B_{ij} = B_{ji}$), we can simplify this to:\n$$\nA : B = A_{11}B_{11} + A_{22}B_{22} + A_{33}B_{33} + 2A_{12}B_{12} + 2A_{13}B_{13} + 2A_{23}B_{23}\n$$\nThis expression serves as our ground truth for the correct value of the product.\n\nNow, we analyze the Voigt notations. Voigt notation is a method to represent a symmetric tensor as a vector, reducing storage and simplifying certain operations. However, care must be taken to ensure that scalar invariants like the Frobenius product are preserved.\n\nFirst, consider the plain Voigt mapping, $v_{\\text{plain}}(T)$, which directly maps tensor components to a vector:\n$$\nv_{\\text{plain}}(A) = \\begin{bmatrix} A_{11} \\\\ A_{22} \\\\ A_{33} \\\\ A_{23} \\\\ A_{13} \\\\ A_{12} \\end{bmatrix}, \\quad\nv_{\\text{plain}}(B) = \\begin{bmatrix} B_{11} \\\\ B_{22} \\\\ B_{33} \\\\ B_{23} \\\\ B_{13} \\\\ B_{12} \\end{bmatrix}\n$$\nThe standard Euclidean dot product of these two vectors is:\n$$\nv_{\\text{plain}}(A) \\cdot v_{\\text{plain}}(B) = A_{11}B_{11} + A_{22}B_{22} + A_{33}B_{33} + A_{23}B_{23} + A_{13}B_{13} + A_{12}B_{12}\n$$\nComparing this to the full Frobenius product, we observe a discrepancy: the shear terms ($A_{12}B_{12}$, $A_{13}B_{13}$, $A_{23}B_{23}$) are not multiplied by the factor of $2$. Therefore, in general, $A:B \\ne v_{\\text{plain}}(A) \\cdot v_{\\text{plain}}(B)$. The error is precisely the sum of the missing shear term products: $|A:B - v_{\\text{plain}}(A) \\cdot v_{\\text{plain}}(B)| = |A_{12}B_{12} + A_{13}B_{13} + A_{23}B_{23}|$.\n\nTo correct this, the engineering Voigt notation, $v_{\\text{eng}}(T)$, introduces factors of $2$ for the shear components of one of the tensors in the product. The convention distinguishes between \"stress-like\" and \"strain-like\" quantities. Let $A$ be stress-like and $B$ be strain-like.\n$$\nv_{\\text{eng}}(A;\\text{stress}) = \\begin{bmatrix} A_{11} \\\\ A_{22} \\\\ A_{33} \\\\ A_{23} \\\\ A_{13} \\\\ A_{12} \\end{bmatrix}, \\quad\nv_{\\text{eng}}(B;\\text{strain}) = \\begin{bmatrix} B_{11} \\\\ B_{22} \\\\ B_{33} \\\\ 2B_{23} \\\\ 2B_{13} \\\\ 2B_{12} \\end{bmatrix}\n$$\nThe dot product of these vectors is:\n$$\nv_{\\text{eng}}(A;\\text{stress}) \\cdot v_{\\text{eng}}(B;\\text{strain}) = A_{11}B_{11} + A_{22}B_{22} + A_{33}B_{33} + A_{23}(2B_{23}) + A_{13}(2B_{13}) + A_{12}(2B_{12})\n$$\n$$\n= A_{11}B_{11} + A_{22}B_{22} + A_{33}B_{33} + 2A_{23}B_{23} + 2A_{13}B_{13} + 2A_{12}B_{12}\n$$\nThis expression is algebraically identical to the expansion of the Frobenius product $A:B$. This demonstrates that the engineering Voigt convention is specifically designed to preserve the work-conjugacy, i.e., $A:B = v_{\\text{eng}}(A;\\text{stress}) \\cdot v_{\\text{eng}}(B;\\text{strain})$. Any numerical difference between these two quantities should be attributable only to floating-point precision errors.\n\nThe algorithmic procedure will be to:\n$1$. Implement a function for the true Frobenius product $A:B$ using the component-wise summation $\\sum_{i,j} A_{ij}B_{ij}$.\n$2$. Implement functions for the plain and engineering Voigt mappings as defined.\n$3$. For each test case, calculate the three quantities: the true product, the engineering Voigt dot product, and the plain Voigt dot product.\n$4$. Validate that the absolute difference between the true product and the engineering product is within the given tolerance $\\varepsilon = 10^{-12}$.\n$5$. Calculate the absolute and relative errors resulting from using the plain Voigt dot product instead of the true Frobenius product.\n$6$. Collect and format the results as specified.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the tensor contraction problem by comparing the Frobenius product\n    with dot products of Voigt vector representations.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\n            np.array([\n                [3.0, -2.0, 1.0],\n                [-2.0, 0.5, 4.0],\n                [1.0, 4.0, -1.0]\n            ]),\n            np.array([\n                [1.2, 0.8, -1.1],\n                [0.8, -0.5, 2.3],\n                [-1.1, 2.3, 0.7]\n            ])\n        ),\n        (\n            np.array([\n                [2.0, 0.0, 0.0],\n                [0.0, -1.0, 0.0],\n                [0.0, 0.0, 3.0]\n            ]),\n            np.array([\n                [-4.0, 0.0, 0.0],\n                [0.0, 0.5, 0.0],\n                [0.0, 0.0, 2.0]\n            ])\n        ),\n        (\n            np.array([\n                [0.0, 5.0, 3.0],\n                [5.0, 0.0, -2.0],\n                [3.0, -2.0, 0.0]\n            ]),\n            np.array([\n                [0.0, -1.0, 0.5],\n                [-1.0, 0.0, 4.0],\n                [0.5, 4.0, 0.0]\n            ])\n        ),\n        (\n            np.array([\n                [1.0e-12, 2.0e-12, -3.0e-12],\n                [2.0e-12, -1.0e-12, 5.0e-13],\n                [-3.0e-12, 5.0e-13, -2.0e-12]\n            ]),\n            np.array([\n                [-4.0e-12, 7.0e-13, 1.0e-12],\n                [7.0e-13, 3.0e-12, -2.0e-12],\n                [1.0e-12, -2.0e-12, 5.0e-13]\n            ])\n        )\n    ]\n\n    def compute_frobenius_product(tensor_A, tensor_B):\n        \"\"\"Computes the Frobenius product A:B = sum(A_ij * B_ij).\"\"\"\n        return np.sum(tensor_A * tensor_B)\n\n    def map_to_plain_voigt(tensor_T):\n        \"\"\"Maps a 3x3 symmetric tensor to its 6-component plain Voigt vector.\"\"\"\n        return np.array([\n            tensor_T[0, 0], tensor_T[1, 1], tensor_T[2, 2],\n            tensor_T[1, 2], tensor_T[0, 2], tensor_T[0, 1]\n        ])\n\n    def map_to_engineering_voigt(tensor_T, role):\n        \"\"\"\n        Maps a 3x3 symmetric tensor to its 6-component engineering Voigt vector.\n        'stress' role has no factors.\n        'strain' role has factors of 2 on shear terms.\n        \"\"\"\n        if role not in ['stress', 'strain']:\n            raise ValueError(\"Role must be 'stress' or 'strain'.\")\n        \n        shear_factor = 2.0 if role == 'strain' else 1.0\n        return np.array([\n            tensor_T[0, 0], tensor_T[1, 1], tensor_T[2, 2],\n            shear_factor * tensor_T[1, 2], \n            shear_factor * tensor_T[0, 2], \n            shear_factor * tensor_T[0, 1]\n        ])\n\n    results = []\n    tolerance = 1e-12\n\n    for A, B in test_cases:\n        # 1. Compute the true Frobenius product from full tensors.\n        true_product = compute_frobenius_product(A, B)\n\n        # 2. Compute the dot product using engineering Voigt notation.\n        v_A_eng = map_to_engineering_voigt(A, role='stress')\n        v_B_eng = map_to_engineering_voigt(B, role='strain')\n        eng_product = np.dot(v_A_eng, v_B_eng)\n\n        # 3. Compute the dot product using plain Voigt notation.\n        v_A_plain = map_to_plain_voigt(A)\n        v_B_plain = map_to_plain_voigt(B)\n        plain_product = np.dot(v_A_plain, v_B_plain)\n\n        # Validate preservation for engineering Voigt.\n        preserved = abs(true_product - eng_product) = tolerance\n\n        # Quantify error for plain Voigt.\n        abs_error_plain = abs(true_product - plain_product)\n        \n        if abs(true_product) == 0:\n            rel_error_plain = 0.0\n        else:\n            rel_error_plain = abs_error_plain / abs(true_product)\n            \n        results.append([preserved, abs_error_plain, rel_error_plain])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "We conclude our hands-on practices by applying the double dot product to a cornerstone concept in solid mechanics: the decomposition of stress into volumetric and deviatoric components. This practice  guides you through the design of an algorithm to compute the deviatoric energy, a key quantity in plasticity theory. Furthermore, you will use the properties of the double dot product to analytically and numerically verify the idempotence of the deviatoric operator, revealing its nature as a true projection onto the space of traceless tensors.",
            "id": "3604892",
            "problem": "Design and implement a complete algorithm in a modern programming language to compute a scalar deviatoric energy measure and to verify the idempotence of the deviatoric projection for a given second-order tensor. Use the following core definitions from continuum mechanics, with all calculations restricted to three-dimensional second-order tensors.\n\nLet the Cauchy stress tensor be denoted by $\\sigma \\in \\mathbb{R}^{3 \\times 3}$. The second-order identity tensor is denoted by $I \\in \\mathbb{R}^{3 \\times 3}$, with the double contraction $I:I=3$. The double dot product (also called double contraction) of two second-order tensors $A$ and $B$ is defined as $A:B=\\sum_{i=1}^{3}\\sum_{j=1}^{3}A_{ij}B_{ij}$. The deviatoric operator is defined by $dev(\\sigma)=\\sigma-\\dfrac{1}{3}(\\sigma:I)I$, which maps $\\sigma$ to its trace-free part.\n\nStarting from these fundamental definitions, you must:\n\n1. Derive from first principles why $dev(dev(\\sigma))=dev(\\sigma)$, explicitly using $I:I=3$ and properties of the double dot product, and design an algorithmic test that verifies idempotence numerically for given inputs by measuring the Frobenius norm $||A||_{F}=\\sqrt{A:A}$ of the difference $dev(dev(\\sigma))-dev(\\sigma)$ against a small tolerance (use $10^{-10}$ as the tolerance).\n2. Define the deviatoric energy measure $E_{dev}(\\sigma)$ as the scalar $E_{dev}(\\sigma)=\\dfrac{1}{2}\\,dev(\\sigma):dev(\\sigma)$ and implement its computation. All inputs and outputs are dimensionless; express the output energy values as floating-point numbers.\n\nYour implementation must be fully self-contained and produce results for the following test suite of stress tensors (each is symmetric and $3 \\times 3$), specified numerically:\n\n- General case (nonzero trace and shear): \n  $\\sigma_{A}=\\begin{bmatrix}120  -30  45 \\\\ -30  80  0 \\\\ 45  0  -10\\end{bmatrix}$.\n- Pure hydrostatic case: $\\sigma_{B}=50\\,I=\\begin{bmatrix}50  0  0 \\\\ 0  50  0 \\\\ 0  0  50\\end{bmatrix}$.\n- Pure deviatoric case (zero trace with shear): \n  $\\sigma_{C}=\\begin{bmatrix}30  -6  0 \\\\ -6  -15  0 \\\\ 0  0  -15\\end{bmatrix}$.\n- Zero tensor (boundary case): \n  $\\sigma_{D}=\\begin{bmatrix}0  0  0 \\\\ 0  0  0 \\\\ 0  0  0\\end{bmatrix}$.\n- Tiny-magnitude deviatoric case (edge case): \n  $\\sigma_{E}=\\begin{bmatrix}10^{-12}  2\\cdot 10^{-12}  -3\\cdot 10^{-12} \\\\ 2\\cdot 10^{-12}  -10^{-12}  4\\cdot 10^{-12} \\\\ -3\\cdot 10^{-12}  4\\cdot 10^{-12}  0\\end{bmatrix}$.\n\nFor each test case, compute:\n- The scalar deviatoric energy $E_{dev}(\\sigma)$ as a floating-point number.\n- A boolean flag indicating whether idempotence holds numerically, defined as $||dev(dev(\\sigma))-dev(\\sigma)||_{F}  10^{-10}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case and is itself a two-element list containing the floating-point deviatoric energy and the boolean idempotence flag. For example, the output format must be of the form \n$[[E_{A},\\text{flag}_{A}],[E_{B},\\text{flag}_{B}],\\dots]$, \nwith no extra text before or after the bracketed list.",
            "solution": "The problem statement is evaluated to be **valid**. It is scientifically grounded in the principles of continuum mechanics, is well-posed with all necessary definitions and data, and is expressed in objective, formal language. There are no contradictions, ambiguities, or factual unsoundness. We may therefore proceed with a solution.\n\nThe solution requires two main components: a formal derivation of the idempotence property of the deviatoric operator, and the design of an algorithm to compute the required quantities for a given set of test cases.\n\n### Part 1: Derivation of the Idempotence of the Deviatoric Operator\n\nThe deviatoric operator, $dev(\\cdot)$, maps a second-order tensor $\\boldsymbol{\\sigma}$ to its trace-free part. It is defined as:\n$$\ndev(\\boldsymbol{\\sigma}) = \\boldsymbol{\\sigma} - \\frac{1}{3}(\\boldsymbol{\\sigma}:\\boldsymbol{I})\\boldsymbol{I}\n$$\nwhere $\\boldsymbol{\\sigma}$ is a second-order tensor, $\\boldsymbol{I}$ is the second-order identity tensor, and $A:B$ denotes the double dot product (or double contraction) of two tensors $A$ and $B$, defined as $A:B = \\sum_{i}\\sum_{j}A_{ij}B_{ij}$. The term $\\boldsymbol{\\sigma}:\\boldsymbol{I}$ is the trace of $\\boldsymbol{\\sigma}$, denoted $tr(\\boldsymbol{\\sigma})$.\n\nAn operator $P$ is idempotent if applying it twice has the same effect as applying it once, i.e., $P(P(x)) = P(x)$. For the deviatoric operator, we must prove that $dev(dev(\\boldsymbol{\\sigma})) = dev(\\boldsymbol{\\sigma})$.\n\nLet us define a tensor $\\boldsymbol{\\sigma}'$ as the result of applying the deviatoric operator to $\\boldsymbol{\\sigma}$:\n$$\n\\boldsymbol{\\sigma}' = dev(\\boldsymbol{\\sigma}) = \\boldsymbol{\\sigma} - \\frac{1}{3}(\\boldsymbol{\\sigma}:\\boldsymbol{I})\\boldsymbol{I}\n$$\nNow, we apply the deviatoric operator to $\\boldsymbol{\\sigma}'$:\n$$\ndev(\\boldsymbol{\\sigma}') = \\boldsymbol{\\sigma}' - \\frac{1}{3}(\\boldsymbol{\\sigma}':\\boldsymbol{I})\\boldsymbol{I}\n$$\nTo proceed, we must evaluate the term $\\boldsymbol{\\sigma}':\\boldsymbol{I}$, which is the trace of the deviatoric tensor $\\boldsymbol{\\sigma}'$. We substitute the definition of $\\boldsymbol{\\sigma}'$ into this expression:\n$$\n\\boldsymbol{\\sigma}':\\boldsymbol{I} = \\left(\\boldsymbol{\\sigma} - \\frac{1}{3}(\\boldsymbol{\\sigma}:\\boldsymbol{I})\\boldsymbol{I}\\right):\\boldsymbol{I}\n$$\nThe double dot product is a bilinear form, so we can distribute it across the subtraction:\n$$\n\\boldsymbol{\\sigma}':\\boldsymbol{I} = (\\boldsymbol{\\sigma}:\\boldsymbol{I}) - \\left(\\frac{1}{3}(\\boldsymbol{\\sigma}:\\boldsymbol{I})\\boldsymbol{I}\\right):\\boldsymbol{I}\n$$\nThe term $\\frac{1}{3}(\\boldsymbol{\\sigma}:\\boldsymbol{I})$ is a scalar. Scalars can be factored out of the double dot product operation:\n$$\n\\boldsymbol{\\sigma}':\\boldsymbol{I} = (\\boldsymbol{\\sigma}:\\boldsymbol{I}) - \\frac{1}{3}(\\boldsymbol{\\sigma}:\\boldsymbol{I})(\\boldsymbol{I}:\\boldsymbol{I})\n$$\nThe problem statement provides the fundamental identity that for a second-order identity tensor in three dimensions, $\\boldsymbol{I}:\\boldsymbol{I}=3$. We can also verify this from the definition: $\\boldsymbol{I}:\\boldsymbol{I} = \\sum_{i,j} \\delta_{ij}\\delta_{ij} = \\sum_{i} \\delta_{ii} = \\delta_{11} + \\delta_{22} + \\delta_{33} = 1 + 1 + 1 = 3$. Substituting this result into our equation:\n$$\n\\boldsymbol{\\sigma}':\\boldsymbol{I} = (\\boldsymbol{\\sigma}:\\boldsymbol{I}) - \\frac{1}{3}(\\boldsymbol{\\sigma}:\\boldsymbol{I})(3)\n$$\n$$\n\\boldsymbol{\\sigma}':\\boldsymbol{I} = (\\boldsymbol{\\sigma}:\\boldsymbol{I}) - (\\boldsymbol{\\sigma}:\\boldsymbol{I}) = 0\n$$\nThis demonstrates a key property: any tensor resulting from the deviatoric operator is traceless.\n\nNow we substitute this result, $\\boldsymbol{\\sigma}':\\boldsymbol{I} = 0$, back into the expression for $dev(\\boldsymbol{\\sigma}')$:\n$$\ndev(\\boldsymbol{\\sigma}') = \\boldsymbol{\\sigma}' - \\frac{1}{3}(0)\\boldsymbol{I}\n$$\n$$\ndev(\\boldsymbol{\\sigma}') = \\boldsymbol{\\sigma}' - 0 = \\boldsymbol{\\sigma}'\n$$\nSince we initially defined $\\boldsymbol{\\sigma}' = dev(\\boldsymbol{\\sigma})$, we have successfully shown that:\n$$\ndev(dev(\\boldsymbol{\\sigma})) = dev(\\boldsymbol{\\sigma})\n$$\nThis completes the proof. The deviatoric operator is indeed an idempotent operator, which is characteristic of a projection operator. It projects a tensor from the general space of second-order tensors onto the subspace of trace-free (deviatoric) tensors.\n\n### Part 2: Algorithmic Design and Implementation\n\nBased on the validated principles and the derivation above, we design an algorithm to perform the required computations.\n\n**1. Data Representation:**\nAll second-order tensors, such as the Cauchy stress $\\boldsymbol{\\sigma}$ and the identity tensor $\\boldsymbol{I}$, are represented as $3 \\times 3$ numerical arrays.\n\n**2. Core Operations:**\n\n*   **Double Dot Product:** A function will compute the double dot product $A:B = \\sum_{i,j} A_{ij}B_{ij}$. This corresponds to an element-wise multiplication of the two arrays followed by a sum of all elements in the resulting array.\n\n*   **Deviatoric Operator:** A function `dev(tensor)` will implement the formula $dev(\\boldsymbol{\\sigma}) = \\boldsymbol{\\sigma} - \\frac{1}{3}(\\boldsymbol{\\sigma}:\\boldsymbol{I})\\boldsymbol{I}$. It will use the double dot product function to compute the trace, $tr(\\boldsymbol{\\sigma}) = \\boldsymbol{\\sigma}:\\boldsymbol{I}$.\n\n**3. Required Computations:**\n\n*   **Deviatoric Energy Measure:** The scalar deviatoric energy, $E_{dev}(\\boldsymbol{\\sigma}) = \\frac{1}{2}dev(\\boldsymbol{\\sigma}):dev(\\boldsymbol{\\sigma})$, is calculated. First, the deviatoric tensor $\\boldsymbol{\\sigma}' = dev(\\boldsymbol{\\sigma})$ is computed. Then, its double dot product with itself, $\\boldsymbol{\\sigma}':\\boldsymbol{\\sigma}'$, is calculated and multiplied by $\\frac{1}{2}$.\n\n*   **Idempotence Verification:** To numerically test the property $dev(dev(\\boldsymbol{\\sigma})) = dev(\\boldsymbol{\\sigma})$, we compute the difference between the two sides of the equation: $D = dev(dev(\\boldsymbol{\\sigma})) - dev(\\boldsymbol{\\sigma})$. Due to floating-point arithmetic, this difference may not be exactly zero. Therefore, we quantify its magnitude using the Frobenius norm, $||D||_F = \\sqrt{D:D}$. The idempotence property is considered to hold numerically if this norm is less than a small tolerance, which is specified as $10^{-10}$. The result is a boolean flag.\n\n**4. Overall Procedure:**\nThe main algorithm will execute the following steps for each of the provided input stress tensors:\n1.  Receive the input tensor $\\boldsymbol{\\sigma}$.\n2.  Compute its deviatoric part: $\\boldsymbol{\\sigma}' = dev(\\boldsymbol{\\sigma})$.\n3.  Compute the deviatoric energy: $E_{dev} = \\frac{1}{2} (\\boldsymbol{\\sigma}':\\boldsymbol{\\sigma}')$.\n4.  Compute the second application of the deviatoric operator: $\\boldsymbol{\\sigma}'' = dev(\\boldsymbol{\\sigma}')$.\n5.  Calculate the difference tensor for the idempotence check: $D = \\boldsymbol{\\sigma}'' - \\boldsymbol{\\sigma}'$.\n6.  Calculate the Frobenius norm of the difference: $||D||_F = \\sqrt{D:D}$.\n7.  Compare the norm to the tolerance to get the boolean flag: $\\text{flag} = (||D||_F  10^{-10})$.\n8.  Store the pair $[E_{dev}, \\text{flag}]$.\n\nAfter processing all test cases, the collected results will be formatted into a single string as specified by the problem, e.g., `[[E_A, flag_A], [E_B, flag_B], ...]`, and printed to standard output.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes a scalar deviatoric energy measure and verifies the idempotence\n    of the deviatoric projection for a given suite of second-order stress tensors.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # sigma_A: General case\n        np.array([[120.0, -30.0, 45.0], \n                  [-30.0, 80.0, 0.0], \n                  [45.0, 0.0, -10.0]]),\n        \n        # sigma_B: Pure hydrostatic case\n        np.array([[50.0, 0.0, 0.0], \n                  [0.0, 50.0, 0.0], \n                  [0.0, 0.0, 50.0]]),\n        \n        # sigma_C: Pure deviatoric case\n        np.array([[30.0, -6.0, 0.0], \n                  [-6.0, -15.0, 0.0], \n                  [0.0, 0.0, -15.0]]),\n        \n        # sigma_D: Zero tensor\n        np.array([[0.0, 0.0, 0.0], \n                  [0.0, 0.0, 0.0], \n                  [0.0, 0.0, 0.0]]),\n\n        # sigma_E: Tiny-magnitude deviatoric case\n        np.array([[1e-12, 2e-12, -3e-12],\n                  [2e-12, -1e-12, 4e-12],\n                  [-3e-12, 4e-12, 0.0]])\n    ]\n\n    results = []\n    \n    # Define the second-order identity tensor in 3D\n    identity_tensor = np.identity(3)\n    \n    # Define tolerance for the idempotence check\n    tolerance = 1e-10\n\n    def double_dot_product(tensor_A, tensor_B):\n        \"\"\"\n        Computes the double dot product A:B = sum(A_ij * B_ij).\n        \"\"\"\n        return np.sum(tensor_A * tensor_B)\n\n    def deviatoric_operator(tensor):\n        \"\"\"\n        Computes the deviatoric part of a tensor: dev(T) = T - 1/3 * tr(T) * I.\n        \"\"\"\n        trace = double_dot_product(tensor, identity_tensor)\n        return tensor - (trace / 3.0) * identity_tensor\n\n    for sigma in test_cases:\n        # 1. Compute the deviatoric part of the stress tensor\n        dev_sigma = deviatoric_operator(sigma)\n        \n        # 2. Compute the scalar deviatoric energy\n        # E_dev = 1/2 * dev(sigma):dev(sigma)\n        deviatoric_energy = 0.5 * double_dot_product(dev_sigma, dev_sigma)\n        \n        # 3. Verify the idempotence property: dev(dev(sigma)) = dev(sigma)\n        # We compute dev(dev(sigma))\n        dev_dev_sigma = deviatoric_operator(dev_sigma)\n        \n        # Calculate the difference tensor D = dev(dev(sigma)) - dev(sigma)\n        difference_tensor = dev_dev_sigma - dev_sigma\n        \n        # Calculate the Frobenius norm of the difference: ||D||_F = sqrt(D:D)\n        norm_of_difference = np.sqrt(double_dot_product(difference_tensor, difference_tensor))\n        \n        # Check if the norm is within the specified tolerance\n        idempotence_holds = norm_of_difference  tolerance\n        \n        # Append the result pair to the list\n        results.append([deviatoric_energy, idempotence_holds])\n\n    # Convert each two-element list result into its string representation\n    # e.g., [7358.333, True] becomes \"[7358.333333333333, True]\"\n    # Using python's boolean string representation 'True'/'False' directly.\n    string_results = [str(res) for res in results]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(string_results)}]\")\n\nsolve()\n```"
        }
    ]
}