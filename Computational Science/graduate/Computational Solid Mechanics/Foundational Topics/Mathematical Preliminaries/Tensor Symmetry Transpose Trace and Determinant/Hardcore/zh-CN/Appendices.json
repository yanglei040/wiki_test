{
    "hands_on_practices": [
        {
            "introduction": "行列式是线性代数中的一个基本概念，但在数值计算中，其计算并非易事。本练习  旨在通过比较不同计算方法的精度——经典的拉普拉斯展开法与基于特征值的方法——来探索数值计算中的陷阱。我们将研究矩阵的条件数和偏离对称性的程度如何影响这些方法的稳定性和准确性，从而加深对计算力学中数值稳定重要性的理解。",
            "id": "3605420",
            "problem": "令 $C \\in \\mathbb{R}^{3 \\times 3}$ 表示一个二阶张量（一个实的 $3 \\times 3$ 矩阵），例如，在计算固体力学中作为右柯西-格林张量的离散表示。$C$ 的转置表示为 $C^{\\mathsf{T}}$。$C$ 的对称部分定义为 $S = \\tfrac{1}{2}\\left(C + C^{\\mathsf{T}}\\right)$，斜对称部分定义为 $W = \\tfrac{1}{2}\\left(C - C^{\\mathsf{T}}\\right)$。弗罗贝尼乌斯范数定义为 $\\lVert X \\rVert_{\\mathrm{F}} = \\sqrt{\\sum_{i,j} x_{ij}^{2}}$。矩阵 $2$-范数下的谱条件数是 $\\kappa_{2}(C) = \\lVert C \\rVert_{2}\\,\\lVert C^{-1} \\rVert_{2}$，其中 $\\lVert \\cdot \\rVert_{2}$ 表示算子 $2$-范数。行列式为 $\\det(C)$，迹为 $\\mathrm{tr}(C)$。\n\n您的任务是编写一个程序，对于一组给定的张量 $C$ 测试套件，比较计算 $\\det(C)$ 的两种策略——直接的拉普拉斯展开和特征值之积——并量化每种方法的浮点误差，将其表示为 $C$ 的条件数和对称性偏差的函数。\n\n使用的基本原理和定义：\n- 行列式是一个多重线性交替形式，其值等于由 $C$ 所代表的线性映射的有向体积缩放因子。\n- 行列式等于特征值之积（计入代数重数），即，如果 $\\{\\lambda_{i}\\}_{i=1}^{3}$ 是 $C$ 的特征值，则 $\\det(C) = \\prod_{i=1}^{3} \\lambda_{i}$。\n- 对于满足 $Q^{\\mathsf{T}}Q = I$ 的正交矩阵 $Q$，行列式在正交相似变换下是不变的，即 $\\det\\!\\left(Q \\Lambda Q^{\\mathsf{T}}\\right) = \\det(\\Lambda)$，且 $Q \\Lambda Q^{\\mathsf{T}}$ 的奇异值与 $\\Lambda$ 的奇异值相等。\n- 微分恒等式 $\\mathrm{d} \\log \\det(C) = \\mathrm{tr}\\!\\left(C^{-1} \\mathrm{d}C\\right)$ 意味着 $\\det(\\cdot)$ 对扰动的一阶灵敏度界。\n\n实现要求：\n1. 对于每个指定的测试用例，按如下方式构造张量 $C$：\n   $$C = Q \\,\\mathrm{diag}(\\ell_{1},\\ell_{2},\\ell_{3})\\, Q^{\\mathsf{T}} + \\varepsilon A,$$\n   其中 $Q$ 是一个给定的正交矩阵，$\\mathrm{diag}(\\ell_{1},\\ell_{2},\\ell_{3})$ 是一个对角线元素为正的实对角矩阵（定义一个对称正定（SPD）基底），$A$ 是一个归一化为单位弗罗贝尼乌斯范数的固定斜对称矩阵，$\\varepsilon \\ge 0$ 是一个给定的标量，用于控制对称性的偏差。对称性偏差必须以相对斜对称度量来报告：\n   $$\\delta_{\\mathrm{skew}}(C) = \\frac{\\lVert \\tfrac{1}{2}(C - C^{\\mathsf{T}}) \\rVert_{\\mathrm{F}}}{\\lVert C \\rVert_{\\mathrm{F}}}.$$\n2. 使用以下方法计算 $\\det(C)$：\n   - 沿第一行的直接拉普拉斯展开（即使用余子式的代数余子式展开）。\n   - 由通用特征值程序（适用于可能非对称的 $C$）计算的特征值之积。\n   使用一个基于数值稳定分解的程序作为参考行列式（例如，一个在数学上等同于带部分主元的高斯消元法的程序）。\n3. 量化每种方法相对于参考值的相对误差：\n   $$e_{\\mathrm{L}} = \\frac{\\lvert \\det_{\\mathrm{Laplace}}(C) - \\det_{\\mathrm{ref}}(C) \\rvert}{\\lvert \\det_{\\mathrm{ref}}(C) \\rvert}, \\quad e_{\\mathrm{E}} = \\frac{\\lvert \\det_{\\mathrm{eigprod}}(C) - \\det_{\\mathrm{ref}}(C) \\rvert}{\\lvert \\det_{\\mathrm{ref}}(C) \\rvert}.$$\n   如果 $\\lvert \\det_{\\mathrm{ref}}(C) \\rvert$ 下溢至低于机器可表示的阈值，则为了稳健性切换到绝对误差，但仍报告程序计算出的数值。\n4. 对于每个 $C$，还需使用奇异值（通过奇异值分解（SVD））计算谱条件数 $\\kappa_{2}(C)$。\n5. 用于定义旋转的角度必须以弧度为单位进行解释。\n\n测试套件：\n- 定义固定的斜对称矩阵 $A_{0}$：\n  $$A_{0} = \\begin{bmatrix} 0  1  -2 \\\\ -1  0  3 \\\\ 2  -3  0 \\end{bmatrix}, \\quad A = \\frac{A_{0}}{\\lVert A_{0} \\rVert_{\\mathrm{F}}}.$$\n- 定义旋转矩阵：\n  - 绕 $z$ 轴旋转角度 $\\theta$：\n    $$R_{z}(\\theta) = \\begin{bmatrix} \\cos\\theta  -\\sin\\theta  0 \\\\ \\sin\\theta  \\cos\\theta  0 \\\\ 0  0  1 \\end{bmatrix}.$$\n  - 绕 $x$ 轴旋转角度 $\\phi$：\n    $$R_{x}(\\phi) = \\begin{bmatrix} 1  0  0 \\\\ 0  \\cos\\phi  -\\sin\\phi \\\\ 0  \\sin\\phi  \\cos\\phi \\end{bmatrix}.$$\n  - 使用罗德里格斯公式绕单位轴 $u \\in \\mathbb{R}^{3}$ 旋转角度 $\\alpha$：\n    $$R(u,\\alpha) = I \\cos\\alpha + (1-\\cos\\alpha)\\,u u^{\\mathsf{T}} + [u]_{\\times} \\sin\\alpha,$$\n    其中 $[u]_{\\times}$ 是与 $u$ 相关的斜对称叉积矩阵。\n- 指定正交矩阵和对角谱：\n  - $Q_{0} = I$。\n  - $Q_{1} = R_{z}(\\theta_{z})$，其中 $\\theta_{z} = \\pi/3$。\n  - $Q_{2} = R(u,\\alpha)$，其中 $u = \\tfrac{1}{\\sqrt{3}}[1,1,1]^{\\mathsf{T}}$ 且 $\\alpha = \\pi/5$。\n  - $Q_{3} = R_{z}(\\pi/7)\\,R_{x}(\\pi/9)$。\n  - $\\Lambda_{1} = \\mathrm{diag}(1,1,1)$。\n  - $\\Lambda_{2} = \\mathrm{diag}(10^{6},1,1)$。\n  - $\\Lambda_{3} = \\mathrm{diag}(1,1,10^{-6})$。\n  - $\\Lambda_{6} = \\mathrm{diag}(10,1,10^{-1})$。\n- 按如下方式构造六个测试用例：\n  1. $(\\Lambda_{1}, Q_{0}, \\varepsilon = 0)$。\n  2. $(\\Lambda_{2}, Q_{1}, \\varepsilon = 0)$。\n  3. $(\\Lambda_{3}, Q_{2}, \\varepsilon = 0)$。\n  4. $(\\Lambda_{2}, Q_{1}, \\varepsilon = 10^{-8})$。\n  5. $(\\Lambda_{3}, Q_{2}, \\varepsilon = 10^{-4})$。\n  6. $(\\Lambda_{6}, Q_{3}, \\varepsilon = 10^{-2})$。\n\n程序输出规范：\n- 对于每个测试用例，计算并记录列表\n  $$\\left[ \\kappa_{2}(C),\\ \\delta_{\\mathrm{skew}}(C),\\ e_{\\mathrm{L}},\\ e_{\\mathrm{E}} \\right].$$\n- 最终的程序输出必须是包含所有六个测试用例结果的单行，形式为这些四元组列表的逗号分隔列表，并用一对单独的方括号括起来，例如：\n  $$\\big[\\,[\\kappa_{2}^{(1)},\\delta_{\\mathrm{skew}}^{(1)},e_{\\mathrm{L}}^{(1)},e_{\\mathrm{E}}^{(1)}],\\ldots,[\\kappa_{2}^{(6)},\\delta_{\\mathrm{skew}}^{(6)},e_{\\mathrm{L}}^{(6)},e_{\\mathrm{E}}^{(6)}]\\,\\big].$$\n不涉及物理单位。角度必须以弧度为单位。所有数值必须以十进制浮点数输出。",
            "solution": "问题陈述经评估有效。它在科学上基于数值线性代数和计算力学，定义和数据完整且一致，问题阐述清晰，并且其表述是客观的。任务是进行一个数值实验，比较计算一个 $3 \\times 3$ 矩阵行列式的两种方法的准确性，并与一个基准参考值进行对比，评估其准确性与矩阵条件数及其对称性偏差的关系。这在数值分析中是一个标准且有意义的练习。\n\n解决方案首先通过算法构建测试矩阵，然后使用指定方法计算所需量，最后以规定格式报告结果。\n\n问题的核心是根据以下公式构造一系列测试张量 $C \\in \\mathbb{R}^{3 \\times 3}$：\n$$C = Q \\Lambda Q^{\\mathsf{T}} + \\varepsilon A$$\n这里，$Q$ 是一个正交矩阵 ($Q^{\\mathsf{T}}Q=I$)，$\\Lambda = \\mathrm{diag}(\\ell_{1},\\ell_{2},\\ell_{3})$ 是一个对角线元素为正的对角矩阵，$\\varepsilon \\ge 0$ 是一个控制非对称扰动大小的标量，$A$ 是一个固定的、单位范数的斜对称矩阵。项 $Q \\Lambda Q^{\\mathsf{T}}$ 代表一个对称正定（SPD）张量，然后被斜对称项 $\\varepsilon A$ 扰动。\n\n固定的斜对称矩阵 $A_0$ 如下所示：\n$$A_{0} = \\begin{bmatrix} 0  1  -2 \\\\ -1  0  3 \\\\ 2  -3  0 \\end{bmatrix}$$\n该矩阵必须根据弗罗贝尼乌斯范数进行归一化，$\\lVert X \\rVert_{\\mathrm{F}} = \\sqrt{\\mathrm{tr}(X^{\\mathsf{T}}X)} = \\sqrt{\\sum_{i,j} x_{ij}^{2}}$。$A_0$ 的弗罗贝尼乌斯范数的平方是 $\\lVert A_0 \\rVert_{\\mathrm{F}}^2 = 0^2 + 1^2 + (-2)^2 + (-1)^2 + 0^2 + 3^2 + 2^2 + (-3)^2 + 0^2 = 1+4+1+9+4+9 = 28$。因此，归一化后的矩阵是 $A = A_0 / \\sqrt{28}$。\n\n对于由三元组 $(\\Lambda, Q, \\varepsilon)$ 指定的每个测试用例，构造矩阵 $C$。然后，我们计算四个关键指标：\n\n1.  **谱条件数, $\\kappa_{2}(C)$**：此指标量化了矩阵逆对扰动的敏感性。对于一个通用矩阵 $C$，它定义为 $\\kappa_{2}(C) = \\lVert C \\rVert_{2}\\,\\lVert C^{-1} \\rVert_{2}$。最稳健的计算方法是使用通过奇异值分解（SVD）得到的 $C$ 的奇异值 $\\{\\sigma_i\\}$。条件数是最大奇异值与最小奇异值之比：$\\kappa_{2}(C) = \\sigma_{\\max} / \\sigma_{\\min}$。\n\n2.  **相对斜对称度量, $\\delta_{\\mathrm{skew}}(C)$**：此指标衡量 $C$ 偏离对称矩阵的程度。它定义为 $C$ 的斜对称部分的弗罗贝尼乌斯范数与 $C$ 本身的弗罗贝尼乌斯范数之比：\n    $$\\delta_{\\mathrm{skew}}(C) = \\frac{\\lVert W \\rVert_{\\mathrm{F}}}{\\lVert C \\rVert_{\\mathrm{F}}} \\quad \\text{其中} \\quad W = \\frac{1}{2}(C - C^{\\mathsf{T}})$$\n    对于构造的矩阵，$W = \\frac{1}{2}((Q \\Lambda Q^{\\mathsf{T}} + \\varepsilon A) - (Q \\Lambda Q^{\\mathsf{T}} + \\varepsilon A)^{\\mathsf{T}}) = \\frac{1}{2}(\\varepsilon A - \\varepsilon A^{\\mathsf{T}})$。由于 $A$ 是斜对称的（$A^{\\mathsf{T}} = -A$），这简化为 $W = \\varepsilon A$。\n\n3.  **拉普拉斯展开误差, $e_{\\mathrm{L}}$**：首先使用沿 $C=[c_{ij}]$ 第一行的拉普拉斯（或代数余子式）展开计算行列式：\n    $$\\det_{\\mathrm{Laplace}}(C) = c_{11}(c_{22}c_{33} - c_{23}c_{32}) - c_{12}(c_{21}c_{33} - c_{23}c_{31}) + c_{13}(c_{21}c_{32} - c_{22}c_{31})$$\n    众所周知，由于相减抵消，该方法在数值上是不稳定的，特别是对于较大或病态的矩阵。\n\n4.  **特征值乘积误差, $e_{\\mathrm{E}}$**：行列式也作为其特征值的乘积来计算，$\\det_{\\mathrm{eigprod}}(C) = \\prod_{i=1}^{3} \\lambda_{i}$。由于 $C$ 可能非对称，其特征值 $\\{\\lambda_i\\}$ 可能是复数，因此需要一个通用的特征值求解器。\n\n这两种方法将与一个参考行列式 $\\det_{\\mathrm{ref}}(C)$ 进行比较，该参考行列式使用标准的、数值稳定的库函数计算。此类函数通常采用如带部分主元消去法的 LU 分解等矩阵分解方法，这种方法通常既稳健又高效。然后计算相对误差：\n$$e_{\\mathrm{L}} = \\frac{\\lvert \\det_{\\mathrm{Laplace}}(C) - \\det_{\\mathrm{ref}}(C) \\rvert}{\\lvert \\det_{\\mathrm{ref}}(C) \\rvert}, \\quad e_{\\mathrm{E}} = \\frac{\\lvert \\det_{\\mathrm{eigprod}}(C) - \\det_{\\mathrm{ref}}(C) \\rvert}{\\lvert \\det_{\\mathrm{ref}}(C) \\rvert}$$\n如果 $\\det_{\\mathrm{ref}}(C)$ 为零，则此公式无定义。然而，此问题中构造的矩阵被设计为可逆的，尽管有些可能接近奇异（即具有非常大的条件数），导致分母非常小。\n\n正交矩阵 $Q$ 是使用标准旋转矩阵公式构造的。对于绕单位轴 $u$ 旋转角度 $\\alpha$，使用罗德里格斯公式：\n$$R(u,\\alpha) = I \\cos\\alpha + (1-\\cos\\alpha)\\,u u^{\\mathsf{T}} + [u]_{\\times} \\sin\\alpha$$\n其中 $[u]_{\\times}$ 是与 $u$ 的叉积相关的斜对称矩阵表示：\n$$[u]_{\\times} = \\begin{bmatrix} 0  -u_3  u_2 \\\\ u_3  0  -u_1 \\\\ -u_2  u_1  0 \\end{bmatrix}$$\n我们将为每种旋转类型和罗德里格斯公式实现辅助函数来构建测试用例。最终的实现将系统地处理六个指定的测试用例，为每个用例执行所有计算，并将结果四元组 $[\\kappa_{2}(C), \\delta_{\\mathrm{skew}}(C), e_{\\mathrm{L}}, e_{\\mathrm{E}}]$ 格式化为最终所需的输出结构。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Solves the problem by constructing test matrices, computing determinants\n    via three methods, and evaluating errors and matrix properties.\n    \"\"\"\n\n    def get_laplace_determinant(C):\n        \"\"\"Computes the determinant of a 3x3 matrix using Laplace expansion.\"\"\"\n        # C[i,j] corresponds to c_{i+1, j+1}\n        det = (C[0, 0] * (C[1, 1] * C[2, 2] - C[1, 2] * C[2, 1]) -\n               C[0, 1] * (C[1, 0] * C[2, 2] - C[1, 2] * C[2, 0]) +\n               C[0, 2] * (C[1, 0] * C[2, 1] - C[1, 1] * C[2, 0]))\n        return det\n\n    def get_eigenvalue_determinant(C):\n        \"\"\"Computes the determinant from the product of eigenvalues.\"\"\"\n        eigenvalues = np.linalg.eigvals(C)\n        return np.prod(eigenvalues)\n\n    def rz_matrix(theta):\n        \"\"\"Returns the rotation matrix around the z-axis.\"\"\"\n        c, s = np.cos(theta), np.sin(theta)\n        return np.array([[c, -s, 0], [s, c, 0], [0, 0, 1]])\n\n    def rx_matrix(phi):\n        \"\"\"Returns the rotation matrix around the x-axis.\"\"\"\n        c, s = np.cos(phi), np.sin(phi)\n        return np.array([[1, 0, 0], [0, c, -s], [0, s, c]])\n\n    def rodrigues_rotation(u, alpha):\n        \"\"\"\n        Computes the rotation matrix for a rotation about axis u by angle alpha.\n        \"\"\"\n        u = np.asarray(u)\n        u = u / np.linalg.norm(u)\n        I = np.identity(3)\n        u_outer = np.outer(u, u)\n        u_cross_matrix = np.array([\n            [0, -u[2], u[1]],\n            [u[2], 0, -u[0]],\n            [-u[1], u[0], 0]\n        ])\n        cos_a = np.cos(alpha)\n        sin_a = np.sin(alpha)\n        R = I * cos_a + (1 - cos_a) * u_outer + u_cross_matrix * sin_a\n        return R\n\n    # Define the fixed skew-symmetric matrix A\n    A0 = np.array([[0, 1, -2], [-1, 0, 3], [2, -3, 0]])\n    A = A0 / np.linalg.norm(A0, 'fro')\n\n    # Define the orthogonal matrices Q\n    Q0 = np.identity(3)\n    Q1 = rz_matrix(np.pi / 3)\n    u2 = (1 / np.sqrt(3)) * np.array([1, 1, 1])\n    Q2 = rodrigues_rotation(u2, np.pi / 5)\n    Q3 = rz_matrix(np.pi / 7) @ rx_matrix(np.pi / 9)\n\n    # Define the diagonal matrices Lambda\n    Lambda1 = np.diag([1, 1, 1])\n    Lambda2 = np.diag([1e6, 1, 1])\n    Lambda3 = np.diag([1, 1, 1e-6])\n    Lambda6 = np.diag([10, 1, 1e-1])\n\n    # Define the test suite\n    test_cases = [\n        (Lambda1, Q0, 0.0),\n        (Lambda2, Q1, 0.0),\n        (Lambda3, Q2, 0.0),\n        (Lambda2, Q1, 1e-8),\n        (Lambda3, Q2, 1e-4),\n        (Lambda6, Q3, 1e-2)\n    ]\n\n    results = []\n    for Lambda, Q, epsilon in test_cases:\n        # 1. Construct the tensor C\n        C = Q @ Lambda @ Q.T + epsilon * A\n\n        # 2. Compute determinants\n        det_ref = np.linalg.det(C)\n        det_laplace = get_laplace_determinant(C)\n        det_eig = get_eigenvalue_determinant(C)\n\n        # 3. Quantify relative errors\n        if np.abs(det_ref) > np.finfo(float).tiny:\n            e_L = np.abs(det_laplace - det_ref) / np.abs(det_ref)\n            e_E = np.abs(det_eig - det_ref) / np.abs(det_ref)\n        else: # Handle denormalized or zero determinant\n            e_L = np.abs(det_laplace - det_ref)\n            e_E = np.abs(det_eig - det_ref)\n\n        # 4. Compute spectral condition number kappa_2(C)\n        singular_values = np.linalg.svd(C, compute_uv=False)\n        kappa_2 = singular_values[0] / singular_values[-1]\n\n        # 5. Compute relative skew measure delta_skew(C)\n        W = 0.5 * (C - C.T)\n        delta_skew = np.linalg.norm(W, 'fro') / np.linalg.norm(C, 'fro')\n        \n        # Ensure outputs are floats\n        case_results = [float(kappa_2), float(delta_skew), float(e_L), float(np.real(e_E))]\n        results.append(case_results)\n\n    # Final print statement in the exact required format\n    # Using f-strings with general format specifier 'g' for clean output\n    output_str = \"[\" + \",\".join(\n        f\"[{res[0]:.15g},{res[1]:.15g},{res[2]:.15g},{res[3]:.15g}]\" for res in results\n    ) + \"]\"\n    print(output_str)\n\nsolve()\n\n```"
        },
        {
            "introduction": "在认识到直接计算可能存在数值不稳定性之后，我们转向一个更具体的挑战：在固体力学中，如何稳定地计算雅可比行列式的对数 $\\ln J$。当雅可比行列式 $J$ 的值极大或极小时，直接计算会面临上溢或下溢的风险。本练习  要求你设计并实现一个利用奇异值分解 (SVD) 和动态缩放技术的数值稳定算法，以有效避免这些错误，确保计算的鲁棒性。",
            "id": "3605427",
            "problem": "设计一个数值稳定的算法，用于计算雅可比行列式的自然对数 $\\,\\ln J\\,$。其中 $\\,J = \\det F\\,$，$\\,F \\in \\mathbb{R}^{n \\times n}\\,$ 是一个表示计算固体力学中变形梯度的实方阵。假设 $\\,F\\,$ 可能是病态的，并且在具有物理意义的情况下 $\\,J>0\\,$，但允许在人工测试中出现 $\\,J<0\\,$ 的情况。您的解决方案必须从第一性原理和核心定义出发。仅从以下基本事实开始：(i) 奇异值分解（SVD）的存在性，即任何实矩阵 $\\,F\\,$ 都允许分解为 $\\,F = U \\Sigma V^{T}\\,$，其中 $\\,U, V\\,$ 是正交矩阵，$\\,\\Sigma\\,$ 是对角矩阵，其非负对角元称为奇异值；(ii) 正交矩阵的行列式大小为 $\\,1\\,$；(iii) 行列式的定义，即它是一个多线性交替形式，对于正规矩阵，其值等于特征值的乘积；以及 (iv) 对于可逆矩阵 $\\,F\\,$，行列式的弗雷歇微分满足 $\\,\\mathrm{d}(\\det F)[\\delta F] = \\det(F)\\,\\mathrm{tr}(F^{-1}\\delta F)\\,$，这意味着 $\\,\\mathrm{d}(\\ln \\det F)[\\delta F] = \\mathrm{tr}(F^{-1}\\delta F)\\,$。不要假设或陈述任何关于奇异值表示 $\\,\\ln \\det F\\,$ 的封闭形式快捷方式；相反，您使用的任何此类表达式都必须从这些基础推导出来。\n\n您的任务分为三个部分：\n\n1) 推导与条件数分析。仅使用上述基本事实，推导出用奇异值分解（SVD）中的量表示 $\\,\\ln | \\det F |\\,$ 的表达式，并使用扰动分析和弗雷歇微分来证明此计算的条件数。您的证明必须指明 $\\,F\\,$ 的哪些方面控制着灵敏度，并且必须与最小奇异值联系起来。提供绝对扰动 $\\,|\\delta(\\ln |\\det F|)|\\,$ 的一个界，用 $\\,F^{-1}\\,$ 的矩阵范数和 $\\,\\delta F\\,$ 的范数表示。\n\n2) 数值稳定的算法。提出一个数值稳定的算法，用于计算病态矩阵 $\\,F\\,$ 的 $\\,\\ln |\\det F|\\,$，该算法仅使用不会遭受灾难性下溢或上溢的操作。您的算法必须：\n- 在设计中明确使用奇异值分解（SVD）$\\,F = U \\Sigma V^{T}\\,$。\n- 采用2的幂进行动态缩放，以防止浮点运算中的中间溢出或下溢。令 $\\,k = \\lfloor \\log_{2}\\|F\\|_{F}\\rfloor\\,$，按 $\\,a = 2^{-k}\\,$ 进行缩放，并将 $\\,\\ln |\\det F|\\,$ 与 $\\,aF\\,$ 的奇异值相关联，而无需将奇异值相乘。\n- 同时从正交因子计算方向符号 $\\,s = \\operatorname{sign}(\\det F)\\in\\{-1,+1\\}\\,$。\n\n3) 实现与测试套件。将您的算法实现为一个程序，该程序不接受任何输入，并评估一组固定的测试矩阵 $\\,F_i\\,$，生成所需的输出。角度应解释为弧度，对数为自然对数。该程序应评估以下五个 $\\,\\mathbb{R}^{3\\times 3}\\,$ 中的方阵：\n- 情况 $\\,1\\,$ (良态，保向): $\\,F_1 = R_z(\\theta_1)\\,\\mathrm{diag}(2.0,\\,0.5,\\,1.5)\\,R_y(\\phi_1)^{T}\\,$，其中 $\\,\\theta_1=0.7\\,$，$\\phi_1=-0.4\\,$。\n- 情况 $\\,2\\,$ (高度病态但单位体积变化): $\\,F_2 = R_x(\\alpha_2)\\,\\mathrm{diag}(10^{-12},\\,1.0,\\,10^{12})\\,R_z(\\beta_2)^{T}\\,$，其中 $\\,\\alpha_2=0.3\\,$，$\\beta_2=1.2\\,$。\n- 情况 $\\,3\\,$ (尺度极大，若直接相乘有溢出风险): $\\,F_3 = R_y(\\alpha_3)\\,\\mathrm{diag}(10^{100},\\,2\\cdot 10^{100},\\,5\\cdot 10^{99})\\,R_x(\\beta_3)^{T}\\,$，其中 $\\,\\alpha_3=0.9\\,$，$\\beta_3=-1.1\\,$。\n- 情况 $\\,4\\,$ (尺度分离极端，若直接相乘有下溢风险): $\\,F_4 = R_z(\\theta_4)\\,\\mathrm{diag}(10^{-300},\\,10^{-10},\\,10^{20})\\,R_y(\\phi_4)^{T}\\,$，其中 $\\,\\theta_4=-0.8\\,$，$\\phi_4=0.6\\,$。\n- 情况 $\\,5\\,$ (反向): $\\,F_5 = R_x(\\alpha_5)\\,\\mathrm{diag}(-2.0,\\,3.0,\\,5.0)\\,R_y(\\beta_5)^{T}\\,$，其中 $\\,\\alpha_5=0.5\\,$，$\\beta_5=-0.7\\,$。\n\n此处，对于 $\\,\\gamma \\in \\mathbb{R}\\,$，\n$$\nR_x(\\gamma)=\\begin{bmatrix}\n1  0  0\\\\\n0  \\cos\\gamma  -\\sin\\gamma\\\\\n0  \\sin\\gamma  \\cos\\gamma\n\\end{bmatrix},\\quad\nR_y(\\gamma)=\\begin{bmatrix}\n\\cos\\gamma  0  \\sin\\gamma\\\\\n0  1  0\\\\\n-\\sin\\gamma  0  \\cos\\gamma\n\\end{bmatrix},\\quad\nR_z(\\gamma)=\\begin{bmatrix}\n\\cos\\gamma  -\\sin\\gamma  0\\\\\n\\sin\\gamma  \\cos\\gamma  0\\\\\n0  0  1\n\\end{bmatrix}.\n$$\n\n对于每种情况，您的程序必须输出一个列表 $\\,[\\ln|\\det F_i|,\\,s_i]\\,$，其中 $\\,s_i \\in\\{-1,+1\\}\\,$ 是从正交SVD因子计算出的方向符号。将所有五个结果汇总到一个列表中。最终输出格式必须是单行，包含一个由方括号括起来的、由逗号分隔的五个内部列表，例如 $\\,\\big[\\,[\\ell_1,s_1],[\\ell_2,s_2],\\dots,[\\ell_5,s_5]\\,\\big]\\,$，不含空格。\n\n您的实现必须使用自然对数和弧度作为角度单位，并且不得读取任何输入。输出 $\\,\\ln|\\det F_i|\\,$ 为浮点数，$\\,s_i\\,$ 为整数。这构成了测试套件和输出规范。",
            "solution": "任务是为计算可能病态的实方阵 $F \\in \\mathbb{R}^{n \\times n}$ 的雅可比行列式的自然对数 $\\ln J = \\ln(\\det F)$，设计、证明并实现一个数值稳定的算法。解决方案按要求分为三个部分：推导与条件数分析、算法设计和实现。\n\n**第一部分：推导与条件数分析**\n\n此部分基于奇异值分解（SVD）推导 $\\ln|\\det F|$ 的表达式，并分析问题的条件数。\n\n**$\\ln|\\det F|$ 的推导**\n\n我们给定以下基本事实：\n(i) 任何实矩阵 $F \\in \\mathbb{R}^{n \\times n}$ 都允许进行奇异值分解（SVD），$F = U \\Sigma V^{T}$，其中 $U, V \\in \\mathbb{R}^{n \\times n}$ 是正交矩阵，$\\Sigma \\in \\mathbb{R}^{n \\times n}$ 是一个对角矩阵，其非负对角元 $\\sigma_i \\ge 0$ 称为 $F$ 的奇异值。\n(ii) 任何正交矩阵的行列式大小为 $1$。\n(iii) 行列式是一个多线性交替形式，对于正规矩阵，其值等于特征值的乘积。\n\n利用行列式的乘法性质，我们可以将 $F$ 的行列式写为：\n$$\n\\det F = \\det(U \\Sigma V^{T}) = (\\det U) (\\det \\Sigma) (\\det V^{T})\n$$\n根据事实 (ii)，由于 $U$ 和 $V$ 是正交的，它们的行列式为 $\\det U = \\pm 1$ 和 $\\det V = \\pm 1$。由于矩阵转置的行列式等于原矩阵的行列式，$\\det V^T = \\det V = \\pm 1$。\n\n矩阵 $\\Sigma$ 是一个对角矩阵，它是正规矩阵的一个特例。根据事实 (iii)，其行列式是其特征值的乘积。对角矩阵的特征值是其对角线上的元素，在本例中即为 $F$ 的奇异值 $\\sigma_i$。因此：\n$$\n\\det \\Sigma = \\prod_{i=1}^{n} \\sigma_i\n$$\n综合这些结果，我们得到一个用 $F$ 的 SVD 分量表示其行列式的表达式：\n$$\n\\det F = (\\det U) (\\det V^T) \\prod_{i=1}^{n} \\sigma_i\n$$\n为了找到 $\\ln|\\det F|$ 的表达式，我们首先取行列式的绝对值：\n$$\n|\\det F| = |(\\det U) (\\det V^T)| \\left| \\prod_{i=1}^{n} \\sigma_i \\right|\n$$\n因为 $|\\det U| = 1$，$|\\det V^T| = 1$，且奇异值 $\\sigma_i$ 是非负的，所以乘积 $\\prod_{i=1}^{n} \\sigma_i$ 也是非负的。因此，我们有：\n$$\n|\\det F| = \\prod_{i=1}^{n} \\sigma_i\n$$\n此表达式表明，体积变化因子 $|\\det F|$ 完全由奇异值的乘积决定。对两边取自然对数，并利用乘积的对数等于对数的和这一性质，我们得到所需的表达式：\n$$\n\\ln|\\det F| = \\ln\\left(\\prod_{i=1}^{n} \\sigma_i\\right) = \\sum_{i=1}^{n} \\ln \\sigma_i\n$$\n此推导仅依赖于所提供的基本事实。该公式是数值稳定计算的基础，因为它避免了奇异值的显式相乘，这种相乘可能导致数值上溢或下溢。\n\n**条件数分析**\n\n我们给定事实 (iv)，行列式的弗雷歇微分，对于可逆矩阵 $F$，它导出其自然对数的微分：\n$$\n\\mathrm{d}(\\ln \\det F)[\\delta F] = \\mathrm{tr}(F^{-1} \\delta F)\n$$\n其中 $\\delta F$ 是矩阵 $F$ 的一个扰动。对于小扰动，这意味着 $\\ln(\\det F)$ 的变化，记作 $\\delta(\\ln \\det F)$，可以近似为：\n$$\n\\delta(\\ln \\det F) \\approx \\mathrm{tr}(F^{-1} \\delta F)\n$$\n问题关注的是 $\\ln|\\det F|$。如果我们假设扰动 $\\delta F$ 足够小，以至于 $\\mathrm{sign}(\\det(F+\\delta F)) = \\mathrm{sign}(\\det F)$，那么如果 $\\det F > 0$，则 $\\delta(\\ln|\\det F|) = \\delta(\\ln(\\det F))$；如果 $\\det F < 0$，则 $\\delta(\\ln(-\\det F))$。在这两种情况下，微分都是 $\\mathrm{tr}(F^{-1}\\delta F)$。所以，我们可以将 $\\ln|\\det F|$ 的扰动分析为：\n$$\n|\\delta(\\ln|\\det F|)| \\approx |\\mathrm{tr}(F^{-1} \\delta F)|\n$$\n为给此表达式定界，我们可以使用矩阵的弗罗贝尼乌斯内积的柯西-施瓦茨不等式，对于实矩阵 $A, B \\in \\mathbb{R}^{n \\times n}$，该内积定义为 $\\langle A, B \\rangle_F = \\mathrm{tr}(A^T B)$。不等式表明 $|\\langle A, B \\rangle_F| \\le \\|A\\|_F \\|B\\|_F$。令 $A = (F^{-1})^T$ 和 $B = \\delta F$，我们得到：\n$$\n|\\mathrm{tr}(((F^{-1})^T)^T \\delta F)| = |\\mathrm{tr}(F^{-1} \\delta F)| \\le \\|(F^{-1})^T\\|_F \\|\\delta F\\|_F\n$$\n由于弗罗贝尼乌斯范数在转置下不变，$\\|(F^{-1})^T\\|_F = \\|F^{-1}\\|_F$，我们获得界：\n$$\n|\\delta(\\ln|\\det F|)| \\lesssim \\|F^{-1}\\|_F \\|\\delta F\\|_F\n$$\n这个不等式将 $\\ln|\\det F|$ 的绝对扰动与 $F$ 的逆矩阵的范数以及扰动 $\\delta F$ 的范数联系起来。\n\n为了将这种灵敏度与 $F$ 的奇异值联系起来，我们将 $\\|F^{-1}\\|_F$ 表示为 $F$ 的奇异值。$F^{-1}$ 的 SVD 是 $F^{-1} = (U \\Sigma V^T)^{-1} = V \\Sigma^{-1} U^T$。$F^{-1}$ 的奇异值是 $F$ 的奇异值的倒数，即 $1/\\sigma_i$。$F^{-1}$ 的弗罗贝尼乌斯范数是其奇异值平方和的平方根：\n$$\n\\|F^{-1}\\|_F = \\sqrt{\\sum_{i=1}^{n} \\left(\\frac{1}{\\sigma_i}\\right)^2}\n$$\n令 $\\sigma_{\\min} = \\min_{i} \\{\\sigma_i\\}$ 为 $F$ 的最小奇异值。逆矩阵的范数则有下界 $\\|F^{-1}\\|_F \\ge \\sqrt{(1/\\sigma_{\\min})^2} = 1/\\sigma_{\\min}$。如果 $\\sigma_{\\min}$ 非常小，$F$ 就是病态的（接近奇异），并且 $\\|F^{-1}\\|_F$ 会变得非常大。因此，即使对于一个小的扰动 $\\|\\delta F\\|_F$，项 $\\|F^{-1}\\|_F \\|\\delta F\\|_F$ 也可能很大，这表明 $\\ln|\\det F|$ 的计算对 $F$ 的扰动很敏感。问题的条件数因此关键性地由 $F$ 的最小奇异值控制。\n\n**第二部分：数值稳定的算法**\n\n通过先计算 $J = \\det F$ 然后再取对数的朴素方法计算 $\\ln|\\det F|$ 很容易出现数值问题。如果 $F$ 的奇异值非常大或非常小，它们的乘积 $J$ 很容易在取对数之前就超出标准浮点表示的范围，导致上溢或下溢。推导出的表达式 $\\ln|\\det F| = \\sum_i \\ln \\sigma_i$ 通过将乘积转换为求和来规避此问题，而求和是一个稳定得多的运算。\n\n然而，问题指出 SVD 计算本身可能会受到 $F$ 的极端缩放的影响。为预先防止这种情况，需要一个动态缩放程序。\n\n所提出的算法如下：\n\n1.  **缩放**：给定矩阵 $F \\in \\mathbb{R}^{n \\times n}$，计算其弗罗贝尼乌斯范数 $\\|F\\|_F = \\sqrt{\\sum_{i,j=1}^{n} F_{ij}^2}$。为了将矩阵元素带入一个数值上有利的范围（数量级为 $1$），我们用 $2$ 的幂来缩放 $F$。\n    -   计算缩放指数 $k = \\lfloor \\log_2 \\|F\\|_F \\rfloor$。这可以使用 `floor(log2(norm))` 来计算。\n    -   定义缩放因子 $a = 2^{-k}$。\n    -   构成缩放后的矩阵 $F' = aF$。该矩阵的范数将在范围 $1 \\le \\|F'\\|_F < 2$ 内。\n\n2.  **缩放后矩阵的SVD**：计算经过良好缩放的矩阵 $F' = U' \\Sigma' (V')^T$ 的SVD。这会得到正交矩阵 $U'$ 和 $(V')^T$，以及包含 $F'$ 的奇异值 $\\sigma'_i$ 的对角矩阵 $\\Sigma'$。\n\n3.  **计算 $\\ln|\\det F|$**：我们将 $\\det F$ 与 $\\det F'$ 联系起来。由 $F' = aF$，我们有 $\\det(F') = \\det(aF) = a^n \\det F$。因此，$\\det F = a^{-n} \\det F'$。\n    取绝对值的自然对数：\n    $$\n    \\ln|\\det F| = \\ln|a^{-n} \\det F'| = \\ln(a^{-n}) + \\ln|\\det F'| = -n \\ln(a) + \\sum_{i=1}^{n} \\ln \\sigma'_i\n    $$\n    代入 $a = 2^{-k}$，我们有 $\\ln a = \\ln(2^{-k}) = -k \\ln 2$。计算的最终表达式为：\n    $$\n    \\ln|\\det F| = -n(-k \\ln 2) + \\sum_{i=1}^{n} \\ln \\sigma'_i = nk \\ln 2 + \\sum_{i=1}^{n} \\ln \\sigma'_i\n    $$\n    此计算是数值稳定的，因为它涉及对行为良好的奇异值 $\\sigma'_i$ 的对数求和，并加上一个缩放项。它完全避免了对原始奇异值 $\\sigma_i = \\sigma'_i/a$ 进行乘法运算。\n\n4.  **计算方向符号**：方向符号为 $s = \\mathrm{sign}(\\det F)$。由于缩放因子 $a = 2^{-k}$ 是正数，所以 $\\mathrm{sign}(\\det F) = \\mathrm{sign}(\\det F')$。\n    从 $F'$ 的 SVD，我们有 $\\det F' = (\\det U') (\\det \\Sigma') (\\det (V')^T)$。对于非奇异矩阵，所有奇异值 $\\sigma'_i$ 都是正的，所以 $\\det \\Sigma' = \\prod_i \\sigma'_i > 0$。\n    因此，符号由正交因子的行列式决定：\n    $$\n    s = \\mathrm{sign}(\\det F) = \\mathrm{sign}((\\det U')(\\det(V')^T)) = (\\det U')(\\det(V')^T)\n    $$\n    $U'$ 和 $(V')^T$ 的行列式是通过数值计算得出的。由于已知它们的值为 $\\pm 1$，可以将乘积四舍五入到最近的整数，以得到一个稳健的 $\\pm 1$ 符号。\n\n**算法总结**\n对于给定的矩阵 $F \\in \\mathbb{R}^{n \\times n}$：\na. 如果 $F$ 是零矩阵，则 $|\\det F| = 0$ 且 $\\ln|\\det F| = -\\infty$。符号未定义，但可取为 $0$ 或 $1$。我们假设 $F$ 非零。\nb. 计算弗罗贝尼乌斯范数 $\\|F\\|_F$。\nc. 计算缩放指数 $k = \\lfloor \\log_2 \\|F\\|_F \\rfloor$ 和因子 $a = 2^{-k}$。\nd. 构建缩放矩阵 $F' = aF$。\ne. 对 $F'$ 进行 SVD 分解，得到 $U'$、奇异值 $\\sigma'_i$ 和 $V'^T$。\nf. 计算 $\\ln|\\det F| = n k \\ln(2) + \\sum_i \\ln(\\sigma'_i)$。\ng. 计算符号 $s = \\mathrm{round}(\\det(U') \\cdot \\det(V'^T))$。\nh. 返回数对 $[\\ln|\\det F|, s]$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Designs and executes a numerically stable algorithm to compute ln|det(F)| and sign(det(F))\n    for a given set of test matrices F.\n    \"\"\"\n\n    def Rx(gamma):\n        \"\"\"Rotation matrix about x-axis.\"\"\"\n        c = np.cos(gamma)\n        s = np.sin(gamma)\n        return np.array([[1, 0, 0], [0, c, -s], [0, s, c]], dtype=np.float64)\n\n    def Ry(gamma):\n        \"\"\"Rotation matrix about y-axis.\"\"\"\n        c = np.cos(gamma)\n        s = np.sin(gamma)\n        return np.array([[c, 0, s], [0, 1, 0], [-s, 0, c]], dtype=np.float64)\n\n    def Rz(gamma):\n        \"\"\"Rotation matrix about z-axis.\"\"\"\n        c = np.cos(gamma)\n        s = np.sin(gamma)\n        return np.array([[c, -s, 0], [s, c, 0], [0, 0, 1]], dtype=np.float64)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (well-conditioned, orientation-preserving)\n        Rz(0.7) @ np.diag([2.0, 0.5, 1.5]) @ Ry(-0.4).T,\n        # Case 2 (highly ill-conditioned but with unit volume change)\n        Rx(0.3) @ np.diag([1e-12, 1.0, 1e12]) @ Rz(1.2).T,\n        # Case 3 (very large scales, risk of overflow)\n        Ry(0.9) @ np.diag([1e100, 2e100, 5e99]) @ Rx(-1.1).T,\n        # Case 4 (extreme scale separation, risk of underflow)\n        Rz(-0.8) @ np.diag([1e-300, 1e-10, 1e20]) @ Ry(0.6).T,\n        # Case 5 (orientation-reversing)\n        Rx(0.5) @ np.diag([-2.0, 3.0, 5.0]) @ Ry(-0.7).T\n    ]\n\n    results = []\n    \n    # Process each test case using the derived numerically stable algorithm\n    for F in test_cases:\n        n = F.shape[0]\n\n        # Step 1: Scaling\n        norm_F = np.linalg.norm(F, 'fro')\n        \n        # Handle the case of a zero matrix, though not in test suite.\n        if norm_F == 0:\n            log_det_abs = -np.inf\n            sign_det = 0 # Or undefined. Problem asks for +/-1. Assume non-singular.\n            results.append([log_det_abs, sign_det])\n            continue\n            \n        k = np.floor(np.log2(norm_F))\n        a = 2.0**(-k)\n        \n        # Step 2: SVD of Scaled Matrix\n        F_scaled = a * F\n        U, s_scaled, Vt = np.linalg.svd(F_scaled)\n\n        # Step 3: Compute ln|det F|\n        # ln|det F| = nk*ln(2) + sum(ln(sigma_i_scaled))\n        log_det_abs = n * k * np.log(2) + np.sum(np.log(s_scaled))\n\n        # Step 4: Compute Orientation Sign\n        # sign(det F) = det(U) * det(Vt)\n        det_U = np.linalg.det(U)\n        det_Vt = np.linalg.det(Vt)\n        sign_det = int(np.round(det_U * det_Vt))\n        \n        results.append([log_det_abs, sign_det])\n\n    # Final print statement in the exact required format.\n    # Convert list of lists to string and remove spaces.\n    output_str = str(results).replace(' ', '')\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "最后一个练习将我们的重点从算法设计转移到实现的验证上，这是开发可靠计算力学软件的关键一步。在本练习  中，你将利用基本的张量恒等式，如克莱姆法则和逆转置恒等式，作为原则性的单元测试。通过这些测试，你将能够系统地检验行列式和余子式矩阵计算的正确性，并识别由于数值计算策略（如轴转）和舍入误差可能导致的差异。",
            "id": "3605426",
            "problem": "在计算固体力学中，考虑变形梯度张量 $F \\in \\mathbb{R}^{3 \\times 3}$，其中雅可比行列式 $J = \\det(F)$ 用于量化局部体积变化。对 $\\det(F)$ 进行稳健的数值计算时，必须考虑下三角-上三角 (LU) 分解中的主元选择，以避免因行置换引起的符号错误。伴随矩阵（cofactor/adjugate tensor） $\\mathrm{cof}(F)$ 以及转置/逆的恒等式提供了原则性的单元测试，用于检测实现中的缺陷，特别是与错误转置相关的缺陷。\n\n从适用于张量的基本线性代数定义和事实出发：\n- 转置 $F^T$ 的定义为 $(F^T)_{ij} = F_{ji}$。\n- 可逆张量 $F$ 的逆 $F^{-1}$ 满足 $F F^{-1} = F^{-1} F = I$，其中 $I$ 是单位张量。\n- 对于所有可逆的 $F$，逆转置恒等式 $F^{-T} = (F^{-1})^T$ 成立。\n- 伴随矩阵（cofactor/adjugate tensor） $\\mathrm{cof}(F)$ 是代数余子式矩阵，对于可逆的 $F$ 满足 $\\mathrm{cof}(F) = \\det(F)\\, F^{-T}$。\n- 克莱姆法则（Cramer's rule）意味着对于所有 $F \\in \\mathbb{R}^{n \\times n}$（包括奇异矩阵 $F$），$F\\, \\mathrm{cof}(F)^T = \\det(F)\\, I$ 成立。\n- 带部分主元选择的 LU 分解得到 $P F = L U$，其中 $P$ 是一个置换矩阵，$L$ 是单位下三角矩阵，$U$ 是上三角矩阵，这意味着 $\\det(F) = \\det(P)\\, \\det(U)$，因为 $\\det(L) = 1$。\n\n您的任务是编写一个程序，对每个给定的 $3 \\times 3$ 测试张量 $F$ 执行以下操作：\n1. 使用通用后端调用（库行列式函数）计算 $\\det(F)$。\n2. 使用带部分主元选择的 LU 分解，通过恒等式 $\\det(F) = \\det(P)\\, \\prod_i U_{ii}$ 计算 $\\det(F)$，其中 $P F = L U$ 且 $U_{ii}$ 是 $U$ 的对角线元素。\n3. 根据其定义（代数余子式矩阵）计算 $\\mathrm{cof}(F)$，然后使用从克莱姆法则导出的迹恒等式再次计算 $\\det(F)$：$\\det(F) = \\frac{1}{3}\\, \\mathrm{tr}\\left(F\\, \\mathrm{cof}(F)^T\\right)$。\n4. 仅对可逆的 $F$ 验证逆转置恒等式 $F^{-T} = (F^{-1})^T$（对于奇异矩阵 $F$，跳过或标记为假）。\n5. 仅对可逆的 $F$ 验证伴随矩阵恒等式 $\\mathrm{cof}(F) = \\det(F)\\, F^{-T}$。\n6. 对所有 $F$ 验证克莱姆法则恒等式 $F\\, \\mathrm{cof}(F)^T = \\det(F)\\, I$。\n7. 比较三种行列式计算方法，检查因主元选择和舍入误差可能产生的任何差异。\n\n在矩阵相等性检查中，相对比较的容差使用 $\\varepsilon = 10^{-11}$，绝对比较的容差使用 $\\delta = 10^{-12}$（即，如果 $\\|A-B\\|_{\\infty} \\le \\delta + \\varepsilon \\|B\\|_{\\infty}$，则认为两个矩阵 $A$ 和 $B$ 相等）。\n\n测试套件（五个 $3 \\times 3$ 张量）：\n- 通用非奇异张量（正常情况）：\n$$\nF_1 = \\begin{bmatrix}\n1.2  -0.3  0.5 \\\\\n0.4  2.1  -1.0 \\\\\n-0.8  0.7  1.5\n\\end{bmatrix}\n$$\n- 对称正定张量：\n$$\nF_2 = \\begin{bmatrix}\n2  -1  0 \\\\\n-1  2  -1 \\\\\n0  -1  2\n\\end{bmatrix}\n$$\n- 负行列式张量（通过将 $F_2$ 左乘 $D = \\mathrm{diag}(-1,1,1)$ 构建）：\n$$\nF_3 = D F_2 = \\begin{bmatrix}\n-2  1  0 \\\\\n-1  2  -1 \\\\\n0  -1  2\n\\end{bmatrix}\n$$\n- 近奇异张量（边界条件）：\n$$\nF_4 = \\begin{bmatrix}\n1  1  1 \\\\\n1 + 10^{-8}  1 + 10^{-8}  1 + 10^{-8} \\\\\n1  2  3\n\\end{bmatrix}\n$$\n- 奇异张量（精确秩亏）：\n$$\nF_5 = \\begin{bmatrix}\n1  2  3 \\\\\n2  4  6 \\\\\n0  0  1\n\\end{bmatrix}\n$$\n\n最终输出格式：\n对于每个测试用例 $F_k$，生成一个包含六个条目的列表，顺序严格如下：\n$[\\det_{\\mathrm{lib}}, \\det_{\\mathrm{pivot}}, \\det_{\\mathrm{trace}}, \\text{invT\\_ok}, \\text{cof\\_adj\\_ok}, \\text{cramer\\_ok}]$，其中：\n- $\\det_{\\mathrm{lib}}$ 是来自后端调用的行列式，\n- $\\det_{\\mathrm{pivot}}$ 是来自带主元选择的 LU 分解的行列式，\n- $\\det_{\\mathrm{trace}}$ 是来自迹恒等式的行列式，\n- $\\text{invT\\_ok}$ 是 $F^{-T} = (F^{-1})^T$ 的布尔值（仅对可逆 $F$，否则为假），\n- $\\text{cof\\_adj\\_ok}$ 是 $\\mathrm{cof}(F) = \\det(F)\\, F^{-T}$ 的布尔值（仅对可逆 $F$，否则为假），\n- $\\text{cramer\\_ok}$ 是 $F\\, \\mathrm{cof}(F)^T = \\det(F)\\, I$ 的布尔值（对所有 $F$）。\n\n您的程序应生成单行输出，其中包含一个五个测试用例结果的列表，该列表为逗号分隔，并用方括号括起来，每个用例本身也表示为遵循上述顺序的列表。例如：\n$[[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],\\ldots]$。\n此计算不涉及物理单位。也不涉及角度。\n\n目标是使用这些恒等式作为原则性的单元测试，以捕捉转置错误，并检查在计算 $\\det(F)$ 时因主元选择和数值舍入而产生的差异。",
            "solution": "我们从适用于变形梯度张量的线性代数基础和恒等式开始。对于 $F \\in \\mathbb{R}^{3 \\times 3}$，$\\det(F)$ 可以通过几种一致的方法获得；结果不匹配则揭示了数值或实现上的缺陷。\n\n通过因式分解和主元选择计算行列式：在带部分主元选择的下三角-上三角 (LU) 分解中，我们得到 $P F = L U$，其中 $P$ 是一个置换矩阵，$L$ 是单位下三角矩阵（对角线元素等于 $1$），$U$ 是上三角矩阵。取两边行列式，\n$$\n\\det(P)\\, \\det(F) = \\det(L)\\, \\det(U) \\quad \\Rightarrow \\quad \\det(F) = \\det(P)\\, \\det(U),\n$$\n因为 $\\det(L) = 1$。此表达式明确了主元选择的影响：行置换会产生一个符号因子 $\\det(P) \\in \\{-1, +1\\}$，必须将其考虑在内，以避免 $\\det(F)$ 出现符号错误。\n\n伴随矩阵与克莱姆法则恒等式：伴随矩阵 $\\mathrm{cof}(F)$ 定义为代数余子式矩阵：\n$$\n\\mathrm{cof}(F)_{ij} = (-1)^{i+j} \\det(M_{ij}),\n$$\n其中 $M_{ij}$ 是通过删除第 $i$ 行和第 $j$ 列得到的余子式。克莱姆法则得出一个对所有方阵（包括奇异矩阵）都有效的恒等式：\n$$\nF\\, \\mathrm{cof}(F)^T = \\det(F)\\, I.\n$$\n对于 $3 \\times 3$ 矩阵，对两边取迹可得\n$$\n\\mathrm{tr}\\!\\left(F\\, \\mathrm{cof}(F)^T\\right) = \\det(F)\\, \\mathrm{tr}(I) = 3\\, \\det(F),\n$$\n这意味着基于迹的行列式公式为\n$$\n\\det(F) = \\frac{1}{3}\\, \\mathrm{tr}\\!\\left(F\\, \\mathrm{cof}(F)^T\\right).\n$$\n该公式仅依赖于伴随矩阵的定义并避免了求逆，因此即使当 $F$ 是奇异矩阵时，它也具有稳健性。\n\n逆转置恒等式与伴随矩阵恒等式：对于可逆的 $F$，逆转置恒等式\n$$\nF^{-T} = (F^{-1})^T\n$$\n可从 $F F^{-1} = I$ 和矩阵转置的性质直接得出。此外，经典的伴随矩阵恒等式\n$$\n\\mathrm{cof}(F) = \\det(F)\\, F^{-T}\n$$\n对可逆的 $F$ 成立，并且等价于 $F\\, \\mathrm{cof}(F)^T = \\det(F)\\, I$。\n\n数值验证策略和容差：我们采用相对容差 $\\varepsilon = 10^{-11}$ 和绝对容差 $\\delta = 10^{-12}$ 进行相等性检查。对于矩阵相等性 $A = B$，我们测试\n$$\n\\|A - B\\|_{\\infty} \\le \\delta + \\varepsilon \\, \\|B\\|_{\\infty},\n$$\n其中 $\\|\\cdot\\|_{\\infty}$ 是最大绝对值范数。在代码中，我们使用带有这些容差的 $\\mathrm{allclose}$ 风格的检查。\n\n每个测试用例 $F$ 的算法计划：\n1. 通过对行列式的标准后端调用计算 $\\det_{\\mathrm{lib}}$。\n2. 通过计算 $\\det(P)$ 和 $\\prod_i U_{ii}$，从带主元选择的 LU 分解中计算 $\\det_{\\mathrm{pivot}}$。\n3. 使用显式的 $3 \\times 3$ 代数余子式计算 $\\mathrm{cof}(F)$，然后获得 $\\det_{\\mathrm{trace}} = \\frac{1}{3}\\, \\mathrm{tr}(F\\, \\mathrm{cof}(F)^T)$。\n4. 通过秩来判断可逆性：如果 $\\mathrm{rank}(F) = 3$，则继续；否则视为不可逆。\n5. 如果可逆，通过分别计算 $(F^{-1})^T$ 和 $(F^T)^{-1}$ 并使用容差检查其相等性来验证 $F^{-T} = (F^{-1})^T$。\n6. 如果可逆，验证 $\\mathrm{cof}(F) = \\det_{\\mathrm{lib}}\\, F^{-T}$。\n7. 对所有 $F$，验证 $F\\, \\mathrm{cof}(F)^T = \\det_{\\mathrm{lib}}\\, I$。\n8. 记录元组 $[\\det_{\\mathrm{lib}}, \\det_{\\mathrm{pivot}}, \\det_{\\mathrm{trace}}, \\text{invT\\_ok}, \\text{cof\\_adj\\_ok}, \\text{cramer\\_ok}]$。\n\n边界情况的覆盖：\n- 通用非奇异情况测试了不同方法之间的一致性。\n- 对称正定情况检查了当 $F = F^T$（转置对称性）时的行为。\n- 负行列式情况突出了定向反转的影响，确保主元选择中的符号处理是正确的。\n- 近奇异情况考察了数值稳定性（舍入和条件数）。\n- 奇异情况避免了求逆，并测试了仍然有效的克莱姆法则恒等式。\n\n最终输出将五个测试用例的结果汇总到一个顶级列表中，并将其作为单行打印。行列式计算之间的差异（如果存在）源于主元选择的符号处理和数值舍入；基于 $F^{-T} = (F^{-1})^T$ 和 $\\mathrm{cof}(F) = \\det(F)\\, F^{-T}$ 的单元测试直接暴露了与转置相关的实现错误和伴随矩阵的误用，而 $F\\, \\mathrm{cof}(F)^T = \\det(F)\\, I$ 即使在 $F$ 是奇异矩阵时也提供了一个稳健的检查。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import lu\nimport json\n\ndef det_pivoting(A: np.ndarray) -> float:\n    \"\"\"\n    Compute det(A) using LU factorization with partial pivoting.\n    Given P @ A = L @ U, with L unit lower triangular, det(A) = det(P) * det(U).\n    \"\"\"\n    P, L, U = lu(A)\n    # det(P) is +/-1 for a permutation matrix; compute robustly\n    detP = np.linalg.det(P)\n    # Round to nearest integer to avoid tiny floating error\n    signP = int(np.round(detP))\n    detU = float(np.prod(np.diag(U)))\n    return signP * detU\n\ndef cofactor_3x3(A: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute the cofactor (adjugate) matrix of a 3x3 matrix A via signed minors.\n    \"\"\"\n    a = A\n    cof = np.empty((3, 3), dtype=float)\n    # Row 0\n    cof[0,0] = a[1,1]*a[2,2] - a[1,2]*a[2,1]\n    cof[0,1] = -(a[1,0]*a[2,2] - a[1,2]*a[2,0])\n    cof[0,2] = a[1,0]*a[2,1] - a[1,1]*a[2,0]\n    # Row 1\n    cof[1,0] = -(a[0,1]*a[2,2] - a[0,2]*a[2,1])\n    cof[1,1] = a[0,0]*a[2,2] - a[0,2]*a[2,0]\n    cof[1,2] = -(a[0,0]*a[2,1] - a[0,1]*a[2,0])\n    # Row 2\n    cof[2,0] = a[0,1]*a[1,2] - a[0,2]*a[1,1]\n    cof[2,1] = -(a[0,0]*a[1,2] - a[0,2]*a[1,0])\n    cof[2,2] = a[0,0]*a[1,1] - a[0,1]*a[1,0]\n    return cof\n\ndef det_trace_from_cof(A: np.ndarray, cofA: np.ndarray) -> float:\n    \"\"\"\n    Compute det(A) via the trace identity det(A) = (1/3) * tr(A @ cof(A).T) for 3x3.\n    \"\"\"\n    return float(np.trace(A @ cofA.T) / 3.0)\n\ndef is_invertible(A: np.ndarray) -> bool:\n    \"\"\"\n    Determine invertibility by rank for 3x3: rank == 3 => invertible.\n    \"\"\"\n    r = np.linalg.matrix_rank(A)\n    return r == 3\n\ndef allclose_inf_norm(A: np.ndarray, B: np.ndarray, rtol: float, atol: float) -> bool:\n    \"\"\"\n    Check max-norm closeness: ||A-B||_inf = atol + rtol * ||B||_inf\n    \"\"\"\n    diff = np.max(np.abs(A - B))\n    normB = np.max(np.abs(B))\n    return diff = (atol + rtol * normB)\n\ndef make_test_cases():\n    # F1: general non-singular\n    F1 = np.array([\n        [1.2, -0.3, 0.5],\n        [0.4,  2.1, -1.0],\n        [-0.8, 0.7, 1.5]\n    ], dtype=float)\n\n    # F2: symmetric positive definite\n    F2 = np.array([\n        [ 2.0, -1.0,  0.0],\n        [-1.0,  2.0, -1.0],\n        [ 0.0, -1.0,  2.0]\n    ], dtype=float)\n\n    # F3: negative determinant via left-multiplication by diag(-1,1,1)\n    D = np.diag([-1.0, 1.0, 1.0])\n    F3 = D @ F2\n\n    # F4: nearly singular\n    eps = 1e-8\n    F4 = np.array([\n        [1.0, 1.0, 1.0],\n        [1.0 + eps, 1.0 + eps, 1.0 + eps],\n        [1.0, 2.0, 3.0]\n    ], dtype=float)\n\n    # F5: singular (second row is 2x first row)\n    F5 = np.array([\n        [1.0, 2.0, 3.0],\n        [2.0, 4.0, 6.0],\n        [0.0, 0.0, 1.0]\n    ], dtype=float)\n\n    return [F1, F2, F3, F4, F5]\n\ndef solve():\n    rtol = 1e-11\n    atol = 1e-12\n\n    test_cases = make_test_cases()\n    results = []\n\n    for F in test_cases:\n        # Determinants\n        det_lib = float(np.linalg.det(F))\n        det_piv = det_pivoting(F)\n        cofF = cofactor_3x3(F)\n        det_trace = det_trace_from_cof(F, cofF)\n\n        # Invertibility check\n        invertible = is_invertible(F)\n\n        # Identity checks\n        if invertible:\n            invF = np.linalg.inv(F)\n            invT_from_inv = invF.T\n            invT_from_transpose = np.linalg.inv(F.T)\n            invT_ok = allclose_inf_norm(invT_from_inv, invT_from_transpose, rtol, atol)\n\n            # cof(F) = det(F) * F^{-T}\n            cof_adj_rhs = det_lib * invT_from_inv\n            cof_adj_ok = allclose_inf_norm(cofF, cof_adj_rhs, rtol, atol)\n        else:\n            invT_ok = False\n            cof_adj_ok = False\n\n        # Cramer's rule: F @ cof(F).T = det(F) * I for all F\n        lhs = F @ cofF.T\n        rhs = det_lib * np.eye(3)\n        cramer_ok = allclose_inf_norm(lhs, rhs, rtol, atol)\n\n        case_result = [det_lib, det_piv, det_trace, bool(invT_ok), bool(cof_adj_ok), bool(cramer_ok)]\n        results.append(case_result)\n\n    # Final print statement in the exact required format: single line, JSON-like brackets, no spaces.\n    print(json.dumps(results, separators=(',',':')))\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}