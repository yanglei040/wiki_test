{
    "hands_on_practices": [
        {
            "introduction": "To build a robust understanding of solid mechanics, we must first master the language of kinematics. This exercise grounds the abstract vector operators of gradient, divergence, and curl in the physical reality of a deforming body. By starting with a defined displacement field, you will see how the displacement gradient tensor, $\\nabla \\mathbf{u}$, encapsulates all local deformation information and can be decomposed into pure strain and pure rotation . This practice reinforces the fundamental connections between these operators and key physical concepts like volumetric change and infinitesimal rotation.",
            "id": "3568721",
            "problem": "A homogeneous, isotropic solid body undergoes a small deformation described by the displacement field $\\mathbf{u}(\\mathbf{x}) = \\begin{bmatrix} \\alpha x^{2} \\\\ \\beta x y \\\\ \\gamma z \\end{bmatrix}$, where $\\alpha$, $\\beta$, and $\\gamma$ are real constants, and $\\mathbf{x} = (x,y,z)$ are Cartesian coordinates. Using the kinematics of the infinitesimal strain theory as the fundamental base, perform the following:\n\n1. Starting from the definition of the displacement gradient $\\nabla \\mathbf{u}$ in Cartesian coordinates and the additive decomposition of a second-order tensor into symmetric and skew-symmetric parts, derive explicit expressions for the displacement gradient $\\nabla \\mathbf{u}$, the infinitesimal strain tensor $\\boldsymbol{\\varepsilon} = \\tfrac{1}{2}\\left(\\nabla \\mathbf{u} + (\\nabla \\mathbf{u})^{T}\\right)$, and the infinitesimal spin tensor $\\boldsymbol{\\omega} = \\tfrac{1}{2}\\left(\\nabla \\mathbf{u} - (\\nabla \\mathbf{u})^{T}\\right)$ as functions of $x$, $y$, $z$, $\\alpha$, $\\beta$, and $\\gamma$.\n\n2. Compute the divergence $\\nabla \\cdot \\mathbf{u}$ and the curl $\\nabla \\times \\mathbf{u}$, and verify from first principles that $\\operatorname{tr}(\\boldsymbol{\\varepsilon}) = \\nabla \\cdot \\mathbf{u}$ and that the axial (vector) representation of $\\boldsymbol{\\omega}$ equals $\\tfrac{1}{2}\\nabla \\times \\mathbf{u}$.\n\n3. Define the scalar invariant $S(x,y,z)$ by $S(x,y,z) := \\operatorname{tr}(\\boldsymbol{\\varepsilon}) + \\|\\boldsymbol{\\omega}_{\\text{ax}}\\|_{2}$, where $\\boldsymbol{\\omega}_{\\text{ax}}$ denotes the axial vector of $\\boldsymbol{\\omega}$ and $\\|\\cdot\\|_{2}$ is the Euclidean norm. Provide $S(x,y,z)$ in closed form as a function of $x$, $y$, $z$, $\\alpha$, $\\beta$, and $\\gamma$. Express the final result as a single analytic expression with no units.\n\nFinally, briefly comment on the spatial variation of the fields you computed and discuss the physical plausibility of the deformation under the small-strain hypothesis. The comment does not affect the grading of the calculation.\n\nYour final answer must be the single analytic expression for $S(x,y,z)$.",
            "solution": "The solution proceeds by following the three parts outlined in the problem statement.\n\nPart $1$: Derivation of the displacement gradient, strain tensor, and spin tensor.\n\nThe given displacement field is $\\mathbf{u}(\\mathbf{x}) = \\begin{pmatrix} u_x \\\\ u_y \\\\ u_z \\end{pmatrix} = \\begin{pmatrix} \\alpha x^{2} \\\\ \\beta x y \\\\ \\gamma z \\end{pmatrix}$.\nThe displacement gradient tensor, $\\nabla \\mathbf{u}$, is a second-order tensor whose components in Cartesian coordinates are given by $(\\nabla \\mathbf{u})_{ij} = \\frac{\\partial u_i}{\\partial x_j}$.\n\nThe components are calculated as follows:\n$(\\nabla \\mathbf{u})_{11} = \\frac{\\partial u_x}{\\partial x} = \\frac{\\partial}{\\partial x}(\\alpha x^{2}) = 2\\alpha x$\n$(\\nabla \\mathbf{u})_{12} = \\frac{\\partial u_x}{\\partial y} = \\frac{\\partial}{\\partial y}(\\alpha x^{2}) = 0$\n$(\\nabla \\mathbf{u})_{13} = \\frac{\\partial u_x}{\\partial z} = \\frac{\\partial}{\\partial z}(\\alpha x^{2}) = 0$\n$(\\nabla \\mathbf{u})_{21} = \\frac{\\partial u_y}{\\partial x} = \\frac{\\partial}{\\partial x}(\\beta x y) = \\beta y$\n$(\\nabla \\mathbf{u})_{22} = \\frac{\\partial u_y}{\\partial y} = \\frac{\\partial}{\\partial y}(\\beta x y) = \\beta x$\n$(\\nabla \\mathbf{u})_{23} = \\frac{\\partial u_y}{\\partial z} = \\frac{\\partial}{\\partial z}(\\beta x y) = 0$\n$(\\nabla \\mathbf{u})_{31} = \\frac{\\partial u_z}{\\partial x} = \\frac{\\partial}{\\partial x}(\\gamma z) = 0$\n$(\\nabla \\mathbf{u})_{32} = \\frac{\\partial u_z}{\\partial y} = \\frac{\\partial}{\\partial y}(\\gamma z) = 0$\n$(\\nabla \\mathbf{u})_{33} = \\frac{\\partial u_z}{\\partial z} = \\frac{\\partial}{\\partial z}(\\gamma z) = \\gamma$\n\nAssembling these components into a matrix gives the displacement gradient:\n$$ \\nabla \\mathbf{u} = \\begin{pmatrix} 2\\alpha x & 0 & 0 \\\\ \\beta y & \\beta x & 0 \\\\ 0 & 0 & \\gamma \\end{pmatrix} $$\nThe infinitesimal strain tensor $\\boldsymbol{\\varepsilon}$ is the symmetric part of $\\nabla \\mathbf{u}$:\n$$ \\boldsymbol{\\varepsilon} = \\frac{1}{2}\\left(\\nabla \\mathbf{u} + (\\nabla \\mathbf{u})^{T}\\right) = \\frac{1}{2}\\left( \\begin{pmatrix} 2\\alpha x & 0 & 0 \\\\ \\beta y & \\beta x & 0 \\\\ 0 & 0 & \\gamma \\end{pmatrix} + \\begin{pmatrix} 2\\alpha x & \\beta y & 0 \\\\ 0 & \\beta x & 0 \\\\ 0 & 0 & \\gamma \\end{pmatrix} \\right) $$\n$$ \\boldsymbol{\\varepsilon} = \\frac{1}{2} \\begin{pmatrix} 4\\alpha x & \\beta y & 0 \\\\ \\beta y & 2\\beta x & 0 \\\\ 0 & 0 & 2\\gamma \\end{pmatrix} = \\begin{pmatrix} 2\\alpha x & \\frac{1}{2}\\beta y & 0 \\\\ \\frac{1}{2}\\beta y & \\beta x & 0 \\\\ 0 & 0 & \\gamma \\end{pmatrix} $$\nThe infinitesimal spin tensor $\\boldsymbol{\\omega}$ is the skew-symmetric part of $\\nabla \\mathbf{u}$:\n$$ \\boldsymbol{\\omega} = \\frac{1}{2}\\left(\\nabla \\mathbf{u} - (\\nabla \\mathbf{u})^{T}\\right) = \\frac{1}{2}\\left( \\begin{pmatrix} 2\\alpha x & 0 & 0 \\\\ \\beta y & \\beta x & 0 \\\\ 0 & 0 & \\gamma \\end{pmatrix} - \\begin{pmatrix} 2\\alpha x & \\beta y & 0 \\\\ 0 & \\beta x & 0 \\\\ 0 & 0 & \\gamma \\end{pmatrix} \\right) $$\n$$ \\boldsymbol{\\omega} = \\frac{1}{2} \\begin{pmatrix} 0 & -\\beta y & 0 \\\\ \\beta y & 0 & 0 \\\\ 0 & 0 & 0 \\end{pmatrix} = \\begin{pmatrix} 0 & -\\frac{1}{2}\\beta y & 0 \\\\ \\frac{1}{2}\\beta y & 0 & 0 \\\\ 0 & 0 & 0 \\end{pmatrix} $$\n\nPart $2$: Verification of continuum mechanics identities.\n\nFirst, compute the divergence of the displacement field, $\\nabla \\cdot \\mathbf{u}$:\n$$ \\nabla \\cdot \\mathbf{u} = \\frac{\\partial u_x}{\\partial x} + \\frac{\\partial u_y}{\\partial y} + \\frac{\\partial u_z}{\\partial z} = 2\\alpha x + \\beta x + \\gamma = (2\\alpha + \\beta)x + \\gamma $$\nNext, compute the trace of the strain tensor, $\\operatorname{tr}(\\boldsymbol{\\varepsilon})$:\n$$ \\operatorname{tr}(\\boldsymbol{\\varepsilon}) = \\varepsilon_{11} + \\varepsilon_{22} + \\varepsilon_{33} = 2\\alpha x + \\beta x + \\gamma = (2\\alpha + \\beta)x + \\gamma $$\nComparing the two results, we verify that $\\operatorname{tr}(\\boldsymbol{\\varepsilon}) = \\nabla \\cdot \\mathbf{u}$.\n\nNext, compute the curl of the displacement field, $\\nabla \\times \\mathbf{u}$:\n$$ \\nabla \\times \\mathbf{u} = \\begin{vmatrix} \\mathbf{e}_x & \\mathbf{e}_y & \\mathbf{e}_z \\\\ \\frac{\\partial}{\\partial x} & \\frac{\\partial}{\\partial y} & \\frac{\\partial}{\\partial z} \\\\ \\alpha x^{2} & \\beta x y & \\gamma z \\end{vmatrix} = \\left(\\frac{\\partial(\\gamma z)}{\\partial y} - \\frac{\\partial(\\beta x y)}{\\partial z}\\right)\\mathbf{e}_x - \\left(\\frac{\\partial(\\gamma z)}{\\partial x} - \\frac{\\partial(\\alpha x^2)}{\\partial z}\\right)\\mathbf{e}_y + \\left(\\frac{\\partial(\\beta x y)}{\\partial x} - \\frac{\\partial(\\alpha x^2)}{\\partial y}\\right)\\mathbf{e}_z $$\n$$ \\nabla \\times \\mathbf{u} = (0 - 0)\\mathbf{e}_x - (0 - 0)\\mathbf{e}_y + (\\beta y - 0)\\mathbf{e}_z = \\beta y \\mathbf{e}_z = \\begin{pmatrix} 0 \\\\ 0 \\\\ \\beta y \\end{pmatrix} $$\nThe axial vector $\\boldsymbol{\\omega}_{\\text{ax}}$ of the skew-symmetric tensor $\\boldsymbol{\\omega}$ has components $w_k = -\\frac{1}{2}\\epsilon_{ijk}\\omega_{ij}$, where $\\epsilon_{ijk}$ is the Levi-Civita symbol.\n$w_x = -\\omega_{23} = 0$\n$w_y = \\omega_{13} = 0$\n$w_z = -\\omega_{12} = -(-\\frac{1}{2}\\beta y) = \\frac{1}{2}\\beta y$\nThus, the axial vector is $\\boldsymbol{\\omega}_{\\text{ax}} = \\begin{pmatrix} 0 \\\\ 0 \\\\ \\frac{1}{2}\\beta y \\end{pmatrix}$.\nWe are asked to verify that $\\boldsymbol{\\omega}_{\\text{ax}} = \\frac{1}{2}\\nabla \\times \\mathbf{u}$.\n$$ \\frac{1}{2}\\nabla \\times \\mathbf{u} = \\frac{1}{2} \\begin{pmatrix} 0 \\\\ 0 \\\\ \\beta y \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\\\ \\frac{1}{2}\\beta y \\end{pmatrix} $$\nThe identity $\\boldsymbol{\\omega}_{\\text{ax}} = \\frac{1}{2}\\nabla \\times \\mathbf{u}$ is thus explicitly verified for the given displacement field.\n\nPart $3$: Calculation of the scalar invariant $S(x,y,z)$.\n\nThe scalar invariant is defined as $S(x,y,z) := \\operatorname{tr}(\\boldsymbol{\\varepsilon}) + \\|\\boldsymbol{\\omega}_{\\text{ax}}\\|_{2}$.\nFrom Part $2$, we have $\\operatorname{tr}(\\boldsymbol{\\varepsilon}) = (2\\alpha + \\beta)x + \\gamma$.\nThe Euclidean norm of the axial vector $\\boldsymbol{\\omega}_{\\text{ax}}$ is:\n$$ \\|\\boldsymbol{\\omega}_{\\text{ax}}\\|_{2} = \\sqrt{w_x^2 + w_y^2 + w_z^2} = \\sqrt{0^2 + 0^2 + \\left(\\frac{1}{2}\\beta y\\right)^2} = \\sqrt{\\left(\\frac{1}{2}\\beta y\\right)^2} = \\left|\\frac{1}{2}\\beta y\\right| $$\nSubstituting these expressions into the definition of $S(x,y,z)$:\n$$ S(x,y,z) = (2\\alpha + \\beta)x + \\gamma + \\left|\\frac{1}{2}\\beta y\\right| $$\n\nBrief comment on spatial variation and plausibility:\nThe components of the strain tensor $\\boldsymbol{\\varepsilon}$ and spin tensor $\\boldsymbol{\\omega}$ are functions of the spatial coordinates $x$ and $y$, indicating a non-homogeneous deformation. The volumetric strain, $\\operatorname{tr}(\\boldsymbol{\\varepsilon})$, varies linearly with $x$, implying that slices of the material at different $x$ coordinates expand or contract by different amounts. The local rotation, represented by $\\boldsymbol{\\omega}_{\\text{ax}}$, varies linearly with $y$ and is always directed along the $z$-axis.\nThe small-strain hypothesis requires that the magnitudes of the components of the displacement gradient tensor $\\nabla \\mathbf{u}$ are much less than $1$, i.e., $|\\nabla \\mathbf{u}_{ij}| \\ll 1$. Since components such as $(\\nabla \\mathbf{u})_{11}=2\\alpha x$ and $(\\nabla \\mathbf{u})_{21}=\\beta y$ grow linearly with the coordinates, this assumption can only hold true in a sufficiently small region around the origin $(0,0,0)$. This displacement field is therefore only physically tenable as a local approximation of a deformation in a small material neighborhood.",
            "answer": "$$\n\\boxed{(2\\alpha + \\beta)x + \\gamma + \\frac{1}{2}|\\beta y|}\n$$"
        },
        {
            "introduction": "Vector calculus provides identities that serve as powerful consistency checks in computational modeling. A cornerstone identity is that the curl of the gradient of any smooth scalar field is identically zero ($\\nabla \\times \\nabla f = \\mathbf{0}$), signifying that gradient fields are irrotational. This exercise  first has you verify this theorem analytically, then challenges you to consider its profound implications for numerical methods like FEM, where this identity's violation can signal non-physical numerical artifacts.",
            "id": "3568747",
            "problem": "Consider a gradient-damage regularization posed on a bounded open domain $\\Omega \\subset \\mathbb{R}^{3}$, where the damage field $d(\\mathbf{x})$ is treated as a non-dimensional scalar and is assumed sufficiently smooth. Let\n$$\nd(x,y,z) \\;=\\; \\alpha\\, x^{3}y^{2} \\;+\\; \\beta\\, x y z \\;+\\; \\gamma\\, \\sin(xy) \\;+\\; \\delta\\, \\cos(z),\n$$\nwith $\\alpha,\\beta,\\gamma,\\delta \\in \\mathbb{R}$ constants and $(x,y,z) \\in \\Omega$. You will investigate a consistency diagnostic relevant to computational implementations of gradient-damage models by analyzing the quantity $\\nabla \\times \\nabla d$.\n\nTasks:\n\n1. Starting strictly from the component-wise definitions of the gradient and the curl operators in $\\mathbb{R}^{3}$, compute $\\nabla \\times \\nabla d$ for the above $d(x,y,z)$. In your derivation, use only the equality of mixed second partial derivatives for sufficiently smooth functions as a fundamental fact. State the minimal smoothness assumptions on $d$ under which your simplification is valid.\n\n2. Define the scalar diagnostic\n$$\nJ \\;=\\; \\int_{\\Omega} \\left| \\nabla \\times \\nabla d(\\mathbf{x}) \\right|^{2} \\, \\mathrm{d}\\Omega.\n$$\nUsing your result from Task 1, evaluate $J$ exactly for the given $d(x,y,z)$ on any bounded $\\Omega$ and interpret the result physically for a consistent gradient-damage computation.\n\n3. Briefly explain how, in a finite element method (FEM) implementation with $C^0$ piecewise-linear interpolants for $d_h$ on a tetrahedral mesh, the classical (element-wise) evaluation of $\\nabla \\times \\nabla d_h$ might fail to reveal numerical artifacts, and indicate—using first principles—where nonzero contributions originate in the distributional sense.\n\nInstructions for the final numeric report: Treat all quantities as non-dimensional. Express the final value of $J$ as an exact number with no rounding. Provide no units for the final reported value.",
            "solution": "### Task 1: Computation of $\\nabla \\times \\nabla d$\n\nThe gradient and curl operators in a Cartesian coordinate system $(x,y,z)$ are defined as:\n$$\n\\nabla f = \\frac{\\partial f}{\\partial x}\\hat{\\mathbf{i}} + \\frac{\\partial f}{\\partial y}\\hat{\\mathbf{j}} + \\frac{\\partial f}{\\partial z}\\hat{\\mathbf{k}}\n$$\n$$\n\\nabla \\times \\mathbf{F} = \\left( \\frac{\\partial F_z}{\\partial y} - \\frac{\\partial F_y}{\\partial z} \\right) \\hat{\\mathbf{i}} + \\left( \\frac{\\partial F_x}{\\partial z} - \\frac{\\partial F_z}{\\partial x} \\right) \\hat{\\mathbf{j}} + \\left( \\frac{\\partial F_y}{\\partial x} - \\frac{\\partial F_x}{\\partial y} \\right) \\hat{\\mathbf{k}}\n$$\nwhere $f$ is a scalar field and $\\mathbf{F} = F_x \\hat{\\mathbf{i}} + F_y \\hat{\\mathbf{j}} + F_z \\hat{\\mathbf{k}}$ is a vector field.\n\nWe are asked to compute $\\nabla \\times (\\nabla d)$. Let the vector field $\\mathbf{F}$ be the gradient of the scalar field $d$, i.e., $\\mathbf{F} = \\nabla d$. The components of $\\mathbf{F}$ are:\n$$\nF_x = \\frac{\\partial d}{\\partial x}, \\quad F_y = \\frac{\\partial d}{\\partial y}, \\quad F_z = \\frac{\\partial d}{\\partial z}\n$$\nSubstituting these into the definition of the curl, we obtain the general expression for the curl of a gradient:\n$$\n\\nabla \\times (\\nabla d) = \\left( \\frac{\\partial}{\\partial y}\\left(\\frac{\\partial d}{\\partial z}\\right) - \\frac{\\partial}{\\partial z}\\left(\\frac{\\partial d}{\\partial y}\\right) \\right) \\hat{\\mathbf{i}} + \\left( \\frac{\\partial}{\\partial z}\\left(\\frac{\\partial d}{\\partial x}\\right) - \\frac{\\partial}{\\partial x}\\left(\\frac{\\partial d}{\\partial z}\\right) \\right) \\hat{\\mathbf{j}} + \\left( \\frac{\\partial}{\\partial x}\\left(\\frac{\\partial d}{\\partial y}\\right) - \\frac{\\partial}{\\partial y}\\left(\\frac{\\partial d}{\\partial x}\\right) \\right) \\hat{\\mathbf{k}}\n$$\nThis can be written using subscript notation for partial derivatives as:\n$$\n\\nabla \\times (\\nabla d) = (d_{zy} - d_{yz})\\hat{\\mathbf{i}} + (d_{xz} - d_{zx})\\hat{\\mathbf{j}} + (d_{yx} - d_{xy})\\hat{\\mathbf{k}}\n$$\nThe problem states to use the equality of mixed second partial derivatives for sufficiently smooth functions. This is Clairaut's theorem, which states that if a function $d$ has continuous second partial derivatives in a neighborhood of a point, then the order of differentiation does not matter, i.e., $\\frac{\\partial^2 d}{\\partial x_i \\partial x_j} = \\frac{\\partial^2 d}{\\partial x_j \\partial x_i}$. The minimal smoothness assumption for this theorem to hold is that the function $d$ must be of class $C^2$ (its second-order partial derivatives exist and are continuous).\n\nThe given damage field $d(x,y,z) = \\alpha\\, x^{3}y^{2} + \\beta\\, x y z + \\gamma\\, \\sin(xy) + \\delta\\, \\cos(z)$ is composed of polynomials and trigonometric functions sin and cos. These functions are infinitely differentiable ($C^{\\infty}$) over all of $\\mathbb{R}^3$. Thus, the function $d$ is of class $C^{\\infty}$, which is much smoother than the required $C^2$ condition.\n\nTherefore, for the given function $d$:\n$$\n\\frac{\\partial^2 d}{\\partial y \\partial z} = \\frac{\\partial^2 d}{\\partial z \\partial y}, \\quad \\frac{\\partial^2 d}{\\partial z \\partial x} = \\frac{\\partial^2 d}{\\partial x \\partial z}, \\quad \\frac{\\partial^2 d}{\\partial x \\partial y} = \\frac{\\partial^2 d}{\\partial y \\partial x}\n$$\nThis implies that each component of $\\nabla \\times (\\nabla d)$ is zero.\n$$\n\\nabla \\times (\\nabla d) = (0)\\hat{\\mathbf{i}} + (0)\\hat{\\mathbf{j}} + (0)\\hat{\\mathbf{k}} = \\mathbf{0}\n$$\nThis is a general result for any $C^2$ scalar field, often summarized by the vector identity $\\nabla \\times \\nabla d \\equiv \\mathbf{0}$. The computation for the specific $d(x,y,z)$ provided merely serves as a concrete verification of this identity.\n\nTo be explicit, let us compute the derivatives for the given $d$:\nFirst, the gradient $\\nabla d$:\n$$\n\\frac{\\partial d}{\\partial x} = 3\\alpha x^2 y^2 + \\beta y z + \\gamma y \\cos(xy)\n$$\n$$\n\\frac{\\partial d}{\\partial y} = 2\\alpha x^3 y + \\beta x z + \\gamma x \\cos(xy)\n$$\n$$\n\\frac{\\partial d}{\\partial z} = \\beta x y - \\delta \\sin(z)\n$$\nNow, the mixed second partial derivatives for the z-component of the curl:\n$$\n\\frac{\\partial}{\\partial x}\\left(\\frac{\\partial d}{\\partial y}\\right) = \\frac{\\partial}{\\partial x}(2\\alpha x^3 y + \\beta x z + \\gamma x \\cos(xy)) = 6\\alpha x^2 y + \\beta z + \\gamma \\cos(xy) - \\gamma xy \\sin(xy)\n$$\n$$\n\\frac{\\partial}{\\partial y}\\left(\\frac{\\partial d}{\\partial x}\\right) = \\frac{\\partial}{\\partial y}(3\\alpha x^2 y^2 + \\beta y z + \\gamma y \\cos(xy)) = 6\\alpha x^2 y + \\beta z + \\gamma \\cos(xy) - \\gamma xy \\sin(xy)\n$$\nThese are equal, so the z-component is zero. The equality of the other pairs of mixed partials follows similarly.\n\n### Task 2: Evaluation and Interpretation of $J$\n\nThe scalar diagnostic is defined as:\n$$\nJ = \\int_{\\Omega} \\left| \\nabla \\times \\nabla d(\\mathbf{x}) \\right|^{2} \\, \\mathrm{d}\\Omega\n$$\nFrom the result of Task 1, we established that for the given sufficiently smooth scalar field $d(x,y,z)$, the quantity $\\nabla \\times \\nabla d$ is identically the zero vector, $\\mathbf{0}$.\n$$\n\\nabla \\times \\nabla d(\\mathbf{x}) = \\mathbf{0} \\quad \\forall \\mathbf{x} \\in \\Omega\n$$\nSubstituting this into the definition of $J$:\n$$\nJ = \\int_{\\Omega} |\\mathbf{0}|^{2} \\, \\mathrm{d}\\Omega = \\int_{\\Omega} 0 \\, \\mathrm{d}\\Omega\n$$\nThe integral of zero over any bounded domain $\\Omega$ is zero.\n$$\nJ = 0\n$$\nPhysical Interpretation: The identity $\\nabla \\times \\nabla d = \\mathbf{0}$ means that any vector field that can be expressed as the gradient of a scalar potential (a conservative field) is irrotational (has zero curl). In the context of continuum mechanics, this is a fundamental consistency condition. The integral $J$ represents the total squared magnitude of the \"inconsistency\" over the domain $\\Omega$. A value of $J=0$ indicates perfect consistency. In a computational implementation, differential operators are approximated. Due to discretization error, the numerical approximation of the curl of the numerical gradient, $\\nabla_h \\times \\nabla_h d_h$, may not be exactly zero. Therefore, $J$ serves as a powerful diagnostic tool: a non-zero value of $J$ in a simulation indicates that the numerical scheme fails to preserve this fundamental vector identity and signals a loss of consistency in the computation. A robust numerical method for gradient-damage models should ensure that $J$ is zero, or at least approaches zero under mesh refinement at an appropriate rate.\n\n### Task 3: Finite Element Method (FEM) Implementation\n\nIn an FEM implementation with $C^0$ piecewise-linear interpolants for the damage field $d$ on a tetrahedral mesh, the discrete approximation is denoted $d_h(\\mathbf{x})$.\n1.  **$C^0$ Continuity and Piecewise Linearity**: $C^0$ continuity means the function $d_h$ is continuous across the faces of adjacent tetrahedra, but its derivatives (i.e., its gradient) are not guaranteed to be continuous. Within a single tetrahedron (element $e$), a linear interpolant has the form $d_h(\\mathbf{x}) = a_e + b_e x + c_e y + f_e z$, where the coefficients are constant for that element.\n2.  **Element-wise Gradient**: The gradient of $d_h$ within an element $e$ is $\\nabla d_h(\\mathbf{x}) = b_e \\hat{\\mathbf{i}} + c_e \\hat{\\mathbf{j}} + f_e \\hat{\\mathbf{k}}$. This is a constant vector field within each element.\n3.  **Classical Element-wise Curl**: The curl of any constant vector field is identically zero. Therefore, if one computes $\\nabla \\times (\\nabla d_h)$ by applying the curl operator *inside* each element, the result is $\\mathbf{0}$ everywhere within the interior of all elements. This is the \"classical (element-wise) evaluation\" mentioned in the problem. This evaluation is misleading because it completely misses the behavior at the element interfaces and would erroneously suggest perfect consistency ($J=0$).\n4.  **Distributional Origin of Non-zero Contributions**: The field $\\nabla d_h$ is a *piecewise-constant* vector field. It is constant within each tetrahedron but typically has a jump discontinuity across the shared faces of adjacent tetrahedra. The theory of distributions provides the framework for differentiating such functions. The derivative of a function with a jump discontinuity contains a Dirac delta function supported on the surface of the jump.\n5.  **Curl in the Distributional Sense**: Let's consider a face $S_{ij}$ with unit normal $\\mathbf{n}$ shared by two elements, $e_i$ and $e_j$. The gradient vectors in these elements are constant but different: $\\mathbf{g}_i = (\\nabla d_h)|_{e_i}$ and $\\mathbf{g}_j = (\\nabla d_h)|_{e_j}$. The jump in the gradient across the face is $[\\![\\nabla d_h]\\!] = \\mathbf{g}_j - \\mathbf{g}_i$. The curl of the discontinuous field $\\nabla d_h$ is not zero in the distributional sense. It contains a singular part that is concentrated on the mesh faces. This singular part can be expressed (using a generalized Stokes' theorem) as:\n$$\n(\\nabla \\times \\nabla d_h)_{\\text{singular}} = \\sum_{\\text{faces } S_{ij}} (\\mathbf{n} \\times [\\![\\nabla d_h]\\!]) \\delta_S\n$$\nwhere $\\delta_S$ is a surface Dirac delta distribution. The term $\\mathbf{n} \\times [\\![\\nabla d_h]\\!]$ represents the jump in the tangential component of the gradient field across the face.\n6.  **Conclusion**: The non-zero contributions to the true, distributional $\\nabla \\times \\nabla d_h$ originate from the jump discontinuities of the gradient field $\\nabla d_h$ at the inter-element faces. An element-wise evaluation is blind to this, as it only sees the constant (and thus curl-free) field inside the elements. The failure of $C^0$ elements to enforce continuity of the gradient is what creates this numerical artifact, leading to a non-zero value of $J$ if it were computed correctly in a way that accounts for these inter-element contributions. This is a primary motivation for using higher-order elements or mixed finite element methods in problems where gradient or curl conformity is crucial.",
            "answer": "$$\n\\boxed{0}\n$$"
        },
        {
            "introduction": "The divergence theorem is a foundational principle linking a field's behavior within a volume to its flux across the enclosing surface. In solid mechanics, it relates the divergence of the stress tensor (representing internal force sources) to the traction vector on the boundary. This computational practice  moves from theory to application, challenging you to write code that numerically validates this theorem for a complex, heterogeneous material, providing direct insight into the interplay between physical laws and numerical accuracy.",
            "id": "3568743",
            "problem": "Consider the validation of the divergence theorem (Gauss’ theorem) for a second-order tensor field in two dimensions within small-strain, isotropic, linear elasticity under plane strain kinematics. The divergence theorem for a second-order tensor field states that for a bounded, sufficiently smooth domain $\\Omega \\subset \\mathbb{R}^2$ with boundary $\\partial \\Omega$ and outward unit normal $\\mathbf{n}$, the following identity holds:\n$$\n\\int_{\\Omega} \\nabla \\cdot \\boldsymbol{\\sigma} \\, d\\Omega \\;=\\; \\int_{\\partial \\Omega} \\boldsymbol{\\sigma} \\, \\mathbf{n} \\, dS,\n$$\nwhere $\\boldsymbol{\\sigma}(x,y)$ is the Cauchy stress tensor and $\\nabla \\cdot \\boldsymbol{\\sigma}$ is the divergence of $\\boldsymbol{\\sigma}$ taken row-wise (producing a vector field). The goal is to compute both integrals numerically and compare them under heterogeneous material properties reconstructed from a prescribed displacement field.\n\nUse the following modeling assumptions and definitions as the fundamental base:\n- Small-strain kinematics: the infinitesimal strain tensor $\\boldsymbol{\\varepsilon}$ is defined by\n$$\n\\boldsymbol{\\varepsilon} \\;=\\; \\frac{1}{2}\\left( \\nabla \\mathbf{u} + (\\nabla \\mathbf{u})^{\\top} \\right),\n$$\nwith displacement field $\\mathbf{u} = [u(x,y), v(x,y)]^{\\top}$.\n- Isotropic linear elasticity in plane strain: the stress–strain relation is\n$$\n\\boldsymbol{\\sigma} \\;=\\; \\lambda \\, \\mathrm{tr}(\\boldsymbol{\\varepsilon}) \\, \\mathbf{I} \\;+\\; 2\\mu \\, \\boldsymbol{\\varepsilon},\n$$\nwhere $\\mathrm{tr}(\\boldsymbol{\\varepsilon})$ is the trace of $\\boldsymbol{\\varepsilon}$, $\\mathbf{I}$ is the identity tensor, and $\\lambda(x,y)$ and $\\mu(x,y)$ are the position-dependent Lamé parameters defined via Young’s modulus $E(x,y)$ and Poisson’s ratio $\\nu(x,y)$ by\n$$\n\\mu \\;=\\; \\frac{E}{2(1+\\nu)}, \\qquad \\lambda \\;=\\; \\frac{E\\nu}{(1+\\nu)(1-2\\nu)}.\n$$\n- The divergence operator acting on $\\boldsymbol{\\sigma}$ yields a vector field\n$$\n\\nabla \\cdot \\boldsymbol{\\sigma} \\;=\\; \\begin{bmatrix}\n\\frac{\\partial \\sigma_{xx}}{\\partial x} + \\frac{\\partial \\sigma_{xy}}{\\partial y} \\\\\n\\frac{\\partial \\sigma_{yx}}{\\partial x} + \\frac{\\partial \\sigma_{yy}}{\\partial y}\n\\end{bmatrix}.\n$$\n\nLet the computational domain be the unit square\n$$\n\\Omega \\;=\\; [0,1]\\times[0,1],\n$$\nwith boundary $\\partial \\Omega$ composed of four edges with outward unit normals given by\n$$\n\\mathbf{n}_{\\text{left}} = [-1,0]^{\\top},\\quad \\mathbf{n}_{\\text{right}} = [1,0]^{\\top},\\quad \\mathbf{n}_{\\text{bottom}} = [0,-1]^{\\top},\\quad \\mathbf{n}_{\\text{top}} = [0,1]^{\\top}.\n$$\n\nPrescribe two displacement fields to reconstruct $\\boldsymbol{\\sigma}(x,y)$:\n1. A smooth, non-polynomial field to exercise heterogeneous elasticity:\n$$\nu(x,y) \\;=\\; \\sin(\\pi x)\\sin(\\pi y) \\;+\\; 0.1\\,x^2, \\qquad v(x,y) \\;=\\; \\cos(\\pi x)\\sin(\\pi y) \\;+\\; 0.05\\, x y.\n$$\n2. A linear field for a constant-stress baseline:\n$$\nu(x,y) \\;=\\; \\alpha x, \\qquad v(x,y) \\;=\\; \\beta y,\n$$\nwith constants $\\alpha = 0.3$ and $\\beta = -0.2$.\n\nPrescribe heterogeneous material properties for the general case:\n$$\nE(x,y) \\;=\\; E_0 \\left( 1 \\;+\\; 0.3\\, x \\;+\\; 0.2\\, y \\;+\\; 0.1 \\sin(2\\pi x)\\cos(2\\pi y) \\right), \\qquad E_0 \\;=\\; 1000,\n$$\n$$\n\\nu(x,y) \\;=\\; \\nu_0 \\;+\\; 0.05 \\sin(\\pi x)\\sin(\\pi y), \\qquad \\nu_0 \\;=\\; 0.3,\n$$\nand for the baseline case use constant $E(x,y) = E_0$ and $\\nu(x,y) = \\nu_0$. All trigonometric functions use radians.\n\nCompute the following two vector-valued integrals numerically:\n- The volume integral of the divergence:\n$$\n\\mathbf{I}_{\\Omega} \\;=\\; \\int_{\\Omega} \\nabla \\cdot \\boldsymbol{\\sigma} \\, d\\Omega,\n$$\n- The boundary integral of the traction:\n$$\n\\mathbf{I}_{\\partial \\Omega} \\;=\\; \\int_{\\partial \\Omega} \\boldsymbol{\\sigma}\\, \\mathbf{n} \\, dS \\;=\\; \\sum_{\\text{edges}} \\int_{\\text{edge}} \\boldsymbol{\\sigma}\\, \\mathbf{n}_{\\text{edge}} \\, d\\ell.\n$$\n\nUse tensor calculus definitions and the chain rule to evaluate $\\nabla \\cdot \\boldsymbol{\\sigma}$ analytically from the prescribed $\\mathbf{u}(x,y)$ and spatially varying $\\lambda(x,y)$ and $\\mu(x,y)$, and then perform numerical quadrature to approximate the integrals. For quadrature, use tensor-product Gauss–Legendre quadrature of order $q_{\\Omega}$ over $\\Omega$ and one-dimensional Gauss–Legendre quadrature of order $q_{\\partial \\Omega}$ on each edge of $\\partial \\Omega$, both mapped to $[0,1]$.\n\nDesign a program that, for specified parameter sets, computes the absolute error norm\n$$\n\\varepsilon \\;=\\; \\left\\| \\mathbf{I}_{\\Omega} \\;-\\; \\mathbf{I}_{\\partial \\Omega} \\right\\|_2,\n$$\nwhere $\\|\\cdot\\|_2$ denotes the Euclidean norm. The program must implement the above constitutive relations and kinematics exactly and assess the effect of quadrature orders.\n\nTest Suite:\n- Case $1$: heterogeneous $E(x,y), \\nu(x,y)$ with the smooth displacement field, $q_{\\Omega} = 5$, $q_{\\partial \\Omega} = 5$.\n- Case $2$: heterogeneous $E(x,y), \\nu(x,y)$ with the smooth displacement field, $q_{\\Omega} = 1$, $q_{\\partial \\Omega} = 1$.\n- Case $3$: heterogeneous $E(x,y), \\nu(x,y)$ with the smooth displacement field, $q_{\\Omega} = 10$, $q_{\\partial \\Omega} = 10$.\n- Case $4$: constant $E(x,y) = E_0$, constant $\\nu(x,y) = \\nu_0$ with the linear displacement field ($\\alpha = 0.3$, $\\beta = -0.2$), $q_{\\Omega} = 2$, $q_{\\partial \\Omega} = 2$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of Cases $1$ through $4$, for example, $[\\varepsilon_1,\\varepsilon_2,\\varepsilon_3,\\varepsilon_4]$. All values are dimensionless. All trigonometric evaluations must be in radians. No user input should be required; the program must run as-is.",
            "solution": "### Solution Derivation\nThe solution requires implementing the mathematical model and numerical integration routines as described. The core of the task is to compute the integrands for the volume and boundary integrals.\n\n#### Integrand for the Volume Integral\nThe volume integral is $\\mathbf{I}_{\\Omega} = \\int_{\\Omega} \\nabla \\cdot \\boldsymbol{\\sigma} d\\Omega$. The integrand is the vector field $\\nabla \\cdot \\boldsymbol{\\sigma}$, whose components are:\n$$\n(\\nabla \\cdot \\boldsymbol{\\sigma})_x = \\frac{\\partial \\sigma_{xx}}{\\partial x} + \\frac{\\partial \\sigma_{xy}}{\\partial y}\n$$\n$$\n(\\nabla \\cdot \\boldsymbol{\\sigma})_y = \\frac{\\partial \\sigma_{yx}}{\\partial x} + \\frac{\\partial \\sigma_{yy}}{\\partial y}\n$$\nGiven that the material properties $\\lambda(x,y)$ and $\\mu(x,y)$ are spatially variable, the chain rule must be applied to differentiate the stress components:\n$$\n\\sigma_{xx} = \\lambda(\\varepsilon_{xx} + \\varepsilon_{yy}) + 2\\mu\\varepsilon_{xx}\n$$\n$$\n\\sigma_{yy} = \\lambda(\\varepsilon_{xx} + \\varepsilon_{yy}) + 2\\mu\\varepsilon_{yy}\n$$\n$$\n\\sigma_{xy} = \\sigma_{yx} = 2\\mu\\varepsilon_{xy}\n$$\nThe derivatives become:\n$$\n\\frac{\\partial \\sigma_{xx}}{\\partial x} = \\frac{\\partial \\lambda}{\\partial x}\\mathrm{tr}(\\boldsymbol{\\varepsilon}) + \\lambda \\frac{\\partial \\mathrm{tr}(\\boldsymbol{\\varepsilon})}{\\partial x} + 2\\frac{\\partial \\mu}{\\partial x}\\varepsilon_{xx} + 2\\mu \\frac{\\partial \\varepsilon_{xx}}{\\partial x}\n$$\n$$\n\\frac{\\partial \\sigma_{xy}}{\\partial y} = 2\\frac{\\partial \\mu}{\\partial y}\\varepsilon_{xy} + 2\\mu \\frac{\\partial \\varepsilon_{xy}}{\\partial y}\n$$\nAnd similarly for the $y$-component of the divergence. This requires computing first derivatives of the Lamé parameters and first derivatives of the strain components. The derivatives of strain (e.g., $\\partial \\varepsilon_{xx} / \\partial x$) in turn require second derivatives of the displacement field components $u(x,y)$ and $v(x,y)$. The derivatives of the Lamé parameters (e.g., $\\partial \\lambda / \\partial x$) require first derivatives of $E(x,y)$ and $\\nu(x,y)$. All these elemental functions and their derivatives are provided or can be derived analytically. The implementation will systematically compute all these quantities at each quadrature point.\n\n#### Integrand for the Boundary Integral\nThe boundary integral is $\\mathbf{I}_{\\partial \\Omega} = \\int_{\\partial \\Omega} \\mathbf{t} dS$, where $\\mathbf{t} = \\boldsymbol{\\sigma}\\mathbf{n}$ is the traction vector. This is computed as a sum of integrals over the four edges of the unit square:\n$$\n\\mathbf{I}_{\\partial\\Omega} = \\int_0^1 \\begin{bmatrix} \\sigma_{xx}(1,y) \\\\ \\sigma_{yx}(1,y) \\end{bmatrix} dy + \\int_0^1 \\begin{bmatrix} -\\sigma_{xx}(0,y) \\\\ -\\sigma_{yx}(0,y) \\end{bmatrix} dy + \\int_0^1 \\begin{bmatrix} \\sigma_{xy}(x,1) \\\\ \\sigma_{yy}(x,1) \\end{bmatrix} dx + \\int_0^1 \\begin{bmatrix} -\\sigma_{xy}(x,0) \\\\ -\\sigma_{yy}(x,0) \\end{bmatrix} dx\n$$\nThe integrands here are the components of the stress tensor $\\boldsymbol{\\sigma}$, evaluated on the boundary. This requires computing the displacements and their first derivatives to find the strain $\\boldsymbol{\\varepsilon}$, and the material properties $E$ and $\\nu$ to find $\\lambda$ and $\\mu$, all evaluated at the boundary quadrature points.\n\n#### Numerical Quadrature\nBoth integrals are approximated using Gauss-Legendre quadrature. For a 1D integral $\\int_0^1 f(z) dz$, the approximation is:\n$$\n\\int_0^1 f(z) dz \\approx \\frac{1}{2} \\sum_{i=1}^{q} w_i f\\left(\\frac{\\xi_i+1}{2}\\right)\n$$\nwhere $(\\xi_i, w_i)$ are the Gauss points and weights on $[-1, 1]$.\nFor the 2D volume integral over $[0,1]\\times[0,1]$, a tensor product rule is used:\n$$\n\\int_0^1 \\int_0^1 \\mathbf{g}(x,y) dx dy \\approx \\frac{1}{4} \\sum_{i=1}^{q_\\Omega} \\sum_{j=1}^{q_\\Omega} w_i w_j \\mathbf{g}\\left(\\frac{\\xi_i+1}{2}, \\frac{\\xi_j+1}{2}\\right)\n$$\nThe factors $\\frac{1}{2}$ and $\\frac{1}{4}$ are the Jacobians of the transformation from the canonical interval/square to the domain of integration.\n\n#### Program Structure\nThe implementation is structured as follows:\n1. A function `calculate_state(x, y, funcs)`: Takes a point $(x,y)$ and a dictionary of analytic functions `funcs` (for $u, v, E, \\nu$ and their derivatives). It computes and returns all necessary mechanical quantities at that point: the stress tensor $\\boldsymbol{\\sigma}$ and its divergence $\\nabla \\cdot \\boldsymbol{\\sigma}$. This modularizes the complex physics calculations.\n2. Functions `compute_volume_integral` and `compute_boundary_integral`: These implement the Gauss-Legendre quadrature schemes. They iterate over the Gauss points, call `calculate_state` to get the integrand values, and perform the weighted summation.\n3. A main `solve` function: Defines the specific parameters for each of the four test cases (including the dictionaries of analytic functions), calls the integration routines to compute $\\mathbf{I}_{\\Omega}$ and $\\mathbf{I}_{\\partial \\Omega}$, calculates the final error norm $\\varepsilon$, and formats the output.\n\nFor Case 4 (linear displacement, constant properties), the derivatives of strain and material properties are zero. This leads to $\\nabla \\cdot \\boldsymbol{\\sigma} = \\mathbf{0}$, so $\\mathbf{I}_{\\Omega} = \\mathbf{0}$. The boundary integral $\\mathbf{I}_{\\partial \\Omega}$ also evaluates to $\\mathbf{0}$ analytically. Therefore, the numerical error $\\varepsilon_4$ is expected to be close to machine zero, serving as a verification of the implementation's correctness. For the other cases, the error is expected to decrease as the quadrature order increases from Case 2 ($q=1$) to Case 1 ($q=5$) to Case 3 ($q=10$).",
            "answer": "```python\nimport numpy as np\n\ndef calculate_state(x, y, funcs):\n    \"\"\"\n    Computes all mechanical quantities at a point (x, y).\n\n    Args:\n        x (float): The x-coordinate.\n        y (float): The y-coordinate.\n        funcs (dict): A dictionary of lambda functions for u, v, E, nu\n                      and all their required partial derivatives.\n\n    Returns:\n        A dictionary containing the stress tensor 'sigma' (2x2 numpy array)\n        and the stress divergence 'div_sigma' (2-element numpy array).\n    \"\"\"\n    # Evaluate displacement derivatives at (x, y)\n    u_x = funcs['u_x'](x, y)\n    u_y = funcs['u_y'](x, y)\n    v_x = funcs['v_x'](x, y)\n    v_y = funcs['v_y'](x, y)\n    u_xx = funcs['u_xx'](x, y)\n    u_xy = funcs['u_xy'](x, y)\n    u_yy = funcs['u_yy'](x, y)\n    v_xx = funcs['v_xx'](x, y)\n    v_xy = funcs['v_xy'](x, y)\n    v_yy = funcs['v_yy'](x, y)\n\n    # Strain components and their derivatives\n    eps_xx = u_x\n    eps_yy = v_y\n    eps_xy = 0.5 * (u_y + v_x)\n    tr_eps = eps_xx + eps_yy\n\n    eps_xx_x = u_xx\n    eps_xx_y = u_xy\n    eps_yy_x = v_xy\n    eps_yy_y = v_yy\n    eps_xy_x = 0.5 * (u_xy + v_xx)\n    eps_xy_y = 0.5 * (u_yy + v_xy)\n\n    tr_eps_x = eps_xx_x + eps_yy_x\n    tr_eps_y = eps_xx_y + eps_yy_y\n\n    # Material properties and their derivatives\n    E = funcs['E'](x, y)\n    nu = funcs['nu'](x, y)\n    E_x = funcs['E_x'](x, y)\n    E_y = funcs['E_y'](x, y)\n    nu_x = funcs['nu_x'](x, y)\n    nu_y = funcs['nu_y'](x, y)\n\n    # Lame parameters and their derivatives\n    mu = E / (2.0 * (1.0 + nu))\n    # Plane strain lambda\n    lambda_ = (E * nu) / ((1.0 + nu) * (1.0 - 2.0 * nu))\n\n    mu_x = 0.5 * (E_x * (1.0 + nu) - E * nu_x) / (1.0 + nu)**2\n    mu_y = 0.5 * (E_y * (1.0 + nu) - E * nu_y) / (1.0 + nu)**2\n    \n    # Derivative of lambda\n    den_l = (1.0 + nu) * (1.0 - 2.0 * nu)\n    num_l = E * nu\n    den_l_x = (-1.0 - 4.0 * nu) * nu_x\n    den_l_y = (-1.0 - 4.0 * nu) * nu_y\n    num_l_x = E_x * nu + E * nu_x\n    num_l_y = E_y * nu + E * nu_y\n    lambda_x = (num_l_x * den_l - num_l * den_l_x) / den_l**2\n    lambda_y = (num_l_y * den_l - num_l * den_l_y) / den_l**2\n\n    # Stress tensor (sigma)\n    sigma_xx = lambda_ * tr_eps + 2.0 * mu * eps_xx\n    sigma_yy = lambda_ * tr_eps + 2.0 * mu * eps_yy\n    sigma_xy = 2.0 * mu * eps_xy\n    sigma = np.array([[sigma_xx, sigma_xy], [sigma_xy, sigma_yy]])\n\n    # Stress divergence (div_sigma)\n    sigma_xx_x = lambda_x * tr_eps + lambda_ * tr_eps_x + 2.0 * mu_x * eps_xx + 2.0 * mu * eps_xx_x\n    sigma_xy_y = 2.0 * mu_y * eps_xy + 2.0 * mu * eps_xy_y\n    div_sigma_x = sigma_xx_x + sigma_xy_y\n\n    sigma_yx_x = 2.0 * mu_x * eps_xy + 2.0 * mu * eps_xy_x\n    sigma_yy_y = lambda_y * tr_eps + lambda_ * tr_eps_y + 2.0 * mu_y * eps_yy + 2.0 * mu * eps_yy_y\n    div_sigma_y = sigma_yx_x + sigma_yy_y\n    div_sigma = np.array([div_sigma_x, div_sigma_y])\n\n    return {\"sigma\": sigma, \"div_sigma\": div_sigma}\n\ndef compute_volume_integral(q_omega, funcs):\n    points, weights = np.polynomial.legendre.leggauss(q_omega)\n    I_omega = np.zeros(2)\n    \n    mapped_points = 0.5 * (points + 1.0)\n    jacobian_factor = 0.25\n\n    for i in range(q_omega):\n        for j in range(q_omega):\n            x, y = mapped_points[i], mapped_points[j]\n            state = calculate_state(x, y, funcs)\n            I_omega += weights[i] * weights[j] * state['div_sigma']\n            \n    return jacobian_factor * I_omega\n\ndef compute_boundary_integral(q_d_omega, funcs):\n    points, weights = np.polynomial.legendre.leggauss(q_d_omega)\n    I_d_omega = np.zeros(2)\n\n    mapped_points = 0.5 * (points + 1.0)\n    jacobian_factor = 0.5\n\n    # Right edge: x=1, n=(1,0)\n    for i in range(q_d_omega):\n        y = mapped_points[i]\n        sigma = calculate_state(1.0, y, funcs)['sigma']\n        traction = np.array([sigma[0, 0], sigma[1, 0]])\n        I_d_omega += weights[i] * traction\n        \n    # Left edge: x=0, n=(-1,0)\n    for i in range(q_d_omega):\n        y = mapped_points[i]\n        sigma = calculate_state(0.0, y, funcs)['sigma']\n        traction = np.array([-sigma[0, 0], -sigma[1, 0]])\n        I_d_omega += weights[i] * traction\n        \n    # Top edge: y=1, n=(0,1)\n    for i in range(q_d_omega):\n        x = mapped_points[i]\n        sigma = calculate_state(x, 1.0, funcs)['sigma']\n        traction = np.array([sigma[0, 1], sigma[1, 1]])\n        I_d_omega += weights[i] * traction\n    \n    # Bottom edge: y=0, n=(0,-1)\n    for i in range(q_d_omega):\n        x = mapped_points[i]\n        sigma = calculate_state(x, 0.0, funcs)['sigma']\n        traction = np.array([-sigma[0, 1], -sigma[1, 1]])\n        I_d_omega += weights[i] * traction\n        \n    return jacobian_factor * I_d_omega\n\ndef solve():\n    pi = np.pi\n    E0 = 1000.0\n    nu0 = 0.3\n    alpha = 0.3\n    beta = -0.2\n\n    funcs_smooth_hetero = {\n        'u': lambda x,y: np.sin(pi*x)*np.sin(pi*y) + 0.1*x**2,\n        'v': lambda x,y: np.cos(pi*x)*np.sin(pi*y) + 0.05*x*y,\n        'u_x': lambda x,y: pi*np.cos(pi*x)*np.sin(pi*y) + 0.2*x,\n        'u_y': lambda x,y: pi*np.sin(pi*x)*np.cos(pi*y),\n        'v_x': lambda x,y: -pi*np.sin(pi*x)*np.sin(pi*y) + 0.05*y,\n        'v_y': lambda x,y: pi*np.cos(pi*x)*np.cos(pi*y) + 0.05*x,\n        'u_xx': lambda x,y: -pi**2*np.sin(pi*x)*np.sin(pi*y) + 0.2,\n        'u_yy': lambda x,y: -pi**2*np.sin(pi*x)*np.sin(pi*y),\n        'u_xy': lambda x,y: pi**2*np.cos(pi*x)*np.cos(pi*y),\n        'v_xx': lambda x,y: -pi**2*np.cos(pi*x)*np.sin(pi*y),\n        'v_yy': lambda x,y: -pi**2*np.cos(pi*x)*np.sin(pi*y),\n        'v_xy': lambda x,y: -pi**2*np.sin(pi*x)*np.cos(pi*y) + 0.05,\n        'E': lambda x,y: E0 * (1 + 0.3*x + 0.2*y + 0.1*np.sin(2*pi*x)*np.cos(2*pi*y)),\n        'nu': lambda x,y: nu0 + 0.05*np.sin(pi*x)*np.sin(pi*y),\n        'E_x': lambda x,y: E0 * (0.3 + 0.2*pi*np.cos(2*pi*x)*np.cos(2*pi*y)),\n        'E_y': lambda x,y: E0 * (0.2 - 0.2*pi*np.sin(2*pi*x)*np.sin(2*pi*y)),\n        'nu_x': lambda x,y: 0.05*pi*np.cos(pi*x)*np.sin(pi*y),\n        'nu_y': lambda x,y: 0.05*pi*np.sin(pi*x)*np.cos(pi*y),\n    }\n\n    z = lambda x,y: 0.0\n    funcs_linear_const = {\n        'u': lambda x,y: alpha*x,\n        'v': lambda x,y: beta*y,\n        'u_x': lambda x,y: alpha, 'u_y': z,\n        'v_x': z, 'v_y': lambda x,y: beta,\n        'u_xx': z, 'u_yy': z, 'u_xy': z,\n        'v_xx': z, 'v_yy': z, 'v_xy': z,\n        'E': lambda x,y: E0,\n        'nu': lambda x,y: nu0,\n        'E_x': z, 'E_y': z,\n        'nu_x': z, 'nu_y': z,\n    }\n\n    test_cases = [\n        {'q_omega': 5, 'q_d_omega': 5, 'funcs': funcs_smooth_hetero},\n        {'q_omega': 1, 'q_d_omega': 1, 'funcs': funcs_smooth_hetero},\n        {'q_omega': 10, 'q_d_omega': 10, 'funcs': funcs_smooth_hetero},\n        {'q_omega': 2, 'q_d_omega': 2, 'funcs': funcs_linear_const},\n    ]\n\n    results = []\n    for case in test_cases:\n        I_omega = compute_volume_integral(case['q_omega'], case['funcs'])\n        I_d_omega = compute_boundary_integral(case['q_d_omega'], case['funcs'])\n        error = np.linalg.norm(I_omega - I_d_omega)\n        results.append(error)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}