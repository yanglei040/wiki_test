{
    "hands_on_practices": [
        {
            "introduction": "In the Finite Element Method (FEM), complex physical domains are discretized into simpler, standard shapes in a reference coordinate system. This exercise provides hands-on practice with the essential mechanics of mapping from reference to physical space. By calculating the Jacobian matrix and using its properties, you will compute the physical surface normal and area element, which are crucial for evaluating the boundary integral term $\\int_{\\partial\\Omega} \\boldsymbol{v} \\cdot \\boldsymbol{n} \\, dS$ in the Gauss divergence theorem. Mastering this transformation is a cornerstone for implementing the weak forms of partial differential equations that govern physical phenomena .",
            "id": "3567179",
            "problem": "Consider a single eight-node hexahedral finite element in the Finite Element Method (FEM) with reference domain $\\widehat{\\Omega} = [-1,1]^3$ and an affine mapping $\\boldsymbol{x}(\\xi,\\eta,\\zeta)$ from the reference coordinates $(\\xi,\\eta,\\zeta)$ to the physical coordinates $\\boldsymbol{x}=(x,y,z)$ given by\n$$\n\\boldsymbol{x}(\\xi,\\eta,\\zeta) = \n\\begin{pmatrix}\n2\\,\\xi + \\eta + \\frac{1}{2}\\,\\zeta + 1 \\\\\n-\\xi + 3\\,\\eta + \\zeta - 2 \\\\\n\\xi - \\eta + 4\\,\\zeta\n\\end{pmatrix}.\n$$\nLet the boundary face $\\widehat{F}$ of the reference element be the quadrilateral at $\\zeta=1$, i.e., $\\widehat{F}=\\{(\\xi,\\eta,1): \\xi\\in[-1,1], \\eta\\in[-1,1]\\}$. A vector field $\\boldsymbol{v}(\\boldsymbol{x})$ is prescribed on the physical face as\n$$\n\\boldsymbol{v}(\\boldsymbol{x})=\n\\begin{pmatrix}\n1 + \\frac{1}{5}\\,x + \\frac{2}{5}\\,y - \\frac{1}{10}\\,z \\\\\n-\\frac{1}{2} + \\frac{2}{5}\\,x - \\frac{3}{10}\\,y + \\frac{1}{5}\\,z \\\\\n\\frac{7}{10} - \\frac{1}{5}\\,x + \\frac{1}{10}\\,y + \\frac{3}{10}\\,z\n\\end{pmatrix}.\n$$\nStarting from the fundamental definition of the Jacobian matrix $\\mathbf{J}=\\partial\\boldsymbol{x}/\\partial(\\xi,\\eta,\\zeta)$ and the geometric meaning of its columns as covariant base vectors, use the cofactors of $\\mathbf{J}$ to:\n(1) derive the physical unit normal $\\boldsymbol{n}$ and the scalar area element $dS$ on the face $\\zeta=1$,\n(2) express the flux integrand $\\boldsymbol{v}\\cdot\\boldsymbol{n}\\,dS$ on this face in terms of the reference variables $(\\xi,\\eta)$, and\n(3) evaluate the surface flux\n$$\n\\int_{\\partial\\Omega_e\\cap\\{\\zeta=1\\}} \\boldsymbol{v}\\cdot\\boldsymbol{n}\\, dS\n$$\nby reference quadrature using the tensor-product two-point Gauss–Legendre rule on $[-1,1]^2$, with points $\\xi=\\pm\\frac{1}{\\sqrt{3}}$, $\\eta=\\pm\\frac{1}{\\sqrt{3}}$ and weights $w_\\xi=w_\\eta=1$. Assume the mapping is orientation-preserving and take the outward normal on the $\\zeta=1$ face to be the one associated with increasing $\\zeta$. Provide the final value of the flux as a single exact number. No unit conversion is required, and no rounding is necessary.",
            "solution": "The user wants to evaluate a surface flux integral over one face of an eight-node hexahedral finite element. This problem will be solved in three parts as requested: (1) calculation of the surface normal and area element, (2) expression of the flux integrand in reference coordinates, and (3) evaluation of the flux integral using Gauss quadrature.\n\nFirst, we must validate the problem statement.\n\n### Step 1: Extract Givens\n-   **Reference Domain**: A cube $\\widehat{\\Omega} = [-1,1]^3$ in coordinates $(\\xi,\\eta,\\zeta)$.\n-   **Affine Mapping**: $\\boldsymbol{x}(\\xi,\\eta,\\zeta)$ from reference to physical coordinates $\\boldsymbol{x}=(x,y,z)$ is given by:\n    $$\n    \\boldsymbol{x}(\\xi,\\eta,\\zeta) = \n    \\begin{pmatrix}\n    2\\,\\xi + \\eta + \\frac{1}{2}\\,\\zeta + 1 \\\\\n    -\\xi + 3\\,\\eta + \\zeta - 2 \\\\\n    \\xi - \\eta + 4\\,\\zeta\n    \\end{pmatrix}\n    $$\n-   **Boundary Face**: The reference face is $\\widehat{F}=\\{(\\xi,\\eta,1): \\xi\\in[-1,1], \\eta\\in[-1,1]\\}$, which corresponds to the physical face $\\partial\\Omega_e\\cap\\{\\zeta=1\\}$.\n-   **Vector Field**: The vector field $\\boldsymbol{v}(\\boldsymbol{x})$ is:\n    $$\n    \\boldsymbol{v}(\\boldsymbol{x})=\n    \\begin{pmatrix}\n    1 + \\frac{1}{5}\\,x + \\frac{2}{5}\\,y - \\frac{1}{10}\\,z \\\\\n    -\\frac{1}{2} + \\frac{2}{5}\\,x - \\frac{3}{10}\\,y + \\frac{1}{5}\\,z \\\\\n    \\frac{7}{10} - \\frac{1}{5}\\,x + \\frac{1}{10}\\,y + \\frac{3}{10}\\,z\n    \\end{pmatrix}\n    $$\n-   **Task**:\n    1.  Derive the physical unit normal $\\boldsymbol{n}$ and scalar area element $dS$ on the face $\\zeta=1$ using cofactors of the Jacobian matrix $\\mathbf{J}$.\n    2.  Express the flux integrand $\\boldsymbol{v}\\cdot\\boldsymbol{n}\\,dS$ in terms of $(\\xi,\\eta)$.\n    3.  Evaluate the flux integral $\\int \\boldsymbol{v}\\cdot\\boldsymbol{n}\\, dS$ using the tensor-product two-point Gauss-Legendre rule, with points $\\xi=\\pm\\frac{1}{\\sqrt{3}}$, $\\eta=\\pm\\frac{1}{\\sqrt{3}}$ and weights $w_\\xi=w_\\eta=1$.\n-   **Assumptions**: The mapping is orientation-preserving. The outward normal on the $\\zeta=1$ face is associated with increasing $\\zeta$.\n\n### Step 2: Validate Using Extracted Givens\n-   **Scientifically Grounded**: The problem is based on standard principles of continuum mechanics and the Finite Element Method (FEM), specifically isoparametric mapping and surface integration. These are well-established concepts in computational solid mechanics.\n-   **Well-Posed**: The problem provides all necessary information: the geometric mapping, the vector field, and the integration rule. The tasks are specified clearly, leading to a unique numerical answer.\n-   **Objective**: The problem is stated in precise mathematical language, free from ambiguity or subjective claims.\n\nThe problem does not exhibit any flaws such as scientific unsoundness, incompleteness, contradiction, or infeasibility. It is a well-posed, standard problem in computational engineering.\n\n### Step 3: Verdict and Action\nThe problem is deemed **valid**. We proceed with the solution.\n\n### Detailed Solution\n\n**Part (1): Derive the physical unit normal $\\boldsymbol{n}$ and scalar area element $dS$.**\n\nThe mapping from reference coordinates $(\\xi,\\eta,\\zeta)$ to physical coordinates $\\boldsymbol{x}=(x,y,z)$ is given. The Jacobian matrix $\\mathbf{J}$ of this mapping is defined as:\n$$\n\\mathbf{J} = \\frac{\\partial\\boldsymbol{x}}{\\partial(\\xi,\\eta,\\zeta)} = \\begin{pmatrix}\n\\frac{\\partial x}{\\partial \\xi} & \\frac{\\partial x}{\\partial \\eta} & \\frac{\\partial x}{\\partial \\zeta} \\\\\n\\frac{\\partial y}{\\partial \\xi} & \\frac{\\partial y}{\\partial \\eta} & \\frac{\\partial y}{\\partial \\zeta} \\\\\n\\frac{\\partial z}{\\partial \\xi} & \\frac{\\partial z}{\\partial \\eta} & \\frac{\\partial z}{\\partial \\zeta}\n\\end{pmatrix}\n$$\nThe columns of $\\mathbf{J}$ are the covariant base vectors $\\boldsymbol{g}_1 = \\frac{\\partial\\boldsymbol{x}}{\\partial\\xi}$, $\\boldsymbol{g}_2 = \\frac{\\partial\\boldsymbol{x}}{\\partial\\eta}$, and $\\boldsymbol{g}_3 = \\frac{\\partial\\boldsymbol{x}}{\\partial\\zeta}$. For the given affine mapping, these vectors are constant:\n$$\n\\boldsymbol{g}_1 = \\begin{pmatrix} 2 \\\\ -1 \\\\ 1 \\end{pmatrix}, \\quad\n\\boldsymbol{g}_2 = \\begin{pmatrix} 1 \\\\ 3 \\\\ -1 \\end{{pmatrix}, \\quad\n\\boldsymbol{g}_3 = \\begin{pmatrix} \\frac{1}{2} \\\\ 1 \\\\ 4 \\end{pmatrix}\n$$\nThe Jacobian matrix is therefore constant:\n$$\n\\mathbf{J} = \\begin{pmatrix} 2 & 1 & \\frac{1}{2} \\\\ -1 & 3 & 1 \\\\ 1 & -1 & 4 \\end{pmatrix}\n$$\nThe relationship between a physical surface element vector $d\\boldsymbol{S} = \\boldsymbol{n}\\,dS$ and its corresponding reference surface element vector $d\\boldsymbol{S}_0 = \\boldsymbol{N}\\,dA$ is given by Nanson's formula, which involves the cofactor matrix of $\\mathbf{J}$:\n$$\nd\\boldsymbol{S} = \\text{Cof}(\\mathbf{J})\\,d\\boldsymbol{S}_0\n$$\nThe face of interest is at $\\zeta=1$. In the reference domain, this face has a unit normal vector $\\boldsymbol{N} = (0, 0, 1)^T$ and an area element $dA = d\\xi\\,d\\eta$. Thus, $d\\boldsymbol{S}_0 = (0, 0, 1)^T d\\xi\\,d\\eta$.\nConsequently, the physical surface element vector $d\\boldsymbol{S}$ is the third column of the cofactor matrix of $\\mathbf{J}$, multiplied by $d\\xi\\,d\\eta$. The cofactor matrix $\\mathbf{C} = \\text{Cof}(\\mathbf{J})$ is given by $C_{ij} = (-1)^{i+j} M_{ij}$, where $M_{ij}$ is the minor of the element $J_{ij}$. We need the third column ($j=3$):\n$$\nC_{13} = (-1)^{1+3} \\det\\begin{pmatrix} -1 & 3 \\\\ 1 & -1 \\end{pmatrix} = (1)(1) - (3)(1) = -2\n$$\n$$\nC_{23} = (-1)^{2+3} \\det\\begin{pmatrix} 2 & 1 \\\\ 1 & -1 \\end{pmatrix} = -((2)(-1) - (1)(1)) = -(-2-1) = 3\n$$\n$$\nC_{33} = (-1)^{3+3} \\det\\begin{pmatrix} 2 & 1 \\\\ -1 & 3 \\end{pmatrix} = (2)(3) - (1)(-1) = 6+1 = 7\n$$\nSo, the surface element vector is:\n$$\nd\\boldsymbol{S} = \\boldsymbol{n}\\,dS = \\begin{pmatrix} -2 \\\\ 3 \\\\ 7 \\end{pmatrix} d\\xi\\,d\\eta\n$$\nThe scalar area element $dS$ is the magnitude of the vector coefficient of $d\\xi\\,d\\eta$:\n$$\ndS = \\left\\| \\begin{pmatrix} -2 \\\\ 3 \\\\ 7 \\end{pmatrix} \\right\\| d\\xi\\,d\\eta = \\sqrt{(-2)^2 + 3^2 + 7^2}\\,d\\xi\\,d\\eta = \\sqrt{4+9+49}\\,d\\xi\\,d\\eta = \\sqrt{62}\\,d\\xi\\,d\\eta\n$$\nThe unit normal vector $\\boldsymbol{n}$ is:\n$$\n\\boldsymbol{n} = \\frac{1}{\\sqrt{62}} \\begin{pmatrix} -2 \\\\ 3 \\\\ 7 \\end{pmatrix}\n$$\nThis vector must be checked for orientation. The outward normal is in the direction of increasing $\\zeta$, represented by $\\boldsymbol{g}_3$. The sign of $\\det(\\mathbf{J}) = (\\boldsymbol{g}_1 \\times \\boldsymbol{g}_2) \\cdot \\boldsymbol{g}_3$ determines the orientation. The vector coefficient of $d\\xi\\,d\\eta$ in $d\\boldsymbol{S}$ is $\\boldsymbol{g}_1 \\times \\boldsymbol{g}_2$. Its dot product with $\\boldsymbol{g}_3$ is:\n$$\n\\begin{pmatrix} -2 \\\\ 3 \\\\ 7 \\end{pmatrix} \\cdot \\begin{pmatrix} \\frac{1}{2} \\\\ 1 \\\\ 4 \\end{pmatrix} = (-2)(\\frac{1}{2}) + (3)(1) + (7)(4) = -1 + 3 + 28 = 30\n$$\nSince $\\det(\\mathbf{J})=30 > 0$, our calculated normal vector correctly points outward, consistent with the problem statement.\n\n**Part (2): Express the flux integrand $\\boldsymbol{v}\\cdot\\boldsymbol{n}\\,dS$ in terms of $(\\xi,\\eta)$.**\n\nThe flux integrand is $\\boldsymbol{v}\\cdot\\boldsymbol{n}\\,dS$, which is simply $\\boldsymbol{v}\\cdot d\\boldsymbol{S}$.\n$$\n\\boldsymbol{v}\\cdot\\boldsymbol{n}\\,dS = \\boldsymbol{v} \\cdot \\left( \\begin{pmatrix} -2 \\\\ 3 \\\\ 7 \\end{pmatrix} d\\xi\\,d\\eta \\right) = (-2v_x + 3v_y + 7v_z) \\,d\\xi\\,d\\eta\n$$\nLet's first express the term $(-2v_x + 3v_y + 7v_z)$ in terms of physical coordinates $(x,y,z)$:\n$$\n-2v_x = -2\\left(1 + \\frac{1}{5}x + \\frac{2}{5}y - \\frac{1}{10}z\\right) = -2 - \\frac{2}{5}x - \\frac{4}{5}y + \\frac{1}{5}z\n$$\n$$\n3v_y = 3\\left(-\\frac{1}{2} + \\frac{2}{5}x - \\frac{3}{10}y + \\frac{1}{5}z\\right) = -\\frac{3}{2} + \\frac{6}{5}x - \\frac{9}{10}y + \\frac{3}{5}z\n$$\n$$\n7v_z = 7\\left(\\frac{7}{10} - \\frac{1}{5}x + \\frac{1}{10}y + \\frac{3}{10}z\\right) = \\frac{49}{10} - \\frac{7}{5}x + \\frac{7}{10}y + \\frac{21}{10}z\n$$\nSumming these gives:\n$$\n(-2-\\frac{3}{2}+\\frac{49}{10}) + (-\\frac{2}{5}+\\frac{6}{5}-\\frac{7}{5})x + (-\\frac{4}{5}-\\frac{9}{10}+\\frac{7}{10})y + (\\frac{1}{5}+\\frac{3}{5}+\\frac{21}{10})z\n$$\n$$\n= \\frac{-20-15+49}{10} + \\frac{-2+6-7}{5}x + \\frac{-8-9+7}{10}y + \\frac{2+6+21}{10}z\n$$\n$$\n= \\frac{14}{10} - \\frac{3}{5}x - \\frac{10}{10}y + \\frac{29}{10}z = \\frac{7}{5} - \\frac{3}{5}x - y + \\frac{29}{10}z\n$$\nNow, substitute the physical coordinates on the face $\\zeta=1$ in terms of reference coordinates $(\\xi,\\eta)$:\n$$\n\\boldsymbol{x}(\\xi,\\eta,1) = \\begin{pmatrix} x \\\\ y \\\\ z \\end{pmatrix} = \\begin{pmatrix}\n2\\xi + \\eta + \\frac{1}{2}(1) + 1 \\\\ -\\xi + 3\\eta + 1 - 2 \\\\ \\xi - \\eta + 4(1)\n\\end{pmatrix} = \\begin{pmatrix}\n2\\xi + \\eta + \\frac{3}{2} \\\\ -\\xi + 3\\eta - 1 \\\\ \\xi - \\eta + 4\n\\end{pmatrix}\n$$\nSubstitute these into the expression for $\\boldsymbol{v}\\cdot(-2,3,7)^T$:\n$$\nI(\\xi,\\eta) = \\frac{7}{5} - \\frac{3}{5}\\left(2\\xi + \\eta + \\frac{3}{2}\\right) - \\left(-\\xi + 3\\eta - 1\\right) + \\frac{29}{10}\\left(\\xi - \\eta + 4\\right)\n$$\n$$\nI(\\xi,\\eta) = \\frac{7}{5} - \\frac{6}{5}\\xi - \\frac{3}{5}\\eta - \\frac{9}{10} + \\xi - 3\\eta + 1 + \\frac{29}{10}\\xi - \\frac{29}{10}\\eta + \\frac{116}{10}\n$$\nCombine terms with common denominators:\n$$\n\\text{Constant term:} \\quad \\frac{14}{10} - \\frac{9}{10} + \\frac{10}{10} + \\frac{116}{10} = \\frac{131}{10}\n$$\n$$\n\\xi\\text{ term:} \\quad \\left(-\\frac{12}{10} + \\frac{10}{10} + \\frac{29}{10}\\right)\\xi = \\frac{27}{10}\\xi\n$$\n$$\n\\eta\\text{ term:} \\quad \\left(-\\frac{6}{10} - \\frac{30}{10} - \\frac{29}{10}\\right)\\eta = -\\frac{65}{10}\\eta = -\\frac{13}{2}\\eta\n$$\nThe integrand function is $I(\\xi, \\eta) = \\frac{27}{10}\\xi - \\frac{13}{2}\\eta + \\frac{131}{10}$.\nThe flux integrand is thus $\\left(\\frac{27}{10}\\xi - \\frac{13}{2}\\eta + \\frac{131}{10}\\right)d\\xi\\,d\\eta$.\n\n**Part (3): Evaluate the surface flux using Gauss quadrature.**\n\nThe surface flux is the integral of the integrand function over the reference face $\\widehat{F}$:\n$$\n\\text{Flux} = \\int_{-1}^{1} \\int_{-1}^{1} I(\\xi,\\eta)\\,d\\xi\\,d\\eta = \\int_{-1}^{1} \\int_{-1}^{1} \\left(\\frac{27}{10}\\xi - \\frac{13}{2}\\eta + \\frac{131}{10}\\right)d\\xi\\,d\\eta\n$$\nWe use the tensor-product two-point Gauss-Legendre rule. The quadrature points are $(\\xi_i, \\eta_j)$ where $\\xi_i, \\eta_j \\in \\{-\\frac{1}{\\sqrt{3}}, \\frac{1}{\\sqrt{3}}\\}$, and the weights are $w_i = w_j = 1$.\nThe integral is approximated by:\n$$\n\\text{Flux} \\approx \\sum_{i=1}^{2} \\sum_{j=1}^{2} w_i w_j I(\\xi_i, \\eta_j) = \\sum_{i=1}^{2} \\sum_{j=1}^{2} I(\\xi_i, \\eta_j)\n$$\nThe four evaluation points are $(-\\frac{1}{\\sqrt{3}}, -\\frac{1}{\\sqrt{3}})$, $(-\\frac{1}{\\sqrt{3}}, \\frac{1}{\\sqrt{3}})$, $(\\frac{1}{\\sqrt{3}}, -\\frac{1}{\\sqrt{3}})$, and $(\\frac{1}{\\sqrt{3}}, \\frac{1}{\\sqrt{3}})$.\nThe integrand $I(\\xi, \\eta)$ is a linear polynomial in $\\xi$ and $\\eta$. The two-point Gauss-Legendre rule is exact for polynomials of degree up to $2n-1 = 2(2)-1=3$. Therefore, the quadrature will yield the exact value of the integral.\nFor a linear function $f(\\xi,\\eta) = a\\xi + b\\eta + c$, the sum over the four symmetric Gauss points is:\n$$\n\\sum_{i,j} f(\\xi_i, \\eta_j) = f(-\\alpha,-\\alpha) + f(-\\alpha,\\alpha) + f(\\alpha,-\\alpha) + f(\\alpha,\\alpha) \\quad \\left(\\alpha = \\frac{1}{\\sqrt{3}}\\right)\n$$\n$$\n= (-a\\alpha -b\\alpha + c) + (-a\\alpha +b\\alpha + c) + (a\\alpha -b\\alpha + c) + (a\\alpha +b\\alpha + c)\n$$\n$$\n= (-a-a+a+a)\\alpha + (-b+b-b+b)\\alpha + 4c = 4c\n$$\nIn our case, $a = \\frac{27}{10}$, $b = -\\frac{13}{2}$, and $c = \\frac{131}{10}$.\nThe value of the integral is exactly $4$ times the constant term of the integrand multiplied by the product of the domain lengths, which is already accounted for in the standard quadrature formula on $[-1,1]^2$.\nThe sum is $4c = 4 \\times \\frac{131}{10} = \\frac{524}{10} = \\frac{262}{5}$.\nLet's convert to a decimal for clarity in the steps: $4 \\times 13.1 = 52.4$.\nThe final value must be an exact number.\n$$\n\\text{Flux} = \\frac{262}{5}\n$$",
            "answer": "$$\\boxed{\\frac{262}{5}}$$"
        },
        {
            "introduction": "A correct computer program is one that correctly solves the mathematical model it is based on. This practice introduces the Method of Manufactured Solutions (MMS), a rigorous technique for code verification where the Gauss divergence theorem serves as a powerful checking tool. You will implement a numerical test to verify the identity $\\int_{\\partial\\Omega}\\boldsymbol{\\sigma}\\boldsymbol{n}\\,dS = \\int_{\\Omega}\\nabla\\cdot\\boldsymbol{\\sigma}\\,d\\Omega$ for a predefined stress field, exploring how the accuracy of numerical quadrature rules directly impacts the validity of this discrete balance. This exercise demonstrates how to build confidence in your computational tools by confirming that they respect fundamental physical laws .",
            "id": "3567224",
            "problem": "Consider a two-dimensional, static body in Computational Solid Mechanics (CSM) with a manufactured second-order Cauchy stress tensor field $\\boldsymbol{\\sigma}(\\boldsymbol{x})$ that is symmetric, where $\\boldsymbol{x}=(x,y)$ and $\\boldsymbol{\\sigma}=\\begin{bmatrix}\\sigma_{xx}&\\sigma_{xy}\\\\\\sigma_{xy}&\\sigma_{yy}\\end{bmatrix}$. Let the divergence of the stress tensor be defined component-wise by $(\\nabla\\cdot\\boldsymbol{\\sigma})_i=\\sum_{j=1}^{2}\\partial \\sigma_{ij}/\\partial x_j$ for $i\\in\\{1,2\\}$, and denote the resulting vector field by $\\boldsymbol{b}(\\boldsymbol{x})=\\nabla\\cdot\\boldsymbol{\\sigma}(\\boldsymbol{x})$. The Gauss divergence theorem for a tensor field implies that $\\int_{\\partial\\Omega}\\boldsymbol{\\sigma}\\boldsymbol{n}\\,dS=\\int_{\\Omega}\\nabla\\cdot\\boldsymbol{\\sigma}\\,d\\Omega$, where $\\Omega\\subset\\mathbb{R}^2$ is a bounded domain with piecewise smooth boundary $\\partial\\Omega$, and $\\boldsymbol{n}$ is the outward unit normal. In computational verification for polynomial fields, numerical quadrature rules may or may not exactly integrate the required polynomials depending on their order.\n\nStarting from the conservation of linear momentum for a static body without inertia, which states $\\nabla\\cdot\\boldsymbol{\\sigma}+\\boldsymbol{b}_{\\text{phys}}=\\boldsymbol{0}$, construct a manufactured source field by setting $\\boldsymbol{b}=\\nabla\\cdot\\boldsymbol{\\sigma}$. Then verify numerically the identity $\\int_{\\partial\\Omega}\\boldsymbol{\\sigma}\\boldsymbol{n}\\,dS-\\int_{\\Omega}\\boldsymbol{b}\\,d\\Omega=\\boldsymbol{0}$ using Gauss–Legendre quadrature under varying quadrature orders. All quantities are dimensionless.\n\nYour task is to write a complete, runnable program that:\n- Implements the following polynomial stress fields $\\boldsymbol{\\sigma}(\\boldsymbol{x})$ for each test case, with $\\sigma_{xy}=\\sigma_{yx}$, and constructs $\\boldsymbol{b}(\\boldsymbol{x})$ exactly from the divergence of $\\boldsymbol{\\sigma}(\\boldsymbol{x})$.\n- Numerically computes both $\\int_{\\partial\\Omega}\\boldsymbol{\\sigma}\\boldsymbol{n}\\,dS$ and $\\int_{\\Omega}\\boldsymbol{b}\\,d\\Omega$ using Gauss–Legendre quadrature rules of specified orders for boundary segments and for the area, respectively.\n- Reports the Euclidean norm of the residual vector $\\boldsymbol{r}=\\int_{\\partial\\Omega}\\boldsymbol{\\sigma}\\boldsymbol{n}\\,dS-\\int_{\\Omega}\\boldsymbol{b}\\,d\\Omega$ as a single floating-point value per test case.\n\nUse rectangular domains $\\Omega=[x_0,x_1]\\times[y_0,y_1]$ with outward normals on the four edges given by $\\boldsymbol{n}=(0,-1)$ on the bottom edge, $\\boldsymbol{n}=(1,0)$ on the right edge, $\\boldsymbol{n}=(0,1)$ on the top edge, and $\\boldsymbol{n}=(-1,0)$ on the left edge. Use Gauss–Legendre quadrature with order $m$ on each boundary edge and tensor-product Gauss–Legendre quadrature with orders $(n_x,n_y)$ in the area. The Euclidean norm must be reported as a dimensionless floating-point number.\n\nManufactured stress polynomials and test suite:\n- Test case $1$ (happy path, exact integration expected):\n  - Domain: $[0,1]\\times[0,1]$.\n  - Quadrature orders: boundary $m=2$, area $(n_x,n_y)=(2,2)$.\n  - Stress components:\n    - $\\sigma_{xx}=2x+3y+1$,\n    - $\\sigma_{xy}=4x+5y+2$,\n    - $\\sigma_{yy}=-x+2y+\\tfrac{1}{2}$.\n- Test case $2$ (under-integration, nonzero residual expected):\n  - Domain: $[0,1]\\times[0,1]$.\n  - Quadrature orders: boundary $m=1$, area $(n_x,n_y)=(1,1)$.\n  - Stress components:\n    - $\\sigma_{xx}=x^3+2x^2y+xy^2+y^3+x^2+y^2+x+y+1$,\n    - $\\sigma_{xy}=x^2y+xy^2+x^2+y^2+x+y+1$,\n    - $\\sigma_{yy}=2x^3+x^2y+xy^2+\\tfrac{1}{2}y^3+x^2+y^2+x+y$.\n- Test case $3$ (general rectangle, exact integration expected):\n  - Domain: $[-1,2]\\times[0,3]$.\n  - Quadrature orders: boundary $m=3$, area $(n_x,n_y)=(3,3)$.\n  - Stress components:\n    - $\\sigma_{xx}=3x^2+2xy+y^2+x+2y+1$,\n    - $\\sigma_{xy}=-x^2+3xy+2y^2+0.1x+0.2y+0.3$,\n    - $\\sigma_{yy}=2x^2-xy+4y^2+0.5x+1.5y+2$.\n- Test case $4$ (small domain, high-order quadrature, near-machine-precision residual expected):\n  - Domain: $[0,0.01]\\times[0,0.02]$.\n  - Quadrature orders: boundary $m=5$, area $(n_x,n_y)=(5,5)$.\n  - Stress components:\n    - $\\sigma_{xx}=0.1x^3+0.2x^2y+0.3xy^2+0.4y^3+0.5x+0.6y+0.7$,\n    - $\\sigma_{xy}=0.2x^2y+0.1xy^2+0.3x^2+0.4y^2+0.5x+0.6y+0.1$,\n    - $\\sigma_{yy}=0.3x^3+0.1x^2y+0.2xy^2+0.5y^3+0.4x+0.3y+0.2$.\n\nImplementation requirements:\n- Compute $\\int_{\\partial\\Omega}\\boldsymbol{\\sigma}\\boldsymbol{n}\\,dS$ by summing the four edge integrals using one-dimensional Gauss–Legendre quadrature of order $m$ on each edge with appropriate arc-length scaling and outward normal $\\boldsymbol{n}$.\n- Compute $\\int_{\\Omega}\\boldsymbol{b}\\,d\\Omega$ by tensor-product two-dimensional Gauss–Legendre quadrature of orders $(n_x,n_y)$ using affine mapping from $[-1,1]$ to $[x_0,x_1]$ and $[y_0,y_1]$.\n- For each test case, output the Euclidean norm $\\|\\boldsymbol{r}\\|_2$ as a dimensionless floating-point number.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,r_3,r_4]$), where each $r_k$ is the residual norm for test case $k$.\n\nNo external input, files, or network access are allowed. The final output must strictly follow the single-line format described above.",
            "solution": "The user wants to numerically verify the Gauss divergence theorem for a second-order Cauchy stress tensor field $\\boldsymbol{\\sigma}$ over a rectangular domain $\\Omega$. The theorem states that the integral of the traction vector $\\boldsymbol{t} = \\boldsymbol{\\sigma}\\boldsymbol{n}$ over the boundary $\\partial\\Omega$ is equal to the integral of the divergence of the stress tensor, $\\nabla\\cdot\\boldsymbol{\\sigma}$, over the domain $\\Omega$. The problem is formulated in the context of the Method of Manufactured Solutions (MMS) in Computational Solid Mechanics, where a known stress field $\\boldsymbol{\\sigma}$ is \"manufactured\", and its divergence is treated as a body force source term $\\boldsymbol{b} = \\nabla\\cdot\\boldsymbol{\\sigma}$. The identity to be verified is $\\int_{\\partial\\Omega}\\boldsymbol{\\sigma}\\boldsymbol{n}\\,dS = \\int_{\\Omega}\\boldsymbol{b}\\,d\\Omega$, or equivalently, that the residual vector $\\boldsymbol{r} = \\int_{\\partial\\Omega}\\boldsymbol{\\sigma}\\boldsymbol{n}\\,dS - \\int_{\\Omega}\\boldsymbol{b}\\,d\\Omega$ is the zero vector. We will compute the Euclidean norm of this residual, $\\|\\boldsymbol{r}\\|_2$, for several test cases involving polynomial stress fields and different orders of Gauss-Legendre quadrature.\n\n### Step 1: Mathematical Formulation\n\nLet the domain be a rectangle $\\Omega = [x_0, x_1] \\times [y_0, y_1]$. The boundary $\\partial\\Omega$ consists of four line segments.\n\n**1.1. Stress Tensor and its Divergence**\nThe given stress tensor is a symmetric $2 \\times 2$ matrix field:\n$$\n\\boldsymbol{\\sigma}(\\boldsymbol{x}) = \\begin{bmatrix} \\sigma_{xx}(x,y) & \\sigma_{xy}(x,y) \\\\ \\sigma_{xy}(x,y) & \\sigma_{yy}(x,y) \\end{bmatrix}\n$$\nThe body force source term $\\boldsymbol{b}$ is defined as the divergence of $\\boldsymbol{\\sigma}$:\n$$\n\\boldsymbol{b}(\\boldsymbol{x}) = \\nabla\\cdot\\boldsymbol{\\sigma}(\\boldsymbol{x}) = \\begin{pmatrix} b_x(x,y) \\\\ b_y(x,y) \\end{pmatrix} = \\begin{pmatrix} \\frac{\\partial \\sigma_{xx}}{\\partial x} + \\frac{\\partial \\sigma_{xy}}{\\partial y} \\\\ \\frac{\\partial \\sigma_{xy}}{\\partial x} + \\frac{\\partial \\sigma_{yy}}{\\partial y} \\end{pmatrix}\n$$\nFor each test case, we first analytically compute the functions $b_x(x,y)$ and $b_y(x,y)$ from the given polynomial expressions for $\\sigma_{ij}$.\n\n**1.2. Boundary Integral**\nThe boundary integral $\\int_{\\partial\\Omega}\\boldsymbol{\\sigma}\\boldsymbol{n}\\,dS$ is the sum of integrals over the four edges of the rectangle. Let's denote this integral by $\\boldsymbol{I}_{\\partial\\Omega}$.\nThe four edges are:\n- Bottom: $y = y_0$, $x \\in [x_0, x_1]$, $\\boldsymbol{n} = (0, -1)$. The traction is $\\boldsymbol{\\sigma}\\boldsymbol{n} = (-\\sigma_{xy}, -\\sigma_{yy})^T$.\n  $$ \\boldsymbol{I}_{\\text{bottom}} = \\int_{x_0}^{x_1} \\begin{pmatrix} -\\sigma_{xy}(x, y_0) \\\\ -\\sigma_{yy}(x, y_0) \\end{pmatrix} dx $$\n- Right: $x = x_1$, $y \\in [y_0, y_1]$, $\\boldsymbol{n} = (1, 0)$. The traction is $\\boldsymbol{\\sigma}\\boldsymbol{n} = (\\sigma_{xx}, \\sigma_{xy})^T$.\n  $$ \\boldsymbol{I}_{\\text{right}} = \\int_{y_0}^{y_1} \\begin{pmatrix} \\sigma_{xx}(x_1, y) \\\\ \\sigma_{xy}(x_1, y) \\end{pmatrix} dy $$\n- Top: $y = y_1$, $x \\in [x_0, x_1]$, $\\boldsymbol{n} = (0, 1)$. The traction is $\\boldsymbol{\\sigma}\\boldsymbol{n} = (\\sigma_{xy}, \\sigma_{yy})^T$.\n  $$ \\boldsymbol{I}_{\\text{top}} = \\int_{x_0}^{x_1} \\begin{pmatrix} \\sigma_{xy}(x, y_1) \\\\ \\sigma_{yy}(x, y_1) \\end{pmatrix} dx $$\n- Left: $x = x_0$, $y \\in [y_0, y_1]$, $\\boldsymbol{n} = (-1, 0)$. The traction is $\\boldsymbol{\\sigma}\\boldsymbol{n} = (-\\sigma_{xx}, -\\sigma_{xy})^T$.\n  $$ \\boldsymbol{I}_{\\text{left}} = \\int_{y_0}^{y_1} \\begin{pmatrix} -\\sigma_{xx}(x_0, y) \\\\ -\\sigma_{xy}(x_0, y) \\end{pmatrix} dy $$\nThe total boundary integral is $\\boldsymbol{I}_{\\partial\\Omega} = \\boldsymbol{I}_{\\text{bottom}} + \\boldsymbol{I}_{\\text{right}} + \\boldsymbol{I}_{\\text{top}} + \\boldsymbol{I}_{\\text{left}}$.\n\n**1.3. Area Integral**\nThe area integral is the integral of the body force vector $\\boldsymbol{b}$ over the domain $\\Omega$:\n$$\n\\boldsymbol{I}_{\\Omega} = \\int_{\\Omega} \\boldsymbol{b}\\,d\\Omega = \\int_{y_0}^{y_1} \\int_{x_0}^{x_1} \\begin{pmatrix} b_x(x,y) \\\\ b_y(x,y) \\end{pmatrix} dx dy\n$$\n\n### Step 2: Numerical Quadrature\n\nWe use Gauss-Legendre quadrature to approximate the integrals. A 1D Gauss-Legendre rule of order $k$ (using $k$ points) integrates polynomials of degree up to $2k-1$ exactly.\n\n**2.1. 1D Gauss-Legendre Quadrature (for Boundary Integrals)**\nTo compute an integral $\\int_a^b f(t) dt$, we map the reference interval $\\xi \\in [-1, 1]$ to $[a, b]$ using $t(\\xi) = \\frac{b-a}{2}\\xi + \\frac{a+b}{2}$. The differential is $dt = \\frac{b-a}{2}d\\xi$. The integral is approximated as:\n$$\n\\int_a^b f(t) dt \\approx \\frac{b-a}{2} \\sum_{i=1}^{m} w_i f(t(\\xi_i))\n$$\nwhere $\\xi_i$ are the quadrature points, $w_i$ are the corresponding weights, and $m$ is the quadrature order. The term $\\frac{b-a}{2}$ is the Jacobian of the 1D transformation.\n\n**2.2. 2D Tensor-Product Gauss-Legendre Quadrature (for Area Integral)**\nTo compute $\\int_{y_0}^{y_1} \\int_{x_0}^{x_1} \\boldsymbol{g}(x,y) dx dy$, we map the reference square $(\\xi, \\eta) \\in [-1, 1] \\times [-1, 1]$ to the rectangle $[x_0, x_1] \\times [y_0, y_1]$.\nThe mappings are $x(\\xi) = \\frac{x_1-x_0}{2}\\xi + \\frac{x_0+x_1}{2}$ and $y(\\eta) = \\frac{y_1-y_0}{2}\\eta + \\frac{y_0+y_1}{2}$.\nThe differential area is $d\\Omega = dx dy = \\left(\\frac{x_1-x_0}{2}\\right)\\left(\\frac{y_1-y_0}{2}\\right)d\\xi d\\eta = J d\\xi d\\eta$, where $J$ is the Jacobian determinant of the transformation. The integral is approximated as:\n$$\n\\int_{\\Omega} \\boldsymbol{g}\\,d\\Omega \\approx J \\sum_{j=1}^{n_y} \\sum_{i=1}^{n_x} w_j^{\\eta} w_i^{\\xi} \\boldsymbol{g}(x(\\xi_i), y(\\eta_j))\n$$\nwhere $(w_i^{\\xi}, \\xi_i)$ and $(w_j^{\\eta}, \\eta_j)$ are the weights and points for Gauss-Legendre rules of orders $n_x$ and $n_y$, respectively.\n\n### Step 3: Algorithmic Implementation\n\nFor each test case, the algorithm proceeds as follows:\n1. Define Python functions for the components of the stress tensor $\\sigma_{xx}, \\sigma_{xy}, \\sigma_{yy}$.\n2. Analytically derive and define Python functions for the components of the body force vector $b_x, b_y$.\n3. Retrieve the quadrature points and weights for the specified orders using `scipy.special.roots_legendre`.\n4. **Compute Boundary Integral $\\boldsymbol{I}_{\\partial\\Omega}$**:\n   - Initialize a 2D vector $\\boldsymbol{I}_{\\partial\\Omega} = [0, 0]^T$.\n   - For each of the four edges:\n     - Determine the integration limits $[a,b]$, the corresponding Jacobian $\\frac{b-a}{2}$, the integrand vector function, and the fixed coordinate.\n     - Apply the 1D Gauss-Legendre quadrature formula by summing the contributions at each quadrature point, scaled by the weight and Jacobian.\n     - Add the result for the edge to $\\boldsymbol{I}_{\\partial\\Omega}$.\n5. **Compute Area Integral $\\boldsymbol{I}_{\\Omega}$**:\n   - Initialize a 2D vector $\\boldsymbol{I}_{\\Omega} = [0, 0]^T$.\n   - Calculate the area Jacobian $J = (\\frac{x_1-x_0}{2})(\\frac{y_1-y_0}{2})$.\n   - Use nested loops to iterate through the tensor product of quadrature points $(\\xi_i, \\eta_j)$.\n   - In the inner loop, map the reference coordinates to physical coordinates $(x,y)$, evaluate $\\boldsymbol{b}(x,y)$, and add the contribution $w_i^{\\xi} w_j^{\\eta} \\boldsymbol{b}(x,y)$ to a running sum.\n   - Multiply the final sum by the area Jacobian $J$ to get $\\boldsymbol{I}_{\\Omega}$.\n6. **Compute Residual**:\n   - Calculate the residual vector $\\boldsymbol{r} = \\boldsymbol{I}_{\\partial\\Omega} - \\boldsymbol{I}_{\\Omega}$.\n   - Compute and return its Euclidean norm $\\|\\boldsymbol{r}\\|_2 = \\sqrt{r_x^2 + r_y^2}$.\n\nThe implementation will be structured to handle the list of test cases, storing the result for each and formatting the final output as a single-line list.\n\n- **Test Case 1 (Exact Integration)**: The boundary integrands are linear (degree 1), and the area integrand is constant (degree 0). Quadrature orders $m=2$ and $(n_x, n_y)=(2, 2)$ can exactly integrate polynomials up to degree $3$ and $(3,3)$ respectively. Thus, both integrals will be computed exactly, and the residual norm should be near machine precision.\n- **Test Case 2 (Under-integration)**: The stress tensor components are degree 3 polynomials. The boundary integrands are also degree 3, and the area integrand is degree 2. Quadrature orders $m=1$ and $(n_x, n_y)=(1, 1)$ can only exactly integrate polynomials up to degree $1$ and $(1,1)$. Due to this under-integration, a significant non-zero residual is expected.\n- **Test Case 3 (Exact Integration)**: The boundary integrands are degree 2, and the area integrand is degree 1. Quadrature orders $m=3$ and $(n_x, n_y)=(3, 3)$ integrate polynomials up to degree $5$ and $(5,5)$, which is sufficient for exact integration. The residual norm should be near machine precision.\n- **Test Case 4 (Exact Integration)**: The boundary integrands are degree 3, and the area integrand is degree 2. High quadrature orders $m=5$ and $(n_x, n_y)=(5, 5)$ are used, which integrate up to degree $9$ and $(9,9)$, ensuring exact integration. The residual norm should be near machine precision.\n\nThis numerical verification procedure is a cornerstone of code verification in scientific computing, confirming that the discrete implementation of a continuous mathematical operator (here, the divergence) is correct.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_legendre\n\ndef compute_boundary_integral(domain, m_order, sigma_funcs):\n    \"\"\"\n    Computes the boundary integral of sigma*n over a rectangular domain.\n    \"\"\"\n    x0, x1, y0, y1 = domain\n    sxx, sxy, syy = sigma_funcs['xx'], sigma_funcs['xy'], sigma_funcs['yy']\n    \n    points, weights = roots_legendre(m_order)\n    \n    total_integral = np.zeros(2, dtype=float)\n\n    # Edge definitions: (integration_var, fixed_coord_val, normal_vector, integrand_funcs)\n    # integrand_funcs is a tuple of functions defining the vector components of sigma*n\n    edges = [\n        # Bottom edge: n=(0,-1). Integrand: (-sxy, -syy)\n        ('x', y0, np.array([0., -1.]), (lambda x, y: -sxy(x,y), lambda x, y: -syy(x,y))),\n        # Right edge: n=(1,0). Integrand: (sxx, sxy)\n        ('y', x1, np.array([1., 0.]), (lambda x, y: sxx(x,y), lambda x, y: sxy(x,y))),\n        # Top edge: n=(0,1). Integrand: (sxy, syy)\n        ('x', y1, np.array([0., 1.]), (lambda x, y: sxy(x,y), lambda x, y: syy(x,y))),\n        # Left edge: n=(-1,0). Integrand: (-sxx, -sxy)\n        ('y', x0, np.array([-1., 0.]), (lambda x, y: -sxx(x,y), lambda x, y: -sxy(x,y))),\n    ]\n\n    for int_var, fixed_val, _, integrand_funcs in edges:\n        edge_integral = np.zeros(2, dtype=float)\n        if int_var == 'x':\n            a, b = x0, x1\n            fixed_coord = 'y'\n        else: # int_var == 'y'\n            a, b = y0, y1\n            fixed_coord = 'x'\n            \n        jac = (b - a) / 2.0\n        \n        for i in range(m_order):\n            xi, wi = points[i], weights[i]\n            # Affine map from [-1,1] to [a,b]\n            t = jac * xi + (a + b) / 2.0\n            \n            coords = {'x': t, 'y': fixed_val} if int_var == 'x' else {'x': fixed_val, 'y': t}\n            \n            integrand_vec = np.array([\n                integrand_funcs[0](coords['x'], coords['y']),\n                integrand_funcs[1](coords['x'], coords['y'])\n            ])\n            edge_integral += wi * integrand_vec\n            \n        total_integral += jac * edge_integral\n        \n    return total_integral\n\ndef compute_area_integral(domain, n_orders, b_funcs):\n    \"\"\"\n    Computes the area integral of b over a rectangular domain.\n    \"\"\"\n    x0, x1, y0, y1 = domain\n    nx, ny = n_orders\n    bx, by = b_funcs['x'], b_funcs['y']\n    \n    points_x, weights_x = roots_legendre(nx)\n    points_y, weights_y = roots_legendre(ny)\n    \n    jac_x = (x1 - x0) / 2.0\n    jac_y = (y1 - y0) / 2.0\n    jac_area = jac_x * jac_y\n    \n    total_integral = np.zeros(2, dtype=float)\n    \n    for j in range(ny):\n        eta, wj = points_y[j], weights_y[j]\n        y = jac_y * eta + (y0 + y1) / 2.0\n        for i in range(nx):\n            xi, wi = points_x[i], weights_x[i]\n            x = jac_x * xi + (x0 + x1) / 2.0\n            \n            integrand_vec = np.array([bx(x, y), by(x, y)])\n            total_integral += wi * wj * integrand_vec\n            \n    return jac_area * total_integral\n\ndef solve():\n    \"\"\"\n    Solves the problem for all specified test cases.\n    \"\"\"\n    test_cases = [\n        # Test Case 1\n        {\n            \"domain\": (0., 1., 0., 1.),\n            \"quad_orders\": (2, (2, 2)), # m, (nx, ny)\n            \"sigma\": {\n                \"xx\": lambda x, y: 2*x + 3*y + 1,\n                \"xy\": lambda x, y: 4*x + 5*y + 2,\n                \"yy\": lambda x, y: -x + 2*y + 0.5,\n            },\n            \"b\": {\n                \"x\": lambda x, y: 2.0 + 5.0,  # d(s_xx)/dx + d(s_xy)/dy\n                \"y\": lambda x, y: 4.0 + 2.0,  # d(s_xy)/dx + d(s_yy)/dy\n            },\n        },\n        # Test Case 2\n        {\n            \"domain\": (0., 1., 0., 1.),\n            \"quad_orders\": (1, (1, 1)),\n            \"sigma\": {\n                \"xx\": lambda x, y: x**3 + 2*x**2*y + x*y**2 + y**3 + x**2 + y**2 + x + y + 1,\n                \"xy\": lambda x, y: x**2*y + x*y**2 + x**2 + y**2 + x + y + 1,\n                \"yy\": lambda x, y: 2*x**3 + x**2*y + x*y**2 + 0.5*y**3 + x**2 + y**2 + x + y,\n            },\n            \"b\": {\n                \"x\": lambda x, y: (3*x**2 + 4*x*y + y**2 + 2*x + 1) + (x**2 + 2*x*y + 2*y + 1),\n                \"y\": lambda x, y: (2*x*y + y**2 + 2*x + 1) + (x**2 + 2*x*y + 1.5*y**2 + 2*y + 1),\n            },\n        },\n        # Test Case 3\n        {\n            \"domain\": (-1., 2., 0., 3.),\n            \"quad_orders\": (3, (3, 3)),\n            \"sigma\": {\n                \"xx\": lambda x, y: 3*x**2 + 2*x*y + y**2 + x + 2*y + 1,\n                \"xy\": lambda x, y: -x**2 + 3*x*y + 2*y**2 + 0.1*x + 0.2*y + 0.3,\n                \"yy\": lambda x, y: 2*x**2 - x*y + 4*y**2 + 0.5*x + 1.5*y + 2,\n            },\n            \"b\": {\n                \"x\": lambda x, y: (6*x + 2*y + 1) + (3*x + 4*y + 0.2),\n                \"y\": lambda x, y: (-2*x + 3*y + 0.1) + (-x + 8*y + 1.5),\n            },\n        },\n        # Test Case 4\n        {\n            \"domain\": (0., 0.01, 0., 0.02),\n            \"quad_orders\": (5, (5, 5)),\n            \"sigma\": {\n                \"xx\": lambda x, y: 0.1*x**3 + 0.2*x**2*y + 0.3*x*y**2 + 0.4*y**3 + 0.5*x + 0.6*y + 0.7,\n                \"xy\": lambda x, y: 0.2*x**2*y + 0.1*x*y**2 + 0.3*x**2 + 0.4*y**2 + 0.5*x + 0.6*y + 0.1,\n                \"yy\": lambda x, y: 0.3*x**3 + 0.1*x**2*y + 0.2*x*y**2 + 0.5*y**3 + 0.4*x + 0.3*y + 0.2,\n            },\n            \"b\": {\n                \"x\": lambda x, y: (0.3*x**2 + 0.4*x*y + 0.3*y**2 + 0.5) + (0.2*x**2 + 0.2*x*y + 0.8*y + 0.6),\n                \"y\": lambda x, y: (0.4*x*y + 0.1*y**2 + 0.6*x + 0.5) + (0.1*x**2 + 0.4*x*y + 1.5*y**2 + 0.3),\n            },\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        domain = case[\"domain\"]\n        m_order, n_orders = case[\"quad_orders\"]\n        sigma_funcs = case[\"sigma\"]\n        b_funcs = case[\"b\"]\n        \n        boundary_int = compute_boundary_integral(domain, m_order, sigma_funcs)\n        area_int = compute_area_integral(domain, n_orders, b_funcs)\n        \n        residual_vector = boundary_int - area_int\n        residual_norm = np.linalg.norm(residual_vector)\n        \n        results.append(residual_norm)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.15f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Beyond verification, the Gauss divergence theorem is a cornerstone of advanced computational algorithms that improve simulation accuracy and efficiency. This exercise guides you in building a practical *a posteriori* error estimator, a tool that identifies regions in a simulation where the numerical solution is least accurate. By calculating the integrated equilibrium residual $\\boldsymbol{R}_\\omega = \\int_{\\omega} (\\nabla \\cdot \\boldsymbol{\\sigma} + \\boldsymbol{b}) \\, dV$ for various subdomains, you will create an 'eigenstress detector' that can guide adaptive mesh refinement strategies in real-world engineering simulations .",
            "id": "3567232",
            "problem": "You are tasked with designing and implementing an \"eigenstress detector\" for two-dimensional static linear momentum balance in computational solid mechanics, grounded in the Gauss divergence theorem. The detector must compute the net traction flux across subdomain boundaries by converting boundary integrals into volume integrals, then quantify and rank subdomain imbalance to inform adaptive mesh refinement. The derivation and implementation must begin solely from the fundamentals of continuum mechanics and vector calculus, without shortcut formulas.\n\nThe setting is a two-dimensional body occupying a rectangular region in the plane with unit out-of-plane thickness (that is, thickness equal to $1\\,\\mathrm{m}$). Let the Cauchy stress tensor field be denoted by $\\boldsymbol{\\sigma}(\\boldsymbol{x}) \\in \\mathbb{R}^{2 \\times 2}$, where $\\boldsymbol{x} = (x,y)$, and let the body force per unit volume be $\\boldsymbol{b}(\\boldsymbol{x}) \\in \\mathbb{R}^2$. The balance of linear momentum in the static case states that $\\nabla \\cdot \\boldsymbol{\\sigma} + \\boldsymbol{b} = \\boldsymbol{0}$ in the absence of inertia. The Gauss divergence theorem relates the net boundary traction flux to a volume integral of the divergence of the stress tensor. The traction vector on a boundary with outward unit normal $\\boldsymbol{n}$ is $\\boldsymbol{t} = \\boldsymbol{\\sigma} \\boldsymbol{n}$.\n\nStarting from these fundamentals, derive the expression for the net traction flux across the boundary $\\partial \\omega$ of any rectangular subdomain $\\omega \\subset \\mathbb{R}^2$ of unit thickness,\n$$\n\\int_{\\partial \\omega} \\boldsymbol{\\sigma}\\,\\boldsymbol{n}\\, \\mathrm{d}S,\n$$\nin terms of a volume integral over $\\omega$. Define the integrated equilibrium residual over $\\omega$ as\n$$\n\\boldsymbol{R}_\\omega \\equiv \\int_{\\omega} \\left(\\nabla \\cdot \\boldsymbol{\\sigma} + \\boldsymbol{b}\\right) \\, \\mathrm{d}V,\n$$\nand the imbalance magnitude\n$$\nI_\\omega \\equiv \\left\\|\\boldsymbol{R}_\\omega\\right\\|.\n$$\nThis $I_\\omega$ is the detector you will compute and use to rank subdomains. All physical units must be consistent with the International System of Units. Report $I_\\omega$ in Newtons ($\\mathrm{N}$). If any trigonometric functions appear, use angles in radians.\n\nImplement a program that, for each test case below, performs the following for each listed rectangular subdomain $\\omega$:\n- Compute the net traction flux using the Gauss divergence theorem as a volume integral of $\\nabla \\cdot \\boldsymbol{\\sigma}$ over $\\omega$ with unit thickness.\n- Compute the volume integral of the body force $\\boldsymbol{b}$ over $\\omega$.\n- Compute $\\boldsymbol{R}_\\omega = \\int_{\\omega} \\left(\\nabla \\cdot \\boldsymbol{\\sigma} + \\boldsymbol{b}\\right) \\mathrm{d}V$ and its magnitude $I_\\omega$ in Newtons, rounded to eight decimal places.\n- Rank the subdomains by $I_\\omega$ in descending order. In the case of ties, rank by ascending subdomain index.\nIndex subdomains in the order they are specified (starting at $1$).\n\nUse tensor notation where $\\left(\\nabla \\cdot \\boldsymbol{\\sigma}\\right)_i = \\sum_{j=1}^2 \\frac{\\partial \\sigma_{ij}}{\\partial x_j}$ and $\\sigma_{xy} = \\sigma_{yx}$ (stress symmetry). In all integrals, interpret $\\mathrm{d}V$ as $\\mathrm{d}A$ multiplied by unit thickness, because subdomains are two-dimensional with unit thickness.\n\nTest Suite:\n- Test Case 1 (equilibrium polynomial field; happy path):\n  - Global domain: $[0,1]\\times[0,1]$.\n  - Subdomains:\n    1. $\\omega_1 = [0.0,\\,0.5]\\times[0.0,\\,0.5]$,\n    2. $\\omega_2 = [0.5,\\,1.0]\\times[0.0,\\,0.5]$,\n    3. $\\omega_3 = [0.0,\\,1.0]\\times[0.5,\\,1.0]$.\n  - Stress field:\n    $$\n    \\sigma_{xx} = 2x^3 + y^2,\\quad \\sigma_{yy} = 3y^3 + x^2,\\quad \\sigma_{xy} = \\sigma_{yx} = xy.\n    $$\n  - Body force defined to satisfy equilibrium:\n    $$\n    \\boldsymbol{b}(x,y) = -\\nabla \\cdot \\boldsymbol{\\sigma}(x,y).\n    $$\n  - Quadrature order: use a tensor-product Gauss–Legendre rule with $5$ points per direction.\n\n- Test Case 2 (non-equilibrium polynomial field; residual present):\n  - Global domain: $[0,1]\\times[0,1]$.\n  - Subdomains: same as Test Case 1.\n  - Stress field: same as Test Case 1.\n  - Body force:\n    $$\n    \\boldsymbol{b}(x,y) = \\boldsymbol{0}.\n    $$\n  - Quadrature order: $5$ points per direction.\n\n- Test Case 3 (oscillatory stress; edge-case coverage with small and skewed subdomains):\n  - Global domain: $[0,1]\\times[0,1]$, angle unit: radians.\n  - Subdomains:\n    1. $\\omega_1 = [0.25,\\,0.35]\\times[0.60,\\,0.90]$,\n    2. $\\omega_2 = [0.60,\\,0.99]\\times[0.01,\\,0.20]$,\n    3. $\\omega_3 = [0.90,\\,1.00]\\times[0.90,\\,1.00]$.\n  - Stress field with amplitude $A = 10^5\\,\\mathrm{Pa}$:\n    $$\n    \\sigma_{xx} = A \\sin(3\\pi x)\\cos(2\\pi y),\\quad\n    \\sigma_{yy} = A \\cos(2\\pi x)\\sin(3\\pi y),\\quad\n    \\sigma_{xy} = \\sigma_{yx} = \\tfrac{A}{2}\\sin(2\\pi x)\\sin(2\\pi y).\n    $$\n  - Body force:\n    $$\n    \\boldsymbol{b}(x,y) = \\boldsymbol{0}.\n    $$\n  - Quadrature order: $40$ points per direction.\n\nFinal Output Specification:\n- Your program should produce a single line of output containing the results for all three test cases. For each test case, output a pair of lists in the form $[\\,[I_{\\omega_1}, I_{\\omega_2}, I_{\\omega_3}],\\,[r_1, r_2, r_3]\\,]$, where $I_{\\omega_k}$ are the imbalance magnitudes in $\\mathrm{N}$ rounded to eight decimal places, and $[r_1, r_2, r_3]$ are the subdomain indices sorted in descending imbalance magnitude (ties broken by ascending index).\n- Aggregate the three test cases into a single list, so the final output format is a single line representing a list of three elements:\n$$\n\\big[\\,[\\,[I_{\\omega_1},I_{\\omega_2},I_{\\omega_3}],\\,[r_1,r_2,r_3]\\,],\\;[\\,[\\cdot],\\,[\\cdot]\\,],\\;[\\,[\\cdot],\\,[\\cdot]\\,]\\,\\big].\n$$\nFor example: \n$[[[0.0,0.0,0.0],[1,2,3]],[[\\dots],[\\dots]],[[\\dots],[\\dots]]]$.",
            "solution": "The problem requires the design and implementation of an \"eigenstress detector\" to quantify equilibrium imbalance in subdomains of a two-dimensional solid body. This will be achieved by calculating the integrated equilibrium residual, $\\boldsymbol{R}_\\omega$, for each subdomain $\\omega$. The solution is derived from the fundamental principles of continuum mechanics and vector calculus.\n\n**1. Theoretical Derivation**\n\nThe static balance of linear momentum is given by the equilibrium equation $\\nabla \\cdot \\boldsymbol{\\sigma} + \\boldsymbol{b} = \\boldsymbol{0}$, where $\\boldsymbol{\\sigma}$ is the Cauchy stress tensor and $\\boldsymbol{b}$ is the body force per unit volume. The problem asks for the evaluation of the net traction flux, $\\int_{\\partial \\omega} \\boldsymbol{\\sigma}\\,\\boldsymbol{n}\\, \\mathrm{d}S$, across the boundary $\\partial \\omega$ of a subdomain $\\omega$.\n\nThe Gauss divergence theorem relates a boundary integral of a field to the volume integral of its divergence. For a tensor field like $\\boldsymbol{\\sigma}$, the theorem states:\n$$\n\\int_{\\partial \\omega} \\boldsymbol{\\sigma} \\boldsymbol{n} \\, \\mathrm{d}S = \\int_{\\omega} (\\nabla \\cdot \\boldsymbol{\\sigma}) \\, \\mathrm{d}V\n$$\nHere, $\\boldsymbol{n}$ is the outward unit normal to the boundary $\\partial \\omega$. The left-hand side is the net traction flux, which represents the total force exerted by the material outside $\\omega$ onto the boundary of $\\omega$. The right-hand side is the volume integral of the stress divergence over the subdomain. This equation provides the required expression for the net traction flux in terms of a volume integral.\n\nThe integrated equilibrium residual $\\boldsymbol{R}_\\omega$ is defined as:\n$$\n\\boldsymbol{R}_\\omega \\equiv \\int_{\\omega} \\left(\\nabla \\cdot \\boldsymbol{\\sigma} + \\boldsymbol{b}\\right) \\, \\mathrm{d}V\n$$\nThis vector quantity, $\\boldsymbol{R}_\\omega$, represents the net force on the subdomain $\\omega$, considering both internal stress gradients (via the traction flux) and external body forces. If the subdomain is in static equilibrium, this resultant force must be zero. A non-zero $\\boldsymbol{R}_\\omega$ indicates an imbalance, or a \"residual\" in the equilibrium equation when integrated over $\\omega$.\n\nThe \"eigenstress detector\" is then defined as the Euclidean norm of this residual vector:\n$$\nI_\\omega \\equiv \\left\\|\\boldsymbol{R}_\\omega\\right\\| = \\left\\| \\int_{\\omega} \\left(\\nabla \\cdot \\boldsymbol{\\sigma} + \\boldsymbol{b}\\right) \\, \\mathrm{d}V \\right\\|\n$$\nThis scalar value $I_\\omega$, in units of Newtons ($\\mathrm{N}$), quantifies the magnitude of the equilibrium imbalance for subdomain $\\omega$.\n\n**2. Computational Method**\n\nTo compute $I_\\omega$ for a given rectangular subdomain $\\omega = [x_{min}, x_{max}] \\times [y_{min}, y_{max}]$, we need to evaluate the two-dimensional vector integral of the function $\\boldsymbol{f}(x,y) = \\nabla \\cdot \\boldsymbol{\\sigma}(x,y) + \\boldsymbol{b}(x,y)$. The problem specifies a unit thickness of $1\\,\\mathrm{m}$, so the volume element $\\mathrm{d}V$ becomes $\\mathrm{d}A \\cdot (1\\,\\mathrm{m}) = \\mathrm{d}x\\,\\mathrm{d}y \\cdot (1\\,\\mathrm{m})$.\n\nThe integrals are computed numerically using a tensor-product Gauss-Legendre quadrature rule. For a function $g(x,y)$, the integral over $\\omega$ is approximated as follows. First, we map the physical domain $[x_{min}, x_{max}] \\times [y_{min}, y_{max}]$ to the canonical domain $[-1, 1] \\times [-1, 1]$ using the linear transformations:\n$$\nx(\\xi) = \\frac{x_{max}-x_{min}}{2}\\xi + \\frac{x_{min}+x_{max}}{2}\n$$\n$$\ny(\\eta) = \\frac{y_{max}-y_{min}}{2}\\eta + \\frac{y_{min}+y_{max}}{2}\n$$\nThe integral then becomes:\n$$\n\\int_{y_{min}}^{y_{max}} \\int_{x_{min}}^{x_{max}} g(x,y) \\, \\mathrm{d}x \\, \\mathrm{d}y = \\frac{(x_{max}-x_{min})(y_{max}-y_{min})}{4} \\int_{-1}^{1} \\int_{-1}^{1} g\\left(x(\\xi), y(\\eta)\\right) \\, \\mathrm{d}\\xi \\, \\mathrm{d}\\eta\n$$\nUsing an $N$-point Gauss-Legendre quadrature rule with points $\\xi_i, \\eta_j$ and weights $w_i, w_j$, the integral is approximated by the sum:\n$$\n\\approx \\frac{(x_{max}-x_{min})(y_{max}-y_{min})}{4} \\sum_{i=1}^{N} \\sum_{j=1}^{N} w_i w_j g(x(\\xi_i), y(\\eta_j))\n$$\nThis numerical integration is performed for each component of the vector integrand $\\boldsymbol{f}(x,y)$ to find the components of $\\boldsymbol{R}_\\omega = (R_{\\omega,x}, R_{\\omega,y})$. The imbalance $I_\\omega$ is then $\\sqrt{R_{\\omega,x}^2 + R_{\\omega,y}^2}$.\n\n**3. Test Case-Specific Integrands**\n\nThe integrand $\\boldsymbol{f}(x,y) = \\nabla \\cdot \\boldsymbol{\\sigma} + \\boldsymbol{b}$ is derived for each test case.\nThe divergence of the stress tensor $\\boldsymbol{\\sigma}$ is a vector with components:\n$(\\nabla \\cdot \\boldsymbol{\\sigma})_x = \\frac{\\partial \\sigma_{xx}}{\\partial x} + \\frac{\\partial \\sigma_{xy}}{\\partial y}$\n$(\\nabla \\cdot \\boldsymbol{\\sigma})_y = \\frac{\\partial \\sigma_{yx}}{\\partial x} + \\frac{\\partial \\sigma_{yy}}{\\partial y}$\n\n- **Test Case 1**: With $\\boldsymbol{b} = -\\nabla \\cdot \\boldsymbol{\\sigma}$, the integrand is $\\boldsymbol{f}(x,y) = \\boldsymbol{0}$. Thus, $\\boldsymbol{R}_\\omega = \\boldsymbol{0}$ and $I_\\omega = 0$ analytically. The numerical result should be close to zero, subject to floating-point precision.\n\n- **Test Case 2**: With $\\sigma_{xx} = 2x^3 + y^2$, $\\sigma_{yy} = 3y^3 + x^2$, $\\sigma_{xy} = xy$, and $\\boldsymbol{b} = \\boldsymbol{0}$, the integrand is $\\boldsymbol{f}(x,y) = \\nabla \\cdot \\boldsymbol{\\sigma}$.\n$$\n(\\nabla \\cdot \\boldsymbol{\\sigma})_x = \\frac{\\partial}{\\partial x}(2x^3 + y^2) + \\frac{\\partial}{\\partial y}(xy) = 6x^2 + x\n$$\n$$\n(\\nabla \\cdot \\boldsymbol{\\sigma})_y = \\frac{\\partial}{\\partial x}(xy) + \\frac{\\partial}{\\partial y}(3y^3 + x^2) = y + 9y^2\n$$\nThe integrand is $\\boldsymbol{f}(x,y) = (6x^2 + x, 9y^2 + y)$.\n\n- **Test Case 3**: With $\\boldsymbol{b} = \\boldsymbol{0}$ and the given trigonometric stress field with $A=10^5\\,\\mathrm{Pa}$, the integrand is $\\boldsymbol{f}(x,y) = \\nabla \\cdot \\boldsymbol{\\sigma}$.\n$$\n(\\nabla \\cdot \\boldsymbol{\\sigma})_x = \\frac{\\partial}{\\partial x}(A \\sin(3\\pi x)\\cos(2\\pi y)) + \\frac{\\partial}{\\partial y}(\\tfrac{A}{2}\\sin(2\\pi x)\\sin(2\\pi y))\n= 3\\pi A \\cos(3\\pi x)\\cos(2\\pi y) + \\pi A \\sin(2\\pi x)\\cos(2\\pi y)\n$$\n$$\n(\\nabla \\cdot \\boldsymbol{\\sigma})_y = \\frac{\\partial}{\\partial x}(\\tfrac{A}{2}\\sin(2\\pi x)\\sin(2\\pi y)) + \\frac{\\partial}{\\partial y}(A \\cos(2\\pi x)\\sin(3\\pi y))\n= \\pi A \\cos(2\\pi x)\\sin(2\\pi y) + 3\\pi A \\cos(2\\pi x)\\cos(3\\pi y)\n$$\n\n**4. Ranking and Output**\n\nFor each test case, the imbalance magnitudes $I_\\omega$ are computed for all specified subdomains. The values are rounded to eight decimal places. The subdomains are then ranked based on these $I_\\omega$ values in descending order. Any ties in magnitude are resolved by ranking the subdomain with the lower original index first. The final output is structured as a list of lists, encapsulating the imbalance values and the ranked indices for each test case.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the eigenstress detector problem for three test cases.\n    \"\"\"\n\n    def integrate_2d_vector(func_x, func_y, x_bounds, y_bounds, n_points):\n        \"\"\"\n        Performs 2D Gauss-Legendre quadrature for a vector function over a rectangular domain.\n\n        Args:\n            func_x: The x-component of the vector integrand function f(x, y).\n            func_y: The y-component of the vector integrand function f(x, y).\n            x_bounds: A tuple (xmin, xmax) for the integration domain.\n            y_bounds: A tuple (ymin, ymax) for the integration domain.\n            n_points: The number of Gauss points per dimension.\n\n        Returns:\n            A tuple (integral_x, integral_y) representing the vector result of the integration.\n        \"\"\"\n        gauss_pts, gauss_wts = np.polynomial.legendre.leggauss(n_points)\n        x_min, x_max = x_bounds\n        y_min, y_max = y_bounds\n        \n        # Jacobian factor for change of variables from [-1, 1] to [min, max]\n        jac_factor = (x_max - x_min) * (y_max - y_min) / 4.0\n\n        integral_x = 0.0\n        integral_y = 0.0\n\n        for i in range(n_points):\n            xi, wi = gauss_pts[i], gauss_wts[i]\n            # Map canonical coordinate xi to physical coordinate x\n            x = (x_max - x_min) / 2.0 * xi + (x_min + x_max) / 2.0\n            \n            for j in range(n_points):\n                eta, wj = gauss_pts[j], gauss_wts[j]\n                # Map canonical coordinate eta to physical coordinate y\n                y = (y_max - y_min) / 2.0 * eta + (y_min + y_max) / 2.0\n                \n                # Evaluate integrand components at physical point (x, y)\n                fx_val = func_x(x, y)\n                fy_val = func_y(x, y)\n                \n                # Accumulate the weighted sum\n                integral_x += wi * wj * fx_val\n                integral_y += wi * wj * fy_val\n        \n        integral_x *= jac_factor\n        integral_y *= jac_factor\n        \n        return (integral_x, integral_y)\n\n    # Test Case 1: Equilibrium polynomial field\n    case1_subdomains = [\n        ((0.0, 0.5), (0.0, 0.5)),  # omega_1\n        ((0.5, 1.0), (0.0, 0.5)),  # omega_2\n        ((0.0, 1.0), (0.5, 1.0)),  # omega_3\n    ]\n    # Integrand is identically zero since b = -div(sigma)\n    case1_integrand = (lambda x, y: 0.0, lambda x, y: 0.0)\n    case1_quad_order = 5\n\n    # Test Case 2: Non-equilibrium polynomial field\n    case2_subdomains = case1_subdomains\n    # div(sigma)_x = 6x^2 + x; div(sigma)_y = 9y^2 + y. b = 0.\n    case2_integrand = (lambda x, y: 6*x**2 + x, lambda x, y: 9*y**2 + y)\n    case2_quad_order = 5\n\n    # Test Case 3: Oscillatory stress field\n    case3_subdomains = [\n        ((0.25, 0.35), (0.60, 0.90)),  # omega_1\n        ((0.60, 0.99), (0.01, 0.20)),  # omega_2\n        ((0.90, 1.00), (0.90, 1.00)),  # omega_3\n    ]\n    A = 1e5\n    # div(sigma)_x = A*pi*cos(2*pi*y)*(3*cos(3*pi*x) + sin(2*pi*x))\n    # div(sigma)_y = A*pi*cos(2*pi*x)*(sin(2*pi*y) + 3*cos(3*pi*y))\n    case3_integrand = (\n        lambda x, y: A * np.pi * np.cos(2*np.pi*y) * (3*np.cos(3*np.pi*x) + np.sin(2*np.pi*x)),\n        lambda x, y: A * np.pi * np.cos(2*np.pi*x) * (np.sin(2*np.pi*y) + 3*np.cos(3*np.pi*y))\n    )\n    case3_quad_order = 40\n\n    test_cases = [\n        (case1_subdomains, case1_integrand, case1_quad_order),\n        (case2_subdomains, case2_integrand, case2_quad_order),\n        (case3_subdomains, case3_integrand, case3_quad_order),\n    ]\n\n    all_results_str = []\n    for subdomains, (integrand_x, integrand_y), quad_order in test_cases:\n        imbalances = []\n        # Store (imbalance_magnitude, original_index) for sorting\n        imbalance_tuples = []\n        \n        for i, (x_bounds, y_bounds) in enumerate(subdomains):\n            # Compute R_omega vector\n            Rx, Ry = integrate_2d_vector(integrand_x, integrand_y, x_bounds, y_bounds, quad_order)\n            \n            # Compute imbalance magnitude I_omega and round it\n            I_omega = np.sqrt(Rx**2 + Ry**2)\n            rounded_I_omega = round(I_omega, 8)\n            \n            imbalances.append(rounded_I_omega)\n            imbalance_tuples.append((rounded_I_omega, i + 1)) # Use 1-based indexing as per spec\n            \n        # Sort by imbalance (desc) and then index (asc)\n        imbalance_tuples.sort(key=lambda t: (-t[0], t[1]))\n        \n        ranked_indices = [t[1] for t in imbalance_tuples]\n        \n        # Format strings for final output, ensuring 8 decimal places\n        I_str = \",\".join([f\"{val:.8f}\" for val in imbalances])\n        r_str = \",\".join(map(str, ranked_indices))\n        \n        case_str = f\"[[{I_str}],[{r_str}]]\"\n        all_results_str.append(case_str)\n        \n    # Combine all case results into a single string\n    final_output = f\"[{','.join(all_results_str)}]\"\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}