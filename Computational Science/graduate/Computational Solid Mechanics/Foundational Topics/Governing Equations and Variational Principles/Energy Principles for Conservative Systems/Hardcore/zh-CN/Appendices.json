{
    "hands_on_practices": [
        {
            "introduction": "超弹性模型的基石是应变能函数，它将材料的应力状态与一个标量势函数联系起来。本练习将指导您从一个给定的应变能密度函数出发，推导出不同形式的应力张量（第一和第二Piola-Kirchhoff应力），并从计算上验证它们在能量上的等价性。这项实践旨在连接抽象的张量微积分与具体的数值计算，加深您对功共轭对概念的理解。",
            "id": "3561581",
            "problem": "考虑一个三维、均匀、各向同性的超弹性固体，其单位参考体积的应变能密度由可压缩 Neo-Hookean 模型给出\n$$\n\\Psi(\\mathbf{F}) = \\frac{\\mu}{2}\\left(\\operatorname{tr}(\\mathbf{C}) - 3\\right) - \\mu \\ln J + \\frac{\\kappa}{2} (\\ln J)^2,\n$$\n其中 $\\mathbf{F}$ 是变形梯度，$\\mathbf{C} = \\mathbf{F}^{\\mathsf{T}}\\mathbf{F}$ 是右 Cauchy-Green 变形张量，$J = \\det(\\mathbf{F}) > 0$ 是雅可比行列式，而 $\\mu > 0$ 和 $\\kappa > 0$ 是材料常数（分别为剪切模量和体积模量）。令 $U$ 表示储存在体积为 $V_0$ 的参考构型体 $\\mathcal{B}_0$ 中的总内能，因此 $U = \\int_{\\mathcal{B}_0} \\Psi(\\mathbf{F}) \\,\\mathrm{d}V_0$。\n\n仅从保守系统的能量原理基本陈述和核心定义（超弹性、功共轭、标架无关性以及构型间的变量变换）出发，完成以下任务：\n\n1. 从第一性原理出发，推导第一 Piola-Kirchhoff 应力 $\\mathbf{P}$、第二 Piola-Kirchhoff 应力 $\\mathbf{S}$ 和 Cauchy 应力 $\\boldsymbol{\\sigma}$ 关于给定应变能密度 $\\Psi(\\mathbf{F})$ 的表达式。然后，用这些表达式证明以下能量共轭对应于内能一阶变分 $\\delta U$ 的等价性：\n   - 对偶 $(\\mathbf{F}, \\mathbf{P})$ 满足\n     $$\n     \\delta U = \\int_{\\mathcal{B}_0} \\mathbf{P} : \\delta \\mathbf{F} \\,\\mathrm{d}V_0,\n     $$\n     其中 $:$ 是双点积，$\\delta \\mathbf{F}$ 是 $\\mathbf{F}$ 的一个容许的虚变分。\n   - 对偶 $(\\mathbf{C}, \\mathbf{S})$ 满足\n     $$\n     \\delta U = \\frac{1}{2} \\int_{\\mathcal{B}_0} \\mathbf{S} : \\delta \\mathbf{C} \\,\\mathrm{d}V_0,\n     $$\n     其中 $\\delta \\mathbf{C} = \\mathbf{F}^{\\mathsf{T}}\\delta \\mathbf{F} + \\delta \\mathbf{F}^{\\mathsf{T}} \\mathbf{F}$。\n   - 在小应变假设（线性化运动学）下，对偶 $(\\boldsymbol{\\varepsilon}, \\boldsymbol{\\sigma})$ 满足\n     $$\n     \\delta U \\approx \\int_{\\mathcal{B}} \\boldsymbol{\\sigma} : \\delta \\boldsymbol{\\varepsilon} \\,\\mathrm{d}v,\n     $$\n     其中 $\\boldsymbol{\\varepsilon} \\approx \\frac{1}{2}((\\mathbf{F}-\\mathbf{I}) + (\\mathbf{F}-\\mathbf{I})^\\mathsf{T})$ 是对称小应变张量，$\\delta \\boldsymbol{\\varepsilon} \\approx \\frac{1}{2}\\left(\\delta \\mathbf{F} + \\delta \\mathbf{F}^{\\mathsf{T}}\\right)$ 是其虚变分，而 $\\mathrm{d}v$ 是当前体积微元。利用构型间的变量变换，精确说明在何种情况下 $\\mathrm{d}v \\approx \\mathrm{d}V_0$ 是合理的，并在能量共轭对等价性的背景下解释该近似。\n\n2. 实现一个程序，对于指定的材料参数和运动学数据 $(\\mathbf{F}, \\delta \\mathbf{F})$，在相同的变形和虚变分下，使用所有三个共轭对计算 $\\delta U$，并报告每个测试用例的三个值：\n   - 使用 $(\\mathbf{F}, \\mathbf{P})$：计算 $\\delta U_{\\mathbf{P}} = \\int_{\\mathcal{B}_0} \\mathbf{P} : \\delta \\mathbf{F} \\,\\mathrm{d}V_0$。\n   - 使用 $(\\mathbf{C}, \\mathbf{S})$：计算 $\\delta U_{\\mathbf{S}} = \\frac{1}{2}\\int_{\\mathcal{B}_0} \\mathbf{S} : \\delta \\mathbf{C} \\,\\mathrm{d}V_0$。\n   - 在小应变线弹性下使用 $(\\boldsymbol{\\varepsilon}, \\boldsymbol{\\sigma})$：计算 $\\delta U_{\\boldsymbol{\\sigma}} = \\int_{\\mathcal{B}_0} \\boldsymbol{\\sigma}_{\\text{lin}} : \\delta \\boldsymbol{\\varepsilon} \\,\\mathrm{d}V_0$，其中 $\\boldsymbol{\\sigma}_{\\text{lin}} = \\lambda \\operatorname{tr}(\\boldsymbol{\\varepsilon}) \\mathbf{I} + 2\\mu \\boldsymbol{\\varepsilon}$ 且 $\\lambda = \\kappa - \\tfrac{2}{3}\\mu$ 是 Lamé 参数。为与小应变假设保持一致，取 $\\mathrm{d}v \\approx \\mathrm{d}V_0$。\n\n使用以下测试套件。在每个案例中，将所有矩阵分量解释为无量纲，$\\mu$ 和 $\\kappa$ 的单位为帕斯卡， $V_0$ 的单位为 $\\mathrm{m}^3$，并以焦耳为单位报告 $\\delta U$。角度必须以弧度为单位。\n\n- 测试用例 1 (一般小应变，理想情况)：\n  - $V_0 = 1.0$，\n  - $\\mu = 8.0\\times 10^{4}$，\n  - $\\kappa = 1.6\\times 10^{5}$，\n  - $\\mathbf{F} = \\mathbf{I} + \\begin{bmatrix}\n  1.0\\times 10^{-3}  2.0\\times 10^{-4}  0 \\\\\n  0  -5.0\\times 10^{-4}  3.0\\times 10^{-4} \\\\\n  0  0  4.0\\times 10^{-4}\n  \\end{bmatrix}$，\n  - $\\delta \\mathbf{F} = \\begin{bmatrix}\n  1.0\\times 10^{-4}  2.0\\times 10^{-5}  0 \\\\\n  -2.0\\times 10^{-5}  -1.0\\times 10^{-5}  1.0\\times 10^{-5} \\\\\n  0  -1.0\\times 10^{-5}  3.0\\times 10^{-5}\n  \\end{bmatrix}$。\n\n- 测试用例 2 (纯旋转边界；标架无关性)：\n  - $V_0 = 0.8$，\n  - $\\mu = 1.2\\times 10^{5}$，\n  - $\\kappa = 2.4\\times 10^{5}$，\n  - 令 $\\theta = 1.0\\times 10^{-3}$ 为绕 $z$ 轴的旋转（弧度）。定义旋转\n    $$\n    \\mathbf{R} = \\begin{bmatrix}\n    \\cos\\theta  -\\sin\\theta  0 \\\\\n    \\sin\\theta  \\cos\\theta  0 \\\\\n    0  0  1\n    \\end{bmatrix}, \\quad \\mathbf{F} = \\mathbf{R}.\n    $$\n    令 $\\delta \\theta = 5.0\\times 10^{-4}$ 并定义斜对称生成元\n    $$\n    \\mathbf{W} = \\begin{bmatrix}\n    0  -\\delta \\theta  0 \\\\\n    \\delta \\theta  0  0 \\\\\n    0  0  0\n    \\end{bmatrix}, \\quad \\delta \\mathbf{F} = \\mathbf{R}\\mathbf{W}.\n    $$\n\n- 测试用例 3 (近不可压缩边界情况)：\n  - $V_0 = 1.0$，\n  - $\\mu = 8.0\\times 10^{4}$，\n  - $\\kappa = 8.0\\times 10^{7}$，\n  - $\\mathbf{F} = \\operatorname{diag}(1.002, 1.002, 0.996)$，\n  - $\\delta \\mathbf{F} = 1.0\\times 10^{-4}\\,\\mathbf{I}$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。每个条目应是一个包含三个浮点数的列表，对应于按上述顺序列出的测试用例的 $[\\delta U_{\\mathbf{P}}, \\delta U_{\\mathbf{S}}, \\delta U_{\\boldsymbol{\\sigma}}]$。例如，输出必须如下所示\n$$\n[[\\delta U_{\\mathbf{P}}^{(1)},\\delta U_{\\mathbf{S}}^{(1)},\\delta U_{\\boldsymbol{\\sigma}}^{(1)}],[\\delta U_{\\mathbf{P}}^{(2)},\\delta U_{\\mathbf{S}}^{(2)},\\delta U_{\\boldsymbol{\\sigma}}^{(2)}],[\\delta U_{\\mathbf{P}}^{(3)},\\delta U_{\\mathbf{S}}^{(3)},\\delta U_{\\boldsymbol{\\sigma}}^{(3)}]].\n$$\n所有数值答案必须以焦耳为单位，并在输出行中以标准 Python 浮点数形式打印，不带单位。不允许外部输入；程序必须是自包含的，且必须能直接运行。",
            "solution": "该问题是有效的，将通过首先从第一性原理推导所需的理论关系，然后对给定的测试用例进行数值实现来解决。该分析假设一个均匀变形，这使得对参考体 $\\mathcal{B}_0$ 的积分可以替换为被积函数（在恒定变形梯度 $\\mathbf{F}$ 处取值）与参考体积 $V_0$ 的乘积。\n\n### 第 1 部分：推导与理论分析\n\n#### 应力张量的推导\n\n超弹性的基础是应力状态可以从一个标量势（应变能密度函数 $\\Psi$）推导得出。对于一个保守系统，总内能的一阶变分 $\\delta U$ 等于内力所做的虚功。\n\n**1. 第一 Piola-Kirchhoff 应力 ($\\mathbf{P}$)**\n\n第一 Piola-Kirchhoff 应力张量 $\\mathbf{P}$ 定义为与变形梯度 $\\mathbf{F}$ 能量共轭的应力度量。这通过参考构型中的虚功原理来表达：\n$$\n\\delta U = \\int_{\\mathcal{B}_0} \\mathbf{P} : \\delta \\mathbf{F} \\,\\mathrm{d}V_0\n$$\n其中 $\\delta\\mathbf{F}$ 是 $\\mathbf{F}$ 的虚变分。总内能 $U$ 是应变能密度 $\\Psi$ 在参考体积 $V_0$ 上的积分：\n$$\nU = \\int_{\\mathcal{B}_0} \\Psi(\\mathbf{F}) \\,\\mathrm{d}V_0\n$$\n因此，$\\delta U$ 的变分为：\n$$\n\\delta U = \\delta \\int_{\\mathcal{B}_0} \\Psi(\\mathbf{F}) \\,\\mathrm{d}V_0 = \\int_{\\mathcal{B}_0} \\delta \\Psi(\\mathbf{F}) \\,\\mathrm{d}V_0 = \\int_{\\mathcal{B}_0} \\frac{\\partial \\Psi}{\\partial \\mathbf{F}} : \\delta \\mathbf{F} \\,\\mathrm{d}V_0\n$$\n比较 $\\delta U$ 的两个表达式，我们确定 $\\mathbf{P}$ 的本构关系：\n$$\n\\mathbf{P} = \\frac{\\partial \\Psi}{\\partial \\mathbf{F}}\n$$\n为对给定的可压缩 Neo-Hookean 模型 $\\Psi(\\mathbf{F}) = \\frac{\\mu}{2}(\\operatorname{tr}(\\mathbf{C}) - 3) - \\mu \\ln J + \\frac{\\kappa}{2} (\\ln J)^2$ 计算此式，我们需要以下张量导数：\n-   $\\frac{\\partial \\operatorname{tr}(\\mathbf{C})}{\\partial \\mathbf{F}} = \\frac{\\partial \\operatorname{tr}(\\mathbf{F}^{\\mathsf{T}}\\mathbf{F})}{\\partial \\mathbf{F}} = 2\\mathbf{F}$\n-   $\\frac{\\partial J}{\\partial \\mathbf{F}} = J \\mathbf{F}^{-\\mathsf{T}}$ (雅可比公式)，这意味着 $\\frac{\\partial (\\ln J)}{\\partial \\mathbf{F}} = \\frac{1}{J} \\frac{\\partial J}{\\partial \\mathbf{F}} = \\mathbf{F}^{-\\mathsf{T}}$\n-   $\\frac{\\partial (\\ln J)^2}{\\partial \\mathbf{F}} = 2(\\ln J) \\frac{\\partial (\\ln J)}{\\partial \\mathbf{F}} = 2(\\ln J) \\mathbf{F}^{-\\mathsf{T}}$\n\n将这些代入 $\\Psi$ 的导数中：\n$$\n\\mathbf{P} = \\frac{\\partial \\Psi}{\\partial \\mathbf{F}} = \\frac{\\mu}{2}(2\\mathbf{F}) - \\mu(\\mathbf{F}^{-\\mathsf{T}}) + \\frac{\\kappa}{2}(2(\\ln J)\\mathbf{F}^{-\\mathsf{T}})\n$$\n$$\n\\mathbf{P} = \\mu \\mathbf{F} + (\\kappa \\ln J - \\mu) \\mathbf{F}^{-\\mathsf{T}}\n$$\n\n**2. 第二 Piola-Kirchhoff 应力 ($\\mathbf{S}$)**\n\n第二 Piola-Kirchhoff 应力张量 $\\mathbf{S}$ 与 Green-Lagrange 应变张量 $\\mathbf{E} = \\frac{1}{2}(\\mathbf{C}-\\mathbf{I})$ 能量共轭。其虚功贡献用右 Cauchy-Green 张量 $\\mathbf{C} = \\mathbf{F}^{\\mathsf{T}}\\mathbf{F}$ 的变分表示：\n$$\n\\delta U = \\frac{1}{2}\\int_{\\mathcal{B}_0} \\mathbf{S} : \\delta \\mathbf{C} \\,\\mathrm{d}V_0\n$$\n我们可以将 $\\Psi$ 表示为 $\\mathbf{C}$ 的函数，注意到 $J = \\det(\\mathbf{F}) = \\sqrt{\\det(\\mathbf{C})}$。\n$$\n\\hat{\\Psi}(\\mathbf{C}) = \\frac{\\mu}{2}(\\operatorname{tr}(\\mathbf{C}) - 3) - \\frac{\\mu}{2} \\ln(\\det\\mathbf{C}) + \\frac{\\kappa}{8} (\\ln(\\det\\mathbf{C}))^2\n$$\n变分为 $\\delta \\Psi = \\frac{\\partial \\hat{\\Psi}}{\\partial \\mathbf{C}} : \\delta \\mathbf{C}$。将其与虚功表达式 $\\delta\\Psi = \\frac{1}{2} \\mathbf{S} : \\delta\\mathbf{C}$ 进行比较，我们得到本构关系：\n$$\n\\mathbf{S} = 2 \\frac{\\partial \\hat{\\Psi}}{\\partial \\mathbf{C}}\n$$\n我们计算相对于对称张量 $\\mathbf{C}$ 的导数：\n-   $\\frac{\\partial \\operatorname{tr}(\\mathbf{C})}{\\partial \\mathbf{C}} = \\mathbf{I}$\n-   $\\frac{\\partial \\ln(\\det\\mathbf{C})}{\\partial \\mathbf{C}} = \\mathbf{C}^{-1}$\n-   $\\frac{\\partial (\\ln(\\det\\mathbf{C}))^2}{\\partial \\mathbf{C}} = 2 \\ln(\\det\\mathbf{C}) \\mathbf{C}^{-1} = 4 \\ln J \\mathbf{C}^{-1}$\n\n代入这些结果：\n$$\n\\mathbf{S} = 2 \\left( \\frac{\\mu}{2}\\mathbf{I} - \\frac{\\mu}{2}\\mathbf{C}^{-1} + \\frac{\\kappa}{8}(4 \\ln J \\mathbf{C}^{-1}) \\right)\n$$\n$$\n\\mathbf{S} = \\mu \\mathbf{I} + (\\kappa \\ln J - \\mu) \\mathbf{C}^{-1}\n$$\n\n**3. Cauchy 应力 ($\\boldsymbol{\\sigma}$)**\n\nCauchy 应力 $\\boldsymbol{\\sigma}$，或称真实应力，作用于变形后的构型。它通过前推（push-forward）操作与 $\\mathbf{P}$ 和 $\\mathbf{S}$ 相关联。使用与 $\\mathbf{S}$ 的关系可以确保 $\\boldsymbol{\\sigma}$ 的对称性：\n$$\n\\boldsymbol{\\sigma} = J^{-1} \\mathbf{F} \\mathbf{S} \\mathbf{F}^{\\mathsf{T}}\n$$\n代入 $\\mathbf{S}$ 的表达式：\n$$\n\\boldsymbol{\\sigma} = J^{-1} \\mathbf{F} (\\mu \\mathbf{I} + (\\kappa \\ln J - \\mu) \\mathbf{C}^{-1}) \\mathbf{F}^{\\mathsf{T}}\n$$\n使用 $\\mathbf{C}^{-1} = (\\mathbf{F}^{\\mathsf{T}}\\mathbf{F})^{-1} = \\mathbf{F}^{-1}\\mathbf{F}^{-\\mathsf{T}}$ 并定义左 Cauchy-Green 张量 $\\mathbf{B} = \\mathbf{F}\\mathbf{F}^{\\mathsf{T}}$:\n$$\n\\boldsymbol{\\sigma} = J^{-1} (\\mu \\mathbf{F}\\mathbf{I}\\mathbf{F}^{\\mathsf{T}} + (\\kappa \\ln J - \\mu) \\mathbf{F}\\mathbf{C}^{-1}\\mathbf{F}^{\\mathsf{T}}) = J^{-1} (\\mu \\mathbf{B} + (\\kappa \\ln J - \\mu) \\mathbf{I})\n$$\n\n#### 能量共轭对的等价性\n\n**$(\\mathbf{F}, \\mathbf{P})$ 和 $(\\mathbf{C}, \\mathbf{S})$ 对的等价性：**\n\n我们需要证明 $\\mathbf{P} : \\delta \\mathbf{F} = \\frac{1}{2} \\mathbf{S} : \\delta \\mathbf{C}$。我们从变分 $\\delta\\mathbf{F}$ 和 $\\delta\\mathbf{C}$ 之间的运动学关系开始：\n$$\n\\delta \\mathbf{C} = \\delta(\\mathbf{F}^{\\mathsf{T}}\\mathbf{F}) = \\delta\\mathbf{F}^{\\mathsf{T}}\\mathbf{F} + \\mathbf{F}^{\\mathsf{T}}\\delta\\mathbf{F}\n$$\n现在考虑虚功密度的第二个表达式：\n$$\n\\frac{1}{2} \\mathbf{S} : \\delta \\mathbf{C} = \\frac{1}{2} \\mathbf{S} : (\\delta\\mathbf{F}^{\\mathsf{T}}\\mathbf{F} + \\mathbf{F}^{\\mathsf{T}}\\delta\\mathbf{F}) = \\frac{1}{2}(\\mathbf{S} : \\delta\\mathbf{F}^{\\mathsf{T}}\\mathbf{F} + \\mathbf{S} : \\mathbf{F}^{\\mathsf{T}}\\delta\\mathbf{F})\n$$\n由于 $\\mathbf{S}$ 是对称的（$\\mathbf{S} = \\mathbf{S}^{\\mathsf{T}}$），我们对第一项使用恒等式 $\\mathbf{A}:\\mathbf{B} = \\mathbf{A}^{\\mathsf{T}}:\\mathbf{B}^{\\mathsf{T}}$：\n$$\n\\mathbf{S} : \\delta\\mathbf{F}^{\\mathsf{T}}\\mathbf{F} = \\mathbf{S}^{\\mathsf{T}} : (\\delta\\mathbf{F}^{\\mathsf{T}}\\mathbf{F})^{\\mathsf{T}} = \\mathbf{S} : (\\mathbf{F}^{\\mathsf{T}}\\delta\\mathbf{F})\n$$\n因此，表达式简化为：\n$$\n\\frac{1}{2} \\mathbf{S} : \\delta \\mathbf{C} = \\frac{1}{2}(\\mathbf{S} : \\mathbf{F}^{\\mathsf{T}}\\delta\\mathbf{F} + \\mathbf{S} : \\mathbf{F}^{\\mathsf{T}}\\delta\\mathbf{F}) = \\mathbf{S} : (\\mathbf{F}^{\\mathsf{T}}\\delta\\mathbf{F})\n$$\n使用张量恒等式 $(\\mathbf{AB}):\\mathbf{C} = \\mathbf{B}:(\\mathbf{A}^{\\mathsf{T}}\\mathbf{C})$，我们可以写出：\n$$\n\\mathbf{S} : (\\mathbf{F}^{\\mathsf{T}}\\delta\\mathbf{F}) = (\\mathbf{FS}) : \\delta\\mathbf{F}\n$$\n联系两个 Piola-Kirchhoff 应力的变换法则是 $\\mathbf{P} = \\mathbf{FS}$。代入此式，我们得到：\n$$\n\\frac{1}{2} \\mathbf{S} : \\delta \\mathbf{C} = \\mathbf{P} : \\delta \\mathbf{F}\n$$\n在参考体积 $V_0$ 上对两边积分，证明了 $\\delta U$ 两种形式的等价性。\n\n**在小应变假设下 $(\\boldsymbol{\\varepsilon}, \\boldsymbol{\\sigma})$ 的等价性：**\n\n在小应变假设下，位移梯度 $\\mathbf{H} = \\mathbf{F} - \\mathbf{I}$ 的分量很小，即 $||\\mathbf{H}|| \\ll 1$。这会引出几个近似：\n$1$. 不同应力度量之间的区别消失，即 $\\mathbf{P} \\approx \\mathbf{S} \\approx \\boldsymbol{\\sigma}$。\n$2$. 虚功密度 $\\mathbf{P}:\\delta\\mathbf{F}$ 可以近似为。由于 $\\delta\\mathbf{F} = \\delta\\mathbf{H}$ 且 $\\mathbf{P}\\approx\\boldsymbol{\\sigma}$（它是对称的），我们有：\n$$\n\\mathbf{P}:\\delta\\mathbf{F} \\approx \\boldsymbol{\\sigma}:\\delta\\mathbf{H} = \\boldsymbol{\\sigma}:(\\text{sym}(\\delta\\mathbf{H}) + \\text{skew}(\\delta\\mathbf{H})) = \\boldsymbol{\\sigma}:\\text{sym}(\\delta\\mathbf{H})\n$$\n虚位移梯度的对称部分正是问题中给出的虚小应变张量，$\\delta\\boldsymbol{\\varepsilon} = \\text{sym}(\\delta\\mathbf{F}) = \\frac{1}{2}(\\delta\\mathbf{F} + \\delta\\mathbf{F}^{\\mathsf{T}})$。因此：\n$$\n\\mathbf{P}:\\delta\\mathbf{F} \\approx \\boldsymbol{\\sigma}:\\delta\\boldsymbol{\\varepsilon}\n$$\n$3$. 对于小应变，应力-应变关系变为线性。问题给出了标准的各向同性线弹性关系 $\\boldsymbol{\\sigma} \\approx \\boldsymbol{\\sigma}_{\\text{lin}} = \\lambda \\operatorname{tr}(\\boldsymbol{\\varepsilon})\\mathbf{I} + 2\\mu\\boldsymbol{\\varepsilon}$，其中 $\\boldsymbol{\\varepsilon}$ 是小应变张量，$\\lambda$ 是第一 Lamé 参数。\n$4$. 体积变化由 $\\mathrm{d}v = J \\mathrm{d}V_0$ 给出。对于小应变，$J = \\det(\\mathbf{I}+\\mathbf{H}) \\approx 1+\\operatorname{tr}(\\mathbf{H}) = 1+\\operatorname{tr}(\\boldsymbol{\\varepsilon})$。由于应变很小，$\\operatorname{tr}(\\boldsymbol{\\varepsilon}) \\ll 1$，这为近似 $J \\approx 1$ 从而 $\\mathrm{d}v \\approx \\mathrm{d}V_0$ 提供了依据。这个近似在应变的一阶精度上是准确的。\n\n综合以上几点，我们从精确表达式出发并应用近似：\n$$\n\\delta U = \\int_{\\mathcal{B}_0} \\mathbf{P} : \\delta\\mathbf{F}\\,\\mathrm{d}V_0 \\approx \\int_{\\mathcal{B}_0} \\boldsymbol{\\sigma}_{\\text{lin}} : \\delta\\boldsymbol{\\varepsilon}\\,\\mathrm{d}V_0 \\approx \\int_{\\mathcal{B}} \\boldsymbol{\\sigma}_{\\text{lin}} : \\delta\\boldsymbol{\\varepsilon}\\,\\mathrm{d}v\n$$\n这建立了小应变共轭对 $(\\boldsymbol{\\varepsilon}, \\boldsymbol{\\sigma})$ 的近似等价性。问题给出的公式使用了相一致的近似 $\\delta U_{\\boldsymbol{\\sigma}} = \\int_{\\mathcal{B}_0} \\boldsymbol{\\sigma}_{\\text{lin}} : \\delta \\boldsymbol{\\varepsilon} \\,\\mathrm{d}V_0$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (V0, mu, kappa, F, dF)\n    test_cases = [\n        # Test Case 1: General small-strain\n        (\n            1.0, 8.0e4, 1.6e5,\n            np.array([\n                [1.001, 2.0e-4, 0.0],\n                [0.0, 0.9995, 3.0e-4],\n                [0.0, 0.0, 1.0004]\n            ]),\n            np.array([\n                [1.0e-4, 2.0e-5, 0.0],\n                [-2.0e-5, -1.0e-5, 1.0e-5],\n                [0.0, -1.0e-5, 3.0e-5]\n            ])\n        ),\n        # Test Case 2: Pure rotation\n        (\n            0.8, 1.2e5, 2.4e5,\n            # For F and dF, we compute them from the given angles\n            (lambda theta: np.array([\n                [np.cos(theta), -np.sin(theta), 0],\n                [np.sin(theta), np.cos(theta),  0],\n                [0,             0,              1]\n            ]))(1.0e-3),\n            # dF = R @ W\n            (lambda R, dtheta: R @ np.array([\n                [0, -dtheta, 0],\n                [dtheta, 0, 0],\n                [0, 0, 0]\n            ]))((lambda theta: np.array([\n                [np.cos(theta), -np.sin(theta), 0],\n                [np.sin(theta), np.cos(theta),  0],\n                [0,             0,              1]\n            ]))(1.0e-3), 5.0e-4)\n        ),\n        # Test Case 3: Nearly incompressible\n        (\n            1.0, 8.0e4, 8.0e7,\n            np.diag([1.002, 1.002, 0.996]),\n            1.0e-4 * np.identity(3)\n        )\n    ]\n\n    results = []\n    for case in test_cases:\n        V0, mu, kappa, F, dF = case\n        result_triplet = compute_energy_variations(V0, mu, kappa, F, dF)\n        results.append(result_triplet)\n\n    # Final print statement in the exact required format.\n    # Use str(results).replace(\" \", \"\") to get the comma-separated list\n    # of lists without any whitespace.\n    print(str(results).replace(\" \", \"\"))\n\ndef compute_energy_variations(V0, mu, kappa, F, dF):\n    \"\"\"\n    Computes the first variation of internal energy dU using three\n    different work conjugate pairs for a homogeneous deformation.\n\n    Args:\n        V0 (float): Reference volume.\n        mu (float): Shear modulus.\n        kappa (float): Bulk modulus.\n        F (np.ndarray): Deformation gradient tensor (3x3).\n        dF (np.ndarray): Variation of the deformation gradient (3x3).\n\n    Returns:\n        list: A list of three floats [dU_P, dU_S, dU_sigma].\n    \"\"\"\n    I = np.identity(3)\n\n    # --- Calculation 1: Using (F, P) ---\n    J = np.linalg.det(F)\n    if J <= 0:\n        # Physical deformation requires J > 0\n        raise ValueError(\"Deformation gradient must have a positive determinant.\")\n    \n    # P = mu*F + (kappa*ln(J) - mu) * (F^-T)\n    F_inv_T = np.linalg.inv(F).T\n    P = mu * F + (kappa * np.log(J) - mu) * F_inv_T\n    \n    # dU_P = V0 * (P : dF)\n    # The double-dot product A:B is sum(A_ij * B_ij)\n    dU_P = V0 * np.sum(P * dF)\n\n    # --- Calculation 2: Using (C, S) ---\n    # C = F^T * F\n    C = F.T @ F\n    # dC = dF^T*F + F^T*dF\n    dC = dF.T @ F + F.T @ dF\n    \n    C_inv = np.linalg.inv(C)\n    \n    # S = mu*I + (kappa*ln(J) - mu)*C^-1\n    S = mu * I + (kappa * np.log(J) - mu) * C_inv\n\n    # dU_S = V0 * 1/2 * (S : dC)\n    dU_S = V0 * 0.5 * np.sum(S * dC)\n\n    # --- Calculation 3: Using (epsilon, sigma) under small-strain ---\n    # Displacement gradient H = F - I\n    H = F - I\n    # Small-strain tensor epsilon = 1/2 * (H + H^T)\n    epsilon = 0.5 * (H + H.T)\n\n    # Variation of small-strain tensor d_epsilon\n    d_epsilon = 0.5 * (dF + dF.T)\n    \n    # Lamé's first parameter lambda\n    lame_lambda = kappa - (2.0/3.0) * mu\n\n    # Linearized Cauchy stress sigma_lin = lambda*tr(epsilon)*I + 2*mu*epsilon\n    sigma_lin = lame_lambda * np.trace(epsilon) * I + 2 * mu * epsilon\n    \n    # dU_sigma = V0 * (sigma_lin : d_epsilon)\n    dU_sigma = V0 * np.sum(sigma_lin * d_epsilon)\n\n    return [dU_P, dU_S, dU_sigma]\n\nsolve()\n```"
        },
        {
            "introduction": "在有限元方法（FEM）中，我们通过对离散单元上的积分求和来近似系统的总能量。本练习探讨了数值积分方案（例如减缩积分）的选择如何影响解的稳定性。您将通过分析单元刚度矩阵的零空间来识别非物理的“沙漏”变形模式，这是计算力学中一个典型且重要的问题。",
            "id": "3561584",
            "problem": "考虑一个二维线性弹性体，其通过一个含四个节点的等参双线性四边形有限元进行离散。线性弹性的守恒内能泛函由下式给出\n$$\n\\Pi_{\\text{int}}[\\boldsymbol{u}] = \\int_{\\Omega} \\frac{1}{2} \\boldsymbol{\\varepsilon}(\\boldsymbol{u})^{\\mathsf{T}} \\mathbf{D} \\, \\boldsymbol{\\varepsilon}(\\boldsymbol{u}) \\, d\\Omega,\n$$\n其中 $\\boldsymbol{u}$ 是位移场，$\\boldsymbol{\\varepsilon}(\\boldsymbol{u})$ 是小应变张量，$\\mathbf{D}$ 是平面应力条件下线性弹性的对称正定本构矩阵。该等参双线性四边形单元在方形参考域 $\\{(\\xi,\\eta)\\in[-1,1]\\times[-1,1]\\}$ 上使用双线性形函数，并通过一个光滑映射将其映射到具有逆时针排序节点坐标 $\\{(x_i,y_i)\\}_{i=1}^4$ 的物理单元上。\n\n在减缩积分下，离散内能通过单元中心 $(\\xi,\\eta)=(0,0)$ 处的单个高斯点来近似：\n$$\n\\Pi_{\\text{int}}^{\\text{red}}(\\mathbf{u}_e) = \\frac{1}{2} \\, w \\, J(0,0) \\, \\boldsymbol{\\varepsilon}_c(\\mathbf{u}_e)^{\\mathsf{T}} \\mathbf{D} \\, \\boldsymbol{\\varepsilon}_c(\\mathbf{u}_e),\n$$\n其中 $\\mathbf{u}_e \\in \\mathbb{R}^{8}$ 集合了节点的位移自由度（每个节点两个，$\\{u_{x,i},u_{y,i}\\}_{i=1}^4$），$w$ 是参考方块上的二维单点高斯权重，$J(0,0)$ 是中心处等参映射的雅可比行列式，而 $\\boldsymbol{\\varepsilon}_c(\\mathbf{u}_e)$ 是在中心处计算的小应变向量。该离散泛函通过以下方式定义一个对称矩阵 $\\mathbf{K}_{\\text{red}}$\n$$\n\\Pi_{\\text{int}}^{\\text{red}}(\\mathbf{u}_e) = \\frac{1}{2} \\, \\mathbf{u}_e^{\\mathsf{T}} \\mathbf{K}_{\\text{red}} \\, \\mathbf{u}_e.\n$$\n如果一个位移模式位于 $\\mathbf{K}_{\\text{red}}$ 的零空间中，则称其为该离散泛函的“零能模式”。刚体运动是处处产生零应变的位移场；它们总是零能模式。“沙漏模式”是减缩积分离散化特有的一种非刚体零能模式。\n\n任务：仅从内能泛函、小应变运动学和等参映射的基本定义出发，推导一个为单个双线性四边形单元构建 $\\mathbf{K}_{\\text{red}}$ 的计算过程，并将沙漏模式识别为不属于刚体运动子空间的离散泛函零能模式。实现此过程，并为每个测试用例返回两个整数：\n- $\\mathbf{K}_{\\text{red}}$ 的零能模式总数（零空间的维度），以及\n- 沙漏模式的数量（零空间维度减去刚体运动子空间的维度）。\n\n假设为平面应力，杨氏模量为 $E$（单位：帕斯卡），泊松比为 $\\nu$（无量纲）。节点坐标以米为单位。对于方形参考域上的单点高斯法则，使用标准权重。此外，实现一个使用完全 $2\\times 2$ 高斯积分的比较案例，以显示沙漏模式的消失。使用数值稳健的方法（例如，奇异值分解）和合理的相对容差来确定零空间的维度。\n\n输入通过以下单元几何形状和材料参数的测试套件硬编码在您的程序中：\n1. 方形单元，减缩积分：节点 $\\{(0,0),(1,0),(1,1),(0,1)\\}$，$E=210\\times 10^9$ Pa，$\\nu=0.30$。\n2. 斜平行四边形，减缩积分：节点 $\\{(0,0),(1.2,0.1),(1.0,1.1),(-0.2,1.0)\\}$，$E=70\\times 10^9$ Pa，$\\nu=0.25$。\n3. 扭曲梯形，减缩积分：节点 $\\{(0,0),(1.3,0.0),(0.9,0.8),(0.1,0.6)\\}$，$E=100\\times 10^9$ Pa，$\\nu=0.30$。\n4. 细长矩形，减缩积分：节点 $\\{(0,0),(2.0,0.0),(2.0,0.2),(0.0,0.2)\\}$，$E=50\\times 10^9$ Pa，$\\nu=0.30$。\n5. 方形单元，完全积分（$2\\times 2$ 高斯）：节点 $\\{(0,0),(1,0),(1,1),(0,1)\\}$，$E=210\\times 10^9$ Pa，$\\nu=0.30$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果必须是按上述顺序排列的含两个整数的列表。例如，最终输出应如下所示\n$$\n[\\,[n_1,h_1],[n_2,h_2],[n_3,h_3],[n_4,h_4],[n_5,h_5]\\,],\n$$\n不含空格。所有计算必须在国际单位制（SI）下进行：长度以米为单位，模量以帕斯卡为单位。角度（如果有）应以弧度为单位，尽管本任务中不需要角度。",
            "solution": "本任务要求推导并实现一个计算过程，以确定单个双线性四边形有限元在不同积分方案下的零能模式和沙漏模式的数量。该分析基于线性弹性、等参有限元列式和数值求积的原理。\n\n### 1. 理论框架\n\n经历小变形的线性弹性体的内部弹性能量泛函 $\\Pi_{\\text{int}}$ 由下式给出：\n$$\n\\Pi_{\\text{int}}[\\boldsymbol{u}] = \\int_{\\Omega} \\frac{1}{2} \\boldsymbol{\\varepsilon}(\\boldsymbol{u})^{\\mathsf{T}} \\mathbf{D} \\, \\boldsymbol{\\varepsilon}(\\boldsymbol{u}) \\, d\\Omega\n$$\n其中 $\\boldsymbol{u}$ 是位移场，$\\boldsymbol{\\varepsilon}$ 是 Voigt 记法下的应变张量，$\\mathbf{D}$ 是材料本构矩阵，$\\Omega$ 是物体所占的域。\n\n#### 1.1. 等参有限元离散化\n\n对于一个四节点双线性四边形单元，其几何形状和位移场使用同一组形函数 $N_i(\\xi, \\eta)$ 从节点值进行插值，这些形函数定义在一个方形参考母元 $[-1,1] \\times [-1,1]$ 上。形函数为：\n$$\n\\begin{aligned}\nN_1(\\xi, \\eta) = \\frac{1}{4}(1-\\xi)(1-\\eta) \\\\\nN_2(\\xi, \\eta) = \\frac{1}{4}(1+\\xi)(1-\\eta) \\\\\nN_3(\\xi, \\eta) = \\frac{1}{4}(1+\\xi)(1+\\eta) \\\\\nN_4(\\xi, \\eta) = \\frac{1}{4}(1-\\xi)(1+\\eta)\n\\end{aligned}\n$$\n物理坐标 $(x, y)$ 使用节点坐标 $\\mathbf{x}_e = [x_1, y_1, \\dots, x_4, y_4]^{\\mathsf{T}}$ 从参考坐标 $(\\xi, \\eta)$ 映射而来：\n$$\nx(\\xi, \\eta) = \\sum_{i=1}^4 N_i(\\xi, \\eta) x_i \\quad \\text{和} \\quad y(\\xi, \\eta) = \\sum_{i=1}^4 N_i(\\xi, \\eta) y_i\n$$\n类似地，位移场 $\\boldsymbol{u} = [u_x, u_y]^{\\mathsf{T}}$ 从节点位移向量 $\\mathbf{u}_e = [u_{x,1}, u_{y,1}, \\dots, u_{x,4}, u_{y,4}]^{\\mathsf{T}} \\in \\mathbb{R}^8$ 插值得到：\n$$\n\\boldsymbol{u}(\\xi, \\eta) = \\mathbf{N}(\\xi, \\eta) \\mathbf{u}_e \\quad \\text{其中} \\quad \\mathbf{N} = \\begin{bmatrix} N_1  0  N_2  0  N_3  0  N_4  0 \\\\ 0  N_1  0  N_2  0  N_3  0  N_4 \\end{bmatrix}\n$$\n\n#### 1.2. 应变-位移关系\n\n以 Voigt 向量形式表示的小应变张量 $\\boldsymbol{\\varepsilon} = [\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}]^{\\mathsf{T}}$ 是通过对位移场求导得出的：\n$$\n\\boldsymbol{\\varepsilon} = \\begin{bmatrix} \\partial/\\partial x  0 \\\\ 0  \\partial/\\partial y \\\\ \\partial/\\partial y  \\partial/\\partial x \\end{bmatrix} \\boldsymbol{u}\n$$\n代入插值后的位移场，我们得到基本的应变-位移关系 $\\boldsymbol{\\varepsilon} = \\mathbf{B} \\mathbf{u}_e$，其中 $\\mathbf{B}$ 是应变-位移矩阵。矩阵 $\\mathbf{B}$ 由节点块 $\\mathbf{B}_i$ 组成：\n$$\n\\mathbf{B} = [\\mathbf{B}_1, \\mathbf{B}_2, \\mathbf{B}_3, \\mathbf{B}_4] \\quad \\text{with} \\quad \\mathbf{B}_i = \\begin{bmatrix} \\frac{\\partial N_i}{\\partial x}  0 \\\\ 0  \\frac{\\partial N_i}{\\partial y} \\\\ \\frac{\\partial N_i}{\\partial y}  \\frac{\\partial N_i}{\\partial x} \\end{bmatrix}\n$$\n形函数关于物理坐标 $(x,y)$ 的导数通过链式法则和等参映射的雅可比矩阵 $\\mathbf{J}$ 求得：\n$$\n\\begin{Bmatrix} \\frac{\\partial N_i}{\\partial x} \\\\ \\frac{\\partial N_i}{\\partial y} \\end{Bmatrix} = \\mathbf{J}^{-1} \\begin{Bmatrix} \\frac{\\partial N_i}{\\partial \\xi} \\\\ \\frac{\\partial N_i}{\\partial \\eta} \\end{Bmatrix}, \\quad \\text{其中} \\quad \\mathbf{J} = \\begin{bmatrix} \\frac{\\partial x}{\\partial \\xi}  \\frac{\\partial y}{\\partial \\xi} \\\\ \\frac{\\partial x}{\\partial \\eta}  \\frac{\\partial y}{\\partial \\eta} \\end{bmatrix}\n$$\n\n#### 1.3. 单元刚度矩阵\n\n将离散应变表示代入能量泛函可得：\n$$\n\\Pi_{\\text{int}}(\\mathbf{u}_e) = \\frac{1}{2} \\mathbf{u}_e^{\\mathsf{T}} \\left( \\int_{\\Omega} \\mathbf{B}^{\\mathsf{T}} \\mathbf{D} \\mathbf{B} \\, d\\Omega \\right) \\mathbf{u}_e = \\frac{1}{2} \\mathbf{u}_e^{\\mathsf{T}} \\mathbf{K}_e \\mathbf{u}_e\n$$\n因此，单元刚度矩阵 $\\mathbf{K}_e$ 由该积分定义。此积分被转换到参考域，并使用高斯求积进行数值计算：\n$$\n\\mathbf{K}_e = \\int_{-1}^1 \\int_{-1}^1 \\mathbf{B}(\\xi, \\eta)^{\\mathsf{T}} \\mathbf{D} \\mathbf{B}(\\xi, \\eta) \\, \\det(\\mathbf{J}(\\xi, \\eta)) \\, d\\xi d\\eta \\approx \\sum_{k=1}^{N_g} w_k \\, \\det(\\mathbf{J}_k) \\, \\mathbf{B}_k^{\\mathsf{T}} \\mathbf{D} \\mathbf{B}_k\n$$\n其中 $N_g$ 是高斯点的数量，$(\\xi_k, \\eta_k)$、$w_k$、$\\mathbf{J}_k$ 和 $\\mathbf{B}_k$ 分别是第 $k$ 个高斯点处的坐标、权重、雅可比矩阵和应变-位移矩阵。对于平面应力，本构矩阵为：\n$$\n\\mathbf{D} = \\frac{E}{1-\\nu^2} \\begin{bmatrix} 1  \\nu  0 \\\\ \\nu  1  0 \\\\ 0  0  \\frac{1-\\nu}{2} \\end{bmatrix}\n$$\n\n### 2. 零能模式分析\n\n零能模式是一个非零的节点位移向量 $\\mathbf{v}$，它产生零应变能，即 $\\frac{1}{2}\\mathbf{v}^{\\mathsf{T}}\\mathbf{K}_e\\mathbf{v} = 0$。由于 $\\mathbf{K}_e$ 是对称半正定的，这等价于 $\\mathbf{v}$ 位于 $\\mathbf{K}_e$ 的零空间中，即 $\\mathbf{K}_e\\mathbf{v} = \\mathbf{0}$。\n\n#### 2.1. 刚体模式\n任何刚体运动在整个单元内都产生零应变。对于二维物体，存在三种这样的独立模式：两个平移和一个面内旋转。这三种模式必须始终位于任何正确定制的刚度矩阵的零空间中。\n\n#### 2.2. 沙漏模式（减缩积分）\n减缩积分使用的高斯点数量少于精确积分刚度矩阵被积函数所需的数量。对于双线性四边形，单点求积是一种常见的减缩积分方案。此处，$N_g=1$，高斯点为 $(\\xi_1, \\eta_1) = (0,0)$，权重为 $w_1 = 4$。刚度矩阵为：\n$$\n\\mathbf{K}_{\\text{red}} = w_1 \\, \\det(\\mathbf{J}(0,0)) \\, \\mathbf{B}(0,0)^{\\mathsf{T}} \\mathbf{D} \\mathbf{B}(0,0)\n$$\n对于 $\\mathbf{K}_{\\text{red}}$，一个零能模式 $\\mathbf{v}$ 是指使单元中心的应变为零的模式：$\\boldsymbol{\\varepsilon}_c = \\mathbf{B}(0,0) \\mathbf{v} = \\mathbf{0}$。双线性形函数基包含 $\\xi\\eta$ 项。一个与此项成比例的位移场，例如 $u_x(\\xi, \\eta) = c \\, \\xi\\eta$，其导数为 $\\partial u_x/\\partial\\xi = c\\eta$ 和 $\\partial u_x/\\partial\\eta = c\\xi$。在 $(\\xi, \\eta)=(0,0)$ 处，这两个导数都为零，这意味着该场在中心处产生零应变。与场 $\\xi\\eta$ 对应的节点位移可通过在四个节点处求值得到：$(\\xi_i\\eta_i)_{i=1}^4 = (1, -1, 1, -1)$。这个向量就是特征“沙漏”形状向量，$\\mathbf{h} = [1, -1, 1, -1]^{\\mathsf{T}}$。\n\n可以从此形状构造出两个独立的位移模式：\n1.  一个 x-位移模式：$\\mathbf{u}_{h1} = [1, 0, -1, 0, 1, 0, -1, 0]^{\\mathsf{T}}$\n2.  一个 y-位移模式：$\\mathbf{u}_{h2} = [0, 1, 0, -1, 0, 1, 0, -1]^{\\mathsf{T}}$\n\n这两种模式与三种刚体模式线性无关。因此，$\\mathbf{B}(0,0)$ 的零空间维度为 5。这意味着 $\\mathbf{K}_{\\text{red}}$ 将有一个维度为 5 的零空间。零能模式的数量为 $n=5$，沙漏模式的数量为 $h = n - 3 = 2$。\n\n#### 2.3. 完全积分\n双线性四边形的完全积分使用 $2 \\times 2$ 高斯求积法则（$N_g=4$）。四个高斯点为 $(\\xi_k, \\eta_k) = (\\pm 1/\\sqrt{3}, \\pm 1/\\sqrt{3})$，每个点的权重为 $w_k = 1$。虽然沙漏模式在中心点 $(\\xi, \\eta)=(0,0)$ 处产生零应变，但它们在 $2 \\times 2$ 的高斯点上产生非零应变。因此，它们不再是零能模式，因为它们对总应变能 $\\sum_k w_k (\\dots)$ 的贡献是正的。唯一保留在零空间中的模式是三种刚体模式，它们的应变处处为零。因此，对于完全积分，零能模式的数量为 $n=3$，沙漏模式的数量为 $h = 3-3=0$。\n\n### 3. 计算过程\n\n解决该问题的算法如下：\n1.  对于每个测试用例（单元几何形状、材料属性、积分法则）：\n    a. 构建平面应力的本构矩阵 $\\mathbf{D}$。\n    b. 初始化一个 $8 \\times 8$ 的单元刚度矩阵 $\\mathbf{K}_e$ 为零矩阵。\n    c. 确定指定积分法则的一组高斯点 $(\\xi_k, \\eta_k)$ 和权重 $w_k$。\n    d. 对每个高斯点：\n        i.   计算形函数的导数 $\\partial N_i/\\partial \\xi$ 和 $\\partial N_i/\\partial \\eta$。\n        ii.  计算雅可比矩阵 $\\mathbf{J}$ 及其行列式 $\\det(\\mathbf{J})$。\n        iii. 使用 $\\mathbf{J}^{-1}$ 和形函数导数计算应变-位移矩阵 $\\mathbf{B}$。\n        iv.  计算对刚度矩阵的贡献 $\\Delta\\mathbf{K} = w_k \\det(\\mathbf{J}) \\mathbf{B}^{\\mathsf{T}} \\mathbf{D} \\mathbf{B}$ 并将其加到 $\\mathbf{K}_e$ 上。\n    e. 计算最终矩阵 $\\mathbf{K}_e$ 的奇异值分解（SVD）。\n    f. 通过计算相对于最大奇异值 $\\sigma_{\\max}$ 而言实际上为零的奇异值 $\\sigma_i$ 的数量，来确定零空间的维度 $n$。如果 $\\sigma_i / \\sigma_{\\max}  \\epsilon$，则认为该奇异值为零，其中 $\\epsilon$ 是一个小的数值容差（例如 $10^{-12}$）。\n    g. 沙漏模式的数量为 $h = n - 3$。\n2.  为每个测试用例收集数对 $[n, h]$。\n3.  按规定格式化最终结果。\n\n此过程在以下 Python 程序中实现。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy is not used as numpy is sufficient.\n\ndef get_stiffness_matrix(nodes, E, nu, integration_rule):\n    \"\"\"\n    Computes the stiffness matrix for a 4-node bilinear quadrilateral element.\n\n    Args:\n        nodes (np.ndarray): A 4x2 array of nodal coordinates, ordered counter-clockwise.\n        E (float): Young's modulus.\n        nu (float): Poisson's ratio.\n        integration_rule (str): Either 'reduced' (1-point) or 'full' (2x2).\n\n    Returns:\n        np.ndarray: The 8x8 element stiffness matrix.\n    \"\"\"\n    # Constitutive matrix for plane stress\n    D = (E / (1 - nu**2)) * np.array([\n        [1, nu, 0],\n        [nu, 1, 0],\n        [0, 0, (1 - nu) / 2]\n    ])\n\n    # Define Gauss quadrature points and weights\n    if integration_rule == 'reduced':\n        gauss_points = np.array([[0.0, 0.0]])\n        gauss_weights = np.array([4.0])\n    elif integration_rule == 'full':\n        a = 1.0 / np.sqrt(3.0)\n        gauss_points = np.array([\n            [-a, -a],\n            [ a, -a],\n            [ a,  a],\n            [-a,  a]\n        ])\n        gauss_weights = np.array([1.0, 1.0, 1.0, 1.0])\n    else:\n        raise ValueError(\"Invalid integration rule specified.\")\n\n    # Initialize stiffness matrix\n    K = np.zeros((8, 8))\n\n    # Loop over Gauss points for numerical integration\n    for i in range(len(gauss_weights)):\n        xi, eta = gauss_points[i]\n        weight = gauss_weights[i]\n\n        # Derivatives of shape functions w.r.t. reference coordinates (xi, eta)\n        # N1 = 0.25*(1-xi)*(1-eta), N2 = 0.25*(1+xi)*(1-eta), etc.\n        dN_dxi = 0.25 * np.array([-(1 - eta), (1 - eta), (1 + eta), -(1 + eta)])\n        dN_deta = 0.25 * np.array([-(1 - xi), -(1 + xi), (1 + xi), (1 - xi)])\n\n        # Jacobian matrix J = [[dx/dxi, dy/dxi], [dx/deta, dy/deta]]\n        # J is computed as [dN/dxi, dN/deta]^T @ [x, y]\n        J_mat = np.array([\n            [np.dot(dN_dxi, nodes[:, 0]), np.dot(dN_dxi, nodes[:, 1])],\n            [np.dot(dN_deta, nodes[:, 0]), np.dot(dN_deta, nodes[:, 1])]\n        ])\n\n        detJ = np.linalg.det(J_mat)\n        if detJ = 0:\n            # Should not happen for valid element geometries ordered CCW\n            raise ValueError(\"Jacobian determinant is non-positive.\")\n        \n        # Matrix of shape function derivatives w.r.t. physical coordinates (x, y)\n        # [dN/dx, dN/dy]^T = J_inv @ [dN/dxi, dN/deta]^T\n        # We need [dN/dx, dN/dy] = [dN/dxi, dN/deta] @ J_inv^T\n        dN_dxy = np.linalg.inv(J_mat).T @ np.vstack((dN_dxi, dN_deta))\n        dN_dx = dN_dxy[0, :]\n        dN_dy = dN_dxy[1, :]\n\n        # Strain-displacement matrix B\n        B = np.zeros((3, 8))\n        for j in range(4):\n            B[0, 2*j]     = dN_dx[j]\n            B[1, 2*j + 1] = dN_dy[j]\n            B[2, 2*j]     = dN_dy[j]\n            B[2, 2*j + 1] = dN_dx[j]\n\n        # Accumulate stiffness matrix\n        K += B.T @ D @ B * detJ * weight\n\n    return K\n\ndef get_nullspace_dims(K, tol=1e-12):\n    \"\"\"\n    Calculates the dimensions of the nullspace and hourglass mode space.\n    \"\"\"\n    # Use Singular Value Decomposition to find the rank\n    s = np.linalg.svd(K, compute_uv=False)\n    \n    # The number of zero-energy modes is the number of singular values\n    # that are numerically zero relative to the largest one.\n    s_max = s[0] if len(s)  0 else 0\n    if s_max == 0: # This is a zero matrix\n        num_zero_modes = K.shape[0]\n    else:\n        num_zero_modes = np.sum(s  tol * s_max)\n\n    # Number of rigid body modes in 2D is 3\n    num_rigid_body_modes = 3\n    \n    # Hourglass modes are non-rigid-body zero-energy modes\n    num_hourglass_modes = num_zero_modes - num_rigid_body_modes\n    \n    return [num_zero_modes, num_hourglass_modes]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Square, reduced integration\n        {'nodes': np.array([[0.0, 0.0], [1.0, 0.0], [1.0, 1.0], [0.0, 1.0]]),\n         'E': 210e9, 'nu': 0.30, 'rule': 'reduced'},\n        # Case 2: Skew parallelogram, reduced integration\n        {'nodes': np.array([[0.0, 0.0], [1.2, 0.1], [1.0, 1.1], [-0.2, 1.0]]),\n         'E': 70e9, 'nu': 0.25, 'rule': 'reduced'},\n        # Case 3: Distorted trapezoid, reduced integration\n        {'nodes': np.array([[0.0, 0.0], [1.3, 0.0], [0.9, 0.8], [0.1, 0.6]]),\n         'E': 100e9, 'nu': 0.30, 'rule': 'reduced'},\n        # Case 4: Slender rectangle, reduced integration\n        {'nodes': np.array([[0.0, 0.0], [2.0, 0.0], [2.0, 0.2], [0.0, 0.2]]),\n         'E': 50e9, 'nu': 0.30, 'rule': 'reduced'},\n        # Case 5: Square, full integration\n        {'nodes': np.array([[0.0, 0.0], [1.0, 0.0], [1.0, 1.0], [0.0, 1.0]]),\n         'E': 210e9, 'nu': 0.30, 'rule': 'full'},\n    ]\n\n    results = []\n    for case in test_cases:\n        K = get_stiffness_matrix(case['nodes'], case['E'], case['nu'], case['rule'])\n        dims = get_nullspace_dims(K)\n        results.append(dims)\n\n    # Final print statement in the exact required format.\n    # e.g., [[5,2],[5,2],[5,2],[5,2],[3,0]]\n    result_str = str(results).replace(\" \", \"\")\n    print(result_str)\n\nsolve()\n```"
        },
        {
            "introduction": "任何非线性结构力学求解器的关键测试之一是其是否在全局上遵守能量守恒。这项高级实践要求您设计一个数值“能量审计”程序。通过该程序，您可以检查计算出的内能增量是否与外部所做的功相匹配，这为验证复杂模拟程序的正确性提供了一种强有力的方法。",
            "id": "3561571",
            "problem": "要求您为保守载荷下的非线性超弹性有限元方法（FEM）系统，形式化、实现并测试一个离散能量诊断工具。目标是为超弹性体定义一个离散的总能量泛函，并设计一个量化诊断方法，用于标记非物理的能量增益，以此作为数值问题的网格无关指示器。该问题设定在二维平面应变体的背景下，其位移场由载荷参数化的运动学容许位移场预先规定。\n\n从以下与背景相符的基本概念开始：\n- 超弹性材料的定义：第一Piola–Kirchhoff应力 $\\mathbf{P}$ 由应变能密度函数 $W(\\mathbf{F})$ 导出，其中 $\\mathbf{F}$ 是变形梯度。对于一个在 $d$ 维空间中的可压缩Neo-Hookean材料，$W(\\mathbf{F})$ 是 $\\mathbf{F}$ 的不变量和雅可比行列式 $J$ 的函数。\n- 准静态保守系统的能量守恒原理：对于一个由载荷参数 $\\lambda$ 从 $\\lambda = 0$ 到 $\\lambda = \\lambda_n$ 参数化的过程，只要载荷是保守的且解在每一步都满足平衡条件，则储存的内能增量等于沿路径累积的外部功输入。在离散化中，这成为一个积分关系，必须由一致的数值近似来遵循。\n\n几何与运动学：\n- 考虑一个矩形域 $\\Omega = [0,L_x] \\times [0,L_y]$，其 $L_x$ 和 $L_y$ 以米为单位，厚度为1米（平面应变，单位厚度）。\n- 定义一个由 $\\lambda$ 参数化的光滑、非均匀位移场：\n$$\\mathbf{u}(\\mathbf{X};\\lambda) = \\lambda \\mathbf{u}_0(\\mathbf{X}), \\quad \\mathbf{X}=(X,Y),$$\n其基础场分量为\n$$u_{0x}(X,Y) = c_1 \\frac{X^2}{L_x^2} + c_2 \\frac{Y^2}{L_y^2}, \\quad u_{0y}(X,Y) = c_3 \\frac{XY}{L_x L_y}.$$\n- 平面应变中的变形梯度为\n$$\\mathbf{F}(\\lambda,\\mathbf{X}) = \\mathbf{I} + \\lambda \\nabla \\mathbf{u}_0(\\mathbf{X}),$$\n其中 $\\mathbf{I}$ 是单位张量，$\\nabla \\mathbf{u}_0$ 是基础位移场的梯度。\n\n超弹性本构律：\n- 对于 $d=2$ 维的可压缩Neo-Hookean材料，应变能密度为\n$$W(\\mathbf{F}) = \\frac{\\mu}{2} \\left( \\mathrm{tr}(\\mathbf{F}^\\top \\mathbf{F}) - d - 2\\ln J \\right) + \\frac{\\kappa}{2} (\\ln J)^2,$$\n其中 $d=2$，$J = \\det(\\mathbf{F})$，剪切模量 $\\mu$ 的单位是帕斯卡，体积模量 $\\kappa$ 的单位是帕斯卡。\n- 第一Piola–Kirchhoff应力为\n$$\\mathbf{P}(\\mathbf{F}) = \\mu \\left(\\mathbf{F} - \\mathbf{F}^{-\\top}\\right) + \\kappa \\ln J \\, \\mathbf{F}^{-\\top}.$$\n\n保守载荷：\n- 通过定义单位参考体积的保守体力，为每个 $\\lambda$ 强制施加平衡条件\n$$\\mathbf{b}(\\lambda,\\mathbf{X}) = - \\nabla \\cdot \\mathbf{P}(\\mathbf{F}(\\lambda,\\mathbf{X})),$$\n其中 $\\nabla \\cdot$ 逐列作用于参考构型中的 $\\mathbf{P}$。这种选择确保了强形式的平衡方程 $\\nabla \\cdot \\mathbf{P} + \\mathbf{b} = \\mathbf{0}$ 对规定的 $\\mathbf{u}(\\mathbf{X};\\lambda)$ 成立，从而使载荷成为保守且路径一致的。\n- 该准静态过程的外部功率为\n$$\\dot{W}_{\\mathrm{ext}}(\\lambda) = \\int_{\\Omega} \\mathbf{b}(\\lambda,\\mathbf{X}) \\cdot \\frac{\\partial \\mathbf{u}}{\\partial \\lambda}(\\mathbf{X};\\lambda) \\, dV = \\int_{\\Omega} \\mathbf{b}(\\lambda,\\mathbf{X}) \\cdot \\mathbf{u}_0(\\mathbf{X}) \\, dV.$$\n\n离散总能量和数值诊断：\n- 用 $N_x \\times N_y$ 个单元的结构化矩形网格离散化 $\\Omega$。在每个面积为 $A_e$ 的单元 $e$ 上，通过高斯求积法近似计算 $\\lambda_i$ 时的内能：\n$$E_{\\mathrm{int}}(\\lambda_i) \\approx \\sum_{e} \\sum_{q=1}^{n_q} W\\!\\left(\\mathbf{F}(\\lambda_i,\\mathbf{X}_{e,q})\\right) \\, w_q \\, A_e,$$\n其中 $\\mathbf{X}_{e,q}$ 是求积点，$w_q$ 是求积权重，$n_q$ 是每个单元的求积点数，$A_e$ 的单位是 $\\mathrm{m}^2$。内能以焦耳表示。\n- 使用梯形法则对外部功率进行积分，近似计算沿路径 $\\lambda_0, \\lambda_1, \\dots, \\lambda_n$ 累积的外部功：\n$$W_{\\mathrm{ext}}(0 \\to \\lambda_n) \\approx \\sum_{i=1}^{n} \\frac{\\dot{W}_{\\mathrm{ext}}(\\lambda_{i-1}) + \\dot{W}_{\\mathrm{ext}}(\\lambda_i)}{2} \\, (\\lambda_i - \\lambda_{i-1}).$$\n- 定义能量残差\n$$r = E_{\\mathrm{int}}(\\lambda_n) - W_{\\mathrm{ext}}(0 \\to \\lambda_n).$$\n- 诊断规则：如果 $r  \\tau_{\\mathrm{abs}} + \\tau_{\\mathrm{rel}} \\, E_{\\mathrm{int}}(\\lambda_n)$，则标记非物理能量增益。其中绝对容差 $\\tau_{\\mathrm{abs}}$ 的单位是焦耳，相对容差 $\\tau_{\\mathrm{rel}}$ 是无量纲的。如果该诊断方法能在离散化不一致时，无论网格参数如何，都能检测到伪能量产生，那么它就是网格无关的。\n\n数值实现细节：\n- 从给定的 $u_0$ 符号化地计算梯度 $\\nabla \\mathbf{u}_0$ 得到 $\\mathbf{F}$，并在求积点上计算 $W$ 和 $\\mathbf{P}$。\n- 通过对 $\\mathbf{P}$ 的列应用中心有限差分法，以与局部单元尺寸成比例的步长数值计算 $\\nabla \\cdot \\mathbf{P}$，从而确保科学真实性和数值稳定性。\n- 为了对网格无关性进行比较测试，可以选择性地使用一个故意不一致的外部功计算器，该计算器通过一个线性化的小应变模型定义 $\\mathbf{P}_{\\mathrm{lin}}$：\n$$\\boldsymbol{\\varepsilon} = \\frac{1}{2} \\left( \\nabla \\mathbf{u} + (\\nabla \\mathbf{u})^\\top \\right), \\quad \\lambda_{\\mathrm{Lame}} = \\kappa - \\frac{2}{3}\\mu,$$\n$$\\mathbf{P}_{\\mathrm{lin}} \\approx \\lambda_{\\mathrm{Lame}} \\, \\mathrm{tr}(\\boldsymbol{\\varepsilon}) \\, \\mathbf{I} + 2 \\mu \\boldsymbol{\\varepsilon},$$\n然后设置 $\\mathbf{b}_{\\mathrm{lin}}(\\lambda,\\mathbf{X}) = -\\nabla \\cdot \\mathbf{P}_{\\mathrm{lin}}(\\lambda,\\mathbf{X})$。这模拟了一个常见的数值问题，即内部和外部能量学被不一致地计算，导致可被该诊断工具检测到的非物理能量产生。\n\n物理和数值单位：\n- 长度使用米（$\\mathrm{m}$），模量 $\\mu$ 和 $\\kappa$ 使用帕斯卡（$\\mathrm{Pa}$），能量使用焦耳（$\\mathrm{J}$）。角度没有出现，也不需要。\n\n测试套件和要求的输出：\n- 使用以下测试用例来检验诊断工具：\n    1. 案例A（理想情况，一致的能量学，细网格）：$L_x = 1.0 \\, \\mathrm{m}$，$L_y = 1.0 \\, \\mathrm{m}$，$N_x = 40$，$N_y = 40$，$\\mu = 1.0 \\times 10^{6} \\, \\mathrm{Pa}$，$\\kappa = 5.0 \\times 10^{6} \\, \\mathrm{Pa}$，$c_1 = 0.5$，$c_2 = 0.5$，$c_3 = 0.3$，载荷步长 $\\lambda \\in \\{0.0, 0.7, 1.0\\}$，一致的Neo-Hookean内部和外部模型。容差：$\\tau_{\\mathrm{abs}} = 1.0 \\times 10^{-1} \\, \\mathrm{J}$，$\\tau_{\\mathrm{rel}} = 1.0 \\times 10^{-6}$。\n    2. 案例B（不一致的能量学，粗网格）：与案例A相同的$L_x$、$L_y$、$\\mu$、$\\kappa$、$c_1$、$c_2$、$c_3$和载荷步长，但是$N_x = 6$，$N_y = 6$，内能使用Neo-Hookean模型计算，外部功率使用上述线性化小应变模型 $\\mathbf{P}_{\\mathrm{lin}}$ 计算。容差相同。此案例应标记非物理能量增益。\n    3. 案例C（边界情况，零路径）：几何和材料与之前相同，$N_x = 8$，$N_y = 8$，载荷步长 $\\lambda \\in \\{0.0, 0.0\\}$，一致的Neo-Hookean内部和外部模型。容差相同。此案例不应标记非物理能量增益。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[result_1,result_2,result_3]$），其中 $result_i$ 是每个案例的布尔值，指示是否标记了非物理能量增益（$\\mathrm{True}$）或没有（$\\mathrm{False}$）。\n\n覆盖率设计：\n- 案例A测试了一致离散化下的一般正确行为。\n- 案例B测试了当内部功和外部功计算不一致时，诊断工具检测伪能量产生的能​​力，这是一个现实的数值问题。\n- 案例C测试了沿路径没有能量交换的边界条件。\n\n答案格式：\n- 最终程序必须完全自包含，不需要任何输入，并且必须以上述格式精确打印一行。确保布尔值是根据测试套件中给出的数值近似和参数，通过实现的诊断工具计算得出的。",
            "solution": "用户提供了一个计算固体力学问题，涉及为超弹性材料的数值模拟开发一个基于能量的诊断工具。在尝试解决问题之前，需要对问题的自洽性、科学合理性和适定性进行验证。\n\n### 步骤 1: 提取给定信息\n\n- **域**：一个矩形域 $\\Omega = [0,L_x] \\times [0,L_y]$，单位厚度（$1 \\, \\mathrm{m}$）。\n- **运动学**：\n    - 预设位移场：$\\mathbf{u}(\\mathbf{X};\\lambda) = \\lambda \\mathbf{u}_0(\\mathbf{X})$，其中 $\\mathbf{X}=(X,Y)$。\n    - 基础位移分量：$u_{0x}(X,Y) = c_1 \\frac{X^2}{L_x^2} + c_2 \\frac{Y^2}{L_y^2}$ 和 $u_{0y}(X,Y) = c_3 \\frac{XY}{L_x L_y}$。\n    - 变形梯度（平面应变）：$\\mathbf{F}(\\lambda,\\mathbf{X}) = \\mathbf{I} + \\lambda \\nabla \\mathbf{u}_0(\\mathbf{X})$。\n- **本构律（可压缩Neo-Hookean, $d=2$）**：\n    - 应变能密度：$W(\\mathbf{F}) = \\frac{\\mu}{2} \\left( \\mathrm{tr}(\\mathbf{F}^\\top \\mathbf{F}) - d - 2\\ln J \\right) + \\frac{\\kappa}{2} (\\ln J)^2$，其中 $d=2$，$J = \\det(\\mathbf{F})$。\n    - 第一Piola-Kirchhoff应力：$\\mathbf{P}(\\mathbf{F}) = \\mu \\left(\\mathbf{F} - \\mathbf{F}^{-\\top}\\right) + \\kappa \\ln J \\, \\mathbf{F}^{-\\top}$。\n- **载荷**：\n    - 保守体力：$\\mathbf{b}(\\lambda,\\mathbf{X}) = - \\nabla \\cdot \\mathbf{P}(\\mathbf{F}(\\lambda,\\mathbf{X}))$。\n    - 外部功率：$\\dot{W}_{\\mathrm{ext}}(\\lambda) = \\int_{\\Omega} \\mathbf{b}(\\lambda,\\mathbf{X}) \\cdot \\mathbf{u}_0(\\mathbf{X}) \\, dV$。\n- **不一致模型（用于测试）**：\n    - 线性化应变：$\\boldsymbol{\\varepsilon} = \\frac{1}{2} \\left( \\nabla \\mathbf{u} + (\\nabla \\mathbf{u})^\\top \\right)$。\n    - 拉梅参数：$\\lambda_{\\mathrm{Lame}} = \\kappa - \\frac{2}{3}\\mu$。\n    - 线性化应力：$\\mathbf{P}_{\\mathrm{lin}} \\approx \\lambda_{\\mathrm{Lame}} \\, \\mathrm{tr}(\\boldsymbol{\\varepsilon}) \\, \\mathbf{I} + 2 \\mu \\boldsymbol{\\varepsilon}$。\n    - 不一致体力：$\\mathbf{b}_{\\mathrm{lin}}(\\lambda,\\mathbf{X}) = -\\nabla \\cdot \\mathbf{P}_{\\mathrm{lin}}(\\lambda,\\mathbf{X})$。\n- **离散化和数值方法**：\n    - 网格：$N_x \\times N_y$ 单元的结构化矩形网格。\n    - 内能积分：高斯求积，$E_{\\mathrm{int}}(\\lambda_i) \\approx \\sum_{e} \\sum_{q=1}^{n_q} W(\\mathbf{F}(\\lambda_i,\\mathbf{X}_{e,q})) \\, w_q \\, A_e$。\n    - 外功积分：梯形法则，$W_{\\mathrm{ext}}(0 \\to \\lambda_n) \\approx \\sum_{i=1}^{n} \\frac{\\dot{W}_{\\mathrm{ext}}(\\lambda_{i-1}) + \\dot{W}_{\\mathrm{ext}}(\\lambda_i)}{2} (\\lambda_i - \\lambda_{i-1})$。\n    - 体力计算：使用中心有限差分计算 $\\nabla \\cdot \\mathbf{P}$，步长与单元尺寸成比例。\n- **诊断**：\n    - 能量残差：$r = E_{\\mathrm{int}}(\\lambda_n) - W_{\\mathrm{ext}}(0 \\to \\lambda_n)$。\n    - 标记条件：$r  \\tau_{\\mathrm{abs}} + \\tau_{\\mathrm{rel}} \\, E_{\\mathrm{int}}(\\lambda_n)$。\n- **测试案例**：\n    - 案例A：一致模型，细网格（$N_x=40, N_y=40$），$\\lambda \\in \\{0.0, 0.7, 1.0\\}$，$\\tau_{\\mathrm{abs}}=0.1 \\, \\mathrm{J}$，$\\tau_{\\mathrm{rel}}=10^{-6}$。\n    - 案例B：不一致模型，粗网格（$N_x=6, N_y=6$），其他参数相同。\n    - 案例C：一致模型，零路径（$\\lambda \\in \\{0.0, 0.0\\}$），$N_x=8, N_y=8$。\n    - 公共参数：$L_x=1.0 \\, \\mathrm{m}$，$L_y=1.0 \\, \\mathrm{m}$，$\\mu=10^6 \\, \\mathrm{Pa}$，$\\kappa=5 \\times 10^6 \\, \\mathrm{Pa}$，$c_1=0.5$，$c_2=0.5$，$c_3=0.3$。\n- **输出**：单行，逗号分隔的布尔值列表：`[result_A, result_B, result_C]`。\n\n### 步骤 2: 使用提取的给定信息进行验证\n\n对该问题进行严格验证。\n1.  **科学或事实不健全性**：该问题基于连续介质力学、超弹性和有限元法（FEM）的既定原理。使用预设位移场和相应的平衡体力是创建验证测试用例（制造解法）的标准技术。Neo-Hookean模型是经典的超弹性定律。所有原理都是健全的。\n2.  **无法形式化或不相关**：该问题高度形式化，与计算固体力学中的能量原理这一特定主题直接相关。它需要对特定的数学和数值构造进行形式化和实现。\n3.  **不完整或矛盾的设置**：问题陈述异常详细，提供了所有必要的运动学定义、本构律、材料参数、离散化方案和测试用例规范。没有明显的矛盾。为$\\lambda_{\\mathrm{Lame}}$提供一个特定的（尽管对于二维在物理上不一致）公式，是为测试目的而有意设置的“错误”模型规范的一部分，而不是问题本身的缺陷。\n4.  **不切实际或不可行**：物理参数在软材料的合理范围内。数值任务（求积、有限差分）是标准的，并且在计算上是可行的。\n5.  **不适定或结构不良**：该问题是适定的。它定义了一个确定性算法，其输入被完全指定，从而为每个测试用例产生唯一的、可计算的结果。诊断规则是明确的。\n6.  **伪深刻、琐碎或同义反复**：该问题需要一个非凡的实现，涉及符号微分、数值积分和数值微分，所有这些都集成到一个内聚的诊断工具中。这是一项实质性的计算任务。\n7.  **超出科学可验证性范围**：通过实现所描述的算法，结果是计算上可验证的。\n\n### 步骤 3: 结论和行动\n\n该问题是有效的。它是一个定义明确、科学合理且全面的计算力学问题。我将继续生成解决方案。\n\n### 解决方案设计\n\n解决方案将使用Python和NumPy库实现。逻辑遵循问题陈述中列出的步骤，为每个测试用例构建和评估能量诊断。\n\n**1. 解析预备知识**\n基础位移场由 $\\mathbf{u}_0(\\mathbf{X}) = (u_{0x}, u_{0y})^\\top$ 给出，其中：\n$$u_{0x}(X,Y) = c_1 \\frac{X^2}{L_x^2} + c_2 \\frac{Y^2}{L_y^2}$$\n$$u_{0y}(X,Y) = c_3 \\frac{XY}{L_x L_y}$$\n该场的梯度 $\\nabla \\mathbf{u}_0$ 是解析计算的。其分量为 $(\\nabla \\mathbf{u}_0)_{ij} = \\partial u_{0i} / \\partial X_j$：\n$$\n\\nabla \\mathbf{u}_0(\\mathbf{X}) =\n\\begin{pmatrix}\n\\frac{\\partial u_{0x}}{\\partial X}  \\frac{\\partial u_{0x}}{\\partial Y} \\\\\n\\frac{\\partial u_{0y}}{\\partial X}  \\frac{\\partial u_{0y}}{\\partial Y}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n2c_1 X / L_x^2  2c_2 Y / L_y^2 \\\\\nc_3 Y / (L_x L_y)  c_3 X / (L_x L_y)\n\\end{pmatrix}\n$$\n那么，对于给定的载荷参数 $\\lambda$ 和位置 $\\mathbf{X}$，变形梯度为 $\\mathbf{F}(\\lambda, \\mathbf{X}) = \\mathbf{I} + \\lambda \\nabla \\mathbf{u}_0(\\mathbf{X})$。\n\n**2. 数值积分方案**\n内能 $E_{\\mathrm{int}}$ 和外部功率 $\\dot{W}_{\\mathrm{ext}}$ 都是在域 $\\Omega$ 上的体积积分。我们将 $\\Omega$ 离散化为一个 $N_x \\times N_y$ 的矩形单元网格，每个单元的面积为 $A_e = (L_x/N_x) \\times (L_y/N_y)$。在每个单元内，使用标准的 $2 \\times 2$ 高斯求积法来近似积分。这涉及到在每个单元内的 $n_q=4$ 个特定点上计算被积函数，并用适当的权重将它们相加。因此，函数 $f(\\mathbf{X})$ 在单元 $e$ 上的积分近似为：\n$$ \\int_e f(\\mathbf{X}) dA \\approx \\sum_{q=1}^{4} f(\\mathbf{X}_{e,q}) \\frac{A_e}{4} $$\n在 $\\Omega$ 上的总积分是所有单元贡献的总和。\n\n**3. 内能计算**\n在给定载荷水平 $\\lambda_i$ 时的内能为 $E_{\\mathrm{int}}(\\lambda_i) = \\int_{\\Omega} W(\\mathbf{F}(\\lambda_i, \\mathbf{X})) dV$。使用数值积分方案：\n$$ E_{\\mathrm{int}}(\\lambda_i) \\approx \\sum_{e=1}^{N_x N_y} \\sum_{q=1}^{4} W(\\mathbf{F}(\\lambda_i, \\mathbf{X}_{e,q})) \\frac{A_e}{4} $$\n函数 $W(\\mathbf{F})$ 是指定的可压缩Neo-Hookean应变能密度。\n\n**4. 外功计算**\n外部功率为 $\\dot{W}_{\\mathrm{ext}}(\\lambda) = \\int_{\\Omega} \\mathbf{b}(\\lambda, \\mathbf{X}) \\cdot \\mathbf{u}_0(\\mathbf{X}) dV$。这个积分也使用 $2 \\times 2$ 高斯求积法进行计算。体力 $\\mathbf{b}$ 本身是在每个求积点 $\\mathbf{X}_{e,q}$ 处，使用中心有限差分法计算应力张量 $\\mathbf{P}$ 的散度来数值计算的：\n$$ (\\nabla \\cdot \\mathbf{P})_i = \\sum_j \\frac{\\partial P_{ij}}{\\partial X_j} \\approx \\sum_j \\frac{P_{ij}(\\mathbf{X} + \\frac{h_j}{2}\\mathbf{e}_j) - P_{ij}(\\mathbf{X} - \\frac{h_j}{2}\\mathbf{e}_j)}{h_j} $$\n其中 $h_1 = L_x/N_x$ 和 $h_2 = L_y/N_y$ 是单元尺寸。对于给定的测试用例，应力 $\\mathbf{P}$ 要么根据一致的Neo-Hookean定律计算，要么根据不一致的线性化定律计算。然后，使用梯形法则沿载荷路径 $\\{\\lambda_0, \\lambda_1, \\dots, \\lambda_n\\}$ 对功率 $\\dot{W}_{\\mathrm{ext}}(\\lambda)$ 进行积分，从而计算出总外功 $W_{\\mathrm{ext}}(0 \\to \\lambda_n)$。\n\n**5. 诊断评估**\n对于每个测试用例，计算最终内能 $E_{\\mathrm{int}}(\\lambda_n)$ 和总外功 $W_{\\mathrm{ext}}(0 \\to \\lambda_n)$。计算能量残差 $r$，并检查诊断条件 $r  \\tau_{\\mathrm{abs}} + \\tau_{\\mathrm{rel}} |E_{\\mathrm{int}}(\\lambda_n)|$。为了稳健性，在相对容差项中使用了 $E_{\\mathrm{int}}$ 的绝对值，尽管对于给定的位移场，能量是非负的。\n\n- 案例A使用一致的能量学。残差 $r$ 应该很小，仅由数值离散化误差（积分的求积法、散度的有限差分、路径积分的梯形法则）引起。在细网格下，此误差应低于指定的容差。预期结果为 `False`。\n- 案例B使用不一致的公式：$E_{\\mathrm{int}}$ 来自非线性的Neo-Hookean模型，而 $W_{\\mathrm{ext}}$ 来自线性化的应力模型。这种根本性的不匹配预计会产生一个显著的、非物理的能量残差，该残差与网格细化无关，并应被诊断工具标记。预期结果为 `True`。\n- 案例C涉及一个零长度的载荷路径 ($\\lambda_0=\\lambda_n=0$)。在 $\\lambda=0$ 时，$\\mathbf{F}=\\mathbf{I}$，$J=1$，并且应变能密度 $W$ 为零。因此，$E_{\\mathrm{int}}(0)=0$。在零长度区间上对 $W_{\\mathrm{ext}}$ 进行路径积分也为零。残差 $r$ 将精确为 $0$，这小于正的绝对容差 $\\tau_{\\mathrm{abs}}$。预期结果为 `False`。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass EnergyDiagnosticSolver:\n    \"\"\"\n    一个求解器，用于形式化并测试一个保守载荷下非线性超弹性系统的离散能量诊断。\n    \"\"\"\n    def __init__(self, case_params):\n        \"\"\"使用特定测试用例的参数初始化求解器。\"\"\"\n        self.Lx = case_params[\"Lx\"]\n        self.Ly = case_params[\"Ly\"]\n        self.Nx = case_params[\"Nx\"]\n        self.Ny = case_params[\"Ny\"]\n        self.mu = case_params[\"mu\"]\n        self.kappa = case_params[\"kappa\"]\n        self.c1 = case_params[\"c1\"]\n        self.c2 = case_params[\"c2\"]\n        self.c3 = case_params[\"c3\"]\n        self.lambdas = case_params[\"lambdas\"]\n        self.model_type = case_params[\"model_type\"]\n        self.tau_abs = case_params[\"tau_abs\"]\n        self.tau_rel = case_params[\"tau_rel\"]\n        \n        self.dx = self.Lx / self.Nx\n        self.dy = self.Ly / self.Ny\n        self.Ae = self.dx * self.dy\n        \n        # 参考[-1,1]^2单元上2x2高斯求积的求积参数\n        a = 1.0 / np.sqrt(3)\n        self.quad_points_ref = np.array([\n            [-a, -a], [ a, -a],\n            [-a,  a], [ a,  a]\n        ])\n        self.quad_weights_ref = np.array([1.0, 1.0, 1.0, 1.0])\n        self.n_quad = len(self.quad_weights_ref)\n        \n        self.d = 2 # 问题是二维平面应变\n\n    def u0_fn(self, X, Y):\n        \"\"\"计算(X, Y)处的基础位移场 u0。\"\"\"\n        u0x = self.c1 * X**2 / self.Lx**2 + self.c2 * Y**2 / self.Ly**2\n        u0y = self.c3 * X * Y / (self.Lx * self.Ly)\n        return np.array([u0x, u0y])\n\n    def grad_u0_fn(self, X, Y):\n        \"\"\"计算(X, Y)处的基础位移场的梯度。\"\"\"\n        du0x_dX = 2 * self.c1 * X / self.Lx**2\n        du0x_dY = 2 * self.c2 * Y / self.Ly**2\n        du0y_dX = self.c3 * Y / (self.Lx * self.Ly)\n        du0y_dY = self.c3 * X / (self.Lx * self.Ly)\n        return np.array([[du0x_dX, du0x_dY], [du0y_dX, du0y_dY]])\n\n    def F_fn(self, X, Y, lam):\n        \"\"\"计算给定lambda时(X, Y)处的变形梯度 F。\"\"\"\n        return np.identity(self.d) + lam * self.grad_u0_fn(X, Y)\n\n    def W_neo_hookean_fn(self, F):\n        \"\"\"计算Neo-Hookean应变能密度。\"\"\"\n        J = np.linalg.det(F)\n        if J = 0: return np.inf\n        I1 = np.trace(F.T @ F)\n        W = self.mu / 2 * (I1 - self.d - 2 * np.log(J)) + self.kappa / 2 * (np.log(J))**2\n        return W\n\n    def P_neo_hookean_fn(self, F):\n        \"\"\"计算Neo-Hookean模型的第一Piola-Kirchhoff应力。\"\"\"\n        J = np.linalg.det(F)\n        if J = 0: return np.full((self.d, self.d), np.nan)\n        F_inv_T = np.linalg.inv(F).T\n        P = self.mu * (F - F_inv_T) + self.kappa * np.log(J) * F_inv_T\n        return P\n\n    def P_linearized_fn(self, X, Y, lam):\n        \"\"\"计算不一致的线性化第一Piola-Kirchhoff应力。\"\"\"\n        grad_u = lam * self.grad_u0_fn(X, Y)\n        epsilon = 0.5 * (grad_u + grad_u.T)\n        lame_lambda = self.kappa - (2/3) * self.mu  # 根据问题规范\n        tr_epsilon = np.trace(epsilon)\n        P_lin = lame_lambda * tr_epsilon * np.identity(self.d) + 2 * self.mu * epsilon\n        return P_lin\n\n    def b_fn(self, X, Y, lam):\n        \"\"\"通过对应力P进行数值微分来计算体力b。\"\"\"\n        hx, hy = self.dx, self.dy\n        \n        stress_fn = (self.P_neo_hookean_fn if self.model_type == 'consistent'\n                     else self.P_linearized_fn)\n\n        if self.model_type == 'consistent':\n            P_xp = stress_fn(self.F_fn(X + hx/2, Y, lam))\n            P_xm = stress_fn(self.F_fn(X - hx/2, Y, lam))\n            P_yp = stress_fn(self.F_fn(X, Y + hy/2, lam))\n            P_ym = stress_fn(self.F_fn(X, Y - hy/2, lam))\n        else:\n            P_xp = stress_fn(X + hx/2, Y, lam)\n            P_xm = stress_fn(X - hx/2, Y, lam)\n            P_yp = stress_fn(X, Y + hy/2, lam)\n            P_ym = stress_fn(X, Y - hy/2, lam)\n\n        if np.any(np.isnan(P_xp)) or np.any(np.isnan(P_xm)) or \\\n           np.any(np.isnan(P_yp)) or np.any(np.isnan(P_ym)):\n            return np.array([np.nan, np.nan])\n\n        dP_dX = (P_xp - P_xm) / hx\n        dP_dY = (P_yp - P_ym) / hy\n        \n        div_P = np.array([dP_dX[0, 0] + dP_dY[0, 1], dP_dX[1, 0] + dP_dY[1, 1]])\n        return -div_P\n\n    def _integrate_over_domain(self, integrand_fn):\n        \"\"\"使用求积法在域上积分一个函数的通用函数。\"\"\"\n        total_integral = 0.0\n        for i in range(self.Nx):\n            for j in range(self.Ny):\n                x_el_min, y_el_min = i * self.dx, j * self.dy\n                for k in range(self.n_quad):\n                    xi, eta = self.quad_points_ref[k]\n                    X_q = x_el_min + self.dx / 2 * (1 + xi)\n                    Y_q = y_el_min + self.dy / 2 * (1 + eta)\n                    \n                    value = integrand_fn(X_q, Y_q)\n                    if np.isnan(value): return np.nan\n                    \n                    # 物理空间中的求积权重为 (weight_ref * Area_element / 4)\n                    w_q_phys = self.quad_weights_ref[k] * self.Ae / 4.0\n                    total_integral += value * w_q_phys\n        return total_integral\n\n    def compute_internal_energy(self, lam):\n        \"\"\"计算给定lambda的总内能 E_int。\"\"\"\n        integrand = lambda X, Y: self.W_neo_hookean_fn(self.F_fn(X, Y, lam))\n        return self._integrate_over_domain(integrand)\n\n    def compute_external_work_rate(self, lam):\n        \"\"\"计算给定lambda的总外部功率 dW_ext/dlambda。\"\"\"\n        integrand = lambda X, Y: np.dot(self.b_fn(X, Y, lam), self.u0_fn(X, Y))\n        return self._integrate_over_domain(integrand)\n\n    def run_diagnostic(self):\n        \"\"\"为该案例执行完整的能量诊断程序。\"\"\"\n        if len(self.lambdas)  2 or self.lambdas[0] == self.lambdas[-1]:\n            # 对于零长度路径，E_int 和 W_ext 均为0。残差为0。\n            return 0.0  self.tau_abs # False\n\n        lam_n = self.lambdas[-1]\n        E_int_final = self.compute_internal_energy(lam_n)\n\n        W_ext_total = 0.0\n        for i in range(1, len(self.lambdas)):\n            lam_i, lam_im1 = self.lambdas[i], self.lambdas[i-1]\n            delta_lam = lam_i - lam_im1\n\n            W_dot_i = self.compute_external_work_rate(lam_i)\n            W_dot_im1 = self.compute_external_work_rate(lam_im1)\n            \n            if np.isnan(W_dot_i) or np.isnan(W_dot_im1):\n                # 无效的功率（例如由J=0引起）意味着路径失败\n                return True\n\n            W_ext_total += (W_dot_i + W_dot_im1) / 2.0 * delta_lam\n        \n        residual = E_int_final - W_ext_total\n        threshold = self.tau_abs + self.tau_rel * abs(E_int_final)\n\n        return residual  threshold\n\ndef solve():\n    \"\"\"\n    定义并运行能量诊断的测试套件。\n    \"\"\"\n    test_cases = [\n        # 案例A：理想情况，一致，细网格。预期为False。\n        {\n            \"Lx\": 1.0, \"Ly\": 1.0, \"Nx\": 40, \"Ny\": 40, \"mu\": 1.0e6, \"kappa\": 5.0e6,\n            \"c1\": 0.5, \"c2\": 0.5, \"c3\": 0.3, \"lambdas\": [0.0, 0.7, 1.0],\n            \"model_type\": 'consistent', \"tau_abs\": 1.0e-1, \"tau_rel\": 1.0e-6\n        },\n        # 案例B：不一致的能量学，粗网格。预期为True。\n        {\n            \"Lx\": 1.0, \"Ly\": 1.0, \"Nx\": 6, \"Ny\": 6, \"mu\": 1.0e6, \"kappa\": 5.0e6,\n            \"c1\": 0.5, \"c2\": 0.5, \"c3\": 0.3, \"lambdas\": [0.0, 0.7, 1.0],\n            \"model_type\": 'inconsistent', \"tau_abs\": 1.0e-1, \"tau_rel\": 1.0e-6\n        },\n        # 案例C：边界情况，零路径。预期为False。\n        {\n            \"Lx\": 1.0, \"Ly\": 1.0, \"Nx\": 8, \"Ny\": 8, \"mu\": 1.0e6, \"kappa\": 5.0e6,\n            \"c1\": 0.5, \"c2\": 0.5, \"c3\": 0.3, \"lambdas\": [0.0, 0.0],\n            \"model_type\": 'consistent', \"tau_abs\": 1.0e-1, \"tau_rel\": 1.0e-6\n        }\n    ]\n\n    results = []\n    for case_params in test_cases:\n        solver = EnergyDiagnosticSolver(case_params)\n        flag = solver.run_diagnostic()\n        results.append(flag)\n\n    # 最终的打印语句采用确切的所需格式。\n    print(f\"[{','.join(str(r) for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}