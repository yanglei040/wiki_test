{
    "hands_on_practices": [
        {
            "introduction": "本节的第一个实践是一个基础练习。我们将完整地走过一个简单一维杆件混合边界条件问题的求解过程 。通过手动组装刚度矩阵和力向量，然后施加诺伊曼（Neumann）和狄利克雷（Dirichlet）边界条件（使用罚函数法），你将具体地理解这些理论概念如何转化为一个可解的线性系统。这个练习为你搭建了从理论弱形式到数值解的桥梁。",
            "id": "3558610",
            "problem": "模拟一根长度为 $L=1$ 的棱柱杆，其轴向刚度为 $EA=10$。杆的变形由控制方程 $-\\frac{d}{dx}\\!\\left(EA\\,\\frac{du}{dx}\\right)=0$ 在 $0  x  L$ 范围内描述。杆的一端在 $x=0$ 处被固定（狄利克雷边界条件 $u(0)=0$），另一端在 $x=L$ 处受到大小为 $F=0.003$ 的轴向拉力（诺伊曼边界条件 $EA\\frac{du}{dx}|_{x=L} = F$）。使用包含两个等长线性杆单元的有限元模型，计算位于 $x=L/2$ 的中间节点（节点2）的位移。",
            "solution": "首先，我们根据问题描述建立有限元模型。\n\n**1. 单元刚度矩阵**\n对于长度为 $L_e$ 的线性杆单元，其单元刚度矩阵为 $k^{(e)} = \\frac{EA}{L_e} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix}$。在本问题中，杆被分为两个等长的单元，因此每个单元的长度为 $L_e = L/2 = 0.5$。代入 $EA=10$，我们得到：\n$k^{(e)} = \\frac{10}{0.5} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix} = 20 \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix}$。\n\n**2. 全局刚度矩阵与力向量**\n通过组合两个单元的刚度矩阵，我们得到包含三个节点的全局刚度矩阵 $K$：\n$$\nK = \\begin{pmatrix} 20  -20  0 \\\\ -20  20+20  -20 \\\\ 0  -20  20 \\end{pmatrix} = \\begin{pmatrix} 20  -20  0 \\\\ -20  40  -20 \\\\ 0  -20  20 \\end{pmatrix}\n$$\n全局力向量 $\\boldsymbol{f}$ 包含来自诺伊曼边界条件的节点力。力 $F=0.003$ 施加在节点3（$x=L$）上。\n$$\n\\boldsymbol{f} = \\begin{Bmatrix} 0 \\\\ 0 \\\\ 0.003 \\end{Bmatrix}\n$$\n\n**3. 施加边界条件并求解**\n我们在节点1处（$x=0$）的狄利克雷边界条件 $u_1=0$ 将使用罚函数法施加。我们选择一个大的罚参数 $\\alpha$，例如 $\\alpha = 10^7 \\times K_{11} = 10^7 \\times 20 = 2 \\times 10^8$。然后修改线性系统 $K \\boldsymbol{u} = \\boldsymbol{f}$：\n- 将 $K_{11}$ 修改为 $K_{11} + \\alpha$。\n- 将 $f_1$ 修改为 $f_1 + \\alpha \\bar{u}_1$（其中规定的位移 $\\bar{u}_1=0$）。\n\n修改后的系统变为：\n$$\n\\begin{pmatrix} 20 + 2 \\times 10^8  -20  0 \\\\ -20  40  -20 \\\\ 0  -20  20 \\end{pmatrix} \\begin{Bmatrix} u_1 \\\\ u_2 \\\\ u_3 \\end{Bmatrix} = \\begin{Bmatrix} 0 \\\\ 0 \\\\ 0.003 \\end{Bmatrix}\n$$\n求解这个线性方程组可以得到节点位移。我们关心的是 $u_2$。从系统的最后两个方程可以得到：\n- $-20 u_2 + 20 u_3 = 0.003 \\implies u_3 - u_2 = 0.00015$\n- $-20 u_1 + 40 u_2 - 20 u_3 = 0$\n\n由于罚参数 $\\alpha$ 很大，位移 $u_1$ 将非常接近于零。因此，第二个方程可以近似为 $40 u_2 - 20 u_3 \\approx 0$，即 $u_3 \\approx 2 u_2$。\n将此关系代入第一个方程中：\n$2 u_2 - u_2 = 0.00015 \\implies u_2 = 0.00015$。\n\n因此，节点2的位移是 $1.5 \\times 10^{-4}$。",
            "answer": "$$\\boxed{1.500 \\times 10^{-4}}$$"
        },
        {
            "introduction": "在节点力概念的基础上，本实践将聚焦于二维问题中诺伊曼（Neumann）边界条件的稳健实施 。你将编写代码，根据给定的边界牵引力场计算“一致”的节点载荷，这涉及到在单元边界上的数值积分（求积）。这项技能对于处理弯曲边界尤为重要，因为它需要使用等参映射来精确地将牵引力转化为等效节点力，这是开发通用有限元代码的一项关键能力。",
            "id": "3558590",
            "problem": "考虑一个二维固体的小应变平衡，其中 Cauchy 应力场用 $\\boldsymbol{\\sigma}$ 表示，Neumann 边界 $\\Gamma_N$ 上的给定面力用 $\\bar{\\boldsymbol{t}}$ 表示。从虚功原理（该原理源于 Newton 定律和线性动量守恒）出发，弱形式引入了外面力虚功项 $\\int_{\\Gamma_N} \\delta \\boldsymbol{u}^T \\bar{\\boldsymbol{t}} \\, d\\Gamma$，其中 $\\delta \\boldsymbol{u}$ 是虚位移场。在有限元法 (FEM) 中，虚位移近似为 $\\delta \\boldsymbol{u} = \\boldsymbol{N} \\, \\delta \\hat{\\boldsymbol{u}}$，其中 $\\boldsymbol{N}$ 是形函数矩阵，$\\delta \\hat{\\boldsymbol{u}}$ 是节点虚位移。因此，一致性节点面力载荷向量由以下边界积分定义\n$$\n\\boldsymbol{f}_{\\Gamma_N} = \\int_{\\Gamma_N} \\boldsymbol{N}^T \\, \\bar{\\boldsymbol{t}} \\, d\\Gamma.\n$$\n为了对每个边界边对此量进行数值计算和组装，我们使用从参数 $\\xi \\in [-1,1]$ 的一维参考线段到物理边界边的等参映射。设该边有 $n$ 个节点，其物理坐标为 $\\boldsymbol{x}_a \\in \\mathbb{R}^2$，其中 $a \\in \\{1,\\dots,n\\}$。令 $N_a(\\xi)$ 表示边形函数，$\\boldsymbol{x}(\\xi) = \\sum_{a=1}^n N_a(\\xi) \\boldsymbol{x}_a$ 表示该映射。线单元的 Jacobian 因子为 $J_\\Gamma(\\xi) = \\left\\| \\dfrac{\\partial \\boldsymbol{x}}{\\partial \\xi} \\right\\|$。对于均匀厚度 $t_h$，该边的一致性节点载荷向量为\n$$\n\\boldsymbol{f}^{(e)} = \\int_{-1}^{1} \\boldsymbol{N}(\\xi)^T \\, \\bar{\\boldsymbol{t}}(\\boldsymbol{x}(\\xi)) \\, J_\\Gamma(\\xi) \\, t_h \\, d\\xi,\n$$\n其中 $\\boldsymbol{N}(\\xi)$ 是块对角矩阵，包含与每个节点的两个位移分量相关联的标量形函数 $N_a(\\xi)$。\n\n使用具有 $n_q$ 个点 $\\{\\xi_i, w_i\\}_{i=1}^{n_q}$ 的 Gauss–Legendre 求积来近似该积分。对于一个 $2$ 节点线单元边，使用 $[-1,1]$ 上的标准线性形函数 $N_1(\\xi) = \\dfrac{1-\\xi}{2}$ 和 $N_2(\\xi) = \\dfrac{1+\\xi}{2}$。对于一个在参考位置 $\\xi = -1, 0, 1$ 处有节点的 $3$ 节点二次线单元边，使用 $N_1(\\xi) = \\dfrac{\\xi(\\xi-1)}{2}$、$N_2(\\xi) = 1 - \\xi^2$ 和 $N_3(\\xi) = \\dfrac{\\xi(\\xi+1)}{2}$。在所有情况下，从等参映射导数 $\\dfrac{\\partial \\boldsymbol{x}}{\\partial \\xi} = \\sum_{a=1}^n \\dfrac{dN_a}{d\\xi} \\boldsymbol{x}_a$ 计算 $J_\\Gamma(\\xi)$，并设 $J_\\Gamma(\\xi) = \\left\\| \\dfrac{\\partial \\boldsymbol{x}}{\\partial \\xi} \\right\\|$。\n\n假设所有量都是无量纲的；报告无量纲的数值。\n\n实现一个程序，为以下边界边测试套件计算一致性边界面力载荷向量。对于每个边，使用适当的 Gauss–Legendre 求积和上述等参映射，计算局部一致性节点面力载荷向量 $\\boldsymbol{f}^{(e)}$。\n\n测试案例 A（正常路径，在直的 $2$ 节点边上的恒定面力）：\n- 边节点：$\\boldsymbol{x}_1 = (0,0)$，$\\boldsymbol{x}_2 = (1,0)$。\n- 厚度：$t_h = 1$。\n- 面力：对于边上的所有 $\\boldsymbol{x}$，$\\bar{\\boldsymbol{t}}(\\boldsymbol{x}) = (2,-1)$。\n- 求积：在 $[-1,1]$ 上使用 $n_q = 2$ 个 Gauss 点。\n- 此案例所需输出：按 $[f_{1x}, f_{1y}, f_{2x}, f_{2y}]$ 顺序排列的局部一致性节点载荷向量分量。\n\n测试案例 B（在直的 $2$ 节点边上的线性变化面力）：\n- 边节点：$\\boldsymbol{x}_1 = (0,0)$，$\\boldsymbol{x}_2 = (1,0)$。\n- 厚度：$t_h = 1$。\n- 面力：$\\bar{\\boldsymbol{t}}(\\boldsymbol{x}) = (x, 0)$，其中 $x$ 是 $\\boldsymbol{x}$ 的第一个坐标。\n- 求积：在 $[-1,1]$ 上使用 $n_q = 2$ 个 Gauss 点。\n- 此案例所需输出：按 $[f_{1x}, f_{1y}, f_{2x}, f_{2y}]$ 顺序排列的局部一致性节点载荷向量分量。\n\n测试案例 C（具有二次映射和恒定面力的弯曲 $3$ 节点边）：\n- 边节点：$\\boldsymbol{x}_1 = (0,0)$，$\\boldsymbol{x}_2 = (0.5,0.2)$，$\\boldsymbol{x}_3 = (1,0)$。\n- 厚度：$t_h = 2$。\n- 面力：对于边上的所有 $\\boldsymbol{x}$，$\\bar{\\boldsymbol{t}}(\\boldsymbol{x}) = (0,1)$。\n- 求积：在 $[-1,1]$ 上使用 $n_q = 3$ 个 Gauss 点。\n- 此案例所需输出：按 $[f_{1x}, f_{1y}, f_{2x}, f_{2y}, f_{3x}, f_{3y}]$ 顺序排列的局部一致性节点载荷向量分量。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。\n- 该列表必须按顺序连接测试案例 A 的所有分量，然后是测试案例 B 的所有分量，最后是测试案例 C 的所有分量，并使用指定的分量排序。即，输出列表为\n$$\n[ f_{1x}^{A}, f_{1y}^{A}, f_{2x}^{A}, f_{2y}^{A}, f_{1x}^{B}, f_{1y}^{B}, f_{2x}^{B}, f_{2y}^{B}, f_{1x}^{C}, f_{1y}^{C}, f_{2x}^{C}, f_{2y}^{C}, f_{3x}^{C}, f_{3y}^{C} ].\n$$\n- 每个数字在打印输出中应四舍五入到恰好 $10$ 位小数。",
            "solution": "该问题要求计算三个不同边界边在承受面力载荷时的一致性节点载荷向量。此计算的基础是虚功原理，该原理导出了有限元边的一致性节点载荷向量 $\\boldsymbol{f}^{(e)}$ 的定义，即在参考坐标系 $\\xi \\in [-1, 1]$ 中对单元域的边界积分。\n\n控制方程由下式给出：\n$$\n\\boldsymbol{f}^{(e)} = \\int_{-1}^{1} \\boldsymbol{N}(\\xi)^T \\, \\bar{\\boldsymbol{t}}(\\boldsymbol{x}(\\xi)) \\, J_\\Gamma(\\xi) \\, t_h \\, d\\xi\n$$\n其中 $\\boldsymbol{N}(\\xi)$ 是形函数矩阵，$\\bar{\\boldsymbol{t}}$ 是给定的面力向量，$t_h$ 是单元厚度，$J_\\Gamma(\\xi)$ 是从参考坐标 $\\xi$ 到物理坐标 $\\boldsymbol{x}$ 的等参映射的 Jacobian。\n\n该积分使用 Gauss-Legendre 求积进行数值近似。对于具有权重 $w_i$ 和位置 $\\xi_i$ 的 $n_q$ 个求积点，节点载荷向量计算如下：\n$$\n\\boldsymbol{f}^{(e)} \\approx t_h \\sum_{i=1}^{n_q} w_i \\, \\boldsymbol{N}(\\xi_i)^T \\, \\bar{\\boldsymbol{t}}(\\boldsymbol{x}(\\xi_i)) \\, J_\\Gamma(\\xi_i)\n$$\n此向量的分量，表示节点 $a$ 在方向 $k \\in \\{x, y\\}$ 上的力，可以单独计算：\n$$\nf_{ak}^{(e)} \\approx t_h \\sum_{i=1}^{n_q} w_i \\, N_a(\\xi_i) \\, \\bar{t}_k(\\boldsymbol{x}(\\xi_i)) \\, J_\\Gamma(\\xi_i)\n$$\n每个测试案例的计算都通过评估此求和中的各项来进行。关键步骤如下：\n1.  定义等参映射 $\\boldsymbol{x}(\\xi) = \\sum_{a=1}^n N_a(\\xi) \\boldsymbol{x}_a$。\n2.  计算其关于参考坐标的导数 $\\frac{\\partial \\boldsymbol{x}}{\\partial \\xi} = \\sum_{a=1}^n \\frac{dN_a}{d\\xi} \\boldsymbol{x}_a$。\n3.  计算 Jacobian 行列式 $J_\\Gamma(\\xi) = \\left\\| \\frac{\\partial \\boldsymbol{x}}{\\partial \\xi} \\right\\|$。\n4.  对于每个 Gauss 点 $\\xi_i$：\n    a. 计算形函数 $N_a(\\xi_i)$。\n    b. 计算 Jacobian $J_\\Gamma(\\xi_i)$。\n    c. 确定物理坐标 $\\boldsymbol{x}(\\xi_i)$。\n    d. 计算在该物理点上的面力 $\\bar{\\boldsymbol{t}}(\\boldsymbol{x}(\\xi_i))$。\n    e. 累加对每个节点力分量的加权贡献。\n\n对于 $n_q=2$ 的 Gauss-Legendre 求积点 $(\\xi_i, w_i)$ 是 $(\\mp 1/\\sqrt{3}, 1)$，对于 $n_q=3$ 是 $(0, 8/9)$ 和 $(\\mp\\sqrt{3/5}, 5/9)$。\n\n测试案例 A:\n- 边：2 节点线性单元，节点为 $\\boldsymbol{x}_1 = (0,0)$ 和 $\\boldsymbol{x}_2 = (1,0)$。\n- 形函数：$N_1(\\xi) = \\frac{1-\\xi}{2}$，$N_2(\\xi) = \\frac{1+\\xi}{2}$。它们的导数是 $\\frac{dN_1}{d\\xi} = -1/2$，$\\frac{dN_2}{d\\xi} = 1/2$。\n- 映射：$\\boldsymbol{x}(\\xi) = N_1(\\xi)\\boldsymbol{x}_1 + N_2(\\xi)\\boldsymbol{x}_2 = \\frac{1+\\xi}{2}(1,0) = ( (1+\\xi)/2, 0 )$。\n- Jacobian: $\\frac{\\partial\\boldsymbol{x}}{\\partial\\xi} = (\\frac{1}{2}, 0)$，所以 $J_\\Gamma(\\xi) = \\sqrt{(1/2)^2} = 1/2$。Jacobian 是常数。\n- 面力：$\\bar{\\boldsymbol{t}}(\\boldsymbol{x}) = (2,-1)$，为常数。\n- 厚度：$t_h = 1$。\n- 节点载荷：由于被积函数关于 $\\xi$ 是常数，2 点求积是精确的。总分布载荷为 $\\bar{\\boldsymbol{t}} \\cdot (\\text{长度}) \\cdot t_h = (2,-1) \\cdot 1 \\cdot 1 = (2,-1)$。对于线性形函数，这会平均分配到各个节点。因此，每个节点承受总载荷的一半：$\\boldsymbol{f}_1 = (1, -0.5)$ 和 $\\boldsymbol{f}_2 = (1, -0.5)$。\n- 计算出的向量是 $[f_{1x}, f_{1y}, f_{2x}, f_{2y}] = [1.0, -0.5, 1.0, -0.5]$。\n\n测试案例 B:\n- 边：与案例 A 中相同的 2 节点线性单元。$\\boldsymbol{x}(\\xi) = ( (1+\\xi)/2, 0 )$ 且 $J_\\Gamma(\\xi) = 1/2$。\n- 面力：$\\bar{\\boldsymbol{t}}(\\boldsymbol{x}) = (x, 0)$。用 $\\xi$ 表示，即 $\\bar{\\boldsymbol{t}}(\\xi) = ( (1+\\xi)/2, 0 )$。\n- 厚度：$t_h = 1$。\n- 节点载荷：求积涉及对诸如 $N_a(\\xi) \\cdot x(\\xi)$ 的乘积进行积分。对于 $f_{1x}$，被积函数正比于 $N_1(\\xi)x(\\xi) = \\frac{1-\\xi}{2}\\frac{1+\\xi}{2} = \\frac{1-\\xi^2}{4}$，这是一个二次多项式。对于 $f_{2x}$，它正比于 $N_2(\\xi)x(\\xi) = (\\frac{1+\\xi}{2})^2$，也是二次的。2 点 Gauss 求积可精确积分最高 $2n_q-1=3$ 次的多项式，因此结果是精确的。\n- 解析地：\n  $f_{1x} = \\int_{-1}^{1} N_1(\\xi) \\bar{t}_x(\\xi) J_\\Gamma t_h d\\xi = \\int_{-1}^{1} \\frac{1-\\xi}{2} \\cdot \\frac{1+\\xi}{2} \\cdot \\frac{1}{2} \\cdot 1 d\\xi = \\frac{1}{8} \\int_{-1}^{1} (1-\\xi^2) d\\xi = 1/6$。\n  $f_{2x} = \\int_{-1}^{1} N_2(\\xi) \\bar{t}_x(\\xi) J_\\Gamma t_h d\\xi = \\int_{-1}^{1} \\frac{1+\\xi}{2} \\cdot \\frac{1+\\xi}{2} \\cdot \\frac{1}{2} \\cdot 1 d\\xi = \\frac{1}{8} \\int_{-1}^{1} (1+\\xi)^2 d\\xi = 1/3$。\n  y 分量为 0。\n- 计算出的向量是 $[f_{1x}, f_{1y}, f_{2x}, f_{2y}] = [0.1666666667, 0.0, 0.3333333333, 0.0]$。\n\n测试案例 C:\n- 边：3 节点二次单元，节点为 $\\boldsymbol{x}_1 = (0,0)$、$\\boldsymbol{x}_2 = (0.5,0.2)$、$\\boldsymbol{x}_3 = (1,0)$。\n- 形函数：$N_1(\\xi) = \\frac{\\xi(\\xi-1)}{2}$、$N_2(\\xi) = 1-\\xi^2$、$N_3(\\xi) = \\frac{\\xi(\\xi+1)}{2}$。\n- 映射：$\\boldsymbol{x}(\\xi) = N_1(\\xi)\\boldsymbol{x}_1 + N_2(\\xi)\\boldsymbol{x}_2 + N_3(\\xi)\\boldsymbol{x}_3 = (1-\\xi^2)(0.5, 0.2) + \\frac{\\xi(\\xi+1)}{2}(1,0)$。简化后为 $\\boldsymbol{x}(\\xi) = (0.5(1+\\xi), 0.2(1-\\xi^2))$。\n- Jacobian: $\\frac{\\partial \\boldsymbol{x}}{\\partial \\xi} = (0.5, -0.4\\xi)$，所以 $J_\\Gamma(\\xi) = \\sqrt{0.5^2 + (-0.4\\xi)^2} = \\sqrt{0.25 + 0.16\\xi^2}$。\n- 面力：$\\bar{\\boldsymbol{t}}(\\boldsymbol{x}) = (0,1)$，为常数。\n- 厚度：$t_h = 2$。\n- 节点载荷：使用 3 点 Gauss-Legendre 求积计算载荷。由于 $\\bar{t}_x=0$，力的 x 分量为 0。y 分量通过对三个 Gauss 点 $\\xi_1=-\\sqrt{3/5}$、$\\xi_2=0$、$\\xi_3=\\sqrt{3/5}$ 处的贡献求和来计算：\n$$\nf_{ay} \\approx 2 \\sum_{i=1}^{3} w_i N_a(\\xi_i) (1) \\sqrt{0.25 + 0.16\\xi_i^2}\n$$\n数值计算得出：\n- $f_{1x}=0.0$，$f_{1y} \\approx 0.3921450977$。\n- $f_{2x}=0.0$，$f_{2y} \\approx 1.4117490192$。\n- $f_{3x}=0.0$，$f_{3y} \\approx 0.3921450977$。\n几何和载荷关于 y 轴（在参考坐标 $\\xi$ 中）的对称性导致 $f_{1y}=f_{3y}$。\n- 计算出的向量是 $[0.0, 0.3921450977, 0.0, 1.4117490192, 0.0, 0.3921450977]$。\n\n将所有测试案例的结果按规定合并到一个列表中，即可得到最终输出。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes consistent nodal traction load vectors for a series of boundary edges\n    using the Finite Element Method with isoparametric mapping and Gauss-Legendre quadrature.\n    \"\"\"\n\n    def get_shape_functions(n_nodes):\n        \"\"\"Returns shape functions and their derivatives for a given number of nodes.\"\"\"\n        if n_nodes == 2:  # Linear element\n            N = lambda xi: np.array([(1 - xi) / 2, (1 + xi) / 2])\n            dN_dxi = lambda xi: np.array([-0.5, 0.5])\n        elif n_nodes == 3:  # Quadratic element\n            N = lambda xi: np.array([xi * (xi - 1) / 2, 1 - xi**2, xi * (xi + 1) / 2])\n            dN_dxi = lambda xi: np.array([xi - 0.5, -2 * xi, xi + 0.5])\n        else:\n            raise ValueError(\"Only 2-node and 3-node elements are supported.\")\n        return N, dN_dxi\n\n    def compute_nodal_loads(nodes, thickness, traction_func, n_q):\n        \"\"\"\n        Computes the consistent nodal load vector for a single boundary edge.\n        \"\"\"\n        n_nodes = len(nodes)\n        nodal_coords = np.array(nodes)\n        \n        N, dN_dxi = get_shape_functions(n_nodes)\n        \n        gauss_points, gauss_weights = np.polynomial.legendre.leggauss(n_q)\n        \n        f_e = np.zeros(2 * n_nodes)\n        \n        for xi, w in zip(gauss_points, gauss_weights):\n            # Evaluate shape functions and their derivatives at the Gauss point\n            N_vals = N(xi)\n            dN_vals = dN_dxi(xi)\n            \n            # Compute the derivative of the mapping and the Jacobian\n            dxdxi = dN_vals @ nodal_coords\n            jacobian = np.linalg.norm(dxdxi)\n            \n            # Compute the physical coordinate of the Gauss point\n            x_coord = N_vals @ nodal_coords\n            \n            # Evaluate the traction vector at the physical coordinate\n            traction_vec = traction_func(x_coord)\n            \n            # Accumulate the contribution to the nodal force vector\n            for a in range(n_nodes):\n                # Contribution to x-component of force at node a\n                f_e[2 * a] += w * N_vals[a] * traction_vec[0] * jacobian * thickness\n                # Contribution to y-component of force at node a\n                f_e[2 * a + 1] += w * N_vals[a] * traction_vec[1] * jacobian * thickness\n                \n        return f_e\n\n    # Test Case A\n    nodes_A = [[0.0, 0.0], [1.0, 0.0]]\n    thickness_A = 1.0\n    traction_A = lambda x: np.array([2.0, -1.0])\n    nq_A = 2\n    result_A = compute_nodal_loads(nodes_A, thickness_A, traction_A, nq_A)\n\n    # Test Case B\n    nodes_B = [[0.0, 0.0], [1.0, 0.0]]\n    thickness_B = 1.0\n    traction_B = lambda x: np.array([x[0], 0.0])\n    nq_B = 2\n    result_B = compute_nodal_loads(nodes_B, thickness_B, traction_B, nq_B)\n\n    # Test Case C\n    nodes_C = [[0.0, 0.0], [0.5, 0.2], [1.0, 0.0]]\n    thickness_C = 2.0\n    traction_C = lambda x: np.array([0.0, 1.0])\n    nq_C = 3\n    result_C = compute_nodal_loads(nodes_C, thickness_C, traction_C, nq_C)\n\n    # Concatenate all results\n    all_results = np.concatenate([result_A, result_B, result_C])\n\n    # Format the results to 10 decimal places and print\n    formatted_results = [f\"{r:.10f}\" for r in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "最后一个实践将探讨一个关键且更高级的主题：仅含诺伊曼（Neumann）边界条件的问题中出现的奇异性 。这类系统在物理上未受刚体运动的约束，导致其刚度矩阵不可逆。通过这个编程练习，你将研究刚度矩阵的零空间，并探索移除这些非物理模式以获得唯一、有物理意义解的常用实用技术。",
            "id": "3558482",
            "problem": "考虑一个小型应变、静态的二维线性弹性体，其占据的区域为 $\\Omega = [0,1] \\times [0,1]$（单位：米），边界为 $\\partial \\Omega$。设该材料是均匀、各向同性的，并遵循平面应力条件下的线性弹性本构关系，其杨氏模量为 $E = 210 \\times 10^9$ 帕斯卡和泊松比为 $\\nu = 0.3$。设物体的单位厚度为 $h=1$ 米。其控制方程源于线性动量平衡和柯西应力-应变关系：在 $\\Omega$ 内的平衡方程 $\\nabla \\cdot \\boldsymbol{\\sigma} + \\mathbf{b} = \\mathbf{0}$（体力 $\\mathbf{b}=\\mathbf{0}$），运动学方程 $\\boldsymbol{\\varepsilon} = \\tfrac{1}{2}(\\nabla \\mathbf{u} + \\nabla \\mathbf{u}^{\\top})$，以及本构关系 $\\boldsymbol{\\sigma} = \\mathbf{D} \\, \\boldsymbol{\\varepsilon}$，其中 $\\mathbf{D}$ 是各向同性平面应力弹性矩阵。在整个边界 $\\partial \\Omega$ 上，仅给定诺伊曼边界条件，形式为 $\\boldsymbol{\\sigma} \\mathbf{n} = \\bar{\\mathbf{t}}$，其中 $\\mathbf{n}$ 是外法向单位向量，$\\bar{\\mathbf{t}}$ 是指定的单位面积牵引力。为确保合力为零，使用静水压力加载 $\\bar{\\mathbf{t}} = -p \\, \\mathbf{n}$，其中 $p$ 为以帕斯卡为单位的恒定压力，这在物理上对应于均匀的压缩压力。\n\n有限元法（FEM）近似采用线性的三节点常应变三角形（CST）构建。根据虚功原理，离散系统可以写为 $\\mathbf{K} \\, \\mathbf{u} = \\mathbf{f}$，其中 $\\mathbf{K}$ 是由单元贡献 $\\mathbf{K}^{(e)} = h \\, A^{(e)} \\, \\mathbf{B}^{\\top} \\mathbf{D} \\, \\mathbf{B}$ 组装而成的全局对称刚度矩阵，其中 $A^{(e)}$ 是单元面积，$\\mathbf{B}$ 是三角形的常应变-位移矩阵。载荷向量 $\\mathbf{f}$ 是通过边界边上的牵引力积分 $\\int_{\\Gamma_e} \\mathbf{N}^{\\top} \\bar{\\mathbf{t}} \\, ds$ 组装而成，对于均匀牵引力和线性形函数，该积分简化为每个长度为 $L_e$ 的边界边上的 $\\tfrac{L_e}{2} h \\, \\bar{\\mathbf{t}}$，并由两个边节点平分。在仅有诺伊曼边界条件的情况下，刚度矩阵 $\\mathbf{K}$ 是半正定的，其零空间由刚体模态组成。在二维情况下，若无位移约束，刚体零空间的维度预计为 $3$（两个平动和一个平面内转动）。\n\n您的任务是编写一个程序，为一个具有均匀结构化三角形剖分的单位正方形组装有限元刚度矩阵 $\\mathbf{K}$ 和边界载荷向量 $\\mathbf{f}$，然后研究在不同最小约束策略下刚体模态的移除情况。使用材料参数 $E = 210 \\times 10^9$ 帕斯卡和 $\\nu = 0.3$。使用网格分辨率 $N_e = 4$ 个单元/每边，形成一个结构化网格，其中每个正方形沿对角线分割成三角形。在所有边界上施加静水压力 $p = 1 \\times 10^6$ 帕斯卡，使得在 $\\partial \\Omega$ 上 $\\bar{\\mathbf{t}} = -p \\, \\mathbf{n}$。如果计算位移，请以米为单位表示。\n\n定义以下四个测试用例来研究离散算子的零空间：\n\n- 测试用例 1（纯诺伊曼问题）：不施加任何位移约束。计算 $\\mathbf{K}$ 的近零奇异值的数量，这被解释为对应于刚体模态的零空间维度。\n\n- 测试用例 2（最小约束，单节点）：在单个角节点上施加狄利克雷约束 $\\mathbf{u} = \\mathbf{0}$（固定该节点的两个分量）。计算通过消除受约束自由度得到的简化刚度矩阵的近零奇异值的数量。\n\n- 测试用例 3（最小约束，消除转动）：在同一个角节点上施加狄利克雷约束 $\\mathbf{u} = \\mathbf{0}$，并额外约束第二个角节点的竖向位移为零。计算简化刚度矩阵的近零奇异值的数量。\n\n- 测试用例 4（通过拉格朗日乘子施加平均约束）：在两个方向上施加零平均位移约束，即 $\\tfrac{1}{|\\Omega|}\\int_{\\Omega} u_x \\, d\\Omega = 0$ 和 $\\tfrac{1}{|\\Omega|}\\int_{\\Omega} u_y \\, d\\Omega = 0$，在离散系统中使用拉格朗日乘子实现。实践中，这通过约束矩阵 $\\mathbf{C}$ 实现，使得增广系统为 $\\begin{bmatrix} \\mathbf{K}  \\mathbf{C}^{\\top} \\\\ \\mathbf{C}  \\mathbf{0} \\end{bmatrix} \\begin{bmatrix} \\mathbf{u} \\\\ \\boldsymbol{\\lambda} \\end{bmatrix} = \\begin{bmatrix} \\mathbf{f} \\\\ \\mathbf{0} \\end{bmatrix}$，其中 $\\mathbf{C}$ 的一行对应所有 x-位移自由度的位置为1，另一行对应所有 y-位移自由度的位置为1。计算该增广算子的近零奇异值的数量。\n\n对于每个测试用例，通过计算算子（$\\mathbf{K}$、简化后的 $\\mathbf{K}$ 或增广算子）满足 $\\sigma_i  \\varepsilon \\, \\max_j \\sigma_j$ 条件的奇异值 $\\sigma_i$ 的数量来估计零空间维度，其中容差为 $\\varepsilon = 10^{-9}$。在每种情况下对相应的矩阵使用奇异值分解。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $[r_1,r_2,r_3,r_4]$），其中每个 $r_i$ 是测试用例 $i$ 的近零奇异值的整数计数。此输出无单位。程序必须是自包含的，且不应需要任何用户输入或外部文件。材料参数和载荷的数值必须与上面给出的完全一致，单位也如所述；最终输出纯粹是如上所述的整数列表，无单位。",
            "solution": "求解过程如下：首先，我们为指定问题构建有限元法（FEM）模型。这包括生成网格、定义单元属性以及组装全局刚度矩阵 $\\mathbf{K}$。随后，我们通过操作或增广该矩阵来处理四个测试用例中的每一个，然后使用奇异值分解（SVD）确定其零空间的维度。\n\n**1. 有限元离散化**\n\n该问题涉及一个处于平面应力条件下的二维线性弹性体。其区域为单位正方形 $\\Omega = [0,1] \\times [0,1]$。材料由杨氏模量 $E = 210 \\times 10^9 \\, \\text{Pa}$ 和泊松比 $\\nu = 0.3$ 定义。物体的单位厚度为 $h = 1 \\, \\text{m}$。\n\n应力向量 $\\boldsymbol{\\sigma} = [\\sigma_{xx}, \\sigma_{yy}, \\sigma_{xy}]^{\\top}$ 与应变向量 $\\boldsymbol{\\varepsilon} = [\\varepsilon_{xx}, \\varepsilon_{yy}, 2\\varepsilon_{xy}]^{\\top}$ 之间的本构关系由 $\\boldsymbol{\\sigma} = \\mathbf{D} \\boldsymbol{\\varepsilon}$ 给出。对于各向同性平面应力，弹性矩阵 $\\mathbf{D}$ 为：\n$$\n\\mathbf{D} = \\frac{E}{1 - \\nu^2}\n\\begin{bmatrix}\n1  \\nu  0 \\\\\n\\nu  1  0 \\\\\n0  0  \\frac{1 - \\nu}{2}\n\\end{bmatrix}\n$$\n\n该区域使用线性的三节点常应变三角形（CST）的结构化网格进行离散化。网格每边有 $N_e = 4$ 个划分，从而形成一个包含 $(N_e+1) \\times (N_e+1) = 5 \\times 5 = 25$ 个节点的网格。$N_e^2 = 16$ 个正方形单元中的每一个都被划分为两个三角形，总共有 $32$ 个单元。总自由度（DOFs）为每个节点 $2$ 个（一个水平位移，一个竖直位移），总计 $2 \\times 25 = 50$ 个自由度。\n\n对于一个节点坐标为 $(x_1, y_1)$、$(x_2, y_2)$ 和 $(x_3, y_3)$ 的CST单元，其应变-位移矩阵 $\\mathbf{B}$ 在单元内是恒定的，由以下公式给出：\n$$\n\\mathbf{B} = \\frac{1}{2A^{(e)}}\n\\begin{bmatrix}\ny_2-y_3  0  y_3-y_1  0  y_1-y_2  0 \\\\\n0  x_3-x_2  0  x_1-x_3  0  x_2-x_1 \\\\\nx_3-x_2  y_2-y_3  x_1-x_3  y_3-y_1  x_2-x_1  y_1-y_2\n\\end{bmatrix}\n$$\n其中 $A^{(e)}$ 是单元的面积。单元刚度矩阵 $\\mathbf{K}^{(e)}$（一个 $6 \\times 6$ 矩阵）通过在单元体积上对 $\\mathbf{B}^{\\top} \\mathbf{D} \\mathbf{B}$ 进行积分来计算：\n$$\n\\mathbf{K}^{(e)} = h A^{(e)} \\mathbf{B}^{\\top} \\mathbf{D} \\mathbf{B}\n$$\n\n全局刚度矩阵 $\\mathbf{K}$（一个 $50 \\times 50$ 矩阵）是通过将所有 $32$ 个单元刚度矩阵 $\\mathbf{K}^{(e)}$ 的贡献累加到其对应的全局自由度位置来组装的。\n\n**2. 算子零空间分析**\n\n一个在整个边界上仅指定了诺伊曼边界条件的问题，在物理上可以自由进行刚体运动（平动和转动），而不会产生任何应变，因此也不会产生应力。这反映在全局刚度矩阵 $\\mathbf{K}$ 是奇异的（半正定的）。其零空间对应于这些刚体模态。对于一个二维问题，存在三种此类模态：两个平动和一个平面内转动。\n\n为了数值化地确定一个矩阵 $\\mathbf{M}$ 的零空间维度（即秩亏），我们使用其奇异值分解（SVD）。奇异值 $\\sigma_i$ 中为零的数量对应于零度。由于有限精度计算，我们计算数值上接近于零的奇异值的数量。按照规定，如果一个奇异值 $\\sigma_i$ 满足 $\\sigma_i  \\varepsilon \\cdot \\max_j \\sigma_j$，则认为其接近于零，容差为 $\\varepsilon = 10^{-9}$。\n\n**3. 测试用例的实现**\n\n**测试用例 1：纯诺伊曼问题**\n不施加任何位移约束。要分析的算子是原始的全局刚度矩阵 $\\mathbf{K}$。我们期望找到一个对应于三个刚体模态的零度。\n$$\n\\text{Nullity}(\\mathbf{K}) = 3\n$$\n\n**测试用例 2：最小约束（单节点）**\n在单个角节点上施加位移约束 $\\mathbf{u} = \\mathbf{0}$，例如在 $(0,0)$ 处的节点。这对应于将前两个自由度（节点0的 u_x 和 u_y）设置为零。通过从全局矩阵 $\\mathbf{K}$ 中移除与这些自由度对应的行和列来实现，从而得到一个简化的矩阵 $\\mathbf{K}_{red}$。固定单个节点可以阻止两种平动模态。然而，物体仍然可以围绕该固定点旋转。因此，我们期望简化后的系统还剩下一个刚体模态。\n$$\n\\text{Nullity}(\\mathbf{K}_{red}) = 1\n$$\n\n**测试用例 3：最小约束（消除转动）**\n除了像用例2中那样固定 $(0,0)$ 处的节点外，还约束第二个角节点（例如在 $(1,0)$ 处）的竖向位移为零。这三个约束足以消除所有三个刚体模态：通过固定第一个节点消除了两个平动，而对第二个节点的最终约束阻止了围绕第一个节点的任何转动。得到的简化矩阵 $\\mathbf{K}_{red}$ 应该是满秩的（正定的）。\n$$\n\\text{Nullity}(\\mathbf{K}_{red}) = 0\n$$\n\n**测试用例 4：通过拉格朗日乘子施加平均约束**\n此用例通过强制区域上的平均位移为零来消除刚体平动，即 $\\int_{\\Omega} u_x d\\Omega = 0$ 和 $\\int_{\\Omega} u_y d\\Omega = 0$。在离散系统中，这通过两个约束方程来近似。根据问题描述，这些约束是 $\\sum u_{x,i} = 0$ 和 $\\sum u_{y,i} = 0$，其中求和遍历所有节点。这些约束通过使用拉格朗日乘子引入，从而得到增广的鞍点系统：\n$$\n\\begin{bmatrix} \\mathbf{K}  \\mathbf{C}^{\\top} \\\\ \\mathbf{C}  \\mathbf{0} \\end{bmatrix} \\begin{bmatrix} \\mathbf{u} \\\\ \\boldsymbol{\\lambda} \\end{bmatrix} = \\begin{bmatrix} \\mathbf{f} \\\\ \\mathbf{0} \\end{bmatrix}\n$$\n这里，$\\mathbf{C}$ 是一个 $2 \\times 50$ 的矩阵，其中第一行在对应于 x-自由度的位置上为1，其他位置为0；第二行对 y-自由度做同样的处理。要分析的算子是增广矩阵 $\\mathbf{M} = \\begin{bmatrix} \\mathbf{K}  \\mathbf{C}^{\\top} \\\\ \\mathbf{C}  \\mathbf{0} \\end{bmatrix}$。这两个约束有效地消除了两个平动模态。转动模态不受此公式的约束，因为围绕物体几何中心的纯转动导致的净位移为零。因此，我们期望增广算子的零度为1。\n$$\n\\text{Nullity}(\\mathbf{M}) = 1\n$$\n\n以下程序实现了计算这四种用例下零度的整个过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import svdvals\n\ndef solve():\n    \"\"\"\n    Solves the FEM problem for rigid-body mode analysis.\n    \"\"\"\n    \n    # Material and problem parameters\n    E = 210e9  # Young's modulus in Pa\n    nu = 0.3   # Poisson's ratio\n    h = 1.0    # Thickness in m\n    Ne = 4     # Number of elements per side\n    \n    # Derived parameters\n    n_nodes_per_side = Ne + 1\n    n_nodes = n_nodes_per_side**2\n    n_dofs = 2 * n_nodes\n    \n    # 1. Mesh Generation (Nodes and Elements)\n    nodes = np.zeros((n_nodes, 2))\n    for i in range(n_nodes_per_side):\n        for j in range(n_nodes_per_side):\n            node_idx = i * n_nodes_per_side + j\n            nodes[node_idx] = [j / Ne, i / Ne]\n\n    elements = []\n    for i in range(Ne):\n        for j in range(Ne):\n            n1 = i * n_nodes_per_side + j         # Bottom-left\n            n2 = i * n_nodes_per_side + j + 1     # Bottom-right\n            n3 = (i + 1) * n_nodes_per_side + j + 1 # Top-right\n            n4 = (i + 1) * n_nodes_per_side + j     # Top-left\n            # Split square cell along the n1-n3 diagonal\n            elements.append([n1, n2, n3])\n            elements.append([n1, n3, n4])\n    elements = np.array(elements)\n\n    # 2. FEM Assembly\n    # Plane stress constitutive matrix D\n    D_factor = E / (1 - nu**2)\n    D = D_factor * np.array([[1, nu, 0],\n                             [nu, 1, 0],\n                             [0, 0, (1 - nu) / 2]])\n\n    # Global stiffness matrix K\n    K = np.zeros((n_dofs, n_dofs))\n\n    for el_nodes in elements:\n        # Node coordinates for the element\n        x1, y1 = nodes[el_nodes[0]]\n        x2, y2 = nodes[el_nodes[1]]\n        x3, y3 = nodes[el_nodes[2]]\n\n        # Area of the element\n        A_e = 0.5 * np.abs(x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2))\n\n        # Strain-displacement matrix B\n        B = (1 / (2 * A_e)) * np.array([\n            [y2 - y3, 0, y3 - y1, 0, y1 - y2, 0],\n            [0, x3 - x2, 0, x1 - x3, 0, x2 - x1],\n            [x3 - x2, y2 - y3, x1 - x3, y3 - y1, x2 - x1, y1 - y2]\n        ])\n\n        # Element stiffness matrix Ke\n        Ke = h * A_e * (B.T @ D @ B)\n\n        # Assemble Ke into global K\n        dof_map = np.array([2 * n for n in el_nodes for _ in range(2)])\n        dof_map[1::2] += 1\n        \n        K[np.ix_(dof_map, dof_map)] += Ke\n\n    # 3. Nullspace Analysis for each Test Case\n    \n    def count_nullity(matrix, epsilon=1e-9):\n        \"\"\"\n        Calculates the nullity of a matrix by counting near-zero singular values.\n        \"\"\"\n        s = svdvals(matrix)\n        # svdvals returns sorted values, s[0] is the maximum\n        max_sv = s[0]\n        if np.isclose(max_sv, 0):\n            return matrix.shape[0]  # Zero matrix case\n        \n        tolerance = epsilon * max_sv\n        return np.sum(s  tolerance)\n\n    results = []\n\n    # Test Case 1: Pure Neumann problem\n    nullity1 = count_nullity(K)\n    results.append(nullity1)\n\n    # Test Case 2: Minimal constraints, single node fixed\n    all_dofs = np.arange(n_dofs)\n    # Fix node 0 at (0,0) -> DOFs 0 (u_x) and 1 (u_y)\n    constrained_dofs_2 = [0, 1]\n    free_dofs_2 = np.setdiff1d(all_dofs, constrained_dofs_2)\n    K_red_2 = K[np.ix_(free_dofs_2, free_dofs_2)]\n    nullity2 = count_nullity(K_red_2)\n    results.append(nullity2)\n\n    # Test Case 3: Minimal constraints, rotation removed\n    # Fix node 0 at (0,0) and u_y at node located at (1,0)\n    # Node at (1,0) corresponds to grid indices i=0, j=Ne. \n    # Node index = 0 * (Ne+1) + Ne = Ne\n    node_idx_for_rot_constraint = Ne\n    dof_for_rot_constraint = 2 * node_idx_for_rot_constraint + 1\n    \n    constrained_dofs_3 = [0, 1, dof_for_rot_constraint]\n    free_dofs_3 = np.setdiff1d(all_dofs, constrained_dofs_3)\n    K_red_3 = K[np.ix_(free_dofs_3, free_dofs_3)]\n    nullity3 = count_nullity(K_red_3)\n    results.append(nullity3)\n\n    # Test Case 4: Average constraints via Lagrange multipliers\n    C = np.zeros((2, n_dofs))\n    C[0, 0::2] = 1.0  # Constraint on sum of u_x\n    C[1, 1::2] = 1.0  # Constraint on sum of u_y\n\n    augmented_size = n_dofs + 2\n    M = np.zeros((augmented_size, augmented_size))\n    M[:n_dofs, :n_dofs] = K\n    M[:n_dofs, n_dofs:] = C.T\n    M[n_dofs:, :n_dofs] = C\n    \n    nullity4 = count_nullity(M)\n    results.append(nullity4)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}