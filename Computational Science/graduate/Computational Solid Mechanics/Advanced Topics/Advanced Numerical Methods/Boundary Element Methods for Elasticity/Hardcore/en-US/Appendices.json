{
    "hands_on_practices": [
        {
            "introduction": "The Boundary Integral Equation (BIE) forms the theoretical core of the Boundary Element Method (BEM), and its correct formulation at every point on the boundary is paramount. At non-smooth points like corners or edges, a special \"free-term\" arises from the limiting process of the Somigliana identity. This exercise will guide you through deriving this geometric coefficient and the associated numerical strategies at a re-entrant corner, enhancing your understanding of how the BIE adapts to complex geometries. ",
            "id": "3547859",
            "problem": "Consider two-dimensional elastostatic boundary element analysis for a homogeneous, isotropic, linear elastic body occupying a bounded domain $\\Omega \\subset \\mathbb{R}^{2}$ with piecewise smooth boundary $\\Gamma$. Let the material have shear modulus $\\mu$ and Poisson’s ratio $\\nu$ under plane strain or plane stress; assume the required fundamental solution exists. The Boundary Integral Equation (BIE) for displacement, derived from the Somigliana identity, involves the Cauchy Principal Value (CPV) of singular boundary integrals and a geometric free-term coefficient at boundary collocation points.\n\nAt a boundary collocation point $P \\in \\Gamma$ that is a re-entrant corner with internal angle $\\theta$ satisfying $\\theta > \\pi$, the local boundary is formed by two straight segments $\\Gamma_{1}$ and $\\Gamma_{2}$ meeting at $P$ with opening angles $\\alpha_{1}$ and $\\alpha_{2}$, respectively, such that $\\alpha_{1} + \\alpha_{2} = \\theta$. For a nodal collocation Boundary Element Method (BEM) discretization that assigns a single-valued displacement $u_{i}(P)$ to the corner node but represents $u_{i}(P)$ through the neighboring elements’ shape functions as $u_{i}^{(1)}(P)$ from $\\Gamma_{1}$ and $u_{i}^{(2)}(P)$ from $\\Gamma_{2}$, an averaging strategy is required to consistently define $u_{i}(P)$ in the limiting process of the BIE at $P$.\n\nStarting from the classical Somigliana displacement identity, the definition of traction as $t_{i}(Q) = \\sigma_{ij}(Q) n_{j}(Q)$ with the stress-strain relation $\\sigma_{ij} = \\lambda \\delta_{ij} \\varepsilon_{kk} + 2 \\mu \\varepsilon_{ij}$ and $\\varepsilon_{ij} = \\frac{1}{2} \\left( \\frac{\\partial u_{i}}{\\partial x_{j}} + \\frac{\\partial u_{j}}{\\partial x_{i}} \\right)$ in isotropic linear elasticity (where $\\lambda$ is the first Lamé constant), and the existence and properties of the Kelvin fundamental solution and its associated traction kernel, derive the geometric free-term coefficient $c(P)$ appearing in the displacement BIE at a re-entrant corner with angle $\\theta$, and determine an angle-consistent averaging strategy for $u_{i}(P)$ based on the local partition $(\\alpha_{1}, \\alpha_{2})$.\n\nExplicitly compute:\n- The free-term coefficient $c(P)$ as a function of $\\theta$.\n- The averaging weights $w_{1}$ and $w_{2}$ such that $u_{i}(P) = w_{1} \\, u_{i}^{(1)}(P) + w_{2} \\, u_{i}^{(2)}(P)$, consistent with the local angular partition, with $w_{1} + w_{2} = 1$.\n\nAngles must be treated in radians. Express your final result as a single row matrix containing three entries in the order $\\left( c(P), w_{1}, w_{2} \\right)$. Provide exact expressions; do not round. Briefly explain how these quantities affect the local system equations obtained from boundary collocation.\n\nYour final answer must be a calculation in closed form, and it must be expressed as a single row matrix as specified above, with all angles in radians and no units included inside the final answer.",
            "solution": "The problem requires the derivation of the free-term coefficient $c(P)$ and averaging weights $(w_1, w_2)$ for a re-entrant corner in a two-dimensional elastostatic boundary element analysis.\n\nWe begin with the fundamental principles as stipulated. The governing differential equation for elastostatics is Navier's equation. Its integral representation is the Somigliana identity for the displacement $u_i$ at an interior point $p \\in \\Omega$:\n$$u_i(p) = \\int_{\\Gamma} U_{ij}(p,Q) t_j(Q) \\, d\\Gamma(Q) - \\int_{\\Gamma} T_{ij}(p,Q) u_j(Q) \\, d\\Gamma(Q)$$\nHere, $Q \\in \\Gamma$ is a field point on the boundary, $t_j(Q)$ is the traction vector at $Q$, $U_{ij}(p,Q)$ is the Kelvin fundamental solution for displacement (displacement at $Q$ in direction $j$ due to a unit point force at $p$ in direction $i$), and $T_{ij}(p,Q)$ is the associated fundamental solution for traction. The traction $t_j$ is related to the stress tensor $\\sigma_{jk}$ via Cauchy's formula, $t_j = \\sigma_{jk} n_k$, where $n_k$ is the outward unit normal to the boundary $\\Gamma$.\n\nTo obtain the Boundary Integral Equation (BIE), we take the limit as the source point $p$ approaches a point $P$ on the boundary, $p \\to P$. The integral involving the kernel $U_{ij}$ is weakly singular and the limit can be taken inside the integral. The integral involving the kernel $T_{ij}$ is strongly singular, and its limit must be evaluated carefully, leading to a free-term and a Cauchy Principal Value (CPV) integral. The resulting BIE for a collocation point $P \\in \\Gamma$ is:\n$$c_{ij}(P) u_j(P) + \\oint_{\\Gamma} T_{ij}(P,Q) u_j(Q) \\, d\\Gamma(Q) = \\int_{\\Gamma} U_{ij}(P,Q) t_j(Q) \\, d\\Gamma(Q)$$\nwhere $\\oint$ denotes the CPV of the integral.\n\n**Part 1: Derivation of the Free-Term Coefficient $c(P)$**\n\nThe free-term coefficient tensor $c_{ij}(P)$ arises from the jump in the value of the singular integral $\\int_{\\Gamma} T_{ij}(p,Q) u_j(Q) d\\Gamma$ as the point $p$ crosses the boundary. For a constant displacement field $u_j(Q) = \\delta_{jk}$ (a rigid-body translation), the tractions $t_j$ are zero everywhere. The Somigliana identity for an interior point $p \\in \\Omega$ reduces to:\n$$\\delta_{ik} + \\int_{\\Gamma} T_{ij}(p,Q) \\delta_{jk} \\, d\\Gamma(Q) = 0 \\quad \\implies \\quad \\int_{\\Gamma} T_{ik}(p,Q) \\, d\\Gamma(Q) = -\\delta_{ik}$$\nFor a point $p$ outside the domain, the integral is zero. The value of the integral for a boundary point $P$ depends on the local geometry. The free-term coefficient $c_{ij}(P)$ is directly related to this geometry. It can be computed by isolating the singular point $P$ with a small circular arc $\\Gamma_{\\epsilon}$ of radius $\\epsilon$ centered at $P$, lying within the domain $\\Omega$, and taking the limit as $\\epsilon \\to 0$. The angle subtended by this arc is the internal angle $\\theta$ of the corner.\n\nThe coefficient is given by:\n$$c_{ij}(P) = \\lim_{\\epsilon \\to 0} \\int_{\\Gamma_{\\epsilon}} T_{ij}(P,Q) \\, d\\Gamma(Q)$$\nFor 2D isotropic elastostatics, direct evaluation of this integral over an arc of angle $\\theta$ shows that the resulting matrix $c_{ij}(P)$ is generally not a scalar multiple of the identity matrix, i.e., $c_{ij}(P) \\neq c(P) \\delta_{ij}$, as it depends on the orientation of the corner with respect to the coordinate system.\n\nHowever, the problem asks for a single scalar coefficient $c(P)$. This is a common simplification in BEM literature, where the geometrical nature of the free term is emphasized. The scalar coefficient is interpreted as the fraction of the \"solid angle\" that the domain $\\Omega$ occupies at point $P$. In 2D, the full angle is $2\\pi$ radians. For a corner with an internal angle $\\theta$, the fraction of the angle inside the domain is $\\frac{\\theta}{2\\pi}$. This value corresponds to the average of the diagonal terms of the full tensor coefficient, $\\frac{1}{2} \\text{Tr}[c_{ij}(P)]$. It is also the exact free-term coefficient for the potential problem (governed by Laplace's equation). Adopting this standard and physically intuitive simplification, we have:\n$$c(P) = \\frac{\\theta}{2\\pi}$$\nFor a smooth boundary, $\\theta = \\pi$, which correctly gives $c(P) = \\frac{1}{2}$. For the specified re-entrant corner, $\\theta > \\pi$.\n\n**Part 2: Derivation of the Averaging Weights $w_1$ and $w_2$**\n\nThe problem describes a numerical strategy at the corner node $P$ where a single-valued displacement $u_i(P)$ is defined through an averaging of values derived from the adjacent elements on segments $\\Gamma_1$ and $\\Gamma_2$. The averaging rule is given as:\n$$u_i(P) = w_1 u_i^{(1)}(P) + w_2 u_i^{(2)}(P)$$\nwith the constraint $w_1 + w_2 = 1$. The values $u_i^{(1)}(P)$ and $u_i^{(2)}(P)$ are representations of the displacement at $P$ as seen from the elements on $\\Gamma_1$ and $\\Gamma_2$, respectively.\n\nWe are asked to find an \"angle-consistent\" averaging strategy based on a local partition of the total internal angle $\\theta$ into two sub-angles, $\\alpha_1$ and $\\alpha_2$, such that $\\alpha_1 + \\alpha_2 = \\theta$. The phrasing \"opening angles... of two straight segments\" is interpreted to mean that the total corner angle $\\theta$ is partitioned into $\\alpha_1$ and $\\alpha_2$, which are associated with the influence or contribution of each segment/element side.\n\nA logical and consistent interpretation of \"angle-consistent\" averaging is to define the weights to be proportional to the magnitude of the angles in the partition. We set:\n$$w_1 = k \\alpha_1 \\quad \\text{and} \\quad w_2 = k \\alpha_2$$\nwhere $k$ is a constant of proportionality. Using the constraint $w_1 + w_2 = 1$:\n$$k \\alpha_1 + k \\alpha_2 = 1 \\implies k(\\alpha_1 + \\alpha_2) = 1$$\nSince $\\alpha_1 + \\alpha_2 = \\theta$, we have $k\\theta = 1$, which gives $k = \\frac{1}{\\theta}$.\nSubstituting this back, we obtain the expressions for the weights:\n$$w_1 = \\frac{\\alpha_1}{\\theta}$$\n$$w_2 = \\frac{\\alpha_2}{\\theta}$$\nThis choice ensures that the contribution of each \"side\" to the averaged displacement is proportional to its respective angle in the partition of the corner.\n\n**Effect on Local System Equations**\n\nIn the discretized BEM system of equations $[H]\\{u\\} = [G]\\{t\\}$, the free-term coefficient $c(P)$ contributes to the diagonal blocks of the $[H]$ matrix corresponding to the degrees of freedom at node $P$. Its value, reflecting the corner geometry, is crucial for the diagonal dominance and overall stability of the system matrix.\n\nThe averaging weights $(w_1, w_2)$ define a constraint between the nodal displacement degrees of freedom. In a multi-node formulation where distinct displacement values $u_i^{(1)}$ and $u_i^{(2)}$ might exist at the corner, this averaging equation is used to enforce displacement continuity and reduce the number of unknowns, coupling the equations associated with the elements meeting at the corner.\n\nCombining the results, the requested quantities are:\n$c(P) = \\frac{\\theta}{2\\pi}$\n$w_1 = \\frac{\\alpha_1}{\\theta}$\n$w_2 = \\frac{\\alpha_2}{\\theta}$\nThese are presented in a single row matrix as requested.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{\\theta}{2\\pi} & \\frac{\\alpha_1}{\\theta} & \\frac{\\alpha_2}{\\theta}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "A central computational challenge in BEM is the accurate evaluation of boundary integrals whose kernels become singular when the integration point coincides with the collocation point. Standard quadrature rules fail in this limit, requiring specialized techniques. This practice involves implementing and comparing two powerful methods—polar coordinate mapping and the Duffy transformation—to handle these singular integrals, providing direct experience with the numerical engine of a BEM code. ",
            "id": "3547872",
            "problem": "Consider a single flat triangular boundary element in a plane, representing a local panel in a Boundary Element Method (BEM) for linear elastostatics. Let the vertices of the triangle be $\\mathbf{v}_1=(0,0)$, $\\mathbf{v}_2=(1,0.2)$, and $\\mathbf{v}_3=(0.1,0.9)$, and let $\\mathbf{x}_0$ be a point inside the triangle. Define a smooth test function $\\varphi(\\mathbf{x})=1+\\alpha x+\\beta y$ with $\\alpha=0.3$ and $\\beta=0.2$, where $\\mathbf{x}=(x,y)$ is a point on the panel. Two canonical kernel types arise in elastostatic boundary integrals:\n- A weakly singular kernel in two-dimensional elasticity of the form $K_{\\mathrm{w}}(r)=\\log r$, where $r=\\|\\mathbf{x}-\\mathbf{x}_0\\|$.\n- A strongly singular kernel in three-dimensional elasticity appearing in hypersingular formulations, with local behavior $K_{\\mathrm{s}}(r)=1/r^2$.\n\nTo make numerical quadrature scientifically and computationally well-posed, introduce a small regularization parameter $\\varepsilon>0$ and define the regularized kernels\n$$\nK_{\\mathrm{w},\\varepsilon}(r)=\\log\\big(\\sqrt{r^2+\\varepsilon^2}\\big),\\qquad K_{\\mathrm{s},\\varepsilon}(r)=\\frac{1}{r^2+\\varepsilon^2}.\n$$\nFor a given panel and source point $\\mathbf{x}_0$, define the target integral\n$$\nI(K,\\varepsilon)=\\int_{T} \\varphi(\\mathbf{x})\\,K_{\\varepsilon}(\\|\\mathbf{x}-\\mathbf{x}_0\\|)\\,\\mathrm{d}A,\n$$\nwhere $T$ is the triangular panel and $K_{\\varepsilon}$ is either $K_{\\mathrm{w},\\varepsilon}$ or $K_{\\mathrm{s},\\varepsilon}$.\n\nDesign and implement two quadrature mappings specialized for handling the near-singularity at $\\mathbf{x}_0$:\n1. A polar mapping centered at $\\mathbf{x}_0$ on the panel, parameterizing the triangle by polar rays through $\\mathbf{x}_0$. For each angle $\\theta\\in[0,2\\pi)$, define $\\rho_{\\max}(\\theta)$ as the distance from $\\mathbf{x}_0$ along the ray at angle $\\theta$ to the triangle boundary. The mapping $(\\theta,\\rho)\\mapsto \\mathbf{x}(\\theta,\\rho)=\\mathbf{x}_0+\\rho\\,\\mathbf{d}(\\theta)$, where $\\mathbf{d}(\\theta)=(\\cos\\theta,\\sin\\theta)$, induces the area element $\\mathrm{d}A=\\rho\\,\\mathrm{d}\\rho\\,\\mathrm{d}\\theta$. Use tensor-product Gauss–Legendre quadrature in $\\theta\\in[0,2\\pi]$ and in a normalized radial coordinate $t\\in[0,1]$ with $\\rho=t\\,\\rho_{\\max}(\\theta)$, yielding\n$$\nI_{\\mathrm{polar}}(K,\\varepsilon;N_\\theta,N_\\rho)\\approx\\sum_{i=1}^{N_\\theta}\\sum_{j=1}^{N_\\rho} w_{\\theta,i}\\,w_{t,j}\\,\\varphi\\big(\\mathbf{x}_0+t_j\\,\\rho_{\\max}(\\theta_i)\\,\\mathbf{d}(\\theta_i)\\big)\\,K_{\\varepsilon}\\big(t_j\\,\\rho_{\\max}(\\theta_i)\\big)\\,\\big(\\rho_{\\max}(\\theta_i)^2\\,t_j\\big),\n$$\nwhere $w_{\\theta,i}$ and $w_{t,j}$ are the Gauss–Legendre weights mapped from $[-1,1]$ to $[0,2\\pi]$ and $[0,1]$, respectively.\n\n2. A Duffy transformation on a star-subdivision of the triangle into three sub-triangles formed by joining $\\mathbf{x}_0$ to each edge. For each sub-triangle with local affine map $\\mathbf{x}(u,v)=\\mathbf{x}_0+u\\,\\mathbf{a}+v\\,\\mathbf{b}$, $u\\ge 0$, $v\\ge 0$, $u+v\\le 1$, where $\\mathbf{a}$ and $\\mathbf{b}$ are the edge vectors from $\\mathbf{x}_0$ to two consecutive vertices, apply the Duffy map $(\\xi,\\eta)\\mapsto (u,v)$ with $u=\\xi(1-\\eta)$ and $v=\\xi\\eta$, $(\\xi,\\eta)\\in[0,1]^2$. The area element transforms as $\\mathrm{d}A=J_{\\text{sub}}\\,\\xi\\,\\mathrm{d}\\xi\\,\\mathrm{d}\\eta$, where $J_{\\text{sub}}=\\left|\\det\\left[\\mathbf{a}\\ \\mathbf{b}\\right]\\right|$ is the absolute value of the planar Jacobian determinant. The local distance is $r(\\xi,\\eta)=\\|\\mathbf{x}(\\xi,\\eta)-\\mathbf{x}_0\\|=\\xi\\,\\|\\,(1-\\eta)\\mathbf{a}+\\eta\\mathbf{b}\\,\\|$. Using tensor-product Gauss–Legendre quadrature in $(\\xi,\\eta)\\in[0,1]^2$ and summing contributions from the three sub-triangles yields $I_{\\mathrm{Duffy}}(K,\\varepsilon;N_\\xi,N_\\eta)$.\n\nStarting from fundamental principles of boundary integral formulations in linear elastostatics (namely, that boundary integrals involve kernels with weak or strong local singularities and that accurate numerical evaluation requires singularity-aware mappings and Jacobian control), derive the mapping Jacobians and implement both quadrature schemes. For each test case below, compute a high-accuracy reference $I_{\\mathrm{ref}}(K,\\varepsilon)$ using the polar mapping with large quadrature orders, and quantify the absolute errors\n$$\nE_{\\mathrm{polar}}=\\left|I_{\\mathrm{polar}}-I_{\\mathrm{ref}}\\right|,\\qquad E_{\\mathrm{Duffy}}=\\left|I_{\\mathrm{Duffy}}-I_{\\mathrm{ref}}\\right|.\n$$\nReport the efficiency ratio $R=E_{\\mathrm{Duffy}}/E_{\\mathrm{polar}}$ for each test case.\n\nTest suite parameterization:\n- The triangle vertices are fixed as above. The test function parameters are $\\alpha=0.3$, $\\beta=0.2$.\n- Source points $\\mathbf{x}_0$:\n  - Case A: the centroid $\\mathbf{x}_0=(\\mathbf{v}_1+\\mathbf{v}_2+\\mathbf{v}_3)/3$.\n  - Case B: near vertex $\\mathbf{v}_1$, $\\mathbf{x}_0=0.8\\,\\mathbf{v}_1+0.1\\,\\mathbf{v}_2+0.1\\,\\mathbf{v}_3$.\n  - Case C: near edge between $\\mathbf{v}_2$ and $\\mathbf{v}_3$, $\\mathbf{x}_0=0.1\\,\\mathbf{v}_1+0.8\\,\\mathbf{v}_2+0.1\\,\\mathbf{v}_3$.\n- Reference quadrature orders: $N_\\theta^{\\mathrm{ref}}=200$, $N_\\rho^{\\mathrm{ref}}=200$.\n\nTest cases to evaluate, each specified as $(\\text{kernel type}, \\varepsilon, N_\\theta, N_\\rho, N_{\\mathrm{Duffy}}, \\mathbf{x}_0)$:\n1. Weakly singular: $(\\text{weak}, 10^{-6}, 24, 24, 24, \\text{centroid})$.\n2. Weakly singular: $(\\text{weak}, 10^{-8}, 16, 16, 16, \\text{centroid})$.\n3. Weakly singular: $(\\text{weak}, 10^{-6}, 24, 24, 24, \\text{near } \\mathbf{v}_1)$.\n4. Strongly singular: $(\\text{strong}, 10^{-4}, 24, 24, 24, \\text{centroid})$.\n5. Strongly singular: $(\\text{strong}, 10^{-6}, 32, 32, 32, \\text{centroid})$.\n6. Strongly singular: $(\\text{strong}, 10^{-6}, 24, 24, 24, \\text{near edge } \\mathbf{v}_2\\text{-}\\mathbf{v}_3)$.\n\nYour program should produce a single line of output containing the six efficiency ratios $R$ for the above test cases as a comma-separated list enclosed in square brackets (e.g., \"[r1,r2,r3,r4,r5,r6]\"). All numerical values must be computed with the triangle and function settings given here; no physical units are required. Angles must be handled in radians.",
            "solution": "The user has provided a valid problem statement. The problem is scientifically grounded in the field of computational solid mechanics, specifically concerning the numerical evaluation of singular boundary integrals in the Boundary Element Method (BEM) for elastostatics. It is well-posed, with all necessary data, definitions, and constraints provided, allowing for a unique numerical solution. The language is objective and formal. This solution proceeds with the derivation of the quadrature schemes and their implementation.\n\nThe core task is to compute the integral $I(K,\\varepsilon)=\\int_{T} \\varphi(\\mathbf{x})\\,K_{\\varepsilon}(\\|\\mathbf{x}-\\mathbf{x}_0\\|)\\,\\mathrm{d}A$ over a triangular panel $T$ for two types of regularized kernels, $K_{\\mathrm{w},\\varepsilon}$ and $K_{\\mathrm{s},\\varepsilon}$. The point $\\mathbf{x}_0$ is a source point inside the triangle, near which the kernels become singular as $\\varepsilon \\to 0$. We will derive and implement two specialized quadrature techniques: a polar coordinate mapping and a Duffy transformation.\n\nThe vertices of the triangle are $\\mathbf{v}_1=(0,0)$, $\\mathbf{v}_2=(1,0.2)$, and $\\mathbf{v}_3=(0.1,0.9)$. The test function is $\\varphi(\\mathbf{x})=1+0.3x+0.2y$. The regularized kernels are $K_{\\mathrm{w},\\varepsilon}(r)=\\log\\big(\\sqrt{r^2+\\varepsilon^2}\\big)$ and $K_{\\mathrm{s},\\varepsilon}(r)=1/(r^2+\\varepsilon^2)$.\n\n### 1. Polar Coordinate Mapping\n\nThis method re-parameterizes the domain of integration using polar coordinates $(\\rho, \\theta)$ centered at the source point $\\mathbf{x}_0$. A point $\\mathbf{x}$ in the triangle is given by $\\mathbf{x}(\\rho, \\theta) = \\mathbf{x}_0 + \\rho\\mathbf{d}(\\theta)$, where $\\mathbf{d}(\\theta) = (\\cos\\theta, \\sin\\theta)$ is the direction vector. The distance from the source point is $r = \\|\\mathbf{x} - \\mathbf{x}_0\\| = \\rho$.\n\nThe Jacobian of this transformation from Cartesian $(x,y)$ to polar $(\\rho,\\theta)$ coordinates gives the differential area element $\\mathrm{d}A = \\rho\\,\\mathrm{d}\\rho\\,\\mathrm{d}\\theta$. The integral becomes:\n$$\nI = \\int_{0}^{2\\pi} \\int_{0}^{\\rho_{\\max}(\\theta)} \\varphi\\big(\\mathbf{x}_0 + \\rho\\mathbf{d}(\\theta)\\big) K_{\\varepsilon}(\\rho) \\rho\\,\\mathrm{d}\\rho\\,\\mathrm{d}\\theta\n$$\nHere, $\\rho_{\\max}(\\theta)$ is the distance from $\\mathbf{x}_0$ to the boundary of the triangle $T$ in the direction $\\mathbf{d}(\\theta)$.\n\nTo create a fixed integration domain, we introduce a normalized radial coordinate $t \\in [0,1]$ such that $\\rho = t\\rho_{\\max}(\\theta)$. The differential is then $\\mathrm{d}\\rho = \\rho_{\\max}(\\theta)\\,\\mathrm{d}t$. Substituting this into the integral expression, the term $\\rho\\,\\mathrm{d}\\rho$ transforms as:\n$$\n\\rho\\,\\mathrm{d}\\rho = \\big(t\\rho_{\\max}(\\theta)\\big) \\big(\\rho_{\\max}(\\theta)\\,\\mathrm{d}t\\big) = t\\rho_{\\max}(\\theta)^2\\,\\mathrm{d}t\n$$\nThe integral over the rectangular domain $[0, 2\\pi] \\times [0, 1]$ in $(\\theta, t)$ coordinates is:\n$$\nI = \\int_{0}^{2\\pi} \\int_{0}^{1} \\varphi\\big(\\mathbf{x}_0 + t\\rho_{\\max}(\\theta)\\mathbf{d}(\\theta)\\big) K_{\\varepsilon}\\big(t\\rho_{\\max}(\\theta)\\big) \\left(t\\rho_{\\max}(\\theta)^2\\right)\\,\\mathrm{d}t\\,\\mathrm{d}\\theta\n$$\n Applying a tensor-product Gauss-Legendre quadrature with $N_\\theta$ points for $\\theta$ and $N_\\rho$ points for $t$ (which corresponds to $\\rho$ in the problem description), we obtain the numerical approximation:\n$$\nI_{\\mathrm{polar}} \\approx \\sum_{i=1}^{N_\\theta}\\sum_{j=1}^{N_\\rho} w_{\\theta,i}\\,w_{t,j}\\,\\left[ \\varphi\\big(\\mathbf{x}(\\theta_i, t_j)\\big) K_{\\varepsilon}\\big(r(\\theta_i, t_j)\\big) t_j\\,\\rho_{\\max}(\\theta_i)^2 \\right]\n$$\nwhere $\\mathbf{x}(\\theta_i, t_j) = \\mathbf{x}_0+t_j\\,\\rho_{\\max}(\\theta_i)\\,\\mathbf{d}(\\theta_i)$, $r(\\theta_i, t_j) = t_j\\,\\rho_{\\max}(\\theta_i)$, and $(t_j, w_{t,j})$ and $(\\theta_i, w_{\\theta,i})$ are the Gauss-Legendre quadrature points and weights mapped to the intervals $[0,1]$ and $[0,2\\pi]$, respectively. This confirms the formula provided in the problem statement.\n\n### 2. Duffy Transformation\n\nThis method first decomposes the original triangle $T$ into three sub-triangles ($T_1, T_2, T_3$) by connecting the source point $\\mathbf{x}_0$ to each of the vertices $\\mathbf{v}_1, \\mathbf{v}_2, \\mathbf{v}_3$. The total integral is the sum of the integrals over these sub-triangles: $I = \\sum_{k=1}^3 \\int_{T_k} \\varphi(\\mathbf{x}) K_\\varepsilon(\\dots) \\mathrm{d}A$.\n\nConsider a single sub-triangle with vertices $\\mathbf{x}_0, \\mathbf{v}_a, \\mathbf{v}_b$. We introduce a standard affine map from a reference triangle in the $(u,v)$ plane (where $u \\ge 0, v \\ge 0, u+v \\le 1$) to the sub-triangle:\n$$\n\\mathbf{x}(u,v) = \\mathbf{x}_0 + u(\\mathbf{v}_a - \\mathbf{x}_0) + v(\\mathbf{v}_b - \\mathbf{x}_0) = \\mathbf{x}_0 + u\\mathbf{a} + v\\mathbf{b}\n$$\nThe area element transforms as $\\mathrm{d}A = J_{\\text{sub}}\\,\\mathrm{d}u\\,\\mathrm{d}v$, where $J_{\\text{sub}} = |\\det[\\mathbf{a} \\ \\mathbf{b}]|$ is the Jacobian determinant of the affine map.\n\nNext, the Duffy transformation maps the unit square in the $(\\xi, \\eta)$ plane, $(\\xi,\\eta) \\in [0,1]^2$, to the reference triangle in the $(u,v)$ plane:\n$$\nu = \\xi(1-\\eta), \\quad v = \\xi\\eta\n$$\nThe Jacobian of this map is:\n$$\nJ_{\\text{Duffy}} = \\left|\\det\\left(\\frac{\\partial(u,v)}{\\partial(\\xi,\\eta)}\\right)\\right| = \\left|\\det\\begin{pmatrix} 1-\\eta & -\\xi \\\\ \\eta & \\xi \\end{pmatrix}\\right| = |\\xi(1-\\eta) - (-\\xi\\eta)| = |\\xi| = \\xi \\quad (\\text{since } \\xi \\in [0,1])\n$$\nThe area element $\\mathrm{d}u\\,\\mathrm{d}v$ is replaced by $\\xi\\,\\mathrm{d}\\xi\\,\\mathrm{d}\\eta$. The complete transformation of the area element is thus $\\mathrm{d}A = J_{\\text{sub}}\\,\\xi\\,\\mathrm{d}\\xi\\,\\mathrm{d}\\eta$.\n\nThe distance from the source point is $r = \\|\\mathbf{x} - \\mathbf{x}_0\\| = \\|u\\mathbf{a} + v\\mathbf{b}\\| = \\|\\xi(1-\\eta)\\mathbf{a} + \\xi\\eta\\mathbf{b}\\| = \\xi\\|(1-\\eta)\\mathbf{a} + \\eta\\mathbf{b}\\|$. The integral over one sub-triangle becomes:\n$$\nI_{\\text{sub}} = \\int_{0}^{1}\\int_{0}^{1} \\varphi\\big(\\mathbf{x}(\\xi,\\eta)\\big) K_{\\varepsilon}\\big(r(\\xi,\\eta)\\big) J_{\\text{sub}}\\,\\xi\\,\\mathrm{d}\\xi\\,\\mathrm{d}\\eta\n$$\nThe total integral $I_{\\mathrm{Duffy}}$ is the sum of three such integrals, one for each sub-triangle. The crucial feature of this transformation is the factor of $\\xi$ in the area element, which effectively cancels the weakest part of the singularity. For a weakly singular kernel like $K_w(r) = \\log r \\sim \\log \\xi$, the integrand contains the term $\\xi \\log \\xi$, which is finite and non-singular at $\\xi=0$. For the strongly singular regularized kernel $K_s(r) = 1/(r^2+\\varepsilon^2) \\sim 1/(\\xi^2)$, the integrand term $\\xi/(\\xi^2(\\dots)+\\varepsilon^2)$ is also non-singular for $\\varepsilon > 0$. This demonstrates that the Duffy transformation regularizes the integrand, making it suitable for standard Gauss-Legendre quadrature.\n\n### 3. Implementation and Comparison\n\nThe provided Python code implements both the polar and Duffy quadrature schemes based on the derivations above. For each test case, a high-accuracy reference value $I_{\\mathrm{ref}}$ is calculated using the polar method with a large number of quadrature points ($N_\\theta^{\\mathrm{ref}}=200, N_\\rho^{\\mathrm{ref}}=200$). The absolute errors of the polar method ($E_{\\mathrm{polar}} = |I_{\\mathrm{polar}} - I_{\\mathrm{ref}}|$) and the Duffy method ($E_{\\mathrm{Duffy}} = |I_{\\mathrm{Duffy}} - I_{\\mathrm{ref}}|$) are computed using the specified lower-order quadrature rules. The final reported value is the efficiency ratio $R = E_{\\mathrm{Duffy}} / E_{\\mathrm{polar}}$, which compares the accuracy of the two methods for a given number of quadrature points. A ratio $R<1$ signifies that the Duffy method is more accurate.",
            "answer": "```python\nimport numpy as np\nfrom numpy.polynomial.legendre import leggauss\n\ndef solve():\n    \"\"\"\n    Solves the BEM quadrature problem by implementing and comparing polar and Duffy integration methods.\n    \"\"\"\n    # Global constants from the problem\n    V1 = np.array([0.0, 0.0])\n    V2 = np.array([1.0, 0.2])\n    V3 = np.array([0.1, 0.9])\n    VERTICES = (V1, V2, V3)\n    ALPHA = 0.3\n    BETA = 0.2\n\n    # Test function\n    def phi(x):\n        return 1.0 + ALPHA * x[0] + BETA * x[1]\n\n    # Regularized kernels\n    def k_weak(r, epsilon):\n        # The argument to log must be > 0. sqrt(r^2+eps^2) is always >0 for eps>0.\n        return 0.5 * np.log(r**2 + epsilon**2)\n\n    def k_strong(r, epsilon):\n        return 1.0 / (r**2 + epsilon**2)\n\n    # Helper function for Gauss-Legendre quadrature on arbitrary interval [a, b]\n    def mapped_leggauss(N, a, b):\n        points, weights = leggauss(N)\n        mapped_points = (b - a) / 2.0 * points + (a + b) / 2.0\n        mapped_weights = (b - a) / 2.0 * weights\n        return mapped_points, mapped_weights\n    \n    # Memoization for get_rho_max to speed up repeated calls with same theta\n    rho_max_cache = {}\n    def get_rho_max(theta, x0_tuple):\n        x0 = np.array(x0_tuple)\n        cache_key = (theta, x0_tuple)\n        if cache_key in rho_max_cache:\n            return rho_max_cache[cache_key]\n\n        d = np.array([np.cos(theta), np.sin(theta)])\n        distances = []\n        \n        edges = [(V1, V2), (V2, V3), (V3, V1)]\n        for p1, p2 in edges:\n            v = p2 - p1\n            mat_det = -d[0] * v[1] + d[1] * v[0]\n            \n            if np.abs(mat_det) < 1e-15:\n                continue\n\n            rhs = p1 - x0\n            t = (rhs[0] * (-v[1]) - rhs[1] * (-v[0])) / mat_det\n            s = (d[0] * rhs[1] - d[1] * rhs[0]) / mat_det\n            \n            if t > 1e-12 and -1e-12 <= s <= 1 + 1e-12:\n                distances.append(t)\n        \n        if not distances:\n            raise ValueError(f\"No intersection found for theta={theta}, x0={x0}\")\n        \n        result = min(distances)\n        rho_max_cache[cache_key] = result\n        return result\n\n    def integrate_polar(kernel_func, epsilon, N_theta, N_rho, x0):\n        theta_pts, theta_w = mapped_leggauss(N_theta, 0, 2 * np.pi)\n        t_pts, t_w = mapped_leggauss(N_rho, 0, 1)\n        \n        integral = 0.0\n        x0_tuple = tuple(x0) # Use tuple for cache key\n        \n        for i, th in enumerate(theta_pts):\n            rho_max_i = get_rho_max(th, x0_tuple)\n            d_i = np.array([np.cos(th), np.sin(th)])\n            \n            for j, t in enumerate(t_pts):\n                rho = t * rho_max_i\n                x = x0 + rho * d_i\n                integrand = phi(x) * kernel_func(rho, epsilon) * (rho_max_i**2 * t)\n                integral += theta_w[i] * t_w[j] * integrand\n                \n        return integral\n\n    def integrate_duffy_sub(kernel_func, epsilon, N, x0, v_a, v_b):\n        a = v_a - x0\n        b = v_b - x0\n        \n        J_sub = np.abs(a[0] * b[1] - a[1] * b[0])\n        \n        xi_pts, xi_w = mapped_leggauss(N, 0, 1)\n        eta_pts, eta_w = mapped_leggauss(N, 0, 1)\n        \n        integral = 0.0\n        \n        for i, xi in enumerate(xi_pts):\n            for j, eta in enumerate(eta_pts):\n                pos_rel = xi * ((1 - eta) * a + eta * b)\n                x = x0 + pos_rel\n                r = np.linalg.norm(pos_rel)\n                integrand = phi(x) * kernel_func(r, epsilon) * J_sub * xi\n                integral += xi_w[i] * eta_w[j] * integrand\n        \n        return integral\n\n    def integrate_duffy(kernel_func, epsilon, N, x0):\n        total_integral = 0.0\n        v1, v2, v3 = VERTICES\n        total_integral += integrate_duffy_sub(kernel_func, epsilon, N, x0, v1, v2)\n        total_integral += integrate_duffy_sub(kernel_func, epsilon, N, x0, v2, v3)\n        total_integral += integrate_duffy_sub(kernel_func, epsilon, N, x0, v3, v1)\n        return total_integral\n\n    test_cases_params = [\n        ('weak', 1e-6, 24, 24, 24, 'centroid'),\n        ('weak', 1e-8, 16, 16, 16, 'centroid'),\n        ('weak', 1e-6, 24, 24, 24, 'near_v1'),\n        ('strong', 1e-4, 24, 24, 24, 'centroid'),\n        ('strong', 1e-6, 32, 32, 32, 'centroid'),\n        ('strong', 1e-6, 24, 24, 24, 'near_edge_v2_v3'),\n    ]\n\n    x0_centroid = (V1 + V2 + V3) / 3.0\n    x0_near_v1 = 0.8 * V1 + 0.1 * V2 + 0.1 * V3\n    x0_near_edge = 0.1 * V1 + 0.8 * V2 + 0.1 * V3\n\n    source_points_map = {\n        'centroid': x0_centroid,\n        'near_v1': x0_near_v1,\n        'near_edge_v2_v3': x0_near_edge\n    }\n    \n    kernel_map = {'weak': k_weak, 'strong': k_strong}\n    N_theta_ref, N_rho_ref = 200, 200\n    \n    results = []\n\n    for params in test_cases_params:\n        k_type, epsilon, N_theta, N_rho, N_duffy, x0_key = params\n        \n        kernel = kernel_map[k_type]\n        x0 = source_points_map[x0_key]\n        \n        rho_max_cache.clear() # Clear cache for each new configuration\n        I_ref = integrate_polar(kernel, epsilon, N_theta_ref, N_rho_ref, x0)\n        \n        rho_max_cache.clear()\n        I_polar = integrate_polar(kernel, epsilon, N_theta, N_rho, x0)\n        I_duffy = integrate_duffy(kernel, epsilon, N_duffy, x0)\n        \n        E_polar = np.abs(I_polar - I_ref)\n        E_duffy = np.abs(I_duffy - I_ref)\n        \n        if E_polar < 1e-16:\n            ratio = 1.0 if E_duffy < 1e-16 else np.inf\n        else:\n            ratio = E_duffy / E_polar\n            \n        results.append(ratio)\n        \n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While singular integrals are a known challenge, nearly singular integrals pose a more subtle but equally critical problem for the accuracy and robustness of BEM. These arise when the evaluation point is very close to, but not on, an integration element, a common scenario in problems involving thin structures or contact. In this hands-on exercise, you will develop an adaptive quadrature scheme that refines the integration mesh based on proximity, ensuring accurate results even in these challenging geometric configurations. ",
            "id": "3547819",
            "problem": "Consider two straight, parallel boundary segments representing the walls of a thin gap in isotropic, homogeneous, two-dimensional linear elasticity under plane strain. Let the upper wall be the segment from $(0, g/2)$ to $(L, g/2)$ and the lower wall be the segment from $(0, -g/2)$ to $(L, -g/2)$. Let a target point $\\mathbf{x} = (x_0, y_0)$ lie inside the gap. The gap thickness $g$ is small, so that the distance from $\\mathbf{x}$ to the walls is much smaller than the typical panel size $h$ used to discretize each wall, i.e., $\\text{dist}(\\mathbf{x}, \\Gamma) \\ll h$.\n\nYou will approximate the displacement field induced at $\\mathbf{x}$ by a single-layer potential with a prescribed constant density on both walls. The single-layer potential for displacement in isotropic, homogeneous, two-dimensional linear elasticity (plane strain) is given by\n$$\nu_i(\\mathbf{x}) = \\int_{\\Gamma} U_{ij}(\\mathbf{x}, \\mathbf{y}) \\, t_j(\\mathbf{y}) \\, \\mathrm{d}\\Gamma(\\mathbf{y}),\n$$\nwhere $U_{ij}(\\mathbf{x}, \\mathbf{y})$ is the Kelvin fundamental solution for displacement in plane strain,\n$$\nU_{ij}(\\mathbf{x}, \\mathbf{y}) = \\frac{1}{8 \\pi \\mu(1-\\nu)} \\left( - \\kappa \\, \\delta_{ij} \\, \\ln r + \\frac{r_i r_j}{r^2} \\right),\n$$\n$r_i = x_i - y_i$, $r = \\|\\mathbf{x} - \\mathbf{y}\\|$, $\\delta_{ij}$ is the Kronecker delta, $\\mu$ is the shear modulus, and $\\kappa = 3 - 4 \\nu$ with $\\nu$ the Poisson ratio. Assume the traction density is constant and equal to $t_j(\\mathbf{y}) = (1, 0)$ for both walls. The material parameters are $\\mu = 1$ and $\\nu = 0.25$.\n\nThe integral is nearly singular when $\\mathbf{x}$ lies close to a wall panel but is not coincident with it. You must design and implement a distance-aware quadrature that resolves these nearly singular integrals. The quadrature must:\n\n- Partition each wall into $N$ equal panels of length $h = L/N$.\n- For a given target point $\\mathbf{x}$ and a panel with endpoints $\\mathbf{a}$ and $\\mathbf{b}$, compute the minimum distance $\\rho$ from $\\mathbf{x}$ to the segment $\\overline{\\mathbf{ab}}$.\n- If $\\rho/h$ is below a refinement threshold, subdivide the panel into $n_{\\text{ref}}$ uniform subpanels so that the subpanel length is $\\mathcal{O}(\\rho)$, and increase the Gauss–Legendre quadrature order $q$ based on the ratio $h/\\rho$ (ensuring $q$ remains within reasonable bounds). Otherwise use a base quadrature order without subdivision.\n- Evaluate the integral panel-wise using Gauss–Legendre quadrature, summing contributions from all panels of both walls.\n\nStarting from the Somigliana identity and the Kelvin fundamental solution, justify the quadrature design by explicitly relating the near-singular behavior of $U_{ij}(\\mathbf{x}, \\mathbf{y})$ to the need for distance-aware subdivision and order selection. The derivation must begin from the governing equations of linear elasticity and the properties of the Kelvin solution, and must produce a clear algorithmic strategy for selecting $n_{\\text{ref}}$ and $q$ as functions of $\\rho/h$.\n\nCompute the $x$-component of displacement, $u_x(\\mathbf{x})$, for the following test suite. All lengths are in nondimensional units where $\\mu = 1$ and $L$ is a unit length. Report results in nondimensional displacement units:\n\n1. Case A (thin gap, center): $L = 1.0$, $g = 10^{-3}$, $N = 8$, $\\mathbf{x} = (0.5, 0.0)$.\n2. Case B (ultra-thin gap, center): $L = 1.0$, $g = 10^{-6}$, $N = 8$, $\\mathbf{x} = (0.5, 0.0)$.\n3. Case C (thin gap, off-center in $x$): $L = 1.0$, $g = 10^{-2}$, $N = 8$, $\\mathbf{x} = (0.75, 0.0)$.\n4. Case D (moderate gap, center): $L = 1.0$, $g = 0.2$, $N = 8$, $\\mathbf{x} = (0.25, 0.0)$.\n5. Case E (thin gap, near left edge): $L = 1.0$, $g = 10^{-3}$, $N = 8$, $\\mathbf{x} = (10^{-6}, 0.0)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[$r_1$,$r_2$,$r_3$,$r_4$,$r_5$]\"), where $r_k$ is the computed $u_x(\\mathbf{x})$ for test case $k$. All numerical results must be in nondimensional units as specified above and must be decimal floats.",
            "solution": "The user-provided problem is valid as it is scientifically grounded in the principles of linear elasticity, well-posed with a complete and consistent setup, and expressed in objective, formal language. We proceed with a full solution.\n\n### Introduction and Theoretical Justification\n\nThe problem requires the computation of the displacement field at a target point $\\mathbf{x}$ due to a specified traction density $\\mathbf{t}(\\mathbf{y})$ on two parallel boundary segments $\\Gamma$. This is achieved by evaluating a single-layer boundary integral, a fundamental construct in the Boundary Element Method (BEM). The core of the problem lies in the accurate numerical evaluation of this integral when the target point $\\mathbf{x}$ is very close to the integration boundary $\\Gamma$, a situation known as near-singular integration.\n\nThe governing equations for a linear elastic, isotropic, and homogeneous body in static equilibrium are the Navier-Cauchy equations:\n$$\n\\mu u_{i,jj}(\\mathbf{x}) + (\\lambda+\\mu) u_{j,ji}(\\mathbf{x}) + b_i(\\mathbf{x}) = 0\n$$\nwhere $u_i$ is the displacement vector, $b_i$ is the body force per unit volume, and $\\lambda$ and $\\mu$ are Lamé's first and second parameters. The parameter $\\mu$ is the shear modulus.\n\nThe Boundary Element Method is built upon a boundary integral equation derived from Betti's reciprocal theorem and a fundamental solution of the governing equations. The fundamental solution, or Kelvin solution $U_{ij}(\\mathbf{x}, \\mathbf{y})$, represents the displacement at point $\\mathbf{x}$ in an infinite elastic medium due to a concentrated unit point force applied at point $\\mathbf{y}$ in the $j$-direction. It satisfies the governing equation with a singular body force term:\n$$\n\\mu U_{ik,ll}(\\mathbf{x}, \\mathbf{y}) + (\\lambda+\\mu) U_{lk,li}(\\mathbf{x}, \\mathbf{y}) + \\delta_{ij}\\delta(\\mathbf{x}-\\mathbf{y}) = 0\n$$\nwhere $\\delta_{ij}$ is the Kronecker delta and $\\delta(\\mathbf{x}-\\mathbf{y})$ is the Dirac delta function. For two-dimensional plane strain, the Kelvin solution is given by:\n$$\nU_{ij}(\\mathbf{x}, \\mathbf{y}) = \\frac{1}{8 \\pi \\mu(1-\\nu)} \\left( - \\kappa \\, \\delta_{ij} \\, \\ln r + \\frac{r_i r_j}{r^2} \\right)\n$$\nwhere $\\mathbf{r} = \\mathbf{x} - \\mathbf{y}$, $r = \\|\\mathbf{r}\\|$, $r_i = x_i - y_i$, and $\\kappa = 3 - 4\\nu$ with $\\nu$ being Poisson's ratio.\n\nThe displacement field generated by a distribution of forces (a traction density) $\\mathbf{t}(\\mathbf{y})$ on a surface $\\Gamma$ embedded in an infinite medium is given by the single-layer potential:\n$$\nu_i(\\mathbf{x}) = \\int_{\\Gamma} U_{ij}(\\mathbf{x}, \\mathbf{y}) \\, t_j(\\mathbf{y}) \\, \\mathrm{d}\\Gamma(\\mathbf{y})\n$$\nThis is the integral we must evaluate. The kernel $U_{ij}$ contains a logarithmic term, $\\ln r$, which is singular as $r \\to 0$. When $\\mathbf{x}$ is close to, but not on, the boundary $\\Gamma$, the distance $r = \\|\\mathbf{x} - \\mathbf{y}\\|$ becomes very small for points $\\mathbf{y}$ on the boundary panel near $\\mathbf{x}$. This does not create a singularity in the integral itself, but it causes the integrand to vary extremely rapidly, forming a sharp peak. Standard numerical quadrature methods, such as Gauss-Legendre quadrature, are designed for smooth, well-behaved functions and will fail to accurately capture this peak, leading to significant errors.\n\nLet us analyze the source of this error. A standard $q$-point Gaussian quadrature's error over an interval of length $h$ is proportional to $E \\propto h^{2q+1} f^{(2q)}(\\eta)$, where $f^{(2q)}$ is the $(2q)$-th derivative of the integrand $f$ at some point $\\eta$ in the interval.\nConsider a panel of length $h$ and a target point $\\mathbf{x}$ whose minimum distance to the line containing the panel is $\\rho \\ll h$. Let the panel be parameterized by a local coordinate $s$, with $s=0$ at the point of closest approach. The distance $r$ is given by $r(s) = \\sqrt{\\rho^2 + s^2}$. The problematic part of our integrand behaves like $f(s) \\sim \\ln r(s) = \\frac{1}{2}\\ln(\\rho^2 + s^2)$. The derivatives of this function with respect to $s$ scale with inverse powers of $\\rho$. For example, the second derivative is $f''(s) = (\\rho^2-s^2)/(\\rho^2+s^2)^2$, which at $s=0$ is $1/\\rho^2$. In general, the $k$-th derivative scales as $f^{(k)}(s) \\sim \\mathcal{O}(\\rho^{-k})$.\nConsequently, the quadrature error scales as $E \\propto h^{2q+1} \\rho^{-2q} = (h/ \\rho)^{2q} h$. When $\\rho \\ll h$, the term $(h/\\rho)^{2q}$ becomes enormous, and the numerical integration is inaccurate.\n\nTo remedy this, we must use a distance-aware adaptive quadrature scheme. The goal is to make the integration domain small enough relative to the distance $\\rho$ that the integrand becomes smooth over that domain. This can be achieved by subdividing the panel. If we divide the panel of length $h$ into $n_{\\text{ref}}$ subpanels, each of length $h_s = h/n_{\\text{ref}}$, the error contribution from one subpanel is $E_s \\propto h_s^{2q+1} \\rho^{-2q}$. If we choose the number of subdivisions such that the subpanel length is on the order of the distance, i.e., $h_s \\approx \\rho$, then the error becomes $E_s \\propto \\rho^{2q+1} \\rho^{-2q} = \\rho$. The total error across the original panel is the sum of errors from the $n_{\\text{ref}}$ subpanels: $E_{\\text{total}} \\approx n_{\\text{ref}} \\times E_s = (h/h_s) \\times E_s \\approx (h/\\rho) \\times \\rho = h$. The error is now controlled by the panel size $h$ and is independent of the small distance $\\rho$. This restores the convergence properties of the numerical method.\n\nThis analysis provides a direct justification for the following algorithmic strategy:\n1. For each panel, compute the minimum distance $\\rho = \\text{dist}(\\mathbf{x}, \\text{panel})$.\n2. Define a refinement threshold, e.g., $\\rho/h < 2$.\n3. If a panel is \"near\" (i.e., the condition is met), subdivide it into $n_{\\text{ref}}$ subpanels. A robust choice for the number of subdivisions is $n_{\\text{ref}} = \\lceil h/\\rho \\rceil$. This ensures that the subpanel length $h/n_{\\text{ref}}$ is always less than or equal to $\\rho$.\n4. Evaluate the integral over each subpanel (or the original panel, if \"far\") using a fixed-order Gauss-Legendre quadrature.\n\nWe implement this strategy to solve the given problem.\n\n### Numerical Implementation\n\nWe are given $\\mu=1$ and $\\nu=0.25$, which yields $\\kappa = 3 - 4(0.25) = 2$. The constant traction density is $\\mathbf{t}(\\mathbf{y}) = (1, 0)$. The displacement components to be integrated are derived from the single-layer potential formula with $t_j = \\delta_{j1}$:\n$$\nu_i(\\mathbf{x}) = \\int_{\\Gamma} U_{i1}(\\mathbf{x}, \\mathbf{y}) \\, \\mathrm{d}\\Gamma(\\mathbf{y})\n$$\nWe need to compute the $x$-component, $u_x = u_1$. The required integrand is:\n$$\nU_{11}(\\mathbf{x}, \\mathbf{y}) = \\frac{1}{8 \\pi \\mu(1-\\nu)} \\left( - \\kappa \\, \\ln r + \\frac{r_1^2}{r^2} \\right)\n$$\nThe calculation proceeds by discretizing the upper and lower walls into $N$ panels each. For each panel, its distance $\\rho$ to the target point $\\mathbf{x}$ is calculated. If the panel is deemed \"near\", it is subdivided as described above. The integral over each panel (or subpanel) is computed using Gauss-Legendre quadrature, and the contributions from all panels on both walls are summed to obtain the final displacement at $\\mathbf{x}$.",
            "answer": "```python\nimport numpy as np\nfrom math import ceil\n\ndef solve():\n    \"\"\"\n    Solves the 2D elasticity problem using a nearly-singular\n    boundary element integration scheme.\n    \"\"\"\n\n    # --- Problem Constants and Quadrature Settings ---\n    MU = 1.0\n    NU = 0.25\n    KAPPA = 3.0 - 4.0 * NU\n    C_KELVIN = 1.0 / (8.0 * np.pi * MU * (1.0 - NU))\n    TRACTION = np.array([1.0, 0.0])\n\n    BASE_QUAD_ORDER = 16\n    REFINEMENT_THRESHOLD = 2.0\n    MAX_SUBDIVISIONS = 2000 # Safety cap\n\n    # Pre-compute Gauss-Legendre points and weights for the interval [-1, 1]\n    gauss_points, gauss_weights = np.polynomial.legendre.leggauss(BASE_QUAD_ORDER)\n\n    def get_min_dist_to_segment(p, a, b):\n        \"\"\"\n        Calculates the minimum distance from a point p to a line segment [a, b].\n        All inputs are numpy arrays representing coordinates.\n        \"\"\"\n        v = b - a\n        w = p - a\n        l2 = np.dot(v, v)\n        if l2 == 0.0: # a and b are the same point\n            return np.linalg.norm(w)\n        \n        # Project w onto v. t is the projection parameter.\n        t = np.dot(w, v) / l2\n        \n        # If projection falls outside the segment, clamp it to the nearest endpoint.\n        t = max(0.0, min(1.0, t))\n        \n        projection = a + t * v\n        return np.linalg.norm(p - projection)\n\n    def integrate_segment(x_target, p_start, p_end):\n        \"\"\"\n        Integrates the single-layer kernel over a single line segment [p_start, p_end]\n        using Gauss-Legendre quadrature. Returns the displacement vector contribution.\n        \"\"\"\n        segment_vec = p_end - p_start\n        segment_len = np.linalg.norm(segment_vec)\n        \n        # Jacobian of the transformation from reference element [-1, 1] to the segment\n        jacobian = segment_len / 2.0\n        \n        # Map Gauss points from [-1, 1] to physical points on the segment\n        # y_points is a (BASE_QUAD_ORDER x 2) array of coordinates\n        y_points = p_start + 0.5 * (1.0 + gauss_points[:, np.newaxis]) * segment_vec\n        \n        # Calculate r vector and its magnitude for all quadrature points\n        r_vec = x_target - y_points\n        r_sq = np.sum(r_vec * r_vec, axis=1)\n        r = np.sqrt(r_sq)\n        \n        # Calculate the integrand vector components (U_i1)\n        # We need the first column of the Kelvin tensor U_ij, since t = (1, 0)\n        rx = r_vec[:, 0]\n        ry = r_vec[:, 1]\n        \n        # Integrand for u_x (displacement in x-direction)\n        integrand_x = C_KELVIN * (-KAPPA * np.log(r) + (rx * rx) / r_sq)\n        \n        # The problem only asks for u_x, but we compute u_y for completeness\n        # Integrand for u_y (displacement in y-direction)\n        # integrand_y = C_KELVIN * ((rx * ry) / r_sq)\n        \n        # Perform quadrature sum\n        u_x = np.sum(integrand_x * gauss_weights) * jacobian\n        # u_y = np.sum(integrand_y * gauss_weights) * jacobian\n        \n        return u_x # Return only the x-component\n\n    # --- Test Cases ---\n    test_cases = [\n        # Case A: L, g, N, x_target\n        (1.0, 1e-3, 8, np.array([0.5, 0.0])),\n        # Case B\n        (1.0, 1e-6, 8, np.array([0.5, 0.0])),\n        # Case C\n        (1.0, 1e-2, 8, np.array([0.75, 0.0])),\n        # Case D\n        (1.0, 0.2, 8, np.array([0.25, 0.0])),\n        # Case E\n        (1.0, 1e-3, 8, np.array([1e-6, 0.0])),\n    ]\n\n    results = []\n\n    for L, g, N, x_target in test_cases:\n        h = L / N\n        walls_y = [g / 2.0, -g / 2.0]\n        total_disp_x = 0.0\n\n        for y_wall in walls_y:\n            for i in range(N):\n                p_start = np.array([i * h, y_wall])\n                p_end = np.array([(i + 1) * h, y_wall])\n\n                rho = get_min_dist_to_segment(x_target, p_start, p_end)\n                \n                # Use adaptive subdivision for \"near\" panels\n                if rho > 1e-12 and rho / h < REFINEMENT_THRESHOLD:\n                    n_ref = min(MAX_SUBDIVISIONS, ceil(h / rho))\n                    sub_h = h / n_ref\n                    for j in range(n_ref):\n                        sub_p_start = np.array([(i * h) + j * sub_h, y_wall])\n                        sub_p_end = np.array([(i * h) + (j + 1) * sub_h, y_wall])\n                        total_disp_x += integrate_segment(x_target, sub_p_start, sub_p_end)\n                else: # Use standard quadrature for \"far\" panels or if rho is zero\n                    total_disp_x += integrate_segment(x_target, p_start, p_end)\n        \n        results.append(total_disp_x)\n\n    # Format the final output string exactly as required\n    print(f\"[{','.join(f'{r:.12f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}