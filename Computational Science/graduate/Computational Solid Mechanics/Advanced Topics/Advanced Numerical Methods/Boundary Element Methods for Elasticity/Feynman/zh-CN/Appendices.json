{
    "hands_on_practices": [
        {
            "introduction": "在构建复杂的数值模型之前，掌握内部应力、边界面力和边界功之间的基本关系至关重要。本练习旨在实践应用柯西公式 (Cauchy's formula)，并计算在给定边界位移下由边界面力所做的功，这些都是构成边界元法能量理论基础的核心要素。通过这个具体的计算，您可以加深对弹性力学基本原理在BEM理论推导中如何应用的理解。",
            "id": "3547823",
            "problem": "考虑一个三维弹性体，其占据了以原点为中心、半径为 $a$ 的实心球体，其光滑边界为 $\\Gamma = \\{ \\mathbf{x} \\in \\mathbb{R}^{3} : |\\mathbf{x}| = a \\}$。整个物体内的 Cauchy 应力场被指定为 $\\sigma_{ij}(\\mathbf{x}) = p_{0}\\,\\delta_{ij} + q_{0}\\,\\dfrac{x_{i} x_{j}}{a^{2}}$，其中 $p_{0}$ 和 $q_{0}$ 为常数，$\\delta_{ij}$ 是克罗内克 delta (Kronecker delta)，$x_{i}$ 是笛卡尔坐标。在边界 $\\Gamma$ 上的单位外法向量为 $n_{i}(\\mathbf{x}) = \\dfrac{x_{i}}{a}$，且边界位移场是径向均匀的，$u_{i}(\\mathbf{x}) = U_{0}\\,n_{i}(\\mathbf{x})$ 对于 $\\mathbf{x} \\in \\Gamma$。\n\n从 Cauchy 应力原理和局部（微分）层面的线动量守恒出发，推导从应力张量到有向面上的面力向量的线性映射，并确定在边界 $\\Gamma$ 上的面力向量。然后，利用弹性力学中边界积分公式所依据的边界面力与边界位移之间的标准外虚功配对，计算标量边界功泛函\n$$\nW \\;=\\; \\int_{\\Gamma} u_{i}(\\mathbf{x})\\, t_{i}(\\mathbf{x}) \\, \\mathrm{d}\\Gamma,\n$$\n其中 $t_{i}(\\mathbf{x})$ 表示作用于物体边界 $\\Gamma$ 上的面力向量。使用数值数据 $a = 0.5\\,\\mathrm{m}$，$p_{0} = 2.0 \\times 10^{6}\\,\\mathrm{N/m^{2}}$，$q_{0} = 1.0 \\times 10^{6}\\,\\mathrm{N/m^{2}}$ 以及 $U_{0} = 5.0 \\times 10^{-3}\\,\\mathrm{m}$。\n\n解释单位外法向量和面力向量的符号约定如何与边界位移的功共轭相关，即对于边界速度 $v_{i}$，外部输入功率为 $\\int_{\\Gamma} t_{i} v_{i} \\,\\mathrm{d}\\Gamma$。最后，根据给定数据计算 $W$。将 $W$ 的最终值以牛顿-米为单位表示；无需四舍五入。最终答案必须是单个实数或单个闭式解析表达式。",
            "solution": "此问题经验证是自洽的、有科学依据的，并且对于所要求的特定任务是适定的。给定的应力场 $\\sigma_{ij}(\\mathbf{x})$ 在没有体力的情况下不满足平衡方程 $\\sigma_{ij,j} = 0$（因为 $\\sigma_{ij,j} = \\frac{4q_0 x_i}{a^2}$），这一事实并不妨碍计算边界上面力和随后的功积分，因为这些运算仅依赖于场在边界上的值，而不依赖于内部的场方程。我们假设问题陈述是要求使用给定场进行这些计算，并继续进行。\n\n首先，我们推导从应力张量到面力向量的线性映射，这被称为 Cauchy 公式。对于具有边界 $\\partial V$ 的任意控制体 $V$，线动量守恒表明动量的变化率等于面力和体力的总和。在积分形式下，对于静态情况或惯性效应在极限情况下可忽略不计的情况，这表示为 $\\int_{\\partial V} t_i \\, \\mathrm{d}\\Gamma + \\int_V b_i \\, \\mathrm{d}V = \\mathbf{0}$，其中 $t_i$ 是作用在 $\\partial V$ 上的面力向量，$b_i$ 是单位体积的体力。在表面上一点 $\\mathbf{x}$ 处的面力 $\\mathbf{t}$ 取决于表面的方向，该方向由其单位法向量 $\\mathbf{n}$ 给出。这种关系表示为 $\\mathbf{t} = \\mathbf{t}(\\mathbf{x}, \\mathbf{n})$。通过考虑一个无穷小四面体的平衡，其三个面平行于笛卡尔坐标平面，另一个面具有任意法线 $\\mathbf{n}$，我们可以将斜面上的面力 $\\mathbf{t}^{(\\mathbf{n})}$ 与坐标平面上的面力联系起来。在四面体尺寸缩小到零的极限下，与体积相关的项（如体力）比与表面相关的项消失得更快。这导出了基本结果：\n$$\nt_i = \\sigma_{ij} n_j\n$$\n其中 $\\sigma_{ij}$ 是 Cauchy 应力张量，其第 $j$ 列表示作用在法线沿 $x_j$ 轴的表面上的面力向量。这就是所要求的线性映射。\n\n接下来，我们确定实心球体边界 $\\Gamma$ 上的面力向量 $t_i(\\mathbf{x})$。给定的应力场为：\n$$\n\\sigma_{ij}(\\mathbf{x}) = p_{0}\\,\\delta_{ij} + q_{0}\\,\\dfrac{x_{i} x_{j}}{a^{2}}\n$$\n在球面 $\\Gamma$ 上（其中 $|\\mathbf{x}| = a$），单位外法向量为：\n$$\nn_{j}(\\mathbf{x}) = \\dfrac{x_{j}}{a}\n$$\n应用 Cauchy 公式，我们计算面力向量 $t_i$ 的分量：\n$$\nt_i = \\sigma_{ij} n_j = \\left( p_{0}\\,\\delta_{ij} + q_{0}\\,\\dfrac{x_{i} x_{j}}{a^{2}} \\right) \\left( \\dfrac{x_{j}}{a} \\right)\n$$\n我们将乘法展开：\n$$\nt_i = p_{0}\\,\\delta_{ij} \\dfrac{x_j}{a} + q_{0}\\,\\dfrac{x_{i} x_{j}}{a^{2}} \\dfrac{x_j}{a}\n$$\n利用克罗内克 delta 的性质，$\\delta_{ij} x_j = x_i$。第一项变为：\n$$\np_{0}\\,\\dfrac{x_i}{a} = p_0 n_i\n$$\n对于第二项，我们有乘积 $x_j x_j = x_1^2 + x_2^2 + x_3^2 = |\\mathbf{x}|^2$。由于我们在边界 $\\Gamma$ 上，所以 $|\\mathbf{x}|^2 = a^2$。第二项为：\n$$\nq_{0}\\,\\dfrac{x_{i}}{a^3} (x_j x_j) = q_{0}\\,\\dfrac{x_{i}}{a^3} a^2 = q_{0}\\,\\dfrac{x_i}{a} = q_0 n_i\n$$\n结合两项，边界上的面力向量为：\n$$\nt_i(\\mathbf{x}) = p_0 n_i(\\mathbf{x}) + q_0 n_i(\\mathbf{x}) = (p_0 + q_0) n_i(\\mathbf{x})\n$$\n\n问题要求解释符号约定。对物体做的外功是外力与力作用点位移的点积的积分。面力向量 $t_i$ 表示*周围环境通过边界 $\\Gamma$ 施加于物体*的单位面积力。边界的位移是 $u_i$。在面元 $\\mathrm{d}\\Gamma$ 上的元力是 $t_i \\mathrm{d}\\Gamma$。该力所做的功是 $(t_i \\mathrm{d}\\Gamma) u_i$。对边界进行积分得到总外功 $W = \\int_{\\Gamma} t_i u_i \\, \\mathrm{d}\\Gamma$。类似地，功率输入（做功速率）由 $P = \\int_{\\Gamma} t_i v_i \\, \\mathrm{d}\\Gamma$ 给出，其中 $v_i = \\dot{u}_i$ 是边界速度。该框架定义了面力 $t_i$ 与位移/速度 $u_i/v_i$ 之间的功共轭配对。使用*外*法线 $\\mathbf{n}$ 是一种约定，通过 Cauchy 公式 $t_i = \\sigma_{ij}n_j$，将 $\\mathbf{t}$ 定义为从外部作用于物体的力。因此，功率积分 $\\int t_i v_i \\mathrm{d}\\Gamma$ 的正值明确对应于能量从周围环境流入物体。\n\n现在，我们计算标量边界功泛函 $W$：\n$$\nW = \\int_{\\Gamma} u_{i}(\\mathbf{x})\\, t_{i}(\\mathbf{x}) \\, \\mathrm{d}\\Gamma\n$$\n边界位移给出为 $u_{i}(\\mathbf{x}) = U_{0}\\,n_{i}(\\mathbf{x})$。将 $u_i$ 和 $t_i$ 的表达式代入被积函数：\n$$\nu_i t_i = \\left( U_0 n_i \\right) \\left( (p_0 + q_0) n_i \\right) = U_0 (p_0 + q_0) (n_i n_i)\n$$\n由于 $\\mathbf{n}$ 是单位向量，标量积 $n_i n_i = |\\mathbf{n}|^2 = 1$。因此，被积函数在整个边界 $\\Gamma$ 上是常数：\n$$\nu_i t_i = U_0 (p_0 + q_0)\n$$\n功泛函变为：\n$$\nW = \\int_{\\Gamma} U_0 (p_0 + q_0) \\, \\mathrm{d}\\Gamma = U_0 (p_0 + q_0) \\int_{\\Gamma} \\mathrm{d}\\Gamma\n$$\n积分 $\\int_{\\Gamma} \\mathrm{d}\\Gamma$ 是半径为 $a$ 的球体的表面积，即 $4 \\pi a^2$。因此，功的解析表达式为：\n$$\nW = 4 \\pi a^2 U_0 (p_0 + q_0)\n$$\n最后，我们代入给定的数值：$a = 0.5\\,\\mathrm{m}$，$p_{0} = 2.0 \\times 10^{6}\\,\\mathrm{N/m^{2}}$，$q_{0} = 1.0 \\times 10^{6}\\,\\mathrm{N/m^{2}}$ 以及 $U_{0} = 5.0 \\times 10^{-3}\\,\\mathrm{m}$。\n$$\np_0 + q_0 = (2.0 \\times 10^6 + 1.0 \\times 10^6)\\,\\mathrm{N/m^2} = 3.0 \\times 10^6\\,\\mathrm{N/m^2}\n$$\n$$\na^2 = (0.5\\,\\mathrm{m})^2 = 0.25\\,\\mathrm{m^2}\n$$\n将这些值代入 $W$ 的表达式中：\n$$\nW = 4 \\pi (0.25\\,\\mathrm{m^2}) (5.0 \\times 10^{-3}\\,\\mathrm{m}) (3.0 \\times 10^6\\,\\mathrm{N/m^2})\n$$\n$$\nW = \\pi (1.0\\,\\mathrm{m^2}) (5.0 \\times 10^{-3}\\,\\mathrm{m}) (3.0 \\times 10^6\\,\\mathrm{N/m^2})\n$$\n$$\nW = \\pi (15.0 \\times 10^3)\\,\\mathrm{N \\cdot m}\n$$\n$$\nW = 15000 \\pi \\,\\mathrm{N \\cdot m}\n$$\n结果以牛顿-米为单位，符合要求。",
            "answer": "$$\n\\boxed{15000\\pi}\n$$"
        },
        {
            "introduction": "奇异积分的精确计算是边界元方法成功的基石。这个动手编程练习要求您实现并比较两种处理奇异性的强大技术——极坐标映射 (polar mapping) 和杜菲变换 (Duffy transformation)，以解决当源点与场点重合时出现的奇异性问题。掌握这些方法对于开发一个稳健、准确的BEM程序至关重要。",
            "id": "3547872",
            "problem": "考虑一个平面内的单个平坦三角形边界元，该边界元代表了线性弹性静力学边界元法（BEM）中的一个局部面板。设三角形的顶点为 $\\mathbf{v}_1=(0,0)$、$\\mathbf{v}_2=(1,0.2)$ 和 $\\mathbf{v}_3=(0.1,0.9)$，并设 $\\mathbf{x}_0$ 为三角形内部的一个点。定义一个光滑测试函数 $\\varphi(\\mathbf{x})=1+\\alpha x+\\beta y$，其中 $\\alpha=0.3$、$\\beta=0.2$，$\\mathbf{x}=(x,y)$ 是面板上的一个点。在弹性静力学边界积分中会出现两种典型的核函数类型：\n- 在二维弹性力学中，形式为 $K_{\\mathrm{w}}(r)=\\log r$ 的弱奇异核，其中 $r=\\|\\mathbf{x}-\\mathbf{x}_0\\|$。\n- 在三维弹性力学中，出现于超奇异公式中的强奇异核，其局部行为为 $K_{\\mathrm{s}}(r)=1/r^2$。\n\n为了使数值积分在科学和计算上是适定的，引入一个小的正则化参数 $\\varepsilon>0$ 并定义正则化核函数\n$$\nK_{\\mathrm{w},\\varepsilon}(r)=\\log\\big(\\sqrt{r^2+\\varepsilon^2}\\big),\\qquad K_{\\mathrm{s},\\varepsilon}(r)=\\frac{1}{r^2+\\varepsilon^2}.\n$$\n对于给定的面板和源点 $\\mathbf{x}_0$，定义目标积分\n$$\nI(K,\\varepsilon)=\\int_{T} \\varphi(\\mathbf{x})\\,K_{\\varepsilon}(\\|\\mathbf{x}-\\mathbf{x}_0\\|)\\,\\mathrm{d}A,\n$$\n其中 $T$ 是三角形面板，$K_{\\varepsilon}$ 是 $K_{\\mathrm{w},\\varepsilon}$ 或 $K_{\\mathrm{s},\\varepsilon}$。\n\n设计并实现两种专门用于处理 $\\mathbf{x}_0$ 处近奇异性的积分映射：\n1. 一种在面板上以 $\\mathbf{x}_0$ 为中心的极坐标映射，通过穿过 $\\mathbf{x}_0$ 的极射线来参数化该三角形。对于每个角度 $\\theta\\in[0,2\\pi)$，定义 $\\rho_{\\max}(\\theta)$ 为从 $\\mathbf{x}_0$ 沿角度为 $\\theta$ 的射线到三角形边界的距离。映射 $(\\theta,\\rho)\\mapsto \\mathbf{x}(\\theta,\\rho)=\\mathbf{x}_0+\\rho\\,\\mathbf{d}(\\theta)$，其中 $\\mathbf{d}(\\theta)=(\\cos\\theta,\\sin\\theta)$，导出面积元 $\\mathrm{d}A=\\rho\\,\\mathrm{d}\\rho\\,\\mathrm{d}\\theta$。在 $\\theta\\in[0,2\\pi]$ 和归一化径向坐标 $t\\in[0,1]$（其中 $\\rho=t\\,\\rho_{\\max}(\\theta)$）上使用张量积高斯-勒让德积分，得到\n$$\nI_{\\mathrm{polar}}(K,\\varepsilon;N_\\theta,N_\\rho)\\approx\\sum_{i=1}^{N_\\theta}\\sum_{j=1}^{N_\\rho} w_{\\theta,i}\\,w_{t,j}\\,\\varphi\\big(\\mathbf{x}_0+t_j\\,\\rho_{\\max}(\\theta_i)\\,\\mathbf{d}(\\theta_i)\\big)\\,K_{\\varepsilon}\\big(t_j\\,\\rho_{\\max}(\\theta_i)\\big)\\,\\big(\\rho_{\\max}(\\theta_i)^2\\,t_j\\big),\n$$\n其中 $w_{\\theta,i}$ 和 $w_{t,j}$ 分别是从 $[-1,1]$ 映射到 $[0,2\\pi]$ 和 $[0,1]$ 的高斯-勒让德权重。\n\n2. 在对三角形进行星形剖分（通过将$\\mathbf{x}_0$与各顶点连接，形成三个子三角形）的基础上应用Duffy变换。对于每个具有局部仿射映射 $\\mathbf{x}(u,v)=\\mathbf{x}_0+u\\,\\mathbf{a}+v\\,\\mathbf{b}$（$u\\ge 0, v\\ge 0, u+v\\le 1$）的子三角形，其中 $\\mathbf{a}$ 和 $\\mathbf{b}$ 是从 $\\mathbf{x}_0$ 到两个相邻顶点的边向量，应用Duffy映射 $(\\xi,\\eta)\\mapsto (u,v)$，其中 $u=\\xi(1-\\eta)$ 和 $v=\\xi\\eta$，$(\\xi,\\eta)\\in[0,1]^2$。面积元变换为 $\\mathrm{d}A=J_{\\text{sub}}\\,\\xi\\,\\mathrm{d}\\xi\\,\\mathrm{d}\\eta$，其中 $J_{\\text{sub}}=\\left|\\det\\left[\\mathbf{a}\\ \\mathbf{b}\\right]\\right|$ 是平面雅可比行列式的绝对值。局部距离为 $r(\\xi,\\eta)=\\|\\mathbf{x}(\\xi,\\eta)-\\mathbf{x}_0\\|=\\xi\\|(1-\\eta)\\mathbf{a}+\\eta\\mathbf{b}\\|$。在 $(\\xi,\\eta)\\in[0,1]^2$ 上使用张量积高斯-勒让德积分，并对三个子三角形的贡献求和，得到 $I_{\\mathrm{Duffy}}(K,\\varepsilon;N_\\xi,N_\\eta)$。\n\n从线性弹性静力学中边界积分公式的基本原理出发（即，边界积分涉及具有弱或强局部奇异性的核函数，且精确的数值评估需要能够感知奇异性的映射和雅可比控制），推导映射的雅可比行列式并实现这两种积分方案。对于下方的每个测试用例，使用高阶积分的极坐标映射计算一个高精度参考值 $I_{\\mathrm{ref}}(K,\\varepsilon)$，并量化绝对误差\n$$\nE_{\\mathrm{polar}}=\\left|I_{\\mathrm{polar}}-I_{\\mathrm{ref}}\\right|,\\qquad E_{\\mathrm{Duffy}}=\\left|I_{\\mathrm{Duffy}}-I_{\\mathrm{ref}}\\right|.\n$$\n报告每个测试用例的效率比 $R=E_{\\mathrm{Duffy}}/E_{\\mathrm{polar}}$。\n\n测试套件参数化：\n- 三角形顶点如上固定。测试函数参数为 $\\alpha=0.3, \\beta=0.2$。\n- 源点 $\\mathbf{x}_0$：\n  - 情况A：形心 $\\mathbf{x}_0=(\\mathbf{v}_1+\\mathbf{v}_2+\\mathbf{v}_3)/3$。\n  - 情况B：靠近顶点 $\\mathbf{v}_1$，$\\mathbf{x}_0=0.8\\,\\mathbf{v}_1+0.1\\,\\mathbf{v}_2+0.1\\,\\mathbf{v}_3$。\n  - 情况C：靠近 $\\mathbf{v}_2$ 和 $\\mathbf{v}_3$ 之间的边，$\\mathbf{x}_0=0.1\\,\\mathbf{v}_1+0.8\\,\\mathbf{v}_2+0.1\\,\\mathbf{v}_3$。\n- 参考积分阶数: $N_\\theta^{\\mathrm{ref}}=200$, $N_\\rho^{\\mathrm{ref}}=200$。\n\n待评估的测试用例，每个指定为 $(\\text{核函数类型}, \\varepsilon, N_\\theta, N_\\rho, N_{\\mathrm{Duffy}}, \\mathbf{x}_0)$：\n1. 弱奇异：$(\\text{weak}, 10^{-6}, 24, 24, 24, \\text{centroid})$。\n2. 弱奇异：$(\\text{weak}, 10^{-8}, 16, 16, 16, \\text{centroid})$。\n3. 弱奇异：$(\\text{weak}, 10^{-6}, 24, 24, 24, \\text{near } \\mathbf{v}_1)$。\n4. 强奇异：$(\\text{strong}, 10^{-4}, 24, 24, 24, \\text{centroid})$。\n5. 强奇异：$(\\text{strong}, 10^{-6}, 32, 32, 32, \\text{centroid})$。\n6. 强奇异：$(\\text{strong}, 10^{-6}, 24, 24, 24, \\text{near edge } \\mathbf{v}_2\\text{-}\\mathbf{v}_3)$。\n\n您的程序应生成单行输出，其中包含上述六个测试用例的效率比 $R$，形式为用方括号括起来的逗号分隔列表（例如，“[r1,r2,r3,r4,r5,r6]”）。所有数值都必须使用此处给出的三角形和函数设置进行计算；不需要物理单位。角度必须以弧度为单位进行处理。",
            "solution": "用户提供了一个有效的问题陈述。该问题在计算固体力学领域具有科学依据，具体涉及弹性静力学边界元法（BEM）中奇异边界积分的数值评估。该问题是适定的，提供了所有必要的数据、定义和约束，从而能够得到唯一的数值解。其语言客观、正式。本解答将着手推导并实现这些积分方案。\n\n核心任务是针对两种类型的正则化核函数 $K_{\\mathrm{w},\\varepsilon}$ 和 $K_{\\mathrm{s},\\varepsilon}$，在一个三角形面板 $T$ 上计算积分 $I(K,\\varepsilon)=\\int_{T} \\varphi(\\mathbf{x})\\,K_{\\varepsilon}(\\|\\mathbf{x}-\\mathbf{x}_0\\|)\\,\\mathrm{d}A$。点 $\\mathbf{x}_0$ 是三角形内部的一个源点，当 $\\varepsilon \\to 0$ 时，核函数在该点附近会变得奇异。我们将推导并实现两种专门的积分技术：极坐标映射和Duffy变换。\n\n三角形的顶点为 $\\mathbf{v}_1=(0,0)$、$\\mathbf{v}_2=(1,0.2)$ 和 $\\mathbf{v}_3=(0.1,0.9)$。测试函数为 $\\varphi(\\mathbf{x})=1+0.3x+0.2y$。正则化核函数为 $K_{\\mathrm{w},\\varepsilon}(r)=\\log\\big(\\sqrt{r^2+\\varepsilon^2}\\big)$ 和 $K_{\\mathrm{s},\\varepsilon}(r)=1/(r^2+\\varepsilon^2)$。\n\n### 1. 极坐标映射\n\n该方法使用以源点 $\\mathbf{x}_0$ 为中心的极坐标 $(\\rho, \\theta)$ 来重新参数化积分域。三角形中的一个点 $\\mathbf{x}$ 由 $\\mathbf{x}(\\rho, \\theta) = \\mathbf{x}_0 + \\rho\\mathbf{d}(\\theta)$ 给出，其中 $\\mathbf{d}(\\theta) = (\\cos\\theta, \\sin\\theta)$ 是方向向量。离源点的距离为 $r = \\|\\mathbf{x} - \\mathbf{x}_0\\| = \\rho$。\n\n从笛卡尔坐标 $(x,y)$ 到极坐标 $(\\rho,\\theta)$ 的这种变换的雅可比行列式给出了微分面积元 $\\mathrm{d}A = \\rho\\,\\mathrm{d}\\rho\\,\\mathrm{d}\\theta$。积分变为：\n$$\nI = \\int_{0}^{2\\pi} \\int_{0}^{\\rho_{\\max}(\\theta)} \\varphi\\big(\\mathbf{x}_0 + \\rho\\mathbf{d}(\\theta)\\big) K_{\\varepsilon}(\\rho) \\rho\\,\\mathrm{d}\\rho\\,\\mathrm{d}\\theta\n$$\n此处，$\\rho_{\\max}(\\theta)$ 是从 $\\mathbf{x}_0$ 沿方向 $\\mathbf{d}(\\theta)$ 到三角形 $T$ 边界的距离。\n\n为了创建一个固定的积分域，我们引入一个归一化的径向坐标 $t \\in [0,1]$，使得 $\\rho = t\\rho_{\\max}(\\theta)$。微分则为 $\\mathrm{d}\\rho = \\rho_{\\max}(\\theta)\\,\\mathrm{d}t$。将此代入积分表达式，项 $\\rho\\,\\mathrm{d}\\rho$ 变换为：\n$$\n\\rho\\,\\mathrm{d}\\rho = \\big(t\\rho_{\\max}(\\theta)\\big) \\big(\\rho_{\\max}(\\theta)\\,\\mathrm{d}t\\big) = t\\rho_{\\max}(\\theta)^2\\,\\mathrm{d}t\n$$\n在 $(\\theta, t)$ 坐标系下，矩形域 $[0, 2\\pi] \\times [0, 1]$ 上的积分为：\n$$\nI = \\int_{0}^{2\\pi} \\int_{0}^{1} \\varphi\\big(\\mathbf{x}_0 + t\\rho_{\\max}(\\theta)\\mathbf{d}(\\theta)\\big) K_{\\varepsilon}\\big(t\\rho_{\\max}(\\theta)\\big) \\left(t\\rho_{\\max}(\\theta)^2\\right)\\,\\mathrm{d}t\\,\\mathrm{d}\\theta\n$$\n对 $\\theta$ 使用 $N_\\theta$ 个点、对 $t$（在问题描述中对应于 $\\rho$）使用 $N_\\rho$ 个点应用张量积高斯-勒让德积分，我们得到数值近似：\n$$\nI_{\\mathrm{polar}} \\approx \\sum_{i=1}^{N_\\theta}\\sum_{j=1}^{N_\\rho} w_{\\theta,i}\\,w_{t,j}\\,\\left[ \\varphi\\big(\\mathbf{x}(\\theta_i, t_j)\\big) K_{\\varepsilon}\\big(r(\\theta_i, t_j)\\big) t_j\\,\\rho_{\\max}(\\theta_i)^2 \\right]\n$$\n其中 $\\mathbf{x}(\\theta_i, t_j) = \\mathbf{x}_0+t_j\\,\\rho_{\\max}(\\theta_i)\\,\\mathbf{d}(\\theta_i)$，$r(\\theta_i, t_j) = t_j\\,\\rho_{\\max}(\\theta_i)$，并且 $(t_j, w_{t,j})$ 和 $(\\theta_i, w_{\\theta_i})$ 分别是映射到区间 $[0,1]$ 和 $[0,2\\pi]$ 的高斯-勒让德积分点和权重。这证实了问题陈述中提供的公式。\n\n### 2. Duffy变换\n\n该方法首先通过将源点 $\\mathbf{x}_0$ 与每个顶点 $\\mathbf{v}_1, \\mathbf{v}_2, \\mathbf{v}_3$ 连接，将原始三角形 $T$ 分解为三个子三角形（$T_1, T_2, T_3$）。总积分是这些子三角形上积分的总和：$I = \\sum_{k=1}^3 \\int_{T_k} \\varphi(\\mathbf{x}) K_\\varepsilon(\\dots) \\mathrm{d}A$。\n\n考虑一个顶点为 $\\mathbf{x}_0, \\mathbf{v}_a, \\mathbf{v}_b$ 的子三角形。我们引入一个从 $(u,v)$ 平面中的参考三角形（其中 $u \\ge 0, v \\ge 0, u+v \\le 1$）到该子三角形的标准仿射映射：\n$$\n\\mathbf{x}(u,v) = \\mathbf{x}_0 + u(\\mathbf{v}_a - \\mathbf{x}_0) + v(\\mathbf{v}_b - \\mathbf{x}_0) = \\mathbf{x}_0 + u\\mathbf{a} + v\\mathbf{b}\n$$\n面积元变换为 $\\mathrm{d}A = J_{\\text{sub}}\\,\\mathrm{d}u\\,\\mathrm{d}v$，其中 $J_{\\text{sub}} = |\\det[\\mathbf{a} \\ \\mathbf{b}]|$ 是该仿射映射的雅可比行列式。\n\n接下来，Duffy变换将 $(\\xi, \\eta)$ 平面中的单位正方形 $(\\xi,\\eta) \\in [0,1]^2$ 映射到 $(u,v)$ 平面中的参考三角形：\n$$\nu = \\xi(1-\\eta), \\quad v = \\xi\\eta\n$$\n该映射的雅可比行列式为：\n$$\nJ_{\\text{Duffy}} = \\left|\\det\\left(\\frac{\\partial(u,v)}{\\partial(\\xi,\\eta)}\\right)\\right| = \\left|\\det\\begin{pmatrix} 1-\\eta & -\\xi \\\\ \\eta & \\xi \\end{pmatrix}\\right| = |\\xi(1-\\eta) - (-\\xi\\eta)| = |\\xi| = \\xi \\quad (\\text{因为 } \\xi \\in [0,1])\n$$\n面积元 $\\mathrm{d}u\\,\\mathrm{d}v$ 被替换为 $\\xi\\,\\mathrm{d}\\xi\\,\\mathrm{d}\\eta$。因此，面积元的完整变换为 $\\mathrm{d}A = J_{\\text{sub}}\\,\\xi\\,\\mathrm{d}\\xi\\,\\mathrm{d}\\eta$。\n\n离源点的距离为 $r = \\|\\mathbf{x} - \\mathbf{x}_0\\| = \\|u\\mathbf{a} + v\\mathbf{b}\\| = \\|\\xi(1-\\eta)\\mathbf{a} + \\xi\\eta\\mathbf{b}\\| = \\xi\\|(1-\\eta)\\mathbf{a} + \\eta\\mathbf{b}\\|$。一个子三角形上的积分变为：\n$$\nI_{\\text{sub}} = \\int_{0}^{1}\\int_{0}^{1} \\varphi\\big(\\mathbf{x}(\\xi,\\eta)\\big) K_{\\varepsilon}\\big(r(\\xi,\\eta)\\big) J_{\\text{sub}}\\,\\xi\\,\\mathrm{d}\\xi\\,\\mathrm{d}\\eta\n$$\n总积分 $I_{\\mathrm{Duffy}}$ 是三个此类积分之和，每个子三角形一个。此变换的关键特征是面积元中的因子 $\\xi$，它有效地抵消了奇异性中最弱的部分。对于像 $K_w(r) = \\log r$ 这样的弱奇异核，由于 $r \\propto \\xi$，被积函数会包含 $\\xi \\log \\xi$ 项，该项在 $\\xi=0$ 处是有限且非奇异的。对于强奇异正则化核 $K_s(r) = 1/(r^2+\\varepsilon^2)$，由于 $r \\propto \\xi$，被积函数项将表现为 $\\xi / ((\\xi(\\dots))^2 + \\varepsilon^2)$，当 $\\varepsilon > 0$ 时，这也是非奇异的。这表明Duffy变换对被积函数进行了正则化，使其适用于标准的高斯-勒让德积分。\n\n### 3. 实现与比较\n\n提供的Python代码基于上述推导实现了极坐标和Duffy积分方案。对于每个测试用例，使用具有大量积分点（$N_\\theta^{\\mathrm{ref}}=200, N_\\rho^{\\mathrm{ref}}=200$）的极坐标方法计算一个高精度参考值 $I_{\\mathrm{ref}}$。然后使用指定的较低阶积分规则计算极坐标方法（$E_{\\mathrm{polar}} = |I_{\\mathrm{polar}} - I_{\\mathrm{ref}}|$）和Duffy方法（$E_{\\mathrm{Duffy}} = |I_{\\mathrm{Duffy}} - I_{\\mathrm{ref}}|$）的绝对误差。最终报告的值是效率比 $R = E_{\\mathrm{Duffy}} / E_{\\mathrm{polar}}$，它比较了在给定积分点数量下两种方法的准确性。一个小于1的比率 R 表明 Duffy 方法更准确。",
            "answer": "```python\nimport numpy as np\nfrom numpy.polynomial.legendre import leggauss\n\ndef solve():\n    \"\"\"\n    Solves the BEM quadrature problem by implementing and comparing polar and Duffy integration methods.\n    \"\"\"\n    # Global constants from the problem\n    V1 = np.array([0.0, 0.0])\n    V2 = np.array([1.0, 0.2])\n    V3 = np.array([0.1, 0.9])\n    VERTICES = (V1, V2, V3)\n    ALPHA = 0.3\n    BETA = 0.2\n\n    # Test function\n    def phi(x):\n        return 1.0 + ALPHA * x[0] + BETA * x[1]\n\n    # Regularized kernels\n    def k_weak(r, epsilon):\n        # The argument to log must be > 0. sqrt(r^2+eps^2) is always >0 for eps>0.\n        return 0.5 * np.log(r**2 + epsilon**2)\n\n    def k_strong(r, epsilon):\n        return 1.0 / (r**2 + epsilon**2)\n\n    # Helper function for Gauss-Legendre quadrature on arbitrary interval [a, b]\n    def mapped_leggauss(N, a, b):\n        points, weights = leggauss(N)\n        mapped_points = (b - a) / 2.0 * points + (a + b) / 2.0\n        mapped_weights = (b - a) / 2.0 * weights\n        return mapped_points, mapped_weights\n    \n    # Memoization for get_rho_max to speed up repeated calls with same theta\n    rho_max_cache = {}\n    def get_rho_max(theta, x0_tuple):\n        x0 = np.array(x0_tuple)\n        cache_key = (theta, x0_tuple)\n        if cache_key in rho_max_cache:\n            return rho_max_cache[cache_key]\n\n        d = np.array([np.cos(theta), np.sin(theta)])\n        distances = []\n        \n        edges = [(V1, V2), (V2, V3), (V3, V1)]\n        for p1, p2 in edges:\n            v = p2 - p1\n            mat_det = -d[0] * v[1] + d[1] * v[0]\n            \n            if np.abs(mat_det)  1e-15:\n                continue\n\n            rhs = p1 - x0\n            t = (rhs[0] * (-v[1]) - rhs[1] * (-v[0])) / mat_det\n            s = (d[0] * rhs[1] - d[1] * rhs[0]) / mat_det\n            \n            if t > 1e-12 and -1e-12 = s = 1 + 1e-12:\n                distances.append(t)\n        \n        if not distances:\n            raise ValueError(f\"No intersection found for theta={theta}, x0={x0}\")\n        \n        result = min(distances)\n        rho_max_cache[cache_key] = result\n        return result\n\n    def integrate_polar(kernel_func, epsilon, N_theta, N_rho, x0):\n        theta_pts, theta_w = mapped_leggauss(N_theta, 0, 2 * np.pi)\n        t_pts, t_w = mapped_leggauss(N_rho, 0, 1)\n        \n        integral = 0.0\n        x0_tuple = tuple(x0) # Use tuple for cache key\n        \n        for i, th in enumerate(theta_pts):\n            rho_max_i = get_rho_max(th, x0_tuple)\n            d_i = np.array([np.cos(th), np.sin(th)])\n            \n            for j, t in enumerate(t_pts):\n                rho = t * rho_max_i\n                x = x0 + rho * d_i\n                integrand = phi(x) * kernel_func(rho, epsilon) * (rho_max_i**2 * t)\n                integral += theta_w[i] * t_w[j] * integrand\n                \n        return integral\n\n    def integrate_duffy_sub(kernel_func, epsilon, N, x0, v_a, v_b):\n        a = v_a - x0\n        b = v_b - x0\n        \n        J_sub = np.abs(a[0] * b[1] - a[1] * b[0])\n        \n        xi_pts, xi_w = mapped_leggauss(N, 0, 1)\n        eta_pts, eta_w = mapped_leggauss(N, 0, 1)\n        \n        integral = 0.0\n        \n        for i, xi in enumerate(xi_pts):\n            for j, eta in enumerate(eta_pts):\n                pos_rel = xi * ((1 - eta) * a + eta * b)\n                x = x0 + pos_rel\n                r = np.linalg.norm(pos_rel)\n                integrand = phi(x) * kernel_func(r, epsilon) * J_sub * xi\n                integral += xi_w[i] * eta_w[j] * integrand\n        \n        return integral\n\n    def integrate_duffy(kernel_func, epsilon, N, x0):\n        total_integral = 0.0\n        v1, v2, v3 = VERTICES\n        total_integral += integrate_duffy_sub(kernel_func, epsilon, N, x0, v1, v2)\n        total_integral += integrate_duffy_sub(kernel_func, epsilon, N, x0, v2, v3)\n        total_integral += integrate_duffy_sub(kernel_func, epsilon, N, x0, v3, v1)\n        return total_integral\n\n    test_cases_params = [\n        ('weak', 1e-6, 24, 24, 24, 'centroid'),\n        ('weak', 1e-8, 16, 16, 16, 'centroid'),\n        ('weak', 1e-6, 24, 24, 24, 'near_v1'),\n        ('strong', 1e-4, 24, 24, 24, 'centroid'),\n        ('strong', 1e-6, 32, 32, 32, 'centroid'),\n        ('strong', 1e-6, 24, 24, 24, 'near_edge_v2_v3'),\n    ]\n\n    x0_centroid = (V1 + V2 + V3) / 3.0\n    x0_near_v1 = 0.8 * V1 + 0.1 * V2 + 0.1 * V3\n    x0_near_edge = 0.1 * V1 + 0.8 * V2 + 0.1 * V3\n\n    source_points_map = {\n        'centroid': x0_centroid,\n        'near_v1': x0_near_v1,\n        'near_edge_v2_v3': x0_near_edge\n    }\n    \n    kernel_map = {'weak': k_weak, 'strong': k_strong}\n    N_theta_ref, N_rho_ref = 200, 200\n    \n    results = []\n\n    for params in test_cases_params:\n        k_type, epsilon, N_theta, N_rho, N_duffy, x0_key = params\n        \n        kernel = kernel_map[k_type]\n        x0 = source_points_map[x0_key]\n        \n        rho_max_cache.clear() # Clear cache for each new configuration\n        I_ref = integrate_polar(kernel, epsilon, N_theta_ref, N_rho_ref, x0)\n        \n        rho_max_cache.clear()\n        I_polar = integrate_polar(kernel, epsilon, N_theta, N_rho, x0)\n        I_duffy = integrate_duffy(kernel, epsilon, N_duffy, x0)\n        \n        E_polar = np.abs(I_polar - I_ref)\n        E_duffy = np.abs(I_duffy - I_ref)\n        \n        if E_polar  1e-16:\n            ratio = 1.0 if E_duffy  1e-16 else np.inf\n        else:\n            ratio = E_duffy / E_polar\n            \n        results.append(ratio)\n        \n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "除了处理真正的奇异点，BEM的实践者还必须有效处理近奇异积分，这种情况发生在计算点非常靠近某个边界单元但并不在该单元上时。本练习专注于设计一种与距离相关的自适应求积方案，以确保在薄壁结构或微小间隙等具有挑战性的工程分析场景中，数值计算仍能保持高精度。",
            "id": "3547819",
            "problem": "考虑在各向同性、均匀的二维线性弹性力学平面应变条件下，代表一个薄间隙壁面的两条平行直线边界段。设上壁面为从 $(0, g/2)$ 到 $(L, g/2)$ 的线段，下壁面为从 $(0, -g/2)$ 到 $(L, -g/2)$ 的线段。设目标点 $\\mathbf{x} = (x_0, y_0)$ 位于间隙内部。间隙厚度 $g$ 很小，使得 $\\mathbf{x}$ 到壁面的距离远小于用于离散化每个壁面的典型单元尺寸 $h$，即 $\\text{dist}(\\mathbf{x}, \\Gamma) \\ll h$。\n\n你需要通过在两个壁面上使用给定的常数密度的单层势，来近似计算在 $\\mathbf{x}$ 处引起的位移场。在各向同性、均匀的二维线性弹性力学（平面应变）中，位移的单层势由下式给出\n$$\nu_i(\\mathbf{x}) = \\int_{\\Gamma} U_{ij}(\\mathbf{x}, \\mathbf{y}) \\, t_j(\\mathbf{y}) \\, \\mathrm{d}\\Gamma(\\mathbf{y}),\n$$\n其中 $U_{ij}(\\mathbf{x}, \\mathbf{y})$ 是平面应变位移的 Kelvin 基本解，\n$$\nU_{ij}(\\mathbf{x}, \\mathbf{y}) = \\frac{1}{8 \\pi \\mu} \\left( - \\kappa \\, \\delta_{ij} \\, \\ln r + \\frac{r_i r_j}{r^2} \\right),\n$$\n$r_i = x_i - y_i$，$r = \\|\\mathbf{x} - \\mathbf{y}\\|$，$\\delta_{ij}$ 是克罗内克 δ，$\\mu$ 是剪切模量，$\\kappa = 3 - 4 \\nu$，其中 $\\nu$ 是泊松比。假设两个壁面的面力密度均为常数，等于 $t_j(\\mathbf{y}) = (1, 0)$。材料参数为 $\\mu = 1$ 和 $\\nu = 0.25$。\n\n当 $\\mathbf{x}$ 靠近壁面单元但不与之重合时，该积分为近奇异积分。你必须设计并实现一种能够解决这些近奇异积分的距离感知求积法。该求积法必须：\n\n- 将每个壁面划分为 $N$ 个长度为 $h = L/N$ 的相等单元。\n- 对于给定的目标点 $\\mathbf{x}$ 和端点为 $\\mathbf{a}$ 和 $\\mathbf{b}$ 的单元，计算 $\\mathbf{x}$ 到线段 $\\overline{\\mathbf{ab}}$ 的最小距离 $\\rho$。\n- 如果 $\\rho/h$ 低于一个加密阈值，则将该单元细分为 $n_{\\text{ref}}$ 个均匀的子单元，使得子单元长度为 $\\mathcal{O}(\\rho)$，并根据比率 $h/\\rho$ 增加 Gauss-Legendre 求积阶数 $q$（确保 $q$ 保持在合理范围内）。否则，使用基础求积阶数，不进行细分。\n- 使用 Gauss-Legendre 求积法逐单元计算积分，并将两个壁面上所有单元的贡献相加。\n\n从 Somigliana 恒等式和 Kelvin 基本解出发，通过明确地将 $U_{ij}(\\mathbf{x}, \\mathbf{y})$ 的近奇异行为与距离感知的细分和阶数选择的必要性联系起来，来论证该求积设计的合理性。推导过程必须从线性弹性力学的控制方程和 Kelvin 解的性质开始，并且必须为根据 $\\rho/h$ 选择 $n_{\\text{ref}}$ 和 $q$ 得出一个清晰的算法策略。\n\n为以下测试套件计算位移的 x 分量 $u_x(\\mathbf{x})$。所有长度均为无量纲单位，其中 $\\mu=1$ 且 $L$ 为单位长度。以无量纲位移单位报告结果：\n\n1. 情况 A（薄间隙，中心）：$L = 1.0$，$g = 10^{-3}$，$N = 8$，$\\mathbf{x} = (0.5, 0.0)$。\n2. 情况 B（超薄间隙，中心）：$L = 1.0$，$g = 10^{-6}$，$N = 8$，$\\mathbf{x} = (0.5, 0.0)$。\n3. 情况 C（薄间隙，x 方向偏心）：$L = 1.0$，$g = 10^{-2}$，$N = 8$，$\\mathbf{x} = (0.75, 0.0)$。\n4. 情况 D（中等间隙，中心）：$L = 1.0$，$g = 0.2$，$N = 8$，$\\mathbf{x} = (0.25, 0.0)$。\n5. 情况 E（薄间隙，靠近左边缘）：$L = 1.0$，$g = 10^{-3}$，$N = 8$，$\\mathbf{x} = (10^{-6}, 0.0)$。\n\n你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，“[$r_1$,$r_2$,$r_3$,$r_4$,$r_5$]”），其中 $r_k$ 是测试用例 $k$ 计算出的 $u_x(\\mathbf{x})$。所有数值结果必须如上所述为无量纲单位，并且必须是十进制浮点数。",
            "solution": "用户提供的问题是有效的，因为它科学地基于线性弹性力学原理，具有完整且一致的适定设置，并以客观、正式的语言表述。我们继续提供完整解答。\n\n### 引言与理论论证\n\n该问题要求计算在两个平行边界段 $\\Gamma$ 上，由给定的面力密度 $\\mathbf{t}(\\mathbf{y})$ 在目标点 $\\mathbf{x}$ 处引起的位移场。这通过计算一个单层边界积分来实现，该积分是边界元法 (BEM) 中的一个基本构造。问题的核心在于，当目标点 $\\mathbf{x}$ 非常靠近积分边界 $\\Gamma$ 时（这种情况被称为近奇异积分），如何精确地进行该积分的数值计算。\n\n线性弹性、各向同性、均匀体在静力平衡状态下的控制方程是 Navier-Cauchy 方程：\n$$\n\\mu u_{i,jj}(\\mathbf{x}) + (\\lambda+\\mu) u_{j,ji}(\\mathbf{x}) + b_i(\\mathbf{x}) = 0\n$$\n其中 $u_i$ 是位移向量，$b_i$ 是单位体积的体力，$\\lambda$ 和 $\\mu$ 是 Lamé 第一和第二参数。参数 $\\mu$ 是剪切模量。\n\n边界元法建立在一个边界积分方程之上，该方程由 Betti 互易定理和控制方程的基本解推导而来。基本解，即 Kelvin 解 $U_{ij}(\\mathbf{x}, \\mathbf{y})$，表示在无限弹性介质中，由于在 $j$ 方向上施加于点 $\\mathbf{y}$ 的一个集中单位点力而在点 $\\mathbf{x}$ 处产生的位移。它满足带有奇异体力项的控制方程：\n$$\n\\mu U_{ik,ll}(\\mathbf{x}, \\mathbf{y}) + (\\lambda+\\mu) U_{lk,li}(\\mathbf{x}, \\mathbf{y}) + \\delta_{ij}\\delta(\\mathbf{x}-\\mathbf{y}) = 0\n$$\n其中 $\\delta_{ij}$ 是克罗内克 δ，$\\delta(\\mathbf{x}-\\mathbf{y})$ 是 Dirac δ 函数。对于二维平面应变，Kelvin 解由下式给出：\n$$\nU_{ij}(\\mathbf{x}, \\mathbf{y}) = \\frac{1}{8 \\pi \\mu} \\left( - \\kappa \\, \\delta_{ij} \\, \\ln r + \\frac{r_i r_j}{r^2} \\right)\n$$\n其中 $\\mathbf{r} = \\mathbf{x} - \\mathbf{y}$，$r = \\|\\mathbf{r}\\|$，$r_i = x_i - y_i$，$\\kappa = 3 - 4\\nu$，$\\nu$ 是泊松比。\n\n由嵌入在无限介质中的表面 $\\Gamma$ 上的力分布（面力密度）$\\mathbf{t}(\\mathbf{y})$ 产生的位移场由单层势给出：\n$$\nu_i(\\mathbf{x}) = \\int_{\\Gamma} U_{ij}(\\mathbf{x}, \\mathbf{y}) \\, t_j(\\mathbf{y}) \\, \\mathrm{d}\\Gamma(\\mathbf{y})\n$$\n这就是我们必须计算的积分。核函数 $U_{ij}$ 包含一个对数项 $\\ln r$，当 $r \\to 0$ 时该项是奇异的。当 $\\mathbf{x}$ 靠近边界 $\\Gamma$ 但不在其上时，对于边界单元上靠近 $\\mathbf{x}$ 的点 $\\mathbf{y}$，距离 $r = \\|\\mathbf{x} - \\mathbf{y}\\|$ 变得非常小。这本身不会在积分中产生奇点，但会导致被积函数变化极其迅速，形成一个尖锐的峰值。标准的数值求积方法，如 Gauss-Legendre 求积法，是为光滑、性态良好的函数设计的，无法准确捕捉这个峰值，从而导致显著误差。\n\n让我们分析这个误差的来源。一个标准的 q 点高斯求积在长度为 $h$ 的区间上的误差与 $E \\propto h^{2q+1} f^{(2q)}(\\eta)$ 成正比，其中 $f^{(2q)}$ 是被积函数 $f$ 在区间内某点 $\\eta$ 的 $(2q)$ 阶导数。\n考虑一个长度为 $h$ 的单元和一个目标点 $\\mathbf{x}$，其到包含该单元的直线的最小距离为 $\\rho \\ll h$。设该单元由局部坐标 $s$ 参数化，其中 $s=0$ 对应最近点。距离 $r$ 由 $r(s) = \\sqrt{\\rho^2 + s^2}$ 给出。我们被积函数中有问题的部分表现为 $f(s) \\sim \\ln r(s) = \\frac{1}{2}\\ln(\\rho^2 + s^2)$。该函数关于 $s$ 的导数与 $\\rho$ 的负幂成比例。例如，二阶导数为 $f''(s) = \\frac{\\rho^2-s^2}{(\\rho^2+s^2)^2}$，在 $s=0$ 时为 $1/\\rho^2$。通常，k 阶导数的标度为 $f^{(k)}(s) \\sim \\mathcal{O}(\\rho^{-k})$。\n因此，求积误差的标度为 $E \\propto h^{2q+1} \\rho^{-2q} = \\left(\\frac{h}{\\rho}\\right)^{2q} h$。当 $\\rho \\ll h$ 时，项 $\\left(\\frac{h}{\\rho}\\right)^{2q}$ 变得巨大，数值积分变得不准确。\n\n为解决此问题，我们必须使用距离感知的自适应求积方案。其目标是使积分域相对于距离 $\\rho$ 足够小，以使被积函数在该域上变得光滑。这可以通过细分单元来实现。如果我们将长度为 $h$ 的单元划分为 $n_{\\text{ref}}$ 个子单元，每个子单元的长度为 $h_s = \\frac{h}{n_{\\text{ref}}}$，则一个子单元的误差贡献为 $E_s \\propto h_s^{2q+1} \\rho^{-2q}$。如果我们选择的细分数量使得子单元长度与距离同量级，即 $h_s \\approx \\rho$，则误差变为 $E_s \\propto \\rho^{2q+1} \\rho^{-2q} = \\rho$。整个原始单元上的总误差是 $n_{\\text{ref}}$ 个子单元误差的总和：$E_{\\text{total}} \\approx n_{\\text{ref}} \\times E_s = \\left(\\frac{h}{h_s}\\right) \\times E_s \\approx \\left(\\frac{h}{\\rho}\\right) \\times \\rho = h$。现在误差由单元尺寸 $h$ 控制，并且与小距离 $\\rho$ 无关。这恢复了数值方法的收敛性质。\n\n这一分析为以下算法策略提供了直接的理论依据：\n1. 对每个单元，计算最小距离 $\\rho = \\text{dist}(\\mathbf{x}, \\text{单元})$。\n2. 定义一个加密阈值，例如 $\\rho/h  2$。\n3. 如果一个单元是“近”的（即满足条件），则将其细分为 $n_{\\text{ref}}$ 个子单元。一个稳健的细分数量选择是 $n_{\\text{ref}} = \\lceil h/\\rho \\rceil$。这确保了子单元长度 $h/n_{\\text{ref}}$ 总是小于或等于 $\\rho$。\n4. 使用固定阶的 Gauss-Legendre 求积法计算每个子单元（或者，如果是“远”的，则为原始单元）上的积分。\n\n我们实现这一策略来解决给定的问题。\n\n### 数值实现\n\n给定 $\\mu=1$ 和 $\\nu=0.25$，得到 $\\kappa = 3 - 4(0.25) = 2$。常数面力密度为 $\\mathbf{t}(\\mathbf{y}) = (1, 0)$。要积分的位移分量由单层势公式（其中 $t_j = \\delta_{j1}$）推导得出：\n$$\nu_i(\\mathbf{x}) = \\int_{\\Gamma} U_{i1}(\\mathbf{x}, \\mathbf{y}) \\, \\mathrm{d}\\Gamma(\\mathbf{y})\n$$\n我们需要计算 x 分量，$u_x = u_1$。所需的被积函数是：\n$$\nU_{11}(\\mathbf{x}, \\mathbf{y}) = \\frac{1}{8 \\pi \\mu} \\left( - \\kappa \\, \\ln r + \\frac{r_1^2}{r^2} \\right)\n$$\n计算过程如下：将上、下壁面各离散为 $N$ 个单元。对每个单元，计算其到目标点 $\\mathbf{x}$ 的距离 $\\rho$。如果该单元被认为是“近”的，则如上所述对其进行细分。使用 Gauss-Legendre 求积法计算每个单元（或子单元）上的积分，并将两个壁面上所有单元的贡献相加，以获得在 $\\mathbf{x}$ 处的最终位移。",
            "answer": "```python\nimport numpy as np\nfrom math import ceil\n\ndef solve():\n    \"\"\"\n    Solves the 2D elasticity problem using a nearly-singular\n    boundary element integration scheme.\n    \"\"\"\n\n    # --- Problem Constants and Quadrature Settings ---\n    MU = 1.0\n    NU = 0.25\n    KAPPA = 3.0 - 4.0 * NU\n    C_KELVIN = 1.0 / (8.0 * np.pi * MU)\n    TRACTION = np.array([1.0, 0.0])\n\n    BASE_QUAD_ORDER = 16\n    REFINEMENT_THRESHOLD = 2.0\n    MAX_SUBDIVISIONS = 2000 # Safety cap\n\n    # Pre-compute Gauss-Legendre points and weights for the interval [-1, 1]\n    gauss_points, gauss_weights = np.polynomial.legendre.leggauss(BASE_QUAD_ORDER)\n\n    def get_min_dist_to_segment(p, a, b):\n        \"\"\"\n        Calculates the minimum distance from a point p to a line segment [a, b].\n        All inputs are numpy arrays representing coordinates.\n        \"\"\"\n        v = b - a\n        w = p - a\n        l2 = np.dot(v, v)\n        if l2 == 0.0: # a and b are the same point\n            return np.linalg.norm(w)\n        \n        # Project w onto v. t is the projection parameter.\n        t = np.dot(w, v) / l2\n        \n        # If projection falls outside the segment, clamp it to the nearest endpoint.\n        t = max(0.0, min(1.0, t))\n        \n        projection = a + t * v\n        return np.linalg.norm(p - projection)\n\n    def integrate_segment(x_target, p_start, p_end):\n        \"\"\"\n        Integrates the single-layer kernel over a single line segment [p_start, p_end]\n        using Gauss-Legendre quadrature. Returns the displacement vector contribution.\n        \"\"\"\n        segment_vec = p_end - p_start\n        segment_len = np.linalg.norm(segment_vec)\n        \n        # Jacobian of the transformation from reference element [-1, 1] to the segment\n        jacobian = segment_len / 2.0\n        \n        # Map Gauss points from [-1, 1] to physical points on the segment\n        # y_points is a (BASE_QUAD_ORDER x 2) array of coordinates\n        y_points = p_start + 0.5 * (1.0 + gauss_points[:, np.newaxis]) * segment_vec\n        \n        # Calculate r vector and its magnitude for all quadrature points\n        r_vec = x_target - y_points\n        r_sq = np.sum(r_vec * r_vec, axis=1)\n        r = np.sqrt(r_sq)\n        \n        # Calculate the integrand vector components (U_i1)\n        # We need the first column of the Kelvin tensor U_ij, since t = (1, 0)\n        rx = r_vec[:, 0]\n        ry = r_vec[:, 1]\n        \n        # Integrand for u_x (displacement in x-direction)\n        integrand_x = C_KELVIN * (-KAPPA * np.log(r) + (rx * rx) / r_sq)\n        \n        # The problem only asks for u_x, but we compute u_y for completeness\n        # Integrand for u_y (displacement in y-direction)\n        # integrand_y = C_KELVIN * ((rx * ry) / r_sq)\n        \n        # Perform quadrature sum\n        u_x = np.sum(integrand_x * gauss_weights) * jacobian\n        # u_y = np.sum(integrand_y * gauss_weights) * jacobian\n        \n        return u_x # Return only the x-component\n\n    # --- Test Cases ---\n    test_cases = [\n        # Case A: L, g, N, x_target\n        (1.0, 1e-3, 8, np.array([0.5, 0.0])),\n        # Case B\n        (1.0, 1e-6, 8, np.array([0.5, 0.0])),\n        # Case C\n        (1.0, 1e-2, 8, np.array([0.75, 0.0])),\n        # Case D\n        (1.0, 0.2, 8, np.array([0.25, 0.0])),\n        # Case E\n        (1.0, 1e-3, 8, np.array([1e-6, 0.0])),\n    ]\n\n    results = []\n\n    for L, g, N, x_target in test_cases:\n        h = L / N\n        walls_y = [g / 2.0, -g / 2.0]\n        total_disp_x = 0.0\n\n        for y_wall in walls_y:\n            for i in range(N):\n                p_start = np.array([i * h, y_wall])\n                p_end = np.array([(i + 1) * h, y_wall])\n\n                rho = get_min_dist_to_segment(x_target, p_start, p_end)\n                \n                # Use adaptive subdivision for \"near\" panels\n                if rho > 1e-12 and rho / h  REFINEMENT_THRESHOLD:\n                    n_ref = min(MAX_SUBDIVISIONS, ceil(h / rho))\n                    sub_h = h / n_ref\n                    for j in range(n_ref):\n                        sub_p_start = np.array([(i * h) + j * sub_h, y_wall])\n                        sub_p_end = np.array([(i * h) + (j + 1) * sub_h, y_wall])\n                        total_disp_x += integrate_segment(x_target, sub_p_start, sub_p_end)\n                else: # Use standard quadrature for \"far\" panels or if rho is zero\n                    total_disp_x += integrate_segment(x_target, p_start, p_end)\n        \n        results.append(total_disp_x)\n\n    # Format the final output string exactly as required\n    print(f\"[{','.join(f'{r:.12f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}