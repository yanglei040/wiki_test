{
    "hands_on_practices": [
        {
            "introduction": "The foundation of any meshfree method lies in the construction of its shape functions. This first practice takes you back to the fundamentals by guiding you through the analytical derivation of Moving Least Squares (MLS) shape functions in one dimension . By working through the minimization of the weighted least-squares functional, you will explicitly construct the moment matrix and derive the shape functions and their gradients, gaining a concrete understanding of their mathematical structure and inherent smoothness. This exercise also highlights a key distinction from finite element methods: the general absence of the Kronecker-delta property at the nodes.",
            "id": "3581248",
            "problem": "Consider a one-dimensional meshfree Galerkin approximation constructed via the Moving Least Squares (MLS) method, which is a standard realization of the Reproducing Kernel Particle Method (RKPM). Let the trial space be generated from the quadratic polynomial basis $p(x) = [\\,1,\\; x,\\; x^{2}\\,]^{\\mathsf{T}}$. Assume a nodal set located at positions $x_{i} \\in \\{-2,\\,-1,\\,0,\\,1,\\,2\\}$ on the real line, with nodal parameters (pseudo-values) $u_{i}$. The MLS approximation at a point $x$ takes the form $u^{h}(x) = p^{\\mathsf{T}}(x)\\,a(x)$, where $a(x)$ is determined by minimizing the weighted least-squares functional built from a Gaussian weight function. Specifically, use the Gaussian weights\n$$\nw_{i}(x) \\;=\\; \\exp\\!\\Big(-\\,\\frac{(x - x_{i})^{2}}{2}\\Big),\n$$\nwhich are $C^{\\infty}$ functions of $x$. Starting from the least-squares minimization and its normal equations, derive the MLS shape functions $N_{i}(x)$ such that $u^{h}(x) = \\sum_{i} N_{i}(x)\\,u_{i}$, and their spatial gradients in one dimension, $\\partial_{x} N_{i}(x)$. Then, using only the given nodal set, basis, and weights:\n\n1) Compute the exact closed-form expressions of the MLS shape functions $N_{i}(x)$ in a neighborhood of $x=0$ by explicitly forming the moment matrix $M(x)$, inverting it, and evaluating $N_{i}(x) = p^{\\mathsf{T}}(x)\\,M^{-1}(x)\\,w_{i}(x)\\,p(x_{i})$ at $x=0$.\n\n2) Compute the exact expressions of the gradients $\\partial_{x} N_{i}(x)$ at $x=0$ by differentiating the MLS shape functions with respect to $x$, carefully accounting for the $x$-dependence of both the weights and the inverse moment matrix.\n\n3) Using your formulas from items $1)$ and $2)$, verify:\n- Smoothness: argue from first principles why the functions $N_{i}(x)$ and $\\partial_{x}N_{i}(x)$ are continuous (indeed $C^{\\infty}$) at $x=0$.\n- Absence of the Kronecker delta property at nodes: demonstrate explicitly that $N_{0}(0) \\neq 1$ and $N_{j}(0) \\neq 0$ for at least one $j \\neq 0$.\n\nFor the final answer, report only the exact closed-form analytic expression (in terms of $\\exp(\\cdot)$) for the central-node MLS shape function evaluated at the central node, $N_{0}(0)$. Do not provide a numerical approximation. Express your final answer as a single simplified expression in terms of $\\exp(-\\tfrac{1}{2})$ and $\\exp(-2)$. No units are required.",
            "solution": "The problem is well-posed, scientifically grounded, and contains all necessary information to derive a unique solution. We proceed with the solution.\n\nThe Moving Least Squares (MLS) approximation $u^{h}(x)$ of a function $u(x)$ is constructed by finding the best local polynomial fit. At any point $x$, we seek a vector of coefficients $a(x)$ that minimizes a weighted discrete $L_2$ norm of the error between the polynomial approximation and the nodal values $u_i = u(x_i)$. The functional to be minimized is:\n$$\nJ(a(x)) = \\sum_{i} w_{i}(x) \\left( p^{\\mathsf{T}}(x_i) a(x) - u_i \\right)^2\n$$\nwhere $p(x) = [\\,1,\\; x,\\; x^2\\,]^{\\mathsf{T}}$ is the quadratic basis, $x_i \\in \\{-2, -1, 0, 1, 2\\}$ is the set of nodes, and $w_{i}(x) = \\exp(-\\frac{(x - x_i)^2}{2})$ is the Gaussian weight function.\n\nThe minimum is found by setting the gradient of $J$ with respect to $a(x)$ to zero, $\\nabla_a J(a(x)) = 0$. This leads to the normal equations:\n$$\n\\left( \\sum_{i} w_{i}(x) p(x_i) p^{\\mathsf{T}}(x_i) \\right) a(x) = \\sum_{i} w_{i}(x) p(x_i) u_i\n$$\nThe matrix in the parentheses is the moment matrix, $M(x) = \\sum_{i} w_{i}(x) p(x_i) p^{\\mathsf{T}}(x_i)$. The normal equations are thus $M(x) a(x) = B(x) u$, where $B(x)$ is a matrix whose $i$-th column is $w_{i}(x)p(x_i)$ and $u$ is the vector of nodal values $u_i$.\nSolving for $a(x)$ yields $a(x) = M^{-1}(x) \\sum_{i} w_{i}(x) p(x_i) u_i$.\nThe MLS approximation is then $u^{h}(x) = p^{\\mathsf{T}}(x) a(x)$. Substituting the expression for $a(x)$:\n$$\nu^{h}(x) = p^{\\mathsf{T}}(x) M^{-1}(x) \\sum_{i} w_{i}(x) p(x_i) u_i = \\sum_{i} \\left( p^{\\mathsf{T}}(x) M^{-1}(x) w_{i}(x) p(x_i) \\right) u_i\n$$\nBy definition, $u^{h}(x) = \\sum_{i} N_i(x) u_i$, so the MLS shape function for node $i$ is:\n$$\nN_i(x) = p^{\\mathsf{T}}(x) M^{-1}(x) w_{i}(x) p(x_i)\n$$\n\n### Part 1: Computation of $N_i(0)$\n\nWe need to evaluate the shape functions at $x=0$. This requires computing the moment matrix $M(0)$ and its inverse.\nThe nodes are $x_i \\in \\{-2, -1, 0, 1, 2\\}$. Let us denote them $x_{-2}, x_{-1}, x_0, x_1, x_2$.\nThe weights at $x=0$ are $w_i(0) = \\exp(-\\frac{x_i^2}{2})$.\n$w_0(0) = \\exp(0) = 1$.\n$w_1(0) = w_{-1}(0) = \\exp(-\\frac{1^2}{2}) = \\exp(-\\frac{1}{2})$.\n$w_2(0) = w_{-2}(0) = \\exp(-\\frac{(-2)^2}{2}) = \\exp(-2)$.\n\nThe moment matrix is $M(x) = \\sum_{i} w_i(x) \\begin{pmatrix} 1 & x_i & x_i^2 \\\\ x_i & x_i^2 & x_i^3 \\\\ x_i^2 & x_i^3 & x_i^4 \\end{pmatrix}$.\nAt $x=0$, due to the symmetry of the nodes and weights ($w_i(0)=w_{-i}(0)$), any summation $\\sum_i w_i(0) x_i^k$ for odd $k$ will be zero.\n$$\nM(0) = \\begin{pmatrix} \\sum_i w_i(0) & 0 & \\sum_i w_i(0) x_i^2 \\\\ 0 & \\sum_i w_i(0) x_i^2 & 0 \\\\ \\sum_i w_i(0) x_i^2 & 0 & \\sum_i w_i(0) x_i^4 \\end{pmatrix}\n$$\nLet's compute the sums (moments):\n$S_0 = \\sum_i w_i(0) = w_0(0) + 2w_1(0) + 2w_2(0) = 1 + 2\\exp(-\\frac{1}{2}) + 2\\exp(-2)$.\n$S_2 = \\sum_i w_i(0) x_i^2 = w_0(0)(0)^2 + 2w_1(0)(1)^2 + 2w_2(0)(2)^2 = 2\\exp(-\\frac{1}{2}) + 8\\exp(-2)$.\n$S_4 = \\sum_i w_i(0) x_i^4 = w_0(0)(0)^4 + 2w_1(0)(1)^4 + 2w_2(0)(2)^4 = 2\\exp(-\\frac{1}{2}) + 32\\exp(-2)$.\n\nSo the moment matrix at $x=0$ is:\n$$\nM(0) = \\begin{pmatrix} S_0 & 0 & S_2 \\\\ 0 & S_2 & 0 \\\\ S_2 & 0 & S_4 \\end{pmatrix}\n$$\nThe matrix is block-diagonal, which simplifies inversion. The inverse is:\n$$\nM^{-1}(0) = \\begin{pmatrix} \\frac{S_4}{S_0 S_4 - S_2^2} & 0 & \\frac{-S_2}{S_0 S_4 - S_2^2} \\\\ 0 & \\frac{1}{S_2} & 0 \\\\ \\frac{-S_2}{S_0 S_4 - S_2^2} & 0 & \\frac{S_0}{S_0 S_4 - S_2^2} \\end{pmatrix}\n$$\nThe determinant of the $2 \\times 2$ block is $\\det_{sub} = S_0 S_4 - S_2^2$. Let $E_1 = \\exp(-\\frac{1}{2})$ and $E_2 = \\exp(-2)$.\n$S_0 = 1 + 2E_1 + 2E_2$\n$S_2 = 2E_1 + 8E_2$\n$S_4 = 2E_1 + 32E_2$\n$\\det_{sub} = (1 + 2E_1 + 2E_2)(2E_1 + 32E_2) - (2E_1 + 8E_2)^2$\n$= (2E_1+32E_2) + (4E_1^2+64E_1E_2) + (4E_1E_2+64E_2^2) - (4E_1^2 + 32E_1E_2 + 64E_2^2)$\n$= 2E_1 + 32E_2 + 36E_1E_2$.\nSubstituting back the exponential forms and using $E_1E_2 = \\exp(-\\frac{5}{2})$:\n$\\det_{sub} = 2\\exp(-\\frac{1}{2}) + 32\\exp(-2) + 36\\exp(-\\frac{5}{2})$.\n\nNow we compute $N_i(0) = p^{\\mathsf{T}}(0) M^{-1}(0) w_i(0) p(x_i)$.\nSince $p^{\\mathsf{T}}(0) = [\\,1,\\; 0,\\; 0\\,]$, it picks the first row of $M^{-1}(0)$:\n$p^{\\mathsf{T}}(0) M^{-1}(0) = [\\,(M^{-1})_{11},\\; 0,\\; (M^{-1})_{13}\\,] = [\\,\\frac{S_4}{\\det_{sub}},\\; 0,\\; \\frac{-S_2}{\\det_{sub}}\\,]$.\nThen, $N_i(0) = [\\,\\frac{S_4}{\\det_{sub}},\\; 0,\\; \\frac{-S_2}{\\det_{sub}}\\,] \\begin{pmatrix} 1 \\\\ x_i \\\\ x_i^2 \\end{pmatrix} w_i(0) = \\frac{w_i(0)}{\\det_{sub}} (S_4 - S_2 x_i^2)$.\n\nFor the central node $i=0$: $x_0=0$, $w_0(0)=1$.\n$N_0(0) = \\frac{1}{\\det_{sub}}(S_4 - S_2(0)^2) = \\frac{S_4}{\\det_{sub}}$.\n$N_0(0) = \\frac{2\\exp(-\\frac{1}{2}) + 32\\exp(-2)}{2\\exp(-\\frac{1}{2}) + 32\\exp(-2) + 36\\exp(-\\frac{5}{2})}$.\nDividing the numerator and denominator by $2$:\n$N_0(0) = \\frac{\\exp(-\\frac{1}{2}) + 16\\exp(-2)}{\\exp(-\\frac{1}{2}) + 16\\exp(-2) + 18\\exp(-\\frac{5}{2})}$.\n\n### Part 2: Computation of $\\partial_x N_i(0)$\n\nThe gradient of the shape function is found by differentiating $N_i(x)$:\n$\\partial_x N_i(x) = (\\partial_x p^{\\mathsf{T}}(x)) M^{-1}(x) w_i(x) p(x_i) + p^{\\mathsf{T}}(x) (\\partial_x M^{-1}(x)) w_i(x) p(x_i) + p^{\\mathsf{T}}(x) M^{-1}(x) (\\partial_x w_i(x)) p(x_i)$.\nWe evaluate each term at $x=0$.\n$\\partial_x p(x) = [\\,0,\\; 1,\\; 2x\\,]^{\\mathsf{T}}$, so $\\partial_x p(0) = [\\,0,\\; 1,\\; 0\\,]^{\\mathsf{T}}$.\n$\\partial_x w_i(x) = -(x-x_i)w_i(x)$, so $\\partial_x w_i(0) = x_i w_i(0)$.\n$\\partial_x M^{-1}(x) = -M^{-1}(x) (\\partial_x M(x)) M^{-1}(x)$.\n$\\partial_x M(x) = \\sum_j (\\partial_x w_j(x)) p(x_j)p^{\\mathsf{T}}(x_j)$, so $\\partial_x M(0) = \\sum_j x_j w_j(0) p(x_j)p^{\\mathsf{T}}(x_j)$.\nThis matrix, let's call it $M'(0)$, has entries $M'_{kl}(0) = \\sum_j w_j(0) x_j^{k+l-1}$. Due to symmetry, entries are non-zero only if $k+l-1$ is even.\n$M'_{11} = \\sum w_j x_j = 0$. $M'_{12} = \\sum w_j x_j^2 = S_2$. $M'_{13} = 0$. $M'_{22} = 0$. $M'_{23} = \\sum w_j x_j^4 = S_4$. $M'_{33}=0$.\n$$\nM'(0) = \\begin{pmatrix} 0 & S_2 & 0 \\\\ S_2 & 0 & S_4 \\\\ 0 & S_4 & 0 \\end{pmatrix}\n$$\nNow we evaluate the three terms of $\\partial_x N_i(0)$.\n- Term 1: $\\partial_x p^{\\mathsf{T}}(0) M^{-1}(0) w_i(0) p(x_i) = [\\,0,1,0\\,]M^{-1}(0) w_i(0) p(x_i) = (M^{-1})_{22} w_i(0) x_i = \\frac{1}{S_2} w_i(0) x_i$.\n- Term 2: $-p^{\\mathsf{T}}(0)M^{-1}(0)M'(0)M^{-1}(0)w_i(0)p(x_i)$.\nThe vector $v^{\\mathsf{T}} = p^{\\mathsf{T}}(0)M^{-1}(0)M'(0) = [\\,\\frac{S_4}{\\det_{sub}}, 0, \\frac{-S_2}{\\det_{sub}}\\,] \\begin{pmatrix} 0 & S_2 & 0 \\\\ S_2 & 0 & S_4 \\\\ 0 & S_4 & 0 \\end{pmatrix} = [\\,0, \\frac{S_4 S_2}{\\det_{sub}} - \\frac{S_2 S_4}{\\det_{sub}}, 0\\,] = [\\,0, 0, 0\\,]$.\nSo, Term 2 is zero for all $i$. This is a consequence of symmetry.\n- Term 3: $p^{\\mathsf{T}}(0) M^{-1}(0) (\\partial_x w_i(0)) p(x_i) = p^{\\mathsf{T}}(0) M^{-1}(0) (x_i w_i(0)) p(x_i) = x_i N_i(0)$.\n\nCombining terms:\n$$\n\\partial_x N_i(0) = \\frac{x_i w_i(0)}{S_2} + x_i N_i(0) = x_i w_i(0) \\left( \\frac{1}{S_2} + \\frac{S_4 - S_2 x_i^2}{\\det_{sub}} \\right)\n$$\nFor $i=0$, $x_0=0$, so $\\partial_x N_0(0) = 0$. This is expected for an even shape function $N_0(x)$ centered at a point of symmetry.\n\n### Part 3: Verification of Properties\n\n- **Smoothness**: The shape function is $N_i(x) = p^{\\mathsf{T}}(x) M^{-1}(x) w_i(x) p(x_i)$. The basis functions $p_k(x)$ are polynomials and hence $C^{\\infty}$. The weight functions $w_i(x)$ are Gaussian and are $C^{\\infty}$. The moment matrix $M(x)$ has entries that are linear combinations of $w_j(x)$, so they are also $C^{\\infty}$. The inverse $M^{-1}(x)$ exists and its entries are $C^{\\infty}$ as long as $\\det(M(x)) \\neq 0$. We computed $\\det(M(0)) = S_2 \\cdot \\det_{sub}$. Since $S_2 > 0$ and $\\det_{sub} > 0$, the determinant is non-zero at $x=0$. By continuity, it is non-zero in a neighborhood of $x=0$. Therefore, $M^{-1}(x)$ is $C^{\\infty}$ near $x=0$. As $N_i(x)$ is formed from products and sums of $C^{\\infty}$ functions, it is $C^{\\infty}$. Its derivative $\\partial_x N_i(x)$ is consequently also $C^{\\infty}$.\n\n- **Absence of Kronecker Delta Property**:\nWe need to show $N_0(0) \\neq 1$ and $N_j(0) \\neq 0$ for some $j \\neq 0$.\nThe expression for $N_0(0)$ is $\\frac{S_4}{\\det_{sub}} = \\frac{S_4}{S_4 + 36\\exp(-\\frac{5}{2})}$, which is clearly positive and less than $1$. So $N_0(0) \\neq 1$.\nFor $j=1$, $x_1=1$, $i=1$:\n$N_1(0) = \\frac{w_1(0)}{\\det_{sub}}(S_4 - S_2 x_1^2) = \\frac{\\exp(-\\frac{1}{2})}{\\det_{sub}}(S_4 - S_2)$.\n$S_4 - S_2 = (2E_1 + 32E_2) - (2E_1 + 8E_2) = 24E_2 = 24\\exp(-2)$.\n$N_1(0) = \\frac{\\exp(-\\frac{1}{2}) \\cdot 24\\exp(-2)}{\\det_{sub}} = \\frac{24\\exp(-\\frac{5}{2})}{\\det_{sub}}$.\nSince $\\det_{sub}>0$, we have $N_1(0) > 0$. By symmetry, $N_{-1}(0) = N_1(0) \\neq 0$.\nSimilarly, for $j=2$, $x_2=2$:\n$N_2(0) = \\frac{w_2(0)}{\\det_{sub}}(S_4 - S_2 x_2^2) = \\frac{\\exp(-2)}{\\det_{sub}}(S_4 - 4S_2)$.\n$S_4 - 4S_2 = (2E_1 + 32E_2) - 4(2E_1 + 8E_2) = -6E_1 = -6\\exp(-\\frac{1}{2})$.\n$N_2(0) = \\frac{\\exp(-2) \\cdot (-6\\exp(-\\frac{1}{2}))}{\\det_{sub}} = \\frac{-6\\exp(-\\frac{5}{2})}{\\det_{sub}} \\neq 0$.\nThis explicitly demonstrates that the MLS shape functions do not possess the Kronecker delta property at the nodes.",
            "answer": "$$\n\\boxed{\\frac{\\exp(-\\frac{1}{2}) + 16\\exp(-2)}{18\\exp(-\\frac{5}{2}) + \\exp(-\\frac{1}{2}) + 16\\exp(-2)}}\n$$"
        },
        {
            "introduction": "A crucial property of Reproducing Kernel (RK) approximations is their ability to exactly reproduce polynomial fields up to a certain degree, which is essential for achieving optimal convergence. This hands-on coding exercise challenges you to implement and perform a numerical \"patch test\" to verify this reproduction property for various scenarios in two dimensions . You will investigate how the choice of basis (constant vs. linear) dictates whether the method can reproduce rigid body motions and uniform strain fields, providing tangible evidence for the theoretical consistency of the Element-Free Galerkin (EFG) method. This practice is a standard and indispensable step in validating any new implementation of a meshfree method.",
            "id": "3581266",
            "problem": "Consider a two-dimensional meshfree Element-Free Galerkin (EFG) patch test formulated via Moving Least Squares (MLS) within the framework of Reproducing Kernel (RK) approximation. The goal is to verify the reproduction properties under rigid body motion and uniform strain for a square particle cloud, and to quantify the effect of support size and basis degree on the numerical reproduction error.\n\nYou are to implement an MLS-based shape function construction over a uniform set of nodes in the square domain $[0,1] \\times [0,1]$, with node coordinates given by a regular grid of size $N_x \\times N_y$, where $N_x = N_y = 11$. The grid spacing is $h = 1/(N_x - 1)$. Use a compactly supported, positive weight function defined by\n$$\nw(q) = \\begin{cases}\n1 - 6 q^2 + 8 q^3 - 3 q^4, & 0 \\le q \\le 1, \\\\\n0, & q > 1,\n\\end{cases}\n$$\nwhere $q = r/d$, $r$ is the Euclidean distance from the evaluation point to a node, and $d$ is the nodal support radius. The MLS basis must be either degree $0$ (constant basis $p(\\mathbf{x}) = [1]$) or degree $1$ (linear basis $p(\\mathbf{x}) = [1, x, y]$). The MLS approximation must be constructed directly from first principles: start from the variational definition of MLS coefficients that minimize the weighted least-squares error over the local neighborhood, and derive the algebraic expressions needed for numerical evaluation of the shape functions and the approximate field.\n\nDefine three displacement fields in the plane:\n- Rigid translation: $\\mathbf{u}(\\mathbf{x}) = \\mathbf{c}$, with $\\mathbf{c} \\in \\mathbb{R}^2$.\n- Infinitesimal rigid rotation about the origin by angle $\\theta$ (in radians): $\\mathbf{u}(\\mathbf{x}) = \\theta\\,[-y,\\,x]^T$.\n- Uniform strain: $\\mathbf{u}(\\mathbf{x}) = \\mathbf{E}\\,\\mathbf{x}$, with $\\mathbf{E} \\in \\mathbb{R}^{2 \\times 2}$ constant.\n\nThe reproduction test requires that the MLS approximation $\\mathbf{u}^h(\\mathbf{x})$ exactly matches the target field $\\mathbf{u}(\\mathbf{x})$ for all $\\mathbf{x}$ whenever the field belongs to the polynomial space spanned by the chosen basis and the moment matrix is invertible. In particular, with the degree $0$ basis, constant fields are reproducible; with the degree $1$ basis, all linear vector fields, including rigid body rotation and uniform strain, are reproducible.\n\nNumerically verify these reproduction properties by constructing the MLS approximant $\\mathbf{u}^h(\\mathbf{x})$ from nodal samples $\\{\\mathbf{u}_i\\}$ at the grid nodes $\\{\\mathbf{x}_i\\}$ and evaluating the maximum absolute error\n$$\n\\varepsilon_{\\max} = \\max_{\\mathbf{x} \\in \\mathcal{S}} \\|\\mathbf{u}^h(\\mathbf{x}) - \\mathbf{u}(\\mathbf{x})\\|_{\\infty},\n$$\nover a set $\\mathcal{S}$ of evaluation points. Use the infinity norm on $\\mathbb{R}^2$ defined by $\\|[a,b]^T\\|_{\\infty} = \\max\\{|a|,|b|\\}$.\n\nAngles must be in radians. No physical units are involved in the outputs. Your program must implement the MLS shape functions and compute $\\varepsilon_{\\max}$ for each test case below. The final output must be a single line containing a list of floating-point errors for each test case, in the specified order.\n\nTest suite:\n- Test $\\mathbf{T1}$ (happy path, constant reproduction): basis degree $0$; support factor $s = 2.5$ so $d = s\\,h$; rigid translation with $\\mathbf{c} = [0.3,-0.2]^T$; evaluation set $\\mathcal{S}$ is the Cartesian product of coordinates $\\{0.1,0.3,0.5,0.7,0.9\\} \\times \\{0.1,0.3,0.5,0.7,0.9\\}$, totaling $25$ points.\n- Test $\\mathbf{T2}$ (non-reproducible with constant basis): basis degree $0$; support factor $s = 2.5$; rigid rotation with $\\theta = 0.1$; evaluation set $\\mathcal{S}$ as in $\\mathbf{T1}$.\n- Test $\\mathbf{T3}$ (rigid rotation reproduction): basis degree $1$; support factor $s = 2.5$; rigid rotation with $\\theta = 0.1$; evaluation set $\\mathcal{S}$ as in $\\mathbf{T1}$.\n- Test $\\mathbf{T4}$ (uniform strain reproduction): basis degree $1$; support factor $s = 2.5$; uniform strain with\n$$\n\\mathbf{E} = \\begin{bmatrix} 0.01 & 0.02 \\\\ 0.00 & -0.005 \\end{bmatrix};\n$$\nevaluation set $\\mathcal{S}$ as in $\\mathbf{T1}$.\n- Test $\\mathbf{T5}$ (edge case near boundary with small support): basis degree $1$; support factor $s = 1.05$; uniform strain with the same $\\mathbf{E}$ as in $\\mathbf{T4}$; evaluation set $\\mathcal{S}$ consists of a single point $\\mathbf{x} = [0.02, 0.02]^T$.\n\nFor each test, compute and return the value of $\\varepsilon_{\\max}$ as a float. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[$r_1,r_2,r_3,r_4,r_5$]\"), where $r_k$ is the result for test $\\mathbf{Tk}$ in the above order. Angles must be interpreted in radians, and there are no physical units for the outputs.\n\nYour derivations and implementation must start from the foundational definitions of the MLS approximation and the concept of reproduction in reproducing kernel methods, without assuming specialized formulas beyond these definitions.",
            "solution": "The problem requires the numerical verification of the reproduction properties of the Moving Least Squares (MLS) approximation, a cornerstone of meshfree methods like the Element-Free Galerkin (EFG) method. We will first derive the MLS shape functions from foundational principles and then outline the numerical procedure to conduct the patch tests.\n\n### 1. Moving Least Squares (MLS) Approximation\n\nThe MLS method constructs a continuous approximation of a field from a set of discrete nodal values. Let $u(\\mathbf{x})$ be a scalar field defined over a domain $\\Omega \\subset \\mathbb{R}^2$. Given a set of $N$ nodes $\\{\\mathbf{x}_i\\}_{i=1}^N$ with corresponding nodal values $\\{u_i = u(\\mathbf{x}_i)\\}_{i=1}^N$, the MLS approximation $u^h(\\mathbf{x})$ at an evaluation point $\\mathbf{x}$ is defined as a polynomial of a certain degree whose coefficients are determined locally.\n\nLet $\\mathbf{p}(\\mathbf{x}) = [p_1(\\mathbf{x}), p_2(\\mathbf{x}), \\dots, p_m(\\mathbf{x})]^T$ be a basis of $m$ polynomial functions. For a linear approximation in two dimensions, a suitable basis is $\\mathbf{p}(\\mathbf{x}) = [1, x, y]^T$, corresponding to a basis degree of $1$ and $m=3$. For a constant approximation, the basis is $\\mathbf{p}(\\mathbf{x}) = [1]$, with degree $0$ and $m=1$.\n\nThe approximation at a point $\\mathbf{x}$ is given by:\n$$\nu^h(\\mathbf{x}) = \\mathbf{p}^T(\\mathbf{x}) \\mathbf{a}(\\mathbf{x})\n$$\nwhere $\\mathbf{a}(\\mathbf{x}) \\in \\mathbb{R}^m$ is a vector of coefficients that depends on the position $\\mathbf{x}$. These coefficients are determined by minimizing a weighted, discrete least-squares error functional $J(\\mathbf{a})$ over the nodal values in a local neighborhood of $\\mathbf{x}$:\n$$\nJ(\\mathbf{a}) = \\sum_{i=1}^{N} w(\\mathbf{x} - \\mathbf{x}_i) \\left[ \\mathbf{p}^T(\\mathbf{x}_i) \\mathbf{a}(\\mathbf{x}) - u_i \\right]^2\n$$\nThe function $w(\\mathbf{x} - \\mathbf{x}_i)$ is a weight function with compact support, which is non-zero only for nodes $\\mathbf{x}_i$ \"close\" to $\\mathbf{x}$. The problem specifies the weight function as:\n$$\nw(q) = \\begin{cases}\n1 - 6 q^2 + 8 q^3 - 3 q^4, & 0 \\le q \\le 1, \\\\\n0, & q > 1,\n\\end{cases}\n$$\nwhere $q = \\|\\mathbf{x} - \\mathbf{x}_i\\|_2 / d$, $d$ being the radius of the support domain. For brevity, we denote $w_i(\\mathbf{x}) = w(\\mathbf{x} - \\mathbf{x}_i)$.\n\nTo find the coefficients $\\mathbf{a}(\\mathbf{x})$ that minimize $J$, we take the derivative of $J$ with respect to $\\mathbf{a}$ and set it to zero:\n$$\n\\frac{\\partial J}{\\partial \\mathbf{a}} = 2 \\sum_{i=1}^{N} w_i(\\mathbf{x}) \\mathbf{p}(\\mathbf{x}_i) \\left[ \\mathbf{p}^T(\\mathbf{x}_i) \\mathbf{a}(\\mathbf{x}) - u_i \\right] = \\mathbf{0}\n$$\nThis leads to the following system of linear equations for $\\mathbf{a}(\\mathbf{x})$:\n$$\n\\left( \\sum_{i=1}^{N} w_i(\\mathbf{x}) \\mathbf{p}(\\mathbf{x}_i) \\mathbf{p}^T(\\mathbf{x}_i) \\right) \\mathbf{a}(\\mathbf{x}) = \\sum_{i=1}^{N} w_i(\\mathbf{x}) \\mathbf{p}(\\mathbf{x}_i) u_i\n$$\nWe define the moment matrix $\\mathbf{M}(\\mathbf{x})$, an $m \\times m$ matrix, as:\n$$\n\\mathbf{M}(\\mathbf{x}) = \\sum_{i=1}^{N} w_i(\\mathbf{x}) \\mathbf{p}(\\mathbf{x}_i) \\mathbf{p}^T(\\mathbf{x}_i)\n$$\nThe system can now be written as $\\mathbf{M}(\\mathbf{x}) \\mathbf{a}(\\mathbf{x}) = \\sum_{i=1}^{N} w_i(\\mathbf{x}) \\mathbf{p}(\\mathbf{x}_i) u_i$.\nAssuming $\\mathbf{M}(\\mathbf{x})$ is invertible, which requires a sufficient number of nodes within the support domain of $\\mathbf{x}$ that are not in a degenerate configuration, we can solve for $\\mathbf{a}(\\mathbf{x})$:\n$$\n\\mathbf{a}(\\mathbf{x}) = \\mathbf{M}^{-1}(\\mathbf{x}) \\sum_{i=1}^{N} w_i(\\mathbf{x}) \\mathbf{p}(\\mathbf{x}_i) u_i\n$$\n\n### 2. Derivation of MLS Shape Functions\n\nSubstituting the expression for $\\mathbf{a}(\\mathbf{x})$ back into the definition of $u^h(\\mathbf{x})$, we get:\n$$\nu^h(\\mathbf{x}) = \\mathbf{p}^T(\\mathbf{x}) \\mathbf{M}^{-1}(\\mathbf{x}) \\sum_{i=1}^{N} w_i(\\mathbf{x}) \\mathbf{p}(\\mathbf{x}_i) u_i\n$$\nBy rearranging the expression to match the standard finite element form $u^h(\\mathbf{x}) = \\sum_{i=1}^{N} \\phi_i(\\mathbf{x}) u_i$, we can identify the MLS shape function $\\phi_i(\\mathbf{x})$ associated with node $i$:\n$$\n\\phi_i(\\mathbf{x}) = \\mathbf{p}^T(\\mathbf{x}) \\mathbf{M}^{-1}(\\mathbf{x}) \\mathbf{p}(\\mathbf{x}_i) w_i(\\mathbf{x})\n$$\nNote that $\\phi_i(\\mathbf{x}) = 0$ if node $\\mathbf{x}_i$ is outside the support of $\\mathbf{x}$, because $w_i(\\mathbf{x})=0$.\n\nFor a vector field, such as a displacement field $\\mathbf{u}(\\mathbf{x}) \\in \\mathbb{R}^2$, the MLS approximation is applied to each component independently using the same scalar shape functions:\n$$\n\\mathbf{u}^h(\\mathbf{x}) = \\sum_{i=1}^{N} \\phi_i(\\mathbf{x}) \\mathbf{u}_i\n$$\nwhere $\\mathbf{u}_i = \\mathbf{u}(\\mathbf{x}_i)$ are the nodal displacement vectors.\n\n### 3. Reproduction Property\n\nThe MLS approximation possesses the \"reproducing kernel\" property. If the basis $\\mathbf{p}(\\mathbf{x})$ includes all polynomial terms up to degree $k$, then the MLS approximation can exactly reproduce any polynomial field of degree up to $k$.\nLet the field to be approximated, $u(\\mathbf{x})$, be a polynomial from the span of the basis, i.e., $u(\\mathbf{x}) = \\mathbf{p}^T(\\mathbf{x})\\mathbf{c}$ for some constant coefficient vector $\\mathbf{c}$. The nodal values are $u_i = u(\\mathbf{x}_i) = \\mathbf{p}^T(\\mathbf{x}_i)\\mathbf{c}$.\nSubstituting these nodal values into the expression for $u^h(\\mathbf{x})$:\n$$\nu^h(\\mathbf{x}) = \\sum_{i=1}^{N} \\phi_i(\\mathbf{x}) u_i = \\sum_{i=1}^{N} \\phi_i(\\mathbf{x}) (\\mathbf{p}^T(\\mathbf{x}_i)\\mathbf{c})\n$$\nSubstituting the formula for $\\phi_i(\\mathbf{x})$:\n$$\nu^h(\\mathbf{x}) = \\sum_{i=1}^{N} \\left[ \\mathbf{p}^T(\\mathbf{x}) \\mathbf{M}^{-1}(\\mathbf{x}) \\mathbf{p}(\\mathbf{x}_i) w_i(\\mathbf{x}) \\right] (\\mathbf{p}^T(\\mathbf{x}_i)\\mathbf{c})\n$$\nSince $\\mathbf{c}$ is constant, we can pull it out of the summation:\n$$\nu^h(\\mathbf{x}) = \\mathbf{p}^T(\\mathbf{x}) \\mathbf{M}^{-1}(\\mathbf{x}) \\left( \\sum_{i=1}^{N} w_i(\\mathbf{x}) \\mathbf{p}(\\mathbf{x}_i)\\mathbf{p}^T(\\mathbf{x}_i) \\right) \\mathbf{c}\n$$\nThe term in the parenthesis is the definition of the moment matrix $\\mathbf{M}(\\mathbf{x})$. Therefore:\n$$\nu^h(\\mathbf{x}) = \\mathbf{p}^T(\\mathbf{x}) \\mathbf{M}^{-1}(\\mathbf{x}) \\mathbf{M}(\\mathbf{x}) \\mathbf{c} = \\mathbf{p}^T(\\mathbf{x}) \\mathbf{c} = u(\\mathbf{x})\n$$\nThis proves that $u^h(\\mathbf{x}) = u(\\mathbf{x})$ for any point $\\mathbf{x}$ where $\\mathbf{M}(\\mathbf{x})$ is invertible, provided $u(\\mathbf{x})$ is in the space spanned by the basis $\\mathbf{p}(\\mathbf{x})$.\n\n### 4. Numerical Implementation for Patch Tests\n\nThe algorithm to perform the numerical verification for each test case is as follows:\n1.  **Node Generation**: Generate a grid of $N_x \\times N_y = 11 \\times 11$ nodes in the domain $[0,1] \\times [0,1]$. The grid spacing is $h = 1 / (N_x - 1) = 1/10 = 0.1$.\n2.  **Test Case Setup**: For each test case ($\\mathbf{T1}$ to $\\mathbf{T5}$), set the basis degree, support factor $s$, the analytical displacement field $\\mathbf{u}(\\mathbf{x})$, and the set of evaluation points $\\mathcal{S}$. The support radius is $d = s \\cdot h$.\n3.  **Nodal Displacements**: Evaluate the analytical displacement field $\\mathbf{u}(\\mathbf{x})$ at each node $\\mathbf{x}_i$ to obtain the nodal values $\\mathbf{u}_i$.\n4.  **Error Calculation**:\n    a. Initialize maximum error $\\varepsilon_{\\max} = 0$.\n    b. For each evaluation point $\\mathbf{x} \\in \\mathcal{S}$:\n        i.   Identify all nodes $\\{\\mathbf{x}_i\\}$ within the support, i.e., for which $\\|\\mathbf{x} - \\mathbf{x}_i\\|_2 \\le d$.\n        ii.  Construct the moment matrix $\\mathbf{M}(\\mathbf{x})$ using the basis polynomials $\\mathbf{p}(\\mathbf{x}_i)$ and weights $w_i(\\mathbf{x})$ for the nodes in the support.\n        iii. If $\\mathbf{M}(\\mathbf{x})$ is invertible, compute its inverse $\\mathbf{M}^{-1}(\\mathbf{x})$.\n        iv.  Initialize the approximated displacement $\\mathbf{u}^h(\\mathbf{x}) = [0, 0]^T$.\n        v.   For each node $\\mathbf{x}_i$ in the support, compute its shape function value $\\phi_i(\\mathbf{x}) = \\mathbf{p}^T(\\mathbf{x}) \\mathbf{M}^{-1}(\\mathbf{x}) \\mathbf{p}(\\mathbf{x}_i) w_i(\\mathbf{x})$.\n        vi.  Accumulate the approximation: $\\mathbf{u}^h(\\mathbf{x}) += \\phi_i(\\mathbf{x}) \\mathbf{u}_i$.\n        vii. Calculate the analytical displacement $\\mathbf{u}(\\mathbf{x})$ at the evaluation point.\n        viii.Compute the error $\\varepsilon = \\|\\mathbf{u}^h(\\mathbf{x}) - \\mathbf{u}(\\mathbf{x})\\|_{\\infty} = \\max(|u_x^h - u_x|, |u_y^h - u_y|)$.\n        ix.  Update $\\varepsilon_{\\max} = \\max(\\varepsilon_{\\max}, \\varepsilon)$.\n5.  **Return Result**: The final $\\varepsilon_{\\max}$ is the result for the test case.\n\nThe test cases are designed to verify the reproduction property:\n-   **T1**: Degree $0$ basis on a constant field. Expected $\\varepsilon_{\\max} \\approx 0$.\n-   **T2**: Degree $0$ basis on a linear field. Not reproducible. Expected $\\varepsilon_{\\max} > 0$.\n-   **T3**: Degree $1$ basis on a linear field (rotation). Expected $\\varepsilon_{\\max} \\approx 0$.\n-   **T4**: Degree $1$ basis on a linear field (strain). Expected $\\varepsilon_{\\max} \\approx 0$.\n-   **T5**: Degree $1$ basis on a linear field, with minimal support near a boundary. This tests the robustness of the method. Expected $\\varepsilon_{\\max} \\approx 0$, possibly slightly larger than T3/T4 due to poorer conditioning of $\\mathbf{M}(\\mathbf{x})$.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and runs the Element-Free Galerkin (EFG) patch tests \n    using Moving Least Squares (MLS) approximation.\n    \"\"\"\n\n    # --- Problem Setup ---\n    Nx = 11\n    Ny = 11\n    h = 1.0 / (Nx - 1)\n    \n    # Generate node coordinates\n    x_coords = np.linspace(0.0, 1.0, Nx)\n    y_coords = np.linspace(0.0, 1.0, Ny)\n    nodes = np.array(np.meshgrid(x_coords, y_coords)).T.reshape(-1, 2)\n\n    # --- Weight Function ---\n    def weight_function(q):\n        \"\"\"\n        C1 continuous quartic spline weight function.\n        w(q) = 1 - 6q^2 + 8q^3 - 3q^4 for 0 <= q <= 1.\n        \"\"\"\n        if 0.0 <= q <= 1.0:\n            return 1.0 - 6.0*q**2 + 8.0*q**3 - 3.0*q**4\n        return 0.0\n\n    # --- MLS Core Logic ---\n    def compute_mls_error(nodes, basis_degree, support_factor, u_field_func, eval_points):\n        \"\"\"\n        Computes the maximum error of the MLS approximation for a given setup.\n        \"\"\"\n        s = support_factor\n        d = s * h\n        \n        # Get nodal values from the analytical field\n        u_nodal = np.array([u_field_func(node) for node in nodes])\n        \n        max_error = 0.0\n        \n        for x_eval in eval_points:\n            # Find nodes within the support domain of x_eval\n            support_nodes_indices = []\n            distances = []\n            for i, node in enumerate(nodes):\n                dist = np.linalg.norm(x_eval - node)\n                if dist <= d:\n                    support_nodes_indices.append(i)\n                    distances.append(dist)\n\n            if not support_nodes_indices:\n                # Should not happen with the given parameters\n                # If it does, the approximation is zero, error is the field value\n                u_true = u_field_func(x_eval)\n                error = np.max(np.abs(u_true))\n                max_error = max(max_error, error)\n                continue\n\n            # Basis setup\n            if basis_degree == 0:\n                m = 1\n                get_p = lambda x: np.array([1.0])\n            elif basis_degree == 1:\n                m = 3\n                get_p = lambda x: np.array([1.0, x[0], x[1]])\n            else:\n                raise ValueError(\"Unsupported basis degree\")\n\n            if len(support_nodes_indices) < m:\n                # Insufficient nodes for a stable approximation\n                # This indicates a potential issue, e.g., in T5\n                u_true = u_field_func(x_eval)\n                # Approximation is ill-defined, cannot compute error robustly.\n                # A robust implementation might switch to a lower order basis.\n                # Here we assume the error is large or skip. Let's compute best effort.\n                u_h = np.zeros(2) # Fallback\n                error = np.max(np.abs(u_h - u_true))\n                max_error = max(max_error, error)\n                continue\n\n            # Construct Moment Matrix M(x)\n            M = np.zeros((m, m))\n            support_nodes = nodes[support_nodes_indices]\n            \n            w_vals = [weight_function(dist / d) for dist in distances]\n\n            for i in range(len(support_nodes)):\n                node = support_nodes[i]\n                p_i = get_p(node)\n                w_i = w_vals[i]\n                M += w_i * np.outer(p_i, p_i)\n\n            # Invert Moment Matrix\n            try:\n                M_inv = np.linalg.inv(M)\n            except np.linalg.LinAlgError:\n                # Singular matrix, approximation fails\n                u_true = u_field_func(x_eval)\n                u_h = np.zeros(2) # Fallback\n                error = np.max(np.abs(u_h - u_true))\n                max_error = max(max_error, error)\n                continue\n\n            # Calculate shape functions and approximated field u_h(x)\n            p_eval = get_p(x_eval)\n            u_h = np.zeros(2)\n            \n            for i in range(len(support_nodes)):\n                node_idx = support_nodes_indices[i]\n                node = support_nodes[i]\n                p_i = get_p(node)\n                w_i = w_vals[i]\n                \n                # Shape function value phi_i(x_eval)\n                phi_i = p_eval.T @ M_inv @ p_i * w_i\n                \n                u_h += phi_i * u_nodal[node_idx]\n\n            # Calculate error at the evaluation point\n            u_true = u_field_func(x_eval)\n            error = np.max(np.abs(u_h - u_true))\n            max_error = max(max_error, error)\n            \n        return max_error\n\n    # --- Test Cases Definition ---\n    eval_grid_coords = [0.1, 0.3, 0.5, 0.7, 0.9]\n    eval_set_T1_T4 = np.array(np.meshgrid(eval_grid_coords, eval_grid_coords)).T.reshape(-1, 2)\n    \n    # T1: Rigid Translation\n    c = np.array([0.3, -0.2])\n    u_trans = lambda x: c\n\n    # T2/T3: Rigid Rotation\n    theta = 0.1\n    u_rot = lambda x: theta * np.array([-x[1], x[0]])\n\n    # T4/T5: Uniform Strain\n    E = np.array([[0.01, 0.02], [0.00, -0.005]])\n    u_strain = lambda x: E @ x\n\n    test_cases = [\n        {'name': 'T1', 'basis_degree': 0, 'support_factor': 2.5, 'u_field_func': u_trans, 'eval_points': eval_set_T1_T4},\n        {'name': 'T2', 'basis_degree': 0, 'support_factor': 2.5, 'u_field_func': u_rot, 'eval_points': eval_set_T1_T4},\n        {'name': 'T3', 'basis_degree': 1, 'support_factor': 2.5, 'u_field_func': u_rot, 'eval_points': eval_set_T1_T4},\n        {'name': 'T4', 'basis_degree': 1, 'support_factor': 2.5, 'u_field_func': u_strain, 'eval_points': eval_set_T1_T4},\n        {'name': 'T5', 'basis_degree': 1, 'support_factor': 1.05, 'u_field_func': u_strain, 'eval_points': np.array([[0.02, 0.02]])},\n    ]\n\n    results = []\n    for case in test_cases:\n        error = compute_mls_error(nodes, case['basis_degree'], case['support_factor'], case['u_field_func'], case['eval_points'])\n        results.append(error)\n\n    # --- Final Output ---\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The ultimate test of a numerical method is its performance in solving a boundary value problem and its ability to converge to the exact solution at the theoretically predicted rate. This comprehensive practice guides you through building a complete meshfree Galerkin solver for a 2D anti-plane shear problem, from assembling the global stiffness matrix to computing error norms . By systematically refining the particle discretization, you will compute the observed convergence rates for both the $L^2$-norm and $H^1$-seminorm of the error. This verification study allows you to confirm that your implementation correctly captures the expected $O(h^2)$ and $O(h)$ convergence behavior, solidifying your understanding of the method's accuracy and reliability.",
            "id": "3581216",
            "problem": "Consider the anti-plane shear model problem from computational solid mechanics on the unit square domain $\\Omega = [0,1]^2$. Let the out-of-plane displacement field be $u(x,y)$, governed by the weak form of the linear elliptic problem derived from static equilibrium with constant shear modulus $\\mu = 1$: find $u \\in H^1(\\Omega)$ such that for all test functions $v \\in H_0^1(\\Omega)$,\n$$\n\\int_{\\Omega} \\nabla u \\cdot \\nabla v \\, d\\Omega = \\int_{\\Omega} f \\, v \\, d\\Omega,\n$$\nsubject to the essential boundary condition $u = u_{\\text{exact}}$ on $\\partial \\Omega$. Use the Method of Manufactured Solutions with\n$$\nu_{\\text{exact}}(x,y) = \\sin(\\pi x)\\sin(\\pi y), \\quad f(x,y) = -\\Delta u_{\\text{exact}}(x,y) = 2\\pi^2 \\sin(\\pi x)\\sin(\\pi y).\n$$\nDiscretize this problem using a meshfree Galerkin method with reproducing kernel particle method (RKPM) shape functions that achieve linear polynomial reproduction. Use a radially symmetric, compactly supported weight function $w(q)$ with support radius $h_s$, where $q = r/h_s$ and $r = \\|\\boldsymbol{x} - \\boldsymbol{x}_i\\|$ for a particle located at $\\boldsymbol{x}_i$. Let the weight be the $C^2$ quartic spline\n$$\nw(q) = \\begin{cases}\n(1-q)^4(1+4q), & 0 \\le q < 1,\\\\\n0, & q \\ge 1,\n\\end{cases}\n$$\nwith derivative\n$$\n\\frac{dw}{dq} = -20\\,q\\,(1-q)^3 \\quad \\text{for } 0 \\le q < 1.\n$$\nConstruct the RKPM shape functions with a linear polynomial basis $p(\\boldsymbol{x}) = [1, x, y]^T$. At any quadrature point $\\boldsymbol{x}$, define the moment matrix\n$$\nM(\\boldsymbol{x}) = \\sum_{i} w\\left(\\frac{\\|\\boldsymbol{x} - \\boldsymbol{x}_i\\|}{h_s}\\right) \\, p(\\boldsymbol{x}_i)\\, p(\\boldsymbol{x}_i)^T,\n$$\nand the corrected shape functions\n$$\nN_i(\\boldsymbol{x}) = p(\\boldsymbol{x})^T\\, M(\\boldsymbol{x})^{-1}\\, p(\\boldsymbol{x}_i)\\, w\\left(\\frac{\\|\\boldsymbol{x} - \\boldsymbol{x}_i\\|}{h_s}\\right),\n$$\ntogether with their spatial gradients $\\nabla N_i(\\boldsymbol{x})$ computed by differentiating the above expression, including the derivatives of the moment matrix $M(\\boldsymbol{x})$.\n\nAssemble the symmetric positive definite stiffness matrix and load vector using background Gaussian quadrature on a structured background grid of bilinear cells covering $\\Omega$. Enforce essential boundary conditions strongly by direct modification of the linear system (row and column replacement by an identity row and the load set to the exact boundary value). Solve the discrete system to obtain the nodal vector of unknowns, and evaluate the following error measures using numerical quadrature over the background cells:\n$$\n\\|e\\|_{L^2(\\Omega)} = \\left( \\int_{\\Omega} \\left(u_h - u_{\\text{exact}}\\right)^2 \\, d\\Omega \\right)^{1/2}, \\qquad\n|e|_{H^1(\\Omega)} = \\left( \\int_{\\Omega} \\|\\nabla u_h - \\nabla u_{\\text{exact}}\\|^2 \\, d\\Omega \\right)^{1/2}.\n$$\n\nUse a quasi-uniform distribution of particles placed on a Cartesian lattice including the boundary. Let the background integration mesh coincide with the particle grid cells. For particle spacing $h = 1/(n-1)$ with $n$ particles per coordinate direction, set the support radius as $h_s = \\alpha h$ with $\\alpha = 2.5$. Use tensor-product Gauss quadrature with $2 \\times 2$ points per cell. For neighborhood queries, use an efficient search to include all particles within the support radius.\n\nThe theoretical expectation for RKPM with linear polynomial reproduction for this elliptic problem is that the $L^2$-norm error scales as $O(h^2)$ and the $H^1$-seminorm error scales as $O(h)$, provided sufficient smoothness and stable integration.\n\nYour task is to implement the above and perform a numerical verification study. Use the following test suite of particle resolutions:\n- Case A: $n = 9$,\n- Case B: $n = 17$,\n- Case C: $n = 33$.\n\nFor each consecutive pair $(A,B)$ and $(B,C)$, compute the observed convergence rates\n$$\nr_{L^2} = \\frac{\\log\\left(\\|e\\|_{L^2,h_1} / \\|e\\|_{L^2,h_2}\\right)}{\\log\\left(h_1/h_2\\right)}, \\qquad\nr_{H^1} = \\frac{\\log\\left(|e|_{H^1,h_1} / |e|_{H^1,h_2}\\right)}{\\log\\left(h_1/h_2\\right)},\n$$\nwhere $h_1$ and $h_2$ are the particle spacings for the coarse and fine resolutions, respectively. Report the four rates for $(A,B)$ and $(B,C)$. Additionally, report two boolean indicators stating whether both observed $L^2$ rates are at least $1.7$ and whether both observed $H^1$ rates are at least $0.85$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the following order:\n- $r_{L^2}^{A\\to B}$,\n- $r_{H^1}^{A\\to B}$,\n- $r_{L^2}^{B\\to C}$,\n- $r_{H^1}^{B\\to C}$,\n- boolean for $L^2$ verification,\n- boolean for $H^1$ verification.\n\nAll floating-point results must be rounded to three decimal places in the final output. No user input is required; all constants and parameters are fixed as stated above. The output must be exactly one line in the format, for example, $[1.950,0.990,1.980,1.010,True,True]$.",
            "solution": "The user-provided problem is a well-posed verification task for a meshfree Galerkin method. It is scientifically grounded, self-contained, and algorithmically detailed. Therefore, it is deemed valid. We proceed with the solution.\n\nThe problem requires the numerical solution of an anti-plane shear problem, which models the out-of-plane displacement $u(x,y)$ on a unit square domain $\\Omega = [0,1]^2$. The governing physics is described by a linear elliptic partial differential equation, specifically a Poisson equation with a given source term. The problem is cast in its weak form, a standard starting point for finite element and meshfree Galerkin methods.\n\nThe weak form is stated as: find $u \\in H^1(\\Omega)$ satisfying the essential boundary conditions such that for all test functions $v \\in H_0^1(\\Omega)$:\n$$\n\\int_{\\Omega} \\nabla u \\cdot \\nabla v \\, d\\Omega = \\int_{\\Omega} f \\, v \\, d\\Omega\n$$\nHere, the shear modulus is $\\mu=1$, and the source term $f(x,y)$ is derived from a chosen exact solution $u_{\\text{exact}}(x,y) = \\sin(\\pi x)\\sin(\\pi y)$ using the Method of Manufactured Solutions. This method ensures that a known solution exists, allowing for the precise quantification of numerical error. The source term is $f = -\\Delta u_{\\text{exact}} = 2\\pi^2 \\sin(\\pi x)\\sin(\\pi y)$. Essential boundary conditions are imposed strongly by setting $u = u_{\\text{exact}}$ on the boundary $\\partial \\Omega$.\n\nThe domain is discretized by a set of particles (nodes), and the displacement field $u(x,y)$ is approximated by a function $u_h(x,y)$:\n$$\nu(\\boldsymbol{x}) \\approx u_h(\\boldsymbol{x}) = \\sum_{i=1}^{N} d_i N_i(\\boldsymbol{x})\n$$\nwhere $N$ is the total number of particles, $d_i$ are the unknown nodal displacement coefficients, and $N_i(\\boldsymbol{x})$ are the meshfree shape functions associated with particle $i$. The problem specifies the use of the Reproducing Kernel Particle Method (RKPM) to construct these shape functions.\n\nTo ensure linear polynomial reproduction, i.e., the ability of the basis to exactly represent any linear function, a linear polynomial basis $\\boldsymbol{p}(\\boldsymbol{x}) = [1, x, y]^T$ is used. The RKPM shape function for particle $i$ at a point $\\boldsymbol{x}$ is given by:\n$$\nN_i(\\boldsymbol{x}) = C(\\boldsymbol{x};\\boldsymbol{x}-\\boldsymbol{x}_i) w\\left(\\frac{\\|\\boldsymbol{x} - \\boldsymbol{x}_i\\|}{h_s}\\right) = \\boldsymbol{p}(\\boldsymbol{x})^T \\boldsymbol{M}(\\boldsymbol{x})^{-1} \\boldsymbol{p}(\\boldsymbol{x}_i) w_i(\\boldsymbol{x})\n$$\nwhere $w_i(\\boldsymbol{x}) = w(\\|\\boldsymbol{x} - \\boldsymbol{x}_i\\|/h_s)$ is the specified $C^2$ quartic spline weight function with compact support radius $h_s$. The matrix $\\boldsymbol{M}(\\boldsymbol{x})$ is the moment matrix, defined as:\n$$\n\\boldsymbol{M}(\\boldsymbol{x}) = \\sum_{j=1}^{N} w_j(\\boldsymbol{x}) \\boldsymbol{p}(\\boldsymbol{x}_j) \\boldsymbol{p}(\\boldsymbol{x}_j)^T\n$$\nThe sum is taken over all particles $j$ whose support contains the point $\\boldsymbol{x}$.\n\nSubstituting the approximation $u_h$ into the weak form and choosing the test functions to be the shape functions themselves ($v = N_i$), we obtain the discrete system of linear equations $\\boldsymbol{K}\\boldsymbol{d} = \\boldsymbol{F}$, where:\n- The stiffness matrix $\\boldsymbol{K}$ has entries $K_{ij} = \\int_{\\Omega} \\nabla N_i(\\boldsymbol{x}) \\cdot \\nabla N_j(\\boldsymbol{x}) \\, d\\Omega$.\n- The force vector $\\boldsymbol{F}$ has entries $F_i = \\int_{\\Omega} f(\\boldsymbol{x}) N_i(\\boldsymbol{x}) \\, d\\Omega$.\n- The vector $\\boldsymbol{d}$ contains the unknown nodal coefficients $d_i$.\n\nThe spatial gradients of the shape functions, $\\nabla N_i(\\boldsymbol{x})$, are required for the stiffness matrix. They are derived by applying the product rule to the expression for $N_i(\\boldsymbol{x})$. Differentiating with respect to a spatial coordinate $x_k$ gives:\n$$\n\\frac{\\partial N_i}{\\partial x_k} = \\left(\\frac{\\partial \\boldsymbol{p}^T}{\\partial x_k}\\right) \\boldsymbol{M}^{-1} \\boldsymbol{p}_i w_i + \\boldsymbol{p}^T \\left(\\frac{\\partial \\boldsymbol{M}^{-1}}{\\partial x_k}\\right) \\boldsymbol{p}_i w_i + \\boldsymbol{p}^T \\boldsymbol{M}^{-1} \\boldsymbol{p}_i \\left(\\frac{\\partial w_i}{\\partial x_k}\\right)\n$$\nThis expression involves the derivative of the inverse of the moment matrix, $\\partial \\boldsymbol{M}^{-1}/\\partial x_k = -\\boldsymbol{M}^{-1} (\\partial \\boldsymbol{M}/\\partial x_k) \\boldsymbol{M}^{-1}$, which in turn requires the derivative of the moment matrix, $\\partial \\boldsymbol{M}/\\partial x_k$. This relies on the chain rule and the provided derivative of the weight function, $dw/dq$.\n\nThe integrals for $\\boldsymbol{K}$ and $\\boldsymbol{F}$ are computed numerically using a background mesh of bilinear cells, which coincides with the cells formed by the particle grid. A $2 \\times 2$ Gaussian quadrature scheme is used within each cell.\n\nEssential boundary conditions $u=u_{\\text{exact}}$ on $\\partial\\Omega$ are enforced strongly. The problem states \"direct modification of the linear system (row and column replacement by an identity row and the load set to the exact boundary value)\". A robust and standard implementation of this, known as the \"lifting\" method, is employed. For each boundary node $I$, its known value $u_I = u_{\\text{exact}}(\\boldsymbol{x}_I)$ is used to modify the force vector for all interior nodes $J$: $F_J \\leftarrow F_J - K_{JI} u_I$. Subsequently, the rows and columns of $\\boldsymbol{K}$ corresponding to boundary nodes are zeroed out, the diagonal entries are set to $1$, and the corresponding entries in $\\boldsymbol{F}$ are set to the known boundary values $u_I$. This procedure correctly enforces the boundary conditions while maintaining a solvable system.\n\nAfter solving the system $\\boldsymbol{K}\\boldsymbol{d} = \\boldsymbol{F}$ for the coefficient vector $\\boldsymbol{d}$, the numerical solution $u_h$ is known. The error is quantified by numerically integrating the squared differences between the numerical and exact solutions and their gradients over the domain, yielding the $L^2$-norm error $\\|e\\|_{L^2}$ and the $H^1$-seminorm error $|e|_{H^1}$.\n\nA convergence study is performed with particle resolutions $n=9, 17, 33$. The corresponding particle spacings are $h_1=1/8$, $h_2=1/16$, and $h_3=1/32$. The ratio of consecutive spacings is $h_k/h_{k+1}=2$. The observed convergence rate for an error measure $E$ is calculated as $r = \\log(E_1 / E_2) / \\log(h_1 / h_2)$. For our case, this simplifies to $r = \\log_2(E_1/E_2)$. The theoretical rates for linear reproduction are $O(h^2)$ for the $L^2$ error and $O(h)$ for the $H^1$ error. The numerical study verifies if the implementation achieves rates close to these theoretical values, subject to the specified thresholds of $1.7$ and $0.85$, respectively.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import lil_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Implements the RKPM meshfree method for a 2D anti-plane shear problem\n    and performs a numerical verification study.\n    \"\"\"\n    \n    # Test cases defined in the problem statement\n    test_cases = [9, 17, 33]\n\n    # --------------- Helper Functions ---------------\n\n    pi = np.pi\n\n    def u_exact(x, y):\n        return np.sin(pi * x) * np.sin(pi * y)\n\n    def grad_u_exact(x, y):\n        return np.array([\n            pi * np.cos(pi * x) * np.sin(pi * y),\n            pi * np.sin(pi * x) * np.cos(pi * y)\n        ])\n\n    def f_source(x, y):\n        return 2.0 * pi**2 * np.sin(pi * x) * np.sin(pi * y)\n\n    def weight_func(q):\n        val = np.zeros_like(q)\n        mask = (q >= 0)  (q  1)\n        q_masked = q[mask]\n        val[mask] = (1.0 - q_masked)**4 * (1.0 + 4.0 * q_masked)\n        return val\n\n    def d_weight_func_dq(q):\n        val = np.zeros_like(q)\n        mask = (q >= 0)  (q  1)\n        q_masked = q[mask]\n        val[mask] = -20.0 * q_masked * (1.0 - q_masked)**3\n        return val\n\n    # --------------- Main Calculation Loop ---------------\n    \n    errors_all_cases = []\n    \n    for n in test_cases:\n        # --- Setup for the current resolution ---\n        h = 1.0 / (n - 1)\n        alpha = 2.5\n        hs = alpha * h\n        num_nodes = n * n\n        \n        # Particle generation (row-major order)\n        x_coords = np.linspace(0.0, 1.0, n)\n        y_coords = np.linspace(0.0, 1.0, n)\n        X, Y = np.meshgrid(x_coords, y_coords, indexing='ij')\n        particles = np.stack([X.ravel(), Y.ravel()], axis=-1)\n\n        # Integration setup (2x2 Gauss quadrature)\n        gp_loc = 1.0 / np.sqrt(3.0)\n        gauss_points_parent = [(-gp_loc, -gp_loc), (gp_loc, -gp_loc), (-gp_loc, gp_loc), (gp_loc, gp_loc)]\n        gauss_weights_parent = [1.0, 1.0, 1.0, 1.0]\n        \n        # Initialize sparse stiffness matrix and load vector\n        K = lil_matrix((num_nodes, num_nodes))\n        F = np.zeros(num_nodes)\n\n        # --- Assembly Loop ---\n        num_cells_per_dim = n - 1\n        cell_size = h\n        \n        for i_cell in range(num_cells_per_dim):\n            for j_cell in range(num_cells_per_dim):\n                x0 = i_cell * cell_size\n                y0 = j_cell * cell_size\n                \n                for gp_idx, (gp_xi, gp_eta) in enumerate(gauss_points_parent):\n                    xq = np.array([\n                        x0 + (gp_xi + 1.0) * cell_size / 2.0,\n                        y0 + (gp_eta + 1.0) * cell_size / 2.0\n                    ])\n                    w_q = gauss_weights_parent[gp_idx] * (cell_size / 2.0)**2\n\n                    # --- RKPM Shape Function Evaluation at Quadrature Point xq ---\n                    dists_vec = xq - particles\n                    dists = np.linalg.norm(dists_vec, axis=1)\n                    neighbor_indices = np.where(dists  hs)[0]\n\n                    if len(neighbor_indices)  3:\n                        continue\n                        \n                    q_vals = dists[neighbor_indices] / hs\n                    w_vals = weight_func(q_vals)\n                    dw_dq_vals = d_weight_func_dq(q_vals)\n                    \n                    p_xq = np.array([1.0, xq[0], xq[1]])\n                    \n                    M = np.zeros((3, 3))\n                    dM_dx = np.zeros((3, 3))\n                    dM_dy = np.zeros((3, 3))\n                    \n                    for k_idx, node_idx in enumerate(neighbor_indices):\n                        p_i = np.array([1.0, particles[node_idx, 0], particles[node_idx, 1]])\n                        p_i_outer = np.outer(p_i, p_i)\n                        M += w_vals[k_idx] * p_i_outer\n                        \n                        r_i = dists[node_idx]\n                        if r_i > 1e-12:\n                            grad_term = dw_dq_vals[k_idx] / (hs * r_i)\n                            dw_dx_i = grad_term * dists_vec[node_idx, 0]\n                            dw_dy_i = grad_term * dists_vec[node_idx, 1]\n                        else:\n                            dw_dx_i = dw_dy_i = 0.0\n                        \n                        dM_dx += dw_dx_i * p_i_outer\n                        dM_dy += dw_dy_i * p_i_outer\n\n                    try:\n                        M_inv = np.linalg.inv(M)\n                    except np.linalg.LinAlgError:\n                        continue\n                    \n                    dM_inv_dx = -M_inv @ dM_dx @ M_inv\n                    dM_inv_dy = -M_inv @ dM_dy @ M_inv\n                    \n                    dp_dx = np.array([0.0, 1.0, 0.0])\n                    dp_dy = np.array([0.0, 0.0, 1.0])\n                    \n                    shape_funcs = []\n                    shape_func_grads = []\n                    \n                    for k_idx, node_idx in enumerate(neighbor_indices):\n                        p_i = np.array([1.0, particles[node_idx, 0], particles[node_idx, 1]])\n                        w_i_val = w_vals[k_idx]\n                        \n                        r_i = dists[node_idx]\n                        if r_i > 1e-12:\n                            grad_term = dw_dq_vals[k_idx] / (hs * r_i)\n                            dw_dx_i = grad_term * dists_vec[node_idx, 0]\n                            dw_dy_i = grad_term * dists_vec[node_idx, 1]\n                        else:\n                            dw_dx_i = dw_dy_i = 0.0\n                        \n                        c_vec = M_inv @ p_i\n                        \n                        N_val = (p_xq.T @ c_vec) * w_i_val\n                        \n                        dN_dx = (dp_dx.T @ c_vec) * w_i_val \\\n                                + (p_xq.T @ (dM_inv_dx @ p_i)) * w_i_val \\\n                                + (p_xq.T @ c_vec) * dw_dx_i\n                                \n                        dN_dy = (dp_dy.T @ c_vec) * w_i_val \\\n                                + (p_xq.T @ (dM_inv_dy @ p_i)) * w_i_val \\\n                                + (p_xq.T @ c_vec) * dw_dy_i\n                        \n                        shape_funcs.append(N_val)\n                        shape_func_grads.append(np.array([dN_dx, dN_dy]))\n\n                    # --- Add contributions to K and F ---\n                    f_val = f_source(xq[0], xq[1])\n                    for k_outer, idx_outer in enumerate(neighbor_indices):\n                        F[idx_outer] += shape_funcs[k_outer] * f_val * w_q\n                        for k_inner, idx_inner in enumerate(neighbor_indices):\n                            grad_dot = np.dot(shape_func_grads[k_outer], shape_func_grads[k_inner])\n                            K[idx_outer, idx_inner] += grad_dot * w_q\n\n        # --- Boundary Conditions (Lifting Method) ---\n        boundary_nodes = [i for i in range(num_nodes) if np.isclose(particles[i,0], 0.0) or np.isclose(particles[i,0], 1.0) or np.isclose(particles[i,1], 0.0) or np.isclose(particles[i,1], 1.0)]\n        interior_nodes = list(set(range(num_nodes)) - set(boundary_nodes))\n        \n        K_csr = K.tocsr()\n        for i in interior_nodes:\n            for j in boundary_nodes:\n                u_bc = u_exact(particles[j, 0], particles[j, 1])\n                F[i] -= K_csr[i, j] * u_bc\n\n        for i in boundary_nodes:\n            K[i, :] = 0\n            K[:, i] = 0\n            K[i, i] = 1.0\n            F[i] = u_exact(particles[i, 0], particles[i, 1])\n\n        # --- Solve Linear System ---\n        d = spsolve(K.tocsr(), F)\n        \n        # --- Error Calculation ---\n        l2_error_sq = 0.0\n        h1_error_sq = 0.0\n        # Re-use integration loop for error calculation\n        for i_cell in range(num_cells_per_dim):\n             for j_cell in range(num_cells_per_dim):\n                x0, y0 = i_cell * cell_size, j_cell * cell_size\n                for gp_idx, (gp_xi, gp_eta) in enumerate(gauss_points_parent):\n                    xq = np.array([x0 + (gp_xi + 1.0) * cell_size / 2.0, y0 + (gp_eta + 1.0) * cell_size / 2.0])\n                    w_q = gauss_weights_parent[gp_idx] * (cell_size / 2.0)**2\n\n                    # Minimal recalculation just for the needed values\n                    dists_vec = xq - particles\n                    dists = np.linalg.norm(dists_vec, axis=1)\n                    neighbor_indices = np.where(dists  hs)[0]\n                    if len(neighbor_indices)  3: continue\n                    \n                    # This section is a repeat of the shape function logic from assembly\n                    u_h = 0.0\n                    grad_u_h = np.zeros(2)\n                    \n                    q_vals = dists[neighbor_indices] / hs\n                    w_vals = weight_func(q_vals)\n                    dw_dq_vals = d_weight_func_dq(q_vals)\n                    p_xq = np.array([1.0, xq[0], xq[1]])\n                    M = np.zeros((3, 3)); dM_dx = np.zeros((3, 3)); dM_dy = np.zeros((3, 3))\n                    for k_idx, node_idx in enumerate(neighbor_indices):\n                        p_i = np.array([1.0, particles[node_idx, 0], particles[node_idx, 1]])\n                        M += w_vals[k_idx] * np.outer(p_i, p_i)\n                        r_i = dists[node_idx]\n                        if r_i > 1e-12:\n                            grad_term = dw_dq_vals[k_idx] / (hs * r_i)\n                            dM_dx += (grad_term * dists_vec[node_idx, 0]) * np.outer(p_i, p_i)\n                            dM_dy += (grad_term * dists_vec[node_idx, 1]) * np.outer(p_i, p_i)\n                    try: M_inv = np.linalg.inv(M)\n                    except np.linalg.LinAlgError: continue\n                    dM_inv_dx = -M_inv @ dM_dx @ M_inv; dM_inv_dy = -M_inv @ dM_dy @ M_inv\n                    dp_dx = np.array([0., 1., 0.]); dp_dy = np.array([0., 0., 1.])\n                    \n                    for k_idx, node_idx in enumerate(neighbor_indices):\n                      p_i = np.array([1.0, particles[node_idx, 0], particles[node_idx, 1]])\n                      w_i_val = w_vals[k_idx]\n                      r_i = dists[node_idx]\n                      if r_i > 1e-12:\n                          grad_term = dw_dq_vals[k_idx] / (hs * r_i); dw_dx_i = grad_term * dists_vec[node_idx, 0]; dw_dy_i = grad_term * dists_vec[node_idx, 1]\n                      else: dw_dx_i = dw_dy_i = 0.0\n                      c_vec = M_inv @ p_i\n                      N_val = (p_xq.T @ c_vec) * w_i_val\n                      dN_dx = (dp_dx.T @ c_vec) * w_i_val + (p_xq.T @ (dM_inv_dx @ p_i)) * w_i_val + (p_xq.T @ c_vec) * dw_dx_i\n                      dN_dy = (dp_dy.T @ c_vec) * w_i_val + (p_xq.T @ (dM_inv_dy @ p_i)) * w_i_val + (p_xq.T @ c_vec) * dw_dy_i\n                      u_h += d[node_idx] * N_val\n                      grad_u_h += d[node_idx] * np.array([dN_dx, dN_dy])\n\n                    # Add squared error contributions\n                    l2_error_sq += (u_h - u_exact(xq[0], xq[1]))**2 * w_q\n                    h1_error_sq += np.sum((grad_u_h - grad_u_exact(xq[0], xq[1]))**2) * w_q\n        \n        errors_all_cases.append((np.sqrt(l2_error_sq), np.sqrt(h1_error_sq)))\n\n    # --- Post-processing: Convergence Rates  Verification ---\n    e_L2_A, e_H1_A = errors_all_cases[0]\n    e_L2_B, e_H1_B = errors_all_cases[1]\n    e_L2_C, e_H1_C = errors_all_cases[2]\n\n    h_A = 1.0 / (test_cases[0] - 1)\n    h_B = 1.0 / (test_cases[1] - 1)\n    h_C = 1.0 / (test_cases[2] - 1)\n\n    r_L2_AB = np.log(e_L2_A / e_L2_B) / np.log(h_A / h_B)\n    r_H1_AB = np.log(e_H1_A / e_H1_B) / np.log(h_A / h_B)\n\n    r_L2_BC = np.log(e_L2_B / e_L2_C) / np.log(h_B / h_C)\n    r_H1_BC = np.log(e_H1_B / e_H1_C) / np.log(h_B / h_C)\n    \n    bool_L2 = r_L2_AB >= 1.7 and r_L2_BC >= 1.7\n    bool_H1 = r_H1_AB >= 0.85 and r_H1_BC >= 0.85\n    \n    # --- Final Output Formatting ---\n    results_str = [\n        f\"{r_L2_AB:.3f}\",\n        f\"{r_H1_AB:.3f}\",\n        f\"{r_L2_BC:.3f}\",\n        f\"{r_H1_BC:.3f}\",\n        str(bool_L2),\n        str(bool_H1)\n    ]\n    \n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```"
        }
    ]
}