{
    "hands_on_practices": [
        {
            "introduction": "理解无网格近似的最好方法之一是从头开始构建它。本练习将引导您在一个简单的一维环境中，通过解析推导移动最小二乘（MLS）形函数。这个过程将阐明基函数、权函数和矩量矩阵各自扮演的角色，并揭示无网格方法的关键特性，如光滑性和不具备克罗内克-德尔塔性质，这些特性使其与传统的有限元方法区别开来。",
            "id": "3581248",
            "problem": "考虑一个通过移动最小二乘（MLS）法构建的一维无网格伽辽金近似，该方法是再生核粒子法（RKPM）的一种标准实现。设试探空间由二次多项式基 $p(x) = [\\,1,\\; x,\\; x^{2}\\,]^{\\mathsf{T}}$ 生成。假设在实线上有一组节点集，其位置为 $x_{i} \\in \\{-2,\\,-1,\\,0,\\,1,\\,2\\}$，对应的节点参数（伪值）为 $u_{i}$。在点 $x$ 处的MLS近似形式为 $u^{h}(x) = p^{\\mathsf{T}}(x)\\,a(x)$，其中 $a(x)$ 是通过最小化由高斯权函数构建的加权最小二乘泛函来确定的。具体来说，使用高斯权函数\n$$\nw_{i}(x) \\;=\\; \\exp\\!\\Big(-\\,\\frac{(x - x_{i})^{2}}{2}\\Big),\n$$\n它们是关于 $x$ 的 $C^{\\infty}$ 函数。从最小二乘最小化及其正规方程出发，推导MLS形函数 $N_{i}(x)$（使得 $u^{h}(x) = \\sum_{i} N_{i}(x)\\,u_{i}$）及其在一维空间中的梯度 $\\partial_{x} N_{i}(x)$。然后，仅使用给定的节点集、基和权函数：\n\n1) 通过显式构造矩量矩阵 $A(x)$、求其逆，并在 $x=0$ 处计算 $N_{i}(x) = p^{\\mathsf{T}}(x)\\,A^{-1}(x)\\,w_{i}(x)\\,p(x_{i})$，来求出在 $x=0$ 邻域内MLS形函数 $N_{i}(x)$ 的精确闭式表达式。\n\n2) 通过对MLS形函数关于 $x$ 求导，并仔细考虑权函数和逆矩量矩阵对 $x$ 的依赖性，计算在 $x=0$ 处梯度 $\\partial_{x} N_{i}(x)$ 的精确表达式。\n\n3) 使用第1)和2)项中得到的公式，验证：\n- 光滑性：从第一性原理出发，论证为什么函数 $N_{i}(x)$ 和 $\\partial_{x}N_{i}(x)$ 在 $x=0$ 处是连续的（实际上是 $C^{\\infty}$ 的）。\n- 节点上不具备克罗内克(Kronecker)δ性质：明确证明 $N_{0}(0) \\neq 1$ 且对于至少一个 $j \\neq 0$ 有 $N_{j}(0) \\neq 0$。\n\n对于最终答案，只报告在中心节点处计算的中心节点MLS形函数 $N_{0}(0)$ 的精确闭式解析表达式（用 $\\exp(\\cdot)$ 表示）。不要提供数值近似。将最终答案表示为仅含 $\\exp(-\\tfrac{1}{2})$ 和 $\\exp(-2)$ 的单个简化表达式。无需单位。",
            "solution": "该问题是适定的，有科学依据，并包含了推导唯一解所需的所有信息。我们开始求解。\n\n函数 $u(x)$ 的移动最小二乘（MLS）近似 $u^{h}(x)$ 是通过寻找最佳局部多项式拟合来构造的。在任意点 $x$ 处，我们寻求一个系数向量 $a(x)$，它能够最小化多项式近似与节点值 $u_i = u(x_i)$ 之间误差的加权离散 $L_2$ 范数。待最小化的泛函是：\n$$\nJ(a(x)) = \\sum_{i} w_{i}(x) \\left( p^{\\mathsf{T}}(x_i) a(x) - u_i \\right)^2\n$$\n其中 $p(x) = [\\,1,\\; x,\\; x^2\\,]^{\\mathsf{T}}$ 是二次多项式基，$x_i \\in \\{-2, -1, 0, 1, 2\\}$ 是节点集，$w_{i}(x) = \\exp(-\\frac{(x - x_i)^2}{2})$ 是高斯权函数。\n\n通过将 $J$ 关于 $a(x)$ 的梯度设为零（$\\nabla_a J(a(x)) = 0$）来找到最小值。这导出了正规方程：\n$$\n\\left( \\sum_{i} w_{i}(x) p(x_i) p^{\\mathsf{T}}(x_i) \\right) a(x) = \\sum_{i} w_{i}(x) p(x_i) u_i\n$$\n括号中的矩阵是矩量矩阵，$A(x) = \\sum_{i} w_{i}(x) p(x_i) p^{\\mathsf{T}}(x_i)$。因此，正规方程为 $A(x) a(x) = B(x) u$，其中 $B(x)$ 是一个矩阵，其第 $i$ 列是 $w_{i}(x)p(x_i)$，$u$ 是节点值 $u_i$ 的向量。\n求解 $a(x)$ 得到 $a(x) = A^{-1}(x) \\sum_{i} w_{i}(x) p(x_i) u_i$。\nMLS近似则为 $u^{h}(x) = p^{\\mathsf{T}}(x) a(x)$。代入 $a(x)$ 的表达式：\n$$\nu^{h}(x) = p^{\\mathsf{T}}(x) A^{-1}(x) \\sum_{i} w_{i}(x) p(x_i) u_i = \\sum_{i} \\left( p^{\\mathsf{T}}(x) A^{-1}(x) w_{i}(x) p(x_i) \\right) u_i\n$$\n根据定义，$u^{h}(x) = \\sum_{i} N_i(x) u_i$，因此节点 $i$ 的MLS形函数为：\n$$\nN_i(x) = p^{\\mathsf{T}}(x) A^{-1}(x) w_{i}(x) p(x_i)\n$$\n\n### 第1部分：$N_i(0)$ 的计算\n\n我们需要在 $x=0$ 处计算形函数。这需要计算矩量矩阵 $A(0)$ 及其逆。\n节点为 $x_i \\in \\{-2, -1, 0, 1, 2\\}$。我们将其记为 $x_{-2}, x_{-1}, x_0, x_1, x_2$。\n在 $x=0$ 处的权函数值为 $w_i(0) = \\exp(-\\frac{x_i^2}{2})$。\n$w_0(0) = \\exp(0) = 1$。\n$w_1(0) = w_{-1}(0) = \\exp(-\\frac{1^2}{2}) = \\exp(-\\frac{1}{2})$。\n$w_2(0) = w_{-2}(0) = \\exp(-\\frac{(-2)^2}{2}) = \\exp(-2)$。\n\n矩量矩阵为 $A(x) = \\sum_{i} w_i(x) \\begin{pmatrix} 1 & x_i & x_i^2 \\\\ x_i & x_i^2 & x_i^3 \\\\ x_i^2 & x_i^3 & x_i^4 \\end{pmatrix}$。\n在 $x=0$ 处，由于节点和权函数的对称性（$w_i(0)=w_{-i}(0)$），对于奇数 $k$，任何求和 $\\sum_i w_i(0) x_i^k$ 都将为零。\n$$\nA(0) = \\begin{pmatrix} \\sum_i w_i(0) & 0 & \\sum_i w_i(0) x_i^2 \\\\ 0 & \\sum_i w_i(0) x_i^2 & 0 \\\\ \\sum_i w_i(0) x_i^2 & 0 & \\sum_i w_i(0) x_i^4 \\end{pmatrix}\n$$\n我们来计算这些和（矩）：\n$S_0 = \\sum_i w_i(0) = w_0(0) + 2w_1(0) + 2w_2(0) = 1 + 2\\exp(-\\frac{1}{2}) + 2\\exp(-2)$。\n$S_2 = \\sum_i w_i(0) x_i^2 = w_0(0)(0)^2 + 2w_1(0)(1)^2 + 2w_2(0)(2)^2 = 2\\exp(-\\frac{1}{2}) + 8\\exp(-2)$。\n$S_4 = \\sum_i w_i(0) x_i^4 = w_0(0)(0)^4 + 2w_1(0)(1)^4 + 2w_2(0)(2)^4 = 2\\exp(-\\frac{1}{2}) + 32\\exp(-2)$。\n\n所以在 $x=0$ 处的矩量矩阵是：\n$$\nA(0) = \\begin{pmatrix} S_0 & 0 & S_2 \\\\ 0 & S_2 & 0 \\\\ S_2 & 0 & S_4 \\end{pmatrix}\n$$\n该矩阵是块对角的，这简化了求逆过程。其逆矩阵是：\n$$\nA^{-1}(0) = \\begin{pmatrix} \\frac{S_4}{S_0 S_4 - S_2^2} & 0 & \\frac{-S_2}{S_0 S_4 - S_2^2} \\\\ 0 & \\frac{1}{S_2} & 0 \\\\ \\frac{-S_2}{S_0 S_4 - S_2^2} & 0 & \\frac{S_0}{S_0 S_4 - S_2^2} \\end{pmatrix}\n$$\n这个 $2 \\times 2$ 子块的行列式是 $\\det_{sub} = S_0 S_4 - S_2^2$。我们来计算这一项。令 $E_1 = \\exp(-\\frac{1}{2})$ 和 $E_2 = \\exp(-2)$。\n$S_0 = 1 + 2E_1 + 2E_2$\n$S_2 = 2E_1 + 8E_2$\n$S_4 = 2E_1 + 32E_2$\n$\\det_{sub} = (1 + 2E_1 + 2E_2)(2E_1 + 32E_2) - (2E_1 + 8E_2)^2$\n$= (2E_1+32E_2) + (2E_1)(2E_1+32E_2) + (2E_2)(2E_1+32E_2) - (4E_1^2 + 32E_1E_2 + 64E_2^2)$\n$= (2E_1+32E_2) + (4E_1^2+64E_1E_2) + (4E_1E_2+64E_2^2) - (4E_1^2 + 32E_1E_2 + 64E_2^2)$\n$= 2E_1+32E_2 + (68-32)E_1E_2 = 2E_1 + 32E_2 + 36E_1E_2$。\n代回指数形式并使用 $E_1E_2 = \\exp(-\\frac{5}{2})$：\n$\\det_{sub} = 2\\exp(-\\frac{1}{2}) + 32\\exp(-2) + 36\\exp(-\\frac{5}{2})$。\n\n现在我们计算 $N_i(0) = p^{\\mathsf{T}}(0) A^{-1}(0) w_i(0) p(x_i)$。\n由于 $p^{\\mathsf{T}}(0) = [\\,1,\\; 0,\\; 0\\,]$，它会选取 $A^{-1}(0)$ 的第一行：\n$p^{\\mathsf{T}}(0) A^{-1}(0) = [\\,(A^{-1})_{11},\\; 0,\\; (A^{-1})_{13}\\,] = [\\,\\frac{S_4}{\\det_{sub}},\\; 0,\\; \\frac{-S_2}{\\det_{sub}}\\,]$。\n然后，$N_i(0) = [\\,\\frac{S_4}{\\det_{sub}},\\; 0,\\; \\frac{-S_2}{\\det_{sub}}\\,] \\begin{pmatrix} 1 \\\\ x_i \\\\ x_i^2 \\end{pmatrix} w_i(0) = \\frac{w_i(0)}{\\det_{sub}} (S_4 - S_2 x_i^2)$。\n\n对于中心节点 $i=0$：$x_0=0$，$w_0(0)=1$。\n$N_0(0) = \\frac{1}{\\det_{sub}}(S_4 - S_2(0)^2) = \\frac{S_4}{\\det_{sub}}$。\n$N_0(0) = \\frac{2\\exp(-\\frac{1}{2}) + 32\\exp(-2)}{2\\exp(-\\frac{1}{2}) + 32\\exp(-2) + 36\\exp(-\\frac{5}{2})}$。\n分子分母同时除以2：\n$N_0(0) = \\frac{\\exp(-\\frac{1}{2}) + 16\\exp(-2)}{\\exp(-\\frac{1}{2}) + 16\\exp(-2) + 18\\exp(-\\frac{5}{2})}$。这就是最终答案所要求的值。\n\n### 第2部分：$\\partial_x N_i(0)$ 的计算\n\n形函数的梯度通过对 $N_i(x)$ 求导得到：\n$\\partial_x N_i(x) = (\\partial_x p^{\\mathsf{T}}(x)) A^{-1}(x) w_i(x) p(x_i) + p^{\\mathsf{T}}(x) (\\partial_x A^{-1}(x)) w_i(x) p(x_i) + p^{\\mathsf{T}}(x) A^{-1}(x) (\\partial_x w_i(x)) p(x_i)$。\n我们在 $x=0$ 处计算每一项。\n$\\partial_x p(x) = [\\,0,\\; 1,\\; 2x\\,]^{\\mathsf{T}}$，所以 $\\partial_x p(0) = [\\,0,\\; 1,\\; 0\\,]^{\\mathsf{T}}$。\n$\\partial_x w_i(x) = -(x-x_i)w_i(x)$，所以 $\\partial_x w_i(0) = x_i w_i(0)$。\n$\\partial_x A^{-1}(x) = -A^{-1}(x) (\\partial_x A(x)) A^{-1}(x)$。\n$\\partial_x A(x) = \\sum_j (\\partial_x w_j(x)) p(x_j)p^{\\mathsf{T}}(x_j)$，所以 $\\partial_x A(0) = \\sum_j x_j w_j(0) p(x_j)p^{\\mathsf{T}}(x_j)$。\n这个矩阵，我们称之为 $A'(0)$，其元素为 $A'_{kl}(0) = \\sum_j w_j(0) x_j^{k+l-1}$。由于对称性，只有当 $k+l-1$ 为偶数时，元素才非零。\n$A'_{11} = \\sum w_j x_j = 0$。$A'_{12} = \\sum w_j x_j^2 = S_2$。$A'_{13} = 0$。$A'_{22} = 0$。$A'_{23} = \\sum w_j x_j^4 = S_4$。$A'_{33}=0$。\n$$\nA'(0) = \\begin{pmatrix} 0 & S_2 & 0 \\\\ S_2 & 0 & S_4 \\\\ 0 & S_4 & 0 \\end{pmatrix}\n$$\n现在我们计算 $\\partial_x N_i(0)$ 的三项。\n- 第1项：$\\partial_x p^{\\mathsf{T}}(0) A^{-1}(0) w_i(0) p(x_i) = [\\,0,1,0\\,]A^{-1}(0) w_i(0) p(x_i) = (A^{-1})_{22} w_i(0) x_i = \\frac{1}{S_2} w_i(0) x_i$。\n- 第2项：$-p^{\\mathsf{T}}(0)A^{-1}(0)A'(0)A^{-1}(0)w_i(0)p(x_i)$。\n向量 $v^{\\mathsf{T}} = p^{\\mathsf{T}}(0)A^{-1}(0)A'(0) = [\\,\\frac{S_4}{\\det_{sub}}, 0, \\frac{-S_2}{\\det_{sub}}\\,] \\begin{pmatrix} 0 & S_2 & 0 \\\\ S_2 & 0 & S_4 \\\\ 0 & S_4 & 0 \\end{pmatrix} = [\\,0, \\frac{S_4 S_2}{\\det_{sub}} - \\frac{S_2 S_4}{\\det_{sub}}, 0\\,] = [\\,0, 0, 0\\,]$。\n因此，对于所有 $i$，第2项都为零。这是对称性的结果。\n- 第3项：$p^{\\mathsf{T}}(0) A^{-1}(0) (\\partial_x w_i(0)) p(x_i) = p^{\\mathsf{T}}(0) A^{-1}(0) (x_i w_i(0)) p(x_i) = x_i N_i(0)$。\n\n合并各项：\n$$\n\\partial_x N_i(0) = \\frac{x_i w_i(0)}{S_2} + x_i N_i(0) = x_i w_i(0) \\left( \\frac{1}{S_2} + \\frac{S_4 - S_2 x_i^2}{\\det_{sub}} \\right)\n$$\n对于 $i=0$，$x_0=0$，所以 $\\partial_x N_0(0) = 0$。对于一个以对称点为中心的偶形函数 $N_0(x)$，这是预期的结果。\n\n### 第3部分：性质验证\n\n- **光滑性**：形函数为 $N_i(x) = p^{\\mathsf{T}}(x) A^{-1}(x) w_i(x) p(x_i)$。基函数 $p_k(x)$ 是多项式，因此是 $C^{\\infty}$ 的。权函数 $w_i(x)$ 是高斯函数，也是 $C^{\\infty}$ 的。矩量矩阵 $A(x)$ 的元素是 $w_j(x)$ 的线性组合，因此它们也是 $C^{\\infty}$ 的。其逆矩阵 $A^{-1}(x)$ 存在，并且只要 $\\det(A(x)) \\neq 0$，其元素也是 $C^{\\infty}$ 的。我们计算出 $\\det(A(0)) = S_2 \\cdot \\det_{sub}$。由于 $S_2 > 0$ 且 $\\det_{sub} > 0$，因此在 $x=0$ 处行列式不为零。根据连续性，它在 $x=0$ 的一个邻域内也不为零。因此，$A^{-1}(x)$ 在 $x=0$ 附近是 $C^{\\infty}$ 的。由于 $N_i(x)$ 是由 $C^{\\infty}$ 函数的乘积和求和构成的，所以它也是 $C^{\\infty}$ 的。因此，其导数 $\\partial_x N_i(x)$ 也是 $C^{\\infty}$ 的。\n\n- **不具备克罗内克(Kronecker)δ性质**：\n我们需要证明 $N_0(0) \\neq 1$ 且对于某个 $j \\neq 0$ 有 $N_j(0) \\neq 0$。\n$N_0(0)$ 的表达式是 $\\frac{S_4}{S_4 + 36\\exp(-\\frac{5}{2})}$，它显然为正且小于1。所以 $N_0(0) \\neq 1$。\n对于 $j=1, x_1=1, i=1$：\n$N_1(0) = \\frac{w_1(0)}{\\det_{sub}}(S_4 - S_2 x_1^2) = \\frac{\\exp(-\\frac{1}{2})}{\\det_{sub}}(S_4 - S_2)$。\n$S_4 - S_2 = (2E_1 + 32E_2) - (2E_1 + 8E_2) = 24E_2 = 24\\exp(-2)$。\n$N_1(0) = \\frac{\\exp(-\\frac{1}{2}) \\cdot 24\\exp(-2)}{\\det_{sub}} = \\frac{24\\exp(-\\frac{5}{2})}{\\det_{sub}}$。\n由于 $\\det_{sub}>0$，我们有 $N_1(0) > 0$。根据对称性，$N_{-1}(0) = N_1(0) \\neq 0$。\n同理，对于 $j=2, x_2=2$：\n$N_2(0) = \\frac{w_2(0)}{\\det_{sub}}(S_4 - S_2 x_2^2) = \\frac{\\exp(-2)}{\\det_{sub}}(S_4 - 4S_2)$。\n$S_4 - 4S_2 = (2E_1 + 32E_2) - 4(2E_1 + 8E_2) = -6E_1 = -6\\exp(-\\frac{1}{2})$。\n$N_2(0) = \\frac{\\exp(-2) \\cdot (-6\\exp(-\\frac{1}{2}))}{\\det_{sub}} = \\frac{-6\\exp(-\\frac{5}{2})}{\\det_{sub}} \\neq 0$。\n这明确表明MLS形函数在节点上不具备克罗内克δ性质。\n\n所要求的最终答案是 $N_0(0)$ 的表达式。\n$N_0(0) = \\frac{2\\exp(-\\frac{1}{2}) + 32\\exp(-2)}{2\\exp(-\\frac{1}{2}) + 32\\exp(-2) + 36\\exp(-\\frac{5}{2})} = \\frac{\\exp(-\\frac{1}{2}) + 16\\exp(-2)}{\\exp(-\\frac{1}{2}) + 16\\exp(-2) + 18\\exp(-\\frac{5}{2})}$。\n从分母中提出分子项可以直观地展示这一点：\n$N_0(0) = \\frac{\\exp(-\\frac{1}{2}) + 16\\exp(-2)}{(\\exp(-\\frac{1}{2}) + 16\\exp(-2)) + 18\\exp(-\\frac{5}{2})}$。",
            "answer": "$$\n\\boxed{\\frac{\\exp(-\\frac{1}{2}) + 16\\exp(-2)}{18\\exp(-\\frac{5}{2}) + \\exp(-\\frac{1}{2}) + 16\\exp(-2)}}\n$$"
        },
        {
            "introduction": "在解析推导出形函数之后，下一步是对其特性进行数值验证。本练习将实现经典的“面片检验”（patch test），以验证所构建的MLS近似是否能够精确地再生其基函数所包含的多项式场，这是确保方法收敛性的一个基本要求，即再生特性。通过测试不同的基函数和位移场，本练习将帮助您对这一核心概念建立具体而深刻的认识。",
            "id": "3581266",
            "problem": "考虑一个二维无网格无单元伽辽金法 (EFG) 斑块检验，该检验通过移动最小二乘法 (MLS) 在再生核 (RK) 近似框架下构建。目标是验证方形粒子云在刚体运动和均匀应变下的再生特性，并量化支承尺寸和基函数阶次对数值再生误差的影响。\n\n您需要在一个均匀节点集上实现基于 MLS 的形函数构造，该节点集位于方形域 $[0,1] \\times [0,1]$ 内，节点坐标由一个大小为 $N_x \\times N_y$ 的规则网格给出，其中 $N_x = N_y = 11$。网格间距为 $h = 1/(N_x - 1)$。使用一个由下式定义的紧支正权函数\n$$\nw(q) = \\begin{cases}\n1 - 6 q^2 + 8 q^3 - 3 q^4, & 0 \\le q \\le 1, \\\\\n0, & q > 1,\n\\end{cases}\n$$\n其中 $q = r/d$，$r$ 是计算点到节点的欧氏距离，$d$ 是节点支承半径。MLS 基函数必须是 0 阶（常数基 $p(\\mathbf{x}) = [1]$）或 1 阶（线性基 $p(\\mathbf{x}) = [1, x, y]$）。MLS 近似必须直接从第一性原理构建：从最小化局部邻域上加权最小二乘误差的 MLS 系数变分定义出发，推导出数值计算形函数和近似场所需的代数表达式。\n\n在平面中定义三个位移场：\n- 刚性平移：$\\mathbf{u}(\\mathbf{x}) = \\mathbf{c}$，其中 $\\mathbf{c} \\in \\mathbb{R}^2$。\n- 绕原点的无穷小刚性旋转，旋转角为 $\\theta$（弧度）：$\\mathbf{u}(\\mathbf{x}) = \\theta\\,[-y,\\,x]^T$。\n- 均匀应变：$\\mathbf{u}(\\mathbf{x}) = \\mathbf{E}\\,\\mathbf{x}$，其中 $\\mathbf{E} \\in \\mathbb{R}^{2 \\times 2}$ 为常数。\n\n再生检验要求，只要场属于所选基函数张成的多项式空间且矩量矩阵可逆，MLS 近似 $\\mathbf{u}^h(\\mathbf{x})$ 就必须对所有 $\\mathbf{x}$ 精确匹配目标场 $\\mathbf{u}(\\mathbf{x})$。特别地，对于 0 阶基，常数场是可再生的；对于 1 阶基，所有线性向量场，包括刚体旋转和均匀应变，都是可再生的。\n\n通过从网格节点 $\\{\\mathbf{x}_i\\}$ 处的节点样本 $\\{\\mathbf{u}_i\\}$ 构建 MLS 近似体 $\\mathbf{u}^h(\\mathbf{x})$，并在一个计算点集 $\\mathcal{S}$ 上计算最大绝对误差来数值验证这些再生特性\n$$\n\\varepsilon_{\\max} = \\max_{\\mathbf{x} \\in \\mathcal{S}} \\|\\mathbf{u}^h(\\mathbf{x}) - \\mathbf{u}(\\mathbf{x})\\|_{\\infty},\n$$\n使用 $\\mathbb{R}^2$ 上的无穷范数，定义为 $\\|[a,b]^T\\|_{\\infty} = \\max\\{|a|,|b|\\}$。\n\n角度必须使用弧度。输出不涉及物理单位。您的程序必须实现 MLS 形函数并为下面的每个测试用例计算 $\\varepsilon_{\\max}$。最终输出必须为单行，包含一个浮点误差列表，按指定顺序排列。\n\n测试套件：\n- 测试 $\\mathbf{T1}$ (理想情况，常数再生): 基函数阶次 0；支承因子 $s = 2.5$，因此 $d = s\\,h$；刚性平移 $\\mathbf{c} = [0.3,-0.2]^T$；计算点集 $\\mathcal{S}$ 是坐标 $\\{0.1,0.3,0.5,0.7,0.9\\} \\times \\{0.1,0.3,0.5,0.7,0.9\\}$ 的笛卡尔积，共 25 个点。\n- 测试 $\\mathbf{T2}$ (使用常数基不可再生): 基函数阶次 0；支承因子 $s = 2.5$；刚性旋转 $\\theta = 0.1$；计算点集 $\\mathcal{S}$ 与 $\\mathbf{T1}$ 相同。\n- 测试 $\\mathbf{T3}$ (刚性旋转再生): 基函数阶次 1；支承因子 $s = 2.5$；刚性旋转 $\\theta = 0.1$；计算点集 $\\mathcal{S}$ 与 $\\mathbf{T1}$ 相同。\n- 测试 $\\mathbf{T4}$ (均匀应变再生): 基函数阶次 1；支承因子 $s = 2.5$；均匀应变\n$$\n\\mathbf{E} = \\begin{bmatrix} 0.01 & 0.02 \\\\ 0.00 & -0.005 \\end{bmatrix};\n$$\n计算点集 $\\mathcal{S}$ 与 $\\mathbf{T1}$ 相同。\n- 测试 $\\mathbf{T5}$ (靠近边界且支承较小的边界情况): 基函数阶次 1；支承因子 $s = 1.05$；均匀应变，$\\mathbf{E}$ 与 $\\mathbf{T4}$ 相同；计算点集 $\\mathcal{S}$ 仅包含单点 $\\mathbf{x} = [0.02, 0.02]^T$。\n\n对于每个测试，计算并返回 $\\varepsilon_{\\max}$ 的值（浮点数）。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，“[$r_1,r_2,r_3,r_4,r_5$]”），其中 $r_k$ 是测试 $\\mathbf{Tk}$ 的结果，顺序如上。角度必须解释为弧度，输出没有物理单位。\n\n您的推导和实现必须从 MLS 近似的基本定义和再生核方法中再生的概念出发，不得假定超出这些定义之外的专用公式。",
            "solution": "该问题要求对移动最小二乘法 (MLS) 近似的再生特性进行数值验证，MLS 是诸如无单元伽辽金 (EFG) 法等无网格方法的基石。我们将首先从基本原理推导 MLS 形函数，然后概述执行斑块检验的数值步骤。\n\n### 1. 移动最小二乘 (MLS) 近似\n\nMLS 方法从一组离散的节点值构建场的连续近似。设 $u(\\mathbf{x})$ 是定义在域 $\\Omega \\subset \\mathbb{R}^2$ 上的标量场。给定一组 $N$ 个节点 $\\{\\mathbf{x}_i\\}_{i=1}^N$ 及其对应的节点值 $\\{u_i = u(\\mathbf{x}_i)\\}_{i=1}^N$，在计算点 $\\mathbf{x}$ 处的 MLS 近似 $u^h(\\mathbf{x})$ 被定义为一个特定阶次的多项式，其系数在局部确定。\n\n设 $\\mathbf{p}(\\mathbf{x}) = [p_1(\\mathbf{x}), p_2(\\mathbf{x}), \\dots, p_m(\\mathbf{x})]^T$ 是一个由 $m$ 个多项式函数组成的基。对于二维线性近似，一个合适的基是 $\\mathbf{p}(\\mathbf{x}) = [1, x, y]^T$，对应于 1 阶基和 $m=3$。对于常数近似，基是 $\\mathbf{p}(\\mathbf{x}) = [1]$，阶次为 0 且 $m=1$。\n\n在点 $\\mathbf{x}$ 处的近似由下式给出：\n$$\nu^h(\\mathbf{x}) = \\mathbf{p}^T(\\mathbf{x}) \\mathbf{a}(\\mathbf{x})\n$$\n其中 $\\mathbf{a}(\\mathbf{x}) \\in \\mathbb{R}^m$ 是一个依赖于位置 $\\mathbf{x}$ 的系数向量。这些系数是通过在 $\\mathbf{x}$ 的局部邻域内的节点值上最小化一个加权的、离散的最小二乘误差泛函 $J(\\mathbf{a})$ 来确定的：\n$$\nJ(\\mathbf{a}) = \\sum_{i=1}^{N} w(\\mathbf{x} - \\mathbf{x}_i) \\left[ \\mathbf{p}^T(\\mathbf{x}_i) \\mathbf{a}(\\mathbf{x}) - u_i \\right]^2\n$$\n函数 $w(\\mathbf{x} - \\mathbf{x}_i)$ 是一个具有紧支集的权函数，仅在节点 $\\mathbf{x}_i$ “靠近” $\\mathbf{x}$ 时非零。问题指定的权函数为：\n$$\nw(q) = \\begin{cases}\n1 - 6 q^2 + 8 q^3 - 3 q^4, & 0 \\le q \\le 1, \\\\\n0, & q > 1,\n\\end{cases}\n$$\n其中 $q = \\|\\mathbf{x} - \\mathbf{x}_i\\|_2 / d$，$d$ 是支承域的半径。为简洁起见，我们记作 $w_i(\\mathbf{x}) = w(\\mathbf{x} - \\mathbf{x}_i)$。\n\n为了找到最小化 $J$ 的系数 $\\mathbf{a}(\\mathbf{x})$，我们将 $J$ 对 $\\mathbf{a}$ 求导并令其为零：\n$$\n\\frac{\\partial J}{\\partial \\mathbf{a}} = 2 \\sum_{i=1}^{N} w_i(\\mathbf{x}) \\mathbf{p}(\\mathbf{x}_i) \\left[ \\mathbf{p}^T(\\mathbf{x}_i) \\mathbf{a}(\\mathbf{x}) - u_i \\right] = \\mathbf{0}\n$$\n这导出了关于 $\\mathbf{a}(\\mathbf{x})$ 的以下线性方程组：\n$$\n\\left( \\sum_{i=1}^{N} w_i(\\mathbf{x}) \\mathbf{p}(\\mathbf{x}_i) \\mathbf{p}^T(\\mathbf{x}_i) \\right) \\mathbf{a}(\\mathbf{x}) = \\sum_{i=1}^{N} w_i(\\mathbf{x}) \\mathbf{p}(\\mathbf{x}_i) u_i\n$$\n我们定义矩量矩阵 $\\mathbf{M}(\\mathbf{x})$，一个 $m \\times m$ 的矩阵，为：\n$$\n\\mathbf{M}(\\mathbf{x}) = \\sum_{i=1}^{N} w_i(\\mathbf{x}) \\mathbf{p}(\\mathbf{x}_i) \\mathbf{p}^T(\\mathbf{x}_i)\n$$\n现在，该系统可以写成 $\\mathbf{M}(\\mathbf{x}) \\mathbf{a}(\\mathbf{x}) = \\sum_{i=1}^{N} w_i(\\mathbf{x}) \\mathbf{p}(\\mathbf{x}_i) u_i$。\n假设 $\\mathbf{M}(\\mathbf{x})$ 是可逆的，这要求在 $\\mathbf{x}$ 的支承域内有足够数量且不处于退化构型的节点，我们可以解出 $\\mathbf{a}(\\mathbf{x})$：\n$$\n\\mathbf{a}(\\mathbf{x}) = \\mathbf{M}^{-1}(\\mathbf{x}) \\sum_{i=1}^{N} w_i(\\mathbf{x}) \\mathbf{p}(\\mathbf{x}_i) u_i\n$$\n\n### 2. MLS 形函数的推导\n\n将 $\\mathbf{a}(\\mathbf{x})$ 的表达式代回 $u^h(\\mathbf{x})$ 的定义中，我们得到：\n$$\nu^h(\\mathbf{x}) = \\mathbf{p}^T(\\mathbf{x}) \\mathbf{M}^{-1}(\\mathbf{x}) \\sum_{i=1}^{N} w_i(\\mathbf{x}) \\mathbf{p}(\\mathbf{x}_i) u_i\n$$\n通过重新排列表达式以匹配标准的有限元形式 $u^h(\\mathbf{x}) = \\sum_{i=1}^{N} \\phi_i(\\mathbf{x}) u_i$，我们可以确定与节点 $i$ 相关联的 MLS 形函数 $\\phi_i(\\mathbf{x})$：\n$$\n\\phi_i(\\mathbf{x}) = \\mathbf{p}^T(\\mathbf{x}) \\mathbf{M}^{-1}(\\mathbf{x}) \\mathbf{p}(\\mathbf{x}_i) w_i(\\mathbf{x})\n$$\n注意，如果节点 $\\mathbf{x}_i$ 在 $\\mathbf{x}$ 的支承域之外，则 $\\phi_i(\\mathbf{x}) = 0$，因为 $w_i(\\mathbf{x})=0$。\n\n对于向量场，例如位移场 $\\mathbf{u}(\\mathbf{x}) \\in \\mathbb{R}^2$，MLS 近似被独立地应用于每个分量，使用相同的标量形函数：\n$$\n\\mathbf{u}^h(\\mathbf{x}) = \\sum_{i=1}^{N} \\phi_i(\\mathbf{x}) \\mathbf{u}_i\n$$\n其中 $\\mathbf{u}_i = \\mathbf{u}(\\mathbf{x}_i)$ 是节点位移向量。\n\n### 3. 再生特性\n\nMLS 近似具有“再生核”特性。如果基函数 $\\mathbf{p}(\\mathbf{x})$ 包含直到 $k$ 阶的所有多项式项，则 MLS 近似可以精确地再生任何直到 $k$ 阶的多项式场。\n设待近似的场 $u(\\mathbf{x})$ 是一个来自基函数张成空间的多项式，即 $u(\\mathbf{x}) = \\mathbf{p}^T(\\mathbf{x})\\mathbf{c}$，其中 $\\mathbf{c}$ 是某个常系数向量。节点值为 $u_i = u(\\mathbf{x}_i) = \\mathbf{p}^T(\\mathbf{x}_i)\\mathbf{c}$。\n将这些节点值代入 $u^h(\\mathbf{x})$ 的表达式中：\n$$\nu^h(\\mathbf{x}) = \\sum_{i=1}^{N} \\phi_i(\\mathbf{x}) u_i = \\sum_{i=1}^{N} \\phi_i(\\mathbf{x}) (\\mathbf{p}^T(\\mathbf{x}_i)\\mathbf{c})\n$$\n代入 $\\phi_i(\\mathbf{x})$ 的公式：\n$$\nu^h(\\mathbf{x}) = \\sum_{i=1}^{N} \\left[ \\mathbf{p}^T(\\mathbf{x}) \\mathbf{M}^{-1}(\\mathbf{x}) \\mathbf{p}(\\mathbf{x}_i) w_i(\\mathbf{x}) \\right] (\\mathbf{p}^T(\\mathbf{x}_i)\\mathbf{c})\n$$\n由于 $\\mathbf{c}$ 是常数，我们可以将其从求和中提出：\n$$\nu^h(\\mathbf{x}) = \\mathbf{p}^T(\\mathbf{x}) \\mathbf{M}^{-1}(\\mathbf{x}) \\left( \\sum_{i=1}^{N} w_i(\\mathbf{x}) \\mathbf{p}(\\mathbf{x}_i)\\mathbf{p}^T(\\mathbf{x}_i) \\right) \\mathbf{c}\n$$\n括号中的项是矩量矩阵 $\\mathbf{M}(\\mathbf{x})$ 的定义。因此：\n$$\nu^h(\\mathbf{x}) = \\mathbf{p}^T(\\mathbf{x}) \\mathbf{M}^{-1}(\\mathbf{x}) \\mathbf{M}(\\mathbf{x}) \\mathbf{c} = \\mathbf{p}^T(\\mathbf{x}) \\mathbf{c} = u(\\mathbf{x})\n$$\n这证明了对于任何使 $\\mathbf{M}(\\mathbf{x})$ 可逆的点 $\\mathbf{x}$，只要 $u(\\mathbf{x})$ 位于基函数 $\\mathbf{p}(\\mathbf{x})$ 张成的空间中，就有 $u^h(\\mathbf{x}) = u(\\mathbf{x})$。\n\n### 4. 斑块检验的数值实现\n\n为每个测试用例执行数值验证的算法如下：\n1.  **节点生成**: 在域 $[0,1] \\times [0,1]$ 内生成一个 $N_x \\times N_y = 11 \\times 11$ 的网格节点。网格间距为 $h = 1 / (N_x - 1) = 1/10 = 0.1$。\n2.  **测试用例设置**: 对于每个测试用例（$\\mathbf{T1}$ 到 $\\mathbf{T5}$），设置基函数阶次、支承因子 $s$、解析位移场 $\\mathbf{u}(\\mathbf{x})$ 以及计算点集 $\\mathcal{S}$。支承半径为 $d = s \\cdot h$。\n3.  **节点位移**: 在每个节点 $\\mathbf{x}_i$ 处计算解析位移场 $\\mathbf{u}(\\mathbf{x})$ 以获得节点值 $\\mathbf{u}_i$。\n4.  **误差计算**:\n    a. 初始化最大误差 $\\varepsilon_{\\max} = 0$。\n    b. 对于每个计算点 $\\mathbf{x} \\in \\mathcal{S}$：\n        i.   识别支承域内的所有节点 $\\{\\mathbf{x}_i\\}$，即满足 $\\|\\mathbf{x} - \\mathbf{x}_i\\|_2 \\le d$ 的节点。\n        ii.  使用支承域内节点的基多项式 $\\mathbf{p}(\\mathbf{x}_i)$ 和权函数 $w_i(\\mathbf{x})$ 构建矩量矩阵 $\\mathbf{M}(\\mathbf{x})$。\n        iii. 如果 $\\mathbf{M}(\\mathbf{x})$ 可逆，计算其逆矩阵 $\\mathbf{M}^{-1}(\\mathbf{x})$。\n        iv.  初始化近似位移 $\\mathbf{u}^h(\\mathbf{x}) = [0, 0]^T$。\n        v.   对于支承域内的每个节点 $\\mathbf{x}_i$，计算其形函数值 $\\phi_i(\\mathbf{x}) = \\mathbf{p}^T(\\mathbf{x}) \\mathbf{M}^{-1}(\\mathbf{x}) \\mathbf{p}(\\mathbf{x}_i) w_i(\\mathbf{x})$。\n        vi.  累加近似值：$\\mathbf{u}^h(\\mathbf{x}) += \\phi_i(\\mathbf{x}) \\mathbf{u}_i$。\n        vii. 在计算点计算解析位移 $\\mathbf{u}(\\mathbf{x})$。\n        viii.计算误差 $\\varepsilon = \\|\\mathbf{u}^h(\\mathbf{x}) - \\mathbf{u}(\\mathbf{x})\\|_{\\infty} = \\max(|u_x^h - u_x|, |u_y^h - u_y|)$。\n        ix.  更新 $\\varepsilon_{\\max} = \\max(\\varepsilon_{\\max}, \\varepsilon)$。\n5.  **返回结果**: 最终的 $\\varepsilon_{\\max}$ 是该测试用例的结果。\n\n这些测试用例旨在验证再生特性：\n-   **T1**: 在常数场上使用 0 阶基。预期 $\\varepsilon_{\\max} \\approx 0$。\n-   **T2**: 在线性场上使用 0 阶基。不可再生。预期 $\\varepsilon_{\\max} > 0$。\n-   **T3**: 在线性场（旋转）上使用 1 阶基。预期 $\\varepsilon_{\\max} \\approx 0$。\n-   **T4**: 在线性场（应变）上使用 1 阶基。预期 $\\varepsilon_{\\max} \\approx 0$。\n-   **T5**: 在线性场上使用 1 阶基，在边界附近采用最小支承。这测试了方法的鲁棒性。预期 $\\varepsilon_{\\max} \\approx 0$，可能由于 $\\mathbf{M}(\\mathbf{x})$ 较差的条件数而比 T3/T4 略大。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and runs the Element-Free Galerkin (EFG) patch tests \n    using Moving Least Squares (MLS) approximation.\n    \"\"\"\n\n    # --- Problem Setup ---\n    Nx = 11\n    Ny = 11\n    h = 1.0 / (Nx - 1)\n    \n    # Generate node coordinates\n    x_coords = np.linspace(0.0, 1.0, Nx)\n    y_coords = np.linspace(0.0, 1.0, Ny)\n    nodes = np.array(np.meshgrid(x_coords, y_coords)).T.reshape(-1, 2)\n\n    # --- Weight Function ---\n    def weight_function(q):\n        \"\"\"\n        C1 continuous quartic spline weight function.\n        w(q) = 1 - 6q^2 + 8q^3 - 3q^4 for 0 = q = 1.\n        \"\"\"\n        if 0.0 = q = 1.0:\n            return 1.0 - 6.0*q**2 + 8.0*q**3 - 3.0*q**4\n        return 0.0\n\n    # --- MLS Core Logic ---\n    def compute_mls_error(nodes, basis_degree, support_factor, u_field_func, eval_points):\n        \"\"\"\n        Computes the maximum error of the MLS approximation for a given setup.\n        \"\"\"\n        s = support_factor\n        d = s * h\n        \n        # Get nodal values from the analytical field\n        u_nodal = np.array([u_field_func(node) for node in nodes])\n        \n        max_error = 0.0\n        \n        for x_eval in eval_points:\n            # Find nodes within the support domain of x_eval\n            support_nodes_indices = []\n            distances = []\n            for i, node in enumerate(nodes):\n                dist = np.linalg.norm(x_eval - node)\n                if dist = d:\n                    support_nodes_indices.append(i)\n                    distances.append(dist)\n\n            if not support_nodes_indices:\n                # Should not happen with the given parameters\n                # If it does, the approximation is zero, error is the field value\n                u_true = u_field_func(x_eval)\n                error = np.max(np.abs(u_true))\n                max_error = max(max_error, error)\n                continue\n\n            # Basis setup\n            if basis_degree == 0:\n                m = 1\n                get_p = lambda x: np.array([1.0])\n            elif basis_degree == 1:\n                m = 3\n                get_p = lambda x: np.array([1.0, x[0], x[1]])\n            else:\n                raise ValueError(\"Unsupported basis degree\")\n\n            if len(support_nodes_indices)  m:\n                # Insufficient nodes for a stable approximation\n                # This indicates a potential issue, e.g., in T5\n                u_true = u_field_func(x_eval)\n                # Approximation is ill-defined, cannot compute error robustly.\n                # A robust implementation might switch to a lower order basis.\n                # Here we assume the error is large or skip. Let's compute best effort.\n                u_h = np.zeros(2) # Fallback\n                error = np.max(np.abs(u_h - u_true))\n                max_error = max(max_error, error)\n                continue\n\n            # Construct Moment Matrix M(x)\n            M = np.zeros((m, m))\n            support_nodes = nodes[support_nodes_indices]\n            \n            w_vals = [weight_function(dist / d) for dist in distances]\n\n            for i in range(len(support_nodes)):\n                node = support_nodes[i]\n                p_i = get_p(node)\n                w_i = w_vals[i]\n                M += w_i * np.outer(p_i, p_i)\n\n            # Invert Moment Matrix\n            try:\n                M_inv = np.linalg.inv(M)\n            except np.linalg.LinAlgError:\n                # Singular matrix, approximation fails\n                u_true = u_field_func(x_eval)\n                u_h = np.zeros(2) # Fallback\n                error = np.max(np.abs(u_h - u_true))\n                max_error = max(max_error, error)\n                continue\n\n            # Calculate shape functions and approximated field u_h(x)\n            p_eval = get_p(x_eval)\n            u_h = np.zeros(2)\n            \n            for i in range(len(support_nodes)):\n                node_idx = support_nodes_indices[i]\n                node = support_nodes[i]\n                p_i = get_p(node)\n                w_i = w_vals[i]\n                \n                # Shape function value phi_i(x_eval)\n                phi_i = p_eval.T @ M_inv @ p_i * w_i\n                \n                u_h += phi_i * u_nodal[node_idx]\n\n            # Calculate error at the evaluation point\n            u_true = u_field_func(x_eval)\n            error = np.max(np.abs(u_h - u_true))\n            max_error = max(max_error, error)\n            \n        return max_error\n\n    # --- Test Cases Definition ---\n    eval_grid_coords = [0.1, 0.3, 0.5, 0.7, 0.9]\n    eval_set_T1_T4 = np.array(np.meshgrid(eval_grid_coords, eval_grid_coords)).T.reshape(-1, 2)\n    \n    # T1: Rigid Translation\n    c = np.array([0.3, -0.2])\n    u_trans = lambda x: c\n\n    # T2/T3: Rigid Rotation\n    theta = 0.1\n    u_rot = lambda x: theta * np.array([-x[1], x[0]])\n\n    # T4/T5: Uniform Strain\n    E = np.array([[0.01, 0.02], [0.00, -0.005]])\n    u_strain = lambda x: E @ x\n\n    test_cases = [\n        {'name': 'T1', 'basis_degree': 0, 'support_factor': 2.5, 'u_field_func': u_trans, 'eval_points': eval_set_T1_T4},\n        {'name': 'T2', 'basis_degree': 0, 'support_factor': 2.5, 'u_field_func': u_rot, 'eval_points': eval_set_T1_T4},\n        {'name': 'T3', 'basis_degree': 1, 'support_factor': 2.5, 'u_field_func': u_rot, 'eval_points': eval_set_T1_T4},\n        {'name': 'T4', 'basis_degree': 1, 'support_factor': 2.5, 'u_field_func': u_strain, 'eval_points': eval_set_T1_T4},\n        {'name': 'T5', 'basis_degree': 1, 'support_factor': 1.05, 'u_field_func': u_strain, 'eval_points': np.array([[0.02, 0.02]])},\n    ]\n\n    results = []\n    for case in test_cases:\n        error = compute_mls_error(nodes, case['basis_degree'], case['support_factor'], case['u_field_func'], case['eval_points'])\n        results.append(error)\n\n    # --- Final Output ---\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "真实的工程问题常常涉及复杂的几何形状，这给无网格方法的应用带来了独特的挑战。本练习将再生特性的验证推广到一个带有凹角的非凸域中，并引入了“可见性”这一关键概念。它不仅要求您检验方法的成功，更要求您诊断特定的失效模式，从而培养将无网格方法稳健地应用于实际工程模拟所必需的宝贵技能。",
            "id": "3581244",
            "problem": "考虑一个二维 L 形域，由点集 $\\mathcal{D} = \\{(x,y) \\in \\mathbb{R}^2 \\mid -1 \\le x \\le 1, -1 \\le y \\le 1, x \\le 0 \\text{ or } y \\le 0\\}$ 定义，其在 $(0,0)$ 处有一个凹角。节点被放置在 $[-1,1] \\times [-1,1]$ 上的一个间距为 $h$ 的均匀笛卡尔网格上，并限制在 $\\mathcal{D}$ 内。对于一个给定的评估点 $\\mathbf{x} \\in \\mathcal{D}$，定义使用线性多项式基 $p(\\mathbf{X}) = [1, X, Y]^T$ 的移动最小二乘 (MLS) 近似。设紧支权函数为 $w(r) = (1 - r)^4(4r + 1)$（对于 $0 \\le r \\le 1$）且在其他情况下 $w(r) = 0$，其中 $r = \\|\\mathbf{x} - \\mathbf{X}_I\\|/R$ 是归一化距离，支持半径为 $R$，$\\mathbf{X}_I$ 表示节点 $I$ 的坐标。MLS 矩量矩阵定义为\n$$\n\\mathbf{A}(\\mathbf{x}) = \\sum_{I} w_I(\\mathbf{x})\\, p(\\mathbf{X}_I)\\, p(\\mathbf{X}_I)^T,\n$$\n且相应的 MLS 形函数为\n$$\n\\phi_I(\\mathbf{x}) = p(\\mathbf{x})^T \\mathbf{A}(\\mathbf{x})^{-1} w_I(\\mathbf{x}) p(\\mathbf{X}_I).\n$$\n当强制执行可见性约束时，如果连接 $\\mathbf{x}$ 和 $\\mathbf{X}_I$ 的直线段完全位于 $\\mathcal{D}$ 内，则认为节点 $I$ 从 $\\mathbf{x}$ 处可见；否则，对该节点 $I$ 设置 $w_I(\\mathbf{x}) = 0$。假设 $p(\\mathbf{x}) = [1, x, y]^T$，其中 $(x,y)$ 是 $\\mathbf{x}$ 的坐标。\n\n您的任务是实现一个程序，该程序针对每个提供的测试案例，在指定的支持和可见性条件下构建 MLS 形函数 $\\phi_I(\\mathbf{x})$，然后评估：\n\n1. 单位分解误差\n$$\ne_{\\mathrm{PU}}(\\mathbf{x}) = \\left| \\sum_I \\phi_I(\\mathbf{x}) - 1 \\right|.\n$$\n\n2. 线性再生误差\n$$\ne_{\\mathrm{LIN}}(\\mathbf{x}) = \\left\\| \\sum_I \\phi_I(\\mathbf{x})\\, \\mathbf{X}_I - \\mathbf{x} \\right\\|_2.\n$$\n\n使用以下诊断逻辑对失效模式进行分类：\n- 返回一个诊断整数 $d$，定义如下：\n  - $d = 0$：如果两项测试均在指定容差内通过。\n  - $d = 1$：如果支持不足，定义为贡献节点（应用可见性后 $w_I(\\mathbf{x})  0$ 的节点）少于 $3$ 个。\n  - $d = 2$：如果 MLS 矩量矩阵 $\\mathbf{A}(\\mathbf{x})$ 是奇异或病态的（使用条件数阈值 $10^{12}$）。\n  - $d = 3$：如果在支持充足且矩量矩阵条件良好的情况下测试失败，表明失败归因于可见性约束或几何分布。\n\n对于数值容差，对 $e_{\\mathrm{PU}}$ 和 $e_{\\mathrm{LIN}}$ 均使用 $10^{-8}$。不涉及物理单位；将所有量视为无量纲。\n\n实现以下测试套件，其中每个案例以 $(\\mathbf{x}, R, h, \\mathrm{visibility})$ 的形式给出：\n- 测试案例 1: $\\mathbf{x} = (-0.5,-0.5)$, $R = 0.45$, $h = 0.2$, $\\mathrm{visibility} = \\text{False}$.\n- 测试案例 2: $\\mathbf{x} = (-0.05,-0.05)$, $R = 0.15$, $h = 0.2$, $\\mathrm{visibility} = \\text{False}$.\n- 测试案例 3: $\\mathbf{x} = (-0.05,-0.05)$, $R = 0.35$, $h = 0.2$, $\\mathrm{visibility} = \\text{True}$.\n- 测试案例 4: $\\mathbf{x} = (0.2,-0.2)$, $R = 0.3$, $h = 0.2$, $\\mathrm{visibility} = \\text{True}$.\n- 测试案例 5: $\\mathbf{x} = (-0.05,-0.05)$, $R = 0.25$, $h = 0.2$, $\\mathrm{visibility} = \\text{True}$.\n\n对于每个测试案例，计算布尔指标\n$$\nb_{\\mathrm{PU}} = \\left( e_{\\mathrm{PU}} \\le 10^{-8} \\right), \\quad b_{\\mathrm{LIN}} = \\left( e_{\\mathrm{LIN}} \\le 10^{-8} \\right),\n$$\n和上面定义的诊断整数 $d$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个元素对应一个测试案例，形式为 $[b_{\\mathrm{PU}}, b_{\\mathrm{LIN}}, d]$。例如：\n$$\n[ [\\text{True}, \\text{True}, 0], [\\text{False}, \\text{False}, 1], \\ldots ].\n$$",
            "solution": "该问题提出了一个在计算力学领域中明确定义的练习，特别关注非凸域中移动最小二乘 (MLS) 形函数的性质。所有给定的定义，包括 L 形域 $\\mathcal{D}$、多项式基 $p(\\mathbf{X})$、权函数 $w(r)$、矩量矩阵 $\\mathbf{A}(\\mathbf{x})$、形函数 $\\phi_I(\\mathbf{x})$ 以及误差度量 $e_{\\mathrm{PU}}$ 和 $e_{\\mathrm{LIN}}$，在无网格方法的理论中都是标准的。该问题具有科学依据、客观性，并包含为每个测试案例进行唯一计算求解所需的所有必要信息。包含了对节点支持不足、矩阵条件和可见性效应等失效模式的诊断标准，使该问题成为对 MLS 原理理解的全面测试。因此，该问题被认为是**有效的**。\n\n解决方案通过为每个指定的测试案例实施 MLS 近似方案来进行。核心步骤如下：\n\n1.  **节点离散化**：对于给定的网格间距 $h$，在方形域 $[-1, 1] \\times [-1, 1]$ 上生成一个均匀的笛卡尔网格节点。然后对这些节点进行筛选，只保留位于指定 L 形域 $\\mathcal{D}$ 内的节点。如果坐标为 $(X_I, Y_I)$ 的节点满足条件 $X_I \\le 0$ 或 $Y_I \\le 0$，则保留该节点。在实践中，使用一个小的数值容差来精确处理边界上的浮点运算（例如，$X_I \\le 10^{-9}$）。\n\n2.  **支持域与权函数计算**：对于给定的评估点 $\\mathbf{x}$ 和支持半径 $R$，我们找出圆形支持域内的所有节点 $\\mathbf{X}_I$，即欧几里得距离 $\\|\\mathbf{x} - \\mathbf{X}_I\\|$ 小于或等于 $R$ 的节点。对于每个这样的节点，计算归一化距离 $r_I = \\|\\mathbf{x} - \\mathbf{X}_I\\| / R$。然后使用给定的四次样条函数 $w(r_I) = (1 - r_I)^4(4r_I + 1)$ 来评估相应的权值 $w_I(\\mathbf{x})$。\n\n3.  **可见性约束**：如果可见性约束是激活的，则对支持半径内的每个节点 $\\mathbf{X}_I$ 执行额外的检查。如果连接节点到评估点 $\\mathbf{x}$ 的直线段与域的空白区域相交，则该节点被视为“不可见”。空白区域是开放的第一象限 $\\{(u,v) \\in \\mathbb{R}^2 \\mid u  0, v  0\\}$。当且仅当其中一个点（$\\mathbf{x}$ 或 $\\mathbf{X}_I$）位于开放的第二象限（$\\{ u  0, v  0 \\}$）而另一个点位于开放的第四象限（$\\{ u  0, v  0 \\}$）时，才会出现此几何条件。如果一个节点不可见，其权值将被设为零，$w_I(\\mathbf{x})=0$，从而有效地将其从近似中移除。\n\n4.  **充足支持的诊断检查**：使用线性基 $p(\\mathbf{x}) = [1, x, y]^T$ 的 MLS 近似需要至少 $3$ 个节点，以确保矩量矩阵可以是非奇异的。计算贡献节点（在应用距离和可见性标准后 $w_I(\\mathbf{x})  0$ 的节点）的数量。如果此数量小于 $3$，则支持不足。诊断代码设为 $d=1$，并且不对此案例执行进一步的计算。\n\n5.  **矩量矩阵的构建与条件数**：如果支持充足，则组装 $3 \\times 3$ 的矩量矩阵 $\\mathbf{A}(\\mathbf{x})$：\n    $$\n    \\mathbf{A}(\\mathbf{x}) = \\sum_{I} w_I(\\mathbf{x})\\, p(\\mathbf{X}_I)\\, p(\\mathbf{X}_I)^T\n    $$\n    其中求和遍及所有贡献节点。节点 $I$ 的基向量是 $p(\\mathbf{X}_I) = [1, X_I, Y_I]^T$。然后计算 $\\mathbf{A}(\\mathbf{x})$ 的条件数。如果它超过阈值 $10^{12}$，则该矩阵被认为是病态的，诊断代码设为 $d=2$。\n\n6.  **形函数评估与性质验证**：如果矩量矩阵是良态的，则使用其逆矩阵 $\\mathbf{A}(\\mathbf{x})^{-1}$ 来确定形函数。为了计算效率，我们首先计算向量 $\\mathbf{b}(\\mathbf{x})^T = p(\\mathbf{x})^T \\mathbf{A}(\\mathbf{x})^{-1}$。然后，每个贡献节点 $I$ 的形函数是 $\\phi_I(\\mathbf{x}) = \\mathbf{b}(\\mathbf{x})^T w_I(\\mathbf{x}) p(\\mathbf{X}_I)$。计算出形函数后，我们验证单位分解和线性再生性质：\n    -   单位分解 (PU)：我们计算和 $\\sum_I \\phi_I(\\mathbf{x})$ 及其与 $1$ 的绝对偏差，得到 $e_{\\mathrm{PU}}$。\n    -   线性再生 (LIN)：我们计算向量和 $\\sum_I \\phi_I(\\mathbf{x})\\, \\mathbf{X}_I$ 及其到评估点 $\\mathbf{x}$ 的欧几里得距离，得到 $e_{\\mathrm{LIN}}$。\n\n7.  **最终诊断**：根据误差计算，确定布尔指标 $b_{\\mathrm{PU}} = (e_{\\mathrm{PU}} \\le 10^{-8})$ 和 $b_{\\mathrm{LIN}} = (e_{\\mathrm{LIN}} \\le 10^{-8})$。最终的诊断代码 $d$ 被赋值如下：\n    -   如果 $b_{\\mathrm{PU}}$ 和 $b_{\\mathrm{LIN}}$ 均为真，则 $d=0$（成功）。\n    -   否则（如果在支持充足且矩阵良态的情况下任一测试失败），则 $d=3$（再生失败）。\n\n将此程序系统地应用于每个测试案例，以生成所需的输出。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Moving Least Squares problem for a set of test cases.\n    \"\"\"\n    test_cases = [\n        # (x_eval, R, h, visibility_flag)\n        ((-0.5, -0.5), 0.45, 0.2, False),\n        ((-0.05, -0.05), 0.15, 0.2, False),\n        ((-0.05, -0.05), 0.35, 0.2, True),\n        ((0.2, -0.2), 0.3, 0.2, True),\n        ((-0.05, -0.05), 0.25, 0.2, True),\n    ]\n\n    results = []\n    \n    TOL = 1e-8\n    COND_THRESH = 1e12\n\n    def weight_function(r):\n        if 0 = r = 1:\n            return (1 - r)**4 * (4 * r + 1)\n        return 0.0\n\n    def is_visible(p1, p2):\n        x1, y1 = p1\n        x2, y2 = p2\n        eps = 1e-9\n        \n        # Obstructed if one point is in the open 2nd quadrant and the other in the open 4th.\n        # Q2: x  0, y > 0\n        # Q4: x > 0, y  0\n        case1 = (x1  -eps and y1 > eps) and (x2 > eps and y2  -eps)\n        case2 = (x1 > eps and y1  -eps) and (x2  -eps and y2 > eps)\n        \n        return not (case1 or case2)\n\n    for x_eval, R, h, visibility_flag in test_cases:\n        # Step 1: Nodal Discretization\n        n_points = int(round(2.0 / h)) + 1\n        coords = np.linspace(-1.0, 1.0, n_points)\n        all_nodes = []\n        for x_node in coords:\n            for y_node in coords:\n                # Domain D: x = 0 or y = 0\n                if x_node = TOL or y_node = TOL:\n                    all_nodes.append(np.array([x_node, y_node]))\n        \n        x_eval = np.array(x_eval)\n        \n        # Step 2  3: Find contributing nodes (support + visibility)\n        contributing_nodes = []\n        for X_I in all_nodes:\n            dist = np.linalg.norm(x_eval - X_I)\n            if dist = R:\n                if visibility_flag and not is_visible(x_eval, X_I):\n                    continue\n                \n                r = dist / R\n                w_I = weight_function(r)\n                if w_I > 0:\n                    contributing_nodes.append({'pos': X_I, 'w': w_I})\n                    \n        # Step 4: Diagnostic Check for Sufficient Support\n        if len(contributing_nodes)  3:\n            results.append([False, False, 1])\n            continue\n\n        # Step 5: Moment Matrix Construction and Conditioning\n        A = np.zeros((3, 3))\n        for node in contributing_nodes:\n            p_I = np.array([1.0, node['pos'][0], node['pos'][1]])\n            A += node['w'] * np.outer(p_I, p_I)\n        \n        if np.linalg.cond(A) > COND_THRESH:\n            results.append([False, False, 2])\n            continue\n            \n        # Step 6: Shape Function and Property Verification\n        p_eval = np.array([1.0, x_eval[0], x_eval[1]])\n        try:\n            b = np.linalg.solve(A, p_eval)\n        except np.linalg.LinAlgError:\n            results.append([False, False, 2]) # Should be caught by cond, but as a safeguard\n            continue\n\n        phi_sum = 0.0\n        phi_X_sum = np.zeros(2)\n\n        for node in contributing_nodes:\n            p_I = np.array([1.0, node['pos'][0], node['pos'][1]])\n            phi_I = np.dot(b, p_I) * node['w']\n            phi_sum += phi_I\n            phi_X_sum += phi_I * node['pos']\n            \n        e_PU = abs(phi_sum - 1.0)\n        e_LIN = np.linalg.norm(phi_X_sum - x_eval)\n        \n        b_PU = (e_PU = TOL)\n        b_LIN = (e_LIN = TOL)\n\n        # Step 7: Final Diagnostics\n        if b_PU and b_LIN:\n            d = 0\n        else:\n            d = 3\n        \n        results.append([b_PU, b_LIN, d])\n\n    # Format the final output string\n    # E.g., [ [True, True, 0], [False, False, 1], ... ]\n    output_str = \"[ \" + \", \".join(map(str, results)) + \" ]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}