{
    "hands_on_practices": [
        {
            "introduction": "在 $p$-自适应有限元方法中，一个核心的挑战是如何处理相邻单元具有不同多项式次数（即非协调网格）的情况。为了确保解的连续性，必须在共享边界上施加约束，将高阶单元的自由度“悬挂”在低阶单元的自由度上。本练习将引导你推导这些约束背后的数学原理，通过构建一个将 $p=3$ 单元的边节点值与 $p=1$ 单元的边节点值联系起来的“延长”矩阵，从而深入理解 $hp$-自适应的底层力学机制 。",
            "id": "3571687",
            "problem": "考虑计算固体力学网格中共享一条直边的两个二维有限元。采用共享边的常用参考参数化，坐标为 $s \\in [-1,1]$，其中 $s=-1$ 和 $s=1$ 对应于该边在全局方向上的左右顶点。左单元是多项式次数为 $p=3$ 的单元，右单元是多项式次数为 $p=1$ 的单元。假设在共享边上，自由度的表示是纯标量的，并对应于位移场的迹。\n\n在次数 $p=3$ 的单元上，假设边迹空间是至多三次的多项式全空间，并且边自由度由沿该边的四个 Legendre–Gauss–Lobatto 点上的节点值定义。根据标准定义，对于次数 $p=3$，Legendre–Gauss–Lobatto 节点是端点 $s=\\pm 1$ 以及 $(1-s^{2}) P_{3}'(s)$ 的根所对应的两个内点，其中 $P_{3}(s)$ 是 3 次 Legendre 多项式。在次数 $p=1$ 的单元上，假设边迹空间是至多一次的多项式空间，其自由度由 $s=-1$ 和 $s=1$ 处的节点值给出。\n\n通过要求次数 $p=3$ 一侧的迹是次数 $p=1$ 的迹沿该边向高阶节点空间的延长，来施加位移迹在共享边上的 $C^{0}$ 连续性。具体来说，令限制算子通过保留端点值将次数 $p=3$ 的节点迹映射到唯一的 $\\leq 1$ 次多项式，并令延长算子通过在四个 Legendre–Gauss–Lobatto 节点上计算 $\\leq 1$ 次插值多项式的值，将次数 $p=1$ 的节点迹映射到次数 $p=3$ 的节点迹。\n\n推导显式的 $4 \\times 2$ 约束（延长）矩阵 $\\mathbf{P}$，使得如果 $\\mathbf{u}^{(1)} = \\begin{pmatrix} u(-1) \\\\ u(1) \\end{pmatrix}$ 表示次数 $p=1$ 的边自由度，而 $\\mathbf{u}^{(3)} = \\begin{pmatrix} u(s_{1}) \\\\ u(s_{2}) \\\\ u(s_{3}) \\\\ u(s_{4}) \\end{pmatrix}$ 表示按四个 Legendre–Gauss–Lobatto 节点 $s_{1}, s_{2}, s_{3}, s_{4}$ 从左到右排序的次数 $p=3$ 的边自由度，则有 $\\mathbf{u}^{(3)} = \\mathbf{P}\\,\\mathbf{u}^{(1)}$。\n\n你的推导必须从 Legendre 多项式 $P_{3}(s)$、作为集合 $\\{-1,1\\}$ 与 $(1-s^{2})P_{3}'(s)$ 的根的并集的 Legendre–Gauss–Lobatto 节点，以及沿该边的 $\\leq 1$ 次 Lagrange 形函数的定义开始。以精确形式给出最终矩阵 $\\mathbf{P}$。不需要四舍五入。最终答案必须表示为单一矩阵 $\\mathbf{P}$，并在出现根式时使用精确根式。",
            "solution": "我们首先对迹空间和节点进行形式化。共享边由 $s \\in [-1,1]$ 参数化。次数 $p=3$ 的迹空间是多项式空间 $\\mathcal{P}_{3}([-1,1])$，边自由度是 Legendre–Gauss–Lobatto 节点上的节点值。根据定义，对于多项式次数 $p$，Legendre–Gauss–Lobatto 节点包含端点 $s=\\pm 1$ 和由 $(1-s^{2}) P_{p}'(s)$ 的根给出的 $p-1$ 个内部点，其中 $P_{p}(s)$ 是 $p$ 次 Legendre 多项式。\n\n对于 $p=3$，我们首先写出 Legendre 多项式\n$$\nP_{3}(s) = \\frac{1}{2}\\left(5 s^{3} - 3 s\\right).\n$$\n其导数为\n$$\nP_{3}'(s) = \\frac{1}{2}\\left(15 s^{2} - 3\\right) = \\frac{3}{2}\\left(5 s^{2} - 1\\right).\n$$\n内部 Legendre–Gauss–Lobatto 节点是 $(1-s^{2}) P_{3}'(s) = 0$ 在 $(-1,1)$ 区间内的根。排除端点 $s=\\pm 1$（它们也是 $(1-s^{2})$ 的零点），内部节点满足 $P_{3}'(s)=0$，这给出\n$$\n\\frac{3}{2}\\left(5 s^{2} - 1\\right) = 0 \\quad \\Rightarrow \\quad 5 s^{2} - 1 = 0 \\quad \\Rightarrow \\quad s^{2} = \\frac{1}{5} \\quad \\Rightarrow \\quad s = \\pm \\frac{1}{\\sqrt{5}}.\n$$\n因此，对于次数 $p=3$ 的 Legendre–Gauss–Lobatto 节点是\n$$\ns_{1} = -1, \\quad s_{2} = -\\frac{1}{\\sqrt{5}}, \\quad s_{3} = \\frac{1}{\\sqrt{5}}, \\quad s_{4} = 1.\n$$\n\n在次数 $p=1$ 的单元上，迹空间是 $\\mathcal{P}_{1}([-1,1])$。一个位移迹 $u^{(1)}(s) \\in \\mathcal{P}_{1}([-1,1])$ 由其在端点处的值唯一确定。使用与端点相关联的标准 1 次 Lagrange 形函数，我们有\n$$\nN_{L}(s) = \\frac{1-s}{2}, \\qquad N_{R}(s) = \\frac{1+s}{2},\n$$\n因此对于给定的节点值 $u(-1)$ 和 $u(1)$，线性插值函数为\n$$\nu^{(1)}(s) = u(-1)\\,N_{L}(s) + u(1)\\,N_{R}(s) = u(-1)\\,\\frac{1-s}{2} + u(1)\\,\\frac{1+s}{2}.\n$$\n\n从次数 $p=1$ 到次数 $p=3$ 沿该边的延长算子，是通过在次数 $p=3$ 的节点上计算此线性插值函数的值来定义的。将 $p=1$ 的边自由度向量记为\n$$\n\\mathbf{u}^{(1)} = \\begin{pmatrix} u(-1) \\\\ u(1) \\end{pmatrix},\n$$\n并将 $p=3$ 的边自由度向量（以节点形式）记为\n$$\n\\mathbf{u}^{(3)} = \\begin{pmatrix} u(s_{1}) \\\\ u(s_{2}) \\\\ u(s_{3}) \\\\ u(s_{4}) \\end{pmatrix}.\n$$\n根据延长的定义，我们有\n$$\nu(s_{i}) = u^{(1)}(s_{i}) = u(-1)\\,N_{L}(s_{i}) + u(1)\\,N_{R}(s_{i}), \\quad i=1,2,3,4.\n$$\n因此，延长矩阵 $\\mathbf{P}$ 的行由数对 $\\big(N_{L}(s_{i}),\\,N_{R}(s_{i})\\big)$ 给出。我们在节点 $s_{1}=-1$，$s_{2}=-1/\\sqrt{5}$，$s_{3}=1/\\sqrt{5}$，$s_{4}=1$ 处显式计算这些值。\n\n对于 $s_{1}=-1$：\n$$\nN_{L}(-1) = \\frac{1-(-1)}{2} = 1, \\qquad N_{R}(-1) = \\frac{1+(-1)}{2} = 0.\n$$\n\n对于 $s_{2}=-\\frac{1}{\\sqrt{5}}$：\n$$\nN_{L}\\!\\left(-\\frac{1}{\\sqrt{5}}\\right) = \\frac{1+\\frac{1}{\\sqrt{5}}}{2} = \\frac{1}{2}\\left(1 + \\frac{1}{\\sqrt{5}}\\right), \\qquad\nN_{R}\\!\\left(-\\frac{1}{\\sqrt{5}}\\right) = \\frac{1-\\frac{1}{\\sqrt{5}}}{2} = \\frac{1}{2}\\left(1 - \\frac{1}{\\sqrt{5}}\\right).\n$$\n\n对于 $s_{3}=\\frac{1}{\\sqrt{5}}$：\n$$\nN_{L}\\!\\left(\\frac{1}{\\sqrt{5}}\\right) = \\frac{1-\\frac{1}{\\sqrt{5}}}{2} = \\frac{1}{2}\\left(1 - \\frac{1}{\\sqrt{5}}\\right), \\qquad\nN_{R}\\!\\left(\\frac{1}{\\sqrt{5}}\\right) = \\frac{1+\\frac{1}{\\sqrt{5}}}{2} = \\frac{1}{2}\\left(1 + \\frac{1}{\\sqrt{5}}\\right).\n$$\n\n对于 $s_{4}=1$：\n$$\nN_{L}(1) = \\frac{1-1}{2} = 0, \\qquad N_{R}(1) = \\frac{1+1}{2} = 1.\n$$\n\n汇总这些行，满足 $\\mathbf{u}^{(3)} = \\mathbf{P}\\,\\mathbf{u}^{(1)}$ 的延长（约束）矩阵 $\\mathbf{P}$ 是\n$$\n\\mathbf{P} =\n\\begin{pmatrix}\n1 & 0 \\\\\n\\dfrac{1}{2}\\left(1 + \\dfrac{1}{\\sqrt{5}}\\right) & \\dfrac{1}{2}\\left(1 - \\dfrac{1}{\\sqrt{5}}\\right) \\\\\n\\dfrac{1}{2}\\left(1 - \\dfrac{1}{\\sqrt{5}}\\right) & \\dfrac{1}{2}\\left(1 + \\dfrac{1}{\\sqrt{5}}\\right) \\\\\n0 & 1\n\\end{pmatrix}.\n$$\n\n该矩阵通过将四个次数 $p=3$ 的边节点值表示为由相邻次数 $p=1$ 单元上的两个端点自由度所确定的唯一 $\\leq 1$ 次边迹的延长，来施加 $C^{0}$ 连续性约束。与此构造一致的限制算子是仅保留端点值的映射；在节点坐标下，它是选择第 1 和第 4 个分量的 $2 \\times 4$ 矩阵。然而，所要求的将次数 $p=3$ 的迹与次数 $p=1$ 的迹联系起来的约束矩阵是上面计算的延长矩阵 $\\mathbf{P}$。",
            "answer": "$$\\boxed{\\begin{pmatrix}\n1 & 0 \\\\\n\\frac{1}{2}\\left(1 + \\frac{1}{\\sqrt{5}}\\right) & \\frac{1}{2}\\left(1 - \\frac{1}{\\sqrt{5}}\\right) \\\\\n\\frac{1}{2}\\left(1 - \\frac{1}{\\sqrt{5}}\\right) & \\frac{1}{2}\\left(1 + \\frac{1}{\\sqrt{5}}\\right) \\\\\n0 & 1\n\\end{pmatrix}}$$"
        },
        {
            "introduction": "$hp$-自适应的关键决策是在 $h$-细化（单元加密）和 $p$-细化（提升多项式次数）之间做出选择。一般而言，当解在局部是光滑时，$p$-细化效率更高；而当解存在奇异性（如裂纹尖端或材料界面处的“扭结”）时，$h$-细化是必需的。本练习通过一个实际的编码任务，让你实现一个基于解的谱特性（勒让德多项式系数的衰减率）的自适应指示器，以自动区分这两种情况并做出智能的细化决策 。",
            "id": "3571718",
            "problem": "考虑一根长度为 $L=1$、横截面积恒为 $A=1$ 的一维线弹性杆，该杆受到轴向体力场 $f(x)$ 的作用，且右边界无牵引力。该杆由两个均匀层组成，其杨氏模量 $E(x)$ 为分段常数，具体为：当 $0 \\le x < x_I$ 时，$E(x)=E_1$；当 $x_I \\le x \\le 1$ 时，$E(x)=E_2$，其中 $0<x_I<1$ 是界面位置。采用线性本构关系的小应变弹性理论的控制平衡方程为\n$$\\frac{d}{dx}\\left(E(x)A\\frac{du}{dx}\\right)=f(x),$$\n边界条件为 $u(0)=0$ 和 $E(1)A\\,u'(1)=0$。假设 $f(x)=f_0$ 是一个正的常数。\n\n对于一个由不重叠单元 $\\{[x_{e,\\mathrm{L}},x_{e,\\mathrm{R}}]\\}$ 组成的、对区间 $[0,1]$ 进行剖分的给定网格，基于单元位移场 $u(x)$ 的 Legendre 多项式展开，为每个单元定义模态衰减指标。令 $\\xi \\in [-1,1]$ 为参考坐标，$x(\\xi)=\\frac{x_{e,\\mathrm{R}}-x_{e,\\mathrm{L}}}{2}(\\xi+1)+x_{e,\\mathrm{L}}$ 为仿射映射。参考场 $u_e(\\xi)$ 定义为 $u_e(\\xi)=u(x(\\xi))$。令 $P_\\ell(\\xi)$ 为 $\\ell$ 次 Legendre 多项式，在 $[-1,1]$ 上带单位权重正交。定义 $L^2$ 投影系数 $a_\\ell$ 如下：\n$$a_\\ell=\\frac{2\\ell+1}{2}\\int_{-1}^{1}u_e(\\xi)P_\\ell(\\xi)\\,d\\xi,\\quad \\ell=0,1,\\dots,p,$$\n其中 $p$ 是指标计算中考虑的最高局部多项式次数。单元 $e$ 的模态衰减斜率 $m_e$ 通过对 $\\ell=1,\\dots,p$ 时的 $\\log_{10}(|a_\\ell|)$ 与 $\\ell$ 进行最小二乘线性拟合得到，即计算 $m_e$ 使得：\n$$\\log_{10}(|a_\\ell|)\\approx m_e\\,\\ell + b_e,$$\n此拟合在最小二乘意义下进行，并在对数函数内部加入一个小的正则化项 $\\varepsilon$ 以避免在 $a_\\ell=0$ 处出现奇异性。\n\n决策规则：如果 $m_e\\le m_{\\mathrm{crit}}$（更负的斜率表示更快的衰减），则对单元 $e$ 选择 $p$-加密；否则，选择 $h$-加密。\n\n任务：\n1. 从平衡方程和边界条件出发，推导当 $f(x)=f_0$ 且 $E(x)$ 为在 $x_I$ 处有单一界面的分段常数时，位移 $u(x)$ 的分段闭式解。需确保在 $x_I$ 处位移的连续性和轴向力 $E(x)A\\,u'(x)$ 的连续性。\n2. 在每个单元中，使用 $Q$ 阶 Gaussian-Legendre 求积，通过上述积分近似计算 $\\ell=0,\\dots,p$ 的系数 $a_\\ell$。然后，使用 $\\log_{10}(|a_\\ell|+\\varepsilon)$，通过对 $\\ell=1,\\dots,p$ 进行最小二乘拟合来计算斜率 $m_e$。其中正则化项定义为 $\\varepsilon=\\max_{\\ell}|a_\\ell|\\times 10^{-14}+10^{-30}$。\n3. 应用具有指定临界斜率 $m_{\\mathrm{crit}}$ 的决策规则，并为每个测试用例中的每个单元输出一个布尔值，指示是进行 $p$-加密（True）还是 $h$-加密（False）。\n\n单位：物理参数 $E_1$ 和 $E_2$ 的单位是帕斯卡（Pascals），$f_0$ 的单位是牛顿每立方米（Newtons per cubic meter）。最终程序输出的是无单位的布尔值。无需进行单位转换。\n\n测试套件：\n- 测试用例 1（单一单元，界面位于单元内部，中等对比度）：$E_1=200\\times 10^9$, $E_2=50\\times 10^9$, $x_I=0.35$, $f_0=10^6$, 单元 $[(0.0,1.0)]$, $p=8$, $Q=64$, $m_{\\mathrm{crit}}=-0.8$。\n- 测试用例 2（两个单元，与界面对齐，中等对比度）：与测试用例 1 具有相同的 $E_1$, $E_2$, $x_I$, 和 $f_0$；单元 $[(0.0,0.35),(0.35,1.0)]$, $p=8$, $Q=64$, $m_{\\mathrm{crit}}=-0.8$。\n- 测试用例 3（两个单元，与界面未对齐，中等对比度）：与测试用例 1 具有相同的 $E_1$, $E_2$, $x_I$, 和 $f_0$；单元 $[(0.0,0.5),(0.5,1.0)]$, $p=8$, $Q=64$, $m_{\\mathrm{crit}}=-0.8$。\n- 测试用例 4（单一单元，界面位于单元内部，更高对比度，边界次数情况）：$E_1=200\\times 10^9$, $E_2=5\\times 10^9$, $x_I=0.65$, $f_0=10^6$, 单元 $[(0.0,1.0)]$, $p=3$, $Q=24$, $m_{\\mathrm{crit}}=-0.8$。\n\n您的程序应生成单行输出，其中包含四个测试用例中所有单元的决策，按顺序排列，形式为方括号括起来的逗号分隔列表。顺序是每个测试用例内按单元排列，且测试用例按上述顺序处理。例如，输出格式必须与 $[b_1,b_2,\\dots,b_6]$ 完全一样，其中每个 $b_k$ 是 True 或 False。",
            "solution": "该问题是有效的，因为它在线弹性理论中有科学依据，数学上是适定的，客观的，并且包含了推导唯一解和执行指定数值任务所需的所有数据。\n\n求解过程分三个阶段进行：首先，推导位移场 $u(x)$ 的解析表达式；其次，描述为每个单元计算模态衰减指标 $m_e$ 的数值过程；第三，应用决策规则来确定适当的网格自适应策略。\n\n**1. 解析位移场 $u(x)$ 的推导**\n\n一维弹性杆的控制平衡方程如下：\n$$\n\\frac{d}{dx}\\left(E(x)A\\frac{du}{dx}\\right) = f(x)\n$$\n给定恒定的横截面积 $A=1$ 和恒定的体力 $f(x)=f_0$，方程得以简化。区域 $[0, 1]$ 由两种材料组成，其杨氏模量为分段常数：当 $0 \\le x < x_I$ 时，$E(x) = E_1$；当 $x_I \\le x \\le 1$ 时，$E(x) = E_2$。我们在每个区域分别求解该方程。\n\n对于区域 1（$0 \\le x < x_I$）：\n$$\nE_1 \\frac{d^2u_1}{dx^2} = f_0\n$$\n对 $x$ 积分两次，得到位移 $u_1(x)$ 的通解：\n$$\nu_1(x) = \\frac{f_0}{2E_1}x^2 + C_1 x + C_2\n$$\n\n对于区域 2（$x_I \\le x \\le 1$）：\n$$\nE_2 \\frac{d^2u_2}{dx^2} = f_0\n$$\n积分两次得到位移 $u_2(x)$ 的通解：\n$$\nu_2(x) = \\frac{f_0}{2E_2}x^2 + C_3 x + C_4\n$$\n存在 4 个未知的积分常数（$C_1, C_2, C_3, C_4$），它们通过应用边界和界面条件来确定。\n\n边界条件为：\n1.  左端固定位移：$u(0)=0$。将此应用于 $u_1(x)$：\n    $u_1(0) = C_2 = 0$。\n2.  右端无牵引力：$E(1)A u'(1)=0$。由于 $A=1$ 且 $E(1)=E_2$，此条件简化为 $E_2 u_2'(1)=0$。\n    $u_2(x)$ 的导数为 $u_2'(x) = \\frac{f_0}{E_2}x + C_3$。\n    $E_2 \\left(\\frac{f_0}{E_2}(1) + C_3\\right) = 0 \\implies f_0 + E_2 C_3 = 0 \\implies C_3 = -\\frac{f_0}{E_2}$。\n\n在 $x=x_I$ 处的界面条件确保了两种材料层之间的相容性：\n3.  位移连续性：$u_1(x_I) = u_2(x_I)$。\n4.  轴力连续性：$E_1 A u_1'(x_I) = E_2 A u_2'(x_I)$。由于 $A=1$：\n    $E_1 \\left(\\frac{f_0}{E_1}x_I + C_1\\right) = E_2 \\left(\\frac{f_0}{E_2}x_I + C_3\\right)$。\n    代入 $C_3 = -f_0/E_2$：\n    $f_0 x_I + E_1 C_1 = E_2 \\left(\\frac{f_0}{E_2}x_I - \\frac{f_0}{E_2}\\right) = f_0 x_I - f_0$。\n    $E_1 C_1 = -f_0 \\implies C_1 = -\\frac{f_0}{E_1}$。\n\n最后，我们使用位移连续性条件 (3) 来求 $C_4$。\n$u_1(x_I) = \\frac{f_0}{2E_1}x_I^2 - \\frac{f_0}{E_1}x_I = \\frac{f_0}{E_1}\\left(\\frac{x_I^2}{2} - x_I\\right)$。\n$u_2(x_I) = \\frac{f_0}{2E_2}x_I^2 - \\frac{f_0}{E_2}x_I + C_4 = \\frac{f_0}{E_2}\\left(\\frac{x_I^2}{2} - x_I\\right) + C_4$。\n令两者相等可得：\n$C_4 = \\frac{f_0}{E_1}\\left(\\frac{x_I^2}{2} - x_I\\right) - \\frac{f_0}{E_2}\\left(\\frac{x_I^2}{2} - x_I\\right) = f_0\\left(\\frac{1}{E_1} - \\frac{1}{E_2}\\right)\\left(\\frac{x_I^2}{2} - x_I\\right)$。\n\n位移场 $u(x)$ 的完整分段解析解为：\n$$\nu(x) =\n\\begin{cases}\nu_1(x) = \\frac{f_0}{E_1}\\left(\\frac{x^2}{2} - x\\right) & \\text{当 } 0 \\le x < x_I \\text{ 时} \\\\\nu_2(x) = \\frac{f_0}{E_2}\\left(\\frac{x^2}{2} - x\\right) + f_0\\left(\\frac{1}{E_1} - \\frac{1}{E_2}\\right)\\left(\\frac{x_I^2}{2} - x_I\\right) & \\text{当 } x_I \\le x \\le 1 \\text{ 时}\n\\end{cases}\n$$\n该解是连续的，但当 $E_1 \\neq E_2$ 时，其导数 $u'(x)$ 在 $x=x_I$ 处不连续，在位移剖面中产生一个“尖点”。这种缺乏光滑性的特点是模态衰减指标旨在检测的关键特征。\n\n**2. 模态衰减指标 $m_e$ 的数值计算**\n\n指标 $m_e$ 量化了单元内解的 Legendre 谱系数的衰减率。快速衰减（$m_e$ 为较大的负值）意味着解是光滑的，能被多项式很好地近似，因此适用于 $p$-加密（提高多项式次数）。慢速衰减（$m_e$ 为较小的负值）则表明存在奇异点或尖锐特征，对此 $h$-加密（细分单元）更为有效。\n\n对于每个单元 $e = [x_{e,\\mathrm{L}}, x_{e,\\mathrm{R}}]$，计算流程如下：\n1.  **计算 Legendre 系数 $a_\\ell$**：系数 $a_\\ell$ 是单元的参考位移场 $u_e(\\xi)$ 在 Legendre 多项式 $P_\\ell(\\xi)$ 上的投影。该积分使用一个 $Q$ 点 Gaussian-Legendre 求积法则进行近似，其求积点 $\\xi_q$ 和权重 $w_q$ 定义在参考区间 $[-1, 1]$ 上。\n    $$\n    a_\\ell \\approx \\frac{2\\ell+1}{2} \\sum_{q=1}^{Q} u(x(\\xi_q)) P_\\ell(\\xi_q) w_q\n    $$\n    物理坐标 $x(\\xi_q)$ 通过仿射映射 $x(\\xi)=\\frac{x_{e,\\mathrm{R}}-x_{e,\\mathrm{L}}}{2}(\\xi+1)+x_{e,\\mathrm{L}}$ 获得。系数的计算范围是 $\\ell=0, 1, \\dots, p$。\n\n2.  **正则化**：为避免对数值上为零的系数计算 $\\log(0)$ 导致的问题，会加上一个很小的正值 $\\varepsilon$。首先，计算系数向量 $[a_0, a_1, \\dots, a_p]$。然后，正则化项计算为 $\\varepsilon=\\max_{\\ell=0,\\dots,p}|a_\\ell|\\times 10^{-14}+10^{-30}$。\n\n3.  **最小二乘拟合**：我们求解能最佳拟合数据点 $(\\ell, \\log_{10}(|a_\\ell|+\\varepsilon))$（其中 $\\ell=1, \\dots, p$）的直线的斜率 $m_e$。这是一个标准的线性回归问题。斜率 $m_e$ 通过求解代表该拟合的线性系统的最小二乘解来计算。这可以利用数值库轻易完成。\n\n**3. 决策逻辑与实现**\n\n最后一步是为每个测试用例中的每个单元应用决策规则。\n对于给定的临界斜率 $m_{\\mathrm{crit}}$，自适应决策如下：\n-   如果 $m_e \\le m_{\\mathrm{crit}}$：谱衰减快。选择 $p$-加密（输出 `True`）。\n-   如果 $m_e > m_{\\mathrm{crit}}$：谱衰减慢。选择 $h$-加密（输出 `False`）。\n\n整个过程用 Python 实现。一个函数根据材料参数生成解析解函数 $u(x)$。另一个函数利用 `numpy` 进行数组操作，`numpy.polynomial.legendre.leggauss` 进行求积，`scipy.special.legendre` 进行多项式求值，以及 `numpy.polyfit` 进行最小二乘拟合，从而协调计算给定单元的 $m_e$。主循环遍历所提供的测试用例，为每个单元计算指标，应用决策规则，并汇总布尔结果以供最终输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import legendre\nfrom numpy.polynomial.legendre import leggauss\n\ndef get_analytical_solution_u(E1, E2, xI, f0):\n    \"\"\"\n    Creates and returns the analytical solution function u(x) for the given parameters.\n    \"\"\"\n    # Constant C4 is derived from continuity of displacement at x=xI\n    C4 = f0 * (1/E1 - 1/E2) * (xI**2 / 2 - xI)\n\n    def u(x):\n        \"\"\"\n        Calculates the displacement u at position(s) x.\n        x can be a single float or a numpy array.\n        \"\"\"\n        x_arr = np.asarray(x, dtype=float)\n        res = np.zeros_like(x_arr, dtype=float)\n        \n        # Region 1: 0 = x  xI\n        mask1 = x_arr  xI\n        res[mask1] = (f0 / E1) * (x_arr[mask1]**2 / 2 - x_arr[mask1])\n\n        # Region 2: xI = x = 1\n        mask2 = x_arr >= xI\n        res[mask2] = (f0 / E2) * (x_arr[mask2]**2 / 2 - x_arr[mask2]) + C4\n        \n        return res\n        \n    return u\n\ndef compute_modal_decay_slope(u_func, element_bounds, p, Q):\n    \"\"\"\n    Computes the modal decay slope m_e for a single element.\n    \"\"\"\n    x_L, x_R = element_bounds\n    \n    # Get Gaussian quadrature points and weights for interval [-1, 1]\n    xi_q, w_q = leggauss(Q)\n    \n    # Map reference coordinates xi_q to physical coordinates x_q\n    x_q = (x_R - x_L) / 2 * (xi_q + 1) + x_L\n    \n    # Evaluate solution at physical quadrature points\n    u_q = u_func(x_q)\n    \n    # Compute Legendre projection coefficients a_l for l=0,...,p\n    a_coeffs = np.zeros(p + 1)\n    for l_val in range(p + 1):\n        P_l = legendre(l_val)\n        integrand = u_q * P_l(xi_q)\n        integral = np.sum(w_q * integrand)\n        a_coeffs[l_val] = (2 * l_val + 1) / 2 * integral\n        \n    # Compute regularization term epsilon\n    epsilon = np.max(np.abs(a_coeffs)) * 1e-14 + 1e-30\n    \n    # Prepare data for least-squares fit for l=1,...,p\n    l_vals = np.arange(1, p + 1)\n    y_vals = np.log10(np.abs(a_coeffs[1:]) + epsilon)\n    \n    # Perform linear least-squares fit to find the slope m_e\n    m_e, _ = np.polyfit(l_vals, y_vals, 1)\n    \n    return m_e\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'E1': 200e9, 'E2': 50e9, 'xI': 0.35, 'f0': 1e6, 'elements': [(0.0, 1.0)], 'p': 8, 'Q': 64, 'm_crit': -0.8},\n        {'E1': 200e9, 'E2': 50e9, 'xI': 0.35, 'f0': 1e6, 'elements': [(0.0, 0.35), (0.35, 1.0)], 'p': 8, 'Q': 64, 'm_crit': -0.8},\n        {'E1': 200e9, 'E2': 50e9, 'xI': 0.35, 'f0': 1e6, 'elements': [(0.0, 0.5), (0.5, 1.0)], 'p': 8, 'Q': 64, 'm_crit': -0.8},\n        {'E1': 200e9, 'E2': 5e9, 'xI': 0.65, 'f0': 1e6, 'elements': [(0.0, 1.0)], 'p': 3, 'Q': 24, 'm_crit': -0.8}\n    ]\n\n    results = []\n    for case in test_cases:\n        # Generate the analytical solution function for the current case\n        u_func = get_analytical_solution_u(case['E1'], case['E2'], case['xI'], case['f0'])\n        \n        # Process each element in the test case's mesh\n        for element in case['elements']:\n            m_e = compute_modal_decay_slope(u_func, element, case['p'], case['Q'])\n            # Apply the decision rule\n            decision = m_e = case['m_crit']\n            results.append(decision)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "我们可以将自适应网格设计提升到一个全局优化的层面，将其视为一个资源分配问题：如何在给定的计算预算（总自由度）下，为网格中的每个单元分配最佳的多项式次数 $p_K$，从而使全局误差最小化？本练习将指导你将此问题构建为一个凸优化模型，并通过求解 Karush-Kuhn-Tucker (KKT) 条件来找到最优的多项式次数分布。这让你能够体验到如何运用优化理论来设计高效的计算网格 。",
            "id": "3571693",
            "problem": "考虑一个固定的协调有限元网格，其单元集由索引 $K \\in \\{1,\\dots,N_e\\}$ 标记。在网格尺寸和多项式次数自适应（通常称为 $h$-$p$ 自适应）的背景下，假设每个单元 $K$ 被分配一个多项式次数 $p_K$，并且为了优化的目的，该次数被视为区间 $[p_{\\min},p_{\\max}]$ 内的连续变量。假设全局后验误差估计子的一个凸代理模型是单元贡献 $E_K(p_K)$ 的总和，其中 $E_K(p_K) = A_K \\exp(-b_K p_K)$，且 $A_K  0$ 和 $b_K  0$。设自由度（DOF）预算近似为一个线性函数 $\\sum_{K=1}^{N_e} c_K p_K \\le B$，其中 $c_K  0$ 且总预算 $B  0$。目标是分配多项式次数 $p_K$，以在自由度预算和边界约束下最小化全局代理。\n\n按如下方式构建全局连续松弛优化问题：最小化\n$$\nJ(\\mathbf{p}) = \\sum_{K=1}^{N_e} A_K \\exp(-b_K p_K),\n$$\n约束条件为\n$$\n\\sum_{K=1}^{N_e} c_K p_K \\le B, \\quad p_{\\min} \\le p_K \\le p_{\\max} \\quad \\text{for all } K,\n$$\n其中 $\\mathbf{p} = (p_1,\\dots,p_{N_e})$。推导并求解此凸优化问题的 Karush-Kuhn-Tucker (KKT) 条件。您的程序必须求解最优多项式次数 $\\{p_K\\}$ 和与自由度预算约束相关的拉格朗日乘子 $\\lambda$，并为每个测试用例返回最优的 $\\mathbf{p}$ 和最优目标值 $J(\\mathbf{p})$。\n\n从一个与上下文相符的基本准则开始：一个经过充分检验的观察结果是，当解在单元上局部足够光滑时，在合适的能量范数下，单元误差会随着多项式次数 $p_K$ 的增加呈指数级下降，并且对于中等范围的 $p_K$，自由度数量可以近似为 $p_K$ 的线性函数。纯粹用数学术语构建优化问题，并推导 KKT 条件，而不依赖于凸优化基础之外的捷径公式。\n\n您的程序必须实现一个鲁棒的算法，该算法：\n- 计算满足 KKT 系统的 $\\{p_K\\}$ 和 $\\lambda$，包括在适当时处理边界激活 $p_K = p_{\\min}$ 或 $p_K = p_{\\max}$ 的情况。\n- 通过验证自由度预算 $B$ 位于可行范围 $[\\sum_{K=1}^{N_e} c_K p_{\\min}, \\sum_{K=1}^{N_e} c_K p_{\\max}]$ 内，确保科学上的真实性和可行性；如果不可行，程序必须通过返回所有条目均为 $\\texttt{nan}$ 的列表来指示不可行性，并仍然产生结果。\n- 基于加权自由度总和对 $\\lambda$ 的单调依赖性，使用单调求根策略来确定 $\\lambda$。\n\n物理单位不涉及此纯数学公式，因此不需要。不使用角度。不使用百分比。\n\n测试套件：\n为以下测试用例提供解决方案。在每个案例中，$N_e$ 由数组的长度隐式给出。\n\n- 案例 1（顺利路径，预期为内部解，部分边界可能未激活）：\n  - $A = [\\,0.8,\\,1.2,\\,0.5,\\,1.5,\\,1.0\\,]$\n  - $b = [\\,0.9,\\,0.6,\\,1.1,\\,0.7,\\,0.8\\,]$\n  - $c = [\\,1.0,\\,1.0,\\,1.5,\\,0.7,\\,1.2\\,]$\n  - $p_{\\min} = 1.0$\n  - $p_{\\max} = 5.0$\n  - $B = 8.0$\n\n- 案例 2（边界条件，自由度预算等于最小可行总和）：\n  - $A = [\\,0.8,\\,1.2,\\,0.5,\\,1.5,\\,1.0\\,]$\n  - $b = [\\,0.9,\\,0.6,\\,1.1,\\,0.7,\\,0.8\\,]$\n  - $c = [\\,1.0,\\,1.0,\\,1.5,\\,0.7,\\,1.2\\,]$\n  - $p_{\\min} = 1.0$\n  - $p_{\\max} = 5.0$\n  - $B = 5.4$\n\n- 案例 3（边界条件，自由度预算等于最大可行总和）：\n  - $A = [\\,0.8,\\,1.2,\\,0.5,\\,1.5,\\,1.0\\,]$\n  - $b = [\\,0.9,\\,0.6,\\,1.1,\\,0.7,\\,0.8\\,]$\n  - $c = [\\,1.0,\\,1.0,\\,1.5,\\,0.7,\\,1.2\\,]$\n  - $p_{\\min} = 1.0$\n  - $p_{\\max} = 5.0$\n  - $B = 27.0$\n\n- 案例 4（边缘情况，部分单元在 $p_{\\max}$ 处饱和，而其他单元自由）：\n  - $A = [\\,0.8,\\,1.2,\\,0.5,\\,1.5,\\,1.0\\,]$\n  - $b = [\\,0.9,\\,0.6,\\,1.1,\\,0.7,\\,0.8\\,]$\n  - $c = [\\,1.0,\\,1.0,\\,1.5,\\,0.7,\\,1.2\\,]$\n  - $p_{\\min} = 1.0$\n  - $p_{\\max} = 5.0$\n  - $B = 15.0$\n\n答案规格：\n对于每个测试用例，您的程序必须按顺序输出最优拉格朗日乘子 $\\lambda$（与自由度预算相关）、最优目标值 $J(\\mathbf{p})$ 和最优多项式次数列表 $[p_1,\\dots,p_{N_e}]$。这些必须汇总到单行输出中，包含一个列表的列表，每个测试用例一个列表，没有空格，并且只使用数字字面量。例如，输出必须如下所示：\n$$\n[\\,[\\lambda_1,J_1,p_{1,1},\\dots,p_{1,N_e}],\\,[\\lambda_2,J_2,p_{2,1},\\dots,p_{2,N_e}],\\,\\dots\\,]\n$$\n并完全按照上面列出的顺序包含这些案例。您的程序应生成单行输出，其中包含如上所示的、用方括号括起来的、以逗号分隔的结果列表，且不含空格。",
            "solution": "用户希望解决一个源于计算力学中$hp$自适应的凸优化问题。\n\n### 问题验证\n\n**步骤1：提取给定条件**\n\n问题是最小化目标函数：\n$$\nJ(\\mathbf{p}) = \\sum_{K=1}^{N_e} A_K \\exp(-b_K p_K)\n$$\n约束条件为：\n1. 预算约束：$\\sum_{K=1}^{N_e} c_K p_K \\le B$\n2. 边界约束：$p_{\\min} \\le p_K \\le p_{\\max}$ 对所有 $K \\in \\{1, \\dots, N_e\\}$\n\n参数定义如下：\n- $\\mathbf{p} = (p_1, \\dots, p_{N_e})$：多项式次数向量，被视为连续变量。\n- $A_K  0$, $b_K  0$：误差估计子的单元系数。\n- $c_K  0$：自由度（DOF）近似的单元系数。\n- $B  0$：总自由度预算。\n- $p_{\\min}, p_{\\max}$：多项式次数的下界和上界。\n\n问题要求推导并求解该系统的 Karush-Kuhn-Tucker (KKT) 条件，并实现一个鲁棒的算法来找到最优的 $\\mathbf{p}$ 和预算约束的拉格朗日乘子 $\\lambda$。\n\n**步骤2：使用提取的给定条件进行验证**\n\n- **科学基础**：该问题表述是计算科学与工程领域的标准形式，特别是在面向目标的误差估计和自适应有限元方法的背景下。误差的指数衰减模型 $A_K \\exp(-b_K p_K)$ 是当解在单元上是解析的时，$p$版本有限元法收敛性的一个公认的近似。自由度的线性近似也是一个常见的简化。该表述在科学上是合理的。\n\n- **适定性**：目标函数 $J(\\mathbf{p})$ 是指数函数的和，每个指数函数都是凸的。凸函数的和是凸的。$J$ 的海森矩阵是对角矩阵，其对角元素为 $\\frac{\\partial^2 J}{\\partial p_K^2} = A_K b_K^2 \\exp(-b_K p_K)  0$，因此目标函数是严格凸的。所有约束都是线性不等式，它们定义了一个凸的可行集（一个多胞形）。在一个非空、闭合、凸的集合上最小化一个严格凸函数有唯一解。问题是适定的。问题陈述还要求检查可行性，即可行集是否非空。\n\n- **客观性**：问题以精确、无歧义的数学语言陈述。它不含主观或基于意见的论断。\n\n问题通过了所有验证标准。\n\n**步骤3：结论与行动**\n\n问题是有效的。我将继续进行求解推导。\n\n### 求解推导\n\n这是一个凸优化问题。我们可以通过找到满足 Karush-Kuhn-Tucker (KKT) 条件的点 $(\\mathbf{p}^*)$ 来解决它。\n\n#### 1. 拉格朗日公式化\n\n我们为不等式约束引入拉格朗日乘子：\n- $\\lambda \\ge 0$ 用于预算约束 $g(\\mathbf{p}) = \\sum_{K=1}^{N_e} c_K p_K - B \\le 0$。\n- $\\mu_K \\ge 0$ 用于下界约束 $h_{K,1}(\\mathbf{p}) = p_{\\min} - p_K \\le 0$。\n- $\\nu_K \\ge 0$ 用于上界约束 $h_{K,2}(\\mathbf{p}) = p_K - p_{\\max} \\le 0$。\n\n拉格朗日函数 $\\mathcal{L}$ 是：\n$$\n\\mathcal{L}(\\mathbf{p}, \\lambda, \\boldsymbol{\\mu}, \\boldsymbol{\\nu}) = J(\\mathbf{p}) + \\lambda g(\\mathbf{p}) + \\sum_{K=1}^{N_e} \\mu_K (p_{\\min} - p_K) + \\sum_{K=1}^{N_e} \\nu_K (p_K - p_{\\max})\n$$\n$$\n\\mathcal{L} = \\sum_{K=1}^{N_e} A_K e^{-b_K p_K} + \\lambda \\left(\\sum_{K=1}^{N_e} c_K p_K - B\\right) - \\sum_{K=1}^{N_e} \\mu_K p_K + \\sum_{K=1}^{N_e} \\nu_K p_K + \\text{const.}\n$$\n其中 `const.` 包含了不依赖于 $\\mathbf{p}$ 的项。\n\n#### 2. KKT 条件\n\n最优解 $(\\mathbf{p}^*, \\lambda^*, \\boldsymbol{\\mu}^*, \\boldsymbol{\\nu}^*)$ 的 KKT 条件是：\n\n1.  **平稳性**：$\\nabla_{\\mathbf{p}} \\mathcal{L}(\\mathbf{p}^*, \\lambda^*, \\boldsymbol{\\mu}^*, \\boldsymbol{\\nu}^*) = 0$。\n    对于每个单元 $K$：\n    $$\n    \\frac{\\partial \\mathcal{L}}{\\partial p_K} = -A_K b_K e^{-b_K p_K^*} + \\lambda^* c_K - \\mu_K^* + \\nu_K^* = 0\n    $$\n\n2.  **原始可行性**：\n    - $\\sum_{K=1}^{N_e} c_K p_K^* \\le B$\n    - $p_{\\min} \\le p_K^* \\le p_{\\max}$ 对所有 $K$。\n\n3.  **对偶可行性**：\n    - $\\lambda^* \\ge 0$\n    - $\\mu_K^* \\ge 0$, $\\nu_K^* \\ge 0$ 对所有 $K$。\n\n4.  **互补松弛性**：\n    - $\\lambda^* \\left(\\sum_{K=1}^{N_e} c_K p_K^* - B\\right) = 0$\n    - $\\mu_K^* (p_{\\min} - p_K^*) = 0$ 对所有 $K$。\n    - $\\nu_K^* (p_K^* - p_{\\max}) = 0$ 对所有 $K$。\n\n#### 3. 求解多项式次数 $p_K$\n\n从平稳性条件，我们有 $A_K b_K e^{-b_K p_K^*} = \\lambda^* c_K - \\mu_K^* + \\nu_K^*$。我们根据 $p_K^*$ 的值来分析这个条件：\n\n-   **情况1：$p_K$ 的内部解 ($p_{\\min}  p_K^*  p_{\\max}$)**\n    根据互补松弛性，$\\mu_K^* = 0$ 且 $\\nu_K^* = 0$。平稳性条件简化为：\n    $$\n    -A_K b_K e^{-b_K p_K^*} + \\lambda^* c_K = 0 \\implies e^{-b_K p_K^*} = \\frac{\\lambda^* c_K}{A_K b_K}\n    $$\n    这要求 $\\lambda^*  0$。求解 $p_K^*$：\n    $$\n    p_K^* = -\\frac{1}{b_K} \\ln \\left(\\frac{\\lambda^* c_K}{A_K b_K}\\right) = \\frac{1}{b_K} \\ln \\left(\\frac{A_K b_K}{\\lambda^* c_K}\\right)\n    $$\n    我们把这个无约束解表示为 $p_K^{\\text{free}}(\\lambda^*) = \\frac{1}{b_K} \\ln \\left(\\frac{A_K b_K}{\\lambda^* c_K}\\right)$。\n\n-   **情况2：下界激活 ($p_K^* = p_{\\min}$)**\n    根据互补松弛性，$\\nu_K^* = 0$，但 $\\mu_K^* \\ge 0$。平稳性条件给出 $\\mu_K^* = \\lambda^* c_K - A_K b_K e^{-b_K p_{\\min}}$。因为 $\\mu_K^* \\ge 0$，我们必须有 $\\lambda^* c_K \\ge A_K b_K e^{-b_K p_{\\min}}$。整理后得到 $p_K^{\\text{free}}(\\lambda^*) \\le p_{\\min}$。\n\n-   **情况3：上界激活 ($p_K^* = p_{\\max}$)**\n    根据互补松弛性，$\\mu_K^* = 0$，但 $\\nu_K^* \\ge 0$。平稳性条件给出 $\\nu_K^* = A_K b_K e^{-b_K p_{\\max}} - \\lambda^* c_K$。因为 $\\nu_K^* \\ge 0$，我们必须有 $A_K b_K e^{-b_K p_{\\max}} \\ge \\lambda^* c_K$。整理后得到 $p_K^{\\text{free}}(\\lambda^*) \\ge p_{\\max}$。\n\n综合这些情况，对于给定的 $\\lambda^*  0$，最优的 $p_K^*$ 是通过将自由解裁剪到允许范围内得到的：\n$$\np_K^*(\\lambda^*) = \\text{clip}(p_K^{\\text{free}}(\\lambda^*), p_{\\min}, p_{\\max}) = \\max\\left( p_{\\min}, \\min\\left( p_K^{\\text{free}}(\\lambda^*), p_{\\max} \\right) \\right)\n$$\n\n#### 4. 求解拉格朗日乘子 $\\lambda$\n\n最优多项式次数 $\\{p_K^*\\}$ 现在表示为单个未知标量 $\\lambda^*$ 的函数。我们必须找到满足剩余 KKT 条件的 $\\lambda^*$，特别是预算约束及其互补松弛性条件。\n\n设 $S(\\lambda) = \\sum_{K=1}^{N_e} c_K p_K^*(\\lambda)$。我们需要求解 $\\lambda$。\n\n- **可行性**：总预算 $B$ 必须是可实现的。最小可能的预算使用量为 $B_{\\min} = \\sum_{K=1}^{N_e} c_K p_{\\min}$，最大为 $B_{\\max} = \\sum_{K=1}^{N_e} c_K p_{\\max}$。如果 $B$ 不在区间 $[B_{\\min}, B_{\\max}]$ 内，则问题如规定是不可行的。\n\n- **预算 $B$ 的边界情况**：\n    - 如果 $B \\ge B_{\\max}$：目标函数 $J$ 通过最大化所有 $p_K$ 来最小化。因此，最优解为 $p_K^* = p_{\\max}$ 对所有 $K$。预算约束 $\\sum c_K p_K^* \\le B$ 得到满足，并且可能是松弛的。根据互补松弛性，如果约束是松弛的（$\\sum c_K p_{\\max}  B$），则 $\\lambda^* = 0$。如果它是激活的（$B = B_{\\max}$），$\\lambda^*=0$ 仍然是满足 KKT 条件的有效选择。\n    - 如果 $B = B_{\\min}$：唯一的可行解是 $p_K^* = p_{\\min}$ 对所有 $K$。预算约束是激活的。我们需要找到一个 $\\lambda^*  0$，使得对所有 $K$ 都有 $p_K^*(\\lambda^*) = p_{\\min}$。这要求对所有 $K$ 都有 $p_K^{\\text{free}}(\\lambda^*) \\le p_{\\min}$，这意味着 $\\lambda^* \\ge \\frac{A_K b_K}{c_K} e^{-b_K p_{\\min}}$。满足所有 $K$ 的最小的 $\\lambda^*$ 是 $\\lambda^* = \\max_K \\left\\{ \\frac{A_K b_K}{c_K} e^{-b_K p_{\\min}} \\right\\}$。\n\n- **内部情况 ($B_{\\min}  B  B_{\\max}$)**：\n    在这种情况下，我们期望预算约束是激活的，即 $\\sum c_K p_K^* = B$，这意味着 $\\lambda^*  0$。我们需要解非线性标量方程 $S(\\lambda) = B$。\n    函数 $p_K^*(\\lambda)$ 是 $\\lambda$ 的单调非增函数。因此，$S(\\lambda)$ 也是单调非增的。这个性质允许我们使用高效且鲁棒的求根方法，如二分法。\n    要应用二分法，我们需要找到一个包含根的区间 $[\\lambda_{\\text{low}}, \\lambda_{\\text{high}}]$。\n    - 任何 $p_K$ 开始从 $p_{\\max}$ 减小的最低 $\\lambda$ 值为 $\\lambda_K^{\\text{upper}} = \\frac{A_K b_K}{c_K} e^{-b_K p_{\\max}}$。我们搜索的一个下界是 $\\lambda_{\\text{low}} = \\min_K \\lambda_K^{\\text{upper}}$。在此 $\\lambda$ 处，$S(\\lambda_{\\text{low}}) = B_{\\max}  B$。\n    - 任何 $p_K$ 仍然高于 $p_{\\min}$ 的最高 $\\lambda$ 值为 $\\lambda_K^{\\text{lower}} = \\frac{A_K b_K}{c_K} e^{-b_K p_{\\min}}$。我们搜索的一个上界是 $\\lambda_{\\text{high}} = \\max_K \\lambda_K^{\\text{lower}}$。在此 $\\lambda$ 处，$S(\\lambda_{\\text{high}}) = B_{\\min}  B$。\n    区间 $[\\lambda_{\\text{low}}, \\lambda_{\\text{high}}]$ 保证包含唯一的根 $\\lambda^*$。\n\n#### 5. 算法总结\n1.  计算 $B_{\\min} = \\sum_K c_K p_{\\min}$ 和 $B_{\\max} = \\sum_K c_K p_{\\max}$。\n2.  如果 $B  B_{\\min}$ 或 $B  B_{\\max}$，则认为问题不可行。返回一个指示此情况的结果。\n3.  如果 $B = B_{\\max}$，解为 $\\lambda^* = 0$ 和 $p_K^* = p_{\\max}$ 对所有 $K$。\n4.  如果 $B = B_{\\min}$，解为 $p_K^* = p_{\\min}$ 对所有 $K$ 且 $\\lambda^* = \\max_K \\{ (A_K b_K / c_K) e^{-b_K p_{\\min}} \\}$。\n5.  如果 $B_{\\min}  B  B_{\\max}$，通过在上述定义的区间 $[\\lambda_{\\text{low}}, \\lambda_{\\text{high}}]$ 内使用二分法求解 $S(\\lambda) - B = 0$ 来找到 $\\lambda^*$。\n6.  一旦找到 $\\lambda^*$，计算最优次数 $p_K^* = \\text{clip}\\left( \\frac{1}{b_K} \\ln \\left(\\frac{A_K b_K}{\\lambda^* c_K}\\right), p_{\\min}, p_{\\max} \\right)$。\n7.  计算最优目标值 $J^* = \\sum_K A_K e^{-b_K p_K^*}$。\n8.  返回最优的 $\\lambda^*$、$J^*$ 和向量 $\\mathbf{p}^*$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the hp-adaptivity optimization problem for all test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        {'A': [0.8, 1.2, 0.5, 1.5, 1.0],\n         'b': [0.9, 0.6, 1.1, 0.7, 0.8],\n         'c': [1.0, 1.0, 1.5, 0.7, 1.2],\n         'p_min': 1.0, 'p_max': 5.0, 'B': 8.0},\n        # Case 2\n        {'A': [0.8, 1.2, 0.5, 1.5, 1.0],\n         'b': [0.9, 0.6, 1.1, 0.7, 0.8],\n         'c': [1.0, 1.0, 1.5, 0.7, 1.2],\n         'p_min': 1.0, 'p_max': 5.0, 'B': 5.4},\n        # Case 3\n        {'A': [0.8, 1.2, 0.5, 1.5, 1.0],\n         'b': [0.9, 0.6, 1.1, 0.7, 0.8],\n         'c': [1.0, 1.0, 1.5, 0.7, 1.2],\n         'p_min': 1.0, 'p_max': 5.0, 'B': 27.0},\n        # Case 4\n        {'A': [0.8, 1.2, 0.5, 1.5, 1.0],\n         'b': [0.9, 0.6, 1.1, 0.7, 0.8],\n         'c': [1.0, 1.0, 1.5, 0.7, 1.2],\n         'p_min': 1.0, 'p_max': 5.0, 'B': 15.0}\n    ]\n\n    results = []\n    for params in test_cases:\n        A = np.array(params['A'])\n        b = np.array(params['b'])\n        c = np.array(params['c'])\n        p_min = params['p_min']\n        p_max = params['p_max']\n        B = params['B']\n        \n        result = _solve_one_case(A, b, c, p_min, p_max, B)\n        results.append(result)\n\n    # Format the output as a string representation of a list of lists, with no spaces.\n    print(str(results).replace(' ', ''))\n\ndef _solve_one_case(A, b, c, p_min, p_max, B):\n    \"\"\"\n    Solves a single instance of the optimization problem.\n    \"\"\"\n    Ne = len(A)\n    B_min = np.sum(c * p_min)\n    B_max = np.sum(c * p_max)\n    \n    # Use a small tolerance for floating point comparisons to B_min and B_max\n    tol = 1e-9\n\n    # 1. Feasibility Check\n    if B  B_min - tol or B > B_max + tol:\n        return [np.nan] * (2 + Ne)\n\n    # 2. Boundary Cases for Budget B\n    if abs(B - B_max) = tol:\n        p_opt = np.full(Ne, p_max)\n        lambda_opt = 0.0\n        J_opt = np.sum(A * np.exp(-b * p_opt))\n        return [lambda_opt, J_opt] + p_opt.tolist()\n\n    if abs(B - B_min) = tol:\n        p_opt = np.full(Ne, p_min)\n        # As derived, lambda is the max required to push all p_k to p_min\n        lambda_opt = np.max((A * b / c) * np.exp(-b * p_min))\n        J_opt = np.sum(A * np.exp(-b * p_opt))\n        return [lambda_opt, J_opt] + p_opt.tolist()\n\n    # 3. Interior Case: B_min  B  B_max\n    # Use bisection to find lambda that satisfies Sum(c_k * p_k(lambda)) = B\n    \n    # Pre-compute constant terms\n    Ab_c = A * b / c\n\n    def get_p_from_lambda(lam):\n        # Handle lambda -> 0 case for safety, though bisection bounds prevent it.\n        if lam = 0: return np.full(Ne, p_max)\n        # Formula for p_k before clipping\n        p_free = (1 / b) * np.log(Ab_c / lam)\n        # Clip to [p_min, p_max]\n        return np.clip(p_free, p_min, p_max)\n\n    def budget_func(lam):\n        p = get_p_from_lambda(lam)\n        return np.sum(c * p) - B\n\n    # Establish search bounds for lambda\n    # lam_low corresponds to B_max, lam_high to B_min\n    lam_low = np.min(Ab_c * np.exp(-b * p_max))\n    lam_high = np.max(Ab_c * np.exp(-b * p_min))\n\n    # Bisection search loop\n    max_iter = 100\n    for _ in range(max_iter):\n        lam_mid = (lam_low + lam_high) / 2.0\n        if lam_mid == lam_low or lam_mid == lam_high: # converged\n            break\n        \n        # S(lambda) > B means lambda is too small\n        if budget_func(lam_mid) > 0:\n            lam_low = lam_mid\n        else:\n            lam_high = lam_mid\n            \n    lambda_opt = (lam_low + lam_high) / 2.0\n\n    # 4. Final Calculation\n    p_opt = get_p_from_lambda(lambda_opt)\n    J_opt = np.sum(A * np.exp(-b * p_opt))\n\n    return [lambda_opt, J_opt] + p_opt.tolist()\n\n\nsolve()\n```"
        }
    ]
}