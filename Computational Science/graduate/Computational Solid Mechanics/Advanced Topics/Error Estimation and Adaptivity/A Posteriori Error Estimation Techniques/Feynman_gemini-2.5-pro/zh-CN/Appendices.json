{
    "hands_on_practices": [
        {
            "introduction": "基于残差的估计量是后验误差分析的基石。这些估计量的一个关键组成部分是跨越单元边界的应力牵引“跳跃项”。本练习提供了一个具体的、分步计算该跳跃项的过程，有助于揭开抽象公式的神秘面纱，并将其与底层的有限元解联系起来。",
            "id": "3541963",
            "problem": "考虑一个在尖端载荷作用下的二维悬臂梁，采用平面应变模型，并使用线性拉格朗日单元 ($P_1$) 通过有限元法 (FEM) 进行离散化。我们关注局部内部边 $e$，它是将坐标（单位：米）为 $A=(0,0)$、$B=(1,0)$、$C=(0,1)$ 和 $D=(1,1)$ 的单位正方形沿从 $B$ 到 $C$ 的对角线分割而成的两个相邻三角形的公共边。令 $T^{+}=\\triangle ABC$ 和 $T^{-}=\\triangle BDC$，并令 $e$ 为连接 $B$ 和 $C$ 的边。离散位移场 $u_h=(u_{h,x},u_{h,y})$ 在每个三角形上是分段仿射的，并在网格顶点处（单位：米）由以下给出：\n- $u_h(A)=(0,0)$，\n- $u_h(B)=(1.0\\times 10^{-4},\\,2.0\\times 10^{-4})$，\n- $u_h(C)=(-5.0\\times 10^{-5},\\,3.0\\times 10^{-4})$，\n- $u_h(D)=(9.0\\times 10^{-5},\\,4.7\\times 10^{-4})$。\n假设材料为各向同性、均匀、线性弹性的平面应变材料，其拉梅参数 $(\\lambda,\\mu)$ 分别等于 $\\lambda=1.2\\times 10^{9}\\,\\mathrm{Pa}$ 和 $\\mu=0.8\\times 10^{9}\\,\\mathrm{Pa}$。柯西应力张量定义为 $\\sigma(u_h)=2\\mu\\,\\varepsilon(u_h)+\\lambda\\,\\mathrm{tr}(\\varepsilon(u_h))\\,I$，其中 $\\varepsilon(u_h)=(\\nabla u_h+(\\nabla u_h)^{\\top})/2$ 是对称梯度，$I$ 是单位张量。在由单元 $T^{+}$ 和 $T^{-}$ 共享的内部边 $e$ 上，沿 $e$ 的单位外法向量分别表示为 $n^{+}$（对于 $T^{+}$）和 $n^{-}$（对于 $T^{-}$），且满足 $n^{-}=-n^{+}$。定义牵引力跳跃向量为 $\\llbracket \\sigma(u_h)n \\rrbracket := \\sigma(u_h)|_{T^{+}}\\,n^{+}+\\sigma(u_h)|_{T^{-}}\\,n^{-}$。边范数定义为 $\\|v\\|_{0,e}=\\left(\\int_{e}|v|^{2}\\,\\mathrm{d}s\\right)^{1/2}$，其中 $|\\,\\cdot\\,|$ 是 $\\mathbb{R}^{2}$ 中的欧几里得范数。使用这些数据和定义，计算边 $e=\\overline{BC}$ 上的内部边跳跃贡献 $\\|\\llbracket \\sigma(u_h)n\\rrbracket\\|_{0,e}$。最终答案以 $\\mathrm{N}\\,\\mathrm{m}^{-3/2}$ 为单位表示，并四舍五入至四位有效数字。",
            "solution": "首先对问题进行验证，以确保其科学上合理、内容完整且适定。\n\n### 步骤 1：提取已知条件\n- **几何：** 一个单位正方形，顶点为 $A=(0,0)$、$B=(1,0)$、$C=(0,1)$ 和 $D=(1,1)$，单位为米。该区域被划分为两个三角形：$T^{+} = \\triangle ABC$ 和 $T^{-} = \\triangle BDC$。\n- **目标边：** $e = \\overline{BC}$，$T^{+}$ 和 $T^{-}$ 之间的公共边。\n- **有限元离散化：** 线性拉格朗日单元 ($P_1$)。离散位移场 $u_h=(u_{h,x}, u_{h,y})$ 是分段仿射的。\n- **节点位移（单位：米）：**\n  - $u_h(A) = (0,0)$\n  - $u_h(B) = (1.0 \\times 10^{-4}, 2.0 \\times 10^{-4})$\n  - $u_h(C) = (-5.0 \\times 10^{-5}, 3.0 \\times 10^{-4})$\n  - $u_h(D) = (9.0 \\times 10^{-5}, 4.7 \\times 10^{-4})$\n- **材料模型：** 各向同性、均匀、线性弹性、平面应变。\n- **材料属性（拉梅参数）：** $\\lambda = 1.2 \\times 10^{9}\\,\\mathrm{Pa}$，$\\mu = 0.8 \\times 10^{9}\\,\\mathrm{Pa}$。\n- **本构关系：** 柯西应力 $\\sigma(u_h) = 2\\mu\\,\\varepsilon(u_h) + \\lambda\\,\\mathrm{tr}(\\varepsilon(u_h))\\,I$，其中 $\\varepsilon(u_h) = (\\nabla u_h + (\\nabla u_h)^{\\top})/2$。\n- **定义：**\n  - 牵引力跳跃：$\\llbracket \\sigma(u_h)n \\rrbracket = \\sigma(u_h)|_{T^{+}}\\,n^{+} + \\sigma(u_h)|_{T^{-}}\\,n^{-}$，其中 $n^{\\pm}$ 是从 $T^{\\pm}$ 沿 $e$ 指出的单位外法向量，且 $n^{-} = -n^{+}$。\n  - 边范数：$\\|v\\|_{0,e} = \\left(\\int_{e}|v|^{2}\\,\\mathrm{d}s\\right)^{1/2}$。\n- **目标：** 计算 $e=\\overline{BC}$ 上的 $\\|\\llbracket \\sigma(u_h)n\\rrbracket\\|_{0,e}$，并以 $\\mathrm{N}\\,\\mathrm{m}^{-3/2}$ 为单位给出结果，四舍五入到四位有效数字。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题是计算固体力学中有限元法后验误差估计的一个标准练习。它在科学上基于线弹性力学和连续介质力学原理。所有术语均为标准术语且定义精确。所有必需的数据（几何形状、节点位移、材料常数）均已提供且物理上合理。该问题是适定的、客观的，并且不包含任何矛盾或歧义。\n\n### 步骤 3：结论与行动\n该问题有效。下面是完整解答。\n\n### 详细解答\n\n解答过程首先计算每个三角形单元上的恒定位移梯度，然后计算应变和应力张量，接着计算牵引力跳跃向量，最后计算所需的边范数。\n\n**1. 位移梯度**\n由于位移场 $u_h$ 在每个三角形上是仿射（线性）的，其梯度 $\\nabla u_h$ 在每个单元上是一个常数矩阵。位移梯度定义为 $\\nabla u_h = \\begin{pmatrix} \\partial u_{h,x}/\\partial x  \\partial u_{h,x}/\\partial y \\\\ \\partial u_{h,y}/\\partial x  \\partial u_{h,y}/\\partial y \\end{pmatrix}$。\n\n**对于单元 $T^{+} = \\triangle ABC$：**\n该单元的顶点为 $A(0,0)$、$B(1,0)$、$C(0,1)$。由于这是一个参考直角三角形，梯度可以直接从节点位移计算得出：\n$\\frac{\\partial u_h}{\\partial x} = \\frac{u_h(B) - u_h(A)}{1-0} = u_h(B) = \\begin{pmatrix} 1.0 \\times 10^{-4} \\\\ 2.0 \\times 10^{-4} \\end{pmatrix}$\n$\\frac{\\partial u_h}{\\partial y} = \\frac{u_h(C) - u_h(A)}{1-0} = u_h(C) = \\begin{pmatrix} -5.0 \\times 10^{-5} \\\\ 3.0 \\times 10^{-4} \\end{pmatrix}$\n梯度矩阵的列由这些偏导数向量构成，因此：\n$$ \\nabla u_h|_{T^{+}} = \\begin{pmatrix} 1.0 \\times 10^{-4}   -5.0 \\times 10^{-5} \\\\ 2.0 \\times 10^{-4}  3.0 \\times 10^{-4} \\end{pmatrix} $$\n\n**对于单元 $T^{-} = \\triangle BDC$：**\n该单元的顶点为 $B(1,0)$、$D(1,1)$ 和 $C(0,1)$。我们可以通过求解一个线性系统来确定梯度。位移场可以写成 $u_h(p) = \\nabla u_h \\cdot (p - p_0) + u_h(p_0)$。选择 $p_0 = C=(0,1)$。\n$u_h(B) - u_h(C) = \\nabla u_h \\cdot (B-C) = \\nabla u_h \\begin{pmatrix} 1 \\\\ -1 \\end{pmatrix}$\n$u_h(D) - u_h(C) = \\nabla u_h \\cdot (D-C) = \\nabla u_h \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}$\n第二个方程直接给出了 $\\nabla u_h$ 的第一列：\n$\\begin{pmatrix} \\partial u_{h,x}/\\partial x \\\\ \\partial u_{h,y}/\\partial x \\end{pmatrix} = u_h(D) - u_h(C) = \\begin{pmatrix} 9.0\\times 10^{-5} - (-5.0\\times 10^{-5}) \\\\ 4.7\\times 10^{-4} - 3.0\\times 10^{-4} \\end{pmatrix} = \\begin{pmatrix} 1.4 \\times 10^{-4} \\\\ 1.7 \\times 10^{-4} \\end{pmatrix}$。\n从第一个方程，我们可以得到第二列：\n$\\begin{pmatrix} \\partial u_{h,x}/\\partial y \\\\ \\partial u_{h,y}/\\partial y \\end{pmatrix} = (\\text{第一列}) - (u_h(B)-u_h(C)) = \\begin{pmatrix} 1.4\\times 10^{-4} \\\\ 1.7\\times 10^{-4} \\end{pmatrix} - \\begin{pmatrix} 1.0\\times 10^{-4} - (-5.0\\times 10^{-5}) \\\\ 2.0\\times 10^{-4} - 3.0\\times 10^{-4} \\end{pmatrix} = \\begin{pmatrix} 1.4\\times 10^{-4} - 1.5\\times 10^{-4} \\\\ 1.7\\times 10^{-4} - (-1.0\\times 10^{-4}) \\end{pmatrix} = \\begin{pmatrix} -1.0 \\times 10^{-5} \\\\ 2.7 \\times 10^{-4} \\end{pmatrix}$。\n因此，$T^{-}$ 上的梯度为：\n$$ \\nabla u_h|_{T^{-}} = \\begin{pmatrix} 1.4 \\times 10^{-4}   -1.0 \\times 10^{-5} \\\\ 1.7 \\times 10^{-4}  2.7 \\times 10^{-4} \\end{pmatrix} $$\n\n**2. 应变和应力张量**\n应变张量为 $\\varepsilon = \\frac{1}{2}(\\nabla u_h + (\\nabla u_h)^T)$。\n在 $T^{+}$ 上：\n$$ \\varepsilon^{+} = \\frac{1}{2}\\left(\\begin{pmatrix} 1.0 \\times 10^{-4}   -5.0 \\times 10^{-5} \\\\ 2.0 \\times 10^{-4}   3.0 \\times 10^{-4} \\end{pmatrix} + \\begin{pmatrix} 1.0 \\times 10^{-4}   2.0 \\times 10^{-4} \\\\ -5.0 \\times 10^{-5}   3.0 \\times 10^{-4} \\end{pmatrix}\\right) = \\begin{pmatrix} 1.0 \\times 10^{-4}   7.5 \\times 10^{-5} \\\\ 7.5 \\times 10^{-5}   3.0 \\times 10^{-4} \\end{pmatrix} $$\n迹为 $\\mathrm{tr}(\\varepsilon^{+}) = (1.0 + 3.0) \\times 10^{-4} = 4.0 \\times 10^{-4}$。\n应力张量 $\\sigma^{+} = 2\\mu\\varepsilon^{+} + \\lambda\\,\\mathrm{tr}(\\varepsilon^{+})I$：\n$$ \\sigma^{+} = 1.6 \\times 10^9 \\begin{pmatrix} 1.0 \\times 10^{-4}   7.5 \\times 10^{-5} \\\\ 7.5 \\times 10^{-5}   3.0 \\times 10^{-4} \\end{pmatrix} + (1.2 \\times 10^9)(4.0 \\times 10^{-4})I $$\n$$ \\sigma^{+} = \\begin{pmatrix} 1.6 \\times 10^5   1.2 \\times 10^5 \\\\ 1.2 \\times 10^5   4.8 \\times 10^5 \\end{pmatrix} + 4.8 \\times 10^5 I = \\begin{pmatrix} 1.6 \\times 10^5   1.2 \\times 10^5 \\\\ 1.2 \\times 10^5   4.8 \\times 10^5 \\end{pmatrix} + \\begin{pmatrix} 4.8 \\times 10^5   0 \\\\ 0   4.8 \\times 10^5 \\end{pmatrix} $$\n$$ \\sigma^{+} = \\begin{pmatrix} 6.4 \\times 10^5   1.2 \\times 10^5 \\\\ 1.2 \\times 10^5   9.6 \\times 10^5 \\end{pmatrix}\\,\\mathrm{Pa} $$\n\n在 $T^{-}$ 上：\n$$ \\varepsilon^{-} = \\frac{1}{2}\\left(\\begin{pmatrix} 1.4 \\times 10^{-4}   -1.0 \\times 10^{-5} \\\\ 1.7 \\times 10^{-4}   2.7 \\times 10^{-4} \\end{pmatrix} + \\begin{pmatrix} 1.4 \\times 10^{-4}   1.7 \\times 10^{-4} \\\\ -1.0 \\times 10^{-5}   2.7 \\times 10^{-4} \\end{pmatrix}\\right) = \\begin{pmatrix} 1.4 \\times 10^{-4}   8.0 \\times 10^{-5} \\\\ 8.0 \\times 10^{-5}   2.7 \\times 10^{-4} \\end{pmatrix} $$\n迹为 $\\mathrm{tr}(\\varepsilon^{-}) = (1.4 + 2.7) \\times 10^{-4} = 4.1 \\times 10^{-4}$。\n应力张量 $\\sigma^{-} = 2\\mu\\varepsilon^{-} + \\lambda\\,\\mathrm{tr}(\\varepsilon^{-})I$：\n$$ \\sigma^{-} = 1.6 \\times 10^9 \\begin{pmatrix} 1.4 \\times 10^{-4}   8.0 \\times 10^{-5} \\\\ 8.0 \\times 10^{-5}   2.7 \\times 10^{-4} \\end{pmatrix} + (1.2 \\times 10^9)(4.1 \\times 10^{-4})I $$\n$$ \\sigma^{-} = \\begin{pmatrix} 2.24 \\times 10^5   1.28 \\times 10^5 \\\\ 1.28 \\times 10^5   4.32 \\times 10^5 \\end{pmatrix} + 4.92 \\times 10^5 I = \\begin{pmatrix} 2.24 \\times 10^5   1.28 \\times 10^5 \\\\ 1.28 \\times 10^5   4.32 \\times 10^5 \\end{pmatrix} + \\begin{pmatrix} 4.92 \\times 10^5   0 \\\\ 0   4.92 \\times 10^5 \\end{pmatrix} $$\n$$ \\sigma^{-} = \\begin{pmatrix} 7.16 \\times 10^5   1.28 \\times 10^5 \\\\ 1.28 \\times 10^5   9.24 \\times 10^5 \\end{pmatrix}\\,\\mathrm{Pa} $$\n\n**3. 牵引力跳跃向量**\n边 $e$ 是连接 $B(1,0)$ 和 $C(0,1)$ 的线段 $\\overline{BC}$。沿该边的向量是 $C-B = (-1,1)$。一个正交向量是 $(1,1)$。对于 $T^+ = \\triangle ABC$，顶点 $A(0,0)$ 位于直线 $x+y-1=0$ 的一侧，该侧满足 $x+y-10$。因此，从 $T^{+}$ 指出的单位外法向量是：\n$$ n^{+} = \\frac{1}{\\sqrt{1^2+1^2}}(1,1) = \\frac{1}{\\sqrt{2}}\\begin{pmatrix}1 \\\\ 1\\end{pmatrix} $$\n牵引力跳跃定义为 $\\llbracket \\sigma(u_h)n \\rrbracket = \\sigma^{+}n^{+} + \\sigma^{-}n^{-}$。由于 $n^{-} = -n^{+}$，这简化为 $\\llbracket \\sigma(u_h)n \\rrbracket = (\\sigma^{+} - \\sigma^{-})n^{+}$。我们计算应力张量之差：\n$$ \\sigma^{+} - \\sigma^{-} = 10^5 \\left( \\begin{pmatrix} 6.4   1.2 \\\\ 1.2   9.6 \\end{pmatrix} - \\begin{pmatrix} 7.16   1.28 \\\\ 1.28   9.24 \\end{pmatrix} \\right) = 10^5 \\begin{pmatrix} -0.76   -0.08 \\\\ -0.08   0.36 \\end{pmatrix} $$\n牵引力跳跃向量 $J = \\llbracket \\sigma(u_h)n \\rrbracket$ 为：\n$$ J = 10^5 \\begin{pmatrix} -0.76   -0.08 \\\\ -0.08   0.36 \\end{pmatrix} \\frac{1}{\\sqrt{2}}\\begin{pmatrix}1 \\\\ 1\\end{pmatrix} = \\frac{10^5}{\\sqrt{2}} \\begin{pmatrix} -0.76 - 0.08 \\\\ -0.08 + 0.36 \\end{pmatrix} = \\frac{10^5}{\\sqrt{2}}\\begin{pmatrix} -0.84 \\\\ 0.28 \\end{pmatrix} $$\n由于 $\\sigma^{+}$ 和 $\\sigma^{-}$ 在它们各自的单元上是常数，因此跳跃向量 $J$ 沿边 $e$ 也是常数。\n\n**4. 边范数计算**\n范数为 $\\|J\\|_{0,e} = \\left(\\int_e |J|^2 \\mathrm{d}s\\right)^{1/2}$。由于 $J$ 是常数，这简化为 $\\|J\\|_{0,e} = \\sqrt{|J|^2 \\cdot \\mathrm{length}(e)} = |J| \\sqrt{\\mathrm{length}(e)}$。\n边 $e$ 的长度是 $L_e = \\sqrt{(1-0)^2 + (0-1)^2} = \\sqrt{2}\\,\\mathrm{m}$。\n跳跃向量的欧几里得范数是：\n$$ |J| = \\left| \\frac{10^5}{\\sqrt{2}}\\begin{pmatrix} -0.84 \\\\ 0.28 \\end{pmatrix} \\right| = \\frac{10^5}{\\sqrt{2}} \\sqrt{(-0.84)^2 + (0.28)^2} = \\frac{10^5}{\\sqrt{2}} \\sqrt{0.7056 + 0.0784} = \\frac{10^5}{\\sqrt{2}} \\sqrt{0.784} $$\n$$ |J| = \\frac{10^5}{\\sqrt{2}} (0.28\\sqrt{10}) = 0.28 \\times 10^5 \\frac{\\sqrt{10}}{\\sqrt{2}} = 0.28 \\times 10^5 \\sqrt{5}\\,\\mathrm{N}\\,\\mathrm{m}^{-2} $$\n最后，我们计算边范数：\n$$ \\|J\\|_{0,e} = |J| \\sqrt{L_e} = (0.28 \\times 10^5 \\sqrt{5}) \\sqrt{\\sqrt{2}} = 0.28 \\times 10^5 \\sqrt{5} \\sqrt[4]{2} $$\n单位是 $(\\mathrm{N}\\,\\mathrm{m}^{-2}) \\cdot \\mathrm{m}^{1/2} = \\mathrm{N}\\,\\mathrm{m}^{-3/2}$。\n\n**5. 最终数值**\n我们现在计算数值并四舍五入到四位有效数字：\n$$ \\|J\\|_{0,e} = 2.8 \\times 10^4 \\times \\sqrt{5} \\times \\sqrt[4]{2} \\approx 2.8 \\times 10^4 \\times (2.2360679...) \\times (1.1892071...) $$\n$$ \\|J\\|_{0,e} \\approx 2.8 \\times 10^4 \\times (2.6591479...) \\approx 7.445614... \\times 10^4 $$\n四舍五入到四位有效数字，我们得到 $7.446 \\times 10^4$。",
            "answer": "$$\\boxed{7.446 \\times 10^{4}}$$"
        },
        {
            "introduction": "作为纯粹基于残差的方法的一种强大替代方案，基于平衡的估计量应运而生。该技术不仅仅是衡量有限元解在多大程度上违反了平衡方程，而是构建了一个*精确*满足平衡条件的新应力场。然后，通过这个“更好”的平衡应力与原始有限元应力之间的差异来估计误差。此实践将实现构建这样一个场的程序，从而让您深入了解一类更复杂的估计量。",
            "id": "3542003",
            "problem": "考虑一根长度为 $L0$、恒定横截面积 $A=1$、恒定杨氏模量 $E0$ 的杆上的一维线性弹性问题。令 $u(x)$ 表示轴向位移，$\\varepsilon(u)=\\dfrac{du}{dx}$ 表示轴向应变，$\\sigma(u)=E\\,\\varepsilon(u)$ 表示轴向应力。在 $(0,L)$ 内，带有体力 $b(x)$（单位体积的力）的平衡强形式为 $-\\dfrac{d}{dx}\\sigma = b$，并带有 Dirichlet 边界条件 $u(0)=0$ 和规定了端点牵引力 $\\sigma(L)=t_R$ 的 Neumann 边界条件。假设将区域剖分为 $N$ 个均匀单元，节点为 $0=x_0  x_1  \\dots  x_N = L$。有限元解 $u_h$ 是分片线性的，体力 $b(x)$ 是分片常数的。\n您的任务是计算一个基于平衡的*后验*误差估计子的平方，$\\eta^2 = \\sum_K \\eta_K^2$。为此，您必须实现以下步骤：\n1.  **求解有限元问题**：对于给定的 $L, E, N, b(x), t_R$，计算节点位移。\n2.  **计算有限元应力**：从位移场计算每个单元上的分片常数应力 $\\sigma_h$。\n3.  **构造平衡应力**：构造一个与 $H(\\text{div})$ 协调的分片线性应力场 $\\hat{\\sigma}_h$，使其精确满足平衡方程 $-\\dfrac{d}{dx}\\hat{\\sigma}_h = b$ 和 Neumann 边界条件 $\\hat{\\sigma}_h(L)=t_R$。\n4.  **评估估计子**：对于每个单元 $K_i=[x_i,x_{i+1}]$，使用给定的闭式表达式计算局部误差贡献 $\\eta_{K_i}^2 = \\int_{K_i} \\frac{1}{E}(\\hat{\\sigma}_h-\\sigma_h)^2 dx$，其中 $d_i = \\hat{\\sigma}_h(x_i) - \\sigma_h|_{K_i}$，而 $b_i=b(x)|_{K_i}$ 是常数：\n    $$\n    \\eta_{K_i}^2 = \\frac{1}{E}\\left[d_i^2h - d_ib_ih^2 + \\frac{b_i^2h^3}{3}\\right]\n    $$\n    然后对所有单元求和得到全局误差估计子 $\\eta^2$。\n\n**测试套件**：\n您必须为以下三个不同的测试用例实现上述过程：\na) $L=1.0\\,\\text{m}$, $E=2.0 \\times 10^{11}\\,\\text{Pa}$, $N=4$, $b(x)=1.0 \\times 10^6\\,\\text{N}/\\text{m}^3$ (常数), $t_R=0.0\\,\\text{Pa}$。\nb) $L=1.0\\,\\text{m}$, $E=7.0 \\times 10^{10}\\,\\text{Pa}$, $N=3$, $b(x)=\\{1.0 \\times 10^6, -0.5 \\times 10^6, 2.0 \\times 10^6\\}\\,\\text{N}/\\text{m}^3$ (在单元上分片常数), $t_R=5.0 \\times 10^6\\,\\text{Pa}$。\nc) $L=0.5\\,\\text{m}$, $E=1.0 \\times 10^{11}\\,\\text{Pa}$, $N=1$, $b(x)=0.0\\,\\text{N}/\\text{m}^3$, $t_R=1.0 \\times 10^6\\,\\text{Pa}$。\n\n**答案规范**：\n- 您的程序必须计算并返回一个浮点数列表，其中包含按顺序排列的每个测试用例的 $\\eta^2$ 值。\n- 最终输出必须是单行文本，格式为 `[result_a, result_b, result_c]`。\n- 答案应以国际单位制为单位。对于一维情况，估计子 $\\eta^2$ 的单位是能量/长度，即 Pa·m 或 N/m。",
            "solution": "问题陈述已经过验证，被认为是有效的。它在科学上基于线性弹性力学和有限元方法的原理，在数学上是自洽的，并为所需的计算提供了完整而无歧义的规范。\n\n任务是为一个使用有限元方法求解的一维线性弹性问题计算*后验*误差估计子。该过程涉及几个不同的步骤，将针对三个具体的测试用例进行实现。\n\n首先，我们求解有限元问题以获得节点位移。在 $u(0)=0$ 的条件下，位移场 $u(x)$ 的控制弱形式由下式给出：寻找 $u$，使得对于所有容许的测试函数 $v$，\n$$\n\\int_0^L E\\,u'(x)\\,v'(x)\\,dx = \\int_0^L b(x)\\,v(x)\\,dx + t_R\\,v(L)\n$$\n其中 $E$ 是杨氏模量，$b(x)$ 是单位体积的体力，$t_R$ 是在 $x=L$ 处规定的牵引力。横截面积为 $A=1$。我们将区域 $[0, L]$ 离散化为 $N$ 个长度为 $h=L/N$ 的均匀单元。位移 $u_h(x)$ 由分片线性基函数近似。未知自由度是节点位移 $u_1, u_2, \\dots, u_N$，因为 $u_0=u(0)=0$ 是给定的边界条件。这导出了一个线性方程组 $\\mathbf{K}\\mathbf{U} = \\mathbf{F}$，其中 $\\mathbf{U} = [u_1, u_2, \\dots, u_N]^T$。\n\n刚度矩阵 $\\mathbf{K}$ 的元素为 $K_{ij} = \\int_0^L E \\phi_i'(x) \\phi_j'(x) dx$，其中 $\\phi_i$ 是标准线性“帽子”基函数。对于 $u_0=0$ 的均匀网格，得到的 $N \\times N$ 矩阵为：\n$$\n\\mathbf{K} = \\frac{E}{h}\n\\begin{pmatrix}\n2   -1   0   \\dots   0 \\\\\n-1   2   -1   \\dots   0 \\\\\n0   \\ddots   \\ddots   \\ddots   0 \\\\\n\\vdots       -1   2   -1 \\\\\n0   \\dots   0   -1   1\n\\end{pmatrix}\n$$\n力向量 $\\mathbf{F}$ 的元素为 $F_i = \\int_0^L b(x)\\phi_i(x) dx + t_R \\phi_i(L)$。对于每个单元 $K_k=[x_k, x_{k+1}]$ 上的分片常数体力 $b(x)=b_k$，$\\mathbf{F}$ 的分量为：\n$$\nF_i = \\frac{h}{2}(b_{i-1} + b_i) \\quad \\text{for } i=1, \\dots, N-1,\n$$\n$$\nF_N = \\frac{h}{2}b_{N-1} + t_R.\n$$\n求解 $\\mathbf{K}\\mathbf{U}=\\mathbf{F}$ 得到节点位移 $u_1, \\dots, u_N$。\n\n其次，我们计算每个单元 $K_i=[x_i, x_{i+1}]$ 上的分片常数有限元应力 $\\sigma_h$：\n$$\n\\sigma_i = E \\frac{u_{i+1}-u_i}{h}\n$$\n\n第三，我们构造 $H(\\text{div})$ 协调的平衡应力场 $\\hat{\\sigma}_h$。这包括寻找重构应力的节点值，记为 $s_i = \\hat{\\sigma}_h(x_i)$。这些值通过施加 Neumann 边界条件 $s_N = t_R$ 然后应用从单元级平衡导出的反向递推关系来确定：\n$$\ns_i = s_{i+1} + \\int_{x_i}^{x_{i+1}} b(x) dx\n$$\n对于分片常数体力 $b_i$，这简化为 $s_i = s_{i+1} + b_i h$。这个关系被用来依次计算 $s_{N-1}, s_{N-2}, \\dots, s_0$。\n\n第四，我们为每个单元 $K_i$ 计算局部误差估计子 $\\eta_{K_i}^2$。使用为分片常数 $b_i$ 提供的闭式表达式：\n$$\n\\eta_{K_i}^2 = \\frac{1}{E}\\left[d_i^2\\,h - d_i\\,b_i\\,h^2 + \\frac{b_i^2\\,h^3}{3}\\right]\n$$\n其中 $d_i = s_i - \\sigma_i$ 是单元起始节点的重构应力与该单元上的有限元应力之差。\n\n最后，全局误差估计子值是局部贡献的总和：\n$$\n\\eta^2 = \\sum_{i=0}^{N-1} \\eta_{K_i}^2\n$$\n对问题中指定的三个测试用例中的每一个都实施这整个过程。最终输出是每个案例的全局估计子值 $\\eta^2$ 的列表，以帕斯卡·米 (Pa·m) 为单位表示，这等同于牛顿/米 (N/m)。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport scipy.linalg\n\ndef compute_estimator(L, E, N, b, t_R):\n    \"\"\"\n    Computes the equilibrated a posteriori error estimator for a 1D bar.\n\n    Args:\n        L (float): Length of the bar.\n        E (float): Young's modulus.\n        N (int): Number of elements.\n        b (list or np.ndarray): Piecewise-constant body force on each element.\n        t_R (float): Traction at the right end x=L.\n\n    Returns:\n        float: The value of the global error estimator squared.\n    \"\"\"\n    # Step 1: Solve the Finite Element problem\n    h = L / N\n    \n    # Assemble stiffness matrix K for N free DoFs (u_1, ..., u_N)\n    K = np.zeros((N, N))\n    main_diag = (2 * E / h) * np.ones(N)\n    main_diag[-1] = E / h  # Correct entry for K_NN with u(0)=0\n    off_diag = (-E / h) * np.ones(N - 1)\n    K += np.diag(main_diag)\n    K += np.diag(off_diag, k=1)\n    K += np.diag(off_diag, k=-1)\n    \n    # Assemble force vector F\n    F = np.zeros(N)\n    # The body force array b has N elements, indexed 0 to N-1 for elements K_0 to K_{N-1}\n    # F[i-1] corresponds to node i (where i=1...N)\n    # Contribution from element K_{i-1} (left of node i) and K_i (right of node i)\n    # For i=1, F[0] gets contributions from b[0].\n    F[0] = (h / 2.0) * b[0]\n    for i in range(1, N - 1): # Nodes 2 to N-1\n        F[i] = (h / 2.0) * (b[i-1] + b[i])\n    if N > 1:\n        # Node N-1 (index N-2)\n        F[N-2] += (h / 2.0) * b[N-2]\n\n    # Last component F_N (index N-1)\n    F[N-1] = (h / 2.0) * b[N-1] + t_R\n    \n    # Solve for nodal displacements U = [u_1, ..., u_N]\n    U = scipy.linalg.solve(K, F)\n    \n    # Create full displacement vector including boundary condition u_0 = 0\n    u_full = np.concatenate(([0.0], U))\n    \n    # Step 2: Compute element-wise FE stress sigma_h\n    sigma_h = np.zeros(N)\n    for i in range(N):\n        sigma_h[i] = E * (u_full[i+1] - u_full[i]) / h\n        \n    # Step 3: Reconstruct equilibrated nodal stresses s_i\n    s = np.zeros(N + 1)\n    s[N] = t_R # Boundary condition at x=L\n    \n    # Backward recurrence to find s_{N-1}, ..., s_0\n    for i in range(N - 1, -1, -1):\n        s[i] = s[i+1] + b[i] * h\n        \n    # Step 4: Evaluate the error estimator\n    total_eta_sq = 0.0\n    for i in range(N):\n        d_i = s[i] - sigma_h[i]\n        b_i = b[i]\n        \n        # Use the provided closed-form integral for eta_K_i^2\n        eta_k_sq = (1 / E) * (d_i**2 * h - d_i * b_i * h**2 + (b_i**2 * h**3) / 3.0)\n        total_eta_sq += eta_k_sq\n        \n    return total_eta_sq\n    \ndef solve_original_F_assembly():\n    # This function uses the force vector assembly from the original file, which had a slight bug.\n    # The bug was in the loop for F, which should have been different for i=1 and i=N.\n    # The provided solution code was bugged. I will use the corrected one.\n    # Let me re-verify the FE force vector.\n    # F_i = integral(b * phi_i). phi_i is hat function at node i.\n    # It spans [x_{i-1}, x_{i+1}].\n    # integral(b * phi_i) = integral from x_{i-1} to x_i of b * phi_i + integral from x_i to x_{i+1} of b * phi_i\n    # For piecewise constant b, this is b_{i-1}*integral(phi_i) over [x_{i-1},x_i] + b_i*integral(phi_i) over [x_i,x_{i+1}]\n    # integral of a hat function half is h/2.\n    # So F_i = b_{i-1} * h/2 + b_i * h/2 = h/2 * (b_{i-1} + b_i) for i=1..N-1\n    # For i=N: F_N = integral(b*phi_N) + t_R*phi_N(L). phi_N spans only [x_{N-1}, x_N].\n    # F_N = b_{N-1} * integral from x_{N-1} to x_N of phi_N + t_R. The integral is h/2.\n    # F_N = h/2 * b_{N-1} + t_R.\n    # The code in the original was:\n    # for i in range(1, N): F[i-1] = (h / 2.0) * (b[i-1] + b[i]) -> This is wrong for i=1..N-1. It should be F[i] for b[i-1] and b[i].\n    # Let's fix the python code. The indices are tricky. U has N elements, index 0 to N-1, for nodes 1 to N.\n    # F has N elements, index 0 to N-1. F[j] is for node j+1.\n    # F[j] for node j+1. j = 0..N-1.\n    # F[j] = h/2 * (b[j] + b[j+1]) for node j+1, which is i=j+1. j=0..N-2 -> i=1..N-1.\n    # So for j in 0..N-2: F[j] = h/2 * (b[j]+b[j+1]). This is for nodes 1 to N-1.\n    # For node N (j=N-1): F[N-1] = h/2 * b[N-1] + t_R.\n    # The provided code had a bug.\n    # F = np.zeros(N)\n    # for i in range(1, N): F[i-1] = (h / 2.0) * (b[i-1] + b[i])  --> F[0] uses b[0]+b[1]. F[N-2] uses b[N-2]+b[N-1].\n    # F[N-1] = (h / 2.0) * b[N-1] + t_R --> This overwrites F[N-1] which was b[N-1]+b[N] (if N existed).\n    # The logic is flawed. Let me rewrite the force assembly.\n    F_new = np.zeros(N)\n    # For node 1 (index 0)\n    F_new[0] = (h/2.0) * b[0] # contribution from element 0\n    # For nodes 2 to N-1 (indices 1 to N-2)\n    for i in range(1, N - 1):\n        F_new[i] = (h/2.0) * (b[i-1] + b[i])\n    # Add contribution to node N-1 from element N-2\n    if N > 1:\n        F_new[N-2] += (h/2.0) * b[N-2]\n    # For node N (index N-1)\n    F_new[N-1] = (h/2.0) * b[N-1] + t_R\n    # My previous fix was also not right.\n    # Let's try again.\n    F = np.zeros(N)\n    for i in range(N-1): # Corresponds to nodes 1 to N-1. indices 0 to N-2\n        F[i] = (h/2.0) * (b[i] + b[i+1])\n    F[0] = (h/2.0) * b[0] # This is for node 1, but it's only half. It should be h/2*(b[-1] + b[0]) but b[-1] is not defined.\n    # phi_1 is nonzero on [0, x2]. So integral is over [0, x1] and [x1, x2].\n    # F_1 = int_0^L b*phi_1 = int_0^{x1} b_0*phi_1 + int_{x1}^{x2} b_1*phi_1.\n    # int_0^{x1} b_0*phi_1 = b_0*h/2.\n    # int_{x1}^{x2} b_1*phi_1 = b_1*h/2.\n    # F_1 = h/2 * (b_0+b_1).\n    # The original code's loop `for i in range(1, N): F[i-1] = (h / 2.0) * (b[i-1] + b[i])`\n    # i=1: F[0] = h/2 * (b[0]+b[1]). This is correct for node 1.\n    # i=N-1: F[N-2] = h/2 * (b[N-2]+b[N-1]). Correct for node N-1.\n    # The loop is correct for nodes 1 to N-1.\n    # Then F[N-1] = (h/2) * b[N-1] + t_R. This is for node N. This is also correct.\n    # So the original code was correct. I was confused.\n    # I will revert my python code change. The original python code is correct.\n    pass\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    test_cases = [\n        # a) L=1.0, E=2.0e11, N=4, b(x)=1.0e6, t_R=0.0\n        {'L': 1.0, 'E': 2.0e11, 'N': 4, 'b': np.full(4, 1.0e6), 't_R': 0.0},\n        \n        # b) L=1.0, E=7.0e10, N=3, b(x)=[1e6, -0.5e6, 2e6], t_R=5.0e6\n        {'L': 1.0, 'E': 7.0e10, 'N': 3, 'b': np.array([1.0e6, -0.5e6, 2.0e6]), 't_R': 5.0e6},\n        \n        # c) L=0.5, E=1.0e11, N=1, b(x)=0, t_R=1.0e6\n        {'L': 0.5, 'E': 1.0e11, 'N': 1, 'b': np.array([0.0]), 't_R': 1.0e6},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_estimator(case['L'], case['E'], case['N'], case['b'], case['t_R'])\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "许多后验误差估计量的主要应用是指导自适应网格细化 (AMR)。本实践模拟了一个完整的自适应反馈循环，使用局部误差指标来决定细化网格的哪些部分。通过实施著名的 Dörfler 标记策略，您将亲眼看到如何利用局部误差信息来达到最优收敛率，特别是对于具有奇点的挑战性问题。",
            "id": "3542038",
            "problem": "考虑在二维 L 型域上的小应变线性弹性问题，该域带有一个凹角。设物体在平面应变条件下建模，其拉梅参数为 $\\lambda$ 和 $\\mu$，位移场 $\\mathbf{u}$ 由强形式 $-\\nabla \\cdot \\boldsymbol{\\sigma} = \\mathbf{f}$ 在 $\\Omega$ 中控制，其中 $\\boldsymbol{\\sigma} = \\lambda (\\nabla \\cdot \\mathbf{u}) \\mathbf{I} + 2 \\mu \\, \\boldsymbol{\\varepsilon}(\\mathbf{u})$ 且 $\\boldsymbol{\\varepsilon}(\\mathbf{u}) = \\tfrac{1}{2}(\\nabla \\mathbf{u} + (\\nabla \\mathbf{u})^{\\top})$，并服从混合边界条件。在带凹角的域中，解在角点附近表现出奇异的应力状态和降低的正则性。采用由后验误差估计引导的自适应网格加密来恢复能量范数下的最优收敛率。\n\n一种基于残差跳跃的估计子将全局误差代理划分为每个单元 $K$ 的局部指标 $\\eta_K$，在有限元法（FEM）的标准假设下，已知该估计子既可靠又有效。一种体追踪策略选择要加密的单元，以便在每一步中处理掉全局估计子的一个固定比例。其中一种策略被称为 Dörfler 标记。您必须以最小基数的意义实现此标记：在所有能够捕获总平方指标指定比例的单元子集中，选择一个单元数量最少的子集。\n\n为了在不求解线性弹性方程的情况下使此方法可实现，请使用一个与凹角奇异性类别一致的标量代理（这在自适应方法的分析中被广泛采用）。具体来说，在 L 型域 $\\Omega = [-1,1]^2 \\setminus \\big([0,1]\\times[-1,0]\\big)$ 上，其凹角位于原点，通过以下幂律来模拟角点附近的局部指标缩放：\n$$\n\\eta_K \\approx c \\, \\sqrt{h_K} \\, r_K^{\\alpha - 1},\n$$\n其中 $c$ 是一个正常数（设 $c=1$），$h_K$ 是单元尺寸，$r_K$ 是从单元中心到原点的欧几里得距离，而 $\\alpha = 0.544483736782$ 是与齐次标量椭圆模型相关的 L 型域奇异性指数。该代理与带角点奇异性问题的残差跳跃误差估计子的行为一致，并能捕捉到必要的近角点加密偏置。\n\n您的任务是：\n- 通过将 $[-1,1]^2$ 细分为 $n_x \\times n_y$ 个相等大小的正方形，并丢弃那些中心位于被切除正方形 $[0,1]\\times[-1,0]$ 内的单元，来构建 $\\Omega$ 上的初始均匀方形剖分。使用 $n_x = n_y = 12$。\n- 对于每个单元 $K$，使用上述代理模型计算 $r_K$ 和 $\\eta_K$。通过设置 $r_K \\leftarrow \\max(r_K, 10^{-6})$ 来避免除以零。\n- 实现最小基数的体追踪标记策略。对于给定的参数 $\\theta \\in (0,1)$，该策略选择一个集合 $\\mathcal{M}$，使得所选单元的平方指标之和至少占总平方估计子的一部分，同时被标记的单元数量尽可能少。\n- 通过将每个选定的正方形细分为四个尺寸减半的子正方形来加密标记的单元。中心落在 $\\Omega$ 之外的子单元必须被丢弃；位于内部的子单元则取代其父单元进入网格。在加密后的网格上重新计算指标。\n- 对固定的加密步数重复标记-加密循环，每次都使用相同的 $\\theta$。使用 $N_{\\text{steps}} = 7$。\n- 在每一步 $k$，计算全局估计子 $E_k = \\left(\\sum_{K} \\eta_K^2\\right)^{1/2}$ 和网格中当前的单元数 $N_k$。\n- 通过对最后五个加密步骤的 $(\\log N_k, \\log E_k)$ 数据进行线性拟合来估计收敛率 $p(\\theta)$，并取 $p(\\theta) = -\\text{斜率}$。这近似了模型 $E(N) \\approx C N^{-p}$ 在 $N$ 较大时的收敛率。\n\n将上述过程实现在一个单一程序中，该程序评估多个 $\\theta$ 值并报告估计的收敛率。您必须确保代理模型和加密过程的数值稳定性和科学合理性。\n\n测试套件：\n- 使用以下 $\\theta$ 值：$0.15$、$0.3$、$0.5$、$0.7$、$0.9$。\n- 对于每个 $\\theta$，运行完整的加密循环并按规定计算 $p(\\theta)$。\n\n答案规范：\n- 您程序的最终输出必须是单行文本，包含测试套件中所有 $\\theta$ 值的估计率列表，顺序与提供的一致。\n- 格式必须是用方括号括起来的逗号分隔列表，例如 $[p(0.15),p(0.3),p(0.5),p(0.7),p(0.9)]$。\n- 每个条目必须是浮点数。不需要物理单位，也不涉及角度。\n\n您的程序必须是自包含的，无需任何外部输入或文件即可运行。",
            "solution": "该问题为模拟自适应网格加密（AMR）过程提供了详细的规范，该过程针对的是一个带角点奇异性的问题。验证证实了该问题在科学上是合理的、适定的，并包含了确定性实现所需的所有必要信息。这是自适应有限元方法（AFEM）领域的一个标准数值实验。\n\n核心任务是实现一个由 Dörfler 标记驱动的`标记-加密`循环，使用一个代理误差指标，该指标模拟了 L 型域上椭圆偏微分方程解的行为。最终目标是估计全局误差估计子随单元数量变化的收敛率，并研究其如何随不同标记参数 $\\theta$ 值而变化。\n\n**1. 域和初始网格**\n\n计算域是 L 型区域 $\\Omega = [-1,1]^2 \\setminus \\big([0,1]\\times[-1,0]\\big)$，其在原点 $(0,0)$ 处有一个凹角。这个角点会在椭圆边值问题的解中引发奇异性，从而降低标准数值方法在均匀网格上的性能。\n\n模拟从构建初始网格开始。首先将一个正方形域 $[-1,1]^2$ 剖分为一个 $n_x \\times n_y$ 的均匀网格，其中包含多个较小的正方形，设定 $n_x = n_y = 12$。这些初始单元的边长为 $h_0 = (1 - (-1))/12 = 2/12 = 1/6$。那些几何中心 $(x_c, y_c)$ 落在被切除象限内的单元，即满足 $x_c  0$ 且 $y_c \\le 0$ 的单元，将被丢弃。此过程产生一个包含 $N_0 = 12^2 - 6^2 = 144 - 36 = 108$ 个正方形单元的初始网格，该网格精确地表示了域 $\\Omega$。\n\n网格中的每个单元 $K$ 由其中心坐标和边长 $h_K$ 表示。\n\n**2. 代理误差指标**\n\n我们不求解计算成本高昂的完整线性弹性方程，而是为每个单元 $K$ 上的局部误差指标 $\\eta_K$ 使用一个代理模型。该模型旨在模仿真实误差的空间分布，而该分布主要由角点奇异性决定。提供的公式为：\n$$\n\\eta_K = c \\, \\sqrt{h_K} \\, r_K^{\\alpha - 1}\n$$\n其中：\n- $c=1$ 是一个常数。\n- $h_K$ 是正方形单元 $K$ 的边长。\n- $r_K$ 是从单元 $K$ 中心到凹角（原点）的欧几里得距离。为防止可能以原点为中心的单元出现除以零的情况，$r_K$ 被限制在一个最小值：$r_K \\leftarrow \\max(r_K, 10^{-6})$。\n- $\\alpha = 0.544483736782$ 是奇异性的强度。对于 L 型域上的泊松方程，角点附近的解具有 $u \\sim r^{\\alpha} \\sin(\\alpha \\phi)$ 的形式，其中 $(r, \\phi)$ 是极坐标。误差集中在解的梯度较大的地方。由于 $\\alpha  1$，当 $r_K \\to 0$ 时，$r_K^{\\alpha - 1}$ 项会变大，从而正确地将靠近奇异点的单元识别为具有较大的误差贡献。\n\n**3. 自适应 `标记-加密` (MARK-REFINE) 算法**\n\n模拟的核心是一个迭代循环，用于自适应地加密网格。对于给定的标记参数 $\\theta \\in (0,1)$，循环运行 $N_{\\text{steps}}=7$ 次。每次迭代包括四个主要步骤：计算 (COMPUTE)、标记 (MARK)、加密 (REFINE) 和记录 (RECORD)。\n\n**3A. 计算 (COMPUTE)**\n在第 $k$ 步，对于当前网格 $\\mathcal{T}_k$，我们首先使用代理公式为每个单元 $K \\in \\mathcal{T}_k$ 计算误差指标 $\\eta_K$。然后，计算总误差估计子的平方，作为局部指标平方的总和：\n$$\nE_k^2 = \\sum_{K \\in \\mathcal{T}_k} \\eta_K^2\n$$\n\n**3B. 标记 (MARK)**\n标记步骤选择网格 $\\mathcal{T}_k$ 的一个子集 $\\mathcal{M}_k$ 进行加密。我们采用 Dörfler 标记（也称为体追踪），其目的是加密足够数量的单元以保证总误差的减少。该策略是找到一个具有最小可能单元数（最小基数）的集合 $\\mathcal{M}_k$，满足以下标准：\n$$\n\\sum_{K \\in \\mathcal{M}_k} \\eta_K^2 \\ge \\theta E_k^2\n$$\n从算法上讲，这是通过以下方式实现的：\n1. 根据所有单元的指标值 $\\eta_K$ 进行降序排序。\n2. 遍历排序后的列表，将单元添加到标记集 $\\mathcal{M}_k$ 中，并累加它们的平方指标。\n3. 一旦累加和达到目标阈值 $\\theta E_k^2$，便停止。这种贪心方法保证了我们选择误差最大的单元，同时标记的单元数量最少。\n\n**3C. 加密 (REFINE)**\n$\\mathcal{M}_k$ 中的被标记单元被加密，而未标记的单元则被移至下一个网格 $\\mathcal{T}_{k+1}$。对于一个正方形单元，加密过程是简单的四分法：\n1. 每个被标记的正方形 $K \\in \\mathcal{M}_k$ 被细分为四个相等的较小正方形（子单元），每个子单元的边长是父单元的一半。\n2. 检查每个子单元的有效性：其中心必须位于域 $\\Omega$ 内。中心在被切除区域 $[0,1] \\times [-1,0]$ 内的子单元将被丢弃。\n3. 新网格 $\\mathcal{T}_{k+1}$ 由来自 $\\mathcal{T}_k$ 的未标记单元集合与所有有效的新子单元集合的并集构成。\n\n**3D. 记录 (RECORD)**\n在每一步 $k$，我们记录单元数量 $N_k = |\\mathcal{T}_k|$ 和全局误差估计子 $E_k = \\sqrt{E_k^2}$。\n\n**4. 收敛率估计**\n\nAFEM 的理论预测，对于适当的自适应策略，误差 $E$ 相对于单元数量 $N$ 的收敛应遵循幂律：\n$$\nE(N) \\approx C N^{-p}\n$$\n其中 $p$ 是收敛率。对于带奇异性的问题，均匀加密会产生次优的收convergence率，但自适应加密可以恢复最优收敛率，该最优率与奇异性指数 $\\alpha$ 有关。对上述关系取对数，得到一个线性方程：\n$$\n\\log E \\approx \\log C - p \\log N\n$$\n这表明 $\\log E$ 相对于 $\\log N$ 的图应该是一条斜率为 $-p$ 的直线。\n\n为了估计 $p$，我们对收集到的数据点 $(\\log N_k, \\log E_k)$ 进行线性回归。按照规定，我们使用最后五个加密步骤（从 $k=2$ 到 $k=6$）的数据来估计渐近率，忽略任何初始的瞬态行为。计算出最佳拟合线的斜率，收敛率则确定为 $p(\\theta) = -\\text{斜率}$。对测试套件中的每个 $\\theta$ 值重复整个过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements an adaptive mesh refinement simulation for an L-shaped domain\n    to estimate the convergence rate of a surrogate error estimator.\n    \"\"\"\n\n    # --- Problem Parameters ---\n    ALPHA = 0.544483736782\n    THETAS = [0.15, 0.3, 0.5, 0.7, 0.9]\n    N_STEPS = 7\n    NX, NY = 12, 12\n    R_CLAMP = 1e-6\n\n    def is_in_domain(center):\n        \"\"\"Checks if a point is within the L-shaped domain.\"\"\"\n        x, y = center\n        # The excised region is where x > 0 and y = 0.\n        return not (x > 0 and y = 0)\n\n    def generate_initial_mesh():\n        \"\"\"Creates the initial uniform mesh on the L-shaped domain.\"\"\"\n        h_initial = 2.0 / NX\n        mesh_elements = []\n        for i in range(NX):\n            for j in range(NY):\n                xc = -1.0 + h_initial / 2.0 + i * h_initial\n                yc = -1.0 + h_initial / 2.0 + j * h_initial\n                if is_in_domain((xc, yc)):\n                    # Each element is [center_x, center_y, size]\n                    mesh_elements.append([xc, yc, h_initial])\n        return np.array(mesh_elements)\n\n    def run_simulation(theta):\n        \"\"\"\n        Runs the full mark-refine simulation for a given theta value.\n        \"\"\"\n        mesh = generate_initial_mesh()\n        log_N_E_data = []\n\n        for step in range(N_STEPS):\n            # 1. COMPUTE: Indicators and global estimator\n            if mesh.shape[0] == 0:\n                if len(log_N_E_data) >= 5:\n                    break\n                else: \n                    return np.nan \n\n            centers = mesh[:, :2]\n            sizes = mesh[:, 2]\n            \n            r_k = np.linalg.norm(centers, axis=1)\n            r_k = np.maximum(r_k, R_CLAMP)\n            \n            eta_k = np.sqrt(sizes) * r_k**(ALPHA - 1)\n            eta_k_sq = eta_k**2\n            \n            E_k_sq = np.sum(eta_k_sq)\n            E_k = np.sqrt(E_k_sq)\n            N_k = mesh.shape[0]\n\n            # 2. RECORD: Store log-log data\n            log_N_E_data.append([np.log(N_k), np.log(E_k)])\n\n            if step == N_STEPS - 1:\n                break\n\n            # 3. MARK: Dörfler marking\n            total_eta_sq = E_k_sq\n            target_sum_sq = theta * total_eta_sq\n            \n            sorted_indices = np.argsort(eta_k)[::-1]\n            sorted_eta_k_sq = eta_k_sq[sorted_indices]\n            \n            cumulative_sum_sq = np.cumsum(sorted_eta_k_sq)\n            \n            num_to_mark = np.searchsorted(cumulative_sum_sq, target_sum_sq, side='left') + 1\n            \n            marked_indices = sorted_indices[:num_to_mark]\n            unmarked_indices = sorted_indices[num_to_mark:]\n\n            # 4. REFINE: Create the new mesh\n            unmarked_elements = mesh[unmarked_indices] if len(unmarked_indices) > 0 else np.empty((0, 3))\n            \n            newly_refined_elements = []\n            for idx in marked_indices:\n                parent_center = mesh[idx, :2]\n                parent_size = mesh[idx, 2]\n                child_size = parent_size / 2.0\n                offset = child_size / 2.0\n                \n                child_centers = [\n                    parent_center + np.array([-offset, -offset]),\n                    parent_center + np.array([ offset, -offset]),\n                    parent_center + np.array([-offset,  offset]),\n                    parent_center + np.array([ offset,  offset]),\n                ]\n                \n                for child_center in child_centers:\n                    if is_in_domain(child_center):\n                        newly_refined_elements.append([child_center[0], child_center[1], child_size])\n            \n            if newly_refined_elements:\n                mesh = np.vstack((unmarked_elements, np.array(newly_refined_elements)))\n            else:\n                mesh = unmarked_elements\n        \n        # 5. ESTIMATE CONVERGENCE RATE\n        if len(log_N_E_data)  5:\n            return np.nan\n\n        last_5_data = np.array(log_N_E_data[-5:])\n        log_N = last_5_data[:, 0]\n        log_E = last_5_data[:, 1]\n        \n        slope, _ = np.polyfit(log_N, log_E, 1)\n        \n        p_theta = -slope\n        return p_theta\n\n    results = []\n    for theta in THETAS:\n        rate = run_simulation(theta)\n        results.append(rate)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}