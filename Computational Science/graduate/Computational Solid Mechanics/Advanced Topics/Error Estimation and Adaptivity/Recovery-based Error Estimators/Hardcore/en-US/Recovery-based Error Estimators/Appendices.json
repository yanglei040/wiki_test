{
    "hands_on_practices": [
        {
            "introduction": "The foundation of any recovery-based error estimator is the local, or element-wise, error indicator $\\eta_K$. This value quantifies the estimated error contained within a single finite element, and the global error estimate is simply a sum of these local contributions. This first practice provides a concrete exercise in computing the squared error indicator $\\eta_K^2$ by applying its definition directly, connecting the abstract concept of error energy to a tangible numerical value using material properties and strain data .",
            "id": "3593882",
            "problem": "Consider a single two-dimensional finite element $K$ in a small-strain, linear, isotropic, plane-strain solid. The material has Young’s modulus $E = 210 \\times 10^{9}$ and Poisson’s ratio $\\nu = 0.3$. The element has area $A = 0.25$ and constant thickness $t = 0.02$, so its volume is $V = A\\,t$. The local energy-norm error indicator squared $\\eta_{K}^{2}$ is defined as the element-wise integral of the energy density of the strain error, namely the integral over $K$ of $\\left(\\boldsymbol{\\varepsilon}^{*} - \\boldsymbol{\\varepsilon}_{h}\\right) : \\mathbb{C} \\left(\\boldsymbol{\\varepsilon}^{*} - \\boldsymbol{\\varepsilon}_{h}\\right)$, where $\\mathbb{C}$ is the fourth-order elasticity tensor for plane strain, $\\boldsymbol{\\varepsilon}^{*}$ is the recovered strain (for example from Superconvergent Patch Recovery using the Zienkiewicz–Zhu method), and $\\boldsymbol{\\varepsilon}_{h}$ is the finite element strain. Use a three-point symmetric quadrature over the triangle, with equal weights $w_{q} = V/3$ at quadrature points $q = 1,2,3$.\n\nCompute $\\eta_{K}^{2}$ using the following sampled strains at the quadrature points (all strains are components of the symmetric small-strain tensor in the plane, reported as $(\\varepsilon_{xx}, \\varepsilon_{yy}, \\varepsilon_{xy})$):\n- At point $q=1$: $\\boldsymbol{\\varepsilon}^{*}(x_{1}) = \\left(1.2 \\times 10^{-3},\\, 0.8 \\times 10^{-3},\\, 0.5 \\times 10^{-3}\\right)$ and $\\boldsymbol{\\varepsilon}_{h}(x_{1}) = \\left(1.0 \\times 10^{-3},\\, 0.9 \\times 10^{-3},\\, 0.4 \\times 10^{-3}\\right)$.\n- At point $q=2$: $\\boldsymbol{\\varepsilon}^{*}(x_{2}) = \\left(1.1 \\times 10^{-3},\\, 0.85 \\times 10^{-3},\\, 0.6 \\times 10^{-3}\\right)$ and $\\boldsymbol{\\varepsilon}_{h}(x_{2}) = \\left(1.05 \\times 10^{-3},\\, 0.90 \\times 10^{-3},\\, 0.55 \\times 10^{-3}\\right)$.\n- At point $q=3$: $\\boldsymbol{\\varepsilon}^{*}(x_{3}) = \\left(1.3 \\times 10^{-3},\\, 0.75 \\times 10^{-3},\\, 0.45 \\times 10^{-3}\\right)$ and $\\boldsymbol{\\varepsilon}_{h}(x_{3}) = \\left(1.15 \\times 10^{-3},\\, 0.80 \\times 10^{-3},\\, 0.50 \\times 10^{-3}\\right)$.\n\nAssume plane strain with Lamé parameters $\\lambda$ and $\\mu$, and use the exact small-strain linear elasticity relations for $\\mathbb{C}$. Express the final value of $\\eta_{K}^{2}$ in Joules. Round your answer to four significant figures.",
            "solution": "The user has provided a well-posed problem in computational solid mechanics. All necessary data are provided, and the requested calculation is based on standard, scientifically sound principles of the finite element method and continuum mechanics. The problem is therefore deemed valid.\n\nThe objective is to compute the squared energy-norm error indicator, $\\eta_{K}^{2}$, for a single finite element $K$. The definition is given as:\n$$\n\\eta_{K}^{2} = \\int_{K} \\left(\\boldsymbol{\\varepsilon}^{*} - \\boldsymbol{\\varepsilon}_{h}\\right) : \\mathbb{C} \\left(\\boldsymbol{\\varepsilon}^{*} - \\boldsymbol{\\varepsilon}_{h}\\right) dV\n$$\nwhere $\\boldsymbol{\\varepsilon}^{*}$ is the recovered strain, $\\boldsymbol{\\varepsilon}_{h}$ is the finite element strain, and $\\mathbb{C}$ is the fourth-order elasticity tensor for a linear, isotropic material under plane strain conditions. Let the error strain be $\\boldsymbol{\\varepsilon}_{e} = \\boldsymbol{\\varepsilon}^{*} - \\boldsymbol{\\varepsilon}_{h}$. The integral becomes:\n$$\n\\eta_{K}^{2} = \\int_{K} \\boldsymbol{\\varepsilon}_{e} : \\mathbb{C} \\boldsymbol{\\varepsilon}_{e} \\, dV\n$$\nThe integral is evaluated using a three-point numerical quadrature rule with equal weights $w_{q} = V/3$ for each quadrature point $q \\in \\{1,2,3\\}$. The element volume $V$ is given by the area $A=0.25$ and thickness $t=0.02$. Assuming consistent SI units, $A$ is in $m^2$ and $t$ is in m.\n$$\nV = A \\cdot t = 0.25 \\, \\text{m}^2 \\times 0.02 \\, \\text{m} = 0.005 \\, \\text{m}^3\n$$\nThe quadrature weights are $w_1=w_2=w_3 = V/3 = 0.005/3$ $m^3$.\nThe integral is thus approximated as a sum:\n$$\n\\eta_{K}^{2} \\approx \\sum_{q=1}^{3} w_{q} \\left[ \\boldsymbol{\\varepsilon}_{e}(x_{q}) : \\mathbb{C} \\boldsymbol{\\varepsilon}_{e}(x_{q}) \\right] = \\frac{V}{3} \\sum_{q=1}^{3} \\left[ \\boldsymbol{\\varepsilon}_{e,q} : \\mathbb{C} \\boldsymbol{\\varepsilon}_{e,q} \\right]\n$$\nThe term $\\boldsymbol{\\varepsilon}_{e} : \\mathbb{C} \\boldsymbol{\\varepsilon}_{e}$ represents the strain energy density of the error strain field, multiplied by a factor of $2$. For a linear isotropic material, the stress tensor is given by $\\boldsymbol{\\sigma} = \\lambda \\, \\text{tr}(\\boldsymbol{\\varepsilon}) \\mathbf{I} + 2\\mu \\boldsymbol{\\varepsilon}$, where $\\lambda$ and $\\mu$ are the Lamé parameters. The energy density term is equivalent to $\\boldsymbol{\\sigma}_{e} : \\boldsymbol{\\varepsilon}_{e}$. Under plane strain conditions ($\\varepsilon_{zz}=0, \\varepsilon_{xz}=0, \\varepsilon_{yz}=0$), this expands to:\n$$\n\\boldsymbol{\\varepsilon}_{e} : \\mathbb{C} \\boldsymbol{\\varepsilon}_{e} = \\lambda \\left(\\varepsilon_{e,xx} + \\varepsilon_{e,yy}\\right)^2 + 2\\mu \\left(\\varepsilon_{e,xx}^2 + \\varepsilon_{e,yy}^2 + 2\\varepsilon_{e,xy}^2\\right)\n$$\nThe Lamé parameters are calculated from the given Young's modulus $E = 210 \\times 10^{9}$ Pa and Poisson's ratio $\\nu = 0.3$:\n$$\n\\mu = \\frac{E}{2(1+\\nu)} = \\frac{210 \\times 10^9}{2(1+0.3)} = \\frac{210 \\times 10^9}{2.6} = \\frac{105}{1.3} \\times 10^9 \\, \\text{Pa}\n$$\n$$\n\\lambda = \\frac{E\\nu}{(1+\\nu)(1-2\\nu)} = \\frac{(210 \\times 10^9)(0.3)}{(1+0.3)(1-2(0.3))} = \\frac{63 \\times 10^9}{1.3 \\times 0.4} = \\frac{63 \\times 10^9}{0.52} = \\frac{1575}{13} \\times 10^9 \\, \\text{Pa}\n$$\nNext, we calculate the error strain tensor $\\boldsymbol{\\varepsilon}_{e,q}$ at each quadrature point $q$:\n\\begin{itemize}\n    \\item For $q=1$: $\\boldsymbol{\\varepsilon}_{e,1} = \\boldsymbol{\\varepsilon}^{*}(x_{1}) - \\boldsymbol{\\varepsilon}_{h}(x_{1})$\n    $$\n    \\boldsymbol{\\varepsilon}_{e,1} = \\left(1.2 \\times 10^{-3} - 1.0 \\times 10^{-3}, \\, 0.8 \\times 10^{-3} - 0.9 \\times 10^{-3}, \\, 0.5 \\times 10^{-3} - 0.4 \\times 10^{-3}\\right)\n    $$\n    $$\n    \\boldsymbol{\\varepsilon}_{e,1} = \\left(0.2 \\times 10^{-3}, \\, -0.1 \\times 10^{-3}, \\, 0.1 \\times 10^{-3}\\right)\n    $$\n    \\item For $q=2$: $\\boldsymbol{\\varepsilon}_{e,2} = \\boldsymbol{\\varepsilon}^{*}(x_{2}) - \\boldsymbol{\\varepsilon}_{h}(x_{2})$\n    $$\n    \\boldsymbol{\\varepsilon}_{e,2} = \\left(1.1 \\times 10^{-3} - 1.05 \\times 10^{-3}, \\, 0.85 \\times 10^{-3} - 0.90 \\times 10^{-3}, \\, 0.6 \\times 10^{-3} - 0.55 \\times 10^{-3}\\right)\n    $$\n    $$\n    \\boldsymbol{\\varepsilon}_{e,2} = \\left(0.05 \\times 10^{-3}, \\, -0.05 \\times 10^{-3}, \\, 0.05 \\times 10^{-3}\\right)\n    $$\n    \\item For $q=3$: $\\boldsymbol{\\varepsilon}_{e,3} = \\boldsymbol{\\varepsilon}^{*}(x_{3}) - \\boldsymbol{\\varepsilon}_{h}(x_{3})$\n    $$\n    \\boldsymbol{\\varepsilon}_{e,3} = \\left(1.3 \\times 10^{-3} - 1.15 \\times 10^{-3}, \\, 0.75 \\times 10^{-3} - 0.80 \\times 10^{-3}, \\, 0.45 \\times 10^{-3} - 0.50 \\times 10^{-3}\\right)\n    $$\n    $$\n    \\boldsymbol{\\varepsilon}_{e,3} = \\left(0.15 \\times 10^{-3}, \\, -0.05 \\times 10^{-3}, \\, -0.05 \\times 10^{-3}\\right)\n    $$\n\\end{itemize}\nNow, we evaluate the integrand term $I_q = \\boldsymbol{\\varepsilon}_{e,q} : \\mathbb{C} \\boldsymbol{\\varepsilon}_{e,q}$ for each point. We can factor out $(10^{-3})^2 = 10^{-6}$.\n\\begin{itemize}\n    \\item For $q=1$:\n    $$\n    I_1 = \\left[ \\lambda \\left(0.2 - 0.1\\right)^2 + 2\\mu \\left( (0.2)^2 + (-0.1)^2 + 2(0.1)^2 \\right) \\right] \\times 10^{-6}\n    $$\n    $$\n    I_1 = \\left[ \\lambda(0.1)^2 + 2\\mu(0.04 + 0.01 + 0.02) \\right] \\times 10^{-6} = (0.01\\lambda + 0.14\\mu) \\times 10^{-6}\n    $$\n    \\item For $q=2$:\n    $$\n    I_2 = \\left[ \\lambda \\left(0.05 - 0.05\\right)^2 + 2\\mu \\left( (0.05)^2 + (-0.05)^2 + 2(0.05)^2 \\right) \\right] \\times 10^{-6}\n    $$\n    $$\n    I_2 = \\left[ \\lambda(0)^2 + 2\\mu(0.0025 + 0.0025 + 0.005) \\right] \\times 10^{-6} = (0.02\\mu) \\times 10^{-6}\n    $$\n    \\item For $q=3$:\n    $$\n    I_3 = \\left[ \\lambda \\left(0.15 - 0.05\\right)^2 + 2\\mu \\left( (0.15)^2 + (-0.05)^2 + 2(-0.05)^2 \\right) \\right] \\times 10^{-6}\n    $$\n    $$\n    I_3 = \\left[ \\lambda(0.1)^2 + 2\\mu(0.0225 + 0.0025 + 0.005) \\right] \\times 10^{-6} = (0.01\\lambda + 0.06\\mu) \\times 10^{-6}\n    $$\n\\end{itemize}\nThe sum of the integrand contributions is:\n$$\n\\sum_{q=1}^{3} I_q = ( (0.01\\lambda + 0.14\\mu) + (0.02\\mu) + (0.01\\lambda + 0.06\\mu) ) \\times 10^{-6}\n$$\n$$\n\\sum_{q=1}^{3} I_q = (0.02\\lambda + 0.22\\mu) \\times 10^{-6}\n$$\nNow, substitute the values for $\\lambda$ and $\\mu$:\n$$\n\\sum_{q=1}^{3} I_q = \\left(0.02 \\left(\\frac{1575}{13}\\times 10^9\\right) + 0.22 \\left(\\frac{105}{1.3}\\times 10^9\\right)\\right) \\times 10^{-6}\n$$\n$$\n\\sum_{q=1}^{3} I_q = \\left(\\frac{31.5}{13}\\times 10^9 + \\frac{23.1}{1.3}\\times 10^9\\right) \\times 10^{-6} = \\left(\\frac{31.5}{13}\\times 10^9 + \\frac{231}{13}\\times 10^9\\right) \\times 10^{-6}\n$$\n$$\n\\sum_{q=1}^{3} I_q = \\left(\\frac{262.5}{13}\\times 10^9\\right) \\times 10^{-6} = \\frac{262.5}{13} \\times 10^3 \\, \\text{J/m}^3\n$$\nFinally, compute $\\eta_{K}^{2}$:\n$$\n\\eta_{K}^{2} = \\frac{V}{3} \\sum_{q=1}^{3} I_q = \\frac{0.005}{3} \\times \\left(\\frac{262.5}{13} \\times 10^3\\right)\n$$\n$$\n\\eta_{K}^{2} = \\frac{0.005 \\times 262.5 \\times 1000}{3 \\times 13} = \\frac{5 \\times 262.5}{39} = \\frac{1312.5}{39} \\approx 33.653846... \\, \\text{J}\n$$\nRounding the result to four significant figures as requested gives $33.65$.",
            "answer": "$$\n\\boxed{33.65}\n$$"
        },
        {
            "introduction": "The previous exercise took the recovered strain field $\\boldsymbol{\\varepsilon}^*$ as a given. But how is this higher-accuracy field obtained in the first place? This practice delves into the mathematical machinery of Superconvergent Patch Recovery (SPR), a cornerstone of the Zienkiewicz-Zhu method, by deriving the weighted least-squares system used to construct the smooth polynomial approximation from the raw, discontinuous finite element stresses . This reveals the linear algebra that underpins the entire recovery process.",
            "id": "3593897",
            "problem": "Consider Superconvergent Patch Recovery (SPR) for a single in-plane stress component in two-dimensional linear elasticity over a local patch around a node. Let the recovered stress field be approximated by a polynomial ansatz with coefficients collected in a vector $\\mathbf{a} \\in \\mathbb{R}^{3}$ using the basis $\\{\\phi_{1},\\phi_{2},\\phi_{3}\\}$ defined by $\\phi_{1}(x,y)=1$, $\\phi_{2}(x,y)=x$, and $\\phi_{3}(x,y)=y$. Suppose there are $N$ sampling points indexed by $m=1,\\dots,N$ with nondimensional local coordinates $(x_{m},y_{m})$, weights $w_{m} \\ge 0$, and finite element sample stresses $s_{m}$.\n\nDefine the weighted least-squares functional\n$$\nJ(\\mathbf{a})=\\sum_{m=1}^{N} w_{m}\\,\\bigg(\\sum_{i=1}^{3} a_{i}\\,\\phi_{i}(x_{m},y_{m}) - s_{m}\\bigg)^{2}.\n$$\nStarting from this functional and the calculus of variations for finite-dimensional optimization, derive the normal equations for the minimizer and show they can be written in the form of a linear system with a symmetric matrix multiplying $\\mathbf{a}$ and a right-hand side vector formed from weighted data. Then, for the specific data below, explicitly construct the matrix and vector of this system and compute the determinant of the matrix.\n\nUse the following sampling set with $N=4$:\n- Point $m=1$: $(x_{1},y_{1})=(0,0)$, $w_{1}=1$, $s_{1}=2$.\n- Point $m=2$: $(x_{2},y_{2})=(1,0)$, $w_{2}=2$, $s_{2}=3$.\n- Point $m=3$: $(x_{3},y_{3})=(0,1)$, $w_{3}=1$, $s_{3}=4$.\n- Point $m=4$: $(x_{4},y_{4})=(1,1)$, $w_{4}=3$, $s_{4}=6$.\n\nAfter forming the system, discuss the conditions under which the matrix in the normal equations is invertible in the general case with the basis $\\{1,x,y\\}$ and nonnegative weights. Your final reported answer must be the determinant of the matrix for the given data above, expressed as an exact integer with no units. No rounding is required. All coordinates are nondimensional, so no units are associated with any of the quantities.",
            "solution": "The problem statement is evaluated against the validation criteria.\n\n### Step 1: Extract Givens\n- **Problem Domain**: Superconvergent Patch Recovery (SPR) in two-dimensional linear elasticity.\n- **Recovered Field Ansatz**: A single stress component is approximated by $\\sum_{i=1}^{3} a_{i}\\,\\phi_{i}(x,y)$.\n- **Coefficients**: $\\mathbf{a} = [a_1, a_2, a_3]^T \\in \\mathbb{R}^{3}$.\n- **Basis Functions**: $\\{\\phi_{1},\\phi_{2},\\phi_{3}\\}$ where $\\phi_{1}(x,y)=1$, $\\phi_{2}(x,y)=x$, and $\\phi_{3}(x,y)=y$.\n- **Sampling Data**: A set of $N$ sampling points with index $m=1,\\dots,N$, having local coordinates $(x_{m},y_{m})$, non-negative weights $w_{m} \\ge 0$, and finite element sample stresses $s_{m}$.\n- **Functional to Minimize**: The weighted least-squares functional $J(\\mathbf{a})=\\sum_{m=1}^{N} w_{m}\\,\\bigg(\\sum_{i=1}^{3} a_{i}\\,\\phi_{i}(x_{m},y_{m}) - s_{m}\\bigg)^{2}$.\n- **Specific Data for $N=4$**:\n  - Point $m=1$: $(x_{1},y_{1})=(0,0)$, $w_{1}=1$, $s_{1}=2$.\n  - Point $m=2$: $(x_{2},y_{2})=(1,0)$, $w_{2}=2$, $s_{2}=3$.\n  - Point $m=3$: $(x_{3},y_{3})=(0,1)$, $w_{3}=1$, $s_{3}=4$.\n  - Point $m=4$: $(x_{4},y_{4})=(1,1)$, $w_{4}=3$, $s_{4}=6$.\n- **Tasks**:\n  1. Derive the normal equations for the minimizer of $J(\\mathbf{a})$.\n  2. Show that these equations form a linear system with a symmetric matrix.\n  3. For the specific data, explicitly construct the matrix and the right-hand side vector.\n  4. Compute the determinant of the matrix.\n  5. Discuss the conditions for the matrix's invertibility in the general case.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is evaluated as follows:\n- **Scientifically Grounded**: The problem is based on the well-established weighted least-squares method, a fundamental technique in approximation theory and numerical analysis. Its application to Superconvergent Patch Recovery is a standard procedure in the finite element method for a posteriori error estimation. The setup is scientifically and mathematically sound.\n- **Well-Posed**: The problem is well-posed. Minimizing a strictly convex quadratic functional yields a unique solution, provided the system matrix is invertible. The problem provides sufficient data and clear objectives to determine a unique solution.\n- **Objective**: The problem is stated in precise, objective mathematical language, free from ambiguity or subjective claims.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. It is self-contained, consistent, and scientifically grounded. I will proceed with the solution.\n\nThe weighted least-squares functional to be minimized is given by\n$$\nJ(\\mathbf{a})=\\sum_{m=1}^{N} w_{m}\\,\\bigg(\\sum_{i=1}^{3} a_{i}\\,\\phi_{i}(x_{m},y_{m}) - s_{m}\\bigg)^{2}.\n$$\nSubstituting the given basis functions $\\phi_{1}(x,y)=1$, $\\phi_{2}(x,y)=x$, and $\\phi_{3}(x,y)=y$, the functional becomes\n$$\nJ(\\mathbf{a})=\\sum_{m=1}^{N} w_{m}\\,\\left(a_{1} + a_{2}x_{m} + a_{3}y_{m} - s_{m}\\right)^{2}.\n$$\nTo find the coefficients $\\mathbf{a}=[a_1, a_2, a_3]^T$ that minimize this functional, we must set the partial derivatives of $J(\\mathbf{a})$ with respect to each coefficient $a_{k}$ to zero. This is a necessary condition for a minimum of the convex functional $J$. For $k=1, 2, 3$:\n$$\n\\frac{\\partial J}{\\partial a_{k}} = 0.\n$$\nLet's compute these partial derivatives.\nFor $k=1$:\n$$\n\\frac{\\partial J}{\\partial a_{1}} = \\sum_{m=1}^{N} 2w_{m}\\,(a_{1} + a_{2}x_{m} + a_{3}y_{m} - s_{m}) \\frac{\\partial}{\\partial a_1}(a_{1} + a_{2}x_{m} + a_{3}y_{m}) = \\sum_{m=1}^{N} 2w_{m}\\,(a_{1} + a_{2}x_{m} + a_{3}y_{m} - s_{m}) = 0.\n$$\nFor $k=2$:\n$$\n\\frac{\\partial J}{\\partial a_{2}} = \\sum_{m=1}^{N} 2w_{m}\\,(a_{1} + a_{2}x_{m} + a_{3}y_{m} - s_{m}) \\frac{\\partial}{\\partial a_2}(a_{1} + a_{2}x_{m} + a_{3}y_{m}) = \\sum_{m=1}^{N} 2w_{m}x_{m}\\,(a_{1} + a_{2}x_{m} + a_{3}y_{m} - s_{m}) = 0.\n$$\nFor $k=3$:\n$$\n\\frac{\\partial J}{\\partial a_{3}} = \\sum_{m=1}^{N} 2w_{m}\\,(a_{1} + a_{2}x_{m} + a_{3}y_{m} - s_{m}) \\frac{\\partial}{\\partial a_3}(a_{1} + a_{2}x_{m} + a_{3}y_{m}) = \\sum_{m=1}^{N} 2w_{m}y_{m}\\,(a_{1} + a_{2}x_{m} + a_{3}y_{m} - s_{m}) = 0.\n$$\nWe can divide each equation by $2$ and rearrange the terms to separate the unknown coefficients $a_i$ from the known data $s_m$.\nFrom $\\frac{\\partial J}{\\partial a_{1}} = 0$:\n$$\na_{1}\\left(\\sum_{m=1}^{N} w_{m}\\right) + a_{2}\\left(\\sum_{m=1}^{N} w_{m}x_{m}\\right) + a_{3}\\left(\\sum_{m=1}^{N} w_{m}y_{m}\\right) = \\sum_{m=1}^{N} w_{m}s_{m}.\n$$\nFrom $\\frac{\\partial J}{\\partial a_{2}} = 0$:\n$$\na_{1}\\left(\\sum_{m=1}^{N} w_{m}x_{m}\\right) + a_{2}\\left(\\sum_{m=1}^{N} w_{m}x_{m}^2\\right) + a_{3}\\left(\\sum_{m=1}^{N} w_{m}x_{m}y_{m}\\right) = \\sum_{m=1}^{N} w_{m}x_{m}s_{m}.\n$$\nFrom $\\frac{\\partial J}{\\partial a_{3}} = 0$:\n$$\na_{1}\\left(\\sum_{m=1}^{N} w_{m}y_{m}\\right) + a_{2}\\left(\\sum_{m=1}^{N} w_{m}x_{m}y_{m}\\right) + a_{3}\\left(\\sum_{m=1}^{N} w_{m}y_{m}^2\\right) = \\sum_{m=1}^{N} w_{m}y_{m}s_{m}.\n$$\nThis system of three linear equations in the three unknowns $a_1, a_2, a_3$ constitutes the normal equations. It can be written in matrix form as $\\mathbf{M}\\mathbf{a} = \\mathbf{b}$, where:\n$$\n\\mathbf{M} = \\begin{pmatrix}\n\\sum w_m & \\sum w_m x_m & \\sum w_m y_m \\\\\n\\sum w_m x_m & \\sum w_m x_m^2 & \\sum w_m x_m y_m \\\\\n\\sum w_m y_m & \\sum w_m x_m y_m & \\sum w_m y_m^2\n\\end{pmatrix},\n\\quad \\mathbf{a} = \\begin{pmatrix} a_1 \\\\ a_2 \\\\ a_3 \\end{pmatrix},\n\\quad \\mathbf{b} = \\begin{pmatrix}\n\\sum w_m s_m \\\\\n\\sum w_m x_m s_m \\\\\n\\sum w_m y_m s_m\n\\end{pmatrix}.\n$$\nThe matrix $\\mathbf{M}$ is symmetric, since $M_{ij} = M_{ji}$. For example, $M_{12} = \\sum w_m x_m = M_{21}$, $M_{13} = \\sum w_m y_m = M_{31}$, and $M_{23} = \\sum w_m x_m y_m = M_{32}$. This fulfills the first part of the task.\n\nNext, we construct $\\mathbf{M}$ and $\\mathbf{b}$ using the provided data for $N=4$ points.\nThe data is:\n$(x_1, y_1)=(0,0), w_1=1, s_1=2$\n$(x_2, y_2)=(1,0), w_2=2, s_2=3$\n$(x_3, y_3)=(0,1), w_3=1, s_3=4$\n$(x_4, y_4)=(1,1), w_4=3, s_4=6$\n\nWe compute the necessary sums for the matrix $\\mathbf{M}$:\n$M_{11} = \\sum w_m = 1+2+1+3 = 7$.\n$M_{12} = M_{21} = \\sum w_m x_m = 1(0) + 2(1) + 1(0) + 3(1) = 0+2+0+3 = 5$.\n$M_{13} = M_{31} = \\sum w_m y_m = 1(0) + 2(0) + 1(1) + 3(1) = 0+0+1+3 = 4$.\n$M_{22} = \\sum w_m x_m^2 = 1(0^2) + 2(1^2) + 1(0^2) + 3(1^2) = 0+2+0+3 = 5$.\n$M_{23} = M_{32} = \\sum w_m x_m y_m = 1(0)(0) + 2(1)(0) + 1(0)(1) + 3(1)(1) = 0+0+0+3 = 3$.\n$M_{33} = \\sum w_m y_m^2 = 1(0^2) + 2(0^2) + 1(1^2) + 3(1^2) = 0+0+1+3 = 4$.\n\nSo, the matrix $\\mathbf{M}$ is:\n$$\n\\mathbf{M} = \\begin{pmatrix}\n7 & 5 & 4 \\\\\n5 & 5 & 3 \\\\\n4 & 3 & 4\n\\end{pmatrix}.\n$$\nNow we compute the sums for the right-hand side vector $\\mathbf{b}$:\n$b_1 = \\sum w_m s_m = 1(2)+2(3)+1(4)+3(6) = 2+6+4+18 = 30$.\n$b_2 = \\sum w_m x_m s_m = 1(0)(2)+2(1)(3)+1(0)(4)+3(1)(6) = 0+6+0+18 = 24$.\n$b_3 = \\sum w_m y_m s_m = 1(0)(2)+2(0)(3)+1(1)(4)+3(1)(6) = 0+0+4+18 = 22$.\n\nThe vector $\\mathbf{b}$ is:\n$$\n\\mathbf{b} = \\begin{pmatrix}\n30 \\\\\n24 \\\\\n22\n\\end{pmatrix}.\n$$\nThe problem requires computing the determinant of matrix $\\mathbf{M}$.\n$$\n\\det(\\mathbf{M}) = \\det\\begin{pmatrix}\n7 & 5 & 4 \\\\\n5 & 5 & 3 \\\\\n4 & 3 & 4\n\\end{pmatrix}\n$$\nUsing the cofactor expansion along the first row:\n$$\n\\det(\\mathbf{M}) = 7\\begin{vmatrix} 5 & 3 \\\\ 3 & 4 \\end{vmatrix} - 5\\begin{vmatrix} 5 & 3 \\\\ 4 & 4 \\end{vmatrix} + 4\\begin{vmatrix} 5 & 5 \\\\ 4 & 3 \\end{vmatrix}\n$$\n$$\n\\det(\\mathbf{M}) = 7(5 \\cdot 4 - 3 \\cdot 3) - 5(5 \\cdot 4 - 3 \\cdot 4) + 4(5 \\cdot 3 - 5 \\cdot 4)\n$$\n$$\n\\det(\\mathbf{M}) = 7(20 - 9) - 5(20 - 12) + 4(15 - 20)\n$$\n$$\n\\det(\\mathbf{M}) = 7(11) - 5(8) + 4(-5)\n$$\n$$\n\\det(\\mathbf{M}) = 77 - 40 - 20 = 17.\n$$\nThe determinant of the matrix is $17$.\n\nFinally, we discuss the conditions under which the matrix $\\mathbf{M}$ is invertible. The matrix $\\mathbf{M}$ is invertible if and only if its determinant is non-zero. $\\mathbf{M}$ can be written as $\\mathbf{M} = \\mathbf{P}^T\\mathbf{W}\\mathbf{P}$, where $\\mathbf{P}$ is the $N \\times 3$ matrix of basis functions evaluated at the sampling points, and $\\mathbf{W}$ is the $N \\times N$ diagonal matrix of weights.\n$$\n\\mathbf{P} = \\begin{pmatrix} 1 & x_1 & y_1 \\\\ 1 & x_2 & y_2 \\\\ \\vdots & \\vdots & \\vdots \\\\ 1 & x_N & y_N \\end{pmatrix}, \\quad \\mathbf{W} = \\text{diag}(w_1, w_2, \\dots, w_N).\n$$\n$\\mathbf{M}$ is a Gram matrix. It is singular if and only if the columns of the matrix $\\sqrt{\\mathbf{W}}\\mathbf{P}$ are linearly dependent. Assuming the weights $w_m$ are strictly positive for a subset of points, this is equivalent to the columns of $\\mathbf{P}$ (for that subset of points) being linearly dependent. The columns of $\\mathbf{P}$ are linearly dependent if there exists a non-zero vector $\\mathbf{c} = [c_1, c_2, c_3]^T$ such that $\\mathbf{P}\\mathbf{c} = \\mathbf{0}$. This corresponds to the condition\n$$\nc_1 \\cdot 1 + c_2 \\cdot x_m + c_3 \\cdot y_m = 0\n$$\nfor all points $(x_m, y_m)$ with corresponding weight $w_m > 0$. This is the equation of a line in the $(x,y)$-plane.\nTherefore, the matrix $\\mathbf{M}$ is singular if and only if all sampling points $(x_m, y_m)$ with $w_m > 0$ are collinear (lie on the same straight line). For $\\mathbf{M}$ to be invertible, we need at least $3$ sampling points with positive weights (since we are fitting $3$ parameters), and these points must not be collinear. In the given problem, the four points $(0,0), (1,0), (0,1), (1,1)$ all have positive weights and are clearly not collinear. Hence, the matrix $\\mathbf{M}$ is invertible, which is consistent with its non-zero determinant of $17$.",
            "answer": "$$\n\\boxed{17}\n$$"
        },
        {
            "introduction": "After computing a local error indicator $\\eta_K$ for every element in the mesh, the ultimate goal is to use this information to improve the solution. This hands-on coding exercise demonstrates the practical application of these indicators by implementing Dörfler's bulk marking strategy, a theoretically robust algorithm for selecting elements for refinement. This practice bridges the gap from theory to a functional component of an adaptive finite element solver, showing how error estimation drives computational efficiency and accuracy .",
            "id": "3593863",
            "problem": "Implement a complete program that performs Dörfler bulk marking for adaptive mesh refinement using recovery-based energy-norm element error indicators in two-dimensional linear elasticity. The program must compute recovery-based element indicators from a given triangulation and a prescribed continuous displacement field, and then select a minimal set of marked elements according to Dörfler’s criterion. Finally, aggregate and print the selected element indices for a provided test suite.\n\nStart from the standard setting of two-dimensional linear elasticity with small strains under plane stress conditions. Let the displacement field be a vector function $u : \\Omega \\subset \\mathbb{R}^2 \\to \\mathbb{R}^2$. The infinitesimal strain tensor is $\\varepsilon(u) = \\frac{1}{2}(\\nabla u + \\nabla u^\\top)$, and the stress is $\\sigma = \\mathbb{C}\\,\\varepsilon(u)$, where $\\mathbb{C}$ is the isotropic elasticity tensor with Young’s modulus $E$ and Poisson’s ratio $\\nu$ under plane stress. Consider a triangulation of $\\Omega$ into three-node linear triangles. On each element $K$, the standard finite element method (FEM) strain $\\varepsilon^h|_K$ is constant and obtained from the displacement values at the element nodes via the element strain-displacement matrix.\n\nUse a Zienkiewicz–Zhu (ZZ) recovery procedure to construct a recovered strain field $\\varepsilon^\\star$ on the mesh. In this problem, you must implement nodal recovery by area-weighted averaging of the constant element strains contributing to each node, and define the elementwise recovered strain $\\varepsilon^\\star|_K$ as the arithmetic average of the recovered strains at the three nodes of $K$.\n\nDefine the squared element energy-norm indicator for each element $K$ as\n$$\n\\eta_K^2 = \\int_{K} (\\varepsilon^\\star - \\varepsilon^h)^\\top \\, \\mathbb{C} \\, (\\varepsilon^\\star - \\varepsilon^h)\\, \\mathrm{d}\\Omega.\n$$\nIn this problem, approximate the integral by the element area times the energy density evaluated with the constant $\\varepsilon^h|_K$ and the elementwise $\\varepsilon^\\star|_K$:\n$$\n\\eta_K^2 \\approx |K|\\, (\\varepsilon^\\star|_K - \\varepsilon^h|_K)^\\top \\mathbb{C} \\, (\\varepsilon^\\star|_K - \\varepsilon^h|_K).\n$$\n\nImplement Dörfler bulk marking to select a minimal set of elements $\\mathcal{M}$ satisfying\n$$\n\\sum_{K \\in \\mathcal{M}} \\eta_K^2 \\;\\ge\\; \\theta \\sum_{K} \\eta_K^2,\n$$\nwith $0 < \\theta < 1$. Use the following deterministic minimality rule: sort the elements by descending $\\eta_K^2$ values and break ties by ascending element index; then include elements in that order until the inequality is satisfied. If $\\sum_K \\eta_K^2$ is numerically zero, treat it as zero using the floating-point tolerance $\\varepsilon = 10^{-12}$ and return the empty set (no elements marked).\n\nYou must compute all relevant quantities in the International System of Units. The elasticity tensor $\\mathbb{C}$ must be formed for plane stress from $E$ (in Pascals) and $\\nu$ (dimensionless). Areas must be in square meters. Although intermediate variables have units, the program’s final outputs are lists of element indices and therefore unitless.\n\nTest Suite Specification:\n- For each test case, the program receives a mesh and a displacement field specified by an analytic function evaluated at nodal coordinates, material parameters, and the marking parameter $\\theta$. Your program must compute $\\eta_K^2$ for all elements and then return the marked set indices as specified.\n\nUse the following three test cases:\n1. Happy path with zero error:\n   - Domain: the unit square with two triangles,\n     - Nodes (indexed from $0$): $(0,0)$, $(1,0)$, $(1,1)$, $(0,1)$.\n     - Elements: $K_0 = (0,1,2)$ and $K_1 = (0,2,3)$ (each triple is the list of node indices).\n   - Displacement field: $u_x(x,y) = 0.1\\,x + 0.0\\,y$, $u_y(x,y) = 0.0\\,x + 0.05\\,y$.\n   - Material: $E = 2.10\\times 10^{11}$ Pa, $\\nu = 0.3$.\n   - Marking parameter: $\\theta = 0.6$.\n   - Expected behavior: exact linear field yields $\\eta_K^2 \\approx 0$; by the tolerance rule, the marked set is the empty list.\n\n2. Nontrivial quadratic field on a refined mesh:\n   - Domain: the unit square partitioned into a uniform $2\\times 2$ grid with triangles,\n     - Nodes (indexed from $0$): $(0,0)$, $(0.5,0)$, $(1,0)$, $(0,0.5)$, $(0.5,0.5)$, $(1,0.5)$, $(0,1)$, $(0.5,1)$, $(1,1)$.\n     - Elements: lower-left cell split by the diagonal from its bottom-left to top-right corner, consistently across the grid. Specifically, the triangles are $K_0=(0,1,4)$, $K_1=(0,4,3)$, $K_2=(1,2,5)$, $K_3=(1,5,4)$, $K_4=(3,4,7)$, $K_5=(3,7,6)$, $K_6=(4,5,8)$, $K_7=(4,8,7)$.\n   - Displacement field: $u_x(x,y) = 0.02\\,x^2$, $u_y(x,y) = 0.03\\,y^2$.\n   - Material: $E = 2.10\\times 10^{11}$ Pa, $\\nu = 0.3$.\n   - Marking parameter: $\\theta = 0.5$.\n   - Expected behavior: nonzero indicators; Dörfler marking selects a minimal set of elements capturing at least half of the total squared indicator sum.\n\n3. Boundary regime with large bulk parameter:\n   - Same mesh and material as Test Case 2.\n   - Displacement field: $u_x(x,y) = 0.02\\,x^2$, $u_y(x,y) = 0.03\\,y^2$.\n   - Marking parameter: $\\theta = 0.95$.\n   - Expected behavior: near-total marking; the set contains most elements.\n\nFinal Output Format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each entry corresponds to one test case and is itself a list of marked element indices in ascending order of marking inclusion. For example, the output must look like\n$[\\,[i_{0,1},i_{0,2},\\dots],\\,[i_{1,1},\\dots],\\,[i_{2,1},\\dots]\\,]$,\nwhere $i_{t,k}$ are integers. Use zero-based element indices.\n\nYou must also explain, in your accompanying solution, the derivation of the energy-norm indicator from linear elasticity and strain recovery, the algorithmic structure of Dörfler marking, and provide a principled justification for typical choices of the bulk parameter $\\theta$ used in practice.",
            "solution": "The problem requires the implementation of a recovery-based error indicator and the Dörfler bulk marking strategy for adaptive mesh refinement in two-dimensional linear elasticity. The solution is presented in three parts: a theoretical exposition of the error estimation and marking procedures, a description of the algorithmic steps, and the final implementation details.\n\n### Principle-Based Design\n\n#### 1. Energy Norm Error Estimation in Linear Elasticity\n\nIn the finite element method (FEM) for linear elasticity, the primary goal is to find an approximate displacement field $u^h$ to the true (but unknown) displacement field $u$. The quality of the approximation is often measured by the error $e = u - u^h$ in the energy norm. The squared energy norm of the error is defined as:\n$$\n\\|e\\|_E^2 = \\int_{\\Omega} (\\varepsilon(u) - \\varepsilon(u^h))^\\top \\, \\mathbb{C} \\, (\\varepsilon(u) - \\varepsilon(u^h)) \\, \\mathrm{d}\\Omega\n$$\nwhere $\\varepsilon(u)$ is the strain tensor derived from a displacement field $u$, and $\\mathbb{C}$ is the constitutive (elasticity) tensor. This integral represents the strain energy of the error field. In a real-world scenario, the exact solution $u$ is not available, making direct computation of $\\|e\\|_E^2$ impossible.\n\nA-posteriori error estimation aims to approximate this error using only the computed FEM solution $u^h$ and the problem data. The global error is expressed as a sum of local contributions from each element $K$ in the mesh triangulation $\\mathcal{T}$:\n$$\n\\|e\\|_E^2 = \\sum_{K \\in \\mathcal{T}} \\int_{K} (\\varepsilon(u) - \\varepsilon(u^h))^\\top \\, \\mathbb{C} \\, (\\varepsilon(u) - \\varepsilon(u^h)) \\, \\mathrm{d}K = \\sum_{K \\in \\mathcal{T}} \\eta_K^2\n$$\nHere, $\\eta_K$ is the local error indicator for element $K$. The key to a-posteriori estimation is to find a computable approximation for $\\eta_K$.\n\n#### 2. Zienkiewicz-Zhu (ZZ) Recovery and Error Indication\n\nThe Zienkiewicz-Zhu (ZZ) recovery method is a widely used technique for error estimation. It is based on the observation that while the FEM displacement solution $u^h$ is continuous across element boundaries, its derivative, the FEM strain $\\varepsilon^h$, is typically discontinuous and less accurate. The core idea is to \"recover\" a more accurate, continuous strain field, denoted $\\varepsilon^\\star$, by post-processing the discontinuous field $\\varepsilon^h$.\n\nThe fundamental assumption of ZZ-type estimators is that the recovered strain $\\varepsilon^\\star$ is a significantly better approximation of the true strain $\\varepsilon(u)$ than the raw FEM strain $\\varepsilon^h$ is. This allows us to approximate the strain error as:\n$$\n\\varepsilon(u) - \\varepsilon(u^h) \\approx \\varepsilon^\\star - \\varepsilon^h\n$$\nSubstituting this approximation into the definition of the element error indicator gives the computable ZZ error indicator:\n$$\n\\eta_K^2 = \\int_{K} (\\varepsilon^\\star - \\varepsilon^h)^\\top \\, \\mathbb{C} \\, (\\varepsilon^\\star - \\varepsilon^h) \\, \\mathrm{d}K\n$$\nThe problem specifies a particular procedure for constructing $\\varepsilon^\\star$:\n1.  **Nodal Strain Recovery**: For each node in the mesh, the recovered strain $\\varepsilon^\\star_{node}$ is computed as the area-weighted average of the constant FEM strains $\\varepsilon^h$ from all elements sharing that node.\n2.  **Element Recovered Strain**: For each element $K$, a constant recovered strain $\\varepsilon^\\star|_K$ is computed as the arithmetic mean of the recovered strains at its three vertices.\n3.  **Indicator Approximation**: The integral for $\\eta_K^2$ is approximated by assuming the integrand is constant over the element, using the element-wise constant strains $\\varepsilon^h|_K$ and $\\varepsilon^\\star|_K$. This leads to the algebraic expression:\n    $$\n    \\eta_K^2 \\approx |K|\\, (\\varepsilon^\\star|_K - \\varepsilon^h|_K)^\\top \\mathbb{C} \\, (\\varepsilon^\\star|_K - \\varepsilon^h|_K)\n    $$\n    where $|K|$ is the area of element $K$.\n\n#### 3. Dörfler Bulk Marking\n\nOnce the error indicators $\\eta_K^2$ are computed for all elements, adaptive mesh refinement (AMR) proceeds by refining only those elements that contribute most significantly to the total error. Dörfler marking provides a robust strategy for selecting this set of elements.\n\nGiven a bulk parameter $0 < \\theta < 1$, Dörfler's criterion requires selecting a minimal set of elements $\\mathcal{M}$ for refinement such that the sum of their error indicators accounts for at least a fraction $\\theta$ of the total estimated error:\n$$\n\\sum_{K \\in \\mathcal{M}} \\eta_K^2 \\ge \\theta \\sum_{K \\in \\mathcal{T}} \\eta_K^2\n$$\nThe minimality condition is satisfied by the following deterministic algorithm:\n1.  Compute the squared indicator $\\eta_K^2$ for every element $K$ in the mesh $\\mathcal{T}$.\n2.  Calculate the total estimated squared error $\\eta_{total}^2 = \\sum_{K \\in \\mathcal{T}} \\eta_K^2$.\n3.  Sort the elements in descending order based on their $\\eta_K^2$ values. To ensure determinism, any ties are broken by sorting elements with equal indicators by their original index in ascending order.\n4.  Iterate through the sorted list of elements, accumulating their $\\eta_K^2$ values into a running sum. Add each element to the marked set $\\mathcal{M}$.\n5.  Stop when the accumulated sum first reaches or exceeds the target value $\\theta \\cdot \\eta_{total}^2$.\n\nThe resulting set $\\mathcal{M}$ contains the elements with the largest estimated errors, which are the prime candidates for subdivision to improve the overall accuracy of the next FEM solution.\n\nThe parameter $\\theta$ controls the aggressiveness of the refinement. A small $\\theta$ (e.g., $0.2-0.4$) targets only the elements with the most dominant errors, which is effective for problems with sharp singularities. A large $\\theta$ (e.g., $0.7-0.9$) leads to a larger marked set, approaching uniform refinement, which can be suitable when the error is more evenly distributed. A common, balanced choice in practice is $\\theta \\approx 0.5$.\n\n### Algorithmic Implementation\n\nThe program will execute the following sequence of operations for each test case:\n1.  **Initialization**: Define the mesh (nodal coordinates and element connectivity), material properties ($E, \\nu$), and the marking parameter $\\theta$. The plane stress elasticity matrix $\\mathbb{C}$ is constructed using $E$ and $\\nu$.\n2.  **Compute FEM Strain $\\varepsilon^h$**: For each element, calculate the strain-displacement matrix $B_K$ and area $|K|$. From the given analytic displacement function, evaluate nodal displacements $d_K$. Compute the constant element strain $\\varepsilon^h_K = B_K d_K$.\n3.  **Compute Recovered Nodal Strain $\\varepsilon^\\star_{node}$**: For each node, sum the products of strain and area $(\\varepsilon^h_K \\cdot |K|)$ from all adjacent elements and divide by the sum of their areas.\n4.  **Compute Recovered Element Strain $\\varepsilon^\\star_K$**: For each element, average the recovered strains of its three nodes.\n5.  **Calculate Error Indicators**: For each element, compute the strain error difference $\\Delta\\varepsilon_K = \\varepsilon^\\star_K - \\varepsilon^h_K$ and then the squared indicator $\\eta_K^2 = |K|\\, (\\Delta\\varepsilon_K^\\top \\mathbb{C} \\Delta\\varepsilon_K)$.\n6.  **Perform Dörfler Marking**: Sum all indicators to get $\\eta_{total}^2$. If this sum is below a tolerance ($10^{-12}$), return an empty set. Otherwise, sort indicators in descending order (with tie-breaking) and select elements until their cumulative sum reaches $\\theta \\cdot \\eta_{total}^2$. The indices of the selected elements are collected in the order of their inclusion.\n7.  **Final Output**: The lists of marked indices for all test cases are formatted into a single string as specified.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n\n    class TestCaseSolver:\n        \"\"\"\n        Encapsulates the logic for solving one test case of Dörfler marking.\n        \"\"\"\n        def __init__(self, nodes, elements, E, nu, theta, u_func):\n            self.nodes = np.array(nodes, dtype=float)\n            self.elements = np.array(elements, dtype=int)\n            self.E = float(E)\n            self.nu = float(nu)\n            self.theta = float(theta)\n            self.u_func = u_func\n            self.num_nodes = self.nodes.shape[0]\n            self.num_elements = self.elements.shape[0]\n\n            # Plane stress elasticity matrix C for [exx, eyy, gxy]\n            c1 = self.E / (1 - self.nu**2)\n            c2 = self.E * self.nu / (1 - self.nu**2)\n            c3 = self.E / (2 * (1 + self.nu))  # Shear modulus G\n            self.C = np.array([[c1, c2, 0],\n                               [c2, c1, 0],\n                               [0,  0, c3]], dtype=float)\n\n        def _compute_fem_strains(self):\n            \"\"\"\n            Computes the constant FEM strain for each element.\n            \"\"\"\n            self.elem_strains_h = np.zeros((self.num_elements, 3))\n            self.elem_areas = np.zeros(self.num_elements)\n\n            for i, elem_nodes_indices in enumerate(self.elements):\n                node_coords = self.nodes[elem_nodes_indices]\n                \n                # Nodal coordinates\n                x1, y1 = node_coords[0]\n                x2, y2 = node_coords[1]\n                x3, y3 = node_coords[2]\n\n                # Element area\n                area = 0.5 * np.abs(x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2))\n                self.elem_areas[i] = area\n\n                if area  1e-15:  # Degenerate element\n                    continue\n                \n                # B matrix components\n                b1, b2, b3 = y2 - y3, y3 - y1, y1 - y2\n                c1, c2, c3 = x3 - x2, x1 - x3, x2 - x1\n\n                # Strain-displacement matrix B\n                B = (1 / (2 * area)) * np.array([\n                    [b1, 0,  b2, 0,  b3, 0 ],\n                    [0,  c1, 0,  c2, 0,  c3],\n                    [c1, b1, c2, b2, c3, b3]\n                ])\n\n                # Nodal displacement vector d\n                d = np.zeros(6)\n                for j, node_idx in enumerate(elem_nodes_indices):\n                    pos = self.nodes[node_idx]\n                    ux, uy = self.u_func(pos[0], pos[1])\n                    d[2*j] = ux\n                    d[2*j + 1] = uy\n                \n                # Element strain epsilon_h = B * d\n                self.elem_strains_h[i] = B @ d\n\n        def _compute_recovered_strains(self):\n            \"\"\"\n            Computes the recovered strain field epsilon_star.\n            \"\"\"\n            # 1. Nodal recovery by area-weighted averaging\n            nodal_strains_star_num = np.zeros((self.num_nodes, 3))\n            nodal_areas_sum = np.zeros(self.num_nodes)\n\n            for i, elem_nodes_indices in enumerate(self.elements):\n                area = self.elem_areas[i]\n                strain_h = self.elem_strains_h[i]\n                for node_idx in elem_nodes_indices:\n                    nodal_strains_star_num[node_idx] += strain_h * area\n                    nodal_areas_sum[node_idx] += area\n\n            # Avoid division by zero for nodes not in any element\n            valid_nodes = nodal_areas_sum > 1e-15\n            self.nodal_strains_star = np.zeros((self.num_nodes, 3))\n            self.nodal_strains_star[valid_nodes] = \\\n                nodal_strains_star_num[valid_nodes] / nodal_areas_sum[valid_nodes, np.newaxis]\n\n            # 2. Element-wise recovered strain by averaging nodal values\n            self.elem_strains_star = np.zeros((self.num_elements, 3))\n            for i, elem_nodes_indices in enumerate(self.elements):\n                self.elem_strains_star[i] = np.mean(self.nodal_strains_star[elem_nodes_indices], axis=0)\n        \n        def _compute_indicators(self):\n            \"\"\"\n            Computes the squared energy-norm indicator for each element.\n            \"\"\"\n            self.indicators_sq = np.zeros(self.num_elements)\n            strain_diff = self.elem_strains_star - self.elem_strains_h\n            \n            for i in range(self.num_elements):\n                delta_eps = strain_diff[i]\n                # indicator^2 = area * (delta_eps^T * C * delta_eps)\n                energy_density = delta_eps.T @ self.C @ delta_eps\n                self.indicators_sq[i] = self.elem_areas[i] * energy_density\n\n        def _perform_doerfler_marking(self):\n            \"\"\"\n            Performs Dörfler bulk marking to select elements for refinement.\n            \"\"\"\n            total_indicator_sq_sum = np.sum(self.indicators_sq)\n\n            # Handle zero-error case\n            if total_indicator_sq_sum  1e-12:\n                return []\n\n            target_sum = self.theta * total_indicator_sq_sum\n\n            # Create tuples of (-indicator, index) for sorting\n            # Sort by descending indicator, then ascending index for tie-breaking\n            indexed_indicators = [(-self.indicators_sq[i], i) for i in range(self.num_elements)]\n            indexed_indicators.sort()\n\n            marked_indices = []\n            current_sum = 0.0\n            for neg_indicator, index in indexed_indicators:\n                if current_sum >= target_sum:\n                    break\n                current_sum += -neg_indicator\n                marked_indices.append(index)\n            \n            return marked_indices\n\n        def run(self):\n            \"\"\"\n            Runs the full analysis for the test case.\n            \"\"\"\n            self._compute_fem_strains()\n            self._compute_recovered_strains()\n            self._compute_indicators()\n            marked_set = self._perform_doerfler_marking()\n            return marked_set\n\n    # Test Suite Specification\n    test_cases = [\n        # Case 1: Happy path with zero error\n        {\n            \"nodes\": [(0,0), (1,0), (1,1), (0,1)],\n            \"elements\": [(0,1,2), (0,2,3)],\n            \"E\": 2.10e11, \"nu\": 0.3, \"theta\": 0.6,\n            \"u_func\": lambda x, y: (0.1*x, 0.05*y)\n        },\n        # Case 2: Nontrivial quadratic field on a refined mesh\n        {\n            \"nodes\": [(0,0), (0.5,0), (1,0), (0,0.5), (0.5,0.5), (1,0.5), (0,1), (0.5,1), (1,1)],\n            \"elements\": [(0,1,4), (0,4,3), (1,2,5), (1,5,4), (3,4,7), (3,7,6), (4,5,8), (4,8,7)],\n            \"E\": 2.10e11, \"nu\": 0.3, \"theta\": 0.5,\n            \"u_func\": lambda x, y: (0.02*x**2, 0.03*y**2)\n        },\n        # Case 3: Boundary regime with large bulk parameter\n        {\n            \"nodes\": [(0,0), (0.5,0), (1,0), (0,0.5), (0.5,0.5), (1,0.5), (0,1), (0.5,1), (1,1)],\n            \"elements\": [(0,1,4), (0,4,3), (1,2,5), (1,5,4), (3,4,7), (3,7,6), (4,5,8), (4,8,7)],\n            \"E\": 2.10e11, \"nu\": 0.3, \"theta\": 0.95,\n            \"u_func\": lambda x, y: (0.02*x**2, 0.03*y**2)\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        solver = TestCaseSolver(\n            nodes=case[\"nodes\"],\n            elements=case[\"elements\"],\n            E=case[\"E\"],\n            nu=case[\"nu\"],\n            theta=case[\"theta\"],\n            u_func=case[\"u_func\"]\n        )\n        result = solver.run()\n        all_results.append(result)\n\n    # Final print statement in the specified format without spaces.\n    inner_results = []\n    for res_list in all_results:\n        inner_str = f\"[{','.join(map(str, res_list))}]\"\n        inner_results.append(inner_str)\n    \n    print(f\"[{','.join(inner_results)}]\")\n\nsolve()\n```"
        }
    ]
}