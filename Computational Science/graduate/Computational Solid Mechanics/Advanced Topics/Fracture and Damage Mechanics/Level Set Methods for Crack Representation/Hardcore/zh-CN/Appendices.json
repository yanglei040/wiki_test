{
    "hands_on_practices": [
        {
            "introduction": "在任何模拟开始之前，我们必须将裂纹的几何表示（例如一系列相连的线段）转换为隐式的水平集表示。这个练习将重点实现计算符号距离函数 $\\phi$ 和辅助的裂尖距离函数 $\\psi$ 的基本算法。这两个函数是扩展水平集方法（X-LSM）的基石，为后续的裂纹扩展分析提供了必要的信息场。",
            "id": "3577077",
            "problem": "给定平面上的一组相连线段，它们定义了一条作为多段线的有向裂纹。该多段线由有序顶点 $\\{\\mathbf{x}_0,\\mathbf{x}_1,\\ldots,\\mathbf{x}_{N-1}\\}$ 指定，其中 $\\mathbf{x}_i \\in \\mathbb{R}^2$。最后一个顶点 $\\mathbf{x}_{N-1}$ 是裂纹尖端。您的任务是为一组查询点 $\\{\\mathbf{p}_k\\}$ 构建两个标量场：\n\n1. 一个到代表裂纹表面的多段线的有符号距离函数 (SDF) $\\phi(\\mathbf{p})$。\n2. 一个弧长函数 $\\psi(\\mathbf{p})$，它返回从裂纹尖端沿多段线到多段线上最近点的累积距离。\n\n您的推导和算法应基于以下基本定义和几何事实：\n\n- 对于从 $\\mathbf{x}_i$ 到 $\\mathbf{x}_{i+1}$ 的每条线段 $i$，定义线段向量 $\\mathbf{v}_i = \\mathbf{x}_{i+1} - \\mathbf{x}_i$，线段长度 $L_i = \\|\\mathbf{v}_i\\|_2$，单位切向量 $\\mathbf{t}_i = \\mathbf{v}_i / L_i$，以及通过将 $\\mathbf{t}_i$ 旋转 $+90^\\circ$ 得到的单位法向量 $\\mathbf{n}_i$，即 $\\mathbf{n}_i = R_{90}\\,\\mathbf{t}_i$，其中 $R_{90} = \\begin{pmatrix}0  -1 \\\\ 1  0\\end{pmatrix}$。此约定使得 $\\mathbf{n}_i$ 指向有向线段的“左侧”。\n- 从点 $\\mathbf{p}$ 到线段 $i$ 的无符号欧几里得距离由 $\\|\\mathbf{p} - (\\mathbf{x}_i + s\\,\\mathbf{v}_i)\\|_2$（其中 $s \\in [0,1]$）在线段上的最小值给出。令 $s_i^\\ast = \\mathrm{clamp}\\left(\\frac{(\\mathbf{p}-\\mathbf{x}_i)\\cdot \\mathbf{v}_i}{\\mathbf{v}_i \\cdot \\mathbf{v}_i},\\,0,\\,1\\right)$ 为截断的投影参数，$\\mathbf{q}_i^\\ast = \\mathbf{x}_i + s_i^\\ast \\mathbf{v}_i$ 为线段 $i$ 上离 $\\mathbf{p}$ 最近的点。\n- 到线段 $i$ 的有符号距离是通过将无符号距离乘以一个基于有向法线的侧面指示符得到的，$\\mathrm{sign}_i(\\mathbf{p}) = \\begin{cases}+1  \\text{如果 } \\mathbf{n}_i \\cdot (\\mathbf{p} - \\mathbf{q}_i^\\ast) \\ge 0\\\\-1  \\text{否则}\\end{cases}$。因此，来自线段 $i$ 的有符号距离候选值为 $\\phi_i(\\mathbf{p}) = \\mathrm{sign}_i(\\mathbf{p})\\,\\|\\mathbf{p}-\\mathbf{q}_i^\\ast\\|_2$。\n- 多段线有符号距离 $\\phi(\\mathbf{p})$ 的定义是：选择使无符号距离 $\\|\\mathbf{p}-\\mathbf{q}_{i}^\\ast\\|_2$ 最小化的线段索引 $i^\\ast$，并设 $\\phi(\\mathbf{p}) = \\phi_{i^\\ast}(\\mathbf{p})$。\n- 从尖端到任意顶点 $j$ 的弧长定义为 $$s(\\mathbf{x}_{N-1}) = 0,\\quad s(\\mathbf{x}_{j}) = \\sum_{m=j}^{N-2} L_m \\quad \\text{对于 } j=0,1,\\ldots,N-2.$$ 对于一个点 $\\mathbf{p}$，其最近点位于参数为 $s_i^\\ast$ 的线段 $i$ 上，弧长场为 $$\\psi(\\mathbf{p}) = s(\\mathbf{x}_{i+1}) + (1 - s_i^\\ast)\\,L_i,$$ 它测量了从尖端 $\\mathbf{x}_{N-1}$ 沿多段线到最近点的累积距离。距离应以米为单位表示。\n\n假设和约定：\n\n- 所有坐标 $\\mathbf{x}_i$ 和 $\\mathbf{p}_k$ 都以米为单位。您的输出 $\\phi$ 和 $\\psi$ 也必须以米为单位。\n- 多段线是非退化的：每条线段的长度都严格为正。\n- $\\phi$ 的符号约定如上所述使用有向法线 $\\mathbf{n}_i$；如果 $\\mathbf{p}$ 位于最近点处局部有向线段的“左侧”，则 $\\phi(\\mathbf{p})  0$，如果位于“右侧”，则 $\\phi(\\mathbf{p})  0$。如果 $\\mathbf{p}-\\mathbf{q}_i^\\ast$ 与 $\\mathbf{n}_i$ 正交，则在侧面指示符中使用非负分支，即点积为零时 $\\mathrm{sign}_i(\\mathbf{p}) = +1$。\n\n任务：\n\n- 实现一个程序，对于下面的每个测试用例，使用上述定义为提供的查询点计算 $\\phi$ 和 $\\psi$ 值的列表。\n\n测试套件：\n\n- 测试用例 1：\n  - 多段线顶点： $\\{(0.0, 0.0),\\,(2.0, 0.0)\\}$，尖端位于 $(2.0,0.0)$。\n  - 查询点： $\\{(1.0, 0.5),\\,(1.0,-0.5),\\,(2.5, 0.0),\\,(0.0,-0.5)\\}$。\n- 测试用例 2：\n  - 多段线顶点： $\\{(0.0,0.0),\\,(1.0,0.0),\\,(1.0,1.0)\\}$，尖端位于 $(1.0,1.0)$。\n  - 查询点： $\\{(0.25,0.20),\\,(0.80,0.75),\\,(0.50,-0.30),\\,(-0.20,0.00)\\}$。\n- 测试用例 3：\n  - 多段线顶点： $\\{(0.0,0.0),\\,(2.0,1.0),\\,(3.0,3.0),\\,(5.0,2.0)\\}$，尖端位于 $(5.0,2.0)$。\n  - 查询点： $\\{(2.5,2.0),\\,(3.5,2.1),\\,(4.5,2.2),\\,(0.0,0.0)\\}$。\n\n最终输出格式：\n\n- 您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。\n- 对于每个测试用例，首先按给定顺序输出查询点的 $\\phi$ 值序列，然后是相同点的 $\\psi$ 值序列，两个值都以米为单位。\n- 按顺序连接三个测试用例的输出。例如，最终输出应采用以下形式\n  $$[\\phi_{1,1},\\ldots,\\phi_{1,M_1},\\psi_{1,1},\\ldots,\\psi_{1,M_1},\\phi_{2,1},\\ldots,\\psi_{3,M_3}]$$\n  其中 $M_i$ 是测试用例 $i$ 中的查询点数量。",
            "solution": "该问题陈述是计算几何学中一个有效的、适定的问题，与使用水平集方法表示裂纹的计算固体力学领域直接相关。所有定义、数据和约束在科学上都是合理、一致和完整的。该问题要求实现一种算法，为给定的多段线裂纹和一组查询点计算两个标量场：有符号距离函数 $\\phi$ 和弧长函数 $\\psi$。\n\n### 算法方法\n\n问题的核心是为每个查询点 $\\mathbf{p}$ 找到多段线裂纹上的最近点。多段线是线段的集合。多段线上的最近点是在所有单个线段上的最近点中，使欧几里得距离最小化的那一个。一旦确定了这个全局最近点及其对应的线段，就可以根据提供的定义计算场 $\\phi(\\mathbf{p})$ 和 $\\psi(\\mathbf{p})$。\n\n总体算法如下：\n1.  对于每个测试用例，获取多段线顶点 $\\{\\mathbf{x}_0, \\ldots, \\mathbf{x}_{N-1}\\}$ 和查询点 $\\{\\mathbf{p}_k\\}$。\n2.  **预计算阶段**：对于给定的多段线，为连接 $\\mathbf{x}_i$ 到 $\\mathbf{x}_{i+1}$ 的每条线段 $i \\in \\{0, \\ldots, N-2\\}$ 预计算以下属性：\n    -   线段向量 $\\mathbf{v}_i = \\mathbf{x}_{i+1} - \\mathbf{x}_i$。\n    -   线段长度 $L_i = \\|\\mathbf{v}_i\\|_2$ 及其平方 $L_i^2 = \\mathbf{v}_i \\cdot \\mathbf{v}_i$。\n    -   单位切向量 $\\mathbf{t}_i = \\mathbf{v}_i / L_i$。\n    -   单位法向量 $\\mathbf{n}_i = R_{90}\\,\\mathbf{t}_i$，其中 $R_{90}$ 是 $+90^\\circ$ 旋转矩阵。如果 $\\mathbf{t}_i = (t_x, t_y)$，则 $\\mathbf{n}_i = (-t_y, t_x)$。\n    -   从裂纹尖端 $\\mathbf{x}_{N-1}$ 到每个顶点 $\\mathbf{x}_j$ 的弧长 $s(\\mathbf{x}_j)$。这些值从尖端开始向后迭代计算：$s(\\mathbf{x}_{N-1}) = 0$，对于 $j = N-2, \\ldots, 0$，$s(\\mathbf{x}_j) = s(\\mathbf{x}_{j+1}) + L_j$。\n3.  **查询阶段**：对于每个查询点 $\\mathbf{p}$：\n    a. 将最小平方距离初始化为无穷大。\n    b. 遍历多段线的每条线段 $i$。\n        i.  计算参数 $s_i$，该参数确定了包含线段 $i$ 的无限直线上的最近点。这通过将向量 $\\mathbf{p}-\\mathbf{x}_i$ 投影到线段向量 $\\mathbf{v}_i$ 上来完成：\n            $$s_i = \\frac{(\\mathbf{p}-\\mathbf{x}_i)\\cdot \\mathbf{v}_i}{\\mathbf{v}_i \\cdot \\mathbf{v}_i}$$\n        ii. 通过将 $s_i$ 截断到区间 $[0, 1]$ 来找到线段上最近点的参数：\n            $$s_i^\\ast = \\mathrm{clamp}(s_i, 0, 1)$$\n        iii. 那么线段 $i$ 上的最近点是 $\\mathbf{q}_i^\\ast = \\mathbf{x}_i + s_i^\\ast \\mathbf{v}_i$。\n        iv. 计算平方距离 $d_i^2 = \\|\\mathbf{p}-\\mathbf{q}_i^\\ast\\|_2^2$。\n        v. 如果 $d_i^2$ 小于当前的最小平方距离，则更新最小值并存储线段索引 $i^\\ast$、参数 $s_{i^\\ast}^\\ast$ 和最近点 $\\mathbf{q}_{i^\\ast}^\\ast$。\n    c. 检查完所有线段后，我们将确定全局最近的线段 $i^\\ast$、多段线上的最近点 $\\mathbf{q}^\\ast = \\mathbf{q}_{i^\\ast}^\\ast$、最小距离 $d_{\\min} = \\sqrt{\\|\\mathbf{p}-\\mathbf{q}^\\ast\\|_2^2}$ 以及对应的投影参数 $s_{i^\\ast}^\\ast$。\n4.  **场计算**：\n    a. **有符号距离函数 $\\phi(\\mathbf{p})$**：符号由向量 $\\mathbf{p} - \\mathbf{q}^\\ast$ 相对于最近线段法线 $\\mathbf{n}_{i^\\ast}$ 的方向确定。\n        $$\\mathrm{sign} = \\begin{cases}+1  \\text{如果 } \\mathbf{n}_{i^\\ast} \\cdot (\\mathbf{p} - \\mathbf{q}^\\ast) \\ge 0\\\\-1  \\text{否则}\\end{cases}$$\n        有符号距离为 $\\phi(\\mathbf{p}) = \\mathrm{sign} \\times d_{\\min}$。如果 $d_{\\min}=0$，则 $\\phi(\\mathbf{p})=0$。\n    b. **弧长函数 $\\psi(\\mathbf{p})$**：该函数测量从裂纹尖端 $\\mathbf{x}_{N-1}$ 沿多段线到最近点 $\\mathbf{q}^\\ast$ 的距离。它使用预先计算的到各顶点的弧长和在最近线段上的局部位置进行计算：\n        $$\\psi(\\mathbf{p}) = s(\\mathbf{x}_{i^\\ast+1}) + (1 - s_{i^\\ast}^\\ast) L_{i^\\ast}$$\n        此处，$s(\\mathbf{x}_{i^\\ast+1})$ 是从尖端到最近线段末端顶点的距离。项 $(1 - s_{i^\\ast}^\\ast) L_{i^\\ast}$ 是从最近点 $\\mathbf{q}^\\ast$ 沿该线段到此末端顶点的距离。\n\n这个有原则的、分步的过程提供了一种计算所需场的稳健方法，能正确处理所有几何情况，包括点最接近线段内部和顶点的情况。实现将使用 `numpy` 进行高效和精确的向量运算。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of computing signed distance and arc-length fields\n    for a polyline crack representation.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1\n        {\n            \"vertices\": [[0.0, 0.0], [2.0, 0.0]],\n            \"query_points\": [[1.0, 0.5], [1.0, -0.5], [2.5, 0.0], [0.0, -0.5]]\n        },\n        # Test case 2\n        {\n            \"vertices\": [[0.0, 0.0], [1.0, 0.0], [1.0, 1.0]],\n            \"query_points\": [[0.25, 0.20], [0.80, 0.75], [0.50, -0.30], [-0.20, 0.00]]\n        },\n        # Test case 3\n        {\n            \"vertices\": [[0.0, 0.0], [2.0, 1.0], [3.0, 3.0], [5.0, 2.0]],\n            \"query_points\": [[2.5, 2.0], [3.5, 2.1], [4.5, 2.2], [0.0, 0.0]]\n        }\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        vertices = np.array(case[\"vertices\"], dtype=float)\n        query_points = np.array(case[\"query_points\"], dtype=float)\n\n        N = vertices.shape[0]\n        num_segments = N - 1\n\n        # === Pre-computation Phase ===\n        \n        # Segment properties\n        segment_starts = vertices[:-1]\n        segment_ends = vertices[1:]\n        segment_vectors = segment_ends - segment_starts\n        segment_lengths_sq = np.sum(segment_vectors**2, axis=1)\n        segment_lengths = np.sqrt(segment_lengths_sq)\n        \n        # Unit tangents and normals. Add small epsilon to avoid division by zero\n        # although problem guarantees non-degenerate segments.\n        unit_tangents = segment_vectors / (segment_lengths[:, np.newaxis] + 1e-12)\n        unit_normals = np.array([-unit_tangents[:, 1], unit_tangents[:, 0]]).T\n\n        # Arc-lengths from the tip (last vertex) to each vertex\n        arc_lengths_at_vertices = np.zeros(N)\n        for j in range(N - 2, -1, -1):\n            arc_lengths_at_vertices[j] = arc_lengths_at_vertices[j+1] + segment_lengths[j]\n\n        phi_values = []\n        psi_values = []\n\n        # === Query Phase ===\n        for p in query_points:\n            min_dist_sq = np.inf\n            closest_segment_idx = -1\n            optimal_s_star = -1.0\n            closest_point_on_polyline = None\n\n            for i in range(num_segments):\n                # Vector from segment start to query point\n                w = p - segment_starts[i]\n                \n                # Projection parameter (unclamped)\n                s = np.dot(w, segment_vectors[i]) / (segment_lengths_sq[i] + 1e-12)\n                \n                # Clamped parameter\n                s_star = np.clip(s, 0.0, 1.0)\n                \n                # Closest point on the current segment\n                q_star = segment_starts[i] + s_star * segment_vectors[i]\n                \n                dist_sq = np.sum((p - q_star)**2)\n\n                if dist_sq  min_dist_sq:\n                    min_dist_sq = dist_sq\n                    closest_segment_idx = i\n                    optimal_s_star = s_star\n                    closest_point_on_polyline = q_star\n\n            # === Field Computation ===\n            \n            # 1. Signed Distance Function (SDF) phi\n            dist = np.sqrt(min_dist_sq)\n            if np.isclose(dist, 0.0):\n                phi = 0.0\n            else:\n                vec_p_q = p - closest_point_on_polyline\n                dot_product = np.dot(unit_normals[closest_segment_idx], vec_p_q)\n                sign = 1.0 if dot_product >= 0 else -1.0\n                phi = sign * dist\n            phi_values.append(phi)\n            \n            # 2. Arc-Length Function psi\n            psi = arc_lengths_at_vertices[closest_segment_idx + 1] + \\\n                  (1 - optimal_s_star) * segment_lengths[closest_segment_idx]\n            psi_values.append(psi)\n\n        all_results.extend(phi_values)\n        all_results.extend(psi_values)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在整个计算域上求解水平集函数的演化是非常耗费计算资源的。本练习将介绍窄带技术，这是一种关键的优化方法，它将计算限制在裂纹周围的一个小区域内。你将实现这种方法，并分析计算成本与求解精度之间的权衡关系，这是实际工程模拟中的一个核心考量。",
            "id": "3577131",
            "problem": "考虑一个二维计算域，代表一个带有直裂纹的薄板，其中裂纹由标量场 $\\phi(x,y,t)$ 的零水平集隐式表示，而 $\\phi$ 的符号区分裂纹的两个侧面。假设初始条件为 $\\phi(x,y,0)=x$，这是到平面 $x=0$ 的有符号距离，其零水平集对应于直裂纹线。该水平集由线性平流方程演化\n$$\n\\frac{\\partial \\phi}{\\partial t} + \\mathbf{v}\\cdot\\nabla \\phi = 0,\n$$\n其中 $\\mathbf{v}=(v_x,v_y)$ 是驱动裂纹前缘的恒定速度场。对于所选的初始条件和恒定速度，其精确解为\n$$\n\\phi_{\\text{exact}}(x,y,t)=x - v_x t,\n$$\n对于任何 $y$ 均成立，因为 $\\nabla \\phi(0)=(1,0)$ 且平流是均匀的。\n\n您的任务是实现一个窄带水平集更新方法，在每个时间步将计算限制在满足 $|\\phi|\\le \\delta$ 的网格单元内，其中 $\\delta0$ 是给定的带半宽。在窄带之外，$\\phi$ 必须保持不变。对平流方程在空间上使用一阶显式迎风有限差分格式，在时间上使用前向欧拉法。具体来说，对于每个索引为 $(i,j)$ 的网格单元，使用迎风差分\n$$\nD_x^-\\phi_{i,j}=\\frac{\\phi_{i,j}-\\phi_{i-1,j}}{\\Delta x},\\quad\nD_x^+\\phi_{i,j}=\\frac{\\phi_{i+1,j}-\\phi_{i,j}}{\\Delta x},\n$$\n$$\nD_y^-\\phi_{i,j}=\\frac{\\phi_{i,j}-\\phi_{i,j-1}}{\\Delta y},\\quad\nD_y^+\\phi_{i,j}=\\frac{\\phi_{i,j+1}-\\phi_{i,j}}{\\Delta y},\n$$\n并将在 $(i,j)$ 处的离散平流项定义为\n$$\n\\mathcal{A}_{i,j} = \\max(v_x,0)\\,D_x^-\\phi_{i,j} + \\min(v_x,0)\\,D_x^+\\phi_{i,j} + \\max(v_y,0)\\,D_y^-\\phi_{i,j} + \\min(v_y,0)\\,D_y^+\\phi_{i,j}.\n$$\n那么，对于带内的单元，时间更新为\n$$\n\\phi_{i,j}^{n+1} = \\phi_{i,j}^n - \\Delta t\\,\\mathcal{A}_{i,j},\\quad \\text{if }|\\phi_{i,j}^n|\\le \\delta,\n$$\n否则\n$$\n\\phi_{i,j}^{n+1} = \\phi_{i,j}^n,\\quad \\text{if }|\\phi_{i,j}^n| \\delta.\n$$\n通过将边界值复制到虚拟点来施加齐次 Neumann 边界条件，以便在边界处单边差分有良好定义。\n\n使用以下数值设置：\n- 域：$x\\in[-1,1]$ 和 $y\\in[-1,1]$，单位为米。\n- 均匀网格，有 $N_x=N_y=201$ 个点，因此 $\\Delta x=\\Delta y=\\frac{2}{N_x-1}$，单位为米。\n- 初始条件：$\\phi(x,y,0)=x$。\n- 速度：$\\mathbf{v}=(v_x,v_y)=(0.5,0.0)$，单位为米/秒。\n- 最终时间：$T=0.4$，单位为秒。\n- 时间步长：选择 $\\Delta t$ 以满足 Courant–Friedrichs–Lewy (CFL) 条件 $\\Delta t=\\theta\\min\\left(\\frac{\\Delta x}{|v_x|},\\frac{\\Delta y}{|v_y|+\\varepsilon}\\right)$，其中 $\\theta=0.5$，当 $v_y=0$ 时 $\\varepsilon=0$，因此 $\\Delta t=0.5\\,\\frac{\\Delta x}{|v_x|}$，单位为秒。\n- 时间积分：前向欧拉法，步数为 $N_t=\\left\\lceil\\frac{T}{\\Delta t}\\right\\rceil$。\n\n将精度度量定义为在时间 $T$ 时，窄带数值解与整个网格上的精确解 $\\phi_{\\text{exact}}(x,y,T)=x-v_x T$ 之间的均方根误差 (RMSE)，\n$$\n\\mathrm{RMSE}=\\sqrt{\\frac{1}{N_x N_y}\\sum_{i=1}^{N_x}\\sum_{j=1}^{N_y}\\left(\\phi_{i,j}^{\\text{band}}(T)-\\phi_{\\text{exact}}(x_i,y_j,T)\\right)^2},\n$$\n其单位为米。将计算成本定义为每个时间步更新的网格单元的平均比例，\n$$\n\\mathrm{cost}=\\frac{1}{N_t}\\sum_{n=0}^{N_t-1}\\frac{\\#\\{(i,j):|\\phi_{i,j}^n|\\le \\delta\\}}{N_x N_y},\n$$\n其为无量纲，且值在 $[0,1]$ 区间内。\n\n测试套件：\n- 情况 1：$\\delta=0$ 米（边界情况：仅更新恰好在零水平集上的单元）。\n- 情况 2：$\\delta=\\Delta x$ 米（带宽大约为一个网格单元宽度）。\n- 情况 3：$\\delta=0.05$ 米（中等带宽）。\n- 情况 4：$\\delta=2.0$ 米（带宽覆盖整个域；等同于全域更新）。\n\n您的程序必须为每个测试用例计算 $[\\mathrm{RMSE},\\mathrm{cost}]$ 对，并生成一行输出，其中包含这些对的列表，形式为逗号分隔且无空格，并用方括号括起来，例如：\n$[[e_1,c_1],[e_2,c_2],[e_3,c_3],[e_4,c_4]]$。\n所有报告的值必须是浮点数。输出中无需打印物理单位；RMSE 将隐式地以米为单位，而成本是无量纲的。",
            "solution": "该问题要求实现和分析一种窄带水平集方法，用于模拟界面的平流。其控制方程是线性平流方程，该方程描述了标量场 $\\phi$ 如何被速度场 $\\mathbf{v}$ 输运。\n\n### 1. 问题描述与离散化\n\n物理问题是在二维域中，标量场 $\\phi(x,y,t)$ 的演化，由偏微分方程 (PDE) 控制：\n$$\n\\frac{\\partial \\phi}{\\partial t} + \\mathbf{v} \\cdot \\nabla \\phi = 0\n$$\n域是由 $x \\in [-1, 1]$ 和 $y \\in [-1, 1]$ 定义的方形板。该域使用具有 $N_x = 201$ 和 $N_y = 201$ 个点的均匀网格进行离散化。因此，每个方向上的网格间距是相同的：\n$$\n\\Delta x = \\frac{1 - (-1)}{N_x - 1} = \\frac{2}{200} = 0.01 \\, \\text{m}\n$$\n$$\n\\Delta y = \\frac{1 - (-1)}{N_y - 1} = \\frac{2}{200} = 0.01 \\, \\text{m}\n$$\n网格点由 $(x_i, y_j)$ 表示，其中 $x_i = -1 + i\\Delta x$（对于 $i \\in \\{0, 1, \\dots, N_x-1\\}$）和 $y_j = -1 + j\\Delta y$（对于 $j \\in \\{0, 1, \\dots, N_y-1\\}$）。\n\n水平集场的初始条件由以下公式给出：\n$$\n\\phi(x, y, 0) = x\n$$\n在离散网格上，这转化为 $\\phi_{i,j}^0 = x_i$。\n\n时间演化模拟到最终时间 $T = 0.4 \\, \\text{s}$。时间积分使用前向欧拉法进行。为确保数值稳定性，时间步长 $\\Delta t$ 由 Courant–Friedrichs–Lewy (CFL) 条件确定。给定安全系数 $\\theta = 0.5$ 和恒定速度场 $\\mathbf{v} = (v_x, v_y) = (0.5, 0.0) \\, \\text{m/s}$，时间步长为：\n$$\n\\Delta t = \\theta \\frac{\\Delta x}{|v_x|} = 0.5 \\times \\frac{0.01}{|0.5|} = 0.01 \\, \\text{s}\n$$\n达到最终时间 $T$ 所需的总时间步数为：\n$$\nN_t = \\left\\lceil \\frac{T}{\\Delta t} \\right\\rceil = \\left\\lceil \\frac{0.4}{0.01} \\right\\rceil = 40\n$$\n\n### 2. 数值格式：迎风有限差分\n\n平流项 $\\mathbf{v} \\cdot \\nabla \\phi$ 中的空间导数使用一阶迎风有限差分格式进行近似。选择此格式是因为其在求解像平流方程这样的双曲型偏微分方程时具有稳定性。它使用一种单边差分，从速度的“迎风”方向获取信息。离散平流算子 $\\mathcal{A}_{i,j}$ 定义为：\n$$\n\\mathcal{A}_{i,j} = \\max(v_x,0)\\,D_x^-\\phi_{i,j} + \\min(v_x,0)\\,D_x^+\\phi_{i,j} + \\max(v_y,0)\\,D_y^-\\phi_{i,j} + \\min(v_y,0)\\,D_y^+\\phi_{i,j}\n$$\n此处，$D_x^-$、$D_x^+$、$D_y^-$ 和 $D_y^+$ 分别是后向和前向差分算子。对于给定的速度 $\\mathbf{v} = (0.5, 0.0)$，我们有 $v_x  0$ 和 $v_y = 0$。$\\mathcal{A}_{i,j}$ 的表达式简化为：\n$$\n\\mathcal{A}_{i,j} = v_x D_x^-\\phi_{i,j} = 0.5 \\times \\frac{\\phi_{i,j} - \\phi_{i-1,j}}{\\Delta x}\n$$\n为了处理域边界处的导数，施加了齐次 Neumann 边界条件。这是通过在计算网格周围创建一层“虚拟单元”来实现的，其中虚拟单元中的值是相邻内部单元值的副本。例如，$\\phi_{-1,j} = \\phi_{0,j}$ 和 $\\phi_{N_x,j} = \\phi_{N_x-1,j}$。这确保了边界处的法向导数实际上为零。\n\n### 3. 窄带更新算法\n\n窄带水平集方法是一种优化，它将耗费计算资源的操作限制在零水平集周围的一个小编带内的网格单元上。对于从 $n=0$到 $N_t-1$ 的每个时间步，算法按以下步骤进行：\n\n1.  **识别窄带**：创建一个布尔掩码，用于识别所有当前水平集值 $\\phi_{i,j}^n$ 满足 $|\\phi_{i,j}^n| \\le \\delta$ 的网格单元 $(i,j)$，其中 $\\delta$ 是给定的带半宽。为计算成本度量，对该带内的单元数量进行计数。\n\n2.  **应用边界条件**：根据齐次 Neumann 条件，用虚拟单元填充 $\\phi^n$ 的网格。\n\n3.  **计算平流项**：为所有网格点计算简化的迎风平流项 $\\mathcal{A}_{i,j} = v_x (\\phi_{i,j}^n - \\phi_{i-1,j}^n) / \\Delta x$。\n\n4.  **更新水平集场**：从 $\\phi^n$ 创建当前场的副本 $\\phi_{\\text{next}}$。仅对识别为在窄带内的单元更新 $\\phi_{\\text{next}}$ 的值：\n    $$\n    \\phi_{i,j}^{n+1} = \\phi_{i,j}^n - \\Delta t\\,\\mathcal{A}_{i,j} \\quad \\text{对于所有 } (i,j) \\text{ 其中 } |\\phi_{i,j}^n| \\le \\delta\n    $$\n    对于带外的单元，其值保持不变：$\\phi_{i,j}^{n+1} = \\phi_{i,j}^n$。\n\n5.  **前进到下一步**：将下一时间步的场 $\\phi^{n+1}$ 设置为新计算的场 $\\phi_{\\text{next}}$。\n\n这个迭代过程重复 $N_t = 40$ 步。\n\n### 4. 性能指标\n\n在最后一个时间步之后，将数值解 $\\phi^{\\text{band}}(T)$ 与精确解析解进行比较。对于初始条件 $\\phi(x,y,0) = x$ 和恒定速度 $\\mathbf{v}=(v_x, 0)$，精确解为 $\\phi_{\\text{exact}}(x,y,t) = x - v_x t$。在时间 $T=0.4$ 时，这变为：\n$$\n\\phi_{\\text{exact}}(x,y,T) = x - 0.5 \\times 0.4 = x - 0.2\n$$\n\n为每个由不同 $\\delta$ 定义的测试用例计算两个度量：\n\n1.  **精度 (RMSE)**：均方根误差测量整个网格上数值解与精确解的偏差：\n    $$\n    \\mathrm{RMSE} = \\sqrt{\\frac{1}{N_x N_y}\\sum_{i=0}^{N_x-1}\\sum_{j=0}^{N_y-1}\\left(\\phi_{i,j}^{\\text{band}}(T) - \\phi_{\\text{exact}}(x_i,y_j,T)\\right)^2}\n    $$\n\n2.  **计算成本**：此度量量化了窄带方法的效率。它是在模拟过程中，每个时间步更新的网格单元的平均比例：\n    $$\n    \\mathrm{cost} = \\frac{1}{N_t N_x N_y} \\sum_{n=0}^{N_t-1} \\#\\{(i,j) : |\\phi_{i,j}^n| \\le \\delta\\}\n    $$\n\n对四个指定的 $\\delta$ 值：$0$、$\\Delta x = 0.01$、$0.05$ 和 $2.0$，分别执行这整个过程。$\\delta=2.0$ 的情况有效地覆盖了整个域，因为 $|x| \\le 1$，因此代表了预期成本为 $1.0$ 的全域更新。$\\delta=0$ 的情况是一个极端，只有精确位于零等值线上的单元被更新，预计计算成本低但精度差，因为界面会移出这些网格点。这些结果揭示了窄带方法中计算开销与解的精度之间的权衡。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the narrow-band level set advection problem for a set of test cases.\n    \"\"\"\n    \n    # ------------------\n    # Numerical Setup\n    # ------------------\n    Lx, Ly = 2.0, 2.0  # Domain size in meters\n    Nx, Ny = 201, 201    # Number of grid points\n    vx, vy = 0.5, 0.0    # Velocity in m/s\n    T_final = 0.4      # Final time in seconds\n    cfl_theta = 0.5    # CFL safety factor\n\n    # Grid spacing\n    dx = Lx / (Nx - 1)\n    dy = Ly / (Ny - 1)\n\n    # Time step from CFL condition\n    # Epsilon is only needed for non-zero vy, but to avoid division by zero if vx was 0\n    # we use a small number. Here vx is non-zero, so it is direct.\n    # The problem specifies vy=0, so the min() simplifies.\n    dt = cfl_theta * dx / abs(vx)\n    \n    # Number of time steps\n    Nt = math.ceil(T_final / dt)\n\n    # Grid coordinates\n    x = np.linspace(-Lx/2, Lx/2, Nx)\n    y = np.linspace(-Ly/2, Ly/2, Ny)\n    X, Y = np.meshgrid(x, y)\n\n    # Test cases for narrow-band half-width delta\n    test_cases = [\n        0.0,      # Case 1: Only zero level set\n        dx,       # Case 2: Band width of one grid cell\n        0.05,     # Case 3: Moderate band width\n        2.0       # Case 4: Full domain (max |phi| is 1.0)\n    ]\n\n    results = []\n    for delta in test_cases:\n        # ------------------\n        # Simulation for one delta\n        # ------------------\n\n        # Initialize level set field phi\n        phi = X.copy()\n        \n        total_active_cells = 0\n\n        # Time-stepping loop\n        for n in range(Nt):\n            # 1. Identify the narrow band\n            band_mask = np.abs(phi) = delta\n            total_active_cells += np.sum(band_mask)\n\n            # Create a copy for the next time step\n            phi_next = phi.copy()\n\n            # 2. Apply homogeneous Neumann boundary conditions via padding\n            phi_padded = np.pad(phi, pad_width=1, mode='edge')\n\n            # 3. Compute spatial derivatives (upwind scheme) using slicing\n            # Slices correspond to original grid within the padded grid\n            # numpy is (row, col) -> (j, i)\n            # So phi[j, i] corresponds to phi(x_i, y_j)\n            # X, Y from meshgrid have X as (N_y, N_x)\n            # So X[j, i] = x[i]. Correct.\n            # The first index is y (j), second is x (i)\n            phi_i_j = phi_padded[1:-1, 1:-1]\n            phi_im1_j_correct = phi_padded[1:-1, :-2] # phi at (j, i-1)\n            phi_ip1_j_correct = phi_padded[1:-1, 2:]  # phi at (j, i+1)\n            phi_i_jm1_correct = phi_padded[:-2, 1:-1] # phi at (j-1, i)\n            phi_i_jp1_correct = phi_padded[2:, 1:-1]  # phi at (j+1, i)\n            \n            Dx_minus = (phi_i_j - phi_im1_j_correct) / dx\n            Dx_plus = (phi_ip1_j_correct - phi_i_j) / dx\n            Dy_minus = (phi_i_j - phi_i_jm1_correct) / dy\n            Dy_plus = (phi_i_jp1_correct - phi_i_j) / dy\n\n            # 4. Compute discrete advection term\n            vx_pos = max(vx, 0.0)\n            vx_neg = min(vx, 0.0)\n            vy_pos = max(vy, 0.0)\n            vy_neg = min(vy, 0.0)\n            \n            adv_term = (vx_pos * Dx_minus + vx_neg * Dx_plus +\n                        vy_pos * Dy_minus + vy_neg * Dy_plus)\n\n            # 5. Update phi only inside the narrow band\n            phi_next[band_mask] = phi[band_mask] - dt * adv_term[band_mask]\n            \n            # 6. Advance to the next step\n            phi = phi_next\n\n        # ------------------\n        # Post-processing and Metrics\n        # ------------------\n        \n        # Exact solution at final time T\n        phi_exact = X - vx * T_final\n        \n        # RMSE calculation\n        rmse = np.sqrt(np.mean((phi - phi_exact)**2))\n        \n        # Computational cost calculation\n        cost = total_active_cells / (Nt * Nx * Ny)\n        \n        results.append([rmse, cost])\n\n    # Format output as required: [[e1,c1],[e2,c2],[e3,c3],[e4,c4]]\n    # using str() and replace() is a robust way to get the exact format\n    output_string = str(results).replace(\" \", \"\")\n\n    print(output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "水平集表示的最终目的是为了方便进行力学分析，通常会使用扩展有限元法（XFEM）。在 XFEM 中，一个关键任务是精确地对跨越裂纹面的不连续函数进行积分。本练习将指导你完成对一个被水平集切割的四面体单元进行划分，并应用适当的求积规则来计算不连续函数的积分，这是构建系统刚度矩阵的基本环节。",
            "id": "3577100",
            "problem": "要求您为三维四面体有限元设计并实现一个稳健的数值求积程序，这些有限元被一个由标量场的零水平集隐式表示的裂纹面所切割。在用于裂纹表示的水平集方法中，裂纹面被建模为水平集函数的零等值面。考虑一个顶点位置为 $\\mathbf{v}_0,\\mathbf{v}_1,\\mathbf{v}_2,\\mathbf{v}_3 \\in \\mathbb{R}^3$ 的单个四面体单元，以及一个在单元内呈线性的水平集函数 $\\phi(\\mathbf{x})$。零水平集 $\\phi(\\mathbf{x})=0$ 应被解释为裂纹面。任务是计算一个分段光滑的被积函数的积分，该函数在 $\\{\\mathbf{x} \\mid \\phi(\\mathbf{x})=0\\}$ 上存在跳跃间断。\n\n您必须使用的基本原理包括：水平集函数的定义及其在表示界面中的作用，当在顶点上指定时 $\\phi(\\mathbf{x})$ 在有限元内的线性性质，通过平面切割凸集来构造多面体划分，以及使用重心坐标为四面体构建求积规则。您必须从这些基础出发来设计程序，并推导出边交点计算、多面体三角化和四面体积分所需的公式。您不得假定超出这些基础知识的任何特殊快捷公式，并且必须说明如何选择您的求积规则，以在每个子四面体内精确积分给定次数的多项式。\n\n在每个单元内，被积函数 $f(\\mathbf{x})$ 分段定义如下：\n- 对于 $\\phi(\\mathbf{x})0$，$f(\\mathbf{x})=f^{+}(\\mathbf{x})$，\n- 对于 $\\phi(\\mathbf{x})\\le 0$，$f(\\mathbf{x})=f^{-}(\\mathbf{x})$，\n其中 $f^{+}(\\mathbf{x})$ 和 $f^{-}(\\mathbf{x})$ 是单元内的光滑多项式，跳跃由 $f^{-}(\\mathbf{x})=f^{+}(\\mathbf{x}) + J$ 实现，其中 $J \\in \\mathbb{R}$ 是一个恒定的跳跃幅度。\n\n您的程序必须：\n1. 对于每个四面体，通过四面体与半空间 $\\{\\mathbf{x} \\mid \\phi(\\mathbf{x})\\ge 0\\}$ 和 $\\{\\mathbf{x} \\mid \\phi(\\mathbf{x})\\le 0\\}$ 的交集，将该单元划分为两个凸多面体。这需要计算平面 $\\phi(\\mathbf{x})=0$ 与任何其端点 $\\phi$ 值符号相反的四面体棱之间的交点。您必须基于单元内 $\\phi$ 的线性性质所隐含的线性插值，推导并实现边交点计算。\n2. 将每个凸多面体三角化为一组子四面体，使得它们的并集等于该多面体，并且除了可能在零测度的边界上之外，它们不重叠。您必须设计一个通用程序，适用于三角形切割情况（一个顶点在一侧，三个在另一侧）和四边形切割情况（每侧两个顶点），以及无切割情况。您的方法必须从凸多面体的第一性原理推导得出，并且必须以科学合理的方式生成一组覆盖该多面体的四面体。\n3. 在每个子四面体上，使用一个对最高2次（二阶）多项式精确的四面体积分法则进行数值求积，以确保对二次被积函数的准确性。该法则必须通过重心坐标和适当的权重来表示，并且必须从单纯形上多项式精确性的第一性原理进行证明。\n4. 使用 $f^{+}(\\mathbf{x})$ 对 $\\phi0$ 一侧的子四面体的贡献求和，使用 $f^{-}(\\mathbf{x})$ 对 $\\phi\\le 0$ 一侧的子四面体的贡献求和，从而捕捉裂纹面上的跳跃间断。\n5. 为每个测试用例，生成 $f(\\mathbf{x})$ 在整个四面体上的积分值。\n\n数学设定纯粹是几何和代数的。不涉及角度，因此不需要角度单位。不涉及物理单位；所有量都是无量纲的。您的程序必须使用以下测试套件，它涵盖了一般情况、四边形切割、无切割以及靠近顶点的近退化切割。对于所有测试用例，正侧的被积函数是\n$$\nf^{+}(\\mathbf{x}) = a_0 + \\mathbf{a} \\cdot \\mathbf{x} + \\mathbf{x}^{\\top} \\mathbf{B} \\mathbf{x},\n$$\n其中 $a_0 \\in \\mathbb{R}$，$\\mathbf{a} \\in \\mathbb{R}^3$，$\\mathbf{B} \\in \\mathbb{R}^{3\\times 3}$ 是对称矩阵，而在负侧 $f^{-}(\\mathbf{x}) = f^{+}(\\mathbf{x}) + J$，其中 $J \\in \\mathbb{R}$。\n\n为所有测试用例定义四面体顶点如下\n$$\n\\mathbf{v}_0=(0,0,0),\\quad \\mathbf{v}_1=(1,0,0),\\quad \\mathbf{v}_2=(0,1,0),\\quad \\mathbf{v}_3=(0,0,1).\n$$\n对于每个测试用例 $k$，定义 $\\phi(\\mathbf{x}) = \\mathbf{n}^{(k)} \\cdot \\mathbf{x} - c^{(k)}$，其中 $\\mathbf{n}^{(k)} \\in \\mathbb{R}^3$ 且 $c^{(k)} \\in \\mathbb{R}$：\n\n- 测试用例 1 (三角形切割): $\\mathbf{n}^{(1)}=(1,1,1)$, $c^{(1)}=0.8$, $a_0=0$, $\\mathbf{a}=(0.2,-0.1,0.05)$, $\\mathbf{B}=\\mathrm{diag}(0.1,0.2,0.3)$, $J=1.0$。\n- 测试用例 2 (四边形切割): $\\mathbf{n}^{(2)}=(1,1,0)$, $c^{(2)}=0.5$, $a_0=0$, $\\mathbf{a}=(0.2,-0.1,0.05)$, $\\mathbf{B}=\\mathrm{diag}(0.1,0.2,0.3)$, $J=1.0$。\n- 测试用例 3 (无切割，全为正): $\\mathbf{n}^{(3)}=(0,0,1)$, $c^{(3)}=-0.2$, $a_0=0$, $\\mathbf{a}=(0.2,-0.1,0.05)$, $\\mathbf{B}=\\mathrm{diag}(0.1,0.2,0.3)$, $J=1.0$。\n- 测试用例 4 (近退化三角形切割): $\\mathbf{n}^{(4)}=(1,1,1)$, $c^{(4)}=1 - 10^{-12}$, $a_0=0$, $\\mathbf{a}=(0.2,-0.1,0.05)$, $\\mathbf{B}=\\mathrm{diag}(0.1,0.2,0.3)$, $J=1.0$。\n\n您的程序必须为每个测试用例计算积分\n$$\nI = \\int_{\\text{tet}} f(\\mathbf{x}) \\, \\mathrm{d}V = \\int_{\\phi(\\mathbf{x})0} f^{+}(\\mathbf{x}) \\, \\mathrm{d}V + \\int_{\\phi(\\mathbf{x})\\le 0} f^{-}(\\mathbf{x}) \\, \\mathrm{d}V,\n$$\n通过使用零水平集划分四面体，并应用对2次多项式精确的子四面体求积法。最终输出必须是包含测试用例结果的单行文本，形式为用方括号括起来的逗号分隔列表。例如，它应该看起来像\n$[I_1,I_2,I_3,I_4]$,\n其中 $I_k$ 是测试用例 $k$ 的浮点积分值。\n\n您的程序必须是自包含的，并且无需用户输入即可运行。它必须遵守指定的执行环境和库约束。输出值必须以默认的浮点字符串表示形式按完全精度打印。答案没有物理单位；返回原始数值。",
            "solution": "该问题要求设计并实现一个数值求积程序，用以计算一个分段定义函数在单个四面体单元上的积分。该函数在一个由线性函数 $\\phi(\\mathbf{x})$ 的零水平集隐式定义的平面上存在跳跃间断。该方法基于计算几何和数值分析的原理，具体而言，是通过根据 $\\phi(\\mathbf{x})$ 的符号来划分积分域。\n\n需要计算的值是积分 $I$：\n$$\nI = \\int_{T} f(\\mathbf{x}) \\, \\mathrm{d}V = \\int_{T \\cap \\{\\mathbf{x}|\\phi(\\mathbf{x})0\\}} f^{+}(\\mathbf{x}) \\, \\mathrm{d}V + \\int_{T \\cap \\{\\mathbf{x}|\\phi(\\mathbf{x})\\le 0\\}} f^{-}(\\mathbf{x}) \\, \\mathrm{d}V\n$$\n其中 $T$ 是四面体单元。核心策略包括四个主要步骤：(1) 确定平面 $\\phi(\\mathbf{x})=0$ 与四面体的交集，(2) 基于此交集将四面体划分为两个多面体，(3) 将每个多面体分解为一组不重叠的子四面体，以及 (4) 对每个子四面体应用合适的数值求积法则。\n\n**步骤1：水平集表示与边交点**\n\n一个四面体 $T$ 由其四个顶点 $\\mathbf{v}_0, \\mathbf{v}_1, \\mathbf{v}_2, \\mathbf{v}_3 \\in \\mathbb{R}^3$ 定义。水平集函数 $\\phi(\\mathbf{x})$ 在单元内是线性的，这意味着其在任意点 $\\mathbf{x}$ 的值可以通过其在顶点处值的线性插值得到。令 $\\phi_i = \\phi(\\mathbf{v}_i)$，其中 $i \\in \\{0, 1, 2, 3\\}$。\n\n切割平面 $\\phi(\\mathbf{x})=0$ 与四面体相交，当且仅当并非所有 $\\phi_i$ 都具有相同的符号。交点（如果存在）位于四面体的棱上。考虑连接顶点 $\\mathbf{v}_i$ 和 $\\mathbf{v}_j$ 的一条棱。该棱所定义的线段上的任意点 $\\mathbf{p}$ 都可以参数化为 $\\mathbf{p}(t) = (1-t)\\mathbf{v}_i + t\\mathbf{v}_j$，其中 $t \\in [0, 1]$。由于 $\\phi$ 的线性性质，其在 $\\mathbf{p}(t)$ 处的值为 $\\phi(\\mathbf{p}(t)) = (1-t)\\phi_i + t\\phi_j$。\n\n与零水平集的交点发生在 $\\phi(\\mathbf{p}(t)) = 0$ 处。求解 $t$ 可得：\n$$\n(1-t)\\phi_i + t\\phi_j = 0 \\implies t\\phi_j - t\\phi_i = -\\phi_i \\implies t(\\phi_j - \\phi_i) = -\\phi_i\n$$\n$$\nt = \\frac{\\phi_i}{\\phi_i - \\phi_j}\n$$\n当且仅当 $\\phi_i$ 和 $\\phi_j$ 符号相反时，一个交点 $\\mathbf{p}_{ij}$ 才存在于棱段内部（即 $t \\in (0, 1)$）。该交点的位置则为：\n$$\n\\mathbf{p}_{ij} = (1-t)\\mathbf{v}_i + t\\mathbf{v}_j = \\mathbf{v}_i + t(\\mathbf{v}_j - \\mathbf{v}_i)\n$$\n\n**步骤2：划分四面体**\n\n我们首先根据水平集函数的符号将顶点分为两组：正集 $V^+ = \\{\\mathbf{v}_i \\mid \\phi_i  0\\}$ 和负集 $V^- = \\{\\mathbf{v}_i \\mid \\phi_i \\le 0\\}$。\n- 如果 $V^+$ 或 $V^-$ 为空，则平面不切割四面体。整个单元位于间断的一侧，积分在原始四面体上使用 $f^+(\\mathbf{x})$ 或 $f^-(\\mathbf{x})$ 计算。\n- 如果两个集合都非空，则平面切割四面体。根据每侧顶点的数量，出现两种情况：\n    1.  **三角形切割（1个顶点 vs 3个顶点）：**一个顶点在一个集合中（例如 $V^-$），三个在另一个集合中（$V^+$）。平面与连接单个顶点到另外三个顶点的三条棱相交，在平面上形成一个三角形的相交区域。这将四面体划分为一个小四面体和一个五面体（一个截角四面体）。\n    2.  **四边形切割（2个顶点 vs 2个顶点）：**两个顶点在 $V^-$ 中，两个在 $V^+$ 中。平面与连接来自不同集合的顶点的四条棱相交，形成一个四边形的相交区域。这将四面体划分为两个楔形多面体。\n\n**步骤3：凸多面体的三角化**\n\n为了进行积分，每个产生的凸多面体都必须被分解（三角化）为一组不重叠的子四面体。我们为每种情况建立一个系统性的分解方法。\n\n**情况A：三角形切割（1 vs. 3）**\n假设顶点 $\\mathbf{v}_d \\in V^-$，顶点 $\\mathbf{v}_a, \\mathbf{v}_b, \\mathbf{v}_c \\in V^+$。平面分别在点 $\\mathbf{p}_{da}$、$\\mathbf{p}_{db}$ 和 $\\mathbf{p}_{dc}$ 处与棱 $(\\mathbf{v}_d, \\mathbf{v}_a)$、$(\\mathbf{v}_d, \\mathbf{v}_b)$ 和 $(\\mathbf{v}_d, \\mathbf{v}_c)$ 相交。\n- 负多面体是四面体 $T^- = (\\mathbf{v}_d, \\mathbf{p}_{da}, \\mathbf{p}_{db}, \\mathbf{p}_{dc})$。\n- 正多面体（一个五面体）被分解为三个四面体：\n    - $T^+_1 = (\\mathbf{v}_a, \\mathbf{p}_{da}, \\mathbf{p}_{db}, \\mathbf{p}_{dc})$\n    - $T^+_2 = (\\mathbf{v}_a, \\mathbf{v}_b, \\mathbf{p}_{db}, \\mathbf{p}_{dc})$\n    - $T^+_3 = (\\mathbf{v}_a, \\mathbf{v}_b, \\mathbf{v}_c, \\mathbf{p}_{dc})$\n这种分解是通用的，其体积总和正确地等于该五面体的体积。\n\n**情况B：四边形切割（2 vs. 2）**\n假设顶点 $\\mathbf{v}_a, \\mathbf{v}_b \\in V^-$，顶点 $\\mathbf{v}_c, \\mathbf{v}_d \\in V^+$。平面分别在点 $\\mathbf{p}_{ac}$、$\\mathbf{p}_{ad}$、$\\mathbf{p}_{bc}$ 和 $\\mathbf{p}_{bd}$ 处与棱 $(\\mathbf{v}_a, \\mathbf{v}_c)$、$(\\mathbf{v}_a, \\mathbf{v}_d)$、$(\\mathbf{v}_b, \\mathbf{v}_c)$ 和 $(\\mathbf{v}_b, \\mathbf{v}_d)$ 相交。\n- 负多面体被分解为三个四面体：\n    - $T^-_1 = (\\mathbf{v}_a, \\mathbf{v}_b, \\mathbf{p}_{ac}, \\mathbf{p}_{ad})$\n    - $T^-_2 = (\\mathbf{v}_b, \\mathbf{p}_{ac}, \\mathbf{p}_{bc}, \\mathbf{p}_{ad})$\n    - $T^-_3 = (\\mathbf{v}_b, \\mathbf{p}_{bc}, \\mathbf{p}_{bd}, \\mathbf{p}_{ad})$\n- 根据对称性，正多面体被分解为三个四面体：\n    - $T^+_1 = (\\mathbf{v}_c, \\mathbf{v}_d, \\mathbf{p}_{ac}, \\mathbf{p}_{bc})$\n    - $T^+_2 = (\\mathbf{v}_d, \\mathbf{p}_{ac}, \\mathbf{p}_{ad}, \\mathbf{p}_{bc})$\n    - $T^+_3 = (\\mathbf{v}_d, \\mathbf{p}_{ad}, \\mathbf{p}_{bd}, \\mathbf{p}_{bc})$\n这种稳健的分解方法覆盖了每个楔形多面体的体积。\n\n**步骤4：在子四面体上进行数值求积**\n\n函数 $g(\\mathbf{x})$ 在子四面体 $T_{sub}$ 上的积分通过一个数值求积法则来近似：\n$$\n\\int_{T_{sub}} g(\\mathbf{x}) \\, \\mathrm{d}V \\approx V_{sub} \\sum_{q=1}^{N_q} w_q g(\\mathbf{x}_q)\n$$\n其中 $V_{sub}$ 是子四面体的体积，$\\mathbf{x}_q$ 是求积点，$w_q$ 是相应的权重，$N_q$ 是点的数量。一个顶点为 $(\\mathbf{v}_w, \\mathbf{v}_x, \\mathbf{v}_y, \\mathbf{v}_z)$ 的四面体的体积由 $V_{sub} = \\frac{1}{6} |\\det([\\mathbf{v}_x-\\mathbf{v}_w, \\mathbf{v}_y-\\mathbf{v}_w, \\mathbf{v}_z-\\mathbf{v}_w])|$ 给出。\n\n问题要求一个对2次多项式精确的法则。一个标准的4点法则满足此条件。求积点可以方便地用相对于子四面体顶点的重心坐标 $(\\xi_0, \\xi_1, \\xi_2, \\xi_3)$ 来表示。该法则由四个点定义，具有以下重心坐标和相等的权重：\n- 点 1: $(\\alpha, \\beta, \\beta, \\beta)$\n- 点 2: $(\\beta, \\alpha, \\beta, \\beta)$\n- 点 3: $(\\beta, \\beta, \\alpha, \\beta)$\n- 点 4: $(\\beta, \\beta, \\beta, \\alpha)$\n其中 $\\alpha = \\frac{5+3\\sqrt{5}}{20}$ 和 $\\beta = \\frac{5-\\sqrt{5}}{20}$。每个点的权重为 $w_q = 1/4$。\n对于一个顶点为 $(\\mathbf{v}_w, \\mathbf{v}_x, \\mathbf{v}_y, \\mathbf{v}_z)$ 且对应重心坐标为 $(\\xi_w, \\xi_x, \\xi_y, \\xi_z)$ 的子四面体，其求积点 $\\mathbf{x}_q$ 的笛卡尔坐标计算如下：$\\mathbf{x}_q = \\xi_w \\mathbf{v}_w + \\xi_x \\mathbf{v}_x + \\xi_y \\mathbf{v}_y + \\xi_z \\mathbf{v}_z$。\n\n**最终算法**\n\n总积分 $I$ 是所有子四面体上积分的总和。对于从正多面体生成的每个子四面体，使用被积函数 $f^+(\\mathbf{x})$。对于从负多面体生成的子四面体，使用 $f^-(\\mathbf{x}) = f^+(\\mathbf{x}) + J$。这个过程正确地处理了被积函数在裂纹面上的跳跃。最终的实现将系统地将这些推导出的公式应用于所提供的测试用例。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the integral of a piecewise polynomial function over a tetrahedral element\n    intersected by a planar crack surface defined by a level set function.\n    \"\"\"\n\n    # Define the fixed tetrahedral vertices for all test cases.\n    v = np.array([\n        [0.0, 0.0, 0.0],  # v0\n        [1.0, 0.0, 0.0],  # v1\n        [0.0, 1.0, 0.0],  # v2\n        [0.0, 0.0, 1.0]   # v3\n    ])\n\n    # Define the test cases.\n    test_cases = [\n        # case 1: triangular cut\n        {'n': np.array([1.0, 1.0, 1.0]), 'c': 0.8, 'a0': 0.0, 'a': np.array([0.2, -0.1, 0.05]), 'B': np.diag([0.1, 0.2, 0.3]), 'J': 1.0},\n        # case 2: quadrilateral cut\n        {'n': np.array([1.0, 1.0, 0.0]), 'c': 0.5, 'a0': 0.0, 'a': np.array([0.2, -0.1, 0.05]), 'B': np.diag([0.1, 0.2, 0.3]), 'J': 1.0},\n        # case 3: no cut, all positive\n        {'n': np.array([0.0, 0.0, 1.0]), 'c': -0.2, 'a0': 0.0, 'a': np.array([0.2, -0.1, 0.05]), 'B': np.diag([0.1, 0.2, 0.3]), 'J': 1.0},\n        # case 4: near-degenerate triangular cut\n        {'n': np.array([1.0, 1.0, 1.0]), 'c': 1.0 - 1e-12, 'a0': 0.0, 'a': np.array([0.2, -0.1, 0.05]), 'B': np.diag([0.1, 0.2, 0.3]), 'J': 1.0},\n    ]\n\n    # Barycentric coordinates and weights for the 4-point, 2nd-order quadrature rule.\n    alpha = (5.0 + 3.0 * np.sqrt(5.0)) / 20.0\n    beta = (5.0 - np.sqrt(5.0)) / 20.0\n    quad_bary_coords = np.array([\n        [alpha, beta,  beta,  beta],\n        [beta,  alpha, beta,  beta],\n        [beta,  beta,  alpha, beta],\n        [beta,  beta,  beta,  alpha]\n    ])\n    quad_weights = np.full(4, 1.0 / 4.0)\n\n    def integrate_tet(tet_vertices, integrand_func):\n        \"\"\"\n        Numerically integrates a given function over a single tetrahedron.\n        \"\"\"\n        v0, v1, v2, v3 = tet_vertices\n        \n        # Volume of the tetrahedron\n        mat = np.array([v1 - v0, v2 - v0, v3 - v0])\n        volume = np.abs(np.linalg.det(mat)) / 6.0\n        \n        if volume  1e-16: # Skip integration for degenerate tetrahedra.\n            return 0.0\n\n        integral = 0.0\n        for i in range(4):\n            bary_coords = quad_bary_coords[i]\n            # Convert barycentric to Cartesian coordinates\n            quad_point = bary_coords[0] * v0 + bary_coords[1] * v1 + \\\n                         bary_coords[2] * v2 + bary_coords[3] * v3\n            \n            # Evaluate integrand at the quadrature point\n            integrand_val = integrand_func(quad_point)\n            integral += quad_weights[i] * integrand_val\n        \n        return volume * integral\n\n    results = []\n    for case in test_cases:\n        n, c, a0, a, B, J = case['n'], case['c'], case['a0'], case['a'], case['B'], case['J']\n\n        def f_plus(x):\n            return a0 + np.dot(a, x) + x.T @ B @ x\n\n        def f_minus(x):\n            return f_plus(x) + J\n\n        phi_vals = np.array([np.dot(n, vi) - c for vi in v])\n        \n        pos_indices = [i for i, val in enumerate(phi_vals) if val > 0]\n        neg_indices = [i for i, val in enumerate(phi_vals) if val = 0]\n\n        total_integral = 0.0\n\n        if not pos_indices:  # All vertices are negative\n            total_integral = integrate_tet(v, f_minus)\n        elif not neg_indices:  # All vertices are positive\n            total_integral = integrate_tet(v, f_plus)\n        else: # The element is cut\n            # Find intersection points\n            intersection_points = {}\n            edges = [(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)]\n            for i, j in edges:\n                if phi_vals[i] * phi_vals[j]  0:\n                    # Sort to ensure (neg, pos) pair for consistent t calculation\n                    i_neg, i_pos = (i, j) if phi_vals[i] = 0 else (j, i)\n                    phi_i, phi_j = phi_vals[i_neg], phi_vals[i_pos]\n                    t = phi_i / (phi_i - phi_j)\n                    p_ij = v[i_neg] + t * (v[i_pos] - v[i_neg])\n                    key = tuple(sorted((i,j)))\n                    intersection_points[key] = p_ij\n\n            positive_sub_tets = []\n            negative_sub_tets = []\n\n            if len(neg_indices) == 1 or len(pos_indices) == 1: # 1-vs-3 split\n                if len(neg_indices) == 1:\n                    d_idx = neg_indices[0]\n                    a_idx, b_idx, c_idx = pos_indices\n                else: # Symmetric case\n                    d_idx = pos_indices[0]\n                    a_idx, b_idx, c_idx = neg_indices\n                \n                v_d, v_a, v_b, v_c = v[d_idx], v[a_idx], v[b_idx], v[c_idx]\n                p_da = intersection_points[tuple(sorted((d_idx, a_idx)))]\n                p_db = intersection_points[tuple(sorted((d_idx, b_idx)))]\n                p_dc = intersection_points[tuple(sorted((d_idx, c_idx)))]\n                \n                # Polyhedron on the side of v_d\n                sub_tets_d = [(v_d, p_da, p_db, p_dc)]\n                # Polyhedron on the side of v_a,v_b,v_c\n                sub_tets_abc = [\n                    (p_da, v_a, v_b, v_c),\n                    (p_da, p_db, v_b, v_c),\n                    (p_da, p_db, p_dc, v_c)\n                ]\n\n                if phi_vals[d_idx] = 0:\n                    negative_sub_tets.extend(sub_tets_d)\n                    positive_sub_tets.extend(sub_tets_abc)\n                else:\n                    positive_sub_tets.extend(sub_tets_d)\n                    negative_sub_tets.extend(sub_tets_abc)\n\n            elif len(neg_indices) == 2 and len(pos_indices) == 2: # 2-vs-2 split\n                a_idx, b_idx = neg_indices\n                c_idx, d_idx = pos_indices\n                v_a, v_b = v[a_idx], v[b_idx]\n                v_c, v_d = v[c_idx], v[d_idx]\n\n                p_ac = intersection_points[tuple(sorted((a_idx, c_idx)))]\n                p_ad = intersection_points[tuple(sorted((a_idx, d_idx)))]\n                p_bc = intersection_points[tuple(sorted((b_idx, c_idx)))]\n                p_bd = intersection_points[tuple(sorted((b_idx, d_idx)))]\n\n                # Negative polyhedron triangulation\n                negative_sub_tets.extend([\n                    (v_a, v_b, p_ac, p_ad),\n                    (v_b, p_ac, p_bc, p_ad),\n                    (v_b, p_bc, p_bd, p_ad)\n                ])\n                # Positive polyhedron triangulation\n                positive_sub_tets.extend([\n                    (v_c, v_d, p_ac, p_bc),\n                    (v_d, p_ac, p_ad, p_bc),\n                    (v_d, p_ad, p_bd, p_bc)\n                ])\n\n            for tet in positive_sub_tets:\n                total_integral += integrate_tet(tet, f_plus)\n            for tet in negative_sub_tets:\n                total_integral += integrate_tet(tet, f_minus)\n\n        results.append(total_integral)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}