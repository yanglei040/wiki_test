{
    "hands_on_practices": [
        {
            "introduction": "To build robust fluid-structure interaction solvers, we must first understand how to mathematically describe the coupled system. This foundational exercise () uses the classic one-dimensional piston problem to demonstrate how to derive the governing equations from first principles. By applying conservation laws for the fluid and Newton's second law for the structure, you will construct the coupled partial differential equation (PDE) and ordinary differential equation (ODE) system and identify the intrinsic wave speed of the fluid, a key parameter governing the system's dynamics.",
            "id": "3566559",
            "problem": "Consider a one-dimensional, compressible, inviscid fluid of constant density $\\rho_{f}$ occupying a rigid tube of undeformed length $L$ and constant cross-sectional area $A$. The tube is closed at $x=L$ and at $x=0$ the fluid is in contact with a rigid piston of mass $m_{s}$ that is attached to a linear spring of stiffness $k_{s}$, anchored to a fixed support. The piston moves along the axis of the tube and compresses the fluid. Assume small perturbations about a uniform equilibrium state, and neglect mean flow and gravity.\n\nUsing the fundamental balance laws for the fluid (conservation of linear momentum and mass) and Newton’s second law for the piston, derive the coupled ordinary differential equation–partial differential equation system governing the piston displacement $x_{s}(t)$, the fluid velocity $u(x,t)$, and the fluid pressure $p(x,t)$ under small perturbations. Close the fluid equations by a linearized equation of state based on the fluid bulk modulus $K$, appropriate for small-amplitude acoustic motions.\n\nThen, define the “effective wave speed seen by the piston” as the characteristic speed of propagation of small disturbances in the fluid that determines the causality and time-of-flight of information from the boundary into the fluid domain. Compute this effective wave speed in closed form and express it symbolically as a function of the bulk modulus $K$ and the fluid density $\\rho_{f}$. You do not need to provide a numerical value; provide the analytical expression only. If any intermediate quantities require units, use the International System of Units (SI), but the final analytical expression should be unit-free in its presentation.",
            "solution": "We begin from first principles under small perturbations. The fluid is assumed inviscid and compressible, and the motions are small, so the linearized equations of acoustics apply. Let $u(x,t)$ denote the axial fluid velocity and $p(x,t)$ denote the pressure perturbation. The linearized conservation of linear momentum (Euler equation) and mass (continuity), together with a linearized constitutive relation (equation of state), form the foundation.\n\nThe linearized momentum balance in one spatial dimension is\n$$\n\\rho_{f}\\,\\frac{\\partial u}{\\partial t} + \\frac{\\partial p}{\\partial x} = 0,\n$$\nwhich states that the rate of change of momentum density $\\rho_{f} u$ is balanced by the pressure gradient force. The linearized mass conservation, together with the linearized equation of state for small-amplitude acoustics, can be written equivalently as\n$$\n\\frac{\\partial p}{\\partial t} + \\rho_{f}\\,c^{2}\\,\\frac{\\partial u}{\\partial x} = 0,\n$$\nwhere $c$ is the acoustic wave speed to be determined from material properties. For a compressible, inviscid fluid, the linearized equation of state relates pressure and volumetric strain via the bulk modulus $K$. Under small perturbations, one obtains the well-tested relation\n$$\nc^{2} = \\frac{K}{\\rho_{f}}.\n$$\nThis follows from $K = \\rho_{f}\\left(\\frac{\\partial p}{\\partial \\rho}\\right)$ and the linearization about a uniform state.\n\nCombining the two linear first-order equations yields the classical acoustic wave equations. Differentiating the momentum equation with respect to time and the continuity equation with respect to space, and eliminating $u$, we obtain\n$$\n\\frac{\\partial^{2} p}{\\partial t^{2}} = c^{2}\\,\\frac{\\partial^{2} p}{\\partial x^{2}},\n$$\nand similarly, eliminating $p$ yields\n$$\n\\frac{\\partial^{2} u}{\\partial t^{2}} = c^{2}\\,\\frac{\\partial^{2} u}{\\partial x^{2}}.\n$$\nBoth pressure and velocity perturbations thus satisfy hyperbolic wave equations with characteristic speed $c = \\sqrt{\\frac{K}{\\rho_{f}}}$.\n\nWe now include the fluid–structure coupling at the boundaries and the piston dynamics. The right end at $x=L$ is a rigid wall, so the fluid velocity there must vanish:\n$$\nu(L,t) = 0.\n$$\nAt the left end, $x=0$, the fluid is in contact with the piston. Because the fluid and piston share the boundary, the no-slip compatibility for inviscid normal motion implies that the fluid velocity equals the piston velocity,\n$$\nu(0,t) = \\dot{x}_{s}(t),\n$$\nwhere $x_{s}(t)$ is the piston displacement and the dot denotes a time derivative.\n\nThe piston is subjected to the spring force and the net fluid pressure force acting over area $A$. Newton’s second law for the piston reads\n$$\nm_{s}\\,\\ddot{x}_{s}(t) + k_{s}\\,x_{s}(t) + A\\,p(0,t) = 0,\n$$\nwhere the sign convention is chosen so that positive $x_{s}$ compresses the fluid, $p(0,t)$ is the fluid pressure at the piston interface, and $A\\,p(0,t)$ is the resultant fluid force on the piston opposing motion.\n\nCollecting these, the coupled ordinary differential equation–partial differential equation system is\n$$\n\\rho_{f}\\,\\frac{\\partial u}{\\partial t} + \\frac{\\partial p}{\\partial x} = 0,\\qquad\n\\frac{\\partial p}{\\partial t} + \\rho_{f}\\,c^{2}\\,\\frac{\\partial u}{\\partial x} = 0,\\qquad c^{2} = \\frac{K}{\\rho_{f}},\n$$\nwith boundary conditions\n$$\nu(0,t) = \\dot{x}_{s}(t),\\qquad u(L,t) = 0,\n$$\nand the piston evolution equation\n$$\nm_{s}\\,\\ddot{x}_{s}(t) + k_{s}\\,x_{s}(t) + A\\,p(0,t) = 0.\n$$\n\nWe now compute the effective wave speed seen by the piston, defined as the characteristic speed of propagation of small disturbances in the fluid domain. In the linear acoustics limit derived above, the governing hyperbolic equations for $u$ and $p$ possess characteristics $x \\pm c t = \\mathrm{const}$, indicating that information travels through the fluid at the speed $c$. The coupling to the piston and the rigid wall affects the amplitudes and admissible mode shapes and frequencies through boundary conditions, but does not alter the intrinsic propagation speed of the hyperbolic operator governing the fluid field. Therefore, the effective wave speed seen by the piston, in the sense of the causality and time-of-flight of disturbances from the boundary into the fluid column, is the acoustic speed\n$$\nc = \\sqrt{\\frac{K}{\\rho_{f}}}.\n$$\n\nThis expression depends only on the fluid bulk modulus $K$ and the density $\\rho_{f}$; the structural parameters $m_{s}$, $k_{s}$, $L$, and $A$ enter the coupling and modal spectrum but do not modify the characteristic speed of the underlying fluid equations under the stated small-perturbation assumptions.",
            "answer": "$$\\boxed{\\sqrt{\\frac{K}{\\rho_{f}}}}$$"
        },
        {
            "introduction": "While partitioned algorithms, which solve fluid and solid sub-problems separately, are popular for their modularity, they can suffer from severe numerical instabilities. This practice () confronts the notorious 'added-mass instability,' which arises when a light structure interacts with a dense fluid using an explicit coupling scheme. Through a combination of analytical derivation and computational verification, you will uncover the mathematical condition that leads to this instability, gaining a crucial understanding of why and when simple partitioned schemes fail.",
            "id": "3566533",
            "problem": "Consider a one-dimensional, linearized Fluid-Structure Interaction (FSI) coupling in which a light elastic structure is coupled to an inviscid, incompressible fluid in a straight channel. The structure is modeled as a single-degree-of-freedom oscillator with mass $m$ and stiffness $k$ (for example, the fundamental mode of a thin beam), while the fluid is modeled via an added-mass approximation that represents the inertia of the fluid accelerated by the structure. The coupling is performed by a partitioned, explicit Dirichlet-Neumann algorithm where the structure is advanced using fluid loads lagged by one time step. The purpose is to establish a Courant-Friedrichs-Lewy (CFL) type stability limit on the time step $\\Delta t$ in terms of $m$, the fluid density $\\rho_f$, and geometry via the added mass, and to validate the limit on a beam-in-channel surrogate.\n\nFundamental base:\n- Newton’s second law for the structure: $m \\ddot{x}(t) + k x(t) = f_f(t)$ with $x(t)$ the structural displacement at the fluid-structure interface and $f_f(t)$ the fluid traction resultant.\n- Added-mass approximation for an inviscid, incompressible fluid in a straight channel: the net fluid force equals $f_f(t) = - m_a \\ddot{x}(t)$, where the added mass $m_a$ depends on fluid density and geometry. For a straight channel of length $L_c$, channel gap height $h$, and out-of-plane width $b$, a plug-flow added-mass estimate is $m_a = \\alpha \\rho_f A L_c$ with $A = b h$ and $\\alpha$ a dimensionless coefficient of order unity representing mode-shape and flow-distribution effects. Use $\\alpha = 1$ in what follows.\n\nExplicit partitioned coupling assumption:\n- In the discrete scheme, the structural acceleration at time level $n$ uses a fluid force evaluated from the previous acceleration, i.e., $f_f^n \\approx - m_a \\ddot{x}^{n-1}$.\n\nDiscretization:\n- Use the centered-difference update for the structure,\n$$\nx^{n+1} = 2 x^n - x^{n-1} + \\Delta t^2 a^n,\n$$\nwith $a^n$ the structural acceleration at time $n$ computed from the explicit coupling described above.\n\nTasks:\n1. Derive, from the given fundamental base and assumptions, a linear homogeneous recurrence (amplification equation) for the discrete dynamics that depends on $m$, $k$, $m_a$, and $\\Delta t$. From this, determine a necessary and sufficient stability condition expressed as a CFL-like inequality of the form $\\Delta t \\le C(m,\\rho_f,b,h,L_c,k)$, and identify conditions under which no choice of $\\Delta t$ yields stability. You must not use any pre-derived formulas other than the fundamental statements above.\n2. Specialize $m_a$ to the beam-in-channel surrogate with $m_a = \\rho_f b h L_c$ (i.e., $\\alpha = 1$) and $A = b h$. Express your stability result explicitly in terms of $m$, $k$, $\\rho_f$, $b$, $h$, and $L_c$. All times must be expressed in seconds, masses in kilograms, stiffness in newtons per meter, lengths in meters, and densities in kilograms per cubic meter.\n3. Implement a program that, for a given set of test cases, computes:\n   - The predicted critical time step $\\Delta t_{\\mathrm{crit}}$ from your derived CFL-like stability condition. If your analysis indicates that the scheme is unstable for all $\\Delta t$, then set $\\Delta t_{\\mathrm{crit}} = 0$.\n   - The spectral radius of the one-step amplification operator for two tested time steps: a “small” time step $\\Delta t_{\\mathrm{small}}$ and a “large” time step $\\Delta t_{\\mathrm{large}}$. If $\\Delta t_{\\mathrm{crit}}  0$, choose $\\Delta t_{\\mathrm{small}} = 0.5 \\Delta t_{\\mathrm{crit}}$ and $\\Delta t_{\\mathrm{large}} = 1.5 \\Delta t_{\\mathrm{crit}}$. If $\\Delta t_{\\mathrm{crit}} = 0$, use $\\Delta t_{\\mathrm{small}} = 0.1 / \\omega_0$ and $\\Delta t_{\\mathrm{large}} = 0.2 / \\omega_0$, where $\\omega_0 = \\sqrt{k/m}$ in radians per second.\n   - A boolean classification of stability at each tested time step by checking whether the spectral radius is less than or equal to $1$ (considering numerical roundoff).\n4. For each test case, compare the observed stability against your prediction: if $\\Delta t_{\\mathrm{crit}}  0$, then the “small” time step should be stable and the “large” time step should be unstable; if $\\Delta t_{\\mathrm{crit}} = 0$, then both tested time steps should be unstable. Record, for each test case, two booleans indicating whether the observations match the prediction at the small and the large time steps, respectively.\n\nTest suite:\nUse the following structurally and geometrically consistent cases, all in International System of Units, with $\\alpha = 1$:\n- Case $1$ (happy path): $m = 1$, $k = 1000$, $\\rho_f = 1000$, $b = 0.02$, $h = 0.025$, $L_c = 1.0$.\n- Case $2$ (boundary, light structure): $m = 1$, $k = 1000$, $\\rho_f = 1000$, $b = 0.02$, $h = 0.025$, $L_c = 1.98$.\n- Case $3$ (heavy added mass, instability expected): $m = 1$, $k = 1000$, $\\rho_f = 1000$, $b = 0.02$, $h = 0.025$, $L_c = 4.0$.\n- Case $4$ (nearly uncoupled fluid): $m = 1$, $k = 1000$, $\\rho_f = 10^{-6}$, $b = 0.02$, $h = 0.025$, $L_c = 1.0$.\n\nAll quantities are given in kilograms, meters, seconds, and newtons per meter. Your program must output a single line containing a list of booleans with two entries per test case in the order listed above, corresponding to the correctness of the “small” and “large” time step stability predictions. For example, the output format must be exactly of the form\n$[b_1,b_2,\\ldots,b_8]$\nwith each $b_i$ equal to either True or False and no additional text. The results must be printed as a comma-separated list enclosed in square brackets.",
            "solution": "Begin with the structure governed by Newton’s second law,\n$$\nm \\ddot{x}(t) + k x(t) = f_f(t).\n$$\nUnder the added-mass approximation for an inviscid, incompressible fluid accelerated coherently with the interface motion, the net fluid force can be modeled as\n$$\nf_f(t) = - m_a \\ddot{x}(t),\n$$\nwhere $m_a$ is the added mass. The exact continuous coupled dynamics then reduce to\n$$\n\\left(m + m_a \\right) \\ddot{x}(t) + k x(t) = 0.\n$$\nIn an explicit partitioned algorithm of Dirichlet-Neumann type, the fluid traction used to advance the structure at time level $n$ is evaluated using lagged kinematics (or equivalently lagged accelerations in the added-mass model), yielding the discrete approximation\n$$\nf_f^n = - m_a \\ddot{x}^{n-1}.\n$$\nDiscretize the structure with the centered-difference update\n$$\nx^{n+1} = 2 x^n - x^{n-1} + \\Delta t^2 a^n,\n$$\nwith the acceleration at time $n$ given by\n$$\na^n = \\frac{- k x^n - m_a a^{n-1}}{m}.\n$$\nTo perform a linear stability (von Neumann) analysis, seek solutions of the homogeneous recurrence in the form $x^n = X z^n$ and $a^n = A z^n$ for a complex amplification factor $z$. The discrete acceleration relation becomes\n$$\nm A z^n + k X z^n + m_a A z^{n-1} = 0 \\quad \\Rightarrow \\quad (m z + m_a) A + k z X = 0,\n$$\nand the centered update gives\n$$\nX z^{n+1} = 2 X z^n - X z^{n-1} + \\Delta t^2 \\left( - \\frac{k}{m} X z^n - \\frac{m_a}{m} A z^{n-1} \\right).\n$$\nDivide by $z^{n-1}$, rearrange, and eliminate $A$ via $A = - \\dfrac{k z}{m z + m_a} X$ to obtain the scalar characteristic polynomial in $z$:\n$$\n(z + \\gamma) (z - 1)^2 + \\lambda z^2 = 0,\n$$\nwhere $\\gamma = \\dfrac{m_a}{m}$ and $\\lambda = \\Delta t^2 \\dfrac{k}{m} = \\Delta t^2 \\, \\omega_0^2$ with $\\omega_0 = \\sqrt{\\dfrac{k}{m}}$ in radians per second. Expanding yields the cubic\n$$\nz^3 + \\left(-2 + \\gamma + \\lambda \\right) z^2 + \\left(1 - 2 \\gamma \\right) z + \\gamma = 0.\n$$\nStability of the time-marching scheme requires that all roots satisfy $|z| \\le 1$. The boundary of stability is identified by a root crossing the unit circle. Evaluating the polynomial at $z = -1$,\n$$\nP(-1) = (-1 + \\gamma) (-2)^2 + \\lambda (1) = 4 (\\gamma - 1) + \\lambda.\n$$\nA change of sign at $z = -1$ indicates a crossing there. Setting $P(-1) = 0$ gives the critical value\n$$\n\\lambda_{\\mathrm{crit}} = 4 (1 - \\gamma).\n$$\nTherefore, when $\\gamma  1$ (that is, $m  m_a$), the maximum stable time step is\n$$\n\\Delta t_{\\mathrm{crit}} = \\frac{2}{\\omega_0} \\sqrt{1 - \\gamma} = 2 \\sqrt{\\frac{m - m_a}{k}}.\n$$\nWhen $\\gamma \\ge 1$ (that is, $m \\le m_a$), we have $\\lambda_{\\mathrm{crit}} \\le 0$, meaning the polynomial has a root with $z = -\\gamma$ at $\\Delta t = 0$, which lies outside the unit circle for $\\gamma  1$ (indeed, for $\\Delta t = 0$, the roots are $z = 1$ (double) and $z = -\\gamma$). Consequently, for $\\gamma \\ge 1$, the explicit partitioned scheme is unstable for all $\\Delta t$. This recovers the well-known added-mass instability of explicit Dirichlet-Neumann coupling for light structures.\n\nMapping to the beam-in-channel surrogate, take\n$$\nm_a = \\alpha \\, \\rho_f \\, A \\, L_c = \\rho_f \\, b \\, h \\, L_c,\n$$\nusing $\\alpha = 1$ and $A = b h$. Substituting into the stability limit yields the CFL-like condition\n$$\n\\Delta t \\le C(m,\\rho_f,b,h,L_c,k) := 2 \\sqrt{\\frac{m - \\rho_f b h L_c}{k}},\n$$\nvalid only if $m  \\rho_f b h L_c$; otherwise, the method is unstable for any $\\Delta t$.\n\nValidation methodology:\n- Use the amplification polynomial\n$$\nz^3 + \\left(-2 + \\gamma + \\lambda \\right) z^2 + \\left(1 - 2 \\gamma \\right) z + \\gamma = 0,\n$$\nwith $\\gamma = \\dfrac{m_a}{m}$ and $\\lambda = \\Delta t^2 \\dfrac{k}{m}$, and compute its roots numerically for selected $\\Delta t$. The spectral radius $\\rho = \\max_i |z_i|$ determines stability: stable if $\\rho \\le 1$, unstable otherwise.\n- For cases with $\\Delta t_{\\mathrm{crit}}  0$, test $\\Delta t_{\\mathrm{small}} = 0.5 \\Delta t_{\\mathrm{crit}}$ (predicted stable) and $\\Delta t_{\\mathrm{large}} = 1.5 \\Delta t_{\\mathrm{crit}}$ (predicted unstable).\n- For cases with $\\Delta t_{\\mathrm{crit}} = 0$, test $\\Delta t_{\\mathrm{small}} = 0.1 / \\omega_0$ and $\\Delta t_{\\mathrm{large}} = 0.2 / \\omega_0$ (both predicted unstable).\n\nTest suite parameters:\n- Case $1$: $m = 1$, $k = 1000$, $\\rho_f = 1000$, $b = 0.02$, $h = 0.025$, $L_c = 1.0$ gives $m_a = 0.5$ and $\\gamma = 0.5$, hence $\\Delta t_{\\mathrm{crit}} = 2 \\sqrt{(1 - 0.5)/1000}$ in seconds.\n- Case $2$: $m = 1$, $k = 1000$, $\\rho_f = 1000$, $b = 0.02$, $h = 0.025$, $L_c = 1.98$ gives $m_a = 0.99$ and $\\gamma = 0.99$, yielding a small but positive $\\Delta t_{\\mathrm{crit}}$ in seconds.\n- Case $3$: $m = 1$, $k = 1000$, $\\rho_f = 1000$, $b = 0.02$, $h = 0.025$, $L_c = 4.0$ gives $m_a = 2.0$ and $\\gamma = 2.0$, which is unstable for all $\\Delta t$.\n- Case $4$: $m = 1$, $k = 1000$, $\\rho_f = 10^{-6}$, $b = 0.02$, $h = 0.025$, $L_c = 1.0$ yields $m_a \\approx 5 \\times 10^{-10}$, i.e., nearly uncoupled, with $\\Delta t_{\\mathrm{crit}}$ close to the central-difference limit $2/\\omega_0$ in seconds.\n\nThe program should compute the predicted $\\Delta t_{\\mathrm{crit}}$ and the observed stability at the two prescribed time steps via the spectral radius, and output a single line with booleans reflecting whether observations match predictions for the “small” and “large” time steps, two booleans per case, in the order of the cases listed. The final output must be a single line, a comma-separated list enclosed in square brackets, with no extra text.",
            "answer": "```python\n# Execution environment:\n# - Python 3.12\n# - numpy 1.23.5\n# - scipy 1.11.4 (not used)\nimport numpy as np\n\ndef amplification_poly_coeffs(gamma: float, lam: float):\n    \"\"\"\n    Construct coefficients of the amplification polynomial:\n        z^3 + (-2 + gamma + lam) z^2 + (1 - 2 gamma) z + gamma = 0\n    where gamma = m_a / m, lam = dt^2 * k / m.\n    Returns coefficients [1, a2, a1, a0].\n    \"\"\"\n    a3 = 1.0\n    a2 = -2.0 + gamma + lam\n    a1 = 1.0 - 2.0 * gamma\n    a0 = gamma\n    return np.array([a3, a2, a1, a0], dtype=float)\n\ndef spectral_radius(gamma: float, lam: float) - float:\n    \"\"\"\n    Compute the spectral radius (max |z|) of the amplification polynomial\n    for given gamma and lambda.\n    \"\"\"\n    coeffs = amplification_poly_coeffs(gamma, lam)\n    roots = np.roots(coeffs)\n    return np.max(np.abs(roots))\n\ndef predicted_dt_crit(m: float, k: float, m_a: float) - float:\n    \"\"\"\n    CFL-like critical time step for explicit partitioned coupling derived:\n        dt_crit = 2 * sqrt((m - m_a) / k) if m  m_a\n        dt_crit = 0 otherwise (unstable for any dt)\n    \"\"\"\n    if m_a = m:\n        return 0.0\n    return 2.0 * np.sqrt((m - m_a) / k)\n\ndef run_case(m: float, k: float, rho_f: float, b: float, h: float, Lc: float):\n    \"\"\"\n    For given parameters (SI units), compute:\n    - m_a = rho_f * b * h * Lc\n    - gamma = m_a / m\n    - omega0 = sqrt(k/m)\n    - dt_crit predicted\n    - dt_small, dt_large according to problem statement\n    - spectral radius at dt_small and dt_large\n    - stability booleans (rho = 1 + tol)\n    - predicted booleans for small (True if dt_crit  0) and large (False if dt_crit  0; both False if dt_crit == 0)\n    Return booleans indicating whether observed stability matches predictions for small and large.\n    \"\"\"\n    m_a = rho_f * b * h * Lc\n    gamma = m_a / m if m  0 else np.inf\n    omega0 = np.sqrt(k / m)\n    dtcrit = predicted_dt_crit(m, k, m_a)\n\n    # Choose dt_small and dt_large\n    if dtcrit  0.0:\n        dt_small = 0.5 * dtcrit\n        dt_large = 1.5 * dtcrit\n    else:\n        # Unstable for all dt: pick two small fractions of structural period\n        dt_small = 0.1 / omega0\n        dt_large = 0.2 / omega0\n\n    # Compute lambda values\n    lam_small = (dt_small ** 2) * (k / m)\n    lam_large = (dt_large ** 2) * (k / m)\n\n    # Spectral radii\n    rho_small = spectral_radius(gamma, lam_small)\n    rho_large = spectral_radius(gamma, lam_large)\n\n    # Stability classification with a small tolerance\n    tol = 1e-10\n    stable_small = (rho_small = 1.0 + tol)\n    stable_large = (rho_large = 1.0 + tol)\n\n    # Predicted classifications\n    if dtcrit  0.0:\n        pred_small = True\n        pred_large = False\n    else:\n        pred_small = False\n        pred_large = False\n\n    return (stable_small == pred_small, stable_large == pred_large)\n\ndef solve():\n    # Define the test cases from the problem statement (SI units).\n    # Each case is a tuple: (m, k, rho_f, b, h, Lc)\n    test_cases = [\n        (1.0, 1000.0, 1000.0, 0.02, 0.025, 1.0),   # Case 1\n        (1.0, 1000.0, 1000.0, 0.02, 0.025, 1.98),  # Case 2\n        (1.0, 1000.0, 1000.0, 0.02, 0.025, 4.0),   # Case 3\n        (1.0, 1000.0, 1.0e-6, 0.02, 0.025, 1.0),   # Case 4\n    ]\n\n    results = []\n    for case in test_cases:\n        ok_small, ok_large = run_case(*case)\n        results.append(ok_small)\n        results.append(ok_large)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "Having identified the potential for instability in simple partitioned schemes, we now turn to advanced techniques designed to ensure robustness and efficiency. This practice () introduces the Interface Quasi-Newton with Inverse Least Squares (IQN-ILS) method, a powerful algorithm for accelerating the convergence of the FSI coupling iterations. By implementing the core logic of this method in a simplified linear setting, you will learn how to build an approximate inverse Jacobian and use it to predict the convergence rate, providing insight into the mechanics of modern, high-performance FSI solvers.",
            "id": "3566593",
            "problem": "Consider a linearized partitioned fluid-structure interaction setup at the interface, modeled as follows. Let $u \\in \\mathbb{R}^n$ denote the vector of interface displacements. The fluid subsystem returns interface traction $t \\in \\mathbb{R}^n$ according to the linear coupling operator $K \\in \\mathbb{R}^{n \\times n}$ via $t = K u$. The structure subsystem maps traction to displacement through the structural compliance operator $S \\in \\mathbb{R}^{n \\times n}$ via $u = S t$. In the linearized regime, the monolithic interface equation becomes $u = S K u$, and the classical partitioned fixed-point iteration seeks $u$ by repeatedly applying the map $\\Phi(u) = S K u$.\n\nDefine the residual $r(u) = u - \\Phi(u) = (I - S K) u$, where $I$ is the identity matrix of dimension $n$, and the Jacobian of the residual $J = \\frac{\\partial r}{\\partial u}$ equals $J = I - S K$ for the linear case. An interface quasi-Newton acceleration termed Interface Quasi-Newton with Inverse Least Squares (IQN-ILS) constructs an approximation $B \\approx J^{-1}$ to update $u$ by $u^{k+1} = u^k - B r(u^k)$. The reduced iteration matrix associated with one IQN-ILS update is $R = I - B J$. Convergence is predicted by the spectral radius $\\rho(R)$ of $R$, with $\\rho(R)  1$ indicating linear contraction.\n\nTo build $B$, IQN-ILS uses $m$ stored secant pairs derived from past iterates. In the linear case, for displacement differences $\\Delta u_i \\in \\mathbb{R}^n$ $(i = 1,\\dots,m)$, the corresponding residual differences are $\\Delta r_i = J \\Delta u_i$. Collect these in the matrices $S_m = [\\Delta u_1,\\dots,\\Delta u_m] \\in \\mathbb{R}^{n \\times m}$ and $Y_m = [\\Delta r_1,\\dots,\\Delta r_m] \\in \\mathbb{R}^{n \\times m}$. IQN-ILS with Tikhonov regularization uses a prior $B_0 = \\beta I$ with $\\beta \\in \\mathbb{R}$ and a regularization parameter $\\lambda  0$ to ensure numerical stability and inject prior information. The inverse least squares problem determines $B$ by minimizing the objective function $\\|B Y_m - S_m\\|_F^2 + \\lambda \\|B - B_0\\|_F^2$, where $\\|\\cdot\\|_F$ denotes the Frobenius norm.\n\nYour task is to implement a program that, for each test case described below, performs the following steps:\n1. Form $J = I - S K$.\n2. Construct $S_m$ by stacking the prescribed displacement differences as columns, and compute $Y_m = J S_m$.\n3. Compute $B$ by solving the inverse least squares problem with the given $\\lambda$ and $B_0 = \\beta I$.\n4. Form $R = I - B J$.\n5. Compute the spectral radius $\\rho(R)$ as the maximum modulus of the eigenvalues of $R$.\n\nNo physical units are involved; all quantities are dimensionless. Angles do not appear. The final answers must be floating-point numbers.\n\nTest Suite:\n- Case $1$ (general convergent case):\n  - Dimension $n = 3$.\n  - Structural compliance operator $S = \\mathrm{diag}(0.4, 0.3, 0.2)$.\n  - Coupling operator\n    $$\n    K = \\begin{bmatrix}\n    2.0  0.3  0.0 \\\\\n    0.3  1.5  0.2 \\\\\n    0.0  0.2  1.0\n    \\end{bmatrix}.\n    $$\n  - Secant displacement differences $m = 2$ with $\\Delta u_1 = [1,0,0]^\\top$, $\\Delta u_2 = [0,1,0]^\\top$ so that\n    $$\n    S_m = \\begin{bmatrix}\n    1  0 \\\\\n    0  1 \\\\\n    0  0\n    \\end{bmatrix}.\n    $$\n  - Regularization parameter $\\lambda = 0.05$.\n  - Prior scale $\\beta = 1.0$.\n\n- Case $2$ (near-boundary contraction):\n  - Dimension $n = 3$.\n  - Structural compliance operator $S = \\mathrm{diag}(0.9, 0.95, 1.0)$.\n  - Coupling operator $K = \\mathrm{diag}(1.05, 1.03, 0.999)$.\n  - Secant displacement differences $m = 3$ with $\\Delta u_1 = [1,0,0]^\\top$, $\\Delta u_2 = [0,1,0]^\\top$, $\\Delta u_3 = [0,0,1]^\\top$, so\n    $$\n    S_m = \\begin{bmatrix}\n    1  0  0 \\\\\n    0  1  0 \\\\\n    0  0  1\n    \\end{bmatrix}.\n    $$\n  - Regularization parameter $\\lambda = 0.01$.\n  - Prior scale $\\beta = 1.0$.\n\n- Case $3$ (base fixed-point divergent, quasi-Newton stabilization):\n  - Dimension $n = 3$.\n  - Structural compliance operator $S = \\mathrm{diag}(0.95, 0.6, 0.5)$.\n  - Coupling operator\n    $$\n    K = \\begin{bmatrix}\n    1.4  0.2  0.0 \\\\\n    0.2  2.0  0.1 \\\\\n    0.0  0.1  3.0\n    \\end{bmatrix}.\n    $$\n  - Secant displacement differences $m = 3$ with $\\Delta u_1 = [1,0,0]^\\top$, $\\Delta u_2 = [0,1,0]^\\top$, $\\Delta u_3 = [0,0,1]^\\top$, so\n    $$\n    S_m = \\begin{bmatrix}\n    1  0  0 \\\\\n    0  1  0 \\\\\n    0  0  1\n    \\end{bmatrix}.\n    $$\n  - Regularization parameter $\\lambda = 0.1$.\n  - Prior scale $\\beta = 1.0$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[r_1,r_2,r_3]$), where $r_i$ is the floating-point spectral radius $\\rho(R)$ for Case $i$ in the order given above.",
            "solution": "The problem statement has been rigorously validated and is determined to be valid. It is scientifically sound, self-contained, well-posed, and expressed in unambiguous mathematical terms. It presents a standard numerical exercise in the field of computational science and engineering, specifically concerning acceleration techniques for partitioned fluid-structure interaction solvers.\n\nThe task is to compute the spectral radius of the reduced iteration matrix for an Interface Quasi-Newton with Inverse Least Squares (IQN-ILS) scheme for three distinct test cases. The spectral radius, $\\rho(R)$, is a critical indicator of the convergence of the iterative method, with convergence assured if $\\rho(R)  1$.\n\nThe solution procedure is executed in five sequential steps for each test case, as prescribed:\n\n1.  **Formation of the Jacobian Matrix, $J$**: The monolithic interface equation for the displacement vector $u$ is $u = S K u$, where $S$ is the structural compliance operator and $K$ is the fluid coupling operator. The residual function is defined as $r(u) = u - S K u$. For this linear system, the Jacobian of the residual, $J = \\frac{\\partial r}{\\partial u}$, is constant and given by $J = I - S K$, where $I$ is the identity matrix of dimension $n$.\n\n2.  **Construction of Secant Data Matrices, $S_m$ and $Y_m$**: The IQN-ILS method constructs an approximation to the inverse Jacobian using a history of $m$ previous steps. These are stored as pairs of displacement differences $(\\Delta u_i)$ and corresponding residual differences $(\\Delta r_i)$. These vectors are collected into matrices $S_m = [\\Delta u_1, \\dots, \\Delta u_m]$ and $Y_m = [\\Delta r_1, \\dots, \\Delta r_m]$. For a linear problem, the relationship is direct: $\\Delta r_i = J \\Delta u_i$, which implies $Y_m = J S_m$.\n\n3.  **Computation of the Approximate Inverse Jacobian, $B$**: The core of the IQN-ILS method is the determination of the matrix $B \\approx J^{-1}$. This is formulated as a regularized inverse least-squares problem. The matrix $B$ is found by minimizing the objective function\n    $$\n    L(B) = \\|B Y_m - S_m\\|_F^2 + \\lambda \\|B - B_0\\|_F^2\n    $$\n    where $\\|\\cdot\\|_F$ is the Frobenius norm, $\\lambda  0$ is a Tikhonov regularization parameter, and $B_0 = \\beta I$ is a scaled identity matrix acting as a prior. To find the optimal $B$, we compute the gradient of $L(B)$ with respect to $B$ and set it to zero. The gradient is given by\n    $$\n    \\nabla_B L(B) = 2(B Y_m - S_m)Y_m^\\top + 2\\lambda(B - B_0)\n    $$\n    Setting $\\nabla_B L(B) = 0$ yields the normal equation for $B$:\n    $$\n    (B Y_m - S_m)Y_m^\\top + \\lambda(B - B_0) = 0\n    $$\n    Rearranging the terms to solve for $B$, we get:\n    $$\n    B Y_m Y_m^\\top - S_m Y_m^\\top + \\lambda B - \\lambda B_0 = 0\n    $$\n    $$\n    B (Y_m Y_m^\\top + \\lambda I) = S_m Y_m^\\top + \\lambda B_0\n    $$\n    This gives the unique analytical solution for $B$:\n    $$\n    B = (S_m Y_m^\\top + \\lambda B_0) (Y_m Y_m^\\top + \\lambda I)^{-1}\n    $$\n    The matrix $(Y_m Y_m^\\top + \\lambda I)$ is guaranteed to be invertible because $Y_m Y_m^\\top$ is symmetric positive semi-definite and $\\lambda  0$, making the sum symmetric positive definite.\n\n4.  **Formation of the Reduced Iteration Matrix, $R$**: The IQN-ILS update step is $u^{k+1} = u^k - B r(u^k)$. Substituting $r(u^k) = J u^k$ for the linear case relative to the solution $u=0$, the new iterate is $u^{k+1} = (I - B J) u^k$. The matrix $R = I - B J$ is therefore the reduced iteration matrix that governs the convergence of the method.\n\n5.  **Computation of the Spectral Radius, $\\rho(R)$**: The convergence of the iterative scheme is determined by the spectral radius of $R$, denoted $\\rho(R)$. The spectral radius is defined as the maximum of the moduli of the eigenvalues of $R$:\n    $$\n    \\rho(R) = \\max_i |\\lambda_i(R)|\n    $$\n    where $\\lambda_i(R)$ are the eigenvalues of $R$. The eigenvalues are computed numerically.\n\nThis systematic procedure is implemented for each of the three test cases provided, yielding the required spectral radii.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_rho(n, S, K, Sm, lambda_reg, beta):\n    \"\"\"\n    Calculates the spectral radius of the IQN-ILS reduced iteration matrix.\n\n    Args:\n        n (int): Dimension of the system.\n        S (np.ndarray): Structural compliance operator (n x n).\n        K (np.ndarray): Fluid coupling operator (n x n).\n        Sm (np.ndarray): Matrix of secant displacement differences (n x m).\n        lambda_reg (float): Tikhonov regularization parameter.\n        beta (float): Prior scaling factor.\n\n    Returns:\n        float: The spectral radius rho(R).\n    \"\"\"\n    # Define identity matrix\n    I = np.eye(n)\n\n    # Step 1: Form J = I - S K\n    J = I - S @ K\n\n    # Step 2: Construct Ym = J * Sm\n    Ym = J @ Sm\n\n    # Step 3: Compute B by solving the inverse least squares problem\n    # The prior is B0 = beta * I\n    B0 = beta * I\n    \n    # The analytical solution for B is B = (Sm * Ym^T + lambda * B0) * (Ym * Ym^T + lambda * I)^-1\n    # Let A1 = Sm * Ym^T + lambda * B0\n    A1 = Sm @ Ym.T + lambda_reg * B0\n    \n    # Let A2 = Ym * Ym^T + lambda * I\n    A2 = Ym @ Ym.T + lambda_reg * I\n    \n    # Compute B = A1 * A2^-1. Using np.linalg.inv is fine for small n.\n    # For larger systems, a linear solver would be more stable, e.g.,\n    # B = np.linalg.solve(A2.T, A1.T).T\n    B = A1 @ np.linalg.inv(A2)\n\n    # Step 4: Form R = I - B * J\n    R = I - B @ J\n\n    # Step 5: Compute the spectral radius rho(R)\n    eigenvalues = np.linalg.eigvals(R)\n    spectral_radius = np.max(np.abs(eigenvalues))\n    \n    return spectral_radius\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: general convergent case\n        {\n            \"n\": 3,\n            \"S\": np.diag([0.4, 0.3, 0.2]),\n            \"K\": np.array([\n                [2.0, 0.3, 0.0],\n                [0.3, 1.5, 0.2],\n                [0.0, 0.2, 1.0]\n            ]),\n            \"Sm\": np.array([\n                [1, 0],\n                [0, 1],\n                [0, 0]\n            ]),\n            \"lambda_reg\": 0.05,\n            \"beta\": 1.0,\n        },\n        # Case 2: near-boundary contraction\n        {\n            \"n\": 3,\n            \"S\": np.diag([0.9, 0.95, 1.0]),\n            \"K\": np.diag([1.05, 1.03, 0.999]),\n            \"Sm\": np.array([\n                [1, 0, 0],\n                [0, 1, 0],\n                [0, 0, 1]\n            ]),\n            \"lambda_reg\": 0.01,\n            \"beta\": 1.0,\n        },\n        # Case 3: base fixed-point divergent, quasi-Newton stabilization\n        {\n            \"n\": 3,\n            \"S\": np.diag([0.95, 0.6, 0.5]),\n            \"K\": np.array([\n                [1.4, 0.2, 0.0],\n                [0.2, 2.0, 0.1],\n                [0.0, 0.1, 3.0]\n            ]),\n            \"Sm\": np.array([\n                [1, 0, 0],\n                [0, 1, 0],\n                [0, 0, 1]\n            ]),\n            \"lambda_reg\": 0.1,\n            \"beta\": 1.0,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        # Main logic to calculate the spectral radius for one case.\n        rho = calculate_rho(\n            n=case[\"n\"],\n            S=case[\"S\"],\n            K=case[\"K\"],\n            Sm=case[\"Sm\"],\n            lambda_reg=case[\"lambda_reg\"],\n            beta=case[\"beta\"]\n        )\n        results.append(rho)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}