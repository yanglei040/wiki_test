{
    "hands_on_practices": [
        {
            "introduction": "Moving beyond linear examples, this first practice guides you through building a reduced-order model for a nonlinear hyperelastic solid undergoing large deformations. You will implement the full model reduction pipeline, from generating snapshots with a Newton-Raphson solver to constructing a Proper Orthogonal Decomposition (POD) basis. This exercise provides a crucial comparison between the standard Galerkin and the Least-Squares Petrov-Galerkin (LSPG) projection methods, evaluating their effectiveness in preserving the system's total potential energy—a key metric for physical fidelity. ",
            "id": "3591637",
            "problem": "You are asked to implement a complete, runnable program that constructs a projection-based reduced-order model for a nonlinear hyperelastic one-dimensional solid undergoing large deformations and compares standard Galerkin projection versus Least-Squares Petrov-Galerkin projection in terms of their ability to preserve the mechanical energy $E(u)$ across incremental load steps. The system, reduction approach, and comparison must be derived and implemented from first principles of computational solid mechanics and numerical approximation.\n\nThe physical model is a one-dimensional bar of length $L$ and constant cross-sectional area $A$, with the left end fixed and a prescribed axial force $P$ applied at the right end. The bar undergoes finite strain, and its constitutive behavior is hyperelastic. The equilibrium problem is quasi-static. You must work in the reference (material) configuration with coordinate $X \\in [0,L]$ and displacement field $u(X)$ mapping the material point to its current position $x(X) = X + u(X)$. The deformation gradient is $F(X) = \\dfrac{dx}{dX} = 1 + \\dfrac{du}{dX}$. The mechanical energy of interest is the total potential energy functional\n$$\nE(u) = \\int_0^L A\\, W(F(X))\\, dX - P\\, u(L),\n$$\nwhere $W(F)$ is the strain energy density per unit volume. Use the Green-Lagrange strain $E_{\\mathrm{GL}}(F) = \\dfrac{1}{2}(F^2 - 1)$ and define the strain energy density as\n$$\nW(F) = \\dfrac{1}{2}\\,E\\,E_{\\mathrm{GL}}(F)^2,\n$$\nwith $E$ the (effective) elastic modulus in pascals. The first Piola-Kirchhoff stress is $P_1(F) = \\dfrac{dW}{dF}$, and the consistent tangent is $H(F) = \\dfrac{dP_1}{dF}$. All quantities must be treated in the reference configuration. The units must be consistent with the International System of Units: length in meters (m), area in square meters (m$^2$), elastic modulus in pascals (Pa), force in newtons (N), and energy in joules (J). The energy $E(u)$ must be computed and reported in joules.\n\nDiscretize the bar with $N$ uniform two-node linear finite elements in the reference configuration. Enforce the left-end Dirichlet boundary condition $u(0)=0$ strongly by eliminating the corresponding degree of freedom. Use nodal unknowns $u_i$ at the mesh nodes. Derive the discrete residual vector and consistent tangent matrix from the stationary condition of the total potential energy. The discrete nonlinear system must be solved at each load step using Newton-Raphson with a consistent tangent and a simple backtracking line search if needed for robustness.\n\nConstruct a Proper Orthogonal Decomposition (POD) basis using the method of snapshots obtained from the full-order model (FOM) solutions across all load steps. Use the $L^2$ inner product weighted by the consistent mass matrix of the displacement field (i.e., the inner product $(v,w)_M = v^T M w$ with $M$ the consistent finite element mass matrix associated with the displacement shape functions and cross-sectional area $A$). Obtain a reduced basis of dimension $r$ that is $M$-orthonormal.\n\nForm two reduced-order models (ROMs) for the nonlinear equilibrium:\n- Standard Galerkin projection: Solve the reduced nonlinear system obtained by projecting the FOM residual onto the reduced space via the test space equal to the trial space and the $M$-orthonormal basis.\n- Least-Squares Petrov-Galerkin (LSPG) projection: Solve the reduced nonlinear system obtained by minimizing the $M$-weighted residual norm in the reduced coordinates, which leads to normal equations involving the Jacobian of the residual.\n\nFor both ROMs, perform the same sequence of load steps and compute the total potential energy $E(u)$ at each step using the ROM solution. Compare how well each ROM preserves the FOM mechanical energy across the load steps by computing the root-mean-square (RMS) relative energy deviation defined as\n$$\n\\varepsilon_{\\mathrm{RMS}} = \\dfrac{\\sqrt{\\dfrac{1}{K} \\sum_{k=1}^K \\left(E_{\\mathrm{ROM}}^{(k)} - E_{\\mathrm{FOM}}^{(k)}\\right)^2}}{\\dfrac{1}{K} \\sum_{k=1}^K \\left|E_{\\mathrm{FOM}}^{(k)}\\right|},\n$$\nwhere $K$ is the number of load steps, $E_{\\mathrm{FOM}}^{(k)}$ is the full-order energy at step $k$, and $E_{\\mathrm{ROM}}^{(k)}$ is the reduced energy for the method in question at step $k$. Report the RMS relative energy deviation for both standard Galerkin and Least-Squares Petrov-Galerkin.\n\nYour program must implement the following test suite of parameter sets, covering a typical case, a reduced basis size boundary case, a stronger nonlinearity case, and a coarser discretization case:\n\n- Case 1 (typical): $L = 1.0\\,\\mathrm{m}$, $A = 1.0\\times10^{-2}\\,\\mathrm{m}^2$, $E = 1.0\\times10^{6}\\,\\mathrm{Pa}$, $N = 30$, $K = 25$ load steps with forces linearly ramped from $0$ to $P_{\\max} = 1000\\,\\mathrm{N}$, reduced dimension $r=6$.\n- Case 2 (reduced basis boundary): Same as Case 1 but $r=1$.\n- Case 3 (stronger nonlinearity): Same as Case 1 but $P_{\\max} = 5000\\,\\mathrm{N}$, $r=6$.\n- Case 4 (coarser mesh): Same as Case 1 but $N = 8$, $r=6$.\n\nFor each case, compute and record two floating-point results: the RMS relative energy deviation for the standard Galerkin ROM and for the Least-Squares Petrov-Galerkin ROM. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order\n$$\n[\\varepsilon_{\\mathrm{G}}^{(1)}, \\varepsilon_{\\mathrm{LSPG}}^{(1)}, \\varepsilon_{\\mathrm{G}}^{(2)}, \\varepsilon_{\\mathrm{LSPG}}^{(2)}, \\varepsilon_{\\mathrm{G}}^{(3)}, \\varepsilon_{\\mathrm{LSPG}}^{(3)}, \\varepsilon_{\\mathrm{G}}^{(4)}, \\varepsilon_{\\mathrm{LSPG}}^{(4)}],\n$$\nwhere superscripts refer to the case number. Express all eight outputs as decimal floating-point numbers (dimensionless), and ensure they are computed from energies measured in joules.\n\nYou must provide a complete, runnable program with no user input or external files, as specified in the final answer section. The program must numerically approximate the continuous model and produce the required output. All mathematical entities in this problem statement must be written in LaTeX using $...$ or $$...$$ delimiters, and acronyms must be defined upon first usage (e.g., Proper Orthogonal Decomposition (POD), Least-Squares Petrov-Galerkin (LSPG)).",
            "solution": "We begin with the fundamental balance laws and definitions for a quasi-static hyperelastic solid. In the reference (material) configuration, static equilibrium can be stated in weak form by stationarity of the total potential energy. For a one-dimensional bar with displacement field $u(X)$, the deformation gradient is $F(X) = \\dfrac{dx}{dX} = 1 + \\dfrac{du}{dX}$. For a hyperelastic material, the strain energy density per unit volume is a function of $F$, denoted $W(F)$, and the first Piola-Kirchhoff stress is $P_1(F) = \\dfrac{dW}{dF}$. The total potential energy is\n$$\nE(u) = \\int_0^L A\\, W(F)\\, dX - P\\, u(L),\n$$\nwith $A$ the cross-sectional area and $P$ the applied axial force at the right end. The equilibrium configuration minimizes $E(u)$, and the necessary condition is that its first variation vanishes.\n\nWe adopt the Green-Lagrange strain $E_{\\mathrm{GL}}(F) = \\dfrac{1}{2}(F^2 - 1)$ and take the strain energy density\n$$\nW(F) = \\dfrac{1}{2}\\, E \\, E_{\\mathrm{GL}}(F)^2,\n$$\nwhere $E$ is an elastic modulus. This choice yields a nonlinear, but smooth, hyperelastic model capable of representing large deformations in one dimension. The associated first Piola-Kirchhoff stress is\n$$\nP_1(F) = \\dfrac{dW}{dF} \n= \\dfrac{d}{dF} \\left( \\dfrac{1}{2} E \\left(\\dfrac{1}{2}(F^2 - 1)\\right)^2 \\right)\n= \\dfrac{1}{2} E \\left( F^3 - F \\right),\n$$\nand the consistent tangent modulus is\n$$\nH(F) = \\dfrac{dP_1}{dF} = \\dfrac{1}{2} E \\left( 3 F^2 - 1 \\right).\n$$\n\nFor the finite element discretization, partition $[0,L]$ into $N$ uniform elements of size $h = \\dfrac{L}{N}$, with nodes $X_i = i h$, $i=0,\\dots,N$. Use linear shape functions on each element and nodal degrees of freedom $u_i$. Impose $u_0 = 0$ strongly, leaving $N$ free unknowns $u_1,\\dots,u_N$. On an element connecting nodes $i$ and $i+1$, the displacement is linear, so the gradient $\\dfrac{du}{dX}$ is constant: $\\dfrac{du}{dX} = \\dfrac{u_{i+1} - u_i}{h}$, and thus $F = 1 + \\dfrac{u_{i+1} - u_i}{h}$. The element contribution to the internal force vector for the two nodes follows from the first variation of $\\int A W(F)\\,dX$ and is\n$$\n\\mathbf{f}_{\\mathrm{int}}^{(e)} = A\\, P_1(F)\\, \\begin{bmatrix} -1 \\\\ 1 \\end{bmatrix},\n$$\nsince the sensitivity of $F$ to nodal displacements is $[\\partial F/\\partial u_i, \\partial F/\\partial u_{i+1}] = [-1/h, 1/h]$ and the element length is $h$. The consistent element tangent matrix is\n$$\n\\mathbf{K}^{(e)} = \\dfrac{A\\, H(F)}{h}\\, \\begin{bmatrix} 1 & -1 \\\\ -1 & 1 \\end{bmatrix}.\n$$\nAssemble these contributions to obtain the global internal force vector $\\mathbf{f}_{\\mathrm{int}}(\\mathbf{u})$ and global tangent matrix $\\mathbf{K}(\\mathbf{u})$. The external force vector is zero everywhere except at the right-end node $N$, where it is $P$. After enforcing $u_0=0$, extract the free-part residual\n$$\n\\mathbf{r}(\\mathbf{u}_f) = \\mathbf{f}_{\\mathrm{int},f}(\\mathbf{u}_f) - \\mathbf{f}_{\\mathrm{ext},f},\n$$\nand the free-part tangent $\\mathbf{K}_f(\\mathbf{u}_f)$, where $\\mathbf{u}_f = [u_1,\\dots,u_N]^T$ and the only nonzero component of $\\mathbf{f}_{\\mathrm{ext},f}$ is the last entry equal to $P$. Solve $\\mathbf{r}(\\mathbf{u}_f)=\\mathbf{0}$ at each load step with Newton-Raphson:\n$$\n\\mathbf{K}_f(\\mathbf{u}_f^{(m)})\\, \\Delta \\mathbf{u}_f^{(m)} = - \\mathbf{r}(\\mathbf{u}_f^{(m)}), \\quad \\mathbf{u}_f^{(m+1)} = \\mathbf{u}_f^{(m)} + \\alpha^{(m)} \\Delta \\mathbf{u}_f^{(m)},\n$$\nwhere $\\alpha^{(m)} \\in (0,1]$ is adjusted (backtracking) if needed to reduce the residual norm. The energy at a given load $P$ is computed as\n$$\nE(\\mathbf{u}_f) = \\sum_{e=1}^{N} A\\, h\\, W(F_e) - P\\, u_N,\n$$\nwith $F_e$ the deformation gradient on element $e$ and $u_N$ the displacement at the right end.\n\nFor Proper Orthogonal Decomposition (POD), collect the full-order displacement snapshots into a matrix $\\mathbf{S} \\in \\mathbb{R}^{n_f \\times K}$, where $n_f=N$ is the number of free degrees of freedom and $K$ the number of load steps. Define the consistent mass matrix $\\mathbf{M}$ for the displacement space (with unit density, since only a spatial weighting is required here) by assembling the element matrices\n$$\n\\mathbf{M}^{(e)} = A \\int_{X_i}^{X_{i+1}} \\begin{bmatrix} N_1 \\\\ N_2 \\end{bmatrix} \\begin{bmatrix} N_1 & N_2 \\end{bmatrix}\\, dX \n= A \\begin{bmatrix} \\dfrac{h}{3} & \\dfrac{h}{6} \\\\ \\dfrac{h}{6} & \\dfrac{h}{3} \\end{bmatrix}.\n$$\nExtract the free-part $\\mathbf{M}_f \\in \\mathbb{R}^{n_f \\times n_f}$. Compute the POD basis by solving the generalized eigenvalue problem for the snapshot covariance\n$$\n\\mathbf{C} = \\mathbf{S}^T \\mathbf{M}_f \\mathbf{S}, \\quad \\mathbf{C}\\,\\mathbf{w}_i = \\lambda_i\\, \\mathbf{w}_i,\n$$\nsorting eigenpairs by descending $\\lambda_i>0$, and forming $M$-orthonormal basis vectors\n$$\n\\mathbf{v}_i = \\dfrac{1}{\\sqrt{\\lambda_i}} \\mathbf{S}\\, \\mathbf{w}_i,\n$$\nwhich satisfy $\\mathbf{v}_i^T \\mathbf{M}_f \\mathbf{v}_j = \\delta_{ij}$. Stack the first $r$ basis vectors into $\\mathbf{V} \\in \\mathbb{R}^{n_f \\times r}$.\n\nFor the standard Galerkin reduced model, seek reduced coordinates $\\mathbf{a} \\in \\mathbb{R}^r$ such that the full displacement is approximated as $\\mathbf{u}_f \\approx \\mathbf{V}\\, \\mathbf{a}$ and the residual is orthogonal to the reduced space, yielding\n$$\n\\mathbf{V}^T\\, \\mathbf{r}(\\mathbf{V}\\mathbf{a}) = \\mathbf{0}.\n$$\nImplement Newton in reduced coordinates. The chain rule gives the reduced tangent \n$$\n\\mathbf{K}_r(\\mathbf{a}) = \\mathbf{V}^T\\, \\mathbf{K}_f(\\mathbf{V}\\mathbf{a})\\, \\mathbf{V},\n$$\nand the reduced Newton update is obtained by solving\n$$\n\\mathbf{K}_r(\\mathbf{a}^{(m)})\\, \\Delta \\mathbf{a}^{(m)} = - \\mathbf{V}^T\\, \\mathbf{r}(\\mathbf{V}\\mathbf{a}^{(m)}), \\quad \\mathbf{a}^{(m+1)} = \\mathbf{a}^{(m)} + \\alpha^{(m)} \\Delta \\mathbf{a}^{(m)}.\n$$\n\nFor the Least-Squares Petrov-Galerkin (LSPG) reduced model, minimize the $M$-weighted residual norm $\\|\\mathbf{r}(\\mathbf{V}\\mathbf{a})\\|_{\\mathbf{M}_f} = \\sqrt{\\mathbf{r}^T \\mathbf{M}_f \\mathbf{r}}$. The Gauss-Newton condition gives the normal equations\n$$\n\\left[ (\\mathbf{J}_r(\\mathbf{a}))^T \\mathbf{M}_f\\, \\mathbf{J}_r(\\mathbf{a}) \\right] \\Delta \\mathbf{a}\n= - (\\mathbf{J}_r(\\mathbf{a}))^T \\mathbf{M}_f\\, \\mathbf{r}(\\mathbf{V}\\mathbf{a}),\n$$\nwhere $\\mathbf{J}_r(\\mathbf{a}) = \\dfrac{\\partial \\mathbf{r}}{\\partial \\mathbf{u}_f}(\\mathbf{V}\\mathbf{a})\\, \\mathbf{V} = \\mathbf{K}_f(\\mathbf{V}\\mathbf{a})\\, \\mathbf{V}$. Update $\\mathbf{a}$ with backtracking if necessary to reduce the weighted residual norm.\n\nFor both ROMs, at each load step compute the reduced displacement $\\mathbf{u}_f^{\\mathrm{ROM}}$ and the corresponding energy $E_{\\mathrm{ROM}}$. Compare the reduced energies against the full-order energies $E_{\\mathrm{FOM}}$ by calculating the root-mean-square relative energy deviation across the $K$ steps:\n$$\n\\varepsilon_{\\mathrm{RMS}} = \\dfrac{\\sqrt{\\dfrac{1}{K} \\sum_{k=1}^K \\left(E_{\\mathrm{ROM}}^{(k)} - E_{\\mathrm{FOM}}^{(k)}\\right)^2}}{\\dfrac{1}{K} \\sum_{k=1}^K \\left|E_{\\mathrm{FOM}}^{(k)}\\right|}.\n$$\n\nAlgorithmic design for the program:\n- Define the mesh and assembly routines for internal force and tangent, using $P_1(F) = \\dfrac{1}{2}E(F^3 - F)$ and $H(F) = \\dfrac{1}{2}E(3F^2 - 1)$ on each element with $F = 1 + \\dfrac{u_{i+1}-u_i}{h}$.\n- Implement the full-order Newton solver over $K$ load steps ramping $P$ from $0$ to $P_{\\max}$, with initial guess $\\mathbf{u}_f=\\mathbf{0}$ and warm-starting from the previous step. Include a small diagonal regularization and simple backtracking on the update to improve robustness.\n- Assemble the consistent mass matrix $\\mathbf{M}_f$ for the displacement space using the prescribed element formula, and compute the mass-weighted POD basis $\\mathbf{V}$ of dimension $r$ from the full-order snapshots.\n- Implement the Galerkin ROM Newton solver and the LSPG ROM Gauss-Newton solver across the same load steps, initializing the reduced coordinates by mass-weighted projection $\\mathbf{a}_0 = \\mathbf{V}^T \\mathbf{M}_f \\mathbf{u}_f^{\\text{prev}}$.\n- Compute energies in joules at each step for FOM and each ROM. Compute the RMS relative energy deviations for both ROMs per case.\n- Execute the four cases specified in the problem statement and output the eight resulting floating-point values as a single comma-separated list enclosed in square brackets.\n\nAll computations are performed in SI units: $L$ in meters, $A$ in square meters, $E$ in pascals, forces in newtons, and energies $E(u)$ in joules. The final printed outputs are dimensionless decimals that quantify the energy preservation performance of the reduced models relative to the full model across the load steps.\n\nThis approach integrates the core principles of hyperelasticity, variational formulation of equilibrium, finite element discretization, Proper Orthogonal Decomposition (POD), standard Galerkin projection, and Least-Squares Petrov-Galerkin (LSPG), to produce a scientifically sound and algorithmically clear comparison focused on preservation of mechanical energy $E(u)$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef assemble_internal_and_tangent(u_free, L, A, E_mod, N, P_ext):\n    \"\"\"\n    Assemble internal force vector and tangent stiffness for the free dofs.\n    u_free: array of length N (nodes 1..N), with u0 = 0 fixed.\n    Returns residual r (size N), tangent K_ff (NxN), and energy computation utility can be separate.\n    \"\"\"\n    h = L / N\n    n_nodes = N + 1\n    # Full displacement including fixed left node\n    u_full = np.zeros(n_nodes)\n    u_full[1:] = u_free\n\n    f_full = np.zeros(n_nodes)\n    K_full = np.zeros((n_nodes, n_nodes))\n\n    # Loop over elements\n    for e in range(N):\n        i = e\n        j = e + 1\n        ui = u_full[i]\n        uj = u_full[j]\n        du_dx = (uj - ui) / h\n        F = 1.0 + du_dx\n        # First Piola stress and tangent for the chosen hyperelastic model\n        Pstress = 0.5 * E_mod * (F**3 - F)\n        Htan = 0.5 * E_mod * (3.0 * F**2 - 1.0)\n        # Element internal force contribution\n        f_e = A * Pstress * np.array([-1.0, 1.0])\n        f_full[i] += f_e[0]\n        f_full[j] += f_e[1]\n        # Element tangent contribution\n        Ke = (A * Htan / h) * np.array([[1.0, -1.0], [-1.0, 1.0]])\n        K_full[i:i+2, i:i+2] += Ke\n\n    # Extract free part\n    r = f_full[1:].copy()\n    # External force applied at the right end node N (index N in full, index N-1 in free)\n    r[-1] -= P_ext\n    K_ff = K_full[1:, 1:]\n    return r, K_ff\n\ndef compute_energy(u_free, L, A, E_mod, N, P_ext):\n    \"\"\"\n    Compute total potential energy E(u) = sum_e A*h*W(F_e) - P_ext * u(L).\n    \"\"\"\n    h = L / N\n    n_nodes = N + 1\n    u_full = np.zeros(n_nodes)\n    u_full[1:] = u_free\n    U_int = 0.0\n    for e in range(N):\n        i = e\n        j = e + 1\n        ui = u_full[i]\n        uj = u_full[j]\n        du_dx = (uj - ui) / h\n        F = 1.0 + du_dx\n        EGL = 0.5 * (F**2 - 1.0)\n        W = 0.5 * E_mod * (EGL**2)\n        U_int += A * h * W\n    U_ext = P_ext * u_full[-1]\n    E_total = U_int - U_ext\n    return E_total\n\ndef newton_fom(L, A, E_mod, N, P_values, tol=1e-10, max_iter=60):\n    \"\"\"\n    Full-order model Newton solve across load steps.\n    Returns snapshots matrix S (N x K), energies list E_fom (length K).\n    \"\"\"\n    n_free = N\n    K_steps = len(P_values)\n    S = np.zeros((n_free, K_steps))\n    E_fom = []\n    u_free = np.zeros(n_free)\n    # Solve for each load step\n    for k, Pk in enumerate(P_values):\n        # Warm start from previous step\n        # Newton iterations\n        for it in range(max_iter):\n            r, K = assemble_internal_and_tangent(u_free, L, A, E_mod, N, Pk)\n            rn = np.linalg.norm(r)\n            if rn < tol:\n                break\n            # Regularization\n            reg = 1e-12\n            K_reg = K + reg * np.eye(n_free)\n            try:\n                du = np.linalg.solve(K_reg, -r)\n            except np.linalg.LinAlgError:\n                # Fallback: add stronger regularization\n                K_reg = K + 1e-8 * np.eye(n_free)\n                du = np.linalg.solve(K_reg, -r)\n            # Backtracking line search on residual norm\n            alpha = 1.0\n            u_trial = u_free + alpha * du\n            r_trial, _ = assemble_internal_and_tangent(u_trial, L, A, E_mod, N, Pk)\n            rn_trial = np.linalg.norm(r_trial)\n            bt_count = 0\n            while rn_trial > rn and bt_count < 10:\n                alpha *= 0.5\n                u_trial = u_free + alpha * du\n                r_trial, _ = assemble_internal_and_tangent(u_trial, L, A, E_mod, N, Pk)\n                rn_trial = np.linalg.norm(r_trial)\n                bt_count += 1\n            u_free = u_trial\n        # Save snapshot and energy\n        S[:, k] = u_free\n        E_fom.append(compute_energy(u_free, L, A, E_mod, N, Pk))\n    return S, np.array(E_fom)\n\ndef assemble_mass_matrix(L, A, N):\n    \"\"\"\n    Assemble consistent mass matrix M for displacement space (unit density weighting).\n    Returns free-part M_ff of size N x N.\n    \"\"\"\n    h = L / N\n    n_nodes = N + 1\n    M_full = np.zeros((n_nodes, n_nodes))\n    Me = A * np.array([[h/3.0, h/6.0],\n                       [h/6.0, h/3.0]])\n    for e in range(N):\n        i = e\n        j = e + 1\n        M_full[i:i+2, i:i+2] += Me\n    M_ff = M_full[1:, 1:]\n    return M_ff\n\ndef pod_mass_weighted(S, M_ff, r_dim, eig_tol=1e-14):\n    \"\"\"\n    Compute mass-weighted POD basis V (n_free x r_dim) with V^T M_ff V = I.\n    \"\"\"\n    # Covariance\n    C = S.T @ M_ff @ S\n    # Symmetric eigen-decomposition\n    evals, evecs = np.linalg.eigh(C)\n    # Sort descending\n    idx = np.argsort(evals)[::-1]\n    evals = evals[idx]\n    evecs = evecs[:, idx]\n    # Filter positive eigenvalues\n    pos = evals > eig_tol\n    evals = evals[pos]\n    evecs = evecs[:, pos]\n    r_eff = min(r_dim, evecs.shape[1])\n    if r_eff == 0:\n        # No variance; return zeros basis (should not happen with nontrivial snapshots)\n        return np.zeros((S.shape[0], 0))\n    evecs_r = evecs[:, :r_eff]\n    evals_r = evals[:r_eff]\n    # Build basis vectors: v_i = 1/sqrt(lambda_i) * S w_i\n    V = S @ (evecs_r / np.sqrt(evals_r))\n    return V\n\ndef project_initial(V, M_ff, u_free):\n    \"\"\"\n    Mass-weighted projection of full displacement onto reduced coordinates: a0 = V^T M u.\n    Assumes V^T M V = I.\n    \"\"\"\n    return V.T @ (M_ff @ u_free)\n\ndef rom_galerkin(L, A, E_mod, N, P_values, V, M_ff, tol=1e-10, max_iter=60):\n    \"\"\"\n    Standard Galerkin ROM solve across load steps.\n    Returns reduced energies list E_rom (length K).\n    \"\"\"\n    K_steps = len(P_values)\n    n_free = N\n    r = V.shape[1]\n    a = np.zeros(r)\n    E_rom = []\n    u_free_prev = np.zeros(n_free)\n    for k, Pk in enumerate(P_values):\n        # Warm start from projection of previous FOM/ROM solution\n        a = project_initial(V, M_ff, u_free_prev)\n        # Newton in reduced coordinates\n        for it in range(max_iter):\n            u = V @ a\n            r_full, K_full = assemble_internal_and_tangent(u, L, A, E_mod, N, Pk)\n            r_red = V.T @ r_full\n            rn = np.linalg.norm(r_red)\n            if rn < tol:\n                break\n            K_red = V.T @ (K_full @ V)\n            # Regularization\n            reg = 1e-12\n            K_red_reg = K_red + reg * np.eye(r)\n            try:\n                da = np.linalg.solve(K_red_reg, -r_red)\n            except np.linalg.LinAlgError:\n                K_red_reg = K_red + 1e-8 * np.eye(r)\n                da = np.linalg.solve(K_red_reg, -r_red)\n            # Backtracking on full residual norm\n            alpha = 1.0\n            a_trial = a + alpha * da\n            u_trial = V @ a_trial\n            r_trial, _ = assemble_internal_and_tangent(u_trial, L, A, E_mod, N, Pk)\n            rn_trial = np.linalg.norm(r_trial)\n            rn_full = np.linalg.norm(r_full)\n            bt_count = 0\n            while rn_trial > rn_full and bt_count < 10:\n                alpha *= 0.5\n                a_trial = a + alpha * da\n                u_trial = V @ a_trial\n                r_trial, _ = assemble_internal_and_tangent(u_trial, L, A, E_mod, N, Pk)\n                rn_trial = np.linalg.norm(r_trial)\n                bt_count += 1\n            a = a_trial\n        u_sol = V @ a\n        E_rom.append(compute_energy(u_sol, L, A, E_mod, N, Pk))\n        u_free_prev = u_sol\n    return np.array(E_rom)\n\ndef rom_lspg(L, A, E_mod, N, P_values, V, M_ff, tol=1e-10, max_iter=60):\n    \"\"\"\n    Least-Squares Petrov-Galerkin ROM solve across load steps using Gauss-Newton normal equations.\n    Returns reduced energies list E_rom (length K).\n    \"\"\"\n    K_steps = len(P_values)\n    n_free = N\n    r = V.shape[1]\n    a = np.zeros(r)\n    E_rom = []\n    u_free_prev = np.zeros(n_free)\n    for k, Pk in enumerate(P_values):\n        # Warm start\n        a = project_initial(V, M_ff, u_free_prev)\n        for it in range(max_iter):\n            u = V @ a\n            r_full, K_full = assemble_internal_and_tangent(u, L, A, E_mod, N, Pk)\n            J_r = K_full @ V  # Jacobian of residual wrt reduced coords\n            # Normal equations: (J^T M J) da = - J^T M r\n            A_mat = J_r.T @ (M_ff @ J_r)\n            b_vec = J_r.T @ (M_ff @ r_full)\n            # Solve for increment\n            reg = 1e-12\n            A_reg = A_mat + reg * np.eye(r)\n            try:\n                da = -np.linalg.solve(A_reg, b_vec)\n            except np.linalg.LinAlgError:\n                A_reg = A_mat + 1e-8 * np.eye(r)\n                da = -np.linalg.solve(A_reg, b_vec)\n            # Backtracking on weighted residual norm\n            alpha = 1.0\n            r_weighted_norm = np.sqrt(r_full.T @ (M_ff @ r_full))\n            a_trial = a + alpha * da\n            u_trial = V @ a_trial\n            r_trial, _ = assemble_internal_and_tangent(u_trial, L, A, E_mod, N, Pk)\n            r_trial_weighted_norm = np.sqrt(r_trial.T @ (M_ff @ r_trial))\n            bt_count = 0\n            while r_trial_weighted_norm > r_weighted_norm and bt_count < 10:\n                alpha *= 0.5\n                a_trial = a + alpha * da\n                u_trial = V @ a_trial\n                r_trial, _ = assemble_internal_and_tangent(u_trial, L, A, E_mod, N, Pk)\n                r_trial_weighted_norm = np.sqrt(r_trial.T @ (M_ff @ r_trial))\n                bt_count += 1\n            a = a_trial\n            # Convergence check on weighted residual norm\n            if r_trial_weighted_norm < tol:\n                break\n        u_sol = V @ a\n        E_rom.append(compute_energy(u_sol, L, A, E_mod, N, Pk))\n        u_free_prev = u_sol\n    return np.array(E_rom)\n\ndef rms_relative_energy_error(E_rom, E_fom, tiny=1e-16):\n    \"\"\"\n    Compute RMS relative energy deviation as specified.\n    \"\"\"\n    K = len(E_fom)\n    num = np.sqrt(np.mean((E_rom - E_fom)**2))\n    den = np.mean(np.abs(E_fom))\n    if den < tiny:\n        return float('nan')\n    return num / den\n\ndef run_case(L, A, E_mod, N, K_steps, P_max, r_dim):\n    # Load steps\n    P_values = np.linspace(0.0, P_max, K_steps)\n    # Full-order\n    S, E_fom = newton_fom(L, A, E_mod, N, P_values)\n    # Mass matrix for POD\n    M_ff = assemble_mass_matrix(L, A, N)\n    # POD basis\n    V = pod_mass_weighted(S, M_ff, r_dim)\n    # Galerkin ROM\n    E_g = rom_galerkin(L, A, E_mod, N, P_values, V, M_ff)\n    # LSPG ROM\n    E_lspg = rom_lspg(L, A, E_mod, N, P_values, V, M_ff)\n    # Errors\n    err_g = rms_relative_energy_error(E_g, E_fom)\n    err_l = rms_relative_energy_error(E_lspg, E_fom)\n    return err_g, err_l\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (L, A, E_mod, N, K_steps, P_max, r_dim)\n        (1.0, 1.0e-2, 1.0e6, 30, 25, 1000.0, 6),  # Case 1\n        (1.0, 1.0e-2, 1.0e6, 30, 25, 1000.0, 1),  # Case 2\n        (1.0, 1.0e-2, 1.0e6, 30, 25, 5000.0, 6),  # Case 3\n        (1.0, 1.0e-2, 1.0e6, 8,  25, 1000.0, 6),  # Case 4\n    ]\n\n    results = []\n    for case in test_cases:\n        L, A, E_mod, N, K_steps, P_max, r_dim = case\n        err_g, err_l = run_case(L, A, E_mod, N, K_steps, P_max, r_dim)\n        results.append(err_g)\n        results.append(err_l)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "After learning to build a reduced model, a practitioner must ask: how accurate is it, and how can it be made more efficient? This theoretical exercise shifts focus from implementation to analysis, guiding you through the fundamental principles of error estimation and cost optimization for hyper-reduced models. By decomposing the total error into projection and hyper-reduction components and modeling their respective costs, you will devise a strategy to optimally allocate computational resources to meet a desired accuracy target. ",
            "id": "3591661",
            "problem": "Consider a quasi-static nonlinear finite element model of hyperelasticity in which the full-order model (FOM) seeks $u^\\star \\in \\mathbb{R}^N$ satisfying the equilibrium equation $R(u;\\mu) = f_{\\mathrm{ext}}(\\mu) - f_{\\mathrm{int}}(u;\\mu) = 0$ for a given parameter $\\mu$. Assume the internal force $f_{\\mathrm{int}}(\\,\\cdot\\,;\\mu)$ is Gateaux differentiable and its Jacobian (the consistent tangent) $K(u;\\mu) = \\partial f_{\\mathrm{int}}/\\partial u$ is uniformly strongly monotone and Lipschitz continuous in a neighborhood of $u^\\star$, i.e., there exist constants $\\alpha > 0$ and $L > 0$ such that, for all $u,v$ in that neighborhood, $(K(w;\\mu)\\xi,\\xi) \\ge \\alpha \\|\\xi\\|_2^2$ for all $\\xi$ and $\\|K(u;\\mu) - K(v;\\mu)\\|_2 \\le L \\|u-v\\|_2$ for all $u,v,w$ on the segment between $u$ and $v$. A Proper Orthogonal Decomposition (POD) reduced basis $V_r \\in \\mathbb{R}^{N\\times r}$ with orthonormal columns (in the Euclidean inner product induced by mass lumping) is constructed from displacement snapshots, and a Discrete Empirical Interpolation Method (DEIM) basis $U_m \\in \\mathbb{R}^{N\\times m}$ with sampling matrix $P \\in \\mathbb{R}^{N\\times m}$ is constructed from internal force snapshots. The DEIM approximation is $f_{\\mathrm{int}}^m(u;\\mu) = U_m (P^T U_m)^{-1} P^T f_{\\mathrm{int}}(u;\\mu)$. The hyper-reduced reduced-order model (ROM) computes $a_m(\\mu) \\in \\mathbb{R}^r$ from $V_r^T\\big(f_{\\mathrm{ext}}(\\mu) - f_{\\mathrm{int}}^m(V_r a_m(\\mu);\\mu)\\big) = 0$ and returns the state approximation $u_r^m(\\mu) = V_r a_m(\\mu)$.\n\nSuppose the singular values of the displacement snapshot matrix decay algebraically as $\\sigma_i^{(u)} \\sim C_u^{(0)}\\, i^{-p}$ with $p > \\tfrac{1}{2}$, and the singular values of the internal force snapshot matrix decay as $\\sigma_i^{(f)} \\sim C_f^{(0)}\\, i^{-q}$ with $q > \\tfrac{1}{2}$. Let the DEIM interpolation stability be characterized by $\\kappa_m = \\|(P^T U_m)^{-1}\\|_2$; assume a strong rank-revealing factorization yields a uniform bound $\\kappa_m \\le \\kappa_0$ independent of $m$ in the regime of interest. Consider the computational cost per Newton step of the hyper-reduced ROM given by $\\mathcal{C}(r,m) = c_s r^3 + c_e m r$, where $c_s > 0$ reflects reduced system factorization/solve and $c_e > 0$ reflects hyper-reduced residual and Jacobian assembly.\n\nYour task is to reason from first principles to (i) decompose the total ROM state error $\\|u^\\star - u_r^m\\|_2$ into a projection component and a hyper-reduction component using a two-step argument based on strong monotonicity and the triangle inequality, and (ii) design a strategy to allocate basis size $r$ and DEIM size $m$ that meets a target tolerance $\\varepsilon > 0$ on the state error at minimal cost. In particular, use the POD optimality property for snapshot approximation and the algebraic decay models above to justify asymptotic forms for the projection and hyper-reduction error contributions as functions of $r$ and $m$, and then describe how to determine $r$ and $m$ to minimize $\\mathcal{C}(r,m)$ subject to meeting the tolerance.\n\nAssume throughout that $\\alpha = L$, $\\kappa_m \\le \\kappa_0$ with a moderate $\\kappa_0$, and that the neighborhood assumptions required for Newton convergence and the operator inequalities are satisfied.\n\nWhich option best captures both a valid decomposition and a cost-minimizing allocation principle consistent with these assumptions?\n\nA. Introduce the intermediate Galerkin solution $u_r$ that solves $V_r^T\\big(f_{\\mathrm{ext}}(\\mu) - f_{\\mathrm{int}}(V_r a_r(\\mu);\\mu)\\big) = 0$, invoke strong monotonicity to obtain a quasi-optimality bound $\\|u^\\star - u_r\\|_2 \\le C_1 \\inf_{v\\in \\mathrm{Range}(V_r)} \\|u^\\star - v\\|_2$, and bound the hyper-reduction perturbation $\\|u_r - u_r^m\\|_2$ via residual consistency and $\\kappa_m$ to get $\\|u^\\star - u_r^m\\|_2 \\le C_1\\,\\rho_r + C_2\\,\\kappa_m\\,\\tau_m$, where $\\rho_r \\approx \\big(\\sum_{i>r} (\\sigma_i^{(u)})^2\\big)^{1/2} \\sim \\tilde C_u\\, r^{-(p-\\tfrac{1}{2})}$ and $\\tau_m \\approx \\big(\\sum_{i>m} (\\sigma_i^{(f)})^2\\big)^{1/2} \\sim \\tilde C_f\\, m^{-(q-\\tfrac{1}{2})}$. Then choose $r$ and $m$ by solving the constrained optimization $\\min_{r,m} \\mathcal{C}(r,m)$ subject to $C_1\\,\\rho_r + C_2\\,\\kappa_0\\,\\tau_m \\le \\varepsilon$, using Lagrange multipliers to equalize the marginal cost per unit error reduction, i.e., $(\\partial \\mathcal{C}/\\partial r)/|\\partial (C_1\\rho_r)/\\partial r| = (\\partial \\mathcal{C}/\\partial m)/|\\partial (C_2\\kappa_0 \\tau_m)/\\partial m|$, which allocates a larger share of the error budget to the more expensive-to-reduce contribution (typically the projection error due to the $r^3$ term), thereby achieving minimal cost.\n\nB. Treat the projection and hyper-reduction errors as orthogonal and decompose the total error as a Euclidean sum $\\|u^\\star - u_r^m\\|_2^2 = \\|u^\\star - u_r\\|_2^2 + \\|u_r - u_r^m\\|_2^2$; then enforce equal allocation by imposing $\\|u^\\star - u_r\\|_2 = \\|u_r - u_r^m\\|_2 = \\varepsilon/ \\sqrt{2}$, which implies choosing $r$ and $m$ so that $\\rho_r \\approx \\tau_m \\approx \\varepsilon$, because equal splitting always minimizes the cost under any cost model.\n\nC. Choose $r$ and $m$ to be equal, $r = m$, since using the same number of POD modes for the state and the internal force ensures balanced accuracy; determine the common value by solving $\\rho_r \\approx \\tau_r \\approx \\varepsilon$ and ignore the distinct costs of solving the reduced system and assembling the hyper-reduced residual.\n\nD. Use the triangle inequality to write $\\|u^\\star - u_r^m\\|_2 \\le \\|u^\\star - u_r\\|_2 + \\|u_r - u_r^m\\|_2$, but then allocate the tolerance by forcing the two contributions to be equal, $\\|u^\\star - u_r\\|_2 = \\|u_r - u_r^m\\|_2 = \\varepsilon/2$, regardless of the cost model, because equal splitting minimizes the sum of two positive terms; compute $r$ and $m$ from the algebraic decay of $\\rho_r$ and $\\tau_m$ under this halving rule.",
            "solution": "The user requires a critical validation of the problem statement, followed by a first-principles derivation of the solution and a detailed evaluation of all provided options.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n\n-   **Full-Order Model (FOM):** The state vector $u^\\star \\in \\mathbb{R}^N$ solves the nonlinear system $R(u;\\mu) = f_{\\mathrm{ext}}(\\mu) - f_{\\mathrm{int}}(u;\\mu) = 0$ for a parameter $\\mu$.\n-   **Internal Force and Tangent Stiffness:** The internal force $f_{\\mathrm{int}}(u;\\mu)$ is Gateaux differentiable. Its Jacobian is the tangent stiffness matrix $K(u;\\mu) = \\partial f_{\\mathrm{int}}/\\partial u$.\n-   **Operator Properties:** $K(u;\\mu)$ is uniformly strongly monotone and Lipschitz continuous in a neighborhood of the solution $u^\\star$.\n    -   Strong monotonicity: $(K(w;\\mu)\\xi,\\xi) \\ge \\alpha \\|\\xi\\|_2^2$ for a constant $\\alpha > 0$.\n    -   Lipschitz continuity: $\\|K(u;\\mu) - K(v;\\mu)\\|_2 \\le L \\|u-v\\|_2$ for a constant $L > 0$.\n-   **Reduced Bases:**\n    -   A POD basis for displacement, $V_r \\in \\mathbb{R}^{N\\times r}$, has orthonormal columns ($V_r^T V_r = I_r$).\n    -   A DEIM basis for the internal force, $U_m \\in \\mathbb{R}^{N\\times m}$, is used with a sampling matrix $P \\in \\mathbb{R}^{N\\times m}$.\n-   **DEIM Approximation:** The internal force is approximated as $f_{\\mathrm{int}}^m(u;\\mu) = U_m (P^T U_m)^{-1} P^T f_{\\mathrm{int}}(u;\\mu)$.\n-   **Hyper-Reduced ROM (HROM):** The HROM solution is $u_r^m(\\mu) = V_r a_m(\\mu)$, where the reduced coordinate vector $a_m(\\mu) \\in \\mathbb{R}^r$ solves the projected system $V_r^T\\big(f_{\\mathrm{ext}}(\\mu) - f_{\\mathrm{int}}^m(V_r a_m(\\mu);\\mu)\\big) = 0$.\n-   **Error Decay Models:**\n    -   Singular values of displacement snapshots: $\\sigma_i^{(u)} \\sim C_u^{(0)}\\, i^{-p}$ with $p > \\tfrac{1}{2}$.\n    -   Singular values of internal force snapshots: $\\sigma_i^{(f)} \\sim C_f^{(0)}\\, i^{-q}$ with $q > \\tfrac{1}{2}$.\n-   **DEIM Stability:** The DEIM interpolation process has a stability constant bounded by $\\kappa_m = \\|(P^T U_m)^{-1}\\|_2 \\le \\kappa_0$.\n-   **Cost Model:** The computational cost per Newton step is $\\mathcal{C}(r,m) = c_s r^3 + c_e m r$, with $c_s > 0$ and $c_e > 0$.\n-   **Task:** (i) Decompose the total state error $\\|u^\\star - u_r^m\\|_2$ and (ii) determine a cost-minimizing strategy for selecting $r$ and $m$ to meet a tolerance $\\varepsilon > 0$.\n-   **Assumptions:** $\\alpha = L$, and neighborhood assumptions for analysis hold.\n\n**Step 2: Validate Using Extracted Givens**\n\n-   **Scientific Grounding:** The problem is firmly grounded in the advanced literature of computational solid mechanics, specifically in projection-based model order reduction. All concepts—POD, DEIM, hyper-reduction, Newton's method, strong monotonicity, and Lipschitz continuity of operators—are standard and correctly formulated. The described framework is the state of the art for analyzing the accuracy of such methods.\n-   **Well-Posedness:** The problem is well-posed. It provides sufficient mathematical structure (e.g., operator properties ensuring unique solutions to the nonlinear systems) and defines a clear objective (error analysis and cost optimization).\n-   **Objectivity:** The problem statement is expressed in precise, objective mathematical language, free from ambiguity or subjective claims.\n\n**Step 3: Verdict and Action**\n\nThe problem statement is scientifically sound, self-contained, and well-posed. It represents a standard, albeit complex, theoretical problem in its field. All conditions are met for a valid problem. Therefore, I will proceed with the solution.\n\n### Derivation and Option Analysis\n\nThe task is to analyze the total error of the hyper-reduced model, $\\|u^\\star - u_r^m\\|_2$, and devise a strategy to minimize computational cost $\\mathcal{C}(r,m)$ for a given error tolerance $\\varepsilon$.\n\n**Part (i): Error Decomposition**\n\nA standard technique for analyzing the error of a perturbed system is to introduce an intermediate, unperturbed solution and apply the triangle inequality. The natural intermediate solution here is the Galerkin ROM solution, which uses projection but not hyper-reduction. Let $u_r = V_r a_r$ be the solution to the Galerkin ROM:\n$$ V_r^T R(u_r) = V_r^T(f_{\\mathrm{ext}}(\\mu) - f_{\\mathrm{int}}(u_r;\\mu)) = 0 $$\nThe total error can then be decomposed using the triangle inequality:\n$$ \\|u^\\star - u_r^m\\|_2 \\le \\|u^\\star - u_r\\|_2 + \\|u_r - u_r^m\\|_2 $$\nThis decomposition splits the total error into two distinct contributions:\n1.  $\\|u^\\star - u_r\\|_2$: The **projection error**, arising from approximating the solution manifold by the finite-dimensional subspace spanned by $V_r$.\n2.  $\\|u_r - u_r^m\\|_2$: The **hyper-reduction error**, which is the perturbation in the Galerkin solution caused by approximating the internal force $f_{\\mathrm{int}}$ with the DEIM approximation $f_{\\mathrm{int}}^m$.\n\n**Bounding the Projection Error $\\|u^\\star - u_r\\|_2$:**\nThe properties of strong monotonicity and Lipschitz continuity of the residual operator $R(u)$ (which follow from the given properties for $K = -\\partial R/\\partial u$) lead to a quasi-optimality result, a nonlinear analogue of Céa's lemma. This result states that the error of the Galerkin solution is bounded by a constant times the best possible approximation error from the subspace:\n$$ \\|u^\\star - u_r\\|_2 \\le C_1 \\inf_{v_r \\in \\mathrm{Range}(V_r)} \\|u^\\star - v_r\\|_2 $$\nThe constant $C_1$ depends on the operator properties (specifically, a ratio of a Lipschitz/boundedness constant to the strong monotonicity constant $\\alpha$). The term $\\inf_{v_r \\in \\mathrm{Range}(V_r)} \\|u^\\star - v_r\\|_2 = \\|(I - V_rV_r^T)u^\\star\\|_2$ is the error of the best approximation of $u^\\star$ in the subspace. POD is designed to make this term small on average over the set of snapshots used to generate $V_r$. The expected magnitude of this error is well-approximated by the truncated singular values of the displacement snapshot matrix. Let $\\rho_r$ denote this error term. Given the algebraic decay model $\\sigma_i^{(u)} \\sim C_u^{(0)} i^{-p}$, the root-mean-square error over the snapshots is $\\big(\\sum_{i=r+1}^{S} (\\sigma_i^{(u)})^2\\big)^{1/2}$. For large $r$, this sum can be approximated by an integral:\n$$ \\rho_r \\approx \\left( \\int_r^\\infty (C_u^{(0)} x^{-p})^2 dx \\right)^{1/2} = C_u^{(0)} \\left( \\frac{r^{1-2p}}{2p-1} \\right)^{1/2} \\sim \\tilde{C}_u r^{-(p - 1/2)} $$\nThis relies on the given condition $p > 1/2$. Thus, we have $\\|u^\\star - u_r\\|_2 \\lesssim C_1 \\tilde{C}_u r^{-(p - 1/2)}$.\n\n**Bounding the Hyper-reduction Error $\\|u_r - u_r^m\\|_2$:**\nThis error is the difference between the solutions of the Galerkin ROM and the HROM. Their governing equations are:\n$$ V_r^T f_{\\mathrm{int}}(u_r) = V_r^T f_{\\mathrm{ext}} $$\n$$ V_r^T f_{\\mathrm{int}}^m(u_r^m) = V_r^T f_{\\mathrm{ext}} $$\nSubtracting gives $V_r^T (f_{\\mathrm{int}}(u_r) - f_{\\mathrm{int}}^m(u_r^m)) = 0$. By adding and subtracting $V_r^T f_{\\mathrm{int}}(u_r^m)$, we obtain:\n$$ V_r^T (f_{\\mathrm{int}}(u_r) - f_{\\mathrm{int}}(u_r^m)) = V_r^T (f_{\\mathrm{int}}^m(u_r^m) - f_{\\mathrm{int}}(u_r^m)) $$\nAn analysis based on the strong monotonicity of $f_{\\mathrm{int}}$ (which follows from that of $K$) shows that the left-hand side provides a lower bound in terms of $\\|u_r-u_r^m\\|_2^2$, while the right-hand side is the source term due to the DEIM approximation. This leads to a bound of the form:\n$$ \\|u_r - u_r^m\\|_2 \\le \\frac{1}{\\alpha'} \\|f_{\\mathrm{int}}(u_r^m) - f_{\\mathrm{int}}^m(u_r^m)\\|_2 $$\nwhere $\\alpha'$ is an effective strong monotonicity constant for the reduced system. The DEIM error itself is bounded by the best approximation error from the DEIM subspace, scaled by the stability constant $\\kappa_m = \\|(P^T U_m)^{-1}\\|_2$:\n$$ \\|f_{\\mathrm{int}}(u) - f_{\\mathrm{int}}^m(u)\\|_2 \\le C_{\\mathrm{DEIM}}\\,\\kappa_m\\, \\|(I - U_mU_m^T)f_{\\mathrm{int}}(u)\\|_2 $$\nThe term $\\|(I - U_mU_m^T)f_{\\mathrm{int}}(u)\\|_2$ is the error of the best approximation of the internal force vector from the subspace spanned by $U_m$. Let's call its supremum $\\tau_m$. Similar to the displacement case, this is estimated by the tail of the singular values of the internal force snapshot matrix, which yields the asymptotic behavior $\\tau_m \\sim \\tilde{C}_f m^{-(q - 1/2)}$.\nCombining these results and using the uniform bound $\\kappa_m \\le \\kappa_0$, we get the bound on the hyper-reduction error: $\\|u_r - u_r^m\\|_2 \\lesssim C_2 \\kappa_0 \\tau_m \\sim C_2 \\kappa_0 \\tilde{C}_f m^{-(q - 1/2)}$.\n\n**Total Error Bound:**\nCombining the two components, the total error is bounded by:\n$$ \\|u^\\star - u_r^m\\|_2 \\le C_1 \\rho_r + C_2 \\kappa_0 \\tau_m \\approx A r^{-(p-1/2)} + B m^{-(q-1/2)} $$\nwhere $A$ and $B$ are constants.\n\n**Part (ii): Cost Minimization**\n\nWe aim to minimize the cost $\\mathcal{C}(r,m) = c_s r^3 + c_e m r$ subject to the error constraint $A r^{-(p-1/2)} + B m^{-(q-1/2)} \\le \\varepsilon$. To find the minimum cost, we solve the problem for the equality constraint $A r^{-(p-1/2)} + B m^{-(q-1/2)} = \\varepsilon$. This is a constrained optimization problem, solvable with Lagrange multipliers. Let $P = p-1/2$ and $Q = q-1/2$. The Lagrangian is:\n$$ \\mathcal{L}(r, m, \\lambda) = (c_s r^3 + c_e m r) - \\lambda (A r^{-P} + B m^{-Q} - \\varepsilon) $$\nThe optimality conditions are $\\nabla \\mathcal{L} = 0$:\n$$ \\frac{\\partial \\mathcal{L}}{\\partial r} = (3 c_s r^2 + c_e m) - \\lambda (-P A r^{-P-1}) = 0 $$\n$$ \\frac{\\partial \\mathcal{L}}{\\partial m} = c_e r - \\lambda (-Q B m^{-Q-1}) = 0 $$\nFrom these two equations, we can solve for the Lagrange multiplier $\\lambda$:\n$$ \\lambda = \\frac{3 c_s r^2 + c_e m}{P A r^{-P-1}} = \\frac{c_e r}{Q B m^{-Q-1}} $$\nThe term $\\partial \\mathcal{C} / \\partial r = 3c_s r^2 + c_e m$ is the marginal cost of increasing $r$. The term $|\\partial(A r^{-P})/\\partial r| = P A r^{-P-1}$ is the marginal error reduction from increasing $r$. The ratio is precisely the left-hand expression for $\\lambda$. Similarly, the right-hand expression is the marginal cost per unit error reduction for $m$. The equality of these two ratios is the principle of equi-marginality: at the optimum, the \"value\" (in terms of error reduction) obtained from the last dollar spent must be the same, whether it's spent on increasing $r$ or increasing $m$.\n\nIf one error source (e.g., projection error reduced by $r$) is much more expensive to reduce, the optimization will favor a smaller $r$, thus allocating a larger portion of the total error budget $\\varepsilon$ to the projection error, while requiring a much smaller hyper-reduction error (achieved with a larger $m$) to compensate.\n\n### Option-by-Option Analysis\n\n**A. Introduce the intermediate Galerkin solution $u_r$ that solves $V_r^T\\big(f_{\\mathrm{ext}}(\\mu) - f_{\\mathrm{int}}(V_r a_r(\\mu);\\mu)\\big) = 0$, invoke strong monotonicity to obtain a quasi-optimality bound $\\|u^\\star - u_r\\|_2 \\le C_1 \\inf_{v\\in \\mathrm{Range}(V_r)} \\|u^\\star - v\\|_2$, and bound the hyper-reduction perturbation $\\|u_r - u_r^m\\|_2$ via residual consistency and $\\kappa_m$ to get $\\|u^\\star - u_r^m\\|_2 \\le C_1\\,\\rho_r + C_2\\,\\kappa_m\\,\\tau_m$, where $\\rho_r \\approx \\big(\\sum_{i>r} (\\sigma_i^{(u)})^2\\big)^{1/2} \\sim \\tilde C_u\\, r^{-(p-\\tfrac{1}{2})}$ and $\\tau_m \\approx \\big(\\sum_{i>m} (\\sigma_i^{(f)})^2\\big)^{1/2} \\sim \\tilde C_f\\, m^{-(q-\\tfrac{1}{2})}$. Then choose $r$ and $m$ by solving the constrained optimization $\\min_{r,m} \\mathcal{C}(r,m)$ subject to $C_1\\,\\rho_r + C_2\\,\\kappa_0\\,\\tau_m \\le \\varepsilon$, using Lagrange multipliers to equalize the marginal cost per unit error reduction, i.e., $(\\partial \\mathcal{C}/\\partial r)/|\\partial (C_1\\rho_r)/\\partial r| = (\\partial \\mathcal{C}/\\partial m)/|\\partial (C_2\\kappa_0 \\tau_m)/\\partial m|$, which allocates a larger share of the error budget to the more expensive-to-reduce contribution (typically the projection error due to the $r^3$ term), thereby achieving minimal cost.**\n- This option perfectly follows the rigorous derivation. The error decomposition, the bounds based on operator properties, the asymptotic error forms, and the cost-optimization principle based on Lagrange multipliers (equalizing marginal cost per unit error reduction) are all correct. The concluding remark about allocating a larger error share to the more expensive component is a correct insight derived from this principle.\n- **Verdict: Correct.**\n\n**B. Treat the projection and hyper-reduction errors as orthogonal and decompose the total error as a Euclidean sum $\\|u^\\star - u_r^m\\|_2^2 = \\|u^\\star - u_r\\|_2^2 + \\|u_r - u_r^m\\|_2^2$; then enforce equal allocation by imposing $\\|u^\\star - u_r\\|_2 = \\|u_r - u_r^m\\|_2 = \\varepsilon/ \\sqrt{2}$, which implies choosing $r$ and $m$ so that $\\rho_r \\approx \\tau_m \\approx \\varepsilon$, because equal splitting always minimizes the cost under any cost model.**\n- The decomposition $\\|u^\\star - u_r^m\\|_2^2 = \\|u^\\star - u_r\\|_2^2 + \\|u_r - u_r^m\\|_2^2$ requires the error vectors $u^\\star - u_r$ and $u_r - u_r^m$ to be orthogonal. There is no mathematical reason for this to be true in general. The vector $u_r-u_r^m$ lies in the subspace $\\mathrm{Range}(V_r)$, but $u^\\star - u_r$ is not guaranteed to be orthogonal to this subspace. The claim that \"equal splitting always minimizes the cost\" is false; it ignores the cost function's structure.\n- **Verdict: Incorrect.**\n\n**C. Choose $r$ and $m$ to be equal, $r = m$, since using the same number of POD modes for the state and the internal force ensures balanced accuracy; determine the common value by solving $\\rho_r \\approx \\tau_r \\approx \\varepsilon$ and ignore the distinct costs of solving the reduced system and assembling the hyper-reduced residual.**\n- The assumption $r=m$ is an ad-hoc simplification. The optimal choice of $r$ and $m$ depends on the decay rates of the respective singular values ($p$ and $q$) and the cost coefficients ($c_s$ and $c_e$), none of which suggest $r$ and $m$ should be equal. Ignoring the distinct costs is contrary to the problem's goal of minimizing $\\mathcal{C}(r,m)$.\n- **Verdict: Incorrect.**\n\n**D. Use the triangle inequality to write $\\|u^\\star - u_r^m\\|_2 \\le \\|u^\\star - u_r\\|_2 + \\|u_r - u_r^m\\|_2$, but then allocate the tolerance by forcing the two contributions to be equal, $\\|u^\\star - u_r\\|_2 = \\|u_r - u_r^m\\|_2 = \\varepsilon/2$, regardless of the cost model, because equal splitting minimizes the sum of two positive terms; compute $r$ and $m$ from the algebraic decay of $\\rho_r$ and $\\tau_m$ under this halving rule.**\n- This option correctly starts with the triangle inequality. However, it then proposes a naive `a priori` error balancing scheme ($\\varepsilon/2$ for each term). This heuristic is not optimal because it fails to account for the potentially very different costs of reducing each error component. The justification \"because equal splitting minimizes the sum of two positive terms\" is a non-sequitur; the goal is to minimize cost for a fixed sum of errors, not to minimize the sum of errors itself.\n- **Verdict: Incorrect.**",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "Real-world systems are often characterized by coupled multiphysics and physical constraints, such as inequalities, which pose a significant challenge for model reduction. This practice tackles the complex problem of phase-field fracture, involving coupled displacement ($u$) and damage ($\\phi$) fields. You will implement a reduced model that incorporates a sophisticated projection technique to enforce the critical irreversibility constraint ($\\dot{\\phi} \\ge 0$), ensuring the model does not \"heal\" damage unphysically. ",
            "id": "3591639",
            "problem": "You are asked to implement a complete, runnable program that constructs a projection-based reduced-order model for a one-dimensional bar undergoing phase-field fracture with coupled displacement and damage fields, and that designs a reduced-space projection enforcing the crack irreversibility constraint while quantifying the error in a crack surface functional. The goal is to demonstrate a principled reduction using Proper Orthogonal Decomposition (POD) and to assess its fidelity against a high-fidelity reference.\n\nThe fundamental base comprises:\n- Balance of linear momentum in quasi-static small-strain elasticity for the displacement field $u$, with a phase-field degradation $g(\\phi)$ of the stiffness.\n- A gradient flow update for the phase-field fracture variable $\\phi$ driving damage growth from elastic energy.\n- The crack surface functional $\\Gamma(\\phi)$ arising from the Ambrosio–Tortorelli regularization.\n\nConsider a one-dimensional bar of length $L$ discretized by linear finite elements with $N$ nodes and $N-1$ elements. Let the Young’s modulus be $E$ and the cross-sectional area be $A$. Let $h = L/(N-1)$ be the element size. The bar is loaded by a time-ramped end traction. The left end at $x=0$ is fixed with Dirichlet condition $u(0)=0$. The right end at $x=L$ carries a traction of amplitude $\\lambda \\, t_n$, where $\\lambda$ is a load scaling parameter and $t_n$ is a ramp factor increasing linearly in discrete time from $0$ to $1$ over $T$ steps indexed by $n=1,\\dots,T$.\n\nThe physical modeling assumptions are:\n- The small-strain elastic stiffness is degraded by the phase field via $g(\\phi) = \\kappa + (1-\\kappa)\\,(1-\\phi)^2$ with a small regularization $\\kappa \\in (0,1)$.\n- The quasi-static equilibrium at time step $n$ is $K(\\phi^n)\\,u^n = f^n$, where $K(\\phi)$ is the assembled stiffness with element contributions scaled by $g(\\phi)$ and $f^n$ is the nodal force vector induced by the traction at step $n$.\n- The phase-field update at step $n \\to n+1$ is given by a linearized gradient flow with discrete operator $A_\\phi = \\frac{1}{\\Delta t} M + G + H$, right-hand side $b_\\phi = \\frac{1}{\\Delta t} M \\phi^n + \\alpha\\,r(u^n)$, and the irreversibility constraint $\\phi^{n+1} \\ge \\phi^n$ applied component-wise. Here $M$ is the consistent mass matrix, $G = \\ell\\,K_{\\text{grad}}$ with $K_{\\text{grad}}$ the stiffness matrix assembled using unit modulus, $H = \\frac{1}{\\ell} M$, $\\ell>0$ is the length scale parameter, $\\Delta t>0$ the time step, and $\\alpha>0$ a coupling parameter. The driving vector $r(u)$ is assembled from the elastic energy density, using per-element energy density $Y_e = \\tfrac{1}{2} E \\varepsilon_e^2$ with element strain $\\varepsilon_e = \\frac{u_{i+1}-u_i}{h}$, consistently distributed to the nodes.\n\nThe crack surface functional is defined in discrete form by\n$$\n\\Gamma(\\phi) = \\tfrac{1}{2}\\,\\phi^\\top H\\,\\phi \\;+\\; \\tfrac{1}{2}\\,\\phi^\\top G\\,\\phi.\n$$\n\nYou must:\n1) Construct a high-fidelity solver that, for each load step $n$, solves the quasi-static equilibrium for $u^n$ using the current $\\phi^n$, then updates $\\phi^{n+1}$ by solving $A_\\phi \\phi^{n+1} = b_\\phi$ and enforcing component-wise $\\phi^{n+1} \\ge \\phi^{n}$ and $0 \\le \\phi^{n+1} \\le 1$. Use $u(0)=0$ as the Dirichlet boundary condition for displacements and implement the traction as a nodal force applied at the rightmost node. Use a linear ramp $t_n = \\tfrac{n}{T}$.\n2) Generate snapshot matrices for $u$ and $\\phi$ using an offline training set of load amplitudes. From these snapshots, construct reduced bases $V_u$ and $V_\\phi$ by Proper Orthogonal Decomposition (POD) (define Proper Orthogonal Decomposition (POD) as the method that extracts orthonormal modes by singular value decomposition, retaining a prescribed energy content).\n3) Define the reduced-order model:\n   - For the displacement, apply a Galerkin projection to obtain reduced coordinates $a^n$ solving $V_u^\\top K(\\phi_{\\text{rb}}^n) V_u\\, a^n = V_u^\\top f^n$ and reconstruct $u_{\\text{rb}}^n = V_u a^n$, where $\\phi_{\\text{rb}}^n = V_\\phi b^n$.\n   - For the phase field, solve the unconstrained reduced update $b^{n+1}_{\\text{unc}}$ from $V_\\phi^\\top A_\\phi V_\\phi\\, b^{n+1}_{\\text{unc}} = V_\\phi^\\top \\left(\\tfrac{1}{\\Delta t} M \\phi_{\\text{rb}}^n + \\alpha\\,r(u_{\\text{rb}}^n)\\right)$. Then design a projection that enforces the irreversibility constraint in reduced coordinates as follows:\n     • Lift the unconstrained update to the full space $\\tilde{\\phi}^{n+1} = V_\\phi b^{n+1}_{\\text{unc}}$.\n     • Enforce $\\phi$-monotonicity by setting $\\hat{\\phi}^{n+1} = \\max(\\phi_{\\text{rb}}^n, \\tilde{\\phi}^{n+1})$ component-wise and clipping to $[0,1]$.\n     • Project back to reduced coordinates by solving the mass-weighted least-squares problem $\\min_{b} \\| \\hat{\\phi}^{n+1} - V_\\phi b \\|_{M}$, i.e., solve $(V_\\phi^\\top M V_\\phi) b^{n+1} = V_\\phi^\\top M \\hat{\\phi}^{n+1}$. Optionally perform one additional refinement by re-enforcing monotonicity after reconstruction and re-solving the weighted least-squares. The reduced phase field is $\\phi_{\\text{rb}}^{n+1} = V_\\phi b^{n+1}$.\n4) For each time step, compare the reduced-order crack surface functional $\\Gamma(\\phi_{\\text{rb}}^{n})$ with the high-fidelity $\\Gamma(\\phi^{n})$ computed from the reference trajectory under the same load ramp. Record the maximum absolute error over time.\n\nThe program must implement the following parameter values:\n- Mesh and material: $L = 1$, $N = 41$, $E = 1$, $A = 1$.\n- Phase-field parameters: $\\ell = 3h$ where $h = L/(N-1)$, $\\kappa = 10^{-6}$, $\\alpha = 0.2$, $\\Delta t = 1/T$ with $T = 12$.\n- Offline training load amplitudes used to build snapshots: $\\lambda \\in \\{0.5, 1.0, 1.5\\}$ (ramped over $T$ steps as described).\n- POD energy retention threshold: retain the smallest number of modes $r_u$ and $r_\\phi$ such that the cumulative singular value energy is at least $0.999$, with a minimum of $1$ mode retained in each field.\n\nYou must evaluate the reduced-order model on the following test suite of load amplitudes:\n- Case $1$: $\\lambda = 0.25$ (small load).\n- Case $2$: $\\lambda = 1.0$ (moderate load).\n- Case $3$: $\\lambda = 2.0$ (high load).\n\nFor each case, compute:\n- The maximum absolute crack surface functional error over time, defined as $\\max_{n=1,\\dots,T} |\\Gamma(\\phi_{\\text{rb}}^n) - \\Gamma(\\phi^n)|$.\n- A boolean indicating whether the reduced trajectory satisfies irreversibility at all nodes and times, i.e., $\\phi_{\\text{rb}}^{n+1}(x_i) - \\phi_{\\text{rb}}^{n}(x_i) \\ge -\\varepsilon$ for all nodes $i$ and steps $n$, with a numerical tolerance $\\varepsilon = 10^{-12}$ to account for floating-point round-off.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a two-entry list $[\\text{max\\_abs\\_error}, \\text{irreversibility\\_ok}]$. For example, the output format must be:\n\"[ [e1,True],[e2,False],[e3,True] ]\" where $e1,e2,e3$ are floating-point numbers.\n\nAll quantities are non-dimensional in this problem. Angles are not used. Percentages must not be used; any fractional quantity is to be represented as a decimal. Your implementation must be self-contained and must not require any input.",
            "solution": "The user has requested the implementation of a projection-based reduced-order model (ROM) for phase-field fracture in a one-dimensional bar. The task involves a comprehensive workflow: first, building a high-fidelity finite element model (HFM); second, using the HFM to generate simulation data (snapshots); third, constructing a reduced basis via Proper Orthogonal Decomposition (POD); and finally, implementing and evaluating the ROM against the HFM for a given set of test cases.\n\n### Step 1: Problem Validation\n\nThe problem statement is critically assessed for its validity.\n\n**Extracted Givens:**\n- **Domain/Discretization**: 1D bar, length $L=1$, $N=41$ nodes, $N-1$ linear elements. Element size $h=L/(N-1)$.\n- **Material/Geometry**: Young's modulus $E=1$, cross-sectional area $A=1$.\n- **Loading/BCs**: Fixed at $x=0$ ($u(0)=0$). Time-ramped traction at $x=L$ with amplitude $\\lambda \\, t_n$, where $t_n = n/T$ for $n=1,\\dots,T$ over $T=12$ steps.\n- **Physics**: Coupled displacement $u$ and phase-field $\\phi$.\n- **Stiffness Degradation**: $g(\\phi) = \\kappa + (1-\\kappa)\\,(1-\\phi)^2$ with $\\kappa = 10^{-6}$.\n- **HFM Equations**:\n    - Quasi-static momentum balance: $K(\\phi^n)\\,u^n = f^n$.\n    - Phase-field evolution (linearized gradient flow): $A_\\phi \\phi^{n+1} = \\frac{1}{\\Delta t} M \\phi^n + \\alpha\\,r(u^n)$, with $\\alpha=0.2$. Followed by component-wise irreversibility ($\\phi^{n+1} \\ge \\phi^n$) and bounds ($0 \\le \\phi^{n+1} \\le 1$) enforcement.\n- **Matrix/Vector Definitions**:\n    - $M$: Consistent mass matrix.\n    - $G = \\ell\\,K_{\\text{grad}}$ ($K_{\\text{grad}}$ is unit-modulus stiffness matrix).\n    - $H = \\frac{1}{\\ell} M$, with length scale $\\ell=3h$.\n    - $A_\\phi = \\frac{1}{\\Delta t} M + G + H$, with time step $\\Delta t = 1/T$.\n    - $r(u)$: Nodal vector from consistent distribution of element elastic energy density $Y_e = \\frac{1}{2} E \\varepsilon_e^2$.\n- **Crack Surface Functional**: $\\Gamma(\\phi) = \\frac{1}{2}\\,\\phi^\\top H\\,\\phi \\;+\\; \\frac{1}{2}\\,\\phi^\\top G\\,\\phi$.\n- **Offline Stage (ROM Construction)**:\n    - Snapshots from HFM runs with training loads $\\lambda \\in \\{0.5, 1.0, 1.5\\}$.\n    - POD bases $V_u$, $V_\\phi$ from snapshots, retaining modes for $\\ge 0.999$ cumulative singular value energy (minimum 1 mode).\n- **Online Stage (ROM Execution)**:\n    - Reduced displacement: $V_u^\\top K(\\phi_{\\text{rb}}^n) V_u\\, a^n = V_u^\\top f^n$, then $u_{\\text{rb}}^n = V_u a^n$.\n    - Reduced phase-field update:\n        1. Solve unconstrained system: $V_\\phi^\\top A_\\phi V_\\phi\\, b^{n+1}_{\\text{unc}} = V_\\phi^\\top (\\dots)$.\n        2. Lift to full space: $\\tilde{\\phi}^{n+1} = V_\\phi b^{n+1}_{\\text{unc}}$.\n        3. Enforce constraints: $\\hat{\\phi}^{n+1} = \\text{clip}(\\max(\\phi_{\\text{rb}}^n, \\tilde{\\phi}^{n+1}), [0,1])$.\n        4. Project back via mass-weighted least-squares: $(V_\\phi^\\top M V_\\phi) b^{n+1} = V_\\phi^\\top M \\hat{\\phi}^{n+1}$.\n- **Evaluation**:\n    - Test loads: $\\lambda \\in \\{0.25, 1.0, 2.0\\}$.\n    - Metrics: $\\max_{n=1,\\dots,T} |\\Gamma(\\phi_{\\text{rb}}^n) - \\Gamma(\\phi^n)|$ and a boolean for irreversibility satisfaction ($\\phi_{\\text{rb}}^{n+1}(x_i) - \\phi_{\\text{rb}}^{n}(x_i) \\ge -10^{-12}$).\n- **Output Format**: A single-line string `\"[ [e1,True],[e2,False],[e3,True] ]\"`.\n\n**Validation Verdict:**\nThe problem is **valid**. It describes a standard, albeit complex, problem in computational solid mechanics and model order reduction. All parameters, equations, and procedures are specified in sufficient detail to permit a unique implementation. The underlying physics (phase-field fracture) and numerical methods (finite elements, POD, Galerkin projection) are well-established. There is a minor ambiguity in a phrase \"Optionally perform one additional refinement,\" which is resolved by implementing the specified procedure without the optional step. The time indexing requires careful interpretation, but a consistent staggered-scheme logic can be established: for each time step $n$, from an existing state $\\phi^{n-1}$, one first solves for $u^n$ and then for $\\phi^n$. This interpretation is consistent with the overall problem structure.\n\n### Step 2: Solution Design and Implementation\n\nBased on the validated problem statement, a complete Python program is designed. The implementation is structured logically to mirror the theoretical workflow.\n\n**1. Finite Element Assembly:**\nHelper functions are created to assemble the standard 1D finite element matrices for a bar.\n- `assemble_matrices`: This function pre-computes all time-invariant global matrices: the unit stiffness matrix $K_{\\text{unit}}$, the consistent mass matrix $M$, the gradient energy matrix $G$, the homogeneous energy matrix $H$, and the phase-field system matrix $A_\\phi$. This is done once to optimize performance.\n- `assemble_stiffness`: This function assembles the global stiffness matrix $K(\\phi)$, which depends on the current phase-field $\\phi$. It iterates over each element, calculates the degraded stiffness property $g(\\phi)$ using a mid-element evaluation of $\\phi$, and assembles the element contribution into the global matrix.\n\n**2. High-Fidelity Model (HFM) Solver:**\nThe function `run_hfm` implements the full-order simulation. It follows a staggered time-stepping scheme for $n=1,\\dots,T$:\n- At each step $n$, given the phase field $\\phi^{n-1}$ from the previous step, it first computes the external force vector $f^n$.\n- It then solves the linear momentum balance $K(\\phi^{n-1}) u^n = f^n$ for the displacement field $u^n$. The Dirichlet boundary condition $u(0)=0$ is enforced by solving a reduced system for the free degrees of freedom.\n- The elastic energy density is computed from $u^n$ and assembled into the damage driving vector $r(u^n)$.\n- The phase-field is updated by solving the linear system $A_\\phi \\phi^n_{\\text{unc}} = \\frac{1}{\\Delta t} M \\phi^{n-1} + \\alpha r(u^n)$.\n- Finally, the irreversibility and bounds constraints ($\\phi^n = \\text{clip}(\\max(\\phi^{n-1}, \\phi^n_{\\text{unc}}), 0, 1)$) are enforced component-wise.\n- The resulting fields $u^n$ and $\\phi^n$ are stored as snapshots for the offline stage and as reference trajectories for the online error analysis.\n\n**3. Proper Orthogonal Decomposition (POD):**\nThe `build_pod_basis` function implements the POD method.\n- It takes a snapshot matrix, where each column is a state vector at a specific time.\n- It performs Singular Value Decomposition (SVD) on this matrix. The left singular vectors form an optimal orthonormal basis for the snapshots.\n- It calculates the cumulative energy of the singular values and truncates the basis to retain the minimum number of modes $r$ required to capture at least $99.9\\%$ of the energy, ensuring at least one mode is always kept.\n\n**4. Reduced-Order Model (ROM) Solver:**\nThe `run_rom` function executes the online phase of the model reduction.\n- It takes the pre-computed POD bases $V_u$ and $V_\\phi$ as input.\n- It follows the same time-stepping scheme as the HFM but operates in the reduced-coordinate space.\n- At each step $n$:\n    - The stiffness matrix $K(\\phi_{\\text{rb}}^{n-1})$ is assembled in the full space and then projected onto the reduced basis: $K_{\\text{rb}} = V_u^\\top K(\\phi_{\\text{rb}}^{n-1}) V_u$.\n    - The reduced displacement coordinates $a^n$ are found by solving the small linear system $K_{\\text{rb}} a^n = V_u^\\top f^n$. The displacement field is reconstructed as $u_{\\text{rb}}^n = V_u a^n$.\n    - The phase-field update follows the specified projection-based constraint enforcement:\n        1. An unconstrained update is performed in the reduced space to get $b^{n}_{\\text{unc}}$.\n        2. This is lifted to the full space ($\\tilde{\\phi}^n = V_\\phi b^{n}_{\\text{unc}}$).\n        3. Constraints are enforced directly on this full-space vector ($\\hat{\\phi}^n = \\text{clip}(\\max(\\phi_{\\text{rb}}^{n-1}, \\tilde{\\phi}^n), 0, 1)$).\n        4. This corrected field is projected back to the reduced basis by solving a mass-matrix-weighted least-squares problem, yielding the final reduced coordinates $b^n$. The phase field is then $\\phi_{\\text{rb}}^n = V_\\phi b^n$.\n- Throughout the simulation, the error in the crack surface functional $|\\Gamma(\\phi_{\\text{rb}}^n) - \\Gamma(\\phi_{\\text{hfm}}^n)|$ is computed and its maximum value is tracked. The irreversibility condition is also checked at every step.\n\n**5. Main Driver:**\nThe main `solve` function orchestrates the entire process:\n- It initializes all physical and numerical parameters.\n- It runs the offline stage by calling `run_hfm` for each training load case, collecting all snapshots, and then calling `build_pod_basis` to create $V_u$ and $V_\\phi$.\n- It runs the online stage by iterating through the test load cases. For each case, it first runs the HFM to get a reference solution and then runs the ROM.\n- It collects the specified metrics (max absolute error and irreversibility boolean) for each test case.\n- Finally, it formats the results into the precise string format required by the problem statement and prints it to standard output.",
            "answer": "```python\nimport numpy as np\n\nclass ProblemParameters:\n    \"\"\"A container for all physical and numerical parameters.\"\"\"\n    def __init__(self):\n        self.L = 1.0\n        self.N = 41\n        self.E = 1.0\n        self.A = 1.0\n        self.h = self.L / (self.N - 1)\n        self.ell = 3.0 * self.h\n        self.kappa = 1e-6\n        self.alpha = 0.2\n        self.T = 12\n        self.dt = 1.0 / self.T\n        self.pod_energy_threshold = 0.999\n        self.irreversibility_tol = 1e-12\n\ndef assemble_matrices(p: ProblemParameters):\n    \"\"\"Assembles time-invariant finite element matrices.\"\"\"\n    N = p.N\n    h = p.h\n\n    K_unit = np.zeros((N, N))\n    M = np.zeros((N, N))\n\n    k_e_unit = (1.0 / h) * np.array([[1, -1], [-1, 1]])\n    m_e = (h / 6.0) * np.array([[2, 1], [1, 2]])\n\n    for i in range(N - 1):\n        K_unit[i:i+2, i:i+2] += k_e_unit\n        M[i:i+2, i:i+2] += m_e\n    \n    G = p.ell * K_unit\n    H = (1.0 / p.ell) * M\n    A_phi = (1.0 / p.dt) * M + G + H\n    \n    return K_unit, M, G, H, A_phi\n\ndef assemble_stiffness(phi, K_unit, p: ProblemParameters):\n    \"\"\"Assembles the phi-dependent global stiffness matrix.\"\"\"\n    N = p.N\n    k_e_factor = p.E * p.A\n    K = np.zeros((N, N))\n    \n    for i in range(N - 1):\n        phi_mid = 0.5 * (phi[i] + phi[i+1])\n        g_phi = p.kappa + (1 - p.kappa) * (1 - phi_mid)**2\n        ke = (k_e_factor / p.h) * np.array([[1, -1], [-1, 1]])\n        K[i:i+2, i:i+2] += g_phi * ke\n        \n    return K\n\ndef apply_bc_solve(K, f, N):\n    \"\"\"Solves a linear system with a fixed u(0)=0 boundary condition.\"\"\"\n    free_dofs = np.arange(1, N)\n    K_ff = K[np.ix_(free_dofs, free_dofs)]\n    f_f = f[free_dofs]\n    \n    u = np.zeros(N)\n    try:\n        u_f = np.linalg.solve(K_ff, f_f)\n        u[free_dofs] = u_f\n    except np.linalg.LinAlgError:\n        # Failsafe for singular matrix, although not expected with kappa > 0\n        pass\n    \n    return u\n\ndef get_damage_driver(u, p: ProblemParameters):\n    \"\"\"Computes the damage driving force vector from the displacement field.\"\"\"\n    N, h, E, A = p.N, p.h, p.E, p.A\n    r = np.zeros(N)\n    for i in range(N - 1):\n        strain = (u[i+1] - u[i]) / h\n        energy_density = 0.5 * E * strain**2\n        nodal_r_contrib = energy_density * A * h * 0.5\n        r[i] += nodal_r_contrib\n        r[i+1] += nodal_r_contrib\n    return r\n\ndef run_hfm(lambda_val, p, matrices):\n    \"\"\"Runs the high-fidelity simulation.\"\"\"\n    N, T, A, dt = p.N, p.T, p.A, p.dt\n    K_unit, M, G, H, A_phi = matrices\n\n    u = np.zeros(N)\n    phi = np.zeros(N)\n    \n    u_snapshots = []\n    phi_snapshots = []\n    \n    u_traj = [u.copy()]\n    phi_traj = [phi.copy()]\n    \n    for n in range(1, T + 1):\n        f = np.zeros(N)\n        f[-1] = lambda_val * (n / T) * A\n\n        K = assemble_stiffness(phi, K_unit, p)\n        u_new = apply_bc_solve(K, f, N)\n        \n        r_u = get_damage_driver(u_new, p)\n        \n        b_phi = (1.0 / dt) * M @ phi + p.alpha * r_u\n        phi_unc = np.linalg.solve(A_phi, b_phi)\n        \n        phi_new = np.maximum(phi, phi_unc)\n        phi_new = np.clip(phi_new, 0.0, 1.0)\n        \n        u, phi = u_new, phi_new\n        \n        u_snapshots.append(u)\n        phi_snapshots.append(phi)\n        u_traj.append(u.copy())\n        phi_traj.append(phi.copy())\n        \n    return u_snapshots, phi_snapshots, u_traj, phi_traj\n\ndef build_pod_basis(snapshots, energy_threshold):\n    \"\"\"Constructs a POD basis from a list of snapshot vectors.\"\"\"\n    if not snapshots:\n        return np.zeros((snapshots[0].shape[0], 1))\n\n    S = np.array(snapshots).T\n    if S.shape[1] == 0:\n        return np.zeros((S.shape[0], 1))\n\n    U, s, _ = np.linalg.svd(S, full_matrices=False)\n    \n    singular_values_sq = s**2\n    total_energy = np.sum(singular_values_sq)\n    if total_energy < 1e-16:\n        return U[:, :1]\n        \n    cumulative_energy = np.cumsum(singular_values_sq) / total_energy\n    \n    num_modes_arr = np.where(cumulative_energy >= energy_threshold)[0]\n    r = num_modes_arr[0] + 1 if len(num_modes_arr) > 0 else S.shape[1]\n    r = max(1, r)\n    \n    return U[:, :r]\n\ndef run_rom(lambda_val, p, V_u, V_phi, hfm_phi_traj, matrices):\n    \"\"\"Runs the reduced-order model simulation.\"\"\"\n    N, T, A, dt = p.N, p.T, p.A, p.dt\n    K_unit, M, G, H, A_phi = matrices\n    \n    A_phi_r = V_phi.T @ A_phi @ V_phi\n    M_r_proj = V_phi.T @ M @ V_phi\n    V_phi_T_M = V_phi.T @ M\n    \n    phi_rb = np.zeros(N)\n    \n    max_abs_error = 0.0\n    irreversibility_ok = True\n    \n    Gamma_op = G + H\n\n    for n in range(1, T + 1):\n        phi_rb_prev = phi_rb.copy()\n        \n        f = np.zeros(N)\n        f[-1] = lambda_val * (n / T) * A\n        f_r = V_u.T @ f\n        \n        K_full = assemble_stiffness(phi_rb_prev, K_unit, p)\n        K_r = V_u.T @ K_full @ V_u\n        a_coords = np.linalg.solve(K_r, f_r)\n        u_rb = V_u @ a_coords\n        \n        r_u_rb = get_damage_driver(u_rb, p)\n        \n        rhs_phi_r = (1/dt) * (V_phi.T @ M @ phi_rb_prev) + p.alpha * (V_phi.T @ r_u_rb)\n        b_unc_coords = np.linalg.solve(A_phi_r, rhs_phi_r)\n        \n        phi_tilde = V_phi @ b_unc_coords\n        phi_hat = np.maximum(phi_rb_prev, phi_tilde)\n        phi_hat = np.clip(phi_hat, 0.0, 1.0)\n        \n        rhs_proj = V_phi_T_M @ phi_hat\n        b_coords = np.linalg.solve(M_r_proj, rhs_proj)\n        phi_rb = V_phi @ b_coords\n        \n        gamma_rom = 0.5 * (phi_rb.T @ Gamma_op @ phi_rb)\n        gamma_hfm = 0.5 * (hfm_phi_traj[n].T @ Gamma_op @ hfm_phi_traj[n])\n        max_abs_error = max(max_abs_error, abs(gamma_rom - gamma_hfm))\n\n        if np.any(phi_rb - phi_rb_prev < -p.irreversibility_tol):\n            irreversibility_ok = False\n            \n    return max_abs_error, irreversibility_ok\n\ndef solve():\n    \"\"\"Main driver function to run the full simulation and evaluation pipeline.\"\"\"\n    params = ProblemParameters()\n    matrices = assemble_matrices(params)\n    \n    # Offline stage\n    training_lambdas = [0.5, 1.0, 1.5]\n    all_u_snapshots = []\n    all_phi_snapshots = []\n    for lam in training_lambdas:\n        u_snaps, phi_snaps, _, _ = run_hfm(lam, params, matrices)\n        all_u_snapshots.extend(u_snaps)\n        all_phi_snapshots.extend(phi_snaps)\n        \n    V_u = build_pod_basis(all_u_snapshots, params.pod_energy_threshold)\n    V_phi = build_pod_basis(all_phi_snapshots, params.pod_energy_threshold)\n    \n    # Online stage\n    test_cases = [0.25, 1.0, 2.0]\n    results = []\n    \n    for lam_test in test_cases:\n        _, _, _, hfm_phi_traj = run_hfm(lam_test, params, matrices)\n        max_err, irrev_ok = run_rom(lam_test, params, V_u, V_phi, hfm_phi_traj, matrices)\n        results.append([max_err, irrev_ok])\n        \n    case_strings = [f\"[{err},{str(ok)}]\" for err, ok in results]\n    final_str = f\"[{','.join(case_strings)}]\"\n    print(final_str)\n\nsolve()\n```"
        }
    ]
}