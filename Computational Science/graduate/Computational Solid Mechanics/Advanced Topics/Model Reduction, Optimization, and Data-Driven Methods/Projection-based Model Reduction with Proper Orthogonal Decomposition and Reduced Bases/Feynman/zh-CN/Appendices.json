{
    "hands_on_practices": [
        {
            "introduction": "本实践将引导你为非线性超弹性固体建立一个完整的降阶模型（ROM）。你将首先通过求解全阶模型（FOM）生成快照，然后使用本征正交分解（POD）从中提取一个降阶基。此练习的核心在于比较两种经典的投影方法——标准伽辽金（Galerkin）投影和最小二乘彼得罗夫-伽辽金（LSPG）投影——在保持系统总势能等关键物理量方面的表现。通过亲手实现和对比，你将深刻理解不同投影技术如何影响非线性ROM的稳定性和保真度。",
            "id": "3591637",
            "problem": "要求您实现一个完整的、可运行的程序，该程序为一个经历大变形的非线性超弹性一维实体构建一个基于投影的降阶模型，并比较标准 Galerkin 投影与最小二乘 Petrov-Galerkin 投影在跨增量加载步长中保持机械能 $E(u)$ 的能力。该系统、降阶方法和比较必须从计算固体力学和数值近似的第一性原理推导和实现。\n\n物理模型是一根长度为 $L$、横截面积恒为 $A$ 的一维杆，其左端固定，右端施加规定的轴向力 $P$。杆经历有限应变，其本构行为是超弹性的。平衡问题是准静态的。您必须在参考（物质）构型下工作，使用坐标 $X \\in [0,L]$ 和位移场 $u(X)$，它将物质点映射到其当前位置 $x(X) = X + u(X)$。变形梯度为 $F(X) = \\dfrac{dx}{dX} = 1 + \\dfrac{du}{dX}$。我们关注的机械能是总势能泛函\n$$\nE(u) = \\int_0^L A\\, W(F(X))\\, dX - P\\, u(L),\n$$\n其中 $W(F)$ 是单位体积的应变能密度。使用 Green-Lagrange 应变 $E_{\\mathrm{GL}}(F) = \\dfrac{1}{2}(F^2 - 1)$ 并将应变能密度定义为\n$$\nW(F) = \\dfrac{1}{2}\\,E\\,E_{\\mathrm{GL}}(F)^2,\n$$\n其中 $E$ 是（有效）弹性模量，单位为帕斯卡。第一 Piola-Kirchhoff 应力为 $P_1(F) = \\dfrac{dW}{dF}$，一致切线为 $H(F) = \\dfrac{dP_1}{dF}$。所有量都必须在参考构型中处理。单位必须与国际单位制一致：长度单位为米 (m)，面积单位为平方米 (m$^2$)，弹性模量单位为帕斯卡 (Pa)，力单位为牛顿 (N)，能量单位为焦耳 (J)。能量 $E(u)$ 必须以焦耳为单位计算和报告。\n\n在参考构型中使用 $N$ 个均匀的两节点线性有限元对杆进行离散化。通过消除相应的自由度来强施加左端的 Dirichlet 边界条件 $u(0)=0$。在网格节点处使用节点未知数 $u_i$。从总势能的驻值条件推导离散残差向量和一致切线矩阵。离散非线性系统必须在每个加载步使用 Newton-Raphson 方法求解，并配备一致切线；如果需要增强鲁棒性，则使用简单的回溯线搜索。\n\n构建一个本征正交分解 (Proper Orthogonal Decomposition, POD) 基，使用从全阶模型 (FOM) 在所有加载步的解中获得的快照方法。使用由位移场的一致质量矩阵加权的 $L^2$ 内积（即内积 $(v,w)_M = v^T M w$，其中 $M$ 是与位移形函数和横截面积 $A$ 相关的一致有限元质量矩阵）。获得一个维度为 $r$ 的 $M$-正交归一的降阶基。\n\n为非线性平衡建立两个降阶模型 (ROM)：\n- 标准 Galerkin 投影：通过将 FOM 残差投影到降阶空间上来求解降阶非线性系统，其中测试空间等于试探空间，并使用 $M$-正交归一基。\n- 最小二乘 Petrov-Galerkin (LSPG) 投影：通过在降阶坐标中最小化 $M$ 加权的残差范数来求解降阶非线性系统，这将导致涉及残差雅可比矩阵的正规方程。\n\n对于这两个 ROM，执行相同的加载步序列，并使用 ROM 解在每个步骤计算总势能 $E(u)$。通过计算定义为如下的均方根 (RMS) 相对能量偏差，比较每个 ROM 在加载步中保持 FOM 机械能的优劣程度\n$$\n\\varepsilon_{\\mathrm{RMS}} = \\dfrac{\\sqrt{\\dfrac{1}{K} \\sum_{k=1}^K \\left(E_{\\mathrm{ROM}}^{(k)} - E_{\\mathrm{FOM}}^{(k)}\\right)^2}}{\\dfrac{1}{K} \\sum_{k=1}^K \\left|E_{\\mathrm{FOM}}^{(k)}\\right|},\n$$\n其中 $K$ 是加载步数，$E_{\\mathrm{FOM}}^{(k)}$ 是第 $k$ 步的全阶能量，$E_{\\mathrm{ROM}}^{(k)}$ 是所讨论方法在第 $k$ 步的降阶能量。报告标准 Galerkin 和最小二乘 Petrov-Galerkin 的 RMS 相对能量偏差。\n\n您的程序必须实现以下参数集的测试套件，涵盖典型情况、降阶基尺寸边界情况、更强非线性情况和更粗网格情况：\n\n- 案例 1 (典型情况)：$L = 1.0\\,\\mathrm{m}$，$A = 1.0\\times10^{-2}\\,\\mathrm{m}^2$，$E = 1.0\\times10^{6}\\,\\mathrm{Pa}$，$N = 30$，力从 $0$ 线性增加到 $P_{\\max} = 1000\\,\\mathrm{N}$ 的 $K = 25$ 个加载步，降阶维度 $r=6$。\n- 案例 2 (降阶基边界情况)：与案例 1 相同，但 $r=1$。\n- 案例 3 (更强非线性情况)：与案例 1 相同，但 $P_{\\max} = 5000\\,\\mathrm{N}$，$r=6$。\n- 案例 4 (更粗网格情况)：与案例 1 相同，但 $N = 8$，$r=6$。\n\n对于每个案例，计算并记录两个浮点数结果：标准 Galerkin ROM 和最小二乘 Petrov-Galerkin ROM 的 RMS 相对能量偏差。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序如下\n$$\n[\\varepsilon_{\\mathrm{G}}^{(1)}, \\varepsilon_{\\mathrm{LSPG}}^{(1)}, \\varepsilon_{\\mathrm{G}}^{(2)}, \\varepsilon_{\\mathrm{LSPG}}^{(2)}, \\varepsilon_{\\mathrm{G}}^{(3)}, \\varepsilon_{\\mathrm{LSPG}}^{(3)}, \\varepsilon_{\\mathrm{G}}^{(4)}, \\varepsilon_{\\mathrm{LSPG}}^{(4)}],\n$$\n其中上标指的是案例编号。将所有八个输出表示为十进制浮点数（无量纲），并确保它们是根据以焦耳为单位测量的能量计算得出的。\n\n您必须按照最终答案部分中的规定，提供一个完整的、可运行的程序，无需用户输入或外部文件。程序必须对连续模型进行数值近似，并生成所需的输出。本问题陈述中的所有数学实体都必须使用 $...$ 或 $$...$$ 分隔符以 LaTeX 格式书写，并且首字母缩略词必须在首次使用时定义（例如，本征正交分解 (Proper Orthogonal Decomposition, POD)，最小二乘 Petrov-Galerkin (LSPG)）。",
            "solution": "我们从准静态超弹性固体的基本平衡定律和定义开始。在参考（物质）构型中，静态平衡可以通过总势能的驻值性以弱形式陈述。对于位移场为 $u(X)$ 的一维杆，变形梯度为 $F(X) = \\dfrac{dx}{dX} = 1 + \\dfrac{du}{dX}$。对于超弹性材料，单位体积的应变能密度是 $F$ 的函数，记为 $W(F)$，第一 Piola-Kirchhoff 应力为 $P_1(F) = \\dfrac{dW}{dF}$。总势能为\n$$\nE(u) = \\int_0^L A\\, W(F)\\, dX - P\\, u(L),\n$$\n其中 $A$ 是横截面积，$P$ 是施加在右端的轴向力。平衡构型使 $E(u)$ 最小化，其必要条件是其一阶变分为零。\n\n我们采用 Green-Lagrange 应变 $E_{\\mathrm{GL}}(F) = \\dfrac{1}{2}(F^2 - 1)$，并取应变能密度为\n$$\nW(F) = \\dfrac{1}{2}\\, E \\, E_{\\mathrm{GL}}(F)^2,\n$$\n其中 $E$ 是一个弹性模量。这个选择产生了一个非线性但光滑的超弹性模型，能够表示一维的大变形。相关的第一 Piola-Kirchhoff 应力为\n$$\nP_1(F) = \\dfrac{dW}{dF} \n= \\dfrac{d}{dF} \\left( \\dfrac{1}{2} E \\left(\\dfrac{1}{2}(F^2 - 1)\\right)^2 \\right)\n= \\dfrac{1}{2} E \\left( F^3 - F \\right),\n$$\n以及一致切线模量为\n$$\nH(F) = \\dfrac{dP_1}{dF} = \\dfrac{1}{2} E \\left( 3 F^2 - 1 \\right).\n$$\n\n对于有限元离散化，将 $[0,L]$ 划分成 $N$ 个大小为 $h = \\dfrac{L}{N}$ 的均匀单元，节点为 $X_i = i h$, $i=0,\\dots,N$。在每个单元上使用线性形函数和节点自由度 $u_i$。强施加 $u_0 = 0$，剩下 $N$ 个自由未知数 $u_1,\\dots,u_N$。在连接节点 $i$ 和 $i+1$ 的单元上，位移是线性的，因此梯度 $\\dfrac{du}{dX}$ 是常数：$\\dfrac{du}{dX} = \\dfrac{u_{i+1} - u_i}{h}$，从而 $F = 1 + \\dfrac{u_{i+1} - u_i}{h}$。两个节点的单元对内力向量的贡献来自于 $\\int A W(F)\\,dX$ 的一阶变分，其形式为\n$$\n\\mathbf{f}_{\\mathrm{int}}^{(e)} = A\\, P_1(F)\\, \\begin{bmatrix} -1 \\\\ 1 \\end{bmatrix},\n$$\n因为 $F$ 对节点位移的敏感度为 $[\\partial F/\\partial u_i, \\partial F/\\partial u_{i+1}] = [-1/h, 1/h]$ 且单元长度为 $h$。一致单元切线矩阵为\n$$\n\\mathbf{K}^{(e)} = \\dfrac{A\\, H(F)}{h}\\, \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix}.\n$$\n组装这些贡献以获得全局内力向量 $\\mathbf{f}_{\\mathrm{int}}(\\mathbf{u})$ 和全局切线矩阵 $\\mathbf{K}(\\mathbf{u})$。外力向量除了在右端节点 $N$ 处为 $P$ 外，其他地方均为零。在施加 $u_0=0$ 后，提取自由部分的残差\n$$\n\\mathbf{r}(\\mathbf{u}_f) = \\mathbf{f}_{\\mathrm{int},f}(\\mathbf{u}_f) - \\mathbf{f}_{\\mathrm{ext},f},\n$$\n和自由部分的切线 $\\mathbf{K}_f(\\mathbf{u}_f)$，其中 $\\mathbf{u}_f = [u_1,\\dots,u_N]^T$，并且 $\\mathbf{f}_{\\mathrm{ext},f}$ 唯一非零分量是等于 $P$ 的最后一个条目。在每个加载步使用 Newton-Raphson 求解 $\\mathbf{r}(\\mathbf{u}_f)=\\mathbf{0}$：\n$$\n\\mathbf{K}_f(\\mathbf{u}_f^{(m)})\\, \\Delta \\mathbf{u}_f^{(m)} = - \\mathbf{r}(\\mathbf{u}_f^{(m)}), \\quad \\mathbf{u}_f^{(m+1)} = \\mathbf{u}_f^{(m)} + \\alpha^{(m)} \\Delta \\mathbf{u}_f^{(m)},\n$$\n其中，如果需要减小残差范数，可调整 $\\alpha^{(m)} \\in (0,1]$（回溯）。在给定载荷 $P$ 下的能量计算如下\n$$\nE(\\mathbf{u}_f) = \\sum_{e=1}^{N} A\\, h\\, W(F_e) - P\\, u_N,\n$$\n其中 $F_e$ 是单元 $e$ 上的变形梯度，$u_N$ 是右端的位移。\n\n对于本征正交分解 (POD)，将全阶位移快照收集到一个矩阵 $\\mathbf{S} \\in \\mathbb{R}^{n_f \\times K}$ 中，其中 $n_f=N$ 是自由度数量，$K$ 是加载步数。通过组装单元矩阵来定义位移空间的一致质量矩阵 $\\mathbf{M}$（使用单位密度，因为这里只需要空间加权）\n$$\n\\mathbf{M}^{(e)} = A \\int_{X_i}^{X_{i+1}} \\begin{bmatrix} N_1 \\\\ N_2 \\end{bmatrix} \\begin{bmatrix} N_1  N_2 \\end{bmatrix}\\, dX \n= A \\begin{bmatrix} \\dfrac{h}{3}  \\dfrac{h}{6} \\\\ \\dfrac{h}{6}  \\dfrac{h}{3} \\end{bmatrix}.\n$$\n提取自由部分 $\\mathbf{M}_f \\in \\mathbb{R}^{n_f \\times n_f}$。通过求解快照协方差的广义特征值问题来计算 POD 基\n$$\n\\mathbf{C} = \\mathbf{S}^T \\mathbf{M}_f \\mathbf{S}, \\quad \\mathbf{C}\\,\\mathbf{w}_i = \\lambda_i\\, \\mathbf{w}_i,\n$$\n按 $\\lambda_i>0$ 降序对特征对进行排序，并形成 $M$-正交归一基向量\n$$\n\\mathbf{v}_i = \\dfrac{1}{\\sqrt{\\lambda_i}} \\mathbf{S}\\, \\mathbf{w}_i,\n$$\n它们满足 $\\mathbf{v}_i^T \\mathbf{M}_f \\mathbf{v}_j = \\delta_{ij}$。将前 $r$ 个基向量堆叠成 $\\mathbf{V} \\in \\mathbb{R}^{n_f \\times r}$。\n\n对于标准 Galerkin 降阶模型，寻求降阶坐标 $\\mathbf{a} \\in \\mathbb{R}^r$，使得全位移近似为 $\\mathbf{u}_f \\approx \\mathbf{V}\\, \\mathbf{a}$，且残差与降阶空间正交，得到\n$$\n\\mathbf{V}^T\\, \\mathbf{r}(\\mathbf{V}\\mathbf{a}) = \\mathbf{0}.\n$$\n在降阶坐标中实现 Newton 法。链式法则给出降阶切线\n$$\n\\mathbf{K}_r(\\mathbf{a}) = \\mathbf{V}^T\\, \\mathbf{K}_f(\\mathbf{V}\\mathbf{a})\\, \\mathbf{V},\n$$\n并通过求解下式获得降阶 Newton 更新\n$$\n\\mathbf{K}_r(\\mathbf{a}^{(m)})\\, \\Delta \\mathbf{a}^{(m)} = - \\mathbf{V}^T\\, \\mathbf{r}(\\mathbf{V}\\mathbf{a}^{(m)}), \\quad \\mathbf{a}^{(m+1)} = \\mathbf{a}^{(m)} + \\alpha^{(m)} \\Delta \\mathbf{a}^{(m)}.\n$$\n\n对于最小二乘 Petrov-Galerkin (LSPG) 降阶模型，最小化 $M$-加权残差范数 $\\|\\mathbf{r}(\\mathbf{V}\\mathbf{a})\\|_{\\mathbf{M}_f} = \\sqrt{\\mathbf{r}^T \\mathbf{M}_f \\mathbf{r}}$。Gauss-Newton 条件给出正规方程\n$$\n\\left[ (\\mathbf{J}_r(\\mathbf{a}))^T \\mathbf{M}_f\\, \\mathbf{J}_r(\\mathbf{a}) \\right] \\Delta \\mathbf{a}\n= - (\\mathbf{J}_r(\\mathbf{a}))^T \\mathbf{M}_f\\, \\mathbf{r}(\\mathbf{V}\\mathbf{a}),\n$$\n其中 $\\mathbf{J}_r(\\mathbf{a}) = \\dfrac{\\partial \\mathbf{r}}{\\partial \\mathbf{u}_f}(\\mathbf{V}\\mathbf{a})\\, \\mathbf{V} = \\mathbf{K}_f(\\mathbf{V}\\mathbf{a})\\, \\mathbf{V}$。如有必要，使用回溯法更新 $\\mathbf{a}$ 以减小加权残差范数。\n\n对于这两个 ROM，在每个加载步计算降阶位移 $\\mathbf{u}_f^{\\mathrm{ROM}}$ 和相应的能量 $E_{\\mathrm{ROM}}$。通过计算跨越 $K$ 个加载步的均方根相对能量偏差，来比较降阶能量与全阶能量 $E_{\\mathrm{FOM}}$：\n$$\n\\varepsilon_{\\mathrm{RMS}} = \\dfrac{\\sqrt{\\dfrac{1}{K} \\sum_{k=1}^K \\left(E_{\\mathrm{ROM}}^{(k)} - E_{\\mathrm{FOM}}^{(k)}\\right)^2}}{\\dfrac{1}{K} \\sum_{k=1}^K \\left|E_{\\mathrm{FOM}}^{(k)}\\right|}.\n$$\n\n程序算法设计：\n- 定义用于内力和切线的网格和组装例程，在每个单元上使用 $P_1(F) = \\dfrac{1}{2}E(F^3 - F)$ 和 $H(F) = \\dfrac{1}{2}E(3F^2 - 1)$，其中 $F = 1 + \\dfrac{u_{i+1}-u_i}{h}$。\n- 实现全阶 Newton 求解器，在 $K$ 个加载步上将 $P$ 从 $0$ 增加到 $P_{\\max}$，初始猜测为 $\\mathbf{u}_f=\\mathbf{0}$ 并从上一步热启动。在更新中包含一个小的对角正则化和简单的回溯法以提高鲁棒性。\n- 使用规定的单元公式组装位移空间的一致质量矩阵 $\\mathbf{M}_f$，并从全阶快照中计算维度为 $r$ 的质量加权 POD 基 $\\mathbf{V}$。\n- 实现 Galerkin ROM Newton 求解器和 LSPG ROM Gauss-Newton 求解器，在相同的加载步上进行求解，并通过质量加权投影 $\\mathbf{a}_0 = \\mathbf{V}^T \\mathbf{M}_f \\mathbf{u}_f^{\\text{prev}}$ 初始化降阶坐标。\n- 在每个步骤中为 FOM 和每个 ROM 计算能量（以焦耳为单位）。为每个案例计算两个 ROM 的 RMS 相对能量偏差。\n- 执行问题陈述中指定的四个案例，并将八个结果浮点值作为单个逗号分隔的列表输出，并用方括号括起来。\n\n所有计算均在国际单位制 (SI) 下进行：$L$ 单位为米，$A$ 单位为平方米，$E$ 单位为帕斯卡，力单位为牛顿，能量 $E(u)$ 单位为焦耳。最终打印的输出是无量纲的十进制数，用于量化降阶模型相对于全阶模型在所有加载步中的能量保持性能。\n\n此方法整合了超弹性、平衡的变分公式、有限元离散化、本征正交分解 (POD)、标准 Galerkin 投影和最小二乘 Petrov-Galerkin (LSPG) 的核心原理，旨在产生一个科学上合理且算法上清晰的比较，重点关注机械能 $E(u)$ 的保持情况。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef assemble_internal_and_tangent(u_free, L, A, E_mod, N, P_ext):\n    \"\"\"\n    Assemble internal force vector and tangent stiffness for the free dofs.\n    u_free: array of length N (nodes 1..N), with u0 = 0 fixed.\n    Returns residual r (size N), tangent K_ff (NxN), and energy computation utility can be separate.\n    \"\"\"\n    h = L / N\n    n_nodes = N + 1\n    # Full displacement including fixed left node\n    u_full = np.zeros(n_nodes)\n    u_full[1:] = u_free\n\n    f_full = np.zeros(n_nodes)\n    K_full = np.zeros((n_nodes, n_nodes))\n\n    # Loop over elements\n    for e in range(N):\n        i = e\n        j = e + 1\n        ui = u_full[i]\n        uj = u_full[j]\n        du_dx = (uj - ui) / h\n        F = 1.0 + du_dx\n        # First Piola stress and tangent for the chosen hyperelastic model\n        Pstress = 0.5 * E_mod * (F**3 - F)\n        Htan = 0.5 * E_mod * (3.0 * F**2 - 1.0)\n        # Element internal force contribution\n        f_e = A * Pstress * np.array([-1.0, 1.0])\n        f_full[i] += f_e[0]\n        f_full[j] += f_e[1]\n        # Element tangent contribution\n        Ke = (A * Htan / h) * np.array([[1.0, -1.0], [-1.0, 1.0]])\n        K_full[i:i+2, i:i+2] += Ke\n\n    # Extract free part\n    r = f_full[1:].copy()\n    # External force applied at the right end node N (index N in full, index N-1 in free)\n    r[-1] -= P_ext\n    K_ff = K_full[1:, 1:]\n    return r, K_ff\n\ndef compute_energy(u_free, L, A, E_mod, N, P_ext):\n    \"\"\"\n    Compute total potential energy E(u) = sum_e A*h*W(F_e) - P_ext * u(L).\n    \"\"\"\n    h = L / N\n    n_nodes = N + 1\n    u_full = np.zeros(n_nodes)\n    u_full[1:] = u_free\n    U_int = 0.0\n    for e in range(N):\n        i = e\n        j = e + 1\n        ui = u_full[i]\n        uj = u_full[j]\n        du_dx = (uj - ui) / h\n        F = 1.0 + du_dx\n        EGL = 0.5 * (F**2 - 1.0)\n        W = 0.5 * E_mod * (EGL**2)\n        U_int += A * h * W\n    U_ext = P_ext * u_full[-1]\n    E_total = U_int - U_ext\n    return E_total\n\ndef newton_fom(L, A, E_mod, N, P_values, tol=1e-10, max_iter=60):\n    \"\"\"\n    Full-order model Newton solve across load steps.\n    Returns snapshots matrix S (N x K), energies list E_fom (length K).\n    \"\"\"\n    n_free = N\n    K_steps = len(P_values)\n    S = np.zeros((n_free, K_steps))\n    E_fom = []\n    u_free = np.zeros(n_free)\n    # Solve for each load step\n    for k, Pk in enumerate(P_values):\n        # Warm start from previous step\n        # Newton iterations\n        for it in range(max_iter):\n            r, K = assemble_internal_and_tangent(u_free, L, A, E_mod, N, Pk)\n            rn = np.linalg.norm(r)\n            if rn  tol:\n                break\n            # Regularization\n            reg = 1e-12\n            K_reg = K + reg * np.eye(n_free)\n            try:\n                du = np.linalg.solve(K_reg, -r)\n            except np.linalg.LinAlgError:\n                # Fallback: add stronger regularization\n                K_reg = K + 1e-8 * np.eye(n_free)\n                du = np.linalg.solve(K_reg, -r)\n            # Backtracking line search on residual norm\n            alpha = 1.0\n            u_trial = u_free + alpha * du\n            r_trial, _ = assemble_internal_and_tangent(u_trial, L, A, E_mod, N, Pk)\n            rn_trial = np.linalg.norm(r_trial)\n            bt_count = 0\n            while rn_trial > rn and bt_count  10:\n                alpha *= 0.5\n                u_trial = u_free + alpha * du\n                r_trial, _ = assemble_internal_and_tangent(u_trial, L, A, E_mod, N, Pk)\n                rn_trial = np.linalg.norm(r_trial)\n                bt_count += 1\n            u_free = u_trial\n        # Save snapshot and energy\n        S[:, k] = u_free\n        E_fom.append(compute_energy(u_free, L, A, E_mod, N, Pk))\n    return S, np.array(E_fom)\n\ndef assemble_mass_matrix(L, A, N):\n    \"\"\"\n    Assemble consistent mass matrix M for displacement space (unit density weighting).\n    Returns free-part M_ff of size N x N.\n    \"\"\"\n    h = L / N\n    n_nodes = N + 1\n    M_full = np.zeros((n_nodes, n_nodes))\n    Me = A * np.array([[h/3.0, h/6.0],\n                       [h/6.0, h/3.0]])\n    for e in range(N):\n        i = e\n        j = e + 1\n        M_full[i:i+2, i:i+2] += Me\n    M_ff = M_full[1:, 1:]\n    return M_ff\n\ndef pod_mass_weighted(S, M_ff, r_dim, eig_tol=1e-14):\n    \"\"\"\n    Compute mass-weighted POD basis V (n_free x r_dim) with V^T M_ff V = I.\n    \"\"\"\n    # Covariance\n    C = S.T @ M_ff @ S\n    # Symmetric eigen-decomposition\n    evals, evecs = np.linalg.eigh(C)\n    # Sort descending\n    idx = np.argsort(evals)[::-1]\n    evals = evals[idx]\n    evecs = evecs[:, idx]\n    # Filter positive eigenvalues\n    pos = evals > eig_tol\n    evals = evals[pos]\n    evecs = evecs[:, pos]\n    r_eff = min(r_dim, evecs.shape[1])\n    if r_eff == 0:\n        # No variance; return zeros basis (should not happen with nontrivial snapshots)\n        return np.zeros((S.shape[0], 0))\n    evecs_r = evecs[:, :r_eff]\n    evals_r = evals[:r_eff]\n    # Build basis vectors: v_i = 1/sqrt(lambda_i) * S w_i\n    V = S @ (evecs_r / np.sqrt(evals_r))\n    return V\n\ndef project_initial(V, M_ff, u_free):\n    \"\"\"\n    Mass-weighted projection of full displacement onto reduced coordinates: a0 = V^T M u.\n    Assumes V^T M V = I.\n    \"\"\"\n    return V.T @ (M_ff @ u_free)\n\ndef rom_galerkin(L, A, E_mod, N, P_values, V, M_ff, tol=1e-10, max_iter=60):\n    \"\"\"\n    Standard Galerkin ROM solve across load steps.\n    Returns reduced energies list E_rom (length K).\n    \"\"\"\n    K_steps = len(P_values)\n    n_free = N\n    r = V.shape[1]\n    a = np.zeros(r)\n    E_rom = []\n    u_free_prev = np.zeros(n_free)\n    for k, Pk in enumerate(P_values):\n        # Warm start from projection of previous FOM/ROM solution\n        a = project_initial(V, M_ff, u_free_prev)\n        # Newton in reduced coordinates\n        for it in range(max_iter):\n            u = V @ a\n            r_full, K_full = assemble_internal_and_tangent(u, L, A, E_mod, N, Pk)\n            r_red = V.T @ r_full\n            rn = np.linalg.norm(r_red)\n            if rn  tol:\n                break\n            K_red = V.T @ (K_full @ V)\n            # Regularization\n            reg = 1e-12\n            K_red_reg = K_red + reg * np.eye(r)\n            try:\n                da = np.linalg.solve(K_red_reg, -r_red)\n            except np.linalg.LinAlgError:\n                K_red_reg = K_red + 1e-8 * np.eye(r)\n                da = np.linalg.solve(K_red_reg, -r_red)\n            # Backtracking on full residual norm\n            alpha = 1.0\n            a_trial = a + alpha * da\n            u_trial = V @ a_trial\n            r_trial, _ = assemble_internal_and_tangent(u_trial, L, A, E_mod, N, Pk)\n            rn_trial = np.linalg.norm(r_trial)\n            rn_full = np.linalg.norm(r_full)\n            bt_count = 0\n            while rn_trial > rn_full and bt_count  10:\n                alpha *= 0.5\n                a_trial = a + alpha * da\n                u_trial = V @ a_trial\n                r_trial, _ = assemble_internal_and_tangent(u_trial, L, A, E_mod, N, Pk)\n                rn_trial = np.linalg.norm(r_trial)\n                bt_count += 1\n            a = a_trial\n        u_sol = V @ a\n        E_rom.append(compute_energy(u_sol, L, A, E_mod, N, Pk))\n        u_free_prev = u_sol\n    return np.array(E_rom)\n\ndef rom_lspg(L, A, E_mod, N, P_values, V, M_ff, tol=1e-10, max_iter=60):\n    \"\"\"\n    Least-Squares Petrov-Galerkin ROM solve across load steps using Gauss-Newton normal equations.\n    Returns reduced energies list E_rom (length K).\n    \"\"\"\n    K_steps = len(P_values)\n    n_free = N\n    r = V.shape[1]\n    a = np.zeros(r)\n    E_rom = []\n    u_free_prev = np.zeros(n_free)\n    for k, Pk in enumerate(P_values):\n        # Warm start\n        a = project_initial(V, M_ff, u_free_prev)\n        for it in range(max_iter):\n            u = V @ a\n            r_full, K_full = assemble_internal_and_tangent(u, L, A, E_mod, N, Pk)\n            J_r = K_full @ V  # Jacobian of residual wrt reduced coords\n            # Normal equations: (J^T M J) da = - J^T M r\n            A_mat = J_r.T @ (M_ff @ J_r)\n            b_vec = J_r.T @ (M_ff @ r_full)\n            # Solve for increment\n            reg = 1e-12\n            A_reg = A_mat + reg * np.eye(r)\n            try:\n                da = -np.linalg.solve(A_reg, b_vec)\n            except np.linalg.LinAlgError:\n                A_reg = A_mat + 1e-8 * np.eye(r)\n                da = -np.linalg.solve(A_reg, b_vec)\n            # Backtracking on weighted residual norm\n            alpha = 1.0\n            r_weighted_norm = np.sqrt(r_full.T @ (M_ff @ r_full))\n            a_trial = a + alpha * da\n            u_trial = V @ a_trial\n            r_trial, _ = assemble_internal_and_tangent(u_trial, L, A, E_mod, N, Pk)\n            r_trial_weighted_norm = np.sqrt(r_trial.T @ (M_ff @ r_trial))\n            bt_count = 0\n            while r_trial_weighted_norm > r_weighted_norm and bt_count  10:\n                alpha *= 0.5\n                a_trial = a + alpha * da\n                u_trial = V @ a_trial\n                r_trial, _ = assemble_internal_and_tangent(u_trial, L, A, E_mod, N, Pk)\n                r_trial_weighted_norm = np.sqrt(r_trial.T @ (M_ff @ r_trial))\n                bt_count += 1\n            a = a_trial\n            # Convergence check on weighted residual norm\n            if r_trial_weighted_norm  tol:\n                break\n        u_sol = V @ a\n        E_rom.append(compute_energy(u_sol, L, A, E_mod, N, Pk))\n        u_free_prev = u_sol\n    return np.array(E_rom)\n\ndef rms_relative_energy_error(E_rom, E_fom, tiny=1e-16):\n    \"\"\"\n    Compute RMS relative energy deviation as specified.\n    \"\"\"\n    K = len(E_fom)\n    num = np.sqrt(np.mean((E_rom - E_fom)**2))\n    den = np.mean(np.abs(E_fom))\n    if den  tiny:\n        return float('nan')\n    return num / den\n\ndef run_case(L, A, E_mod, N, K_steps, P_max, r_dim):\n    # Load steps\n    P_values = np.linspace(0.0, P_max, K_steps)\n    # Full-order\n    S, E_fom = newton_fom(L, A, E_mod, N, P_values)\n    # Mass matrix for POD\n    M_ff = assemble_mass_matrix(L, A, N)\n    # POD basis\n    V = pod_mass_weighted(S, M_ff, r_dim)\n    # Galerkin ROM\n    E_g = rom_galerkin(L, A, E_mod, N, P_values, V, M_ff)\n    # LSPG ROM\n    E_lspg = rom_lspg(L, A, E_mod, N, P_values, V, M_ff)\n    # Errors\n    err_g = rms_relative_energy_error(E_g, E_fom)\n    err_l = rms_relative_energy_error(E_lspg, E_fom)\n    return err_g, err_l\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (L, A, E_mod, N, K_steps, P_max, r_dim)\n        (1.0, 1.0e-2, 1.0e6, 30, 25, 1000.0, 6),  # Case 1\n        (1.0, 1.0e-2, 1.0e6, 30, 25, 1000.0, 1),  # Case 2\n        (1.0, 1.0e-2, 1.0e6, 30, 25, 5000.0, 6),  # Case 3\n        (1.0, 1.0e-2, 1.0e6, 8,  25, 1000.0, 6),  # Case 4\n    ]\n\n    results = []\n    for case in test_cases:\n        L, A, E_mod, N, K_steps, P_max, r_dim = case\n        err_g, err_l = run_case(L, A, E_mod, N, K_steps, P_max, r_dim)\n        results.append(err_g)\n        results.append(err_l)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "本实践将带你探索模型降阶在数据驱动状态估计中的应用。你将学习如何利用从仿真快照中提取的POD基，仅根据少数几个传感器（“稀疏”测量）的读数来重构整个系统的高维位移场。练习的关键在于使用列主元QR分解这一经典算法来策略性地选择最优传感器位置，并实现“残缺POD”（Gappy POD）重构算法。通过这项练习，你将掌握将仿真模型与物理世界中的稀疏测量相结合的核心技术，这对于结构健康监测和数字孪生等领域至关重要。",
            "id": "3591686",
            "problem": "考虑一根一维线性弹性杆，其长度为 $L$，空间坐标为 $x \\in [0,L]$，杨氏模量 $E$ 和横截面积 $A$ 均为常数。设位移场为 $u(x)$，单位长度的体力为 $b(x;\\mu)$，其中 $\\mu \\in [0,1]$ 是一个标量参数。控制平衡方程的强形式为 $- \\dfrac{d}{dx}\\!\\left(EA \\dfrac{du}{dx}\\right) = b(x;\\mu)$，且该杆受到齐次狄利克雷边界条件 $u(0) = 0$ 和 $u(L) = 0$ 的约束。使用标准的伽辽金有限元法，在均匀网格上采用连续的分段线性形函数来离散化该问题，从而得到关于内部自由度的对称正定线性系统 $\\mathbf{K}\\mathbf{u} = \\mathbf{f}(\\mu)$，其中 $\\mathbf{u} \\in \\mathbb{R}^{n}$ 表示 $n$ 个内部节点的节点位移向量（两个边界节点因边界条件而被消除），$\\mathbf{K} \\in \\mathbb{R}^{n \\times n}$ 是刚度矩阵，$\\mathbf{f}(\\mu) \\in \\mathbb{R}^{n}$ 是由体力组装成的载荷向量。\n\n根据基本原理，每个长度为 $h$ 的单元的刚度矩阵由与内虚功相关的双线性形式给出，从而得到标准的双节点单元刚度 $\\mathbf{K}^{(e)} = \\dfrac{EA}{h} \\begin{bmatrix}1  -1 \\\\ -1  1 \\end{bmatrix}$，而单元载荷向量 $\\mathbf{f}^{(e)}(\\mu)$ 来自体力的虚功，其形式为 $\\int_{x_e}^{x_{e+1}} N_i(x)\\, b(x;\\mu)\\, dx$，其中 $N_i(x)$ 是单元形函数。相应地组装全局矩阵 $\\mathbf{K}$ 和全局向量 $\\mathbf{f}(\\mu)$。\n\n通过收集与参数值 $\\{\\mu_j\\}_{j=1}^{n_s}$ 对应的 $n_s$ 个位移解（快照）$\\mathbf{u}(\\mu_j)$ 来定义训练快照矩阵 $\\mathbf{S} \\in \\mathbb{R}^{n \\times n_s}$，因此 $\\mathbf{S} = [\\,\\mathbf{u}(\\mu_1)\\,\\cdots\\,\\mathbf{u}(\\mu_{n_s})\\,]$。通过提取 $\\mathbf{S}$ 的前 $r$ 个左奇异向量来构建一个秩为 $r$ 的本征正交分解 (Proper Orthogonal Decomposition, POD) 基，这些向量汇集在具有标准正交列的矩阵 $\\boldsymbol{\\Phi}_r \\in \\mathbb{R}^{n \\times r}$ 中。通过对 $\\mathbf{S}^\\top$ 执行列主元 QR 分解来选择 $m$ 个传感器位置（自由度），该分解返回一个对 $\\mathbf{S}$ 的行进行优先级排序的置换向量；将前 $m$ 个选定的行解释为传感器索引。令 $\\mathbf{C} \\in \\{0,1\\}^{m \\times n}$ 表示提取这些传感器条目的选择矩阵，因此对于一个状态 $\\mathbf{u}$，其传感器测量向量为 $\\mathbf{y} = \\mathbf{C}\\mathbf{u} \\in \\mathbb{R}^{m}$。\n\n给定一个新参数 $\\mu^\\star$，定义以下三个构造。\n\n1) 间隙本征正交分解 (gappy POD) 重构：通过寻找系数 $\\widehat{\\mathbf{a}} \\in \\mathbb{R}^{r}$，从稀疏传感器推断出近似解 $\\widehat{\\mathbf{u}} \\in \\mathbb{R}^{n}$，这些系数能够最小化测量数据与降阶基在传感器位置上的投影之间的残差，即求解 $\\min_{\\mathbf{a} \\in \\mathbb{R}^{r}} \\| \\mathbf{C}\\boldsymbol{\\Phi}_r \\mathbf{a} - \\mathbf{C}\\,\\mathbf{u}(\\mu^\\star) \\|_2$ 得到 $\\widehat{\\mathbf{a}}$，并设置 $\\widehat{\\mathbf{u}} = \\boldsymbol{\\Phi}_r \\widehat{\\mathbf{a}}$。\n\n2) 伽辽金降阶模型预测：通过求解降阶线性系统 $\\boldsymbol{\\Phi}_r^\\top \\mathbf{K} \\boldsymbol{\\Phi}_r \\,\\mathbf{a}_{\\mathrm{rom}}(\\mu^\\star) = \\boldsymbol{\\Phi}_r^\\top \\mathbf{f}(\\mu^\\star)$ 计算降阶坐标 $\\mathbf{a}_{\\mathrm{rom}}(\\mu^\\star) \\in \\mathbb{R}^{r}$，并设置 $\\mathbf{u}_{\\mathrm{rom}} = \\boldsymbol{\\Phi}_r \\mathbf{a}_{\\mathrm{rom}}(\\mu^\\star)$。\n\n3) 标量关注量：定义类柔度量 $q(\\mathbf{u};\\mu^\\star) := \\mathbf{u}^\\top \\mathbf{f}(\\mu^\\star)$。\n\n对于下方的每个测试用例，您必须执行以下任务：\n\n- 在具有 $N$ 个总节点（包括两个边界节点）的均匀网格上建立全阶模型，其中 $E = 1$，$A = 1$，$L = 1$，并在 $x=0$ 和 $x=L$ 处施加齐次狄利克雷边界条件。在每个单元中使用两点高斯求积从体力组装载荷向量。\n- 使用 $n_s$ 个训练参数 $\\{\\mu_j\\}_{j=1}^{n_s}$ 来组装快照矩阵 $\\mathbf{S}$。\n- 从 $\\mathbf{S}$ 计算秩为 $r$ 的 POD 基 $\\boldsymbol{\\Phi}_r$。\n- 对 $\\mathbf{S}^\\top$ 进行主元 QR 分解以对传感器索引进行排序并选择 $m$ 个传感器。\n- 对于指定的测试参数 $\\mu^\\star$，计算高保真解 $\\mathbf{u}(\\mu^\\star)$、间隙重构解 $\\widehat{\\mathbf{u}}$ 和伽辽金降阶解 $\\mathbf{u}_{\\mathrm{rom}}$。\n- 报告以下三个相对误差（所有答案均以小数表示）：\n  - 相对状态重构误差 $e_{\\text{state}} := \\dfrac{\\|\\widehat{\\mathbf{u}} - \\mathbf{u}(\\mu^\\star)\\|_2}{\\|\\mathbf{u}(\\mu^\\star)\\|_2}$。\n  - 间隙重构的关注量相对误差 $e_{q,\\text{gappy}} := \\dfrac{|q(\\widehat{\\mathbf{u}};\\mu^\\star) - q(\\mathbf{u}(\\mu^\\star);\\mu^\\star)|}{|q(\\mathbf{u}(\\mu^\\star);\\mu^\\star)|}$。\n  - 伽辽金降阶模型的关注量相对误差 $e_{q,\\text{rom}} := \\dfrac{|q(\\mathbf{u}_{\\mathrm{rom}};\\mu^\\star) - q(\\mathbf{u}(\\mu^\\star);\\mu^\\star)|}{|q(\\mathbf{u}(\\mu^\\star);\\mu^\\star)|}$。\n\n使用体力参数化\n$$\nb(x;\\mu) = c_1 \\sin(\\pi x) + c_2 \\sin(2\\pi x) + c_3 \\exp\\!\\left(-\\frac{(x-\\mu)^2}{2\\sigma^2}\\right),\n$$\n其中 $c_1 = 1$, $c_2 = \\tfrac{1}{2}$, $c_3 = 4$, 且 $\\sigma = 0.07$。设训练参数在 $[0.1,0.9]$ 区间内均匀分布，具体为 $\\mu_j = 0.1 + (j-1)\\Delta\\mu$，其中 $\\Delta\\mu = \\dfrac{0.8}{n_s-1}$，$j=1,\\dots,n_s$。所有测试用例均使用 $N=121$ 和 $n_s=21$。\n\n测试套件：\n- 用例 1：$r=8$, $m=12$, $\\mu^\\star = 0.37$。\n- 用例 2：$r=8$, $m=8$, $\\mu^\\star = 0.63$。\n- 用例 3：$r=8$, $m=25$, $\\mu^\\star = 0.51$。\n- 用例 4：$r=8$, $m=5$, $\\mu^\\star = 0.75$。\n- 用例 5：$r=5$, $m=8$, $\\mu^\\star = 0.42$。\n\n您的程序必须实现以上所有步骤，并为每个用例按顺序输出浮点数三元组 $[e_{\\text{state}}, e_{q,\\text{gappy}}, e_{q,\\text{rom}}]$。这三个值都是无量纲的。您的程序应生成单行输出，其中包含这些三元组以逗号分隔的列表，并用方括号括起来。例如，格式必须为\n$$\n\\big[\\,[e_{\\text{state}}^{(1)},e_{q,\\text{gappy}}^{(1)},e_{q,\\text{rom}}^{(1)}],\\dots,[e_{\\text{state}}^{(5)},e_{q,\\text{gappy}}^{(5)},e_{q,\\text{rom}}^{(5)}]\\,\\big].\n$$",
            "solution": "该问题要求对一维弹性杆进行涉及有限元法 (FEM)、本征正交分解 (POD) 及相关模型降阶技术的综合数值模拟与分析。该过程分为几个阶段：全阶模型 (FOM) 构建、快照收集、降阶模型 (ROM) 构建和误差评估。\n\n物理系统是一根长度为 $L=1$、杨氏模量为 $E=1$、横截面积为 $A=1$ 的线性弹性杆。在体力 $b(x;\\mu)$ 作用下，位移场 $u(x)$ 的控制方程是二阶常微分方程：\n$$\n- \\frac{d}{dx}\\!\\left(EA \\frac{du}{dx}\\right) = b(x;\\mu), \\quad x \\in [0, 1]\n$$\n其齐次狄利克雷边界条件为 $u(0)=0$ 和 $u(1)=0$。\n\n首先，我们使用伽辽金有限元法对空间域进行离散化。将域 $[0,1]$ 划分为 $N-1=120$ 个长度为 $h=1/120$ 的等尺寸单元，由 $N=121$ 个节点定义。我们使用连续的分段线性基函数（帽函数）。施加边界条件后，剩下 $n=N-2=119$ 个内部自由度。离散化后得到一个关于内部节点位移向量 $\\mathbf{u} \\in \\mathbb{R}^{n}$ 的线性方程组：\n$$\n\\mathbf{K}\\mathbf{u} = \\mathbf{f}(\\mu)\n$$\n此处，$\\mathbf{K} \\in \\mathbb{R}^{n \\times n}$ 是全局刚度矩阵，$\\mathbf{f}(\\mu) \\in \\mathbb{R}^{n}$ 是取决于参数 $\\mu$ 的全局载荷向量。\n\n刚度矩阵 $\\mathbf{K}$ 由单元刚度矩阵 $\\mathbf{K}^{(e)} = \\frac{EA}{h} \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix}$ 组装而成。对于内部节点，这会形成一个对称、三对角、正定的矩阵，其对角线元素为 $K_{ii} = \\frac{2EA}{h}$，次对角线元素为 $K_{i,i\\pm 1} = -\\frac{EA}{h}$。由于 $E=1$，$A=1$，且 $h=1/120$，因此对角线元素为 $240$，次对角线元素为 $-120$。\n\n载荷向量 $\\mathbf{f}(\\mu)$ 由单元贡献组装而成。对于内部节点 $i$，其对应的条目 $f_i(\\mu)$ 由体力 $b(x;\\mu)$ 乘以帽状基函数 $\\phi_i(x)$ 的积分给出：\n$$\nf_i(\\mu) = \\int_0^1 \\phi_i(x) b(x;\\mu) dx = \\int_{x_{i-1}}^{x_{i+1}} \\phi_i(x) b(x;\\mu) dx\n$$\n按照规定，此积分在每个相邻的两个单元上使用两点高斯求积进行数值计算。体力由以下公式给出：\n$$\nb(x;\\mu) = c_1 \\sin(\\pi x) + c_2 \\sin(2\\pi x) + c_3 \\exp\\!\\left(-\\frac{(x-\\mu)^2}{2\\sigma^2}\\right)\n$$\n其中常数 $c_1=1$, $c_2=1/2$, $c_3=4$, 且 $\\sigma=0.07$。\n\n在建立全阶模型 (FOM) 后，我们通过求解在 $[0.1, 0.9]$ 区间内均匀分布的一组训练参数 $\\{\\mu_j\\}_{j=1}^{n_s}$ 对应的 FOM，生成 $n_s=21$ 个“快照”。得到的位移向量（快照）$\\mathbf{u}(\\mu_j)$ 作为快照矩阵 $\\mathbf{S} \\in \\mathbb{R}^{n \\times n_s}$ 的列进行收集。\n\n接下来，我们使用本征正交分解 (Proper Orthogonal Decomposition, POD) 为解流形构建一个低维基，这等效于对快照矩阵 $\\mathbf{S} = \\mathbf{U}\\boldsymbol{\\Sigma}\\mathbf{V}^\\top$ 执行奇异值分解 (Singular Value Decomposition, SVD)。秩为 $r$ 的 POD 基，记为 $\\boldsymbol{\\Phi}_r \\in \\mathbb{R}^{n \\times r}$，由 $\\mathbf{S}$ 的前 $r$ 个左奇异向量（即 $\\mathbf{U}$ 的前 $r$ 列）组成。这些向量构成一个标准正交基，能以最优方式捕捉快照的能量。\n\n传感器位置通过基于 $\\mathbf{S}^\\top$ 的列主元 QR 分解的贪心算法确定。该过程选择 $\\mathbf{S}$ 的 $m$ 个行索引（对应自由度），这些行提供了关于快照的最线性无关的信息。这 $m$ 个索引定义了传感器位置，并用于构建选择矩阵 $\\mathbf{C} \\in \\{0,1\\}^{m \\times n}$。\n\n对于给定的测试参数 $\\mu^\\star$，我们评估解 $\\mathbf{u}(\\mu^\\star)$ 的三种不同近似：\n1. 高保真解 $\\mathbf{u}(\\mu^\\star)$，通过求解全阶系统 $\\mathbf{K}\\mathbf{u}(\\mu^\\star)=\\mathbf{f}(\\mu^\\star)$ 获得。此解作为“基准真相”。\n2. 间隙 POD 重构解 $\\widehat{\\mathbf{u}}$。它从稀疏测量值 $\\mathbf{y} = \\mathbf{C}\\mathbf{u}(\\mu^\\star)$ 近似完整状态。状态被近似为 POD 基向量的线性组合，$\\widehat{\\mathbf{u}} = \\boldsymbol{\\Phi}_r \\widehat{\\mathbf{a}}$，其中系数 $\\widehat{\\mathbf{a}} \\in \\mathbb{R}^r$ 通过求解最小二乘问题找到：\n$$\n\\widehat{\\mathbf{a}} = \\arg\\min_{\\mathbf{a} \\in \\mathbb{R}^{r}} \\| \\mathbf{C}\\boldsymbol{\\Phi}_r \\mathbf{a} - \\mathbf{y} \\|_2\n$$\n3. 伽辽金 ROM 预测解 $\\mathbf{u}_{\\mathrm{rom}}$。该解通过将控制 FOM 方程投影到 POD 基上找到。解写为 $\\mathbf{u}_{\\mathrm{rom}} = \\boldsymbol{\\Phi}_r \\mathbf{a}_{\\mathrm{rom}}$，其中降阶坐标 $\\mathbf{a}_{\\mathrm{rom}} \\in \\mathbb{R}^r$ 是一个规模小得多的 $r \\times r$ 线性系统的解：\n$$\n\\mathbf{K}_r \\mathbf{a}_{\\mathrm{rom}} = \\mathbf{f}_r(\\mu^\\star), \\quad \\text{where} \\quad \\mathbf{K}_r = \\boldsymbol{\\Phi}_r^\\top \\mathbf{K} \\boldsymbol{\\Phi}_r \\quad \\text{and} \\quad \\mathbf{f}_r(\\mu^\\star) = \\boldsymbol{\\Phi}_r^\\top \\mathbf{f}(\\mu^\\star)\n$$\n\n最后，对每个测试用例，我们计算三个相对误差。首先是间隙 POD 的状态重构误差：\n$$\ne_{\\text{state}} = \\frac{\\|\\widehat{\\mathbf{u}} - \\mathbf{u}(\\mu^\\star)\\|_2}{\\|\\mathbf{u}(\\mu^\\star)\\|_2}\n$$\n其次和第三，是标量关注量 (QoI) 的相对误差，该关注量定义为柔度 $q(\\mathbf{u};\\mu^\\star) = \\mathbf{u}^\\top \\mathbf{f}(\\mu^\\star)$，分别针对间隙 POD 解和伽辽金 ROM 解计算：\n$$\ne_{q,\\text{gappy}} = \\frac{|q(\\widehat{\\mathbf{u}};\\mu^\\star) - q(\\mathbf{u}(\\mu^\\star);\\mu^\\star)|}{|q(\\mathbf{u}(\\mu^\\star);\\mu^\\star)|}, \\quad e_{q,\\text{rom}} = \\frac{|q(\\mathbf{u}_{\\mathrm{rom}};\\mu^\\star) - q(\\mathbf{u}(\\mu^\\star);\\mu^\\star)|}{|q(\\mathbf{u}(\\mu^\\star);\\mu^\\star)|}\n$$\n对问题陈述中指定的五个测试用例中的每一个都执行这些计算。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import qr, svd\n\ndef solve():\n    \"\"\"\n    Solves the model reduction problem for a 1D elastic bar.\n\n    The function implements the following steps:\n    1. Sets up the finite element model (FEM) for the bar.\n    2. Generates solution snapshots for a range of parameters.\n    3. Computes a Proper Orthogonal Decomposition (POD) basis from the snapshots.\n    4. Determines optimal sensor locations using column-pivoted QR factorization.\n    5. For each test case, it computes:\n        a. The high-fidelity FEM solution.\n        b. A gappy POD reconstruction from sparse sensor data.\n        c. A Galerkin reduced-order model (ROM) prediction.\n    6. Calculates and reports the relative errors for state reconstruction and a quantity of interest.\n    \"\"\"\n    \n    # --- 1. Model and Simulation Parameters ---\n    N = 121         # Total number of nodes\n    L = 1.0         # Length of the bar\n    E = 1.0         # Young's modulus\n    A = 1.0         # Cross-sectional area\n    n = N - 2       # Number of interior nodes (degrees of freedom)\n    h = L / (N - 1) # Element length\n    nodes = np.linspace(0, L, N) # Nodal coordinates\n\n    # Body force function parameters\n    c1, c2, c3, sigma = 1.0, 0.5, 4.0, 0.07\n\n    def body_force(x, mu):\n        term1 = c1 * np.sin(np.pi * x)\n        term2 = c2 * np.sin(2 * np.pi * x)\n        term3 = c3 * np.exp(-(x - mu)**2 / (2 * sigma**2))\n        return term1 + term2 + term3\n\n    # --- 2. Full-Order Model (FEM) Assembly ---\n    # Stiffness Matrix K\n    K_diag = 2.0 * E * A / h\n    K_offdiag = -E * A / h\n    K = np.diag(np.full(n, K_diag, dtype=np.float64)) + \\\n        np.diag(np.full(n - 1, K_offdiag, dtype=np.float64), k=1) + \\\n        np.diag(np.full(n - 1, K_offdiag, dtype=np.float64), k=-1)\n    \n    # Gaussian quadrature points and weights for 2-point rule\n    gauss_pts = np.array([-1.0/np.sqrt(3.0), 1.0/np.sqrt(3.0)], dtype=np.float64)\n    gauss_wts = np.array([1.0, 1.0], dtype=np.float64)\n    \n    def assemble_force_vector(mu):\n        f = np.zeros(n, dtype=np.float64)\n        # N1 and N2 are shape functions on the reference element [-1, 1]\n        N1_vals = (1.0 - gauss_pts) / 2.0\n        N2_vals = (1.0 + gauss_pts) / 2.0\n\n        for i in range(1, N - 1): # Iterate over interior nodes\n            node_idx = i - 1\n            \n            # Contribution from left element (element i-1)\n            # Node i is the 2nd node of this element -> use shape function N2\n            xq_left = nodes[i - 1] + (h / 2.0) * (1.0 + gauss_pts)\n            integral_left = (h / 2.0) * np.sum(gauss_wts * N2_vals * body_force(xq_left, mu))\n            \n            # Contribution from right element (element i)\n            # Node i is the 1st node of this element -> use shape function N1\n            xq_right = nodes[i] + (h / 2.0) * (1.0 + gauss_pts)\n            integral_right = (h / 2.0) * np.sum(gauss_wts * N1_vals * body_force(xq_right, mu))\n            \n            f[node_idx] = integral_left + integral_right\n        return f\n\n    # --- 3. Snapshot Generation ---\n    n_s = 21\n    mu_train = np.linspace(0.1, 0.9, n_s, dtype=np.float64)\n    S = np.zeros((n, n_s), dtype=np.float64)\n    for j in range(n_s):\n        f_j = assemble_force_vector(mu_train[j])\n        u_j = np.linalg.solve(K, f_j)\n        S[:, j] = u_j\n\n    # --- 4. SVD and QR Pre-computation ---\n    U, _, _ = svd(S, full_matrices=False)\n    _, _, P = qr(S.T, pivoting=True, mode='economic')\n\n    # --- 5. Test Suite Execution ---\n    test_cases = [\n        (8, 12, 0.37),\n        (8, 8, 0.63),\n        (8, 25, 0.51),\n        (8, 5, 0.75),\n        (5, 8, 0.42),\n    ]\n\n    results = []\n    for r, m, mu_star in test_cases:\n        # Get POD basis of rank r\n        Phi_r = U[:, :r]\n        \n        # Get m sensor locations\n        sensor_indices = P[:m]\n        \n        # Compute high-fidelity solution for mu_star\n        f_star = assemble_force_vector(mu_star)\n        u_hifi = np.linalg.solve(K, f_star)\n        u_hifi_norm = np.linalg.norm(u_hifi)\n        \n        # Gappy POD Reconstruction\n        C_Phi_r = Phi_r[sensor_indices, :]\n        y_meas = u_hifi[sensor_indices]\n        a_hat, _, _, _ = np.linalg.lstsq(C_Phi_r, y_meas, rcond=None)\n        u_gappy = Phi_r @ a_hat\n\n        # Galerkin ROM Prediction\n        K_r = Phi_r.T @ K @ Phi_r\n        f_r = Phi_r.T @ f_star\n        a_rom = np.linalg.solve(K_r, f_r)\n        u_rom = Phi_r @ a_rom\n        \n        # Quantities of Interest (QoI)\n        q_hifi = u_hifi @ f_star\n        q_gappy = u_gappy @ f_star\n        q_rom = u_rom @ f_star\n        q_hifi_abs = np.abs(q_hifi)\n\n        # Compute relative errors\n        e_state = np.linalg.norm(u_gappy - u_hifi) / u_hifi_norm\n        e_q_gappy = np.abs(q_gappy - q_hifi) / q_hifi_abs\n        e_q_rom = np.abs(q_rom - q_hifi) / q_hifi_abs\n        \n        results.append([e_state, e_q_gappy, e_q_rom])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}