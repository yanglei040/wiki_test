{
    "hands_on_practices": [
        {
            "introduction": "热力学第二定律是一条不可违背的物理约束，任何本构模型，无论是源于第一性原理还是从数据中学习得到，都必须遵守。本练习将引导你亲手实践如何数值上检验这一基本约束，即克劳修斯-杜亥姆不等式 。通过对不同候选能量函数（包括有效和无效的例子）进行测试，你将掌握一个验证材料模型物理合理性的关键工具。",
            "id": "3557155",
            "problem": "给定离散的、按时间排序的小应变张量和柯西应力张量的测量值，表示为数对集合 $\\{(\\boldsymbol{\\varepsilon}_k,\\boldsymbol{\\sigma}_k)\\}_{k=0}^N$，其中每个 $\\boldsymbol{\\varepsilon}_k$ 和 $\\boldsymbol{\\sigma}_k$ 都是对称的 $3\\times 3$ 张量。在小应变假设和等温条件下，连续介质层面的机械耗散的克劳修斯-杜亥姆不等式 (CDI) 指出，单位体积的耗散率满足 $\\boldsymbol{\\sigma}:\\dot{\\boldsymbol{\\varepsilon}} - \\dot{\\psi} \\ge 0$，其中 $\\psi$ 是亥姆霍兹自由能密度。在采用后向差分的离散时间设置中，这得到了分段离散耗散\n$$\n\\mathcal{D}_k = \\boldsymbol{\\sigma}_k : \\left( \\boldsymbol{\\varepsilon}_k - \\boldsymbol{\\varepsilon}_{k-1} \\right) - \\left[ \\psi(\\boldsymbol{\\varepsilon}_k) - \\psi(\\boldsymbol{\\varepsilon}_{k-1}) \\right],\n$$\n以及整个历史过程中的累积耗散\n$$\n\\mathcal{D}_{\\mathrm{tot}} = \\sum_{k=1}^N \\mathcal{D}_k.\n$$\n二阶张量的双点积 $:$ 定义为 $\\mathbf{A}:\\mathbf{B} = \\sum_{i=1}^3\\sum_{j=1}^3 A_{ij}B_{ij}$，弗罗贝尼乌斯范数满足 $\\|\\mathbf{A}\\|_F^2 = \\mathbf{A}:\\mathbf{A}$。\n\n您的任务是实现一个程序，对于给定的候选能量密度 $\\psi(\\boldsymbol{\\varepsilon})$，计算几个测试历史的分段离散耗散 $\\mathcal{D}_k$ 和累积耗散 $\\mathcal{D}_{\\mathrm{tot}}$，并验证所有分段 $k=1,\\dots,N$ 的非负性条件 $\\mathcal{D}_k \\ge 0$。离散耗散是单位体积的能量，必须以帕斯卡 (Pa) 为单位表示。您必须使用 $10^{-12}\\,\\mathrm{Pa}$ 的数值容差来检查非负性，也就是说，如果 $\\mathcal{D}_k \\ge -10^{-12}\\,\\mathrm{Pa}$，则将该分段视为非负。\n\n实现以下候选能量密度：\n- 各向同性线弹性势能，其拉梅参数为 $\\lambda>0$ 和 $\\mu>0$，\n$$\n\\psi_{\\mathrm{lin}}(\\boldsymbol{\\varepsilon};\\lambda,\\mu) = \\tfrac{1}{2}\\lambda \\left(\\mathrm{tr}\\,\\boldsymbol{\\varepsilon}\\right)^2 + \\mu\\, \\boldsymbol{\\varepsilon}:\\boldsymbol{\\varepsilon}.\n$$\n- 四次凸函数能量，其系数为 $\\alpha \\ge 0$ 和 $\\beta > 0$，\n$$\n\\psi_{\\mathrm{quartic}}(\\boldsymbol{\\varepsilon};\\alpha,\\beta) = \\alpha\\, \\|\\boldsymbol{\\varepsilon}\\|_F^2 + \\beta\\, \\|\\boldsymbol{\\varepsilon}\\|_F^4.\n$$\n- 凹二次函数能量（热力学上不可接受），其系数为 $\\alpha>0$，\n$$\n\\psi_{\\mathrm{concave}}(\\boldsymbol{\\varepsilon};\\alpha) = -\\alpha\\, \\|\\boldsymbol{\\varepsilon}\\|_F^2.\n$$\n对于测量应力与所选 $\\psi$ 一致的测试用例，使用 $\\boldsymbol{\\sigma}_k = \\partial \\psi/\\partial \\boldsymbol{\\varepsilon}\\,\\big|_{\\boldsymbol{\\varepsilon}_k}$，其梯度如下：\n- 对于 $\\psi_{\\mathrm{lin}}$：$\\boldsymbol{\\sigma} = \\lambda\\,\\mathrm{tr}(\\boldsymbol{\\varepsilon})\\,\\mathbf{I} + 2\\mu\\,\\boldsymbol{\\varepsilon}$，其中 $\\mathbf{I}$ 是单位张量。\n- 对于 $\\psi_{\\mathrm{quartic}}$：$\\boldsymbol{\\sigma} = 2\\alpha\\,\\boldsymbol{\\varepsilon} + 4\\beta\\,\\|\\boldsymbol{\\varepsilon}\\|_F^2\\,\\boldsymbol{\\varepsilon}$。\n- 对于 $\\psi_{\\mathrm{concave}}$：$\\boldsymbol{\\sigma} = -2\\alpha\\,\\boldsymbol{\\varepsilon}$。\n\n此外，包括一个测试用例，其中测量应力取自屈服应力为 $\\sigma_y>0$ 的理想化单轴弹塑性响应。在这种情况下，限制在单轴应变路径上，其中 $\\varepsilon_{11}\\neq 0$ 且所有其他应变分量均为零，并将测量应力定义为\n$$\n\\sigma_{11,k} = \\mathrm{sign}(\\varepsilon_{11,k}) \\,\\min\\!\\left( E_{\\mathrm{eff}}\\, \\varepsilon_{11,k},\\, \\sigma_y \\right), \\quad \\sigma_{ij,k}=0 \\;\\text{for}\\; (i,j)\\neq(1,1),\n$$\n其中 $E_{\\mathrm{eff}} = \\lambda + 2\\mu$ 是与该测试中使用的各向同性线弹性 $\\psi_{\\mathrm{lin}}$ 相关联的有效单轴模量，$\\mathrm{sign}(\\cdot)$ 表示符号函数。\n\n测试套件。为确保科学覆盖范围，请使用以下四个历史和参数：\n\n1. 具有一致应力的凸二次函数能量（理想路径）。使用 $\\psi_{\\mathrm{lin}}$，其中 $\\lambda = 6.0\\times 10^{10}\\,\\mathrm{Pa}$ 且 $\\mu = 4.0\\times 10^{10}\\,\\mathrm{Pa}$。设 $N=4$ 且\n$$\n\\boldsymbol{\\varepsilon}_0 = \\begin{bmatrix} 0  0  0 \\\\ 0  0  0 \\\\ 0  0  0 \\end{bmatrix},\\;\n\\boldsymbol{\\varepsilon}_1 = \\begin{bmatrix} 1.0\\times 10^{-3}  1.5\\times 10^{-4}  0 \\\\ 1.5\\times 10^{-4}  -2.0\\times 10^{-4}  5.0\\times 10^{-5} \\\\ 0  5.0\\times 10^{-5}  3.0\\times 10^{-4} \\end{bmatrix},\n$$\n$$\n\\boldsymbol{\\varepsilon}_2 = \\begin{bmatrix} 2.0\\times 10^{-3}  1.0\\times 10^{-4}  -1.0\\times 10^{-4} \\\\ 1.0\\times 10^{-4}  4.0\\times 10^{-4}  2.0\\times 10^{-5} \\\\ -1.0\\times 10^{-4}  2.0\\times 10^{-5}  1.0\\times 10^{-3} \\end{bmatrix},\n\\quad\n\\boldsymbol{\\varepsilon}_3 = \\begin{bmatrix} 1.5\\times 10^{-3}  0  0 \\\\ 0  1.0\\times 10^{-3}  0 \\\\ 0  0  5.0\\times 10^{-4} \\end{bmatrix},\n$$\n$$\n\\boldsymbol{\\varepsilon}_4 = \\begin{bmatrix} 1.5\\times 10^{-3}  2.0\\times 10^{-5}  -1.0\\times 10^{-5} \\\\ 2.0\\times 10^{-5}  1.2\\times 10^{-3}  0 \\\\ -1.0\\times 10^{-5}  0  4.0\\times 10^{-4} \\end{bmatrix}.\n$$\n使用 $\\boldsymbol{\\sigma}_k = \\partial \\psi_{\\mathrm{lin}}/\\partial \\boldsymbol{\\varepsilon}\\,\\big|_{\\boldsymbol{\\varepsilon}_k}$。\n\n2. 具有一致应力的凹二次函数能量（显示违规的边界情况）。使用 $\\psi_{\\mathrm{concave}}$，其中 $\\alpha = 1.0\\times 10^{9}\\,\\mathrm{Pa}$。设 $N=3$ 且\n$$\n\\boldsymbol{\\varepsilon}_0 = \\begin{bmatrix} 0  0  0 \\\\ 0  0  0 \\\\ 0  0  0 \\end{bmatrix},\\;\n\\boldsymbol{\\varepsilon}_1 = \\begin{bmatrix} 3.0\\times 10^{-3}  0  0 \\\\ 0  0  0 \\\\ 0  0  0 \\end{bmatrix},\n$$\n$$\n\\boldsymbol{\\varepsilon}_2 = \\begin{bmatrix} 6.0\\times 10^{-3}  0  0 \\\\ 0  -2.0\\times 10^{-3}  0 \\\\ 0  0  1.0\\times 10^{-3} \\end{bmatrix},\\quad\n\\boldsymbol{\\varepsilon}_3 = \\begin{bmatrix} 2.0\\times 10^{-3}  0  0 \\\\ 0  2.0\\times 10^{-3}  0 \\\\ 0  0  -1.0\\times 10^{-3} \\end{bmatrix}.\n$$\n使用 $\\boldsymbol{\\sigma}_k = \\partial \\psi_{\\mathrm{concave}}/\\partial \\boldsymbol{\\varepsilon}\\,\\big|_{\\boldsymbol{\\varepsilon}_k}$。\n\n3. 具有重复状态的四次凸函数能量（零增量的边界情况）。使用 $\\psi_{\\mathrm{quartic}}$，其中 $\\alpha = 2.5\\times 10^{8}\\,\\mathrm{Pa}$ 且 $\\beta = 5.0\\times 10^{11}\\,\\mathrm{Pa}$。设 $N=4$ 且\n$$\n\\boldsymbol{\\varepsilon}_0 = \\begin{bmatrix} 0  0  0 \\\\ 0  0  0 \\\\ 0  0  0 \\end{bmatrix},\\;\n\\boldsymbol{\\varepsilon}_1 = \\begin{bmatrix} -1.0\\times 10^{-3}  2.0\\times 10^{-4}  0 \\\\ 2.0\\times 10^{-4}  -1.0\\times 10^{-3}  0 \\\\ 0  0  -1.0\\times 10^{-3} \\end{bmatrix},\n$$\n$$\n\\boldsymbol{\\varepsilon}_2 = \\boldsymbol{\\varepsilon}_1,\\quad\n\\boldsymbol{\\varepsilon}_3 = \\begin{bmatrix} -2.0\\times 10^{-3}  3.0\\times 10^{-4}  0 \\\\ 3.0\\times 10^{-4}  -5.0\\times 10^{-4}  1.0\\times 10^{-4} \\\\ 0  1.0\\times 10^{-4}  -2.0\\times 10^{-4} \\end{bmatrix},\n$$\n$$\n\\boldsymbol{\\varepsilon}_4 = \\begin{bmatrix} -2.5\\times 10^{-3}  0  0 \\\\ 0  -1.0\\times 10^{-3}  0 \\\\ 0  0  0 \\end{bmatrix}.\n$$\n使用 $\\boldsymbol{\\sigma}_k = \\partial \\psi_{\\mathrm{quartic}}/\\partial \\boldsymbol{\\varepsilon}\\,\\big|_{\\boldsymbol{\\varepsilon}_k}$。\n\n4. 使用测量的弹塑性应力的弹性势能（显示潜在违规的边界情况）。使用 $\\psi_{\\mathrm{lin}}$，其中 $\\lambda = 6.0\\times 10^{10}\\,\\mathrm{Pa}$ 且 $\\mu = 4.0\\times 10^{10}\\,\\mathrm{Pa}$，屈服应力 $\\sigma_y = 1.0\\times 10^{8}\\,\\mathrm{Pa}$。设 $N=3$ 并考虑单轴应变路径\n$$\n\\boldsymbol{\\varepsilon}_0 = \\mathbf{0},\\quad\n\\boldsymbol{\\varepsilon}_1 = \\begin{bmatrix} 5.0\\times 10^{-4}  0  0 \\\\ 0  0  0 \\\\ 0  0  0 \\end{bmatrix},\\quad\n\\boldsymbol{\\varepsilon}_2 = \\begin{bmatrix} 1.0\\times 10^{-3}  0  0 \\\\ 0  0  0 \\\\ 0  0  0 \\end{bmatrix},\\quad\n\\boldsymbol{\\varepsilon}_3 = \\begin{bmatrix} 2.0\\times 10^{-3}  0  0 \\\\ 0  0  0 \\\\ 0  0  0 \\end{bmatrix},\n$$\n且测量应力由上述理想弹塑性法则给出，其中 $E_{\\mathrm{eff}}=\\lambda+2\\mu$。\n\n程序要求。您的程序必须：\n- 实现上述 $\\psi$ 函数，并在指定之处实现相应的应力函数。\n- 对每个测试用例，计算所有分段耗散值 $\\mathcal{D}_k$ 和累积耗散值 $\\mathcal{D}_{\\mathrm{tot}}$（以帕斯卡为单位）。\n- 使用 $10^{-12}\\,\\mathrm{Pa}$ 的容差验证每个分段的非负性条件，并报告该测试用例中的所有分段是否均为非负。\n- 生成单行输出，其中包含一个方括号内的逗号分隔列表形式的结果，顺序为 $[\\mathcal{D}_{\\mathrm{tot}}^{(1)},\\mathrm{all\\_nonneg}^{(1)},\\mathcal{D}_{\\mathrm{tot}}^{(2)},\\mathrm{all\\_nonneg}^{(2)},\\mathcal{D}_{\\mathrm{tot}}^{(3)},\\mathrm{all\\_nonneg}^{(3)},\\mathcal{D}_{\\mathrm{tot}}^{(4)},\\mathrm{all\\_nonneg}^{(4)}]$，其中 $\\mathcal{D}_{\\mathrm{tot}}^{(i)}$ 是一个以帕斯卡为单位的浮点数，$\\mathrm{all\\_nonneg}^{(i)}$ 是一个布尔值，指示测试用例 $i$ 中的所有分段是否满足 $\\mathcal{D}_k \\ge -10^{-12}\\,\\mathrm{Pa}$。",
            "solution": "问题陈述被评估为有效。它在科学上基于连续介质力学的原理，特别是克劳修斯-杜亥姆不等式对材料行为施加的热力学约束。该问题是适定的，为直接计算求解提供了所有必要的数据、参数和函数形式。定义和测试用例清晰、客观且自洽。\n\n问题的核心是针对几种材料模型和加载历史，验证克劳修斯-杜亥姆不等式 (CDI) 的离散形式。在等温力学过程的背景下，CDI 指出耗散率必须为非负。其对于从步骤 $k-1$ 到 $k$ 的时间段的离散对应形式由下式给出：\n$$\n\\mathcal{D}_k = \\boldsymbol{\\sigma}_k : (\\boldsymbol{\\varepsilon}_k - \\boldsymbol{\\varepsilon}_{k-1}) - \\left[ \\psi(\\boldsymbol{\\varepsilon}_k) - \\psi(\\boldsymbol{\\varepsilon}_{k-1}) \\right] \\ge 0\n$$\n其中 $\\boldsymbol{\\varepsilon}_k$ 是小应变张量，$\\boldsymbol{\\sigma}_k$ 是柯西应力张量，而 $\\psi$ 是亥姆霍兹自由能密度。上述条件必须对每个分段 $k=1, \\dots, N$ 都成立。整个历史过程中的总耗散是其总和 $\\mathcal{D}_{\\mathrm{tot}} = \\sum_{k=1}^N \\mathcal{D}_k$。\n\n计算过程涉及实现给定的亥姆霍兹自由能密度 $\\psi$ 的候选函数以及相应的应力张量 $\\boldsymbol{\\sigma}$。对于每个测试用例，程序将遍历所提供的按时间排序的应变历史 $\\{\\boldsymbol{\\varepsilon}_k\\}$。在每个分段中，它计算增量功 $\\boldsymbol{\\sigma}_k : (\\boldsymbol{\\varepsilon}_k - \\boldsymbol{\\varepsilon}_{k-1})$ 和储存能量的变化 $\\psi(\\boldsymbol{\\varepsilon}_k) - \\psi(\\boldsymbol{\\varepsilon}_{k-1})$，并随后计算耗散 $\\mathcal{D}_k$。\n\n该实现将高度依赖于数值张量代数，`numpy` 库非常适合此任务。张量 $\\boldsymbol{\\varepsilon}$ 和 $\\boldsymbol{\\sigma}$ 表示为 $3\\times3$ 的 `numpy` 数组。所需的基本张量运算包括：\n- 迹, $\\mathrm{tr}\\,\\boldsymbol{\\varepsilon} = \\sum_{i=1}^3 \\varepsilon_{ii}$。\n- 双点积, $\\mathbf{A}:\\mathbf{B} = \\sum_{i,j} A_{ij}B_{ij}$，这等效于逐元素乘积后求和。\n- 弗罗贝尼乌斯范数的平方, $\\|\\mathbf{A}\\|_F^2 = \\mathbf{A}:\\mathbf{A}$。\n\n让我们分析每个测试用例的理论预期：\n\n1.  **各向同性线弹性势能 ($\\psi_{\\mathrm{lin}}$)**：能量函数 $\\psi_{\\mathrm{lin}}(\\boldsymbol{\\varepsilon}) = \\frac{1}{2}\\lambda (\\mathrm{tr}\\,\\boldsymbol{\\varepsilon})^2 + \\mu\\, \\boldsymbol{\\varepsilon}:\\boldsymbol{\\varepsilon}$ 是一个二次型。当拉梅参数 $\\lambda > 0$ 且 $\\mu > 0$ 时，此函数是严格凸的。应力由 $\\boldsymbol{\\sigma} = \\partial\\psi_{\\mathrm{lin}}/\\partial\\boldsymbol{\\varepsilon}$ 给出。在这种所谓的*超弹性*情况下，离散耗散 $\\mathcal{D}_k$ 等效于与凸函数 $\\psi$ 相关联的 Bregman 散度。\n    $$\n    \\mathcal{D}_k = \\frac{\\partial\\psi}{\\partial\\boldsymbol{\\varepsilon}}\\bigg|_{\\boldsymbol{\\varepsilon}_k} : (\\boldsymbol{\\varepsilon}_k - \\boldsymbol{\\varepsilon}_{k-1}) - (\\psi(\\boldsymbol{\\varepsilon}_k) - \\psi(\\boldsymbol{\\varepsilon}_{k-1}))\n    $$\n    由于 $\\psi$ 的凸性，该量保证为非负。实际上，对于像 $\\psi_{\\mathrm{lin}}$ 这样的二次函数，此表达式简化为 $\\mathcal{D}_k = \\psi_{\\mathrm{lin}}(\\boldsymbol{\\varepsilon}_k - \\boldsymbol{\\varepsilon}_{k-1})$。由于对于非零应变，$\\psi_{\\mathrm{lin}}$ 是正定的，我们预期 $\\mathcal{D}_k \\ge 0$，且仅当 $\\boldsymbol{\\varepsilon}_k = \\boldsymbol{\\varepsilon}_{k-1}$ 时等号成立。因此，预计所有分段都将满足 CDI。\n\n2.  **凹二次函数能量 ($\\psi_{\\mathrm{concave}}$)**：能量 $\\psi_{\\mathrm{concave}}(\\boldsymbol{\\varepsilon}) = -\\alpha\\, \\|\\boldsymbol{\\varepsilon}\\|_F^2$ (其中 $\\alpha>0$) 是严格凹的。对于稳定材料而言，这样的能量函数在热力学上是不可接受的。当 $\\boldsymbol{\\sigma} = \\partial\\psi_{\\mathrm{concave}}/\\partial\\boldsymbol{\\varepsilon}$ 时，直接计算可得：\n    $$\n    \\mathcal{D}_k = -\\alpha \\|\\boldsymbol{\\varepsilon}_k - \\boldsymbol{\\varepsilon}_{k-1}\\|_F^2\n    $$\n    由于 $\\alpha>0$ 且 $\\|\\cdot\\|_F^2$ 是非负的，$\\mathcal{D}_k$ 将是非正的。对于应变发生变化的任何分段（$\\boldsymbol{\\varepsilon}_k \\neq \\boldsymbol{\\varepsilon}_{k-1}$），我们预期会严格违反 CDI，即 $\\mathcal{D}_k < 0$。\n\n3.  **四次凸函数能量 ($\\psi_{\\mathrm{quartic}}$)**：函数 $\\psi_{\\mathrm{quartic}}(\\boldsymbol{\\varepsilon}) = \\alpha\\, \\|\\boldsymbol{\\varepsilon}\\|_F^2 + \\beta\\, \\|\\boldsymbol{\\varepsilon}\\|_F^4$ (其中 $\\alpha \\ge 0, \\beta > 0$) 是严格凸的。与第一种情况一样，该材料是超弹性的，$\\psi$ 的凸性确保了耗散 $\\mathcal{D}_k$ 是非负的。此测试用例中的一个分段由 $\\boldsymbol{\\varepsilon}_2 = \\boldsymbol{\\varepsilon}_1$ 定义，这意味着 $\\boldsymbol{\\varepsilon}_2 - \\boldsymbol{\\varepsilon}_1 = \\mathbf{0}$。对于此分段，耗散 $\\mathcal{D}_2$ 必须精确为零，我们的实现必须正确处理这一点。预计所有分段都将满足 CDI。\n\n4.  **具有塑性应力的弹性势能**：在这里，所选的能量函数 $\\psi_{\\mathrm{lin}}$ 仅表示能量储存中弹性的、可恢复的部分。然而，应力取自一个理想弹塑性模型，该模型包括不可恢复的（耗散性）变形。该应力不能从所选的 $\\psi$ 导出，即 $\\boldsymbol{\\sigma}_k \\neq \\partial\\psi_{\\mathrm{lin}}/\\partial\\boldsymbol{\\varepsilon}\\big|_{\\boldsymbol{\\varepsilon}_k}$。因此，计算出的量 $\\mathcal{D}_k$ 并不代表真实的物理耗散。该框架要求 $\\psi$ 是总亥姆霍兹自由能。通过使用一个不完整的 $\\psi$，计算出的非负性可能会被违反，并且在本例中这是预期的。具体来说，当材料屈服时，应力被限制在 $\\sigma_y$，而储存的弹性势能（通过 $\\psi_{\\mathrm{lin}}$ 和总应变 $\\boldsymbol{\\varepsilon}_k$ 计算）继续呈二次方增长。这种不匹配可能导致计算出的 $\\mathcal{D}_k < 0$。\n\n程序将被结构化以处理这些情况中的每一种。它将为每个 $\\psi$ 和 $\\boldsymbol{\\sigma}$ 定义函数。一个主循环将遍历四个测试套件，计算应力历史、分段耗散 $\\mathcal{D}_k$、累积耗散 $\\mathcal{D}_{\\mathrm{tot}}$，并根据给定的 $10^{-12}\\,\\mathrm{Pa}$ 容差验证非负性条件。最终结果将按指定的方式汇总和格式化。",
            "answer": "```python\nimport numpy as np\n\n# A meticulous and exacting professor in the STEM fields.\n\ndef solve():\n    \"\"\"\n    Computes and verifies discrete dissipation for several constitutive models.\n    \"\"\"\n    TOL = 1e-12\n\n    # Utility functions for tensor algebra\n    def double_dot(A, B):\n        \"\"\"Computes the double dot product of two 3x3 tensors.\"\"\"\n        return np.sum(A * B)\n\n    def frobenius_norm_sq(A):\n        \"\"\"Computes the squared Frobenius norm of a 3x3 tensor.\"\"\"\n        return double_dot(A, A)\n\n    # Candidate energy and stress functions\n    def psi_lin(eps, lam, mu):\n        \"\"\"Isotropic linear elastic energy density.\"\"\"\n        return 0.5 * lam * np.trace(eps)**2 + mu * double_dot(eps, eps)\n\n    def sigma_lin(eps, lam, mu):\n        \"\"\"Stress from isotropic linear elastic energy.\"\"\"\n        return lam * np.trace(eps) * np.eye(3) + 2 * mu * eps\n\n    def psi_quartic(eps, alpha, beta):\n        \"\"\"Quartic convex energy density.\"\"\"\n        norm_sq = frobenius_norm_sq(eps)\n        return alpha * norm_sq + beta * norm_sq**2\n\n    def sigma_quartic(eps, alpha, beta):\n        \"\"\"Stress from quartic convex energy.\"\"\"\n        norm_sq = frobenius_norm_sq(eps)\n        return 2 * alpha * eps + 4 * beta * norm_sq * eps\n\n    def psi_concave(eps, alpha):\n        \"\"\"Concave quadratic energy density.\"\"\"\n        return -alpha * frobenius_norm_sq(eps)\n\n    def sigma_concave(eps, alpha):\n        \"\"\"Stress from concave quadratic energy.\"\"\"\n        return -2 * alpha * eps\n\n    # --- Test Suite Setup ---\n\n    # Case 1: Convex quadratic energy with consistent stress\n    case1_params = {'lam': 6.0e10, 'mu': 4.0e10}\n    case1_eps_hist = [\n        np.array([[0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]]),\n        np.array([[1.0e-3, 1.5e-4, 0.0], [1.5e-4, -2.0e-4, 5.0e-5], [0.0, 5.0e-5, 3.0e-4]]),\n        np.array([[2.0e-3, 1.0e-4, -1.0e-4], [1.0e-4, 4.0e-4, 2.0e-5], [-1.0e-4, 2.0e-5, 1.0e-3]]),\n        np.array([[1.5e-3, 0.0, 0.0], [0.0, 1.0e-3, 0.0], [0.0, 0.0, 5.0e-4]]),\n        np.array([[1.5e-3, 2.0e-5, -1.0e-5], [2.0e-5, 1.2e-3, 0.0], [-1.0e-5, 0.0, 4.0e-4]])\n    ]\n\n    # Case 2: Concave quadratic energy with consistent stress\n    case2_params = {'alpha': 1.0e9}\n    case2_eps_hist = [\n        np.array([[0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]]),\n        np.array([[3.0e-3, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]]),\n        np.array([[6.0e-3, 0.0, 0.0], [0.0, -2.0e-3, 0.0], [0.0, 0.0, 1.0e-3]]),\n        np.array([[2.0e-3, 0.0, 0.0], [0.0, 2.0e-3, 0.0], [0.0, 0.0, -1.0e-3]])\n    ]\n\n    # Case 3: Quartic convex energy with a repeated state\n    case3_params = {'alpha': 2.5e8, 'beta': 5.0e11}\n    _eps1_case3 = np.array([[-1.0e-3, 2.0e-4, 0.0], [2.0e-4, -1.0e-3, 0.0], [0.0, 0.0, -1.0e-3]])\n    case3_eps_hist = [\n        np.array([[0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]]),\n        _eps1_case3,\n        _eps1_case3.copy(),\n        np.array([[-2.0e-3, 3.0e-4, 0.0], [3.0e-4, -5.0e-4, 1.0e-4], [0.0, 1.0e-4, -2.0e-4]]),\n        np.array([[-2.5e-3, 0.0, 0.0], [0.0, -1.0e-3, 0.0], [0.0, 0.0, 0.0]])\n    ]\n\n    # Case 4: Elastic energy with measured elastic-perfectly plastic stress\n    case4_params = {'lam': 6.0e10, 'mu': 4.0e10, 'sigma_y': 1.0e8}\n    case4_eps_hist = [\n        np.array([[0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]]),\n        np.array([[5.0e-4, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]]),\n        np.array([[1.0e-3, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]]),\n        np.array([[2.0e-3, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]])\n    ]\n    \n    test_suite = [\n        {'psi_func': psi_lin, 'sigma_type': 'consistent', 'sigma_func': sigma_lin, 'params': case1_params, 'eps_hist': case1_eps_hist},\n        {'psi_func': psi_concave, 'sigma_type': 'consistent', 'sigma_func': sigma_concave, 'params': case2_params, 'eps_hist': case2_eps_hist},\n        {'psi_func': psi_quartic, 'sigma_type': 'consistent', 'sigma_func': sigma_quartic, 'params': case3_params, 'eps_hist': case3_eps_hist},\n        {'psi_func': psi_lin, 'sigma_type': 'plastic', 'params': case4_params, 'eps_hist': case4_eps_hist}\n    ]\n\n    results = []\n\n    for case in test_suite:\n        eps_hist = case['eps_hist']\n        params = case['params']\n        psi_func = case['psi_func']\n        N = len(eps_hist) - 1\n        \n        # Generate stress history\n        sigma_hist = [np.zeros((3, 3))] * (N + 1)\n        if case['sigma_type'] == 'consistent':\n            sigma_func = case['sigma_func']\n            sigma_hist = [sigma_func(eps, **params) for eps in eps_hist]\n        elif case['sigma_type'] == 'plastic':\n            lam, mu, sigma_y = params['lam'], params['mu'], params['sigma_y']\n            E_eff = lam + 2 * mu\n            temp_sigma_hist = []\n            for k in range(N + 1):\n                eps_k = eps_hist[k]\n                stress_k = np.zeros((3, 3))\n                if k > 0:\n                    eps11_k = eps_k[0, 0]\n                    sigma11_elastic = E_eff * eps11_k\n                    sigma11_k = np.sign(eps11_k) * min(abs(sigma11_elastic), sigma_y)\n                    stress_k[0, 0] = sigma11_k\n                temp_sigma_hist.append(stress_k)\n            sigma_hist = temp_sigma_hist\n\n        # Calculate dissipation\n        d_total = 0.0\n        all_nonneg = True\n        \n        for k in range(1, N + 1):\n            eps_k = eps_hist[k]\n            eps_km1 = eps_hist[k-1]\n            sigma_k = sigma_hist[k]\n\n            work_inc = double_dot(sigma_k, eps_k - eps_km1)\n            psi_k = psi_func(eps_k, **{p: v for p, v in params.items() if p not in ['sigma_y']})\n            psi_km1 = psi_func(eps_km1, **{p: v for p, v in params.items() if p not in ['sigma_y']})\n            \n            d_k = work_inc - (psi_k - psi_km1)\n            d_total += d_k\n            \n            if d_k  -TOL:\n                all_nonneg = False\n        \n        results.extend([d_total, str(all_nonneg).lower()])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "继热力学一致性之后，材料框架无关性（即客观性）是连续介质力学的另一块基石，它确保材料的响应独立于观察者的刚体转动。本练习将展示一种强大而简洁的方法，通过构造来强制模型满足客观性：在主拉伸这一不变量空间中学习本构关系，并通过谱分解重构完整的应力张量 。你还将学习使用“对抗性旋转”这一现代验证技术，来检测模型中可能存在的“不变性泄漏”。",
            "id": "3557115",
            "problem": "要求您实现并验证一个数据驱动的本构模型，该模型通过在主伸长变量中进行训练并通过谱映射重构应力，从而强制实现材料框架无关性（客观性）。目标是 (i) 使用一个仅依赖于客观量的共享函数形式，学习从主伸长到主应力的映射，(ii) 使用谱分解为任意变形重构完整的柯西应力张量，以及 (iii) 设计并评估对抗性旋转，以量化所学模型的任何不变性泄漏。\n\n从以下基本原理开始：\n- 材料框架无关性要求对于所有正常正交旋转 $Q \\in \\mathbb{R}^{3 \\times 3}$（其中 $\\det(Q) = 1$），柯西应力映射 $\\sigma$ 满足 $\\sigma(QF) = Q \\, \\sigma(F) \\, Q^{\\mathsf{T}}$，此条件对每个变形梯度 $F \\in \\mathbb{R}^{3 \\times 3}$（其中 $\\det(F)  0$）均成立。\n- 极分解表明 $F = R U$，其中 $R \\in \\mathbb{R}^{3 \\times 3}$ 是一个正常旋转，$U \\in \\mathbb{R}^{3 \\times 3}$ 是右伸长张量，它是对称正定的。\n- 左柯西-格林张量为 $B = F F^{\\mathsf{T}}$，其特征值为 $\\beta_i$，其标准正交特征向量定义了主方向。主伸长为 $\\lambda_i = \\sqrt{\\beta_i}$，雅可比行列式为 $J = \\lambda_1 \\lambda_2 \\lambda_3$。\n- 定义基尔霍夫应力 $\\tau = J \\, \\sigma$。对于各向同性弹性材料，$\\tau$ 和 $B$ 可交换并共享特征向量。主基尔霍夫应力 $\\tau_i$ 可以通过各向同性本构关系，用主伸长 $\\lambda_i$ 和 $J$ 来表示。\n\n使用以下经过充分检验的本构定律（在一致的无量纲单位下）来生成监督训练信号和基准真值比较：\n- 对于剪切模量为 $\\mu$、体积模量为 $\\kappa$ 的可压缩 Neo-Hookean 材料，其柯西应力为\n$$\n\\sigma(F) = \\frac{\\mu}{J}\\left(B - I\\right) + \\kappa \\left(J - 1\\right) I,\n$$\n其中 $I$ 是单位张量。因此，主基尔霍夫应力满足\n$$\n\\tau_i = \\mu\\left(\\lambda_i^2 - 1\\right) + \\kappa \\, J \\left(J - 1\\right).\n$$\n\n您的任务：\n1. 设计一个小型数据驱动本构模型，该模型将主伸长映射到主基尔霍夫应力，并通过构造强制实现客观性：\n   - 使用输入 $x_i = \\ln(\\lambda_i)$ 和体积耦合变量 $s = \\sum_{j=1}^3 x_j = \\ln(J)$。\n   - 对每个主分量采用一个共享线性模型，其形式如下，且在 $i \\in \\{1,2,3\\}$ 上具有相同的参数\n   $$\n   \\widehat{\\tau}_i = w_1 \\, \\exp(2 x_i) + w_2 \\cdot 1 + w_3 \\, \\exp(2 s) + w_4 \\, \\exp(s),\n   $$\n   这确保了主方向的置换等变处理，并通过 $s$ 耦合了偏响应和体积响应。使用从给定本构定律采样的合成训练数据，通过最小二乘法拟合参数向量 $w \\in \\mathbb{R}^4$。\n2. 对于给定的变形 $F$，按如下方式重构完整的预测柯西应力张量：\n   - 计算 $B = F F^{\\mathsf{T}}$ 并获取其谱分解以恢复主方向和主伸长 $\\lambda_i = \\sqrt{\\beta_i}$，其中 $J = \\lambda_1 \\lambda_2 \\lambda_3$。\n   - 在主伸长上评估所学模型 $\\widehat{\\tau}_i$，并组装预测的基尔霍夫应力张量 $\\widehat{\\tau} = \\sum_{i=1}^3 \\widehat{\\tau}_i \\, v_i \\otimes v_i$，其中 $v_i$ 是 $B$ 的特征向量。\n   - 返回预测的柯西应力 $\\widehat{\\sigma} = \\widehat{\\tau} / J$。\n3. 提出对抗性旋转以评估所学模型的不变性泄漏：\n   - 对于一个固定的伸长张量 $U = \\mathrm{diag}(\\lambda_1,\\lambda_2,\\lambda_3)$ 和一个选定的参考旋转 $R_{\\text{ref}}$，构造 $F_1 = R_{\\text{ref}} U$。\n   - 对于多个以弧度为单位随机采样的旋转 $Q_k$，定义 $F_{2,k} = Q_k F_1$ 并计算所学得的应力 $\\widehat{\\sigma}(F_1)$ 和 $\\widehat{\\sigma}(F_{2,k})$。\n   - 将每个 $k$ 的不变性泄漏度量定义为\n   $$\n   \\mathcal{L}_k = \\frac{\\left\\| \\widehat{\\sigma}(F_{2,k}) - Q_k \\, \\widehat{\\sigma}(F_1) \\, Q_k^{\\mathsf{T}} \\right\\|_F}{\\left\\| \\widehat{\\sigma}(F_1) \\right\\|_F + \\epsilon},\n   $$\n   其中 $\\|\\cdot\\|_F$ 表示弗罗贝尼乌斯范数，$\\epsilon$ 是一个小的正数以避免除以零。报告每个测试用例在对抗性集合上的最大泄漏 $\\max_k \\mathcal{L}_k$。\n\n训练数据协议：\n- 通过从均值为 $0$、标准差为 $0.4$ 的正态分布中抽取 $x_i = \\ln(\\lambda_i)$ 来采样 $N_{\\text{train}} = 256$ 个独立的主伸长三元组，然后设置 $\\lambda_i = \\exp(x_i)$，$J = \\prod_i \\lambda_i$。使用上述 Neo-Hookean 定律（参数为 $\\mu = 2.0$ 和 $\\kappa = 10.0$）计算精确的目标值 $\\tau_i$，并通过对所有主分量合并进行最小二乘拟合来得到 $w$。\n- 使用固定的随机种子以使采样和训练过程具有确定性。\n\n对抗性旋转生成：\n- 通过在单位球面上均匀选择一个随机轴和在 $[0, \\pi)$ 弧度范围内均匀选择一个随机角度，然后通过罗德里格斯公式构造 $Q_k$ 来采样 $K = 25$ 个随机旋转 $Q_k$。使用确定性种子，以使结果可复现。\n\n测试套件：\n- 使用三个测试用例，每个用例都有预设的主伸长以及固定的参考旋转轴和角度。在所有情况下，参考旋转轴与 $(1,1,1)$ 成比例并被归一化，参考旋转角度为 $\\alpha = 1.234$ 弧度。\n  1. 用例 A（中等近等容）：$\\lambda = (1.10, 0.95, 0.96)$。\n  2. 用例 B（大各向异性）：$\\lambda = (1.60, 0.70, 1.30)$。\n  3. 用例 C（近简并方向）：$\\lambda = (1.00, 1.00, 1.05)$。\n- 对于每个用例：\n  - 构造 $U = \\mathrm{diag}(\\lambda)$ 和 $F_1 = R_{\\text{ref}} U$。\n  - 使用给定的本构定律计算真实柯西应力，并使用所学模型计算预测的柯西应力。报告相对弗罗贝尼乌斯误差\n  $$\n  e = \\frac{\\left\\|\\widehat{\\sigma}(F_1) - \\sigma(F_1)\\right\\|_F}{\\left\\|\\sigma(F_1)\\right\\|_F}.\n  $$\n  - 计算在上述定义的 $K$ 个对抗性旋转上的最大不变性泄漏 $\\max_k \\mathcal{L}_k$。\n\n角度单位说明：\n- 所有角度必须以弧度为单位。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个长度为 $6$、用方括号括起来的逗号分隔列表，顺序如下\n  $$\n  [e_A, \\max \\mathcal{L}_A, e_B, \\max \\mathcal{L}_B, e_C, \\max \\mathcal{L}_C],\n  $$\n  其中 $e_{\\cdot}$ 是基础变形 $F_1$ 的相对弗罗贝尼乌斯误差，$\\max \\mathcal{L}_{\\cdot}$ 是每种情况下对抗性旋转下的最大不变性泄漏。输出条目是无单位的实数（浮点数），必须以十进制形式表示。",
            "solution": "该问题是有效的。它在科学上基于连续介质力学的原理，问题定义清晰，具有明确和确定性的程序来获得唯一解，并使用客观、正式的语言进行描述。这些任务与数据驱动计算力学领域相关，并涉及模型训练、预测和验证的非平凡实现。\n\n解决方案按规定分为三个主要部分：(1) 训练一个数据驱动的本构模型，(2) 实现一个基于谱分解的应力重构算法，以及 (3) 使用对抗性旋转评估模型的材料框架无关性。\n\n### 第一部分：本构模型训练\n\n目标是学习从主伸长 $\\lambda_i$到主基尔霍夫应力 $\\tau_i$ 的映射。基准真值关系由可压缩 Neo-Hookean 模型给出，其剪切模量 $\\mu = 2.0$，体积模量 $\\kappa = 10.0$：\n$$\n\\tau_i = \\mu\\left(\\lambda_i^2 - 1\\right) + \\kappa \\, J \\left(J - 1\\right)\n$$\n其中 $J = \\lambda_1 \\lambda_2 \\lambda_3$ 是雅可比行列式。\n\n所提出的数据驱动模型是主基尔霍夫应力 $\\widehat{\\tau}_i$ 的一个线性模型：\n$$\n\\widehat{\\tau}_i = w_1 \\, \\exp(2 x_i) + w_2 \\cdot 1 + w_3 \\, \\exp(2 s) + w_4 \\, \\exp(s)\n$$\n其中 $x_i = \\ln(\\lambda_i)$ 且 $s = \\sum_j x_j = \\ln(J)$。代入这些定义后，模型形式变为：\n$$\n\\widehat{\\tau}_i = w_1 \\lambda_i^2 + w_2 + w_3 J^2 + w_4 J\n$$\n这种形式是合适的选择，因为它是真实定律 $\\tau_i = \\mu \\lambda_i^2 - \\mu + \\kappa J^2 - \\kappa J$ 中出现的项的线性组合。我们期望学习到的权重将近似于 $w_1 \\approx \\mu$、$w_2 \\approx -\\mu$、$w_3 \\approx \\kappa$ 和 $w_4 \\approx -\\kappa$。\n\n训练使用合成数据集进行。$N_{\\text{train}} = 256$ 个主伸长样本是通过首先从正态分布 $\\mathcal{N}(0, 0.4^2)$ 中抽取对数伸长 $x_i$ 来生成的。然后，主伸长为 $\\lambda_i = \\exp(x_i)$。对于每组 $(\\lambda_1, \\lambda_2, \\lambda_3)$，目标主应力 $(\\tau_1, \\tau_2, \\tau_3)$都使用 Neo-Hookean 公式计算。\n\n参数向量 $w = [w_1, w_2, w_3, w_4]^{\\mathsf{T}}$ 通过求解形式为 $A w = b$ 的线性最小二乘问题来确定。来自所有 $N_{\\text{train}}$ 个样本的全部 3 个主方向的数据被汇集在一起，得到 $3 \\times N_{\\text{train}} = 768$ 个数据点。设计矩阵 $A$ 的大小为 $(768, 4)$，目标向量 $b$ 的大小为 $(768, 1)$。对于每个对应于样本 $j$ 和主方向 $i$ 的数据点 $k$，$A$ 和 $b$ 的行结构如下：\n$$\nA_k = [\\lambda_{j,i}^2, \\quad 1, \\quad J_j^2, \\quad J_j], \\quad b_k = \\tau_{j,i}\n$$\n该系统使用 `numpy.linalg.lstsq` 求解 $w$。固定的随机种子确保了训练数据以及因此学习到的权重 $w$ 的可复现性。\n\n### 第二部分：应力张量重构\n\n所学习的模型作用于主伸长，它们是标量不变量。为了预测任意变形梯度 $F$ 的完整柯西应力张量 $\\widehat{\\sigma}$，我们使用谱重构方法。这个过程内在地强制了材料框架无关性。\n\n给定一个变形梯度 $F$，且 $\\det(F)  0$：\n1.  计算左柯西-格林张量 $B = F F^{\\mathsf{T}}$。$B$ 是对称正定的。\n2.  对 $B$ 进行谱分解，以找到其特征值 $\\beta_i$ 和相应的标准正交特征向量 $v_i$。即 $B = \\sum_{i=1}^3 \\beta_i v_i \\otimes v_i$。\n3.  主伸长是 $B$ 的特征值的平方根：$\\lambda_i = \\sqrt{\\beta_i}$。特征向量 $v_i$ 定义了空间构型中的主伸长方向。对特征值进行排序以保持一致的顺序，例如 $\\lambda_1 \\le \\lambda_2 \\le \\lambda_3$。\n4.  雅可比行列式计算为 $J = \\lambda_1 \\lambda_2 \\lambda_3$。\n5.  学习到的模型 $\\widehat{\\tau}_i(w, \\lambda_1, \\lambda_2, \\lambda_3)$ 被用来预测主基尔霍夫应力 $\\widehat{\\tau}_i$。\n6.  完整的基尔霍夫应力张量 $\\widehat{\\tau}$ 在 $B$ 的特征向量基中被重构：\n    $$\n    \\widehat{\\tau} = \\sum_{i=1}^3 \\widehat{\\tau}_i \\, v_i \\otimes v_i\n    $$\n    此操作将主应力与主伸长方向正确对齐。\n7.  最后，通过缩放基尔霍夫应力获得预测的柯西应力张量：$\\widehat{\\sigma} = \\widehat{\\tau} / J$。\n\n### 第三部分：框架无关性的对抗性验证\n\n材料框架无关性要求本构定律独立于观察者的刚体旋转。在数学上，对于任何正常正交张量 $Q$，应力响应必须满足 $\\sigma(QF) = Q \\sigma(F) Q^{\\mathsf{T}}$。\n\n谱重构方法在设计上就满足这一性质。为了在数值上验证这一点并量化任何由浮点不精确性引起的“泄漏”，我们采用对抗性测试。\n1.  一个基础变形 $F_1 = R_{\\text{ref}} U$ 由一个纯伸长 $U = \\mathrm{diag}(\\lambda_1, \\lambda_2, \\lambda_3)$ 和一个参考旋转 $R_{\\text{ref}}$ 创建。\n2.  生成一组 $K=25$ 个随机的“对抗性”旋转 $Q_k$。\n3.  对于每个 $Q_k$，形成一个新的变形 $F_{2,k} = Q_k F_1$。这代表从一个旋转的框架观察到的相同的物理变形 $F_1$。\n4.  模型预测两种变形的应力：$\\widehat{\\sigma}(F_1)$ 和 $\\widehat{\\sigma}(F_{2,k})$。\n5.  如果模型是完全客观的，它必须满足 $\\widehat{\\sigma}(F_{2,k}) = Q_k \\widehat{\\sigma}(F_1) Q_k^{\\mathsf{T}}$。\n6.  不变性泄漏使用以下度量进行量化：\n    $$\n    \\mathcal{L}_k = \\frac{\\left\\| \\widehat{\\sigma}(F_{2,k}) - Q_k \\, \\widehat{\\sigma}(F_1) \\, Q_k^{\\mathsf{T}} \\right\\|_F}{\\left\\| \\widehat{\\sigma}(F_1) \\right\\|_F + \\epsilon}\n    $$\n    其中 $\\|\\cdot\\|_F$ 是弗罗贝尼乌斯范数，$\\epsilon$ 是一个小的正则化常数。对于我们的模型，$\\mathcal{L}_k$ 的任何非零值都可归因于矩阵运算序列（特别是 `eigh`）中的数值浮点误差。该测试报告了在对抗性旋转集合上的最大泄漏 $\\max_k \\mathcal{L}_k$。\n\n该实现对所有随机数生成使用固定的种子，以确保训练、对抗性旋转生成和最终结果的完全可复现性。对于测试用例，还计算了模型预测 $\\widehat{\\sigma}(F_1)$ 与基准真值 $\\sigma(F_1)$ 之间的相对误差，以评估所学线性模型的准确性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef rodrigues_rotation(axis, angle):\n    \"\"\"\n    Computes the rotation matrix for a given axis and angle using Rodrigues' formula.\n    \"\"\"\n    axis = np.asarray(axis, dtype=float)\n    axis /= np.linalg.norm(axis)\n    \n    K = np.array([[0, -axis[2], axis[1]],\n                  [axis[2], 0, -axis[0]],\n                  [-axis[1], axis[0], 0]])\n    \n    R = np.identity(3) + np.sin(angle) * K + (1 - np.cos(angle)) * (K @ K)\n    return R\n\ndef solve():\n    \"\"\"\n    Main function to perform model training, evaluation, and reporting.\n    \"\"\"\n    # --- Constants and Hyperparameters ---\n    MU = 2.0\n    KAPPA = 10.0\n    N_TRAIN = 256\n    K_ADV = 25\n    EPSILON = 1e-15\n    TRAIN_SEED = 42\n    ADV_SEED = 123\n\n    # --- 1. Training Phase ---\n    rng_train = np.random.default_rng(TRAIN_SEED)\n    # Generate logarithmic stretches x_i = ln(lambda_i)\n    x_train = rng_train.normal(loc=0.0, scale=0.4, size=(N_TRAIN, 3))\n    lambdas_train = np.exp(x_train)\n    J_train = np.prod(lambdas_train, axis=1)\n\n    # Compute ground-truth Kirchhoff stresses (targets)\n    # tau_i = mu*(lambda_i^2 - 1) + kappa*J*(J-1)\n    tau_train = MU * (lambdas_train**2 - 1) + KAPPA * J_train[:, np.newaxis] * (J_train[:, np.newaxis] - 1)\n    \n    # Assemble design matrix A and target vector b for least squares Aw=b\n    # Model: tau_hat_i = w1*lambda_i^2 + w2*1 + w3*J^2 + w4*J\n    # All 3*N_TRAIN components are pooled together\n    b = tau_train.flatten()\n    A = np.zeros((3 * N_TRAIN, 4))\n    A[:, 0] = (lambdas_train**2).flatten()\n    A[:, 1] = 1.0\n    A[:, 2] = (np.repeat(J_train, 3)**2)\n    A[:, 3] = np.repeat(J_train, 3)\n\n    # Solve for the weight vector w\n    w, _, _, _ = np.linalg.lstsq(A, b, rcond=None)\n\n    # --- Define Prediction and Ground Truth Functions ---\n    def predict_sigma_hat(F, w_fit):\n        \"\"\"Predicts Cauchy stress using the learned spectral model.\"\"\"\n        if np.linalg.det(F) == 0:\n            return np.full((3, 3), np.nan) # Invalid deformation\n        B = F @ F.T\n        # eigh returns sorted eigenvalues and corresponding eigenvectors\n        betas, V = np.linalg.eigh(B)\n        \n        # Clamp small negative numerical noise before sqrt\n        betas[betas  0] = 0\n        lambdas = np.sqrt(betas)\n        J = np.prod(lambdas)\n        if J  EPSILON: J = EPSILON # Avoid division by zero\n        \n        # Evaluate learned model for principal Kirchhoff stresses\n        tau_hat_i = w_fit[0] * lambdas**2 + w_fit[1] + w_fit[2] * J**2 + w_fit[3] * J\n        \n        # Reconstruct Kirchhoff stress tensor\n        tau_hat = V @ np.diag(tau_hat_i) @ V.T\n        \n        # Return Cauchy stress\n        return tau_hat / J\n\n    def true_sigma(F, mu, kappa):\n        \"\"\"Computes Cauchy stress using the true Neo-Hookean law.\"\"\"\n        J = np.linalg.det(F)\n        if J == 0:\n            return np.full((3, 3), np.nan)\n        B = F @ F.T\n        I = np.identity(3)\n        return (mu/J) * (B - I) + kappa * (J - 1) * I\n\n    # --- 2. Test Suite Execution ---\n    results = []\n    test_cases = [\n        np.array([1.10, 0.95, 0.96]),\n        np.array([1.60, 0.70, 1.30]),\n        np.array([1.00, 1.00, 1.05])\n    ]\n\n    # Reference rotation for base deformation\n    axis_ref = np.array([1.0, 1.0, 1.0])\n    angle_ref = 1.234\n    R_ref = rodrigues_rotation(axis_ref, angle_ref)\n    \n    rng_adv = np.random.default_rng(ADV_SEED)\n\n    for lambdas_test in test_cases:\n        # --- Base Deformation Analysis ---\n        U = np.diag(lambdas_test)\n        F1 = R_ref @ U\n        \n        sigma_hat_1 = predict_sigma_hat(F1, w)\n        sigma_true_1 = true_sigma(F1, MU, KAPPA)\n\n        # Compute relative Frobenius error\n        error_num = np.linalg.norm(sigma_hat_1 - sigma_true_1, 'fro')\n        error_den = np.linalg.norm(sigma_true_1, 'fro')\n        relative_error = error_num / error_den if error_den > EPSILON else 0.0\n        results.append(relative_error)\n\n        # --- Adversarial Analysis for Invariance Leakage ---\n        max_leakage = 0.0\n        den_L = np.linalg.norm(sigma_hat_1, 'fro') + EPSILON\n\n        for _ in range(K_ADV):\n            # Generate random rotation as per problem specification\n            axis_adv = rng_adv.normal(size=3)\n            norm_axis = np.linalg.norm(axis_adv)\n            if norm_axis  EPSILON:\n                axis_adv = np.array([1.0, 0.0, 0.0]) # fallback for zero vector\n            else:\n                axis_adv /= norm_axis\n\n            angle_adv = rng_adv.uniform(0, np.pi)\n            Qk = rodrigues_rotation(axis_adv, angle_adv)\n            \n            F2k = Qk @ F1\n            sigma_hat_2k = predict_sigma_hat(F2k, w)\n            sigma_transformed = Qk @ sigma_hat_1 @ Qk.T\n            \n            num_L = np.linalg.norm(sigma_hat_2k - sigma_transformed, 'fro')\n            Lk = num_L / den_L\n            \n            if Lk > max_leakage:\n                max_leakage = Lk\n        \n        results.append(max_leakage)\n\n    # --- 3. Final Output ---\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "一个仅仅能准确预测应力或能量值的数据驱动模型，对于隐式有限元模拟等实际应用可能还不够，因为这些模拟严重依赖于精确的材料切线刚度。本练习介绍了一种被称为 Sobolev 训练的物理知识驱动技术，它将函数的导数信息也纳入学习过程 。通过改进损失函数，你将训练出一个能更准确预测切线刚度的模型，这是向着构建稳健高效的、基于机器学习的数值求解器迈出的关键一步。",
            "id": "3557090",
            "problem": "实现一个完整的、可运行的程序，该程序通过使用神经网络（NN）输出相对于不变量的导数来增强损失函数，从而演示数据驱动的超弹性本构模型的 Sobolev 训练，并评估这种方法如何改善用于耦合到有限元（FE）公式中的切线预测。\n\n您将处理一种各向同性、可压缩的超弹性材料，其应变能密度是右柯西-格林张量不变量的标量函数。从以下基本基础开始：\n\n- 超弹性：柯西应力是通过对应变度量的张量微分从标量应变能密度函数导出的。\n- 不变量：对于变形梯度 $F$，定义 $C = F^{\\mathsf{T}} F$，其不变量 $I_1 = \\mathrm{tr}(C)$，以及雅可比行列式 $J = \\det(F)$。\n- 链式法则和基本微积分：对于复合函数 $W(I_1, J)$，使用 $\\mathrm{d} W = \\dfrac{\\partial W}{\\partial I_1} \\mathrm{d} I_1 + \\dfrac{\\partial W}{\\partial J} \\mathrm{d} J$。\n\n您必须从第一性原理推导出从 $W(I_1, J)$ 计算应力所需的应力表达式，并在您的程序中实现它。推导过程必须在您的解题思路中完成，而不是在程序注释中。您不得依赖任何非从所述基础推导出的公式。\n\n数据生成：\n\n- 使用以下形式的合成但科学上合理的能量密度函数\n  $$W(I_1, J) = \\tfrac{1}{2} \\mu_1 (I_1 - 3) + 0.1\\, a_2 (I_1 - 3)^2 + k_1 \\ln J + \\tfrac{1}{2} \\kappa (\\ln J)^2 + 0.05\\, k_3 (\\ln J)^3,$$\n  其中无量纲常数选择为 $\\mu_1 = 20$， $a_2 = 3$， $k_1 = -20$， $\\kappa = 50$，以及 $k_3 = 5$。在此练习中，所有量均视为无量纲。\n- 从此 $W$ 计算关于不变量的精确导数：\n  $$\\dfrac{\\partial W}{\\partial I_1} \\quad\\text{和}\\quad \\dfrac{\\partial W}{\\partial J}。$$\n- 通过在区间 $[0.7, 1.3]$ 内采样对角变形梯度 $F = \\mathrm{diag}(\\lambda_1, \\lambda_2, \\lambda_3)$（其中 $\\lambda_i$ 为主拉伸）来生成训练数据。对于每个样本，计算 $I_1$、$J$、$W(I_1, J)$ 以及关于 $I_1$ 和 $J$ 的精确导数。\n\n学习模型：\n\n- 使用具有固定随机特征的单隐藏层神经网络作为假设空间。具体来说，定义隐藏特征 $\\phi_j(x) = \\tanh(w_j^{\\mathsf{T}} x + b_j)$，其中 $x = [I_1, J]^{\\mathsf{T}}$，$w_j \\in \\mathbb{R}^2$ 和 $b_j \\in \\mathbb{R}$ 是固定的随机参数，并且只学习线性输出权重 $\\beta \\in \\mathbb{R}^{M}$，因此模型为 $W_\\beta(x) = \\sum_{j=1}^{M} \\beta_j \\phi_j(x)$。这确保了 $W_\\beta$ 及其输入导数都是关于 $\\beta$ 的线性函数。\n- 将 Sobolev 训练目标定义为一个加权最小二乘问题，结合了能量及其导数上的数据失配：\n  $$\\mathcal{L}(\\beta) = \\dfrac{1}{N} \\sum_{n=1}^{N} \\left( W_\\beta(x_n) - W(x_n) \\right)^2 + \\alpha \\left\\| \\nabla_x W_\\beta(x_n) - \\nabla_x W(x_n) \\right\\|_2^2,$$\n  其中 $\\alpha \\ge 0$ 是一个可调权重，$\\nabla_x = \\left[ \\dfrac{\\partial}{\\partial I_1}, \\dfrac{\\partial}{\\partial J} \\right]^{\\mathsf{T}}$。\n- 实现基线训练（$\\alpha = 0$）和 Sobolev 训练（$\\alpha  0$），每个都作为对 $\\beta$ 进行 Tikhonov 正则化的单个线性最小二乘问题来解决。\n\n应力和切线评估：\n\n- 对于能量 $W(I_1, J)$，根据不变量、其导数和变形张量，从第一性原理推导柯西应力 $\\sigma$。在代码中为对角 $F$ 实现此公式。\n- 定义两个用于评估的单参数变形路径：\n  1. 体积（静水）路径：$F(\\lambda) = \\lambda I$，其中 $\\lambda \\in [0.85, 1.15]$。\n  2. 等容（保体积）单轴路径：$F(\\gamma) = \\mathrm{diag}(\\gamma, \\gamma^{-1/2}, \\gamma^{-1/2})$，其中 $\\gamma \\in [0.8, 1.25]$。\n- 对于每条路径，通过柯西应力第 $11$ 分量关于路径参数的中心有限差分来计算方向切线（即，对于体积路径为 $\\dfrac{\\mathrm{d} \\sigma_{11}}{\\mathrm{d} \\lambda}$，对于等容路径为 $\\dfrac{\\mathrm{d} \\sigma_{11}}{\\mathrm{d} \\gamma}$）。使用足够小的对称差商，并确保扰动保持在指定的参数区间内。\n- 计算预测切线（基线和 Sobolev）与从精确模型获得的真实切线在每条路径上一组均匀间隔点上的均方根误差（RMSE），并报告两个 RMSE（体积和等容）的平均值。\n\n数值和输出要求：\n\n- 所有量都是无量纲的；不要报告任何物理单位。\n- 不使用角度；无需指定角度单位。\n- 程序必须为每个测试用例内部设置一个随机种子以保证可复现性。\n- 实现以下由三个案例组成的测试套件，每个案例由一个元组 $(\\text{seed}, N_{\\text{train}}, M_{\\text{features}}, \\alpha, \\lambda_{\\text{ridge}}, \\sigma_{\\text{noise}})$ 定义：\n  1. 案例 A (理想情况): $(123, 128, 200, 10.0, 10^{-4}, 0.01)$\n  2. 案例 B (低数据量): $(456, 32, 200, 20.0, 10^{-4}, 0.01)$\n  3. 案例 C (对照组, 无 Sobolev 增益): $(789, 128, 200, 0.0, 10^{-4}, 0.01)$\n- 在每个案例中，对能量和每个导数训练标签独立地应用标准差为 $\\sigma_{\\text{noise}}$ 的附加独立零均值高斯噪声。确保在给定案例中，基线训练和 Sobolev 训练使用相同的噪声实现。\n- 对于每个案例，比较基线模型和 Sobolev 训练模型的平均切线 RMSE，并输出一个布尔值：如果 Sobolev 训练模型的平均切线 RMSE 比基线模型的平均切线 RMSE 至少低 $5\\%$，则为 true，否则为 false。形式上，如果\n  $$\\mathrm{RMSE}_{\\mathrm{Sob}} \\le (1 - 0.05)\\, \\mathrm{RMSE}_{\\mathrm{Base}},$$\n  则输出 true，否则输出 false。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的 Python 布尔值逗号分隔列表（例如，\"[True,False,True]\"），按 A、B、C 的顺序对应三个案例的结果。\n\n程序必须是自包含的，不需要任何用户输入或外部文件，并且必须用 Python 编写。在给定指定种子的情况下，所有计算都必须是确定性和可复现的。代码必须在标准 CPU 上合理时间内完成，仅使用基本的线性代数运算。",
            "solution": "目标是实现并评估一个用于数据驱动超弹性本构模型的 Sobolev 训练方案。这涉及几个步骤：首先，从第一性原理推导必要的连续介质力学表达式；其次，从已知的能量函数生成合成数据；第三，在有和没有导数信息的情况下训练神经网络模型；最后，评估模型沿特定变形路径预测材料切线的能力。\n\n### 第1部分：柯西应力张量的推导\n\n超弹性模型的核心是应变能密度函数 $W$，它是一个标量势，应力由其导出。对于各向同性材料，$W$ 是合适应变张量不变量的函数。这里，我们认为 $W$ 是右柯西-格林张量第一不变量 $I_1$ 和变形梯度行列式 $J$ 的函数。\n\n令 $\\boldsymbol{F}$ 为变形梯度张量。右和左柯西-格林张量分别定义为 $\\boldsymbol{C} = \\boldsymbol{F}^{\\mathsf{T}}\\boldsymbol{F}$ 和 $\\boldsymbol{B} = \\boldsymbol{F}\\boldsymbol{F}^{\\mathsf{T}}$。指定的不变量为 $I_1 = \\mathrm{tr}(\\boldsymbol{C})$ 和 $J = \\det(\\boldsymbol{F})$。注意 $J = \\sqrt{\\det(\\boldsymbol{C})}$。\n\n应变能与应力之间的基本关系通过虚功原理给出。单位参考体积的应变能变化率 $\\dot{W}$ 等于应力所做的功率。在物质描述中，这表示为 $\\dot{W} = \\frac{1}{2}\\boldsymbol{S}:\\dot{\\boldsymbol{C}}$，其中 $\\boldsymbol{S}$ 是对称的第二 Piola-Kirchhoff (2nd P-K) 应力张量，$\\dot{\\boldsymbol{C}}$ 是 $\\boldsymbol{C}$ 的物质时间导数。此关系意味着 $\\boldsymbol{S} = 2\\frac{\\partial W}{\\partial \\boldsymbol{C}}$。\n\n由于 $W$ 是 $I_1$ 和 $J$ 的函数，而 $I_1$ 和 $J$ 本身又是 $\\boldsymbol{C}$ 的函数，我们应用链式法则：\n$$\n\\boldsymbol{S} = 2 \\left( \\frac{\\partial W}{\\partial I_1} \\frac{\\partial I_1}{\\partial \\boldsymbol{C}} + \\frac{\\partial W}{\\partial J} \\frac{\\partial J}{\\partial \\boldsymbol{C}} \\right)\n$$\n我们需要不变量相对于 $\\boldsymbol{C}$ 的导数：\n1.  对于 $I_1 = \\mathrm{tr}(\\boldsymbol{C}) = C_{kk}$，其微分为 $\\mathrm{d}I_1 = \\mathrm{d}(\\mathrm{tr}(\\boldsymbol{C})) = \\mathrm{tr}(\\mathrm{d}\\boldsymbol{C}) = \\boldsymbol{I}:\\mathrm{d}\\boldsymbol{C}$，其中 $\\boldsymbol{I}$ 是二阶单位张量。因此，$\\frac{\\partial I_1}{\\partial \\boldsymbol{C}} = \\boldsymbol{I}$。\n2.  对于 $J = \\sqrt{\\det(\\boldsymbol{C})}$，其微分为 $\\mathrm{d}J = \\frac{1}{2\\sqrt{\\det(\\boldsymbol{C})}}\\mathrm{d}(\\det(\\boldsymbol{C}))$。使用 Jacobi 公式，$\\mathrm{d}(\\det(\\boldsymbol{C})) = \\det(\\boldsymbol{C})\\mathrm{tr}(\\boldsymbol{C}^{-1}\\mathrm{d}\\boldsymbol{C}) = \\det(\\boldsymbol{C})(\\boldsymbol{C}^{-1})^{\\mathsf{T}}:\\mathrm{d}\\boldsymbol{C}$。由于 $\\boldsymbol{C}$ 是对称的，其逆也是对称的，因此这简化为 $\\det(\\boldsymbol{C})\\boldsymbol{C}^{-1}:\\mathrm{d}\\boldsymbol{C}$。将此代入 $\\mathrm{d}J$ 的表达式中可得：\n    $$\n    \\mathrm{d}J = \\frac{1}{2J} (J^2 \\boldsymbol{C}^{-1}:\\mathrm{d}\\boldsymbol{C}) = \\frac{J}{2}\\boldsymbol{C}^{-1}:\\mathrm{d}\\boldsymbol{C}\n    $$\n    因此，$\\frac{\\partial J}{\\partial \\boldsymbol{C}} = \\frac{J}{2}\\boldsymbol{C}^{-1}$。\n\n将这些导数代回 $\\boldsymbol{S}$ 的表达式中：\n$$\n\\boldsymbol{S} = 2 \\left( \\frac{\\partial W}{\\partial I_1} \\boldsymbol{I} + \\frac{\\partial W}{\\partial J} \\frac{J}{2}\\boldsymbol{C}^{-1} \\right) = 2\\frac{\\partial W}{\\partial I_1}\\boldsymbol{I} + J\\frac{\\partial W}{\\partial J}\\boldsymbol{C}^{-1}\n$$\n柯西应力张量 $\\boldsymbol{\\sigma}$ 代表变形构型中的真实应力，是通过对 $\\boldsymbol{S}$ 的前推（push-forward）运算得到的：$\\boldsymbol{\\sigma} = \\frac{1}{J}\\boldsymbol{F}\\boldsymbol{S}\\boldsymbol{F}^{\\mathsf{T}}$。\n$$\n\\boldsymbol{\\sigma} = \\frac{1}{J}\\boldsymbol{F} \\left( 2\\frac{\\partial W}{\\partial I_1}\\boldsymbol{I} + J\\frac{\\partial W}{\\partial J}\\boldsymbol{C}^{-1} \\right) \\boldsymbol{F}^{\\mathsf{T}}\n$$\n分配各项可得：\n$$\n\\boldsymbol{\\sigma} = \\frac{2}{J}\\frac{\\partial W}{\\partial I_1}\\boldsymbol{F}\\boldsymbol{I}\\boldsymbol{F}^{\\mathsf{T}} + \\frac{\\partial W}{\\partial J}\\boldsymbol{F}\\boldsymbol{C}^{-1}\\boldsymbol{F}^{\\mathsf{T}}\n$$\n我们识别出 $\\boldsymbol{F}\\boldsymbol{F}^{\\mathsf{T}} = \\boldsymbol{B}$ 并简化第二项：$\\boldsymbol{F}\\boldsymbol{C}^{-1}\\boldsymbol{F}^{\\mathsf{T}} = \\boldsymbol{F}(\\boldsymbol{F}^{\\mathsf{T}}\\boldsymbol{F})^{-1}\\boldsymbol{F}^{\\mathsf{T}} = \\boldsymbol{F}\\boldsymbol{F}^{-1}(\\boldsymbol{F}^{\\mathsf{T}})^{-1}\\boldsymbol{F}^{\\mathsf{T}} = \\boldsymbol{I}\\boldsymbol{I} = \\boldsymbol{I}$。\n柯西应力张量的最终表达式为：\n$$\n\\boldsymbol{\\sigma} = \\frac{2}{J}\\frac{\\partial W}{\\partial I_1}\\boldsymbol{B} + \\frac{\\partial W}{\\partial J}\\boldsymbol{I}\n$$\n对于对角变形梯度 $\\boldsymbol{F} = \\mathrm{diag}(\\lambda_1, \\lambda_2, \\lambda_3)$，主拉伸为 $\\lambda_i$。相应的张量和不变量为：\n$\\boldsymbol{C} = \\mathrm{diag}(\\lambda_1^2, \\lambda_2^2, \\lambda_3^2)$，$\\boldsymbol{B} = \\mathrm{diag}(\\lambda_1^2, \\lambda_2^2, \\lambda_3^2)$，$I_1 = \\lambda_1^2 + \\lambda_2^2 + \\lambda_3^2$，以及 $J = \\lambda_1\\lambda_2\\lambda_3$。柯西应力张量 $\\boldsymbol{\\sigma}$ 也是对角的，其主分量为：\n$$\n\\sigma_{ii} = \\frac{2}{J}\\frac{\\partial W}{\\partial I_1}\\lambda_i^2 + \\frac{\\partial W}{\\partial J}\n$$\n该表达式用于从数据驱动模型对 $W$ 导数的预测中计算应力。\n\n### 第2部分：数据生成与模型训练\n\n使用能量函数建立一个合成的基准真相：\n$W(I_1, J) = \\tfrac{1}{2} \\mu_1 (I_1 - 3) + 0.1\\, a_2 (I_1 - 3)^2 + k_1 \\ln J + \\tfrac{1}{2} \\kappa (\\ln J)^2 + 0.05\\, k_3 (\\ln J)^3$。\n精确导数通过解析计算得出：\n$\\frac{\\partial W}{\\partial I_1} = \\frac{\\mu_1}{2} + 0.2 a_2 (I_1 - 3)$ 和 $\\frac{\\partial W}{\\partial J} = \\frac{1}{J} (k_1 + \\kappa \\ln J + 0.15 k_3 (\\ln J)^2)$。\n通过采样主拉伸生成训练数据 $\\{x_n, y_n\\}_{n=1}^N$，计算 $x_n = [I_1, J]^{\\mathsf{T}}$ 和“标签”$y_n = [W, \\frac{\\partial W}{\\partial I_1}, \\frac{\\partial W}{\\partial J}]^{\\mathsf{T}}$，并添加高斯噪声。\n\n学习模型是一个随机特征模型，$W_\\beta(x) = \\sum_{j=1}^{M} \\beta_j \\phi_j(x) = \\boldsymbol{\\Phi}(x)^{\\mathsf{T}}\\boldsymbol{\\beta}$，其中特征 $\\phi_j(x)=\\tanh(\\boldsymbol{w}_j^\\mathsf{T}x+b_j)$ 具有固定的随机权重 $\\boldsymbol{w}_j$ 和偏置 $b_j$。其梯度为 $\\nabla_x W_\\beta(x) = (\\nabla_x \\boldsymbol{\\Phi}(x))\\boldsymbol{\\beta}$。\n\n包括 Tikhonov 正则化的 Sobolev 训练目标是找到最小化以下函数的 $\\boldsymbol{\\beta}$：\n$$\n\\mathcal{L}(\\boldsymbol{\\beta}) = \\sum_{n=1}^{N} \\left[ (W_\\beta(x_n) - W(x_n))^2 + \\alpha \\left\\| \\nabla_x W_\\beta(x_n) - \\nabla_x W(x_n) \\right\\|_2^2 \\right] + \\lambda_{\\text{ridge}} \\|\\boldsymbol{\\beta}\\|_2^2\n$$\n这是一个线性最小二乘问题。对于每个训练样本 $n$，我们为能量及其两个导数构成一个方程组。全局系统可以写为 $\\| \\boldsymbol{A} \\boldsymbol{\\beta} - \\boldsymbol{y} \\|_2^2 + \\lambda_{\\text{ridge}} \\|\\boldsymbol{\\beta}\\|_2^2$，其中 $\\boldsymbol{A}$ 和 $\\boldsymbol{y}$ 的构造如下：\n$$\n\\boldsymbol{A} = \\begin{pmatrix} \\boldsymbol{\\Phi}(x_1)^{\\mathsf{T}} \\\\ \\vdots \\\\ \\boldsymbol{\\Phi}(x_N)^{\\mathsf{T}} \\\\ \\sqrt{\\alpha} (\\frac{\\partial}{\\partial I_1}\\boldsymbol{\\Phi}(x_1))^{\\mathsf{T}} \\\\ \\vdots \\\\ \\sqrt{\\alpha} (\\frac{\\partial}{\\partial J}\\boldsymbol{\\Phi}(x_N))^{\\mathsf{T}} \\end{pmatrix}, \\quad \n\\boldsymbol{y} = \\begin{pmatrix} W(x_1) \\\\ \\vdots \\\\ W(x_N) \\\\ \\sqrt{\\alpha} \\frac{\\partial W}{\\partial I_1}(x_1) \\\\ \\vdots \\\\ \\sqrt{\\alpha} \\frac{\\partial W}{\\partial J}(x_N) \\end{pmatrix}\n$$\n该问题使用标准的正则化最小二乘求解器解决。基线训练使用 $\\alpha=0$，仅考虑能量数据。Sobolev 训练使用 $\\alpha  0$。\n\n### 第3部分：切线评估\n\n模型的评估基于它们预测材料切线的能力，这对于隐式有限元模拟至关重要。我们计算应力分量沿指定变形路径的方向导数。对于体积路径 $\\boldsymbol{F}(\\lambda) = \\lambda\\boldsymbol{I}$ 和等容路径 $\\boldsymbol{F}(\\gamma) = \\mathrm{diag}(\\gamma, \\gamma^{-1/2}, \\gamma^{-1/2})$，我们分别评估 $\\frac{\\mathrm{d}\\sigma_{11}}{\\mathrm{d}\\lambda}$ 和 $\\frac{\\mathrm{d}\\sigma_{11}}{\\mathrm{d}\\gamma}$。这些切线使用中心有限差分格式和一个小步长 $\\delta$ 来近似：\n$$\n\\frac{\\mathrm{d}\\sigma_{11}}{\\mathrm{d}p} \\approx \\frac{\\sigma_{11}(p+\\delta/2) - \\sigma_{11}(p-\\delta/2)}{\\delta}\n$$\n其中 $p$ 是路径参数（$\\lambda$ 或 $\\gamma$）。预测切线的均方根误差 (RMSE) 是相对真实模型的切线计算的。计算两条路径的平均 RMSE。成功的最终标准是 Sobolev 模型的平均 RMSE 是否比基线模型的平均 RMSE 至少低 5%，即 $\\mathrm{RMSE}_{\\mathrm{Sob}} \\le 0.95 \\times \\mathrm{RMSE}_{\\mathrm{Base}}$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# No other libraries are permitted.\n\nclass TrueModel:\n    \"\"\"Computes the ground truth energy, derivatives, and stress.\"\"\"\n    def __init__(self):\n        self.mu1 = 20.0\n        self.a2 = 3.0\n        self.k1 = -20.0\n        self.kappa = 50.0\n        self.k3 = 5.0\n\n    def get_W_and_derivatives(self, I1, J):\n        \"\"\"Computes W and its derivatives wrt invariants.\"\"\"\n        # Ensure logJ is numerically stable, though J>0 for the given stretch range.\n        J_safe = np.maximum(J, 1e-9)\n        logJ = np.log(J_safe)\n        \n        W = (0.5 * self.mu1 * (I1 - 3.0) +\n             0.1 * self.a2 * (I1 - 3.0)**2 +\n             self.k1 * logJ +\n             0.5 * self.kappa * logJ**2 +\n             0.05 * self.k3 * logJ**3)\n        \n        dW_dI1 = 0.5 * self.mu1 + 0.2 * self.a2 * (I1 - 3.0)\n        \n        dW_dJ = (1.0 / J_safe) * (self.k1 + self.kappa * logJ + 0.15 * self.k3 * logJ**2)\n        \n        return W, dW_dI1, dW_dJ\n\n    def get_stress_11(self, F_diag):\n        \"\"\"Computes the 11-component of the Cauchy stress.\"\"\"\n        lambda1 = F_diag[..., 0]\n        lambda2 = F_diag[..., 1]\n        lambda3 = F_diag[..., 2]\n        \n        I1 = lambda1**2 + lambda2**2 + lambda3**2\n        J = lambda1 * lambda2 * lambda3\n        \n        _, dW_dI1, dW_dJ = self.get_W_and_derivatives(I1, J)\n        \n        # sigma_11 = (2/J) * dW/dI1 * lambda1^2 + dW/dJ\n        sigma11 = (2.0 / J) * dW_dI1 * lambda1**2 + dW_dJ\n        \n        return sigma11\n\nclass HyperelasticNN:\n    \"\"\"A random feature model for the hyperelastic energy.\"\"\"\n    def __init__(self, beta, w, b):\n        self.beta = beta\n        self.w = w\n        self.b = b\n\n    def get_W_and_derivatives(self, I1, J):\n        \"\"\"Predicts W and its derivatives from the NN model.\"\"\"\n        X = np.stack([I1, J], axis=-1)\n        if X.ndim == 1:\n            X = X[np.newaxis, :]\n            \n        U = X @ self.w.T + self.b\n        Phi = np.tanh(U)\n        \n        W_pred = Phi @ self.beta\n\n        dPhi_dU = 1.0 - Phi**2\n        \n        dPhi_dI1 = dPhi_dU * self.w[:, 0]\n        dW_dI1_pred = dPhi_dI1 @ self.beta\n        \n        dPhi_dJ = dPhi_dU * self.w[:, 1]\n        dW_dJ_pred = dPhi_dJ @ self.beta\n        \n        return W_pred.squeeze(), dW_dI1_pred.squeeze(), dW_dJ_pred.squeeze()\n\n    def get_stress_11(self, F_diag):\n        \"\"\"Predicts the 11-component of the Cauchy stress.\"\"\"\n        lambda1 = F_diag[..., 0]\n        lambda2 = F_diag[..., 1]\n        lambda3 = F_diag[..., 2]\n        \n        I1 = lambda1**2 + lambda2**2 + lambda3**2\n        J = lambda1 * lambda2 * lambda3\n        \n        _, dW_dI1, dW_dJ = self.get_W_and_derivatives(I1, J)\n        \n        sigma11 = (2.0 / J) * dW_dI1 * lambda1**2 + dW_dJ\n        \n        return sigma11\n\ndef train_model(X_train, Y_train_noisy, M_features, alpha, lambda_ridge, w, b):\n    \"\"\"Solves for the NN weights beta using (regularized) least squares.\"\"\"\n    N_train = X_train.shape[0]\n    \n    # Unpack noisy labels\n    W_noisy, dWdI1_noisy, dWdJ_noisy = Y_train_noisy.T\n\n    # Compute feature matrix and its derivatives\n    U = X_train @ w.T + b\n    Phi = np.tanh(U)\n    \n    dPhi_dU = 1.0 - Phi**2\n    dPhi_dI1 = dPhi_dU * w[:, 0]\n    dPhi_dJ = dPhi_dU * w[:, 1]\n    \n    # Assemble the system matrix A for the least-squares problem\n    A = np.vstack([\n        Phi,\n        np.sqrt(alpha) * dPhi_dI1,\n        np.sqrt(alpha) * dPhi_dJ\n    ])\n    \n    # Assemble the target vector y\n    y = np.concatenate([\n        W_noisy,\n        np.sqrt(alpha) * dWdI1_noisy,\n        np.sqrt(alpha) * dWdJ_noisy\n    ])\n    \n    # Augment for Tikhonov (ridge) regularization\n    A_aug = np.vstack([A, np.sqrt(lambda_ridge) * np.eye(M_features)])\n    y_aug = np.concatenate([y, np.zeros(M_features)])\n    \n    # Solve the linear system\n    beta, _, _, _ = np.linalg.lstsq(A_aug, y_aug, rcond=None)\n    \n    return beta\n\ndef eval_model_tangent(stress_predictor, path_type, num_points=100, dp=1e-6):\n    \"\"\"Evaluates the directional tangent of sigma_11 along a path.\"\"\"\n    if path_type == 'volumetric':\n        p_vals = np.linspace(0.85, 1.15, num_points)\n        def get_F(p_vec):\n            return np.vstack([p_vec, p_vec, p_vec]).T\n    elif path_type == 'isochoric':\n        p_vals = np.linspace(0.8, 1.25, num_points)\n        def get_F(p_vec):\n            # Use np.power for vectorized exponentiation\n            return np.vstack([p_vec, np.power(p_vec, -0.5), np.power(p_vec, -0.5)]).T\n    else:\n        raise ValueError(\"Invalid path type\")\n        \n    p_plus = p_vals + dp / 2.0\n    p_minus = p_vals - dp / 2.0\n    \n    F_plus = get_F(p_plus)\n    F_minus = get_F(p_minus)\n\n    sigma_plus = stress_predictor(F_plus)\n    sigma_minus = stress_predictor(F_minus)\n    \n    tangents = (sigma_plus - sigma_minus) / dp\n    return tangents\n\ndef run_case(case_params):\n    \"\"\"Runs a full test case from data generation to evaluation.\"\"\"\n    seed, N_train, M_features, alpha_sob, lambda_ridge, sigma_noise = case_params\n\n    rng = np.random.default_rng(seed)\n    true_model = TrueModel()\n\n    # Data Generation\n    lambdas = rng.uniform(0.7, 1.3, size=(N_train, 3))\n    I1 = np.sum(lambdas**2, axis=1)\n    J = np.prod(lambdas, axis=1)\n    X_train = np.stack([I1, J], axis=1)\n    \n    W_true, dWdI1_true, dWdJ_true = true_model.get_W_and_derivatives(I1, J)\n    \n    W_noisy = W_true + rng.normal(0, sigma_noise, size=N_train)\n    dWdI1_noisy = dWdI1_true + rng.normal(0, sigma_noise, size=N_train)\n    dWdJ_noisy = dWdJ_true + rng.normal(0, sigma_noise, size=N_train)\n    Y_train_noisy = np.stack([W_noisy, dWdI1_noisy, dWdJ_noisy], axis=1)\n    \n    # Model Training\n    w = rng.standard_normal(size=(M_features, 2))\n    b = rng.uniform(-1.0, 1.0, size=M_features)\n\n    # Baseline model\n    beta_base = train_model(X_train, Y_train_noisy, M_features, 0.0, lambda_ridge, w, b)\n    model_base = HyperelasticNN(beta_base, w, b)\n    \n    # Sobolev model\n    beta_sob = train_model(X_train, Y_train_noisy, M_features, alpha_sob, lambda_ridge, w, b)\n    model_sob = HyperelasticNN(beta_sob, w, b)\n\n    # Evaluation\n    rmses_base, rmses_sob = [], []\n    for path in ['volumetric', 'isochoric']:\n        tangents_true = eval_model_tangent(true_model.get_stress_11, path)\n        \n        tangents_base = eval_model_tangent(model_base.get_stress_11, path)\n        rmse_base = np.sqrt(np.mean((tangents_base - tangents_true)**2))\n        rmses_base.append(rmse_base)\n\n        tangents_sob = eval_model_tangent(model_sob.get_stress_11, path)\n        rmse_sob = np.sqrt(np.mean((tangents_sob - tangents_true)**2))\n        rmses_sob.append(rmse_sob)\n        \n    avg_rmse_base = np.mean(rmses_base)\n    avg_rmse_sob = np.mean(rmses_sob)\n    \n    return avg_rmse_sob = 0.95 * avg_rmse_base\n\ndef solve():\n    \"\"\"Defines and runs the test suite.\"\"\"\n    test_cases = [\n        (123, 128, 200, 10.0, 1e-4, 0.01),  # Case A\n        (456, 32, 200, 20.0, 1e-4, 0.01),   # Case B\n        (789, 128, 200, 0.0, 1e-4, 0.01),   # Case C\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_case(case)\n        results.append(str(result).lower())\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}