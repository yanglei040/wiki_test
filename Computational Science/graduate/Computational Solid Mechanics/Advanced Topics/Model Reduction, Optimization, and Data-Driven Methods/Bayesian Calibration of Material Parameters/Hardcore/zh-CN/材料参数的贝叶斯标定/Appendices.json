{
    "hands_on_practices": [
        {
            "introduction": "在贝叶斯材料参数校准中，一个核心要求是确保先验分布尊重物理约束，例如弹性模量必须为正。一种强大而通用的技术是通过重参数化来强制执行这些约束。本练习  将指导您完成一个基本但至关重要的推导：从对数空间中参数（$\\eta = \\ln(E)$）的高斯先验，导出物理参数（杨氏模量 $E$）的诱导先验分布，即对数正态分布。这个过程不仅能加深您对概率密度变量代换法则的理解，还为您处理正定参数提供了一个标准的建模工具。",
            "id": "3547099",
            "problem": "在计算固体力学中，考虑对各向同性线弹性材料的杨氏模量（记为 $E$）进行贝叶斯校准，其中由于物理约束，$E$ 严格为正。为强制其为正并稳定推断过程，引入对数重参数化 $\\eta = \\ln(E)$。假设潜变量 $\\eta$ 的先验信念服从均值为 $\\mu$、标准差为 $\\sigma$（其中 $\\sigma > 0$）的高斯分布，也就是说，$\\eta$ 的先验密度为\n$$\np_{\\eta}(\\eta) = \\frac{1}{\\sigma \\sqrt{2\\pi}} \\exp\\!\\left(-\\frac{(\\eta - \\mu)^{2}}{2\\sigma^{2}}\\right).\n$$\n从重参数化下的概率守恒和概率密度的定义出发，推导由映射 $E = \\exp(\\eta)$ 所蕴含的物理模量 $E$ 的导出先验密度 $p_{E}(E)$。确定归一化常数，使得\n$$\n\\int_{0}^{\\infty} p_{E}(E)\\,\\mathrm{d}E = 1.\n$$\n将最终答案表示为关于 $E$、$\\mu$ 和 $\\sigma$ 的 $p_{E}(E)$ 的单个闭式解析表达式。无需进行数值计算。最终表达式中不包含单位。最终答案必须仅为单个表达式。",
            "solution": "该问题要求在给定杨氏模量 $E$ 的对数 $\\eta = \\ln(E)$ 的概率密度函数 (PDF) 的情况下，推导 $E$ 的概率密度函数。这两个 PDF 之间的关系遵循概率守恒原理，该原理导出了概率密度的变量替换公式。\n\n设 $\\eta$ 是一个具有已知 PDF $p_{\\eta}(\\eta)$ 的随机变量，并设 $E = g(\\eta)$ 是由一个可逆、可微的变换 $g$ 定义的新随机变量。其逆变换为 $\\eta = g^{-1}(E)$。$E$ 的 PDF（记为 $p_{E}(E)$）可以通过以下关系找到：\n$$\np_{E}(E) = p_{\\eta}\\left(g^{-1}(E)\\right) \\left| \\frac{\\mathrm{d}}{\\mathrm{d}E} g^{-1}(E) \\right|\n$$\n此公式确保了概率元是守恒的，即 $|p_{E}(E)\\,\\mathrm{d}E| = |p_{\\eta}(\\eta)\\,\\mathrm{d}\\eta|$。\n\n在本问题的背景下，我们已知：\n1.  从潜变量 $\\eta$ 到物理参数 $E$ 的变换：$E = \\exp(\\eta)$。\n2.  因此，逆变换为 $\\eta = \\ln(E)$。所以，$g^{-1}(E) = \\ln(E)$。\n3.  $\\eta$ 的先验密度，它是一个均值为 $\\mu$、标准差为 $\\sigma$ 的高斯分布：\n$$\np_{\\eta}(\\eta) = \\frac{1}{\\sigma \\sqrt{2\\pi}} \\exp\\left(-\\frac{(\\eta - \\mu)^{2}}{2\\sigma^{2}}\\right)\n$$\n$\\eta$ 的定义域是 $(-\\infty, \\infty)$。由于 $E = \\exp(\\eta)$，因此 $E$ 的定义域是 $(0, \\infty)$，这与杨氏模量必须严格为正的物理要求相一致。\n\n首先，我们计算变换的雅可比行列式，即逆变换导数的绝对值，$\\left| \\frac{\\mathrm{d}\\eta}{\\mathrm{d}E} \\right|$。\n$$\n\\eta(E) = \\ln(E)\n$$\n导数为：\n$$\n\\frac{\\mathrm{d}\\eta}{\\mathrm{d}E} = \\frac{\\mathrm{d}}{\\mathrm{d}E} \\left( \\ln(E) \\right) = \\frac{1}{E}\n$$\n由于 $E > 0$，其绝对值就是：\n$$\n\\left| \\frac{\\mathrm{d}\\eta}{\\mathrm{d}E} \\right| = \\left| \\frac{1}{E} \\right| = \\frac{1}{E}\n$$\n\n接下来，我们将 $\\eta = \\ln(E)$ 代入 $p_{\\eta}(\\eta)$ 的表达式中：\n$$\np_{\\eta}(\\ln(E)) = \\frac{1}{\\sigma \\sqrt{2\\pi}} \\exp\\left(-\\frac{(\\ln(E) - \\mu)^{2}}{2\\sigma^{2}}\\right)\n$$\n\n现在，我们将 $p_{\\eta}(\\ln(E))$ 乘以雅可比项 $\\left| \\frac{\\mathrm{d}\\eta}{\\mathrm{d}E} \\right|$，从而组合出 $p_{E}(E)$ 的最终表达式：\n$$\np_{E}(E) = p_{\\eta}(\\ln(E)) \\left| \\frac{\\mathrm{d}\\eta}{\\mathrm{d}E} \\right| = \\left( \\frac{1}{\\sigma \\sqrt{2\\pi}} \\exp\\left(-\\frac{(\\ln(E) - \\mu)^{2}}{2\\sigma^{2}}\\right) \\right) \\cdot \\left( \\frac{1}{E} \\right)\n$$\n整理各项，得到 $E$ 的先验密度的最终闭式表达式：\n$$\np_{E}(E) = \\frac{1}{E \\sigma \\sqrt{2\\pi}} \\exp\\left(-\\frac{(\\ln(E) - \\mu)^{2}}{2\\sigma^{2}}\\right)\n$$\n这是对数正态分布的概率密度函数，其定义域为 $E > 0$。\n\n问题要求确定归一化常数，使得 $\\int_{0}^{\\infty} p_{E}(E)\\,\\mathrm{d}E = 1$。使用变量替换公式的推导过程会自动保持归一化。如果 $p_{\\eta}(\\eta)$ 归一化为 1，那么得到的 $p_{E}(E)$ 也归一化为 1。高斯先验 $p_{\\eta}(\\eta)$ 从 $-\\infty$ 到 $\\infty$ 的积分为 1。通过在积分 $\\int_{0}^{\\infty} p_{E}(E)\\,\\mathrm{d}E$ 中进行变量替换 $u = \\ln(E)$（因此 $\\mathrm{d}u = \\frac{1}{E} \\mathrm{d}E$，积分限从 $(0, \\infty)$ 变换到 $(-\\infty, \\infty)$），该积分变为 $\\int_{-\\infty}^{\\infty} p_{\\eta}(u)\\,\\mathrm{d}u$，这证实了该积分确实为 1。因此，推导出的表达式已经正确归一化，“归一化常数”已隐含在表达式中，具体来说就是因子 $\\frac{1}{\\sigma\\sqrt{2\\pi}}$。",
            "answer": "$$\\boxed{\\frac{1}{E \\sigma \\sqrt{2\\pi}} \\exp\\left(-\\frac{\\left(\\ln(E) - \\mu\\right)^{2}}{2\\sigma^{2}}\\right)}$$"
        },
        {
            "introduction": "实验数据常常包含由传感器故障或意外干扰引起的离群值，而标准的高斯噪声模型对这些离群值非常敏感，可能导致校准结果产生偏差。为了构建更稳健的推断模型，我们可以使用具有更重尾部的概率分布，例如Student-$t$分布。在本练习  中，您将通过一个分层贝叶斯模型推导Student-$t$似然函数，该模型将高斯噪声的方差本身视为一个随机变量。通过对这个潜在方差变量进行边缘化，您将亲手构建出一个能够抵抗数据中离群值影响的似然函数，这是贝叶斯建模中一项高级且实用的技术。",
            "id": "3547105",
            "problem": "对延性金属进行的准静态单轴拉伸试验提供了 $N$ 组测量的工程应变和柯西应力，记为 $\\{(\\varepsilon_i, \\sigma_i)\\}_{i=1}^N$。一个计算正向模型 $m(\\varepsilon; \\boldsymbol{\\theta})$ 基于选定的本构律将应变 $ \\varepsilon $ 映射到预测应力，该本构律包含材料参数 $\\boldsymbol{\\theta}$（例如，一个通过标准返回映射算法积分的率无关各向同性 $J_2$ 弹塑性模型）。假设观测误差由偶然的夹具滑移和传感器非线性引起，从而产生异常应力值。为了在 $\\boldsymbol{\\theta}$ 的贝叶斯校准中抵抗异常值，使用加性学生t分布噪声模型代替通常的加性高斯噪声模型。假设残差 $r_i(\\boldsymbol{\\theta}) = \\sigma_i - m(\\varepsilon_i;\\boldsymbol{\\theta})$ 服从以下分层测量模型：\n1) 在给定潜方差 $ \\tau_i $ 的条件下，每个残差服从高斯分布：$r_i \\mid \\tau_i \\sim \\mathcal{N}(0,\\tau_i)$。\n2) 潜方差在不同观测值之间独立同分布，服从逆伽马分布，其形状参数为 $ \\alpha = \\nu/2 $，尺度参数为 $ \\beta = \\nu s^2/2 $，其中 $ \\nu > 0 $ 是学生t模型的自由度（DoF），$ s > 0 $ 是一个尺度参数。\n3) 在给定 $(\\boldsymbol{\\theta}, s, \\nu)$ 的条件下，残差在不同 $ i $ 之间是独立的。\n\n通过对潜方差 $ \\{\\tau_i\\} $ 进行边缘化，推导在该学生t分布噪声模型下，给定正向模型预测值 $ \\{m(\\varepsilon_i;\\boldsymbol{\\theta})\\}_{i=1}^N $ 时，应力观测值 $ \\{\\sigma_i\\}_{i=1}^N $ 的闭式似然函数，并用 $ \\boldsymbol{\\theta} $、$ s $、$ \\nu $ 和数据明确表示。为似然函数 $L(\\boldsymbol{\\theta}, s \\mid \\mathcal{D}, \\nu)$ 提供一个单一的闭式解析表达式，其中 $ \\mathcal{D} = \\{(\\varepsilon_i, \\sigma_i)\\}_{i=1}^N $。不要简化为对数似然函数。您的最终答案必须是一个单一的解析表达式。不需要四舍五入。",
            "solution": "目标是推导似然函数 $L(\\boldsymbol{\\theta}, s \\mid \\mathcal{D}, \\nu) = p(\\{\\sigma_i\\}_{i=1}^N \\mid \\boldsymbol{\\theta}, s, \\nu)$，其中 $\\mathcal{D} = \\{(\\varepsilon_i, \\sigma_i)\\}_{i=1}^N$。问题陈述，在给定参数 $(\\boldsymbol{\\theta}, s, \\nu)$ 的条件下，残差 $r_i(\\boldsymbol{\\theta}) = \\sigma_i - m(\\varepsilon_i;\\boldsymbol{\\theta})$ 在不同观测值 $i$ 之间是独立的。因此，总似然函数是每个独立观测值似然的乘积：\n$$\nL(\\boldsymbol{\\theta}, s \\mid \\mathcal{D}, \\nu) = \\prod_{i=1}^{N} p(\\sigma_i \\mid \\boldsymbol{\\theta}, s, \\nu)\n$$\n由于噪声模型是加性的，即 $\\sigma_i = m(\\varepsilon_i;\\boldsymbol{\\theta}) + r_i$，观测值 $\\sigma_i$ 的概率密度等同于其对应残差 $r_i$ 的概率密度：\n$$\np(\\sigma_i \\mid \\boldsymbol{\\theta}, s, \\nu) = p(r_i(\\boldsymbol{\\theta}) \\mid s, \\nu)\n$$\n因此，我们的任务简化为通过对潜方差 $\\tau_i$进行积分，求出单个残差的边缘概率密度函数 $p(r_i)$。\n\n对于单个残差 $r_i$，分层模型由以下给出：\n1. 残差的条件分布是高斯分布：$r_i \\mid \\tau_i \\sim \\mathcal{N}(0, \\tau_i)$。其概率密度函数（PDF）为：\n$$\np(r_i \\mid \\tau_i) = \\frac{1}{\\sqrt{2\\pi\\tau_i}} \\exp\\left(-\\frac{r_i^2}{2\\tau_i}\\right)\n$$\n2. 潜方差 $\\tau_i$ 服从逆伽马分布：$\\tau_i \\sim \\text{Inverse-Gamma}(\\alpha, \\beta)$，其形状参数为 $\\alpha = \\nu/2$，尺度参数为 $\\beta = \\nu s^2/2$。其 PDF 为：\n$$\np(\\tau_i \\mid s, \\nu) = \\frac{\\beta^{\\alpha}}{\\Gamma(\\alpha)} \\tau_i^{-\\alpha-1} \\exp\\left(-\\frac{\\beta}{\\tau_i}\\right) = \\frac{\\left(\\frac{\\nu s^2}{2}\\right)^{\\frac{\\nu}{2}}}{\\Gamma\\left(\\frac{\\nu}{2}\\right)} \\tau_i^{-\\frac{\\nu}{2}-1} \\exp\\left(-\\frac{\\nu s^2}{2\\tau_i}\\right)\n$$\n其中 $\\Gamma(\\cdot)$ 是伽马函数。\n\n通过对联合概率 $p(r_i, \\tau_i) = p(r_i \\mid \\tau_i) p(\\tau_i)$ 在 $\\tau_i$ 的所有可能值 $\\tau_i \\in (0, \\infty)$ 上积分，可以得到 $r_i$ 的边缘概率：\n$$\np(r_i \\mid s, \\nu) = \\int_{0}^{\\infty} p(r_i \\mid \\tau_i) p(\\tau_i \\mid s, \\nu) \\,d\\tau_i\n$$\n代入 PDF：\n$$\np(r_i \\mid s, \\nu) = \\int_{0}^{\\infty} \\left[ \\frac{1}{\\sqrt{2\\pi\\tau_i}} \\exp\\left(-\\frac{r_i^2}{2\\tau_i}\\right) \\right] \\left[ \\frac{\\left(\\frac{\\nu s^2}{2}\\right)^{\\frac{\\nu}{2}}}{\\Gamma\\left(\\frac{\\nu}{2}\\right)} \\tau_i^{-\\frac{\\nu}{2}-1} \\exp\\left(-\\frac{\\nu s^2}{2\\tau_i}\\right) \\right] \\,d\\tau_i\n$$\n合并包含 $\\tau_i$ 的项：\n$$\np(r_i \\mid s, \\nu) = \\frac{\\left(\\frac{\\nu s^2}{2}\\right)^{\\frac{\\nu}{2}}}{\\sqrt{2\\pi}\\Gamma\\left(\\frac{\\nu}{2}\\right)} \\int_{0}^{\\infty} \\tau_i^{-\\frac{1}{2}} \\tau_i^{-\\frac{\\nu}{2}-1} \\exp\\left(-\\frac{r_i^2}{2\\tau_i} - \\frac{\\nu s^2}{2\\tau_i}\\right) \\,d\\tau_i\n$$\n$$\np(r_i \\mid s, \\nu) = \\frac{\\left(\\frac{\\nu s^2}{2}\\right)^{\\frac{\\nu}{2}}}{\\sqrt{2\\pi}\\Gamma\\left(\\frac{\\nu}{2}\\right)} \\int_{0}^{\\infty} \\tau_i^{-\\left(\\frac{\\nu+1}{2}\\right)-1} \\exp\\left(-\\frac{1}{\\tau_i}\\left(\\frac{r_i^2 + \\nu s^2}{2}\\right)\\right) \\,d\\tau_i\n$$\n该积分的形式为 $\\int_{0}^{\\infty} x^{-a-1} \\exp(-b/x) \\,dx$，这与逆伽马分布的归一化常数有关。此积分的值为 $\\frac{\\Gamma(a)}{b^a}$。\n在我们的例子中，积分的参数为 $a = \\frac{\\nu+1}{2}$ 和 $b = \\frac{r_i^2 + \\nu s^2}{2}$。\n计算该积分得到：\n$$\n\\int_{0}^{\\infty} \\tau_i^{-\\left(\\frac{\\nu+1}{2}\\right)-1} \\exp\\left(-\\frac{1}{\\tau_i}\\left(\\frac{r_i^2 + \\nu s^2}{2}\\right)\\right) \\,d\\tau_i = \\frac{\\Gamma\\left(\\frac{\\nu+1}{2}\\right)}{\\left(\\frac{r_i^2 + \\nu s^2}{2}\\right)^{\\frac{\\nu+1}{2}}}\n$$\n将此结果代回 $p(r_i \\mid s, \\nu)$ 的表达式中：\n$$\np(r_i \\mid s, \\nu) = \\frac{\\left(\\frac{\\nu s^2}{2}\\right)^{\\frac{\\nu}{2}}}{\\sqrt{2\\pi}\\Gamma\\left(\\frac{\\nu}{2}\\right)} \\frac{\\Gamma\\left(\\frac{\\nu+1}{2}\\right)}{\\left(\\frac{r_i^2 + \\nu s^2}{2}\\right)^{\\frac{\\nu+1}{2}}}\n$$\n整理各项以获得标准形式：\n$$\np(r_i \\mid s, \\nu) = \\frac{\\Gamma\\left(\\frac{\\nu+1}{2}\\right)}{\\Gamma\\left(\\frac{\\nu}{2}\\right)\\sqrt{2\\pi}} \\frac{\\left(\\frac{\\nu s^2}{2}\\right)^{\\frac{\\nu}{2}}}{\\left(\\frac{\\nu s^2}{2}\\left(1 + \\frac{r_i^2}{\\nu s^2}\\right)\\right)^{\\frac{\\nu+1}{2}}}\n$$\n$$\np(r_i \\mid s, \\nu) = \\frac{\\Gamma\\left(\\frac{\\nu+1}{2}\\right)}{\\Gamma\\left(\\frac{\\nu}{2}\\right)\\sqrt{2\\pi}} \\frac{\\left(\\frac{\\nu s^2}{2}\\right)^{\\frac{\\nu}{2}}}{\\left(\\frac{\\nu s^2}{2}\\right)^{\\frac{\\nu+1}{2}}\\left(1 + \\frac{r_i^2}{\\nu s^2}\\right)^{\\frac{\\nu+1}{2}}}\n$$\n$$\np(r_i \\mid s, \\nu) = \\frac{\\Gamma\\left(\\frac{\\nu+1}{2}\\right)}{\\Gamma\\left(\\frac{\\nu}{2}\\right)\\sqrt{2\\pi}} \\frac{1}{\\left(\\frac{\\nu s^2}{2}\\right)^{\\frac{1}{2}}} \\left(1 + \\frac{r_i^2}{\\nu s^2}\\right)^{-\\frac{\\nu+1}{2}}\n$$\n$$\np(r_i \\mid s, \\nu) = \\frac{\\Gamma\\left(\\frac{\\nu+1}{2}\\right)}{\\Gamma\\left(\\frac{\\nu}{2}\\right)\\sqrt{\\nu\\pi} s} \\left(1 + \\frac{1}{\\nu}\\left(\\frac{r_i}{s}\\right)^2\\right)^{-\\frac{\\nu+1}{2}}\n$$\n这是具有自由度 $\\nu$、位置 $\\mu=0$ 和尺度 $s$ 的位置-尺度学生t分布的 PDF。\n\n代入 $r_i = \\sigma_i - m(\\varepsilon_i;\\boldsymbol{\\theta})$，单个观测值的似然函数为：\n$$\np(\\sigma_i \\mid \\boldsymbol{\\theta}, s, \\nu) = \\frac{\\Gamma\\left(\\frac{\\nu+1}{2}\\right)}{s \\sqrt{\\nu\\pi} \\Gamma\\left(\\frac{\\nu}{2}\\right)} \\left(1 + \\frac{\\left(\\sigma_i - m(\\varepsilon_i; \\boldsymbol{\\theta})\\right)^2}{\\nu s^2}\\right)^{-\\frac{\\nu+1}{2}}\n$$\n最后，对于 $N$ 个独立观测值的完整似然函数是各个似然函数的乘积：\n$$\nL(\\boldsymbol{\\theta}, s \\mid \\mathcal{D}, \\nu) = \\prod_{i=1}^{N} \\left[ \\frac{\\Gamma\\left(\\frac{\\nu+1}{2}\\right)}{s \\sqrt{\\nu\\pi} \\Gamma\\left(\\frac{\\nu}{2}\\right)} \\left(1 + \\frac{\\left(\\sigma_i - m(\\varepsilon_i; \\boldsymbol{\\theta})\\right)^2}{\\nu s^2}\\right)^{-\\frac{\\nu+1}{2}} \\right]\n$$\n通过提出常数项，可以将其写得更紧凑：\n$$\nL(\\boldsymbol{\\theta}, s \\mid \\mathcal{D}, \\nu) = \\left( \\frac{\\Gamma\\left(\\frac{\\nu+1}{2}\\right)}{s \\sqrt{\\nu\\pi} \\Gamma\\left(\\frac{\\nu}{2}\\right)} \\right)^{N} \\prod_{i=1}^{N} \\left(1 + \\frac{\\left(\\sigma_i - m(\\varepsilon_i; \\boldsymbol{\\theta})\\right)^2}{\\nu s^2}\\right)^{-\\frac{\\nu+1}{2}}\n$$\n这就是所求的似然函数的闭式解析表达式。",
            "answer": "$$\n\\boxed{\\left( \\frac{\\Gamma\\left(\\frac{\\nu+1}{2}\\right)}{s \\sqrt{\\nu\\pi} \\Gamma\\left(\\frac{\\nu}{2}\\right)} \\right)^{N} \\prod_{i=1}^{N} \\left(1 + \\frac{\\left(\\sigma_i - m(\\varepsilon_i; \\boldsymbol{\\theta})\\right)^2}{\\nu s^2}\\right)^{-\\frac{\\nu+1}{2}}}\n$$"
        },
        {
            "introduction": "现代材料校准通常依赖于复杂的计算模型（如有限元方法）来预测实验响应。为了在贝叶斯框架下高效地探索高维参数空间（例如，使用哈密顿蒙特卡洛等梯度驱动的采样方法），计算后验概率对数相对于模型参数的梯度至关重要。本综合练习  旨在连接统计推断与计算力学，您将首先为有限元模型推导伴随梯度，然后通过编程实现它。这项练习是本章的顶点，它整合了非线性固体力学、有限元分析和贝叶斯推断，展示了如何使复杂工程问题的贝叶斯校准在计算上变得可行。",
            "id": "3547183",
            "problem": "考虑一个一维无量纲化的超弹性杆，占据参考域 $[0,L]$，其中 $L=1$。该杆使用有限元 (FE) 方法进行离散化，包含 $N_e$ 个线性单元和 $N_n=N_e+1$ 个节点。节点位移场 $u(X)$ 定义了当前位置 $x=X+u(X)$ 和变形梯度 $F=1+\\frac{du}{dX}$。横截面积为 $A=1$，所有量均为无量纲，因此不涉及物理单位。\n\n假设一个可压缩的 Neo-Hookean 储存能量密度\n$$\nW(F;\\theta)=\\frac{\\mu}{2}\\left(F^2-1\\right)-\\mu\\ln F+\\frac{\\lambda}{2}\\left(\\ln F\\right)^2,\n$$\n其中材料参数为 $\\theta=\\{\\lambda,\\mu\\}$。第一 Piola-Kirchhoff 应力为\n$$\nP(F;\\theta)=\\frac{\\partial W}{\\partial F}=\\mu F-\\frac{\\mu}{F}+\\frac{\\lambda \\ln F}{F}.\n$$\n该杆受到指定的位移边界条件 $u(0)=0$ 和 $u(L)=U_0$ 的作用，没有体力，也没有施加的面力。自由节点自由度的有限元内力残差 $R(u,\\theta)$ 是通过虚功原理得到的。在每个长度为 $h=L/N_e$ 的单元上使用单点积分和线性形函数，单元内力贡献为 $[-P(F;\\theta),+P(F;\\theta)]$，并组装到全局残差中。切线矩阵 $A=\\frac{\\partial R}{\\partial u}$ 是通过对残差关于自由节点位移求导得到的，并通过 $\\frac{\\partial F}{\\partial u}$ 涉及到 $\\frac{\\partial P}{\\partial F}$。\n\n您观察到单元中点的应力，收集在数据向量 $D\\in\\mathbb{R}^m$ 中，其中 $m=N_e$。前向映射 $f(\\theta)$ 计算与边界条件一致的有限元解 $u(\\theta)$，并为每个单元 $e=1,\\dots,N_e$ 返回预测的应力值 $P(F_e;\\theta)$。给定参数的数据似然函数是高斯分布（Gaussian），每个测量点的噪声独立且方差为 $\\sigma^2$：\n$$\np(D\\mid \\theta)\\propto \\exp\\left(-\\frac{1}{2}\\left(D-f(\\theta)\\right)^{\\!\\top}\\Sigma^{-1}\\left(D-f(\\theta)\\right)\\right),\\quad \\Sigma=\\sigma^2 I_m.\n$$\n您的任务是：\n- 从虚功原理和高斯似然定义出发，推导基于伴随方法的梯度 $\\frac{\\partial \\log p(D\\mid\\theta)}{\\partial \\theta}$，以避免对 $\\frac{du}{d\\theta}$ 的显式计算。用 $\\frac{\\partial f}{\\partial \\theta}$、$\\frac{\\partial f}{\\partial u}$、$\\frac{\\partial R}{\\partial u}$ 和 $\\frac{\\partial R}{\\partial \\theta}$ 表示伴随方程和最终的梯度公式。\n- 实现一个完整的程序，该程序：\n  1. 使用给定的 $W(F;\\theta)$ 和 $P(F;\\theta)$，为一维杆建立有限元残差 $R(u,\\theta)$ 和切线矩阵 $A=\\frac{\\partial R}{\\partial u}$。\n  2. 使用牛顿法，根据指定的位移边界条件，求解非线性有限元平衡方程 $R(u,\\theta)=0$。\n  3. 评估前向映射 $f(\\theta)$ 及其灵敏度 $\\frac{\\partial f}{\\partial \\theta}$ 和 $\\frac{\\partial f}{\\partial u}$，组装伴随系统，求解伴随问题，并使用您推导的公式计算 $\\frac{\\partial \\log p(D\\mid\\theta)}{\\partial \\theta}$。\n\n使用以下测试用例集，所有量均为无量纲：\n- 情况 1（一般情况）：$N_e=4$，$U_0=0.2$，$\\sigma=0.05$，候选参数 $\\theta=\\{\\lambda=8.0,\\mu=4.0\\}$，数据 $D=[3.0274117,\\,2.9974117,\\,3.0324117,\\,3.0124117]$。\n- 情况 2（有限应变）：$N_e=3$，$U_0=0.5$，$\\sigma=0.08$，候选参数 $\\theta=\\{\\lambda=12.0,\\mu=6.0\\}$，数据 $D=[8.545232495,\\,8.515232495,\\,8.525232495]$。\n- 情况 3（边缘，接近单位拉伸）：$N_e=2$，$U_0=0.0$，$\\sigma=0.03$，候选参数 $\\theta=\\{\\lambda=10.0,\\mu=5.0\\}$，数据 $D=[0.003,\\,-0.004]$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果必须是该情况下的双分量梯度向量 $[\\frac{\\partial \\log p}{\\partial \\lambda},\\frac{\\partial \\log p}{\\partial \\mu}]$，因此总输出是按测试用例顺序排列的浮点数列表的列表，例如 $[[g_{\\lambda,1},g_{\\mu,1}],[g_{\\lambda,2},g_{\\mu,2}],[g_{\\lambda,3},g_{\\mu,3}]]$。",
            "solution": "### 基于伴随方法的梯度推导\n\n设材料参数向量为 $\\theta = \\{\\lambda, \\mu\\}$。观测值收集在数据向量 $D$ 中。前向模型 $f(\\theta)$ 预测这些观测值。系统的状态由自由节点位移向量 $u$ 表示，它通过非线性有限元平衡方程 $R(u, \\theta) = 0$ 隐式地依赖于 $\\theta$。\n\n对数似然函数，忽略常数项，由下式给出：\n$$\nJ(\\theta) \\equiv \\log p(D \\mid \\theta) = -\\frac{1}{2\\sigma^2} (D - f(u(\\theta), \\theta))^T (D - f(u(\\theta), \\theta))\n$$\n我们的目标是计算 $J$ 相对于 $\\theta$ 的全导数，记为 $\\frac{dJ}{d\\theta}$。应用链式法则，我们得到：\n$$\n\\frac{dJ}{d\\theta} = \\frac{\\partial J}{\\partial \\theta} + \\frac{\\partial J}{\\partial u} \\frac{du}{d\\theta}\n$$\n其中 $\\frac{\\partial J}{\\partial \\theta}$ 和 $\\frac{\\partial J}{\\partial u}$ 是偏导数，而 $\\frac{du}{d\\theta}$ 是位移相对于参数的灵敏度。项 $\\frac{du}{d\\theta}$ 的直接计算成本很高。伴随方法提供了一种绕过其显式计算的优雅方式。\n\n我们通过对平衡方程 $R(u, \\theta) = 0$ 关于 $\\theta$ 求全导数来找到 $\\frac{du}{d\\theta}$ 的表达式：\n$$\n\\frac{dR}{d\\theta} = \\frac{\\partial R}{\\partial \\theta} + \\frac{\\partial R}{\\partial u} \\frac{du}{d\\theta} = 0\n$$\n假设切线刚度矩阵 $A = \\frac{\\partial R}{\\partial u}$ 是可逆的，我们可以写出：\n$$\n\\frac{du}{d\\theta} = - \\left(\\frac{\\partial R}{\\partial u}\\right)^{-1} \\frac{\\partial R}{\\partial \\theta}\n$$\n将此代入 $\\frac{dJ}{d\\theta}$ 的表达式，得到直接灵敏度表达式：\n$$\n\\frac{dJ}{d\\theta} = \\frac{\\partial J}{\\partial \\theta} - \\frac{\\partial J}{\\partial u} \\left(\\frac{\\partial R}{\\partial u}\\right)^{-1} \\frac{\\partial R}{\\partial \\theta}\n$$\n该表达式仍然需要为 $\\theta$ 中的每个参数求解一个线性系统。为了获得伴随公式，我们重新排列各项。我们定义一个新向量，即伴随向量 $\\psi$，作为以下称为伴随方程的线性系统的解：\n$$\n\\left(\\frac{\\partial R}{\\partial u}\\right)^T \\psi = \\left(\\frac{\\partial J}{\\partial u}\\right)^T\n$$\n这个定义允许我们写出 $\\frac{\\partial J}{\\partial u} = \\psi^T \\frac{\\partial R}{\\partial u}$。将此代入梯度表达式：\n$$\n\\frac{dJ}{d\\theta} = \\frac{\\partial J}{\\partial \\theta} - \\left(\\psi^T \\frac{\\partial R}{\\partial u}\\right) \\left(\\frac{\\partial R}{\\partial u}\\right)^{-1} \\frac{\\partial R}{\\partial \\theta} = \\frac{\\partial J}{\\partial \\theta} - \\psi^T \\frac{\\partial R}{\\partial \\theta}\n$$\n这就是最终的基于伴随方法的梯度公式。要使用它，我们需要 $J$ 的偏导数。根据 $J$ 的定义：\n$$\n\\frac{\\partial J}{\\partial u} = \\frac{1}{\\sigma^2} (D - f)^T \\frac{\\partial f}{\\partial u}\n$$\n$$\n\\frac{\\partial J}{\\partial \\theta} = \\frac{1}{\\sigma^2} (D - f)^T \\frac{\\partial f}{\\partial \\theta}\n$$\n将这些代入我们的主要公式，得到可操作的方程：\n\n1.  **伴随方程**：\n    $$\n    \\left(\\frac{\\partial R}{\\partial u}\\right)^T \\psi = \\frac{1}{\\sigma^2} \\left(\\frac{\\partial f}{\\partial u}\\right)^T (D - f)\n    $$\n2.  **梯度公式**：\n    $$\n    \\frac{dJ}{d\\theta} = \\frac{1}{\\sigma^2} (D - f)^T \\frac{\\partial f}{\\partial \\theta} - \\psi^T \\frac{\\partial R}{\\partial \\theta}\n    $$\n\n### 算法实现\n\n计算按以下步骤进行：\n1.  **正向求解**：对于给定的一组参数 $\\theta$，求解非线性方程组 $R(u, \\theta) = 0$，以获得自由度的位移向量 $u$。这是通过使用牛顿法完成的，该方法迭代求解 $A \\Delta u = -R$，其中 $A = \\frac{\\partial R}{\\partial u}$ 是切线刚度矩阵。\n2.  **计算模型预测**：使用收敛的位移场 $u$，为每个单元 $e$ 计算变形梯度 $F_e$ 和第一 Piola-Kirchhoff 应力 $P_e$。这些应力的向量构成了前向模型预测 $f(\\theta) = [P_1, \\dots, P_{N_e}]^T$。\n3.  **计算灵敏度**：在收敛状态 $(u, \\theta)$ 下评估所有必需的偏导数：\n    - $\\frac{\\partial R}{\\partial u}$：切线刚度矩阵 $A$，可从牛顿求解器的最后一步获得。\n    - $\\frac{\\partial R}{\\partial \\theta}$：残差对参数的灵敏度。\n    - $\\frac{\\partial f}{\\partial u}$：预测应力对位移的灵敏度。\n    - $\\frac{\\partial f}{\\partial \\theta}$：预测应力对参数的灵敏度。\n4.  **伴随求解**：组装伴随方程的右侧项 $b_{adj} = \\frac{1}{\\sigma^2} (\\frac{\\partial f}{\\partial u})^T (D - f)$，并求解线性系统 $A^T \\psi = b_{adj}$ 以获得伴随向量 $\\psi$。\n5.  **梯度组装**：计算梯度公式的两项并将它们组合起来，得到最终的梯度向量 $\\frac{dJ}{d\\theta}$。\n\n此过程为问题陈述中提供的每个测试用例实现。一维杆的均匀性简化了问题，因为平衡位移场是线性的，导致所有单元的变形梯度 $F$ 均一。这导致 $\\frac{\\partial R}{\\partial \\theta} = 0$，将这些特定情况的梯度计算简化为仅第一项 $\\frac{1}{\\sigma^2} (D-f)^T \\frac{\\partial f}{\\partial \\theta}$。然而，该实现是通用的，不依赖于此简化。",
            "answer": "```python\nimport numpy as np\n\ndef solve_fe(params, Ne, U0):\n    \"\"\"\n    Solves the nonlinear FE equilibrium equation R(u, theta) = 0 using Newton's method.\n    \"\"\"\n    lambda_, mu = params\n    L = 1.0\n    h = L / Ne\n    num_free_dof = Ne - 1\n\n    if num_free_dof == 0:\n        # Case with no free DOFs (e.g., Ne=1)\n        u = np.linspace(0, U0, Ne + 1)\n        F = 1.0 + np.diff(u) / h\n        lnF = np.log(F)\n        P_prime = mu + mu / F**2 + lambda_ * (1 - lnF) / F**2\n        A = np.array([[]]) # No tangent for free dofs\n        return u, A, True\n\n    # Initial guess: linear displacement profile\n    u_free = np.linspace(0, U0, Ne + 1)[1:-1]\n    \n    max_iter = 20\n    tol = 1e-10\n\n    A = np.zeros((num_free_dof, num_free_dof))\n\n    for _ in range(max_iter):\n        u = np.concatenate(([0], u_free, [U0]))\n        \n        u_diff = np.diff(u)\n        F = 1.0 + u_diff / h\n        \n        if np.any(F = 0):\n            return None, None, False\n\n        lnF = np.log(F)\n        P = mu * F - mu / F + lambda_ * lnF / F\n        \n        R_free = P[1:] - P[:-1]\n        \n        norm_R = np.linalg.norm(R_free)\n        if norm_R  tol:\n            # Converged. Re-compute tangent for return.\n            P_prime = mu + mu / F**2 + lambda_ * (1 - lnF) / F**2\n            diag = -(P_prime[1:] + P_prime[:-1]) / h\n            sup_diag = P_prime[1:-1] / h\n            sub_diag = P_prime[1:-1] / h\n            A = np.diag(diag) + np.diag(sup_diag, k=1) + np.diag(sub_diag, k=-1)\n            return u, A, True\n\n        P_prime = mu + mu / F**2 + lambda_ * (1 - lnF) / F**2\n        \n        diag = -(P_prime[1:] + P_prime[:-1]) / h\n        A = np.diag(diag)\n        if num_free_dof > 1:\n            sup_diag = P_prime[1:-1] / h\n            sub_diag = P_prime[1:-1] / h\n            A += np.diag(sup_diag, k=1) + np.diag(sub_diag, k=-1)\n\n        delta_u = np.linalg.solve(A, -R_free)\n        u_free += delta_u\n            \n    return None, None, False # Did not converge\n\ndef calculate_gradient(params, Ne, U0, sigma, D):\n    \"\"\"\n    Calculates the adjoint-based gradient of the log-likelihood.\n    \"\"\"\n    lambda_, mu = params\n    h = 1.0 / Ne\n    num_free_dof = Ne - 1\n    \n    # 1. Forward Solve\n    u, A, converged = solve_fe(params, Ne, U0)\n    if not converged:\n        raise RuntimeError(\"FE solver did not converge for the given parameters.\")\n\n    # 2. Compute Model Prediction f(theta) and its derivatives\n    u_diff = np.diff(u)\n    F = 1.0 + u_diff / h\n    lnF = np.log(F)\n    \n    f_theta = mu * F - mu / F + lambda_ * lnF / F\n    misfit = D - f_theta\n    \n    # 3. Compute Sensitivities\n    # Partial derivative of P wrt F\n    P_prime = mu + mu / F**2 + lambda_ * (1 - lnF) / F**2\n\n    # df/dtheta (Ne x 2 matrix)\n    df_dlambda = lnF / F\n    df_dmu = F - 1.0 / F\n    df_dtheta = np.vstack((df_dlambda, df_dmu)).T\n    \n    if num_free_dof > 0:\n        # dR/dtheta ((Ne-1) x 2 matrix)\n        dR_dlambda = df_dlambda[1:] - df_dlambda[:-1]\n        dR_dmu = df_dmu[1:] - df_dmu[:-1]\n        dR_dtheta = np.vstack((dR_dlambda, dR_dmu)).T\n\n        # df/du_free (Ne x (Ne-1) matrix)\n        # u_free[j] corresponds to nodal displacement u_{j+1}\n        # df_e/du_free[j] = dP_e/dF_e * dF_e/du_{j+1}\n        df_du_free = np.zeros((Ne, num_free_dof))\n        for e in range(Ne): # over elements (rows)\n            # Contribution from u_{e+1} dependency\n            if e  num_free_dof: # u_{e+1} is u_free[e]\n                df_du_free[e, e] += P_prime[e] / h\n            # Contribution from u_e dependency\n            if e > 0 and (e - 1)  num_free_dof: # u_e is u_free[e-1]\n                df_du_free[e, e - 1] -= P_prime[e] / h\n        \n        # 4. Adjoint Solve\n        b_adj = df_du_free.T @ misfit / (sigma**2)\n        psi = np.linalg.solve(A.T, b_adj)\n        \n        # 5. Gradient Assembly\n        term1 = (misfit @ df_dtheta) / (sigma**2)\n        term2 = psi.T @ dR_dtheta\n        grad = term1 - term2\n    else: # No free dofs, gradient has no adjoint part\n        term1 = (misfit @ df_dtheta) / (sigma**2)\n        grad = term1\n\n    return grad.tolist()\n\ndef solve():\n    test_cases = [\n        {'Ne': 4, 'U0': 0.2, 'sigma': 0.05, 'params': (8.0, 4.0), \n         'D': np.array([3.0274117, 2.9974117, 3.0324117, 3.0124117])},\n        {'Ne': 3, 'U0': 0.5, 'sigma': 0.08, 'params': (12.0, 6.0), \n         'D': np.array([8.545232495, 8.515232495, 8.525232495])},\n        {'Ne': 2, 'U0': 0.0, 'sigma': 0.03, 'params': (10.0, 5.0), \n         'D': np.array([0.003, -0.004])},\n    ]\n\n    results = []\n    for case in test_cases:\n        grad = calculate_gradient(case['params'], case['Ne'], case['U0'], case['sigma'], case['D'])\n        results.append(grad)\n\n    # Format the output exactly as required.\n    # e.g., [[g_lam1,g_mu1],[g_lam2,g_mu2],[g_lam3,g_mu3]]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}