{
    "hands_on_practices": [
        {
            "introduction": "要建立稳健的接触仿真，我们必须首先理解单个接触相互作用是如何转化为有限元方法的语言的。本练习通过计算单个积分点对全局方程组的贡献，深入探讨了接触公式的核心 。通过对节点-片段（NTS）单元的虚功原理进行离散化，您将具体地理解残差向量（力）和切向矩阵（刚度）是如何组装的，它们构成了任何隐式接触分析的基本构建模块。",
            "id": "3584757",
            "problem": "考虑在平面应变设置下，单个从节点与一个直线双节点主段之间的无摩擦单边接触，该接触通过有限元法 (FEM) 使用基于砂浆类积分的点对面 (NTS) 公式进行离散化。主段的端点坐标为 $\\boldsymbol{x}_1=(0,\\,0)$ 和 $\\boldsymbol{x}_2=(0.1,\\,0)$，因此其物理长度为 $L=\\sqrt{(0.1-0)^{2}+(0-0)^{2}}=0.1\\,\\text{m}$。假设单位外法线方向在从节点的投影点处定义，并且接触是激活的，法向间隙为 $g_{n}=-2.0\\times 10^{-4}\\,\\text{m}$ (穿透为负值)。在激活接触中，法向接触牵引力遵循线性罚函数法 $p_{n}=-\\epsilon\\,g_{n}$，其中单位面积的法向罚刚度为 $\\epsilon=5.0\\times 10^{10}\\,\\text{N/m}^{3}$。取平面外厚度为 $t=1.0\\times 10^{-2}\\,\\text{m}$。\n\n在主段上使用位于参数坐标 $\\xi_{g}=\\sqrt{3}/3$ 的单个高斯点，其高斯权重为 $w_{g}=1$。主段在参考区间 $\\xi\\in[-1,1]$ 上使用标准线性等参形函数进行插值，形函数为 $N_{1}(\\xi)=\\frac{1-\\xi}{2}$ 和 $N_{2}(\\xi)=\\frac{1+\\xi}{2}$。该直线段的等参映射雅可比范数为 $J(\\xi)=\\left\\lVert \\frac{\\partial \\boldsymbol{x}}{\\partial \\xi}\\right\\rVert=\\frac{L}{2}$。\n\n从接触的虚功原理和罚牵引力的定义出发，推导单个高斯点对以下各项的贡献：\n- 与主节点2相关的法向标量残差，记为 $R_{2}^{n}$，\n- 关于法向间隙的相应标量一致切线，记为 $K_{2}^{n}=\\frac{\\partial R_{2}^{n}}{\\partial g_{n}}$，\n\n在沿主段的砂浆类积分下。以 $\\text{N}$ 为单位表示 $R_{2}^{n}$，以 $\\text{N/m}$ 为单位表示 $K_{2}^{n}$。将两个量都四舍五入到四位有效数字。以行矩阵 $\\begin{pmatrix}R_{2}^{n}  K_{2}^{n}\\end{pmatrix}$ 的形式报告你的最终答案。",
            "solution": "我们从基于虚功原理的法向接触的弱形式开始。对于无摩擦单边接触，主面上的接触虚功可以写为\n$$\n\\delta W_{c}=\\int_{\\Gamma_{m}} p_{n}\\,\\delta g_{n}\\, t\\, \\mathrm{d}\\Gamma,\n$$\n其中 $\\Gamma_{m}$ 是主接触段，$p_{n}$ 是法向接触牵引力，$g_{n}$ 是法向间隙，$t$ 是平面外厚度，$\\mathrm{d}\\Gamma$ 是物理空间中的线元。在罚函数法中，对于激活接触 ($g_{n}  0$)，牵引力为\n$$\np_{n}=-\\epsilon\\,g_{n},\n$$\n其中 $\\epsilon$ 是单位面积的法向罚刚度 (单位 $\\text{N/m}^{3}$)，因此 $p_{n}$ 的单位是应力单位 $\\text{N/m}^{2}$。\n\n在砂浆类NTS离散化中，与主节点 $i$ 相关的法向残差贡献是通过用主段形函数 $N_{i}$ 加权并沿该段积分得到的。对于单个高斯点，这简化为\n$$\nR_{i}^{n}\\approx -\\,w_{g}\\,J(\\xi_{g})\\,t\\,N_{i}(\\xi_{g})\\,p_{n}(\\xi_{g}).\n$$\n负号反映了主从之间的作用力与反作用力：作用在主段上的压缩牵引力会产生一个与主面法向上的从节点穿透方向相反的残差。使用高斯点处的罚函数法，\n$$\np_{n}(\\xi_{g})=-\\epsilon\\,g_{n},\n$$\n我们有\n$$\nR_{i}^{n} = -\\,w_{g}\\,J(\\xi_{g})\\,t\\,N_{i}(\\xi_{g})\\,\\big(-\\epsilon\\,g_{n}\\big)\n= w_{g}\\,J(\\xi_{g})\\,t\\,N_{i}(\\xi_{g})\\,\\epsilon\\,g_{n}.\n$$\n\n关于法向间隙的此高斯点贡献的一致切线是通过对 $R_{i}^{n}$ 关于 $g_{n}$ 求导得到的：\n$$\nK_{i}^{n}=\\frac{\\partial R_{i}^{n}}{\\partial g_{n}}=w_{g}\\,J(\\xi_{g})\\,t\\,N_{i}(\\xi_{g})\\,\\epsilon.\n$$\n\n我们现在专门针对主节点 $i=2$ 并根据给定的数据计算这些量。首先，计算该直线段的雅可比范数：\n$$\nL=\\sqrt{(0.1-0)^{2}+(0-0)^{2}}=0.1\\,\\text{m},\\qquad J(\\xi_{g})=\\frac{L}{2}=\\frac{0.1}{2}=0.05\\,\\text{m}.\n$$\n在 $\\xi_{g}=\\sqrt{3}/3$ 处计算形函数：\n$$\nN_{2}(\\xi)=\\frac{1+\\xi}{2}\\quad\\Rightarrow\\quad N_{2}(\\xi_{g})=\\frac{1+\\sqrt{3}/3}{2}.\n$$\n为了进行数值计算，使用 $\\sqrt{3}\\approx 1.732050807568877$，因此\n$$\n\\xi_{g}=\\frac{\\sqrt{3}}{3}\\approx 0.5773502691896257,\\quad N_{2}(\\xi_{g})=\\frac{1+0.5773502691896257}{2}\\approx 0.7886751345948129.\n$$\n高斯权重为 $w_{g}=1$，厚度为 $t=1.0\\times 10^{-2}\\,\\text{m}$，罚刚度为 $\\epsilon=5.0\\times 10^{10}\\,\\text{N/m}^{3}$，间隙为 $g_{n}=-2.0\\times 10^{-4}\\,\\text{m}$。\n\n计算残差贡献：\n$$\nR_{2}^{n} = w_{g}\\,J(\\xi_{g})\\,t\\,N_{2}(\\xi_{g})\\,\\epsilon\\,g_{n}\n= (1)\\,(0.05)\\,(1.0\\times 10^{-2})\\,(0.7886751345948129)\\,(5.0\\times 10^{10})\\,(-2.0\\times 10^{-4}).\n$$\n组合各项因子：\n$$\nw_{g}\\,J\\,t\\,N_{2}\\approx 1\\times 0.05\\times 0.01\\times 0.7886751346 \\approx 3.943375672974064\\times 10^{-4},\n$$\n然后\n$$\nR_{2}^{n}\\approx \\big(3.943375672974064\\times 10^{-4}\\big)\\times \\big(5.0\\times 10^{10}\\big)\\times \\big(-2.0\\times 10^{-4}\\big)\n= -3.943375672974064\\times 10^{3}\\,\\text{N}.\n$$\n\n计算切线贡献：\n$$\nK_{2}^{n}=w_{g}\\,J(\\xi_{g})\\,t\\,N_{2}(\\xi_{g})\\,\\epsilon\n= \\big(3.943375672974064\\times 10^{-4}\\big)\\times \\big(5.0\\times 10^{10}\\big)\n= 1.971687836487032\\times 10^{7}\\,\\text{N/m}.\n$$\n\n最后，将两个量都四舍五入到四位有效数字，并以行矩阵的形式报告：\n$$\nR_{2}^{n}\\approx -3.943\\times 10^{3}\\,\\text{N},\\qquad K_{2}^{n}\\approx 1.972\\times 10^{7}\\,\\text{N/m}.\n$$",
            "answer": "$$\\boxed{\\begin{pmatrix}-3.943 \\times 10^{3}  1.972 \\times 10^{7}\\end{pmatrix}}$$"
        },
        {
            "introduction": "尽管不同的接触离散化方案看起来可能相似，但它们的性能差异可能很大。本练习通过在经典的赫兹接触基准问题上评估节点-片段（NTS）和片段-片段（STS）方法的精度和收敛速度，对这两种方法进行了实践性比较 。通过数值验证更高阶的STS公式能产生更精确的结果，您将对不同建模选择之间的权衡有更实际的理解，并体会到为可靠的工程分析选择合适离散化方案的重要性。",
            "id": "3584744",
            "problem": "考虑一个在闭区间 $\\left[-a,a\\right]$ 上的一维赫兹线接触基准问题，其精确的法向接触压力分布为 $p(x)=p_{0}\\,\\sqrt{1-\\left(\\frac{x}{a}\\right)^{2}}$（其中 $x\\in\\left[-a,a\\right]$），并以无量纲单位表示。该压力源于弹性体之间的经典无摩擦法向接触，是一个在接触边缘 $x=\\pm a$ 处以平方根形式消失的光滑函数。您将比较两种离散接触压力表示方法，并量化它们在网格加密时的收敛率。\n\n需要对比的两种方案定义如下。\n- 片段-片段 (STS) 方法：将有限维空间 $\\mathcal{V}_{h}$ 定义为在将 $\\left[-a,a\\right]$ 均匀剖分为 $N$ 个尺寸为 $h=\\frac{2a}{N}$ 的相等线段上的一组连续分段线性函数。STS 近似 $p_{h}^{\\mathrm{STS}}\\in\\mathcal{V}_{h}$ 是 $p$ 在 $\\mathcal{V}_{h}$ 上的 $L^{2}$-正交投影，即它满足变分形式 $\\int_{-a}^{a}\\left(p_{h}^{\\mathrm{STS}}(x)-p(x)\\right)\\,v_{h}(x)\\,\\mathrm{d}x=0$ 对所有 $v_{h}\\in\\mathcal{V}_{h}$ 成立。\n- 节点-片段 (NTS) 方法：将有限维空间 $\\mathcal{W}_{h}$ 定义为在相同剖分上的一组分段常数函数。NTS 近似 $p_{h}^{\\mathrm{NTS}}\\in\\mathcal{W}_{h}$ 通过在每个单元的左端点进行节点配置来定义：在单元 $e=\\left[x_{i},x_{i+1}\\right]$ 上，对所有 $x\\in e$ 设 $p_{h}^{\\mathrm{NTS}}(x)=p(x_{i})$，其中 $x_{i}=-a+i\\,h$ 对应 $i\\in\\{0,1,\\dots,N-1\\}$。\n\n每个近似的精度通过相对 $L^{2}$ 误差来衡量\n$$\ne(h)=\\frac{\\left\\|p-p_{h}\\right\\|_{L^{2}(-a,a)}}{\\left\\|p\\right\\|_{L^{2}(-a,a)}},\\quad \\left\\|q\\right\\|_{L^{2}(-a,a)}=\\left(\\int_{-a}^{a}q(x)^{2}\\,\\mathrm{d}x\\right)^{\\frac{1}{2}}.\n$$\n所有积分必须使用足够高的数值积分精度进行计算，以可靠地解析 $x=\\pm a$ 附近的平方根行为；每个单元使用高阶高斯-勒让德积分来计算所需的积分。\n\n对于一组网格尺寸 $\\{h_{k}\\}$ 和相应的误差 $\\{e(h_{k})\\}$，将一种方法的实验收敛率 $r$ 定义为在最小二乘意义下映射 $\\log h_{k}\\mapsto \\log e(h_{k})$ 的最佳拟合直线的斜率，即在所有给定的网格尺寸上，$\\log e$ 对 $\\log h$ 的线性回归斜率。\n\n必须使用以下概念基础来推导和实现该过程：\n- 连续介质力学中的无摩擦单边接触受间隙与法向牵引力之间的互补性以及线动量平衡的制约；在本基准问题中，精确压力 $p(x)$ 是先验已知的。\n- 在 $L^{2}$ 内积中的正交投影最小化了子空间上的 $L^{2}$ 误差，并导出由所选基的质量矩阵构成的对称正定线性系统。\n- 基于左端点节点值的分段常数配置是在均匀网格上对光滑场的一致、一阶表示。\n\n任务：对于下面的每个测试用例，构建具有 $N$ 个单元的均匀网格，在这些网格上按上述定义计算 $p_{h}^{\\mathrm{STS}}$ 和 $p_{h}^{\\mathrm{NTS}}$，评估 $e^{\\mathrm{STS}}(h)$ 和 $e^{\\mathrm{NTS}}(h)$，然后通过对数据对 $\\left(\\log h,\\log e\\right)$ 进行最小二乘法来估计收敛率 $r^{\\mathrm{STS}}$ 和 $r^{\\mathrm{NTS}}$。此外，对于每个测试用例，确定在最精细的网格（最小的 $h$）上，STS 方法是否比 NTS 方法更精确，即检查 $e^{\\mathrm{STS}}(h_{\\min})  e^{\\mathrm{NTS}}(h_{\\min})$。",
            "solution": "本问题要求对比两种离散化方法（STS和NTS）在逼近一维赫兹接触压力分布时的精度和收敛率。\n\n### 1. 近似方案\n\n**片段-片段 (STS) 方法**:\nSTS近似 $p_h^{\\mathrm{STS}}$ 是精确解 $p(x)$ 在连续分段线性函数空间 $\\mathcal{V}_h$ 上的 $L^2$ 正交投影。设 $p_h^{\\mathrm{STS}}(x) = \\sum_{j=0}^{N} c_j N_j(x)$，其中 $N_j(x)$ 是节点 $j$ 处的标准“帽”状基函数，$c_j$ 是未知的节点系数。$L^2$ 投影的变分形式为：\n$$\n\\int_{-a}^{a} p_h^{\\mathrm{STS}}(x) v_h(x) dx = \\int_{-a}^{a} p(x) v_h(x) dx \\quad \\forall v_h \\in \\mathcal{V}_h\n$$\n取测试函数 $v_h$ 为基函数 $N_i(x)$，可得一个线性方程组 $\\mathbf{M}\\mathbf{c} = \\mathbf{f}$，其中：\n- $\\mathbf{c} = \\{c_j\\}$ 是待求解的节点系数组。\n- $\\mathbf{M}$ 是质量矩阵，其元素为 $M_{ij} = \\int_{-a}^{a} N_i(x) N_j(x) dx$。对于均匀网格，这是一个三对角矩阵。\n- $\\mathbf{f}$ 是载荷向量，其元素为 $f_i = \\int_{-a}^{a} p(x) N_i(x) dx$。\n\n解出 $\\mathbf{c}$ 后，即可得到 $p_h^{\\mathrm{STS}}$。\n\n**节点-片段 (NTS) 方法**:\nNTS近似 $p_h^{\\mathrm{NTS}}$ 是一种更简单的分段常数插值。在每个单元 $e_i = [x_i, x_{i+1}]$ 上，其值被定义为该单元左端点处的精确值：\n$$\np_h^{\\mathrm{NTS}}(x) = p(x_i) \\quad \\forall x \\in [x_i, x_{i+1})\n$$\n\n### 2. 误差计算与收敛率\n\n对于每种方法，相对 $L^2$ 误差按下式计算：\n$$\ne(h) = \\frac{\\|p - p_h\\|_{L^2}}{\\|p\\|_{L^2}} = \\frac{\\left(\\int_{-a}^{a} (p(x) - p_h(x))^2 dx\\right)^{1/2}}{\\left(\\int_{-a}^{a} p(x)^2 dx\\right)^{1/2}}\n$$\n其中，积分使用高阶高斯数值积分在每个单元上分别计算，然后求和。\n\n对于STS方法，利用 $L^2$ 投影的正交性，误差可以更高效地计算：\n$$\n\\|p - p_h^{\\mathrm{STS}}\\|^2 = \\|p\\|^2 - \\|p_h^{\\mathrm{STS}}\\|^2 = \\|p\\|^2 - \\mathbf{c}^T \\mathbf{M} \\mathbf{c} = \\|p\\|^2 - \\mathbf{c}^T \\mathbf{f}\n$$\n精确解的 $L^2$ 范数的平方是可解析计算的：$\\|p\\|^2 = \\int_{-a}^{a} p_0^2(1-(x/a)^2) dx = \\frac{4}{3} a p_0^2$。\n\n收敛率 $r$ 描述了当网格尺寸 $h$ 减小时，误差 $e(h)$ 的下降速度，满足 $e(h) \\approx C h^r$。在对数坐标下，$\\log(e) \\approx \\log(C) + r \\log(h)$。因此，收敛率 $r$ 是 $\\log(e)$ 关于 $\\log(h)$ 的线性回归直线的斜率。\n\n赫兹压力函数 $p(x)$ 在接触区域边缘 $x=\\pm a$ 处其导数是奇异的，这会影响高阶方法的收敛率。理论上，对于此类函数，分段常数近似（NTS）的收敛率为 $r \\approx 1.0$，而分段线性 $L^2$ 投影（STS）的收敛率为 $r \\approx 1.5$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef p_func(x, a, p0):\n    \"\"\"\n    Computes the exact Hertzian pressure p(x). Uses np.maximum to prevent\n    taking the square root of a small negative number due to floating point\n    inaccuracies for x near +-a.\n    \"\"\"\n    arg = 1.0 - (x / a)**2\n    return p0 * np.sqrt(np.maximum(0, arg))\n\ndef calculate_nts_error_sq(a, p0, N, h, q_points, q_weights):\n    \"\"\"\n    Calculates the squared L2 error for the Node-to-Segment (NTS) approximation.\n    The NTS approximation is piecewise constant, defined by nodal collocation\n    at the left endpoint of each element.\n    \"\"\"\n    nodes = np.linspace(-a, a, N + 1)\n    total_error_sq = 0.0\n    for i in range(N):\n        x_i, x_i1 = nodes[i], nodes[i+1]\n        \n        # NTS approximation is p(x_i) on element i.\n        p_val_at_node = p_func(x_i, a, p0)\n        \n        # Map standard quadrature points [-1, 1] to the element [x_i, x_i1]\n        x_q = 0.5 * h * q_points + 0.5 * (x_i + x_i1)\n        \n        # Evaluate exact pressure and the integrand at quadrature points\n        p_vals_q = p_func(x_q, a, p0)\n        integrand = (p_vals_q - p_val_at_node)**2\n        \n        # Numerically compute the integral over the element. Jacobian is h/2.\n        elem_integral = (h / 2.0) * np.sum(q_weights * integrand)\n        total_error_sq += elem_integral\n        \n    return total_error_sq\n\ndef calculate_sts_error_sq(a, p0, N, h, p_norm_sq, q_points, q_weights):\n    \"\"\"\n    Calculates the squared L2 error for the Segment-to-Segment (STS) approximation.\n    The STS approximation is the L^2 projection onto piecewise linear functions.\n    \"\"\"\n    num_nodes = N + 1\n    nodes = np.linspace(-a, a, num_nodes)\n    \n    # Assemble the consistent mass matrix M for 1D linear elements on a uniform mesh\n    M = np.zeros((num_nodes, num_nodes))\n    diag = np.full(num_nodes, 2.0 * h / 3.0)\n    diag[0] = h / 3.0\n    diag[-1] = h / 3.0\n    off_diag = np.full(num_nodes - 1, h / 6.0)\n    M += np.diag(diag) + np.diag(off_diag, k=1) + np.diag(off_diag, k=-1)\n    \n    # Assemble the load vector f, where f_k = integral(p(x) * N_k(x) dx)\n    f = np.zeros(num_nodes)\n    for k in range(num_nodes):\n        f_k = 0.0\n        \n        # Contribution from the left element [x_{k-1}, x_k]\n        if k > 0:\n            x_start, x_end = nodes[k-1], nodes[k]\n            x_q = 0.5 * h * q_points + 0.5 * (x_start + x_end)\n            basis_vals = (x_q - x_start) / h\n            p_vals = p_func(x_q, a, p0)\n            f_k += (h / 2.0) * np.sum(q_weights * p_vals * basis_vals)\n            \n        # Contribution from the right element [x_k, x_{k+1}]\n        if k  N:\n            x_start, x_end = nodes[k], nodes[k+1]\n            x_q = 0.5 * h * q_points + 0.5 * (x_start + x_end)\n            basis_vals = (x_end - x_q) / h\n            p_vals = p_func(x_q, a, p0)\n            f_k += (h / 2.0) * np.sum(q_weights * p_vals * basis_vals)\n            \n        f[k] = f_k\n        \n    # Solve the system Mc = f for the nodal coefficients c\n    c = np.linalg.solve(M, f)\n    \n    # Compute error using the orthogonality property: ||p-p_h||^2 = ||p||^2 - c^T f\n    error_sq = p_norm_sq - np.dot(c, f)\n    \n    return error_sq\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'a': 1.0, 'p0': 1.0, 'N_values': [8, 16, 32, 64]},\n        {'a': 1.0, 'p0': 3.0, 'N_values': [8, 16, 32, 64]},\n        {'a': 0.5, 'p0': 2.0, 'N_values': [10, 20, 40, 80]},\n    ]\n    \n    # High-order quadrature is specified to handle the function's square-root behavior.\n    QUAD_ORDER = 40\n    q_points, q_weights = np.polynomial.legendre.leggauss(QUAD_ORDER)\n\n    all_results = []\n\n    for case in test_cases:\n        a = case['a']\n        p0 = case['p0']\n        N_values = case['N_values']\n\n        h_list = []\n        e_sts_list = []\n        e_nts_list = []\n\n        # Analytical L2 norm squared of p(x) for relative error calculation.\n        # ||p||^2 = integral_{-a to a} (p0^2 * (1-(x/a)^2)) dx = (4/3)*a*p0^2\n        p_norm_sq = (4.0 / 3.0) * a * p0**2\n\n        for N in N_values:\n            h = 2.0 * a / N\n            h_list.append(h)\n            \n            # NTS error calculation\n            nts_error_sq = calculate_nts_error_sq(a, p0, N, h, q_points, q_weights)\n            e_nts = np.sqrt(nts_error_sq / p_norm_sq)\n            e_nts_list.append(e_nts)\n            \n            # STS error calculation\n            sts_error_sq = calculate_sts_error_sq(a, p0, N, h, p_norm_sq, q_points, q_weights)\n            e_sts = np.sqrt(max(0, sts_error_sq) / p_norm_sq)\n            e_sts_list.append(e_sts)\n\n        # Convergence rate is the slope of log(e) vs log(h)\n        log_h = np.log(h_list)\n        log_e_sts = np.log(e_sts_list)\n        log_e_nts = np.log(e_nts_list)\n        \n        # Use numpy's polyfit for linear regression\n        r_sts = np.polyfit(log_h, log_e_sts, 1)[0]\n        r_nts = np.polyfit(log_h, log_e_nts, 1)[0]\n        \n        # Compare accuracy at the finest mesh (last element in the list)\n        is_sts_more_accurate = e_sts_list[-1]  e_nts_list[-1]\n        \n        # Store results rounded as specified\n        case_result = [round(r_sts, 3), round(r_nts, 3), is_sts_more_accurate]\n        all_results.append(case_result)\n        \n    # Format the final output string to match the required format e.g., [[r1,r2,b1],[...]]\n    # with no spaces between list elements.\n    list_of_str_results = []\n    for res in all_results:\n        # Python's default str(bool) is 'True' or 'False'.\n        list_of_str_results.append(f\"[{res[0]},{res[1]},{str(res[2])}]\")\n    final_output_str = f\"[{','.join(list_of_str_results)}]\"\n    print(final_output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "现实世界中的接触很少是无摩擦的。本练习聚焦于库仑摩擦定律的数值实现，这是真实接触仿真的基石 。您将使用径向回归方法（计算塑性力学中的一种基本算法）实现一个预测-校正方案，以更新切向牵引力。本练习将巩固您对如何增量式地施加非线性约束的理解，并为您在固体力学中模拟路径相关现象提供一项关键技能。",
            "id": "3584809",
            "problem": "考虑计算固体力学中的一个摩擦接触相互作用，该作用发生在一个从节点和一个平面（维度 $d=2$）中的直段（主段）之间。令线段外法线向量为 $\\mathbf{n}\\in\\mathbb{R}^2$（不一定是单位长度），节点相对于最近点投影处的线段的相对速度为 $\\mathbf{v}_{\\text{rel}}\\in\\mathbb{R}^2$，时间步长为 $\\Delta t0$。目标是计算该时间步长内的切向滑移增量 $\\Delta\\boldsymbol{\\delta}_t\\in\\mathbb{R}^2$，并使用带有径向返回到库仑摩擦锥的弹塑性预测-校正方法来更新切向牵引力 $\\mathbf{t}_t^{n+1}\\in\\mathbb{R}^2$。您需要从基本原理开始：相对运动的运动学，到由接触法线定义的切向子空间的正交投影，以及在切向方向上使用罚函数类型弹性预测的库仑摩擦定律的定义。不要假设任何预先推导出的接触公式；相反，从这些基础出发推导所需的操作算子。\n\n每个测试用例的输入为：\n- 一个线段法线 $\\mathbf{n}$，\n- 一个相对速度 $\\mathbf{v}_{\\text{rel}}$，\n- 一个时间步长 $\\Delta t$（单位：秒），\n- 一个切向罚刚度 $k_t$（单位：帕斯卡/米），\n- 一个摩擦系数 $\\mu$（无量纲），\n- 一个法向接触压力 $p_n\\ge 0$（单位：帕斯卡，压缩为正），\n- 以及上一步的切向牵引力 $\\mathbf{t}_t^{n}\\in\\mathbb{R}^2$（单位：帕斯卡）。\n\n需要实现和论证的任务：\n- 从运动学出发，使用相对位移增量 $\\Delta \\mathbf{u}_{\\text{rel}}=\\mathbf{v}_{\\text{rel}}\\,\\Delta t$ 构建到与单位法线 $\\widehat{\\mathbf{n}}=\\mathbf{n}/\\|\\mathbf{n}\\|$ 正交的切向子空间上的欧几里得正交投影算子，然后应用它来获得切向滑移增量 $\\Delta\\boldsymbol{\\delta}_t$。\n- 使用罚刚度和计算出的 $\\Delta\\boldsymbol{\\delta}_t$ 对切向牵引力进行弹性预测，以获得试探切向牵引力 $\\mathbf{t}_t^{\\text{trial}}$。\n- 通过最近点（径向返回）映射强制执行摩擦系数为 $\\mu$ 和法向接触压力为 $p_n$ 的库仑摩擦条件：如果试探牵引力的大小超过摩擦边界，则返回到摩擦锥的表面；否则，保持粘滞。\n- 通过将 $\\mathbf{n}$ 归一化为单位长度，并使用一个小的容差处理 $\\|\\mathbf{t}_t^{\\text{trial}}\\|$ 接近于零的情况，来确保数值鲁棒性。将压缩视为正，因此摩擦边界为 $\\mu\\,p_n$。\n\n科学和数值要求：\n- 所有长度单位为米，时间单位为秒，牵引力和压力单位为帕斯卡。\n- 切向滑移增量 $\\Delta\\boldsymbol{\\delta}_t$ 必须以米为单位报告，更新后的切向牵引力 $\\mathbf{t}_t^{n+1}$ 必须以帕斯卡为单位报告。\n- 不需要角度；如果任何内部计算使用角度，它们必须是弧度。\n- 您的算法必须适用于任何 $\\|\\mathbf{n}\\|0$ 的 $\\mathbf{n}\\in\\mathbb{R}^2$ 和任何 $\\mathbf{v}_{\\text{rel}}\\in\\mathbb{R}^2$。\n\n测试套件：\n为以下五个案例提供结果。对于每个案例，计算 $\\Delta\\boldsymbol{\\delta}_t$ 和 $\\mathbf{t}_t^{n+1}$。\n\n- 案例 1（滑动，轴对齐法线）：\n  - $\\mathbf{n}=[0,1]$，$\\mathbf{v}_{\\text{rel}}=[0.1,-0.2]$（单位：米/秒），$\\Delta t=0.01$ 秒，$k_t=10^6$ 帕斯卡/米，$\\mu=0.3$，$p_n=1000$ 帕斯卡，$\\mathbf{t}_t^{n}=[0,0]$ 帕斯卡。\n\n- 案例 2（粘滞，小切向增量）：\n  - $\\mathbf{n}=[0,1]$，$\\mathbf{v}_{\\text{rel}}=[0.001,0.0]$（单位：米/秒），$\\Delta t=0.001$ 秒，$k_t=10^6$ 帕斯卡/米，$\\mu=0.4$，$p_n=500$ 帕斯卡，$\\mathbf{t}_t^{n}=[0,0]$ 帕斯卡。\n\n- 案例 3（在摩擦边界上，无需返回）：\n  - $\\mathbf{n}=[0,1]$，$\\mathbf{v}_{\\text{rel}}=[0.2,0.0]$（单位：米/秒），$\\Delta t=0.001$ 秒，$k_t=10^6$ 帕斯卡/米，$\\mu=0.3$，$p_n=1000$ 帕斯卡，$\\mathbf{t}_t^{n}=[100,0]$ 帕斯卡。\n\n- 案例 4（滑动，非单位法线的斜投影）：\n  - $\\mathbf{n}=[2,2]$，$\\mathbf{v}_{\\text{rel}}=[0.05,0.0]$（单位：米/秒），$\\Delta t=0.02$ 秒，$k_t=5\\times 10^5$ 帕斯卡/米，$\\mu=0.25$，$p_n=400$ 帕斯卡，$\\mathbf{t}_t^{n}=[10,20]$ 帕斯卡。\n\n- 案例 5（零相对速度，预先存在的牵引力低于边界，保持粘滞）：\n  - $\\mathbf{n}=[0,1]$，$\\mathbf{v}_{\\text{rel}}=[0.0,0.0]$（单位：米/秒），$\\Delta t=0.05$ 秒，$k_t=2\\times 10^6$ 帕斯卡/米，$\\mu=0.6$，$p_n=800$ 帕斯卡，$\\mathbf{t}_t^{n}=[100,200]$ 帕斯卡。\n\n最终输出格式：\n- 对于每个案例，输出一个包含五个条目的列表：$\\Delta\\boldsymbol{\\delta}_t$ 的两个分量（单位：米），$\\mathbf{t}_t^{n+1}$ 的两个分量（单位：帕斯卡），以及一个布尔值，指示是否调用了塑性校正器（滑动）。\n- 将所有浮点输出四舍五入到六位小数。\n- 将所有五个案例的结果聚合到一行中，作为一个用方括号括起来的逗号分隔列表，其中每个案例的结果本身就是一个用方括号括起来的列表。例如：$[\\,[\\dots],[\\dots],\\dots\\,]$。",
            "solution": "该问题要求实现摩擦接触界面上切向牵引力向量的增量更新，该更新基于弹塑性预测-校正方案，并采用径向返回映射处理库仑摩擦定律。其理论框架将从运动学和连续介质力学的基本原理推导得出。\n\n### 1. 相对运动的运动学与切向投影\n\n分析始于一个二维欧几里得空间 $\\mathbb{R}^2$。接触界面由一个主段定义，其方向由外法线向量 $\\mathbf{n} \\in \\mathbb{R}^2$ 给出。此向量不一定是单位长度。为了进行投影，我们首先定义单位法线向量 $\\widehat{\\mathbf{n}}$：\n$$\n\\widehat{\\mathbf{n}} = \\frac{\\mathbf{n}}{\\|\\mathbf{n}\\|}\n$$\n其中 $\\|\\cdot\\|$ 表示欧几里得范数。向量 $\\widehat{\\mathbf{n}}$ 定义了接触点的法线方向。切向方向是与 $\\widehat{\\mathbf{n}}$ 正交的子空间。\n\n从节点和主段之间的相对速度为 $\\mathbf{v}_{\\text{rel}} \\in \\mathbb{R}^2$。在持续时间为 $\\Delta t  0$ 的时间步长内，假设速度在该步长内恒定，相对位移增量计算如下：\n$$\n\\Delta \\mathbf{u}_{\\text{rel}} = \\mathbf{v}_{\\text{rel}} \\Delta t\n$$\n这个相对位移增量可以分解为法向分量 $\\Delta u_n$ 和切向分量，即切向滑移增量 $\\Delta\\boldsymbol{\\delta}_t$。该分解通过正交投影算子实现。\n\n到法线方向（由 $\\widehat{\\mathbf{n}}$ 张成的子空间）的正交投影算子是张量 $\\mathbf{P}_n = \\widehat{\\mathbf{n}} \\otimes \\widehat{\\mathbf{n}}^T$。将其应用于向量 $\\mathbf{v}$ 可得到其法向分量：\n$$\n\\mathbf{v}_n = \\mathbf{P}_n \\mathbf{v} = (\\widehat{\\mathbf{n}} \\cdot \\mathbf{v}) \\widehat{\\mathbf{n}}\n$$\n到切向子空间的正交投影算子由 $\\mathbf{P}_t = \\mathbf{I} - \\mathbf{P}_n$ 给出，其中 $\\mathbf{I}$ 是二阶单位张量。将其应用于向量 $\\mathbf{v}$ 可得到其切向分量：\n$$\n\\mathbf{v}_t = \\mathbf{P}_t \\mathbf{v} = \\mathbf{v} - \\mathbf{v}_n = \\mathbf{v} - (\\widehat{\\mathbf{n}} \\cdot \\mathbf{v}) \\widehat{\\mathbf{n}}\n$$\n将此切向投影算子应用于相对位移增量 $\\Delta \\mathbf{u}_{\\text{rel}}$，得到切向滑移增量 $\\Delta\\boldsymbol{\\delta}_t$：\n$$\n\\Delta\\boldsymbol{\\delta}_t = \\mathbf{P}_t(\\Delta \\mathbf{u}_{\\text{rel}}) = \\Delta \\mathbf{u}_{\\text{rel}} - (\\widehat{\\mathbf{n}} \\cdot \\Delta \\mathbf{u}_{\\text{rel}}) \\widehat{\\mathbf{n}}\n$$\n这个向量 $\\Delta\\boldsymbol{\\delta}_t$ 代表在时间步长 $\\Delta t$ 内，沿着接触表面切线方向发生的那部分相对运动。\n\n### 2. 本构模型：弹塑性摩擦接触\n\n切向牵引力 $\\mathbf{t}_t$ 的演化采用类似于率无关塑性的框架进行建模。总切向滑移被加法分解为一个弹性（可恢复）部分和一个塑性（摩擦滑动）部分。切向牵引力与滑移的弹性部分之间的关系被假定为线性的，由切向罚刚度 $k_t$ 控制。\n\n从时间步 $n$ 到 $n+1$ 的切向牵引力更新过程遵循一个预测-校正方案。\n\n#### 2.1. 弹性预测\n\n首先，我们假设整个切向滑移增量 $\\Delta\\boldsymbol{\\delta}_t$ 是纯弹性的。这产生了一个在步骤 $n+1$ 时的切向牵引力的“试探”状态。试探牵引力 $\\mathbf{t}_t^{\\text{trial}}$ 是通过将一个弹性增量加到上一步的牵引力 $\\mathbf{t}_t^n$ 上计算得出的：\n$$\n\\mathbf{t}_t^{\\text{trial}} = \\mathbf{t}_t^n + k_t \\Delta\\boldsymbol{\\delta}_t\n$$\n这里，$k_t$ 的单位是应力每单位长度（例如，Pa/m），代表接触界面的切向刚度。\n\n#### 2.2. 摩擦准则和校正步骤\n\n必须根据库仑摩擦定律检查试探牵引力的容许性。该定律规定，切向牵引力的大小不能超过一个临界值，该临界值与法向接触压力 $p_n$ 和摩擦系数 $\\mu$ 成正比。这在切向牵引力空间中定义了一个“粘滞”区域或弹性域。该条件可以用一个屈服函数 $\\Phi$ 来表示：\n$$\n\\Phi(\\mathbf{t}_t, p_n) = \\|\\mathbf{t}_t\\| - \\mu p_n \\le 0\n$$\n由于法向压力 $p_n$ 在压缩时定义为正，摩擦极限为 $t_{\\text{crit}} = \\mu p_n$。容许状态是满足 $\\|\\mathbf{t}_t\\| \\le t_{\\text{crit}}$ 的状态。\n\n我们在试探状态下评估屈服函数：\n$$\n\\Phi^{\\text{trial}} = \\|\\mathbf{t}_t^{\\text{trial}}\\| - \\mu p_n\n$$\n\n出现两种情况：\n\n**情况A：粘滞条件 ($\\Phi^{\\text{trial}} \\le 0$)**\n如果试探牵引力的大小在摩擦极限内，则试探状态是容许的。对于此增量，纯弹性行为的假设是正确的。没有发生摩擦滑动（塑性滑移）。更新后的切向牵引力就是试探牵引力：\n$$\n\\mathbf{t}_t^{n+1} = \\mathbf{t}_t^{\\text{trial}}\n$$\n在这种情况下，不调用塑性校正器。\n\n**情况B：滑动条件 ($\\Phi^{\\text{trial}}  0$)**\n如果试探牵引力的大小超过摩擦极限，则试探状态是不可容许的。这表明必须发生摩擦滑动。纯弹性行为的假设是不正确的。牵引力向量必须被“返回”到容许区域的边界，即半径为 $t_{\\text{crit}}$ 的圆。此校正的算法是最近点投影，称为径向返回映射。最终牵引力向量的方向假定与试探牵引力向量的方向相同。其大小被缩减到极限 $t_{\\text{crit}}$。\n更新后的切向牵引力为：\n$$\n\\mathbf{t}_t^{n+1} = t_{\\text{crit}} \\frac{\\mathbf{t}_t^{\\text{trial}}}{\\|\\mathbf{t}_t^{\\text{trial}}\\|} = (\\mu p_n) \\frac{\\mathbf{t}_t^{\\text{trial}}}{\\|\\mathbf{t}_t^{\\text{trial}}\\|}\n$$\n在这种情况下，调用塑性校正器。\n\n对于滑动情况，需要一个数值上的考虑。如果 $\\|\\mathbf{t}_t^{\\text{trial}}\\|$ 非常接近于零，其归一化在数值上是不稳定的。然而，如果 $\\|\\mathbf{t}_t^{\\text{trial}}\\|$ 小于一个小的容差（例如，$10^{-12}$），它保证处于粘滞区域（因为 $\\mu p_n \\ge 0$），所以对滑动的显式检查足以处理这种情况。只有当 $\\|\\mathbf{t}_t^{\\text{trial}}\\|  \\mu p_n$ 时才会出现除以 $\\|\\mathbf{t}_t^{\\text{trial}}\\|$ 的情况，对于任何有意义的摩擦问题，这个值都是非零的。\n\n### 3. 算法总结\n\n对于每个具有输入 $\\{\\mathbf{n}, \\mathbf{v}_{\\text{rel}}, \\Delta t, k_t, \\mu, p_n, \\mathbf{t}_t^n\\}$ 的测试用例，计算 $\\Delta\\boldsymbol{\\delta}_t$ 和 $\\mathbf{t}_t^{n+1}$ 的算法如下：\n\n1.  **归一化法线向量**：\n    计算单位法线 $\\widehat{\\mathbf{n}} = \\mathbf{n} / \\|\\mathbf{n}\\|$。\n\n2.  **计算切向滑移增量**：\n    a. 计算相对位移增量：$\\Delta \\mathbf{u}_{\\text{rel}} = \\mathbf{v}_{\\text{rel}} \\Delta t$。\n    b. 将 $\\Delta \\mathbf{u}_{\\text{rel}}$ 投影到切平面上以获得滑移增量：$\\Delta\\boldsymbol{\\delta}_t = \\Delta \\mathbf{u}_{\\text{rel}} - (\\widehat{\\mathbf{n}} \\cdot \\Delta \\mathbf{u}_{\\text{rel}}) \\widehat{\\mathbf{n}}$。\n\n3.  **弹性预测**：\n    计算试探切向牵引力：$\\mathbf{t}_t^{\\text{trial}} = \\mathbf{t}_t^n + k_t \\Delta\\boldsymbol{\\delta}_t$。\n\n4.  **摩擦校正（径向返回）**：\n    a. 计算试探切向牵引力的大小 $\\|\\mathbf{t}_t^{\\text{trial}}\\|$。\n    b. 计算摩擦极限：$t_{\\text{crit}} = \\mu p_n$。\n    c. 设置一个布尔标志 `corrector_invoked = False`。\n    d. 如果 $\\|\\mathbf{t}_t^{\\text{trial}}\\|  t_{\\text{crit}}$：\n        i.  状态为滑动。设置 `corrector_invoked = True`。\n        ii. 通过径向返回更新牵引力：$\\mathbf{t}_t^{n+1} = t_{\\text{crit}} \\frac{\\mathbf{t}_t^{\\text{trial}}}{\\|\\mathbf{t}_t^{\\text{trial}}\\|}$。\n    e. 否则（如果 $\\|\\mathbf{t}_t^{\\text{trial}}\\| \\le t_{\\text{crit}}$）：\n        i.  状态为粘滞。\n        ii. 更新后的牵引力是试探牵引力：$\\mathbf{t}_t^{n+1} = \\mathbf{t}_t^{\\text{trial}}$。\n\n5.  **输出**：\n    存储计算出的 $\\Delta\\boldsymbol{\\delta}_t$ 的两个分量、$\\mathbf{t}_t^{n+1}$ 的两个分量以及布尔值 `corrector_invoked`。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the tangential slip increment and updated tangential traction\n    for a node-to-segment frictional contact problem using a radial return algorithm.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: Sliding, axis-aligned normal\n        {'n': [0, 1], 'v_rel': [0.1, -0.2], 'dt': 0.01, 'k_t': 1e6, 'mu': 0.3, 'p_n': 1000, 't_t_n': [0, 0]},\n        \n        # Case 2: Sticking, small tangential increment\n        {'n': [0, 1], 'v_rel': [0.001, 0.0], 'dt': 0.001, 'k_t': 1e6, 'mu': 0.4, 'p_n': 500, 't_t_n': [0, 0]},\n        \n        # Case 3: On the friction bound, no return needed\n        {'n': [0, 1], 'v_rel': [0.2, 0.0], 'dt': 0.001, 'k_t': 1e6, 'mu': 0.3, 'p_n': 1000, 't_t_n': [100, 0]},\n        \n        # Case 4: Sliding, oblique projection with non-unit normal\n        {'n': [2, 2], 'v_rel': [0.05, 0.0], 'dt': 0.02, 'k_t': 5e5, 'mu': 0.25, 'p_n': 400, 't_t_n': [10, 20]},\n        \n        # Case 5: Zero relative velocity, stick with pre-existing traction\n        {'n': [0, 1], 'v_rel': [0.0, 0.0], 'dt': 0.05, 'k_t': 2e6, 'mu': 0.6, 'p_n': 800, 't_t_n': [100, 200]},\n    ]\n\n    all_results_strings = []\n\n    for case in test_cases:\n        # Step 0: Extract givens and convert to numpy arrays\n        n = np.array(case['n'], dtype=float)\n        v_rel = np.array(case['v_rel'], dtype=float)\n        dt = case['dt']\n        k_t = case['k_t']\n        mu = case['mu']\n        p_n = case['p_n']\n        t_t_n = np.array(case['t_t_n'], dtype=float)\n\n        # Step 1: Normalize the normal vector\n        norm_n = np.linalg.norm(n)\n        if norm_n == 0:\n            # Handle the unlikely case of a zero normal vector\n            n_hat = np.zeros_like(n)\n        else:\n            n_hat = n / norm_n\n\n        # Step 2: Compute tangential slip increment\n        delta_u_rel = v_rel * dt\n        # Project onto normal: (n_hat . delta_u_rel) * n_hat\n        normal_component = np.dot(n_hat, delta_u_rel) * n_hat\n        # Tangential slip increment is the total minus the normal component\n        delta_t = delta_u_rel - normal_component\n\n        # Step 3: Elastic Predictor\n        # Compute trial tangential traction\n        t_t_trial = t_t_n + k_t * delta_t\n\n        # Step 4: Frictional Corrector (Radial Return)\n        norm_t_t_trial = np.linalg.norm(t_t_trial)\n        t_crit = mu * p_n\n        \n        corrector_invoked = False\n        \n        # Handle the tolerance for near-zero trial traction magnitude implicitly.\n        # If norm_t_t_trial is very small, it will be less than t_crit (as t_crit >= 0).\n        if norm_t_t_trial > t_crit:\n            # Slip condition: return to friction cone\n            corrector_invoked = True\n            # The condition norm_t_t_trial > t_crit ensures norm_t_t_trial is not zero,\n            # so the division is safe.\n            t_t_n_plus_1 = t_crit * (t_t_trial / norm_t_t_trial)\n        else:\n            # Stick condition: elastic update is admissible\n            t_t_n_plus_1 = t_t_trial\n\n        # Step 5: Format the output for this case\n        case_result_values = [\n            delta_t[0],\n            delta_t[1],\n            t_t_n_plus_1[0],\n            t_t_n_plus_1[1],\n            corrector_invoked\n        ]\n        \n        formatted_values = []\n        for val in case_result_values:\n            if isinstance(val, bool):\n                formatted_values.append(str(val))\n            else:\n                formatted_values.append(f\"{val:.6f}\")\n        \n        all_results_strings.append(f\"[{','.join(formatted_values)}]\")\n\n    # Final print statement in the exact required format\n    final_output = f\"[{','.join(all_results_strings)}]\"\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}