{
    "hands_on_practices": [
        {
            "introduction": "有限元近似的精度与底层多项式插值的质量密切相关。本练习将通过动手实践，展示龙格现象 (Runge's phenomenon)——一个在等距节点上进行高次插值时可能导致巨大误差的经典问题。通过将其与切比雪夫-高斯-洛巴托 (Chebyshev-Gauss-Lobatto) 节点上的插值进行比较，您将对为何节点布局是开发稳健数值方法的关键环节有一个实践性的理解。",
            "id": "3589599",
            "problem": "构建一个完整、可运行的程序，针对标量函数 $f(x)=\\dfrac{1}{1+25x^2}$ 在闭区间 $[-1,1]$ 上的情况，使用两种节点分布构建次数为 $n$ 的拉格朗日插值（有限元形函数），并计算最大插值误差。使用以下两种节点分布：(i) 包括端点的等距节点；(ii) 包括端点的切比雪夫-高斯-洛巴托节点。插值函数必须是次数最多为 $n$ 的唯一多项式，且在所选节点处与 $f$ 的值相匹配。必须通过在一个精细的评估网格上计算最大绝对插值误差来进行比较。\n\n需要使用的基本依据和定义：\n- 拉格朗日插值 $\\mathcal{I}_n[f](x)$ 定义为次数最多为 $n$ 的唯一多项式，它在 $[-1,1]$ 上的 $n+1$ 个插值节点 $\\{x_i\\}_{i=0}^n$ 处满足 $\\mathcal{I}_n[f](x_i)=f(x_i)$。\n- 拉格朗日形函数 $\\{N_i(x)\\}_{i=0}^n$ 由 $N_i(x_j)=\\delta_{ij}$ 和对所有 $x$ 满足 $\\sum_{i=0}^n N_i(x)=1$ 来定义。\n\n精确的数值任务：\n1. 对于测试套件中的每个次数 $n$，定义两个节点集：\n   - 等距节点：$x_j=-1+\\dfrac{2j}{n}$，其中 $j=0,1,\\dots,n$。\n   - 切比雪夫-高斯-洛巴托节点：$x_j=\\cos\\!\\left(\\dfrac{\\pi j}{n}\\right)$，其中 $j=0,1,\\dots,n$，角度单位为弧度。节点的顺序不影响正确性。\n2. 使用拉格朗日形函数构建插值。您必须实现在 $[-1,1]$ 上任意点处对插值进行数值稳定的计算；重心拉格朗日公式是拉格朗日形函数可接受的一种算法表达。\n3. 通过在 $[-1,1]$ 区间上一个包含 $M$ 个点（$M=10001$）的均匀网格上进行评估，并取该网格上绝对误差的最大值，来近似计算最大绝对插值误差 $\\max_{x\\in[-1,1]} |f(x)-\\mathcal{I}_n[f](x)|$。\n4. 对每个测试用例，返回包含三个输出的列表：\n   - 等距节点的最大误差，表示为一个保留 $12$ 位小数的浮点数。\n   - 切比雪夫-高斯-洛巴托节点的最大误差，表示为一个保留 $12$ 位小数的浮点数。\n   - 一个布尔值，指示切比雪夫-高斯-洛巴托误差是否在公差 $\\tau=10^{-12}$ 内小于或等于等距误差，即如果 $E_{\\text{GL}}\\le E_{\\text{EQ}}+\\tau$ 则为 $\\text{True}$，否则为 $\\text{False}$。\n\n测试套件：\n- 用例 1：$n=1$。\n- 用例 2：$n=6$。\n- 用例 3：$n=20$。\n\n所有计算都是无量纲的；不涉及物理单位。所有三角函数求值必须使用弧度。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表。输出应该是一个列表的列表，每个测试用例一个，按上述顺序排列。每个内部列表必须具有 $[E_{\\text{EQ}},E_{\\text{GL}},B]$ 的形式，其中 $E_{\\text{EQ}}$ 和 $E_{\\text{GL}}$ 是保留 $12$ 位小数的浮点数，$B$ 是一个布尔值，例如：\n  - $[[0.0,0.0,\\text{True}],[\\dots],[\\dots]]$。",
            "solution": "所提出的问题是数值分析领域，特别是逼近理论中的一个标准练习，与计算固体力学直接相关，因为多项式形函数构成了有限元法的基础。目标是为龙格函数 $f(x) = \\frac{1}{1+25x^2}$ 在区间 $x \\in [-1, 1]$ 上构建拉格朗日插值多项式，并比较两种不同插值节点集的插值误差。这个函数是一个典型的例子，用于说明龙格现象——即对于某些函数，使用等距节点的高次多项式插值无法收敛。\n\n问题的核心是构建一个次数最多为 $n$ 的唯一多项式，记为 $\\mathcal{I}_n[f](x)$，它在 $n+1$ 个指定节点 $\\{x_i\\}_{i=0}^n$ 处与函数 $f(x)$ 匹配，即 $\\mathcalI_n[f](x_i) = f(x_i)$。这些节点的两种分布是：\n1.  **等距节点**：这些节点均匀分布在整个区间上，包括端点。对于一个 $n$ 次多项式，这 $n+1$ 个节点由公式 $x_j^{\\text{EQ}} = -1 + \\frac{2j}{n}$ 给出，其中 $j=0, 1, \\dots, n$。\n2.  **切比雪夫-高斯-洛巴托 (CGL) 节点**：这些节点是 $n$ 次第一类切比雪夫多项式导数的根，外加端点 $-1$ 和 $1$。它们在区间端点附近更密集地聚集。它们由公式 $x_j^{\\text{GL}} = \\cos\\left(\\frac{\\pi j}{n}\\right)$ 给出，其中 $j=0, 1, \\dots, n$。\n\n拉格朗日插值 $\\mathcal{I}_n[f](x)$ 可以用拉格朗日基多项式表示，在有限元背景下通常称为形函数 $\\{N_i(x)\\}_{i=0}^n$。每个基多项式 $N_i(x)$ 都具有 $N_i(x_j) = \\delta_{ij}$ 的性质，其中 $\\delta_{ij}$ 是克罗内克δ。完整的插值是这些形函数的线性组合，由节点处的函数值加权：\n$$ \\mathcal{I}_n[f](x) = \\sum_{i=0}^n f(x_i) N_i(x) $$\n形函数的显式形式是 $N_i(x) = \\prod_{k=0, k \\neq i}^n \\frac{x-x_k}{x_i - x_k}$。虽然这个乘积形式在数学上很优雅，但对于高次 $n$，直接计算它的计算成本高且数值不稳定。\n\n一种数值上更优的计算插值的方法是重心拉格朗日插值公式。第二种，即“真”重心公式，提供了一种稳定而高效的计算方法：\n$$ \\mathcal{I}_n[f](x) = \\frac{\\displaystyle\\sum_{i=0}^n \\frac{w_i}{x-x_i} f(x_i)}{\\displaystyle\\sum_{i=0}^n \\frac{w_i}{x-x_i}} $$\n这里的 $w_i$ 是重心权重，定义为 $w_i = \\left(\\prod_{k=0, k \\neq i}^n (x_i - x_k)\\right)^{-1}$。这些权重仅取决于节点分布，可以预先计算。如果评估点 $x$ 与某个节点 $x_j$ 重合，插值的值已知为 $f(x_j)$，这种情况需要单独处理以避免除以零。Python 库 `SciPy` 提供了 `BarycentricInterpolator` 类，它实现了这种稳定高效的算法。\n\n问题要求计算最大绝对插值误差 $E_n = \\max_{x \\in [-1, 1]} |f(x) - \\mathcal{I}_n[f](x)|$。通过在一个非常精细的、包含 $M=10001$ 个点 $\\{z_k\\}$ 的均匀网格上评估误差，可以得到该最大值的精确近似，该网格跨越区间 $[-1, 1]$。然后，最大误差取为 $E_n \\approx \\max_{k} |f(z_k) - \\mathcal{I}_n[f](z_k)|$。对于测试套件中指定的每个次数 $n$（$n=1, 6, 20$），这个过程需要对等距节点集（得到误差 $E_{\\text{EQ}}$）和 CGL 节点集（得到误差 $E_{\\text{GL}}$）重复进行。\n\n最后，通过一个布尔测试来形式化两种方法的比较：如果 CGL 方法的误差 $E_{\\text{GL}}$ 在一个小的公差 $\\tau = 10^{-12}$ 内小于或等于等距误差 $E_{\\text{EQ}}$，则认为 CGL 方法更优。程序将为每个 $n$ 值计算三元组 $[E_{\\text{EQ}}, E_{\\text{GL}}, (E_{\\text{GL}} \\le E_{\\text{EQ}} + \\tau)]$。这个练习将证明，虽然对于 $n=1$ 两种节点集是相同的，但对于更高的次数，CGL 节点能产生远为优越的近似效果，有效减轻了龙格现象，该现象在使用等距节点时会导致大幅振荡和误差发散。",
            "answer": "```python\nimport numpy as np\nfrom scipy.interpolate import BarycentricInterpolator\n\ndef solve():\n    \"\"\"\n    Constructs Lagrange interpolants for the Runge function using two different\n    node distributions (equispaced and Chebyshev-Gauss-Lobatto) and computes the\n    maximum interpolation error for each.\n    \"\"\"\n\n    test_cases = [1, 6, 20]  # Degrees n\n    M = 10001  # Number of evaluation points for error calculation\n    tau = 1e-12  # Tolerance for error comparison\n\n    # Define the Runge function to be interpolated\n    def f(x):\n        return 1.0 / (1.0 + 25.0 * x**2)\n\n    # Create a fine grid of points in [-1, 1] to evaluate the error\n    eval_points = np.linspace(-1.0, 1.0, M)\n    f_eval = f(eval_points)\n    \n    results = []\n\n    for n in test_cases:\n        # Step 1: Define the two node sets and function values at nodes\n        \n        # (i) Equispaced nodes\n        nodes_eq = np.linspace(-1.0, 1.0, n + 1)\n        f_nodes_eq = f(nodes_eq)\n        \n        # (ii) Chebyshev–Gauss–Lobatto nodes\n        j = np.arange(n + 1)\n        nodes_cgl = np.cos(np.pi * j / n)\n        f_nodes_cgl = f(nodes_cgl)\n        \n        # Step 2: Construct the interpolants using BarycentricInterpolator\n        \n        # Interpolant for equispaced nodes\n        poly_eq = BarycentricInterpolator(nodes_eq, f_nodes_eq)\n        f_interp_eq = poly_eq(eval_points)\n        \n        # Interpolant for Chebyshev-Gauss-Lobatto nodes\n        poly_cgl = BarycentricInterpolator(nodes_cgl, f_nodes_cgl)\n        f_interp_cgl = poly_cgl(eval_points)\n        \n        # Step 3: Compute the maximum absolute interpolation error\n        \n        err_eq = np.max(np.abs(f_eval - f_interp_eq))\n        err_cgl = np.max(np.abs(f_eval - f_interp_cgl))\n        \n        # Step 4: Compare errors and prepare the result triplet\n        \n        is_le = err_cgl = err_eq + tau\n        \n        # Append the rounded floats and boolean to the results list\n        # The problem asks to round to 12 decimal places.\n        result_triplet = [\n            round(err_eq, 12),\n            round(err_cgl, 12),\n            is_le\n        ]\n        results.append(result_triplet)\n\n    # Format the final output string as a list of lists\n    formatted_results = []\n    for res in results:\n        e_eq, e_gl, b_val = res\n        # Format: [E_EQ,E_GL,B] with no spaces and True/False as literals\n        formatted_results.append(f\"[{e_eq},{e_gl},{b_val}]\")\n    \n    final_output_string = f\"[{','.join(formatted_results)}]\"\n    \n    print(final_output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "等参元概念是现代有限元分析的基石，它允许使用简单的参考单元来模拟复杂的几何形状。本练习将指导您实现一个双线性四边形 ($Q_1$) 单元，以数值方式验证其两个最关键的特性：单位分解性 (partition of unity) 与线性场的精确再现能力。完成此练习将增强您对单元公式基本正确性的信心。",
            "id": "3589573",
            "problem": "考虑一个在计算固体力学中使用的单个等参一阶四边形 ($Q_1$) 有限元。参考（自然）坐标为 $(\\xi,\\eta)\\in[-1,1]\\times[-1,1]$。物理坐标 $(x,y)$ 是通过等参双线性映射得到的，该映射使用的双线性插值形函数与单元上场插值所用的形函数相同。四个节点按逆时针顺序排列如下：节点 $1$ 对应 $(\\xi,\\eta)=(-1,-1)$，节点 $2$ 对应 $(\\xi,\\eta)=(+1,-1)$，节点 $3$ 对应 $(\\xi,\\eta)=(+1,+1)$，节点 $4$ 对应 $(\\xi,\\eta)=(-1,+1)$。双线性形函数是唯一的在自身节点处为 $1$、在参考正方形上其他节点处为 $0$ 的多项式，它们既用于映射几何形状，也用于插值场。\n\n从等参双线性插值使用相同的双线性形函数进行几何和场近似这一基本出发点，对单个单元上的标量场 $u(x,y)$ 执行以下验证任务：\n- 单位分解性验证：在所有内部采样点 $(\\xi,\\eta)$ 处，形函数应满足 $\\sum_{i=1}^{4}N_i(\\xi,\\eta)=1$。\n- 精确重构验证：对于线性物理空间场 $u(x,y)=1+x-y$，由节点值 $u_i=u(x_i,y_i)$ 构造的等参插值函数在所有内部采样点 $(\\xi,\\eta)$ 处的计算结果必须等于 $u(x(\\xi,\\eta),y(\\xi,\\eta))$，其中 $(x(\\xi,\\eta),y(\\xi,\\eta))$ 是通过单元的等参映射获得的。\n\n您的程序必须从第一性原理出发，实现双线性 ($Q_1$) 形函数、几何的等参映射以及场插值。然后，对于下面描述的每个测试单元，程序必须在一组指定的内部采样点上，计算单位分解的最大绝对偏差和线性场重构的最大绝对误差。\n\n使用以下由三个单元组成的测试套件，每个单元由其四个节点的物理坐标 $(x_i,y_i)$ 定义（$i\\in\\{1,2,3,4\\}$），顺序如上文所述的逆时针方向：\n- 单元 A（仿射平行四边形）：$(x_1,y_1)=(0,0)$, $(x_2,y_2)=(2,0)$, $(x_3,y_3)=(2,1)$, $(x_4,y_4)=(0,1)$。\n- 单元 B（中度扭曲的凸四边形）：$(x_1,y_1)=(0,0)$, $(x_2,y_2)=(2,0.2)$, $(x_3,y_3)=(2.2,1.1)$, $(x_4,y_4)=(-0.2,0.9)$。\n- 单元 C（严重倾斜的凸四边形）：$(x_1,y_1)=(0,0)$, $(x_2,y_2)=(1.7,-0.3)$, $(x_3,y_3)=(2.4,0.8)$, $(x_4,y_4)=(-0.4,1.2)$。\n\n在参考正方形中使用以下内部采样点：\n- 中心点：$(\\xi,\\eta)=(0,0)$。\n- 两点高斯求积点组合：令 $g=1/\\sqrt{3}$；使用 $(\\xi,\\eta)=(g,g)$, $(g,-g)$, $(-g,g)$, $(-g,-g)$。\n- 靠近边界的附加内部点：$(\\xi,\\eta)=(0.8,-0.6)$, $(-0.6,0.8)$, $(0.9,0)$, $(0,-0.9)$。\n\n对于每个单元，计算：\n- 在采样点集上的单位分解最大绝对偏差，定义为 $\\max|\\sum_{i=1}^{4}N_i(\\xi,\\eta)-1|$。\n- 在采样点集上的线性场重构最大绝对误差，定义为 $\\max|u^h(\\xi,\\eta)-u(x(\\xi,\\eta),y(\\xi,\\eta))|$，其中 $u^h(\\xi,\\eta)=\\sum_{i=1}^{4}N_i(\\xi,\\eta)\\,u_i$ 且 $u_i=1+x_i-y_i$。\n\n将所有计算出的误差表示为无量纲的浮点数。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $[\\mathrm{E\\_pu}^{(A)},\\mathrm{E\\_lin}^{(A)},\\mathrm{E\\_pu}^{(B)},\\mathrm{E\\_lin}^{(B)},\\mathrm{E\\_pu}^{(C)},\\mathrm{E\\_lin}^{(C)}]$，其中 $\\mathrm{E\\_pu}^{(\\cdot)}$ 和 $\\mathrm{E\\_lin}^{(\\cdot)}$ 分别表示指定单元的单位分解最大绝对偏差和线性场重构最大绝对误差。不涉及单位，也不使用角度。",
            "solution": "该问题要求验证一阶等参四边形 ($Q_1$) 有限元的两个基本性质：单位分解性和线性多项式的精确重构。这是计算力学中验证单元公式实现的标准化流程。该验证将在参考域内的一组指定采样点上，对三种不同的单元几何形状进行数值计算。\n\n**1. $Q_1$ 单元的双线性形函数**\n\n$Q_1$ 单元定义在自然坐标系 $(\\xi,\\eta)$ 中的一个参考域（一个正方形）上，其中 $\\xi \\in [-1, 1]$ 且 $\\eta \\in [-1, 1]$。四个节点位于该正方形的角点，逆时针编号：\n- 节点 $1$: $(\\xi_1, \\eta_1) = (-1, -1)$\n- 节点 $2$: $(\\xi_2, \\eta_2) = (+1, -1)$\n- 节点 $3$: $(\\xi_3, \\eta_3) = (+1, +1)$\n- 节点 $4$: $(\\xi_4, \\eta_4) = (-1, +1)$\n\n与节点 $i$ 相关联的形函数 $N_i(\\xi, \\eta)$ 是一个 $c_0 + c_1\\xi + c_2\\eta + c_3\\xi\\eta$ 形式的双线性多项式。它的定义性质是在其自身节点处为 $1$，在其他三个节点处为 $0$，即 $N_i(\\xi_j, \\eta_j) = \\delta_{ij}$，其中 $\\delta_{ij}$ 是克罗内克 δ。这个条件唯一地确定了四个形函数。它们可以通过观察法，利用线性函数的乘积来构造。例如，当 $\\xi=+1$ 或 $\\eta=+1$ 时，$N_1(\\xi, \\eta)$ 必须为零，这表明它与 $(1-\\xi)(1-\\eta)$ 成正比。通过强制 $N_1(-1, -1) = 1$ 来找到比例常数。这个过程得出了以下标准双线性形函数集：\n\n$$N_1(\\xi, \\eta) = \\frac{1}{4}(1-\\xi)(1-\\eta)$$\n$$N_2(\\xi, \\eta) = \\frac{1}{4}(1+\\xi)(1-\\eta)$$\n$$N_3(\\xi, \\eta) = \\frac{1}{4}(1+\\xi)(1+\\eta)$$\n$$N_4(\\xi, \\eta) = \\frac{1}{4}(1-\\xi)(1+\\eta)$$\n\n这些函数构成了单元内插值的基础。\n\n**2. 等参映射和场插值**\n\n等参概念要求使用相同的形函数来插值单元的几何形状（物理坐标 $(x,y)$）以及近似单元上的任何场变量（例如标量场 $u$）。\n\n从参考坐标 $(\\xi, \\eta)$ 到物理坐标 $(x,y)$ 的映射由下式给出：\n$$x(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) x_i$$\n$$y(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) y_i$$\n其中 $(x_i, y_i)$ 是单元四个节点的已知物理坐标。\n\n类似地，标量场 $u$ 在单元内通过插值函数 $u^h$ 来近似：\n$$u^h(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) u_i$$\n其中 $u_i$ 是场在节点处的值。\n\n**3. 验证性质**\n\n实现将根据这些形函数的两个基石性质进行验证。\n\n**3.1. 单位分解性**\n\n在单元内的每一点，形函数之和必须为 1：\n$$\\sum_{i=1}^{4} N_i(\\xi, \\eta) = 1 \\quad \\forall (\\xi, \\eta) \\in [-1, 1] \\times [-1, 1]$$\n这个性质对于确保精确表示刚体运动（一个恒定的位移场）至关重要，这是收敛性的一个要求。我们可以代数地验证这个性质：\n$$ \\sum_{i=1}^{4} N_i = \\frac{1}{4} \\left[ (1-\\xi)(1-\\eta) + (1+\\xi)(1-\\eta) + (1+\\xi)(1+\\eta) + (1-\\xi)(1+\\eta) \\right] $$\n分解项：\n$$ \\sum_{i=1}^{4} N_i = \\frac{1}{4} \\left[ (1-\\eta)(1-\\xi+1+\\xi) + (1+\\eta)(1+\\xi+1-\\xi) \\right] $$\n$$ \\sum_{i=1}^{4} N_i = \\frac{1}{4} \\left[ (1-\\eta)(2) + (1+\\eta)(2) \\right] = \\frac{1}{2} (1-\\eta+1+\\eta) = \\frac{1}{2}(2) = 1 $$\n在数值上，我们将计算单位分解偏差，定义为在采样点集上与 $1$ 的最大绝对差：\n$$ \\mathrm{E_{\\mathrm{pu}}} = \\max_{(\\xi, \\eta) \\in S} \\left| \\left( \\sum_{i=1}^{4} N_i(\\xi, \\eta) \\right) - 1 \\right| $$\n其中 $S$ 是给定的采样点集。由于有限精度算术，这个误差预计在机器精度量级，而不是精确为零。\n\n**3.2. 线性场重构**\n\n有限元公式必须能够精确表示空间坐标的线性函数场，即 $u(x,y) = a + bx + cy$。这是该方法通过分片检验并达到其理论收敛率的必要条件。问题指定了场 $u(x,y) = 1 + x - y$。\n\n该场的节点值为 $u_i = u(x_i, y_i) = 1 + x_i - y_i$。插值场为：\n$$ u^h(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) u_i = \\sum_{i=1}^{4} N_i(\\xi, \\eta) (1 + x_i - y_i) $$\n通过分配求和：\n$$ u^h(\\xi, \\eta) = \\left( \\sum_{i=1}^{4} N_i(\\xi, \\eta) \\right) \\cdot 1 + \\sum_{i=1}^{4} N_i(\\xi, \\eta) x_i - \\sum_{i=1}^{4} N_i(\\xi, \\eta) y_i $$\n识别出单位分解性和等参坐标映射：\n$$ u^h(\\xi, \\eta) = 1 + x(\\xi, \\eta) - y(\\xi, \\eta) $$\n这表明在点 $(\\xi, \\eta)$ 处的插值场 $u^h$ 与在相应物理点 $(x(\\xi, \\eta), y(\\xi, \\eta))$ 处计算的精确场 $u$ 是相同的。\n\n在数值上，我们将计算线性场重构误差，定义为在采样点集上插值场与精确场之间的最大绝对差：\n$$ \\mathrm{E_{\\mathrm{lin}}} = \\max_{(\\xi, \\eta) \\in S} \\left| u^h(\\xi, \\eta) - u(x(\\xi, \\eta), y(\\xi, \\eta)) \\right| $$\n与单位分解偏差类似，这个误差预计不为零但非常小，反映了浮点精度的限制。\n\n**4. 算法实现**\n\n验证过程实现如下：\n1. 在参考域中定义 $9$ 个采样点 $(\\xi, \\eta)$ 的集合。\n2. 对于由其节点坐标 $(x_i, y_i)$ 定义的三个测试单元（A、B、C）中的每一个：\n    a. 将最大单位分解偏差 $\\mathrm{E_{\\mathrm{pu}}}$ 和最大线性重构误差 $\\mathrm{E_{\\mathrm{lin}}}$ 初始化为 $0$。\n    b. 计算线性测试场的节点值 $u_i = 1+x_i-y_i$。\n    c. 遍历每个采样点 $(\\xi_s, \\eta_s)$：\n        i. 计算四个形函数值 $N_i(\\xi_s, \\eta_s)$。\n        ii. 计算单位分解和 $\\Sigma_N = \\sum_{i=1}^4 N_i$。更新 $\\mathrm{E_{\\mathrm{pu}}} = \\max(\\mathrm{E_{\\mathrm{pu}}}, |\\Sigma_N - 1|)$。\n        iii. 使用等参映射计算与 $(\\xi_s, \\eta_s)$ 对应的物理坐标 $(x_s, y_s)$：$x_s = \\sum N_i x_i$， $y_s = \\sum N_i y_i$。\n        iv. 计算该点的精确场值：$u_{exact} = 1 + x_s - y_s$。\n        v. 计算插值场值：$u_h = \\sum N_i u_i$。\n        vi. 计算重构误差 $|u_h - u_{exact}|$。更新 $\\mathrm{E_{\\mathrm{lin}}} = \\max(\\mathrm{E_{\\mathrm{lin}}}, |u_h - u_{exact}|)$。\n3. 收集六个计算出的最大误差值 $(\\mathrm{E_{\\mathrm{pu}}}^{(A)}, \\mathrm{E_{\\mathrm{lin}}}^{(A)}, \\dots)$ 以供最终输出。\n\n此过程系统地测试了所实现的形函数和插值方案是否符合其核心理论性质。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the verification of partition of unity and linear field reproduction\n    for a Q1 isoparametric element.\n    \"\"\"\n\n    # Define the three test elements by their nodal coordinates (x, y)\n    # in the specified counterclockwise order:\n    # node 1: (xi,eta)=(-1,-1), node 2: (1,-1), node 3: (1,1), node 4: (-1,1).\n    test_cases = [\n        # Element A: Affine parallelogram (Rectangle)\n        np.array([[0.0, 0.0], [2.0, 0.0], [2.0, 1.0], [0.0, 1.0]]),\n        # Element B: Moderately distorted convex quadrilateral\n        np.array([[0.0, 0.0], [2.0, 0.2], [2.2, 1.1], [-0.2, 0.9]]),\n        # Element C: Strongly skewed convex quadrilateral\n        np.array([[0.0, 0.0], [1.7, -0.3], [2.4, 0.8], [-0.4, 1.2]]),\n    ]\n\n    # Define the interior sampling points in the reference square [-1,1]x[-1,1]\n    g = 1.0 / np.sqrt(3.0)\n    sampling_points = [\n        (0.0, 0.0),                               # Center\n        (g, g), (g, -g), (-g, g), (-g, -g),      # 2x2 Gauss points\n        (0.8, -0.6), (-0.6, 0.8), (0.9, 0.0), (0.0, -0.9) # Additional points\n    ]\n\n    def get_shape_functions(xi, eta):\n        \"\"\"\n        Computes the four bilinear shape functions for a Q1 element at a point (xi, eta).\n        Returns a numpy array of shape (4,).\n        \"\"\"\n        N1 = 0.25 * (1.0 - xi) * (1.0 - eta)\n        N2 = 0.25 * (1.0 + xi) * (1.0 - eta)\n        N3 = 0.25 * (1.0 + xi) * (1.0 + eta)\n        N4 = 0.25 * (1.0 - xi) * (1.0 + eta)\n        return np.array([N1, N2, N3, N4])\n\n    results = []\n    \n    # Process each element\n    for nodes in test_cases:\n        max_pu_defect = 0.0\n        max_lin_error = 0.0\n\n        # Nodal coordinates (x_i, y_i)\n        x_nodes = nodes[:, 0]\n        y_nodes = nodes[:, 1]\n\n        # Nodal values for the linear field u(x,y) = 1 + x - y\n        u_nodes = 1.0 + x_nodes - y_nodes\n\n        # Iterate over all sampling points\n        for xi, eta in sampling_points:\n            # 1. Compute shape functions at the sampling point\n            N = get_shape_functions(xi, eta)\n\n            # 2. Partition of Unity (PU) verification\n            pu_sum = np.sum(N)\n            pu_defect = np.abs(pu_sum - 1.0)\n            if pu_defect  max_pu_defect:\n                max_pu_defect = pu_defect\n            \n            # 3. Linear Field Reproduction verification\n            \n            # Map sampling point to physical coordinates using isoparametric mapping\n            x_s = N @ x_nodes\n            y_s = N @ y_nodes\n            \n            # Evaluate the exact field at the mapped physical point\n            u_exact = 1.0 + x_s - y_s\n            \n            # Evaluate the interpolated field using nodal values\n            u_h = N @ u_nodes\n            \n            # Calculate the reproduction error\n            lin_error = np.abs(u_h - u_exact)\n            if lin_error  max_lin_error:\n                max_lin_error = lin_error\n\n        results.append(max_pu_defect)\n        results.append(max_lin_error)\n\n    # Format the output string as a comma-separated list in brackets\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "这最后一个练习将理论上的形函数概念与其在结构分析中的最终应用联系起来。您将从第一性原理出发，实现一个完整的计算流程来推导单元刚度矩阵 ($\\mathbf{K}$)，该过程包括计算应变-位移矩阵 ($\\mathbf{B}$) 和进行数值积分。验证所得刚度矩阵的对称性，是对您整个实现过程的一次关键性检验。",
            "id": "3589673",
            "problem": "题目要求你实现一个用于二维小应变线性弹性的等参双线性四边形单元，该单元使用多项式插值和形函数，并验证所得单元刚度的一个结构特性。重点是推导和计算一个扭曲单元在高斯积分点上的应变-位移矩阵（通常称为 $B$ 矩阵），并验证组装后的单元刚度矩阵是对称的。请从基本定义和经过充分检验的事实出发，并据此构建你的算法。\n\n假设为二维小应变运动学。小应变张量定义为 $\\boldsymbol{\\varepsilon} = \\operatorname{sym}\\left(\\nabla \\mathbf{u}\\right)$，其中 $\\mathbf{u}$ 是位移场。本构模型为线性弹性，表示为 $\\boldsymbol{\\sigma} = \\mathbf{D}\\,\\boldsymbol{\\varepsilon}$，其中 $\\boldsymbol{\\sigma}$ 是 Cauchy 应力张量，$\\mathbf{D}$ 是平面应变下的对称本构张量。使用一个等参映射，通过满足节点处 Kronecker-delta 性质的双线性形函数进行多项式插值，将自然坐标 $(\\xi,\\eta)\\in[-1,1]\\times[-1,1]$ 映射到物理坐标 $(x,y)$。节点从左下角开始按逆时针编号，形成一个四节点单元。从自然导数到物理导数的梯度变换应使用映射的雅可比矩阵来完成。\n\n你的任务是：\n- 从自然坐标 $(\\xi,\\eta)$ 下的多项式插值条件推导 $Q_1$ 单元的双线性形函数。\n- 使用等参映射的雅可比矩阵 $\\mathbf{J}(\\xi,\\eta)$ 及其逆矩阵，推导形函数导数从自然坐标到物理坐标的变换。\n- 在每个积分点上，为二维小应变情况构建应变-位移矩阵 $\\mathbf{B}(\\xi,\\eta)$。\n- 在平面应变条件下，使用 $2\\times 2$ 点的高斯积分、厚度 $t$ 以及材料参数杨氏模量 $E$ 和泊松比 $\\nu$，组装单元刚度矩阵 $\\mathbf{K}$。\n- 通过在合理的数值公差范围内检查 $\\mathbf{K} = \\mathbf{K}^\\top$ 是否成立，来验证 $\\mathbf{K}$ 的对称性。\n\n使用以下单元和材料参数的测试套件。所有长度单位为 $\\mathrm{m}$，所有弹性模量单位为 $\\mathrm{Pa}$。厚度 $t$ 的单位为 $\\mathrm{m}$。\n\n测试用例 1：\n- 节点：$\\left[(0,0),(1,0),(1,1),(0,1)\\right]$\n- $E = 70\\times 10^{9}$, $\\nu = 0.33$, $t = 0.1$\n\n测试用例 2：\n- 节点：$\\left[(0,0),(1.2,0),(1.2,1),(0.2,1)\\right]$\n- $E = 210\\times 10^{9}$, $\\nu = 0.3$, $t = 0.05$\n\n测试用例 3：\n- 节点：$\\left[(0,0),(1,0),(0.9,0.8),(-0.1,0.9)\\right]$\n- $E = 120\\times 10^{9}$, $\\nu = 0.25$, $t = 0.2$\n\n测试用例 4：\n- 节点：将角点为 $\\left[(0,0),(2,0),(2,1),(0,1)\\right]$ 的矩形绕原点旋转 $30$ 度，得到坐标 $\\left[(0,0),(1.7320508075688772,1.0),(1.2320508075688772,1.8660254037844386),(-0.5,0.8660254037844386)\\right]$\n- $E = 1\\times 10^{9}$, $\\nu = 0.4$, $t = 0.005$\n\n你的程序必须：\n- 对于每个测试用例，计算所有四个 $2\\times 2$ 高斯积分点上的 $\\mathbf{B}$ 矩阵，组装单元刚度矩阵 $\\mathbf{K}$，并在一个基于 $\\mathbf{K}$ 量级的严格绝对公差内检查其对称性。\n- 生成单行输出，其中包含四个测试用例的对称性检查结果，形式为方括号括起来的逗号分隔列表；例如，$\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4\\right]$，其中每个条目都是一个布尔值。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含结果，形式为方括号括起来的逗号分隔列表，确切格式为 $\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4\\right]$，其中每个 $\\text{result}_i$ 为 $\\text{True}$ 或 $\\text{False}$。",
            "solution": "本问题要求实现一个用于线性弹性的二维四节点等参四边形单元，并验证所得单元刚度矩阵 $\\mathbf{K}$ 的对称性。此验证是对实现正确性的一次基本检验，因为 $\\mathbf{K}$ 的对称性是底层保守物理原理和有限元法变分形式的直接结果。推导过程从第一性原理开始，如下所示。\n\n首先，我们在父单元域内建立多项式插值。一个四节点四边形 ($Q_1$) 单元使用双线性形函数 $N_i(\\xi, \\eta)$，这些函数定义在自然坐标系 $(\\xi, \\eta)$ 上，其中 $\\xi, \\eta \\in [-1, 1]$。一个一般的双线性多项式形式为 $p(\\xi, \\eta) = c_1 + c_2\\xi + c_3\\eta + c_4\\xi\\eta$。节点 $i$ 的形函数 $N_i$ 必须满足 Kronecker-delta 性质：$N_i(\\xi_j, \\eta_j) = \\delta_{ij}$，其中 $(\\xi_j, \\eta_j)$ 是节点 $j$ 的坐标。在父单元域中，节点按逆时针编号：节点 1 位于 $(-1, -1)$，节点 2 位于 $(1, -1)$，节点 3 位于 $(1, 1)$，节点 4 位于 $(-1, 1)$。通过要求 $N_i$ 在其自身节点处为 1，在其他节点处为 0，我们推导出四个形函数：\n$$N_1(\\xi, \\eta) = \\frac{1}{4}(1-\\xi)(1-\\eta)$$\n$$N_2(\\xi, \\eta) = \\frac{1}{4}(1+\\xi)(1-\\eta)$$\n$$N_3(\\xi, \\eta) = \\frac{1}{4}(1+\\xi)(1+\\eta)$$\n$$N_4(\\xi, \\eta) = \\frac{1}{4}(1-\\xi)(1+\\eta)$$\n\n第二，我们定义等参映射。单元内任意点的物理坐标 $(x, y)$ 是通过使用相同的形函数从节点坐标 $(x_i, y_i)$ 插值得到的：\n$$x(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) x_i, \\quad y(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) y_i$$\n为了将关于物理坐标 $(x, y)$ 的导数与关于自然坐标 $(\\xi, \\eta)$ 的导数联系起来，我们使用链式法则，它定义了雅可比矩阵 $\\mathbf{J}$：\n$$ \\begin{Bmatrix} \\frac{\\partial f}{\\partial \\xi} \\\\ \\frac{\\partial f}{\\partial \\eta} \\end{Bmatrix} = \\begin{bmatrix} \\frac{\\partial x}{\\partial \\xi}  \\frac{\\partial y}{\\partial \\xi} \\\\ \\frac{\\partial x}{\\partial \\eta}  \\frac{\\partial y}{\\partial \\eta} \\end{bmatrix} \\begin{Bmatrix} \\frac{\\partial f}{\\partial x} \\\\ \\frac{\\partial f}{\\partial y} \\end{Bmatrix} = \\mathbf{J} \\begin{Bmatrix} \\frac{\\partial f}{\\partial x} \\\\ \\frac{\\partial f}{\\partial y} \\end{Bmatrix} $$\n$\\mathbf{J}$ 的分量通过对映射方程求导得到：\n$$J_{11} = \\frac{\\partial x}{\\partial \\xi} = \\sum_{i=1}^{4} \\frac{\\partial N_i}{\\partial \\xi} x_i, \\quad J_{12} = \\frac{\\partial y}{\\partial \\xi} = \\sum_{i=1}^{4} \\frac{\\partial N_i}{\\partial \\xi} y_i$$\n$$J_{21} = \\frac{\\partial x}{\\partial \\eta} = \\sum_{i=1}^{4} \\frac{\\partial N_i}{\\partial \\eta} x_i, \\quad J_{22} = \\frac{\\partial y}{\\partial \\eta} = \\sum_{i=1}^{4} \\frac{\\partial N_i}{\\partial \\eta} y_i$$\n所需的物理导数通过反转该关系得到：$\\nabla_x f = \\mathbf{J}^{-1} \\nabla_\\xi f$。\n\n第三，我们构建应变-位移矩阵 $\\mathbf{B}$。位移场 $\\mathbf{u} = (u_x, u_y)$ 的插值方式与几何形状类似：$u_x = \\sum N_i u_{xi}$ 和 $u_y = \\sum N_i u_{yi}$，其中 $\\mathbf{d} = [u_{x1}, u_{y1}, \\dots, u_{x4}, u_{y4}]^\\top$ 是节点位移向量。对于小应变运动学，采用 Voigt 记法（使用工程剪切应变）的应变向量为 $\\boldsymbol{\\varepsilon} = [\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}]^\\top$，其中：\n$$\\varepsilon_{xx} = \\frac{\\partial u_x}{\\partial x}, \\quad \\varepsilon_{yy} = \\frac{\\partial u_y}{\\partial y}, \\quad \\gamma_{xy} = \\frac{\\partial u_x}{\\partial y} + \\frac{\\partial u_y}{\\partial x}$$\n代入插值位移，我们得到关系式 $\\boldsymbol{\\varepsilon} = \\mathbf{B}\\mathbf{d}$。矩阵 $\\mathbf{B}$ 可分块为 $\\mathbf{B} = [\\mathbf{B}_1, \\mathbf{B}_2, \\mathbf{B}_3, \\mathbf{B}_4]$，其中每个子矩阵 $\\mathbf{B}_i$ 将应变与节点 $i$ 的位移联系起来：\n$$ \\mathbf{B}_i(\\xi, \\eta) = \\begin{bmatrix} \\frac{\\partial N_i}{\\partial x}  0 \\\\ 0  \\frac{\\partial N_i}{\\partial y} \\\\ \\frac{\\partial N_i}{\\partial y}  \\frac{\\partial N_i}{\\partial x} \\end{bmatrix} $$\n形函数的空间导数 $\\frac{\\partial N_i}{\\partial x}$ 和 $\\frac{\\partial N_i}{\\partial y}$ 在每个点 $(\\xi, \\eta)$ 处使用雅可比逆矩阵计算：\n$$ \\begin{Bmatrix} \\frac{\\partial N_i}{\\partial x} \\\\ \\frac{\\partial N_i}{\\partial y} \\end{Bmatrix} = \\mathbf{J}^{-1}(\\xi, \\eta) \\begin{Bmatrix} \\frac{\\partial N_i}{\\partial \\xi} \\\\ \\frac{\\partial N_i}{\\partial \\eta} \\end{Bmatrix} $$\n\n第四，我们组装单元刚度矩阵 $\\mathbf{K}$。根据虚功原理，$\\mathbf{K}$ 由在单元体积 $V_e$ 上的积分给出：\n$$ \\mathbf{K} = \\int_{V_e} \\mathbf{B}^\\top \\mathbf{D} \\mathbf{B} \\, dV $$\n对于一个厚度恒为 $t$ 的二维单元，这变成一个面积分，并被变换到父单元域：\n$$ \\mathbf{K} = t \\int_{-1}^{1} \\int_{-1}^{1} \\mathbf{B}(\\xi, \\eta)^\\top \\mathbf{D} \\mathbf{B}(\\xi, \\eta) \\det(\\mathbf{J}(\\xi, \\eta)) \\, d\\xi d\\eta $$\n材料的本构行为由对称矩阵 $\\mathbf{D}$ 描述。对于平面应变，它是：\n$$ \\mathbf{D} = \\frac{E}{(1+\\nu)(1-2\\nu)} \\begin{bmatrix} 1-\\nu  \\nu  0 \\\\ \\nu  1-\\nu  0 \\\\ 0  0  \\frac{1-2\\nu}{2} \\end{bmatrix} $$\n其中 $E$ 是杨氏模量，$\\nu$ 是泊松比。该积分使用 $2 \\times 2$ 高斯积分进行数值计算。积分点为 $(\\xi_k, \\eta_k) = (\\pm 1/\\sqrt{3}, \\pm 1/\\sqrt{3})$，所有相关权重 $w_k$ 均为 1。因此，刚度矩阵是以下总和：\n$$ \\mathbf{K} = t \\sum_{k=1}^{4} w_k \\mathbf{B}(\\xi_k, \\eta_k)^\\top \\mathbf{D} \\mathbf{B}(\\xi_k, \\eta_k) \\det(\\mathbf{J}(\\xi_k, \\eta_k)) $$\n\n最后，我们讨论 $\\mathbf{K}$ 的对称性。被积函数，我们称之为 $\\mathbf{C}(\\xi, \\eta) = \\mathbf{B}^\\top \\mathbf{D} \\mathbf{B}$，由于 $\\mathbf{D}$ 是对称的，所以它也是对称的：$\\mathbf{C}^\\top = (\\mathbf{B}^\\top \\mathbf{D} \\mathbf{B})^\\top = \\mathbf{B}^\\top \\mathbf{D}^\\top (\\mathbf{B}^\\top)^\\top = \\mathbf{B}^\\top \\mathbf{D} \\mathbf{B} = \\mathbf{C}$。由于 $\\mathbf{K}$ 是这些对称矩阵的加权和（其中权重是厚度、积分权重和雅可比行列式的标量积），$\\mathbf{K}$ 也必须是对称的：$\\mathbf{K} = \\mathbf{K}^\\top$。给定的任务是数值上验证此属性。由于浮点运算，计算出的矩阵 $\\mathbf{K}$ 可能不完全等于其转置 $\\mathbf{K}^\\top$。因此，验证必须检查差值 $\\mathbf{K} - \\mathbf{K}^\\top$ 是否在一个考虑了机器精度误差的、严格的小数值公差内为零。我们将使用一个随矩阵条目量级缩放的绝对公差来检查 `np.allclose(K, K.T)` 是否成立，以确保测试既严谨又实用。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef get_stiffness_matrix(nodes, E, nu, t):\n    \"\"\"\n    Computes the 8x8 stiffness matrix for a 4-node isoparametric\n    quadrilateral element under plane strain conditions.\n\n    Args:\n        nodes (np.ndarray): A 4x2 array of nodal coordinates, ordered counter-clockwise.\n        E (float): Young's modulus.\n        nu (float): Poisson's ratio.\n        t (float): Element thickness.\n\n    Returns:\n        np.ndarray: The 8x8 element stiffness matrix K.\n    \"\"\"\n    # Define the constitutive matrix D for plane strain\n    D_factor = E / ((1 + nu) * (1 - 2 * nu))\n    D = D_factor * np.array([\n        [1 - nu, nu, 0],\n        [nu, 1 - nu, 0],\n        [0, 0, (1 - 2 * nu) / 2.]\n    ])\n\n    # 2x2 Gaussian quadrature points and weights\n    # For a 2x2 scheme in [-1, 1], all weights are 1.0.\n    gp_val = 1.0 / np.sqrt(3.0)\n    gauss_points = [\n        (-gp_val, -gp_val),\n        (gp_val, -gp_val),\n        (gp_val, gp_val),\n        (-gp_val, gp_val)\n    ]\n    \n    # Initialize the 8x8 element stiffness matrix\n    K = np.zeros((8, 8))\n\n    # Loop over the Gaussian quadrature points\n    for xi, eta in gauss_points:\n        # Derivatives of shape functions with respect to natural coordinates (xi, eta)\n        dNdxi_vec = 0.25 * np.array([\n            -(1 - eta),  # dN1/dxi\n            (1 - eta),   # dN2/dxi\n            (1 + eta),   # dN3/dxi\n            -(1 + eta)   # dN4/dxi\n        ])\n        \n        dNdeta_vec = 0.25 * np.array([\n            -(1 - xi),   # dN1/deta\n            -(1 + xi),   # dN2/deta\n            (1 + xi),    # dN3/deta\n            (1 - xi)     # dN4/deta\n        ])\n        \n        # Calculate the Jacobian matrix J\n        # J = [[dx/dxi, dy/dxi], [dx/deta, dy/deta]]\n        J = np.zeros((2, 2))\n        J[0, 0] = np.dot(dNdxi_vec, nodes[:, 0])\n        J[0, 1] = np.dot(dNdxi_vec, nodes[:, 1])\n        J[1, 0] = np.dot(dNdeta_vec, nodes[:, 0])\n        J[1, 1] = np.dot(dNdeta_vec, nodes[:, 1])\n        \n        detJ = np.linalg.det(J)\n        \n        # The Jacobian determinant must be positive for a valid mapping.\n        if detJ = 0:\n            raise ValueError(\"Jacobian determinant is non-positive. Element is distorted.\")\n        \n        invJ = np.linalg.inv(J)\n        \n        # Initialize the strain-displacement matrix B (3x8)\n        B = np.zeros((3, 8))\n        for i in range(4):\n            # Combine the derivatives for node i\n            dNi_dxieta = np.array([dNdxi_vec[i], dNdeta_vec[i]])\n            \n            # Transform derivatives to physical coordinates (x, y)\n            dNi_dxy = invJ @ dNi_dxieta\n            dN_dx = dNi_dxy[0]\n            dN_dy = dNi_dxy[1]\n            \n            # Populate the B matrix for node i (columns 2*i and 2*i+1)\n            B[0, 2 * i] = dN_dx\n            B[1, 2 * i + 1] = dN_dy\n            B[2, 2 * i] = dN_dy\n            B[2, 2 * i + 1] = dN_dx\n\n        # Accumulate the stiffness matrix contribution from the current Gauss point\n        # The quadrature weight is 1.0.\n        K += B.T @ D @ B * detJ * t\n        \n    return K\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and verify the symmetry\n    of the computed element stiffness matrices.\n    \"\"\"\n    test_cases = [\n        {'nodes': np.array([(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)]), \n         'E': 70e9, 'nu': 0.33, 't': 0.1},\n        {'nodes': np.array([(0.0, 0.0), (1.2, 0.0), (1.2, 1.0), (0.2, 1.0)]), \n         'E': 210e9, 'nu': 0.3, 't': 0.05},\n        {'nodes': np.array([(0.0, 0.0), (1.0, 0.0), (0.9, 0.8), (-0.1, 0.9)]), \n         'E': 120e9, 'nu': 0.25, 't': 0.2},\n        {'nodes': np.array([(0.0, 0.0), (1.7320508075688772, 1.0), \n                             (1.2320508075688772, 1.8660254037844386), \n                             (-0.5, 0.8660254037844386)]), \n         'E': 1e9, 'nu': 0.4, 't': 0.005}\n    ]\n    \n    results = []\n    for case in test_cases:\n        K = get_stiffness_matrix(case['nodes'], case['E'], case['nu'], case['t'])\n        \n        # Symmetry Check: Verify that K is equal to its transpose K.T within a\n        # strict tolerance to account for floating-point inaccuracies.\n        # The absolute tolerance is scaled by the maximum absolute value in K,\n        # as suggested by the prompt \"based on the magnitude of K\".\n        max_abs_K = np.max(np.abs(K))\n        \n        if max_abs_K == 0.0:\n            # For a zero matrix, it is symmetric, and atol can be 0.\n            dynamic_atol = 0.0\n        else:\n            # Define a strict absolute tolerance that scales with the matrix magnitude.\n            # A factor of 1e-12 is robust for double precision arithmetic.\n            dynamic_atol = 1e-12 * max_abs_K\n            \n        is_symmetric = np.allclose(K, K.T, rtol=0, atol=dynamic_atol)\n        results.append(is_symmetric)\n        \n    # Print the results in the required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}