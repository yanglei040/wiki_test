{
    "hands_on_practices": [
        {
            "introduction": "等参映射是有限元方法的基石，它允许我们使用一个统一的“母单元”来表示物理域中各种形状的单元。此映射的有效性取决于雅可比行列式，该行列式在整个单元内必须保持为正，以确保一个唯一的、非反转的映射关系。本练习将通过计算一个双线性四边形的雅可比行列式，让你亲手实践并诊断映射失效的情况，这是调试网格和理解单元扭曲极限的一项关键技能 。",
            "id": "3565546",
            "problem": "考虑一个用于离散化计算固体力学中固体域的四节点双线性等参四边形单元。该单元在母空间中由自然坐标 $(\\xi,\\eta)\\in[-1,1]\\times[-1,1]$ 定义，并通过双线性形函数映射到物理空间 $(x,y)$。物理空间中的节点坐标按局部节点编号 $1\\to2\\to3\\to4$ 的顺序列出，分别为 $\\boldsymbol{x}_1=(0,0)$、$\\boldsymbol{x}_2=(0,2)$、$\\boldsymbol{x}_3=(2,0)$ 和 $\\boldsymbol{x}_4=(2,2)$。使用标准双线性等参映射，计算雅可比行列式 $J(\\xi,\\eta)=\\det\\left(\\partial(x,y)/\\partial(\\xi,\\eta)\\right)$ 及其在标准 $2\\times 2$ Gauss-Legendre 积分点 $(\\xi,\\eta)=\\left(\\pm\\frac{1}{\\sqrt{3}},\\pm\\frac{1}{\\sqrt{3}}\\right)$ 处的绝对值 $|J(\\xi,\\eta)|$。确定在这些点中是否有任何点违反了正定条件 $J(\\xi,\\eta)>0$。\n\n将您的最终答案表示为一个单行矩阵，其中包含：\n- 首先是按 $(\\xi,\\eta)=\\left(-\\frac{1}{\\sqrt{3}},-\\frac{1}{\\sqrt{3}}\\right)$、$\\left(+\\frac{1}{\\sqrt{3}},-\\frac{1}{\\sqrt{3}}\\right)$、$\\left(+\\frac{1}{\\sqrt{3}},+\\frac{1}{\\sqrt{3}}\\right)$、$\\left(-\\frac{1}{\\sqrt{3}},+\\frac{1}{\\sqrt{3}}\\right)$ 顺序排列的四个高斯点上的 $J$ 值，\n- 然后是按相同顺序排列的对应的四个 $|J|$ 值，\n- 最后是违反正定条件 $J(\\xi,\\eta)>0$ 的高斯点整数计数。\n\n无需四舍五入。只提供所要求的数字；最终答案中不包括单位。",
            "solution": "用户想要分析一个四节点双线性等参四边形单元。这个过程涉及几个步骤：定义从母单元到物理单元的映射，计算该映射的雅可比矩阵，然后在其指定点上计算其行列式以检查有效性。\n\n### 步骤 1：问题验证\n\n**1.1. 提取已知条件**\n- **单元类型**：四节点双线性等参四边形单元。\n- **母空间**：自然坐标 $(\\xi, \\eta)$ 在域 $[-1, 1] \\times [-1, 1]$ 内。\n- **物理空间节点坐标**：按局部节点编号 $1 \\to 2 \\to 3 \\to 4$ 的顺序列出：\n  - $\\boldsymbol{x}_1 = (x_1, y_1) = (0, 0)$\n  - $\\boldsymbol{x}_2 = (x_2, y_2) = (0, 2)$\n  - $\\boldsymbol{x}_3 = (x_3, y_3) = (2, 0)$\n  - $\\boldsymbol{x}_4 = (x_4, y_4) = (2, 2)$\n- **任务**：计算在四个标准 $2 \\times 2$ Gauss-Legendre 积分点处的雅可比行列式 $J(\\xi, \\eta)$ 及其绝对值 $|J(\\xi, \\eta)|$。\n- **高斯点**：$(\\xi, \\eta) = \\left(\\pm\\frac{1}{\\sqrt{3}}, \\pm\\frac{1}{\\sqrt{3}}\\right)$。\n- **正定条件**：确定违反 $J(\\xi, \\eta) > 0$ 条件的高斯点数量。\n- **输出顺序**：最终答案需要按以下顺序给出高斯点上的 $J$ 值、$|J|$ 值以及违规计数：\n  1. $(-\\frac{1}{\\sqrt{3}}, -\\frac{1}{\\sqrt{3}})$\n  2. $(+\\frac{1}{\\sqrt{3}}, -\\frac{1}{\\sqrt{3}})$\n  3. $(+\\frac{1}{\\sqrt{3}}, +\\frac{1}{\\sqrt{3}})$\n  4. $(-\\frac{1}{\\sqrt{3}}, +\\frac{1}{\\sqrt{3}})$\n\n**1.2. 使用提取的已知条件进行验证**\n该问题在科学上基于有限元法（FEM）的理论。它是一个适定的问题，提供了计算唯一解所需的所有数据。节点坐标描述了一个非凸（“领结”形或“沙漏”形）四边形，这是一种有效但扭曲的构型，用于测试单元格式的鲁棒性。检查雅可比行列式符号的任务是有限元法中的一个标准程序，以确保从母单元到物理单元的映射是有效的一一映射。该问题是客观的，不包含任何科学缺陷、不一致或歧义。\n\n**1.3. 结论与行动**\n问题有效。将提供完整解答。\n\n### 步骤 2：定义等参映射\n\n对于一个四节点双线性等参单元，物理坐标 $(x, y)$ 是使用双线性形函数 $N_i(\\xi, \\eta)$ 从节点坐标插值得到的。母空间中的标准局部节点编号是逆时针方向的：\n- 节点 1：$(\\xi, \\eta) = (-1, -1)$\n- 节点 2：$(\\xi, \\eta) = (1, -1)$\n- 节点 3：$(\\xi, \\eta) = (1, 1)$\n- 节点 4：$(\\xi, \\eta) = (-1, 1)$\n\n相应的形函数是：\n$N_1(\\xi, \\eta) = \\frac{1}{4}(1-\\xi)(1-\\eta)$\n$N_2(\\xi, \\eta) = \\frac{1}{4}(1+\\xi)(1-\\eta)$\n$N_3(\\xi, \\eta) = \\frac{1}{4}(1+\\xi)(1+\\eta)$\n$N_4(\\xi, \\eta) = \\frac{1}{4}(1-\\xi)(1+\\eta)$\n\n问题陈述将给定的物理坐标 $\\boldsymbol{x}_1, \\boldsymbol{x}_2, \\boldsymbol{x}_3, \\boldsymbol{x}_4$ 分别赋给局部节点 $1, 2, 3, 4$。等参映射为：\n$$ x(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) x_i $$\n$$ y(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) y_i $$\n\n代入给定的节点坐标：\n$x(\\xi, \\eta) = N_1(\\xi, \\eta) \\cdot 0 + N_2(\\xi, \\eta) \\cdot 0 + N_3(\\xi, \\eta) \\cdot 2 + N_4(\\xi, \\eta) \\cdot 2$\n$x(\\xi, \\eta) = 2(N_3(\\xi, \\eta) + N_4(\\xi, \\eta))$\n$x(\\xi, \\eta) = 2 \\left( \\frac{1}{4}(1+\\xi)(1+\\eta) + \\frac{1}{4}(1-\\xi)(1+\\eta) \\right)$\n$x(\\xi, \\eta) = \\frac{1}{2}(1+\\eta) \\left( (1+\\xi) + (1-\\xi) \\right) = \\frac{1}{2}(1+\\eta)(2) = 1+\\eta$\n\n$y(\\xi, \\eta) = N_1(\\xi, \\eta) \\cdot 0 + N_2(\\xi, \\eta) \\cdot 2 + N_3(\\xi, \\eta) \\cdot 0 + N_4(\\xi, \\eta) \\cdot 2$\n$y(\\xi, \\eta) = 2(N_2(\\xi, \\eta) + N_4(\\xi, \\eta))$\n$y(\\xi, \\eta) = 2 \\left( \\frac{1}{4}(1+\\xi)(1-\\eta) + \\frac{1}{4}(1-\\xi)(1+\\eta) \\right)$\n$y(\\xi, \\eta) = \\frac{1}{2} \\left( 1-\\eta+\\xi-\\xi\\eta + 1+\\eta-\\xi-\\xi\\eta \\right) = \\frac{1}{2}(2 - 2\\xi\\eta) = 1-\\xi\\eta$\n\n因此，从母空间到物理空间的映射由 $(x, y) = (1+\\eta, 1-\\xi\\eta)$ 给出。\n\n### 步骤 3：计算雅可比矩阵及其行列式\n\n变换的雅可比矩阵 $\\mathbf{J}$ 定义为：\n$$ \\mathbf{J}(\\xi, \\eta) = \\frac{\\partial(x, y)}{\\partial(\\xi, \\eta)} = \\begin{pmatrix} \\frac{\\partial x}{\\partial \\xi} & \\frac{\\partial x}{\\partial \\eta} \\\\ \\frac{\\partial y}{\\partial \\xi} & \\frac{\\partial y}{\\partial \\eta} \\end{pmatrix} $$\n\n我们计算所需的偏导数：\n$\\frac{\\partial x}{\\partial \\xi} = \\frac{\\partial}{\\partial \\xi}(1+\\eta) = 0$\n$\\frac{\\partial x}{\\partial \\eta} = \\frac{\\partial}{\\partial \\eta}(1+\\eta) = 1$\n$\\frac{\\partial y}{\\partial \\xi} = \\frac{\\partial}{\\partial \\xi}(1-\\xi\\eta) = -\\eta$\n$\\frac{\\partial y}{\\partial \\eta} = \\frac{\\partial}{\\partial \\eta}(1-\\xi\\eta) = -\\xi$\n\n组合成雅可比矩阵：\n$$ \\mathbf{J}(\\xi, \\eta) = \\begin{pmatrix} 0 & 1 \\\\ -\\eta & -\\xi \\end{pmatrix} $$\n\n雅可比行列式，记为 $J(\\xi, \\eta)$，为：\n$$ J(\\xi, \\eta) = \\det(\\mathbf{J}) = (0)(-\\xi) - (1)(-\\eta) = \\eta $$\n\n### 步骤 4：在高斯积分点处求值\n\n我们需要按照指定的顺序，在四个高斯点上计算 $J(\\xi, \\eta) = \\eta$ 和 $|J(\\xi, \\eta)|=|\\eta|$。令 $a = \\frac{1}{\\sqrt{3}}$。\n\n1.  **点 1**：$(\\xi_1, \\eta_1) = (-a, -a) = \\left(-\\frac{1}{\\sqrt{3}}, -\\frac{1}{\\sqrt{3}}\\right)$\n    $J_1 = \\eta_1 = -\\frac{1}{\\sqrt{3}}$\n    $|J_1| = \\left|-\\frac{1}{\\sqrt{3}}\\right| = \\frac{1}{\\sqrt{3}}$\n\n2.  **点 2**：$(\\xi_2, \\eta_2) = (a, -a) = \\left(\\frac{1}{\\sqrt{3}}, -\\frac{1}{\\sqrt{3}}\\right)$\n    $J_2 = \\eta_2 = -\\frac{1}{\\sqrt{3}}$\n    $|J_2| = \\left|-\\frac{1}{\\sqrt{3}}\\right| = \\frac{1}{\\sqrt{3}}$\n\n3.  **点 3**：$(\\xi_3, \\eta_3) = (a, a) = \\left(\\frac{1}{\\sqrt{3}}, \\frac{1}{\\sqrt{3}}\\right)$\n    $J_3 = \\eta_3 = \\frac{1}{\\sqrt{3}}$\n    $|J_3| = \\left|\\frac{1}{\\sqrt{3}}\\right| = \\frac{1}{\\sqrt{3}}$\n\n4.  **点 4**：$(\\xi_4, \\eta_4) = (-a, a) = \\left(-\\frac{1}{\\sqrt{3}}, \\frac{1}{\\sqrt{3}}\\right)$\n    $J_4 = \\eta_4 = \\frac{1}{\\sqrt{3}}$\n    $|J_4| = \\left|\\frac{1}{\\sqrt{3}}\\right| = \\frac{1}{\\sqrt{3}}$\n\n### 步骤 5：检查正定条件的违反情况\n\n$J(\\xi, \\eta) > 0$ 的正定条件确保了映射的有效性（保持方向）。如果 $J(\\xi, \\eta) \\le 0$，则发生违规。\n\n-   在点 1：$J_1 = -\\frac{1}{\\sqrt{3}} < 0$。**违规**。\n-   在点 2：$J_2 = -\\frac{1}{\\sqrt{3}} < 0$。**违规**。\n-   在点 3：$J_3 = \\frac{1}{\\sqrt{3}} > 0$。无违规。\n-   在点 4：$J_4 = \\frac{1}{\\sqrt{3}} > 0$。无违规。\n\n违反正定条件的高斯点总数为 $2$。\n\n### 步骤 6：整合最终答案\n\n最终答案是一个行矩阵，按指定顺序包含四个 $J$ 值、四个 $|J|$ 值和违规计数。\n\n-   $J$ 的值：$-\\frac{1}{\\sqrt{3}}$, $-\\frac{1}{\\sqrt{3}}$, $\\frac{1}{\\sqrt{3}}$, $\\frac{1}{\\sqrt{3}}$\n-   $|J|$ 的值：$\\frac{1}{\\sqrt{3}}$, $\\frac{1}{\\sqrt{3}}$, $\\frac{1}{\\sqrt{3}}$, $\\frac{1}{\\sqrt{3}}$\n-   违规计数：$2$\n\n由此得到最终的矩阵。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n-\\frac{1}{\\sqrt{3}} & -\\frac{1}{\\sqrt{3}} & \\frac{1}{\\sqrt{3}} & \\frac{1}{\\sqrt{3}} & \\frac{1}{\\sqrt{3}} & \\frac{1}{\\sqrt{3}} & \\frac{1}{\\sqrt{3}} & \\frac{1}{\\sqrt{3}} & 2\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "单元刚度矩阵 $k_e$ 是有限元分析的核心，它建立了节点位移与节点力之间的关系。该矩阵源于虚功原理，融合了描述几何信息的应变-位移矩阵 $B$ 和描述材料本构关系的矩阵 $D$。这项综合性练习要求你从第一性原理出发，为三维线性四面体单元推导并实现刚度矩阵的计算，从而深入理解单元几何形状和材料属性如何影响其力学响应 。",
            "id": "3565565",
            "problem": "您需要推导、实现并评估一个线性四面体有限元的应变-位移矩阵和一致单元刚度，该单元用于三维小应变各向同性线弹性问题。从虚功原理和小应变定义出发，得到其离散形式。然后，针对每个指定的测试用例，计算并报告所要求的标量不变量。\n\n从以下基本依据和核心定义开始：\n- 小应变张量 $\\boldsymbol{\\varepsilon}(\\mathbf{u})$，定义为 $\\varepsilon_{ij} = \\frac{1}{2}\\left(u_{i,j}+u_{j,i}\\right)$。\n- 各向同性线弹性固体的本构关系（胡克定律），$\\boldsymbol{\\sigma} = \\mathbb{C}:\\boldsymbol{\\varepsilon}$，其中 $\\mathbb{C}$ 取决于杨氏模量 $E$ 和泊松比 $\\nu$。\n- 在单个单元域 $\\Omega_e$ 上，无体力静态平衡的虚功原理的 Galerkin 形式，通过形函数进行空间离散化后，可得到单元刚度。\n\n在线性四面体上，位移场由四个标量形函数 $N_a(\\mathbf{x})$（$a\\in\\{1,2,3,4\\}$）插值而成，这些形函数在节点处满足 $N_a(\\mathbf{x}_b) = \\delta_{ab}$。每个 $N_a$ 都是仿射的，形式为 $N_a(x,y,z) = a_a + b_a x + c_a y + d_a z$。通过强制执行 Kronecker delta 属性来确定系数。梯度 $\\nabla N_a$ 在单元上是常数，并定义了线性四面体的应变-位移矩阵 $\\mathbf{B}$。对于三维弹性问题，采用工程应变向量排序 $\\{\\varepsilon_{xx},\\varepsilon_{yy},\\varepsilon_{zz},\\gamma_{yz},\\gamma_{zx},\\gamma_{xy}\\}^{\\mathsf{T}}$，相应地组装 $\\mathbf{B}\\in\\mathbb{R}^{6\\times 12}$。\n\n对于三维各向同性弹性矩阵 $\\mathbf{D}\\in\\mathbb{R}^{6\\times 6}$，使用由 $E$ 和 $\\nu$ 定义的 Lamé 参数 $\\lambda$ 和 $\\mu$，以及与所选工程应变向量一致的标准 $6\\times 6$ 表示。\n\n一致单元刚度通过在单元上积分双线性形式得到，对于线性四面体单元，这简化为常数被积函数乘以单元体积。\n\n实现一个程序，对每个测试用例计算：\n- 单元体积 $V$，单位为 $\\mathrm{m}^3$，\n- 应变-位移矩阵的 Frobenius 范数 $\\lVert \\mathbf{B}\\rVert_F$，单位为 $\\mathrm{m}^{-1}$，\n- 单元刚度的 Frobenius 范数 $\\lVert \\mathbf{k}_e\\rVert_F$，单位为 $\\mathrm{N/m}$，\n- 单元刚度的迹 $\\mathrm{tr}(\\mathbf{k}_e)$，单位为 $\\mathrm{N/m}$。\n\n所有答案必须以国际单位制（SI）表示。不涉及角度。将每个测试用例的四个输出报告为实数。\n\n测试套件（每个用例由节点坐标和材料属性定义）：\n- 用例 $1$（基准单位四面体）：节点位于 $\\mathbf{x}_1=(0,0,0)$、$\\mathbf{x}_2=(1,0,0)$、$\\mathbf{x}_3=(0,1,0)$、$\\mathbf{x}_4=(0,0,1)$，材料属性为 $E=2.10\\times 10^{11}\\,\\mathrm{Pa}$ 和 $\\nu=0.3$。\n- 用例 $2$（几何尺寸缩放因子为 $2$）：节点位于 $\\mathbf{x}_1=(0,0,0)$、$\\mathbf{x}_2=(2,0,0)$、$\\mathbf{x}_3=(0,2,0)$、$\\mathbf{x}_4=(0,0,2)$，材料属性为 $E=2.10\\times 10^{11}\\,\\mathrm{Pa}$ 和 $\\nu=0.3$。\n- 用例 $3$（扭曲四面体）：节点位于 $\\mathbf{x}_1=(1.0,-1.0,0.5)$、$\\mathbf{x}_2=(2.0,0.2,-0.3)$、$\\mathbf{x}_3=(0.3,1.7,0.4)$、$\\mathbf{x}_4=(-0.5,-0.6,1.2)$，材料属性为 $E=7.0\\times 10^{10}\\,\\mathrm{Pa}$ 和 $\\nu=0.25$。\n- 用例 $4$（近退化体积）：节点位于 $\\mathbf{x}_1=(0,0,0)$、$\\mathbf{x}_2=(1,0,0)$、$\\mathbf{x}_3=(0,1.0\\times 10^{-2},0)$、$\\mathbf{x}_4=(0,0,1.0\\times 10^{-3})$，材料属性为 $E=1.0\\times 10^{10}\\,\\mathrm{Pa}$ 和 $\\nu=0.33$。\n- 用例 $5$（近不可压缩）：节点位于 $\\mathbf{x}_1=(0,0,0)$、$\\mathbf{x}_2=(1,0,0)$、$\\mathbf{x}_3=(0,1,0)$、$\\mathbf{x}_4=(0,0,1)$，材料属性为 $E=1.0\\times 10^{6}\\,\\mathrm{Pa}$ 和 $\\nu=0.4999$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含所有测试用例的结果，格式为逗号分隔的列表，并用方括号括起来。每个测试用例贡献一个包含四个数字的子列表，顺序为 $[V,\\lVert \\mathbf{B}\\rVert_F,\\lVert \\mathbf{k}_e\\rVert_F,\\mathrm{tr}(\\mathbf{k}_e)]$。\n- 对每个数字使用科学记数法，并精确到 $10$ 位有效数字。\n- 例如，总输出的格式必须类似于 $[[v_1,b_1,k_1,t_1],[v_2,b_2,k_2,t_2],\\dots]$，不含空格。\n\n您的任务是从第一性原理出发进行推导和实现，以便程序运行时能为上述五个用例输出所要求的一行结果。",
            "solution": "我们从第一性原理出发，推导三维小应变各向同性弹性的线性四面体单元矩阵。设 $\\Omega_e\\subset\\mathbb{R}^3$ 为单元域，其节点位置为 $\\mathbf{x}_a=(x_a,y_a,z_a)$，其中 $a\\in\\{1,2,3,4\\}$。位移场 $\\mathbf{u}(\\mathbf{x})$ 通过形函数 $N_a(\\mathbf{x})$ 和节点位移向量 $\\mathbf{d}_a\\in\\mathbb{R}^3$ 近似为 $\\mathbf{u}(\\mathbf{x})=\\sum_{a=1}^4 N_a(\\mathbf{x})\\mathbf{d}_a$。在小应变运动学中，应变张量为 $\\boldsymbol{\\varepsilon}(\\mathbf{u})=\\frac{1}{2}\\left(\\nabla\\mathbf{u}+(\\nabla\\mathbf{u})^{\\mathsf{T}}\\right)$，其分量为 $\\varepsilon_{ij}=\\frac{1}{2}\\left(u_{i,j}+u_{j,i}\\right)$。\n\n对于线性四面体，每个形函数 $N_a$ 都是仿射的：\n$$\nN_a(x,y,z)=a_a + b_a x + c_a y + d_a z,\n$$\n具有 Kronecker delta 插值条件 $N_a(\\mathbf{x}_b)=\\delta_{ab}$。对每个 $a$ 的这四个条件给出一个 $4\\times 4$ 线性系统。将节点位置收集到矩阵中\n$$\n\\mathbf{M}=\\begin{bmatrix}\n1 & x_1 & y_1 & z_1\\\\\n1 & x_2 & y_2 & z_2\\\\\n1 & x_3 & y_3 & z_3\\\\\n1 & x_4 & y_4 & z_4\n\\end{bmatrix},\n$$\n并定义系数向量 $\\boldsymbol{\\alpha}_a=\\begin{bmatrix}a_a & b_a & c_a & d_a\\end{bmatrix}^{\\mathsf{T}}$。Kronecker 条件可写为 $\\mathbf{M}\\boldsymbol{\\alpha}_a=\\mathbf{e}_a$，其中 $\\mathbf{e}_a$ 是 $\\mathbb{R}^4$ 的第 $a$ 个标准基向量。因此，$\\boldsymbol{\\alpha}_a=\\mathbf{M}^{-1}\\mathbf{e}_a$ 且梯度在整个单元上是常数：\n$$\n\\nabla N_a = \\begin{bmatrix} \\frac{\\partial N_a}{\\partial x} \\\\ \\frac{\\partial N_a}{\\partial y} \\\\ \\frac{\\partial N_a}{\\partial z} \\end{bmatrix} = \\begin{bmatrix} b_a\\\\ c_a\\\\ d_a\\end{bmatrix} \\in \\mathbb{R}^3.\n$$\n\n采用工程应变向量排序 $\\boldsymbol{\\varepsilon}_\\mathrm{eng}=\\begin{bmatrix}\\varepsilon_{xx} & \\varepsilon_{yy} & \\varepsilon_{zz} & \\gamma_{yz} & \\gamma_{zx} & \\gamma_{xy}\\end{bmatrix}^{\\mathsf{T}}$。应变-位移矩阵 $\\mathbf{B}\\in\\mathbb{R}^{6\\times 12}$ 由梯度 $\\nabla N_a$ 组装而成，使得 $\\boldsymbol{\\varepsilon}_\\mathrm{eng}=\\mathbf{B}\\mathbf{d}_e$，其中 $\\mathbf{d}_e\\in\\mathbb{R}^{12}$ 堆叠了节点位移 $\\mathbf{d}_1,\\dots,\\mathbf{d}_4$。对于节点 $a$，其梯度分量为 $b_a=\\partial N_a/\\partial x$, $c_a=\\partial N_a/\\partial y$, $d_a=\\partial N_a/\\partial z$，位于 $\\mathbf{B}$ 矩阵第 $3(a-1)+1:3a$ 列的块 $\\mathbf{B}_a$ 为\n$$\n\\mathbf{B}_a=\\begin{bmatrix}\nb_a & 0   & 0\\\\\n0   & c_a & 0\\\\\n0   & 0   & d_a\\\\\n0   & d_a & c_a\\\\\nd_a & 0   & b_a\\\\\nc_a & b_a & 0\n\\end{bmatrix}.\n$$\n因此 $\\mathbf{B}=\\begin{bmatrix}\\mathbf{B}_1 & \\mathbf{B}_2 & \\mathbf{B}_3 & \\mathbf{B}_4\\end{bmatrix}$。\n\n对于三维各向同性线弹性，柯西应力和工程应变通过 $\\boldsymbol{\\sigma}_\\mathrm{eng}=\\mathbf{D}\\boldsymbol{\\varepsilon}_\\mathrm{eng}$ 相关联，其中 $\\mathbf{D}\\in\\mathbb{R}^{6\\times 6}$ 用 Lamé 参数 $\\lambda$ 和 $\\mu$ 表示：\n$$\n\\lambda=\\frac{E\\nu}{(1+\\nu)(1-2\\nu)},\\qquad \\mu=\\frac{E}{2(1+\\nu)},\n$$\n以及\n$$\n\\mathbf{D}=\\begin{bmatrix}\n\\lambda+2\\mu & \\lambda      & \\lambda      & 0 & 0 & 0\\\\\n\\lambda      & \\lambda+2\\mu & \\lambda      & 0 & 0 & 0\\\\\n\\lambda      & \\lambda      & \\lambda+2\\mu & 0 & 0 & 0\\\\\n0            & 0            & 0            & \\mu & 0 & 0\\\\\n0            & 0            & 0            & 0 & \\mu & 0\\\\\n0            & 0            & 0            & 0 & 0 & \\mu\n\\end{bmatrix}.\n$$\n\n对于无体力的单个单元，虚功原理给出\n$$\n\\delta W_\\mathrm{int}=\\int_{\\Omega_e}\\boldsymbol{\\varepsilon}(\\delta\\mathbf{u}):\\boldsymbol{\\sigma}(\\mathbf{u})\\,\\mathrm{d}V\n=\\int_{\\Omega_e}\\boldsymbol{\\varepsilon}_\\mathrm{eng}(\\delta\\mathbf{u})^{\\mathsf{T}}\\mathbf{D}\\boldsymbol{\\varepsilon}_\\mathrm{eng}(\\mathbf{u})\\,\\mathrm{d}V\n=\\delta\\mathbf{d}_e^{\\mathsf{T}}\\left(\\int_{\\Omega_e}\\mathbf{B}^{\\mathsf{T}}\\mathbf{D}\\mathbf{B}\\,\\mathrm{d}V\\right)\\mathbf{d}_e.\n$$\n因此，一致单元刚度为\n$$\n\\mathbf{k}_e=\\int_{\\Omega_e}\\mathbf{B}^{\\mathsf{T}}\\mathbf{D}\\mathbf{B}\\,\\mathrm{d}V.\n$$\n对于线性四面体单元，$\\mathbf{B}$ 在 $\\Omega_e$ 上是常数，因此\n$$\n\\mathbf{k}_e=\\mathbf{B}^{\\mathsf{T}}\\mathbf{D}\\mathbf{B}V,\\qquad V=\\int_{\\Omega_e}\\mathrm{d}V.\n$$\n\n单元体积 $V$ 可以从节点坐标获得。设\n$$\n\\mathbf{M}=\\begin{bmatrix}\n1 & x_1 & y_1 & z_1\\\\\n1 & x_2 & y_2 & z_2\\\\\n1 & x_3 & y_3 & z_3\\\\\n1 & x_4 & y_4 & z_4\n\\end{bmatrix}.\n$$\n则有符号体积为 $V_s=\\frac{\\det(\\mathbf{M})}{6}$，而物理体积为 $V=|V_s|$. 这等价于 $V=\\frac{1}{6}\\big|(\\mathbf{x}_2-\\mathbf{x}_1)\\cdot\\big((\\mathbf{x}_3-\\mathbf{x}_1)\\times(\\mathbf{x}_4-\\mathbf{x}_1)\\big)\\big|$.\n\n每个测试用例的算法步骤：\n1.  根据节点坐标组装 $\\mathbf{M}$ 并计算 $\\mathbf{M}^{-1}$。对每个节点 $a$，提取 $\\boldsymbol{\\alpha}_a=\\mathbf{M}^{-1}\\mathbf{e}_a$，从而使 $\\nabla N_a=\\begin{bmatrix}b_a & c_a & d_a\\end{bmatrix}^{\\mathsf{T}}$ 对应于 $\\boldsymbol{\\alpha}_a$ 的最后三个分量。\n2.  通过放置由 $b_a,c_a,d_a$ 构建的 $\\mathbf{B}_a$ 块来组装 $\\mathbf{B}$。\n3.  根据给定的 $E$ 和 $\\nu$ 计算 $\\lambda$ 和 $\\mu$，并组装 $\\mathbf{D}$。\n4.  计算 $V=\\frac{|\\det(\\mathbf{M})|}{6}$。\n5.  计算 $\\mathbf{k}_e=\\mathbf{B}^{\\mathsf{T}}\\mathbf{D}\\mathbf{B}V$。\n6.  报告每个用例的四个标量：$V$、$\\lVert \\mathbf{B}\\rVert_F=\\sqrt{\\sum_{i,j}B_{ij}^2}$、$\\lVert \\mathbf{k}_e\\rVert_F=\\sqrt{\\sum_{i,j}k_{e,ij}^2}$ 和 $\\mathrm{tr}(\\mathbf{k}_e)=\\sum_i k_{e,ii}$。\n\n单位与条件说明：\n- $V$ 的单位是 $\\mathrm{m}^3$。\n- $\\mathbf{B}$ 的项以长度的倒数进行缩放，因此 $\\lVert\\mathbf{B}\\rVert_F$ 的单位是 $\\mathrm{m}^{-1}$。\n- $\\mathbf{D}$ 的单位是 $\\mathrm{Pa}=\\mathrm{N/m}^2$，所以 $\\mathbf{k}_e$ 的单位是 $\\mathrm{N/m}$。因此，$\\lVert\\mathbf{k}_e\\rVert_F$ 和 $\\mathrm{tr}(\\mathbf{k}_e)$ 的单位都是 $\\mathrm{N/m}$。\n- 单个单元刚度 $\\mathbf{k}_e$ 由于刚体模态而秩亏；Frobenius 范数和迹仍然是良定义且严格为正的。\n- 在用例 $2$ 中，将单元尺寸缩放因子 $s=2$，梯度将缩放 $1/s$，体积将缩放 $s^3$，因此 $\\mathbf{k}_e$ 缩放 $s$，这提供了一致性检验。在用例 $5$ 中，$\\nu\\to 0.5^{-}$ 会使 $\\lambda$ 变大，从而主要增加体积子空间中的刚度项。在用例 $4$ 中，小体积和大的梯度导致有限的 $\\mathbf{k}_e$，但 $\\lVert\\mathbf{B}\\rVert_F$ 增大。\n\n实现完全遵循这些推导过程，并按要求将每个用例的标量打印在单行的方括号嵌套列表中，每个数字采用科学记数法，并精确到十位有效数字。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_shape_function_gradients(nodes):\n    \"\"\"\n    Compute gradients of linear tetrahedral shape functions.\n    nodes: (4,3) array with rows [x_i, y_i, z_i] for i=1..4\n    Returns:\n        grads: (3,4) array where column i is [dNi/dx, dNi/dy, dNi/dz]\n        volume: positive scalar volume\n    \"\"\"\n    M = np.column_stack((np.ones(4), nodes))  # 4x4\n    detM = np.linalg.det(M)\n    volume = abs(detM) / 6.0\n    invM = np.linalg.inv(M)\n    # invM columns correspond to coefficients [a_i, b_i, c_i, d_i] for N_i\n    grads = invM[1:, :]  # rows 1..3 are [b, c, d], shape (3,4)\n    return grads, volume\n\ndef assemble_B(grads):\n    \"\"\"\n    Assemble the 6x12 B matrix from gradients.\n    grads: (3,4) with columns [dNi/dx, dNi/dy, dNi/dz]\n    Returns:\n        B: (6,12) strain-displacement matrix\n    \"\"\"\n    B = np.zeros((6, 12), dtype=float)\n    for a in range(4):\n        bx, by, bz = grads[0, a], grads[1, a], grads[2, a]\n        col = 3 * a\n        # Normal strains\n        B[0, col + 0] = bx\n        B[1, col + 1] = by\n        B[2, col + 2] = bz\n        # Engineering shear strains\n        B[3, col + 1] = bz  # gamma_yz: [0, d/dz, d/dy]\n        B[3, col + 2] = by\n        B[4, col + 0] = bz  # gamma_zx: [d/dz, 0, d/dx]\n        B[4, col + 2] = bx\n        B[5, col + 0] = by  # gamma_xy: [d/dy, d/dx, 0]\n        B[5, col + 1] = bx\n    return B\n\ndef elasticity_matrix_3d(E, nu):\n    \"\"\"\n    Build the 6x6 isotropic elasticity matrix D for 3D using engineering strains.\n    \"\"\"\n    lam = E * nu / ((1.0 + nu) * (1.0 - 2.0 * nu))\n    mu = E / (2.0 * (1.0 + nu))\n    D = np.zeros((6, 6), dtype=float)\n    # Normal components\n    D[0, 0] = lam + 2.0 * mu\n    D[1, 1] = lam + 2.0 * mu\n    D[2, 2] = lam + 2.0 * mu\n    D[0, 1] = lam\n    D[0, 2] = lam\n    D[1, 0] = lam\n    D[1, 2] = lam\n    D[2, 0] = lam\n    D[2, 1] = lam\n    # Shear components\n    D[3, 3] = mu\n    D[4, 4] = mu\n    D[5, 5] = mu\n    return D\n\ndef compute_element_invariants(nodes, E, nu):\n    \"\"\"\n    Compute V, ||B||_F, ||ke||_F, trace(ke) for a linear tetrahedral element.\n    \"\"\"\n    grads, V = compute_shape_function_gradients(nodes)\n    B = assemble_B(grads)\n    D = elasticity_matrix_3d(E, nu)\n    ke = B.T @ D @ B * V\n    # Invariants\n    Bnorm = float(np.linalg.norm(B, ord='fro'))\n    Kenorm = float(np.linalg.norm(ke, ord='fro'))\n    TrKe = float(np.trace(ke))\n    return V, Bnorm, Kenorm, TrKe\n\ndef format_results(results):\n    \"\"\"\n    Format results as a single-line nested list with scientific notation (10 significant digits).\n    \"\"\"\n    def fmt(x):\n        return f\"{x:.10e}\"\n    sublists = []\n    for V, Bn, Kn, Tr in results:\n        sublists.append(\"[\" + \",\".join([fmt(V), fmt(Bn), fmt(Kn), fmt(Tr)]) + \"]\")\n    return \"[\" + \",\".join(sublists) + \"]\"\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Unit tetrahedron, E=2.10e11 Pa, nu=0.3\n        (np.array([[0.0, 0.0, 0.0],\n                   [1.0, 0.0, 0.0],\n                   [0.0, 1.0, 0.0],\n                   [0.0, 0.0, 1.0]], dtype=float),\n         2.10e11, 0.3),\n        # Case 2: Scaled by 2\n        (np.array([[0.0, 0.0, 0.0],\n                   [2.0, 0.0, 0.0],\n                   [0.0, 2.0, 0.0],\n                   [0.0, 0.0, 2.0]], dtype=float),\n         2.10e11, 0.3),\n        # Case 3: Skew tetrahedron, E=7.0e10 Pa, nu=0.25\n        (np.array([[ 1.0, -1.0,  0.5],\n                   [ 2.0,  0.2, -0.3],\n                   [ 0.3,  1.7,  0.4],\n                   [-0.5, -0.6,  1.2]], dtype=float),\n         7.0e10, 0.25),\n        # Case 4: Nearly degenerate, E=1.0e10 Pa, nu=0.33\n        (np.array([[0.0, 0.0, 0.0],\n                   [1.0, 0.0, 0.0],\n                   [0.0, 1.0e-2, 0.0],\n                   [0.0, 0.0, 1.0e-3]], dtype=float),\n         1.0e10, 0.33),\n        # Case 5: Nearly incompressible, E=1.0e6 Pa, nu=0.4999\n        (np.array([[0.0, 0.0, 0.0],\n                   [1.0, 0.0, 0.0],\n                   [0.0, 1.0, 0.0],\n                   [0.0, 0.0, 1.0]], dtype=float),\n         1.0e6, 0.4999),\n    ]\n\n    results = []\n    for nodes, E, nu in test_cases:\n        V, Bnorm, Kenorm, TrKe = compute_element_invariants(nodes, E, nu)\n        results.append((V, Bnorm, Kenorm, TrKe))\n\n    # Final print statement in the exact required format.\n    print(format_results(results))\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "对于一般的单元形状，计算刚度矩阵的积分 $\\int B^T D B \\, dV$ 很少有解析解，因此必须进行数值计算。高斯积分是完成此任务的主力工具，但积分阶数（即高斯点的数量）的选择是在精度和计算成本之间的权衡。通过这项计算实践，你将研究积分阶数如何影响不同扭曲程度单元的刚度矩阵精度，从而对减缩积分等现象以及选择合适积分规则的重要性获得实践性的理解 。",
            "id": "3565598",
            "problem": "考虑一个处于平面应变条件下的小应变、线性弹性二维实体，该实体通过一个四节点双线性等参四边形单元进行离散化。以虚功原理和应变-位移关系的定义为基本依据。计算目标是通过数值积分来近似单元刚度矩阵，并量化积分阶数对结果的扰动。在无量纲形式下进行计算，以使所有量均为无量纲。\n\n从以下基本定义出发：(i) 在平面应变条件下，Cauchy应力张量通过各向同性弹性张量与小应变张量线性相关；(ii) 从母单元正方形到物理单元的等参映射定义了变换的雅可比矩阵；(iii) 应变-位移矩阵由形函数的空间导数得出。请在不依赖任何预制单元矩阵的情况下，实现以下算法任务：\n\n1. 在母域 $[-1,1] \\times [-1,1]$ 上，使用四节点双线性四边形等参插值，节点按逆时针方向采用标准排序 $\\{1,2,3,4\\}$。构建形函数及其关于母坐标 $(\\xi,\\eta)$ 的导数，通过雅可比矩阵映射到物理坐标，并使用工程剪应变约定，构建平面应变问题的应变-位移矩阵 $B$。\n\n2. 使用平面应变条件下的各向同性线性弹性本构矩阵，其杨氏模量为 $E$，泊松比为 $\\nu$。该矩阵用 Lamé 参数 $\\lambda$ 和 $\\mu$ 表示，使得剪切分量使用工程剪应变 $\\gamma_{xy}$。设置 $E=1$ 和 $\\nu=0.3$；使用单位厚度 $t=1$。\n\n3. 对于给定的单元几何形状，在每个参数方向上使用 $p \\in \\{1,2,3\\}$ 阶的张量积 Gauss-Legendre 积分来近似单元刚度矩阵 $k_e$，并使用 $p_{\\mathrm{ref}}=8$ 阶计算一个高保真参考值。将 $p$ 阶的归一化 Frobenius 范数误差定义为\n$$\ne_p \\equiv \\frac{\\lVert k_e^{(p)} - k_e^{(p_{\\mathrm{ref}})} \\rVert_F}{\\lVert k_e^{(p_{\\mathrm{ref}})} \\rVert_F}.\n$$\n通过离散变差估计刚度对积分阶数的敏感性\n$$\ns \\equiv \\max\\left( \\left| e_2 - e_1 \\right|, \\left| e_3 - e_2 \\right| \\right).\n$$\n\n4. 对以下单元几何形状测试套件实施上述步骤（节点坐标以 $(x,y)$ 形式列出，每个节点坐标对均按逆时针顺序给出）。所有坐标均为无量纲：\n- 测试用例 A（仿射正方形）：$[(0,0),(1,0),(1,1),(0,1)]$。\n- 测试用例 B（中度扭曲梯形）：$[(0,0),(2,0),(1.6,1.0),(0.2,1.0)]$。\n- 测试用例 C（倾斜凸四边形）：$[(0,0),(1.5,0.2),(1.8,1.1),(0.1,1.0)]$。\n- 测试用例 D（高纵横比矩形）：$[(0,0),(100,0),(100,1),(0,1)]$。\n\n对于每个测试用例，计算列表 $[e_1,e_2,e_3,s]$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个条目对应一个测试用例，其本身是包含四个浮点数的列表，按 $[e_1,e_2,e_3,s]$ 的顺序四舍五入到八位小数。例如，输出格式必须为\n$[[e_{1,A},e_{2,A},e_{3,A},s_A],[e_{1,B},e_{2,B},e_{3,B},s_B],[e_{1,C},e_{2,C},e_{3,C},s_C],[e_{1,D},e_{2,D},e_{3,D},s_D]]$。",
            "solution": "该问题要求实现并分析一个用于平面应变条件下二维线性弹性体的四节点双线性等参四边形单元。我们必须首先根据基本原理构建单元刚度矩阵的公式，然后通过 Gauss-Legendre 积分实现其数值近似，最后分析结果对于几种不同单元几何形状下积分阶数的敏感性。\n\n固体力学中有限元法的基础是虚功原理，其离散形式可导出方程组 $\\boldsymbol{K}\\boldsymbol{d} = \\boldsymbol{f}$，其中 $\\boldsymbol{K}$ 是全局刚度矩阵，$\\boldsymbol{d}$ 是节点位移向量，$\\boldsymbol{f}$ 是节点力向量。全局刚度矩阵由单元刚度矩阵 $\\boldsymbol{k}_e$ 组装而成。单个单元的单元刚度矩阵由其在单元体积 $V_e$ 上的积分给出：\n$$\n\\boldsymbol{k}_e = \\int_{V_e} \\boldsymbol{B}^T \\boldsymbol{C} \\boldsymbol{B} \\, dV\n$$\n对于厚度为常数 $t$ 的 $2$D 问题，这变为在单元面积 $A_e$ 上的积分：\n$$\n\\boldsymbol{k}_e = t \\int_{A_e} \\boldsymbol{B}^T \\boldsymbol{C} \\boldsymbol{B} \\, dA\n$$\n\n我们将构建此积分的各组成部分：应变-位移矩阵 $\\boldsymbol{B}$ 和本构矩阵 $\\boldsymbol{C}$。\n\n四节点四边形单元依赖于一种等参映射，该映射将由坐标 $(\\xi, \\eta) \\in [-1, 1] \\times [-1, 1]$ 定义的标准母单元正方形域映射到 $(x,y)$ 笛卡尔空间中的物理单元。该映射由用于插值位移场的相同形函数定义。单元内任意点的物理坐标 $(x,y)$ 由其四个节点的节点坐标 $(x_i, y_i)$ 插值得到：\n$$\nx(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) x_i \\quad , \\quad y(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) y_i\n$$\n对于从左下角 $(-1,-1)$ 开始的标准逆时针节点排序，双线性形函数 $N_i(\\xi, \\eta)$ 为：\n$$\n\\begin{aligned}\nN_1(\\xi, \\eta) = \\frac{1}{4}(1-\\xi)(1-\\eta) \\\\\nN_2(\\xi, \\eta) = \\frac{1}{4}(1+\\xi)(1-\\eta) \\\\\nN_3(\\xi, \\eta) = \\frac{1}{4}(1+\\xi)(1+\\eta) \\\\\nN_4(\\xi, \\eta) = \\frac{1}{4}(1-\\xi)(1+\\eta)\n\\end{aligned}\n$$\n\n应变-位移矩阵 $\\boldsymbol{B}$ 将工程应变向量 $\\boldsymbol{\\epsilon} = [\\epsilon_x, \\epsilon_y, \\gamma_{xy}]^T$ 与单元的节点位移向量 $\\boldsymbol{u}_e = [u_1, v_1, u_2, v_2, u_3, v_3, u_4, v_4]^T$ 相关联。应变分量由位移场 $u(x,y)$ 和 $v(x,y)$ 的空间导数导出：$\\epsilon_x = \\frac{\\partial u}{\\partial x}$，$\\epsilon_y = \\frac{\\partial v}{\\partial y}$ 和 $\\gamma_{xy} = \\frac{\\partial u}{\\partial y} + \\frac{\\partial v}{\\partial x}$。使用插值 $u = \\sum N_i u_i$ 和 $v = \\sum N_i v_i$，我们可以写出 $\\boldsymbol{\\epsilon} = \\boldsymbol{B} \\boldsymbol{u}_e$。$\\boldsymbol{B}$ 矩阵是一个 $3 \\times 8$ 的矩阵，由形函数的空间导数构成：\n$$\n\\boldsymbol{B}_i = \\begin{pmatrix} \\frac{\\partial N_i}{\\partial x} & 0 \\\\ 0 & \\frac{\\partial N_i}{\\partial y} \\\\ \\frac{\\partial N_i}{\\partial y} & \\frac{\\partial N_i}{\\partial x} \\end{pmatrix} \\quad \\implies \\quad \\boldsymbol{B} = [\\boldsymbol{B}_1, \\boldsymbol{B}_2, \\boldsymbol{B}_3, \\boldsymbol{B}_4]\n$$\n所需导数 $\\frac{\\partial N_i}{\\partial x}$ 和 $\\frac{\\partial N_i}{\\partial y}$ 是通过链式法则从母域中的导数 $\\frac{\\partial N_i}{\\partial \\xi}$ 和 $\\frac{\\partial N_i}{\\partial \\eta}$ 获得的，该法则涉及雅可比矩阵 $\\boldsymbol{J}$ 的逆：\n$$\n\\begin{pmatrix} \\frac{\\partial N_i}{\\partial x} \\\\ \\frac{\\partial N_i}{\\partial y} \\end{pmatrix} = \\boldsymbol{J}^{-1} \\begin{pmatrix} \\frac{\\partial N_i}{\\partial \\xi} \\\\ \\frac{\\partial N_i}{\\partial \\eta} \\end{pmatrix}\n$$\n雅可比矩阵 $\\boldsymbol{J}$ 定义为：\n$$\n\\boldsymbol{J} = \\begin{pmatrix} \\frac{\\partial x}{\\partial \\xi} & \\frac{\\partial y}{\\partial \\xi} \\\\ \\frac{\\partial x}{\\partial \\eta} & \\frac{\\partial y}{\\partial \\eta} \\end{pmatrix} = \\begin{pmatrix} \\sum_{i=1}^4 \\frac{\\partial N_i}{\\partial \\xi} x_i & \\sum_{i=1}^4 \\frac{\\partial N_i}{\\partial \\xi} y_i \\\\ \\sum_{i=1}^4 \\frac{\\partial N_i}{\\partial \\eta} x_i & \\sum_{i=1}^4 \\frac{\\partial N_i}{\\partial \\eta} y_i \\end{pmatrix}\n$$\n平面应变条件下各向同性线性弹性材料的本构矩阵 $\\boldsymbol{C}$ 通过 $\\boldsymbol{\\sigma} = \\boldsymbol{C}\\boldsymbol{\\epsilon}$ 将应力向量 $\\boldsymbol{\\sigma} = [\\sigma_x, \\sigma_y, \\tau_{xy}]^T$ 与应变向量 $\\boldsymbol{\\epsilon}$ 相关联。使用 Lamé 参数 $\\lambda$ 和 $\\mu$ （剪切模量），该矩阵为：\n$$\n\\boldsymbol{C} = \\begin{pmatrix} \\lambda + 2\\mu & \\lambda & 0 \\\\ \\lambda & \\lambda + 2\\mu & 0 \\\\ 0 & 0 & \\mu \\end{pmatrix}\n$$\nLamé 参数通过以下公式与杨氏模量 $E$ 和泊松比 $\\nu$ 相关：\n$$\n\\lambda = \\frac{E\\nu}{(1+\\nu)(1-2\\nu)} \\quad , \\quad \\mu = \\frac{E}{2(1+\\nu)}\n$$\n对于给定问题，$E=1$ 且 $\\nu=0.3$。\n\n刚度矩阵的积分在母域中进行计算。微分面积元变换为 $dA = \\det(\\boldsymbol{J}) d\\xi d\\eta$。当单位厚度 $t=1$ 时，刚度矩阵变为：\n$$\n\\boldsymbol{k}_e = \\int_{-1}^{1} \\int_{-1}^{1} \\boldsymbol{B}(\\xi, \\eta)^T \\boldsymbol{C} \\boldsymbol{B}(\\xi, \\eta) \\det(\\boldsymbol{J}(\\xi, \\eta)) \\, d\\xi \\, d\\eta\n$$\n被积函数通常是关于 $\\xi$ 和 $\\eta$ 的有理函数，因为 $\\boldsymbol{B}$ 依赖于 $\\boldsymbol{J}^{-1}$。因此，需要进行数值积分。我们使用张量积 Gauss-Legendre 积分方案。函数 $f(\\xi, \\eta)$ 的积分通过在 $p \\times p$ 个 Gauss 点 $(\\xi_i, \\eta_j)$ 网格上的加权和来近似：\n$$\n\\int_{-1}^{1} \\int_{-1}^{1} f(\\xi, \\eta) \\, d\\xi \\, d\\eta \\approx \\sum_{i=1}^{p} \\sum_{j=1}^{p} w_i w_j f(\\xi_i, \\eta_j)\n$$\n其中 $w_i, w_j$ 是权重，$(\\xi_i, \\eta_j)$ 是 $p$ 点 Gauss-Legendre 法则的横坐标。对积分阶数 $p \\in \\{1, 2, 3\\}$ 计算此数值近似以获得 $\\boldsymbol{k}_e^{(p)}$，并对高保真参考阶数 $p_{\\mathrm{ref}}=8$ 计算以获得 $\\boldsymbol{k}_e^{(p_{\\mathrm{ref}})}$。\n\n最后，使用差分矩阵的归一化 Frobenius 范数来量化 $p$ 阶刚度矩阵近似的误差：\n$$\ne_p = \\frac{\\lVert \\boldsymbol{k}_e^{(p)} - \\boldsymbol{k}_e^{(p_{\\mathrm{ref}})} \\rVert_F}{\\lVert \\boldsymbol{k}_e^{(p_{\\mathrm{ref}})} \\rVert_F}\n$$\n其中矩阵 $\\boldsymbol{A}$ 的 Frobenius 范数为 $\\lVert \\boldsymbol{A} \\rVert_F = \\sqrt{\\sum_{i,j} A_{ij}^2}$。刚度对积分阶数的敏感性通过连续阶数之间误差的最大变化来估计：\n$$\ns = \\max\\left( \\left| e_2 - e_1 \\right|, \\left| e_3 - e_2 \\right| \\right)\n$$\n将此过程应用于四个指定的单元几何形状，以生成所需的数值结果。对于仿射单元（矩形），雅可比矩阵 $\\boldsymbol{J}$ 是常数。被积函数分别成为关于 $\\xi$ 和 $\\eta$ 的 $2$ 次多项式，一个 $2 \\times 2$ 的 Gauss 法则（$p=2$）可以对其精确积分。因此，对于测试用例 A 和 D，我们预期 $e_2$ 和 $e_3$ 将为零（在机器精度范围内）。对于扭曲单元（B 和 C），雅可比矩阵是 $\\xi$ 和 $\\eta$ 的函数，导致被积函数为有理函数，低阶积分会产生非零误差。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the computation for all test cases.\n    \"\"\"\n    test_cases = {\n        'A': np.array([[0.0, 0.0], [1.0, 0.0], [1.0, 1.0], [0.0, 1.0]]),\n        'B': np.array([[0.0, 0.0], [2.0, 0.0], [1.6, 1.0], [0.2, 1.0]]),\n        'C': np.array([[0.0, 0.0], [1.5, 0.2], [1.8, 1.1], [0.1, 1.0]]),\n        'D': np.array([[0.0, 0.0], [100.0, 0.0], [100.0, 1.0], [0.0, 1.0]]),\n    }\n\n    E = 1.0\n    nu = 0.3\n    t = 1.0\n    p_ref = 8\n    p_orders = [1, 2, 3]\n    \n    all_results = []\n\n    for case_id in ['A', 'B', 'C', 'D']:\n        coords = test_cases[case_id]\n        \n        # Compute reference stiffness matrix with high-order quadrature\n        k_ref = compute_stiffness_matrix(coords, p_ref, E, nu, t)\n        norm_k_ref = np.linalg.norm(k_ref, 'fro')\n\n        errors = []\n        for p in p_orders:\n            k_p = compute_stiffness_matrix(coords, p, E, nu, t)\n            # Handle the case where the reference norm is zero (theoretically impossible for a non-singular element)\n            if norm_k_ref == 0:\n                error = np.linalg.norm(k_p - k_ref, 'fro')\n            else:\n                error = np.linalg.norm(k_p - k_ref, 'fro') / norm_k_ref\n            errors.append(error)\n        \n        e1, e2, e3 = errors\n        s = max(abs(e2 - e1), abs(e3 - e2))\n        \n        case_results = [round(e1, 8), round(e2, 8), round(e3, 8), round(s, 8)]\n        all_results.append(case_results)\n\n    # Format the final output string\n    result_str_parts = []\n    for res_list in all_results:\n        result_str_parts.append(str(res_list).replace(\" \", \"\"))\n    \n    print(f\"[{','.join(result_str_parts)}]\")\n\n\ndef get_shape_functions_derivatives(xi, eta):\n    \"\"\"\n    Computes the derivatives of the 4-node quad shape functions w.r.t. parent coordinates.\n    Returns a 2x4 matrix dN/d(xi, eta).\n    \"\"\"\n    dN_dxi = 0.25 * np.array([-(1 - eta), (1 - eta), (1 + eta), -(1 + eta)])\n    dN_deta = 0.25 * np.array([-(1 - xi), -(1 + xi), (1 + xi), (1 - xi)])\n    return np.vstack([dN_dxi, dN_deta])\n\n\ndef compute_stiffness_matrix(coords, p, E, nu, t):\n    \"\"\"\n    Computes the element stiffness matrix for a 4-node quadrilateral element.\n\n    Args:\n        coords (np.ndarray): 4x2 array of nodal coordinates (x,y).\n        p (int): Order of Gauss-Legendre quadrature.\n        E (float): Young's modulus.\n        nu (float): Poisson's ratio.\n        t (float): Element thickness.\n\n    Returns:\n        np.ndarray: The 8x8 element stiffness matrix.\n    \"\"\"\n    # Material constitutive matrix for plane strain\n    lame_lambda = (E * nu) / ((1 + nu) * (1 - 2 * nu))\n    lame_mu = E / (2 * (1 + nu))\n    C = np.array([\n        [lame_lambda + 2 * lame_mu, lame_lambda, 0],\n        [lame_lambda, lame_lambda + 2 * lame_mu, 0],\n        [0, 0, lame_mu]\n    ])\n\n    k_e = np.zeros((8, 8))\n    \n    # Get Gauss points and weights\n    gauss_points, gauss_weights = np.polynomial.legendre.leggauss(p)\n\n    # Loop over Gauss points for numerical integration\n    for i in range(p):\n        xi = gauss_points[i]\n        w_xi = gauss_weights[i]\n        for j in range(p):\n            eta = gauss_points[j]\n            w_eta = gauss_weights[j]\n\n            # Derivatives of shape functions w.r.t. parent coordinates (xi, eta)\n            dN_dxi_eta = get_shape_functions_derivatives(xi, eta)  # 2x4 matrix\n\n            # Jacobian matrix\n            J = dN_dxi_eta @ coords  # 2x2 matrix\n            det_J = np.linalg.det(J)\n            if det_J = 0:\n                raise ValueError(\"Jacobian determinant is non-positive. Check element node ordering or geometry.\")\n            \n            inv_J = np.linalg.inv(J)\n\n            # Derivatives of shape functions w.r.t. physical coordinates (x, y)\n            dN_dxy = inv_J @ dN_dxi_eta  # 2x4 matrix\n\n            # Strain-displacement matrix B (3x8)\n            B = np.zeros((3, 8))\n            for k in range(4):\n                B[0, 2 * k] = dN_dxy[0, k]\n                B[1, 2 * k + 1] = dN_dxy[1, k]\n                B[2, 2 * k] = dN_dxy[1, k]\n                B[2, 2 * k + 1] = dN_dxy[0, k]\n\n            # Accumulate stiffness matrix\n            k_e += B.T @ C @ B * det_J * w_xi * w_eta * t\n\n    return k_e\n\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}