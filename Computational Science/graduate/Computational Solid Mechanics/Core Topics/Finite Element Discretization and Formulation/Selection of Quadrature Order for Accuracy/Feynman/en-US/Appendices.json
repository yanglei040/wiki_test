{
    "hands_on_practices": [
        {
            "introduction": "The first step in mastering quadrature selection is performing an *a priori* analysis. This technique involves determining the polynomial degree of the function to be integrated and then applying the known exactness properties of a quadrature rule to find the minimum order required. This exercise  provides a perfect entry point, guiding you through the analysis of a load vector integral where the contributions from shape functions, an affine coordinate map, and an external body force are clearly defined.",
            "id": "3598711",
            "problem": "Consider a Two-Dimensional (2D) quadrilateral finite element of order $p$, denoted as a $Q_{p}$ element within the Finite Element Method (FEM). The element is mapped affinely from the bi-unit square reference domain $\\hat{\\Omega} = [-1,1] \\times [-1,1]$ with parametric coordinates $(\\xi,\\eta)$ to the physical domain $\\Omega_{e}$ by\n$$\nx(\\xi,\\eta) = a_{0} + a_{1}\\,\\xi + a_{2}\\,\\eta, \\quad y(\\xi,\\eta) = b_{0} + b_{1}\\,\\xi + b_{2}\\,\\eta,\n$$\nwhere $a_{0}, a_{1}, a_{2}, b_{0}, b_{1}, b_{2}$ are constants. This mapping has a constant Jacobian determinant $J$.\n\nLet the body force per unit volume be a quadratic polynomial in the physical coordinates $(x,y)$,\n$$\nb(x,y) = c_{0} + c_{1}\\,x + c_{2}\\,y + c_{3}\\,x^{2} + c_{4}\\,x\\,y + c_{5}\\,y^{2},\n$$\nwhere $c_{0}, c_{1}, c_{2}, c_{3}, c_{4}, c_{5}$ are constants. Consider a single scalar degree of freedom associated with the nodal shape function $N_{i}(\\xi,\\eta)$ of the $Q_{p}$ element, which is the tensor product of one-dimensional Lagrange polynomials of degree $p$ in $\\xi$ and in $\\eta$.\n\nThe elemental load vector component associated with node $i$ is\n$$\nf_{i} = \\int_{\\Omega_{e}} N_{i}(x,y)\\,b(x,y)\\,\\mathrm{d}\\Omega = \\int_{\\hat{\\Omega}} N_{i}(\\xi,\\eta)\\,b\\big(x(\\xi,\\eta),y(\\xi,\\eta)\\big)\\,J\\,\\mathrm{d}\\xi\\,\\mathrm{d}\\eta.\n$$\nAssume the integral is to be evaluated using a tensor-product Gauss–Legendre quadrature with $n$ points in each of the $\\xi$ and $\\eta$ directions.\n\nUsing only foundational properties of polynomial degree under affine maps and the exactness of Gauss–Legendre quadrature on polynomials, determine the minimal number $n$ of Gauss–Legendre points per direction required to integrate $f_{i}$ exactly for any quadratic body force $b(x,y)$ and any $Q_{p}$ element with affine mapping. Express your final answer as a closed-form analytic expression in terms of $p$. No numerical evaluation is required, and no rounding is needed. Provide the expression for $n$.",
            "solution": "The problem requires determining the minimal number of Gauss-Legendre quadrature points, $n$, per direction required for the exact numerical integration of an elemental load vector component, $f_i$. The integral to be evaluated is given by:\n$$\nf_{i} = \\int_{\\hat{\\Omega}} N_{i}(\\xi,\\eta)\\,b\\big(x(\\xi,\\eta),y(\\xi,\\eta)\\big)\\,J\\,\\mathrm{d}\\xi\\,\\mathrm{d}\\eta\n$$\nwhere the integration domain is the bi-unit square $\\hat{\\Omega} = [-1,1] \\times [-1,1]$. The integration is performed using a tensor-product Gauss-Legendre quadrature scheme with $n$ points in the $\\xi$-direction and $n$ points in the $\\eta$-direction.\n\nThe fundamental property of a one-dimensional $n$-point Gauss-Legendre quadrature rule is that it can exactly integrate any polynomial of degree up to $2n-1$. For a tensor-product rule, this property applies independently in each direction. Therefore, to find the minimum required $n$, we must first determine the maximum degree of the integrand polynomial with respect to $\\xi$ and $\\eta$ individually.\n\nLet the integrand be denoted by $g(\\xi,\\eta) = N_{i}(\\xi,\\eta)\\,b\\big(x(\\xi,\\eta),y(\\xi,\\eta)\\big)\\,J$. We will analyze the polynomial degree of each term in this product. We use $P_{k}(z)$ to denote a polynomial of degree $k$ in the variable $z$.\n\n1.  **Shape Function $N_{i}(\\xi,\\eta)$**: The element is a $Q_{p}$ quadrilateral element. Its shape functions $N_{i}(\\xi,\\eta)$ are constructed as a tensor product of one-dimensional Lagrange polynomials of degree $p$. This means that $N_{i}(\\xi,\\eta)$ is a polynomial of degree $p$ in $\\xi$ for any fixed $\\eta$, and a polynomial of degree $p$ in $\\eta$ for any fixed $\\xi$.\n\n2.  **Coordinate Mapping $x(\\xi,\\eta)$ and $y(\\xi,\\eta)$**: The mapping from the reference domain $(\\xi,\\eta)$ to the physical domain $(x,y)$ is affine, given by:\n    $$\n    x(\\xi,\\eta) = a_{0} + a_{1}\\,\\xi + a_{2}\\,\\eta\n    $$\n    $$\n    y(\\xi,\\eta) = b_{0} + b_{1}\\,\\xi + b_{2}\\,\\eta\n    $$\n    From these definitions, $x(\\xi,\\eta)$ is a polynomial of degree $1$ in $\\xi$ and degree $1$ in $\\eta$. Similarly, $y(\\xi,\\eta)$ is a polynomial of degree $1$ in $\\xi$ and degree $1$ in $\\eta$.\n\n3.  **Body Force $b(x,y)$ after Mapping**: The body force $b(x,y)$ is a quadratic polynomial in the physical coordinates $(x,y)$:\n    $$\n    b(x,y) = c_{0} + c_{1}\\,x + c_{2}\\,y + c_{3}\\,x^{2} + c_{4}\\,x\\,y + c_{5}\\,y^{2}\n    $$\n    To find the degree of $b$ in terms of the reference coordinates $(\\xi,\\eta)$, we substitute the mapping functions into this expression. The degree of the composite function $b(x(\\xi,\\eta), y(\\xi,\\eta))$ is determined by the highest-degree terms, which are $x^2$, $xy$, and $y^2$. Since $x$ and $y$ are polynomials of degree $1$ in $\\xi$ and $\\eta$, their squares ($x^2$, $y^2$) and product ($xy$) will be polynomials of at most degree $2$ in $\\xi$ and at most degree $2$ in $\\eta$. For example, the term $x^2$ becomes $(a_0 + a_1\\xi + a_2\\eta)^2 = a_1^2 \\xi^2 + \\dots$, which is of degree $2$ in $\\xi$. The same logic applies to all quadratic terms and both variables. Therefore, $b(x(\\xi,\\eta), y(\\xi,\\eta))$ is a polynomial of degree at most $2$ in $\\xi$ and at most $2$ in $\\eta$.\n\n4.  **Jacobian Determinant $J$**: The problem statement specifies that the mapping is affine, which results in a constant Jacobian determinant, $J$. A constant is a polynomial of degree $0$.\n\nNow, we determine the degree of the complete integrand $g(\\xi,\\eta)$. Since the degree of a product of polynomials is the sum of the degrees of the factors, we can find the degree of $g(\\xi,\\eta)$ in each variable separately.\n\n-   The degree of $g(\\xi,\\eta)$ in the variable $\\xi$ is the sum of the degrees of its factors in $\\xi$:\n    $$\n    \\deg_{\\xi}(g) = \\deg_{\\xi}(N_i) + \\deg_{\\xi}(b) + \\deg_{\\xi}(J) = p + 2 + 0 = p+2\n    $$\n-   Similarly, the degree of $g(\\xi,\\eta)$ in the variable $\\eta$ is:\n    $$\n    \\deg_{\\eta}(g) = \\deg_{\\eta}(N_i) + \\deg_{\\eta}(b) + \\deg_{\\eta}(J) = p + 2 + 0 = p+2\n    $$\n\nThe integrand is a polynomial of degree $p+2$ in $\\xi$ and $p+2$ in $\\eta$. To integrate this polynomial exactly using an $n$-point Gauss-Legendre quadrature rule, the rule must be exact for polynomials of degree up to $p+2$. The condition for exactness is:\n$$\n2n - 1 \\ge \\deg(\\text{polynomial})\n$$\nApplying this condition for our integrand in either the $\\xi$ or $\\eta$ direction, we have:\n$$\n2n - 1 \\ge p + 2\n$$\nWe must find the minimal integer $n$ that satisfies this inequality.\n$$\n2n \\ge p + 3\n$$\n$$\nn \\ge \\frac{p+3}{2}\n$$\nSince $n$ must be an integer representing the number of quadrature points, we must take the smallest integer that satisfies this condition. This is achieved by taking the ceiling of the expression on the right-hand side.\n$$\nn = \\left\\lceil \\frac{p+3}{2} \\right\\rceil\n$$\nThis is the minimal number of Gauss-Legendre points per direction required to integrate the elemental load vector component exactly. This expression is a closed-form analytic function of $p$.",
            "answer": "$$\n\\boxed{\\left\\lceil \\frac{p+3}{2} \\right\\rceil}\n$$"
        },
        {
            "introduction": "Building on the foundational skill of polynomial degree counting, this practice explores a more complex and realistic scenario in finite element analysis. In this problem , we analyze the integration of a consistent mass matrix for an isoparametric element, where the geometry mapping itself is described by higher-order polynomials. This exercise is crucial for understanding how the complexity of an element's geometry, encapsulated in the Jacobian determinant $\\det(J)$, directly impacts the required quadrature order for exact integration.",
            "id": "3598631",
            "problem": "Consider a two-dimensional isoparametric quadrilateral finite element with quadratic shape functions (a $Q_2$ element), used to compute the consistent mass matrix in the Finite Element Method (FEM) for transient structural dynamics. Let the physical mapping $\\boldsymbol{x}(\\xi,\\eta)$ from the bi-unit parent square $[-1,1]\\times[-1,1]$ to the physical element be defined by the same quadratic shape functions as the field interpolation, so that $\\boldsymbol{x}(\\xi,\\eta)$ is biquadratic in the parent coordinates $\\xi$ and $\\eta$. Assume a constant mass density $\\rho$ and a unit thickness so that the consistent element mass matrix entries are given by\n$$\nM_{ij}=\\int_{\\Omega_e} \\rho\\,N_i(\\boldsymbol{x})\\,N_j(\\boldsymbol{x})\\,\\mathrm{d}\\Omega\n=\\int_{-1}^{1}\\int_{-1}^{1} \\rho\\,N_i(\\xi,\\eta)\\,N_j(\\xi,\\eta)\\,\\det J(\\xi,\\eta)\\,\\mathrm{d}\\xi\\,\\mathrm{d}\\eta,\n$$\nwhere $N_i(\\xi,\\eta)$ and $N_j(\\xi,\\eta)$ are the biquadratic shape functions on the parent domain and $\\det J(\\xi,\\eta)$ is the determinant of the Jacobian matrix of the isoparametric mapping. You are to select a tensor-product Gauss–Legendre quadrature with $n$ points per direction to integrate the above exactly.\n\nStarting only from (i) the definition of the consistent mass integrand on the parent domain as $N_i(\\xi,\\eta)\\,N_j(\\xi,\\eta)\\,\\det J(\\xi,\\eta)$, (ii) the fact that a $Q_2$ shape function is quadratic in each parent coordinate, (iii) the chain rule characterization of the Jacobian entries as first derivatives of the mapping, and (iv) the well-tested exactness property of the one-dimensional $n$-point Gauss–Legendre rule for polynomials up to degree $2n-1$, determine the highest polynomial degree in each parent coordinate $(\\xi,\\eta)$ of the integrand $N_i(\\xi,\\eta)\\,N_j(\\xi,\\eta)\\,\\det J(\\xi,\\eta)$, and from it choose the minimal integer $n$ such that the tensor-product $n\\times n$ Gauss–Legendre rule is exact for this integrand over $[-1,1]\\times[-1,1]$.\n\nProvide only the minimal integer $n$ as your final answer. No rounding is required.",
            "solution": "The user has provided a valid, well-posed problem statement from the field of computational solid mechanics. The objective is to determine the minimum number of quadrature points, $n$, for a tensor-product Gauss-Legendre rule to exactly integrate the consistent mass matrix for a biquadratic ($Q_2$) isoparametric element.\n\nThe integral for an entry of the consistent mass matrix, evaluated over the parent domain, is given by:\n$$\nM_{ij} = \\int_{-1}^{1}\\int_{-1}^{1} \\rho\\,N_i(\\xi,\\eta)\\,N_j(\\xi,\\eta)\\,\\det J(\\xi,\\eta)\\,\\mathrm{d}\\xi\\,\\mathrm{d}\\eta\n$$\nThe mass density $\\rho$ is assumed constant and thus does not affect the polynomial degree of the integrand. The integrand function is $I(\\xi, \\eta) = N_i(\\xi,\\eta)\\,N_j(\\xi,\\eta)\\,\\det J(\\xi,\\eta)$.\n\nA one-dimensional $n$-point Gauss-Legendre quadrature rule exactly integrates any polynomial of degree up to $2n-1$. For a two-dimensional tensor-product rule with $n$ points in each direction $(\\xi, \\eta)$, the integration is exact if the integrand is a polynomial of degree at most $2n-1$ in $\\xi$ and at most $2n-1$ in $\\eta$ separately. Our task is therefore to determine the maximum polynomial degree of $I(\\xi, \\eta)$ with respect to $\\xi$ and $\\eta$. Let $P_\\xi(f)$ and $P_\\eta(f)$ denote the polynomial degree of a function $f(\\xi,\\eta)$ in the variables $\\xi$ and $\\eta$, respectively.\n\n1.  **Polynomial Degree of the Shape Function Product $N_i(\\xi,\\eta)\\,N_j(\\xi,\\eta)$**\n    The problem states that the element is a $Q_2$ element, meaning its shape functions $N_k(\\xi,\\eta)$ are biquadratic. A biquadratic function is a polynomial of degree $2$ in each variable, $\\xi$ and $\\eta$. Therefore, for any shape function $N_k(\\xi,\\eta)$:\n    $$\n    P_\\xi(N_k) = 2 \\quad \\text{and} \\quad P_\\eta(N_k) = 2\n    $$\n    The product of two such shape functions, $N_i(\\xi,\\eta)N_j(\\xi,\\eta)$, will have a degree that is the sum of the degrees of the individual functions:\n    $$\n    P_\\xi(N_i N_j) = P_\\xi(N_i) + P_\\xi(N_j) = 2 + 2 = 4\n    $$\n    $$\n    P_\\eta(N_i N_j) = P_\\eta(N_i) + P_\\eta(N_j) = 2 + 2 = 4\n    $$\n\n2.  **Polynomial Degree of the Jacobian Determinant $\\det J(\\xi,\\eta)$**\n    The mapping from parent to physical coordinates is isoparametric, defined by the same shape functions:\n    $$\n    \\boldsymbol{x}(\\xi,\\eta) = \\begin{pmatrix} x(\\xi,\\eta) \\\\ y(\\xi,\\eta) \\end{pmatrix} = \\sum_{k=1}^{9} \\begin{pmatrix} x_k \\\\ y_k \\end{pmatrix} N_k(\\xi,\\eta)\n    $$\n    Since $N_k(\\xi,\\eta)$ are biquadratic, the mapping functions $x(\\xi,\\eta)$ and $y(\\xi,\\eta)$ are also biquadratic polynomials in $\\xi$ and $\\eta$.\n    $$\n    P_\\xi(x) = 2, \\quad P_\\eta(x) = 2\n    $$\n    $$\n    P_\\xi(y) = 2, \\quad P_\\eta(y) = 2\n    $$\n    The Jacobian matrix $J$ contains the partial derivatives of the mapping:\n    $$\n    J(\\xi,\\eta) = \\begin{pmatrix} \\frac{\\partial x}{\\partial \\xi} & \\frac{\\partial y}{\\partial \\xi} \\\\ \\frac{\\partial x}{\\partial \\eta} & \\frac{\\partial y}{\\partial \\eta} \\end{pmatrix}\n    $$\n    We determine the polynomial degrees of each entry. Differentiating with respect to a variable reduces its polynomial degree by $1$.\n    -   $P_\\xi\\left(\\frac{\\partial x}{\\partial \\xi}\\right) = P_\\xi(x) - 1 = 2-1 = 1$; \\quad $P_\\eta\\left(\\frac{\\partial x}{\\partial \\xi}\\right) = P_\\eta(x) = 2$.\n    -   $P_\\xi\\left(\\frac{\\partial y}{\\partial \\xi}\\right) = P_\\xi(y) - 1 = 2-1 = 1$; \\quad $P_\\eta\\left(\\frac{\\partial y}{\\partial \\xi}\\right) = P_\\eta(y) = 2$.\n    -   $P_\\xi\\left(\\frac{\\partial x}{\\partial \\eta}\\right) = P_\\xi(x) = 2$; \\quad $P_\\eta\\left(\\frac{\\partial x}{\\partial \\eta}\\right) = P_\\eta(x) - 1 = 2-1 = 1$.\n    -   $P_\\xi\\left(\\frac{\\partial y}{\\partial \\eta}\\right) = P_\\xi(y) = 2$; \\quad $P_\\eta\\left(\\frac{\\partial y}{\\partial \\eta}\\right) = P_\\eta(y) - 1 = 2-1 = 1$.\n\n    The determinant of the Jacobian is $\\det J = \\frac{\\partial x}{\\partial \\xi}\\frac{\\partial y}{\\partial \\eta} - \\frac{\\partial y}{\\partial \\xi}\\frac{\\partial x}{\\partial \\eta}$. The degree of a product of polynomials is the sum of their degrees. The degree of a sum or difference is the maximum of the degrees (assuming no cancellation of highest-order terms, which cannot be guaranteed for a general element geometry).\n    \n    Degree in $\\xi$:\n    -   $P_\\xi\\left(\\frac{\\partial x}{\\partial \\xi}\\frac{\\partial y}{\\partial \\eta}\\right) = P_\\xi\\left(\\frac{\\partial x}{\\partial \\xi}\\right) + P_\\xi\\left(\\frac{\\partial y}{\\partial \\eta}\\right) = 1 + 2 = 3$.\n    -   $P_\\xi\\left(\\frac{\\partial y}{\\partial \\xi}\\frac{\\partial x}{\\partial \\eta}\\right) = P_\\xi\\left(\\frac{\\partial y}{\\partial \\xi}\\right) + P_\\xi\\left(\\frac{\\partial x}{\\partial \\eta}\\right) = 1 + 2 = 3$.\n    Therefore, the maximum degree of $\\det J$ in $\\xi$ is $P_\\xi(\\det J) = 3$.\n\n    Degree in $\\eta$:\n    -   $P_\\eta\\left(\\frac{\\partial x}{\\partial \\xi}\\frac{\\partial y}{\\partial \\eta}\\right) = P_\\eta\\left(\\frac{\\partial x}{\\partial \\xi}\\right) + P_\\eta\\left(\\frac{\\partial y}{\\partial \\eta}\\right) = 2 + 1 = 3$.\n    -   $P_\\eta\\left(\\frac{\\partial y}{\\partial \\xi}\\frac{\\partial x}{\\partial \\eta}\\right) = P_\\eta\\left(\\frac{\\partial y}{\\partial \\xi}\\right) + P_\\eta\\left(\\frac{\\partial x}{\\partial \\eta}\\right) = 2 + 1 = 3$.\n    Therefore, the maximum degree of $\\det J$ in $\\eta$ is $P_\\eta(\\det J) = 3$.\n\n3.  **Polynomial Degree of the Complete Integrand $I(\\xi, \\eta)$**\n    We can now find the degree of the full integrand $I(\\xi, \\eta) = N_i N_j \\det J$.\n    -   Degree in $\\xi$: $P_\\xi(I) = P_\\xi(N_i N_j) + P_\\xi(\\det J) = 4 + 3 = 7$.\n    -   Degree in $\\eta$: $P_\\eta(I) = P_\\eta(N_i N_j) + P_\\eta(\\det J) = 4 + 3 = 7$.\n\n4.  **Determination of the Minimal Quadrature Order $n$**\n    The integrand is a polynomial of degree $7$ in $\\xi$ and degree $7$ in $\\eta$. To integrate a polynomial of degree $p$ exactly using a 1D Gauss-Legendre rule with $n$ points, we must satisfy the condition:\n    $$\n    2n - 1 \\ge p\n    $$\n    In our case, $p=7$ for both directions. Thus, we require:\n    $$\n    2n - 1 \\ge 7\n    $$\n    $$\n    2n \\ge 8\n    $$\n    $$\n    n \\ge 4\n    $$\n    The minimal integer value for $n$ that satisfies this condition is $n=4$. Consequently, a tensor-product quadrature rule with $4 \\times 4$ points is required to guarantee exact integration of the consistent mass matrix for a general $Q_2$ isoparametric element.",
            "answer": "$$\\boxed{4}$$"
        },
        {
            "introduction": "While *a priori* analysis is powerful for polynomial integrands, many engineering problems involve material properties or source terms that are non-polynomial or computationally expensive to analyze. For such cases, an *a posteriori* adaptive strategy is more practical. This hands-on exercise  challenges you to implement an algorithm that automatically refines the integration order based on a numerical error estimate, ensuring accuracy for complex integrands without prior analysis.",
            "id": "3598603",
            "problem": "You are tasked to design and implement an adaptive Gaussian quadrature strategy for computing element stiffness contributions in a one-dimensional linear elastic bar using the Finite Element Method (FEM). The adaptation must be based on an a posteriori integrand sampling: compute the integral with $n$ points and re-integrate with $n+1$ points to estimate an integral defect; use this defect to adapt $n$ per element until the defect falls below a prescribed tolerance $\\epsilon$.\n\nConsider a one-dimensional bar occupying the interval $x \\in [0,L]$ with total length $L$ in meters. The local element stiffness of a two-node linear element spanning $[x_a,x_b]$ is the scalar\n$$\nk_e = \\int_{x_a}^{x_b} \\frac{E(x)\\,A(x)}{L_e^2}\\,\\mathrm{d}x,\n$$\nwhere $E(x)$ is the Young's modulus in Pascals, $A(x)$ is the cross-sectional area in square meters, and $L_e = x_b - x_a$ is the element length in meters. This expression follows from the weak form of one-dimensional linear elasticity with linear shape functions, where the strain-displacement matrix for the element is constant and equal to $\\pm 1/L_e$ per node. You must evaluate $k_e$ by Gaussian-Legendre quadrature on each element, mapping the physical interval $[x_a,x_b]$ to the reference interval $\\xi \\in [-1,1]$ via the standard affine map $x(\\xi) = \\frac{x_b - x_a}{2}\\,\\xi + \\frac{x_b + x_a}{2}$ with Jacobian $J = \\frac{x_b - x_a}{2}$. The $n$-point Gaussian-Legendre quadrature approximates\n$$\nk_e^{(n)} = \\sum_{i=1}^{n} w_i \\,\\frac{E\\!\\left(x(\\xi_i)\\right)\\,A\\!\\left(x(\\xi_i)\\right)}{L_e^2}\\,J,\n$$\nwhere $\\{\\xi_i,w_i\\}_{i=1}^{n}$ are the nodes and weights on $\\xi \\in [-1,1]$.\n\nYour adaptation rule per element is:\n- Start from $n=1$.\n- Compute $k_e^{(n)}$ and $k_e^{(n+1)}$.\n- Define the a posteriori defect as $\\delta_e^{(n)} = \\left|k_e^{(n+1)} - k_e^{(n)}\\right|$ in Newton per meter ($\\mathrm{N}/\\mathrm{m}$).\n- If $\\delta_e^{(n)} \\le \\epsilon$, accept the order $n$ for that element; otherwise increment $n$ and repeat.\n- Impose a maximum order $n_{\\max}$ to avoid unbounded iteration; if the defect does not fall below $\\epsilon$ by $n=n_{\\max}$, mark the element as not meeting tolerance.\n\nImplement this adaptive selection for the following test suite. For each test case, the bar length $L$ (in meters), the partition of the domain into nodes $\\{x_0,\\dots,x_m\\}$ (in meters), field functions $E(x)$ (in Pascals) and $A(x)$ (in square meters), the tolerance $\\epsilon$ (in Newton per meter), and the cap $n_{\\max}$ are specified. For each element $[x_j,x_{j+1}]$, you must return the selected order $n$, or $-1$ if the tolerance was not met by $n_{\\max}$.\n\nTest Suite:\n- Case $1$ (constant integrand, expected immediate acceptance):\n  - $L = 1$.\n  - Nodes: $[0, 0.25, 0.5, 0.75, 1]$.\n  - $E(x) = 210\\times 10^9$.\n  - $A(x) = 1\\times 10^{-4}$.\n  - $\\epsilon = 1\\times 10^{-6}$ $\\mathrm{N}/\\mathrm{m}$.\n  - $n_{\\max} = 10$.\n\n- Case $2$ (polynomial variation of material):\n  - $L = 1$.\n  - Nodes: $[0, \\tfrac{1}{3}, \\tfrac{2}{3}, 1]$.\n  - $E(x) = 70\\times 10^9\\left(1 + 0.5\\left(\\tfrac{x}{L}\\right)^2\\right)$.\n  - $A(x) = 2\\times 10^{-4}$.\n  - $\\epsilon = 1\\times 10^4$ $\\mathrm{N}/\\mathrm{m}$.\n  - $n_{\\max} = 10$.\n\n- Case $3$ (moderate-frequency sinusoidal modulation of material):\n  - $L = 1$.\n  - Nodes: $[0, 0.2, 0.4, 0.6, 0.8, 1]$.\n  - $E(x) = 50\\times 10^9\\left(1 + 0.1\\sin\\!\\left(20\\pi \\tfrac{x}{L}\\right)\\right)$.\n  - $A(x) = 1.5\\times 10^{-4}$.\n  - $\\epsilon = 5\\times 10^5$ $\\mathrm{N}/\\mathrm{m}$.\n  - $n_{\\max} = 10$.\n\n- Case $4$ (high-frequency sinusoidal modulation, strict tolerance to trigger cap):\n  - $L = 1$.\n  - Nodes: $[0, 0.2, 0.4, 0.6, 0.8, 1]$.\n  - $E(x) = 50\\times 10^9\\left(1 + 0.1\\sin\\!\\left(60\\pi \\tfrac{x}{L}\\right)\\right)$.\n  - $A(x) = 1.5\\times 10^{-4}$.\n  - $\\epsilon = 1\\times 10^2$ $\\mathrm{N}/\\mathrm{m}$.\n  - $n_{\\max} = 10$.\n\nYour program must implement the adaptive strategy described above for each test case and report, for each element, the selected quadrature order $n$ or $-1$ if the tolerance was not satisfied by $n_{\\max}$. The final output must be a single line containing the results for all test cases as a comma-separated list enclosed in square brackets, where each test case result is a list of integers in the order of the elements; for example, a valid output format is $[[n_{1,1},n_{1,2},\\dots],[n_{2,1},\\dots],[\\dots],[\\dots]]$ with no additional text.",
            "solution": "The user-provided problem statement is valid. It is scientifically grounded in the principles of computational solid mechanics, specifically the Finite Element Method (FEM). The problem is well-posed, providing all necessary information, definitions, and data for a unique, verifiable solution. The objective is to implement a well-defined numerical algorithm—an adaptive Gaussian quadrature scheme—to determine the appropriate integration order for calculating element stiffness contributions. All parameters and functions are clearly specified, and the test cases are structured to validate the algorithm's correctness across different integrand complexities.\n\nThe core of the problem is the numerical evaluation of the element stiffness integral:\n$$\nk_e = \\int_{x_a}^{x_b} \\frac{E(x)\\,A(x)}{L_e^2}\\,\\mathrm{d}x\n$$\nfor a one-dimensional bar element spanning the physical interval $[x_a, x_b]$. Here, $E(x)$ is Young's modulus, $A(x)$ is the cross-sectional area, and $L_e = x_b - x_a$ is the element length.\n\nTo perform the numerical integration, we use Gaussian-Legendre quadrature. This requires mapping the physical interval $[x_a, x_b]$ to a canonical reference interval $\\xi \\in [-1, 1]$. The standard affine mapping is:\n$$\nx(\\xi) = \\frac{x_b - x_a}{2}\\,\\xi + \\frac{x_b + x_a}{2}\n$$\nThe differential element transforms as $\\mathrm{d}x = J\\,\\mathrm{d}\\xi$, where the Jacobian $J$ is a constant for this mapping:\n$$\nJ = \\frac{\\mathrm{d}x}{\\mathrm{d}\\xi} = \\frac{x_b - x_a}{2} = \\frac{L_e}{2}\n$$\nSubstituting the mapping into the integral for $k_e$ yields:\n$$\nk_e = \\int_{-1}^{1} \\frac{E(x(\\xi))\\,A(x(\\xi))}{L_e^2}\\,J\\,\\mathrm{d}\\xi\n$$\nAn $n$-point Gaussian-Legendre quadrature rule approximates this integral as a weighted sum:\n$$\nk_e^{(n)} \\approx \\sum_{i=1}^{n} w_i \\, \\left( \\frac{E(x(\\xi_i))\\,A(x(\\xi_i))}{L_e^2}\\,J \\right)\n$$\nwhere $\\{\\xi_i, w_i\\}_{i=1}^{n}$ are the quadrature nodes and weights on the reference interval $[-1, 1]$. These nodes and weights are obtained from the roots of the Legendre polynomial of degree $n$ and their corresponding weight functions.\n\nThe adaptive strategy is based on an a posteriori error estimate. We iteratively increase the quadrature order $n$ until the change in the computed integral value becomes negligible. The procedure for each element is as follows:\n$1$. Initialize the integration order, $n=1$.\n$2$. Enter a loop that continues as long as $n \\le n_{\\max}$.\n$3$. In each iteration, compute the stiffness using both $n$ and $n+1$ points: $k_e^{(n)}$ and $k_e^{(n+1)}$.\n$4$. Calculate the absolute difference, which serves as an estimate of the integration error (the defect): $\\delta_e^{(n)} = |k_e^{(n+1)} - k_e^{(n)}|$.\n$5$. Compare the defect to the specified tolerance $\\epsilon$. If $\\delta_e^{(n)} \\le \\epsilon$, the integral has converged sufficiently. The order $n$ is accepted, and the process for this element terminates.\n$6$. If the defect is larger than the tolerance, $\\delta_e^{(n)} > \\epsilon$, we increment the order, $n \\to n+1$, and repeat the process.\n$7$. If the loop completes without the defect satisfying the tolerance (i.e., the condition is not met even when testing the defect for $n=n_{\\max}$), the element is flagged as not meeting the tolerance by returning an order of $-1$.\n\nThis algorithm will be implemented in Python. We will use the `scipy.special.roots_legendre` function to obtain the required Gaussian-Legendre nodes and weights. The logic will be encapsulated in a a function that processes each test case by iterating through its constituent elements and applying the adaptive quadrature scheme to each one.\n\nFor example, in Case $1$, the integrand $E(x)A(x)$ is constant. Gaussian quadrature with $n=1$ is sufficient to integrate any constant function exactly (as $\\sum w_i = 2$, the integral of a constant $C$ over $[-1, 1]$ is $\\int C d\\xi = 2C$, and the 1-point rule gives $w_1 C(\\xi_1) = 2C(0)$). Thus, $k_e^{(1)} = k_e^{(2)}$, the defect $\\delta_e^{(1)}$ will be zero, and the algorithm will correctly choose $n=1$.\n\nIn Case $2$, the integrand is a quadratic polynomial. An $n$-point Gaussian rule integrates polynomials of degree up to $2n-1$ exactly. To integrate a quadratic (degree $2$), we require $2n-1 \\ge 2$, meaning $n \\ge 1.5$. Therefore, $n=2$ is the lowest order that yields the exact result. The algorithm will find that $k_e^{(1)} \\neq k_e^{(2)}$, but $k_e^{(2)} = k_e^{(3)}$ (since both are exact), causing the defect $\\delta_e^{(2)}$ to be zero and the order $n=2$ to be selected.\n\nCases $3$ and $4$ involve non-polynomial, oscillatory integrands, which test the robustness of the adaptive scheme under more challenging conditions.",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import roots_legendre\n\ndef solve():\n    \"\"\"\n    Designs and implements an adaptive Gaussian quadrature strategy for computing\n    1D FEM element stiffness contributions.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"L\": 1.0,\n            \"nodes\": [0, 0.25, 0.5, 0.75, 1.0],\n            \"E_func\": lambda x: 210e9,\n            \"A_func\": lambda x: 1e-4,\n            \"epsilon\": 1e-6,\n            \"n_max\": 10,\n        },\n        {\n            \"L\": 1.0,\n            \"nodes\": [0, 1/3, 2/3, 1.0],\n            \"E_func\": lambda x, L=1.0: 70e9 * (1 + 0.5 * (x / L)**2),\n            \"A_func\": lambda x: 2e-4,\n            \"epsilon\": 1e4,\n            \"n_max\": 10,\n        },\n        {\n            \"L\": 1.0,\n            \"nodes\": [0, 0.2, 0.4, 0.6, 0.8, 1.0],\n            \"E_func\": lambda x, L=1.0: 50e9 * (1 + 0.1 * np.sin(20 * np.pi * x / L)),\n            \"A_func\": lambda x: 1.5e-4,\n            \"epsilon\": 5e5,\n            \"n_max\": 10,\n        },\n        {\n            \"L\": 1.0,\n            \"nodes\": [0, 0.2, 0.4, 0.6, 0.8, 1.0],\n            \"E_func\": lambda x, L=1.0: 50e9 * (1 + 0.1 * np.sin(60 * np.pi * x / L)),\n            \"A_func\": lambda x: 1.5e-4,\n            \"epsilon\": 1e2,\n            \"n_max\": 10,\n        },\n    ]\n\n    def compute_ke(E_func, A_func, xa, xb, order):\n        \"\"\"Computes element stiffness k_e using n-point Gaussian quadrature.\"\"\"\n        Le = xb - xa\n        if Le == 0.0:\n            return 0.0\n        \n        jacobian = Le / 2.0\n        \n        # Get Gaussian-Legendre nodes and weights for the reference interval [-1, 1]\n        xi_nodes, weights = roots_legendre(order)\n        \n        # Map nodes from [-1, 1] to the physical interval [xa, xb]\n        x_at_nodes = jacobian * xi_nodes + (xa + xb) / 2.0\n        \n        # Evaluate the product E(x)A(x) at the physical nodes\n        integrand_product = E_func(x_at_nodes) * A_func(x_at_nodes)\n        \n        # Perform the quadrature sum\n        integral_on_ref = np.sum(weights * integrand_product)\n        \n        # Calculate k_e using the integral and geometric properties\n        k_e = integral_on_ref * jacobian / (Le**2)\n        \n        return k_e\n\n    all_results = []\n    for case in test_cases:\n        nodes = case[\"nodes\"]\n        E_func = case[\"E_func\"]\n        A_func = case[\"A_func\"]\n        epsilon = case[\"epsilon\"]\n        n_max = case[\"n_max\"]\n        \n        case_results = []\n        for i in range(len(nodes) - 1):\n            xa, xb = nodes[i], nodes[i+1]\n            \n            n = 1\n            selected_order = -1\n            \n            while n = n_max:\n                k_n = compute_ke(E_func, A_func, xa, xb, n)\n                k_n_plus_1 = compute_ke(E_func, A_func, xa, xb, n + 1)\n                \n                defect = np.abs(k_n_plus_1 - k_n)\n                \n                if defect = epsilon:\n                    selected_order = n\n                    break\n                \n                n += 1\n            \n            case_results.append(selected_order)\n        \n        all_results.append(case_results)\n    \n    # Format the final output string to match the required format precisely.\n    print(str(all_results).replace(\" \", \"\"))\n\nsolve()\n```"
        }
    ]
}