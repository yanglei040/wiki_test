{
    "hands_on_practices": [
        {
            "introduction": "掌握静态凝聚的最好方法莫过于亲手实践。本练习旨在引导您完成一个基本的一维杆件结构的完整分析流程，该结构被划分为两个子结构。您将从第一性原理出发，为分布载荷推导一致的节点力向量，然后执行静态凝聚以消除内部自由度，最终求解界面位移。通过这个具体计算 ，您将清晰地看到抽象的矩阵运算如何应用于实际问题，并理解将大问题分解、求解和重组的核心思想。",
            "id": "2562927",
            "problem": "一根与全局$x$轴对齐的直棱柱一维杆被分解为两个子结构$\\mathcal{A}$和$\\mathcal{B}$，它们通过一个单一的界面节点$I$（节点$2$）连接。子结构$\\mathcal{A}$由两个线性的双节点轴向单元组成，连接节点$0$–$1$和$1$–$2$，具有统一的轴向刚度$E A = 2.0 \\times 10^{5}\\,\\mathrm{N}$，单元长度分别为$L_{01} = 1\\,\\mathrm{m}$和$L_{12} = 1\\,\\mathrm{m}$。节点$0$被固定，即$u_{0} = 0$。一个均布轴向体力密度$b_{12} = 1000\\,\\mathrm{N/m}$沿单元$(1$–$2)$作用于$x$轴正方向；单元$(0$–$1)$无载荷。子结构$\\mathcal{B}$由两个线性的双节点轴向单元组成，连接节点$2$–$3$和$3$–$4$，轴向刚度分别为$E A = 1.0 \\times 10^{4}\\,\\mathrm{N}$，长度分别为$L_{23} = 2\\,\\mathrm{m}$和$L_{34} = 1\\,\\mathrm{m}$。一个均布轴向体力密度$b_{23} = 500\\,\\mathrm{N/m}$沿单元$(2$–$3)$作用于$x$轴正方向。在节点$4$处，施加了一个外部节点牵引力$T_{4} = 2000\\,\\mathrm{N}$，方向为$x$轴正方向。无其他载荷作用。\n\n从虚功原理和双节点轴向单元的线性形函数定义出发，推导分布体力的等效单元载荷向量，组装子结构平衡方程，并执行静力凝聚（子结构法）以消除每个子结构内的所有内部自由度，从而只剩下界面位移$u_{2}$。然后，组装简化的全局界面方程并求解界面位移$u_{2}$。\n\n最终结果$u_{2}$以毫米表示，并四舍五入到四位有效数字。",
            "solution": "该问题具有科学依据，提法恰当且自成体系。所有必需的数据、边界条件和材料属性均已提供。要求使用虚功原理、一致载荷和静力凝聚是有限元法中的标准有效步骤。因此，该问题是有效的，并将提供解答。\n\n分析从线性双节点轴向单元的基本原理开始。长度为$L_e$的单元内的轴向位移场$u(x)$是通过线性形函数$N_1(x)$和$N_2(x)$从节点位移$u_1$和$u_2$插值得到的：\n$$u(x) = N_1(x) u_1 + N_2(x) u_2 = \\mathbf{N}(x) \\mathbf{d}^{(e)}$$\n在单元范围从$x=0$到$x=L_e$的局部坐标系中，形函数为：\n$$N_1(x) = 1 - \\frac{x}{L_e} \\quad , \\quad N_2(x) = \\frac{x}{L_e}$$\n单元刚度矩阵$\\mathbf{k}^{(e)}$由应变能推导得出，其表达式为：\n$$\\mathbf{k}^{(e)} = \\frac{EA}{L_e} \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix}$$\n\n对于分布体力$b(x)$（单位长度上的力），一致单元载荷向量$\\mathbf{f}^{(e)}$由虚功原理推导得出。体力所做的虚功为：\n$$\\delta W_{\\text{ext}} = \\int_{0}^{L_e} \\delta u(x) b(x) dx$$\n代入插值得到的虚位移$\\delta u(x) = \\mathbf{N}(x) \\delta\\mathbf{d}^{(e)}$：\n$$\\delta W_{\\text{ext}} = \\int_{0}^{L_e} (\\mathbf{N}(x) \\delta\\mathbf{d}^{(e)})^T b(x) dx = (\\delta\\mathbf{d}^{(e)})^T \\int_{0}^{L_e} \\mathbf{N}(x)^T b(x) dx$$\n由于$\\delta W_{\\text{ext}} = (\\delta\\mathbf{d}^{(e)})^T \\mathbf{f}^{(e)}$，一致载荷向量为：\n$$\\mathbf{f}^{(e)} = \\int_{0}^{L_e} \\mathbf{N}(x)^T b(x) dx$$\n对于均布体力$b$，积分为：\n$$\\mathbf{f}^{(e)} = b \\int_{0}^{L_e} \\begin{pmatrix} 1 - x/L_e \\\\ x/L_e \\end{pmatrix} dx = b \\left[ \\begin{matrix} x - \\frac{x^2}{2L_e} \\\\ \\frac{x^2}{2L_e} \\end{matrix} \\right]_0^{L_e} = b \\begin{pmatrix} L_e - \\frac{L_e^2}{2L_e} \\\\ \\frac{L_e^2}{2L_e} \\end{pmatrix} = \\frac{bL_e}{2} \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}$$\n这意味着总载荷$bL_e$被平均分配到两个节点上。\n\n现在，我们分析每个子结构。\n\n**子结构 $\\mathcal{A}$ (节点 $0, 1, 2$)**\n该子结构由单元 $(0-1)$ 和 $(1-2)$ 组成。\n单元 $(0-1)$: $L_{01} = 1\\,\\mathrm{m}$, $EA = 2.0 \\times 10^5\\,\\mathrm{N}$。无体力。\n$$\\mathbf{k}^{(0-1)} = \\frac{2.0 \\times 10^5}{1} \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix}_{u_0, u_1} \\quad ; \\quad \\mathbf{f}^{(0-1)} = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}$$\n单元 $(1-2)$: $L_{12} = 1\\,\\mathrm{m}$, $EA = 2.0 \\times 10^5\\,\\mathrm{N}$, $b_{12} = 1000\\,\\mathrm{N/m}$。\n$$\\mathbf{k}^{(1-2)} = \\frac{2.0 \\times 10^5}{1} \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix}_{u_1, u_2} \\quad ; \\quad \\mathbf{f}^{(1-2)} = \\frac{1000 \\times 1}{2} \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}_{u_1, u_2} = \\begin{pmatrix} 500 \\\\ 500 \\end{pmatrix}$$\n节点 $(0, 1, 2)$ 的组装系统为 $\\mathbf{K}^\\mathcal{A} \\mathbf{u}^\\mathcal{A} = \\mathbf{F}^\\mathcal{A}$:\n$$\\begin{pmatrix} k^{(0-1)}_{11} & k^{(0-1)}_{12} & 0 \\\\ k^{(0-1)}_{21} & k^{(0-1)}_{22}+k^{(1-2)}_{11} & k^{(1-2)}_{12} \\\\ 0 & k^{(1-2)}_{21} & k^{(1-2)}_{22} \\end{pmatrix} \\begin{pmatrix} u_0 \\\\ u_1 \\\\ u_2 \\end{pmatrix} = \\begin{pmatrix} f^{(0-1)}_1 \\\\ f^{(0-1)}_2 + f^{(1-2)}_1 \\\\ f^{(1-2)}_2 \\end{pmatrix}$$\n$$2.0 \\times 10^5 \\begin{pmatrix} 1 & -1 & 0 \\\\ -1 & 2 & -1 \\\\ 0 & -1 & 1 \\end{pmatrix} \\begin{pmatrix} u_0 \\\\ u_1 \\\\ u_2 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 500 \\\\ 500 \\end{pmatrix}$$\n应用边界条件 $u_0=0$，自由度 $(u_1, u_2)$ 的系统变为：\n$$2.0 \\times 10^5 \\begin{pmatrix} 2 & -1 \\\\ -1 & 1 \\end{pmatrix} \\begin{pmatrix} u_1 \\\\ u_2 \\end{pmatrix} = \\begin{pmatrix} 500 \\\\ 500 \\end{pmatrix}$$\n为执行静力凝聚，我们将系统划分为内部自由度（$i = \\{1\\}$）和界面自由度（$b = \\{2\\}$）：\n$$\\begin{pmatrix} \\mathbf{K}_{ii} & \\mathbf{K}_{ib} \\\\ \\mathbf{K}_{bi} & \\mathbf{K}_{bb} \\end{pmatrix} \\begin{pmatrix} \\mathbf{u}_i \\\\ \\mathbf{u}_b \\end{pmatrix} = \\begin{pmatrix} \\mathbf{F}_i \\\\ \\mathbf{F}_b \\end{pmatrix}$$\n其中 $\\mathbf{K}_{ii} = 4.0 \\times 10^5$, $\\mathbf{K}_{ib} = -2.0 \\times 10^5$, $\\mathbf{K}_{bi} = -2.0 \\times 10^5$, $\\mathbf{K}_{bb} = 2.0 \\times 10^5$, $\\mathbf{F}_i = 500$, 且 $\\mathbf{F}_b = 500$。\n凝聚后的系统为 $\\mathbf{K}^*_\\mathcal{A} \\mathbf{u}_b = \\mathbf{F}^*_\\mathcal{A}$，其中：\n$\\mathbf{K}^*_\\mathcal{A} = \\mathbf{K}_{bb} - \\mathbf{K}_{bi} \\mathbf{K}_{ii}^{-1} \\mathbf{K}_{ib} = 2.0 \\times 10^5 - (-2.0 \\times 10^5)(4.0 \\times 10^5)^{-1}(-2.0 \\times 10^5) = 2.0 \\times 10^5 - \\frac{(2.0 \\times 10^5)^2}{4.0 \\times 10^5} = 2.0 \\times 10^5 - 1.0 \\times 10^5 = 1.0 \\times 10^5\\,\\mathrm{N/m}$。\n$\\mathbf{F}^*_\\mathcal{A} = \\mathbf{F}_b - \\mathbf{K}_{bi} \\mathbf{K}_{ii}^{-1} \\mathbf{F}_i = 500 - (-2.0 \\times 10^5)(4.0 \\times 10^5)^{-1}(500) = 500 - (-\\frac{1}{2})(500) = 500 + 250 = 750\\,\\mathrm{N}$。\n子结构 $\\mathcal{A}$ 在界面节点 $2$ 处的凝聚方程为 $1.0 \\times 10^5 u_2 = 750$。\n\n**子结构 $\\mathcal{B}$ (节点 $2, 3, 4$)**\n该子结构由单元 $(2-3)$ 和 $(3-4)$ 组成。\n单元 $(2-3)$: $L_{23} = 2\\,\\mathrm{m}$, $EA = 1.0 \\times 10^4\\,\\mathrm{N}$, $b_{23} = 500\\,\\mathrm{N/m}$。\n$$\\mathbf{k}^{(2-3)} = \\frac{1.0 \\times 10^4}{2} \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix}_{u_2, u_3} = 5000 \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix} \\quad ; \\quad \\mathbf{f}^{(2-3)} = \\frac{500 \\times 2}{2} \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}_{u_2, u_3} = \\begin{pmatrix} 500 \\\\ 500 \\end{pmatrix}$$\n单元 $(3-4)$: $L_{34} = 1\\,\\mathrm{m}$, $EA = 1.0 \\times 10^4\\,\\mathrm{N}$。无体力。\n$$\\mathbf{k}^{(3-4)} = \\frac{1.0 \\times 10^4}{1} \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix}_{u_3, u_4} \\quad ; \\quad \\mathbf{f}^{(3-4)} = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}$$\n节点 $4$ 处的节点力: $T_4 = 2000\\,\\mathrm{N}$。\n节点 $(2, 3, 4)$ 的组装系统为 $\\mathbf{K}^\\mathcal{B} \\mathbf{u}^\\mathcal{B} = \\mathbf{F}^\\mathcal{B}$:\n$$\\begin{pmatrix} 5000 & -5000 & 0 \\\\ -5000 & 5000+10000 & -10000 \\\\ 0 & -10000 & 10000 \\end{pmatrix} \\begin{pmatrix} u_2 \\\\ u_3 \\\\ u_4 \\end{pmatrix} = \\begin{pmatrix} 500 \\\\ 500 \\\\ 0 \\end{pmatrix} + \\begin{pmatrix} 0 \\\\ 0 \\\\ 2000 \\end{pmatrix}$$\n$$1000 \\begin{pmatrix} 5 & -5 & 0 \\\\ -5 & 15 & -10 \\\\ 0 & -10 & 10 \\end{pmatrix} \\begin{pmatrix} u_2 \\\\ u_3 \\\\ u_4 \\end{pmatrix} = \\begin{pmatrix} 500 \\\\ 500 \\\\ 2000 \\end{pmatrix}$$\n我们凝聚掉内部自由度 $i=\\{3, 4\\}$ 以找到界面自由度 $b=\\{2\\}$ 的关系。\n$\\mathbf{K}_{bb}=5000$, $\\mathbf{K}_{bi}=\\begin{pmatrix} -5000 & 0 \\end{pmatrix}$, $\\mathbf{K}_{ib}=\\begin{pmatrix} -5000 \\\\ 0 \\end{pmatrix}$, $\\mathbf{K}_{ii}=1000\\begin{pmatrix} 15 & -10 \\\\ -10 & 10 \\end{pmatrix}$。\n$\\mathbf{F}_b = 500$, $\\mathbf{F}_i = \\begin{pmatrix} 500 \\\\ 2000 \\end{pmatrix}$。\n首先，我们求 $\\mathbf{K}_{ii}^{-1}$: $\\det(\\mathbf{K}_{ii}) = (1000)^2 (150-100) = 50 \\times 10^6$。\n$\\mathbf{K}_{ii}^{-1} = \\frac{1}{50 \\times 10^6} \\begin{pmatrix} 10000 & 10000 \\\\ 10000 & 15000 \\end{pmatrix} = \\frac{1}{5000} \\begin{pmatrix} 1 & 1 \\\\ 1 & 1.5 \\end{pmatrix}$。\n凝聚刚度为 $\\mathbf{K}^*_\\mathcal{B} = \\mathbf{K}_{bb} - \\mathbf{K}_{bi} \\mathbf{K}_{ii}^{-1} \\mathbf{K}_{ib}$。\n$\\mathbf{K}_{bi} \\mathbf{K}_{ii}^{-1} = \\begin{pmatrix} -5000 & 0 \\end{pmatrix} \\frac{1}{5000} \\begin{pmatrix} 1 & 1 \\\\ 1 & 1.5 \\end{pmatrix} = \\begin{pmatrix} -1 & -1 \\end{pmatrix}$。\n$\\mathbf{K}_{bi} \\mathbf{K}_{ii}^{-1} \\mathbf{K}_{ib} = \\begin{pmatrix} -1 & -1 \\end{pmatrix} \\begin{pmatrix} -5000 \\\\ 0 \\end{pmatrix} = 5000$。\n$\\mathbf{K}^*_\\mathcal{B} = 5000 - 5000 = 0$。这是预料之中的，因为子结构 $\\mathcal{B}$ 是无约束的，允许刚体运动。\n凝聚力为 $\\mathbf{F}^*_\\mathcal{B} = \\mathbf{F}_b - \\mathbf{K}_{bi} \\mathbf{K}_{ii}^{-1} \\mathbf{F}_i$。\n$\\mathbf{K}_{bi} \\mathbf{K}_{ii}^{-1} \\mathbf{F}_i = \\begin{pmatrix} -1 & -1 \\end{pmatrix} \\begin{pmatrix} 500 \\\\ 2000 \\end{pmatrix} = -500 - 2000 = -2500$。\n$\\mathbf{F}^*_\\mathcal{B} = 500 - (-2500) = 3000\\,\\mathrm{N}$。\n凝聚力代表施加在子结构上并传递到界面的总力。子结构 $\\mathcal{B}$ 上的外力为 $b_{23}L_{23} + T_4 = (500)(2) + 2000 = 3000\\,\\mathrm{N}$。\n\n**组装与求解**\n最后一步是在界面节点2处组装两个子结构的凝聚方程。子结构法的组装规则是 $(\\mathbf{K}^*_\\mathcal{A} + \\mathbf{K}^*_\\mathcal{B}) \\mathbf{u}_2 = \\mathbf{F}^*_\\mathcal{A} + \\mathbf{F}^*_\\mathcal{B}$。\n$$(1.0 \\times 10^5 + 0) u_2 = 750 + 3000$$\n$$1.0 \\times 10^5 u_2 = 3750$$\n求解界面位移 $u_2$:\n$$u_2 = \\frac{3750}{1.0 \\times 10^5} = 0.0375\\,\\mathrm{m}$$\n题目要求答案以毫米为单位，并四舍五入到四位有效数字。\n$$u_2 = 0.0375\\,\\mathrm{m} \\times \\frac{1000\\,\\mathrm{mm}}{1\\,\\mathrm{m}} = 37.5\\,\\mathrm{mm}$$\n四舍五入到四位有效数字得到 $37.50\\,\\mathrm{mm}$。",
            "answer": "$$\\boxed{37.50}$$"
        },
        {
            "introduction": "静态凝聚不仅是消除自由度的工具，更是一种保持能量一致性的模型降阶方法。当子结构内部包含复杂的运动约束时，例如由内部刚性连接引起的多点约束（MPC），如何正确推导其等效刚度就显得尤为重要。本练习  要求您推导一个受线性多点约束的杆件子结构的有效边界刚度。这个过程将加深您对凝聚过程物理本质的理解，表明正确的凝聚必须在系统的势能表达式中严格执行运动学约束，从而确保最终得到的等效模型在能量上是精确的。",
            "id": "3602467",
            "problem": "考虑一个用于系统级子结构分析的一维线性弹性子结构。该子结构包含标记为 $1$、$2$ 和 $3$ 的 $3$ 个节点，由 $2$ 个轴向杆单元连接：单元 $(1,2)$ 的轴向刚度为 $k_1$，单元 $(2,3)$ 的轴向刚度为 $k_2$。设节点位移为 $u_1$、$u_2$ 和 $u_3$，节点力为 $f_1$、$f_2$ 和 $f_3$。该线性系统的全局平衡由虚功原理 (PVW) 控制，对于线性弹簧，该原理可简化为线性系统 $K u = f$，其中 $K$ 是由单元刚度组装而成的全局刚度矩阵，总势能为 $\\Pi(u) = \\tfrac{1}{2} u^{\\mathsf T} K u - f^{\\mathsf T} u$。\n\n该子结构受到一个线性多点约束 (MPC)，该约束将内部节点位移 $u_2$ 与边界节点位移通过一个凸组合联系起来，\n$$u_2 = \\eta\\, u_1 + (1-\\eta)\\, u_3,$$\n其中给定参数 $0 < \\eta < 1$。物理上，此 MPC 可能源于一个内部刚性约束，该约束在保留的边界自由度之间选择了仿射插值。\n\n我们将节点 $1$ 和 $3$ 视为要保留的边界自由度，节点 $2$ 视为要消去的内部自由度。该子结构将用作一个更大型模型中的一个组件，在该模型中节点 $3$ 被固定，即 $u_3 = 0$，并在节点 $1$ 施加一个标量荷载 $f_1$，其中 $f_3$ 代表反力。定义受约束和凝聚后的子结构的有效边界刚度 $k_{\\text{eff}}$ 为\n$$k_{\\text{eff}} := \\frac{f_1}{u_1}\\quad\\text{在边界条件 }u_3=0\\text{ 下，}$$\n其中 MPC 被精确施加，且内部自由度以能量一致的方式被消去。\n\n仅从上述基本定义（轴向弹簧的线性弹性、基于 PVW 的平衡、线性运动学约束）出发，推导 $k_{\\text{eff}}$ 关于 $k_1$、$k_2$ 和 $\\eta$ 的闭式解析表达式。最终有效刚度以 $\\text{N}/\\text{m}$ 为单位表示。请以包含 $k_1$、$k_2$ 和 $\\eta$ 的单一解析表达式的形式提供最终答案。无需代入数值，也无需进行舍入。",
            "solution": "问题陈述已经过严格验证，被认为是科学上成立、适定、客观且自洽的。它提出了一个计算固体力学中的标准问题，涉及受约束子结构的静力凝聚。所有给定的数据和定义都是一致且充分的，足以推导出唯一且有意义的解。\n\n目标是求解受线性多点约束 (MPC) 的一维三节点子结构的有效刚度 $k_{\\text{eff}}$。有效刚度定义为当施加边界条件 $u_3=0$ 时，$k_{\\text{eff}} := f_1/u_1$。推导将从问题陈述中指定的势能原理出发。\n\n无约束系统的总势能由 $\\Pi(u) = \\frac{1}{2} u^{\\mathsf T} K u - f^{\\mathsf T} u$ 给出。内应变能储存在两个轴向杆单元中，由 $\\Pi_{\\text{int}}(u) = \\frac{1}{2} u^{\\mathsf T} K u$ 给出。对于这两个单元，其具体表达式为：\n$$\n\\Pi_{\\text{int}}(u) = \\frac{1}{2} k_1 (u_2 - u_1)^2 + \\frac{1}{2} k_2 (u_3 - u_2)^2\n$$\n其中 $k_1$ 和 $k_2$ 分别是单元 $(1,2)$ 和 $(2,3)$ 的轴向刚度，$u_1, u_2, u_3$ 是节点位移。\n\n系统受到一个线性运动学 MPC 约束：\n$$\nu_2 = \\eta u_1 + (1-\\eta) u_3\n$$\n其中节点 $1$ 和 $3$ 是保留的边界自由度 (DOF)，节点 $2$ 是待消去的内部自由度。参数 $\\eta$ 是给定的，满足 $0 < \\eta < 1$。\n\n为求得子结构的凝聚（或有效）属性，我们必须仅用保留的边界位移 $u_b = \\begin{pmatrix} u_1 \\\\ u_3 \\end{pmatrix}$ 来表示势能。这是一种对内部自由度 $u_2$ 的能量一致性消去。我们将 MPC 代入应变能表达式中。\n\n首先，让我们用边界自由度 $u_1$ 和 $u_3$ 来表示单元伸长量：\n第一个单元的伸长量为 $(u_2 - u_1)$：\n$$\nu_2 - u_1 = (\\eta u_1 + (1-\\eta) u_3) - u_1 = (\\eta - 1) u_1 + (1-\\eta) u_3 = (1-\\eta)(u_3 - u_1)\n$$\n第二个单元的伸长量为 $(u_3 - u_2)$：\n$$\nu_3 - u_2 = u_3 - (\\eta u_1 + (1-\\eta) u_3) = -\\eta u_1 + (1 - (1-\\eta)) u_3 = -\\eta u_1 + \\eta u_3 = \\eta(u_3 - u_1)\n$$\n注意到，MPC 迫使两个单元的伸长量都与子结构的总伸长量 $(u_3 - u_1)$ 成正比。\n\n现在，将这些表达式代回应变能方程：\n$$\n\\Pi_{\\text{int}}(u_1, u_3) = \\frac{1}{2} k_1 \\left[ (1-\\eta)(u_3 - u_1) \\right]^2 + \\frac{1}{2} k_2 \\left[ \\eta(u_3 - u_1) \\right]^2\n$$\n提取公因式 $(u_3 - u_1)^2$：\n$$\n\\Pi_{\\text{int}}(u_1, u_3) = \\frac{1}{2} \\left[ k_1 (1-\\eta)^2 + k_2 \\eta^2 \\right] (u_3 - u_1)^2\n$$\n此表达式是凝聚后子结构的应变能，完全由边界自由度 $u_1$ 和 $u_3$ 表示。该能量具有 $\\frac{1}{2} u_b^{\\mathsf{T}} K_c u_b$ 的形式，其中 $K_c$ 是 $2 \\times 2$ 的凝聚刚度矩阵。我们展开平方项以确定 $K_c$ 的分量：\n$$\n(u_3 - u_1)^2 = u_1^2 - 2u_1 u_3 + u_3^2 = \\begin{pmatrix} u_1 & u_3 \\end{pmatrix} \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix} \\begin{pmatrix} u_1 \\\\ u_3 \\end{pmatrix}\n$$\n令常数项为 $C = k_1 (1-\\eta)^2 + k_2 \\eta^2$。那么应变能为：\n$$\n\\Pi_{\\text{int}}(u_1, u_3) = \\frac{1}{2} C (u_1^2 - 2u_1 u_3 + u_3^2) = \\frac{1}{2} \\begin{pmatrix} u_1 & u_3 \\end{pmatrix} \\begin{pmatrix} C & -C \\\\ -C & C \\end{pmatrix} \\begin{pmatrix} u_1 \\\\ u_3 \\end{pmatrix}\n$$\n由此，我们确定凝聚刚度矩阵 $K_c$ 为：\n$$\nK_c = \\begin{pmatrix} k_1(1-\\eta)^2 + k_2\\eta^2 & -[k_1(1-\\eta)^2 + k_2\\eta^2] \\\\ -[k_1(1-\\eta)^2 + k_2\\eta^2] & k_1(1-\\eta)^2 + k_2\\eta^2 \\end{pmatrix}\n$$\n凝聚系统的平衡方程为 $K_c u_b = f_b$，其中 $f_b = \\begin{pmatrix} f_1 \\\\ f_3 \\end{pmatrix}$ 是作用在边界节点上的外力（假设内部节点上没有外力，即 $f_2=0$）。\n$$\n\\begin{pmatrix} K_{c,11} & K_{c,12} \\\\ K_{c,21} & K_{c,22} \\end{pmatrix} \\begin{pmatrix} u_1 \\\\ u_3 \\end{pmatrix} = \\begin{pmatrix} f_1 \\\\ f_3 \\end{pmatrix}\n$$\n我们需要在条件 $u_3=0$ 下求得 $k_{\\text{eff}} = f_1/u_1$。我们使用矩阵方程的第一行：\n$$\nK_{c,11} u_1 + K_{c,12} u_3 = f_1\n$$\n应用边界条件 $u_3=0$：\n$$\nK_{c,11} u_1 + K_{c,12} (0) = f_1 \\implies K_{c,11} u_1 = f_1\n$$\n因此，有效刚度由凝聚刚度矩阵的 $(1,1)$ 分量给出：\n$$\nk_{\\text{eff}} = \\frac{f_1}{u_1} = K_{c,11}\n$$\n代入我们找到的 $K_{c,11}$ 的表达式：\n$$\nk_{\\text{eff}} = k_1(1-\\eta)^2 + k_2\\eta^2\n$$\n这就是受约束子结构的有效刚度关于给定参数的最终闭式解析表达式。问题中提到的单位 `N/m` 是为了指明刚度的物理量纲，这与解析结果是一致的。",
            "answer": "$$\\boxed{k_1(1-\\eta)^2 + k_2\\eta^2}$$"
        },
        {
            "introduction": "静态凝聚和子结构化的真正威力在于其在模型降阶和大规模计算中的应用，特别是在处理包含大量重复组件的复杂系统时。通过预先计算这些组件（即“超单元”）的响应，我们可以在系统级分析中实现显著的计算加速。本计算实践  引导您完成一个完整的计算工作流：为一个参数化的子结构构建一个超单元库，使用插值方法来近似新参数下的超单元行为，并最终评估这种降阶模型所引入的误差。这项练习不仅提供了宝贵的编程实践，而且突显了在离线预计算成本与在线快速评估效益之间的权衡，这是现代计算工程中的一个核心概念。",
            "id": "3602488",
            "problem": "给定一个参数化的一维线弹性子结构，用作更大组合体中的超单元。该子结构是一根长度为 $L$（单位：$\\mathrm{m}$）、杨氏模量 $E$（单位：$\\mathrm{Pa}$）和横截面积 $A$（单位：$\\mathrm{m}^2$）恒定的直轴向杆。该子结构被离散化为 $m$ 个等长的双节点有限元，根据虚功原理和小应变线弹性理论，得到一个组装后的线性系统：一个对称正定的全局刚度矩阵 $K$（单位：$\\mathrm{N}/\\mathrm{m}$），它通过 $K u = f$ 将节点位移向量 $u$（单位：$\\mathrm{m}$）与力向量 $f$（单位：$\\mathrm{N}$）关联起来。长度为 $\\ell_e$ 的轴向杆的单元刚度由基本本构关系 $\\sigma = E \\varepsilon$ 和轴向平衡得到，其单元刚度矩阵与 $E A / \\ell_e$ 成正比。\n\n在子结构法中，内部自由度被消除，以定义一个凝聚的（或称为“超单元”）刚度 $S(\\theta)$，它将子结构两端的边界位移对映射到相应的边界力，其中 $\\theta = (E, A, L)$。凝聚矩阵 $S(\\theta)$ 是一个对称的 $2 \\times 2$ 矩阵，它通过组装和凝聚的有限元模型依赖于这些参数。\n\n您的任务是纯粹以计算方式实现以下步骤：\n\n1. 库的构建：\n   - 每个子结构固定 $m = 4$ 个单元。\n   - 定义参数网格：\n     - $E \\in \\{70 \\times 10^{9}, 140 \\times 10^{9}, 210 \\times 10^{9}\\}$（单位：$\\mathrm{Pa}$）。\n     - $A \\in \\{5 \\times 10^{-4}, 10^{-3}, 2 \\times 10^{-3}\\}$（单位：$\\mathrm{m}^2$）。\n     - $L \\in \\{0.5, 1.0, 2.0\\}$（单位：$\\mathrm{m}$）。\n   - 对于张量积网格上的每个三元组 $\\theta = (E, A, L)$，使用 $m$ 个等长单元组装 $m+1$ 个节点的轴向有限元模型，并通过静态凝聚内部节点来获得两个边界节点的边界凝聚刚度 $S(\\theta)$。将此超单元库制成表格。\n\n2. 插值：\n   - 对于网格凸包内的（无外插）通用参数点 $\\theta$，通过在 $(E, A, L)$ 空间中对库进行多线性插值来构建一个三线性插值 $\\tilde{S}(\\theta)$。插值逐项应用于 $2 \\times 2$ 的凝聚刚度矩阵。\n\n3. 全局组装与柔度：\n   - 考虑一个由两个此类超单元串联组装而成的一维全局结构。将左侧超单元表示为 $\\theta_1$，右侧超单元表示为 $\\theta_2$。设全局左边界节点固定，位移为零，并在全局右边界节点施加一个右端点载荷 $P = 10^{5}$（单位：$\\mathrm{N}$）。每个节点有一个标量自由度。在共享的界面节点处，使用标准有限元组装方法，从两个凝聚的 $2 \\times 2$ 超单元矩阵组装出 $3 \\times 3$ 的全局刚度矩阵。施加左侧狄利克雷边界条件后，求解得到的简化系统，计算全局位移向量。设全局柔度为 $c = f^{\\mathsf{T}} u$（单位：$\\mathrm{J}$）。\n   - 将参数对 $(\\theta_1, \\theta_2)$ 的相对柔度误差定义为无量纲量\n     $$\n     \\varepsilon = \\frac{\\lvert c(S(\\theta_1), S(\\theta_2)) - c(\\tilde{S}(\\theta_1), \\tilde{S}(\\theta_2)) \\rvert}{\\lvert c(S(\\theta_1), S(\\theta_2)) \\rvert}.\n     $$\n\n4. 测试套件：\n   - 使用以下四个测试用例，每个用例指定 $(\\theta_1, \\theta_2)$，其中 $\\theta_i = (E_i, A_i, L_i)$：\n     - 测试 $1$（在网格点上，预期插值误差为零）：$\\theta_1 = (140 \\times 10^{9}, 10^{-3}, 1.0)$，$\\theta_2 = (140 \\times 10^{9}, 10^{-3}, 1.0)$。\n     - 测试 $2$（一个内部点，一个网格点）：$\\theta_1 = (100 \\times 10^{9}, 0.8 \\times 10^{-3}, 1.2)$，$\\theta_2 = (140 \\times 10^{9}, 10^{-3}, 1.0)$。\n     - 测试 $3$（$L$ 值混合了内部点和边界点）：$\\theta_1 = (175 \\times 10^{9}, 1.5 \\times 10^{-3}, 0.5)$，$\\theta_2 = (100 \\times 10^{9}, 0.8 \\times 10^{-3}, 1.2)$。\n     - 测试 $4$（面边界情况和网格角点）：$\\theta_1 = (140 \\times 10^{9}, 0.75 \\times 10^{-3}, 2.0)$，$\\theta_2 = (210 \\times 10^{9}, 2 \\times 10^{-3}, 2.0)$。\n   - 所有量均采用上述单位。最终报告的误差是无量纲的。\n\n5. 程序输出格式：\n   - 您的程序必须构建库，根据需要进行插值，组装全局系统，并按所列顺序为四个测试中的每一个计算相对柔度误差 $\\varepsilon$。\n   - 您的程序应生成单行输出，其中包含四个结果，格式为方括号内以逗号分隔的列表（例如，`[e_1,e_2,e_3,e_4]`），其中每个 $e_i$ 是一个浮点数。\n\n约束和说明：\n- 您的推导应基于轴向杆的平衡、线弹性、有限元组装以及静态凝聚（即消除内部自由度以获得边界关系）的定义。不要在问题陈述本身使用任何未经证实的简化公式。\n- 数值稳定性：对于给定数据，组装的内部刚度块是对称正定的，因此标准线性代数足以进行静态凝聚。\n- 不涉及角度；不需要角度单位。\n- 由于请求的输出是无量纲的相对误差，因此最终的数值输出中不需要明确的物理单位。",
            "solution": "用户提供的问题经过了严格验证，被认为是科学上合理、适定、客观和完整的。在计算线弹性框架内，所有提供的数据和约束都是一致且物理上现实的。任务是计算由超单元刚度矩阵的三线性插值引起的结构柔度的相对误差。解决方案将按照规定的计算步骤实现。\n\n### 静态凝聚原理\n\n有限元模型的静态分析由线性系统 $K u = f$ 控制，其中 $K$ 是全局刚度矩阵，$u$ 是节点位移向量，$f$ 是节点力向量。在子结构法中，我们将自由度 (DOFs) $u$ 分为内部（或“待消去”）自由度 $u_i$ 和边界（或“保留”）自由度 $u_b$。方程组也相应地进行分块：\n\n$$\n\\begin{pmatrix} K_{bb} & K_{bi} \\\\ K_{ib} & K_{ii} \\end{pmatrix}\n\\begin{pmatrix} u_b \\\\ u_i \\end{pmatrix} =\n\\begin{pmatrix} f_b \\\\ f_i \\end{pmatrix}\n$$\n\n静态凝聚是消除内部自由度 $u_i$ 的过程，以找到边界力 $f_b$ 和边界位移 $u_b$ 之间的直接关系。这通常在假设没有外力施加于内部自由度（即 $f_i = 0$）的情况下进行。\n\n从分块系统的第二行，我们求解 $u_i$：\n$K_{ib} u_b + K_{ii} u_i = 0 \\implies u_i = -K_{ii}^{-1} K_{ib} u_b$。\n$K_{ii}$ 矩阵是可逆的，因为它代表了边界自由度被固定时的结构刚度矩阵，这是一个稳定的构型。\n\n将 $u_i$ 的这个表达式代入系统的第一行，得到：\n$K_{bb} u_b + K_{bi} (-K_{ii}^{-1} K_{ib} u_b) = f_b$\n$$\n(K_{bb} - K_{bi} K_{ii}^{-1} K_{ib}) u_b = f_b\n$$\n这就定义了凝聚刚度矩阵，或称超单元刚度矩阵 $S$ 为：\n$$\nS = K_{bb} - K_{bi} K_{ii}^{-1} K_{ib}\n$$\n这个矩阵 $S$ 关联了子结构边界上的位移和力。注意，由于刚度矩阵 $K$ 的对称性，有 $K_{ib} = K_{bi}^{\\mathsf{T}}$。\n\n### 步骤 1：子结构刚度矩阵的组装和凝聚\n\n该子结构是一根长度为 $L$、杨氏模量为 $E$、面积为 $A$ 的一维轴向杆。它被离散化为 $m=4$ 个等长单元。每个单元的长度为 $\\ell_e = L/4$。单个双节点杆单元的刚度矩阵为：\n$$\nk_e = \\frac{EA}{\\ell_e} \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix} = \\frac{4EA}{L} \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix}\n$$\n对 $m=4$ 个单元（有 $m+1=5$ 个节点）进行标准有限元组装，得到 $5 \\times 5$ 的全局刚度矩阵 $K$：\n$$\nK = \\frac{4EA}{L} \\begin{pmatrix}\n1 & -1 & 0 & 0 & 0 \\\\\n-1 & 2 & -1 & 0 & 0 \\\\\n0 & -1 & 2 & -1 & 0 \\\\\n0 & 0 & -1 & 2 & -1 \\\\\n0 & 0 & 0 & -1 & 1\n\\end{pmatrix}\n$$\n边界自由度对应于第一个和最后一个节点（节点索引为 $0$ 和 $4$），内部自由度对应于中间节点（索引为 $1, 2, 3$）。根据分块方案，我们确定以下子矩阵：\n$u_b = (u_0, u_4)^{\\mathsf{T}}$，$u_i = (u_1, u_2, u_3)^{\\mathsf{T}}$。\n基于完整的矩阵 $K$，各分块为：\n$$\nK_{bb} = \\frac{4EA}{L} \\begin{pmatrix} 1 & 0 \\\\ 0 & 1 \\end{pmatrix}, \\quad\nK_{bi} = \\frac{4EA}{L} \\begin{pmatrix} -1 & 0 & 0 \\\\ 0 & 0 & -1 \\end{pmatrix}\n$$\n$$\nK_{ii} = \\frac{4EA}{L} \\begin{pmatrix} 2 & -1 & 0 \\\\ -1 & 2 & -1 \\\\ 0 & -1 & 2 \\end{pmatrix}\n$$\n对于每个参数集 $\\theta = (E, A, L)$，计算 $S(\\theta)$ 的过程是通过数值上构建这些矩阵并计算表达式 $S = K_{bb} - K_{bi} (\\text{solve}(K_{ii}, K_{ib}))$。我们将通过计算并存储指定的 $(E, A, L)$ 张量积网格上每个点的 $S(\\theta)$ 来构建一个库。\n\n### 步骤 2：三线性插值\n\n对于不在网格上的通用参数点 $\\theta=(E, A, L)$，凝聚刚度矩阵 $\\tilde{S}(\\theta)$ 通过从预先计算的库中进行逐项三线性插值来近似。对于网格上定义的任何标量 $f(E,A,L)$，其在网格单元 $[E_i, E_{i+1}] \\times [A_j, A_{j+1}] \\times [L_k, L_{k+1}]$ 内一点 $(E,A,L)$ 的三线性插值，首先通过计算归一化坐标来找到：\n$$\nt_E = \\frac{E - E_i}{E_{i+1} - E_i}, \\quad t_A = \\frac{A - A_j}{A_{j+1} - A_j}, \\quad t_L = \\frac{L - L_k}{L_{k+1} - L_k}\n$$\n然后通过一系列线性插值（lerps）计算插值。令 $c_{pqr} = f(E_{i+p}, A_{j+q}, L_{k+r})$，其中 $p,q,r \\in \\{0, 1\\}$。\n1.  沿 $E$ 轴对单元格与其平行的四条边进行插值。\n2.  将步骤 1 的四个结果沿 $A$ 轴进行插值，得到两个值。\n3.  将步骤 2 的两个结果沿 $L$ 轴进行插值，得到最终值。\n\n此过程应用于对称 $2 \\times 2$ 矩阵 $S(\\theta)$ 的独立元素，即 $S_{11}$、$S_{12}$ 和 $S_{22}$。\n\n### 步骤 3：全局组装与柔度计算\n\n由参数 $\\theta_1$ 和 $\\theta_2$ 描述的两个超单元串联组装。这创建了一个具有三个节点的全局结构：节点 $0$（左端）、节点 $1$（界面）和节点 $2$（右端）。全局刚度矩阵 $K_G$ 是一个 $3 \\times 3$ 矩阵，由两个 $2 \\times 2$ 的超单元矩阵 $S(\\theta_1)$ 和 $S(\\theta_2)$ 组装而成：\n$$\nK_G = \\begin{pmatrix}\nS_{1,11} & S_{1,12} & 0 \\\\\nS_{1,21} & S_{1,22} + S_{2,11} & S_{2,12} \\\\\n0 & S_{2,21} & S_{2,22}\n\\end{pmatrix}\n$$\n边界条件为左端位移固定，$u_0 = 0$。在右端施加载荷 $P=10^5 \\, \\mathrm{N}$。全局方程组为 $K_G u = f$，其中 $u = (u_0, u_1, u_2)^{\\mathsf{T}}$，外力向量为 $f_{ext} = (0, 0, P)^{\\mathsf{T}}$。\n\n应用边界条件 $u_0=0$ 将系统简化为关于未知位移 $u_1$ 和 $u_2$ 的 $2 \\times 2$ 问题：\n$$\n\\begin{pmatrix}\nS_{1,22} + S_{2,11} & S_{2,12} \\\\\nS_{2,21} & S_{2,22}\n\\end{pmatrix}\n\\begin{pmatrix} u_1 \\\\ u_2 \\end{pmatrix} =\n\\begin{pmatrix} 0 \\\\ P \\end{pmatrix}\n$$\n求解出 $u_1$ 和 $u_2$ 后，完整的位移向量为 $u = (0, u_1, u_2)^{\\mathsf{T}}$。柔度 $c$ 是外施力所做的功，定义为 $c = f_{ext}^{\\mathsf{T}} u$。在本例中，它简化为 $c = P u_2$。\n\n### 步骤 4：相对误差计算\n\n对于每个测试用例 $(\\theta_1, \\theta_2)$，我们计算两个柔度值：\n1.  $c_{exact}$：使用精确计算的超单元矩阵 $S(\\theta_1)$ 和 $S(\\theta_2)$。\n2.  $c_{interp}$：使用三线性插值的矩阵 $\\tilde{S}(\\theta_1)$ 和 $\\tilde{S}(\\theta_2)$。\n\n然后，相对柔度误差 $\\varepsilon$ 按如下方式计算：\n$$\n\\varepsilon = \\frac{\\lvert c_{exact} - c_{interp} \\rvert}{\\lvert c_{exact} \\rvert}\n$$\n\n以下 Python 代码实现了针对四个指定测试用例的整个过程。",
            "answer": "```python\nimport numpy as np\n\ndef compute_S(theta, m):\n    \"\"\"\n    Computes the condensed stiffness matrix S for a 1D bar.\n    \n    Args:\n        theta (tuple): A tuple (E, A, L) of material and geometric properties.\n        m (int): Number of finite elements.\n    \n    Returns:\n        numpy.ndarray: The 2x2 condensed stiffness matrix.\n    \"\"\"\n    E, A, L = theta\n    if E == 0 or A == 0 or L == 0:\n        return np.zeros((2, 2))\n    \n    le = L / m\n    k_factor = E * A / le\n    \n    n_nodes = m + 1\n    K = np.zeros((n_nodes, n_nodes))\n    \n    for i in range(m):\n        k_e = k_factor * np.array([[1, -1], [-1, 1]])\n        K[i:i+2, i:i+2] += k_e\n\n    retained_dofs = [0, m]\n    doomed_dofs = list(range(1, m))\n\n    K_rr = K[np.ix_(retained_dofs, retained_dofs)]\n    K_rd = K[np.ix_(retained_dofs, doomed_dofs)]\n    K_dr = K[np.ix_(doomed_dofs, retained_dofs)]\n    K_dd = K[np.ix_(doomed_dofs, doomed_dofs)]\n    \n    # Solve K_dd * X = K_dr for X, then S = K_rr - K_rd @ X\n    Kdd_inv_Kdr = np.linalg.solve(K_dd, K_dr)\n    S = K_rr - K_rd @ Kdd_inv_Kdr\n    return S\n\ndef get_indices_and_t(val, grid):\n    \"\"\"\n    Finds the lower-bound index and normalized distance for interpolation.\n    \n    Args:\n        val (float): The value to locate in the grid.\n        grid (numpy.ndarray): The 1D sorted grid array.\n    \n    Returns:\n        tuple: (lower_bound_index, normalized_distance_t)\n    \"\"\"\n    if val == grid[-1]:\n        return len(grid) - 2, 1.0\n    \n    idx = np.searchsorted(grid, val, side='right') - 1\n    \n    # Handle precision issues where val might be slightly less than grid[0]\n    idx = max(0, idx)\n\n    t = (val - grid[idx]) / (grid[idx+1] - grid[idx])\n    \n    return idx, t\n\ndef interpolate_S(theta, library, grids):\n    \"\"\"\n    Computes the interpolated stiffness matrix S_tilde using trilinear interpolation.\n    \n    Args:\n        theta (tuple): The parameter point (E, A, L).\n        library (dict): The pre-computed library of stiffness matrices.\n        grids (tuple): A tuple of (E_grid, A_grid, L_grid).\n\n    Returns:\n        numpy.ndarray: The 2x2 interpolated stiffness matrix.\n    \"\"\"\n    if theta in library:\n        return library[theta]\n\n    E_grid, A_grid, L_grid = grids\n    E, A, L = theta\n\n    i, tE = get_indices_and_t(E, E_grid)\n    j, tA = get_indices_and_t(A, A_grid)\n    k, tL = get_indices_and_t(L, L_grid)\n\n    # Get the 8 corner points of the grid cell\n    corners = np.zeros((8, 3)) # 8 corners, 3 values (S00, S01, S11)\n    \n    E_coords = [E_grid[i], E_grid[i+1]]\n    A_coords = [A_grid[j], A_grid[j+1]]\n    L_coords = [L_grid[k], L_grid[k+1]]\n\n    corner_idx = 0\n    # The order of loops establishes the convention for interpolation axes.\n    # E -> x, A -> y, L -> z\n    for l_val in L_coords:\n        for a_val in A_coords:\n            for e_val in E_coords:\n                S_val = library[(e_val, a_val, l_val)]\n                corners[corner_idx, :] = [S_val[0,0], S_val[0,1], S_val[1,1]]\n                corner_idx += 1\n    \n    interp_vals = np.zeros(3)\n    for val_idx in range(3): # Iterate over S00, S01, S11\n        # Interpolate along E axis (tE)\n        c00 = corners[0, val_idx] * (1 - tE) + corners[1, val_idx] * tE\n        c10 = corners[2, val_idx] * (1 - tE) + corners[3, val_idx] * tE\n        c01 = corners[4, val_idx] * (1 - tE) + corners[5, val_idx] * tE\n        c11 = corners[6, val_idx] * (1 - tE) + corners[7, val_idx] * tE\n        \n        # Interpolate along A axis (tA)\n        c0 = c00 * (1 - tA) + c10 * tA\n        c1 = c01 * (1 - tA) + c11 * tA\n        \n        # Interpolate along L axis (tL)\n        interp_vals[val_idx] = c0 * (1 - tL) + c1 * tL\n\n    S_interp = np.array([\n        [interp_vals[0], interp_vals[1]],\n        [interp_vals[1], interp_vals[2]]\n    ])\n    return S_interp\n\ndef calculate_compliance(S1, S2, P):\n    \"\"\"\n    Calculates the global compliance for a two-element assembly.\n    \n    Args:\n        S1, S2 (numpy.ndarray): 2x2 stiffness matrices for elements 1 and 2.\n        P (float): Applied load at the right end.\n        \n    Returns:\n        float: The global compliance.\n    \"\"\"\n    K_red = np.array([\n        [S1[1,1] + S2[0,0], S2[0,1]],\n        [S2[1,0], S2[1,1]]\n    ])\n    f_red = np.array([0, P])\n    \n    if np.linalg.det(K_red) == 0:\n        return np.inf\n\n    u_red = np.linalg.solve(K_red, f_red)\n    u2 = u_red[1]\n    \n    return P * u2\n\ndef solve():\n    \"\"\"\n    Main function to run the analysis and print the results.\n    \"\"\"\n    # Define parameters and problem setup\n    m = 4\n    P = 1e5\n    E_grid = np.array([70e9, 140e9, 210e9])\n    A_grid = np.array([5e-4, 1e-3, 2e-3])\n    L_grid = np.array([0.5, 1.0, 2.0])\n    grids = (E_grid, A_grid, L_grid)\n\n    # Define the test cases\n    test_cases = [\n        # ((E1, A1, L1), (E2, A2, L2))\n        ((140e9, 1e-3, 1.0), (140e9, 1e-3, 1.0)),\n        ((100e9, 0.8e-3, 1.2), (140e9, 1e-3, 1.0)),\n        ((175e9, 1.5e-3, 0.5), (100e9, 0.8e-3, 1.2)),\n        ((140e9, 0.75e-3, 2.0), (210e9, 2e-3, 2.0)),\n    ]\n\n    # Step 1: Library construction\n    library = {}\n    for E in E_grid:\n        for A in A_grid:\n            for L in L_grid:\n                theta = (E, A, L)\n                library[theta] = compute_S(theta, m)\n\n    results = []\n    for theta1, theta2 in test_cases:\n        # Exact calculation\n        S1_exact = compute_S(theta1, m)\n        S2_exact = compute_S(theta2, m)\n        c_exact = calculate_compliance(S1_exact, S2_exact, P)\n\n        # Interpolated calculation\n        S1_interp = interpolate_S(theta1, library, grids)\n        S2_interp = interpolate_S(theta2, library, grids)\n        c_interp = calculate_compliance(S1_interp, S2_interp, P)\n\n        # Relative error\n        if c_exact != 0:\n            error = np.abs(c_exact - c_interp) / np.abs(c_exact)\n        else:\n            # This case implies infinite stiffness, zero compliance\n            error = 0.0 if c_interp == 0.0 else np.inf\n        results.append(error)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}