{
    "hands_on_practices": [
        {
            "introduction": "A crucial step in developing reliable finite elements is verifying their performance. The patch test is a fundamental tool for this, checking if an element can exactly reproduce simple, constant-strain states. This practice guides you through implementing a patch test for a Mindlin-Reissner shell element under pure bending, a state that should theoretically produce zero transverse shear. You will compare a standard formulation, which notoriously suffers from shear locking, against more advanced selective reduced integration and mixed-interpolation methods, revealing firsthand why specialized formulations are essential for accurate thin plate and shell analysis .",
            "id": "3581860",
            "problem": "Construct a one-element patch test for a quadrilateral Mindlin–Reissner shell element with bilinear isoparametric mapping and use it to assess transverse-shear behavior under constant bending curvature. Start from first principles of Mindlin–Reissner kinematics and isoparametric mapping, and require the algorithm to be derived from these bases without invoking any pre-quoted element formulas.\n\nFundamental bases and definitions to use:\n- Mindlin–Reissner plate and shell kinematics with small strains and moderate rotations: the transverse shear vector is defined by the two in-plane components $\\boldsymbol{s} = [\\gamma_{xz}, \\gamma_{yz}]^{\\mathsf{T}}$, where $\\gamma_{xz} = \\theta_x + \\partial w/\\partial x$ and $\\gamma_{yz} = \\theta_y + \\partial w/\\partial y$. Here $w$ is the transverse deflection of the midsurface and $(\\theta_x, \\theta_y)$ are the rotations of the normal about the $y$- and $x$-axes, respectively. Angles must be treated in radians. For a Kirchhoff–Love bending field with zero transverse shear, the rotations satisfy $(\\theta_x, \\theta_y) = -\\nabla w$.\n- Constant curvature bending field: prescribe an exact target deflection $w^\\star(x,y)$ that produces constant curvatures $(\\kappa_x, \\kappa_y, \\kappa_{xy})$ in physical coordinates, for example\n$$\nw^\\star(x,y) = \\tfrac{1}{2}\\,\\kappa_x\\,x^2 + \\tfrac{1}{2}\\,\\kappa_y\\,y^2 + \\kappa_{xy}\\,x\\,y,\n$$\nand set the exact rotations as\n$$\n\\theta_x^\\star(x,y) = -\\frac{\\partial w^\\star}{\\partial x} = -(\\kappa_x x + \\kappa_{xy} y),\\qquad\n\\theta_y^\\star(x,y) = -\\frac{\\partial w^\\star}{\\partial y} = -(\\kappa_y y + \\kappa_{xy} x).\n$$\n- Bilinear isoparametric quadrilateral mapping: physical coordinates are a bilinear function of parent coordinates $(\\xi,\\eta)\\in[-1,1]^2$,\n$$\n\\boldsymbol{x}(\\xi,\\eta) = \\sum_{a=1}^{4} N_a(\\xi,\\eta)\\,\\boldsymbol{x}_a,\\quad\nN_1=\\tfrac{1}{4}(1-\\xi)(1-\\eta),\\ N_2=\\tfrac{1}{4}(1+\\xi)(1-\\eta),\\ N_3=\\tfrac{1}{4}(1+\\xi)(1+\\eta),\\ N_4=\\tfrac{1}{4}(1-\\xi)(1+\\eta).\n$$\nThe covariant base vectors are $\\boldsymbol{a}_\\xi = \\partial \\boldsymbol{x}/\\partial \\xi$ and $\\boldsymbol{a}_\\eta = \\partial \\boldsymbol{x}/\\partial \\eta$. The Jacobian for the in-plane mapping is the $2\\times 2$ matrix $J=[\\partial x/\\partial \\xi\\ \\ \\partial x/\\partial \\eta;\\ \\partial y/\\partial \\xi\\ \\ \\partial y/\\partial \\eta]$, and the chain rule gives $[\\partial w/\\partial x\\ \\ \\partial w/\\partial y]^{\\mathsf{T}} = \\boldsymbol{J}^{-\\mathsf{T}}[\\partial w/\\partial \\xi\\ \\ \\partial w/\\partial \\eta]^{\\mathsf{T}}$.\n- For integration over the physical element, use standard Gaussian quadrature in parent coordinates with differential area $dA = |\\boldsymbol{a}_\\xi \\times \\boldsymbol{a}_\\eta|\\,d\\xi\\,d\\eta$. For planar midsurfaces with $\\boldsymbol{x}=(x,y,0)$, the magnitude $|\\boldsymbol{a}_\\xi \\times \\boldsymbol{a}_\\eta|$ reduces to $|\\det \\boldsymbol{J}|$.\n\nDiscretization to test:\n- Use bilinear interpolation in parent coordinates for the unknown fields $w^h(\\xi,\\eta)$ and $(\\theta_x^h(\\xi,\\eta),\\theta_y^h(\\xi,\\eta))$, with nodal values taken from the exact fields $w^\\star$ and $(\\theta_x^\\star,\\theta_y^\\star)$ evaluated at the physical node locations. That is, for $a\\in\\{1,2,3,4\\}$ and any $(\\xi,\\eta)$, $w^h(\\xi,\\eta)=\\sum_a N_a(\\xi,\\eta)\\,w^\\star(\\boldsymbol{x}_a)$ and $\\theta_i^h(\\xi,\\eta)=\\sum_a N_a(\\xi,\\eta)\\,\\theta_i^\\star(\\boldsymbol{x}_a)$ for $i\\in\\{x,y\\}$.\n- Implement three transverse-shear evaluation strategies:\n  1. Standard strain evaluation (STD): compute $\\boldsymbol{s}_{\\text{STD}}(\\xi,\\eta) = [\\theta_x^h+\\partial w^h/\\partial x,\\ \\theta_y^h+\\partial w^h/\\partial y]^{\\mathsf{T}}$ pointwise at quadrature points by chain rule.\n  2. Selective reduced integration (SRI): compute $\\boldsymbol{s}_{\\text{SRI}}$ only at the element center $(\\xi,\\eta)=(0,0)$ and use it as a constant value for integration, representing a one-point reduced integration for the shear terms.\n  3. Edge-tied assumed-strain (MITC-type) using projections along the covariant edge tangents: define the unit tangents $\\boldsymbol{t}_\\xi = \\boldsymbol{a}_\\xi/||\\boldsymbol{a}_\\xi||$ and $\\boldsymbol{t}_\\eta = \\boldsymbol{a}_\\eta/||\\boldsymbol{a}_\\eta||$. Enforce the two projected shear components $\\boldsymbol{s}\\cdot \\boldsymbol{t}_\\xi$ and $\\boldsymbol{s}\\cdot \\boldsymbol{t}_\\eta$ by tying them at the midpoints of opposite edges (at $(\\xi,\\eta)=(0,\\pm 1)$ for the $\\xi$-edges, and $(\\xi,\\eta)=(\\pm 1,0)$ for the $\\eta$-edges), using the projections of $\\boldsymbol{\\theta}^h$ and the directional derivatives of $w^h$ along the corresponding parametric lines. Interpolate each projected component linearly across the element in the orthogonal parent coordinate, and reconstruct the in-plane shear vector $\\boldsymbol{s}_{\\text{MITC}}(\\xi,\\eta)$ at quadrature points by solving the least-squares problem that matches these two projections simultaneously.\n\nPerformance metric and pass criterion:\n- For any shear evaluation strategy $X\\in\\{\\text{STD},\\text{SRI},\\text{MITC}\\}$ define the squared $L^2$-seminorm of spurious shear\n$$\nE_X = \\int_{\\Omega_e} \\| \\boldsymbol{s}_X \\|_2^2\\,dA \\approx \\sum_{q} w_q\\,|\\det \\boldsymbol{J}(\\xi_q,\\eta_q)|\\,\\|\\boldsymbol{s}_X(\\xi_q,\\eta_q)\\|_2^2,\n$$\nwhere $\\{(\\xi_q,\\eta_q), w_q\\}$ are the Gaussian points and weights appropriate to the strategy ($2\\times 2$ Gauss points for STD and MITC, and $1\\times 1$ for SRI located at $(0,0)$). Let the element area be $A=\\int_{\\Omega_e} dA$. Let the curvature scale be $K=\\sqrt{\\kappa_x^2+\\kappa_y^2+\\kappa_{xy}^2}$. Define the dimensionless shear error index\n$$\n\\mathcal{M}_X = \\frac{\\sqrt{E_X}}{\\sqrt{A}\\,K\\,\\sqrt{A}} = \\frac{\\sqrt{E_X}}{K\\,A}.\n$$\nInterpret an element as passing the constant curvature patch test without spurious transverse shear if $\\mathcal{M}_X \\le \\tau$, with tolerance $\\tau=10^{-8}$ (dimensionless).\n- All angles must be interpreted in radians, all coordinates in meters, and the final error index is dimensionless. No loads or constitutive parameters are required for this kinematic patch test.\n\nTest suite:\nFor each of the following one-element patches (node coordinates in meters) and curvature triplets (in inverse meters), evaluate the three strategies and report booleans for pass/fail.\n\n- Geometry G1 (affine square): nodes\n  $\\boldsymbol{x}_1=(0,0,0)$, $\\boldsymbol{x}_2=(1,0,0)$, $\\boldsymbol{x}_3=(1,1,0)$, $\\boldsymbol{x}_4=(0,1,0)$.\n  Curvature set C1: $(\\kappa_x,\\kappa_y,\\kappa_{xy})=(0.02,0.01,0.015)$.\n- Geometry G2 (skewed parallelogram): nodes\n  $\\boldsymbol{x}_1=(0,0,0)$, $\\boldsymbol{x}_2=(2,0.2,0)$, $\\boldsymbol{x}_3=(1.8,1.2,0)$, $\\boldsymbol{x}_4=(-0.1,0.9,0)$.\n  Curvature set C1: $(\\kappa_x,\\kappa_y,\\kappa_{xy})=(0.02,0.01,0.015)$.\n- Geometry G2 with pure $x$-bending: curvature set C2: $(\\kappa_x,\\kappa_y,\\kappa_{xy})=(0.05,0,0)$.\n- Geometry G3 (strongly distorted bilinear quadrilateral): nodes\n  $\\boldsymbol{x}_1=(0,0,0)$, $\\boldsymbol{x}_2=(1.2,0.1,0)$, $\\boldsymbol{x}_3=(0.9,1.1,0)$, $\\boldsymbol{x}_4=(-0.2,0.8,0)$.\n  Curvature set C3: $(\\kappa_x,\\kappa_y,\\kappa_{xy})=(0,0,0.03)$.\n\nFinal output format:\nYour program should produce a single line of output containing a list of results, one per test case, where each result is a list of three booleans corresponding to $[\\text{STD},\\ \\text{SRI},\\ \\text{MITC}]$. The line must be printed exactly as a Python list literal, for example\n`[[True,False,True], [False,False,True], [False,True,True], [False,False,True]]`,\nbut without extra spaces beyond those automatically produced by Python’s default list and boolean string representations. The actual boolean values must be the computed outcomes for the specified test suite.",
            "solution": "The user requests the construction and application of a one-element patch test for a quadrilateral Mindlin-Reissner shell element. This test is a fundamental verification procedure in computational mechanics, designed to assess an element's ability to represent a state of constant bending curvature without producing spurious, non-physical transverse shear strains, a phenomenon known as shear locking.\n\n### Step 1: Problem Validation\n\nThe problem statement is critically evaluated against the specified criteria.\n\n- **Givens Extraction**:\n  - **Kinematics**: Mindlin-Reissner theory with shear strains $\\gamma_{xz} = \\theta_x + \\partial w/\\partial x$ and $\\gamma_{yz} = \\theta_y + \\partial w/\\partial y$.\n  - **Target Field**: A constant curvature bending field defined by $w^\\star(x,y)$, $\\theta_x^\\star(x,y)$, and $\\theta_y^\\star(x,y)$, which is kinematically consistent with zero transverse shear ($\\boldsymbol{\\theta}^\\star = -\\nabla w^\\star$).\n  - **Discretization**: A four-node quadrilateral element using bilinear isoparametric interpolation for both geometry and the unknown fields ($w^h, \\theta_x^h, \\theta_y^h$). Nodal values are prescribed by evaluating the exact target field at the element's physical node locations.\n  - **Shear Evaluation Methods**: Three distinct strategies are defined: Standard (STD) full integration, Selective Reduced Integration (SRI), and an edge-based Mixed Interpolation of Tensorial Components (MITC) formulation.\n  - **Performance Metric**: A dimensionless shear error index, $\\mathcal{M}_X$, is defined as $\\mathcal{M}_X = \\sqrt{E_X} / (K A)$, where $E_X$ is the integrated squared norm of the spurious shear strain, $A$ is the element area, and $K$ is a curvature-based scaling factor.\n  - **Pass Criterion**: The element passes if $\\mathcal{M}_X \\le 10^{-8}$.\n  - **Test Suite**: Four specific test cases are provided, combining three distinct element geometries (G1, G2, G3) with three curvature sets (C1, C2, C3).\n\n- **Validation Verdict**:\n  - The problem is **scientifically grounded** in the established principles of the finite element method and shell theory.\n  - It is **well-posed**, providing a complete, self-contained, and unambiguous set of instructions for a computational algorithm.\n  - The language is **objective** and precise.\n  - The task is non-trivial and directly relevant to the specified topic, testing core concepts of element formulation and performance.\n  - All definitions, constraints, and data are consistent and sufficient for deriving a unique numerical solution.\n\nThe problem is deemed **valid**. We may proceed with the solution.\n\n### Step 2: Algorithmic Design from First Principles\n\nThe solution is implemented by adhering strictly to the provided definitions. A class `PatchTester` is designed to encapsulate the logic for a single test case.\n\n1.  **Initialization**: An instance is created with the element's nodal coordinates and the prescribed curvatures $(\\kappa_x, \\kappa_y, \\kappa_{xy})$.\n    - The exact continuous fields for deflection ($w^\\star$) and rotations ($\\theta_x^\\star, \\theta_y^\\star$) are defined as functions of the physical coordinates $(x,y)$.\n    - The nodal degrees of freedom ($w_a, \\theta_{xa}, \\theta_{ya}$ for $a=1,..,4$) are computed by evaluating these exact functions at the physical coordinates of the four nodes.\n\n2.  **Isoparametric and Field Interpolation**:\n    - The standard bilinear shape functions $N_a(\\xi, \\eta)$ and their derivatives with respect to parent coordinates, $\\partial N_a/\\partial \\xi$ and $\\partial N_a/\\partial \\eta$, are implemented.\n    - At any point $(\\xi, \\eta)$ in the parent domain, the physical coordinates $\\boldsymbol{x}$, the Jacobian matrix $\\boldsymbol{J}$, its determinant $|\\boldsymbol{J}|$, and the covariant base vectors $\\boldsymbol{a}_\\xi, \\boldsymbol{a}_\\eta$ are computed from the nodal coordinates using the shape functions and their derivatives.\n    - Similarly, the interpolated fields $\\theta_x^h, \\theta_y^h$ and the parent-space derivatives of deflection, $\\partial w^h/\\partial \\xi, \\partial w^h/\\partial \\eta$, are computed from the nodal DOFs.\n\n3.  **Shear Strain Calculation and Integration**: For each of the three strategies, the spurious shear energy $E_X$ is computed. This involves integrating the squared norm of the computed shear vector, $\\|\\boldsymbol{s}_X\\|^2$, over the element area $A$. Numerical integration via Gaussian quadrature is used as specified.\n\n    - **Standard (STD) Strategy**:\n        - A $2 \\times 2$ Gaussian quadrature loop is executed.\n        - At each quadrature point $(\\xi_q, \\eta_q)$, the physical derivatives of deflection $\\nabla w^h = [\\partial w^h/\\partial x, \\partial w^h/\\partial y]^{\\mathsf{T}}$ are found using the chain rule: $\\nabla w^h = \\boldsymbol{J}^{-\\mathsf{T}} [\\partial w^h/\\partial \\xi, \\partial w^h/\\partial \\eta]^{\\mathsf{T}}$.\n        - The shear strain vector $\\boldsymbol{s}_{\\text{STD}} = [\\theta_x^h + \\partial w^h/\\partial x, \\theta_y^h + \\partial w^h/\\partial y]^{\\mathsf{T}}$ is computed.\n        - The contribution to the energy, $w_q |\\boldsymbol{J}(\\xi_q, \\eta_q)| \\|\\boldsymbol{s}_{\\text{STD}}(\\xi_q, \\eta_q)\\|_2^2$, is added to the total $E_{\\text{STD}}$.\n\n    - **Selective Reduced Integration (SRI) Strategy**:\n        - The shear strain $\\boldsymbol{s}_{\\text{SRI}}$ is computed only at the element center $(\\xi, \\eta) = (0,0)$.\n        - The energy $E_{\\text{SRI}}$ is computed using a one-point quadrature rule, which has a weight of $4$ for the domain $[-1,1]^2$: $E_{\\text{SRI}} = 4 \\cdot |\\boldsymbol{J}(0,0)| \\cdot \\|\\boldsymbol{s}_{\\text{SRI}}(0,0)\\|_2^2$.\n\n    - **MITC-type Strategy**:\n        - **Tying**: The projected shear components are computed at the midpoints of the four edges. For example, at the midpoint of the $\\eta = -1$ edge (point A), the projection is $g_{\\xi,A} = (\\boldsymbol{\\theta}^h \\cdot \\boldsymbol{t}_\\xi + (\\partial w^h/\\partial \\xi)/\\|\\boldsymbol{a}_\\xi\\|)|_A$, where $\\boldsymbol{t}_\\xi=\\boldsymbol{a}_\\xi/\\|\\boldsymbol{a}_\\xi\\|$ is the unit tangent vector. This is done for both projections at opposite edge pairs.\n        - **Interpolation**: Two assumed shear fields, $p_\\xi(\\eta)$ and $p_\\eta(\\xi)$, are defined by linearly interpolating the tied values from opposite edges.\n        - **Reconstruction**: The final shear vector $\\boldsymbol{s}_{\\text{MITC}}$ is computed within the $2 \\times 2$ quadrature loop. At each quadrature point, the local unit tangents $\\boldsymbol{t}_\\xi$ and $\\boldsymbol{t}_\\eta$ form a $2 \\times 2$ transformation matrix $\\boldsymbol{T}$. The shear vector is recovered by solving the system $\\boldsymbol{T} \\boldsymbol{s}_{\\text{MITC}} = [p_\\xi(\\eta_q), p_\\eta(\\xi_q)]^{\\mathsf{T}}$.\n        - **Integration**: The energy $E_{\\text{MITC}}$ is accumulated using the reconstructed shear vector at each of the $2 \\times 2$ Gauss points.\n\n4.  **Metric Evaluation**: After calculating the element area $A$ and the total energies $E_X$, the dimensionless error index $\\mathcal{M}_X$ for each strategy is computed and compared against the tolerance $\\tau=10^{-8}$ to determine the pass/fail booleans for the test case.\n\nThis systematic procedure, derived directly from the problem's fundamental definitions, is implemented in the following Python program.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# version: Python 3.12\n# libraries: numpy 1.23.5\n\nclass PatchTester:\n    \"\"\"\n    Encapsulates the logic for a one-element Mindlin-Reissner patch test for a \n    given geometry and constant curvature field.\n    \"\"\"\n    def __init__(self, nodes, curvatures, tolerance=1e-8):\n        \"\"\"\n        Initializes the test with geometry, target field, and tolerance.\n\n        Args:\n            nodes (list of tuples): A 4x3 list of nodal coordinates.\n            curvatures (tuple): A tuple (kappa_x, kappa_y, kappa_xy).\n            tolerance (float): The threshold for the pass/fail criterion.\n        \"\"\"\n        self.nodes = np.array(nodes, dtype=float)\n        self.k_x, self.k_y, self.k_xy = curvatures\n        self.tolerance = tolerance\n\n        self.x_coords = self.nodes[:, 0]\n        self.y_coords = self.nodes[:, 1]\n        \n        # Define exact kinematic fields as functions of physical coordinates (x, y)\n        self.w_star = lambda x, y: 0.5 * self.k_x * x**2 + 0.5 * self.k_y * y**2 + self.k_xy * x * y\n        self.theta_x_star = lambda x, y: -(self.k_x * x + self.k_xy * y)\n        self.theta_y_star = lambda x, y: -(self.k_y * y + self.k_xy * x)\n\n        # Evaluate nodal values of DOFs from the exact fields\n        self.w_nodes = self.w_star(self.x_coords, self.y_coords)\n        self.theta_x_nodes = self.theta_x_star(self.x_coords, self.y_coords)\n        self.theta_y_nodes = self.theta_y_star(self.x_coords, self.y_coords)\n\n        # Gaussian quadrature setup\n        gp = 1.0 / np.sqrt(3)\n        self.gauss_pts_2x2 = [(-gp, -gp), (gp, -gp), (gp, gp), (-gp, gp)]\n        self.gauss_w_2x2 = [1.0, 1.0, 1.0, 1.0]\n\n    # --- Core FEM functions: Shape Functions & Isoparametric Mapping ---\n    def N(self, xi, eta):\n        return 0.25 * np.array([(1 - xi) * (1 - eta), (1 + xi) * (1 - eta), (1 + xi) * (1 + eta), (1 - xi) * (1 + eta)])\n    def dN_dxi(self, xi, eta):\n        return 0.25 * np.array([-(1 - eta), (1 - eta), (1 + eta), -(1 + eta)])\n    def dN_deta(self, xi, eta):\n        return 0.25 * np.array([-(1 - xi), -(1 + xi), (1 + xi), (1 - xi)])\n    \n    def get_jacobian_and_related(self, xi, eta):\n        dN_dxi_vals = self.dN_dxi(xi, eta)\n        dN_deta_vals = self.dN_deta(xi, eta)\n        dx_dxi = dN_dxi_vals @ self.x_coords\n        dy_dxi = dN_dxi_vals @ self.y_coords\n        dx_deta = dN_deta_vals @ self.x_coords\n        dy_deta = dN_deta_vals @ self.y_coords\n        J = np.array([[dx_dxi, dx_deta], [dy_dxi, dy_deta]])\n        detJ = np.linalg.det(J)\n        a_xi = np.array([dx_dxi, dy_dxi])\n        a_eta = np.array([dx_deta, dy_deta])\n        return J, detJ, a_xi, a_eta\n\n    def get_interpolated_fields(self, xi, eta):\n        N_vals = self.N(xi, eta)\n        dN_dxi_vals = self.dN_dxi(xi, eta)\n        dN_deta_vals = self.dN_deta(xi, eta)\n        return {\n            'theta_x_h': N_vals @ self.theta_x_nodes,\n            'theta_y_h': N_vals @ self.theta_y_nodes,\n            'dw_h_dxi': dN_dxi_vals @ self.w_nodes,\n            'dw_h_deta': dN_deta_vals @ self.w_nodes\n        }\n\n    # --- Main Test Execution ---\n    def run_tests(self):\n        area = self._calculate_area()\n        K_scale = np.sqrt(self.k_x**2 + self.k_y**2 + self.k_xy**2)\n        \n        if K_scale  1e-12 or area  1e-12:\n            return [True, True, True]\n\n        def get_metric(E_squared):\n            return np.sqrt(E_squared) / (K_scale * area)\n\n        E_std = self._calculate_E_std()\n        M_std = get_metric(E_std)\n\n        E_sri = self._calculate_E_sri()\n        M_sri = get_metric(E_sri)\n\n        E_mitc = self._calculate_E_mitc()\n        M_mitc = get_metric(E_mitc)\n        \n        return [M_std = self.tolerance, M_sri = self.tolerance, M_mitc = self.tolerance]\n\n    def _calculate_area(self):\n        area = 0.0\n        for i, (xi_q, eta_q) in enumerate(self.gauss_pts_2x2):\n            _, detJ, _, _ = self.get_jacobian_and_related(xi_q, eta_q)\n            area += self.gauss_w_2x2[i] * np.abs(detJ)\n        return area\n\n    # --- Shear Evaluation Strategies ---\n    def _calculate_E_std(self):\n        E_squared = 0.0\n        for i, (xi_q, eta_q) in enumerate(self.gauss_pts_2x2):\n            J, detJ, _, _ = self.get_jacobian_and_related(xi_q, eta_q)\n            invJT = np.linalg.inv(J).T\n            fields = self.get_interpolated_fields(xi_q, eta_q)\n            grad_w_h_parent = np.array([fields['dw_h_dxi'], fields['dw_h_deta']])\n            grad_w_h_physical = invJT @ grad_w_h_parent\n            s_std = np.array([fields['theta_x_h'] + grad_w_h_physical[0],\n                              fields['theta_y_h'] + grad_w_h_physical[1]])\n            E_squared += self.gauss_w_2x2[i] * np.abs(detJ) * (s_std @ s_std)\n        return E_squared\n\n    def _calculate_E_sri(self):\n        xi_q, eta_q = 0.0, 0.0\n        J, detJ_center, _, _ = self.get_jacobian_and_related(xi_q, eta_q)\n        invJT = np.linalg.inv(J).T\n        fields = self.get_interpolated_fields(xi_q, eta_q)\n        grad_w_h_parent = np.array([fields['dw_h_dxi'], fields['dw_h_deta']])\n        grad_w_h_physical = invJT @ grad_w_h_parent\n        s_sri_center = np.array([fields['theta_x_h'] + grad_w_h_physical[0],\n                                 fields['theta_y_h'] + grad_w_h_physical[1]])\n        # 1-point quadrature rule over [-1,1]x[-1,1] has weight 4.\n        E_squared = 4.0 * np.abs(detJ_center) * (s_sri_center @ s_sri_center)\n        return E_squared\n\n    def _calculate_E_mitc(self):\n        tying_pts = {'A': (0, -1), 'B': (1, 0), 'C': (0, 1), 'D': (-1, 0)}\n\n        def get_tied_shear(xi, eta, direction):\n            _, _, a_xi, a_eta = self.get_jacobian_and_related(xi, eta)\n            fields = self.get_interpolated_fields(xi, eta)\n            tangent_vec, deriv_w = (a_xi, fields['dw_h_dxi']) if direction == 'xi' else (a_eta, fields['dw_h_deta'])\n            norm_tangent = np.linalg.norm(tangent_vec)\n            if norm_tangent  1e-12: return 0.0\n            unit_tangent = tangent_vec / norm_tangent\n            theta_h = np.array([fields['theta_x_h'], fields['theta_y_h']])\n            return (theta_h @ unit_tangent) + deriv_w / norm_tangent\n        \n        g_xi_A = get_tied_shear(tying_pts['A'][0], tying_pts['A'][1], 'xi')\n        g_xi_C = get_tied_shear(tying_pts['C'][0], tying_pts['C'][1], 'xi')\n        g_eta_B = get_tied_shear(tying_pts['B'][0], tying_pts['B'][1], 'eta')\n        g_eta_D = get_tied_shear(tying_pts['D'][0], tying_pts['D'][1], 'eta')\n\n        E_squared = 0.0\n        for i, (xi_q, eta_q) in enumerate(self.gauss_pts_2x2):\n            p_xi = 0.5 * (1 - eta_q) * g_xi_A + 0.5 * (1 + eta_q) * g_xi_C\n            p_eta = 0.5 * (1 - xi_q) * g_eta_D + 0.5 * (1 + xi_q) * g_eta_B\n            _, detJ, a_xi, a_eta = self.get_jacobian_and_related(xi_q, eta_q)\n            norm_a_xi, norm_a_eta = np.linalg.norm(a_xi), np.linalg.norm(a_eta)\n            if norm_a_xi  1e-12 or norm_a_eta  1e-12 or abs(detJ)  1e-12: continue\n            \n            t_xi, t_eta = a_xi / norm_a_xi, a_eta / norm_a_eta\n            T_mat = np.array([t_xi, t_eta])\n            \n            if np.abs(np.linalg.det(T_mat))  1e-12: continue\n            s_mitc = np.linalg.inv(T_mat) @ np.array([p_xi, p_eta])\n            E_squared += self.gauss_w_2x2[i] * np.abs(detJ) * (s_mitc @ s_mitc)\n        return E_squared\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and run the patch tests.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"nodes\": [(0,0,0), (1,0,0), (1,1,0), (0,1,0)],\n            \"curvatures\": (0.02, 0.01, 0.015)\n        },\n        {\n            \"nodes\": [(0,0,0), (2,0.2,0), (1.8,1.2,0), (-0.1,0.9,0)],\n            \"curvatures\": (0.02, 0.01, 0.015)\n        },\n        {\n            \"nodes\": [(0,0,0), (2,0.2,0), (1.8,1.2,0), (-0.1,0.9,0)],\n            \"curvatures\": (0.05, 0, 0)\n        },\n        {\n            \"nodes\": [(0,0,0), (1.2,0.1,0), (0.9,1.1,0), (-0.2,0.8,0)],\n            \"curvatures\": (0, 0, 0.03)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        tester = PatchTester(nodes=case[\"nodes\"], curvatures=case[\"curvatures\"])\n        result = tester.run_tests()\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n\n```"
        },
        {
            "introduction": "Selective Reduced Integration (SRI) is a common technique to alleviate the shear locking demonstrated in the previous exercise. While effective, this method can introduce non-physical, zero-energy deformation modes known as \"hourglassing,\" which can corrupt the solution. This hands-on problem challenges you to derive these spurious modes from first principles for a bilinear quadrilateral element. You will then implement a robust stabilization scheme that suppresses these modes without reintroducing the original shear locking pathology, a critical skill for developing practical and accurate shell elements .",
            "id": "3581819",
            "problem": "Consider the Mindlin–Reissner plate theory for a four-node bilinear quadrilateral element with three nodal degrees of freedom per node: transverse displacement $w$ and rotations of the normal $\\theta_x$ and $\\theta_y$. The transverse shear strains are defined by $\\gamma_{xz} = \\theta_x + \\partial w / \\partial x$ and $\\gamma_{yz} = \\theta_y + \\partial w / \\partial y$. The transverse shear stress resultants follow $\\mathbf{Q} = k_s \\, G \\, t \\, \\boldsymbol{\\gamma}$, where $k_s$ is the shear correction factor, $G$ is the shear modulus, $t$ is the plate thickness, and $\\boldsymbol{\\gamma} = [\\gamma_{xz}, \\gamma_{yz}]^\\top$.\n\nWork in the setting of a single isoparametric bilinear (four-node) element mapped from the parent square $(\\xi,\\eta) \\in [-1,1] \\times [-1,1]$ to a rectangle of dimensions $h_x$ and $h_y$ in the physical coordinates. At the element center $(\\xi, \\eta) = (0,0)$, the bilinear shape functions are $N_i = \\tfrac{1}{4}$ for $i=1,2,3,4$. The derivatives with respect to the physical coordinates at the center are obtained through the Jacobian of the isoparametric map, giving $\\partial N_i / \\partial x = (2/h_x) \\, \\partial N_i / \\partial \\xi$ and $\\partial N_i / \\partial y = (2/h_y) \\, \\partial N_i / \\partial \\eta$, with $\\partial N_i / \\partial \\xi$ and $\\partial N_i / \\partial \\eta$ evaluated at $(\\xi,\\eta)=(0,0)$ as follows: for node $1$ at $(-1,-1)$, $\\partial N_1/\\partial \\xi = -\\tfrac{1}{4}$, $\\partial N_1/\\partial \\eta = -\\tfrac{1}{4}$; for node $2$ at $(+1,-1)$, $\\partial N_2/\\partial \\xi = +\\tfrac{1}{4}$, $\\partial N_2/\\partial \\eta = -\\tfrac{1}{4}$; for node $3$ at $(+1,+1)$, $\\partial N_3/\\partial \\xi = +\\tfrac{1}{4}$, $\\partial N_3/\\partial \\eta = +\\tfrac{1}{4}$; for node $4$ at $(-1,+1)$, $\\partial N_4/\\partial \\xi = -\\tfrac{1}{4}$, $\\partial N_4/\\partial \\eta = +\\tfrac{1}{4}$.\n\nUsing these quantities, construct the transverse shear strain–displacement operator $\\mathbf{B}_s$ at the element center such that $\\boldsymbol{\\gamma} = \\mathbf{B}_s \\, \\mathbf{d}$, where $\\mathbf{d} \\in \\mathbb{R}^{12}$ collects the nodal degrees of freedom in the order $[w_1,\\theta_{x1},\\theta_{y1},w_2,\\theta_{x2},\\theta_{y2},w_3,\\theta_{x3},\\theta_{y3},w_4,\\theta_{x4},\\theta_{y4}]^\\top$. The transverse shear stiffness matrix under Selective Reduced Integration (SRI), that is, using the single center Gauss point for shear only, is\n$$\n\\mathbf{K}_s = k_s \\, G \\, t \\, A \\, \\mathbf{B}_s^\\top \\mathbf{B}_s,\n$$\nwhere $A = h_x h_y$ is the element area. This reduced integration introduces spurious zero-energy patterns (hourglass modes) in the shear part because $\\text{rank}(\\mathbf{B}_s) \\le 2$ while there are $12$ degrees of freedom.\n\nYour tasks are:\n- Derive the hourglass modes introduced by the SRI shear discretization directly from first principles by computing the nullspace of $\\mathbf{B}_s$ and distinguishing the physically admissible shear-free rigid-body subspace from the spurious hourglass subspace. The rigid-body shear-free subspace is spanned by the three patterns: a constant transverse translation ($w_i$ equal and $\\theta_{xi}=\\theta_{yi}=0$), a rigid rotation about the $y$-axis ($w$ linear in $x$ with $\\theta_x = -\\partial w/\\partial x$ constant and $\\theta_y=0$), and a rigid rotation about the $x$-axis ($w$ linear in $y$ with $\\theta_y = -\\partial w/\\partial y$ constant and $\\theta_x=0$). All mathematical entities you use must be written in LaTeX. For example, you must denote the nullspace of $\\mathbf{B}_s$ as $\\text{Null}(\\mathbf{B}_s)$ and explicitly work with its basis vectors.\n- Propose and implement a stabilization that penalizes only the hourglass subspace without affecting the physically admissible shear-free subspace, thereby suppressing hourglass modes without reintroducing shear locking. Construct a stabilization matrix\n$$\n\\mathbf{K}_{\\text{hg}} = \\eta \\, k_s \\, G \\, t \\, \\frac{A}{L} \\sum_{i=1}^{n_{\\text{hg}}} \\mathbf{h}_i \\mathbf{h}_i^\\top,\n$$\nwhere $\\{\\mathbf{h}_1,\\ldots,\\mathbf{h}_{n_{\\text{hg}}}\\}$ is an orthonormal basis of the hourglass subspace obtained by removing the rigid-body shear-free basis from $\\text{Null}(\\mathbf{B}_s)$, $\\eta$ is a user-defined non-dimensional stabilization parameter, and $L$ is a characteristic length. Take $L = \\sqrt{A}$. You must demonstrate, through computation, that this stabilization leaves constant shear states energetically unchanged.\n- Quantify the hourglass suppression by counting the number of near-zero eigenvalues of $\\mathbf{K}_s$ before stabilization and of $\\mathbf{K}_s + \\mathbf{K}_{\\text{hg}}$ after stabilization, using an absolute tolerance defined as $\\epsilon = 10^{-9} \\, k_s \\, G \\, t \\, A$ on the eigenvalues.\n- Verify that the stabilization does not reintroduce locking by performing a constant shear patch test. For a prescribed constant shear $\\gamma_{xz} = \\gamma_0$ with $\\gamma_0$ a given scalar, set the nodal degrees of freedom to $w_i = 0$, $\\theta_{xi} = \\gamma_0$, and $\\theta_{yi} = 0$ for all nodes. Compute the discrete shear energy\n$$\nU_{\\text{disc}} = \\tfrac{1}{2} \\, \\mathbf{d}^\\top \\mathbf{K} \\, \\mathbf{d},\n$$\nwith $\\mathbf{K} \\in \\{\\mathbf{K}_s, \\mathbf{K}_s + \\mathbf{K}_{\\text{hg}}\\}$, and compare to the exact continuum energy\n$$\nU_{\\text{exact}} = \\tfrac{1}{2} \\, k_s \\, G \\, t \\, A \\, \\gamma_0^2.\n$$\nReport the relative error $e = \\left| U_{\\text{disc}} / U_{\\text{exact}} - 1 \\right|$ as a float.\n\nAngle units are not applicable in this computation. All other quantities may be treated as dimensionless for the purposes of this numerical experiment, and you should output pure numbers without units.\n\nImplementation requirements:\n- Compute $G = E / \\left( 2 (1+\\nu) \\right)$ from the Young’s modulus $E$ and Poisson’s ratio $\\nu$.\n- Build $\\mathbf{B}_s$ using the exact formulas for $N_i$ and $\\partial N_i / \\partial x$, $\\partial N_i / \\partial y$ at $(\\xi,\\eta)=(0,0)$ and the mapping to physical coordinates of a rectangle of size $h_x \\times h_y$.\n- Compute the singular value decomposition of $\\mathbf{B}_s$ to extract $\\text{Null}(\\mathbf{B}_s)$, then remove the rigid-body shear-free subspace using an orthogonal projection. Orthonormalize the remaining hourglass basis.\n- Assemble $\\mathbf{K}_s$, $\\mathbf{K}_{\\text{hg}}$, and the stabilized matrix $\\mathbf{K}_\\text{stab} = \\mathbf{K}_s + \\mathbf{K}_{\\text{hg}}$.\n- Count near-zero eigenvalues with the specified tolerance $\\epsilon$ using the symmetric eigensolver.\n- Perform the constant shear patch test and compute relative errors.\n\nTest suite:\n- Case $1$: $h_x = 1$, $h_y = 1$, $t = 0.2$, $E = 1.0 \\times 10^{10}$, $\\nu = 0.3$, $k_s = 5/6$, $\\eta = 0.1$, $\\gamma_0 = 0.01$.\n- Case $2$: $h_x = 2$, $h_y = 1$, $t = 0.2$, $E = 1.0 \\times 10^{10}$, $\\nu = 0.3$, $k_s = 5/6$, $\\eta = 0.1$, $\\gamma_0 = 0.01$.\n- Case $3$ (edge-thickness variation): $h_x = 1$, $h_y = 1$, $t = 0.01$, $E = 1.0 \\times 10^{10}$, $\\nu = 0.3$, $k_s = 5/6$, $\\eta = 0.1$, $\\gamma_0 = 0.01$.\n\nFor each case, produce the following outputs:\n- The integer count of near-zero eigenvalues of $\\mathbf{K}_s$.\n- The integer count of near-zero eigenvalues of $\\mathbf{K}_\\text{stab}$.\n- The float relative error $e_s$ for the constant shear patch test with $\\mathbf{K}_s$.\n- The float relative error $e_\\text{stab}$ for the constant shear patch test with $\\mathbf{K}_\\text{stab}$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order\n$[$count\\_zero\\_sri\\_case1,count\\_zero\\_stab\\_case1,e\\_s\\_case1,e\\_stab\\_case1,count\\_zero\\_sri\\_case2,count\\_zero\\_stab\\_case2,e\\_s\\_case2,e\\_stab\\_case2,count\\_zero\\_sri\\_case3,count\\_zero\\_stab\\_case3,e\\_s\\_case3,e\\_stab\\_case3$]$.",
            "solution": "The problem is evaluated as valid. It is scientifically grounded, well-posed, objective, and self-contained, representing a standard exercise in the field of computational solid mechanics.\n\n### 1. Theoretical Formulation\n\nThe problem addresses the issue of shear locking and spurious zero-energy modes (hourglassing) in a four-node quadrilateral Mindlin-Reissner plate element under selective reduced integration (SRI). We will derive the necessary matrices from first principles, identify the source of the spurious modes, and implement a stabilization technique.\n\n### 2. Derivation of the Strain-Displacement Operator $\\mathbf{B}_s$\n\nThe displacement and rotation fields within the element are interpolated from the nodal degrees of freedom $\\mathbf{d} \\in \\mathbb{R}^{12}$ using bilinear shape functions $N_i(\\xi, \\eta)$:\n$$ w(\\xi, \\eta) = \\sum_{i=1}^4 N_i(\\xi, \\eta) w_i $$\n$$ \\theta_x(\\xi, \\eta) = \\sum_{i=1}^4 N_i(\\xi, \\eta) \\theta_{xi} $$\n$$ \\theta_y(\\xi, \\eta) = \\sum_{i=1}^4 N_i(\\xi, \\eta) \\theta_{yi} $$\nThe vector of nodal degrees of freedom is ordered as $\\mathbf{d} = [w_1, \\theta_{x1}, \\theta_{y1}, \\dots, w_4, \\theta_{x4}, \\theta_{y4}]^\\top$.\n\nThe transverse shear strains are given by $\\gamma_{xz} = \\theta_x + \\partial w/\\partial x$ and $\\gamma_{yz} = \\theta_y + \\partial w/\\partial y$. Substituting the interpolated fields, we get:\n$$ \\gamma_{xz} = \\sum_{i=1}^4 \\left( N_i \\theta_{xi} + \\frac{\\partial N_i}{\\partial x} w_i \\right) $$\n$$ \\gamma_{yz} = \\sum_{i=1}^4 \\left( N_i \\theta_{yi} + \\frac{\\partial N_i}{\\partial y} w_i \\right) $$\n\nWe express this relationship in matrix form as $\\boldsymbol{\\gamma} = \\mathbf{B}_s \\mathbf{d}$, where $\\boldsymbol{\\gamma} = [\\gamma_{xz}, \\gamma_{yz}]^\\top$. The strain-displacement operator $\\mathbf{B}_s$ is a $2 \\times 12$ matrix composed of four $2 \\times 3$ nodal blocks, $\\mathbf{B}_s = [\\mathbf{B}_{s1}, \\mathbf{B}_{s2}, \\mathbf{B}_{s3}, \\mathbf{B}_{s4}]$, where:\n$$ \\mathbf{B}_{si} = \\begin{bmatrix} \\frac{\\partial N_i}{\\partial x}  N_i  0 \\\\ \\frac{\\partial N_i}{\\partial y}  0  N_i \\end{bmatrix} $$\n\nFor selective reduced integration, these quantities are evaluated at a single Gauss point at the element center, $(\\xi, \\eta) = (0,0)$. At this point, $N_i = 1/4$ for all $i=1, \\dots, 4$. For a rectangular element of size $h_x \\times h_y$, the derivatives of the shape functions with respect to physical coordinates are related to the derivatives in the parent domain by $\\partial N_i/\\partial x = (2/h_x) \\partial N_i/\\partial \\xi$ and $\\partial N_i/\\partial y = (2/h_y) \\partial N_i/\\partial \\eta$. Using the provided values of $\\partial N_i/\\partial \\xi$ and $\\partial N_i/\\partial \\eta$ at the center, we construct the full $\\mathbf{B}_s$ matrix:\n$$ \\mathbf{B}_s = \\frac{1}{4} \\begin{bmatrix}\n-\\frac{2}{h_x}  1  0  \\frac{2}{h_x}  1  0  \\frac{2}{h_x}  1  0  -\\frac{2}{h_x}  1  0 \\\\\n-\\frac{2}{h_y}  0  1  -\\frac{2}{h_y}  0  1  \\frac{2}{h_y}  0  1  \\frac{2}{h_y}  0  1\n\\end{bmatrix} $$\n\n### 3. Nullspace Analysis: Rigid-Body and Hourglass Modes\n\nThe shear stiffness matrix under SRI is $\\mathbf{K}_s = k_s G t A \\mathbf{B}_s^\\top \\mathbf{B}_s$, where $A=h_x h_y$ is the element area. The rank of $\\mathbf{K}_s$ is the same as the rank of $\\mathbf{B}_s$. Since $\\mathbf{B}_s$ is a $2 \\times 12$ matrix with two linearly independent rows, its rank is $2$. By the rank-nullity theorem, the dimension of its nullspace, $\\text{Null}(\\mathbf{B}_s)$, is $12 - 2 = 10$. These $10$ vectors correspond to deformation modes that produce zero shear strain at the center and thus have zero shear energy.\n\nThis $10$-dimensional nullspace consists of both physically meaningful rigid-body modes and non-physical, spurious hourglass modes.\n\n#### Rigid-Body Shear-Free Subspace ($V_{RB}$)\nThe subspace of physically admissible shear-free modes has dimension $3$. Its basis vectors are:\n1.  **Constant transverse translation**: $w_i=c$, $\\theta_{xi}=0$, $\\theta_{yi}=0$. For $c=1$, the vector is $\\mathbf{v}_1 = [1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0]^\\top$.\n2.  **Rigid rotation about the y-axis**: A rotation by an angle $c$ corresponds to the displacement field $w(x) = -c x$. This implies $\\theta_x = -\\partial w/\\partial x = c$ and $\\theta_y = 0$. For nodal coordinates $x_i \\in \\{-h_x/2, h_x/2\\}$, the vector (for $c=1$) is $\\mathbf{v}_2 = [h_x/2, 1, 0, -h_x/2, 1, 0, -h_x/2, 1, 0, h_x/2, 1, 0]^\\top$.\n3.  **Rigid rotation about the x-axis**: A rotation corresponds to $w(y) = c y$. This implies $\\theta_y = -\\partial w/\\partial y = -c$ and $\\theta_x = 0$. For nodal coordinates $y_i \\in \\{-h_y/2, h_y/2\\}$, the vector (for $c=1$) is $\\mathbf{v}_3 = [-h_y/2, 0, -1, -h_y/2, 0, -1, h_y/2, 0, -1, h_y/2, 0, -1]^\\top$.\n\n#### Spurious Hourglass Subspace ($V_{HG}$)\nThe remaining $10 - 3 = 7$ dimensions of $\\text{Null}(\\mathbf{B}_s)$ constitute the hourglass subspace, $V_{HG}$. This subspace is the orthogonal complement of $V_{RB}$ within $\\text{Null}(\\mathbf{B}_s)$, i.e., $V_{HG} = \\text{Null}(\\mathbf{B}_s) \\cap V_{RB}^\\perp$. An orthonormal basis $\\{\\mathbf{h}_1, \\dots, \\mathbf{h}_7\\}$ for $V_{HG}$ is found computationally. First, an orthonormal basis for $\\text{Null}(\\mathbf{B}_s)$ is obtained from the singular value decomposition (SVD) of $\\mathbf{B}_s$. Then, the components of these basis vectors that lie in $V_{RB}$ are removed via orthogonal projection, and the remaining vectors spanning $V_{HG}$ are re-orthonormalized.\n\n### 4. Hourglass Stabilization\n\nTo suppress the spurious modes, a stabilization matrix $\\mathbf{K}_{\\text{hg}}$ is added to $\\mathbf{K}_s$. This matrix must penalize only the hourglass modes, leaving rigid-body motions and constant strain states unaffected. The proposed stabilization matrix is:\n$$ \\mathbf{K}_{\\text{hg}} = \\eta \\, k_s \\, G \\, t \\, \\frac{A}{L} \\sum_{i=1}^{7} \\mathbf{h}_i \\mathbf{h}_i^\\top $$\nwhere $L=\\sqrt{A}$, so $A/L = \\sqrt{A}$. The term $\\mathbf{P}_{HG} = \\sum_{i=1}^{7} \\mathbf{h}_i \\mathbf{h}_i^\\top$ is the projection matrix onto the hourglass subspace $V_{HG}$.\n\nThe stabilized stiffness matrix is $\\mathbf{K}_{\\text{stab}} = \\mathbf{K}_s + \\mathbf{K}_{\\text{hg}}$.\n- For any rigid-body mode $\\mathbf{v} \\in V_{RB}$, $\\mathbf{K}_{\\text{hg}} \\mathbf{v} = \\mathbf{0}$ because $V_{HG}$ and $V_{RB}$ are orthogonal.\n- For any hourglass mode $\\mathbf{h} \\in V_{HG}$, $\\mathbf{K}_s \\mathbf{h} = \\mathbf{0}$, but $\\mathbf{K}_{\\text{hg}} \\mathbf{h}$ is non-zero, providing the necessary stabilization energy.\nConsequently, $\\mathbf{K}_{\\text{stab}}$ has a nullspace of dimension $3$, spanned only by the rigid-body modes. The number of near-zero eigenvalues is thus reduced from $10$ to $3$.\n\n### 5. Constant Shear Patch Test\n\nThis test verifies that the stabilization does not introduce artificial stiffness for constant shear states (i.e., it does not cause shear locking). We consider a state of constant shear $\\gamma_{xz}=\\gamma_0, \\gamma_{yz}=0$. The corresponding nodal displacement vector is $\\mathbf{d}_{\\text{patch}} = [0, \\gamma_0, 0, \\dots, 0, \\gamma_0, 0]^\\top$. The exact continuum energy for this state is $U_{\\text{exact}} = \\frac{1}{2} k_s G t A \\gamma_0^2$.\n\nThe discrete energy is $U_{\\text{disc}} = \\frac{1}{2} \\mathbf{d}_{\\text{patch}}^\\top \\mathbf{K} \\mathbf{d}_{\\text{patch}}$.\nFor the unstabilized case, $\\mathbf{K} = \\mathbf{K}_s$. The discrete strain is $\\boldsymbol{\\gamma}_{\\text{disc}} = \\mathbf{B}_s \\mathbf{d}_{\\text{patch}} = [\\gamma_0, 0]^\\top$, which exactly matches the continuum strain. The discrete energy $U_s = \\frac{1}{2} k_s G t A (\\mathbf{B}_s \\mathbf{d}_{\\text{patch}})^\\top(\\mathbf{B}_s \\mathbf{d}_{\\text{patch}}) = U_{\\text{exact}}$. Thus, the relative error $e_s$ is zero.\n\nFor the stabilized case, $U_{\\text{stab}} = U_s + \\frac{1}{2} \\mathbf{d}_{\\text{patch}}^\\top \\mathbf{K}_{\\text{hg}} \\mathbf{d}_{\\text{patch}}$. The patch test is passed if the stabilization energy is zero, i.e., $\\mathbf{K}_{\\text{hg}} \\mathbf{d}_{\\text{patch}} = \\mathbf{0}$. The constant shear mode $\\mathbf{d}_{\\text{patch}}$ is an energy-producing mode and thus lies in the range of $\\mathbf{B}_s^\\top$. The range of $\\mathbf{B}_s^\\top$ is the orthogonal complement of $\\text{Null}(\\mathbf{B}_s)$. Since $V_{HG} \\subset \\text{Null}(\\mathbf{B}_s)$, the vector $\\mathbf{d}_{\\text{patch}}$ must be orthogonal to every vector in $V_{HG}$. Therefore, $\\mathbf{P}_{HG} \\mathbf{d}_{\\text{patch}} = \\mathbf{0}$, which implies $\\mathbf{K}_{\\text{hg}} \\mathbf{d}_{\\text{patch}} = \\mathbf{0}$. The stabilization energy is indeed zero, and the relative error $e_{\\text{stab}}$ is also zero. This confirms the stabilization is consistent and does not re-introduce locking.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_case(hx, hy, t, E, nu, ks, eta, gamma0):\n    \"\"\"\n    Analyzes a 4-node Mindlin-Reissner plate element with hourglass stabilization.\n    \"\"\"\n    # Derived physical and geometric constants\n    G = E / (2.0 * (1.0 + nu))\n    A = hx * hy\n    L = np.sqrt(A)\n\n    # --- Step 1: Construct the B_s matrix at the element center (xi=0, eta=0) ---\n    # At the center, Ni = 1/4 for all i=1,2,3,4\n    N_val = 1.0 / 4.0\n\n    # Derivatives of shape functions w.r.t. parent coordinates (xi, eta) at the center\n    dN_dxi = np.array([-0.25, 0.25, 0.25, -0.25])\n    dN_deta = np.array([-0.25, -0.25, 0.25, 0.25])\n\n    # Derivatives w.r.t. physical coordinates (x, y) using the Jacobian for a rectangle\n    dN_dx = (2.0 / hx) * dN_dxi\n    dN_dy = (2.0 / hy) * dN_deta\n\n    # Assemble the 2x12 B_s matrix\n    # B_s = [B_s1, B_s2, B_s3, B_s4] where Bi = [[dNi/dx, Ni, 0], [dNi/dy, 0, Ni]]\n    B_s = np.zeros((2, 12))\n    for i in range(4):\n        B_s[0, 3 * i] = dN_dx[i]\n        B_s[0, 3 * i + 1] = N_val\n        B_s[1, 3 * i] = dN_dy[i]\n        B_s[1, 3 * i + 2] = N_val\n        \n    # --- Step 2: Find the nullspace of B_s and separate RBMs from HGMs ---\n    \n    # Orthonormal basis for Null(B_s) using SVD\n    # B_s = U S Vh. The last 10 rows of Vh (for a 2x12 matrix) form the basis for the nullspace.\n    _U, _s, Vh = np.linalg.svd(B_s, full_matrices=True)\n    # The rank is 2. Nullspace dimension is 12 - 2 = 10.\n    # Q_N contains orthonormal column vectors spanning Null(B_s)\n    Q_N = Vh[2:, :].T  # Shape: (12, 10)\n\n    # Rigid Body Mode basis vectors (RBMs)\n    v1 = np.array([1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0], dtype=float)  # Translation\n    v2 = np.array([hx/2, 1, 0, -hx/2, 1, 0, -hx/2, 1, 0, hx/2, 1, 0], dtype=float)  # Rotation about y\n    v3 = np.array([-hy/2, 0, -1, -hy/2, 0, -1, hy/2, 0, -1, hy/2, 0, -1], dtype=float)  # Rotation about x\n    \n    V_RB = np.vstack([v1, v2, v3]).T # Shape: (12, 3)\n\n    # Orthonormal basis for the RBM subspace using QR decomposition\n    Q_R, _ = np.linalg.qr(V_RB) # Shape: (12, 3)\n\n    # Project the nullspace basis onto the RBM basis to find their intersection\n    M = Q_R.T @ Q_N # Shape: (3, 10)\n    \n    # The nullspace of M gives combinations of Null(B_s) basis vectors that are orthogonal \n    # to the RBMs. These are the hourglass modes.\n    # SVD of M: M = Um Sm Vhm. Nullspace of M is spanned by last 7 rows of Vhm.\n    _Um, _sm, Vhm = np.linalg.svd(M)\n    # Rank of M is 3. Nullspace dimension is 10 - 3 = 7.\n    Alpha_T = Vhm[3:, :] # Shape: (7, 10)\n\n    # Orthonormal basis for the hourglass subspace\n    H = Q_N @ Alpha_T.T # Shape: (12, 7)\n\n    # --- Step 3: Construct stiffness and stabilization matrices ---\n    # Shear stiffness matrix (SRI)\n    K_s = ks * G * t * A * (B_s.T @ B_s)\n\n    # Hourglass stabilization matrix\n    K_hg = eta * ks * G * t * L * (H @ H.T)\n\n    # Stabilized stiffness matrix\n    K_stab = K_s + K_hg\n\n    # --- Step 4: Count near-zero eigenvalues ---\n    epsilon = 1e-9 * ks * G * t * A\n\n    eigvals_s = np.linalg.eigvalsh(K_s)\n    count_zero_sri = np.sum(np.abs(eigvals_s)  epsilon)\n\n    eigvals_stab = np.linalg.eigvalsh(K_stab)\n    count_zero_stab = np.sum(np.abs(eigvals_stab)  epsilon)\n    \n    # --- Step 5: Perform constant shear patch test ---\n    # Nodal DOFs for constant shear gamma_xz = gamma0\n    d_patch = np.zeros(12)\n    d_patch[1::3] = gamma0\n\n    # Exact continuum energy\n    U_exact = 0.5 * ks * G * t * A * gamma0**2\n\n    # Discrete energy with K_s\n    U_s_disc = 0.5 * d_patch.T @ K_s @ d_patch\n    e_s = np.abs(U_s_disc / U_exact - 1.0) if U_exact != 0 else 0.0\n\n    # Discrete energy with K_stab\n    U_stab_disc = 0.5 * d_patch.T @ K_stab @ d_patch\n    e_stab = np.abs(U_stab_disc / U_exact - 1.0) if U_exact != 0 else 0.0\n\n    return count_zero_sri, count_zero_stab, float(e_s), float(e_stab)\n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: hx=1, hy=1, t=0.2, E=1e10, nu=0.3, ks=5/6, eta=0.1, gamma0=0.01\n        (1.0, 1.0, 0.2, 1.0e10, 0.3, 5.0/6.0, 0.1, 0.01),\n        # Case 2: hx=2, hy=1, t=0.2, E=1e10, nu=0.3, ks=5/6, eta=0.1, gamma0=0.01\n        (2.0, 1.0, 0.2, 1.0e10, 0.3, 5.0/6.0, 0.1, 0.01),\n        # Case 3: hx=1, hy=1, t=0.01, E=1e10, nu=0.3, ks=5/6, eta=0.1, gamma0=0.01\n        (1.0, 1.0, 0.01, 1.0e10, 0.3, 5.0/6.0, 0.1, 0.01),\n    ]\n\n    results = []\n    for case in test_cases:\n        count_sri, count_stab, err_s, err_stab = solve_case(*case)\n        results.extend([count_sri, count_stab, err_s, err_stab])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Having practically observed the success of mixed-interpolation elements and the complexities of stabilizing reduced-integration schemes, we now turn to the underlying theory. This exercise uses a Ritz approximation within a mixed variational framework, where displacements, rotations, and shear strains are treated as independent fields. By deriving an analytical solution, you will rigorously prove that this formulation is inherently free from shear locking, as its solution converges to the classical Kirchhoff-Love thin plate theory when the thickness $t$ approaches zero. This practice provides the theoretical validation for the advanced element technologies used in modern computational mechanics .",
            "id": "3581855",
            "problem": "Consider the Reissner-Mindlin plate model for a homogeneous, isotropic square plate occupying the domain $\\Omega = (0,1)\\times(0,1)$ with edges simply supported. The transverse displacement is denoted by $w(x,y)$, and the rotations of the director (normal to the mid-surface) are denoted by $\\boldsymbol{\\beta}(x,y)=\\left[\\beta_x(x,y),\\beta_y(x,y)\\right]^T$. The transverse shear strain vector is $\\boldsymbol{\\gamma}(x,y)=\\left[\\gamma_x(x,y),\\gamma_y(x,y)\\right]^T$, and the Reissner-Mindlin kinematic relation is $\\boldsymbol{\\gamma}=\\boldsymbol{\\beta}+\\nabla w$. In a mixed formulation, introduce an independent shear stress-like Lagrange multiplier field $\\boldsymbol{\\lambda}(x,y)$ to weakly enforce the kinematic relation through the constraint term in the Lagrangian. The material has Young’s modulus $E$ (in $\\mathrm{Pa}$), Poisson’s ratio $\\nu$ (dimensionless), thickness $t$ (in $\\mathrm{m}$), and shear modulus $G=E/\\left(2(1+\\nu)\\right)$ (in $\\mathrm{Pa}$). The shear correction factor is $\\kappa_s$ (dimensionless). The plate bending stiffness is $D=\\dfrac{E\\,t^3}{12\\left(1-\\nu^2\\right)}$ (in $\\mathrm{N\\,m}$). The plate is subjected to a spatially uniform transverse load $q$ (in $\\mathrm{N/m^2}$). Angles are in radians.\n\nStarting from the principle of stationary potential energy and the Reissner-Mindlin assumptions, construct a one-mode Ritz approximation with fields\n- $w(x,y)=W\\,\\sin(\\pi x)\\,\\sin(\\pi y)$,\n- $\\beta_x(x,y)=B_x\\,\\cos(\\pi x)\\,\\sin(\\pi y)$,\n- $\\beta_y(x,y)=B_y\\,\\sin(\\pi x)\\,\\cos(\\pi y)$,\n- $\\gamma_x(x,y)=G_x\\,\\cos(\\pi x)\\,\\sin(\\pi y)$,\n- $\\gamma_y(x,y)=G_y\\,\\sin(\\pi x)\\,\\cos(\\pi y)$,\n- $\\lambda_x(x,y)=L_x\\,\\cos(\\pi x)\\,\\sin(\\pi y)$,\n- $\\lambda_y(x,y)=L_y\\,\\sin(\\pi x)\\,\\cos(\\pi y)$,\n\nwith scalar amplitudes $W$, $B_x$, $B_y$, $G_x$, $G_y$, $L_x$, $L_y$. Use the isotropic plate bending energy density derived from the Kirchhoff-Love bending constitutive matrix, and the Reissner-Mindlin shear energy density with $\\kappa_s$ and $G$. Enforce the kinematic relation $\\boldsymbol{\\gamma}=\\boldsymbol{\\beta}+\\nabla w$ weakly using the Lagrange multipliers $\\boldsymbol{\\lambda}$, i.e., add the constraint term $-\\int_{\\Omega}\\boldsymbol{\\lambda}\\cdot\\left(\\boldsymbol{\\gamma}-\\boldsymbol{\\beta}-\\nabla w\\right)\\,\\mathrm{d}\\Omega$ to the total potential energy. Do not add any penalty terms. Derive the linear system of equations for the amplitudes by setting the first variation of the Lagrangian to zero.\n\nThen, for a given set of material and loading parameters, solve the resulting linear system and extract the displacement amplitude $W$. Separately, compute the Kirchhoff-Love thin-plate amplitude $W_{\\mathrm{KL}}$ for the same one-mode $w$-field by minimizing the bending energy in the absence of shear, which yields\n$$\nW_{\\mathrm{KL}}=\\frac{q}{4\\,D\\,\\pi^4}.\n$$\n\nConstruct a program that, for each test thickness $t$, assembles and solves the mixed system to obtain $W$, computes $W_{\\mathrm{KL}}$, and returns the ratio $R(t)=\\dfrac{W}{W_{\\mathrm{KL}}}$. The objective is to numerically verify locking-free behavior as $t\\to 0$ by showing that $R(t)\\to 1$.\n\nUse the following material and loading parameters:\n- $E=210\\times 10^9\\,\\mathrm{Pa}$,\n- $\\nu=0.3$,\n- $\\kappa_s=\\dfrac{5}{6}$,\n- $q=1000\\,\\mathrm{N/m^2}$.\n\nUse the following test suite for plate thickness (in $\\mathrm{m}$):\n- $t=0.5$ (a relatively thick case),\n- $t=0.1$ (moderately thick),\n- $t=0.01$ (thin),\n- $t=0.001$ (very thin),\n- $t=10^{-5}$ (near the thin limit).\n\nYour program should produce a single line of output containing the ratios $R(t)$, in the order of the above test suite, as a comma-separated list of floating-point numbers enclosed in square brackets, rounded to six decimal places (e.g., `[1.000000,0.999000]`). No units are required for the ratios, which are dimensionless.",
            "solution": "The user wants to analyze a mixed-formulation of the Reissner-Mindlin plate theory to verify its locking-free behavior. This involves deriving and solving a system of algebraic equations for the amplitudes of assumed displacement, rotation, shear, and Lagrange multiplier fields.\n\n### Problem Validation\nThe problem is well-defined within the context of computational solid mechanics. It concerns a standard Ritz approximation for a Reissner-Mindlin plate, employing a mixed variational principle to mitigate shear locking. The material properties, geometry, and boundary conditions are clearly specified.\n\nThere is a minor ambiguity in the problem statement regarding the load. The phrase \"spatially uniform transverse load $q$\" is used, but the provided formula for the Kirchhoff-Love deflection, $W_{\\mathrm{KL}}=\\dfrac{q}{4\\,D\\,\\pi^4}$, is characteristic of a sinusoidal load of the form $p(x,y) = q \\sin(\\pi x) \\sin(\\pi y)$, not a uniform one. For a one-mode Ritz approximation with sinusoidal basis functions, it is standard practice to consider only the corresponding Fourier component of the load. A uniform load $q$ has a first Fourier component $q_{11} \\sin(\\pi x)\\sin(\\pi y)$ where $q_{11} = 16q/\\pi^2$. If this were the case, the consistent $W_{KL}$ would be $W_{KL} = 4q/(D\\pi^6)$. The discrepancy suggests that the symbol $q$ in the problem description is intended to represent the amplitude of a sinusoidal load, $p(x,y) = q \\sin(\\pi x) \\sin(\\pi y)$, and the numerical value $q=1000\\,\\mathrm{N/m^2}$ applies to this amplitude. This interpretation renders the problem entirely self-consistent. The problem is therefore deemed **valid** under this standard interpretation.\n\n### Derivation of the Governing Equations\n\nThe total Lagrangian $\\mathcal{L}$ for the mixed formulation is given by:\n$$\n\\mathcal{L} = U_b + U_s - W_{ext} - C\n$$\nwhere $U_b$ is the bending strain energy, $U_s$ is the shear strain energy, $W_{ext}$ is the potential energy of the external load, and $C$ is the constraint term.\n$$\nC = \\int_{\\Omega}\\boldsymbol{\\lambda}\\cdot\\left(\\boldsymbol{\\gamma}-\\boldsymbol{\\beta}-\\nabla w\\right)\\,\\mathrm{d}\\Omega\n$$\n\nThe problem is symmetric with respect to geometry, boundary conditions, and loading (under the sinusoidal interpretation). Therefore, we can assume a symmetric response, which simplifies the Ritz approximations: $B_x=B_y=B$, $G_x=G_y=G$, and $L_x=L_y=L$. The unknowns are the scalar amplitudes $W, B, G, L$.\n\n**1. Bending Strain Energy ($U_b$)**\n\nThe bending energy is $U_b = \\frac{1}{2} \\int_\\Omega \\boldsymbol{\\kappa}^T \\mathbf{C}_b \\boldsymbol{\\kappa} \\,dA$, where $\\mathbf{C}_b$ is the bending constitutive matrix and $\\boldsymbol{\\kappa}$ contains derivatives of the rotations $\\boldsymbol{\\beta}$. With $\\beta_x = B \\cos(\\pi x) \\sin(\\pi y)$ and $\\beta_y = B \\sin(\\pi x) \\cos(\\pi y)$, the energy integral evaluates to:\n$$\nU_b = \\frac{D \\pi^2 B^2}{2}\n$$\n\n**2. Shear Strain Energy ($U_s$)**\n\nThe shear energy is $U_s = \\frac{1}{2} \\int_\\Omega \\boldsymbol{\\gamma}^T \\mathbf{C}_s \\boldsymbol{\\gamma} \\,dA$, with $\\mathbf{C}_s = \\kappa_s G t \\mathbf{I}$. Using the independent shear strain fields $\\gamma_x = G \\cos(\\pi x) \\sin(\\pi y)$ and $\\gamma_y = G \\sin(\\pi x) \\cos(\\pi y)$, the integral becomes:\n$$\nU_s = \\frac{1}{2} \\kappa_s G t \\left( \\int_0^1 \\int_0^1 G^2 \\cos^2(\\pi x)\\sin^2(\\pi y) + G^2 \\sin^2(\\pi x)\\cos^2(\\pi y) \\,dx\\,dy \\right) = \\frac{\\kappa_s G t G^2}{4}\n$$\n\n**3. External Load Potential ($W_{ext}$)**\n\nAs established, the load is taken to be $p(x,y) = q \\sin(\\pi x) \\sin(\\pi y)$. The potential is $W_{ext} = \\int_\\Omega p(x,y) w(x,y) \\,dA$.\n$$\nW_{ext} = \\int_0^1 \\int_0^1 (q \\sin(\\pi x) \\sin(\\pi y)) (W \\sin(\\pi x) \\sin(\\pi y)) \\,dx\\,dy = \\frac{qW}{4}\n$$\n\n**4. Constraint Term ($C$)**\n\nThe constraint term enforces $\\boldsymbol{\\gamma} = \\boldsymbol{\\beta} + \\nabla w$ weakly.\n$$\nC = \\int_\\Omega [\\lambda_x(\\gamma_x - \\beta_x - \\partial_x w) + \\lambda_y(\\gamma_y - \\beta_y - \\partial_y w)] \\,dA\n$$\nSubstituting the symmetric field approximations:\n$$\n\\gamma_x - \\beta_x - \\partial_x w = (G-B-W\\pi) \\cos(\\pi x) \\sin(\\pi y)\n$$\n$$\n\\gamma_y - \\beta_y - \\partial_y w = (G-B-W\\pi) \\sin(\\pi x) \\cos(\\pi y)\n$$\nAnd with $\\lambda_x = L \\cos(\\pi x) \\sin(\\pi y)$ and $\\lambda_y = L \\sin(\\pi x) \\cos(\\pi y)$, the integral becomes:\n$$\nC = \\int_0^1 \\int_0^1 L(G-B-W\\pi)(\\cos^2(\\pi x)\\sin^2(\\pi y) + \\sin^2(\\pi x)\\cos^2(\\pi y)) \\,dx\\,dy = \\frac{L(G-B-W\\pi)}{2}\n$$\n\n**5. Total Lagrangian and System of Equations**\n\nThe resulting Lagrangian is a function of the four amplitudes:\n$$\n\\mathcal{L}(W, B, G, L) = \\frac{D \\pi^2 B^2}{2} + \\frac{\\kappa_s G t G^2}{4} - \\frac{qW}{4} - \\frac{L(G-B-W\\pi)}{2}\n$$\nThe principle of stationary potential energy requires setting the partial derivatives of $\\mathcal{L}$ with respect to each amplitude to zero.\n\n- $\\dfrac{\\partial \\mathcal{L}}{\\partial W} = -\\dfrac{q}{4} - \\dfrac{L(-\\pi)}{2} = 0 \\implies \\dfrac{\\pi L}{2} = \\dfrac{q}{4}$\n- $\\dfrac{\\partial \\mathcal{L}}{\\partial B} = D \\pi^2 B - \\dfrac{L(-1)}{2} = 0 \\implies D \\pi^2 B + \\dfrac{L}{2} = 0$\n- $\\dfrac{\\partial \\mathcal{L}}{\\partial G} = \\dfrac{\\kappa_s G t G}{2} - \\dfrac{L}{2} = 0 \\implies \\kappa_s G t G - L = 0$\n- $\\dfrac{\\partial \\mathcal{L}}{\\partial L} = -\\dfrac{G-B-W\\pi}{2} = 0 \\implies G - B - W\\pi = 0$\n\n**6. Solution for the Amplitudes**\n\nThis system of four linear equations for $(W, B, G, L)$ can be solved sequentially.\n\nFrom $\\dfrac{\\partial \\mathcal{L}}{\\partial W} = 0$:\n$$\nL = \\frac{q}{2\\pi}\n$$\nFrom $\\dfrac{\\partial \\mathcal{L}}{\\partial B} = 0$:\n$$\nB = -\\frac{L}{2D\\pi^2} = -\\frac{q/(2\\pi)}{2D\\pi^2} = -\\frac{q}{4D\\pi^3}\n$$\nFrom $\\dfrac{\\partial \\mathcal{L}}{\\partial G} = 0$:\n$$\nG = \\frac{L}{\\kappa_s G t} = \\frac{q/(2\\pi)}{\\kappa_s G t} = \\frac{q}{2\\pi \\kappa_s G t}\n$$\nFrom $\\dfrac{\\partial \\mathcal{L}}{\\partial L} = 0$:\n$$\nW = \\frac{G-B}{\\pi} = \\frac{1}{\\pi} \\left( \\frac{q}{2\\pi \\kappa_s G t} - \\left(-\\frac{q}{4D\\pi^3}\\right) \\right) = \\frac{q}{2\\pi^2 \\kappa_s G t} + \\frac{q}{4D\\pi^4}\n$$\n\n**7. Ratio Calculation**\n\nThe derived displacement amplitude is $W = \\dfrac{q}{2\\pi^2 \\kappa_s G t} + W_{\\mathrm{KL}}$, where $W_{\\mathrm{KL}} = \\dfrac{q}{4D\\pi^4}$ is the Kirchhoff-Love amplitude provided in the problem. The ratio $R(t) = W/W_{\\mathrm{KL}}$ is:\n$$\nR(t) = \\frac{\\frac{q}{2\\pi^2 \\kappa_s G t} + W_{\\mathrm{KL}}}{W_{\\mathrm{KL}}} = 1 + \\frac{q}{2\\pi^2 \\kappa_s G t} \\frac{1}{W_{\\mathrm{KL}}} = 1 + \\frac{q}{2\\pi^2 \\kappa_s G t} \\frac{4D\\pi^4}{q} = 1 + \\frac{2D\\pi^2}{\\kappa_s G t}\n$$\nTo simplify this for computation, we substitute the expressions for $D$ and $G$:\n$D = \\dfrac{E t^3}{12(1-\\nu^2)}$ and $G = \\dfrac{E}{2(1+\\nu)}$.\nThe term $\\dfrac{D}{Gt}$ becomes:\n$$\n\\frac{D}{Gt} = \\frac{E t^3}{12(1-\\nu^2)} \\frac{1}{\\frac{E}{2(1+\\nu)} t} = \\frac{E t^3}{12(1-\\nu)(1+\\nu)} \\frac{2(1+\\nu)}{E t} = \\frac{t^2}{6(1-\\nu)}\n$$\nSubstituting this back into the expression for $R(t)$:\n$$\nR(t) = 1 + \\frac{2\\pi^2}{\\kappa_s} \\left( \\frac{t^2}{6(1-\\nu)} \\right) = 1 + \\frac{\\pi^2 t^2}{3\\kappa_s(1-\\nu)}\n$$\nThis final expression elegantly shows that as the thickness $t \\to 0$, the ratio $R(t) \\to 1$, demonstrating that this mixed formulation is free from shear locking. This formula will be implemented to compute the results.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the ratio of Reissner-Mindlin to Kirchhoff-Love central displacement\n    for a simply supported square plate under a single-mode sinusoidal load.\n\n    The derivation is based on a one-mode Ritz approximation with a mixed\n    variational formulation, which is shown to be locking-free.\n    \"\"\"\n\n    # --- Given Parameters ---\n    # E = 210e9  # Young's modulus in Pa\n    nu = 0.3      # Poisson's ratio (dimensionless)\n    kappa_s = 5/6 # Shear correction factor (dimensionless)\n    # q = 1000   # Load amplitude in N/m^2\n\n    # The problem specifies E and q, but the final ratio R(t) simplifies to\n    # an expression that is independent of E and q, depending only on t, nu, and kappa_s.\n    \n    # Test suite for plate thickness t (in meters)\n    test_thicknesses = [0.5, 0.1, 0.01, 0.001, 1e-5]\n\n    results = []\n    \n    # --- Calculation Loop ---\n    for t in test_thicknesses:\n        # The ratio R(t) = W / W_KL was derived in the solution description as:\n        # R(t) = 1 + (pi^2 * t^2) / (3 * kappa_s * (1 - nu))\n        \n        numerator = np.pi**2 * t**2\n        denominator = 3 * kappa_s * (1 - nu)\n        \n        ratio = 1 + numerator / denominator\n        \n        results.append(ratio)\n        \n    # --- Format and Print Output ---\n    # The output must be a comma-separated list of floating-point numbers\n    # rounded to six decimal places, enclosed in square brackets.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}