{
    "hands_on_practices": [
        {
            "introduction": "Before applying a new finite element to complex engineering problems, we must first verify its fundamental correctness. The patch test is a cornerstone of this verification process, ensuring that the element can exactly represent basic states of deformation, such as constant curvature, regardless of the mesh geometry. This exercise  guides you through implementing a patch test to confirm that your Euler-Bernoulli beam element's discrete strain energy precisely matches the exact continuum energy, a critical check for ensuring the reliability of your code.",
            "id": "3563483",
            "problem": "Implement a finite element patch test for the Euler–Bernoulli beam in one dimension to verify exact reproduction of a constant curvature state. The objective is to demonstrate, for any mesh of two-node Hermite Euler–Bernoulli beam elements, that when a constant curvature field is imposed through the nodal degrees of freedom, the discrete internal strain energy equals the external work of the equivalent nodal loads to within numerical precision, independent of mesh partitioning. The test must leverage only the Euler–Bernoulli beam kinematics and linear elasticity, and follow a principled derivation, without relying on shortcut formulas.\n\nBegin from the following fundamental base:\n- Kinematics under the Euler–Bernoulli hypothesis: the transverse displacement field is $w(x)$ and the cross-section rotation is $\\theta(x) = \\dfrac{dw}{dx}$. The curvature is $\\kappa(x) = \\dfrac{d\\theta}{dx} = \\dfrac{d^2 w}{dx^2}$.\n- Constitutive relation for bending: the bending moment is $M(x) = E I \\, \\kappa(x)$, where $E$ is Young’s modulus and $I$ is the second moment of area.\n- Internal strain energy: $U = \\dfrac{1}{2}\\int_{0}^{L} E I \\, \\kappa(x)^2 \\, dx$.\n- Principle of virtual work (no axial effects, small deformations): the weak form is $\\int_{0}^{L} E I \\, \\kappa \\, \\delta \\kappa \\, dx = \\delta W_{\\text{ext}}$, where $W_{\\text{ext}}$ is the work of external loads.\n\nDiscretize the beam of length $L$ using standard two-node Hermite Euler–Bernoulli elements with nodal degrees of freedom $w$ (transverse displacement) and $\\theta$ (rotation) at each node. Use cubic Hermite interpolation for $w$ so that $w$ and $\\theta = dw/dx$ are interpolated exactly at nodes. Assemble the global stiffness matrix from the element contributions derived via the weak form and the curvature definition (you must not assume any shortcut expressions without derivation in your implementation design, but you may implement the well-established result in code after justifying it in your solution).\n\nConstruct a constant curvature target field by prescribing nodal values consistent with\n- $w(x) = \\dfrac{\\kappa_0}{2} x^2 + a x + b$,\n- $\\theta(x) = \\dfrac{dw}{dx} = \\kappa_0 x + a$,\nwhere $\\kappa_0$ is a constant curvature, $a$ and $b$ are arbitrary constants, and $\\theta$ is in radians. For the purpose of numerical verification, choose $a = 0$ and $b = 0$ to avoid rigid-body offsets in the demonstration, but your formulation must not rely on this special choice for correctness.\n\nDefine the following verification quantities for any assembled mesh and material parameters:\n- The discrete generalized displacement vector $\\mathbf{u}$ containing $(w_i,\\theta_i)$ at all nodes.\n- The assembled global stiffness matrix $\\mathbf{K}$.\n- The discrete internal strain energy $U_h = \\dfrac{1}{2} \\mathbf{u}^T \\mathbf{K} \\mathbf{u}$.\n- The equivalent nodal load vector $\\mathbf{f}_{\\text{eq}} = \\mathbf{K}\\mathbf{u}$, representing boundary nodal forces and moments that would reproduce the same internal state in a linear system.\n- The external work under linear ramping of loads $W_h = \\dfrac{1}{2} \\mathbf{u}^T \\mathbf{f}_{\\text{eq}}$.\n- The continuum exact energy for constant curvature $U_{\\text{exact}} = \\dfrac{1}{2} E I \\kappa_0^2 L$.\n\nYour program must:\n1. Assemble $\\mathbf{K}$ for arbitrary meshes that partition $[0,L]$ into elements of lengths that sum to $L$.\n2. Construct the nodal vector $\\mathbf{u}$ from the constant curvature field using $\\kappa_0$, with $\\theta$ in radians and $w$ in meters.\n3. Compute $U_h$, $W_h$, and $U_{\\text{exact}}$.\n4. For each test case, return a boolean that is true if and only if both $|U_h - W_h|$ and $|U_h - U_{\\text{exact}}|$ are less than or equal to a tolerance defined as $10^{-10} \\max(1, U_{\\text{exact}})$.\n\nImplement and run the following test suite. For each case, use the given parameters and meshes, and ensure that all physical quantities are interpreted in International System of Units (SI units: meters, Pascals, etc.). Rotations must be in radians. No user input is required.\n\nTest cases:\n- Case 1 (uniform mesh): $L = 1.0$, $E = 2.10 \\times 10^{11}$, $I = 1.0 \\times 10^{-6}$, $\\kappa_0 = 2.0 \\times 10^{-2}$, mesh element lengths $[0.25, 0.25, 0.25, 0.25]$.\n- Case 2 (nonuniform mesh): $L = 2.0$, $E = 7.0 \\times 10^{10}$, $I = 5.0 \\times 10^{-5}$, $\\kappa_0 = 3.0 \\times 10^{-3}$, mesh element lengths $[0.1, 0.4, 0.7, 0.5, 0.3]$.\n- Case 3 (zero curvature edge case): $L = 1.0$, $E = 1.0 \\times 10^{9}$, $I = 1.0 \\times 10^{-4}$, $\\kappa_0 = 0.0$, mesh element lengths $[1/3, 1/3, 1/3]$.\n- Case 4 (high curvature, fine nonuniform mesh): $L = 0.5$, $E = 2.0 \\times 10^{11}$, $I = 1.0 \\times 10^{-8}$, $\\kappa_0 = 50.0$, mesh element lengths $[0.05, 0.10, 0.20, 0.15]$.\n- Case 5 (single element): $L = 1.5$, $E = 1.0 \\times 10^{11}$, $I = 2.0 \\times 10^{-6}$, $\\kappa_0 = 0.1$, mesh element lengths $[1.5]$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list of boolean values enclosed in square brackets (e.g., \"[True,False,True,True,False]\"). The list must be in the same order as the test cases above.",
            "solution": "The problem requires the implementation and verification of a finite element patch test for the Euler-Bernoulli beam. The patch test is a fundamental verification procedure in the finite element method. It tests whether a given finite element formulation can exactly reproduce a state of constant strain (or, in this case, constant curvature) on an arbitrary mesh. Passing the patch test is a necessary condition for the convergence of a finite element formulation.\n\nThe solution is developed from first principles, starting with the weak form of the beam's governing equation, which is derived from the principle of virtual work. For an Euler-Bernoulli beam without axial effects and undergoing small deformations, the weak form is:\n$$\n\\int_{0}^{L} \\delta\\kappa \\, M \\, dx = \\delta W_{\\text{ext}}\n$$\nwhere $L$ is the beam length, $M$ is the bending moment, $\\kappa$ is the curvature, and $\\delta W_{\\text{ext}}$ is the virtual work done by external forces. The symbol $\\delta$ denotes a virtual variation. Using the linear elastic constitutive relation $M(x) = E I \\, \\kappa(x)$, where $E$ is Young's modulus and $I$ is the second moment of area (both assumed constant), the weak form becomes:\n$$\n\\int_{0}^{L} E I \\, \\delta\\kappa \\, \\kappa \\, dx = \\delta W_{\\text{ext}}\n$$\nThe problem is discretized using a mesh of two-node Euler-Bernoulli beam elements. Each element spans between two nodes, and each node possesses two degrees of freedom (DOFs): a transverse displacement $w$ and a rotation $\\theta$. For an element $e$ of length $l_e$ with local coordinate $\\xi \\in [0, l_e]$, the nodal DOFs are collected in the vector $\\mathbf{u}_e = [w_1, \\theta_1, w_2, \\theta_2]^T$.\n\nThe transverse displacement field $w(\\xi)$ within the element is interpolated from the nodal DOFs using cubic Hermite shape functions, $\\mathbf{N}(\\xi)$:\n$$\nw(\\xi) = \\mathbf{N}(\\xi) \\mathbf{u}_e = N_1(\\xi) w_1 + N_2(\\xi) \\theta_1 + N_3(\\xi) w_2 + N_4(\\xi) \\theta_2\n$$\nIn a normalized coordinate system $\\eta = \\xi/l_e \\in [0, 1]$, the shape functions are given by:\n\\begin{align*}\nN_1(\\eta) = 1 - 3\\eta^2 + 2\\eta^3 \\\\\nN_2(\\eta) = l_e (\\eta - 2\\eta^2 + \\eta^3) \\\\\nN_3(\\eta) = 3\\eta^2 - 2\\eta^3 \\\\\nN_4(\\eta) = l_e (-\\eta^2 + \\eta^3)\n\\end{align*}\nThis formulation ensures that both the displacement $w$ and the rotation $\\theta = dw/dx$ are continuous at the nodes.\n\nThe curvature is defined by the Euler-Bernoulli hypothesis as $\\kappa(x) = d^2w/dx^2$. Applying this to the interpolated displacement field, we obtain a relationship between the curvature at any point in the element and the nodal DOFs:\n$$\n\\kappa(\\xi) = \\frac{d^2w}{d\\xi^2} = \\frac{d^2\\mathbf{N}(\\xi)}{d\\xi^2} \\mathbf{u}_e = \\mathbf{B}(\\xi) \\mathbf{u}_e\n$$\nThe row vector $\\mathbf{B}(\\xi)$ is the strain-displacement matrix for the beam element. Its components are the second derivatives of the shape functions with respect to the spatial coordinate $\\xi$. Using the chain rule, $\\frac{d^2}{d\\xi^2} = \\frac{1}{l_e^2} \\frac{d^2}{d\\eta^2}$, the $\\mathbf{B}$ matrix in terms of the normalized coordinate $\\eta$ is:\n$$\n\\mathbf{B}(\\eta) = \\frac{1}{l_e^2} \\left[ (12\\eta - 6), \\ l_e(6\\eta - 4), \\ (6 - 12\\eta), \\ l_e(6\\eta - 2) \\right]\n$$\nThe internal strain energy of a single element, $U_e$, is given by:\n$$\nU_e = \\frac{1}{2} \\int_{0}^{l_e} E I \\, \\kappa(\\xi)^2 \\, d\\xi = \\frac{1}{2} \\int_{0}^{l_e} E I \\, (\\mathbf{B}(\\xi)\\mathbf{u}_e)^T (\\mathbf{B}(\\xi)\\mathbf{u}_e) \\, d\\xi\n$$\nFactoring out the constant nodal DOFs $\\mathbf{u}_e$ from the integral yields the standard quadratic form for energy:\n$$\nU_e = \\frac{1}{2} \\mathbf{u}_e^T \\left( E I \\int_{0}^{l_e} \\mathbf{B}(\\xi)^T \\mathbf{B}(\\xi) \\, d\\xi \\right) \\mathbf{u}_e = \\frac{1}{2} \\mathbf{u}_e^T \\mathbf{K}_e \\mathbf{u}_e\n$$\nHere, $\\mathbf{K}_e$ is the element stiffness matrix. Evaluating the integral by substituting the expression for $\\mathbf{B}(\\eta)$ and changing the integration variable to $\\eta$ (with $d\\xi = l_e d\\eta$) leads to the well-established element stiffness matrix for an Euler-Bernoulli beam element:\n$$\n\\mathbf{K}_e = E I \\int_{0}^{1} \\mathbf{B}(\\eta)^T \\mathbf{B}(\\eta) l_e \\, d\\eta = \\frac{E I}{l_e^3} \\begin{pmatrix} 12  6l_e  -12  6l_e \\\\ 6l_e  4l_e^2  -6l_e  2l_e^2 \\\\ -12  -6l_e  12  -6l_e \\\\ 6l_e  2l_e^2  -6l_e  4l_e^2 \\end{pmatrix}\n$$\nThe global stiffness matrix $\\mathbf{K}$ for the entire beam is assembled by summing the contributions of each element's stiffness matrix $\\mathbf{K}_e$ into the appropriate global DOF locations.\n\nThe patch test proceeds as follows:\n$1$. A mesh is defined, partitioning the beam of total length $L$ into elements. Node coordinates $x_i$ are established.\n$2$. A state of constant curvature $\\kappa_0$ is imposed. This corresponds to an exact displacement field $w(x) = \\frac{\\kappa_0}{2} x^2 + ax + b$ and rotation field $\\theta(x) = \\kappa_0 x + a$. For simplicity, we choose $a=0$ and $b=0$. The nodal DOFs for each node $i$ at position $x_i$ are set to match this field: $w_i = \\frac{\\kappa_0}{2} x_i^2$ and $\\theta_i = \\kappa_0 x_i$. These values populate the global nodal displacement vector $\\mathbf{u}$.\n$3$. The global stiffness matrix $\\mathbf{K}$ is assembled for the specified mesh and material properties ($E, I$).\n$4$. Three key quantities are computed:\n    a. The exact continuum strain energy for constant curvature: $U_{\\text{exact}} = \\frac{1}{2} \\int_{0}^{L} E I \\kappa_0^2 \\, dx = \\frac{1}{2} E I \\kappa_0^2 L$.\n    b. The discrete internal strain energy from the finite element model: $U_h = \\frac{1}{2} \\mathbf{u}^T \\mathbf{K} \\mathbf{u}$.\n    c. The discrete external work, defined via the equivalent nodal loads $\\mathbf{f}_{\\text{eq}} = \\mathbf{K}\\mathbf{u}$: $W_h = \\frac{1}{2} \\mathbf{u}^T \\mathbf{f}_{\\text{eq}}$.\n\nThe test involves two comparisons. First, by definition, $W_h = \\frac{1}{2} \\mathbf{u}^T (\\mathbf{K}\\mathbf{u}) = U_h$. Verifying that $|U_h - W_h|$ is near zero serves as a numerical self-consistency check.\nThe second, and more crucial, comparison is between the discrete energy $U_h$ and the exact energy $U_{\\text{exact}}$. The Hermite cubic shape functions can exactly represent any polynomial of degree up to $3$. The target displacement field $w(x) = \\frac{\\kappa_0}{2} x^2$ is a quadratic polynomial. Therefore, the finite element interpolation within each element, $w_h(x) = \\mathbf{N}(x)\\mathbf{u}_e$, will exactly reproduce the quadratic field since the nodal values in $\\mathbf{u}_e$ are sampled from it. Consequently, the curvature computed from the interpolation, $\\kappa_h(x) = d^2w_h/dx^2$, must be identically equal to the constant $\\kappa_0$ everywhere within the mesh.\nThis means the discrete energy calculation becomes:\n$$\nU_h = \\sum_e U_e = \\sum_e \\frac{1}{2} \\int_{l_e} E I \\kappa_h(x)^2 \\, dx = \\sum_e \\frac{1}{2} \\int_{l_e} E I \\kappa_0^2 \\, dx = \\frac{1}{2} E I \\kappa_0^2 \\sum_e l_e = \\frac{1}{2} E I \\kappa_0^2 L = U_{\\text{exact}}\n$$\nThus, for a correct implementation, the discrete energy must equal the exact energy to within numerical precision, regardless of how the domain $[0,L]$ is partitioned. The test passes if $|U_h - U_{\\text{exact}}|$ is below a specified tolerance.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a finite element patch test for the Euler-Bernoulli beam\n    to verify exact reproduction of a constant curvature state.\n    \"\"\"\n    \n    # Test cases defined in the problem statement.\n    # Format: (L, E, I, kappa_0, mesh_element_lengths)\n    test_cases = [\n        (1.0, 2.10e11, 1.0e-6, 2.0e-2, [0.25, 0.25, 0.25, 0.25]),\n        (2.0, 7.0e10, 5.0e-5, 3.0e-3, [0.1, 0.4, 0.7, 0.5, 0.3]),\n        (1.0, 1.0e9, 1.0e-4, 0.0, [1/3, 1/3, 1/3]),\n        (0.5, 2.0e11, 1.0e-8, 50.0, [0.05, 0.10, 0.20, 0.15]),\n        (1.5, 1.0e11, 2.0e-6, 0.1, [1.5])\n    ]\n\n    results = []\n\n    for case in test_cases:\n        L, E, I, kappa_0, mesh_lengths = case\n        \n        # 1. Generate node coordinates from element lengths\n        node_coords = np.zeros(len(mesh_lengths) + 1)\n        node_coords[1:] = np.cumsum(mesh_lengths)\n        \n        num_nodes = len(node_coords)\n        num_dofs = 2 * num_nodes\n\n        # 2. Construct global nodal displacement vector 'u'\n        # The target displacement field is w(x) = (kappa_0 / 2) * x^2\n        # The target rotation field is theta(x) = kappa_0 * x\n        u = np.zeros(num_dofs)\n        for i in range(num_nodes):\n            x_i = node_coords[i]\n            w_i = 0.5 * kappa_0 * x_i**2\n            theta_i = kappa_0 * x_i\n            u[2*i] = w_i\n            u[2*i + 1] = theta_i\n\n        # 3. Assemble the global stiffness matrix 'K'\n        K = np.zeros((num_dofs, num_dofs))\n        \n        for e, l_e in enumerate(mesh_lengths):\n            # Calculate element stiffness matrix Ke\n            c = E * I / l_e**3\n            Ke = c * np.array([\n                [12, 6*l_e,    -12, 6*l_e],\n                [6*l_e, 4*l_e**2, -6*l_e, 2*l_e**2],\n                [-12, -6*l_e,   12, -6*l_e],\n                [6*l_e, 2*l_e**2, -6*l_e, 4*l_e**2]\n            ])\n            \n            # Assemble Ke into K\n            dof_indices = np.array([2*e, 2*e + 1, 2*(e+1), 2*(e+1) + 1])\n            K[np.ix_(dof_indices, dof_indices)] += Ke\n            \n        # 4. Compute verification quantities\n        U_exact = 0.5 * E * I * kappa_0**2 * L\n        \n        Uh = 0.5 * u.T @ K @ u\n        \n        f_eq = K @ u\n        Wh = 0.5 * u.T @ f_eq\n\n        # 5. Perform the check against the specified tolerance\n        tolerance = 1e-10 * max(1.0, np.abs(U_exact))\n        \n        # Check 1: Numerical self-consistency (Uh vs Wh)\n        check1 = np.abs(Uh - Wh) = tolerance\n        \n        # Check 2: Patch test verification (Uh vs U_exact)\n        check2 = np.abs(Uh - U_exact) = tolerance\n        \n        # The patch test passes if both checks are true\n        results.append(check1 and check2)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, [str(r) for r in results]))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "With the element's basic formulation verified, we can now validate its performance on a classic boundary value problem: the cantilever beam. This practice  involves comparing your finite element results against the exact analytical solution derived from first principles. You will discover a key property of Hermite cubic elements—their ability to exactly represent the cubic deflection field of this problem—which provides an unambiguous benchmark for the correctness of your entire analysis workflow, from assembly to solution.",
            "id": "3563555",
            "problem": "Consider a prismatic, homogeneous, straight cantilever beam of length $L$, bending stiffness $E I$ (with $E$ the Young's modulus and $I$ the second moment of area), clamped at $x=0$ and free at $x=L$, subjected to a concentrated transverse end load $P$ acting at $x=L$. Using the Euler-Bernoulli kinematic assumption that plane cross-sections remain plane and normal to the centerline after deformation, and starting from the force and moment equilibrium of a free-body segment and the moment-curvature relation $M(x) = E I \\, \\kappa(x)$ with $\\kappa(x) = w''(x)$, derive the closed-form transverse deflection field $w(x)$ for $x \\in [0,L]$ under the stated loading and boundary conditions. All rotations $\\theta(x)$ must be treated in radians, and all lengths in meters.\n\nUsing the exact $w(x)$ that you have derived, design and implement a finite element model employing one-dimensional Euler-Bernoulli beam elements with two degrees of freedom per node (transverse displacement $w$ and rotation $\\theta$), standard Hermite cubic interpolation of $w(x)$, and the corresponding consistent element stiffness matrix obtained from the weak form. Assemble the global stiffness matrix for a uniform mesh of $N$ equal-length elements along $[0,L]$, apply the clamped boundary conditions $w(0)=0$ and $\\theta(0)=0$, and apply the nodal end load $P$ at the transverse displacement degree of freedom at $x=L$. Solve for the nodal degrees of freedom.\n\nFor a given mesh with $N$ elements, compute:\n- The normalized $L^2$ error in the transverse deflection,\n$$ e_{L^2}(N) = \\sqrt{\\frac{1}{L} \\int_{0}^{L} \\left(w_{\\mathrm{FE}}(x) - w_{\\mathrm{exact}}(x)\\right)^2 \\, dx}, $$\nwhere $w_{\\mathrm{FE}}(x)$ is the finite element deflection obtained by Hermite cubic interpolation from the solved nodal values, and $w_{\\mathrm{exact}}(x)$ is the closed-form solution you derived. Use numerical quadrature that is sufficiently accurate for polynomials up to degree $6$ to evaluate the integral.\n- The absolute tip deflection error,\n$$ e_{\\mathrm{tip}}(N) = \\left| w_{\\mathrm{FE}}(L) - w_{\\mathrm{exact}}(L) \\right|. $$\n\nUse the following physically consistent parameters expressed in the International System of Units (SI):\n- Young's modulus $E = 2.10 \\times 10^{11}\\ \\mathrm{Pa}$,\n- Second moment of area $I = 6.0 \\times 10^{-6}\\ \\mathrm{m}^4$,\n- Beam length $L = 2.0\\ \\mathrm{m}$,\n- End load $P = 1000\\ \\mathrm{N}$.\n\nAngles must be in radians. Report all error quantities in meters, rounded to $10^{-8}$ meters.\n\nTest Suite:\n- Number of elements $N \\in \\{\\,1,\\,2,\\,4,\\,8\\,\\}$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered by test case with pairs per mesh in the sequence $\\left[e_{L^2}(1), e_{\\mathrm{tip}}(1), e_{L^2}(2), e_{\\mathrm{tip}}(2), e_{L^2}(4), e_{\\mathrm{tip}}(4), e_{L^2}(8), e_{\\mathrm{tip}}(8)\\right]$. Each entry must be a float in meters, rounded to $10^{-8}$ meters, for example,\n$$ \\left[ a_1, b_1, a_2, b_2, a_3, b_3, a_4, b_4 \\right]. $$",
            "solution": "The problem as stated is valid. It is a well-posed problem in structural mechanics, founded on the established principles of Euler-Bernoulli beam theory and the finite element method. All necessary physical parameters, boundary conditions, and geometric data are provided, and they are mutually consistent and physically plausible. The objectives are clearly defined and mathematically formalizable.\n\nWe will proceed with the solution in three parts. First, we derive the exact analytical expression for the transverse deflection, $w_{\\mathrm{exact}}(x)$. Second, we formulate the finite element model. Third, we define the error metrics and analyze the expected outcome.\n\n**1. Analytical Solution for Transverse Deflection**\n\nThe problem concerns a cantilever beam of length $L$ clamped at $x=0$ and subjected to a point load $P$ at the free end $x=L$. We define the transverse deflection $w(x)$ to be positive in the direction of the load (downwards). According to Euler-Bernoulli beam theory, the bending moment $M(x)$ is related to the deflection by the moment-curvature equation:\n$$\nM(x) = EI \\frac{d^2w}{dx^2}\n$$\nwhere $E$ is Young's modulus and $I$ is the second moment of area of the cross-section.\n\nTo determine the bending moment $M(x)$, we consider the static equilibrium of a free-body diagram of the beam segment from an arbitrary position $x$ to the free end at $L$. Summing moments about the cut section at $x$ gives:\n$$\n\\sum M_{\\text{at } x} = M(x) - P(L-x) = 0\n$$\nThis yields the bending moment distribution along the beam:\n$$\nM(x) = P(L-x)\n$$\nSubstituting this into the moment-curvature relation gives a second-order ordinary differential equation for $w(x)$:\n$$\nEI \\frac{d^2w}{dx^2} = P(L-x)\n$$\nWe integrate this equation twice with respect to $x$ to find the deflection. Integrating once yields the rotation (slope) $\\theta(x) = w'(x)$:\n$$\nEI \\frac{dw}{dx} = P\\left(Lx - \\frac{x^2}{2}\\right) + C_1\n$$\nIntegrating a second time yields the deflection $w(x)$:\n$$\nEI w(x) = P\\left(\\frac{Lx^2}{2} - \\frac{x^3}{6}\\right) + C_1 x + C_2\n$$\nThe integration constants $C_1$ and $C_2$ are determined by the boundary conditions at the clamped end ($x=0$).\nThe clamped condition implies zero deflection and zero rotation:\n1.  $w(0) = 0$:\n    $EI w(0) = P(0 - 0) + C_1(0) + C_2 = 0 \\implies C_2 = 0$.\n2.  $\\theta(0) = w'(0) = 0$:\n    $EI w'(0) = P(0 - 0) + C_1 = 0 \\implies C_1 = 0$.\n\nWith both constants being zero, the exact analytical solution for the transverse deflection is:\n$$\nw_{\\mathrm{exact}}(x) = \\frac{P}{EI}\\left(\\frac{Lx^2}{2} - \\frac{x^3}{6}\\right) = \\frac{Px^2}{6EI}(3L-x)\n$$\nThe maximum deflection occurs at the tip ($x=L$):\n$$\nw_{\\mathrm{exact}}(L) = \\frac{PL^3}{3EI}\n$$\n\n**2. Finite Element Formulation**\n\nWe discretize the beam into $N$ one-dimensional Euler-Bernoulli elements of equal length $l_e = L/N$. Each node has two degrees of freedom (DOFs): a transverse displacement $w$ and a rotation $\\theta$. For an element spanning from local coordinate $x=0$ to $x=l_e$, the deflection is interpolated using Hermite cubic shape functions, $\\mathbf{H}(x)$, and the nodal DOFs $\\mathbf{d}^e = [w_1, \\theta_1, w_2, \\theta_2]^T$:\n$$\nw(x) = \\mathbf{H}(x) \\mathbf{d}^e\n$$\nThe element stiffness matrix, $k^e$, is derived from the beam's strain energy, $U_e = \\frac{1}{2}\\int_0^{l_e} EI (w''(x))^2 dx$. For a prismatic element, this results in the standard consistent stiffness matrix:\n$$\nk^e = \\frac{EI}{l_e^3} \\begin{pmatrix}\n12  6l_e  -12  6l_e \\\\\n6l_e  4l_e^2  -6l_e  2l_e^2 \\\\\n-12  -6l_e  12  -6l_e \\\\\n6l_e  2l_e^2  -6l_e  4l_e^2\n\\end{pmatrix}\n$$\nThe global stiffness matrix $\\mathbf{K}$ and force vector $\\mathbf{F}$ for the entire beam are assembled by summing the contributions from each element's matrix. The global system of equations is $\\mathbf{K}\\mathbf{D} = \\mathbf{F}$, where $\\mathbf{D}$ is the vector of all nodal DOFs.\n\nThe clamped boundary conditions at $x=0$ (Node $0$) are $w_0=0$ and $\\theta_0=0$. These are essential boundary conditions, applied by removing the corresponding rows and columns from the global system. The point load $P$ is applied as a nodal force to the displacement DOF at $x=L$ (Node $N$), so the only non-zero entry in the initial force vector is $F_{2N}=P$. After applying the boundary conditions, the reduced linear system is solved for the unknown nodal displacements and rotations.\n\n**3. Error Analysis and Quadrature**\n\nThe normalized $L^2$ error $e_{L^2}(N)$ and the absolute tip deflection error $e_{\\mathrm{tip}}(N)$ are computed to assess the accuracy of the finite element solution $w_{\\mathrm{FE}}(x)$.\n\nAn essential property of the chosen finite element formulation is that the Hermite cubic basis functions can exactly represent any polynomial of degree up to three. The derived analytical solution, $w_{\\mathrm{exact}}(x)$, is a cubic polynomial in $x$. Consequently, the finite element solution must be capable of reproducing the exact solution identically. The nodal displacements and rotations solved by the finite element model will exactly match the values of $w_{\\mathrm{exact}}(x)$ and $w'_{\\mathrm{exact}}(x)$ at the nodes. Since a cubic polynomial is uniquely defined by its values and derivatives at two points, the interpolated solution within each element, $w_{\\mathrm{FE}}(x)$, will be identical to $w_{\\mathrm{exact}}(x)$.\n\nTherefore, the difference $w_{\\mathrm{FE}}(x) - w_{\\mathrm{exact}}(x)$ is theoretically zero for all $x \\in [0,L]$ and for any number of elements $N \\ge 1$. This implies that both error metrics must evaluate to zero:\n$$\ne_{L^2}(N) = 0 \\quad \\text{and} \\quad e_{\\mathrm{tip}}(N) = 0\n$$\nAny non-zero result would be attributable solely to floating-point arithmetic inaccuracies, which are expected to be negligible and fall below the required output precision of $10^{-8}$.\n\nThe calculation of the $L^2$ error requires integrating a polynomial of degree six, $(w_{\\mathrm{FE}}(x) - w_{\\mathrm{exact}}(x))^2$. To perform this integration numerically with sufficient accuracy as requested, a quadrature rule exact for polynomials up to degree $2k-1$ is needed. For degree $6$, we require $2k-1 \\ge 6$, so $k \\ge 3.5$. A $4$-point Gauss-Legendre quadrature rule, which is exact for polynomials up to degree $7$, is therefore appropriate and will be used in the implementation. However, as noted, the integrand itself is identically zero, so the result of the integration will be zero.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the deflection of a cantilever beam using the Finite Element Method\n    and computes the error against the exact analytical solution for various mesh sizes.\n    \"\"\"\n\n    # --- Physical and geometric parameters (SI units) ---\n    E = 2.10e11  # Young's modulus in Pa\n    I = 6.0e-6   # Second moment of area in m^4\n    L = 2.0      # Beam length in m\n    P = 1000.0   # End load in N\n    EI = E * I\n\n    # --- Test Suite ---\n    test_cases_N = [1, 2, 4, 8]\n\n    results = []\n\n    # --- Hermite shape functions and their derivatives ---\n    def get_hermite_shape_functions(x, l):\n        \"\"\"\n        Calculates the value of Hermite cubic shape functions at a given\n        local coordinate x within an element of length l.\n        \"\"\"\n        s = x / l\n        H1 = 1 - 3 * s**2 + 2 * s**3\n        H2 = x * (1 - s)**2\n        H3 = 3 * s**2 - 2 * s**3\n        H4 = x**2 / l * (s - 1)\n        return H1, H2, H3, H4\n\n    # --- Main loop for each test case ---\n    for N in test_cases_N:\n        l_e = L / N  # Element length\n        num_nodes = N + 1\n        num_dofs = 2 * num_nodes\n\n        # --- Element stiffness matrix (k_e) ---\n        c = EI / l_e**3\n        k_e = c * np.array([\n            [12, 6 * l_e, -12, 6 * l_e],\n            [6 * l_e, 4 * l_e**2, -6 * l_e, 2 * l_e**2],\n            [-12, -6 * l_e, 12, -6 * l_e],\n            [6 * l_e, 2 * l_e**2, -6 * l_e, 4 * l_e**2]\n        ])\n\n        # --- Assembly of global stiffness matrix (K) and force vector (F) ---\n        K = np.zeros((num_dofs, num_dofs))\n        F = np.zeros(num_dofs)\n\n        for e in range(N):\n            # Global DOFs for element e (nodes e and e+1)\n            dof_map = [2 * e, 2 * e + 1, 2 * (e + 1), 2 * (e + 1) + 1]\n            for i in range(4):\n                for j in range(4):\n                    K[dof_map[i], dof_map[j]] += k_e[i, j]\n\n        # --- Application of loads ---\n        # Nodal force P at the transverse displacement DOF of node N\n        F[2 * N] = P\n\n        # --- Application of boundary conditions ---\n        # Clamped at x=0 (node 0): w_0 = 0, theta_0 = 0\n        # We solve a reduced system for the unknown DOFs.\n        # Unknown DOFs are from index 2 to the end.\n        unknown_dofs = np.arange(2, num_dofs)\n        K_red = K[np.ix_(unknown_dofs, unknown_dofs)]\n        F_red = F[unknown_dofs]\n\n        # --- Solve for unknown displacements and rotations ---\n        D_red = np.linalg.solve(K_red, F_red)\n        \n        # --- Reconstruct the full DOF vector ---\n        D = np.zeros(num_dofs)\n        D[2:] = D_red\n\n        # --- Error Calculation ---\n\n        # 1. Absolute Tip Deflection Error\n        w_fe_tip = D[2 * N]\n        w_exact_tip = (P * L**3) / (3 * EI)\n        e_tip = np.abs(w_fe_tip - w_exact_tip)\n\n        # 2. Normalized L^2 Error\n        # Get 4-point Gauss-Legendre quadrature points and weights\n        gauss_points, gauss_weights = np.polynomial.legendre.leggauss(4)\n        \n        squared_error_integral = 0.0\n        for e in range(N):\n            x_start = e * l_e\n            # Nodal DOFs for the current element\n            d_e = np.array([D[2 * e], D[2 * e + 1], D[2 * (e + 1)], D[2 * (e + 1) + 1]])\n\n            element_integral = 0.0\n            for i in range(len(gauss_points)):\n                xi = gauss_points[i]\n                wi = gauss_weights[i]\n\n                # Map Gauss point from [-1, 1] to global coordinate in [x_start, x_start + l_e]\n                x_glob = x_start + (l_e / 2.0) * (1 + xi)\n                x_loc = x_glob - x_start\n\n                # Exact solution at the Gauss point\n                w_exact = (P * x_glob**2) / (6.0 * EI) * (3.0 * L - x_glob)\n\n                # FE solution at the Gauss point using Hermite interpolation\n                H = get_hermite_shape_functions(x_loc, l_e)\n                w_fe = H[0] * d_e[0] + H[1] * d_e[1] + H[2] * d_e[2] + H[3] * d_e[3]\n\n                # Add to the element's integral sum\n                element_integral += (w_fe - w_exact)**2 * wi\n            \n            # Add the element's completed integral (with Jacobian factor l_e/2)\n            squared_error_integral += element_integral * (l_e / 2.0)\n        \n        e_l2 = np.sqrt(squared_error_integral / L)\n        \n        # The problem asks for [e_L2, e_tip] pairs\n        results.append(round(e_l2, 8))\n        results.append(round(e_tip, 8))\n\n\n    # --- Final Output ---\n    # Format: [e_L2(1), e_tip(1), e_L2(2), e_tip(2), ...]\n    output_str = \"[\" + \",\".join([f\"{val:.8f}\" for val in results]) + \"]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "A powerful aspect of numerical modeling is understanding not just what a model can do, but also its limitations. The Euler-Bernoulli beam theory is built on the assumption that shear deformation is negligible, an assumption that holds true for slender beams. This hands-on practice  challenges you to design a numerical experiment that exposes the \"spurious stiffness\" of the model when this assumption is violated, comparing your results to the more general Timoshenko beam theory to quantify the error and understand the physical domain where your element is no longer reliable.",
            "id": "3563594",
            "problem": "You are asked to design and implement a self-contained numerical experiment that exposes spurious stiffness when an Euler–Bernoulli beam element is used for a problem where shear deformation dominates. Your program must compute the finite element deflection predicted by the Euler–Bernoulli model and compare it against the reference deflection from a Timoshenko beam model derived from first principles, and then quantify and summarize the qualitative error pattern in the deflection field.\n\nThe physical scenario is a prismatic cantilever beam of rectangular cross-section with width $b$ and height $h$, made of a homogeneous isotropic linear elastic material with Young's modulus $E$ and Poisson's ratio $\\nu$, fixed at $x=0$ and loaded by a vertical concentrated force $P$ at its free end $x=L$. You must model the beam with an Euler–Bernoulli finite element discretization using standard two-node cubic Hermite interpolation for the transverse deflection $w(x)$ and the cross-section rotation $\\theta(x)$, and apply clamped boundary conditions $w(0)=0$ and $\\theta(0)=0$ in radians. The shear correction factor must be taken as $k=5/6$ for a rectangular cross-section. The shear modulus is $G=E/\\left(2(1+\\nu)\\right)$, cross-sectional area is $A=b h$, and second moment of area is $I=b h^3 / 12$. All physical inputs must be in the following units: $E$ in Pascals (Pa), $P$ in Newtons (N), $b$, $h$, and $L$ in meters (m), and the computed deflections must be in meters (m); any rotation is in radians.\n\nStarting from the governing relations of Euler–Bernoulli and Timoshenko beam theory and the equilibrium of a cantilever with a tip load, derive expressions for the exact deflection $w_{\\mathrm{T}}(x)$ in the Timoshenko model and the corresponding Euler–Bernoulli deflection $w_{\\mathrm{EB}}(x)$. Your Euler–Bernoulli finite element must use the standard consistent stiffness matrix based on cubic Hermite interpolation and be assembled for $n_e$ equal-length elements over $[0,L]$, with the end load $P$ applied at the global tip transverse-deflection degree of freedom. You must sample the deflection fields at a set of points that excludes the trivial boundary layer near the clamp to avoid division-by-zero artifacts in relative errors: evaluate over the normalized interval $x \\in [0.1L,\\,L]$.\n\nDefine the following error metrics:\n- The tip-deflection underprediction ratio $r = w_{\\mathrm{EB}}(L) / w_{\\mathrm{T}}(L)$, which is dimensionless.\n- The maximum pointwise relative deflection error over $x \\in [0.1L,\\,L]$ given by $e_{\\max} = \\max_{x \\in [0.1L,L]} \\left( \\left( w_{\\mathrm{T}}(x) - w_{\\mathrm{EB}}(x) \\right) / w_{\\mathrm{T}}(x) \\right )$, which is dimensionless.\n- A boolean flag $m$ that is true if the sampled relative error $e(x)$ decreases monotonically with $x$ over $[0.1L,L]$, and false otherwise.\n\nYour program must apply the following test suite, which varies slenderness and mesh to expose spurious stiffness and its qualitative pattern:\n1. Case A (happy path, slender): $E=210 \\times 10^9$, $\\nu=0.3$, $b=0.02$, $h=0.01$, $L=0.20$, $P=1000$, $n_e=1$.\n2. Case B (moderately thick): $E=210 \\times 10^9$, $\\nu=0.3$, $b=0.02$, $h=0.01$, $L=0.05$, $P=1000$, $n_e=1$.\n3. Case C (thick with mesh refinement): $E=210 \\times 10^9$, $\\nu=0.3$, $b=0.02$, $h=0.01$, $L=0.02$, $P=1000$, $n_e=4$.\n4. Case D (edge case, very short beam): $E=210 \\times 10^9$, $\\nu=0.3$, $b=0.02$, $h=0.01$, $L=0.01$, $P=1000$, $n_e=8$.\n\nFor each case, compute $r$, $e_{\\max}$, and $m$ using the specified units and sampling interval. Your program should produce a single line of output containing the results as a comma-separated list of lists in the order of the test cases, where each inner list contains $[r, e_{\\max}, m]$. For example, the output must have the form $[[r_A,e_{\\max,A},m_A],[r_B,e_{\\max,B},m_B],[r_C,e_{\\max,C},m_C],[r_D,e_{\\max,D},m_D]]$ with all real numbers in decimal form.\n\nThe derivation must start from fundamental relations and definitions, and you must not use any shortcut formulas beyond those derivations. Ensure scientific realism and self-consistency of all parameters. The final program must be complete and runnable, without any external inputs, and must adhere to the specified output format.",
            "solution": "The user has requested a numerical experiment to demonstrate the spurious stiffness of the Euler-Bernoulli beam model in shear-dominated scenarios. This requires deriving the analytical solutions for both Timoshenko and Euler-Bernoulli beam theories, implementing a finite element (FE) model based on Euler-Bernoulli theory, and calculating specified error metrics that compare the FE solution to the more accurate Timoshenko solution.\n\n### Step 1: Analytical Derivations\n\nWe consider a cantilever beam of length $L$ clamped at $x=0$ and subjected to a downward vertical point load $P$ at the free end, $x=L$. We establish a coordinate system with $x$ along the beam's neutral axis and $w(x)$ as the downward transverse deflection.\n\nThe key physical parameters are:\n- Young's modulus: $E$\n- Poisson's ratio: $\\nu$\n- Cross-section width: $b$\n- Cross-section height: $h$\n- Shear correction factor: $k = 5/6$ for a rectangular section\n\nFrom these, we derive:\n- Cross-sectional area: $A = bh$\n- Second moment of area: $I = bh^3/12$\n- Shear modulus: $G = E / (2(1+\\nu))$\n\nFor a cantilever with a tip load $P$, the internal shear force $V(x)$ and bending moment $M(x)$ for any cross-section at $x \\in [0, L]$ are given by static equilibrium:\n$$ V(x) = P $$\n$$ M(x) = P(L-x) $$\nThis sign convention assumes $w$ positive downwards, and $M$ positive when causing tension on the upper fiber (which is not the case here, but the magnitude is what matters for the energy and deflection in the chosen direction). A consistent derivation based on potential energy or direct integration with boundary conditions yields the following results.\n\n#### 1.1. Euler-Bernoulli (EB) Beam Theory\nThis theory neglects shear deformation. The governing relationship is $EI \\frac{d^2w}{dx^2} = M(x)$.\n$$ EI \\frac{d^2w_{\\mathrm{EB}}}{dx^2} = P(L-x) $$\nIntegrating with respect to $x$:\n$$ EI \\frac{dw_{\\mathrm{EB}}}{dx} = P(Lx - \\frac{x^2}{2}) + C_1 $$\nThe clamped boundary condition at $x=0$ imposes zero rotation, $\\frac{dw_{\\mathrm{EB}}}{dx}(0) = 0$, which implies $C_1=0$.\nIntegrating again:\n$$ EI w_{\\mathrm{EB}}(x) = P(\\frac{Lx^2}{2} - \\frac{x^3}{6}) + C_2 $$\nThe clamped boundary condition at $x=0$ imposes zero deflection, $w_{\\mathrm{EB}}(0)=0$, which implies $C_2=0$.\nThus, the exact deflection for the Euler-Bernoulli model is:\n$$ w_{\\mathrm{EB}}(x) = \\frac{P}{EI} \\left( \\frac{Lx^2}{2} - \\frac{x^3}{6} \\right) = \\frac{Px^2}{6EI}(3L-x) $$\n\n#### 1.2. Timoshenko Beam Theory\nThis theory accounts for both bending and shear deformation. The total deflection $w_{\\mathrm{T}}(x)$ is the sum of the deflection due to bending, $w_b(x)$, and the deflection due to shear, $w_s(x)$. The bending component is identical in form to the Euler-Bernoulli solution.\nThe shear deformation is governed by the relation $V = kAG \\gamma_s$, where the shear strain $\\gamma_s = dw_s/dx$.\n$$ \\frac{dw_s}{dx} = \\gamma_s = \\frac{V(x)}{kAG} = \\frac{P}{kAG} $$\nIntegrating with respect to $x$ and applying the boundary condition $w_s(0)=0$:\n$$ w_s(x) = \\int_0^x \\frac{P}{kAG} d\\xi = \\frac{Px}{kAG} $$\nThe total deflection under Timoshenko theory is the superposition of bending and shear effects:\n$$ w_{\\mathrm{T}}(x) = w_b(x) + w_s(x) = \\frac{Px^2}{6EI}(3L-x) + \\frac{Px}{kAG} $$\nThis expression serves as the reference (\"true\") solution against which the Euler-Bernoulli FE model is compared.\n\n### Step 2: Euler-Bernoulli Finite Element Formulation\n\nThe beam is discretized into $n_e$ elements of equal length $l_e = L/n_e$. Each element has two nodes, and each node has two degrees of freedom (DOFs): a transverse displacement $w_i$ and a rotation $\\theta_i$. The element displacement vector is $\\mathbf{d}^e = [w_1, \\theta_1, w_2, \\theta_2]^T$. The element stiffness matrix $\\mathbf{k}^e$ for an Euler-Bernoulli beam element, derived from cubic Hermite shape functions, is:\n$$ \\mathbf{k}^e = \\frac{EI}{l_e^3} \\begin{bmatrix} 12  6l_e  -12  6l_e \\\\ 6l_e  4l_e^2  -6l_e  2l_e^2 \\\\ -12  -6l_e  12  -6l_e \\\\ 6l_e  2l_e^2  -6l_e  4l_e^2 \\end{bmatrix} $$\nThe global stiffness matrix $\\mathbf{K}$ and global force vector $\\mathbf{F}$ are assembled from the element-level contributions. The system has $N_{DOF} = 2(n_e+1)$ total DOFs.\nThe boundary conditions are applied by enforcing $w_0=0$ and $\\theta_0=0$ at the first node ($x=0$). This is typically done by removing the first two rows and columns of $\\mathbf{K}$ and the corresponding entries in the displacement and force vectors.\nThe tip load $P$ is applied to the transverse displacement DOF of the last node (node $n_e$ at $x=L$). The global force vector $\\mathbf{F}$ is zero everywhere except for the entry corresponding to this DOF, which is set to $P$.\nThe reduced system of linear equations, $\\mathbf{K}_{red}\\mathbf{d}_{red} = \\mathbf{F}_{red}$, is solved for the vector of unknown nodal displacements $\\mathbf{d}_{red}$.\n\nAfter solving, the full nodal displacement vector $\\mathbf{d}$ is reconstructed. To find the deflection $w_{FE}(x)$ at an arbitrary point $x$ within an element $e$ (from $x_e$ to $x_e+l_e$), we use Hermite shape function interpolation:\n$$ w_{FE}(x(\\xi)) = N_1(\\xi)w_1 + N_2(\\xi)\\theta_1 + N_3(\\xi)w_2 + N_4(\\xi)\\theta_2 $$\nwhere $\\xi = (x - x_e) / l_e$ is the local coordinate, and $[w_1, \\theta_1, w_2, \\theta_2]$ are the solved nodal DOFs for that element. The shape functions are:\n$$ N_1(\\xi) = 1 - 3\\xi^2 + 2\\xi^3 \\quad , \\quad N_2(\\xi) = l_e(\\xi - 2\\xi^2 + \\xi^3) $$\n$$ N_3(\\xi) = 3\\xi^2 - 2\\xi^3 \\quad \\quad, \\quad N_4(\\xi) = l_e(-\\xi^2 + \\xi^3) $$\nFor this specific problem—a beam loaded only at the nodes with cubic Hermite elements—the finite element solution $w_{FE}(x)$ will exactly match the analytical Euler-Bernoulli solution $w_{\\mathrm{EB}}(x)$, regardless of the number of elements $n_e$. The implementation of the FE solver is nevertheless a requirement of the problem statement.\n\n### Step 3: Error Metric Calculation\n\nThe problem asks to compute three metrics for each test case. As per the problem statement, the symbol $w_{\\mathrm{EB}}$ in the metric definitions refers to the computed FE deflection, which we denote $w_{FE}$.\n\n1.  **Tip-deflection underprediction ratio ($r$)**: This measures how much the EB model underestimates the total tip deflection.\n    $$ r = \\frac{w_{FE}(L)}{w_{\\mathrm{T}}(L)} $$\n    where $w_{FE}(L)$ is the computed transverse displacement at the tip node, and $w_{\\mathrm{T}}(L) = \\frac{PL^3}{3EI} + \\frac{PL}{kAG}$.\n\n2.  **Maximum pointwise relative deflection error ($e_{\\max}$)**: This quantifies the maximum error in the deflection profile over the specified domain.\n    $$ e_{\\max} = \\max_{x \\in [0.1L, L]} \\left( \\frac{w_{\\mathrm{T}}(x) - w_{FE}(x)}{w_{\\mathrm{T}}(x)} \\right) $$\n    This is found by sampling the error function at a high resolution over the interval $[0.1L, L]$ and finding the maximum value.\n\n3.  **Monotonicity flag ($m$)**: This boolean flag indicates whether the relative error function, $e(x) = (w_{\\mathrm{T}}(x) - w_{FE}(x)) / w_{\\mathrm{T}}(x)$, is monotonically decreasing over the sampling interval $[0.1L, L]$. Analytically, we have:\n    $$ e(x) = \\frac{w_s(x)}{w_b(x) + w_s(x)} = \\frac{Px/kAG}{\\frac{Px^2}{6EI}(3L-x) + Px/kAG} = \\frac{1}{\\frac{kAG}{6EI}x(3L-x) + 1} $$\n    The function $f(x) = x(3L-x)$ has a maximum at $x=1.5L$. On the interval $[0.1L, L]$, $f(x)$ is strictly increasing. Therefore, the denominator of $e(x)$ is strictly increasing, which means $e(x)$ must be strictly decreasing. The flag $m$ should be `True` for all cases. The numerical implementation will verify this.\n\nThe program will execute this entire workflow for each of the four test cases provided, which are designed to show how the \"spurious stiffness\" of the Euler-Bernoulli model becomes more pronounced as the beam's slenderness ($L/h$) decreases.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the beam problem for all test cases and prints the formatted result.\n    \"\"\"\n\n    test_cases = [\n        # Case A (slender)\n        {\"E\": 210e9, \"nu\": 0.3, \"b\": 0.02, \"h\": 0.01, \"L\": 0.20, \"P\": 1000, \"ne\": 1},\n        # Case B (moderately thick)\n        {\"E\": 210e9, \"nu\": 0.3, \"b\": 0.02, \"h\": 0.01, \"L\": 0.05, \"P\": 1000, \"ne\": 1},\n        # Case C (thick with mesh refinement)\n        {\"E\": 210e9, \"nu\": 0.3, \"b\": 0.02, \"h\": 0.01, \"L\": 0.02, \"P\": 1000, \"ne\": 4},\n        # Case D (very short beam)\n        {\"E\": 210e9, \"nu\": 0.3, \"b\": 0.02, \"h\": 0.01, \"L\": 0.01, \"P\": 1000, \"ne\": 8},\n    ]\n\n    results = []\n    for case in test_cases:\n        res = compute_metrics(**case)\n        # Format boolean as required for output string\n        results.append(f\"[{res[0]},{res[1]},{str(res[2]).lower()}]\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef compute_metrics(E, nu, b, h, L, P, ne):\n    \"\"\"\n    Computes the error metrics for a single beam problem case.\n    \n    Args:\n        E (float): Young's modulus (Pa)\n        nu (float): Poisson's ratio\n        b (float): Cross-section width (m)\n        h (float): Cross-section height (m)\n        L (float): Beam length (m)\n        P (float): Tip load (N)\n        ne (int): Number of finite elements\n\n    Returns:\n        tuple: A tuple containing (r, e_max, m).\n    \"\"\"\n\n    # 1. Calculate derived physical properties\n    I = (b * h**3) / 12           # Second moment of area\n    A = b * h                     # Cross-sectional area\n    G = E / (2 * (1 + nu))        # Shear modulus\n    k = 5.0 / 6.0                 # Shear correction factor for rectangular section\n    EI = E * I\n    kAG = k * A * G\n\n    # 2. Compute Finite Element solution based on Euler-Bernoulli theory\n    le = L / ne\n    num_nodes = ne + 1\n    num_dofs = 2 * num_nodes\n\n    # Element stiffness matrix\n    ke = (EI / le**3) * np.array([\n        [12, 6 * le, -12, 6 * le],\n        [6 * le, 4 * le**2, -6 * le, 2 * le**2],\n        [-12, -6 * le, 12, -6 * le],\n        [6 * le, 2 * le**2, -6 * le, 4 * le**2]\n    ])\n\n    # Assembly\n    K_global = np.zeros((num_dofs, num_dofs))\n    for i in range(ne):\n        # Connectivity: element i connects node i and i+1\n        # DOFs: (2*i, 2*i+1) and (2*(i+1), 2*(i+1)+1)\n        dof_indices = np.array([2 * i, 2 * i + 1, 2 * (i + 1), 2 * (i + 1) + 1])\n        for r_local, r_global in enumerate(dof_indices):\n            for c_local, c_global in enumerate(dof_indices):\n                K_global[r_global, c_global] += ke[r_local, c_local]\n\n    # Force vector\n    F_global = np.zeros(num_dofs)\n    F_global[-2] = P  # Force P on transverse DOF of the last node\n\n    # Apply boundary conditions (clamped at x=0)\n    # DOFs 0 and 1 (w_0, theta_0) are fixed to zero.\n    dofs_to_keep = np.arange(2, num_dofs)\n    K_reduced = K_global[np.ix_(dofs_to_keep, dofs_to_keep)]\n    F_reduced = F_global[dofs_to_keep]\n\n    # Solve for unknown displacements\n    d_reduced = np.linalg.solve(K_reduced, F_reduced)\n    \n    # Reconstruct full displacement vector\n    d_full = np.zeros(num_dofs)\n    d_full[2:] = d_reduced\n    \n    # 3. Define analytical and FE deflection functions\n    \n    def w_timoshenko(x):\n        term_bending = (P * x**2) / (6 * EI) * (3 * L - x)\n        term_shear = (P * x) / kAG\n        return term_bending + term_shear\n\n    def w_fem_eb(x_coords):\n        x_coords = np.atleast_1d(x_coords)\n        w_vals = np.zeros_like(x_coords, dtype=float)\n        \n        for i, x in enumerate(x_coords):\n            if x == L:\n                elem_idx = ne - 1\n            else:\n                elem_idx = int(x // le)\n            \n            x_e = elem_idx * le\n            xi = (x - x_e) / le\n            \n            w1_idx, th1_idx = 2 * elem_idx, 2 * elem_idx + 1\n            w2_idx, th2_idx = 2 * (elem_idx + 1), 2 * (elem_idx + 1) + 1\n            \n            d_elem = np.array([d_full[w1_idx], d_full[th1_idx], d_full[w2_idx], d_full[th2_idx]])\n\n            N1 = 1 - 3 * xi**2 + 2 * xi**3\n            N2 = le * (xi - 2 * xi**2 + xi**3)\n            N3 = 3 * xi**2 - 2 * xi**3\n            N4 = le * (-xi**2 + xi**3)\n            \n            shape_funcs = np.array([N1, N2, N3, N4])\n            w_vals[i] = np.dot(shape_funcs, d_elem)\n            \n        return w_vals if len(x_coords) > 1 else w_vals[0]\n\n    # 4. Calculate metrics\n    \n    # tip-deflection underprediction ratio (r)\n    w_fe_tip = d_full[-2]\n    w_t_tip = w_timoshenko(L)\n    r = w_fe_tip / w_t_tip\n    \n    # maximum pointwise relative deflection error (e_max)\n    # and monotonicity flag (m)\n    sample_points = np.linspace(0.1 * L, L, 1000)\n    w_t_samples = w_timoshenko(sample_points)\n    w_fe_samples = w_fem_eb(sample_points)\n    \n    # Avoid division by zero if w_t is zero anywhere, though not expected here\n    w_t_samples[w_t_samples == 0] = 1e-30 \n    \n    relative_errors = (w_t_samples - w_fe_samples) / w_t_samples\n    e_max = np.max(relative_errors)\n    \n    # Check for monotonicity: error should decrease with x\n    # np.diff(a)[i] = a[i+1] - a[i]. For a decreasing sequence, all diffs must be = 0.\n    # Allowing for small float inaccuracies by using a small tolerance epsilon.\n    m = np.all(np.diff(relative_errors) = 1e-9)\n\n    return r, e_max, m\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}