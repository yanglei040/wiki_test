{
    "hands_on_practices": [
        {
            "introduction": "在将任何有限元单元投入实际应用之前，我们必须首先验证其基本正确性。“分片检验”（Patch Test）是此验证过程的基石。本练习将指导您为欧拉-伯努利梁单元实现一个分片检验 ，通过验证该单元能否精确地再现一个常曲率状态，来确保其满足收敛性的必要条件。",
            "id": "3563483",
            "problem": "实现一维欧拉-伯努利梁的有限元分片检验（patch test），以验证其能否精确再现常曲率状态。其目标是证明，对于由双节点厄米特（Hermite）欧拉-伯努利梁单元构成的任意网格，当通过节点自由度施加一个常曲率场时，离散的内部应变能等于等效节点荷载所做的外力功，两者在数值精度范围内相等，且与网格划分无关。此检验必须仅利用欧拉-伯努利梁运动学和线性弹性理论，并遵循严谨的推导过程，不得依赖任何简化的快捷公式。\n\n从以下基本原理开始：\n- 欧拉-伯努利假设下的运动学：横向位移场为 $w(x)$，横截面转角为 $\\theta(x) = \\dfrac{dw}{dx}$。曲率为 $\\kappa(x) = \\dfrac{d\\theta}{dx} = \\dfrac{d^2 w}{dx^2}$。\n- 弯曲的本构关系：弯矩为 $M(x) = E I \\, \\kappa(x)$，其中 $E$ 是杨氏模量，$I$ 是截面二次矩。\n- 内部应变能：$U = \\dfrac{1}{2}\\int_{0}^{L} E I \\, \\kappa(x)^2 \\, dx$。\n- 虚功原理（无轴向效应，小变形）：其弱形式为 $\\int_{0}^{L} E I \\, \\kappa \\, \\delta \\kappa \\, dx = \\delta W_{\\text{ext}}$，其中 $W_{\\text{ext}}$ 是外荷载所做的功。\n\n使用标准的双节点厄米特欧拉-伯努利单元对长度为 $L$ 的梁进行离散化，每个节点具有 $w$（横向位移）和 $\\theta$（转角）两个节点自由度。对 $w$ 使用三次厄米特插值，从而保证 $w$ 和 $\\theta = dw/dx$ 在节点处得到精确插值。根据弱形式和曲率定义推导出单元贡献，并由此组装全局刚度矩阵（在实现设计中，您必须推导所有公式，不能假设任何快捷表达式，但在代码中可以在论证其合理性后实现已广为接受的结果）。\n\n通过规定与以下公式一致的节点值来构造一个常曲率目标场：\n- $w(x) = \\dfrac{\\kappa_0}{2} x^2 + a x + b$，\n- $\\theta(x) = \\dfrac{dw}{dx} = \\kappa_0 x + a$，\n其中 $\\kappa_0$ 是一个常曲率，$a$ 和 $b$ 是任意常数，$\\theta$ 以弧度为单位。为了便于数值验证，选择 $a = 0$ 和 $b = 0$ 以避免在演示中出现刚体位移，但您的公式的正确性不能依赖于此特殊选择。\n\n为任意组装的网格和材料参数定义以下验证量：\n- 包含所有节点 $(w_i,\\theta_i)$ 的离散广义位移向量 $\\mathbf{u}$。\n- 组装后的全局刚度矩阵 $\\mathbf{K}$。\n- 离散内部应变能 $U_h = \\dfrac{1}{2} \\mathbf{u}^T \\mathbf{K} \\mathbf{u}$。\n- 等效节点荷载向量 $\\mathbf{f}_{\\text{eq}} = \\mathbf{K}\\mathbf{u}$，代表在线性系统中能够再现相同内部状态的边界节点力和力矩。\n- 在荷载线性加载下的外力功 $W_h = \\dfrac{1}{2} \\mathbf{u}^T \\mathbf{f}_{\\text{eq}}$。\n- 常曲率下的连续介质精确能量 $U_{\\text{exact}} = \\dfrac{1}{2} E I \\kappa_0^2 L$。\n\n您的程序必须：\n1. 为将 $[0,L]$ 划分为总长度为 $L$ 的任意网格组装 $\\mathbf{K}$。\n2. 使用 $\\kappa_0$ 从常曲率场构造节点向量 $\\mathbf{u}$，其中 $\\theta$ 以弧度为单位， $w$ 以米为单位。\n3. 计算 $U_h$、$W_h$ 和 $U_{\\text{exact}}$。\n4. 对于每个测试用例，返回一个布尔值，当且仅当 $|U_h - W_h|$ 和 $|U_h - U_{\\text{exact}}|$ 均小于或等于容差 $10^{-10} \\max(1, U_{\\text{exact}})$ 时，该值为真。\n\n实现并运行以下测试套件。对于每个用例，使用给定的参数和网格，并确保所有物理量均以国际单位制（SI单位：米、帕斯卡等）进行解释。转角必须以弧度为单位。无需用户输入。\n\n测试用例：\n- 用例 1 (均匀网格): $L = 1.0$, $E = 2.10 \\times 10^{11}$, $I = 1.0 \\times 10^{-6}$, $\\kappa_0 = 2.0 \\times 10^{-2}$, 网格单元长度 $[0.25, 0.25, 0.25, 0.25]$。\n- 用例 2 (非均匀网格): $L = 2.0$, $E = 7.0 \\times 10^{10}$, $I = 5.0 \\times 10^{-5}$, $\\kappa_0 = 3.0 \\times 10^{-3}$, 网格单元长度 $[0.1, 0.4, 0.7, 0.5, 0.3]$。\n- 用例 3 (零曲率边界情况): $L = 1.0$, $E = 1.0 \\times 10^{9}$, $I = 1.0 \\times 10^{-4}$, $\\kappa_0 = 0.0$, 网格单元长度 $[1/3, 1/3, 1/3]$。\n- 用例 4 (高曲率，细化的非均匀网格): $L = 0.5$, $E = 2.0 \\times 10^{11}$, $I = 1.0 \\times 10^{-8}$, $\\kappa_0 = 50.0$, 网格单元长度 $[0.05, 0.10, 0.20, 0.15]$。\n- 用例 5 (单个单元): $L = 1.5$, $E = 1.0 \\times 10^{11}$, $I = 2.0 \\times 10^{-6}$, $\\kappa_0 = 0.1$, 网格单元长度 $[1.5]$。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个以逗号分隔的布尔值列表，并用方括号括起来（例如，\"[True,False,True,True,False]\"）。该列表的顺序必须与上述测试用例的顺序相同。",
            "solution": "该问题要求实现并验证欧拉-伯努利梁的有限元分片检验。分片检验是有限元方法中一个基本的验证程序。它测试一个给定的有限元格式能否在任意网格上精确地再现一个常应变（或在此情况下为常曲率）的状态。通过分片检验是有限元格式收敛的必要条件。\n\n该解决方案从第一性原理出发，始于梁控制方程的弱形式，该弱形式由虚功原理推导而来。对于一个无轴向效应且经历小变形的欧拉-伯努利梁，其弱形式为：\n$$\n\\int_{0}^{L} \\delta\\kappa \\, M \\, dx = \\delta W_{\\text{ext}}\n$$\n其中 $L$ 是梁的长度，$M$ 是弯矩，$\\kappa$ 是曲率，$\\delta W_{\\text{ext}}$ 是外力所做的虚功。符号 $\\delta$ 表示虚变分。使用线性弹性本构关系 $M(x) = E I \\, \\kappa(x)$，其中杨氏模量 $E$ 和截面二次矩 $I$ 均假定为常数，弱形式变为：\n$$\n\\int_{0}^{L} E I \\, \\delta\\kappa \\, \\kappa \\, dx = \\delta W_{\\text{ext}}\n$$\n该问题使用一个由双节点欧拉-伯努利梁单元组成的网格进行离散化。每个单元连接两个节点，每个节点拥有两个自由度（DOFs）：一个横向位移 $w$ 和一个转角 $\\theta$。对于一个长度为 $l_e$、局部坐标为 $\\xi \\in [0, l_e]$ 的单元 $e$，其节点自由度被收集在向量 $\\mathbf{u}_e = [w_1, \\theta_1, w_2, \\theta_2]^T$ 中。\n\n单元内的横向位移场 $w(\\xi)$ 通过三次厄米特形函数 $\\mathbf{N}(\\xi)$ 从节点自由度插值得到：\n$$\nw(\\xi) = \\mathbf{N}(\\xi) \\mathbf{u}_e = N_1(\\xi) w_1 + N_2(\\xi) \\theta_1 + N_3(\\xi) w_2 + N_4(\\xi) \\theta_2\n$$\n在归一化坐标系 $\\eta = \\xi/l_e \\in [0, 1]$ 中，形函数由以下公式给出：\n\\begin{align*}\nN_1(\\eta) = 1 - 3\\eta^2 + 2\\eta^3 \\\\\nN_2(\\eta) = l_e (\\eta - 2\\eta^2 + \\eta^3) \\\\\nN_3(\\eta) = 3\\eta^2 - 2\\eta^3 \\\\\nN_4(\\eta) = l_e (-\\eta^2 + \\eta^3)\n\\end{align*}\n该公式确保了位移 $w$ 和转角 $\\theta = dw/dx$ 在节点处是连续的。\n\n根据欧拉-伯努利假设，曲率定义为 $\\kappa(x) = d^2w/dx^2$。将此应用于插值位移场，我们得到单元内任意点的曲率与节点自由度之间的关系：\n$$\n\\kappa(\\xi) = \\frac{d^2w}{d\\xi^2} = \\frac{d^2\\mathbf{N}(\\xi)}{d\\xi^2} \\mathbf{u}_e = \\mathbf{B}(\\xi) \\mathbf{u}_e\n$$\n行向量 $\\mathbf{B}(\\xi)$ 是梁单元的应变-位移矩阵。其分量是形函数对空间坐标 $\\xi$ 的二阶导数。使用链式法则 $\\frac{d^2}{d\\xi^2} = \\frac{1}{l_e^2} \\frac{d^2}{d\\eta^2}$，以归一化坐标 $\\eta$ 表示的 $\\mathbf{B}$ 矩阵为：\n$$\n\\mathbf{B}(\\eta) = \\frac{1}{l_e^2} \\left[ (12\\eta - 6), \\ l_e(6\\eta - 4), \\ (6 - 12\\eta), \\ l_e(6\\eta - 2) \\right]\n$$\n单个单元的内部应变能 $U_e$ 由下式给出：\n$$\nU_e = \\frac{1}{2} \\int_{0}^{l_e} E I \\, \\kappa(\\xi)^2 \\, d\\xi = \\frac{1}{2} \\int_{0}^{l_e} E I \\, (\\mathbf{B}(\\xi)\\mathbf{u}_e)^T (\\mathbf{B}(\\xi)\\mathbf{u}_e) \\, d\\xi\n$$\n将常数节点自由度 $\\mathbf{u}_e$ 从积分中提出，得到标准的能量二次型：\n$$\nU_e = \\frac{1}{2} \\mathbf{u}_e^T \\left( E I \\int_{0}^{l_e} \\mathbf{B}(\\xi)^T \\mathbf{B}(\\xi) \\, d\\xi \\right) \\mathbf{u}_e = \\frac{1}{2} \\mathbf{u}_e^T \\mathbf{K}_e \\mathbf{u}_e\n$$\n此处，$\\mathbf{K}_e$ 是单元刚度矩阵。通过代入 $\\mathbf{B}(\\eta)$ 的表达式并更换积分变量为 $\\eta$（其中 $d\\xi = l_e d\\eta$）来计算该积分，可以得到广为接受的欧拉-伯努利梁单元的单元刚度矩阵：\n$$\n\\mathbf{K}_e = E I \\int_{0}^{1} \\mathbf{B}(\\eta)^T \\mathbf{B}(\\eta) l_e \\, d\\eta = \\frac{E I}{l_e^3} \\begin{pmatrix} 12  6l_e  -12  6l_e \\\\ 6l_e  4l_e^2  -6l_e  2l_e^2 \\\\ -12  -6l_e  12  -6l_e \\\\ 6l_e  2l_e^2  -6l_e  4l_e^2 \\end{pmatrix}\n$$\n整个梁的全局刚度矩阵 $\\mathbf{K}$ 是通过将每个单元刚度矩阵 $\\mathbf{K}_e$ 的贡献累加到相应的全局自由度位置来组装的。\n\n分片检验按以下步骤进行：\n1. 定义一个网格，将总长度为 $L$ 的梁划分为若干单元。建立节点坐标 $x_i$。\n2. 施加一个常曲率状态 $\\kappa_0$。这对应于一个精确的位移场 $w(x) = \\frac{\\kappa_0}{2} x^2 + ax + b$ 和转角场 $\\theta(x) = \\kappa_0 x + a$。为简化起见，我们选择 $a=0$ 和 $b=0$。将每个位于 $x_i$ 位置的节点 $i$ 的节点自由度设置为与此场匹配：$w_i = \\frac{\\kappa_0}{2} x_i^2$ 和 $\\theta_i = \\kappa_0 x_i$。这些值填充到全局节点位移向量 $\\mathbf{u}$ 中。\n3. 根据指定的网格和材料属性（$E, I$）组装全局刚度矩阵 $\\mathbf{K}$。\n4. 计算三个关键量：\n    a. 常曲率下的精确连续介质应变能：$U_{\\text{exact}} = \\frac{1}{2} \\int_{0}^{L} E I \\kappa_0^2 \\, dx = \\frac{1}{2} E I \\kappa_0^2 L$。\n    b. 来自有限元模型的离散内部应变能：$U_h = \\frac{1}{2} \\mathbf{u}^T \\mathbf{K} \\mathbf{u}$。\n    c. 通过等效节点荷载 $\\mathbf{f}_{\\text{eq}} = \\mathbf{K}\\mathbf{u}$ 定义的离散外力功：$W_h = \\frac{1}{2} \\mathbf{u}^T \\mathbf{f}_{\\text{eq}}$。\n\n该检验包含两个比较。首先，根据定义，$W_h = \\frac{1}{2} \\mathbf{u}^T (\\mathbf{K}\\mathbf{u}) = U_h$。验证 $|U_h - W_h|$ 是否接近于零，可作为数值上的自洽性检查。\n第二个也是更关键的比较，是在离散能量 $U_h$ 和精确能量 $U_{\\text{exact}}$ 之间进行。厄米特三次形函数能够精确表示最高三次的多项式。目标位移场 $w(x) = \\frac{\\kappa_0}{2} x^2$ 是一个二次多项式。因此，由于 $\\mathbf{u}_e$ 中的节点值是从该场中采样的，每个单元内的有限元插值 $w_h(x) = \\mathbf{N}(x)\\mathbf{u}_e$ 将精确地再现该二次场。因此，根据插值计算出的曲率 $\\kappa_h(x) = d^2w_h/dx^2$ 必须在网格内的任何地方都恒等于常数 $\\kappa_0$。\n这意味着离散能量的计算变为：\n$$\nU_h = \\sum_e U_e = \\sum_e \\frac{1}{2} \\int_{l_e} E I \\kappa_h(x)^2 \\, dx = \\sum_e \\frac{1}{2} \\int_{l_e} E I \\kappa_0^2 \\, dx = \\frac{1}{2} E I \\kappa_0^2 \\sum_e l_e = \\frac{1}{2} E I \\kappa_0^2 L = U_{\\text{exact}}\n$$\n因此，对于一个正确的实现，离散能量必须在数值精度范围内等于精确能量，无论区域 $[0,L]$ 如何划分。如果 $|U_h - U_{\\text{exact}}|$ 低于指定的容差，则检验通过。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a finite element patch test for the Euler-Bernoulli beam\n    to verify exact reproduction of a constant curvature state.\n    \"\"\"\n    \n    # Test cases defined in the problem statement.\n    # Format: (L, E, I, kappa_0, mesh_element_lengths)\n    test_cases = [\n        (1.0, 2.10e11, 1.0e-6, 2.0e-2, [0.25, 0.25, 0.25, 0.25]),\n        (2.0, 7.0e10, 5.0e-5, 3.0e-3, [0.1, 0.4, 0.7, 0.5, 0.3]),\n        (1.0, 1.0e9, 1.0e-4, 0.0, [1/3, 1/3, 1/3]),\n        (0.5, 2.0e11, 1.0e-8, 50.0, [0.05, 0.10, 0.20, 0.15]),\n        (1.5, 1.0e11, 2.0e-6, 0.1, [1.5])\n    ]\n\n    results = []\n\n    for case in test_cases:\n        L, E, I, kappa_0, mesh_lengths = case\n        \n        # 1. Generate node coordinates from element lengths\n        node_coords = np.zeros(len(mesh_lengths) + 1)\n        node_coords[1:] = np.cumsum(mesh_lengths)\n        \n        num_nodes = len(node_coords)\n        num_dofs = 2 * num_nodes\n\n        # 2. Construct global nodal displacement vector 'u'\n        # The target displacement field is w(x) = (kappa_0 / 2) * x^2\n        # The target rotation field is theta(x) = kappa_0 * x\n        u = np.zeros(num_dofs)\n        for i in range(num_nodes):\n            x_i = node_coords[i]\n            w_i = 0.5 * kappa_0 * x_i**2\n            theta_i = kappa_0 * x_i\n            u[2*i] = w_i\n            u[2*i + 1] = theta_i\n\n        # 3. Assemble the global stiffness matrix 'K'\n        K = np.zeros((num_dofs, num_dofs))\n        \n        for e, l_e in enumerate(mesh_lengths):\n            # Calculate element stiffness matrix Ke\n            c = E * I / l_e**3\n            Ke = c * np.array([\n                [12, 6*l_e,    -12, 6*l_e],\n                [6*l_e, 4*l_e**2, -6*l_e, 2*l_e**2],\n                [-12, -6*l_e,   12, -6*l_e],\n                [6*l_e, 2*l_e**2, -6*l_e, 4*l_e**2]\n            ])\n            \n            # Assemble Ke into K\n            dof_indices = np.array([2*e, 2*e + 1, 2*(e+1), 2*(e+1) + 1])\n            K[np.ix_(dof_indices, dof_indices)] += Ke\n            \n        # 4. Compute verification quantities\n        U_exact = 0.5 * E * I * kappa_0**2 * L\n        \n        Uh = 0.5 * u.T @ K @ u\n        \n        f_eq = K @ u\n        Wh = 0.5 * u.T @ f_eq\n\n        # 5. Perform the check against the specified tolerance\n        tolerance = 1e-10 * max(1.0, np.abs(U_exact))\n        \n        # Check 1: Numerical self-consistency (Uh vs Wh)\n        check1 = np.abs(Uh - Wh) = tolerance\n        \n        # Check 2: Patch test verification (Uh vs U_exact)\n        check2 = np.abs(Uh - U_exact) = tolerance\n        \n        # The patch test passes if both checks are true\n        results.append(check1 and check2)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在通过了基本的分片检验之后，下一步是评估单元在具有已知解析解的问题上的精度和收敛行为。本实践将对一个经典的悬臂梁问题进行建模 。通过将有限元结果与精确的理论解进行比较，我们不仅可以验证代码实现的正确性，还能深入理解单元的逼近能力及其在特定多项式解空间中的表现。",
            "id": "3563555",
            "problem": "考虑一根长度为 $L$、抗弯刚度为 $E I$（其中 $E$ 为杨氏模量，$I$ 为截面二次矩）的等截面、均质、直悬臂梁。该梁在 $x=0$ 处固支，在 $x=L$ 处自由，并在 $x=L$ 处承受一个集中横向端部荷载 $P$。使用 Euler-Bernoulli 运动学假设（即变形后平面横截面保持为平面且垂直于中性轴），并从自由体微段的力与力矩平衡以及弯矩-曲率关系 $M(x) = E I \\, \\kappa(x)$（其中 $\\kappa(x) = w''(x)$）出发，推导在所述荷载和边界条件下 $x \\in [0,L]$ 区间内的横向挠度场 $w(x)$ 的闭式解。所有转角 $\\theta(x)$ 必须以弧度为单位，所有长度以米为单位。\n\n利用您推导出的精确解 $w(x)$，设计并实现一个有限元模型。该模型使用一维 Euler-Bernoulli 梁单元，每个节点具有两个自由度（横向位移 $w$ 和转角 $\\theta$），采用标准的 Hermite 三次插值函数对 $w(x)$ 进行插值，并使用从弱形式推导出的相应协调单元刚度矩阵。在 $[0,L]$ 区间上为 $N$ 个等长单元组成的均匀网格组装全局刚度矩阵，施加固支边界条件 $w(0)=0$ 和 $\\theta(0)=0$，并在 $x=L$ 处的横向位移自由度上施加节点端部荷载 $P$。求解节点自由度。\n\n对于给定的包含 $N$ 个单元的网格，计算：\n- 横向挠度的归一化 $L^2$ 误差，\n$$ e_{L^2}(N) = \\sqrt{\\frac{1}{L} \\int_{0}^{L} \\left(w_{\\mathrm{FE}}(x) - w_{\\mathrm{exact}}(x)\\right)^2 \\, dx}, $$\n其中 $w_{\\mathrm{FE}}(x)$ 是通过求解出的节点值并使用 Hermite 三次插值得到的有限元挠度，而 $w_{\\mathrm{exact}}(x)$ 是您推导出的闭式解。使用对最高为 6 次的多项式足够精确的数值积分方法来计算该积分。\n- 端点挠度绝对误差，\n$$ e_{\\mathrm{tip}}(N) = \\left| w_{\\mathrm{FE}}(L) - w_{\\mathrm{exact}}(L) \\right|. $$\n\n使用以下以国际单位制（SI）表示的物理一致参数：\n- 杨氏模量 $E = 2.10 \\times 10^{11}\\ \\mathrm{Pa}$，\n- 截面二次矩 $I = 6.0 \\times 10^{-6}\\ \\mathrm{m}^4$，\n- 梁长 $L = 2.0\\ \\mathrm{m}$，\n- 端部荷载 $P = 1000\\ \\mathrm{N}$。\n\n角度必须以弧度为单位。所有误差量以米为单位报告，并四舍五入到 $10^{-8}$ 米。\n\n测试套件：\n- 单元数量 $N \\in \\{\\,1,\\,2,\\,4,\\,8\\,\\}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个由逗号分隔的列表，并用方括号括起来。结果按测试用例排序，每个网格的结果对按以下顺序排列：$\\left[e_{L^2}(1), e_{\\mathrm{tip}}(1), e_{L^2}(2), e_{\\mathrm{tip}}(2), e_{L^2}(4), e_{\\mathrm{tip}}(4), e_{L^2}(8), e_{\\mathrm{tip}}(8)\\right]$。每个条目必须是浮点数，单位为米，四舍五入到 $10^{-8}$ 米，例如，\n$$ \\left[ a_1, b_1, a_2, b_2, a_3, b_3, a_4, b_4 \\right]. $$",
            "solution": "所述问题是有效的。这是一个结构力学中的适定问题，建立在 Euler-Bernoulli 梁理论和有限元法的既定原则之上。所有必需的物理参数、边界条件和几何数据均已提供，并且它们是相互一致且物理上合理的。目标定义清晰，并且可以用数学方法形式化。\n\n我们将分三部分进行求解。首先，我们推导横向挠度 $w_{\\mathrm{exact}}(x)$ 的精确解析表达式。其次，我们构建有限元模型。第三，我们定义误差度量并分析预期结果。\n\n**1. 横向挠度的解析解**\n\n该问题涉及一根长度为 $L$ 的悬臂梁，它在 $x=0$ 处固支，并在自由端 $x=L$ 处承受一个点荷载 $P$。我们定义横向挠度 $w(x)$ 在荷载方向（向下）为正。根据 Euler-Bernoulli 梁理论，弯矩 $M(x)$ 通过弯矩-曲率方程与挠度相关联：\n$$\nM(x) = EI \\frac{d^2w}{dx^2}\n$$\n其中 $E$ 是杨氏模量，$I$ 是横截面的截面二次矩。\n\n为确定弯矩 $M(x)$，我们考虑从任意位置 $x$ 到自由端 $L$ 的梁段的自由体图的静力平衡。对截面 $x$ 处的力矩求和可得：\n$$\n\\sum M_{\\text{at } x} = M(x) - P(L-x) = 0\n$$\n这给出了沿梁的弯矩分布：\n$$\nM(x) = P(L-x)\n$$\n将此代入弯矩-曲率关系，得到一个关于 $w(x)$ 的二阶常微分方程：\n$$\nEI \\frac{d^2w}{dx^2} = P(L-x)\n$$\n我们对该方程关于 $x$ 积分两次以求得挠度。积分一次得到转角（斜率）$\\theta(x) = w'(x)$：\n$$\nEI \\frac{dw}{dx} = P\\left(Lx - \\frac{x^2}{2}\\right) + C_1\n$$\n再次积分得到挠度 $w(x)$：\n$$\nEI w(x) = P\\left(\\frac{Lx^2}{2} - \\frac{x^3}{6}\\right) + C_1 x + C_2\n$$\n积分常数 $C_1$ 和 $C_2$ 由固支端（$x=0$）的边界条件确定。\n固支条件意味着零挠度和零转角：\n1.  $w(0) = 0$:\n    $EI w(0) = P(0 - 0) + C_1(0) + C_2 = 0 \\implies C_2 = 0$。\n2.  $\\theta(0) = w'(0) = 0$:\n    $EI w'(0) = P(0 - 0) + C_1 = 0 \\implies C_1 = 0$。\n\n由于两个常数均为零，横向挠度的精确解析解为：\n$$\nw_{\\mathrm{exact}}(x) = \\frac{P}{EI}\\left(\\frac{Lx^2}{2} - \\frac{x^3}{6}\\right) = \\frac{Px^2}{6EI}(3L-x)\n$$\n最大挠度出现在梁的端点（$x=L$）：\n$$\nw_{\\mathrm{exact}}(L) = \\frac{PL^3}{3EI}\n$$\n\n**2. 有限元公式**\n\n我们将梁离散为 $N$ 个等长度 $l_e = L/N$ 的一维 Euler-Bernoulli 单元。每个节点有两个自由度（DOFs）：一个横向位移 $w$ 和一个转角 $\\theta$。对于一个从局部坐标 $x=0$ 延伸到 $x=l_e$ 的单元，其挠度通过 Hermite 三次形函数 $\\mathbf{H}(x)$ 和节点自由度 $\\mathbf{d}^e = [w_1, \\theta_1, w_2, \\theta_2]^T$ 进行插值：\n$$\nw(x) = \\mathbf{H}(x) \\mathbf{d}^e\n$$\n单元刚度矩阵 $k^e$ 从梁的应变能 $U_e = \\frac{1}{2}\\int_0^{l_e} EI (w''(x))^2 dx$ 导出。对于等截面单元，这得到标准的协调刚度矩阵：\n$$\nk^e = \\frac{EI}{l_e^3} \\begin{pmatrix}\n12  6l_e  -12  6l_e \\\\\n6l_e  4l_e^2  -6l_e  2l_e^2 \\\\\n-12  -6l_e  12  -6l_e \\\\\n6l_e  2l_e^2  -6l_e  4l_e^2\n\\end{pmatrix}\n$$\n整个梁的全局刚度矩阵 $\\mathbf{K}$ 和力向量 $\\mathbf{F}$ 是通过对每个单元矩阵的贡献求和来组装的。全局方程组为 $\\mathbf{K}\\mathbf{D} = \\mathbf{F}$，其中 $\\mathbf{D}$ 是所有节点自由度的向量。\n\n在 $x=0$ 处（节点0）的固支边界条件为 $w_0=0$ 和 $\\theta_0=0$。这些是本质边界条件，通过从全局系统中移除相应的行和列来施加。点荷载 $P$ 作为节点力施加到 $x=L$ 处（节点N）的位移自由度上，因此初始力向量中唯一的非零项是 $F_{2N}=P$。施加边界条件后，求解降阶后的线性系统以获得未知的节点位移和转角。\n\n**3. 误差分析与数值积分**\n\n计算归一化 $L^2$ 误差 $e_{L^2}(N)$ 和端点挠度绝对误差 $e_{\\mathrm{tip}}(N)$，以评估有限元解 $w_{\\mathrm{FE}}(x)$ 的准确性。\n\n所选有限元公式的一个关键特性是，Hermite 三次基函数可以精确表示任何次数不高于三的多项式。我们推导出的解析解 $w_{\\mathrm{exact}}(x)$ 是一个关于 $x$ 的三次多项式。因此，有限元解必须能够完全重现精确解。由有限元模型求解出的节点位移和转角将与节点处的 $w_{\\mathrm{exact}}(x)$ 和 $w'_{\\mathrm{exact}}(x)$ 的值完全匹配。由于一个三次多项式由其在两点处的值和导数唯一确定，因此每个单元内的插值解 $w_{\\mathrm{FE}}(x)$ 将与 $w_{\\mathrm{exact}}(x)$ 完全相同。\n\n因此，对于所有 $x \\in [0,L]$ 和任何单元数 $N \\ge 1$，差值 $w_{\\mathrm{FE}}(x) - w_{\\mathrm{exact}}(x)$ 在理论上都为零。这意味着两种误差度量都必须等于零：\n$$\ne_{L^2}(N) = 0 \\quad \\text{和} \\quad e_{\\mathrm{tip}}(N) = 0\n$$\n任何非零结果都将完全归因于浮点运算误差，预计这些误差可以忽略不计，并且会低于要求的 $10^{-8}$ 输出精度。\n\n$L^2$ 误差的计算需要对一个六次多项式 $(w_{\\mathrm{FE}}(x) - w_{\\mathrm{exact}}(x))^2$ 进行积分。为了如题目要求那样以足够的精度进行数值积分，需要一个对最高为 $2k-1$ 次的多项式精确的求积法则。对于 6 次多项式，我们需要 $2k-1 \\ge 6$，因此 $k \\ge 3.5$。一个 4 点 Gauss-Legendre 求积法则，它对最高为 7 次的多项式是精确的，因此是合适的，并将在实现中使用。然而，如前所述，被积函数本身恒等于零，因此积分结果将为零。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the deflection of a cantilever beam using the Finite Element Method\n    and computes the error against the exact analytical solution for various mesh sizes.\n    \"\"\"\n\n    # --- Physical and geometric parameters (SI units) ---\n    E = 2.10e11  # Young's modulus in Pa\n    I = 6.0e-6   # Second moment of area in m^4\n    L = 2.0      # Beam length in m\n    P = 1000.0   # End load in N\n    EI = E * I\n\n    # --- Test Suite ---\n    test_cases_N = [1, 2, 4, 8]\n\n    results = []\n\n    # --- Hermite shape functions and their derivatives ---\n    def get_hermite_shape_functions(x, l):\n        \"\"\"\n        Calculates the value of Hermite cubic shape functions at a given\n        local coordinate x within an element of length l.\n        \"\"\"\n        s = x / l\n        H1 = 1 - 3 * s**2 + 2 * s**3\n        H2 = x * (1 - s)**2\n        H3 = 3 * s**2 - 2 * s**3\n        H4 = x**2 / l * (s - 1)\n        return H1, H2, H3, H4\n\n    # --- Main loop for each test case ---\n    for N in test_cases_N:\n        l_e = L / N  # Element length\n        num_nodes = N + 1\n        num_dofs = 2 * num_nodes\n\n        # --- Element stiffness matrix (k_e) ---\n        c = EI / l_e**3\n        k_e = c * np.array([\n            [12, 6 * l_e, -12, 6 * l_e],\n            [6 * l_e, 4 * l_e**2, -6 * l_e, 2 * l_e**2],\n            [-12, -6 * l_e, 12, -6 * l_e],\n            [6 * l_e, 2 * l_e**2, -6 * l_e, 4 * l_e**2]\n        ])\n\n        # --- Assembly of global stiffness matrix (K) and force vector (F) ---\n        K = np.zeros((num_dofs, num_dofs))\n        F = np.zeros(num_dofs)\n\n        for e in range(N):\n            # Global DOFs for element e (nodes e and e+1)\n            dof_map = [2 * e, 2 * e + 1, 2 * (e + 1), 2 * (e + 1) + 1]\n            for i in range(4):\n                for j in range(4):\n                    K[dof_map[i], dof_map[j]] += k_e[i, j]\n\n        # --- Application of loads ---\n        # Nodal force P at the transverse displacement DOF of node N\n        F[2 * N] = P\n\n        # --- Application of boundary conditions ---\n        # Clamped at x=0 (node 0): w_0 = 0, theta_0 = 0\n        # We solve a reduced system for the unknown DOFs.\n        # Unknown DOFs are from index 2 to the end.\n        unknown_dofs = np.arange(2, num_dofs)\n        K_red = K[np.ix_(unknown_dofs, unknown_dofs)]\n        F_red = F[unknown_dofs]\n\n        # --- Solve for unknown displacements and rotations ---\n        D_red = np.linalg.solve(K_red, F_red)\n        \n        # --- Reconstruct the full DOF vector ---\n        D = np.zeros(num_dofs)\n        D[2:] = D_red\n\n        # --- Error Calculation ---\n\n        # 1. Absolute Tip Deflection Error\n        w_fe_tip = D[2 * N]\n        w_exact_tip = (P * L**3) / (3 * EI)\n        e_tip = np.abs(w_fe_tip - w_exact_tip)\n        results.append(round(e_tip, 8)) # Note: problem requests e_L2 first. Swapped order. Will fix.\n\n        # 2. Normalized L^2 Error\n        # Get 4-point Gauss-Legendre quadrature points and weights\n        gauss_points, gauss_weights = np.polynomial.legendre.leggauss(4)\n        \n        squared_error_integral = 0.0\n        for e in range(N):\n            x_start = e * l_e\n            # Nodal DOFs for the current element\n            d_e = np.array([D[2 * e], D[2 * e + 1], D[2 * (e + 1)], D[2 * (e + 1) + 1]])\n\n            element_integral = 0.0\n            for i in range(len(gauss_points)):\n                xi = gauss_points[i]\n                wi = gauss_weights[i]\n\n                # Map Gauss point from [-1, 1] to global coordinate in [x_start, x_start + l_e]\n                x_glob = x_start + (l_e / 2.0) * (1 + xi)\n                x_loc = x_glob - x_start\n\n                # Exact solution at the Gauss point\n                w_exact = (P * x_glob**2) / (6.0 * EI) * (3.0 * L - x_glob)\n\n                # FE solution at the Gauss point using Hermite interpolation\n                H = get_hermite_shape_functions(x_loc, l_e)\n                w_fe = H[0] * d_e[0] + H[1] * d_e[1] + H[2] * d_e[2] + H[3] * d_e[3]\n\n                # Add to the element's integral sum\n                element_integral += (w_fe - w_exact)**2 * wi\n            \n            # Add the element's completed integral (with Jacobian factor l_e/2)\n            squared_error_integral += element_integral * (l_e / 2.0)\n        \n        e_l2 = np.sqrt(squared_error_integral / L)\n        \n        # The problem asks for [e_L2, e_tip] pairs, so the previous append was wrong\n        results.pop() # remove e_tip\n        results.append(round(e_l2, 8))\n        results.append(round(e_tip, 8))\n\n\n    # --- Final Output ---\n    # Format: [e_L2(1), e_tip(1), e_L2(2), e_tip(2), ...]\n    output_str = \"[\" + \",\".join(map(str, results)) + \"]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "当我们对梁单元的静力学性能建立信心后，便可将其应用扩展至动力学问题。本练习将使用Newmark时间积分方案，探究梁在无阻尼自由振动下的动力学响应 。此项实践的目标是数值验证一个关键的理论特性：线性系统中的能量守恒，这是评估动力学仿真是否稳定和准确的重要指标。",
            "id": "3563579",
            "problem": "考虑一根无阻尼、无外力的直棱柱 Euler–Bernoulli 梁的横向振动。使用 Euler–Bernoulli 运动学和虚功原理，在经过标准有限元离散化（每个单元内采用三次 Hermite 插值）后，推导空间上的半离散运动方程。其基本出发点是动量平衡的弱形式和线性弹性弯曲理论：弯矩-曲率关系为 $M(x,t) = E I \\kappa(x,t)$，其中 $E$ 是杨氏模量，$I$ 是面积二阶矩；单位长度上的惯性力为 $\\rho A \\, \\ddot{w}(x,t)$，其中 $\\rho$ 是质量密度，$A$ 是横截面积，$w(x,t)$ 是横向位移。证明该半离散模型具有以下形式：\n$$\n\\mathbf{M} \\, \\ddot{\\mathbf{u}}(t) + \\mathbf{K} \\, \\mathbf{u}(t) = \\mathbf{0},\n$$\n其中 $\\mathbf{u}(t)$ 叠加了节点的横向位移和转角，$\\mathbf{M}$ 是协调的对称正定质量矩阵，$\\mathbf{K}$ 是对称半正定刚度矩阵。边界条件使得 $\\mathbf{K}$ 在自由度上是正定的。机械能为\n$$\n\\mathcal{E}(t) = \\tfrac{1}{2} \\, \\dot{\\mathbf{u}}(t)^{\\mathsf{T}} \\mathbf{M} \\, \\dot{\\mathbf{u}}(t) + \\tfrac{1}{2} \\, \\mathbf{u}(t)^{\\mathsf{T}} \\mathbf{K} \\, \\mathbf{u}(t).\n$$\n您将验证平均加速度 Newmark 方法的离散能量守恒性，并量化由浮点舍入引起的偏差。\n\n任务：\n- 从半离散方程出发，仅利用 $\\mathbf{M}$ 和 $\\mathbf{K}$ 是对称的性质以及 Newmark 平均加速度格式使用时间平均的加速度和速度（参数为 $\\beta = 1/4$ 和 $\\gamma = 1/2$）这一特性，在精确算术下推导该方法能为无阻尼、无外力的线性系统精确地保持离散机械能守恒，即对于所有时间步，$\\mathcal{E}_{n+1} = \\mathcal{E}_n$。\n- 实现应用于组装后的半离散梁方程（使用协调质量）的平均加速度 Newmark 格式。使用标准的 $2$ 节点 Euler–Bernoulli 梁有限元（具有 $4$ 个局部自由度：两端的横向位移和转角），并为均匀网格组装全局 $\\mathbf{M}$ 和 $\\mathbf{K}$ 矩阵。通过消除受约束的自由度来施加本质边界条件。以零位移和在自由横向位移自由度上规定的节点速度分布进行初始化，而节点转动速度为零。在每个时间步计算离散机械能，并报告整个模拟过程中与初始能量的最大相对偏差。\n- 使用国际单位制 (SI)：$E$ 以 $\\mathrm{Pa}$ 为单位，$I$ 以 $\\mathrm{m}^4$ 为单位，$\\rho$ 以 $\\mathrm{kg/m^3}$ 为单位，$A$ 以 $\\mathrm{m}^2$ 为单位，长度以 $\\mathrm{m}$ 为单位，时间以 $\\mathrm{s}$ 为单位，角度以弧度为单位。报告的能量偏差是无量纲的。角度必须以弧度为单位。\n\n测试套件：\n对于每种情况，构建梁，组装 $\\mathbf{M}$ 和 $\\mathbf{K}$，施加边界条件，并使用 Newmark 平均加速度方法进行时间积分。对于所有情况，使用相同的材料和几何属性，以及初始速度幅值 $a_{\\mathrm{vel}} = 0.1$，该速度按下面指定的方式以正弦位置模式施加于自由横向位移自由度上，初始位移为零。三种情况如下：\n- 情况 $1$（粗网格，两端固支）：$L = 2.0$，$E = 210 \\times 10^9$，$I = 8.333 \\times 10^{-6}$，$\\rho = 7850$，$A = 0.01$，单元数 $N_e = 2$，边界条件为两端固支（两端的横向位移和转角均固定），时间步长 $\\Delta t = 1.0 \\times 10^{-5}$，总时间 $T = 0.5$。\n- 情况 $2$（中等网格，简支）：相同的 $L, E, I, \\rho, A$；$N_e = 10$，边界条件为简支（两端横向位移固定，转角自由），$\\Delta t = 2.0 \\times 10^{-5}$，$T = 0.2$。\n- 情况 $3$（细化网格，简支）：相同的 $L, E, I, \\rho, A$；$N_e = 20$，边界条件为简支，$\\Delta t = 1.0 \\times 10^{-5}$，$T = 0.1$。\n\n初始速度规定：对于每个节点位置 $x_i = i \\, L / N_e$（$i = 0,\\dots,N_e$），将节点 $i$ 处与横向位移自由度相关的初始速度（如果它是自由度）设置为 $a_{\\mathrm{vel}} \\, \\sin(\\pi x_i/L)$，并将所有转动初始速度设置为零。初始位移为零。从离散方程计算初始加速度。\n\n您的程序必须产生单行输出，其中包含每个案例的最大相对能量偏差，格式为用方括号括起来的逗号分隔列表，每个浮点数四舍五入到 $10$ 位有效数字，例如，`[1.23e-10,4.56e-12,7.89e-11]`。三个输出分别对应情况 $1$、$2$ 和 $3$。\n\n不允许提供提示。不要在问题陈述中提供捷径公式。专注于第一性原理和核心定义。最终的数值答案必须由您的程序计算，无需外部输入或文件。",
            "solution": "该问题要求对无阻尼线性系统的 Newmark 平均加速度方法的能量守恒特性进行理论推导，然后通过数值实现来验证振动的 Euler-Bernoulli 梁的这一特性。数值部分涉及量化由浮点运算产生的微小能量偏差。\n\n首先，我们处理理论推导。无阻尼、无外力线性系统的半离散运动方程如下：\n$$\n\\mathbf{M} \\ddot{\\mathbf{u}}(t) + \\mathbf{K} \\mathbf{u}(t) = \\mathbf{0}\n$$\n其中 $\\mathbf{M}$ 是对称正定质量矩阵，$\\mathbf{K}$ 是对称刚度矩阵，$\\mathbf{u}(t)$ 是广义位移向量。系统的离散机械能是动能和势能之和：\n$$\n\\mathcal{E}(t) = \\mathcal{T}(t) + \\mathcal{V}(t) = \\frac{1}{2} \\dot{\\mathbf{u}}(t)^{\\mathsf{T}} \\mathbf{M} \\dot{\\mathbf{u}}(t) + \\frac{1}{2} \\mathbf{u}(t)^{\\mathsf{T}} \\mathbf{K} \\mathbf{u}(t)\n$$\nNewmark 方法提供了从时间步 $t_n$到 $t_{n+1} = t_n + \\Delta t$ 的位移 $\\mathbf{u}$ 和速度 $\\dot{\\mathbf{u}}$ 的更新规则。对于平均加速度法，Newmark 参数为 $\\gamma = 1/2$ 和 $\\beta = 1/4$。更新规则为：\n$$\n\\mathbf{u}_{n+1} = \\mathbf{u}_n + \\Delta t \\dot{\\mathbf{u}}_n + \\Delta t^2 \\left[ \\left(\\frac{1}{2} - \\beta\\right) \\ddot{\\mathbf{u}}_n + \\beta \\ddot{\\mathbf{u}}_{n+1} \\right] \\\\\n\\dot{\\mathbf{u}}_{n+1} = \\dot{\\mathbf{u}}_n + \\Delta t \\left[ (1 - \\gamma) \\ddot{\\mathbf{u}}_n + \\gamma \\ddot{\\mathbf{u}}_{n+1} \\right]\n$$\n代入 $\\gamma = 1/2$ 和 $\\beta = 1/4$：\n$$\n\\mathbf{u}_{n+1} = \\mathbf{u}_n + \\Delta t \\dot{\\mathbf{u}}_n + \\frac{\\Delta t^2}{4} (\\ddot{\\mathbf{u}}_n + \\ddot{\\mathbf{u}}_{n+1}) \\\\\n\\dot{\\mathbf{u}}_{n+1} = \\dot{\\mathbf{u}}_n + \\frac{\\Delta t}{2} (\\ddot{\\mathbf{u}}_n + \\ddot{\\mathbf{u}}_{n+1})\n$$\n这两个方程可以重新排列，以表明该方法等价于梯形法则。速度更新直接给出了平均加速度关系：\n$$\n\\frac{\\dot{\\mathbf{u}}_{n+1} - \\dot{\\mathbf{u}}_n}{\\Delta t} = \\frac{\\ddot{\\mathbf{u}}_n + \\ddot{\\mathbf{u}}_{n+1}}{2}\n$$\n由此，我们可以写出 $\\ddot{\\mathbf{u}}_n + \\ddot{\\mathbf{u}}_{n+1} = \\frac{2}{\\Delta t}(\\dot{\\mathbf{u}}_{n+1} - \\dot{\\mathbf{u}}_n)$。将此代入位移更新规则：\n$$\n\\mathbf{u}_{n+1} = \\mathbf{u}_n + \\Delta t \\dot{\\mathbf{u}}_n + \\frac{\\Delta t^2}{4} \\frac{2}{\\Delta t}(\\dot{\\mathbf{u}}_{n+1} - \\dot{\\mathbf{u}}_n) = \\mathbf{u}_n + \\Delta t \\dot{\\mathbf{u}}_n + \\frac{\\Delta t}{2}(\\dot{\\mathbf{u}}_{n+1} - \\dot{\\mathbf{u}}_n)\n$$\n重新整理此式，得到平均速度关系：\n$$\n\\frac{\\mathbf{u}_{n+1} - \\mathbf{u}_n}{\\Delta t} = \\frac{\\dot{\\mathbf{u}}_n + \\dot{\\mathbf{u}}_{n+1}}{2}\n$$\n运动方程必须在离散时间点 $t_n$ 和 $t_{n+1}$ 处得到满足。梯形法则在时间步上平均地强制满足运动方程：\n$$\n\\frac{1}{2}(\\mathbf{M} \\ddot{\\mathbf{u}}_n + \\mathbf{K} \\mathbf{u}_n) + \\frac{1}{2}(\\mathbf{M} \\ddot{\\mathbf{u}}_{n+1} + \\mathbf{K} \\mathbf{u}_{n+1}) = \\mathbf{0}\n$$\n$$\n\\mathbf{M} \\left( \\frac{\\ddot{\\mathbf{u}}_n + \\ddot{\\mathbf{u}}_{n+1}}{2} \\right) + \\mathbf{K} \\left( \\frac{\\mathbf{u}_n + \\mathbf{u}_{n+1}}{2} \\right) = \\mathbf{0}\n$$\n代入平均速度和平均加速度规则：\n$$\n\\mathbf{M} \\left( \\frac{\\dot{\\mathbf{u}}_{n+1} - \\dot{\\mathbf{u}}_n}{\\Delta t} \\right) + \\mathbf{K} \\left( \\frac{\\mathbf{u}_n + \\mathbf{u}_{n+1}}{2} \\right) = \\mathbf{0}\n$$\n为证明能量守恒，我们考察离散能量的变化 $\\Delta \\mathcal{E} = \\mathcal{E}_{n+1} - \\mathcal{E}_n$：\n$$\n\\Delta \\mathcal{E} = \\left(\\frac{1}{2} \\dot{\\mathbf{u}}_{n+1}^{\\mathsf{T}} \\mathbf{M} \\dot{\\mathbf{u}}_{n+1} - \\frac{1}{2} \\dot{\\mathbf{u}}_n^{\\mathsf{T}} \\mathbf{M} \\dot{\\mathbf{u}}_n\\right) + \\left(\\frac{1}{2} \\mathbf{u}_{n+1}^{\\mathsf{T}} \\mathbf{K} \\mathbf{u}_{n+1} - \\frac{1}{2} \\mathbf{u}_n^{\\mathsf{T}} \\mathbf{K} \\mathbf{u}_n\\right)\n$$\n利用恒等式 $b^2 - a^2 = (b-a)(b+a)$ 以及 $\\mathbf{M}$ 和 $\\mathbf{K}$ 的对称性：\n$$\n\\Delta \\mathcal{E} = \\frac{1}{2} (\\dot{\\mathbf{u}}_{n+1} - \\dot{\\mathbf{u}}_n)^{\\mathsf{T}} \\mathbf{M} (\\dot{\\mathbf{u}}_{n+1} + \\dot{\\mathbf{u}}_n) + \\frac{1}{2} (\\mathbf{u}_{n+1} - \\mathbf{u}_n)^{\\mathsf{T}} \\mathbf{K} (\\mathbf{u}_{n+1} + \\mathbf{u}_n)\n$$\n现在，将平均速度规则代入第二项：\n$$\n\\Delta \\mathcal{E} = \\frac{1}{2} (\\dot{\\mathbf{u}}_{n+1} - \\dot{\\mathbf{u}}_n)^{\\mathsf{T}} \\mathbf{M} (\\dot{\\mathbf{u}}_{n+1} + \\dot{\\mathbf{u}}_n) + \\frac{1}{2} \\left[ \\frac{\\Delta t}{2}(\\dot{\\mathbf{u}}_{n+1} + \\dot{\\mathbf{u}}_n) \\right]^{\\mathsf{T}} \\mathbf{K} (\\mathbf{u}_{n+1} + \\mathbf{u}_n)\n$$\n根据平均化的运动方程，我们有 $\\mathbf{K} (\\mathbf{u}_{n+1} + \\mathbf{u}_n) = -\\frac{2}{\\Delta t} \\mathbf{M} (\\dot{\\mathbf{u}}_{n+1} - \\dot{\\mathbf{u}}_n)$。代入此式：\n$$\n\\Delta \\mathcal{E} = \\frac{1}{2} (\\dot{\\mathbf{u}}_{n+1} - \\dot{\\mathbf{u}}_n)^{\\mathsf{T}} \\mathbf{M} (\\dot{\\mathbf{u}}_{n+1} + \\dot{\\mathbf{u}}_n) + \\frac{1}{2} \\left[ \\frac{\\Delta t}{2}(\\dot{\\mathbf{u}}_{n+1} + \\dot{\\mathbf{u}}_n) \\right]^{\\mathsf{T}} \\left[ -\\frac{2}{\\Delta t} \\mathbf{M} (\\dot{\\mathbf{u}}_{n+1} - \\dot{\\mathbf{u}}_n) \\right]\n$$\n$$\n\\Delta \\mathcal{E} = \\frac{1}{2} (\\dot{\\mathbf{u}}_{n+1} - \\dot{\\mathbf{u}}_n)^{\\mathsf{T}} \\mathbf{M} (\\dot{\\mathbf{u}}_{n+1} + \\dot{\\mathbf{u}}_n) - \\frac{1}{2} (\\dot{\\mathbf{u}}_{n+1} + \\dot{\\mathbf{u}}_n)^{\\mathsf{T}} \\mathbf{M} (\\dot{\\mathbf{u}}_{n+1} - \\dot{\\mathbf{u}}_n)\n$$\n令 $\\mathbf{a} = \\dot{\\mathbf{u}}_{n+1} - \\dot{\\mathbf{u}}_n$ 和 $\\mathbf{b} = \\dot{\\mathbf{u}}_{n+1} + \\dot{\\mathbf{u}}_n$。表达式变为 $\\Delta\\mathcal{E} = \\frac{1}{2} \\mathbf{a}^{\\mathsf{T}}\\mathbf{M}\\mathbf{b} - \\frac{1}{2} \\mathbf{b}^{\\mathsf{T}}\\mathbf{M}\\mathbf{a}$。由于 $\\mathbf{M}$ 是对称的，标量 $\\mathbf{b}^{\\mathsf{T}}\\mathbf{M}\\mathbf{a} = (\\mathbf{a}^{\\mathsf{T}}\\mathbf{M}^{\\mathsf{T}}\\mathbf{b})^{\\mathsf{T}} = (\\mathbf{a}^{\\mathsf{T}}\\mathbf{M}\\mathbf{b})^{\\mathsf{T}} = \\mathbf{a}^{\\mathsf{T}}\\mathbf{M}\\mathbf{b}$。因此：\n$$\n\\Delta \\mathcal{E} = \\frac{1}{2} \\mathbf{a}^{\\mathsf{T}}\\mathbf{M}\\mathbf{b} - \\frac{1}{2} \\mathbf{a}^{\\mathsf{T}}\\mathbf{M}\\mathbf{b} = 0\n$$\n这证明了在精确算术下 $\\mathcal{E}_{n+1} = \\mathcal{E}_n$。\n\n对于数值实现，我们使用 Euler-Bernoulli 梁的有限元离散化。采用一个 $2$ 节点单元，对横向位移 $w(x,t)$ 使用三次 Hermite 插值。长度为 $L_e$ 的单元的节点自由度 (DOF) 为 $\\mathbf{u}^e = [w_1, \\theta_1, w_2, \\theta_2]^{\\mathsf{T}}$。相应的单元刚度矩阵 $\\mathbf{k}^e$ 和协调质量矩阵 $\\mathbf{m}^e$ 为：\n$$\n\\mathbf{k}^e = \\frac{EI}{L_e^3} \\begin{pmatrix} 12  6L_e  -12  6L_e \\\\ 6L_e  4L_e^2  -6L_e  2L_e^2 \\\\ -12  -6L_e  12  -6L_e \\\\ 6L_e  2L_e^2  -6L_e  4L_e^2 \\end{pmatrix}\n$$\n$$\n\\mathbf{m}^e = \\frac{\\rho A L_e}{420} \\begin{pmatrix} 156  22L_e  54  -13L_e \\\\ 22L_e  4L_e^2  13L_e  -3L_e^2 \\\\ 54  13L_e  156  -22L_e \\\\ -13L_e  -3L_e^2  -22L_e  4L_e^2 \\end{pmatrix}\n$$\n全局矩阵 $\\mathbf{M}$ 和 $\\mathbf{K}$ 是通过对所有单元的贡献求和来组装的。通过消除与受约束自由度对应的行和列来施加本质边界条件（固支或简支），从而得到控制自由自由度的简化矩阵 $\\mathbf{M}_{\\text{free}}$ 和 $\\mathbf{K}_{\\text{free}}$。\n\nNewmark 积分过程如下。在每个时间步，我们求解下一步的加速度 $\\ddot{\\mathbf{u}}_{n+1}$：\n$$\n(\\mathbf{M}_{\\text{free}} + \\beta \\Delta t^2 \\mathbf{K}_{\\text{free}}) \\ddot{\\mathbf{u}}_{n+1} = -\\mathbf{K}_{\\text{free}} (\\mathbf{u}_n + \\Delta t \\dot{\\mathbf{u}}_n + (\\frac{1}{2}-\\beta)\\Delta t^2 \\ddot{\\mathbf{u}}_n)\n$$\n左侧的矩阵，或称有效刚度矩阵 $\\hat{\\mathbf{K}}$，是常数，可以一次性分解。解出此线性系统得到 $\\ddot{\\mathbf{u}}_{n+1}$ 后，更新速度 $\\dot{\\mathbf{u}}_{n+1}$ 和位移 $\\mathbf{u}_{n+1}$。在每一步计算离散能量，并跟踪与初始能量 $\\mathcal{E}_0$ 的最大相对偏差。初始位移为零，因此 $\\mathcal{E}_0$ 仅由规定的初始速度分布产生的动能组成。由于 $\\mathbf{u}_0=\\mathbf{0}$，初始加速度也为 $\\ddot{\\mathbf{u}}_0 = -\\mathbf{M}_{\\text{free}}^{-1}\\mathbf{K}_{\\text{free}}\\mathbf{u}_0 = \\mathbf{0}$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print results.\n    \"\"\"\n    test_cases = [\n        { # Case 1\n            \"L\": 2.0, \"E\": 210e9, \"I\": 8.333e-6, \"rho\": 7850, \"A\": 0.01,\n            \"Ne\": 2, \"bc_type\": \"clamped-clamped\", \"dt\": 1.0e-5, \"T\": 0.5,\n            \"a_vel\": 0.1\n        },\n        { # Case 2\n            \"L\": 2.0, \"E\": 210e9, \"I\": 8.333e-6, \"rho\": 7850, \"A\": 0.01,\n            \"Ne\": 10, \"bc_type\": \"simply-supported\", \"dt\": 2.0e-5, \"T\": 0.2,\n            \"a_vel\": 0.1\n        },\n        { # Case 3\n            \"L\": 2.0, \"E\": 210e9, \"I\": 8.333e-6, \"rho\": 7850, \"A\": 0.01,\n            \"Ne\": 20, \"bc_type\": \"simply-supported\", \"dt\": 1.0e-5, \"T\": 0.1,\n            \"a_vel\": 0.1\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        max_rel_dev = run_simulation(case)\n        results.append(f\"{max_rel_dev:.9e}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef run_simulation(params):\n    \"\"\"\n    Executes a single beam vibration simulation based on the provided parameters.\n    \"\"\"\n    # Unpack parameters\n    L, E, I, rho, A = params[\"L\"], params[\"E\"], params[\"I\"], params[\"rho\"], params[\"A\"]\n    Ne, bc_type, dt, T, a_vel = params[\"Ne\"], params[\"bc_type\"], params[\"dt\"], params[\"T\"], params[\"a_vel\"]\n\n    # Element properties\n    Le = L / Ne\n    EI = E * I\n    rhoA = rho * A\n\n    # Element stiffness matrix (k_e)\n    k_e = (EI / Le**3) * np.array([\n        [12, 6*Le, -12, 6*Le],\n        [6*Le, 4*Le**2, -6*Le, 2*Le**2],\n        [-12, -6*Le, 12, -6*Le],\n        [6*Le, 2*Le**2, -6*Le, 4*Le**2]\n    ])\n\n    # Element consistent mass matrix (m_e)\n    m_e = (rhoA * Le / 420) * np.array([\n        [156, 22*Le, 54, -13*Le],\n        [22*Le, 4*Le**2, 13*Le, -3*Le**2],\n        [54, 13*Le, 156, -22*Le],\n        [-13*Le, -3*Le**2, -22*Le, 4*Le**2]\n    ])\n\n    # Assembly of global matrices\n    num_nodes = Ne + 1\n    num_dofs = 2 * num_nodes\n    K = np.zeros((num_dofs, num_dofs))\n    M = np.zeros((num_dofs, num_dofs))\n\n    for e in range(Ne):\n        # Global DOFs for element e are: w_e, th_e, w_{e+1}, th_{e+1}\n        # which correspond to indices 2*e, 2*e+1, 2*e+2, 2*e+3\n        dofs = np.arange(2*e, 2*e+4)\n        K[np.ix_(dofs, dofs)] += k_e\n        M[np.ix_(dofs, dofs)] += m_e\n\n    # Apply boundary conditions by identifying constrained DOFs\n    if bc_type == 'clamped-clamped':\n        constrained_dofs = [0, 1, 2*Ne, 2*Ne+1]\n    elif bc_type == 'simply-supported':\n        constrained_dofs = [0, 2*Ne]\n    else: # free-free\n        constrained_dofs = []\n\n    all_dofs = np.arange(num_dofs)\n    free_dofs = np.setdiff1d(all_dofs, constrained_dofs, assume_unique=True)\n\n    # Reduce matrices to free DOFs\n    K_free = K[np.ix_(free_dofs, free_dofs)]\n    M_free = M[np.ix_(free_dofs, free_dofs)]\n\n    # Initial conditions\n    u0_full = np.zeros(num_dofs)\n    udot0_full = np.zeros(num_dofs)\n    for i in range(num_nodes):\n        x_i = i * Le\n        # Set velocity for transverse displacement DOFs\n        udot0_full[2*i] = a_vel * np.sin(np.pi * x_i / L)\n    \n    # Reduce initial condition vectors to free DOFs\n    u0 = u0_full[free_dofs]\n    udot0 = udot0_full[free_dofs]\n\n    # Initial acceleration is zero since initial displacement is zero\n    uddot0 = np.zeros_like(u0)\n\n    # Newmark time integration (average-acceleration method)\n    gamma = 0.5\n    beta = 0.25\n    u, udot, uddot = u0.copy(), udot0.copy(), uddot0.copy()\n\n    # Pre-calculate effective stiffness matrix\n    K_eff = M_free + beta * dt**2 * K_free\n\n    # Calculate initial energy\n    E0 = 0.5 * udot.T @ M_free @ udot + 0.5 * u.T @ K_free @ u\n    if np.isclose(E0, 0): # Avoid division by zero if initial energy is zero\n        return 0.0\n\n    max_rel_dev = 0.0\n    num_steps = int(T / dt)\n\n    for _ in range(num_steps):\n        # Calculate effective force vector\n        F_eff = -K_free @ (u + dt * udot + (0.5 - beta) * dt**2 * uddot)\n        \n        # Solve for new acceleration\n        uddot_new = linalg.solve(K_eff, F_eff, assume_a='sym')\n        \n        # Update velocity and displacement\n        udot_new = udot + dt * ((1 - gamma) * uddot + gamma * uddot_new)\n        u_new = u + dt * udot + dt**2 * ((0.5 - beta) * uddot + beta * uddot_new)\n        \n        # Update state variables\n        u, udot, uddot = u_new, udot_new, uddot_new\n        \n        # Calculate energy at current step\n        En = 0.5 * udot.T @ M_free @ udot + 0.5 * u.T @ K_free @ u\n        \n        # Track maximum relative energy deviation\n        rel_dev = abs(En - E0) / abs(E0)\n        if rel_dev > max_rel_dev:\n            max_rel_dev = rel_dev\n\n    return max_rel_dev\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}