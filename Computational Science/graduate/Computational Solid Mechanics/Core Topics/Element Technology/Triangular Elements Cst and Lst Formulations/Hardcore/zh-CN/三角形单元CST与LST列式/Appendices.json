{
    "hands_on_practices": [
        {
            "introduction": "单元刚度矩阵 $K_e$ 是有限元的核心，它建立了节点力与节点位移之间的联系。本练习  将指导你从虚功原理出发，为常应变三角形（CST）单元推导其 $K_e$ 矩阵，将理论力学转化为一个具体的矩阵。通过这个过程，你将能更好地理解其基本的数学性质，如对称性和奇异性。",
            "id": "3607848",
            "problem": "考虑一个处于平面应力状态的二维线弹性体，其本构矩阵为 $D=\\dfrac{E}{1-\\nu^{2}}\\begin{bmatrix}1 & \\nu & 0\\\\ \\nu & 1 & 0\\\\ 0 & 0 & \\dfrac{1-\\nu}{2}\\end{bmatrix}$，其中 $E$ 是杨氏模量，$\\nu$ 是泊松比。使用常应变三角形 (CST) 列式，基于虚功原理，从第一性原理推导节点坐标为 $((x_{1},y_{1}),(x_{2},y_{2}),(x_{3},y_{3}))=((0,0),(2,0),(0,1))$ 且厚度均匀为 $t$ 的三角形有限元的单元刚度矩阵 $K_{e}$。用 $E$、$\\nu$ 和 $t$ 明确计算 $K_{e}$，并使用能量论证验证 $K_{e}$ 的对称性和半正定性。最后，给出行列式 $\\det(K_{e})$ 的精确值，作为一个无量纲标量。无需四舍五入。在首次使用时定义常应变三角形 (CST) 和线性应变三角形 (LST) 的缩写。",
            "solution": "该问题需要进行验证。\n\n### 步骤一：提取已知条件\n- **领域：** 处于平面应力状态的二维线弹性体。\n- **本构矩阵 ($\\mathbf{D}$):** 对于平面应力，$\\mathbf{D} = \\frac{E}{1-\\nu^2} \\begin{bmatrix} 1 & \\nu & 0 \\\\ \\nu & 1 & 0 \\\\ 0 & 0 & \\frac{1-\\nu}{2} \\end{bmatrix}$。\n- **常数：** 杨氏模量 $E$，泊松比 $\\nu$。\n- **单元类型：** 常应变三角形 (CST)。\n- **推导方法：** 基于虚功原理的第一性原理。\n- **目标：** 单元刚度矩阵 $\\mathbf{K}_e$。\n- **几何形状：** 节点坐标为 $((x_1, y_1), (x_2, y_2), (x_3, y_3)) = ((0,0), (2,0), (0,1))$ 的三角形有限元。\n- **厚度：** 均匀厚度 $t$。\n- **任务：**\n    1. 从第一性原理推导 $\\mathbf{K}_e$。\n    2. 对于给定的几何形状，用 $E$、$\\nu$ 和 $t$ 明确计算 $\\mathbf{K}_e$。\n    3. 使用能量论证验证 $\\mathbf{K}_e$ 的对称性和半正定性。\n    4. 给出行列式 $\\det(\\mathbf{K}_e)$ 的精确值，作为一个无量纲标量。\n    5. 在首次使用时定义常应变三角形 (CST) 和线性应变三角形 (LST) 的缩写。\n\n### 步骤二：使用提取的已知条件进行验证\n- **科学依据：** 该问题是有限元法 (FEM) 在二维线弹性问题中的一个标准应用。虚功原理、平面应力本构模型和常应变三角形 (CST) 单元的使用都是计算固体力学中基本且正确的概念。\n- **适定性：** 问题被完整地规定，包含了所有必要信息：几何形状、材料属性（符号表示）、单元列式和推导方法。单元刚度矩阵存在唯一解。\n- **客观性：** 问题使用精确的技术语言陈述，没有主观或模糊的术语。\n\n### 步骤三：结论与行动\n该问题是有效的，因为它是科学合理的、适定的和客观的。将提供完整的解答。\n\n***\n\n常应变三角形（Constant Strain Triangle, CST）是一种三节点三角形有限元，其特征是线性位移场。该列式导致单元内的应变（和应力）为常数。相比之下，线性应变三角形（Linear Strain Triangle, LST）是一种六节点三角形单元（在边中点有节点），其特征是二次位移场，这导致单元内的应变（和应力）呈线性变化。\n\n单元刚度矩阵 $\\mathbf{K}_e$ 由虚功原理推导得出。对于单个单元，内虚功 $\\delta W_{int}$ 由下式给出：\n$$ \\delta W_{int} = \\int_{V_e} \\delta \\boldsymbol{\\epsilon}^T \\boldsymbol{\\sigma} \\, dV $$\n其中 $\\boldsymbol{\\sigma}$ 是应力向量，$\\delta \\boldsymbol{\\epsilon}$ 是虚应变向量，积分范围是单元体积 $V_e$。\n\nCST 单元的运动学关系通过线性形函数 $N_i(x,y)$ 将位移场 $\\mathbf{u}(x,y)$ 与节点位移 $\\mathbf{d}_e$ 联系起来。\n$$ \\mathbf{u}(x,y) = \\begin{Bmatrix} u(x,y) \\\\ v(x,y) \\end{Bmatrix} = \\mathbf{N}(x,y) \\mathbf{d}_e $$\n其中 $\\mathbf{d}_e = \\{u_1, v_1, u_2, v_2, u_3, v_3\\}^T$ 是节点位移向量，形函数矩阵为：\n$$ \\mathbf{N}(x,y) = \\begin{bmatrix} N_1 & 0 & N_2 & 0 & N_3 & 0 \\\\ 0 & N_1 & 0 & N_2 & 0 & N_3 \\end{bmatrix} $$\n形函数为 $N_i(x,y) = \\frac{1}{2A}(a_i + b_i x + c_i y)$，其中 $A$ 是单元面积，系数为 $a_i = x_j y_k - x_k y_j$，$b_i = y_j - y_k$ 和 $c_i = x_k - x_j$，对于循环索引 $(i,j,k)$。\n\n应变向量 $\\boldsymbol{\\epsilon} = \\{\\epsilon_x, \\epsilon_y, \\gamma_{xy}\\}^T$ 通过 $\\boldsymbol{\\epsilon} = \\mathbf{L}\\mathbf{u}$ 与位移场相关联，其中 $\\mathbf{L}$ 是微分算子。代入插值位移，我们得到：\n$$ \\boldsymbol{\\epsilon} = \\mathbf{B} \\mathbf{d}_e $$\n其中 $\\mathbf{B} = \\mathbf{L}\\mathbf{N}$ 是应变-位移矩阵。对于 CST，$\\mathbf{B}$ 是常数：\n$$ \\mathbf{B} = \\frac{1}{2A} \\begin{bmatrix} b_1 & 0 & b_2 & 0 & b_3 & 0 \\\\ 0 & c_1 & 0 & c_2 & 0 & c_3 \\\\ c_1 & b_1 & c_2 & b_2 & c_3 & b_3 \\end{bmatrix} $$\n\n本构关系关联了应力和应变：$\\boldsymbol{\\sigma} = \\mathbf{D} \\boldsymbol{\\epsilon} = \\mathbf{D} \\mathbf{B} \\mathbf{d}_e$。将这些代入虚功表达式：\n$$ \\delta W_{int} = \\int_{V_e} (\\delta(\\mathbf{B} \\mathbf{d}_e))^T (\\mathbf{D} \\mathbf{B} \\mathbf{d}_e) \\, dV = \\delta \\mathbf{d}_e^T \\left( \\int_{V_e} \\mathbf{B}^T \\mathbf{D} \\mathbf{B} \\, dV \\right) \\mathbf{d}_e $$\n根据定义 $\\delta W_{int} = \\delta \\mathbf{d}_e^T \\mathbf{K}_e \\mathbf{d}_e$，单元刚度矩阵为：\n$$ \\mathbf{K}_e = \\int_{V_e} \\mathbf{B}^T \\mathbf{D} \\mathbf{B} \\, dV $$\n对于厚度均匀为 $t$ 的 CST，$\\mathbf{B}$ 和 $\\mathbf{D}$ 是常数，因此积分简化为：\n$$ \\mathbf{K}_e = (\\mathbf{B}^T \\mathbf{D} \\mathbf{B}) \\cdot (A \\cdot t) $$\n\n现在，我们为给定节点 $(0,0)$、$(2,0)$ 和 $(0,1)$ 的单元计算 $\\mathbf{K}_e$。\n三角形的面积是 $A = \\frac{1}{2} |\\det \\begin{bmatrix} x_1 & y_1 & 1 \\\\ x_2 & y_2 & 1 \\\\ x_3 & y_3 & 1 \\end{bmatrix}| = \\frac{1}{2} |\\det \\begin{bmatrix} 0 & 0 & 1 \\\\ 2 & 0 & 1 \\\\ 0 & 1 & 1 \\end{bmatrix}| = \\frac{1}{2} |1(2 \\cdot 1 - 0 \\cdot 0)| = 1$。\n系数 $b_i$ 和 $c_i$ 是：\n$b_1 = y_2 - y_3 = 0 - 1 = -1$\n$b_2 = y_3 - y_1 = 1 - 0 = 1$\n$b_3 = y_1 - y_2 = 0 - 0 = 0$\n$c_1 = x_3 - x_2 = 0 - 2 = -2$\n$c_2 = x_1 - x_3 = 0 - 0 = 0$\n$c_3 = x_2 - x_1 = 2 - 0 = 2$\n\n由于 $2A = 2$，$\\mathbf{B}$ 矩阵为：\n$$ \\mathbf{B} = \\frac{1}{2} \\begin{bmatrix} -1 & 0 & 1 & 0 & 0 & 0 \\\\ 0 & -2 & 0 & 0 & 0 & 2 \\\\ -2 & -1 & 0 & 1 & 2 & 0 \\end{bmatrix} $$\n本构矩阵是 $\\mathbf{D} = \\frac{E}{1-\\nu^2} \\begin{bmatrix} 1 & \\nu & 0 \\\\ \\nu & 1 & 0 \\\\ 0 & 0 & \\frac{1-\\nu}{2} \\end{bmatrix}$。\n\n我们现在计算 $\\mathbf{K}_e = t A \\mathbf{B}^T \\mathbf{D} \\mathbf{B} = t \\mathbf{B}^T \\mathbf{D} \\mathbf{B}$。\n$$ \\mathbf{K}_e = t \\left( \\frac{1}{2} \\begin{bmatrix} -1 & 0 & -2 \\\\ 0 & -2 & -1 \\\\ 1 & 0 & 0 \\\\ 0 & 0 & 1 \\\\ 0 & 0 & 2 \\\\ 0 & 2 & 0 \\end{bmatrix} \\right) \\left( \\frac{E}{1-\\nu^2} \\begin{bmatrix} 1 & \\nu & 0 \\\\ \\nu & 1 & 0 \\\\ 0 & 0 & \\frac{1-\\nu}{2} \\end{bmatrix} \\right) \\left( \\frac{1}{2} \\begin{bmatrix} -1 & 0 & 1 & 0 & 0 & 0 \\\\ 0 & -2 & 0 & 0 & 0 & 2 \\\\ -2 & -1 & 0 & 1 & 2 & 0 \\end{bmatrix} \\right) $$\n$$ \\mathbf{K}_e = \\frac{Et}{4(1-\\nu^2)} \\begin{bmatrix} -1 & 0 & -2 \\\\ 0 & -2 & -1 \\\\ 1 & 0 & 0 \\\\ 0 & 0 & 1 \\\\ 0 & 0 & 2 \\\\ 0 & 2 & 0 \\end{bmatrix} \\begin{bmatrix} 1 & \\nu & 0 \\\\ \\nu & 1 & 0 \\\\ 0 & 0 & \\frac{1-\\nu}{2} \\end{bmatrix} \\begin{bmatrix} -1 & 0 & 1 & 0 & 0 & 0 \\\\ 0 & -2 & 0 & 0 & 0 & 2 \\\\ -2 & -1 & 0 & 1 & 2 & 0 \\end{bmatrix} $$\n执行矩阵乘法得出：\n$$ \\mathbf{K}_e = \\frac{Et}{4(1-\\nu^2)} \\begin{bmatrix} 3-2\\nu & 1+\\nu & -1 & \\nu-1 & 2\\nu-2 & -2\\nu \\\\ 1+\\nu & \\frac{9-\\nu}{2} & -2\\nu & -\\frac{1-\\nu}{2} & \\nu-1 & -4 \\\\ -1 & -2\\nu & 1 & 0 & 0 & 2\\nu \\\\ \\nu-1 & -\\frac{1-\\nu}{2} & 0 & \\frac{1-\\nu}{2} & 1-\\nu & 0 \\\\ 2\\nu-2 & \\nu-1 & 0 & 1-\\nu & 2(1-\\nu) & 0 \\\\ -2\\nu & -4 & 2\\nu & 0 & 0 & 4 \\end{bmatrix} $$\n\n**对称性和半正定性的验证：**\n1.  **对称性：** 刚度矩阵由 $\\mathbf{K}_e = tA\\mathbf{B}^T\\mathbf{D}\\mathbf{B}$ 给出。其转置是 $\\mathbf{K}_e^T = tA(\\mathbf{B}^T\\mathbf{D}\\mathbf{B})^T = tA\\mathbf{B}^T\\mathbf{D}^T(\\mathbf{B}^T)^T = tA\\mathbf{B}^T\\mathbf{D}\\mathbf{B} = \\mathbf{K}_e$，因为线弹性材料的本构矩阵 $\\mathbf{D}$ 是对称的（$\\mathbf{D}^T = \\mathbf{D}$）。通过观察也可以看出明确计算出的矩阵是对称的。\n2.  **半正定性：** 存储在单元中的应变能为 $U_e = \\frac{1}{2} \\mathbf{d}_e^T \\mathbf{K}_e \\mathbf{d}_e$。由于对于任何物理上允许的位移 $\\mathbf{d}_e$，应变能必须是非负的，所以二次型 $\\mathbf{d}_e^T \\mathbf{K}_e \\mathbf{d}_e$ 必须大于或等于零。这就是半正定矩阵的定义。只有当应变为零时，即 $\\boldsymbol{\\epsilon} = \\mathbf{B}\\mathbf{d}_e = 0$ 时，能量才为零。这种情况发生在刚体运动（平移和旋转）中，此时单元不发生变形。一个无约束的单元刚度矩阵必须允许这些零能量模式的存在，这些模式对应于一个非平凡的零空间。因此，$\\mathbf{K}_e$ 必须是奇异的并且是半正定的，而不是正定的。\n\n**$\\mathbf{K}_e$ 的行列式：**\n奇异矩阵的行列式为零。我们可以通过识别其对应于刚体运动的零空间向量来验证 $\\mathbf{K}_e$ 是奇异的。\n对于 $x$ 方向的刚体平移，$\\mathbf{d}_e = \\{1, 0, 1, 0, 1, 0\\}^T$。乘积 $\\mathbf{K}_e \\mathbf{d}_e$ 是 $\\mathbf{K}_e$ 的第1、第3和第5列之和。对第一行的元素求和得到：\n$\\frac{Et}{4(1-\\nu^2)}[(3-2\\nu) + (-1) + (2\\nu-2)] = \\frac{Et}{4(1-\\nu^2)}[0] = 0$。\n这对所有行都成立。因此，对于这个 $\\mathbf{d}_e$，$\\mathbf{K}_e \\mathbf{d}_e = \\mathbf{0}$，这证实了存在一个非平凡的零空间。\n类似地，对于 $y$ 方向的刚体平移，$\\mathbf{d}_e = \\{0, 1, 0, 1, 0, 1\\}^T$，第2、第4和第6列之和为零向量。\n由于 $\\mathbf{K}_e$ 有一个非平凡的零空间，所以它是奇异的。任何奇异矩阵的行列式都为零。\n$$ \\det(\\mathbf{K}_e) = 0 $$\n值 $0$ 是一个无量纲标量，满足题目的要求。",
            "answer": "$$\n\\boxed{0}\n$$"
        },
        {
            "introduction": "一个正确构建的有限元必须能够精确地再现常应变状态，这是保证收敛性的基本要求。这个练习  将通过编程实现一个数值“分片检验”（patch test），来验证 CST 单元的这一关键特性。通过确认一组单元能够无误差地表示一个线性位移场，我们能建立对该单元在网格细化时收敛到真实解的信心。",
            "id": "3607774",
            "problem": "考虑二维空间中的小应变、线性弹性、平面应力问题，且体力为零。设位移场为 $\\mathbf{u}(x,y) = \\begin{bmatrix} u(x,y) \\\\ v(x,y) \\end{bmatrix}$，无穷小应变张量为 $\\boldsymbol{\\varepsilon} = \\begin{bmatrix} \\varepsilon_{xx} \\\\ \\varepsilon_{yy} \\\\ \\gamma_{xy} \\end{bmatrix} = \\begin{bmatrix} \\dfrac{\\partial u}{\\partial x} \\\\ \\dfrac{\\partial v}{\\partial y} \\\\ \\dfrac{\\partial u}{\\partial y} + \\dfrac{\\partial v}{\\partial x} \\end{bmatrix}$。对于平面应力下的各向同性材料，令 $\\mathbf{D}$ 为弹性本构矩阵，使得 $\\boldsymbol{\\sigma} = \\mathbf{D}\\,\\boldsymbol{\\varepsilon}$，其中 $\\boldsymbol{\\sigma} = \\begin{bmatrix} \\sigma_{xx} \\\\ \\sigma_{yy} \\\\ \\sigma_{xy} \\end{bmatrix}$ 是 Cauchy 应力矢量。对于杨氏模量 $E$ 和泊松比 $\\nu$，平面应力矩阵为 $\\mathbf{D} = \\dfrac{E}{1-\\nu^2}\\begin{bmatrix} 1 & \\nu & 0 \\\\ \\nu & 1 & 0 \\\\ 0 & 0 & \\dfrac{1-\\nu}{2} \\end{bmatrix}$。\n\n在常应变三角形（CST）有限元中，位移在每个三角形上通过线性形函数进行插值。用 $t$ 表示单元厚度（平面外，为正常数）。在体力为零和边界 $\\Gamma$ 上施加一致边界牵引力 $\\mathbf{t} = \\boldsymbol{\\sigma}\\,\\mathbf{n}$ 的情况下，虚功原理导出组装后的平衡（残差）矢量 $\\mathbf{r} = \\mathbf{f}_{\\mathrm{int}} - \\mathbf{f}_{\\mathrm{trac}}$。其中，$\\mathbf{f}_{\\mathrm{int}}$ 是组装后的内节点力矢量，每个单元的贡献为 $\\int_{\\Omega_e} \\mathbf{B}^\\top \\boldsymbol{\\sigma}\\, \\mathrm{d}\\Omega$；$\\mathbf{f}_{\\mathrm{trac}}$ 是组装后的一致节点牵引力矢量，每个边界边的贡献为 $\\int_{\\Gamma_e} \\mathbf{N}^\\top \\mathbf{t}\\, \\mathrm{d}\\Gamma$。$\\mathbf{B}$ 是由线性形函数的导数构建的标准 CST 应变-位移矩阵，$\\mathbf{N}$ 是汇集了两个位移分量的形函数的矩阵。\n\n您的任务是设计并分析由 CST 单元组成的三个三角形单元片，并从第一性原理出发，在数值上和算法上验证以下两个性质：\n- 如果精确位移是 $x$ 和 $y$ 的线性函数，那么当节点值取自同一线性场时，CST 插值能够在每个单元上逐点地再现该位移场。\n- 在体力为零，且边界牵引力设置为与同一线性场相对应的精确值 $\\mathbf{t} = \\boldsymbol{\\sigma}\\,\\mathbf{n}$ 的条件下，组装后的残差 $\\mathbf{r}$ 为零，即全局内力与边界牵引力精确平衡，因此残差范数为零。\n\n为每个指定的单元片和线性位移场，实现一个完整的程序来计算：\n- 在每个三角形内的一组采样点上，最大的绝对位移再现误差，以 $\\max\\limits_{\\text{samples},\\ \\alpha \\in \\{u,v\\}} \\left| \\alpha_{\\mathrm{FE}} - \\alpha_{\\mathrm{exact}} \\right|$ 度量，单位为米（SI 单位）。\n- 当一致边界牵引力 $\\mathbf{t} = \\boldsymbol{\\sigma}\\,\\mathbf{n}$ 按逆时针顺序施加在边界边上时，组装后的残差矢量 $\\|\\mathbf{r}\\|_2 = \\|\\mathbf{f}_{\\mathrm{int}} - \\mathbf{f}_{\\mathrm{trac}}\\|_2$ 的欧几里得范数，单位为牛顿（SI 单位）。\n\n使用以下三个测试用例（所有坐标单位为米，模量单位为帕斯卡，厚度单位为米）。对于每个用例，线性位移场由 $u(x,y) = a_0 + a_1 x + a_2 y$ 和 $v(x,y) = b_0 + b_1 x + b_2 y$ 给出。如果出现任何角度，都必须以弧度为单位。\n\n测试用例 $\\mathbf{1}$（由两个三角形组成正方形的基准单元片）：\n- 节点 $\\mathbf{x}_i$：$\\left[(0,0),(1,0),(1,1),(0,1)\\right]$。\n- 单元（节点索引三元组，从零开始）：$\\left[(0,1,2),(0,2,3)\\right]$。\n- 边界边（按逆时针顺序排列的节点索引对）：$\\left[(0,1),(1,2),(2,3),(3,0)\\right]$。\n- 材料：$E = 210\\times 10^9$，$\\nu = 0.3$，$t = 0.01$。\n- 线性场系数：$a_0 = 1$, $a_1 = 2$, $a_2 = -3$, $b_0 = -0.5$, $b_1 = 4$, $b_2 = 1$。\n\n测试用例 $\\mathbf{2}$（带有内部节点的单元片：四个三角形在中心交汇）：\n- 节点 $\\mathbf{x}_i$：$\\left[(0,0),(2,0),(2,1),(0,1),(1,0.5)\\right]$。\n- 单元：$\\left[(0,1,4),(1,2,4),(2,3,4),(3,0,4)\\right]$。\n- 边界边（逆时针）：$\\left[(0,1),(1,2),(2,3),(3,0)\\right]$。\n- 材料：$E = 70\\times 10^9$，$\\nu = 0.25$，$t = 0.02$。\n- 线性场系数：$a_0 = -0.1$, $a_1 = 0.3$, $a_2 = 0.2$, $b_0 = 0.7$, $b_1 = -0.6$, $b_2 = 0.4$。\n\n测试用例 $\\mathbf{3}$（边界情况：一个单一的狭长三角形）：\n- 节点 $\\mathbf{x}_i$：$\\left[(0,0),(0.001,0),(1,0.1)\\right]$。\n- 单元：$\\left[(0,1,2)\\right]$。\n- 边界边（逆时针）：$\\left[(0,1),(1,2),(2,0)\\right]$。\n- 材料：$E = 110\\times 10^9$，$\\nu = 0.29$，$t = 0.005$。\n- 线性场系数（刚体运动：零应变）：$a_0 = 0.02$, $a_1 = 0$, $a_2 = 0.001$, $b_0 = -0.03$, $b_1 = -0.001$, $b_2 = 0$。\n\n算法要求：\n- 使用标准的 CST 构建方法。对于每个具有节点 $(x_i,y_i)$ 的三角形，定义线性形函数 $N_i(x,y)$（$i\\in\\{1,2,3\\}$）及其在单元上的常数导数。相应地构建单元 $\\mathbf{B}$ 矩阵。\n- 根据给定的线性场计算精确的常数应变，即 $\\varepsilon_{xx} = a_1$、$\\varepsilon_{yy} = b_2$ 和 $\\gamma_{xy} = a_2 + b_1$，然后计算 $\\boldsymbol{\\sigma} = \\mathbf{D}\\,\\boldsymbol{\\varepsilon}$。\n- 通过对所有单元求和来组装内力矢量，每个单元的贡献为 $\\int_{\\Omega_e} \\mathbf{B}^\\top \\boldsymbol{\\sigma}\\, \\mathrm{d}\\Omega = \\mathbf{B}^\\top \\boldsymbol{\\sigma}\\,A_e\\,t$，其中 $A_e$ 是单元面积。\n- 通过对所有边界边求和来组装一致边界牵引力矢量 $\\int_{\\Gamma_e} \\mathbf{N}^\\top \\mathbf{t}\\, \\mathrm{d}\\Gamma$，其中 $\\mathbf{t} = \\boldsymbol{\\sigma}\\,\\mathbf{n}$，单位外法向量 $\\mathbf{n}$ 从逆时针的边排序中获得。由于在线性位移场下，$\\mathbf{t}$ 沿直边是恒定的，因此作用于该边上每个节点的力可计算为 $\\dfrac{L_e\\,t}{2}\\mathbf{t}$，并进行分配，其中 $L_e$ 是边长。\n- 对于再现误差，将节点位移设置为在节点处求值的精确线性场，然后使用 CST 形函数在采样点（包括每个三角形的形心和每条边的中点）处计算有限元位移，并计算所有样本和两个位移分量与精确场之间的最大绝对差。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个 Python 风格的列表，内含 6 个浮点数，顺序如下：$\\left[\\text{err}_1,\\ \\|\\mathbf{r}_1\\|_2,\\ \\text{err}_2,\\ \\|\\mathbf{r}_2\\|_2,\\ \\text{err}_3,\\ \\|\\mathbf{r}_3\\|_2\\right]$。其中，$\\text{err}_k$ 是测试用例 $k$ 的最大绝对位移再现误差（单位：米），$\\|\\mathbf{r}_k\\|_2$ 是测试用例 $k$ 的组装后残差矢量的欧几里得范数（单位：牛顿）。不要打印单位；确保数值符合指定的 SI 单位。\n\n程序必须是自包含的，并且不需要任何输入。它必须实现执行所述计算所需的所有细节。",
            "solution": "该问题要求在平面应力条件下，对常应变三角形（CST）有限元的两个基本性质进行数值验证。这两个性质分别是：它能精确再现线性位移场的能力，以及通过单元片检验（patch test）的能力。对于体力为零的情况，当施加与常应变状态相对应的一致边界牵引力时，单元片检验体现为残余力矢量为零。我们将分析三个不同的测试用例，每个用例都具有指定的几何形状、材料属性和线性位移场。\n\n该分析基于线性弹性原理和有限元法。位移场 $\\mathbf{u}(x,y)$ 由 $\\mathbf{u} = [u(x,y), v(x,y)]^\\top$ 给出。无穷小应变的应变-位移关系以矢量形式给出为 $\\boldsymbol{\\varepsilon} = [\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}]^\\top$，其中\n$$ \\boldsymbol{\\varepsilon} = \\begin{bmatrix} \\dfrac{\\partial u}{\\partial x} \\\\ \\dfrac{\\partial v}{\\partial y} \\\\ \\dfrac{\\partial u}{\\partial y} + \\dfrac{\\partial v}{\\partial x} \\end{bmatrix} $$\n对于平面应力下的线性、各向同性、均匀材料，应力矢量 $\\boldsymbol{\\sigma} = [\\sigma_{xx}, \\sigma_{yy}, \\sigma_{xy}]^\\top$ 通过本构矩阵 $\\mathbf{D}$ 与应变矢量相关联：\n$$ \\boldsymbol{\\sigma} = \\mathbf{D} \\boldsymbol{\\varepsilon} \\quad \\text{其中} \\quad \\mathbf{D} = \\dfrac{E}{1-\\nu^2}\\begin{bmatrix} 1 & \\nu & 0 \\\\ \\nu & 1 & 0 \\\\ 0 & 0 & \\dfrac{1-\\nu}{2} \\end{bmatrix} $$\n此处，$E$ 代表杨氏模量，$\\nu$ 是泊松比。\n\nCST 单元使用线性形函数 $N_i(x,y)$ 来近似三角形域 $\\Omega_e$ 内的位移场，其中 $i \\in \\{1,2,3\\}$ 对应于单元的三个节点。插值后的位移场 $(u^h, v^h)$ 为：\n$$ u^h(x,y) = \\sum_{i=1}^{3} N_i(x,y) u_i \\quad \\text{和} \\quad v^h(x,y) = \\sum_{i=1}^{3} N_i(x,y) v_i $$\n其中 $(u_i, v_i)$ 是节点 $i$ 处的位移。形函数 $N_i$ 是 $x$ 和 $y$ 的线性函数，具有属性 $N_i(x_j, y_j) = \\delta_{ij}$，其中 $\\delta_{ij}$ 是 Kronecker 符号。\n\n这些线性形函数的导数在整个单元上是恒定的。这导致单元内产生一个恒定的应变场，这也是它被命名为常应变三角形的原因。应变通过应变-位移矩阵 $\\mathbf{B}$ 与节点位移矢量 $\\mathbf{d}_e = [u_1, v_1, u_2, v_2, u_3, v_3]^\\top$ 相关联：\n$$ \\boldsymbol{\\varepsilon}_e = \\mathbf{B} \\mathbf{d}_e $$\n对于一个节点按逆时针顺序排列为 $(x_1, y_1)$, $(x_2, y_2)$, $(x_3, y_3)$ 的单元，$\\mathbf{B}$ 矩阵由下式给出：\n$$ \\mathbf{B} = \\frac{1}{2A_e} \\begin{bmatrix}\ny_2-y_3 & 0 & y_3-y_1 & 0 & y_1-y_2 & 0 \\\\\n0 & x_3-x_2 & 0 & x_1-x_3 & 0 & x_2-x_1 \\\\\nx_3-x_2 & y_2-y_3 & x_1-x_3 & y_3-y_1 & x_2-x_1 & y_1-y_2\n\\end{bmatrix} $$\n其中 $A_e$ 是单元的面积，计算公式为 $A_e = \\frac{1}{2} \\det \\begin{bmatrix} 1 & x_1 & y_1 \\\\ 1 & x_2 & y_2 \\\\ 1 & x_3 & y_3 \\end{bmatrix}$。\n\n**位移再现性的验证**\n\n第一个要验证的性质是 CST 单元能够精确再现线性位移场。给定的精确场为：\n$$ u(x,y) = a_0 + a_1 x + a_2 y \\quad \\text{和} \\quad v(x,y) = b_0 + b_1 x + b_2 y $$\n由于 CST 形函数 $N_i(x,y)$ 本身是线性的，并且它们构成了三角形上线性多项式的一个基（因为 $\\sum N_i = 1$），因此取自线性场的节点值的任何线性组合都必须再现该线性场。也就是说，如果我们设置节点位移 $u_i = u(x_i, y_i)$ 和 $v_i = v(x_i, y_i)$，那么对于单元内的所有点 $(x,y)$，插值位移 $u^h(x,y) = \\sum N_i(x,y) u(x_i,y_i)$ 必须与 $u(x,y)$ 完全相同。一个线性函数由其在三个不共线点（即顶点）上的值唯一确定。由于 $u(x,y)$ 和 $u^h(x,y)$ 都是线性的且在顶点处值相同，因此它们必须处处相同。\n\n为了在数值上验证这一点，我们在每个单元内的一组采样点（形心和边中点）上计算有限元近似解 $u^h, v^h$，并将其与精确值 $u, v$ 进行比较。预期的最大绝对差 $\\max |\\alpha_{\\mathrm{FE}} - \\alpha_{\\mathrm{exact}}|$（其中 $\\alpha \\in \\{u,v\\}$）应在浮点精度范围内为零。\n\n**单元片检验的验证（零残差）**\n\n第二个性质是满足单元片检验。对于处于常应变状态且无体力的单元片，节点平衡方程必须得到满足。这意味着组装后的内节点力 $\\mathbf{f}_{\\mathrm{int}}$ 必须与由边界牵引力产生的组装后外节点力 $\\mathbf{f}_{\\mathrm{trac}}$ 精确平衡。残差矢量 $\\mathbf{r} = \\mathbf{f}_{\\mathrm{int}} - \\mathbf{f}_{\\mathrm{trac}}$ 必须为零矢量。\n\n所提供的线性位移场在整个域上引起一个恒定的应变状态：\n$$ \\boldsymbol{\\varepsilon} = \\begin{bmatrix} a_1 \\\\ b_2 \\\\ a_2 + b_1 \\end{bmatrix} $$\n这导致一个恒定的应力场 $\\boldsymbol{\\sigma} = \\mathbf{D} \\boldsymbol{\\varepsilon}$。\n\n单元的内力矢量是通过对内应力的虚功进行积分来计算的：\n$$ \\mathbf{f}_{e, \\mathrm{int}} = \\int_{\\Omega_e} \\mathbf{B}^\\top \\boldsymbol{\\sigma} \\, \\mathrm{d}\\Omega $$\n由于在 CST 单元内 $\\mathbf{B}$ 和 $\\boldsymbol{\\sigma}$ 是恒定的，该式可简化为：\n$$ \\mathbf{f}_{e, \\mathrm{int}} = \\mathbf{B}^\\top \\boldsymbol{\\sigma} A_e t $$\n其中 $t$ 是恒定的单元厚度。这些单元矢量被组装成全局内力矢量 $\\mathbf{f}_{\\mathrm{int}}$。\n\n由边界牵引力引起的一致节点力是为单元片外部边界上的每条边计算的。对于一条具有牵引力矢量 $\\mathbf{t}$ 的边 $\\Gamma_e$，其力矢量为：\n$$ \\mathbf{f}_{e, \\mathrm{trac}} = \\int_{\\Gamma_e} \\mathbf{N}^\\top \\mathbf{t} \\, \\mathrm{d}\\Gamma $$\n具有单位外法向量 $\\mathbf{n}$ 的边上的牵引力 $\\mathbf{t}$ 由 $\\mathbf{t} = \\hat{\\boldsymbol{\\sigma}}\\mathbf{n}$ 给出，其中 $\\hat{\\boldsymbol{\\sigma}}$ 是 Cauchy 应力张量。对于我们的恒定应力场，$\\mathbf{t}$ 沿着每条直边界边是恒定的。对于一个具有节点 $i$ 和 $j$ 的线性边单元，该积分将总的边力 $L_e t \\mathbf{t}$ 平均分配给两个节点：\n$$ \\mathbf{f}_{i, \\mathrm{trac}} = \\mathbf{f}_{j, \\mathrm{trac}} = \\frac{L_e t}{2} \\mathbf{t} $$\n其中 $L_e$ 是边长。这些节点力被组装成全局牵引力矢量 $\\mathbf{f}_{\\mathrm{trac}}$。\n\n然后计算所得残差矢量的范数 $\\|\\mathbf{r}\\|_2 = \\|\\mathbf{f}_{\\mathrm{int}} - \\mathbf{f}_{\\mathrm{trac}}\\|_2$。理论预测该范数将为零（在浮点容差范围内），这证实了 CST 列式通过了单元片检验。\n\n每个测试用例的计算步骤如下：\n1.  解析用例数据：节点坐标、单元连接关系、边界边、材料属性和线性场系数。\n2.  **再现误差**：\n    a. 对每个单元，确定采样点（形心、边中点）。\n    b. 通过在单元节点处计算给定的线性场，来计算精确的节点位移。\n    c. 在每个采样点，使用节点值和形函数计算插值得到的有限元位移。\n    d. 计算采样点处的精确位移。\n    e. 计算有限元位移和精确位移在 $u$ 和 $v$ 两个分量上的绝对误差。\n    f. 所有单元和采样点中这些误差的最大值即为该测试用例的结果。\n3.  **残差范数**：\n    a. 将全局力矢量 $\\mathbf{f}_{\\mathrm{int}}$ 和 $\\mathbf{f}_{\\mathrm{trac}}$ 初始化为零。\n    b. 根据线性场系数和材料属性计算常数应变矢量 $\\boldsymbol{\\varepsilon}$ 和应力矢量 $\\boldsymbol{\\sigma}$。\n    c. 遍历所有单元：计算单元内力矢量 $\\mathbf{f}_{e, \\mathrm{int}}$ 并将其组装到 $\\mathbf{f}_{\\mathrm{int}}$ 中。\n    d. 遍历所有边界边：计算牵引力矢量 $\\mathbf{t}$ 和节点力，并将其组装到 $\\mathbf{f}_{\\mathrm{trac}}$ 中。\n    e. 计算残差 $\\mathbf{r} = \\mathbf{f}_{\\mathrm{int}} - \\mathbf{f}_{\\mathrm{trac}}$ 及其欧几里得范数。\n\n该步骤在实现后，将从数值上证明 CST 列式对于常应变状态的正确性，这是有限元理论的一块基石。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the verification tests for CST elements.\n    \"\"\"\n    test_cases = [\n        {\n            \"nodes\": np.array([[0, 0], [1, 0], [1, 1], [0, 1]]),\n            \"elements\": np.array([[0, 1, 2], [0, 2, 3]]),\n            \"boundary_edges\": np.array([[0, 1], [1, 2], [2, 3], [3, 0]]),\n            \"material\": {\"E\": 210e9, \"nu\": 0.3, \"t\": 0.01},\n            \"field\": {\"a\": [1, 2, -3], \"b\": [-0.5, 4, 1]},\n        },\n        {\n            \"nodes\": np.array([[0, 0], [2, 0], [2, 1], [0, 1], [1, 0.5]]),\n            \"elements\": np.array([[0, 1, 4], [1, 2, 4], [2, 3, 4], [3, 0, 4]]),\n            \"boundary_edges\": np.array([[0, 1], [1, 2], [2, 3], [3, 0]]),\n            \"material\": {\"E\": 70e9, \"nu\": 0.25, \"t\": 0.02},\n            \"field\": {\"a\": [-0.1, 0.3, 0.2], \"b\": [0.7, -0.6, 0.4]},\n        },\n        {\n            \"nodes\": np.array([[0, 0], [0.001, 0], [1, 0.1]]),\n            \"elements\": np.array([[0, 1, 2]]),\n            \"boundary_edges\": np.array([[0, 1], [1, 2], [2, 0]]),\n            \"material\": {\"E\": 110e9, \"nu\": 0.29, \"t\": 0.005},\n            \"field\": {\"a\": [0.02, 0, 0.001], \"b\": [-0.03, -0.001, 0]},\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        err = calculate_reproduction_error(case)\n        residual_norm = calculate_residual_norm(case)\n        results.extend([err, residual_norm])\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef get_cst_b_matrix_and_area(node_coords):\n    \"\"\"\n    Computes the B-matrix and area for a CST element.\n    node_coords is a 3x2 numpy array of [[x1, y1], [x2, y2], [x3, y3]].\n    \"\"\"\n    mat = np.hstack([np.ones((3, 1)), node_coords])\n    area = 0.5 * np.linalg.det(mat)\n    \n    # Ensure area is positive (assumes CCW ordering)\n    if area  0:\n        # This case is not expected with problem data but good practice\n        node_coords = node_coords[[0, 2, 1], :]\n        area = -area\n\n    (x1, y1), (x2, y2), (x3, y3) = node_coords\n    \n    b_mat = (1 / (2 * area)) * np.array([\n        [y2 - y3, 0, y3 - y1, 0, y1 - y2, 0],\n        [0, x3 - x2, 0, x1 - x3, 0, x2 - x1],\n        [x3 - x2, y2 - y3, x1 - x3, y3 - y1, x2 - x1, y1 - y2]\n    ])\n    \n    return b_mat, area\n\ndef calculate_reproduction_error(case):\n    \"\"\"\n    Calculates the maximum absolute displacement reproduction error.\n    \"\"\"\n    nodes = case[\"nodes\"]\n    elements = case[\"elements\"]\n    a_coeffs, b_coeffs = case[\"field\"][\"a\"], case[\"field\"][\"b\"]\n\n    max_error = 0.0\n\n    # Define exact displacement field functions\n    def u_exact(x, y):\n        return a_coeffs[0] + a_coeffs[1] * x + a_coeffs[2] * y\n\n    def v_exact(x, y):\n        return b_coeffs[0] + b_coeffs[1] * x + b_coeffs[2] * y\n\n    for el_nodes_idx in elements:\n        node_coords = nodes[el_nodes_idx]\n        \n        # Get exact nodal displacements\n        nodal_u = u_exact(node_coords[:, 0], node_coords[:, 1])\n        nodal_v = v_exact(node_coords[:, 0], node_coords[:, 1])\n\n        # Define sample points: centroid and edge midpoints\n        p1, p2, p3 = node_coords[0], node_coords[1], node_coords[2]\n        sample_points = [\n            (p1 + p2 + p3) / 3.0,  # Centroid\n            (p1 + p2) / 2.0,       # Midpoint of edge 1-2\n            (p2 + p3) / 2.0,       # Midpoint of edge 2-3\n            (p3 + p1) / 2.0,       # Midpoint of edge 3-1\n        ]\n        \n        for sp in sample_points:\n            x_sp, y_sp = sp\n\n            # Calculate shape function values (using area coordinates)\n            mat = np.hstack([np.ones((3, 1)), node_coords])\n            total_area = 0.5 * np.linalg.det(mat)\n            \n            # Area coordinates L1, L2, L3 are the shape function values N1, N2, N3\n            N = np.zeros(3)\n            # N1 = Area(P, P2, P3) / TotalArea\n            N[0] = 0.5 * np.linalg.det(np.array([[1, x_sp, y_sp], [1, p2[0], p2[1]], [1, p3[0], p3[1]]])) / total_area\n            # N2 = Area(P, P3, P1) / TotalArea\n            N[1] = 0.5 * np.linalg.det(np.array([[1, x_sp, y_sp], [1, p3[0], p3[1]], [1, p1[0], p1[1]]])) / total_area\n            # N3 = 1 - N1 - N2\n            N[2] = 1.0 - N[0] - N[1]\n\n            # FE interpolated displacement\n            u_fe = np.dot(N, nodal_u)\n            v_fe = np.dot(N, nodal_v)\n\n            # Exact displacement\n            u_ex = u_exact(x_sp, y_sp)\n            v_ex = v_exact(x_sp, y_sp)\n\n            # Update max error\n            max_error = max(max_error, abs(u_fe - u_ex), abs(v_fe - v_ex))\n            \n    return max_error\n\ndef calculate_residual_norm(case):\n    \"\"\"\n    Calculates the Euclidean norm of the assembled residual vector.\n    \"\"\"\n    nodes = case[\"nodes\"]\n    elements = case[\"elements\"]\n    boundary_edges = case[\"boundary_edges\"]\n    E, nu, t = case[\"material\"][\"E\"], case[\"material\"][\"nu\"], case[\"material\"][\"t\"]\n    a_coeffs, b_coeffs = case[\"field\"][\"a\"], case[\"field\"][\"b\"]\n\n    num_nodes = len(nodes)\n    f_int = np.zeros(2 * num_nodes)\n    f_trac = np.zeros(2 * num_nodes)\n\n    # 1. Calculate constant strain and stress from the linear field\n    strain = np.array([\n        a_coeffs[1],                # eps_xx = a1\n        b_coeffs[2],                # eps_yy = b2\n        a_coeffs[2] + b_coeffs[1]   # gamma_xy = a2 + b1\n    ])\n    \n    # Plane stress constitutive matrix D\n    D_mat = (E / (1 - nu**2)) * np.array([\n        [1, nu, 0],\n        [nu, 1, 0],\n        [0, 0, (1 - nu) / 2]\n    ])\n    \n    stress = D_mat @ strain\n\n    # 2. Assemble internal force vector f_int\n    for el_nodes_idx in elements:\n        node_coords = nodes[el_nodes_idx]\n        b_mat, area = get_cst_b_matrix_and_area(node_coords)\n        \n        f_e_int = b_mat.T @ stress * area * t\n        \n        # Assembly map\n        dof_indices = np.array([2*i for i in el_nodes_idx] + [2*i+1 for i in el_nodes_idx]).reshape(2,3).T.flatten()\n        f_int[dof_indices] += f_e_int\n\n    # 3. Assemble traction force vector f_trac\n    # Stress tensor in 2x2 matrix form for traction calculation\n    stress_tensor = np.array([\n        [stress[0], stress[2]],  # [sigma_xx, sigma_xy]\n        [stress[2], stress[1]]   # [sigma_xy, sigma_yy]\n    ])\n    \n    for edge_nodes_idx in boundary_edges:\n        n1_idx, n2_idx = edge_nodes_idx\n        p1, p2 = nodes[n1_idx], nodes[n2_idx]\n        \n        dx, dy = p2[0] - p1[0], p2[1] - p1[1]\n        length = np.sqrt(dx**2 + dy**2)\n        \n        # Outward normal vector (assuming CCW boundary edge ordering)\n        normal = np.array([dy, -dx]) / length\n        \n        # Traction vector t = sigma * n\n        traction_vec = stress_tensor @ normal\n        \n        # Distribute force to nodes\n        node_force = (length * t / 2) * traction_vec\n        \n        # Assembly\n        f_trac[2*n1_idx: 2*n1_idx+2] += node_force\n        f_trac[2*n2_idx: 2*n2_idx+2] += node_force\n\n    # 4. Calculate residual and its norm\n    residual = f_int - f_trac\n    return np.linalg.norm(residual)\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "CST 单元中的“常应变”假设既是一种简化，也是一种限制。本练习  探讨了当真实位移场为二次函数时的情况。通过比较 CST 与更高阶的线性应变三角形（LST）单元的性能，我们将量化 CST 的内在近似误差，并亲眼见证为何需要 LST 单元来精确捕捉变化的应变场。",
            "id": "3607784",
            "problem": "一个二维小应变连续体被用三角形有限元离散化。考虑恒定应变三角形 (CST) 和线性应变三角形 (LST)。CST 在一个三节点三角形上采用线性形函数，从而在单元内部产生一个恒定的应变场。LST 在一个六节点三角形（三个顶点和三个边中点节点）上采用二次形函数，可以精确插值单元内的任何二次位移场。\n\n从二维无穷小应变的定义出发，设位移场是关于位置的二次函数：\n$$\nu(x,y) = a\\,x^2 + b\\,x\\,y + c\\,y^2 + d\\,x + e\\,y + f,\\qquad\nv(x,y) = p\\,x^2 + q\\,x\\,y + r\\,y^2 + s\\,x + t\\,y + w,\n$$\n其中 $u$ 和 $v$ 是位移分量，$a,b,c,d,e,f,p,q,r,s,t,w$ 是实系数。小应变张量分量定义为\n$$\n\\varepsilon_{xx} = \\frac{\\partial u}{\\partial x},\\quad\n\\varepsilon_{yy} = \\frac{\\partial v}{\\partial y},\\quad\n\\varepsilon_{xy} = \\frac{1}{2}\\left(\\frac{\\partial u}{\\partial y} + \\frac{\\partial v}{\\partial x}\\right).\n$$\n对于一个给定顶点为 $(x_1,y_1)$、$(x_2,y_2)$、$(x_3,y_3)$ 的三角形，将其重心（面积）坐标记为 $(L_1,L_2,L_3)$，满足 $L_1+L_2+L_3=1$ 且 $L_i\\ge 0$。CST 使用线性形函数 $N_1=L_1$、$N_2=L_2$、$N_3=L_3$。LST 使用二次形函数 $N_1=L_1(2L_1-1)$、$N_2=L_2(2L_2-1)$、$N_3=L_3(2L_3-1)$、$N_4=4L_1L_2$、$N_5=4L_2L_3$、$N_6=4L_3L_1$。在单元上，重心坐标是 $(x,y)$ 的线性函数，并且它们的梯度是恒定的。\n\n你的任务是实现一个程序，该程序：\n- 根据指定的系数构建精确的二次位移场。\n- 通过在节点处评估精确位移场，计算 CST 的顶点节点位移和 LST 的 $6$ 个节点（顶点和边中点节点）的节点位移。\n- 为 CST 和 LST 形成单元位移近似，并使用小应变定义计算相应的应变分量。\n- 从二次场中评估精确的应变分量。\n- 通过在一组由重心坐标指定的内部采样点上计算均方根 (RMS) 范数，来量化单元内部的残余应变误差。\n\n使用以下由三个案例组成的测试套件，每个案例都由三角形顶点坐标和位移系数定义：\n- 案例 1（具有二次和线性混合项的一般不等边三角形）：\n  - 三角形顶点：$(0,0)$、$(2,0)$、$(0.5,1.5)$。\n  - u 的系数：$a=0.3$、$b=-0.2$、$c=0.4$、$d=1.0$、$e=-0.5$、$f=0.0$。\n  - v 的系数：$p=-0.1$、$q=0.25$、$r=0.2$、$s=-0.7$、$t=0.3$、$w=0.2$。\n- 案例 2（具有纯二次场的等边三角形）：\n  - 三角形顶点：$(0,0)$、$(1,0)$、$\\left(0.5,\\frac{\\sqrt{3}}{2}\\right)$。\n  - u 的系数：$a=0.5$、$b=0.1$、$c=0.3$、$d=0.0$、$e=0.0$、$f=0.0$。\n  - v 的系数：$p=-0.4$、$q=0.2$、$r=0.1$、$s=0.0$、$t=0.0$、$w=0.0$。\n- 案例 3（用于探究几何条件数的窄长三角形）：\n  - 三角形顶点：$(0,0)$、$(10^{-3},0)$、$(0,1.0)$。\n  - u 的系数：$a=0.8$、$b=-0.6$、$c=0.5$、$d=0.0$、$e=1.0$、$f=-0.3$。\n  - v 的系数：$p=0.2$、$q=0.3$、$r=-0.4$、$s=0.0$、$t=-0.2$、$w=0.5$。\n\n使用以下由重心坐标定义的 $7$ 个采样点来评估 RMS 误差：\n$$\n(1/3,1/3,1/3),\\ (0.6,0.2,0.2),\\ (0.2,0.6,0.2),\\ (0.2,0.2,0.6),\\ (0.05,0.05,0.90),\\ (0.05,0.90,0.05),\\ (0.90,0.05,0.05).\n$$\n在每个采样点，计算 CST 和 LST 的近似应变以及来自二次场的精确应变，得到每种方法的误差向量 $(\\varepsilon_{xx}^{h}-\\varepsilon_{xx}^{\\text{exact}},\\varepsilon_{yy}^{h}-\\varepsilon_{yy}^{\\text{exact}},\\varepsilon_{xy}^{h}-\\varepsilon_{xy}^{\\text{exact}})$，累加误差范数的平方和，然后除以采样点数并取平方根，以获得 RMS 误差。应变是无量纲的；将 RMS 残差报告为无量纲浮点数。\n\n你的程序应生成单行输出，其中包含 6 个结果，形式为方括号括起来的逗号分隔列表，顺序为 $[\\text{案例 }1\\ \\text{CST RMS},\\ \\text{案例 }1\\ \\text{LST RMS},\\ \\text{案例 }2\\ \\text{CST RMS},\\ \\text{案例 }2\\ \\text{LST RMS},\\ \\text{案例 }3\\ \\text{CST RMS},\\ \\text{案例 }3\\ \\text{LST RMS}]$。例如，输出格式为 $[r_1^{\\text{CST}},r_1^{\\text{LST}},r_2^{\\text{CST}},r_2^{\\text{LST}},r_3^{\\text{CST}},r_3^{\\text{LST}}]$。",
            "solution": "该问题已经过验证，被认为是合理的。这是一个适定的数值分析问题，其基础是计算固体力学和有限元法的原理。所有需要的数据和定义都已提供，没有内部矛盾或科学上的不准确之处。\n\n解决方案通过实施一项计算分析来进行，以量化恒定应变三角形 (CST) 和线性应变三角形 (LST) 单元在承受精确二次位移场时产生的应变近似误差。该误差通过应变张量分量的均方根 (RMS) 范数来衡量，该范数是在单元内一组预设的采样点上进行评估的。\n\n首先，我们定义精确的位移场和应变场。问题提供了二维 $(x, y)$ 上的一个通用二次位移场：\n$$u(x,y) = a\\,x^2 + b\\,x\\,y + c\\,y^2 + d\\,x + e\\,y + f$$\n$$v(x,y) = p\\,x^2 + q\\,x\\,y + r\\,y^2 + s\\,x + t\\,y + w$$\n其中 $u$ 和 $v$ 分别是沿 $x$ 和 $y$ 轴的位移分量。系数 $a,b,c,d,e,f,p,q,r,s,t,w$ 在每个测试案例中给出。\n\n精确的无穷小应变张量分量 $(\\varepsilon_{xx}^{\\text{exact}}, \\varepsilon_{yy}^{\\text{exact}}, \\varepsilon_{xy}^{\\text{exact}})$ 是根据小应变定义对位移场进行微分推导得出的：\n$$\\varepsilon_{xx}^{\\text{exact}} = \\frac{\\partial u}{\\partial x} = 2ax + by + d$$\n$$\\varepsilon_{yy}^{\\text{exact}} = \\frac{\\partial v}{\\partial y} = qx + 2ry + t$$\n$$\\varepsilon_{xy}^{\\text{exact}} = \\frac{1}{2}\\left(\\frac{\\partial u}{\\partial y} + \\frac{\\partial v}{\\partial x}\\right) = \\frac{1}{2}\\left( (bx + 2cy + e) + (2px + qy + s) \\right) = \\left(\\frac{b}{2} + p\\right)x + \\left(c + \\frac{q}{2}\\right)y + \\frac{e+s}{2}$$\n注意，对于二次位移场，得到的应变场是关于位置 $(x, y)$ 的线性函数。\n\n接下来，我们构建有限元近似。此公式的一个关键组成部分是使用重心坐标 $(L_1, L_2, L_3)$，该坐标用于顶点为 $(x_1, y_1)$、$(x_2, y_2)$ 和 $(x_3, y_3)$ 的三角形。三角形内的任何点 $(x,y)$ 都可以表示为顶点的凸组合：$x = L_1x_1 + L_2x_2 + L_3x_3$ 和 $y = L_1y_1 + L_2y_2 + L_3y_3$，其中 $L_1+L_2+L_3=1$。近似位移场 $u^h(x,y)$ 是通过使用形函数 $N_i$ 插值节点位移 $u_i$ 来构建的：$u^h = \\sum_i N_i u_i$。为了计算应变，我们需要形函数的空间梯度。由于形函数是根据重心坐标定义的，我们使用链式法则：$\\frac{\\partial N_i}{\\partial x} = \\sum_{j=1}^3 \\frac{\\partial N_i}{\\partial L_j} \\frac{\\partial L_j}{\\partial x}$。重心坐标的梯度在整个单元内是恒定的，并由以下公式给出：\n$$ \\frac{\\partial L_1}{\\partial x} = \\frac{y_2 - y_3}{2A}, \\quad \\frac{\\partial L_1}{\\partial y} = \\frac{x_3 - x_2}{2A} $$\n$$ \\frac{\\partial L_2}{\\partial x} = \\frac{y_3 - y_1}{2A}, \\quad \\frac{\\partial L_2}{\\partial y} = \\frac{x_1 - x_3}{2A} $$\n$$ \\frac{\\partial L_3}{\\partial x} = \\frac{y_1 - y_2}{2A}, \\quad \\frac{\\partial L_3}{\\partial y} = \\frac{x_2 - x_1}{2A} $$\n其中 $A$ 是三角形的面积，计算公式为 $2A = x_1(y_2 - y_3) + x_2(y_3 - y_1) + x_3(y_1 - y_2)$。\n\n对于恒定应变三角形 (CST)，我们在顶点处有 $3$ 个节点。形函数是线性的：$N_1=L_1, N_2=L_2, N_3=L_3$。因此，位移近似 $u^h$ 是线性的，而其导数，即应变 $\\varepsilon^h$，是恒定的。节点位移 $(u_i,v_i)$（对于 $i=1,2,3$）是通过在顶点坐标处评估精确的二次位移场获得的。然后，恒定的近似应变分量为：\n$$ \\varepsilon_{xx}^h = \\sum_{i=1}^3 \\frac{\\partial N_i}{\\partial x} u_i = \\sum_{i=1}^3 \\frac{\\partial L_i}{\\partial x} u_i $$\n$$ \\varepsilon_{yy}^h = \\sum_{i=1}^3 \\frac{\\partial N_i}{\\partial y} v_i = \\sum_{i=1}^3 \\frac{\\partial L_i}{\\partial y} v_i $$\n$$ \\varepsilon_{xy}^h = \\frac{1}{2} \\left( \\sum_{i=1}^3 \\frac{\\partial N_i}{\\partial y} u_i + \\sum_{i=1}^3 \\frac{\\partial N_i}{\\partial x} v_i \\right) $$\n由于精确应变场是线性的，而 CST 近似是恒定的，因此预计会存在误差。\n\n对于线性应变三角形 (LST)，我们有 6 个节点：3 个在顶点，3 个在边的中点。形函数 $N_i$ 是重心坐标的二次多项式。对于 LST 单元，关键的见解在于它能够精确表示任何二次多项式。二元二次多项式空间 $P_2(x,y)$ 有 6 个自由度（对应于 $1, x, y, x^2, xy, y^2$ 的系数）。一个 LST 单元有 6 个节点。一个二次多项式由其在 6 个非退化点上的值唯一确定。由于精确位移场 $(u, v)$ 是二次的，并且 LST 节点位移 $(u_i, v_i)$ 是从这个精确场评估得出的，因此 LST 插值 $u^h = \\sum_{i=1}^6 N_i u_i$ 将在单元内的任何地方都与精确场 $u(x,y)$ 完全相同。这是有限元完备性的一个基本性质。因此，从 LST 近似推导出的应变 $\\varepsilon^h$ 将与精确应变 $\\varepsilon^{\\text{exact}}$ 完全相同。所以，LST 单元的应变误差恒等于零，最终的 RMS 误差为 $0.0$。\n\n残余误差通过 RMS 范数量化。对于 $N_{sp}=7$ 个采样点中的每一个，我们计算应变误差向量 $\\mathbf{e} = (\\varepsilon_{xx}^{h}-\\varepsilon_{xx}^{\\text{exact}},\\varepsilon_{yy}^{h}-\\varepsilon_{yy}^{\\text{exact}},\\varepsilon_{xy}^{h}-\\varepsilon_{xy}^{\\text{exact}})$。RMS 误差则为：\n$$ \\text{RMS error} = \\sqrt{\\frac{1}{N_{sp}} \\sum_{k=1}^{N_{sp}} \\|\\mathbf{e}_k\\|^2_2} = \\sqrt{\\frac{1}{N_{sp}} \\sum_{k=1}^{N_{sp}} \\left( (\\varepsilon_{xx,k}^{h}-\\varepsilon_{xx,k}^{\\text{exact}})^2 + (\\varepsilon_{yy,k}^{h}-\\varepsilon_{yy,k}^{\\text{exact}})^2 + (\\varepsilon_{xy,k}^{h}-\\varepsilon_{xy,k}^{\\text{exact}})^2 \\right)} $$\n对于 CST 单元，该值通过数值计算得出。对于 LST 单元，该值在理论上和数值上均为 $0.0$。\n\n所实现的算法对每个测试案例执行以下步骤：\n1.  根据给定的系数定义精确的位移和应变函数。\n2.  计算单元的几何属性（面积和重心坐标梯度）。\n3.  对于 CST 分析：\n    a. 在 3 个顶点节点处评估精确位移。\n    b. 计算 CST 单元的恒定应变分量。\n    c. 将误差平方和初始化为 $0$。\n    d. 对于 7 个采样点中的每一个（以重心坐标给出）：\n        i. 将重心坐标转换为笛卡尔坐标 $(x_{sp}, y_{sp})$。\n        ii. 在 $(x_{sp}, y_{sp})$ 处评估精确应变。\n        iii. 计算该点处恒定 CST 应变与精确应变之间的误差向量的平方范数。\n        iv. 将此值加到误差平方和中。\n    e. 通过计算误差平方和的平均值的平方根，来计算 CST 的最终 RMS 误差。\n4.  对于 LST 分析，根据上述理论论证，RMS 误差设置为 $0.0$。\n5.  收集所有案例的结果，并以指定格式呈现。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the finite element analysis problem for CST and LST elements.\n    \"\"\"\n\n    def calculate_rms_errors(vertices, u_coeffs, v_coeffs):\n        \"\"\"\n        Calculates RMS strain errors for CST and LST for a single test case.\n\n        Args:\n            vertices (tuple): A tuple of 3 vertex coordinates ((x1, y1), ...).\n            u_coeffs (tuple): Coefficients a, b, c, d, e, f for the u-displacement.\n            v_coeffs (tuple): Coefficients p, q, r, s, t, w for the v-displacement.\n\n        Returns:\n            tuple: A tuple containing (rms_err_cst, rms_err_lst).\n        \"\"\"\n        # Unpack vertices\n        (x1, y1), (x2, y2), (x3, y3) = vertices\n        \n        # Unpack coefficients\n        a, b, c, d, e, f = u_coeffs\n        p, q, r, s, t, w = v_coeffs\n\n        # --- Exact field and strain definitions ---\n        def u_exact(x, y):\n            return a*x**2 + b*x*y + c*y**2 + d*x + e*y + f\n\n        def v_exact(x, y):\n            return p*x**2 + q*x*y + r*y**2 + s*x + t*y + w\n\n        def eps_xx_exact(x, y):\n            return 2*a*x + b*y + d\n\n        def eps_yy_exact(x, y):\n            return q*x + 2*r*y + t\n\n        def eps_xy_exact(x, y):\n            # 0.5 * ( (b*x + 2*c*y + e) + (2*p*x + q*y + s) )\n            return (0.5*b + p)*x + (c + 0.5*q)*y + 0.5*(e + s)\n\n        # --- CST (Constant Strain Triangle) Calculation ---\n        \n        # Triangle Area and Barycentric coordinate gradients\n        two_A = x1*(y2 - y3) + x2*(y3 - y1) + x3*(y1 - y2)\n        if abs(two_A)  1e-20:  # Avoid division by zero for collinear points\n            return np.nan, np.nan\n\n        L1x = (y2 - y3) / two_A\n        L1y = (x3 - x2) / two_A\n        L2x = (y3 - y1) / two_A\n        L2y = (x1 - x3) / two_A\n        L3x = (y1 - y2) / two_A\n        L3y = (x2 - x1) / two_A\n\n        # Nodal displacements for CST (3 vertices)\n        u1, v1 = u_exact(x1, y1), v_exact(x1, y1)\n        u2, v2 = u_exact(x2, y2), v_exact(x2, y2)\n        u3, v3 = u_exact(x3, y3), v_exact(x3, y3)\n        \n        # Constant strain components for CST\n        eps_xx_cst = L1x*u1 + L2x*u2 + L3x*u3\n        eps_yy_cst = L1y*v1 + L2y*v2 + L3y*v3\n        eps_xy_cst = 0.5 * ((L1y*u1 + L2y*u2 + L3y*u3) + (L1x*v1 + L2x*v2 + L3x*v3))\n\n        # --- Error calculation over specified sampling points ---\n        sampling_points_bary = [\n            (1/3, 1/3, 1/3),\n            (0.6, 0.2, 0.2), (0.2, 0.6, 0.2), (0.2, 0.2, 0.6),\n            (0.05, 0.05, 0.90), (0.05, 0.90, 0.05), (0.90, 0.05, 0.05),\n        ]\n        \n        sum_sq_err_cst = 0.0\n        for L1s, L2s, L3s in sampling_points_bary:\n            # Cartesian coordinates of the sampling point\n            xs = L1s*x1 + L2s*x2 + L3s*x3\n            ys = L1s*y1 + L2s*y2 + L3s*y3\n\n            # Exact strain at the sampling point\n            exx_e = eps_xx_exact(xs, ys)\n            eyy_e = eps_yy_exact(xs, ys)\n            exy_e = eps_xy_exact(xs, ys)\n\n            # Error for CST\n            err_xx = eps_xx_cst - exx_e\n            err_yy = eps_yy_cst - eyy_e\n            err_xy = eps_xy_cst - exy_e\n            sum_sq_err_cst += err_xx**2 + err_yy**2 + err_xy**2\n\n        num_sampling_points = len(sampling_points_bary)\n        rms_err_cst = np.sqrt(sum_sq_err_cst / num_sampling_points)\n\n        # --- LST (Linear Strain Triangle) Calculation ---\n        # The LST element with quadratic shape functions can exactly represent the\n        # quadratic displacement field. Therefore, the approximated strains are\n        # identical to the exact strains, and the error is zero.\n        rms_err_lst = 0.0\n\n        return rms_err_cst, rms_err_lst\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"vertices\": ((0.0, 0.0), (2.0, 0.0), (0.5, 1.5)),\n            \"u_coeffs\": (0.3, -0.2, 0.4, 1.0, -0.5, 0.0),\n            \"v_coeffs\": (-0.1, 0.25, 0.2, -0.7, 0.3, 0.2),\n        },\n        {\n            \"vertices\": ((0.0, 0.0), (1.0, 0.0), (0.5, np.sqrt(3)/2)),\n            \"u_coeffs\": (0.5, 0.1, 0.3, 0.0, 0.0, 0.0),\n            \"v_coeffs\": (-0.4, 0.2, 0.1, 0.0, 0.0, 0.0),\n        },\n        {\n            \"vertices\": ((0.0, 0.0), (1e-3, 0.0), (0.0, 1.0)),\n            \"u_coeffs\": (0.8, -0.6, 0.5, 0.0, 1.0, -0.3),\n            \"v_coeffs\": (0.2, 0.3, -0.4, 0.0, -0.2, 0.5),\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        rms_cst, rms_lst = calculate_rms_errors(\n            case[\"vertices\"], \n            case[\"u_coeffs\"], \n            case[\"v_coeffs\"]\n        )\n        results.append(rms_cst)\n        results.append(rms_lst)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}