{
    "hands_on_practices": [
        {
            "introduction": "第一个练习将通过量化分析，直观地展示剪切锁定现象。通过为一个铁木辛柯梁建立一个简单的有限元模型，您将对比完全积分和减缩积分方案在计算悬臂梁末端挠度时的表现，并将其与精确解进行比较。这个过程将使“锁定”这一抽象概念，转变为一个可触摸、可度量的数值结果。",
            "id": "3600155",
            "problem": "一根长度为 $L$、矩形截面宽度为 $b$、厚度为 $h$ 的悬臂梁，使用Timoshenko梁理论 (TBT) 进行建模，并通过有限元法 (FEM) 进行离散化。离散化采用双节点线性单元来描述横向位移 $w(x)$ 和转角 $\\theta(x)$。梁在 $x=0$ 处被固支，并在自由端 $x=L$ 处承受一个横向集中荷载 $P$。材料是线性弹性的，其杨氏模量为 $E$，泊松比为 $\\nu$，剪切模量为 $G = \\dfrac{E}{2(1+\\nu)}$。剪切修正因子 $\\kappa$ 用于修正抗剪刚度，以考虑沿厚度方向的非均匀剪应力分布。本题的目标是为细长梁和厚梁建立尖端挠度的定量基准，并通过比较剪切能的完全积分与减缩积分来揭示剪切锁定现象。\n\n从基本原理出发：Timoshenko梁的运动学关系表明，剪应变为 $\\gamma(x) = \\dfrac{dw}{dx} - \\theta(x)$，弯曲曲率为 $\\dfrac{d\\theta}{dx}$。本构关系为弯矩 $M(x) = E I \\dfrac{d\\theta}{dx}$ 和剪力 $V(x) = \\kappa G A \\gamma(x)$，其中 $I = \\dfrac{b h^3}{12}$ 是截面二次矩，$A = b h$ 是截面面积。在尖端荷载 $P$ 作用下，梁的总势能为\n$$\n\\Pi[w,\\theta] = \\int_{0}^{L} \\left( \\tfrac{1}{2} E I \\left(\\dfrac{d\\theta}{dx}\\right)^2 + \\tfrac{1}{2} \\kappa G A \\left(\\dfrac{dw}{dx} - \\theta\\right)^2 \\right) \\, dx \\;-\\; P\\, w(L).\n$$\n对每个单元使用线性形函数离散化 $w$ 和 $\\theta$，组装全局刚度矩阵，在 $x=0$ 处施加固支边界条件 ($w(0)=0$, $\\theta(0)=0$)，并求解节点自由度。计算每个测试用例下有限元模型的尖端挠度 $w(L)$。作为定量基准，将数值计算得到的 $w(L)$ 与Timoshenko梁理论下悬臂梁在尖端荷载作用下的精确解析尖端挠度进行比较，\n$$\nw_{\\mathrm{exact}} = \\frac{P L^3}{3 E I} + \\frac{P L}{\\kappa G A}.\n$$\n定义无量纲比率\n$$\nR = \\frac{w_{\\mathrm{FE}}}{w_{\\mathrm{exact}}},\n$$\n其中 $w_{\\mathrm{FE}}$ 是有限元的尖端挠度。使用此比率来评估精度并识别剪切锁定，其中 $R<1$ 表示由于锁定导致的刚度过大。\n\n对剪切项 $\\int \\tfrac{1}{2} \\kappa G A \\left(\\dfrac{dw}{dx}-\\theta\\right)^2 dx$ 实现两种求积方案：\n- 在参考单元上使用$2$点Gauss-Legendre求积的完全积分，\n- 在参考单元上使用$1$点Gauss-Legendre求积的减缩积分。\n弯曲项 $\\int \\tfrac{1}{2} E I \\left(\\dfrac{d\\theta}{dx}\\right)^2 dx$ 应被精确积分。\n\n在国际单位制 (SI) 中使用以下科学上符合实际的材料和几何参数：$E = 2.10 \\times 10^{11}\\,\\mathrm{Pa}$，$\\nu = 0.3$，$\\kappa = \\dfrac{5}{6}$，$b = 1.0 \\times 10^{-2}\\,\\mathrm{m}$，$L = 1.0\\,\\mathrm{m}$，以及 $P = 1.0 \\times 10^{3}\\,\\mathrm{N}$。考虑两种厚度以涵盖从细长梁到厚梁的范围：$h \\in \\{1.0 \\times 10^{-3}\\,\\mathrm{m},\\, 1.0 \\times 10^{-1}\\,\\mathrm{m}\\}$，并采用不同的网格分辨率和积分方案。\n\n将测试套件设计为以下六个案例，每个案例由元组 $(L,b,h,E,\\nu,\\kappa,P,N_{\\mathrm{el}},n_{\\mathrm{g}})$ 指定，其中 $N_{\\mathrm{el}}$ 是单元数量，$n_{\\mathrm{g}}$ 是用于剪切项的Gauss点数：\n- 案例 1：$(1.0,\\, 1.0\\times 10^{-2},\\, 1.0\\times 10^{-3},\\, 2.10\\times 10^{11},\\, 0.3,\\, \\dfrac{5}{6},\\, 1.0\\times 10^{3},\\, 1,\\, 2)$。\n- 案例 2：$(1.0,\\, 1.0\\times 10^{-2},\\, 1.0\\times 10^{-3},\\, 2.10\\times 10^{11},\\, 0.3,\\, \\dfrac{5}{6},\\, 1.0\\times 10^{3},\\, 1,\\, 1)$。\n- 案例 3：$(1.0,\\, 1.0\\times 10^{-2},\\, 1.0\\times 10^{-3},\\, 2.10\\times 10^{11},\\, 0.3,\\, \\dfrac{5}{6},\\, 1.0\\times 10^{3},\\, 8,\\, 2)$。\n- 案例 4：$(1.0,\\, 1.0\\times 10^{-2},\\, 1.0\\times 10^{-3},\\, 2.10\\times 10^{11},\\, 0.3,\\, \\dfrac{5}{6},\\, 1.0\\times 10^{3},\\, 8,\\, 1)$。\n- 案例 5：$(1.0,\\, 1.0\\times 10^{-2},\\, 1.0\\times 10^{-1},\\, 2.10\\times 10^{11},\\, 0.3,\\, \\dfrac{5}{6},\\, 1.0\\times 10^{3},\\, 2,\\, 2)$。\n- 案例 6：$(1.0,\\, 1.0\\times 10^{-2},\\, 1.0\\times 10^{-1},\\, 2.10\\times 10^{11},\\, 0.3,\\, \\dfrac{5}{6},\\, 1.0\\times 10^{3},\\, 2,\\, 1)$。\n\n您的程序必须计算每个案例的 $R$ 值。最终输出必须是单行文本，包含一个由方括号括起来的、用逗号分隔的六个比率列表，每个比率四舍五入到$6$位小数，例如 $\\left[\\dots\\right]$。由于 $R$ 是无量纲的，输出中不需要物理单位。不允许使用外部输入或文件；所有参数都将嵌入到程序中。",
            "solution": "该问题要求使用基于Timoshenko梁理论 (TBT) 的有限元法 (FEM) 计算悬臂梁的尖端挠度。目标是通过比较细长梁和厚梁在完全和减缩数值积分方案下的结果，来分析剪切锁定现象。数值结果将与精确解析解进行比较。\n\n出发点是梁的总势能 $\\Pi$，它是应变能和外荷载势能之和。\n$$\n\\Pi[w,\\theta] = U_b + U_s - W_{ext} = \\int_{0}^{L} \\frac{1}{2} E I \\left(\\frac{d\\theta}{dx}\\right)^2 dx + \\int_{0}^{L} \\frac{1}{2} \\kappa G A \\left(\\frac{dw}{dx} - \\theta\\right)^2 dx - P w(L)\n$$\n此处，$U_b$是弯曲应变能，$U_s$是剪切应变能。$w(x)$是横向位移，$\\theta(x)$是截面转角，$E$是杨氏模量，$I$是截面二次矩，$\\kappa$是剪切修正因子，$G$是剪切模量，$A$是截面面积，$L$是梁的长度，$P$是尖端荷载。\n\n在有限元法中，连续函数 $w(x)$ 和 $\\theta(x)$ 在每个单元上使用形函数和节点值进行近似。对于长度为 $l_e$ 的双节点线性单元，其近似表示为：\n$$\nw(\\xi) = N_1(\\xi) w_1 + N_2(\\xi) w_2 \\quad \\text{and} \\quad \\theta(\\xi) = N_1(\\xi) \\theta_1 + N_2(\\xi) \\theta_2\n$$\n其中 $\\xi \\in [-1, 1]$ 是单元上的自然坐标，$w_i$ 和 $\\theta_i$ 是节点自由度 (DOFs)，$N_1(\\xi) = \\frac{1}{2}(1-\\xi)$ 和 $N_2(\\xi) = \\frac{1}{2}(1+\\xi)$ 是线性形函数。单元的节点位移向量为 $\\mathbf{d}_e = [w_1, \\theta_1, w_2, \\theta_2]^T$。\n\n弯曲曲率和剪应变用节点自由度表示。在线性单元内，曲率 $\\frac{d\\theta}{dx}$ 是一个常数：\n$$\n\\frac{d\\theta}{dx} = \\frac{d\\theta}{d\\xi}\\frac{d\\xi}{dx} = \\frac{1}{l_e}(-\\theta_1 + \\theta_2) = \\mathbf{B}_b \\mathbf{d}_e, \\quad \\text{where } \\mathbf{B}_b = \\frac{1}{l_e}[0, -1, 0, 1]\n$$\n剪应变 $\\gamma(x) = \\frac{dw}{dx} - \\theta(x)$ 为：\n$$\n\\gamma(\\xi) = \\frac{1}{l_e}(-w_1 + w_2) - (N_1(\\xi)\\theta_1 + N_2(\\xi)\\theta_2) = \\mathbf{B}_s(\\xi) \\mathbf{d}_e\n$$\n其中 $\\mathbf{B}_s(\\xi) = [-\\frac{1}{l_e}, -N_1(\\xi), \\frac{1}{l_e}, -N_2(\\xi)]$。\n\n单元刚度矩阵 $\\mathbf{K}_e$ 通过最小化势能导出，得到 $\\mathbf{K}_e = \\mathbf{K}_{b,e} + \\mathbf{K}_{s,e}$。弯曲刚度矩阵 $\\mathbf{K}_{b,e}$ 为：\n$$\n\\mathbf{K}_{b,e} = \\int_0^{l_e} E I (\\mathbf{B}_b)^T \\mathbf{B}_b dx = E I l_e (\\mathbf{B}_b)^T \\mathbf{B}_b = \\frac{E I}{l_e} \\begin{bmatrix} 0 & 0 & 0 & 0 \\\\ 0 & 1 & 0 & -1 \\\\ 0 & 0 & 0 & 0 \\\\ 0 & -1 & 0 & 1 \\end{bmatrix}\n$$\n由于被积函数是常数，这代表了精确积分。\n\n剪切刚度矩阵 $\\mathbf{K}_{s,e}$ 通过在单元长度上进行数值积分计算得出：\n$$\n\\mathbf{K}_{s,e} = \\int_0^{l_e} \\kappa G A (\\mathbf{B}_s)^T \\mathbf{B}_s dx = \\int_{-1}^{1} \\kappa G A (\\mathbf{B}_s(\\xi))^T \\mathbf{B}_s(\\xi) \\frac{l_e}{2} d\\xi\n$$\n\n对于减缩积分 ($n_g=1$)，我们使用位于 $\\xi=0$ 处的一个Gauss点，其权重为 $w_1=2$。在 $\\xi=0$ 处，$N_1(0)=N_2(0)=1/2$，且 $\\mathbf{B}_s(0) = [-\\frac{1}{l_e}, -\\frac{1}{2}, \\frac{1}{l_e}, -\\frac{1}{2}]$。积分变为：\n$$\n\\mathbf{K}_{s,e}^{(\\text{1-pt})} = \\kappa G A \\frac{l_e}{2} \\left( w_1 (\\mathbf{B}_s(0))^T \\mathbf{B}_s(0) \\right) = \\kappa G A l_e (\\mathbf{B}_s(0))^T \\mathbf{B}_s(0)\n$$\n$$\n\\mathbf{K}_{s,e}^{(\\text{1-pt})} = \\kappa G A \\begin{bmatrix} 1/l_e & 1/2 & -1/l_e & 1/2 \\\\ 1/2 & l_e/4 & -1/2 & l_e/4 \\\\ -1/l_e & -1/2 & 1/l_e & -1/2 \\\\ 1/2 & l_e/4 & -1/2 & l_e/4 \\end{bmatrix}\n$$\n\n对于完全积分 ($n_g=2$)，我们使用位于 $\\xi_{1,2} = \\mp 1/\\sqrt{3}$ 处的两个Gauss点，其权重为 $w_{1,2}=1$。这等效于对 $(\\mathbf{B}_s)^T \\mathbf{B}_s$ 中的多项式项进行精确积分，这些项在 $\\xi$ 中最多是二次的。得到的矩阵是：\n$$\n\\mathbf{K}_{s,e}^{(\\text{2-pt})} = \\kappa G A \\begin{bmatrix} 1/l_e & 1/2 & -1/l_e & 1/2 \\\\ 1/2 & l_e/3 & -1/2 & l_e/6 \\\\ -1/l_e & -1/2 & 1/l_e & -1/2 \\\\ 1/2 & l_e/6 & -1/2 & l_e/3 \\end{bmatrix}\n$$\n总单元刚度矩阵为 $\\mathbf{K}_e = \\mathbf{K}_{b,e} + \\mathbf{K}_{s,e}$，其中使用相应的剪切矩阵。\n\n对于包含 $N_{\\mathrm{el}}$ 个单元的网格，组装全局刚度矩阵 $\\mathbf{K}$ 和力向量 $\\mathbf{F}$。该系统有 $2(N_{\\mathrm{el}}+1)$ 个自由度。荷载向量 $\\mathbf{F}$ 除了对应于尖端节点 ($x=L$) 横向位移的项等于 $P$ 之外，其余项均为零。通过移除 $\\mathbf{K}$ 的前两行和前两列以及 $\\mathbf{F}$ 的前两项，来施加根部 ($x=0$) 的固支边界条件 $w(0)=0$ 和 $\\theta(0)=0$。然后求解得到的简化系统 $\\mathbf{K}_{\\text{reduced}} \\mathbf{d}_{\\text{reduced}} = \\mathbf{F}_{\\text{reduced}}$，以获得未知的节点自由度 $\\mathbf{d}_{\\text{reduced}}$。\n\n从解向量中，提取出尖端挠度 $w_{\\mathrm{FE}} = w(L)$。将其与TBT的精确解析解进行比较：\n$$\nw_{\\mathrm{exact}} = \\frac{P L^3}{3 E I} + \\frac{P L}{\\kappa G A}\n$$\n为每个测试用例计算无量纲比率 $R = w_{\\mathrm{FE}}/w_{\\mathrm{exact}}$。对于细长梁，剪应变 $\\gamma = dw/dx - \\theta$ 必须趋近于零。使用线性单元的完全积分会过强地施加此条件，导致单元变得过刚，这种现象称为剪切锁定，表现为 $R \\ll 1$。对剪切项进行减缩积分可以放宽此约束，从而缓解锁定现象，并为细长梁产生更精确的结果。\n\n每个测试用例的计算步骤如下：\n1.  定义几何和材料参数。\n2.  计算单元长度 $l_e = L/N_{\\mathrm{el}}$。\n3.  计算单元弯曲刚度矩阵 $\\mathbf{K}_{b,e}$。\n4.  根据指定的Gauss点数 $n_{\\mathrm{g}}$ 计算单元剪切刚度矩阵 $\\mathbf{K}_{s,e}$。\n5.  形成总单元刚度矩阵 $\\mathbf{K}_e$。\n6.  为包含 $N_{\\mathrm{el}}$ 个单元的网格组装全局刚度矩阵 $\\mathbf{K}$。\n7.  定义尖端荷载为 $P$ 的全局力向量 $\\mathbf{F}$。\n8.  施加边界条件以获得简化系统。\n9.  求解线性系统以获得未知位移。\n10. 提取数值尖端挠度 $w_{\\mathrm{FE}}$。\n11. 计算精确尖端挠度 $w_{\\mathrm{exact}}$。\n12. 计算并存储比率 $R = w_{\\mathrm{FE}} / w_{\\mathrm{exact}}$。\n\n对所有六个指定的测试用例重复此过程，涵盖具有不同网格分辨率和积分方案的细长梁和厚梁，以演示剪切锁定的原理及其纠正措施。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the tip deflection of a Timoshenko beam using FEM\n    and compares it to the exact analytical solution to demonstrate shear locking.\n    \"\"\"\n\n    def solve_fem_timoshenko(L, b, h, E, nu, kappa, P, Nel, n_g):\n        \"\"\"\n        Computes the ratio R = w_FE / w_exact for a single test case.\n\n        Args:\n            L (float): Beam length\n            b (float): Cross-section breadth\n            h (float): Cross-section thickness\n            E (float): Young's modulus\n            nu (float): Poisson's ratio\n            kappa (float): Shear correction factor\n            P (float): Tip load\n            Nel (int): Number of elements\n            n_g (int): Number of Gauss points for shear term (1 or 2)\n\n        Returns:\n            float: The ratio R of FEM-calculated to exact tip deflection.\n        \"\"\"\n        # 1. Derived properties\n        G = E / (2 * (1 + nu))\n        A = b * h\n        I = b * h**3 / 12\n        le = L / Nel\n\n        # 2. Element stiffness matrices\n        # Bending stiffness matrix (integrated exactly)\n        K_b_e = (E * I / le) * np.array([\n            [0,  0,  0,  0],\n            [0,  1,  0, -1],\n            [0,  0,  0,  0],\n            [0, -1,  0,  1]\n        ])\n\n        # Shear stiffness matrix (numerical integration)\n        if n_g == 1:  # Reduced integration (1-point Gauss)\n            K_s_e = (kappa * G * A) * np.array([\n                [1/le,    1/2, -1/le,    1/2],\n                [ 1/2,   le/4,  -1/2,   le/4],\n                [-1/le,  -1/2,  1/le,   -1/2],\n                [ 1/2,   le/4,  -1/2,   le/4]\n            ])\n        elif n_g == 2:  # Full integration (2-point Gauss)\n            K_s_e = (kappa * G * A) * np.array([\n                [1/le,    1/2, -1/le,    1/2],\n                [ 1/2,   le/3,  -1/2,   le/6],\n                [-1/le,  -1/2,  1/le,   -1/2],\n                [ 1/2,   le/6,  -1/2,   le/3]\n            ])\n        else:\n            raise ValueError(\"Number of Gauss points n_g must be 1 or 2.\")\n        \n        K_e = K_b_e + K_s_e\n\n        # 3. Assembly of global stiffness matrix\n        num_nodes = Nel + 1\n        num_dof = 2 * num_nodes\n        K_global = np.zeros((num_dof, num_dof))\n\n        for i in range(Nel):\n            dof_indices = np.array([2*i, 2*i+1, 2*i+2, 2*i+3])\n            K_global[np.ix_(dof_indices, dof_indices)] += K_e\n\n        # 4. Global force vector\n        F_global = np.zeros(num_dof)\n        F_global[2 * Nel] = P  # Apply force P at w-dof of the last node\n\n        # 5. Apply Boundary Conditions (clamped at x=0, node 0)\n        # DOFs 0 (w_0) and 1 (theta_0) are fixed.\n        # We form the reduced system by removing rows/columns 0 and 1.\n        K_reduced = K_global[2:, 2:]\n        F_reduced = F_global[2:]\n\n        # 6. Solve the linear system\n        d_reduced = np.linalg.solve(K_reduced, F_reduced)\n        \n        # 7. Extract FEM tip deflection\n        # The tip deflection w(L) is at node Nel. Its global DOF is 2*Nel.\n        # In the reduced vector, its index is 2*Nel - 2.\n        w_FE = d_reduced[2 * Nel - 2]\n    \n        # 8. Calculate exact analytical solution\n        w_exact_bending = (P * L**3) / (3 * E * I)\n        w_exact_shear = (P * L) / (kappa * G * A)\n        w_exact = w_exact_bending + w_exact_shear\n\n        # 9. Compute and return the ratio R\n        R = w_FE / w_exact\n        return R\n\n    # Define the six test cases from the problem statement\n    test_cases = [\n        # (L,     b,      h,      E,        nu,  kappa,   P,    Nel, n_g)\n        (1.0, 1.0e-2, 1.0e-3, 2.10e11, 0.3, 5/6, 1.0e3, 1, 2),  # Case 1\n        (1.0, 1.0e-2, 1.0e-3, 2.10e11, 0.3, 5/6, 1.0e3, 1, 1),  # Case 2\n        (1.0, 1.0e-2, 1.0e-3, 2.10e11, 0.3, 5/6, 1.0e3, 8, 2),  # Case 3\n        (1.0, 1.0e-2, 1.0e-3, 2.10e11, 0.3, 5/6, 1.0e3, 8, 1),  # Case 4\n        (1.0, 1.0e-2, 1.0e-1, 2.10e11, 0.3, 5/6, 1.0e3, 2, 2),  # Case 5\n        (1.0, 1.0e-2, 1.0e-1, 2.10e11, 0.3, 5/6, 1.0e3, 2, 1)   # Case 6\n    ]\n\n    results = []\n    for case in test_cases:\n        R = solve_fem_timoshenko(*case)\n        # Format the result to 6 decimal places as required.\n        results.append(f\"{R:.6f}\")\n\n    # Print the final output in the exact specified format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在观察到剪切锁定现象之后，下一步是理解其在单元层面上的根源。本练习将使用“单元检验”（Patch Test）——有限元方法中一个基础的验证工具——来从解析上证明，标准双线性板单元在纯弯曲状态下会产生虚假的剪切应变，而这正是导致剪切锁定的根本原因。",
            "id": "3600168",
            "problem": "考虑 Mindlin–Reissner 板理论，其中横向剪切应变由以下关系定义：$$\\gamma_{xz}=\\frac{\\partial w}{\\partial x}+\\theta_x,\\qquad \\gamma_{yz}=\\frac{\\partial w}{\\partial y}+\\theta_y,$$ 其中 $w(x,y)$ 是中面的横向位移，$(\\theta_{x}(x,y),\\theta_{y}(x,y))$ 分别是法线绕 $y$ 轴和 $x$ 轴的转角。一个四节点双线性四边形等参 Mindlin 板单元占据矩形区域 $$\\Omega=\\{(x,y)\\in\\mathbb{R}^{2}\\,|\\,0\\le x\\le L,\\;0\\le y\\le H\\},$$ 其节点位于 $(0,0)$、$(L,0)$、$(L,H)$ 和 $(0,H)$。设自然坐标为 $(\\xi,\\eta)\\in[-1,1]\\times[-1,1]$，仿射映射为 $$x=\\frac{L}{2}(1+\\xi),\\qquad y=\\frac{H}{2}(1+\\eta),$$ 并设标准双线性形函数为 $$N_{1}(\\xi,\\eta)=\\frac{1}{4}(1-\\xi)(1-\\eta),\\quad N_{2}(\\xi,\\eta)=\\frac{1}{4}(1+\\xi)(1-\\eta),\\quad N_{3}(\\xi,\\eta)=\\frac{1}{4}(1+\\xi)(1+\\eta),\\quad N_{4}(\\xi,\\eta)=\\frac{1}{4}(1-\\xi)(1+\\eta)。$$ 有限元法 (FEM) 对 $w$、$\\theta_{x}$ 和 $\\theta_{y}$ 的插值取为 $$w_{h}(\\xi,\\eta)=\\sum_{i=1}^{4}N_{i}(\\xi,\\eta)\\,w_{i},\\qquad \\theta_{x,h}(\\xi,\\eta)=\\sum_{i=1}^{4}N_{i}(\\xi,\\eta)\\,\\theta_{x,i},\\qquad \\theta_{y,h}(\\xi,\\eta)=\\sum_{i=1}^{4}N_{i}(\\xi,\\eta)\\,\\theta_{y,i},$$ 其中，下标 $h$ 表示离散场，节点值 $(w_{i},\\theta_{x,i},\\theta_{y,i})$ 通过根据零剪切斑块检验 (zero-shear patch test) 的定义在节点处对精确场进行采样来规定：$$w(x,y)=\\alpha x^{2},\\qquad \\theta_{x}(x,y)=-\\frac{\\partial w}{\\partial x}=-2\\alpha x,\\qquad \\theta_{y}(x,y)=-\\frac{\\partial w}{\\partial y}=0.$$ 使用这些规定，计算单元的残余离散剪切能 $$U_{s}=\\frac{1}{2}\\,\\kappa\\,G\\,t\\int_{\\Omega}\\left(\\gamma_{xz,h}^{2}+\\gamma_{yz,h}^{2}\\right)\\,d\\Omega,$$ 其中 $\\kappa$ 是剪切修正系数，$G$ 是剪切模量，$t$ 是板的厚度。将您的最终答案以包含 $\\alpha$、$L$、$H$、$\\kappa$、$G$ 和 $t$ 的闭式解析表达式符号化地表示出来。最终能量以焦耳 (Joules) 为单位表示。不需要进行数值近似或舍入。",
            "solution": "### 目标\n计算一个四节点双线性四边形单元在纯弯曲变形场作用下的离散剪切能 $U_{s}$。\n\n### 步骤 1：确定节点值\n我们首先通过在单元的四个节点上对给定的精确场进行采样来确定节点值 $(w_i, \\theta_{x,i}, \\theta_{y,i})$。节点坐标为：\n-   节点 1：$(x_1, y_1) = (0, 0)$\n-   节点 2：$(x_2, y_2) = (L, 0)$\n-   节点 3：$(x_3, y_3) = (L, H)$\n-   节点 4：$(x_4, y_4) = (0, H)$\n\n精确场为 $w(x,y)=\\alpha x^{2}$，$\\theta_{x}(x,y)=-2\\alpha x$，以及 $\\theta_{y}(x,y)=0$。\n在节点处采样：\n-   $w_1 = w(0,0) = \\alpha(0)^2 = 0$\n-   $w_2 = w(L,0) = \\alpha L^2$\n-   $w_3 = w(L,H) = \\alpha L^2$\n-   $w_4 = w(0,H) = \\alpha(0)^2 = 0$\n\n-   $\\theta_{x,1} = \\theta_x(0,0) = -2\\alpha(0) = 0$\n-   $\\theta_{x,2} = \\theta_x(L,0) = -2\\alpha L$\n-   $\\theta_{x,3} = \\theta_x(L,H) = -2\\alpha L$\n-   $\\theta_{x,4} = \\theta_x(0,H) = -2\\alpha(0) = 0$\n\n-   $\\theta_{y,1} = \\theta_{y,2} = \\theta_{y,3} = \\theta_{y,4} = 0$\n\n### 步骤 2：构造插值场\n接下来，我们使用双线性形函数 $N_i(\\xi, \\eta)$ 构造插值场 $w_h$、$\\theta_{x,h}$ 和 $\\theta_{y,h}$：\n$$w_{h}(\\xi,\\eta)=\\sum_{i=1}^{4}N_{i}w_{i} = N_1(0) + N_2(\\alpha L^2) + N_3(\\alpha L^2) + N_4(0) = \\alpha L^2 (N_2 + N_3)$$\n$$\\theta_{x,h}(\\xi,\\eta)=\\sum_{i=1}^{4}N_{i}\\theta_{x,i} = N_1(0) + N_2(-2\\alpha L) + N_3(-2\\alpha L) + N_4(0) = -2\\alpha L (N_2 + N_3)$$\n$$\\theta_{y,h}(\\xi,\\eta)=\\sum_{i=1}^{4}N_{i}\\theta_{y,i} = 0$$\n\n简化形函数的和：\n$$N_2 + N_3 = \\frac{1}{4}(1+\\xi)(1-\\eta) + \\frac{1}{4}(1+\\xi)(1+\\eta) = \\frac{1}{4}(1+\\xi) [(1-\\eta) + (1+\\eta)] = \\frac{1}{4}(1+\\xi)(2) = \\frac{1}{2}(1+\\xi)$$\n将此代回插值场：\n$$w_h(\\xi, \\eta) = \\alpha L^2 \\left(\\frac{1}{2}(1+\\xi)\\right) = \\frac{\\alpha L^2}{2}(1+\\xi)$$\n$$\\theta_{x,h}(\\xi, \\eta) = -2\\alpha L \\left(\\frac{1}{2}(1+\\xi)\\right) = -\\alpha L(1+\\xi)$$\n\n### 步骤 3：计算离散剪切应变\n我们需要计算空间导数 $\\frac{\\partial w_h}{\\partial x}$ 和 $\\frac{\\partial w_h}{\\partial y}$。我们使用链式法则和坐标映射的雅可比矩阵。\n映射为 $x=\\frac{L}{2}(1+\\xi)$ 和 $y=\\frac{H}{2}(1+\\eta)$。其雅可比矩阵的逆为：\n$$\\mathbf{J}^{-1} = \\begin{pmatrix} \\frac{\\partial \\xi}{\\partial x} & \\frac{\\partial \\xi}{\\partial y} \\\\ \\frac{\\partial \\eta}{\\partial x} & \\frac{\\partial \\eta}{\\partial y} \\end{pmatrix} = \\begin{pmatrix} \\frac{2}{L} & 0 \\\\ 0 & \\frac{2}{H} \\end{pmatrix}$$\n应用链式法则：\n$$\\frac{\\partial w_h}{\\partial x} = \\frac{\\partial w_h}{\\partial \\xi} \\frac{\\partial \\xi}{\\partial x} = \\left(\\frac{\\alpha L^2}{2}\\right) \\left(\\frac{2}{L}\\right) = \\alpha L$$\n$$\\frac{\\partial w_h}{\\partial y} = \\frac{\\partial w_h}{\\partial \\eta} \\frac{\\partial \\eta}{\\partial y} = (0) \\left(\\frac{2}{H}\\right) = 0$$\n\n现在我们可以计算离散剪切应变：\n$$\\gamma_{xz,h} = \\frac{\\partial w_h}{\\partial x} + \\theta_{x,h} = \\alpha L + (-\\alpha L(1+\\xi)) = -\\alpha L \\xi$$\n$$\\gamma_{yz,h} = \\frac{\\partial w_h}{\\partial y} + \\theta_{y,h} = 0 + 0 = 0$$\n请注意，精确解对应于处处为零的剪切状态。然而，双线性单元产生了伪非零剪切应变 $\\gamma_{xz,h} = -\\alpha L \\xi$。这是剪切锁定的根本原因。\n\n### 步骤 4：计算剪切能\n最后，我们通过在单元面积上积分来计算剪切能 $U_s$。\n$$U_{s}=\\frac{1}{2}\\,\\kappa\\,G\\,t\\int_{\\Omega}\\left(\\gamma_{xz,h}^{2}+\\gamma_{yz,h}^{2}\\right)\\,d\\Omega$$\n在自然坐标系 $(\\xi, \\eta)$ 中进行积分，面积微元 $d\\Omega = dx\\,dy = \\det(\\mathbf{J})\\,d\\xi\\,d\\eta = \\frac{LH}{4}\\,d\\xi\\,d\\eta$。\n$$U_{s}=\\frac{1}{2}\\,\\kappa\\,G\\,t\\int_{-1}^{1}\\int_{-1}^{1}\\left((-\\alpha L\\xi)^{2}+0^{2}\\right)\\,\\frac{LH}{4}\\,d\\xi\\,d\\eta$$\n$$U_{s}=\\frac{1}{2}\\,\\kappa\\,G\\,t\\,\\frac{LH}{4}\\,\\alpha^2 L^2 \\int_{-1}^{1}\\int_{-1}^{1}\\xi^2\\,d\\xi\\,d\\eta$$\n该积分是可分离的：\n$$\\int_{-1}^{1}\\int_{-1}^{1}\\xi^2\\,d\\xi\\,d\\eta = \\left(\\int_{-1}^{1}\\xi^2\\,d\\xi\\right)\\left(\\int_{-1}^{1}d\\eta\\right)$$\n计算每个积分：\n$$\\int_{-1}^{1}\\xi^2\\,d\\xi = \\left[\\frac{\\xi^3}{3}\\right]_{-1}^{1} = \\frac{1^3}{3} - \\frac{(-1)^3}{3} = \\frac{2}{3}$$\n$$\\int_{-1}^{1}d\\eta = \\left[\\eta\\right]_{-1}^{1} = 1 - (-1) = 2$$\n双重积分的值为 $(\\frac{2}{3})(2) = \\frac{4}{3}$。\n\n将此代回 $U_s$ 的表达式：\n$$U_{s} = \\frac{1}{2}\\,\\kappa\\,G\\,t\\,\\frac{\\alpha^2 L^3 H}{4} \\left(\\frac{4}{3}\\right)$$\n$$U_{s} = \\frac{1}{6}\\kappa G t \\alpha^2 L^3 H$$\n\n这是存储在单元中的伪剪切能的最终符号表达式。在国际单位制（SI）中，能量的单位是焦耳，这与所提供变量的单位一致。",
            "answer": "$$\\boxed{\\frac{\\kappa G t \\alpha^{2} L^{3} H}{6}}$$"
        },
        {
            "introduction": "最后一个高级练习将概念应用到更复杂的二维板结构中。它要求您实现一个完整的板单元求解器，并使用一种精密的技术——面向目标的误差估计——来精确量化单元积分方案的选择（即锁定修正方法）对关键工程预测（如尖端挠度）精度的影响程度。",
            "id": "3600154",
            "problem": "考慮一個懸臂 Mindlin-Reissner 板，佔據矩形域 $\\Omega = [0,L] \\times [0,W]$，其厚度為 $t$，楊氏模量為 $E$，泊松比為 $\\nu$。左邊界 $x=0$ 處為固支，因此橫向位移 $w$ 以及轉角 $\\theta_x$ 和 $\\theta_y$ 在該處為零。一個均勻的橫向載荷 $q$（單位面積上的力）作用在板的表面。Mindlin-Reissner 板的控制運動學關係是彎曲曲率 $\\kappa_x = \\partial \\theta_x / \\partial x$、$\\kappa_y = \\partial \\theta_y / \\partial y$ 和 $\\kappa_{xy} = \\partial \\theta_x / \\partial y + \\partial \\theta_y / \\partial x$，以及橫向剪切應變 $\\gamma_x = \\theta_x + \\partial w / \\partial x$、$\\gamma_y = \\theta_y + \\partial w / \\partial y$。本構關係使用彎曲剛度矩陣 $D_b$ 和剪切剛度矩陣 $D_s$，其中 $D_b = \\dfrac{E t^3}{12(1-\\nu^2)}\\begin{bmatrix} 1 & \\nu & 0 \\\\ \\nu & 1 & 0 \\\\ 0 & 0 & \\dfrac{1-\\nu}{2}\\end{bmatrix}$ 且 $D_s = \\kappa_s G t \\, I_2$，其中 $G = \\dfrac{E}{2(1+\\nu)}$ 且 $\\kappa_s$ 是剪切修正因子。\n\n弱（變分）形式旨在求解在滿足 $x=0$ 處固支邊界條件的適當空間中的 $(w,\\theta_x,\\theta_y)$，使得對於所有容許的測試函數 $(\\hat{w},\\hat{\\theta}_x,\\hat{\\theta}_y)$，以下平衡式\n$$\n\\int_{\\Omega} \\begin{bmatrix}\\kappa_x & \\kappa_y & \\kappa_{xy}\\end{bmatrix} D_b \n\\begin{bmatrix}\\hat{\\kappa}_x \\\\ \\hat{\\kappa}_y \\\\ \\hat{\\kappa}_{xy}\\end{bmatrix} \\, \\mathrm{d}\\Omega\n\\;+\\;\n\\int_{\\Omega} \\begin{bmatrix}\\gamma_x & \\gamma_y\\end{bmatrix} D_s \n\\begin{bmatrix}\\hat{\\gamma}_x \\\\ \\hat{\\gamma}_y\\end{bmatrix} \\, \\mathrm{d}\\Omega\n\\;=\\;\n\\int_{\\Omega} q \\, \\hat{w} \\, \\mathrm{d}\\Omega\n$$\n成立。該公式使用雙線性四邊形元素（四節點，通常表示為 $Q_4$）進行離散化，每個節點具有節點自由度 $w$、$\\theta_x$ 和 $\\theta_y$。單元的彎曲貢獻使用由形函數對物理座標的導數構建的曲率-位移矩陣，而剪切貢獻使用由形函數及其導數耦合 $w$ 和轉角而構建的矩陣。\n\n眾所周知，對於薄板（即 $t$ 很小），使用雙線性元素對剪切能進行樸素的全積分會導致剪切鎖死，產生過於剛硬的響應，並在諸如尖端撓度等關心量上精度較差。一種常見的補救方法是選擇性減縮積分，其中彎曲項使用 $2\\times 2$ 高斯法則進行積分，而剪切項則在單元中心使用 $1\\times 1$ 高斯法則進行積分。在本問題中，這種選擇性減縮積分起到了剪切應變豐富化的作用。\n\n我們將目標泛函定義為自由角點的尖端撓度：\n$$\nJ(w,\\theta_x,\\theta_y) = w(L,W).\n$$\n對於粗網格上的給定離散近似，使用雙網格伴隨法構造一個面向目標的誤差估計器：細網格上的伴隨解以目標泛函為右端項的離散伴隨系統。設細網格上的離散算子為 $K_f$ 和 $f_f$，延拓到細網格的粗網格解為 $u_{c \\rightarrow f}$，細網格伴隨解為 $z_f$，求解 $K_f z_f = j_f$，其中 $j_f$ 代表 $J$，是一個在尖端位移自由度處為單位值、其餘位置為零的向量。一個校準的估計器為\n$$\n\\eta = c \\, z_f^\\top \\left(f_f - K_f u_{c \\rightarrow f}\\right),\n$$\n其中常數 $c$ 是在一個基線厚度上透過將此估計器與在細網格解和粗網格解之間觀察到的實際目標誤差進行匹配來校準的。此校準使得能夠預測其他厚度的目標誤差。\n\n您的任務是：\n- 針對 Mindlin-Reissner 板，在均勻矩形網格上使用雙線性四邊形元素，實作一個有限元求解器，該求解器具有兩種變體：\n  1. 標準全積分：彎曲項和剪切項均使用 $2\\times 2$ 高斯點。\n  2. 剪切豐富化的選擇性減縮積分：彎曲項使用 $2\\times 2$ 高斯積分，剪切項使用 $1\\times 1$ 高斯積分。\n- 求解粗網格和細網格的板問題。細網格使用剪切豐富化的變體，並提供一個代理參考解。\n- 使用細網格伴隨解構造雙網格面向目標的誤差估計器，並在基線厚度上校準其常數 $c$。\n- 評估與標準全積分相比，剪切豐富化是否能改善小 $t$ 情況下的目標精度。\n\n使用以下參數和單位：\n- 板長 $L = 1.0$ m，寬度 $W = 0.2$ m。\n- 材料常數 $E = 70\\times 10^9$ Pa，$\\nu = 0.3$，剪切修正因子 $\\kappa_s = 5/6$。\n- 均勻橫向載荷 $q = 10^4$ N/m$^2$。\n- 粗網格解析度：$N_x^{(c)} = 12$，$N_y^{(c)} = 4$ 個元素。\n- 細網格解析度：$N_x^{(f)} = 24$，$N_y^{(f)} = 8$ 個元素。\n- 用於校準的基線厚度：$t_{\\mathrm{cal}} = 0.05$ m。\n- 薄板測試厚度：$t_1 = 0.01$ m 和 $t_2 = 0.005$ m。\n\n將厚度為 $t$、粗網格解為 $u_c$ 的目標誤差定義為\n$$\ne_J(t) = J(u_f(t)) - J(u_c(t)),\n$$\n其中 $u_f(t)$ 是使用剪切豐富化變體計算的精細參考解。對於每個薄板測試厚度，計算標準全積分粗網格解和剪切豐富化粗網格解的實際目標誤差，並使用校準後的常數計算相應的估計器預測值。\n\n物理單位：所有量必須以國際單位制計算，目標撓度值必須以米表示，並四捨五入到六位小數。\n\n測試套組：\n- 案例 A（基線校準）：$t_{\\mathrm{cal}} = 0.05$ m。使用此案例計算 $c$。\n- 案例 B（薄板）：$t_1 = 0.01$ m。\n- 案例 C（更薄的板）：$t_2 = 0.005$ m。\n\n您的程式應產生單行輸出，其中包含一個以逗號分隔的結果列表，並用方括號括起來，順序如下：\n- 校準常數 $c$（浮點數）。\n- 對於 $t_1$：標準粗網格解的估計目標誤差（浮點數），剪切豐富化粗網格解的估計目標誤差（浮點數），標準粗網格解的實際目標誤差（浮點數），剪切豐富化粗網格解的實際目標誤差（浮點數），以及一個指示豐富化解是否比標準解具有更小絕對目標誤差的布林值。\n- 對於 $t_2$：與 $t_1$ 相同的五個值，順序相同。\n\n所有浮點數必須四捨五入到六位小數，布林值必須是 True 或 False。例如，輸出格式必須是\n$$\n[\\text{c},\\;\\text{est\\_std\\_t1},\\;\\text{est\\_enr\\_t1},\\;\\text{act\\_std\\_t1},\\;\\text{act\\_enr\\_t1},\\;\\text{improved\\_t1},\\;\\text{est\\_std\\_t2},\\;\\text{est\\_enr\\_t2},\\;\\text{act\\_std\\_t2},\\;\\text{act\\_enr\\_t2},\\;\\text{improved\\_t2}]\n$$\n並且必須以單行形式印出。",
            "solution": "該問題要求實作一個用於 Mindlin-Reissner 板的有限元方法（FEM）求解器，分析剪切鎖死現象，並應用一個面向目標的誤差估計器。\n\n### **方法論與解決步驟**\n\n解決方案需要為 Mindlin-Reissner 板開發一個完整的有限元分析框架，然後用它來執行一個面向目標的誤差估計研究。過程如下：\n\n1.  **有限元公式化**：將實作一個 `FEMPlateSolver` 類別來封裝整個有限元分析過程。\n    -   **網格**：一個函數生成 $Q_4$ 元素的結構化矩形網格，定義節點座標和元素連接性。\n    -   **元素矩陣**：對每個元素，透過數值積分（高斯積分）計算剛度矩陣 $k_e$ 和力向量 $f_e$。\n        -   元素剛度矩陣是彎曲部分（$k_{e,b}$）和剪切部分（$k_{e,s}$）的和。\n        -   $k_{e,b} = \\int_{A_e} B_b^T D_b B_b \\, \\mathrm{d}A$ 和 $k_{e,s} = \\int_{A_e} B_s^T D_s B_s \\, \\mathrm{d}A$，其中 $B_b$ 和 $B_s$ 分別是彎曲和剪切的應變-位移矩陣。\n        -   彎曲部分總是使用 $2 \\times 2$ 高斯法則積分。\n        -   剪切部分根據分析類型，使用 $2 \\times 2$ 法則（全積分，FI）或 $1 \\times 1$ 法則（選擇性減縮積分，SRI）进行积分。\n        -   元素力向量 $f_e = \\int_{A_e} N_w^T q \\, \\mathrm{d}A$ 使用 $2 \\times 2$ 高斯法則計算。\n    -   **組裝**：將元素矩陣和向量組裝成全域稀疏矩陣 $K$ 和全域向量 $F$。\n    -   **邊界條件**：透過識別在 $x=0$ 邊界上的自由度（DOF），並從線性系統中移除相應的行和列，來施加固支條件。\n    -   **求解器**：求解簡化後的系統 $K_{free} u_{free} = F_{free}$ 以獲得未知的節點位移 $u_{free}$。然後重建完整的解向量 $u$。\n\n2.  **面向目標的誤差估計**：\n    -   **參考解**：對於給定的厚度 $t$，在細網格（$24 \\times 8$）上使用 SRI 方案計算一個高保真度的參考解 $u_f(t)$。\n    -   **粗網格解**：對於相同的厚度，在粗網格（$12 \\times 4$）上計算兩個粗網格解：使用 FI 的 $u_c^{\\text{std}}(t)$ 和使用 SRI 的 $u_c^{\\text{enr}}(t)$。\n    -   **延拓**：透過雙線性插值將粗網格解轉移到細網格格點上，得到 $u_{c \\to f}^{\\text{std}}$ 和 $u_{c \\to f}^{\\text{enr}}$。\n    -   **伴隨問題**：在細網格上求解伴隨問題 $K_f z_f = j_f$。右端項 $j_f$ 是一個向量，其中對應於尖端 $(L,W)$ 橫向位移 $w$ 的自由度處為 1，其餘為零。注意 $K_f$ 以及因此 $z_f$ 都依賴於厚度 $t$。\n    -   **校準**：在基線厚度 $t_{\\mathrm{cal}}=0.05$ m 處確定校準常數 $c$。它的計算方式是使標準（FI）粗網格解的估計誤差与实际误差相匹配：\n        $$ c = \\frac{J(u_f(t_{\\mathrm{cal}})) - J(u_c^{\\text{std}}(t_{\\mathrm{cal}}))}{z_f(t_{\\mathrm{cal}})^\\top \\left( f_f - K_f(t_{\\mathrm{cal}}) u_{c \\to f}^{\\text{std}}(t_{\\mathrm{cal}}) \\right)} $$\n    -   **誤差預測**：對於測試厚度 $t_1$ 和 $t_2$，使用校準後的常數 $c$ 來預測標準和豐富化粗網格解的目標誤差。例如，厚度為 $t$ 的標準解的估計誤差為：\n        $$ \\eta^{\\text{std}}(t) = c \\cdot z_f(t)^\\top \\left( f_f - K_f(t) u_{c \\to f}^{\\text{std}}(t) \\right) $$\n\n3.  **分析與輸出**：對於每個測試厚度，將估計誤差與實際計算的誤差 $e_J(t) = J(u_f(t)) - J(u_c(t))$ 進行比較。比較 FI 和 SRI 粗網格解的絕對實際誤差，以確定豐富化（SRI）元素是否為尖端撓度提供了更準確的結果。收集最終結果並按規定格式輸出。",
            "answer": "```python\nimport numpy as np\nfrom scipy.sparse import coo_matrix, csc_matrix\nfrom scipy.sparse.linalg import spsolve\nfrom functools import lru_cache\n\ndef solve():\n    \"\"\"\n    Main function to perform the entire FEM analysis and error estimation.\n    \"\"\"\n    \n    # Problem Parameters\n    L, W = 1.0, 0.2\n    E, nu = 70e9, 0.3\n    ks = 5/6\n    q = 1e4\n    \n    Nx_c, Ny_c = 12, 4\n    Nx_f, Ny_f = 24, 8\n\n    t_cal = 0.05\n    t1 = 0.01\n    t2 = 0.005\n    \n    class FEMPlateSolver:\n        \"\"\"\n        A class to perform Finite Element Analysis for a Mindlin-Reissner plate.\n        \"\"\"\n        def __init__(self, L, W, Nx, Ny, t, E, nu, ks, q, integration_type):\n            self.L, self.W, self.Nx, self.Ny = L, W, Nx, Ny\n            self.t, self.E, self.nu, self.ks, self.q = t, E, nu, ks, q\n            self.integration_type = integration_type\n\n            # Material properties\n            self.G = self.E / (2 * (1 + self.nu))\n            Db_factor = self.E * self.t**3 / (12 * (1 - self.nu**2))\n            self.Db = Db_factor * np.array([[1, self.nu, 0], [self.nu, 1, 0], [0, 0, (1 - self.nu)/2]])\n            self.Ds = self.ks * self.G * self.t * np.eye(2)\n\n            self.nodes, self.elements = self._generate_mesh()\n            self.num_nodes = self.nodes.shape[0]\n            self.num_dofs = self.num_nodes * 3\n            \n            self.clamped_dofs = self._get_clamped_dofs()\n            all_dofs = np.arange(self.num_dofs)\n            self.free_dofs = np.setdiff1d(all_dofs, self.clamped_dofs, assume_unique=True)\n\n        def _generate_mesh(self):\n            nx, ny = self.Nx + 1, self.Ny + 1\n            x = np.linspace(0, self.L, nx)\n            y = np.linspace(0, self.W, ny)\n            nodes = np.array([[xi, yi] for yi in y for xi in x]) # Changed order for node numbering\n            \n            elements = []\n            for i in range(self.Nx):\n                for j in range(self.Ny):\n                    n1 = i * ny + j\n                    n2 = (i + 1) * ny + j\n                    n3 = (i + 1) * ny + (j + 1)\n                    n4 = i * ny + (j + 1)\n                    elements.append([n1, n2, n3, n4])\n            return nodes, np.array(elements)\n\n        @staticmethod\n        @lru_cache(maxsize=None)\n        def _get_gauss_points(n):\n            if n == 1:\n                return np.array([[0.0, 0.0]]), np.array([4.0])\n            if n == 2:\n                p = 1.0 / np.sqrt(3)\n                points = np.array([[-p, -p], [p, -p], [-p, p], [p, p]])\n                weights = np.array([1.0, 1.0, 1.0, 1.0])\n                return points, weights\n            raise ValueError(\"Only 1 and 2-point Gauss quadrature are supported.\")\n\n        @staticmethod\n        @lru_cache(maxsize=None)\n        def _get_shape_functions(xi, eta):\n            N = 0.25 * np.array([(1-xi)*(1-eta), (1+xi)*(1-eta), (1+xi)*(1+eta), (1-xi)*(1+eta)])\n            dNd_xi = 0.25 * np.array([-(1-eta), (1-eta), (1+eta), -(1+eta)])\n            dNd_eta = 0.25 * np.array([-(1-xi), -(1+xi), (1+xi), (1-xi)])\n            return N, np.vstack((dNd_xi, dNd_eta))\n\n        def _get_clamped_dofs(self):\n            clamped_nodes = np.where(np.isclose(self.nodes[:, 0], 0.0))[0]\n            dofs = []\n            for node_idx in clamped_nodes:\n                dofs.extend([3 * node_idx, 3 * node_idx + 1, 3 * node_idx + 2])\n            return np.array(dofs)\n\n        def solve_system(self):\n            rows, cols, data_K = [], [], []\n            F = np.zeros(self.num_dofs)\n\n            gp_bend, w_bend = self._get_gauss_points(2)\n            gp_shear, w_shear = self._get_gauss_points(1 if self.integration_type == 'SRI' else 2)\n\n            for el_nodes_idx in self.elements:\n                el_coords = self.nodes[el_nodes_idx]\n                dofs = np.array([[3*n, 3*n+1, 3*n+2] for n in el_nodes_idx]).flatten()\n                \n                ke_b = np.zeros((12, 12))\n                ke_s = np.zeros((12, 12))\n                fe = np.zeros(12)\n\n                # Bending stiffness\n                for gp, w in zip(gp_bend, w_bend):\n                    N, dNd_xieta = self._get_shape_functions(gp[0], gp[1])\n                    J = dNd_xieta @ el_coords\n                    detJ = np.linalg.det(J)\n                    dNd_xy = np.linalg.inv(J) @ dNd_xieta\n                    \n                    Bb = np.zeros((3, 12))\n                    for i in range(4):\n                        Bb[0, 3*i+1] = dNd_xy[0, i]\n                        Bb[1, 3*i+2] = dNd_xy[1, i]\n                        Bb[2, 3*i+1] = dNd_xy[1, i]\n                        Bb[2, 3*i+2] = dNd_xy[0, i]\n                    ke_b += Bb.T @ self.Db @ Bb * detJ * w\n                \n                # Shear stiffness\n                for gp, w in zip(gp_shear, w_shear):\n                    N, dNd_xieta = self._get_shape_functions(gp[0], gp[1])\n                    J = dNd_xieta @ el_coords\n                    detJ = np.linalg.det(J)\n                    dNd_xy = np.linalg.inv(J) @ dNd_xieta\n                    \n                    Bs = np.zeros((2, 12))\n                    for i in range(4):\n                        Bs[0, 3*i]   = dNd_xy[0, i]\n                        Bs[0, 3*i+1] = N[i]\n                        Bs[1, 3*i]   = dNd_xy[1, i]\n                        Bs[1, 3*i+2] = N[i]\n                    ke_s += Bs.T @ self.Ds @ Bs * detJ * w\n                \n                # Force vector\n                for gp, w in zip(gp_bend, w_bend):\n                    N, dNd_xieta = self._get_shape_functions(gp[0], gp[1])\n                    J = dNd_xieta @ el_coords\n                    detJ = np.linalg.det(J)\n                    for i in range(4):\n                        fe[3*i] += N[i] * self.q * detJ * w\n                \n                ke = ke_b + ke_s\n                row_indices, col_indices = np.meshgrid(dofs, dofs)\n                rows.extend(row_indices.flatten())\n                cols.extend(col_indices.flatten())\n                data_K.extend(ke.flatten())\n                F[dofs] += fe\n\n            K = csc_matrix((data_K, (rows, cols)), shape=(self.num_dofs, self.num_dofs))\n            K_free = K[self.free_dofs, :][:, self.free_dofs]\n            F_free = F[self.free_dofs]\n            \n            u_free = spsolve(K_free, F_free)\n            \n            u = np.zeros(self.num_dofs)\n            u[self.free_dofs] = u_free\n            \n            return K, F, u\n\n        def get_tip_w_dof_index(self):\n            # Node at (L, W)\n            tip_node_idx = (self.Nx) * (self.Ny+1) + self.Ny\n            return 3 * tip_node_idx\n            \n        def get_tip_deflection(self, u):\n            return u[self.get_tip_w_dof_index()]\n\n    def prolong_solution(u_c, solver_c, solver_f):\n        u_f_prolonged = np.zeros(solver_f.num_dofs)\n        \n        for i_f in range(solver_f.Nx + 1):\n            for j_f in range(solver_f.Ny + 1):\n                node_idx_f = i_f * (solver_f.Ny + 1) + j_f\n                xf, yf = solver_f.nodes[node_idx_f]\n\n                el_idx_c_x, el_idx_c_y = min(int(xf / (solver_c.L/solver_c.Nx)), solver_c.Nx-1), min(int(yf / (solver_c.W/solver_c.Ny)), solver_c.Ny-1)\n                el_idx_c = el_idx_c_x * solver_c.Ny + el_idx_c_y\n                \n                el_nodes_c_idx = solver_c.elements[el_idx_c]\n                el_coords_c = solver_c.nodes[el_nodes_c_idx]\n\n                x0, y0 = el_coords_c[0]\n                le_x = el_coords_c[1,0] - x0\n                le_y = el_coords_c[3,1] - y0\n                \n                xi = 2 * (xf - x0) / le_x - 1\n                eta = 2 * (yf - y0) / le_y - 1\n\n                N, _ = solver_c._get_shape_functions(xi, eta)\n                \n                for dof_i in range(3):\n                    val = 0.0\n                    for k in range(4):\n                        node_c_idx = el_nodes_c_idx[k]\n                        val += N[k] * u_c[3*node_c_idx + dof_i]\n                    u_f_prolonged[3*node_idx_f + dof_i] = val\n        return u_f_prolonged\n\n    # --- Calibration at t_cal ---\n    solver_c_std_cal = FEMPlateSolver(L, W, Nx_c, Ny_c, t_cal, E, nu, ks, q, 'FI')\n    K_c_std_cal, F_c_std_cal, u_c_std_cal = solver_c_std_cal.solve_system()\n    \n    solver_f_sri_cal = FEMPlateSolver(L, W, Nx_f, Ny_f, t_cal, E, nu, ks, q, 'SRI')\n    K_f_cal, F_f_cal, u_f_sri_cal = solver_f_sri_cal.solve_system()\n\n    # Adjoint solve\n    j_f = np.zeros(solver_f_sri_cal.num_dofs)\n    tip_dof_f = solver_f_sri_cal.get_tip_w_dof_index()\n    j_f[tip_dof_f] = 1.0\n\n    K_f_free = K_f_cal[solver_f_sri_cal.free_dofs, :][:, solver_f_sri_cal.free_dofs]\n    j_f_free = j_f[solver_f_sri_cal.free_dofs]\n    z_f_free = spsolve(K_f_free.T, j_f_free) # Using K.T for adjoint\n    z_f_cal = np.zeros(solver_f_sri_cal.num_dofs)\n    z_f_cal[solver_f_sri_cal.free_dofs] = z_f_free\n\n    # Prolong coarse solution and compute residual\n    u_c_to_f_std_cal = prolong_solution(u_c_std_cal, solver_c_std_cal, solver_f_sri_cal)\n    residual_std_cal = F_f_cal - K_f_cal @ u_c_to_f_std_cal\n    \n    eta_hat_std_cal = z_f_cal.T @ residual_std_cal\n    actual_err_std_cal = solver_f_sri_cal.get_tip_deflection(u_f_sri_cal) - solver_c_std_cal.get_tip_deflection(u_c_std_cal)\n    c = actual_err_std_cal / eta_hat_std_cal if eta_hat_std_cal != 0 else 1.0\n    results = [round(c, 6)]\n\n    # --- Analysis for t1 and t2 ---\n    for t_val in [t1, t2]:\n        solver_c_std = FEMPlateSolver(L, W, Nx_c, Ny_c, t_val, E, nu, ks, q, 'FI')\n        _, _, u_c_std = solver_c_std.solve_system()\n        solver_c_sri = FEMPlateSolver(L, W, Nx_c, Ny_c, t_val, E, nu, ks, q, 'SRI')\n        _, _, u_c_sri = solver_c_sri.solve_system()\n        \n        solver_f_sri = FEMPlateSolver(L, W, Nx_f, Ny_f, t_val, E, nu, ks, q, 'SRI')\n        K_f, F_f, u_f_sri = solver_f_sri.solve_system()\n\n        K_f_free = K_f[solver_f_sri.free_dofs, :][:, solver_f_sri.free_dofs]\n        z_f_free = spsolve(K_f_free.T, j_f_free) # Using K.T for adjoint\n        z_f = np.zeros(solver_f_sri.num_dofs)\n        z_f[solver_f_sri.free_dofs] = z_f_free\n\n        # Standard (FI)\n        u_c_to_f_std = prolong_solution(u_c_std, solver_c_std, solver_f_sri)\n        residual_std = F_f - K_f @ u_c_to_f_std\n        est_err_std = c * (z_f.T @ residual_std)\n        act_err_std = solver_f_sri.get_tip_deflection(u_f_sri) - solver_c_std.get_tip_deflection(u_c_std)\n\n        # Enriched (SRI)\n        u_c_to_f_sri = prolong_solution(u_c_sri, solver_c_sri, solver_f_sri)\n        residual_sri = F_f - K_f @ u_c_to_f_sri\n        est_err_sri = c * (z_f.T @ residual_sri)\n        act_err_sri = solver_f_sri.get_tip_deflection(u_f_sri) - solver_c_sri.get_tip_deflection(u_c_sri)\n\n        improved = abs(act_err_sri) < abs(act_err_std)\n        \n        results.extend([\n            round(est_err_std, 6), round(est_err_sri, 6),\n            round(act_err_std, 6), round(act_err_sri, 6),\n            improved\n        ])\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}