{
    "hands_on_practices": [
        {
            "introduction": "Our exploration of shear locking begins with the most fundamental case: the Timoshenko beam. This practice provides a clear and quantitative demonstration of the shear locking phenomenon by comparing a \"locked\" element model (using full numerical integration) with an \"unlocked\" one (using reduced integration) against a known exact solution . By analyzing how the accuracy of the tip deflection changes for both slender and thick beams, you will gain a foundational, hands-on understanding of why shear locking occurs and how simple changes in the numerical integration scheme can effectively remedy it.",
            "id": "3600155",
            "problem": "A cantilever beam of length $L$ with rectangular cross-section of breadth $b$ and thickness $h$ is modeled using the Timoshenko Beam Theory (TBT) and discretized by the Finite Element Method (FEM) with two-node linear elements for the transverse displacement $w(x)$ and the rotation $\\theta(x)$. The beam is clamped at $x=0$ and subjected to a concentrated transverse load $P$ at the free tip $x=L$. The material is linearly elastic, with Young’s modulus $E$, Poisson’s ratio $\\nu$, and shear modulus $G = \\dfrac{E}{2(1+\\nu)}$. A shear correction factor $\\kappa$ modifies the shear stiffness to account for non-uniform shear stress through the thickness. The goal is to construct quantitative benchmarks of tip deflection for slender and thick beams, and to expose shear locking by comparing full versus reduced integration of the shear energy.\n\nStart from first principles: kinematics of Timoshenko beams state that the shear strain is $\\gamma(x) = \\dfrac{dw}{dx} - \\theta(x)$ and the bending curvature is $\\dfrac{d\\theta}{dx}$. The constitutive relations are the bending moment $M(x) = E I \\dfrac{d\\theta}{dx}$ and shear force $V(x) = \\kappa G A \\gamma(x)$, where $I = \\dfrac{b h^3}{12}$ is the second moment of area and $A = b h$ is the cross-sectional area. The total potential energy of the beam under the tip load $P$ is\n$$\n\\Pi[w,\\theta] = \\int_{0}^{L} \\left( \\tfrac{1}{2} E I \\left(\\dfrac{d\\theta}{dx}\\right)^2 + \\tfrac{1}{2} \\kappa G A \\left(\\dfrac{dw}{dx} - \\theta\\right)^2 \\right) \\, dx \\;-\\; P\\, w(L).\n$$\nDiscretize $w$ and $\\theta$ with linear shape functions over each element, assemble the global stiffness matrix, apply clamped boundary conditions at $x=0$ ($w(0)=0$, $\\theta(0)=0$), and solve for the nodal degrees of freedom. Compute the tip deflection $w(L)$ of the finite element model for each test case. As a quantitative benchmark, compare the numerically obtained $w(L)$ to the exact analytical tip deflection from Timoshenko Beam Theory for a cantilever under a tip load,\n$$\nw_{\\mathrm{exact}} = \\frac{P L^3}{3 E I} + \\frac{P L}{\\kappa G A}.\n$$\nDefine the dimensionless ratio\n$$\nR = \\frac{w_{\\mathrm{FE}}}{w_{\\mathrm{exact}}},\n$$\nwhere $w_{\\mathrm{FE}}$ is the finite element tip deflection. Use this ratio to assess accuracy and identify shear locking, with $R<1$ indicating excessive stiffness due to locking.\n\nImplement two quadrature schemes for the shear term $\\int \\tfrac{1}{2} \\kappa G A \\left(\\dfrac{dw}{dx}-\\theta\\right)^2 dx$: \n- Full integration using $2$-point Gauss-Legendre quadrature on the reference element,\n- Reduced integration using $1$-point Gauss-Legendre quadrature on the reference element.\nThe bending term $\\int \\tfrac{1}{2} E I \\left(\\dfrac{d\\theta}{dx}\\right)^2 dx$ should be integrated exactly.\n\nUse the following scientifically realistic material and geometric parameters in International System of Units (SI): $E = 2.10 \\times 10^{11}\\,\\mathrm{Pa}$, $\\nu = 0.3$, $\\kappa = \\dfrac{5}{6}$, $b = 1.0 \\times 10^{-2}\\,\\mathrm{m}$, $L = 1.0\\,\\mathrm{m}$, and $P = 1.0 \\times 10^{3}\\,\\mathrm{N}$. Consider two thicknesses to span slender to thick beams: $h \\in \\{1.0 \\times 10^{-3}\\,\\mathrm{m},\\, 1.0 \\times 10^{-1}\\,\\mathrm{m}\\}$ with varying mesh resolutions and integration schemes.\n\nDesign the test suite as the following six cases, each specified by the tuple $(L,b,h,E,\\nu,\\kappa,P,N_{\\mathrm{el}},n_{\\mathrm{g}})$, where $N_{\\mathrm{el}}$ is the number of elements and $n_{\\mathrm{g}}$ is the number of Gauss points for the shear term:\n- Case $1$: $(1.0,\\, 1.0\\times 10^{-2},\\, 1.0\\times 10^{-3},\\, 2.10\\times 10^{11},\\, 0.3,\\, \\dfrac{5}{6},\\, 1.0\\times 10^{3},\\, 1,\\, 2)$.\n- Case $2$: $(1.0,\\, 1.0\\times 10^{-2},\\, 1.0\\times 10^{-3},\\, 2.10\\times 10^{11},\\, 0.3,\\, \\dfrac{5}{6},\\, 1.0\\times 10^{3},\\, 1,\\, 1)$.\n- Case $3$: $(1.0,\\, 1.0\\times 10^{-2},\\, 1.0\\times 10^{-3},\\, 2.10\\times 10^{11},\\, 0.3,\\, \\dfrac{5}{6},\\, 1.0\\times 10^{3},\\, 8,\\, 2)$.\n- Case $4$: $(1.0,\\, 1.0\\times 10^{-2},\\, 1.0\\times 10^{-3},\\, 2.10\\times 10^{11},\\, 0.3,\\, \\dfrac{5}{6},\\, 1.0\\times 10^{3},\\, 8,\\, 1)$.\n- Case $5$: $(1.0,\\, 1.0\\times 10^{-2},\\, 1.0\\times 10^{-1},\\, 2.10\\times 10^{11},\\, 0.3,\\, \\dfrac{5}{6},\\, 1.0\\times 10^{3},\\, 2,\\, 2)$.\n- Case $6$: $(1.0,\\, 1.0\\times 10^{-2},\\, 1.0\\times 10^{-1},\\, 2.10\\times 10^{11},\\, 0.3,\\, \\dfrac{5}{6},\\, 1.0\\times 10^{3},\\, 2,\\, 1)$.\n\nYour program must compute $R$ for each case. The final output must be a single line containing the six ratios as a comma-separated list enclosed in square brackets, with each ratio rounded to $6$ decimal places, e.g., $\\left[\\dots\\right]$. Since $R$ is dimensionless, no physical unit is required in the output. No external inputs or files are permitted; all parameters are to be embedded in the program.",
            "solution": "The problem requires the calculation of the tip deflection of a cantilever beam using the Finite Element Method (FEM) based on Timoshenko Beam Theory (TBT). The goal is to analyze the phenomenon of shear locking by comparing results from full and reduced numerical integration schemes for slender and thick beams. The numerical results will be compared against the exact analytical solution.\n\nThe starting point is the total potential energy of the beam, $\\Pi$, which is the sum of the strain energy and the potential of the external load.\n$$\n\\Pi[w,\\theta] = U_b + U_s - W_{ext} = \\int_{0}^{L} \\frac{1}{2} E I \\left(\\frac{d\\theta}{dx}\\right)^2 dx + \\int_{0}^{L} \\frac{1}{2} \\kappa G A \\left(\\frac{dw}{dx} - \\theta\\right)^2 dx - P w(L)\n$$\nHere, $U_b$ is the bending strain energy and $U_s$ is the shear strain energy. $w(x)$ is the transverse displacement, $\\theta(x)$ is the cross-section rotation, $E$ is Young's modulus, $I$ is the second moment of area, $\\kappa$ is the shear correction factor, $G$ is the shear modulus, $A$ is the cross-sectional area, $L$ is the beam length, and $P$ is the tip load.\n\nIn the Finite Element Method, the continuous functions $w(x)$ and $\\theta(x)$ are approximated over each element using shape functions and nodal values. For a two-node linear element of length $l_e$, the approximations are:\n$$\nw(\\xi) = N_1(\\xi) w_1 + N_2(\\xi) w_2 \\quad \\text{and} \\quad \\theta(\\xi) = N_1(\\xi) \\theta_1 + N_2(\\xi) \\theta_2\n$$\nwhere $\\xi \\in [-1, 1]$ is the natural coordinate on the element, $w_i$ and $\\theta_i$ are the nodal degrees of freedom (DOFs), and $N_1(\\xi) = \\frac{1}{2}(1-\\xi)$, $N_2(\\xi) = \\frac{1}{2}(1+\\xi)$ are the linear shape functions. The element's nodal displacement vector is $\\mathbf{d}_e = [w_1, \\theta_1, w_2, \\theta_2]^T$.\n\nThe bending curvature and shear strain are expressed in terms of nodal DOFs. The curvature $\\frac{d\\theta}{dx}$ is constant within a linear element:\n$$\n\\frac{d\\theta}{dx} = \\frac{d\\theta}{d\\xi}\\frac{d\\xi}{dx} = \\frac{1}{l_e}(-\\theta_1 + \\theta_2) = \\mathbf{B}_b \\mathbf{d}_e, \\quad \\text{where } \\mathbf{B}_b = \\frac{1}{l_e}[0, -1, 0, 1]\n$$\nThe shear strain $\\gamma(x) = \\frac{dw}{dx} - \\theta(x)$ is:\n$$\n\\gamma(\\xi) = \\frac{1}{l_e}(-w_1 + w_2) - (N_1(\\xi)\\theta_1 + N_2(\\xi)\\theta_2) = \\mathbf{B}_s(\\xi) \\mathbf{d}_e\n$$\nwhere $\\mathbf{B}_s(\\xi) = [-\\frac{1}{l_e}, -N_1(\\xi), \\frac{1}{l_e}, -N_2(\\xi)]$.\n\nThe element stiffness matrix $\\mathbf{K}_e$ is derived from minimizing the potential energy, leading to $\\mathbf{K}_e = \\mathbf{K}_{b,e} + \\mathbf{K}_{s,e}$. The bending stiffness matrix $\\mathbf{K}_{b,e}$ is:\n$$\n\\mathbf{K}_{b,e} = \\int_0^{l_e} E I (\\mathbf{B}_b)^T \\mathbf{B}_b dx = E I l_e (\\mathbf{B}_b)^T \\mathbf{B}_b = \\frac{E I}{l_e} \\begin{bmatrix} 0 & 0 & 0 & 0 \\\\ 0 & 1 & 0 & -1 \\\\ 0 & 0 & 0 & 0 \\\\ 0 & -1 & 0 & 1 \\end{bmatrix}\n$$\nSince the integrand is constant, this represents an exact integration.\n\nThe shear stiffness matrix $\\mathbf{K}_{s,e}$ is computed by numerically integrating over the element length:\n$$\n\\mathbf{K}_{s,e} = \\int_0^{l_e} \\kappa G A (\\mathbf{B}_s)^T \\mathbf{B}_s dx = \\int_{-1}^{1} \\kappa G A (\\mathbf{B}_s(\\xi))^T \\mathbf{B}_s(\\xi) \\frac{l_e}{2} d\\xi\n$$\n\nFor reduced integration ($n_g=1$), we use one Gauss point at $\\xi=0$ with weight $w_1=2$. At $\\xi=0$, $N_1(0)=N_2(0)=1/2$, and $\\mathbf{B}_s(0) = [-\\frac{1}{l_e}, -\\frac{1}{2}, \\frac{1}{l_e}, -\\frac{1}{2}]$. The integral becomes:\n$$\n\\mathbf{K}_{s,e}^{(\\text{1-pt})} = \\kappa G A \\frac{l_e}{2} \\left( w_1 (\\mathbf{B}_s(0))^T \\mathbf{B}_s(0) \\right) = \\kappa G A l_e (\\mathbf{B}_s(0))^T \\mathbf{B}_s(0)\n$$\n$$\n\\mathbf{K}_{s,e}^{(\\text{1-pt})} = \\kappa G A \\begin{bmatrix} 1/l_e & 1/2 & -1/l_e & 1/2 \\\\ 1/2 & l_e/4 & -1/2 & l_e/4 \\\\ -1/l_e & -1/2 & 1/l_e & -1/2 \\\\ 1/2 & l_e/4 & -1/2 & l_e/4 \\end{bmatrix}\n$$\n\nFor full integration ($n_g=2$), we use two Gauss points at $\\xi_{1,2} = \\mp 1/\\sqrt{3}$ with weights $w_{1,2}=1$. This is equivalent to exact integration of the polynomial terms in $(\\mathbf{B}_s)^T \\mathbf{B}_s$, which are at most quadratic in $\\xi$. The resulting matrix is:\n$$\n\\mathbf{K}_{s,e}^{(\\text{2-pt})} = \\kappa G A \\begin{bmatrix} 1/l_e & 1/2 & -1/l_e & 1/2 \\\\ 1/2 & l_e/3 & -1/2 & l_e/6 \\\\ -1/l_e & -1/2 & 1/l_e & -1/2 \\\\ 1/2 & l_e/6 & -1/2 & l_e/3 \\end{bmatrix}\n$$\nThe total element stiffness matrix is $\\mathbf{K}_e = \\mathbf{K}_{b,e} + \\mathbf{K}_{s,e}$, using the appropriate shear matrix.\n\nThe global stiffness matrix $\\mathbf{K}$ and force vector $\\mathbf{F}$ for a mesh of $N_{\\mathrm{el}}$ elements are assembled. The system has $2(N_{\\mathrm{el}}+1)$ DOFs. The load vector $\\mathbf{F}$ is zero everywhere except for the entry corresponding to the transverse displacement at the tip node ($x=L$), which is equal to $P$. Clamped boundary conditions at the root ($x=0$), $w(0)=0$ and $\\theta(0)=0$, are enforced by removing the first two rows and columns of $\\mathbf{K}$ and the first two entries of $\\mathbf{F}$. The resulting reduced system $\\mathbf{K}_{\\text{reduced}} \\mathbf{d}_{\\text{reduced}} = \\mathbf{F}_{\\text{reduced}}$ is solved for the unknown nodal DOFs $\\mathbf{d}_{\\text{reduced}}$.\n\nFrom the solution vector, the tip deflection $w_{\\mathrm{FE}} = w(L)$ is extracted. This is compared to the exact analytical solution from TBT:\n$$\nw_{\\mathrm{exact}} = \\frac{P L^3}{3 E I} + \\frac{P L}{\\kappa G A}\n$$\nThe dimensionless ratio $R = w_{\\mathrm{FE}}/w_{\\mathrm{exact}}$ is computed for each test case. For slender beams, the shear strain $\\gamma = dw/dx - \\theta$ must approach zero. Full integration with linear elements enforces this condition too strongly, causing the element to become overly stiff, a phenomenon known as shear locking, which manifests as $R \\ll 1$. Reduced integration of the shear term relaxes this constraint, mitigating locking and yielding more accurate results for slender beams.\n\nThe computational procedure for each test case is:\n1.  Define the geometric and material parameters.\n2.  Calculate the element length $l_e = L/N_{\\mathrm{el}}$.\n3.  Compute the element bending stiffness matrix $\\mathbf{K}_{b,e}$.\n4.  Compute the element shear stiffness matrix $\\mathbf{K}_{s,e}$ based on the specified number of Gauss points $n_{\\mathrm{g}}$.\n5.  Form the total element stiffness matrix $\\mathbf{K}_e$.\n6.  Assemble the global stiffness matrix $\\mathbf{K}$ for the $N_{\\mathrm{el}}$-element mesh.\n7.  Define the global force vector $\\mathbf{F}$ with load $P$ at the tip.\n8.  Apply boundary conditions to obtain the reduced system.\n9.  Solve the linear system for the unknown displacements.\n10. Extract the numerical tip deflection $w_{\\mathrm{FE}}$.\n11. Compute the exact tip deflection $w_{\\mathrm{exact}}$.\n12. Calculate and store the ratio $R = w_{\\mathrm{FE}} / w_{\\mathrm{exact}}$.\n\nThis process is repeated for all six specified test cases, covering slender and thick beams with different mesh resolutions and integration schemes to demonstrate the principles of shear locking and its remedy.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the tip deflection of a Timoshenko beam using FEM\n    and compares it to the exact analytical solution to demonstrate shear locking.\n    \"\"\"\n\n    def solve_fem_timoshenko(L, b, h, E, nu, kappa, P, Nel, n_g):\n        \"\"\"\n        Computes the ratio R = w_FE / w_exact for a single test case.\n\n        Args:\n            L (float): Beam length\n            b (float): Cross-section breadth\n            h (float): Cross-section thickness\n            E (float): Young's modulus\n            nu (float): Poisson's ratio\n            kappa (float): Shear correction factor\n            P (float): Tip load\n            Nel (int): Number of elements\n            n_g (int): Number of Gauss points for shear term (1 or 2)\n\n        Returns:\n            float: The ratio R of FEM-calculated to exact tip deflection.\n        \"\"\"\n        # 1. Derived properties\n        G = E / (2 * (1 + nu))\n        A = b * h\n        I = b * h**3 / 12\n        le = L / Nel\n\n        # 2. Element stiffness matrices\n        # Bending stiffness matrix (integrated exactly)\n        K_b_e = (E * I / le) * np.array([\n            [0,  0,  0,  0],\n            [0,  1,  0, -1],\n            [0,  0,  0,  0],\n            [0, -1,  0,  1]\n        ])\n\n        # Shear stiffness matrix (numerical integration)\n        if n_g == 1:  # Reduced integration (1-point Gauss)\n            K_s_e = (kappa * G * A) * np.array([\n                [1/le,    1/2, -1/le,    1/2],\n                [ 1/2,   le/4,  -1/2,   le/4],\n                [-1/le,  -1/2,  1/le,   -1/2],\n                [ 1/2,   le/4,  -1/2,   le/4]\n            ])\n        elif n_g == 2:  # Full integration (2-point Gauss)\n            K_s_e = (kappa * G * A) * np.array([\n                [1/le,    1/2, -1/le,    1/2],\n                [ 1/2,   le/3,  -1/2,   le/6],\n                [-1/le,  -1/2,  1/le,   -1/2],\n                [ 1/2,   le/6,  -1/2,   le/3]\n            ])\n        else:\n            raise ValueError(\"Number of Gauss points n_g must be 1 or 2.\")\n        \n        K_e = K_b_e + K_s_e\n\n        # 3. Assembly of global stiffness matrix\n        num_nodes = Nel + 1\n        num_dof = 2 * num_nodes\n        K_global = np.zeros((num_dof, num_dof))\n\n        for i in range(Nel):\n            dof_indices = np.array([2*i, 2*i+1, 2*i+2, 2*i+3])\n            K_global[np.ix_(dof_indices, dof_indices)] += K_e\n\n        # 4. Global force vector\n        F_global = np.zeros(num_dof)\n        F_global[2 * Nel] = P  # Apply force P at w-dof of the last node\n\n        # 5. Apply Boundary Conditions (clamped at x=0, node 0)\n        # DOFs 0 (w_0) and 1 (theta_0) are fixed.\n        # We form the reduced system by removing rows/columns 0 and 1.\n        K_reduced = K_global[2:, 2:]\n        F_reduced = F_global[2:]\n\n        # 6. Solve the linear system\n        d_reduced = np.linalg.solve(K_reduced, F_reduced)\n        \n        # 7. Extract FEM tip deflection\n        # The tip deflection w(L) is at node Nel. Its global DOF is 2*Nel.\n        # In the reduced vector, its index is 2*Nel - 2.\n        w_FE = d_reduced[2 * Nel - 2]\n    \n        # 8. Calculate exact analytical solution\n        w_exact_bending = (P * L**3) / (3 * E * I)\n        w_exact_shear = (P * L) / (kappa * G * A)\n        w_exact = w_exact_bending + w_exact_shear\n\n        # 9. Compute and return the ratio R\n        R = w_FE / w_exact\n        return R\n\n    # Define the six test cases from the problem statement\n    test_cases = [\n        # (L,     b,      h,      E,        nu,  kappa,   P,    Nel, n_g)\n        (1.0, 1.0e-2, 1.0e-3, 2.10e11, 0.3, 5/6, 1.0e3, 1, 2),  # Case 1\n        (1.0, 1.0e-2, 1.0e-3, 2.10e11, 0.3, 5/6, 1.0e3, 1, 1),  # Case 2\n        (1.0, 1.0e-2, 1.0e-3, 2.10e11, 0.3, 5/6, 1.0e3, 8, 2),  # Case 3\n        (1.0, 1.0e-2, 1.0e-3, 2.10e11, 0.3, 5/6, 1.0e3, 8, 1),  # Case 4\n        (1.0, 1.0e-2, 1.0e-1, 2.10e11, 0.3, 5/6, 1.0e3, 2, 2),  # Case 5\n        (1.0, 1.0e-2, 1.0e-1, 2.10e11, 0.3, 5/6, 1.0e3, 2, 1)   # Case 6\n    ]\n\n    results = []\n    for case in test_cases:\n        R = solve_fem_timoshenko(*case)\n        # Format the result to 6 decimal places as required.\n        results.append(f\"{R:.6f}\")\n\n    # Print the final output in the exact specified format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Building on the principles from the beam exercise, we now advance to the more complex two-dimensional case of a Mindlin-Reissner plate. Instead of merely observing locking, this practice introduces a powerful technique to quantify its impact on a specific engineering goal—the tip deflection of a cantilever plate . You will implement a goal-oriented error estimator using the adjoint method, a sophisticated approach that allows you to predict the error in your computed result without knowing the exact solution. This exercise provides critical skills for practical engineering analysis, where assessing the accuracy of simulations is paramount.",
            "id": "3600154",
            "problem": "Consider a cantilever Mindlin-Reissner plate occupying the rectangular domain $\\Omega = [0,L] \\times [0,W]$ with thickness $t$, Young's modulus $E$, and Poisson's ratio $\\nu$. The left edge at $x=0$ is clamped, so the transverse displacement $w$ and the rotations $\\theta_x$ and $\\theta_y$ are zero there. A uniform transverse load $q$ (force per unit area) acts over the surface of the plate. The governing kinematic relations of the Mindlin-Reissner plate are the bending curvatures $\\kappa_x = \\partial \\theta_x / \\partial x$, $\\kappa_y = \\partial \\theta_y / \\partial y$, and $\\kappa_{xy} = \\partial \\theta_x / \\partial y + \\partial \\theta_y / \\partial x$, and the transverse shear strains $\\gamma_x = \\theta_x + \\partial w / \\partial x$, $\\gamma_y = \\theta_y + \\partial w / \\partial y$. The constitutive relations use the bending stiffness matrix $D_b$ and the shear stiffness matrix $D_s$, with $D_b = \\dfrac{E t^3}{12(1-\\nu^2)}\\begin{bmatrix} 1 & \\nu & 0 \\\\ \\nu & 1 & 0 \\\\ 0 & 0 & \\dfrac{1-\\nu}{2}\\end{bmatrix}$ and $D_s = \\kappa_s G t \\, I_2$ where $G = \\dfrac{E}{2(1+\\nu)}$ and $\\kappa_s$ is the shear correction factor.\n\nThe weak (variational) formulation seeks $(w,\\theta_x,\\theta_y)$ in an appropriate space satisfying the clamped boundary conditions at $x=0$, such that for all admissible test functions $(\\hat{w},\\hat{\\theta}_x,\\hat{\\theta}_y)$ the balance\n$$\n\\int_{\\Omega} \\begin{bmatrix}\\kappa_x & \\kappa_y & \\kappa_{xy}\\end{bmatrix} D_b \n\\begin{bmatrix}\\hat{\\kappa}_x \\\\ \\hat{\\kappa}_y \\\\ \\hat{\\kappa}_{xy}\\end{bmatrix} \\, \\mathrm{d}\\Omega\n\\;+\\;\n\\int_{\\Omega} \\begin{bmatrix}\\gamma_x & \\gamma_y\\end{bmatrix} D_s \n\\begin{bmatrix}\\hat{\\gamma}_x \\\\ \\hat{\\gamma}_y\\end{bmatrix} \\, \\mathrm{d}\\Omega\n\\;=\\;\n\\int_{\\Omega} q \\, \\hat{w} \\, \\mathrm{d}\\Omega\n$$\nholds. This formulation is discretized using bilinear quadrilateral elements (four-node, often denoted $Q_4$) with nodal degrees of freedom $w$, $\\theta_x$, and $\\theta_y$ at each node. The element bending contribution uses the curvature-displacement matrix constructed from derivatives of shape functions with respect to physical coordinates, and the shear contribution uses the matrix constructed from shape functions and their derivatives coupling $w$ and rotations.\n\nIt is well known that for thin plates, i.e., small $t$, naive full integration of the shear energy with bilinear elements leads to shear locking, producing overly stiff responses and poor accuracy in quantities of interest such as tip deflection. A common remedy is selective reduced integration, where bending terms are integrated with a $2\\times 2$ Gauss rule, but the shear terms are integrated with a $1\\times 1$ Gauss rule at the element center. In this problem, this selective reduced integration acts as a shear strain enrichment.\n\nWe define the goal functional as the tip deflection at the free corner:\n$$\nJ(w,\\theta_x,\\theta_y) = w(L,W).\n$$\nFor a given discrete approximation on a coarse mesh, a goal-oriented error estimator is constructed using a two-grid adjoint approach: the adjoint on a fine mesh solves the discrete adjoint system with the goal functional as the right-hand side. Let the discrete operators on the fine mesh be $K_f$ and $f_f$, the coarse solution prolonged to the fine mesh be $u_{c \\rightarrow f}$, and the fine adjoint be $z_f$ solving $K_f z_f = j_f$ where $j_f$ represents $J$ as a vector with a unit entry at the tip displacement degree of freedom and zeros elsewhere. A calibrated estimator is\n$$\n\\eta = c \\, z_f^\\top \\left(f_f - K_f u_{c \\rightarrow f}\\right),\n$$\nwhere the constant $c$ is calibrated on a baseline thickness by matching this estimator to the actual goal error observed between the fine solution and the coarse solution. This calibration enables prediction of goal errors for other thicknesses.\n\nYour tasks are:\n- Implement a finite element solver for the Mindlin-Reissner plate on uniform rectangular meshes using bilinear quadrilateral elements with two variants:\n  1. Standard full integration: $2\\times 2$ Gauss points for both bending and shear terms.\n  2. Shear-enriched selective reduced integration: $2\\times 2$ Gauss for bending and $1\\times 1$ Gauss for shear.\n- Solve the plate problem for a coarse mesh and a fine mesh. The fine mesh uses the shear-enriched variant and provides a surrogate reference solution.\n- Construct the two-grid goal-oriented error estimator using the fine adjoint and calibrate its constant $c$ on the baseline thickness.\n- Evaluate whether shear enrichment improves the goal accuracy for small $t$ compared to the standard full integration.\n\nUse the following parameters and units:\n- Plate length $L = 1.0$ m, width $W = 0.2$ m.\n- Material constants $E = 70\\times 10^9$ Pa, $\\nu = 0.3$, shear correction factor $\\kappa_s = 5/6$.\n- Uniform transverse load $q = 10^4$ N/m$^2$.\n- Coarse mesh resolution: $N_x^{(c)} = 12$, $N_y^{(c)} = 4$ elements.\n- Fine mesh resolution: $N_x^{(f)} = 24$, $N_y^{(f)} = 8$ elements.\n- Baseline thickness for calibration: $t_{\\mathrm{cal}} = 0.05$ m.\n- Thin-plate test thicknesses: $t_1 = 0.01$ m and $t_2 = 0.005$ m.\n\nDefine the goal error for a thickness $t$ and a coarse solution $u_c$ as\n$$\ne_J(t) = J(u_f(t)) - J(u_c(t)),\n$$\nwhere $u_f(t)$ is the fine reference solution computed with the shear-enriched variant. For each of the thin-plate test thicknesses, compute the actual goal error for the standard full integration coarse solution and for the shear-enriched coarse solution, and compute the corresponding estimator predictions using the calibrated constant.\n\nPhysical units: All quantities must be computed in International System of Units, and goal deflection values must be expressed in meters, rounded to six decimal places.\n\nTest suite:\n- Case A (baseline calibration): $t_{\\mathrm{cal}} = 0.05$ m. Use this case to compute $c$.\n- Case B (thin plate): $t_1 = 0.01$ m.\n- Case C (thinner plate): $t_2 = 0.005$ m.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the following order:\n- The calibrated constant $c$ (float).\n- For $t_1$: the estimated goal error for the standard coarse solution (float), the estimated goal error for the shear-enriched coarse solution (float), the actual goal error for the standard coarse solution (float), the actual goal error for the shear-enriched coarse solution (float), and a boolean indicating whether the enriched solution has smaller absolute goal error than the standard solution.\n- For $t_2$: the same five values as for $t_1$, in the same order.\n\nAll floats must be rounded to six decimal places, and the booleans must be either True or False. For example, the output format must be\n$$\n[\\text{c},\\;\\text{est\\_std\\_t1},\\;\\text{est\\_enr\\_t1},\\;\\text{act\\_std\\_t1},\\;\\text{act\\_enr\\_t1},\\;\\text{improved\\_t1},\\;\\text{est\\_std\\_t2},\\;\\text{est\\_enr\\_t2},\\;\\text{act\\_std\\_t2},\\;\\text{act\\_enr\\_t2},\\;\\text{improved\\_t2}]\n$$\nand must be printed as a single line.",
            "solution": "The user has provided a comprehensive problem in computational solid mechanics, requiring the implementation of a finite element method (FEM) solver for a Mindlin-Reissner plate, an analysis of shear locking, and the application of a goal-oriented error estimator.\n\n### **Problem Validation**\n\n**Step 1: Extract Givens**\n\n- **Domain**: Rectangular, $\\Omega = [0,L] \\times [0,W]$ with $L = 1.0$ m, $W = 0.2$ m.\n- **Material**: Young's modulus $E = 70 \\times 10^9$ Pa, Poisson's ratio $\\nu = 0.3$.\n- **Plate Model**: Mindlin-Reissner theory with shear correction factor $\\kappa_s = 5/6$. Thickness is a variable $t$.\n- **Boundary Conditions**: Clamped at $x=0$ ($w=0, \\theta_x=0, \\theta_y=0$).\n- **Load**: Uniform transverse load $q = 10^4$ N/m$^2$.\n- **Kinematics & Constitutive Laws**: Standard Mindlin-Reissner relations are provided for bending curvatures $(\\kappa_x, \\kappa_y, \\kappa_{xy})$ and transverse shear strains $(\\gamma_x, \\gamma_y)$, along with the corresponding bending ($D_b$) and shear ($D_s$) stiffness matrices.\n- **Discretization**: Bilinear quadrilateral elements ($Q_4$) with nodal DOFs $(w, \\theta_x, \\theta_y)$.\n- **Integration Schemes**:\n    1.  Full Integration (FI): $2 \\times 2$ Gauss quadrature for both bending and shear terms.\n    2.  Selective Reduced Integration (SRI): $2 \\times 2$ for bending, $1 \\times 1$ for shear.\n- **Mesh Resolutions**:\n    - Coarse: $N_x^{(c)} = 12$, $N_y^{(c)} = 4$.\n    - Fine: $N_x^{(f)} = 24$, $N_y^{(f)} = 8$. The fine mesh with SRI serves as the reference solution.\n- **Goal Functional**: Tip deflection, $J = w(L,W)$.\n- **Error Estimator**: Two-grid adjoint-based, $\\eta = c \\, z_f^\\top (f_f - K_f u_{c \\rightarrow f})$, with $K_f z_f = j_f$.\n- **Calibration**: The constant $c$ is to be calibrated using the case with thickness $t_{\\mathrm{cal}} = 0.05$ m.\n- **Test Cases**: Thicknesses $t_1 = 0.01$ m and $t_2 = 0.005$ m.\n- **Error Definition**: $e_J(t) = J(u_f(t)) - J(u_c(t))$.\n- **Required Output**: A single-line comma-separated list of 11 specific values (the calibration constant $c$, and for each test thickness, the estimated and actual errors for FI and SRI solutions, plus a boolean for accuracy improvement).\n\n**Step 2: Validate Using Extracted Givens**\n\nThe problem is assessed against the validation criteria:\n- **Scientifically Grounded**: The problem is firmly rooted in established principles of solid mechanics (Mindlin-Reissner plate theory) and computational mechanics (Finite Element Method, shear locking, selective reduced integration, goal-oriented error estimation). All provided formulas and parameters are standard and physically sound. The premise is factually correct.\n- **Well-Posed**: The problem describes a standard boundary value problem for a system of elliptic partial differential equations. The specified clamped boundary conditions and distributed load ensure a unique and stable solution for the continuous problem. The discrete FEM formulation leads to a symmetric positive-definite stiffness matrix (after application of boundary conditions), guaranteeing a unique solution to the resulting linear system $K u = F$.\n- **Objective**: All aspects of the problem are defined with precise, quantitative, and unambiguous language. The required tasks are computational and deterministic, free from any subjectivity.\n\nThe problem exhibits none of the invalidity flags:\n1.  **Scientific Unsoundness**: No violations of physics or mathematics.\n2.  **Non-Formalizable**: The problem is a classic, formalizable task in computational engineering.\n3.  **Incomplete/Contradictory Setup**: The problem is highly detailed and self-contained. A minor ambiguity exists regarding which coarse solution (FI or SRI) to use for calibrating the constant $c$. A reasonable and standard choice is to calibrate based on the error of the \"naive\" Full Integration (FI) solution, as this is the baseline method being evaluated. This interpretation does not invalidate the problem.\n4.  **Unrealistic/Infeasible**: The parameters and required computations are realistic and computationally feasible.\n5.  **Ill-Posed**: The problem is well-structured and leads to a unique set of numerical results.\n6.  **Trivial/Tautological**: The problem is complex, requiring a full FEM implementation and an understanding of advanced topics in error estimation. It is not trivial.\n7.  **Unverifiable**: The results are numerically deterministic and can be independently verified.\n\n**Step 3: Verdict and Action**\n\nThe problem is **valid**. A complete solution will be provided, following the plan outlined below.\n\n### **Methodology and Solution Steps**\n\nThe solution requires developing a complete finite element analysis framework for a Mindlin-Reissner plate and then using it to perform a goal-oriented error estimation study. The process is as follows:\n\n1.  **Finite Element Formulation**: A class `FEMPlateSolver` will be implemented to encapsulate the entire FEM process.\n    -   **Mesh**: A function generates a structured rectangular mesh of $Q_4$ elements, defining node coordinates and element connectivity.\n    -   **Element Matrices**: For each element, the stiffness matrix $k_e$ and force vector $f_e$ are computed via numerical integration (Gauss quadrature).\n        -   The element stiffness matrix is the sum of a bending part ($k_{e,b}$) and a shear part ($k_{e,s}$).\n        -   $k_{e,b} = \\int_{A_e} B_b^T D_b B_b \\, \\mathrm{d}A$ and $k_{e,s} = \\int_{A_e} B_s^T D_s B_s \\, \\mathrm{d}A$, where $B_b$ and $B_s$ are the strain-displacement matrices for bending and shear, respectively.\n        -   The bending part is always integrated using a $2 \\times 2$ Gauss rule.\n        -   The shear part is integrated using either a $2 \\times 2$ rule (Full Integration, FI) or a $1 \\times 1$ rule (Selective Reduced Integration, SRI), depending on the analysis type.\n        -   The element force vector $f_e = \\int_{A_e} N_w^T q \\, \\mathrm{d}A$ is computed using a $2 \\times 2$ Gauss rule.\n    -   **Assembly**: Element matrices and vectors are assembled into global sparse matrices $K$ and a global vector $F$.\n    -   **Boundary Conditions**: The clamped conditions at $x=0$ are enforced by identifying the degrees of freedom (DOFs) on this boundary and removing the corresponding rows and columns from the linear system.\n    -   **Solver**: The reduced system $K_{free} u_{free} = F_{free}$ is solved for the unknown nodal displacements $u_{free}$. The full solution vector $u$ is then reconstructed.\n\n2.  **Goal-Oriented Error Estimation**:\n    -   **Reference Solution**: For a given thickness $t$, a high-fidelity reference solution $u_f(t)$ is computed on the fine mesh ($24 \\times 8$) using the SRI scheme.\n    -   **Coarse Solutions**: For the same thickness, two coarse solutions are computed on the coarse mesh ($12 \\times 4$): $u_c^{\\text{std}}(t)$ using FI and $u_c^{\\text{enr}}(t)$ using SRI.\n    -   **Prolongation**: The coarse solutions are transferred to the fine mesh grid via bilinear interpolation, yielding $u_{c \\to f}^{\\text{std}}$ and $u_{c \\to f}^{\\text{enr}}$.\n    -   **Adjoint Problem**: An adjoint problem $K_f z_f = j_f$ is solved on the fine mesh. The right-hand side, $j_f$, is a vector of zeros with a single $1$ at the DOF corresponding to the transverse displacement $w$ at the tip $(L,W)$. Note that $K_f$, and thus $z_f$, depends on the thickness $t$.\n    -   **Calibration**: The calibration constant $c$ is determined at the baseline thickness $t_{\\mathrm{cal}}=0.05$ m. It is computed to match the estimated error to the actual error for the standard (FI) coarse solution:\n        $$ c = \\frac{J(u_f(t_{\\mathrm{cal}})) - J(u_c^{\\text{std}}(t_{\\mathrm{cal}}))}{z_f(t_{\\mathrm{cal}})^\\top \\left( f_f - K_f(t_{\\mathrm{cal}}) u_{c \\to f}^{\\text{std}}(t_{\\mathrm{cal}}) \\right)} $$\n    -   **Error Prediction**: For the test thicknesses $t_1$ and $t_2$, the calibrated constant $c$ is used to predict the goal error for both the standard and enriched coarse solutions. For example, the estimated error for the standard solution at thickness $t$ is:\n        $$ \\eta^{\\text{std}}(t) = c \\cdot z_f(t)^\\top \\left( f_f - K_f(t) u_{c \\to f}^{\\text{std}}(t) \\right) $$\n\n3.  **Analysis and Output**: For each test thickness, the estimated errors are compared to the actual calculated errors $e_J(t) = J(u_f(t)) - J(u_c(t))$. The absolute actual errors for the FI and SRI coarse solutions are compared to determine if the enriched (SRI) element provides a more accurate result for the tip deflection. The final results are collected and formatted as specified.",
            "answer": "```python\nimport numpy as np\nfrom scipy.sparse import coo_matrix, csc_matrix\nfrom scipy.sparse.linalg import spsolve\nfrom functools import lru_cache\n\ndef solve():\n    \"\"\"\n    Main function to perform the entire FEM analysis and error estimation.\n    \"\"\"\n    \n    # Problem Parameters\n    L, W = 1.0, 0.2\n    E, nu = 70e9, 0.3\n    ks = 5/6\n    q = 1e4\n    \n    Nx_c, Ny_c = 12, 4\n    Nx_f, Ny_f = 24, 8\n\n    t_cal = 0.05\n    t1 = 0.01\n    t2 = 0.005\n    \n    class FEMPlateSolver:\n        \"\"\"\n        A class to perform Finite Element Analysis for a Mindlin-Reissner plate.\n        \"\"\"\n        def __init__(self, L, W, Nx, Ny, t, E, nu, ks, q, integration_type):\n            self.L, self.W, self.Nx, self.Ny = L, W, Nx, Ny\n            self.t, self.E, self.nu, self.ks, self.q = t, E, nu, ks, q\n            self.integration_type = integration_type\n\n            # Material properties\n            self.G = self.E / (2 * (1 + self.nu))\n            Db_factor = self.E * self.t**3 / (12 * (1 - self.nu**2))\n            self.Db = Db_factor * np.array([[1, self.nu, 0], [self.nu, 1, 0], [0, 0, (1 - self.nu)/2]])\n            self.Ds = self.ks * self.G * self.t * np.eye(2)\n\n            self.nodes, self.elements = self._generate_mesh()\n            self.num_nodes = self.nodes.shape[0]\n            self.num_dofs = self.num_nodes * 3\n            \n            self.clamped_dofs = self._get_clamped_dofs()\n            all_dofs = np.arange(self.num_dofs)\n            self.free_dofs = np.setdiff1d(all_dofs, self.clamped_dofs, assume_unique=True)\n\n        def _generate_mesh(self):\n            nx, ny = self.Nx + 1, self.Ny + 1\n            x = np.linspace(0, self.L, nx)\n            y = np.linspace(0, self.W, ny)\n            nodes = np.array([[xi, yi] for xi in x for yi in y])\n            \n            elements = []\n            for i in range(self.Nx):\n                for j in range(self.Ny):\n                    n1 = i * ny + j\n                    n2 = (i + 1) * ny + j\n                    n3 = (i + 1) * ny + (j + 1)\n                    n4 = i * ny + (j + 1)\n                    elements.append([n1, n2, n3, n4])\n            return nodes, np.array(elements)\n\n        @staticmethod\n        @lru_cache(maxsize=None)\n        def _get_gauss_points(n):\n            if n == 1:\n                return np.array([[0.0, 0.0]]), np.array([4.0])\n            if n == 2:\n                p = 1.0 / np.sqrt(3)\n                points = np.array([[-p, -p], [p, -p], [-p, p], [p, p]])\n                weights = np.array([1.0, 1.0, 1.0, 1.0])\n                return points, weights\n            raise ValueError(\"Only 1 and 2-point Gauss quadrature are supported.\")\n\n        @staticmethod\n        @lru_cache(maxsize=None)\n        def _get_shape_functions(xi, eta):\n            N = 0.25 * np.array([(1-xi)*(1-eta), (1+xi)*(1-eta), (1+xi)*(1+eta), (1-xi)*(1+eta)])\n            dNd_xi = 0.25 * np.array([-(1-eta), (1-eta), (1+eta), -(1+eta)])\n            dNd_eta = 0.25 * np.array([-(1-xi), -(1+xi), (1+xi), (1-xi)])\n            return N, np.vstack((dNd_xi, dNd_eta))\n\n        def _get_clamped_dofs(self):\n            clamped_nodes = np.where(np.isclose(self.nodes[:, 0], 0.0))[0]\n            dofs = []\n            for node_idx in clamped_nodes:\n                dofs.extend([3 * node_idx, 3 * node_idx + 1, 3 * node_idx + 2])\n            return np.array(dofs)\n\n        def solve_system(self):\n            rows, cols, data_K = [], [], []\n            F = np.zeros(self.num_dofs)\n\n            gp_bend, w_bend = self._get_gauss_points(2)\n            gp_shear, w_shear = self._get_gauss_points(1 if self.integration_type == 'SRI' else 2)\n\n            for el_nodes_idx in self.elements:\n                el_coords = self.nodes[el_nodes_idx]\n                dofs = np.array([[3*n, 3*n+1, 3*n+2] for n in el_nodes_idx]).flatten()\n                \n                ke_b = np.zeros((12, 12))\n                ke_s = np.zeros((12, 12))\n                fe = np.zeros(12)\n\n                # Bending stiffness\n                for gp, w in zip(gp_bend, w_bend):\n                    N, dNd_xieta = self._get_shape_functions(gp[0], gp[1])\n                    J = dNd_xieta @ el_coords\n                    detJ = np.linalg.det(J)\n                    dNd_xy = np.linalg.inv(J) @ dNd_xieta\n                    \n                    Bb = np.zeros((3, 12))\n                    for i in range(4):\n                        Bb[0, 3*i+1] = dNd_xy[0, i]\n                        Bb[1, 3*i+2] = dNd_xy[1, i]\n                        Bb[2, 3*i+1] = dNd_xy[1, i]\n                        Bb[2, 3*i+2] = dNd_xy[0, i]\n                    ke_b += Bb.T @ self.Db @ Bb * detJ * w\n                \n                # Shear stiffness\n                for gp, w in zip(gp_shear, w_shear):\n                    N, dNd_xieta = self._get_shape_functions(gp[0], gp[1])\n                    J = dNd_xieta @ el_coords\n                    detJ = np.linalg.det(J)\n                    dNd_xy = np.linalg.inv(J) @ dNd_xieta\n                    \n                    Bs = np.zeros((2, 12))\n                    for i in range(4):\n                        Bs[0, 3*i]   = dNd_xy[0, i]\n                        Bs[0, 3*i+1] = N[i]\n                        Bs[1, 3*i]   = dNd_xy[1, i]\n                        Bs[1, 3*i+2] = N[i]\n                    ke_s += Bs.T @ self.Ds @ Bs * detJ * w\n                \n                # Force vector\n                for gp, w in zip(gp_bend, w_bend):\n                    N, dNd_xieta = self._get_shape_functions(gp[0], gp[1])\n                    J = dNd_xieta @ el_coords\n                    detJ = np.linalg.det(J)\n                    for i in range(4):\n                        fe[3*i] += N[i] * self.q * detJ * w\n                \n                ke = ke_b + ke_s\n                row_indices, col_indices = np.meshgrid(dofs, dofs)\n                rows.extend(row_indices.flatten())\n                cols.extend(col_indices.flatten())\n                data_K.extend(ke.flatten())\n                F[dofs] += fe\n\n            K = csc_matrix((data_K, (rows, cols)), shape=(self.num_dofs, self.num_dofs))\n            K_free = K[self.free_dofs, :][:, self.free_dofs]\n            F_free = F[self.free_dofs]\n            \n            u_free = spsolve(K_free, F_free)\n            \n            u = np.zeros(self.num_dofs)\n            u[self.free_dofs] = u_free\n            \n            return K, F, u\n\n        def get_tip_w_dof_index(self):\n            tip_node_idx = self.Nx * (self.Ny + 1) + self.Ny\n            return 3 * tip_node_idx\n            \n        def get_tip_deflection(self, u):\n            return u[self.get_tip_w_dof_index()]\n\n    def prolong_solution(u_c, solver_c, solver_f):\n        u_f_prolonged = np.zeros(solver_f.num_dofs)\n        nodes_map = np.zeros((solver_f.num_nodes, 4), dtype=int)\n        weights_map = np.zeros((solver_f.num_nodes, 4))\n\n        for i_f in range(solver_f.Nx + 1):\n            for j_f in range(solver_f.Ny + 1):\n                node_idx_f = i_f * (solver_f.Ny + 1) + j_f\n                \n                i_c, rem_i = divmod(i_f, 2)\n                j_c, rem_j = divmod(j_f, 2)\n                \n                if rem_i == 0 and rem_j == 0: # coarse node\n                    nodes_map[node_idx_f, 0] = i_c * (solver_c.Ny + 1) + j_c\n                    weights_map[node_idx_f, 0] = 1.0\n                elif rem_i == 1 and rem_j == 0: # horizontal edge midpoint\n                    n1 = i_c * (solver_c.Ny + 1) + j_c\n                    n2 = (i_c + 1) * (solver_c.Ny + 1) + j_c\n                    nodes_map[node_idx_f, :2] = [n1, n2]\n                    weights_map[node_idx_f, :2] = [0.5, 0.5]\n                elif rem_i == 0 and rem_j == 1: # vertical edge midpoint\n                    n1 = i_c * (solver_c.Ny + 1) + j_c\n                    n2 = i_c * (solver_c.Ny + 1) + (j_c + 1)\n                    nodes_map[node_idx_f, :2] = [n1, n2]\n                    weights_map[node_idx_f, :2] = [0.5, 0.5]\n                else: # center of coarse element\n                    n1 = i_c * (solver_c.Ny + 1) + j_c\n                    n2 = (i_c + 1) * (solver_c.Ny + 1) + j_c\n                    n3 = (i_c + 1) * (solver_c.Ny + 1) + (j_c + 1)\n                    n4 = i_c * (solver_c.Ny + 1) + (j_c + 1)\n                    nodes_map[node_idx_f, :] = [n1, n2, n3, n4]\n                    weights_map[node_idx_f, :] = [0.25, 0.25, 0.25, 0.25]\n        \n        for i_f in range(solver_f.num_nodes):\n            for dof_i in range(3):\n                val = 0.0\n                for j in range(4):\n                    if weights_map[i_f, j] > 0:\n                        node_c = nodes_map[i_f, j]\n                        val += weights_map[i_f, j] * u_c[3 * node_c + dof_i]\n                u_f_prolonged[3 * i_f + dof_i] = val\n        return u_f_prolonged\n\n    # --- Calibration at t_cal ---\n    solver_c_std_cal = FEMPlateSolver(L, W, Nx_c, Ny_c, t_cal, E, nu, ks, q, 'FI')\n    K_c_std_cal, F_c_std_cal, u_c_std_cal = solver_c_std_cal.solve_system()\n    \n    solver_f_sri_cal = FEMPlateSolver(L, W, Nx_f, Ny_f, t_cal, E, nu, ks, q, 'SRI')\n    K_f_cal, F_f_cal, u_f_sri_cal = solver_f_sri_cal.solve_system()\n\n    # Adjoint solve\n    j_f = np.zeros(solver_f_sri_cal.num_dofs)\n    tip_dof_f = solver_f_sri_cal.get_tip_w_dof_index()\n    j_f[tip_dof_f] = 1.0\n\n    K_f_free = K_f_cal[solver_f_sri_cal.free_dofs, :][:, solver_f_sri_cal.free_dofs]\n    j_f_free = j_f[solver_f_sri_cal.free_dofs]\n    z_f_free = spsolve(K_f_free, j_f_free)\n    z_f_cal = np.zeros(solver_f_sri_cal.num_dofs)\n    z_f_cal[solver_f_sri_cal.free_dofs] = z_f_free\n\n    # Prolong coarse solution and compute residual\n    u_c_to_f_std_cal = prolong_solution(u_c_std_cal, solver_c_std_cal, solver_f_sri_cal)\n    residual_std_cal = F_f_cal - K_f_cal @ u_c_to_f_std_cal\n    \n    # Raw estimator\n    eta_hat_std_cal = z_f_cal.T @ residual_std_cal\n    \n    # Actual error\n    actual_err_std_cal = solver_f_sri_cal.get_tip_deflection(u_f_sri_cal) - solver_c_std_cal.get_tip_deflection(u_c_std_cal)\n\n    # Calibration constant\n    c = actual_err_std_cal / eta_hat_std_cal\n    results = [round(c, 6)]\n\n    # --- Analysis for t1 and t2 ---\n    for t_val in [t1, t2]:\n        # Coarse solutions\n        solver_c_std = FEMPlateSolver(L, W, Nx_c, Ny_c, t_val, E, nu, ks, q, 'FI')\n        _, _, u_c_std = solver_c_std.solve_system()\n        solver_c_sri = FEMPlateSolver(L, W, Nx_c, Ny_c, t_val, E, nu, ks, q, 'SRI')\n        _, _, u_c_sri = solver_c_sri.solve_system()\n        \n        # Fine reference solution\n        solver_f_sri = FEMPlateSolver(L, W, Nx_f, Ny_f, t_val, E, nu, ks, q, 'SRI')\n        K_f, F_f, u_f_sri = solver_f_sri.solve_system()\n\n        # New Adjoint solve for current t\n        K_f_free = K_f[solver_f_sri.free_dofs, :][:, solver_f_sri.free_dofs]\n        z_f_free = spsolve(K_f_free, j_f_free)\n        z_f = np.zeros(solver_f_sri.num_dofs)\n        z_f[solver_f_sri.free_dofs] = z_f_free\n\n        # --- Standard (FI) solution analysis ---\n        u_c_to_f_std = prolong_solution(u_c_std, solver_c_std, solver_f_sri)\n        residual_std = F_f - K_f @ u_c_to_f_std\n        est_err_std = c * (z_f.T @ residual_std)\n        act_err_std = solver_f_sri.get_tip_deflection(u_f_sri) - solver_c_std.get_tip_deflection(u_c_std)\n\n        # --- Enriched (SRI) solution analysis ---\n        u_c_to_f_sri = prolong_solution(u_c_sri, solver_c_sri, solver_f_sri)\n        residual_sri = F_f - K_f @ u_c_to_f_sri\n        est_err_sri = c * (z_f.T @ residual_sri)\n        act_err_sri = solver_f_sri.get_tip_deflection(u_f_sri) - solver_c_sri.get_tip_deflection(u_c_sri)\n\n        improved = abs(act_err_sri)  abs(act_err_std)\n        \n        results.extend([\n            round(est_err_std, 6), round(est_err_sri, 6),\n            round(act_err_std, 6), round(act_err_sri, 6),\n            improved\n        ])\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Having seen how to identify and remedy shear locking, our final practice delves into the subtle but critical role of numerical precision. For very thin plates, the calculation of shear strain often involves subtracting two nearly equal numbers, a classic scenario for catastrophic cancellation error in floating-point arithmetic . This exercise models this effect to reveal how the finite precision of computer arithmetic can interact with the theoretical formulation, potentially undermining the accuracy of even advanced, lock-remedying methods. By comparing results from standard double-precision and emulated quadruple-precision arithmetic, you will gain crucial insight into the numerical stability of finite element methods and the importance of careful implementation.",
            "id": "3600188",
            "problem": "Consider a single, four-node bilinear quadrilateral plate element of side length $L$ in the Reissner–Mindlin theory, with transverse displacement field $w(x,y)$ and rotations $\\theta_x(x,y)$ and $\\theta_y(x,y)$. The thin-plate limit is governed by the Kirchhoff constraint, where the Reissner–Mindlin shear strains $\\gamma_{xz}$ and $\\gamma_{yz}$ tend to zero because the kinematic relation enforces $\\theta_x \\approx -\\partial w/\\partial x$ and $\\theta_y \\approx -\\partial w/\\partial y$. In a Finite Element Method (FEM) implementation that uses the $\\bar{B}$-projection (commonly called the $B\\text{-}\\bar{}$ method), the elementwise projected shear strains are defined at quadrature points as $\\bar{\\gamma}_{xz,i} = \\gamma_{xz,i} - \\overline{\\gamma}_{xz}$ and $\\bar{\\gamma}_{yz,i} = \\gamma_{yz,i} - \\overline{\\gamma}_{yz}$, where $\\overline{\\gamma}$ is the elementwise average of the corresponding shear strain over the quadrature points. This projection is used to alleviate shear locking, which otherwise manifests when the thickness-to-length ratio becomes small in Reissner–Mindlin formulations.\n\nYou will analyze the sensitivity of the projected shear energy to floating-point rounding and cancellation when the plate is thin, specifically comparing standard double precision to quadruple precision. The focus is the numerical effect of cancellation in forming $\\gamma_{xz} = \\theta_x + \\partial w/\\partial x$ and $\\gamma_{yz} = \\theta_y + \\partial w/\\partial y$ when the ideal Kirchhoff relations $\\theta_x = -\\partial w/\\partial x$ and $\\theta_y = -\\partial w/\\partial y$ hold, but the operands are themselves rounded floating-point values. The rounding model is based on a standard floating-point error characterization, where the rounded value of any quantity $a$ is $\\mathrm{fl}(a) = a(1+\\delta)$ with $|\\delta| \\le u$, and the unit roundoff $u$ depends on precision. For Institute of Electrical and Electronics Engineers (IEEE) double precision, take $u = 2^{-53}$, and for IEEE quadruple precision, take $u = 2^{-113}$.\n\nUse the manufactured field\n$$\nw(x,y) = \\alpha x^2 + \\beta y^2,\\quad \\theta_x(x,y) = -\\frac{\\partial w}{\\partial x} = -2\\alpha x,\\quad \\theta_y(x,y) = -\\frac{\\partial w}{\\partial y} = -2\\beta y,\n$$\nwith constants $\\alpha$ and $\\beta$ independent of $L$ and $t$ (the plate thickness). For material parameters, use Young’s modulus $E$, Poisson’s ratio $\\nu$, shear correction factor $\\kappa_s$, and shear modulus $G = \\dfrac{E}{2(1+\\nu)}$. The bending stiffness is $D = \\dfrac{E t^3}{12(1-\\nu^2)}$. The bending strain energy for this field is constant over the element and equal to\n$$\nU_{\\text{bend}} = \\frac{1}{2} D \\left(\\kappa_{xx}^2 + \\kappa_{yy}^2 + 2\\nu \\kappa_{xx}\\kappa_{yy}\\right) L^2,\n$$\nwhere $\\kappa_{xx} = \\dfrac{\\partial^2 w}{\\partial x^2} = 2\\alpha$, $\\kappa_{yy} = \\dfrac{\\partial^2 w}{\\partial y^2} = 2\\beta$, and $\\kappa_{xy} = 0$. The projected shear strain energy is computed with $2\\times 2$ Gauss quadrature as\n$$\nU_{\\text{shear}}^{\\bar{B}} = \\frac{1}{2} \\kappa_s G t \\sum_{i=1}^4 w_i \\left( \\bar{\\gamma}_{xz,i}^2 + \\bar{\\gamma}_{yz,i}^2 \\right) \\det J,\n$$\nwhere $w_i = 1$ are the Gauss weights and $\\det J = (L/2)^2$ for the mapping from the reference square $[-1,1]^2$ to $[0,L]^2$. The projected shear strains are formed by $\\bar{\\gamma}_{xz,i} = \\gamma_{xz,i} - \\overline{\\gamma}_{xz}$ and $\\bar{\\gamma}_{yz,i} = \\gamma_{yz,i} - \\overline{\\gamma}_{yz}$, with $\\overline{\\gamma}_{xz} = \\dfrac{1}{4} \\sum_{i=1}^4 \\gamma_{xz,i}$ and $\\overline{\\gamma}_{yz} = \\dfrac{1}{4} \\sum_{i=1}^4 \\gamma_{yz,i}$.\n\nTo model cancellation in forming $\\gamma_{xz,i}$ and $\\gamma_{yz,i}$ under floating-point rounding when $\\theta_x = -\\partial w/\\partial x$ and $\\theta_y = -\\partial w/\\partial y$, take the rounded operands to be\n$$\n\\mathrm{fl}\\big(\\theta_x(x_i,y_i)\\big) = -2\\alpha x_i\\,(1+\\delta^{(x)}_{1,i}),\\quad \\mathrm{fl}\\left(\\frac{\\partial w}{\\partial x}(x_i,y_i)\\right) = 2\\alpha x_i\\,(1+\\delta^{(x)}_{2,i}),\n$$\nand\n$$\n\\mathrm{fl}\\big(\\theta_y(x_i,y_i)\\big) = -2\\beta y_i\\,(1+\\delta^{(y)}_{1,i}),\\quad \\mathrm{fl}\\left(\\frac{\\partial w}{\\partial y}(x_i,y_i)\\right) = 2\\beta y_i\\,(1+\\delta^{(y)}_{2,i}),\n$$\nso that\n$$\n\\gamma_{xz,i} = \\mathrm{fl}\\big(\\theta_x\\big) + \\mathrm{fl}\\left(\\frac{\\partial w}{\\partial x}\\right) \\approx 2\\alpha x_i\\left(\\delta^{(x)}_{2,i} - \\delta^{(x)}_{1,i}\\right),\n$$\nand\n$$\n\\gamma_{yz,i} \\approx 2\\beta y_i\\left(\\delta^{(y)}_{2,i} - \\delta^{(y)}_{1,i}\\right).\n$$\nChoose deterministic rounding perturbations at the Gauss points as\n$$\n\\delta^{(x)}_{1,i} = u \\left(1 + \\frac{x_i}{L}\\right),\\quad \\delta^{(x)}_{2,i} = -u \\left(1 + \\frac{y_i}{L}\\right),\\quad\n\\delta^{(y)}_{1,i} = u \\left(1 + \\frac{y_i}{L}\\right),\\quad \\delta^{(y)}_{2,i} = -u \\left(1 + \\frac{x_i}{L}\\right).\n$$\nFor the four Gauss points on $[0,L]^2$, use the canonical $2\\times 2$ locations mapped from the reference points $(\\xi,\\eta) = (\\pm 1/\\sqrt{3},\\pm 1/\\sqrt{3})$ via $x = (1+\\xi)L/2$, $y = (1+\\eta)L/2$. This construction models near-worst-case cancellation in thin-plate kinematics in a deterministic way without stochastic components.\n\nCompute, for each thickness ratio $t/L$, the dimensionless ratio\n$$\nR = \\frac{U_{\\text{shear}}^{\\bar{B}}}{U_{\\text{bend}}},\n$$\nonce using IEEE double precision rounding and once using IEEE quadruple precision rounding. For the quadruple-precision path, implement arithmetic for summation and multiplication of projected shear-strain terms using a double-double representation to emulate quadruple accuracy, including compensated summation for the $\\bar{B}$ projection averages. For the double-precision path, use standard floating-point operations. Take the constants\n$$\nE = 2.10\\times 10^{11}\\ \\text{Pa},\\quad \\nu = 0.3,\\quad \\kappa_s = \\frac{5}{6},\\quad \\alpha = 1.0,\\quad \\beta = 1.0,\\quad L = 1.0\\ \\text{m}.\n$$\n\nYour program must implement this computation for the following test suite of thickness-to-length ratios:\n- $t/L = 10^{-1}$ (a relatively thick plate),\n- $t/L = 10^{-2}$,\n- $t/L = 10^{-3}$,\n- $t/L = 10^{-4}$ (a very thin plate, representative of locking-prone regimes).\n\nAll quantities are dimensionless ratios, so no physical unit is required in the final output. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain $8$ floating-point numbers in scientific notation with six significant digits. The first four numbers correspond to $R$ in double precision for the four test cases in the order given, and the next four numbers correspond to $R$ in quadruple precision for the same test cases and order. For example, the output format must be like\n$$\n[\\text{R}_{\\text{double},1},\\text{R}_{\\text{double},2},\\text{R}_{\\text{double},3},\\text{R}_{\\text{double},4},\\text{R}_{\\text{quad},1},\\text{R}_{\\text{quad},2},\\text{R}_{\\text{quad},3},\\text{R}_{\\text{quad},4}],\n$$\nwith each $\\text{R}$ printed as a number in scientific notation with six significant digits.",
            "solution": "The user-provided problem is a valid exercise in computational solid mechanics and numerical analysis. It requires the computation of a dimensionless ratio $R$ comparing a numerically-induced shear strain energy $U_{\\text{shear}}^{\\bar{B}}$ to the analytical bending strain energy $U_{\\text{bend}}$ for a thin plate element under a specific manufactured solution. The analysis must be performed for several thickness-to-length ratios $t/L$ and repeated for two different floating-point precision levels: IEEE double precision and an emulated IEEE quadruple precision.\n\nThe core of the problem lies in modeling and quantifying the effect of subtractive cancellation when computing Reissner–Mindlin shear strains $\\gamma = \\theta + \\partial w/\\partial x$ in the thin-plate limit, where kinematically $\\theta \\to -\\partial w/\\partial x$. The problem provides a deterministic model for the rounding errors, which simplifies the analysis while retaining the essential numerical behavior.\n\nThe solution is implemented by following these steps:\n\n1.  **Constants and Geometry**: Define all physical and geometric constants ($E, \\nu, \\kappa_s, \\alpha, \\beta, L$) as provided. The shear modulus $G$ is derived from $E$ and $\\nu$. The coordinates of the four $2\\times 2$ Gauss quadrature points are calculated by mapping the reference points $(\\xi_i, \\eta_i) = (\\pm 1/\\sqrt{3}, \\pm 1/\\sqrt{3})$ from the canonical square $[-1,1]^2$ to the physical element domain $[0,L]^2$.\n\n2.  **Bending Strain Energy ($U_{\\text{bend}}$)**: This quantity serves as a reference scale. It is computed analytically from the given manufactured solution. The curvatures are constant throughout the element: $\\kappa_{xx} = 2\\alpha$ and $\\kappa_{yy} = 2\\beta$. The bending stiffness is $D = \\frac{E t^3}{12(1-\\nu^2)}$. The bending energy for the square element of area $L^2$ is then:\n    $$U_{\\text{bend}} = \\frac{1}{2} D \\left(\\kappa_{xx}^2 + \\kappa_{yy}^2 + 2\\nu \\kappa_{xx}\\kappa_{yy}\\right) L^2$$\n    This calculation is performed for each given thickness $t$.\n\n3.  **Shear Strain Computation with Modeled Rounding Error**: The key part of the problem is the computation of the shear strains $\\gamma_{xz}$ and $\\gamma_{yz}$ at each of the four Gauss points $(x_i, y_i)$. The problem specifies a model where the exact cancellation is perturbed by floating-point rounding errors on the operands:\n    $$\n    \\gamma_{xz,i} = \\mathrm{fl}(\\theta_x) + \\mathrm{fl}\\left(\\frac{\\partial w}{\\partial x}\\right) \\approx 2\\alpha x_i\\left(\\delta^{(x)}_{2,i} - \\delta^{(x)}_{1,i}\\right)\n    $$\n    $$\n    \\gamma_{yz,i} = \\mathrm{fl}(\\theta_y) + \\mathrm{fl}\\left(\\frac{\\partial w}{\\partial y}\\right) \\approx 2\\beta y_i\\left(\\delta^{(y)}_{2,i} - \\delta^{(y)}_{1,i}\\right)\n    $$\n    The perturbations $\\delta$ are defined deterministically based on the unit roundoff $u$ and the Gauss point coordinates:\n    $$\n    \\delta^{(x)}_{1,i} = u \\left(1 + \\frac{x_i}{L}\\right),\\quad \\delta^{(x)}_{2,i} = -u \\left(1 + \\frac{y_i}{L}\\right)\n    $$\n    $$\n    \\delta^{(y)}_{1,i} = u \\left(1 + \\frac{y_i}{L}\\right),\\quad \\delta^{(y)}_{2,i} = -u \\left(1 + \\frac{x_i}{L}\\right)\n    $$\n    Substituting these into the strain expressions gives:\n    $$\n    \\gamma_{xz,i} = -2\\alpha u x_i \\left(2 + \\frac{x_i + y_i}{L}\\right)\n    $$\n    $$\n    \\gamma_{yz,i} = -2\\beta u y_i \\left(2 + \\frac{x_i + y_i}{L}\\right)\n    $$\n    These strains are calculated for two scenarios, differing by the value of the unit roundoff $u$: $u_{\\text{double}} = 2^{-53}$ and $u_{\\text{quad}} = 2^{-113}$.\n\n4.  **Projected Shear Strain Energy ($U_{\\text{shear}}^{\\bar{B}}$)**: The $\\bar{B}$-projection method requires computing element-averaged shear strains and subtracting them from the pointwise values. For each shear component (e.g., $xz$), the average is $\\overline{\\gamma}_{xz} = \\frac{1}{4} \\sum_{i=1}^4 \\gamma_{xz,i}$, and the projected strain at Gauss point $i$ is $\\bar{\\gamma}_{xz,i} = \\gamma_{xz,i} - \\overline{\\gamma}_{xz}$. The shear energy is then computed via numerical quadrature:\n    $$\n    U_{\\text{shear}}^{\\bar{B}} = \\frac{1}{2} \\kappa_s G t \\sum_{i=1}^4 \\left( \\bar{\\gamma}_{xz,i}^2 + \\bar{\\gamma}_{yz,i}^2 \\right) (\\text{weight}_i \\cdot \\det J)\n    $$\n    For $2\\times 2$ Gauss quadrature on a square element mapped from $[-1,1]^2$ to $[0,L]^2$, the weights are $w_i=1$ and the Jacobian determinant is $\\det J = (L/2)^2$.\n\n5.  **Precision Emulation**: The calculation in step 4 is performed twice with different arithmetic implementations.\n    *   **Double Precision Path**: All calculations (summation, subtraction, squaring) use standard Python floating-point numbers (IEEE 754 double precision).\n    *   **Quadruple Precision Path**: To emulate quadruple precision, a `DoubleDouble` number representation is implemented. Each number is stored as a pair of doubles, `(high_part, low_part)`. Arithmetic operations (addition, subtraction, multiplication, division by scalar) are implemented for this `DoubleDouble` type using established algorithms (e.g., those by Knuth, Dekker, Bailey) that manage the error terms from standard floating-point operations. The summation to find the average strain and the summation of squared projected strains are carried out using this `DoubleDouble` arithmetic to maintain higher precision and correctly model the behavior with $u = 2^{-113}$.\n\n6.  **Final Ratio Calculation and Output**: For each specified $t/L$ ratio and for each precision path, the dimensionless ratio $R = U_{\\text{shear}}^{\\bar{B}} / U_{\\text{bend}}$ is computed. The eight resulting values of $R$ (four for double precision, four for quad precision) are collected and formatted into a single string as specified by the problem instructions. The results are printed in scientific notation with six significant digits.",
            "answer": "```python\n# The final answer must be a single, complete, standalone program.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the shear locking numerical precision problem.\n    \"\"\"\n    \n    # This block defines the Double-Double arithmetic functionality.\n    # It is placed inside solve() to be fully self-contained.\n    def two_sum_robust(a, b):\n        \"\"\"Computes s, e such that s = a + b and e is the computational error.\"\"\"\n        s = a + b\n        v = s - a\n        e = (a - (s - v)) + (b - v)\n        return s, e\n\n    # A factor for splitting a double-precision number's mantissa.\n    SPLITTER = 134217729.0  # 2**27 + 1\n\n    def split(a):\n        \"\"\"Splits a double into two non-overlapping parts.\"\"\"\n        c = SPLITTER * a\n        big = c - (c - a)\n        small = a - big\n        return big, small\n\n    def two_prod(a, b):\n        \"\"\"Computes p, e such that p = a * b and e is the computational error.\"\"\"\n        p = a * b\n        ah, al = split(a)\n        bh, bl = split(b)\n        e = ((ah * bh - p) + ah * bl + al * bh) + al * bl\n        return p, e\n\n    class DoubleDouble:\n        \"\"\"\n        A class to represent numbers with emulated quadruple precision using two doubles.\n        Implements basic arithmetic operations needed for this problem.\n        \"\"\"\n        __slots__ = ['hi', 'lo']\n\n        def __init__(self, x, y=0.0):\n            if isinstance(x, DoubleDouble):\n                self.hi, self.lo = x.hi, x.lo\n            else:\n                self.hi, self.lo = float(x), float(y)\n\n        @property\n        def value(self):\n            return self.hi + self.lo\n\n        def __add__(self, other):\n            if isinstance(other, DoubleDouble):\n                s, e = two_sum_robust(self.hi, other.hi)\n                e += self.lo + other.lo\n                s, e = two_sum_robust(s, e)\n                return DoubleDouble(s, e)\n            else:\n                s, e = two_sum_robust(self.hi, other)\n                e += self.lo\n                s, e = two_sum_robust(s, e)\n                return DoubleDouble(s, e)\n\n        def __radd__(self, other):\n            return self.__add__(other)\n\n        def __sub__(self, other):\n            return self.__add__(-other)\n\n        def __neg__(self):\n            return DoubleDouble(-self.hi, -self.lo)\n\n        def __mul__(self, other):\n            if isinstance(other, DoubleDouble):\n                p, e = two_prod(self.hi, other.hi)\n                t = self.hi * other.lo + self.lo * other.hi\n                s, err = two_sum_robust(p, t)\n                err += e\n                s, err = two_sum_robust(s, err)\n                return DoubleDouble(s, err)\n            else:\n                p1, e1 = two_prod(self.hi, other)\n                p2 = self.lo * other\n                s, e = two_sum_robust(p1, p2)\n                e += e1\n                s, e = two_sum_robust(s, e)\n                return DoubleDouble(s, e)\n\n        def __pow__(self, n):\n            if n == 2:\n                return self * self\n            raise NotImplementedError(\"Power only implemented for n=2.\")\n\n        def __truediv__(self, other_val):\n            if isinstance(other_val, (int, float)):\n                q1 = self.hi / other_val\n                p1, e1 = two_prod(q1, other_val)\n                d = (self.hi - p1) - e1 + self.lo\n                q2 = d / other_val\n                hi, lo = two_sum_robust(q1, q2)\n                return DoubleDouble(hi, lo)\n            raise NotImplementedError(\"Division by DoubleDouble not implemented.\")\n\n    # Problem constants and setup\n    E = 2.10e11\n    nu = 0.3\n    kappa_s = 5.0 / 6.0\n    alpha = 1.0\n    beta = 1.0\n    L = 1.0\n    G = E / (2.0 * (1.0 + nu))\n    u_double = 2.0**-53\n    u_quad = 2.0**-113\n    \n    test_cases_t_over_L = [1e-1, 1e-2, 1e-3, 1e-4]\n\n    # Gauss quadrature points for a [0,L]x[0,L] element\n    g = 1.0 / np.sqrt(3.0)\n    xi_eta_pairs = [(-g, -g), (g, -g), (g, g), (-g, g)]\n    gauss_points = [((1.0 + xi) * L / 2.0, (1.0 + eta) * L / 2.0) for xi, eta in xi_eta_pairs]\n\n    def calculate_R(t_over_L, precision_mode):\n        u = u_double if precision_mode == 'double' else u_quad\n        t = t_over_L * L\n\n        # Calculate Bending Energy (U_bend)\n        kappa_xx = 2.0 * alpha\n        kappa_yy = 2.0 * beta\n        D = (E * t**3) / (12.0 * (1.0 - nu**2))\n        \n        if D == 0.0: return 0.0\n            \n        U_bend = 0.5 * D * (kappa_xx**2 + kappa_yy**2 + 2.0 * nu * kappa_xx * kappa_yy) * L**2\n        \n        if U_bend == 0.0: return float('inf')\n\n        # Calculate Shear Strains at Gauss points due to rounding\n        gammas_xz, gammas_yz = [], []\n        for x_i, y_i in gauss_points:\n            common_factor = 2.0 + (x_i + y_i) / L\n            gammas_xz.append(-2.0 * alpha * u * x_i * common_factor)\n            gammas_yz.append(-2.0 * beta * u * y_i * common_factor)\n    \n        # Calculate sum of squared projected strains\n        sum_sq_gamma_bar = 0.0\n        if precision_mode == 'double':\n            avg_gamma_xz = sum(gammas_xz) / 4.0\n            avg_gamma_yz = sum(gammas_yz) / 4.0\n            \n            for i in range(4):\n                gamma_xz_bar = gammas_xz[i] - avg_gamma_xz\n                gamma_yz_bar = gammas_yz[i] - avg_gamma_yz\n                sum_sq_gamma_bar += gamma_xz_bar**2 + gamma_yz_bar**2\n        else: # 'quad' precision mode\n            dd_gammas_xz = [DoubleDouble(g) for g in gammas_xz]\n            dd_gammas_yz = [DoubleDouble(g) for g in gammas_yz]\n            \n            dd_sum_xz = sum(dd_gammas_xz, DoubleDouble(0.0))\n            dd_avg_xz = dd_sum_xz / 4.0\n\n            dd_sum_yz = sum(dd_gammas_yz, DoubleDouble(0.0))\n            dd_avg_yz = dd_sum_yz / 4.0\n            \n            dd_sum_sq_gamma_bar = DoubleDouble(0.0)\n            for i in range(4):\n                dd_gamma_xz_bar = dd_gammas_xz[i] - dd_avg_xz\n                dd_gamma_yz_bar = dd_gammas_yz[i] - dd_avg_yz\n                dd_sum_sq_gamma_bar += (dd_gamma_xz_bar**2) + (dd_gamma_yz_bar**2)\n\n            sum_sq_gamma_bar = dd_sum_sq_gamma_bar.value\n\n        # Calculate Projected Shear Energy (U_shear)\n        det_J = (L / 2.0)**2\n        U_shear = 0.5 * kappa_s * G * t * det_J * sum_sq_gamma_bar\n        \n        R = U_shear / U_bend\n        return R\n\n    # Main calculation loop\n    results_double = [calculate_R(t_L, 'double') for t_L in test_cases_t_over_L]\n    results_quad = [calculate_R(t_L, 'quad') for t_L in test_cases_t_over_L]\n    \n    final_results = results_double + results_quad\n    \n    # Format and print output with 6 significant digits. The .5e specifier is correct for this.\n    formatted_results = [f\"{r:.5e}\" for r in final_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}