{
    "hands_on_practices": [
        {
            "introduction": "To truly master a numerical technique, one must look under the hood and understand its mathematical foundation. This first exercise demystifies Selective Reduced Integration by guiding you through the derivation of the element stiffness matrix from first principles. By splitting the strain energy into volumetric and deviatoric parts and applying different quadrature rules, you will see precisely how the SRI formulation is constructed to target volumetric locking at its source .",
            "id": "3599144",
            "problem": "Consider a two-dimensional small-strain isotropic solid discretized by the Finite Element Method (FEM), using a single bilinear quadrilateral element ($Q_4$) that occupies the rectangular domain with nodes at $(0,0)$, $(a,0)$, $(a,b)$, and $(0,b)$ in physical coordinates. The stored energy density is split into volumetric and deviatoric parts according to\n$$\nW = \\tfrac{1}{2}K\\big(\\operatorname{tr}\\epsilon\\big)^{2} + \\mu\\,\\epsilon_{\\text{dev}}:\\epsilon_{\\text{dev}},\n$$\nwhere $K$ is the bulk modulus, $\\mu$ is the shear modulus, $\\epsilon$ is the small-strain tensor, and $\\epsilon_{\\text{dev}} = \\epsilon - \\tfrac{1}{2}(\\operatorname{tr}\\epsilon)\\,\\mathbf{I}$ is the two-dimensional deviatoric strain (with $\\mathbf{I}$ the identity). The parent-space bilinear shape functions $N_{i}(\\xi,\\eta)$, $i=1,\\dots,4$, are defined on $[-1,1]\\times[-1,1]$, and the isoparametric map for the rectangle is affine, with Jacobian determinant $|J|=ab/4$.\n\nStarting from this energy density and the principle of virtual work, derive the element-level stiffness matrix split into volumetric and deviatoric contributions and implement Selective Reduced Integration (SRI): evaluate the volumetric contribution with one-point Gauss quadrature at $(\\xi,\\eta)=(0,0)$ with weight $4$, and evaluate the deviatoric contribution with the $2\\times 2$ Gauss rule at $(\\xi,\\eta)=\\big(\\pm 1/\\sqrt{3},\\pm 1/\\sqrt{3}\\big)$ with unit weights. Use the two-dimensional Voigt notation for strains and stresses, with the strain-displacement matrix $B(\\xi,\\eta)$ constructed from $N_{i,x}(\\xi,\\eta)$ and $N_{i,y}(\\xi,\\eta)$, where $N_{i,x}=(2/a)\\,N_{i,\\xi}$ and $N_{i,y}=(2/b)\\,N_{i,\\eta}$ and\n$$\nN_{1}=\\tfrac{1}{4}(1-\\xi)(1-\\eta),\\quad\nN_{2}=\\tfrac{1}{4}(1+\\xi)(1-\\eta),\\quad\nN_{3}=\\tfrac{1}{4}(1+\\xi)(1+\\eta),\\quad\nN_{4}=\\tfrac{1}{4}(1-\\xi)(1+\\eta),\n$$\nwith\n$$\nN_{1,\\xi}=-\\tfrac{1}{4}(1-\\eta),\\quad\nN_{2,\\xi}=\\tfrac{1}{4}(1-\\eta),\\quad\nN_{3,\\xi}=\\tfrac{1}{4}(1+\\eta),\\quad\nN_{4,\\xi}=-\\tfrac{1}{4}(1+\\eta),\n$$\nand\n$$\nN_{1,\\eta}=-\\tfrac{1}{4}(1-\\xi),\\quad\nN_{2,\\eta}=-\\tfrac{1}{4}(1+\\xi),\\quad\nN_{3,\\eta}=\\tfrac{1}{4}(1+\\xi),\\quad\nN_{4,\\eta}=\\tfrac{1}{4}(1-\\xi).\n$$\nExpress the final stiffness matrix as a single closed-form analytic expression in terms of $a$, $b$, $K$, $\\mu$, and the strain-displacement matrix $B(\\xi,\\eta)$. Your final answer must be a calculation, specifically the single analytic expression for the SRI-computed element stiffness. No numerical rounding is required.",
            "solution": "The problem asks for the derivation of the element-level stiffness matrix for a specific case of a two-dimensional, small-strain, isotropic solid discretized by a single bilinear quadrilateral ($Q_4$) element. The derivation must employ the technique of Selective Reduced Integration (SRI).\n\nThe general expression for the element stiffness matrix $k^e$ in the Finite Element Method for linear elasticity is obtained from the principle of virtual work and is given by the integral over the element's volume $\\Omega^e$:\n$$\nk^e = \\int_{\\Omega^e} B^T D B \\, d\\Omega\n$$\nwhere $B$ is the strain-displacement matrix, and $D$ is the constitutive matrix relating stress and strain in Voigt notation.\n\nFor an isoparametric element, this integral is transformed to the parent domain, which is a square $[-1,1]\\times[-1,1]$ in $(\\xi, \\eta)$ coordinates. The differential volume element becomes $d\\Omega = t|J|d\\xi d\\eta$, where $t$ is the element thickness (we assume $t=1$) and $|J|$ is the determinant of the Jacobian of the coordinate mapping. The problem specifies that for the given rectangular element, $|J| = ab/4$. The stiffness matrix integral is thus:\n$$\nk^e = \\int_{-1}^{1} \\int_{-1}^{1} B(\\xi, \\eta)^T D B(\\xi, \\eta) \\left(\\frac{ab}{4}\\right) d\\xi d\\eta\n$$\n\nThe problem specifies a decomposition of the stored energy density $W$ into volumetric and deviatoric parts:\n$$\nW = W_{vol} + W_{dev} = \\tfrac{1}{2}K\\big(\\operatorname{tr}\\epsilon\\big)^{2} + \\mu\\,\\epsilon_{\\text{dev}}:\\epsilon_{\\text{dev}}\n$$\nThis energy decomposition leads to a corresponding additive split of the constitutive matrix $D = D_{vol} + D_{dev}$. We derive these matrices for a 2D problem using Voigt notation with the strain vector $\\boldsymbol{\\epsilon} = [\\epsilon_{xx}, \\epsilon_{yy}, \\gamma_{xy}]^T$, where $\\gamma_{xy} = 2\\epsilon_{xy}$ is the engineering shear strain.\n\nThe volumetric energy term is $W_{vol} = \\frac{1}{2}K(\\epsilon_{xx}+\\epsilon_{yy})^2$. In the quadratic form $\\frac{1}{2}\\boldsymbol{\\epsilon}^T D_{vol} \\boldsymbol{\\epsilon}$, this corresponds to the volumetric constitutive matrix:\n$$\nD_{vol} = K \\begin{pmatrix} 1 & 1 & 0 \\\\ 1 & 1 & 0 \\\\ 0 & 0 & 0 \\end{pmatrix}\n$$\n\nThe deviatoric energy term is $W_{dev} = \\mu\\,\\epsilon_{\\text{dev}}:\\epsilon_{\\text{dev}}$. For a 2D strain state, the deviatoric strain tensor is $\\epsilon_{dev} = \\epsilon - \\tfrac{1}{2}(\\operatorname{tr}\\epsilon)\\mathbf{I}$, and the term $\\epsilon_{dev}:\\epsilon_{dev}$ becomes $\\frac{1}{2}(\\epsilon_{xx}-\\epsilon_{yy})^2 + \\frac{1}{2}\\gamma_{xy}^2$. Thus, $W_{dev} = \\frac{\\mu}{2}\\left((\\epsilon_{xx}-\\epsilon_{yy})^2 + \\gamma_{xy}^2\\right)$. In the quadratic form $\\frac{1}{2}\\boldsymbol{\\epsilon}^T D_{dev} \\boldsymbol{\\epsilon}$, this corresponds to the deviatoric constitutive matrix:\n$$\nD_{dev} = \\mu \\begin{pmatrix} 1 & -1 & 0 \\\\ -1 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix}\n$$\nWith the constitutive matrix split, the stiffness matrix is also split:\n$$\nk^e = k^e_{vol} + k^e_{dev} = \\frac{ab}{4} \\int_{-1}^{1} \\int_{-1}^{1} B^T D_{vol} B \\, d\\xi d\\eta + \\frac{ab}{4} \\int_{-1}^{1} \\int_{-1}^{1} B^T D_{dev} B \\, d\\xi d\\eta\n$$\n\nThe Selective Reduced Integration (SRI) method evaluates these two integrals using different numerical quadrature rules.\n1.  The volumetric part, $k^e_{vol}$, is integrated using a one-point Gauss quadrature rule. The single quadrature point is $(\\xi_v, \\eta_v) = (0,0)$ with a weight of $w_v = 4$. The integral is approximated as:\n$$\nk^e_{vol} \\approx \\frac{ab}{4} \\left( w_v \\cdot B^T(0,0) D_{vol} B(0,0) \\right) = \\frac{ab}{4} \\left( 4 \\cdot B^T(0,0) D_{vol} B(0,0) \\right) = ab B^T(0,0) D_{vol} B(0,0)\n$$\n\n2.  The deviatoric part, $k^e_{dev}$, is integrated using a $2\\times2$ Gauss quadrature rule. This involves four quadrature points, denoted as $(\\xi_j, \\eta_j)$ for $j=1, \\dots, 4$, which are $(\\pm 1/\\sqrt{3}, \\pm 1/\\sqrt{3})$. Each point has a weight of $w_j=1$. The integral is approximated by a sum over these four points:\n$$\nk^e_{dev} \\approx \\frac{ab}{4} \\sum_{j=1}^{4} \\left( w_j \\cdot B^T(\\xi_j, \\eta_j) D_{dev} B(\\xi_j, \\eta_j) \\right) = \\frac{ab}{4} \\sum_{j=1}^{4} B^T(\\xi_j, \\eta_j) D_{dev} B(\\xi_j, \\eta_j)\n$$\n\nCombining the two parts gives the final expression for the SRI-computed element stiffness matrix. The question asks for this expression in terms of the given parameters and the matrix $B(\\xi, \\eta)$. We substitute the derived matrices $D_{vol}$ and $D_{dev}$ into the expressions for $k^e_{vol}$ and $k^e_{dev}$. Let the set of four deviatoric quadrature points be $\\mathcal{Q}_{dev} = \\{(\\pm 1/\\sqrt{3}, \\pm 1/\\sqrt{3})\\}$. The final stiffness matrix is:\n$$\nk^e_{SRI} = ab \\, B^T(0,0) D_{vol} B(0,0) + \\frac{ab}{4} \\sum_{(\\xi,\\eta) \\in \\mathcal{Q}_{dev}} B^T(\\xi,\\eta) D_{dev} B(\\xi,\\eta)\n$$\nSubstituting the explicit forms of $D_{vol}$ and $D_{dev}$:\n$$\nk^e_{SRI} = ab \\cdot K \\cdot B^T(0,0) \\begin{pmatrix} 1 & 1 & 0 \\\\ 1 & 1 & 0 \\\\ 0 & 0 & 0 \\end{pmatrix} B(0,0) + \\frac{ab}{4} \\cdot \\mu \\sum_{j=1}^{4} B^T(\\xi_j, \\eta_j) \\begin{pmatrix} 1 & -1 & 0 \\\\ -1 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} B(\\xi_j, \\eta_j)\n$$\nwhere the summation is over the four points $(\\xi_j, \\eta_j) = (\\pm 1/\\sqrt{3}, \\pm 1/\\sqrt{3})$. This is the single analytic expression for the stiffness matrix computed with the specified SRI scheme.",
            "answer": "$$\n\\boxed{ab K B^T(0,0) \\begin{pmatrix} 1 & 1 & 0 \\\\ 1 & 1 & 0 \\\\ 0 & 0 & 0 \\end{pmatrix} B(0,0) + \\frac{ab\\mu}{4} \\sum_{j=1}^{4} B^T(\\xi_j, \\eta_j) \\begin{pmatrix} 1 & -1 & 0 \\\\ -1 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} B(\\xi_j, \\eta_j) \\quad \\text{where} \\quad (\\xi_j, \\eta_j) \\in \\{(\\pm\\frac{1}{\\sqrt{3}}, \\pm\\frac{1}{\\sqrt{3}})\\}}\n$$"
        },
        {
            "introduction": "With the theoretical formulation in hand, the next step is to witness its practical effect. This coding exercise challenges you to implement both full integration and Selective Reduced Integration to solve a boundary value problem known to exhibit severe volumetric locking . By comparing the results against a high-fidelity reference, you will gain a tangible, quantitative understanding of how SRI dramatically improves solution accuracy for nearly incompressible materials.",
            "id": "2592773",
            "problem": "Consider the two-dimensional small-strain, linear-elasticity boundary-value problem in plane strain on a rectangular domain $\\Omega = [0,W] \\times [0,H]$ with boundary $\\partial \\Omega = \\Gamma_u \\cup \\Gamma_t$, where the bottom edge $\\Gamma_u = \\{(x,0): 0 \\le x \\le W\\}$ is fixed with prescribed zero displacement, and the top edge $\\Gamma_t = \\{(x,H): 0 \\le x \\le W\\}$ is subjected to a uniform surface traction of magnitude $p$ acting in the negative $y$-direction. The left and right edges are traction-free. The governing weak form derived from the principle of virtual work is\n$$\n\\int_{\\Omega} \\boldsymbol{\\varepsilon}(\\boldsymbol{u}) : \\mathbf{C} : \\boldsymbol{\\varepsilon}(\\boldsymbol{v}) \\, \\mathrm{d}\\Omega = \\int_{\\Gamma_t} \\boldsymbol{t} \\cdot \\boldsymbol{v} \\, \\mathrm{d}\\Gamma\n$$\nfor all admissible virtual displacements $\\boldsymbol{v}$ vanishing on $\\Gamma_u$, where $\\boldsymbol{u} = (u_x,u_y)$ is the displacement field, $\\boldsymbol{\\varepsilon}(\\boldsymbol{u}) = \\tfrac{1}{2}(\\nabla \\boldsymbol{u} + \\nabla \\boldsymbol{u}^\\top)$ is the small-strain tensor, $\\boldsymbol{t} = (0,-p)$ is the traction on $\\Gamma_t$, and $\\mathbf{C}$ is the fourth-order elasticity tensor for an isotropic solid in plane strain characterized by Young’s modulus $E$ and Poisson’s ratio $\\nu$. In Voigt notation with strain vector $\\boldsymbol{\\epsilon} = [\\epsilon_{xx}, \\epsilon_{yy}, \\gamma_{xy}]^\\top$, where $\\gamma_{xy} = 2 \\epsilon_{xy}$, the stress-strain relation is $\\boldsymbol{\\sigma} = \\mathbf{D} \\, \\boldsymbol{\\epsilon}$ with\n$$\n\\mathbf{D} = \n\\begin{bmatrix}\n\\lambda + 2\\mu & \\lambda & 0 \\\\\n\\lambda & \\lambda + 2\\mu & 0 \\\\\n0 & 0 & \\mu\n\\end{bmatrix},\n\\quad\n\\mu = \\frac{E}{2(1+\\nu)}, \n\\quad\n\\lambda = \\frac{E \\nu}{(1+\\nu)(1-2\\nu)},\n$$\nand the bulk modulus $\\kappa = \\lambda + \\tfrac{2}{3}\\mu$.\n\nUse isoparametric bilinear quadrilateral (Q4) finite elements with nodal shape functions\n$$\nN_1 = \\tfrac{1}{4}(1-\\xi)(1-\\eta), \\quad\nN_2 = \\tfrac{1}{4}(1+\\xi)(1-\\eta), \\quad\nN_3 = \\tfrac{1}{4}(1+\\xi)(1+\\eta), \\quad\nN_4 = \\tfrac{1}{4}(1-\\xi)(1+\\eta),\n$$\ndefined on the parent domain $(\\xi,\\eta) \\in [-1,1]^2$, and the standard isoparametric mapping to the physical element. Let $\\mathbf{B}(\\xi,\\eta)$ denote the $3\\times 8$ strain-displacement matrix such that $\\boldsymbol{\\epsilon} = \\mathbf{B} \\, \\mathbf{u}_e$ for element nodal displacement vector $\\mathbf{u}_e \\in \\mathbb{R}^8$.\n\nYou must implement two element integration strategies:\n\n1. Full integration (FI): assemble the element stiffness matrix\n$$\n\\mathbf{K}_e^{\\mathrm{FI}} = \\int_{\\Omega_e} \\mathbf{B}^\\top \\mathbf{D} \\, \\mathbf{B} \\, \\mathrm{d}\\Omega\n$$\nusing the tensor-product two-point Gaussian quadrature in each parent coordinate (i.e., $2 \\times 2$ Gauss points) with exact edge loads from two-point Gauss quadrature on the top edge.\n\n2. Selective Reduced Integration (SRI): split the constitutive operator into deviatoric and volumetric parts,\n$$\n\\mathbf{D} = \\mathbf{D}_{\\mathrm{dev}} + \\mathbf{D}_{\\mathrm{vol}},\n\\quad\n\\mathbf{D}_{\\mathrm{vol}} = \\kappa \\, \\mathbf{P}^\\top \\mathbf{P},\n\\quad\n\\mathbf{P} = \n\\begin{bmatrix}\n1 & 1 & 0\n\\end{bmatrix},\n\\quad\n\\mathbf{D}_{\\mathrm{dev}} = \\mathbf{D} - \\mathbf{D}_{\\mathrm{vol}},\n$$\nand assemble\n$$\n\\mathbf{K}_e^{\\mathrm{SRI}} = \\underbrace{\\int_{\\Omega_e} \\mathbf{B}^\\top \\mathbf{D}_{\\mathrm{dev}} \\, \\mathbf{B} \\, \\mathrm{d}\\Omega}_{\\text{integrated with } 2\\times 2 \\text{ Gauss}}\n+\n\\underbrace{\\int_{\\Omega_e} (\\mathbf{P}\\mathbf{B})^\\top \\kappa \\, (\\mathbf{P}\\mathbf{B}) \\, \\mathrm{d}\\Omega}_{\\text{integrated with } 1\\times 1 \\text{ Gauss at } (\\xi,\\eta)=(0,0)}.\n$$\nThe surface traction vector on the top edges should always be integrated exactly using two-point Gaussian quadrature along the edge.\n\nConstruct a structured mesh of $n_x \\times n_y$ Q4 elements over the rectangle $\\Omega$, enforce the homogeneous Dirichlet boundary condition $\\boldsymbol{u} = \\boldsymbol{0}$ on the bottom edge $\\Gamma_u$, assemble the global linear system, and solve for the nodal displacement vector. Let $\\bar{u}_y$ denote the average vertical displacement on the top edge, defined by\n$$\n\\bar{u}_y = \\frac{1}{|\\mathcal{N}_t|}\\sum_{a \\in \\mathcal{N}_t} (u_y)_a,\n$$\nwhere $\\mathcal{N}_t$ is the set of nodes lying on $y=H$. As a high-fidelity reference, for each test case defined below, compute $\\bar{u}_y^{\\mathrm{ref}}$ using the SRI method on a fine mesh with $N_x^{\\mathrm{ref}} = 32$ elements along the width and $N_y^{\\mathrm{ref}} = \\max\\{2, \\mathrm{round}(32 \\, H/W)\\}$ elements along the height.\n\nDefine the absolute error in the scalar response for a method $m \\in \\{\\mathrm{FI}, \\mathrm{SRI}\\}$ by\n$$\ne_m = \\left| \\bar{u}_y^{(m)} - \\bar{u}_y^{\\mathrm{ref}} \\right|.\n$$\nDefine the locking error reduction factor (dimensionless) of SRI relative to full integration as\n$$\n\\rho = \\frac{e_{\\mathrm{FI}} - e_{\\mathrm{SRI}}}{e_{\\mathrm{FI}}}.\n$$\nA positive value of $\\rho$ indicates that selective reduced integration decreases the locking-induced error in the computed response.\n\nImplement a program that computes $\\rho$ for the following test suite of four cases. All physical quantities must be handled in the International System of Units (SI), namely lengths in meters (m), stresses (including $E$ and $p$) in Pascals (Pa), and displacements in meters (m). No angles are used.\n\nTest suite:\n- Case 1 (nearly incompressible, moderate mesh): $W = 1\\,\\mathrm{m}$, $H = 1\\,\\mathrm{m}$, $E = 1000\\,\\mathrm{Pa}$, $\\nu = 0.4999$, $p = 1\\,\\mathrm{Pa}$, $n_x = 2$, $n_y = 2$.\n- Case 2 (nearly incompressible, very coarse mesh): $W = 1\\,\\mathrm{m}$, $H = 1\\,\\mathrm{m}$, $E = 1000\\,\\mathrm{Pa}$, $\\nu = 0.4999$, $p = 1\\,\\mathrm{Pa}$, $n_x = 1$, $n_y = 1$.\n- Case 3 (nearly incompressible, rectangular domain): $W = 2\\,\\mathrm{m}$, $H = 1\\,\\mathrm{m}$, $E = 1000\\,\\mathrm{Pa}$, $\\nu = 0.4999$, $p = 1\\,\\mathrm{Pa}$, $n_x = 4$, $n_y = 2$.\n- Case 4 (compressible, moderate mesh): $W = 1\\,\\mathrm{m}$, $H = 1\\,\\mathrm{m}$, $E = 1000\\,\\mathrm{Pa}$, $\\nu = 0.3$, $p = 1\\,\\mathrm{Pa}$, $n_x = 2$, $n_y = 2$.\n\nYour program should produce a single line of output containing the results for the four cases as a comma-separated list enclosed in square brackets, in the order of the cases above. Each entry must be a real number (float) equal to the value of $\\rho$ for that case, rounded to six decimal places. For example, an output line should look like: \"[0.123456,0.234567,0.345678,0.456789]\".",
            "solution": "We derive the computational procedure from first principles. The starting point is the weak form of linear elasticity in plane strain:\n$$\n\\int_{\\Omega} \\boldsymbol{\\varepsilon}(\\boldsymbol{u}) : \\mathbf{C} : \\boldsymbol{\\varepsilon}(\\boldsymbol{v}) \\, \\mathrm{d}\\Omega = \\int_{\\Gamma_t} \\boldsymbol{t} \\cdot \\boldsymbol{v} \\, \\mathrm{d}\\Gamma.\n$$\nDiscretization with isoparametric bilinear quadrilateral (Q4) elements uses the interpolation\n$$\n\\boldsymbol{u}(x,y) \\approx \\sum_{a=1}^{4} N_a(\\xi,\\eta) \\, \\boldsymbol{u}_a, \n\\quad \n\\boldsymbol{\\epsilon} = \\mathbf{B}(\\xi,\\eta)\\, \\mathbf{u}_e,\n$$\nwhere $(\\xi,\\eta)$ are the parent coordinates, $\\{N_a\\}$ are bilinear shape functions on $[-1,1]^2$, and $\\mathbf{B}$ maps nodal displacements to the Voigt strain vector $\\boldsymbol{\\epsilon} = [\\epsilon_{xx}, \\epsilon_{yy}, \\gamma_{xy}]^\\top$ with $\\gamma_{xy} = \\partial u_x/\\partial y + \\partial u_y/\\partial x$. The isoparametric mapping from parent to physical coordinates is $x(\\xi,\\eta)=\\sum_a N_a(\\xi,\\eta) x_a$, $y(\\xi,\\eta)=\\sum_a N_a(\\xi,\\eta) y_a$, with Jacobian $\\mathbf{J} = \\begin{bmatrix}\\partial x/\\partial \\xi & \\partial y/\\partial \\xi \\\\ \\partial x/\\partial \\eta & \\partial y/\\partial \\eta \\end{bmatrix}$. Gradients $\\partial N_a/\\partial x$ and $\\partial N_a/\\partial y$ follow from $\\begin{bmatrix}\\partial N_a/\\partial x & \\partial N_a/\\partial y \\end{bmatrix} = \\begin{bmatrix}\\partial N_a/\\partial \\xi & \\partial N_a/\\partial \\eta\\end{bmatrix}\\mathbf{J}^{-1}$. Then, with plane strain isotropic elasticity, the element stiffness matrix is\n$$\n\\mathbf{K}_e = \\int_{\\Omega_e} \\mathbf{B}^\\top \\mathbf{D}\\, \\mathbf{B} \\, \\mathrm{d}\\Omega,\n$$\nand the element nodal force from the top-edge traction is\n$$\n\\mathbf{f}_e^{\\Gamma} = \\int_{\\Gamma_{t,e}} \\mathbf{N}^\\top \\boldsymbol{t} \\, \\mathrm{d}\\Gamma,\n$$\nwhere $\\mathbf{N} = \\mathrm{diag}(N_1,N_1,N_2,N_2,N_3,N_3,N_4,N_4)$ maps vector-valued shape functions, and $\\Gamma_{t,e}$ is the part of the top boundary intersecting the element. The boundary integral over a straight edge is evaluated via one-dimensional Gaussian quadrature on the parent edge $(\\xi\\in[-1,1], \\eta = +1)$ with the correct edge Jacobian factor $\\| \\partial \\boldsymbol{x}/\\partial \\xi \\|$.\n\nFor numerical integration in the volume, full integration for Q4 elements uses two-point Gaussian quadrature in each parent direction: points $\\{\\pm 1/\\sqrt{3}\\}$ with weights $\\{1,1\\}$, leading to $2\\times 2$ points in the square. Reduced integration uses a single point $(\\xi,\\eta)=(0,0)$ with weight $4$ (the product of one-dimensional weights $\\{2\\}$). However, using reduced integration for the entire stiffness matrix generally causes rank deficiency (hourglassing). To mitigate volumetric locking — the artificial stiffening observed when $\\nu \\to 1/2$ (nearly incompressible) — a stable compromise is Selective Reduced Integration (SRI). SRI leverages the standard decomposition of the elastic energy density into deviatoric and volumetric parts:\n$$\nW = \\mu\\, \\boldsymbol{\\varepsilon}_{\\mathrm{dev}}:\\boldsymbol{\\varepsilon}_{\\mathrm{dev}} + \\frac{\\kappa}{2} (\\mathrm{tr}\\, \\boldsymbol{\\varepsilon})^2,\n$$\nwith shear modulus $\\mu$ and bulk modulus $\\kappa = \\lambda + \\tfrac{2}{3}\\mu$. In Voigt form restricted to in-plane components $(\\epsilon_{xx},\\epsilon_{yy},\\gamma_{xy})$, we approximate this split by\n$$\n\\mathbf{D}_{\\mathrm{vol}} = \\kappa \\, \\mathbf{P}^\\top \\mathbf{P}, \n\\quad \\mathbf{P} = \\begin{bmatrix}1 & 1 & 0\\end{bmatrix},\n\\quad\n\\mathbf{D}_{\\mathrm{dev}} = \\mathbf{D} - \\mathbf{D}_{\\mathrm{vol}}.\n$$\nThis choice retains the correct hydrostatic stiffness in the in-plane subspace while ensuring the deviatoric response is handled by $\\mathbf{D}_{\\mathrm{dev}}$. The SRI assembly then integrates the deviatoric part with $2\\times 2$ Gauss points and the volumetric part with a single Gauss point at $(\\xi,\\eta)=(0,0)$. This strategy avoids hourglass modes (because the deviatoric part is fully integrated) and alleviates volumetric locking (because the volumetric stiffness is integrated at reduced order, which softens the spurious constraints that arise under full integration when $\\nu$ is close to $1/2$).\n\nAlgorithmic design:\n1. Generate a structured mesh of $n_x \\times n_y$ Q4 elements over $[0,W]\\times[0,H]$ with nodal coordinates on a Cartesian grid. Each element connectivity follows the local node order: $(\\xi,\\eta)=(-1,-1)$ bottom-left, $(+1,-1)$ bottom-right, $(+1,+1)$ top-right, $(-1,+1)$ top-left.\n2. For each element, compute the element stiffness:\n   - Full Integration: $\\mathbf{K}_e^{\\mathrm{FI}} = \\sum_{i=1}^2 \\sum_{j=1}^2 \\mathbf{B}(\\xi_i,\\eta_j)^\\top \\mathbf{D} \\, \\mathbf{B}(\\xi_i,\\eta_j) \\, \\det\\mathbf{J}(\\xi_i,\\eta_j)$.\n   - SRI: $\\mathbf{K}_e^{\\mathrm{SRI}} = \\sum_{i=1}^2 \\sum_{j=1}^2 \\mathbf{B}^\\top \\mathbf{D}_{\\mathrm{dev}} \\mathbf{B} \\, \\det\\mathbf{J} + 4 \\, (\\mathbf{P}\\mathbf{B}(0,0))^\\top \\kappa \\, (\\mathbf{P}\\mathbf{B}(0,0)) \\, \\det\\mathbf{J}(0,0)$.\n   The factor $4$ in the volumetric term is the two-dimensional reduced Gauss weight corresponding to the area of the parent square.\n3. Assemble the global stiffness matrix in sparse Compressed Sparse Row (CSR) format by summing element contributions into the global degrees of freedom, where each node contributes two degrees of freedom $(u_x,u_y)$.\n4. Assemble the global load vector from the top-edge pressure by integrating each element edge lying on $y=H$ with two-point Gauss quadrature along the edge: $\\mathbf{f}_e^\\Gamma = \\sum_{k=1}^2 \\mathbf{N}^\\top(\\xi_k,\\eta=+1) \\, \\boldsymbol{t} \\, \\|\\partial \\boldsymbol{x}/\\partial \\xi\\| \\, w_k$.\n5. Impose homogeneous Dirichlet boundary conditions on the bottom edge $\\Gamma_u$ by extracting the free-degree-of-freedom submatrix and right-hand side and solving the reduced system. This is consistent with the weak form and avoids ill-conditioning from explicitly modifying rows and columns.\n6. Compute the scalar response $\\bar{u}_y$ as the average vertical displacement over all nodes with $y=H$.\n7. For each test case, compute the fine-mesh reference $\\bar{u}_y^{\\mathrm{ref}}$ using SRI with $N_x^{\\mathrm{ref}} = 32$ and $N_y^{\\mathrm{ref}} = \\max\\{2, \\mathrm{round}(32 \\, H/W)\\}$. Compute the absolute errors $e_{\\mathrm{FI}}$ and $e_{\\mathrm{SRI}}$, and finally the reduction factor $\\rho = (e_{\\mathrm{FI}} - e_{\\mathrm{SRI}})/e_{\\mathrm{FI}}$.\n8. Aggregate the four values of $\\rho$ corresponding to the test suite into a single list and print it on one line in the required format.\n\nWhy SRI reduces locking: As $\\nu \\to 1/2$, the Lamé parameter $\\lambda$ (and hence the bulk modulus $\\kappa$) grows without bound, which makes the volumetric part of the stiffness dominate under full integration, enforcing $\\mathrm{tr}\\, \\boldsymbol{\\epsilon} \\approx 0$ too strongly in a discrete sense and producing an overly stiff response (locking). By integrating the volumetric contribution at reduced order, SRI effectively reduces the discrete constraint intensity associated with the volumetric strain while preserving the deviatoric stiffness and stability. Consequently, for nearly incompressible materials, SRI typically yields a more compliant and accurate response on coarse meshes compared to full integration. For moderately compressible materials (e.g., $\\nu = 0.3$), both schemes give nearly identical results because volumetric stiffness does not dominate.\n\nThe program below implements this procedure, solves the test suite, and prints the four reduction factors as a single comma-separated list rounded to six decimal places, as required.",
            "answer": "```python\nimport numpy as np\nfrom scipy.sparse import coo_matrix, csr_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef constitutive_plane_strain(E, nu):\n    lam = E * nu / ((1.0 + nu) * (1.0 - 2.0 * nu))\n    mu = E / (2.0 * (1.0 + nu))\n    D = np.array([[lam + 2.0 * mu, lam, 0.0],\n                  [lam, lam + 2.0 * mu, 0.0],\n                  [0.0, 0.0, mu]], dtype=float)\n    kappa = lam + 2.0 * mu / 3.0\n    return D, lam, mu, kappa\n\ndef shape_Q4(ksi, eta):\n    N = np.array([\n        0.25 * (1 - ksi) * (1 - eta),\n        0.25 * (1 + ksi) * (1 - eta),\n        0.25 * (1 + ksi) * (1 + eta),\n        0.25 * (1 - ksi) * (1 + eta)\n    ], dtype=float)\n    dN_dksi = 0.25 * np.array([\n        -(1 - eta),\n        (1 - eta),\n        (1 + eta),\n        -(1 + eta)\n    ], dtype=float)\n    dN_deta = 0.25 * np.array([\n        -(1 - ksi),\n        -(1 + ksi),\n        (1 + ksi),\n        (1 - ksi)\n    ], dtype=float)\n    return N, dN_dksi, dN_deta\n\ndef B_matrix_Q4(xe, ksi, eta):\n    # xe: 4x2 nodal coordinates of the element (in order 1..4)\n    N, dN_dksi, dN_deta = shape_Q4(ksi, eta)\n    J = np.zeros((2, 2), dtype=float)\n    # Compute Jacobian J = [dx/dksi dy/dksi; dx/deta dy/deta]\n    J[0, 0] = np.dot(dN_dksi, xe[:, 0])\n    J[0, 1] = np.dot(dN_dksi, xe[:, 1])\n    J[1, 0] = np.dot(dN_deta, xe[:, 0])\n    J[1, 1] = np.dot(dN_deta, xe[:, 1])\n    detJ = np.linalg.det(J)\n    invJ = np.linalg.inv(J)\n    # Gradients with respect to x,y: grads[i,0]=dNi/dx, grads[i,1]=dNi/dy\n    grads = np.zeros((4, 2), dtype=float)\n    for i in range(4):\n        dN_parent = np.array([dN_dksi[i], dN_deta[i]])\n        dN_xy = invJ @ dN_parent\n        grads[i, 0] = dN_xy[0]\n        grads[i, 1] = dN_xy[1]\n    # Build B matrix (3x8) for plane strain with Voigt [exx, eyy, gxy]\n    B = np.zeros((3, 8), dtype=float)\n    for i in range(4):\n        Bi = np.array([\n            [grads[i, 0], 0.0],\n            [0.0, grads[i, 1]],\n            [grads[i, 1], grads[i, 0]]\n        ], dtype=float)\n        B[:, 2 * i:2 * i + 2] = Bi\n    return B, detJ\n\ndef element_stiffness_FI(xe, D):\n    # 2x2 Gauss integration\n    gp = 1.0 / np.sqrt(3.0)\n    ksi_list = [-gp, gp]\n    eta_list = [-gp, gp]\n    Ke = np.zeros((8, 8), dtype=float)\n    for ksi in ksi_list:\n        for eta in eta_list:\n            B, detJ = B_matrix_Q4(xe, ksi, eta)\n            Ke += (B.T @ D @ B) * detJ\n    return Ke\n\ndef element_stiffness_SRI(xe, D, kappa):\n    # D_dev = D - kappa * P^T P, with P = [1,1,0]\n    P = np.array([[1.0, 1.0, 0.0]], dtype=float)\n    D_vol = kappa * (P.T @ P)\n    D_dev = D - D_vol\n    # Deviatoric part with 2x2 Gauss\n    gp = 1.0 / np.sqrt(3.0)\n    ksi_list = [-gp, gp]\n    eta_list = [-gp, gp]\n    Ke = np.zeros((8, 8), dtype=float)\n    for ksi in ksi_list:\n        for eta in eta_list:\n            B, detJ = B_matrix_Q4(xe, ksi, eta)\n            Ke += (B.T @ D_dev @ B) * detJ\n    # Volumetric part with 1x1 Gauss at (0,0), weight = 4\n    Bc, detJc = B_matrix_Q4(xe, 0.0, 0.0)\n    Bvol = P @ Bc  # shape (1,8)\n    Ke += (Bvol.T @ (kappa * Bvol)) * detJc * 4.0\n    return Ke\n\ndef edge_load_top_Q4(xe, p):\n    # Compute consistent nodal load vector (8,) for top edge (eta=+1) traction t = (0,-p)\n    # 2-point Gauss along the edge\n    gp = 1.0 / np.sqrt(3.0)\n    s_list = [-gp, gp]\n    w_list = [1.0, 1.0]\n    fe = np.zeros(8, dtype=float)\n    eta = 1.0\n    for s, w in zip(s_list, w_list):\n        N, dN_dksi, dN_deta = shape_Q4(s, eta)\n        # Edge tangent vector dx/dksi at eta=+1\n        dx_dksi = np.dot(dN_dksi, xe[:, 0])\n        dy_dksi = np.dot(dN_dksi, xe[:, 1])\n        J_edge = np.sqrt(dx_dksi ** 2 + dy_dksi ** 2)\n        # Assemble contributions: only vertical traction\n        t = np.array([0.0, -p], dtype=float)\n        for i in range(4):\n            Ni = N[i]\n            fe[2 * i:2 * i + 2] += Ni * t * J_edge * w\n    return fe\n\ndef generate_mesh(W, H, nx, ny):\n    xs = np.linspace(0.0, W, nx + 1)\n    ys = np.linspace(0.0, H, ny + 1)\n    coords = np.array([(x, y) for y in ys for x in xs], dtype=float)\n    # Node numbering: row-major (x fastest), node index = j*(nx+1)+i\n    conn = []\n    for j in range(ny):\n        for i in range(nx):\n            n1 = j * (nx + 1) + i\n            n2 = n1 + 1\n            n3 = n1 + (nx + 1) + 1\n            n4 = n1 + (nx + 1)\n            conn.append([n1, n2, n3, n4])\n    conn = np.array(conn, dtype=int)\n    return coords, conn\n\ndef assemble_system(W, H, nx, ny, E, nu, p, method):\n    coords, conn = generate_mesh(W, H, nx, ny)\n    nnode = coords.shape[0]\n    ndof = 2 * nnode\n    D, lam, mu, kappa = constitutive_plane_strain(E, nu)\n\n    rows = []\n    cols = []\n    data = []\n    f = np.zeros(ndof, dtype=float)\n\n    # Assemble stiffness and traction\n    for e, nodes in enumerate(conn):\n        xe = coords[nodes, :]\n        if method == 'FI':\n            Ke = element_stiffness_FI(xe, D)\n        elif method == 'SRI':\n            Ke = element_stiffness_SRI(xe, D, kappa)\n        else:\n            raise ValueError(\"Unknown method\")\n        # Global dof indices\n        dofs = np.zeros(8, dtype=int)\n        for a_local, a in enumerate(nodes):\n            dofs[2 * a_local] = 2 * a\n            dofs[2 * a_local + 1] = 2 * a + 1\n        # Add to global COO\n        for i_local in range(8):\n            gi = dofs[i_local]\n            for j_local in range(8):\n                gj = dofs[j_local]\n                rows.append(gi)\n                cols.append(gj)\n                data.append(Ke[i_local, j_local])\n\n        # Top edge load if this element has its top edge on y=H\n        # Local top edge nodes are 3 (index 2) and 4 (index 3)\n        y3 = xe[2, 1]\n        y4 = xe[3, 1]\n        if np.isclose(y3, H) and np.isclose(y4, H):\n            fe = edge_load_top_Q4(xe, p)\n            for a_local, a in enumerate(nodes):\n                f[2 * a] += fe[2 * a_local]\n                f[2 * a + 1] += fe[2 * a_local + 1]\n\n    K = coo_matrix((data, (rows, cols)), shape=(ndof, ndof)).tocsr()\n\n    # Apply Dirichlet BCs on bottom edge: y=0, fix both u and v\n    bottom_nodes = np.where(np.isclose(coords[:, 1], 0.0))[0]\n    fixed_dofs = []\n    for n in bottom_nodes:\n        fixed_dofs.append(2 * n)     # u_x\n        fixed_dofs.append(2 * n + 1) # u_y\n    fixed_dofs = np.array(sorted(set(fixed_dofs)), dtype=int)\n\n    all_dofs = np.arange(ndof, dtype=int)\n    free_dofs = np.setdiff1d(all_dofs, fixed_dofs, assume_unique=False)\n\n    K_ff = K[free_dofs, :][:, free_dofs]\n    f_f = f[free_dofs]\n\n    u = np.zeros(ndof, dtype=float)\n    if K_ff.shape[0] > 0:\n        u_f = spsolve(K_ff, f_f)\n        u[free_dofs] = u_f\n\n    # Average vertical displacement on top edge\n    top_nodes = np.where(np.isclose(coords[:, 1], H))[0]\n    v_dofs = 2 * top_nodes + 1\n    avg_v = float(np.mean(u[v_dofs])) if v_dofs.size > 0 else 0.0\n    return avg_v\n\ndef compute_reduction_for_case(W, H, nx, ny, E, nu, p):\n    # Reference using SRI on fine mesh\n    Nx_ref = 32\n    Ny_ref = int(np.round(32.0 * H / W))\n    Ny_ref = max(2, Ny_ref)\n    uref = assemble_system(W, H, Nx_ref, Ny_ref, E, nu, p, method='SRI')\n\n    # Coarse solutions\n    u_fi = assemble_system(W, H, nx, ny, E, nu, p, method='FI')\n    u_sri = assemble_system(W, H, nx, ny, E, nu, p, method='SRI')\n\n    e_fi = abs(u_fi - uref)\n    e_sri = abs(u_sri - uref)\n    rho = (e_fi - e_sri) / e_fi if e_fi != 0.0 else 0.0\n    return rho\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Parameters: (W, H, nx, ny, E, nu, p)\n    test_cases = [\n        (1.0, 1.0, 2, 2, 1000.0, 0.4999, 1.0),\n        (1.0, 1.0, 1, 1, 1000.0, 0.4999, 1.0),\n        (2.0, 1.0, 4, 2, 1000.0, 0.4999, 1.0),\n        (1.0, 1.0, 2, 2, 1000.0, 0.3, 1.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        W, H, nx, ny, E, nu, p = case\n        rho = compute_reduction_for_case(W, H, nx, ny, E, nu, p)\n        # Round to six decimal places\n        results.append(f\"{rho:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "Standard SRI is a powerful but static tool; a more sophisticated approach would adapt the level of integration to the local needs of the solution. This advanced practice guides you in designing such a method, where a solution-dependent indicator drives the blending between full and reduced integration for the volumetric term . This exercise introduces the modern concept of adaptive numerical methods, enhancing both the robustness and accuracy of your simulations, especially in problems with heterogeneous materials.",
            "id": "3599208",
            "problem": "Consider small-strain, static, linear elasticity of a two-dimensional domain with displacement field $u=(u_x,u_y)$, where the governing strong form equilibrium is $\\nabla\\cdot\\sigma=0$ with no body forces, and the linear strain is $\\varepsilon=\\nabla^{\\mathrm{s}}u$, where $\\nabla^{\\mathrm{s}}$ denotes the symmetric gradient. The constitutive relation under plane strain is $\\sigma=\\mathbb{C}:\\varepsilon$ with isotropic, spatially varying material defined by Young’s modulus $E>0$ and Poisson’s ratio $\\nu(x,y)\\in(-1/2,1/2)$, where the Lame parameters are $\\lambda=E\\nu/((1+\\nu)(1-2\\nu))$ and $\\mu=E/(2(1+\\nu))$. The linearization of the principle of virtual work yields the bilinear form $a(u,v)=\\int_{\\Omega}\\varepsilon(v):\\mathbb{C}:\\varepsilon(u)\\,\\mathrm{d}\\Omega$ and the discrete finite element system $K d = f$ assembled over elements.\n\nFor bilinear quadrilateral elements in plane strain, let the in-plane Voigt notation be $[\\varepsilon_{xx},\\varepsilon_{yy},\\gamma_{xy}]^{\\top}$ with $\\gamma_{xy}=2\\varepsilon_{xy}$. Using the Lame-parameter form, the constitutive matrix can be additively split into a deviatoric part and a volumetric part $\\mathbb{C}=\\mathbb{C}_{\\mathrm{dev}}+\\mathbb{C}_{\\mathrm{vol}}$ such that, in Voigt notation,\n$$\n\\mathbb{C}_{\\mathrm{dev}}=\\begin{bmatrix}2\\mu&0&0\\\\0&2\\mu&0\\\\0&0&\\mu\\end{bmatrix},\\quad\n\\mathbb{C}_{\\mathrm{vol}}=\\lambda\\begin{bmatrix}1&1&0\\\\1&1&0\\\\0&0&0\\end{bmatrix}.\n$$\nSelective Reduced Integration (SRI) is a technique to alleviate volumetric locking by under-integrating the volumetric part while fully integrating the deviatoric part. In this task, design an adaptive SRI strategy where the degree of under-integration of the volumetric part per element is driven by a local indicator of volumetric strain $\\epsilon_{\\mathrm{vol}}=\\nabla\\cdot u=\\varepsilon_{xx}+\\varepsilon_{yy}$. Specifically, for each element $e$, define a blending parameter $\\alpha_e\\in[0,1]$ that weights the volumetric stiffness assembled using full Gauss integration versus reduced single-point integration, with $\\alpha_e$ increasing with the magnitude of a local indicator of $|\\epsilon_{\\mathrm{vol}}|$ and $\\alpha_e\\rightarrow 0$ for nearly incompressible response (small $|\\epsilon_{\\mathrm{vol}}|$). Use a fixed-point iteration: start with $\\alpha_e=1$, solve for $u$, update $\\alpha_e$ from the current $u$, rebuild, and resolve until convergence or a maximum number of iterations is reached.\n\nImplement the following:\n\n- Domain and discretization: a unit square $\\Omega=[0,1]\\times[0,1]$, thickness $t=1$, discretized by a structured mesh of bilinear quadrilateral elements of size $n_x\\times n_y$ with $n_x=n_y=8$.\n\n- Kinematics and element matrices: use standard bilinear shape functions in the parent space $(\\xi,\\eta)\\in[-1,1]^2$, compute the strain-displacement matrix $B$ via isoparametric mapping, and assemble the global stiffness matrix $K$ with\n$$\nK_e=\\underbrace{\\int_{\\Omega_e}B^{\\top}\\mathbb{C}_{\\mathrm{dev}}B\\,\\mathrm{d}\\Omega}_{\\text{full }2\\times 2\\text{ Gauss}}+\\underbrace{\\alpha_e\\int_{\\Omega_e}B^{\\top}\\mathbb{C}_{\\mathrm{vol}}B\\,\\mathrm{d}\\Omega}_{\\text{full }2\\times 2\\text{ Gauss}}+\\underbrace{(1-\\alpha_e)\\int_{\\Omega_e}B^{\\top}\\mathbb{C}_{\\mathrm{vol}}B\\,\\mathrm{d}\\Omega}_{\\text{reduced }1\\times 1\\text{ Gauss}}.\n$$\n\n- Boundary conditions: impose a simple shear by fixing the bottom edge $y=0$ as $u_x=0$, $u_y=0$, and imposing a horizontal displacement $u_x=\\gamma$ and $u_y=0$ on the top edge $y=1$, with $\\gamma=0.01$. The left and right edges are traction-free.\n\n- Adaptive indicator and update: after each solve, compute the element-wise average volumetric strain magnitude\n$$\n\\bar{\\epsilon}_{\\mathrm{vol},e}=\\frac{1}{A_e}\\int_{\\Omega_e}|\\varepsilon_{xx}+\\varepsilon_{yy}|\\,\\mathrm{d}\\Omega,\n$$\nand update $\\alpha_e$ via a monotone mapping\n$$\n\\alpha_e=\\min\\left(1,\\left(\\frac{\\bar{\\epsilon}_{\\mathrm{vol},e}}{\\epsilon_0}\\right)^{\\beta}\\right),\n$$\nwith $\\epsilon_0=10^{-4}$ and $\\beta=1/2$.\n\n- Poisson’s ratio fields: set $E=10^3$ uniformly and define three test cases with spatially varying $\\nu(x,y)$:\n  1. Heterogeneous patch: $\\nu(x,y)=0.499$ for $x<0.5$ and $\\nu(x,y)=0.3$ for $x\\ge 0.5$.\n  2. Uniform moderate: $\\nu(x,y)=0.3$ for all $(x,y)\\in\\Omega$.\n  3. Uniform nearly incompressible: $\\nu(x,y)=0.4999$ for all $(x,y)\\in\\Omega$.\n\n- Stopping criterion: iterate the adaptive update until $\\max_e|\\alpha_e^{(k)}-\\alpha_e^{(k-1)}|<10^{-3}$ or a maximum of $5$ iterations, whichever occurs first.\n\n- Robustness metric: for each test case, after convergence, compute the global $L^2$ norm of volumetric strain\n$$\n\\left\\|\\epsilon_{\\mathrm{vol}}\\right\\|_{L^2(\\Omega)}=\\left(\\int_{\\Omega}(\\varepsilon_{xx}+\\varepsilon_{yy})^2\\,\\mathrm{d}\\Omega\\right)^{1/2},\n$$\napproximated by $2\\times 2$ Gauss quadrature over elements.\n\nYour program must implement the above algorithm and produce a single line of output containing the three $L^2$ norms for the test cases $1$, $2$, and $3$ as a comma-separated list enclosed in square brackets, for example $[r_1,r_2,r_3]$. The norms are dimensionless because $\\epsilon_{\\mathrm{vol}}$ is dimensionless. No external input is required, and the code must run as is. The final outputs $r_1$, $r_2$, and $r_3$ must be floating-point numbers computed by the program.\n\nTest Suite:\n\n- Case $1$ (heterogeneous patch): $\\nu(x,y)=0.499$ for $x<0.5$, $\\nu(x,y)=0.3$ otherwise; expect adaptive $\\alpha_e$ to be smaller in the left half.\n- Case $2$ (uniform moderate): $\\nu(x,y)=0.3$; expect $\\alpha_e$ to stay near $1$.\n- Case $3$ (uniform nearly incompressible): $\\nu(x,y)=0.4999$; expect $\\alpha_e$ to drop significantly toward $0$.\n\nFinal Output Format:\n\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,r_3]$).",
            "solution": "The task is to implement a finite element method (FEM) for a 2D linear elasticity problem in plane strain, incorporating an adaptive selective reduced integration (SRI) scheme to mitigate volumetric locking. The solution proceeds by first discretizing the domain, then iteratively assembling and solving the linear system while updating the integration scheme based on the local volumetric strain.\n\n**1. Discretization and Kinematics**\nThe domain $\\Omega=[0,1]\\times[0,1]$ is discretized into an $8 \\times 8$ structured mesh of bilinear quadrilateral elements. Each node has two degrees of freedom (DOFs), $u_x$ and $u_y$. The displacement field within an element is interpolated from nodal displacements $d_e$ using bilinear shape functions $N_i(\\xi, \\eta)$:\n$$ u(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) \\begin{pmatrix} u_{x,i} \\\\ u_{y,i} \\end{pmatrix} $$\nwhere $(\\xi, \\eta) \\in [-1,1]^2$ are the parent coordinates.\nThe strain-displacement relationship, $\\varepsilon = \\nabla^s u$, is expressed in matrix form as $\\varepsilon = B d_e$, where $B$ is the strain-displacement matrix. For a bilinear element, the components of $B$ depend on the derivatives of shape functions with respect to the physical coordinates $(x,y)$. These are obtained using the chain rule and the Jacobian of the isoparametric mapping from parent to physical coordinates:\n$$ J = \\frac{\\partial(x,y)}{\\partial(\\xi,\\eta)} = \\begin{bmatrix} \\partial x/\\partial \\xi & \\partial y/\\partial \\xi \\\\ \\partial x/\\partial \\eta & \\partial y/\\partial \\eta \\end{bmatrix} $$\nThe derivatives are then $\\begin{pmatrix} \\partial N_i/\\partial x \\\\ \\partial N_i/\\partial y \\end{pmatrix} = J^{-1} \\begin{pmatrix} \\partial N_i/\\partial \\xi \\\\ \\partial N_i/\\partial \\eta \\end{pmatrix}$. The $B$ matrix, of size $3 \\times 8$, for Voigt strain $[\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}]^T$ is assembled from these derivatives for all four nodes of the element.\n\n**2. Element Stiffness Matrix and Adaptive SRI**\nThe element stiffness matrix $K_e$ is computed by integrating the weak form of the equilibrium equation over the element domain $\\Omega_e$. The integral is approximated numerically using Gauss quadrature.\n$$ K_e = \\int_{\\Omega_e} B^T \\mathbb{C} B \\, d\\Omega = \\int_{-1}^1 \\int_{-1}^1 B^T \\mathbb{C} B \\det(J) \\, d\\xi d\\eta \\approx \\sum_{gp} w_{gp} (B^T \\mathbb{C} B \\det(J))|_{gp} $$\nThe core of the problem is the adaptive SRI scheme. The constitutive matrix $\\mathbb{C}$ is split into deviatoric ($\\mathbb{C}_{\\mathrm{dev}}$) and volumetric ($\\mathbb{C}_{\\mathrm{vol}}$) parts. The deviatoric part, associated with shape change, is always fully integrated using a $2 \\times 2$ Gauss quadrature rule, which is sufficient for bilinear elements. The volumetric part, associated with volume change, is integrated using a blend of full ($2 \\times 2$) and reduced (one-point) integration. The element stiffness is:\n$$ K_e = K_{e,\\mathrm{dev}}^{\\text{full}} + \\alpha_e K_{e,\\mathrm{vol}}^{\\text{full}} + (1-\\alpha_e) K_{e,\\mathrm{vol}}^{\\text{red}} $$\nThe blending parameter $\\alpha_e \\in [0,1]$ is adapted based on the local volumetric response. A small value of $\\alpha_e$ (approaching reduced integration) is used where the material behaves in a nearly incompressible manner (i.e., small volumetric strain, $|\\nabla \\cdot u| \\approx 0$), which is where volumetric locking occurs. A large value of $\\alpha_e$ (approaching full integration) is used in compressible regions for better accuracy.\n\n**3. Iterative Solution and Adaptation**\nA fixed-point iterative scheme is employed:\n1.  **Initialization**: Set the blending parameters $\\alpha_e = 1$ for all elements. This corresponds to full integration everywhere.\n2.  **Assembly and Solve**: Assemble the global stiffness matrix $K = \\sum_e K_e$ using the current set of $\\alpha_e$. Apply the Dirichlet boundary conditions ($u_x=u_y=0$ on the bottom edge; $u_x=0.01, u_y=0$ on the top edge) to the linear system $Kd=f$. As there are no external forces, the vector $f$ arises from manipulating the system to enforce the non-homogeneous boundary conditions. Solve for the global displacement vector $d$.\n3.  **Indicator Calculation**: For each element $e$, compute the average magnitude of the volumetric strain from the newly computed displacement field $d$:\n    $$ \\bar{\\epsilon}_{\\mathrm{vol},e}=\\frac{\\int_{\\Omega_e}|\\varepsilon_{xx}+\\varepsilon_{yy}|\\,\\mathrm{d}\\Omega}{\\int_{\\Omega_e}\\,\\mathrm{d}\\Omega} $$\n    These integrals are evaluated using $2 \\times 2$ Gauss quadrature.\n4.  **Update $\\alpha_e$**: Update the blending parameter for each element using the provided monotonic mapping:\n    $$ \\alpha_e \\leftarrow \\min\\left(1, \\left(\\frac{\\bar{\\epsilon}_{\\mathrm{vol},e}}{\\epsilon_0}\\right)^{\\beta}\\right) $$\n    where $\\epsilon_0=10^{-4}$ and $\\beta=1/2$.\n5.  **Convergence Check**: Compare the newly computed $\\alpha_e$ values with those from the previous iteration. If the maximum absolute change $\\max_e|\\alpha_e^{(k)}-\\alpha_e^{(k-1)}|$ is below the tolerance $10^{-3}$, or if the maximum number of iterations (5) is reached, the process terminates. Otherwise, return to step 2.\n\n**4. Final Metric Calculation**\nAfter convergence, the robustness of the solution is quantified by computing the global $L^2$ norm of the volumetric strain over the entire domain:\n$$ \\|\\epsilon_{\\mathrm{vol}}\\|_{L^2(\\Omega)} = \\left( \\sum_e \\int_{\\Omega_e} (\\varepsilon_{xx}+\\varepsilon_{yy})^2\\,\\mathrm{d}\\Omega \\right)^{1/2} $$\nThis integral is also approximated using $2 \\times 2$ Gauss quadrature over each element. This process is repeated for each of the three test cases defined by different spatial distributions of Poisson's ratio $\\nu(x,y)$, yielding three final norm values.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements an adaptive selective reduced integration finite element method\n    for a 2D plane strain elasticity problem and computes a robustness metric for three test cases.\n    \"\"\"\n    \n    # GLOBAL PARAMETERS\n    NX, NY = 8, 8\n    GAMMA = 0.01\n    E_MOD = 1000.0\n    EPSILON0 = 1e-4\n    BETA = 0.5\n    MAX_ITER = 5\n    TOL = 1e-3\n\n    def get_shape_functions_and_derivs(xi, eta):\n        \"\"\"Computes bilinear shape functions and their derivatives in parent coordinates.\"\"\"\n        xi_nodes = np.array([-1, 1, 1, -1])\n        eta_nodes = np.array([-1, -1, 1, 1])\n        \n        N = 0.25 * (1 + xi_nodes * xi) * (1 + eta_nodes * eta)\n        \n        dN_dxi = 0.25 * xi_nodes * (1 + eta_nodes * eta)\n        dN_deta = 0.25 * eta_nodes * (1 + xi_nodes * xi)\n        \n        dN_dxieta = np.vstack([dN_dxi, dN_deta])\n        return N, dN_dxieta\n\n    def get_constitutive_matrices(nu, E):\n        \"\"\"Computes deviatoric and volumetric constitutive matrices for plane strain.\"\"\"\n        lam = E * nu / ((1 + nu) * (1 - 2 * nu))\n        mu = E / (2 * (1 + nu))\n        \n        C_dev = np.array([[2 * mu, 0, 0], [0, 2 * mu, 0], [0, 0, mu]])\n        C_vol = lam * np.array([[1, 1, 0], [1, 1, 0], [0, 0, 0]])\n        return C_dev, C_vol\n\n    def run_simulation(nu_func):\n        \"\"\"Runs the full adaptive FEM simulation for a given material law nu_func(x, y).\"\"\"\n        # 1. MESH GENERATION\n        num_nodes_x = NX + 1\n        num_nodes_y = NY + 1\n        num_nodes = num_nodes_x * num_nodes_y\n        num_dofs = 2 * num_nodes\n        \n        x_coords = np.linspace(0, 1, num_nodes_x)\n        y_coords = np.linspace(0, 1, num_nodes_y)\n        node_coords = np.array([[xi, yi] for yi in y_coords for xi in x_coords])\n        \n        elements = np.array([\n            [j * num_nodes_x + i, j * num_nodes_x + i + 1, (j + 1) * num_nodes_x + i + 1, (j + 1) * num_nodes_x + i]\n            for j in range(NY) for i in range(NX)\n        ])\n        num_elements = len(elements)\n\n        # 2. GAUSS QUADRATURE\n        gp_1d = 1.0 / np.sqrt(3)\n        quad_points_2x2 = [(-gp_1d, -gp_1d, 1.0), (gp_1d, -gp_1d, 1.0), (gp_1d, gp_1d, 1.0), (-gp_1d, gp_1d, 1.0)]\n        quad_point_1x1 = [(0.0, 0.0, 4.0)]\n\n        # 3. BOUNDARY CONDITIONS\n        fixed_dofs = {}\n        for i in range(num_nodes_x):\n            # Bottom edge (y=0)\n            node_idx_bottom = i\n            fixed_dofs[2 * node_idx_bottom] = 0.0\n            fixed_dofs[2 * node_idx_bottom + 1] = 0.0\n            # Top edge (y=1)\n            node_idx_top = NY * num_nodes_x + i\n            fixed_dofs[2 * node_idx_top] = GAMMA\n            fixed_dofs[2 * node_idx_top + 1] = 0.0\n\n        all_dofs = np.arange(num_dofs)\n        fixed_dof_indices = list(fixed_dofs.keys())\n        free_dofs = np.setdiff1d(all_dofs, fixed_dof_indices)\n\n        # 4. ADAPTIVE ITERATION\n        alphas = np.ones(num_elements)\n        d = np.zeros(num_dofs)\n\n        for k in range(MAX_ITER):\n            alphas_prev = alphas.copy()\n            K = np.zeros((num_dofs, num_dofs))\n            \n            for e_idx, el_nodes in enumerate(elements):\n                el_coords = node_coords[el_nodes]\n                alpha_e = alphas[e_idx]\n\n                Ke_dev = np.zeros((8, 8))\n                Ke_vol_full = np.zeros((8, 8))\n                \n                # Full integration (2x2)\n                for xi, eta, w in quad_points_2x2:\n                    N, dN_dxieta = get_shape_functions_and_derivs(xi, eta)\n                    J = dN_dxieta @ el_coords\n                    detJ = np.linalg.det(J)\n                    \n                    B = np.zeros((3, 8))\n                    dN_dxy = np.linalg.inv(J) @ dN_dxieta\n                    B[0, 0::2] = dN_dxy[0, :]\n                    B[1, 1::2] = dN_dxy[1, :]\n                    B[2, 0::2] = dN_dxy[1, :]\n                    B[2, 1::2] = dN_dxy[0, :]\n                    \n                    gp_coords = N @ el_coords\n                    nu = nu_func(gp_coords[0], gp_coords[1])\n                    C_dev, C_vol = get_constitutive_matrices(nu, E_MOD)\n                    \n                    Ke_dev += B.T @ C_dev @ B * detJ * w\n                    Ke_vol_full += B.T @ C_vol @ B * detJ * w\n\n                # Reduced integration (1x1)\n                Ke_vol_red = np.zeros((8, 8))\n                xi, eta, w = quad_point_1x1[0]\n                N, dN_dxieta = get_shape_functions_and_derivs(xi, eta)\n                J = dN_dxieta @ el_coords\n                detJ = np.linalg.det(J)\n                \n                B = np.zeros((3, 8))\n                dN_dxy = np.linalg.inv(J) @ dN_dxieta\n                B[0, 0::2] = dN_dxy[0, :]\n                B[1, 1::2] = dN_dxy[1, :]\n                B[2, 0::2] = dN_dxy[1, :]\n                B[2, 1::2] = dN_dxy[0, :]\n\n                gp_coords = N @ el_coords\n                nu = nu_func(gp_coords[0], gp_coords[1])\n                _, C_vol = get_constitutive_matrices(nu, E_MOD)\n                \n                Ke_vol_red = B.T @ C_vol @ B * detJ * w\n                \n                Ke = Ke_dev + alpha_e * Ke_vol_full + (1 - alpha_e) * Ke_vol_red\n                \n                dof_indices = np.ravel([[2 * n, 2 * n + 1] for n in el_nodes])\n                K[np.ix_(dof_indices, dof_indices)] += Ke\n\n            F = np.zeros(num_dofs)\n            for dof_idx, val in fixed_dofs.items():\n                F[free_dofs] -= K[free_dofs, dof_idx] * val\n            \n            K_reduced = K[np.ix_(free_dofs, free_dofs)]\n            F_reduced = F[free_dofs]\n            \n            d_free = np.linalg.solve(K_reduced, F_reduced)\n            \n            d[free_dofs] = d_free\n            for dof_idx, val in fixed_dofs.items():\n                d[dof_idx] = val\n\n            for e_idx, el_nodes in enumerate(elements):\n                dof_indices = np.ravel([[2 * n, 2 * n + 1] for n in el_nodes])\n                d_e = d[dof_indices]\n                el_coords = node_coords[el_nodes]\n                \n                vol_strain_integral, area = 0.0, 0.0\n                for xi, eta, w in quad_points_2x2:\n                    _, dN_dxieta = get_shape_functions_and_derivs(xi, eta)\n                    J = dN_dxieta @ el_coords\n                    detJ = np.linalg.det(J)\n                    \n                    B = np.zeros((3, 8))\n                    dN_dxy = np.linalg.inv(J) @ dN_dxieta\n                    B[0, 0::2] = dN_dxy[0, :]\n                    B[1, 1::2] = dN_dxy[1, :]\n                    B[2, 0::2] = dN_dxy[1, :]\n                    B[2, 1::2] = dN_dxy[0, :]\n                    \n                    strain = B @ d_e\n                    vol_strain = strain[0] + strain[1]\n                    \n                    vol_strain_integral += np.abs(vol_strain) * detJ * w\n                    area += detJ * w\n                \n                avg_vol_strain = vol_strain_integral / area if area > 0 else 0\n                alphas[e_idx] = min(1.0, (avg_vol_strain / EPSILON0)**BETA)\n\n            if np.max(np.abs(alphas - alphas_prev))  TOL:\n                break\n                \n        # 5. POST-PROCESSING\n        vol_strain_sq_integral = 0.0\n        for e_idx, el_nodes in enumerate(elements):\n            dof_indices = np.ravel([[2 * n, 2 * n + 1] for n in el_nodes])\n            d_e = d[dof_indices]\n            el_coords = node_coords[el_nodes]\n            \n            for xi, eta, w in quad_points_2x2:\n                _, dN_dxieta = get_shape_functions_and_derivs(xi, eta)\n                J = dN_dxieta @ el_coords\n                detJ = np.linalg.det(J)\n                \n                B = np.zeros((3, 8))\n                dN_dxy = np.linalg.inv(J) @ dN_dxieta\n                B[0, 0::2] = dN_dxy[0, :]\n                B[1, 1::2] = dN_dxy[1, :]\n                B[2, 0::2] = dN_dxy[1, :]\n                B[2, 1::2] = dN_dxy[0, :]\n\n                strain = B @ d_e\n                vol_strain = strain[0] + strain[1]\n                vol_strain_sq_integral += (vol_strain**2) * detJ * w\n                \n        return np.sqrt(vol_strain_sq_integral)\n\n    # --- DEFINE AND RUN TEST CASES ---\n    test_cases = [\n        lambda x, y: 0.499 if x  0.5 else 0.3,  # Case 1\n        lambda x, y: 0.3,                          # Case 2\n        lambda x, y: 0.4999                        # Case 3\n    ]\n\n    results = [run_simulation(nu_func) for nu_func in test_cases]\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}