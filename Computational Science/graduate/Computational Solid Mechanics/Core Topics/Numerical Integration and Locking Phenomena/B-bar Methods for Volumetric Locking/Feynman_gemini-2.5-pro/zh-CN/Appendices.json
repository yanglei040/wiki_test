{
    "hands_on_practices": [
        {
            "introduction": "在我们深入研究B-bar方法的实现细节之前，通过一个基础的推导来理解其核心构件是至关重要的。这项练习  将指导您为标准双线性四边形单元推导体积平均算子，该算子是构建B-bar公式的数学基础。完成此练习将使您对该方法如何将节点位移映射到单元平均体积应变有一个清晰的认识。",
            "id": "3545792",
            "problem": "考虑一个单一的等参双线性四边形 ($Q_4$) 有限元 (FE)，其在物理坐标 $(x,y)$ 中占据单位正方形域 $\\Omega = [0,1]\\times[0,1]$。设节点坐标按逆时针顺序排列为：节点 $1$ 在 $(0,0)$，节点 $2$ 在 $(1,0)$，节点 $3$ 在 $(1,1)$，节点 $4$ 在 $(0,1)$。设位移自由度 (degrees of freedom, DOFs) 集合在单元向量中\n$$\n\\mathbf{d}_e = \\begin{pmatrix} u_1  v_1  u_2  v_2  u_3  v_3  u_4  v_4 \\end{pmatrix}^{\\mathsf{T}},\n$$\n其中 $u_i$ 和 $v_i$ 分别是节点 $i$ 沿 $x$ 和 $y$ 方向的位移分量。假设平面应变中的小应变运动学，因此体积应变 (膨胀) 定义为\n$$\n\\epsilon_v(x,y) = \\nabla \\cdot \\mathbf{u}(x,y) = \\frac{\\partial u}{\\partial x} + \\frac{\\partial v}{\\partial y}.\n$$\n有限元位移场使用单位正方形上的标准双线性形函数来近似，\n$$\nN_1(x,y) = (1-x)(1-y), \\quad N_2(x,y) = x(1-y), \\quad N_3(x,y) = xy, \\quad N_4(x,y) = (1-x)y,\n$$\n因此\n$$\nu(x,y) = \\sum_{i=1}^{4} N_i(x,y)\\,u_i, \\qquad v(x,y) = \\sum_{i=1}^{4} N_i(x,y)\\,v_i.\n$$\n定义单元平均体积应变\n$$\n\\bar{\\epsilon}_v = \\frac{1}{A}\\int_{\\Omega} \\epsilon_v(x,y)\\,\\mathrm{d}A,\n$$\n其中单元面积 $A=1$。在用于解决体积锁定的 $\\bar{B}$方法 (B-bar 方法) 的背景下，体积平均算子 $\\mathbf{P}_v$ 是唯一的 $1\\times 8$ 行矩阵，使得\n$$\n\\bar{\\epsilon}_v = \\mathbf{P}_v\\,\\mathbf{d}_e.\n$$\n仅从前面的定义和小应变运动学出发，通过对 $\\Omega$ 的精确积分，显式地推导出 $\\mathbf{P}_v$。将最终算子表示为按 $\\left[u_1, v_1, u_2, v_2, u_3, v_3, u_4, v_4\\right]$ 顺序排列的 $1\\times 8$ 行矩阵。不需要进行数值舍入，结果必须以精确的有理数形式给出。",
            "solution": "我们从二维体积应变 (膨胀) 的小应变定义开始：\n$$\n\\epsilon_v(x,y) = \\nabla \\cdot \\mathbf{u}(x,y) = \\frac{\\partial u}{\\partial x} + \\frac{\\partial v}{\\partial y}.\n$$\n使用有限元 (FE) 近似\n$$\nu(x,y) = \\sum_{i=1}^{4} N_i(x,y)\\,u_i, \n\\qquad \nv(x,y) = \\sum_{i=1}^{4} N_i(x,y)\\,v_i,\n$$\n我们得到\n$$\n\\frac{\\partial u}{\\partial x} = \\sum_{i=1}^{4} \\frac{\\partial N_i}{\\partial x}(x,y)\\,u_i,\n\\qquad\n\\frac{\\partial v}{\\partial y} = \\sum_{i=1}^{4} \\frac{\\partial N_i}{\\partial y}(x,y)\\,v_i,\n$$\n因此\n$$\n\\epsilon_v(x,y) = \\sum_{i=1}^{4} \\left(\\frac{\\partial N_i}{\\partial x}(x,y)\\,u_i + \\frac{\\partial N_i}{\\partial y}(x,y)\\,v_i\\right).\n$$\n在面积 $A=1$ 的单位正方形 $\\Omega = [0,1]\\times[0,1]$ 上的单元平均体积应变为\n$$\n\\bar{\\epsilon}_v = \\int_{\\Omega} \\epsilon_v(x,y)\\,\\mathrm{d}A \n= \\sum_{i=1}^{4} \\left( u_i \\int_{\\Omega} \\frac{\\partial N_i}{\\partial x}\\,\\mathrm{d}A + v_i \\int_{\\Omega} \\frac{\\partial N_i}{\\partial y}\\,\\mathrm{d}A \\right).\n$$\n因此，体积平均算子 $\\mathbf{P}_v$ 由以下精确积分组装而成\n$$\nI_{x,i} := \\int_{\\Omega} \\frac{\\partial N_i}{\\partial x}\\,\\mathrm{d}A, \n\\qquad \nI_{y,i} := \\int_{\\Omega} \\frac{\\partial N_i}{\\partial y}\\,\\mathrm{d}A,\n$$\n为\n$$\n\\bar{\\epsilon}_v = \\begin{pmatrix} I_{x,1}  I_{y,1}  I_{x,2}  I_{y,2}  I_{x,3}  I_{y,3}  I_{x,4}  I_{y,4} \\end{pmatrix}\n\\begin{pmatrix} u_1 \\\\ v_1 \\\\ u_2 \\\\ v_2 \\\\ u_3 \\\\ v_3 \\\\ u_4 \\\\ v_4 \\end{pmatrix}.\n$$\n因此，\n$$\n\\mathbf{P}_v = \\begin{pmatrix} I_{x,1}  I_{y,1}  I_{x,2}  I_{y,2}  I_{x,3}  I_{y,3}  I_{x,4}  I_{y,4} \\end{pmatrix}.\n$$\n\n我们计算单位正方形上双线性形函数的所需导数：\n\n$$\n\\begin{aligned}\nN_1(x,y) = (1-x)(1-y),  \\frac{\\partial N_1}{\\partial x} = -(1-y),  \\frac{\\partial N_1}{\\partial y} = -(1-x),\\\\\nN_2(x,y) = x(1-y),       \\frac{\\partial N_2}{\\partial x} = (1-y),   \\frac{\\partial N_2}{\\partial y} = -x,\\\\\nN_3(x,y) = xy,           \\frac{\\partial N_3}{\\partial x} = y,        \\frac{\\partial N_3}{\\partial y} = x,\\\\\nN_4(x,y) = (1-x)y,       \\frac{\\partial N_4}{\\partial x} = -y,       \\frac{\\partial N_4}{\\partial y} = (1-x).\n\\end{aligned}\n$$\n\n我们对 $\\Omega = [0,1]\\times[0,1]$ 进行精确积分：\n\n$$\n\\begin{aligned}\nI_{x,1} = \\int_{0}^{1}\\int_{0}^{1} \\left( -(1-y) \\right)\\,\\mathrm{d}x\\,\\mathrm{d}y \n= \\int_{0}^{1} \\left( -(1-y) \\int_{0}^{1} \\mathrm{d}x \\right)\\mathrm{d}y \n= \\int_{0}^{1} \\left( -(1-y) \\cdot 1 \\right)\\mathrm{d}y \n= -\\int_{0}^{1} (1-y)\\,\\mathrm{d}y \n= -\\left[ y - \\frac{y^{2}}{2} \\right]_{0}^{1} \n= -\\left(1 - \\frac{1}{2}\\right) \n= -\\frac{1}{2},\\\\\nI_{x,2} = \\int_{0}^{1}\\int_{0}^{1} (1-y)\\,\\mathrm{d}x\\,\\mathrm{d}y \n= \\int_{0}^{1} (1-y)\\,\\mathrm{d}y \n= \\frac{1}{2},\\\\\nI_{x,3} = \\int_{0}^{1}\\int_{0}^{1} y\\,\\mathrm{d}x\\,\\mathrm{d}y \n= \\int_{0}^{1} y \\left(\\int_{0}^{1} \\mathrm{d}x\\right)\\mathrm{d}y \n= \\int_{0}^{1} y\\,\\mathrm{d}y \n= \\frac{1}{2},\\\\\nI_{x,4} = \\int_{0}^{1}\\int_{0}^{1} \\left( -y \\right)\\,\\mathrm{d}x\\,\\mathrm{d}y \n= -\\int_{0}^{1} y\\,\\mathrm{d}y \n= -\\frac{1}{2}.\n\\end{aligned}\n$$\n\n对于 $y$ 方向的导数，类似地：\n\n$$\n\\begin{aligned}\nI_{y,1} = \\int_{0}^{1}\\int_{0}^{1} \\left( -(1-x) \\right)\\,\\mathrm{d}x\\,\\mathrm{d}y \n= -\\int_{0}^{1} (1-x)\\,\\mathrm{d}x \n= -\\left[ x - \\frac{x^{2}}{2} \\right]_{0}^{1} \n= -\\left(1 - \\frac{1}{2}\\right) \n= -\\frac{1}{2},\\\\\nI_{y,2} = \\int_{0}^{1}\\int_{0}^{1} \\left( -x \\right)\\,\\mathrm{d}x\\,\\mathrm{d}y \n= -\\int_{0}^{1} x\\,\\mathrm{d}x \n= -\\frac{1}{2},\\\\\nI_{y,3} = \\int_{0}^{1}\\int_{0}^{1} x\\,\\mathrm{d}x\\,\\mathrm{d}y \n= \\int_{0}^{1} x\\,\\mathrm{d}x \n= \\frac{1}{2},\\\\\nI_{y,4} = \\int_{0}^{1}\\int_{0}^{1} (1-x)\\,\\mathrm{d}x\\,\\mathrm{d}y \n= \\int_{0}^{1} (1-x)\\,\\mathrm{d}x \n= \\frac{1}{2}.\n\\end{aligned}\n$$\n\n将这些结果收集到算子中，并注意到 $A=1$，我们得到\n$$\n\\mathbf{P}_v = \\begin{pmatrix}\n-\\frac{1}{2}  -\\frac{1}{2}  \\frac{1}{2}  -\\frac{1}{2}  \\frac{1}{2}  \\frac{1}{2}  -\\frac{1}{2}  \\frac{1}{2}\n\\end{pmatrix}.\n$$\n作为一致性检验，与 $u$-自由度和 $v$-自由度相关的系数之和分别等于零，\n$$\n\\left(-\\frac{1}{2} + \\frac{1}{2} + \\frac{1}{2} - \\frac{1}{2}\\right) = 0,\n\\qquad\n\\left(-\\frac{1}{2} - \\frac{1}{2} + \\frac{1}{2} + \\frac{1}{2}\\right) = 0,\n$$\n这与单位分解以及恒定位移场具有零体积应变的事实相一致。至此，我们完成了在单位正方形 $Q_4$ 单元上，用于 $\\bar{B}$ 方法的体积平均算子的推导。",
            "answer": "$$\\boxed{\\begin{pmatrix}-\\frac{1}{2}  -\\frac{1}{2}  \\frac{1}{2}  -\\frac{1}{2}  \\frac{1}{2}  \\frac{1}{2}  -\\frac{1}{2}  \\frac{1}{2}\\end{pmatrix}}$$"
        },
        {
            "introduction": "建立了理论基础后，下一步是在一个受控的数值实验中验证我们的方法。静水补丁测试是一个经典的基准，旨在隔离体积锁定效应，并验证一种单元公式是否能准确再现恒定应力状态。通过将标准单元与B-bar修正单元进行比较，这项练习  将直观地展示锁定问题以及B-bar方法作为解决方案的有效性。",
            "id": "3545830",
            "problem": "设计一个方形域内的二维线性弹性平面应变静水压力补丁测试，以分离恒定压力模式，并比较标准双线性四边形单元与 $\\bar B$-修正单元。目标是验证，当 Poisson 比接近不可压缩性时，$\\bar B$ 单元能在均匀边界压力荷载下再现精确的恒定平面静水应力，而标准单元则表现出体积闭锁现象。\n\n使用以下基本依据和假设：\n- 小变形、准静态、无体力的线性动量平衡。\n- 线性各向同性平面应变弹性，其杨氏模量为 $E$，Poisson 比为 $\\nu$，Lamé 参数为 $\\lambda = \\dfrac{E \\nu}{(1+\\nu)(1-2\\nu)}$ 和 $\\mu = \\dfrac{E}{2(1+\\nu)}$。在工程应变基 $\\{\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}\\}$ 下的本构矩阵为\n$$\n\\mathbf{D} = \\begin{bmatrix}\n\\lambda + 2\\mu  \\lambda  0 \\\\\n\\lambda  \\lambda + 2\\mu  0 \\\\\n0  0  \\mu\n\\end{bmatrix}.\n$$\n- 双线性四边形 ($Q4$) 单元，其刚度矩阵采用 $2\\times 2$ 阶完全 Gauss 积分，每个边界边上的一致性牵引荷载采用 2 阶积分。\n- $\\bar B$ 修正将每个 Gauss 点处的体积应变替换为单元平均体积应变，同时精确地保留偏应变部分。\n\n几何、荷载与边界条件：\n- 计算域为单位正方形 $[0,1]\\times[0,1]$，被划分为 $n_x \\times n_y$ 个双线性单元组成的结构化网格。边长取 $L=1$。\n- 在所有四个边界边上施加均匀压缩压力 $p_0$，其牵引力为 $\\mathbf{t} = -p_0 \\,\\mathbf{n}$，其中 $\\mathbf{n}$ 是外法向单位向量。\n- 为消除刚体模式且不干扰均匀静水压缩模式，施加以下本质边界条件：\n  - 在角点 $(x,y)=(0,0)$ 处，强制 $u=0$ 和 $v=0$。\n  - 在角点 $(x,y)=(1,0)$ 处，强制 $v=0$。\n  - 在角点 $(x,y)=(0,1)$ 处，强制 $u=0$。\n这些条件与均匀压缩场 $u = e\\,x$，$v = e\\,y$ 相容。\n\n用于验证的静水精确解：\n- 在精确的平面静水应力状态下，$\\sigma_{xx}=\\sigma_{yy}=-p_0$ 为常数且无剪切，一个与之相容的精确恒定应变场为 $\\varepsilon_{xx}=\\varepsilon_{yy}=e$ 和 $\\gamma_{xy}=0$，其中\n$$\ne = -\\frac{p_0}{2\\lambda + 2\\mu}.\n$$\n因此，整个域上的精确位移场为 $u(x,y)=e\\,x$ 和 $v(x,y)=e\\,y$。精确的平面静水压力（平面平均应力的相反数）满足 $p_{\\text{planar}} = -\\dfrac{\\sigma_{xx}+\\sigma_{yy}}{2} = p_0$。\n\n需要实现的有限元公式：\n- 标准 $Q4$：在每个 Gauss 点 $g$，计算应变 $\\boldsymbol\\varepsilon_g = \\mathbf{B}_g \\,\\mathbf{u}_e$ 和刚度贡献 $\\mathbf{K}_e^{\\text{std}} \\mathrel{+}= \\mathbf{B}_g^\\top \\mathbf{D}\\,\\mathbf{B}_g \\, w_g \\,\\det\\mathbf{J}_g$。\n- $\\bar B$ 修正的 $Q4$：令 $\\mathbf{m}^\\top = [\\,1 \\;\\; 1 \\;\\; 0\\,]$（用于提取平面体积应变）和 $\\mathbf{q} = [\\,1 \\;\\; 1 \\;\\; 0\\,]^\\top$。对于一个包含 Gauss 点 $g$ 的单元，定义单元面积\n$$\nA_e = \\sum_g w_g \\,\\det\\mathbf{J}_g\n$$\n和单元平均体积应变行向量\n$$\n\\boldsymbol{\\Theta} = \\frac{1}{A_e}\\sum_g w_g \\,\\det\\mathbf{J}_g \\,\\mathbf{m}^\\top \\mathbf{B}_g,\n$$\n使得平均体积应变为 $\\theta_{\\text{bar}} = \\boldsymbol{\\Theta}\\,\\mathbf{u}_e$。在 Gauss 点 $g$ 处的 $\\bar B$ 应变-位移算子为\n$$\n\\bar{\\mathbf{B}}_g = \\left(\\mathbf{I}_{3\\times 3} - \\frac{1}{2}\\,\\mathbf{q}\\,\\mathbf{m}^\\top\\right)\\mathbf{B}_g + \\frac{1}{2}\\,\\mathbf{q}\\,\\boldsymbol{\\Theta},\n$$\n该算子能精确保留偏应变，并仅将体积应变部分替换为其单元平均值。单元刚度为\n$$\n\\mathbf{K}_e^{\\bar B} \\mathrel{+}= \\bar{\\mathbf{B}}_g^\\top \\mathbf{D}\\,\\bar{\\mathbf{B}}_g \\, w_g \\,\\det\\mathbf{J}_g.\n$$\n\n验证指标：\n- 计算相对均方根 (RMS) 位移误差\n$$\n\\eta_u = \\sqrt{ \\frac{\\sum_i \\left\\|\\mathbf{u}_i - \\mathbf{u}_{\\text{exact}}(x_i,y_i)\\right\\|^2}{\\sum_i \\left\\|\\mathbf{u}_{\\text{exact}}(x_i,y_i)\\right\\|^2} },\n$$\n其中求和遍历所有节点 $i$，且 $\\mathbf{u}=(u,v)$。\n- 使用单元 Gauss 点应力计算平面压力误差。对于每种方法，计算平均平面压力\n$$\n\\bar p = -\\frac{1}{2 A}\\sum_{e}\\sum_{g} \\left(\\sigma_{xx}^g + \\sigma_{yy}^g\\right)\\, w_g \\,\\det\\mathbf{J}_g,\n$$\n其中 $A=1$ 是总面积，并定义相对压力误差\n$$\n\\eta_p = \\frac{|\\bar p - p_0|}{p_0}.\n$$\n\n测试组：\n- 所有情况均使用 $E=1$ 和 $p_0=1$，并取 $L=1$。\n- 情况 1：$(n_x,n_y,\\nu) = (2,2,0.3)$。\n- 情况 2：$(n_x,n_y,\\nu) = (2,2,0.4999)$。\n- 情况 3：$(n_x,n_y,\\nu) = (4,4,0.4999)$。\n\n程序要求：\n- 按照上述方法实现标准单元和 $\\bar B$ 单元公式，组装全局系统，施加指定的本质边界条件，并对每个边界上的压力使用沿边界边的 2 点 Gauss 积分来计算一致性牵引荷载。\n- 对每个测试用例，计算数组 $(\\eta_u^{\\text{std}}, \\eta_u^{\\bar B})$ 和 $(\\eta_p^{\\text{std}}, \\eta_p^{\\bar B})$。\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按以下顺序包含 12 个浮点数：\n  - 情况 1：$\\eta_u^{\\text{std}}$, $\\eta_u^{\\bar B}$, $\\eta_p^{\\text{std}}$, $\\eta_p^{\\bar B}$,\n  - 情况 2：$\\eta_u^{\\text{std}}$, $\\eta_u^{\\bar B}$, $\\eta_p^{\\text{std}}$, $\\eta_p^{\\bar B}$,\n  - 情况 3：$\\eta_u^{\\text{std}}$, $\\eta_u^{\\bar B}$, $\\eta_p^{\\text{std}}$, $\\eta_p^{\\bar B}$。\n所有输出均为无量纲浮点数。最终输出不需要单位，因为报告的量是相对误差。不使用角度。百分比必须表示为小数（而不是用百分号）。",
            "solution": "该问题要求为二维线性弹性单元设计并实现一个静水压力补丁测试。此测试的目的是在近不可压缩条件下，展示标准双线性四边形 ($Q4$) 单元中的体积闭锁现象，并验证 $\\bar B$ 方法的修正效果。\n\n我们将模拟一个单位正方形域的响应，该域通过 $Q4$ 单元的结构化网格进行离散化，并承受均匀的外部压力 $p_0$。材料是各向同性的线性弹性体，处于平面应变状态。将对两种单元公式进行分析：标准 $Q4$ 单元和使用 $\\bar B$ 技术修正的 $Q4$ 单元。\n\n有限元法 (FEM) 的基础是虚功原理，对于无体力的准静态线性弹性问题，该原理导出了矩阵系统 $\\mathbf{K}\\mathbf{U} = \\mathbf{F}$。其中，$\\mathbf{K}$ 是全局刚度矩阵，$\\mathbf{U}$ 是节点位移向量，$\\mathbf{F}$ 是从施加的牵引力导出的全局节点力向量。\n\n单个单元的单元刚度矩阵 $\\mathbf{K}_e$ 通过对单元体积（在二维中为面积 $A_e$）进行积分计算得出：\n$$\n\\mathbf{K}_e = \\int_{A_e} \\mathbf{B}^\\top \\mathbf{D} \\mathbf{B} \\,dA\n$$\n其中 $\\mathbf{D}$ 是材料本构矩阵，$\\mathbf{B}$ 是应变-位移矩阵，它将节点位移 $\\mathbf{u}_e$ 与应变场 $\\boldsymbol{\\varepsilon} = \\mathbf{B}\\mathbf{u}_e$ 联系起来。对于 $Q4$ 单元，$\\mathbf{B}$ 由双线性形函数的导数推导得出。该积分使用 $2 \\times 2$ Gauss 求积进行数值计算。\n\n由单元边界 $\\Gamma_e$ 上的牵引力 $\\mathbf{t}$ 产生的力向量 $\\mathbf{F}_e$ 由下式给出：\n$$\n\\mathbf{F}_e = \\int_{\\Gamma_e} \\mathbf{N}^\\top \\mathbf{t} \\,d\\Gamma\n$$\n其中 $\\mathbf{N}$ 是形函数矩阵。对于指定的均匀压力 $p_0$，牵引力为 $\\mathbf{t}=-p_0\\mathbf{n}$，其中 $\\mathbf{n}$ 是外法线。该积分沿每个边界边使用 2 点 Gauss 求积进行计算。\n\n**体积闭锁与 $\\bar B$ 方法**\n\n体积闭锁是一种在模拟近不可压缩材料（即 Poisson 比 $\\nu \\to 0.5$）时，出现在低阶有限元（如标准 $Q4$ 单元）中的数值伪影。对于平面应变，Lamé 参数 $\\lambda = \\frac{E \\nu}{(1+\\nu)(1-2\\nu)}$ 趋于无穷大，导致单元对体积变形的响应过度刚化。单元会错误地预测出接近零的体积应变，即发生“闭锁”。\n\n$\\bar B$ 方法通过解耦应变场计算中的偏应变部分和体积应变部分来修正此问题。在每个 Gauss 点，偏应变像标准公式一样在局部计算。然而，体积应变（体积膨胀）被替换为单个的单元平均值 $\\theta_{\\text{bar}}$。\n\n这一修正是通过构造一个修正的应变-位移矩阵 $\\bar{\\mathbf{B}}$ 来实现的。在 Gauss 点 $g$ 处的应变计算为 $\\boldsymbol{\\varepsilon}_g = \\bar{\\mathbf{B}}_g \\mathbf{u}_e$。问题给出了 $\\bar{\\mathbf{B}}_g$ 的直接构造方法：\n$$\n\\bar{\\mathbf{B}}_g = \\left(\\mathbf{I}_{3\\times 3} - \\frac{1}{2}\\,\\mathbf{q}\\,\\mathbf{m}^\\top\\right)\\mathbf{B}_g + \\frac{1}{2}\\,\\mathbf{q}\\,\\boldsymbol{\\Theta}\n$$\n其中 $\\mathbf{m}^\\top=[1,1,0]$ 用于提取平面体积应变 $\\theta = \\varepsilon_{xx}+\\varepsilon_{yy}$，$\\mathbf{q}=\\mathbf{m}^\\top$，而 $\\boldsymbol{\\Theta}$ 是一个行向量，它根据单元节点位移计算单元平均体积应变 $\\theta_{\\text{bar}} = \\boldsymbol{\\Theta}\\mathbf{u}_e$。具体而言，$\\boldsymbol{\\Theta}$ 是通过在单元面积上对 $\\mathbf{m}^\\top\\mathbf{B}_g$ 进行平均计算得到的：\n$$\n\\boldsymbol{\\Theta} = \\frac{1}{A_e}\\sum_g w_g \\det(\\mathbf{J}_g) (\\mathbf{m}^\\top \\mathbf{B}_g)\n$$\n项 $(\\mathbf{I} - \\frac{1}{2}\\mathbf{q}\\mathbf{m}^\\top)$ 是一个投影算子，它从标准计算 $\\mathbf{B}_g\\mathbf{u}_e$ 中提取应变的偏应变部分。然后，项 $\\frac{1}{2}\\mathbf{q}\\boldsymbol{\\Theta}$ 使用单一的平均值加回体积应变部分。$\\bar B$ 单元的单元刚度则为：\n$$\n\\mathbf{K}_e^{\\bar B} = \\int_{A_e} \\bar{\\mathbf{B}}^\\top \\mathbf{D} \\bar{\\mathbf{B}} \\,dA\n$$\n\n**补丁测试验证**\n\n问题描述了一个静水压力补丁测试，其精确解对应于均匀静水应力和应变的状态。解析位移场为 $u(x,y)=e\\,x$，$v(x,y)=e\\,y$，其中 $e = -p_0/(2\\lambda + 2\\mu)$。一个有效的有限元公式应该能再现这个精确解。\n\n我们在三个角点施加本质边界条件以消除刚体运动，而不约束精确的变形模式。根据均匀边界压力一致地施加节点力。然后，我们对标准公式和 $\\bar B$ 公式求解全局系统 $\\mathbf{K}\\mathbf{U}=\\mathbf{F}$。\n\n结果通过两个误差度量进行量化：1. 相对均方根位移误差 $\\eta_u$，它衡量计算出的节点位移与精确场之间的偏差。2. 相对压力误差 $\\eta_p$，它衡量计算出的平均平面压力与解析值 $p_0$ 之间的偏差。\n\n对于 $\\nu \\to 0.5$ 的情况，我们预期标准 $Q4$ 单元会产生较大的误差（$\\eta_u \\to 1$ 和较大的 $\\eta_p$），这表明发生了闭锁。相比之下，$\\bar B$ 单元被设计用来通过这个补丁测试，因此对于所有 $\\nu$ 值，其误差应保持在机器精度附近。所提供的 $\\nu=0.3$ 和 $\\nu=0.4999$ 的测试用例将突显这种差异。在此测试中，网格细化（情况 3）不会缓解标准单元的闭锁问题。",
            "answer": "```python\nimport numpy as np\n\ndef solve_fem_system(nx, ny, E, nu, p0, L, use_b_bar):\n    \"\"\"\n    Solves a 2D linear elasticity problem on a square domain using Q4 elements.\n    \"\"\"\n    # 1. Material and Mesh Setup\n    if abs(1 - 2 * nu)  1e-9: # Avoid singularity at nu=0.5\n        return np.nan, np.nan\n    lame_lambda = E * nu / ((1 + nu) * (1 - 2 * nu))\n    lame_mu = E / (2 * (1 + nu))\n    D = np.array([\n        [lame_lambda + 2 * lame_mu, lame_lambda, 0],\n        [lame_lambda, lame_lambda + 2 * lame_mu, 0],\n        [0, 0, lame_mu]\n    ])\n\n    num_nodes_x = nx + 1\n    num_nodes_y = ny + 1\n    num_nodes = num_nodes_x * num_nodes_y\n    num_dofs = 2 * num_nodes\n    \n    node_coords = np.zeros((num_nodes, 2))\n    for j in range(num_nodes_y):\n        for i in range(num_nodes_x):\n            node_idx = i + j * num_nodes_x\n            node_coords[node_idx, 0] = i * L / nx\n            node_coords[node_idx, 1] = j * L / ny\n\n    elements = []\n    for j in range(ny):\n        for i in range(nx):\n            n1 = i + j * num_nodes_x\n            n2 = (i + 1) + j * num_nodes_x\n            n3 = (i + 1) + (j + 1) * num_nodes_x\n            n4 = i + (j + 1) * num_nodes_x\n            elements.append(np.array([n1, n2, n3, n4]))\n\n    K = np.zeros((num_dofs, num_dofs))\n    \n    # 2. Element Assembly Loop\n    gauss_points = [-1 / np.sqrt(3), 1 / np.sqrt(3)]\n    gauss_weights = [1.0, 1.0]\n\n    def get_shape_functions_and_derivs(xi, eta):\n        N = 0.25 * np.array([(1 - xi) * (1 - eta), (1 + xi) * (1 - eta),\n                               (1 + xi) * (1 + eta), (1 - xi) * (1 + eta)])\n        dN_dxi = 0.25 * np.array([-(1 - eta), (1 - eta), (1 + eta), -(1 + eta)])\n        dN_deta = 0.25 * np.array([-(1 - xi), -(1 + xi), (1 + xi), (1 - xi)])\n        return N, dN_dxi, dN_deta\n\n    m_T = np.array([1.0, 1.0, 0.0])\n    q = m_T.reshape(3, 1)\n    P_dev = np.eye(3) - 0.5 * q @ q.T\n\n    for el_nodes in elements:\n        el_coords = node_coords[el_nodes]\n        Ke = np.zeros((8, 8))\n        \n        # B-bar: First pass to compute element-averaged strain vector Theta\n        if use_b_bar:\n            el_area = 0.0\n            Theta_num = np.zeros(8)\n            for xi in gauss_points:\n                for eta in gauss_points:\n                    _, dN_dxi, dN_deta = get_shape_functions_and_derivs(xi, eta)\n                    J = np.vstack((dN_dxi, dN_deta)) @ el_coords\n                    detJ = np.linalg.det(J)\n                    \n                    B_gauss = np.zeros((3, 8))\n                    for i in range(4):\n                        dN_d_xy = np.linalg.solve(J.T, [dN_dxi[i], dN_deta[i]])\n                        B_gauss[0, 2 * i] = dN_d_xy[0]\n                        B_gauss[1, 2 * i + 1] = dN_d_xy[1]\n                        B_gauss[2, 2 * i] = dN_d_xy[1]\n                        B_gauss[2, 2 * i + 1] = dN_d_xy[0]\n                    \n                    el_area += detJ  # All weights are 1.0\n                    Theta_num += detJ * (m_T @ B_gauss)\n            Theta = Theta_num / el_area if el_area != 0 else np.zeros(8)\n\n        # Second pass to compute stiffness matrix\n        for xi_idx, xi in enumerate(gauss_points):\n            for eta_idx, eta in enumerate(gauss_points):\n                w = gauss_weights[xi_idx] * gauss_weights[eta_idx]\n                _, dN_dxi, dN_deta = get_shape_functions_and_derivs(xi, eta)\n                J = np.vstack((dN_dxi, dN_deta)) @ el_coords\n                detJ = np.linalg.det(J)\n\n                B = np.zeros((3, 8))\n                for i in range(4):\n                    dN_d_xy = np.linalg.solve(J.T, [dN_dxi[i], dN_deta[i]])\n                    B[0, 2 * i] = dN_d_xy[0]\n                    B[1, 2 * i + 1] = dN_d_xy[1]\n                    B[2, 2 * i] = dN_d_xy[1]\n                    B[2, 2 * i + 1] = dN_d_xy[0]\n\n                if use_b_bar:\n                    B_bar = P_dev @ B + 0.5 * q @ Theta.reshape(1, 8)\n                    Ke += B_bar.T @ D @ B_bar * w * detJ\n                else:\n                    Ke += B.T @ D @ B * w * detJ\n\n        dof_indices = np.c_[2 * el_nodes, 2 * el_nodes + 1].flatten()\n        K[np.ix_(dof_indices, dof_indices)] += Ke\n\n    # 3. Apply Boundary Conditions and Loads\n    F = np.zeros(num_dofs)\n    hx, hy = L / nx, L / ny\n    for i in range(nx): # Bottom edge y=0, n=(0,-1), t=(0,p0)\n        n1, n2 = i, i+1; F[2*n1+1]+=p0*hx/2; F[2*n2+1]+=p0*hx/2\n    for i in range(nx): # Top edge y=L, n=(0,1), t=(0,-p0)\n        n1, n2 = i+ny*num_nodes_x, i+1+ny*num_nodes_x; F[2*n1+1]-=p0*hx/2; F[2*n2+1]-=p0*hx/2\n    for j in range(ny): # Left edge x=0, n=(-1,0), t=(p0,0)\n        n1, n2 = j*num_nodes_x, (j+1)*num_nodes_x; F[2*n1]+=p0*hy/2; F[2*n2]+=p0*hy/2\n    for j in range(ny): # Right edge x=L, n=(1,0), t=(-p0,0)\n        n1, n2 = nx+j*num_nodes_x, nx+(j+1)*num_nodes_x; F[2*n1]-=p0*hy/2; F[2*n2]-=p0*hy/2\n\n    bc_dofs = []\n    bc_dofs.extend([0, 1])  # (0,0): u=0, v=0\n    bc_dofs.append(2 * nx + 1)  # (L,0): v=0\n    bc_dofs.append(2 * (ny * num_nodes_x)) # (0,L): u=0\n    \n    free_dofs = np.setdiff1d(np.arange(num_dofs), bc_dofs)\n    \n    U = np.zeros(num_dofs)\n    U[free_dofs] = np.linalg.solve(K[np.ix_(free_dofs, free_dofs)], F[free_dofs])\n\n    # 4. Post-processing and Error Calculation\n    e = -p0 / (2 * lame_lambda + 2 * lame_mu)\n    U_exact = np.array([e * c[0] if i % 2 == 0 else e * c[1] for i, c in enumerate(np.repeat(node_coords, 2, axis=0))])\n    \n    sum_u_exact_sq = np.sum(U_exact**2)\n    sum_u_err_sq = np.sum((U - U_exact)**2)\n    eta_u = np.sqrt(sum_u_err_sq / sum_u_exact_sq) if sum_u_exact_sq > 0 else 0\n\n    pressure_integral = 0\n    for el_nodes in elements:\n        el_coords = node_coords[el_nodes]\n        dof_indices = np.c_[2 * el_nodes, 2 * el_nodes + 1].flatten()\n        u_e = U[dof_indices]\n\n        if use_b_bar: # Recompute Theta needed for stress calculation\n            el_area = (L/nx)*(L/ny)\n            Theta_num = np.zeros(8)\n            for xi in gauss_points:\n                for eta in gauss_points:\n                    _, dN_dxi, dN_deta = get_shape_functions_and_derivs(xi, eta)\n                    J = np.vstack((dN_dxi, dN_deta)) @ el_coords\n                    detJ = np.linalg.det(J)\n                    B_gauss = np.zeros((3, 8))\n                    for i in range(4):\n                        dN_d_xy = np.linalg.solve(J.T, [dN_dxi[i], dN_deta[i]])\n                        B_gauss[0,2*i]=dN_d_xy[0]; B_gauss[1,2*i+1]=dN_d_xy[1]; B_gauss[2,2*i]=dN_d_xy[1]; B_gauss[2,2*i+1]=dN_d_xy[0]\n                    Theta_num += detJ * (m_T @ B_gauss)\n            Theta = Theta_num / el_area if el_area != 0 else np.zeros(8)\n            theta_bar_val = Theta @ u_e\n\n        for xi_idx, xi in enumerate(gauss_points):\n            for eta_idx, eta in enumerate(gauss_points):\n                w = gauss_weights[xi_idx] * gauss_weights[eta_idx]\n                _, dN_dxi, dN_deta = get_shape_functions_and_derivs(xi, eta)\n                J = np.vstack((dN_dxi, dN_deta)) @ el_coords\n                detJ = np.linalg.det(J)\n                \n                B = np.zeros((3, 8))\n                for i in range(4):\n                    dN_d_xy = np.linalg.solve(J.T, [dN_dxi[i], dN_deta[i]])\n                    B[0,2*i]=dN_d_xy[0]; B[1,2*i+1]=dN_d_xy[1]; B[2,2*i]=dN_d_xy[1]; B[2,2*i+1]=dN_d_xy[0]\n\n                if use_b_bar:\n                    strain = (P_dev @ B @ u_e) + (0.5 * q.flatten() * theta_bar_val)\n                else:\n                    strain = B @ u_e\n                \n                stress = D @ strain\n                pressure_integral += (stress[0] + stress[1]) * w * detJ\n                \n    avg_p = -0.5 * pressure_integral / (L*L)\n    eta_p = abs(avg_p - p0) / p0 if p0 != 0 else 0\n\n    return eta_u, eta_p\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        (2, 2, 0.3),\n        (2, 2, 0.4999),\n        (4, 4, 0.4999),\n    ]\n    E = 1.0\n    p0 = 1.0\n    L = 1.0\n    results = []\n\n    for nx, ny, nu in test_cases:\n        # Standard Q4 element\n        eta_u_std, eta_p_std = solve_fem_system(nx, ny, E, nu, p0, L, use_b_bar=False)\n        # B-bar modified Q4 element\n        eta_u_bbar, eta_p_bbar = solve_fem_system(nx, ny, E, nu, p0, L, use_b_bar=True)\n        \n        results.extend([eta_u_std, eta_u_bbar, eta_p_std, eta_p_bbar])\n\n    print(f\"[{','.join(f'{r:.6e}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "为了将我们的理解从理想化的测试扩展到更具挑战性的工程场景，我们现在来解决一个悬臂梁弯曲问题。这个问题  不仅能让您在一个受剪切和弯曲共同主导的变形模式中应用B-bar方法，还将引导您实现并比较另一种常见的锁定补救措施——J-bar方法（或选择性减缩积分）。通过定义和计算具体的性能指标，您将学会如何定量评估和比较不同单元技术的有效性。",
            "id": "3545765",
            "problem": "考虑在各向同性线弹性环境下，基于平面应变运动学的二维悬臂梁的准静态、小应变弯曲问题。设梁占据矩形区域 $\\Omega = [0,L] \\times [0,H]$，厚度为 $1$。左边界 $x=0$ 为完全夹持，满足 $u_x = 0$ 和 $u_y = 0$，并在右边界 $x=L$ 上施加均匀的竖向（向下）面力 $t_y = -q$。忽略体积力。使用标准的等参映射四节点双线性四边形单元（记为 $\\mathrm{Q4}$）。\n\n基本方程包括：\n- 无惯性力和体积力时的线性动量平衡：$\\nabla \\cdot \\boldsymbol{\\sigma} = \\boldsymbol{0}$。\n- 小应变运动学：$\\boldsymbol{\\varepsilon} = \\tfrac{1}{2}(\\nabla \\boldsymbol{u} + (\\nabla \\boldsymbol{u})^\\top)$，其中 $\\boldsymbol{u} = (u_x,u_y)$。\n- 基于 Lamé 参数 $\\lambda$ 和 $\\mu$ 的各向同性线弹性，以及平面应变本构律：$\\boldsymbol{\\sigma} = \\lambda \\,\\mathrm{tr}(\\boldsymbol{\\varepsilon})\\boldsymbol{I} + 2\\mu\\,\\boldsymbol{\\varepsilon}$，其中 $\\lambda = \\dfrac{E\\nu}{(1+\\nu)(1-2\\nu)}$ 且 $\\mu = \\dfrac{E}{2(1+\\nu)}$。体积模量为 $\\kappa = \\lambda + \\dfrac{2}{3}\\mu$。\n- 采用双线性形函数的标准 $\\mathrm{Q4}$ 有限元法，并对单元矩阵使用完全积分（$2\\times 2$ Gauss 积分）。\n\n当材料接近不可压缩时，即泊松比 $\\nu$ 趋近于 $0.5$ 时，会导致 $\\kappa \\gg \\mu$，此时可能发生体积闭锁。本问题着重于使用 $B$-bar 和 $J$-bar 方法的补救措施，以及如何通过可量化的度量标准来评估闭锁现象。\n\n您必须实现两种补救方法：\n1. $B$-bar 方法：将 Gauss 点处的体积应变 $\\varepsilon_{\\mathrm{vol}} = \\mathrm{tr}(\\boldsymbol{\\varepsilon})$ 替换为单元平均值 $\\overline{\\varepsilon}_{\\mathrm{vol}}$，从而得到修正后的单元体积刚度，形式如下\n$$\n\\mathbf{K}_{\\mathrm{vol}}^{(e)} = \\kappa \\, \\Omega_e \\, \\mathbf{B}_{\\mathrm{vol,mean}}^\\top \\mathbf{B}_{\\mathrm{vol,mean}},\n$$\n其中 $\\Omega_e$ 是单元面积，$\\mathbf{B}_{\\mathrm{vol,mean}}$ 将节点位移映射到单元平均体积应变，定义为\n$$\n\\mathbf{B}_{\\mathrm{vol,mean}} = \\frac{1}{\\Omega_e} \\int_{\\Omega_e} \\mathbf{B}_{\\mathrm{vol}} \\, \\mathrm{d}\\Omega,\n\\quad\n\\mathbf{B}_{\\mathrm{vol}} \\boldsymbol{u}_e = \\varepsilon_{\\mathrm{vol}}.\n$$\n\n2. $J$-bar 方法（小应变模拟）：在单元中心使用单点积分计算体积刚度，同时对偏量项保留完全积分，即\n$$\n\\mathbf{K}_{\\mathrm{vol}}^{(e)} = \\kappa \\, w_c \\, J_c \\, \\mathbf{B}_{\\mathrm{vol,c}}^\\top \\mathbf{B}_{\\mathrm{vol,c}},\n$$\n其中 $\\mathbf{B}_{\\mathrm{vol,c}}$ 是单元中心的体积应变-位移行向量，$J_c$ 是中心的雅可比行列式，$w_c=4$ 是对应于双单位正方形映射的 $1\\times 1$ Gauss 权重。\n\n将本构刚度分解为偏量和体积两部分，以隔离体积闭锁机制。在平面应变条件下，使用 Voigt 记法，其中 $\\boldsymbol{\\varepsilon}_v=[\\varepsilon_{xx},\\varepsilon_{yy},\\gamma_{xy}]^\\top$，采用以下偏量矩阵\n$$\n\\mathbf{C}_{\\mathrm{dev}} =\n\\begin{bmatrix}\n\\dfrac{4\\mu}{3}  -\\dfrac{2\\mu}{3}  0 \\\\\n-\\dfrac{2\\mu}{3}  \\dfrac{4\\mu}{3}  0 \\\\\n0  0  \\mu\n\\end{bmatrix},\n$$\n以及体积能量密度 $\\kappa \\, \\varepsilon_{\\mathrm{vol}}^2$，其中 $\\varepsilon_{\\mathrm{vol}} = \\varepsilon_{xx} + \\varepsilon_{yy}$。按如下方式组装全局刚度\n$$\n\\mathbf{K} = \\mathbf{K}_{\\mathrm{dev}} + \\mathbf{K}_{\\mathrm{vol}},\n\\quad\n\\mathbf{K}_{\\mathrm{dev}} = \\int_{\\Omega} \\mathbf{B}^\\top \\mathbf{C}_{\\mathrm{dev}} \\mathbf{B} \\,\\mathrm{d}\\Omega,\n$$\n其中 $\\mathbf{K}_{\\mathrm{dev}}$ 采用 $2\\times 2$ Gauss 积分，而 $\\mathbf{K}_{\\mathrm{vol}}$ 则根据所选方法（$B$-bar 或 $J$-bar）计算。\n\n使用以下显式闭锁评估度量：\n- 度量 M1（边界挠度）：在加载边界 $x=L$ 处的平均竖向位移，定义为\n$$\n\\overline{v}_{\\mathrm{edge}} = \\frac{1}{N_R}\\sum_{i\\in \\Gamma_R} v_i,\n$$\n其中 $\\Gamma_R$ 是 $x=L$ 处的节点集合，$N_R$ 是其基数，$v_i$ 是节点 $i$ 处的 $u_y$ 位移。以米为单位报告此值，并四舍五入至六位小数。\n\n- 度量 M2（体积能分数）：体积应变能与总应变能之比，\n$$\n\\eta_{\\mathrm{vol}} = \\frac{U_{\\mathrm{vol}}}{U_{\\mathrm{tot}}},\n\\quad\nU_{\\mathrm{tot}} = \\tfrac{1}{2} \\boldsymbol{u}^\\top \\mathbf{K} \\boldsymbol{u},\n$$\n且 $U_{\\mathrm{vol}}$ 的组装方式与所选方法一致，即对每个单元\n$$\nU_{\\mathrm{vol}}^{(e)} =\n\\begin{cases}\n\\tfrac{1}{2}\\kappa \\,\\Omega_e \\left(\\mathbf{B}_{\\mathrm{vol,mean}}\\boldsymbol{u}_e\\right)^2,  \\text{B-bar} \\\\\n\\tfrac{1}{2}\\kappa \\, w_c J_c \\left(\\mathbf{B}_{\\mathrm{vol,c}}\\boldsymbol{u}_e\\right)^2,  \\text{J-bar}\n\\end{cases}\n$$\n将 $\\eta_{\\mathrm{vol}}$ 报告为无单位小数，并四舍五入至六位小数。\n\n- 度量 M3（体积应变振荡）：体积应变与其单元平均值偏差的均方根，\n$$\nr_{\\mathrm{vol}} = \\sqrt{\\frac{\\sum_{e}\\sum_{g} w_g J_g \\left(\\varepsilon_{\\mathrm{vol},g}^{(e)} - \\overline{\\varepsilon}_{\\mathrm{vol}}^{(e)}\\right)^2}{\\sum_e \\Omega_e}},\n\\quad\n\\overline{\\varepsilon}_{\\mathrm{vol}}^{(e)} = \\frac{1}{\\Omega_e}\\sum_{g} w_g J_g \\varepsilon_{\\mathrm{vol},g}^{(e)},\n$$\n其中 $g$ 索引单元 $e$ 中的 $2\\times 2$ Gauss 点。将 $r_{\\mathrm{vol}}$ 报告为无单位小数，并四舍五入至六位小数。\n\n实现有限元组装、边界条件和两种补救方法，然后计算 $B$-bar 和 $J$-bar 方法下的三种度量。\n\n测试套件：\n使用以下参数集来运行求解器，涵盖一个典型的近不可压缩案例、一个严重闭锁案例和一个基准可压缩案例。所有量均采用国际单位制（SI）。\n\n- 案例 1（典型的近不可压缩弯曲）：$L=4\\,\\mathrm{m}$，$H=1\\,\\mathrm{m}$，$E=1.0\\times 10^{6}\\,\\mathrm{Pa}$，$\\nu=0.499$，$q=1.0\\times 10^{3}\\,\\mathrm{N/m}$，网格 $n_x=8$，$n_y=4$。\n\n- 案例 2（严重闭锁趋势，粗网格）：$L=4\\,\\mathrm{m}$，$H=1\\,\\mathrm{m}$，$E=1.0\\times 10^{6}\\,\\mathrm{Pa}$，$\\nu=0.4999$，$q=1.0\\times 10^{3}\\,\\mathrm{N/m}$，网格 $n_x=2$，$n_y=1$。\n\n- 案例 3（基准中度可压缩）：$L=4\\,\\mathrm{m}$，$H=1\\,\\mathrm{m}$，$E=1.0\\times 10^{6}\\,\\mathrm{Pa}$，$\\nu=0.3$，$q=1.0\\times 10^{3}\\,\\mathrm{N/m}$，网格 $n_x=2$，$n_y=1$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。对于每个测试案例，按以下顺序输出一个包含六个项目的列表：$[\\overline{v}_{\\mathrm{edge},B\\text{-}\\mathrm{bar}},\\overline{v}_{\\mathrm{edge},J\\text{-}\\mathrm{bar}},\\eta_{\\mathrm{vol},B\\text{-}\\mathrm{bar}},\\eta_{\\mathrm{vol},J\\text{-}\\mathrm{bar}},r_{\\mathrm{vol},B\\text{-}\\mathrm{bar}},r_{\\mathrm{vol},J\\text{-}\\mathrm{bar}}]$。所有六个值都必须是四舍五入到六位小数的浮点数。将三个测试案例的列表聚合成一个列表，不含空格，例如：\"[[vB1,vJ1,etaB1,etaJ1,rB1,rJ1],[vB2,...],[vB3,...]]\"。",
            "solution": "此问题是有效的，因为它提出了一个在计算固体力学领域中定义明确且具有科学依据的任务。它自成体系，为实现平面应变悬臂梁问题的有限元解提供了所有必需的数据、方程和定义。问题的核心——评估体积闭锁及其补救措施（$B$-bar 和 $J$-bar 方法）——是该领域的标准且重要的课题。所提供的方程、边界条件和评估度量是一致的，能够得出一个唯一的、可验证的解。\n\n在此，将详细介绍有限元实现的具体方法。\n\n### 1. 有限元离散化\n问题域 $\\Omega = [0,L] \\times [0,H]$ 被离散化为 $n_x \\times n_y$ 个四节点双线性四边形（$\\mathrm{Q4}$）单元组成的结构化网格。每个单元 $\\Omega_e$ 内的位移场 $\\boldsymbol{u}(x,y)$ 使用等参形函数 $N_i(\\xi, \\eta)$ 进行近似：\n$$\n\\boldsymbol{u}(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) \\boldsymbol{u}_i, \\quad \\boldsymbol{x}(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) \\boldsymbol{x}_i\n$$\n其中 $\\boldsymbol{u}_i$ 和 $\\boldsymbol{x}_i$ 分别是节点位移和坐标，$(\\xi, \\eta)$ 是在双单位正方形 $[-1,1]^2$ 中的母坐标。形函数由 $N_1=\\tfrac{1}{4}(1-\\xi)(1-\\eta)$、$N_2=\\tfrac{1}{4}(1+\\xi)(1-\\eta)$、$N_3=\\tfrac{1}{4}(1+\\xi)(1+\\eta)$ 和 $N_4=\\tfrac{1}{4}(1-\\xi)(1+\\eta)$ 给出。\n\n小应变张量 $\\boldsymbol{\\varepsilon}$ 通过应变-位移矩阵 $\\mathbf{B}$ 与节点位移 $\\boldsymbol{d}_e$ 相关联：\n$$\n\\boldsymbol{\\varepsilon}_v = \\mathbf{B} \\boldsymbol{d}_e, \\quad \\text{where} \\quad \\boldsymbol{\\varepsilon}_v = [\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}]^\\top\n$$\n矩阵 $\\mathbf{B}$ 由形函数的空间导数导出。形函数关于物理坐标 $(x,y)$ 的导数通过链式法则和雅可比矩阵 $\\mathbf{J}$ 的逆矩阵获得：\n$$\n\\begin{Bmatrix} \\frac{\\partial N_i}{\\partial x} \\\\ \\frac{\\partial N_i}{\\partial y} \\end{Bmatrix} = \\mathbf{J}^{-1} \\begin{Bmatrix} \\frac{\\partial N_i}{\\partial \\xi} \\\\ \\frac{\\partial N_i}{\\partial \\eta} \\end{Bmatrix}, \\quad \\mathbf{J} = \\begin{bmatrix} \\partial x / \\partial \\xi  \\partial y / \\partial \\xi \\\\ \\partial x / \\partial \\eta  \\partial y / \\partial \\eta \\end{bmatrix}\n$$\n因此，一个 $\\mathrm{Q4}$ 单元的 $3 \\times 8$ 矩阵 $\\mathbf{B}$ 构建如下：\n$$\n\\mathbf{B}_i = \\begin{bmatrix} \\frac{\\partial N_i}{\\partial x}  0 \\\\ 0  \\frac{\\partial N_i}{\\partial y} \\\\ \\frac{\\partial N_i}{\\partial y}  \\frac{\\partial N_i}{\\partial x} \\end{bmatrix}, \\quad \\mathbf{B} = [\\mathbf{B}_1, \\mathbf{B}_2, \\mathbf{B}_3, \\mathbf{B}_4]\n$$\n\n### 2. 刚度矩阵分解与组装\n虚功原理导出线性方程组 $\\mathbf{K}\\boldsymbol{u}=\\mathbf{F}$，其中 $\\mathbf{K}$ 是全局刚度矩阵，$\\boldsymbol{u}$ 是全局节点位移向量，$\\mathbf{F}$ 是全局力向量。刚度矩阵被加法分解为偏量和体积两部分：$\\mathbf{K} = \\mathbf{K}_{\\mathrm{dev}} + \\mathbf{K}_{\\mathrm{vol}}$。\n\n单位厚度的单元刚度矩阵为 $\\mathbf{K}^{(e)} = \\int_{\\Omega_e} \\mathbf{B}^\\top \\mathbf{C} \\mathbf{B} \\, \\mathrm{d}\\Omega$，其中 $\\mathbf{C}$ 是平面应变的本构矩阵。将 $\\mathbf{C}$ 分解为 $\\mathbf{C}_{\\mathrm{dev}}$ 和 $\\mathbf{C}_{\\mathrm{vol}}$ 允许对刚度部分进行分开组装。积分通过在母单元上使用 Gauss 求积进行数值计算：\n$$\n\\mathbf{K}^{(e)} = \\int_{-1}^{1}\\int_{-1}^{1} \\mathbf{B}^\\top \\mathbf{C} \\mathbf{B} \\, \\det(\\mathbf{J}) \\, \\mathrm{d}\\xi \\mathrm{d}\\eta \\approx \\sum_{g} w_g \\, \\mathbf{B}_g^\\top \\mathbf{C}_g \\mathbf{B}_g \\det(\\mathbf{J}_g)\n$$\n其中 $g$ 索引 Gauss 点，$w_g$ 是求积权重。\n\n#### 偏刚度 $\\mathbf{K}_{\\mathrm{dev}}$\n偏刚度按照规定使用完全 $2 \\times 2$ Gauss 求积计算：\n$$\n\\mathbf{K}_{\\mathrm{dev}}^{(e)} = \\sum_{g=1}^{4} w_g \\, \\mathbf{B}_g^\\top \\mathbf{C}_{\\mathrm{dev}} \\mathbf{B}_g \\det(\\mathbf{J}_g)\n$$\n使用所提供的偏量本构矩阵 $\\mathbf{C}_{\\mathrm{dev}}$。\n\n#### 体积刚度 $\\mathbf{K}_{\\mathrm{vol}}$\n实现了两种计算体积刚度的方法，两者都旨在缓解闭锁。本构响应的体积部分与能量密度 $\\tfrac{1}{2}\\kappa \\varepsilon_{\\mathrm{vol}}^2$ 相关，其中 $\\varepsilon_{\\mathrm{vol}} = \\varepsilon_{xx} + \\varepsilon_{yy}$。应变 $\\varepsilon_{\\mathrm{vol}}$ 通过行向量 $\\mathbf{B}_{\\mathrm{vol}} = [1, 1, 0]\\mathbf{B}$ 与节点位移相关联。\n\n1.  **$J$-bar 方法（选择性减缩积分）：** 体积刚度通过在单元中心 $(\\xi, \\eta)=(0,0)$ 使用单个 Gauss 点进行积分。对于双单位正方形，相应的权重为 $w_c=4$。\n    $$\n    \\mathbf{K}_{\\mathrm{vol}, J}^{(e)} = \\kappa \\left( \\mathbf{B}_{\\mathrm{vol,c}}^\\top \\mathbf{B}_{\\mathrm{vol,c}} \\right) w_c \\det(\\mathbf{J}_c)\n    $$\n    其中下标 $c$ 表示在单元中心进行评估。\n\n2.  **$B$-bar 方法：** 此方法用单元平均的体积应变-位移算子 $\\mathbf{B}_{\\mathrm{vol,mean}}$ 替换局部的 $\\mathbf{B}_{\\mathrm{vol}}$。\n    $$\n    \\mathbf{B}_{\\mathrm{vol,mean}} = \\frac{1}{\\Omega_e} \\int_{\\Omega_e} \\mathbf{B}_{\\mathrm{vol}} \\, \\mathrm{d}\\Omega = \\frac{\\sum_{g=1}^{4} w_g \\mathbf{B}_{\\mathrm{vol},g} \\det(\\mathbf{J}_g)}{\\sum_{g=1}^{4} w_g \\det(\\mathbf{J}_g)}\n    $$\n    然后单元体积刚度构建如下：\n    $$\n    \\mathbf{K}_{\\mathrm{vol}, B}^{(e)} = \\kappa \\, \\Omega_e \\, \\mathbf{B}_{\\mathrm{vol,mean}}^\\top \\mathbf{B}_{\\mathrm{vol,mean}}\n    $$\n    其中 $\\Omega_e = \\sum_{g=1}^{4} w_g \\det(\\mathbf{J}_g)$ 是使用完全积分计算的单元面积。\n\n### 3. 力向量和边界条件\n在右边界（$x=L$）上施加均匀面力 $t_y = -q$。通过在该边界上沿每个单元边对面力与形函数进行积分来组装一致节点力向量 $\\mathbf{F}$。对于矩形单元上长度为 $h_e$ 的垂直边，总垂直力 $-q h_e$ 平均分配给该边上的两个节点，每个节点贡献 $-q h_e / 2$。\n\n通过应用罚函数法来施加 $x=0$ 处的夹持边界条件（$u_x = 0, u_y = 0$）。将一个大数加到全局刚度矩阵中与约束自由度相对应的对角线项上。\n\n### 4. 闭锁评估度量\n在求解位移向量 $\\boldsymbol{u}_B$ 和 $\\boldsymbol{u}_J$ 的方程组 $(\\mathbf{K}_{\\mathrm{dev}} + \\mathbf{K}_{\\mathrm{vol},B})\\boldsymbol{u}_B = \\mathbf{F}$ 和 $(\\mathbf{K}_{\\mathrm{dev}} + \\mathbf{K}_{\\mathrm{vol},J})\\boldsymbol{u}_J = \\mathbf{F}$ 后，为每个解计算以下度量：\n\n-   **M1（边界挠度）：** 加载边界 $x=L$ 上节点的平均竖向位移 $\\overline{v}_{\\mathrm{edge}}$。该度量直接显示了闭锁的人为刚化效应；一个闭锁的单元结构挠度会更小。\n\n-   **M2（体积能分数）：** 比率 $\\eta_{\\mathrm{vol}} = U_{\\mathrm{vol}}/U_{\\mathrm{tot}}$。总应变能为 $U_{\\mathrm{tot}} = \\tfrac{1}{2}\\boldsymbol{u}^\\top\\mathbf{F}$。体积应变能 $U_{\\mathrm{vol}}$ 是对所有单元求和得到的，其计算公式与所用方法（B-bar 或 J-bar）一致。在易于闭锁的情况下，由于单元过度抵抗体积变化，该比率会变得异常高。\n\n-   **M3（体积应变振荡）：** 度量 $r_{\\mathrm{vol}}$ 量化了体积应变场中非物理的、单元级别的振荡，这是闭锁的典型症状。它是点态体积应变（在 $2 \\times 2$ Gauss 点处）与单元平均体积应变偏差的均方根。高值表示单元内部存在显著的、非物理的应变变化。\n$$\nr_{\\mathrm{vol}} = \\sqrt{\\frac{\\sum_{e}\\sum_{g} w_g \\det(\\mathbf{J}_g) \\left(\\varepsilon_{\\mathrm{vol},g}^{(e)} - \\overline{\\varepsilon}_{\\mathrm{vol}}^{(e)}\\right)^2}{\\sum_e \\Omega_e}}\n$$\n其中 $\\varepsilon_{\\mathrm{vol},g}^{(e)}$ 是根据求解出的位移场 $\\boldsymbol{u}$，在每个 Gauss 点 $g$ 处使用标准的 $\\mathbf{B}_{\\mathrm{vol}, g}$ 计算得出的。\n\n这三个度量提供了对体积闭锁以及所实施补救措施有效性的全面、定量的评估。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main solver function that iterates through test cases and prints the final result.\n    \"\"\"\n    test_cases = [\n        # Case 1 (typical nearly incompressible bending)\n        {'L': 4.0, 'H': 1.0, 'E': 1.0e6, 'nu': 0.499, 'q': 1.0e3, 'nx': 8, 'ny': 4},\n        # Case 2 (severe locking tendency, coarse mesh)\n        {'L': 4.0, 'H': 1.0, 'E': 1.0e6, 'nu': 0.4999, 'q': 1.0e3, 'nx': 2, 'ny': 1},\n        # Case 3 (baseline moderately compressible)\n        {'L': 4.0, 'H': 1.0, 'E': 1.0e6, 'nu': 0.3, 'q': 1.0e3, 'nx': 2, 'ny': 1},\n    ]\n\n    results = []\n    for case in test_cases:\n        case_results = solve_case(**case)\n        results.append(case_results)\n\n    # Format output string to match requirements\n    # '[[vB1,vJ1,etaB1,etaJ1,rB1,rJ1],[vB2,...],[vB3,...]]'\n    output_str = str(results).replace(\" \", \"\")\n    print(output_str)\n\ndef solve_case(L, H, E, nu, q, nx, ny):\n    \"\"\"\n    Solves the FEM problem for a single set of parameters.\n    \"\"\"\n    # 1. Material properties and mesh generation\n    mu = E / (2 * (1 + nu))\n    lmbda = E * nu / ((1 + nu) * (1 - 2 * nu))\n    kappa = lmbda + 2/3 * mu\n    \n    C_dev = np.array([\n        [4/3 * mu, -2/3 * mu, 0],\n        [-2/3 * mu, 4/3 * mu, 0],\n        [0, 0, mu]\n    ])\n\n    num_nodes = (nx + 1) * (ny + 1)\n    num_elems = nx * ny\n    \n    node_coords = np.zeros((num_nodes, 2))\n    dx, dy = L / nx, H / ny\n    for j in range(ny + 1):\n        for i in range(nx + 1):\n            node_idx = j * (nx + 1) + i\n            node_coords[node_idx] = [i * dx, j * dy]\n\n    elem_conn = np.zeros((num_elems, 4), dtype=int)\n    for j in range(ny):\n        for i in range(nx):\n            elem_idx = j * nx + i\n            n1 = j * (nx + 1) + i\n            n2 = n1 + 1\n            n3 = n2 + nx + 1\n            n4 = n1 + nx + 1\n            elem_conn[elem_idx] = [n1, n2, n3, n4]\n            \n    # 2. FEM Preliminaries\n    # Gauss points and weights for 2x2 quadrature\n    gp = 1 / np.sqrt(3)\n    gauss_points_2x2 = np.array([[-gp, -gp], [gp, -gp], [gp, gp], [-gp, gp]])\n    gauss_weights_2x2 = np.array([1, 1, 1, 1])\n\n    def shape_functions(xi, eta):\n        N = 0.25 * np.array([\n            (1 - xi) * (1 - eta),\n            (1 + xi) * (1 - eta),\n            (1 + xi) * (1 + eta),\n            (1 - xi) * (1 + eta)\n        ])\n        return N\n\n    def shape_derivatives(xi, eta):\n        dNd_xi = 0.25 * np.array([\n            -(1 - eta), (1 - eta), (1 + eta), -(1 + eta)\n        ])\n        dNd_eta = 0.25 * np.array([\n            -(1 - xi), -(1 + xi), (1 + xi), (1 - xi)\n        ])\n        return dNd_xi, dNd_eta\n\n    # 3. Assembly\n    num_dofs = 2 * num_nodes\n    K_dev = np.zeros((num_dofs, num_dofs))\n    K_vol_B = np.zeros((num_dofs, num_dofs))\n    K_vol_J = np.zeros((num_dofs, num_dofs))\n    F = np.zeros(num_dofs)\n    \n    dofs_map = np.zeros((4, 2), dtype=int)\n\n    m_vec = np.array([1, 1, 0])\n\n    for el in range(num_elems):\n        node_indices = elem_conn[el]\n        el_coords = node_coords[node_indices]\n        \n        dofs_map[:, 0] = 2 * node_indices\n        dofs_map[:, 1] = 2 * node_indices + 1\n        dofs = dofs_map.flatten()\n\n        # Deviatoric stiffness (full 2x2 integration)\n        Ke_dev = np.zeros((8, 8))\n        \n        # For B-bar method\n        B_vol_int = np.zeros(8)\n        Omega_e = 0.0\n\n        for i in range(len(gauss_points_2x2)):\n            xi, eta = gauss_points_2x2[i]\n            w = gauss_weights_2x2[i]\n            \n            dNd_xi, dNd_eta = shape_derivatives(xi, eta)\n            \n            J_mat = np.zeros((2, 2))\n            J_mat[0, :] = dNd_xi @ el_coords\n            J_mat[1, :] = dNd_eta @ el_coords\n            detJ = np.linalg.det(J_mat)\n            invJ = np.linalg.inv(J_mat)\n            \n            B = np.zeros((3, 8))\n            for k in range(4):\n                dNd_xy = invJ @ np.array([dNd_xi[k], dNd_eta[k]])\n                B[0, 2*k] = dNd_xy[0]\n                B[1, 2*k+1] = dNd_xy[1]\n                B[2, 2*k] = dNd_xy[1]\n                B[2, 2*k+1] = dNd_xy[0]\n\n            Ke_dev += B.T @ C_dev @ B * detJ * w\n            \n            # Accumulate for B-bar\n            B_vol = m_vec @ B\n            B_vol_int += B_vol * detJ * w\n            Omega_e += detJ * w\n\n        K_dev[np.ix_(dofs, dofs)] += Ke_dev\n\n        # B-bar volumetric stiffness\n        B_vol_mean = B_vol_int / Omega_e\n        Ke_vol_B = kappa * Omega_e * np.outer(B_vol_mean, B_vol_mean)\n        K_vol_B[np.ix_(dofs, dofs)] += Ke_vol_B\n\n        # J-bar volumetric stiffness (1-point integration)\n        xi_c, eta_c = 0.0, 0.0\n        dNd_xi_c, dNd_eta_c = shape_derivatives(xi_c, eta_c)\n        J_mat_c = np.zeros((2, 2))\n        J_mat_c[0, :] = dNd_xi_c @ el_coords\n        J_mat_c[1, :] = dNd_eta_c @ el_coords\n        detJ_c = np.linalg.det(J_mat_c)\n        invJ_c = np.linalg.inv(J_mat_c)\n        \n        B_c = np.zeros((3, 8))\n        for k in range(4):\n            dNd_xy_c = invJ_c @ np.array([dNd_xi_c[k], dNd_eta_c[k]])\n            B_c[0, 2 * k] = dNd_xy_c[0]\n            B_c[1, 2 * k + 1] = dNd_xy_c[1]\n            B_c[2, 2 * k] = dNd_xy_c[1]\n            B_c[2, 2 * k + 1] = dNd_xy_c[0]\n        \n        B_vol_c = m_vec @ B_c\n        w_c = 4.0 # For bi-unit square\n        Ke_vol_J = kappa * w_c * detJ_c * np.outer(B_vol_c, B_vol_c)\n        K_vol_J[np.ix_(dofs, dofs)] += Ke_vol_J\n    \n    # Force vector\n    for j in range(ny):\n        elem_idx = (j + 1) * nx - 1\n        nodes = elem_conn[elem_idx]\n        dof_y1 = 2 * nodes[1] + 1\n        dof_y2 = 2 * nodes[2] + 1\n        force_per_node = -q * dy / 2.0\n        F[dof_y1] += force_per_node\n        F[dof_y2] += force_per_node\n\n    # 4. Boundary Conditions\n    K_B = K_dev + K_vol_B\n    K_J = K_dev + K_vol_J\n    \n    penalty = 1e10 * np.max(np.abs(K_B.diagonal())) \n    clamped_nodes = np.where(node_coords[:, 0] == 0)[0]\n    for node_idx in clamped_nodes:\n        dof1 = 2 * node_idx\n        dof2 = 2 * node_idx + 1\n        K_B[dof1, dof1] += penalty\n        K_B[dof2, dof2] += penalty\n        K_J[dof1, dof1] += penalty\n        K_J[dof2, dof2] += penalty\n\n    # 5. Solve\n    u_B = np.linalg.solve(K_B, F)\n    u_J = np.linalg.solve(K_J, F)\n\n    # 6. Post-processing - Metrics\n    def calculate_metrics(u_sol, K_vol_method):\n        # M1: Edge deflection\n        right_edge_nodes = np.where(node_coords[:, 0] == L)[0]\n        right_edge_dofs_y = 2 * right_edge_nodes + 1\n        v_edge = np.mean(u_sol[right_edge_dofs_y])\n        \n        # M2: Volumetric energy fraction\n        U_tot = 0.5 * u_sol @ F\n        U_vol = 0.5 * u_sol @ (K_vol_method @ u_sol)\n        eta_vol = U_vol / U_tot if U_tot != 0 else 0\n\n        # M3: Volumetric strain oscillation\n        total_volume = 0\n        osc_numerator = 0\n        for el in range(num_elems):\n            node_indices = elem_conn[el]\n            el_coords = node_coords[node_indices]\n            dofs_map[:, 0] = 2 * node_indices\n            dofs_map[:, 1] = 2 * node_indices + 1\n            dofs = dofs_map.flatten()\n            u_e = u_sol[dofs]\n\n            # Calculate mean vol strain with 2x2 Gauss\n            vol_strain_sum = 0\n            Omega_e = 0\n            strains_at_gp = []\n            \n            for i in range(len(gauss_points_2x2)):\n                xi, eta = gauss_points_2x2[i]\n                w = gauss_weights_2x2[i]\n                \n                dNd_xi, dNd_eta = shape_derivatives(xi, eta)\n                J_mat = np.zeros((2, 2))\n                J_mat[0, :] = dNd_xi @ el_coords\n                J_mat[1, :] = dNd_eta @ el_coords\n                detJ = np.linalg.det(J_mat)\n                invJ = np.linalg.inv(J_mat)\n                \n                B = np.zeros((3, 8))\n                for k in range(4):\n                    dNd_xy = invJ @ np.array([dNd_xi[k], dNd_eta[k]])\n                    B[0, 2*k] = dNd_xy[0]\n                    B[1, 2*k+1] = dNd_xy[1]\n                    B[2, 2*k] = dNd_xy[1]\n                    B[2, 2*k+1] = dNd_xy[0]\n\n                eps_vol_g = (m_vec @ B) @ u_e\n                strains_at_gp.append((eps_vol_g, w, detJ))\n                vol_strain_sum += eps_vol_g * detJ * w\n                Omega_e += detJ * w\n            \n            eps_vol_mean = vol_strain_sum / Omega_e if Omega_e != 0 else 0\n            total_volume += Omega_e\n            \n            # Sum for numerator\n            for eps_vol_g, w, detJ in strains_at_gp:\n                osc_numerator += w * detJ * (eps_vol_g - eps_vol_mean)**2\n        \n        r_vol = np.sqrt(osc_numerator / total_volume) if total_volume != 0 else 0\n        \n        return round(v_edge, 6), round(eta_vol, 6), round(r_vol, 6)\n\n    v_B, eta_B, r_B = calculate_metrics(u_B, K_vol_B)\n    v_J, eta_J, r_J = calculate_metrics(u_J, K_vol_J)\n    \n    return [v_B, v_J, eta_B, eta_J, r_B, r_J]\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}