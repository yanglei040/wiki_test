{
    "hands_on_practices": [
        {
            "introduction": "The cornerstone of the updated Lagrangian (UL) formulation is the multiplicative update of the deformation gradient, where the total deformation is composed from a sequence of incremental steps. This exercise provides fundamental practice in applying this core concept, requiring you to compute the incremental deformation gradient $\\mathbf{f}$ from nodal displacements and use it to update the total deformation gradient from step $n$ to step $n+1$ .",
            "id": "3608832",
            "problem": "In the updated Lagrangian (UL) finite element formulation for large deformations, the current configuration at time step $n$ is taken as the reference for the incremental update from step $n$ to step $n+1$. Consider a single four-node linear tetrahedral element whose nodal coordinates at step $n$ (the current configuration) are given by\n$$\n\\mathbf{x}_{1}^{(n)} = (0, 0, 0),\\quad\n\\mathbf{x}_{2}^{(n)} = (1, 0, 0),\\quad\n\\mathbf{x}_{3}^{(n)} = (0, 1, 0),\\quad\n\\mathbf{x}_{4}^{(n)} = (0, 0, 1).\n$$\nAt the same step, the incremental nodal displacements from $n$ to $n+1$ are\n$$\n\\Delta \\mathbf{u}_{1} = (0, 0, 0),\\quad\n\\Delta \\mathbf{u}_{2} = (1, 2, -1),\\quad\n\\Delta \\mathbf{u}_{3} = (0, 1, 1),\\quad\n\\Delta \\mathbf{u}_{4} = (-2, 0, 3).\n$$\nAssume the standard $C^{0}$ linear shape functions defined over the element in the current configuration at step $n$, and assume the element is kinematically homogeneous so that the incremental deformation gradient is constant over the element when computed with these shape functions. The deformation gradient at step $n$ (taken as constant within the element) is\n$$\n\\mathbf{F}_{n} = \n\\begin{pmatrix}\n2 & 0 & 0\\\\\n0 & 1 & 0\\\\\n0 & 0 & \\tfrac{1}{2}\n\\end{pmatrix}.\n$$\nStarting from the kinematic definitions of the incremental mapping in the updated Lagrangian description, construct the elementwise incremental deformation gradient $\\mathbf{f}$ and compute the updated deformation gradient $\\mathbf{F}_{n+1}$ at the element centroid using the multiplicative update. Treat all quantities as nondimensional. Provide your final answer as the single $3\\times 3$ matrix $\\mathbf{F}_{n+1}$. No rounding is required.",
            "solution": "The updated Lagrangian formulation uses the configuration at time step $n$ as the reference for analyzing the motion to time step $n+1$. The total deformation gradient at step $n+1$, $\\mathbf{F}_{n+1}$, is related to the deformation gradient at step $n$, $\\mathbf{F}_{n}$, through the incremental deformation gradient, $\\mathbf{f}$, via a multiplicative decomposition:\n$$ \\mathbf{F}_{n+1} = \\mathbf{f} \\mathbf{F}_{n} $$\nThe incremental deformation gradient $\\mathbf{f}$ maps vectors from the configuration at step $n$ to the configuration at step $n+1$. It is defined in terms of the incremental displacement field $\\Delta\\mathbf{u}$ as:\n$$ \\mathbf{f} = \\mathbf{I} + \\nabla_n(\\Delta\\mathbf{u}) $$\nwhere $\\mathbf{I}$ is the second-order identity tensor and $\\nabla_n(\\Delta\\mathbf{u})$ is the spatial gradient of the incremental displacement field with respect to the coordinates in the current configuration, $\\mathbf{x}^{(n)}$.\n\nFor a finite element, the incremental displacement field is interpolated from the nodal incremental displacements $\\Delta\\mathbf{u}_I$ using the shape functions $N_I(\\mathbf{x}^{(n)})$:\n$$ \\Delta\\mathbf{u}(\\mathbf{x}^{(n)}) = \\sum_{I=1}^{4} N_I(\\mathbf{x}^{(n)}) \\Delta\\mathbf{u}_I $$\nThe gradient of this field is a sum of dyadic products, which in matrix form is:\n$$ \\nabla_n(\\Delta\\mathbf{u}) = \\sum_{I=1}^{4} \\Delta\\mathbf{u}_I (\\nabla_n N_I)^T $$\nThe element's nodal coordinates at step $n$ define a master or parent element, for which the shape functions are simply the barycentric coordinates. Let $\\mathbf{x} = (x, y, z)$ be the coordinates in the current configuration (we drop the superscript $(n)$ for brevity). The shape functions are:\n$$ N_1(x,y,z) = 1 - x - y - z $$\n$$ N_2(x,y,z) = x $$\n$$ N_3(x,y,z) = y $$\n$$ N_4(x,y,z) = z $$\nThe gradients of these shape functions with respect to $\\mathbf{x} = (x,y,z)^T$ are constant vectors:\n$$ \\nabla_n N_1 = \\begin{pmatrix} -1 \\\\ -1 \\\\ -1 \\end{pmatrix}, \\quad \\nabla_n N_2 = \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix}, \\quad \\nabla_n N_3 = \\begin{pmatrix} 0 \\\\ 1 \\\\ 0 \\end{pmatrix}, \\quad \\nabla_n N_4 = \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\end{pmatrix} $$\nNow we can compute the gradient of the incremental displacement field, $\\nabla_n(\\Delta\\mathbf{u})$, using the given incremental nodal displacements:\n$$ \\Delta\\mathbf{u}_1 = \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\end{pmatrix}, \\quad \\Delta\\mathbf{u}_2 = \\begin{pmatrix} 1 \\\\ 2 \\\\ -1 \\end{pmatrix}, \\quad \\Delta\\mathbf{u}_3 = \\begin{pmatrix} 0 \\\\ 1 \\\\ 1 \\end{pmatrix}, \\quad \\Delta\\mathbf{u}_4 = \\begin{pmatrix} -2 \\\\ 0 \\\\ 3 \\end{pmatrix} $$\nSince $\\Delta\\mathbf{u}_1 = \\mathbf{0}$, the first term is zero. We sum the contributions from the other nodes:\n$$\n\\nabla_n(\\Delta\\mathbf{u}) =\n\\begin{pmatrix} 1 \\\\ 2 \\\\ -1 \\end{pmatrix} \\begin{pmatrix} 1 & 0 & 0 \\end{pmatrix} +\n\\begin{pmatrix} 0 \\\\ 1 \\\\ 1 \\end{pmatrix} \\begin{pmatrix} 0 & 1 & 0 \\end{pmatrix} +\n\\begin{pmatrix} -2 \\\\ 0 \\\\ 3 \\end{pmatrix} \\begin{pmatrix} 0 & 0 & 1 \\end{pmatrix}\n$$\n$$\n\\nabla_n(\\Delta\\mathbf{u}) =\n\\begin{pmatrix} 1 & 0 & 0 \\\\ 2 & 0 & 0 \\\\ -1 & 0 & 0 \\end{pmatrix} +\n\\begin{pmatrix} 0 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 1 & 0 \\end{pmatrix} +\n\\begin{pmatrix} 0 & 0 & -2 \\\\ 0 & 0 & 0 \\\\ 0 & 0 & 3 \\end{pmatrix}\n$$\nSumming these matrices gives:\n$$\n\\nabla_n(\\Delta\\mathbf{u}) =\n\\begin{pmatrix}\n1 & 0 & -2 \\\\\n2 & 1 & 0 \\\\\n-1 & 1 & 3\n\\end{pmatrix}\n$$\nNext, we find the incremental deformation gradient $\\mathbf{f}$:\n$$\n\\mathbf{f} = \\mathbf{I} + \\nabla_n(\\Delta\\mathbf{u}) =\n\\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} +\n\\begin{pmatrix} 1 & 0 & -2 \\\\ 2 & 1 & 0 \\\\ -1 & 1 & 3 \\end{pmatrix} =\n\\begin{pmatrix} 2 & 0 & -2 \\\\ 2 & 2 & 0 \\\\ -1 & 1 & 4 \\end{pmatrix}\n$$\nFinally, we compute the updated deformation gradient $\\mathbf{F}_{n+1}$ using the multiplicative update rule, $\\mathbf{F}_{n+1} = \\mathbf{f} \\mathbf{F}_{n}$:\n$$\n\\mathbf{F}_{n+1} =\n\\begin{pmatrix} 2 & 0 & -2 \\\\ 2 & 2 & 0 \\\\ -1 & 1 & 4 \\end{pmatrix}\n\\begin{pmatrix} 2 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & \\frac{1}{2} \\end{pmatrix}\n$$\nPerforming the matrix multiplication:\n$$\n\\mathbf{F}_{n+1} =\n\\begin{pmatrix}\n(2)(2) + (0)(0) + (-2)(0) & (2)(0) + (0)(1) + (-2)(0) & (2)(0) + (0)(0) + (-2)(\\frac{1}{2}) \\\\\n(2)(2) + (2)(0) + (0)(0) & (2)(0) + (2)(1) + (0)(0) & (2)(0) + (2)(0) + (0)(\\frac{1}{2}) \\\\\n(-1)(2) + (1)(0) + (4)(0) & (-1)(0) + (1)(1) + (4)(0) & (-1)(0) + (1)(0) + (4)(\\frac{1}{2})\n\\end{pmatrix}\n$$\n$$\n\\mathbf{F}_{n+1} =\n\\begin{pmatrix}\n4 & 0 & -1 \\\\\n4 & 2 & 0 \\\\\n-2 & 1 & 2\n\\end{pmatrix}\n$$\nThis is the updated deformation gradient at step $n+1$.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n4 & 0 & -1 \\\\\n4 & 2 & 0 \\\\\n-2 & 1 & 2\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "While the UL formulation linearizes kinematics within each increment, its power lies in composing these small steps to accurately model large nonlinear deformations, especially large rotations. This computational benchmark illustrates the critical importance of this incremental approach . By comparing a single, large-step approximation against a multi-step procedure, you will see firsthand why the sequential updating inherent to the UL method is essential for maintaining accuracy.",
            "id": "3608872",
            "problem": "Consider a purely kinematic large rotation benchmark in the context of the Updated Lagrangian (UL) finite element formulation for computational solid mechanics. A homogeneous, deformable body in a $2$-dimensional ($2$D) setting undergoes a rigid rotation about the origin by a prescribed total angle $\\theta$ (in radians). The motion is characterized by the mapping $\\boldsymbol{x}(\\boldsymbol{X}, t)$ from the material (reference) coordinates $\\boldsymbol{X}$ to the spatial (current) coordinates $\\boldsymbol{x}$, and the deformation gradient $\\boldsymbol{F} = \\partial \\boldsymbol{x} / \\partial \\boldsymbol{X}$. In the UL framework, the incremental kinematics for one step from configuration $n$ to configuration $n+1$ obey the relation $\\boldsymbol{F}_{n+1} = (\\boldsymbol{I} + \\nabla_{\\boldsymbol{x}} \\Delta \\boldsymbol{u}) \\boldsymbol{F}_n$, where $\\boldsymbol{I}$ is the identity tensor and $\\nabla_{\\boldsymbol{x}} \\Delta \\boldsymbol{u}$ is the spatial displacement gradient over the increment.\n\nIn this benchmark, focus on the accuracy impact of increment size when the incremental rotation is approximated using a first-order (small-angle) linearization. Specifically, compare:\n\n- A single large step that applies the total angle $\\theta$ in one increment.\n- Multiple small steps that subdivide $\\theta$ into $N$ equal increments $\\Delta \\theta = \\theta / N$ and compose them multiplicatively.\n\nFor a rigid rotation in $2$D, the exact deformation gradient is the rotation matrix $\\boldsymbol{R}(\\theta)$, which serves as the ground truth. The first-order linearized incremental rotation uses the skew-symmetric generator $\\boldsymbol{W}(\\Delta \\theta)$ associated with the angular increment $\\Delta \\theta$ to approximate the incremental mapping by $(\\boldsymbol{I} + \\boldsymbol{W}(\\Delta \\theta))$ in each step. With one large step, this yields $\\boldsymbol{F}^{\\text{single}} = \\boldsymbol{I} + \\boldsymbol{W}(\\theta)$. With $N$ small steps, this yields $\\boldsymbol{F}^{\\text{multi}}(N) = (\\boldsymbol{I} + \\boldsymbol{W}(\\theta / N))^{N}$.\n\nYour task is to implement a program that, for each test case $(\\theta, N)$, computes the following two scalar error measures:\n- $e_{\\text{single}}(\\theta) = \\lVert \\boldsymbol{F}^{\\text{single}} - \\boldsymbol{R}(\\theta) \\rVert_F$,\n- $e_{\\text{multi}}(\\theta, N) = \\lVert \\boldsymbol{F}^{\\text{multi}}(N) - \\boldsymbol{R}(\\theta) \\rVert_F$,\nwhere $\\lVert \\cdot \\rVert_F$ denotes the Frobenius norm.\n\nUse the following test suite, with angles expressed in radians and $N$ as the number of equal increments:\n- $(\\theta, N) = (0, 8)$ to test the zero-rotation boundary case.\n- $(\\theta, N) = (\\pi / 2, 8)$ to test a moderate large rotation.\n- $(\\theta, N) = (\\pi, 32)$ to test a $180^\\circ$ rotation.\n- $(\\theta, N) = (2 \\pi, 64)$ to test a full $360^\\circ$ rotation.\n- $(\\theta, N) = (-\\pi / 3, 12)$ to test a negative rotation.\n\nYour program must:\n- Treat all angles in radians.\n- For each test case, compute $e_{\\text{single}}$ and $e_{\\text{multi}}$ as defined above.\n- Produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain the errors ordered by test case, with two floating-point numbers per test case: $[e_{\\text{single,case1}}, e_{\\text{multi,case1}}, e_{\\text{single,case2}}, e_{\\text{multi,case2}}, \\dots]$.\n\nNo external input is required. The output is dimensionless since it is a norm of a difference of matrices, and angles must be handled in radians throughout.",
            "solution": "The problem statement is confirmed to be valid as it represents a standard, well-posed, and scientifically grounded benchmark in computational solid mechanics. It is free of contradictions, ambiguities, or factual errors. We may therefore proceed with a formal solution.\n\nThe objective is to quantify the error resulting from a first-order linearization of a large rigid body rotation in a 2D space. This error is evaluated for two distinct numerical strategies within an Updated Lagrangian (UL) framework: a single incremental step encompassing the total rotation, and a sequence of multiple smaller incremental steps. The exact solution, which serves as the ground truth for error computation, is the pure rotation matrix.\n\nFirst, we define the key mathematical objects in a $2$-dimensional Cartesian coordinate system.\n\nThe exact deformation gradient, $\\boldsymbol{F}$, for a rigid body rotation by an angle $\\theta$ about the origin is given by the rotation matrix $\\boldsymbol{R}(\\theta)$. In $2$D, this is:\n$$\n\\boldsymbol{R}(\\theta) = \\begin{pmatrix} \\cos\\theta & -\\sin\\theta \\\\ \\sin\\theta & \\cos\\theta \\end{pmatrix}\n$$\nThis matrix represents the ground truth against which we will compare our approximations.\n\nThe problem states that the incremental rotation is approximated using a first-order Taylor expansion around the identity. The exact rotation over a small angle $\\Delta\\theta$ is $\\boldsymbol{R}(\\Delta\\theta)$. For small $\\Delta\\theta$, we have $\\cos(\\Delta\\theta) \\approx 1$ and $\\sin(\\Delta\\theta) \\approx \\Delta\\theta$. The first-order approximation of $\\boldsymbol{R}(\\Delta\\theta)$ is:\n$$\n\\boldsymbol{R}(\\Delta\\theta) \\approx \\boldsymbol{I} + \\boldsymbol{W}(\\Delta\\theta)\n$$\nwhere $\\boldsymbol{I}$ is the $2 \\times 2$ identity matrix and $\\boldsymbol{W}(\\Delta\\theta)$ is the skew-symmetric generator of the rotation group $SO(2)$:\n$$\n\\boldsymbol{I} = \\begin{pmatrix} 1 & 0 \\\\ 0 & 1 \\end{pmatrix}, \\quad \\boldsymbol{W}(\\Delta\\theta) = \\begin{pmatrix} 0 & -\\Delta\\theta \\\\ \\Delta\\theta & 0 \\end{pmatrix}\n$$\nThis linear approximation forms the basis of the two numerical schemes to be evaluated.\n\n**1. Single-Step Approximation**\n\nIn this approach, the entire rotation $\\theta$ is treated as a single incremental step. The approximation for the deformation gradient, denoted $\\boldsymbol{F}^{\\text{single}}$, is obtained by setting $\\Delta\\theta = \\theta$:\n$$\n\\boldsymbol{F}^{\\text{single}} = \\boldsymbol{I} + \\boldsymbol{W}(\\theta) = \\begin{pmatrix} 1 & -\\theta \\\\ \\theta & 1 \\end{pmatrix}\n$$\nThis is a very coarse approximation and is expected to be accurate only for $|\\theta| \\ll 1$.\n\n**2. Multi-Step Approximation**\n\nThis strategy subdivides the total rotation angle $\\theta$ into $N$ equal increments, each of size $\\Delta\\theta = \\theta / N$. The deformation gradient for one small increment is approximated as $\\boldsymbol{F}_{\\text{inc}} = \\boldsymbol{I} + \\boldsymbol{W}(\\Delta\\theta) = \\boldsymbol{I} + \\boldsymbol{W}(\\theta/N)$. In the UL formulation, the total deformation is the product of incremental deformations. Thus, the final deformation gradient, $\\boldsymbol{F}^{\\text{multi}}(N)$, is the result of composing these $N$ increments:\n$$\n\\boldsymbol{F}^{\\text{multi}}(N) = \\underbrace{(\\boldsymbol{I} + \\boldsymbol{W}(\\theta/N)) \\dots (\\boldsymbol{I} + \\boldsymbol{W}(\\theta/N))}_{N \\text{ times}} = \\left(\\boldsymbol{I} + \\boldsymbol{W}(\\theta/N)\\right)^N\n$$\nThis composition of small, linearized steps is a fundamental concept in geometric numerical integration. As $N \\to \\infty$, this expression converges to the matrix exponential of $\\boldsymbol{W}(\\theta)$:\n$$\n\\lim_{N \\to \\infty} \\left(\\boldsymbol{I} + \\frac{\\boldsymbol{W}(\\theta)}{N}\\right)^N = \\exp(\\boldsymbol{W}(\\theta))\n$$\nIt is a known property of Lie groups that the exponential of the generator gives the group element, i.e., $\\exp(\\boldsymbol{W}(\\theta)) = \\boldsymbol{R}(\\theta)$. Therefore, the multi-step approximation is expected to converge to the exact solution as the number of steps $N$ increases.\n\n**Error Quantification**\n\nThe error in each approximation is measured using the Frobenius norm of the difference between the approximate and the exact deformation gradients. The Frobenius norm of a matrix $\\boldsymbol{A}$ is given by $\\lVert \\boldsymbol{A} \\rVert_F = \\sqrt{\\sum_{i,j} A_{ij}^2}$.\n\nThe two error measures are:\n-   Single-step error: $e_{\\text{single}}(\\theta) = \\lVert \\boldsymbol{F}^{\\text{single}} - \\boldsymbol{R}(\\theta) \\rVert_F$\n-   Multi-step error: $e_{\\text{multi}}(\\theta, N) = \\lVert \\boldsymbol{F}^{\\text{multi}}(N) - \\boldsymbol{R}(\\theta) \\rVert_F$\n\n**Algorithm for Implementation**\n\nFor each given test case $(\\theta, N)$:\n1.  Construct the identity matrix $\\boldsymbol{I}$.\n2.  Compute the exact rotation matrix $\\boldsymbol{R}(\\theta)$ using the values of $\\cos\\theta$ and $\\sin\\theta$.\n3.  **Single-step path**:\n    a. Construct the generator matrix $\\boldsymbol{W}(\\theta)$.\n    b. Compute $\\boldsymbol{F}^{\\text{single}} = \\boldsymbol{I} + \\boldsymbol{W}(\\theta)$.\n    c. Calculate the error $e_{\\text{single}} = \\lVert \\boldsymbol{F}^{\\text{single}} - \\boldsymbol{R}(\\theta) \\rVert_F$.\n4.  **Multi-step path**:\n    a. Calculate the incremental angle $\\Delta\\theta = \\theta / N$.\n    b. Construct the incremental generator matrix $\\boldsymbol{W}(\\Delta\\theta)$.\n    c. Form the incremental deformation approximation $\\boldsymbol{F}_{\\text{inc}} = \\boldsymbol{I} + \\boldsymbol{W}(\\Delta\\theta)$.\n    d. Compute the total deformation by matrix exponentiation: $\\boldsymbol{F}^{\\text{multi}}(N) = (\\boldsymbol{F}_{\\text{inc}})^N$.\n    e. Calculate the error $e_{\\text{multi}} = \\lVert \\boldsymbol{F}^{\\text{multi}}(N) - \\boldsymbol{R}(\\theta) \\rVert_F$.\n5.  Store the computed errors $e_{\\text{single}}$ and $e_{\\text{multi}}$ for the final output.\n\nThis procedure will be systematically applied to all test cases provided. The numerical implementation will utilize the `numpy` library for efficient matrix operations, including matrix power and norm calculations.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and compares errors for two different numerical approximations\n    of a large 2D rigid rotation in an Updated Lagrangian framework.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple (theta_in_radians, N_steps).\n    test_cases = [\n        (0.0, 8),\n        (np.pi / 2, 8),\n        (np.pi, 32),\n        (2 * np.pi, 64),\n        (-np.pi / 3, 12),\n    ]\n\n    results = []\n    \n    # Identity matrix in 2D\n    I = np.identity(2)\n\n    for theta, N in test_cases:\n        # --- Ground Truth Calculation ---\n        # The exact deformation gradient is the rotation matrix R(theta).\n        c, s = np.cos(theta), np.sin(theta)\n        R_theta = np.array([[c, -s], \n                            [s,  c]])\n\n        # --- Single-Step Approximation ---\n        # F_single = I + W(theta), where W is the skew-symmetric generator.\n        W_theta = np.array([[0, -theta], \n                            [theta, 0]])\n        F_single = I + W_theta\n        \n        # Calculate single-step error using the Frobenius norm.\n        e_single = np.linalg.norm(F_single - R_theta, 'fro')\n\n        # --- Multi-Step Approximation ---\n        # F_multi = (I + W(theta/N))^N\n        # This handles the general case for N > 0.\n        # The special case theta = 0 also works correctly: d_theta = 0, W_d_theta = 0,\n        # F_inc = I, and finally F_multi = I, which is the correct result.\n        d_theta = theta / N\n        W_d_theta = np.array([[0, -d_theta], \n                                [d_theta, 0]])\n        F_inc = I + W_d_theta\n        \n        # Compute F_multi by raising the incremental matrix to the power of N.\n        F_multi = np.linalg.matrix_power(F_inc, N)\n\n        # Calculate multi-step error using the Frobenius norm.\n        e_multi = np.linalg.norm(F_multi - R_theta, 'fro')\n\n        # Append the two error measures for the current test case.\n        results.append(e_single)\n        results.append(e_multi)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "To solve for equilibrium, a finite element solver must compute the internal forces that resist deformation, which are derived from the element's stress state. This practice bridges the gap between kinetics and the discrete nodal degrees of freedom by applying the principle of virtual work . You will assemble the spatial strain-displacement matrix $\\mathbf{B}$ and use the Cauchy stress tensor $\\boldsymbol{\\sigma}$ to calculate the contribution to the internal force vector, a key step in any nonlinear analysis.",
            "id": "3608915",
            "problem": "Consider the updated Lagrangian finite element formulation for a three-dimensional eight-node trilinear hexahedral element in its current configuration. Let the current nodal coordinates form an axis-aligned rectangular parallelepiped with side lengths $L_x = 0.6$ m, $L_y = 0.4$ m, and $L_z = 0.2$ m, with nodes located at the corners $(0,0,0)$, $(L_x,0,0)$, $(L_x,L_y,0)$, $(0,L_y,0)$, $(0,0,L_z)$, $(L_x,0,L_z)$, $(L_x,L_y,L_z)$, $(0,L_y,L_z)$. Use the standard isoparametric mapping from the parent domain with coordinates $(\\xi, \\eta, \\zeta) \\in [-1, 1]^3$ and the trilinear shape functions\n$$\nN_i(\\xi,\\eta,\\zeta) = \\frac{1}{8}\\left(1+\\xi\\,\\xi_i\\right)\\left(1+\\eta\\,\\eta_i\\right)\\left(1+\\zeta\\,\\zeta_i\\right),\n$$\nwhere $(\\xi_i,\\eta_i,\\zeta_i)\\in\\{-1,1\\}^3$ are the parent-space coordinates of node $i$. Work in the spatial (current) configuration and use the Cauchy stress tensor for internal virtual work.\n\nStarting from the balance of virtual power in the current configuration, namely that the internal virtual work is\n$$\n\\delta W_{\\text{int}} = \\int_{\\Omega_t} \\boldsymbol{\\sigma} : \\operatorname{sym}(\\nabla_x \\delta \\boldsymbol{v}) \\,\\mathrm{d}v,\n$$\nderive the finite element internal force contribution at a Gauss point by assembling the spatial strain-displacement matrix $B$ using the spatial gradients $\\nabla_x N_i$. Adopt the Voigt mapping with engineering shear components so that the strain-rate vector is $[d_{xx},\\, d_{yy},\\, d_{zz},\\, 2d_{xy},\\, 2d_{yz},\\, 2d_{zx}]^{\\mathsf{T}}$ and the Cauchy stress vector is $[\\sigma_{xx},\\, \\sigma_{yy},\\, \\sigma_{zz},\\, \\sigma_{xy},\\, \\sigma_{yz},\\, \\sigma_{zx}]^{\\mathsf{T}}$.\n\nAssume a uniform Cauchy stress in the current configuration given (in megapascals) by\n$$\n\\boldsymbol{\\sigma} = \n\\begin{pmatrix}\n120 & 30 & -50 \\\\\n30 & 90 & -20 \\\\\n-50 & -20 & 60\n\\end{pmatrix}\n\\text{ MPa}.\n$$\nUse a $2\\times 2\\times 2$ Gauss quadrature rule with points at $(\\xi,\\eta,\\zeta) = (\\pm 1/\\sqrt{3}, \\pm 1/\\sqrt{3}, \\pm 1/\\sqrt{3})$ and weights equal to $1$ at each point. Focus on the Gauss point at $(\\xi,\\eta,\\zeta) = (1/\\sqrt{3}, 1/\\sqrt{3}, 1/\\sqrt{3})$. Using the standard eight-node ordering with node $1$ located at $(\\xi_1,\\eta_1,\\zeta_1) = (-1,-1,-1)$ in the parent domain, assemble the spatial $B$ matrix at this Gauss point and compute the scalar contribution from this single Gauss point to the $x$-component of the internal nodal force at node $1$.\n\nExpress your final answer in Newtons and round your answer to four significant figures. Do not include units in your final boxed answer.",
            "solution": "The problem requires computing a component of the internal nodal force vector from the principle of virtual power. The internal virtual power is given by:\n$$\n\\delta W_{\\text{int}} = \\int_{\\Omega_t} \\boldsymbol{\\sigma} : \\delta \\boldsymbol{d} \\,\\mathrm{d}v\n$$\nwhere $\\Omega_t$ is the current volume, $\\boldsymbol{\\sigma}$ is the Cauchy stress, and $\\delta \\boldsymbol{d} = \\operatorname{sym}(\\nabla_x \\delta \\boldsymbol{v})$ is the virtual rate of deformation tensor.\n\nIn the finite element method, the virtual velocity field $\\delta\\boldsymbol{v}$ is interpolated from nodal virtual velocities $\\delta\\boldsymbol{v}_I$:\n$$\n\\delta \\boldsymbol{v}(\\boldsymbol{x}) = \\sum_{I=1}^{8} N_I(\\boldsymbol{\\xi}) \\delta \\boldsymbol{v}_I\n$$\nThe virtual rate of deformation tensor, expressed in Voigt vector form $\\delta\\boldsymbol{d}_{\\text{voigt}}$, is related to the global vector of nodal virtual velocities $\\delta\\boldsymbol{v}_{\\text{global}}$ via the spatial strain-displacement matrix $\\boldsymbol{B}$:\n$$\n\\delta\\boldsymbol{d}_{\\text{voigt}} = \\boldsymbol{B} \\delta\\boldsymbol{v}_{\\text{global}}\n$$\nThe $\\boldsymbol{B}$ matrix is composed of blocks $\\boldsymbol{B}_I$ for each node, where:\n$$\n\\boldsymbol{B}_I = \\begin{pmatrix}\n\\frac{\\partial N_I}{\\partial x} & 0 & 0 \\\\\n0 & \\frac{\\partial N_I}{\\partial y} & 0 \\\\\n0 & 0 & \\frac{\\partial N_I}{\\partial z} \\\\\n\\frac{\\partial N_I}{\\partial y} & \\frac{\\partial N_I}{\\partial x} & 0 \\\\\n0 & \\frac{\\partial N_I}{\\partial z} & \\frac{\\partial N_I}{\\partial y} \\\\\n\\frac{\\partial N_I}{\\partial z} & 0 & \\frac{\\partial N_I}{\\partial x}\n\\end{pmatrix}\n$$\nIn Voigt notation, the internal virtual power becomes:\n$$\n\\delta W_{\\text{int}} = \\int_{\\Omega_t} \\boldsymbol{\\sigma}_{\\text{voigt}}^{\\mathsf{T}} \\delta\\boldsymbol{d}_{\\text{voigt}} \\,\\mathrm{d}v = \\delta\\boldsymbol{v}_{\\text{global}}^{\\mathsf{T}} \\int_{\\Omega_t} \\boldsymbol{B}^{\\mathsf{T}} \\boldsymbol{\\sigma}_{\\text{voigt}} \\,\\mathrm{d}v\n$$\nThe internal force vector is thus $\\boldsymbol{f}_{\\text{int}} = \\int_{\\Omega_t} \\boldsymbol{B}^{\\mathsf{T}} \\boldsymbol{\\sigma}_{\\text{voigt}} \\,\\mathrm{d}v$. Using Gauss quadrature, the contribution from a single Gauss point is $(\\boldsymbol{f}_{\\text{int}})_{gp} = (\\boldsymbol{B}^{\\mathsf{T}} \\boldsymbol{\\sigma}_{\\text{voigt}} \\det(\\boldsymbol{J}) w)_{gp}$.\n\nWe need the $x$-component of this force for node 1, which corresponds to the first row of $(\\boldsymbol{f}_{\\text{int}})_{gp}$. This row is computed by multiplying the first column of $\\boldsymbol{B}^{\\mathsf{T}}$ (i.e., $\\boldsymbol{B}_1^{\\mathsf{T}}$) by $\\boldsymbol{\\sigma}_{\\text{voigt}}$. The first row of $\\boldsymbol{B}_1^{\\mathsf{T}}$ is $[\\frac{\\partial N_1}{\\partial x}, 0, 0, \\frac{\\partial N_1}{\\partial y}, 0, \\frac{\\partial N_1}{\\partial z}]$. The force component is:\n$$\n(f_{\\text{int}, 1})_x = \\left( \\frac{\\partial N_1}{\\partial x} \\sigma_{xx} + \\frac{\\partial N_1}{\\partial y} \\sigma_{xy} + \\frac{\\partial N_1}{\\partial z} \\sigma_{zx} \\right) \\det(\\boldsymbol{J}) w\n$$\nThe mapping from parent to spatial coordinates is $x = \\frac{L_x}{2}(1+\\xi)$, $y = \\frac{L_y}{2}(1+\\eta)$, $z = \\frac{L_z}{2}(1+\\zeta)$. The Jacobian matrix $\\boldsymbol{J} = \\frac{\\partial \\boldsymbol{x}}{\\partial \\boldsymbol{\\xi}}$ is constant and diagonal:\n$$\n\\boldsymbol{J} = \\begin{pmatrix} L_x/2 & 0 & 0 \\\\ 0 & L_y/2 & 0 \\\\ 0 & 0 & L_z/2 \\end{pmatrix}\n$$\nThe determinant is $\\det(\\boldsymbol{J}) = \\frac{L_x L_y L_z}{8} = \\frac{(0.6)(0.4)(0.2)}{8} = 0.006 \\, \\text{m}^3$.\n\nNext, we find the derivatives of the shape function for node $1$ ($(\\xi_1, \\eta_1, \\zeta_1) = (-1,-1,-1)$):\n$$\nN_1(\\xi, \\eta, \\zeta) = \\frac{1}{8}(1-\\xi)(1-\\eta)(1-\\zeta)\n$$\nThe derivatives with respect to parent coordinates at the Gauss point $(\\xi, \\eta, \\zeta)_{gp} = (1/\\sqrt{3}, 1/\\sqrt{3}, 1/\\sqrt{3})$ are identical:\n$$\n\\frac{\\partial N_1}{\\partial \\xi}\\Big|_{gp} = -\\frac{1}{8}(1-\\eta)(1-\\zeta) \\Big|_{gp} = -\\frac{1}{8}\\left(1-\\frac{1}{\\sqrt{3}}\\right)^2\n$$\n$$\n-\\frac{1}{8}\\left(1-\\frac{2}{\\sqrt{3}}+\\frac{1}{3}\\right) = -\\frac{1}{8}\\left(\\frac{4-2\\sqrt{3}}{3}\\right) = -\\frac{4-2\\sqrt{3}}{24} = -\\frac{2-\\sqrt{3}}{12}\n$$\nThe spatial derivatives are found using the chain rule, $\\nabla_x N_1 = \\boldsymbol{J}^{-\\mathsf{T}} \\nabla_{\\xi} N_1$. Since $\\boldsymbol{J}$ is diagonal, $\\boldsymbol{J}^{-\\mathsf{T}}=\\boldsymbol{J}^{-1}$.\n$$\n\\frac{\\partial N_1}{\\partial x}\\Big|_{gp} = \\frac{2}{L_x} \\frac{\\partial N_1}{\\partial \\xi}\\Big|_{gp} = \\frac{2}{0.6} \\left(-\\frac{2-\\sqrt{3}}{12}\\right) = -\\frac{2-\\sqrt{3}}{3.6}\n$$\n$$\n\\frac{\\partial N_1}{\\partial y}\\Big|_{gp} = \\frac{2}{L_y} \\frac{\\partial N_1}{\\partial \\eta}\\Big|_{gp} = \\frac{2}{0.4} \\left(-\\frac{2-\\sqrt{3}}{12}\\right) = -\\frac{2-\\sqrt{3}}{2.4}\n$$\n$$\n\\frac{\\partial N_1}{\\partial z}\\Big|_{gp} = \\frac{2}{L_z} \\frac{\\partial N_1}{\\partial \\zeta}\\Big|_{gp} = \\frac{2}{0.2} \\left(-\\frac{2-\\sqrt{3}}{12}\\right) = -\\frac{2-\\sqrt{3}}{1.2}\n$$\nThe stress values are given in MPa ($10^6$ N/m$^2$): $\\sigma_{xx} = 120 \\times 10^6$, $\\sigma_{xy} = 30 \\times 10^6$, $\\sigma_{zx} = -50 \\times 10^6$. The Gauss weight $w=1$.\nPlugging these into the force component expression:\n$$\n(f_{\\text{int}, 1})_x = \\left[ \\left(-\\frac{2-\\sqrt{3}}{3.6}\\right)(120 \\times 10^6) + \\left(-\\frac{2-\\sqrt{3}}{2.4}\\right)(30 \\times 10^6) + \\left(-\\frac{2-\\sqrt{3}}{1.2}\\right)(-50 \\times 10^6) \\right] (0.006)\n$$\nFactor out the common term $-\\frac{2-\\sqrt{3}}{1.2}$:\n$$\n(f_{\\text{int}, 1})_x = -\\frac{2-\\sqrt{3}}{1.2} \\left[ \\frac{120}{3}(10^6) + \\frac{30}{2}(10^6) + (-50)(10^6) \\right] (0.006)\n$$\n$$\n(f_{\\text{int}, 1})_x = -\\frac{2-\\sqrt{3}}{1.2} \\left[ 40 + 15 - 50 \\right] \\times 10^6 \\times 0.006\n$$\n$$\n(f_{\\text{int}, 1})_x = -\\frac{2-\\sqrt{3}}{1.2} (5 \\times 10^6) (0.006) = -\\frac{2-\\sqrt{3}}{1.2} (30000)\n$$\n$$\n(f_{\\text{int}, 1})_x = -(2-\\sqrt{3}) \\frac{30000}{1.2} = -(2-\\sqrt{3}) (25000) \\, \\text{N}\n$$\nUsing $\\sqrt{3} \\approx 1.7320508$:\n$$\n(f_{\\text{int}, 1})_x \\approx -(2 - 1.7320508) \\times 25000 = -0.2679492 \\times 25000 = -6698.73 \\, \\text{N}\n$$\nRounding to four significant figures, the result is $-6699$ N.",
            "answer": "$$\n\\boxed{-6699}\n$$"
        }
    ]
}