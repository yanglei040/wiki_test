{
    "hands_on_practices": [
        {
            "introduction": "在更新拉格朗日（UL）列式中，变形梯度的演化是核心。本练习将通过一个具体的计算，带你实践如何从上一步的变形状态和当前的位移增量，通过乘法更新法则计算出新的变形梯度 。这个基本练习旨在加深你对UL列式中运动学核心更新规则 $\\mathbf{F}_{n+1} = \\mathbf{f} \\mathbf{F}_{n}$ 的理解。",
            "id": "3608832",
            "problem": "在用于大变形的更新拉格朗日（UL）有限元列式中，时间步 $n$ 的当前构型被用作从时间步 $n$ 到 $n+1$ 的增量更新的参考。考虑一个四节点线性四面体单元，其在时间步 $n$ （当前构型）的节点坐标由下式给出\n$$\n\\mathbf{x}_{1}^{(n)} = (0,\\,0,\\,0),\\quad\n\\mathbf{x}_{2}^{(n)} = (1,\\,0,\\,0),\\quad\n\\mathbf{x}_{3}^{(n)} = (0,\\,1,\\,0),\\quad\n\\mathbf{x}_{4}^{(n)} = (0,\\,0,\\,1).\n$$\n在同一步，从 $n$ 到 $n+1$ 的增量节点位移为\n$$\n\\Delta \\mathbf{u}_{1} = (0,\\,0,\\,0),\\quad\n\\Delta \\mathbf{u}_{2} = (1,\\,2,\\,-1),\\quad\n\\Delta \\mathbf{u}_{3} = (0,\\,1,\\,1),\\quad\n\\Delta \\mathbf{u}_{4} = (-2,\\,0,\\,3).\n$$\n假设在时间步 $n$ 的当前构型下，单元上定义了标准的 $C^{0}$ 线性形函数，并假设单元是运动学均匀的，因此使用这些形函数计算时，增量变形梯度在整个单元上是恒定的。时间步 $n$ 的变形梯度（在单元内视为常数）为\n$$\n\\mathbf{F}_{n} = \n\\begin{pmatrix}\n2  0  0\\\\\n0  1  0\\\\\n0  0  \\tfrac{1}{2}\n\\end{pmatrix}.\n$$\n从更新拉格朗日描述中增量映射的运动学定义出发，构建单元增量变形梯度 $\\mathbf{f}$，并使用乘法更新计算单元形心处的更新变形梯度 $\\mathbf{F}_{n+1}$。将所有量视为无量纲。以单个 $3\\times 3$ 矩阵 $\\mathbf{F}_{n+1}$ 的形式提供最终答案。无需进行四舍五入。",
            "solution": "题目要求在更新拉格朗日（UL）有限元框架下，求解一个四节点四面体单元在时间步 $n+1$ 的更新变形梯度，记为 $\\mathbf{F}_{n+1}$。\n\n### 步骤 1：问题验证\n\n#### 步骤 1.1：提取已知条件\n- **列式**：更新拉格朗日（UL）有限元列式。\n- **参考构型**：时间步 $n$ 的当前构型是从 $n$ 到 $n+1$ 增量的参考。\n- **单元类型**：四节点线性四面体单元。\n- **时间步 $n$ 的节点坐标**：\n  $$ \\mathbf{x}_{1}^{(n)} = (0,\\,0,\\,0) $$\n  $$ \\mathbf{x}_{2}^{(n)} = (1,\\,0,\\,0) $$\n  $$ \\mathbf{x}_{3}^{(n)} = (0,\\,1,\\,0) $$\n  $$ \\mathbf{x}_{4}^{(n)} = (0,\\,0,\\,1) $$\n- **从 $n$ 到 $n+1$ 的增量节点位移**：\n  $$ \\Delta \\mathbf{u}_{1} = (0,\\,0,\\,0) $$\n  $$ \\Delta \\mathbf{u}_{2} = (1,\\,2,\\,-1) $$\n  $$ \\Delta \\mathbf{u}_{3} = (0,\\,1,\\,1) $$\n  $$ \\Delta \\mathbf{u}_{4} = (-2,\\,0,\\,3) $$\n- **形函数**：在时间步 $n$ 的构型下，单元上定义的标准 $C^{0}$ 线性形函数。\n- **假设**：增量变形梯度在整个单元上是恒定的。\n- **时间步 $n$ 的变形梯度**：\n  $$ \\mathbf{F}_{n} = \\begin{pmatrix} 2  0  0\\\\ 0  1  0\\\\ 0  0  \\tfrac{1}{2} \\end{pmatrix} $$\n- **任务**：使用乘法更新计算更新后的变形梯度 $\\mathbf{F}_{n+1}$。所有量均为无量纲。\n\n#### 步骤 1.2：使用提取的已知条件进行验证\n1.  **科学依据**：该问题基于非线性连续介质力学和有限元方法的标准、公认的原理，特别是更新拉格朗日列式。诸如变形梯度、增量位移、形函数和乘法更新等所有概念都是该领域的基础。该问题在科学上是合理的。\n2.  **良态性**：该问题提供了所有必要的信息：当前步的单元几何形状、增量节点位移、当前步的变形梯度以及明确的目标。增量变形梯度恒定的假设与四面体单元使用线性形函数是一致的。存在唯一解。\n3.  **目标**：问题使用精确的数学术语和定义陈述，没有主观或模糊的语言。\n4.  **无其他缺陷**：问题没有矛盾、不完整或不切实际之处。给定的数值是一致的，不会引起问题。\n\n#### 步骤 1.3：结论和行动\n问题有效。将提供解答。\n\n### 步骤 2：求解\n\n更新拉格朗日列式使用时间步 $n$ 的构型作为分析到时间步 $n+1$ 的运动的参考。时间步 $n+1$ 的总变形梯度 $\\mathbf{F}_{n+1}$ 通过增量变形梯度 $\\mathbf{f}$ 与时间步 $n$ 的变形梯度 $\\mathbf{F}_{n}$ 相关联，其关系为乘法分解：\n$$ \\mathbf{F}_{n+1} = \\mathbf{f} \\mathbf{F}_{n} $$\n增量变形梯度 $\\mathbf{f}$ 将向量从时间步 $n$ 的构型映射到时间步 $n+1$ 的构型。其定义为：\n$$ \\mathbf{f} = \\frac{\\partial \\mathbf{x}^{(n+1)}}{\\partial \\mathbf{x}^{(n)}} $$\n其中 $\\mathbf{x}^{(n)}$ 和 $\\mathbf{x}^{(n+1)}$ 分别是物质点在时间步 $n$ 和 $n+1$ 构型中的位置向量。这些位置之间的关系由增量位移场 $\\Delta\\mathbf{u}$ 给出：\n$$ \\mathbf{x}^{(n+1)} = \\mathbf{x}^{(n)} + \\Delta\\mathbf{u}(\\mathbf{x}^{(n)}) $$\n将此代入 $\\mathbf{f}$ 的定义中：\n$$ \\mathbf{f} = \\frac{\\partial}{\\partial \\mathbf{x}^{(n)}} \\left( \\mathbf{x}^{(n)} + \\Delta\\mathbf{u} \\right) = \\mathbf{I} + \\frac{\\partial (\\Delta\\mathbf{u})}{\\partial \\mathbf{x}^{(n)}} = \\mathbf{I} + \\nabla_n(\\Delta\\mathbf{u}) $$\n其中 $\\mathbf{I}$ 是二阶单位张量，$\\nabla_n(\\Delta\\mathbf{u})$ 是增量位移场相对于当前构型坐标的空间梯度。\n\n对于一个有限元，增量位移场是使用形函数 $N_I(\\mathbf{x}^{(n)})$ 从节点增量位移 $\\Delta\\mathbf{u}_I$ 插值得到的：\n$$ \\Delta\\mathbf{u}(\\mathbf{x}^{(n)}) = \\sum_{I=1}^{4} N_I(\\mathbf{x}^{(n)}) \\Delta\\mathbf{u}_I $$\n该场的梯度为：\n$$ \\nabla_n(\\Delta\\mathbf{u}) = \\sum_{I=1}^{4} \\nabla_n(N_I) \\otimes \\Delta\\mathbf{u}_I = \\sum_{I=1}^{4} \\Delta\\mathbf{u}_I (\\nabla_n N_I)^T $$\n对于线性四面体单元，形函数是坐标的线性函数，这意味着它们的梯度 $\\nabla_n N_I$ 是常数向量。这使得 $\\nabla_n(\\Delta\\mathbf{u})$ 在整个单元中是恒定的，与问题的假设一致。\n\n单元在时间步 $n$ 的节点坐标定义了一个主单元或父单元：$\\mathbf{x}_{1}^{(n)} = (0,0,0)$，$\\mathbf{x}_{2}^{(n)} = (1,0,0)$，$\\mathbf{x}_{3}^{(n)} = (0,1,0)$ 和 $\\mathbf{x}_{4}^{(n)} = (0,0,1)$。对于这样的单元，形函数是重心坐标，这大大简化了计算。令 $\\mathbf{x} = (x, y, z)$ 为当前构型中的坐标（为简洁起见，我们省略了上标 $(n)$）。形函数为：\n$$ N_1(x,y,z) = 1 - x - y - z $$\n$$ N_2(x,y,z) = x $$\n$$ N_3(x,y,z) = y $$\n$$ N_4(x,y,z) = z $$\n这些形函数相对于 $\\mathbf{x} = (x,y,z)^T$ 的梯度为：\n$$ \\nabla_n N_1 = \\begin{pmatrix} -1 \\\\ -1 \\\\ -1 \\end{pmatrix}, \\quad \\nabla_n N_2 = \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix}, \\quad \\nabla_n N_3 = \\begin{pmatrix} 0 \\\\ 1 \\\\ 0 \\end{pmatrix}, \\quad \\nabla_n N_4 = \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\end{pmatrix} $$\n现在我们可以计算增量位移场的梯度 $\\nabla_n(\\Delta\\mathbf{u})$：\n$$ \\nabla_n(\\Delta\\mathbf{u}) = \\Delta\\mathbf{u}_1 (\\nabla_n N_1)^T + \\Delta\\mathbf{u}_2 (\\nabla_n N_2)^T + \\Delta\\mathbf{u}_3 (\\nabla_n N_3)^T + \\Delta\\mathbf{u}_4 (\\nabla_n N_4)^T $$\n使用给定的增量节点位移：\n$$ \\Delta\\mathbf{u}_1 = \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\end{pmatrix}, \\quad \\Delta\\mathbf{u}_2 = \\begin{pmatrix} 1 \\\\ 2 \\\\ -1 \\end{pmatrix}, \\quad \\Delta\\mathbf{u}_3 = \\begin{pmatrix} 0 \\\\ 1 \\\\ 1 \\end{pmatrix}, \\quad \\Delta\\mathbf{u}_4 = \\begin{pmatrix} -2 \\\\ 0 \\\\ 3 \\end{pmatrix} $$\n第一项为零，因为 $\\Delta\\mathbf{u}_1 = \\mathbf{0}$。我们计算其余各项：\n$$\n\\nabla_n(\\Delta\\mathbf{u}) =\n\\begin{pmatrix} 1 \\\\ 2 \\\\ -1 \\end{pmatrix} \\begin{pmatrix} 1  0  0 \\end{pmatrix} +\n\\begin{pmatrix} 0 \\\\ 1 \\\\ 1 \\end{pmatrix} \\begin{pmatrix} 0  1  0 \\end{pmatrix} +\n\\begin{pmatrix} -2 \\\\ 0 \\\\ 3 \\end{pmatrix} \\begin{pmatrix} 0  0  1 \\end{pmatrix}\n$$\n$$\n\\nabla_n(\\Delta\\mathbf{u}) =\n\\begin{pmatrix} 1  0  0 \\\\ 2  0  0 \\\\ -1  0  0 \\end{pmatrix} +\n\\begin{pmatrix} 0  0  0 \\\\ 0  1  0 \\\\ 0  1  0 \\end{pmatrix} +\n\\begin{pmatrix} 0  0  -2 \\\\ 0  0  0 \\\\ 0  0  3 \\end{pmatrix}\n$$\n将这些矩阵相加得到：\n$$\n\\nabla_n(\\Delta\\mathbf{u}) =\n\\begin{pmatrix}\n1  0  -2 \\\\\n2  1  0 \\\\\n-1  1  3\n\\end{pmatrix}\n$$\n接下来，我们求增量变形梯度 $\\mathbf{f}$：\n$$\n\\mathbf{f} = \\mathbf{I} + \\nabla_n(\\Delta\\mathbf{u}) =\n\\begin{pmatrix} 1  0  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{pmatrix} +\n\\begin{pmatrix} 1  0  -2 \\\\ 2  1  0 \\\\ -1  1  3 \\end{pmatrix} =\n\\begin{pmatrix} 2  0  -2 \\\\ 2  2  0 \\\\ -1  1  4 \\end{pmatrix}\n$$\n最后，我们使用乘法更新法则 $\\mathbf{F}_{n+1} = \\mathbf{f} \\mathbf{F}_{n}$ 来计算更新后的变形梯度 $\\mathbf{F}_{n+1}$：\n$$\n\\mathbf{F}_{n+1} =\n\\begin{pmatrix} 2  0  -2 \\\\ 2  2  0 \\\\ -1  1  4 \\end{pmatrix}\n\\begin{pmatrix} 2  0  0 \\\\ 0  1  0 \\\\ 0  0  \\frac{1}{2} \\end{pmatrix}\n$$\n执行矩阵乘法：\n$$\n\\mathbf{F}_{n+1} =\n\\begin{pmatrix}\n(2)(2) + (0)(0) + (-2)(0)   (2)(0) + (0)(1) + (-2)(0)   (2)(0) + (0)(0) + (-2)(\\frac{1}{2}) \\\\\n(2)(2) + (2)(0) + (0)(0)   (2)(0) + (2)(1) + (0)(0)   (2)(0) + (2)(0) + (0)(\\frac{1}{2}) \\\\\n(-1)(2) + (1)(0) + (4)(0)   (-1)(0) + (1)(1) + (4)(0)   (-1)(0) + (1)(0) + (4)(\\frac{1}{2})\n\\end{pmatrix}\n$$\n$$\n\\mathbf{F}_{n+1} =\n\\begin{pmatrix}\n4  0  -1 \\\\\n4  2  0 \\\\\n-2  1  2\n\\end{pmatrix}\n$$\n这就是在时间步 $n+1$ 的更新变形梯度。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n4  0  -1 \\\\\n4  2  0 \\\\\n-2  1  2\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "掌握了变形的描述后，下一步是将其与力联系起来，这是有限元分析求解平衡方程的关键。本练习基于虚功率原理，要求你计算在当前构型下由柯西应力（Cauchy stress）产生的内力向量 。通过这个实践，你将学会如何利用形函数的空间梯度来构建应变-位移矩阵 $\\boldsymbol{B}$，并最终理解变形与内力之间的桥梁。",
            "id": "3608915",
            "problem": "考虑在当前构型下的一个三维八节点三线性六面体单元的更新拉格朗日有限元列式。设当前节点坐标形成一个轴对齐的长方体，其边长分别为 $L_x = 0.6$ m，$L_y = 0.4$ m，和 $L_z = 0.2$ m，节点位于角点 $(0,0,0)$, $(L_x,0,0)$, $(L_x,L_y,0)$, $(0,L_y,0)$, $(0,0,L_z)$, $(L_x,0,L_z)$, $(L_x,L_y,L_z)$, $(0,L_y,L_z)$。使用从母域（坐标为 $(\\xi,\\eta,\\zeta)\\in[-1,1]^3$）的标准等参映射以及三线性形函数\n$$\nN_i(\\xi,\\eta,\\zeta) = \\frac{1}{8}\\left(1+\\xi\\,\\xi_i\\right)\\left(1+\\eta\\,\\eta_i\\right)\\left(1+\\zeta\\,\\zeta_i\\right),\n$$\n其中 $(\\xi_i,\\eta_i,\\zeta_i)\\in\\{-1,1\\}^3$ 是节点 $i$ 的母空间坐标。在空间（当前）构型中进行计算，并使用 Cauchy 应力张量计算内虚功。\n\n从当前构型中的虚功率平衡出发，即内虚功为\n$$\n\\delta W_{\\text{int}} = \\int_{\\Omega_t} \\boldsymbol{\\sigma} : \\operatorname{sym}(\\nabla_x \\delta \\boldsymbol{v}) \\,\\mathrm{d}v,\n$$\n通过使用空间梯度 $\\nabla_x N_i$ 组装空间应变-位移矩阵 $B$，推导在 Gauss 点处的有限元内力贡献。采用带有工程剪切分量的 Voigt 映射，使得应变率向量为 $[d_{xx},\\, d_{yy},\\, d_{zz},\\, 2d_{xy},\\, 2d_{yz},\\, 2d_{zx}]^{\\mathsf{T}}$，Cauchy 应力向量为 $[\\sigma_{xx},\\, \\sigma_{yy},\\, \\sigma_{zz},\\, \\sigma_{xy},\\, \\sigma_{yz},\\, \\sigma_{zx}]^{\\mathsf{T}}$。\n\n假设在当前构型中存在一个均匀的 Cauchy 应力，由下式给出（单位为兆帕）：\n$$\n\\boldsymbol{\\sigma} = \n\\begin{pmatrix}\n120  30  -50 \\\\\n30  90  -20 \\\\\n-50  -20  60\n\\end{pmatrix}\n\\text{ MPa}.\n$$\n使用 $2\\times 2\\times 2$ 的 Gauss 求积法则，其积分点位于 $(\\xi,\\eta,\\zeta) = (\\pm 1/\\sqrt{3}, \\pm 1/\\sqrt{3}, \\pm 1/\\sqrt{3})$，且每个点的权重均为 $1$。关注 Gauss 点 $(\\xi,\\eta,\\zeta) = (1/\\sqrt{3}, 1/\\sqrt{3}, 1/\\sqrt{3})$。使用标准的八节点排序，其中节点 1 在母域中的位置为 $(\\xi_1,\\eta_1,\\zeta_1) = (-1,-1,-1)$，在该 Gauss 点处组装空间 B 矩阵，并计算此单个 Gauss 点对节点 1 处节点内力的 x 分量的标量贡献。\n\n以牛顿为单位表示最终答案，并将答案四舍五入到四位有效数字。在最终的方框答案中不要包含单位。",
            "solution": "该问题要求基于更新拉格朗日列式，计算有限元节点内力向量的一个特定分量。其出发点是虚功率原理，其中内虚功功率 $\\delta \\dot{W}_{\\text{int}}$ 等于外虚功功率。内虚功功率的表达式如下：\n$$\n\\delta \\dot{W}_{\\text{int}} = \\int_{\\Omega_t} \\boldsymbol{\\sigma} : \\operatorname{sym}(\\nabla_x \\delta \\boldsymbol{v}) \\,\\mathrm{d}v\n$$\n其中 $\\Omega_t$ 是物体的当前体积，$\\boldsymbol{\\sigma}$ 是 Cauchy 应力张量，$\\delta \\boldsymbol{v}$ 是虚速度场，$\\nabla_x$ 是关于当前空间坐标 $\\boldsymbol{x}$ 的梯度算子。虚变形率张量为 $\\delta \\boldsymbol{d} = \\operatorname{sym}(\\nabla_x \\delta \\boldsymbol{v})$。\n\n在有限元法中，虚速度场 $\\delta \\boldsymbol{v}$ 是使用形函数 $N_I$ 从虚节点速度 $\\delta \\dot{\\boldsymbol{d}}_I$ 插值得到的：\n$$\n\\delta \\boldsymbol{v}(\\boldsymbol{x}) = \\sum_{I=1}^{8} N_I(\\boldsymbol{\\xi}) \\delta \\dot{\\boldsymbol{d}}_I\n$$\n其中 $\\boldsymbol{\\xi} = (\\xi, \\eta, \\zeta)$ 是母坐标，$\\delta \\dot{\\boldsymbol{d}}_I = [\\delta \\dot{u}_I, \\delta \\dot{v}_I, \\delta \\dot{w}_I]^{\\mathsf{T}}$ 是节点 $I$ 处的虚速度向量。\n\n虚变形率张量 $\\delta \\boldsymbol{d}$ 可以用 Voigt 记法表示为向量 $\\delta\\dot{\\boldsymbol{\\epsilon}}$。该向量通过空间应变-位移矩阵 $\\boldsymbol{B}$ 与全局虚节点速度向量 $\\delta\\dot{\\boldsymbol{d}}$ 相关联：\n$$\n\\delta\\dot{\\boldsymbol{\\epsilon}} = \\boldsymbol{B} \\delta\\dot{\\boldsymbol{d}}\n$$\n矩阵 $\\boldsymbol{B}$ 由每个节点的块矩阵 $\\boldsymbol{B}_I$ 构成，$\\boldsymbol{B} = [\\boldsymbol{B}_1, \\boldsymbol{B}_2, \\ldots, \\boldsymbol{B}_8]$，其中每个 $\\boldsymbol{B}_I$ 是一个 $6 \\times 3$ 矩阵：\n$$\n\\boldsymbol{B}_I = \\begin{pmatrix}\n\\frac{\\partial N_I}{\\partial x}   0   0 \\\\\n0   \\frac{\\partial N_I}{\\partial y}   0 \\\\\n0   0   \\frac{\\partial N_I}{\\partial z} \\\\\n\\frac{\\partial N_I}{\\partial y}   \\frac{\\partial N_I}{\\partial x}   0 \\\\\n0   \\frac{\\partial N_I}{\\partial z}   \\frac{\\partial N_I}{\\partial y} \\\\\n\\frac{\\partial N_I}{\\partial z}   0   \\frac{\\partial N_I}{\\partial x}\n\\end{pmatrix}\n$$\n虚功率可以用 Voigt 记法写成：\n$$\n\\delta \\dot{W}_{\\text{int}} = \\int_{\\Omega_t} \\boldsymbol{\\sigma}^{\\mathsf{T}} \\delta\\dot{\\boldsymbol{\\epsilon}} \\,\\mathrm{d}v = \\int_{\\Omega_t} \\boldsymbol{\\sigma}^{\\mathsf{T}} \\boldsymbol{B} \\delta\\dot{\\boldsymbol{d}} \\,\\mathrm{d}v\n$$\n其中 $\\boldsymbol{\\sigma}$ 是 Cauchy 应力向量。由于 $\\delta\\dot{\\boldsymbol{d}}$ 是一个任意常数向量，我们有：\n$$\n\\delta \\dot{W}_{\\text{int}} = \\delta\\dot{\\boldsymbol{d}}^{\\mathsf{T}} \\int_{\\Omega_t} \\boldsymbol{B}^{\\mathsf{T}} \\boldsymbol{\\sigma} \\,\\mathrm{d}v\n$$\n根据定义，$\\delta \\dot{W}_{\\text{int}} = \\delta\\dot{\\boldsymbol{d}}^{\\mathsf{T}} \\boldsymbol{f}_{\\text{int}}$，所以内力向量为：\n$$\n\\boldsymbol{f}_{\\text{int}} = \\int_{\\Omega_t} \\boldsymbol{B}^{\\mathsf{T}} \\boldsymbol{\\sigma} \\,\\mathrm{d}v\n$$\n问题要求计算来自单个 Gauss 点的对该力的贡献。该积分使用 Gauss 求积进行数值近似：\n$$\n\\boldsymbol{f}_{\\text{int}} \\approx \\sum_{gp} (\\boldsymbol{B}^{\\mathsf{T}} \\boldsymbol{\\sigma} \\det(\\boldsymbol{J}) w)_{gp}\n$$\n其中 $\\boldsymbol{J}$ 是等参映射的雅可比矩阵，$w$ 是 Gauss 权重，并在 Gauss 点 $gp$ 处求值。因此，来自单个 Gauss 点的贡献为 $(\\boldsymbol{f}_{\\text{int}})_{gp} = (\\boldsymbol{B}^{\\mathsf{T}} \\boldsymbol{\\sigma} \\det(\\boldsymbol{J}) w)_{gp}$。\n\n节点 $I$ 处内力的 x 分量，记为 $(f_{\\text{int}, I})_x$，是该向量中对应于自由度 $\\delta \\dot{u}_I$ 的分量。这可以通过取 $\\boldsymbol{B}_I^{\\mathsf{T}}$ 的第一行与应力向量的点积来获得。由于应力张量是对称的，$\\sigma_{zx} = \\sigma_{xz}$，我们得到：\n$$\n(f_{\\text{int}, I})_x = \\left( \\frac{\\partial N_I}{\\partial x} \\sigma_{xx} + \\frac{\\partial N_I}{\\partial y} \\sigma_{xy} + \\frac{\\partial N_I}{\\partial z} \\sigma_{zx} \\right) \\det(\\boldsymbol{J}) w\n$$\n我们需要在 Gauss 点 $(\\xi, \\eta, \\zeta) = (1/\\sqrt{3}, 1/\\sqrt{3}, 1/\\sqrt{3})$ 处为节点 $I=1$ 计算此值。\n\n首先，我们求雅可比矩阵 $\\boldsymbol{J}$。该单元是一个轴对齐的长方体，节点位于角点。从母坐标 $\\boldsymbol{\\xi} \\in [-1,1]^3$ 到空间坐标 $\\boldsymbol{x} \\in [0,L_x]\\times[0,L_y]\\times[0,L_z]$ 的映射由下式给出：\n$$\nx = \\frac{L_x}{2}(1+\\xi), \\quad y = \\frac{L_y}{2}(1+\\eta), \\quad z = \\frac{L_z}{2}(1+\\zeta)\n$$\n雅可比矩阵为 $\\boldsymbol{J} = \\frac{\\partial \\boldsymbol{x}}{\\partial \\boldsymbol{\\xi}}$：\n$$\n\\boldsymbol{J} = \\begin{pmatrix} \\frac{\\partial x}{\\partial \\xi}   \\frac{\\partial x}{\\partial \\eta}   \\frac{\\partial x}{\\partial \\zeta} \\\\ \\frac{\\partial y}{\\partial \\xi}   \\frac{\\partial y}{\\partial \\eta}   \\frac{\\partial y}{\\partial \\zeta} \\\\ \\frac{\\partial z}{\\partial \\xi}   \\frac{\\partial z}{\\partial \\eta}   \\frac{\\partial z}{\\partial \\zeta} \\end{pmatrix} = \\begin{pmatrix} L_x/2   0   0 \\\\ 0   L_y/2   0 \\\\ 0   0   L_z/2 \\end{pmatrix}\n$$\n该矩阵是常数。其行列式为：\n$$\n\\det(\\boldsymbol{J}) = \\frac{L_x L_y L_z}{8} = \\frac{(0.6)(0.4)(0.2)}{8} = \\frac{0.048}{8} = 0.006 \\, \\text{m}^3\n$$\n逆雅可比矩阵为：\n$$\n\\boldsymbol{J}^{-1} = \\begin{pmatrix} 2/L_x   0   0 \\\\ 0   2/L_y   0 \\\\ 0   0   2/L_z \\end{pmatrix}\n$$\n\n接下来，我们需要节点 1 形函数的空间导数。节点 1 的母坐标为 $(\\xi_1, \\eta_1, \\zeta_1) = (-1,-1,-1)$。\n$$\nN_1(\\xi, \\eta, \\zeta) = \\frac{1}{8}(1+\\xi\\xi_1)(1+\\eta\\eta_1)(1+\\zeta\\zeta_1) = \\frac{1}{8}(1-\\xi)(1-\\eta)(1-\\zeta)\n$$\n关于母坐标的导数为：\n$$\n\\frac{\\partial N_1}{\\partial \\xi} = -\\frac{1}{8}(1-\\eta)(1-\\zeta), \\quad\n\\frac{\\partial N_1}{\\partial \\eta} = -\\frac{1}{8}(1-\\xi)(1-\\zeta), \\quad\n\\frac{\\partial N_1}{\\partial \\zeta} = -\\frac{1}{8}(1-\\xi)(1-\\eta)\n$$\n我们在 Gauss 点 $(\\xi, \\eta, \\zeta)_{gp} = (1/\\sqrt{3}, 1/\\sqrt{3}, 1/\\sqrt{3})$ 处计算这些值：\n$$\n\\frac{\\partial N_1}{\\partial \\xi}\\Big|_{gp} = \\frac{\\partial N_1}{\\partial \\eta}\\Big|_{gp} = \\frac{\\partial N_1}{\\partial \\zeta}\\Big|_{gp} = -\\frac{1}{8}\\left(1-\\frac{1}{\\sqrt{3}}\\right)^2 = -\\frac{1}{8}\\frac{(\\sqrt{3}-1)^2}{3} = -\\frac{4-2\\sqrt{3}}{24} = -\\frac{2-\\sqrt{3}}{12}\n$$\n空间导数使用链式法则求得，$\\nabla_x N_1 = (\\boldsymbol{J}^{-T} \\nabla_{\\xi} N_1^T)^T = (\\boldsymbol{J}^{-1} \\nabla_{\\xi} N_1)$，因为 $\\boldsymbol{J}$ 是对角的。\n$$\n\\frac{\\partial N_1}{\\partial x}\\Big|_{gp} = \\frac{2}{L_x} \\frac{\\partial N_1}{\\partial \\xi}\\Big|_{gp} = \\frac{2}{0.6} \\left(-\\frac{2-\\sqrt{3}}{12}\\right) = -\\frac{2-\\sqrt{3}}{3.6}\n$$\n为避免过早的数值代入，我们保持符号形式：\n$$\n\\frac{\\partial N_1}{\\partial x}\\Big|_{gp} = \\frac{2}{L_x} \\left(-\\frac{2-\\sqrt{3}}{12}\\right) = -\\frac{2-\\sqrt{3}}{6L_x}\n$$\n$$\n\\frac{\\partial N_1}{\\partial y}\\Big|_{gp} = -\\frac{2-\\sqrt{3}}{6L_y}, \\quad\n\\frac{\\partial N_1}{\\partial z}\\Big|_{gp} = -\\frac{2-\\sqrt{3}}{6L_z}\n$$\n现在我们可以计算力的分量。Gauss 权重 $w$ 给定为 1。应力值以 MPa（$10^6$ Pa 或 $10^6$ N/m$^2$）为单位给出：\n$\\sigma_{xx} = 120 \\times 10^6$ N/m$^2$,\n$\\sigma_{xy} = 30 \\times 10^6$ N/m$^2$,\n$\\sigma_{zx} = -50 \\times 10^6$ N/m$^2$\n长度为 $L_x=0.6$ m, $L_y=0.4$ m, $L_z=0.2$ m。\n\n$$\n(f_{\\text{int}, 1})_x = \\left[ \\left(-\\frac{2-\\sqrt{3}}{6L_x}\\right)\\sigma_{xx} + \\left(-\\frac{2-\\sqrt{3}}{6L_y}\\right)\\sigma_{xy} + \\left(-\\frac{2-\\sqrt{3}}{6L_z}\\right)\\sigma_{zx} \\right] \\det(\\boldsymbol{J}) \\cdot w\n$$\n$$\n(f_{\\text{int}, 1})_x = -\\frac{2-\\sqrt{3}}{6} \\left( \\frac{\\sigma_{xx}}{L_x} + \\frac{\\sigma_{xy}}{L_y} + \\frac{\\sigma_{zx}}{L_z} \\right) \\det(\\boldsymbol{J}) \\cdot w\n$$\n让我们计算括号中的项：\n$$\n\\frac{\\sigma_{xx}}{L_x} + \\frac{\\sigma_{xy}}{L_y} + \\frac{\\sigma_{zx}}{L_z} = \\left( \\frac{120}{0.6} + \\frac{30}{0.4} + \\frac{-50}{0.2} \\right) \\times 10^6 \\frac{\\text{N}}{\\text{m}^3}\n$$\n$$\n= (200 + 75 - 250) \\times 10^6 = 25 \\times 10^6 \\frac{\\text{N}}{\\text{m}^3}\n$$\n现在将所有值代入力的表达式：\n$$\n(f_{\\text{int}, 1})_x = -\\frac{2-\\sqrt{3}}{6} \\left( 25 \\times 10^6 \\frac{\\text{N}}{\\text{m}^3} \\right) (0.006 \\, \\text{m}^3) \\cdot 1\n$$\n$$\n(f_{\\text{int}, 1})_x = -\\frac{2-\\sqrt{3}}{6} (150000) \\, \\text{N}\n$$\n$$\n(f_{\\text{int}, 1})_x = -(2-\\sqrt{3}) (25000) \\, \\text{N}\n$$\n使用 $\\sqrt{3} \\approx 1.7320508$：\n$$\n(f_{\\text{int}, 1})_x \\approx -(2 - 1.7320508) \\times 25000 = -0.2679492 \\times 25000 = -6698.73 \\, \\text{N}\n$$\n四舍五入到四位有效数字得到 $-6699$ N。",
            "answer": "$$\n\\boxed{-6699}\n$$"
        },
        {
            "introduction": "处理大转动是更新拉格朗日列式中的一个主要挑战，不正确的本构更新会导致非物理性的应力。本练习将引导你实现一种高级且在实际中广泛应用的“协同转动”（corotational）本构更新算法，该算法通过极分解提取并“中和”刚体转动的影响 。通过比较该客观算法与朴素算法在牛顿-拉弗森迭代收敛性上的表现，你将直观地看到遵循材料客观性原理在数值计算中的强大优势。",
            "id": "3608906",
            "problem": "您的任务是设计并实现一个完整的、可运行的程序，在计算固体力学的更新拉格朗日有限元格式内，执行增量本构更新。该更新通过在每个增量步中使用极分解从变形梯度 $F$ 中提取旋转 $R$ 来消除刚体转动。您必须比较使用此旋转中和更新的标量 Newton-Raphson 迭代与不中和刚体转动的朴素更新的收敛行为。\n\n您的算法推导必须从第一性原理和经过充分检验的定义出发。具体来说，使用以下基础：\n- 变形梯度 $F$ 由当前构型到后续构型的空间映射定义，并捕捉局部拉伸和旋转。\n- 极分解 $F = R U$ 将 $F$ 分解为一个真正交旋转 $R$ 和一个对称右拉伸 $U$。\n- 对于共旋坐标系中小应变下的各向同性线弹性，Cauchy 应力增量由 $\\Delta \\boldsymbol{\\sigma}^{\\ast} = \\lambda \\,\\mathrm{tr}(\\boldsymbol{\\varepsilon}) \\mathbf{I} + 2 G \\boldsymbol{\\varepsilon}$ 给出，其中 $\\lambda$ 和 $G$ 是 Lamé 参数，$\\mathrm{tr}(\\cdot)$ 表示迹，$\\mathbf{I}$ 是单位矩阵，$\\boldsymbol{\\varepsilon}$ 是共旋坐标系中的小应变张量。\n- 在更新拉格朗日增量程序中，每个增量都相对于当前构型施加，并且应力增量会进行累积。\n\n您的程序必须在一系列增量上实现两种本构更新算法：\n1. 旋转中和（客观共旋更新）：对于每个具有变形梯度 $F_i$ 的增量 $i$，从极分解中获取 $R_i$ 和 $U_i$，计算应变增量为 $\\boldsymbol{\\varepsilon}_i = U_i - \\mathbf{I}$，使用各向同性线弹性计算共旋应力增量 $\\Delta \\boldsymbol{\\sigma}_i^{\\ast}$，并将其旋转回空间坐标系以累积 $\\boldsymbol{\\sigma} \\leftarrow \\boldsymbol{\\sigma} + R_i \\Delta \\boldsymbol{\\sigma}_i^{\\ast} R_i^{\\mathsf{T}}$。\n2. 朴素非客观更新：对于每个增量 $i$，计算 $\\boldsymbol{\\varepsilon}_i = \\tfrac{1}{2}\\left(F_i + F_i^{\\mathsf{T}}\\right) - \\mathbf{I}$ 并累积 $\\boldsymbol{\\sigma} \\leftarrow \\boldsymbol{\\sigma} + \\lambda \\,\\mathrm{tr}(\\boldsymbol{\\varepsilon}_i) \\mathbf{I} + 2 G \\boldsymbol{\\varepsilon}_i$。\n\n为了使 Newton-Raphson 迭代在两种更新中都具有数值可测试性和可比性，引入一个标量载荷缩放参数 $\\alpha \\in \\mathbb{R}$，该参数将每个增量变形梯度从单位矩阵线性缩放为\n$$\nF_i(\\alpha) = \\mathbf{I} + \\alpha \\left(F_i - \\mathbf{I}\\right).\n$$\n对于给定的目标剪应力 $\\tau_{\\mathrm{target}}$，定义标量残差\n$$\nr(\\alpha) = \\left[\\boldsymbol{\\sigma}(\\alpha)\\right]_{12} - \\tau_{\\mathrm{target}},\n$$\n其中 $\\left[\\boldsymbol{\\sigma}(\\alpha)\\right]_{12}$ 是在应用所有由 $\\alpha$ 缩放的增量后，累积 Cauchy 应力的 $(1,2)$ 分量。使用 Newton-Raphson 方法求解 $r(\\alpha) = 0$，从初始猜测值 $\\alpha_0$ 开始，使用数值导数\n$$\n\\frac{\\mathrm{d} r}{\\mathrm{d} \\alpha} \\approx \\frac{r(\\alpha + h) - r(\\alpha)}{h},\n$$\n其中 $h$ 是一个小的有限差分步长。如果 $\\lvert r(\\alpha)\\rvert  \\varepsilon$ 或达到最大迭代次数，则终止 Newton 迭代。记录所用的迭代次数。\n\n您的程序必须计算每个测试用例中旋转中和更新和朴素更新所需的迭代次数，并以整数形式报告迭代次数的差异\n$$\n\\Delta N = N_{\\mathrm{naive}} - N_{\\mathrm{objective}}.\n$$\n\n角度单位说明：所有角度必须以弧度处理。\n\n材料参数和数值常量：\n- 杨氏模量 $E = 2.10 \\times 10^{11}$，泊松比 $\\nu = 0.30$。计算 Lamé 参数 $G = \\dfrac{E}{2(1+\\nu)}$ 和 $\\lambda = \\dfrac{E \\nu}{(1+\\nu)(1-2\\nu)}$。\n- Newton-Raphson 容差 $\\varepsilon = 10^{-9}$，有限差分步长 $h = 10^{-8}$，最大迭代次数 $N_{\\max} = 50$，并在每次更新后将 $\\alpha$ 限制在区间 $[0, 1.5]$ 内。\n- 单位矩阵 $\\mathbf{I}$ 是 $2 \\times 2$ 的单位矩阵。\n\n测试套件（角度以弧度为单位）：\n- 情况 1（纯旋转增量，客观性的理想路径）：三个增量，分别为 $F_1 = R(\\theta)$、$F_2 = R(\\theta)$、$F_3 = R(\\theta)$，其中 $R(\\theta) = \\begin{bmatrix} \\cos\\theta   -\\sin\\theta \\\\ \\sin\\theta   \\cos\\theta \\end{bmatrix}$ 且 $\\theta = \\dfrac{\\pi}{18}$。目标剪应力 $\\tau_{\\mathrm{target}} = 0$，初始猜测值 $\\alpha_0 = 0.5$。\n- 情况 2（简单剪切增量）：三个增量，其中 $F_i = \\begin{bmatrix} 1   \\gamma \\\\ 0   1 \\end{bmatrix}$，$\\gamma = 0.2$ 且 $i \\in \\{1,2,3\\}$。目标剪应力 $\\tau_{\\mathrm{target}} = 3 G \\gamma$，初始猜测值 $\\alpha_0 = 0.5$。\n- 情况 3（旋转与拉伸组合）：两个增量，其中 $F_i = R(\\theta) S$，$R(\\theta)$ 如上定义，$\\theta = \\dfrac{\\pi}{36}$，$S = \\mathrm{diag}(1.05, 0.98)$。目标剪应力 $\\tau_{\\mathrm{target}}$ 是在 $\\alpha = 1$ 时，旋转中和更新对这些增量计算得到的剪应力，初始猜测值 $\\alpha_0 = 0.5$。\n- 情况 4（边界情况，单位矩阵）：一个增量，其中 $F_1 = \\mathbf{I}$。目标剪应力 $\\tau_{\\mathrm{target}} = 0$，初始猜测值 $\\alpha_0 = 0.5$。\n\n您的程序必须：\n- 使用奇异值分解实现一个稳健的 $2 \\times 2$ 极分解，以获得 $R$ 和 $U$，并确保 $\\det(R) = +1$。\n- 实现上述两种更新算法。\n- 使用指定的数值参数和导数近似实现 Newton-Raphson 求解器。\n- 对于每个测试用例，计算朴素更新和客观更新之间的迭代次数差异 $\\Delta N$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $[r_1,r_2,r_3,r_4]$），其中每个 $r_j$ 是按上述顺序对应的测试用例的整数 $\\Delta N$。最终输出中没有物理单位；所有条目都是纯整数。",
            "solution": "用户旨在比较固体力学更新拉格朗日框架内两种不同本构更新方案的收敛行为。该比较通过使用 Newton-Raphson 方法求解一个标量非线性方程，并比较每种方案达到收敛所需的迭代次数来执行。\n\n### 1. 理论框架\n\n#### 1.1. 运动学与材料客观性\n从参考构型到当前构型的变形由变形梯度 $F$ 描述。在更新拉格朗日格式中，我们考虑从当前构型出发的增量变形。该问题指定了一系列增量变形梯度，记为 $F_i$。\n\n极分解定理指出，任何可逆的变形梯度 $F$ 都可以唯一地分解为一个旋转和一个拉伸：\n$$ F = R U $$\n其中 $R$ 是一个真正交张量（$\\det(R) = 1$, $R^{\\mathsf{T}}R = \\mathbf{I}$），代表刚体旋转；$U$ 是对称、正定的右拉伸张量（$U = U^{\\mathsf{T}}$），代表材料的纯变形。\n\n材料坐标系无关性（或客观性）原理要求本构律（应力-应变关系）独立于观察者，这意味着它们必须不受刚体旋转的影响。第一个要实现的算法，即“客观共旋更新”，旨在遵循这一原理。第二个“朴素”算法则不然，会导致物理上不正确的结果，例如在纯刚体旋转下产生应力。\n\n#### 1.2. 本构模型与材料参数\n该问题指定了一个次弹性本构模型，其中应力*增量*与应变*增量*相关。对于各向同性线弹性材料，在共旋坐标系（随材料一同旋转的坐标系）中的应力增量由下式给出：\n$$ \\Delta \\boldsymbol{\\sigma}^{\\ast} = \\lambda \\,\\mathrm{tr}(\\boldsymbol{\\varepsilon}) \\mathbf{I} + 2 G \\boldsymbol{\\varepsilon} $$\n其中 $\\boldsymbol{\\varepsilon}$ 是共旋坐标系中的应变增量张量，$\\mathbf{I}$ 是 $2 \\times 2$ 单位矩阵，$\\lambda$ 和 $G$ 是 Lamé 参数。它们由杨氏模量 $E$ 和泊松比 $\\nu$ 计算得出：\n$$ G = \\frac{E}{2(1+\\nu)} $$\n$$ \\lambda = \\frac{E \\nu}{(1+\\nu)(1-2\\nu)} $$\n\n#### 1.3. 增量更新算法\n\n总 Cauchy 应力 $\\boldsymbol{\\sigma}$ 在一系列变形增量上累积。该问题的一个关键方面是引入一个标量参数 $\\alpha$ 来缩放变形。对于每个基础增量变形梯度 $F_{base, i}$，施加的变形为：\n$$ F_i(\\alpha) = \\mathbf{I} + \\alpha (F_{base, i} - \\mathbf{I}) $$\n总应力 $\\boldsymbol{\\sigma}(\\alpha)$ 是此参数的函数。问题指定了一个加法累积方案，其中总应力是每个增量贡献的总和，从初始零应力状态开始计算。\n\n**算法 1：客观共旋更新**\n此方法仅从变形的拉伸部分计算应变，从而确保客观性。\n对于每个增量 $i$：\n1.  计算缩放后的变形梯度 $F_i(\\alpha)$。\n2.  执行极分解：$F_i(\\alpha) = R_i U_i$。使用基于奇异值分解 (SVD) 的稳健方法：如果 $F = W \\Sigma V^{\\mathsf{T}}$，则 $R = W V^{\\mathsf{T}}$ 且 $U = V \\Sigma V^{\\mathsf{T}}$。需注意确保 $\\det(R)=+1$。\n3.  从拉伸张量计算材料应变增量：$\\boldsymbol{\\varepsilon}_i = U_i - \\mathbf{I}$。\n4.  使用线弹性定律计算共旋应力增量 $\\Delta\\boldsymbol{\\sigma}_i^*$。\n5.  将此增量旋转回固定的空间坐标系，并加到总应力中：$\\boldsymbol{\\sigma}(\\alpha) \\leftarrow \\boldsymbol{\\sigma}(\\alpha) + R_i \\Delta\\boldsymbol{\\sigma}_i^* R_i^{\\mathsf{T}}$。\n\n**算法 2：朴素非客观更新**\n此方法不恰当地将旋转和应变混为一谈。\n对于每个增量 $i$：\n1.  计算缩放后的变形梯度 $F_i(\\alpha)$。\n2.  应变增量定义为梯度减去单位矩阵的对称部分：$\\boldsymbol{\\varepsilon}_i = \\frac{1}{2}(F_i(\\alpha) + F_i(\\alpha)^{\\mathsf{T}}) - \\mathbf{I}$。此度量不区分拉伸和旋转。\n3.  直接计算应力增量：$\\Delta\\boldsymbol{\\sigma}_i = \\lambda \\,\\mathrm{tr}(\\boldsymbol{\\varepsilon}_i) \\mathbf{I} + 2 G \\boldsymbol{\\varepsilon}_i$。\n4.  将增量加到总应力中，而不考虑材料单元的旋转：$\\boldsymbol{\\sigma}(\\alpha) \\leftarrow \\boldsymbol{\\sigma}(\\alpha) + \\Delta\\boldsymbol{\\sigma}_i$。\n\n### 2. 通过 Newton-Raphson 方法进行数值求解\n\n目标是找到能够产生特定目标剪应力 $\\tau_{\\mathrm{target}}$ 的 $\\alpha$ 值。这被表述为标量残差函数的求根问题：\n$$ r(\\alpha) = [\\boldsymbol{\\sigma}(\\alpha)]_{12} - \\tau_{\\mathrm{target}} $$\n其中 $[\\boldsymbol{\\sigma}(\\alpha)]_{12}$ 是最终累积的 Cauchy 应力的 $(1,2)$ 工程剪切分量。\n\n使用 Newton-Raphson 方法求解 $r(\\alpha)=0$。从初始猜测值 $\\alpha_0$ 开始，迭代过程如下：\n$$ \\alpha_{k+1} = \\alpha_k - \\frac{r(\\alpha_k)}{r'(\\alpha_k)} $$\n导数 $r'(\\alpha_k)$ 不是通过解析方式推导，而是使用有限差分格式近似：\n$$ r'(\\alpha_k) \\approx \\frac{r(\\alpha_k + h) - r(\\alpha_k)}{h} $$\n其中 $h$ 是一个小的步长（给定为 $10^{-8}$）。迭代持续进行，直到残差的绝对值低于容差 $\\varepsilon=10^{-9}$ 或达到最大迭代次数 $N_{\\max}=50$。对每种方法，记录迭代次数 $N$。每个测试用例的最终输出是差异 $\\Delta N = N_{\\mathrm{naive}} - N_{\\mathrm{objective}}$。\n\n### 3. 实现设计\n\n实现结构如下：\n1.  一个主函数 `solve` 协调整个过程，定义测试用例和材料/数值参数。\n2.  一个稳健的 `polar_decomposition` 函数使用 `scipy.linalg.svd` 从 $F$ 计算 $R$ 和 $U$，并根据问题规范确保 $\\det(R)=+1$。\n3.  一个 `calculate_sigma` 函数实现客观更新和朴素更新的逻辑。它接收 $\\alpha$、基础增量列表和方法类型（'objective' 或 'naive'）作为输入，并返回最终累积的应力张量 $\\boldsymbol{\\sigma}(\\alpha)$。\n4.  一个 `newton_raphson_solver` 函数封装了迭代过程。它重复调用 `calculate_sigma` 来评估残差 $r(\\alpha)$ 及其数值导数，更新 $\\alpha$，并记录迭代次数直到收敛。\n5.  对于每个测试用例，为两种方法调用求解器以获得 $N_{\\mathrm{naive}}$ 和 $N_{\\mathrm{objective}}$。计算并存储差异 $\\Delta N$。\n6.  最后，将所有测试用例的 $\\Delta N$ 值列表按指定格式打印。为保证数值稳定性，在 Newton-Raphson 迭代的每一步都将 $\\alpha$ 限制在区间 $[0, 1.5]$ 内。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import svd\n\ndef solve():\n    \"\"\"\n    Main function to run the computational solid mechanics simulation\n    and comparison of constitutive update methods.\n    \"\"\"\n\n    # --- Material parameters and numerical constants ---\n    E = 2.10e11\n    nu = 0.30\n    G = E / (2 * (1 + nu))\n    lmbda = (E * nu) / ((1 + nu) * (1 - 2 * nu))\n\n    NR_TOL = 1e-9\n    FD_STEP = 1e-8\n    MAX_ITER = 50\n    ALPHA_CLAMP_MIN = 0.0\n    ALPHA_CLAMP_MAX = 1.5\n    I = np.identity(2)\n\n    def polar_decomposition(F):\n        \"\"\"\n        Performs polar decomposition of a 2x2 matrix F into R and U.\n        F = R U, where R is a proper rotation (det(R)=1) and U is symmetric positive semi-definite.\n        Uses an SVD-based method.\n        \"\"\"\n        W, s, Vh = svd(F)\n        R = W @ Vh\n        \n        # Ensure R is a proper rotation matrix (det(R) = +1).\n        # For physical deformations det(F)0, so det(R) from svd should be +1.\n        # This check adds robustness.\n        if np.linalg.det(R)  0.0:\n            W_mod = W.copy()\n            W_mod[:, -1] *= -1\n            R = W_mod @ Vh\n            \n        U = Vh.T @ np.diag(s) @ Vh\n        return R, U\n\n    def calculate_sigma(alpha, base_increments, method):\n        \"\"\"\n        Calculates the final accumulated Cauchy stress tensor sigma(alpha)\n        for a given update method.\n        \"\"\"\n        sigma = np.zeros((2, 2))\n        \n        for F_base in base_increments:\n            F = I + alpha * (F_base - I)\n            \n            if method == 'objective':\n                R, U = polar_decomposition(F)\n                eps = U - I\n                d_sigma_star = lmbda * np.trace(eps) * I + 2 * G * eps\n                sigma += R @ d_sigma_star @ R.T\n            elif method == 'naive':\n                eps = 0.5 * (F + F.T) - I\n                d_sigma = lmbda * np.trace(eps) * I + 2 * G * eps\n                sigma += d_sigma\n\n        return sigma\n\n    def newton_raphson_solver(base_increments, tau_target, alpha_0, method):\n        \"\"\"\n        Solves r(alpha) = 0 using Newton-Raphson and returns the iteration count.\n        \"\"\"\n        alpha = alpha_0\n        num_iterations = 0\n        \n        for k in range(MAX_ITER):\n            # Calculate residual r(alpha)\n            sigma_alpha = calculate_sigma(alpha, base_increments, method)\n            res_alpha = sigma_alpha[0, 1] - tau_target\n\n            if abs(res_alpha)  NR_TOL:\n                # Converged, iteration count is k. The assignment below makes it more explicit.\n                num_iterations = k\n                break\n\n            # Calculate residual r(alpha + h) for numerical derivative\n            sigma_alpha_h = calculate_sigma(alpha + FD_STEP, base_increments, method)\n            res_alpha_h = sigma_alpha_h[0, 1] - tau_target\n            \n            # Numerical derivative\n            dr_dalpha = (res_alpha_h - res_alpha) / FD_STEP\n\n            if abs(dr_dalpha)  1e-20:  # Avoid division by zero\n                # Could not find a good search direction, terminate.\n                 num_iterations = k + 1\n                 break\n\n            # Newton-Raphson update\n            alpha -= res_alpha / dr_dalpha\n            \n            # Clamp alpha\n            alpha = max(ALPHA_CLAMP_MIN, min(ALPHA_CLAMP_MAX, alpha))\n\n            if k == MAX_ITER - 1:\n                num_iterations = MAX_ITER\n        else: # This 'else' belongs to the 'for', executed if loop finishes without break\n             if abs(res_alpha) = NR_TOL:\n                num_iterations = MAX_ITER\n             else:\n                num_iterations = MAX_ITER\n        \n        # Consistent problem definition interpretation of \"number of iterations\"\n        # If converged at k=0, loop doesn't run, num_iterations=0.\n        # If converged at k=1, loop ran once, num_iterations=1.\n        # The prompt \"N - k+1\" suggests counting completed update steps.\n        # A simple way to achieve this without complex logic is to just return k if loop breaks.\n        return num_iterations\n        \n    # --- Test Suite ---\n    \n    # Common parameters\n    alpha_0 = 0.5\n    \n    # Case 1: Pure rotation\n    theta1 = np.pi / 18\n    R1 = np.array([[np.cos(theta1), -np.sin(theta1)], [np.sin(theta1), np.cos(theta1)]])\n    case1_increments = [R1, R1, R1]\n    case1_tau_target = 0.0\n\n    # Case 2: Simple shear\n    gamma2 = 0.2\n    F2 = np.array([[1, gamma2], [0, 1]])\n    case2_increments = [F2, F2, F2]\n    # Target is the shear stress produced by the naive update at alpha=1\n    case2_tau_target = 3 * G * gamma2\n\n    # Case 3: Combined rotation and stretch\n    theta3 = np.pi / 36\n    R3 = np.array([[np.cos(theta3), -np.sin(theta3)], [np.sin(theta3), np.cos(theta3)]])\n    S3 = np.diag([1.05, 0.98])\n    F3 = R3 @ S3\n    case3_increments = [F3, F3]\n    # Target is the shear obtained by the objective update at alpha=1\n    sigma_obj_at_1 = calculate_sigma(1.0, case3_increments, 'objective')\n    case3_tau_target = sigma_obj_at_1[0, 1]\n\n    # Case 4: Identity\n    F4 = np.identity(2)\n    case4_increments = [F4]\n    case4_tau_target = 0.0\n    \n    test_cases = [\n        (case1_increments, case1_tau_target, alpha_0),\n        (case2_increments, case2_tau_target, alpha_0),\n        (case3_increments, case3_tau_target, alpha_0),\n        (case4_increments, case4_tau_target, alpha_0),\n    ]\n\n    results = []\n    for increments, tau_target, alpha_start in test_cases:\n        # A revised Newton solver that counts completed update steps.\n        def newton_solver(base_incs, target_tau, initial_alpha, meth):\n            alpha = initial_alpha\n            for i in range(MAX_ITER):\n                sigma = calculate_sigma(alpha, base_incs, meth)\n                res = sigma[0, 1] - target_tau\n                if abs(res)  NR_TOL:\n                    return i\n                \n                sigma_h = calculate_sigma(alpha + FD_STEP, base_incs, meth)\n                res_h = sigma_h[0, 1] - target_tau\n                deriv = (res_h - res) / FD_STEP\n\n                if abs(deriv)  1e-20:\n                    return MAX_ITER # Stagnated\n                    \n                alpha -= res / deriv\n                alpha = max(ALPHA_CLAMP_MIN, min(ALPHA_CLAMP_MAX, alpha))\n            return MAX_ITER\n\n        N_objective = newton_solver(increments, tau_target, alpha_start, 'objective')\n        N_naive = newton_solver(increments, tau_target, alpha_start, 'naive')\n        \n        delta_N = N_naive - N_objective\n        results.append(delta_N)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}