{
    "hands_on_practices": [
        {
            "introduction": "The heart of the Updated Lagrangian (UL) formulation is its step-by-step approach, where the current configuration serves as the reference for the next incremental deformation. This exercise provides a foundational, hands-on calculation of this process. By working through the update of the deformation gradient, $\\boldsymbol{F}$, for a single element, you will solidify your understanding of how kinematics are tracked in a large-deformation analysis ().",
            "id": "3608832",
            "problem": "In the updated Lagrangian (UL) finite element formulation for large deformations, the current configuration at time step $n$ is taken as the reference for the incremental update from step $n$ to step $n+1$. Consider a single four-node linear tetrahedral element whose nodal coordinates at step $n$ (the current configuration) are given by\n$$\n\\mathbf{x}_{1}^{(n)} = (0,\\,0,\\,0),\\quad\n\\mathbf{x}_{2}^{(n)} = (1,\\,0,\\,0),\\quad\n\\mathbf{x}_{3}^{(n)} = (0,\\,1,\\,0),\\quad\n\\mathbf{x}_{4}^{(n)} = (0,\\,0,\\,1).\n$$\nAt the same step, the incremental nodal displacements from $n$ to $n+1$ are\n$$\n\\Delta \\mathbf{u}_{1} = (0,\\,0,\\,0),\\quad\n\\Delta \\mathbf{u}_{2} = (1,\\,2,\\,-1),\\quad\n\\Delta \\mathbf{u}_{3} = (0,\\,1,\\,1),\\quad\n\\Delta \\mathbf{u}_{4} = (-2,\\,0,\\,3).\n$$\nAssume the standard $C^{0}$ linear shape functions defined over the element in the current configuration at step $n$, and assume the element is kinematically homogeneous so that the incremental deformation gradient is constant over the element when computed with these shape functions. The deformation gradient at step $n$ (taken as constant within the element) is\n$$\n\\mathbf{F}_{n} = \n\\begin{pmatrix}\n2 & 0 & 0\\\\\n0 & 1 & 0\\\\\n0 & 0 & \\tfrac{1}{2}\n\\end{pmatrix}.\n$$\nStarting from the kinematic definitions of the incremental mapping in the updated Lagrangian description, construct the elementwise incremental deformation gradient $\\mathbf{f}$ and compute the updated deformation gradient $\\mathbf{F}_{n+1}$ at the element centroid using the multiplicative update. Treat all quantities as nondimensional. Provide your final answer as the single $3\\times 3$ matrix $\\mathbf{F}_{n+1}$. No rounding is required.",
            "solution": "The user wants to find the updated deformation gradient at step $n+1$, denoted as $\\mathbf{F}_{n+1}$, for a four-node tetrahedral element within an updated Lagrangian (UL) finite element framework.\n\n### Step 1: Problem Validation\n\n#### Step 1.1: Extract Givens\n- **Formulation**: Updated Lagrangian (UL) finite element formulation.\n- **Reference Configuration**: The current configuration at step $n$ is the reference for the increment from $n$ to $n+1$.\n- **Element Type**: Four-node linear tetrahedral element.\n- **Nodal Coordinates at step $n$**:\n  $$ \\mathbf{x}_{1}^{(n)} = (0,\\,0,\\,0) $$\n  $$ \\mathbf{x}_{2}^{(n)} = (1,\\,0,\\,0) $$\n  $$ \\mathbf{x}_{3}^{(n)} = (0,\\,1,\\,0) $$\n  $$ \\mathbf{x}_{4}^{(n)} = (0,\\,0,\\,1) $$\n- **Incremental Nodal Displacements from $n$ to $n+1$**:\n  $$ \\Delta \\mathbf{u}_{1} = (0,\\,0,\\,0) $$\n  $$ \\Delta \\mathbf{u}_{2} = (1,\\,2,\\,-1) $$\n  $$ \\Delta \\mathbf{u}_{3} = (0,\\,1,\\,1) $$\n  $$ \\Delta \\mathbf{u}_{4} = (-2,\\,0,\\,3) $$\n- **Shape Functions**: Standard $C^{0}$ linear shape functions over the element in the configuration at step $n$.\n- **Assumption**: The incremental deformation gradient is constant over the element.\n- **Deformation Gradient at step $n$**:\n  $$ \\mathbf{F}_{n} = \\begin{pmatrix} 2 & 0 & 0\\\\ 0 & 1 & 0\\\\ 0 & 0 & \\tfrac{1}{2} \\end{pmatrix} $$\n- **Task**: Compute the updated deformation gradient $\\mathbf{F}_{n+1}$ using the multiplicative update. All quantities are nondimensional.\n\n#### Step 1.2: Validate Using Extracted Givens\n1.  **Scientifically Grounded**: The problem is based on standard, well-established principles of nonlinear continuum mechanics and the finite element method, specifically the updated Lagrangian formulation. All concepts like deformation gradient, incremental displacements, shape functions, and multiplicative updates are fundamental to this field. The problem is scientifically sound.\n2.  **Well-Posed**: The problem provides all necessary information: element geometry at the current step, incremental nodal displacements, the deformation gradient at the current step, and a clear objective. The assumption of a constant incremental deformation gradient is consistent with the use of linear shape functions for a tetrahedral element. A unique solution exists.\n3.  **Objective**: The problem is stated using precise mathematical terms and definitions, with no subjective or ambiguous language.\n4.  **No other flaws**: The problem is not contradictory, incomplete, or unrealistic. The given numerical values are consistent and pose no issues.\n\n#### Step 1.3: Verdict and Action\nThe problem is valid. A solution will be provided.\n\n### Step 2: Solution\n\nThe updated Lagrangian formulation uses the configuration at time step $n$ as the reference for analyzing the motion to time step $n+1$. The total deformation gradient at step $n+1$, $\\mathbf{F}_{n+1}$, is related to the deformation gradient at step $n$, $\\mathbf{F}_{n}$, through the incremental deformation gradient, $\\mathbf{f}$, via a multiplicative decomposition:\n$$ \\mathbf{F}_{n+1} = \\mathbf{f} \\mathbf{F}_{n} $$\nThe incremental deformation gradient $\\mathbf{f}$ maps vectors from the configuration at step $n$ to the configuration at step $n+1$. It is defined as:\n$$ \\mathbf{f} = \\frac{\\partial \\mathbf{x}^{(n+1)}}{\\partial \\mathbf{x}^{(n)}} $$\nwhere $\\mathbf{x}^{(n)}$ and $\\mathbf{x}^{(n+1)}$ are the position vectors of a material point in the configurations at steps $n$ and $n+1$, respectively. The relationship between these positions is given by the incremental displacement field $\\Delta\\mathbf{u}$:\n$$ \\mathbf{x}^{(n+1)} = \\mathbf{x}^{(n)} + \\Delta\\mathbf{u}(\\mathbf{x}^{(n)}) $$\nSubstituting this into the definition of $\\mathbf{f}$:\n$$ \\mathbf{f} = \\frac{\\partial}{\\partial \\mathbf{x}^{(n)}} \\left( \\mathbf{x}^{(n)} + \\Delta\\mathbf{u} \\right) = \\mathbf{I} + \\frac{\\partial (\\Delta\\mathbf{u})}{\\partial \\mathbf{x}^{(n)}} = \\mathbf{I} + \\nabla_n(\\Delta\\mathbf{u}) $$\nwhere $\\mathbf{I}$ is the second-order identity tensor and $\\nabla_n(\\Delta\\mathbf{u})$ is the spatial gradient of the incremental displacement field with respect to the coordinates in the current configuration.\n\nFor a finite element, the incremental displacement field is interpolated from the nodal incremental displacements $\\Delta\\mathbf{u}_I$ using the shape functions $N_I(\\mathbf{x}^{(n)})$:\n$$ \\Delta\\mathbf{u}(\\mathbf{x}^{(n)}) = \\sum_{I=1}^{4} N_I(\\mathbf{x}^{(n)}) \\Delta\\mathbf{u}_I $$\nThe gradient of this field is:\n$$ \\nabla_n(\\Delta\\mathbf{u}) = \\sum_{I=1}^{4} \\nabla_n(N_I) \\otimes \\Delta\\mathbf{u}_I = \\sum_{I=1}^{4} \\Delta\\mathbf{u}_I (\\nabla_n N_I)^T $$\nFor a linear tetrahedral element, the shape functions are linear functions of the coordinates, meaning their gradients $\\nabla_n N_I$ are constant vectors. This makes $\\nabla_n(\\Delta\\mathbf{u})$ constant throughout the element, consistent with the problem's assumption.\n\nThe element's nodal coordinates at step $n$ define a master or parent element: $\\mathbf{x}_{1}^{(n)} = (0,0,0)$, $\\mathbf{x}_{2}^{(n)} = (1,0,0)$, $\\mathbf{x}_{3}^{(n)} = (0,1,0)$, and $\\mathbf{x}_{4}^{(n)} = (0,0,1)$. For such an element, the shape functions are the barycentric coordinates, which simplify significantly. Let $\\mathbf{x} = (x, y, z)$ be the coordinates in the current configuration (we drop the superscript $(n)$ for brevity). The shape functions are:\n$$ N_1(x,y,z) = 1 - x - y - z $$\n$$ N_2(x,y,z) = x $$\n$$ N_3(x,y,z) = y $$\n$$ N_4(x,y,z) = z $$\nThe gradients of these shape functions with respect to $\\mathbf{x} = (x,y,z)^T$ are:\n$$ \\nabla_n N_1 = \\begin{pmatrix} -1 \\\\ -1 \\\\ -1 \\end{pmatrix}, \\quad \\nabla_n N_2 = \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix}, \\quad \\nabla_n N_3 = \\begin{pmatrix} 0 \\\\ 1 \\\\ 0 \\end{pmatrix}, \\quad \\nabla_n N_4 = \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\end{pmatrix} $$\nNow we can compute the gradient of the incremental displacement field, $\\nabla_n(\\Delta\\mathbf{u})$:\n$$ \\nabla_n(\\Delta\\mathbf{u}) = \\Delta\\mathbf{u}_1 (\\nabla_n N_1)^T + \\Delta\\mathbf{u}_2 (\\nabla_n N_2)^T + \\Delta\\mathbf{u}_3 (\\nabla_n N_3)^T + \\Delta\\mathbf{u}_4 (\\nabla_n N_4)^T $$\nUsing the given incremental nodal displacements:\n$$ \\Delta\\mathbf{u}_1 = \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\end{pmatrix}, \\quad \\Delta\\mathbf{u}_2 = \\begin{pmatrix} 1 \\\\ 2 \\\\ -1 \\end{pmatrix}, \\quad \\Delta\\mathbf{u}_3 = \\begin{pmatrix} 0 \\\\ 1 \\\\ 1 \\end{pmatrix}, \\quad \\Delta\\mathbf{u}_4 = \\begin{pmatrix} -2 \\\\ 0 \\\\ 3 \\end{pmatrix} $$\nThe first term is zero since $\\Delta\\mathbf{u}_1 = \\mathbf{0}$. We calculate the remaining terms:\n$$\n\\nabla_n(\\Delta\\mathbf{u}) =\n\\begin{pmatrix} 1 \\\\ 2 \\\\ -1 \\end{pmatrix} \\begin{pmatrix} 1 & 0 & 0 \\end{pmatrix} +\n\\begin{pmatrix} 0 \\\\ 1 \\\\ 1 \\end{pmatrix} \\begin{pmatrix} 0 & 1 & 0 \\end{pmatrix} +\n\\begin{pmatrix} -2 \\\\ 0 \\\\ 3 \\end{pmatrix} \\begin{pmatrix} 0 & 0 & 1 \\end{pmatrix}\n$$\n$$\n\\nabla_n(\\Delta\\mathbf{u}) =\n\\begin{pmatrix} 1 & 0 & 0 \\\\ 2 & 0 & 0 \\\\ -1 & 0 & 0 \\end{pmatrix} +\n\\begin{pmatrix} 0 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 1 & 0 \\end{pmatrix} +\n\\begin{pmatrix} 0 & 0 & -2 \\\\ 0 & 0 & 0 \\\\ 0 & 0 & 3 \\end{pmatrix}\n$$\nSumming these matrices gives:\n$$\n\\nabla_n(\\Delta\\mathbf{u}) =\n\\begin{pmatrix}\n1 & 0 & -2 \\\\\n2 & 1 & 0 \\\\\n-1 & 1 & 3\n\\end{pmatrix}\n$$\nNext, we find the incremental deformation gradient $\\mathbf{f}$:\n$$\n\\mathbf{f} = \\mathbf{I} + \\nabla_n(\\Delta\\mathbf{u}) =\n\\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} +\n\\begin{pmatrix} 1 & 0 & -2 \\\\ 2 & 1 & 0 \\\\ -1 & 1 & 3 \\end{pmatrix} =\n\\begin{pmatrix} 2 & 0 & -2 \\\\ 2 & 2 & 0 \\\\ -1 & 1 & 4 \\end{pmatrix}\n$$\nFinally, we compute the updated deformation gradient $\\mathbf{F}_{n+1}$ using the multiplicative update rule, $\\mathbf{F}_{n+1} = \\mathbf{f} \\mathbf{F}_{n}$:\n$$\n\\mathbf{F}_{n+1} =\n\\begin{pmatrix} 2 & 0 & -2 \\\\ 2 & 2 & 0 \\\\ -1 & 1 & 4 \\end{pmatrix}\n\\begin{pmatrix} 2 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & \\frac{1}{2} \\end{pmatrix}\n$$\nPerforming the matrix multiplication:\n$$\n\\mathbf{F}_{n+1} =\n\\begin{pmatrix}\n(2)(2) + (0)(0) + (-2)(0) & (2)(0) + (0)(1) + (-2)(0) & (2)(0) + (0)(0) + (-2)(\\frac{1}{2}) \\\\\n(2)(2) + (2)(0) + (0)(0) & (2)(0) + (2)(1) + (0)(0) & (2)(0) + (2)(0) + (0)(\\frac{1}{2}) \\\\\n(-1)(2) + (1)(0) + (4)(0) & (-1)(0) + (1)(1) + (4)(0) & (-1)(0) + (1)(0) + (4)(\\frac{1}{2})\n\\end{pmatrix}\n$$\n$$\n\\mathbf{F}_{n+1} =\n\\begin{pmatrix}\n4 & 0 & -1 \\\\\n4 & 2 & 0 \\\\\n-2 & 1 & 2\n\\end{pmatrix}\n$$\nThis is the updated deformation gradient at step $n+1$.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n4 & 0 & -1 \\\\\n4 & 2 & 0 \\\\\n-2 & 1 & 2\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "Once the kinematic state is updated, a finite element solver must determine the internal forces resisting the deformation to check for equilibrium. This practice connects the continuum world of Cauchy stress, $\\boldsymbol{\\sigma}$, to the discrete world of nodal forces. You will compute the internal force vector contribution from a single integration point, a fundamental operation performed millions of times in any nonlinear structural simulation ().",
            "id": "3608915",
            "problem": "Consider the updated Lagrangian finite element formulation for a three-dimensional eight-node trilinear hexahedral element in its current configuration. Let the current nodal coordinates form an axis-aligned rectangular parallelepiped with side lengths $L_x = 0.6$ m, $L_y = 0.4$ m, and $L_z = 0.2$ m, with nodes located at the corners $(0,0,0)$, $(L_x,0,0)$, $(L_x,L_y,0)$, $(0,L_y,0)$, $(0,0,L_z)$, $(L_x,0,L_z)$, $(L_x,L_y,L_z)$, $(0,L_y,L_z)$. Use the standard isoparametric mapping from the parent domain with coordinates $(\\xi,\\eta,\\zeta)\\in[-1,1]^3$ and the trilinear shape functions\n$$\nN_i(\\xi,\\eta,\\zeta) = \\frac{1}{8}\\left(1+\\xi\\,\\xi_i\\right)\\left(1+\\eta\\,\\eta_i\\right)\\left(1+\\zeta\\,\\zeta_i\\right),\n$$\nwhere $(\\xi_i,\\eta_i,\\zeta_i)\\in\\{-1,1\\}^3$ are the parent-space coordinates of node $i$. Work in the spatial (current) configuration and use the Cauchy stress tensor for internal virtual work.\n\nStarting from the balance of virtual power in the current configuration, namely that the internal virtual work is\n$$\n\\delta W_{\\text{int}} = \\int_{\\Omega_t} \\boldsymbol{\\sigma} : \\operatorname{sym}(\\nabla_x \\delta \\boldsymbol{v}) \\,\\mathrm{d}v,\n$$\nderive the finite element internal force contribution at a Gauss point by assembling the spatial strain-displacement matrix $\\boldsymbol{B}$ using the spatial gradients $\\nabla_x N_i$. Adopt the Voigt mapping with engineering shear components so that the strain-rate vector is $[d_{xx},\\, d_{yy},\\, d_{zz},\\, 2d_{xy},\\, 2d_{yz},\\, 2d_{zx}]^{\\mathsf{T}}$ and the Cauchy stress vector is $[\\sigma_{xx},\\, \\sigma_{yy},\\, \\sigma_{zz},\\, \\sigma_{xy},\\, \\sigma_{yz},\\, \\sigma_{zx}]^{\\mathsf{T}}$.\n\nAssume a uniform Cauchy stress in the current configuration given (in megapascals) by\n$$\n\\boldsymbol{\\sigma} = \n\\begin{pmatrix}\n120 & 30 & -50 \\\\\n30 & 90 & -20 \\\\\n-50 & -20 & 60\n\\end{pmatrix}\n\\text{ MPa}.\n$$\nUse a $2\\times 2\\times 2$ Gauss quadrature rule with points at $(\\xi,\\eta,\\zeta) = (\\pm 1/\\sqrt{3}, \\pm 1/\\sqrt{3}, \\pm 1/\\sqrt{3})$ and weights equal to $1$ at each point. Focus on the Gauss point at $(\\xi,\\eta,\\zeta) = (1/\\sqrt{3}, 1/\\sqrt{3}, 1/\\sqrt{3})$. Using the standard eight-node ordering with node $1$ located at $(\\xi_1,\\eta_1,\\zeta_1) = (-1,-1,-1)$ in the parent domain, assemble the spatial $\\boldsymbol{B}$ matrix at this Gauss point and compute the scalar contribution from this single Gauss point to the $x$-component of the internal nodal force at node $1$.\n\nExpress your final answer in Newtons and round your answer to four significant figures. Do not include units in your final boxed answer.",
            "solution": "The problem requires the computation of a specific component of the internal nodal force vector for a finite element, based on the updated Lagrangian formulation. The starting point is the principle of virtual power, where the rate of internal virtual work, $\\delta \\dot{W}_{\\text{int}}$ (using the notation $\\delta W$ from the problem statement for the virtual power), is equated to the rate of external virtual work. The expression for the internal virtual power is given as:\n$$\n\\delta \\dot{W}_{\\text{int}} = \\int_{\\Omega_t} \\boldsymbol{\\sigma} : \\operatorname{sym}(\\nabla_x \\delta \\boldsymbol{v}) \\,\\mathrm{d}v\n$$\nwhere $\\Omega_t$ is the current volume of the body, $\\boldsymbol{\\sigma}$ is the Cauchy stress tensor, $\\delta \\boldsymbol{v}$ is the virtual velocity field, and $\\nabla_x$ is the gradient operator with respect to the current spatial coordinates $\\boldsymbol{x}$. The virtual rate of deformation tensor is $\\delta \\boldsymbol{d} = \\operatorname{sym}(\\nabla_x \\delta \\boldsymbol{v})$.\n\nIn the finite element method, the virtual velocity field $\\delta \\boldsymbol{v}$ is interpolated from the virtual nodal velocities $\\delta \\dot{\\boldsymbol{d}}_I$ using the shape functions $N_I$:\n$$\n\\delta \\boldsymbol{v}(\\boldsymbol{x}) = \\sum_{I=1}^{8} N_I(\\boldsymbol{\\xi}) \\delta \\dot{\\boldsymbol{d}}_I\n$$\nwhere $\\boldsymbol{\\xi} = (\\xi, \\eta, \\zeta)$ are the parent coordinates, and $\\delta \\dot{\\boldsymbol{d}}_I = [\\delta \\dot{u}_I, \\delta \\dot{v}_I, \\delta \\dot{w}_I]^{\\mathsf{T}}$ is the virtual velocity vector at node $I$.\n\nThe virtual rate of deformation tensor, $\\delta \\boldsymbol{d}$, can be expressed in Voigt notation as a vector $\\delta\\dot{\\boldsymbol{\\epsilon}}$. This vector is related to the global vector of virtual nodal velocities $\\delta\\dot{\\boldsymbol{d}}$ through the spatial strain-displacement matrix $\\boldsymbol{B}$:\n$$\n\\delta\\dot{\\boldsymbol{\\epsilon}} = \\boldsymbol{B} \\delta\\dot{\\boldsymbol{d}}\n$$\nThe matrix $\\boldsymbol{B}$ is constructed from blocks $\\boldsymbol{B}_I$ for each node, $\\boldsymbol{B} = [\\boldsymbol{B}_1, \\boldsymbol{B}_2, \\ldots, \\boldsymbol{B}_8]$, where each $\\boldsymbol{B}_I$ is a $6 \\times 3$ matrix:\n$$\n\\boldsymbol{B}_I = \\begin{pmatrix}\n\\frac{\\partial N_I}{\\partial x} & 0 & 0 \\\\\n0 & \\frac{\\partial N_I}{\\partial y} & 0 \\\\\n0 & 0 & \\frac{\\partial N_I}{\\partial z} \\\\\n\\frac{\\partial N_I}{\\partial y} & \\frac{\\partial N_I}{\\partial x} & 0 \\\\\n0 & \\frac{\\partial N_I}{\\partial z} & \\frac{\\partial N_I}{\\partial y} \\\\\n\\frac{\\partial N_I}{\\partial z} & 0 & \\frac{\\partial N_I}{\\partial x}\n\\end{pmatrix}\n$$\nThe virtual power can be written in Voigt notation as:\n$$\n\\delta \\dot{W}_{\\text{int}} = \\int_{\\Omega_t} \\boldsymbol{\\sigma}^{\\mathsf{T}} \\delta\\dot{\\boldsymbol{\\epsilon}} \\,\\mathrm{d}v = \\int_{\\Omega_t} \\boldsymbol{\\sigma}^{\\mathsf{T}} \\boldsymbol{B} \\delta\\dot{\\boldsymbol{d}} \\,\\mathrm{d}v\n$$\nwhere $\\boldsymbol{\\sigma}$ is the Cauchy stress vector. Since $\\delta\\dot{\\boldsymbol{d}}$ is a vector of arbitrary constants, we have:\n$$\n\\delta \\dot{W}_{\\text{int}} = \\delta\\dot{\\boldsymbol{d}}^{\\mathsf{T}} \\int_{\\Omega_t} \\boldsymbol{B}^{\\mathsf{T}} \\boldsymbol{\\sigma} \\,\\mathrm{d}v\n$$\nBy definition, $\\delta \\dot{W}_{\\text{int}} = \\delta\\dot{\\boldsymbol{d}}^{\\mathsf{T}} \\boldsymbol{f}_{\\text{int}}$, so the internal force vector is:\n$$\n\\boldsymbol{f}_{\\text{int}} = \\int_{\\Omega_t} \\boldsymbol{B}^{\\mathsf{T}} \\boldsymbol{\\sigma} \\,\\mathrm{d}v\n$$\nThe problem asks for the contribution to this force from a single Gauss point. The integral is approximated numerically using Gauss quadrature:\n$$\n\\boldsymbol{f}_{\\text{int}} \\approx \\sum_{gp} (\\boldsymbol{B}^{\\mathsf{T}} \\boldsymbol{\\sigma} \\det(\\boldsymbol{J}) w)_{gp}\n$$\nwhere $\\boldsymbol{J}$ is the Jacobian of the isoparametric mapping, $w$ is the Gauss weight, and the evaluation is at the Gauss point $gp$. The contribution from a single Gauss point is thus $(\\boldsymbol{f}_{\\text{int}})_{gp} = (\\boldsymbol{B}^{\\mathsf{T}} \\boldsymbol{\\sigma} \\det(\\boldsymbol{J}) w)_{gp}$.\n\nThe $x$-component of the internal force at node $I$, denoted $(f_{\\text{int}, I})_x$, is the component of this vector corresponding to the degree of freedom $\\delta \\dot{u}_I$. This is obtained by taking the dot product of the first row of $\\boldsymbol{B}_I^{\\mathsf{T}}$ with the stress vector:\n$$\n(f_{\\text{int}, I})_x = \\left( \\frac{\\partial N_I}{\\partial x} \\sigma_{xx} + \\frac{\\partial N_I}{\\partial y} \\sigma_{xy} + \\frac{\\partial N_I}{\\partial z} \\sigma_{zx} \\right) \\det(\\boldsymbol{J}) w\n$$\nHere, $\\sigma_{xz}$ is used for $\\sigma_{zx}$ as the stress tensor is symmetric. We need to evaluate this for node $I=1$ at the Gauss point $(\\xi, \\eta, \\zeta) = (1/\\sqrt{3}, 1/\\sqrt{3}, 1/\\sqrt{3})$.\n\nFirst, we find the Jacobian matrix $\\boldsymbol{J}$. The element is an axis-aligned rectangular parallelepiped with nodes at the corners. The mapping from parent coordinates $\\boldsymbol{\\xi} \\in [-1,1]^3$ to spatial coordinates $\\boldsymbol{x} \\in [0,L_x]\\times[0,L_y]\\times[0,L_z]$ is given by:\n$$\nx = \\frac{L_x}{2}(1+\\xi), \\quad y = \\frac{L_y}{2}(1+\\eta), \\quad z = \\frac{L_z}{2}(1+\\zeta)\n$$\nThe Jacobian matrix is $\\boldsymbol{J} = \\frac{\\partial \\boldsymbol{x}}{\\partial \\boldsymbol{\\xi}}$:\n$$\n\\boldsymbol{J} = \\begin{pmatrix} \\frac{\\partial x}{\\partial \\xi} & \\frac{\\partial x}{\\partial \\eta} & \\frac{\\partial x}{\\partial \\zeta} \\\\ \\frac{\\partial y}{\\partial \\xi} & \\frac{\\partial y}{\\partial \\eta} & \\frac{\\partial y}{\\partial \\zeta} \\\\ \\frac{\\partial z}{\\partial \\xi} & \\frac{\\partial z}{\\partial \\eta} & \\frac{\\partial z}{\\partial \\zeta} \\end{pmatrix} = \\begin{pmatrix} L_x/2 & 0 & 0 \\\\ 0 & L_y/2 & 0 \\\\ 0 & 0 & L_z/2 \\end{pmatrix}\n$$\nThis matrix is constant. Its determinant is:\n$$\n\\det(\\boldsymbol{J}) = \\frac{L_x L_y L_z}{8} = \\frac{(0.6)(0.4)(0.2)}{8} = \\frac{0.048}{8} = 0.006 \\, \\text{m}^3\n$$\nThe inverse Jacobian is:\n$$\n\\boldsymbol{J}^{-1} = \\begin{pmatrix} 2/L_x & 0 & 0 \\\\ 0 & 2/L_y & 0 \\\\ 0 & 0 & 2/L_z \\end{pmatrix}\n$$\n\nNext, we need the spatial derivatives of the shape function for node $1$. Node $1$ has parent coordinates $(\\xi_1, \\eta_1, \\zeta_1) = (-1,-1,-1)$.\n$$\nN_1(\\xi, \\eta, \\zeta) = \\frac{1}{8}(1+\\xi\\xi_1)(1+\\eta\\eta_1)(1+\\zeta\\zeta_1) = \\frac{1}{8}(1-\\xi)(1-\\eta)(1-\\zeta)\n$$\nThe derivatives with respect to the parent coordinates are:\n$$\n\\frac{\\partial N_1}{\\partial \\xi} = -\\frac{1}{8}(1-\\eta)(1-\\zeta)\n$$\n$$\n\\frac{\\partial N_1}{\\partial \\eta} = -\\frac{1}{8}(1-\\xi)(1-\\zeta)\n$$\n$$\n\\frac{\\partial N_1}{\\partial \\zeta} = -\\frac{1}{8}(1-\\xi)(1-\\eta)\n$$\nWe evaluate these at the Gauss point $(\\xi, \\eta, \\zeta)_{gp} = (1/\\sqrt{3}, 1/\\sqrt{3}, 1/\\sqrt{3})$:\n$$\n\\frac{\\partial N_1}{\\partial \\xi}\\Big|_{gp} = \\frac{\\partial N_1}{\\partial \\eta}\\Big|_{gp} = \\frac{\\partial N_1}{\\partial \\zeta}\\Big|_{gp} = -\\frac{1}{8}\\left(1-\\frac{1}{\\sqrt{3}}\\right)^2 = -\\frac{4-2\\sqrt{3}}{24} = -\\frac{2-\\sqrt{3}}{12}\n$$\nThe spatial derivatives are found using the chain rule, $\\nabla_x N_1 = \\boldsymbol{J}^{-T} \\nabla_{\\xi} N_1$. Since $\\boldsymbol{J}$ is diagonal, $\\boldsymbol{J}^{-T} = \\boldsymbol{J}^{-1}$:\n$$\n\\begin{pmatrix} \\frac{\\partial N_1}{\\partial x} \\\\ \\frac{\\partial N_1}{\\partial y} \\\\ \\frac{\\partial N_1}{\\partial z} \\end{pmatrix} = \\begin{pmatrix} 2/L_x & 0 & 0 \\\\ 0 & 2/L_y & 0 \\\\ 0 & 0 & 2/L_z \\end{pmatrix} \\begin{pmatrix} \\frac{\\partial N_1}{\\partial \\xi} \\\\ \\frac{\\partial N_1}{\\partial \\eta} \\\\ \\frac{\\partial N_1}{\\partial \\zeta} \\end{pmatrix}\n$$\nAt the Gauss point, this gives:\n$$\n\\frac{\\partial N_1}{\\partial x}\\Big|_{gp} = \\frac{2}{L_x} \\left(-\\frac{2-\\sqrt{3}}{12}\\right) = -\\frac{2-\\sqrt{3}}{6L_x}\n$$\n$$\n\\frac{\\partial N_1}{\\partial y}\\Big|_{gp} = \\frac{2}{L_y} \\left(-\\frac{2-\\sqrt{3}}{12}\\right) = -\\frac{2-\\sqrt{3}}{6L_y}\n$$\n$$\n\\frac{\\partial N_1}{\\partial z}\\Big|_{gp} = \\frac{2}{L_z} \\left(-\\frac{2-\\sqrt{3}}{12}\\right) = -\\frac{2-\\sqrt{3}}{6L_z}\n$$\nNow we can compute the force component. The Gauss weight $w$ is given as $1$. The stress values are given in MPa ($10^6$ Pa or $10^6$ N/m$^2$):\n$\\sigma_{xx} = 120 \\times 10^6$ N/m$^2$\n$\\sigma_{xy} = 30 \\times 10^6$ N/m$^2$\n$\\sigma_{zx} = -50 \\times 10^6$ N/m$^2$\nThe lengths are $L_x=0.6$ m, $L_y=0.4$ m, $L_z=0.2$ m.\n\n$$\n(f_{\\text{int}, 1})_x = \\left[ \\left(-\\frac{2-\\sqrt{3}}{6L_x}\\right)\\sigma_{xx} + \\left(-\\frac{2-\\sqrt{3}}{6L_y}\\right)\\sigma_{xy} + \\left(-\\frac{2-\\sqrt{3}}{6L_z}\\right)\\sigma_{zx} \\right] \\det(\\boldsymbol{J}) \\cdot w\n$$\n$$\n(f_{\\text{int}, 1})_x = -\\frac{2-\\sqrt{3}}{6} \\left( \\frac{\\sigma_{xx}}{L_x} + \\frac{\\sigma_{xy}}{L_y} + \\frac{\\sigma_{zx}}{L_z} \\right) \\det(\\boldsymbol{J}) \\cdot w\n$$\nLet's compute the term in the parenthesis:\n$$\n\\frac{\\sigma_{xx}}{L_x} + \\frac{\\sigma_{xy}}{L_y} + \\frac{\\sigma_{zx}}{L_z} = \\left( \\frac{120}{0.6} + \\frac{30}{0.4} + \\frac{-50}{0.2} \\right) \\times 10^6 \\frac{\\text{N}}{\\text{m}^3}\n$$\n$$\n= (200 + 75 - 250) \\times 10^6 = 25 \\times 10^6 \\frac{\\text{N}}{\\text{m}^3}\n$$\nNow substitute all values into the force expression:\n$$\n(f_{\\text{int}, 1})_x = -\\frac{2-\\sqrt{3}}{6} \\left( 25 \\times 10^6 \\frac{\\text{N}}{\\text{m}^3} \\right) (0.006 \\, \\text{m}^3) \\cdot 1\n$$\n$$\n(f_{\\text{int}, 1})_x = -\\frac{2-\\sqrt{3}}{6} (150000) \\, \\text{N}\n$$\n$$\n(f_{\\text{int}, 1})_x = -(2-\\sqrt{3}) (25000) \\, \\text{N}\n$$\nUsing $\\sqrt{3} \\approx 1.7320508$:\n$$\n(f_{\\text{int}, 1})_x \\approx -(2 - 1.7320508) \\times 25000 = -0.2679492 \\times 25000 = -6698.73 \\, \\text{N}\n$$\nRounding to four significant figures gives $-6699$ N.",
            "answer": "$$\n\\boxed{-6699}\n$$"
        },
        {
            "introduction": "A key motivation for using an updated Lagrangian framework is its inherent ability to handle large rotations. This computational exercise demonstrates this powerful feature by contrasting two ways of approximating a rigid rotation. You will write a short program to see how composing many small, linearized increments accurately captures the rotation, revealing why the incremental, multiplicative update is a cornerstone of modern nonlinear solid mechanics codes ().",
            "id": "3608872",
            "problem": "Consider a purely kinematic large rotation benchmark in the context of the Updated Lagrangian (UL) finite element formulation for computational solid mechanics. A homogeneous, deformable body in a $2$-dimensional ($2$D) setting undergoes a rigid rotation about the origin by a prescribed total angle $\\theta$ (in radians). The motion is characterized by the mapping $\\boldsymbol{x}(\\boldsymbol{X}, t)$ from the material (reference) coordinates $\\boldsymbol{X}$ to the spatial (current) coordinates $\\boldsymbol{x}$, and the deformation gradient $\\boldsymbol{F} = \\partial \\boldsymbol{x} / \\partial \\boldsymbol{X}$. In the UL framework, the incremental kinematics for one step from configuration $n$ to configuration $n+1$ obey the relation $\\boldsymbol{F}_{n+1} = (\\boldsymbol{I} + \\nabla_{\\boldsymbol{x}} \\Delta \\boldsymbol{u}) \\boldsymbol{F}_n$, where $\\boldsymbol{I}$ is the identity tensor and $\\nabla_{\\boldsymbol{x}} \\Delta \\boldsymbol{u}$ is the spatial displacement gradient over the increment.\n\nIn this benchmark, focus on the accuracy impact of increment size when the incremental rotation is approximated using a first-order (small-angle) linearization. Specifically, compare:\n\n- A single large step that applies the total angle $\\theta$ in one increment.\n- Multiple small steps that subdivide $\\theta$ into $N$ equal increments $\\Delta \\theta = \\theta / N$ and compose them multiplicatively.\n\nFor a rigid rotation in $2$D, the exact deformation gradient is the rotation matrix $\\boldsymbol{R}(\\theta)$, which serves as the ground truth. The first-order linearized incremental rotation uses the skew-symmetric generator $\\boldsymbol{W}(\\Delta \\theta)$ associated with the angular increment $\\Delta \\theta$ to approximate the incremental mapping by $(\\boldsymbol{I} + \\boldsymbol{W}(\\Delta \\theta))$ in each step. With one large step, this yields $\\boldsymbol{F}^{\\text{single}} = \\boldsymbol{I} + \\boldsymbol{W}(\\theta)$. With $N$ small steps, this yields $\\boldsymbol{F}^{\\text{multi}}(N) = (\\boldsymbol{I} + \\boldsymbol{W}(\\theta / N))^{N}$.\n\nYour task is to implement a program that, for each test case $(\\theta, N)$, computes the following two scalar error measures:\n- $e_{\\text{single}}(\\theta) = \\lVert \\boldsymbol{F}^{\\text{single}} - \\boldsymbol{R}(\\theta) \\rVert_F$,\n- $e_{\\text{multi}}(\\theta, N) = \\lVert \\boldsymbol{F}^{\\text{multi}}(N) - \\boldsymbol{R}(\\theta) \\rVert_F$,\nwhere $\\lVert \\cdot \\rVert_F$ denotes the Frobenius norm.\n\nUse the following test suite, with angles expressed in radians and $N$ as the number of equal increments:\n- $(\\theta, N) = (0, 8)$ to test the zero-rotation boundary case.\n- $(\\theta, N) = (\\pi / 2, 8)$ to test a moderate large rotation.\n- $(\\theta, N) = (\\pi, 32)$ to test a $180^\\circ$ rotation.\n- $(\\theta, N) = (2 \\pi, 64)$ to test a full $360^\\circ$ rotation.\n- $(\\theta, N) = (-\\pi / 3, 12)$ to test a negative rotation.\n\nYour program must:\n- Treat all angles in radians.\n- For each test case, compute $e_{\\text{single}}$ and $e_{\\text{multi}}$ as defined above.\n- Produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain the errors ordered by test case, with two floating-point numbers per test case: $[e_{\\text{single,case1}}, e_{\\text{multi,case1}}, e_{\\text{single,case2}}, e_{\\text{multi,case2}}, \\dots]$.\n\nNo external input is required. The output is dimensionless since it is a norm of a difference of matrices, and angles must be handled in radians throughout.",
            "solution": "The problem statement is confirmed to be valid as it represents a standard, well-posed, and scientifically grounded benchmark in computational solid mechanics. It is free of contradictions, ambiguities, or factual errors. We may therefore proceed with a formal solution.\n\nThe objective is to quantify the error resulting from a first-order linearization of a large rigid body rotation in a 2D space. This error is evaluated for two distinct numerical strategies within an Updated Lagrangian (UL) framework: a single incremental step encompassing the total rotation, and a sequence of multiple smaller incremental steps. The exact solution, which serves as the ground truth for error computation, is the pure rotation matrix.\n\nFirst, we define the key mathematical objects in a $2$-dimensional Cartesian coordinate system.\n\nThe exact deformation gradient, $\\boldsymbol{F}$, for a rigid body rotation by an angle $\\theta$ about the origin is given by the rotation matrix $\\boldsymbol{R}(\\theta)$. In $2$D, this is:\n$$\n\\boldsymbol{R}(\\theta) = \\begin{pmatrix} \\cos\\theta & -\\sin\\theta \\\\ \\sin\\theta & \\cos\\theta \\end{pmatrix}\n$$\nThis matrix represents the ground truth against which we will compare our approximations.\n\nThe problem states that the incremental rotation is approximated using a first-order Taylor expansion around the identity. The exact rotation over a small angle $\\Delta\\theta$ is $\\boldsymbol{R}(\\Delta\\theta)$. For small $\\Delta\\theta$, we have $\\cos(\\Delta\\theta) \\approx 1$ and $\\sin(\\Delta\\theta) \\approx \\Delta\\theta$. The first-order approximation of $\\boldsymbol{R}(\\Delta\\theta)$ is:\n$$\n\\boldsymbol{R}(\\Delta\\theta) \\approx \\boldsymbol{I} + \\boldsymbol{W}(\\Delta\\theta)\n$$\nwhere $\\boldsymbol{I}$ is the $2 \\times 2$ identity matrix and $\\boldsymbol{W}(\\Delta\\theta)$ is the skew-symmetric generator of the rotation group $SO(2)$:\n$$\n\\boldsymbol{I} = \\begin{pmatrix} 1 & 0 \\\\ 0 & 1 \\end{pmatrix}, \\quad \\boldsymbol{W}(\\Delta\\theta) = \\begin{pmatrix} 0 & -\\Delta\\theta \\\\ \\Delta\\theta & 0 \\end{pmatrix}\n$$\nThis linear approximation forms the basis of the two numerical schemes to be evaluated.\n\n**1. Single-Step Approximation**\n\nIn this approach, the entire rotation $\\theta$ is treated as a single incremental step. The approximation for the deformation gradient, denoted $\\boldsymbol{F}^{\\text{single}}$, is obtained by setting $\\Delta\\theta = \\theta$:\n$$\n\\boldsymbol{F}^{\\text{single}} = \\boldsymbol{I} + \\boldsymbol{W}(\\theta) = \\begin{pmatrix} 1 & -\\theta \\\\ \\theta & 1 \\end{pmatrix}\n$$\nThis is a very coarse approximation and is expected to be accurate only for $|\\theta| \\ll 1$.\n\n**2. Multi-Step Approximation**\n\nThis strategy subdivides the total rotation angle $\\theta$ into $N$ equal increments, each of size $\\Delta\\theta = \\theta / N$. The deformation gradient for one small increment is approximated as $\\boldsymbol{F}_{\\text{inc}} = \\boldsymbol{I} + \\boldsymbol{W}(\\Delta\\theta) = \\boldsymbol{I} + \\boldsymbol{W}(\\theta/N)$. In the UL formulation, the total deformation is the product of incremental deformations. Thus, the final deformation gradient, $\\boldsymbol{F}^{\\text{multi}}(N)$, is the result of composing these $N$ increments:\n$$\n\\boldsymbol{F}^{\\text{multi}}(N) = \\underbrace{(\\boldsymbol{I} + \\boldsymbol{W}(\\theta/N)) \\dots (\\boldsymbol{I} + \\boldsymbol{W}(\\theta/N))}_{N \\text{ times}} = \\left(\\boldsymbol{I} + \\boldsymbol{W}(\\theta/N)\\right)^N\n$$\nThis composition of small, linearized steps is a fundamental concept in geometric numerical integration. As $N \\to \\infty$, this expression converges to the matrix exponential of $\\boldsymbol{W}(\\theta)$:\n$$\n\\lim_{N \\to \\infty} \\left(\\boldsymbol{I} + \\frac{\\boldsymbol{W}(\\theta)}{N}\\right)^N = \\exp(\\boldsymbol{W}(\\theta))\n$$\nIt is a known property of Lie groups that the exponential of the generator gives the group element, i.e., $\\exp(\\boldsymbol{W}(\\theta)) = \\boldsymbol{R}(\\theta)$. Therefore, the multi-step approximation is expected to converge to the exact solution as the number of steps $N$ increases.\n\n**Error Quantification**\n\nThe error in each approximation is measured using the Frobenius norm of the difference between the approximate and the exact deformation gradients. The Frobenius norm of a matrix $\\boldsymbol{A}$ is given by $\\lVert \\boldsymbol{A} \\rVert_F = \\sqrt{\\sum_{i,j} A_{ij}^2}$.\n\nThe two error measures are:\n-   Single-step error: $e_{\\text{single}}(\\theta) = \\lVert \\boldsymbol{F}^{\\text{single}} - \\boldsymbol{R}(\\theta) \\rVert_F$\n-   Multi-step error: $e_{\\text{multi}}(\\theta, N) = \\lVert \\boldsymbol{F}^{\\text{multi}}(N) - \\boldsymbol{R}(\\theta) \\rVert_F$\n\n**Algorithm for Implementation**\n\nFor each given test case $(\\theta, N)$:\n1.  Construct the identity matrix $\\boldsymbol{I}$.\n2.  Compute the exact rotation matrix $\\boldsymbol{R}(\\theta)$ using the values of $\\cos\\theta$ and $\\sin\\theta$.\n3.  **Single-step path**:\n    a. Construct the generator matrix $\\boldsymbol{W}(\\theta)$.\n    b. Compute $\\boldsymbol{F}^{\\text{single}} = \\boldsymbol{I} + \\boldsymbol{W}(\\theta)$.\n    c. Calculate the error $e_{\\text{single}} = \\lVert \\boldsymbol{F}^{\\text{single}} - \\boldsymbol{R}(\\theta) \\rVert_F$.\n4.  **Multi-step path**:\n    a. Calculate the incremental angle $\\Delta\\theta = \\theta / N$.\n    b. Construct the incremental generator matrix $\\boldsymbol{W}(\\Delta\\theta)$.\n    c. Form the incremental deformation approximation $\\boldsymbol{F}_{\\text{inc}} = \\boldsymbol{I} + \\boldsymbol{W}(\\Delta\\theta)$.\n    d. Compute the total deformation by matrix exponentiation: $\\boldsymbol{F}^{\\text{multi}}(N) = (\\boldsymbol{F}_{\\text{inc}})^N$.\n    e. Calculate the error $e_{\\text{multi}} = \\lVert \\boldsymbol{F}^{\\text{multi}}(N) - \\boldsymbol{R}(\\theta) \\rVert_F$.\n5.  Store the computed errors $e_{\\text{single}}$ and $e_{\\text{multi}}$ for the final output.\n\nThis procedure will be systematically applied to all test cases provided. The numerical implementation will utilize the `numpy` library for efficient matrix operations, including matrix power and norm calculations.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and compares errors for two different numerical approximations\n    of a large 2D rigid rotation in an Updated Lagrangian framework.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple (theta_in_radians, N_steps).\n    test_cases = [\n        (0.0, 8),\n        (np.pi / 2, 8),\n        (np.pi, 32),\n        (2 * np.pi, 64),\n        (-np.pi / 3, 12),\n    ]\n\n    results = []\n    \n    # Identity matrix in 2D\n    I = np.identity(2)\n\n    for theta, N in test_cases:\n        # --- Ground Truth Calculation ---\n        # The exact deformation gradient is the rotation matrix R(theta).\n        c, s = np.cos(theta), np.sin(theta)\n        R_theta = np.array([[c, -s], \n                            [s,  c]])\n\n        # --- Single-Step Approximation ---\n        # F_single = I + W(theta), where W is the skew-symmetric generator.\n        W_theta = np.array([[0, -theta], \n                            [theta, 0]])\n        F_single = I + W_theta\n        \n        # Calculate single-step error using the Frobenius norm.\n        e_single = np.linalg.norm(F_single - R_theta, 'fro')\n\n        # --- Multi-Step Approximation ---\n        # F_multi = (I + W(theta/N))^N\n        # This handles the N > 0 cases as specified.\n        # The case theta = 0 results in d_theta = 0, W_d_theta = 0, F_inc = I,\n        # F_multi = I, which is the correct result.\n        d_theta = theta / N\n        W_d_theta = np.array([[0, -d_theta], \n                                [d_theta, 0]])\n        F_inc = I + W_d_theta\n        \n        # Compute F_multi by raising the incremental matrix to the power of N.\n        F_multi = np.linalg.matrix_power(F_inc, N)\n\n        # Calculate multi-step error using the Frobenius norm.\n        e_multi = np.linalg.norm(F_multi - R_theta, 'fro')\n\n        # Append the two error measures for the current test case.\n        results.append(e_single)\n        results.append(e_multi)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}