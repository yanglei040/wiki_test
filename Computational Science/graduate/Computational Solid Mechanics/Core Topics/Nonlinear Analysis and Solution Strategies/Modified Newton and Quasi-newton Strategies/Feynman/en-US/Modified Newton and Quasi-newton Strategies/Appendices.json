{
    "hands_on_practices": [
        {
            "introduction": "To master nonlinear solution strategies, we must first master the foundational method from which they are derived. This exercise walks you through a single iteration of the full Newton-Raphson method for a materially nonlinear bar. By deriving the residual vector and the consistent tangent stiffness matrix from first principles, you will solidify your understanding of how a nonlinear system is linearized to find a corrective step toward equilibrium .",
            "id": "3582791",
            "problem": "A straight, prismatic one-dimensional bar of length $L$ and constant cross-sectional area $A$ is modeled by a single two-node linear finite element with nodal displacements $u_{1}$ and $u_{2}$. The bar is fixed at node $1$ so that $u_{1}=0$ and is subjected to a concentrated axial load $f$ applied at node $2$. Assume small-strain kinematics with axial strain $\\varepsilon = du/dx$, and let the displacement field be interpolated by linear shape functions $N_{1}(x)=1-x/L$ and $N_{2}(x)=x/L$, so that $u(x)=N_{1}(x)\\,u_{1}+N_{2}(x)\\,u_{2}$ and $\\varepsilon(x)=B\\,u_{e}$ with $B=\\left[-1/L,\\;1/L\\right]$ and $u_{e}=\\begin{pmatrix}u_{1}\\\\u_{2}\\end{pmatrix}$. The material is hyperelastic with a one-dimensional constitutive relation $\\sigma(\\varepsilon)=E\\,\\varepsilon+\\alpha\\,\\varepsilon^{3}$, where $E$ and $\\alpha$ are positive constants.\n\nStarting from the finite element residual statement $R(u)=\\int_{0}^{L}B^{\\top}\\,\\sigma(Bu)\\,A\\,dx - f$ for the free degree of freedom at node $2$, derive the consistent scalar tangent stiffness $K(u)=dR/du$ in terms of $E$, $\\alpha$, $L$, $A$, and the current scalar displacement $u:=u_{2}$. Then, for the specific data $L=1.0$ m, $A=2.0\\times 10^{-4}$ m$^{2}$, $E=2.0\\times 10^{9}$ Pa, $\\alpha=1.0\\times 10^{10}$ Pa, applied load $f=1.0\\times 10^{5}$ N, and current Newton iterate $u_{k}=0.20$ m, compute the numerical values of $K(u_{k})$ and the Newton update $\\Delta u=-R(u_{k})/K(u_{k})$. Express the final update $\\Delta u$ in millimeters and round your answer to four significant figures.",
            "solution": "The problem is validated as being scientifically grounded, well-posed, and objective, despite a minor ambiguity in the definition of the residual which can be resolved from first principles. The use of a small-strain kinematic model in a context that yields a large strain value ($20\\%$) is interpreted as a deliberate simplification for an academic problem, not a fundamental flaw.\n\nThe problem asks for the derivation of the consistent tangent stiffness and the calculation of a Newton-Raphson update for a one-dimensional, materially nonlinear finite element model.\n\nFirst, we establish the scalar residual equation $R(u)$ for the free degree of freedom, which is the displacement at node $2$, denoted by $u := u_2$. The boundary condition is $u_1=0$. The residual is the difference between the internal force at node $2$, $F_{int,2}$, and the external applied force, $f$.\n$$R(u) = F_{int,2}(u) - f$$\nThe internal force is derived from the integral of the stress over the element domain, weighted by the appropriate derivative of the shape function. For node $2$, this is:\n$$F_{int,2}(u) = \\int_{0}^{L} N_{2,x}(x) \\, \\sigma(\\varepsilon(u)) \\, A \\, dx$$\nThe displacement field is $u(x) = N_1(x)u_1 + N_2(x)u_2 = (1-x/L)u_1 + (x/L)u_2$. Given $u_1=0$ and $u_2=u$, this becomes $u(x) = (x/L)u$.\nThe axial strain $\\varepsilon$ is defined as $\\varepsilon = du/dx$.\n$$\\varepsilon = \\frac{d}{dx}\\left(\\frac{x}{L}u\\right) = \\frac{u}{L}$$\nAlternatively, using the given strain-displacement matrix $B = [-1/L, 1/L]$ and the nodal displacement vector $u_e = \\begin{pmatrix} u_1 \\\\ u_2 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ u \\end{pmatrix}$:\n$$\\varepsilon = B u_e = \\begin{pmatrix} -1/L & 1/L \\end{pmatrix} \\begin{pmatrix} 0 \\\\ u \\end{pmatrix} = \\frac{u}{L}$$\nSince the strain $\\varepsilon$ is constant throughout the element, the stress $\\sigma$ is also constant. The constitutive relation is $\\sigma(\\varepsilon) = E\\varepsilon + \\alpha\\varepsilon^3$. Substituting $\\varepsilon = u/L$:\n$$\\sigma(u) = E\\left(\\frac{u}{L}\\right) + \\alpha\\left(\\frac{u}{L}\\right)^3$$\nThe derivative of the second shape function is $N_{2,x}(x) = d/dx(x/L) = 1/L$.\nNow we can compute the internal force integral:\n$$F_{int,2}(u) = \\int_{0}^{L} \\frac{1}{L} \\left[ E\\left(\\frac{u}{L}\\right) + \\alpha\\left(\\frac{u}{L}\\right)^3 \\right] A \\, dx$$\nSince all terms in the integrand are constant with respect to $x$:\n$$F_{int,2}(u) = \\frac{A}{L} \\left[ E\\frac{u}{L} + \\alpha\\frac{u^3}{L^3} \\right] \\int_{0}^{L} dx = \\frac{A}{L} \\left[ E\\frac{u}{L} + \\alpha\\frac{u^3}{L^3} \\right] L$$\n$$F_{int,2}(u) = A \\left[ \\frac{E}{L}u + \\frac{\\alpha}{L^3}u^3 \\right]$$\nThe scalar residual equation is therefore:\n$$R(u) = \\frac{AE}{L}u + \\frac{A\\alpha}{L^3}u^3 - f$$\nNext, we derive the consistent scalar tangent stiffness $K(u)$ by differentiating the residual $R(u)$ with respect to the displacement $u$.\n$$K(u) = \\frac{dR}{du} = \\frac{d}{du}\\left( \\frac{AE}{L}u + \\frac{A\\alpha}{L^3}u^3 - f \\right)$$\n$$K(u) = \\frac{AE}{L} + 3\\frac{A\\alpha}{L^3}u^2$$\nThis is the symbolic expression for the tangent stiffness.\n\nNow we substitute the given numerical values to compute $K(u_k)$ and the Newton update $\\Delta u$.\nThe given data are:\n$L = 1.0$ m\n$A = 2.0 \\times 10^{-4}$ m$^2$\n$E = 2.0 \\times 10^9$ Pa\n$\\alpha = 1.0 \\times 10^{10}$ Pa\n$f = 1.0 \\times 10^5$ N\nCurrent displacement iterate: $u_k = 0.20$ m\n\nFirst, we calculate the tangent stiffness $K(u_k)$ at $u_k = 0.20$ m.\n$$K(u_k) = \\frac{(2.0 \\times 10^{-4})(2.0 \\times 10^9)}{1.0} + \\frac{3(2.0 \\times 10^{-4})(1.0 \\times 10^{10})}{(1.0)^3}(0.20)^2$$\nThe first term is the linear stiffness:\n$$K_{linear} = (2.0 \\times 10^{-4})(2.0 \\times 10^9) = 4.0 \\times 10^5 \\, \\text{N/m}$$\nThe second term is the nonlinear contribution:\n$$K_{nonlinear} = 3(2.0 \\times 10^{-4})(1.0 \\times 10^{10})(0.04) = (6.0 \\times 10^{-4})(1.0 \\times 10^{10})(0.04) = (6.0 \\times 10^6)(0.04) = 2.4 \\times 10^5 \\, \\text{N/m}$$\nThe total tangent stiffness is:\n$$K(u_k) = 4.0 \\times 10^5 + 2.4 \\times 10^5 = 6.4 \\times 10^5 \\, \\text{N/m}$$\nNext, we calculate the residual $R(u_k)$ at $u_k = 0.20$ m.\n$$R(u_k) = \\frac{(2.0 \\times 10^{-4})(2.0 \\times 10^9)}{1.0}(0.20) + \\frac{(2.0 \\times 10^{-4})(1.0 \\times 10^{10})}{(1.0)^3}(0.20)^3 - 1.0 \\times 10^5$$\n$$R(u_k) = (4.0 \\times 10^5)(0.20) + (2.0 \\times 10^6)(0.008) - 1.0 \\times 10^5$$\n$$R(u_k) = 8.0 \\times 10^4 + 1.6 \\times 10^4 - 1.0 \\times 10^5$$\n$$R(u_k) = 9.6 \\times 10^4 - 1.0 \\times 10^5 = -0.04 \\times 10^5 = -4000 \\, \\text{N}$$\nThe Newton update $\\Delta u$ is given by the formula $\\Delta u = -R(u_k) / K(u_k)$.\n$$\\Delta u = - \\frac{-4000 \\, \\text{N}}{6.4 \\times 10^5 \\, \\text{N/m}} = \\frac{4000}{640000} \\, \\text{m} = \\frac{4}{640} \\, \\text{m} = \\frac{1}{160} \\, \\text{m}$$\n$$\\Delta u = 0.00625 \\, \\text{m}$$\nThe problem asks for the answer in millimeters (mm), rounded to four significant figures.\n$$\\Delta u = 0.00625 \\, \\text{m} \\times \\frac{1000 \\, \\text{mm}}{1 \\, \\text{m}} = 6.25 \\, \\text{mm}$$\nRounding to four significant figures gives $6.250$ mm.",
            "answer": "$$\\boxed{6.250}$$"
        },
        {
            "introduction": "While the full Newton-Raphson method offers rapid quadratic convergence, its computational cost per iteration can be prohibitive. This practice explores the modified Newton strategy, a common alternative that trades convergence speed for computational efficiency by reusing the tangent stiffness matrix across multiple iterations. By analyzing a hypothetical cost model, you will quantify the performance trade-offs and gain insight into the practical decision-making behind choosing a nonlinear solver .",
            "id": "3582866",
            "problem": "A three-dimensional elastoplastic block, discretized by the Finite Element Method (FEM), is driven by a monotonic, displacement-controlled load path with $8$ equal increments. The nonlinear equilibrium problem at each increment is solved by the Newton–Raphson (NR) method, which seeks $\\mathbf{u}$ such that the residual $\\mathbf{R}(\\mathbf{u}) = \\mathbf{0}$, where $\\mathbf{R}(\\mathbf{u}) = \\mathbf{f}^{\\text{ext}} - \\mathbf{f}^{\\text{int}}(\\mathbf{u})$. In full Newton, the consistent tangent stiffness $\\mathbf{K}_{T}(\\mathbf{u}^{(k)})$ is assembled and factorized at each iteration $k$. In the modified Newton scheme, the tangent $\\mathbf{K}_{T}$ is assembled and factorized only once at the start of each load increment and reused for all subsequent iterations within that increment. \n\nThe Degrees of Freedom (DOF) remain fixed throughout the analysis. Assume one linear system backsolve per iteration and no line search, no constraint solves, and no contact iterations. The measured computational costs for the employed sparse solver and element routines on this problem are:\n- Tangent assembly time per assembly $t_{a} = 0.90$ seconds.\n- Sparse factorization time per factorization $t_{f} = 2.80$ seconds.\n- Single right-hand-side backsolve time per iteration $t_{s} = 0.14$ seconds.\n\nThe recorded iteration counts per load increment for full Newton (denote by $N_{i}$) and for modified Newton (denote by $M_{i}$) are:\n- Load increment $1$: $N_{1} = 4$, $M_{1} = 5$.\n- Load increment $2$: $N_{2} = 3$, $M_{2} = 4$.\n- Load increment $3$: $N_{3} = 3$, $M_{3} = 5$.\n- Load increment $4$: $N_{4} = 5$, $M_{4} = 7$.\n- Load increment $5$: $N_{5} = 6$, $M_{5} = 8$.\n- Load increment $6$: $N_{6} = 7$, $M_{6} = 9$.\n- Load increment $7$: $N_{7} = 7$, $M_{7} = 10$.\n- Load increment $8$: $N_{8} = 8$, $M_{8} = 11$.\n\nTasks:\n1. Compute the total number of factorization reuses achieved by the modified Newton scheme over the entire load path relative to full Newton.\n2. Compute the total number of additional iterations required by the modified Newton scheme relative to full Newton.\n3. Using the given computational cost model, estimate the net runtime savings of modified Newton compared to full Newton over the entire load path.\n\nExpress the final answer as the net runtime savings in seconds. Round your answer to four significant figures. Use seconds as the unit for any intermediate results and the final reported quantity.",
            "solution": "The problem statement is first validated according to the specified criteria.\n\n**Step 1: Extract Givens**\n- Analysis type: Three-dimensional elastoplastic block discretized by FEM.\n- Loading: Monotonic, displacement-controlled, with $n_{\\text{inc}} = 8$ equal increments.\n- Nonlinear solver: Newton-Raphson (NR) method for $\\mathbf{R}(\\mathbf{u}) = \\mathbf{0}$.\n- Full Newton (FN) scheme: Tangent stiffness $\\mathbf{K}_{T}$ is assembled and factorized at each iteration.\n- Modified Newton (MN) scheme: $\\mathbf{K}_{T}$ is assembled and factorized only once at the start of each load increment.\n- Computational costs:\n  - Tangent assembly time: $t_{a} = 0.90$ seconds.\n  - Sparse factorization time: $t_{f} = 2.80$ seconds.\n  - Backsolve time: $t_{s} = 0.14$ seconds.\n- Assumptions: One backsolve per iteration, no line search, no constraint solves, no contact iterations.\n- Iteration counts for FN ($N_{i}$) and MN ($M_{i}$) per increment $i$:\n  - $N_1 = 4$, $M_1 = 5$.\n  - $N_2 = 3$, $M_2 = 4$.\n  - $N_3 = 3$, $M_3 = 5$.\n  - $N_4 = 5$, $M_4 = 7$.\n  - $N_5 = 6$, $M_5 = 8$.\n  - $N_6 = 7$, $M_6 = 9$.\n  - $N_7 = 7$, $M_7 = 10$.\n  - $N_8 = 8$, $M_8 = 11$.\n- Required output: Net runtime savings of MN compared to FN, rounded to four significant figures.\n\n**Step 2: Validate Using Extracted Givens**\n- **Scientifically Grounded:** The problem is firmly rooted in the field of computational solid mechanics, specifically concerning the numerical solution of nonlinear systems arising from the Finite Element Method. The concepts of full Newton and modified Newton methods, tangent stiffness assembly, factorization, back-substitution, and their associated computational costs are standard and well-established.\n- **Well-Posed:** All necessary data (computational times for atomic operations, number of increments, and iteration counts for both methods) are provided. The tasks are specific and calculable, leading to a unique numerical solution. The assumptions simplify the cost model but do not render it invalid; they create a clear, self-contained problem.\n- **Objective:** The problem is described using precise, objective technical language and numerical data. It is free from ambiguity and subjective claims.\n- **Conclusion:** The problem is scientifically sound, well-posed, complete, and objective. It does not violate any of the invalidity criteria.\n\n**Step 3: Verdict and Action**\nThe problem is valid. A full solution will be provided.\n\n**Solution Derivation**\n\nThe primary objective is to calculate the net runtime savings, $\\Delta T$, achieved by using the modified Newton (MN) scheme instead of the full Newton (FN) scheme. This saving is the difference between the total computational time for each method:\n$$ \\Delta T = T_{\\text{FN}} - T_{\\text{MN}} $$\n\nLet $n_{\\text{inc}} = 8$ be the number of load increments. We model the total computational time for each scheme by summing the costs over all increments.\n\n**Cost Model for Full Newton (FN)**\nIn the full Newton-Raphson method, the tangent stiffness matrix is assembled and factorized at every iteration. Therefore, the cost of a single iteration is the sum of the assembly time $t_a$, factorization time $t_f$, and backsolve time $t_s$. For load increment $i$, which requires $N_i$ iterations, the computational cost is:\n$$ T_{\\text{FN},i} = N_i (t_a + t_f + t_s) $$\nThe total cost over all $n_{\\text{inc}}$ increments is the sum of the costs for each increment:\n$$ T_{\\text{FN}} = \\sum_{i=1}^{n_{\\text{inc}}} T_{\\text{FN},i} = \\sum_{i=1}^{8} N_i (t_a + t_f + t_s) = \\left(\\sum_{i=1}^{8} N_i\\right) (t_a + t_f + t_s) $$\n\n**Cost Model for Modified Newton (MN)**\nIn the modified Newton method, the tangent stiffness matrix is assembled and factorized only once at the beginning of each load increment. This cost, $(t_a + t_f)$, is incurred once per increment. Each of the $M_i$ iterations within increment $i$ requires a backsolve. Thus, the computational cost for increment $i$ is:\n$$ T_{\\text{MN},i} = (t_a + t_f) + M_i t_s $$\nThe total cost over all $n_{\\text{inc}}$ increments is:\n$$ T_{\\text{MN}} = \\sum_{i=1}^{n_{\\text{inc}}} T_{\\text{MN},i} = \\sum_{i=1}^{8} ((t_a + t_f) + M_i t_s) = n_{\\text{inc}}(t_a + t_f) + \\left(\\sum_{i=1}^{8} M_i\\right) t_s $$\n\n**Calculations**\n\nFirst, we calculate the total number of iterations for each method.\nTotal iterations for FN, $N_{\\text{total}}$:\n$$ N_{\\text{total}} = \\sum_{i=1}^{8} N_i = 4 + 3 + 3 + 5 + 6 + 7 + 7 + 8 = 43 $$\nTotal iterations for MN, $M_{\\text{total}}$:\n$$ M_{\\text{total}} = \\sum_{i=1}^{8} M_i = 5 + 4 + 5 + 7 + 8 + 9 + 10 + 11 = 59 $$\n\nNow, we address the intermediate tasks for completeness.\n1.  **Total factorization reuses:** In the MN scheme, a factorization is performed once per increment. For an increment with $M_i$ iterations, the factorization is reused $M_i - 1$ times. The total number of reuses is $\\sum_{i=1}^{8} (M_i - 1) = M_{\\text{total}} - 8 = 59 - 8 = 51$.\n2.  **Total additional iterations:** The number of additional iterations required by MN relative to FN is $M_{\\text{total}} - N_{\\text{total}} = 59 - 43 = 16$.\n\nNext, we compute the total runtimes using the given cost data: $t_a = 0.90 \\, \\text{s}$, $t_f = 2.80 \\, \\text{s}$, $t_s = 0.14 \\, \\text{s}$.\n\nCalculating $T_{\\text{FN}}$:\n$$ T_{\\text{FN}} = N_{\\text{total}} (t_a + t_f + t_s) = 43 \\times (0.90 + 2.80 + 0.14) \\, \\text{s} $$\n$$ T_{\\text{FN}} = 43 \\times 3.84 \\, \\text{s} = 165.12 \\, \\text{s} $$\n\nCalculating $T_{\\text{MN}}$:\n$$ T_{\\text{MN}} = n_{\\text{inc}}(t_a + t_f) + M_{\\text{total}} t_s = 8 \\times (0.90 + 2.80) \\, \\text{s} + 59 \\times 0.14 \\, \\text{s} $$\n$$ T_{\\text{MN}} = 8 \\times 3.70 \\, \\text{s} + 8.26 \\, \\text{s} $$\n$$ T_{\\text{MN}} = 29.60 \\, \\text{s} + 8.26 \\, \\text{s} = 37.86 \\, \\text{s} $$\n\nFinally, we compute the net runtime savings, $\\Delta T$.\n$$ \\Delta T = T_{\\text{FN}} - T_{\\text{MN}} = 165.12 \\, \\text{s} - 37.86 \\, \\text{s} = 127.26 \\, \\text{s} $$\n\nThe problem requires the answer to be rounded to four significant figures. The value $127.26$ rounded to four significant figures is $127.3$.",
            "answer": "$$\\boxed{127.3}$$"
        },
        {
            "introduction": "Quasi-Newton methods represent a sophisticated middle ground, updating the tangent approximation without re-computing it from scratch. This exercise challenges you to implement the Limited-Memory Broyden–Fletcher–Goldfarb–Shanno (L-BFGS) algorithm, a powerhouse of large-scale optimization. By coding the famous two-loop recursion, you will learn how an approximation to the inverse Hessian can be efficiently applied, providing a powerful descent direction without the cost of matrix factorization .",
            "id": "3582815",
            "problem": "Implement a limited-memory Broyden–Fletcher–Goldfarb–Shanno (L-BFGS) two-loop recursion that applies the inverse Hessian approximation $H_k$ to a vector without ever forming $H_k$ explicitly, in the setting of minimizing a finite element potential energy $\\phi(u)$ for a small nonlinear spring network. Begin from the fundamental base that in computational solid mechanics, equilibrium of a discrete system is obtained by minimizing the potential energy functional $\\phi(u)$, with first-order optimality expressed as the residual $g(u) = \\nabla \\phi(u) = 0$, and that Newton’s method is derived from the Taylor expansion of $\\phi(u)$ with the Hessian $K(u) = \\nabla^2 \\phi(u)$ serving as the tangent stiffness. To reduce the cost of forming and factorizing $K(u)$, quasi-Newton strategies build an approximation $B_k \\approx K(u_k)$, with $H_k = B_k^{-1}$, and enforce the secant condition $B_{k+1}s_k = y_k$, where $s_k = u_{k+1} - u_k$ and $y_k = g_{k+1} - g_k$. The Broyden–Fletcher–Goldfarb–Shanno update is a well-tested positive definite update under the curvature condition $s_k^\\top y_k > 0$, and the limited-memory variant stores only the last $m$ pairs $(s_i, y_i)$ and applies $H_k$ to a vector by a two-loop recursion.\n\nDefine a dimensionless potential energy for a two-degree-of-freedom discrete spring network as\n$$\n\\phi(u) = \\sum_{i=1}^2 \\left( \\tfrac{1}{2} k_i (a_i^\\top u)^2 + \\tfrac{1}{4} c_i (a_i^\\top u)^4 \\right) - f^\\top u,\n$$\nwhere $u \\in \\mathbb{R}^2$, $a_1 = [1,\\,0]^\\top$, $a_2 = [1,\\,1]^\\top$, $k = [k_1,\\,k_2]^\\top$, $c = [c_1,\\,c_2]^\\top$, and $f \\in \\mathbb{R}^2$. The gradient is\n$$\ng(u) = \\nabla \\phi(u) = \\sum_{i=1}^2 \\left( k_i (a_i^\\top u) + c_i (a_i^\\top u)^3 \\right) a_i - f.\n$$\nUse this model only to generate consistent $(s_i, y_i)$ pairs for the test suite. Your program must implement:\n\n- A function that, given lists of at most $m$ stored pairs $\\{(s_i, y_i)\\}$, a vector $q$, and an initial scalar $ \\gamma_k > 0$ defining $H_0 = \\gamma_k I$, computes $r = H_k q$ using the standard two-loop recursion without forming $H_k$.\n- The curvature screening: skip any pair with $s_i^\\top y_i \\le \\delta$, where $\\delta = \\varepsilon \\|s_i\\| \\, \\|y_i\\|$ and $\\varepsilon = 10^{-12}$.\n- The initial scaling $ \\gamma_k$ set as $ \\gamma_k = \\dfrac{s_{k-1}^\\top y_{k-1}}{y_{k-1}^\\top y_{k-1}}$ if there is at least one valid stored pair, otherwise $ \\gamma_k = 1$.\n\nConstruct the following test suite. All quantities are dimensionless; no physical units are required.\n\n- Test $1$ (mechanics-consistent pairs and applying $H_k$ to the current gradient): Let $k_1 = 10$, $k_2 = 5$, $c_1 = 1$, $c_2 = 0.5$, $f = [1,\\,0.2]^\\top$, $u_0 = [0,\\,0]^\\top$, $u_1 = [0.1,\\,-0.05]^\\top$, $u_2 = [0.18,\\,-0.06]^\\top$. Compute $g(u_j)$ for $j \\in \\{0,1,2\\}$, $s_0 = u_1 - u_0$, $s_1 = u_2 - u_1$, $y_0 = g(u_1) - g(u_0)$, $y_1 = g(u_2) - g(u_1)$. Store the last $m = 2$ pairs in chronological order $(s_0,y_0)$, $(s_1,y_1)$ after applying the curvature screening. Set $q = g(u_2)$. Compute $r^{(1)} = H_k q$ using the two-loop recursion with $ \\gamma_k$ as defined above. Return the two components of $r^{(1)}$ as a list of two floats.\n- Test $2$ (general vector application): Using the same stored pairs and the same $ \\gamma_k$ as in Test $1$, set $q = [1,\\,-1]^\\top$ and compute $r^{(2)} = H_k q$. Return the two components of $r^{(2)}$ as a list of two floats.\n- Test $3$ (empty memory boundary case): Use $m = 0$ (no stored pairs), $ \\gamma_k = 1$, and $q = [0.3,\\,-0.4]^\\top$. Compute $r^{(3)} = H_k q$. Return the two components of $r^{(3)}$ as a list of two floats.\n- Test $4$ (curvature screening edge case): Use one pair with $s = [10^{-8},\\,0]^\\top$, $y = [-10^{-8},\\,0]^\\top$, $m = 1$, $q = [0.2,\\,0.5]^\\top$. Since $s^\\top y \\le 0$, this pair must be skipped by the screening rule; with no valid pairs remaining, use $ \\gamma_k = 1$. Compute $r^{(4)} = H_k q$. Return the two components of $r^{(4)}$ as a list of two floats.\n- Test $5$ (descent property check): Using the valid pairs and $ \\gamma_k$ from Test $1$, set $q = g(u_2)$, compute $p = - H_k q$, and return the boolean value of the statement $q^\\top p < 0$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order $[r^{(1)}, r^{(2)}, r^{(3)}, r^{(4)}, \\text{descent}]$, where each $r^{(i)}$ for $i \\in \\{1,2,3,4\\}$ is itself a list of two floats and $\\text{descent}$ is a boolean. For example, a valid output shape is $[[x_1, x_2],[y_1, y_2],[z_1, z_2],[w_1, w_2],\\text{True}]$ with the actual computed numbers replacing $x_1$, $x_2$, $y_1$, $y_2$, $z_1$, $z_2$, $w_1$, and $w_2$.",
            "solution": "The fundamental base is that equilibrium of a discrete solid mechanics system arises from minimizing the potential energy $\\phi(u)$ so that the first-order condition $g(u) = \\nabla \\phi(u) = 0$ holds. A Newton iteration for solving $g(u) = 0$ follows from the Taylor expansion $g(u + \\Delta u) \\approx g(u) + K(u) \\Delta u$ with $K(u) = \\nabla^2 \\phi(u)$, so that $K(u) \\Delta u = -g(u)$. In nonlinear finite elements, explicitly assembling and factorizing $K(u)$ can be computationally expensive. Quasi-Newton methods construct an approximation $B_k \\approx K(u_k)$ such that the secant condition $B_{k+1} s_k = y_k$ holds, where $s_k = u_{k+1} - u_k$ and $y_k = g_{k+1} - g_k$. The Broyden–Fletcher–Goldfarb–Shanno update is a well-tested positive definite update defined by\n$$\nB_{k+1} = B_k - \\frac{B_k s_k s_k^\\top B_k}{s_k^\\top B_k s_k} + \\frac{y_k y_k^\\top}{s_k^\\top y_k},\n$$\nunder the curvature condition $s_k^\\top y_k > 0$. Its inverse $H_{k+1} = B_{k+1}^{-1}$ can be updated by\n$$\nH_{k+1} = \\left(I - \\rho_k s_k y_k^\\top\\right) H_k \\left(I - \\rho_k y_k s_k^\\top\\right) + \\rho_k s_k s_k^\\top, \\quad \\rho_k = \\frac{1}{y_k^\\top s_k},\n$$\nand remains positive definite if $H_k$ is positive definite and $s_k^\\top y_k > 0$. Positive definiteness implies that for any nonzero $q$, $q^\\top H_k q > 0$, hence the direction $p_k = - H_k g_k$ is a strict descent direction because $g_k^\\top p_k = - g_k^\\top H_k g_k < 0$.\n\nThe limited-memory version avoids storing $H_k$ or $B_k$ explicitly. Instead, it stores the last $m$ pairs $\\{(s_i, y_i)\\}$ and applies $H_k$ to a vector $q$ through the two-loop recursion. Label the pairs in chronological order with $i = 0$ for the oldest and $i = \\ell - 1$ for the most recent pair, where $\\ell \\le m$. The two-loop recursion for computing $r = H_k q$ is:\n1. Set $q_0 \\leftarrow q$. For $i = \\ell - 1, \\ell - 2, \\dots, 0$, compute $\\rho_i = 1/(y_i^\\top s_i)$, $\\alpha_i = \\rho_i \\, s_i^\\top q_0$, and update $q_0 \\leftarrow q_0 - \\alpha_i y_i$.\n2. Choose the initial approximation $H_0 = \\gamma_k I$ with a positive scalar $\\gamma_k$. A standard and effective scaling is $\\gamma_k = \\dfrac{s_{\\ell-1}^\\top y_{\\ell-1}}{y_{\\ell-1}^\\top y_{\\ell-1}}$, using the most recent valid pair; if no pairs are available, set $\\gamma_k = 1$.\n3. Set $r \\leftarrow H_0 q_0 = \\gamma_k q_0$.\n4. For $i = 0, 1, \\dots, \\ell - 1$, compute $\\rho_i = 1/(y_i^\\top s_i)$, $\\beta_i = \\rho_i \\, y_i^\\top r$, and update $r \\leftarrow r + s_i (\\alpha_i - \\beta_i)$.\n\nThe curvature condition $s_i^\\top y_i > 0$ is critical to maintain positive definiteness. In finite precision, we enforce a screening rule to skip any pair whose curvature is not sufficiently positive. Specifically, for a small tolerance $\\varepsilon = 10^{-12}$, we accept a pair $(s_i, y_i)$ only if $s_i^\\top y_i > \\delta$ with $\\delta = \\varepsilon \\|s_i\\| \\, \\|y_i\\|$. Skipped pairs are simply omitted from the two-loop recursion.\n\nTo generate mechanics-consistent pairs for the test suite, we define the dimensionless potential energy\n$$\n\\phi(u) = \\sum_{i=1}^2 \\left( \\tfrac{1}{2} k_i (a_i^\\top u)^2 + \\tfrac{1}{4} c_i (a_i^\\top u)^4 \\right) - f^\\top u,\n$$\nwith $a_1 = [1,\\,0]^\\top$, $a_2 = [1,\\,1]^\\top$, $k = [k_1,\\,k_2]^\\top$, $c = [c_1,\\,c_2]^\\top$, and $f \\in \\mathbb{R}^2$. The corresponding gradient is\n$$\ng(u) = \\sum_{i=1}^2 \\left( k_i (a_i^\\top u) + c_i (a_i^\\top u)^3 \\right) a_i - f.\n$$\nFor Test $1$, with $k_1 = 10$, $k_2 = 5$, $c_1 = 1$, $c_2 = 0.5$, $f = [1,\\,0.2]^\\top$, and iterates $u_0 = [0,\\,0]^\\top$, $u_1 = [0.1,\\,-0.05]^\\top$, $u_2 = [0.18,\\,-0.06]^\\top$, we compute $g(u_j)$ for $j \\in \\{0,1,2\\}$ and form $s_0 = u_1 - u_0$, $s_1 = u_2 - u_1$, $y_0 = g(u_1) - g(u_0)$, and $y_1 = g(u_2) - g(u_1)$. After curvature screening, we keep the valid pairs in chronological order, set $\\gamma_k = \\dfrac{s_1^\\top y_1}{y_1^\\top y_1}$, let $q = g(u_2)$, and run the two-loop recursion to obtain $r^{(1)} = H_k q$. Test $2$ repeats the same procedure but with $q = [1,\\,-1]^\\top$. Test $3$ uses $m = 0$ and therefore $H_k = I$ so that $r^{(3)} = q$ directly. Test $4$ demonstrates the curvature screening by providing a pair with $s^\\top y \\le 0$, which is skipped so that $H_k = I$ and $r^{(4)} = q$. Test $5$ checks the descent property by computing $p = - H_k g(u_2)$ and verifying that $g(u_2)^\\top p < 0$, which must hold because the two-loop recursion yields a positive definite $H_k$ when all included pairs satisfy the curvature requirement.\n\nAlgorithmically, the implementation consists of the following steps:\n- Implement $g(u)$ from the given $\\phi(u)$.\n- Compute $u_0$, $u_1$, $u_2$, their gradients, and the pairs $(s_i, y_i)$ with screening.\n- Implement the L-BFGS two-loop recursion with initial scaling $\\gamma_k$ as specified.\n- Execute the four vector applications and the descent check, and print the results in the required single-line, bracketed list format.\n\nThis design is principle-based: it begins from the equilibrium condition and Newton method in computational solid mechanics, explains the quasi-Newton approximation and secant condition, details the positive definiteness and curvature condition, and finally implements the limited-memory two-loop recursion to realize $H_k q$ without explicit matrices. The tests cover a mechanics-consistent application, a general vector application, boundary behavior with no memory, robustness under curvature screening, and the fundamental descent property.",
            "answer": "```python\nimport numpy as np\n\ndef gradient_phi(u, k, c, a_list, f):\n    # g(u) = sum_i (k_i (a_i^T u) + c_i (a_i^T u)^3) a_i - f\n    g = np.zeros_like(u, dtype=float)\n    for i in range(len(a_list)):\n        a = a_list[i]\n        aiu = float(a @ u)\n        g += (k[i] * aiu + c[i] * (aiu ** 3)) * a\n    g -= f\n    return g\n\ndef curvature_ok(s, y, eps=1e-12):\n    # Accept if s^T y > eps * ||s|| * ||y||\n    sty = float(s @ y)\n    thresh = eps * np.linalg.norm(s) * np.linalg.norm(y)\n    return sty > thresh\n\ndef lbfgs_two_loop(s_list, y_list, q, gamma=None, eps=1e-12):\n    # Filter pairs by curvature condition\n    valid_pairs = []\n    for s, y in zip(s_list, y_list):\n        if curvature_ok(s, y, eps=eps):\n            valid_pairs.append((s.copy(), y.copy()))\n    # Determine gamma\n    if gamma is None:\n        if len(valid_pairs) > 0:\n            s_last, y_last = valid_pairs[-1]\n            sty = float(s_last @ y_last)\n            yty = float(y_last @ y_last)\n            gamma_k = sty / yty if yty > 0.0 else 1.0\n            if gamma_k <= 0.0 or not np.isfinite(gamma_k):\n                gamma_k = 1.0\n        else:\n            gamma_k = 1.0\n    else:\n        gamma_k = float(gamma)\n\n    # Two-loop recursion\n    q_vec = q.astype(float).copy()\n    alphas = []\n    rhos = []\n    # First loop: from newest to oldest\n    for s, y in reversed(valid_pairs):\n        sty = float(s @ y)\n        rho = 1.0 / sty\n        alpha = rho * float(s @ q_vec)\n        q_vec = q_vec - alpha * y\n        alphas.append(alpha)\n        rhos.append(rho)\n    # Apply initial H0\n    r = gamma_k * q_vec\n    # Second loop: from oldest to newest\n    # Need alphas, rhos in corresponding order\n    alphas = alphas[::-1]\n    rhos = rhos[::-1]\n    for (s, y), alpha, rho in zip(valid_pairs, alphas, rhos):\n        beta = rho * float(y @ r)\n        r = r + s * (alpha - beta)\n    return r\n\ndef solve():\n    results = []\n\n    # Common model data for mechanics-consistent tests\n    # a1 = [1, 0], a2 = [1, 1]\n    a_list = [np.array([1.0, 0.0]), np.array([1.0, 1.0])]\n    k = np.array([10.0, 5.0])\n    c = np.array([1.0, 0.5])\n    f = np.array([1.0, 0.2])\n\n    # Iterates\n    u0 = np.array([0.0, 0.0])\n    u1 = np.array([0.1, -0.05])\n    u2 = np.array([0.18, -0.06])\n\n    # Gradients\n    g0 = gradient_phi(u0, k, c, a_list, f)\n    g1 = gradient_phi(u1, k, c, a_list, f)\n    g2 = gradient_phi(u2, k, c, a_list, f)\n\n    # Secant pairs\n    s0 = u1 - u0\n    s1 = u2 - u1\n    y0 = g1 - g0\n    y1 = g2 - g1\n\n    # Store pairs in chronological order\n    s_list = [s0, s1]\n    y_list = [y0, y1]\n\n    # Test 1: Apply H_k to q = g(u2) with gamma from last valid pair\n    q1 = g2.copy()\n    r1 = lbfgs_two_loop(s_list, y_list, q1, gamma=None, eps=1e-12)\n    results.append([float(r1[0]), float(r1[1])])\n\n    # Test 2: Apply H_k to q = [1, -1] with same pairs and gamma rule\n    q2 = np.array([1.0, -1.0])\n    r2 = lbfgs_two_loop(s_list, y_list, q2, gamma=None, eps=1e-12)\n    results.append([float(r2[0]), float(r2[1])])\n\n    # Test 3: Empty memory, gamma = 1, q = [0.3, -0.4]\n    q3 = np.array([0.3, -0.4])\n    r3 = lbfgs_two_loop([], [], q3, gamma=1.0, eps=1e-12)\n    results.append([float(r3[0]), float(r3[1])])\n\n    # Test 4: Curvature screening edge case, pair should be skipped\n    s_bad = np.array([1e-8, 0.0])\n    y_bad = np.array([-1e-8, 0.0])\n    q4 = np.array([0.2, 0.5])\n    r4 = lbfgs_two_loop([s_bad], [y_bad], q4, gamma=None, eps=1e-12)\n    results.append([float(r4[0]), float(r4[1])])\n\n    # Test 5: Descent property check with q = g(u2)\n    q5 = g2.copy()\n    Hq = lbfgs_two_loop(s_list, y_list, q5, gamma=None, eps=1e-12)\n    p = -Hq\n    descent = float(q5 @ p) < 0.0\n    results.append(bool(descent))\n\n    # Print in the exact required single-line format\n    # Nested lists will be printed by constructing the string manually\n    def to_str(x):\n        if isinstance(x, list):\n            return \"[\" + \",\".join(to_str(v) for v in x) + \"]\"\n        elif isinstance(x, bool):\n            return \"True\" if x else \"False\"\n        else:\n            return str(x)\n\n    print(\"[\" + \",\".join(to_str(r) for r in results) + \"]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}