{
    "hands_on_practices": [
        {
            "introduction": "本练习旨在通过一个具体的一维有限元问题，将抽象的牛顿-拉弗森法付诸实践。通过亲手推导切线刚度并计算一次迭代更新 ，您将巩固对该算法在固体力学中最基本层面如何运作的理解。这个练习将帮助您弥合数学公式与其物理意义之间的鸿沟，为更复杂的非线性分析打下坚实的基础。",
            "id": "3582791",
            "problem": "一根长度为 $L$、横截面积恒为 $A$ 的直棱柱一维杆，使用一个具有节点位移 $u_{1}$ 和 $u_{2}$ 的双节点线性有限元进行建模。该杆在节点1处被固定，因此 $u_{1}=0$，并在节点2处承受集中轴向载荷 $f$。假设小应变运动学，轴向应变为 $\\varepsilon = du/dx$，位移场由线性形函数 $N_{1}(x)=1-x/L$ 和 $N_{2}(x)=x/L$ 插值得到，因此 $u(x)=N_{1}(x)\\,u_{1}+N_{2}(x)\\,u_{2}$ 且 $\\varepsilon(x)=B\\,u_{e}$，其中 $B=\\left[-1/L,\\;1/L\\right]$ 且 $u_{e}=\\begin{pmatrix}u_{1}\\\\u_{2}\\end{pmatrix}$。材料是超弹性的，其一维本构关系为 $\\sigma(\\varepsilon)=E\\,\\varepsilon+\\alpha\\,\\varepsilon^{3}$，其中 $E$ 和 $\\alpha$ 是正常数。\n\n从节点2自由度的有限元残差表达式 $R(u)=\\int_{0}^{L}B^{\\top}\\,\\sigma(Bu)\\,A\\,dx - f$ 出发，推导一致标量切向刚度 $K(u)=dR/du$，用 $E$、$\\alpha$、$L$、$A$ 和当前标量位移 $u:=u_{2}$ 表示。然后，对于具体数据 $L=1.0$ m, $A=2.0\\times 10^{-4}$ m$^{2}$, $E=2.0\\times 10^{9}$ Pa, $\\alpha=1.0\\times 10^{10}$ Pa, 外加载荷 $f=1.0\\times 10^{5}$ N, 以及当前牛顿迭代值 $u_{k}=0.20$ m, 计算 $K(u_{k})$ 的数值和牛顿更新量 $\\Delta u=-R(u_{k})/K(u_{k})$。将最终更新量 $\\Delta u$ 以毫米为单位表示，并四舍五入到四位有效数字。",
            "solution": "该问题被验证为具有科学依据、适定且客观，尽管在残差的定义上存在轻微的模糊性，但这可以从第一性原理解决。在一个会产生大应变值（$20\\%$）的背景下使用小应变运动学模型，这被解释为针对学术问题的有意简化，而非根本性缺陷。\n\n该问题要求推导一致切向刚度，并为一个一维、材料非线性的有限元模型计算牛顿–拉夫逊更新量。\n\n首先，我们为自由度（即节点2的位移，记为 $u := u_2$）建立标量残差方程 $R(u)$。边界条件为 $u_1=0$。残差是节点2处的内力 $F_{int,2}$ 与外部施加的力 $f$ 之差。\n$$R(u) = F_{int,2}(u) - f$$\n内力由应力在单元域上的积分导出，并由相应形函数的导数加权。对于节点2，这表示为：\n$$F_{int,2}(u) = \\int_{0}^{L} N_{2,x}(x) \\, \\sigma(\\varepsilon(u)) \\, A \\, dx$$\n位移场为 $u(x) = N_1(x)u_1 + N_2(x)u_2 = (1-x/L)u_1 + (x/L)u_2$。给定 $u_1=0$ 和 $u_2=u$，这变为 $u(x) = (x/L)u$。\n轴向应变 $\\varepsilon$ 定义为 $\\varepsilon = du/dx$。\n$$\\varepsilon = \\frac{d}{dx}\\left(\\frac{x}{L}u\\right) = \\frac{u}{L}$$\n或者，使用给定的应变-位移矩阵 $B = [-1/L, 1/L]$ 和节点位移向量 $u_e = \\begin{pmatrix} u_1 \\\\ u_2 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ u \\end{pmatrix}$：\n$$\\varepsilon = B u_e = \\begin{pmatrix} -1/L  1/L \\end{pmatrix} \\begin{pmatrix} 0 \\\\ u \\end{pmatrix} = \\frac{u}{L}$$\n由于应变 $\\varepsilon$ 在整个单元中是恒定的，因此应力 $\\sigma$ 也是恒定的。本构关系为 $\\sigma(\\varepsilon) = E\\varepsilon + \\alpha\\varepsilon^3$。代入 $\\varepsilon = u/L$：\n$$\\sigma(u) = E\\left(\\frac{u}{L}\\right) + \\alpha\\left(\\frac{u}{L}\\right)^3$$\n第二个形函数的导数为 $N_{2,x}(x) = d/dx(x/L) = 1/L$。\n现在我们可以计算内力积分：\n$$F_{int,2}(u) = \\int_{0}^{L} \\frac{1}{L} \\left[ E\\left(\\frac{u}{L}\\right) + \\alpha\\left(\\frac{u}{L}\\right)^3 \\right] A \\, dx$$\n由于被积函数中的所有项相对于 $x$ 都是常数：\n$$F_{int,2}(u) = \\frac{A}{L} \\left[ E\\frac{u}{L} + \\alpha\\frac{u^3}{L^3} \\right] \\int_{0}^{L} dx = \\frac{A}{L} \\left[ E\\frac{u}{L} + \\alpha\\frac{u^3}{L^3} \\right] L$$\n$$F_{int,2}(u) = A \\left[ \\frac{E}{L}u + \\frac{\\alpha}{L^3}u^3 \\right]$$\n因此，标量残差方程为：\n$$R(u) = \\frac{AE}{L}u + \\frac{A\\alpha}{L^3}u^3 - f$$\n接下来，我们通过对残差 $R(u)$ 关于位移 $u$ 求导，来推导一致标量切向刚度 $K(u)$。\n$$K(u) = \\frac{dR}{du} = \\frac{d}{du}\\left( \\frac{AE}{L}u + \\frac{A\\alpha}{L^3}u^3 - f \\right)$$\n$$K(u) = \\frac{AE}{L} + 3\\frac{A\\alpha}{L^3}u^2$$\n这就是切向刚度的符号表达式。\n\n现在我们代入给定的数值来计算 $K(u_k)$ 和牛顿更新量 $\\Delta u$。\n给定数据如下：\n$L = 1.0$ m\n$A = 2.0 \\times 10^{-4}$ m$^2$\n$E = 2.0 \\times 10^9$ Pa\n$\\alpha = 1.0 \\times 10^{10}$ Pa\n$f = 1.0 \\times 10^5$ N\n当前位移迭代值: $u_k = 0.20$ m\n\n首先，我们计算在 $u_k = 0.20$ m 处的切向刚度 $K(u_k)$。\n$$K(u_k) = \\frac{(2.0 \\times 10^{-4})(2.0 \\times 10^9)}{1.0} + \\frac{3(2.0 \\times 10^{-4})(1.0 \\times 10^{10})}{(1.0)^3}(0.20)^2$$\n第一项是线性刚度：\n$$K_{linear} = (2.0 \\times 10^{-4})(2.0 \\times 10^9) = 4.0 \\times 10^5 \\, \\text{N/m}$$\n第二项是非线性贡献：\n$$K_{nonlinear} = 3(2.0 \\times 10^{-4})(1.0 \\times 10^{10})(0.04) = (6.0 \\times 10^{-4})(1.0 \\times 10^{10})(0.04) = (6.0 \\times 10^6)(0.04) = 2.4 \\times 10^5 \\, \\text{N/m}$$\n总切向刚度为：\n$$K(u_k) = 4.0 \\times 10^5 + 2.4 \\times 10^5 = 6.4 \\times 10^5 \\, \\text{N/m}$$\n接下来，我们计算在 $u_k = 0.20$ m 处的残差 $R(u_k)$。\n$$R(u_k) = \\frac{(2.0 \\times 10^{-4})(2.0 \\times 10^9)}{1.0}(0.20) + \\frac{(2.0 \\times 10^{-4})(1.0 \\times 10^{10})}{(1.0)^3}(0.20)^3 - 1.0 \\times 10^5$$\n$$R(u_k) = (4.0 \\times 10^5)(0.20) + (2.0 \\times 10^6)(0.008) - 1.0 \\times 10^5$$\n$$R(u_k) = 8.0 \\times 10^4 + 1.6 \\times 10^4 - 1.0 \\times 10^5$$\n$$R(u_k) = 9.6 \\times 10^4 - 1.0 \\times 10^5 = -0.04 \\times 10^5 = -4000 \\, \\text{N}$$\n牛顿更新量 $\\Delta u$ 由公式 $\\Delta u = -R(u_k) / K(u_k)$ 给出。\n$$\\Delta u = - \\frac{-4000 \\, \\text{N}}{6.4 \\times 10^5 \\, \\text{N/m}} = \\frac{4000}{640000} \\, \\text{m} = \\frac{4}{640} \\, \\text{m} = \\frac{1}{160} \\, \\text{m}$$\n$$\\Delta u = 0.00625 \\, \\text{m}$$\n题目要求答案以毫米（mm）为单位，并四舍五入到四位有效数字。\n$$\\Delta u = 0.00625 \\, \\text{m} \\times \\frac{1000 \\, \\text{mm}}{1 \\, \\text{m}} = 6.25 \\, \\text{mm}$$\n四舍五入到四位有效数字得到 $6.250$ mm。",
            "answer": "$$\\boxed{6.250}$$"
        },
        {
            "introduction": "在掌握了单次牛顿迭代的计算之后，一个自然而然的问题是：我们为什么需要替代方法？本练习将引导您从计算效率的角度进行一次实际的探究 。通过量化分析，您将比较全牛顿法和修正牛顿法的成本与收益，后者避免了在每次迭代中都更新昂贵的切线刚度矩阵。这个练习突显了迭代次数与单次迭代成本之间的权衡，这是在真实世界模拟中需要核心考量的因素。",
            "id": "3582866",
            "problem": "一个通过有限元法 (FEM) 离散化的三维弹塑性块体，在一个包含 $8$ 个相等增量的单调位移控制加载路径下驱动。每个增量步的非线性平衡问题通过 Newton–Raphson (NR) 法求解，该方法旨在寻找 $\\mathbf{u}$ 以满足残差 $\\mathbf{R}(\\mathbf{u}) = \\mathbf{0}$，其中 $\\mathbf{R}(\\mathbf{u}) = \\mathbf{f}^{\\text{ext}} - \\mathbf{f}^{\\text{int}}(\\mathbf{u})$。在完全 Newton 法中，一致切线刚度 $\\mathbf{K}_{T}(\\mathbf{u}^{(k)})$ 在每次迭代 $k$ 中都会被组装和分解。在修正 Newton 法中，切线刚度 $\\mathbf{K}_{T}$ 在每个加载增量的开始时仅组装和分解一次，并在该增量内的所有后续迭代中重复使用。\n\n自由度 (DOF) 在整个分析过程中保持不变。假设每次迭代进行一次线性系统回代求解，并且没有线搜索、没有约束求解、也没有接触迭代。对于本问题所采用的稀疏求解器和单元例程，测得的计算成本如下：\n- 每次组装的切线组装时间 $t_{a} = 0.90$ 秒。\n- 每次分解的稀疏分解时间 $t_{f} = 2.80$ 秒。\n- 每次迭代的单右端项回代求解时间 $t_{s} = 0.14$ 秒。\n\n对于完全 Newton 法（记为 $N_{i}$）和修正 Newton 法（记为 $M_{i}$），每个加载增量的记录迭代次数如下：\n- 加载增量 $1$：$N_{1} = 4$, $M_{1} = 5$。\n- 加载增量 $2$：$N_{2} = 3$, $M_{2} = 4$。\n- 加载增量 $3$：$N_{3} = 3$, $M_{3} = 5$。\n- 加载增量 $4$：$N_{4} = 5$, $M_{4} = 7$。\n- 加载增量 $5$：$N_{5} = 6$, $M_{5} = 8$。\n- 加载增量 $6$：$N_{6} = 7$, $M_{6} = 9$。\n- 加载增量 $7$：$N_{7} = 7$, $M_{7} = 10$。\n- 加载增量 $8$：$N_{8} = 8$, $M_{8} = 11$。\n\n任务：\n1. 计算修正 Newton 法相对于完全 Newton 法在整个加载路径上实现的总分解重用次数。\n2. 计算修正 Newton 法相对于完全 Newton 法所需的额外迭代总次数。\n3. 使用给定的计算成本模型，估算修正 Newton 法相比于完全 Newton 法在整个加载路径上的净运行时间节省。\n\n将最终答案以净运行时间节省量（单位：秒）的形式表示。将答案四舍五入到四位有效数字。任何中间结果和最终报告的量都应使用秒作为单位。",
            "solution": "首先根据指定标准对问题陈述进行验证。\n\n**步骤 1：提取已知条件**\n- 分析类型：通过 FEM 离散化的三维弹塑性块体。\n- 加载：单调，位移控制，包含 $n_{\\text{inc}} = 8$ 个相等增量。\n- 非线性求解器：用于求解 $\\mathbf{R}(\\mathbf{u}) = \\mathbf{0}$ 的 Newton-Raphson (NR) 法。\n- 完全 Newton (FN) 法：在每次迭代中组装和分解切线刚度 $\\mathbf{K}_{T}$。\n- 修正 Newton (MN) 法：在每个加载增量的开始时仅组装和分解一次 $\\mathbf{K}_{T}$。\n- 计算成本：\n  - 切线组装时间：$t_{a} = 0.90$ 秒。\n  - 稀疏分解时间：$t_{f} = 2.80$ 秒。\n  - 回代求解时间：$t_{s} = 0.14$ 秒。\n- 假设：每次迭代一次回代求解，无线性搜索，无约束求解，无接触迭代。\n- 每个增量 $i$ 的 FN ($N_{i}$) 和 MN ($M_{i}$) 迭代次数：\n  - $N_1 = 4$, $M_1 = 5$。\n  - $N_2 = 3$, $M_2 = 4$。\n  - $N_3 = 3$, $M_3 = 5$。\n  - $N_4 = 5$, $M_4 = 7$。\n  - $N_5 = 6$, $M_5 = 8$。\n  - $N_6 = 7$, $M_6 = 9$。\n  - $N_7 = 7$, $M_7 = 10$。\n  - $N_8 = 8$, $M_8 = 11$。\n- 要求输出：MN 相对于 FN 的净运行时间节省，四舍五入到四位有效数字。\n\n**步骤 2：使用提取的已知条件进行验证**\n- **科学依据充分：** 该问题牢固地植根于计算固体力学领域，具体涉及由有限元法产生的非线性系统的数值解。完全 Newton 法和修正 Newton 法、切线刚度组装、分解、回代及其相关计算成本等概念都是标准且成熟的。\n- **适定性：** 所有必要数据（原子操作的计算时间、增量数以及两种方法的迭代次数）均已提供。任务具体且可计算，从而可以得到唯一的数值解。所作的假设简化了成本模型但并未使其失效，而是构成了一个清晰、自洽的问题。\n- **客观性：** 问题采用精确、客观的技术语言和数值数据进行描述，没有歧义和主观论断。\n- **结论：** 该问题具有科学合理性、适定性、完整性和客观性，不违反任何无效标准。\n\n**步骤 3：结论与行动**\n该问题有效。将提供完整解答。\n\n**求解推导**\n\n主要目标是计算使用修正 Newton (MN) 法替代完全 Newton (FN) 法所实现的净运行时间节省量 $\\Delta T$。该节省量是两种方法总计算时间的差值：\n$$ \\Delta T = T_{\\text{FN}} - T_{\\text{MN}} $$\n\n令 $n_{\\text{inc}} = 8$ 为加载增量的数量。我们通过对所有增量的成本求和来为每种方法建立总计算时间模型。\n\n**完全 Newton (FN) 法的成本模型**\n在完全 Newton–Raphson 法中，切线刚度矩阵在每次迭代中都会被组装和分解。因此，单次迭代的成本是组装时间 $t_a$、分解时间 $t_f$ 和回代求解时间 $t_s$ 的总和。对于需要 $N_i$ 次迭代的加载增量 $i$，其计算成本为：\n$$ T_{\\text{FN},i} = N_i (t_a + t_f + t_s) $$\n所有 $n_{\\text{inc}}$ 个增量的总成本是每个增量成本的总和：\n$$ T_{\\text{FN}} = \\sum_{i=1}^{n_{\\text{inc}}} T_{\\text{FN},i} = \\sum_{i=1}^{8} N_i (t_a + t_f + t_s) = \\left(\\sum_{i=1}^{8} N_i\\right) (t_a + t_f + t_s) $$\n\n**修正 Newton (MN) 法的成本模型**\n在修正 Newton 法中，切线刚度矩阵在每个加载增量开始时仅组装和分解一次。这个成本 $(t_a + t_f)$ 在每个增量中只产生一次。增量 $i$ 内的每一次迭代（共 $M_i$ 次）都需要一次回代求解。因此，增量 $i$ 的计算成本是：\n$$ T_{\\text{MN},i} = (t_a + t_f) + M_i t_s $$\n所有 $n_{\\text{inc}}$ 个增量的总成本是：\n$$ T_{\\text{MN}} = \\sum_{i=1}^{n_{\\text{inc}}} T_{\\text{MN},i} = \\sum_{i=1}^{8} ((t_a + t_f) + M_i t_s) = n_{\\text{inc}}(t_a + t_f) + \\left(\\sum_{i=1}^{8} M_i\\right) t_s $$\n\n**计算**\n\n首先，我们计算每种方法的总迭代次数。\nFN 的总迭代次数 $N_{\\text{total}}$：\n$$ N_{\\text{total}} = \\sum_{i=1}^{8} N_i = 4 + 3 + 3 + 5 + 6 + 7 + 7 + 8 = 43 $$\nMN 的总迭代次数 $M_{\\text{total}}$：\n$$ M_{\\text{total}} = \\sum_{i=1}^{8} M_i = 5 + 4 + 5 + 7 + 8 + 9 + 10 + 11 = 59 $$\n\n现在，为了完整性，我们解决中间任务。\n1.  **总分解重用次数：** 在 MN 法中，每个增量执行一次分解。对于一个有 $M_i$ 次迭代的增量，分解被重用了 $M_i - 1$ 次。总重用次数为 $\\sum_{i=1}^{8} (M_i - 1) = M_{\\text{total}} - 8 = 59 - 8 = 51$。\n2.  **总额外迭代次数：** MN 相对于 FN 所需的额外迭代次数为 $M_{\\text{total}} - N_{\\text{total}} = 59 - 43 = 16$。\n\n接下来，我们使用给定的成本数据计算总运行时间：$t_a = 0.90 \\, \\text{s}$，$t_f = 2.80 \\, \\text{s}$，$t_s = 0.14 \\, \\text{s}$。\n\n计算 $T_{\\text{FN}}$：\n$$ T_{\\text{FN}} = N_{\\text{total}} (t_a + t_f + t_s) = 43 \\times (0.90 + 2.80 + 0.14) \\, \\text{s} $$\n$$ T_{\\text{FN}} = 43 \\times 3.84 \\, \\text{s} = 165.12 \\, \\text{s} $$\n\n计算 $T_{\\text{MN}}$：\n$$ T_{\\text{MN}} = n_{\\text{inc}}(t_a + t_f) + M_{\\text{total}} t_s = 8 \\times (0.90 + 2.80) \\, \\text{s} + 59 \\times 0.14 \\, \\text{s} $$\n$$ T_{\\text{MN}} = 8 \\times 3.70 \\, \\text{s} + 8.26 \\, \\text{s} $$\n$$ T_{\\text{MN}} = 29.60 \\, \\text{s} + 8.26 \\, \\text{s} = 37.86 \\, \\text{s} $$\n\n最后，我们计算净运行时间节省量 $\\Delta T$。\n$$ \\Delta T = T_{\\text{FN}} - T_{\\text{MN}} = 165.12 \\, \\text{s} - 37.86 \\, \\text{s} = 127.26 \\, \\text{s} $$\n\n问题要求将答案四舍五入到四位有效数字。将数值 $127.26$ 四舍五入到四位有效数字得到 $127.3$。",
            "answer": "$$\\boxed{127.3}$$"
        },
        {
            "introduction": "从修正牛顿法迈向更复杂的拟牛顿法，本练习将挑战您亲自实现L-BFGS算法 。L-BFGS是一种功能强大的技术，它通过近似而非显式构造海森矩阵，尤其适用于大规模问题。通过编写其核心的双循环递归代码，您将对这个内存高效的优化利器如何运作获得深刻的实践性理解。",
            "id": "3582815",
            "problem": "实现一种有限内存Broyden–Fletcher–Goldfarb–Shanno (L-BFGS) 双循环递归算法，该算法将逆Hessian近似 $H_k$ 应用于一个向量，而无需显式地构建 $H_k$。应用场景是为一个小型非线性弹簧网络最小化其有限元势能 $\\phi(u)$。从计算固体力学的一个基本点出发：离散系统的平衡是通过最小化势能泛函 $\\phi(u)$ 获得的，其一阶最优性条件表示为残差 $g(u) = \\nabla \\phi(u) = 0$，而牛顿法源自 $\\phi(u)$ 的泰勒展开，其中Hessian矩阵 $K(u) = \\nabla^2 \\phi(u)$ 作为切线刚度。为降低构建和分解 $K(u)$ 的成本，拟牛顿策略构建一个近似 $B_k \\approx K(u_k)$，其中 $H_k = B_k^{-1}$，并强制满足割线条件 $B_{k+1}s_k = y_k$，这里 $s_k = u_{k+1} - u_k$ 且 $y_k = g_{k+1} - g_k$。在曲率条件 $s_k^\\top y_k  0$ 下，Broyden–Fletcher–Goldfarb–Shanno更新是一种经过充分检验的正定更新，其有限内存变体仅存储最近的 $m$ 对 $(s_i, y_i)$，并通过双循环递归将 $H_k$ 应用于一个向量。\n\n定义一个双自由度离散弹簧网络的无量纲势能为\n$$\n\\phi(u) = \\sum_{i=1}^2 \\left( \\tfrac{1}{2} k_i (a_i^\\top u)^2 + \\tfrac{1}{4} c_i (a_i^\\top u)^4 \\right) - f^\\top u,\n$$\n其中 $u \\in \\mathbb{R}^2$, $a_1 = [1,\\,0]^\\top$, $a_2 = [1,\\,1]^\\top$, $k = [k_1,\\,k_2]^\\top$, $c = [c_1,\\,c_2]^\\top$, 且 $f \\in \\mathbb{R}^2$。其梯度为\n$$\ng(u) = \\nabla \\phi(u) = \\sum_{i=1}^2 \\left( k_i (a_i^\\top u) + c_i (a_i^\\top u)^3 \\right) a_i - f.\n$$\n仅使用此模型为测试套件生成一致的 $(s_i, y_i)$ 对。您的程序必须实现：\n\n- 一个函数，给定最多 $m$ 个存储的向量对 $\\{(s_i, y_i)\\}$、一个向量 $q$ 和一个定义了 $H_0 = \\gamma_k I$ 的初始标量 $ \\gamma_k  0$，该函数使用标准的双循环递归计算 $r = H_k q$，而不显式构建 $H_k$。\n- 曲率筛选：跳过任何满足 $s_i^\\top y_i \\le \\delta$ 的向量对，其中 $\\delta = \\varepsilon \\|s_i\\| \\, \\|y_i\\|$ 且 $\\varepsilon = 10^{-12}$。\n- 初始缩放 $ \\gamma_k$ 设置为 $ \\gamma_k = \\dfrac{s_{k-1}^\\top y_{k-1}}{y_{k-1}^\\top y_{k-1}}$（如果至少有一个有效的已存储向量对），否则 $ \\gamma_k = 1$。\n\n构建以下测试套件。所有量均为无量纲；无需物理单位。\n\n- 测试 $1$（力学一致的向量对并将 $H_k$ 应用于当前梯度）：设 $k_1 = 10$, $k_2 = 5$, $c_1 = 1$, $c_2 = 0.5$, $f = [1,\\,0.2]^\\top$, $u_0 = [0,\\,0]^\\top$, $u_1 = [0.1,\\,-0.05]^\\top$, $u_2 = [0.18,\\,-0.06]^\\top$。计算 $j \\in \\{0,1,2\\}$ 时的 $g(u_j)$，以及 $s_0 = u_1 - u_0$, $s_1 = u_2 - u_1$, $y_0 = g(u_1) - g(u_0)$, $y_1 = g(u_2) - g(u_1)$。在应用曲率筛选后，按时间顺序存储最近的 $m = 2$ 对 $(s_0,y_0)$, $(s_1,y_1)$。设 $q = g(u_2)$。使用双循环递归和如上定义的 $ \\gamma_k$ 计算 $r^{(1)} = H_k q$。返回 $r^{(1)}$ 的两个分量，形式为一个包含两个浮点数的列表。\n- 测试 $2$（通用向量应用）：使用与测试 $1$ 中相同的已存储向量对和相同的 $ \\gamma_k$，设 $q = [1,\\,-1]^\\top$ 并计算 $r^{(2)} = H_k q$。返回 $r^{(2)}$ 的两个分量，形式为一个包含两个浮点数的列表。\n- 测试 $3$（空内存边界情况）：使用 $m = 0$（无存储的向量对）、$ \\gamma_k = 1$ 和 $q = [0.3,\\,-0.4]^\\top$。计算 $r^{(3)} = H_k q$。返回 $r^{(3)}$ 的两个分量，形式为一个包含两个浮点数的列表。\n- 测试 $4$（曲率筛选边缘情况）：使用一对向量 $s = [10^{-8},\\,0]^\\top$，$y = [-10^{-8},\\,0]^\\top$，$m = 1$，$q = [0.2,\\,0.5]^\\top$。由于 $s^\\top y \\le 0$，此对应被筛选规则跳过；在没有有效向量对的情况下，使用 $ \\gamma_k = 1$。计算 $r^{(4)} = H_k q$。返回 $r^{(4)}$ 的两个分量，形式为一个包含两个浮点数的列表。\n- 测试 $5$（下降属性检查）：使用测试 $1$ 中的有效向量对和 $ \\gamma_k$，设 $q = g(u_2)$，计算 $p = - H_k q$，并返回语句 $q^\\top p  0$ 的布尔值。\n\n您的程序应生成单行输出，其中包含一个以方括号括起来的逗号分隔列表形式的结果，顺序为 $[r^{(1)}, r^{(2)}, r^{(3)}, r^{(4)}, \\text{descent}]$，其中每个 $r^{(i)}$ (对于 $i \\in \\{1,2,3,4\\}$) 本身是一个包含两个浮点数的列表，而 $\\text{descent}$ 是一个布尔值。例如，一个有效的输出形状是 $[[x_1, x_2],[y_1, y_2],[z_1, z_2],[w_1, w_2],\\text{True}]$，其中实际计算出的数字替换了 $x_1$, $x_2$, $y_1$, $y_2$, $z_1$, $z_2$, $w_1$ 和 $w_2$。",
            "solution": "其基本原理是，离散固体力学系统的平衡源于最小化势能 $\\phi(u)$，使得一阶条件 $g(u) = \\nabla \\phi(u) = 0$ 成立。求解 $g(u) = 0$ 的牛顿迭代来自泰勒展开 $g(u + \\Delta u) \\approx g(u) + K(u) \\Delta u$，其中 $K(u) = \\nabla^2 \\phi(u)$，因此有 $K(u) \\Delta u = -g(u)$。在非线性有限元中，显式组装和分解 $K(u)$ 在计算上可能非常昂贵。拟牛顿法构建一个近似 $B_k \\approx K(u_k)$，使得割线条件 $B_{k+1} s_k = y_k$ 成立，其中 $s_k = u_{k+1} - u_k$，$y_k = g_{k+1} - g_k$。Broyden–Fletcher–Goldfarb–Shanno更新由以下公式定义，在曲率条件 $s_k^\\top y_k  0$ 下是一种经过充分检验的正定更新：\n$$\nB_{k+1} = B_k - \\frac{B_k s_k s_k^\\top B_k}{s_k^\\top B_k s_k} + \\frac{y_k y_k^\\top}{s_k^\\top y_k},\n$$\n其逆 $H_{k+1} = B_{k+1}^{-1}$ 可以通过以下方式更新：\n$$\nH_{k+1} = \\left(I - \\rho_k s_k y_k^\\top\\right) H_k \\left(I - \\rho_k y_k s_k^\\top\\right) + \\rho_k s_k s_k^\\top, \\quad \\rho_k = \\frac{1}{y_k^\\top s_k},\n$$\n并且如果 $H_k$ 是正定的且 $s_k^\\top y_k  0$，则 $H_{k+1}$ 保持正定。正定性意味着对于任何非零向量 $q$，都有 $q^\\top H_k q  0$，因此方向 $p_k = - H_k g_k$ 是一个严格下降方向，因为 $g_k^\\top p_k = - g_k^\\top H_k g_k  0$。\n\n有限内存版本避免了显式存储 $H_k$ 或 $B_k$。相反，它存储最近的 $m$ 对 $\\{(s_i, y_i)\\}$ 并通过双循环递归将 $H_k$ 应用于向量 $q$。按时间顺序标记这些向量对，其中 $i = 0$ 表示最旧的，$i = \\ell - 1$ 表示最新的，这里 $\\ell \\le m$。计算 $r = H_k q$ 的双循环递归如下：\n1. 设置 $q_0 \\leftarrow q$。对于 $i = \\ell - 1, \\ell - 2, \\dots, 0$，计算 $\\rho_i = 1/(y_i^\\top s_i)$，$\\alpha_i = \\rho_i \\, s_i^\\top q_0$，并更新 $q_0 \\leftarrow q_0 - \\alpha_i y_i$。\n2. 选择初始近似 $H_0 = \\gamma_k I$，其中 $\\gamma_k$ 是一个正标量。一种标准且有效的缩放是 $\\gamma_k = \\dfrac{s_{\\ell-1}^\\top y_{\\ell-1}}{y_{\\ell-1}^\\top y_{\\ell-1}}$，使用最新的有效向量对；如果没有可用的向量对，则设置 $\\gamma_k = 1$。\n3. 设置 $r \\leftarrow H_0 q_0 = \\gamma_k q_0$。\n4. 对于 $i = 0, 1, \\dots, \\ell - 1$，计算 $\\rho_i = 1/(y_i^\\top s_i)$，$\\beta_i = \\rho_i \\, y_i^\\top r$，并更新 $r \\leftarrow r + s_i (\\alpha_i - \\beta_i)$。\n\n曲率条件 $s_i^\\top y_i  0$ 对维持正定性至关重要。在有限精度计算中，我们强制执行一个筛选规则，以跳过任何曲率不够正的向量对。具体来说，对于一个小的容差 $\\varepsilon = 10^{-12}$，我们只接受满足 $s_i^\\top y_i  \\delta$ 且 $\\delta = \\varepsilon \\|s_i\\| \\, \\|y_i\\|$ 的向量对 $(s_i, y_i)$。被跳过的向量对在双循环递归中被简单地省略。\n\n为了为测试套件生成力学上一致的向量对，我们定义无量纲势能\n$$\n\\phi(u) = \\sum_{i=1}^2 \\left( \\tfrac{1}{2} k_i (a_i^\\top u)^2 + \\tfrac{1}{4} c_i (a_i^\\top u)^4 \\right) - f^\\top u,\n$$\n其中 $a_1 = [1,\\,0]^\\top$, $a_2 = [1,\\,1]^\\top$, $k = [k_1,\\,k_2]^\\top$, $c = [c_1,\\,c_2]^\\top$ 且 $f \\in \\mathbb{R}^2$。对应的梯度为\n$$\ng(u) = \\sum_{i=1}^2 \\left( k_i (a_i^\\top u) + c_i (a_i^\\top u)^3 \\right) a_i - f.\n$$\n对于测试 $1$，给定 $k_1 = 10$, $k_2 = 5$, $c_1 = 1$, $c_2 = 0.5$, $f = [1,\\,0.2]^\\top$ 以及迭代点 $u_0 = [0,\\,0]^\\top$, $u_1 = [0.1,\\,-0.05]^\\top$, $u_2 = [0.18,\\,-0.06]^\\top$，我们计算 $j \\in \\{0,1,2\\}$ 时的 $g(u_j)$，并构成 $s_0 = u_1 - u_0$, $s_1 = u_2 - u_1$, $y_0 = g(u_1) - g(u_0)$ 和 $y_1 = g(u_2) - g(u_1)$。经过曲率筛选后，我们按时间顺序保留有效的向量对，设置 $\\gamma_k = \\dfrac{s_1^\\top y_1}{y_1^\\top y_1}$，令 $q = g(u_2)$，然后运行双循环递归得到 $r^{(1)} = H_k q$。测试 $2$ 重复相同的过程，但使用 $q = [1,\\,-1]^\\top$。测试 $3$ 使用 $m = 0$，因此 $H_k = I$，从而直接得到 $r^{(3)} = q$。测试 $4$ 通过提供一个 $s^\\top y \\le 0$ 的向量对来演示曲率筛选，该向量对被跳过，因此 $H_k = I$ 且 $r^{(4)} = q$。测试 $5$ 通过计算 $p = - H_k g(u_2)$ 并验证 $g(u_2)^\\top p  0$ 来检查下降属性，由于当所有包含的向量对都满足曲率要求时，双循环递归会产生一个正定的 $H_k$，因此该条件必须成立。\n\n算法上，实现包括以下步骤：\n- 根据给定的 $\\phi(u)$ 实现 $g(u)$。\n- 计算 $u_0$, $u_1$, $u_2$、它们的梯度以及经过筛选的向量对 $(s_i, y_i)$。\n- 实现具有指定初始缩放 $\\gamma_k$ 的L-BFGS双循环递归。\n- 执行四个向量应用和一个下降检查，并按要求的单行、括号列表格式打印结果。\n\n此设计是基于原理的：它从计算固体力学中的平衡条件和牛顿法出发，解释了拟牛顿近似和割线条件，详细说明了正定性和曲率条件，并最终实现了有限内存双循环递归来计算 $H_k q$ 而无需显式矩阵。这些测试涵盖了力学一致的应用、通用向量应用、无内存时的边界行为、曲率筛选下的鲁棒性以及基本的下降属性。",
            "answer": "```python\nimport numpy as np\n\ndef gradient_phi(u, k, c, a_list, f):\n    # g(u) = sum_i (k_i (a_i^T u) + c_i (a_i^T u)^3) a_i - f\n    g = np.zeros_like(u, dtype=float)\n    for i in range(len(a_list)):\n        a = a_list[i]\n        aiu = float(a @ u)\n        g += (k[i] * aiu + c[i] * (aiu ** 3)) * a\n    g -= f\n    return g\n\ndef curvature_ok(s, y, eps=1e-12):\n    # Accept if s^T y > eps * ||s|| * ||y||\n    sty = float(s @ y)\n    thresh = eps * np.linalg.norm(s) * np.linalg.norm(y)\n    return sty > thresh\n\ndef lbfgs_two_loop(s_list, y_list, q, gamma=None, eps=1e-12):\n    # Filter pairs by curvature condition\n    valid_pairs = []\n    for s, y in zip(s_list, y_list):\n        if curvature_ok(s, y, eps=eps):\n            valid_pairs.append((s.copy(), y.copy()))\n    # Determine gamma\n    if gamma is None:\n        if len(valid_pairs) > 0:\n            s_last, y_last = valid_pairs[-1]\n            sty = float(s_last @ y_last)\n            yty = float(y_last @ y_last)\n            gamma_k = sty / yty if yty > 0.0 else 1.0\n            if gamma_k = 0.0 or not np.isfinite(gamma_k):\n                gamma_k = 1.0\n        else:\n            gamma_k = 1.0\n    else:\n        gamma_k = float(gamma)\n\n    # Two-loop recursion\n    q_vec = q.astype(float).copy()\n    alphas = []\n    rhos = []\n    # First loop: from newest to oldest\n    for s, y in reversed(valid_pairs):\n        sty = float(s @ y)\n        rho = 1.0 / sty\n        alpha = rho * float(s @ q_vec)\n        q_vec = q_vec - alpha * y\n        alphas.append(alpha)\n        rhos.append(rho)\n    # Apply initial H0\n    r = gamma_k * q_vec\n    # Second loop: from oldest to newest\n    # Need alphas, rhos in corresponding order\n    alphas = alphas[::-1]\n    rhos = rhos[::-1]\n    for (s, y), alpha, rho in zip(valid_pairs, alphas, rhos):\n        beta = rho * float(y @ r)\n        r = r + s * (alpha - beta)\n    return r\n\ndef solve():\n    results = []\n\n    # Common model data for mechanics-consistent tests\n    # a1 = [1, 0], a2 = [1, 1]\n    a_list = [np.array([1.0, 0.0]), np.array([1.0, 1.0])]\n    k = np.array([10.0, 5.0])\n    c = np.array([1.0, 0.5])\n    f = np.array([1.0, 0.2])\n\n    # Iterates\n    u0 = np.array([0.0, 0.0])\n    u1 = np.array([0.1, -0.05])\n    u2 = np.array([0.18, -0.06])\n\n    # Gradients\n    g0 = gradient_phi(u0, k, c, a_list, f)\n    g1 = gradient_phi(u1, k, c, a_list, f)\n    g2 = gradient_phi(u2, k, c, a_list, f)\n\n    # Secant pairs\n    s0 = u1 - u0\n    s1 = u2 - u1\n    y0 = g1 - g0\n    y1 = g2 - g1\n\n    # Store pairs in chronological order\n    s_list = [s0, s1]\n    y_list = [y0, y1]\n\n    # Test 1: Apply H_k to q = g(u2) with gamma from last valid pair\n    q1 = g2.copy()\n    r1 = lbfgs_two_loop(s_list, y_list, q1, gamma=None, eps=1e-12)\n    results.append([float(r1[0]), float(r1[1])])\n\n    # Test 2: Apply H_k to q = [1, -1] with same pairs and gamma rule\n    q2 = np.array([1.0, -1.0])\n    r2 = lbfgs_two_loop(s_list, y_list, q2, gamma=None, eps=1e-12)\n    results.append([float(r2[0]), float(r2[1])])\n\n    # Test 3: Empty memory, gamma = 1, q = [0.3, -0.4]\n    q3 = np.array([0.3, -0.4])\n    r3 = lbfgs_two_loop([], [], q3, gamma=1.0, eps=1e-12)\n    results.append([float(r3[0]), float(r3[1])])\n\n    # Test 4: Curvature screening edge case, pair should be skipped\n    s_bad = np.array([1e-8, 0.0])\n    y_bad = np.array([-1e-8, 0.0])\n    q4 = np.array([0.2, 0.5])\n    r4 = lbfgs_two_loop([s_bad], [y_bad], q4, gamma=None, eps=1e-12)\n    results.append([float(r4[0]), float(r4[1])])\n\n    # Test 5: Descent property check with q = g(u2)\n    q5 = g2.copy()\n    Hq = lbfgs_two_loop(s_list, y_list, q5, gamma=None, eps=1e-12)\n    p = -Hq\n    descent = float(q5 @ p)  0.0\n    results.append(bool(descent))\n\n    # Print in the exact required single-line format\n    # Nested lists will be printed by constructing the string manually\n    def to_str(x):\n        if isinstance(x, list):\n            return \"[\" + \",\".join(to_str(v) for v in x) + \"]\"\n        elif isinstance(x, bool):\n            return \"True\" if x else \"False\"\n        else:\n            return str(x)\n\n    print(\"[\" + \",\".join(to_str(r) for r in results) + \"]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}