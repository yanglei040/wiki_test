{
    "hands_on_practices": [
        {
            "introduction": "实现任何超弹性模型的第一步都是从其应变能函数中正确推导应力和切线模量。本练习侧重于可压缩Neo-Hookean模型，这是超弹性的一个基本模型，您将练习从第一性原理推导第二Piola-Kirchhoff应力（$S$）和相应的材料切线模量（$c$）。这项实践的关键技能不仅在于推导，还在于验证；通过将您的解析切线与有限差分法得到的数值近似进行比较，您将学到一种调试和确保本构模型实现正确性的关键技术。",
            "id": "3543698",
            "problem": "考虑一个三维超弹性体，其特征由应变能密度函数 $W$ 描述。该函数依赖于右 Cauchy-Green 张量 (RCG)，定义为 $\\boldsymbol{C} = \\boldsymbol{F}^{\\mathsf{T}} \\boldsymbol{F}$，其中 $\\boldsymbol{F}$ 是变形梯度。令 Green-Lagrange 应变为 $\\boldsymbol{E} = \\tfrac{1}{2}(\\boldsymbol{C} - \\boldsymbol{I})$，并将第二 Piola-Kirchhoff 应力 (SPK) 表示为 $\\boldsymbol{S} = \\dfrac{\\partial W}{\\partial \\boldsymbol{E}}$。算法一致性模量 $\\boldsymbol{c}$ 定义为四阶张量 $\\boldsymbol{c} = \\dfrac{\\partial^2 W}{\\partial \\boldsymbol{E} \\, \\partial \\boldsymbol{E}} = \\dfrac{\\partial \\boldsymbol{S}}{\\partial \\boldsymbol{E}}$。\n\n使用三维可压缩 Neo-Hookean 模型，其 Lamé 参数为 $\\lambda$ 和 $\\mu$ (单位均为帕斯卡)。应变能密度由下式给出\n$$\nW(\\boldsymbol{C}) = \\frac{\\mu}{2} (I_1 - 3) - \\mu \\ln J + \\frac{\\lambda}{2} (\\ln J)^2,\n$$\n其中 $I_1 = \\operatorname{tr}(\\boldsymbol{C})$，$J = \\det(\\boldsymbol{F})$，$\\ln J$ 是 $J$ 的自然对数。注意 $\\det(\\boldsymbol{C}) = J^2$，所以 $\\ln J = \\tfrac{1}{2} \\ln(\\det(\\boldsymbol{C}))$。\n\n您的任务是：\n1. 从 $W(\\boldsymbol{C})$ 出发，推导第二 Piola-Kirchhoff 应力 $\\boldsymbol{S}$ 和算法一致性模量 $\\boldsymbol{c} = \\dfrac{\\partial \\boldsymbol{S}}{\\partial \\boldsymbol{E}}$，并将它们表示为 $\\boldsymbol{C}$、$\\lambda$ 和 $\\mu$ 的函数。不要使用任何快捷公式；您的推导应基于基本求导法则、链式法则以及恒等式 $\\mathrm{d}\\,\\boldsymbol{C}^{-1} = -\\boldsymbol{C}^{-1} (\\mathrm{d}\\,\\boldsymbol{C}) \\boldsymbol{C}^{-1}$。\n2. 实现一个程序，对于给定的 $\\boldsymbol{F}$、$\\lambda$ 和 $\\mu$，计算：\n   - 任务1中推导出的解析解 $\\boldsymbol{S}$ 和 $\\boldsymbol{c}$，\n   - 通过对 $\\boldsymbol{E}$ 施加微小的对称扰动 $\\delta \\boldsymbol{E}$ 并使用中心差分格式，计算 $\\dfrac{\\partial \\boldsymbol{S}}{\\partial \\boldsymbol{E}}$ 的有限差分近似值。\n3. 对于 $\\boldsymbol{E}$ 的每个独立的对称扰动方向，量化解析导数与其有限差分近似值之间的相对误差，并返回所有方向中的最坏情况（最大）相对误差。使用 Frobenius 范数进行比较：\n$$\ne = \\max_{n \\in \\{1,\\dots,6\\}} \\frac{\\left\\| \\left.\\frac{\\partial \\boldsymbol{S}}{\\partial \\boldsymbol{E}}\\right|_{\\text{FD},n} - \\left.\\frac{\\partial \\boldsymbol{S}}{\\partial \\boldsymbol{E}}\\right|_{\\text{analytic},n} \\right\\|_F}{\\max\\left(\\left\\| \\left.\\frac{\\partial \\boldsymbol{S}}{\\partial \\boldsymbol{E}}\\right|_{\\text{analytic},n} \\right\\|_F, \\, \\varepsilon\\right)},\n$$\n其中，每个 $n$ 对应 $\\boldsymbol{E}$ 在 $\\{(1,1),(2,2),(3,3),(1,2),(2,3),(1,3)\\}$ 中的一个对称基方向，$\\varepsilon$ 是一个小的正则化常数，以避免除以零（选择 $\\varepsilon = 10^{-12}$）。应变扰动的中心差分步长必须为 $h = 10^{-6}$（无量纲），并且扰动必须通过 $\\delta \\boldsymbol{C} = 2 \\, \\delta \\boldsymbol{E}$ 应用于 $\\boldsymbol{C}$。\n\n物理单位：$\\lambda$ 和 $\\mu$ 使用帕斯卡 (Pa)。变形梯度 $\\boldsymbol{F}$ 是无量纲的。相对误差 $e$ 是无量纲的。本问题不涉及角度。\n\n测试套件：\n- 案例1 (一般中等变形): \n  - $\\lambda = 1.20 \\times 10^{5}\\,\\text{Pa}$，$\\mu = 8.00 \\times 10^{4}\\,\\text{Pa}$，\n  - $\\boldsymbol{F} = \\begin{bmatrix} 1.1  0.2  0.0 \\\\ 0.0  0.9  0.1 \\\\ 0.0  0.0  1.05 \\end{bmatrix}$。\n- 案例2 (具有微小体积变化的近不可压缩响应):\n  - $\\lambda = 1.00 \\times 10^{6}\\,\\text{Pa}$，$\\mu = 1.00 \\times 10^{4}\\,\\text{Pa}$，\n  - $\\boldsymbol{F} = \\begin{bmatrix} 1.02  0.0  0.0 \\\\ 0.0  0.98  0.0 \\\\ 0.0  0.0  1.00 \\end{bmatrix}$。\n- 案例3 (沿一个轴向的显著压缩并伴随剪切):\n  - $\\lambda = 5.00 \\times 10^{4}\\,\\text{Pa}$，$\\mu = 2.00 \\times 10^{5}\\,\\text{Pa}$，\n  - $\\boldsymbol{F} = \\begin{bmatrix} 1.0  0.3  0.0 \\\\ 0.0  1.0  0.0 \\\\ 0.0  0.0  0.8 \\end{bmatrix}$。\n\n您的程序应生成单行输出，其中包含上述三个案例的最坏情况相对误差 $e$，格式为方括号括起来的逗号分隔列表（例如，$[e_1,e_2,e_3]$）。每个 $e_i$ 都必须是浮点数。不应打印任何其他文本。",
            "solution": "该问题是有效的，因为它是适定的，其科学基础是连续介质力学原理，并为计算超弹性力学中的标准验证程序提供了一套完整且一致的定义和数据。\n\n### 任务1：应力和模量的推导\n\n主要任务是为可压缩 Neo-Hookean 材料推导第二 Piola-Kirchhoff (SPK) 应力张量 $\\boldsymbol{S}$ 和算法一致性模量的四阶张量 $\\boldsymbol{c}$。推导将从给定的应变能密度函数 $W$ 开始。\n\n应变能密度函数由下式给出：\n$$\nW(\\boldsymbol{C}) = \\frac{\\mu}{2} (I_1 - 3) - \\mu \\ln J + \\frac{\\lambda}{2} (\\ln J)^2\n$$\n其中 $I_1 = \\operatorname{tr}(\\boldsymbol{C})$，$J = \\det(\\boldsymbol{F}) = \\sqrt{\\det(\\boldsymbol{C})}$，并且 $\\boldsymbol{C} = \\boldsymbol{F}^{\\mathsf{T}}\\boldsymbol{F}$ 是右 Cauchy-Green 张量。Lamé 参数 $\\lambda$ 和 $\\mu$ 是材料常数。\n\nGreen-Lagrange 应变张量 $\\boldsymbol{E}$ 定义为 $\\boldsymbol{E} = \\frac{1}{2}(\\boldsymbol{C} - \\boldsymbol{I})$，其中 $\\boldsymbol{I}$ 是二阶单位张量。这给出了关系式 $\\boldsymbol{C} = 2\\boldsymbol{E} + \\boldsymbol{I}$。其微分关系为 $\\mathrm{d}\\boldsymbol{C} = 2 \\, \\mathrm{d}\\boldsymbol{E}$。\n\nSPK 应力 $\\boldsymbol{S}$ 和模量 $\\boldsymbol{c}$ 通过对 $\\boldsymbol{E}$ 的导数定义：\n$$\n\\boldsymbol{S} = \\frac{\\partial W}{\\partial \\boldsymbol{E}}, \\quad \\boldsymbol{c} = \\frac{\\partial \\boldsymbol{S}}{\\partial \\boldsymbol{E}} = \\frac{\\partial^2 W}{\\partial \\boldsymbol{E} \\partial \\boldsymbol{E}}\n$$\n使用链式法则，我们可以用 $\\boldsymbol{C}$ 来表示这些导数：\n$$\n\\boldsymbol{S} = \\frac{\\partial W}{\\partial \\boldsymbol{E}} = \\frac{\\partial W}{\\partial \\boldsymbol{C}} : \\frac{\\partial \\boldsymbol{C}}{\\partial \\boldsymbol{E}} = 2 \\frac{\\partial W}{\\partial \\boldsymbol{C}}\n$$\n$$\n\\boldsymbol{c} = \\frac{\\partial \\boldsymbol{S}}{\\partial \\boldsymbol{E}} = \\frac{\\partial \\boldsymbol{S}}{\\partial \\boldsymbol{C}} : \\frac{\\partial \\boldsymbol{C}}{\\partial \\boldsymbol{E}} = 2 \\frac{\\partial \\boldsymbol{S}}{\\partial \\boldsymbol{C}}\n$$\n因子 $2$ 源于 $\\boldsymbol{E}$ 的定义。\n\n#### 第二 Piola-Kirchhoff 应力 $\\boldsymbol{S}$ 的推导\n\n首先，我们计算 $W$ 对 $\\boldsymbol{C}$ 的导数。这需要计算其组成部分 $I_1$ 和 $\\ln J$ 的导数。\n\n1.  **$I_1 = \\operatorname{tr}(\\boldsymbol{C})$ 的导数：**\n    迹是线性算子，$I_1 = \\boldsymbol{I}:\\boldsymbol{C}$。其导数为：\n    $$\n    \\frac{\\partial I_1}{\\partial \\boldsymbol{C}} = \\boldsymbol{I}\n    $$\n\n2.  **$\\ln J$ 的导数：**\n    给定 $\\ln J = \\frac{1}{2}\\ln(\\det(\\boldsymbol{C}))$。使用链式法则和行列式导数的 Jacobi 公式 $\\frac{\\partial(\\det \\boldsymbol{A})}{\\partial \\boldsymbol{A}} = (\\det \\boldsymbol{A}) \\boldsymbol{A}^{-\\mathsf{T}}$，我们得到（因为 $\\boldsymbol{C}$ 是对称的）：\n    $$\n    \\frac{\\partial (\\ln J)}{\\partial \\boldsymbol{C}} = \\frac{\\partial}{\\partial \\boldsymbol{C}}\\left(\\frac{1}{2}\\ln(\\det(\\boldsymbol{C}))\\right) = \\frac{1}{2} \\frac{1}{\\det(\\boldsymbol{C})} \\frac{\\partial(\\det \\boldsymbol{C})}{\\partial \\boldsymbol{C}} = \\frac{1}{2 J^2} (J^2 \\boldsymbol{C}^{-1}) = \\frac{1}{2}\\boldsymbol{C}^{-1}\n    $$\n    \n现在我们可以对 $W$ 求导：\n$$\n\\frac{\\partial W}{\\partial \\boldsymbol{C}} = \\frac{\\partial}{\\partial \\boldsymbol{C}}\\left[ \\frac{\\mu}{2} (I_1 - 3) - \\mu \\ln J + \\frac{\\lambda}{2} (\\ln J)^2 \\right]\n$$\n$$\n\\frac{\\partial W}{\\partial \\boldsymbol{C}} = \\frac{\\mu}{2} \\frac{\\partial I_1}{\\partial \\boldsymbol{C}} - \\mu \\frac{\\partial (\\ln J)}{\\partial \\boldsymbol{C}} + \\lambda (\\ln J) \\frac{\\partial (\\ln J)}{\\partial \\boldsymbol{C}}\n$$\n代入上面求得的导数：\n$$\n\\frac{\\partial W}{\\partial \\boldsymbol{C}} = \\frac{\\mu}{2} \\boldsymbol{I} - \\mu \\left(\\frac{1}{2}\\boldsymbol{C}^{-1}\\right) + \\lambda (\\ln J) \\left(\\frac{1}{2}\\boldsymbol{C}^{-1}\\right) = \\frac{\\mu}{2} \\boldsymbol{I} + \\frac{1}{2}(\\lambda \\ln J - \\mu) \\boldsymbol{C}^{-1}\n$$\nSPK 应力 $\\boldsymbol{S}$ 是 $2 \\frac{\\partial W}{\\partial \\boldsymbol{C}}$：\n$$\n\\boldsymbol{S} = 2 \\left[ \\frac{\\mu}{2} \\boldsymbol{I} + \\frac{1}{2}(\\lambda \\ln J - \\mu) \\boldsymbol{C}^{-1} \\right] = \\mu \\boldsymbol{I} + (\\lambda \\ln J - \\mu) \\boldsymbol{C}^{-1}\n$$\n这就是第二 Piola-Kirchhoff 应力的解析表达式。\n\n#### 算法一致性模量 $\\boldsymbol{c}$ 的推导\n\n算法模量张量为 $\\boldsymbol{c} = 2 \\frac{\\partial \\boldsymbol{S}}{\\partial \\boldsymbol{C}}$。我们必须对 $\\boldsymbol{S}$ 的表达式关于 $\\boldsymbol{C}$ 求导。\n$$\n\\frac{\\partial \\boldsymbol{S}}{\\partial \\boldsymbol{C}} = \\frac{\\partial}{\\partial \\boldsymbol{C}} \\left[ \\mu \\boldsymbol{I} + (\\lambda \\ln J - \\mu) \\boldsymbol{C}^{-1} \\right]\n$$\n第一项 $\\mu\\boldsymbol{I}$ 相对于 $\\boldsymbol{C}$ 是常数，所以其导数为零。对于第二项，我们应用张量乘积法则：$(\\phi \\boldsymbol{A})' = \\phi' \\otimes \\boldsymbol{A} + \\phi \\boldsymbol{A}'$。\n令 $\\phi = \\lambda \\ln J - \\mu$ 且 $\\boldsymbol{A} = \\boldsymbol{C}^{-1}$。\n$$\n\\frac{\\partial}{\\partial \\boldsymbol{C}} \\left[ (\\lambda \\ln J - \\mu) \\boldsymbol{C}^{-1} \\right] = \\left(\\frac{\\partial (\\lambda \\ln J - \\mu)}{\\partial \\boldsymbol{C}}\\right) \\otimes \\boldsymbol{C}^{-1} + (\\lambda \\ln J - \\mu) \\frac{\\partial \\boldsymbol{C}^{-1}}{\\partial \\boldsymbol{C}}\n$$\n我们分别计算每个部分：\n\n1.  **第一项：** 标量部分的导数是：\n    $$\n    \\frac{\\partial (\\lambda \\ln J - \\mu)}{\\partial \\boldsymbol{C}} = \\lambda \\frac{\\partial (\\ln J)}{\\partial \\boldsymbol{C}} = \\frac{\\lambda}{2} \\boldsymbol{C}^{-1}\n    $$\n    因此，乘积法则的第一项是 $\\frac{\\lambda}{2} \\boldsymbol{C}^{-1} \\otimes \\boldsymbol{C}^{-1}$。用指标表示法，这是一个四阶张量，其分量为 $\\frac{\\lambda}{2} C^{-1}_{ij} C^{-1}_{kl}$。\n\n2.  **第二项：** 我们需要逆张量的导数 $\\frac{\\partial \\boldsymbol{C}^{-1}}{\\partial \\boldsymbol{C}}$。使用恒等式 $\\mathrm{d}(\\boldsymbol{C}^{-1}) = -\\boldsymbol{C}^{-1}(\\mathrm{d}\\boldsymbol{C})\\boldsymbol{C}^{-1}$ 并确保所得算子将对称张量映射到对称张量，该导数是四阶张量 $\\boldsymbol{\\mathcal{K}}$，其分量为：\n    $$\n    \\mathcal{K}_{ijkl} = \\frac{\\partial C^{-1}_{ij}}{\\partial C_{kl}} = -\\frac{1}{2} \\left( C^{-1}_{ik} C^{-1}_{jl} + C^{-1}_{il} C^{-1}_{jk} \\right)\n    $$\n    因此，乘积法则的第二项是 $(\\lambda \\ln J - \\mu) \\boldsymbol{\\mathcal{K}}$。\n\n结合这两项，我们得到 $\\frac{\\partial \\boldsymbol{S}}{\\partial \\boldsymbol{C}}$：\n$$\n\\left(\\frac{\\partial \\boldsymbol{S}}{\\partial \\boldsymbol{C}}\\right)_{ijkl} = \\frac{\\lambda}{2} C^{-1}_{ij} C^{-1}_{kl} - \\frac{\\lambda \\ln J - \\mu}{2} \\left( C^{-1}_{ik} C^{-1}_{jl} + C^{-1}_{il} C^{-1}_{jk} \\right)\n$$\n最后，通过乘以 $2$ 得到模量张量 $\\boldsymbol{c} = 2 \\frac{\\partial \\boldsymbol{S}}{\\partial \\boldsymbol{C}}$：\n$$\nc_{ijkl} = \\lambda C^{-1}_{ij} C^{-1}_{kl} - (\\lambda \\ln J - \\mu) \\left( C^{-1}_{ik} C^{-1}_{jl} + C^{-1}_{il} C^{-1}_{jk} \\right)\n$$\n重新整理成更常规的形式：\n$$\nc_{ijkl} = \\lambda \\, C^{-1}_{ij} C^{-1}_{kl} + (\\mu - \\lambda \\ln J) \\left( C^{-1}_{ik} C^{-1}_{jl} + C^{-1}_{il} C^{-1}_{jk} \\right)\n$$\n这是算法一致性模量的解析表达式，它具有所需的主对称性和次对称性。$\\boldsymbol{S}$ 和 $\\boldsymbol{c}$ 的这些表达式将被实现并进行数值验证。\n\n### 任务2和3：实现与误差量化\n\n实现过程包括使用推导出的公式解析地计算 $\\boldsymbol{S}$ 和 $\\boldsymbol{c}$。然后，为了验证，我们近似计算导数 $\\frac{\\partial \\boldsymbol{S}}{\\partial \\boldsymbol{E}}$ 在一组基向量上的作用。对于对称二阶张量空间中的一个基方向 $\\boldsymbol{\\Delta}_n$，方向导数的有限差分近似使用步长为 $h$ 的中心差分格式计算：\n$$\n\\left.\\frac{\\partial \\boldsymbol{S}}{\\partial \\boldsymbol{E}}\\right|_{\\text{FD},n} = \\frac{\\boldsymbol{S}(\\boldsymbol{E} + h \\boldsymbol{\\Delta}_n) - \\boldsymbol{S}(\\boldsymbol{E} - h \\boldsymbol{\\Delta}_n)}{2h}\n$$\n由于 $\\boldsymbol{S}$ 是 $\\boldsymbol{C} = 2\\boldsymbol{E} + \\boldsymbol{I}$ 的函数，扰动 $\\delta\\boldsymbol{E} = h\\boldsymbol{\\Delta}_n$ 对应于扰动 $\\delta\\boldsymbol{C} = 2h\\boldsymbol{\\Delta}_n$。有限差分计算变为：\n$$\n\\frac{\\boldsymbol{S}(\\boldsymbol{C} + 2h\\boldsymbol{\\Delta}_n) - \\boldsymbol{S}(\\boldsymbol{C} - 2h\\boldsymbol{\\Delta}_n)}{2h}\n$$\n将此数值结果与解析结果进行比较，解析结果是张量缩并 $\\boldsymbol{c}:\\boldsymbol{\\Delta}_n$，其分量为 $(c_{ijkl})(\\Delta_n)_{kl}$。然后为每个测试案例报告对称 $3 \\times 3$ 张量的 $6$ 个基方向上的最大相对误差。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_S(C, lam, mu):\n    \"\"\"\n    Computes the Second Piola-Kirchhoff stress tensor S.\n    \n    Args:\n        C (np.ndarray): 3x3 Right Cauchy-Green tensor.\n        lam (float): First Lamé parameter.\n        mu (float): Second Lamé parameter (shear modulus).\n    \n    Returns:\n        np.ndarray: 3x3 Second Piola-Kirchhoff stress tensor.\n    \"\"\"\n    det_C = np.linalg.det(C)\n    if det_C == 0:\n        raise ValueError(\"Determinant of C must be positive.\")\n    \n    J = np.sqrt(det_C)\n    ln_J = np.log(J)\n    C_inv = np.linalg.inv(C)\n    I = np.identity(3)\n    \n    S = mu * I + (lam * ln_J - mu) * C_inv\n    return S\n\ndef calculate_analytical_c(C, lam, mu):\n    \"\"\"\n    Computes the analytical algorithmic consistent tangent moduli c.\n    \n    Args:\n        C (np.ndarray): 3x3 Right Cauchy-Green tensor.\n        lam (float): First Lamé parameter.\n        mu (float): Second Lamé parameter (shear modulus).\n\n    Returns:\n        np.ndarray: 3x3x3x3 fourth-order tangent moduli tensor.\n    \"\"\"\n    det_C = np.linalg.det(C)\n    if det_C == 0:\n        raise ValueError(\"Determinant of C must be positive.\")\n        \n    J = np.sqrt(det_C)\n    ln_J = np.log(J)\n    C_inv = np.linalg.inv(C)\n\n    # c_ijkl = lambda_ * C_inv_ij * C_inv_kl + (mu - lambda_ * ln(J)) * (C_inv_ik*C_inv_jl + C_inv_il*C_inv_jk)\n    \n    # Term 1: lambda * (C_inv (x) C_inv)\n    term1 = lam * np.einsum('ij,kl->ijkl', C_inv, C_inv)\n    \n    # Term 2: (mu - lambda * ln(J)) * (I_symm(C_inv))\n    term2_factor = mu - lam * ln_J\n    term2_tensor = np.einsum('ik,jl->ijkl', C_inv, C_inv) + np.einsum('il,jk->ijkl', C_inv, C_inv)\n    \n    c_analytic = term1 + term2_factor * term2_tensor\n    return c_analytic\n\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and compute errors.\n    \"\"\"\n    test_cases = [\n        (1.20e5, 8.00e4, np.array([[1.1, 0.2, 0.0], [0.0, 0.9, 0.1], [0.0, 0.0, 1.05]])),\n        (1.00e6, 1.00e4, np.array([[1.02, 0.0, 0.0], [0.0, 0.98, 0.0], [0.0, 0.0, 1.00]])),\n        (5.00e4, 2.00e5, np.array([[1.0, 0.3, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 0.8]]))\n    ]\n\n    h = 1e-6\n    epsilon = 1e-12\n    max_errors = []\n\n    # Define the 6 independent symmetric perturbation basis directions for E.\n    perturbation_directions = []\n    # Diagonal directions (1,1), (2,2), (3,3)\n    for i in range(3):\n        delta = np.zeros((3, 3))\n        delta[i, i] = 1.0\n        perturbation_directions.append(delta)\n    # Off-diagonal directions (1,2), (2,3), (1,3)\n    for i, j in [(0, 1), (1, 2), (0, 2)]:\n        delta = np.zeros((3, 3))\n        delta[i, j] = 1.0\n        delta[j, i] = 1.0\n        perturbation_directions.append(delta)\n\n    for lam, mu, F in test_cases:\n        # Base calculation at the given deformation state\n        C = F.T @ F\n        \n        # 1. Compute analytical tangent moduli tensor c\n        c_analytic = calculate_analytical_c(C, lam, mu)\n        \n        errors_for_case = []\n        \n        # 2. Loop through perturbation directions to perform finite difference check\n        for delta_E_dir in perturbation_directions:\n            # Perturbation in C is 2 * delta_E\n            # The step size for delta_E is h\n            delta_C = 2 * h * delta_E_dir\n            \n            # Calculate S at perturbed states using central difference\n            C_plus = C + delta_C\n            C_minus = C - delta_C\n            \n            S_plus = calculate_S(C_plus, lam, mu)\n            S_minus = calculate_S(C_minus, lam, mu)\n            \n            # Finite difference approximation of (c : delta_E_dir)\n            # This is the directional derivative of S wrt E in direction delta_E_dir\n            c_colon_delta_fd = (S_plus - S_minus) / (2 * h)\n            \n            # Analytical result for comparison: contract c with the direction\n            c_colon_delta_analytic = np.einsum('ijkl, kl -> ij', c_analytic, delta_E_dir)\n\n            # 3. Quantify relative error for this direction\n            numerator = np.linalg.norm(c_colon_delta_fd - c_colon_delta_analytic, 'fro')\n            denominator = np.linalg.norm(c_colon_delta_analytic, 'fro')\n            \n            # Apply regularization to avoid division by zero\n            denominator = max(denominator, epsilon)\n            \n            relative_error = numerator / denominator\n            errors_for_case.append(relative_error)\n        \n        # Worst-case error for this test case\n        max_error = max(errors_for_case)\n        max_errors.append(max_error)\n        \n    print(f\"[{','.join(map(str, max_errors))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "在有限元方法中，尤其是在使用减缩积分单元时，通常需要诸如沙漏控制之类的稳定化技术，但这些稳定力可能不是保守的，从而导致非对称的算法切线模量。本练习探讨了在圣维南-基尔霍夫材料的一致性切线中加入非保守沙漏稳定项的后果，您将量化由此导致的次对称性损失，并设计一个投影算子来恢复对称性。这项练习能让您深入理解材料本构与数值离散化之间的相互作用，理解如何处理非对称切线，以及何时可以在不损害牛顿法收敛性的情况下进行对称化，这是计算固体力学专家的标志。",
            "id": "3543675",
            "problem": "本题要求您分析和校正由稳定化引入的算法切线模量张量的次对称性损失，这种稳定化是超弹性有限变形中带有沙漏控制的选择性减缩积分的典型特征。您的目标是推导一个一致的基线，量化由非保守稳定化引起的对称性损失，并设计一个对称化算子，该算子在恢复次对称性的同时，在适当条件下保持牛顿法的二次方收敛性。请在三维空间中进行计算，张量以直角笛卡尔分量表示。\n\n设可压缩 Saint Venant–Kirchhoff 超弹性固体的应变能密度定义在格林-拉格朗日应变上，形式如下：\n$$\nW(\\mathbf{E}) = \\frac{\\lambda}{2} \\left(\\mathrm{tr}\\,\\mathbf{E}\\right)^2 + \\mu\\, \\mathrm{tr}\\left(\\mathbf{E}^2\\right),\n$$\n其中 $\\lambda$ 和 $\\mu$ 是拉梅参数，$\\mathbf{E} = \\frac{1}{2}\\left(\\mathbf{C} - \\mathbf{I}\\right)$，$\\mathbf{C} = \\mathbf{F}^\\mathsf{T}\\mathbf{F}$ 是右柯西-格林张量。设 $\\mathbf{F}$ 为变形梯度，$J = \\det\\mathbf{F}$，$\\mathbf{I}$ 为二阶单位张量。\n\n任务：\n\n1. 从 $W(\\mathbf{E})$ 的定义和第二皮奥拉-基尔霍夫应力 $\\mathbf{S} = \\partial W/\\partial \\mathbf{E}$ 出发，推导拉格朗日形式的四阶材料弹性张量，\n$$\n\\mathbb{C}_{IJKL} = \\frac{\\partial S_{IJ}}{\\partial E_{KL}},\n$$\n并用 $\\lambda$、$\\mu$ 和克罗内克符号明确表示它。然后，通过将 $\\mathbb{C}$ 前推到当前构型，定义一个空间算法一致切线模量 $\\mathbb{a}^{\\mathrm{cons}}$：\n$$\n\\mathbb{a}^{\\mathrm{cons}}_{ijkl}(\\mathbf{F}) = \\frac{1}{J}\\,F_{iI} F_{jJ} F_{kK} F_{lL}\\,\\mathbb{C}_{IJKL}.\n$$\n证明 $\\mathbb{a}^{\\mathrm{cons}}$ 具有次对称性 $a^{\\mathrm{cons}}_{ijkl} = a^{\\mathrm{cons}}_{jikl} = a^{\\mathrm{cons}}_{ijlk}$。\n\n2. 将一个非保守的沙漏控制贡献建模为一个四阶张量 $\\mathbb{h}(\\mathbf{F})$，它被加到一致模量上，其分量为：\n$$\n\\mathbb{h}_{ijkl}(\\mathbf{F}) = \\beta\\left(U_{ij}\\,V_{kl} - V_{ij}\\,U_{kl}\\right),\n$$\n其中 $\\beta$ 是一个标量稳定化参数，$\\mathbf{U} = \\mathbf{F} - \\mathbf{I}$，且 $\\mathbf{V} = \\mathbf{F}^{-\\mathsf{T}} - \\mathbf{I}$。定义稳定化的（非保守的）算法模量：\n$$\n\\mathbb{a}(\\mathbf{F}) = \\mathbb{a}^{\\mathrm{cons}}(\\mathbf{F}) + \\mathbb{h}(\\mathbf{F}).\n$$\n证明对于一般的 $\\mathbf{F}$ 和 $\\beta \\neq 0$，$\\mathbb{a}$ 不满足次对称性。\n\n3. 为任意四阶张量 $\\mathbb{A}$ 定义一个次对称性损失的定量度量：\n$$\nm_{\\mathrm{rel}}(\\mathbb{A}) = \\frac{\\sqrt{\\left\\|\\mathbb{A} - \\mathbb{P}_{ij}(\\mathbb{A})\\right\\|_F^2 + \\left\\|\\mathbb{A} - \\mathbb{P}_{kl}(\\mathbb{A})\\right\\|_F^2}}{\\max\\left(\\left\\|\\mathbb{A}\\right\\|_F,\\varepsilon\\right)},\n$$\n其中 $\\left\\|\\cdot\\right\\|_F$ 表示弗罗贝尼乌斯范数，$\\varepsilon$ 是一个固定的很小的正数以避免除以零，$\\mathbb{P}_{ij}$ 表示前两个指标的转置，即 $\\left(\\mathbb{P}_{ij}(\\mathbb{A})\\right)_{ijkl} = \\mathbb{A}_{jikl}$，$\\mathbb{P}_{kl}$ 表示后两个指标的转置，即 $\\left(\\mathbb{P}_{kl}(\\mathbb{A})\\right)_{ijkl} = \\mathbb{A}_{ijlk}$。\n\n4. 提出一个对称化算子 $\\Pi_{\\mathrm{ms}}$，该算子是到具有两种次对称性的四阶张量子空间上的正交投影算子（在弗罗贝尼乌斯内积下）。证明您提出的算子是一个投影算子（幂等）并且相对于弗罗贝尼乌斯内积是自伴的，因此在最小二乘意义上能得到与 $\\mathbb{A}$ 最接近的次对称张量。将其应用于 $\\mathbb{a}$ 以获得 $\\widetilde{\\mathbb{a}} = \\Pi_{\\mathrm{ms}}(\\mathbb{a})$。\n\n5. 在求解离散非线性平衡方程的牛顿-拉夫逊法背景下，解释在何种充分条件下，用对称化的 $\\widetilde{\\mathbb{a}}$ 替代精确雅可比矩阵 $\\mathbb{a}$ 仍能保持牛顿法的二次方收敛性。您的解释必须基于非精确牛顿法的理论，并应明确陈述在解附近 $\\mathbb{a}$ 的反对称部分相对于残差所需满足的条件。\n\n6. 实现一个程序，对于下面的每个测试用例，使用您推导的公式计算以下量：\n   - 一致前推张量 $\\mathbb{a}^{\\mathrm{cons}}(\\mathbf{F})$。\n   - 沙漏张量 $\\mathbb{h}(\\mathbf{F})$ 和稳定化张量 $\\mathbb{a}(\\mathbf{F}) = \\mathbb{a}^{\\mathrm{cons}} + \\mathbb{h}$。\n   - 对称化张量 $\\widetilde{\\mathbb{a}} = \\Pi_{\\mathrm{ms}}(\\mathbb{a})$。\n   - 相对次对称性损失 $m_{\\mathrm{rel}}(\\mathbb{a})$ 和 $m_{\\mathrm{rel}}(\\widetilde{\\mathbb{a}})$。\n\n使用 $\\varepsilon = 10^{-12}$。所有量均视为无量纲。输出中不需要物理单位。\n\n测试套件（每个用例是一个元组 $\\left(\\mathbf{F}, \\lambda, \\mu, \\beta\\right)$，其中 $\\mathbf{F}$ 由其 $3 \\times 3$ 分量给出）：\n\n- 用例 1（一般变形，中等稳定化）：\n  $$\n  \\mathbf{F} = \\begin{bmatrix}\n  1.1  0.2  0.0\\\\\n  0.0  0.95  0.1\\\\\n  0.0  0.0  1.05\n  \\end{bmatrix},\\quad \\lambda = 120.0,\\quad \\mu = 40.0,\\quad \\beta = 0.6.\n  $$\n- 用例 2（非对角扰动，较强稳定化）：\n  $$\n  \\mathbf{F} = \\begin{bmatrix}\n  1.05  0.15  -0.05\\\\\n  0.02  0.98  0.04\\\\\n  0.01  -0.03  1.02\n  \\end{bmatrix},\\quad \\lambda = 50.0,\\quad \\mu = 30.0,\\quad \\beta = 1.2.\n  $$\n- 用例 3（对角拉伸，无稳定化；零损失的边界条件）：\n  $$\n  \\mathbf{F} = \\mathrm{diag}(1.2,\\,0.85,\\,1.1),\\quad \\lambda = 200.0,\\quad \\mu = 80.0,\\quad \\beta = 0.0.\n  $$\n- 用例 4（近不可压缩，显著剪切，中等稳定化）：\n  $$\n  \\mathbf{F} = \\begin{bmatrix}\n  1.0  0.3  0.0\\\\\n  0.0  1.0  0.2\\\\\n  0.0  0.0  1.0\n  \\end{bmatrix},\\quad \\lambda = 10000.0,\\quad \\mu = 10.0,\\quad \\beta = 0.8.\n  $$\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表的结果，顺序如下：\n$$\n\\left[m_{\\mathrm{rel}}(\\mathbb{a})^{(1)},\\; m_{\\mathrm{rel}}(\\widetilde{\\mathbb{a}})^{(1)},\\; m_{\\mathrm{rel}}(\\mathbb{a})^{(2)},\\; m_{\\mathrm{rel}}(\\widetilde{\\mathbb{a}})^{(2)},\\; m_{\\mathrm{rel}}(\\mathbb{a})^{(3)},\\; m_{\\mathrm{rel}}(\\widetilde{\\mathbb{a}})^{(3)},\\; m_{\\mathrm{rel}}(\\mathbb{a})^{(4)},\\; m_{\\mathrm{rel}}(\\widetilde{\\mathbb{a}})^{(4)}\\right],\n$$\n其中上标表示用例编号。每个条目必须是浮点数。不应打印其他任何文本。",
            "solution": "所提出的问题是计算连续介质力学中的一个综合性练习，重点在于处理非保守稳定化下超弹性中的算法切线模量。该问题具有科学依据，提法明确，并提供了所有必要的信息。我们将按照要求逐步进行推导和分析。\n\n### 1. 材料和空间切线模量的推导\n\nSaint Venant–Kirchhoff 材料的应变能密度函数为：\n$$\nW(\\mathbf{E}) = \\frac{\\lambda}{2} \\left(\\mathrm{tr}\\,\\mathbf{E}\\right)^2 + \\mu\\, \\mathrm{tr}\\left(\\mathbf{E}^2\\right)\n$$\n在直角笛卡尔分量表示法中，这写作：\n$$\nW = \\frac{\\lambda}{2} E_{KK} E_{LL} + \\mu E_{KL} E_{LK}\n$$\n这里隐含了对重复指标的求和。由于格林-拉格朗日应变张量 $\\mathbf{E}$ 是对称的（$E_{KL} = E_{LK}$），我们可以写成 $\\mathrm{tr}(\\mathbf{E}^2) = E_{KL}E_{KL}$。\n\n第二皮奥拉-基尔霍夫应力张量 $\\mathbf{S}$ 是应变能密度对应变张量 $\\mathbf{E}$ 的导数：\n$$\nS_{IJ} = \\frac{\\partial W}{\\partial E_{IJ}}\n$$\n使用链式法则和张量导数的性质（对于对称的 $\\mathbf{E}$，其分量表示为 $\\partial E_{KL}/\\partial E_{IJ} = \\frac{1}{2}(\\delta_{IK}\\delta_{JL} + \\delta_{IL}\\delta_{JK})$，或者更简单地，对于独立分量，$\\partial E_{KK}/\\partial E_{IJ} = \\delta_{IJ}$ 和 $\\partial E_{KL}/\\partial E_{IJ} = \\delta_{IK}\\delta_{JL}$，如果我们事先不假定 $\\partial/\\partial \\mathbf{E}$ 的对称性，随后再进行对称化），我们发现：\n$$\nS_{IJ} = \\frac{\\partial}{\\partial E_{IJ}} \\left( \\frac{\\lambda}{2} E_{KK} E_{LL} + \\mu E_{KL} E_{LK} \\right)\n$$\n$$\nS_{IJ} = \\frac{\\lambda}{2} \\left( \\delta_{IK}\\delta_{JK} E_{LL} + E_{KK} \\delta_{IL}\\delta_{JL} \\right) + \\mu \\left( \\delta_{IK}\\delta_{JL} E_{LK} + E_{KL} \\delta_{IL}\\delta_{JK} \\right)\n$$\n$$\nS_{IJ} = \\frac{\\lambda}{2} \\left( \\delta_{IJ} E_{LL} + E_{KK} \\delta_{IJ} \\right) + \\mu \\left( E_{JI} + E_{IJ} \\right)\n$$\n$$\nS_{IJ} = \\lambda \\left(\\mathrm{tr}\\,\\mathbf{E}\\right) \\delta_{IJ} + 2\\mu E_{IJ}\n$$\n在张量表示法中，即为 $\\mathbf{S} = \\lambda (\\mathrm{tr}\\,\\mathbf{E}) \\mathbf{I} + 2\\mu \\mathbf{E}$。\n\n接下来，我们通过对 $\\mathbf{S}$ 求关于 $\\mathbf{E}$ 的导数来推导四阶材料弹性张量 $\\mathbb{C}$：\n$$\n\\mathbb{C}_{IJKL} = \\frac{\\partial S_{IJ}}{\\partial E_{KL}} = \\frac{\\partial}{\\partial E_{KL}} \\left( \\lambda E_{MM} \\delta_{IJ} + 2\\mu E_{IJ} \\right)\n$$\n$$\n\\mathbb{C}_{IJKL} = \\lambda \\delta_{IJ} \\frac{\\partial E_{MM}}{\\partial E_{KL}} + 2\\mu \\frac{\\partial E_{IJ}}{\\partial E_{KL}}\n$$\n注意到 $\\partial E_{MM}/\\partial E_{KL} = \\delta_{MK}\\delta_{ML} = \\delta_{KL}$ 以及因为 $\\mathbf{E}$ 是对称的，$\\partial E_{IJ}/\\partial E_{KL} = \\frac{1}{2}(\\delta_{IK}\\delta_{JL} + \\delta_{IL}\\delta_{JK})$，我们得到：\n$$\n\\mathbb{C}_{IJKL} = \\lambda \\delta_{IJ} \\delta_{KL} + 2\\mu \\left( \\frac{1}{2}(\\delta_{IK}\\delta_{JL} + \\delta_{IL}\\delta_{JK}) \\right)\n$$\n$$\n\\mathbb{C}_{IJKL} = \\lambda \\delta_{IJ} \\delta_{KL} + \\mu (\\delta_{IK}\\delta_{JL} + \\delta_{IL}\\delta_{JK})\n$$\n这是著名的各向同性弹性张量。\n\n空间算法一致切线模量 $\\mathbb{a}^{\\mathrm{cons}}$ 是通过前推操作得到的：\n$$\n\\mathbb{a}^{\\mathrm{cons}}_{ijkl}(\\mathbf{F}) = \\frac{1}{J}\\,F_{iI} F_{jJ} F_{kK} F_{lL}\\,\\mathbb{C}_{IJKL}\n$$\n为了证明 $\\mathbb{a}^{\\mathrm{cons}}$ 具有次对称性（$a^{\\mathrm{cons}}_{ijkl} = a^{\\mathrm{cons}}_{jikl}$ 和 $a^{\\mathrm{cons}}_{ijkl} = a^{\\mathrm{cons}}_{ijlk}$），我们首先检查 $\\mathbb{C}$ 的对称性。\n- 第一个次对称性（$I \\leftrightarrow J$）：$\\mathbb{C}_{JIKL} = \\lambda \\delta_{JI} \\delta_{KL} + \\mu (\\delta_{JK}\\delta_{IL} + \\delta_{JL}\\delta_{IK}) = \\lambda \\delta_{IJ} \\delta_{KL} + \\mu (\\delta_{IL}\\delta_{JK} + \\delta_{IK}\\delta_{JL}) = \\mathbb{C}_{IJKL}$。\n- 第二个次对称性（$K \\leftrightarrow L$）：$\\mathbb{C}_{IJLK} = \\lambda \\delta_{IJ} \\delta_{LK} + \\mu (\\delta_{IL}\\delta_{JK} + \\delta_{IK}\\delta_{JL}) = \\lambda \\delta_{IJ} \\delta_{KL} + \\mu (\\delta_{IK}\\delta_{JL} + \\delta_{IL}\\delta_{JK}) = \\mathbb{C}_{IJKL}$。\n由于 $\\mathbb{C}$ 具有两种次对称性，我们可以证明 $\\mathbb{a}^{\\mathrm{cons}}$ 也具有同样的性质。\n- $a^{\\mathrm{cons}}_{jikl} = \\frac{1}{J}\\,F_{jA} F_{iB} F_{kC} F_{lD}\\,\\mathbb{C}_{ABCD}$。将求和指标 $A \\to B'$ 和 $B \\to A'$ 重新标记，得到 $\\frac{1}{J}\\,F_{jB'} F_{iA'} F_{kC} F_{lD}\\,\\mathbb{C}_{B'A'CD}$。由于 $\\mathbb{C}_{B'A'CD} = \\mathbb{C}_{A'B'CD}$，这变为 $\\frac{1}{J}\\,F_{iA'} F_{jB'} F_{kC} F_{lD}\\,\\mathbb{C}_{A'B'CD} = a^{\\mathrm{cons}}_{ijkl}$。\n- 类似的论证也适用于后两对指标：$a^{\\mathrm{cons}}_{ijlk} = \\frac{1}{J}\\,F_{iA} F_{jB} F_{kC} F_{lD}\\,\\mathbb{C}_{ABDC}$。由于 $\\mathbb{C}_{ABDC}=\\mathbb{C}_{ABCD}$，这等于 $a^{\\mathrm{cons}}_{ijkl}$。\n因此，$\\mathbb{a}^{\\mathrm{cons}}$ 继承了 $\\mathbb{C}$ 的次对称性。\n\n### 2. 稳定化模量中对称性损失的分析\n\n稳定化算法模量定义为 $\\mathbb{a}(\\mathbf{F}) = \\mathbb{a}^{\\mathrm{cons}}(\\mathbf{F}) + \\mathbb{h}(\\mathbf{F})$，其中沙漏贡献为：\n$$\n\\mathbb{h}_{ijkl}(\\mathbf{F}) = \\beta\\left(U_{ij}\\,V_{kl} - V_{ij}\\,U_{kl}\\right)\n$$\n其中 $\\mathbf{U} = \\mathbf{F} - \\mathbf{I}$ 和 $\\mathbf{V} = \\mathbf{F}^{-\\mathsf{T}} - \\mathbf{I}$。为了使 $\\mathbb{a}$ 具有次对称性，并且已知 $\\mathbb{a}^{\\mathrm{cons}}$ 具有此性质，$\\mathbb{h}$ 也必须具有次对称性。我们现在对一般的变形 $\\mathbf{F}$ 和 $\\beta \\neq 0$ 的情况进行检验。\n\n- 检验第一个次对称性（$h_{ijkl} = h_{jikl}$）：\n    $$\n    h_{jikl} = \\beta(U_{ji}V_{kl} - V_{ji}U_{kl})\n    $$\n    对称性条件 $h_{ijkl} = h_{jikl}$ 要求 $(U_{ij} - U_{ji})V_{kl} - (V_{ij} - V_{ji})U_{kl} = 0$。\n    项 $U_{ij} - U_{ji} = (F_{ij} - \\delta_{ij}) - (F_{ji} - \\delta_{ji}) = F_{ij} - F_{ji} = 2\\,\\mathrm{skw}(\\mathbf{F})_{ij}$。\n    项 $V_{ij} - V_{ji} = ((F^{-1})_{ji} - \\delta_{ij}) - ((F^{-1})_{ij} - \\delta_{ji}) = (F^{-1})_{ji} - (F^{-1})_{ij} = -2\\,\\mathrm{skw}(\\mathbf{F}^{-1})_{ij}$。\n    该条件变为 $2\\beta(\\mathrm{skw}(\\mathbf{F})_{ij} V_{kl} + \\mathrm{skw}(\\mathbf{F}^{-1})_{ij} U_{kl}) = 0$。对于一般变形，$\\mathbf{F}$ 包含旋转部分，因此 $\\mathrm{skw}(\\mathbf{F}) \\neq \\mathbf{0}$。此外，$\\mathbf{U}$ 和 $\\mathbf{V}$ 通常也非零。因此，该表达式不恒为零。\n\n- 检验第二个次对称性（$h_{ijkl} = h_{ijlk}$）：\n    $$\n    h_{ijlk} = \\beta(U_{ij}V_{lk} - V_{ij}U_{lk})\n    $$\n    对称性条件 $h_{ijkl} = h_{ijlk}$ 要求 $U_{ij}(V_{kl} - V_{lk}) - V_{ij}(U_{kl} - U_{lk}) = 0$。\n    项 $V_{kl} - V_{lk} = (F^{-T})_{kl} - (F^{-T})_{lk} = (F^{-1})_{lk} - (F^{-1})_{kl}$。\n    项 $U_{kl} - U_{lk} = F_{kl} - F_{lk}$。\n    该条件为 $\\beta[U_{ij}((F^{-1})_{lk} - (F^{-1})_{kl}) - V_{ij}(F_{kl} - F_{lk})] = 0$。同样，对于一个一般的非对称 $\\mathbf{F}$ 及其逆，该表达式不恒为零。\n\n由于 $\\mathbb{h}$ 通常缺乏两种次对称性，而 $\\mathbb{a}^{\\mathrm{cons}}$ 具有这些对称性，它们的和 $\\mathbb{a} = \\mathbb{a}^{\\mathrm{cons}} + \\mathbb{h}$ 对于一般的 $\\mathbf{F}$ 和 $\\beta \\neq 0$ 将不满足次对称性。\n\n### 3. 次对称性损失的定量度量\n\n所提出的度量 $m_{\\mathrm{rel}}(\\mathbb{A})$ 正确地量化了张量中关于前两个和后两个指标反对称部分的相对大小。弗罗贝尼乌斯范数是标准的张量范数，使用 $\\varepsilon$ 提供了数值稳定性。差分张量的分量是 $A_{ijkl} - A_{jikl}$ 和 $A_{ijkl} - A_{ijlk}$，它们直接度量了对每种次对称性的违反程度。平方、求和再开方，以均方根的方式组合了这些违规。该度量将按定义实现。\n\n### 4. 对称化算子 $\\Pi_{\\mathrm{ms}}$\n\n我们提出以下线性算子 $\\Pi_{\\mathrm{ms}}$，将任意四阶张量 $\\mathbb{A}$ 投影到具有次对称性的张量子空间上：\n$$\n(\\Pi_{\\mathrm{ms}}(\\mathbb{A}))_{ijkl} = \\frac{1}{4} (A_{ijkl} + A_{jikl} + A_{ijlk} + A_{jilk})\n$$\n令 $\\mathbb{B} = \\Pi_{\\mathrm{ms}}(\\mathbb{A})$。我们验证 $\\mathbb{B}$ 具有次对称性：\n- $B_{jikl} = \\frac{1}{4} (A_{jikl} + A_{ijkl} + A_{jilk} + A_{ijlk}) = B_{ijkl}$。\n- $B_{ijlk} = \\frac{1}{4} (A_{ijlk} + A_{jilk} + A_{ijkl} + A_{jikl}) = B_{ijkl}$。\n该算子正确地映射到所期望的子空间。\n\n接下来，我们通过证明它是幂等的和自伴的来证明它是一个正交投影算子。\n- **幂等性** ($\\Pi_{\\mathrm{ms}} \\circ \\Pi_{\\mathrm{ms}} = \\Pi_{\\mathrm{ms}}$)：\n    令 $\\mathbb{B} = \\Pi_{\\mathrm{ms}}(\\mathbb{A})$。我们再次应用该算子：$(\\Pi_{\\mathrm{ms}}(\\mathbb{B}))_{ijkl} = \\frac{1}{4} (B_{ijkl} + B_{jikl} + B_{ijlk} + B_{jilk})$。由于 $\\mathbb{B}$ 具有次对称性，所以 $B_{jikl}=B_{ijlk}=B_{jilk}=B_{ijkl}$。因此，$(\\Pi_{\\mathrm{ms}}(\\mathbb{B}))_{ijkl} = \\frac{1}{4} (4 B_{ijkl}) = B_{ijkl}$。于是，$\\Pi_{\\mathrm{ms}}(\\Pi_{\\mathrm{ms}}(\\mathbb{A})) = \\Pi_{\\mathrm{ms}}(\\mathbb{A})$。\n\n- **自伴性** ($\\langle \\Pi_{\\mathrm{ms}}(\\mathbb{A}), \\mathbb{D} \\rangle_F = \\langle \\mathbb{A}, \\Pi_{\\mathrm{ms}}(\\mathbb{D}) \\rangle_F$)：\n    弗罗贝尼乌斯内积为 $\\langle \\mathbb{A}, \\mathbb{D} \\rangle_F = \\sum_{i,j,k,l} A_{ijkl} D_{ijkl}$。\n    $$\n    \\langle \\Pi_{\\mathrm{ms}}(\\mathbb{A}), \\mathbb{D} \\rangle_F = \\sum_{i,j,k,l} \\frac{1}{4} (A_{ijkl} + A_{jikl} + A_{ijlk} + A_{jilk}) D_{ijkl}\n    $$\n    通过重新标记求和指标，我们可以将指标的转置从 $\\mathbb{A}$ 移到 $\\mathbb{D}$：\n    $\\sum A_{jikl} D_{ijkl} = \\sum A_{abcd} D_{badc} = \\sum A_{ijkl} D_{jikl}$。\n    $\\sum A_{ijlk} D_{ijkl} = \\sum A_{abcd} D_{abdc} = \\sum A_{ijkl} D_{ijlk}$。\n    $\\sum A_{jilk} D_{ijkl} = \\sum A_{abcd} D_{badc} = \\sum A_{ijkl} D_{jilk}$。\n    因此，\n    $$\n    \\langle \\Pi_{\\mathrm{ms}}(\\mathbb{A}), \\mathbb{D} \\rangle_F = \\sum_{i,j,k,l} A_{ijkl} \\frac{1}{4} (D_{ijkl} + D_{jikl} + D_{ijlk} + D_{jilk}) = \\langle \\mathbb{A}, \\Pi_{\\mathrm{ms}}(\\mathbb{D}) \\rangle_F\n    $$\n由于该算子是幂等的和自伴的，它是一个正交投影算子。这保证了 $\\widetilde{\\mathbb{a}} = \\Pi_{\\mathrm{ms}}(\\mathbb{a})$ 是在最小二乘（弗罗贝尼乌斯范数）意义上与 $\\mathbb{a}$ 最接近的次对称张量。\n\n### 5. 二次方收敛的充分条件\n\n求解非线性方程组 $\\mathbf{R}(\\mathbf{u}) = \\mathbf{0}$ 的牛顿-拉夫逊法由迭代 $\\mathbf{u}_{k+1} = \\mathbf{u}_k - [\\mathbf{K}_T(\\mathbf{u}_k)]^{-1} \\mathbf{R}(\\mathbf{u}_k)$ 给出，其中 $\\mathbf{K}_T = \\partial \\mathbf{R}/\\partial \\mathbf{u}$ 是精确的切线刚度矩阵（雅可比矩阵）。如果雅可比矩阵计算正确且在解 $\\mathbf{u}^*$ 处非奇异，该方法将表现出渐近二次方收敛。\n\n在我们的问题中，“精确的”切线模量是 $\\mathbb{a}$，它导出了精确的雅可比矩阵 $\\mathbf{K}_T$。我们用一个近似模量 $\\widetilde{\\mathbb{a}}$ 来替代它，从而得到一个近似的雅可比矩阵 $\\widetilde{\\mathbf{K}}_T$。这将算法转变为一个非精确牛顿法。\n\n非精确牛顿法的理论（例如 Dembo, Eisenstat, Steihaug）为保持快速收敛提供了条件。如果雅可比步骤中的误差满足以下条件，二次方收敛性将得以保持：\n$$\n\\| (\\widetilde{\\mathbf{K}}_T(\\mathbf{u}_k) - \\mathbf{K}_T(\\mathbf{u}_k)) \\Delta\\mathbf{u}_k \\| = O(\\|\\mathbf{R}(\\mathbf{u}_k)\\|^2)\n$$\n其中 $\\Delta\\mathbf{u}_k = \\mathbf{u}_{k+1} - \\mathbf{u}_k$。雅可比矩阵之间的差 $\\widetilde{\\mathbf{K}}_T - \\mathbf{K}_T$ 是由切线模量之差 $\\widetilde{\\mathbb{a}} - \\mathbb{a}$ 组装而成的。这个差是：\n$$\n\\widetilde{\\mathbb{a}} - \\mathbb{a} = \\Pi_{\\mathrm{ms}}(\\mathbb{a}) - \\mathbb{a} = \\Pi_{\\mathrm{ms}}(\\mathbb{a}^{\\mathrm{cons}} + \\mathbb{h}) - (\\mathbb{a}^{\\mathrm{cons}} + \\mathbb{h}) = (\\mathbb{a}^{\\mathrm{cons}} + \\Pi_{\\mathrm{ms}}(\\mathbb{h})) - (\\mathbb{a}^{\\mathrm{cons}} + \\mathbb{h}) = \\Pi_{\\mathrm{ms}}(\\mathbb{h}) - \\mathbb{h}\n$$\n这一项表示 $\\mathbb{h}$ 在与次对称张量正交的子空间上的投影。\n\n一个满足二次方收敛要求的充分但较强的条件是，近似雅可比矩阵在解处等于精确雅可比矩阵。即 $\\widetilde{\\mathbf{K}}_T(\\mathbf{u}^*) = \\mathbf{K}_T(\\mathbf{u}^*)$。这意味着在连续介质层面上，切线模量在解状态 $\\mathbf{F}^*$ 处必须相等：\n$$\n\\widetilde{\\mathbb{a}}(\\mathbf{F}^*) = \\mathbb{a}(\\mathbf{F}^*)\n$$\n此等式成立当且仅当 $\\mathbb{a}(\\mathbf{F}^*)$ 本身已具有次对称性，即 $\\Pi_{\\mathrm{ms}}(\\mathbb{a}(\\mathbf{F}^*)) = \\mathbb{a}(\\mathbf{F}^*)$。这要求沙漏贡献项 $\\mathbb{h}(\\mathbf{F}^*)$ 在解处是次对称的。如第2部分所示，如果 $\\mathbf{F}$ 和 $\\mathbf{F}^{-1}$ 的斜对称部分为零，则 $\\mathbb{h}$ 具有次对称性。这发生在 $\\mathbf{F}$ 是一个对称张量时。\n\n因此，保持牛顿法二次方收敛速度的一个充分条件是，平衡解处的变形 $\\mathbf{F}^*$ 是一个纯拉伸，即 $\\mathbf{F}^*$ 是一个对称张量。在这种情况下，非保守稳定化项 $\\mathbb{h}(\\mathbf{F}^*)$ 变得具有次对称性，对称化切线模量 $\\widetilde{\\mathbb{a}}(\\mathbf{F}^*)$ 等于精确切线模量 $\\mathbb{a}(\\mathbf{F}^*)$，渐近收敛率仍为二次方。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for all test cases and prints the formatted result.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        (\n            np.array([[1.1, 0.2, 0.0], [0.0, 0.95, 0.1], [0.0, 0.0, 1.05]]),\n            120.0, 40.0, 0.6\n        ),\n        # Case 2\n        (\n            np.array([[1.05, 0.15, -0.05], [0.02, 0.98, 0.04], [0.01, -0.03, 1.02]]),\n            50.0, 30.0, 1.2\n        ),\n        # Case 3\n        (\n            np.array([[1.2, 0.0, 0.0], [0.0, 0.85, 0.0], [0.0, 0.0, 1.1]]),\n            200.0, 80.0, 0.0\n        ),\n        # Case 4\n        (\n            np.array([[1.0, 0.3, 0.0], [0.0, 1.0, 0.2], [0.0, 0.0, 1.0]]),\n            10000.0, 10.0, 0.8\n        ),\n    ]\n\n    epsilon = 1e-12\n    results = []\n\n    for F_mat, lam, mu, beta in test_cases:\n        m_rel_a, m_rel_a_tilde = compute_for_case(F_mat, lam, mu, beta, epsilon)\n        results.extend([m_rel_a, m_rel_a_tilde])\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_m_rel(A, epsilon):\n    \"\"\"\n    Computes the relative minor symmetry loss for a 4th-order tensor A.\n    \"\"\"\n    norm_A_F = np.linalg.norm(A)\n    \n    # Difference with respect to transposition of the first two indices\n    A_minus_Pij = A - A.transpose(1, 0, 2, 3)\n    norm_sq_Pij_diff = np.linalg.norm(A_minus_Pij)**2\n    \n    # Difference with respect to transposition of the last two indices\n    A_minus_Pkl = A - A.transpose(0, 1, 3, 2)\n    norm_sq_Pkl_diff = np.linalg.norm(A_minus_Pkl)**2\n    \n    numerator = np.sqrt(norm_sq_Pij_diff + norm_sq_Pkl_diff)\n    denominator = max(norm_A_F, epsilon)\n    \n    return numerator / denominator\n\ndef pi_ms(A):\n    \"\"\"\n    Applies the minor symmetrization operator Pi_ms to a 4th-order tensor A.\n    \"\"\"\n    A_jikl = A.transpose(1, 0, 2, 3)\n    A_ijlk = A.transpose(0, 1, 3, 2)\n    A_jilk = A.transpose(1, 0, 3, 2)\n    return 0.25 * (A + A_jikl + A_ijlk + A_jilk)\n\ndef compute_for_case(F, lam, mu, beta, epsilon):\n    \"\"\"\n    Performs all computations for a single test case.\n    \"\"\"\n    # 1. Compute material elasticity tensor C\n    delta = np.eye(3)\n    C = (lam * np.einsum('ij,kl->ijkl', delta, delta) +\n         mu * (np.einsum('ik,jl->ijkl', delta, delta) +\n               np.einsum('il,jk->ijkl', delta, delta)))\n\n    # 2. Compute consistent spatial tangent a_cons\n    J = np.linalg.det(F)\n    a_cons = (1.0 / J) * np.einsum('iI,jJ,kK,lL,IJKL->ijkl', F, F, F, F, C, optimize=True)\n\n    # 3. Compute hourglass tensor h\n    I = np.eye(3)\n    try:\n        F_inv = np.linalg.inv(F)\n    except np.linalg.LinAlgError:\n        # Handle singular F if it occurs, though not expected in test cases\n        print(\"Error: Singular deformation gradient F.\")\n        return float('nan'), float('nan')\n        \n    F_inv_T = F_inv.T\n    U = F - I\n    V = F_inv_T - I\n    \n    # h_ijkl = beta * (U_ij * V_kl - V_ij * U_kl)\n    h = beta * (np.einsum('ij,kl->ijkl', U, V) - np.einsum('ij,kl->ijkl', V, U))\n\n    # 4. Compute stabilized tensor a\n    a = a_cons + h\n    \n    # 5. Compute symmetrized tensor a_tilde\n    a_tilde = pi_ms(a)\n\n    # 6. Compute relative minor symmetry losses\n    m_rel_a = compute_m_rel(a, epsilon)\n    m_rel_a_tilde = compute_m_rel(a_tilde, epsilon)\n\n    return m_rel_a, m_rel_a_tilde\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "许多先进的超弹性模型天然地使用来自极分解 $\\mathbf{F} = \\mathbf{R}\\mathbf{U}$ 的拉伸张量 $\\mathbf{U}$ 来构建。为了推导一致性切线，需要计算 $\\mathbf{R}$ 和 $\\mathbf{U}$ 相对于 $\\mathbf{F}$ 的导数，当变形极端或退化时，这在数值上可能不稳定。本练习要求您使用奇异值分解 (SVD) 为这些运动学导数开发一个数值稳健的算法，您将推导谱公式，从而优雅地处理接近秩亏或具有重复奇异值的变形情况。掌握这种基于SVD的方法对于创建能够模拟严重材料变形的稳定有限元代码至关重要。",
            "id": "3543722",
            "problem": "要求您设计并验证一个数值稳健的算法，用于计算极分解中的正交因子和右拉伸的导数，这对于超弹性中的算法一致切线算子是必需的。设 $ \\mathbf{F} \\in \\mathbb{R}^{3 \\times 3} $ 为形变梯度，其极分解为 $ \\mathbf{F} = \\mathbf{R} \\mathbf{U} $，其中 $ \\mathbf{R} \\in \\mathrm{SO}(3) $ 是真正交旋转，$ \\mathbf{U} \\in \\mathbb{R}^{3 \\times 3} $ 是对称正定右拉伸。目标是使用一种基于奇异值分解 (SVD) 的方法，稳健地计算线性映射 $ \\mathrm{d}\\mathbf{U}[\\mathrm{d}\\mathbf{F}] $ 和 $ \\mathrm{d}\\mathbf{R}[\\mathrm{d}\\mathbf{F}] $，该方法在 $ \\mathbf{F} $ 近乎秩亏时仍保持稳定，然后利用这些结果为仅依赖于 $ \\mathbf{U} $ 的超弹性储能组装算法一致切线。\n\n您的推导应仅基于以下基本定义和事实：\n- 极分解 $ \\mathbf{F} = \\mathbf{R} \\mathbf{U} $，其中 $ \\mathbf{R}^\\mathsf{T} \\mathbf{R} = \\mathbf{I} $，$ \\det \\mathbf{R} = 1 $，以及 $ \\mathbf{U} = (\\mathbf{F}^\\mathsf{T} \\mathbf{F})^{1/2} $。\n- 奇异值分解 $ \\mathbf{F} = \\bar{\\mathbf{U}} \\boldsymbol{\\Sigma} \\mathbf{V}^\\mathsf{T} $，其中 $ \\boldsymbol{\\Sigma} = \\mathrm{diag}(\\sigma_1,\\sigma_2,\\sigma_3) $，$ \\sigma_i \\ge 0 $，$ \\bar{\\mathbf{U}}, \\mathbf{V} \\in \\mathrm{O}(3) $，以及恒等式 $ \\mathbf{R} = \\bar{\\mathbf{U}} \\mathbf{V}^\\mathsf{T} $，$ \\mathbf{U} = \\mathbf{V} \\boldsymbol{\\Sigma} \\mathbf{V}^\\mathsf{T} $。\n- 写成 $ \\mathbf{U} $ 的函数的可压缩 Neo-Hookean 储能：\n$$\nW(\\mathbf{U}) = \\frac{\\mu}{2} \\left( \\mathrm{tr}(\\mathbf{U}^2) - 3 \\right) - \\mu \\ln J + \\frac{\\lambda}{2} (\\ln J)^2,\n$$\n其中 $ J = \\det \\mathbf{U} = \\det \\mathbf{F} $，剪切模量 $ \\mu > 0 $，第一 Lamé 参数 $ \\lambda > 0 $。\n- 对于仅依赖于 $ \\mathbf{U} $ 的能量，第一 Piola-Kirchhoff 应力可以表示为 $ \\mathbf{P} = \\mathbf{R} \\, \\mathbf{S}(\\mathbf{U}) $，其中 $ \\mathbf{S}(\\mathbf{U}) = \\partial W / \\partial \\mathbf{U} $ 是对称的。\n- 算法一致切线是 Fréchet 导数 $ \\mathbb{A}[\\mathrm{d}\\mathbf{F}] = \\mathrm{d}\\mathbf{P}[\\mathrm{d}\\mathbf{F}] $。\n\n您的任务是：\n1) 从极分解恒等式和定义 $ \\mathbf{U} = (\\mathbf{F}^\\mathsf{T} \\mathbf{F})^{1/2} $ 出发，推导适用于一般非奇异 $ \\mathbf{F} $ 的 $ \\mathrm{d}\\mathbf{U}[\\mathrm{d}\\mathbf{F}] $ 和 $ \\mathrm{d}\\mathbf{R}[\\mathrm{d}\\mathbf{F}] $ 的表达式。展示如何为 $ \\mathrm{d}\\mathbf{U} $ 和满足 $ \\mathrm{d}\\mathbf{R} = \\mathbf{R} \\boldsymbol{\\Omega} $ 的斜对称生成元 $ \\boldsymbol{\\Omega} $ 建立必要的线性矩阵方程。\n2) 提出一种基于 SVD 的稳健计算算法来评估这些导数，该算法在 $ \\mathbf{F} $ 近乎秩亏时（例如，当某个奇异值 $ \\sigma_i $ 极小时）仍能表现良好。您的算法必须仅使用从 SVD 中获得的量，并应包含针对任何变得病态的除法的正则化策略。明确说明您如何正则化所推导的谱公式中的分母，以及如何在使用 SVD 计算时确保 $ \\det \\mathbf{R} = 1 $。\n3) 使用 (1) 和 (2) 的结果，为给定的超弹性模型推导算法一致切线作用 $ \\mathbb{A}[\\mathrm{d}\\mathbf{F}] = \\mathrm{d}\\mathbf{P}[\\mathrm{d}\\mathbf{F}] $ 的公式，该公式完全用 $ \\mathbf{R} $、$ \\mathbf{U} $、$ \\mathbf{S}(\\mathbf{U}) $、作用于 $ \\mathrm{d}\\mathbf{U} $ 的二阶导数 $ \\partial^2 W / \\partial \\mathbf{U} \\partial \\mathbf{U} $ 和 $ \\boldsymbol{\\Omega} $ 表示。\n\n实现要求：\n- 实现一个程序，计算：\n  - 通过您的稳健 SVD 算法计算导数映射 $ \\mathrm{d}\\mathbf{U}[\\mathrm{d}\\mathbf{F}] $ 和 $ \\boldsymbol{\\Omega}[\\mathrm{d}\\mathbf{F}] $。\n  - 第一 Piola-Kirchhoff 应力 $ \\mathbf{P}(\\mathbf{F}) = \\mathbf{R} \\, \\mathbf{S}(\\mathbf{U}) $。\n  - 算法一致切线作用 $ \\mathbb{A}[\\mathrm{d}\\mathbf{F}] $，作为 $ \\mathrm{d}\\mathbf{P}[\\mathrm{d}\\mathbf{F}] $，使用基于您计算的 $ \\mathrm{d}\\mathbf{U} $ 和 $ \\boldsymbol{\\Omega} $ 的链式法则构建。\n  - 使用中心差分格式和小步长 $ \\varepsilon $ 对 $ \\mathrm{d}\\mathbf{U}[\\mathrm{d}\\mathbf{F}] $、$ \\boldsymbol{\\Omega}[\\mathrm{d}\\mathbf{F}] $ 和 $ \\mathbb{A}[\\mathrm{d}\\mathbf{F}] $ 进行独立的有限差分检验。\n- 所有量均为无量纲。不需要物理单位。\n- 如果需要，内部使用的所有角度都必须以弧度为单位。\n\n测试套件：\n使用 $ \\lambda = 20 $ 和 $ \\mu = 10 $。对于以下每种情况，使用给定的 $ \\mathbf{F} $ 和方向 $ \\mathrm{d}\\mathbf{F} $（均为 $ 3 \\times 3 $ 矩阵），以及中心差分步长 $ \\varepsilon = 10^{-8} $：\n- 情况 1 (一般良态)：\n  - $ \\mathbf{F}_1 = \\begin{bmatrix} 1.2  0.3  0.1 \\\\ 0.2  0.9  -0.4 \\\\ 0.0  0.5  1.1 \\end{bmatrix} $,\n  - $ \\mathrm{d}\\mathbf{F}_1 = \\begin{bmatrix} 0.01  -0.02  0.03 \\\\ -0.01  0.02  0.01 \\\\ 0.0  -0.03  0.04 \\end{bmatrix} $。\n- 情况 2 (高度扭曲，近乎秩亏)：设 $ \\theta = 0.7 $。通过 Rodrigues 公式定义绕单位轴 $ \\mathbf{a} = \\frac{1}{\\sqrt{3}} [1,1,1]^\\mathsf{T} $ 的旋转，并设置\n  - $ \\mathbf{F}_2 = \\mathbf{R}_\\theta \\, \\mathrm{diag}(2.5, 10^{-6}, 0.5) $，\n  - $ \\mathrm{d}\\mathbf{F}_2 = \\begin{bmatrix} 0.02  0.01  -0.01 \\\\ -0.03  0.04  0.02 \\\\ 0.01  -0.02  0.03 \\end{bmatrix} $。\n- 情况 3 (奇异值近乎重复)：设 $ \\phi = 0.9 $ 和 $ \\psi = -0.4 $ 分别定义绕轴 $ \\mathbf{e}_z $ 和 $ \\mathbf{e}_x $ 的两次独立旋转；设置\n  - $ \\mathbf{F}_3 = \\mathbf{R}_z(\\phi) \\, \\mathrm{diag}(1.0, 1.0 + 10^{-8}, 0.7) \\, \\mathbf{R}_x(\\psi)^\\mathsf{T} $，\n  - $ \\mathrm{d}\\mathbf{F}_3 = \\begin{bmatrix} -0.015  0.005  0.01 \\\\ 0.025  -0.02  0.005 \\\\ -0.005  0.015  -0.01 \\end{bmatrix} $。\n\n对于每种情况 $ k \\in \\{1,2,3\\} $，计算以下无量纲相对误差：\n- $ e^{(k)}_{\\mathbf{U}} = \\dfrac{\\left\\| \\mathrm{d}\\mathbf{U}_\\text{algo} - \\mathrm{d}\\mathbf{U}_\\text{fd} \\right\\|_F}{\\max\\left(10^{-30}, \\left\\| \\mathrm{d}\\mathbf{U}_\\text{fd} \\right\\|_F \\right)} $，\n- $ e^{(k)}_{\\boldsymbol{\\Omega}} = \\dfrac{\\left\\| \\boldsymbol{\\Omega}_\\text{algo} - \\boldsymbol{\\Omega}_\\text{fd} \\right\\|_F}{\\max\\left(10^{-30}, \\left\\| \\boldsymbol{\\Omega}_\\text{fd} \\right\\|_F \\right)} $，其中 $ \\boldsymbol{\\Omega}_\\text{fd} $ 是通过将 $ \\mathbf{R}^\\mathsf{T} \\, \\mathrm{d}\\mathbf{R}_\\text{fd} $ 投影到斜对称部分得到的，\n- $ e^{(k)}_{\\mathbb{A}} = \\dfrac{\\left\\| \\mathbb{A}_\\text{algo}[\\mathrm{d}\\mathbf{F}_k] - \\mathrm{d}\\mathbf{P}_\\text{fd} \\right\\|_F}{\\max\\left(10^{-30}, \\left\\| \\mathrm{d}\\mathbf{P}_\\text{fd} \\right\\|_F \\right)} $。\n\n程序输出格式：\n- 您的程序应生成单行输出，其中包含九个结果，以逗号分隔的列表形式包含在方括号内，顺序如下：$ [ e^{(1)}_{\\mathbf{U}}, e^{(1)}_{\\boldsymbol{\\Omega}}, e^{(1)}_{\\mathbb{A}}, e^{(2)}_{\\mathbf{U}}, e^{(2)}_{\\boldsymbol{\\Omega}}, e^{(2)}_{\\mathbb{A}}, e^{(3)}_{\\mathbf{U}}, e^{(3)}_{\\boldsymbol{\\Omega}}, e^{(3)}_{\\mathbb{A}} ] $。",
            "solution": "该问题要求推导并实现一个稳健的算法，用于计算形变梯度 $ \\mathbf{F} $ 的极分解因子的导数，并利用这些导数计算可压缩 Neo-Hookean 材料的算法一致切线。该过程将按要求分为三部分进行详细说明。\n\n### 第 1 部分：$ \\mathrm{d}\\mathbf{U} $ 和 $ \\boldsymbol{\\Omega} $ 的线性矩阵方程推导\n\n设形变梯度为 $ \\mathbf{F} \\in \\mathbb{R}^{3\\times3} $。其极分解为 $ \\mathbf{F} = \\mathbf{R} \\mathbf{U} $，其中 $ \\mathbf{R} \\in \\mathrm{SO}(3) $ 是一个真正交旋转张量（$ \\mathbf{R}^\\mathsf{T}\\mathbf{R}=\\mathbf{I} $，$ \\det\\mathbf{R}=1 $），而 $ \\mathbf{U} $ 是对称正定右拉伸张量。一个量的时间变化率或方向导数将用 $ \\mathrm{d}(\\cdot) $ 表示，它是一个作用于增量 $ \\mathrm{d}\\mathbf{F} $ 上的线性映射。\n\n我们从对极分解表达式求导开始：\n$$ \\mathrm{d}\\mathbf{F} = \\mathrm{d}\\mathbf{R} \\, \\mathbf{U} + \\mathbf{R} \\, \\mathrm{d}\\mathbf{U} $$\n旋转张量的导数 $ \\mathrm{d}\\mathbf{R} $ 可以用一个斜对称张量 $ \\boldsymbol{\\Omega} $ 表示为 $ \\mathrm{d}\\mathbf{R} = \\mathbf{R} \\boldsymbol{\\Omega} $。$ \\boldsymbol{\\Omega} $ 的斜对称性源于正交条件 $ \\mathbf{R}^\\mathsf{T}\\mathbf{R}=\\mathbf{I} $，对其求导得到 $ \\mathrm{d}\\mathbf{R}^\\mathsf{T}\\mathbf{R} + \\mathbf{R}^\\mathsf{T}\\mathrm{d}\\mathbf{R} = \\mathbf{0} $，从而得出 $ \\boldsymbol{\\Omega}^\\mathsf{T} + \\boldsymbol{\\Omega} = \\mathbf{0} $。\n\n将 $ \\mathrm{d}\\mathbf{R} = \\mathbf{R} \\boldsymbol{\\Omega} $ 代入 $ \\mathbf{F} $ 的导数中：\n$$ \\mathrm{d}\\mathbf{F} = \\mathbf{R} \\boldsymbol{\\Omega} \\mathbf{U} + \\mathbf{R} \\, \\mathrm{d}\\mathbf{U} $$\n左侧乘以 $ \\mathbf{R}^\\mathsf{T} $，我们得到：\n$$ \\mathbf{R}^\\mathsf{T} \\mathrm{d}\\mathbf{F} = \\boldsymbol{\\Omega} \\mathbf{U} + \\mathrm{d}\\mathbf{U} $$\n我们定义张量 $ \\mathbf{L} = \\mathbf{R}^\\mathsf{T} \\mathrm{d}\\mathbf{F} $。方程变为 $ \\mathbf{L} = \\boldsymbol{\\Omega} \\mathbf{U} + \\mathrm{d}\\mathbf{U} $。\n由于 $ \\mathbf{U} $ 是对称的，张量 $ \\mathrm{d}\\mathbf{U} $ 也必须是对称的。$ \\boldsymbol{\\Omega} $ 是斜对称的。我们可以将 $ \\mathbf{L} $ 分解为其对称部分和斜对称部分：$ \\mathbf{L} = \\mathrm{symm}(\\mathbf{L}) + \\mathrm{skew}(\\mathbf{L}) $。\n$$ \\mathrm{symm}(\\mathbf{L}) = \\mathrm{symm}(\\boldsymbol{\\Omega} \\mathbf{U} + \\mathrm{d}\\mathbf{U}) = \\mathrm{symm}(\\boldsymbol{\\Omega} \\mathbf{U}) + \\mathrm{d}\\mathbf{U} $$\n$$ \\mathrm{skew}(\\mathbf{L}) = \\mathrm{skew}(\\boldsymbol{\\Omega} \\mathbf{U} + \\mathrm{d}\\mathbf{U}) = \\mathrm{skew}(\\boldsymbol{\\Omega} \\mathbf{U}) $$\n第二个方程为 $ \\boldsymbol{\\Omega} $ 提供了一个线性系统。展开斜对称部分：\n$$ \\mathrm{skew}(\\boldsymbol{\\Omega} \\mathbf{U}) = \\frac{1}{2}\\left( \\boldsymbol{\\Omega}\\mathbf{U} - (\\boldsymbol{\\Omega}\\mathbf{U})^\\mathsf{T} \\right) = \\frac{1}{2}\\left( \\boldsymbol{\\Omega}\\mathbf{U} - \\mathbf{U}^\\mathsf{T}\\boldsymbol{\\Omega}^\\mathsf{T} \\right) $$\n使用 $ \\mathbf{U}^\\mathsf{T} = \\mathbf{U} $ 和 $ \\boldsymbol{\\Omega}^\\mathsf{T} = -\\boldsymbol{\\Omega} $，这变为：\n$$ \\mathrm{skew}(\\boldsymbol{\\Omega} \\mathbf{U}) = \\frac{1}{2}\\left( \\boldsymbol{\\Omega}\\mathbf{U} + \\mathbf{U}\\boldsymbol{\\Omega} \\right) $$\n因此，我们得到第一个线性矩阵方程，一个关于 $ \\boldsymbol{\\Omega} $ 的连续 Sylvester（或 Lyapunov）方程：\n$$ 2\\,\\mathrm{skew}(\\mathbf{L}) = \\boldsymbol{\\Omega}\\mathbf{U} + \\mathbf{U}\\boldsymbol{\\Omega} $$\n一旦求出 $ \\boldsymbol{\\Omega} $，$ \\mathrm{d}\\mathbf{U} $ 就可以立即从 $ \\mathbf{L} = \\boldsymbol{\\Omega} \\mathbf{U} + \\mathrm{d}\\mathbf{U} $ 计算得出：\n$$ \\mathrm{d}\\mathbf{U} = \\mathbf{L} - \\boldsymbol{\\Omega}\\mathbf{U} $$\n该系统构成了所需的线性矩阵方程。或者，也可以从 $ \\mathbf{U}^2 = \\mathbf{F}^\\mathsf{T}\\mathbf{F} $ 出发，这将直接得出一个关于 $ \\mathrm{d}\\mathbf{U} $ 的 Sylvester 方程。两种方法是一致的，并会得到相同的解。\n\n### 第 2 部分：稳健的基于 SVD 的计算算法\n\n为了稳健地求解这些方程，特别是在奇异值近乎重复或为零的情况下，我们将其投影到 $ \\mathbf{U} $ 的特征基上。$ \\mathbf{F} $ 的奇异值分解 (SVD) 为 $ \\mathbf{F} = \\bar{\\mathbf{U}} \\boldsymbol{\\Sigma} \\mathbf{V}^\\mathsf{T} $，其中 $ \\boldsymbol{\\Sigma} = \\mathrm{diag}(\\sigma_1, \\sigma_2, \\sigma_3) $。极分解因子与 SVD 因子通过 $ \\mathbf{R} = \\bar{\\mathbf{U}} \\mathbf{V}^\\mathsf{T} $ 和 $ \\mathbf{U} = \\mathbf{V} \\boldsymbol{\\Sigma} \\mathbf{V}^\\mathsf{T} $ 相关。$ \\mathbf{V} $ 的列是 $ \\mathbf{U} $ 的特征向量。\n\n为确保 $ \\det\\mathbf{R} = 1 $，我们采用超弹性力学的标准程序，其中 $ \\det\\mathbf{F}>0 $。如果 SVD 算法得出 $ \\det(\\bar{\\mathbf{U}}\\mathbf{V}^\\mathsf{T}) = -1 $，我们会调整其中一个正交矩阵。一个常见的稳定选择是翻转 $ \\bar{\\mathbf{U}} $ 中对应最小奇异值的列的符号。然而，一个更简单且更常见的方法是通过定义 $\\mathbf{R} = \\bar{\\mathbf{U}} \\mathbf{J} \\mathbf{V}^\\mathsf{T}$ 来强制 $ \\det \\mathbf{R} = 1 $，其中 $\\mathbf{J} = \\mathrm{diag}(1, 1, \\det(\\bar{\\mathbf{U}}\\mathbf{V}^\\mathsf{T}))$。为简洁起见，我们重新定义 $ \\bar{\\mathbf{U}} \\leftarrow \\bar{\\mathbf{U}}\\mathbf{J} $，使得 $ \\mathbf{R} = \\bar{\\mathbf{U}}\\mathbf{V}^\\mathsf{T} $ 的行列式始终为 $ +1 $。\n\n让我们将方程变换到由 $ \\mathbf{V} $ 定义的 $ \\mathbf{U} $ 的特征基中。令 $ \\hat{(\\cdot)} = \\mathbf{V}^\\mathsf{T} (\\cdot) \\mathbf{V} $。方程 $ 2\\,\\mathrm{skew}(\\mathbf{L}) = \\boldsymbol{\\Omega}\\mathbf{U} + \\mathbf{U}\\boldsymbol{\\Omega} $ 变为：\n$$ 2\\,\\mathrm{skew}(\\hat{\\mathbf{L}}) = \\hat{\\boldsymbol{\\Omega}}\\boldsymbol{\\Sigma} + \\boldsymbol{\\Sigma}\\hat{\\boldsymbol{\\Omega}} $$\n其中 $ \\hat{\\mathbf{L}} = \\mathbf{V}^\\mathsf{T} \\mathbf{R}^\\mathsf{T} \\mathrm{d}\\mathbf{F} \\mathbf{V} = (\\mathbf{R}\\mathbf{V})^\\mathsf{T} \\mathrm{d}\\mathbf{F} \\mathbf{V} = \\bar{\\mathbf{U}}^\\mathsf{T} \\mathrm{d}\\mathbf{F} \\mathbf{V} $。我们用 $ \\mathbf{M} $ 表示这个矩阵。\n以分量形式表示，对于 $ i,j \\in \\{1,2,3\\} $：\n$$ 2\\,\\mathrm{skew}(M)_{ij} = \\hat{\\Omega}_{ij}\\sigma_j + \\sigma_i\\hat{\\Omega}_{ij} = (\\sigma_i + \\sigma_j)\\hat{\\Omega}_{ij} $$\n$$ M_{ij} - M_{ji} = (\\sigma_i + \\sigma_j)\\hat{\\Omega}_{ij} $$\n这给出了 $ \\hat{\\Omega}_{ij} $ 的分量形式解：\n$$ \\hat{\\Omega}_{ij} = \\frac{M_{ij} - M_{ji}}{\\sigma_i + \\sigma_j} $$\n这个公式是稳健的，因为只要两个奇异值不都为零，分母 $ \\sigma_i + \\sigma_j $ 就非零，这对于任何物理上有意义的形变都是成立的。该形式能够优雅地处理奇异值重复的情况（$ \\sigma_i = \\sigma_j $），而在这种情况下，分母中包含 $ (\\sigma_j - \\sigma_i) $ 的替代公式将会失效。\n\n现在我们求解 $ \\mathrm{d}\\mathbf{U} $。从 $ \\mathrm{d}\\mathbf{U} = \\mathbf{L} - \\boldsymbol{\\Omega}\\mathbf{U} $ 出发，我们变换到特征基：\n$$ \\hat{\\mathrm{d}\\mathbf{U}} = \\hat{\\mathbf{L}} - \\hat{\\boldsymbol{\\Omega}}\\boldsymbol{\\Sigma} = \\mathbf{M} - \\hat{\\boldsymbol{\\Omega}}\\boldsymbol{\\Sigma} $$\n分量形式为：\n$$ (\\hat{\\mathrm{d}\\mathbf{U}})_{ij} = M_{ij} - \\hat{\\Omega}_{ij}\\sigma_j = M_{ij} - \\frac{M_{ij} - M_{ji}}{\\sigma_i + \\sigma_j} \\sigma_j $$\n$$ (\\hat{\\mathrm{d}\\mathbf{U}})_{ij} = \\frac{M_{ij}(\\sigma_i + \\sigma_j) - (M_{ij} - M_{ji})\\sigma_j}{\\sigma_i + \\sigma_j} = \\frac{M_{ij}\\sigma_i + M_{ji}\\sigma_j}{\\sigma_i + \\sigma_j} $$\n这个公式也是稳健的。在计算实现中，当 $ \\sigma_i + \\sigma_j $ 接近于零时（表示一个高度退化的状态），相应的分量可以设置为零，因为它们将对应于不确定的形变模式。\n\n算法如下：\n1.  给定 $ \\mathbf{F} $ 和 $ \\mathrm{d}\\mathbf{F} $，计算 $ \\mathbf{F} $ 的 SVD 分解 $ \\mathbf{F} = \\bar{\\mathbf{U}} \\boldsymbol{\\Sigma} \\mathbf{V}^\\mathsf{T} $。\n2.  调整 $ \\bar{\\mathbf{U}} $ 以确保 $ \\det(\\bar{\\mathbf{U}}\\mathbf{V}^\\mathsf{T}) = 1 $。例如，如果 $ \\det(\\bar{\\mathbf{U}})\\det(\\mathbf{V}) = -1 $，则将 $ \\bar{\\mathbf{U}} $ 的最后一列乘以 $ -1 $。\n3.  计算 $ \\mathbf{M} = \\bar{\\mathbf{U}}^\\mathsf{T} \\mathrm{d}\\mathbf{F} \\mathbf{V} $。\n4.  使用上述谱公式计算 $ \\hat{\\mathrm{d}\\mathbf{U}} $ 和 $ \\hat{\\boldsymbol{\\Omega}} $ 的分量，为分母设置一个小的容差以处理接近零时的潜在浮点问题。\n5.  变换回原始基：$ \\mathrm{d}\\mathbf{U} = \\mathbf{V} \\hat{\\mathrm{d}\\mathbf{U}} \\mathbf{V}^\\mathsf{T} $ 和 $ \\boldsymbol{\\Omega} = \\mathbf{V} \\hat{\\boldsymbol{\\Omega}} \\mathbf{V}^\\mathsf{T} $。\n\n### 第 3 部分：算法一致切线\n\n第一 Piola-Kirchhoff 应力为 $ \\mathbf{P}(\\mathbf{F}) = \\mathbf{R} \\, \\mathbf{S}(\\mathbf{U}) $，其中 $ \\mathbf{S}(\\mathbf{U}) = \\partial W/\\partial \\mathbf{U} $。算法一致切线是其 Fréchet 导数 $ \\mathbb{A}[\\mathrm{d}\\mathbf{F}] = \\mathrm{d}\\mathbf{P}[\\mathrm{d}\\mathbf{F}] $。应用乘法法则：\n$$ \\mathrm{d}\\mathbf{P} = \\mathrm{d}\\mathbf{R} \\, \\mathbf{S} + \\mathbf{R} \\, \\mathrm{d}\\mathbf{S} $$\n使用 $ \\mathrm{d}\\mathbf{R} = \\mathbf{R}\\boldsymbol{\\Omega} $ 和 $ \\mathrm{d}\\mathbf{S} = (\\partial \\mathbf{S}/\\partial \\mathbf{U})[\\mathrm{d}\\mathbf{U}] = (\\partial^2 W/\\partial \\mathbf{U}\\partial \\mathbf{U})[\\mathrm{d}\\mathbf{U}] =: \\mathbb{C}^\\mathbf{U}[\\mathrm{d}\\mathbf{U}] $ 的链式法则，我们得到：\n$$ \\mathbb{A}[\\mathrm{d}\\mathbf{F}] = \\mathbf{R}\\boldsymbol{\\Omega}\\mathbf{S} + \\mathbf{R}\\,\\mathbb{C}^\\mathbf{U}[\\mathrm{d}\\mathbf{U}] $$\n对于给定的 Neo-Hookean 能量泛函 $ W(\\mathbf{U}) = \\frac{\\mu}{2} (\\mathrm{tr}(\\mathbf{U}^2) - 3) - \\mu \\ln J + \\frac{\\lambda}{2} (\\ln J)^2 $，其中 $ J = \\det\\mathbf{U} $，我们求出应力 $ \\mathbf{S} $ 及其导数 $ \\mathbb{C}^\\mathbf{U}[\\mathrm{d}\\mathbf{U}] $。\n迹项的导数是 $ \\partial(\\mathrm{tr}(\\mathbf{U}^2))/\\partial \\mathbf{U} = 2\\mathbf{U} $。体积项的导数是 $ \\partial(\\ln J)/\\partial \\mathbf{U} = J^{-1} (\\partial J/\\partial \\mathbf{U}) = J^{-1} (J \\mathbf{U}^{-\\mathsf{T}}) = \\mathbf{U}^{-1} $。\n因此，对称应力张量 $ \\mathbf{S} $ 为：\n$$ \\mathbf{S} = \\frac{\\partial W}{\\partial \\mathbf{U}} = \\mu\\mathbf{U} - \\mu J^{-1}J\\mathbf{U}^{-1} + \\lambda (\\ln J) J^{-1}J\\mathbf{U}^{-1} = \\mu\\mathbf{U} + (\\lambda \\ln J - \\mu)\\mathbf{U}^{-1} $$\n现在我们计算其导数 $ \\mathrm{d}\\mathbf{S} = \\mathbb{C}^\\mathbf{U}[\\mathrm{d}\\mathbf{U}] $：\n$$ \\mathrm{d}\\mathbf{S} = \\mu\\,\\mathrm{d}\\mathbf{U} + \\mathrm{d}(\\lambda \\ln J - \\mu)\\,\\mathbf{U}^{-1} + (\\lambda \\ln J - \\mu)\\,\\mathrm{d}(\\mathbf{U}^{-1}) $$\n我们需要导数 $ \\mathrm{d}(\\ln J) = J^{-1}\\mathrm{d}J = \\mathrm{tr}(\\mathbf{U}^{-1}\\mathrm{d}\\mathbf{U}) $ 和 $ \\mathrm{d}(\\mathbf{U}^{-1}) = -\\mathbf{U}^{-1}\\mathrm{d}\\mathbf{U}\\mathbf{U}^{-1} $。\n将这些代入，得到材料切线算子 $ \\mathbb{C}^\\mathbf{U} $ 的作用：\n$$ \\mathbb{C}^\\mathbf{U}[\\mathrm{d}\\mathbf{U}] = \\mu\\,\\mathrm{d}\\mathbf{U} + \\lambda\\,\\mathrm{tr}(\\mathbf{U}^{-1}\\mathrm{d}\\mathbf{U})\\,\\mathbf{U}^{-1} - (\\lambda \\ln J - \\mu)\\,\\mathbf{U}^{-1}\\mathrm{d}\\mathbf{U}\\mathbf{U}^{-1} $$\n将 $ \\mathbf{S} $ 和 $ \\mathbb{C}^\\mathbf{U}[\\mathrm{d}\\mathbf{U}] $ 代入 $ \\mathrm{d}\\mathbf{P} $ 的表达式，即可得到算法一致切线作用的最终表达式。所有需要的量现在都已用 $ \\mathbf{U} $、$ \\mathrm{d}\\mathbf{U} $ 和 $ \\boldsymbol{\\Omega} $ 定义。",
            "answer": "```python\nimport numpy as np\n\ndef rodrigues_formula(axis, angle):\n    \"\"\"Computes a rotation matrix using Rodrigues' formula.\"\"\"\n    axis = axis / np.linalg.norm(axis)\n    K = np.array([\n        [0, -axis[2], axis[1]],\n        [axis[2], 0, -axis[0]],\n        [-axis[1], axis[0], 0]\n    ])\n    R = np.eye(3) + np.sin(angle) * K + (1 - np.cos(angle)) * np.dot(K, K)\n    return R\n\ndef get_polar_decomposition(F):\n    \"\"\"Computes polar decomposition F = R U ensuring det(R) = 1.\"\"\"\n    ubar, s_diag, v_t = np.linalg.svd(F)\n    v = v_t.T\n    \n    # Ensure R has determinant +1, which is standard for hyperelasticity\n    det_check = np.linalg.det(ubar) * np.linalg.det(v)\n    if det_check  0:\n        ubar[:, -1] *= -1\n\n    R = ubar @ v.T\n    U = v @ np.diag(s_diag) @ v.T\n    return R, U, ubar, np.diag(s_diag), v\n\ndef solve_one_case(F_in, dF_in, lamb, mu):\n    \"\"\"Computes analytical derivatives and compares with finite differences.\"\"\"\n    \n    # --- Analytical derivatives (algo) ---\n    ubar, s_diag, v_t = np.linalg.svd(F_in)\n    v = v_t.T\n    s = np.diag(s_diag)\n    \n    det_check = np.linalg.det(ubar) * np.linalg.det(v)\n    if det_check  0:\n        ubar[:, -1] *= -1\n\n    R_algo = ubar @ v.T\n    U_algo = v @ s @ v.T\n\n    # Compute M matrix\n    M = ubar.T @ dF_in @ v\n    \n    # Compute derivatives in the spectral basis\n    d_hat_U = np.zeros((3, 3))\n    omega_hat = np.zeros((3, 3))\n    \n    s_vec = np.diag(s)\n    \n    for i in range(3):\n        for j in range(3):\n            denom = s_vec[i] + s_vec[j]\n            if np.abs(denom) > 1e-30:\n                d_hat_U[i, j] = (s_vec[i] * M[i, j] + s_vec[j] * M[j, i]) / denom\n                omega_hat[i, j] = (M[i, j] - M[j, i]) / denom\n\n    # Transform back to spatial basis\n    dU_algo = v @ d_hat_U @ v.T\n    Omega_algo = v @ omega_hat @ v.T\n\n    # --- Compute stress and tangent action (algo) ---\n    U_inv = np.linalg.inv(U_algo)\n    J = np.linalg.det(U_algo)\n    \n    # First Piola-Kirchhoff stress P = R*S\n    S = mu * U_algo + (lamb * np.log(J) - mu) * U_inv\n    P_algo = R_algo @ S\n    \n    # Algorithmic tangent action A[dF] = dP\n    tr_Uinv_dU = np.trace(U_inv @ dU_algo)\n    dS = mu * dU_algo + lamb * tr_Uinv_dU * U_inv - (lamb * np.log(J) - mu) * (U_inv @ dU_algo @ U_inv)\n    \n    dP_algo = R_algo @ Omega_algo @ S + R_algo @ dS\n\n    return dU_algo, Omega_algo, P_algo, dP_algo\n\ndef check_with_fd(F_in, dF_in, lamb, mu, eps):\n    \"\"\"Computes derivatives using central finite differences.\"\"\"\n    \n    def get_kinematics_and_stress(F):\n        R, U, _, _, _ = get_polar_decomposition(F)\n        if np.linalg.det(U)  1e-12: # Handle near singular case\n            P = np.zeros((3,3)) # Physically stress should be zero\n        else:\n            U_inv = np.linalg.inv(U)\n            J = np.linalg.det(U)\n            S = mu * U + (lamb * np.log(J) - mu) * U_inv\n            P = R @ S\n        return R, U, P\n\n    R_center, U_center, P_center = get_kinematics_and_stress(F_in)\n\n    F_p = F_in + eps * dF_in\n    F_m = F_in - eps * dF_in\n    \n    R_p, U_p, P_p = get_kinematics_and_stress(F_p)\n    R_m, U_m, P_m = get_kinematics_and_stress(F_m)\n\n    dU_fd = (U_p - U_m) / (2 * eps)\n    dP_fd = (P_p - P_m) / (2 * eps)\n    dR_fd = (R_p - R_m) / (2 * eps)\n    \n    # Omega_fd = skew(R_center.T @ dR_fd)\n    omega_mat = R_center.T @ dR_fd\n    Omega_fd = 0.5 * (omega_mat - omega_mat.T)\n    \n    return dU_fd, Omega_fd, dP_fd\n\n\ndef solve():\n    lamb = 20.0\n    mu = 10.0\n    eps = 1e-8\n    \n    # Case 1\n    F1 = np.array([[1.2, 0.3, 0.1], [0.2, 0.9, -0.4], [0.0, 0.5, 1.1]])\n    dF1 = np.array([[0.01, -0.02, 0.03], [-0.01, 0.02, 0.01], [0.0, -0.03, 0.04]])\n\n    # Case 2\n    theta = 0.7\n    axis_a = np.array([1, 1, 1]) / np.sqrt(3)\n    R_theta = rodrigues_formula(axis_a, theta)\n    diag_F2 = np.diag([2.5, 1e-6, 0.5])\n    F2 = R_theta @ diag_F2\n    dF2 = np.array([[0.02, 0.01, -0.01], [-0.03, 0.04, 0.02], [0.01, -0.02, 0.03]])\n\n    # Case 3\n    phi = 0.9\n    psi = -0.4\n    Rz_phi = np.array([[np.cos(phi), -np.sin(phi), 0], [np.sin(phi), np.cos(phi), 0], [0, 0, 1]])\n    Rx_psi = np.array([[1, 0, 0], [0, np.cos(psi), -np.sin(psi)], [0, np.sin(psi), np.cos(psi)]])\n    diag_F3 = np.diag([1.0, 1.0 + 1e-8, 0.7])\n    F3 = Rz_phi @ diag_F3 @ Rx_psi.T\n    dF3 = np.array([[-0.015, 0.005, 0.01], [0.025, -0.02, 0.005], [-0.005, 0.015, -0.01]])\n    \n    test_cases = [ (F1, dF1), (F2, dF2), (F3, dF3) ]\n    \n    results = []\n    \n    for F_case, dF_case in test_cases:\n        dU_algo, Omega_algo, _, dP_algo = solve_one_case(F_case, dF_case, lamb, mu)\n        dU_fd, Omega_fd, dP_fd = check_with_fd(F_case, dF_case, lamb, mu, eps)\n\n        norm_dU_fd = np.linalg.norm(dU_fd, 'fro')\n        err_U = np.linalg.norm(dU_algo - dU_fd, 'fro') / max(1e-30, norm_dU_fd)\n        results.append(err_U)\n        \n        norm_Omega_fd = np.linalg.norm(Omega_fd, 'fro')\n        err_Omega = np.linalg.norm(Omega_algo - Omega_fd, 'fro') / max(1e-30, norm_Omega_fd)\n        results.append(err_Omega)\n        \n        norm_dP_fd = np.linalg.norm(dP_fd, 'fro')\n        err_A = np.linalg.norm(dP_algo - dP_fd, 'fro') / max(1e-30, norm_dP_fd)\n        results.append(err_A)\n\n    print(f\"[{','.join([f'{r:.6e}' for r in results])}]\")\n\nsolve()\n\n```"
        }
    ]
}