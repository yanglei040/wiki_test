{
    "hands_on_practices": [
        {
            "introduction": "在非线性分析中，标准的求解器在极限点附近往往会失效。为了追踪包含贯穿（snap-through）和回弹（snap-back）的复杂平衡路径，路径跟踪算法，特别是弧长法，是不可或缺的工具。本实践通过一个简洁的代数方程，直观地展示了荷载控制、位移控制和弧长控制这三种策略的优缺点，揭示了为何弧长法是捕捉失稳现象的关键 。",
            "id": "3600849",
            "problem": "考虑对由单个代数方程隐式定义的单参数平衡族中的非线性平衡路径进行降阶追踪\n$$\nF(u,\\lambda) = \\left(\\frac{u}{a}\\right)^2 + \\left(\\frac{\\lambda}{b}\\right)^2 - 1 = 0,\n$$\n其中 $u$ 是一个广义位移，$\\lambda$ 是一个广义载荷因子，$a0$ 和 $b0$ 是给定的形状参数。该隐式曲线既有水平切线（载荷极限点，在控制 $\\lambda$ 时与贯穿相关）也有垂直切线（位移极限点，在控制 $u$ 时与回弹相关）。问题在于实现一个带有第二个约束方程 $g(u,\\lambda)=0$ 的增广牛顿求解器，以强制执行不同的控制策略，并评估它们穿越极限点段的能力。此问题中的所有量均为无量纲。\n\n从基本的延拓原理出发：平衡条件是 $F(u,\\lambda)=0$，延拓通过一个标量控制约束 $g(u,\\lambda)=0$ 来对其进行增广，从而在每一步通过牛顿法求解一个 $2\\times 2$ 系统来确定未知向量 $(u,\\lambda)$。设 $F$ 的雅可比矩阵为梯度\n$$\n\\nabla F(u,\\lambda) = \\left[\\frac{\\partial F}{\\partial u}, \\frac{\\partial F}{\\partial \\lambda}\\right] = \\left[\\frac{2u}{a^2}, \\frac{2\\lambda}{b^2}\\right].\n$$\n实现以下三种控制约束 $g(u,\\lambda)$ 的选择：\n\n- 载荷控制：$g(u,\\lambda) = \\lambda - \\lambda_{\\text{target}}$，其中 $\\lambda$ 的目标增量是预先规定的。\n- 位移控制：$g(u,\\lambda) = u - u_{\\text{target}}$，其中 $u$ 的目标增量是预先规定的。\n- 混合控制（带度量加权的球面弧长）：$g(u,\\lambda) = (u - u_n)^2 + \\psi\\,(\\lambda - \\lambda_n)^2 - \\Delta s^2$，其中 $(u_n,\\lambda_n)$ 是上一步收敛的状态，$\\psi  0$ 是一个加权因子，$\\Delta s  0$ 是弧长步长。对于弧长预测，使用一个满足 $\\nabla F \\cdot t = 0$ 的单位切向量 $t = [t_u,t_\\lambda]$，并根据度量 $\\text{diag}(1,\\psi)$ 进行归一化。\n\n你的程序必须为增广系统实现一个通用的 $2\\times 2$ 牛顿求解器\n$$\n\\begin{bmatrix}\nF(u,\\lambda) \\\\\ng(u,\\lambda)\n\\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix},\n$$\n并对每种 $g$ 的选择使用相应的雅可比矩阵。\n\n使用 $a=1.0$ 和 $b=0.8$，将求解器应用于以下测试套件。所有起始点 $(u_0,\\lambda_0)$ 都是平衡曲线 $F=0$ 上的精确点。\n\n- 测试 A（载荷控制，预期在载荷极限点失败）：从 $(u_0,\\lambda_0) = (0.866025403784,\\, 0.4)$ 开始，以固定的载荷增量 $\\Delta \\lambda = +0.05$ 执行 $N=10$ 步。在每一步 $k$，设置 $\\lambda_{\\text{target}} = \\lambda_{k-1} + \\Delta \\lambda$ 并求解 $(u_k,\\lambda_k)$。当且仅当所有 $N$ 步都收敛到增广系统的解时，声明测试成功；否则声明失败。\n\n- 测试 B（位移控制，预期在位移极限点失败）：从 $(u_0,\\lambda_0) = \\left(0.5,\\, 0.8\\sqrt{1-0.5^2}\\right) = \\left(0.5,\\, 0.692820323027551\\right)$ 开始，以固定的位移增量 $\\Delta u = +0.07$ 执行 $N=10$ 步。在每一步 $k$，设置 $u_{\\text{target}} = u_{k-1} + \\Delta u$ 并求解 $(u_k,\\lambda_k)$。当且仅当所有 $N$ 步都收敛时，声明测试成功；否则声明失败。\n\n- 测试 C（通过球面弧长进行混合控制，预期能穿越贯穿和回弹段）：从 $(u_0,\\lambda_0) = \\left(0.707106781186548,\\,-0.565685424949238\\right)$ 开始，取 $\\psi = 1.0$，使用 $\\Delta s = 0.1$ 和最多 $N_{\\max} = 120$ 步。使用一个与 $\\nabla F$ 正交并在度量 $\\text{diag}(1,\\psi)$ 中归一化的预测切向量 $t$，其符号的选择应保持与前一切向量的连续性。在每一步中，先进行预测，然后应用牛顿法对带有弧长约束 $g$ 的增广系统进行校正。如果在至少 $N_{\\min} = 40$ 步后，当前点 $(u_k,\\lambda_k)$ 返回到与起始点 $(u_0,\\lambda_0)$ 的欧几里得距离小于 $\\varepsilon_{\\text{close}} = 10^{-2}$ 的范围内，则终止并声明成功；否则声明失败。\n\n- 测试 D（载荷控制，沿单调段的顺利路径）：从与测试 B 相同的点 $(u_0,\\lambda_0) = \\left(0.5,\\, 0.692820323027551\\right)$ 开始，以固定的载荷减量 $\\Delta \\lambda = -0.05$ 执行 $N=10$ 步。当且仅当所有 $N$ 步都收敛时，声明测试成功。\n\n对于牛顿法，每次校正最多使用 $50$ 次迭代，收敛容差为增广残差向量欧几里得范数的 $10^{-10}$。将任何在迭代限制内未能收敛、任何奇异雅可比求解或任何数值溢出都视为失败的步骤。\n\n你的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，顺序为 $[\\text{A},\\text{B},\\text{C},\\text{D}]$，其中每个条目都是一个布尔值，指示该测试的成功状态。例如，如果测试 A 和 B 失败，测试 C 成功，测试 D 成功，则输出应为 \"[False,False,True,True]\"。",
            "solution": "该问题要求实现和比较三种标准的延拓（路径跟踪）策略，用于追踪一个非线性系统的平衡路径。该系统由单个代数方程 $F(u,\\lambda)=0$ 定义，其中 $u$ 是广义位移，$\\lambda$ 是载荷参数。具体的平衡路径是一个椭圆，由下式给出\n$$\nF(u,\\lambda) = \\left(\\frac{u}{a}\\right)^2 + \\left(\\frac{\\lambda}{b}\\right)^2 - 1 = 0\n$$\n其中 $a$ 和 $b$ 是给定的正参数。该曲线具有两个载荷极限点（水平切线），位于 $(u,\\lambda) = (0, \\pm b)$，以及两个位移极限点（垂直切线），位于 $(u,\\lambda) = (\\pm a, 0)$，它们分别与贯穿和回弹失稳相关。\n\n延拓方法的核心原理是用一个控制约束 $g(u,\\lambda)=0$ 来增广平衡方程 $F(u,\\lambda)=0$。这为两个未知数 $(u, \\lambda)$ 创建了一个包含两个方程的系统：\n$$\n\\mathbf{R}(u,\\lambda) = \\begin{bmatrix} F(u,\\lambda) \\\\ g(u,\\lambda) \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}\n$$\n在路径跟踪过程的每一步，都使用牛顿-拉夫逊迭代法来求解该系统。对于迭代 $i$，更新规则为：\n$$\n\\begin{bmatrix} u_{i+1} \\\\ \\lambda_{i+1} \\end{bmatrix} = \\begin{bmatrix} u_i \\\\ \\lambda_i \\end{bmatrix} - \\mathbf{J}^{-1}(u_i, \\lambda_i) \\mathbf{R}(u_i, \\lambda_i)\n$$\n其中 $\\mathbf{J}(u,\\lambda)$ 是 $2 \\times 2$ 的增广雅可比矩阵：\n$$\n\\mathbf{J}(u,\\lambda) = \\frac{\\partial \\mathbf{R}}{\\partial (u, \\lambda)} = \\begin{bmatrix}\n\\frac{\\partial F}{\\partial u}  \\frac{\\partial F}{\\partial \\lambda} \\\\\n\\frac{\\partial g}{\\partial u}  \\frac{\\partial g}{\\partial \\lambda}\n\\end{bmatrix}\n$$\n平衡函数 $F$ 的梯度明确给出为 $\\nabla F(u,\\lambda) = \\left[\\frac{2u}{a^2}, \\frac{2\\lambda}{b^2}\\right]$。程序实现了一个通用的牛顿求解器，它以系统函数 $\\mathbf{R}$ 及其雅可比矩阵 $\\mathbf{J}$ 作为输入，然后在每个测试案例的分析的每一步中求解 $(u, \\lambda)$。\n\n三种控制策略的实现如下：\n1.  **载荷控制**：约束为 $g(u,\\lambda) = \\lambda - \\lambda_{\\text{target}} = 0$。这在每一步都固定了载荷参数。该约束的梯度为 $\\nabla g = [0, 1]$。增广雅可比矩阵为：\n    $$\n    \\mathbf{J}_{\\text{load}} = \\begin{bmatrix} \\frac{2u}{a^2}  \\frac{2\\lambda}{b^2} \\\\ 0  1 \\end{bmatrix}\n    $$\n    当其行列式 $\\frac{2u}{a^2}$ 为零时，该矩阵变为奇异，这发生在 $u=0$ 时。这对应于一个载荷极限点（贯穿），此时平衡路径有一条水平切线。在此类点上，载荷控制会失败。测试 A 就是为了遇到这种失败而设计的。\n\n2.  **位移控制**：约束为 $g(u,\\lambda) = u - u_{\\text{target}} = 0$，这固定了位移。该约束的梯度为 $\\nabla g = [1, 0]$。增广雅可比矩阵为：\n    $$\n    \\mathbf{J}_{\\text{disp}} = \\begin{bmatrix} \\frac{2u}{a^2}  \\frac{2\\lambda}{b^2} \\\\ 1  0 \\end{bmatrix}\n    $$\n    当其行列式 $-\\frac{2\\lambda}{b^2}$ 为零时，该矩阵变为奇异，这发生在 $\\lambda=0$ 时。这对应于一个位移极限点（回弹），此时路径有一条垂直切线。位移控制在此类点上会失败。测试 B 就是为了遇到这种失败而设计的。\n\n3.  **混合（弧长）控制**：该方法将步长约束在一个以先前收敛点 $(u_n, \\lambda_n)$ 为中心、半径为 $\\Delta s$ 的球（在此二维情况下为圆）上。约束为 $g(u,\\lambda) = (u - u_n)^2 + \\psi(\\lambda - \\lambda_n)^2 - \\Delta s^2 = 0$。该约束的梯度为 $\\nabla g = [2(u-u_n), 2\\psi(\\lambda-\\lambda_n)]$。增广雅可比矩阵为：\n    $$\n    \\mathbf{J}_{\\text{arc}} = \\begin{bmatrix} \\frac{2u}{a^2}  \\frac{2\\lambda}{b^2} \\\\ 2(u-u_n)  2\\psi(\\lambda-\\lambda_n) \\end{bmatrix}\n    $$\n    该雅可比矩阵在载荷和位移极限点通常都是非奇异的，这使得弧长控制成为一种用于穿越复杂平衡路径的稳健方法。此方法使用预测-校正格式。\n    - **预测**：通过沿当前点 $(u_n, \\lambda_n)$ 处曲线的切线方向移动距离 $\\Delta s$ 来找到下一个点的初始猜测值。切向量 $\\mathbf{t} = [t_u, t_\\lambda]$ 与梯度 $\\nabla F$ 正交，即 $\\nabla F \\cdot \\mathbf{t} = 0$。一个有效的（未归一化的）切向量是 $\\mathbf{t}' = [-\\frac{\\partial F}{\\partial \\lambda}, \\frac{\\partial F}{\\partial u}]$。然后根据指定的度量对该向量进行归一化：$\\mathbf{t} = \\mathbf{t}' / \\sqrt{t_u'^2 + \\psi t_\\lambda'^2}$。为确保路径连续追踪而不反向，选择切向量的符号使得对于步长 $k0$，$\\mathbf{t}_k \\cdot \\mathbf{t}_{k-1}  0$。对于第一步，选择符号以启动椭圆的逆时针遍历。预测点则为 $(u_p, \\lambda_p) = (u_n, \\lambda_n) + \\Delta s \\cdot \\mathbf{t}$。\n    - **校正**：使用牛顿求解器，以 $(u_p, \\lambda_p)$ 为初始猜测值，来找到平衡曲线 $F=0$ 和约束球面 $g=0$ 的交点。测试 C 使用此方法，并预期能成功追踪整个椭圆路径。\n\n测试 D 为载荷控制提供了一个“顺利路径”的场景，其中载荷增量远离任何极限点，展示了这种简单方法在平衡路径的单调段上的成功应用。\n\n所实现的程序定义了一个通用的牛顿求解器，然后为问题中描述的每个测试案例设置了四个函数。每个函数配置适当的控制约束，运行路径跟踪循环，并根据指定的标准报告成功或失败。最终输出汇总了所有四个测试的布尔结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Global parameters from the problem statement\nA = 1.0\nB = 0.8\nNEWTON_TOL = 1e-10\nNEWTON_MAX_ITER = 50\n\ndef F_func(u, lam, a, b):\n    \"\"\"The equilibrium equation F(u, lambda) = 0.\"\"\"\n    return (u / a)**2 + (lam / b)**2 - 1.0\n\ndef grad_F_func(u, lam, a, b):\n    \"\"\"The gradient of the equilibrium equation, [dF/du, dF/dlam].\"\"\"\n    return np.array([2.0 * u / a**2, 2.0 * lam / b**2])\n\ndef newton_solver(system_func, jacobian_func, initial_guess):\n    \"\"\"\n    Solves a 2x2 system of nonlinear equations using Newton's method.\n\n    Args:\n        system_func: A callable F(u, lam) that returns the residual vector [F, g].\n        jacobian_func: A callable J(u, lam) that returns the Jacobian matrix.\n        initial_guess: A tuple or array (u, lam) for the initial guess.\n\n    Returns:\n        A tuple ((u, lam), success_flag), where (u, lam) is the solution\n        and success_flag is a boolean.\n    \"\"\"\n    x_k = np.array(initial_guess, dtype=float)\n\n    for _ in range(NEWTON_MAX_ITER):\n        try:\n            # Calculate residual and check for convergence\n            R = system_func(x_k[0], x_k[1])\n            norm_R = np.linalg.norm(R)\n\n            if norm_R  NEWTON_TOL:\n                return x_k, True  # Converged successfully\n\n            # Calculate Jacobian and solve for the update\n            J = jacobian_func(x_k[0], x_k[1])\n            delta_x = np.linalg.solve(J, -R)\n            \n            x_k += delta_x\n\n            if np.any(np.isinf(x_k)) or np.any(np.isnan(x_k)):\n                return None, False # Numerical overflow detected\n\n        except np.linalg.LinAlgError:\n            return None, False  # Singular Jacobian matrix\n        except (ValueError, OverflowError):\n            return None, False  # Other numerical errors\n\n    return None, False  # Failed to converge within max iterations\n\ndef run_test_A():\n    \"\"\"Test A: Load control, expected failure at a load limit point.\"\"\"\n    u_k, lam_k = 0.866025403784, 0.4\n    delta_lam = 0.05\n    num_steps = 10\n\n    for _ in range(num_steps):\n        lam_target = lam_k + delta_lam\n        \n        def system(u, lam):\n            return np.array([F_func(u, lam, A, B), lam - lam_target])\n\n        def jacobian(u, lam):\n            grad_F = grad_F_func(u, lam, A, B)\n            return np.array([[grad_F[0], grad_F[1]], [0.0, 1.0]])\n        \n        initial_guess = np.array([u_k, lam_k])\n        solution, converged = newton_solver(system, jacobian, initial_guess)\n\n        if not converged:\n            return False\n\n        u_k, lam_k = solution\n\n    return True\n\ndef run_test_B():\n    \"\"\"Test B: Displacement control, expected failure at a displacement limit point.\"\"\"\n    u_k, lam_k = 0.5, 0.692820323027551\n    delta_u = 0.07\n    num_steps = 10\n    \n    for _ in range(num_steps):\n        u_target = u_k + delta_u\n\n        def system(u, lam):\n            return np.array([F_func(u, lam, A, B), u - u_target])\n\n        def jacobian(u, lam):\n            grad_F = grad_F_func(u, lam, A, B)\n            return np.array([[grad_F[0], grad_F[1]], [1.0, 0.0]])\n            \n        initial_guess = np.array([u_k, lam_k])\n        solution, converged = newton_solver(system, jacobian, initial_guess)\n\n        if not converged:\n            return False\n\n        u_k, lam_k = solution\n\n    return True\n\ndef run_test_C():\n    \"\"\"Test C: Mixed control (arc-length), expected to traverse the full path.\"\"\"\n    u_start, lam_start = 0.707106781186548, -0.565685424949238\n    u_n, lam_n = u_start, lam_start\n    psi = 1.0\n    ds = 0.1\n    n_max = 120\n    n_min = 40\n    eps_close = 1e-2\n\n    gradF_0 = grad_F_func(u_n, lam_n, A, B)\n    t_un_0 = np.array([-gradF_0[1], gradF_0[0]])\n    norm_t_0 = np.sqrt(t_un_0[0]**2 + psi * t_un_0[1]**2)\n    t_prev = t_un_0 / norm_t_0\n\n    for k in range(1, n_max + 1):\n        u_p, lam_p = (u_n, lam_n) + ds * t_prev\n\n        def system(u, lam):\n            return np.array([\n                F_func(u, lam, A, B),\n                (u - u_n)**2 + psi * (lam - lam_n)**2 - ds**2\n            ])\n\n        def jacobian(u, lam):\n            grad_F = grad_F_func(u, lam, A, B)\n            return np.array([\n                [grad_F[0], grad_F[1]],\n                [2.0 * (u - u_n), 2.0 * psi * (lam - lam_n)]\n            ])\n\n        solution, converged = newton_solver(system, jacobian, (u_p, lam_p))\n        \n        if not converged:\n            return False\n\n        u_n, lam_n = solution\n\n        if k >= n_min:\n            dist = np.sqrt((u_n - u_start)**2 + (lam_n - lam_start)**2)\n            if dist  eps_close:\n                return True\n\n        gradF_k = grad_F_func(u_n, lam_n, A, B)\n        t_un_k = np.array([-gradF_k[1], gradF_k[0]])\n        norm_t_k = np.sqrt(t_un_k[0]**2 + psi * t_un_k[1]**2)\n        if norm_t_k  1e-12: return False\n        \n        t_k = t_un_k / norm_t_k\n        \n        if np.dot(t_k, t_prev)  0:\n            t_k = -t_k\n        \n        t_prev = t_k\n        \n    return False\n\ndef run_test_D():\n    \"\"\"Test D: Load control, happy path along a monotonic segment.\"\"\"\n    u_k, lam_k = 0.5, 0.692820323027551\n    delta_lam = -0.05\n    num_steps = 10\n\n    for _ in range(num_steps):\n        lam_target = lam_k + delta_lam\n\n        def system(u, lam):\n            return np.array([F_func(u, lam, A, B), lam - lam_target])\n\n        def jacobian(u, lam):\n            grad_F = grad_F_func(u, lam, A, B)\n            return np.array([[grad_F[0], grad_F[1]], [0.0, 1.0]])\n        \n        initial_guess = np.array([u_k, lam_k])\n        solution, converged = newton_solver(system, jacobian, initial_guess)\n\n        if not converged:\n            return False\n\n        u_k, lam_k = solution\n\n    return True\n\ndef solve():\n    \"\"\"\n    Executes the test suite and prints the final results.\n    \"\"\"\n    test_cases_funcs = [\n        run_test_A,\n        run_test_B,\n        run_test_C,\n        run_test_D,\n    ]\n\n    results = []\n    for test_func in test_cases_funcs:\n        results.append(test_func())\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "将抽象的算法应用于具体物理问题，材料软化是结构失稳的常见根源。本实践要求您为一根具有损伤软化本构的拉杆实现一维有限元分析。此练习将引导您面对并解决材料软化建模中的一个关键数值挑战：网格依赖性，并学习如何通过引入断裂能进行正则化来获得客观的数值结果 。",
            "id": "3600892",
            "problem": "考虑一根长度为 $L$、横截面积为 $A$ 的一维拉杆，离散为 $N$ 个双节点线性有限元。该杆处于准静态，无体力，并在拉伸中经历损伤引起的软化。控制方程由虚功原理和准静态条件下的线性动量守恒导出。令 $u(x)$ 表示轴向位移，$\\varepsilon(x) = \\frac{du}{dx}$ 表示轴向应变，$\\sigma(x)$ 表示轴向应力。本构响应为拉伸状态下的可损伤线性弹性，由 $\\sigma = (1 - d) E \\varepsilon$ 给出，其中 $E$ 是杨氏模量，$d \\in [0,1)$ 是一个标量损伤变量，它随拉伸应变单调增加，在压缩时保持为零。损伤变量通过一个双线性峰后应力-应变本构来实现软化。\n\n拉伸状态下的双线性软化本构由三个应变水平 $0 \\le \\varepsilon \\le \\varepsilon_0 \\le \\varepsilon_1 \\le \\varepsilon_f$ 以及对应的应力 $\\sigma(\\varepsilon_0) = \\sigma_0$ 和 $\\sigma(\\varepsilon_1) = \\sigma_1$ 定义，其中 $\\sigma_1 = r_{\\sigma} \\sigma_0$ 且 $0  r_{\\sigma}  1$。应力-应变函数 $s(\\varepsilon)$ 为\n$$\ns(\\varepsilon) = \n\\begin{cases}\nE \\varepsilon,  0 \\le \\varepsilon \\le \\varepsilon_0, \\\\\n\\sigma_0 + \\dfrac{\\sigma_1 - \\sigma_0}{\\varepsilon_1 - \\varepsilon_0} \\left(\\varepsilon - \\varepsilon_0\\right),  \\varepsilon_0  \\varepsilon \\le \\varepsilon_1, \\\\\n\\sigma_1 \\dfrac{\\varepsilon_f - \\varepsilon}{\\varepsilon_f - \\varepsilon_1},  \\varepsilon_1  \\varepsilon \\le \\varepsilon_f, \\\\\n0,  \\varepsilon > \\varepsilon_f,\n\\end{cases}\n$$\n其中 $\\sigma_0 = E \\varepsilon_0$。损伤变量由 $s(\\varepsilon) = (1 - d) E \\varepsilon$ 隐式定义，即\n$$\nd(\\varepsilon) = 1 - \\frac{s(\\varepsilon)}{E \\varepsilon} \\quad \\text{对于 } \\varepsilon  0, \\quad d(\\varepsilon) = 0 \\text{ 对于 } \\varepsilon \\le 0,\n$$\n并且在加载过程中被强制为单调不减。\n\n对于位移控制，规定端点位移 $u(0) = 0$ 和 $u(L) = \\bar{u}$，通过组装全局刚度矩阵来求解内部节点位移，其中单元刚度为 $k_e = (1 - d_e) \\dfrac{E A}{h_e} \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix}$，$h_e$ 是单元长度，$d_e$ 是在当前应变下计算的单元损伤。$x=L$ 处的反力为 $P(\\bar{u})$，通过划分全局平衡方程 $K u = f$（其中 $f=0$）并施加本质边界条件得到。在载荷控制下，当载荷-位移响应的增量刚度为负时，即 $\\dfrac{dP}{d\\bar{u}}  0$ 时，会出现不稳定性（回弹）。\n\n为量化网格敏感性，考虑两种建模选项：\n- 局部损伤模型：软化参数 $\\varepsilon_f$ 与 $h_e$ 无关。\n- 正则化损伤模型：通过规定单位面积断裂能 $G_f$ 来强制能量耗散与网格无关，使得峰后应力-应变曲线下面积满足\n$$\nh_e \\int_{\\varepsilon_0}^{\\varepsilon_f} s(\\varepsilon)\\, d\\varepsilon = G_f,\n$$\n对于双线性本构，这意味着\n$$\nh_e \\left[ \\frac{\\sigma_0 + \\sigma_1}{2} (\\varepsilon_1 - \\varepsilon_0) + \\frac{\\sigma_1}{2} (\\varepsilon_f - \\varepsilon_1) \\right] = G_f,\n$$\n因此\n$$\n\\varepsilon_f = \\varepsilon_1 + \\frac{2}{\\sigma_1} \\left( \\frac{G_f}{h_e} - \\frac{\\sigma_0 + \\sigma_1}{2} (\\varepsilon_1 - \\varepsilon_0) \\right),\n$$\n前提是括号内的项为非负；否则将 $\\varepsilon_f$ 设置为略大于 $\\varepsilon_1$ 以避免不适定性。\n\n实现一个采用算子分裂的位移控制增量分析：在 $\\bar{u}$ 的每个增量步中，使用当前的损伤状态求解位移，更新应变，使用双线性本构更新损伤并强制其单调性，然后迭代直至收敛。计算载荷-位移曲线 $P(\\bar{u})$，通过检查离散斜率 $\\Delta P / \\Delta \\bar{u}$ 的符号来检测回弹，并使用数值积分（梯形法则）计算外力功 $W = \\int P(\\bar{u})\\, d\\bar{u}$。使用微小的非均匀性来引发局部化：在单个“缺陷”单元中，通过一个小的因子来减小 $\\varepsilon_0$ 和 $\\varepsilon_1$，同时保持 $r_{\\sigma}$ 不变。\n\n您的程序必须评估以下测试套件，所有量均采用国际单位制 (SI)，角度不适用。载荷以牛顿 (N) 表示，位移以米 (m) 表示，能量以牛顿·米 (N·m) 表示。返回四舍五入到六位小数的浮点值，以及作为 Python 字面量的布尔值。\n\n所有测试的通用参数：\n- $L = 1.0\\,\\mathrm{m}$,\n- $A = 1.0 \\times 10^{-4}\\,\\mathrm{m}^2$,\n- $E = 7.0 \\times 10^{10}\\,\\mathrm{Pa}$,\n- $\\varepsilon_0 = 0.002$,\n- $\\varepsilon_1 = 0.006$,\n- $r_{\\sigma} = 0.5$ 以使 $\\sigma_1 = r_{\\sigma} \\sigma_0$,\n- 缺陷单元索引为中间单元，该单元的 $\\varepsilon_0$ 和 $\\varepsilon_1$ 仅在该单元内乘以 $(1 - \\delta)$，其中 $\\delta = 0.02$,\n- 损伤上限为 $d_{\\max} = 0.9999$，以避免刚度矩阵奇异。\n\n测试用例：\n1. 局部模型，$N = 20$，除缺陷单元外所有单元的 $\\varepsilon_f = 0.02$，缺陷单元的 $\\varepsilon_f$ 也乘以 $(1 - \\delta)$。使用 $400$ 个位移增量，直到 $\\bar{u}_{\\max} = 1.2\\, h_{\\ell}\\, \\varepsilon_{f,\\ell}$，其中 $h_{\\ell}$ 是缺陷单元的长度，$\\varepsilon_{f,\\ell}$ 是其 $\\varepsilon_f$。\n2. 局部模型，$N = 100$，与用例 1 相同。\n3. 正则化模型，$N = 20$，$G_f = 50000\\,\\mathrm{N/m}$。通过上述能量条件为每个单元计算 $\\varepsilon_f$。使用 $400$ 个增量，直到 $\\bar{u}_{\\max} = 1.2\\, h_{\\ell}\\, \\varepsilon_{f,\\ell}$，如用例 1。\n4. 正则化模型，$N = 100$，$G_f = 50000\\,\\mathrm{N/m}$，采用相同的增量策略。\n\n对于每个测试用例，计算：\n- 以 $\\mathrm{N}$ 为单位的 $P_{\\text{peak}}$，\n- 以 $\\mathrm{m}$ 为单位的 $\\bar{u}_{\\text{peak}}$，即 $P(\\bar{u})$ 达到其最大值时的位移，\n- 一个布尔标志 $\\text{has\\_snapback}$，如果任何离散斜率 $\\Delta P / \\Delta \\bar{u}$ 为负，则为真，\n- 以 $\\mathrm{N\\cdot m}$ 为单位的外力功 $W$，即 $P(\\bar{u})$ 在计算的 $\\bar{u}$ 范围内的梯形积分值。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，每个测试用例对应一个子列表，并按上述顺序排列。每个子列表必须是 $[P_{\\text{peak}}, \\bar{u}_{\\text{peak}}, \\text{has\\_snapback}, W]$ 这四个值。例如，包含两个测试用例的输出将如下所示：$[[1.0,0.1,true,0.05],[2.0,0.2,false,0.10]]$。",
            "solution": "用户提供的问题是计算固体力学领域一个适定且有科学依据的练习，特别关注材料非线性、损伤力学和结构不稳定性。该问题有效且可解。\n\n解决方案需要实现一个一维（$1$D）非线性有限元分析，用于模拟经历损伤和软化的拉杆。分析在位移控制下进行，以追踪完整的载荷-位移响应，包括可能发生回弹不稳定的峰后软化阶段。解决方案的核心在于一个交错（或算子分裂）迭代方案，该方案处理机械变形和材料损伤演化之间的耦合。\n\n以下步骤和原则概述了构建解决方案的方法。\n\n### 1. 虚功原理和有限元离散化\n该问题由线性动量守恒控制，在准静态条件下，其弱形式通过虚功原理表达：对于任何运动学容许的虚位移，内虚功必须等于外虚功。长度为 $L$ 的杆被离散为 $N$ 个双节点线性有限元。每个单元 $e$ 的长度为 $h_e = L/N$。位移场 $u(x)$ 被近似为分段线性函数，由节点 $x_i$ 处的节点位移 $u_i$ 唯一确定。在每个单元内，应变 $\\varepsilon_e$ 是恒定的，由 $\\varepsilon_e = (u_{e+1} - u_e) / h_e$ 给出，其中 $u_e$ 和 $u_{e+1}$ 是单元两个节点的位移。\n\n单元刚度矩阵 $k_e$ 关联了节点力与节点位移。对于线性弹性材料，$k_e = \\frac{E A}{h_e} \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix}$，其中 $E$ 是杨氏模量，$A$ 是横截面积。在本问题中，通过降低刚度来引入损伤，从而得到切向单元刚度矩阵：\n$$\nk_e = (1 - d_e) \\frac{E A}{h_e} \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix}\n$$\n这里，$d_e$ 是单元 $e$ 的标量损伤变量，假定在单元内是常数。包含 $N+1$ 个节点的全局刚度矩阵 $K$ 是通过将所有 $N$ 个单元刚度矩阵的贡献相加而组装起来的。\n\n### 2. 本构模型：具有双线性软化的可损伤弹性\n由于损伤，材料的本构行为是非线性的。应力 $\\sigma$ 通过 $\\sigma = (1-d)E\\varepsilon$ 与应变 $\\varepsilon$ 相关。损伤变量 $d$ 本身取决于应变历史。拉伸状态下的应力-应变关系 $s(\\varepsilon)$ 由峰后双线性软化本构定义。在应变达到 $\\varepsilon_0$ 之前，它是线性弹性的，应力为 $\\sigma_0 = E \\varepsilon_0$。在此峰值之后，应力在两个线性段内减小，直到在最终应变 $\\varepsilon_f$ 处达到零。$s(\\varepsilon)$ 的具体形式在问题描述中给出。\n\n损伤变量 $d$ 从该应力-应变本构中导出：\n$$\nd(\\varepsilon) = 1 - \\frac{s(\\varepsilon)}{E \\varepsilon} \\quad \\text{对于 } \\varepsilon > 0\n$$\n为考虑损伤的不可逆性，它必须是加载的非递减函数。这是通过在材料点整个历史中所经历的最大拉伸应变 $\\varepsilon_{\\max}$ 处评估损伤本构来实现的，即 $d = d(\\varepsilon_{\\max})$。对于每个单元 $e$，都会存储一个历史变量 $\\varepsilon_{\\max,e}$ 并在每一步中更新。为防止单元刚度变为零（这会导致全局刚度矩阵奇异），损伤被限制在 $d_{\\max} = 0.9999$。\n\n### 3. 网格依赖性和正则化\n局部损伤模型，其中材料参数（如 $\\varepsilon_f$）是常数，存在病态的网格依赖性：随着网格细化（$h_e \\to 0$），软化响应变得更脆，失效过程中耗散的能量趋于零。为对模型进行正则化，问题引入了断裂能方法。单位面积上耗散的总能量 $G_f$ 被规定为材料属性。该能量对应于峰值应力后应力-应变曲线下的面积。通过强制应力在软化应变范围内所做的功（按单元体积缩放）等于一个恒定的断裂能 $G_f$，我们可以使整体结构响应相对于网格细化是客观的。\n失效应变 $\\varepsilon_f$ 不再是常数，而是为每个单元计算以满足能量等效性：\n$$\nh_e \\int_{\\varepsilon_0}^{\\varepsilon_f} s(\\varepsilon)\\, d\\varepsilon = G_f\n$$\n对于给定的双线性本构，这导致了问题中提供的关于 $\\varepsilon_f$ 的代数表达式，该表达式是 $h_e$ 和其他材料参数的函数。\n\n### 4. 数值解法：增量-迭代交错方案\n由于损伤依赖的刚度，该问题是高度非线性的。通过使用位移控制的增量分析结合迭代交错（算子分裂）方案，可以找到一个稳健的解。在 $u(L)$ 处施加的总位移 $\\bar{u}_{\\max}$ 以小增量施加。对于 $\\bar{u}$ 的每个增量：\n1.  **初始化**：从上一个位移步骤收敛的损伤状态 $d_{e}^{\\text{old}}$ 开始。\n2.  **迭代求收敛**：进入一个不动点迭代循环，以找到当前 $\\bar{u}$ 下一致的损伤场和位移场。\n    a.  **组装与求解**：使用当前的损伤状态 $d_{e}^{\\text{old}}$ 组装全局刚度矩阵 $K$。通过划分系统施加边界条件（$u_0 = 0$，$u_N = \\bar{u}$）。求解线性系统 $K_{II} u_I = -K_{IE} u_E$ 以获得未知的内部节点位移 $u_I$。\n    b.  **更新状态**：使用完整的位移向量 $u$，计算新的单元应变 $\\varepsilon_e$。更新最大应变历史 $\\varepsilon_{\\max,e} = \\max(\\varepsilon_{\\max,e}, \\varepsilon_e)$。\n    c.  **更新损伤**：根据每个单元更新的最大应变历史 $\\varepsilon_{\\max,e}$ 及其材料参数（$\\varepsilon_0$, $\\varepsilon_1$, $\\varepsilon_f$）计算新的损伤状态 $d_{e}^{\\text{new}}$。\n    d.  **检查收敛**：将新的损伤向量 $d^{\\text{new}}$ 与旧的 $d^{\\text{old}}$ 进行比较。如果它们的差的范数 $\\|d^{\\text{new}} - d^{\\text{old}}\\|$ 低于容差，则非线性步骤已收敛。退出循环。否则，设置 $d_{e}^{\\text{old}} \\leftarrow d_{e}^{\\text{new}}$ 并从步骤 2a 重复。\n3.  **存储结果**：收敛后，从方程 $f_E = K_{EI} u_I + K_{EE} u_E$ 计算右端的反力 $P(\\bar{u})$。存储数据对 $(\\bar{u}, P(\\bar{u}))$。\n\n引入了微小的非均匀性（一个强度略低的“缺陷”单元），以可预测的方式引发应变局部化，从而使数值问题变得适定。\n\n### 5. 后处理与输出计算\n完成所有位移增量后，对收集到的载荷-位移数据 $(\\bar{u}, P(\\bar{u}))$ 进行分析：\n-   **峰值载荷（$P_{\\text{peak}}$）和相应位移（$\\bar{u}_{\\text{peak}}$）**：通过在计算的反力数组中搜索最大值来找到。\n-   **回弹不稳定性（$\\text{has\\_snapback}$）**：检查曲线是否有任何负斜率，即对于任何增量 $i$ 是否有 $P_{i+1}  P_i$。存在这样的段表示回弹。\n-   **外力功（$W$）**：对杆做的总外力功是反力对规定位移的积分，$W = \\int_{0}^{\\bar{u}_{\\max}} P(\\bar{u})\\, d\\bar{u}$。这个积分使用梯形法则从离散数据点进行数值计算。\n\n该实现将处理四个不同的测试用例，改变单元数量（$N=20$ vs. $N=100$）和损伤模型（局部 vs. 正则化），并报告每个用例的四个计算指标。结果将突显局部模型的网格依赖性以及基于断裂能方法的正则化效果。",
            "answer": "```python\nimport numpy as np\n\n# Global constants and material properties from the problem statement\nL = 1.0  # m\nA = 1.0e-4  # m^2\nE = 7.0e10  # Pa\nEPSILON_0_REF = 0.002\nEPSILON_1_REF = 0.006\nR_SIGMA = 0.5\nDELTA = 0.02\nG_F = 50000.0  # N/m\nD_MAX = 0.9999\nN_INCR = 400\nNL_TOL = 1e-8\nNL_MAX_ITER = 50\n\ndef get_stress(eps, eps_0, eps_1, eps_f, E):\n    \"\"\"\n    Computes stress based on the bilinear softening law for a given strain.\n    Assumes strain represents the monotonic loading path.\n    \"\"\"\n    if eps = 0:\n        return E * eps  # Elastic in compression\n    \n    sigma_0 = E * eps_0\n    sigma_1 = R_SIGMA * sigma_0\n    \n    if eps = eps_0:\n        return E * eps\n    elif eps = eps_1:\n        if abs(eps_1 - eps_0)  1e-12: return sigma_0\n        return sigma_0 + (sigma_1 - sigma_0) / (eps_1 - eps_0) * (eps - eps_0)\n    elif eps = eps_f:\n        if abs(eps_f - eps_1)  1e-12: return 0.0\n        return sigma_1 * (eps_f - eps) / (eps_f - eps_1)\n    else:\n        return 0.0\n\ndef get_damage(eps, eps_0, eps_1, eps_f, E):\n    \"\"\"\n    Computes the damage variable d(eps) based on the stress law.\n    \"\"\"\n    if eps = eps_0:\n        return 0.0\n    \n    stress = get_stress(eps, eps_0, eps_1, eps_f, E)\n    if eps > 1e-12: # Avoid division by zero\n        damage = 1.0 - stress / (E * eps)\n    else:\n        damage = 0.0\n        \n    return min(damage, D_MAX)\n\ndef run_simulation(params):\n    \"\"\"\n    Performs a full nonlinear finite element simulation for one test case.\n    \"\"\"\n    # 1. Setup mesh and material properties\n    N = params['N']\n    h_e = L / N\n    num_nodes = N + 1\n    \n    eps_0_e = np.full(N, EPSILON_0_REF)\n    eps_1_e = np.full(N, EPSILON_1_REF)\n    eps_f_e = np.zeros(N)\n\n    flawed_elem_idx = N // 2\n    \n    eps_0_e[flawed_elem_idx] *= (1.0 - DELTA)\n    eps_1_e[flawed_elem_idx] *= (1.0 - DELTA)\n\n    if params['model_type'] == 'local':\n        eps_f_e.fill(params['epsilon_f_ref'])\n        eps_f_e[flawed_elem_idx] *= (1.0 - DELTA)\n    else: # 'regularized'\n        G_f = params['G_f']\n        for i in range(N):\n            e0, e1 = eps_0_e[i], eps_1_e[i]\n            s0 = E * e0\n            s1 = R_SIGMA * s0\n            \n            if s1  1e-9:\n                eps_f_e[i] = e1 * 1.001\n                continue\n\n            term = G_f / h_e - (s0 + s1) / 2.0 * (e1 - e0)\n            if term >= 0:\n                eps_f_e[i] = e1 + (2.0 / s1) * term\n            else:\n                eps_f_e[i] = e1 * 1.001\n\n    # 2. Simulation initialization\n    u_max = 1.2 * h_e * eps_f_e[flawed_elem_idx]\n    u_bar_steps = np.linspace(0, u_max, N_INCR)\n    \n    u = np.zeros(num_nodes)\n    d_e = np.zeros(N)\n    eps_max_e = np.zeros(N)\n    \n    load_disp_curve = [(0.0, 0.0)]\n    singular_failure = False\n\n    # 3. Incremental displacement-controlled loop\n    for i, u_bar in enumerate(u_bar_steps):\n        if i == 0: continue\n        \n        # Non-linear solver loop (staggered scheme)\n        for _ in range(NL_MAX_ITER):\n            K = np.zeros((num_nodes, num_nodes))\n            for e in range(N):\n                k_scalar = (1.0 - d_e[e]) * E * A / h_e\n                k_el = k_scalar * np.array([[1, -1], [-1, 1]])\n                K[e:e+2, e:e+2] += k_el\n\n            K_II = K[1:-1, 1:-1]\n            K_IE = K[1:-1, [0, -1]]\n            u_E = np.array([0, u_bar])\n            \n            f_ext_I = -K_IE @ u_E\n            \n            try:\n                u_I = np.linalg.solve(K_II, f_ext_I)\n            except np.linalg.LinAlgError:\n                for j in range(i, N_INCR):\n                    load_disp_curve.append((u_bar_steps[j], 0.0))\n                singular_failure = True\n                break\n\n            u[1:-1] = u_I\n            u[-1] = u_bar\n            \n            new_d_e = np.zeros(N)\n            strains = np.diff(u) / h_e\n            eps_max_e = np.maximum(eps_max_e, strains)\n            \n            for e in range(N):\n                new_d_e[e] = get_damage(eps_max_e[e], eps_0_e[e], eps_1_e[e], eps_f_e[e], E)\n            \n            d_norm_diff = np.linalg.norm(new_d_e - d_e)\n            d_e = new_d_e\n            \n            if d_norm_diff  NL_TOL:\n                break\n        \n        if singular_failure:\n            break\n        \n        K_EI = K[[0, -1], 1:-1]\n        K_EE = K[[0, -1], [0, -1]]\n        f_E = K_EI @ u_I + K_EE @ u_E\n        P = f_E[1]\n        \n        load_disp_curve.append((u_bar, P))\n        \n    # 4. Post-process results\n    disps = np.array([p[0] for p in load_disp_curve])\n    loads = np.array([p[1] for p in load_disp_curve])\n\n    P_peak, u_peak = (0.0, 0.0)\n    if len(loads) > 0 and np.any(loads > 0):\n        peak_idx = np.argmax(loads)\n        P_peak = loads[peak_idx]\n        u_peak = disps[peak_idx]\n\n    has_snapback = np.any(np.diff(loads)  0)\n    \n    W = np.trapz(loads, disps)\n\n    return [P_peak, u_peak, bool(has_snapback), W]\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the test cases and print the final result.\n    \"\"\"\n    test_cases = [\n        {'model_type': 'local', 'N': 20, 'epsilon_f_ref': 0.02},\n        {'model_type': 'local', 'N': 100, 'epsilon_f_ref': 0.02},\n        {'model_type': 'regularized', 'N': 20, 'G_f': G_F},\n        {'model_type': 'regularized', 'N': 100, 'G_f': G_F},\n    ]\n\n    results = []\n    for params in test_cases:\n        result = run_simulation(params)\n        results.append(result)\n\n    formatted_results = []\n    for res in results:\n        p_peak_str = f\"{res[0]:.6f}\"\n        u_peak_str = f\"{res[1]:.6f}\"\n        snap_str = str(res[2]).lower()\n        w_str = f\"{res[3]:.6f}\"\n        formatted_results.append(f\"[{p_peak_str},{u_peak_str},{snap_str},{w_str}]\")\n\n    final_output_string = f\"[{','.join(formatted_results)}]\"\n    print(final_output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "成功追踪非线性平衡路径后，下一步是精确地解读结果。本实践专注于后处理仿真数据，以自动识别和分类路径上的临界点。您将开发一个算法，通过检验荷载参数的导数以及切线刚度矩阵的特征值，来区分极限点（如贯穿和回弹）与对称性破缺分岔点，这是从计算结果中提炼物理洞察力的核心技能 。",
            "id": "3600883",
            "problem": "给定一个在计算固体力学中由伪弧长参数 $s$ 索引的非线性平衡路径的离散状态延拓序列。设 $\\mathbf{u}(s)$ 为广义位移向量，$\\lambda(s)$ 为标量载荷参数。平衡条件由非线性残差 $\\mathbf{R}(\\mathbf{u},\\lambda)=\\mathbf{0}$ 给出，切向刚度为 $\\mathbf{K}_T(\\mathbf{u},\\lambda)=\\partial \\mathbf{R}/\\partial \\mathbf{u}$。对于数值延拓，切向刚度的对称部分定义为 $\\mathbf{S}=\\tfrac{1}{2}\\left(\\mathbf{K}_T+\\mathbf{K}_T^{\\mathsf{T}}\\right)$。用 $\\mu_{\\min}(s)$ 表示在参数值 $s$ 处 $\\mathbf{S}$ 的最小特征值。\n\n您的任务是设计并实现一个稳健的、纯粹的算法准则，仅使用给定的离散样本 $\\{s_k,\\lambda_k,\\mathbf{K}_{T,k}\\}$ 来分类路径上遇到的分岔类型。请仅依赖于基本原理：正定性的丧失由 $\\mu_{\\min}(s)\\to 0$ 表明，载荷路径中的转折点满足 $\\mathrm{d}\\lambda/\\mathrm{d}s=0$。您必须：\n\n- 在 $s$ 网格上使用有限差分近似计算每个样本点的 $\\mathrm{d}\\lambda/\\mathrm{d}s$。\n- 在每个样本点，通过特征值分析从 $\\mathbf{K}_T$ 的对称部分计算 $\\mu_{\\min}$。\n- 对每个测试案例按如下方式声明事件分类：\n  - 如果存在至少一个 $s$，使得 $\\left|\\mathrm{d}\\lambda/\\mathrm{d}s\\right|$ 在规定容差内数值上为零，并且这表示 $\\lambda(s)$ 的一个转折点，则将该案例分类为极限点。这对应于检测到 $\\mathrm{d}\\lambda/\\mathrm{d}s=0$ 的贯穿或回弹。\n  - 否则，如果 $\\mu_{\\min}(s)$ 在样本间改变符号（即，存在 $\\mu_{\\min}0$ 的样本和 $\\mu_{\\min}0$ 的其他样本）且在规定容差内，则将该案例分类为对称性破缺分岔。这对应于分支不稳定性，其中对称刚度的最小特征值沿路径穿过零并改变符号，而载荷参数继续单调变化。\n  - 否则，将该案例分类为在给定样本窗口内未检测到分岔。\n\n您的程序必须为两种检查实现合理的数值容差。对 $\\left|\\mathrm{d}\\lambda/\\mathrm{d}s\\right|$ 使用导数容差 $\\tau_{\\lambda'}=10^{-3}$，对 $\\mu_{\\min}$ 的比较使用特征值容差 $\\tau_{\\mu}=10^{-6}$。在近似计算 $\\mathrm{d}\\lambda/\\mathrm{d}s$ 时，您必须对内部点使用中心差分，对端点使用单侧差分。\n\n测试套件。在以下三个测试案例上实现您的算法。对于每个案例，您将获得 $s$、$\\lambda$ 和 $\\mathbf{K}_T$（矩阵）的离散样本，所有这些都是无量纲的。特征分析必须在 $\\mathbf{S}_k=\\tfrac{1}{2}\\left(\\mathbf{K}_{T,k}+\\mathbf{K}_{T,k}^{\\mathsf{T}}\\right)$ 上进行。\n\n- 案例 A（极限点候选）：\n  - $s=\\left[0.8,\\,0.9,\\,1.0,\\,1.1,\\,1.2\\right]$\n  - $\\lambda(s)=1-(s-1)^2$ 在给定的 $s$ 处采样；即 $\\lambda=\\left[0.96,\\,0.99,\\,1.0,\\,0.99,\\,0.96\\right]$\n  - $\\mathbf{K}_T(s)$ 是一个 $1\\times 1$ 的标量，在每个 $s$ 处 $\\mathbf{K}_T=s-1$；即 $\\mathbf{K}_T=\\left[-0.2,\\,-0.1,\\,0.0,\\,0.1,\\,0.2\\right]$\n- 案例 B（对称性破缺候选）：\n  - $s=\\left[0.9,\\,0.95,\\,1.0,\\,1.05\\right]$\n  - $\\lambda(s)=s$ 在给定的 $s$ 处采样；即 $\\lambda=\\left[0.9,\\,0.95,\\,1.0,\\,1.05\\right]$\n  - $\\mathbf{K}_T(s)$ 是一个 $2\\times 2$ 的对角矩阵，在每个 $s$ 处的元素为 $\\left[s-1,\\,1\\right]$；例如在 $s=0.9$ 时，$\\mathbf{K}_T=\\begin{bmatrix}-0.1  0 \\\\ 0  1\\end{bmatrix}$，其他样本类似\n- 案例 C（窗口内无事件）：\n  - $s=\\left[0.0,\\,0.5,\\,1.0\\right]$\n  - $\\lambda(s)=s+0.2$ 在给定的 $s$ 处采样；即 $\\lambda=\\left[0.2,\\,0.7,\\,1.2\\right]$\n  - $\\mathbf{K}_T(s)$ 是一个 $2\\times 2$ 的对角矩阵，在每个 $s$ 处的元素为 $\\left[1,\\,2\\right]$；即在所有样本点 $\\mathbf{K}_T=\\begin{bmatrix}1  0 \\\\ 0  2\\end{bmatrix}$\n\n您的程序应使用整数代码为每个案例输出单个分类：\n- $1$ 表示极限点（通过 $\\mathrm{d}\\lambda/\\mathrm{d}s\\approx 0$ 检测到的贯穿或回弹转折点），\n- $2$ 表示对称性破缺分岔（$\\mu_{\\min}$ 的符号变化），\n- $0$ 表示未检测到事件。\n\n如果在一个案例中同时满足多个标准，您必须优先声明为极限点（代码 $1$）而不是对称性破缺分岔（代码 $2$）。对于每个案例，处理提供的 $(s,\\lambda,\\mathbf{K}_T)$ 数组并报告一个整数代码。\n\n最终输出格式。您的程序应生成一行输出，其中包含按 A、B、C 顺序排列的结果，形式为逗号分隔的列表并用方括号括起；例如，格式必须与 $\\left[\\text{result\\_A},\\text{result\\_B},\\text{result\\_C}\\right]$ 完全一样。",
            "solution": "问题陈述已经过严格验证，并被确定为有效。它在科学上基于计算固体力学的原理，问题定义清晰，具有一组明确客观的要求，并包含唯一解所需的所有数据。任务是构建并实现一种算法，用于对离散非线性平衡路径上的失稳事件进行分类。\n\n目标是制定一个纯粹的算法准则，使用离散的状态序列 $\\{s_k, \\lambda_k, \\mathbf{K}_{T,k}\\}$ 来区分极限点（贯穿/回弹现象）和对称性破缺分岔。这里，$s_k$ 是伪弧长参数的第 $k$ 个样本，$\\lambda_k$ 是对应的载荷参数，$\\mathbf{K}_{T,k}$ 是切向刚度矩阵。分类依赖于结构稳定性的基本原理。\n\n一个力学系统的平衡路径是在位移 $\\mathbf{u}$ 和载荷参数 $\\lambda$ 的状态空间中的一条曲线，由残余力向量 $\\mathbf{R}(\\mathbf{u}, \\lambda)$ 为零的条件定义。在数值延拓方法中，该路径由弧长参数 $s$ 参数化，得到 $(\\mathbf{u}(s), \\lambda(s))$。失稳，或称临界点，是路径上解的性质发生改变的点。\n\n考虑两种主要类型的临界点：\n$1$. **极限点**：这些是载荷参数 $\\lambda$ 沿路径达到局部极值的点。在极限点处，路径相对于载荷参数轴的切线是水平的，这在数学上对应于条件 $\\mathrm{d}\\lambda/\\mathrm{d}s = 0$。这类点通常与贯穿或回弹失稳有关。\n$2$. **分岔点**：这些是多条不同平衡路径相交的点。分岔的一个必要条件是切向刚度矩阵 $\\mathbf{K}_T = \\partial\\mathbf{R}/\\partial\\mathbf{u}$ 的奇异性。通常，一个平衡状态的稳定性由切向刚度矩阵的对称部分 $\\mathbf{S} = \\frac{1}{2}(\\mathbf{K}_T + \\mathbf{K}_T^\\mathsf{T})$ 的正定性来评估。当 $\\mathbf{S}$ 不再是正定时，就会发生失稳，其标志是最小特征值 $\\mu_{\\min}$ 穿过零。对于对称性破缺分岔，这种失稳发生在载荷参数可能单调变化时（即 $\\mathrm{d}\\lambda/\\mathrm{d}s \\neq 0$）。\n\n基于这些原理，设计了以下三步算法来对给定测试案例的事件类型进行分类。\n\n**第 1 步：极限点检测**\n第一步是检查是否存在极限点。由于我们有离散样本 $(\\lambda_k, s_k)$，必须对导数 $\\mathrm{d}\\lambda/\\mathrm{d}s$ 进行数值近似。我们使用对内部点为二阶精度、对端点为一阶精度的有限差分公式：\n- 对于内部点 $k$ ($0  k  N-1$)：使用中心差分，$\\frac{\\mathrm{d}\\lambda}{\\mathrm{d}s}\\bigg|_{s_k} \\approx \\frac{\\lambda_{k+1} - \\lambda_{k-1}}{s_{k+1} - s_{k-1}}$。\n- 对于第一个点 $k=0$：使用向前差分，$\\frac{\\mathrm{d}\\lambda}{\\mathrm{d}s}\\bigg|_{s_0} \\approx \\frac{\\lambda_1 - \\lambda_0}{s_1 - s_0}$。\n- 对于最后一个点 $k=N-1$：使用向后差分，$\\frac{\\mathrm{d}\\lambda}{\\mathrm{d}s}\\bigg|_{s_{N-1}} \\approx \\frac{\\lambda_{N-1} - \\lambda_{N-2}}{s_{N-1} - s_{N-2}}$。\n如果对于任何样本 $k$，近似导数的绝对值在数值上接近于零，则检测到极限点。条件是 $|\\mathrm{d}\\lambda/\\mathrm{d}s|_k  \\tau_{\\lambda'}$，其中 $\\tau_{\\lambda'} = 10^{-3}$ 是规定的容差。\n\n**第 2 步：对称性破缺分岔检测**\n如果没有检测到极限点，算法将检查是否存在对称性破缺分岔。这涉及在每个样本点 $k$ 分析对称刚度矩阵 $\\mathbf{S}_k$ 的特征值。\n对于每个样本 $k$：\n- 首先，计算切向刚度矩阵的对称部分：$\\mathbf{S}_k = \\frac{1}{2}(\\mathbf{K}_{T,k} + \\mathbf{K}_{T,k}^\\mathsf{T})$。\n- 接着，计算这个实对称矩阵 $\\mathbf{S}_k$ 的特征值。\n- 确定最小特征值 $\\mu_{\\min, k}$。\n如果最小特征值序列 $\\{\\mu_{\\min, k}\\}$ 在采样范围内改变符号，则检测到分岔。通过检查是否存在至少一个样本 $i$ 使得 $\\mu_{\\min, i}  -\\tau_{\\mu}$ 并且至少一个样本 $j$ 使得 $\\mu_{\\min, j}  \\tau_{\\mu}$ 来测试这一点。规定的容差是 $\\tau_{\\mu} = 10^{-6}$。\n\n**第 3 步：分类与优先级**\n最终分类根据严格的优先规则进行：\n- 如果在第 1 步中检测到极限点，则该案例被分类为极限点（代码 $1$），并且该案例的处理终止。\n- 否则，如果在第 2 步中检测到对称性破缺分岔，则该案例被分类为此类（代码 $2$）。\n- 否则，如果以上两个条件都未满足，则断定在给定的样本窗口内未检测到事件（代码 $0$）。\n\n**应用于测试案例**\n\n- **案例 A**：\n  - $s=\\left[0.8,\\,0.9,\\,1.0,\\,1.1,\\,1.2\\right]$, $\\lambda=\\left[0.96,\\,0.99,\\,1.0,\\,0.99,\\,0.96\\right]$。\n  - 极限点检查：在每个点近似计算导数 $\\mathrm{d}\\lambda/\\mathrm{d}s$。在 $s=1.0$ 处，中心差分为 $(\\lambda_{1.1} - \\lambda_{0.9})/(1.1 - 0.9) = (0.99 - 0.99)/0.2 = 0$。由于 $|0|  10^{-3}$，检测到极限点。分类为 $1$。尽管 $\\mathbf{K}_T = \\mathbf{S}$ 的特征值为 $[-0.2, -0.1, 0.0, 0.1, 0.2]$，显示出符号变化，但极限点标准优先。\n\n- **案例 B**：\n  - $s=\\left[0.9,\\,0.95,\\,1.0,\\,1.05\\right]$, $\\lambda=\\left[0.9,\\,0.95,\\,1.0,\\,1.05\\right]$。\n  - 极限点检查：$\\lambda(s)=s$，所以 $\\mathrm{d}\\lambda/\\mathrm{d}s=1$。所有有限差分近似值都接近 $1$，因此没有导数接近零。未检测到极限点。\n  - 分岔检查：$\\mathbf{K}_T$ 是对角矩阵，因此是对称的（$\\mathbf{S}_k = \\mathbf{K}_{T,k}$）。特征值是其对角元素 $[s-1, 1]$。最小特征值为 $\\mu_{\\min}(s) = s-1$。给定 $s$ 值的最小特征值序列是 $[-0.1, -0.05, 0.0, 0.05]$。该序列包含小于 $-\\tau_{\\mu}$ 的值（例如 $-0.1$）和大于 $\\tau_{\\mu}$ 的值（例如 $0.05$）。检测到符号变化。分类为 $2$。\n\n- **案例 C**：\n  - $s=\\left[0.0,\\,0.5,\\,1.0\\right]$, $\\lambda=\\left[0.2,\\,0.7,\\,1.2\\right]$。\n  - 极限点检查：$\\lambda(s) = s+0.2$，所以 $\\mathrm{d}\\lambda/\\mathrm{d}s=1$。所有近似值都远非零。未检测到极限点。\n  - 分岔检查：$\\mathbf{K}_T = \\begin{bmatrix}1  0 \\\\ 0  2\\end{bmatrix}$ 是常数且对称的。所有样本的特征值为 $1$ 和 $2$。最小特征值为 $\\mu_{\\min, k}=1$ 对于所有 $k$。最小特征值序列是 $[1, 1, 1]$。没有符号变化。未检测到分岔。分类为 $0$。\n\n因此，案例 A、B 和 C 的最终结果是 $[1, 2, 0]$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the bifurcation classification problem for the given test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: limit point candidate\n        {\n            \"s\": np.array([0.8, 0.9, 1.0, 1.1, 1.2]),\n            \"lambda\": np.array([0.96, 0.99, 1.0, 0.99, 0.96]),\n            \"K_T\": [\n                np.atleast_2d(-0.2), \n                np.atleast_2d(-0.1), \n                np.atleast_2d(0.0), \n                np.atleast_2d(0.1), \n                np.atleast_2d(0.2)\n            ]\n        },\n        # Case B: symmetry-breaking candidate\n        {\n            \"s\": np.array([0.9, 0.95, 1.0, 1.05]),\n            \"lambda\": np.array([0.9, 0.95, 1.0, 1.05]),\n            \"K_T\": [\n                np.diag([0.9 - 1.0, 1.0]),\n                np.diag([0.95 - 1.0, 1.0]),\n                np.diag([1.0 - 1.0, 1.0]),\n                np.diag([1.05 - 1.0, 1.0]),\n            ]\n        },\n        # Case C: no event in window\n        {\n            \"s\": np.array([0.0, 0.5, 1.0]),\n            \"lambda\": np.array([0.2, 0.7, 1.2]),\n            \"K_T\": [\n                np.diag([1.0, 2.0]),\n                np.diag([1.0, 2.0]),\n                np.diag([1.0, 2.0]),\n            ]\n        }\n    ]\n\n    results = []\n    \n    # Numerical tolerances\n    tau_lambda_prime = 1e-3\n    tau_mu = 1e-6\n\n    for case in test_cases:\n        s_k = case[\"s\"]\n        lambda_k = case[\"lambda\"]\n        K_T_k_list = case[\"K_T\"]\n\n        # --- Step 1: Limit Point Detection ---\n        # Approximate d(lambda)/ds using finite differences.\n        # np.gradient uses central differences for interior points and\n        # one-sided differences at the boundaries, as specified.\n        d_lambda_ds = np.gradient(lambda_k, s_k)\n        \n        limit_point_detected = np.any(np.abs(d_lambda_ds)  tau_lambda_prime)\n\n        # --- Step 2: Symmetry-Breaking Bifurcation Detection ---\n        mu_mins = []\n        for K_T in K_T_k_list:\n            # S = 0.5 * (K_T + K_T^T)\n            S = 0.5 * (K_T + K_T.T)\n            \n            # Compute eigenvalues of the symmetric matrix S.\n            # eigvalsh is optimized for real symmetric/Hermitian matrices.\n            eigenvalues = np.linalg.eigvalsh(S)\n            \n            # Find the minimum eigenvalue\n            mu_min = np.min(eigenvalues)\n            mu_mins.append(mu_min)\n        \n        mu_mins = np.array(mu_mins)\n        \n        # Check for sign change in the smallest eigenvalue across samples\n        bifurcation_detected = np.any(mu_mins > tau_mu) and np.any(mu_mins  -tau_mu)\n\n        # --- Step 3: Classification with Prioritization ---\n        if limit_point_detected:\n            results.append(1)\n        elif bifurcation_detected:\n            results.append(2)\n        else:\n            results.append(0)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}