{
    "hands_on_practices": [
        {
            "introduction": "To build a robust understanding of structural instability, we begin with an analytical investigation. This exercise explores a classic two-bar truss, a system simple enough for closed-form analysis yet rich enough to exhibit complex nonlinear behavior. By deriving the exact load-displacement relationship from first principles, you will see precisely how the interplay between geometric nonlinearity and a material's softening response gives rise to a load limit point, the hallmark of snap-back instability under load control . This foundational practice illuminates the physical and mathematical origins of the phenomena we later aim to capture with computational tools.",
            "id": "3600896",
            "problem": "A symmetric pin-jointed two-bar truss is formed by two identical straight members of undeformed length connecting fixed supports at coordinates $(-a,0)$ and $(a,0)$ to a common apex initially located at $(0,h_0)$, where $a>0$ and $h_0>0$. Each member is axially deformable with constant cross-sectional area $A$ and obeys the softening linear stress–strain law $\\sigma=\\sigma_0+H\\,\\varepsilon$ with $H0$ and constant $\\sigma_0$, where $\\varepsilon$ is the Green–Lagrange axial strain taken here in the small-strain limit as the axial engineering strain $\\varepsilon=\\left(\\ell-L_0\\right)/L_0$, with $L_0=\\sqrt{a^2+h_0^2}$ the initial member length and $\\ell$ its current length. The apex is displaced vertically downward by a prescribed displacement $w$ (so its current vertical coordinate is $h=h_0-w$), and the corresponding reaction load $P$ is measured in the vertical direction at the apex, under quasi-static conditions. Assume plane pin-jointed behavior with axial forces only and neglect body forces, shear deformation, and bending.\n\nUsing only equilibrium, compatibility, and the stated constitutive relation:\n- Derive the exact global load–displacement relation $P(w)$ for this system in closed form in terms of $a$, $h_0$, $A$, $\\sigma_0$, $H$, and $w$.\n- Determine the onset of snap-back under load control by finding the critical downward apex displacement $w_{\\mathrm{cr}}$ at which the global load–displacement curve develops a horizontal tangent. Provide a single closed-form analytic expression for $w_{\\mathrm{cr}}$.\n\nExpress the displacement $w_{\\mathrm{cr}}$ in meters. Do not insert any numerical values. The final answer must be a single closed-form analytic expression.",
            "solution": "The problem is valid as it describes a well-posed physical system in structural mechanics and seeks a derivable analytical result based on the provided principles of equilibrium, compatibility, and material constitution.\n\nThe solution proceeds in two parts: first, deriving the global load-displacement relation $P(w)$, and second, finding the critical displacement $w_{\\mathrm{cr}}$ for the onset of snap-back by analyzing this relation.\n\n**Part 1: Derivation of the Load-Displacement Relation $P(w)$**\n\n**1. Kinematics and Compatibility**\nThe initial geometry consists of two members of length $L_0$ connecting supports at $(\\pm a, 0)$ to an apex at $(0, h_0)$. The initial length of each member is given by the Pythagorean theorem:\n$$L_0 = \\sqrt{a^2 + h_0^2}$$\nWhen the apex is displaced vertically downward by a distance $w$, its new coordinates are $(0, h)$, where the current height $h$ is:\n$$h = h_0 - w$$\nThe current length of each member, $\\ell$, can be found from the new geometry:\n$$\\ell(w) = \\sqrt{a^2 + h^2} = \\sqrt{a^2 + (h_0 - w)^2}$$\nThe axial engineering strain $\\varepsilon$ is defined as the change in length divided by the original length:\n$$\\varepsilon = \\frac{\\ell - L_0}{L_0} = \\frac{\\sqrt{a^2 + (h_0 - w)^2} - \\sqrt{a^2 + h_0^2}}{\\sqrt{a^2 + h_0^2}}$$\n\n**2. Constitutive Relation**\nThe axial stress $\\sigma$ in each member is given by the specified linear softening law:\n$$\\sigma = \\sigma_0 + H\\,\\varepsilon$$\nwhere $\\sigma_0$ is a constant and $H  0$. The axial force $F$ in each member, with cross-sectional area $A$, is:\n$$F = \\sigma A = A(\\sigma_0 + H\\,\\varepsilon)$$\nSubstituting the expression for strain $\\varepsilon$:\n$$F(w) = A\\left(\\sigma_0 + H \\left(\\frac{\\ell(w)}{L_0} - 1\\right)\\right) = A\\left(\\sigma_0 - H + \\frac{H}{L_0}\\ell(w)\\right)$$\n\n**3. Equilibrium**\nAt the apex, the externally applied vertical load $P$ must be balanced by the vertical components of the axial forces from the two members. By symmetry, the horizontal force components cancel. Let $\\theta$ be the angle between a member and the horizontal axis. The vertical equilibrium equation is:\n$$P = 2 F \\sin(\\theta)$$\nFrom the geometry, $\\sin(\\theta)$ is the ratio of the current apex height $h$ to the current member length $\\ell$:\n$$\\sin(\\theta) = \\frac{h}{\\ell} = \\frac{h_0 - w}{\\sqrt{a^2 + (h_0 - w)^2}}$$\nSubstituting the expressions for $F(w)$ and $\\sin(\\theta)$ into the equilibrium equation yields the load-displacement relation $P(w)$:\n$$P(w) = 2 \\left[ A\\left(\\sigma_0 - H + \\frac{H}{L_0}\\ell(w)\\right) \\right] \\frac{h_0 - w}{\\ell(w)}$$\nDistributing the term $\\frac{h_0 - w}{\\ell(w)}$ gives:\n$$P(w) = 2A \\left( (\\sigma_0 - H)\\frac{h_0 - w}{\\ell(w)} + \\frac{H}{L_0}(h_0 - w) \\right)$$\nSubstituting the full expressions for $\\ell(w)$ and $L_0$, we obtain the final closed-form relation:\n$$P(w) = 2A(h_0 - w) \\left( \\frac{\\sigma_0 - H}{\\sqrt{a^2 + (h_0 - w)^2}} + \\frac{H}{\\sqrt{a^2 + h_0^2}} \\right)$$\n\n**Part 2: Determination of the Critical Displacement $w_{\\mathrm{cr}}$**\n\nThe onset of snap-back under load control corresponds to a limit point on the load-displacement curve, which is characterized by a horizontal tangent. Mathematically, this occurs where the derivative of the load $P$ with respect to the displacement $w$ is zero:\n$$\\frac{dP}{dw} = 0$$\nWe differentiate the expression for $P(w)$ with respect to $w$. Let's analyze the two terms inside the parentheses in the expression for $P(w) / (2A)$:\n$$P(w) / (2A) = (\\sigma_0 - H)\\frac{h_0 - w}{\\sqrt{a^2 + (h_0 - w)^2}} + \\frac{H}{L_0}(h_0 - w)$$\nThe derivative of the second term is straightforward:\n$$\\frac{d}{dw}\\left[\\frac{H}{L_0}(h_0 - w)\\right] = -\\frac{H}{L_0}$$\nFor the first term, we use the quotient rule and chain rule. Let $u = h_0 - w$, so $\\frac{du}{dw} = -1$. The term is $\\frac{u}{\\sqrt{a^2 + u^2}}$.\n$$\\frac{d}{du}\\left(\\frac{u}{\\sqrt{a^2 + u^2}}\\right) = \\frac{1 \\cdot \\sqrt{a^2 + u^2} - u \\cdot \\frac{u}{\\sqrt{a^2 + u^2}}}{a^2 + u^2} = \\frac{(a^2 + u^2) - u^2}{(a^2 + u^2)^{3/2}} = \\frac{a^2}{(a^2 + u^2)^{3/2}}$$\nUsing the chain rule, the derivative with respect to $w$ is:\n$$\\frac{d}{dw}\\left(\\frac{h_0 - w}{\\sqrt{a^2 + (h_0 - w)^2}}\\right) = \\frac{a^2}{(a^2 + (h_0-w)^2)^{3/2}} \\cdot (-1) = \\frac{-a^2}{\\ell(w)^3}$$\nCombining the derivatives, we get:\n$$\\frac{dP}{dw} = 2A \\left[ (\\sigma_0 - H)\\left(\\frac{-a^2}{\\ell(w)^3}\\right) - \\frac{H}{L_0} \\right]$$\nSetting $\\frac{dP}{dw} = 0$ gives the condition for the critical displacement $w_{\\mathrm{cr}}$:\n$$-(\\sigma_0 - H)\\frac{a^2}{\\ell_{\\mathrm{cr}}^3} - \\frac{H}{L_0} = 0$$\nwhere $\\ell_{\\mathrm{cr}} = \\ell(w_{\\mathrm{cr}})$. Rearranging to solve for $\\ell_{\\mathrm{cr}}^3$:\n$$-(\\sigma_0 - H)a^2 L_0 = H \\ell_{\\mathrm{cr}}^3$$\n$$\\ell_{\\mathrm{cr}}^3 = -\\frac{(\\sigma_0 - H)}{H} a^2 L_0 = \\frac{H - \\sigma_0}{H} a^2 L_0 = \\left(1 - \\frac{\\sigma_0}{H}\\right) a^2 L_0$$\nThe critical member length $\\ell_{\\mathrm{cr}}$ is therefore:\n$$\\ell_{\\mathrm{cr}} = \\left[ \\left(1 - \\frac{\\sigma_0}{H}\\right) a^2 L_0 \\right]^{1/3}$$\nTo find the critical displacement $w_{\\mathrm{cr}}$, we use the kinematic relation $\\ell_{\\mathrm{cr}}^2 = a^2 + (h_0 - w_{\\mathrm{cr}})^2$.\n$$(h_0 - w_{\\mathrm{cr}})^2 = \\ell_{\\mathrm{cr}}^2 - a^2$$\nAssuming the first critical point occurs before the apex inverts (i.e., $h_0 - w_{\\mathrm{cr}} > 0$), we take the positive root:\n$$h_0 - w_{\\mathrm{cr}} = \\sqrt{\\ell_{\\mathrm{cr}}^2 - a^2}$$\n$$w_{\\mathrm{cr}} = h_0 - \\sqrt{\\ell_{\\mathrm{cr}}^2 - a^2}$$\nSubstituting the expression for $\\ell_{\\mathrm{cr}}$:\n$$w_{\\mathrm{cr}} = h_0 - \\sqrt{\\left( \\left[ \\left(1 - \\frac{\\sigma_0}{H}\\right) a^2 L_0 \\right]^{1/3} \\right)^2 - a^2}$$\n$$w_{\\mathrm{cr}} = h_0 - \\sqrt{\\left[ \\left(1 - \\frac{\\sigma_0}{H}\\right) a^2 L_0 \\right]^{2/3} - a^2}$$\nFinally, substituting $L_0 = \\sqrt{a^2 + h_0^2}$ gives the complete expression for $w_{\\mathrm{cr}}$ in terms of the given parameters:\n$$w_{\\mathrm{cr}} = h_0 - \\sqrt{\\left[ \\left(1 - \\frac{\\sigma_0}{H}\\right) a^2 \\sqrt{a^2 + h_0^2} \\right]^{\\frac{2}{3}} - a^2}$$\nThis is the required single closed-form analytic expression for the critical displacement.",
            "answer": "$$\n\\boxed{h_0 - \\sqrt{\\left( a^2 \\left(1 - \\frac{\\sigma_0}{H}\\right) \\sqrt{a^2 + h_0^2} \\right)^{\\frac{2}{3}} - a^2}}\n$$"
        },
        {
            "introduction": "While analytical solutions provide invaluable insight, most real-world engineering problems require numerical methods to trace their equilibrium paths. This practice focuses on the core computational engine for instability analysis: the continuation algorithm. You will implement and compare three fundamental control strategies—load, displacement, and arc-length control—on a simple, reduced-order model that cleanly exhibits both snap-through and snap-back behaviors . This exercise is designed to provide hands-on experience with the algorithms themselves, demonstrating why robust methods like arc-length control are essential for navigating the limit points that simpler approaches cannot.",
            "id": "3600849",
            "problem": "Consider the reduced-order tracing of nonlinear equilibrium paths in a one-parameter family of equilibria defined implicitly by the single algebraic equation\n$$\nF(u,\\lambda) = \\left(\\frac{u}{a}\\right)^2 + \\left(\\frac{\\lambda}{b}\\right)^2 - 1 = 0,\n$$\nwhere $u$ is a generalized displacement, $\\lambda$ is a generalized load factor, and $a>0$, $b>0$ are given shape parameters. This implicit curve has both horizontal tangents (load limit points, associated with snap-through when controlling $\\lambda$) and vertical tangents (displacement limit points, associated with snap-back when controlling $u$). The problem is to implement an augmented Newton solver with a second constraint equation $g(u,\\lambda)=0$ to enforce different control strategies and to assess their capability to traverse limit-point segments. All quantities in this problem are dimensionless.\n\nStart from fundamental continuation principles: the equilibrium condition is $F(u,\\lambda)=0$, and continuation augments it with a scalar control constraint $g(u,\\lambda)=0$ so that the unknown vector $(u,\\lambda)$ is determined by solving a $2\\times 2$ system at each step via Newton's method. Let the Jacobian of $F$ be the gradient\n$$\n\\nabla F(u,\\lambda) = \\left[\\frac{\\partial F}{\\partial u}, \\frac{\\partial F}{\\partial \\lambda}\\right] = \\left[\\frac{2u}{a^2}, \\frac{2\\lambda}{b^2}\\right].\n$$\nImplement the following three choices of the control constraint $g(u,\\lambda)$:\n\n- Load control: $g(u,\\lambda) = \\lambda - \\lambda_{\\text{target}}$ with prescribed target increment of $\\lambda$.\n- Displacement control: $g(u,\\lambda) = u - u_{\\text{target}}$ with prescribed target increment of $u$.\n- Mixed control (spherical arc-length with metric weighting): $g(u,\\lambda) = (u - u_n)^2 + \\psi\\,(\\lambda - \\lambda_n)^2 - \\Delta s^2$, where $(u_n,\\lambda_n)$ is the converged state at the previous step, $\\psi > 0$ is a weighting factor, and $\\Delta s > 0$ is the arc-length step size. For the arc-length predictor, use a unit tangent $\\mathbf{t} = [t_u,t_\\lambda]$ satisfying $\\nabla F \\cdot \\mathbf{t} = 0$, normalized with respect to the metric $\\text{diag}(1,\\psi)$.\n\nYour program must implement a generic $2\\times 2$ Newton solver for the augmented system\n$$\n\\begin{bmatrix}\nF(u,\\lambda) \\\\\ng(u,\\lambda)\n\\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix},\n$$\nusing the corresponding Jacobians for each choice of $g$.\n\nUsing $a=1.0$ and $b=0.8$, apply the solver to the following test suite. All starting points $(u_0,\\lambda_0)$ are exact points on the equilibrium curve $F=0$.\n\n- Test A (load control, expected failure at a load limit point): Start at $(u_0,\\lambda_0) = (0.866025403784,\\, 0.4)$ and perform $N=10$ steps with a fixed load increment $\\Delta \\lambda = +0.05$. At each step $k$, set $\\lambda_{\\text{target}} = \\lambda_{k-1} + \\Delta \\lambda$ and solve for $(u_k,\\lambda_k)$. Declare the test successful if and only if all $N$ steps converge to solutions of the augmented system; otherwise declare failure.\n\n- Test B (displacement control, expected failure at a displacement limit point): Start at $(u_0,\\lambda_0) = \\left(0.5,\\, 0.8\\sqrt{1-0.5^2}\\right) = \\left(0.5,\\, 0.692820323027551\\right)$ and perform $N=10$ steps with a fixed displacement increment $\\Delta u = +0.07$. At each step $k$, set $u_{\\text{target}} = u_{k-1} + \\Delta u$ and solve for $(u_k,\\lambda_k)$. Declare the test successful if and only if all $N$ steps converge; otherwise declare failure.\n\n- Test C (mixed control via spherical arc-length, expected to traverse both snap-through and snap-back segments): Start at $(u_0,\\lambda_0) = \\left(0.707106781186548,\\,-0.565685424949238\\right)$, take $\\psi = 1.0$, and use $\\Delta s = 0.1$ with a maximum of $N_{\\max} = 120$ steps. Use a predictor $t$ orthogonal to $\\nabla F$ and normalized in the metric $\\text{diag}(1,\\psi)$, with sign chosen to maintain continuity with the previous tangent. At each step, predict and then correct with Newton applied to the augmented system with the arc-length constraint $g$. Terminate successfully if the current point $(u_k,\\lambda_k)$ returns within a Euclidean distance less than $\\varepsilon_{\\text{close}} = 10^{-2}$ of the start $(u_0,\\lambda_0)$ after at least $N_{\\min} = 40$ steps; otherwise declare failure.\n\n- Test D (load control, happy path along a monotonic segment): Start at the same point as Test B, $(u_0,\\lambda_0) = \\left(0.5,\\, 0.692820323027551\\right)$, and perform $N=10$ steps with a fixed load decrement $\\Delta \\lambda = -0.05$. Declare the test successful if and only if all $N$ steps converge.\n\nFor Newton’s method, use a maximum of $50$ iterations per correction and a convergence tolerance of $10^{-10}$ on the Euclidean norm of the augmented residual vector. Treat any failure to converge within the iteration limit, any singular Jacobian solve, or any numerical overflow as a failed step.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order $[\\text{A},\\text{B},\\text{C},\\text{D}]$, where each entry is a boolean indicating the success status of that test. For example, if Tests A and B fail, Test C succeeds, and Test D succeeds, the output should be \"[False,False,True,True]\".",
            "solution": "The problem requires the implementation and comparison of three standard continuation (path-following) strategies for tracing the equilibrium path of a nonlinear system. The system is defined by a single algebraic equation $F(u,\\lambda)=0$, where $u$ is a generalized displacement and $\\lambda$ is a load parameter. The specific equilibrium path is an ellipse given by\n$$\nF(u,\\lambda) = \\left(\\frac{u}{a}\\right)^2 + \\left(\\frac{\\lambda}{b}\\right)^2 - 1 = 0\n$$\nwith given positive parameters $a$ and $b$. This curve features two load limit points (horizontal tangents) at $(u,\\lambda) = (0, \\pm b)$ and two displacement limit points (vertical tangents) at $(u,\\lambda) = (\\pm a, 0)$, which are associated with snap-through and snap-back instabilities, respectively.\n\nThe core principle of continuation methods is to augment the equilibrium equation $F(u,\\lambda)=0$ with a control constraint $g(u,\\lambda)=0$. This creates a system of two equations for the two unknowns $(u, \\lambda)$:\n$$\n\\mathbf{R}(u,\\lambda) = \\begin{bmatrix} F(u,\\lambda) \\\\ g(u,\\lambda) \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}\n$$\nThis system is solved at each step of the path-following procedure using a Newton-Raphson iterative method. The update rule for an iteration $i$ is:\n$$\n\\begin{bmatrix} u_{i+1} \\\\ \\lambda_{i+1} \\end{bmatrix} = \\begin{bmatrix} u_i \\\\ \\lambda_i \\end{bmatrix} - \\mathbf{J}^{-1}(u_i, \\lambda_i) \\mathbf{R}(u_i, \\lambda_i)\n$$\nwhere $\\mathbf{J}(u,\\lambda)$ is the $2 \\times 2$ augmented Jacobian matrix:\n$$\n\\mathbf{J}(u,\\lambda) = \\frac{\\partial \\mathbf{R}}{\\partial (u, \\lambda)} = \\begin{bmatrix}\n\\frac{\\partial F}{\\partial u}  \\frac{\\partial F}{\\partial \\lambda} \\\\\n\\frac{\\partial g}{\\partial u}  \\frac{\\partial g}{\\partial \\lambda}\n\\end{bmatrix}\n$$\nThe gradient of the equilibrium function $F$ is explicitly given as $\\nabla F(u,\\lambda) = \\left[\\frac{2u}{a^2}, \\frac{2\\lambda}{b^2}\\right]$. The program implements a generic Newton solver that takes the system function $\\mathbf{R}$ and its Jacobian $\\mathbf{J}$ as inputs, and then solves for $(u, \\lambda)$ at each step of the analysis for each test case.\n\nThe three control strategies are implemented as follows:\n1.  **Load Control**: The constraint is $g(u,\\lambda) = \\lambda - \\lambda_{\\text{target}} = 0$. This fixes the load parameter at each step. The gradient of the constraint is $\\nabla g = [0, 1]$. The augmented Jacobian is:\n    $$\n    \\mathbf{J}_{\\text{load}} = \\begin{bmatrix} \\frac{2u}{a^2}  \\frac{2\\lambda}{b^2} \\\\ 0  1 \\end{bmatrix}\n    $$\n    This matrix becomes singular when its determinant, $\\frac{2u}{a^2}$, is zero, which occurs when $u=0$. This corresponds to a load limit point (snap-through), where the equilibrium path has a horizontal tangent. At such points, load control fails. Test A is designed to encounter this failure.\n\n2.  **Displacement Control**: The constraint is $g(u,\\lambda) = u - u_{\\text{target}} = 0$, which fixes the displacement. The gradient of the constraint is $\\nabla g = [1, 0]$. The augmented Jacobian is:\n    $$\n    \\mathbf{J}_{\\text{disp}} = \\begin{bmatrix} \\frac{2u}{a^2}  \\frac{2\\lambda}{b^2} \\\\ 1  0 \\end{bmatrix}\n    $$\n    This matrix becomes singular when its determinant, $-\\frac{2\\lambda}{b^2}$, is zero, which occurs when $\\lambda=0$. This corresponds to a displacement limit point (snap-back), where the path has a vertical tangent. Displacement control fails at such points. Test B is designed to encounter this failure.\n\n3.  **Mixed (Arc-Length) Control**: This method constrains the step to lie on a sphere (a circle in this $2$D case) of radius $\\Delta s$ centered at the previously converged point $(u_n, \\lambda_n)$. The constraint is $g(u,\\lambda) = (u - u_n)^2 + \\psi(\\lambda - \\lambda_n)^2 - \\Delta s^2 = 0$. The gradient of this constraint is $\\nabla g = [2(u-u_n), 2\\psi(\\lambda-\\lambda_n)]$. The augmented Jacobian is:\n    $$\n    \\mathbf{J}_{\\text{arc}} = \\begin{bmatrix} \\frac{2u}{a^2}  \\frac{2\\lambda}{b^2} \\\\ 2(u-u_n)  2\\psi(\\lambda-\\lambda_n) \\end{bmatrix}\n    $$\n    This Jacobian is generally non-singular at both load and displacement limit points, making arc-length control a robust method for traversing complex equilibrium paths. This method uses a predictor-corrector scheme.\n    - **Predictor**: An initial guess for the next point is found by moving a distance $\\Delta s$ along the tangent to the curve at the current point $(u_n, \\lambda_n)$. The tangent vector $\\mathbf{t} = [t_u, t_\\lambda]$ is orthogonal to the gradient $\\nabla F$, i.e., $\\nabla F \\cdot \\mathbf{t} = 0$. A valid (un-normalized) tangent is $\\mathbf{t}' = [-\\frac{\\partial F}{\\partial \\lambda}, \\frac{\\partial F}{\\partial u}]$. This vector is then normalized according to the specified metric: $\\mathbf{t} = \\mathbf{t}' / \\sqrt{t_u'^2 + \\psi t_\\lambda'^2}$. To ensure the path is traced continuously without reversing direction, the sign of the tangent is chosen such that $\\mathbf{t}_k \\cdot \\mathbf{t}_{k-1} > 0$ for step $k>0$. For the first step, the sign is chosen to initiate a counter-clockwise traversal of the ellipse. The predictor point is then $(u_p, \\lambda_p) = (u_n, \\lambda_n) + \\Delta s \\cdot \\mathbf{t}$.\n    - **Corrector**: The Newton solver is used with $(u_p, \\lambda_p)$ as the initial guess to find the intersection of the equilibrium curve $F=0$ and the constraint sphere $g=0$. Test C uses this method and is expected to succeed in tracing the entire elliptical path.\n\nTest D provides a \"happy path\" scenario for load control, where the load increments move away from any limit points, demonstrating a successful application of this simple method on a monotonic segment of the equilibrium path.\n\nThe implemented program defines a generic Newton solver and then sets up four functions, one for each test case described in the problem. Each function configures the appropriate control constraint, runs the path-following loop, and reports success or failure based on the specified criteria. The final output aggregates the boolean results from all four tests.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Global parameters from the problem statement\nA = 1.0\nB = 0.8\nNEWTON_TOL = 1e-10\nNEWTON_MAX_ITER = 50\n\ndef F_func(u, lam, a, b):\n    \"\"\"The equilibrium equation F(u, lambda) = 0.\"\"\"\n    return (u / a)**2 + (lam / b)**2 - 1.0\n\ndef grad_F_func(u, lam, a, b):\n    \"\"\"The gradient of the equilibrium equation, [dF/du, dF/dlam].\"\"\"\n    return np.array([2.0 * u / a**2, 2.0 * lam / b**2])\n\ndef newton_solver(system_func, jacobian_func, initial_guess):\n    \"\"\"\n    Solves a 2x2 system of nonlinear equations using Newton's method.\n\n    Args:\n        system_func: A callable F(u, lam) that returns the residual vector [F, g].\n        jacobian_func: A callable J(u, lam) that returns the Jacobian matrix.\n        initial_guess: A tuple or array (u, lam) for the initial guess.\n\n    Returns:\n        A tuple ((u, lam), success_flag), where (u, lam) is the solution\n        and success_flag is a boolean.\n    \"\"\"\n    x_k = np.array(initial_guess, dtype=float)\n\n    for _ in range(NEWTON_MAX_ITER):\n        try:\n            # Calculate residual and check for convergence\n            R = system_func(x_k[0], x_k[1])\n            norm_R = np.linalg.norm(R)\n\n            if norm_R  NEWTON_TOL:\n                return x_k, True  # Converged successfully\n\n            # Calculate Jacobian and solve for the update\n            J = jacobian_func(x_k[0], x_k[1])\n            delta_x = np.linalg.solve(J, -R)\n            \n            x_k += delta_x\n\n            if np.any(np.isinf(x_k)) or np.any(np.isnan(x_k)):\n                return None, False # Numerical overflow detected\n\n        except np.linalg.LinAlgError:\n            return None, False  # Singular Jacobian matrix\n        except (ValueError, OverflowError):\n            return None, False  # Other numerical errors\n\n    return None, False  # Failed to converge within max iterations\n\ndef run_test_A():\n    \"\"\"Test A: Load control, expected failure at a load limit point.\"\"\"\n    u_k, lam_k = 0.866025403784, 0.4\n    delta_lam = 0.05\n    num_steps = 10\n\n    for _ in range(num_steps):\n        lam_target = lam_k + delta_lam\n        \n        def system(u, lam):\n            return np.array([F_func(u, lam, A, B), lam - lam_target])\n\n        def jacobian(u, lam):\n            grad_F = grad_F_func(u, lam, A, B)\n            return np.array([[grad_F[0], grad_F[1]], [0.0, 1.0]])\n        \n        initial_guess = np.array([u_k, lam_k])\n        solution, converged = newton_solver(system, jacobian, initial_guess)\n\n        if not converged:\n            return False\n\n        u_k, lam_k = solution\n\n    return True\n\ndef run_test_B():\n    \"\"\"Test B: Displacement control, expected failure at a displacement limit point.\"\"\"\n    u_k, lam_k = 0.5, 0.692820323027551\n    delta_u = 0.07\n    num_steps = 10\n    \n    for _ in range(num_steps):\n        u_target = u_k + delta_u\n\n        def system(u, lam):\n            return np.array([F_func(u, lam, A, B), u - u_target])\n\n        def jacobian(u, lam):\n            grad_F = grad_F_func(u, lam, A, B)\n            return np.array([[grad_F[0], grad_F[1]], [1.0, 0.0]])\n            \n        initial_guess = np.array([u_k, lam_k])\n        solution, converged = newton_solver(system, jacobian, initial_guess)\n\n        if not converged:\n            return False\n\n        u_k, lam_k = solution\n\n    return True\n\ndef run_test_C():\n    \"\"\"Test C: Mixed control (arc-length), expected to traverse the full path.\"\"\"\n    u_start, lam_start = 0.707106781186548, -0.565685424949238\n    u_n, lam_n = u_start, lam_start\n    psi = 1.0\n    ds = 0.1\n    n_max = 120\n    n_min = 40\n    eps_close = 1e-2\n\n    gradF_0 = grad_F_func(u_n, lam_n, A, B)\n    t_un_0 = np.array([-gradF_0[1], gradF_0[0]])\n    norm_t_0 = np.sqrt(t_un_0[0]**2 + psi * t_un_0[1]**2)\n    t_prev = t_un_0 / norm_t_0\n\n    for k in range(1, n_max + 1):\n        u_p, lam_p = (u_n, lam_n) + ds * t_prev\n\n        def system(u, lam):\n            return np.array([\n                F_func(u, lam, A, B),\n                (u - u_n)**2 + psi * (lam - lam_n)**2 - ds**2\n            ])\n\n        def jacobian(u, lam):\n            grad_F = grad_F_func(u, lam, A, B)\n            return np.array([\n                [grad_F[0], grad_F[1]],\n                [2.0 * (u - u_n), 2.0 * psi * (lam - lam_n)]\n            ])\n\n        solution, converged = newton_solver(system, jacobian, (u_p, lam_p))\n        \n        if not converged:\n            return False\n\n        u_n, lam_n = solution\n\n        if k = n_min:\n            dist = np.sqrt((u_n - u_start)**2 + (lam_n - lam_start)**2)\n            if dist  eps_close:\n                return True\n\n        gradF_k = grad_F_func(u_n, lam_n, A, B)\n        t_un_k = np.array([-gradF_k[1], gradF_k[0]])\n        norm_t_k = np.sqrt(t_un_k[0]**2 + psi * t_un_k[1]**2)\n        if norm_t_k  1e-12: return False\n        \n        t_k = t_un_k / norm_t_k\n        \n        if np.dot(t_k, t_prev)  0:\n            t_k = -t_k\n        \n        t_prev = t_k\n        \n    return False\n\ndef run_test_D():\n    \"\"\"Test D: Load control, happy path along a monotonic segment.\"\"\"\n    u_k, lam_k = 0.5, 0.692820323027551\n    delta_lam = -0.05\n    num_steps = 10\n\n    for _ in range(num_steps):\n        lam_target = lam_k + delta_lam\n\n        def system(u, lam):\n            return np.array([F_func(u, lam, A, B), lam - lam_target])\n\n        def jacobian(u, lam):\n            grad_F = grad_F_func(u, lam, A, B)\n            return np.array([[grad_F[0], grad_F[1]], [0.0, 1.0]])\n        \n        initial_guess = np.array([u_k, lam_k])\n        solution, converged = newton_solver(system, jacobian, initial_guess)\n\n        if not converged:\n            return False\n\n        u_k, lam_k = solution\n\n    return True\n\ndef solve():\n    \"\"\"\n    Executes the test suite and prints the final results.\n    \"\"\"\n    test_cases_funcs = [\n        run_test_A,\n        run_test_B,\n        run_test_C,\n        run_test_D,\n    ]\n\n    results = []\n    for test_func in test_cases_funcs:\n        results.append(test_func())\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A successful path-following simulation generates a sequence of equilibrium states, but the analysis is incomplete without a clear interpretation of the critical points encountered. This final practice shifts our focus from path-tracing to path-analysis, equipping you with an algorithm to automatically detect and classify instabilities. Using only the discrete output from a continuation analysis (the load parameter and the tangent stiffness matrix), you will learn to distinguish between limit points, which characterize snap-through and snap-back, and symmetry-breaking bifurcations . This exercise develops the crucial skill of translating raw numerical data into a physical diagnosis of a structure's stability.",
            "id": "3600883",
            "problem": "You are given a continuation sequence of discrete states indexed by a pseudo-arc-length parameter $s$ for a nonlinear equilibrium path in computational solid mechanics. Let $\\mathbf{u}(s)$ be the vector of generalized displacements and $\\lambda(s)$ be a scalar load parameter. The equilibrium condition is given by the nonlinear residual $\\mathbf{R}(\\mathbf{u},\\lambda)=\\mathbf{0}$, and the tangent stiffness is $\\mathbf{K}_T(\\mathbf{u},\\lambda)=\\partial \\mathbf{R}/\\partial \\mathbf{u}$. For numerical continuation, the symmetric part of the tangent stiffness is defined as $\\mathbf{S}=\\tfrac{1}{2}\\left(\\mathbf{K}_T+\\mathbf{K}_T^{\\mathsf{T}}\\right)$. Denote by $\\mu_{\\min}(s)$ the smallest eigenvalue of $\\mathbf{S}$ at parameter value $s$.\n\nYour task is to design and implement a robust, purely algorithmic criterion that classifies the type of bifurcation encountered along the path using only the provided discrete samples $\\{s_k,\\lambda_k,\\mathbf{K}_{T,k}\\}$. Rely solely on fundamental principles: loss of positive definiteness is indicated by $\\mu_{\\min}(s)\\to 0$, and turning points in the load path satisfy $\\mathrm{d}\\lambda/\\mathrm{d}s=0$. You must:\n\n- Approximate $\\mathrm{d}\\lambda/\\mathrm{d}s$ at each sample using finite differences on the $s$-grid.\n- Compute $\\mu_{\\min}$ at each sample from the symmetric part of $\\mathbf{K}_T$ using eigenvalue analysis.\n- Declare the event classification for each test case as follows:\n  - If there exists at least one $s$ where $|\\mathrm{d}\\lambda/\\mathrm{d}s|$ is numerically zero within a prescribed tolerance and this indicates a turning point of $\\lambda(s)$, classify the case as a limit point. This corresponds to detecting snap-through or snap-back where $\\mathrm{d}\\lambda/\\mathrm{d}s=0$.\n  - Else, if $\\mu_{\\min}(s)$ changes sign across samples (i.e., there exist samples with $\\mu_{\\min}>0$ and others with $\\mu_{\\min}0$) within a prescribed tolerance, classify the case as a symmetry-breaking bifurcation. This corresponds to branching instabilities where the smallest eigenvalue of the symmetric stiffness passes through zero and changes sign along the path while the load parameter continues monotonically.\n  - Else, classify the case as no detected bifurcation in the given sample window.\n\nYour program must implement reasonable numerical tolerances for both checks. Use a derivative tolerance $\\tau_{\\lambda'}=10^{-3}$ for $|\\mathrm{d}\\lambda/\\mathrm{d}s|$ and an eigenvalue tolerance $\\tau_{\\mu}=10^{-6}$ for $\\mu_{\\min}$ comparisons. You must use central differences for interior points and one-sided differences at endpoints for the approximation of $\\mathrm{d}\\lambda/\\mathrm{d}s$.\n\nTest Suite. Implement your algorithm on the following three test cases. For each case, you are given discrete samples of $s$, $\\lambda$, and $\\mathbf{K}_T$ (matrices), all dimensionless. The eigen-analysis must be performed on $\\mathbf{S}_k=\\tfrac{1}{2}\\left(\\mathbf{K}_{T,k}+\\mathbf{K}_{T,k}^{\\mathsf{T}}\\right)$.\n\n- Case A (limit point candidate):\n  - $s=\\left[0.8,\\,0.9,\\,1.0,\\,1.1,\\,1.2\\right]$\n  - $\\lambda(s)=1-(s-1)^2$ sampled at the given $s$; that is, $\\lambda=\\left[0.96,\\,0.99,\\,1.0,\\,0.99,\\,0.96\\right]$\n  - $\\mathbf{K}_T(s)$ is scalar $1\\times 1$ with $\\mathbf{K}_T=s-1$ at each $s$; that is, $\\mathbf{K}_T=\\left[-0.2,\\,-0.1,\\,0.0,\\,0.1,\\,0.2\\right]$\n- Case B (symmetry-breaking candidate):\n  - $s=\\left[0.9,\\,0.95,\\,1.0,\\,1.05\\right]$\n  - $\\lambda(s)=s$ sampled at the given $s$; that is, $\\lambda=\\left[0.9,\\,0.95,\\,1.0,\\,1.05\\right]$\n  - $\\mathbf{K}_T(s)$ is $2\\times 2$ diagonal with entries $\\left[s-1,\\,1\\right]$ at each $s$; for example at $s=0.9$, $\\mathbf{K}_T=\\begin{bmatrix}-0.10\\\\01\\end{bmatrix}$, and similarly for the other samples\n- Case C (no event in window):\n  - $s=\\left[0.0,\\,0.5,\\,1.0\\right]$\n  - $\\lambda(s)=s+0.2$ sampled at the given $s$; that is, $\\lambda=\\left[0.2,\\,0.7,\\,1.2\\right]$\n  - $\\mathbf{K}_T(s)$ is $2\\times 2$ diagonal with entries $\\left[1,\\,2\\right]$ at each $s$; that is, $\\mathbf{K}_T=\\begin{bmatrix}10\\\\02\\end{bmatrix}$ at all samples\n\nYour program should output a single classification per case using the integer codes:\n- $1$ for a limit point (snap-through or snap-back turning point detected by $\\mathrm{d}\\lambda/\\mathrm{d}s\\approx 0$),\n- $2$ for a symmetry-breaking bifurcation (sign change of $\\mu_{\\min}$),\n- $0$ for no detected event.\n\nIf multiple criteria are simultaneously satisfied in a case, you must prioritize declaring a limit point (code $1$) over a symmetry-breaking bifurcation (code $2$). For each case, process the provided $(s,\\lambda,\\mathbf{K}_T)$ arrays and report a single integer code.\n\nFinal Output Format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for the cases A, B, C in this order; for example, the format must be exactly like $\\left[\\text{result\\_A},\\text{result\\_B},\\text{result\\_C}\\right]$.",
            "solution": "The problem statement has been critically validated and is determined to be valid. It is scientifically grounded in the principles of computational solid mechanics, is well-posed with a clear and objective set of requirements, and contains all necessary data for a unique solution. The task is to construct and implement an algorithm for classifying instability events along a discrete nonlinear equilibrium path.\n\nThe objective is to formulate a purely algorithmic criterion to distinguish between limit points (snap-through/snap-back phenomena) and symmetry-breaking bifurcations using a discrete sequence of states $\\{s_k, \\lambda_k, \\mathbf{K}_{T,k}\\}$. Here, $s_k$ is the $k$-th sample of the pseudo-arc-length parameter, $\\lambda_k$ is the corresponding load parameter, and $\\mathbf{K}_{T,k}$ is the tangent stiffness matrix. The classification relies on fundamental principles of structural stability.\n\nAn equilibrium path of a mechanical system is a curve in the state space of displacements $\\mathbf{u}$ and load parameter $\\lambda$, defined by the condition that the residual force vector $\\mathbf{R}(\\mathbf{u}, \\lambda)$ is zero. In numerical continuation methods, this path is parameterized by an arc-length parameter $s$, yielding $(\\mathbf{u}(s), \\lambda(s))$. Instabilities, or critical points, are points on this path where the solution character changes.\n\nTwo primary types of critical points are considered:\n$1$. **Limit Points**: These are points where the load parameter $\\lambda$ reaches a local extremum along the path. At a limit point, the tangent to the path with respect to the load parameter axis is horizontal, which mathematically corresponds to the condition $\\mathrm{d}\\lambda/\\mathrm{d}s = 0$. Such points are often associated with snap-through or snap-back instabilities.\n$2$. **Bifurcation Points**: These are points where multiple distinct equilibrium paths intersect. A necessary condition for bifurcation is the singularity of the tangent stiffness matrix $\\mathbf{K}_T = \\partial\\mathbf{R}/\\partial\\mathbf{u}$. In general, stability of an equilibrium state is assessed by the positive-definiteness of the symmetric part of the tangent stiffness matrix, $\\mathbf{S} = \\frac{1}{2}(\\mathbf{K}_T + \\mathbf{K}_T^\\mathsf{T})$. A loss of stability occurs when $\\mathbf{S}$ ceases to be positive definite, which is signaled by its smallest eigenvalue, $\\mu_{\\min}$, passing through zero. For a symmetry-breaking bifurcation, this loss of stability occurs while the load parameter may be changing monotonically (i.e., $\\mathrm{d}\\lambda/\\mathrm{d}s \\neq 0$).\n\nBased on these principles, the following three-step algorithm is designed to classify the event type for a given test case.\n\n**Step 1: Limit Point Detection**\nThe first step is to check for the presence of a limit point. Since we have discrete samples $(\\lambda_k, s_k)$, the derivative $\\mathrm{d}\\lambda/\\mathrm{d}s$ must be approximated numerically. We use finite difference formulas that are second-order accurate for interior points and first-order accurate for endpoints:\n- For an interior point $k$ ($0  k  N-1$): A central difference is used, $\\frac{\\mathrm{d}\\lambda}{\\mathrm{d}s}\\bigg|_{s_k} \\approx \\frac{\\lambda_{k+1} - \\lambda_{k-1}}{s_{k+1} - s_{k-1}}$.\n- For the first point $k=0$: A forward difference is used, $\\frac{\\mathrm{d}\\lambda}{\\mathrm{d}s}\\bigg|_{s_0} \\approx \\frac{\\lambda_1 - \\lambda_0}{s_1 - s_0}$.\n- For the last point $k=N-1$: A backward difference is used, $\\frac{\\mathrm{d}\\lambda}{\\mathrm{d}s}\\bigg|_{s_{N-1}} \\approx \\frac{\\lambda_{N-1} - \\lambda_{N-2}}{s_{N-1} - s_{N-2}}$.\nA limit point is detected if, for any sample $k$, the magnitude of the approximated derivative is numerically close to zero. The condition is $|\\mathrm{d}\\lambda/\\mathrm{d}s|_k  \\tau_{\\lambda'}$, where $\\tau_{\\lambda'} = 10^{-3}$ is the prescribed tolerance.\n\n**Step 2: Symmetry-Breaking Bifurcation Detection**\nIf no limit point is detected, the algorithm checks for a symmetry-breaking bifurcation. This involves analyzing the eigenvalues of the symmetric stiffness matrix $\\mathbf{S}_k$ at each sample point $k$.\nFor each sample $k$:\n- First, the symmetric part of the tangent stiffness matrix is computed: $\\mathbf{S}_k = \\frac{1}{2}(\\mathbf{K}_{T,k} + \\mathbf{K}_{T,k}^\\mathsf{T})$.\n- Next, the eigenvalues of this real symmetric matrix $\\mathbf{S}_k$ are calculated.\n- The smallest eigenvalue, $\\mu_{\\min, k}$, is identified.\nA bifurcation is detected if the sequence of smallest eigenvalues $\\{\\mu_{\\min, k}\\}$ changes sign across the sampled range. This is tested by checking if there exists at least one sample $i$ where $\\mu_{\\min, i}  -\\tau_{\\mu}$ and at least one sample $j$ where $\\mu_{\\min, j} > \\tau_{\\mu}$. The prescribed tolerance is $\\tau_{\\mu} = 10^{-6}$.\n\n**Step 3: Classification and Prioritization**\nThe final classification is made according to a strict priority rule:\n- If a limit point is detected in Step 1, the case is classified as a limit point (code $1$), and the process for this case terminates.\n- Else, if a symmetry-breaking bifurcation is detected in Step 2, the case is classified as such (code $2$).\n- Otherwise, if neither of the above conditions is met, it is concluded that no event was detected within the given sample window (code $0$).\n\n**Application to Test Cases**\n\n- **Case A**:\n  - $s=\\left[0.8,\\,0.9,\\,1.0,\\,1.1,\\,1.2\\right]$, $\\lambda=\\left[0.96,\\,0.99,\\,1.0,\\,0.99,\\,0.96\\right]$.\n  - Limit point check: The derivative $\\mathrm{d}\\lambda/\\mathrm{d}s$ is approximated at each point. At $s=1.0$, the central difference is $(\\lambda_{1.1} - \\lambda_{0.9})/(1.1 - 0.9) = (0.99 - 0.99)/0.2 = 0$. Since $|0|  10^{-3}$, a limit point is detected. The classification is $1$. Even though the eigenvalues of $\\mathbf{K}_T = \\mathbf{S}$ are $[-0.2, -0.1, 0.0, 0.1, 0.2]$, which show a sign change, the limit point criterion takes priority.\n\n- **Case B**:\n  - $s=\\left[0.9,\\,0.95,\\,1.0,\\,1.05\\right]$, $\\lambda=\\left[0.9,\\,0.95,\\,1.0,\\,1.05\\right]$.\n  - Limit point check: $\\lambda(s)=s$, so $\\mathrm{d}\\lambda/\\mathrm{d}s=1$. All finite difference approximations yield values close to $1$, so no derivative is close to zero. No limit point is detected.\n  - Bifurcation check: $\\mathbf{K}_T$ is diagonal, hence symmetric ($\\mathbf{S}_k = \\mathbf{K}_{T,k}$). The eigenvalues are its diagonal entries, $[s-1, 1]$. The smallest eigenvalue is $\\mu_{\\min}(s) = s-1$. The sequence of smallest eigenvalues for the given $s$ values is $[-0.1, -0.05, 0.0, 0.05]$. This sequence contains values less than $-\\tau_{\\mu}$ (e.g., $-0.1$) and values greater than $\\tau_{\\mu}$ (e.g., $0.05$). A sign change is detected. The classification is $2$.\n\n- **Case C**:\n  - $s=\\left[0.0,\\,0.5,\\,1.0\\right]$, $\\lambda=\\left[0.2,\\,0.7,\\,1.2\\right]$.\n  - Limit point check: $\\lambda(s) = s+0.2$, so $\\mathrm{d}\\lambda/\\mathrm{d}s=1$. All approximations are far from zero. No limit point is detected.\n  - Bifurcation check: $\\mathbf{K}_T = \\begin{bmatrix}10\\\\02\\end{bmatrix}$ is constant and symmetric. The eigenvalues are $1$ and $2$ for all samples. The smallest eigenvalue is $\\mu_{\\min, k}=1$ for all $k$. The sequence of smallest eigenvalues is $[1, 1, 1]$. There is no sign change. No bifurcation is detected. The classification is $0$.\n\nThe final results for cases A, B, and C are therefore $[1, 2, 0]$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the bifurcation classification problem for the given test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: limit point candidate\n        {\n            \"s\": np.array([0.8, 0.9, 1.0, 1.1, 1.2]),\n            \"lambda\": np.array([0.96, 0.99, 1.0, 0.99, 0.96]),\n            \"K_T\": [\n                np.atleast_2d(-0.2), \n                np.atleast_2d(-0.1), \n                np.atleast_2d(0.0), \n                np.atleast_2d(0.1), \n                np.atleast_2d(0.2)\n            ]\n        },\n        # Case B: symmetry-breaking candidate\n        {\n            \"s\": np.array([0.9, 0.95, 1.0, 1.05]),\n            \"lambda\": np.array([0.9, 0.95, 1.0, 1.05]),\n            \"K_T\": [\n                np.diag([0.9 - 1.0, 1.0]),\n                np.diag([0.95 - 1.0, 1.0]),\n                np.diag([1.0 - 1.0, 1.0]),\n                np.diag([1.05 - 1.0, 1.0]),\n            ]\n        },\n        # Case C: no event in window\n        {\n            \"s\": np.array([0.0, 0.5, 1.0]),\n            \"lambda\": np.array([0.2, 0.7, 1.2]),\n            \"K_T\": [\n                np.diag([1.0, 2.0]),\n                np.diag([1.0, 2.0]),\n                np.diag([1.0, 2.0]),\n            ]\n        }\n    ]\n\n    results = []\n    \n    # Numerical tolerances\n    tau_lambda_prime = 1e-3\n    tau_mu = 1e-6\n\n    for case in test_cases:\n        s_k = case[\"s\"]\n        lambda_k = case[\"lambda\"]\n        K_T_k_list = case[\"K_T\"]\n\n        # --- Step 1: Limit Point Detection ---\n        # Approximate d(lambda)/ds using finite differences.\n        # np.gradient uses central differences for interior points and\n        # one-sided differences at the boundaries, as specified.\n        d_lambda_ds = np.gradient(lambda_k, s_k)\n        \n        limit_point_detected = np.any(np.abs(d_lambda_ds)  tau_lambda_prime)\n\n        # --- Step 2: Symmetry-Breaking Bifurcation Detection ---\n        mu_mins = []\n        for K_T in K_T_k_list:\n            # S = 0.5 * (K_T + K_T^T)\n            S = 0.5 * (K_T + K_T.T)\n            \n            # Compute eigenvalues of the symmetric matrix S.\n            # eigvalsh is optimized for real symmetric/Hermitian matrices.\n            eigenvalues = np.linalg.eigvalsh(S)\n            \n            # Find the minimum eigenvalue\n            mu_min = np.min(eigenvalues)\n            mu_mins.append(mu_min)\n        \n        mu_mins = np.array(mu_mins)\n        \n        # Check for sign change in the smallest eigenvalue across samples\n        bifurcation_detected = np.any(mu_mins  tau_mu) and np.any(mu_mins  -tau_mu)\n\n        # --- Step 3: Classification with Prioritization ---\n        if limit_point_detected:\n            results.append(1)\n        elif bifurcation_detected:\n            results.append(2)\n        else:\n            results.append(0)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}