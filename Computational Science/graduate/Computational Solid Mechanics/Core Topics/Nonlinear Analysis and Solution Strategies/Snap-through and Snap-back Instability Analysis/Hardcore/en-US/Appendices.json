{
    "hands_on_practices": [
        {
            "introduction": "Understanding structural instability begins with grasping its mechanical origins in simple systems. This exercise analyzes a classic two-bar truss, a canonical example where geometric nonlinearity interacts with a softening material response to produce snap-back instability. By deriving the exact load-displacement relationship from first principles, you will gain fundamental insight into how limit points arise on the equilibrium path .",
            "id": "3600896",
            "problem": "A symmetric pin-jointed two-bar truss is formed by two identical straight members of undeformed length connecting fixed supports at coordinates $\\left(-a,0\\right)$ and $\\left(a,0\\right)$ to a common apex initially located at $\\left(0,h_0\\right)$, where $a0$ and $h_00$. Each member is axially deformable with constant cross-sectional area $A$ and obeys the softening linear stress–strain law $\\sigma=\\sigma_0+H\\,\\varepsilon$ with $H0$ and constant $\\sigma_0$, where $\\varepsilon$ is the Green–Lagrange axial strain taken here in the small-strain limit as the axial engineering strain $\\varepsilon=\\left(\\ell-L_0\\right)/L_0$, with $L_0=\\sqrt{a^2+h_0^2}$ the initial member length and $\\ell$ its current length. The apex is displaced vertically downward by a prescribed displacement $w$ (so its current vertical coordinate is $h=h_0-w$), and the corresponding reaction load $P$ is measured in the vertical direction at the apex, under quasi-static conditions. Assume plane pin-jointed behavior with axial forces only and neglect body forces, shear deformation, and bending.\n\nUsing only equilibrium, compatibility, and the stated constitutive relation:\n- Derive the exact global load–displacement relation $P(w)$ for this system in closed form in terms of $a$, $h_0$, $A$, $\\sigma_0$, $H$, and $w$.\n- Determine the onset of snap-back under load control by finding the critical downward apex displacement $w_{\\mathrm{cr}}$ at which the global load–displacement curve develops a horizontal tangent. Provide a single closed-form analytic expression for $w_{\\mathrm{cr}}$.\n\nExpress the displacement $w_{\\mathrm{cr}}$ in meters. Do not insert any numerical values. The final answer must be a single closed-form analytic expression.",
            "solution": "The problem is valid as it describes a well-posed physical system in structural mechanics and seeks a derivable analytical result based on the provided principles of equilibrium, compatibility, and material constitution.\n\nThe solution proceeds in two parts: first, deriving the global load-displacement relation $P(w)$, and second, finding the critical displacement $w_{\\mathrm{cr}}$ for the onset of snap-back by analyzing this relation.\n\n**Part 1: Derivation of the Load-Displacement Relation $P(w)$**\n\n**1. Kinematics and Compatibility**\nThe initial geometry consists of two members of length $L_0$ connecting supports at $(\\pm a, 0)$ to an apex at $(0, h_0)$. The initial length of each member is given by the Pythagorean theorem:\n$$L_0 = \\sqrt{a^2 + h_0^2}$$\nWhen the apex is displaced vertically downward by a distance $w$, its new coordinates are $(0, h)$, where the current height $h$ is:\n$$h = h_0 - w$$\nThe current length of each member, $\\ell$, can be found from the new geometry:\n$$\\ell(w) = \\sqrt{a^2 + h^2} = \\sqrt{a^2 + (h_0 - w)^2}$$\nThe axial engineering strain $\\varepsilon$ is defined as the change in length divided by the original length:\n$$\\varepsilon = \\frac{\\ell - L_0}{L_0} = \\frac{\\sqrt{a^2 + (h_0 - w)^2} - \\sqrt{a^2 + h_0^2}}{\\sqrt{a^2 + h_0^2}}$$\n\n**2. Constitutive Relation**\nThe axial stress $\\sigma$ in each member is given by the specified linear softening law:\n$$\\sigma = \\sigma_0 + H\\,\\varepsilon$$\nwhere $\\sigma_0$ is a constant and $H  0$. The axial force $F$ in each member, with cross-sectional area $A$, is:\n$$F = \\sigma A = A(\\sigma_0 + H\\,\\varepsilon)$$\nSubstituting the expression for strain $\\varepsilon$:\n$$F(w) = A\\left(\\sigma_0 + H \\left(\\frac{\\ell(w)}{L_0} - 1\\right)\\right) = A\\left(\\sigma_0 - H + \\frac{H}{L_0}\\ell(w)\\right)$$\n\n**3. Equilibrium**\nAt the apex, the externally applied vertical load $P$ must be balanced by the vertical components of the axial forces from the two members. By symmetry, the horizontal force components cancel. Let $\\theta$ be the angle between a member and the horizontal axis. The vertical equilibrium equation is:\n$$P = 2 F \\sin(\\theta)$$\nFrom the geometry, $\\sin(\\theta)$ is the ratio of the current apex height $h$ to the current member length $\\ell$:\n$$\\sin(\\theta) = \\frac{h}{\\ell} = \\frac{h_0 - w}{\\sqrt{a^2 + (h_0 - w)^2}}$$\nSubstituting the expressions for $F(w)$ and $\\sin(\\theta)$ into the equilibrium equation yields the load-displacement relation $P(w)$:\n$$P(w) = 2 \\left[ A\\left(\\sigma_0 - H + \\frac{H}{L_0}\\ell(w)\\right) \\right] \\frac{h_0 - w}{\\ell(w)}$$\nDistributing the term $\\frac{h_0 - w}{\\ell(w)}$ gives:\n$$P(w) = 2A \\left( (\\sigma_0 - H)\\frac{h_0 - w}{\\ell(w)} + \\frac{H}{L_0}(h_0 - w) \\right)$$\nSubstituting the full expressions for $\\ell(w)$ and $L_0$, we obtain the final closed-form relation:\n$$P(w) = 2A(h_0 - w) \\left( \\frac{\\sigma_0 - H}{\\sqrt{a^2 + (h_0 - w)^2}} + \\frac{H}{\\sqrt{a^2 + h_0^2}} \\right)$$\n\n**Part 2: Determination of the Critical Displacement $w_{\\mathrm{cr}}$**\n\nThe onset of snap-back under load control corresponds to a limit point on the load-displacement curve, which is characterized by a horizontal tangent. Mathematically, this occurs where the derivative of the load $P$ with respect to the displacement $w$ is zero:\n$$\\frac{dP}{dw} = 0$$\nWe differentiate the expression for $P(w)$ with respect to $w$. Let's analyze the two terms inside the parentheses in the expression for $P(w) / (2A)$:\n$$P(w) / (2A) = (\\sigma_0 - H)\\frac{h_0 - w}{\\sqrt{a^2 + (h_0 - w)^2}} + \\frac{H}{L_0}(h_0 - w)$$\nThe derivative of the second term is straightforward:\n$$\\frac{d}{dw}\\left[\\frac{H}{L_0}(h_0 - w)\\right] = -\\frac{H}{L_0}$$\nFor the first term, we use the quotient rule and chain rule. Let $u = h_0 - w$, so $\\frac{du}{dw} = -1$. The term is $\\frac{u}{\\sqrt{a^2 + u^2}}$.\n$$\\frac{d}{du}\\left(\\frac{u}{\\sqrt{a^2 + u^2}}\\right) = \\frac{1 \\cdot \\sqrt{a^2 + u^2} - u \\cdot \\frac{u}{\\sqrt{a^2 + u^2}}}{a^2 + u^2} = \\frac{(a^2 + u^2) - u^2}{(a^2 + u^2)^{3/2}} = \\frac{a^2}{(a^2 + u^2)^{3/2}}$$\nUsing the chain rule, the derivative with respect to $w$ is:\n$$\\frac{d}{dw}\\left(\\frac{h_0 - w}{\\sqrt{a^2 + (h_0 - w)^2}}\\right) = \\frac{a^2}{(a^2 + (h_0-w)^2)^{3/2}} \\cdot (-1) = \\frac{-a^2}{\\ell(w)^3}$$\nCombining the derivatives, we get:\n$$\\frac{dP}{dw} = 2A \\left[ (\\sigma_0 - H)\\left(\\frac{-a^2}{\\ell(w)^3}\\right) - \\frac{H}{L_0} \\right]$$\nSetting $\\frac{dP}{dw} = 0$ gives the condition for the critical displacement $w_{\\mathrm{cr}}$:\n$$-(\\sigma_0 - H)\\frac{a^2}{\\ell_{\\mathrm{cr}}^3} - \\frac{H}{L_0} = 0$$\nwhere $\\ell_{\\mathrm{cr}} = \\ell(w_{\\mathrm{cr}})$. Rearranging to solve for $\\ell_{\\mathrm{cr}}^3$:\n$$-(\\sigma_0 - H)a^2 L_0 = H \\ell_{\\mathrm{cr}}^3$$\n$$\\ell_{\\mathrm{cr}}^3 = -\\frac{(\\sigma_0 - H)}{H} a^2 L_0 = \\frac{H - \\sigma_0}{H} a^2 L_0 = \\left(1 - \\frac{\\sigma_0}{H}\\right) a^2 L_0$$\nThe critical member length $\\ell_{\\mathrm{cr}}$ is therefore:\n$$\\ell_{\\mathrm{cr}} = \\left[ \\left(1 - \\frac{\\sigma_0}{H}\\right) a^2 L_0 \\right]^{1/3}$$\nTo find the critical displacement $w_{\\mathrm{cr}}$, we use the kinematic relation $\\ell_{\\mathrm{cr}}^2 = a^2 + (h_0 - w_{\\mathrm{cr}})^2$.\n$$(h_0 - w_{\\mathrm{cr}})^2 = \\ell_{\\mathrm{cr}}^2 - a^2$$\nAssuming the first critical point occurs before the apex inverts (i.e., $h_0 - w_{\\mathrm{cr}}  0$), we take the positive root:\n$$h_0 - w_{\\mathrm{cr}} = \\sqrt{\\ell_{\\mathrm{cr}}^2 - a^2}$$\n$$w_{\\mathrm{cr}} = h_0 - \\sqrt{\\ell_{\\mathrm{cr}}^2 - a^2}$$\nSubstituting the expression for $\\ell_{\\mathrm{cr}}$:\n$$w_{\\mathrm{cr}} = h_0 - \\sqrt{\\left( \\left[ \\left(1 - \\frac{\\sigma_0}{H}\\right) a^2 L_0 \\right]^{1/3} \\right)^2 - a^2}$$\n$$w_{\\mathrm{cr}} = h_0 - \\sqrt{\\left[ \\left(1 - \\frac{\\sigma_0}{H}\\right) a^2 L_0 \\right]^{2/3} - a^2}$$\nFinally, substituting $L_0 = \\sqrt{a^2 + h_0^2}$ gives the complete expression for $w_{\\mathrm{cr}}$ in terms of the given parameters:\n$$w_{\\mathrm{cr}} = h_0 - \\sqrt{\\left[ \\left(1 - \\frac{\\sigma_0}{H}\\right) a^2 \\sqrt{a^2 + h_0^2} \\right]^{\\frac{2}{3}} - a^2}$$\nThis is the required single closed-form analytic expression for the critical displacement.",
            "answer": "$$\n\\boxed{h_0 - \\sqrt{\\left( a^2 \\left(1 - \\frac{\\sigma_0}{H}\\right) \\sqrt{a^2 + h_0^2} \\right)^{\\frac{2}{3}} - a^2}}\n$$"
        },
        {
            "introduction": "Tracing the full equilibrium path of a structure, including its unstable segments, requires specialized numerical techniques. Standard load or displacement control methods often fail when they encounter limit points characteristic of snap-through and snap-back. This practice focuses on the core path-following algorithms themselves, using a simple algebraic model to demonstrate why arc-length control is a robust and essential tool for navigating these critical points in nonlinear analysis .",
            "id": "3600849",
            "problem": "Consider the reduced-order tracing of nonlinear equilibrium paths in a one-parameter family of equilibria defined implicitly by the single algebraic equation\n$$\nF(u,\\lambda) = \\left(\\frac{u}{a}\\right)^2 + \\left(\\frac{\\lambda}{b}\\right)^2 - 1 = 0,\n$$\nwhere $u$ is a generalized displacement, $\\lambda$ is a generalized load factor, and $a0$, $b0$ are given shape parameters. This implicit curve has both horizontal tangents (load limit points, associated with snap-through when controlling $\\lambda$) and vertical tangents (displacement limit points, associated with snap-back when controlling $u$). The problem is to implement an augmented Newton solver with a second constraint equation $g(u,\\lambda)=0$ to enforce different control strategies and to assess their capability to traverse limit-point segments. All quantities in this problem are dimensionless.\n\nStart from fundamental continuation principles: the equilibrium condition is $F(u,\\lambda)=0$, and continuation augments it with a scalar control constraint $g(u,\\lambda)=0$ so that the unknown vector $(u,\\lambda)$ is determined by solving a $2\\times 2$ system at each step via Newton's method. Let the Jacobian of $F$ be the gradient\n$$\n\\nabla F(u,\\lambda) = \\left[\\frac{\\partial F}{\\partial u}, \\frac{\\partial F}{\\partial \\lambda}\\right] = \\left[\\frac{2u}{a^2}, \\frac{2\\lambda}{b^2}\\right].\n$$\nImplement the following three choices of the control constraint $g(u,\\lambda)$:\n\n- Load control: $g(u,\\lambda) = \\lambda - \\lambda_{\\text{target}}$ with prescribed target increment of $\\lambda$.\n- Displacement control: $g(u,\\lambda) = u - u_{\\text{target}}$ with prescribed target increment of $u$.\n- Mixed control (spherical arc-length with metric weighting): $g(u,\\lambda) = (u - u_n)^2 + \\psi\\,(\\lambda - \\lambda_n)^2 - \\Delta s^2$, where $(u_n,\\lambda_n)$ is the converged state at the previous step, $\\psi  0$ is a weighting factor, and $\\Delta s  0$ is the arc-length step size. For the arc-length predictor, use a unit tangent $\\mathbf{t} = [t_u,t_\\lambda]$ satisfying $\\nabla F \\cdot \\mathbf{t} = 0$, normalized with respect to the metric $\\text{diag}(1,\\psi)$.\n\nYour program must implement a generic $2\\times 2$ Newton solver for the augmented system\n$$\n\\begin{bmatrix}\nF(u,\\lambda) \\\\\ng(u,\\lambda)\n\\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix},\n$$\nusing the corresponding Jacobians for each choice of $g$.\n\nUsing $a=1.0$ and $b=0.8$, apply the solver to the following test suite. All starting points $(u_0,\\lambda_0)$ are exact points on the equilibrium curve $F=0$.\n\n- Test A (load control, expected failure at a load limit point): Start at $(u_0,\\lambda_0) = (0.866025403784,\\, 0.4)$ and perform $N=10$ steps with a fixed load increment $\\Delta \\lambda = +0.05$. At each step $k$, set $\\lambda_{\\text{target}} = \\lambda_{k-1} + \\Delta \\lambda$ and solve for $(u_k,\\lambda_k)$. Declare the test successful if and only if all $N$ steps converge to solutions of the augmented system; otherwise declare failure.\n\n- Test B (displacement control, expected failure at a displacement limit point): Start at $(u_0,\\lambda_0) = \\left(0.5,\\, 0.8\\sqrt{1-0.5^2}\\right) = \\left(0.5,\\, 0.692820323027551\\right)$ and perform $N=10$ steps with a fixed displacement increment $\\Delta u = +0.07$. At each step $k$, set $u_{\\text{target}} = u_{k-1} + \\Delta u$ and solve for $(u_k,\\lambda_k)$. Declare the test successful if and only if all $N$ steps converge; otherwise declare failure.\n\n- Test C (mixed control via spherical arc-length, expected to traverse both snap-through and snap-back segments): Start at $(u_0,\\lambda_0) = \\left(0.707106781186548,\\,-0.565685424949238\\right)$, take $\\psi = 1.0$, and use $\\Delta s = 0.1$ with a maximum of $N_{\\max} = 120$ steps. Use a predictor $\\mathbf{t}$ orthogonal to $\\nabla F$ and normalized in the metric $\\text{diag}(1,\\psi)$, with sign chosen to maintain continuity with the previous tangent. At each step, predict and then correct with Newton applied to the augmented system with the arc-length constraint $g$. Terminate successfully if the current point $(u_k,\\lambda_k)$ returns within a Euclidean distance less than $\\varepsilon_{\\text{close}} = 10^{-2}$ of the start $(u_0,\\lambda_0)$ after at least $N_{\\min} = 40$ steps; otherwise declare failure.\n\n- Test D (load control, happy path along a monotonic segment): Start at the same point as Test B, $(u_0,\\lambda_0) = \\left(0.5,\\, 0.692820323027551\\right)$, and perform $N=10$ steps with a fixed load decrement $\\Delta \\lambda = -0.05$. Declare the test successful if and only if all $N$ steps converge.\n\nFor Newton’s method, use a maximum of $50$ iterations per correction and a convergence tolerance of $10^{-10}$ on the Euclidean norm of the augmented residual vector. Treat any failure to converge within the iteration limit, any singular Jacobian solve, or any numerical overflow as a failed step.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order $[\\text{A},\\text{B},\\text{C},\\text{D}]$, where each entry is a boolean indicating the success status of that test. For example, if Tests A and B fail, Test C succeeds, and Test D succeeds, the output should be \"[False,False,True,True]\".",
            "solution": "The problem requires the implementation and comparison of three standard continuation (path-following) strategies for tracing the equilibrium path of a nonlinear system. The system is defined by a single algebraic equation $F(u,\\lambda)=0$, where $u$ is a generalized displacement and $\\lambda$ is a load parameter. The specific equilibrium path is an ellipse given by\n$$\nF(u,\\lambda) = \\left(\\frac{u}{a}\\right)^2 + \\left(\\frac{\\lambda}{b}\\right)^2 - 1 = 0\n$$\nwith given positive parameters $a$ and $b$. This curve features two load limit points (horizontal tangents) at $(u,\\lambda) = (0, \\pm b)$ and two displacement limit points (vertical tangents) at $(u,\\lambda) = (\\pm a, 0)$, which are associated with snap-through and snap-back instabilities, respectively.\n\nThe core principle of continuation methods is to augment the equilibrium equation $F(u,\\lambda)=0$ with a control constraint $g(u,\\lambda)=0$. This creates a system of two equations for the two unknowns $(u, \\lambda)$:\n$$\n\\mathbf{R}(u,\\lambda) = \\begin{bmatrix} F(u,\\lambda) \\\\ g(u,\\lambda) \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}\n$$\nThis system is solved at each step of the path-following procedure using a Newton-Raphson iterative method. The update rule for an iteration $i$ is:\n$$\n\\begin{bmatrix} u_{i+1} \\\\ \\lambda_{i+1} \\end{bmatrix} = \\begin{bmatrix} u_i \\\\ \\lambda_i \\end{bmatrix} - \\mathbf{J}^{-1}(u_i, \\lambda_i) \\mathbf{R}(u_i, \\lambda_i)\n$$\nwhere $\\mathbf{J}(u,\\lambda)$ is the $2 \\times 2$ augmented Jacobian matrix:\n$$\n\\mathbf{J}(u,\\lambda) = \\frac{\\partial \\mathbf{R}}{\\partial (u, \\lambda)} = \\begin{bmatrix}\n\\frac{\\partial F}{\\partial u}  \\frac{\\partial F}{\\partial \\lambda} \\\\\n\\frac{\\partial g}{\\partial u}  \\frac{\\partial g}{\\partial \\lambda}\n\\end{bmatrix}\n$$\nThe gradient of the equilibrium function $F$ is explicitly given as $\\nabla F(u,\\lambda) = \\left[\\frac{2u}{a^2}, \\frac{2\\lambda}{b^2}\\right]$. The program implements a generic Newton solver that takes the system function $\\mathbf{R}$ and its Jacobian $\\mathbf{J}$ as inputs, and then solves for $(u, \\lambda)$ at each step of the analysis for each test case.\n\nThe three control strategies are implemented as follows:\n1.  **Load Control**: The constraint is $g(u,\\lambda) = \\lambda - \\lambda_{\\text{target}} = 0$. This fixes the load parameter at each step. The gradient of the constraint is $\\nabla g = [0, 1]$. The augmented Jacobian is:\n    $$\n    \\mathbf{J}_{\\text{load}} = \\begin{bmatrix} \\frac{2u}{a^2}  \\frac{2\\lambda}{b^2} \\\\ 0  1 \\end{bmatrix}\n    $$\n    This matrix becomes singular when its determinant, $\\frac{2u}{a^2}$, is zero, which occurs when $u=0$. This corresponds to a load limit point (snap-through), where the equilibrium path has a horizontal tangent. At such points, load control fails. Test A is designed to encounter this failure.\n\n2.  **Displacement Control**: The constraint is $g(u,\\lambda) = u - u_{\\text{target}} = 0$, which fixes the displacement. The gradient of the constraint is $\\nabla g = [1, 0]$. The augmented Jacobian is:\n    $$\n    \\mathbf{J}_{\\text{disp}} = \\begin{bmatrix} \\frac{2u}{a^2}  \\frac{2\\lambda}{b^2} \\\\ 1  0 \\end{bmatrix}\n    $$\n    This matrix becomes singular when its determinant, $-\\frac{2\\lambda}{b^2}$, is zero, which occurs when $\\lambda=0$. This corresponds to a displacement limit point (snap-back), where the path has a vertical tangent. Displacement control fails at such points. Test B is designed to encounter this failure.\n\n3.  **Mixed (Arc-Length) Control**: This method constrains the step to lie on a sphere (a circle in this $2$D case) of radius $\\Delta s$ centered at the previously converged point $(u_n, \\lambda_n)$. The constraint is $g(u,\\lambda) = (u - u_n)^2 + \\psi(\\lambda - \\lambda_n)^2 - \\Delta s^2 = 0$. The gradient of this constraint is $\\nabla g = [2(u-u_n), 2\\psi(\\lambda-\\lambda_n)]$. The augmented Jacobian is:\n    $$\n    \\mathbf{J}_{\\text{arc}} = \\begin{bmatrix} \\frac{2u}{a^2}  \\frac{2\\lambda}{b^2} \\\\ 2(u-u_n)  2\\psi(\\lambda-\\lambda_n) \\end{bmatrix}\n    $$\n    This Jacobian is generally non-singular at both load and displacement limit points, making arc-length control a robust method for traversing complex equilibrium paths. This method uses a predictor-corrector scheme.\n    - **Predictor**: An initial guess for the next point is found by moving a distance $\\Delta s$ along the tangent to the curve at the current point $(u_n, \\lambda_n)$. The tangent vector $\\mathbf{t} = [t_u, t_\\lambda]$ is orthogonal to the gradient $\\nabla F$, i.e., $\\nabla F \\cdot \\mathbf{t} = 0$. A valid (un-normalized) tangent is $\\mathbf{t}' = [-\\frac{\\partial F}{\\partial \\lambda}, \\frac{\\partial F}{\\partial u}]$. This vector is then normalized according to the specified metric: $\\mathbf{t} = \\mathbf{t}' / \\sqrt{t_u'^2 + \\psi t_\\lambda'^2}$. To ensure the path is traced continuously without reversing direction, the sign of the tangent is chosen such that $\\mathbf{t}_k \\cdot \\mathbf{t}_{k-1}  0$ for step $k0$. For the first step, the sign is chosen to initiate a counter-clockwise traversal of the ellipse. The predictor point is then $(u_p, \\lambda_p) = (u_n, \\lambda_n) + \\Delta s \\cdot \\mathbf{t}$.\n    - **Corrector**: The Newton solver is used with $(u_p, \\lambda_p)$ as the initial guess to find the intersection of the equilibrium curve $F=0$ and the constraint sphere $g=0$. Test C uses this method and is expected to succeed in tracing the entire elliptical path.\n\nTest D provides a \"happy path\" scenario for load control, where the load increments move away from any limit points, demonstrating a successful application of this simple method on a monotonic segment of the equilibrium path.\n\nThe implemented program defines a generic Newton solver and then sets up four functions, one for each test case described in the problem. Each function configures the appropriate control constraint, runs the path-following loop, and reports success or failure based on the specified criteria. The final output aggregates the boolean results from all four tests.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Global parameters from the problem statement\nA = 1.0\nB = 0.8\nNEWTON_TOL = 1e-10\nNEWTON_MAX_ITER = 50\n\ndef F_func(u, lam, a, b):\n    \"\"\"The equilibrium equation F(u, lambda) = 0.\"\"\"\n    return (u / a)**2 + (lam / b)**2 - 1.0\n\ndef grad_F_func(u, lam, a, b):\n    \"\"\"The gradient of the equilibrium equation, [dF/du, dF/dlam].\"\"\"\n    return np.array([2.0 * u / a**2, 2.0 * lam / b**2])\n\ndef newton_solver(system_func, jacobian_func, initial_guess):\n    \"\"\"\n    Solves a 2x2 system of nonlinear equations using Newton's method.\n\n    Args:\n        system_func: A callable F(u, lam) that returns the residual vector [F, g].\n        jacobian_func: A callable J(u, lam) that returns the Jacobian matrix.\n        initial_guess: A tuple or array (u, lam) for the initial guess.\n\n    Returns:\n        A tuple ((u, lam), success_flag), where (u, lam) is the solution\n        and success_flag is a boolean.\n    \"\"\"\n    x_k = np.array(initial_guess, dtype=float)\n\n    for _ in range(NEWTON_MAX_ITER):\n        try:\n            # Calculate residual and check for convergence\n            R = system_func(x_k[0], x_k[1])\n            norm_R = np.linalg.norm(R)\n\n            if norm_R  NEWTON_TOL:\n                return x_k, True  # Converged successfully\n\n            # Calculate Jacobian and solve for the update\n            J = jacobian_func(x_k[0], x_k[1])\n            delta_x = np.linalg.solve(J, -R)\n            \n            x_k += delta_x\n\n            if np.any(np.isinf(x_k)) or np.any(np.isnan(x_k)):\n                return None, False # Numerical overflow detected\n\n        except np.linalg.LinAlgError:\n            return None, False  # Singular Jacobian matrix\n        except (ValueError, OverflowError):\n            return None, False  # Other numerical errors\n\n    return None, False  # Failed to converge within max iterations\n\ndef run_test_A():\n    \"\"\"Test A: Load control, expected failure at a load limit point.\"\"\"\n    u_k, lam_k = 0.866025403784, 0.4\n    delta_lam = 0.05\n    num_steps = 10\n\n    for _ in range(num_steps):\n        lam_target = lam_k + delta_lam\n        \n        def system(u, lam):\n            return np.array([F_func(u, lam, A, B), lam - lam_target])\n\n        def jacobian(u, lam):\n            grad_F = grad_F_func(u, lam, A, B)\n            return np.array([[grad_F[0], grad_F[1]], [0.0, 1.0]])\n        \n        initial_guess = np.array([u_k, lam_k])\n        solution, converged = newton_solver(system, jacobian, initial_guess)\n\n        if not converged:\n            return False\n\n        u_k, lam_k = solution\n\n    return True\n\ndef run_test_B():\n    \"\"\"Test B: Displacement control, expected failure at a displacement limit point.\"\"\"\n    u_k, lam_k = 0.5, 0.692820323027551\n    delta_u = 0.07\n    num_steps = 10\n    \n    for _ in range(num_steps):\n        u_target = u_k + delta_u\n\n        def system(u, lam):\n            return np.array([F_func(u, lam, A, B), u - u_target])\n\n        def jacobian(u, lam):\n            grad_F = grad_F_func(u, lam, A, B)\n            return np.array([[grad_F[0], grad_F[1]], [1.0, 0.0]])\n            \n        initial_guess = np.array([u_k, lam_k])\n        solution, converged = newton_solver(system, jacobian, initial_guess)\n\n        if not converged:\n            return False\n\n        u_k, lam_k = solution\n\n    return True\n\ndef run_test_C():\n    \"\"\"Test C: Mixed control (arc-length), expected to traverse the full path.\"\"\"\n    u_start, lam_start = 0.707106781186548, -0.565685424949238\n    u_n, lam_n = u_start, lam_start\n    psi = 1.0\n    ds = 0.1\n    n_max = 120\n    n_min = 40\n    eps_close = 1e-2\n\n    gradF_0 = grad_F_func(u_n, lam_n, A, B)\n    t_un_0 = np.array([-gradF_0[1], gradF_0[0]])\n    norm_t_0 = np.sqrt(t_un_0[0]**2 + psi * t_un_0[1]**2)\n    t_prev = t_un_0 / norm_t_0\n\n    for k in range(1, n_max + 1):\n        u_p, lam_p = (u_n, lam_n) + ds * t_prev\n\n        def system(u, lam):\n            return np.array([\n                F_func(u, lam, A, B),\n                (u - u_n)**2 + psi * (lam - lam_n)**2 - ds**2\n            ])\n\n        def jacobian(u, lam):\n            grad_F = grad_F_func(u, lam, A, B)\n            return np.array([\n                [grad_F[0], grad_F[1]],\n                [2.0 * (u - u_n), 2.0 * psi * (lam - lam_n)]\n            ])\n\n        solution, converged = newton_solver(system, jacobian, (u_p, lam_p))\n        \n        if not converged:\n            return False\n\n        u_n, lam_n = solution\n\n        if k = n_min:\n            dist = np.sqrt((u_n - u_start)**2 + (lam_n - lam_start)**2)\n            if dist  eps_close:\n                return True\n\n        gradF_k = grad_F_func(u_n, lam_n, A, B)\n        t_un_k = np.array([-gradF_k[1], gradF_k[0]])\n        norm_t_k = np.sqrt(t_un_k[0]**2 + psi * t_un_k[1]**2)\n        if norm_t_k  1e-12: return False\n        \n        t_k = t_un_k / norm_t_k\n        \n        if np.dot(t_k, t_prev)  0:\n            t_k = -t_k\n        \n        t_prev = t_k\n        \n    return False\n\ndef run_test_D():\n    \"\"\"Test D: Load control, happy path along a monotonic segment.\"\"\"\n    u_k, lam_k = 0.5, 0.692820323027551\n    delta_lam = -0.05\n    num_steps = 10\n\n    for _ in range(num_steps):\n        lam_target = lam_k + delta_lam\n\n        def system(u, lam):\n            return np.array([F_func(u, lam, A, B), lam - lam_target])\n\n        def jacobian(u, lam):\n            grad_F = grad_F_func(u, lam, A, B)\n            return np.array([[grad_F[0], grad_F[1]], [0.0, 1.0]])\n        \n        initial_guess = np.array([u_k, lam_k])\n        solution, converged = newton_solver(system, jacobian, initial_guess)\n\n        if not converged:\n            return False\n\n        u_k, lam_k = solution\n\n    return True\n\ndef solve():\n    \"\"\"\n    Executes the test suite and prints the final results.\n    \"\"\"\n    test_cases_funcs = [\n        run_test_A,\n        run_test_B,\n        run_test_C,\n        run_test_D,\n    ]\n\n    results = []\n    for test_func in test_cases_funcs:\n        results.append(test_func())\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Instability in engineering structures is frequently driven by material degradation, such as damage or cracking. This computational exercise delves into the simulation of strain localization and snap-back in a bar with a softening material law, a common scenario in damage mechanics. You will implement a nonlinear finite element analysis and confront the critical issue of pathological mesh sensitivity, learning how regularization techniques based on fracture energy ($G_f$) are used to ensure physically meaningful and objective results .",
            "id": "3600892",
            "problem": "Consider a one-dimensional tensile bar of length $L$ and cross-sectional area $A$, discretized into $N$ two-node linear finite elements. The bar is quasi-static, with no body forces, and experiences damage-induced softening in tension. The governing equations are derived from the principle of virtual work and balance of linear momentum under quasi-static conditions. Let $u(x)$ denote the axial displacement, $\\varepsilon(x) = \\frac{du}{dx}$ the axial strain, and $\\sigma(x)$ the axial stress. The constitutive response is damageable linear elasticity in tension, given by $\\sigma = (1 - d) E \\varepsilon$ where $E$ is Young's modulus and $d \\in [0,1)$ is a scalar damage variable that monotonically increases with tensile strain and remains zero in compression. The damage variable $d$ enforces softening through a bilinear post-peak stress–strain law.\n\nThe bilinear softening law in tension is defined by three strain levels $0 \\le \\varepsilon \\le \\varepsilon_0 \\le \\varepsilon_1 \\le \\varepsilon_f$, and corresponding stresses $\\sigma(\\varepsilon_0) = \\sigma_0$ and $\\sigma(\\varepsilon_1) = \\sigma_1$ with $\\sigma_1 = r_{\\sigma} \\sigma_0$ and $0  r_{\\sigma}  1$. The stress–strain function $s(\\varepsilon)$ is\n$$\ns(\\varepsilon) = \n\\begin{cases}\nE \\varepsilon,  0 \\le \\varepsilon \\le \\varepsilon_0, \\\\\n\\sigma_0 + \\dfrac{\\sigma_1 - \\sigma_0}{\\varepsilon_1 - \\varepsilon_0} \\left(\\varepsilon - \\varepsilon_0\\right),  \\varepsilon_0  \\varepsilon \\le \\varepsilon_1, \\\\\n\\sigma_1 \\dfrac{\\varepsilon_f - \\varepsilon}{\\varepsilon_f - \\varepsilon_1},  \\varepsilon_1  \\varepsilon \\le \\varepsilon_f, \\\\\n0,  \\varepsilon  \\varepsilon_f,\n\\end{cases}\n$$\nwhere $\\sigma_0 = E \\varepsilon_0$. The damage variable is defined implicitly by $s(\\varepsilon) = (1 - d) E \\varepsilon$, that is,\n$$\nd(\\varepsilon) = 1 - \\frac{s(\\varepsilon)}{E \\varepsilon} \\quad \\text{for } \\varepsilon  0, \\quad d(\\varepsilon) = 0 \\text{ for } \\varepsilon \\le 0,\n$$\nand is enforced to be monotonically non-decreasing with loading.\n\nFor displacement control, prescribe the end displacements $u(0) = 0$ and $u(L) = \\bar{u}$, solve for interior nodal displacements by assembling the global stiffness matrix with element stiffness $k_e = (1 - d_e) \\dfrac{E A}{h_e} \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix}$ where $h_e$ is the element length and $d_e$ is the element-wise damage evaluated at the current strain. The reaction force at $x=L$ is $P(\\bar{u})$, obtained from the global equilibrium $K u = f$ with $f=0$ and essential boundary conditions via partitioning. Under load control, instability (snap-back) manifests when the load–displacement response has a negative incremental stiffness, i.e., when $\\dfrac{dP}{d\\bar{u}}  0$.\n\nTo quantify mesh sensitivity, consider two modeling options:\n- Local damage model: the softening parameter $\\varepsilon_f$ is independent of $h_e$.\n- Regularized damage model: enforce mesh-independent energy dissipation by prescribing fracture energy per unit area $G_f$ such that the post-peak stress–strain area satisfies\n$$\nh_e \\int_{\\varepsilon_0}^{\\varepsilon_f} s(\\varepsilon)\\, d\\varepsilon = G_f,\n$$\nwhich for the bilinear law implies\n$$\nh_e \\left[ \\frac{\\sigma_0 + \\sigma_1}{2} (\\varepsilon_1 - \\varepsilon_0) + \\frac{\\sigma_1}{2} (\\varepsilon_f - \\varepsilon_1) \\right] = G_f,\n$$\nso that\n$$\n\\varepsilon_f = \\varepsilon_1 + \\frac{2}{\\sigma_1} \\left( \\frac{G_f}{h_e} - \\frac{\\sigma_0 + \\sigma_1}{2} (\\varepsilon_1 - \\varepsilon_0) \\right),\n$$\nprovided the bracketed term is non-negative; otherwise set $\\varepsilon_f$ slightly above $\\varepsilon_1$ to avoid ill-posedness.\n\nImplement a displacement-controlled incremental analysis with an operator split: at each increment of $\\bar{u}$, solve for displacements using the current damage state, update strains, update damage using the bilinear law and enforce monotonicity, and iterate until convergence. Compute the load–displacement curve $P(\\bar{u})$, detect snap-back by checking the sign of the discrete slope $\\Delta P / \\Delta \\bar{u}$, and compute the external work $W = \\int P(\\bar{u})\\, d\\bar{u}$ by numerical quadrature (trapezoidal rule). Use a slight heterogeneity to trigger localization: reduce $\\varepsilon_0$ and $\\varepsilon_1$ in a single “flawed” element by a small factor, keeping the same $r_{\\sigma}$.\n\nYour program must evaluate the following test suite, with all quantities in International System of Units (SI) and angles not applicable. Express loads in newtons (N), displacements in meters (m), and energies in newton-meters ($\\mathrm{N\\cdot m}$). Return floating-point values rounded to six decimal places and booleans as Python literals.\n\nCommon parameters for all tests:\n- $L = 1.0\\,\\mathrm{m}$,\n- $A = 1.0 \\times 10^{-4}\\,\\mathrm{m}^2$,\n- $E = 7.0 \\times 10^{10}\\,\\mathrm{Pa}$,\n- $\\varepsilon_0 = 0.002$,\n- $\\varepsilon_1 = 0.006$,\n- $r_{\\sigma} = 0.5$ so that $\\sigma_1 = r_{\\sigma} \\sigma_0$,\n- flawed element index is the middle element, with $\\varepsilon_0$ and $\\varepsilon_1$ scaled by $(1 - \\delta)$ with $\\delta = 0.02$ for that element only,\n- $d_{\\max} = 0.9999$ to avoid singular stiffness.\n\nTest cases:\n1. Local model, $N = 20$, $\\varepsilon_f = 0.02$ for all elements except the flawed element which also scales $\\varepsilon_f$ by $(1 - \\delta)$. Use $400$ displacement increments up to $\\bar{u}_{\\max} = 1.2\\, h_{\\ell}\\, \\varepsilon_{f,\\ell}$ where $h_{\\ell}$ is the flawed element length and $\\varepsilon_{f,\\ell}$ its $\\varepsilon_f$.\n2. Local model, $N = 100$, same as case $1$.\n3. Regularized model, $N = 20$, $G_f = 50000\\,\\mathrm{N/m}$. Compute $\\varepsilon_f$ per element via the energy condition above. Use $400$ increments up to $\\bar{u}_{\\max} = 1.2\\, h_{\\ell}\\, \\varepsilon_{f,\\ell}$ as in case $1$.\n4. Regularized model, $N = 100$, $G_f = 50000\\,\\mathrm{N/m}$, same increment strategy.\n\nFor each test case, compute:\n- `$P_{\\text{peak}}$` in $\\mathrm{N}$,\n- `$\\bar{u}_{\\text{peak}}$` in $\\mathrm{m}$ where $P(\\bar{u})$ attains its maximum,\n- a boolean flag `has_snapback` that is `True` if any discrete slope $\\Delta P / \\Delta \\bar{u}$ is negative,\n- the external work `$W$` in $\\mathrm{N\\cdot m}$ as the trapezoidal integral of $P(\\bar{u})$ over the computed $\\bar{u}$ range.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with one sub-list per test case in the order above. Each sub-list must be the four values `[$P_{\\text{peak}}, \\bar{u}_{\\text{peak}}, \\text{has\\_snapback}, W$]`. For example, an output with two test cases would look like `[[1.0,0.1,true,0.05],[2.0,0.2,false,0.10]]`.",
            "solution": "The user-provided problem is a well-posed and scientifically grounded exercise in computational solid mechanics, specifically focusing on material nonlinearity, damage mechanics, and structural instability. It is valid and solvable.\n\nThe solution requires the implementation of a one-dimensional ($1$D) nonlinear finite element analysis for a tensile bar undergoing damage and softening. The analysis is performed under displacement control to trace the full load-displacement response, including the post-peak softening regime where snap-back instability can occur. The core of the solution lies in a staggered (or operator-split) iterative scheme that handles the coupling between mechanical deformation and material damage evolution.\n\nThe following steps and principles outline the methodical construction of the solution.\n\n### 1. Principle of Virtual Work and Finite Element Discretization\nThe problem is governed by the balance of linear momentum, which under quasi-static conditions and in a weak form, is expressed by the principle of virtual work: the internal virtual work must equal the external virtual work for any kinematically admissible virtual displacement. The bar of length $L$ is discretized into $N$ two-node linear finite elements. Each element $e$ has a length $h_e = L/N$. The displacement field $u(x)$ is approximated as a piecewise linear function, uniquely defined by the nodal displacements $u_i$ at nodes $x_i-$. Within each element, the strain $\\varepsilon_e$ is constant and given by $\\varepsilon_e = (u_{e+1} - u_e) / h_e$, where $u_e$ and $u_{e+1}$ are the displacements of the element's two nodes.\n\nThe element stiffness matrix $k_e$ relates nodal forces to nodal displacements. For a linear elastic material, $k_e = \\frac{E A}{h_e} \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix}$, where $E$ is Young's modulus and $A$ is the cross-sectional area. In this problem, damage is incorporated by degrading the stiffness, leading to the tangent element stiffness matrix:\n$$\nk_e = (1 - d_e) \\frac{E A}{h_e} \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix}\n$$\nHere, $d_e$ is the scalar damage variable for element $e$, assumed to be constant within the element. The global stiffness matrix $K$ for the $N+1$ nodes is assembled by summing the contributions from all $N$ element stiffness matrices.\n\n### 2. Constitutive Model: Damageable Elasticity with Bilinear Softening\nThe material's constitutive behavior is nonlinear due to damage. The stress $\\sigma$ is related to the strain $\\varepsilon$ by $\\sigma = (1-d)E\\varepsilon$. The damage variable $d$ itself depends on the strain history. The stress-strain relationship $s(\\varepsilon)$ in tension is defined by a bilinear softening law post-peak. It is linear elastic up to a strain of $\\varepsilon_0$ with stress $\\sigma_0 = E \\varepsilon_0$. After this peak, the stress decreases in two linear segments until it reaches zero at a final strain $\\varepsilon_f$. The specific form of $s(\\varepsilon)$ is given in the problem statement.\n\nThe damage variable $d$ is derived from this stress-strain law:\n$$\nd(\\varepsilon) = 1 - \\frac{s(\\varepsilon)}{E \\varepsilon} \\quad \\text{for } \\varepsilon  0\n$$\nTo account for the irreversibility of damage, it must be a non-decreasing function of loading. This is achieved by evaluating the damage law at the maximum tensile strain $\\varepsilon_{\\max}$ experienced by the material point throughout its history, i.e., $d = d(\\varepsilon_{\\max})$. For each element $e$, a history variable $\\varepsilon_{\\max,e}$ is stored and updated at each step. To prevent the element stiffness from becoming zero, which would result in a singular global stiffness matrix, the damage is capped at $d_{\\max} = 0.9999$.\n\n### 3. Mesh-Dependency and Regularization\nLocal damage models, where material parameters like $\\varepsilon_f$ are constant, suffer from pathological mesh-dependency: as the mesh is refined ( $h_e \\to 0$ ), the softening response becomes more brittle, and the energy dissipated during failure tends to zero. To regularize the model, the problem introduces a fracture energy approach. The total energy dissipated per unit area, $G_f$, is prescribed as a material property. This energy corresponds to the area under the stress-strain curve after the peak stress. By enforcing that the work done by the stress over the softening strain range, scaled by the element volume, is equal to a constant fracture energy $G_f$, we can make the overall structural response objective with respect to mesh refinement.\nThe failure strain $\\varepsilon_f$ is no longer a constant but is computed for each element to satisfy the energy equivalence:\n$$\nh_e \\int_{\\varepsilon_0}^{\\varepsilon_f} s(\\varepsilon)\\, d\\varepsilon = G_f\n$$\nFor the given bilinear law, this leads to the provided algebraic expression for $\\varepsilon_f$ as a function of $h_e$ and other material parameters.\n\n### 4. Numerical Solution: Incremental-Iterative Staggered Scheme\nThe problem is highly nonlinear due to the damage-dependent stiffness. A robust solution is found using a displacement-controlled incremental analysis combined with an iterative staggered (operator-split) scheme. The total prescribed displacement $\\bar{u}_{\\max}$ at $u(L)$ is applied in small increments. For each increment of $\\bar{u}$:\n1.  **Initialize**: Start with the converged damage state $d_{e}^{\\text{old}}$ from the previous displacement step.\n2.  **Iterate for Convergence**: Enter a fixed-point iteration loop to find the consistent damage and displacement fields for the current $\\bar{u}$.\n    a.  **Assemble and Solve**: Assemble the global stiffness matrix $K$ using the current damage state $d_{e}^{\\text{old}}$. Apply boundary conditions ($u_0 = 0$, $u_N = \\bar{u}$) by partitioning the system. Solve the linear system $K_{II} u_I = -K_{IE} u_E$ for the unknown internal nodal displacements $u_I$.\n    b.  **Update State**: With the full displacement vector $u$, compute the new element strains $\\varepsilon_e$. Update the maximum strain history $\\varepsilon_{\\max,e} = \\max(\\varepsilon_{\\max,e}, \\varepsilon_e)$.\n    c.  **Update Damage**: Calculate a new damage state $d_{e}^{\\text{new}}$ for each element based on its updated maximum strain history $\\varepsilon_{\\max,e}$ and its material parameters ($\\varepsilon_0$, $\\varepsilon_1$, $\\varepsilon_f$).\n    d.  **Check Convergence**: Compare the new damage vector $d^{\\text{new}}$ with the old one $d^{\\text{old}}$. If the norm of their difference, $\\|d^{\\text{new}} - d^{\\text{old}}\\|$, is below a tolerance, the non-linear step has converged. Exit the loop. Otherwise, set $d_{e}^{\\text{old}} \\leftarrow d_{e}^{\\text{new}}$ and repeat from step 2a.\n3.  **Store Results**: Once converged, calculate the reaction force $P(\\bar{u})$ at the right end from the equation $f_E = K_{EI} u_I + K_{EE} u_E$. Store the pair $(\\bar{u}, P(\\bar{u}))$.\n\nA small heterogeneity (a single \"flawed\" element with slightly lower strength) is introduced to trigger strain localization in a predictable manner, making the numerical problem well-posed.\n\n### 5. Post-Processing and Output Calculation\nAfter completing all displacement increments, the collected load-displacement data $(\\bar{u}, P(\\bar{u}))$ is analyzed:\n-   **Peak Load ($P_{\\text{peak}}$) and corresponding Displacement ($\\bar{u}_{\\text{peak}}$)**: These are found by searching for the maximum value in the computed reaction force array.\n-   **Snap-Back Instability (`has_snapback`)**: The curve is examined for any negative slope, i.e., if $P_{i+1}  P_i$ for any increment $i$. The presence of such a segment indicates snap-back.\n-   **External Work ($W$)**: The total external work done on the bar is the integral of the reaction force over the prescribed displacement, $W = \\int_{0}^{\\bar{u}_{\\max}} P(\\bar{u})\\, d\\bar{u}$. This integral is computed numerically from the discrete data points using the trapezoidal rule.\n\nThe implementation will process four distinct test cases, varying the number of elements ($N=20$ vs. $N=100$) and the damage model (local vs. regularized), and report the four computed metrics for each case. The results will highlight the mesh-dependency of the local model and the regularizing effect of the fracture energy-based approach.",
            "answer": "```python\nimport numpy as np\n\n# Global constants and material properties from the problem statement\nL = 1.0  # m\nA = 1.0e-4  # m^2\nE = 7.0e10  # Pa\nEPSILON_0_REF = 0.002\nEPSILON_1_REF = 0.006\nR_SIGMA = 0.5\nDELTA = 0.02\nG_F = 50000.0  # N/m\nD_MAX = 0.9999\nN_INCR = 400\nNL_TOL = 1e-8\nNL_MAX_ITER = 50\n\ndef get_stress(eps, eps_0, eps_1, eps_f, E):\n    \"\"\"\n    Computes stress based on the bilinear softening law for a given strain.\n    Assumes strain represents the monotonic loading path.\n    \"\"\"\n    if eps = 0:\n        return E * eps  # Elastic in compression\n    \n    sigma_0 = E * eps_0\n    sigma_1 = R_SIGMA * sigma_0\n    \n    if eps = eps_0:\n        return E * eps\n    elif eps = eps_1:\n        if abs(eps_1 - eps_0)  1e-12: return sigma_0\n        return sigma_0 + (sigma_1 - sigma_0) / (eps_1 - eps_0) * (eps - eps_0)\n    elif eps = eps_f:\n        if abs(eps_f - eps_1)  1e-12: return 0.0\n        return sigma_1 * (eps_f - eps) / (eps_f - eps_1)\n    else:\n        return 0.0\n\ndef get_damage(eps, eps_0, eps_1, eps_f, E):\n    \"\"\"\n    Computes the damage variable d(eps) based on the stress law.\n    \"\"\"\n    if eps = eps_0:\n        return 0.0\n    \n    stress = get_stress(eps, eps_0, eps_1, eps_f, E)\n    if eps  1e-12: # Avoid division by zero\n        damage = 1.0 - stress / (E * eps)\n    else:\n        damage = 0.0\n        \n    return min(damage, D_MAX)\n\ndef run_simulation(params):\n    \"\"\"\n    Performs a full nonlinear finite element simulation for one test case.\n    \"\"\"\n    # 1. Setup mesh and material properties\n    N = params['N']\n    h_e = L / N\n    num_nodes = N + 1\n    \n    eps_0_e = np.full(N, EPSILON_0_REF)\n    eps_1_e = np.full(N, EPSILON_1_REF)\n    eps_f_e = np.zeros(N)\n\n    flawed_elem_idx = N // 2\n    \n    eps_0_e[flawed_elem_idx] *= (1.0 - DELTA)\n    eps_1_e[flawed_elem_idx] *= (1.0 - DELTA)\n\n    if params['model_type'] == 'local':\n        eps_f_e.fill(params['epsilon_f_ref'])\n        eps_f_e[flawed_elem_idx] *= (1.0 - DELTA)\n    else: # 'regularized'\n        G_f = params['G_f']\n        for i in range(N):\n            e0, e1 = eps_0_e[i], eps_1_e[i]\n            s0 = E * e0\n            s1 = R_SIGMA * s0\n            \n            if s1  1e-9:\n                eps_f_e[i] = e1 * 1.001\n                continue\n\n            term = G_f / h_e - (s0 + s1) / 2.0 * (e1 - e0)\n            if term = 0:\n                eps_f_e[i] = e1 + (2.0 / s1) * term\n            else:\n                eps_f_e[i] = e1 * 1.001\n\n    # 2. Simulation initialization\n    u_max = 1.2 * h_e * eps_f_e[flawed_elem_idx]\n    u_bar_steps = np.linspace(0, u_max, N_INCR)\n    \n    u = np.zeros(num_nodes)\n    d_e = np.zeros(N)\n    eps_max_e = np.zeros(N)\n    \n    load_disp_curve = [(0.0, 0.0)]\n    singular_failure = False\n\n    # 3. Incremental displacement-controlled loop\n    for i, u_bar in enumerate(u_bar_steps):\n        if i == 0: continue\n        \n        # Non-linear solver loop (staggered scheme)\n        for _ in range(NL_MAX_ITER):\n            K = np.zeros((num_nodes, num_nodes))\n            for e in range(N):\n                k_scalar = (1.0 - d_e[e]) * E * A / h_e\n                k_el = k_scalar * np.array([[1, -1], [-1, 1]])\n                K[e:e+2, e:e+2] += k_el\n\n            K_II = K[1:-1, 1:-1]\n            K_IE = K[1:-1, [0, -1]]\n            u_E = np.array([0, u_bar])\n            \n            f_ext_I = -K_IE @ u_E\n            \n            try:\n                u_I = np.linalg.solve(K_II, f_ext_I)\n            except np.linalg.LinAlgError:\n                for j in range(i, N_INCR):\n                    load_disp_curve.append((u_bar_steps[j], 0.0))\n                singular_failure = True\n                break\n\n            u[1:-1] = u_I\n            u[-1] = u_bar\n            \n            new_d_e = np.zeros(N)\n            strains = np.diff(u) / h_e\n            eps_max_e = np.maximum(eps_max_e, strains)\n            \n            for e in range(N):\n                new_d_e[e] = get_damage(eps_max_e[e], eps_0_e[e], eps_1_e[e], eps_f_e[e], E)\n            \n            d_norm_diff = np.linalg.norm(new_d_e - d_e)\n            d_e = new_d_e\n            \n            if d_norm_diff  NL_TOL:\n                break\n        \n        if singular_failure:\n            break\n        \n        K_EI = K[[0, -1], 1:-1]\n        K_EE = K[[0, -1], [0, -1]]\n        f_E = K_EI @ u_I + K_EE @ u_E\n        P = f_E[1]\n        \n        load_disp_curve.append((u_bar, P))\n        \n    # 4. Post-process results\n    disps = np.array([p[0] for p in load_disp_curve])\n    loads = np.array([p[1] for p in load_disp_curve])\n\n    P_peak, u_peak = (0.0, 0.0)\n    if len(loads)  0 and np.any(loads  0):\n        peak_idx = np.argmax(loads)\n        P_peak = loads[peak_idx]\n        u_peak = disps[peak_idx]\n\n    has_snapback = np.any(np.diff(loads)  0)\n    \n    W = np.trapz(loads, disps)\n\n    return [P_peak, u_peak, bool(has_snapback), W]\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the test cases and print the final result.\n    \"\"\"\n    test_cases = [\n        {'model_type': 'local', 'N': 20, 'epsilon_f_ref': 0.02},\n        {'model_type': 'local', 'N': 100, 'epsilon_f_ref': 0.02},\n        {'model_type': 'regularized', 'N': 20, 'G_f': G_F},\n        {'model_type': 'regularized', 'N': 100, 'G_f': G_F},\n    ]\n\n    results = []\n    for params in test_cases:\n        result = run_simulation(params)\n        results.append(result)\n\n    formatted_results = []\n    for res in results:\n        p_peak_str = f\"{res[0]:.6f}\"\n        u_peak_str = f\"{res[1]:.6f}\"\n        snap_str = str(res[2]).lower()\n        w_str = f\"{res[3]:.6f}\"\n        formatted_results.append(f\"[{p_peak_str},{u_peak_str},{snap_str},{w_str}]\")\n\n    final_output_string = f\"[{','.join(formatted_results)}]\"\n    print(final_output_string)\n\nsolve()\n```"
        }
    ]
}