{
    "hands_on_practices": [
        {
            "introduction": "要深入理解结构失稳，一个经典的起点是分析一个简单的、可解析求解的系统。本练习将引导你分析一个对称的两杆桁架，这是一个展示突变（snap-back）失稳现象的经典模型。通过从第一性原理——即平衡、协调和本构关系——出发，你将亲手推导出该系统的精确荷载-位移关系，并确定失稳的临界点。这个分析过程旨在建立对由材料软化引起的几何非线性失稳的物理直觉，为你后续学习更复杂的数值方法奠定坚实的理论基础。",
            "id": "3600896",
            "problem": "一个对称的铰接两杆桁架由两个相同的直杆件构成，其未变形长度连接着位于坐标 $\\left(-a,0\\right)$ 和 $\\left(a,0\\right)$ 的固定支座，以及一个初始位于 $\\left(0,h_0\\right)$ 的共同顶点，其中 $a>0$ 且 $h_0>0$。每个杆件均为轴向可变形，具有恒定的横截面积 $A$，并遵循软化线性应力-应变关系 $\\sigma=\\sigma_0+H\\,\\varepsilon$，其中 $H  0$ 且 $\\sigma_0$ 为常数，$\\varepsilon$ 是格林-拉格朗日轴向应变，在此处取小应变极限作为轴向工程应变 $\\varepsilon=\\left(\\ell-L_0\\right)/L_0$，其中 $L_0=\\sqrt{a^2+h_0^2}$ 是杆件的初始长度，$\\ell$ 是其当前长度。在准静态条件下，顶点被施加一个指定的竖向向下位移 $w$（因此其当前竖向坐标为 $h=h_0-w$），并在顶点处测量相应的竖向反作用载荷 $P$。假设为平面铰接行为，只考虑轴向力，并忽略体力、剪切变形和弯曲。\n\n仅使用平衡、协调和给定的本构关系：\n- 以 $a$、$h_0$、$A$、$\\sigma_0$、$H$ 和 $w$ 为变量，推导该系统的精确全局载荷-位移关系 $P(w)$ 的闭合形式。\n- 通过找到全局载荷-位移曲线出现水平切线时的临界顶点向下位移 $w_{\\mathrm{cr}}$，确定载荷控制下的回跳（snap-back）起点。为 $w_{\\mathrm{cr}}$ 提供一个单一的闭合形式解析表达式。\n\n用米表示位移 $w_{\\mathrm{cr}}$。不要代入任何数值。最终答案必须是单一的闭合形式解析表达式。",
            "solution": "该问题是有效的，因为它描述了结构力学中一个适定的物理系统，并寻求基于所提供的平衡、协调和材料本构原理推导出解析结果。\n\n求解过程分为两部分：首先，推导全局载荷-位移关系 $P(w)$；其次，通过分析此关系找到回跳起点的临界位移 $w_{\\mathrm{cr}}$。\n\n**第1部分：载荷-位移关系 $P(w)$ 的推导**\n\n**1. 运动学与协调**\n初始几何结构由两根长度为 $L_0$ 的杆件组成，它们连接位于 $(\\pm a, 0)$ 的支座和位于 $(0, h_0)$ 的顶点。每个杆件的初始长度由勾股定理给出：\n$$L_0 = \\sqrt{a^2 + h_0^2}$$\n当顶点向下竖向位移距离 $w$ 时，其新坐标为 $(0, h)$，其中当前高度 $h$ 为：\n$$h = h_0 - w$$\n每个杆件的当前长度 $\\ell$ 可由新的几何结构得出：\n$$\\ell(w) = \\sqrt{a^2 + h^2} = \\sqrt{a^2 + (h_0 - w)^2}$$\n轴向工程应变 $\\varepsilon$ 定义为长度变化量除以初始长度：\n$$\\varepsilon = \\frac{\\ell - L_0}{L_0} = \\frac{\\sqrt{a^2 + (h_0 - w)^2} - \\sqrt{a^2 + h_0^2}}{\\sqrt{a^2 + h_0^2}}$$\n\n**2. 本构关系**\n每个杆件中的轴向应力 $\\sigma$ 由指定的线性软化定律给出：\n$$\\sigma = \\sigma_0 + H\\,\\varepsilon$$\n其中 $\\sigma_0$ 是一个常数，且 $H  0$。每个杆件的轴向力 $F$（横截面积为 $A$）为：\n$$F = \\sigma A = A(\\sigma_0 + H\\,\\varepsilon)$$\n代入应变 $\\varepsilon$ 的表达式：\n$$F(w) = A\\left(\\sigma_0 + H \\left(\\frac{\\ell(w)}{L_0} - 1\\right)\\right) = A\\left(\\sigma_0 - H + \\frac{H}{L_0}\\ell(w)\\right)$$\n\n**3. 平衡**\n在顶点处，外部施加的竖向载荷 $P$ 必须与两个杆件轴向力的竖向分量相平衡。根据对称性，水平力分量相互抵消。设 $\\theta$ 为杆件与水平轴之间的夹角。竖向平衡方程为：\n$$P = 2 F \\sin(\\theta)$$\n从几何关系可知，$\\sin(\\theta)$ 是当前顶点高度 $h$ 与当前杆件长度 $\\ell$ 的比值：\n$$\\sin(\\theta) = \\frac{h}{\\ell} = \\frac{h_0 - w}{\\sqrt{a^2 + (h_0 - w)^2}}$$\n将 $F(w)$ 和 $\\sin(\\theta)$ 的表达式代入平衡方程，得到载荷-位移关系 $P(w)$：\n$$P(w) = 2 \\left[ A\\left(\\sigma_0 - H + \\frac{H}{L_0}\\ell(w)\\right) \\right] \\frac{h_0 - w}{\\ell(w)}$$\n将项 $\\frac{h_0 - w}{\\ell(w)}$ 分配进去可得：\n$$P(w) = 2A \\left( (\\sigma_0 - H)\\frac{h_0 - w}{\\ell(w)} + \\frac{H}{L_0}(h_0 - w) \\right)$$\n代入 $\\ell(w)$ 和 $L_0$ 的完整表达式，我们得到最终的闭合形式关系：\n$$P(w) = 2A(h_0 - w) \\left( \\frac{\\sigma_0 - H}{\\sqrt{a^2 + (h_0 - w)^2}} + \\frac{H}{\\sqrt{a^2 + h_0^2}} \\right)$$\n\n**第2部分：临界位移 $w_{\\mathrm{cr}}$ 的确定**\n\n载荷控制下的回跳起点对应于载荷-位移曲线上的一个极限点，其特征是具有水平切线。在数学上，这发生在载荷 $P$ 对位移 $w$ 的导数为零的地方：\n$$\\frac{dP}{dw} = 0$$\n我们对 $P(w)$ 的表达式关于 $w$ 求导。我们来分析 $P(w) / (2A)$ 表达式中括号内的两项：\n$$P(w) / (2A) = (\\sigma_0 - H)\\frac{h_0 - w}{\\sqrt{a^2 + (h_0 - w)^2}} + \\frac{H}{L_0}(h_0 - w)$$\n第二项的导数很简单：\n$$\\frac{d}{dw}\\left[\\frac{H}{L_0}(h_0 - w)\\right] = -\\frac{H}{L_0}$$\n对于第一项，我们使用商法则和链式法则。设 $u = h_0 - w$，则 $\\frac{du}{dw} = -1$。该项为 $\\frac{u}{\\sqrt{a^2 + u^2}}$。\n$$\\frac{d}{du}\\left(\\frac{u}{\\sqrt{a^2 + u^2}}\\right) = \\frac{1 \\cdot \\sqrt{a^2 + u^2} - u \\cdot \\frac{u}{\\sqrt{a^2 + u^2}}}{a^2 + u^2} = \\frac{(a^2 + u^2) - u^2}{(a^2 + u^2)^{3/2}} = \\frac{a^2}{(a^2 + u^2)^{3/2}}$$\n使用链式法则，关于 $w$ 的导数为：\n$$\\frac{d}{dw}\\left(\\frac{h_0 - w}{\\sqrt{a^2 + (h_0 - w)^2}}\\right) = \\frac{a^2}{(a^2 + (h_0-w)^2)^{3/2}} \\cdot (-1) = \\frac{-a^2}{\\ell(w)^3}$$\n合并导数，我们得到：\n$$\\frac{dP}{dw} = 2A \\left[ (\\sigma_0 - H)\\left(\\frac{-a^2}{\\ell(w)^3}\\right) - \\frac{H}{L_0} \\right]$$\n令 $\\frac{dP}{dw} = 0$ 得到临界位移 $w_{\\mathrm{cr}}$ 的条件：\n$$-(\\sigma_0 - H)\\frac{a^2}{\\ell_{\\mathrm{cr}}^3} - \\frac{H}{L_0} = 0$$\n其中 $\\ell_{\\mathrm{cr}} = \\ell(w_{\\mathrm{cr}})$。重新整理以求解 $\\ell_{\\mathrm{cr}}^3$：\n$$-(\\sigma_0 - H)a^2 L_0 = H \\ell_{\\mathrm{cr}}^3$$\n$$\\ell_{\\mathrm{cr}}^3 = -\\frac{(\\sigma_0 - H)}{H} a^2 L_0 = \\frac{H - \\sigma_0}{H} a^2 L_0 = \\left(1 - \\frac{\\sigma_0}{H}\\right) a^2 L_0$$\n因此，临界杆件长度 $\\ell_{\\mathrm{cr}}$ 为：\n$$\\ell_{\\mathrm{cr}} = \\left[ \\left(1 - \\frac{\\sigma_0}{H}\\right) a^2 L_0 \\right]^{1/3}$$\n为了找到临界位移 $w_{\\mathrm{cr}}$，我们使用运动学关系 $\\ell_{\\mathrm{cr}}^2 = a^2 + (h_0 - w_{\\mathrm{cr}})^2$。\n$$(h_0 - w_{\\mathrm{cr}})^2 = \\ell_{\\mathrm{cr}}^2 - a^2$$\n假设第一个临界点发生在顶点翻转之前（即 $h_0 - w_{\\mathrm{cr}} > 0$），我们取正根：\n$$h_0 - w_{\\mathrm{cr}} = \\sqrt{\\ell_{\\mathrm{cr}}^2 - a^2}$$\n$$w_{\\mathrm{cr}} = h_0 - \\sqrt{\\ell_{\\mathrm{cr}}^2 - a^2}$$\n代入 $\\ell_{\\mathrm{cr}}$ 的表达式：\n$$w_{\\mathrm{cr}} = h_0 - \\sqrt{\\left( \\left[ \\left(1 - \\frac{\\sigma_0}{H}\\right) a^2 L_0 \\right]^{1/3} \\right)^2 - a^2}$$\n$$w_{\\mathrm{cr}} = h_0 - \\sqrt{\\left[ \\left(1 - \\frac{\\sigma_0}{H}\\right) a^2 L_0 \\right]^{2/3} - a^2}$$\n最后，代入 $L_0 = \\sqrt{a^2 + h_0^2}$，得到以给定参数表示的 $w_{\\mathrm{cr}}$ 的完整表达式：\n$$w_{\\mathrm{cr}} = h_0 - \\sqrt{\\left[ \\left(1 - \\frac{\\sigma_0}{H}\\right) a^2 \\sqrt{a^2 + h_0^2} \\right]^{\\frac{2}{3}} - a^2}$$\n这就是所要求的临界位移的单一闭合形式解析表达式。",
            "answer": "$$\n\\boxed{h_0 - \\sqrt{\\left( a^2 \\left(1 - \\frac{\\sigma_0}{H}\\right) \\sqrt{a^2 + h_0^2} \\right)^{\\frac{2}{3}} - a^2}}\n$$"
        },
        {
            "introduction": "尽管解析模型能够提供深刻的洞见，但大多数工程问题中的非线性平衡路径必须通过数值方法进行追踪。本练习聚焦于路径跟踪算法的核心，这些算法是分析突穿和突变现象的基石。通过在一个简单的代数方程所定义的椭圆路径上实现并比较三种基本的控制策略——荷载控制、位移控制和弧长控制，你将直观地理解为何简单的控制方法会在极限点（limit point）处失效，以及为何更稳健的弧长法对于成功穿越这些复杂的非线性响应至关重要。",
            "id": "3600849",
            "problem": "考虑非线性平衡路径的降阶追踪问题。该路径属于一个单参数平衡族，由以下单个代数方程隐式定义：\n$$\nF(u,\\lambda) = \\left(\\frac{u}{a}\\right)^2 + \\left(\\frac{\\lambda}{b}\\right)^2 - 1 = 0,\n$$\n其中 $u$ 是一个广义位移，$\\lambda$ 是一个广义载荷因子，$a0$，$b0$ 是给定的形状参数。该隐式曲线既有水平切线（载荷极限点，与控制 $\\lambda$ 时的突弹相关），也有垂直切线（位移极限点，与控制 $u$ 时的回弹相关）。本问题要求实现一个带有第二个约束方程 $g(u,\\lambda)=0$ 的增广牛顿求解器，以施加不同的控制策略，并评估它们穿越极限点段的能力。本问题中的所有量均为无量纲。\n\n从基本的延拓原理开始：平衡条件是 $F(u,\\lambda)=0$，延拓法通过一个标量控制约束 $g(u,\\lambda)=0$ 对其进行增广，从而在每一步通过牛顿法求解一个 $2\\times 2$ 系统来确定未知向量 $(u,\\lambda)$。令 $F$ 的雅可比矩阵为其梯度：\n$$\n\\nabla F(u,\\lambda) = \\left[\\frac{\\partial F}{\\partial u}, \\frac{\\partial F}{\\partial \\lambda}\\right] = \\left[\\frac{2u}{a^2}, \\frac{2\\lambda}{b^2}\\right].\n$$\n实现以下三种控制约束 $g(u,\\lambda)$ 的选择：\n\n- 载荷控制：$g(u,\\lambda) = \\lambda - \\lambda_{\\text{target}}$，其中 $\\lambda$ 有规定的目标增量。\n- 位移控制：$g(u,\\lambda) = u - u_{\\text{target}}$，其中 $u$ 有规定的目标增量。\n- 混合控制（带度量权重的球面弧长法）：$g(u,\\lambda) = (u - u_n)^2 + \\psi\\,(\\lambda - \\lambda_n)^2 - \\Delta s^2$，其中 $(u_n,\\lambda_n)$ 是上一步收敛的状态，$\\psi  0$ 是一个权重因子，$\\Delta s  0$ 是弧长步长。对于弧长预测步，使用单位切线 $t = [t_u,t_\\lambda]$，满足 $\\nabla F \\cdot t = 0$，并相对于度量 $\\text{diag}(1,\\psi)$ 进行归一化。\n\n您的程序必须为增广系统实现一个通用的 $2\\times 2$ 牛顿求解器：\n$$\n\\begin{bmatrix}\nF(u,\\lambda) \\\\\ng(u,\\lambda)\n\\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix},\n$$\n使用对应于每种 $g$ 选择的雅可比矩阵。\n\n使用 $a=1.0$ 和 $b=0.8$，将求解器应用于以下测试套件。所有起始点 $(u_0,\\lambda_0)$ 都是平衡曲线 $F=0$ 上的精确点。\n\n- 测试 A（载荷控制，预期在载荷极限点处失败）：从 $(u_0,\\lambda_0) = (0.866025403784,\\, 0.4)$ 开始，以固定的载荷增量 $\\Delta \\lambda = +0.05$ 执行 $N=10$ 步。在每一步 $k$，设置 $\\lambda_{\\text{target}} = \\lambda_{k-1} + \\Delta \\lambda$ 并求解 $(u_k,\\lambda_k)$。当且仅当所有 $N$ 步都收敛到增广系统的解时，宣布测试成功；否则宣布失败。\n\n- 测试 B（位移控制，预期在位移极限点处失败）：从 $(u_0,\\lambda_0) = \\left(0.5,\\, 0.8\\sqrt{1-0.5^2}\\right) = \\left(0.5,\\, 0.692820323027551\\right)$ 开始，以固定的位移增量 $\\Delta u = +0.07$ 执行 $N=10$ 步。在每一步 $k$，设置 $u_{\\text{target}} = u_{k-1} + \\Delta u$ 并求解 $(u_k,\\lambda_k)$。当且仅当所有 $N$ 步都收敛时，宣布测试成功；否则宣布失败。\n\n- 测试 C（通过球面弧长法进行混合控制，预期能够穿越突弹和回弹段）：从 $(u_0,\\lambda_0) = \\left(0.707106781186548,\\,-0.565685424949238\\right)$ 开始，取 $\\psi = 1.0$，使用 $\\Delta s = 0.1$，最多执行 $N_{\\max} = 120$ 步。使用一个与 $\\nabla F$ 正交并在度量 $\\text{diag}(1,\\psi)$ 下归一化的预测切线 $t$，其符号的选择应保持与前一切线的连续性。在每一步，先进行预测，然后应用牛顿法对带有弧长约束 $g$ 的增广系统进行校正。如果在至少 $N_{\\min} = 40$ 步之后，当前点 $(u_k,\\lambda_k)$ 回到距离起始点 $(u_0,\\lambda_0)$ 的欧几里得距离小于 $\\varepsilon_{\\text{close}} = 10^{-2}$ 的范围内，则宣布成功终止；否则宣布失败。\n\n- 测试 D（载荷控制，沿单调段的顺利路径）：从与测试 B 相同的点 $(u_0,\\lambda_0) = \\left(0.5,\\, 0.692820323027551\\right)$ 开始，以固定的载荷减量 $\\Delta \\lambda = -0.05$ 执行 $N=10$ 步。当且仅当所有 $N$ 步都收敛时，宣布测试成功。\n\n对于牛顿法，每次校正最多使用 $50$ 次迭代，增广残差向量的欧几里得范数的收敛容差为 $10^{-10}$。将任何在迭代限制内未能收敛、任何奇异雅可比矩阵求解或任何数值溢出都视为失败的步骤。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $[\\text{A},\\text{B},\\text{C},\\text{D}]$，其中每个条目是一个布尔值，表示该测试的成功状态。例如，如果测试 A 和 B 失败，测试 C 成功，测试 D 成功，输出应为 \"[False,False,True,True]\"。",
            "solution": "该问题要求实现并比较三种标准的延拓（路径跟踪）策略，用于追踪非线性系统的平衡路径。该系统由单个代数方程 $F(u,\\lambda)=0$ 定义，其中 $u$ 是广义位移，$\\lambda$ 是载荷参数。具体的平衡路径是一个椭圆，由下式给出：\n$$\nF(u,\\lambda) = \\left(\\frac{u}{a}\\right)^2 + \\left(\\frac{\\lambda}{b}\\right)^2 - 1 = 0\n$$\n其中 $a$ 和 $b$ 是给定的正常数。该曲线在 $(u,\\lambda) = (0, \\pm b)$ 处具有两个载荷极限点（水平切线），在 $(u,\\lambda) = (\\pm a, 0)$ 处具有两个位移极限点（垂直切线），它们分别与突弹和回弹失稳相关。\n\n延拓方法的核心原理是用一个控制约束 $g(u,\\lambda)=0$ 来增广平衡方程 $F(u,\\lambda)=0$。这就为两个未知数 $(u, \\lambda)$ 创建了一个方程组：\n$$\n\\mathbf{R}(u,\\lambda) = \\begin{bmatrix} F(u,\\lambda) \\\\ g(u,\\lambda) \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}\n$$\n在路径跟踪过程的每一步，都使用牛顿-拉夫逊迭代法求解该系统。对于迭代 $i$，更新规则为：\n$$\n\\begin{bmatrix} u_{i+1} \\\\ \\lambda_{i+1} \\end{bmatrix} = \\begin{bmatrix} u_i \\\\ \\lambda_i \\end{bmatrix} - \\mathbf{J}^{-1}(u_i, \\lambda_i) \\mathbf{R}(u_i, \\lambda_i)\n$$\n其中 $\\mathbf{J}(u,\\lambda)$ 是 $2 \\times 2$ 的增广雅可比矩阵：\n$$\n\\mathbf{J}(u,\\lambda) = \\frac{\\partial \\mathbf{R}}{\\partial (u, \\lambda)} = \\begin{bmatrix}\n\\frac{\\partial F}{\\partial u}  \\frac{\\partial F}{\\partial \\lambda} \\\\\n\\frac{\\partial g}{\\partial u}  \\frac{\\partial g}{\\partial \\lambda}\n\\end{bmatrix}\n$$\n平衡函数 $F$ 的梯度明确给出为 $\\nabla F(u,\\lambda) = \\left[\\frac{2u}{a^2}, \\frac{2\\lambda}{b^2}\\right]$。该程序实现了一个通用的牛顿求解器，它将系统函数 $\\mathbf{R}$ 及其雅可比矩阵 $\\mathbf{J}$ 作为输入，然后在每个测试用例的分析的每一步中求解 $(u, \\lambda)$。\n\n三种控制策略的实现如下：\n1.  **载荷控制**：约束为 $g(u,\\lambda) = \\lambda - \\lambda_{\\text{target}} = 0$。这在每一步都固定了载荷参数。约束的梯度为 $\\nabla g = [0, 1]$。增广雅可比矩阵为：\n    $$\n    \\mathbf{J}_{\\text{load}} = \\begin{bmatrix} \\frac{2u}{a^2}  \\frac{2\\lambda}{b^2} \\\\ 0  1 \\end{bmatrix}\n    $$\n    当其行列式 $\\frac{2u}{a^2}$ 为零时（即 $u=0$ 时），该矩阵变为奇异矩阵。这对应于一个载荷极限点（突弹），在该点平衡路径具有水平切线。在这些点上，载荷控制会失败。测试 A 旨在遇到这种失败。\n\n2.  **位移控制**：约束为 $g(u,\\lambda) = u - u_{\\text{target}} = 0$，这固定了位移。约束的梯度为 $\\nabla g = [1, 0]$。增广雅可比矩阵为：\n    $$\n    \\mathbf{J}_{\\text{disp}} = \\begin{bmatrix} \\frac{2u}{a^2}  \\frac{2\\lambda}{b^2} \\\\ 1  0 \\end{bmatrix}\n    $$\n    当其行列式 $-\\frac{2\\lambda}{b^2}$ 为零时（即 $\\lambda=0$ 时），该矩阵变为奇异矩阵。这对应于一个位移极限点（回弹），在该点路径具有垂直切线。位移控制在这些点上会失败。测试 B 旨在遇到这种失败。\n\n3.  **混合（弧长）控制**：此方法将步长约束在一个以先前收敛点 $(u_n, \\lambda_n)$ 为中心、半径为 $\\Delta s$ 的球面（在此二维情况下为圆）上。约束为 $g(u,\\lambda) = (u - u_n)^2 + \\psi(\\lambda - \\lambda_n)^2 - \\Delta s^2 = 0$。此约束的梯度为 $\\nabla g = [2(u-u_n), 2\\psi(\\lambda-\\lambda_n)]$。增广雅可比矩阵为：\n    $$\n    \\mathbf{J}_{\\text{arc}} = \\begin{bmatrix} \\frac{2u}{a^2}  \\frac{2\\lambda}{b^2} \\\\ 2(u-u_n)  2\\psi(\\lambda-\\lambda_n) \\end{bmatrix}\n    $$\n    该雅可比矩阵在载荷和位移极限点通常都是非奇异的，这使得弧长控制成为一种穿越复杂平衡路径的稳健方法。此方法使用预测-校正方案。\n    - **预测步**：通过在当前点 $(u_n, \\lambda_n)$ 沿曲线切线方向移动距离 $\\Delta s$ 来找到下一个点的初始猜测值。切向量 $\\mathbf{t} = [t_u, t_\\lambda]$ 与梯度 $\\nabla F$ 正交，即 $\\nabla F \\cdot \\mathbf{t} = 0$。一个有效的（未归一化的）切线是 $\\mathbf{t}' = [-\\frac{\\partial F}{\\partial \\lambda}, \\frac{\\partial F}{\\partial u}]$。然后根据指定的度量对此向量进行归一化：$\\mathbf{t} = \\mathbf{t}' / \\sqrt{t_u'^2 + \\psi t_\\lambda'^2}$。为确保路径连续追踪而不反向，切线的符号选择应使得在步骤 $k0$ 时 $\\mathbf{t}_k \\cdot \\mathbf{t}_{k-1}  0$。对于第一步，选择符号以启动椭圆的逆时针遍历。预测点则为 $(u_p, \\lambda_p) = (u_n, \\lambda_n) + \\Delta s \\cdot \\mathbf{t}$。\n    - **校正步**：使用牛顿求解器，以 $(u_p, \\lambda_p)$ 作为初始猜测值，来寻找平衡曲线 $F=0$ 和约束球面 $g=0$ 的交点。测试 C 使用此方法，并预期能成功追踪整个椭圆路径。\n\n测试 D 为载荷控制提供了一个“顺利路径”场景，其中载荷增量远离任何极限点，展示了这种简单方法在平衡路径的单调段上的成功应用。\n\n所实现的程序定义了一个通用的牛顿求解器，然后为问题中描述的每个测试用例设置了四个函数。每个函数配置适当的控制约束，运行路径跟踪循环，并根据指定的标准报告成功或失败。最终输出汇总了所有四个测试的布尔结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Global parameters from the problem statement\nA = 1.0\nB = 0.8\nNEWTON_TOL = 1e-10\nNEWTON_MAX_ITER = 50\n\ndef F_func(u, lam, a, b):\n    \"\"\"The equilibrium equation F(u, lambda) = 0.\"\"\"\n    return (u / a)**2 + (lam / b)**2 - 1.0\n\ndef grad_F_func(u, lam, a, b):\n    \"\"\"The gradient of the equilibrium equation, [dF/du, dF/dlam].\"\"\"\n    return np.array([2.0 * u / a**2, 2.0 * lam / b**2])\n\ndef newton_solver(system_func, jacobian_func, initial_guess):\n    \"\"\"\n    Solves a 2x2 system of nonlinear equations using Newton's method.\n\n    Args:\n        system_func: A callable F(u, lam) that returns the residual vector [F, g].\n        jacobian_func: A callable J(u, lam) that returns the Jacobian matrix.\n        initial_guess: A tuple or array (u, lam) for the initial guess.\n\n    Returns:\n        A tuple ((u, lam), success_flag), where (u, lam) is the solution\n        and success_flag is a boolean.\n    \"\"\"\n    x_k = np.array(initial_guess, dtype=float)\n\n    for _ in range(NEWTON_MAX_ITER):\n        try:\n            # Calculate residual and check for convergence\n            R = system_func(x_k[0], x_k[1])\n            norm_R = np.linalg.norm(R)\n\n            if norm_R  NEWTON_TOL:\n                return x_k, True  # Converged successfully\n\n            # Calculate Jacobian and solve for the update\n            J = jacobian_func(x_k[0], x_k[1])\n            delta_x = np.linalg.solve(J, -R)\n            \n            x_k += delta_x\n\n            if np.any(np.isinf(x_k)) or np.any(np.isnan(x_k)):\n                return None, False # Numerical overflow detected\n\n        except np.linalg.LinAlgError:\n            return None, False  # Singular Jacobian matrix\n        except (ValueError, OverflowError):\n            return None, False  # Other numerical errors\n\n    return None, False  # Failed to converge within max iterations\n\ndef run_test_A():\n    \"\"\"Test A: Load control, expected failure at a load limit point.\"\"\"\n    u_k, lam_k = 0.866025403784, 0.4\n    delta_lam = 0.05\n    num_steps = 10\n\n    for _ in range(num_steps):\n        lam_target = lam_k + delta_lam\n        \n        def system(u, lam):\n            return np.array([F_func(u, lam, A, B), lam - lam_target])\n\n        def jacobian(u, lam):\n            grad_F = grad_F_func(u, lam, A, B)\n            return np.array([[grad_F[0], grad_F[1]], [0.0, 1.0]])\n        \n        initial_guess = np.array([u_k, lam_k])\n        solution, converged = newton_solver(system, jacobian, initial_guess)\n\n        if not converged:\n            return False\n\n        u_k, lam_k = solution\n\n    return True\n\ndef run_test_B():\n    \"\"\"Test B: Displacement control, expected failure at a displacement limit point.\"\"\"\n    u_k, lam_k = 0.5, 0.692820323027551\n    delta_u = 0.07\n    num_steps = 10\n    \n    for _ in range(num_steps):\n        u_target = u_k + delta_u\n\n        def system(u, lam):\n            return np.array([F_func(u, lam, A, B), u - u_target])\n\n        def jacobian(u, lam):\n            grad_F = grad_F_func(u, lam, A, B)\n            return np.array([[grad_F[0], grad_F[1]], [1.0, 0.0]])\n            \n        initial_guess = np.array([u_k, lam_k])\n        solution, converged = newton_solver(system, jacobian, initial_guess)\n\n        if not converged:\n            return False\n\n        u_k, lam_k = solution\n\n    return True\n\ndef run_test_C():\n    \"\"\"Test C: Mixed control (arc-length), expected to traverse the full path.\"\"\"\n    u_start, lam_start = 0.707106781186548, -0.565685424949238\n    u_n, lam_n = u_start, lam_start\n    psi = 1.0\n    ds = 0.1\n    n_max = 120\n    n_min = 40\n    eps_close = 1e-2\n\n    gradF_0 = grad_F_func(u_n, lam_n, A, B)\n    t_un_0 = np.array([-gradF_0[1], gradF_0[0]])\n    norm_t_0 = np.sqrt(t_un_0[0]**2 + psi * t_un_0[1]**2)\n    t_prev = t_un_0 / norm_t_0\n\n    for k in range(1, n_max + 1):\n        u_p, lam_p = (u_n, lam_n) + ds * t_prev\n\n        def system(u, lam):\n            return np.array([\n                F_func(u, lam, A, B),\n                (u - u_n)**2 + psi * (lam - lam_n)**2 - ds**2\n            ])\n\n        def jacobian(u, lam):\n            grad_F = grad_F_func(u, lam, A, B)\n            return np.array([\n                [grad_F[0], grad_F[1]],\n                [2.0 * (u - u_n), 2.0 * psi * (lam - lam_n)]\n            ])\n\n        solution, converged = newton_solver(system, jacobian, (u_p, lam_p))\n        \n        if not converged:\n            return False\n\n        u_n, lam_n = solution\n\n        if k >= n_min:\n            dist = np.sqrt((u_n - u_start)**2 + (lam_n - lam_start)**2)\n            if dist  eps_close:\n                return True\n\n        gradF_k = grad_F_func(u_n, lam_n, A, B)\n        t_un_k = np.array([-gradF_k[1], gradF_k[0]])\n        norm_t_k = np.sqrt(t_un_k[0]**2 + psi * t_un_k[1]**2)\n        if norm_t_k  1e-12: return False\n        \n        t_k = t_un_k / norm_t_k\n        \n        if np.dot(t_k, t_prev)  0:\n            t_k = -t_k\n        \n        t_prev = t_k\n        \n    return False\n\ndef run_test_D():\n    \"\"\"Test D: Load control, happy path along a monotonic segment.\"\"\"\n    u_k, lam_k = 0.5, 0.692820323027551\n    delta_lam = -0.05\n    num_steps = 10\n\n    for _ in range(num_steps):\n        lam_target = lam_k + delta_lam\n\n        def system(u, lam):\n            return np.array([F_func(u, lam, A, B), lam - lam_target])\n\n        def jacobian(u, lam):\n            grad_F = grad_F_func(u, lam, A, B)\n            return np.array([[grad_F[0], grad_F[1]], [0.0, 1.0]])\n        \n        initial_guess = np.array([u_k, lam_k])\n        solution, converged = newton_solver(system, jacobian, initial_guess)\n\n        if not converged:\n            return False\n\n        u_k, lam_k = solution\n\n    return True\n\ndef solve():\n    \"\"\"\n    Executes the test suite and prints the final results.\n    \"\"\"\n    test_cases_funcs = [\n        run_test_A,\n        run_test_B,\n        run_test_C,\n        run_test_D,\n    ]\n\n    results = []\n    for test_func in test_cases_funcs:\n        results.append(test_func())\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "将理论和算法应用于连续介质力学是计算实体力学的重要一步。本练习要求你开发一个一维有限元程序，用于模拟一个经历材料软化和损伤的杆件，这是结构失稳的常见物理根源。你将接触到损伤力学、局部化模型中病态的网格敏感性，以及如何通过断裂能正则化来获得客观的、与网格无关的数值解等关键概念。这项实践将为你提供模拟材料失效及其与结构整体响应（包括突变行为）之间关联的宝贵经验。",
            "id": "3600892",
            "problem": "考虑一根长度为 $L$、横截面积为 $A$ 的一维受拉杆，该杆被离散为 $N$ 个双节点线性有限元。该杆处于准静态，无体力，并在拉伸过程中经历损伤引起的软化。其控制方程源于虚功原理和准静态条件下的线性动量守恒。设 $u(x)$ 表示轴向位移，$\\varepsilon(x) = \\frac{du}{dx}$ 表示轴向应变，$\\sigma(x)$ 表示轴向应力。本构响应为拉伸损伤线性弹性，由 $\\sigma = (1 - d) E \\varepsilon$ 给出，其中 $E$ 是杨氏模量，$d \\in [0,1)$ 是一个标量损伤变量，它随拉伸应变单调增加，在压缩时保持为零。损伤变量通过双线性峰后应力-应变本构来强制实现软化。\n\n拉伸过程中的双线性软化本构由三个应变水平 $0 \\le \\varepsilon \\le \\varepsilon_0 \\le \\varepsilon_1 \\le \\varepsilon_f$ 及相应的应力 $\\sigma(\\varepsilon_0) = \\sigma_0$ 和 $\\sigma(\\varepsilon_1) = \\sigma_1$ 定义，其中 $\\sigma_1 = r_{\\sigma} \\sigma_0$ 且 $0  r_{\\sigma}  1$。应力-应变函数 $s(\\varepsilon)$ 为\n$$\ns(\\varepsilon) = \n\\begin{cases}\nE \\varepsilon,  0 \\le \\varepsilon \\le \\varepsilon_0, \\\\\n\\sigma_0 + \\dfrac{\\sigma_1 - \\sigma_0}{\\varepsilon_1 - \\varepsilon_0} \\left(\\varepsilon - \\varepsilon_0\\right),  \\varepsilon_0  \\varepsilon \\le \\varepsilon_1, \\\\\n\\sigma_1 \\dfrac{\\varepsilon_f - \\varepsilon}{\\varepsilon_f - \\varepsilon_1},  \\varepsilon_1  \\varepsilon \\le \\varepsilon_f, \\\\\n0,  \\varepsilon > \\varepsilon_f,\n\\end{cases}\n$$\n其中 $\\sigma_0 = E \\varepsilon_0$。损伤变量由 $s(\\varepsilon) = (1 - d) E \\varepsilon$ 隐式定义，即\n$$\nd(\\varepsilon) = 1 - \\frac{s(\\varepsilon)}{E \\varepsilon} \\quad \\text{对于 } \\varepsilon > 0, \\quad d(\\varepsilon) = 0 \\text{ 对于 } \\varepsilon \\le 0,\n$$\n并强制其随加载单调不减。\n\n对于位移控制，指定端点位移 $u(0) = 0$ 和 $u(L) = \\bar{u}$，通过组装全局刚度矩阵来求解内部节点位移，其中单元刚度为 $k_e = (1 - d_e) \\dfrac{E A}{h_e} \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix}$，$h_e$ 是单元长度，$d_e$ 是在当前应变下评估的单元损伤。$x=L$ 处的反力 $P(\\bar{u})$ 可通过分块施加本质边界条件从全局平衡方程 $K u = f$（其中 $f=0$）中获得。在载荷控制下，当载荷-位移响应具有负增量刚度时，即当 $\\dfrac{dP}{d\\bar{u}}  0$ 时，会出现失稳（回弹）。\n\n为量化网格敏感性，考虑两种建模选项：\n- 局部损伤模型：软化参数 $\\varepsilon_f$ 与 $h_e$ 无关。\n- 正则化损伤模型：通过指定单位面积的断裂能 $G_f$ 来强制实现网格无关的能量耗散，使得峰后应力-应变曲线下的面积满足\n$$\nh_e \\int_{\\varepsilon_0}^{\\varepsilon_f} s(\\varepsilon)\\, d\\varepsilon = G_f,\n$$\n对于双线性本构，这意味着\n$$\nh_e \\left[ \\frac{\\sigma_0 + \\sigma_1}{2} (\\varepsilon_1 - \\varepsilon_0) + \\frac{\\sigma_1}{2} (\\varepsilon_f - \\varepsilon_1) \\right] = G_f,\n$$\n因此\n$$\n\\varepsilon_f = \\varepsilon_1 + \\frac{2}{\\sigma_1} \\left( \\frac{G_f}{h_e} - \\frac{\\sigma_0 + \\sigma_1}{2} (\\varepsilon_1 - \\varepsilon_0) \\right),\n$$\n前提是括号中的项为非负；否则将 $\\varepsilon_f$ 设置为略高于 $\\varepsilon_1$ 以避免不适定性。\n\n实施一个采用算子分裂的位移控制增量分析：在 $\\bar{u}$ 的每个增量步，使用当前损伤状态求解位移，更新应变，使用双线性本构更新损伤并强制单调性，然后迭代直至收敛。计算载荷-位移曲线 $P(\\bar{u})$，通过检查离散斜率 $\\Delta P / \\Delta \\bar{u}$ 的符号来检测回弹，并使用数值积分（梯形法则）计算外力功 $W = \\int P(\\bar{u})\\, d\\bar{u}$。使用一个轻微的非均匀性来触发局部化：在一个“有缺陷”的单元中，将 $\\varepsilon_0$ 和 $\\varepsilon_1$ 乘以一个小的因子，同时保持相同的 $r_{\\sigma}$。\n\n您的程序必须评估以下测试套件，所有量均采用国际单位制 (SI)，角度不适用。载荷以牛顿 (N) 表示，位移以米 (m) 表示，能量以牛顿米 (N·m) 表示。返回四舍五入到六位小数的浮点数值，以及 Python 字面量形式的布尔值。\n\n所有测试的通用参数：\n- $L = 1.0\\,\\mathrm{m}$，\n- $A = 1.0 \\times 10^{-4}\\,\\mathrm{m}^2$，\n- $E = 7.0 \\times 10^{10}\\,\\mathrm{Pa}$，\n- $\\varepsilon_0 = 0.002$，\n- $\\varepsilon_1 = 0.006$，\n- $r_{\\sigma} = 0.5$ 使得 $\\sigma_1 = r_{\\sigma} \\sigma_0$，\n- 有缺陷单元的索引为中间单元，该单元的 $\\varepsilon_0$ 和 $\\varepsilon_1$ 乘以 $(1 - \\delta)$，其中 $\\delta = 0.02$，\n- 损伤上限为 $d_{\\max} = 0.9999$ 以避免刚度矩阵奇异。\n\n测试案例：\n1. 局部模型，$N = 20$，所有单元的 $\\varepsilon_f = 0.02$，但有缺陷的单元其 $\\varepsilon_f$ 也乘以 $(1 - \\delta)$。使用 $400$ 个位移增量，直到 $\\bar{u}_{\\max} = 1.2\\, h_{\\ell}\\, \\varepsilon_{f,\\ell}$，其中 $h_{\\ell}$ 是有缺陷单元的长度，$\\varepsilon_{f,\\ell}$ 是其 $\\varepsilon_f$ 值。\n2. 局部模型，$N = 100$，与案例1相同。\n3. 正则化模型，$N = 20$，$G_f = 50000\\,\\mathrm{N/m}$。根据上述能量条件计算每个单元的 $\\varepsilon_f$。使用 $400$ 个增量，直到 $\\bar{u}_{\\max} = 1.2\\, h_{\\ell}\\, \\varepsilon_{f,\\ell}$，如案例1。\n4. 正则化模型，$N = 100$，$G_f = 50000\\,\\mathrm{N/m}$，采用相同的增量策略。\n\n对于每个测试案例，计算：\n- $P_{\\text{peak}}$ (N)，\n- $\\bar{u}_{\\text{peak}}$ (m)，即 $P(\\bar{u})$ 达到其最大值时的位移，\n- 一个布尔标志 $\\text{has\\_snapback}$，如果任何离散斜率 $\\Delta P / \\Delta \\bar{u}$ 为负，则为 $true$，\n- 外力功 $W$ (N·m)，作为 $P(\\bar{u})$ 在计算的 $\\bar{u}$ 范围内的梯形积分。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果，每个测试案例一个子列表，按上述顺序排列。每个子列表必须是四个值 $[P_{\\text{peak}}, \\bar{u}_{\\text{peak}}, \\text{has\\_snapback}, W]$。例如，一个包含两个测试案例的输出看起来像 $[[1.0,0.1,true,0.05],[2.0,0.2,false,0.10]]$。",
            "solution": "用户提供的问题是一个在计算固体力学领域中定义良好且有科学依据的练习，特别关注材料非线性、损伤力学和结构失稳。该问题是有效且可解的。\n\n求解需要实现一个一维（$1$D）非线性有限元分析，用于模拟经历损伤和软化的受拉杆。该分析在位移控制下进行，以追踪完整的载荷-位移响应，包括可能发生回弹失稳的峰后软化阶段。求解的核心在于一个交错（或算子分裂）迭代格式，它处理力学变形和材料损伤演化之间的耦合。\n\n以下步骤和原则概述了求解方法的系统构建过程。\n\n### 1. 虚功原理与有限元离散化\n该问题由线性动量守恒控制，在准静态条件下，其弱形式通过虚功原理表达：对于任何运动学容许的虚位移，内力虚功必须等于外力虚功。长度为 $L$ 的杆被离散为 $N$ 个双节点线性有限元。每个单元 $e$ 的长度为 $h_e = L/N$。位移场 $u(x)$ 被近似为分段线性函数，由节点 $x_i$ 处的节点位移 $u_i$ 唯一确定。在每个单元内，应变 $\\varepsilon_e$ 是恒定的，由 $\\varepsilon_e = (u_{e+1} - u_e) / h_e$ 给出，其中 $u_e$ 和 $u_{e+1}$ 是该单元两个节点的位移。\n\n单元刚度矩阵 $k_e$ 关联了节点力与节点位移。对于线性弹性材料，$k_e = \\frac{E A}{h_e} \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix}$，其中 $E$ 是杨氏模量，$A$ 是横截面积。在此问题中，通过降低刚度来引入损伤，从而得到切向单元刚度矩阵：\n$$\nk_e = (1 - d_e) \\frac{E A}{h_e} \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix}\n$$\n这里，$d_e$ 是单元 $e$ 的标量损伤变量，假定在单元内是恒定的。具有 $N+1$ 个节点的全局刚度矩阵 $K$ 是通过将所有 $N$ 个单元刚度矩阵的贡献相加而组装起来的。\n\n### 2. 本构模型：具有双线性软化的损伤弹性\n由于损伤，材料的本构行为是非线性的。应力 $\\sigma$ 与应变 $\\varepsilon$ 通过 $\\sigma = (1-d)E\\varepsilon$ 相关联。损伤变量 $d$ 本身取决于应变历史。拉伸过程中的应力-应变关系 $s(\\varepsilon)$ 由一个峰后双线性软化本构定义。在应变达到 $\\varepsilon_0$ 之前，材料是线性弹性的，应力为 $\\sigma_0 = E \\varepsilon_0$。在此峰值之后，应力在两个线性段内减小，直到在最终应变 $\\varepsilon_f$ 时达到零。$s(\\varepsilon)$ 的具体形式在问题陈述中给出。\n\n损伤变量 $d$ 从此应力-应变本构中导出：\n$$\nd(\\varepsilon) = 1 - \\frac{s(\\varepsilon)}{E \\varepsilon} \\quad \\text{对于 } \\varepsilon > 0\n$$\n为了解释损伤的不可逆性，它必须是加载的非减函数。这是通过在材料点整个历史中所经历的最大拉伸应变 $\\varepsilon_{\\max}$ 处评估损伤本构来实现的，即 $d = d(\\varepsilon_{\\max})$。对于每个单元 $e$，都会存储一个历史变量 $\\varepsilon_{\\max,e}$ 并在每个步骤中更新。为防止单元刚度变为零（这会导致奇异的全局刚度矩阵），损伤被限制在 $d_{\\max} = 0.9999$。\n\n### 3. 网格依赖性与正则化\n局部损伤模型，其中像 $\\varepsilon_f$ 这样的材料参数是常数，会遭受病态的网格依赖性：随着网格细化（$h_e \\to 0$），软化响应变得更脆，破坏过程中耗散的能量趋于零。为了对模型进行正则化，该问题引入了断裂能方法。单位面积耗散的总能量 $G_f$ 被指定为一种材料属性。该能量对应于峰值应力后应力-应变曲线下的面积。通过强制要求应力在软化应变范围上所做的功（按单元体积缩放）等于一个恒定的断裂能 $G_f$，我们可以使整体结构响应相对于网格细化是客观的。\n破坏应变 $\\varepsilon_f$ 不再是常数，而是为每个单元计算以满足能量等效性：\n$$\nh_e \\int_{\\varepsilon_0}^{\\varepsilon_f} s(\\varepsilon)\\, d\\varepsilon = G_f\n$$\n对于给定的双线性本构，这导出了问题中提供的关于 $\\varepsilon_f$ 作为 $h_e$ 和其他材料参数的函数的代数表达式。\n\n### 4. 数值解法：增量-迭代交错格式\n由于依赖于损伤的刚度，该问题是高度非线性的。一个鲁棒的解是通过使用位移控制的增量分析与迭代交错（算子分裂）格式相结合得到的。在 $u(L)$ 处的总指定位移 $\\bar{u}_{\\max}$ 以小增量施加。对于 $\\bar{u}$ 的每个增量：\n1.  **初始化**：从上一个位移步收敛的损伤状态 $d_{e}^{\\text{old}}$ 开始。\n2.  **迭代至收敛**：进入一个不动点迭代循环，以找到当前 $\\bar{u}$ 下一致的损伤场和位移场。\n    a.  **组装与求解**：使用当前损伤状态 $d_{e}^{\\text{old}}$ 组装全局刚度矩阵 $K$。通过对系统进行分块来施加边界条件（$u_0 = 0$, $u_N = \\bar{u}$）。求解线性系统 $K_{II} u_I = -K_{IE} u_E$ 以获得未知的内部节点位移 $u_I$。\n    b.  **更新状态**：利用完整位移向量 $u$，计算新的单元应变 $\\varepsilon_e$。更新最大应变历史 $\\varepsilon_{\\max,e} = \\max(\\varepsilon_{\\max,e}, \\varepsilon_e)$。\n    c.  **更新损伤**：根据每个单元更新后的最大应变历史 $\\varepsilon_{\\max,e}$ 及其材料参数（$\\varepsilon_0$, $\\varepsilon_1$, $\\varepsilon_f$），计算新的损伤状态 $d_{e}^{\\text{new}}$。\n    d.  **检查收敛性**：将新的损伤向量 $d^{\\text{new}}$ 与旧的 $d^{\\text{old}}$ 进行比较。如果它们差值的范数 $\\|d^{\\text{new}} - d^{\\text{old}}\\|$ 低于一个容差，则非线性步骤已收敛。退出循环。否则，设置 $d_{e}^{\\text{old}} \\leftarrow d_{e}^{\\text{new}}$ 并从步骤 2a 重复。\n3.  **存储结果**：一旦收敛，从方程 $f_E = K_{EI} u_I + K_{EE} u_E$ 计算右端的反力 $P(\\bar{u})$。存储配对 $(\\bar{u}, P(\\bar{u}))$。\n\n引入一个小的非均匀性（一个强度稍低的“有缺陷”单元）以可预测的方式触发应变局部化，从而使数值问题适定。\n\n### 5. 后处理与输出计算\n完成所有位移增量后，对收集的载荷-位移数据 $(\\bar{u}, P(\\bar{u}))$ 进行分析：\n-   **峰值载荷 ($P_{\\text{peak}}$)及其对应的位移 ($\\bar{u}_{\\text{peak}}$)**：通过在计算出的反力数组中搜索最大值来找到。\n-   **回弹失稳 ($\\text{has\\_snapback}$)**：检查曲线是否存在任何负斜率，即对于任何增量 $i$，是否有 $P_{i+1}  P_i$。存在这样的段落表明发生了回弹。\n-   **外力功 ($W$)**：对杆做的总外力功是反力在指定位移上的积分，$W = \\int_{0}^{\\bar{u}_{\\max}} P(\\bar{u})\\, d\\bar{u}$。该积分使用梯形法则从离散数据点进行数值计算。\n\n该实现将处理四个不同的测试案例，改变单元数量（$N=20$ 对比 $N=100$）和损伤模型（局部与正则化），并报告每个案例的四个计算指标。结果将突显局部模型的网格依赖性以及基于断裂能方法的正则化效果。",
            "answer": "```python\nimport numpy as np\n\n# Global constants and material properties from the problem statement\nL = 1.0  # m\nA = 1.0e-4  # m^2\nE = 7.0e10  # Pa\nEPSILON_0_REF = 0.002\nEPSILON_1_REF = 0.006\nR_SIGMA = 0.5\nDELTA = 0.02\nG_F = 50000.0  # N/m\nD_MAX = 0.9999\nN_INCR = 400\nNL_TOL = 1e-8\nNL_MAX_ITER = 50\n\ndef get_stress(eps, eps_0, eps_1, eps_f, E):\n    \"\"\"\n    Computes stress based on the bilinear softening law for a given strain.\n    Assumes strain represents the monotonic loading path.\n    \"\"\"\n    if eps = 0:\n        return E * eps  # Elastic in compression\n    \n    sigma_0 = E * eps_0\n    sigma_1 = R_SIGMA * sigma_0\n    \n    if eps = eps_0:\n        return E * eps\n    elif eps = eps_1:\n        if abs(eps_1 - eps_0)  1e-12: return sigma_0\n        return sigma_0 + (sigma_1 - sigma_0) / (eps_1 - eps_0) * (eps - eps_0)\n    elif eps = eps_f:\n        if abs(eps_f - eps_1)  1e-12: return 0.0\n        return sigma_1 * (eps_f - eps) / (eps_f - eps_1)\n    else:\n        return 0.0\n\ndef get_damage(eps, eps_0, eps_1, eps_f, E):\n    \"\"\"\n    Computes the damage variable d(eps) based on the stress law.\n    \"\"\"\n    if eps = eps_0:\n        return 0.0\n    \n    stress = get_stress(eps, eps_0, eps_1, eps_f, E)\n    if eps > 1e-12: # Avoid division by zero\n        damage = 1.0 - stress / (E * eps)\n    else:\n        damage = 0.0\n        \n    return min(damage, D_MAX)\n\ndef run_simulation(params):\n    \"\"\"\n    Performs a full nonlinear finite element simulation for one test case.\n    \"\"\"\n    # 1. Setup mesh and material properties\n    N = params['N']\n    h_e = L / N\n    num_nodes = N + 1\n    \n    eps_0_e = np.full(N, EPSILON_0_REF)\n    eps_1_e = np.full(N, EPSILON_1_REF)\n    eps_f_e = np.zeros(N)\n\n    flawed_elem_idx = N // 2\n    \n    eps_0_e[flawed_elem_idx] *= (1.0 - DELTA)\n    eps_1_e[flawed_elem_idx] *= (1.0 - DELTA)\n\n    if params['model_type'] == 'local':\n        eps_f_e.fill(params['epsilon_f_ref'])\n        eps_f_e[flawed_elem_idx] *= (1.0 - DELTA)\n    else: # 'regularized'\n        G_f = params['G_f']\n        for i in range(N):\n            e0, e1 = eps_0_e[i], eps_1_e[i]\n            s0 = E * e0\n            s1 = R_SIGMA * s0\n            \n            if s1  1e-9:\n                eps_f_e[i] = e1 * 1.001\n                continue\n\n            term = G_f / h_e - (s0 + s1) / 2.0 * (e1 - e0)\n            if term >= 0:\n                eps_f_e[i] = e1 + (2.0 / s1) * term\n            else:\n                eps_f_e[i] = e1 * 1.001\n\n    # 2. Simulation initialization\n    u_max = 1.2 * h_e * eps_f_e[flawed_elem_idx]\n    u_bar_steps = np.linspace(0, u_max, N_INCR)\n    \n    u = np.zeros(num_nodes)\n    d_e = np.zeros(N)\n    eps_max_e = np.zeros(N)\n    \n    load_disp_curve = [(0.0, 0.0)]\n    singular_failure = False\n\n    # 3. Incremental displacement-controlled loop\n    for i, u_bar in enumerate(u_bar_steps):\n        if i == 0: continue\n        \n        # Non-linear solver loop (staggered scheme)\n        for _ in range(NL_MAX_ITER):\n            K = np.zeros((num_nodes, num_nodes))\n            for e in range(N):\n                k_scalar = (1.0 - d_e[e]) * E * A / h_e\n                k_el = k_scalar * np.array([[1, -1], [-1, 1]])\n                K[e:e+2, e:e+2] += k_el\n\n            K_II = K[1:-1, 1:-1]\n            K_IE = K[1:-1, [0, -1]]\n            u_E = np.array([0, u_bar])\n            \n            f_ext_I = -K_IE @ u_E\n            \n            try:\n                u_I = np.linalg.solve(K_II, f_ext_I)\n            except np.linalg.LinAlgError:\n                for j in range(i, N_INCR):\n                    load_disp_curve.append((u_bar_steps[j], 0.0))\n                singular_failure = True\n                break\n\n            u[1:-1] = u_I\n            u[-1] = u_bar\n            \n            new_d_e = np.zeros(N)\n            strains = np.diff(u) / h_e\n            eps_max_e = np.maximum(eps_max_e, strains)\n            \n            for e in range(N):\n                new_d_e[e] = get_damage(eps_max_e[e], eps_0_e[e], eps_1_e[e], eps_f_e[e], E)\n            \n            d_norm_diff = np.linalg.norm(new_d_e - d_e)\n            d_e = new_d_e\n            \n            if d_norm_diff  NL_TOL:\n                break\n        \n        if singular_failure:\n            break\n        \n        K_EI = K[[0, -1], 1:-1]\n        K_EE = K[[0, -1], [0, -1]]\n        f_E = K_EI @ u_I + K_EE @ u_E\n        P = f_E[1]\n        \n        load_disp_curve.append((u_bar, P))\n        \n    # 4. Post-process results\n    disps = np.array([p[0] for p in load_disp_curve])\n    loads = np.array([p[1] for p in load_disp_curve])\n\n    P_peak, u_peak = (0.0, 0.0)\n    if len(loads) > 0 and np.any(loads > 0):\n        peak_idx = np.argmax(loads)\n        P_peak = loads[peak_idx]\n        u_peak = disps[peak_idx]\n\n    has_snapback = np.any(np.diff(loads)  0)\n    \n    W = np.trapz(loads, disps)\n\n    return [P_peak, u_peak, bool(has_snapback), W]\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the test cases and print the final result.\n    \"\"\"\n    test_cases = [\n        {'model_type': 'local', 'N': 20, 'epsilon_f_ref': 0.02},\n        {'model_type': 'local', 'N': 100, 'epsilon_f_ref': 0.02},\n        {'model_type': 'regularized', 'N': 20, 'G_f': G_F},\n        {'model_type': 'regularized', 'N': 100, 'G_f': G_F},\n    ]\n\n    results = []\n    for params in test_cases:\n        result = run_simulation(params)\n        results.append(result)\n\n    formatted_results = []\n    for res in results:\n        p_peak_str = f\"{res[0]:.6f}\"\n        u_peak_str = f\"{res[1]:.6f}\"\n        snap_str = str(res[2]).lower()\n        w_str = f\"{res[3]:.6f}\"\n        formatted_results.append(f\"[{p_peak_str},{u_peak_str},{snap_str},{w_str}]\")\n\n    final_output_string = f\"[{','.join(formatted_results)}]\"\n    print(final_output_string)\n\nsolve()\n```"
        }
    ]
}