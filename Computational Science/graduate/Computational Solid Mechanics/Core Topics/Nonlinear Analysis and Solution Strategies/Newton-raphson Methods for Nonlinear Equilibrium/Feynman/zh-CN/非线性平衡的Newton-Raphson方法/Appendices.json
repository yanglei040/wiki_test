{
    "hands_on_practices": [
        {
            "introduction": "在求解任何非线性问题时，首要任务是量化当前状态与平衡状态之间的偏差。在有限元方法中，这个偏差由“残差向量”表示，它代表了节点上内外力的不平衡。本练习将指导您从虚功原理出发，为一个具有非线性材料本构的一维杆件推导并计算离散的残差向量，这是构建任何牛顿求解器的基础。",
            "id": "3583531",
            "problem": "考虑一根长度为 $L = 2\\,\\mathrm{m}$、均匀横截面积为 $A = 1\\,\\mathrm{m^2}$ 的准静态一维杆。其非线性材料本构关系为 $\\sigma(\\varepsilon) = E\\,\\varepsilon + \\alpha\\,\\varepsilon^{3}$，其中 $\\sigma$ 是柯西应力，$\\varepsilon$ 是小应变。该杆受到分布载荷 $q(x) = q_{0}\\,x$ 的作用，其中 $q_{0} = 1.0 \\times 10^{5}\\,\\mathrm{N/m^2}$，并在 $x=0$ 和 $x=L$ 处具有无牵引力的边界条件。\n\n使用有限元法 (FEM) 和牛顿-拉夫森法 (NR) 求解非线性平衡问题，从平衡的强形式及其通过虚功原理 (PVW) 得到的弱形式出发。对于区间 $[x_{i}, x_{j}]$ 上的一个使用标准线性形函数的线性两节点单元，推导其节点残差向量 $r^{e}(u)$ 关于内力和外力贡献的单元级表达式。然后，在一个包含2个等长线性单元、跨越 $[0,2]$ 且节点位于 $x_{0}=0$、$x_{1}=1$ 和 $x_{2}=2$ 的网格上，组集全局残差向量 $r(u)$。\n\n给定节点值 $u_{0} = 0\\,\\mathrm{m}$、$u_{1} = 0.10\\,\\mathrm{m}$ 和 $u_{2} = 0.25\\,\\mathrm{m}$ 定义的离散位移场 $u_{h}(x)$，以及材料参数 $E = 10^{6}\\,\\mathrm{Pa}$ 和 $\\alpha = 10^{7}\\,\\mathrm{Pa}$，计算残差向量。在可能的情况下使用精确计算。以牛顿 (N) 为单位表示最终的节点残差向量。最终答案必须是包含三个节点残差的单行矩阵。无需四舍五入；提供精确值。",
            "solution": "该问题陈述已经过验证，被认为是有效的。其科学基础在于连续介质力学和有限元法的原理，是适定的、客观的，并为得出唯一解提供了所有必要的数据。对于分布载荷 $q(x)$（其中 $q_0$ 的单位为 N/m$^2$）的解释，可通过量纲分析解决：项 $q(x)=q_0 x$ 代表单位长度上的力，其单位为 $(N/m^2) \\cdot m = N/m$，这对于一维杆问题是一致的。\n\n求解过程首先建立控制方程的强形式和弱形式，然后推导有限元残差表达式，最后对指定的网格和位移场计算这些表达式的值。\n\n**1. 控制方程**\n\n一维杆平衡方程的强形式为：\n$$\n\\frac{d(N)}{dx} + f(x) = 0 \\quad \\text{for } x \\in (0, L)\n$$\n其中 $N$ 是轴向力，$f(x)$ 是单位长度上的分布轴向载荷。轴向力为 $N = A\\sigma$，其中 $A$ 是横截面积，$\\sigma$ 是柯西应力。分布载荷由 $q(x) = q_0 x$ 给出，因此我们认定 $f(x) = q(x)$。对于常数截面积 $A$，平衡方程变为：\n$$\nA\\frac{d\\sigma}{dx} + q_0 x = 0\n$$\n材料本构是非线性的：$\\sigma(\\varepsilon) = E\\varepsilon + \\alpha\\varepsilon^3$。应变-位移关系为 $\\varepsilon = \\frac{du}{dx}$。问题指定了无牵引力的边界条件，这意味着在 $x=0$ 和 $x=L$ 处轴向力 $N$ 为零。\n\n为推导弱形式，我们采用虚功原理 (PVW)。我们将平衡方程乘以一个虚位移 $\\delta u$，并在域 $[0,L]$ 上积分：\n$$\n\\int_{0}^{L} \\delta u \\left( A\\frac{d\\sigma}{dx} + q(x) \\right) dx = 0\n$$\n对第一项进行分部积分，得到：\n$$\n\\left[ \\delta u (A\\sigma) \\right]_0^L - \\int_0^L (A\\sigma) \\frac{d(\\delta u)}{dx} dx + \\int_0^L \\delta u q(x) dx = 0\n$$\n边界项 $\\left[ \\delta u (A\\sigma) \\right]_0^L$ 代表边界上外部点力所做的功。由于边界是无牵引力的，$A\\sigma(0)=0$ 且 $A\\sigma(L)=0$，因此该项为零。虚位移的导数是虚应变，$\\delta\\varepsilon = d(\\delta u)/dx$。因此，弱形式为：\n$$\n\\int_0^L \\sigma(\\varepsilon) \\delta\\varepsilon A \\,dx - \\int_0^L q(x) \\delta u \\,dx = 0\n$$\n对于牛顿-拉夫森法，我们定义残差，它表示给定一个位移场 $u(x)$ 时内力和外力之间的不平衡。残差泛函 $R(u, \\delta u)$ 为：\n$$\nR(u, \\delta u) = \\int_0^L A\\sigma(\\varepsilon) \\delta\\varepsilon \\,dx - \\int_0^L q(x) \\delta u \\,dx\n$$\n当 $R(u, \\delta u) = 0$ 对所有容许的虚位移 $\\delta u$ 成立时，达到平衡。\n\n**2. 有限元列式**\n\n我们将域离散为有限元。对于一个在 $[x_i, x_j]$ 上的通用两节点线性单元，位移 $u(x)$ 由节点位移 $u_i$ 和 $u_j$ 插值得到：\n$$\nu(x) = N_i(x)u_i + N_j(x)u_j = \\boldsymbol{N}(x) \\boldsymbol{u}^e\n$$\n其中 $\\boldsymbol{u}^e = \\begin{pmatrix} u_i  u_j \\end{pmatrix}^T$ 且 $\\boldsymbol{N} = \\begin{pmatrix} N_i(x)  N_j(x) \\end{pmatrix}$。线性形函数为：\n$$\nN_i(x) = \\frac{x_j-x}{L_e}, \\quad N_j(x) = \\frac{x-x_i}{L_e}\n$$\n单元长度为 $L_e = x_j - x_i$。单元内的应变 $\\varepsilon$ 是常数：\n$$\n\\varepsilon_e = \\frac{du}{dx} = \\frac{d\\boldsymbol{N}}{dx}\\boldsymbol{u}^e = \\begin{pmatrix} -\\frac{1}{L_e}  \\frac{1}{L_e} \\end{pmatrix} \\begin{pmatrix} u_i \\\\ u_j \\end{pmatrix} = \\frac{u_j - u_i}{L_e}\n$$\n应变-位移矩阵为 $\\boldsymbol{B} = \\frac{1}{L_e} \\begin{pmatrix} -1  1 \\end{pmatrix}$。虚位移和虚应变也以类似方式插值：$\\delta u = \\boldsymbol{N} \\boldsymbol{\\delta u}^e$ 和 $\\delta\\varepsilon = \\boldsymbol{B} \\boldsymbol{\\delta u}^e$。\n\n将这些代入残差泛函并对所有单元求和，得到：\n$$\n(\\boldsymbol{\\delta u})^T \\boldsymbol{r} = \\sum_e (\\boldsymbol{\\delta u}^e)^T \\left( \\int_{x_i}^{x_j} A \\sigma(\\varepsilon_e) \\boldsymbol{B}^T dx - \\int_{x_i}^{x_j} q(x) \\boldsymbol{N}^T dx \\right)\n$$\n其中 $\\boldsymbol{r}$ 是全局节点残差向量。我们可以识别出单元残差向量 $\\boldsymbol{r}^e$：\n$$\n\\boldsymbol{r}^e = \\boldsymbol{f}_{int}^e - \\boldsymbol{f}_{ext}^e\n$$\n其中 $\\boldsymbol{f}_{int}^e$ 是单元内力向量，$\\boldsymbol{f}_{ext}^e$ 是单元外力向量。\n\n**单元内力向量 $\\boldsymbol{f}_{int}^e$ 的推导：**\n$$\n\\boldsymbol{f}_{int}^e = \\int_{x_i}^{x_j} A \\sigma(\\varepsilon_e) \\boldsymbol{B}^T dx = A \\sigma(\\varepsilon_e) \\boldsymbol{B}^T \\int_{x_i}^{x_j} dx = A L_e \\sigma(\\varepsilon_e) \\boldsymbol{B}^T\n$$\n$$\n\\boldsymbol{f}_{int}^e = A L_e \\left( E\\varepsilon_e + \\alpha\\varepsilon_e^3 \\right) \\frac{1}{L_e} \\begin{pmatrix} -1 \\\\ 1 \\end{pmatrix} = A \\left( E\\varepsilon_e + \\alpha\\varepsilon_e^3 \\right) \\begin{pmatrix} -1 \\\\ 1 \\end{pmatrix}\n$$\n\n**单元外力向量 $\\boldsymbol{f}_{ext}^e$ 的推导：**\n$$\n\\boldsymbol{f}_{ext}^e = \\int_{x_i}^{x_j} q(x) \\boldsymbol{N}^T dx = \\int_{x_i}^{x_j} q_0 x \\begin{pmatrix} (x_j-x)/L_e \\\\ (x-x_i)/L_e \\end{pmatrix} dx\n$$\n该积分的计算得出线性载荷作用于线性单元上的标准结果：\n$$\n\\boldsymbol{f}_{ext}^e = \\frac{q_0 L_e}{6} \\begin{pmatrix} 2x_i + x_j \\\\ x_i + 2x_j \\end{pmatrix}\n$$\n\n**3. 数值计算**\n\n杆被离散为2个等长单元。\n- 总长 $L=2\\,\\mathrm{m}$，因此每个单元长度为 $L_e=1\\,\\mathrm{m}$。\n- 节点位于 $x_0=0$, $x_1=1$, and $x_2=2$。\n- 材料参数：$A=1\\,\\mathrm{m^2}$, $E=10^6\\,\\mathrm{Pa}$, $\\alpha=10^7\\,\\mathrm{Pa}$。\n- 载荷参数：$q_0=10^5\\,\\mathrm{N/m^2}$。\n- 节点位移：$u_0=0\\,\\mathrm{m}$, $u_1=0.1\\,\\mathrm{m}$, $u_2=0.25\\,\\mathrm{m}$。\n\n**单元1 (节点0, 1):**\n$x_i=0$, $x_j=1$, $L_e=1$。节点位移 $u_0=0, u_1=0.1$。\n- 应变: $\\varepsilon^{(1)} = (u_1 - u_0)/L_e = (0.1 - 0)/1 = 0.1$。\n- 应力: $\\sigma^{(1)} = E\\varepsilon^{(1)} + \\alpha(\\varepsilon^{(1)})^3 = 10^6(0.1) + 10^7(0.1)^3 = 10^5 + 10^4 = 1.1 \\times 10^5\\,\\mathrm{Pa}$。\n- 内力向量: $\\boldsymbol{f}_{int}^{(1)} = A\\sigma^{(1)}\\begin{pmatrix} -1 \\\\ 1 \\end{pmatrix} = 1 \\cdot (1.1 \\times 10^5) \\begin{pmatrix} -1 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} -110000 \\\\ 110000 \\end{pmatrix}\\,\\mathrm{N}$。\n- 外力向量: $\\boldsymbol{f}_{ext}^{(1)} = \\frac{10^5 \\cdot 1}{6}\\begin{pmatrix} 2(0)+1 \\\\ 0+2(1) \\end{pmatrix} = \\frac{10^5}{6}\\begin{pmatrix} 1 \\\\ 2 \\end{pmatrix} = \\begin{pmatrix} 50000/3 \\\\ 100000/3 \\end{pmatrix}\\,\\mathrm{N}$。\n- 残差向量: $\\boldsymbol{r}^{(1)} = \\boldsymbol{f}_{int}^{(1)} - \\boldsymbol{f}_{ext}^{(1)} = \\begin{pmatrix} -110000 - 50000/3 \\\\ 110000 - 100000/3 \\end{pmatrix} = \\begin{pmatrix} -430000/3 \\\\ 230000/3 \\end{pmatrix}\\,\\mathrm{N}$。\n等等，我之前的草稿中有一个计算错误。$-110000 - 50000/3 = (-330000 - 50000)/3 = -380000/3$。\n更正后：$\\boldsymbol{r}^{(1)} = \\begin{pmatrix} -380000/3 \\\\ 230000/3 \\end{pmatrix}\\,\\mathrm{N}$。\n\n**单元2 (节点1, 2):**\n$x_i=1$, $x_j=2$, $L_e=1$。节点位移 $u_1=0.1, u_2=0.25$。\n- 应变: $\\varepsilon^{(2)} = (u_2 - u_1)/L_e = (0.25 - 0.1)/1 = 0.15$。\n- 应力: $\\sigma^{(2)} = E\\varepsilon^{(2)} + \\alpha(\\varepsilon^{(2)})^3 = 10^6(0.15) + 10^7(0.15)^3 = 150000 + 10^7(0.003375) = 150000 + 33750 = 183750\\,\\mathrm{Pa}$。\n- 内力向量: $\\boldsymbol{f}_{int}^{(2)} = A\\sigma^{(2)}\\begin{pmatrix} -1 \\\\ 1 \\end{pmatrix} = 1 \\cdot 183750 \\begin{pmatrix} -1 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} -183750 \\\\ 183750 \\end{pmatrix}\\,\\mathrm{N}$。\n- 外力向量: $\\boldsymbol{f}_{ext}^{(2)} = \\frac{10^5 \\cdot 1}{6}\\begin{pmatrix} 2(1)+2 \\\\ 1+2(2) \\end{pmatrix} = \\frac{10^5}{6}\\begin{pmatrix} 4 \\\\ 5 \\end{pmatrix} = \\begin{pmatrix} 200000/3 \\\\ 250000/3 \\end{pmatrix}\\,\\mathrm{N}$。\n- 残差向量: $\\boldsymbol{r}^{(2)} = \\boldsymbol{f}_{int}^{(2)} - \\boldsymbol{f}_{ext}^{(2)} = \\begin{pmatrix} -183750 - 200000/3 \\\\ 183750 - 250000/3 \\end{pmatrix} = \\begin{pmatrix} (-551250-200000)/3 \\\\ (551250-250000)/3 \\end{pmatrix} = \\begin{pmatrix} -751250/3 \\\\ 301250/3 \\end{pmatrix}\\,\\mathrm{N}$。\n\n**全局残差向量 $\\boldsymbol{r}$ 的组集**\n全局残差向量 $\\boldsymbol{r} = \\begin{pmatrix} r_0  r_1  r_2 \\end{pmatrix}^T$ 由单元贡献组集而成：\n$$\nr_0 = r^{(1)}_0 = -\\frac{380000}{3}\n$$\n$$\nr_1 = r^{(1)}_1 + r^{(2)}_0 = \\frac{230000}{3} - \\frac{751250}{3} = \\frac{230000 - 751250}{3} = \\frac{-521250}{3} = -173750\n$$\n$$\nr_2 = r^{(2)}_1 = \\frac{301250}{3}\n$$\n最终的全局残差向量，其分量以牛顿为单位表示，为：\n$$\n\\boldsymbol{r} = \\begin{pmatrix} -380000/3 \\\\ -173750 \\\\ 301250/3 \\end{pmatrix}\n$$",
            "answer": "$$\n\\boxed{\\begin{pmatrix} -\\frac{380000}{3}  -173750  \\frac{301250}{3} \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "牛顿法的精髓在于利用解附近的局部“斜率”（即切线刚度）来预测最优的修正方向，从而实现快速收敛。对于复杂的材料模型，推导与变分结构精确一致的“一致切线刚度”是一项至关重要且具有挑战性的任务。本练习将带您深入研究大变形框架下的张量微积分，为一个可压缩的超弹性材料模型推导其物质和空间切线模量，这对于保证牛顿法的二次收敛率至关重要。",
            "id": "3583525",
            "problem": "考虑一个三维超弹性体，其占据一个参考构型，物质坐标由变形梯度$\\mathbf{F}$、右 Cauchy-Green 张量$\\mathbf{C} = \\mathbf{F}^{\\mathsf{T}}\\mathbf{F}$和雅可比行列式$J = \\det \\mathbf{F}$描述。设单位参考体积的应变能密度为可压缩 neo-Hookean 模型\n$$\n\\Psi(\\mathbf{F}) = \\frac{\\mu}{2}\\left(\\mathbf{F}:\\mathbf{F} - 3\\right) - \\mu \\ln J + \\frac{\\lambda}{2}\\left(\\ln J\\right)^{2},\n$$\n其中 $\\mu$ 和 $\\lambda$ 是 Lamé 参数。平衡问题通过牛顿-拉夫逊方法求解，该方法应用于全拉格朗日列式（使用第二 Piola-Kirchhoff 应力 $\\mathbf{S}$ 和 Green-Lagrange 应变 $\\mathbf{E} = \\frac{1}{2}(\\mathbf{C}-\\mathbf{I})$）或更新拉格朗日列式（使用 Kirchhoff 应力 $\\boldsymbol{\\tau} = J \\boldsymbol{\\sigma}$ 和空间度量）中的平衡弱形式。有限元法（FEM）残差被一致线性化以获得算法切线。\n\n从虚功原理、超弹性应力度量的定义以及内力算子的一致线性化出发：\n\n- 从 $\\Psi(\\mathbf{F})$ 推导第二 Piola-Kirchhoff 应力 $\\mathbf{S}$。\n- 推导全拉格朗日一致材料切线 $\\mathbb{C}_{\\mathrm{TL}} = \\frac{\\partial \\mathbf{S}}{\\partial \\mathbf{E}}$，并使用由 $\\mathbf{C}^{-1}$ 和 $J$ 构成的四阶张量积紧凑地表示它。使用约定\n$$\n(\\mathbf{A} \\otimes \\mathbf{B})_{IJKL} = A_{IJ} B_{KL}, \\quad (\\mathbf{A} \\odot \\mathbf{B})_{IJKL} = \\frac{1}{2}\\left(A_{IK}B_{JL} + A_{IL}B_{JK}\\right),\n$$\n其中大写指标指代物质标架。\n- 将 $\\mathbb{C}_{\\mathrm{TL}}$ 前推，以在当前构型中获得更新拉格朗日空间一致切线 $\\mathfrak{c}_{\\mathrm{UL}}$，使用公式\n$$\n\\mathfrak{c}_{\\mathrm{UL}\\,ijkl} = \\frac{1}{J} F_{iI} F_{jJ} F_{kK} F_{lL}\\, \\mathbb{C}_{\\mathrm{TL}\\,IJKL}.\n$$\n使用单位张量 $\\mathbf{I}$、分量为 $\\mathbb{I}_{ijkl} = \\frac{1}{2}\\left(\\delta_{ik}\\delta_{jl} + \\delta_{il}\\delta_{jk}\\right)$ 的对称四阶单位张量 $\\mathbb{I}$ 和 $J$ 来表示 $\\mathfrak{c}_{\\mathrm{UL}}$。\n- 对于 $\\mathbb{C}_{\\mathrm{TL}}$ 和 $\\mathfrak{c}_{\\mathrm{UL}}$，基于超弹性势 $\\Psi$，识别并论证其在每个指标对内的次对称性和在指标对交换下的主对称性。\n\n以闭式解析四阶张量的形式，提供最终的表达式对 $\\left[\\mathbb{C}_{\\mathrm{TL}},\\, \\mathfrak{c}_{\\mathrm{UL}}\\right]$。无需进行数值计算。使用 LaTeX 的 pmatrix 环境将最终答案表示为行矩阵。无需单位，也无需四舍五入。",
            "solution": "该问题是有效的，因为它在科学上基于连续介质力学，是适定的、客观的且自洽的。它展示了计算固体力学中一个标准的、非平凡的推导过程。\n\n求解过程分为四个阶段：\n1.  推导第二 Piola-Kirchhoff 应力张量 $\\mathbf{S}$。\n2.  推导全拉格朗日（物质）一致切线模量 $\\mathbb{C}_{\\mathrm{TL}}$。\n3.  前推物质切线以推导更新拉格朗日（空间）一致切线模量 $\\mathfrak{c}_{\\mathrm{UL}}$。\n4.  分析两个切线算子的对称性。\n\n**1. 第二 Piola-Kirchhoff 应力 S 的推导**\n\n虚功原理指出，对于处于平衡状态的物体，内虚功等于外虚功。对于超弹性材料，内功的变分由总应变能的变分导出。单位参考体积的内虚功由 $\\delta W_{\\mathrm{int}} = \\mathbf{P}:\\delta\\mathbf{F}^{\\mathsf{T}}$ 给出，其中 $\\mathbf{P}$ 是第一 Piola-Kirchhoff 应力张量。使用关系式 $\\mathbf{P} = \\mathbf{F}\\mathbf{S}$，其中 $\\mathbf{S}$ 是对称的第二 Piola-Kirchhoff 应力张量，我们得到：\n$$\n\\delta W_{\\mathrm{int}} = (\\mathbf{F}\\mathbf{S}):\\delta\\mathbf{F}^{\\mathsf{T}} = \\mathrm{tr}(\\mathbf{F}\\mathbf{S}\\,\\delta\\mathbf{F}) = \\mathrm{tr}(\\mathbf{S}\\,\\delta\\mathbf{F}\\mathbf{F})\n$$\n这不是最直接的路径。相反，我们可以将 $\\delta W_{\\mathrm{int}}$ 与 Green-Lagrange 应变张量 $\\mathbf{E} = \\frac{1}{2}(\\mathbf{C}-\\mathbf{I})$ 相关联，其中 $\\mathbf{C} = \\mathbf{F}^{\\mathsf{T}}\\mathbf{F}$。$\\mathbf{E}$ 的变分是 $\\delta\\mathbf{E} = \\frac{1}{2}\\delta\\mathbf{C} = \\frac{1}{2}(\\delta\\mathbf{F}^{\\mathsf{T}}\\mathbf{F} + \\mathbf{F}^{\\mathsf{T}}\\delta\\mathbf{F})$。内虚功可以表示为 $\\delta W_{\\mathrm{int}} = \\mathbf{S}:\\delta\\mathbf{E}$。\n对于具有应变能密度 $\\Psi$ 的超弹性材料，内能的变分就是 $\\delta\\Psi$。令两种虚功密度的表达式相等，可得：\n$$\n\\delta\\Psi = \\mathbf{S}:\\delta\\mathbf{E} = \\mathbf{S}:\\left(\\frac{1}{2}\\delta\\mathbf{C}\\right) = \\frac{1}{2}\\mathbf{S}:\\delta\\mathbf{C}\n$$\n根据微积分，作为 $\\mathbf{C}$ 的函数的 $\\Psi$ 的变分为 $\\delta\\Psi = \\frac{\\partial\\Psi}{\\partial\\mathbf{C}}:\\delta\\mathbf{C}$。比较这些表达式，可以得到第二 Piola-Kirchhoff 应力的基本关系：\n$$\n\\mathbf{S} = 2\\frac{\\partial\\Psi}{\\partial\\mathbf{C}}\n$$\n为了应用这个关系，我们首先将给定的应变能密度 $\\Psi(\\mathbf{F})$ 用 $\\mathbf{C}$ 表示。我们使用关系式 $\\mathbf{F}:\\mathbf{F} = \\mathrm{tr}(\\mathbf{F}^{\\mathsf{T}}\\mathbf{F}) = \\mathrm{tr}(\\mathbf{C})$ 和 $J = \\det(\\mathbf{F}) = \\sqrt{\\det(\\mathbf{C})}$。\n应变能函数变为：\n$$\n\\Psi(\\mathbf{C}) = \\frac{\\mu}{2}(\\mathrm{tr}(\\mathbf{C}) - 3) - \\mu \\ln(\\sqrt{\\det\\mathbf{C}}) + \\frac{\\lambda}{2} (\\ln(\\sqrt{\\det\\mathbf{C}}))^{2}\n$$\n简化对数项：\n$$\n\\Psi(\\mathbf{C}) = \\frac{\\mu}{2}(\\mathrm{tr}(\\mathbf{C}) - 3) - \\frac{\\mu}{2}\\ln(\\det\\mathbf{C}) + \\frac{\\lambda}{8}(\\ln(\\det\\mathbf{C}))^{2}\n$$\n现在我们计算 $\\Psi$ 对 $\\mathbf{C}$ 的导数。我们需要标准的张量导数：$\\frac{\\partial(\\mathrm{tr}\\mathbf{C})}{\\partial\\mathbf{C}} = \\mathbf{I}$ 和 $\\frac{\\partial(\\det\\mathbf{C})}{\\partial\\mathbf{C}} = (\\det\\mathbf{C})\\mathbf{C}^{-1} = J^{2}\\mathbf{C}^{-1}$。\n应用链式法则：\n$$\n\\frac{\\partial\\Psi}{\\partial\\mathbf{C}} = \\frac{\\mu}{2}\\mathbf{I} - \\frac{\\mu}{2}\\frac{1}{\\det\\mathbf{C}}\\frac{\\partial(\\det\\mathbf{C})}{\\partial\\mathbf{C}} + \\frac{\\lambda}{8} \\cdot 2\\ln(\\det\\mathbf{C}) \\cdot \\frac{1}{\\det\\mathbf{C}}\\frac{\\partial(\\det\\mathbf{C})}{\\partial\\mathbf{C}}\n$$\n$$\n\\frac{\\partial\\Psi}{\\partial\\mathbf{C}} = \\frac{\\mu}{2}\\mathbf{I} - \\frac{\\mu}{2}\\frac{1}{J^{2}}(J^{2}\\mathbf{C}^{-1}) + \\frac{\\lambda}{4} (2\\ln J) \\frac{1}{J^{2}}(J^{2}\\mathbf{C}^{-1})\n$$\n$$\n\\frac{\\partial\\Psi}{\\partial\\mathbf{C}} = \\frac{\\mu}{2}\\mathbf{I} - \\frac{\\mu}{2}\\mathbf{C}^{-1} + \\frac{\\lambda}{2}(\\ln J)\\mathbf{C}^{-1}\n$$\n最终，第二 Piola-Kirchhoff 应力张量为：\n$$\n\\mathbf{S} = 2\\frac{\\partial\\Psi}{\\partial\\mathbf{C}} = \\mu\\mathbf{I} + (\\lambda\\ln J - \\mu)\\mathbf{C}^{-1}\n$$\n\n**2. 全拉格朗日切线模量 $\\mathbb{C}_{\\mathrm{TL}}$ 的推导**\n\n全拉格朗日一致切线模量将 $\\mathbf{S}$ 的变化率与 $\\mathbf{E}$ 的变化率联系起来：$\\dot{\\mathbf{S}} = \\mathbb{C}_{\\mathrm{TL}}:\\dot{\\mathbf{E}}$。这意味着 $\\mathbb{C}_{\\mathrm{TL}} = \\frac{\\partial\\mathbf{S}}{\\partial\\mathbf{E}}$。由于 $\\mathbf{E} = \\frac{1}{2}(\\mathbf{C}-\\mathbf{I})$，所以 $\\delta \\mathbf{E} = \\frac{1}{2}\\delta \\mathbf{C}$。切线模量可以计算为：\n$$\n\\mathbb{C}_{\\mathrm{TL}} = 2\\frac{\\partial\\mathbf{S}}{\\partial\\mathbf{C}}\n$$\n我们将 $\\mathbf{S}$ 的表达式对 $\\mathbf{C}$ 求导：\n$$\n\\frac{\\partial\\mathbf{S}}{\\partial\\mathbf{C}} = \\frac{\\partial}{\\partial\\mathbf{C}} \\left[ \\mu\\mathbf{I} + (\\lambda\\ln J - \\mu)\\mathbf{C}^{-1} \\right]\n$$\n项 $\\mu\\mathbf{I}$ 相对于 $\\mathbf{C}$ 是常数，因此其导数为零。对于第二项，我们使用张量函数的乘法法则 $(f\\mathbf{G})'$，即 $\\frac{\\partial f}{\\partial \\mathbf{C}} \\otimes \\mathbf{G} + f \\frac{\\partial \\mathbf{G}}{\\partial \\mathbf{C}}$。这里，$f(\\mathbf{C}) = \\lambda\\ln J - \\mu = \\frac{\\lambda}{2}\\ln(\\det\\mathbf{C}) - \\mu$ 且 $\\mathbf{G}(\\mathbf{C}) = \\mathbf{C}^{-1}$。\n首先，我们求标量函数 $f$ 的导数：\n$$\n\\frac{\\partial f}{\\partial \\mathbf{C}} = \\frac{\\lambda}{2} \\frac{1}{\\det\\mathbf{C}} \\frac{\\partial(\\det\\mathbf{C})}{\\partial\\mathbf{C}} = \\frac{\\lambda}{2} \\frac{1}{J^{2}}(J^{2}\\mathbf{C}^{-1}) = \\frac{\\lambda}{2}\\mathbf{C}^{-1}\n$$\n接下来，我们求张量函数 $\\mathbf{G}$ 的导数，这是一个关于张量逆相对于张量本身的导数的标准结果（假设对称性）：\n$$\n\\frac{\\partial\\mathbf{C}^{-1}}{\\partial\\mathbf{C}} = -(\\mathbf{C}^{-1} \\odot \\mathbf{C}^{-1})\n$$\n其中四阶张量 $(\\mathbf{A} \\odot \\mathbf{B})_{IJKL} = \\frac{1}{2}(A_{IK}B_{JL} + A_{IL}B_{JK})$。\n使用乘法法则组合这些结果：\n$$\n\\frac{\\partial\\mathbf{S}}{\\partial\\mathbf{C}} = \\left(\\frac{\\lambda}{2}\\mathbf{C}^{-1}\\right) \\otimes \\mathbf{C}^{-1} + (\\lambda\\ln J - \\mu) \\left( -(\\mathbf{C}^{-1} \\odot \\mathbf{C}^{-1}) \\right)\n$$\n最后，乘以 2 得到材料切线模量：\n$$\n\\mathbb{C}_{\\mathrm{TL}} = \\lambda (\\mathbf{C}^{-1} \\otimes \\mathbf{C}^{-1}) - 2(\\lambda\\ln J - \\mu)(\\mathbf{C}^{-1} \\odot \\mathbf{C}^{-1})\n$$\n$$\n\\mathbb{C}_{\\mathrm{TL}} = \\lambda (\\mathbf{C}^{-1} \\otimes \\mathbf{C}^{-1}) + 2(\\mu - \\lambda\\ln J)(\\mathbf{C}^{-1} \\odot \\mathbf{C}^{-1})\n$$\n\n**3. 更新拉格朗日切线模量 $\\mathfrak{c}_{\\mathrm{UL}}$ 的推导**\n\n更新拉格朗日（或空间）切线模量 $\\mathfrak{c}_{\\mathrm{UL}}$ 是通过将物质切线 $\\mathbb{C}_{\\mathrm{TL}}$ 前推到当前（空间）构型得到的。前推操作由下式给出：\n$$\n\\mathfrak{c}_{\\mathrm{UL}\\,ijkl} = \\frac{1}{J} F_{iI} F_{jJ} F_{kK} F_{lL}\\, \\mathbb{C}_{\\mathrm{TL}\\,IJKL}\n$$\n我们将此操作应用于 $\\mathbb{C}_{\\mathrm{TL}}$ 的每一项。\n\n第一项 $\\lambda (\\mathbf{C}^{-1} \\otimes \\mathbf{C}^{-1})$ 的前推：\n其分量为 $\\mathbb{C}^{(1)}_{\\mathrm{TL}\\,IJKL} = \\lambda C^{-1}_{IJ} C^{-1}_{KL}$。\n$$\n\\mathfrak{c}^{(1)}_{\\mathrm{UL}\\,ijkl} = \\frac{\\lambda}{J} F_{iI} F_{jJ} F_{kK} F_{lL} (C^{-1}_{IJ} C^{-1}_{KL}) = \\frac{\\lambda}{J} (F_{iI} C^{-1}_{IJ} F_{jJ}) (F_{kK} C^{-1}_{KL} F_{lL})\n$$\n使用恒等式 $(\\mathbf{F}\\mathbf{C}^{-1}\\mathbf{F}^{\\mathsf{T}})_{ab} = F_{aA}(\\mathbf{F}^{-1}\\mathbf{F}^{-\\mathsf{T}})_{AB}F_{bB} = F_{aA}F^{-1}_{A C}F^{-\\mathsf{T}}_{C B}F_{bB} = \\delta_{aC} \\delta_{Cb} = \\delta_{ab}$，这意味着 $\\mathbf{F}\\mathbf{C}^{-1}\\mathbf{F}^{\\mathsf{T}} = \\mathbf{I}$。\n表达式变为：\n$$\n\\mathfrak{c}^{(1)}_{\\mathrm{UL}\\,ijkl} = \\frac{\\lambda}{J} \\delta_{ij}\\delta_{kl}\n$$\n在张量表示法中，这是 $\\frac{\\lambda}{J}(\\mathbf{I} \\otimes \\mathbf{I})$。\n\n第二项 $2(\\mu - \\lambda\\ln J)(\\mathbf{C}^{-1} \\odot \\mathbf{C}^{-1})$ 的前推：\n其分量为 $\\mathbb{C}^{(2)}_{\\mathrm{TL}\\,IJKL} = 2(\\mu - \\lambda\\ln J) \\frac{1}{2}(C^{-1}_{IK}C^{-1}_{JL} + C^{-1}_{IL}C^{-1}_{JK})$。\n$$\n\\mathfrak{c}^{(2)}_{\\mathrm{UL}\\,ijkl} = \\frac{(\\mu - \\lambda\\ln J)}{J} F_{iI} F_{jJ} F_{kK} F_{lL} (C^{-1}_{IK}C^{-1}_{JL} + C^{-1}_{IL}C^{-1}_{JK})\n$$\n$$\n\\mathfrak{c}^{(2)}_{\\mathrm{UL}\\,ijkl} = \\frac{(\\mu - \\lambda\\ln J)}{J} [(F_{iI}C^{-1}_{IK}F_{kK})(F_{jJ}C^{-1}_{JL}F_{lL}) + (F_{iI}C^{-1}_{IL}F_{lL})(F_{jJ}C^{-1}_{JK}F_{kK})]\n$$\n使用相同的恒等式 $\\mathbf{F}\\mathbf{C}^{-1}\\mathbf{F}^{\\mathsf{T}} = \\mathbf{I}$，这可以简化为：\n$$\n\\mathfrak{c}^{(2)}_{\\mathrm{UL}\\,ijkl} = \\frac{(\\mu - \\lambda\\ln J)}{J} [\\delta_{ik}\\delta_{jl} + \\delta_{il}\\delta_{jk}]\n$$\n方括号中的项是 $2\\mathbb{I}_{ijkl}$，其中 $\\mathbb{I}_{ijkl} = \\frac{1}{2}(\\delta_{ik}\\delta_{jl} + \\delta_{il}\\delta_{jk})$ 是对称的四阶单位张量。\n因此，第二项变为 $\\frac{2(\\mu - \\lambda\\ln J)}{J}\\mathbb{I}$。\n\n组合两个前推项，得到空间切线模量：\n$$\n\\mathfrak{c}_{\\mathrm{UL}} = \\frac{\\lambda}{J}(\\mathbf{I} \\otimes \\mathbf{I}) + \\frac{2(\\mu - \\lambda\\ln J)}{J}\\mathbb{I}\n$$\n\n**4. 对称性分析**\n\n超弹性势 $\\Psi$ 的存在确保了最终的切线算子具有某些对称性。\n\n-   **$\\mathbb{C}_{\\mathrm{TL}}$ 的对称性**：物质切线定义为 $\\mathbb{C}_{\\mathrm{TL}} = 4\\frac{\\partial^2\\Psi}{\\partial\\mathbf{C}\\partial\\mathbf{C}}$。\n    -   **次对称性**：$\\mathbb{C}_{\\mathrm{TL}\\,IJKL} = \\mathbb{C}_{\\mathrm{TL}\\,JIKL}$ 和 $\\mathbb{C}_{\\mathrm{TL}\\,IJKL} = \\mathbb{C}_{\\mathrm{TL}\\,IJLK}$。这些对称性成立，因为微分是相对于对称张量 $\\mathbf{C}$（或 $\\mathbf{E}$）进行的，并且从中导出的应力张量 $\\mathbf{S}$ 也是对称的。这种结构在最终表达式中是显而易见的，因为 $\\mathbf{C}^{-1}$ 是对称的，并且张量积 $\\otimes$ 和 $\\odot$ 的构造保留了这些对称性。\n    -   **主对称性**：$\\mathbb{C}_{\\mathrm{TL}\\,IJKL} = \\mathbb{C}_{\\mathrm{TL}\\,KLIJ}$。这是 Schwarz 定理关于对于足够光滑的势 $\\Psi$ 的混合偏导数相等的直接结果。相对于 $C_{IJ}$ 和 $C_{KL}$ 的微分顺序可以互换，从而保证了这种对称性。检查推导出的 $\\mathbb{C}_{\\mathrm{TL}}$ 公式可以证实这一性质。\n\n-   **$\\mathfrak{c}_{\\mathrm{UL}}$ 的对称性**：空间切线通过前推操作继承了物质切线的对称性。\n    -   映射 $\\mathfrak{c}_{\\mathrm{UL}\\,ijkl} = \\frac{1}{J} F_{iI} F_{jJ} F_{kK} F_{lL}\\, \\mathbb{C}_{\\mathrm{TL}\\,IJKL}$ 是一种线性变换，它保留了 $\\mathbb{C}_{\\mathrm{TL}}$ 的指标对称性。\n    -   **次对称性**：$\\mathfrak{c}_{\\mathrm{UL}\\,ijkl} = \\mathfrak{c}_{\\mathrm{UL}\\,jikl}$ 和 $\\mathfrak{c}_{\\mathrm{UL}\\,ijkl} = \\mathfrak{c}_{\\mathrm{UL}\\,ijlk}$。这些对称性从最终表达式中可以明显看出，该表达式由 Kronecker 符号 $\\delta$ 构成。例如，在 $\\delta_{ij}\\delta_{kl}$ 和 $(\\delta_{ik}\\delta_{jl} + \\delta_{il}\\delta_{jk})$ 中交换 $i$ 和 $j$ 不会改变表达式。\n    -   **主对称性**：$\\mathfrak{c}_{\\mathrm{UL}\\,ijkl} = \\mathfrak{c}_{\\mathrm{UL}\\,klij}$。这也成立，可以通过交换指标对 $(i,j)$ 和 $(k,l)$ 从最终表达式中直接验证。\n\n两个切线算子的对称性是源于其超弹性起源的一个基本性质，这对于有限元实现中刚度矩阵的效率和对称性至关重要。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} \\lambda (\\mathbf{C}^{-1} \\otimes \\mathbf{C}^{-1}) + 2(\\mu - \\lambda \\ln J)(\\mathbf{C}^{-1} \\odot \\mathbf{C}^{-1})  \\frac{\\lambda}{J}(\\mathbf{I} \\otimes \\mathbf{I}) + \\frac{2(\\mu - \\lambda \\ln J)}{J}\\mathbb{I} \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "在掌握了残差和切线刚度的概念之后，是时候构建驱动整个求解过程的迭代引擎了。本练习要求您编写代码，将理论付诸实践，并对比两种最常见的牛顿法变体：全牛顿法和修正牛顿法。通过比较不同非线性程度下两种方法的迭代次数和收敛速率，您将对它们在计算成本和收敛效率之间的权衡获得深刻的直观认识。",
            "id": "3583538",
            "problem": "实现一个完整、可运行的程序，用于比较求解源自一维有限元离散化的非线性平衡问题的两种牛顿-拉夫逊 (Newton-Raphson) 策略。物理模型为一根单杆，其一端固定，另一端承受单调递增的轴向荷载。该杆具有均匀的横截面积，并被离散化为单个线性两节点单元，因此在施加的末端位移下，轴向应变是均匀的。内部轴向应力遵循一个非线性本构关系。目标是构建平衡残差，推导牛顿迭代所需的切线，然后实现并比较全牛顿法和修正牛顿法（在多次迭代中冻结切线刚度）。你必须计算迭代次数和观测到的收敛速率，并将它们整合到单行输出中。\n\n基础理论：\n- 有限元法 (FEM) 中的全局平衡：离散平衡条件为 $r(u) = 0$，其中 $r(u)$ 是残差力向量（此处为标量），$u$ 是离散节点位移，$r(u) = f_{\\text{ext}} - f_{\\text{int}}(u)$，$f_{\\text{ext}}$ 是外部节点力向量（此处为标量）。\n- 运动学：对于一个长度为 $L$、具有线性形函数和自由端位移 $u$ 的均匀杆单元，其轴向应变为 $\\varepsilon = u / L$。\n- 非线性本构关系：轴向应力由 $\\sigma(\\varepsilon) = E \\varepsilon + \\beta \\varepsilon^3$ 给出，其中 $E > 0$ 是杨氏模量，$\\beta \\ge 0$ 控制三次非线性；假设使用无量纲单位，因此在本问题陈述中所有量均为无量纲。\n- 内力：对于横截面积为 $A$、应变恒定的均匀杆，自由节点处的内力简化为 $f_{\\text{int}}(u) = A \\sigma(\\varepsilon)$。\n\n对于给定的端部荷载 $P$ 和节点位移 $u$，将平衡残差定义为 $r(u) = P - f_{\\text{int}}(u) = P - A \\left( E \\frac{u}{L} + \\beta \\left(\\frac{u}{L}\\right)^3 \\right)$。牛顿-拉夫逊法 (NR) 所需的一致切线为 $K_{\\text{T}}(u) = \\frac{dr}{du}$。在第 $k$ 次迭代时，全牛顿法使用当前的 $K_{\\text{T}}(u_k)$，而修正牛顿法则在每个荷载增量开始时冻结 $K_{\\text{T}}$，并在该增量内的所有迭代中重复使用它。\n\n编程任务：\n1. 从平衡残差定义 $r(u) = P - f_{\\text{int}}(u)$ 和本构关系 $\\sigma(\\varepsilon) = E \\varepsilon + \\beta \\varepsilon^3$ 出发，用 $u$、$E$、$\\beta$、$A$、$L$ 和 $P$ 显式地推导出 $r(u)$ 和 $K_{\\text{T}}(u)$。\n2. 在一系列荷载增量上实现两个非线性求解器：\n   - 全牛顿法：在荷载增量内的每次迭代中更新 $K_{\\text{T}}(u_k)$。\n   - 修正牛顿法：在每个荷载增量开始时冻结 $K_{\\text{T}}$（使用在增量首次迭代时，即上一个增量收敛位移处计算的切线）。\n   每个荷载增量将 $P$ 增加 $\\Delta P = P_{\\text{total}}/N_{\\text{inc}}$，并寻求一个收敛的 $u$ 使得 $|r(u)| \\le \\text{tol}$。\n3. 使用前一个增量的收敛位移作为下一个增量的初始猜测值。对于每个增量，记录直到收敛为止的残差范数序列 $\\|r(u_k)\\|$。\n4. 对于修正牛顿法，计算在所有发生至少两次迭代的迭代和增量上的平均观测线性收敛因子：$\\lambda_k = \\frac{\\|r_{k+1}\\|}{\\|r_k\\|}$，并报告所有这些 $\\lambda_k$ 的算术平均值。对于全牛顿法，类似地计算平均观测二次收敛因子：$q_k = \\frac{\\|r_{k+1}\\|}{\\|r_k\\|^2}$，并报告所有发生至少两次迭代的 $q_k$ 的算术平均值。\n5. 对于每个测试用例，计算全牛顿法和修正牛顿法在所有增量上累积的总迭代次数。收敛容差适用于残差范数 $\\|r\\|$，在本标量情况下为 $|r|$。\n\n测试套件：\n所有测试用例均使用无量纲参数 $A = 1$，$L = 1$，$E = 1$。每个增量的最大迭代次数为 $\\text{max\\_iter} = 50$，残差容差为 $\\text{tol} = 10^{-10}$。测试套件包含四个用例：\n- 用例 1：$\\beta = 0.1$, $P_{\\text{total}} = 0.5$, $N_{\\text{inc}} = 5$。\n- 用例 2：$\\beta = 1.0$, $P_{\\text{total}} = 0.8$, $N_{\\text{inc}} = 8$。\n- 用例 3：$\\beta = 5.0$, $P_{\\text{total}} = 0.8$, $N_{\\text{inc}} = 8$。\n- 用例 4（近线性边界）：$\\beta = 0.0$, $P_{\\text{total}} = 0.5$, $N_{\\text{inc}} = 5$。\n\n输出规范：\n- 对于每个测试用例，生成一个列表 $[`N_full`, `N_mod`, `R_full`, `R_mod`]$，其中 `$N_full`$ 是全牛顿法的总迭代次数，`$N_mod`$ 是修正牛顿法的总迭代次数，`$R_full`$ 是全牛顿法的平均二次因子，`$R_mod`$ 是修正牛顿法的平均线性收敛因子。所有四个值都必须是数值；如果在所有增量中（为定义因子）的迭代次数少于两次，则为相应的速率报告 $0.0$。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例对应一个子列表，顺序为：用例 1、用例 2、用例 3、用例 4。例如，确切格式必须类似于 $[[`N_full`, `N_mod`, `R_full`, `R_mod`],\\ldots]$。由于所有输出都是计数或比率，因此输出中不需要物理单位。\n\n科学真实性约束：\n- 问题是无量纲化的，因此所有参数都是无量纲的，从而确保了单位一致性。\n- 本构非线性 $\\beta \\ge 0$ 保证了正切线模量 $E_{\\text{t}} = E + 3 \\beta \\varepsilon^2$，从而避免了椭圆性损失，并确保了所选荷载下的稳健收敛。\n- 使用无随机化的确定性算法，固定容差 $\\text{tol} = 10^{-10}$ 和最大迭代上限 $\\text{max\\_iter} = 50$，以确保可复现性。\n\n您的实现必须是一个完整、可运行的程序。除了所需的单行输出外，不要读取任何输入或写入任何其他输出。实现语言必须是 Python，并遵循稍后指定的约束。结果必须由程序使用上述从第一性原理推导出的算法进行数值计算。",
            "solution": "我们从有限元法 (FEM) 中的离散平衡方程开始：$r(u) = f_{\\text{ext}} - f_{\\text{int}}(u)$。对于长度为 $L$、横截面积为 $A$ 且应变均匀的一维杆，轴向应变为 $\\varepsilon = u/L$。本构关系为 $\\sigma(\\varepsilon) = E \\varepsilon + \\beta \\varepsilon^3$，其中 $E > 0$ 且 $\\beta \\ge 0$。自由端的内部节点轴向力等于横截面积乘以轴向应力，即 $f_{\\text{int}}(u) = A \\sigma(\\varepsilon) = A \\left( E \\frac{u}{L} + \\beta \\left(\\frac{u}{L}\\right)^3 \\right)$。外部节点力为 $f_{\\text{ext}} = P$。因此，标量残差为\n$$\nr(u) = P - A\\left(E \\frac{u}{L} + \\beta \\left(\\frac{u}{L}\\right)^3 \\right).\n$$\n牛顿-拉夫逊法 (NR) 所需的一致切线是 $r(u)$ 对 $u$ 的导数：\n$$\nK_{\\text{T}}(u) = \\frac{dr}{du} = -A\\left(\\frac{E}{L} + 3\\beta \\frac{u^2}{L^3}\\right).\n$$\n负号不成问题，因为 NR 更新求解 $K_{\\text{T}}(u_k) \\Delta u_k = -r(u_k)$ 并更新 $u_{k+1} = u_k + \\Delta u_k$。由于当 $E > 0$、$\\beta \\ge 0$、$A>0$、$L>0$ 时，$K_{\\text{T}}(u)$ 对所有 $u$ 都是严格为负的，因此迭代是良定的；在单调加载下，当 $r(u_k) > 0$ 时，它会导致正的 $\\Delta u_k$。\n\n我们考虑两种算法：\n- 全牛顿法：在给定荷载增量的第 $k$ 次迭代中，根据当前迭代值组装 $K_{\\text{T}}(u_k)$。求解 $K_{\\text{T}}(u_k)\\Delta u_k = -r(u_k)$ 并更新 $u_{k+1} = u_{k} + \\Delta u_k$。重复此过程，直到 $|r(u_{k+1})| \\le \\text{tol}$ 或 $k$ 达到 $\\text{max\\_iter}$。\n- 修正牛顿法：在每个荷载增量开始时，通过在前一个增量的收敛位移 $u^{(i-1)}$ 处（该值作为初始猜测值 $u_0^{(i)}$）计算来冻结 $K_{\\text{T}}$。然后在该增量内的所有牛顿更新中使用这个固定的 $K_{\\text{T}}$进行迭代，直到收敛或达到 $\\text{max\\_iter}$。\n\n加载与初始化：\n我们采用一个包含 $N_{\\text{inc}}$ 个均匀步长的荷载增量方案。总荷载为 $P_{\\text{total}}$，每个增量将荷载增加 $\\Delta P = P_{\\text{total}} / N_{\\text{inc}}$。在增量 $i$（$i = 1, \\ldots, N_{\\text{inc}}$）时，目标荷载为 $P_i = i \\Delta P$。增量 $i$ 中 $u$ 的初始猜测值是增量 $i-1$ 的收敛位移，第一个增量的初始位移为 $u^{(0)} = 0$。对于每个增量和每种方法，我们记录每次 NR 迭代 $k$ 时的残差范数 $|r(u_k)|$。\n\n收敛速率度量：\n- 对于在增量内具有冻结切线的修正牛顿法，解附近的预期局部行为是线性的：$|r_{k+1}| \\approx \\lambda |r_k|$，其中在收敛域内 $0  \\lambda  1$。我们在每一步估计线性因子为 $\\lambda_k = \\frac{|r_{k+1}|}{|r_k|}$，并计算在所有增量和所有至少存在两个残差的迭代索引 $k$（即，如果在该增量中记录了 $n$ 个残差，则 $k$ 的范围从 $0$ 到 $n-2$）上的算术平均值。\n- 对于具有一致切线的全牛顿法，解附近的局部行为是二次的：对于小的 $|r_k|$，$|r_{k+1}| \\approx q |r_k|^2$。我们在每一步估计二次因子为 $q_k = \\frac{|r_{k+1}|}{|r_k|^2}$，并计算在所有增量和符合条件的迭代索引上的算术平均值。在少于两次迭代就收敛的增量中，无法估计该因子；这些增量将从平均值计算中排除。如果在某个测试用例的所有增量中都没有符合条件的步骤，我们为相应的平均速率返回 $0.0$。\n\n测试用例与预期：\n我们使用无量纲参数 $A = 1$，$L = 1$，$E = 1$，这意味着对于此选择，$f_{\\text{int}}(u) = E u + \\beta u^3$ 且 $K_{\\text{T}}(u) = -\\left(E + 3\\beta u^2\\right)$。我们设置 $\\text{tol} = 10^{-10}$ 和 $\\text{max\\_iter} = 50$。模拟了四个用例：\n- 用例 1：$\\beta = 0.1$, $P_{\\text{total}} = 0.5$, $N_{\\text{inc}} = 5$。预期为中等非线性；全牛顿法应表现出近二次收敛，平均 $q$ 值较小，而修正牛顿法应显示线性收敛，其因子 $\\lambda$ 远离零。\n- 用例 2：$\\beta = 1.0$, $P_{\\text{total}} = 0.8$, $N_{\\text{inc}} = 8$。非线性增强；全牛顿法仍然高效；修正牛顿法可能需要更多迭代，$\\lambda$ 值更大。\n- 用例 3：$\\beta = 5.0$, $P_{\\text{total}} = 0.8$, $N_{\\text{inc}} = 8$。强非线性；切线随 $u$ 显著增长。全牛顿法仍应以近二次行为稳健收敛；修正牛顿法的速率可能较慢，迭代次数较高，因为冻结的切线在远离初始猜测值时代表性较差。\n- 用例 4：$\\beta = 0.0$, $P_{\\text{total}} = 0.5$, $N_{\\text{inc}} = 5$。纯线性；两种方法都简化为求解一个线性方程。从每个增量的任意初始猜测值（前一个收敛值）开始，牛顿法在每个增量中单次迭代即可收敛。平均速率无法有意义地计算，因为每个增量最多只有一次迭代；因此，在这种情况下，两种方法的速率输出都应为 $0.0$。\n\n输出格式：\n对于每个测试用例，返回列表 $[`N_full`, `N_mod`, `R_full`, `R_mod`]$，并将所有四个用例聚合到一个顶级列表中，打印为一行，例如 $[[`N_full`, `N_mod`, `R_full`, `R_mod`], [\\cdots], [\\cdots], [\\cdots]]$。`$N_full`$ 和 `$N_mod`$ 的值为整数，`$R_full`$ 和 `$R_mod`$ 的值为浮点数。因为这些是计数和无量纲比率，输出中不需要物理单位。\n\n算法稳健性：\n我们设置了严格的残差容差 $\\text{tol} = 10^{-10}$，以在速率估计中捕捉渐近行为。正切线模量 $E_{\\text{t}} = E + 3 \\beta \\varepsilon^2$ 确保了指定荷载下的解是唯一的。最大迭代上限 $\\text{max\\_iter} = 50$ 可防止出现病态情况。荷载步进策略维持 $P$ 的单调增加，而初始猜测值的选择则促进了快速收敛。\n\n程序将精确实现这些步骤，并以指定格式打印所需的单行输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef residual(u, P, E, beta, A, L):\n    # r(u) = P - A*(E*u/L + beta*(u/L)^3)\n    return P - A * (E * (u / L) + beta * (u / L) ** 3)\n\ndef tangent(u, E, beta, A, L):\n    # K_T(u) = dr/du = -A*(E/L + 3*beta*u^2/L^3)\n    return -A * (E / L + 3.0 * beta * (u ** 2) / (L ** 3))\n\ndef newton_solve(P_total, N_inc, E, beta, A, L, tol=1e-10, max_iter=50, mode=\"full\"):\n    \"\"\"\n    Solve the nonlinear equilibrium over load increments using either full Newton or modified Newton.\n    Returns:\n        total_iterations: int\n        avg_rate: float (quadratic factor for 'full', linear factor for 'modified')\n    \"\"\"\n    u = 0.0  # initial displacement for first increment\n    deltaP = P_total / N_inc\n    total_iterations = 0\n    rate_values = []  # stores lambda_k for 'modified' or q_k for 'full'\n\n    for i in range(1, N_inc + 1):\n        P_i = i * deltaP\n        # Initial guess is previous increment's converged displacement\n        u_i = u\n        residuals = []\n\n        # Freeze tangent for modified Newton at start of increment\n        if mode == \"modified\":\n            K_freeze = tangent(u_i, E, beta, A, L)\n\n        for k in range(max_iter):\n            r_k = residual(u_i, P_i, E, beta, A, L)\n            residuals.append(abs(r_k))\n            if abs(r_k) = tol:\n                # Converged at iteration k\n                total_iterations += k  # we count completed iterations before reaching tolerance\n                break\n            # Choose tangent according to method\n            if mode == \"full\":\n                K_t = tangent(u_i, E, beta, A, L)\n            else:\n                K_t = K_freeze\n\n            # Guard against zero tangent (should not occur with chosen parameters)\n            if K_t == 0.0:\n                # Fail-safe: break to avoid division by zero\n                total_iterations += k + 1\n                break\n\n            # Newton update: K_t * delta = -r_k  => delta = -r_k / K_t\n            delta = -r_k / K_t\n            u_i = u_i + delta\n\n            # If we reached the last allowed iteration without satisfying tol, count it\n            if k == max_iter - 1:\n                total_iterations += max_iter\n\n        # Post-processing for rate estimates within this increment\n        # We use the recorded residuals sequence residuals[0..n-1] to compute step-wise rates\n        n_res = len(residuals)\n        if n_res >= 2:\n            for idx in range(n_res - 1):\n                r_k = residuals[idx]\n                r_k1 = residuals[idx + 1]\n                if mode == \"modified\":\n                    # Linear factor lambda = r_{k+1} / r_k\n                    if r_k > 0.0:\n                        rate_values.append(r_k1 / r_k)\n                else:\n                    # Quadratic factor q = r_{k+1} / r_k^2\n                    if r_k > 0.0:\n                        rate_values.append(r_k1 / (r_k ** 2))\n\n        # Update global u for next increment initial guess\n        u = u_i\n\n    # Average the collected rates; if none, return 0.0\n    if len(rate_values) > 0:\n        avg_rate = float(np.mean(rate_values))\n    else:\n        avg_rate = 0.0\n\n    return total_iterations, avg_rate\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Using nondimensional parameters: A=1, L=1, E=1 for all cases.\n    test_cases = [\n        # (beta, P_total, N_inc, E, A, L)\n        (0.1, 0.5, 5, 1.0, 1.0, 1.0),  # Case 1\n        (1.0, 0.8, 8, 1.0, 1.0, 1.0),  # Case 2\n        (5.0, 0.8, 8, 1.0, 1.0, 1.0),  # Case 3\n        (0.0, 0.5, 5, 1.0, 1.0, 1.0),  # Case 4 (linear)\n    ]\n\n    results = []\n    for case in test_cases:\n        beta, P_total, N_inc, E, A, L = case\n\n        # Full Newton\n        N_full, R_full = newton_solve(\n            P_total=P_total, N_inc=N_inc, E=E, beta=beta, A=A, L=L,\n            tol=1e-10, max_iter=50, mode=\"full\"\n        )\n        # Modified Newton (freeze tangent per increment)\n        N_mod, R_mod = newton_solve(\n            P_total=P_total, N_inc=N_inc, E=E, beta=beta, A=A, L=L,\n            tol=1e-10, max_iter=50, mode=\"modified\"\n        )\n\n        results.append([N_full, N_mod, R_full, R_mod])\n\n    # Final print statement in the exact required format.\n    # Single line: list of sublists per test case.\n    print(str(results))\n\nsolve()\n```"
        }
    ]
}