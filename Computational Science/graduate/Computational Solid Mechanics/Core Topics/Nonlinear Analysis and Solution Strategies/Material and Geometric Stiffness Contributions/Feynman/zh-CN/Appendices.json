{
    "hands_on_practices": [
        {
            "introduction": "几何刚度矩阵 $K_G$ 用于描述初始应力状态对结构刚度的影响，是进行稳定性分析的核心。本练习将通过一个基本但常用的双线性四边形单元，指导您从第一性原理出发，一步步推导出几何刚度矩阵。这项实践旨在建立从连续介质力学理论到有限元离散矩阵计算的关键桥梁。",
            "id": "3579573",
            "problem": "考虑一个在有限元法 (FEM) 中处于平面应力状态下的单个等参双线性四边形单元，它在物理坐标 $\\{x,y\\}$ 中占据一个矩形区域，其中 $x \\in [-a,a]$，$y \\in [-b,b]$，且厚度 $t$ 为常数。从自然坐标 $(\\xi,\\eta) \\in [-1,1]\\times[-1,1]$ 到物理坐标的映射为 $x = a \\,\\xi$ 和 $y = b \\,\\eta$，其标准的双线性形函数为 $N_{1}(\\xi,\\eta) = \\frac{1}{4}(1-\\xi)(1-\\eta)$，$N_{2}(\\xi,\\eta) = \\frac{1}{4}(1+\\xi)(1-\\eta)$，$N_{3}(\\xi,\\eta) = \\frac{1}{4}(1+\\xi)(1+\\eta)$ 和 $N_{4}(\\xi,\\eta) = \\frac{1}{4}(1-\\xi)(1+\\eta)$。假设整个单元内存在一个均匀的初始 Cauchy 应力场，其中 $\\sigma_{xx} = \\sigma_{0}$ 且 $\\sigma_{yy} = \\sigma_{xy} = 0$。使用虚功原理及其关于预应力构型的线性化，推导几何刚度矩阵 $K_{G}$（用形函数梯度和初始应力表示），然后对该单元精确计算所得的积分。\n\n采用节点自由度顺序 $\\{u_{1x}, u_{1y}, u_{2x}, u_{2y}, u_{3x}, u_{3y}, u_{4x}, u_{4y}\\}$，并以 $a$、$b$、$t$ 和 $\\sigma_{0}$ 为参数，计算 $K_{G}$ 的显式 $8 \\times 8$ 闭合形式解析表达式。在推导过程中，验证所得矩阵是对称的。将最终答案表示为单个闭合形式的矩阵表达式；答案中不要求进行数值舍入，也无需指定物理单位。",
            "solution": "该问题经验证具有科学依据、是适定的和客观的。这是计算固体力学中的一个标准问题，特别是在使用有限元法 (FEM) 进行稳定性分析的背景下。所有必要信息均已提供，问题没有矛盾或含糊之处。因此，我们可以开始推导。\n\n几何刚度矩阵 $K_{G}$ 源于内虚功的线性化，它考虑了初始应力状态对单元刚度的影响。由该初始应力对内虚功的贡献由下式给出：\n$$ \\delta W_{G} = \\int_{V_0} \\boldsymbol{S}^{(0)} : \\delta \\boldsymbol{E}_{NL} \\, dV_0 $$\n其中，$V_0$ 是单元在初始构型下的体积，$\\boldsymbol{S}^{(0)}$ 是初始第二 Piola-Kirchhoff 应力张量（由于构型未应变，它等于初始 Cauchy 应力张量 $\\boldsymbol{\\sigma}^{(0)}$），而 $\\delta \\boldsymbol{E}_{NL}$ 是 Green-Lagrange 应变张量非线性部分的变分。非线性应变项为 $\\boldsymbol{E}_{NL} = \\frac{1}{2} (\\nabla \\boldsymbol{u})^T (\\nabla \\boldsymbol{u})$，其中 $\\boldsymbol{u}$ 是位移场，$\\nabla \\boldsymbol{u}$ 是其梯度。其变分为 $\\delta \\boldsymbol{E}_{NL} = \\frac{1}{2} [(\\nabla \\delta \\boldsymbol{u})^T (\\nabla \\boldsymbol{u}) + (\\nabla \\boldsymbol{u})^T (\\nabla \\delta \\boldsymbol{u})]$。\n\n由于 $\\boldsymbol{S}^{(0)}$ 是对称的，被积函数变为 $\\boldsymbol{S}^{(0)} : \\delta \\boldsymbol{E}_{NL} = \\text{Tr}(\\boldsymbol{S}^{(0)} (\\nabla \\delta \\boldsymbol{u})^T (\\nabla \\boldsymbol{u}))$。对于二维问题，用矩阵-向量表示法可写为：\n$$ \\delta W_G = \\int_{V_0} \\begin{pmatrix} \\frac{\\partial \\delta u_x}{\\partial x}  \\frac{\\partial \\delta u_y}{\\partial x} \\\\ \\frac{\\partial \\delta u_x}{\\partial y}  \\frac{\\partial \\delta u_y}{\\partial y} \\end{pmatrix} : \\begin{pmatrix} \\sigma_{xx}^{(0)}  \\sigma_{xy}^{(0)} \\\\ \\sigma_{yx}^{(0)}  \\sigma_{yy}^{(0)} \\end{pmatrix} \\begin{pmatrix} \\frac{\\partial u_x}{\\partial x}  \\frac{\\partial u_x}{\\partial y} \\\\ \\frac{\\partial u_y}{\\partial x}  \\frac{\\partial u_y}{\\partial y} \\end{pmatrix} \\, dV_0 $$\n展开此表达式得到被积函数：\n$$ \\sigma_{xx}^{(0)} \\left(\\frac{\\partial \\delta u_x}{\\partial x} \\frac{\\partial u_x}{\\partial x} + \\frac{\\partial \\delta u_y}{\\partial x} \\frac{\\partial u_y}{\\partial x}\\right) + \\sigma_{yy}^{(0)} \\left(\\frac{\\partial \\delta u_x}{\\partial y} \\frac{\\partial u_x}{\\partial y} + \\frac{\\partial \\delta u_y}{\\partial y} \\frac{\\partial u_y}{\\partial y}\\right) + \\sigma_{xy}^{(0)} \\left(\\frac{\\partial \\delta u_x}{\\partial x} \\frac{\\partial u_x}{\\partial y} + \\frac{\\partial \\delta u_x}{\\partial y} \\frac{\\partial u_x}{\\partial x} + \\frac{\\partial \\delta u_y}{\\partial x} \\frac{\\partial u_y}{\\partial y} + \\frac{\\partial \\delta u_y}{\\partial y} \\frac{\\partial u_y}{\\partial x}\\right) $$\n根据初始应力状态 $\\sigma_{xx}^{(0)} = \\sigma_0$ 和 $\\sigma_{yy}^{(0)} = \\sigma_{xy}^{(0)} = 0$，表达式可显著简化为：\n$$ \\delta W_G = \\int_{V_0} \\sigma_0 \\left( \\frac{\\partial \\delta u_x}{\\partial x} \\frac{\\partial u_x}{\\partial x} + \\frac{\\partial \\delta u_y}{\\partial x} \\frac{\\partial u_y}{\\partial x} \\right) \\, dV_0 $$\n位移场 $\\boldsymbol{u}(\\xi, \\eta) = (u_x, u_y)$ 由节点位移 $\\boldsymbol{d}$ 使用形函数 $N_i(\\xi, \\eta)$ 插值得到：\n$$ u_x(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) u_{ix} \\quad \\text{和} \\quad u_y(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) u_{iy} $$\n节点位移向量为 $\\boldsymbol{d} = \\{u_{1x}, u_{1y}, u_{2x}, u_{2y}, u_{3x}, u_{3y}, u_{4x}, u_{4y}\\}^T$。将插值位移代入 $\\delta W_G$ 的表达式：\n$$ \\delta W_G = \\int_{V_0} \\sigma_0 \\left( \\left(\\sum_{i=1}^{4} \\frac{\\partial N_i}{\\partial x} \\delta u_{ix}\\right) \\left(\\sum_{j=1}^{4} \\frac{\\partial N_j}{\\partial x} u_{jx}\\right) + \\left(\\sum_{i=1}^{4} \\frac{\\partial N_i}{\\partial x} \\delta u_{iy}\\right) \\left(\\sum_{j=1}^{4} \\frac{\\partial N_j}{\\partial x} u_{jy}\\right) \\right) \\, dV_0 $$\n这是一个双线性形式 $\\delta \\boldsymbol{d}^T K_G \\boldsymbol{d}$。几何刚度矩阵 $K_G$ 的分量由下式给出：\n$$ (K_G)_{2i-1, 2j-1} = \\int_{V_0} \\sigma_0 \\frac{\\partial N_i}{\\partial x} \\frac{\\partial N_j}{\\partial x} \\, dV_0 $$\n$$ (K_G)_{2i, 2j} = \\int_{V_0} \\sigma_0 \\frac{\\partial N_i}{\\partial x} \\frac{\\partial N_j}{\\partial x} \\, dV_0 $$\n且所有非对角块 $(K_G)_{2i-1, 2j}$ 和 $(K_G)_{2i, 2j-1}$ 均为零。该结构表明 $K_G$ 是对称的，因为积分关于下标 $i$ 和 $j$ 是对称的。该矩阵可以表示为 Kronecker 积 $K_G = \\boldsymbol{k} \\otimes \\boldsymbol{I}_2$，其中 $\\boldsymbol{I}_2$ 是 $2 \\times 2$ 的单位矩阵，$\\boldsymbol{k}$ 是一个 $4 \\times 4$ 矩阵，其分量为：\n$$ k_{ij} = \\int_{V_0} \\sigma_0 \\frac{\\partial N_i}{\\partial x} \\frac{\\partial N_j}{\\partial x} \\, dV_0 $$\n积分必须转换到自然坐标系 $(\\xi, \\eta)$。微分体积为 $dV_0 = t \\, dx \\, dy = t \\, \\det(\\boldsymbol{J}) \\, d\\xi \\, d\\eta$，其中 $\\boldsymbol{J}$ 是映射的 Jacobian 矩阵。\n映射由 $x=a\\xi$ 和 $y=b\\eta$ 给出。Jacobian 矩阵为：\n$$ \\boldsymbol{J} = \\begin{pmatrix} \\frac{\\partial x}{\\partial \\xi}  \\frac{\\partial y}{\\partial \\xi} \\\\ \\frac{\\partial x}{\\partial \\eta}  \\frac{\\partial y}{\\partial \\eta} \\end{pmatrix} = \\begin{pmatrix} a  0 \\\\ 0  b \\end{pmatrix} $$\n其行列式为 $\\det(\\boldsymbol{J}) = ab$。物理坐标导数与自然坐标导数之间的关系由链式法则给出：\n$$ \\begin{pmatrix} \\frac{\\partial N_i}{\\partial x} \\\\ \\frac{\\partial N_i}{\\partial y} \\end{pmatrix} = \\boldsymbol{J}^{-1} \\begin{pmatrix} \\frac{\\partial N_i}{\\partial \\xi} \\\\ \\frac{\\partial N_i}{\\partial \\eta} \\end{pmatrix} = \\begin{pmatrix} 1/a  0 \\\\ 0  1/b \\end{pmatrix} \\begin{pmatrix} \\frac{\\partial N_i}{\\partial \\xi} \\\\ \\frac{\\partial N_i}{\\partial \\eta} \\end{pmatrix} $$\n这得到 $\\frac{\\partial N_i}{\\partial x} = \\frac{1}{a} \\frac{\\partial N_i}{\\partial \\xi}$。将此代入 $k_{ij}$ 的积分式中：\n$$ k_{ij} = \\int_{-1}^{1} \\int_{-1}^{1} \\sigma_0 \\left( \\frac{1}{a} \\frac{\\partial N_i}{\\partial \\xi} \\right) \\left( \\frac{1}{a} \\frac{\\partial N_j}{\\partial \\xi} \\right) t (ab) \\, d\\xi \\, d\\eta = \\frac{\\sigma_0 t b}{a} \\int_{-1}^{1} \\int_{-1}^{1} \\frac{\\partial N_i}{\\partial \\xi} \\frac{\\partial N_j}{\\partial \\xi} \\, d\\xi \\, d\\eta $$\n接下来，我们计算形函数关于 $\\xi$ 的导数：\n$N_{1} = \\frac{1}{4}(1-\\xi)(1-\\eta) \\implies \\frac{\\partial N_1}{\\partial \\xi} = -\\frac{1}{4}(1-\\eta)$\n$N_{2} = \\frac{1}{4}(1+\\xi)(1-\\eta) \\implies \\frac{\\partial N_2}{\\partial \\xi} = \\frac{1}{4}(1-\\eta)$\n$N_{3} = \\frac{1}{4}(1+\\xi)(1+\\eta) \\implies \\frac{\\partial N_3}{\\partial \\xi} = \\frac{1}{4}(1+\\eta)$\n$N_{4} = \\frac{1}{4}(1-\\xi)(1+\\eta) \\implies \\frac{\\partial N_4}{\\partial \\xi} = -\\frac{1}{4}(1+\\eta)$\n现在我们计算这些导数乘积的积分。\n$$ \\int_{-1}^{1} \\int_{-1}^{1} \\left(\\frac{1}{4}\\right)^2 (1-\\eta)^2 \\, d\\xi d\\eta = \\frac{1}{16} [\\xi]_{-1}^1 \\int_{-1}^1 (1-2\\eta+\\eta^2)d\\eta = \\frac{2}{16} \\left[\\eta-\\eta^2+\\frac{\\eta^3}{3}\\right]_{-1}^1 = \\frac{1}{8} \\left( \\frac{1}{3} - (-\\frac{7}{3}) \\right) = \\frac{1}{3} $$\n$$ \\int_{-1}^{1} \\int_{-1}^{1} \\left(\\frac{1}{4}\\right)^2 (1+\\eta)^2 \\, d\\xi d\\eta = \\frac{1}{16} [\\xi]_{-1}^1 \\int_{-1}^1 (1+2\\eta+\\eta^2)d\\eta = \\frac{2}{16} \\left[\\eta+\\eta^2+\\frac{\\eta^3}{3}\\right]_{-1}^1 = \\frac{1}{8} \\left( \\frac{7}{3} - (-\\frac{1}{3}) \\right) = \\frac{1}{3} $$\n$$ \\int_{-1}^{1} \\int_{-1}^{1} \\left(\\frac{1}{4}\\right)^2 (1-\\eta)(1+\\eta) \\, d\\xi d\\eta = \\frac{1}{16} [\\xi]_{-1}^1 \\int_{-1}^1 (1-\\eta^2)d\\eta = \\frac{2}{16} \\left[\\eta-\\frac{\\eta^3}{3}\\right]_{-1}^1 = \\frac{1}{8} \\left( \\frac{2}{3} - (-\\frac{2}{3}) \\right) = \\frac{1}{6} $$\n使用这些结果，我们构造矩阵 $\\boldsymbol{k}$。令 $C = \\frac{\\sigma_0 t b}{a}$。\n$k_{11} = C \\cdot (1) \\cdot \\frac{1}{3}$，$k_{12} = C \\cdot (-1) \\cdot \\frac{1}{3}$，$k_{13} = C \\cdot (-1) \\cdot \\frac{1}{6}$，$k_{14} = C \\cdot (1) \\cdot \\frac{1}{6}$\n$k_{22} = C \\cdot (1) \\cdot \\frac{1}{3}$，$k_{23} = C \\cdot (1) \\cdot \\frac{1}{6}$，$k_{24} = C \\cdot (-1) \\cdot \\frac{1}{6}$\n$k_{33} = C \\cdot (1) \\cdot \\frac{1}{3}$，$k_{34} = C \\cdot (-1) \\cdot \\frac{1}{3}$\n$k_{44} = C \\cdot (1) \\cdot \\frac{1}{3}$\n组合对称矩阵 $\\boldsymbol{k}$：\n$$ \\boldsymbol{k} = \\frac{\\sigma_0 t b}{a} \\begin{pmatrix} 1/3  -1/3  -1/6  1/6 \\\\ -1/3  1/3  1/6  -1/6 \\\\ -1/6  1/6  1/3  -1/3 \\\\ 1/6  -1/6  -1/3  1/3 \\end{pmatrix} = \\frac{\\sigma_0 t b}{6a} \\begin{pmatrix} 2  -2  -1  1 \\\\ -2  2  1  -1 \\\\ -1  1  2  -2 \\\\ 1  -1  -2  2 \\end{pmatrix} $$\n最终的 $8 \\times 8$ 几何刚度矩阵 $K_G = \\boldsymbol{k} \\otimes \\boldsymbol{I}_2$ 是通过将每个元素 $k_{ij}$ 替换为块 $k_{ij}\\boldsymbol{I}_2$ 来构造的：\n$$ K_G = \\frac{\\sigma_0 t b}{6a} \\begin{pmatrix}\n 2\\boldsymbol{I}_2  -2\\boldsymbol{I}_2  -1\\boldsymbol{I}_2   1\\boldsymbol{I}_2 \\\\\n-2\\boldsymbol{I}_2   2\\boldsymbol{I}_2   1\\boldsymbol{I}_2  -1\\boldsymbol{I}_2 \\\\\n-1\\boldsymbol{I}_2   1\\boldsymbol{I}_2   2\\boldsymbol{I}_2  -2\\boldsymbol{I}_2 \\\\\n 1\\boldsymbol{I}_2  -1\\boldsymbol{I}_2  -2\\boldsymbol{I}_2   2\\boldsymbol{I}_2\n\\end{pmatrix} $$\n将此展开为完整的 $8 \\times 8$ 矩阵即可得到最终结果。该矩阵是对称的，这一点由 $\\boldsymbol{k}$ 的对称性所证实。",
            "answer": "$$\n\\boxed{\\frac{\\sigma_{0} t b}{6a} \\begin{pmatrix}\n 2   0  -2   0  -1   0   1   0 \\\\\n 0   2   0  -2   0  -1   0   1 \\\\\n-2   0   2   0   1   0  -1   0 \\\\\n 0  -2   0   2   0   1   0  -1 \\\\\n-1   0   1   0   2   0  -2   0 \\\\\n 0  -1   0   1   0   2   0  -2 \\\\\n 1   0  -1   0  -2   0   2   0 \\\\\n 0   1   0  -1   0  -2   0   2\n\\end{pmatrix}}\n$$"
        },
        {
            "introduction": "在掌握了如何推导几何刚度矩阵之后，本练习将探讨一个关键问题：“在实际计算中，一致的几何刚度矩阵为何如此重要？”。通过一个预张紧膜的编程任务，您将直接观察并量化将 $K_G$ 纳入切线刚度矩阵后，牛顿法收敛速率的显著提升，尤其是在几何效应显著的情况下。",
            "id": "3579552",
            "problem": "考虑一个在有限元法（FEM）框架内使用单一假定面外模态建模的拉紧矩形薄膜。该薄膜占据域 $\\Omega = [0,L] \\times [0,W]$，厚度为 $t$，材料为各向同性线弹性，杨氏模量为 $E$，泊松比为 $\\nu$，并以均匀的面内应力合力 $N_{0x} = N_{0y} = T_0$ 和 $N_{0xy} = 0$ 进行初始预张紧，其中 $T_0$ 以 $\\mathrm{N}/\\mathrm{m}$ 为单位指定。面外位移被限制为形式 $w(x,y) = u\\,\\phi(x,y)$，其中 $u \\in \\mathbb{R}$ 是单一广义坐标，$\\phi(x,y)$ 是一个光滑的模态振型，满足适用于该薄膜问题的本质边界条件。设外部横向压力 $p$（单位为 $\\mathrm{N}/\\mathrm{m}^2$）均匀作用在薄膜上。\n\n根据虚功原理和薄膜的 von Kármán 应变近似，其弱形式导出一个关于广义坐标 $u$ 的标量非线性残差 $R(u)$。总一致切线刚度 $K_t(u)$ 可加性分解为一个由初始应力状态产生的几何刚度贡献 $K_G$ 和一个由本构律和运动非线性产生的材料刚度贡献 $K_M(u)$。几何刚度 $K_G$ 与 $u$ 无关，而由于非线性薄膜应变，$K_M(u)$ 依赖于 $u$。\n\n你的目标是实现一个程序，在两种线性化策略下执行牛顿迭代来求解 $R(u) = 0$：\n- 策略 A（全切线）：使用完整的一致切线 $K_t(u) = K_G + K_M(u)$。\n- 策略 B（忽略几何刚度）：使用简化的切线 $K_t^{\\neg \\text{geo}}(u) = K_M(u)$，同时保持残差 $R(u)$ 不变。\n\n你必须：\n1. 从虚功原理和 von Kármán 薄膜运动学出发，对于单模态近似 $w=u\\phi$，将标量残差 $R(u)$ 表达为 $u$ 的函数。使用 von Kármán 假设下的面内薄膜应变度量 $\\varepsilon_x$、$\\varepsilon_y$ 和 $\\gamma_{xy}$ 的定义，以及应力合力的平面应力本构律 $\\mathbf{N} = \\mathbf{C}\\,\\boldsymbol{\\varepsilon}$（其中 $\\mathbf{C}$ 是标准的各向同性薄膜刚度矩阵，用 $E$、$\\nu$ 和 $t$ 表示），推导出 $R(u)$ 的结构，用在 $\\Omega$ 上包含 $\\phi$ 导数的积分来表示。这些积分定义了算法将需要的两个标量系数：\n   - 一个几何系数 $\\alpha$，来自初始应力合力 $N_{0x}$、$N_{0y}$ 的虚功和薄膜应变的变分。\n   - 一个材料系数 $\\beta$，来自本构应力合力 $\\mathbf{N} = \\mathbf{C}\\,\\boldsymbol{\\varepsilon}$ 的虚功和薄膜应变的变分。\n   外部载荷贡献一个广义载荷幅值 $F$，它是 $p$ 在模态振型 $\\phi$ 上的投影。最终的标量残差必须为形式 $R(u) = \\alpha\\,T_0\\,u + \\beta\\,u^3 - F$，并且一致切线必须为形式 $K_t(u) = \\alpha\\,T_0 + 3\\,\\beta\\,u^2$。几何和材料切线贡献分别为 $K_G = \\alpha\\,T_0$ 和 $K_M(u) = 3\\,\\beta\\,u^2$。$\\alpha$、$\\beta$ 和 $F$ 的所有定义都必须按照要求从第一性原理推导，以在 $\\Omega$ 上的积分形式给出，其中包含 $\\phi$ 及其导数。使用模态振型 $\\phi(x,y) = \\sin\\!\\left(\\frac{\\pi x}{L}\\right)\\sin\\!\\left(\\frac{\\pi y}{W}\\right)$。\n\n2. 为策略 A 和 B 实现一个牛顿求解器。对两种策略使用相同的初始猜测值 $u_0$，该值基于一个有物理动机的近似来选择，使得当 $F>0$ 时 $u_0$ 严格为正。如果需要，执行回溯线搜索以确保每次迭代中 $|R(u)|$ 减小。对残差大小使用 $\\varepsilon_{\\text{tol}} = 10^{-12}$（单位 $\\mathrm{N}$）的收敛容差，以及最多 50 次迭代。对每种策略，测量：\n   - 收敛所需的牛顿迭代次数（一个整数）。\n   - 每次迭代的平均残差减少率，定义为在收敛前所有接受的迭代中比率 $r_k = \\frac{|R(u_{k+1})|}{|R(u_k)|}$ 的算术平均值（一个浮点数）。\n\n3. 单位必须一致：$L$ 和 $W$ 的单位为 $\\mathrm{m}$，$t$ 的单位为 $\\mathrm{m}$，$E$ 的单位为 $\\mathrm{Pa}$，$\\nu$ 无量纲，$T_0$ 的单位为 $\\mathrm{N}/\\mathrm{m}$，$p$ 的单位为 $\\mathrm{N}/\\mathrm{m}^2$，$u$ 的单位为 $\\mathrm{m}$，$R(u)$ 和 $F$ 的单位为 $\\mathrm{N}$，刚度的单位为 $\\mathrm{N}/\\mathrm{m}$。将平均残差减少率报告为无量纲浮点数，迭代次数报告为整数。\n\n4. 使用以下参数集测试套件，每个都指定为元组 $(L,W,t,E,\\nu,T_0,p)$，所有量均以所述单位表示：\n   - 测试 1：$(1.0\\,\\mathrm{m},\\,1.0\\,\\mathrm{m},\\,1.0\\times 10^{-4}\\,\\mathrm{m},\\,1.0\\times 10^{8}\\,\\mathrm{Pa},\\,0.3,\\,1000\\,\\mathrm{N}/\\mathrm{m},\\,1000\\,\\mathrm{N}/\\mathrm{m}^2)$。\n   - 测试 2：$(1.0\\,\\mathrm{m},\\,1.0\\,\\mathrm{m},\\,1.0\\times 10^{-4}\\,\\mathrm{m},\\,1.0\\times 10^{8}\\,\\mathrm{Pa},\\,0.3,\\,100\\,\\mathrm{N}/\\mathrm{m},\\,1000\\,\\mathrm{N}/\\mathrm{m}^2)$。\n   - 测试 3：$(1.0\\,\\mathrm{m},\\,1.0\\,\\mathrm{m},\\,1.0\\times 10^{-4}\\,\\mathrm{m},\\,1.0\\times 10^{8}\\,\\mathrm{Pa},\\,0.3,\\,0\\,\\mathrm{N}/\\mathrm{m},\\,1000\\,\\mathrm{N}/\\mathrm{m}^2)$。\n   - 测试 4：$(1.0\\,\\mathrm{m},\\,1.0\\,\\mathrm{m},\\,1.0\\times 10^{-4}\\,\\mathrm{m},\\,1.0\\times 10^{8}\\,\\mathrm{Pa},\\,0.3,\\,1000\\,\\mathrm{N}/\\mathrm{m},\\,5000\\,\\mathrm{N}/\\mathrm{m}^2)$。\n\n5. 最终输出格式：你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例贡献一个形式为 $[\\text{iters\\_full},\\text{iters\\_no\\_geo},\\text{avg\\_rate\\_full},\\text{avg\\_rate\\_no\\_geo}]$ 的子列表，其中迭代次数为整数，平均率为浮点数。例如，输出应类似于 $\\left[\\left[i_1,j_1,r_1,s_1\\right],\\left[i_2,j_2,r_2,s_2\\right],\\left[i_3,j_3,r_3,s_3\\right],\\left[i_4,j_4,r_4,s_4\\right]\\right]$。\n\n你的实现必须是一个完整、可运行的程序，该程序使用给定的模态振型 $\\phi(x,y)$ 从所述积分中计算 $\\alpha$、$\\beta$ 和 $F$，对策略 A 和 B 执行牛顿迭代，并以所描述的精确格式报告所提供的测试套件的指标。",
            "solution": "经过仔细评估，用户问题被认为是有效的。它在科学上基于非线性固体力学原理，是良定的，并且为获得唯一解提供了所有必要的数据和条件。该任务涉及计算力学中的一个标准推导，随后是数值求解算法的实现。\n\n该解法是基于预张紧薄膜的单模态近似的虚功原理（PVW）发展而来的。虚功原理指出，对于一个处于平衡状态的系统，对于任何运动学容许的虚位移，内虚功 $\\delta W_{\\text{int}}$ 等于外虚功 $\\delta W_{\\text{ext}}$。\n\n$$ \\delta W_{\\text{int}} = \\delta W_{\\text{ext}} $$\n\n非线性系统的残差 $R(u)$ 由虚功原理定义为 $R(u) \\delta u = \\delta W_{\\text{int}} - \\delta W_{\\text{ext}} = 0$。由于这对于广义坐标的任意虚位移 $\\delta u$ 都必须成立，因此项 $R(u)$ 必须为零。\n\n面外位移 $w$ 及其变分 $\\delta w$ 使用单一模态振型 $\\phi(x,y)$ 和一个广义坐标 $u$ 来近似：\n$$ w(x,y) = u\\,\\phi(x,y) $$\n$$ \\delta w(x,y) = \\delta u\\,\\phi(x,y) $$\n\n内虚功是通过对应力张量与应变张量变分的缩并在体积上积分来计算的。对于薄膜，这使用应力合力 $\\mathbf{N}$ 和薄膜应变 $\\boldsymbol{\\varepsilon}$ 来表示。使用第二 Piola-Kirchhoff 应力合力 $\\mathbf{N}^S$ 和 Green-Lagrange 应变 $\\boldsymbol{\\varepsilon}_L$ 的材料描述，内虚功为：\n$$ \\delta W_{\\text{int}} = \\int_{\\Omega} (\\mathbf{N}^S)^T \\delta\\boldsymbol{\\varepsilon}_L \\,dA $$\n总应力合力是初始预张力 $\\mathbf{N}_0$ 和弹性产生的应力合力 $\\Delta\\mathbf{N}^S$ 的和，即 $\\mathbf{N}^S = \\mathbf{N}_0 + \\Delta\\mathbf{N}^S$。在 von Kármán 假设下（在应变-位移关系中忽略面内位移），Green-Lagrange 薄膜应变是纯非线性的：\n$$ \\boldsymbol{\\varepsilon}_L = \\begin{Bmatrix} \\varepsilon_x \\\\ \\varepsilon_y \\\\ \\gamma_{xy} \\end{Bmatrix} = \\frac{1}{2} u^2 \\begin{Bmatrix} (\\phi_{,x})^2 \\\\ (\\phi_{,y})^2 \\\\ 2 \\phi_{,x} \\phi_{,y} \\end{Bmatrix} $$\n它关于 $u$ 的变分是：\n$$ \\delta\\boldsymbol{\\varepsilon}_L = \\frac{\\partial \\boldsymbol{\\varepsilon}_L}{\\partial u} \\delta u = u\\,\\delta u \\begin{Bmatrix} (\\phi_{,x})^2 \\\\ (\\phi_{,y})^2 \\\\ 2 \\phi_{,x} \\phi_{,y} \\end{Bmatrix} $$\n应力变化的本构关系是 $\\Delta\\mathbf{N}^S = \\mathbf{C} \\boldsymbol{\\varepsilon}_L$，其中 $\\mathbf{C}$ 是平面应力薄膜刚度矩阵。\n内虚功可以可加性地分解为：\n$$ \\delta W_{\\text{int}} = \\int_{\\Omega} (\\mathbf{N}_0 + \\mathbf{C}\\boldsymbol{\\varepsilon}_L)^T \\delta\\boldsymbol{\\varepsilon}_L \\,dA = \\underbrace{\\int_{\\Omega} \\mathbf{N}_0^T \\delta\\boldsymbol{\\varepsilon}_L \\,dA}_{\\delta W_{\\text{geo}}} + \\underbrace{\\int_{\\Omega} (\\mathbf{C}\\boldsymbol{\\varepsilon}_L)^T \\delta\\boldsymbol{\\varepsilon}_L \\,dA}_{\\delta W_{\\text{mat}}} $$\n\n第一项 $\\delta W_{\\text{geo}}$ 代表初始应力场做的功。当 $\\mathbf{N}_0 = \\{T_0, T_0, 0\\}^T$ 时：\n$$ \\delta W_{\\text{geo}} = \\int_{\\Omega} \\begin{Bmatrix} T_0 \\\\ T_0 \\\\ 0 \\end{Bmatrix}^T \\left( u\\,\\delta u \\begin{Bmatrix} \\phi_{,x}^2 \\\\ \\phi_{,y}^2 \\\\ 2\\phi_{,x}\\phi_{,y} \\end{Bmatrix} \\right) \\,dA = \\left( T_0 u \\int_{\\Omega} (\\phi_{,x}^2 + \\phi_{,y}^2) \\,dA \\right) \\delta u $$\n这定义了几何系数 $\\alpha$：\n$$ \\alpha = \\int_{\\Omega} \\left( \\left(\\frac{\\partial\\phi}{\\partial x}\\right)^2 + \\left(\\frac{\\partial\\phi}{\\partial y}\\right)^2 \\right) \\,dA $$\n对残差的贡献是 $\\alpha T_0 u$。\n\n第二项 $\\delta W_{\\text{mat}}$ 代表弹性应力做的功。\n$$ \\delta W_{\\text{mat}} = \\int_{\\Omega} \\boldsymbol{\\varepsilon}_L^T \\mathbf{C} \\delta\\boldsymbol{\\varepsilon}_L \\,dA = \\int_{\\Omega} \\left(\\frac{1}{2}u^2 \\mathbf{v}^T \\mathbf{C}\\right) (u\\,\\delta u\\,\\mathbf{v}) \\,dA = \\left( \\frac{1}{2}u^3 \\int_{\\Omega} \\mathbf{v}^T \\mathbf{C} \\mathbf{v} \\,dA \\right)\\delta u $$\n其中 $\\mathbf{v} = \\{\\phi_{,x}^2, \\phi_{,y}^2, 2\\phi_{,x}\\phi_{,y}\\}^T$。这定义了材料系数 $\\beta$：\n$$ \\beta = \\frac{1}{2} \\int_{\\Omega} \\begin{Bmatrix} (\\phi_{,x})^2 \\\\ (\\phi_{,y})^2 \\\\ 2\\phi_{,x}\\phi_{,y} \\end{Bmatrix}^T \\mathbf{C} \\begin{Bmatrix} (\\phi_{,x})^2 \\\\ (\\phi_{,y})^2 \\\\ 2\\phi_{,x}\\phi_{,y} \\end{Bmatrix} \\,dA $$\n平面应力本构矩阵为：\n$$ \\mathbf{C} = \\frac{E t}{1-\\nu^2} \\begin{bmatrix} 1  \\nu  0 \\\\ \\nu  1  0 \\\\ 0  0  \\frac{1-\\nu}{2} \\end{bmatrix} $$\n将 $\\mathbf{C}$ 代入 $\\beta$ 的表达式并化简得到：\n$$ \\beta = \\frac{Et}{2(1-\\nu^2)} \\int_{\\Omega} \\left( (\\phi_{,x}^2 + \\phi_{,y}^2)^2 + (2\\nu - 1) (\\phi_{,x}^2 \\phi_{,y}^2 - (\\phi_{,x}\\phi_{,y})^2) \\right) \\, dA $$\n对于所选的模态振型，$\\phi_{,x} \\propto \\cos(\\cdot)\\sin(\\cdot)$ 且 $\\phi_{,y} \\propto \\sin(\\cdot)\\cos(\\cdot)$，因此 $\\phi_{,x}^2 \\phi_{,y}^2 = (\\phi_{,x}\\phi_{,y})^2$，这极大地简化了被积函数：\n$$ \\beta = \\frac{Et}{2(1-\\nu^2)} \\int_{\\Omega} (\\phi_{,x}^2 + \\phi_{,y}^2)^2 \\, dA $$\n\n由均匀压力 $p$ 引起的外虚功 $\\delta W_{\\text{ext}}$ 为：\n$$ \\delta W_{\\text{ext}} = \\int_{\\Omega} p\\,\\delta w \\,dA = \\int_{\\Omega} p\\,(\\phi\\,\\delta u) \\,dA = \\left( p \\int_{\\Omega} \\phi \\,dA \\right) \\delta u $$\n这定义了广义力 $F$：\n$$ F = p \\int_{\\Omega} \\phi \\,dA $$\n\n合并各项，标量残差方程 $R(u)=0$ 为：\n$$ R(u) = \\alpha T_0 u + \\beta u^3 - F = 0 $$\n一致切线刚度 $K_t(u)$ 是残差关于 $u$ 的导数：\n$$ K_t(u) = \\frac{dR}{du} = \\alpha T_0 + 3\\beta u^2 $$\n这自然地分解为几何刚度 $K_G = \\alpha T_0$ 和材料刚度 $K_M(u) = 3\\beta u^2$。\n\n系数 $\\alpha$、$\\beta$ 和 $F$ 是为模态振型 $\\phi(x,y) = \\sin(\\frac{\\pi x}{L})\\sin(\\frac{\\pi y}{W})$ 在域 $\\Omega = [0,L] \\times [0,W]$ 上计算的。所需的积分计算如下：\n$$ \\int_0^L \\sin^2\\left(\\frac{\\pi x}{L}\\right)dx = \\frac{L}{2}, \\quad \\int_0^L \\cos^2\\left(\\frac{\\pi x}{L}\\right)dx = \\frac{L}{2} $$\n$$ \\int_0^L \\sin^4\\left(\\frac{\\pi x}{L}\\right)dx = \\frac{3L}{8}, \\quad \\int_0^L \\cos^4\\left(\\frac{\\pi x}{L}\\right)dx = \\frac{3L}{8} $$\n$$ \\int_0^L \\sin^2\\left(\\frac{\\pi x}{L}\\right)\\cos^2\\left(\\frac{\\pi x}{L}\\right)dx = \\frac{L}{8} $$\n这些恒等式类似地适用于在 $[0,W]$ 上对 $y$ 的积分。\n\n$F$ 的计算：\n$$ F = p \\int_0^L \\sin\\left(\\frac{\\pi x}{L}\\right)dx \\int_0^W \\sin\\left(\\frac{\\pi y}{W}\\right)dy = p \\left(\\frac{2L}{\\pi}\\right) \\left(\\frac{2W}{\\pi}\\right) = \\frac{4LWp}{\\pi^2} $$\n\n$\\alpha$ 的计算：\n$$ \\alpha = \\int_0^L \\hspace{-2mm} \\int_0^W \\hspace{-2mm} \\left(\\left(\\frac{\\pi}{L}\\right)^2 \\cos^2\\left(\\frac{\\pi x}{L}\\right)\\sin^2\\left(\\frac{\\pi y}{W}\\right) + \\left(\\frac{\\pi}{W}\\right)^2 \\sin^2\\left(\\frac{\\pi x}{L}\\right)\\cos^2\\left(\\frac{\\pi y}{W}\\right)\\right) dy dx $$\n$$ \\alpha = \\left(\\frac{\\pi}{L}\\right)^2 \\left(\\frac{L}{2}\\right)\\left(\\frac{W}{2}\\right) + \\left(\\frac{\\pi}{W}\\right)^2 \\left(\\frac{L}{2}\\right)\\left(\\frac{W}{2}\\right) = \\frac{\\pi^2 W}{4L} + \\frac{\\pi^2 L}{4W} = \\frac{\\pi^2}{4}\\left(\\frac{W}{L} + \\frac{L}{W}\\right) $$\n\n$\\beta$ 的计算：所需的积分是 $\\int_\\Omega (\\phi_{,x}^2 + \\phi_{,y}^2)^2 \\, dA$。\n$$ (\\phi_{,x}^2 + \\phi_{,y}^2)^2 = \\left(\\left(\\frac{\\pi}{L}\\right)^2 c_x^2 s_y^2 + \\left(\\frac{\\pi}{W}\\right)^2 s_x^2 c_y^2\\right)^2 = \\left(\\frac{\\pi}{L}\\right)^4 c_x^4 s_y^4 + \\left(\\frac{\\pi}{W}\\right)^4 s_x^4 c_y^4 + 2\\left(\\frac{\\pi^2}{LW}\\right)^2 c_x^2 s_x^2 c_y^2 s_y^2 $$\n其中 $s_x = \\sin(\\pi x/L)$，$c_y = \\cos(\\pi y/W)$，等等。逐项积分：\n$$ \\int_{\\Omega} (\\phi_{,x}^2+\\phi_{,y}^2)^2 dA = \\left(\\frac{\\pi}{L}\\right)^4\\left(\\frac{3L}{8}\\right)\\left(\\frac{3W}{8}\\right) + \\left(\\frac{\\pi}{W}\\right)^4\\left(\\frac{3L}{8}\\right)\\left(\\frac{3W}{8}\\right) + 2\\left(\\frac{\\pi^2}{LW}\\right)^2\\left(\\frac{L}{8}\\right)\\left(\\frac{W}{8}\\right) $$\n$$ = \\frac{9\\pi^4 W}{64 L^3} + \\frac{9\\pi^4 L}{64 W^3} + \\frac{2\\pi^4}{64 LW} = \\frac{\\pi^4}{64}\\left(\\frac{9W}{L^3} + \\frac{9L}{W^3} + \\frac{2}{LW}\\right) $$\n因此，系数 $\\beta$ 为：\n$$ \\beta = \\frac{Et}{2(1-\\nu^2)} \\frac{\\pi^4}{64}\\left(\\frac{9W}{L^3} + \\frac{9L}{W^3} + \\frac{2}{LW}\\right) $$\n有了这些系数，就可以实现牛顿求解器。一个基于物理的初始猜测值 $u_0$ 是从线性化问题导出的：如果 $T_0 > 0$，线性几何刚度在 $u$ 较小时占主导地位，给出 $u_0 \\approx F/(\\alpha T_0)$。如果 $T_0 = 0$，问题是纯非线性的，使用精确解 $u = (F/\\beta)^{1/3}$ 作为初始猜测值。使用回溯线搜索来全局化牛顿迭代的收敛性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the nonlinear deflection of a pre-tensioned membrane using a\n    single-mode approximation and compares two Newton iteration strategies.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (L, W, t, E, nu, T0, p)\n        (1.0, 1.0, 1.0e-4, 1.0e8, 0.3, 1000.0, 1000.0),\n        (1.0, 1.0, 1.0e-4, 1.0e8, 0.3, 100.0, 1000.0),\n        (1.0, 1.0, 1.0e-4, 1.0e8, 0.3, 0.0, 1000.0),\n        (1.0, 1.0, 1.0e-4, 1.0e8, 0.3, 1000.0, 5000.0),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        case_results = run_case(case)\n        all_results.append(case_results)\n\n    # Final print statement in the exact required format.\n    # e.g. [[i1,j1,r1,s1],[i2,j2,r2,s2],...]\n    outer_parts = []\n    for res in all_results:\n        inner_parts = [str(item) for item in res]\n        inner_str = f\"[{','.join(inner_parts)}]\"\n        outer_parts.append(inner_str)\n    \n    final_output_str = f\"[{','.join(outer_parts)}]\"\n    print(final_output_str)\n\ndef calculate_coefficients(L, W, t, E, nu, p):\n    \"\"\"\n    Calculates the scalar coefficients F, alpha, and beta based on the\n    derived integral formulas.\n    \"\"\"\n    # Generalized force F\n    F = 4.0 * L * W * p / (np.pi**2)\n\n    # Geometric coefficient alpha\n    alpha = (np.pi**2 / 4.0) * (W / L + L / W)\n\n    # Material coefficient beta\n    C_factor = E * t / (1.0 - nu**2)\n    integral_term = (np.pi**4 / 64.0) * (\n        9.0 * W / L**3 + 9.0 * L / W**3 + 2.0 / (L * W)\n    )\n    beta = (C_factor / 2.0) * integral_term\n\n    return F, alpha, beta\n\ndef newton_solver(F, alpha, beta, T0, use_k_geo):\n    \"\"\"\n    Performs Newton iterations to solve R(u) = 0.\n    \n    Args:\n        F, alpha, beta, T0: Scalar coefficients of the problem.\n        use_k_geo (bool): If True, use full tangent. If False, neglect K_geo.\n\n    Returns:\n        tuple: (iteration_count, average_residual_reduction_rate).\n               Returns (-1, -1.0) on failure.\n    \"\"\"\n    TOL = 1.0e-12\n    MAX_ITER = 50\n\n    def residual(u):\n        return alpha * T0 * u + beta * u**3 - F\n\n    def tangent(u):\n        K_geo = alpha * T0\n        K_mat = 3.0 * beta * u**2\n        if use_k_geo:\n            return K_geo + K_mat\n        else:\n            # For Strategy B, K_geo is omitted from the tangent\n            return K_mat\n\n    # Initial guess for displacement u\n    k_lin = alpha * T0\n    # Use linear solution if stable, otherwise cubic solution\n    if k_lin > 1e-9:\n        u = F / k_lin\n    else:\n        # This branch is taken for T0 = 0\n        if beta > 1e-9:\n            u = (F / beta)**(1.0/3.0)\n        else:\n            # Case with no stiffness, solution is arbitrary or infinite\n            u = 0.0\n\n    R_current = residual(u)\n    if abs(R_current) = TOL:\n        return 0, 0.0\n\n    iterations = 0\n    reduction_rates = []\n\n    for i in range(MAX_ITER):\n        K = tangent(u)\n        \n        # Check for singular stiffness (e.g., in Strategy B at u=0)\n        if abs(K)  1e-12:\n            return -1, -1.0 # Failure: singular tangent\n\n        delta_u = -R_current / K\n\n        # Backtracking line search to ensure residual reduction\n        lambda_ls = 1.0\n        for _ in range(10): # Max 10 backtracking steps\n            u_next = u + lambda_ls * delta_u\n            R_next = residual(u_next)\n            if abs(R_next)  abs(R_current):\n                break\n            lambda_ls /= 2.0\n        else:\n            # Line search failed to find a decreasing step\n            return -2, -2.0 # Failure: line search\n\n        # Store reduction rate before updating state\n        if abs(R_current) > 1e-15: # Avoid division by zero\n            reduction_rates.append(abs(R_next) / abs(R_current))\n\n        # Update state for next iteration\n        u = u_next\n        R_current = R_next\n        iterations += 1\n\n        # Check for convergence\n        if abs(R_current) = TOL:\n            avg_rate = np.mean(reduction_rates) if reduction_rates else 0.0\n            return iterations, avg_rate\n\n    # If loop finishes, max iterations were reached without convergence\n    return MAX_ITER, np.mean(reduction_rates) if reduction_rates else -3.0\n\ndef run_case(case_params):\n    \"\"\"\n    Runs a single test case for both strategies and returns the metrics.\n    \"\"\"\n    L, W, t, E, nu, T0, p = case_params\n\n    F, alpha, beta = calculate_coefficients(L, W, t, E, nu, p)\n\n    # Strategy A: Full tangent K_t = K_geo + K_mat\n    iters_full, avg_rate_full = newton_solver(\n        F, alpha, beta, T0, use_k_geo=True\n    )\n\n    # Strategy B: Reduced tangent K_t = K_mat\n    iters_no_geo, avg_rate_no_geo = newton_solver(\n        F, alpha, beta, T0, use_k_geo=False\n    )\n\n    return [iters_full, iters_no_geo, avg_rate_full, avg_rate_no_geo]\n\nsolve()\n```"
        },
        {
            "introduction": "高级的非线性分析常常涉及大转动问题，而协同转动（co-rotational）列构法是处理这类问题的有效技术。本练习要求您分别在材料坐标系和空间坐标系下实现几何刚度矩阵，并通过数值计算验证它们在协同转动框架下的等价性，从而证明其满足客观性原理（或称框架无关性）。这项实践将加深您对不同运动学描述及其与材料和几何刚度贡献相互作用的理解。",
            "id": "3579576",
            "problem": "实现一个独立的程序，为单个共旋线性四面体实体单元构建几何刚度贡献，并比较在空间坐标系和材料坐标系中计算的结果。目标是通过直接使用基础运动学和应力前推，而不参考预先推导的公式，来验证几何刚度矩阵（表示为 $K_G$）的标架无关性和数值等效性。所有量均为无量纲，并且在适用情况下，角度单位必须是弧度。\n\n推导和实现的基本依据必须从以下连续介质力学定义开始：\n- 设运动为 $x(X)$，其中 $X \\in \\mathbb{R}^3$ 是材料（参考）坐标，$x \\in \\mathbb{R}^3$ 是空间（当前）坐标。\n- 变形梯度为 $F = \\dfrac{\\partial x}{\\partial X}$，其雅可比行列式为 $J = \\det F$。\n- 材料坐标系中的第二类Piola-Kirchhoff应力（SPK）张量为 $S$，空间坐标系中的Cauchy应力张量为 $\\sigma$，它们通过前推关系 $\\sigma = \\dfrac{1}{J} F S F^\\top$ 相关联。\n- 对于具有形函数 $\\{N_i\\}_{i=1}^4$ 的线性四面体单元，材料梯度 $\\nabla_X N_i$ 在单元上是常数，空间梯度则通过运动学映射 $\\nabla_x N_i = F^{-\\top} \\nabla_X N_i$ 得出。\n- 共旋变换使用通过极分解 $F = R U$ 得到的旋转矩阵 $R$，其中 $U$ 是右拉伸张量。对于一个有 4 个节点且每个节点有 3 个自由度的单元，共旋变换是一个大小为 $12 \\times 12$ 的块对角矩阵 $T = \\operatorname{diag}(R, R, R, R)$。\n\n仅使用这些定义，推导并实现在两个坐标系中作为在单元体积上集成的双线性形式的单元几何刚度贡献。您的实现必须：\n1. 使用初等几何方法，从线性四面体的参考节点坐标计算其恒定的材料梯度 $\\nabla_X N_i$。\n2. 通过离散映射 $x(X) = \\sum_{i=1}^4 N_i(X) \\, x_i$ 从当前节点坐标计算变形梯度 $F$，得出 $F = \\sum_{i=1}^4 x_i \\otimes \\nabla_X N_i$。\n3. 计算 $J = \\det F$ 和当前单元体积 $v = J \\, V$，其中 $V$ 是参考单元体积。\n4. 计算空间梯度 $\\nabla_x N_i = F^{-\\top} \\nabla_X N_i$ 和Cauchy应力 $\\sigma = \\dfrac{1}{J} F S F^\\top$。\n5. 在材料坐标系和空间坐标系中组装几何刚度矩阵 $K_G$，每个都是一个 $12 \\times 12$ 的矩阵，由每个节点对的 $3 \\times 3$ 子块组成。每个子块必须是一个标量乘以 $3 \\times 3$ 的单位矩阵，该标量通过在单元域上对形函数梯度和应力的适当双线性形式进行积分得到。\n6. 计算共旋版本 $K_{G,\\text{mat}}^{\\text{cr}} = T^\\top K_{G,\\text{mat}} T$ 和 $K_{G,\\text{spa}}^{\\text{cr}} = T^\\top K_{G,\\text{spa}} T$，并通过比较它们的差异来验证其数值等效性。\n\n您的程序必须评估以下测试套件。在这三种情况下，均使用零平移的线性映射 $x = F X$，并用其材料坐标定义参考四面体。所有角度均以弧度为单位。\n\n- 情况1（带旋转的一般拉伸）：\n  - 参考节点：$X_1 = (0, 0, 0)$, $X_2 = (1, 0, 0)$, $X_3 = (0, 1, 0)$, $X_4 = (0, 0, 1)$。\n  - 绕 $z$ 轴旋转 $R_z(\\theta)$，其中 $\\theta = 0.3$，得到\n    $\n    R_z(\\theta) = \\begin{bmatrix}\n    \\cos(0.3)  -\\sin(0.3)  0 \\\\\n    \\sin(0.3)  \\cos(0.3)  0 \\\\\n    0  0  1\n    \\end{bmatrix}.\n    $\n  - 右拉伸 $U = \\operatorname{diag}(1.1, 0.9, 1.05)$，因此取 $F = R_z(\\theta) U$ 并设置 $x_i = F X_i$。\n  - 材料应力\n    $\n    S_1 = \\begin{bmatrix}\n    2.0  0.3  0.1 \\\\\n    0.3  1.5  0.2 \\\\\n    0.1  0.2  1.2\n    \\end{bmatrix}.\n    $\n\n- 情况2（纯旋转）：\n  - 参考节点：$X_1 = (0, 0, 0)$, $X_2 = (1, 0, 0)$, $X_3 = (0, 1, 0)$, $X_4 = (0, 0, 1)$。\n  - 绕 $y$ 轴旋转 $R_y(\\theta)$，其中 $\\theta = \\pi/4 \\approx 0.7853981633974483$，得到\n    $\n    R_y(\\theta) = \\begin{bmatrix}\n    \\cos(\\theta)  0  \\sin(\\theta) \\\\\n    0  1  0 \\\\\n    -\\sin(\\theta)  0  \\cos(\\theta)\n    \\end{bmatrix}.\n    $\n  - 右拉伸 $U = \\operatorname{diag}(1.0, 1.0, 1.0)$，因此取 $F = R_y(\\theta)$ 并设置 $x_i = F X_i$。\n  - 材料应力\n    $\n    S_2 = \\begin{bmatrix}\n    2.0  0.3  0.1 \\\\\n    0.3  1.5  0.2 \\\\\n    0.1  0.2  1.2\n    \\end{bmatrix}.\n    $\n\n- 情况3（近乎退化的参考，中等旋转和拉伸）：\n  - 参考节点：$X_1 = (0, 0, 0)$, $X_2 = (0.001, 0, 0)$, $X_3 = (0, 0.001, 0)$, $X_4 = (0, 0, 0.001)$。\n  - 绕 $x$ 轴旋转 $R_x(\\theta)$，其中 $\\theta = 0.2$，得到\n    $\n    R_x(\\theta) = \\begin{bmatrix}\n    1  0  0 \\\\\n    0  \\cos(0.2)  -\\sin(0.2) \\\\\n    0  \\sin(0.2)  \\cos(0.2)\n    \\end{bmatrix}.\n    $\n  - 右拉伸 $U = \\operatorname{diag}(0.8, 1.2, 1.0)$，因此取 $F = R_x(\\theta) U$ 并设置 $x_i = F X_i$。\n  - 材料应力\n    $\n    S_3 = \\begin{bmatrix}\n    1.0  0.2  0.0 \\\\\n    0.2  0.5  0.1 \\\\\n    0.0  0.1  0.8\n    \\end{bmatrix}.\n    $\n\n对于每种情况，计算相对弗罗贝尼乌斯范数误差\n$\nr = \\dfrac{\\lVert K_{G,\\text{spa}}^{\\text{cr}} - K_{G,\\text{mat}}^{\\text{cr}} \\rVert_F}{\\lVert K_{G,\\text{mat}}^{\\text{cr}} \\rVert_F},\n$\n以及一个布尔判定 $b$，如果 $r \\le 10^{-12}$ 则为 $1$，否则为 $0$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，格式为\n$\n[\\; r_1, r_2, r_3, b_1, b_2, b_3 \\;].\n$\n输出 $r_1$、$r_2$ 和 $r_3$ 必须是浮点数，$b_1$、$b_2$ 和 $b_3$ 必须是整数 $0$ 或 $1$。",
            "solution": "该问题要求验证线性共旋四面体单元几何刚度矩阵的标架无关性特性。这是通过在两个不同的参考坐标系——材料（或参考）坐标系和空间（或当前）坐标系——中，从第一性原理出发，推导和实现几何刚度矩阵 $K_G$ 来完成的。这两种表述在转换到共同的共旋坐标系后，其数值等效性将作为验证的依据。\n\n推导从问题陈述中提供的连续介质力学和有限元离散化的基本原理开始。几何刚度矩阵源于内部虚功相对于位移的线性化。对于超弹性材料，该项在材料坐标系中涉及第二类Piola-Kirchhoff应力 $S$，在空间坐标系中涉及Cauchy应力 $\\sigma$。\n\n几何刚度对总切向刚度矩阵的贡献由一个涉及应力张量和有限元形函数梯度的双线性形式给出。对于一个三维连续体单元中的节点对 $(I, J)$，几何刚度矩阵的 $3 \\times 3$ 子块是单位矩阵的一个标量倍数。\n\n在材料坐标系中，这个标量通过在参考体积 $V_0$ 上积分得到：\n$$ (K_{G, \\text{mat}})_{IJ} = \\left( \\int_{V_0} (\\nabla_X N_I)^T S (\\nabla_X N_J) dV_0 \\right) I_{3 \\times 3} $$\n其中 $\\nabla_X N_I$ 是节点 $I$ 的形函数相对于材料坐标 $X$ 的梯度，$S$ 是第二类Piola-Kirchhoff应力张量。\n\n在空间坐标系中，公式是类似的，在当前体积 $v$ 上积分：\n$$ (K_{G, \\text{spa}})_{IJ} = \\left( \\int_{v} (\\nabla_x N_I)^T \\sigma (\\nabla_x N_J) dv \\right) I_{3 \\times 3} $$\n其中 $\\nabla_x N_I$ 是相对于空间坐标 $x$ 的梯度，$\\sigma$ 是Cauchy应力张量。\n\n对于线性四面体单元，形函数梯度（$\\nabla_X N_I$ 和 $\\nabla_x N_I$）以及应力张量（$S$ 和 $\\sigma$，假设单元上应力恒定）在整个单元域内都是常数。因此，积分简化为被积函数与域体积的乘积。子块的标量系数变为：\n$$ s_{IJ}^{\\text{mat}} = V_0 \\cdot [(\\nabla_X N_I)^T S (\\nabla_X N_J)] $$\n$$ s_{IJ}^{\\text{spa}} = v \\cdot [(\\nabla_x N_I)^T \\sigma (\\nabla_x N_J)] $$\n\n这个问题的一个关键方面是验证这两种表述确实是等效的。这可以通过将基本的运动学和应力转换规则代入空间坐标系下的公式来证明：\n1.  当前单元体积：$v = J V_0$，其中 $J = \\det(F)$，$F$ 是变形梯度。\n2.  Cauchy应力前推：$\\sigma = \\frac{1}{J} F S F^T$。\n3.  形函数梯度转换：$\\nabla_x N_I = F^{-T} \\nabla_X N_I$。\n\n将这些代入 $s_{IJ}^{\\text{spa}}$ 的表达式中：\n$$ s_{IJ}^{\\text{spa}} = (J V_0) \\cdot [(F^{-T} \\nabla_X N_I)^T (\\frac{1}{J} F S F^T) (F^{-T} \\nabla_X N_J)] $$\n$$ s_{IJ}^{\\text{spa}} = (J V_0 \\frac{1}{J}) \\cdot [(\\nabla_X N_I)^T F^{-1} F S F^T F^{-T} (\\nabla_X N_J)] $$\n利用 $F^{-1} F = I$ 和 $F^T F^{-T} = I$ 的性质，表达式简化为：\n$$ s_{IJ}^{\\text{spa}} = V_0 \\cdot [(\\nabla_X N_I)^T S (\\nabla_X N_J)] = s_{IJ}^{\\text{mat}} $$\n这在代数上证明了通过材料和空间公式计算的几何刚度矩阵是相同的，即 $K_{G, \\text{mat}} = K_{G, \\text{spa}}$。因此，问题就变成了对这个恒等式的数值验证。\n\n实现过程如下：\n1.  **形函数梯度**：对于一组给定的参考节点坐标 $X_1, X_2, X_3, X_4$，计算恒定的材料梯度 $\\nabla_X N_i$ 和参考体积 $V_0$。这是通过求解从形函数属性 $N_i(X_j) = \\delta_{ij}$ 推导出的线性方程组来完成的。具体来说，如果我们构建一个 $4 \\times 4$ 矩阵 $C$，其中第 $j$ 行为 $[1, X_j^T]$，那么梯度就包含在 $C^{-1}$ 的后三行中。\n2.  **运动学和应力量**：给定变形梯度 $F$ 和SPK应力 $S$，我们计算雅可比行列式 $J$、当前体积 $v$、Cauchy应力 $\\sigma$、变形梯度的逆转置 $F^{-T}$ 以及空间梯度 $\\nabla_x N_i$。\n3.  **矩阵组装**：逐块组装 $12 \\times 12$ 的矩阵 $K_{G, \\text{mat}}$ 和 $K_{G, \\text{spa}}$。每个 $3 \\times 3$ 的块 $(I,J)$ 使用上面推导出的相应标量系数计算为 $s_{IJ} I_{3 \\times 3}$。\n4.  **共旋变换和比较**：计算极分解 $F = R U$ 以找到旋转张量 $R$。构建一个全局 $12 \\times 12$ 的旋转矩阵 $T = \\operatorname{diag}(R, R, R, R)$。将 $K_{G, \\text{mat}}$ 和 $K_{G, \\text{spa}}$ 都转换到共旋坐标系中：$K_{G,\\text{mat}}^{\\text{cr}} = T^T K_{G,\\text{mat}} T$ 和 $K_{G,\\text{spa}}^{\\text{cr}} = T^T K_{G,\\text{spa}} T$。由于理论上 $K_{G, \\text{mat}}$ 和 $K_{G, \\text{spa}}$ 是相同的，它们转换后的版本也必须相同。\n5.  **误差计算**：通过计算差异的相对弗罗贝尼乌斯范数来检查数值等效性：$r = \\lVert K_{G,\\text{spa}}^{\\text{cr}} - K_{G,\\text{mat}}^{\\text{cr}} \\rVert_F / \\lVert K_{G,\\text{mat}}^{\\text{cr}} \\rVert_F$。这个误差预计在机器精度量级。根据 $r$ 是否低于 $10^{-12}$ 的容差来赋予一个布尔判定 $b$。\n\n此程序应用于三个测试案例，涵盖了一般变形、纯旋转和近乎退化的参考几何形状，以确保实现在不同场景下的鲁棒性以及原理的验证。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import polar, det, inv, norm, block_diag\n\ndef compute_stiffness_comparison(X_nodes, F, S):\n    \"\"\"\n    Computes and compares geometric stiffness matrices for a tetrahedral element.\n\n    Args:\n        X_nodes (np.ndarray): 4x3 array of reference nodal coordinates.\n        F (np.ndarray): 3x3 deformation gradient tensor.\n        S (np.ndarray): 3x3 Second Piola-Kirchhoff stress tensor.\n\n    Returns:\n        tuple: A tuple containing the relative error (float) and the boolean verdict (int).\n    \"\"\"\n    # 1. Compute material gradients and reference volume V0\n    C = np.hstack([np.ones((4, 1)), X_nodes])\n    try:\n        G = inv(C)\n    except np.linalg.LinAlgError:\n        # Handle degenerate reference element\n        return float('inf'), 0\n    \n    # Gradients are columns of G[1:4, :].\n    # nabla_N_X_cols is a 3x4 matrix where column 'i' is the gradient of N_i.\n    nabla_N_X_cols = G[1:4, :]\n    V0 = np.abs(det(C)) / 6.0\n\n    # 2. Compute spatial quantities\n    J = det(F)\n    if J = 0:\n        # Invalid deformation (element inverted or collapsed)\n        return float('inf'), 0\n\n    v = J * V0\n    sigma = (1.0 / J) * F @ S @ F.T\n    F_inv_T = inv(F).T\n    \n    # nabla_N_x_cols is a 3x4 matrix of spatial gradients\n    nabla_N_x_cols = F_inv_T @ nabla_N_X_cols\n\n    # 3. Assemble K_G,mat\n    K_mat = np.zeros((12, 12))\n    for i in range(4):\n        for j in range(4):\n            grad_Ni = nabla_N_X_cols[:, i]\n            grad_Nj = nabla_N_X_cols[:, j]\n            s_ij = V0 * (grad_Ni.T @ S @ grad_Nj)\n            K_mat[3*i:3*(i+1), 3*j:3*(j+1)] = s_ij * np.eye(3)\n\n    # 4. Assemble K_G,spa\n    K_spa = np.zeros((12, 12))\n    for i in range(4):\n        for j in range(4):\n            grad_ni = nabla_N_x_cols[:, i]\n            grad_nj = nabla_N_x_cols[:, j]\n            t_ij = v * (grad_ni.T @ sigma @ grad_nj)\n            K_spa[3*i:3*(i+1), 3*j:3*(j+1)] = t_ij * np.eye(3)\n    \n    # 5. Co-rotational transform and compare\n    try:\n        R, _ = polar(F)\n    except np.linalg.LinAlgError:\n        return float('inf'), 0\n        \n    T = block_diag(R, R, R, R)\n    \n    K_mat_cr = T.T @ K_mat @ T\n    K_spa_cr = T.T @ K_spa @ T\n    \n    norm_mat_cr = norm(K_mat_cr, 'fro')\n    \n    if norm_mat_cr  1e-15: # Effectively a zero matrix\n        # If both matrices are zero, the error is zero.\n        # Given the proof K_mat = K_spa, if one is zero, the other must also be zero.\n        r = 0.0\n    else:\n        diff_norm = norm(K_spa_cr - K_mat_cr, 'fro')\n        r = diff_norm / norm_mat_cr\n        \n    b = 1 if r = 1e-12 else 0\n\n    return r, b\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and run the computations.\n    \"\"\"\n    # Case 1: General stretch with rotation\n    theta1 = 0.3\n    R1 = np.array([\n        [np.cos(theta1), -np.sin(theta1), 0],\n        [np.sin(theta1), np.cos(theta1), 0],\n        [0, 0, 1]\n    ])\n    U1 = np.diag([1.1, 0.9, 1.05])\n    F1 = R1 @ U1\n    S1 = np.array([\n        [2.0, 0.3, 0.1],\n        [0.3, 1.5, 0.2],\n        [0.1, 0.2, 1.2]\n    ])\n    X1_nodes = np.array([\n        [0.0, 0.0, 0.0],\n        [1.0, 0.0, 0.0],\n        [0.0, 1.0, 0.0],\n        [0.0, 0.0, 1.0]\n    ])\n    case1 = (X1_nodes, F1, S1)\n\n    # Case 2: Pure rotation\n    theta2 = np.pi / 4\n    R2 = np.array([\n        [np.cos(theta2), 0, np.sin(theta2)],\n        [0, 1, 0],\n        [-np.sin(theta2), 0, np.cos(theta2)]\n    ])\n    U2 = np.eye(3)\n    F2 = R2 @ U2\n    S2 = np.array([\n        [2.0, 0.3, 0.1],\n        [0.3, 1.5, 0.2],\n        [0.1, 0.2, 1.2]\n    ])\n    X2_nodes = X1_nodes # Same reference geometry\n    case2 = (X2_nodes, F2, S2)\n\n    # Case 3: Nearly degenerate reference, moderate rotation and stretch\n    theta3 = 0.2\n    R3 = np.array([\n        [1, 0, 0],\n        [0, np.cos(theta3), -np.sin(theta3)],\n        [0, np.sin(theta3), np.cos(theta3)]\n    ])\n    U3 = np.diag([0.8, 1.2, 1.0])\n    F3 = R3 @ U3\n    S3 = np.array([\n        [1.0, 0.2, 0.0],\n        [0.2, 0.5, 0.1],\n        [0.0, 0.1, 0.8]\n    ])\n    X3_nodes = np.array([\n        [0.0, 0.0, 0.0],\n        [0.001, 0.0, 0.0],\n        [0.0, 0.001, 0.0],\n        [0.0, 0.0, 0.001]\n    ])\n    case3 = (X3_nodes, F3, S3)\n    \n    test_cases = [case1, case2, case3]\n    \n    r_values = []\n    b_values = []\n    for case_data in test_cases:\n        r, b = compute_stiffness_comparison(*case_data)\n        r_values.append(r)\n        b_values.append(b)\n        \n    all_results = r_values + b_values\n    \n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n\n```"
        }
    ]
}