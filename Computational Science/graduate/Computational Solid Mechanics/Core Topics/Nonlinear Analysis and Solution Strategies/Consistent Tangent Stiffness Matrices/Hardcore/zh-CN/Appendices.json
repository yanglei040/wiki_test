{
    "hands_on_practices": [
        {
            "introduction": "掌握一致性切线的第一步是从基本力学原理出发，亲手推导它。本练习将引导你对一个包含材料和几何非线性的简单一维杆单元的虚功原理弱形式进行线性化。通过这个实践()，你将建立起系统地将Gâteaux导数应用于内力矢量，从而获得一致性切线刚度矩阵的基础技能。",
            "id": "2538124",
            "problem": "考虑一个长度为 $L$ 的一维双节点线性杆有限元，其参考域为 $x \\in [0,L]$，位移场 $u(x)$ 由标准线性插值 $u(x) = N_{1}(x)\\,u_{1} + N_{2}(x)\\,u_{2}$ 近似，其中 $N_{1}(x) = 1 - x/L$ 且 $N_{2}(x) = x/L$。横截面积呈线性变化，其表达式为 $A(x) = A_{0}\\left(1 + \\beta \\frac{x}{L}\\right)$，其中 $A_{0} > 0$ 和实数 $\\beta$ 为给定常数。该杆由一种具有非线性本构律 $\\sigma = \\sigma(\\epsilon)$ 的材料制成，其中工程应变为 $\\epsilon(x) = \\frac{du}{dx}$。对于本问题，取 $\\sigma(\\epsilon) = E\\,\\epsilon + \\alpha\\,\\epsilon^{3}$，其中 $E > 0$ 和实数 $\\alpha$ 为给定常数。\n\n从虚功原理和有限元方法（FEM）中单元内力向量的定义出发，围绕一个任意的试探状态 $u^{t}(x) = N_{1}(x)\\,u_{1}^{t} + N_{2}(x)\\,u_{2}^{t}$（其节点值 $u_{1}^{t}$ 和 $u_{2}^{t}$ 已知）对弱形式进行一致性线性化。推导在该试探状态下计算的单元一致性切线刚度矩阵。使用单元应变-位移矩阵 $B = \\left[-\\frac{1}{L}\\ \\ \\frac{1}{L}\\right]$，将你的结果完全用 $A_{0}$、$\\beta$、$L$、$E$、$\\alpha$、$u_{1}^{t}$ 和 $u_{2}^{t}$ 表示。\n\n你的最终答案必须是在试探状态下计算的闭合形式的 $2 \\times 2$ 切线刚度矩阵，并写成单个符号表达式。最终答案中不应包含单位。",
            "solution": "所述问题具有科学依据，是适定的且自洽的。它是在非线性有限元分析中一个标准但并非不重要的练习。所有提供的信息都是一致且足以推导出所要求的量。因此，该问题是有效的。我们现在开始推导。\n\n非线性有限元问题公式化的出发点是虚功原理（PVW）。平衡状态要求对于任何任意的运动学容许的虚位移，内虚功 $\\delta W_{int}$ 等于外虚功 $\\delta W_{ext}$。我们关心的是内力和切线刚度，因此我们关注内虚功。对于一维杆，$\\delta W_{int}$ 由应力 $\\sigma$ 在整个单元体积上对虚应变 $\\delta\\epsilon$ 作用的积分给出：\n$$\n\\delta W_{int} = \\int_{V} \\sigma \\delta\\epsilon \\, dV = \\int_{0}^{L} \\sigma(x) A(x) \\delta\\epsilon(x) \\, dx\n$$\n这里，$A(x)$ 是横截面积，$L$ 是单元长度，$\\sigma$ 和 $\\epsilon$ 分别是工程应力和工程应变。\n\n位移场 $u(x)$ 使用线性形函数 $N_1(x)$ 和 $N_2(x)$ 以及节点位移 $u_1$ 和 $u_2$ 进行近似。用矩阵表示法，我们将位移向量写为 $\\mathbf{u}_{e} = \\begin{pmatrix} u_1  u_2 \\end{pmatrix}^T$，位移场表示为：\n$$\nu(x) = \\mathbf{N}(x) \\mathbf{u}_{e} = \\begin{pmatrix} N_1(x)  N_2(x) \\end{pmatrix} \\mathbf{u}_{e}\n$$\n应变 $\\epsilon(x)$ 是位移的空间导数：\n$$\n\\epsilon(x) = \\frac{du}{dx} = \\frac{d\\mathbf{N}}{dx} \\mathbf{u}_{e} = \\mathbf{B} \\mathbf{u}_{e}\n$$\n其中 $\\mathbf{B}$ 是应变-位移矩阵。对于给定的线性形函数 $N_{1}(x) = 1 - x/L$ 和 $N_{2}(x) = x/L$，其导数为常数：$\\frac{dN_1}{dx} = -\\frac{1}{L}$ 和 $\\frac{dN_2}{dx} = \\frac{1}{L}$。因此，$\\mathbf{B}$ 是一个常数矩阵：\n$$\n\\mathbf{B} = \\begin{pmatrix} -\\frac{1}{L}  \\frac{1}{L} \\end{pmatrix}\n$$\n由于 $\\mathbf{B}$ 是常数，对于任何给定的 $\\mathbf{u}_e$，应变 $\\epsilon$ 在整个单元内也是常数。\n\n虚应变 $\\delta\\epsilon$ 通过相同的矩阵 $\\mathbf{B}$ 与虚节点位移 $\\delta\\mathbf{u}_e$ 相关联：\n$$\n\\delta\\epsilon(x) = \\mathbf{B} \\delta\\mathbf{u}_{e}\n$$\n将 $\\sigma$ 和 $\\delta\\epsilon$ 的离散化形式代入 PVW 表达式：\n$$\n\\delta W_{int} = \\int_{0}^{L} \\sigma(\\mathbf{B}\\mathbf{u}_{e}) A(x) (\\mathbf{B} \\delta\\mathbf{u}_{e}) \\, dx = \\delta\\mathbf{u}_{e}^T \\left( \\int_{0}^{L} \\mathbf{B}^T \\sigma(\\mathbf{B}\\mathbf{u}_{e}) A(x) \\, dx \\right)\n$$\n从 PVW，$\\delta W_{int} = \\delta\\mathbf{u}_{e}^T \\mathbf{f}_{int}$，我们识别出单元内力向量 $\\mathbf{f}_{int}$：\n$$\n\\mathbf{f}_{int}(\\mathbf{u}_{e}) = \\int_{0}^{L} \\mathbf{B}^T \\sigma(\\mathbf{B}\\mathbf{u}_{e}) A(x) \\, dx\n$$\n单元一致性切线刚度矩阵 $\\mathbf{K}_T$ 定义为内力向量关于节点位移向量的 Gâteaux 导数：\n$$\n\\mathbf{K}_T = \\frac{d\\mathbf{f}_{int}}{d\\mathbf{u}_e}\n$$\n执行此微分：\n$$\nd\\mathbf{f}_{int} = \\int_{0}^{L} \\mathbf{B}^T d\\sigma A(x) \\, dx\n$$\n应力微分 $d\\sigma$ 通过切线模量 $E_T = \\frac{d\\sigma}{d\\epsilon}$ 与应变微分 $d\\epsilon$ 相关。\n$$\nd\\sigma = E_T(\\epsilon) d\\epsilon = E_T(\\epsilon) \\mathbf{B} d\\mathbf{u}_e\n$$\n将此代入 $d\\mathbf{f}_{int}$ 的表达式：\n$$\nd\\mathbf{f}_{int} = \\int_{0}^{L} \\mathbf{B}^T E_T(\\epsilon) \\mathbf{B} d\\mathbf{u}_e A(x) \\, dx = \\left( \\int_{0}^{L} \\mathbf{B}^T E_T(\\epsilon) \\mathbf{B} A(x) \\, dx \\right) d\\mathbf{u}_e\n$$\n因此，切线刚度矩阵为：\n$$\n\\mathbf{K}_T(\\mathbf{u}_e) = \\int_{0}^{L} \\mathbf{B}^T E_T(\\epsilon) \\mathbf{B} A(x) \\, dx\n$$\n问题要求在给定的试探状态 $\\mathbf{u}_{e}^t = \\begin{pmatrix} u_1^t  u_2^t \\end{pmatrix}^T$ 下计算 $\\mathbf{K}_T$。此状态下的应变 $\\epsilon^t$ 是常数：\n$$\n\\epsilon^t = \\mathbf{B} \\mathbf{u}_{e}^t = \\begin{pmatrix} -\\frac{1}{L}  \\frac{1}{L} \\end{pmatrix} \\begin{pmatrix} u_1^t \\\\ u_2^t \\end{pmatrix} = \\frac{u_2^t - u_1^t}{L}\n$$\n非线性本构律为 $\\sigma(\\epsilon) = E\\,\\epsilon + \\alpha\\,\\epsilon^3$。切线模量 $E_T$ 是其对应变的导数：\n$$\nE_T(\\epsilon) = \\frac{d\\sigma}{d\\epsilon} = E + 3\\alpha\\,\\epsilon^2\n$$\n在试探应变 $\\epsilon^t$ 下计算该值：\n$$\nE_T(\\epsilon^t) = E + 3\\alpha (\\epsilon^t)^2 = E + 3\\alpha \\left( \\frac{u_2^t - u_1^t}{L} \\right)^2\n$$\n由于 $\\mathbf{B}$ 和 $E_T(\\epsilon^t)$ 相对于积分变量 $x$ 是常数，我们可以将它们移到 $\\mathbf{K}_T$ 的积分号外：\n$$\n\\mathbf{K}_T(\\mathbf{u}_{e}^t) = \\mathbf{B}^T E_T(\\epsilon^t) \\mathbf{B} \\int_{0}^{L} A(x) \\, dx\n$$\n接下来，我们计算面积函数 $A(x) = A_{0}\\left(1 + \\beta \\frac{x}{L}\\right)$ 的积分：\n$$\n\\int_{0}^{L} A(x) \\, dx = \\int_{0}^{L} A_0 \\left( 1 + \\beta \\frac{x}{L} \\right) dx = A_0 \\left[ x + \\frac{\\beta x^2}{2L} \\right]_{0}^{L} = A_0 \\left( L + \\frac{\\beta L^2}{2L} \\right) = A_0 L \\left( 1 + \\frac{\\beta}{2} \\right)\n$$\n矩阵乘积 $\\mathbf{B}^T \\mathbf{B}$ 为：\n$$\n\\mathbf{B}^T \\mathbf{B} = \\begin{pmatrix} -1/L \\\\ 1/L \\end{pmatrix} \\begin{pmatrix} -1/L  1/L \\end{pmatrix} = \\begin{pmatrix} 1/L^2  -1/L^2 \\\\ -1/L^2  1/L^2 \\end{pmatrix} = \\frac{1}{L^2} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix}\n$$\n现在，我们组合所有分量：\n$$\n\\mathbf{K}_T(\\mathbf{u}_{e}^t) = \\frac{1}{L^2} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix} \\left( E + 3\\alpha \\frac{(u_2^t - u_1^t)^2}{L^2} \\right) \\left( A_0 L \\left( 1 + \\frac{\\beta}{2} \\right) \\right)\n$$\n合并标量项，我们得到一致性切线刚度矩阵的最终表达式：\n$$\n\\mathbf{K}_T = \\frac{A_0}{L} \\left( 1 + \\frac{\\beta}{2} \\right) \\left( E + 3\\alpha \\frac{(u_2^t - u_1^t)^2}{L^2} \\right) \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix}\n$$\n为了将答案表示为单个矩阵，我们将标量系数定义为：\n$$\nC = \\frac{A_0}{L} \\left( 1 + \\frac{\\beta}{2} \\right) \\left( E + 3\\alpha \\frac{(u_2^t - u_1^t)^2}{L^2} \\right)\n$$\n那么切线刚度矩阵为 $\\mathbf{K}_T = \\begin{pmatrix} C  -C \\\\ -C  C \\end{pmatrix}$。这就是所求的结果。",
            "answer": "$$\n\\boxed{\n\\frac{A_0}{L} \\left( 1 + \\frac{\\beta}{2} \\right) \\left( E + 3\\alpha \\frac{(u_2^t - u_1^t)^2}{L^2} \\right)\n\\begin{pmatrix}\n1  -1 \\\\\n-1  1\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "在推导并编程实现了一致性切线矩阵后，验证其正确性是至关重要的一步。本练习()介绍了一种在有限元代码开发中标准且不可或缺的技术：有限差分检验。通过将解析推导的切线与数值近似进行比较，你不仅可以验证自己实现的正确性，还能深入体会到数值计算中的精妙之处，例如如何平衡截断误差和舍入误差。",
            "id": "3552137",
            "problem": "考虑一个一维双节点杆单元，其具有两个位移自由度，并集中在向量 $\\mathbf{u} = [u_1,u_2]^T$ 中。该单元具有恒定的横截面积 $A > 0$、长度 $L > 0$ 和一个非线性本构关系，该关系将柯西应力 $\\sigma$ 与工程应变 $\\varepsilon$ 联系起来，其表达式为 $\\sigma(\\varepsilon) = E\\,\\varepsilon + \\beta\\,\\varepsilon^3$，其中 $E > 0$ 是线性模量，$\\beta \\ge 0$ 是非线性系数。使用线性形函数，工程应变为 $\\varepsilon = (u_2 - u_1)/L$。内残差向量 $\\mathbf{R}(\\mathbf{u})$ 源于虚功原理，定义为应力通过应变-位移矩阵投影后在单元上的积分。在此设定下，您可以假设残差有两个分量 $R_1(\\mathbf{u})$ 和 $R_2(\\mathbf{u})$，由具有给定本构律的杆单元的力学行为确定。\n\n目标是设计并实现对一致切向刚度矩阵 $\\mathbf{K}(\\mathbf{u}) = \\partial \\mathbf{R}/\\partial \\mathbf{u}$ 的有限差分检验，使用中心差分近似\n$$\nK_{ij}^{\\mathrm{FD}}(\\mathbf{u};\\epsilon) \\approx \\frac{R_i(\\mathbf{u} + \\epsilon\\,\\mathbf{e}_j) - R_i(\\mathbf{u} - \\epsilon\\,\\mathbf{e}_j)}{2\\,\\epsilon},\n$$\n其中 $\\epsilon > 0$ 是一个标量扰动大小，$i,j \\in \\{1,2\\}$，$\\mathbf{e}_j$ 是 $\\mathbb{R}^2$ 中的第 $j$ 个标准单位向量。您还必须从提供的基本定义出发，通过对 $\\mathbf{R}(\\mathbf{u})$ 关于 $\\mathbf{u}$求导来计算精确的一致切向刚度 $\\mathbf{K}(\\mathbf{u})$，并通过报告相对弗罗贝尼乌斯范数误差来比较 $\\mathbf{K}^{\\mathrm{FD}}$ 和 $\\mathbf{K}$\n$$\n\\eta(\\epsilon,\\mathbf{u}) = \\frac{\\left\\|\\mathbf{K}^{\\mathrm{FD}}(\\mathbf{u};\\epsilon) - \\mathbf{K}(\\mathbf{u})\\right\\|_F}{\\left\\|\\mathbf{K}(\\mathbf{u})\\right\\|_F}.\n$$\n\n您的程序必须为所描述的杆单元实现残差 $\\mathbf{R}(\\mathbf{u})$ 和从第一性原理推导出的精确一致切向刚度 $\\mathbf{K}(\\mathbf{u})$。然后，对于下面列出的每个测试用例，程序必须计算有限差分近似 $\\mathbf{K}^{\\mathrm{FD}}(\\mathbf{u};\\epsilon)$，评估相对误差 $\\eta(\\epsilon,\\mathbf{u})$，并汇总结果。\n\n对所有测试使用以下材料和几何参数：$A = 1.0$, $L = 1.0$, $E = 10.0$, $\\beta = 5.0$。将所有量视为无量纲；输出中不需要物理单位。\n\n测试套件：\n1. 一个用于在中等扰动下验证精度的通用情况：$\\mathbf{u} = [0.2,\\,0.8]^T$, $\\epsilon = 10^{-6}$。\n2. 一个具有极小扰动的舍入误差敏感情况：$\\mathbf{u} = [0.2,\\,0.8]^T$, $\\epsilon = 10^{-12}$。\n3. 一个具有大扰动的截断误差主导情况：$\\mathbf{u} = [0.2,\\,0.8]^T$, $\\epsilon = 10^{-2}$。\n4. 一个近零应变的边界情况：$\\mathbf{u} = [10^{-12},\\,-10^{-12}]^T$, $\\epsilon = 10^{-6}$。\n5. 一个使用与机器精度相关的推荐中心差分缩放的情况：$\\mathbf{u} = [0.2,\\,0.8]^T$, $\\epsilon = \\varepsilon_{\\mathrm{mach}}^{1/3}$，其中 $\\varepsilon_{\\mathrm{mach}}$ 是双精度浮点运算的机器精度。\n\n您的程序应生成单行输出，其中包含五个测试用例的相对误差 $\\eta$，格式为方括号内以逗号分隔的列表（例如，“[e1,e2,e3,e4,e5]”），其中每个 $e_k$ 是一个十进制数。",
            "solution": "问题陈述经评估有效。它在科学上基于计算固体力学的原理，包含了所有必要信息，没有矛盾，并且是适定的，容许唯一且有意义的解。\n\n主要目标是通过中心有限差分法，将解析推导的一致切向刚度矩阵 $\\mathbf{K}(\\mathbf{u})$ 与其数值近似 $\\mathbf{K}^{\\mathrm{FD}}(\\mathbf{u};\\epsilon)$ 进行验证。该验证通过相对弗罗贝尼乌斯范数误差 $\\eta$ 来量化。\n\n首先，我们推导内残差向量 $\\mathbf{R}(\\mathbf{u})$ 和一致切向刚度矩阵 $\\mathbf{K}(\\mathbf{u})$ 的解析表达式。推导从虚功原理开始。对于一维杆单元，内虚功 $\\delta W_{\\text{int}}$ 由应力 $\\sigma$ 乘以虚应变 $\\delta\\varepsilon$ 的体积分给出：\n$$\n\\delta W_{\\text{int}} = \\int_{V} \\sigma \\, \\delta\\varepsilon \\, dV\n$$\n给定恒定的横截面积 $A$ 和单元长度 $L$，并假设线性形函数导致单元内应变场恒定，该积分简化为：\n$$\n\\delta W_{\\text{int}} = \\sigma A L \\, \\delta\\varepsilon\n$$\n工程应变 $\\varepsilon$ 通过应变-位移矩阵 $\\mathbf{B}$ 与节点位移向量 $\\mathbf{u} = [u_1, u_2]^T$ 相关：\n$$\n\\varepsilon = \\frac{u_2 - u_1}{L} = \\begin{bmatrix} -1/L  1/L \\end{bmatrix} \\begin{bmatrix} u_1 \\\\ u_2 \\end{bmatrix} = \\mathbf{B}\\mathbf{u}\n$$\n虚应变则为 $\\delta\\varepsilon = \\mathbf{B}\\delta\\mathbf{u}$。将其代入虚功表达式得到：\n$$\n\\delta W_{\\text{int}} = \\sigma A L (\\mathbf{B}\\delta\\mathbf{u}) = (\\sigma A L \\mathbf{B}) \\delta\\mathbf{u}\n$$\n内虚功也通过内残差向量 $\\mathbf{R}$ 定义为 $\\delta W_{\\text{int}} = \\mathbf{R}^T \\delta\\mathbf{u}$。通过比较这两个表达式，我们确定残差向量：\n$$\n\\mathbf{R}(\\mathbf{u})^T = \\sigma A L \\mathbf{B} \\implies \\mathbf{R}(\\mathbf{u}) = \\mathbf{B}^T \\sigma A L\n$$\n代入 $\\mathbf{B}$ 的表达式和给定的本构关系 $\\sigma(\\varepsilon) = E\\varepsilon + \\beta\\varepsilon^3$：\n$$\n\\mathbf{R}(\\mathbf{u}) = \\begin{bmatrix} -1/L \\\\ 1/L \\end{bmatrix} \\left( E\\varepsilon + \\beta\\varepsilon^3 \\right) A L = A \\left( E\\varepsilon + \\beta\\varepsilon^3 \\right) \\begin{bmatrix} -1 \\\\ 1 \\end{bmatrix}\n$$\n该表达式定义了节点处的内力，正如预期的那样，它们大小相等，方向相反。\n\n接下来，我们通过对残差向量 $\\mathbf{R}(\\mathbf{u})$ 关于位移向量 $\\mathbf{u}$ 求导来推导一致切向刚度矩阵 $\\mathbf{K}(\\mathbf{u})$：\n$$\n\\mathbf{K}(\\mathbf{u}) = \\frac{\\partial \\mathbf{R}(\\mathbf{u})}{\\partial \\mathbf{u}}\n$$\n使用链式法则，以及 $\\sigma$ 是 $\\varepsilon$ 的函数，而 $\\varepsilon$ 又是 $\\mathbf{u}$ 的函数这一事实：\n$$\n\\mathbf{K}(\\mathbf{u}) = \\frac{\\partial \\mathbf{R}}{\\partial \\varepsilon} \\frac{\\partial \\varepsilon}{\\partial \\mathbf{u}} = \\left( \\frac{\\partial}{\\partial \\varepsilon} \\left[ \\mathbf{B}^T \\sigma(\\varepsilon) A L \\right] \\right) (\\mathbf{B}) = \\mathbf{B}^T \\frac{d\\sigma}{d\\varepsilon} \\mathbf{B} A L\n$$\n应力对应变的导数 $\\frac{d\\sigma}{d\\varepsilon}$ 是材料切向模量 $E_t$：\n$$\nE_t = \\frac{d\\sigma}{d\\varepsilon} = \\frac{d}{d\\varepsilon}\\left(E\\varepsilon + \\beta\\varepsilon^3\\right) = E + 3\\beta\\varepsilon^2\n$$\n将 $E_t$ 和 $\\mathbf{B}$ 代入 $\\mathbf{K}$ 的表达式中：\n$$\n\\mathbf{K}(\\mathbf{u}) = \\begin{bmatrix} -1/L \\\\ 1/L \\end{bmatrix} (E + 3\\beta\\varepsilon^2) \\begin{bmatrix} -1/L  1/L \\end{bmatrix} A L = \\frac{AL}{L^2}(E + 3\\beta\\varepsilon^2) \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix}\n$$\n这简化为一致切向刚度矩阵的最终解析表达式：\n$$\n\\mathbf{K}(\\mathbf{u}) = \\frac{A}{L} \\left( E + 3\\beta\\left(\\frac{u_2 - u_1}{L}\\right)^2 \\right) \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix}\n$$\n问题要求使用中心差分公式计算数值近似值 $\\mathbf{K}^{\\mathrm{FD}}$：\n$$\nK_{ij}^{\\mathrm{FD}}(\\mathbf{u};\\epsilon) = \\frac{R_i(\\mathbf{u} + \\epsilon\\,\\mathbf{e}_j) - R_i(\\mathbf{u} - \\epsilon\\,\\mathbf{e}_j)}{2\\,\\epsilon}\n$$\n这里，$\\mathbf{e}_1 = [1,0]^T$ 和 $\\mathbf{e}_2 = [0,1]^T$ 是标准基向量。此公式应用于矩阵的每一列 $j$。\n\n最后，使用弗罗贝尼乌斯范数（表示为 $\\|\\cdot\\|_F$）计算相对误差 $\\eta$，对于矩阵 $\\mathbf{M}$，其定义为 $\\|\\mathbf{M}\\|_F = \\sqrt{\\sum_i \\sum_j M_{ij}^2}$。误差为：\n$$\n\\eta(\\epsilon,\\mathbf{u}) = \\frac{\\left\\|\\mathbf{K}^{\\mathrm{FD}}(\\mathbf{u};\\epsilon) - \\mathbf{K}(\\mathbf{u})\\right\\|_F}{\\left\\|\\mathbf{K}(\\mathbf{u})\\right\\|_F}\n$$\n实现将包括计算 $\\mathbf{R}(\\mathbf{u})$、$\\mathbf{K}(\\mathbf{u})$ 和 $\\mathbf{K}^{\\mathrm{FD}}(\\mathbf{u};\\epsilon)$ 的函数，然后为五个指定的测试用例中的每一个评估 $\\eta$。第五种情况需要双精度浮点数的机器ε（$\\varepsilon_{\\mathrm{mach}}$），它是满足 $1.0 + \\varepsilon_{\\mathrm{mach}} \\ne 1.0$ 的最小数。中心差分方案的最佳扰动通常与 $\\varepsilon_{\\mathrm{mach}}^{1/3}$ 相关。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Computes and compares analytical and finite-difference tangent stiffness matrices\n    for a nonlinear 1D bar element.\n    \"\"\"\n\n    # Define material and geometric parameters\n    A = 1.0  # Cross-sectional area\n    L = 1.0  # Length\n    E = 10.0 # Linear modulus\n    beta = 5.0 # Nonlinear coefficient\n\n    def residual(u, A, L, E, beta):\n        \"\"\"\n        Computes the internal residual vector R(u) for the bar element.\n        R(u) = A * sigma(epsilon) * [-1, 1]^T\n        \"\"\"\n        if not isinstance(u, np.ndarray):\n            u = np.array(u, dtype=float)\n        \n        strain = (u[1] - u[0]) / L\n        stress = E * strain + beta * strain**3\n        internal_force = A * stress\n        return np.array([-internal_force, internal_force])\n\n    def exact_stiffness(u, A, L, E, beta):\n        \"\"\"\n        Computes the exact consistent tangent stiffness matrix K(u).\n        K(u) = (A/L) * (E + 3*beta*epsilon^2) * [[1, -1], [-1, 1]]\n        \"\"\"\n        if not isinstance(u, np.ndarray):\n            u = np.array(u, dtype=float)\n            \n        strain = (u[1] - u[0]) / L\n        tangent_modulus = E + 3.0 * beta * strain**2\n        factor = (A / L) * tangent_modulus\n        return factor * np.array([[1.0, -1.0], [-1.0, 1.0]])\n\n    def fd_stiffness(u, eps, A, L, E, beta):\n        \"\"\"\n        Computes the finite-difference approximation of the tangent stiffness matrix.\n        \"\"\"\n        if not isinstance(u, np.ndarray):\n            u = np.array(u, dtype=float)\n            \n        K_fd = np.zeros((2, 2))\n        e_vecs = [np.array([1.0, 0.0]), np.array([0.0, 1.0])]\n        \n        for j in range(2):\n            u_plus = u + eps * e_vecs[j]\n            u_minus = u - eps * e_vecs[j]\n            \n            R_plus = residual(u_plus, A, L, E, beta)\n            R_minus = residual(u_minus, A, L, E, beta)\n            \n            K_fd[:, j] = (R_plus - R_minus) / (2.0 * eps)\n            \n        return K_fd\n\n    def relative_error(K_fd, K_exact):\n        \"\"\"\n        Computes the relative Frobenius norm error between two matrices.\n        \"\"\"\n        diff_norm = np.linalg.norm(K_fd - K_exact, 'fro')\n        exact_norm = np.linalg.norm(K_exact, 'fro')\n        \n        # Handle case where the exact norm is zero\n        if exact_norm == 0:\n            return 0.0 if diff_norm == 0 else np.inf\n            \n        return diff_norm / exact_norm\n\n    # Machine epsilon for double precision\n    eps_mach = np.finfo(float).eps\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # 1. General case\n        {'u': np.array([0.2, 0.8]), 'eps': 1e-6},\n        # 2. Round-off sensitive case\n        {'u': np.array([0.2, 0.8]), 'eps': 1e-12},\n        # 3. Truncation-error dominated case\n        {'u': np.array([0.2, 0.8]), 'eps': 1e-2},\n        # 4. Near-zero-strain edge case\n        {'u': np.array([1e-12, -1e-12]), 'eps': 1e-6},\n        # 5. Optimal perturbation case\n        {'u': np.array([0.2, 0.8]), 'eps': eps_mach**(1/3.0)}\n    ]\n\n    results = []\n    for case in test_cases:\n        u_vec = case['u']\n        epsilon = case['eps']\n        \n        # Compute the exact and finite-difference matrices\n        K_exact = exact_stiffness(u_vec, A, L, E, beta)\n        K_fd = fd_stiffness(u_vec, epsilon, A, L, E, beta)\n        \n        # Compute and store the relative error\n        error = relative_error(K_fd, K_exact)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "推导和实现一个*一致性*切线矩阵的努力最终会在非线性求解器的性能上得到回报。最后一个练习()将展示在线搜索修正的牛顿法中，使用一致性切线与非一致性切线的实际效果差异。通过一个精心设计的算例，你将观察到一致性切线如何确保牛顿法的二次收敛性，从而最大限度地减少回溯搜索的次数，最终实现一个更高效、更稳健的求解器。",
            "id": "3552105",
            "problem": "考虑一个单自由度平衡问题，该问题代表一维线性离散杆，其本构响应为光滑软化型且在应力上保持单调。设位移为未知标量 $u$，工程应变为 $\\varepsilon = u$，柯西应力由非线性本构函数 $\\sigma(\\varepsilon) = \\dfrac{E\\,\\varepsilon}{1 + \\alpha\\,\\varepsilon}$ 给出，其中 $E > 0$ 是一个模量，$\\alpha \\ge 0$ 控制随应变增加的刚度退化。假设始终使用无量纲单位，其中 $A = 1$、$L = 1$ 和 $E = 1$，因此不需要进行物理单位转换。外荷载为标量 $P \\ge 0$，在每个荷载步需要求解的残差方程为 $R(u;P) = \\sigma(u) - P = 0$。\n\n您的任务是基于最小化标量评价函数 $\\phi(u) = \\tfrac{1}{2}\\,R(u;P)^2$，并使用Armijo充分下降回溯准则，为该平衡方程实现一种线搜索修正牛顿法。在迭代点 $u_k$ 处的牛顿搜索方向必须通过线性化方程 $K(u_k)\\,\\Delta u_k = -R(u_k;P)$ 计算，其中 $K(u_k)$ 是切线刚度，试探更新为 $u_{k+1}^{\\text{trial}} = u_k + \\alpha_k\\,\\Delta u_k$，其中回溯参数 $\\alpha_k \\in (0,1]$ 的选择需满足关于 $\\phi$ 的Armijo充分下降条件。\n\n您必须：\n- 推导并实现精确的一致切线刚度 $K_{\\text{cons}}(u) = \\dfrac{dR}{du}(u)$，该刚度由残差 $R(u;P)$ 和给定的本构律推导得出。\n- 实现一个不一致切线模型 $K_{\\text{inc}}(u) = s\\,K_{\\text{cons}}(u)$，其中 $s \\in (0,1]$ 是一个预设标量，用于人为地扰动真实切线。这模拟了实践中算法不一致性的一个常见来源。\n- 实现基于评价函数 $\\phi(u)$ 的、采用Armijo充分下降准则的线搜索修正牛顿法，使用标准参数 $c_1 \\in (0,1)$ 和回溯因子 $\\beta \\in (0,1)$。使用 $c_1 = 10^{-4}$ 和 $\\beta = 1/2$。每个荷载步从上一步的收敛解 $u$ 开始，并在每次迭代时以 $\\alpha_k = 1$ 初始化线搜索。\n- 对于每个荷载步，一旦 $|R(u;P)| \\le \\text{tol}$（其中 $\\text{tol} = 10^{-12}$），则终止牛顿迭代。每个荷载步最多进行50次牛顿迭代，每次迭代最多进行20次回溯缩减。\n- 在整个加载路径上记录两个指标：回溯缩减的总次数（即，在接受一步之前 $\\alpha$ 乘以 $\\beta$ 的次数），以及定义为在整个加载路径上步长 $\\alpha < 1$ 的被接受更新次数与总被接受更新次数之比的拒绝频率。两个指标都是无量纲的。\n\n使用荷载控制过程，外荷载从 $P = 0$ 以 $N_{\\text{inc}}$ 个等量增量线性增加到指定的 $P_{\\max}$。使用前一个收敛解作为下一个荷载步的初始猜测。非线性应力模型是单调的，但其切线刚度随着 $\\alpha$ 的增加而沿路径减小，这提供了不失单调性的软化型响应。此设置旨在揭示一致切线与不一致切线对线搜索行为的影响。\n\n测试套件。为以下四种情况运行求解器，每种情况由元组 $(\\alpha, P_{\\max}, N_{\\text{inc}}, s)$ 指定：\n- 情况A（一致切线，软化路径）：$(10.0, 0.09, 5, 1.0)$。\n- 情况B（不一致，中等扰动）：$(10.0, 0.09, 5, 0.5)$。\n- 情况C（不一致，严重扰动）：$(10.0, 0.09, 5, 0.1)$。\n- 情况D（较温和软化，不一致）：$(3.0, 0.25, 5, 0.5)$。\n\n所有量均为无量纲；答案中无需物理单位。您的程序必须输出一行，其中包含用方括号括起来的逗号分隔列表形式的结果，按以下顺序汇总指标：$[\\text{backtracks}_A,\\text{rejection\\_freq}_A,\\text{backtracks}_B,\\text{rejection\\_freq}_B,\\text{backtracks}_C,\\text{rejection\\_freq}_C,\\text{backtracks}_D,\\text{rejection\\_freq}_D]$，其中每个 $\\text{rejection\\_freq}$ 必须打印为保留小数点后六位的小数，每个 $\\text{backtracks}$ 都是一个整数。例如，要求的格式是 $[\\text{bA},\\text{fA},\\text{bB},\\text{fB},\\text{bC},\\text{fC},\\text{bD},\\text{fD}]$。\n\n正确性标准如下：\n- 一致切线 $K_{\\text{cons}}$ 必须从第一性原理针对给定的本构模型推导得出。\n- 线搜索Armijo准则必须在评价函数 $\\phi(u)$ 上实现，并使用由 $R$ 的真实雅可比矩阵所隐含的方向导数。\n- 报告的指标必须反映每种情况下整个加载路径上的回溯缩减总次数和拒绝频率。",
            "solution": "用户要求实现一种线搜索修正牛顿法，以求解一个单自由度非线性平衡问题。核心任务是比较在使用一致切线刚度与不一致切线刚度时求解器的性能。性能通过线搜索过程中的回溯缩减次数和步长拒绝频率来衡量。\n\n首先验证该问题是科学上合理的、适定的和客观的。它代表了计算固体力学中的一个标准问题，并以足够的细节和一致性进行规定，以得到一个唯一的、可验证的解。\n\n一维杆的平衡由以下非线性标量方程控制：\n$$\nR(u; P) = \\sigma(u) - P = 0\n$$\n其中 $u$ 是位移，$P$ 是施加的外荷载，$\\sigma(u)$ 是由非线性本构律给出的应力。工程应变为 $\\varepsilon = u$，材料模量为 $E=1$，则应力函数为：\n$$\n\\sigma(u) = \\frac{u}{1 + \\alpha u}\n$$\n这里，$\\alpha \\ge 0$ 是一个控制材料软化响应的参数。因此，残差方程为：\n$$\nR(u; P) = \\frac{u}{1 + \\alpha u} - P = 0\n$$\n\n解是使用牛顿-拉夫逊迭代格式找到的。给定第 $k$ 次迭代的估计值 $u_k$，寻求一个更好的估计值 $u_{k+1} = u_k + \\Delta u_k$。修正量 $\\Delta u_k$ 通过求解线性化系统得到：\n$$\nK(u_k) \\Delta u_k = -R(u_k; P)\n$$\n其中 $K(u_k)$ 是在 $u_k$ 处的切线刚度矩阵（在本例中为标量）。\n\n牛顿法二次收敛速度的一个关键方面是使用**一致切线刚度**，即残差相对于未知量的精确导数。我们推导如下：\n$$\nK_{\\text{cons}}(u) = \\frac{d R(u; P)}{d u} = \\frac{d}{d u} \\left( \\frac{u}{1 + \\alpha u} \\right)\n$$\n使用除法求导法则 $(\\frac{f}{g})' = \\frac{f'g - fg'}{g^2}$，其中 $f(u) = u$ 且 $g(u) = 1 + \\alpha u$，我们得到 $f'(u)=1$ 和 $g'(u)=\\alpha$。\n$$\nK_{\\text{cons}}(u) = \\frac{(1)(1 + \\alpha u) - (u)(\\alpha)}{(1 + \\alpha u)^2} = \\frac{1 + \\alpha u - \\alpha u}{(1 + \\alpha u)^2} = \\frac{1}{(1 + \\alpha u)^2}\n$$\n该问题还要求实现一个**不一致切线刚度**来模拟实际的算法误差，定义为：\n$$\nK_{\\text{inc}}(u) = s \\cdot K_{\\text{cons}}(u) = \\frac{s}{(1 + \\alpha u)^2}\n$$\n其中 $s \\in (0, 1]$ 是一个扰动因子。当 $s \\neq 1$ 时，切线刚度 $K(u_k) = K_{\\text{inc}}(u_k)$ 不再是残差的真实导数，这通常会降低纯牛顿法的收敛速度。\n\n为确保全局收敛，尤其是在远离解或使用不一致切线时，标准牛顿步会通过线搜索进行修正。更新由 $u_{k+1} = u_k + \\alpha_k \\Delta u_k$ 给出，其中 $\\alpha_k \\in (0, 1]$ 是由回溯线搜索确定的步长参数。搜索旨在找到一个能使评价函数充分下降的 $\\alpha_k$，此处评价函数选为：\n$$\n\\phi(u) = \\frac{1}{2} R(u; P)^2\n$$\n只要方向导数为负，搜索方向 $\\Delta u_k = -R(u_k;P)/K(u_k)$ 就是 $\\phi(u)$ 的一个下降方向。$\\phi$ 在 $u_k$ 处沿 $\\Delta u_k$ 的方向导数为：\n$$\nD\\phi(u_k)[\\Delta u_k] = \\nabla\\phi(u_k)^T \\Delta u_k = \\left(\\frac{d\\phi}{du}\\right)_{u_k} \\Delta u_k\n$$\n评价函数的梯度为 $\\frac{d\\phi}{du} = \\frac{d}{du}(\\frac{1}{2}R^2) = R \\frac{dR}{du} = R \\cdot K_{\\text{cons}}$。因此，\n$$\nD\\phi(u_k)[\\Delta u_k] = R(u_k) K_{\\text{cons}}(u_k) \\Delta u_k = R(u_k) K_{\\text{cons}}(u_k) \\left(-\\frac{R(u_k)}{K(u_k)}\\right) = -[R(u_k)]^2 \\frac{K_{\\text{cons}}(u_k)}{K(u_k)}\n$$\n代入 $K(u_k) = s \\cdot K_{\\text{cons}}(u_k)$，方向导数变为：\n$$\nD\\phi(u_k)[\\Delta u_k] = -\\frac{[R(u_k)]^2}{s}\n$$\n由于 $s>0$ 且 $[R(u_k)]^2 \\ge 0$，方向导数始终为非正，这证实了 $\\Delta u_k$ 是评价函数 $\\phi$ 的一个下降方向。\n\n回溯算法使用 **Armijo 条件**来接受一个步长。从 $\\alpha_k = 1$ 开始，我们检查是否满足：\n$$\n\\phi(u_k + \\alpha_k \\Delta u_k) \\le \\phi(u_k) + c_1 \\alpha_k D\\phi(u_k)[\\Delta u_k]\n$$\n其中 $c_1 = 10^{-4}$。若条件不满足，则步长乘以一个因子 $\\beta = 1/2$ 进行缩减，即 $\\alpha_k \\leftarrow \\beta \\alpha_k$，然后重复检查。每次这样的缩减都计为一次“回溯”。\n\n对于每个测试用例，总体算法流程如下：\n1.  初始化收敛位移 $u_{\\text{conv}} = 0$ 和性能指标（总回溯次数等）为零。\n2.  从 $P = P_{\\max}/N_{\\text{inc}}$ 到 $P=P_{\\max}$ 遍历 $N_{\\text{inc}}$ 个荷载增量。\n3.  对于每个荷载 $P$，以初始猜测 $u = u_{\\text{conv}}$ 开始牛顿循环。\n4.  在牛顿循环内部，计算残差 $R(u;P)$。如果 $|R| \\le \\text{tol}=10^{-12}$，则该步已收敛。存储新的 $u_{\\text{conv}}$ 并进入下一个荷载增量。\n5.  如果未收敛，则计算切线 $K(u)$（根据 $s$ 是一致的或不一致的）和搜索方向 $\\Delta u$。\n6.  执行回溯线搜索以找到可接受的步长 $\\alpha_k$，从 $\\alpha_k=1$ 开始。计算缩减次数。\n7.  更新位移 $u \\leftarrow u + \\alpha_k \\Delta u$。\n8.  记录指标：增加总更新次数。如果 $\\alpha_k  1$，则增加拒绝完整步长的计数。\n9.  重复牛顿循环直到收敛或达到最大迭代次数。\n10. 在所有荷载步之后，计算最终的拒绝频率，并返回总回溯次数和该频率。\n\n使用不一致切线 ($s1$) 会使搜索方向 $\\Delta u_k$ 成为真实牛顿方向的一个较不准确的近似。这通常会迫使线搜索拒绝完整步长 ($\\alpha_k=1$) 并执行回溯以寻找一个更小的、可接受的步长，从而增加了回溯次数和拒绝频率。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the specified test cases and print results.\n    \"\"\"\n    \n    def run_solver(alpha_mat, P_max, N_inc, s):\n        \"\"\"\n        Solves the 1D nonlinear problem for a single parameter set.\n\n        Args:\n            alpha_mat (float): Material parameter for softening.\n            P_max (float): Maximum applied load.\n            N_inc (int): Number of load increments.\n            s (float): Inconsistency factor for the tangent stiffness.\n\n        Returns:\n            tuple: A tuple containing:\n                - total_backtracks (int): Total number of backtracking reductions.\n                - rejection_freq (float): Ratio of updates with alpha  1 to total updates.\n        \"\"\"\n        # --- Solver Parameters ---\n        c1 = 1e-4\n        beta = 0.5\n        tol = 1e-12\n        max_newton_iter = 50\n        max_backtrack_iter = 20\n\n        # --- State and Metrics Initialization ---\n        u_converged = 0.0\n        total_backtracks = 0\n        updates_with_alpha_lt_1 = 0\n        total_updates = 0\n\n        # --- Load Stepping ---\n        load_increments = np.linspace(P_max / N_inc, P_max, N_inc)\n\n        for P in load_increments:\n            u = u_converged  # Initial guess from previous converged step\n\n            for k in range(max_newton_iter):\n                # --- Calculate Residual ---\n                # Based on sigma(u) = u / (1 + alpha_mat * u)\n                # Denominator is always positive for u>=0 and alpha_mat>=0.\n                R_u = u / (1.0 + alpha_mat * u) - P\n\n                # --- Check for Convergence ---\n                if abs(R_u) = tol:\n                    break\n\n                # --- Calculate Tangent Stiffness and Search Direction ---\n                K_cons_u = 1.0 / (1.0 + alpha_mat * u)**2\n                K_u = s * K_cons_u\n                \n                # Safeguard against singular tangent (unlikely for this problem)\n                if abs(K_u)  1e-20:\n                    # Could indicate a limit point or error, break iteration\n                    break\n                    \n                delta_u = -R_u / K_u\n\n                # --- Line Search (Armijo Backtracking) ---\n                alpha_step = 1.0\n                num_backtracks_this_iter = 0\n                \n                phi_u = 0.5 * R_u**2\n                \n                # Directional derivative of the merit function phi\n                # D(phi)[delta_u] = -R^2 * K_cons/K = -R^2/s\n                slope = -R_u**2 / s\n\n                for _ in range(max_backtrack_iter):\n                    u_trial = u + alpha_step * delta_u\n                    \n                    # The trial step should not lead to non-physical strain\n                    # 1 + alpha_mat * u_trial must be > 0.\n                    # Since u >= 0 and P >= 0, this is not an issue.\n                    \n                    R_trial = u_trial / (1.0 + alpha_mat * u_trial) - P\n                    phi_trial = 0.5 * R_trial**2\n\n                    # Armijo sufficient decrease condition\n                    if phi_trial = phi_u + c1 * alpha_step * slope:\n                        break  # Sufficient decrease, accept step\n                    else:\n                        # Condition failed, backtrack\n                        alpha_step *= beta\n                        num_backtracks_this_iter += 1\n                else:\n                    # Max backtracking iterations reached, may indicate failure to find a step.\n                    # For this problem, we proceed with the last attempted step and hope the\n                    # next Newton iteration can recover.\n                    break \n                \n                # --- Update State and Metrics ---\n                u = u_trial\n                total_updates += 1\n                total_backtracks += num_backtracks_this_iter\n                if alpha_step  1.0:\n                    updates_with_alpha_lt_1 += 1\n\n            # Store converged solution for the next load step\n            u_converged = u\n        \n        # --- Final Metric Calculation ---\n        if total_updates == 0:\n            rejection_freq = 0.0\n        else:\n            rejection_freq = updates_with_alpha_lt_1 / total_updates\n            \n        return total_backtracks, rejection_freq\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (Parameter set 1: alpha, P_max, N_inc, s)\n        (10.0, 0.09, 5, 1.0),  # Case A\n        (10.0, 0.09, 5, 0.5),  # Case B\n        (10.0, 0.09, 5, 0.1),  # Case C\n        (3.0, 0.25, 5, 0.5),   # Case D\n    ]\n\n    results = []\n    for case in test_cases:\n        alpha_val, p_max_val, n_inc_val, s_val = case\n        backtracks, rej_freq = run_solver(alpha_val, p_max_val, n_inc_val, s_val)\n        results.append(str(backtracks))\n        results.append(f\"{rej_freq:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}