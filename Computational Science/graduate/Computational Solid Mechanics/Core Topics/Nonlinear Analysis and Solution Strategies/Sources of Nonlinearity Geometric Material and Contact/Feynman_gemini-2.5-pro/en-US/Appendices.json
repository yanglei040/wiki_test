{
    "hands_on_practices": [
        {
            "introduction": "Our exploration of nonlinearity begins with its most intuitive source: large changes in geometry. Before we can analyze the stresses and forces in a highly deformed body, we must first have a precise mathematical language to describe the deformation itself. This first exercise  grounds us in the fundamental kinematics of finite-strain continuum mechanics. By calculating the deformation gradient ($F$), key strain tensors ($C$, $E$), and performing a polar decomposition for a simple stretch, you will build the essential mathematical foundation needed to navigate the complexities of geometric nonlinearity.",
            "id": "3601263",
            "problem": "Consider a three-dimensional body undergoing a homogeneous deformation described by the motion $\\varphi:\\mathbb{R}^{3}\\to\\mathbb{R}^{3}$ given in Cartesian material coordinates by $\\varphi(X)=\\begin{bmatrix}\\lambda_{1} X_{1} \\\\ \\lambda_{2} X_{2} \\\\ \\lambda_{3} X_{3}\\end{bmatrix}$, where $\\lambda_{1},\\lambda_{2},\\lambda_{3}>0$ are constant principal stretches. Treating this as a finite deformation exemplifying geometric nonlinearity, proceed as follows.\n\nStarting from the definitions of the deformation gradient, the right Cauchy–Green deformation tensor, the Green–Lagrange strain tensor, and the right polar decomposition, compute the deformation gradient $F$, the right Cauchy–Green tensor $C$, and the Green–Lagrange strain $E$ associated with $\\varphi$. Then perform the right polar decomposition of $F$, that is, write $F=R\\,U$, and identify the right stretch tensor $U$ and the rotation tensor $R$.\n\nAs your final reported answer, provide the exact symbolic expression for the Jacobian determinant $J=\\det F$ in terms of $\\lambda_{1},\\lambda_{2},\\lambda_{3}$. Express your final answer as a closed-form analytic expression. Do not include units. No rounding is required.",
            "solution": "The problem statement is evaluated as valid. It is scientifically grounded in the principles of continuum mechanics, well-posed with all necessary information provided, and objective in its formulation. The problem requires the application of standard definitions to a fundamental case of finite deformation, making it a suitable and solvable problem.\n\nThe motion of the body is described by the mapping $\\varphi$ from the material (or reference) configuration, with coordinates $\\mathbf{X} = (X_1, X_2, X_3)$, to the spatial (or current) configuration, with coordinates $\\mathbf{x} = (x_1, x_2, x_3)$. The given motion is:\n$$\n\\mathbf{x} = \\varphi(\\mathbf{X}) = \\begin{bmatrix} \\lambda_{1} X_{1} \\\\ \\lambda_{2} X_{2} \\\\ \\lambda_{3} X_{3} \\end{bmatrix}\n$$\nwhere $\\lambda_1, \\lambda_2, \\lambda_3 > 0$ are constant principal stretches.\n\nFirst, we compute the deformation gradient tensor, $\\mathbf{F}$. It is defined as the gradient of the motion with respect to the material coordinates:\n$$\n\\mathbf{F} = \\frac{\\partial \\varphi}{\\partial \\mathbf{X}} = \\nabla_{\\mathbf{X}} \\varphi\n$$\nIn component form, its elements are $F_{ij} = \\frac{\\partial x_i}{\\partial X_j}$. We compute the components:\n$F_{11} = \\frac{\\partial (\\lambda_1 X_1)}{\\partial X_1} = \\lambda_1$\n$F_{22} = \\frac{\\partial (\\lambda_2 X_2)}{\\partial X_2} = \\lambda_2$\n$F_{33} = \\frac{\\partial (\\lambda_3 X_3)}{\\partial X_3} = \\lambda_3$\nAll off-diagonal components are zero, for example, $F_{12} = \\frac{\\partial (\\lambda_1 X_1)}{\\partial X_2} = 0$.\nThus, the deformation gradient tensor $\\mathbf{F}$ is a diagonal matrix:\n$$\n\\mathbf{F} = \\begin{bmatrix} \\lambda_1 & 0 & 0 \\\\ 0 & \\lambda_2 & 0 \\\\ 0 & 0 & \\lambda_3 \\end{bmatrix}\n$$\n\nNext, we compute the right Cauchy–Green deformation tensor, $\\mathbf{C}$. It is defined as:\n$$\n\\mathbf{C} = \\mathbf{F}^T \\mathbf{F}\n$$\nwhere $\\mathbf{F}^T$ is the transpose of $\\mathbf{F}$. Since $\\mathbf{F}$ is a diagonal matrix, it is symmetric, so $\\mathbf{F}^T = \\mathbf{F}$.\n$$\n\\mathbf{C} = \\mathbf{F}^T \\mathbf{F} = \\mathbf{F} \\mathbf{F} = \\mathbf{F}^2 = \\begin{bmatrix} \\lambda_1 & 0 & 0 \\\\ 0 & \\lambda_2 & 0 \\\\ 0 & 0 & \\lambda_3 \\end{bmatrix} \\begin{bmatrix} \\lambda_1 & 0 & 0 \\\\ 0 & \\lambda_2 & 0 \\\\ 0 & 0 & \\lambda_3 \\end{bmatrix} = \\begin{bmatrix} \\lambda_1^2 & 0 & 0 \\\\ 0 & \\lambda_2^2 & 0 \\\\ 0 & 0 & \\lambda_3^2 \\end{bmatrix}\n$$\n\nThen, we compute the Green–Lagrange strain tensor, $\\mathbf{E}$. It is defined in terms of $\\mathbf{C}$ and the identity tensor $\\mathbf{I}$ as:\n$$\n\\mathbf{E} = \\frac{1}{2}(\\mathbf{C} - \\mathbf{I})\n$$\nSubstituting the expression for $\\mathbf{C}$:\n$$\n\\mathbf{E} = \\frac{1}{2} \\left( \\begin{bmatrix} \\lambda_1^2 & 0 & 0 \\\\ 0 & \\lambda_2^2 & 0 \\\\ 0 & 0 & \\lambda_3^2 \\end{bmatrix} - \\begin{bmatrix} 1 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{bmatrix} \\right) = \\frac{1}{2} \\begin{bmatrix} \\lambda_1^2 - 1 & 0 & 0 \\\\ 0 & \\lambda_2^2 - 1 & 0 \\\\ 0 & 0 & \\lambda_3^2 - 1 \\end{bmatrix}\n$$\n\nNow, we perform the right polar decomposition of $\\mathbf{F}$, which states that $\\mathbf{F}$ can be uniquely written as $\\mathbf{F} = \\mathbf{R} \\mathbf{U}$, where $\\mathbf{R}$ is a proper orthogonal tensor (the rotation tensor) and $\\mathbf{U}$ is a positive definite, symmetric tensor (the right stretch tensor).\nThe tensor $\\mathbf{U}$ can be computed from $\\mathbf{C}$ using the relation $\\mathbf{C} = \\mathbf{U}^2$, which implies $\\mathbf{U} = \\sqrt{\\mathbf{C}}$.\nFor the diagonal tensor $\\mathbf{C}$ we found, its principal square root is a diagonal tensor whose elements are the square roots of the diagonal elements of $\\mathbf{C}$.\n$$\n\\mathbf{U} = \\sqrt{\\mathbf{C}} = \\begin{bmatrix} \\sqrt{\\lambda_1^2} & 0 & 0 \\\\ 0 & \\sqrt{\\lambda_2^2} & 0 \\\\ 0 & 0 & \\sqrt{\\lambda_3^2} \\end{bmatrix}\n$$\nSince it is given that $\\lambda_1, \\lambda_2, \\lambda_3 > 0$, we have $\\sqrt{\\lambda_i^2} = \\lambda_i$.\n$$\n\\mathbf{U} = \\begin{bmatrix} \\lambda_1 & 0 & 0 \\\\ 0 & \\lambda_2 & 0 \\\\ 0 & 0 & \\lambda_3 \\end{bmatrix}\n$$\nNote that in this specific case of pure homogeneous stretch, $\\mathbf{U} = \\mathbf{F}$. This indicates the deformation is irrotational.\n\nThe rotation tensor $\\mathbf{R}$ can now be found from the decomposition $\\mathbf{F} = \\mathbf{R} \\mathbf{U}$. Since $\\mathbf{F}$ must be invertible for the decomposition to be unique ($\\det \\mathbf{F} \\neq 0$), we can write $\\mathbf{R} = \\mathbf{F} \\mathbf{U}^{-1}$.\nSubstituting our results for $\\mathbf{F}$ and $\\mathbf{U}$:\n$$\n\\mathbf{R} = \\mathbf{F} \\mathbf{U}^{-1} = \\begin{bmatrix} \\lambda_1 & 0 & 0 \\\\ 0 & \\lambda_2 & 0 \\\\ 0 & 0 & \\lambda_3 \\end{bmatrix} \\begin{bmatrix} \\frac{1}{\\lambda_1} & 0 & 0 \\\\ 0 & \\frac{1}{\\lambda_2} & 0 \\\\ 0 & 0 & \\frac{1}{\\lambda_3} \\end{bmatrix} = \\begin{bmatrix} 1 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{bmatrix} = \\mathbf{I}\n$$\nThe rotation tensor is the identity tensor $\\mathbf{I}$. This is a valid rotation tensor since it is orthogonal ($\\mathbf{I}^T\\mathbf{I} = \\mathbf{I}$) and has determinant $+1$. This confirms that the given deformation is a pure stretch with no rotation.\n\nFinally, we compute the Jacobian determinant, $J = \\det \\mathbf{F}$. The Jacobian measures the change in volume from the reference to the current configuration.\nUsing the matrix for $\\mathbf{F}$:\n$$\n\\mathbf{F} = \\begin{bmatrix} \\lambda_1 & 0 & 0 \\\\ 0 & \\lambda_2 & 0 \\\\ 0 & 0 & \\lambda_3 \\end{bmatrix}\n$$\nThe determinant of a diagonal matrix is the product of its diagonal elements.\n$$\nJ = \\det \\mathbf{F} = \\lambda_1 \\lambda_2 \\lambda_3\n$$\nThis is the final expression required by the problem.",
            "answer": "$$\n\\boxed{\\lambda_{1} \\lambda_{2} \\lambda_{3}}\n$$"
        },
        {
            "introduction": "We now turn to material nonlinearity, where the stress-strain relationship is no longer a simple constant. This practice focuses on elastoplasticity, the behavior of materials like metals that deform elastically up to a yield point and then undergo permanent plastic flow. To solve such problems numerically, we need a robust algorithm to update the stress state at each step. This problem  guides you through the derivation of the workhorse of computational plasticity: the \"return mapping\" algorithm and its \"consistent tangent operator\" for a 1D model, providing the core logic that extends to complex 3D simulations.",
            "id": "3601269",
            "problem": "Consider a one-dimensional small-strain bar subjected to monotonically increasing tensile deformation, modeled within the Finite Element Method (FEM) using a standard rate-independent associative elastoplastic constitutive law with linear isotropic hardening. The material behavior is defined by the following ingredients:\n\n- The additive strain decomposition $\\varepsilon = \\varepsilon^{\\mathrm{e}} + \\varepsilon^{\\mathrm{p}}$.\n- A quadratic elastic Helmholtz free energy $\\psi(\\varepsilon^{\\mathrm{e}}) = \\tfrac{1}{2} E (\\varepsilon^{\\mathrm{e}})^{2}$, where $E$ is the Young's modulus.\n- The Cauchy stress $\\sigma$ follows $\\sigma = \\frac{\\partial \\psi}{\\partial \\varepsilon^{\\mathrm{e}}} = E (\\varepsilon - \\varepsilon^{\\mathrm{p}})$.\n- An associative yield function $f(\\sigma,\\alpha) = |\\sigma| - \\sigma_{y0} - H \\alpha$, where $\\sigma_{y0} > 0$ is the initial yield stress, $H \\ge 0$ is the isotropic hardening modulus, and $\\alpha$ is the equivalent plastic strain defined by $\\dot{\\alpha} = |\\dot{\\varepsilon}^{\\mathrm{p}}|$.\n- Normality and complementarity conditions consistent with associative plasticity: $\\dot{\\varepsilon}^{\\mathrm{p}} = \\dot{\\gamma} \\, \\partial f / \\partial \\sigma$, $\\dot{\\alpha} = \\dot{\\gamma}$, $\\dot{\\gamma} \\ge 0$, $f \\le 0$, $\\dot{\\gamma} f = 0$.\n\nAssume the loading remains strictly tensile, so that $\\sigma \\ge 0$ and the flow direction is positive. Consider a single implicit time increment from $t_{n}$ to $t_{n+1}$ with a prescribed total strain $\\varepsilon_{n+1}$. Let the internal variables at $t_{n}$ be $\\varepsilon^{\\mathrm{p}}_{n}$ and $\\alpha_{n}$. Define the trial elastic predictor $\\sigma_{\\mathrm{tr}} = E (\\varepsilon_{n+1} - \\varepsilon^{\\mathrm{p}}_{n})$ and the trial yield value $f_{\\mathrm{tr}} = \\sigma_{\\mathrm{tr}} - \\sigma_{y0} - H \\alpha_{n}$.\n\nSuppose that the step is plastically active, namely $f_{\\mathrm{tr}} > 0$. Starting from the above foundational definitions and conditions, carry out the following tasks:\n\n1. Discretize the internal variable evolution using an unconditionally stable scheme suitable for implicit FEM, and formulate the corresponding discrete system for the plastic multiplier increment $\\Delta \\gamma$.\n2. Derive the algorithmic stress update $\\sigma_{n+1}$ in terms of $\\varepsilon_{n+1}$, $\\varepsilon^{\\mathrm{p}}_{n}$, $\\alpha_{n}$, $E$, $H$, and $\\sigma_{y0}$, for the plastically active case $f_{\\mathrm{tr}} > 0$ under tensile loading.\n3. Compute the consistent tangent operator required by a Newton–Raphson solution of the global equilibrium equations in an implicit FEM formulation, that is, evaluate $\\dfrac{\\mathrm{d} \\sigma_{n+1}}{\\mathrm{d} \\varepsilon_{n+1}}$ for the plastically active case under tensile loading.\n\nProvide your final result as a single closed-form analytic expression for the consistent tangent modulus in terms of $E$ and $H$. No numerical evaluation is required, and no physical units should be included in the final expression.",
            "solution": "The problem statement is validated as scientifically grounded, well-posed, and objective. It presents a standard problem in computational elastoplasticity. We proceed to the solution.\n\nThe problem requires the derivation of the stress update and the consistent tangent modulus for a one-dimensional bar undergoing plastic deformation, within the framework of the Finite Element Method (FEM). The model is one of rate-independent associative elastoplasticity with linear isotropic hardening. We are given the case of monotonically increasing tensile loading, which implies the stress $\\sigma$ is non-negative, $\\sigma \\ge 0$.\n\nFirst, we simplify the yield function and flow rule based on the tensile loading condition. The yield function is $f(\\sigma, \\alpha) = |\\sigma| - \\sigma_{y0} - H \\alpha$. Since $\\sigma \\ge 0$, this becomes $f(\\sigma, \\alpha) = \\sigma - \\sigma_{y0} - H \\alpha$.\nThe flow rule for the plastic strain is $\\dot{\\varepsilon}^{\\mathrm{p}} = \\dot{\\gamma} \\frac{\\partial f}{\\partial \\sigma}$. The gradient is $\\frac{\\partial f}{\\partial \\sigma} = \\frac{\\partial}{\\partial \\sigma}(\\sigma - \\sigma_{y0} - H \\alpha) = 1$.\nTherefore, the flow rule simplifies to $\\dot{\\varepsilon}^{\\mathrm{p}} = \\dot{\\gamma}$.\nThe hardening law is given by $\\dot{\\alpha} = |\\dot{\\varepsilon}^{\\mathrm{p}}|$. Substituting $\\dot{\\varepsilon}^{\\mathrm{p}} = \\dot{\\gamma}$ and knowing that the plastic multiplier rate $\\dot{\\gamma}$ is non-negative, $\\dot{\\gamma} \\ge 0$, we get $\\dot{\\alpha} = |\\dot{\\gamma}| = \\dot{\\gamma}$.\n\nThe problem requires a discrete formulation for a single implicit time increment from time $t_n$ to $t_{n+1}$. We will employ the backward Euler method, an unconditionally stable scheme, to integrate the evolution equations for the internal variables $\\varepsilon^{\\mathrm{p}}$ and $\\alpha$.\n\nThe backward Euler discretization of the evolution equations is:\n$$ \\varepsilon^{\\mathrm{p}}_{n+1} = \\varepsilon^{\\mathrm{p}}_{n} + \\Delta \\varepsilon^{\\mathrm{p}} = \\varepsilon^{\\mathrm{p}}_{n} + \\Delta\\gamma \\left. \\frac{\\partial f}{\\partial \\sigma} \\right|_{n+1} $$\n$$ \\alpha_{n+1} = \\alpha_{n} + \\Delta\\alpha = \\alpha_{n} + \\Delta\\gamma $$\nwhere $\\Delta\\gamma = \\int_{t_n}^{t_{n+1}} \\dot{\\gamma} \\, \\mathrm{d}t$ is the increment in the plastic multiplier. Since $\\left. \\frac{\\partial f}{\\partial \\sigma} \\right|_{n+1} = 1$, the plastic strain update becomes:\n$$ \\varepsilon^{\\mathrm{p}}_{n+1} = \\varepsilon^{\\mathrm{p}}_{n} + \\Delta\\gamma $$\n\nThe step is assumed to be plastically active, meaning that after an initial elastic trial step, the yield condition is violated ($f_{\\mathrm{tr}} > 0$). This implies that plastic flow occurs during the increment, and at the end of the increment, the state must lie on the yield surface. This is expressed by the discrete consistency condition:\n$$ f_{n+1} = f(\\sigma_{n+1}, \\alpha_{n+1}) = 0 $$\nSubstituting the simplified yield function, we have:\n$$ \\sigma_{n+1} - \\sigma_{y0} - H \\alpha_{n+1} = 0 $$\n\nNow we express $\\sigma_{n+1}$ and $\\alpha_{n+1}$ in terms of the increment $\\Delta\\gamma$ and known quantities.\nThe stress at $t_{n+1}$ is given by the constitutive law:\n$$ \\sigma_{n+1} = E (\\varepsilon_{n+1} - \\varepsilon^{\\mathrm{p}}_{n+1}) $$\nSubstituting the update for $\\varepsilon^{\\mathrm{p}}_{n+1}$:\n$$ \\sigma_{n+1} = E (\\varepsilon_{n+1} - (\\varepsilon^{\\mathrm{p}}_{n} + \\Delta\\gamma)) = E (\\varepsilon_{n+1} - \\varepsilon^{\\mathrm{p}}_{n}) - E \\Delta\\gamma $$\nThe term $E (\\varepsilon_{n+1} - \\varepsilon^{\\mathrm{p}}_{n})$ is defined as the trial stress, $\\sigma_{\\mathrm{tr}}$. So,\n$$ \\sigma_{n+1} = \\sigma_{\\mathrm{tr}} - E \\Delta\\gamma $$\nThe updated hardening variable is:\n$$ \\alpha_{n+1} = \\alpha_{n} + \\Delta\\gamma $$\n\nWe can now substitute these expressions for $\\sigma_{n+1}$ and $\\alpha_{n+1}$ into the discrete consistency condition $f_{n+1} = 0$:\n$$ (\\sigma_{\\mathrm{tr}} - E \\Delta\\gamma) - \\sigma_{y0} - H (\\alpha_{n} + \\Delta\\gamma) = 0 $$\nRearranging the terms to solve for $\\Delta\\gamma$ addresses Task 1:\n$$ (\\sigma_{\\mathrm{tr}} - \\sigma_{y0} - H \\alpha_{n}) - E \\Delta\\gamma - H \\Delta\\gamma = 0 $$\nThe term in the parentheses is the trial yield value, $f_{\\mathrm{tr}} = \\sigma_{\\mathrm{tr}} - \\sigma_{y0} - H \\alpha_{n}$. The equation becomes:\n$$ f_{\\mathrm{tr}} - (E+H) \\Delta\\gamma = 0 $$\nFor a plastic step, we assumed $f_{\\mathrm{tr}} > 0$. Since $E>0$ and $H \\ge 0$, the sum $E+H$ is positive. We can solve for $\\Delta\\gamma$:\n$$ \\Delta\\gamma = \\frac{f_{\\mathrm{tr}}}{E+H} $$\nThis confirms that $\\Delta\\gamma > 0$, consistent with active plastic loading.\n\nFor Task 2, we derive the algorithmic stress update, $\\sigma_{n+1}$. We substitute the expression for $\\Delta\\gamma$ back into the equation for $\\sigma_{n+1}$:\n$$ \\sigma_{n+1} = \\sigma_{\\mathrm{tr}} - E \\Delta\\gamma = \\sigma_{\\mathrm{tr}} - E \\left( \\frac{f_{\\mathrm{tr}}}{E+H} \\right) $$\nSubstituting the definition of $f_{\\mathrm{tr}}$:\n$$ \\sigma_{n+1} = \\sigma_{\\mathrm{tr}} - \\frac{E}{E+H} (\\sigma_{\\mathrm{tr}} - \\sigma_{y0} - H \\alpha_{n}) $$\nThis expression represents the \"return mapping\" algorithm, which projects the trial stress state back onto the updated yield surface. This expression can be used for Task 3, but for completeness, we can also expand it:\n$$ \\sigma_{n+1} = \\sigma_{\\mathrm{tr}} \\left( 1 - \\frac{E}{E+H} \\right) + \\frac{E}{E+H} (\\sigma_{y0} + H \\alpha_{n}) = \\frac{H}{E+H}\\sigma_{\\mathrm{tr}} + \\frac{E}{E+H}(\\sigma_{y0} + H\\alpha_{n}) $$\nSubstituting $\\sigma_{\\mathrm{tr}} = E(\\varepsilon_{n+1} - \\varepsilon^{\\mathrm{p}}_{n})$ gives the full dependency:\n$$ \\sigma_{n+1} = \\frac{H E}{E+H}(\\varepsilon_{n+1} - \\varepsilon^{\\mathrm{p}}_{n}) + \\frac{E}{E+H}(\\sigma_{y0} + H\\alpha_{n}) $$\n\nFor Task 3, we compute the consistent tangent operator (modulus in 1D), which is the derivative of the updated stress $\\sigma_{n+1}$ with respect to the total strain $\\varepsilon_{n+1}$.\n$$ \\frac{\\mathrm{d} \\sigma_{n+1}}{\\mathrm{d} \\varepsilon_{n+1}} $$\nWe differentiate the expression for $\\sigma_{n+1}$ derived in Task 2. The most convenient form to start from is:\n$$ \\sigma_{n+1} = \\sigma_{\\mathrm{tr}} - \\frac{E}{E+H} (\\sigma_{\\mathrm{tr}} - \\sigma_{y0} - H \\alpha_{n}) $$\nThe variables $\\varepsilon^{\\mathrm{p}}_{n}$ and $\\alpha_{n}$ are historical values from the beginning of the increment and are therefore constant with respect to $\\varepsilon_{n+1}$. The material parameters $E$, $H$, and $\\sigma_{y0}$ are also constants. The only term that depends on $\\varepsilon_{n+1}$ is the trial stress $\\sigma_{\\mathrm{tr}} = E(\\varepsilon_{n+1} - \\varepsilon^{\\mathrm{p}}_{n})$.\nThe derivative of the trial stress is:\n$$ \\frac{\\mathrm{d} \\sigma_{\\mathrm{tr}}}{\\mathrm{d} \\varepsilon_{n+1}} = \\frac{\\mathrm{d}}{\\mathrm{d} \\varepsilon_{n+1}} [E(\\varepsilon_{n+1} - \\varepsilon^{\\mathrm{p}}_{n})] = E $$\nNow, we apply the chain rule to the expression for $\\sigma_{n+1}$:\n$$ \\frac{\\mathrm{d} \\sigma_{n+1}}{\\mathrm{d} \\varepsilon_{n+1}} = \\frac{\\mathrm{d} \\sigma_{\\mathrm{tr}}}{\\mathrm{d} \\varepsilon_{n+1}} - \\frac{E}{E+H} \\frac{\\mathrm{d}}{\\mathrm{d} \\varepsilon_{n+1}} (\\sigma_{\\mathrm{tr}} - \\sigma_{y0} - H \\alpha_{n}) $$\n$$ \\frac{\\mathrm{d} \\sigma_{n+1}}{\\mathrm{d} \\varepsilon_{n+1}} = \\frac{\\mathrm{d} \\sigma_{\\mathrm{tr}}}{\\mathrm{d} \\varepsilon_{n+1}} - \\frac{E}{E+H} \\frac{\\mathrm{d} \\sigma_{\\mathrm{tr}}}{\\mathrm{d} \\varepsilon_{n+1}} $$\nSubstituting $\\frac{\\mathrm{d} \\sigma_{\\mathrm{tr}}}{\\mathrm{d} \\varepsilon_{n+1}} = E$:\n$$ \\frac{\\mathrm{d} \\sigma_{n+1}}{\\mathrm{d} \\varepsilon_{n+1}} = E - \\frac{E}{E+H} (E) = E \\left( 1 - \\frac{E}{E+H} \\right) $$\nSimplifying the expression in the parenthesis:\n$$ \\frac{\\mathrm{d} \\sigma_{n+1}}{\\mathrm{d} \\varepsilon_{n+1}} = E \\left( \\frac{E+H-E}{E+H} \\right) = E \\left( \\frac{H}{E+H} \\right) $$\nThus, the consistent tangent modulus for a plastically active step is:\n$$ \\frac{\\mathrm{d} \\sigma_{n+1}}{\\mathrm{d} \\varepsilon_{n+1}} = \\frac{EH}{E+H} $$\nThis result is the harmonic mean of the elastic modulus $E$ and the plastic (hardening) modulus $H$.\nIf the material is perfectly plastic ($H=0$), the tangent modulus is $0$. If there is no plastic deformation (equivalent to $H \\to \\infty$), the tangent modulus correctly recovers the elastic modulus $E$.",
            "answer": "$$\\boxed{\\frac{EH}{E+H}}$$"
        },
        {
            "introduction": "A classic and important consequence of geometric nonlinearity is its effect on structural stability, commonly known as buckling. When a slender structure is subjected to compressive loads, its stiffness can be significantly reduced, potentially leading to catastrophic failure at a load much lower than the material's strength limit. This P-$\\Delta$ effect is captured through a \"geometric stiffness matrix\" that depends on the current stress state. This practical exercise  involves assembling the linear and geometric stiffness matrices for a frame structure to perform a linearized eigenvalue buckling analysis, a cornerstone technique in engineering design.",
            "id": "3601273",
            "problem": "Consider a planar two-dimensional frame idealized with Euler–Bernoulli beam–column elements. Each node possesses three degrees of freedom: global axial translation $u_X$, global transverse translation $u_Y$, and out-of-plane rotation $\\theta_Z$. The material is linear elastic with Young’s modulus $E$, cross-sectional area $A$, and second moment of area $I$. The geometric nonlinearity is included only through the initial stress (geometric) stiffness associated with constant axial forces $P$ in each element. The P–$\\Delta$ effect is quantified by solving a linearized eigenvalue buckling problem.\n\nStarting from the principle of virtual work and small-strain, small-rotation kinematics, model each element with the standard two-node Euler–Bernoulli interpolation for axial and transverse fields. The linear elastic stiffness matrix arises from the internal strain energy in axial stretch and bending curvature. The geometric stiffness matrix arises from the work of axial force $P$ against second-order transverse displacement gradients. For an element of length $L$ with orientation angle $\\phi$ (in radians, measured from the global $X$ axis toward the element’s local axial direction), assemble the global linear elastic stiffness matrix $\\mathbf{K}$ and the global geometric stiffness matrix $\\mathbf{K}_g$ by:\n- Constructing each element’s local linear elastic stiffness $\\mathbf{K}_e^{\\text{loc}}(E,A,I,L)$ using Euler–Bernoulli theory.\n- Constructing each element’s local geometric (initial stress) stiffness $\\mathbf{K}_{g,e}^{\\text{loc}}(P,L)$ consistent with the virtual work of $P$ and the Hermite cubic transverse interpolation.\n- Rotating each local matrix to global coordinates using the appropriate orthogonal transformation and assembling into global matrices via standard finite element procedure.\n- Enforcing the specified essential boundary conditions by eliminating the constrained degrees of freedom from the global system.\n\nThen, determine the smallest positive load factor $\\lambda_{\\text{cr}}$ that satisfies the generalized eigenvalue problem\n$$\n\\mathbf{K}\\,\\mathbf{u} \\;=\\; \\lambda\\,\\mathbf{K}_g\\,\\mathbf{u}\n$$,\nwhich, by construction, scales the given axial force pattern $\\{P_e\\}$ uniformly to reach the critical state. This $\\lambda_{\\text{cr}}$ is dimensionless and quantifies the P–$\\Delta$ effect on the predicted buckling load for the chosen reference axial forces.\n\nAll angles must be in radians. Use International System of Units: $E$ in $\\text{Pa}$, $A$ in $\\text{m}^2$, $I$ in $\\text{m}^4$, lengths in $\\text{m}$, forces in $\\text{N}$. Report each $\\lambda_{\\text{cr}}$ as a floating-point number. If the geometric stiffness matrix is identically zero for a case, define the result as $+\\infty$.\n\nImplement a program that constructs and solves the buckling problem for the following test suite. The final output must be a single line containing a comma-separated list enclosed in square brackets. Each entry is the smallest positive real eigenvalue $\\lambda_{\\text{cr}}$ rounded to six decimal places.\n\nTest Suite:\n- Case 1 (happy path, pinned–pinned column): A single vertical column discretized into two equal elements.\n  - Nodes: $(0,0)$, $(0,L/2)$, $(0,L)$ with $L = 3.0\\,\\text{m}$.\n  - Elements: two column elements connecting bottom–mid and mid–top.\n  - Properties: $E = 210\\times 10^9\\,\\text{Pa}$, $A = 0.01\\,\\text{m}^2$, $I = 8\\times 10^{-6}\\,\\text{m}^4$.\n  - Axial forces: $P = 1.0\\,\\text{N}$ in each column element.\n  - Boundary conditions: at bottom and top nodes, fix $u_X$ and $u_Y$; rotations $\\theta_Z$ are free.\n  - Output: $\\lambda_{\\text{cr}}$ (dimensionless).\n- Case 2 (boundary condition coverage, fixed–fixed column): Same geometry, discretization, and properties as Case 1.\n  - Axial forces: $P = 1.0\\,\\text{N}$ in each column element.\n  - Boundary conditions: at bottom and top nodes, fix $u_X$, $u_Y$, and $\\theta_Z$.\n  - Output: $\\lambda_{\\text{cr}}$ (dimensionless).\n- Case 3 (frame connectivity and load-path coverage, single-bay frame): Two vertical columns (each discretized into two elements) connected by a single top beam.\n  - Column nodes: left column at $(0,0)$, $(0,L/2)$, $(0,L)$; right column at $(B,0)$, $(B,L/2)$, $(B,L)$; with $L=3.0\\,\\text{m}$ and $B=4.0\\,\\text{m}$.\n  - Beam element: connects $(0,L)$ to $(B,L)$.\n  - Properties: columns have $E = 210\\times 10^9\\,\\text{Pa}$, $A = 0.01\\,\\text{m}^2$, $I = 8\\times 10^{-6}\\,\\text{m}^4$; beam has $E = 210\\times 10^9\\,\\text{Pa}$, $A = 0.01\\,\\text{m}^2$, $I = 1.6\\times 10^{-5}\\,\\text{m}^4$.\n  - Axial forces: columns have $P = 1.0\\,\\text{N}$ in each column element; beam has $P = 0.0\\,\\text{N}$.\n  - Boundary conditions: at both column bases $(0,0)$ and $(B,0)$, fix $u_X$, $u_Y$, and $\\theta_Z$.\n  - Output: $\\lambda_{\\text{cr}}$ (dimensionless).\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3]\"), where each result is rounded to six decimal places, corresponding to Case 1, Case 2, and Case 3, respectively.",
            "solution": "The problem requires the determination of the critical buckling load factor, $\\lambda_{\\text{cr}}$, for several two-dimensional frame structures using the finite element method. The analysis is based on a linearized eigenvalue buckling formulation, which is a standard procedure in computational solid mechanics for assessing structural stability against P-$\\Delta$ effects. The solution involves constructing the linear elastic stiffness matrix $\\mathbf{K}$ and the geometric stiffness matrix $\\mathbf{K}_g$, applying boundary conditions, and solving the resulting generalized eigenvalue problem.\n\nThe entire process is founded on the principle of virtual work, or equivalently, the stationarity of the total potential energy $\\Pi$ of the system. For a discretized system, the total potential energy is the sum of the internal strain energy $U$ and the potential energy of the applied loads $W$.\n$$ \\Pi = U + W $$\nFor stability analysis, the strain energy $U$ is expanded to include second-order terms in the displacements, which captures the interaction between axial forces and transverse deflections. The total strain energy is composed of the linear elastic strain energy $U_e$ and the geometric strain energy $U_g$ associated with the initial stress state.\nEquilibrium is established when the first variation of the potential energy is zero, $\\delta\\Pi = 0$. The stability criterion is determined by the sign of the second variation, $\\delta^2\\Pi$. Buckling occurs when $\\delta^2\\Pi = 0$ for some non-trivial displacement field, indicating a transition from a stable to an unstable equilibrium state. This condition leads to the linearized eigenvalue problem.\n\nThe step-by-step procedure is as follows:\n\n1.  **Element Discretization and Local Stiffness Matrices**\nEach structural member is modeled as a two-node Euler-Bernoulli beam-column element. In a local coordinate system ($x, y, z$) where the $x$-axis aligns with the element's centroidal axis, each node has three degrees of freedom (DOFs): axial displacement $u_x$, transverse displacement $u_y$, and rotation $\\theta_z$. The element nodal displacement vector is $\\mathbf{d}_e^{\\text{loc}} = [u_{x1}, u_{y1}, \\theta_{z1}, u_{x2}, u_{y2}, \\theta_{z2}]^T$.\n\n-   **Linear Elastic Stiffness Matrix ($\\mathbf{K}_e^{\\text{loc}}$)**: This matrix is derived from the linear elastic strain energy, $U_e = \\frac{1}{2}\\int_V \\boldsymbol{\\sigma}^T \\boldsymbol{\\epsilon} \\, dV$. For an Euler-Bernoulli beam, this separates into axial and bending components. The resulting $6 \\times 6$ local stiffness matrix relates the nodal forces and moments to the nodal displacements:\n    $$ \\mathbf{K}_e^{\\text{loc}} = \\begin{bmatrix}\n    \\frac{EA}{L} & 0 & 0 & -\\frac{EA}{L} & 0 & 0 \\\\\n    0 & \\frac{12EI}{L^3} & \\frac{6EI}{L^2} & 0 & -\\frac{12EI}{L^3} & \\frac{6EI}{L^2} \\\\\n    0 & \\frac{6EI}{L^2} & \\frac{4EI}{L} & 0 & -\\frac{6EI}{L^2} & \\frac{2EI}{L} \\\\\n    -\\frac{EA}{L} & 0 & 0 & \\frac{EA}{L} & 0 & 0 \\\\\n    0 & -\\frac{12EI}{L^3} & -\\frac{6EI}{L^2} & 0 & \\frac{12EI}{L^3} & -\\frac{6EI}{L^2} \\\\\n    0 & \\frac{6EI}{L^2} & \\frac{2EI}{L} & 0 & -\\frac{6EI}{L^2} & \\frac{4EI}{L}\n    \\end{bmatrix} $$\n    where $E$ is Young's modulus, $A$ is the cross-sectional area, $I$ is the second moment of area, and $L$ is the element length.\n\n-   **Geometric Stiffness Matrix ($\\mathbf{K}_{g,e}^{\\text{loc}}$)**: This matrix, also known as the initial stress matrix, arises from the work done by the constant axial force $P$ (assumed compressive) on the nonlinear, second-order terms of the transverse displacement gradient. The potential energy term is $U_g = \\frac{1}{2} \\int_0^L P \\left( \\frac{du_y}{dx} \\right)^2 dx$. By using Hermite cubic shape functions for the transverse displacement field $u_y(x)$, we derive the local geometric stiffness matrix:\n    $$ \\mathbf{K}_{g,e}^{\\text{loc}} = \\frac{P}{30L} \\begin{bmatrix}\n    0 & 0 & 0 & 0 & 0 & 0 \\\\\n    0 & 36 & 3L & 0 & -36 & 3L \\\\\n    0 & 3L & 4L^2 & 0 & -3L & -L^2 \\\\\n    0 & 0 & 0 & 0 & 0 & 0 \\\\\n    0 & -36 & -3L & 0 & 36 & -3L \\\\\n    0 & 3L & -L^2 & 0 & -3L & 4L^2\n    \\end{bmatrix} $$\n    Note that this matrix is linearly proportional to the reference axial force $P$.\n\n2.  **Coordinate Transformation**\nTo assemble the global system, each element's local stiffness matrices must be transformed into the global coordinate system ($X, Y, Z$). This is achieved using a transformation matrix $\\mathbf{T}$, which relates local and global nodal displacements, $\\mathbf{d}_e^{\\text{loc}} = \\mathbf{T} \\mathbf{d}_e^{\\text{glob}}$. The matrix $\\mathbf{T}$ is constructed from a $3 \\times 3$ rotation matrix $\\mathbf{R}$ based on the element's orientation angle $\\phi$:\n$$ \\mathbf{R} = \\begin{bmatrix} \\cos\\phi & \\sin\\phi & 0 \\\\ -\\sin\\phi & \\cos\\phi & 0 \\\\ 0 & 0 & 1 \\end{bmatrix}, \\quad \\mathbf{T} = \\begin{bmatrix} \\mathbf{R} & \\mathbf{0} \\\\ \\mathbf{0} & \\mathbf{R} \\end{bmatrix} $$\nThe element stiffness matrices in the global coordinate system, $\\mathbf{K}_e$ and $\\mathbf{K}_{g,e}$, are then obtained through the congruent transformation:\n$$ \\mathbf{K}_e = \\mathbf{T}^T \\mathbf{K}_e^{\\text{loc}} \\mathbf{T}, \\quad \\mathbf{K}_{g,e} = \\mathbf{T}^T \\mathbf{K}_{g,e}^{\\text{loc}} \\mathbf{T} $$\n\n3.  **Assembly of Global Matrices**\nThe global stiffness matrices, $\\mathbf{K}$ and $\\mathbf{K}_g$, for the entire structure are assembled by summing the contributions of each element's global matrix into the corresponding entries of the global matrices. The size of the global matrices is $(3 N_{nodes}) \\times (3 N_{nodes})$, where $N_{nodes}$ is the total number of nodes in the structure.\n\n4.  **Application of Boundary Conditions**\nEssential boundary conditions (prescribed displacements) are enforced by eliminating the rows and columns corresponding to the constrained DOFs from the global matrices. This partitioning results in reduced matrices, $\\mathbf{K}_{\\text{reduced}}$ and $\\mathbf{K}_{g, \\text{reduced}}$, which govern the behavior of the free (unconstrained) DOFs of the system.\n\n5.  **Solution of the Eigenvalue Problem**\nThe condition for buckling, $\\delta^2\\Pi = 0$, leads to the homogeneous system of equations:\n$$ (\\mathbf{K} - \\lambda \\mathbf{K}_g) \\mathbf{u} = 0 \\quad \\implies \\quad \\mathbf{K} \\mathbf{u} = \\lambda \\mathbf{K}_g \\mathbf{u} $$\nAfter applying boundary conditions, we solve the reduced generalized eigenvalue problem:\n$$ \\mathbf{K}_{\\text{reduced}} \\mathbf{u}_{\\text{free}} = \\lambda \\mathbf{K}_{g, \\text{reduced}} \\mathbf{u}_{\\text{free}} $$\nThe eigenvalues $\\lambda$ are the load factors. The critical buckling load factor, $\\lambda_{\\text{cr}}$, is the smallest positive real eigenvalue obtained from this problem. It represents the factor by which the reference axial forces $\\{P_e\\}$ must be multiplied to cause the structure to buckle. The corresponding eigenvector $\\mathbf{u}_{\\text{free}}$ represents the shape of the buckling mode. This problem is solved numerically using standard linear algebra libraries. If the geometric stiffness matrix $\\mathbf{K}_g$ is identically zero (i.e., all reference axial forces are zero), buckling is not defined in this context, and $\\lambda_{\\text{cr}}$ is taken as infinity.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eig\n\ndef get_local_stiffness_matrices(E, A, I, P, L):\n    \"\"\"\n    Constructs the local elastic and geometric stiffness matrices for a 2D Euler-Bernoulli beam element.\n    \n    Args:\n        E (float): Young's modulus\n        A (float): Cross-sectional area\n        I (float): Second moment of area\n        P (float): Compressive axial force\n        L (float): Element length\n        \n    Returns:\n        tuple: A tuple containing the 6x6 local elastic stiffness matrix (K_e_loc) \n               and the 6x6 local geometric stiffness matrix (Kg_e_loc).\n    \"\"\"\n    if L == 0:\n        return np.zeros((6, 6)), np.zeros((6, 6))\n        \n    EA_L = E * A / L\n    EI_L = E * I / L\n    EI_L2 = E * I / L**2\n    EI_L3 = E * I / L**3\n    \n    K_e_loc = np.array([\n        [EA_L, 0, 0, -EA_L, 0, 0],\n        [0, 12*EI_L3, 6*EI_L2, 0, -12*EI_L3, 6*EI_L2],\n        [0, 6*EI_L2, 4*EI_L, 0, -6*EI_L2, 2*EI_L],\n        [-EA_L, 0, 0, EA_L, 0, 0],\n        [0, -12*EI_L3, -6*EI_L2, 0, 12*EI_L3, -6*EI_L2],\n        [0, 6*EI_L2, 2*EI_L, 0, -6*EI_L2, 4*EI_L]\n    ])\n\n    Kg_e_loc = np.zeros((6, 6))\n    if P != 0:\n        P_30L = P / (30 * L)\n        Kg_e_loc = P_30L * np.array([\n            [0, 0, 0, 0, 0, 0],\n            [0, 36, 3*L, 0, -36, 3*L],\n            [0, 3*L, 4*L**2, 0, -3*L, -L**2],\n            [0, 0, 0, 0, 0, 0],\n            [0, -36, -3*L, 0, 36, -3*L],\n            [0, 3*L, -L**2, 0, -3*L, 4*L**2]\n        ])\n    \n    return K_e_loc, Kg_e_loc\n\ndef get_transformation_matrix(phi):\n    \"\"\"\n    Constructs the transformation matrix for a 2D beam element.\n\n    Args:\n        phi (float): Angle of the element with the global X-axis, in radians.\n\n    Returns:\n        numpy.ndarray: The 6x6 transformation matrix T.\n    \"\"\"\n    c = np.cos(phi)\n    s = np.sin(phi)\n    \n    R = np.array([\n        [c, s, 0],\n        [-s, c, 0],\n        [0, 0, 1]\n    ])\n    \n    T = np.zeros((6, 6))\n    T[0:3, 0:3] = R\n    T[3:6, 3:6] = R\n    \n    return T\n\ndef solve_buckling(nodes, elements, bcs):\n    \"\"\"\n    Assembles and solves the linearized buckling eigenvalue problem for a 2D frame.\n    \"\"\"\n    num_nodes = len(nodes)\n    num_dofs = 3 * num_nodes\n    \n    K_global = np.zeros((num_dofs, num_dofs))\n    Kg_global = np.zeros((num_dofs, num_dofs))\n\n    for elem in elements:\n        n1_idx, n2_idx = elem['nodes']\n        n1_coords = nodes[n1_idx]\n        n2_coords = nodes[n2_idx]\n        \n        dx = n2_coords[0] - n1_coords[0]\n        dy = n2_coords[1] - n1_coords[1]\n        \n        L = np.sqrt(dx**2 + dy**2)\n        phi = np.arctan2(dy, dx)\n        \n        E, A, I, P = elem['E'], elem['A'], elem['I'], elem['P']\n        \n        K_loc, Kg_loc = get_local_stiffness_matrices(E, A, I, P, L)\n        T = get_transformation_matrix(phi)\n        \n        K_elem_global = T.T @ K_loc @ T\n        Kg_elem_global = T.T @ Kg_loc @ T\n        \n        dof_indices = np.array([\n            3*n1_idx, 3*n1_idx + 1, 3*n1_idx + 2,\n            3*n2_idx, 3*n2_idx + 1, 3*n2_idx + 2\n        ])\n        \n        ix_grid = np.ix_(dof_indices, dof_indices)\n        K_global[ix_grid] += K_elem_global\n        Kg_global[ix_grid] += Kg_elem_global\n\n    if not np.any(Kg_global):\n        return np.inf\n\n    all_dofs = set(range(num_dofs))\n    constrained_dofs = set(bcs.keys())\n    free_dofs = sorted(list(all_dofs - constrained_dofs))\n    \n    ix_grid_free = np.ix_(free_dofs, free_dofs)\n    K_reduced = K_global[ix_grid_free]\n    Kg_reduced = Kg_global[ix_grid_free]\n    \n    if K_reduced.shape[0] == 0:\n        return np.inf\n        \n    try:\n        eigenvalues = eig(K_reduced, b=Kg_reduced, right=False)\n    except np.linalg.LinAlgError:\n        return np.inf\n\n    real_eigenvalues = eigenvalues[np.isreal(eigenvalues)].real\n    positive_eigenvalues = real_eigenvalues[real_eigenvalues > 1e-9] \n    \n    if len(positive_eigenvalues) == 0:\n        return np.inf\n        \n    lambda_cr = np.min(positive_eigenvalues)\n    return lambda_cr\n\ndef solve():\n    # Define the test cases from the problem statement.\n    L_case1 = 3.0\n    nodes_1 = [(0.0, 0.0), (0.0, L_case1/2.0), (0.0, L_case1)]\n    elements_1 = [\n        {'nodes': (0, 1), 'E': 210e9, 'A': 0.01, 'I': 8e-6, 'P': 1.0},\n        {'nodes': (1, 2), 'E': 210e9, 'A': 0.01, 'I': 8e-6, 'P': 1.0}\n    ]\n    # Case 1: Pinned-pinned column\n    bcs_1 = {0: 0, 1: 0, 6: 0, 7: 0}\n\n    # Case 2: Fixed-fixed column\n    bcs_2 = {0: 0, 1: 0, 2: 0, 6: 0, 7: 0, 8: 0}\n\n    # Case 3: Single-bay frame\n    L_case3, B_case3 = 3.0, 4.0\n    nodes_3 = [\n        (0.0, 0.0), (0.0, L_case3/2.0), (0.0, L_case3),\n        (B_case3, 0.0), (B_case3, L_case3/2.0), (B_case3, L_case3)\n    ]\n    elements_3 = [\n        {'nodes': (0, 1), 'E': 210e9, 'A': 0.01, 'I': 8e-6, 'P': 1.0},\n        {'nodes': (1, 2), 'E': 210e9, 'A': 0.01, 'I': 8e-6, 'P': 1.0},\n        {'nodes': (3, 4), 'E': 210e9, 'A': 0.01, 'I': 8e-6, 'P': 1.0},\n        {'nodes': (4, 5), 'E': 210e9, 'A': 0.01, 'I': 8e-6, 'P': 1.0},\n        {'nodes': (2, 5), 'E': 210e9, 'A': 0.01, 'I': 1.6e-5, 'P': 0.0}\n    ]\n    bcs_3 = {0: 0, 1: 0, 2: 0, 9: 0, 10: 0, 11: 0}\n    \n    test_cases = [\n        (nodes_1, elements_1, bcs_1),\n        (nodes_1, elements_1, bcs_2),\n        (nodes_3, elements_3, bcs_3)\n    ]\n\n    results = []\n    for case in test_cases:\n        nodes, elements, bcs = case\n        result = solve_buckling(nodes, elements, bcs)\n        results.append(f\"{result:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}