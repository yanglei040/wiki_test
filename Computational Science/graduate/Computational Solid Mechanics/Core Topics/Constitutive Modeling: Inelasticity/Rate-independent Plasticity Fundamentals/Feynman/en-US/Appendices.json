{
    "hands_on_practices": [
        {
            "introduction": "The return-mapping algorithm is a cornerstone of modern computational plasticity, forming the basis for stress updates in countless finite element simulations. This first exercise provides hands-on practice in implementing this fundamental algorithm for the widely used von Mises ($J_2$) plasticity model with linear isotropic hardening . By testing your implementation against standard loading paths and verifying key physical principles such as plastic incompressibility, non-negative dissipation, and yield consistency, you will build a robust and reliable tool for material analysis.",
            "id": "3593035",
            "problem": "Consider a small-strain, rate-independent, isotropic elasto-plastic material governed by the second invariant of the deviatoric stress (commonly called $J_2$ plasticity) with linear isotropic hardening. The elastic response is defined by the isotropic linear elasticity tensor with Lamé parameters $ \\lambda $ and $ \\mu $ related to the Young’s modulus $ E $ and Poisson’s ratio $ \\nu $ by $ \\mu = \\dfrac{E}{2(1+\\nu)} $ and $ \\lambda = \\dfrac{E \\nu}{(1+\\nu)(1-2 \\nu)} $. The material behavior is expressed using the additive strain decomposition $ \\varepsilon = \\varepsilon^e + \\varepsilon^p $, where $ \\varepsilon $ is the total small-strain tensor, $ \\varepsilon^e $ is the elastic strain tensor, and $ \\varepsilon^p $ is the plastic strain tensor. The Cauchy stress tensor is $ \\sigma = 2 \\mu \\, \\varepsilon^e + \\lambda \\, \\mathrm{tr}(\\varepsilon^e) I $, where $ I $ is the second-order identity tensor.\n\nPlastic yielding is determined by the von Mises yield function $ f(\\sigma, \\alpha) = \\sigma_{\\mathrm{eq}}(\\sigma) - \\sigma_y(\\alpha) $, where $ \\sigma_{\\mathrm{eq}}(\\sigma) = \\sqrt{\\dfrac{3}{2}} \\, \\| s \\| $, $ s = \\sigma - \\dfrac{1}{3} \\mathrm{tr}(\\sigma) I $ is the deviatoric stress, $ \\| s \\| $ is the Frobenius norm of $ s $, and $ \\sigma_y(\\alpha) = \\sigma_{y0} + H \\alpha $ is the current yield stress expressed through the accumulated equivalent plastic strain $ \\alpha $ with initial yield stress $ \\sigma_{y0} $ and hardening modulus $ H $. The plastic flow is associative, with the plastic strain rate $ \\dot{\\varepsilon}^p $ aligned with the gradient of the yield function with respect to stress, and the accumulated equivalent plastic strain rate $ \\dot{\\alpha} $ defined by $ \\dot{\\alpha} = \\sqrt{\\dfrac{2}{3}} \\, \\| \\dot{\\varepsilon}^p \\| $. The evolution must satisfy the classical Kuhn–Tucker conditions for rate-independent plasticity: $ f \\le 0 $, $ \\dot{\\lambda} \\ge 0 $, $ \\dot{\\lambda} f = 0 $, and the consistency condition when yielding occurs. Here $ \\dot{\\lambda} $ is the plastic multiplier.\n\nYour task is to derive, from these fundamental principles, a backward-Euler return-mapping update for a single constant strain increment in three dimensions, and implement it to advance the state through prescribed loading paths. The update must ensure plastic incompressibility $ \\mathrm{tr}(\\Delta \\varepsilon^p) = 0 $ whenever plastic flow occurs, and must satisfy the mechanical dissipation inequality $ \\Delta D = \\sigma : \\Delta \\varepsilon^p \\ge 0 $ for each increment. You must also implement checks to verify the yield consistency in the final state of each path.\n\nMaterial parameters are given as $ E = 210000 $ (in megapascals, MPa), $ \\nu = 0.3 $ (dimensionless), $ \\sigma_{y0} = 250 $ (in MPa), and $ H = 1000 $ (in MPa). Strains are dimensionless. The stress must be computed in megapascals (MPa). Angles, if any are needed for internal checks, must be handled in radians.\n\nImplement the algorithm and simulate the following three benchmark loading paths, each specified as a sequence of constant strain increments applied to the strain tensor $ \\varepsilon $:\n\n- Uniaxial tension path: apply $ 20 $ increments, each $ \\Delta \\varepsilon = \\mathrm{diag}(10^{-4}, 0, 0) $.\n- Pure shear path: apply $ 20 $ increments, each $ \\Delta \\varepsilon $ having components $ \\Delta \\varepsilon_{12} = \\Delta \\varepsilon_{21} = 10^{-4} $ and all other components zero.\n- Nonproportional biaxial path: first apply $ 15 $ increments of $ \\Delta \\varepsilon = \\mathrm{diag}(10^{-4}, 0, 0) $, then apply $ 5 $ increments of $ \\Delta \\varepsilon = \\mathrm{diag}(0, 10^{-4}, 0) $.\n\nFor each path, after completing all increments, compute and report three boolean checks:\n\n1. Plastic incompressibility check: $ |\\mathrm{tr}(\\varepsilon^p_{\\mathrm{final}})| \\le 10^{-10} $.\n2. Nonnegative dissipation check: the total accumulated plastic dissipation $ \\sum \\sigma_{n+1} : \\Delta \\varepsilon^p \\ge -10^{-12} $.\n3. Yield consistency check at the final state: if the final accumulated equivalent plastic strain $ \\alpha_{\\mathrm{final}} > 10^{-12} $, then $ | f(\\sigma_{\\mathrm{final}}, \\alpha_{\\mathrm{final}}) | \\le 10^{-10} $; otherwise (purely elastic final state), $ f(\\sigma_{\\mathrm{final}}, \\alpha_{\\mathrm{final}}) \\le 10^{-10} $.\n\nYour program should produce a single line of output containing the nine boolean results for the three paths in the order described above, aggregated as a comma-separated list enclosed in square brackets, for example $ [\\mathrm{result}_1, \\mathrm{result}_2, \\mathrm{result}_3, \\ldots, \\mathrm{result}_9] $. No other output should be produced. All computations of stress must be performed in megapascals (MPa). The booleans are dimensionless.",
            "solution": "The problem requires the derivation and implementation of a numerical algorithm to model the behavior of a small-strain, rate-independent, isotropic elasto-plastic material. The model is based on the second invariant of the deviatoric stress, $J_2$, and incorporates linear isotropic hardening. The algorithm will be used to simulate material response under specified loading paths. The core of the solution lies in the implementation of a backward-Euler return-mapping scheme to integrate the constitutive equations over a discrete strain increment.\n\nThe state of the material at a discrete time step $n$ is defined by the total strain tensor $\\varepsilon_n$, the plastic strain tensor $\\varepsilon^p_n$, and the scalar accumulated equivalent plastic strain $\\alpha_n$. Given this state and a prescribed total strain increment $\\Delta\\varepsilon$, the task is to compute the state at step $n+1$. The total strain at the end of the increment is given by $\\varepsilon_{n+1} = \\varepsilon_n + \\Delta\\varepsilon$. The algorithm consists of an elastic predictor step followed by a plastic corrector step if yielding is detected.\n\nThe first step is the elastic predictor. We assume the entire strain increment is purely elastic, which implies that the plastic state variables do not change: $\\Delta\\varepsilon^p = 0$ and $\\Delta\\alpha=0$. The elastic strain at the end of the step, termed the trial elastic strain $\\varepsilon^{e, \\text{trial}}_{n+1}$, is computed as:\n$$ \\varepsilon^{e, \\text{trial}}_{n+1} = \\varepsilon_{n+1} - \\varepsilon^p_n = (\\varepsilon_n + \\Delta\\varepsilon) - \\varepsilon^p_n = \\varepsilon^e_n + \\Delta\\varepsilon $$\nThe trial stress, $\\sigma^{\\text{trial}}_{n+1}$, is then calculated using the isotropic linear elastic constitutive law:\n$$ \\sigma^{\\text{trial}}_{n+1} = 2\\mu \\varepsilon^{e, \\text{trial}}_{n+1} + \\lambda \\mathrm{tr}(\\varepsilon^{e, \\text{trial}}_{n+1}) I $$\nwhere $\\mu = \\frac{E}{2(1+\\nu)}$ and $\\lambda = \\frac{E \\nu}{(1+\\nu)(1-2 \\nu)}$ are the Lamé parameters, and $I$ is the second-order identity tensor. The trial value for the accumulated plastic strain remains unchanged from the previous step, $\\alpha^{\\text{trial}}_{n+1} = \\alpha_n$.\n\nThe second step is the yield condition check. We evaluate the von Mises yield function $f(\\sigma, \\alpha) = \\sigma_{\\mathrm{eq}}(\\sigma) - \\sigma_y(\\alpha)$ at the trial state:\n$$ f^{\\text{trial}} = f(\\sigma^{\\text{trial}}_{n+1}, \\alpha_n) = \\sigma_{\\mathrm{eq}}(\\sigma^{\\text{trial}}_{n+1}) - \\sigma_y(\\alpha_n) $$\nHere, the equivalent stress is $\\sigma_{\\mathrm{eq}}(\\sigma^{\\text{trial}}_{n+1}) = \\sqrt{\\frac{3}{2}} \\| s^{\\text{trial}}_{n+1} \\|$, where $s^{\\text{trial}}_{n+1} = \\sigma^{\\text{trial}}_{n+1} - \\frac{1}{3} \\mathrm{tr}(\\sigma^{\\text{trial}}_{n+1}) I$ is the deviatoric part of the trial stress. The yield stress is given by the linear hardening law $\\sigma_y(\\alpha_n) = \\sigma_{y0} + H\\alpha_n$. If $f^{\\text{trial}} \\le 0$, the elastic assumption is valid. The trial state becomes the final state for the increment: $\\sigma_{n+1} = \\sigma^{\\text{trial}}_{n+1}$, $\\varepsilon^p_{n+1} = \\varepsilon^p_n$, and $\\alpha_{n+1} = \\alpha_n$.\n\nIf $f^{\\text{trial}} > 0$, the material has yielded, and a plastic correction is necessary. This is the return-mapping stage. The plastic flow is governed by the associative flow rule, which, when discretized using the backward-Euler scheme, gives the plastic strain increment $\\Delta\\varepsilon^p = \\varepsilon^p_{n+1} - \\varepsilon^p_n$ as:\n$$ \\Delta\\varepsilon^p = \\Delta\\gamma \\frac{\\partial f}{\\partial\\sigma}\\bigg|_{\\sigma_{n+1}} = \\Delta\\gamma \\sqrt{\\frac{3}{2}} \\frac{s_{n+1}}{\\|s_{n+1}\\|} $$\nwhere $\\Delta\\gamma \\ge 0$ is the plastic multiplier increment. The evolution of the accumulated plastic strain is given by $\\Delta\\alpha = \\sqrt{\\frac{2}{3}} \\| \\Delta\\varepsilon^p \\|$. A crucial consequence of the flow rule for $J_2$ plasticity is that $\\Delta\\alpha = \\Delta\\gamma$. This comes from the fact that the norm of the gradient $\\frac{\\partial f}{\\partial\\sigma}$ is unity. A further consequence is plastic incompressibility, $\\mathrm{tr}(\\Delta\\varepsilon^p)=0$, as the gradient is purely deviatoric.\n\nThe stress at step $n+1$ is related to the trial stress by $\\sigma_{n+1} = \\sigma^{\\text{trial}}_{n+1} - 2\\mu\\Delta\\varepsilon^p$. Since $\\mathrm{tr}(\\Delta\\varepsilon^p)=0$, the hydrostatic stress is unaffected by the plastic correction, i.e., $\\mathrm{tr}(\\sigma_{n+1}) = \\mathrm{tr}(\\sigma^{\\text{trial}}_{n+1})$. The correction applies only to the deviatoric part: $s_{n+1} = s^{\\text{trial}}_{n+1} - 2\\mu\\Delta\\varepsilon^p$. Substituting the flow rule for $\\Delta\\varepsilon^p$:\n$$ s_{n+1} = s^{\\text{trial}}_{n+1} - 2\\mu \\Delta\\gamma \\sqrt{\\frac{3}{2}} \\frac{s_{n+1}}{\\|s_{n+1}\\|} $$\nThis equation reveals that $s_{n+1}$ is collinear with $s^{\\text{trial}}_{n+1}$. By rearranging and taking the norm of both sides, we find the relation:\n$$ \\|s_{n+1}\\| + 2\\mu \\Delta\\gamma \\sqrt{\\frac{3}{2}} = \\|s^{\\text{trial}}_{n+1}\\| $$\nMultiplying by $\\sqrt{3/2}$ and substituting the definition of equivalent stress yields:\n$$ \\sigma_{\\mathrm{eq}}(\\sigma_{n+1}) + 3\\mu\\Delta\\gamma = \\sigma_{\\mathrm{eq}}(\\sigma^{\\text{trial}}_{n+1}) $$\nThe final state must satisfy the consistency condition, $f(\\sigma_{n+1}, \\alpha_{n+1})=0$, which requires $\\sigma_{\\mathrm{eq}}(\\sigma_{n+1}) = \\sigma_y(\\alpha_{n+1}) = \\sigma_y(\\alpha_n) + H\\Delta\\alpha$. Using $\\Delta\\alpha = \\Delta\\gamma$, we get $\\sigma_{\\mathrm{eq}}(\\sigma_{n+1}) = \\sigma_y(\\alpha_n) + H\\Delta\\gamma$. Substituting this into the previous equation allows us to solve for $\\Delta\\gamma$:\n$$ (\\sigma_y(\\alpha_n) + H\\Delta\\gamma) + 3\\mu\\Delta\\gamma = \\sigma_{\\mathrm{eq}}(\\sigma^{\\text{trial}}_{n+1}) $$\n$$ \\sigma_{\\mathrm{eq}}(\\sigma^{\\text{trial}}_{n+1}) - \\sigma_y(\\alpha_n) = (3\\mu + H)\\Delta\\gamma $$\nThe left side is $f^{\\text{trial}}$. Thus, the plastic multiplier is found in closed form:\n$$ \\Delta\\gamma = \\frac{f^{\\text{trial}}}{3\\mu + H} $$\nWith $\\Delta\\gamma$ determined, the state variables are updated.\n1. Update internal hardening variable: $\\alpha_{n+1} = \\alpha_n + \\Delta\\gamma$.\n2. Compute plastic strain increment. Since $s_{n+1}$ and $s^{\\text{trial}}_{n+1}$ are collinear, we can use the direction of $s^{\\text{trial}}_{n+1}$:\n   $$ \\Delta\\varepsilon^p = \\Delta\\gamma \\sqrt{\\frac{3}{2}} \\frac{s^{\\text{trial}}_{n+1}}{\\|s^{\\text{trial}}_{n+1}\\|} $$\n3. Update total plastic strain: $\\varepsilon^p_{n+1} = \\varepsilon^p_n + \\Delta\\varepsilon^p$.\n4. Update the stress tensor: $\\sigma_{n+1} = \\sigma^{\\text{trial}}_{n+1} - 2\\mu\\Delta\\varepsilon^p$.\n\nThis algorithm is implemented for the given loading paths. After all increments for a path are completed, the final state is subjected to three checks: plastic incompressibility $|\\mathrm{tr}(\\varepsilon^p_{\\mathrm{final}})| \\le 10^{-10}$, nonnegative total dissipation $\\sum \\sigma_{n+1} : \\Delta \\varepsilon^p \\ge -10^{-12}$, and yield consistency $| f(\\sigma_{\\mathrm{final}}, \\alpha_{\\mathrm{final}}) | \\le 10^{-10}$ if plastic flow occurred ($\\alpha_{\\mathrm{final}} > 10^{-12}$), or $f(\\sigma_{\\mathrm{final}}, \\alpha_{\\mathrm{final}}) \\le 10^{-10}$ otherwise.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the elasto-plastic problem for three loading paths and reports on the validation checks.\n    \"\"\"\n    \n    # Material parameters (stress in MPa)\n    E = 210000.0\n    nu = 0.3\n    sig_y0 = 250.0\n    H = 1000.0\n\n    # Derived elastic parameters\n    mu = E / (2.0 * (1.0 + nu))\n    lmbda = E * nu / ((1.0 + nu) * (1.0 - 2.0 * nu))\n    \n    # Identity tensor\n    I = np.identity(3)\n\n    # Define loading paths\n    # Path 1: Uniaxial tension\n    uniaxial_path = [\n        (np.diag([1e-4, 0.0, 0.0]), 20)\n    ]\n    \n    # Path 2: Pure shear\n    shear_increment = np.zeros((3, 3))\n    shear_increment[0, 1] = 1e-4\n    shear_increment[1, 0] = 1e-4\n    pure_shear_path = [\n        (shear_increment, 20)\n    ]\n    \n    # Path 3: Nonproportional biaxial path\n    nonproportional_path = [\n        (np.diag([1e-4, 0.0, 0.0]), 15),\n        (np.diag([0.0, 1e-4, 0.0]), 5)\n    ]\n    \n    paths = [uniaxial_path, pure_shear_path, nonproportional_path]\n    \n    final_results = []\n\n    for path in paths:\n        # Initialize state variables\n        eps_n = np.zeros((3, 3))\n        eps_p_n = np.zeros((3, 3))\n        alpha_n = 0.0\n        \n        # Initialize check accumulators\n        total_dissipation = 0.0\n\n        for segment in path:\n            delta_eps_template, num_increments = segment\n            for _ in range(num_increments):\n                # Current state is (eps_n, eps_p_n, alpha_n)\n                # Apply strain increment\n                eps_n1 = eps_n + delta_eps_template\n                \n                # --- Elasto-plastic update algorithm (return mapping) ---\n                \n                # 1. Elastic predictor\n                eps_e_trial = eps_n1 - eps_p_n\n                tr_eps_e_trial = np.trace(eps_e_trial)\n                sig_trial = lmbda * tr_eps_e_trial * I + 2.0 * mu * eps_e_trial\n                \n                s_trial = sig_trial - (np.trace(sig_trial) / 3.0) * I\n                norm_s_trial = np.linalg.norm(s_trial)\n                \n                # Handle case where s_trial is zero to avoid division by zero\n                if norm_s_trial < 1e-12:\n                     sig_eq_trial = 0.0\n                else:\n                    sig_eq_trial = np.sqrt(3.0 / 2.0) * norm_s_trial\n\n                # 2. Yield check\n                sig_y_n = sig_y0 + H * alpha_n\n                f_trial = sig_eq_trial - sig_y_n\n\n                delta_eps_p = np.zeros((3, 3))\n                if f_trial <= 1e-12:  # Elastic step (with tolerance)\n                    eps_p_n1 = eps_p_n\n                    alpha_n1 = alpha_n\n                    sig_n1 = sig_trial\n                else:  # 3. Plastic corrector\n                    delta_gamma = f_trial / (3.0 * mu + H)\n                    \n                    alpha_n1 = alpha_n + delta_gamma\n                    \n                    # Normal to the yield surface at trial state\n                    N_trial = np.sqrt(3.0 / 2.0) * s_trial / norm_s_trial\n                    \n                    delta_eps_p = delta_gamma * N_trial\n                    eps_p_n1 = eps_p_n + delta_eps_p\n                    \n                    # Update stress (radial return)\n                    sig_n1 = sig_trial - 2.0 * mu * delta_eps_p\n\n                # Accumulate dissipation for the current increment\n                dissipation_inc = np.sum(sig_n1 * delta_eps_p)\n                total_dissipation += dissipation_inc\n\n                # Update state for the next increment\n                eps_n = eps_n1\n                eps_p_n = eps_p_n1\n                alpha_n = alpha_n1\n\n        # --- Post-simulation checks for the completed path ---\n        eps_p_final = eps_p_n\n        alpha_final = alpha_n\n        \n        # Recalculate final stress from final strains for consistency\n        eps_e_final = eps_n - eps_p_final\n        sig_final = lmbda * np.trace(eps_e_final) * I + 2.0 * mu * eps_e_final\n\n        # Check 1: Plastic incompressibility\n        check1 = abs(np.trace(eps_p_final)) <= 1e-10\n        final_results.append(check1)\n        \n        # Check 2: Nonnegative dissipation\n        check2 = total_dissipation >= -1e-12\n        final_results.append(check2)\n\n        # Check 3: Yield consistency\n        s_final = sig_final - (np.trace(sig_final) / 3.0) * I\n        norm_s_final = np.linalg.norm(s_final)\n        sig_eq_final = np.sqrt(3.0 / 2.0) * norm_s_final if norm_s_final > 1e-12 else 0.0\n\n        sig_y_final = sig_y0 + H * alpha_final\n        f_final = sig_eq_final - sig_y_final\n        \n        if alpha_final > 1e-12: # Plastic state\n            check3 = abs(f_final) <= 1e-10\n        else: # Elastic state\n            check3 = f_final <= 1e-10\n        final_results.append(check3)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "Building on the basics of isotropic plasticity, this practice explores kinematic hardening, which is essential for modeling phenomena like the Bauschinger effect in materials under cyclic loading. You will derive and implement a return-mapping scheme for a one-dimensional model that includes a backstress state variable, $\\alpha$, to track the translation of the yield surface . This exercise critically highlights the importance of algorithmic consistency by contrasting a rigorous, implicit update with a simplified \"lagged\" scheme, thereby revealing subtle but significant sources of error in numerical simulations.",
            "id": "3593012",
            "problem": "Consider small-strain, uniaxial, rate-independent plasticity with linear kinematic hardening. You will derive, implement, and test a two-substep strain-controlled update algorithm that uses an elastic predictor/plastic corrector return-mapping scheme. The focus is to reveal how a nonzero backstress shifts admissibility in the second substep and to quantify the correction error if the backstress is treated in a lagged fashion.\n\nStart from the following fundamental base:\n- Kinematics: The total strain is additively decomposed into elastic and plastic parts, $\\,\\varepsilon = \\varepsilon^{\\mathrm{e}} + \\varepsilon^{\\mathrm{p}}\\,.$\n- Free energy: Postulate a quadratic Helmholtz free energy density $\\,\\psi(\\varepsilon, \\varepsilon^{\\mathrm{p}}, \\alpha) = \\tfrac{1}{2} E \\left(\\varepsilon - \\varepsilon^{\\mathrm{p}}\\right)^{2} + \\tfrac{1}{2H}\\,\\alpha^{2}\\,,$ where $\\,E\\,$ is Young’s modulus and $\\,H\\,$ is the linear kinematic hardening modulus. Assume small strains.\n- Constitutive force conjugacy: Stress $\\,\\sigma\\,$ is work-conjugate to total strain $\\,\\varepsilon\\,$, plastic strain $\\,\\varepsilon^{\\mathrm{p}}\\,$ is dissipative with an associated plastic multiplier $\\,\\dot{\\gamma}\\ge 0\\,$, and the backstress $\\,\\alpha\\,$ is work-conjugate to its own kinematic internal variable. Use the Clausius–Duhem inequality to ensure nonnegative dissipation and adopt standard associative normality for rate-independent plasticity.\n- Yield function: Use the one-dimensional shifted von Mises-type criterion $\\,f(\\sigma,\\alpha) = \\lvert \\sigma - \\alpha \\rvert - \\sigma_{y}\\le 0\\,$, where $\\,\\sigma_{y}\\,$ is the initial yield stress. Impose the Karush–Kuhn–Tucker complementarity conditions $\\,\\dot{\\gamma}\\ge 0\\,$, $\\,f\\le 0\\,$, and $\\,\\dot{\\gamma}\\,f = 0\\,$, and the consistency condition $\\,\\dot{\\gamma}>0 \\Rightarrow \\dot{f}=0\\,$. Adopt associative flow in one dimension so that the plastic flow direction is $\\,\\mathrm{sign}(\\sigma-\\alpha)\\,$. For linear kinematic hardening in one dimension, take $\\,\\dot{\\alpha} = H\\,\\dot{\\varepsilon}^{\\mathrm{p}}\\,.$\n\nYour tasks:\n1) From the above base, derive the one-dimensional return-mapping equations for a strain-controlled substep update from time $\\,t_{n}\\,$ to $\\,t_{n+1}\\,.$ Express the elastic predictor (trial state) and the plastic corrector with a scalar plastic multiplier increment $\\,\\Delta\\gamma\\,$. Ensure that for plastic loading $\\,\\Delta\\gamma>0\\,$ the updated state satisfies $\\,f(\\sigma_{n+1},\\alpha_{n+1})=0\\,$ exactly. Do not assume any shortcut formulas; derive them from the stated principles.\n2) Define a “lagged backstress” scheme in which the backstress is held fixed at its substep-start value in the yield and consistency equations during the plastic correction, while still updating the stress via the elastic modulus. After solving for the plastic multiplier in this lagged manner, update the backstress at the end of the substep using the obtained plastic strain increment. Quantify the inconsistency of this lagged scheme by evaluating the yield residual $\\,r = \\lvert \\sigma_{n+1}^{\\mathrm{lag}} - \\alpha_{n+1}^{\\mathrm{lag}} \\rvert - \\sigma_{y}\\,$ using the updated (not frozen) backstress and compare the final stress with the consistent solution.\n3) Implement a two-substep loading within a single step. The first substep must be elastic. In the second substep, the trial state must violate admissibility due to the presence of a nonzero backstress, triggering plastic correction.\n\nPhysical and numerical details:\n- Use units of stress in megapascals (MPa) and strain as dimensionless. Express any stress-like output in MPa and any strain-like output as a pure number. When reporting a relative error, report it as a decimal (not a percentage).\n- Angle units are not applicable here.\n\nPrecisely define the two-substep update per test case as follows:\n- Known at the start: $\\,E\\,$ (MPa), $\\,\\sigma_{y}\\,$ (MPa), $\\,H\\,$ (MPa), $\\,\\varepsilon_{0}\\,$, $\\,\\varepsilon^{\\mathrm{p}}_{0}\\,$, and $\\,\\alpha_{0}\\,$.\n- Substep $\\,1\\,$: apply $\\,\\Delta\\varepsilon_{1}\\,$, compute the elastic predictor $\\,\\sigma^{\\mathrm{tr}}_{1} = \\sigma_{0} + E\\,\\Delta\\varepsilon_{1}\\,$ with $\\,\\sigma_{0} = E(\\varepsilon_{0} - \\varepsilon^{\\mathrm{p}}_{0})\\,$, check admissibility, and update the state. This substep must remain elastic for all test cases.\n- Substep $\\,2\\,$: apply $\\,\\Delta\\varepsilon_{2}\\,$ to the updated state from substep $\\,1\\,$. Compute the trial state and detect yielding. If plastic, compute:\n  - The consistent solution $\\,(\\Delta\\gamma^{\\mathrm{cons}}, \\sigma_{2}^{\\mathrm{cons}}, \\alpha_{2}^{\\mathrm{cons}})\\,$ using the derived return mapping that enforces $\\,f(\\sigma_{2}^{\\mathrm{cons}},\\alpha_{2}^{\\mathrm{cons}})=0\\,$.\n  - The lagged-backstress solution $\\,(\\Delta\\gamma^{\\mathrm{lag}}, \\sigma_{2}^{\\mathrm{lag}}, \\alpha_{2}^{\\mathrm{lag}})\\,$ using the frozen-backstress evaluation during the corrector and updating $\\,\\alpha\\,$ only after solving for $\\,\\Delta\\gamma^{\\mathrm{lag}}\\,$.\n  - The yield residual of the lagged update $\\,r = \\lvert \\sigma_{2}^{\\mathrm{lag}} - \\alpha_{2}^{\\mathrm{lag}} \\rvert - \\sigma_{y}\\,$ in MPa, and the relative stress error $\\,e_{\\sigma} = (\\sigma_{2}^{\\mathrm{lag}} - \\sigma_{2}^{\\mathrm{cons}})/\\sigma_{2}^{\\mathrm{cons}}\\,$ as a decimal.\n\nTest suite:\nProvide a program that computes the four scalars per test case: $\\,\\Delta\\gamma^{\\mathrm{cons}}\\,$, $\\,\\Delta\\gamma^{\\mathrm{lag}}\\,$, $\\,r\\,$, and $\\,e_{\\sigma}\\,$ for each set below. Use these exact values.\n\n- Case $\\,\\mathrm{A}\\,$ (happy path, tensile with negative backstress so admissibility fails in substep $\\,2\\,$ due to kinematic shift):\n  - $\\,E = 210000\\,$ MPa, $\\,\\sigma_{y} = 250\\,$ MPa, $\\,H = 5000\\,$ MPa\n  - $\\,\\alpha_{0} = -80\\,$ MPa, $\\,\\varepsilon^{\\mathrm{p}}_{0} = -0.016\\,$, $\\,\\varepsilon_{0} = -0.015285714285714\\,$\n  - $\\,\\Delta\\varepsilon_{1} = 0.00002\\,$, $\\,\\Delta\\varepsilon_{2} = 0.00043238\\,$\n\n- Case $\\,\\mathrm{B}\\,$ (reverse loading boundary-like case, compressive trial is admissible without backstress but fails due to positive backstress):\n  - $\\,E = 70000\\,$ MPa, $\\,\\sigma_{y} = 150\\,$ MPa, $\\,H = 700\\,$ MPa\n  - $\\,\\alpha_{0} = 120\\,$ MPa, $\\,\\varepsilon^{\\mathrm{p}}_{0} = 0.171428571428571\\,$, $\\,\\varepsilon_{0} = 0.171428571428571\\,$\n  - $\\,\\Delta\\varepsilon_{1} = -0.000285714285714\\,$, $\\,\\Delta\\varepsilon_{2} = -0.001714285714286\\,$\n\n- Case $\\,\\mathrm{C}\\,$ (large kinematic hardening modulus relative to elasticity, small consistent correction and observable lagging error):\n  - $\\,E = 100000\\,$ MPa, $\\,\\sigma_{y} = 300\\,$ MPa, $\\,H = 200000\\,$ MPa\n  - $\\,\\alpha_{0} = -50\\,$ MPa, $\\,\\varepsilon^{\\mathrm{p}}_{0} = -0.00025\\,$, $\\,\\varepsilon_{0} = 0.00215\\,$\n  - $\\,\\Delta\\varepsilon_{1} = 0.00005\\,$, $\\,\\Delta\\varepsilon_{2} = 0.0002\\,$\n\nAnswer specification:\n- For each case, output the list $[\\Delta\\gamma^{\\mathrm{cons}}, \\Delta\\gamma^{\\mathrm{lag}}, r, e_{\\sigma}]$, where $\\,\\Delta\\gamma^{\\mathrm{cons}}\\,$ and $\\,\\Delta\\gamma^{\\mathrm{lag}}\\,$ are dimensionless, $\\,r\\,$ is in MPa, and $\\,e_{\\sigma}\\,$ is a decimal (dimensionless).\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The line must be the Python-style list of the three case-result lists, for example, $[\\,[\\cdots], [\\cdots], [\\cdots]\\,]$. Round each printed float to a reasonable number of decimal places so that small differences are visible (for instance, $10^{-12}$ precision is acceptable).",
            "solution": "The problem requires the derivation and implementation of a return-mapping algorithm for one-dimensional, rate-independent plasticity with linear kinematic hardening. The analysis will compare a fully consistent implicit update with a simplified \"lagged backstress\" explicit update.\n\n### 1. Constitutive Framework\n\nThe foundation of the model is a thermodynamically consistent framework. The state of the material is described by the total strain $\\,\\varepsilon\\,$ and two internal variables: the plastic strain $\\,\\varepsilon^{\\mathrm{p}}\\,$ and a scalar kinematic hardening variable, which for linear hardening is linearly related to the backstress $\\,\\alpha\\,$.\n\n**Free Energy and State Variables:**\nThe specified Helmholtz free energy density is:\n$$ \\psi(\\varepsilon, \\varepsilon^{\\mathrm{p}}, \\alpha) = \\frac{1}{2} E \\left(\\varepsilon - \\varepsilon^{\\mathrm{p}}\\right)^{2} + \\frac{1}{2H}\\,\\alpha^{2} $$\nwhere $\\,E\\,$ is Young's modulus and $\\,H\\,$ is the kinematic hardening modulus. The term $\\,\\varepsilon^{\\mathrm{e}} = \\varepsilon - \\varepsilon^{\\mathrm{p}}\\,$ is the elastic strain.\n\n**Thermodynamic Forces:**\nThe constitutive relations for the stress $\\,\\sigma\\,$ and the thermodynamic forces are derived by differentiating the free energy with respect to their conjugate state variables.\nThe stress $\\,\\sigma\\,$ is conjugate to the total strain $\\,\\varepsilon\\,$:\n$$ \\sigma = \\frac{\\partial \\psi}{\\partial \\varepsilon} = E (\\varepsilon - \\varepsilon^{\\mathrm{p}}) = E \\varepsilon^{\\mathrm{e}} $$\nThis is Hooke's Law. The dissipation inequality, derived from the Clausius-Duhem inequality, dictates the evolution of internal variables. The dissipation rate $\\,\\mathcal{D}\\,$ must be non-negative:\n$$ \\mathcal{D} = \\sigma \\dot{\\varepsilon}^{\\mathrm{p}} - \\frac{\\partial \\psi}{\\partial \\alpha}\\dot{\\alpha} \\ge 0 $$\nThe problem defines the hardening law as $\\,\\dot{\\alpha} = H \\dot{\\varepsilon}^{\\mathrm{p}}\\,$. Substituting this and $\\,\\frac{\\partial \\psi}{\\partial \\alpha} = \\frac{\\alpha}{H}\\,$ into the dissipation inequality gives:\n$$ \\mathcal{D} = \\sigma \\dot{\\varepsilon}^{\\mathrm{p}} - \\left(\\frac{\\alpha}{H}\\right) (H \\dot{\\varepsilon}^{\\mathrm{p}}) = (\\sigma - \\alpha) \\dot{\\varepsilon}^{\\mathrm{p}} \\ge 0 $$\nThe term $\\,\\xi = \\sigma - \\alpha\\,$ is the effective stress, which is the thermodynamic driving force for plastic flow.\n\n**Plastic Flow and Yield Condition:**\nFor rate-independent plasticity, flow occurs only when a yield criterion is met. The yield function is given as:\n$$ f(\\sigma, \\alpha) = \\lvert \\sigma - \\alpha \\rvert - \\sigma_{y} = \\lvert \\xi \\rvert - \\sigma_{y} \\le 0 $$\nwhere $\\,\\sigma_{y}\\,$ is the initial yield stress. Plastic flow is governed by the Karush-Kuhn-Tucker (KKT) conditions:\n$$ \\dot{\\gamma} \\ge 0, \\quad f(\\sigma, \\alpha) \\le 0, \\quad \\dot{\\gamma} f(\\sigma, \\alpha) = 0 $$\nwhere $\\,\\dot{\\gamma}\\,$ is the plastic multiplier rate. An associative flow rule is adopted, linking the plastic strain rate to the yield function:\n$$ \\dot{\\varepsilon}^{\\mathrm{p}} = \\dot{\\gamma} \\frac{\\partial f}{\\partial \\sigma} = \\dot{\\gamma} \\, \\mathrm{sign}(\\sigma - \\alpha) $$\nThe consistency condition requires that during plastic flow ($\\,\\dot{\\gamma} > 0\\,$), the state must remain on the yield surface ($\\,f=0\\,$), which implies $\\,\\dot{f}=0\\,$.\n\n### 2. Discretized Update Algorithm: Return Mapping\n\nWe employ a backward Euler integration scheme for a strain-controlled time step from $\\,t_{n}\\,$ to $\\,t_{n+1}\\,$. The state at time $\\,t_n\\,$ ($\\,\\varepsilon_n, \\varepsilon^{\\mathrm{p}}_n, \\alpha_n\\,$) is known, and the total strain at time $\\,t_{n+1} = t_n + \\Delta t\\,$ is prescribed.\n\n**Step 1: Elastic Predictor (Trial State)**\nFirst, we assume the entire strain increment $\\,\\Delta\\varepsilon = \\varepsilon_{n+1} - \\varepsilon_n\\,$ is accommodated elastically.\n- The plastic strain and backstress are frozen: $\\,\\varepsilon^{\\mathrm{p}}_{n+1, \\mathrm{tr}} = \\varepsilon^{\\mathrm{p}}_n\\,$ and $\\,\\alpha_{n+1, \\mathrm{tr}} = \\alpha_n\\,$.\n- The trial stress is computed:\n  $$ \\sigma_{n+1}^{\\mathrm{tr}} = E(\\varepsilon_{n+1} - \\varepsilon^{\\mathrm{p}}_{n+1, \\mathrm{tr}}) = E(\\varepsilon_{n+1} - \\varepsilon^{\\mathrm{p}}_n) = E(\\varepsilon_n + \\Delta\\varepsilon - \\varepsilon^{\\mathrm{p}}_n) = E(\\varepsilon_n - \\varepsilon^{\\mathrm{p}}_n) + E\\Delta\\varepsilon = \\sigma_n + E\\Delta\\varepsilon $$\n- The trial effective stress is $\\,\\xi_{n+1}^{\\mathrm{tr}} = \\sigma_{n+1}^{\\mathrm{tr}} - \\alpha_n\\,$.\n\n**Step 2: Check for Yielding**\nWe evaluate the yield function at the trial state:\n$$ f_{n+1}^{\\mathrm{tr}} = f(\\sigma_{n+1}^{\\mathrm{tr}}, \\alpha_{n+1, \\mathrm{tr}}) = \\lvert \\sigma_{n+1}^{\\mathrm{tr}} - \\alpha_n \\rvert - \\sigma_y = \\lvert \\xi_{n+1}^{\\mathrm{tr}} \\rvert - \\sigma_y $$\n- If $\\,f_{n+1}^{\\mathrm{tr}} \\le 0\\,$, the trial state is admissible. The step is elastic. The updated state is the trial state:\n  $$ \\sigma_{n+1} = \\sigma_{n+1}^{\\mathrm{tr}}, \\quad \\varepsilon^{\\mathrm{p}}_{n+1} = \\varepsilon^{\\mathrm{p}}_n, \\quad \\alpha_{n+1} = \\alpha_n $$\n- If $\\,f_{n+1}^{\\mathrm{tr}} > 0\\,$, the trial state is inadmissible. Plastic flow occurs, and a plastic corrector step is required.\n\n**Step 3: Plastic Corrector**\nThe goal is to find the plastic strain increment $\\,\\Delta\\varepsilon^{\\mathrm{p}}\\,$ such that the final state $(\\sigma_{n+1}, \\alpha_{n+1})$ satisfies the yield condition $\\,f(\\sigma_{n+1}, \\alpha_{n+1}) = 0$. The discrete increments of the internal variables are:\n- Plastic strain increment: $\\,\\Delta\\varepsilon^{\\mathrm{p}} = \\varepsilon^{\\mathrm{p}}_{n+1} - \\varepsilon^{\\mathrm{p}}_n = \\Delta\\gamma \\, \\mathrm{sign}(\\xi_{n+1})\\,$, where $\\,\\Delta\\gamma = \\int_{t_n}^{t_{n+1}} \\dot{\\gamma} dt \\ge 0\\,$.\n- Backstress increment: $\\,\\Delta\\alpha = \\alpha_{n+1} - \\alpha_n = H \\Delta\\varepsilon^{\\mathrm{p}} = H \\Delta\\gamma \\, \\mathrm{sign}(\\xi_{n+1})\\,$.\n\nFor a radial return, the direction of flow is constant and determined by the trial effective stress: $\\,N = \\mathrm{sign}(\\xi_{n+1}) = \\mathrm{sign}(\\xi_{n+1}^{\\mathrm{tr}})\\,$.\nThe updated state variables are expressed in terms of the trial state and the unknown plastic multiplier increment $\\,\\Delta\\gamma\\,$:\n$$ \\sigma_{n+1} = \\sigma_{n+1}^{\\mathrm{tr}} - E \\Delta\\varepsilon^{\\mathrm{p}} = \\sigma_{n+1}^{\\mathrm{tr}} - E \\Delta\\gamma N $$\n$$ \\alpha_{n+1} = \\alpha_n + \\Delta\\alpha = \\alpha_n + H \\Delta\\gamma N $$\nThe final effective stress is:\n$$ \\xi_{n+1} = \\sigma_{n+1} - \\alpha_{n+1} = (\\sigma_{n+1}^{\\mathrm{tr}} - E \\Delta\\gamma N) - (\\alpha_n + H \\Delta\\gamma N) = (\\sigma_{n+1}^{\\mathrm{tr}} - \\alpha_n) - (E+H)\\Delta\\gamma N = \\xi_{n+1}^{\\mathrm{tr}} - (E+H)\\Delta\\gamma N $$\n\n### 3. Derivation of Consistent and Lagged Schemes\n\n**3.1. Consistent Return Mapping**\nThe final state must lie on the yield surface: $\\,\\lvert \\xi_{n+1} \\rvert = \\sigma_y\\,$. Since $\\,\\mathrm{sign}(\\xi_{n+1}) = N\\,$, this means $\\,\\xi_{n+1} = \\sigma_y N\\,$. Substituting this into the effective stress update equation:\n$$ \\sigma_y N = \\xi_{n+1}^{\\mathrm{tr}} - (E+H)\\Delta\\gamma^{\\mathrm{cons}} N $$\nMultiplying by $\\,N\\,$ (since $\\,N^2 = 1\\,$) and noting that $\\,\\xi_{n+1}^{\\mathrm{tr}} N = \\lvert\\xi_{n+1}^{\\mathrm{tr}}\\rvert\\,$:\n$$ \\sigma_y = \\lvert\\xi_{n+1}^{\\mathrm{tr}}\\rvert - (E+H)\\Delta\\gamma^{\\mathrm{cons}} $$\nSolving for the consistent plastic multiplier increment $\\,\\Delta\\gamma^{\\mathrm{cons}}\\,$:\n$$ \\Delta\\gamma^{\\mathrm{cons}} = \\frac{\\lvert\\xi_{n+1}^{\\mathrm{tr}}\\rvert - \\sigma_y}{E+H} = \\frac{f_{n+1}^{\\mathrm{tr}}}{E+H} $$\nSince we are in the plastic case ($\\,f_{n+1}^{\\mathrm{tr}} > 0\\,$), it follows that $\\,\\Delta\\gamma^{\\mathrm{cons}} > 0\\,$. With $\\,\\Delta\\gamma^{\\mathrm{cons}}\\,$ known, all state variables at $\\,t_{n+1}\\,$ can be uniquely determined.\n\n**3.2. Lagged Backstress Scheme**\nIn this scheme, the backstress is \"frozen\" at its step-initial value, $\\,\\alpha_n\\,$, when enforcing the yield condition. The condition becomes $\\,f(\\sigma_{n+1}, \\alpha_n) = 0\\,$, or $\\,\\lvert \\sigma_{n+1} - \\alpha_n \\rvert = \\sigma_y\\,$.\nThe stress update $\\,\\sigma_{n+1} = \\sigma_{n+1}^{\\mathrm{tr}} - E \\Delta\\gamma N\\,$ is still used. We substitute this into the lagged yield condition:\n$$ \\lvert (\\sigma_{n+1}^{\\mathrm{tr}} - E \\Delta\\gamma^{\\mathrm{lag}} N) - \\alpha_n \\rvert = \\sigma_y $$\n$$ \\lvert \\xi_{n+1}^{\\mathrm{tr}} - E \\Delta\\gamma^{\\mathrm{lag}} N \\rvert = \\sigma_y $$\nAgain, assuming a radial return, we obtain:\n$$ \\lvert\\xi_{n+1}^{\\mathrm{tr}}\\rvert - E \\Delta\\gamma^{\\mathrm{lag}} = \\sigma_y $$\nSolving for the lagged plastic multiplier increment $\\,\\Delta\\gamma^{\\mathrm{lag}}\\,$:\n$$ \\Delta\\gamma^{\\mathrm{lag}} = \\frac{\\lvert\\xi_{n+1}^{\\mathrm{tr}}\\rvert - \\sigma_y}{E} = \\frac{f_{n+1}^{\\mathrm{tr}}}{E} $$\nAfter computing $\\,\\Delta\\gamma^{\\mathrm{lag}}\\,$, all state variables are updated. Note that since $\\,H > 0\\,$, it is clear that $\\,\\Delta\\gamma^{\\mathrm{lag}} > \\Delta\\gamma^{\\mathrm{cons}}\\,$.\n\n**3.3. Quantifying Inconsistency of the Lagged Scheme**\nThe lagged scheme is inconsistent because the final state $(\\sigma_{n+1}^{\\mathrm{lag}}, \\alpha_{n+1}^{\\mathrm{lag}})$ does not satisfy the true yield condition. We quantify this with the yield residual, $\\,r\\,$.\nThe final effective stress is $\\,\\xi_{n+1}^{\\mathrm{lag}} = \\sigma_{n+1}^{\\mathrm{lag}} - \\alpha_{n+1}^{\\mathrm{lag}}\\,$. Its magnitude is:\n$$ \\lvert \\xi_{n+1}^{\\mathrm{lag}} \\rvert = \\lvert \\xi_{n+1}^{\\mathrm{tr}} - (E+H)\\Delta\\gamma^{\\mathrm{lag}} N \\rvert = \\lvert\\xi_{n+1}^{\\mathrm{tr}}\\rvert - (E+H)\\Delta\\gamma^{\\mathrm{lag}} $$\nSubstitute the expression for $\\,\\Delta\\gamma^{\\mathrm{lag}}\\,$:\n$$ \\lvert \\xi_{n+1}^{\\mathrm{lag}} \\rvert = \\lvert\\xi_{n+1}^{\\mathrm{tr}}\\rvert - (E+H)\\frac{\\lvert\\xi_{n+1}^{\\mathrm{tr}}\\rvert - \\sigma_y}{E} = \\lvert\\xi_{n+1}^{\\mathrm{tr}}\\rvert - \\left(1 + \\frac{H}{E}\\right)(\\lvert\\xi_{n+1}^{\\mathrm{tr}}\\rvert - \\sigma_y) $$\n$$ \\lvert \\xi_{n+1}^{\\mathrm{lag}} \\rvert = \\lvert\\xi_{n+1}^{\\mathrm{tr}}\\rvert - (\\lvert\\xi_{n+1}^{\\mathrm{tr}}\\rvert - \\sigma_y) - \\frac{H}{E}(\\lvert\\xi_{n+1}^{\\mathrm{tr}}\\rvert - \\sigma_y) = \\sigma_y - \\frac{H}{E}(\\lvert\\xi_{n+1}^{\\mathrm{tr}}\\rvert - \\sigma_y) $$\nThe yield residual is therefore:\n$$ r = \\lvert \\xi_{n+1}^{\\mathrm{lag}} \\rvert - \\sigma_y = -\\frac{H}{E}(\\lvert\\xi_{n+1}^{\\mathrm{tr}}\\rvert - \\sigma_y) = -\\frac{H}{E} f_{n+1}^{\\mathrm{tr}} $$\nSince $\\,H, E, f_{n+1}^{\\mathrm{tr}} > 0\\,$, the residual $\\,r\\,$ is negative, indicating the lagged scheme overcorrects and brings the state inside the true yield surface.\n\nThe relative stress error $\\,e_{\\sigma}\\,$ is defined as $\\,e_{\\sigma} = (\\sigma_{n+1}^{\\mathrm{lag}} - \\sigma_{n+1}^{\\mathrm{cons}})/\\sigma_{n+1}^{\\mathrm{cons}}\\,$.\nThe stress difference is:\n$$ \\sigma_{n+1}^{\\mathrm{lag}} - \\sigma_{n+1}^{\\mathrm{cons}} = (\\sigma_{n+1}^{\\mathrm{tr}} - E \\Delta\\gamma^{\\mathrm{lag}} N) - (\\sigma_{n+1}^{\\mathrm{tr}} - E \\Delta\\gamma^{\\mathrm{cons}} N) = -E(\\Delta\\gamma^{\\mathrm{lag}} - \\Delta\\gamma^{\\mathrm{cons}})N $$\nThe difference in multipliers is:\n$$ \\Delta\\gamma^{\\mathrm{lag}} - \\Delta\\gamma^{\\mathrm{cons}} = \\frac{f_{n+1}^{\\mathrm{tr}}}{E} - \\frac{f_{n+1}^{\\mathrm{tr}}}{E+H} = f_{n+1}^{\\mathrm{tr}} \\left(\\frac{E+H-E}{E(E+H)}\\right) = f_{n+1}^{\\mathrm{tr}} \\frac{H}{E(E+H)} $$\nSo, $\\,\\sigma_{n+1}^{\\mathrm{lag}} - \\sigma_{n+1}^{\\mathrm{cons}} = -E \\left( f_{n+1}^{\\mathrm{tr}} \\frac{H}{E(E+H)} \\right) N = -f_{n+1}^{\\mathrm{tr}} \\frac{H}{E+H} N\\,$. This difference will be evaluated numerically for each case.\n\n### 4. Summary of the Two-Substep Implementation\n\nFor each test case with parameters $\\,E, \\sigma_y, H\\,$ and initial state $\\,\\varepsilon_0, \\varepsilon^{\\mathrm{p}}_0, \\alpha_0\\,$, and strain increments $\\,\\Delta\\varepsilon_1, \\Delta\\varepsilon_2\\,$:\n\n1.  **Initialize**: Compute $\\,\\sigma_0 = E(\\varepsilon_0 - \\varepsilon^{\\mathrm{p}}_0)\\,$.\n2.  **Substep 1 (Elastic)**:\n    -   Compute trial stress $\\,\\sigma_1^{\\mathrm{tr}} = \\sigma_0 + E\\Delta\\varepsilon_1\\,$.\n    -   Confirm $\\,\\lvert \\sigma_1^{\\mathrm{tr}} - \\alpha_0 \\rvert - \\sigma_y \\le 0\\,$.\n    -   Update state: $\\,\\sigma_1 = \\sigma_1^{\\mathrm{tr}}$, $\\,\\varepsilon^{\\mathrm{p}}_1 = \\varepsilon^{\\mathrm{p}}_0$, $\\,\\alpha_1 = \\alpha_0\\,$.\n3.  **Substep 2 (Plastic)**:\n    -   Compute trial stress $\\,\\sigma_2^{\\mathrm{tr}} = \\sigma_1 + E\\Delta\\varepsilon_2\\,$.\n    -   Compute trial effective stress $\\,\\xi_2^{\\mathrm{tr}} = \\sigma_2^{\\mathrm{tr}} - \\alpha_1\\,$ and yield function value $\\,f_2^{\\mathrm{tr}} = \\lvert \\xi_2^{\\mathrm{tr}} \\rvert - \\sigma_y\\,$.\n    -   Confirm $\\,f_2^{\\mathrm{tr}} > 0\\,$.\n    -   Set flow direction $\\,N = \\mathrm{sign}(\\xi_2^{\\mathrm{tr}})\\,$.\n4.  **Compute Consistent Solution**:\n    -   $\\Delta\\gamma^{\\mathrm{cons}} = f_2^{\\mathrm{tr}} / (E+H)\\,$.\n    -   $\\sigma_2^{\\mathrm{cons}} = \\sigma_2^{\\mathrm{tr}} - E \\Delta\\gamma^{\\mathrm{cons}} N\\,$.\n5.  **Compute Lagged Solution**:\n    -   $\\Delta\\gamma^{\\mathrm{lag}} = f_2^{\\mathrm{tr}} / E\\,$.\n    -   $\\sigma_2^{\\mathrm{lag}} = \\sigma_2^{\\mathrm{tr}} - E \\Delta\\gamma^{\\mathrm{lag}} N = \\alpha_1 + \\sigma_y N\\,$.\n    -   $\\alpha_2^{\\mathrm{lag}} = \\alpha_1 + H \\Delta\\gamma^{\\mathrm{lag}} N\\,$.\n6.  **Compute Errors**:\n    -   $r = \\lvert \\sigma_2^{\\mathrm{lag}} - \\alpha_2^{\\mathrm{lag}} \\rvert - \\sigma_y\\,$.\n    -   $e_{\\sigma} = (\\sigma_2^{\\mathrm{lag}} - \\sigma_2^{\\mathrm{cons}}) / \\sigma_2^{\\mathrm{cons}}\\,$.\n7.  **Store Results**: The four values $\\,\\Delta\\gamma^{\\mathrm{cons}}, \\Delta\\gamma^{\\mathrm{lag}}, r, e_{\\sigma}\\,$ are a single case's output.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_case(E, sigma_y, H, eps0, eps_p0, alpha0, delta_eps1, delta_eps2):\n    \"\"\"\n    Solves a single test case for the two-substep plasticity problem.\n\n    Args:\n        E (float): Young's modulus (MPa)\n        sigma_y (float): Initial yield stress (MPa)\n        H (float): Linear kinematic hardening modulus (MPa)\n        eps0 (float): Initial total strain\n        eps_p0 (float): Initial plastic strain\n        alpha0 (float): Initial backstress (MPa)\n        delta_eps1 (float): Strain increment for substep 1\n        delta_eps2 (float): Strain increment for substep 2\n\n    Returns:\n        tuple: (delta_gamma_cons, delta_gamma_lag, r, e_sigma)\n    \"\"\"\n\n    # --- Initial State (n=0) ---\n    sigma0 = E * (eps0 - eps_p0)\n    \n    # Verify initial state admissibility\n    f0 = np.abs(sigma0 - alpha0) - sigma_y\n    if f0 > 1e-9: # Use a small tolerance for floating point comparisons\n        raise ValueError(f\"Initial state is not admissible (f0 = {f0} > 0)\")\n\n    # --- Substep 1 (Elastic) ---\n    sigma1_tr = sigma0 + E * delta_eps1\n    alpha1_tr = alpha0\n    \n    f1_tr = np.abs(sigma1_tr - alpha1_tr) - sigma_y\n    if f1_tr > 1e-9:\n        raise ValueError(f\"Substep 1 is not elastic as required (f1_tr = {f1_tr} > 0)\")\n    \n    # Update state after elastic substep 1\n    sigma1 = sigma1_tr\n    eps_p1 = eps_p0\n    alpha1 = alpha0\n    \n    # --- Substep 2 (Plastic) ---\n    # Predictor\n    sigma2_tr = sigma1 + E * delta_eps2\n    alpha2_tr = alpha1 # Backstress at start of substep\n    \n    # Check yield\n    xi2_tr = sigma2_tr - alpha2_tr\n    f2_tr = np.abs(xi2_tr) - sigma_y\n    \n    if f2_tr <= 1e-9:\n        raise ValueError(f\"Substep 2 is not plastic as required (f2_tr = {f2_tr} <= 0)\")\n        \n    N = np.sign(xi2_tr)\n    \n    # --- Consistent Solution ---\n    delta_gamma_cons = f2_tr / (E + H)\n    sigma2_cons = sigma2_tr - E * delta_gamma_cons * N\n    # alpha2_cons = alpha1 + H * delta_gamma_cons * N\n    # Verification:\n    # xi2_cons = sigma2_cons - alpha2_cons\n    # assert np.isclose(np.abs(xi2_cons), sigma_y), \"Consistent solution failed yield check\"\n    \n    # --- Lagged Backstress Solution ---\n    delta_gamma_lag = f2_tr / E\n    \n    # Update variables for the lagged scheme\n    sigma2_lag = sigma2_tr - E * delta_gamma_lag * N\n    alpha2_lag = alpha1 + H * delta_gamma_lag * N\n    \n    # --- Error Quantification ---\n    # 1. Yield residual of the lagged solution\n    r = np.abs(sigma2_lag - alpha2_lag) - sigma_y\n    \n    # 2. Relative stress error\n    if np.abs(sigma2_cons) < 1e-12:\n        e_sigma = 0.0 if np.isclose(sigma2_lag, sigma2_cons) else np.inf\n    else:\n        e_sigma = (sigma2_lag - sigma2_cons) / sigma2_cons\n        \n    return delta_gamma_cons, delta_gamma_lag, r, e_sigma\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A\n        {'E': 210000.0, 'sigma_y': 250.0, 'H': 5000.0,\n         'alpha0': -80.0, 'eps_p0': -0.016, 'eps0': -0.015285714285714,\n         'delta_eps1': 0.00002, 'delta_eps2': 0.00043238},\n        # Case B\n        {'E': 70000.0, 'sigma_y': 150.0, 'H': 700.0,\n         'alpha0': 120.0, 'eps_p0': 0.171428571428571, 'eps0': 0.171428571428571,\n         'delta_eps1': -0.000285714285714, 'delta_eps2': -0.001714285714286},\n        # Case C\n        {'E': 100000.0, 'sigma_y': 300.0, 'H': 200000.0,\n         'alpha0': -50.0, 'eps_p0': -0.00025, 'eps0': 0.00215,\n         'delta_eps1': 0.00005, 'delta_eps2': 0.0002}\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_case(**case)\n        results.append(result)\n\n    # Format output as specified\n    output_str = \"[\"\n    for i, res_tuple in enumerate(results):\n        formatted_tuple = [f\"{v:.12f}\" for v in res_tuple]\n        output_str += f\"[{','.join(formatted_tuple)}]\"\n        if i < len(results) - 1:\n            output_str += \",\"\n    output_str += \"]\"\n    \n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "This final practice advances from single, smooth yield surfaces to the more general case of multisurface plasticity, where the elastic domain is defined by a collection of intersecting planes. You will implement a powerful active-set strategy, which recasts the return-mapping procedure as a formal constrained quadratic optimization problem . A key challenge you'll tackle is the robust handling of non-smooth corners in the polyhedral yield surface, requiring an anti-cycling rule to guarantee algorithmic convergence—a crucial skill for developing advanced and specialized material models.",
            "id": "3593072",
            "problem": "Implement an active-set return-mapping algorithm for a rate-independent, associative, multisurface plasticity model with convex polyhedral yield surfaces. The elastic domain is defined by a finite set of linear yield functions $f_i(\\sigma,\\kappa) \\le 0$, where $\\sigma \\in \\mathbb{R}^3$ is the Cauchy stress vector in plane stress with components $[\\sigma_{xx},\\sigma_{yy},\\tau_{xy}]$, and $\\kappa$ is a scalar internal variable representing accumulated plastic strain. Use a small-strain linear elastic model with compliance tensor $S \\in \\mathbb{R}^{3 \\times 3}$ that is symmetric positive definite. Assume associative flow and the classical Karush–Kuhn–Tucker (KKT) complementarity conditions for rate-independent plasticity.\n\nBase your derivation and implementation on the following fundamental laws and core definitions:\n- Small-strain linear elasticity with compliance $S$: the incremental elastic constitutive relation $\\Delta \\varepsilon^e = S : \\Delta \\sigma$, equivalently the elastic energy metric defined by $S$.\n- Rate-independent plasticity with associative flow: $\\Delta \\varepsilon^p = \\sum_{i=1}^{m} \\Delta \\lambda_i \\, \\partial_{\\sigma} f_i(\\sigma,\\kappa)$ with $\\Delta \\lambda_i \\ge 0$, yield inequalities $f_i(\\sigma,\\kappa) \\le 0$, and complementarity $\\Delta \\lambda_i \\, f_i(\\sigma,\\kappa) = 0$.\n- Incremental minimum principle for generalized standard materials: the stress update for a given elastic predictor stress $\\sigma^{\\text{trial}}$ is the solution of a convex quadratic program that computes the metric projection onto the elastic domain.\n\nTo keep the model precise and testable, consider a perfect plasticity (no hardening) polyhedral domain defined by the $m=6$ linear yield functions\n$$\nf_i(\\sigma) = n_i^{\\top}\\sigma - R \\le 0 \\quad \\text{for } i \\in \\{1,2,3,4,5,6\\},\n$$\nwith $R>0$ a constant and the normals\n$$\nn_1 = [1,0,0]^\\top,\\; n_2 = [-1,0,0]^\\top,\\; n_3 = [0,1,0]^\\top,\\; n_4=[0,-1,0]^\\top,\\; n_5=[0,0,1]^\\top,\\; n_6=[0,0,-1]^\\top.\n$$\nThis is a multisurface model with a cube-shaped elastic domain in stress space, featuring non-smooth corners where several constraints can be simultaneously active.\n\nFor a single load increment with elastic predictor (trial) stress $\\sigma^{\\text{trial}}$, the elastoplastic stress $\\sigma$ is defined as the unique solution of the metric projection problem\n$$\n\\min_{\\sigma \\in \\mathbb{R}^3}\\;\\; \\tfrac{1}{2}(\\sigma-\\sigma^{\\text{trial}})^\\top S\\,(\\sigma-\\sigma^{\\text{trial}}) \\quad \\text{subject to}\\quad N\\,\\sigma \\le r,\n$$\nwhere $N \\in \\mathbb{R}^{6\\times 3}$ stacks the row vectors $n_i^\\top$, and $r \\in \\mathbb{R}^6$ stacks the entries $R$. The KKT conditions for this convex quadratic program are\n$$\nS(\\sigma-\\sigma^{\\text{trial}}) + N^\\top \\lambda = 0,\\quad\nN\\sigma - r \\le 0,\\quad\n\\lambda \\ge 0,\\quad\n\\lambda \\odot (N\\sigma - r) = 0,\n$$\nwhere $\\lambda \\in \\mathbb{R}^6$ are the Lagrange multipliers and $\\odot$ denotes the Hadamard product.\n\nYour task:\n- Derive an active-set algorithm that enforces the KKT conditions by iteratively guessing a working set $\\mathcal{A}$ of active constraints, solving the equality-constrained subproblem\n$$\n\\min_{\\sigma}\\; \\tfrac{1}{2}(\\sigma-\\sigma^{\\text{trial}})^\\top S(\\sigma-\\sigma^{\\text{trial}})\\quad \\text{s.t.}\\quad N_{\\mathcal{A}}\\sigma = r_{\\mathcal{A}},\n$$\nand updating the set based on infeasibilities and multiplier signs until all KKT conditions are satisfied.\n- Devise a rigorous and implementable criterion to detect and avoid cycling of active sets in non-smooth corners. Your criterion must be based on fundamental algorithmic invariants (such as repeated active sets with no objective decrease, or a Bland-type pivot rule). Explain precisely the entering/leaving rules for constraints and the tie-breaking rule that guarantees termination.\n\nUse the following specific, scientifically consistent data for the test suite (dimensionless quantities):\n- Elastic compliance $S$ for isotropic plane stress with Young’s modulus $E$ and Poisson’s ratio $\\nu$:\n$$\nS = \\begin{bmatrix}\n\\dfrac{1}{E} & -\\dfrac{\\nu}{E} & 0 \\\\[6pt]\n-\\dfrac{\\nu}{E} & \\dfrac{1}{E} & 0 \\\\[6pt]\n0 & 0 & \\dfrac{1}{G}\n\\end{bmatrix},\\quad G = \\dfrac{E}{2(1+\\nu)}.\n$$\nTake $E = 1000$ and $\\nu = 0.3$ for all test cases.\n- Yield radius $R = 100$.\n- Yield normals $N$ as defined above.\n\nProvide a program that, for each given trial stress $\\sigma^{\\text{trial}}$, computes the elastoplastic stress $\\sigma$ by your active-set algorithm with cycling detection and anti-cycling. Your cycling detector must report a boolean flag indicating whether anti-cycling was invoked at least once during the solve for that case.\n\nTest suite. Run your solver on the following $5$ trial stresses (each is a vector in the order $[\\sigma_{xx},\\sigma_{yy},\\tau_{xy}]$):\n- Case $1$: $\\sigma^{\\text{trial}} = [90,\\,80,\\,20]$.\n- Case $2$: $\\sigma^{\\text{trial}} = [150,\\,0,\\,0]$.\n- Case $3$: $\\sigma^{\\text{trial}} = [150,\\,150,\\,0]$.\n- Case $4$: $\\sigma^{\\text{trial}} = [120,\\,120,\\,120]$.\n- Case $5$: $\\sigma^{\\text{trial}} = [100,\\,100,\\,100]$.\n\nRequired final output format. Your program should produce a single line of output containing a list of $5$ results, one per test case, in order. Each result must be a list of length $4$ containing the elastoplastic stress components and the boolean cycling flag in the order $[\\sigma_{xx},\\sigma_{yy},\\tau_{xy},\\text{anticyle\\_used}]$. Represent floating-point numbers in standard decimal notation and the boolean as a literal. The entire output must be a single Python-style list printed on one line, for example:\n$$\n[\\,[\\ldots],\\,[\\ldots],\\,[\\ldots],\\,[\\ldots],\\,[\\ldots]\\,].\n$$\n\nNotes:\n- Treat all quantities as dimensionless; no physical unit conversion is required.\n- Angles do not appear; no angle unit is required.\n- Ensure numerical robustness with a clearly stated tolerance.",
            "solution": "The problem requires the implementation of an active-set return-mapping algorithm for a rate-independent, multisurface plasticity model. The core of the task is to solve a constrained optimization problem that finds the closest point in the elastic domain to a given trial stress, where \"closest\" is measured in the elastic energy metric. An essential part of the requirement is to implement a robust anti-cycling rule to handle non-smooth corners of the polyhedral yield surface.\n\n### 1. Theoretical Formulation\n\nThe elastoplastic stress state $\\sigma$ for a given total strain increment is found by minimizing the incremental work, which, for a given trial elastic stress $\\sigma^{\\text{trial}}$, is equivalent to a metric projection problem. The trial stress is the stress that would be reached under the assumption of purely elastic behavior, $\\sigma^{\\text{trial}} = C:(\\varepsilon_{n} + \\Delta\\varepsilon)$, where $C=S^{-1}$ is the fourth-order elasticity tensor (stiffness), $\\varepsilon_n$ is the total strain at the beginning of the increment, and $\\Delta\\varepsilon$ is the strain increment.\n\nThe updated stress $\\sigma$ is the solution to the following convex quadratic program (QP):\n$$\n\\min_{\\sigma \\in \\mathbb{R}^3}\\;\\; \\tfrac{1}{2}(\\sigma-\\sigma^{\\text{trial}})^\\top S\\,(\\sigma-\\sigma^{\\text{trial}}) \\quad \\text{subject to}\\quad f_i(\\sigma) \\le 0 \\quad \\text{for } i=1,\\dots,m\n$$\nwhere $S$ is the compliance matrix, and the elastic domain is defined by a set of $m$ linear yield functions $f_i(\\sigma) = n_i^\\top \\sigma - R \\le 0$. The matrix $S$ defines the metric for the projection. This problem can be written in matrix form as:\n$$\n\\min_{\\sigma \\in \\mathbb{R}^3}\\;\\; \\tfrac{1}{2}(\\sigma-\\sigma^{\\text{trial}})^\\top S\\,(\\sigma-\\sigma^{\\text{trial}}) \\quad \\text{subject to}\\quad N\\,\\sigma \\le r\n$$\nwhere $N \\in \\mathbb{R}^{m \\times 3}$ is the matrix whose rows are the normal vectors $n_i^\\top$, and $r \\in \\mathbb{R}^m$ is a vector of the yield limits $R$.\n\nThe Karush-Kuhn-Tucker (KKT) conditions provide the necessary and sufficient conditions for the unique solution $\\sigma$ of this convex QP:\n1.  **Stationarity:** $S(\\sigma - \\sigma^{\\text{trial}}) + N^\\top \\lambda = 0$\n2.  **Primal Feasibility:** $N\\sigma - r \\le 0$\n3.  **Dual Feasibility:** $\\lambda \\ge 0$\n4.  **Complementarity:** $\\lambda_i (n_i^\\top \\sigma - R) = 0$ for each $i=1,\\dots,m$.\n\nHere, $\\lambda \\in \\mathbb{R}^m$ is the vector of Lagrange multipliers, which in the context of plasticity correspond to the measures of plastic flow for each yield surface (consistency parameters), $\\lambda_i = \\Delta\\lambda_i$.\n\n### 2. Active-Set Algorithm\n\nAn active-set method is an iterative procedure for solving such constrained optimization problems. It maintains a \"working set\" $\\mathcal{W}$ of constraints that are assumed to be active (i.e., satisfied as equalities) at the solution.\n\n#### Iterative Subproblem\n\nAt each iteration $k$, given a working set $\\mathcal{W}_k$, we solve an equality-constrained QP:\n$$\n\\min_{\\sigma}\\; \\tfrac{1}{2}(\\sigma - \\sigma^{\\text{trial}})^\\top S (\\sigma - \\sigma^{\\text{trial}})\\quad \\text{s.t.}\\quad N_{\\mathcal{W}_k}\\sigma = r_{\\mathcal{W}_k}\n$$\nwhere $N_{\\mathcal{W}_k}$ and $r_{\\mathcal{W}_k}$ consist of the rows of $N$ and $r$ corresponding to the indices in $\\mathcal{W}_k$. The solution to this subproblem is found by solving the associated KKT system, which is a system of linear equations:\n$$\n\\begin{pmatrix}\nS & N_{\\mathcal{W}_k}^\\top \\\\\nN_{\\mathcal{W}_k} & 0\n\\end{pmatrix}\n\\begin{pmatrix}\n\\sigma_{k+1} \\\\\n\\lambda_{\\mathcal{W}_k}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\nS \\sigma^{\\text{trial}} \\\\\nr_{\\mathcal{W}_k}\n\\end{pmatrix}\n$$\nA more computationally stable approach is to first solve for the multipliers $\\lambda_{\\mathcal{W}_k}$ and then update the stress $\\sigma_{k+1}$. From the first KKT equation, $\\sigma_{k+1} = \\sigma^{\\text{trial}} - C N_{\\mathcal{W}_k}^\\top \\lambda_{\\mathcal{W}_k}$, where $C=S^{-1}$ is the stiffness matrix. Substituting this into the constraint equation $N_{\\mathcal{W}_k}\\sigma_{k+1} = r_{\\mathcal{W}_k}$ yields a smaller linear system for $\\lambda_{\\mathcal{W}_k}$:\n$$\n(N_{\\mathcal{W}_k} C N_{\\mathcal{W}_k}^\\top) \\lambda_{\\mathcal{W}_k} = N_{\\mathcal{W}_k} \\sigma^{\\text{trial}} - r_{\\mathcal{W}_k}\n$$\nAfter solving for $\\lambda_{\\mathcal{W}_k}$, $\\sigma_{k+1}$ is computed.\n\n#### Updating the Working Set\n\nThe algorithm terminates if the KKT conditions for the full problem are met. If not, the working set $\\mathcal{W}_k$ is updated to $\\mathcal{W}_{k+1}$ for the next iteration:\n1.  **Check Primal Feasibility:** If any inactive constraint $i \\notin \\mathcal{W}_k$ is violated by $\\sigma_{k+1}$ (i.e., $n_i^\\top \\sigma_{k+1} - R > \\text{tol}$), one of these violated constraints is added to the working set.\n2.  **Check Dual Feasibility:** If $\\sigma_{k+1}$ is primally feasible, we check the signs of the multipliers $\\lambda_{\\mathcal{W}_k}$. If any multiplier $\\lambda_j < -\\text{tol}$ for $j \\in \\mathcal{W}_k$, the corresponding constraint is non-binding and should be removed from the working set.\n\n### 3. Anti-Cycling Strategy\n\nAt degenerate points, such as the non-smooth corners of the polyhedral yield surface, multiple choices may exist for which constraint to add or remove. A naive or \"greedy\" choice (e.g., adding the most violated constraint, removing the constraint with the most negative multiplier) can lead to the algorithm cycling through a sequence of working sets indefinitely.\n\nTo guarantee termination, a rigorous tie-breaking rule is necessary. **Bland's anti-cycling rule**, adapted from the simplex method for linear programming, provides such a guarantee. It states that ties should be broken by choosing the constraint with the smallest index.\n\nThe implemented algorithm employs Bland's rule:\n- **Adding a constraint:** If the set of violated inactive constraints $\\mathcal{V}$ is non-empty, the constraint with the minimum index in $\\mathcal{V}$ is added to the working set.\n- **Removing a constraint:** If the set of active constraints with negative multipliers $\\mathcal{N}$ is non-empty, the constraint with the minimum index in $\\mathcal{N}$ is removed from the working set.\n\nThe problem requires reporting if this anti-cycling mechanism was invoked. This is interpreted as the mechanism being actively needed to resolve an ambiguity. Therefore, the `anticycle_used` flag is set to `True` if, at any step, a choice had to be made from more than one candidate for adding or removing a constraint (i.e., if $|\\mathcal{V}| > 1$ or $|\\mathcal{N}| > 1$).\n\n### 4. Algorithm Summary\n\nThe complete algorithm is as follows:\n1.  **Initialization:** Given $\\sigma^{\\text{trial}}$, define material properties ($C$), yield surface geometry ($N, r$), and a numerical tolerance `tol`.\n2.  **Feasibility Check:** Determine if $\\sigma^{\\text{trial}}$ is within the elastic domain ($N\\sigma^{\\text{trial}} \\le r$). If so, the solution is $\\sigma = \\sigma^{\\text{trial}}$, and the algorithm terminates.\n3.  **Initial Working Set:** If $\\sigma^{\\text{trial}}$ is infeasible, initialize the working set $\\mathcal{W}$ with the indices of all violated constraints.\n4.  **Iterative Refinement:**\n    a. Solve the equality-constrained subproblem for the current working set $\\mathcal{W}$ to find the next stress iterate $\\sigma$ and multipliers $\\lambda_{\\mathcal{W}}$.\n    b. Check for violated primal constraints outside $\\mathcal{W}$. If any exist, add the one with the smallest index to $\\mathcal{W}$ and continue. Set `anticycle_used = True` if there was more than one to choose from.\n    c. If no primal constraints are violated, check for negative multipliers in $\\lambda_{\\mathcal{W}}$. If any exist, remove the corresponding constraint with the smallest index from $\\mathcal{W}$ and continue. Set `anticycle_used = True` if there was more than one to choose from.\n    d. If the solution is both primally and dually feasible, the KKT conditions are satisfied. Terminate the loop.\n5.  **Output:** Return the final stress $\\sigma$ and the `anticycle_used` flag.\n\nThis procedure guarantees convergence to the unique solution of the convex QP.",
            "answer": "```python\nimport numpy as np\n\ndef active_set_solver(sigma_trial, C, N, r, tol=1e-9, max_iter=20):\n    \"\"\"\n    Solves the QP return-mapping problem using an active-set method with\n    Bland's rule for anti-cycling.\n    \n    Args:\n        sigma_trial (np.array): The trial stress vector of shape (3,).\n        C (np.array): The stiffness matrix of shape (3, 3).\n        N (np.array): The matrix of yield surface normals of shape (m, 3).\n        r (np.array): The vector of yield radii of shape (m,).\n        tol (float): Numerical tolerance for checking constraints.\n        max_iter (int): Maximum number of iterations.\n        \n    Returns:\n        tuple: A tuple containing:\n            - np.array: The final elastoplastic stress vector.\n            - bool: A flag indicating if the anti-cycling rule was invoked.\n    \"\"\"\n    anticycle_used = False\n    num_constraints = N.shape[0]\n\n    # Step 2: Initial feasibility check\n    violations = N @ sigma_trial - r\n    if np.max(violations) <= tol:\n        return sigma_trial, False\n\n    # Step 3: Initialize working set with all violated constraints\n    working_set = set(np.where(violations > tol)[0])\n    \n    sigma = sigma_trial.copy()\n\n    # Step 4: Iterative refinement\n    for _ in range(max_iter):\n        \n        # 4a: Solve the equality-constrained subproblem\n        if not working_set:\n            # If the working set becomes empty, the unconstrained minimum is feasible.\n            # This happens if the trial point was outside, but its projection\n            # lies strictly inside the feasible set.\n            sigma = sigma_trial\n            break\n\n        w_list = sorted(list(working_set))\n        Nw = N[w_list, :]\n        rw = r[w_list]\n        \n        try:\n            H = Nw @ C @ Nw.T\n            b = Nw @ sigma_trial - rw\n            lambdas_w = np.linalg.solve(H, b)\n        except np.linalg.LinAlgError:\n            # This indicates linearly dependent active constraints, which is\n            # not expected for the given problem's normals.\n            # E.g., trying to activate both sigma_xx=R and sigma_xx=-R.\n            # The initialization logic should prevent this from happening.\n            print(f\"Warning: Singular matrix for trial stress {sigma_trial} and working set {w_list}\")\n            return sigma, anticycle_used\n\n        sigma = sigma_trial - C @ Nw.T @ lambdas_w\n\n        # 4b: Check for primal feasibility violations\n        all_violations = N @ sigma - r\n        inactive_indices = np.array(list(set(range(num_constraints)) - working_set), dtype=int)\n        \n        if inactive_indices.size > 0:\n            inactive_violations = all_violations[inactive_indices]\n            violated_inactive_mask = inactive_violations > tol\n            \n            if np.any(violated_inactive_mask):\n                violated_inactive_indices = inactive_indices[violated_inactive_mask]\n                \n                # Check if anti-cycling rule is needed\n                if len(violated_inactive_indices) > 1:\n                    anticycle_used = True\n                \n                # Bland's rule: add the constraint with the smallest index\n                idx_to_add = np.min(violated_inactive_indices)\n                working_set.add(idx_to_add)\n                continue\n\n        # 4c: Check for dual feasibility violations\n        negative_lambda_mask = lambdas_w < -tol\n        if np.any(negative_lambda_mask):\n            w_array = np.array(w_list)\n            indices_with_neg_lambda = w_array[negative_lambda_mask]\n            \n            # Check if anti-cycling rule is needed\n            if len(indices_with_neg_lambda) > 1:\n                anticycle_used = True\n            \n            # Bland's rule: remove the constraint with the smallest index\n            idx_to_remove = np.min(indices_with_neg_lambda)\n            working_set.remove(idx_to_remove)\n            continue\n\n        # If no violations, KKT conditions are met. Terminate.\n        break\n    else:\n        # This block executes if the for-loop completes without a 'break'\n        print(f\"Warning: Max iterations ({max_iter}) reached for trial stress {sigma_trial}.\")\n\n    return sigma, anticycle_used\n\ndef solve():\n    # Define problem parameters\n    E = 1000.0\n    nu = 0.3\n    R = 100.0\n\n    # Define test cases for trial stress [sigma_xx, sigma_yy, tau_xy]\n    test_cases = [\n        np.array([90.0, 80.0, 20.0]),\n        np.array([150.0, 0.0, 0.0]),\n        np.array([150.0, 150.0, 0.0]),\n        np.array([120.0, 120.0, 120.0]),\n        np.array([100.0, 100.0, 100.0]),\n    ]\n    \n    # Construct elastic stiffness matrix C (inverse of compliance S) for plane stress\n    # S = [[1/E, -nu/E, 0], [-nu/E, 1/E, 0], [0, 0, 1/G]]\n    # G = E / (2*(1+nu))\n    C = np.zeros((3, 3))\n    C_factor = E / (1 - nu**2)\n    C[0, 0] = C_factor\n    C[0, 1] = nu * C_factor\n    C[1, 0] = nu * C_factor\n    C[1, 1] = C_factor\n    C[2, 2] = E / (2 * (1 + nu))\n\n    # Define yield surface normals\n    N = np.array([\n        [1.0, 0.0, 0.0],\n        [-1.0, 0.0, 0.0],\n        [0.0, 1.0, 0.0],\n        [0.0, -1.0, 0.0],\n        [0.0, 0.0, 1.0],\n        [0.0, 0.0, -1.0],\n    ])\n    \n    # Define yield limits vector\n    r = np.full(6, R)\n\n    results = []\n    for sigma_trial in test_cases:\n        sigma_final, anticycle_flag = active_set_solver(sigma_trial, C, N, r)\n        results.append([sigma_final[0], sigma_final[1], sigma_final[2], anticycle_flag])\n\n    # Format the output as a single-line Python-style list of lists\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}