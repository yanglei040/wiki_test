{
    "hands_on_practices": [
        {
            "introduction": "广义麦克斯韦模型是线性粘弹性力学中的基石。对于实现遗传模型而言，推导其递归更新公式是一项基本技能，因为它允许我们仅根据前一时刻的状态来计算当前状态，从而避免了存储整个加载历史的需要。这项练习  将指导你完成这一推导，并将其应用于一个特定的加载历史，从而加深对手头计算方法的理解。",
            "id": "3544102",
            "problem": "一个单轴、小应变、等温线性粘弹性固体由一个广义麦克斯韦链（三个麦克斯韦臂与一个平衡弹簧并联）建模。设应力分解为 $\\sigma(t) = E_{\\infty}\\,\\epsilon(t) + \\sum_{q=1}^{3} \\sigma_q(t)$，其中 $E_{\\infty}$ 是平衡弹性模量，$\\sigma_q(t)$ 是第 $q$ 个麦克斯韦臂的应力贡献。每个麦克斯韦臂遵循演化方程 $ \\frac{d\\sigma_q}{dt} + \\frac{1}{\\tau_q}\\,\\sigma_q = E_q\\,\\frac{d\\epsilon}{dt}$，其中 $E_q$ 是臂模量，$\\tau_q$ 是其松弛时间。假设初始条件为 $\\epsilon(0^-)=0$ 和 $\\sigma_q(0^-)=0$（对于 $q=1,2,3$）。\n\n材料参数为 $E_{\\infty}=300\\,\\text{MPa}$，$E_1=700\\,\\text{MPa}$，$\\tau_1=1\\,\\text{s}$，$E_2=1000\\,\\text{MPa}$，$\\tau_2=5\\,\\text{s}$，$E_3=400\\,\\text{MPa}$，$\\tau_3=20\\,\\text{s}$。\n\n加载路径包括两个连续的应变跳跃：在 $t=0$ 时施加一个瞬时跳跃 $\\Delta\\epsilon_1=0.012$，然后应变保持恒定 $\\Delta t_1=2\\,\\text{s}$；在 $t=\\Delta t_1$ 时施加一个瞬时跳跃 $\\Delta\\epsilon_2=-0.004$，然后应变保持恒定 $\\Delta t_2=3\\,\\text{s}$。因此，最终时间为 $t_f=\\Delta t_1+\\Delta t_2=5\\,\\text{s}$。\n\n从每个模式给定的演化定律和应力分解出发，推导具有瞬时应变跳跃的分段恒定应变段的算法递归。应用此递归计算最终应力 $\\sigma(t_f)$，并分别报告每个麦克斯韦模式的贡献以及平衡弹簧的贡献。所有应力均以 $\\text{MPa}$ 表示，并将结果四舍五入至四位有效数字。将最终答案表示为一个行矩阵，按顺序包含总应力、平衡弹簧贡献以及模式 $q=1,2,3$ 的贡献。",
            "solution": "问题陈述具有科学依据、适定、客观且自洽。它描述了线性粘弹性中的一个标准问题，提供了所有必要的材料参数、初始条件和明确定义的加载路径。该模型和控制方程是连续介质力学领域的基础。因此，该问题被认为是有效的，并寻求其解答。\n\n问题的核心是求解每个麦克斯韦臂中非平衡应力 $\\sigma_q(t)$ 的演化方程，这是一个一阶线性常微分方程：\n$$ \\frac{d\\sigma_q}{dt} + \\frac{1}{\\tau_q}\\,\\sigma_q = E_q\\,\\frac{d\\epsilon}{dt} $$\n加载被指定为一系列时间间隔，其中瞬时应变跳跃之后是一段恒定应变时期。我们首先推导在一个从 $t_n$ 到 $t_{n+1}$ 的通用时间步长上应力 $\\sigma_q$ 的通用递归更新公式。设步长为 $\\Delta t_{n+1} = t_{n+1} - t_n$。在时间 $t_n$，施加一个瞬时应变跳跃 $\\Delta\\epsilon_{n+1}$。\n\n必须评估在 $t_n$ 时的瞬时应变跳跃对应力 $\\sigma_q$ 的影响。我们可以在一个无穷小的时间间隔 $[t_n^-, t_n^+]$ 上对控制方程进行积分：\n$$ \\int_{t_n^-}^{t_n^+} \\left(\\frac{d\\sigma_q}{dt}\\right) dt + \\int_{t_n^-}^{t_n^+} \\frac{1}{\\tau_q}\\,\\sigma_q dt = \\int_{t_n^-}^{t_n^+} E_q\\,\\frac{d\\epsilon}{dt} dt $$\n当时间间隔趋于零时，第二个积分消失，因为 $\\sigma_q$ 是有界的。方程简化为：\n$$ \\sigma_q(t_n^+) - \\sigma_q(t_n^-) = E_q \\left(\\epsilon(t_n^+) - \\epsilon(t_n^-)\\right) $$\n设 $\\sigma_{q,n}$ 表示前一步结束时的应力，即 $\\sigma_q(t_n^-)$，$\\Delta\\epsilon_{n+1}$ 是在 $t_n$ 时的应变跳跃。跳跃后瞬间的应力 $\\sigma_q(t_n^+)$ 是：\n$$ \\sigma_q(t_n^+) = \\sigma_{q,n} + E_q \\Delta\\epsilon_{n+1} $$\n在随后的时间段 $t \\in (t_n, t_{n+1}]$，应变保持恒定，即 $\\frac{d\\epsilon}{dt} = 0$。控制方程变为齐次的：\n$$ \\frac{d\\sigma_q}{dt} + \\frac{1}{\\tau_q}\\,\\sigma_q = 0 $$\n该方程的解是指数衰减。在时间 $t_n$ 时的初始条件为 $\\sigma_q(t_n^+)$，对于 $t > t_n$ 的解为：\n$$ \\sigma_q(t) = \\sigma_q(t_n^+) \\exp\\left(-\\frac{t-t_n}{\\tau_q}\\right) $$\n在时间步结束时，$t = t_{n+1}$，对此进行求值，得到应力 $\\sigma_{q,n+1}$：\n$$ \\sigma_{q,n+1} = \\sigma_q(t_{n+1}) = \\sigma_q(t_n^+) \\exp\\left(-\\frac{\\Delta t_{n+1}}{\\tau_q}\\right) $$\n代入 $\\sigma_q(t_n^+)$ 的表达式，我们得到非平衡应力的算法递归：\n$$ \\sigma_{q,n+1} = \\left(\\sigma_{q,n} + E_q \\Delta\\epsilon_{n+1}\\right) \\exp\\left(-\\frac{\\Delta t_{n+1}}{\\tau_q}\\right) $$\n我们现在将此公式应用于指定的加载历史。材料初始处于静止状态，因此在 $t=0^-$ 时，我们有 $\\epsilon(0^-)=0$ 和 $\\sigma_{q,0}=\\sigma_q(0^-)=0$（对于 $q=1,2,3$）。\n\n步骤1：第一个加载段，$t \\in [0, 2\\,\\text{s}]$。\n在 $t_0=0$ 时，有一个应变跳跃 $\\Delta\\epsilon_1 = 0.012$。时间间隔为 $\\Delta t_1 = 2\\,\\text{s}$。此间隔内的应变为 $\\epsilon(t) = \\epsilon_1 = 0.012$。\n使用 $n=0$ 的递归，计算此步骤结束时（$t_1 = 2\\,\\text{s}$）的应力：\n$$ \\sigma_{q,1} = (\\sigma_{q,0} + E_q \\Delta\\epsilon_1) \\exp\\left(-\\frac{\\Delta t_1}{\\tau_q}\\right) = (0 + E_q \\times 0.012) \\exp\\left(-\\frac{2}{\\tau_q}\\right) $$\n对于每个麦克斯韦臂 ($q=1,2,3$):\n$$ \\sigma_{1,1} = (700 \\times 0.012) \\exp\\left(-\\frac{2}{1}\\right) = 8.4 \\exp(-2)\\,\\text{MPa} $$\n$$ \\sigma_{2,1} = (1000 \\times 0.012) \\exp\\left(-\\frac{2}{5}\\right) = 12 \\exp(-0.4)\\,\\text{MPa} $$\n$$ \\sigma_{3,1} = (400 \\times 0.012) \\exp\\left(-\\frac{2}{20}\\right) = 4.8 \\exp(-0.1)\\,\\text{MPa} $$\n\n步骤2：第二个加载段，$t \\in (2\\,\\text{s}, 5\\,\\text{s}]$。\n在 $t_1=2\\,\\text{s}$ 时，有一个应变跳跃 $\\Delta\\epsilon_2 = -0.004$。时间间隔为 $\\Delta t_2 = 5 - 2 = 3\\,\\text{s}$。此步骤的初始应力是上面计算的 $\\sigma_{q,1}$。\n最终应变为 $\\epsilon(t_f) = \\epsilon_1 + \\Delta\\epsilon_2 = 0.012 - 0.004 = 0.008$。\n使用 $n=1$ 的递归，计算最终时间 $t_f = 5\\,\\text{s}$ 时的应力：\n$$ \\sigma_{q,f} = \\sigma_q(t_f) = (\\sigma_{q,1} + E_q \\Delta\\epsilon_2) \\exp\\left(-\\frac{\\Delta t_2}{\\tau_q}\\right) $$\n对于每个麦克斯韦臂：\n$$ \\sigma_{1,f} = (8.4 \\exp(-2) + 700(-0.004)) \\exp\\left(-\\frac{3}{1}\\right) = (8.4 \\exp(-2) - 2.8) \\exp(-3) = 8.4 \\exp(-5) - 2.8 \\exp(-3) $$\n$$ \\sigma_{2,f} = (12 \\exp(-0.4) + 1000(-0.004)) \\exp\\left(-\\frac{3}{5}\\right) = (12 \\exp(-0.4) - 4) \\exp(-0.6) = 12 \\exp(-1) - 4 \\exp(-0.6) $$\n$$ \\sigma_{3,f} = (4.8 \\exp(-0.1) + 400(-0.004)) \\exp\\left(-\\frac{3}{20}\\right) = (4.8 \\exp(-0.1) - 1.6) \\exp(-0.15) = 4.8 \\exp(-0.25) - 1.6 \\exp(-0.15) $$\n现在我们计算在 $t_f = 5\\,\\text{s}$ 时这些模式贡献的数值，并四舍五入到四位有效数字：\n$$ \\sigma_{1,f} \\approx 8.4(0.0067379) - 2.8(0.049787) \\approx 0.056598 - 0.139404 = -0.082805\\,\\text{MPa} \\implies -0.08281\\,\\text{MPa} $$\n$$ \\sigma_{2,f} \\approx 12(0.36788) - 4(0.54881) \\approx 4.41456 - 2.19524 = 2.21932\\,\\text{MPa} \\implies 2.219\\,\\text{MPa} $$\n$$ \\sigma_{3,f} \\approx 4.8(0.77880) - 1.6(0.86071) \\approx 3.73824 - 1.37714 = 2.36110\\,\\text{MPa} \\implies 2.361\\,\\text{MPa} $$\n来自平衡弹簧的贡献是纯弹性的：\n$$ \\sigma_{\\infty}(t_f) = E_{\\infty} \\epsilon(t_f) = 300\\,\\text{MPa} \\times 0.008 = 2.4\\,\\text{MPa} $$\n为报告一致性，此值表示为 $2.400\\,\\text{MPa}$。\n\n总应力 $\\sigma(t_f)$ 是平衡和非平衡贡献的总和。将高精度值相加，然后四舍五入到四位有效数字：\n$$ \\sigma(t_f) = \\sigma_{\\infty}(t_f) + \\sigma_{1,f} + \\sigma_{2,f} + \\sigma_{3,f} $$\n$$ \\sigma(t_f) \\approx 2.4 + (-0.082805) + 2.21932 + 2.36110 = 6.897615\\,\\text{MPa} \\implies 6.898\\,\\text{MPa} $$\n\n最终结果是：\n- 总应力：$\\sigma(t_f) = 6.898\\,\\text{MPa}$\n- 平衡弹簧贡献：$\\sigma_{\\infty}(t_f) = 2.400\\,\\text{MPa}$\n- 模式 $1$ 贡献：$\\sigma_1(t_f) = -0.08281\\,\\text{MPa}$\n- 模式 $2$ 贡献：$\\sigma_2(t_f) = 2.219\\,\\text{MPa}$\n- 模式 $3$ 贡献：$\\sigma_3(t_f) = 2.361\\,\\text{MPa}$\n根据要求，将这些值组合成一个行矩阵。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n6.898  2.400  -0.08281  2.219  2.361\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "在开发出一种算法之后，我们必须确保其在物理上是合理的。一个关键要求是算法必须遵守热力学第二定律，这意味着它在数值上不应凭空产生能量。这项练习  专注于分析广泛使用的后向欧拉格式的热力学稳定性，并演示如何从解析上证明并以数值方式验证该格式能够确保非负的能量耗散。",
            "id": "3544081",
            "problem": "考虑一个一维遗传粘弹性材料，该材料由多个并联的 Maxwell 元与一个平衡状态的弹性弹簧组成，通常称为标准线性固体 (SLS) 模型。设总小应变表示为 $\\,\\varepsilon(t)\\,$，总应力表示为 $\\,\\sigma(t)\\,$。该模型由一个模量为 $\\,E_{\\infty}\\,$ 的平衡弹性弹簧和一组 $\\,m\\,$ 个 Maxwell 元组成，其中第 $\\,k\\,$ 个 Maxwell 元的弹性模量为 $\\,E_k\\,$，松弛时间为 $\\,\\tau_k\\,$，$\\,k=1,\\dots,m\\,$. 每个 Maxwell 元都由一个表示其粘性应变的内变量 $\\,q_k(t)\\,$ 来表征。其本构关系和演化方程由以下基本且被广泛接受的框架定义：\n\n- 自由能密度为\n$$\n\\psi(\\varepsilon,\\{q_k\\}) \\;=\\; \\tfrac{1}{2} E_{\\infty}\\,\\varepsilon^2 \\;+\\; \\sum_{k=1}^m \\tfrac{1}{2} E_k\\,\\big(\\varepsilon - q_k\\big)^2.\n$$\n\n- 应力为\n$$\n\\sigma \\;=\\; \\dfrac{\\partial \\psi}{\\partial \\varepsilon} \\;=\\; E_{\\infty}\\,\\varepsilon \\;+\\; \\sum_{k=1}^m E_k\\,\\big(\\varepsilon - q_k\\big).\n$$\n\n- 每个内变量都遵循一个表示粘性松弛的线性常微分方程：\n$$\n\\dot{q}_k \\;=\\; \\dfrac{1}{\\tau_k}\\,\\big(\\varepsilon - q_k\\big),\n\\quad k=1,\\dots,m.\n$$\n\n对于等温过程，Clausius–Duhem 不等式指出耗散率 $\\,\\mathcal{D}(t)\\,$ 必须满足\n$$\n\\mathcal{D}(t) \\;=\\; \\sigma\\,\\dot{\\varepsilon} \\;-\\; \\dot{\\psi} \\;\\ge\\; 0.\n$$\n根据上述定律，可以得到一个经过充分检验的结果\n$$\n\\mathcal{D}(t) \\;=\\; \\sum_{k=1}^m \\dfrac{E_k}{\\tau_k}\\,\\big(\\varepsilon - q_k\\big)^2 \\;\\ge\\; 0.\n$$\n\n现在我们考虑在时间步 $\\,t_n\\,$ 上的时间离散算法更新，其固定步长为 $\\,\\Delta t\\,$，其中 $\\,t_{n+1}=t_n+\\Delta t\\,$. 内变量使用 Backward Euler (BE) 格式进行更新，这是计算固体力学中的一种标准隐式方法：\n$$\nq_k^{n+1} - q_k^{n} \\;=\\; \\dfrac{\\Delta t}{\\tau_k}\\,\\big(\\varepsilon^{n+1} - q_k^{n+1}\\big),\n\\quad k=1,\\dots,m.\n$$\n该时间步末端的应力通过下式计算\n$$\n\\sigma^{n+1} \\;=\\; E_{\\infty}\\,\\varepsilon^{n+1} \\;+\\; \\sum_{k=1}^m E_k\\,\\big(\\varepsilon^{n+1} - q_k^{n+1}\\big).\n$$\n将时间步 $\\,n\\,$ 的离散自由能定义为\n$$\n\\psi^{n} \\;=\\; \\tfrac{1}{2} E_{\\infty}\\,(\\varepsilon^{n})^2 \\;+\\; \\sum_{k=1}^m \\tfrac{1}{2} E_k\\,\\big(\\varepsilon^{n} - q_k^{n}\\big)^2.\n$$\n将时间步 $[t_n,t_{n+1}]$ 上的离散增量功 $\\,W^{n+1}\\,$ 定义为在步末端使用单点求积计算的结果，即\n$$\nW^{n+1} \\;=\\; \\sigma^{n+1}\\,\\Delta\\varepsilon^{n+1},\n\\quad \\text{其中}\\quad \\Delta\\varepsilon^{n+1} \\;=\\; \\varepsilon^{n+1} - \\varepsilon^{n}.\n$$\n将离散耗散 $\\,D^{n+1}\\,$ 定义为\n$$\nD^{n+1} \\;=\\; W^{n+1} \\;-\\; \\big(\\psi^{n+1} - \\psi^{n}\\big).\n$$\n\n您的目标是针对具有交替应变增量的数值测试进行能量分析，并验证对于所选的 Backward Euler 格式，离散耗散 $\\,D^{n+1}\\,$ 是否保持非负。该分析必须实现为一个完整的、可运行的程序。\n\n实现要求：\n- 使用上述包含 $\\,m\\,$ 个 Maxwell 元的模型。初始条件为对所有 $\\,k\\,$，$\\,\\varepsilon^{0} = 0\\,$ 且 $\\,q_k^{0} = 0\\,$.\n- 通过振幅为 $\\,A\\,$ 的交替增量构建应变序列 $\\{\\varepsilon^n\\}$：\n$$\n\\Delta\\varepsilon^{n+1} \\;=\\; A\\,(-1)^n,\n\\quad n=0,1,2,\\dots,N-1,\n$$\n并设 $\\,\\varepsilon^{n+1} = \\varepsilon^{n} + \\Delta\\varepsilon^{n+1}\\,$，其中 $\\,\\varepsilon^{0} = 0\\,$.\n- 物理单位：\n    - 应变 $\\,\\varepsilon\\,$ 是无量纲的。\n    - 应力 $\\,\\sigma\\,$ 和模量 $\\,E_{\\infty}, E_k\\,$ 必须以帕斯卡 ($\\,\\mathrm{Pa}\\,$) 为单位。\n    - 时间 $\\,t\\,$ 和 $\\,\\tau_k\\,$ 必须以秒 ($\\,\\mathrm{s}\\,$) 为单位。\n- 对于每个时间步，使用 Backward Euler 计算 $\\,q_k^{n+1}\\,$，然后计算 $\\,\\sigma^{n+1}\\,$, $\\,\\psi^{n+1}\\,$ 和 $\\,D^{n+1}\\,$。使用一个严格的数值容差来判断非负性：如果 $\\,D^{n+1} \\ge -\\mathrm{tol}\\,$，则该时间步是可以接受的，其中 $\\,\\mathrm{tol}\\,$ 是一个相对于能量尺度选择的小的正浮点数。\n- 对于每个测试用例，程序必须返回一个布尔值，以指示在所有时间步 $\\,n=0,\\dots,N-1\\,$ 中，$\\,D^{n+1}\\,$ 是否（在容差范围内）为非负。\n\n测试套件：\n- 用例 $\\,1\\,$ (一般正常路径)：\n    - $\\,m = 2\\,$, $\\,E_{\\infty} = 2.6\\times 10^{9}\\,\\mathrm{Pa}\\,$,\n      $\\,E_1 = 0.9\\times 10^{9}\\,\\mathrm{Pa}\\,$, $\\,E_2 = 0.4\\times 10^{9}\\,\\mathrm{Pa}\\,$,\n      $\\,\\tau_1 = 0.06\\,\\mathrm{s}\\,$, $\\,\\tau_2 = 0.8\\,\\mathrm{s}\\,$,\n      $\\,\\Delta t = 0.05\\,\\mathrm{s}\\,$, $\\,N = 12\\,$, $\\,A = 0.007\\,$.\n- 用例 $\\,2\\,$ (边界：无平衡弹簧)：\n    - $\\,m = 1\\,$, $\\,E_{\\infty} = 0\\,\\mathrm{Pa}\\,$,\n      $\\,E_1 = 1.2\\times 10^{9}\\,\\mathrm{Pa}\\,$,\n      $\\,\\tau_1 = 0.02\\,\\mathrm{s}\\,$,\n      $\\,\\Delta t = 0.02\\,\\mathrm{s}\\,$, $\\,N = 20\\,$, $\\,A = 0.005\\,$.\n- 用例 $\\,3\\,$ (边缘：时间步相对于某些 $\\,\\tau_k\\,$ 较大)：\n    - $\\,m = 3\\,$, $\\,E_{\\infty} = 3.0\\times 10^{9}\\,\\mathrm{Pa}\\,$,\n      $\\,E_1 = 1.5\\times 10^{9}\\,\\mathrm{Pa}\\,$, $\\,E_2 = 0.5\\times 10^{9}\\,\\mathrm{Pa}\\,$, $\\,E_3 = 0.2\\times 10^{9}\\,\\mathrm{Pa}\\,$,\n      $\\,\\tau_1 = 0.01\\,\\mathrm{s}\\,$, $\\,\\tau_2 = 0.1\\,\\mathrm{s}\\,$, $\\,\\tau_3 = 1.0\\,\\mathrm{s}\\,$,\n      $\\,\\Delta t = 0.5\\,\\mathrm{s}\\,$, $\\,N = 8\\,$, $\\,A = 0.03\\,$.\n- 用例 $\\,4\\,$ (边缘：零振幅增量)：\n    - $\\,m = 2\\,$, $\\,E_{\\infty} = 1.0\\times 10^{9}\\,\\mathrm{Pa}\\,$,\n      $\\,E_1 = 0.7\\times 10^{9}\\,\\mathrm{Pa}\\,$, $\\,E_2 = 0.3\\times 10^{9}\\,\\mathrm{Pa}\\,$,\n      $\\,\\tau_1 = 0.2\\,\\mathrm{s}\\,$, $\\,\\tau_2 = 0.5\\,\\mathrm{s}\\,$,\n      $\\,\\Delta t = 0.1\\,\\mathrm{s}\\,$, $\\,N = 10\\,$, $\\,A = 0\\,$.\n\n答案规格：\n- 您的程序应生成单行输出，其中包含以上四个用例的结果，结果为逗号分隔的列表并用方括号括起，例如 $\\,\\big[\\texttt{result1},\\texttt{result2},\\texttt{result3},\\texttt{result4}\\big]\\,$，其中每个 $\\,\\texttt{resulti}\\,$ 是一个布尔值。",
            "solution": "该问题要求对一维线性粘弹性模型的数值算法进行热力学一致性分析。具体来说，我们必须验证在使用 Backward Euler 积分格式时，所定义的离散耗散是否保持非负。\n\n首先，我们建立解析框架。该模型是标准线性固体 (Standard Linear Solid)，由一个平衡弹簧 ($E_{\\infty}$) 与 $m$ 个 Maxwell 元并联组成。每个 Maxwell 元 $k$ 由一个弹簧 ($E_k$) 和一个粘壶组成，其状态由内变量粘性应变 $q_k$ 描述。\n\n自由能密度 $\\psi$、应力 $\\sigma$ 和内变量 $q_k$ 的演化由以下公式给出：\n$$\n\\psi(\\varepsilon, \\{q_k\\}) = \\frac{1}{2} E_{\\infty} \\varepsilon^2 + \\sum_{k=1}^m \\frac{1}{2} E_k (\\varepsilon - q_k)^2\n$$\n$$\n\\sigma = \\frac{\\partial \\psi}{\\partial \\varepsilon} = E_{\\infty} \\varepsilon + \\sum_{k=1}^m E_k (\\varepsilon - q_k)\n$$\n$$\n\\dot{q}_k = \\frac{1}{\\tau_k}(\\varepsilon - q_k)\n$$\n该问题考虑了从 $t_n$ 到 $t_{n+1} = t_n + \\Delta t$ 的时间步上的时间离散模拟。内变量使用隐式 Backward Euler (BE) 格式进行更新：\n$$\n\\frac{q_k^{n+1} - q_k^n}{\\Delta t} = \\frac{1}{\\tau_k}(\\varepsilon^{n+1} - q_k^{n+1})\n$$\n该方程对于未知数 $q_k^{n+1}$ 是线性的，可以重新整理以提供一个显式的更新法则：\n$$\nq_k^{n+1} \\left(1 + \\frac{\\Delta t}{\\tau_k}\\right) = q_k^n + \\frac{\\Delta t}{\\tau_k} \\varepsilon^{n+1}\n$$\n$$\nq_k^{n+1} = \\frac{\\tau_k}{\\tau_k + \\Delta t} q_k^n + \\frac{\\Delta t}{\\tau_k + \\Delta t} \\varepsilon^{n+1}\n$$\n这个更新公式在计算上很方便，并将在实现中使用。\n\n任务的核心是分析离散耗散 $D^{n+1}$，它被定义为增量功 $W^{n+1}$ 与储存自由能变化量 $\\psi^{n+1} - \\psi^n$ 之间的差值：\n$$\nD^{n+1} = W^{n+1} - (\\psi^{n+1} - \\psi^n)\n$$\n其中 $W^{n+1} = \\sigma^{n+1} \\Delta\\varepsilon^{n+1}$ 且 $\\Delta\\varepsilon^{n+1} = \\varepsilon^{n+1} - \\varepsilon^n$。我们必须证明对于这种特定的算法结构，$D^{n+1} \\ge 0$。\n\n我们将 $W^{n+1}$ 和 $\\psi$ 的定义代入 $D^{n+1}$ 的表达式中：\n$$\nD^{n+1} = \\sigma^{n+1}(\\varepsilon^{n+1} - \\varepsilon^n) - \\left[ \\left( \\frac{1}{2} E_{\\infty} (\\varepsilon^{n+1})^2 + \\sum_{k=1}^m \\frac{1}{2} E_k (\\varepsilon^{n+1} - q_k^{n+1})^2 \\right) - \\left( \\frac{1}{2} E_{\\infty} (\\varepsilon^n)^2 + \\sum_{k=1}^m \\frac{1}{2} E_k (\\varepsilon^n - q_k^n)^2 \\right) \\right]\n$$\n代入应力 $\\sigma^{n+1}$ 的表达式：\n$$\n\\sigma^{n+1} = E_{\\infty}\\varepsilon^{n+1} + \\sum_{k=1}^m E_k (\\varepsilon^{n+1} - q_k^{n+1})\n$$\n耗散表达式变为：\n$$\nD^{n+1} = \\left( E_{\\infty}\\varepsilon^{n+1} + \\sum_{k=1}^m E_k (\\varepsilon^{n+1} - q_k^{n+1}) \\right) \\Delta\\varepsilon^{n+1} - \\frac{1}{2} E_{\\infty} ((\\varepsilon^{n+1})^2 - (\\varepsilon^n)^2) - \\sum_{k=1}^m \\frac{1}{2} E_k ((\\varepsilon^{n+1} - q_k^{n+1})^2 - (\\varepsilon^n - q_k^n)^2)\n$$\n我们可以分别分析平衡弹簧和 Maxwell 元的贡献。\n\n来自平衡弹簧 ($E_{\\infty}$) 的贡献：\n$$\nD_{\\infty}^{n+1} = E_{\\infty}\\varepsilon^{n+1} \\Delta\\varepsilon^{n+1} - \\frac{1}{2} E_{\\infty} ((\\varepsilon^{n+1})^2 - (\\varepsilon^n)^2) = E_{\\infty}\\varepsilon^{n+1}(\\varepsilon^{n+1} - \\varepsilon^n) - \\frac{1}{2} E_{\\infty}(\\varepsilon^{n+1} - \\varepsilon^n)(\\varepsilon^{n+1} + \\varepsilon^n)\n$$\n$$\nD_{\\infty}^{n+1} = \\frac{1}{2} E_{\\infty}(\\varepsilon^{n+1} - \\varepsilon^n) [2\\varepsilon^{n+1} - (\\varepsilon^{n+1} + \\varepsilon^n)] = \\frac{1}{2} E_{\\infty}(\\varepsilon^{n+1} - \\varepsilon^n)^2 = \\frac{1}{2} E_{\\infty}(\\Delta\\varepsilon^{n+1})^2\n$$\n由于 $E_{\\infty} \\ge 0$，该项始终为非负。\n\n来自每个 Maxwell 元 ($k$) 的贡献：\n令 $h_k^n = \\varepsilon^n - q_k^n$。$q_k$ 的 BE 演化方程可以用 $h_k^{n+1}$ 表示为 $\\Delta q_k^{n+1} = q_k^{n+1} - q_k^n = \\frac{\\Delta t}{\\tau_k} h_k^{n+1}$。\n$h_k$ 的变化量为 $\\Delta h_k^{n+1} = h_k^{n+1} - h_k^n = (\\varepsilon^{n+1} - q_k^{n+1}) - (\\varepsilon^n - q_k^n) = \\Delta\\varepsilon^{n+1} - \\Delta q_k^{n+1}$。\n由此，我们得到 $\\Delta\\varepsilon^{n+1} = \\Delta h_k^{n+1} + \\Delta q_k^{n+1} = \\Delta h_k^{n+1} + \\frac{\\Delta t}{\\tau_k} h_k^{n+1}$。\n元 $k$ 的耗散部分 $D_k^{n+1}$ 为：\n$$\nD_k^{n+1} = E_k h_k^{n+1} \\Delta\\varepsilon^{n+1} - \\frac{1}{2} E_k ((h_k^{n+1})^2 - (h_k^n)^2)\n$$\n代入 $\\Delta\\varepsilon^{n+1}$ 的表达式：\n$$\nD_k^{n+1} = E_k h_k^{n+1} \\left( \\Delta h_k^{n+1} + \\frac{\\Delta t}{\\tau_k} h_k^{n+1} \\right) - \\frac{1}{2} E_k ((h_k^{n+1})^2 - (h_k^n)^2)\n$$\n$$\nD_k^{n+1} = E_k \\left( h_k^{n+1}(h_k^{n+1} - h_k^n) + \\frac{\\Delta t}{\\tau_k}(h_k^{n+1})^2 \\right) - \\frac{1}{2} E_k ((h_k^{n+1})^2 - (h_k^n)^2)\n$$\n$$\nD_k^{n+1} = E_k \\left( (h_k^{n+1})^2 - h_k^{n+1}h_k^n + \\frac{\\Delta t}{\\tau_k}(h_k^{n+1})^2 - \\frac{1}{2}(h_k^{n+1})^2 + \\frac{1}{2}(h_k^n)^2 \\right)\n$$\n$$\nD_k^{n+1} = E_k \\left( \\frac{1}{2}(h_k^{n+1})^2 - h_k^{n+1}h_k^n + \\frac{1}{2}(h_k^n)^2 + \\frac{\\Delta t}{\\tau_k}(h_k^{n+1})^2 \\right)\n$$\n识别出完全平方项：\n$$\nD_k^{n+1} = \\frac{1}{2} E_k (h_k^{n+1} - h_k^n)^2 + \\frac{\\Delta t E_k}{\\tau_k} (h_k^{n+1})^2 = \\frac{1}{2} E_k (\\Delta h_k^{n+1})^2 + \\frac{\\Delta t E_k}{\\tau_k} (\\varepsilon^{n+1} - q_k^{n+1})^2\n$$\n由于材料参数 $E_k > 0$、$\\tau_k > 0$ 且时间步 $\\Delta t > 0$，这两项都是非负的。\n\n总的离散耗散是所有贡献的总和：\n$$\nD^{n+1} = D_{\\infty}^{n+1} + \\sum_{k=1}^m D_k^{n+1} = \\frac{1}{2} E_{\\infty}(\\Delta\\varepsilon^{n+1})^2 + \\sum_{k=1}^m \\left( \\frac{1}{2} E_k (\\Delta h_k^{n+1})^2 + \\frac{\\Delta t E_k}{\\tau_k} (\\varepsilon^{n+1} - q_k^{n+1})^2 \\right)\n$$\n该表达式是一系列非负项的和。因此，在解析上可以保证 $D^{n+1} \\ge 0$。此性质被称为无条件热力学稳定性，它是 Backward Euler 格式应用于此类材料模型的一个关键特性。\n\n实现将通过编写一个程序来模拟每个测试用例的应变历史。在每个时间步 $n=0, ..., N-1$，从 $\\varepsilon^0=0, q_k^0=0$ 开始，算法将执行以下操作：\n1. 计算应变增量 $\\Delta\\varepsilon^{n+1} = A(-1)^n$ 和新应变 $\\varepsilon^{n+1} = \\varepsilon^n + \\Delta\\varepsilon^{n+1}$。\n2. 存储旧的自由能 $\\psi^n$。\n3. 使用从 BE 格式导出的显式更新法则计算所有 $k$ 的新内变量 $q_k^{n+1}$。\n4. 计算新应力 $\\sigma^{n+1}$ 和新自由能 $\\psi^{n+1}$。\n5. 计算增量功 $W^{n+1}$，最后计算离散耗散 $D^{n+1} = W^{n+1} - (\\psi^{n+1} - \\psi^n)$。\n6. 验证 $D^{n+1} \\ge -\\mathrm{tol}$ 是否成立，其中 $\\mathrm{tol}$ 是一个小的数值容差（例如 $10^{-9}$），用于考虑浮点数的不精确性。如果该条件在任何时候被违反，则该用例的测试失败。\n\n根据我们的证明，所有测试用例预计都将通过，返回 `True`。对于应变振幅为零的用例 4 ($A=0$)，所有状态变量将保持为零，因此在所有时间步中 $D^{n+1}$ 将恒等于零，这满足了非负性条件。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(m: int, E_inf: float, E_k: np.ndarray, tau_k: np.ndarray, dt: float, N: int, A: float) -> bool:\n    \"\"\"\n    Runs a single simulation for a given set of parameters.\n\n    Args:\n        m (int): Number of Maxwell elements.\n        E_inf (float): Equilibrium elastic modulus.\n        E_k (np.ndarray): Array of elastic moduli for Maxwell elements.\n        tau_k (np.ndarray): Array of relaxation times for Maxwell elements.\n        dt (float): Time step size.\n        N (int): Number of time steps.\n        A (float): Amplitude of strain increments.\n\n    Returns:\n        bool: True if discrete dissipation is non-negative for all steps, False otherwise.\n    \"\"\"\n    # Numerical tolerance for checking non-negativity.\n    # This value is chosen to be small relative to any expected physical energy values.\n    TOL = 1e-9\n\n    # Initial conditions\n    epsilon_n = 0.0\n    q_n = np.zeros(m)  # Internal variables q_k^n\n\n    for n in range(N):\n        # 1. Calculate old free energy psi^n\n        h_n = epsilon_n - q_n\n        psi_n = 0.5 * E_inf * epsilon_n**2 + 0.5 * np.sum(E_k * h_n**2)\n\n        # 2. Update strain for step n+1\n        delta_epsilon_np1 = A * (-1)**n\n        epsilon_np1 = epsilon_n + delta_epsilon_np1\n\n        # 3. Update internal variables q_k^{n+1} using the explicit Backward Euler update rule\n        # q_k^{n+1} = (tau_k / (tau_k + dt)) * q_k^n + (dt / (tau_k + dt)) * epsilon^{n+1}\n        # This update is vectorized using numpy.\n        q_np1 = (tau_k / (tau_k + dt)) * q_n + (dt / (tau_k + dt)) * epsilon_np1\n\n        # 4. Calculate new stress sigma^{n+1}\n        h_np1 = epsilon_np1 - q_np1\n        sigma_np1 = E_inf * epsilon_np1 + np.sum(E_k * h_np1)\n\n        # 5. Calculate incremental work W^{n+1}\n        W_np1 = sigma_np1 * delta_epsilon_np1\n\n        # 6. Calculate new free energy psi^{n+1}\n        psi_np1 = 0.5 * E_inf * epsilon_np1**2 + 0.5 * np.sum(E_k * h_np1**2)\n\n        # 7. Calculate discrete dissipation D^{n+1}\n        D_np1 = W_np1 - (psi_np1 - psi_n)\n\n        # 8. Check for non-negativity\n        if D_np1  -TOL:\n            return False\n\n        # 9. Update state for the next step\n        epsilon_n = epsilon_np1\n        q_n = q_np1\n\n    return True\n\ndef solve():\n    \"\"\"\n    Defines the test suite and runs the simulation for each case.\n    \"\"\"\n    test_cases = [\n        # Case 1: General happy path\n        {'m': 2, 'E_inf': 2.6e9, 'E_k': [0.9e9, 0.4e9], 'tau_k': [0.06, 0.8], \n         'dt': 0.05, 'N': 12, 'A': 0.007},\n        \n        # Case 2: No equilibrium spring\n        {'m': 1, 'E_inf': 0.0, 'E_k': [1.2e9], 'tau_k': [0.02], \n         'dt': 0.02, 'N': 20, 'A': 0.005},\n        \n        # Case 3: Large time step relative to some tau_k\n        {'m': 3, 'E_inf': 3.0e9, 'E_k': [1.5e9, 0.5e9, 0.2e9], 'tau_k': [0.01, 0.1, 1.0], \n         'dt': 0.5, 'N': 8, 'A': 0.03},\n        \n        # Case 4: Zero amplitude increments\n        {'m': 2, 'E_inf': 1.0e9, 'E_k': [0.7e9, 0.3e9], 'tau_k': [0.2, 0.5], \n         'dt': 0.1, 'N': 10, 'A': 0.0},\n    ]\n\n    results = []\n    for case in test_cases:\n        # Convert lists to numpy arrays for vectorized calculations\n        E_k_arr = np.array(case['E_k'], dtype=float)\n        tau_k_arr = np.array(case['tau_k'], dtype=float)\n        \n        is_nonnegative = run_simulation(\n            case['m'], case['E_inf'], E_k_arr, tau_k_arr, \n            case['dt'], case['N'], case['A']\n        )\n        # Format boolean as lowercase string for output\n        results.append(str(is_nonnegative).lower())\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "塑性模型是计算力学中的核心，但其率无关形式由于其非光滑性而带来了数值挑战。这项练习  介绍了一种优雅而强大的技术：使用同伦方法来正则化问题。我们将率无关模型视为粘塑性模型的极限情况，从而为求解器创建一条光滑的路径，以增强算法的鲁棒性。",
            "id": "3544019",
            "problem": "考虑一个具有线性各向同性硬化的一维小应变弹塑性材料，该材料在内变量模型的算法更新框架内进行建模。假设总应变分解为 $ \\varepsilon = \\varepsilon^{e} + \\varepsilon^{p} $，其中 $ \\varepsilon^{e} $ 是弹性应变，$ \\varepsilon^{p} $ 是塑性应变。柯西应力由胡克定律 $ \\sigma = E \\, \\varepsilon^{e} $ 给出，其中 $ E $ 是杨氏模量（单位为 $\\mathrm{Pa}$）。内变量选择为累积塑性应变 $ \\alpha = \\varepsilon^{p} $，线性各向同性硬化由 $ H $（单位为 $\\mathrm{Pa}$）和初始屈服应力 $ \\sigma_{y0} $（单位为 $\\mathrm{Pa}$）表征。屈服函数为 $ f(\\sigma,\\alpha) = \\sigma - (\\sigma_{y0} + H \\alpha) $，假设为单调拉伸，因此 $ \\sigma \\ge 0 $，不需要绝对值。\n\n为了正则化并实现从粘性塑性到率无关塑性的同伦，考虑采用 Perzyna 型粘塑性更新，其中包含超应力参数 $ \\eta $（单位为 $ \\mathrm{s} $），以及在时长为 $ \\Delta t = 1 $（单位为 $ \\mathrm{s} $）的步长上使用后向欧拉时间离散化。离散塑性增量为 $ \\Delta \\gamma \\ge 0 $，使得 $ \\varepsilon^{p}_{n+1} = \\varepsilon^{p}_{n} + \\Delta \\gamma $ 且 $ \\alpha_{n+1} = \\varepsilon^{p}_{n+1} $。试探应力为 $ \\sigma_{\\mathrm{trial}} = E \\left( \\varepsilon_{n} + \\Delta \\varepsilon - \\varepsilon^{p}_{n} \\right) $，其中 $ \\varepsilon_{n} $ 是上一步的总应变，$ \\Delta \\varepsilon $ 是步长内的应变增量，$ \\varepsilon^{p}_{n} $ 是上一步的塑性应变。将相对于当前屈服面的试探超应力定义为 $ r_{\\mathrm{trial}} = \\sigma_{\\mathrm{trial}} - \\left( \\sigma_{y0} + H \\alpha_{n} \\right) $。\n\n指数为 $ m = 1 $ 的 Perzyna 法则的后向欧拉离散化得到标量隐式更新\n$$\n\\Delta \\gamma = \\frac{\\Delta t}{\\eta} \\, \\left\\langle f_{n+1} \\right\\rangle = \\frac{1}{\\eta} \\, \\max\\left( r_{\\mathrm{trial}} - (E+H)\\Delta \\gamma, \\, 0 \\right),\n$$\n其中 $ f_{n+1} = \\sigma_{n+1} - \\left( \\sigma_{y0} + H \\alpha_{n+1} \\right) $ 且 $ \\sigma_{n+1} = \\sigma_{\\mathrm{trial}} - E \\Delta \\gamma $。在 $ \\eta  0 $ 的粘性区域中，该更新是良定的。在率无关极限 $ \\eta \\to 0^{+} $ 下，塑性增量满足经典的一致性形式 $ \\Delta \\gamma = \\max(r_{\\mathrm{trial}},0)/(E+H) $。\n\n您的任务是创建一个关于 $ \\eta $ 的同伦延拓，从粘性状态（$ \\eta $ 较大）过渡到率无关状态（$ \\eta = 0 $），并使用上一个 $ \\eta $ 步的解作为初始猜测来初始化困难的步骤。对于每个测试用例，计算并报告在指定的 $ \\eta $ 值序列上的路径 $ \\alpha_{n+1}(\\eta) $。您必须为每个 $ \\eta  0 $ 实现一个鲁棒的求解器，用于求解关于 $ \\Delta \\gamma $ 的标量非线性方程，方法是基于分段残差\n$$\nR(\\Delta \\gamma; \\eta) = \\Delta \\gamma - \\frac{1}{\\eta} \\, \\max\\left( r_{\\mathrm{trial}} - (E+H)\\Delta \\gamma, \\, 0 \\right),\n$$\n使用牛顿法，其导数根据活动分支一致地选择。在 $ \\eta = 0 $ 时，使用率无关极限 $ \\Delta \\gamma = \\max(r_{\\mathrm{trial}},0)/(E+H) $。\n\n所有物理量都必须使用其适当的单位进行处理：$ E $ 和 $ H $ 的单位为 $ \\mathrm{Pa} $，$ \\sigma_{y0} $ 的单位为 $ \\mathrm{Pa} $，$ \\eta $ 的单位为 $ \\mathrm{s} $，$ \\varepsilon $、$ \\varepsilon^{p} $ 和 $ \\alpha $ 是无量纲应变。最终报告的 $ \\alpha_{n+1}(\\eta) $ 值必须是无量纲的。\n\n测试套件：\n所有测试均使用以下适用于金属的材料参数：$ E = 200 \\times 10^{9} \\, \\mathrm{Pa} $，$ H = 1 \\times 10^{9} \\, \\mathrm{Pa} $，$ \\sigma_{y0} = 250 \\times 10^{6} \\, \\mathrm{Pa} $，$ \\Delta t = 1 \\, \\mathrm{s} $。对于每个测试，计算在同伦序列 $ \\eta \\in \\{ 10^{3}, 10^{2}, 10^{1}, 10^{0}, 10^{-1}, 10^{-2}, 0 \\} $（单位为 $ \\mathrm{s} $）上的 $ \\alpha_{n+1}(\\eta) $，其中最后的 $ \\eta = 0 $ 表示率无关极限。\n\n- 测试 $ 1 $（严格弹性）：$ \\varepsilon_{n} = 0 $，$ \\varepsilon^{p}_{n} = 0 $，$ \\Delta \\varepsilon = 0.001 $。这导致 $ \\sigma_{\\mathrm{trial}} = 200 \\times 10^{6} \\, \\mathrm{Pa} $ 且 $ r_{\\mathrm{trial}}  0 $。\n- 测试 $ 2 $（位于屈服边界）：$ \\varepsilon_{n} = 0 $，$ \\varepsilon^{p}_{n} = 0 $，$ \\Delta \\varepsilon = \\sigma_{y0}/E = 0.00125 $。这导致 $ r_{\\mathrm{trial}} = 0 $。\n- 测试 $ 3 $（中等塑性）：$ \\varepsilon_{n} = 0 $，$ \\varepsilon^{p}_{n} = 0 $，$ \\Delta \\varepsilon = 0.002 $。这导致 $ r_{\\mathrm{trial}}  0 $。\n- 测试 $ 4 $（强塑性）：$ \\varepsilon_{n} = 0 $，$ \\varepsilon^{p}_{n} = 0 $，$ \\Delta \\varepsilon = 0.005 $。这导致 $ r_{\\mathrm{trial}} \\gg 0 $。\n\n要求输出：\n您的程序应生成一行输出，其中包含一个用方括号括起来的、以逗号分隔的列表。对于四个测试用例中的每一个，输出与有序 $ \\eta $ 序列 $ \\{ 10^{3}, 10^{2}, 10^{1}, 10^{0}, 10^{-1}, 10^{-2}, 0 \\} $ 相对应的 $ \\alpha_{n+1}(\\eta) $ 值列表。因此，最终输出格式必须是\n$$\n\\text{[ [a_{1,1}, a_{1,2}, \\dots, a_{1,7}], [a_{2,1}, \\dots, a_{2,7}], [a_{3,1}, \\dots, a_{3,7}], [a_{4,1}, \\dots, a_{4,7}] ]},\n$$\n其中每个 $ a_{i,j} $ 是一个无量纲浮点数，代表测试 $ i $ 的 $ \\alpha_{n+1}(\\eta_{j}) $。",
            "solution": "我们从一维小应变运动学 $ \\varepsilon = \\varepsilon^{e} + \\varepsilon^{p} $ 和胡克定律 $ \\sigma = E \\, \\varepsilon^{e} $ 出发，其中 $ E $ 是杨氏模量。各向同性硬化的内变量选择为 $ \\alpha = \\varepsilon^{p} $，单调拉伸下的屈服函数为 $ f(\\sigma,\\alpha) = \\sigma - (\\sigma_{y0} + H \\alpha) $，其中 $ \\sigma_{y0} $ 是初始屈服应力，$ H $ 是线性硬化模量。\n\n考虑在时长 $ \\Delta t = 1 $ 内从步骤 $ n $ 到步骤 $ n+1 $ 的离散更新。在已知上一步总应变 $ \\varepsilon_{n} $ 和应变增量 $ \\Delta \\varepsilon $ 的假设下，定义试探应力为\n$$\n\\sigma_{\\mathrm{trial}} = E \\left( \\varepsilon_{n} + \\Delta \\varepsilon - \\varepsilon^{p}_{n} \\right).\n$$\n更新后的塑性应变为 $ \\varepsilon^{p}_{n+1} = \\varepsilon^{p}_{n} + \\Delta \\gamma $，其中 $ \\Delta \\gamma \\ge 0 $。更新后的应力则为\n$$\n\\sigma_{n+1} = E \\left( \\varepsilon_{n} + \\Delta \\varepsilon - \\varepsilon^{p}_{n+1} \\right) = \\sigma_{\\mathrm{trial}} - E \\Delta \\gamma.\n$$\n更新后的内变量为 $ \\alpha_{n+1} = \\varepsilon^{p}_{n+1} = \\alpha_{n} + \\Delta \\gamma $。更新后的屈服函数为\n$$\nf_{n+1} = \\sigma_{n+1} - \\left( \\sigma_{y0} + H \\alpha_{n+1} \\right) = \\sigma_{\\mathrm{trial}} - E \\Delta \\gamma - \\left( \\sigma_{y0} + H \\alpha_{n} + H \\Delta \\gamma \\right).\n$$\n合并项以定义相对于当前屈服面的试探超应力，\n$$\nr_{\\mathrm{trial}} := \\sigma_{\\mathrm{trial}} - \\left( \\sigma_{y0} + H \\alpha_{n} \\right),\n$$\n这样更新后的屈服函数可写作\n$$\nf_{n+1} = r_{\\mathrm{trial}} - (E+H) \\Delta \\gamma.\n$$\n\n对于使用指数 $ m = 1 $ 和超应力参数 $ \\eta $ 的 Perzyna 型超应力正则化的粘塑性，后向欧拉离散化（$ \\Delta t = 1 $）得到隐式标量方程\n$$\n\\Delta \\gamma = \\frac{1}{\\eta} \\, \\left\\langle f_{n+1} \\right\\rangle = \\frac{1}{\\eta} \\, \\max\\left( r_{\\mathrm{trial}} - (E+H)\\Delta \\gamma, \\, 0 \\right).\n$$\n为牛顿法定义残差，\n$$\nR(\\Delta \\gamma; \\eta) = \\Delta \\gamma - \\frac{1}{\\eta} \\, \\max\\left( r_{\\mathrm{trial}} - (E+H)\\Delta \\gamma, \\, 0 \\right).\n$$\n有两种情况：\n\n- 如果 $ r_{\\mathrm{trial}} \\le 0 $，即弹性区域，则 $ \\left\\langle f_{n+1} \\right\\rangle = 0 $，唯一容许解为 $ \\Delta \\gamma = 0 $，因此对于任何 $ \\eta \\ge 0 $ 都有 $ \\alpha_{n+1} = \\alpha_{n} $。\n\n- 如果 $ r_{\\mathrm{trial}}  0 $，即塑性区域，则解在收敛时必须满足 $ r_{\\mathrm{trial}} - (E+H)\\Delta \\gamma  0 $（否则方程右侧将为零，从而错误地强制 $ \\Delta \\gamma = 0 $）。在此活动分支上，残差简化为线性形式，\n$$\nR(\\Delta \\gamma; \\eta) = \\Delta \\gamma - \\frac{1}{\\eta} \\left( r_{\\mathrm{trial}} - (E+H)\\Delta \\gamma \\right) = \\Delta \\gamma \\left( 1 + \\frac{E+H}{\\eta} \\right) - \\frac{r_{\\mathrm{trial}}}{\\eta}.\n$$\n令 $ R = 0 $ 可得到 $ \\eta  0 $ 时的唯一解，\n$$\n\\Delta \\gamma(\\eta) = \\frac{r_{\\mathrm{trial}}}{\\eta + E + H}.\n$$\n可以验证其一致性：代回可得 $ f_{n+1} = r_{\\mathrm{trial}} - (E+H)\\Delta \\gamma = r_{\\mathrm{trial}} \\left( \\frac{\\eta}{\\eta + E + H} \\right)  0 $，这对于 $ r_{\\mathrm{trial}}  0 $ 和 $ \\eta  0 $ 是必需的。当 $ \\eta \\to 0^{+} $ 时，率无关极限变为\n$$\n\\Delta \\gamma(0) = \\frac{r_{\\mathrm{trial}}}{E+H},\n$$\n这是一维线性各向同性硬化的经典返回映射更新。\n\n因此，内变量 $ \\alpha_{n+1}(\\eta) $ 的路径为\n$$\n\\alpha_{n+1}(\\eta) =\n\\begin{cases}\n\\alpha_{n},  r_{\\mathrm{trial}} \\le 0, \\\\\n\\alpha_{n} + \\dfrac{r_{\\mathrm{trial}}}{\\eta + E + H},  r_{\\mathrm{trial}}  0,\\; \\eta  0, \\\\\n\\alpha_{n} + \\dfrac{r_{\\mathrm{trial}}}{E + H},  r_{\\mathrm{trial}}  0,\\; \\eta = 0.\n\\end{cases}\n$$\n对于 $ r_{\\mathrm{trial}}  0 $，此路径关于 $ \\eta $ 是单调递减的，因为分母 $ \\eta + E + H $ 随 $ \\eta $ 增大而增大；而对于 $ r_{\\mathrm{trial}} \\le 0 $，路径是恒定的。\n\n同伦延拓算法：\n我们从粘性区域的一个较大的 $ \\eta $ 值开始，逐步过渡到率无关极限 $ \\eta = 0 $，并将上一个 $ \\eta $ 步的解用作牛顿法的初始猜测。对于 $ \\eta  0 $，活动分支上的残差导数为\n$$\n\\frac{\\partial R}{\\partial \\Delta \\gamma} =\n\\begin{cases}\n1,  r_{\\mathrm{trial}} - (E+H)\\Delta \\gamma \\le 0, \\\\\n1 + \\dfrac{E+H}{\\eta},  r_{\\mathrm{trial}} - (E+H)\\Delta \\gamma  0,\n\\end{cases}\n$$\n这确保了牛顿法在活动分支上单次迭代即可收敛，因为残差是关于 $ \\Delta \\gamma $ 的线性函数。尽管如此，我们还是鲁棒地实现了牛顿法，并通过显式计算 max 算子来保护分支条件。在 $ \\eta = 0 $ 时，我们使用显式的率无关极限 $ \\Delta \\gamma = \\max(r_{\\mathrm{trial}},0)/(E+H) $。\n\n测试套件规范和单位：\n所有测试均使用 $ E = 200 \\times 10^{9} \\, \\mathrm{Pa} $，$ H = 1 \\times 10^{9} \\, \\mathrm{Pa} $，$ \\sigma_{y0} = 250 \\times 10^{6} \\, \\mathrm{Pa} $，$ \\Delta t = 1 \\, \\mathrm{s} $。应变变量 $ \\varepsilon $、$ \\varepsilon^{p} $ 和 $ \\alpha $ 是无量纲的；报告的 $ \\alpha_{n+1}(\\eta) $ 值必须是无量纲的。同伦参数序列为 $ \\eta \\in \\{ 10^{3}, 10^{2}, 10^{1}, 10^{0}, 10^{-1}, 10^{-2}, 0 \\} $，单位为 $ \\mathrm{s} $。\n\n对于四个测试：\n- 测试 $ 1 $：$ \\varepsilon_{n} = 0 $，$ \\varepsilon^{p}_{n} = 0 $，$ \\Delta \\varepsilon = 0.001 $ 给出 $ \\sigma_{\\mathrm{trial}} = 200 \\times 10^{6} \\, \\mathrm{Pa} $ 和 $ r_{\\mathrm{trial}} = -50 \\times 10^{6} \\, \\mathrm{Pa} \\le 0 $，所以对于所有 $ \\eta $，$ \\alpha_{n+1}(\\eta) = 0 $。\n- 测试 $ 2 $：$ \\varepsilon_{n} = 0 $，$ \\varepsilon^{p}_{n} = 0 $，$ \\Delta \\varepsilon = \\sigma_{y0}/E = 0.00125 $ 得到 $ r_{\\mathrm{trial}} = 0 $，所以对于所有 $ \\eta $，$ \\alpha_{n+1}(\\eta) = 0 $。\n- 测试 $ 3 $：$ \\varepsilon_{n} = 0 $，$ \\varepsilon^{p}_{n} = 0 $，$ \\Delta \\varepsilon = 0.002 $ 给出 $ \\sigma_{\\mathrm{trial}} = 400 \\times 10^{6} \\, \\mathrm{Pa} $，$ r_{\\mathrm{trial}} = 150 \\times 10^{6} \\, \\mathrm{Pa}  0 $，所以 $ \\alpha_{n+1}(\\eta) = \\dfrac{150 \\times 10^{6}}{\\eta + 201 \\times 10^{9}} $。\n- 测试 $ 4 $：$ \\varepsilon_{n} = 0 $，$ \\varepsilon^{p}_{n} = 0 $，$ \\Delta \\varepsilon = 0.005 $ 给出 $ \\sigma_{\\mathrm{trial}} = 1 \\times 10^{9} \\, \\mathrm{Pa} $，$ r_{\\mathrm{trial}} = 750 \\times 10^{6} \\, \\mathrm{Pa}  0 $，所以 $ \\alpha_{n+1}(\\eta) = \\dfrac{750 \\times 10^{6}}{\\eta + 201 \\times 10^{9}} $。\n\n程序将为了完整性而实现同伦延拓和牛頓法，尽管已有闭式解；它将为每个测试计算并输出列表 $ \\left[ \\alpha_{n+1}(10^{3}), \\alpha_{n+1}(10^{2}), \\alpha_{n+1}(10^{1}), \\alpha_{n+1}(10^{0}), \\alpha_{n+1}(10^{-1}), \\alpha_{n+1}(10^{-2}), \\alpha_{n+1}(0) \\right] $，格式如指定要求。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_delta_gamma(r_trial: float, E: float, H: float, eta: float, init_gamma: float = 0.0, tol: float = 1e-16, max_iter: int = 25) - float:\n    \"\"\"\n    Solve the scalar viscoplastic update for Delta gamma using Newton's method on:\n        R(gamma; eta) = gamma - (1/eta) * max(r_trial - (E+H)*gamma, 0) = 0  for eta  0.\n    For eta == 0, return the rate-independent limit gamma = max(r_trial, 0)/(E+H).\n    \"\"\"\n    if r_trial = 0.0:\n        # Elastic: no plastic increment for any eta.\n        return 0.0\n    if eta == 0.0:\n        # Rate-independent limit.\n        return r_trial / (E + H)\n\n    gamma = max(init_gamma, 0.0)\n    for _ in range(max_iter):\n        # Evaluate residual with the max operator.\n        arg = r_trial - (E + H) * gamma\n        pos_part = arg if arg > 0.0 else 0.0\n        R = gamma - (pos_part / eta)\n        # Derivative depends on the active branch.\n        if arg > 0.0:\n            dR = 1.0 + (E + H) / eta\n        else:\n            dR = 1.0\n        # Newton update\n        delta = -R / dR\n        gamma += delta\n        # Safeguards: gamma must be nonnegative\n        if gamma  0.0:\n            gamma = 0.0\n        # Convergence check\n        if abs(delta)  tol:\n            break\n    # Final projection to active branch if needed\n    if r_trial - (E + H) * gamma = 0.0:\n        # If we fell into the inactive branch, the correct solution is gamma = 0\n        # but since r_trial  0 for entering this function, the active solution exists.\n        # To ensure robustness, use the closed form.\n        gamma = r_trial / (eta + E + H)\n    return gamma\n\ndef compute_alpha_path(E: float, H: float, sigma_y0: float, eps_n: float, eps_p_n: float, delta_eps: float, eta_values: list[float]) - list[float]:\n    \"\"\"\n    Compute alpha_{n+1}(eta) along a homotopy path of eta values, using continuation:\n    previous solution as initial guess for the next eta.\n    \"\"\"\n    sigma_trial = E * (eps_n + delta_eps - eps_p_n)\n    r_trial = sigma_trial - (sigma_y0 + H * eps_p_n)\n    alpha_n = eps_p_n\n    path = []\n    prev_gamma = 0.0\n    for eta in eta_values:\n        gamma = solve_delta_gamma(r_trial, E, H, eta, init_gamma=prev_gamma)\n        alpha_np1 = alpha_n + gamma\n        path.append(alpha_np1)\n        prev_gamma = gamma\n    return path\n\ndef solve():\n    # Material parameters (SI units)\n    E = 200.0e9      # Pa\n    H = 1.0e9        # Pa\n    sigma_y0 = 250.0e6  # Pa\n    # Homotopy eta values (s), including the rate-independent limit represented by 0\n    eta_values = [1e3, 1e2, 1e1, 1e0, 1e-1, 1e-2, 0.0]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (eps_n, eps_p_n, delta_eps) for each test\n        (0.0, 0.0, 0.001),          # Test 1: strictly elastic\n        (0.0, 0.0, sigma_y0 / E),   # Test 2: at yield boundary\n        (0.0, 0.0, 0.002),          # Test 3: moderately plastic\n        (0.0, 0.0, 0.005),          # Test 4: strongly plastic\n    ]\n\n    results = []\n    for eps_n, eps_p_n, delta_eps in test_cases:\n        path = compute_alpha_path(E, H, sigma_y0, eps_n, eps_p_n, delta_eps, eta_values)\n        # Convert to regular Python floats for printing\n        results.append([float(x) for x in path])\n\n    # Final print statement in the exact required format.\n    # Single line: nested lists for the four test cases.\n    def format_list(lst):\n        return \"[\" + \",\".join(f\"{x:.12g}\" for x in lst) + \"]\"\n    print(\"[\" + \",\".join(format_list(r) for r in results) + \"]\")\n\nsolve()\n```"
        }
    ]
}