{
    "hands_on_practices": [
        {
            "introduction": "The heart of logarithmic strain space algorithms is the computation of the matrix logarithm of a stretch tensor, typically the right stretch tensor $\\mathbf{U}$. This foundational exercise solidifies the definition of the Hencky strain $\\ln \\mathbf{U}$ via its spectral decomposition and explores the critical numerical implications that arise when principal stretches approach their physical limits of zero or infinity . Understanding these numerical realities is the first step toward writing robust and stable code for finite deformation analysis.",
            "id": "3579140",
            "problem": "Consider a homogeneous deformation with deformation gradient $\\mathbf{F} \\in \\mathbb{R}^{3 \\times 3}$ admitting the polar decomposition $\\mathbf{F} = \\mathbf{R} \\mathbf{U}$, where $\\mathbf{R} \\in \\mathrm{SO}(3)$ is a proper orthogonal tensor and $\\mathbf{U} \\in \\mathbb{R}^{3 \\times 3}$ is the right stretch tensor. Assume $\\mathbf{U}$ is symmetric positive definite (SPD) with principal stretches $\\lambda_{1} > 0$, $\\lambda_{2} > 0$, and $\\lambda_{3} > 0$, and that an orthonormal basis exists in which $\\mathbf{U}$ is diagonal, $\\mathbf{U} = \\mathrm{diag}(\\lambda_{1}, \\lambda_{2}, \\lambda_{3})$. In logarithmic strain space algorithms, the Hencky (logarithmic) strain tensor is defined by the matrix logarithm of the stretch, $\\ln \\mathbf{U}$.\n\nStarting from the spectral characterization of analytic functions of SPD tensors and the properties of the natural logarithm on $(0,\\infty)$, compute the matrix logarithm $\\ln \\mathbf{U}$ in closed form for the given diagonal $\\mathbf{U}$. In addition, explain, based on first principles of numerical analysis and calculus, the qualitative behavior and numerical implications when any $\\lambda_{i}$ approaches zero or becomes very large in computations that form $\\ln \\mathbf{U}$ and its algorithmic tangent. Your final answer must be the single analytical expression for $\\ln \\mathbf{U}$. No rounding is required, and no physical units are involved.",
            "solution": "The problem statement is valid. It is scientifically grounded in continuum mechanics, well-posed, and presented with objective, precise language. All provided information is self-consistent and sufficient for deriving a solution.\n\nThe primary task is to compute the Hencky strain tensor, defined as the matrix logarithm $\\ln \\mathbf{U}$, where $\\mathbf{U}$ is the symmetric positive definite (SPD) right stretch tensor. We are given that in some orthonormal basis, $\\mathbf{U}$ is diagonal, $\\mathbf{U} = \\mathrm{diag}(\\lambda_{1}, \\lambda_{2}, \\lambda_{3})$, where $\\lambda_{i} > 0$ are the principal stretches.\n\nThe computation of a function of a matrix, such as $\\ln \\mathbf{U}$, is defined through its spectral decomposition. For a symmetric (and thus diagonalizable) matrix $\\mathbf{U}$, the spectral theorem states that it can be written as:\n$$\n\\mathbf{U} = \\sum_{i=1}^{3} \\lambda_{i} \\mathbf{n}_{i} \\otimes \\mathbf{n}_{i}\n$$\nwhere $\\lambda_{i}$ are the real eigenvalues (the principal stretches) and $\\mathbf{n}_{i}$ are the corresponding orthonormal eigenvectors (the principal directions of stretch).\n\nIf a scalar function $f(x)$ is analytic on the spectrum of $\\mathbf{U}$ (i.e., at all eigenvalues $\\lambda_{i}$), then the tensor-valued function $f(\\mathbf{U})$ is defined as:\n$$\nf(\\mathbf{U}) = \\sum_{i=1}^{3} f(\\lambda_{i}) \\mathbf{n}_{i} \\otimes \\mathbf{n}_{i}\n$$\nThis is the spectral characterization of an analytic function of an SPD tensor.\n\nIn this problem, the function is the natural logarithm, $f(x) = \\ln(x)$. The domain of analyticity for $\\ln(x)$ is the set of positive real numbers, $(0, \\infty)$. Since the stretch tensor $\\mathbf{U}$ is symmetric positive definite (SPD), its eigenvalues $\\lambda_{i}$ (the principal stretches) are all strictly positive. Thus, the spectrum of $\\mathbf{U}$ lies entirely within the domain of analyticity of the natural logarithm, and $\\ln \\mathbf{U}$ is well-defined.\n\nWe are given that in the basis of its eigenvectors $\\{\\mathbf{n}_1, \\mathbf{n}_2, \\mathbf{n}_3\\}$, the matrix representation of $\\mathbf{U}$ is diagonal:\n$$\n[\\mathbf{U}] = \\begin{pmatrix} \\lambda_1 & 0 & 0 \\\\ 0 & \\lambda_2 & 0 \\\\ 0 & 0 & \\lambda_3 \\end{pmatrix}\n$$\nApplying the definition of a matrix function, we substitute $f(\\lambda_{i}) = \\ln(\\lambda_{i})$ into the spectral representation of $f(\\mathbf{U})$. In the same orthonormal basis, the matrix representation of $\\ln \\mathbf{U}$ will be:\n$$\n[\\ln \\mathbf{U}] = \\begin{pmatrix} f(\\lambda_1) & 0 & 0 \\\\ 0 & f(\\lambda_2) & 0 \\\\ 0 & 0 & f(\\lambda_3) \\end{pmatrix} = \\begin{pmatrix} \\ln(\\lambda_1) & 0 & 0 \\\\ 0 & \\ln(\\lambda_2) & 0 \\\\ 0 & 0 & \\ln(\\lambda_3) \\end{pmatrix}\n$$\nThis is the closed-form expression for the Hencky strain tensor in the principal basis of stretch.\n\nThe second part of the problem requires an explanation of the qualitative behavior and numerical implications under extreme stretches.\n\n**Case 1: A principal stretch approaches zero ($\\lambda_{i} \\to 0^{+}$)**\nThis corresponds to a state of extreme compression, where a material element is being crushed to zero length in the direction $\\mathbf{n}_{i}$.\n*   **Qualitative Behavior**: As $\\lambda_{i} \\to 0^{+}$, the corresponding principal logarithmic strain, $\\ln(\\lambda_{i})$, approaches $-\\infty$. This correctly represents an infinite compressive strain required to achieve a volume collapse in that direction.\n*   **Numerical Implications**: Standard floating-point arithmetic cannot represent $-\\infty$ without special flags. Computations involving $\\lambda_{i}$ close to zero will cause the value of $\\ln(\\lambda_{i})$ to become a very large negative number, potentially resulting in underflow or being flagged as `-Inf`. This can propagate through the algorithm, leading to `NaN` (Not a Number) results and failure of the numerical simulation (e.g., a Newton-Raphson iterative solver). Furthermore, the algorithmic tangent modulus, which is the fourth-order tensor representing the derivative of the Kirchhoff stress with respect to the logarithmic strain, often contains terms that become singular or ill-conditioned. For instance, components of the tangent can involve expressions like $\\frac{\\ln(\\lambda_i) - \\ln(\\lambda_j)}{\\lambda_i^2 - \\lambda_j^2}$. As $\\lambda_i \\to 0^+$, the numerator diverges to $-\\infty$ while the denominator remains finite (assuming $\\lambda_j > 0$), causing these tangent components to become infinite. This leads to an ill-conditioned stiffness matrix, convergence failure, and numerical instability.\n\n**Case 2: A principal stretch becomes very large ($\\lambda_{i} \\to \\infty$)**\nThis corresponds to a state of extreme tension, where a material element is stretched indefinitely in the direction $\\mathbf{n}_{i}$.\n*   **Qualitative Behavior**: As $\\lambda_{i} \\to \\infty$, the principal logarithmic strain $\\ln(\\lambda_{i})$ also approaches $+\\infty$. The logarithmic measure means the strain grows much more slowly than the stretch itself, which is a key advantage of this strain measure for large deformation analysis.\n*   **Numerical Implications**: While $\\ln(\\lambda_{i})$ grows without bound, it does so very slowly. Numerical overflow might occur on $\\lambda_{i}$ or related quantities (like $\\lambda_i^2$) before it occurs on $\\ln(\\lambda_{i})$. The primary numerical issue again relates to the conditioning of the algorithmic tangent. In the term $\\frac{\\ln(\\lambda_i) - \\ln(\\lambda_j)}{\\lambda_i^2 - \\lambda_j^2}$, as $\\lambda_i \\to \\infty$, the denominator grows like $\\lambda_i^2$ while the numerator grows like $\\ln(\\lambda_i)$. By L'Hôpital's rule, the term approaches $0$. While this may appear stable, having some tangent components approach zero while others remain finite can still cause severe ill-conditioning. A very large disparity between eigenvalues (e.g., $\\lambda_{i} \\gg \\lambda_{j}$) makes the system numerically \"stiff,\" where the stiffness matrix has eigenvalues of vastly different magnitudes. This is notoriously difficult for iterative linear solvers to handle, leading to poor convergence rates or failure.\n\nIn summary, the logarithmic mapping poses significant numerical challenges at the extremes of deformation (both extreme compression and tension), which must be handled with specialized numerical techniques in robust computational solid mechanics codes.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\ln(\\lambda_1) & 0 & 0 \\\\\n0 & \\ln(\\lambda_2) & 0 \\\\\n0 & 0 & \\ln(\\lambda_3)\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "With a firm grasp of the logarithmic strain tensor, we can now build a complete constitutive update algorithm. This practice focuses on implementing the workhorse of computational plasticity: the elastic-predictor, plastic-corrector scheme. By developing a return-mapping algorithm for a uniaxial bar from first principles, you will gain hands-on experience in translating the theory of finite strain elastoplasticity into a functional numerical model .",
            "id": "3579149",
            "problem": "Design a complete and verifiable algorithm for a single-step uniaxial update in finite strain elastoplasticity using the logarithmic (Hencky) strain space. The goal is to compute the updated stress and plastic strain for a uniaxial bar undergoing a specified total logarithmic strain at the end of the step. The derivation must begin from first principles appropriate to finite strain plasticity modeled in logarithmic strain space, and the implementation must follow the elastic predictor/plastic corrector structure in a rate-independent formulation with isotropic hardening.\n\nFundamental bases to use:\n- Kinematics: In one dimension, the total stretch is denoted by $\\lambda$, and the total logarithmic strain (Hencky strain) is $h = \\ln \\lambda$. The determinant of the deformation gradient (the Jacobian) is $J=\\lambda$, and the elastic-logarithmic strain and plastic-logarithmic strain add: $h = h_{\\mathrm{e}} + h_{\\mathrm{p}}$.\n- Work-conjugacy: The Kirchhoff stress $\\tau$ is work-conjugate to the logarithmic strain rate. In one dimension, the elastic constitutive relation in logarithmic strain space is $\\tau = E\\, h_{\\mathrm{e}} = E \\left(h - h_{\\mathrm{p}}\\right)$, where $E$ is the Young’s modulus.\n- Plasticity: Use a one-dimensional associative rate-independent plasticity with isotropic hardening. The yield function is $\\phi(\\tau,\\alpha) = |\\tau| - \\tau_{\\mathrm{y}}(\\alpha)$ with $\\tau_{\\mathrm{y}}(\\alpha)=\\tau_{\\mathrm{y0}}+H\\,\\alpha$, where $\\alpha$ is the accumulated plastic strain, $\\tau_{\\mathrm{y0}}$ is the initial yield stress, and $H$ is the isotropic hardening modulus. The Kuhn–Tucker conditions, consistency, and associative flow hold. In one dimension, the plastic flow direction is given by the sign of $\\tau$.\n\nYou must:\n- Derive the scalar return-mapping corrector in logarithmic strain space for the uniaxial case starting from these bases, without invoking any unproven shortcut formulas. Clearly show how the plastic multiplier is obtained under the consistency condition in the plastic regime.\n- Implement the elastic predictor and plastic corrector to compute the updated quantities at the end of the step: the Kirchhoff stress $\\tau_{n+1}$, plastic logarithmic strain $h_{\\mathrm{p},n+1}$, and accumulated plastic strain $\\alpha_{n+1}$. Finally, compute the Cauchy stress $\\sigma_{n+1}$ using $\\sigma_{n+1}=\\tau_{n+1}/\\lambda_{n+1}$ with $\\lambda_{n+1}=\\exp(h_{n+1})$.\n- For the purpose of numerical reporting, express the final Cauchy stress in megapascal (MPa). The strains $h_{\\mathrm{p}}$ and $\\alpha$ are dimensionless. All returned floating-point values must be rounded to $6$ decimal places.\n\nInput specification for each test case:\n- Material parameters: $E$ (in MPa), $\\tau_{\\mathrm{y0}}$ (in MPa), $H$ (in MPa).\n- State/input at step end: total logarithmic strain $h_{n+1}$ (dimensionless), prior plastic logarithmic strain $h_{\\mathrm{p},n}$ (dimensionless), prior accumulated plastic strain $\\alpha_n$ (dimensionless).\n\nOutput specification per test case:\n- A list of $3$ floats $[\\sigma_{n+1}, h_{\\mathrm{p},n+1}, \\alpha_{n+1}]$ where $\\sigma_{n+1}$ is in MPa and all values are rounded to $6$ decimals.\n\nYour program must process the following test suite and produce the aggregated results in a single line. Use exactly the parameter values provided below.\n\nTest suite (each bullet provides $(E,\\tau_{\\mathrm{y0}},H,h_{n+1},h_{\\mathrm{p},n},\\alpha_n)$):\n- Case A: $(200000, 300, 1000, 0.0005, 0.0, 0.0)$\n- Case B: $(210000, 250, 0, 0.003, 0.0, 0.0)$\n- Case C: $(70000, 100, 1000, 0.01, 0.0, 0.0)$\n- Case D: $(100000, 200, 500, -0.005, 0.0, 0.0)$\n- Case E: $(150000, 300, 200, 0.002, 0.0, 0.0)$\n- Case F: $(210000, 250, 5000, 0.003, 0.01, 0.01)$\n\nFinal output format:\n- Your program should produce a single line of output containing a Python-like list of the per-case lists, with no spaces, and each float rounded to $6$ decimals. For example, a valid format would look like: $[[1.234000,0.000000,0.000000],[\\dots]]$ where the ellipsis denotes additional cases.\n\nAngle units are not applicable. Ensure scientific realism and numerical consistency. No user input is required; the program must embed the test suite and print the results as a single line in the exact format described.",
            "solution": "The user-provided problem is assessed to be **valid**. It is scientifically grounded in the principles of continuum mechanics and computational plasticity, well-posed, objective, and contains all necessary information for a unique solution. The derivation and implementation of a return-mapping algorithm for finite strain uniaxial elastoplasticity in logarithmic strain space will now be presented.\n\n### **1. Problem Formulation**\n\nThe problem concerns the state update for a uniaxial bar undergoing finite deformation. The kinematics are described in terms of the total logarithmic strain, $h = \\ln \\lambda$, where $\\lambda$ is the stretch. The model assumes an additive decomposition of the total logarithmic strain into elastic and plastic parts:\n$$h = h_{\\mathrm{e}} + h_{\\mathrm{p}}$$\nThe state of the material at the beginning of a time step, denoted by subscript $n$, is characterized by the plastic logarithmic strain $h_{\\mathrm{p},n}$ and the accumulated plastic strain $\\alpha_n$. The problem requires finding the updated state $\\{h_{\\mathrm{p},n+1}, \\alpha_{n+1}\\}$ and the corresponding stresses at the end of the step, denoted by subscript $n+1$, given the total logarithmic strain $h_{n+1}$.\n\nThe constitutive relations are:\n- **Elasticity**: The Kirchhoff stress $\\tau$ is related to the elastic logarithmic strain $h_{\\mathrm{e}}$ via Young's modulus $E$:\n  $$\\tau = E h_{\\mathrm{e}} = E(h - h_{\\mathrm{p}})$$\n- **Yield Condition**: Plastic flow occurs when the yield function $\\phi$ is positive. For one-dimensional isotropic hardening, the yield function is:\n  $$\\phi(\\tau, \\alpha) = |\\tau| - \\tau_{\\mathrm{y}}(\\alpha) \\leq 0$$\n  where the yield stress $\\tau_{\\mathrm{y}}$ is a linear function of the accumulated plastic strain $\\alpha$:\n  $$\\tau_{\\mathrm{y}}(\\alpha) = \\tau_{\\mathrm{y0}} + H \\alpha$$\n  Here, $\\tau_{\\mathrm{y0}}$ is the initial yield stress and $H$ is the constant hardening modulus.\n- **Flow Rule**: An associative flow rule is assumed, where the increment of plastic strain is directed along the gradient of the yield function with respect to stress:\n  $$\\Delta h_{\\mathrm{p}} = h_{\\mathrm{p},n+1} - h_{\\mathrm{p},n} = \\Delta \\gamma \\frac{\\partial \\phi}{\\partial \\tau} = \\Delta \\gamma \\, \\text{sgn}(\\tau_{n+1})$$\n  where $\\Delta \\gamma \\geq 0$ is the plastic multiplier for the step.\n- **Hardening Law**: The increment of accumulated plastic strain is equal to the magnitude of the plastic strain increment, which in one dimension is simply the plastic multiplier:\n  $$\\Delta \\alpha = \\alpha_{n+1} - \\alpha_n = |\\Delta h_{\\mathrm{p}}| = \\Delta \\gamma$$\n\nThe final Cauchy stress $\\sigma_{n+1}$ is obtained from the Kirchhoff stress $\\tau_{n+1}$ via the relation:\n$$\\sigma_{n+1} = \\frac{\\tau_{n+1}}{J_{n+1}} = \\frac{\\tau_{n+1}}{\\lambda_{n+1}} = \\frac{\\tau_{n+1}}{\\exp(h_{n+1})}$$\n\n### **2. Algorithm Derivation: Return Mapping**\n\nThe algorithm is based on the standard elastic predictor/plastic corrector structure, which is an implicit time integration scheme.\n\n#### **Step 2.1: Elastic Predictor**\n\nFirst, assume the step is entirely elastic. The plastic state variables are provisionally held constant. The \"trial\" state is computed as follows:\n- Trial plastic strain: $h_{\\mathrm{p, trial}} = h_{\\mathrm{p},n}$\n- Trial accumulated plastic strain: $\\alpha_{\\text{trial}} = \\alpha_n$\n- Trial elastic strain: $h_{\\mathrm{e, trial}} = h_{n+1} - h_{\\mathrm{p, trial}} = h_{n+1} - h_{\\mathrm{p},n}$\n- Trial Kirchhoff stress: This is computed using the elastic law:\n  $$\\tau_{\\text{trial}} = E h_{\\mathrm{e, trial}} = E (h_{n+1} - h_{\\mathrm{p},n})$$\n\n#### **Step 2.2: Yield Check**\n\nThe trial state is checked against the yield condition. The yield stress at the beginning of the step is $\\tau_{\\mathrm{y},n} = \\tau_{\\mathrm{y0}} + H \\alpha_n$. The trial yield function value is:\n$$\\phi_{\\text{trial}} = |\\tau_{\\text{trial}}| - \\tau_{\\mathrm{y},n} = |\\tau_{\\text{trial}}| - (\\tau_{\\mathrm{y0}} + H \\alpha_n)$$\n\n- If $\\phi_{\\text{trial}} \\le 0$, the elastic assumption is correct. The trial state is the final state.\n  - $\\tau_{n+1} = \\tau_{\\text{trial}}$\n  - $h_{\\mathrm{p},n+1} = h_{\\mathrm{p},n}$\n  - $\\alpha_{n+1} = \\alpha_n$\n\n- If $\\phi_{\\text{trial}} > 0$, plastic deformation has occurred. The trial state violates the yield condition, and a plastic correction is required.\n\n#### **Step 2.3: Plastic Corrector**\n\nWhen plasticity occurs, the state at the end of the step must satisfy the full set of constitutive equations simultaneously. This is the \"return mapping\" phase, which projects the trial stress back to the updated yield surface. The system of equations to be solved for the unknowns $\\{\\tau_{n+1}, h_{\\mathrm{p},n+1}, \\alpha_{n+1}, \\Delta\\gamma\\}$ is:\n1.  **Elasticity**: $\\tau_{n+1} = E(h_{n+1} - h_{\\mathrm{p},n+1})$\n2.  **Flow Rule**: $h_{\\mathrm{p},n+1} = h_{\\mathrm{p},n} + \\Delta \\gamma \\, \\text{sgn}(\\tau_{\\text{trial}})$ (Note: $\\text{sgn}(\\tau_{n+1})=\\text{sgn}(\\tau_{\\text{trial}})$ since the return path is radial in stress space)\n3.  **Hardening Law**: $\\alpha_{n+1} = \\alpha_n + \\Delta \\gamma$\n4.  **Consistency Condition**: $\\phi_{n+1} = |\\tau_{n+1}| - (\\tau_{\\mathrm{y0}} + H \\alpha_{n+1}) = 0$\n\nWe solve this system for the plastic multiplier $\\Delta\\gamma$. Substitute Eq. (2) into Eq. (1):\n$$\\tau_{n+1} = E(h_{n+1} - (h_{\\mathrm{p},n} + \\Delta \\gamma \\, \\text{sgn}(\\tau_{\\text{trial}})))$$\n$$\\tau_{n+1} = E(h_{n+1} - h_{\\mathrm{p},n}) - E \\Delta \\gamma \\, \\text{sgn}(\\tau_{\\text{trial}})$$\nRecognizing $E(h_{n+1} - h_{\\mathrm{p},n})$ as $\\tau_{\\text{trial}}$, we have:\n$$\\tau_{n+1} = \\tau_{\\text{trial}} - E \\Delta \\gamma \\, \\text{sgn}(\\tau_{\\text{trial}})$$\nMultiplying by $\\text{sgn}(\\tau_{\\text{trial}})$ and using $|\\tau| = \\tau \\cdot \\text{sgn}(\\tau)$ and $(\\text{sgn}(\\tau_{\\text{trial}}))^2=1$:\n$$|\\tau_{n+1}| = |\\tau_{\\text{trial}}| - E \\Delta \\gamma$$\nNow, substitute this expression for $|\\tau_{n+1}|$ and the hardening law (Eq. 3) into the consistency condition (Eq. 4):\n$$(|\\tau_{\\text{trial}}| - E \\Delta \\gamma) - (\\tau_{\\mathrm{y0}} + H (\\alpha_n + \\Delta \\gamma)) = 0$$\nRearranging to solve for $\\Delta\\gamma$:\n$$|\\tau_{\\text{trial}}| - (\\tau_{\\mathrm{y0}} + H \\alpha_n) = E \\Delta \\gamma + H \\Delta \\gamma$$\nThe left-hand side is precisely the trial yield function value, $\\phi_{\\text{trial}}$:\n$$\\phi_{\\text{trial}} = (E + H) \\Delta \\gamma$$\nThus, the plastic multiplier is determined as:\n$$\\Delta \\gamma = \\frac{\\phi_{\\text{trial}}}{E + H} = \\frac{|\\tau_{\\text{trial}}| - (\\tau_{\\mathrm{y0}} + H \\alpha_n)}{E + H}$$\nSince we are in the plastic case, $\\phi_{\\text{trial}} > 0$. With $E > 0$ and $H \\ge 0$, it follows that $\\Delta \\gamma > 0$, as required.\n\nWith $\\Delta \\gamma$ known, the state variables are updated:\n- **Accumulated Plastic Strain**:\n  $$\\alpha_{n+1} = \\alpha_n + \\Delta \\gamma$$\n- **Plastic Logarithmic Strain**:\n  $$h_{\\mathrm{p},n+1} = h_{\\mathrm{p},n} + \\Delta \\gamma \\, \\text{sgn}(\\tau_{\\text{trial}})$$\n- **Kirchhoff Stress**: From the consistency condition, we know $|\\tau_{n+1}| = \\tau_{\\mathrm{y0}} + H \\alpha_{n+1}$. The sign is preserved from the trial state. This gives a numerically robust update:\n  $$\\tau_{n+1} = (\\tau_{\\mathrm{y0}} + H \\alpha_{n+1}) \\, \\text{sgn}(\\tau_{\\text{trial}})$$\n\n### **3. Summary of the Final Algorithm**\n\nFor each step from state $n$ to $n+1$:\n1.  **Inputs**: Material parameters $\\{E, \\tau_{\\mathrm{y0}}, H\\}$, and state $\\{h_{\\mathrm{p},n}, \\alpha_n, h_{n+1}\\}$.\n2.  **Elastic Predictor**: Calculate trial Kirchhoff stress:\n    $$\\tau_{\\text{trial}} = E (h_{n+1} - h_{\\mathrm{p},n})$$\n3.  **Yield Check**: Calculate trial yield function value:\n    $$\\phi_{\\text{trial}} = |\\tau_{\\text{trial}}| - (\\tau_{\\mathrm{y0}} + H \\alpha_n)$$\n4.  **Case Analysis**:\n    a.  **If $\\phi_{\\text{trial}} \\le 0$ (Elastic Step)**:\n        - $\\tau_{n+1} = \\tau_{\\text{trial}}$\n        - $h_{\\mathrm{p},n+1} = h_{\\mathrm{p},n}$\n        - $\\alpha_{n+1} = \\alpha_n$\n    b.  **If $\\phi_{\\text{trial}} > 0$ (Plastic Step)**:\n        - Compute plastic multiplier: $\\Delta \\gamma = \\phi_{\\text{trial}} / (E + H)$\n        - Update accumulated plastic strain: $\\alpha_{n+1} = \\alpha_n + \\Delta \\gamma$\n        - Update plastic log-strain: $h_{\\mathrm{p},n+1} = h_{\\mathrm{p},n} + \\Delta \\gamma \\, \\text{sgn}(\\tau_{\\text{trial}})$\n        - Update Kirchhoff stress: $\\tau_{n+1} = (\\tau_{\\mathrm{y0}} + H \\alpha_{n+1}) \\, \\text{sgn}(\\tau_{\\text{trial}})$\n5.  **Final Stress Calculation**: Compute the Cauchy (true) stress:\n    $$\\sigma_{n+1} = \\frac{\\tau_{n+1}}{\\exp(h_{n+1})}$$\n6.  **Outputs**: Return the set of updated values $\\{\\sigma_{n+1}, h_{\\mathrm{p},n+1}, \\alpha_{n+1}\\}$.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves a series of uniaxial finite strain elastoplasticity problems\n    using a return-mapping algorithm in logarithmic strain space.\n    \"\"\"\n    # Test suite: (E, tau_y0, H, h_np1, h_p_n, alpha_n)\n    # E, tau_y0, H are in MPa. Strains are dimensionless.\n    test_cases = [\n        (200000.0, 300.0, 1000.0, 0.0005, 0.0, 0.0),      # Case A\n        (210000.0, 250.0, 0.0, 0.003, 0.0, 0.0),          # Case B\n        (70000.0, 100.0, 1000.0, 0.01, 0.0, 0.0),         # Case C\n        (100000.0, 200.0, 500.0, -0.005, 0.0, 0.0),       # Case D\n        (150000.0, 300.0, 200.0, 0.002, 0.0, 0.0),        # Case E\n        (210000.0, 250.0, 5000.0, 0.003, 0.01, 0.01),     # Case F\n    ]\n\n    all_results = []\n    for case in test_cases:\n        E, tau_y0, H, h_np1, h_p_n, alpha_n = case\n\n        # 1. Elastic Predictor\n        tau_trial = E * (h_np1 - h_p_n)\n\n        # 2. Yield Check\n        # Current yield stress at the start of the step\n        tau_y_n = tau_y0 + H * alpha_n\n        phi_trial = np.abs(tau_trial) - tau_y_n\n\n        # 3. Case Analysis: Elastic or Plastic\n        if phi_trial <= 0:\n            # Elastic step\n            tau_np1 = tau_trial\n            h_p_np1 = h_p_n\n            alpha_np1 = alpha_n\n        else:\n            # Plastic step: perform return mapping\n            # Calculate plastic multiplier\n            delta_gamma = phi_trial / (E + H)\n            \n            # Update state variables\n            alpha_np1 = alpha_n + delta_gamma\n            \n            # Handle the sign of trial stress for flow direction\n            # np.sign returns 0 for 0, but phi_trial > 0 implies tau_trial != 0\n            sign_tau_trial = np.sign(tau_trial)\n            h_p_np1 = h_p_n + delta_gamma * sign_tau_trial\n            \n            # Update Kirchhoff stress using the consistency condition (more robust)\n            tau_np1 = (tau_y0 + H * alpha_np1) * sign_tau_trial\n\n        # 4. Final Cauchy Stress Calculation\n        # Total stretch at the end of the step\n        lambda_np1 = np.exp(h_np1)\n        # Cauchy stress\n        sigma_np1 = tau_np1 / lambda_np1\n\n        # 5. Format results\n        # Round final values to 6 decimal places as required\n        result = [\n            round(sigma_np1, 6),\n            round(h_p_np1, 6),\n            round(alpha_np1, 6),\n        ]\n        all_results.append(result)\n\n    # Final print statement must be a single line in the exact specified format.\n    # The replace(\" \", \"\") ensures no spaces are present in the final output.\n    output_str = str(all_results).replace(\" \", \"\")\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "While one-dimensional problems provide insight, the true complexity of finite strain kinematics emerges in three-dimensional, non-proportional loading scenarios where the principal axes of deformation rotate. This advanced practice demonstrates why simplified assumptions, such as the coaxiality of stress and strain, can fail dramatically. By comparing a kinematically correct spectral update with an erroneous simplified approach, this exercise highlights why robustly tracking the evolution of principal material directions is essential for accuracy in general-purpose simulations .",
            "id": "3579110",
            "problem": "Consider a three-dimensional homogeneous deforming body described by the spatial velocity gradient $\\mathbf{L}(t)$, which is additively decomposed into the symmetric rate-of-deformation tensor $\\mathbf{D}(t)$ and the skew-symmetric spin tensor $\\mathbf{W}(t)$ as $\\mathbf{L}(t) = \\mathbf{D}(t) + \\mathbf{W}(t)$. The deformation gradient $\\mathbf{F}(t)$ evolves according to the fundamental kinematic law $\\dot{\\mathbf{F}}(t) = \\mathbf{L}(t) \\mathbf{F}(t)$ with the initial condition $\\mathbf{F}(0) = \\mathbf{I}$, where $\\mathbf{I}$ is the identity tensor. The Cauchy-Green deformation tensor $\\mathbf{B}(t)$ is defined by $\\mathbf{B}(t) = \\mathbf{F}(t) \\mathbf{F}(t)^{\\mathrm{T}}$, which is Symmetric Positive Definite (SPD). The left stretch tensor $\\mathbf{V}(t)$ is obtained through the polar decomposition of $\\mathbf{F}(t)$, satisfying $\\mathbf{V}(t)^2 = \\mathbf{B}(t)$. The Eulerian Hencky (logarithmic) strain is defined as $\\mathbf{E}^{\\log}(t) = \\log(\\mathbf{V}(t))$, where $\\log(\\cdot)$ denotes the principal matrix logarithm. \n\nTo compute stress, assume an isotropic Hencky elastic constitutive law in logarithmic strain space for the Kirchhoff stress $\\mathbf{\\tau}(t)$, with Young’s modulus $E$ and Poisson’s ratio $\\nu$. The bulk modulus $K$ and shear modulus $G$ are $K = \\dfrac{E}{3(1 - 2 \\nu)}$ and $G = \\dfrac{E}{2(1 + \\nu)}$, and the stress is\n$$\n\\mathbf{\\tau}(t) = K \\,\\mathrm{tr}\\big(\\mathbf{E}^{\\log}(t)\\big)\\, \\mathbf{I} + 2 G \\left(\\mathbf{E}^{\\log}(t) - \\frac{1}{3} \\mathrm{tr}\\big(\\mathbf{E}^{\\log}(t)\\big) \\mathbf{I} \\right).\n$$\n\nYou must construct a loading path with rotating principal axes where $\\mathbf{D}(t)$ and $\\mathbf{W}(t)$ are non-commutative, and then compare two algorithms for stress evaluation:\n- Algorithm A (coaxial assumption): Assume $\\mathbf{E}^{\\log}(t)$ and $\\mathbf{\\tau}(t)$ remain coaxial with a fixed spatial basis, so the principal axes do not evolve. Update only the principal values of $\\mathbf{E}^{\\log}(t)$ by integrating the diagonal entries of $\\mathbf{D}(t)$ in the fixed basis, i.e., $\\mathbf{E}^{\\log}(t+\\Delta t) \\approx \\mathbf{E}^{\\log}(t) + \\mathrm{diag}(\\mathbf{D}(t)) \\Delta t$, keeping the eigenvectors fixed.\n- Algorithm B (full spectral orientation update): Integrate $\\mathbf{F}(t)$ from $\\dot{\\mathbf{F}} = \\mathbf{L} \\mathbf{F}$, compute $\\mathbf{B}(t)$, then obtain $\\mathbf{V}(t)$ from the spectral decomposition of $\\mathbf{B}(t)$, and finally compute $\\mathbf{E}^{\\log}(t) = \\log(\\mathbf{V}(t))$ by spectral mapping. Use this $\\mathbf{E}^{\\log}(t)$ to compute $\\mathbf{\\tau}(t)$.\n\nDefine the rotating principal axes loading path by\n$$\n\\mathbf{D}(t) = \\mathbf{R}_z(\\alpha t) \\, \\mathbf{D}_0 \\, \\mathbf{R}_z(\\alpha t)^{\\mathrm{T}}, \\quad \\mathbf{W}(t) = \\begin{bmatrix} 0 & -\\beta & 0 \\\\ \\beta & 0 & 0 \\\\ 0 & 0 & 0 \\end{bmatrix},\n$$\nwhere $\\mathbf{R}_z(\\theta)$ is the rotation tensor about the $z$-axis by angle $\\theta$ (in radians), and $\\mathbf{D}_0$ is a constant diagonal tensor. The parameters $\\alpha$ and $\\beta$ are constant rates (in $\\mathrm{rad/s}$ and $\\mathrm{s}^{-1}$, respectively). The deformation proceeds over total time $T$ with $N$ uniform time steps of size $\\Delta t = T/N$. The time evolution is numerically approximated by explicit integration of $\\dot{\\mathbf{F}} = \\mathbf{L} \\mathbf{F}$ with the update $\\mathbf{F}_{n+1} \\approx (\\mathbf{I} + \\mathbf{L}_n \\Delta t) \\mathbf{F}_n$.\n\nFor each test case, compute the final Kirchhoff stress $\\mathbf{\\tau}_{\\mathrm{coax}}$ from Algorithm A and $\\mathbf{\\tau}_{\\mathrm{spec}}$ from Algorithm B, and measure the dimensionless relative error defined by\n$$\n\\epsilon = \\frac{\\left\\| \\mathbf{\\tau}_{\\mathrm{coax}} - \\mathbf{\\tau}_{\\mathrm{spec}} \\right\\|_F}{\\left\\| \\mathbf{\\tau}_{\\mathrm{spec}} \\right\\|_F},\n$$\nwhere $\\|\\cdot\\|_F$ is the Frobenius norm. Express the final output as decimal numbers (dimensionless).\n\nUse the following material parameters for all cases: $E = 2.10 \\times 10^{11}$, $\\nu = 0.30$. Angles are in radians.\n\nTest Suite:\n- Case 1 (non-commutative, moderate rotation): $\\mathbf{D}_0 = \\mathrm{diag}(0.02, -0.02, 0.00)$ in $\\mathrm{s}^{-1}$, $\\alpha = 1.0$ in $\\mathrm{rad/s}$, $\\beta = 0.5$ in $\\mathrm{s}^{-1}$, $T = 0.5$ in $\\mathrm{s}$, $N = 2000$.\n- Case 2 (commuting boundary, isotropic stretch): $\\mathbf{D}_0 = \\mathrm{diag}(0.02, 0.02, 0.02)$ in $\\mathrm{s}^{-1}$, $\\alpha = 3.0$ in $\\mathrm{rad/s}$, $\\beta = 5.0$ in $\\mathrm{s}^{-1}$, $T = 0.3$ in $\\mathrm{s}$, $N = 1500$.\n- Case 3 (non-commutative, high rotation): $\\mathbf{D}_0 = \\mathrm{diag}(0.02, -0.02, 0.00)$ in $\\mathrm{s}^{-1}$, $\\alpha = 10.0$ in $\\mathrm{rad/s}$, $\\beta = 5.0$ in $\\mathrm{s}^{-1}$, $T = 0.2$ in $\\mathrm{s}$, $N = 4000$.\n- Case 4 (non-commutative, no spin): $\\mathbf{D}_0 = \\mathrm{diag}(0.02, -0.02, 0.00)$ in $\\mathrm{s}^{-1}$, $\\alpha = 1.0$ in $\\mathrm{rad/s}$, $\\beta = 0.0$ in $\\mathrm{s}^{-1}$, $T = 0.5$ in $\\mathrm{s}$, $N = 2000$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,r_3,r_4]$), where each $r_i$ is the relative error $\\epsilon$ for the corresponding test case, reported as decimal numbers.",
            "solution": "The problem requires a critical comparison of two numerical algorithms for computing stress in a body undergoing finite deformation. This is a central task in computational solid mechanics. The first algorithm (Algorithm A) employs a simplifying assumption of coaxiality with a fixed reference frame, while the second (Algorithm B) implements a full, kinematically correct update. The comparison is performed under a specific loading path involving rotating principal axes of deformation, which is designed to test the validity of the coaxiality assumption.\n\nThe analysis is grounded in the principles of continuum mechanics for finite deformations. The state of deformation is described by the deformation gradient tensor $\\mathbf{F}(t)$, which maps material vectors from the reference configuration to the spatial configuration. Its evolution is governed by the fundamental kinematic law:\n$$\n\\dot{\\mathbf{F}}(t) = \\mathbf{L}(t) \\mathbf{F}(t)\n$$\nwith the initial condition $\\mathbf{F}(0) = \\mathbf{I}$, where $\\mathbf{I}$ is the $3 \\times 3$ identity tensor. The spatial velocity gradient, $\\mathbf{L}(t)$, is additively decomposed into its symmetric part, the rate-of-deformation tensor $\\mathbf{D}(t)$, and its skew-symmetric part, the spin tensor $\\mathbf{W}(t)$:\n$$\n\\mathbf{L}(t) = \\mathbf{D}(t) + \\mathbf{W}(t)\n$$\nThe left Cauchy-Green deformation tensor, $\\mathbf{B}(t)$, is defined as $\\mathbf{B}(t) = \\mathbf{F}(t) \\mathbf{F}(t)^{\\mathrm{T}}$. Since $\\mathbf{F}(t)$ is invertible (for any physical deformation), $\\mathbf{B}(t)$ is a Symmetric Positive Definite (SPD) tensor. The polar decomposition theorem states that $\\mathbf{F}(t)$ can be uniquely decomposed into a rotation and a stretch. In the spatial description, this is $\\mathbf{F}(t) = \\mathbf{V}(t) \\mathbf{R}(t)$, where $\\mathbf{V}(t)$ is the left stretch tensor (also SPD) and $\\mathbf{R}(t)$ is a proper orthogonal rotation tensor. From the definition of $\\mathbf{B}(t)$, we have $\\mathbf{V}(t)^2 = \\mathbf{B}(t)$, meaning $\\mathbf{V}(t)$ is the unique SPD square root of $\\mathbf{B}(t)$.\n\nThe constitutive behavior is prescribed by an isotropic Hencky elastic model. This model posits a linear relationship in logarithmic strain space. The Eulerian Hencky (logarithmic) strain tensor, $\\mathbf{E}^{\\log}(t)$, is defined as the principal matrix logarithm of the left stretch tensor:\n$$\n\\mathbf{E}^{\\log}(t) = \\log(\\mathbf{V}(t))\n$$\nThe Kirchhoff stress, $\\mathbf{\\tau}(t)$, is then related to $\\mathbf{E}^{\\log}(t)$ via the isotropic linear elastic law:\n$$\n\\mathbf{\\tau}(t) = K \\,\\mathrm{tr}\\big(\\mathbf{E}^{\\log}(t)\\big)\\, \\mathbf{I} + 2 G \\left(\\mathbf{E}^{\\log}(t) - \\frac{1}{3} \\mathrm{tr}\\big(\\mathbf{E}^{\\log}(t)\\big) \\mathbf{I} \\right)\n$$\nwhere $\\mathrm{tr}(\\cdot)$ denotes the trace of a tensor. The material constants are the bulk modulus $K$ and the shear modulus $G$, which are defined in terms of Young’s modulus $E$ and Poisson’s ratio $\\nu$ as:\n$$\nK = \\frac{E}{3(1 - 2 \\nu)}, \\quad G = \\frac{E}{2(1 + \\nu)}\n$$\nThe problem defines a specific loading path characterized by a rotating rate-of-deformation tensor $\\mathbf{D}(t)$ and a constant spin tensor $\\mathbf{W}(t)$:\n$$\n\\mathbf{D}(t) = \\mathbf{R}_z(\\alpha t) \\, \\mathbf{D}_0 \\, \\mathbf{R}_z(\\alpha t)^{\\mathrm{T}}\n$$\n$$\n\\mathbf{W}(t) = \\begin{bmatrix} 0 & -\\beta & 0 \\\\ \\beta & 0 & 0 \\\\ 0 & 0 & 0 \\end{bmatrix}\n$$\nHere, $\\mathbf{D}_0$ is a constant diagonal tensor, $\\alpha$ is the rate of rotation of the principal axes of $\\mathbf{D}(t)$, $\\beta$ controls the magnitude of an additional rigid-body spin, and $\\mathbf{R}_z(\\theta)$ is the rotation matrix about the $z$-axis by an angle $\\theta$:\n$$\n\\mathbf{R}_z(\\theta) = \\begin{bmatrix} \\cos\\theta & -\\sin\\theta & 0 \\\\ \\sin\\theta & \\cos\\theta & 0 \\\\ 0 & 0 & 1 \\end{bmatrix}\n$$\nThe total deformation occurs over a time period $T_f$ using $N$ discrete time steps of size $\\Delta t = T_f/N$. The evolution of $\\mathbf{F}(t)$ is approximated using an explicit forward Euler a-scheme, $\\mathbf{F}_{n+1} = (\\mathbf{I} + \\mathbf{L}_n \\Delta t) \\mathbf{F}_n$, where the subscript $n$ denotes the value at time $t_n = n \\Delta t$.\n\nThe two algorithms are implemented as follows:\n\nAlgorithm B (Full Spectral Orientation Update): This algorithm serves as the reference solution. It correctly integrates the full kinematics.\n1.  Initialize $\\mathbf{F}_0 = \\mathbf{I}$.\n2.  For each time step $n$ from $0$ to $N-1$:\n    a. Calculate the current time $t_n = n \\Delta t$.\n    b. Construct $\\mathbf{D}(t_n)$ and $\\mathbf{W}(t_n)$ according to their definitions.\n    c. Form the velocity gradient $\\mathbf{L}_n = \\mathbf{D}(t_n) + \\mathbf{W}(t_n)$.\n    d. Update the deformation gradient: $\\mathbf{F}_{n+1} = (\\mathbf{I} + \\mathbf{L}_n \\Delta t) \\mathbf{F}_n$.\n3.  At the final time $T_f = N \\Delta t$, let the final deformation gradient be $\\mathbf{F}_{\\text{final}} = \\mathbf{F}_N$.\n4.  Compute the final left Cauchy-Green tensor: $\\mathbf{B}_{\\text{final}} = \\mathbf{F}_{\\text{final}} \\mathbf{F}_{\\text{final}}^{\\mathrm{T}}$.\n5.  Perform a spectral decomposition of the symmetric tensor $\\mathbf{B}_{\\text{final}}$: $\\mathbf{B}_{\\text{final}} = \\mathbf{P} \\mathbf{\\Lambda}_B \\mathbf{P}^{\\mathrm{T}}$, where $\\mathbf{\\Lambda}_B$ is the diagonal matrix of eigenvalues $\\lambda_i^B$ and $\\mathbf{P}$ is the orthogonal matrix of corresponding eigenvectors.\n6.  The eigenvalues of $\\mathbf{V}_{\\text{final}}$ are $\\lambda_i = \\sqrt{\\lambda_i^B}$, and its eigenvectors are the same as $\\mathbf{B}_{\\text{final}}$. The eigenvalues of the logarithmic strain $\\mathbf{E}^{\\log}_{\\mathrm{spec}}$ are $\\epsilon_i = \\log(\\lambda_i) = \\frac{1}{2} \\log(\\lambda_i^B)$.\n7.  Construct the final logarithmic strain tensor: $\\mathbf{E}^{\\log}_{\\mathrm{spec}} = \\mathbf{P} \\, \\mathrm{diag}(\\epsilon_1, \\epsilon_2, \\epsilon_3) \\, \\mathbf{P}^{\\mathrm{T}}$.\n8.  Calculate the final Kirchhoff stress $\\mathbf{\\tau}_{\\mathrm{spec}}$ using the constitutive law with $\\mathbf{E}^{\\log}_{\\mathrm{spec}}$.\n\nAlgorithm A (Coaxial Assumption): This is a simplified, and generally incorrect, algorithm. It assumes the principal axes of strain are fixed in the laboratory frame throughout the deformation.\n1.  Initialize the logarithmic strain tensor $\\mathbf{E}^{\\log}_{\\mathrm{coax}, 0} = \\mathbf{0}$, which is a $3 \\times 3$ zero matrix.\n2.  For each time step $n$ from $0$ to $N-1$:\n    a. Calculate the current time $t_n = n \\Delta t$.\n    b. Construct $\\mathbf{D}(t_n)$.\n    c. Update the diagonal logarithmic strain tensor by integrating only the diagonal components of $\\mathbf{D}(t_n)$:\n       $\\mathbf{E}^{\\log}_{\\mathrm{coax}, n+1} = \\mathbf{E}^{\\log}_{\\mathrm{coax}, n} + \\mathrm{diag}(D_{11}(t_n), D_{22}(t_n), D_{33}(t_n)) \\Delta t$.\n3.  At the final time $T_f$, the final strain is $\\mathbf{E}^{\\log}_{\\mathrm{coax}} = \\mathbf{E}^{\\log}_{\\mathrm{coax}, N}$.\n4.  Calculate the final Kirchhoff stress $\\mathbf{\\tau}_{\\mathrm{coax}}$ using the constitutive law with $\\mathbf{E}^{\\log}_{\\mathrm{coax}}$.\n\nThe error of the simplified approach is quantified by the relative difference in the Frobenius norm:\n$$\n\\epsilon = \\frac{\\left\\| \\mathbf{\\tau}_{\\mathrm{coax}} - \\mathbf{\\tau}_{\\mathrm{spec}} \\right\\|_F}{\\left\\| \\mathbf{\\tau}_{\\mathrm{spec}} \\right\\|_F}\n$$\nwhere the Frobenius norm of a matrix $\\mathbf{A}$ is $\\|\\mathbf{A}\\|_F = \\sqrt{\\sum_{i,j} A_{ij}^2}$.\n\nThis analysis is expected to show significant error for Algorithm A in cases where the loading is non-proportional (i.e., the principal axes of $\\mathbf{D}(t)$ rotate), as it incorrectly neglects the evolution of the principal strain directions. For the special case of isotropic stretching ($\\mathbf{D}_0 = d_0 \\mathbf{I}$), $\\mathbf{D}(t)$ becomes constant and isotropic ($\\mathbf{D}(t) = d_0 \\mathbf{I}$), which leads to a deformation where the principal strain axes do not rotate relative to the material. In this specific scenario (Case 2), both algorithms should yield the same result, and the error $\\epsilon$ is expected to be zero (or close to machine precision).",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the computational solid mechanics problem for the given test suite.\n    \"\"\"\n\n    # --- Material Parameters ---\n    E = 2.10e11  # Young's modulus\n    nu = 0.30    # Poisson's ratio\n\n    # --- Test Suite ---\n    test_cases = [\n        # Case 1: non-commutative, moderate rotation\n        {'D0_diag': [0.02, -0.02, 0.00], 'alpha': 1.0, 'beta': 0.5, 'T': 0.5, 'N': 2000},\n        # Case 2: commuting boundary, isotropic stretch\n        {'D0_diag': [0.02, 0.02, 0.02], 'alpha': 3.0, 'beta': 5.0, 'T': 0.3, 'N': 1500},\n        # Case 3: non-commutative, high rotation\n        {'D0_diag': [0.02, -0.02, 0.00], 'alpha': 10.0, 'beta': 5.0, 'T': 0.2, 'N': 4000},\n        # Case 4: non-commutative, no spin\n        {'D0_diag': [0.02, -0.02, 0.00], 'alpha': 1.0, 'beta': 0.0, 'T': 0.5, 'N': 2000},\n    ]\n\n    results = []\n\n    # --- Helper Functions ---\n    def get_rotation_matrix_z(theta):\n        \"\"\"Returns the rotation matrix around the z-axis by angle theta.\"\"\"\n        cos_t = np.cos(theta)\n        sin_t = np.sin(theta)\n        return np.array([\n            [cos_t, -sin_t, 0.0],\n            [sin_t,  cos_t, 0.0],\n            [0.0,    0.0,   1.0]\n        ])\n\n    def calculate_stress(E_log, K, G):\n        \"\"\"Calculates Kirchhoff stress from logarithmic strain.\"\"\"\n        I = np.eye(3)\n        tr_E_log = np.trace(E_log)\n        tau = K * tr_E_log * I + 2 * G * (E_log - (1/3) * tr_E_log * I)\n        return tau\n\n    # --- Main Loop ---\n    for case in test_cases:\n        # Unpack parameters\n        D0 = np.diag(case['D0_diag'])\n        alpha = case['alpha']\n        beta = case['beta']\n        T = case['T']\n        N = case['N']\n        \n        # Derived parameters\n        dt = T / N\n        K = E / (3 * (1 - 2 * nu))\n        G = E / (2 * (1 + nu))\n\n        # Initial conditions\n        F = np.eye(3) # For Algorithm B\n        E_log_coax = np.zeros((3, 3)) # For Algorithm A\n        W = np.array([\n            [0.0, -beta, 0.0],\n            [beta,  0.0, 0.0],\n            [0.0,  0.0, 0.0]\n        ])\n\n        # --- Time-stepping integration ---\n        for n in range(N):\n            t = n * dt\n            \n            # Common calculations\n            R_z = get_rotation_matrix_z(alpha * t)\n            D = R_z @ D0 @ R_z.T\n            \n            # --- Algorithm A update (Coaxial Assumption) ---\n            E_log_coax += np.diag(np.diag(D)) * dt\n            \n            # --- Algorithm B update (Full Spectral) ---\n            L = D + W\n            # Forward Euler update for F\n            F = (np.eye(3) + L * dt) @ F\n\n        # --- Post-processing after loop ---\n        \n        # Calculate final stress for Algorithm A\n        tau_coax = calculate_stress(E_log_coax, K, G)\n\n        # Calculate final stress for Algorithm B\n        B = F @ F.T\n        # Spectral decomposition of B\n        # eigh is for symmetric/hermitian matrices\n        eigvals_B, eigvecs_B = np.linalg.eigh(B)\n        \n        # Ensure eigenvalues are positive before sqrt\n        eigvals_B[eigvals_B < 0] = 0\n        \n        eigvals_V = np.sqrt(eigvals_B)\n        \n        # To avoid log(0), handle zero eigenvalues carefully.\n        # Since stretches must be positive, log(stretch) should be well-defined.\n        # A zero eigenvalue in B would imply a singular deformation gradient F,\n        # which means the volume has collapsed to zero.\n        # We add a small epsilon to avoid numerical issues.\n        eigvals_E_log = np.log(eigvals_V + np.finfo(float).eps)\n\n        E_log_spec = eigvecs_B @ np.diag(eigvals_E_log) @ eigvecs_B.T\n        tau_spec = calculate_stress(E_log_spec, K, G)\n\n        # --- Error Calculation ---\n        norm_tau_spec = np.linalg.norm(tau_spec, 'fro')\n        norm_diff = np.linalg.norm(tau_coax - tau_spec, 'fro')\n        \n        if norm_tau_spec > np.finfo(float).eps:\n            error = norm_diff / norm_tau_spec\n        else:\n            # If the true stress is zero, the absolute error is more meaningful.\n            # For this problem, we can assume spec stress is non-zero\n            # except perhaps in trivial cases. Case 2 results in non-zero stress.\n            error = norm_diff\n\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}