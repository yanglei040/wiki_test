{
    "hands_on_practices": [
        {
            "introduction": "理论学习的最佳补充是解决一个可以推导出解析解的典型问题。本练习将返回映射算法应用于一个简化的情形——$J_2$塑性下的纯剪切问题。通过这个练习，你将亲手推导出一个闭式解，从而在不涉及复杂数值求解器的情况下，直观地理解“弹性预测-塑性修正”这一核心思想的运作机制。这个过程对于建立返回映射算法的基本物理图像至关重要。",
            "id": "3596324",
            "problem": "考虑一个各向同性弹塑性固体在均匀、小应变下的简单剪切，该固体遵循基于偏应力第二不变量（J$_2$）的屈服准则，并采用关联流动法则和线性各向同性硬化。其弹性响应是线性的，剪切模量为 $G$，硬化特性由一个恒定的切线模量 $H$ 表征。初始屈服应力为 $\\sigma_{y0}$，在时间 $t_n$ 时的初始状态为无应力且无塑性变形。在一个时长为 $\\Delta t$ 的单一大时间步内，在 $1$-$2$ 平面内施加一个均匀的工程剪应变增量 $\\Delta \\gamma \\ge 0$（简单剪切），法向应变为零。\n\n仅从以下基本原理出发：\n- 小应变运动学，包括工程剪应变与张量剪应变之间的关系。\n- 剪切模量为 $G$ 的线性各向同性弹性。\n- J$_2$ 屈服函数 $f = q - \\sigma_{y}$ 的定义，其中 $q$ 是 von Mises 等效应力，$\\sigma_{y} = \\sigma_{y0} + H \\,\\varepsilon_{p}^{\\mathrm{eq}}$ 是当前屈服应力，$\\varepsilon_{p}^{\\mathrm{eq}}$ 为等效塑性应变。\n- 关联流动法则（法向法则），即流动方向垂直于屈服面，以及在时间步上使用后向欧拉（隐式）积分。\n- $q = \\sqrt{\\frac{3}{2}\\, \\boldsymbol{s}:\\boldsymbol{s}}$ 的定义以及满足 $d\\varepsilon_{p}^{\\mathrm{eq}} = \\sqrt{\\frac{2}{3}}\\, \\| d\\boldsymbol{\\varepsilon}_{p}^{\\mathrm{dev}} \\|$ 的 $\\varepsilon_{p}^{\\mathrm{eq}}$。\n\n推导该步结束后剪切应力分量 $\\sigma_{12,n+1}$ 的一个闭式更新表达式，该表达式用 $G$、$H$、$\\sigma_{y0}$ 和 $\\Delta \\gamma$ 表示。然后，通过直接求解后向欧拉返回映射方程（作为在大时间步 $\\Delta t$ 上的数值积分，即在一步内完成隐式更新而不分子步），验证可以得到相同的表达式。\n\n你的最终答案必须是关于 $\\sigma_{12,n+1}$ 的一个单一闭式解析表达式，用 $G$、$H$、$\\sigma_{y0}$ 和 $\\Delta \\gamma$ 表示。在你的最终方框答案中不要包含单位。如果你的表达式是分段的，你可以使用最小算子将其写成一个单一表达式。",
            "solution": "该问题陈述经评估有效。它提出了一个在计算固体力学领域中适定且具有科学依据的问题，具体涉及返回映射算法在 $J_2$ 塑性中的应用。给定条件是完整、一致且客观陈述的。\n\n任务是，从一个无应力且无塑性变形的状态开始，推导在一步简单剪切后剪切应力分量 $\\sigma_{12,n+1}$ 的闭式表达式。我们将采用标准的弹性预测/塑性修正算法，该算法代表了在本构方程上对时间步 $\\Delta t$ 进行后向欧拉积分的直接求解。\n\n首先，我们定义运动学。在 $1$-$2$ 平面内，一个简单的工程剪应变增量 $\\Delta \\gamma$（法向应变为零）对应的总应变增量张量 $\\Delta\\boldsymbol{\\varepsilon}$ 为：\n$$\n\\Delta\\boldsymbol{\\varepsilon} = \\begin{pmatrix} 0  \\frac{1}{2}\\Delta\\gamma  0 \\\\ \\frac{1}{2}\\Delta\\gamma  0  0 \\\\ 0  0  0 \\end{pmatrix}\n$$\n$\\Delta\\boldsymbol{\\varepsilon}$ 的迹为零，因此变形是等体积的。应变增量是纯偏量的，即 $\\Delta\\boldsymbol{\\varepsilon} = \\Delta\\boldsymbol{\\varepsilon}^{\\mathrm{dev}}$。\n\n求解过程遵循返回映射算法：\n\n1.  **弹性预测步：** 我们首先假设整个应变增量 $\\Delta\\boldsymbol{\\varepsilon}$ 都被弹性地承受。计算在时间 $t_{n+1}$ 的试探应力状态。由于初始状态是无应力的（$\\boldsymbol{\\sigma}_n = \\boldsymbol{0}$），我们有：\n    $$\n    \\boldsymbol{\\sigma}_{n+1}^{\\mathrm{trial}} = \\boldsymbol{C} : \\Delta\\boldsymbol{\\varepsilon}\n    $$\n    对于线性各向同性弹性和偏应变增量，应力增量由 $\\Delta\\boldsymbol{\\sigma} = 2G \\Delta\\boldsymbol{\\varepsilon}^{\\mathrm{dev}}$ 给出。因此，试探应力的唯一非零分量是：\n    $$\n    \\sigma_{12,n+1}^{\\mathrm{trial}} = 2G \\Delta\\varepsilon_{12} = 2G \\left(\\frac{1}{2}\\Delta\\gamma\\right) = G\\Delta\\gamma\n    $$\n    试探应力张量是纯偏量的，所以 $\\boldsymbol{s}_{n+1}^{\\mathrm{trial}} = \\boldsymbol{\\sigma}_{n+1}^{\\mathrm{trial}}$。\n\n2.  **屈服检查：** 我们检查这个试探应力状态是否违反了屈服条件。屈服函数为 $f = q - \\sigma_y$。在该步开始时，材料无塑性变形，因此屈服应力为初始屈服应力 $\\sigma_y = \\sigma_{y0}$。我们计算试探状态的 von Mises 等效应力 $q_{n+1}^{\\mathrm{trial}}$：\n    $$\n    q_{n+1}^{\\mathrm{trial}} = \\sqrt{\\frac{3}{2} \\boldsymbol{s}_{n+1}^{\\mathrm{trial}} : \\boldsymbol{s}_{n+1}^{\\mathrm{trial}}} = \\sqrt{\\frac{3}{2} \\left( (\\sigma_{12,n+1}^{\\mathrm{trial}})^2 + (\\sigma_{21,n+1}^{\\mathrm{trial}})^2 \\right)} = \\sqrt{\\frac{3}{2} \\left( (G\\Delta\\gamma)^2 + (G\\Delta\\gamma)^2 \\right)}\n    $$\n    $$\n    q_{n+1}^{\\mathrm{trial}} = \\sqrt{\\frac{3}{2} (2 G^2 \\Delta\\gamma^2)} = \\sqrt{3} G |\\Delta\\gamma|\n    $$\n    由于问题指定 $\\Delta\\gamma \\ge 0$，我们有 $q_{n+1}^{\\mathrm{trial}} = \\sqrt{3} G \\Delta\\gamma$。\n    试探屈服函数值为 $f^{\\mathrm{trial}} = q_{n+1}^{\\mathrm{trial}} - \\sigma_{y0}$。\n\n    - 如果 $f^{\\mathrm{trial}} \\le 0$，即 $\\sqrt{3} G \\Delta\\gamma \\le \\sigma_{y0}$，则试探状态是允许的。该步是纯弹性的。最终应力即为试探应力：\n      $$\n      \\sigma_{12,n+1} = \\sigma_{12,n+1}^{\\mathrm{trial}} = G\\Delta\\gamma \\quad \\text{如果 } \\Delta\\gamma \\le \\frac{\\sigma_{y0}}{G\\sqrt{3}}\n      $$\n\n    - 如果 $f^{\\mathrm{trial}}  0$，即 $\\sqrt{3} G \\Delta\\gamma  \\sigma_{y0}$，则试探状态位于屈服面之外。发生塑性流动，需要进行塑性修正。\n\n3.  **塑性修正步（返回映射）：** 对于塑性步，最终状态 $(\\boldsymbol{\\sigma}_{n+1}, \\varepsilon_{p,n+1}^{\\mathrm{eq}})$ 必须满足积分后的本构关系和屈服条件。我们将一致性参数（或称塑性乘子）定义为等效塑性应变增量本身，记为 $\\Delta\\gamma_p$。后向欧拉格式意味着：\n    - 加法分解：$\\Delta\\boldsymbol{\\varepsilon} = \\Delta\\boldsymbol{\\varepsilon}_e + \\Delta\\boldsymbol{\\varepsilon}_p$。\n    - 弹性定律：$\\boldsymbol{\\sigma}_{n+1} = \\boldsymbol{C}:\\Delta\\boldsymbol{\\varepsilon}_e$。\n    - 流动法则（关联）：塑性应变增量的方向与屈服面法向一致，其大小由 $\\Delta\\gamma_p$ 确定：$\\Delta\\boldsymbol{\\varepsilon}_p = \\Delta\\gamma_p \\frac{\\partial q}{\\partial \\boldsymbol{\\sigma}}\\Big|_{\\boldsymbol{\\sigma}_{n+1}} = \\Delta\\gamma_p \\frac{3}{2q_{n+1}} \\boldsymbol{s}_{n+1}$。根据问题定义，这个选择确保了 $\\Delta\\varepsilon_{p}^{\\mathrm{eq}} = \\sqrt{\\frac{2}{3} \\Delta\\boldsymbol{\\varepsilon}_p:\\Delta\\boldsymbol{\\varepsilon}_p} = \\Delta\\gamma_p$。\n    - 硬化定律：$\\sigma_{y, n+1} = \\sigma_{y0} + H \\varepsilon_{p,n+1}^{\\mathrm{eq}}$。已知 $\\varepsilon_{p,n}^{\\mathrm{eq}}=0$ 且 $\\Delta\\varepsilon_{p}^{\\mathrm{eq}} = \\Delta\\gamma_p$，我们有 $\\sigma_{y, n+1} = \\sigma_{y0} + H \\Delta\\gamma_p$。\n    - 一致性条件：$f_{n+1} = q_{n+1} - \\sigma_{y, n+1} = 0 \\implies q_{n+1} = \\sigma_{y0} + H \\Delta\\gamma_p$。\n\n    结合这些方程，我们推导出返回映射。最终应力与试探应力相关：\n    $$\n    \\boldsymbol{\\sigma}_{n+1} = \\boldsymbol{\\sigma}_{n+1}^{\\mathrm{trial}} - \\boldsymbol{C}:\\Delta\\boldsymbol{\\varepsilon}_p\n    $$\n    对于偏量部分：\n    $$\n    \\boldsymbol{s}_{n+1} = \\boldsymbol{s}_{n+1}^{\\mathrm{trial}} - 2G \\Delta\\boldsymbol{\\varepsilon}_p = \\boldsymbol{s}_{n+1}^{\\mathrm{trial}} - 2G \\left(\\Delta\\gamma_p \\frac{3}{2q_{n+1}} \\boldsymbol{s}_{n+1}\\right) = \\boldsymbol{s}_{n+1}^{\\mathrm{trial}} - \\frac{3G\\Delta\\gamma_p}{q_{n+1}} \\boldsymbol{s}_{n+1}\n    $$\n    重新整理得到 $\\boldsymbol{s}_{n+1} \\left(1 + \\frac{3G\\Delta\\gamma_p}{q_{n+1}}\\right) = \\boldsymbol{s}_{n+1}^{\\mathrm{trial}}$。这表明 $\\boldsymbol{s}_{n+1}$ 与 $\\boldsymbol{s}_{n+1}^{\\mathrm{trial}}$ 共轴，这就是径向返回的原理。我们可以对上式取范数并乘以 $\\sqrt{3/2}$ 得到 von Mises 等效应力的关系：\n    $$\n    q_{n+1} \\left(1 + \\frac{3G\\Delta\\gamma_p}{q_{n+1}}\\right) = q_{n+1}^{\\mathrm{trial}} \\implies q_{n+1} + 3G\\Delta\\gamma_p = q_{n+1}^{\\mathrm{trial}}\n    $$\n    我们现在得到一个关于 $\\Delta\\gamma_p$ 和 $q_{n+1}$ 的两个代数方程组：\n    1.  $q_{n+1} = q_{n+1}^{\\mathrm{trial}} - 3G\\Delta\\gamma_p$\n    2.  $q_{n+1} = \\sigma_{y0} + H\\Delta\\gamma_p$\n    令两个关于 $q_{n+1}$ 的表达式相等：\n    $$\n    q_{n+1}^{\\mathrm{trial}} - 3G\\Delta\\gamma_p = \\sigma_{y0} + H\\Delta\\gamma_p \\implies q_{n+1}^{\\mathrm{trial}} - \\sigma_{y0} = (3G+H)\\Delta\\gamma_p\n    $$\n    求解塑性乘子 $\\Delta\\gamma_p$：\n    $$\n    \\Delta\\gamma_p = \\frac{q_{n+1}^{\\mathrm{trial}} - \\sigma_{y0}}{3G+H}\n    $$\n    因为我们处于塑性情况， $q_{n+1}^{\\mathrm{trial}} > \\sigma_{y0}$，所以 $\\Delta\\gamma_p > 0$。\n    现在我们求最终应力。最终偏应力是试探偏应力的径向缩放：\n    $$\n    \\boldsymbol{s}_{n+1} = \\frac{q_{n+1}}{q_{n+1}^{\\mathrm{trial}}} \\boldsymbol{s}_{n+1}^{\\mathrm{trial}}\n    $$\n    将 $\\Delta\\gamma_p$ 代入一致性条件以求得 $q_{n+1}$：\n    $$\n    q_{n+1} = \\sigma_{y0} + H \\left(\\frac{q_{n+1}^{\\mathrm{trial}} - \\sigma_{y0}}{3G+H}\\right) = \\frac{\\sigma_{y0}(3G+H) + H(q_{n+1}^{\\mathrm{trial}} - \\sigma_{y0})}{3G+H} = \\frac{3G\\sigma_{y0} + H q_{n+1}^{\\mathrm{trial}}}{3G+H}\n    $$\n    因此，最终的偏应力张量为：\n    $$\n    \\boldsymbol{s}_{n+1} = \\left(\\frac{3G\\sigma_{y0} + H q_{n+1}^{\\mathrm{trial}}}{(3G+H)q_{n+1}^{\\mathrm{trial}}}\\right) \\boldsymbol{s}_{n+1}^{\\mathrm{trial}}\n    $$\n    我们需要分量 $\\sigma_{12,n+1}$。由于变形是等体积的，$\\sigma_{12,n+1} = s_{12,n+1}$。\n    $$\n    \\sigma_{12,n+1} = \\left(\\frac{3G\\sigma_{y0} + H q_{n+1}^{\\mathrm{trial}}}{(3G+H)q_{n+1}^{\\mathrm{trial}}}\\right) \\sigma_{12,n+1}^{\\mathrm{trial}}\n    $$\n    代入 $\\sigma_{12,n+1}^{\\mathrm{trial}} = G\\Delta\\gamma$ 和 $q_{n+1}^{\\mathrm{trial}} = \\sqrt{3}G\\Delta\\gamma$：\n    $$\n    \\sigma_{12,n+1} = \\left(\\frac{3G\\sigma_{y0} + H (\\sqrt{3}G\\Delta\\gamma)}{(3G+H)(\\sqrt{3}G\\Delta\\gamma)}\\right) (G\\Delta\\gamma) = \\frac{3G\\sigma_{y0} + \\sqrt{3}GH\\Delta\\gamma}{\\sqrt{3}(3G+H)}\n    $$\n    $$\n    \\sigma_{12,n+1} = \\frac{\\sqrt{3}G\\sigma_{y0}}{3G+H} + \\frac{GH\\Delta\\gamma}{3G+H} \\quad \\text{如果 } \\Delta\\gamma > \\frac{\\sigma_{y0}}{G\\sqrt{3}}\n    $$\n\n4.  **组合表达式：** 我们可以将弹性和弹塑性解合并为一个单一表达式。设弹性解为 $f(\\Delta\\gamma) = G\\Delta\\gamma$，塑性解为 $g(\\Delta\\gamma) = \\frac{GH\\Delta\\gamma + \\sqrt{3}G\\sigma_{y0}}{3G+H}$。\n    我们分析差值 $f(\\Delta\\gamma) - g(\\Delta\\gamma)$：\n    $$\n    G\\Delta\\gamma - \\frac{GH\\Delta\\gamma + \\sqrt{3}G\\sigma_{y0}}{3G+H} = \\frac{G\\Delta\\gamma(3G+H) - (GH\\Delta\\gamma + \\sqrt{3}G\\sigma_{y0})}{3G+H} = \\frac{3G^2\\Delta\\gamma - \\sqrt{3}G\\sigma_{y0}}{3G+H} = \\frac{\\sqrt{3}G}{3G+H}(\\sqrt{3}G\\Delta\\gamma - \\sigma_{y0})\n    $$\n    - 如果 $\\Delta\\gamma \\le \\frac{\\sigma_{y0}}{G\\sqrt{3}}$，则 $f(\\Delta\\gamma) \\le g(\\Delta\\gamma)$，正确的解是弹性解 $f(\\Delta\\gamma)$。\n    - 如果 $\\Delta\\gamma > \\frac{\\sigma_{y0}}{G\\sqrt{3}}$，则 $f(\\Delta\\gamma) > g(\\Delta\\gamma)$，正确的解是塑性解 $g(\\Delta\\gamma)$。\n    这个逻辑恰好对应于最小算子。最终应力是这两个值中较小的一个：\n    $$\n    \\sigma_{12,n+1} = \\min\\left( G\\Delta\\gamma, \\frac{GH\\Delta\\gamma + \\sqrt{3}G\\sigma_{y0}}{3G+H} \\right)\n    $$\n    这个单一表达式概括了该一维问题的弹性预测和塑性修正（径向返回），正确地实现了从弹性到塑性区域的过渡。为了简洁，可以对该表达式稍作整理：\n    $$\n    \\sigma_{12,n+1} = \\min\\left( G\\Delta\\gamma, \\frac{G(H\\Delta\\gamma + \\sqrt{3}\\sigma_{y0})}{3G+H} \\right)\n    $$\n\n此推导证实，通过直接求解单一大时间步的后向欧拉返回映射方程，可以得到所提供的闭式解。",
            "answer": "$$\n\\boxed{\\min\\left( G\\Delta\\gamma, \\frac{G(H\\Delta\\gamma + \\sqrt{3}\\sigma_{y0})}{3G+H} \\right)}\n$$"
        },
        {
            "introduction": "在实际工程应用中，多数塑性本构模型，特别是包含非线性硬化规律的模型，其控制方程无法求得解析解。本练习将引导你掌握处理这类问题的标准方法：使用数值方法求解非线性的塑性一致性方程。你将实现一个带有线搜索和区间限定的牛顿迭代法，这不仅是现代计算塑性程序的核心技术，也是确保算法鲁棒性和收敛性的关键。",
            "id": "3596258",
            "problem": "考虑一个具有相关联流动法则和基于偏应力张量第二不变量（J2）的屈服函数的小应变、线性各向同性弹塑性材料。使用以下计算固体力学中的基本且经过充分检验的基础定义和事实：\n\n- Cauchy 应力张量分解为体积部分和偏量部分，表达式为 $\\boldsymbol{\\sigma} = \\kappa \\, \\mathrm{tr}(\\boldsymbol{\\varepsilon}) \\boldsymbol{I} + 2 \\mu \\, \\boldsymbol{e}^{\\mathrm{dev}}$，其中 $\\kappa$ 是体积模量，$\\mu$ 是剪切模量，$\\boldsymbol{\\varepsilon}$ 是应变张量，$\\boldsymbol{e}^{\\mathrm{dev}}$ 是弹性偏应变张量。偏应力张量为 $\\boldsymbol{s} = 2 \\mu \\, \\boldsymbol{e}^{\\mathrm{dev}}$。\n- 相关联塑性流动法则为 $\\mathrm{d}\\boldsymbol{\\varepsilon}^{\\mathrm{p}} = \\mathrm{d}\\lambda \\, \\dfrac{\\partial f}{\\partial \\boldsymbol{\\sigma}}$，其中 $f$ 是屈服函数，$\\mathrm{d}\\lambda \\ge 0$ 是塑性乘子增量。\n- 对于 J2 塑性理论，一种常见的以偏应力大小表示的屈服函数形式为 $f(\\boldsymbol{\\sigma}, \\alpha) = \\|\\boldsymbol{s}\\| - \\sqrt{\\dfrac{2}{3}} \\, \\sigma_{\\mathrm{y}}(\\alpha)$，其中 $\\alpha$ 是等效塑性应变，$\\sigma_{\\mathrm{y}}(\\alpha)$ 是当前屈服应力。\n- 等效塑性应变增量为 $\\mathrm{d}\\bar{\\varepsilon}^{\\mathrm{p}} = \\sqrt{\\dfrac{2}{3}} \\, \\|\\mathrm{d}\\boldsymbol{\\varepsilon}^{\\mathrm{p}}\\|$，这意味着 $\\mathrm{d}\\alpha = \\mathrm{d}\\bar{\\varepsilon}^{\\mathrm{p}}$。\n- 在标准返回映射算法（对于 J2 理论是径向返回）下，更新后的偏应力与试探偏应力保持共线，其大小因塑性流动而减小。\n- 本问题中的所有量均为无量纲。不需要物理单位。\n\n从这些基础出发，考虑一个指数类型的各向同性硬化定律，由 $\\sigma_{\\mathrm{y}}(\\alpha) = \\sigma_{\\mathrm{y}0} + H \\left(1 - e^{-b \\alpha}\\right)$ 给出，其中 $\\sigma_{\\mathrm{y}0}  0$ 是初始屈服应力，$H \\ge 0$ 是硬化模量，$b  0$ 控制饱和速率。令 $\\alpha_n$ 表示前一时间步的等效塑性应变，令 $\\|\\boldsymbol{s}_{\\mathrm{tr}}\\|$ 表示假设为纯弹性响应时当前步的试探偏应力大小。返回映射旨在寻求塑性乘子增量 $\\Delta\\lambda \\ge 0$，使得更新后的状态恰好位于屈服面上。\n\n您的任务是：\n\n1. 从上述基本原理出发，不使用任何快捷公式，推导塑性乘子增量 $\\Delta\\lambda$ 的标量一致性方程，其形式为 $g(\\Delta\\lambda) = 0$，其中 $g(\\Delta\\lambda)$ 由 $\\mu$、$\\|\\boldsymbol{s}_{\\mathrm{tr}}\\|$、$\\sigma_{\\mathrm{y}0}$、$H$、$b$ 和 $\\alpha_n$ 显式定义。\n\n2. 构造一个配备线搜索的、带安全措施的牛顿迭代法，用于求解一维变量 $\\Delta\\lambda \\ge 0$ 的方程 $g(\\Delta\\lambda) = 0$。您的带安全措施的牛顿法必须：\n   - 从一个有效区间 $[\\lambda_{\\mathrm{L}}, \\lambda_{\\mathrm{U}}]$ 开始，其中 $\\lambda_{\\mathrm{L}} = 0$。当发生塑性加载时，更新 $\\lambda_{\\mathrm{U}}$ 以确保 $g(\\lambda_{\\mathrm{L}}) \\ge 0$ 和 $g(\\lambda_{\\mathrm{U}}) \\le 0$。\n   - 使用牛顿步 $\\Delta\\lambda_{\\mathrm{trial}} = \\Delta\\lambda - \\dfrac{g(\\Delta\\lambda)}{g'(\\Delta\\lambda)}$ 作为候选值。\n   - 如果 $\\Delta\\lambda_{\\mathrm{trial}}$ 超出该区间，则用二分步 $\\dfrac{\\lambda_{\\mathrm{L}} + \\lambda_{\\mathrm{U}}}{2}$ 替换它。\n   - 对价值函数 $\\phi(\\Delta\\lambda) = \\dfrac{1}{2} \\, g(\\Delta\\lambda)^2$ 应用带有 Armijo（充分下降）条件的回溯线搜索，以接受或减小沿牛顿方向的步长。\n\n3. 陈述精确的数学条件，用数据以及 $g(\\Delta\\lambda)$ 和 $g'(\\Delta\\lambda)$ 的性质来表示，在这些条件下，所提出的带线搜索的安全牛顿法能够保证全局收敛到唯一根。您的条件必须纯粹用数学术语陈述，引用诸如连续性、单调性和导数的有界性等性质，并且必须足以保证解的唯一性和收敛性。\n\n4. 将您的算法实现为一个完整、可运行的程序，该程序针对给定的测试套件计算每种情况下的 $\\Delta\\lambda$ 并输出结果。\n\n使用以下测试套件，每种情况都是一个元组 $(\\mu,\\|\\boldsymbol{s}_{\\mathrm{tr}}\\|,\\sigma_{\\mathrm{y}0},H,b,\\alpha_n)$：\n- 情况 1 (一般塑性): $(80000.0, 600.0, 250.0, 1000.0, 10.0, 0.05)$。\n- 情况 2 (弹性边界): $(80000.0, 500.0, 250.0, 1000.0, 10.0, 0.05)$。\n- 情况 3 (理想塑性，无硬化): $(80000.0, 600.0, 250.0, 0.0, 10.0, 0.05)$。\n- 情况 4 (快速饱和硬化): $(30000.0, 1200.0, 200.0, 1500.0, 200.0, 0.0)$。\n\n对于每种情况，您的程序必须计算塑性乘子增量 $\\Delta\\lambda$（作为一个浮点数），并将结果汇总到单行输出中。您的程序应生成一行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，$[\\text{结果1},\\text{结果2},\\text{结果3},\\text{结果4}]$）。不允许有其他输出。",
            "solution": "我们从一个小应变、线性各向同性弹性和相关联塑性流动法则开始。应力分解为 $\\boldsymbol{\\sigma} = \\kappa \\, \\mathrm{tr}(\\boldsymbol{\\varepsilon}) \\boldsymbol{I} + 2 \\mu \\, \\boldsymbol{e}^{\\mathrm{dev}}$，其中偏应力为 $\\boldsymbol{s} = 2 \\mu \\, \\boldsymbol{e}^{\\mathrm{dev}}$。以偏应力大小表示的 J2 屈服函数为 $f(\\boldsymbol{\\sigma}, \\alpha) = \\|\\boldsymbol{s}\\| - \\sqrt{\\dfrac{2}{3}} \\, \\sigma_{\\mathrm{y}}(\\alpha)$，其中 $\\alpha$ 是等效塑性应变，$\\sigma_{\\mathrm{y}}(\\alpha)$ 是当前屈服应力。相关联流动法则给出 $\\mathrm{d}\\boldsymbol{\\varepsilon}^{\\mathrm{p}} = \\mathrm{d}\\lambda \\, \\dfrac{\\partial f}{\\partial \\boldsymbol{\\sigma}}$。对于 J2 屈服函数 $f(\\boldsymbol{\\sigma}, \\alpha) = \\|\\boldsymbol{s}\\| - \\sqrt{\\dfrac{2}{3}} \\, \\sigma_{\\mathrm{y}}(\\alpha)$，其对应力的梯度为 $\\dfrac{\\partial f}{\\partial \\boldsymbol{\\sigma}} = \\dfrac{\\partial f}{\\partial \\boldsymbol{s}} = \\dfrac{\\boldsymbol{s}}{\\|\\boldsymbol{s}\\|}$，这是一个与 $\\boldsymbol{s}$同向的偏量单位向量。\n\n在标准径向返回映射假设下，更新后的偏应力 $\\boldsymbol{s}_{n+1}$ 与试探偏应力 $\\boldsymbol{s}_{\\mathrm{tr}}$ 共线，其大小通过弹性关系因偏塑性应变增量而减小：$\\boldsymbol{s}_{n+1} = \\boldsymbol{s}_{\\mathrm{tr}} - 2 \\mu \\, \\Delta\\boldsymbol{\\varepsilon}^{\\mathrm{p}}$，其中 $\\Delta\\boldsymbol{\\varepsilon}^{\\mathrm{p}} = \\Delta\\lambda \\, \\dfrac{\\boldsymbol{s}_{n+1}}{\\|\\boldsymbol{s}_{n+1}\\|}$。由于 $\\dfrac{\\boldsymbol{s}_{n+1}}{\\|\\boldsymbol{s}_{n+1}\\|}$ 与 $\\boldsymbol{s}_{\\mathrm{tr}}$ 同向，其大小遵循\n$$\n\\|\\boldsymbol{s}_{n+1}\\| = \\|\\boldsymbol{s}_{\\mathrm{tr}}\\| - 2 \\mu \\, \\Delta\\lambda.\n$$\n增量步结束时的屈服函数一致性条件要求 $f(\\boldsymbol{\\sigma}_{n+1}, \\alpha_{n+1}) = 0$，即\n$$\n\\|\\boldsymbol{s}_{n+1}\\| - \\sqrt{\\dfrac{2}{3}} \\, \\sigma_{\\mathrm{y}}(\\alpha_{n+1}) = 0.\n$$\n等效塑性应变演化为 $\\mathrm{d}\\bar{\\varepsilon}^{\\mathrm{p}} = \\sqrt{\\dfrac{2}{3}} \\|\\mathrm{d}\\boldsymbol{\\varepsilon}^{\\mathrm{p}}\\|$，使用 $\\mathrm{d}\\boldsymbol{\\varepsilon}^{\\mathrm{p}} = \\mathrm{d}\\lambda \\dfrac{\\boldsymbol{s}}{\\|\\boldsymbol{s}\\|}$，可得出 $\\mathrm{d}\\bar{\\varepsilon}^{\\mathrm{p}} = \\sqrt{\\dfrac{2}{3}} \\, \\mathrm{d}\\lambda$。因此，等效塑性应变增量为 $\\Delta\\alpha = \\sqrt{\\dfrac{2}{3}} \\, \\Delta\\lambda$，更新后的 $\\alpha$ 为 $\\alpha_{n+1} = \\alpha_n + \\sqrt{\\dfrac{2}{3}} \\, \\Delta\\lambda$。\n\n对于指数型各向同性硬化定律 $\\sigma_{\\mathrm{y}}(\\alpha) = \\sigma_{\\mathrm{y}0} + H \\left(1 - e^{-b \\alpha}\\right)$，一致性条件变为\n$$\n\\|\\boldsymbol{s}_{\\mathrm{tr}}\\| - 2 \\mu \\, \\Delta\\lambda - \\sqrt{\\dfrac{2}{3}} \\left[ \\sigma_{\\mathrm{y}0} + H \\left( 1 - e^{-b (\\alpha_n + \\sqrt{\\dfrac{2}{3}} \\, \\Delta\\lambda)} \\right) \\right] = 0.\n$$\n定义标量函数\n$$\ng(\\Delta\\lambda) = \\|\\boldsymbol{s}_{\\mathrm{tr}}\\| - 2 \\mu \\, \\Delta\\lambda - \\sqrt{\\dfrac{2}{3}} \\left[ \\sigma_{\\mathrm{y}0} + H \\left( 1 - e^{-b (\\alpha_n + \\sqrt{\\dfrac{2}{3}} \\, \\Delta\\lambda)} \\right) \\right].\n$$\n发生塑性加载的充要条件是 $g(0) > 0$，在这种情况下，必须找到唯一的根 $\\Delta\\lambda > 0$。\n\n我们计算 $g(\\Delta\\lambda)$ 的导数：\n$$\ng'(\\Delta\\lambda) = - 2 \\mu - \\sqrt{\\dfrac{2}{3}} \\left[ H \\cdot \\dfrac{\\mathrm{d}}{\\mathrm{d}\\Delta\\lambda} \\left( 1 - e^{-b (\\alpha_n + \\sqrt{\\dfrac{2}{3}} \\, \\Delta\\lambda)} \\right) \\right].\n$$\n由于 $\\dfrac{\\mathrm{d}}{\\mathrm{d}\\Delta\\lambda} \\left( 1 - e^{-b (\\alpha_n + \\sqrt{\\dfrac{2}{3}} \\, \\Delta\\lambda)} \\right) = b \\sqrt{\\dfrac{2}{3}} \\, e^{-b (\\alpha_n + \\sqrt{\\dfrac{2}{3}} \\, \\Delta\\lambda)}$，我们得到\n$$\ng'(\\Delta\\lambda) = - 2 \\mu - \\left( \\dfrac{2}{3} \\right) H b \\, e^{-b (\\alpha_n + \\sqrt{\\dfrac{2}{3}} \\, \\Delta\\lambda)}.\n$$\n因此，只要 $\\mu > 0$，$H \\ge 0$ 且 $b > 0$，对于所有 $\\Delta\\lambda \\ge 0$，都有 $g'(\\Delta\\lambda)  0$。实际上，\n$$\ng'(\\Delta\\lambda) \\le - 2 \\mu  0,\n$$\n所以 $g$ 是严格递减且连续可微的。此外，$\\lim_{\\Delta\\lambda \\to +\\infty} g(\\Delta\\lambda) = -\\infty$，因此至多存在一个根。如果 $g(0) > 0$，根据介值定理，存在一个唯一的根 $\\Delta\\lambda^\\star > 0$。\n\n现在我们设计一个带线搜索的安全牛顿法。设价值函数为\n$$\n\\phi(\\Delta\\lambda) = \\dfrac{1}{2} \\, g(\\Delta\\lambda)^2.\n$$\n我们使用牛顿步\n$$\n\\Delta\\lambda_{\\mathrm{N}} = \\Delta\\lambda - \\dfrac{g(\\Delta\\lambda)}{g'(\\Delta\\lambda)}.\n$$\n为确保全局收敛，我们实施以下安全措施：\n\n- 初始化和区间限定：设置下界 $\\lambda_{\\mathrm{L}} = 0$。如果 $g(0) \\le 0$，则判定为弹性响应并设置 $\\Delta\\lambda = 0$。否则，选择一个初始上界 $\\lambda_{\\mathrm{U}}$（例如，对于一个小的 $\\varepsilon > 0$，取 $\\lambda_{\\mathrm{U}} = \\max\\left( \\dfrac{g(0)}{2 \\mu}, \\varepsilon \\right)$），并增加 $\\lambda_{\\mathrm{U}}$（例如，通过加倍）直到 $g(\\lambda_{\\mathrm{U}}) \\le 0$。这样，唯一的根就位于 $[\\lambda_{\\mathrm{L}}, \\lambda_{\\mathrm{U}}]$ 内。\n- 安全步：计算牛顿候选值 $\\Delta\\lambda_{\\mathrm{N}}$。如果 $\\Delta\\lambda_{\\mathrm{N}} \\notin [\\lambda_{\\mathrm{L}}, \\lambda_{\\mathrm{U}}]$，则用二分步 $\\Delta\\lambda_{\\mathrm{B}} = \\dfrac{\\lambda_{\\mathrm{L}} + \\lambda_{\\mathrm{U}}}{2}$ 替换它。否则，使用 $\\Delta\\lambda_{\\mathrm{N}}$ 作为线搜索的方向基础。\n- 带 Armijo 条件的线搜索：定义牛顿方向 $p = -\\dfrac{g(\\Delta\\lambda)}{g'(\\Delta\\lambda)}$。从步长 $\\alpha = 1$ 开始，进行回溯（例如，重复将 $\\alpha$ 减半），直到满足 Armijo 充分下降条件：\n$$\n\\phi(\\Delta\\lambda + \\alpha p) \\le \\phi(\\Delta\\lambda) + c \\, \\alpha \\, \\nabla \\phi(\\Delta\\lambda) \\, p,\n$$\n其中 $c \\in (0,1)$，$\\nabla \\phi(\\Delta\\lambda) = g(\\Delta\\lambda) g'(\\Delta\\lambda)$。因为 $p = -\\dfrac{g(\\Delta\\lambda)}{g'(\\Delta\\lambda)}$，右侧简化为\n$$\n\\phi(\\Delta\\lambda) - c \\, \\alpha \\, g(\\Delta\\lambda)^2.\n$$\n此外，确保接受的步长 $\\Delta\\lambda_{\\mathrm{new}} = \\Delta\\lambda + \\alpha p$ 保持在 $[\\lambda_{\\mathrm{L}}, \\lambda_{\\mathrm{U}}]$ 内。如果牛顿候选值超出该区间，则改用二分步，这会减小区间的大小。\n- 区间更新：如果 $g(\\Delta\\lambda_{\\mathrm{new}}) > 0$，则设置 $\\lambda_{\\mathrm{L}} \\leftarrow \\Delta\\lambda_{\\mathrm{new}}$；否则，设置 $\\lambda_{\\mathrm{U}} \\leftarrow \\Delta\\lambda_{\\mathrm{new}}$。然后设置 $\\Delta\\lambda \\leftarrow \\Delta\\lambda_{\\mathrm{new}}$。\n\n终止准则：当 $|g(\\Delta\\lambda)| \\le \\varepsilon_{\\mathrm{tol}}$ （对于选定的容差 $\\varepsilon_{\\mathrm{tol}} > 0$）或区间宽度 $|\\lambda_{\\mathrm{U}} - \\lambda_{\\mathrm{L}}| \\le \\varepsilon_{\\mathrm{tol}}$ 时停止。\n\n全局收敛性和唯一性条件：在以下条件下，所提出的方法全局收敛到唯一根：\n- 函数 $g(\\Delta\\lambda)$ 在 $[0, +\\infty)$ 上是连续可微的；这一点成立，因为 $g$ 是多项式和指数函数的组合。\n- 严格单调性且导数有界远离零：存在一个常数 $m > 0$，使得对于所有 $\\Delta\\lambda \\ge 0$，都有 $g'(\\Delta\\lambda) \\le -m  0$。在我们的情况中，$m = 2 \\mu$，所以只要 $\\mu > 0$，对于所有 $\\Delta\\lambda \\ge 0$，都有 $g'(\\Delta\\lambda) \\le -2 \\mu  0$。这确保了 $g$ 是强单调的，且根是唯一的。\n- 区间限定条件：如果 $g(0) > 0$，则存在 $\\lambda_{\\mathrm{U}} > 0$ 使得 $g(\\lambda_{\\mathrm{U}}) \\le 0$；由于 $\\lim_{\\Delta\\lambda \\to +\\infty} g(\\Delta\\lambda) = -\\infty$，这样的 $\\lambda_{\\mathrm{U}}$ 总是存在的。建立一个包含根的区间 $[\\lambda_{\\mathrm{L}}, \\lambda_{\\mathrm{U}}]$ 可以确保安全牛顿步或二分法能将迭代值保持在区间内并取得进展。\n- 价值函数 $\\phi(\\Delta\\lambda) = \\dfrac{1}{2} g(\\Delta\\lambda)^2$ 是连续可微的，且牛顿方向是 $\\phi$ 的一个下降方向（只要 $g'(\\Delta\\lambda) \\neq 0$）。Armijo 回溯保证了充分下降，因此保证了从区间内任何起始点出发的收敛性。\n\n给定这些条件和安全措施，对于所有容许的材料参数（$\\mu > 0$，$H \\ge 0$，$b > 0$）以及任何满足 $g(0) > 0$ （塑性加载）的试探状态，该算法都会全局收敛到唯一的根 $\\Delta\\lambda^\\star$。如果 $g(0) \\le 0$，则该步为弹性步，正确解为 $\\Delta\\lambda = 0$。\n\n测试套件的实现细节：对于每个测试用例 $(\\mu,\\|\\boldsymbol{s}_{\\mathrm{tr}}\\|,\\sigma_{\\mathrm{y}0},H,b,\\alpha_n)$，定义\n$$\ng(\\Delta\\lambda) = \\|\\boldsymbol{s}_{\\mathrm{tr}}\\| - 2 \\mu \\, \\Delta\\lambda - \\sqrt{\\dfrac{2}{3}} \\left[ \\sigma_{\\mathrm{y}0} + H \\left( 1 - e^{-b (\\alpha_n + \\sqrt{\\dfrac{2}{3}} \\, \\Delta\\lambda)} \\right) \\right],\n$$\n和\n$$\ng'(\\Delta\\lambda) = - 2 \\mu - \\left( \\dfrac{2}{3} \\right) H b \\, e^{-b (\\alpha_n + \\sqrt{\\dfrac{2}{3}} \\, \\Delta\\lambda)}.\n$$\n应用所述的带有 Armijo 回溯线搜索和二分法备用方案的安全牛顿迭代法，并将四种情况下计算出的 $\\Delta\\lambda$ 值汇总成指定的输出格式。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_delta_lambda(mu, s_tr_norm, sigma_y0, H, b, alpha_n,\n                         tol=1e-12, max_iter=200, armijo_c=1e-4, backtrack_factor=0.5):\n    \"\"\"\n    Safeguarded Newton iteration with line search to solve g(Δλ) = 0 for J2 plasticity\n    with exponential isotropic hardening. Returns Δλ >= 0.\n    \"\"\"\n    sqrt23 = np.sqrt(2.0 / 3.0)\n\n    def g(lam):\n        return (s_tr_norm\n                - 2.0 * mu * lam\n                - sqrt23 * (sigma_y0 + H * (1.0 - np.exp(-b * (alpha_n + sqrt23 * lam)))))\n\n    def gp(lam):\n        # g'(lam) = -2 mu - (2/3) H b exp(-b (alpha_n + sqrt(2/3) lam))\n        return -2.0 * mu - (2.0 / 3.0) * H * b * np.exp(-b * (alpha_n + sqrt23 * lam))\n\n    # Elastic check: if g(0) = 0, no plastic correction\n    g0 = g(0.0)\n    if g0 = 0.0:\n        return 0.0\n\n    # Bracketing: lower bound is 0, find upper bound with g(upper) = 0\n    # Start with a heuristic upper bound and expand until sign change.\n    # Heuristic: ignoring hardening saturation, lam_u0 ~ g0 / (2 mu)\n    lam_L = 0.0\n    lam_U = max(g0 / (2.0 * mu), 1e-16)\n    # Ensure lam_U within a reasonable range by expansion\n    # Since g(lam) -> -inf as lam -> +inf, this loop will terminate.\n    iter_expand = 0\n    while g(lam_U) > 0.0 and iter_expand  1000:\n        lam_U *= 2.0\n        iter_expand += 1\n    if g(lam_U) > 0.0:\n        # As a fallback, set a very large upper bound\n        lam_U = lam_U + 1.0\n        while g(lam_U) > 0.0:\n            lam_U *= 2.0\n\n    # Initialize current iterate within bracket\n    lam = lam_L\n\n    # Merit function\n    def phi(lam):\n        val = g(lam)\n        return 0.5 * val * val\n\n    # Main safeguarded Newton iteration with line search\n    for _ in range(max_iter):\n        val = g(lam)\n        if abs(val) = tol:\n            break\n        # Newton direction p = -g / g'\n        deriv = gp(lam)\n        # If derivative is too small (shouldn't happen with mu>0), fallback to bisection\n        if deriv == 0.0 or not np.isfinite(deriv):\n            lam_cand = 0.5 * (lam_L + lam_U)\n        else:\n            p = -val / deriv\n            lam_newton = lam + p\n            # If Newton candidate leaves the bracket, use bisection step\n            if lam_newton = lam_L or lam_newton >= lam_U or not np.isfinite(lam_newton):\n                lam_cand = 0.5 * (lam_L + lam_U)\n            else:\n                # Backtracking line search along Newton direction\n                alpha = 1.0\n                phi_curr = phi(lam)\n                # Armijo condition: phi(lam + alpha p) = phi(lam) - c * alpha * g(lam)^2\n                # Also enforce bracket membership\n                while True:\n                    lam_trial = lam + alpha * p\n                    # Project into bracket if numerical noise causes crossing\n                    if lam_trial = lam_L or lam_trial >= lam_U or (not np.isfinite(lam_trial)):\n                        # Reduce step if outside bracket\n                        alpha *= backtrack_factor\n                        if alpha  1e-16:\n                            lam_trial = 0.5 * (lam_L + lam_U)\n                            break\n                        continue\n                    phi_trial = phi(lam_trial)\n                    if phi_trial = phi_curr - armijo_c * alpha * (val * val):\n                        lam_cand = lam_trial\n                        break\n                    alpha *= backtrack_factor\n                    if alpha  1e-16:\n                        lam_cand = 0.5 * (lam_L + lam_U)\n                        break\n\n        # Update bracket\n        val_cand = g(lam_cand)\n        if val_cand > 0.0:\n            lam_L = lam_cand\n        else:\n            lam_U = lam_cand\n        lam = lam_cand\n\n        # Secondary termination: bracket width small\n        if (lam_U - lam_L) = tol:\n            break\n\n    return lam\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case is (mu, ||s_tr||, sigma_y0, H, b, alpha_n)\n    test_cases = [\n        (80000.0, 600.0, 250.0, 1000.0, 10.0, 0.05),  # Case 1: general plastic\n        (80000.0, 500.0, 250.0, 1000.0, 10.0, 0.05),  # Case 2: elastic boundary\n        (80000.0, 600.0, 250.0, 0.0,    10.0, 0.05),  # Case 3: perfect plasticity (H=0)\n        (30000.0, 1200.0, 200.0, 1500.0, 200.0, 0.0), # Case 4: rapid saturation hardening\n    ]\n\n    results = []\n    for case in test_cases:\n        mu, s_tr_norm, sigma_y0, H, b, alpha_n = case\n        dlambda = compute_delta_lambda(mu, s_tr_norm, sigma_y0, H, b, alpha_n)\n        results.append(dlambda)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了$J_2$这类光滑、单屈服面的模型后，我们将探索更为复杂的材料行为。本高级练习引入了多面体塑性模型，其屈服面由多个相交的平面定义，这在模拟岩土材料、混凝土等领域中非常重要。返回映射问题在这里转化为一个二次规划问题，你将通过实现一个原始-对偶主动集算法来求解它，从而深入理解如何处理屈服面的顶点和棱边等奇异点，并为这类复杂模型推导和验证一致性切线刚度。",
            "id": "3596271",
            "problem": "一个广义小应变关联多机制塑性模型被理想化为在由弹性柔度诱导的度量中，将试探应力正交投影到一个凸多面体容许集上。考虑一个广义应力向量 $\\boldsymbol{\\sigma} \\in \\mathbb{R}^3$ 和一个单位弹性柔度 $\\mathbf{C}^{-1} = \\mathbf{I}$，因此弹性预测值（试探应力）为 $\\boldsymbol{\\sigma}^{\\mathrm{tr}} = \\boldsymbol{\\sigma}_n + \\Delta \\boldsymbol{\\varepsilon}$，其中 $\\boldsymbol{\\sigma}_n$ 是上一个收敛的应力，$\\Delta \\boldsymbol{\\varepsilon} \\in \\mathbb{R}^3$ 是施加的广义应变增量。容许集由线性屈服不等式 $\\mathbf{A}\\boldsymbol{\\sigma} - \\boldsymbol{b} \\le \\boldsymbol{0}$ 定义，其中\n$$\n\\mathbf{A} =\n\\begin{bmatrix}\n1  0  0\\\\\n0  1  0\\\\\n0  0  1\\\\\n-1  -1  -1\n\\end{bmatrix},\\quad\n\\boldsymbol{b} =\n\\begin{bmatrix}\n1.0\\\\\n1.1\\\\\n1.2\\\\\n1.0\n\\end{bmatrix}.\n$$\n最近点返回映射问题是找到 $\\boldsymbol{\\sigma}_{n+1}$ 作为以下问题的唯一最小化子\n$$\n\\min_{\\boldsymbol{\\sigma} \\in \\mathbb{R}^3} \\ \\tfrac{1}{2}\\,\\|\\boldsymbol{\\sigma} - \\boldsymbol{\\sigma}^{\\mathrm{tr}}\\|_2^2 \\quad \\text{subject to} \\quad \\mathbf{A}\\boldsymbol{\\sigma} - \\boldsymbol{b} \\le \\boldsymbol{0}.\n$$\n这代表了在简化度量下的多面体多屈服面关联塑性更新，其中多个屈服机制可能同时激活，包括屈服面的顶点（apices）和边。一个顶点（apex）是三个平面同时激活的顶点，而沿边滑动对应于受两个平面交线约束的运动。\n\n您的程序必须实现一个稳健的原始-对偶活动集返回映射算法，该算法能够：\n- 通过求解上述二次规划问题，从 $\\boldsymbol{\\sigma}^{\\mathrm{tr}}$ 计算修正后的应力 $\\boldsymbol{\\sigma}_{n+1}$。\n- 确定解处的约束活动集 $\\mathcal{A}$，即满足 $a_i^\\mathsf{T}\\boldsymbol{\\sigma}_{n+1} - b_i = 0$ 的索引 $i$ 的集合，以及相关的非负拉格朗日乘子 $\\lambda_i \\ge 0$。\n- 计算与收敛的活动集 $\\mathcal{A}$ 相关的一致算法弹塑性切线 $\\mathbf{C}_{\\mathrm{ep}} = \\dfrac{\\partial \\boldsymbol{\\sigma}_{n+1}}{\\partial \\boldsymbol{\\varepsilon}}$。\n- 使用小扰动 $\\delta\\boldsymbol{\\varepsilon}$ 通过线性化检验来验证切线一致性：将线性预测 $\\boldsymbol{\\sigma}_{\\mathrm{pred}} = \\boldsymbol{\\sigma}_{n+1} + \\mathbf{C}_{\\mathrm{ep}}\\delta\\boldsymbol{\\varepsilon}$ 与通过对扰动后的试探应力 $\\boldsymbol{\\sigma}^{\\mathrm{tr}} + \\delta\\boldsymbol{\\varepsilon}$ 重新运行返回映射得到的完全返回应力 $\\boldsymbol{\\sigma}_{\\mathrm{fd}}$进行比较。报告相对一致性误差\n$$\ne = \\frac{\\|\\boldsymbol{\\sigma}_{\\mathrm{fd}} - \\boldsymbol{\\sigma}_{\\mathrm{pred}}\\|_2}{\\max\\{1,\\ \\|\\boldsymbol{\\sigma}_{\\mathrm{pred}}\\|_2\\}}.\n$$\n\n设计一个应力路径，该路径首先激活一个顶点（三个机制），然后沿一条边滑动（两个机制）。使用以下包含三个双增量加载路径的测试套件，所有路径都从 $\\boldsymbol{\\sigma}_0 = (0,0,0)^\\mathsf{T}$ 开始，并使用相同的第一个增量驱动到顶点：\n- 所有情况的第一个增量：$\\Delta \\boldsymbol{\\varepsilon}_1 = (3.0,\\ 3.0,\\ 3.0)^\\mathsf{T}$。\n- 第二个增量因情况而异：\n  - 情况 A（到达顶点后沿由平面 $1$ 和 $2$ 定义的边滑动）：$\\Delta \\boldsymbol{\\varepsilon}_2^{\\mathrm{A}} = (0.01,\\ 0.01,\\ -0.05)^\\mathsf{T}$。\n  - 情况 B（停留在顶点，所有三个平面保持激活）：$\\Delta \\boldsymbol{\\varepsilon}_2^{\\mathrm{B}} = (0.01,\\ 0.01,\\ 0.01)^\\mathsf{T}$。\n  - 情况 C（到达顶点后沿由平面 $1$ 和 $3$ 定义的边滑动）：$\\Delta \\boldsymbol{\\varepsilon}_2^{\\mathrm{C}} = (0.01,\\ -0.05,\\ 0.01)^\\mathsf{T}$。\n对于每个增量中的切线一致性检查，使用固定扰动 $\\delta\\boldsymbol{\\varepsilon} = (10^{-7},\\ -2\\times 10^{-7},\\ 3\\times 10^{-7})^\\mathsf{T}$。\n\n对于每种情况，执行两个返回映射步骤：\n- 步骤 $1$：$\\boldsymbol{\\sigma}^{\\mathrm{tr}}_1 = \\boldsymbol{\\sigma}_0 + \\Delta \\boldsymbol{\\varepsilon}_1$，返回映射以获得 $\\boldsymbol{\\sigma}_1$、活动集 $\\mathcal{A}_1$ 和切线 $\\mathbf{C}_{\\mathrm{ep},1}$。\n- 步骤 $2$：$\\boldsymbol{\\sigma}^{\\mathrm{tr}}_2 = \\boldsymbol{\\sigma}_1 + \\Delta \\boldsymbol{\\varepsilon}_2$，返回映射以获得 $\\boldsymbol{\\sigma}_2$、活动集 $\\mathcal{A}_2$ 和切线 $\\mathbf{C}_{\\mathrm{ep},2}$。\n\n您的程序必须为每种情况生成以下四个输出：\n- $a_1$：$\\mathcal{A}_1$ 的整数基数，\n- $a_2$：$\\mathcal{A}_2$ 的整数基数，\n- $e_1$：步骤 $1$ 的切线一致性误差，为一个浮点数，\n- $e_2$：步骤 $2$ 的切线一致性误差，为一个浮点数。\n\n最终输出格式：您的程序应生成单行输出，其中包含按 A、B、C 顺序串联的三个案例的结果，形式为用方括号括起来的逗号分隔列表，即 $[a_1^{\\mathrm{A}}, a_2^{\\mathrm{A}}, e_1^{\\mathrm{A}}, e_2^{\\mathrm{A}}, a_1^{\\mathrm{B}}, a_2^{\\mathrm{B}}, e_1^{\\mathrm{B}}, e_2^{\\mathrm{B}}, a_1^{\\mathrm{C}}, a_2^{\\mathrm{C}}, e_1^{\\mathrm{C}}, e_2^{\\mathrm{C}}]$。不涉及物理单位；所有量均为无量纲实数。",
            "solution": "用户提供了一个来自计算固体力学领域的有效问题陈述，具体涉及多屈服面关联塑性模型的返回映射算法的实现。该问题具有科学依据，是适定的，并且为获得唯一解提供了所有必要的数据和定义。\n\n该问题要求实现一个返回映射算法，即一个试探应力状态在一个凸容许应力区域上的正交投影。这被表述为一个二次规划（QP）问题。解决方案需要开发一个原始-对偶活动集方法来求解这个 QP，计算一致算法切线模量，并通过线性化检查来验证其正确性。\n\n### 1. 理论公式\n\n问题的核心是找到更新后的应力 $\\boldsymbol{\\sigma}_{n+1}$，该应力在满足代表屈服准则的一组线性不等式约束的同时，最小化到试探应力 $\\boldsymbol{\\sigma}^{\\mathrm{tr}}$ 的欧几里得距离。\n\n给定试探应力 $\\boldsymbol{\\sigma}^{\\mathrm{tr}} \\in \\mathbb{R}^3$，我们寻求解决：\n$$\n\\min_{\\boldsymbol{\\sigma} \\in \\mathbb{R}^3} \\ f(\\boldsymbol{\\sigma}) = \\frac{1}{2} \\|\\boldsymbol{\\sigma} - \\boldsymbol{\\sigma}^{\\mathrm{tr}}\\|_2^2 \\quad \\text{subject to} \\quad \\mathbf{A}\\boldsymbol{\\sigma} - \\boldsymbol{b} \\le \\boldsymbol{0}\n$$\n这是一个凸优化问题，因为目标函数是严格凸的，并且由线性不等式定义的可行集是一个凸多面体。因此，存在唯一解。Karush-Kuhn-Tucker (KKT) 条件是最优性的充要条件。\n\n该问题的拉格朗日函数为：\n$$\n\\mathcal{L}(\\boldsymbol{\\sigma}, \\boldsymbol{\\lambda}) = \\frac{1}{2} (\\boldsymbol{\\sigma} - \\boldsymbol{\\sigma}^{\\mathrm{tr}})^\\mathsf{T}(\\boldsymbol{\\sigma} - \\boldsymbol{\\sigma}^{\\mathrm{tr}}) + \\boldsymbol{\\lambda}^\\mathsf{T}(\\mathbf{A}\\boldsymbol{\\sigma} - \\boldsymbol{b})\n$$\n其中 $\\boldsymbol{\\lambda} \\in \\mathbb{R}^4$ 是拉格朗日乘子向量。在解 $(\\boldsymbol{\\sigma}_{n+1}, \\boldsymbol{\\lambda})$ 处的 KKT 条件为：\n1.  **平稳性 (Stationarity):** $\\nabla_{\\boldsymbol{\\sigma}} \\mathcal{L} = \\boldsymbol{\\sigma}_{n+1} - \\boldsymbol{\\sigma}^{\\mathrm{tr}} + \\mathbf{A}^\\mathsf{T}\\boldsymbol{\\lambda} = \\boldsymbol{0} \\implies \\boldsymbol{\\sigma}_{n+1} = \\boldsymbol{\\sigma}^{\\mathrm{tr}} - \\mathbf{A}^\\mathsf{T}\\boldsymbol{\\lambda}$。\n2.  **原始可行性 (Primal Feasibility):** $\\mathbf{A}\\boldsymbol{\\sigma}_{n+1} - \\boldsymbol{b} \\le \\boldsymbol{0}$。\n3.  **对偶可行性 (Dual Feasibility):** $\\boldsymbol{\\lambda} \\ge \\boldsymbol{0}$。\n4.  **互补松弛性 (Complementary Slackness):** 对于每个约束 $i \\in \\{0, 1, 2, 3\\}$，有 $\\lambda_i (\\mathbf{a}_i^\\mathsf{T}\\boldsymbol{\\sigma}_{n+1} - b_i) = 0$。\n\n### 2. 原始-对偶活动集算法\n\n采用原始-对偶活动集方法来求解 KKT 系统。该算法迭代地猜测活动约束集 $\\mathcal{A}$（即满足 $\\mathbf{a}_i^\\mathsf{T}\\boldsymbol{\\sigma}_{n+1} - b_i = 0$ 的约束），并求解一个简化的等式约束 QP。算法流程如下：\n\n1.  **初始化:** 从对活动集 $\\mathcal{A}$ 的初始猜测开始。一个常见的选择是所有被试探应力 $\\boldsymbol{\\sigma}^{\\mathrm{tr}}$ 违反的约束的集合。\n2.  **迭代:** 循环直至收敛：\n    a.  **求解子问题:** 假设当前活动集 $\\mathcal{A}$ 中的约束是绑定的（$\\mathbf{A}_{\\mathcal{A}}\\boldsymbol{\\sigma} = \\boldsymbol{b}_{\\mathcal{A}}$），并且其他乘子为零。将平稳性条件代入活动约束中，可以得到关于活动拉格朗日乘子 $\\boldsymbol{\\lambda}_{\\mathcal{A}}$ 的线性系统：\n        $$\n        (\\mathbf{A}_{\\mathcal{A}} \\mathbf{A}_{\\mathcal{A}}^\\mathsf{T}) \\boldsymbol{\\lambda}_{\\mathcal{A}} = \\mathbf{A}_{\\mathcal{A}}\\boldsymbol{\\sigma}^{\\mathrm{tr}} - \\boldsymbol{b}_{\\mathcal{A}}\n        $$\n        求解 $\\boldsymbol{\\lambda}_{\\mathcal{A}}$。\n    b.  **检查收敛性并更新活动集:**\n        i.  **对偶可行性检查:** 检查对于所有 $i \\in \\mathcal{A}$，计算出的 $\\lambda_i$ 是否都 $\\ge 0$。如果任何 $\\lambda_i  0$，则相应的约束应该是非活动的。从 $\\mathcal{A}$ 中移除对应于最负的 $\\lambda_i$ 的索引，并重复迭代。\n        ii. **原始可行性检查:** 如果对偶可行性成立，计算相应的应力 $\\boldsymbol{\\sigma} = \\boldsymbol{\\sigma}^{\\mathrm{tr}} - \\mathbf{A}_{\\mathcal{A}}^\\mathsf{T}\\boldsymbol{\\lambda}_{\\mathcal{A}}$。然后检查对于所有非活动约束 $j \\notin \\mathcal{A}$，是否有 $\\mathbf{a}_j^\\mathsf{T}\\boldsymbol{\\sigma} - b_j \\le 0$。如果任何约束被违反，将最被违反的约束的索引添加到 $\\mathcal{A}$ 中，并重复迭代。\n    c.  **终止:** 如果活动集的对偶可行性和非活动集的原始可行性都得到满足，则 KKT 条件已满足，算法已收敛到唯一解 $(\\boldsymbol{\\sigma}_{n+1}, \\boldsymbol{\\lambda})$。\n\n收敛时的最终活动集 $\\mathcal{A}$ 包含最终应力状态 $\\boldsymbol{\\sigma}_{n+1}$ 所在屈服面的索引。其基数表示为 $a$。\n\n### 3. 一致算法切线\n\n一致算法弹塑性切线模量定义为 $\\mathbf{C}_{\\mathrm{ep}} = \\frac{\\partial \\boldsymbol{\\sigma}_{n+1}}{\\partial \\boldsymbol{\\varepsilon}}$，其中 $\\boldsymbol{\\varepsilon}$ 是总应变。鉴于 $\\boldsymbol{\\sigma}^{\\mathrm{tr}} = \\boldsymbol{\\sigma}_n + \\mathbf{C}\\Delta\\boldsymbol{\\varepsilon}$ 且对于此问题 $\\mathbf{C} = \\mathbf{I}$，我们有 $\\mathrm{d}\\boldsymbol{\\sigma}^{\\mathrm{tr}} = \\mathrm{d}(\\Delta\\boldsymbol{\\varepsilon})$。因此，我们寻求 $\\frac{\\partial \\boldsymbol{\\sigma}_{n+1}}{\\partial \\boldsymbol{\\sigma}^{\\mathrm{tr}}}$。\n\n假设活动集 $\\mathcal{A}$ 对于无穷小扰动保持不变，我们可以对收敛的 KKT 系统进行微分：\n$$\n\\mathrm{d}\\boldsymbol{\\sigma}_{n+1} = \\mathrm{d}\\boldsymbol{\\sigma}^{\\mathrm{tr}} - \\mathbf{A}_{\\mathcal{A}}^\\mathsf{T} \\mathrm{d}\\boldsymbol{\\lambda}_{\\mathcal{A}}\n$$\n$$\n\\mathbf{A}_{\\mathcal{A}}\\mathrm{d}\\boldsymbol{\\sigma}_{n+1} = \\boldsymbol{0}\n$$\n将第一个方程代入第二个方程并求解 $\\mathrm{d}\\boldsymbol{\\lambda}_{\\mathcal{A}}$ 得到 $\\mathrm{d}\\boldsymbol{\\lambda}_{\\mathcal{A}} = (\\mathbf{A}_{\\mathcal{A}}\\mathbf{A}_{\\mathcal{A}}^\\mathsf{T})^{-1}\\mathbf{A}_{\\mathcal{A}}\\mathrm{d}\\boldsymbol{\\sigma}^{\\mathrm{tr}}$。将其代回可得到 $\\mathrm{d}\\boldsymbol{\\sigma}_{n+1}$ 的表达式：\n$$\n\\mathrm{d}\\boldsymbol{\\sigma}_{n+1} = \\left(\\mathbf{I} - \\mathbf{A}_{\\mathcal{A}}^\\mathsf{T}(\\mathbf{A}_{\\mathcal{A}}\\mathbf{A}_{\\mathcal{A}}^\\mathsf{T})^{-1}\\mathbf{A}_{\\mathcal{A}}\\right) \\mathrm{d}\\boldsymbol{\\sigma}^{\\mathrm{tr}}\n$$\n因此，一致切线为：\n$$\n\\mathbf{C}_{\\mathrm{ep}} = \\mathbf{I} - \\mathbf{A}_{\\mathcal{A}}^\\mathsf{T}(\\mathbf{A}_{\\mathcal{A}}\\mathbf{A}_{\\mathcal{A}}^\\mathsf{T})^{-1}\\mathbf{A}_{\\mathcal{A}}\n$$\n如果步骤是弹性的（$\\mathcal{A}$ 为空），则 $\\mathbf{C}_{\\mathrm{ep}} = \\mathbf{I}$。否则，$\\mathbf{C}_{\\mathrm{ep}}$ 是一个投影矩阵，它投影到与活动屈服面交点相切的子空间上。\n\n### 4. 切线一致性验证\n\n计算出的切线 $\\mathbf{C}_{\\mathrm{ep}}$ 的正确性通过线性化检验进行验证。引入一个小的扰动 $\\delta\\boldsymbol{\\varepsilon}$。由线性切线预测的应力状态 $\\boldsymbol{\\sigma}_{\\mathrm{pred}} = \\boldsymbol{\\sigma}_{n+1} + \\mathbf{C}_{\\mathrm{ep}}\\delta\\boldsymbol{\\varepsilon}$ 与从扰动后的试探应力 $\\boldsymbol{\\sigma}^{\\mathrm{tr}} + \\delta\\boldsymbol{\\varepsilon}$ 通过完全非线性返回映射获得的应力 $\\boldsymbol{\\sigma}_{\\mathrm{fd}}$ 进行比较。相对误差 $e$ 计算如下：\n$$\ne = \\frac{\\|\\boldsymbol{\\sigma}_{\\mathrm{fd}} - \\boldsymbol{\\sigma}_{\\mathrm{pred}}\\|_2}{\\max\\{1,\\ \\|\\boldsymbol{\\sigma}_{\\mathrm{pred}}\\|_2\\}}\n$$\n对于一致的切线和足够小的扰动（不改变活动集），此误差应接近机器精度。\n\n实现将遵循这些原则，执行三个指定案例的双步加载路径，并报告所需的活动集基数和一致性误差。",
            "answer": "```python\nimport numpy as np\n\ndef return_map_primal_dual(sigma_tr, A, b):\n    \"\"\"\n    Solves the closest-point projection QP using a primal-dual active-set method.\n    \n    min 1/2 ||sigma - sigma_tr||^2\n    s.t. A sigma - b = 0\n    \"\"\"\n    n_constraints, n_dim = A.shape\n    tol = 1e-12\n\n    # Initial guess for active set: all constraints violated by trial stress\n    violations = A @ sigma_tr - b\n    active_set = {i for i, v in enumerate(violations) if v > tol}\n\n    # Iteratively refine the active set\n    for _ in range(2 * n_constraints + 1): # Safeguard, should converge faster\n        if not active_set:\n            # Current guess is purely elastic\n            sigma = sigma_tr\n            lambdas = np.zeros(n_constraints)\n            \n            # Check primal feasibility for elastic guess\n            violations = A @ sigma - b\n            if np.all(violations = tol):\n                return sigma, [], lambdas # Converged to elastic solution\n            else:\n                # Elastic guess is infeasible, activate the most violated constraint\n                active_set.add(np.argmax(violations))\n                continue\n\n        # Solve subproblem for the current active set\n        active_indices = sorted(list(active_set))\n        A_active = A[active_indices, :]\n        b_active = b[active_indices]\n\n        try:\n            G = A_active @ A_active.T\n            G_inv = np.linalg.inv(G)\n        except np.linalg.LinAlgError:\n            # This can happen if constraint normals are linearly dependent.\n            # The logic should prevent this, but as a fallback, we raise an error.\n            raise RuntimeError(f\"Singular matrix for active set: {active_indices}\")\n\n        rhs = A_active @ sigma_tr - b_active\n        lambda_active = G_inv @ rhs\n\n        # Check dual feasibility (lambda_i >= 0 for all i in active_set)\n        min_lambda = np.inf\n        remove_idx = -1\n        for i, lam in enumerate(lambda_active):\n            if lam  -tol:\n                if lam  min_lambda:\n                    min_lambda = lam\n                    remove_idx = active_indices[i]\n        \n        if remove_idx != -1:\n            # A multiplier is negative, remove it from active set and retry\n            active_set.remove(remove_idx)\n            continue\n\n        # Dual feasibility is met. Compute sigma and check primal feasibility for inactive.\n        lambdas = np.zeros(n_constraints)\n        lambdas[active_indices] = lambda_active\n        sigma = sigma_tr - A.T @ lambdas\n\n        violations = A @ sigma - b\n        max_violation = -1.0\n        add_idx = -1\n        inactive_set = set(range(n_constraints)) - active_set\n        for i in inactive_set:\n            if violations[i] > tol:\n                if violations[i] > max_violation:\n                    max_violation = violations[i]\n                    add_idx = i\n        \n        if add_idx != -1:\n            # Primal feasibility violated, add the constraint and retry\n            active_set.add(add_idx)\n            continue\n\n        # All KKT conditions are satisfied.\n        return sigma, active_indices, lambdas\n        \n    raise RuntimeError(\"Return mapping did not converge within max iterations.\")\n\ndef compute_tangent(active_set_indices, A):\n    \"\"\"Computes the consistent algorithmic tangent.\"\"\"\n    dim = A.shape[1]\n    if not active_set_indices:\n        return np.identity(dim)\n\n    A_active = A[active_set_indices, :]\n    try:\n        G = A_active @ A_active.T\n        G_inv = np.linalg.inv(G)\n        C_ep = np.identity(dim) - A_active.T @ G_inv @ A_active\n    except np.linalg.LinAlgError:\n        raise RuntimeError(f\"Singular matrix for active set in tangent computation: {active_set_indices}\")\n    \n    return C_ep\n\ndef check_consistency(sigma_tr, sigma_ret, C_ep, delta_eps_pert, A, b):\n    \"\"\"Performs the tangent consistency check and returns the error.\"\"\"\n    # Linearized prediction\n    sigma_pred = sigma_ret + C_ep @ delta_eps_pert\n    \n    # Fully-democratic returned stress from perturbed trial stress\n    sigma_tr_pert = sigma_tr + delta_eps_pert\n    sigma_fd, _, _ = return_map_primal_dual(sigma_tr_pert, A, b)\n    \n    # Compute relative error\n    error_norm = np.linalg.norm(sigma_fd - sigma_pred)\n    pred_norm = np.linalg.norm(sigma_pred)\n    \n    return error_norm / max(1.0, pred_norm)\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Problem definition\n    A = np.array([\n        [1., 0., 0.],\n        [0., 1., 0.],\n        [0., 0., 1.],\n        [-1., -1., -1.]\n    ])\n    b = np.array([1.0, 1.1, 1.2, 1.0])\n    \n    sigma_0 = np.array([0.0, 0.0, 0.0])\n    delta_eps_1 = np.array([3.0, 3.0, 3.0])\n    \n    test_cases = {\n        'A': np.array([0.01, 0.01, -0.05]),\n        'B': np.array([0.01, 0.01, 0.01]),\n        'C': np.array([0.01, -0.05, 0.01]),\n    }\n    \n    delta_eps_pert = np.array([1e-7, -2e-7, 3e-7])\n    \n    all_results = []\n\n    for case_label in ['A', 'B', 'C']:\n        delta_eps_2 = test_cases[case_label]\n        case_results = []\n        \n        # --- Step 1 ---\n        sigma_tr_1 = sigma_0 + delta_eps_1\n        sigma_1, active_set_1, _ = return_map_primal_dual(sigma_tr_1, A, b)\n        a1 = len(active_set_1)\n        C_ep_1 = compute_tangent(active_set_1, A)\n        e1 = check_consistency(sigma_tr_1, sigma_1, C_ep_1, delta_eps_pert, A, b)\n        \n        case_results.extend([a1, 0, e1, 0.0]) # Placeholder for step 2 results\n\n        # --- Step 2 ---\n        sigma_tr_2 = sigma_1 + delta_eps_2\n        sigma_2, active_set_2, _ = return_map_primal_dual(sigma_tr_2, A, b)\n        a2 = len(active_set_2)\n        C_ep_2 = compute_tangent(active_set_2, A)\n        e2 = check_consistency(sigma_tr_2, sigma_2, C_ep_2, delta_eps_pert, A, b)\n        \n        case_results[1] = a2\n        case_results[3] = e2\n        \n        all_results.extend(case_results)\n\n    # Format the final output string\n    output_str = f\"[{','.join(f'{x:.8e}' if isinstance(x, float) else str(x) for x in all_results)}]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}