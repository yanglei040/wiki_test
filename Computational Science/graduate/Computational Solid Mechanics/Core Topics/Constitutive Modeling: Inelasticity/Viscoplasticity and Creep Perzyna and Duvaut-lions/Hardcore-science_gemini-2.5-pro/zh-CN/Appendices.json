{
    "hands_on_practices": [
        {
            "introduction": "任何计算粘塑性模拟的核心都是本构更新，也称为“返回映射算法”。本练习将挑战你，使用 Perzyna 模型，为一个材料点推导出其核心数值计算过程。通过使用隐式后向欧拉格式离散化流动法则，你将构建出控制一个时间步内塑性演化的非线性标量方程，并设计求解该方程的Newton-Raphson方法，这是构建复杂有限元分析的基础。",
            "id": "3609493",
            "problem": "一个具有线性各向同性硬化的小应变、等温、率相关的 von Mises (J2) 固体，使用带有幂律粘性的单步后向欧拉（隐式）Perzyna 超应力更新方法，从时间步 $n$ 推进到 $n+1$。应变被加性分解为 $\\boldsymbol{\\varepsilon}=\\boldsymbol{\\varepsilon}^{\\mathrm{e}}+\\boldsymbol{\\varepsilon}^{\\mathrm{p}}$，线性弹性响应由剪切模量 $G$ 表征，各向同性硬化定律为 $\\sigma_{\\mathrm{y}}=\\sigma_{\\mathrm{y}0}+H\\,\\varepsilon_{\\mathrm{p}}^{\\mathrm{eq}}$，其中 $\\varepsilon_{\\mathrm{p}}^{\\mathrm{eq}}$ 是等效塑性应变。von Mises 等效应力为 $\\sigma_{\\mathrm{eq}}=\\sqrt{\\tfrac{3}{2}\\,\\boldsymbol{s}:\\boldsymbol{s}}$，其中 $\\boldsymbol{s}$ 是偏应力张量。屈服函数为 $f=\\sigma_{\\mathrm{eq}}-\\sigma_{\\mathrm{y}}$。具有幂律粘性的 Perzyna 流动法则为 $\\dot{\\gamma}=\\eta_{\\mathrm{v}}^{-1}\\left\\langle f/\\sigma_{0}\\right\\rangle^{m}$，其中 $\\langle\\cdot\\rangle$ 是 Macaulay 括号，$\\eta_{\\mathrm{v}}$ 是粘性参数，$\\sigma_{0}$ 是一个应力标度，$m \\ge 1$ 是率敏感性指数，$\\gamma$ 是塑性乘子，在 J2 模型中与等效塑性应变的增量一致。\n\n考虑一个从 $t_{n}$ 处的已知状态（给定 $\\varepsilon_{\\mathrm{p},n}^{\\mathrm{eq}}$）到 $t_{n+1}$ 的大小为 $\\Delta t$ 的单个隐式时间步，其弹性预测值 $\\sigma_{\\mathrm{eq},\\mathrm{tr}}$ 是通过在该步长内冻结塑性流动来定义的。假设共轴性，使得流动方向与试探偏应力方向保持一致，并且 von Mises 等效应力按 $\\sigma_{\\mathrm{eq},n+1}=\\sigma_{\\mathrm{eq},\\mathrm{tr}}-3G\\,\\Delta\\gamma$ 更新。假设各向同性硬化，使得 $\\varepsilon_{\\mathrm{p},n+1}^{\\mathrm{eq}}=\\varepsilon_{\\mathrm{p},n}^{\\mathrm{eq}}+\\Delta\\gamma$ 并且 $\\sigma_{\\mathrm{y},n+1}=\\sigma_{\\mathrm{y}0}+H\\left(\\varepsilon_{\\mathrm{p},n}^{\\mathrm{eq}}+\\Delta\\gamma\\right)$。\n\n任务：\n1) 仅从上述定义和定律出发，推导塑性乘子增量 $\\Delta\\gamma$ 的标量非线性残差方程，该方程由具有通用幂律指数 $m$ 的 Perzyna 流动法则的单步后向欧拉离散化产生，并明确其对材料和步长数据 $\\left(\\sigma_{\\mathrm{eq},\\mathrm{tr}},\\,\\sigma_{\\mathrm{y}0},\\,H,\\,G,\\,\\varepsilon_{\\mathrm{p},n}^{\\mathrm{eq}},\\,\\eta_{\\mathrm{v}},\\,\\sigma_{0},\\,m,\\,\\Delta t\\right)$ 的依赖关系。\n2) 推导求解此标量残差的 Newton-Raphson 迭代公式，包括 Jacobian（残差相对于 $\\Delta\\gamma$ 的导数）的表达式，并基于在试探状态下计算的显式 Perzyna 预测值，提出一个有数学依据的初始猜测值。\n3) 特化到 $m=1$ 的情况和以下数据（应力使用兆帕斯卡）：\n$\\sigma_{\\mathrm{eq},\\mathrm{tr}}=500$, $\\sigma_{\\mathrm{y}0}=250$, $H=1000$, $G=30000$, $\\varepsilon_{\\mathrm{p},n}^{\\mathrm{eq}}=0.05$, $\\eta_{\\mathrm{v}}=10\\,\\mathrm{s}$, $\\sigma_{0}=100$, and $\\Delta t=0.5\\,\\mathrm{s}$。在这些数据下，计算由您在第2部分推导的 Newton-Raphson 方案得到的 $\\Delta\\gamma$ 的收敛值。如果当 $m=1$ 时非线性方程变为线性方程，请报告其精确解。将 $\\Delta\\gamma$ 的最终值表示为一个无量纲数，并四舍五入到四位有效数字。",
            "solution": "### 第1部分：标量残差方程的推导\n\nPerzyna 流动法则将塑性乘子率 $\\dot{\\gamma}$ 与超应力联系起来。使用一个大小为 $\\Delta t$ 的时间步上的后向欧拉隐式积分方案，在时间步的末端 $t_{n+1}$ 处评估流动法则：\n$$\n\\frac{\\Delta\\gamma}{\\Delta t} = \\dot{\\gamma}_{n+1} = \\frac{1}{\\eta_{\\mathrm{v}}} \\left\\langle \\frac{f_{n+1}}{\\sigma_{0}} \\right\\rangle ^m\n$$\n其中 $\\Delta\\gamma = \\gamma_{n+1} - \\gamma_{n}$ 是该步长内塑性乘子的增量。通过重新排列该方程，可以定义一个标量残差方程 $R(\\Delta\\gamma) = 0$：\n$$\nR(\\Delta\\gamma) = \\Delta\\gamma - \\frac{\\Delta t}{\\eta_{\\mathrm{v}}} \\left\\langle \\frac{f_{n+1}}{\\sigma_{0}} \\right\\rangle ^m = 0\n$$\n为了使这个方程只包含未知数 $\\Delta\\gamma$ 和已知量，我们必须将时间 $t_{n+1}$ 时的屈服函数 $f_{n+1}$ 表示为 $\\Delta\\gamma$ 的函数。屈服函数定义为 $f_{n+1} = \\sigma_{\\mathrm{eq},n+1} - \\sigma_{\\mathrm{y},n+1}$。\n\n使用提供的更新规则：\n$t_{n+1}$ 时的等效应力由下式给出：\n$$\n\\sigma_{\\mathrm{eq},n+1} = \\sigma_{\\mathrm{eq},\\mathrm{tr}} - 3G\\,\\Delta\\gamma\n$$\n$t_{n+1}$ 时的屈服应力取决于累积的等效塑性应变 $\\varepsilon_{\\mathrm{p},n+1}^{\\mathrm{eq}} = \\varepsilon_{\\mathrm{p},n}^{\\mathrm{eq}} + \\Delta\\gamma$：\n$$\n\\sigma_{\\mathrm{y},n+1} = \\sigma_{\\mathrm{y}0} + H\\,\\varepsilon_{\\mathrm{p},n+1}^{\\mathrm{eq}} = \\sigma_{\\mathrm{y}0} + H\\left(\\varepsilon_{\\mathrm{p},n}^{\\mathrm{eq}} + \\Delta\\gamma\\right)\n$$\n这可以写成 $\\sigma_{\\mathrm{y},n+1} = \\sigma_{\\mathrm{y},n} + H\\,\\Delta\\gamma$，其中 $\\sigma_{\\mathrm{y},n} = \\sigma_{\\mathrm{y}0} + H\\,\\varepsilon_{\\mathrm{p},n}^{\\mathrm{eq}}$ 是增量开始时的已知屈服应力。\n\n将这些表达式代入屈服函数 $f_{n+1}$：\n$$\nf_{n+1}(\\Delta\\gamma) = (\\sigma_{\\mathrm{eq},\\mathrm{tr}} - 3G\\,\\Delta\\gamma) - (\\sigma_{\\mathrm{y},n} + H\\,\\Delta\\gamma)\n$$\n$$\nf_{n+1}(\\Delta\\gamma) = (\\sigma_{\\mathrm{eq},\\mathrm{tr}} - \\sigma_{\\mathrm{y},n}) - (3G+H)\\Delta\\gamma\n$$\n项 $\\sigma_{\\mathrm{eq},\\mathrm{tr}} - \\sigma_{\\mathrm{y},n}$ 是试探超应力，我们将其表示为 $f_{\\mathrm{tr}}$。这是用试探弹性应力和先前的塑性状态计算出的屈服函数值。如果 $f_{\\mathrm{tr}} > 0$，则发生粘塑性步。假设此条件成立，我们寻求一个解 $\\Delta\\gamma > 0$ 使得 $f_{n+1} > 0$。在这种情况下，Macaulay 括号 $\\langle \\cdot \\rangle$ 是多余的，可以移除。\n\n将 $f_{n+1}$ 的表达式代入残差方程，得到关于 $\\Delta\\gamma$ 的最终标量非线性方程：\n$$\nR(\\Delta\\gamma) = \\Delta\\gamma - \\frac{\\Delta t}{\\eta_{\\mathrm{v}}\\,\\sigma_{0}^{m}} \\left[ \\sigma_{\\mathrm{eq},\\mathrm{tr}} - \\left(\\sigma_{\\mathrm{y}0} + H\\,\\varepsilon_{\\mathrm{p},n}^{\\mathrm{eq}}\\right) - (3G+H)\\Delta\\gamma \\right]^{m} = 0\n$$\n\n### 第2部分：Newton-Raphson 迭代公式\n\nNewton-Raphson 方法是寻找 $R(\\Delta\\gamma)=0$ 根的迭代方案。给定一个迭代值 $\\Delta\\gamma^{(k)}$，下一个迭代值 $\\Delta\\gamma^{(k+1)}$ 通过以下方式找到：\n$$\n\\Delta\\gamma^{(k+1)} = \\Delta\\gamma^{(k)} - \\frac{R(\\Delta\\gamma^{(k)})}{J(\\Delta\\gamma^{(k)})}\n$$\n其中 $J(\\Delta\\gamma) = \\frac{dR}{d(\\Delta\\gamma)}$ 是残差相对于 $\\Delta\\gamma$ 的 Jacobian。\n\n我们通过对残差 $R(\\Delta\\gamma)$ 求导来计算 Jacobian：\n$$\nJ(\\Delta\\gamma) = \\frac{d}{d(\\Delta\\gamma)} \\left\\{ \\Delta\\gamma - \\frac{\\Delta t}{\\eta_{\\mathrm{v}}\\,\\sigma_{0}^{m}} \\left[ f_{\\mathrm{tr}} - (3G+H)\\Delta\\gamma \\right]^{m} \\right\\}\n$$\n$$\nJ(\\Delta\\gamma) = 1 - \\frac{\\Delta t}{\\eta_{\\mathrm{v}}\\,\\sigma_{0}^{m}} \\cdot m \\left[ f_{\\mathrm{tr}} - (3G+H)\\Delta\\gamma \\right]^{m-1} \\cdot \\frac{d}{d(\\Delta\\gamma)}\\left[-(3G+H)\\Delta\\gamma\\right]\n$$\n$$\nJ(\\Delta\\gamma) = 1 + \\frac{m\\,\\Delta t\\,(3G+H)}{\\eta_{\\mathrm{v}}\\,\\sigma_{0}^{m}} \\left[ f_{\\mathrm{tr}} - (3G+H)\\Delta\\gamma \\right]^{m-1}\n$$\n代入 $f_{\\mathrm{tr}} = \\sigma_{\\mathrm{eq},\\mathrm{tr}} - (\\sigma_{\\mathrm{y}0} + H\\,\\varepsilon_{\\mathrm{p},n}^{\\mathrm{eq}})$ 得到 Jacobian 的完整表达式：\n$$\nJ(\\Delta\\gamma) = 1 + \\frac{m\\,\\Delta t\\,(3G+H)}{\\eta_{\\mathrm{v}}\\,\\sigma_{0}^{m}} \\left[ \\sigma_{\\mathrm{eq},\\mathrm{tr}} - (\\sigma_{\\mathrm{y}0} + H\\,\\varepsilon_{\\mathrm{p},n}^{\\mathrm{eq}}) - (3G+H)\\Delta\\gamma \\right]^{m-1}\n$$\n因此，Newton-Raphson 迭代被完全定义。\n\n对于初始猜测值 $\\Delta\\gamma^{(0)}$，我们使用在试探状态下计算的显式预测值。这意味着我们使用试探状态下的超应力 $f_{\\mathrm{tr}}$ 来计算塑性应变率，并假设此率在时间步 $\\Delta t$ 内是恒定的：\n$$\n\\dot{\\gamma}_{\\mathrm{tr}} = \\frac{1}{\\eta_{\\mathrm{v}}} \\left\\langle \\frac{f_{\\mathrm{tr}}}{\\sigma_{0}} \\right\\rangle ^m = \\frac{1}{\\eta_{\\mathrm{v}}} \\left\\langle \\frac{\\sigma_{\\mathrm{eq},\\mathrm{tr}} - (\\sigma_{\\mathrm{y}0} + H\\,\\varepsilon_{\\mathrm{p},n}^{\\mathrm{eq}})}{\\sigma_{0}} \\right\\rangle ^m\n$$\n那么增量的初始猜测值是：\n$$\n\\Delta\\gamma^{(0)} = \\dot{\\gamma}_{\\mathrm{tr}} \\cdot \\Delta t = \\frac{\\Delta t}{\\eta_{\\mathrm{v}}} \\left\\langle \\frac{\\sigma_{\\mathrm{eq},\\mathrm{tr}} - (\\sigma_{\\mathrm{y}0} + H\\,\\varepsilon_{\\mathrm{p},n}^{\\mathrm{eq}})}{\\sigma_{0}} \\right\\rangle ^m\n$$\n\n### 第3部分：$m=1$ 的特例和数值计算\n\n对于 $m=1$ 的特殊情况，残差方程变为：\n$$\nR(\\Delta\\gamma) = \\Delta\\gamma - \\frac{\\Delta t}{\\eta_{\\mathrm{v}}\\,\\sigma_{0}} \\left[ \\sigma_{\\mathrm{eq},\\mathrm{tr}} - (\\sigma_{\\mathrm{y}0} + H\\,\\varepsilon_{\\mathrm{p},n}^{\\mathrm{eq}}) - (3G+H)\\Delta\\gamma \\right] = 0\n$$\n这是一个关于 $\\Delta\\gamma$ 的线性方程。我们可以直接求解而无需迭代。将包含 $\\Delta\\gamma$ 的项组合在一起：\n$$\n\\Delta\\gamma \\left( 1 + \\frac{\\Delta t (3G+H)}{\\eta_{\\mathrm{v}}\\,\\sigma_{0}} \\right) = \\frac{\\Delta t}{\\eta_{\\mathrm{v}}\\,\\sigma_{0}} \\left[ \\sigma_{\\mathrm{eq},\\mathrm{tr}} - (\\sigma_{\\mathrm{y}0} + H\\,\\varepsilon_{\\mathrm{p},n}^{\\mathrm{eq}}) \\right]\n$$\n$\\Delta\\gamma$ 的精确解是：\n$$\n\\Delta\\gamma = \\frac{\\frac{\\Delta t}{\\eta_{\\mathrm{v}}\\,\\sigma_{0}} \\left[ \\sigma_{\\mathrm{eq},\\mathrm{tr}} - (\\sigma_{\\mathrm{y}0} + H\\,\\varepsilon_{\\mathrm{p},n}^{\\mathrm{eq}}) \\right]}{1 + \\frac{\\Delta t (3G+H)}{\\eta_{\\mathrm{v}}\\,\\sigma_{0}}}\n$$\n现在，我们代入给定的数值：\n$\\sigma_{\\mathrm{eq},\\mathrm{tr}}=500$, $\\sigma_{\\mathrm{y}0}=250$, $H=1000$, $G=30000$, $\\varepsilon_{\\mathrm{p},n}^{\\mathrm{eq}}=0.05$, $\\eta_{\\mathrm{v}}=10$, $\\sigma_{0}=100$, and $\\Delta t=0.5$。所有应力和模量的值都以 MPa 为单位。\n\n首先，计算时间 $t_n$ 时的屈服应力：\n$$\n\\sigma_{\\mathrm{y},n} = \\sigma_{\\mathrm{y}0} + H\\,\\varepsilon_{\\mathrm{p},n}^{\\mathrm{eq}} = 250 + 1000 \\times 0.05 = 250 + 50 = 300\\,\\mathrm{MPa}\n$$\n试探超应力是：\n$$\nf_{\\mathrm{tr}} = \\sigma_{\\mathrm{eq},\\mathrm{tr}} - \\sigma_{\\mathrm{y},n} = 500 - 300 = 200\\,\\mathrm{MPa}\n$$\n由于 $f_{\\mathrm{tr}} > 0$，发生塑性流动。我们现在可以计算求解 $\\Delta\\gamma$ 的各项。\n分子是：\n$$\n\\frac{\\Delta t}{\\eta_{\\mathrm{v}}\\,\\sigma_{0}} f_{\\mathrm{tr}} = \\frac{0.5}{10 \\times 100} \\times 200 = \\frac{100}{1000} = 0.1\n$$\n分母求和中的项是：\n$$\n\\frac{\\Delta t (3G+H)}{\\eta_{\\mathrm{v}}\\,\\sigma_{0}} = \\frac{0.5 \\times (3 \\times 30000 + 1000)}{10 \\times 100} = \\frac{0.5 \\times (90000 + 1000)}{1000} = \\frac{0.5 \\times 91000}{1000} = \\frac{45500}{1000} = 45.5\n$$\n分母是 $1 + 45.5 = 46.5$。\n\n最后，$\\Delta\\gamma$ 的值是：\n$$\n\\Delta\\gamma = \\frac{0.1}{46.5} = \\frac{1}{465} \\approx 0.0021505376...\n$$\n四舍五入到四位有效数字，我们得到 $\\Delta\\gamma = 0.002151$。用标准科学记数法表示：$2.151 \\times 10^{-3}$。",
            "answer": "$$\\boxed{2.151 \\times 10^{-3}}$$"
        },
        {
            "introduction": "虽然返回映射算法能够正确更新材料状态，但在全局有限元分析中实现高效收敛则需要一致的切线刚度矩阵。本练习将重点推导该矩阵的关键组成部分：一致算法切线模量（CATM）。通过对我们隐式更新方案中的离散本构方程进行微分，你将揭示应力增量和应变增量之间的精确关系，这是全局牛顿-拉夫逊求解器实现二次收敛性的关键要素。",
            "id": "3609461",
            "problem": "考虑一个一维、小应变的线性弹粘塑性固体，其应变可加和分解，总应变 $ \\varepsilon $ 分解为弹性应变 $ \\varepsilon^{e} $ 和粘塑性应变 $ \\varepsilon^{p} $，满足 $ \\varepsilon = \\varepsilon^{e} + \\varepsilon^{p} $。应力 $ \\sigma $ 遵循胡克定律 $ \\sigma = E \\varepsilon^{e} $，其中 $ E $ 为杨氏模量。该材料表现出硬化模量为 $ H $ 的线性各向同性硬化，并服从具有线性超应力规律的 Perzyna 型粘塑性流动法则，其形式由下式给出\n$$\n\\dot{\\varepsilon}^{p} = \\frac{1}{\\eta} \\left\\langle f(\\sigma, \\varepsilon^{p}) \\right\\rangle,\n$$\n其中 $ \\eta $ 是一个粘度参数，$ \\left\\langle x \\right\\rangle = \\max(x, 0) $ 表示取正函数。假设为单调拉伸加载，使得屈服函数简化为\n$$\nf(\\sigma, \\varepsilon^{p}) = \\sigma - \\sigma_{y} - H \\varepsilon^{p},\n$$\n其中 $ \\sigma_{y} $ 是初始屈服应力。使用后向欧拉格式在一个均匀的时间步长 $ \\Delta t $ 上对粘塑性流动进行时间离散化，得到\n$$\n\\varepsilon_{n+1}^{p} = \\varepsilon_{n}^{p} + \\Delta t \\, \\frac{1}{\\eta} \\left\\langle f(\\sigma_{n+1}, \\varepsilon_{n+1}^{p}) \\right\\rangle,\n$$\n且 $ \\sigma_{n+1} = E \\left( \\varepsilon_{n+1} - \\varepsilon_{n+1}^{p} \\right) $。假设在该时间步结束时发生粘塑性加载，即 $ f(\\sigma_{n+1}, \\varepsilon_{n+1}^{p})  0 $，因此取正算子是激活的。定义一致性算法切线模量 (CATM) 为\n$$\n\\mathbb{C}_{\\text{alg}} = \\frac{\\mathrm{d} \\sigma_{n+1}}{\\mathrm{d} \\varepsilon_{n+1}},\n$$\n这是对离散化的一维边值问题进行牛顿型求解时，为获得二次收敛性所需要的雅可比矩阵。\n\n仅从给定的本构假设和后向欧拉离散化出发，在给定的粘塑性加载条件下，推导 $ \\mathbb{C}_{\\text{alg}} $ 的封闭形式表达式。将最终结果明确地表示为 $ E $、$ H $、$ \\Delta t $ 和 $ \\eta $ 的函数。最终答案必须是单个解析表达式。不需要进行数值计算，最终方框内的表达式不应包含单位。",
            "solution": "### 一致性算法切线模量的推导\n\n目标是推导 $\\mathbb{C}_{\\text{alg}} = \\frac{\\mathrm{d} \\sigma_{n+1}}{\\mathrm{d} \\varepsilon_{n+1}}$ 的表达式。这需要将时间步结束时总应变的无穷小变化 $\\mathrm{d} \\varepsilon_{n+1}$ 与其对应的应力的无穷小变化 $\\mathrm{d} \\sigma_{n+1}$ 关联起来。\n\n时间步开始时的状态由 $\\varepsilon_{n}^{p}$ 表示，被视为一个固定的历史变量。时间步结束时的总应变 $\\varepsilon_{n+1}$ 是独立的驱动变量。时间步结束时的内变量 $\\sigma_{n+1}$ 和 $\\varepsilon_{n+1}^{p}$ 是 $\\varepsilon_{n+1}$ 的函数。\n\n首先，我们写出从时间步 $t_n$ 到 $t_{n+1}$ 的离散控制方程。\n应力-应变关系由下式给出：\n$$\n\\sigma_{n+1} = E \\left( \\varepsilon_{n+1} - \\varepsilon_{n+1}^{p} \\right)\n$$\n后向欧拉离散化的流动法则是：\n$$\n\\varepsilon_{n+1}^{p} = \\varepsilon_{n}^{p} + \\Delta t \\, \\frac{1}{\\eta} \\left\\langle f(\\sigma_{n+1}, \\varepsilon_{n+1}^{p}) \\right\\rangle\n$$\n问题指明发生了粘塑性加载，这意味着 $f(\\sigma_{n+1}, \\varepsilon_{n+1}^{p}) > 0$。在此条件下，Macaulay 括号 $\\langle \\cdot \\rangle$ 不起作用，流动法则简化为：\n$$\n\\varepsilon_{n+1}^{p} = \\varepsilon_{n}^{p} + \\frac{\\Delta t}{\\eta} \\left( \\sigma_{n+1} - \\sigma_{y} - H \\varepsilon_{n+1}^{p} \\right)\n$$\n为了找到微分量 $\\mathrm{d}\\sigma_{n+1}$ 和 $\\mathrm{d}\\varepsilon_{n+1}$ 之间的关系，我们可以对控制方程取全微分。\n从应力-应变关系可得：\n$$\n\\mathrm{d}\\sigma_{n+1} = E \\left( \\mathrm{d}\\varepsilon_{n+1} - \\mathrm{d}\\varepsilon_{n+1}^{p} \\right) \\quad (* )\n$$\n从简化的流动法则，我们注意到 $\\varepsilon_{n}^{p}$ 和 $\\sigma_{y}$ 相对于当前增量是常数，因此它们的微分为零：\n$$\n\\mathrm{d}\\varepsilon_{n+1}^{p} = \\frac{\\Delta t}{\\eta} \\left( \\mathrm{d}\\sigma_{n+1} - H \\mathrm{d}\\varepsilon_{n+1}^{p} \\right)\n$$\n我们可以重排此方程，将 $\\mathrm{d}\\varepsilon_{n+1}^{p}$ 表示为 $\\mathrm{d}\\sigma_{n+1}$ 的函数：\n$$\n\\mathrm{d}\\varepsilon_{n+1}^{p} + \\frac{H \\Delta t}{\\eta} \\mathrm{d}\\varepsilon_{n+1}^{p} = \\frac{\\Delta t}{\\eta} \\mathrm{d}\\sigma_{n+1}\n$$\n$$\n\\mathrm{d}\\varepsilon_{n+1}^{p} \\left( 1 + \\frac{H \\Delta t}{\\eta} \\right) = \\frac{\\Delta t}{\\eta} \\mathrm{d}\\sigma_{n+1}\n$$\n解出 $\\mathrm{d}\\varepsilon_{n+1}^{p}$：\n$$\n\\mathrm{d}\\varepsilon_{n+1}^{p} = \\frac{\\frac{\\Delta t}{\\eta}}{1 + \\frac{H \\Delta t}{\\eta}} \\mathrm{d}\\sigma_{n+1} = \\frac{\\Delta t}{\\eta + H \\Delta t} \\mathrm{d}\\sigma_{n+1} \\quad (**)\n$$\n这个方程将粘塑性应变增量与应力增量关联起来。现在，我们将此结果代回到微分后的应力-应变关系式 (*) 中：\n$$\n\\mathrm{d}\\sigma_{n+1} = E \\left( \\mathrm{d}\\varepsilon_{n+1} - \\left( \\frac{\\Delta t}{\\eta + H \\Delta t} \\right) \\mathrm{d}\\sigma_{n+1} \\right)\n$$\n我们的目标是求出比率 $\\frac{\\mathrm{d}\\sigma_{n+1}}{\\mathrm{d}\\varepsilon_{n+1}}$。我们通过收集包含 $\\mathrm{d}\\sigma_{n+1}$ 的项来继续：\n$$\n\\mathrm{d}\\sigma_{n+1} + E \\left( \\frac{\\Delta t}{\\eta + H \\Delta t} \\right) \\mathrm{d}\\sigma_{n+1} = E \\, \\mathrm{d}\\varepsilon_{n+1}\n$$\n$$\n\\mathrm{d}\\sigma_{n+1} \\left( 1 + \\frac{E \\Delta t}{\\eta + H \\Delta t} \\right) = E \\, \\mathrm{d}\\varepsilon_{n+1}\n$$\n一致性算法切线模量 $\\mathbb{C}_{\\text{alg}}$ 定义为该比率：\n$$\n\\mathbb{C}_{\\text{alg}} = \\frac{\\mathrm{d}\\sigma_{n+1}}{\\mathrm{d}\\varepsilon_{n+1}} = \\frac{E}{1 + \\frac{E \\Delta t}{\\eta + H \\Delta t}}\n$$\n为了简化此表达式，我们对分母中的项进行通分：\n$$\n\\mathbb{C}_{\\text{alg}} = \\frac{E}{\\frac{(\\eta + H \\Delta t) + E \\Delta t}{\\eta + H \\Delta t}}\n$$\n将分母中的分数取倒数，得到一致性算法切线模量的最终表达式：\n$$\n\\mathbb{C}_{\\text{alg}} = \\frac{E (\\eta + H \\Delta t)}{\\eta + H \\Delta t + E \\Delta t}\n$$\n通过组合乘以 $\\Delta t$ 的项，这可以更紧凑地写成：\n$$\n\\mathbb{C}_{\\text{alg}} = \\frac{E (\\eta + H \\Delta t)}{\\eta + (E + H) \\Delta t}\n$$\n此表达式仅依赖于材料参数 $E$、$H$、$\\eta$ 和时间步长 $\\Delta t$，正如问题陈述所要求的。",
            "answer": "$$\\boxed{\\frac{E (\\eta + H \\Delta t)}{\\eta + (E + H) \\Delta t}}$$"
        },
        {
            "introduction": "现在，让我们将所有部分整合起来，为一个粘塑性杆构建一个完整的有限元模拟。本练习将从单点推导过渡到求解一个完整的边值问题。你将在一个全局牛顿-拉夫逊框架内，实现之前推导的局部本构更新和一致切线模量，并用它来分析网格尺寸、时间步长以及切线公式等因素如何影响模拟的稳定性和收敛速度。",
            "id": "3609471",
            "problem": "您的任务是使用 Perzyna 超应力正则化方法，为一个率相关的弹粘塑性杆实现一维有限元方法，并进行网格细化研究，以及比较一致算法切线与非一致切线。您的程序必须在每个时间步通过牛顿法组装并求解非线性平衡问题，并且必须量化随着网格的细化和时间步长的变化，是否会出现伪振荡以及迭代是否收敛。\n\n物理模型是一个长度为 $L$、横截面积为 $A$ 的小应变一维杆，其线性弹性模量为 $E$，屈服应力为 $\\sigma_{y}$。该杆的左端 $x=0$ 被固定，右端 $x=L$ 施加了随时间变化的牵引力 $\\bar{\\sigma}(t)$。材料的粘塑性由具有幂律超应力的 Perzyna 模型控制。设总小应变为 $\\varepsilon$，粘塑性应变为 $\\varepsilon^{p}$，应力为 $\\sigma = E (\\varepsilon - \\varepsilon^{p})$。对于单调拉伸，一维屈服函数为 $f(\\sigma) = \\sigma - \\sigma_{y}$。带有幂指数 $n$ 的 Perzyna 流动法则为\n$$\n\\dot{\\varepsilon}^{p} = \\frac{1}{\\eta} \\left\\langle \\sigma - \\sigma_{y} \\right\\rangle^{n},\n$$\n其中 $\\eta$ 是类粘度参数，其单位使得 $\\dot{\\varepsilon}^{p}$ 的单位为秒的倒数，$\\langle \\cdot \\rangle$ 表示取正部分。时间离散化采用后向欧拉法。对于没有体积力且在 $x=L$ 处施加牵引力的杆，平衡的弱形式可从虚功原理得到，并产生标准的一维有限元方程。\n\n您的实现必须：\n- 将杆域 $[0,L]$ 离散化为 $N$ 个线性单元，每个单元中心有一个高斯点。使用线性形函数，使得单元应变为常数，并等于节点位移之差除以单元长度。\n- 在每个时间步，给定节点位移，计算每个单元的应变，并执行与后向欧拉法一致的粘塑性应变的局部隐式更新，求解当前时间步的应力以满足本构方程。不要假设有闭式解；推导并实现一个稳健的局部牛顿程序来求解隐式本构方程。\n- 从第一性原理推导 Perzyna 更新的一致算法切线模量（当前增量中总应力对应变的全导数，通过对局部本构方程进行隐式微分得到）。当请求一致切线时，使用此值来组装牛顿法的全局切线剛度矩阵。\n-作为比较，实现一个非一致切线选项，该选项定义为将切线冻结为弹性模量 $E$，而不论塑性流动如何（即，在牛顿迭代期间在全局切线中使用 $E$，同时仍然从粘塑性更新中计算应力）。这模拟了不使用一致切线的情况，并预期会降低收敛性，并可能在迭代残差中引发伪振荡。\n- 使用牛顿法求解每个时间步的全局平衡。非线性残差是组装的内部节点力向量与由于 $x=L$ 处的牵引力引起的外部节点力向量之差。当缩减残差（强制执行狄利克雷边界条件）的欧几里得范数小于相对于当前施加牵引力定义的容差时，即达到收敛。\n- 通过计算同一时间步内牛顿迭代之间残差范数的增加来检测牛顿过程中的伪振荡。与前一次迭代相比，残差增加超过 $5\\%$ 就算作一次振荡。如果任何时间步出现至少一次此类振荡，则该案例被标记为振荡。\n- 对于每个测试案例，返回一个布尔值，指示整个时间历史是否在没有伪振荡的情况下收敛。如果每个时间步都在固定的最大牛顿迭代次数内收敛，并且没有检测到残差振荡事件，则该布尔值为真；否则为假。\n\n基本基础和要求：\n- 运动学：$u(x,t)$ 是轴向位移；小应变为 $\\varepsilon = \\frac{\\partial u}{\\partial x}$；应力为 $\\sigma = E(\\varepsilon - \\varepsilon^{p})$。\n- 平衡的弱形式：离散的内力向量由单元贡献组装而成 $\\mathbf{f}^{\\text{int}} = \\int_{0}^{L} \\mathbf{B}^{T} \\sigma A \\, dx$，其中 $\\mathbf{B}$ 是线性单元的应变-位移矩阵，$A$ 是横截面积。\n- 时间积分：在时间步 $\\Delta t$ 上使用后向欧拉法，其中前一步的粘塑性应变为 $\\varepsilon^{p}_{n}$，当前应力为 $\\sigma_{n+1}$，以满足本构关系和流动法则。\n- 一致切线：通过对局部本构方程进行隐式微分来推导 $d\\sigma_{n+1}/d\\varepsilon_{n+1}$；当启用一致切线选项时，用此来组装牛顿法的全局切线刚度 $\\mathbf{K}$。\n- 数值解：在每个时间步，执行牛顿迭代以求解非线性系统 $\\mathbf{r}(\\mathbf{u}) = \\mathbf{f}^{\\text{int}}(\\mathbf{u}) - \\mathbf{f}^{\\text{ext}}(t) = \\mathbf{0}$，并如上所述监控残差范数和振荡。\n\n在国际单位制 (SI) 中使用以下固定的物理参数：\n- $L = 1.0$ 米, $A = 1.0$ 平方米, $E = 2.10 \\times 10^{11}$ 帕斯卡, $\\sigma_{y} = 4.00 \\times 10^{8}$ 帕斯卡,\n- Perzyna 指数 $n = 2$ (无量纲), 粘度参数 $\\eta = 1.00 \\times 10^{17}$ 帕斯卡平方秒,\n- 最终加载时间 $T_{\\text{end}} = 1.0$ 秒, 施加的牵引力斜坡 $\\bar{\\sigma}(t) = \\sigma_{\\text{max}}\\,(t/T_{\\text{end}})$ 其中 $\\sigma_{\\text{max}} = 8.00 \\times 10^{8}$ 帕斯卡。\n\n您必须实现以下参数值的测试套件，表示为元组 $(N,\\Delta t,\\text{use\\_consistent\\_tangent})$ 并应用于上述模型：\n1. $(8, 0.02, \\text{True})$ — 正常路径，中等网格，小时间步，启用一致切线。\n2. $(32, 0.02, \\text{True})$ — 网格细化，小时间步，启用一致切线。\n3. $(32, 0.50, \\text{True})$ — 细化网格，大时间步，启用一致切线以测试稳健性。\n4. $(32, 0.50, \\text{False})$ — 细化网格，大时间步，非一致切线以探究振荡和潜在的不收敛性。\n5. $(8, 0.10, \\text{False})$ — 粗糙网格，中等时间步，非一致切线以测试敏感性。\n\n对于每个测试案例，以大小为 $\\Delta t$ 的步长模拟从 $t=0$ 到 $t=T_{\\text{end}}$ 的完整时间历史。在每个时间步，求解非线性平衡，更新粘塑性应变，并跟踪收敛和残差振荡。最终输出必须是单行，包含这五个案例的布尔值列表，格式为 $[$result$_1$,result$_2$,result$_3$,result$_4$,result$_5]$，其中每个结果为 $\\text{True}$ 或 $\\text{False}$，没有空格。\n\n不允许用户输入。所有量均采用 SI 单位。不出现角度。没有概率或百分比。预期的输出类型是为上述五个测试案例聚合的布尔值列表。",
            "solution": "### 1. 控制方程和空间离散化\n\n问题涉及一个长度为 $L$ 且横截面积恒为 $A$ 的一维杆。杆在 $x=0$ 处固定，在 $x=L$ 处受到随时间变化的牵引力。忽略体积力的准静态平衡方程为：\n$$\n\\frac{\\partial \\sigma}{\\partial x} = 0\n$$\n边界条件为 $u(0,t) = 0$ (本质边界条件) 和 $\\sigma(L,t) = \\bar{\\sigma}(t)$ (自然边界条件)。\n\n弱形式由虚功原理导出。对于满足 $\\delta u(0)=0$ 的虚位移场 $\\delta u(x)$，我们有：\n$$\n\\int_{0}^{L} \\delta \\varepsilon \\sigma A \\, dx - \\left[ \\delta u A \\sigma \\right]_{x=L} = 0\n$$\n其中 $\\delta \\varepsilon = \\partial(\\delta u)/\\partial x$。代入自然边界条件 $\\sigma(L,t) = \\bar{\\sigma}(t)$ 得：\n$$\n\\int_{0}^{L} \\delta \\varepsilon \\sigma A \\, dx = \\delta u(L) A \\bar{\\sigma}(t)\n$$\n我们将域 $[0,L]$ 离散化为 $N$ 个线性有限元，每个单元长度为 $h = L/N$。位移场 $u(x)$ 被近似为分段线性的 $u^h(x)$。对于连接节点 $i$ 和 $i+1$ 的单元 $e$，其节点位移为 $u_i$ 和 $u_{i+1}$，单元内的应变 $\\varepsilon_e$ 是恒定的：\n$$\n\\varepsilon_e = \\frac{u_{i+1} - u_i}{h}\n$$\n这可以使用应变-位移矩阵 $\\mathbf{B}_e = \\frac{1}{h}[-1, 1]$ 和单元节点位移向量 $\\mathbf{u}_e = [u_i, u_{i+1}]^T$ 写成 $\\varepsilon_e = \\mathbf{B}_e \\mathbf{u}_e$。\n\n将离散化场代入弱形式，得到全局非线性代数方程组：\n$$\n\\mathbf{f}^{\\text{int}}(\\mathbf{u}) = \\mathbf{f}^{\\text{ext}}(t)\n$$\n其中 $\\mathbf{u}$ 是节点位移的全局向量。外力向量 $\\mathbf{f}^{\\text{ext}}$ 只有一个非零分量，位于对应于 $x=L$ 的节点（节点 $N$）：$F^{\\text{ext}}_{N} = A \\bar{\\sigma}(t)$。全局内力向量 $\\mathbf{f}^{\\text{int}}$ 由单元贡献 $\\mathbf{f}^{\\text{int}}_e$ 组装而成：\n$$\n\\mathbf{f}^{\\text{int}}_e = \\int_{\\Omega_e} \\mathbf{B}_e^T \\sigma_e A \\, dx = \\mathbf{B}_e^T \\sigma_e A h = \\frac{1}{h} \\begin{bmatrix} -1 \\\\ 1 \\end{bmatrix} \\sigma_e A h = A \\sigma_e \\begin{bmatrix} -1 \\\\ 1 \\end{bmatrix}\n$$\n其中 $\\sigma_e$ 是单元 $e$ 中的应力。\n\n### 2. 本构模型和时间离散化\n\n总应变 $\\varepsilon$ 被加法分解为弹性部分 $\\varepsilon^e$ 和粘塑性部分 $\\varepsilon^p$。应力 $\\sigma$ 通过胡克定律与弹性应变相关：\n$$\n\\sigma = E \\varepsilon^e = E(\\varepsilon - \\varepsilon^p)\n$$\n粘塑性应变的演化由具有幂律的 Perzyna 模型控制：\n$$\n\\dot{\\varepsilon}^p = \\frac{1}{\\eta} \\langle \\sigma - \\sigma_y \\rangle^n\n$$\n其中 $\\sigma_y$ 是屈服应力，$\\eta$ 是粘度参数，$n$ 是幂律指数，$\\langle x \\rangle = \\max(0, x)$。\n\n我们使用后向欧拉法进行时间积分，时间步长为 $\\Delta t = t_{n+1} - t_n$。流动法则变为：\n$$\n\\frac{\\varepsilon^p_{n+1} - \\varepsilon^p_n}{\\Delta t} = \\frac{1}{\\eta} \\langle \\sigma_{n+1} - \\sigma_y \\rangle^n\n$$\n这给出了该步结束时粘塑性应变的表达式：\n$$\n\\varepsilon^p_{n+1} = \\varepsilon^p_n + \\frac{\\Delta t}{\\eta} \\langle \\sigma_{n+1} - \\sigma_y \\rangle^n\n$$\n将此代入时间 $t_{n+1}$ 的应力-应变关系中得到：\n$$\n\\sigma_{n+1} = E \\left(\\varepsilon_{n+1} - \\varepsilon^p_{n+1}\\right) = E \\left( \\varepsilon_{n+1} - \\varepsilon^p_n - \\frac{\\Delta t}{\\eta} \\langle \\sigma_{n+1} - \\sigma_y \\rangle^n \\right)\n$$\n这是一个关于未知应力 $\\sigma_{n+1}$ 的非线性标量方程，给定总应变 $\\varepsilon_{n+1}$ 和上一步的状态变量 $\\varepsilon^p_n$。\n\n### 3. 局部本构求解器\n\n对于每个单元（高斯点），给定 $\\varepsilon_{n+1}$ 和 $\\varepsilon^p_n$，我们必须求解 $\\sigma_{n+1}$。我们定义一个试探弹性应力，它假设增量期间没有塑性流动：\n$$\n\\sigma^{\\text{trial}} = E(\\varepsilon_{n+1} - \\varepsilon^p_n)\n$$\n如果 $\\sigma^{\\text{trial}} \\le \\sigma_y$，则不发生粘塑性流动。麦考利括号为零，因此 $\\sigma_{n+1} = \\sigma^{\\text{trial}}$ 且 $\\varepsilon^p_{n+1} = \\varepsilon^p_n$。更新是纯弹性的。\n\n如果 $\\sigma^{\\text{trial}} > \\sigma_y$，则发生粘塑性流动，我们必须解非线性方程。我们定义一个局部残差函数 $g(\\sigma_{n+1})$：\n$$\ng(\\sigma_{n+1}) = \\sigma_{n+1} - \\sigma^{\\text{trial}} + \\frac{E \\Delta t}{\\eta} (\\sigma_{n+1} - \\sigma_y)^n = 0\n$$\n我们使用局部牛顿-拉夫逊法求解此方程，以获得 $\\sigma_{n+1} > \\sigma_y$。迭代更新为：\n$$\n\\sigma^{(k+1)} = \\sigma^{(k)} - \\frac{g(\\sigma^{(k)})}{g'(\\sigma^{(k)})}\n$$\n其中导数 $g'(\\sigma)$ 为：\n$$\ng'(\\sigma) = \\frac{dg}{d\\sigma} = 1 + \\frac{E \\Delta t}{\\eta} n (\\sigma - \\sigma_y)^{n-1}\n$$\n迭代从 $\\sigma^{(0)} = \\sigma^{\\text{trial}}$ 开始，直到 $|g(\\sigma^{(k)})|$ 低于某个容差。\n\n### 4. 一致算法切线模量\n\n为了全局牛顿-拉夫逊方法的二次收敛性，切线刚度矩阵必须基于一致算法切线模量 $C^{\\text{alg}} = d\\sigma_{n+1}/d\\varepsilon_{n+1}$。这通过对局部残差方程 $g(\\sigma_{n+1}, \\varepsilon_{n+1}) = 0$ 进行隐式微分来推导，其中我们现在通过 $\\sigma^{\\text{trial}}$ 明确显示其对 $\\varepsilon_{n+1}$ 的依赖性。\n$$\ng(\\sigma_{n+1}, \\varepsilon_{n+1}) = \\sigma_{n+1} - E(\\varepsilon_{n+1} - \\varepsilon^p_n) + \\frac{E \\Delta t}{\\eta} \\langle \\sigma_{n+1} - \\sigma_y \\rangle^n = 0\n$$\n全微分等于零：$dg = \\frac{\\partial g}{\\partial \\sigma_{n+1}}d\\sigma_{n+1} + \\frac{\\partial g}{\\partial \\varepsilon_{n+1}}d\\varepsilon_{n+1} = 0$。这给出：\n$$\nC^{\\text{alg}} = \\frac{d\\sigma_{n+1}}{d\\varepsilon_{n+1}} = - \\left( \\frac{\\partial g}{\\partial \\sigma_{n+1}} \\right)^{-1} \\frac{\\partial g}{\\partial \\varepsilon_{n+1}}\n$$\n偏导数是：\n$$\n\\frac{\\partial g}{\\partial \\sigma_{n+1}} = 1 + \\frac{E \\Delta t}{\\eta} n \\langle \\sigma_{n+1} - \\sigma_y \\rangle^{n-1} \\cdot H(\\sigma_{n+1} - \\sigma_y)\n$$\n其中 $H$ 是亥维赛阶跃函数。\n$$\n\\frac{\\partial g}{\\partial \\varepsilon_{n+1}} = -E\n$$\n如果步长是弹性的（$\\sigma_{n+1} \\le \\sigma_y$），亥维赛函数为零，且 $C^{\\text{alg}} = - (1)^{-1} (-E) = E$。\n如果步长是粘塑性的（$\\sigma_{n+1} > \\sigma_y$），亥维赛函数为一，我们得到：\n$$\nC^{\\text{alg}} = \\frac{E}{1 + \\frac{E \\Delta t}{\\eta} n (\\sigma_{n+1} - \\sigma_y)^{n-1}}\n$$\n非一致切线选项是简单地在所有情况下使用 $C^{\\text{alg}} = E$。\n\n### 5. 全局牛顿-拉夫逊算法\n\n在每个时间步 $t_{n+1}$，我们求解非线性全局系统 $\\mathbf{r}(\\mathbf{u}_{n+1}) = \\mathbf{f}^{\\text{int}}(\\mathbf{u}_{n+1}) - \\mathbf{f}^{\\text{ext}}_{n+1} = \\mathbf{0}$ 以获得位移向量 $\\mathbf{u}_{n+1}$。牛顿-拉夫逊迭代为：\n$$\n\\mathbf{u}^{(k+1)} = \\mathbf{u}^{(k)} - [\\mathbf{K}_T^{(k)}]^{-1} \\mathbf{r}^{(k)}\n$$\n其中 $\\mathbf{r}^{(k)} = \\mathbf{r}(\\mathbf{u}^{(k)})$ 是残差向量，$\\mathbf{K}_T^{(k)} = \\frac{d\\mathbf{f}^{\\text{int}}}{d\\mathbf{u}} |_{\\mathbf{u}^{(k)}}$ 是全局切线刚度矩阵。\n\n单元切线刚度矩阵 $\\mathbf{K}_{T,e}$ 是：\n$$\n\\mathbf{K}_{T,e} = \\frac{d\\mathbf{f}^{\\text{int}}_e}{d\\mathbf{u}_e} = \\frac{d}{d\\mathbf{u}_e} \\left( A \\sigma_e \\begin{bmatrix} -1 \\\\ 1 \\end{bmatrix} \\right) = A \\begin{bmatrix} -1 \\\\ 1 \\end{bmatrix} \\frac{d\\sigma_e}{d\\mathbf{u}_e}\n$$\n使用链式法则，$\\frac{d\\sigma_e}{d\\mathbf{u}_e} = \\frac{d\\sigma_e}{d\\varepsilon_e} \\frac{d\\varepsilon_e}{d\\mathbf{u}_e} = C^{\\text{alg}}_e \\mathbf{B}_e$。\n$$\n\\mathbf{K}_{T,e} = A \\begin{bmatrix} -1 \\\\ 1 \\end{bmatrix} C^{\\text{alg}}_e \\mathbf{B}_e = A C^{\\text{alg}}_e \\begin{bmatrix} -1 \\\\ 1 \\end{bmatrix} \\frac{1}{h} [-1, 1] = \\frac{A C^{\\text{alg}}_e}{h} \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix}\n$$\n一个时间步的完整算法如下：\n1. 初始化 $\\mathbf{u}^{(0)} = \\mathbf{u}_n$。\n2. 对于 $k=0, 1, 2, ...$:\n    a. 对于每个单元 $e$，从 $\\mathbf{u}_e^{(k)}$ 计算 $\\varepsilon_e^{(k)}$。\n    b. 执行局部本构更新以找到 $\\sigma_e^{(k)}$ 和 $C^{\\text{alg},(k)}_e$。\n    c. 组装全局内力向量 $\\mathbf{f}^{\\text{int},(k)}$ 和切线刚度矩阵 $\\mathbf{K}_T^{(k)}$。\n    d. 计算残差 $\\mathbf{r}^{(k)} = \\mathbf{f}^{\\text{int},(k)} - \\mathbf{f}^{\\text{ext}}_{n+1}$。\n    e. 应用位移边界条件（为 $u_0=0$ 修改 $\\mathbf{r}^{(k)}$ 和 $\\mathbf{K}_T^{(k)}$）。\n    f. 通过将缩减残差的范数与容差进行比较来检查收敛性。如果收敛，则跳出循环。\n    g. 检查残差振荡。如果检测到振荡，则设置一个标志。\n    h. 求解线性系统 $\\mathbf{K}_T^{(k)} \\Delta\\mathbf{u}^{(k)} = -\\mathbf{r}^{(k)}$。\n    i. 更新位移：$\\mathbf{u}^{(k+1)} = \\mathbf{u}^{(k)} + \\Delta\\mathbf{u}^{(k)}$。\n3. 如果牛顿循环收敛，则使用收敛解 $\\mathbf{u}_{n+1}$ 更新所有单元的塑性应变状态变量 $\\varepsilon^p_{n+1, e}$。\n4. 进行到下一个时间步。\n\n一个测试案例当且仅当每个时间步都在固定的最大迭代次数内收敛，并且在整个模拟过程中没有检测到残差振荡（范数增加 $>5\\%$）时，才被视为成功（True）。\n\n```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the 1D viscoplastic bar problem.\n    \"\"\"\n\n    def local_constitutive_update(eps_total, ep_p_n, E, sigma_y, eta, n, dt, use_consistent):\n        \"\"\"\n        Performs the local constitutive update (return mapping) for one Gauss point.\n        Solves for stress and provides the algorithmic tangent modulus.\n        \"\"\"\n        sigma_trial = E * (eps_total - ep_p_n)\n        \n        if sigma_trial = sigma_y:\n            # Elastic step\n            sigma_new = sigma_trial\n            ep_p_new = ep_p_n\n            C_alg = E\n            return sigma_new, C_alg, ep_p_new\n\n        # Viscoplastic step: solve for sigma_new using local Newton-Raphson\n        sigma_k = sigma_trial\n        local_tol = 1e-12\n        max_local_iter = 15\n\n        for _ in range(max_local_iter):\n            if sigma_k = sigma_y:\n                sigma_k = sigma_y + 1e-6 * sigma_y\n            \n            overstress = sigma_k - sigma_y\n            g = sigma_k - sigma_trial + (E * dt / eta) * (overstress**n)\n            \n            if abs(g)  local_tol:\n                break\n                \n            g_prime = 1.0 + (E * dt / eta) * n * (overstress**(n - 1))\n            if abs(g_prime)  1e-12: # Avoid division by zero\n                break\n            sigma_k -= g / g_prime\n        \n        sigma_new = sigma_k\n        \n        # Calculate new plastic strain\n        overstress_final = max(0, sigma_new - sigma_y)\n        ep_p_new = ep_p_n + (dt / eta) * (overstress_final**n)\n        \n        # Calculate algorithmic tangent modulus\n        if use_consistent:\n            denominator = 1.0 + (E * dt / eta) * n * (max(0, sigma_new - sigma_y)**(n - 1))\n            C_alg = E / denominator\n        else:\n            C_alg = E\n            \n        return sigma_new, C_alg, ep_p_new\n\n    def run_test_case(N, dt, use_consistent_tangent):\n        \"\"\"\n        Runs a single simulation case for the given parameters.\n        \"\"\"\n        # Physical parameters (SI units)\n        L = 1.0\n        A = 1.0\n        E = 2.10e11\n        sigma_y = 4.00e8\n        n = 2.0\n        eta = 1.00e17\n        T_end = 1.0\n        sigma_max = 8.00e8\n\n        # Numerical parameters\n        max_newton_iter = 25\n        newton_tol_factor = 1e-8\n        oscillation_factor = 1.05\n\n        # Mesh setup\n        h = L / N\n        num_nodes = N + 1\n\n        # State variables\n        u = np.zeros(num_nodes)\n        ep_p = np.zeros(N)  # One plastic strain per element\n\n        # Result flags\n        all_steps_converged = True\n        no_oscillations = True\n\n        num_time_steps = int(round(T_end / dt))\n        time_points = np.linspace(dt, T_end, num_time_steps)\n\n        for t_current in time_points:\n            f_ext_val = sigma_max * (t_current / T_end) * A\n            f_ext = np.zeros(num_nodes)\n            f_ext[N] = f_ext_val\n            \n            conv_tol = max(newton_tol_factor * abs(f_ext_val), 1e-8)\n\n            u_k = u.copy()\n            \n            prev_res_norm = float('inf')\n            step_converged = False\n            \n            for k_iter in range(max_newton_iter):\n                f_int = np.zeros(num_nodes)\n                K_T = np.zeros((num_nodes, num_nodes))\n                \n                sigma_elements = np.zeros(N)\n                ep_p_new_elements = np.zeros(N)\n\n                # Assembly loop\n                for e in range(N):\n                    eps_total_e = (u_k[e + 1] - u_k[e]) / h\n                    \n                    sigma_e, C_alg_e, ep_p_new_e = local_constitutive_update(\n                        eps_total_e, ep_p[e], E, sigma_y, eta, n, dt, use_consistent_tangent\n                    )\n                    \n                    sigma_elements[e] = sigma_e\n                    ep_p_new_elements[e] = ep_p_new_e\n                    \n                    f_int[e] -= A * sigma_e\n                    f_int[e + 1] += A * sigma_e\n\n                    k_e_mat = (A * C_alg_e / h) * np.array([[1, -1], [-1, 1]])\n                    K_T[e:e+2, e:e+2] += k_e_mat\n                \n                res = f_int - f_ext\n\n                res_bc = res.copy()\n                K_T_bc = K_T.copy()\n                res_bc[0] = 0.0\n                K_T_bc[0, :] = 0.0\n                K_T_bc[:, 0] = 0.0\n                K_T_bc[0, 0] = 1.0\n\n                res_norm = np.linalg.norm(res_bc[1:])\n                if res_norm  conv_tol:\n                    step_converged = True\n                    break\n\n                if k_iter > 0 and res_norm > oscillation_factor * prev_res_norm:\n                    no_oscillations = False\n                prev_res_norm = res_norm\n\n                try:\n                    delta_u = np.linalg.solve(K_T_bc, -res_bc)\n                except np.linalg.LinAlgError:\n                    all_steps_converged = False\n                    break\n                \n                u_k += delta_u\n            \n            if not step_converged:\n                all_steps_converged = False\n            \n            if not all_steps_converged or not no_oscillations:\n                break \n\n            u = u_k\n            ep_p = ep_p_new_elements\n        \n        return all_steps_converged and no_oscillations\n\n    test_cases = [\n        (8, 0.02, True),\n        (32, 0.02, True),\n        (32, 0.50, True),\n        (32, 0.50, False),\n        (8, 0.10, False)\n    ]\n\n    results = []\n    for case in test_cases:\n        N, dt, use_consistent_tangent = case\n        result = run_test_case(N, dt, use_consistent_tangent)\n        results.append(result)\n        \n    return f\"[{','.join(map(lambda x: str(x).lower(), results))}]\"\n\n# The final answer is the result of executing the solve function.\n# Expected output based on numerical methods theory:\n# 1. (8, 0.02, True): Should converge well. True.\n# 2. (32, 0.02, True): Finer mesh, should converge well. True.\n# 3. (32, 0.50, True): Large time step, but consistent tangent should handle it. True.\n# 4. (32, 0.50, False): Large time step and inconsistent tangent will likely lead to oscillations or non-convergence. False.\n# 5. (8, 0.10, False): Inconsistent tangent will likely cause issues. False.\n# So, the expected result is [true,true,true,false,false].\n```",
            "answer": "[true,true,true,false,false]"
        }
    ]
}