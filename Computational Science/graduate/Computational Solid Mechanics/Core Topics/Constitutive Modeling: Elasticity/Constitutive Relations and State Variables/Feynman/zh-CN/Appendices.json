{
    "hands_on_practices": [
        {
            "introduction": "本构关系的一个不可违背的基本要求是材料框架无差异性，也即客观性。这意味着材料的响应必须独立于观察者的刚体运动。本练习将引导你设计一个计算测试，通过叠加一个时变的刚体转动来检验一个本构算法是否满足客观性，并观察非客观模型如何产生伪应力 。这个实践将帮助你深刻理解为何必须使用客观应力率或基于势函数的公式来构建本构模型。",
            "id": "3552853",
            "problem": "您接到的指令是为固体力学中的本构算法设计并实现一个材料框架无差异性（客观性）的计算测试。该测试必须依赖于叠加的含时刚体转动，并通过比较应力响应来检测是否违背客观性。这项工作必须基于已确立的原理和定义，所有计算和输出都必须以数学上精确的术语表示。\n\n从以下基本基础开始：\n- 材料框架无差异性（客观性）指出，本构律的响应在叠加刚体运动下必须保持不变。特别地，对于满足 $\\boldsymbol{R}(t)^{\\mathsf{T}}\\boldsymbol{R}(t)=\\boldsymbol{I}$ 的正交转动张量 $\\boldsymbol{R}(t)$，变换后的 Cauchy 应力必须与旋转下的正确张量变换相一致。\n- 变形梯度为 $\\boldsymbol{F}(t)$，速度梯度定义为 $\\boldsymbol{L}(t) = \\dot{\\boldsymbol{F}}(t)\\boldsymbol{F}(t)^{-1}$。\n- 变形率张量为 $\\boldsymbol{D}(t) = \\frac{1}{2}\\left(\\boldsymbol{L}(t) + \\boldsymbol{L}(t)^{\\mathsf{T}}\\right)$，自旋张量为 $\\boldsymbol{W}(t) = \\frac{1}{2}\\left(\\boldsymbol{L}(t) - \\boldsymbol{L}(t)^{\\mathsf{T}}\\right)$。\n- 应用于运动的叠加刚体转动表示为 $\\tilde{\\boldsymbol{F}}(t) = \\boldsymbol{R}(t)\\boldsymbol{F}(t)$。\n\n您的任务是实现两种本构算法和一个计算测试，该测试通过将叠加含时转动下的应力历史与经过适当旋转的原始应力历史进行比较来检验客观性。该测试必须使用明确定义的误差度量，并产生指示通过或失败的布尔值输出。\n\n需要实现的本构算法：\n1. 超弹性算法 H（可压缩 Neo-Hookean）：\n   - 令 $\\mu > 0$ 和 $\\kappa > 0$ 为材料参数。定义 $\\boldsymbol{b}(t) = \\boldsymbol{F}(t)\\boldsymbol{F}(t)^{\\mathsf{T}}$ 及 $J(t) = \\det\\left(\\boldsymbol{F}(t)\\right)$。\n   - Cauchy 应力为\n     $$\\boldsymbol{\\sigma}_{\\mathrm{H}}(t) = \\frac{\\mu}{J(t)}\\left(\\boldsymbol{b}(t) - \\boldsymbol{I}\\right) + \\kappa\\left(J(t) - 1\\right)\\boldsymbol{I}.$$\n2. 次弹性算法 S（使用完整速度梯度的非客观线性应力率）：\n   - 令 $\\lambda > 0$ 和 $\\mu > 0$ 为参数（Lamé 型）。应力率为\n     $$\\dot{\\boldsymbol{\\sigma}}_{\\mathrm{S}}(t) = \\lambda\\,\\operatorname{tr}\\!\\left(\\boldsymbol{L}(t)\\right)\\boldsymbol{I} + 2\\mu\\,\\boldsymbol{L}(t).$$\n   - 使用显式前向欧拉法在指定的时间网格上进行时间积分，初始条件为 $\\boldsymbol{\\sigma}_{\\mathrm{S}}(0) = \\boldsymbol{0}$，时间步长为均匀的 $\\Delta t$。\n\n转动和运动：\n- 刚体转动是围绕 $z$ 轴进行的，转动角为 $\\theta(t)$（以弧度为单位），其中 $\\theta(t) = \\theta_{0} t + a \\sin\\left(2\\pi t/T\\right)$，转动张量为\n  $$\\boldsymbol{R}(t) = \\begin{bmatrix}\n  \\cos\\theta(t) & -\\sin\\theta(t) & 0\\\\\n  \\sin\\theta(t) & \\cos\\theta(t) & 0\\\\\n  0 & 0 & 1\n  \\end{bmatrix}.$$\n- 考虑在 $t \\in [0,T]$ 上的三种基本运动 $\\boldsymbol{F}(t)$：\n  - 情况 1（简单剪切）：$\\boldsymbol{F}(t) = \\begin{bmatrix}1 & \\gamma(t) & 0\\\\ 0 & 1 & 0\\\\ 0 & 0 & 1\\end{bmatrix}$，其中 $\\gamma(t) = \\gamma_{0}\\sin\\left(2\\pi t/T\\right)$。\n  - 情况 2（单轴拉伸）：$\\boldsymbol{F}(t) = \\operatorname{diag}\\left(\\lambda_{x}(t), 1, 1\\right)$，其中 $\\lambda_{x}(t) = 1 + s\\sin\\left(2\\pi t/T\\right)$。\n  - 情况 3（恒等变形）：$\\boldsymbol{F}(t) = \\boldsymbol{I}$（无变形）。\n- 每种情况下旋转后的运动为 $\\tilde{\\boldsymbol{F}}(t) = \\boldsymbol{R}(t)\\boldsymbol{F}(t)$。\n\n误差度量和通过/失败准则：\n- 对于一个给定的算法，其为基本运动生成应力历史 $\\boldsymbol{\\sigma}(t)$，为旋转后的运动生成应力历史 $\\tilde{\\boldsymbol{\\sigma}}(t)$，构建旋转后的参考应力 $\\boldsymbol{\\sigma}_{\\mathrm{ref}}(t) = \\boldsymbol{R}(t)\\boldsymbol{\\sigma}(t)\\boldsymbol{R}(t)^{\\mathsf{T}}$。\n- 将时间 $t$ 的瞬时误差定义为\n  $$e(t) = \\left\\|\\tilde{\\boldsymbol{\\sigma}}(t) - \\boldsymbol{\\sigma}_{\\mathrm{ref}}(t)\\right\\|_{\\mathrm{F}},$$\n  其中 $\\|\\cdot\\|_{\\mathrm{F}}$ 是 Frobenius 范数。使用时间网格上的最大误差：\n  $$E_{\\max} = \\max_{t \\in \\{t_{n}\\}}\\; e(t).$$\n- 如果 $E_{\\max} \\le \\varepsilon$，则认为该算法在此测试案例中是客观一致的，其中容差 $\\varepsilon$ 设为 $\\varepsilon = 10^{-8}$。\n\n数值设置和参数（所有量均为无量纲，角度以弧度为单位）：\n- 时间范围：$T = 1$。\n- 时间步数：$N = 401$。使用均匀步长 $\\Delta t = T/(N-1)$。\n- 转动参数：$\\theta_{0} = 3$ 和 $a = 0.2$。\n- 情况 1：剪切幅值 $\\gamma_{0} = 0.3$。\n- 情况 2：拉伸幅值 $s = 0.25$。\n- 情况 3：恒等变形。\n- 超弹性参数：$\\mu = 10$ 和 $\\kappa = 100$。\n- 次弹性参数：$\\lambda = 60$ 和 $\\mu = 10$。\n\n测试套件和要求输出：\n- 对于三种情况中的每一种，使用上述准则评估算法 H 和算法 S 的通过/失败布尔值。这将产生六个布尔值，按 $[\\text{H1},\\text{S1},\\text{H2},\\text{S2},\\text{H3},\\text{S3}]$ 的顺序排列，分别对应于情况 1–3 和算法 H、S。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，“[True,False,True,False,True,False]”）。\n\n您的实现必须是自包含的，不需要任何输入，并精确生成指定的输出行。所有角度都必须以弧度处理。",
            "solution": "材料框架无差异性（客观性）的测试是利用连续介质运动学在叠加刚体转动下的变换性质以及对本构映射的要求来构建的。其核心思想是，首先计算由变形梯度 $\\boldsymbol{F}(t)$ 描述的基本运动的应力响应，然后叠加一个含时刚体转动 $\\boldsymbol{R}(t)$ 形成 $\\tilde{\\boldsymbol{F}}(t)=\\boldsymbol{R}(t)\\boldsymbol{F}(t)$，最后将该算法在 $\\tilde{\\boldsymbol{F}}(t)$ 驱动下产生的应力历史与经过适当旋转的原始应力历史进行比较。\n\n基于原理的推导：\n- 在观察者叠加一个刚体转动的情况下，本构律必须是客观的。对于从 $\\boldsymbol{F}(t)$ 计算出的 Cauchy 应力响应 $\\boldsymbol{\\sigma}(t)$，旋转后运动的变换应力必须满足变换规则\n  $$\\tilde{\\boldsymbol{\\sigma}}(t) = \\boldsymbol{R}(t)\\,\\boldsymbol{\\sigma}(t)\\,\\boldsymbol{R}(t)^{\\mathsf{T}}.$$\n  这源于空间描述中对各向同性和在叠加刚体运动下不变性的要求；转动由一个正交张量 $\\boldsymbol{R}(t)$ 表示，满足 $\\boldsymbol{R}(t)^{\\mathsf{T}}\\boldsymbol{R}(t)=\\boldsymbol{I}$ 且 $\\dot{\\boldsymbol{R}}(t)\\boldsymbol{R}(t)^{\\mathsf{T}}$ 是反对称的。任何客观的本构律都必须遵守此变换。\n- 变形梯度 $\\boldsymbol{F}(t)$ 将参考构型中的线元映射到当前构型中的线元。速度梯度为 $\\boldsymbol{L}(t) = \\dot{\\boldsymbol{F}}(t)\\boldsymbol{F}(t)^{-1}$，它可以分解为对称的变形率张量 $\\boldsymbol{D}(t)$ 和反对称的自旋张量 $\\boldsymbol{W}(t)$。在叠加刚体转动下，旋转后的速度梯度变为\n  $$\\tilde{\\boldsymbol{L}}(t) = \\dot{\\boldsymbol{R}}(t)\\boldsymbol{R}(t)^{\\mathsf{T}} + \\boldsymbol{R}(t)\\boldsymbol{L}(t)\\boldsymbol{R}(t)^{\\mathsf{T}}.$$\n  项 $\\dot{\\boldsymbol{R}}(t)\\boldsymbol{R}(t)^{\\mathsf{T}}$ 是纯反对称的；因此，任何依赖于完整 $\\boldsymbol{L}(t)$ 而非仅依赖于 $\\boldsymbol{D}(t)$ 的算法，都可能从转动分量中产生伪应力，从而违背客观性。\n\n算法设计：\n- 算法 H（可压缩 Neo-Hookean 超弹性）通过其构造保证了客观性，因为它从在旋转下能正确变换的应变度量来计算 Cauchy 应力。其公式\n  $$\\boldsymbol{\\sigma}_{\\mathrm{H}}(t) = \\frac{\\mu}{J(t)}\\left(\\boldsymbol{b}(t) - \\boldsymbol{I}\\right) + \\kappa\\left(J(t) - 1\\right)\\boldsymbol{I},\\quad \\boldsymbol{b}(t) = \\boldsymbol{F}(t)\\boldsymbol{F}(t)^{\\mathsf{T}},\\quad J(t) = \\det(\\boldsymbol{F}(t)),$$\n  确保了在 $\\tilde{\\boldsymbol{F}}(t) = \\boldsymbol{R}(t)\\boldsymbol{F}(t)$ 下，应力变换遵循 $\\tilde{\\boldsymbol{\\sigma}}_{\\mathrm{H}}(t) = \\boldsymbol{R}(t)\\boldsymbol{\\sigma}_{\\mathrm{H}}(t)\\boldsymbol{R}(t)^{\\mathsf{T}}$。\n- 算法 S 使用完整的速度梯度计算应力率：\n  $$\\dot{\\boldsymbol{\\sigma}}_{\\mathrm{S}}(t) = \\lambda\\,\\operatorname{tr}(\\boldsymbol{L}(t))\\boldsymbol{I} + 2\\mu\\,\\boldsymbol{L}(t).$$\n  由于 $\\boldsymbol{L}(t)$ 包含自旋 $\\boldsymbol{W}(t)$，该算法不是客观的，因为它会从刚体转动中产生应力贡献。在离散时间网格上使用显式欧拉积分可得\n  $$\\boldsymbol{\\sigma}_{\\mathrm{S}}^{n+{1}} = \\boldsymbol{\\sigma}_{\\mathrm{S}}^{n} + \\Delta t\\left[\\lambda\\,\\operatorname{tr}(\\boldsymbol{L}^{n})\\boldsymbol{I} + 2\\mu\\,\\boldsymbol{L}^{n}\\right],\\quad \\boldsymbol{L}^{n} \\approx \\frac{\\boldsymbol{F}^{n+1} - \\boldsymbol{F}^{n}}{\\Delta t}\\left(\\boldsymbol{F}^{n}\\right)^{-1},\\quad \\boldsymbol{\\sigma}_{\\mathrm{S}}^{0} = \\boldsymbol{0}.$$\n\n测试构建：\n- 对于每种基本运动，计算 $\\boldsymbol{\\sigma}_{\\mathrm{H}}(t_{n})$ 和 $\\boldsymbol{\\sigma}_{\\mathrm{S}}(t_{n})$ 以及它们在旋转运动 $\\tilde{\\boldsymbol{F}}(t_{n})$ 下的对应值。构建参考旋转应力 $\\boldsymbol{\\sigma}_{\\mathrm{ref}}(t_{n}) = \\boldsymbol{R}(t_{n})\\boldsymbol{\\sigma}(t_{n})\\boldsymbol{R}(t_{n})^{\\mathsf{T}}$。\n- 使用 Frobenius 范数误差 $e(t_{n}) = \\left\\|\\tilde{\\boldsymbol{\\sigma}}(t_{n}) - \\boldsymbol{\\sigma}_{\\mathrm{ref}}(t_{n})\\right\\|_{\\mathrm{F}}$ 和随时间的最大值 $E_{\\max} = \\max_{n} e(t_{n})$ 来根据容差 $\\varepsilon = 10^{-8}$ 判断通过或失败。\n\n测试套件覆盖范围：\n- 情况 1（简单剪切）测试了具有非零 $\\boldsymbol{D}(t)$ 的非平凡非对角分量。\n- 情况 2（单轴拉伸）测试了超弹性模型中具有非平凡 $J(t)$ 的对角应力演化。\n- 情况 3（恒等变形）隔离了刚体转动效应：对于算法 H，$\\boldsymbol{\\sigma}_{\\mathrm{H}}(t) = \\boldsymbol{0}$；对于算法 S，$\\boldsymbol{L}(t)$ 简化为转动自旋并产生伪应力，清晰地展示了其非客观性。\n\n数值细节：\n- 时间网格 $t_{n}$，其中 $n=0,\\dots,N-1$, $N=401$, $\\Delta t = T/(N-1)$, $T=1$。\n- 转动角 $\\theta(t) = \\theta_{0} t + a \\sin(2\\pi t/T)$，其中 $\\theta_{0}=3$ 和 $a=0.2$ 确保了含时转动；角度以弧度为单位。\n- 参数均为无量纲：超弹性 $\\mu=10$, $\\kappa=100$；次弹性 $\\lambda=60$, $\\mu=10$；剪切幅值 $\\gamma_{0}=0.3$；拉伸幅值 $s=0.25$。\n\n预期结果：\n- 由于客观性，算法 H 应在所有三种情况下通过测试，得出 $E_{\\max}\\le\\varepsilon$。\n- 算法 S 应在所有情况下失败；在情况 3 中最为明显，其中 $\\boldsymbol{F}(t)=\\boldsymbol{I}$，仅转动就通过 $\\boldsymbol{L}(t)$ 的反对称部分产生非零应力，违背了客观性。\n\n实现说明：\n- 在每个时间步通过有限差分和矩阵求逆计算 $\\boldsymbol{L}^{n}$。\n- 对两种算法均使用一致的三维旋转、变形和应力计算。\n- 按 $[\\text{H1},\\text{S1},\\text{H2},\\text{S2},\\text{H3},\\text{S3}]$ 的顺序汇总通过/失败的布尔值，并以指定格式单行打印。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef rotation_matrix_z(theta: float) -> np.ndarray:\n    \"\"\"Return 3x3 rotation about z-axis by angle theta (radians).\"\"\"\n    c = np.cos(theta)\n    s = np.sin(theta)\n    R = np.array([[c, -s, 0.0],\n                  [s,  c, 0.0],\n                  [0.0, 0.0, 1.0]])\n    return R\n\ndef neo_hookean_cauchy(F: np.ndarray, mu: float, kappa: float) -> np.ndarray:\n    \"\"\"Compressible Neo-Hookean Cauchy stress for given deformation gradient F.\"\"\"\n    J = np.linalg.det(F)\n    b = F @ F.T\n    I = np.eye(3)\n    # sigma = (mu/J)*(b - I) + kappa*(J - 1)*I\n    sigma = (mu / J) * (b - I) + kappa * (J - 1.0) * I\n    return sigma\n\ndef velocity_gradient(F_next: np.ndarray, F_curr: np.ndarray, dt: float) -> np.ndarray:\n    \"\"\"Compute velocity gradient L ~ F_dot * F^{-1} via finite difference.\"\"\"\n    Fdot = (F_next - F_curr) / dt\n    Finv = np.linalg.inv(F_curr)\n    L = Fdot @ Finv\n    return L\n\ndef integrate_hypoelastic_sigma(F_series: np.ndarray, dt: float, lam: float, mu: float) -> np.ndarray:\n    \"\"\"Integrate hypoelastic stress rate using full velocity gradient over time series of F.\"\"\"\n    N = F_series.shape[0]\n    I = np.eye(3)\n    # Initialize stress history\n    sigma_hist = np.zeros((N, 3, 3))\n    sigma = np.zeros((3, 3))\n    for n in range(N - 1):\n        L = velocity_gradient(F_series[n + 1], F_series[n], dt)\n        sigma_dot = lam * np.trace(L) * I + 2.0 * mu * L\n        sigma = sigma + dt * sigma_dot\n        sigma_hist[n + 1] = sigma\n    return sigma_hist\n\ndef construct_time_series(T: float, N: int, theta0: float, a: float,\n                          case: int, gamma0: float = 0.3, s: float = 0.25) -> tuple:\n    \"\"\"Construct time series for base F(t), rotation R(t), and rotated Ftilde(t) for a given case.\"\"\"\n    t = np.linspace(0.0, T, N)\n    theta = theta0 * t + a * np.sin(2.0 * np.pi * t / T)\n    R_series = np.array([rotation_matrix_z(th) for th in theta])\n\n    F_series = np.zeros((N, 3, 3))\n    if case == 1:\n        # Simple shear: F = [[1, gamma(t), 0], [0,1,0], [0,0,1]]\n        gamma = gamma0 * np.sin(2.0 * np.pi * t / T)\n        for n in range(N):\n            F_series[n] = np.array([[1.0, gamma[n], 0.0],\n                                    [0.0, 1.0,      0.0],\n                                    [0.0, 0.0,      1.0]])\n    elif case == 2:\n        # Uniaxial stretch along x: F = diag(lambda_x(t), 1, 1)\n        lamx = 1.0 + s * np.sin(2.0 * np.pi * t / T)\n        for n in range(N):\n            F_series[n] = np.diag([lamx[n], 1.0, 1.0])\n    elif case == 3:\n        # Identity: no deformation\n        for n in range(N):\n            F_series[n] = np.eye(3)\n    else:\n        raise ValueError(\"Invalid case index. Must be 1, 2, or 3.\")\n\n    # Rotated motion Ftilde = R * F\n    Ftilde_series = np.array([R_series[n] @ F_series[n] for n in range(N)])\n    return t, R_series, F_series, Ftilde_series\n\ndef compute_objectivity_error_hyper(F_series: np.ndarray, Ftilde_series: np.ndarray, R_series: np.ndarray,\n                                    mu: float, kappa: float) -> float:\n    \"\"\"Compute max Frobenius norm error for hyperelastic algorithm under rotation.\"\"\"\n    N = F_series.shape[0]\n    errors = np.zeros(N)\n    for n in range(N):\n        sigma_base = neo_hookean_cauchy(F_series[n], mu, kappa)\n        sigma_rot = neo_hookean_cauchy(Ftilde_series[n], mu, kappa)\n        sigma_ref = R_series[n] @ sigma_base @ R_series[n].T\n        diff = sigma_rot - sigma_ref\n        errors[n] = np.linalg.norm(diff, ord='fro')\n    return float(np.max(errors))\n\ndef compute_objectivity_error_hypo(F_series: np.ndarray, Ftilde_series: np.ndarray, R_series: np.ndarray,\n                                   dt: float, lam: float, mu: float) -> float:\n    \"\"\"Compute max Frobenius norm error for hypoelastic algorithm under rotation.\"\"\"\n    sigma_base_hist = integrate_hypoelastic_sigma(F_series, dt, lam, mu)\n    sigma_rot_hist = integrate_hypoelastic_sigma(Ftilde_series, dt, lam, mu)\n    N = F_series.shape[0]\n    errors = np.zeros(N)\n    for n in range(N):\n        sigma_ref = R_series[n] @ sigma_base_hist[n] @ R_series[n].T\n        diff = sigma_rot_hist[n] - sigma_ref\n        errors[n] = np.linalg.norm(diff, ord='fro')\n    return float(np.max(errors))\n\ndef solve():\n    # Define parameters from the problem statement\n    T = 1.0\n    N = 401\n    dt = T / (N - 1)\n    theta0 = 3.0\n    a = 0.2\n    gamma0 = 0.3\n    s = 0.25\n\n    # Material parameters\n    mu_hyper = 10.0\n    kappa_hyper = 100.0\n    lam_hypo = 60.0\n    mu_hypo = 10.0\n\n    # Tolerance for pass/fail\n    eps = 1e-8\n\n    results = []\n\n    for case in [1, 2, 3]:\n        # Construct time series for this case\n        _, R_series, F_series, Ftilde_series = construct_time_series(T, N, theta0, a, case, gamma0, s)\n\n        # Algorithm H (Hyperelastic)\n        Emax_H = compute_objectivity_error_hyper(F_series, Ftilde_series, R_series, mu_hyper, kappa_hyper)\n        pass_H = (Emax_H = eps)\n        results.append(pass_H)\n\n        # Algorithm S (Hypoelastic rate with full L)\n        Emax_S = compute_objectivity_error_hypo(F_series, Ftilde_series, R_series, dt, lam_hypo, mu_hypo)\n        pass_S = (Emax_S = eps)\n        results.append(pass_S)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "即使一个本构模型满足客观性，它也可能在描述大变形时表现出不符合物理直觉的行为。本练习通过分析材料在简单剪切下的响应，鲜明地对比了率形式的亚弹性模型和基于应变能势的超弹性模型 。你将推导出亚弹性模型会预测出非物理的应力振荡，而超弹性模型由于其内在的路径无关性，则能正确地描述应力随应变的单调增长，从而揭示了后者在理论上的优越性。",
            "id": "3552823",
            "problem": "考虑一个均匀、各向同性、不可压缩的弹性固体，在恒定的剪切应变率 $\\,\\dot{\\gamma}\\,$ 下进行平面简单剪切，从 $\\,t=0\\,$ 时的无应力状态开始。设该运动由变形梯度 $\\,\\mathbf{F}(t)\\,$ 描述，该变形梯度与在 $\\,x_{1}\\,$ 方向上沿 $\\,x_{2}\\,$ 方向的剪切量 $\\,\\gamma(t)\\,$ 相关，因此 $\\,\\gamma(t)=\\dot{\\gamma}\\,t\\,$. 速度梯度 $\\,\\mathbf{L}=\\dot{\\mathbf{F}}\\mathbf{F}^{-1}\\,$ 具有对称的变形率张量 $\\,\\mathbf{D}=\\tfrac{1}{2}(\\mathbf{L}+\\mathbf{L}^{\\top})\\,$ 和反对称的自旋张量 $\\,\\mathbf{W}=\\tfrac{1}{2}(\\mathbf{L}-\\mathbf{L}^{\\top})\\,$。Cauchy应力 $\\,\\boldsymbol{\\sigma}\\,$ 根据使用Jaumann客观率的线性各向同性次弹性定律演化，\n$$\n\\stackrel{\\triangle}{\\boldsymbol{\\sigma}} \\equiv \\dot{\\boldsymbol{\\sigma}} + \\boldsymbol{\\sigma}\\mathbf{W} - \\mathbf{W}\\boldsymbol{\\sigma} = \\mathbb{C}:\\mathbf{D},\n$$\n其中 $\\,\\mathbb{C}\\,$ 是四阶弹性模量张量。对于不可压缩的各向同性固体，其偏应力响应由恒定的剪切模量 $\\,\\mu\\,$ 表征，且 $\\,\\mathbb{C}:\\mathbf{D}=2\\mu\\,\\mathbf{D}\\,$. 假设为平面应变运动学，其中 $\\,\\mathbf{L}\\,$ 对应于简单剪切，且 $\\,\\boldsymbol{\\sigma}(0)=\\mathbf{0}\\,$.\n\n从这些定义出发，推导Cauchy应力分量的演化方程，并获得由带有Jaumann率的线性次弹性模型所预测的、作为剪切应变 $\\,\\gamma\\,$ 函数的归一化剪切应力 $\\,\\sigma_{12}(\\gamma)/\\mu\\,$ 的闭式表达式。然后，使用基于不可压缩固体的neo-Hookean应变能密度 $\\,W(\\mathbf{B})=\\tfrac{\\mu}{2}\\,(I_{1}-3)\\,$ 的超弹性公式（其中 $\\,\\mathbf{B}=\\mathbf{F}\\mathbf{F}^{\\top}\\,$ 且 $\\,I_{1}=\\mathrm{tr}(\\mathbf{B})\\,$），简要解释为什么超弹性预测在简单剪切中能避免剪切应力振荡。\n\n答案规格：\n- 提供 $\\,\\sigma_{12}(\\gamma)/\\mu\\,$ 的单个解析表达式作为您的最终答案。\n- 无需进行数值计算或四舍五入。\n- 由于所求量是归一化的，最终表达式中不需要物理单位。",
            "solution": "该问题是适定的，并具有科学依据。它提出了连续介质力学中一个关于材料在简单剪切下行为的标准问题，该行为由两种不同的本构模型描述：带有Jaumann率的线性次弹性模型和超弹性neo-Hookean模型。所有概念，如变形梯度、变形率张量、自旋张量、Jaumann率和neo-Hookean应变能，都是固体力学领域的基础。问题陈述是自洽的，提供了推导唯一解所需的所有必要方程和初始条件。因此，该问题是有效的，并且可以推导出解。\n\n该问题要求推导次弹性材料的归一化剪切应力，并解释在超弹性模型中观察到的不同行为。\n\n**第一部分：带有Jaumann率的次弹性模型**\n\n首先，我们建立简单剪切的运动学。运动由 $x_1 = X_1 + \\gamma(t) X_2$、$x_2 = X_2$ 和 $x_3 = X_3$ 给出，其中 $\\gamma(t) = \\dot{\\gamma}t$ 且 $\\dot{\\gamma}$ 是一个常数。变形梯度张量 $\\mathbf{F}$、其时间导数 $\\dot{\\mathbf{F}}$ 及其逆 $\\mathbf{F}^{-1}$ 以矩阵形式给出如下：\n$$\n\\mathbf{F}(t) = \\begin{pmatrix} 1  \\gamma(t)  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{pmatrix}, \\quad \\dot{\\mathbf{F}}(t) = \\begin{pmatrix} 0  \\dot{\\gamma}  0 \\\\ 0  0  0 \\\\ 0  0  0 \\end{pmatrix}, \\quad \\mathbf{F}^{-1}(t) = \\begin{pmatrix} 1  -\\gamma(t)  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{pmatrix}\n$$\n速度梯度 $\\mathbf{L}$ 计算为 $\\mathbf{L} = \\dot{\\mathbf{F}}\\mathbf{F}^{-1}$：\n$$\n\\mathbf{L} = \\begin{pmatrix} 0  \\dot{\\gamma}  0 \\\\ 0  0  0 \\\\ 0  0  0 \\end{pmatrix} \\begin{pmatrix} 1  -\\gamma  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{pmatrix} = \\begin{pmatrix} 0  \\dot{\\gamma}  0 \\\\ 0  0  0 \\\\ 0  0  0 \\end{pmatrix}\n$$\n变形率张量 $\\mathbf{D}$ 是 $\\mathbf{L}$ 的对称部分，自旋张量 $\\mathbf{W}$ 是 $\\mathbf{L}$ 的反对称部分：\n$$\n\\mathbf{D} = \\frac{1}{2}(\\mathbf{L} + \\mathbf{L}^{\\top}) = \\frac{1}{2} \\begin{pmatrix} 0  \\dot{\\gamma}  0 \\\\ \\dot{\\gamma}  0  0 \\\\ 0  0  0 \\end{pmatrix} = \\begin{pmatrix} 0  \\frac{\\dot{\\gamma}}{2}  0 \\\\ \\frac{\\dot{\\gamma}}{2}  0  0 \\\\ 0  0  0 \\end{pmatrix}\n$$\n$$\n\\mathbf{W} = \\frac{1}{2}(\\mathbf{L} - \\mathbf{L}^{\\top}) = \\frac{1}{2} \\begin{pmatrix} 0  \\dot{\\gamma}  0 \\\\ -\\dot{\\gamma}  0  0 \\\\ 0  0  0 \\end{pmatrix} = \\begin{pmatrix} 0  \\frac{\\dot{\\gamma}}{2}  0 \\\\ -\\frac{\\dot{\\gamma}}{2}  0  0 \\\\ 0  0  0 \\end{pmatrix}\n$$\n本构律是带有Jaumann率 $\\stackrel{\\triangle}{\\boldsymbol{\\sigma}}$ 的线性次弹性模型：\n$$\n\\stackrel{\\triangle}{\\boldsymbol{\\sigma}} \\equiv \\dot{\\boldsymbol{\\sigma}} + \\boldsymbol{\\sigma}\\mathbf{W} - \\mathbf{W}\\boldsymbol{\\sigma} = 2\\mu\\mathbf{D}\n$$\n其中 $\\dot{\\boldsymbol{\\sigma}}$ 是Cauchy应力 $\\boldsymbol{\\sigma}$ 的物质时间导数。设对称Cauchy应力张量的分量为 $\\sigma_{ij}$。项 $\\boldsymbol{\\sigma}\\mathbf{W} - \\mathbf{W}\\boldsymbol{\\sigma}$ 计算如下：\n$$\n\\boldsymbol{\\sigma}\\mathbf{W} - \\mathbf{W}\\boldsymbol{\\sigma} = \\begin{pmatrix} \\sigma_{11}  \\sigma_{12}  \\sigma_{13} \\\\ \\sigma_{12}  \\sigma_{22}  \\sigma_{23} \\\\ \\sigma_{13}  \\sigma_{23}  \\sigma_{33} \\end{pmatrix} \\begin{pmatrix} 0  \\frac{\\dot{\\gamma}}{2}  0 \\\\ -\\frac{\\dot{\\gamma}}{2}  0  0 \\\\ 0  0  0 \\end{pmatrix} - \\begin{pmatrix} 0  \\frac{\\dot{\\gamma}}{2}  0 \\\\ -\\frac{\\dot{\\gamma}}{2}  0  0 \\\\ 0  0  0 \\end{pmatrix} \\begin{pmatrix} \\sigma_{11}  \\sigma_{12}  \\sigma_{13} \\\\ \\sigma_{12}  \\sigma_{22}  \\sigma_{23} \\\\ \\sigma_{13}  \\sigma_{23}  \\sigma_{33} \\end{pmatrix}\n$$\n$$\n= \\frac{\\dot{\\gamma}}{2} \\begin{pmatrix} -2\\sigma_{12}  \\sigma_{11}-\\sigma_{22}  -\\sigma_{23} \\\\ \\sigma_{11}-\\sigma_{22}  2\\sigma_{12}  \\sigma_{13} \\\\ -\\sigma_{23}  \\sigma_{13}  0 \\end{pmatrix}\n$$\n本构方程变为 $\\dot{\\boldsymbol{\\sigma}} = 2\\mu\\mathbf{D} - (\\boldsymbol{\\sigma}\\mathbf{W} - \\mathbf{W}\\boldsymbol{\\sigma})$。对于1-2平面内的平面应变简单剪切，我们有 $\\sigma_{13}=\\sigma_{23}=0$。分量方程为：\n$$\n\\dot{\\sigma}_{11} = 0 - (-\\sigma_{12}\\dot{\\gamma}) = \\sigma_{12}\\dot{\\gamma}\n$$\n$$\n\\dot{\\sigma}_{22} = 0 - (\\sigma_{12}\\dot{\\gamma}) = -\\sigma_{12}\\dot{\\gamma}\n$$\n$$\n\\dot{\\sigma}_{12} = 2\\mu(\\frac{\\dot{\\gamma}}{2}) - \\frac{\\dot{\\gamma}}{2}(\\sigma_{11}-\\sigma_{22}) = \\mu\\dot{\\gamma} - \\frac{\\dot{\\gamma}}{2}(\\sigma_{11}-\\sigma_{22})\n$$\n$$\n\\dot{\\sigma}_{33} = 0\n$$\n根据初始条件 $\\boldsymbol{\\sigma}(0)=0$，我们有 $\\sigma_{33}(t)=0$。由前两个方程可知 $\\dot{\\sigma}_{11} + \\dot{\\sigma}_{22} = 0$。对时间积分并应用初始条件，得出 $\\sigma_{11}(t) + \\sigma_{22}(t) = 0$，所以 $\\sigma_{22} = -\\sigma_{11}$。\n将此代入 $\\dot{\\sigma}_{12}$ 的方程中：\n$$\n\\dot{\\sigma}_{12} = \\mu\\dot{\\gamma} - \\frac{\\dot{\\gamma}}{2}(\\sigma_{11}-(-\\sigma_{11})) = (\\mu - \\sigma_{11})\\dot{\\gamma}\n$$\n我们现在得到了一个二元常微分方程组。我们将自变量从时间 $t$ 变为剪切应变 $\\gamma = \\dot{\\gamma}t$。使用链式法则，$\\frac{d}{dt} = \\frac{d\\gamma}{dt}\\frac{d}{d\\gamma} = \\dot{\\gamma}\\frac{d}{d\\gamma}$。该方程组变为：\n1. $\\frac{d\\sigma_{11}}{d\\gamma} = \\sigma_{12}$\n2. $\\frac{d\\sigma_{12}}{d\\gamma} = \\mu - \\sigma_{11}$\n\n对第一个方程关于 $\\gamma$ 求导，并代入第二个方程，得到一个关于 $\\sigma_{11}$ 的二阶常微分方程：\n$$\n\\frac{d^2\\sigma_{11}}{d\\gamma^2} = \\frac{d\\sigma_{12}}{d\\gamma} = \\mu - \\sigma_{11} \\implies \\frac{d^2\\sigma_{11}}{d\\gamma^2} + \\sigma_{11} = \\mu\n$$\n通解是齐次解和特解之和。齐次解为 $C_1\\cos(\\gamma) + C_2\\sin(\\gamma)$。一个特解是 $\\sigma_{11,p}=\\mu$。\n$$\n\\sigma_{11}(\\gamma) = \\mu + C_1\\cos(\\gamma) + C_2\\sin(\\gamma)\n$$\n由此，我们通过求导得到 $\\sigma_{12}(\\gamma)$：\n$$\n\\sigma_{12}(\\gamma) = \\frac{d\\sigma_{11}}{d\\gamma} = -C_1\\sin(\\gamma) + C_2\\cos(\\gamma)\n$$\n常数 $C_1$ 和 $C_2$ 可由初始条件 $\\sigma_{11}(0) = 0$ 和 $\\sigma_{12}(0) = 0$ 求出：\n$$\n\\sigma_{11}(0) = \\mu + C_1\\cos(0) + C_2\\sin(0) = \\mu + C_1 = 0 \\implies C_1 = -\\mu\n$$\n$$\n\\sigma_{12}(0) = -C_1\\sin(0) + C_2\\cos(0) = C_2 = 0\n$$\n将这些常数代回，应力分量为：\n$$\n\\sigma_{11}(\\gamma) = \\mu(1-\\cos(\\gamma))\n$$\n$$\n\\sigma_{12}(\\gamma) = -(-\\mu)\\sin(\\gamma) = \\mu\\sin(\\gamma)\n$$\n因此，归一化剪切应力为：\n$$\n\\frac{\\sigma_{12}(\\gamma)}{\\mu} = \\sin(\\gamma)\n$$\n这一结果预测，随着剪切应变的增加，剪切应力会发生振荡，这对于单调剪切来说在物理上是不切实际的。\n\n**第二部分：超弹性neo-Hookean模型**\n\n对于超弹性材料，Cauchy应力 $\\boldsymbol{\\sigma}$ 由当前的变形状态决定，而不是由变形率的历史决定。对于应变能密度为 $W = \\frac{\\mu}{2}(I_1-3)$ 的不可压缩neo-Hookean材料，其Cauchy应力由下式给出：\n$$\n\\boldsymbol{\\sigma} = -p\\mathbf{I} + \\mu\\mathbf{B}\n$$\n其中 $p$ 是静水压力，$\\mathbf{B}=\\mathbf{F}\\mathbf{F}^{\\top}$ 是左Cauchy-Green变形张量。对于简单剪切，$\\mathbf{F}$ 如上所示，而 $\\mathbf{B}$ 为：\n$$\n\\mathbf{B} = \\begin{pmatrix} 1  \\gamma  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{pmatrix} \\begin{pmatrix} 1  0  0 \\\\ \\gamma  1  0 \\\\ 0  0  1 \\end{pmatrix} = \\begin{pmatrix} 1+\\gamma^2  \\gamma  0 \\\\ \\gamma  1  0 \\\\ 0  0  1 \\end{pmatrix}\n$$\n应力分量为：\n$$\n\\sigma_{11} = -p + \\mu(1+\\gamma^2), \\quad \\sigma_{22} = -p + \\mu, \\quad \\sigma_{12} = \\mu\\gamma\n$$\n在简单剪切的常见边界条件 $\\sigma_{22}=0$ 下，我们得到 $p=\\mu$。那么剪切应力即为：\n$$\n\\sigma_{12}(\\gamma) = \\mu\\gamma\n$$\n在此模型中，剪切应力随剪切应变线性增加，不表现出任何振荡。\n\n超弹性公式避免了在次弹性模型中出现的不符合物理的振荡，因为它是一个可积的、路径无关的模型。应力是有限变形（由 $\\mathbf{F}$ 或 $\\mathbf{B}$ 表示）的状态函数。相比之下，次弹性模型通过一个率方程来定义应力。这个率方程的积分是路径依赖的。Jaumann客观率在确保标架无关性的同时，将应力率与材料的自旋相关联。在连续简单剪切中，这种自旋耦合导致应力张量相对于实验室坐标系的人为旋转，从而使得预测的应力分量发生振荡。超弹性模型避免了这种人为现象，因为其公式基于一个标量能量势，这保证了对于任何给定的变形状态，都存在唯一的应力状态，而与达到该状态所经过的路径无关。",
            "answer": "$$\n\\boxed{\\sin(\\gamma)}\n$$"
        },
        {
            "introduction": "稳健的本构模型不仅要基于正确的物理原理，其数值实现也必须在离散时间步上遵守这些原理。本练习将深入探讨耗散材料模型的热力学基础，指导你推导出一个离散的能量耗散不等式，以确保数值算法在每一步都满足热力学第二定律 。通过此过程，你将发现自由能函数的凸性是保证算法无条件稳定性的关键，它能从根本上防止数值计算中凭空产生能量。",
            "id": "3552881",
            "problem": "考虑一个具有内变量的小应变、等温、准静态、一维广义标准材料。令应变表示为 $\\,\\varepsilon \\in \\mathbb{R}\\,$，内变量表示为 $\\,\\alpha \\in \\mathbb{R}\\,$。亥姆霍兹自由能 $\\,\\psi(\\varepsilon,\\alpha)\\,$ 是二阶连续可微的。柯西应力 $\\,\\sigma\\,$ 和与 $\\,\\alpha\\,$ 共轭的热力学力 $\\,Y\\,$ 由以下标准热力学关系定义\n$$\n\\sigma = \\partial_{\\varepsilon}\\psi(\\varepsilon,\\alpha),\\qquad Y = -\\,\\partial_{\\alpha}\\psi(\\varepsilon,\\alpha).\n$$\n假设存在一个关于内变量率 $\\,v=\\dot{\\alpha}\\,$ 的凸、非负、二阶连续可微的耗散势 $\\,\\Phi(v)\\,$。相关的演化法则是 $\\,Y \\in \\partial \\Phi(v)\\,$，对于可微的 $\\,\\Phi\\,$，这简化为 $\\,Y=\\partial\\Phi(v)\\,$。考虑一个大小为 $\\,\\Delta t0\\,$ 的单时间步 $\\,t_n \\to t_{n+1}\\,$，并对内变量使用后向欧拉（BE）时间离散，即在 $\\,t_{n+1}\\,$ 时刻评估必要的量，并通过 $\\,v_{n+1} = \\Delta \\alpha / \\Delta t\\,$ 将它们与增量 $\\,\\Delta \\alpha = \\alpha_{n+1}-\\alpha_n\\,$ 联系起来。假设应变增量 $\\,\\Delta \\varepsilon = \\varepsilon_{n+1}-\\varepsilon_n\\,$ 是给定的。将物体的（步进）机械功输入定义为 $\\,W_{\\mathrm{ext}} = \\sigma_{n+1} \\,\\Delta \\varepsilon\\,$，并将离散耗散定义为功输入与自由能变化之差，\n$$\n\\Delta D := W_{\\mathrm{ext}} - \\Delta \\psi,\\quad \\text{其中}\\quad \\Delta \\psi := \\psi(\\varepsilon_{n+1},\\alpha_{n+1}) - \\psi(\\varepsilon_{n},\\alpha_{n}).\n$$\n所有量都是无量纲的，不需要物理单位。\n\n任务 A（推导）：仅从热力学第二定律的等温小应变形式、上述热力学定义以及凸函数的性质出发，推导出一个你的后向欧拉更新必须满足的离散能量耗散不等式。然后，通过分析 $\\,\\psi(\\varepsilon,\\alpha)\\,$ 的结构，给出 $\\,\\psi\\,$ 需满足的充分条件，使得不等式 $\\,\\Delta D \\ge 0\\,$ 对任意时间步长 $\\,\\Delta t0\\,$ 均成立（无条件稳定性）。你的推导不得假设超出这些基本原理的任何专门公式。\n\n任务 B（算法与计算）：对于特定模型\n$$\n\\psi(\\varepsilon,\\alpha) = \\tfrac{1}{2}\\,E\\,\\varepsilon^2 + \\tfrac{1}{2}\\,H\\,\\alpha^2 + C\\,\\varepsilon\\,\\alpha,\\qquad \\Phi(v)=\\tfrac{1}{2}\\,\\eta\\,v^2,\n$$\n其中常数 $\\,E0\\,$，$\\,H \\in \\mathbb{R}\\,$，$\\,C \\in \\mathbb{R}\\,$，以及 $\\,\\eta0\\,$，实现一个与演化法则一致的关于 $\\,\\alpha\\,$ 的后向欧拉更新，并计算 $\\,\\Delta D\\,$。使用 $\\,\\sigma_{n+1} = \\partial_{\\varepsilon}\\psi(\\varepsilon_{n+1},\\alpha_{n+1})\\,$ 来评估 $\\,W_{\\mathrm{ext}}\\,$。对于数值评估，请使用以下五个测试用例，每个用例以元组形式给出\n$$\n(E,H,C,\\eta,\\Delta t,\\varepsilon_n,\\alpha_n,\\Delta\\varepsilon):\n$$\n- 用例 1（一般凸）：$(100,\\,10,\\,3,\\,1,\\,1,\\,0,\\,0,\\,0.1)$\n- 用例 2（边界凸，半正定Hessian矩阵）：$(4,\\,1,\\,2,\\,1,\\,1,\\,0,\\,0,\\,0.1)$\n- 用例 3（凸，非常小的时间步）：$(50,\\,2,\\,3,\\,0.5,\\,10^{-6},\\,0,\\,0,\\,0.2)$\n- 用例 4（凸，非常大的时间步）：$(50,\\,2,\\,3,\\,0.5,\\,10^{6},\\,0,\\,0,\\,0.2)$\n- 用例 5（非凸耦合）：$(1,\\,0.01,\\,0.8,\\,0.01,\\,1,\\,0,\\,0,\\,0.1)$\n\n你的程序必须：\n- 对于每个用例，使用与给定的 $\\,\\Phi\\,$ 和热力学力定义一致的后向欧拉格式计算 $\\,\\alpha_{n+1}\\,$。\n- 计算 $\\,\\Delta \\psi\\,$, $\\,W_{\\mathrm{ext}}\\,$, 和 $\\,\\Delta D\\,$。\n- 为每个用例返回一个布尔值，指示是否 $\\,\\Delta D \\ge 0\\,$（将大于或等于 $\\, -10^{-12}\\,$ 的值视为非负，以考虑舍入误差）。\n- 将所有五个测试用例的布尔值聚合到一个列表中，并以 $[\\text{结果}_1,\\text{结果}_2,\\text{结果}_3,\\text{结果}_4,\\text{结果}_5]$ 的确切格式（无空格）单行打印。\n\n注意：\n- 你不得依赖任何用户输入。\n- 每个测试用例的输出类型必须是布尔值。\n- 时间积分和评估必须是完全自包含的。",
            "solution": "根据问题陈述的要求，解答分为两部分：理论推导（任务A）和计算实现（任务B）。\n\n### 任务 A：离散能量耗散不等式及稳定性条件的推导\n\n目标是为给定的材料模型和时间步进格式推导热力学第二定律的离散形式。我们的目的是建立亥姆霍兹自由能 $\\,\\psi(\\varepsilon,\\alpha)\\,$ 需满足的充分条件，以确保离散耗散 $\\,\\Delta D\\,$ 总是非负的。\n\n热力学第二定律，以等温过程的克劳修斯-杜亥姆不等式形式表述，指出内在耗散率必须非负。单位体积的耗散率由 $\\,D = \\sigma\\dot{\\varepsilon} - \\dot{\\psi} \\ge 0\\,$ 给出。对 $\\,\\dot{\\psi}\\,$ 使用链式法则：\n$$\n\\dot{\\psi} = \\frac{\\partial\\psi}{\\partial\\varepsilon}\\dot{\\varepsilon} + \\frac{\\partial\\psi}{\\partial\\alpha}\\dot{\\alpha}\n$$\n通过代入应力的热力学定义 $\\,\\sigma = \\partial_{\\varepsilon}\\psi\\,$ 和共轭力 $\\,Y = -\\partial_{\\alpha}\\psi\\,$，我们得到：\n$$\n\\dot{\\psi} = \\sigma\\dot{\\varepsilon} - Y\\dot{\\alpha}\n$$\n将此代入克劳修斯-杜亥姆不等式，得到以内变量表示的耗散率的标准表达式：\n$$\nD = \\sigma\\dot{\\varepsilon} - (\\sigma\\dot{\\varepsilon} - Y\\dot{\\alpha}) = Y\\dot{\\alpha} \\ge 0\n$$\n为了获得分析数值格式所需的离散对应形式，我们不对此率不等式进行积分。相反，我们在时间步 $\\,\\Delta t = t_{n+1} - t_n\\,$ 上使用一个全局论证。推导的核心依赖于能量函数和耗散函数的凸性。\n\n我们从分析离散耗散的定义开始，$\\,\\Delta D = W_{\\mathrm{ext}} - \\Delta\\psi\\,$，即 $\\,\\Delta D = \\sigma_{n+1}\\Delta\\varepsilon - (\\psi_{n+1} - \\psi_n)\\,$。此处，下标为 $\\,n\\,$ 的量在 $\\,(\\varepsilon_n, \\alpha_n)\\,$ 处取值，下标为 $\\,n+1\\,$ 的量在 $\\,(\\varepsilon_{n+1}, \\alpha_{n+1})\\,$ 处取值。\n\n关键步骤是假设亥姆霍兹自由能 $\\,\\psi(\\varepsilon, \\alpha)\\,$ 是状态变量 $\\,(\\varepsilon, \\alpha)\\,$ 的一个**凸函数**。对于任意二阶可微的凸函数 $\\,f(\\mathbf{x})\\,$，以下不等式成立：\n$$\nf(\\mathbf{x}_a) \\ge f(\\mathbf{x}_b) + \\nabla f(\\mathbf{x}_b) \\cdot (\\mathbf{x}_a - \\mathbf{x}_b)\n$$\n将此性质应用于 $\\,\\psi(\\varepsilon, \\alpha)\\,$，其中 $\\,\\mathbf{x}_a = (\\varepsilon_n, \\alpha_n)\\,$ 且 $\\,\\mathbf{x}_b = (\\varepsilon_{n+1}, \\alpha_{n+1})\\,$，可得：\n$$\n\\psi(\\varepsilon_n, \\alpha_n) \\ge \\psi(\\varepsilon_{n+1}, \\alpha_{n+1}) + \\left.\\frac{\\partial\\psi}{\\partial\\varepsilon}\\right|_{n+1}(\\varepsilon_n - \\varepsilon_{n+1}) + \\left.\\frac{\\partial\\psi}{\\partial\\alpha}\\right|_{n+1}(\\alpha_n - \\alpha_{n+1})\n$$\n使用热力学定义 $\\,\\sigma_{n+1} = \\partial_{\\varepsilon}\\psi|_{n+1}\\,$ 和 $\\,Y_{n+1} = -\\partial_{\\alpha}\\psi|_{n+1}\\,$，以及增量 $\\,\\Delta\\varepsilon = \\varepsilon_{n+1} - \\varepsilon_n\\,$ 和 $\\,\\Delta\\alpha = \\alpha_{n+1} - \\alpha_n\\,$，该不等式变为：\n$$\n\\psi_n \\ge \\psi_{n+1} + \\sigma_{n+1}(-\\Delta\\varepsilon) - Y_{n+1}(-\\Delta\\alpha)\n$$\n$$\n\\psi_n \\ge \\psi_{n+1} - \\sigma_{n+1}\\Delta\\varepsilon + Y_{n+1}\\Delta\\alpha\n$$\n重新整理此表达式以匹配离散耗散 $\\,\\Delta D\\,$ 的形式：\n$$\n\\sigma_{n+1}\\Delta\\varepsilon - (\\psi_{n+1} - \\psi_n) \\ge Y_{n+1}\\Delta\\alpha\n$$\n这直接得出了离散耗散不等式：\n$$\n\\Delta D \\ge Y_{n+1}\\Delta\\alpha\n$$\n现在我们必须分析右侧项 $\\,Y_{n+1}\\Delta\\alpha\\,$。演化法则 $\\,Y = \\partial\\Phi(v)\\,$（其中 $\\,v=\\dot{\\alpha}\\,$）的后向欧拉（BE）时间离散是：\n$$\nY_{n+1} = \\partial\\Phi(v_{n+1}) \\quad \\text{其中} \\quad v_{n+1} = \\frac{\\Delta\\alpha}{\\Delta t}\n$$\n将此代入我们不等式的右侧：\n$$\nY_{n+1}\\Delta\\alpha = \\partial\\Phi(v_{n+1}) \\cdot (\\Delta t \\, v_{n+1}) = \\Delta t \\, v_{n+1}\\partial\\Phi(v_{n+1})\n$$\n耗散势 $\\,\\Phi(v)\\,$ 被给定为一个非负的凸函数。对于任何可微凸函数 $\\,g(x)\\,$，不等式 $\\,g(x) - g(y) \\ge g'(y)(x-y)\\,$ 成立。我们选择 $\\,g(v) = \\Phi(v)\\,$，令 $\\,x=0\\,$ 和 $\\,y=v_{n+1}\\,$。这得到：\n$$\n\\Phi(0) - \\Phi(v_{n+1}) \\ge \\partial\\Phi(v_{n+1})(0 - v_{n+1}) = -v_{n+1}\\partial\\Phi(v_{n+1})\n$$\n对于耗散势，通常假设 $\\,\\Phi(0) = 0\\,$，这与给定的形式 $\\,\\Phi(v)=\\tfrac{1}{2}\\eta v^2\\,$ 一致。因此，该不等式简化为 $\\,-\\Phi(v_{n+1}) \\ge -v_{n+1}\\partial\\Phi(v_{n+1})\\,$，或：\n$$\nv_{n+1}\\partial\\Phi(v_{n+1}) \\ge \\Phi(v_{n+1})\n$$\n由于 $\\,\\Phi\\,$ 也是非负的，我们有 $\\,\\Phi(v_{n+1}) \\ge 0\\,$。结合这些结果：\n$$\nY_{n+1}\\Delta\\alpha = \\Delta t \\, v_{n+1}\\partial\\Phi(v_{n+1}) \\ge \\Delta t \\, \\Phi(v_{n+1}) \\ge 0\n$$\n因此，我们证明了 $\\,\\Delta D \\ge Y_{n+1}\\Delta\\alpha \\ge 0\\,$。只要我们的初始假设成立，即**亥姆霍兹自由能 $\\,\\psi(\\varepsilon, \\alpha)\\,$ 必须是其参数 $\\,(\\varepsilon, \\alpha)\\,$ 的凸函数**，那么离散耗散的非负性 $\\,\\Delta D \\ge 0\\,$ 就能对任意时间步长 $\\,\\Delta t  0\\,$ 得到保证（无条件稳定性）。\n\n对于特定的能量函数 $\\,\\psi(\\varepsilon,\\alpha) = \\tfrac{1}{2}\\,E\\,\\varepsilon^2 + \\tfrac{1}{2}\\,H\\,\\alpha^2 + C\\,\\varepsilon\\,\\alpha\\,$，其凸性取决于其Hessian矩阵是否为半正定。Hessian矩阵为：\n$$\n\\mathbf{H}_{\\psi} = \\begin{pmatrix} \\partial^2_{\\varepsilon\\varepsilon}\\psi  \\partial^2_{\\varepsilon\\alpha}\\psi \\\\ \\partial^2_{\\alpha\\varepsilon}\\psi  \\partial^2_{\\alpha\\alpha}\\psi \\end{pmatrix} = \\begin{pmatrix} E  C \\\\ C  H \\end{pmatrix}\n$$\n要使 $\\,\\mathbf{H}_{\\psi}\\,$ 为半正定，其主子式必须为非负。\n1. 第一个主子式是 $\\,E \\ge 0\\,$。问题指定了 $\\,E  0\\,$。\n2. 第二个主子式是行列式 $\\,\\det(\\mathbf{H}_{\\psi}) = EH - C^2 \\ge 0\\,$。\n因此，对于此特定模型，无条件稳定性（即对所有 $\\,\\Delta t  0\\,$ 都有 $\\,\\Delta D \\ge 0\\,$）的充分条件是 $\\,EH - C^2 \\ge 0\\,$。\n\n### 任务 B：算法实现与计算\n\n该算法包括实现内变量 $\\,\\alpha\\,$ 的后向欧拉更新，然后计算离散耗散 $\\,\\Delta D\\,$。\n\n**1. 后向欧拉更新算法**\n$\\alpha\\,$ 的演化由耦合时间 $\\,t_{n+1}\\,$ 时的热力学力定义来决定：\n$$\nY_{n+1} = -\\partial_{\\alpha}\\psi(\\varepsilon_{n+1}, \\alpha_{n+1}) \\qquad \\text{和} \\qquad Y_{n+1} = \\partial_v\\Phi(v_{n+1})\n$$\n对于给定的函数：\n$\\,\\partial_{\\alpha}\\psi = H\\alpha + C\\varepsilon \\implies Y_{n+1} = -(H\\alpha_{n+1} + C\\varepsilon_{n+1})\\,$\n$\\,\\partial_v\\Phi = \\eta v \\implies Y_{n+1} = \\eta v_{n+1} = \\eta\\frac{\\alpha_{n+1} - \\alpha_n}{\\Delta t}\\,$\n令 $\\,Y_{n+1}\\,$ 的两个表达式相等：\n$$\n\\eta\\frac{\\alpha_{n+1} - \\alpha_n}{\\Delta t} = -H\\alpha_{n+1} - C\\varepsilon_{n+1}\n$$\n这是一个关于 $\\,\\alpha_{n+1}\\,$ 的线性方程。求解 $\\,\\alpha_{n+1}\\,$：\n$$\n\\left(\\frac{\\eta}{\\Delta t} + H\\right)\\alpha_{n+1} = \\frac{\\eta}{\\Delta t}\\alpha_n - C\\varepsilon_{n+1}\n$$\n$$\n\\alpha_{n+1} = \\frac{\\frac{\\eta}{\\Delta t}\\alpha_n - C\\varepsilon_{n+1}}{\\frac{\\eta}{\\Delta t} + H}\n$$\n该公式允许在给定 $\\,t_n\\,$ 时刻的状态和规定的应变 $\\,\\varepsilon_{n+1} = \\varepsilon_n + \\Delta\\varepsilon\\,$ 的情况下，直接计算 $\\,\\alpha_{n+1}\\,$。\n\n**2. $\\Delta D\\,$ 的计算**\n对每个测试用例，依次执行以下步骤：\na. 计算 $\\,\\varepsilon_{n+1} = \\varepsilon_n + \\Delta\\varepsilon\\,$。\nb. 使用推导的更新公式计算 $\\,\\alpha_{n+1}\\,$。\nc. 计算自由能 $\\,\\psi_n = \\psi(\\varepsilon_n, \\alpha_n)\\,$ 和 $\\,\\psi_{n+1} = \\psi(\\varepsilon_{n+1}, \\alpha_{n+1})\\,$。\nd. 计算自由能的变化 $\\,\\Delta\\psi = \\psi_{n+1} - \\psi_n\\,$。\ne. 计算时间步结束时的应力 $\\,\\sigma_{n+1} = E\\varepsilon_{n+1} + C\\alpha_{n+1}\\,$。\nf. 计算外力功输入 $\\,W_{\\mathrm{ext}} = \\sigma_{n+1} \\Delta\\varepsilon\\,$。\ng. 计算离散耗散 $\\,\\Delta D = W_{\\mathrm{ext}} - \\Delta\\psi\\,$。\nh. 检查是否 $\\,\\Delta D \\ge -10^{-12}\\,$ 以确定布尔结果。这个小容差是为了考虑潜在的浮点数不精确性。\n\n对于给定的测试用例，用例1-4满足条件 $\\,EH - C^2 \\ge 0\\,$，因此我们预期 $\\,\\Delta D \\ge 0\\,$。对于用例5，$\\,EH - C^2 = 1(0.01) - (0.8)^2 = 0.01 - 0.64 = -0.63  0\\,$。自由能不是凸的，因此稳定性条件被违反，$\\,\\Delta D\\,$ 可能为负。Python代码实现了这一过程。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by implementing a backward Euler scheme for a 1D\n    generalized standard material model and checking the discrete dissipation\n    inequality for several test cases.\n    \"\"\"\n    \n    # Each test case is a tuple:\n    # (E, H, C, eta, dt, eps_n, alpha_n, deps)\n    test_cases = [\n        # Case 1: General convex potential (EH - C^2  0)\n        (100.0, 10.0, 3.0, 1.0, 1.0, 0.0, 0.0, 0.1),\n        # Case 2: Boundary convex potential (EH - C^2 = 0)\n        (4.0, 1.0, 2.0, 1.0, 1.0, 0.0, 0.0, 0.1),\n        # Case 3: Convex potential, very small time step (approaches elastic response)\n        (50.0, 2.0, 3.0, 0.5, 1e-6, 0.0, 0.0, 0.2),\n        # Case 4: Convex potential, very large time step (approaches relaxed response)\n        (50.0, 2.0, 3.0, 0.5, 1e6, 0.0, 0.0, 0.2),\n        # Case 5: Nonconvex potential (EH - C^2  0)\n        (1.0, 0.01, 0.8, 0.01, 1.0, 0.0, 0.0, 0.1)\n    ]\n    \n    results = []\n\n    for E, H, C, eta, dt, eps_n, alpha_n, deps in test_cases:\n        # Step a: Compute strain at the end of the step\n        eps_n_plus_1 = eps_n + deps\n\n        # Step b: Compute internal variable alpha_n+1 using the BE update rule\n        # The update rule is derived by equating the two expressions for Y_{n+1}:\n        # eta/dt * (alpha_{n+1} - alpha_n) = -(H * alpha_{n+1} + C * eps_{n+1})\n        # (eta/dt + H) * alpha_{n+1} = (eta/dt * alpha_n) - C * eps_{n+1}\n        # alpha_{n+1} = ((eta/dt * alpha_n) - C * eps_{n+1}) / (eta/dt + H)\n        numerator = (eta / dt) * alpha_n - C * eps_n_plus_1\n        denominator = (eta / dt) + H\n        alpha_n_plus_1 = numerator / denominator\n\n        # Helper function for Helmholtz free energy Psi(epsilon, alpha)\n        def psi(eps, alpha):\n            return 0.5 * E * eps**2 + 0.5 * H * alpha**2 + C * eps * alpha\n\n        # Step c: Compute free energies at t_n and t_{n+1}\n        psi_n = psi(eps_n, alpha_n)\n        psi_n_plus_1 = psi(eps_n_plus_1, alpha_n_plus_1)\n\n        # Step d: Compute the change in free energy\n        delta_psi = psi_n_plus_1 - psi_n\n\n        # Step e: Compute stress sigma_{n+1}\n        # sigma = d(Psi)/d(epsilon) = E*epsilon + C*alpha\n        sigma_n_plus_1 = E * eps_n_plus_1 + C * alpha_n_plus_1\n\n        # Step f: Compute external work input\n        W_ext = sigma_n_plus_1 * deps\n\n        # Step g: Compute the discrete dissipation\n        delta_D = W_ext - delta_psi\n        \n        # Step h: Check the dissipation inequality with a numerical tolerance\n        is_dissipation_non_negative = delta_D = -1e-12\n        results.append(is_dissipation_non_negative)\n\n    # Format output as a list of booleans, converted to string without spaces.\n    # str(True) - 'True', str(False) - 'False'\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}