{
    "hands_on_practices": [
        {
            "introduction": "像Ogden模型这样的超弹性模型，其参数乍看之下可能显得抽象。为了建立物理直觉，将它们与我们所熟悉的线弹性常数联系起来至关重要。本练习  将引导您完成将超弹性体积应变能函数线性化的过程，以推导出其对应的小应变体积模量 $K$ 和泊松比 $\\nu$，从而阐明模型参数的物理意义。",
            "id": "3585996",
            "problem": "考虑一个可压缩各向同性超弹性固体，其模型采用 Ogden 类型的解耦自由能，单位参考体积的总 Helmholtz 自由能写作 $W(\\mathbf{F}) = W_{\\text{iso}}(\\bar{\\mathbf{F}}) + U(J)$。其中，$\\mathbf{F}$ 是变形梯度，$J = \\det \\mathbf{F}$ 是雅可比行列式，$\\bar{\\mathbf{F}} = J^{-1/3} \\mathbf{F}$ 是变形梯度的等容部分。等容能 $W_{\\text{iso}}(\\bar{\\mathbf{F}})$ 经过标定，使其小应变极限能够再现目标剪切模量 $\\mu > 0$，而体积罚函数 $U(J)$ 决定了材料的抗体积膨胀能力。在小应变体系中，这种解耦确保了等容部分仅对偏应力有贡献，而体积部分则控制球应力。\n\n从第一 Piola–Kirchhoff 应力的超弹性定义 $\\mathbf{P} = \\partial W / \\partial \\mathbf{F}$、恒等式 $\\partial J / \\partial \\mathbf{F} = J \\mathbf{F}^{-T}$ 以及在参考构型附近的线性化（无穷小应变张量 $\\boldsymbol{\\epsilon}$ 满足 $J = 1 + \\operatorname{tr}(\\boldsymbol{\\epsilon}) + \\mathcal{O}(|\\boldsymbol{\\epsilon}|^{2})$）出发，推导由以下每种体积势函数所蕴含的小应变静水响应：\n- 情况 A (Hencky 型体积能): $U(J) = \\frac{\\kappa}{2}(\\ln J)^{2}$，其中 $\\kappa > 0$。\n- 情况 B (广义多项式体积能): $U(J) = \\frac{1}{D}(J - 1)^{2}$，其中 $D > 0$。\n\n利用这些推导：\n1. 计算每种情况下在参考状态 $J = 1$ 时的小应变体积模量。\n2. 使用解耦的小应变极限 $\\boldsymbol{\\sigma} \\approx 2 \\mu \\operatorname{dev}(\\boldsymbol{\\epsilon}) + K \\operatorname{tr}(\\boldsymbol{\\epsilon}) \\mathbf{I}$，其中 $\\boldsymbol{\\sigma}$ 是 Cauchy 应力，$\\operatorname{dev}(\\boldsymbol{\\epsilon}) = \\boldsymbol{\\epsilon} - \\tfrac{1}{3} \\operatorname{tr}(\\boldsymbol{\\epsilon}) \\mathbf{I}$，且 $K$ 是在第 1 项中获得的体积模量，推导每种情况下对应的泊松比 $\\nu$（用 $\\mu$ 和 $K$ 表示）。\n\n将您的最终答案表示为一个单一的闭式解析表达式，其中按顺序包含 $\\{K_{\\text{A}}, \\nu_{\\text{A}}, K_{\\text{B}}, \\nu_{\\text{B}}\\}$ 这四个量，下标 A 和 B 分别指代上述两种体积势函数。不需要进行数值计算，并且您必须以无单位的形式表达最终答案。如果您引入任何来自各向同性线弹性的辅助关系，请从本问题给出的定义中推导它们，而不是直接引用。由于答案是符号形式，因此不适用四舍五入。",
            "solution": "我们从一般的超弹性框架开始。单位参考体积的总自由能为 $W(\\mathbf{F}) = W_{\\text{iso}}(\\bar{\\mathbf{F}}) + U(J)$，其中 $J = \\det \\mathbf{F}$ 且 $\\bar{\\mathbf{F}} = J^{-1/3} \\mathbf{F}$。第一 Piola–Kirchhoff 应力为\n$$\n\\mathbf{P} = \\frac{\\partial W}{\\partial \\mathbf{F}} = \\frac{\\partial W_{\\text{iso}}}{\\partial \\mathbf{F}} + \\frac{\\partial U}{\\partial J} \\frac{\\partial J}{\\partial \\mathbf{F}}。\n$$\n使用恒等式 $\\frac{\\partial J}{\\partial \\mathbf{F}} = J \\mathbf{F}^{-T}$，对 $\\mathbf{P}$ 的体积贡献为\n$$\n\\mathbf{P}_{\\text{vol}} = U'(J) \\, J \\, \\mathbf{F}^{-T},\n$$\n其中 $U'(J) = \\frac{d U}{d J}$。Cauchy 应力 $\\boldsymbol{\\sigma}$ 由 $\\boldsymbol{\\sigma} = \\frac{1}{J} \\mathbf{P} \\mathbf{F}^{T}$ 给出。因此，Cauchy 应力的体积部分为\n$$\n\\boldsymbol{\\sigma}_{\\text{vol}} = \\frac{1}{J} \\mathbf{P}_{\\text{vol}} \\mathbf{F}^{T} = \\frac{1}{J} \\left( U'(J) \\, J \\, \\mathbf{F}^{-T} \\right) \\mathbf{F}^{T} = U'(J) \\, \\mathbf{I}。\n$$\n因此，对 Cauchy 应力的体积贡献是纯球形的，其大小为 $U'(J)$。\n\n接下来，我们考虑小应变极限。设 $\\boldsymbol{\\epsilon}$ 为无穷小应变张量，并在参考构型附近展开 $J$：\n$$\nJ = 1 + \\operatorname{tr}(\\boldsymbol{\\epsilon}) + \\mathcal{O}(|\\boldsymbol{\\epsilon}|^{2})。\n$$\n我们还将 $U'(J)$ 在 $J = 1$ 附近展开：\n$$\nU'(J) = U'(1) + U''(1) (J - 1) + \\mathcal{O}((J - 1)^{2})。\n$$\n对于无应力参考构型，我们需要 $U'(1) = 0$，给出的两种体积形式都满足此条件。保留应变的一阶项，\n$$\n\\boldsymbol{\\sigma}_{\\text{vol}} \\approx U''(1) (J - 1) \\mathbf{I} \\approx U''(1) \\, \\operatorname{tr}(\\boldsymbol{\\epsilon}) \\, \\mathbf{I}。\n$$\n由于使用 $\\bar{\\mathbf{F}} = J^{-1/3} \\mathbf{F}$ 实现了等容-体积解耦，等容能 $W_{\\text{iso}}(\\bar{\\mathbf{F}})$ 在小应变下仅对偏应力有贡献，并被标定以产生目标剪切模量 $\\mu$。因此，完整的小应变 Cauchy 应力具有以下形式\n$$\n\\boldsymbol{\\sigma} \\approx 2 \\mu \\, \\operatorname{dev}(\\boldsymbol{\\epsilon}) + K \\, \\operatorname{tr}(\\boldsymbol{\\epsilon}) \\, \\mathbf{I},\n$$\n其中\n$$\nK = U''(1)。\n$$\n\n我们现在为每种体积势函数计算 $U''(1)$。\n\n情况 A: $U(J) = \\frac{\\kappa}{2} (\\ln J)^{2}$。\n计算一阶导数：\n$$\nU'(J) = \\kappa \\, \\frac{\\ln J}{J}。\n$$\n计算二阶导数：\n$$\nU''(J) = \\kappa \\, \\frac{d}{dJ} \\left( \\frac{\\ln J}{J} \\right) = \\kappa \\, \\frac{1 - \\ln J}{J^{2}}。\n$$\n在 $J = 1$ 处求值：\n$$\nU''(1) = \\kappa \\, \\frac{1 - \\ln 1}{1^{2}} = \\kappa。\n$$\n因此，情况 A 的体积模量为\n$$\nK_{\\text{A}} = \\kappa。\n$$\n\n情况 B: $U(J) = \\frac{1}{D} (J - 1)^{2}$。\n计算一阶导数：\n$$\nU'(J) = \\frac{2}{D} (J - 1)。\n$$\n计算二阶导数：\n$$\nU''(J) = \\frac{2}{D}。\n$$\n在 $J = 1$ 处求值：\n$$\nU''(1) = \\frac{2}{D}。\n$$\n因此，情况 B 的体积模量为\n$$\nK_{\\text{B}} = \\frac{2}{D}。\n$$\n\n为了获得泊松比，我们将小应变表示与各向同性线弹性中以拉梅参数表示的标准双参数描述联系起来。在一个解耦的超弹性模型中，其小应变形式为 $\\boldsymbol{\\sigma} = 2 \\mu \\, \\operatorname{dev}(\\boldsymbol{\\epsilon}) + K \\, \\operatorname{tr}(\\boldsymbol{\\epsilon}) \\, \\mathbf{I}$，等效的拉梅参数为\n$$\n\\lambda = K - \\frac{2}{3} \\mu, \\quad \\mu = \\mu。\n$$\n对于各向同性线弹性材料，用 $\\lambda$ 和 $\\mu$ 表示的泊松比 $\\nu$ 为\n$$\n\\nu = \\frac{\\lambda}{2 (\\lambda + \\mu)}。\n$$\n代入 $\\lambda = K - \\frac{2}{3} \\mu$，\n\\begin{align*}\n\\nu = \\frac{K - \\frac{2}{3} \\mu}{2 \\left( K - \\frac{2}{3} \\mu + \\mu \\right)}\n= \\frac{K - \\frac{2}{3} \\mu}{2 \\left( K + \\frac{1}{3} \\mu \\right)}\n= \\frac{3 K - 2 \\mu}{2 (3 K + \\mu)}。\n\\end{align*}\n因此，对于每种情况，\n- 情况 A：$K_{\\text{A}} = \\kappa$ 且\n$$\n\\nu_{\\text{A}} = \\frac{3 \\kappa - 2 \\mu}{2 (3 \\kappa + \\mu)}。\n$$\n- 情况 B：$K_{\\text{B}} = \\frac{2}{D}$ 且\n$$\n\\nu_{\\text{B}} = \\frac{3 \\left( \\frac{2}{D} \\right) - 2 \\mu}{2 \\left( 3 \\left( \\frac{2}{D} \\right) + \\mu \\right)} = \\frac{\\frac{6}{D} - 2 \\mu}{2 \\left( \\frac{6}{D} + \\mu \\right)}。\n$$\n\n这些表达式完成了在参考状态下体积模量的推导，以及针对指定的体积能，用目标剪切模量 $\\mu$ 表示的相应泊松比的推导。",
            "answer": "$$\\boxed{\\begin{pmatrix} \\kappa & \\frac{3 \\kappa - 2 \\mu}{2 (3 \\kappa + \\mu)} & \\frac{2}{D} & \\frac{\\frac{6}{D} - 2 \\mu}{2 \\left( \\frac{6}{D} + \\mu \\right)} \\end{pmatrix}}$$"
        },
        {
            "introduction": "一个有效的本构模型不仅要能拟合数据，还必须遵循基本的物理原理，例如材料稳定性。Baker-Ericksen 不等式是一个关键要求，它确保了越大的主拉伸对应越大的主应力。本练习  要求您推导出Ogden模型参数为满足此准则而必须遵守的条件，这是构建物理上真实的材料模型的关键一步。",
            "id": "3586040",
            "problem": "一个不可压缩、各向同性的超弹性固体由一个应变能密度 $W(\\lambda_1,\\lambda_2,\\lambda_3)$ 定义，该函数对主伸长 $\\lambda_i$ 对称，并受约束 $\\lambda_1 \\lambda_2 \\lambda_3 = 1$。Baker–Ericksen (BE) 不等式要求，对于任意两个不同的主伸长 $\\lambda_i \\ne \\lambda_j$，相应的主柯西应力满足 $(\\sigma_i - \\sigma_j)(\\lambda_i - \\lambda_j) > 0$，等号仅在 $\\lambda_i = \\lambda_j$ 时成立。柯西应力由超弹性本构律和一个施加不可压缩性约束的拉格朗日乘子得到。\n\n考虑具有以下应变能密度的 $N$ 项不可压缩Ogden模型\n$$\nW(\\lambda_1,\\lambda_2,\\lambda_3) = \\sum_{p=1}^N \\frac{\\mu_p}{\\alpha_p} \\left(\\lambda_1^{\\alpha_p} + \\lambda_2^{\\alpha_p} + \\lambda_3^{\\alpha_p} - 3\\right),\n$$\n其中 $\\alpha_p \\in \\mathbb{R}\\setminus\\{0\\}$ 和 $\\mu_p \\in \\mathbb{R}$ 是材料参数，而因子-3确保在参考状态 $\\lambda_1=\\lambda_2=\\lambda_3=1$ 时能量为零。\n\n从不可压缩材料的超弹性响应定义出发，推导主柯西应力，然后获得关于 $\\{\\mu_p,\\alpha_p\\}$ 的一个条件，该条件保证Baker–Ericksen不等式对所有具有有序主伸长 $\\lambda_i > \\lambda_j$ 的等体积状态成立。根据您的推导，关于这些参数的以下哪个陈述是保证Baker–Ericksen不等式对所有 $\\lambda_i \\ne \\lambda_j$ 都严格成立的充分必要条件？\n\nA. 对所有 $p$ 都有 $\\mu_p > 0$ 和 $\\alpha_p > 0$。\n\nB. 对所有 $\\alpha_p \\ne 0$ 的 $p$ 都有 $\\mu_p \\alpha_p > 0$。\n\nC. $\\sum_{p=1}^N \\mu_p > 0$，其中 $\\alpha_p \\ne 0$ 是任意的。\n\nD. 对所有 $p$ 都有 $\\mu_p \\ge 0$，其中 $\\alpha_p \\in \\mathbb{R}$ 是任意的。\n\nE. $\\mu_p$ 任意，且所有 $\\alpha_p$ 都是正奇数。",
            "solution": "## 问题验证\n\n### 步骤 1: 提取已知条件\n-   材料是不可压缩、各向同性的超弹性固体。\n-   应变能密度为 $W(\\lambda_1,\\lambda_2,\\lambda_3)$，它对主伸长 $\\lambda_i$ 对称。\n-   不可压缩性约束为 $\\lambda_1 \\lambda_2 \\lambda_3 = 1$。\n-   Baker–Ericksen (BE) 不等式为 $(\\sigma_i - \\sigma_j)(\\lambda_i - \\lambda_j) > 0$，适用于任意两个不同的主伸长 $\\lambda_i \\ne \\lambda_j$，其中 $\\sigma_i$ 是主柯西应力。\n-   N项不可压缩Ogden模型的应变能密度由下式给出：\n    $$ W(\\lambda_1,\\lambda_2,\\lambda_3) = \\sum_{p=1}^N \\frac{\\mu_p}{\\alpha_p} \\left(\\lambda_1^{\\alpha_p} + \\lambda_2^{\\alpha_p} + \\lambda_3^{\\alpha_p} - 3\\right) $$\n-   材料参数为 $\\alpha_p \\in \\mathbb{R}\\setminus\\{0\\}$ 和 $\\mu_p \\in \\mathbb{R}$。\n\n### 步骤 2: 使用提取的已知条件进行验证\n1.  **科学依据：** 该问题基于完善的非线性弹性力学和超弹性理论。Ogden模型、不可压缩性约束和Baker–Ericksen不等式是连续介质力学中的标准概念。\n2.  **适定性：** 该问题要求找出模型参数满足特定物理稳定性判据的充分必要条件。可以推导出一个唯一的条件。\n3.  **客观性：** 该问题以精确的数学和物理术语陈述，不含主观性。\n4.  **不存在其他缺陷**（如不完整、矛盾、不切实际、不适定等）。问题陈述是自洽且逻辑的。\n\n### 步骤 3: 结论与行动\n问题有效。现在开始求解过程。\n\n## 推导与分析\n\n对于不可压缩、各向同性的超弹性材料，主柯西应力 $\\sigma_i$ 与应变能密度函数 $W(\\lambda_1, \\lambda_2, \\lambda_3)$ 通过以下公式相关：\n$$ \\sigma_i = -p + \\lambda_i \\frac{\\partial W}{\\partial \\lambda_i} $$\n其中 $p$ 是一个任意的静水压力（施加不可压缩性约束的拉格朗日乘子）。$p$ 的具体值取决于边界条件，但在考虑应力差时它会被消去。\n\n我们来计算两个主应力之差，$\\sigma_i$ 和 $\\sigma_j$：\n$$ \\sigma_i - \\sigma_j = \\left(-p + \\lambda_i \\frac{\\partial W}{\\partial \\lambda_i}\\right) - \\left(-p + \\lambda_j \\frac{\\partial W}{\\partial \\lambda_j}\\right) = \\lambda_i \\frac{\\partial W}{\\partial \\lambda_i} - \\lambda_j \\frac{\\partial W}{\\partial \\lambda_j} $$\n现在，我们代入给定的Ogden模型应变能密度函数：\n$$ W = \\sum_{p=1}^N \\frac{\\mu_p}{\\alpha_p} \\left(\\lambda_1^{\\alpha_p} + \\lambda_2^{\\alpha_p} + \\lambda_3^{\\alpha_p} - 3\\right) $$\n$W$ 对主伸长 $\\lambda_k$ 的偏导数为：\n$$ \\frac{\\partial W}{\\partial \\lambda_k} = \\sum_{p=1}^N \\frac{\\mu_p}{\\alpha_p} \\left( \\alpha_p \\lambda_k^{\\alpha_p - 1} \\right) = \\sum_{p=1}^N \\mu_p \\lambda_k^{\\alpha_p - 1} $$\n乘以 $\\lambda_k$ 得到：\n$$ \\lambda_k \\frac{\\partial W}{\\partial \\lambda_k} = \\lambda_k \\sum_{p=1}^N \\mu_p \\lambda_k^{\\alpha_p - 1} = \\sum_{p=1}^N \\mu_p \\lambda_k^{\\alpha_p} $$\n因此，主应力差为：\n$$ \\sigma_i - \\sigma_j = \\sum_{p=1}^N \\mu_p \\lambda_i^{\\alpha_p} - \\sum_{p=1}^N \\mu_p \\lambda_j^{\\alpha_p} = \\sum_{p=1}^N \\mu_p \\left( \\lambda_i^{\\alpha_p} - \\lambda_j^{\\alpha_p} \\right) $$\nBaker–Ericksen (BE) 不等式为 $(\\sigma_i - \\sigma_j)(\\lambda_i - \\lambda_j) > 0$ (当 $\\lambda_i \\ne \\lambda_j$)。代入我们的应力差表达式可得：\n$$ (\\lambda_i - \\lambda_j) \\sum_{p=1}^N \\mu_p \\left( \\lambda_i^{\\alpha_p} - \\lambda_j^{\\alpha_p} \\right) > 0 $$\n由于 $\\lambda_i \\ne \\lambda_j$，所以 $(\\lambda_i - \\lambda_j)^2 > 0$。我们可以用这个正量来除不等式，而不会改变其方向：\n$$ \\sum_{p=1}^N \\mu_p \\frac{\\lambda_i^{\\alpha_p} - \\lambda_j^{\\alpha_p}}{\\lambda_i - \\lambda_j} > 0 $$\n我们来分析 $S_p = \\frac{\\lambda_i^{\\alpha_p} - \\lambda_j^{\\alpha_p}}{\\lambda_i - \\lambda_j}$ 这一项。这是函数 $f(t) = t^{\\alpha_p}$ 在 $\\lambda_j$ 和 $\\lambda_i$ 之间的区间上的割线斜率。根据中值定理，在 $\\lambda_j$ 和 $\\lambda_i$ 之间存在一个值 $c_p$，使得 $S_p = f'(c_p) = \\alpha_p c_p^{\\alpha_p - 1}$。由于主伸长是正的，$\\lambda_i, \\lambda_j > 0$，这意味着 $c_p > 0$。因此，对于任何实数指数 $\\alpha_p$，$c_p^{\\alpha_p-1} > 0$。所以，$S_p$ 的符号完全由 $\\alpha_p$ 的符号决定：\n$$ \\text{sign}\\left(\\frac{\\lambda_i^{\\alpha_p} - \\lambda_j^{\\alpha_p}}{\\lambda_i - \\lambda_j}\\right) = \\text{sign}(\\alpha_p) $$\nBE不等式可以表示为：\n$$ \\sum_{p=1}^N \\mu_p \\cdot S_p > 0 $$\n我们将 $S_p$ 写为 $S_p = \\alpha_p K_p$，其中 $K_p = c_p^{\\alpha_p - 1} = \\frac{1}{\\alpha_p} \\frac{\\lambda_i^{\\alpha_p} - \\lambda_j^{\\alpha_p}}{\\lambda_i - \\lambda_j}$。由于 $\\alpha_p$ 和 $S_p$ 符号相同，所以 $K_p$ 恒为正。不等式变为：\n$$ \\sum_{p=1}^N (\\mu_p \\alpha_p) K_p(\\lambda_i, \\lambda_j, \\alpha_p) > 0 $$\n这个不等式是系数 $(\\mu_p \\alpha_p)$ 和正权重函数 $K_p$ 乘积的和，它必须对所有可能的等体积状态（即对所有允许的 $\\lambda_i, \\lambda_j > 0$ 选择）都成立。\n\n**充分性：** 如果我们强制要求对所有 $p=1, ..., N$ 都有 $\\mu_p \\alpha_p > 0$，那么求和中的每一项 $(\\mu_p \\alpha_p) K_p$ 都是两个正数的乘积，因此是正的。严格为正的项之和也严格为正。因此，对所有 $p$ 都有 $\\mu_p \\alpha_p > 0$ 这个条件足以保证BE不等式成立。\n\n**必要性：** 我们必须证明，如果该条件不被满足，则至少存在一个变形状态，使得BE不等式被违反。假设对所有 $p$ 都有 $\\mu_p \\alpha_p > 0$ 的条件是错误的。鉴于问题陈述 $\\alpha_p \\ne 0$，这意味着至少存在一个索引 $k$ 使得 $\\mu_k \\alpha_k \\le 0$。（$\\mu_k \\alpha_k=0$ 的情况将在下面讨论）。\n设索引集合被划分为 $P_+ = \\{p | \\mu_p \\alpha_p > 0 \\}$ 和 $P_- = \\{p | \\mu_p \\alpha_p < 0 \\}$。根据假设，$P_-$ 是非空的。条件是：\n$$ \\sum_{p \\in P_+} |\\mu_p \\alpha_p| K_p - \\sum_{k \\in P_-} |\\mu_k \\alpha_k| K_k > 0 $$\n权重函数 $K_p = \\frac{1}{\\lambda_i - \\lambda_j} \\int_{\\lambda_j}^{\\lambda_i} t^{\\alpha_p - 1} dt$ 的大小强烈依赖于指数 $\\alpha_p$ 和变形范围 $[\\lambda_j, \\lambda_i]$。\n-   对于大伸长（$\\lambda_i \\to \\infty$，$\\lambda_j$ 固定），$K_p$ 对最大的 $\\alpha_p$ 值增长最快。\n-   对于大压缩（$\\lambda_j \\to 0$，$\\lambda_i$ 固定），$K_p$ 对最小的（最负的）$\\alpha_p$ 值增长最快。\n\n如果存在一个项 $k \\in P_-$，使得 $\\alpha_k$ 大于所有 $p \\in P_+$ 的 $\\alpha_p$，那么通过选择一个大拉伸状态（大的 $\\lambda_i$），负项 $|\\mu_k \\alpha_k| K_k$ 将在和中占主导地位，导致不等式被违反。\n类似地，如果有一个项 $k \\in P_-$，其中 $\\alpha_k$ 小于所有 $p \\in P_+$ 的 $\\alpha_p$，那么在一个大压缩状态（小的 $\\lambda_j$）下，其相应的项 $K_k$ 将占主导地位，再次违反不等式。\n对于任何指数集合，总能找到一个变形状态 $(\\lambda_i, \\lambda_j)$，它能够将 $\\mu_k \\alpha_k < 0$ 的项的权重 $K_k$ 相对于 $\\mu_p \\alpha_p > 0$ 的项的权重充分放大，从而违反BE条件。\n因此，为了使不等式对*所有*等体积状态都成立，不能有 $\\mu_p \\alpha_p < 0$ 的项。这意味着 $\\mu_p \\alpha_p \\ge 0$ 是一个必要条件。\n\n对于严格不等式，我们需要和严格为正，这意味着至少有一项必须非零。“N项Ogden模型”的措辞意味着有N个非零项，因此对所有 $p=1,...,N$ 都有 $\\mu_p \\ne 0$。在这种标准解释下，条件 $\\mu_p \\alpha_p \\ge 0$ 变为 $\\mu_p \\alpha_p > 0$，因为 $\\mu_p$ 和 $\\alpha_p$ 都不能为零。因此，对所有 $p$ 都有 $\\mu_p \\alpha_p > 0$ 这个条件是充分且必要的。\n\n## 逐项分析\n\nA. **对所有 $p$ 都有 $\\mu_p > 0$ 和 $\\alpha_p > 0$。**\n这个条件意味着对所有 $p$ 都有 $\\mu_p \\alpha_p > 0$。如上所示，这是一个充分条件。然而，它不是必要的。例如，一个具有 $\\mu_p < 0$ 和 $\\alpha_p < 0$ 的项同样得出 $\\mu_p \\alpha_p > 0$，并对满足BE不等式做出正向贡献。因此，这个选项作为必要条件限制性太强。\n**结论：不正确。**\n\nB. **对所有 $\\alpha_p \\ne 0$ 的 $p$ 都有 $\\mu_p \\alpha_p > 0$。**\n问题陈述已指明对所有 $p$ 都有 $\\alpha_p \\ne 0$。因此，此条件等价于对所有 $p$ 都有 $\\mu_p \\alpha_p > 0$。如上所推导，此条件既是必要的（在所有N个项都是非平凡项的标准解释下），也是充分的，可以保证BE不等式对所有变形都严格成立。\n**结论：正确。**\n\nC. **$\\sum_{p=1}^N \\mu_p > 0$，其中 $\\alpha_p \\ne 0$ 是任意的。**\n这个条件不充分。考虑一个双项模型，其中 $\\mu_1 = 10$, $\\alpha_1=2$ 和 $\\mu_2=-1$, $\\alpha_2=4$。这里 $\\sum \\mu_p = 9 > 0$。BE条件要求 $10\\frac{\\lambda_i^2 - \\lambda_j^2}{\\lambda_i - \\lambda_j} - 1\\frac{\\lambda_i^4 - \\lambda_j^4}{\\lambda_i - \\lambda_j} > 0$。这可以简化为 $10(\\lambda_i+\\lambda_j) - (\\lambda_i+\\lambda_j)(\\lambda_i^2+\\lambda_j^2) > 0$，即 $10 - (\\lambda_i^2+\\lambda_j^2) > 0$。这个不等式显然不适用于所有伸长，例如，如果 $\\lambda_i=4$。\n**结论：不正确。**\n\nD. **对所有 $p$ 都有 $\\mu_p \\ge 0$，其中 $\\alpha_p \\in \\mathbb{R}$ 是任意的。**\n这个条件允许某些 $p$ 存在 $\\mu_p > 0$ 和 $\\alpha_p < 0$ 的情况。在这种情况下，$\\mu_p \\alpha_p < 0$，我们已经证明这违反了必要性。例如，设 $N=1, \\mu_1=1>0, \\alpha_1=-2$。BE不等式变为 $1 \\cdot (\\lambda_i^{-2} - \\lambda_j^{-2})(\\lambda_i - \\lambda_j) > 0$。如果我们取 $\\lambda_i > \\lambda_j$，那么 $\\lambda_i^{-2} < \\lambda_j^{-2}$，使得第一项为负，而第二项为正。它们的乘积为负，违反了该不等式。\n**结论：不正确。**\n\nE. **$\\mu_p$ 任意，且所有 $\\alpha_p$ 都是正奇数。**\n这不充分。如果我们选择 $\\mu_p < 0$ 且 $\\alpha_p$ 为正整数（无论是否为奇数），则 $\\mu_p \\alpha_p < 0$，这违反了必要条件。例如，设 $N=1, \\mu_1=-1, \\alpha_1=3$。BE不等式变为 $-1 \\cdot (\\lambda_i^3 - \\lambda_j^3)(\\lambda_i - \\lambda_j) > 0$。对于 $\\lambda_i \\ne \\lambda_j$，左边的两个因子符号相同，使其乘积为正。乘以-1使整个表达式为负，违反了该不等式。\n**结论：不正确。**",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "本构模型的最终考验是其描述真实材料行为的能力，这需要从实验数据中确定其参数。这项综合性编程练习  模拟了从生成合成数据到使用非线性优化拟合参数，并评估结果的统计可靠性的完整工作流程。通过解决噪声和参数可辨识性等问题，您将在超弹性模型的实际应用中获得宝贵的实践经验。",
            "id": "3586046",
            "problem": "构建一个完整的程序，对在单轴拉伸下的不可压缩、各向同性超弹性固体进行参数辨识和可辨识性评估，该固体由Ogden应变能函数建模。从超弹性力学的第一性原理出发：用主伸长率定义应变能密度函数，通过变形梯度的行列式等于1的约束施加不可压缩性，通过能量共轭获得主Cauchy应力，并特化到横向应力为零的单轴拉伸情况，以推导出单轴Cauchy应力作为伸长率的函数。使用此本构关系生成带有指定标准差的附加零均值高斯噪声的合成数据（所有应力以兆帕（MPa）为单位）。建立一个带边界约束的非线性最小二乘估计问题，以从含噪数据中恢复Ogden参数。使用残差映射的局部线性化来量化鲁棒性和可辨识性：从最优解处的雅可比矩阵计算近似的参数协方差矩阵，并推断出 $95\\%$ 的置信区间宽度。统计结论必须使用残差的数值、多个初始猜测下的参数变化以及置信区间进行论证。\n\n您的程序必须严格按照以下规范实现：\n\n- 使用的基本原理：\n    - 不可压缩各向同性材料的超弹性力学：应变能密度函数 $W$ 依赖于主伸长率，Cauchy应力由 $W$ 的功共轭导数与一个强制不可压缩性的拉格朗日乘子组合而成，在单轴试验中通过适当选择拉格朗日乘子来强制横向应力为零。\n    - 非线性最小二乘估计：估计器通过最小化模型预测应力与观测应力数据之间的残差平方和来进行估计。\n    - 局部统计线性化：从解处的残差雅可比矩阵近似计算Fisher信息矩阵（FIM）、参数估计的协方差和 $95\\%$ 置信区间。\n\n- 建模与数据生成：\n    1. 使用两项（$N=2$）或三项（$N=3$）的Ogden模型。Ogden应变能密度参数为配对的 $(\\mu_i,\\alpha_i)$，$i=1,\\dots,N$，其中 $\\mu_i$ 的单位是兆帕（MPa），$\\alpha_i$ 是无量纲的。对于单轴拉伸，主伸长率满足不可压缩性，且横向Cauchy应力为零。\n    2. 通过在指定的伸长率下评估推导出的Cauchy应力表达式，并添加具有指定标准差的高斯噪声，来生成合成的单轴拉伸数据。所有应力必须以MPa为单位。\n\n- 估计与可辨识性评估：\n    1. 通过使用带边界约束的非线性最小二乘法，最小化含噪数据与模型预测之间的残差平方和，来拟合Ogden参数 $(\\mu_i,\\alpha_i)$。使用在指定边界内采样的不同初始猜测值执行多次拟合。\n    2. 对于每次拟合，计算最优解处残差关于参数的雅可比矩阵。根据雅可比矩阵 $J$ 和残差 $\\mathbf{r}$，计算残差方差 $\\hat{\\sigma}^2$（即残差平方和除以自由度），近似协方差矩阵 $\\Sigma \\approx \\hat{\\sigma}^2 (J^\\top J)^{-1}$（如果 $J^\\top J$ 是病态的，则使用伪逆），以及每个参数 $i$ 的 $95\\%$ 置信区间宽度 $w_i \\approx 2 \\cdot 1.96 \\cdot \\sqrt{\\Sigma_{ii}}$。\n    3. 汇总所有初始猜测的结果以计算：\n        - 各参数中的最大相对绝对误差，定义为 $\\max_i \\left| \\hat{\\theta}_i - \\theta_i^\\star \\right| / \\left| \\theta_i^\\star \\right|$，其中 $\\hat{\\theta}_i$ 表示多次运行的平均估计值，$\\theta_i^\\star$ 表示真实参数。\n        - 各参数中的最大相对标准差，定义为 $\\max_i \\operatorname{std}(\\hat{\\theta}_i^{(k)}) / \\left| \\hat{\\theta}_i \\right|$，其中 $\\hat{\\theta}_i^{(k)}$ 是来自不同初始猜测的估计值，$\\hat{\\theta}_i$ 是它们的平均值。\n        - 各参数中的最大平均相对 $95\\%$ 置信区间宽度，定义为 $\\max_i \\overline{w_i} / \\left| \\hat{\\theta}_i \\right|$，其中 $\\overline{w_i}$ 是多次运行的平均区间宽度。\n\n- 鲁棒性判定规则：\n    - 对于每个约束方案，如果以下所有条件同时满足，则宣布拟合是鲁棒的：\n        1. 最大相对绝对误差小于或等于 $0.25$。\n        2. 最大相对标准差小于或等于 $0.30$。\n        3. 最大平均相对置信区间宽度小于或等于 $0.50$。\n    - 对于每个测试用例，仅当在下面给出的两种约束方案下鲁棒性都成立时，才宣布整体鲁棒性为真。\n\n- 约束方案与初始猜测：\n    - 宽边界：对于每个 $i$，使用 $\\mu_i \\in [0.01, 5.0]$ MPa 和 $\\alpha_i \\in [0.5, 8.0]$。\n    - 窄边界：对于每个 $i$，使用 $\\mu_i \\in [0.01, 2.0]$ MPa 和 $\\alpha_i \\in [0.5, 6.0]$。\n    - 对于每种方案，从在指定边界内均匀采样的初始猜测值开始，执行 $6$ 次独立的拟合。\n\n- 测试套件（所有应力以MPa表示；不出现角度；百分比必须视为小数）：\n    1. 案例A（快乐路径，两项Ogden，中等噪声，宽伸长范围）：\n        - 真实参数：$(\\mu_1,\\alpha_1) = (0.8, 1.3)$，$(\\mu_2,\\alpha_2) = (0.2, 5.0)$。\n        - 伸长范围：在 $[1.0, 1.6]$ 内均匀分布的 $25$ 个点。\n        - 噪声标准差：$0.02$。\n        - 模型：$N=2$ 项。\n    2. 案例B（指数相近导致接近不可辨识）：\n        - 真实参数：$(\\mu_1,\\alpha_1) = (0.5, 2.0)$，$(\\mu_2,\\alpha_2) = (0.5, 2.2)$。\n        - 伸长范围：在 $[1.0, 1.6]$ 内均匀分布的 $25$ 个点。\n        - 噪声标准差：$0.02$。\n        - 模型：$N=2$ 项。\n    3. 案例C（高噪声）：\n        - 真实参数：$(\\mu_1,\\alpha_1) = (0.6, 1.2)$，$(\\mu_2,\\alpha_2) = (0.4, 4.0)$。\n        - 伸长范围：在 $[1.0, 1.6]$ 内均匀分布的 $25$ 个点。\n        - 噪声标准差：$0.20$。\n        - 模型：$N=2$ 项。\n    4. 案例D（窄伸长范围内的有限激励，三项Ogden）：\n        - 真实参数：$(\\mu_1,\\alpha_1) = (0.3, 1.0)$，$(\\mu_2,\\alpha_2) = (0.4, 2.0)$，$(\\mu_3,\\alpha_3) = (0.3, 6.0)$。\n        - 伸长范围：在 $[1.0, 1.1]$ 内均匀分布的 $25$ 个点。\n        - 噪声标准差：$0.02$。\n        - 模型：$N=3$ 项。\n\n- 最终输出格式：\n    - 您的程序应生成单行输出，其中包含案例 A、B、C 和 D 的鲁棒性判定结果，形式为方括号内以逗号分隔的布尔值列表（例如，`[{\\rm True},{\\rm False},{\\rm True},{\\rm True}]`）。\n\n需遵守的假设：\n- 所有应力必须以兆帕（MPa）表示。\n- 不出现角度；不需要角度单位。\n- 百分比必须根据上面定义的鲁棒性阈值表示为小数。\n\n程序必须是完全自包含的，不接受任何输入，并严格遵循指定的输出格式。",
            "solution": "我们从不可压缩各向同性材料的超弹性力学原理开始。设主伸长率表示为 $\\lambda_1$、$\\lambda_2$ 和 $\\lambda_3$，不可压缩性通过约束 $\\lambda_1 \\lambda_2 \\lambda_3 = 1$ 强制施加。包含 $N$ 项的Ogden应变能函数定义为\n$$\nW(\\lambda_1,\\lambda_2,\\lambda_3) = \\sum_{i=1}^N \\frac{\\mu_i}{\\alpha_i}\\left(\\lambda_1^{\\alpha_i} + \\lambda_2^{\\alpha_i} + \\lambda_3^{\\alpha_i} - 3\\right),\n$$\n其中 $\\mu_i$ 是类剪切模量（单位为兆帕，MPa），$\\alpha_i$ 是无量纲指数。\n\n在超弹性力学中，主Cauchy应力分量 $\\sigma_k$ 通过以下方式与伸长率功共轭\n$$\n\\sigma_k = \\lambda_k \\frac{\\partial W}{\\partial \\lambda_k} - p,\n$$\n其中 $p$ 是一个与强制不可压缩性 $\\lambda_1 \\lambda_2 \\lambda_3 = 1$ 相关的拉格朗日乘子。将 $W$ 对 $\\lambda_k$ 求导得出\n$$\n\\frac{\\partial W}{\\partial \\lambda_k} = \\sum_{i=1}^N \\mu_i \\lambda_k^{\\alpha_i - 1}.\n$$\n因此，\n$$\n\\sigma_k = \\lambda_k \\sum_{i=1}^N \\mu_i \\lambda_k^{\\alpha_i - 1} - p = \\sum_{i=1}^N \\mu_i \\lambda_k^{\\alpha_i} - p.\n$$\n\n对于沿1方向的单轴拉伸，伸长率满足 $\\lambda_1 = \\lambda$，不可压缩性意味着 $\\lambda_2 = \\lambda_3 = \\lambda^{-1/2}$。施加横向应力为零，即 $\\sigma_2 = 0$ 和 $\\sigma_3 = 0$，可以确定拉格朗日乘子：\n$$\n0 = \\sigma_2 = \\sum_{i=1}^N \\mu_i \\lambda_2^{\\alpha_i} - p \\quad \\Rightarrow \\quad p = \\sum_{i=1}^N \\mu_i \\lambda^{- \\alpha_i / 2}.\n$$\n因此，单轴Cauchy应力为\n$$\n\\sigma(\\lambda; \\{\\mu_i,\\alpha_i\\}_{i=1}^N) = \\sum_{i=1}^N \\mu_i \\left( \\lambda^{\\alpha_i} - \\lambda^{-\\alpha_i / 2} \\right),\n$$\n单位为兆帕（MPa）。这就是用于生成合成数据和拟合参数的本构关系。\n\n我们通过选择一组伸长率 $\\{\\lambda_j\\}_{j=1}^M$ 并根据真实参数计算无噪声应力 $\\sigma(\\lambda_j)$ 来生成合成数据；然后我们添加零均值高斯噪声 $\\varepsilon_j \\sim \\mathcal{N}(0,\\sigma_{\\rm noise}^2)$ 以获得观测值\n$$\n\\sigma_j^{\\rm obs} = \\sigma(\\lambda_j) + \\varepsilon_j.\n$$\n\n参数辨识被构建为一个非线性最小二乘问题。给定观测数据 $(\\lambda_j, \\sigma_j^{\\rm obs})$，我们寻找参数 $\\theta = (\\mu_1,\\alpha_1,\\dots,\\mu_N,\\alpha_N)$ 以最小化\n$$\n\\min_{\\theta \\in \\mathcal{B}} \\sum_{j=1}^M \\left[\\sigma(\\lambda_j; \\theta) - \\sigma_j^{\\rm obs}\\right]^2,\n$$\n其中 $\\mathcal{B}$ 编码了对参数的边界约束。我们考虑两种约束方案：\n- 宽边界：对于所有 $i$，$\\mu_i \\in [0.01, 5.0]$ 且 $\\alpha_i \\in [0.5, 8.0]$。\n- 窄边界：对于所有 $i$，$\\mu_i \\in [0.01, 2.0]$ 且 $\\alpha_i \\in [0.5, 6.0]$。\n\n为评估在不同初始猜测下的鲁棒性，我们使用在指定边界内均匀采样的初始参数执行多次拟合（每种方案6次）。\n\n统计论证是通过在最优解处对残差映射进行局部线性化来获得的。设 $\\mathbf{r}(\\theta^\\star)$ 表示在拟合参数 $\\theta^\\star$ 处的残差向量，设 $J$ 为 $\\mathbf{r}$ 关于 $\\theta$ 的雅可比矩阵（其元素为 $J_{j,k} = \\partial r_j / \\partial \\theta_k$）。在线性化最小二乘的标准假设下，残差方差的近似估计为\n$$\n\\hat{\\sigma}^2 = \\frac{\\|\\mathbf{r}(\\theta^\\star)\\|_2^2}{M - P},\n$$\n其中 $M$ 是数据点的数量，$P$ 是参数的数量。参数估计的近似协方差矩阵为\n$$\n\\Sigma \\approx \\hat{\\sigma}^2 \\left(J^\\top J\\right)^{-1},\n$$\n其中，如果 $J^\\top J$ 是病态的，则将 $\\left(J^\\top J\\right)^{-1}$ 解释为伪逆。那么每个参数 $\\theta_i$ 的近似 $95\\%$ 置信区间宽度为\n$$\nw_i \\approx 2 \\cdot 1.96 \\cdot \\sqrt{\\Sigma_{ii}}.\n$$\n\n为了汇总不同初始猜测的鲁棒性指标，我们为每种方案计算：\n- 最大相对绝对误差：\n$$\nE_{\\max} = \\max_i \\frac{\\left|\\overline{\\hat{\\theta}}_i - \\theta_i^{\\rm true}\\right|}{\\left|\\theta_i^{\\rm true}\\right|},\n$$\n其中 $\\overline{\\hat{\\theta}}_i$ 是多次拟合的平均估计值，$\\theta_i^{\\rm true}$ 是真实参数。\n- 最大相对标准差：\n$$\nV_{\\max} = \\max_i \\frac{\\operatorname{std}\\left(\\hat{\\theta}_i^{(k)}\\right)}{\\left|\\overline{\\hat{\\theta}}_i\\right|},\n$$\n其中标准差是根据索引为 $k$ 的多次拟合计算的。\n- 最大平均相对置信区间宽度：\n$$\nC_{\\max} = \\max_i \\frac{\\overline{w_i}}{\\left|\\overline{\\hat{\\theta}}_i\\right|},\n$$\n其中 $\\overline{w_i}$ 是多次拟合的平均 $w_i$。\n\n如果 $E_{\\max} \\le 0.25$，$V_{\\max} \\le 0.30$ 且 $C_{\\max} \\le 0.50$，则在给定方案下的拟合被宣布为鲁棒的。一个测试用例只有在两种方案都满足鲁棒性标准时，才被认为是整体鲁棒的。\n\n测试套件规范：\n- 案例A：$N=2$, $(\\mu_1,\\alpha_1) = (0.8, 1.3)$, $(\\mu_2,\\alpha_2) = (0.2, 5.0)$，$M=25$ 个伸长率在 $[1.0, 1.6]$ 内，$\\sigma_{\\rm noise} = 0.02$ MPa。\n- 案例B：$N=2$, $(\\mu_1,\\alpha_1) = (0.5, 2.0)$, $(\\mu_2,\\alpha_2) = (0.5, 2.2)$，$M=25$ 个伸长率在 $[1.0, 1.6]$ 内，$\\sigma_{\\rm noise} = 0.02$ MPa。\n- 案例C：$N=2$, $(\\mu_1,\\alpha_1) = (0.6, 1.2)$, $(\\mu_2,\\alpha_2) = (0.4, 4.0)$，$M=25$ 个伸长率在 $[1.0, 1.6]$ 内，$\\sigma_{\\rm noise} = 0.20$ MPa。\n- 案例D：$N=3$, $(\\mu_1,\\alpha_1) = (0.3, 1.0)$, $(\\mu_2,\\alpha_2) = (0.4, 2.0)$, $(\\mu_3,\\alpha_3) = (0.3, 6.0)$，$M=25$ 个伸长率在 $[1.0, 1.1]$ 内，$\\sigma_{\\rm noise} = 0.02$ MPa。\n\n算法设计：\n1. 实现如上推导的Ogden单轴应力函数 $\\sigma(\\lambda; \\theta)$。\n2. 对于每个测试用例，生成 $\\lambda_j$ 并计算带有附加高斯噪声的 $\\sigma_j^{\\rm obs}$ (MPa)。\n3. 对于每种方案（宽边界和窄边界），在边界内创建6个随机初始猜测，并使用信赖域反射法求解有界非线性最小二乘问题。\n4. 对于每次拟合，记录 $\\hat{\\theta}$、残差和雅可比矩阵。通过 $(J^\\top J)^{-1}$ 或伪逆计算 $\\hat{\\sigma}^2$、$\\Sigma$，以及 $w_i$。\n5. 汇总各次拟合的结果，为每种方案计算 $E_{\\max}$、$V_{\\max}$ 和 $C_{\\max}$。应用鲁棒性判定规则。\n6. 为案例 A–D 生成最终的输出行，其格式为 `[{\\rm True},{\\rm False},{\\rm True},{\\rm True}]` 风格的布尔值。\n\n统计论证：\n- 当指数差异足够大且伸长范围足够宽时（案例A），$J$ 中编码的灵敏度是良态的，导致小的 $\\Sigma$ 和窄的置信区间；估计值在不同初始猜测下表现出低方差，并且相对于真实值的偏差很小，从而满足阈值。\n- 接近不可辨识时（案例B），相近的指数会引起 $J$ 列向量的共线性，使 $J^\\top J$ 变得病态；伪逆运算会产生大的方差和宽的置信区间，并且拟合结果依赖于初始猜测，从而违反了鲁棒性阈值。\n- 高噪声（案例C）会增大 $\\hat{\\sigma}^2$，从而放大 $\\Sigma$ 并加宽置信区间；即使有足够的激励，鲁棒性也可能因为置信区间宽度和多次运行间的可变性而失败。\n- 窄伸长范围（案例D）提供有限的激励，降低了对某些指数和模量的灵敏度；当 $J$ 在与高阶响应相关的方向上发生秩亏时，可辨识性会下降，导致大的置信区间和可变性。\n\n这种方法尊重了其底层的力学原理，并使用标准的统计线性化方法从数值和逻辑上论证了鲁棒性结论。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import least_squares\n\n# Set a fixed random seed for reproducibility\nnp.random.seed(42)\n\ndef ogden_uniaxial_sigma(lambdas, params):\n    \"\"\"\n    Compute the uniaxial Cauchy stress for the incompressible Ogden model.\n    params: [mu1, alpha1, mu2, alpha2, ..., muN, alphaN]\n    lambdas: array of stretches\n    Returns stress in MPa.\n    \"\"\"\n    lambdas = np.asarray(lambdas)\n    N = len(params) // 2\n    mu = np.array(params[0::2])\n    alpha = np.array(params[1::2])\n    # sigma = sum_i mu_i (lambda^{alpha_i} - lambda^{-alpha_i/2})\n    # Vectorized computation\n    # Shape broadcasting: (n_lambdas, N)\n    lam_pow = lambdas[:, None] ** alpha[None, :]\n    lam_neg = lambdas[:, None] ** (-alpha[None, :] / 2.0)\n    sigma = (mu[None, :] * (lam_pow - lam_neg)).sum(axis=1)\n    return sigma\n\ndef generate_synthetic(lambdas, true_params, noise_std):\n    \"\"\"\n    Generate synthetic stress data with Gaussian noise.\n    \"\"\"\n    sigma_true = ogden_uniaxial_sigma(lambdas, true_params)\n    noise = np.random.normal(0.0, noise_std, size=lambdas.shape[0])\n    return sigma_true + noise\n\ndef fit_params(lambdas, sigma_obs, N, bounds, init_guess):\n    \"\"\"\n    Fit Ogden parameters using bounded nonlinear least squares.\n    Returns result object, parameter estimate, residuals, jacobian.\n    \"\"\"\n    def residuals(p):\n        return ogden_uniaxial_sigma(lambdas, p) - sigma_obs\n\n    res = least_squares(\n        residuals,\n        x0=init_guess,\n        bounds=bounds,\n        method='trf',\n        jac='2-point',\n        max_nfev=10000,\n        xtol=1e-12,\n        ftol=1e-12,\n        gtol=1e-12,\n        verbose=0\n    )\n    # SciPy returns res.jac (M x P) approximate Jacobian at solution\n    r = res.fun\n    J = res.jac\n    return res, res.x, r, J\n\ndef covariance_from_jacobian(residuals, jacobian):\n    \"\"\"\n    Compute approximate covariance matrix using linearized least squares.\n    Use pseudo-inverse for (J^T J) to handle ill-conditioning.\n    \"\"\"\n    M, P = jacobian.shape\n    dof = max(M - P, 1)  # guard against non-positive dof\n    rss = float(np.dot(residuals, residuals))\n    sigma2 = rss / dof\n    JTJ = jacobian.T @ jacobian\n    # Pseudo-inverse for stability\n    JTJ_pinv = np.linalg.pinv(JTJ, rcond=1e-12)\n    cov = sigma2 * JTJ_pinv\n    return cov, sigma2\n\ndef assess_regime(lambdas, sigma_obs, true_params, N, bounds, n_runs=6):\n    \"\"\"\n    Assess robustness metrics for a constraint regime.\n    Returns: robust_flag, E_max, V_max, C_max\n    \"\"\"\n    P = 2 * N\n    # Sample initial guesses uniformly within bounds\n    lower = np.array(bounds[0])\n    upper = np.array(bounds[1])\n    inits = []\n    for _ in range(n_runs):\n        u = np.random.rand(P)\n        init = lower + u * (upper - lower)\n        inits.append(init)\n\n    estimates = []\n    ci_widths_runs = []\n    for init in inits:\n        res, est, r, J = fit_params(lambdas, sigma_obs, N, bounds, init)\n        estimates.append(est)\n        # Covariance and CI widths\n        cov, sigma2 = covariance_from_jacobian(r, J)\n        se = np.sqrt(np.clip(np.diag(cov), 0.0, np.inf))\n        ci_widths = 2.0 * 1.96 * se  # 95% CI width\n        ci_widths_runs.append(ci_widths)\n\n    estimates = np.array(estimates)  # shape (n_runs, P)\n    mean_est = estimates.mean(axis=0)\n    std_est = estimates.std(axis=0, ddof=1)\n\n    # Compute metrics\n    true = np.array(true_params)\n    # Avoid division by zero: parameters are positive by construction\n    rel_abs_err = np.abs(mean_est - true) / np.abs(true)\n    E_max = float(np.max(rel_abs_err))\n\n    # Relative std deviation using mean estimate magnitude\n    denom = np.maximum(np.abs(mean_est), 1e-12)\n    rel_std = std_est / denom\n    V_max = float(np.max(rel_std))\n\n    # Average CI widths across runs\n    ci_widths_runs = np.array(ci_widths_runs)  # (n_runs, P)\n    avg_ci_widths = ci_widths_runs.mean(axis=0)\n    rel_ci_widths = avg_ci_widths / denom\n    C_max = float(np.max(rel_ci_widths))\n\n    robust_flag = (E_max = 0.25) and (V_max = 0.30) and (C_max = 0.50)\n    return robust_flag, E_max, V_max, C_max\n\ndef run_case(lambdas, true_params, noise_std, N):\n    \"\"\"\n    Run both wide and tight constraint regimes and compute overall robustness.\n    \"\"\"\n    sigma_obs = generate_synthetic(lambdas, true_params, noise_std)\n\n    # Define bounds\n    # Wide bounds: mu in [0.01, 5.0], alpha in [0.5, 8.0]\n    wide_lower = []\n    wide_upper = []\n    for _ in range(N):\n        wide_lower += [0.01, 0.5]\n        wide_upper += [5.0, 8.0]\n    wide_bounds = (np.array(wide_lower), np.array(wide_upper))\n\n    # Tight bounds: mu in [0.01, 2.0], alpha in [0.5, 6.0]\n    tight_lower = []\n    tight_upper = []\n    for _ in range(N):\n        tight_lower += [0.01, 0.5]\n        tight_upper += [2.0, 6.0]\n    tight_bounds = (np.array(tight_lower), np.array(tight_upper))\n\n    robust_wide, Ew, Vw, Cw = assess_regime(lambdas, sigma_obs, true_params, N, wide_bounds, n_runs=6)\n    robust_tight, Et, Vt, Ct = assess_regime(lambdas, sigma_obs, true_params, N, tight_bounds, n_runs=6)\n\n    overall_robust = robust_wide and robust_tight\n    # We return only the boolean per requirements, but could be extended to include metrics.\n    return overall_robust\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Case A\n    lambdas_A = np.linspace(1.0, 1.6, 25)\n    true_params_A = [0.8, 1.3, 0.2, 5.0]  # N=2\n    noise_std_A = 0.02\n    N_A = 2\n\n    # Case B\n    lambdas_B = np.linspace(1.0, 1.6, 25)\n    true_params_B = [0.5, 2.0, 0.5, 2.2]  # N=2\n    noise_std_B = 0.02\n    N_B = 2\n\n    # Case C\n    lambdas_C = np.linspace(1.0, 1.6, 25)\n    true_params_C = [0.6, 1.2, 0.4, 4.0]  # N=2\n    noise_std_C = 0.20\n    N_C = 2\n\n    # Case D\n    lambdas_D = np.linspace(1.0, 1.1, 25)\n    true_params_D = [0.3, 1.0, 0.4, 2.0, 0.3, 6.0]  # N=3\n    noise_std_D = 0.02\n    N_D = 3\n\n    test_cases = [\n        (lambdas_A, true_params_A, noise_std_A, N_A),\n        (lambdas_B, true_params_B, noise_std_B, N_B),\n        (lambdas_C, true_params_C, noise_std_C, N_C),\n        (lambdas_D, true_params_D, noise_std_D, N_D),\n    ]\n\n    results = []\n    for lambdas, true_params, noise_std, N in test_cases:\n        robust = run_case(lambdas, true_params, noise_std, N)\n        results.append(robust)\n\n    # Final print statement in the exact required format.\n    # Output booleans as True/False in a single bracketed, comma-separated list.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}