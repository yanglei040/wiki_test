{
    "hands_on_practices": [
        {
            "introduction": "显式中心差分法的核心在于其条件稳定性，该稳定性与离散系统的最高固有频率直接相关。本练习将通过计算这一关键的稳定性极限（即临界时间步长 $ \\Delta t_{\\text{cr}} $）提供动手实践。通过比较一致质量矩阵和集中质量矩阵的计算结果，您将更深入地理解有限元分析中的建模选择如何影响显式模拟的动态行为和计算成本 。",
            "id": "3564321",
            "problem": "考虑一根均匀直的轴向变形杆，其长度 $L = 1.0\\,\\mathrm{m}$，横截面积 $A = 1.0\\times 10^{-4}\\,\\mathrm{m}^{2}$，质量密度 $\\rho = 7850\\,\\mathrm{kg/m^{3}}$，杨氏模量 $E = 210\\,\\mathrm{GPa}$。该杆被离散为两个等长的一维线性有限元，节点分别位于 $x=0$、$x=L/2$ 和 $x=L$。位于 $x=0$ 和 $x=L$ 的端节点被固定（Dirichlet 边界条件），使得中间节点的位移成为唯一的活动自由度 (DOF)。在无阻尼线性动力学条件下，假设半离散模型为 $M \\ddot{u} + K u = 0$，并使用显式中心差分法 (CDM)，该方法由加速度在均匀时间步长 $\\Delta t$ 上的中心差分近似定义。\n\n从控制轴向动量平衡方程及其 Galerkin 弱形式出发，利用每个单元上的标准线性形函数来：\n- 推导单元级的一致质量矩阵和刚度矩阵，\n- 施加边界条件后，组装简化的单自由度系统，\n- 针对一致质量和集中质量两种离散化方式，建立并求解广义特征值问题以获得 $\\omega_{\\max}$，以及\n- 利用 CDM 稳定性要求，计算每种质量模型对应的临界时间步长 $\\Delta t_{\\mathrm{cr}}$。\n\n在您的解答中，简要地从物理上解释为什么一致质量模型和集中质量模型预测的 $\\omega_{\\max}$ 会有所不同。\n\n将您最终的两个临界时间步长的数值四舍五入到四位有效数字，并以微秒为单位表示。报告有序对 $\\left(\\Delta t_{\\mathrm{cr}}^{\\text{consistent}},\\ \\Delta t_{\\mathrm{cr}}^{\\text{lumped}}\\right)$。",
            "solution": "用户提供的问题经评估有效。该问题具有科学依据，提法明确，客观，并包含得出唯一解所需的所有必要信息。\n\n该问题要求推导单元矩阵，组装简化系统，计算一致质量和集中质量模型的最高自然频率 $\\omega_{\\max}$，以及显式中心差分法 (CDM) 对应的临界时间步长 $\\Delta t_{\\mathrm{cr}}$。\n\n给定参数如下：\n长度 $L=1.0\\,\\mathrm{m}$\n横截面积 $A=1.0\\times10^{-4}\\,\\mathrm{m}^2$\n质量密度 $\\rho=7850\\,\\mathrm{kg/m^3}$\n杨氏模量 $E=210\\,\\mathrm{GPa} = 210 \\times 10^9\\,\\mathrm{Pa}$\n\n杆被离散为两个等长单元。每个单元的长度为 $l_e = \\frac{L}{2} = 0.5\\,\\mathrm{m}$。\n\n**1. 单元级矩阵**\n\n对于一维线性杆单元，位移场 $u(x)$ 由节点位移 $u_1^e, u_2^e$ 通过线性形函数 $N_1(x), N_2(x)$ 插值得到。轴向应变为 $\\epsilon_x = \\frac{du}{dx} = \\mathbf{B}\\mathbf{u}^e$，其中 $\\mathbf{B}$ 是应变-位移矩阵。\n$\\mathbf{B} = \\begin{bmatrix} \\frac{dN_1}{dx}  \\frac{dN_2}{dx} \\end{bmatrix} = \\frac{1}{l_e}\\begin{bmatrix} -1  1 \\end{bmatrix}$。\n\n单元刚度矩阵 $\\mathbf{k}^e$ 由下式给出：\n$$\n\\mathbf{k}^e = \\int_{0}^{l_e} \\mathbf{B}^T (EA) \\mathbf{B} \\,dx = EA \\int_{0}^{l_e} \\frac{1}{l_e^2}\\begin{bmatrix} -1 \\\\ 1 \\end{bmatrix}\\begin{bmatrix} -1  1 \\end{bmatrix} dx = \\frac{EA}{l_e^2}\\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix} \\int_{0}^{l_e} dx\n$$\n$$\n\\mathbf{k}^e = \\frac{EA}{l_e}\\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix}\n$$\n\n单元一致质量矩阵 $\\mathbf{m}_c^e$ 是从动能推导出来的，使用了相同的形函数：\n$$\n\\mathbf{m}_c^e = \\int_{0}^{l_e} \\rho A \\mathbf{N}^T \\mathbf{N} \\,dx = \\rho A \\int_{0}^{l_e} \\begin{bmatrix} N_1^2  N_1 N_2 \\\\ N_1 N_2  N_2^2 \\end{bmatrix} dx\n$$\n使用局部坐标 $\\xi \\in [-1, 1]$，其中 $N_1(\\xi)=\\frac{1-\\xi}{2}$，$N_2(\\xi)=\\frac{1+\\xi}{2}$，且 $dx=\\frac{l_e}{2}d\\xi$：\n$$\n\\mathbf{m}_c^e = \\rho A \\frac{l_e}{2} \\int_{-1}^{1} \\frac{1}{4}\\begin{bmatrix} (1-\\xi)^2  1-\\xi^2 \\\\ 1-\\xi^2  (1+\\xi)^2 \\end{bmatrix} d\\xi = \\rho A \\frac{l_e}{8} \\begin{bmatrix} \\frac{8}{3}  \\frac{4}{3} \\\\ \\frac{4}{3}  \\frac{8}{3} \\end{bmatrix} = \\frac{\\rho A l_e}{6}\\begin{bmatrix} 2  1 \\\\ 1  2 \\end{bmatrix}\n$$\n\n单元集中质量矩阵 $\\mathbf{m}_l^e$ 通过将单元总质量 $\\rho A l_e$ 平均分配到两个节点上得到（或通过将 $\\mathbf{m}_c^e$ 的行元素求和并置于对角线上得到）：\n$$\n\\mathbf{m}_l^e = \\frac{\\rho A l_e}{2}\\begin{bmatrix} 1  0 \\\\ 0  1 \\end{bmatrix}\n$$\n\n**2. 系统组装与简化**\n\n全局系统有三个节点（自由度 $u_1, u_2, u_3$）。单元1连接节点1-2，单元2连接节点2-3。组装单元矩阵：\n$$\nK_{global} = \\frac{EA}{l_e} \\begin{bmatrix} 1  -1  0 \\\\ -1  1+1  -1 \\\\ 0  -1  1 \\end{bmatrix} = \\frac{EA}{l_e} \\begin{bmatrix} 1  -1  0 \\\\ -1  2  -1 \\\\ 0  -1  1 \\end{bmatrix}\n$$\n$$\nM_{c, global} = \\frac{\\rho A l_e}{6} \\begin{bmatrix} 2  1  0 \\\\ 1  2+2  1 \\\\ 0  1  2 \\end{bmatrix} = \\frac{\\rho A l_e}{6} \\begin{bmatrix} 2  1  0 \\\\ 1  4  1 \\\\ 0  1  2 \\end{bmatrix}\n$$\n$$\nM_{l, global} = \\frac{\\rho A l_e}{2} \\begin{bmatrix} 1  0  0 \\\\ 0  1+1  0 \\\\ 0  0  1 \\end{bmatrix} = \\rho A l_e \\begin{bmatrix} 1/2  0  0 \\\\ 0  1  0 \\\\ 0  0  1/2 \\end{bmatrix}\n$$\n边界条件为 $u_1=0$ 和 $u_3=0$。这使得只有 $u_2$ 是活动自由度。通过取全局矩阵的 (2,2) 项来获得简化系统。设 $K$、$M_c$ 和 $M_l$ 为简化后的 $1 \\times 1$ 矩阵。\n$$\nK = \\frac{2EA}{l_e}\n$$\n$$\nM_c = \\frac{4\\rho A l_e}{6} = \\frac{2\\rho A l_e}{3}\n$$\n$$\nM_l = \\rho A l_e\n$$\n代入 $l_e = L/2$：\n$$\nK = \\frac{2EA}{L/2} = \\frac{4EA}{L}\n$$\n$$\nM_c = \\frac{2\\rho A (L/2)}{3} = \\frac{\\rho A L}{3}\n$$\n$$\nM_l = \\rho A (L/2) = \\frac{\\rho A L}{2}\n$$\n\n**3. 广义特征值问题**\n\n单自由度的无阻尼运动方程为 $M\\ddot{u}_2 + Ku_2 = 0$。假设谐波运动 $u_2(t) = U_2 e^{i\\omega t}$，我们得到特征值问题 $(K - \\omega^2 M)U_2 = 0$。对于非平凡解，$\\det(K - \\omega^2 M) = 0$，简化为 $\\omega^2 = \\frac{K}{M}$。\n\n对于**一致质量**模型：\n$$\n\\omega_c^2 = \\frac{K}{M_c} = \\frac{4EA/L}{\\rho A L / 3} = \\frac{12EA}{\\rho A L^2} = \\frac{12E}{\\rho L^2}\n$$\n因此，最大（也是唯一）频率为 $\\omega_{\\max, c} = \\sqrt{\\frac{12E}{\\rho L^2}}$。\n\n对于**集中质量**模型：\n$$\n\\omega_l^2 = \\frac{K}{M_l} = \\frac{4EA/L}{\\rho A L / 2} = \\frac{8EA}{\\rho A L^2} = \\frac{8E}{\\rho L^2}\n$$\n因此，最大（也是唯一）频率为 $\\omega_{\\max, l} = \\sqrt{\\frac{8E}{\\rho L^2}}$。\n\n**物理解释**\n一致质量矩阵是使用与刚度矩阵相同的插值函数推导的。对于粗糙网格，该方法产生的耦合惯性表示使得离散化系统在动力学上比其物理对应物更“硬”。更“硬”的系统以更高的频率振动。相反，集中质量矩阵将惯性对角化，解耦了节点间的惯性效应。这种简化使系统在动力学上更“软”，导致更低的自然频率。对于此类问题，一个已知的特性是，对于给定的网格，一致质量公式给出了连续系统真实自然频率的上限，而集中质量公式给出了下限。我们的结果 $\\omega_c^2 = \\frac{12E}{\\rho L^2}$ 和 $\\omega_l^2 = \\frac{8E}{\\rho L^2}$ 与两端固定连续杆的精确基频平方 $\\omega_1^2 = \\frac{\\pi^2 E}{\\rho L^2} \\approx \\frac{9.87E}{\\rho L^2}$ 一致，其中 $\\omega_l  \\omega_1  \\omega_c$。\n\n**4. 临界时间步长计算**\n\n显式中心差分法的稳定性极限由下式给出：\n$$\n\\Delta t \\le \\Delta t_{\\mathrm{cr}} = \\frac{2}{\\omega_{\\max}}\n$$\n其中 $\\omega_{\\max}$ 是离散系统的最高自然频率。\n\n对于**一致质量**模型：\n$$\n\\omega_{\\max, c} = \\sqrt{\\frac{12(210 \\times 10^9)}{7850(1.0)^2}} = \\sqrt{\\frac{2.52 \\times 10^{12}}{7850}} \\approx 17917.00\\,\\mathrm{rad/s}\n$$\n$$\n\\Delta t_{\\mathrm{cr}}^{\\text{consistent}} = \\frac{2}{17917.00} \\approx 1.11626 \\times 10^{-4}\\,\\mathrm{s} = 111.626\\,\\mu\\mathrm{s}\n$$\n四舍五入到四位有效数字，$\\Delta t_{\\mathrm{cr}}^{\\text{consistent}} = 111.6\\,\\mu\\mathrm{s}$。\n\n对于**集中质量**模型：\n$$\n\\omega_{\\max, l} = \\sqrt{\\frac{8(210 \\times 10^9)}{7850(1.0)^2}} = \\sqrt{\\frac{1.68 \\times 10^{12}}{7850}} \\approx 14629.17\\,\\mathrm{rad/s}\n$$\n$$\n\\Delta t_{\\mathrm{cr}}^{\\text{lumped}} = \\frac{2}{14629.17} \\approx 1.36713 \\times 10^{-4}\\,\\mathrm{s} = 136.713\\,\\mu\\mathrm{s}\n$$\n四舍五入到四位有效数字，$\\Delta t_{\\mathrm{cr}}^{\\text{lumped}} = 136.7\\,\\mu\\mathrm{s}$。\n\n最终答案是以微秒为单位的临界时间步长的有序对。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 111.6  136.7 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "超越线性系统，许多现实世界的问题都涉及接触等非线性行为。显式中心差分法尤其适用于处理这些复杂的瞬态事件。在本练习中，您将从第一性原理出发，实现核心的蛙跳算法（leapfrog algorithm），以模拟经典的非线性问题——双体碰撞 。根据动量守恒这一基本原理来验证您的实现，将巩固您在开发稳健可靠的计算力学代码方面的一项关键技能。",
            "id": "3564243",
            "problem": "考虑一个计算固体力学中的一维双体碰撞问题，该问题由牛顿第二定律和一个由线性罚函数模拟的无摩擦单边接触所控制。两个点质量，其在一条直线上的位置分别为 $x_1(t)$ 和 $x_2(t)$（单位为米），仅沿该直线运动。质量体 1 初始位于左侧：$x_1(0) = 0$；质量体 2 初始位于右侧：$x_2(0) = \\text{gap}_0 > 0$。初始速度分别为 $v_1(0)$ 和 $v_2(0)$（单位为米每秒）。接触是无摩擦的，且仅在压缩状态下激活，接触力大小为 $f_c = k_c \\max(0, x_1 - x_2)$（单位为牛顿），以等大反向的方式作用于两个质量体。不存在外部作用力。所有物理量必须采用国际单位制（SI）：质量单位为千克，长度单位为米，时间单位为秒。\n\n您的任务是从第一性原理出发，推导并实现一个显式中心差分时间积分器（蛙跳格式），用于演化系统从时间 $t = 0$ 开始，直到任意接触事件后的首次完全分离。该积分器必须仅使用以下基本原理构建：\n- 牛顿第二定律，$m_i \\, \\ddot{x}_i = F_i$。\n- 通过时间差分关联速度和位置的运动学定义。\n- 罚函数接触模型 $f_c = k_c \\max(0, x_1 - x_2)$，其中内力为 $F_1 = -f_c$ 和 $F_2 = +f_c$。\n\n不得假定任何其他预封装的公式或方法。特别地，您必须确保内力的等大反向结构在离散层面得以保持，从而使数值格式在数值舍入误差范围内满足总动量平衡。使用一个均匀的时间步长 $\\Delta t$，该步长根据由最高预期接触频率 $\\omega = \\sqrt{k_c \\left(\\frac{1}{m_1} + \\frac{1}{m_2}\\right)}$ 决定的线性化稳定性极限来选择。设 $\\Delta t = \\gamma \\, \\frac{2}{\\omega}$，其中 $\\gamma \\in (0, 1)$ 是一个给定的无量纲因子。\n\n验证目标：\n1. 动量守恒：在整个计算过程中跟踪总线性动量 $P(t) = m_1 v_1(t) + m_2 v_2(t)$，并记录其与初始值 $P(0)$ 的最大绝对偏差。如果此最大偏差不大于 $10^{-10}$ 千克·米/秒，则认为计算满足动量守恒。\n2. 碰撞后速度：当且仅当实际发生接触（即在某个时刻压缩被激活），首次分离后的速度必须与根据守恒定律解析计算的一维完全弹性（$e=1$）碰撞的速度相匹配。用 $v_1^+$ 和 $v_2^+$ 表示初始接触后完全分离时的首次恒定速度。完全弹性碰撞的解析解为\n$$\nv_1^{\\star} = \\frac{m_1 - m_2}{m_1 + m_2} v_1(0) + \\frac{2 m_2}{m_1 + m_2} v_2(0), \\quad\nv_2^{\\star} = \\frac{2 m_1}{m_1 + m_2} v_1(0) + \\frac{m_2 - m_1}{m_1 + m_2} v_2(0).\n$$\n验证要求 $\\lvert v_1^+ - v_1^{\\star} \\rvert \\le 10^{-3}$ 米/秒以及 $\\lvert v_2^+ - v_2^{\\star} \\rvert \\le 10^{-3}$ 米/秒。在未发生接触（物体从未被压缩）的情况下，解析的碰撞后速度即为初始速度，且适用相同的容差。\n\n数值程序要求：\n- 以与牛顿第二定律和罚函数接触相一致的方式，构建使用半步长速度的显式中心差分（蛙跳）格式。根据零外力和给定的初始数据，一致地初始化半步长速度。\n- 当 $x_1 - x_2 > 0$ 时检测接触激活，当系统从 $x_1 - x_2 > 0$ 过渡到 $x_1 - x_2 \\le 0$ 时检测接触解除。在激活后的首次接触解除时，记录 $v_1^+$ 和 $v_2^+$ 并停止模拟。\n- 使用足够长的模拟时域，以确保如果发生接触，能够捕捉到首次分离。在设置时域时应考虑的固有频率为 $\\omega = \\sqrt{k_c \\left(\\frac{1}{m_1} + \\frac{1}{m_2}\\right)}$，其相关周期为 $T = \\frac{2\\pi}{\\omega}$。\n\n测试套件：\n实现您的程序以运行以下四个独立的测试用例，每个用例由元组 $(m_1, m_2, \\text{gap}_0, v_1(0), v_2(0), k_c, \\gamma)$ 指定：\n\n- 测试 A（不等质量，相互靠近）：\n  - $m_1 = 1.0$ 千克, $m_2 = 2.0$ 千克, $\\text{gap}_0 = 0.01$ 米, $v_1(0) = 1.0$ 米/秒, $v_2(0) = 0.0$ 米/秒, $k_c = 1.0 \\times 10^{6}$ 牛顿/米, $\\gamma = 0.90$。\n- 测试 B（无接触，相互分离）：\n  - $m_1 = 1.0$ 千克, $m_2 = 1.5$ 千克, $\\text{gap}_0 = 0.01$ 米, $v_1(0) = 0.0$ 米/秒, $v_2(0) = 0.5$ 米/秒, $k_c = 1.0 \\times 10^{5}$ 牛顿/米, $\\gamma = 0.90$。\n- 测试 C（刚性接触，接近稳定性极限）：\n  - $m_1 = 0.5$ 千克, $m_2 = 5.0$ 千克, $\\text{gap}_0 = 0.005$ 米, $v_1(0) = 2.0$ 米/秒, $v_2(0) = 0.0$ 米/秒, $k_c = 5.0 \\times 10^{6}$ 牛顿/米, $\\gamma = 0.99$。\n- 测试 D（相等质量，一般性靠近）：\n  - $m_1 = 1.0$ 千克, $m_2 = 1.0$ 千克, $\\text{gap}_0 = 0.02$ 米, $v_1(0) = 1.2$ 米/秒, $v_2(0) = -0.4$ 米/秒, $k_c = 2.0 \\times 10^{6}$ 牛顿/米, $\\gamma = 0.80$。\n\n对于每个测试用例，计算：\n- 一个布尔值，指示在整个模拟过程中动量守恒是否保持在 $10^{-10}$ 千克·米/秒的范围内。\n- 一个布尔值，指示碰撞后速度是否在 $10^{-3}$ 米/秒的容差内符合解析值。如果发生接触，则使用上述完全弹性公式；如果未发生接触，则使用初始值。\n\n使用逻辑与（两者必须为真）组合这两个条件，为每个测试生成一个单一的布尔结果。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含按给定顺序排列的四个测试的结果，结果为逗号分隔的列表，并用方括号括起来。例如，输出可能看起来像 $[ \\text{True}, \\text{False}, \\text{True}, \\text{True} ]$，但没有空格。元素必须是布尔值。",
            "solution": "用户的要求是为一维双体碰撞问题开发并验证一个数值解。该解必须从第一性原理出发，使用显式中心差分（蛙跳）法推导，并对照解析守恒定律进行验证。\n\n**1. 运动控制方程**\n\n系统由两个点质量 $m_1$ 和 $m_2$ 组成，其位置分别为 $x_1(t)$ 和 $x_2(t)$。其动力学由牛顿第二定律控制：\n$$m_1 \\ddot{x}_1(t) = F_1(t)$$\n$$m_2 \\ddot{x}_2(t) = F_2(t)$$\n其中 $\\ddot{x}_i$ 表示质量体 $i$ 的加速度，$F_i$ 是作用在其上的合力。问题指定了一个无外力的单边罚函数接触模型。接触力 $f_c$ 仅在侵入期间（$g > 0$，其中 $g = x_1 - x_2$ 是有符号的侵入量）激活。作用在质量体上的力是内力，大小相等，方向相反：\n$$f_c(t) = k_c \\max(0, x_1(t) - x_2(t))$$\n$$F_1(t) = -f_c(t)$$\n$$F_2(t) = +f_c(t)$$\n这意味着作用于系统的总力为零，$F_1(t) + F_2(t) = 0$，因此系统的总线性动量必须守恒。\n\n**2. 显式中心差分（蛙跳）积分器的推导**\n\n我们用一个恒定的时间步长 $\\Delta t$ 来离散化时间，使得 $t_n = n \\Delta t$。我们用 $x_i^n$、$v_i^n$ 和 $a_i^n$ 分别表示质量体 $i$ 在时间 $t_n$ 的位置、速度和加速度。\n\n蛙跳法将速度的计算交错在半个时间步长上，即 $t_{n \\pm 1/2} = (n \\pm 1/2) \\Delta t$，这增强了稳定性。基本的中心差分近似为：\n在半步长 $n+1/2$ 处的速度是以时间 $t_{n+1/2}$ 为中心的：\n$$v_i^{n+1/2} = \\frac{x_i^{n+1} - x_i^n}{\\Delta t}$$\n在完整步长 $n$ 处的加速度是以时间 $t_n$ 为中心的：\n$$a_i^n = \\frac{v_i^{n+1/2} - v_i^{n-1/2}}{\\Delta t}$$\n\n这些近似可以重排成一个显式的时间步进算法。位置更新规则（“漂移”）由第一个公式推导得出：\n$$x_i^{n+1} = x_i^n + \\Delta t \\cdot v_i^{n+1/2}$$\n速度更新规则（“踢动”）由第二个公式推导得出：\n$$v_i^{n+1/2} = v_i^{n-1/2} + \\Delta t \\cdot a_i^n$$\n\n对于每个时间步长 $n$，算法按以下步骤进行：\n1.  给定位置 $x_i^n$ 和来自前一个半步长的速度 $v_i^{n-1/2}$。\n2.  基于当前位置 $x_i^n$ 计算力 $F_i^n$：\n    $$g^n = x_1^n - x_2^n$$\n    $$f_c^n = k_c \\max(0, g^n)$$\n    $$F_1^n = -f_c^n, \\quad F_2^n = +f_c^n$$\n3.  使用牛顿定律 $a_i^n = F_i^n / m_i$ 计算加速度 $a_i^n$：\n    $$a_1^n = -f_c^n / m_1, \\quad a_2^n = +f_c^n / m_2$$\n4.  将速度从半步长 $n-1/2$ 更新到 $n+1/2$：\n    $$v_i^{n+1/2} = v_i^{n-1/2} + \\Delta t \\cdot a_i^n$$\n5.  使用新计算的半步长速度将位置从步长 $n$ 更新到 $n+1$：\n    $$x_i^{n+1} = x_i^n + \\Delta t \\cdot v_i^{n+1/2}$$\n\n**3. 初始化**\n\n蛙跳格式需要在半步长处有一个初始速度 $v_i^{-1/2}$，以便在 $n=0$ 开始第一次迭代。我们已知在 $t=0$ 时的初始条件，即 $x_i^0$ 和 $v_i^0$。我们可以通过一个半步长的后向欧拉步来近似 $v_i^{-1/2}$：\n$$v_i^0 \\approx \\frac{v_i^{1/2} + v_i^{-1/2}}{2}$$\n为 $n=0$ 重排加速度公式，我们有 $v_i^{1/2} = v_i^{-1/2} + \\Delta t \\cdot a_i^0$。将此代入速度近似中得到：\n$$v_i^0 \\approx \\frac{(v_i^{-1/2} + \\Delta t \\cdot a_i^0) + v_i^{-1/2}}{2} = v_i^{-1/2} + \\frac{\\Delta t}{2} a_i^0$$\n求解 $v_i^{-1/2}$ 得到启动速度：\n$$v_i^{-1/2} = v_i^0 - \\frac{\\Delta t}{2} a_i^0$$\n对于此特定问题，初始位置为 $x_1(0) = 0$ 和 $x_2(0) = \\text{gap}_0 > 0$。因此，初始侵入量为负，$x_1^0 - x_2^0  0$，这意味着初始接触力 $f_c^0$ 为零。因此，初始加速度 $a_i^0$ 为零，启动过程简化为 $v_i^{-1/2} = v_i^0$。\n\n**4. 动量守恒**\n\n根据要求，离散格式必须保持总线性动量。设 $P^{n+1/2} = m_1 v_1^{n+1/2} + m_2 v_2^{n+1/2}$ 是与半步长速度相关的总动量。使用速度更新规则：\n$$P^{n+1/2} = m_1(v_1^{n-1/2} + \\Delta t \\cdot a_1^n) + m_2(v_2^{n-1/2} + \\Delta t \\cdot a_2^n)$$\n$$P^{n+1/2} = (m_1 v_1^{n-1/2} + m_2 v_2^{n-1/2}) + \\Delta t (m_1 a_1^n + m_2 a_2^n)$$\n$$P^{n+1/2} = P^{n-1/2} + \\Delta t (F_1^n + F_2^n)$$\n由于 $F_1^n + F_2^n = -f_c^n + f_c^n = 0$，我们得到 $P^{n+1/2} = P^{n-1/2}$。这表明在半步长处的动量在迭代过程中是精确守恒的（在浮点精度范围内）。完整步长的速度定义为 $v_i^n = (v_i^{n+1/2} + v_i^{n-1/2})/2$。因此，在一个完整步长处的总动量 $P^n = m_1 v_1^n + m_2 v_2^n$ 也是恒定的，因为它是两个恒定量值的平均值。\n\n**5. 实现与验证流程**\n\n模拟将基于推导出的算法来实现。\n- **时间步长：** 稳定的时间步长 $\\Delta t$ 计算为 $\\Delta t = \\gamma \\frac{2}{\\omega}$，其中 $\\omega = \\sqrt{k_c (\\frac{1}{m_1} + \\frac{1}{m_2})}$ 是双体接触振荡器的固有频率。\n- **模拟循环：** 循环进行迭代，更新位置和速度。使用一个布尔标志 `contact_activated` 来跟踪是否曾发生过侵入。\n- **终止条件：** 模拟在首次发生从侵入状态（$x_1^n - x_2^n > 0$）到分离状态（$x_1^{n+1} - x_2^{n+1} \\le 0$）的转变时停止。最终速度 $v_1^+$ 和 $v_2^+$ 取为分离时刻的半步长速度 $v_1^{n+1/2}$ 和 $v_2^{n+1/2}$，因为它们代表了后续自由飞行阶段的恒定速度。如果模拟在未发生任何接触的情况下完成了最大步数，则最终速度即为初始速度。\n- **验证：**\n    1.  **动量守恒：** 在每一步 $n$，使用完整步长速度的定义计算总动量 $P^n$，并与初始动量 $P^0 = m_1 v_1^0 + m_2 v_2^0$ 进行比较。记录模拟过程中的最大绝对偏差，并与 $10^{-10}$ kg·m/s 的容差进行核对。\n    2.  **碰撞后速度：** 将数值计算得到的分离后速度（$v_1^+, v_2^+$）与完全弹性碰撞的解析速度（$v_1^{\\star}, v_2^{\\star}$）进行比较，或者在未发生接触时与初始速度进行比较。绝对差值必须在 $10^{-3}$ m/s 的容差范围内。\n\n通过对两个验证结果进行逻辑与操作，为每个测试用例生成一个单一的布尔结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation_case(m1, m2, gap0, v1_0, v2_0, kc, gamma):\n    \"\"\"\n    Runs a single simulation for the two-body impact problem.\n\n    Returns:\n        (bool, bool): A tuple containing the results for momentum conservation\n                      and post-impact velocity verification.\n    \"\"\"\n    # 1. Setup and Initialization\n    omega = np.sqrt(kc * (1/m1 + 1/m2))\n    dt = gamma * 2 / omega\n\n    # Initial state vectors\n    pos = np.array([0.0, gap0], dtype=np.float64)  # [x1, x2] at step n\n    vel_0 = np.array([v1_0, v2_0], dtype=np.float64) # [v1, v2] at t=0\n\n    # Initial acceleration is zero since there is no initial contact\n    accel_0 = np.array([0.0, 0.0], dtype=np.float64)\n    \n    # Initialize half-step velocity using the startup formula\n    # v_half(-1/2) = v(0) - dt/2 * a(0)\n    vel_half = vel_0 - (dt / 2.0) * accel_0  # Represents v at n-1/2\n\n    masses = np.array([m1, m2], dtype=np.float64)\n    inv_masses = 1.0 / masses\n\n    # Verification trackers\n    p_initial = np.dot(masses, vel_0)\n    max_p_dev = 0.0\n    \n    contact_activated = False\n    v_final = np.copy(vel_0) # Default final velocities are initial velocities\n\n    # Simulation horizon (large enough to capture events)\n    max_steps = 2_000_000\n\n    # 2. Main Simulation Loop (Leapfrog)\n    for n in range(max_steps):\n        # State at step n: pos, vel_half (which is v at n-1/2)\n        \n        # Calculate forces at step n based on pos_n\n        penetration = pos[0] - pos[1]\n        \n        if penetration > 0:\n            contact_activated = True\n        \n        fc = kc * max(0, penetration)\n        forces = np.array([-fc, fc], dtype=np.float64)\n\n        # Calculate accelerations at step n\n        accel_n = forces * inv_masses\n\n        # Calculate full-step velocity v_n for momentum check\n        # v_n = (v_{n+1/2} + v_{n-1/2}) / 2\n        # v_{n+1/2} = v_{n-1/2} + dt * a_n\n        vel_half_next = vel_half + dt * accel_n\n        vel_full_n = (vel_half_next + vel_half) / 2.0\n        \n        # Check momentum conservation at step n\n        p_current = np.dot(masses, vel_full_n)\n        max_p_dev = max(max_p_dev, abs(p_current - p_initial))\n        \n        # --- Update state for next step ---\n        # Update half-step velocity to n+1/2\n        vel_half = vel_half_next\n        \n        # Update position to n+1 using v_{n+1/2}\n        pos = pos + dt * vel_half\n\n        # Check for termination condition: first separation after contact\n        if contact_activated and (pos[0] - pos[1] = 0):\n            v_final = np.copy(vel_half) # Final velocity is the constant post-impact velocity\n            break\n    else: # This else clause runs if the for loop finishes without a break\n        # This handles the no-contact case. v_final remains vel_0.\n        pass\n\n    # 3. Verification\n    \n    # Check 1: Momentum conservation\n    momentum_ok = max_p_dev = 1e-10\n\n    # Check 2: Post-impact velocities\n    if contact_activated:\n        # Compare with analytical elastic collision velocities\n        m_sum = m1 + m2\n        v1_star = ((m1 - m2) / m_sum) * v1_0 + ((2 * m2) / m_sum) * v2_0\n        v2_star = ((2 * m1) / m_sum) * v1_0 + ((m2 - m1) / m_sum) * v2_0\n        v_analytical = np.array([v1_star, v2_star], dtype=np.float64)\n    else:\n        # No contact occurred, compare with initial velocities\n        v_analytical = vel_0\n\n    velocity_dev = np.abs(v_final - v_analytical)\n    velocity_ok = np.all(velocity_dev = 1e-3)\n    \n    return momentum_ok, velocity_ok\n\n\ndef solve():\n    # Test cases: (m1, m2, gap0, v1(0), v2(0), kc, gamma)\n    test_cases = [\n        # Test A (general unequal masses, approaching)\n        (1.0, 2.0, 0.01, 1.0, 0.0, 1.0e6, 0.90),\n        # Test B (no contact, separating)\n        (1.0, 1.5, 0.01, 0.0, 0.5, 1.0e5, 0.90),\n        # Test C (stiff contact, near stability limit)\n        (0.5, 5.0, 0.005, 2.0, 0.0, 5.0e6, 0.99),\n        # Test D (equal masses, generic approaching)\n        (1.0, 1.0, 0.02, 1.2, -0.4, 2.0e6, 0.80),\n    ]\n\n    results = []\n    for case in test_cases:\n        m1, m2, gap0, v1_0, v2_0, kc, gamma = case\n        momentum_ok, velocity_ok = run_simulation_case(m1, m2, gap0, v1_0, v2_0, kc, gamma)\n        # Final result is the logical conjunction of both conditions\n        final_result = momentum_ok and velocity_ok\n        results.append(str(final_result))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在涉及材料失效或大变形等高级模拟中，网格和材料属性可能在分析过程中发生剧烈变化。在这种情况下保持稳定性需要采用自适应时间步长策略。本练习旨在挑战您设计一种运行时算法，该算法能够根据单元侵蚀和材料退化动态调整全局时间步长 。这项练习弥合了教科书理论与在先进的显式动力学软件中稳健实现时间步长控制的实践之间的差距。",
            "id": "3564264",
            "problem": "您的任务是，从第一性原理出发，为通过有限元离散化的一维小应变线弹性杆的显式中心差分积分，开发一种时间步长控制的运行时算法。在模拟过程中，网格可能会因单元侵蚀而发生变化。目标是通过将全局时间增量维持在一个能适应几何和材料变化的保守稳定性边界之下，来确保数值稳定性，并通过随着网格演化追踪最小容许单元时间增量来实现这一目标。\n\n从连续介质动量平衡及其半离散有限元形式出发，推导出一个用单元几何和材料量表示的、保守的、单元级别的稳定性边界。然后，设计一个运行时算法，在每个全局步中，将全局稳定增量计算为当前活动单元集上经安全系数缩放后的最小值。网格通过一个侵蚀规则发生变化，即当一个标量损伤变量超过阈值时，单元将被永久移除。该算法必须支持单元长度和损伤的每步更新，必须立即在全局时间步中反映单元的移除，并且必须持续模拟，直到达到规定的物理结束时间或所有单元都被移除。\n\n在每一步，根据当前的活动单元计算基于稳定性的候选增量，此计算在任何结束时间截断之前进行。将物理时间推进一个执行增量，该增量是基于稳定性的候选增量和到达结束时间的剩余时间中的较小者。为了计算下文要求的统计数据，仅使用基于稳定性的候选值，忽略为精确达到结束时间而进行的最终截断。\n\n物理模型和更新规则：\n- 在步骤 $n$ 时，每个单元 $i$ 的当前长度为 $L_i^n$（单位 $\\mathrm{m}$），密度为 $\\rho_i$（单位 $\\mathrm{kg/m^3}$，为常数），当前杨氏模量为 $E_i^n$（单位 $\\mathrm{Pa}$）。初始值为 $L_i^0 = L_{0,i}$，$E_i^0 = E_{0,i}$。\n- 单元波速为 $c_i^n$（单位 $\\mathrm{m/s}$），由您从第一性原理推导得出。\n- 每步的长度更新为 $L_i^{n+1} = L_i^n (1 + s_i)$，其中 $s_i$ 是给定的每步工程应变增量（无量纲）。假设 $|s_i| \\ll 1$，因此小应变运动学在步进上是自洽的。\n- 标量损伤变量 $d_i^n \\in [0,1]$ 的演化规律为 $d_i^{n+1} = \\min\\{1, d_i^n + g_i\\}$，其中 $g_i \\ge 0$ 是给定的每步增量（无量纲）。模量退化规律为 $E_i^n = (1 - d_i^n) E_{0,i}$。\n- 侵蚀：如果在某一步结束时 $d_i^{n+1} \\ge d_{\\mathrm{thr},i}$，则单元 $i$ 在下一步开始前被移除，并在此后保持非活动状态。\n- 步骤 $n$ 的全局时间增量是安全系数 $\\eta \\in (0,1)$ 乘以您必须使用显式中心差分法推导出的、在所有当前活动单元上的单元级保守稳定性边界的最小值。将此候选增量表示为 $\\Delta t_{\\mathrm{cand}}^n$。执行的增量为 $\\Delta t_{\\mathrm{exec}}^n = \\min\\{\\Delta t_{\\mathrm{cand}}^n, T_{\\mathrm{end}} - t^n\\}$。\n\n假设：\n- 一维杆运动学，小应变，线弹性，无外力；完全专注于均匀更新的稳定性。\n- 使用标准的有限元质量和刚度构造，以及适用于显式中心差分时间积分的、物理上合理的保守边界。\n- 安全系数为 $\\eta = 0.9$。\n- 当没有活动单元剩下时，将候选增量设置为 $\\Delta t_{\\mathrm{cand}}^n = 0$ 并立即终止模拟。\n\n每个测试案例所需输出：\n- 初始候选全局增量 $\\Delta t_{\\mathrm{cand}}^0$，单位为 $\\mathrm{s}$。\n- 所有步骤中候选全局增量的最小值 $\\min_n \\Delta t_{\\mathrm{cand}}^n$，单位为 $\\mathrm{s}$。\n- 所有步骤中候选全局增量的最大值 $\\max_n \\Delta t_{\\mathrm{cand}}^n$，单位为 $\\mathrm{s}$。\n- 执行的总步数（一个整数），即终止前使用的 $\\Delta t_{\\mathrm{exec}}^n$ 的计数。\n对于最小值和最大值，不考虑为精确达到 $T_{\\mathrm{end}}$ 而使用的最终截断；仅使用基于稳定性的候选值。\n\n单位和格式：\n- 所有长度必须以 $\\mathrm{m}$ 为单位，密度以 $\\mathrm{kg/m^3}$ 为单位，模量以 $\\mathrm{Pa}$ 为单位，时间以 $\\mathrm{s}$ 为单位。所有时间量均以 $\\mathrm{s}$ 表示。\n- 您的程序应生成单行输出，包含一个由方括号括起来的逗号分隔列表，其中每个测试案例的结果本身就是按 $[\\Delta t_{\\mathrm{cand}}^0, \\min_n \\Delta t_{\\mathrm{cand}}^n, \\max_n \\Delta t_{\\mathrm{cand}}^n, \\text{steps}]$ 顺序排列的列表。例如：$[[a,b,c,d],[e,f,g,h],[i,j,k,l]]$。对实数使用标准十进制或科学记数法。\n\n测试套件：\n- 案例1（理想情况，无侵蚀）：\n  - $N = 4$。\n  - $\\rho = [7800, 7800, 7800, 7800]\\ \\mathrm{kg/m^3}$。\n  - $E_0 = [2.10 \\times 10^{11}, 2.10 \\times 10^{11}, 2.10 \\times 10^{11}, 2.10 \\times 10^{11}]\\ \\mathrm{Pa}$。\n  - $L_0 = [0.010, 0.012, 0.009, 0.011]\\ \\mathrm{m}$。\n  - $s = [0, 0, 0, 0]$。\n  - $g = [0, 0, 0, 0]$。\n  - $d_{\\mathrm{thr}} = [1, 1, 1, 1]$。\n  - $T_{\\mathrm{end}} = 1.0 \\times 10^{-4}\\ \\mathrm{s}$。\n- 案例2（侵蚀在运行中途增大了全局时间步）：\n  - $N = 5$。\n  - $\\rho = [2700, 2700, 7800, 7800, 7800]\\ \\mathrm{kg/m^3}$。\n  - $E_0 = [7.0 \\times 10^{10}, 7.0 \\times 10^{10}, 2.10 \\times 10^{11}, 2.10 \\times 10^{11}, 2.10 \\times 10^{11}]\\ \\mathrm{Pa}$。\n  - $L_0 = [0.010, 0.006, 0.008, 0.005, 0.007]\\ \\mathrm{m}$。\n  - $s = [0, 0, 0, 0, 0]$。\n  - $g = [0.02, 0.05, 0, 0.03, 0]$。\n  - $d_{\\mathrm{thr}} = [0.5, 0.5, 0.5, 0.5, 0.5]$。\n  - $T_{\\mathrm{end}} = 1.0 \\times 10^{-4}\\ \\mathrm{s}$。\n- 案例3（边界情况，所有单元几乎立即侵蚀）：\n  - $N = 3$。\n  - $\\rho = [1000, 1000, 1000]\\ \\mathrm{kg/m^3}$。\n  - $E_0 = [3.0 \\times 10^{9}, 3.0 \\times 10^{9}, 3.0 \\times 10^{9}]\\ \\mathrm{Pa}$。\n  - $L_0 = [0.004, 0.004, 0.004]\\ \\mathrm{m}$。\n  - $s = [0, 0, 0]$。\n  - $g = [0.5, 0.5, 0.5]$。\n  - $d_{\\mathrm{thr}} = [0.5, 0.5, 0.5]$。\n  - $T_{\\mathrm{end}} = 1.0 \\times 10^{-3}\\ \\mathrm{s}$。\n\n您的实现应遵循您推导出的稳定性边界，并且必须根据上述规则管理不断变化的活动单元集。要求的最终输出格式是包含三个列表的单行列表，每个测试案例一个列表，如上所述，所有时间量以 $\\mathrm{s}$ 为单位，步数计数为整数。",
            "solution": "为显式动力学模拟确定一个稳定的时间增量是计算力学中的一个基本问题。该方法需要为所选的时间积分方案（显式中心差分法）应用于空间离散系统（用有限元建模的杆）推导其稳定性极限。这个极限被称为Courant-Friedrichs-Lewy (CFL) 条件，它规定了信息（物理波）在单个时间步内传播的距离不能超过一个单元的长度。我们将从第一性原理出发推导这个条件，然后构建一个算法，以根据不断变化的材料属性和网格几何形状来调整全局时间步。\n\n### 推导基于稳定性的时间增量\n\n1.  **连续介质运动方程**：假设小应变且无体力，一维弹性杆的动力学由动量平衡方程控制：\n    $$\n    \\rho \\frac{\\partial^2 u}{\\partial t^2} = \\frac{\\partial \\sigma}{\\partial x}\n    $$\n    其中 $\\rho$ 是材料密度，$u(x,t)$ 是轴向位移，$\\sigma(x,t)$ 是轴向应力。\n\n2.  **本构关系和运动学关系**：对于线弹性材料，应力通过胡克定律与应变 $\\epsilon$ 相关：$\\sigma = E \\epsilon$，其中 $E$ 是杨氏模量。小应变假设提供了运动学关系 $\\epsilon = \\frac{\\partial u}{\\partial x}$。将这些代入动量方程，得到一维波动方程：\n    $$\n    \\rho \\frac{\\partial^2 u}{\\partial t^2} = E \\frac{\\partial^2 u}{\\partial x^2} \\implies \\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2}\n    $$\n    其中 $c = \\sqrt{E/\\rho}$ 是材料的纵波波速。\n\n3.  **有限元半离散化**：将连续域离散为有限元。此过程将偏微分方程转换为关于时间的常微分方程组，称为半离散运动方程：\n    $$\n    \\mathbf{M} \\ddot{\\mathbf{u}}(t) + \\mathbf{K} \\mathbf{u}(t) = \\mathbf{F}_{\\text{ext}}(t)\n    $$\n    这里，$\\mathbf{u}(t)$ 是全局节点位移向量，$\\ddot{\\mathbf{u}}(t)$ 是节点加速度向量，$\\mathbf{M}$ 是全局质量矩阵，$\\mathbf{K}$ 是全局刚度矩阵，$\\mathbf{F}_{\\text{ext}}$ 是外部节点力向量，对于本问题为零。对于显式方法，使用集中（对角）质量矩阵 $\\mathbf{M}_L$ 是标准且计算上必需的，它可以解耦方程组。对于长度为 $L_i$、横截面积恒为 $A_i$ 的一维线性杆单元 $i$，其单元刚度矩阵 $\\mathbf{k}_i$ 和集中质量矩阵 $\\mathbf{m}_{L,i}$ 分别为：\n    $$\n    \\mathbf{k}_i = \\frac{A_i E_i}{L_i} \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix}, \\quad \\mathbf{m}_{L,i} = \\frac{\\rho_i A_i L_i}{2} \\begin{bmatrix} 1  0 \\\\ 0  1 \\end{bmatrix}\n    $$\n\n4.  **中心差分时间积分**：显式中心差分格式使用步骤 $n-1$、$n$ 和 $n+1$ 的节点位移来近似步骤 $n$ 的加速度：\n    $$\n    \\ddot{\\mathbf{u}}^n \\approx \\frac{\\mathbf{u}^{n+1} - 2\\mathbf{u}^n + \\mathbf{u}^{n-1}}{(\\Delta t)^2}\n    $$\n    将此代入半离散方程 $\\mathbf{M}_L \\ddot{\\mathbf{u}}^n + \\mathbf{K} \\mathbf{u}^n = \\mathbf{0}$，得到位移向量的更新规则：\n    $$\n    \\mathbf{u}^{n+1} = 2\\mathbf{u}^n - \\mathbf{u}^{n-1} - (\\Delta t)^2 \\mathbf{M}_L^{-1} \\mathbf{K} \\mathbf{u}^n\n    $$\n\n5.  **稳定性分析**：中心差分格式的数值稳定性是有条件的。误差分析表明，如果时间步 $\\Delta t$ 满足以下条件，则该格式是稳定的：\n    $$\n    \\Delta t \\le \\frac{2}{\\omega_{\\max}}\n    $$\n    其中 $\\omega_{\\max}$ 是离散系统的最高自然频率，由矩阵束 $(\\mathbf{K}, \\mathbf{M}_L)$ 的最大特征值的平方根给出，即 $\\omega_{\\max}^2 = \\lambda_{\\max}(\\mathbf{M}_L^{-1} \\mathbf{K})$。\n\n6.  **单元级别的稳定性边界**：对于运行时算法来说，计算全局最大特征值 $\\omega_{\\max}$ 在计算上是不可行的。一个标准的、保守的做法是将 $\\omega_{\\max}$ 用网格中任何单个单元的最大频率来界定，即 $\\omega_{\\max} \\le \\max_i (\\omega_{\\max}^{(i)})$。单个单元 $i$ 的最高频率 $\\omega_{\\max}^{(i)}$ 可以通过求解单元级特征值问题得到：$(\\mathbf{k}_i - (\\omega^{(i)})^2 \\mathbf{m}_{L,i})\\mathbf{v} = \\mathbf{0}$。最大非零特征值给出：\n    $$\n    (\\omega_{\\max}^{(i)})^2 = \\frac{4 E_i}{\\rho_i L_i^2} \\implies \\omega_{\\max}^{(i)} = \\frac{2}{L_i} \\sqrt{\\frac{E_i}{\\rho_i}} = \\frac{2 c_i}{L_i}\n    $$\n    将稳定性条件应用于此单元频率，得到单元的稳定性极限：\n    $$\n    \\Delta t_i \\le \\frac{2}{\\omega_{\\max}^{(i)}} = \\frac{2}{2c_i/L_i} = \\frac{L_i}{c_i}\n    $$\n    这就是单元 $i$ 的 CFL 条件：时间步不能大于波以速度 $c_i$ 传播穿过单元长度 $L_i$ 所需的时间。\n\n7.  **自适应全局时间增量**：为使整个网格保持稳定，全局时间步 $\\Delta t$ 必须小于所有单元稳定性极限的最小值。因此，在每个步骤 $n$，我们通过对当前所有活动单元的最小单元时间步应用一个安全系数 $\\eta$ 来计算候选全局增量：\n    $$\n    \\Delta t_{\\mathrm{cand}}^n = \\eta \\min_{i \\in \\text{active}} \\left( \\frac{L_i^n}{c_i^n} \\right)\n    $$\n    问题规定，长度 $L_i^n$、密度 $\\rho_i$ 和杨氏模量 $E_i^n$ 是特定于单元且可以演化的。模量随标量损伤变量 $d_i^n$ 而退化，即 $E_i^n = (1-d_i^n)E_{0,i}$。因此，波速也依赖于状态：$c_i^n = \\sqrt{E_i^n / \\rho_i}$。候选时间增量的最终表达式为：\n    $$\n    \\Delta t_{\\mathrm{cand}}^n = \\eta \\min_{i \\in \\text{active}} \\left( L_i^n \\sqrt{\\frac{\\rho_i}{(1-d_i^n)E_{0,i}}} \\right)\n    $$\n\n### 算法设计\n运行时算法在一个模拟循环中实现此推导出的公式，该循环跟踪每个单元状态的演变和活动单元集。\n\n1.  **初始化**：对于每个测试案例，初始化 NumPy 数组以存储单元属性：初始长度 ($L_0$)、密度 ($\\rho$)、初始模量 ($E_0$)、每步应变增量 ($s$) 和每步损伤增量 ($g$)。初始化状态数组，用于存储当前长度 $L$、损伤 $d$ 和模量 $E$。一个布尔数组 `active_mask` 跟踪哪些单元是模拟的一部分。设置模拟时间 $t=0$ 和步数计数为 0。\n\n2.  **模拟循环**：只要当前时间 $t$ 小于规定的结束时间 $T_{\\mathrm{end}}$ 且至少有一个活动单元，模拟就继续进行。\n    a.  **计算候选增量**：在每个步骤开始时，为所有 `active_mask` 为真的单元计算单元稳定性极限 $L_i^n / c_i^n$。需要特别注意模量 $E_i^n$ 可能变为零（由于损伤 $d_i^n=1$）的单元；它们对最小值的贡献被视为无穷大，从而有效地将它们从时间步极限的考虑中移除。找到这些值的最小值，并通过乘以安全系数 $\\eta=0.9$ 计算候选全局增量 $\\Delta t_{\\mathrm{cand}}^n$。\n    b.  **收集统计数据**：记录计算出的 $\\Delta t_{\\mathrm{cand}}^n$，以便后续计算模拟过程中的初始值、最小值和最大值。\n    c.  **确定执行增量**：实际采用的时间步 $\\Delta t_{\\mathrm{exec}}^n$ 是候选增量和到达 $T_{\\mathrm{end}}$ 的剩余时间中的较小者。\n    d.  **推进状态**：模拟时间 $t$ 增加 $\\Delta t_{\\mathrm{exec}}^n$，步数计数器增加。\n    e.  **更新单元属性**：根据给定的规则更新所有单元的长度 $L_i$、损伤 $d_i$ 和模量 $E_i$：$L_i^{n+1} = L_i^n(1+s_i)$ 和 $d_i^{n+1} = \\min(1, d_i^n + g_i)$。\n    f.  **单元侵蚀**：更新损伤后，检查每个单元是否达到其侵蚀阈值 $d_{\\mathrm{thr},i}$。如果一个单元的损伤达到或超过其阈值，其在 `active_mask` 中的对应条目将被设置为 `False`，从而将其从后续的时间步计算中永久移除。\n\n3.  **终止与输出**：当 $t \\ge T_{\\mathrm{end}}$ 或 `active_mask` 中不包含任何 `True` 值时，循环终止。然后，收集的统计数据（$\\Delta t_{\\mathrm{cand}}^0$、$\\min_n \\Delta t_{\\mathrm{cand}}^n$、$\\max_n \\Delta t_{\\mathrm{cand}}^n$ 和总步数）将被格式化并为该测试案例返回。\n\n此过程确保模拟在适应单元属性和活动网格配置变化的同时保持数值稳定。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the adaptive time-stepping statistics based on the explicit central difference method\n    stability for a 1D bar with evolving properties and element erosion.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (happy path, no erosion)\n        {\n            \"N\": 4,\n            \"rho\": [7800, 7800, 7800, 7800],\n            \"E0\": [2.10e11, 2.10e11, 2.10e11, 2.10e11],\n            \"L0\": [0.010, 0.012, 0.009, 0.011],\n            \"s\": [0, 0, 0, 0],\n            \"g\": [0, 0, 0, 0],\n            \"d_thr\": [1, 1, 1, 1],\n            \"T_end\": 1.0e-4\n        },\n        # Case 2 (erosion increases the global time step mid-run)\n        {\n            \"N\": 5,\n            \"rho\": [2700, 2700, 7800, 7800, 7800],\n            \"E0\": [7.0e10, 7.0e10, 2.10e11, 2.10e11, 2.10e11],\n            \"L0\": [0.010, 0.006, 0.008, 0.005, 0.007],\n            \"s\": [0, 0, 0, 0, 0],\n            \"g\": [0.02, 0.05, 0, 0.03, 0],\n            \"d_thr\": [0.5, 0.5, 0.5, 0.5, 0.5],\n            \"T_end\": 1.0e-4\n        },\n        # Case 3 (edge case, all elements erode almost immediately)\n        {\n            \"N\": 3,\n            \"rho\": [1000, 1000, 1000],\n            \"E0\": [3.0e9, 3.0e9, 3.0e9],\n            \"L0\": [0.004, 0.004, 0.004],\n            \"s\": [0, 0, 0],\n            \"g\": [0.5, 0.5, 0.5],\n            \"d_thr\": [0.5, 0.5, 0.5],\n            \"T_end\": 1.0e-3\n        }\n    ]\n\n    all_results = []\n    eta = 0.9\n\n    for case_data in test_cases:\n        N = case_data[\"N\"]\n        T_end = case_data[\"T_end\"]\n        \n        # Convert lists to numpy arrays for vectorized operations\n        rho = np.array(case_data[\"rho\"], dtype=float)\n        E0 = np.array(case_data[\"E0\"], dtype=float)\n        s = np.array(case_data[\"s\"], dtype=float)\n        g = np.array(case_data[\"g\"], dtype=float)\n        d_thr = np.array(case_data[\"d_thr\"], dtype=float)\n        \n        # Initialize state variables\n        L = np.array(case_data[\"L0\"], dtype=float)\n        d = np.zeros(N, dtype=float)\n        active_mask = np.ones(N, dtype=bool)\n\n        current_time = 0.0\n        step_count = 0\n        dt_cand_history = []\n        \n        # Main simulation loop\n        while current_time  T_end and np.any(active_mask):\n            \n            # --- Step n: Calculation before advancing time ---\n\n            # 1. Compute current modulus based on damage from previous step\n            E = (1.0 - d) * E0\n\n            # 2. Compute stability-based candidate increment\n            L_active = L[active_mask]\n            rho_active = rho[active_mask]\n            E_active = E[active_mask]\n\n            # To avoid division by zero when E=0 (d=1), treat the term as infinity.\n            # E_active > 0 is a safe check.\n            c_squared_active = np.full_like(E_active, np.inf)\n            valid_E_mask = E_active > 0\n            c_squared_active[valid_E_mask] = E_active[valid_E_mask] / rho_active[valid_E_mask]\n            \n            # Element-wise stability limits (L/c)\n            dt_elems = L_active / np.sqrt(c_squared_active)\n            \n            dt_cand = eta * np.min(dt_elems)\n            dt_cand_history.append(dt_cand)\n\n            # 3. Determine executed time increment and advance time\n            time_to_end = T_end - current_time\n            dt_exec = min(dt_cand, time_to_end)\n            \n            current_time += dt_exec\n            step_count += 1\n            \n            # --- Update state for Step n+1 ---\n\n            # 4. Update element properties\n            L *= (1.0 + s)\n            d = np.minimum(1.0, d + g)\n\n            # 5. Apply erosion for the next step\n            # Element is removed if its new damage exceeds the threshold\n            eroded_mask = d >= d_thr\n            active_mask[eroded_mask] = False\n\n        # Post-processing for this test case\n        if not dt_cand_history:\n            # Case where simulation does not run (e.g., T_end=0 or no elements)\n            dt_cand_0 = 0.0\n            min_dt_cand = 0.0\n            max_dt_cand = 0.0\n        else:\n            dt_cand_0 = dt_cand_history[0]\n            min_dt_cand = min(dt_cand_history)\n            max_dt_cand = max(dt_cand_history)\n\n        all_results.append([dt_cand_0, min_dt_cand, max_dt_cand, step_count])\n\n    # Final print statement in the exact required format.\n    # The str() function on a list correctly formats it as '[...]'\n    # The outer join then assembles the final list of lists apecarance.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        }
    ]
}