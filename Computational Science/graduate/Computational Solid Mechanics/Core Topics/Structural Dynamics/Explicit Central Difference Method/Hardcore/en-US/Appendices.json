{
    "hands_on_practices": [
        {
            "introduction": "Understanding the conditional stability of the explicit central difference method begins with the Courant-Friedrichs-Lewy (CFL) condition. This exercise bridges the gap between the abstract stability criterion, $\\Delta t_{\\text{cr}} \\le \\frac{2}{\\omega_{\\max}}$, and its practical application to a finite element model. By deriving the system matrices for a simple discretized bar and calculating its maximum natural frequency, $\\omega_{\\max}$, you will gain a firsthand understanding of how modeling decisions, such as the choice between a lumped and a consistent mass matrix, directly influence the maximum allowable time step for a stable simulation .",
            "id": "3564321",
            "problem": "Consider a straight, homogeneous, axially deforming bar of length $L = 1.0\\,\\mathrm{m}$, cross-sectional area $A = 1.0\\times 10^{-4}\\,\\mathrm{m}^{2}$, mass density $\\rho = 7850\\,\\mathrm{kg/m^{3}}$, and Young’s modulus $E = 210\\,\\mathrm{GPa}$. The bar is discretized into two equal one-dimensional linear finite elements with nodes at $x=0$, $x=L/2$, and $x=L$. The end nodes at $x=0$ and $x=L$ are fixed (Dirichlet boundary conditions), leaving the middle node displacement as the only active Degree of Freedom (DOF). Under undamped linear dynamics, assume the semi-discrete model $M \\ddot{u} + K u = 0$ and use the Explicit Central Difference Method (CDM), defined by the central difference approximation of acceleration over a uniform time step $\\Delta t$.\n\nStarting from the governing axial momentum balance and its Galerkin weak form, use the standard linear shape functions over each element to:\n- derive the element-level consistent mass and stiffness matrices,\n- assemble the reduced one-DOF system after imposing the boundary conditions,\n- form and solve the generalized eigenvalue problem to obtain $\\omega_{\\max}$ for both the consistent mass and the lumped mass discretizations, and\n- use the CDM stability requirement to compute the corresponding critical time step $\\Delta t_{\\mathrm{cr}}$ for each mass model.\n\nProvide, in your solution, a brief physical explanation of why the predicted $\\omega_{\\max}$ differs between the consistent and lumped mass models.\n\nRound your final numerical values of the two critical time steps to four significant figures and express them in microseconds. Report the ordered pair $\\left(\\Delta t_{\\mathrm{cr}}^{\\text{consistent}},\\ \\Delta t_{\\mathrm{cr}}^{\\text{lumped}}\\right)$.",
            "solution": "The user-provided problem is evaluated as valid. It is scientifically grounded, well-posed, objective, and contains all necessary information for a unique solution.\n\nThe problem asks for the derivation of element matrices, assembly of a reduced system, calculation of the highest natural frequency $\\omega_{\\max}$ for both consistent and lumped mass models, and the corresponding critical time steps $\\Delta t_{\\mathrm{cr}}$ for the explicit Central Difference Method (CDM).\n\nThe given parameters are:\nLength $L=1.0\\,\\mathrm{m}$\nCross-sectional area $A=1.0\\times10^{-4}\\,\\mathrm{m}^2$\nMass density $\\rho=7850\\,\\mathrm{kg/m^3}$\nYoung’s modulus $E=210\\,\\mathrm{GPa} = 210 \\times 10^9\\,\\mathrm{Pa}$\n\nThe bar is discretized into two equal-length elements. The length of each element is $l_e = \\frac{L}{2} = 0.5\\,\\mathrm{m}$.\n\n**1. Element-Level Matrices**\n\nFor a 1D linear bar element, the displacement field $u(x)$ is interpolated from nodal displacements $u_1^e, u_2^e$ using linear shape functions $N_1(x), N_2(x)$. The axial strain is $\\epsilon_x = \\frac{du}{dx} = \\mathbf{B}\\mathbf{u}^e$, where $\\mathbf{B}$ is the strain-displacement matrix.\n$\\mathbf{B} = \\begin{bmatrix} \\frac{dN_1}{dx} & \\frac{dN_2}{dx} \\end{bmatrix} = \\frac{1}{l_e}\\begin{bmatrix} -1 & 1 \\end{bmatrix}$.\n\nThe element stiffness matrix $\\mathbf{k}^e$ is given by:\n$$\n\\mathbf{k}^e = \\int_{0}^{l_e} \\mathbf{B}^T (EA) \\mathbf{B} \\,dx = EA \\int_{0}^{l_e} \\frac{1}{l_e^2}\\begin{bmatrix} -1 \\\\ 1 \\end{bmatrix}\\begin{bmatrix} -1 & 1 \\end{bmatrix} dx = \\frac{EA}{l_e^2}\\begin{bmatrix} 1 & -1 \\\\ -1 & 1 \\end{bmatrix} \\int_{0}^{l_e} dx\n$$\n$$\n\\mathbf{k}^e = \\frac{EA}{l_e}\\begin{bmatrix} 1 & -1 \\\\ -1 & 1 \\end{bmatrix}\n$$\n\nThe element consistent mass matrix $\\mathbf{m}_c^e$ is derived from the kinetic energy, using the same shape functions:\n$$\n\\mathbf{m}_c^e = \\int_{0}^{l_e} \\rho A \\mathbf{N}^T \\mathbf{N} \\,dx = \\rho A \\int_{0}^{l_e} \\begin{bmatrix} N_1^2 & N_1 N_2 \\\\ N_1 N_2 & N_2^2 \\end{bmatrix} dx\n$$\nUsing local coordinates $\\xi \\in [-1, 1]$, where $N_1(\\xi)=\\frac{1-\\xi}{2}$, $N_2(\\xi)=\\frac{1+\\xi}{2}$, and $dx=\\frac{l_e}{2}d\\xi$:\n$$\n\\mathbf{m}_c^e = \\rho A \\frac{l_e}{2} \\int_{-1}^{1} \\frac{1}{4}\\begin{bmatrix} (1-\\xi)^2 & 1-\\xi^2 \\\\ 1-\\xi^2 & (1+\\xi)^2 \\end{bmatrix} d\\xi = \\rho A \\frac{l_e}{8} \\begin{bmatrix} \\frac{8}{3} & \\frac{4}{3} \\\\ \\frac{4}{3} & \\frac{8}{3} \\end{bmatrix} = \\frac{\\rho A l_e}{6}\\begin{bmatrix} 2 & 1 \\\\ 1 & 2 \\end{bmatrix}\n$$\n\nThe element lumped mass matrix $\\mathbf{m}_l^e$ is obtained by placing the total element mass $\\rho A l_e$ equally at the two nodes (or by summing the rows of $\\mathbf{m}_c^e$ onto the diagonal):\n$$\n\\mathbf{m}_l^e = \\frac{\\rho A l_e}{2}\\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\end{bmatrix}\n$$\n\n**2. System Assembly and Reduction**\n\nThe global system has three nodes (DOFs $u_1, u_2, u_3$). Element 1 connects nodes 1-2, and element 2 connects nodes 2-3. Assembling the element matrices:\n$$\nK_{global} = \\frac{EA}{l_e} \\begin{bmatrix} 1 & -1 & 0 \\\\ -1 & 1+1 & -1 \\\\ 0 & -1 & 1 \\end{bmatrix} = \\frac{EA}{l_e} \\begin{bmatrix} 1 & -1 & 0 \\\\ -1 & 2 & -1 \\\\ 0 & -1 & 1 \\end{bmatrix}\n$$\n$$\nM_{c, global} = \\frac{\\rho A l_e}{6} \\begin{bmatrix} 2 & 1 & 0 \\\\ 1 & 2+2 & 1 \\\\ 0 & 1 & 2 \\end{bmatrix} = \\frac{\\rho A l_e}{6} \\begin{bmatrix} 2 & 1 & 0 \\\\ 1 & 4 & 1 \\\\ 0 & 1 & 2 \\end{bmatrix}\n$$\n$$\nM_{l, global} = \\frac{\\rho A l_e}{2} \\begin{bmatrix} 1 & 0 & 0 \\\\ 0 & 1+1 & 0 \\\\ 0 & 0 & 1 \\end{bmatrix} = \\rho A l_e \\begin{bmatrix} 1/2 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1/2 \\end{bmatrix}\n$$\nThe boundary conditions are $u_1=0$ and $u_3=0$. This leaves only $u_2$ as the active DOF. The reduced system is obtained by taking the (2,2) entry of the global matrices. Let $K$, $M_c$, and $M_l$ be the reduced $1 \\times 1$ matrices.\n$$\nK = \\frac{2EA}{l_e}\n$$\n$$\nM_c = \\frac{4\\rho A l_e}{6} = \\frac{2\\rho A l_e}{3}\n$$\n$$\nM_l = \\rho A l_e\n$$\nSubstituting $l_e = L/2$:\n$$\nK = \\frac{2EA}{L/2} = \\frac{4EA}{L}\n$$\n$$\nM_c = \\frac{2\\rho A (L/2)}{3} = \\frac{\\rho A L}{3}\n$$\n$$\nM_l = \\rho A (L/2) = \\frac{\\rho A L}{2}\n$$\n\n**3. Generalized Eigenvalue Problem**\n\nThe undamped equation of motion for the single DOF is $M\\ddot{u}_2 + Ku_2 = 0$. Assuming harmonic motion $u_2(t) = U_2 e^{i\\omega t}$, we get the eigenvalue problem $(K - \\omega^2 M)U_2 = 0$. For a non-trivial solution, $\\det(K - \\omega^2 M) = 0$, which simplifies to $\\omega^2 = \\frac{K}{M}$.\n\nFor the **consistent mass** model:\n$$\n\\omega_c^2 = \\frac{K}{M_c} = \\frac{4EA/L}{\\rho A L / 3} = \\frac{12EA}{\\rho A L^2} = \\frac{12E}{\\rho L^2}\n$$\nThus, the maximum (and only) frequency is $\\omega_{\\max, c} = \\sqrt{\\frac{12E}{\\rho L^2}}$.\n\nFor the **lumped mass** model:\n$$\n\\omega_l^2 = \\frac{K}{M_l} = \\frac{4EA/L}{\\rho A L / 2} = \\frac{8EA}{\\rho A L^2} = \\frac{8E}{\\rho L^2}\n$$\nThus, the maximum (and only) frequency is $\\omega_{\\max, l} = \\sqrt{\\frac{8E}{\\rho L^2}}$.\n\n**Physical Explanation**\nThe consistent mass matrix is derived using the same interpolation functions as the stiffness matrix. This method produces a coupled inertia representation that makes the discretized system dynamically stiffer than its physical counterpart for coarse meshes. A stiffer system vibrates at higher frequencies. Conversely, the lumped mass matrix diagonalizes the inertia, decoupling the inertial effects between nodes. This simplification makes the system dynamically more flexible, leading to lower natural frequencies. For this type of problem, it is a known property that for a given mesh, the consistent mass formulation provides an upper bound, and the lumped mass formulation provides a lower bound, to the true natural frequencies of the continuous system. Our results, $\\omega_c^2 = 12E/(\\rho L^2)$ and $\\omega_l^2 = 8E/(\\rho L^2)$, are consistent with the exact fundamental frequency squared for a fixed-fixed continuous bar, $\\omega_1^2 = \\pi^2 E/(\\rho L^2) \\approx 9.87E/(\\rho L^2)$, where $\\omega_l  \\omega_1  \\omega_c$.\n\n**4. Critical Time Step Calculation**\n\nThe stability limit for the explicit Central Difference Method is given by:\n$$\n\\Delta t \\le \\Delta t_{\\mathrm{cr}} = \\frac{2}{\\omega_{\\max}}\n$$\nwhere $\\omega_{\\max}$ is the highest natural frequency of the discrete system.\n\nFor the **consistent mass** model:\n$$\n\\omega_{\\max, c} = \\sqrt{\\frac{12(210 \\times 10^9)}{7850(1.0)^2}} = \\sqrt{\\frac{2.52 \\times 10^{12}}{7850}} \\approx 17917.00\\,\\mathrm{rad/s}\n$$\n$$\n\\Delta t_{\\mathrm{cr}}^{\\text{consistent}} = \\frac{2}{17917.00} \\approx 1.11626 \\times 10^{-4}\\,\\mathrm{s} = 111.626\\,\\mu\\mathrm{s}\n$$\nRounding to four significant figures, $\\Delta t_{\\mathrm{cr}}^{\\text{consistent}} = 111.6\\,\\mu\\mathrm{s}$.\n\nFor the **lumped mass** model:\n$$\n\\omega_{\\max, l} = \\sqrt{\\frac{8(210 \\times 10^9)}{7850(1.0)^2}} = \\sqrt{\\frac{1.68 \\times 10^{12}}{7850}} \\approx 14629.17\\,\\mathrm{rad/s}\n$$\n$$\n\\Delta t_{\\mathrm{cr}}^{\\text{lumped}} = \\frac{2}{14629.17} \\approx 1.36713 \\times 10^{-4}\\,\\mathrm{s} = 136.713\\,\\mu\\mathrm{s}\n$$\nRounding to four significant figures, $\\Delta t_{\\mathrm{cr}}^{\\text{lumped}} = 136.7\\,\\mu\\mathrm{s}$.\n\nThe final answer is the ordered pair of critical time steps in microseconds.",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 111.6  136.7 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "Moving from theory to practice, this exercise challenges you to implement the explicit central difference (leapfrog) integrator to solve a nonlinear mechanics problem: the high-speed impact between two bodies. This hands-on coding task highlights the importance of creating numerical schemes that inherently respect the fundamental laws of physics, particularly the conservation of linear momentum. By verifying your simulation's outcome against a known analytical solution, you will practice a critical skill in computational engineering: building confidence in the predictive accuracy of your models .",
            "id": "3564243",
            "problem": "Consider a one-dimensional two-body impact in computational solid mechanics governed by Newton's second law and a frictionless, unilateral contact modeled by a linear penalty. Two point masses, with positions $x_1(t)$ and $x_2(t)$ on a line (in meters), move only along that line. Mass $1$ is initially to the left: $x_1(0) = 0$, and mass $2$ is initially to the right: $x_2(0) = \\text{gap}_0 > 0$. The initial velocities are $v_1(0)$ and $v_2(0)$ (in meters per second). The contact is frictionless and activates only under compression, with contact force magnitude $f_c = k_c \\max(0, x_1 - x_2)$ (in newtons), acting with equal magnitude and opposite directions on the two masses. There are no external forces. All physical quantities must be treated in the International System of Units (SI): mass in kilograms, length in meters, time in seconds.\n\nYour task is to derive from first principles and implement an explicit central difference time integrator (leapfrog form) to evolve the system from time $t = 0$ until the first complete separation after any contact event. The integrator must be constructed using only the following fundamental bases:\n- Newton's second law, $m_i \\, \\ddot{x}_i = F_i$.\n- Kinematic definitions relating velocity and position through time differences.\n- The penalty contact model $f_c = k_c \\max(0, x_1 - x_2)$, with internal forces $F_1 = -f_c$ and $F_2 = +f_c$.\n\nNo other prepackaged formulas or methods are to be assumed. In particular, you must ensure that the equal-and-opposite structure of internal forces is preserved at the discrete level so that the numerical scheme respects the total momentum balance to within numerical roundoff. Use a uniform time step $\\Delta t$ chosen from the linearized stability limit determined by the highest expected contact frequency $\\omega = \\sqrt{k_c \\left(\\frac{1}{m_1} + \\frac{1}{m_2}\\right)}$. Set $\\Delta t = \\gamma \\, \\frac{2}{\\omega}$ with a given nondimensional factor $\\gamma \\in (0, 1)$.\n\nVerification objectives:\n1. Momentum conservation: Track the total linear momentum $P(t) = m_1 v_1(t) + m_2 v_2(t)$ during the entire computation and record the maximum absolute deviation from its initial value $P(0)$. The computation is considered to conserve momentum if this maximum deviation is no greater than $10^{-10}$ kilogram-meter per second.\n2. Post-impact velocities: If and only if a contact actually occurs (i.e., compression activates at some time), the first post-separation velocities must match those of a one-dimensional perfectly elastic ($e = 1$) collision computed analytically from conservation laws. Denote by $v_1^+$ and $v_2^+$ the first constant velocities after complete separation following the initial contact. The analytical solution for the perfectly elastic impact is\n$$\nv_1^{\\star} = \\frac{m_1 - m_2}{m_1 + m_2} v_1(0) + \\frac{2 m_2}{m_1 + m_2} v_2(0), \\quad\nv_2^{\\star} = \\frac{2 m_1}{m_1 + m_2} v_1(0) + \\frac{m_2 - m_1}{m_1 + m_2} v_2(0).\n$$\nVerification requires $| v_1^+ - v_1^{\\star} | \\le 10^{-3}$ meters per second and $| v_2^+ - v_2^{\\star} | \\le 10^{-3}$ meters per second. In the case where no contact occurs (the bodies never compress), the analytical post-impact velocities are simply the initial velocities, and the same tolerance applies.\n\nNumerical procedure requirements:\n- Construct the explicit central difference (leapfrog) scheme with half-step velocities in a manner consistent with Newton's second law and the penalty contact. Initialize the half-step velocities consistently with zero external forces and the given initial data.\n- Detect contact activation when $x_1 - x_2 > 0$ and contact deactivation when the system transitions from $x_1 - x_2 > 0$ to $x_1 - x_2 \\le 0$. Upon the very first deactivation following activation, record $v_1^+$ and $v_2^+$ and stop the simulation.\n- Use a simulation horizon sufficiently long to guarantee that, if a contact occurs, the first separation is captured. The natural frequency to consider in setting the horizon is $\\omega = \\sqrt{k_c \\left(\\frac{1}{m_1} + \\frac{1}{m_2}\\right)}$ and the associated period $T = \\frac{2\\pi}{\\omega}$.\n\nTest suite:\nImplement your program to run the following four independent test cases, each specified by the tuple $(m_1, m_2, \\text{gap}_0, v_1(0), v_2(0), k_c, \\gamma)$:\n\n- Test A (general unequal masses, approaching):\n  - $m_1 = 1.0$ kilograms, $m_2 = 2.0$ kilograms, $\\text{gap}_0 = 0.01$ meters, $v_1(0) = 1.0$ meters per second, $v_2(0) = 0.0$ meters per second, $k_c = 1.0 \\times 10^{6}$ newtons per meter, $\\gamma = 0.90$.\n- Test B (no contact, separating):\n  - $m_1 = 1.0$ kilograms, $m_2 = 1.5$ kilograms, $\\text{gap}_0 = 0.01$ meters, $v_1(0) = 0.0$ meters per second, $v_2(0) = 0.5$ meters per second, $k_c = 1.0 \\times 10^{5}$ newtons per meter, $\\gamma = 0.90$.\n- Test C (stiff contact, near stability limit):\n  - $m_1 = 0.5$ kilograms, $m_2 = 5.0$ kilograms, $\\text{gap}_0 = 0.005$ meters, $v_1(0) = 2.0$ meters per second, $v_2(0) = 0.0$ meters per second, $k_c = 5.0 \\times 10^{6}$ newtons per meter, $\\gamma = 0.99$.\n- Test D (equal masses, generic approaching):\n  - $m_1 = 1.0$ kilograms, $m_2 = 1.0$ kilograms, $\\text{gap}_0 = 0.02$ meters, $v_1(0) = 1.2$ meters per second, $v_2(0) = -0.4$ meters per second, $k_c = 2.0 \\times 10^{6}$ newtons per meter, $\\gamma = 0.80$.\n\nFor each test case, compute:\n- A boolean indicating whether momentum conservation holds within $10^{-10}$ kilogram-meter per second over the entire simulation.\n- A boolean indicating whether the post-impact velocities meet the analytical values within $10^{-3}$ meters per second, using the perfectly elastic formulas above if contact occurs, and the initial values if no contact occurs.\n\nCombine the two conditions using logical conjunction (both must be true) to produce a single boolean result per test.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for the four tests in the given order. For example, an output might look like $[ \\text{True}, \\text{False}, \\text{True}, \\text{True} ]$ but without spaces. The elements must be booleans.",
            "solution": "The user's request is to develop and validate a numerical solution for a one-dimensional two-body impact problem. The solution must be derived from first principles using an explicit central difference (leapfrog) method and verified against analytical conservation laws.\n\n**1. Governing Equations of Motion**\n\nThe system consists of two point masses, $m_1$ and $m_2$, with positions $x_1(t)$ and $x_2(t)$. The dynamics are governed by Newton's second law:\n$$m_1 \\ddot{x}_1(t) = F_1(t)$$\n$$m_2 \\ddot{x}_2(t) = F_2(t)$$\nwhere $\\ddot{x}_i$ denotes the acceleration of mass $i$, and $F_i$ is the net force acting upon it. The problem specifies a unilateral penalty contact model with no external forces. The contact force $f_c$ is active only during penetration ($g > 0$, where $g = x_1 - x_2$ is the signed penetration). The forces on the masses are internal, equal in magnitude, and opposite in direction:\n$$f_c(t) = k_c \\max(0, x_1(t) - x_2(t))$$\n$$F_1(t) = -f_c(t)$$\n$$F_2(t) = +f_c(t)$$\nThis implies that the total force on the system is zero, $F_1(t) + F_2(t) = 0$, and thus the total linear momentum of the system must be conserved.\n\n**2. Derivation of the Explicit Central Difference (Leapfrog) Integrator**\n\nWe discretize time with a constant time step $\\Delta t$, such that $t_n = n \\Delta t$. We denote the position, velocity, and acceleration of mass $i$ at time $t_n$ by $x_i^n$, $v_i^n$, and $a_i^n$, respectively.\n\nThe leapfrog method staggers the velocity evaluation at half time steps, $t_{n \\pm 1/2} = (n \\pm 1/2) \\Delta t$, which enhances stability. The fundamental central difference approximations are:\nThe velocity at half-step $n+1/2$ is centered around time $t_{n+1/2}$:\n$$v_i^{n+1/2} = \\frac{x_i^{n+1} - x_i^n}{\\Delta t}$$\nThe acceleration at full-step $n$ is centered around time $t_n$:\n$$a_i^n = \\frac{v_i^{n+1/2} - v_i^{n-1/2}}{\\Delta t}$$\n\nThese approximations can be rearranged into an explicit time-stepping algorithm. The position update rule (\"drift\") is derived from the first formula:\n$$x_i^{n+1} = x_i^n + \\Delta t \\cdot v_i^{n+1/2}$$\nThe velocity update rule (\"kick\") is derived from the second formula:\n$$v_i^{n+1/2} = v_i^{n-1/2} + \\Delta t \\cdot a_i^n$$\n\nThe algorithm proceeds as follows for each time step $n$:\n1.  Given positions $x_i^n$ and velocities from the previous half-step $v_i^{n-1/2}$.\n2.  Calculate the forces $F_i^n$ based on the current positions $x_i^n$:\n    $$g^n = x_1^n - x_2^n$$\n    $$f_c^n = k_c \\max(0, g^n)$$\n    $$F_1^n = -f_c^n, \\quad F_2^n = +f_c^n$$\n3.  Calculate the accelerations $a_i^n$ using Newton's law, $a_i^n = F_i^n / m_i$:\n    $$a_1^n = -f_c^n / m_1, \\quad a_2^n = +f_c^n / m_2$$\n4.  Update the velocities from half-step $n-1/2$ to $n+1/2$:\n    $$v_i^{n+1/2} = v_i^{n-1/2} + \\Delta t \\cdot a_i^n$$\n5.  Update the positions from step $n$ to $n+1$ using the newly computed half-step velocities:\n    $$x_i^{n+1} = x_i^n + \\Delta t \\cdot v_i^{n+1/2}$$\n\n**3. Initialization**\n\nThe leapfrog scheme requires an initial velocity at a half-step, $v_i^{-1/2}$, to begin the first iteration at $n=0$. We are given initial conditions at $t=0$, namely $x_i^0$ and $v_i^0$. We can approximate $v_i^{-1/2}$ by a half-step backward Euler step:\n$$v_i^0 \\approx \\frac{v_i^{1/2} + v_i^{-1/2}}{2}$$\nRearranging the acceleration formula for $n=0$, we have $v_i^{1/2} = v_i^{-1/2} + \\Delta t \\cdot a_i^0$. Substituting this into the velocity approximation gives:\n$$v_i^0 \\approx \\frac{(v_i^{-1/2} + \\Delta t \\cdot a_i^0) + v_i^{-1/2}}{2} = v_i^{-1/2} + \\frac{\\Delta t}{2} a_i^0$$\nSolving for $v_i^{-1/2}$ yields the startup velocity:\n$$v_i^{-1/2} = v_i^0 - \\frac{\\Delta t}{2} a_i^0$$\nFor this specific problem, the initial positions are $x_1(0) = 0$ and $x_2(0) = \\text{gap}_0 > 0$. Thus, the initial penetration is negative, $x_1^0 - x_2^0  0$, which means the initial contact force $f_c^0$ is zero. Consequently, the initial accelerations $a_i^0$ are zero, and the startup simplifies to $v_i^{-1/2} = v_i^0$.\n\n**4. Momentum Conservation**\n\nThe discrete scheme must preserve total linear momentum, as specified. Let $P^{n+1/2} = m_1 v_1^{n+1/2} + m_2 v_2^{n+1/2}$ be the total momentum associated with the half-step velocities. Using the velocity update rule:\n$$P^{n+1/2} = m_1(v_1^{n-1/2} + \\Delta t \\cdot a_1^n) + m_2(v_2^{n-1/2} + \\Delta t \\cdot a_2^n)$$\n$$P^{n+1/2} = (m_1 v_1^{n-1/2} + m_2 v_2^{n-1/2}) + \\Delta t (m_1 a_1^n + m_2 a_2^n)$$\n$$P^{n+1/2} = P^{n-1/2} + \\Delta t (F_1^n + F_2^n)$$\nSince $F_1^n + F_2^n = -f_c^n + f_c^n = 0$, we have $P^{n+1/2} = P^{n-1/2}$. This shows that the momentum at the half-steps is conserved exactly across iterations (to within floating-point precision). The full-step velocity is defined as $v_i^n = (v_i^{n+1/2} + v_i^{n-1/2})/2$. The total momentum at a full step $P^n = m_1 v_1^n + m_2 v_2^n$ is thus also constant, since it is an average of two constant quantities.\n\n**5. Implementation and Verification Procedure**\n\nThe simulation will be implemented based on the derived algorithm.\n- **Time Step:** The stable time step $\\Delta t$ is calculated as $\\Delta t = \\gamma \\frac{2}{\\omega}$, where $\\omega = \\sqrt{k_c (\\frac{1}{m_1} + \\frac{1}{m_2})}$ is the natural frequency of the two-body contact oscillator.\n- **Simulation Loop:** The loop iterates, updating positions and velocities. A boolean flag, `contact_activated`, is used to track whether penetration has ever occurred.\n- **Termination:** The simulation stops upon the first occurrence of a transition from a state of penetration ($x_1^n - x_2^n > 0$) to a state of separation ($x_1^{n+1} - x_2^{n+1} \\le 0$). The final velocities, $v_1^+$ and $v_2^+$, are taken as the half-step velocities $v_1^{n+1/2}$ and $v_2^{n+1/2}$ at the moment of separation, as these represent the constant velocities during the subsequent free-flight interval. If the simulation completes its maximum number of steps without any contact, the final velocities are simply the initial velocities.\n- **Verification:**\n    1.  **Momentum Conservation:** At each step $n$, the total momentum $P^n$ is computed using the full-step velocity definition and compared to the initial momentum $P^0 = m_1 v_1^0 + m_2 v_2^0$. The maximum absolute deviation over the simulation is recorded and checked against the tolerance of $10^{-10}$ kg·m/s.\n    2.  **Post-Impact Velocity:** The numerically obtained post-separation velocities ($v_1^+, v_2^+$) are compared against the analytical velocities for a perfectly elastic collision ($v_1^{\\star}, v_2^{\\star}$), or against the initial velocities if no contact occurred. The absolute differences must be within the tolerance of $10^{-3}$ m/s.\n\nA single boolean result is generated for each test case by taking the logical AND of the two verification outcomes.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation_case(m1, m2, gap0, v1_0, v2_0, kc, gamma):\n    \"\"\"\n    Runs a single simulation for the two-body impact problem.\n\n    Returns:\n        (bool, bool): A tuple containing the results for momentum conservation\n                      and post-impact velocity verification.\n    \"\"\"\n    # 1. Setup and Initialization\n    omega = np.sqrt(kc * (1/m1 + 1/m2))\n    dt = gamma * 2 / omega\n\n    # Initial state vectors\n    pos = np.array([0.0, gap0], dtype=np.float64)  # [x1, x2] at step n\n    vel_0 = np.array([v1_0, v2_0], dtype=np.float64) # [v1, v2] at t=0\n\n    # Initial acceleration is zero since there is no initial contact\n    accel_0 = np.array([0.0, 0.0], dtype=np.float64)\n    \n    # Initialize half-step velocity using the startup formula\n    # v_half(-1/2) = v(0) - dt/2 * a(0)\n    vel_half = vel_0 - (dt / 2.0) * accel_0  # Represents v at n-1/2\n\n    masses = np.array([m1, m2], dtype=np.float64)\n    inv_masses = 1.0 / masses\n\n    # Verification trackers\n    p_initial = np.dot(masses, vel_0)\n    max_p_dev = 0.0\n    \n    contact_activated = False\n    v_final = np.copy(vel_0) # Default final velocities are initial velocities\n\n    # Simulation horizon (large enough to capture events)\n    max_steps = 2_000_000\n\n    # 2. Main Simulation Loop (Leapfrog)\n    for n in range(max_steps):\n        # State at step n: pos, vel_half (which is v at n-1/2)\n        \n        # Calculate forces at step n based on pos_n\n        penetration = pos[0] - pos[1]\n        \n        if penetration > 0:\n            contact_activated = True\n        \n        fc = kc * max(0, penetration)\n        forces = np.array([-fc, fc], dtype=np.float64)\n\n        # Calculate accelerations at step n\n        accel_n = forces * inv_masses\n\n        # Calculate full-step velocity v_n for momentum check\n        # v_n = (v_{n+1/2} + v_{n-1/2}) / 2\n        # v_{n+1/2} = v_{n-1/2} + dt * a_n\n        vel_half_next = vel_half + dt * accel_n\n        vel_full_n = (vel_half_next + vel_half) / 2.0\n        \n        # Check momentum conservation at step n\n        p_current = np.dot(masses, vel_full_n)\n        max_p_dev = max(max_p_dev, abs(p_current - p_initial))\n        \n        # --- Update state for next step ---\n        # Update half-step velocity to n+1/2\n        vel_half = vel_half_next\n        \n        # Update position to n+1 using v_{n+1/2}\n        pos = pos + dt * vel_half\n\n        # Check for termination condition: first separation after contact\n        if contact_activated and (pos[0] - pos[1] = 0):\n            v_final = np.copy(vel_half) # Final velocity is the constant post-impact velocity\n            break\n    else: # This else clause runs if the for loop finishes without a break\n        # This handles the no-contact case. v_final remains vel_0.\n        pass\n\n    # 3. Verification\n    \n    # Check 1: Momentum conservation\n    momentum_ok = max_p_dev = 1e-10\n\n    # Check 2: Post-impact velocities\n    if contact_activated:\n        # Compare with analytical elastic collision velocities\n        m_sum = m1 + m2\n        v1_star = ((m1 - m2) / m_sum) * v1_0 + ((2 * m2) / m_sum) * v2_0\n        v2_star = ((2 * m1) / m_sum) * v1_0 + ((m2 - m1) / m_sum) * v2_0\n        v_analytical = np.array([v1_star, v2_star], dtype=np.float64)\n    else:\n        # No contact occurred, compare with initial velocities\n        v_analytical = vel_0\n\n    velocity_dev = np.abs(v_final - v_analytical)\n    velocity_ok = np.all(velocity_dev = 1e-3)\n    \n    return momentum_ok, velocity_ok\n\n\ndef solve():\n    # Test cases: (m1, m2, gap0, v1(0), v2(0), kc, gamma)\n    test_cases = [\n        # Test A (general unequal masses, approaching)\n        (1.0, 2.0, 0.01, 1.0, 0.0, 1.0e6, 0.90),\n        # Test B (no contact, separating)\n        (1.0, 1.5, 0.01, 0.0, 0.5, 1.0e5, 0.90),\n        # Test C (stiff contact, near stability limit)\n        (0.5, 5.0, 0.005, 2.0, 0.0, 5.0e6, 0.99),\n        # Test D (equal masses, generic approaching)\n        (1.0, 1.0, 0.02, 1.2, -0.4, 2.0e6, 0.80),\n    ]\n\n    results = []\n    for case in test_cases:\n        m1, m2, gap0, v1_0, v2_0, kc, gamma = case\n        momentum_ok, velocity_ok = run_simulation_case(m1, m2, gap0, v1_0, v2_0, kc, gamma)\n        # Final result is the logical conjunction of both conditions\n        final_result = momentum_ok and velocity_ok\n        results.append(str(final_result))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Real-world explicit dynamics simulations often involve complex, evolving scenarios where material degrades and elements are removed from the mesh. This advanced practice tackles the critical challenge of maintaining numerical stability under such conditions by designing an adaptive time-stepping algorithm. You will develop a routine that monitors the stability limit of every element at each time step, dynamically adjusting the global time increment to ensure the simulation remains valid as the model state changes . This exercise provides a window into the sophisticated logic that powers production-level explicit finite element codes.",
            "id": "3564264",
            "problem": "You are tasked with developing, from first principles, a runtime algorithm for time-step control in an explicit central difference integration of a one-dimensional small-strain linear elastic bar discretized by finite elements. The mesh may change during the simulation due to element erosion. The goal is to ensure numerical stability by maintaining the global time increment below a conservative stability bound that adapts to geometry and material changes, and to do so by tracking the smallest admissible element time increment as the mesh evolves.\n\nStart from the continuum momentum balance and its semi-discrete finite element form to derive a conservative, element-wise stability bound in terms of elemental geometric and material quantities. Then, design a runtime algorithm that, at each global step, computes a global stable increment as a safety-scaled minimum over the current set of active elements. The mesh changes via an erosion rule that permanently removes elements when a scalar damage variable exceeds a threshold. The algorithm must support per-step updates of element length and damage, must immediately reflect removals in the global time step, and must continue the simulation until either the prescribed physical end time is reached or all elements have been removed.\n\nAt each step, compute the stability-based candidate increment based on the current active elements prior to any end-time truncation. Advance the physical time by the executed increment, which is the minimum of the stability-based candidate and the remaining time to the end. For the purpose of statistics requested below, use only the stability-based candidate values, ignoring the final truncation to exactly hit the end time.\n\nPhysical model and update rules:\n- Each element $i$ has current length $L_i^n$ in $\\mathrm{m}$ at step $n$, density $\\rho_i$ in $\\mathrm{kg/m^3}$ (constant), and current Young’s modulus $E_i^n$ in $\\mathrm{Pa}$. The initial values are $L_i^0 = L_{0,i}$, $E_i^0 = E_{0,i}$.\n- The element wave speed is $c_i^n$ in $\\mathrm{m/s}$, defined by your derivation from first principles.\n- The per-step length update is $L_i^{n+1} = L_i^n (1 + s_i)$, where $s_i$ is a given per-step engineering strain increment (dimensionless). Assume $|s_i| \\ll 1$ so small-strain kinematics are self-consistent stepwise.\n- The scalar damage variable $d_i^n \\in [0,1]$ evolves as $d_i^{n+1} = \\min\\{1, d_i^n + g_i\\}$, with a given per-step increment $g_i \\ge 0$ (dimensionless). The modulus degrades as $E_i^n = (1 - d_i^n) E_{0,i}$.\n- Erosion: if $d_i^{n+1} \\ge d_{\\mathrm{thr},i}$ at the end of a step, element $i$ is removed before the next step and remains inactive thereafter.\n- The global time increment at step $n$ is the safety factor $\\eta \\in (0,1)$ multiplied by the minimum, over all currently active elements, of an element-wise conservative stability bound that you must derive using the explicit central difference method. Denote this candidate by $\\Delta t_{\\mathrm{cand}}^n$. The executed increment is $\\Delta t_{\\mathrm{exec}}^n = \\min\\{\\Delta t_{\\mathrm{cand}}^n, T_{\\mathrm{end}} - t^n\\}$.\n\nAssumptions:\n- One-dimensional bar kinematics, small strain, linear elasticity, no external forcing; focus entirely on stability of the homogeneous update.\n- Use standard finite element mass and stiffness constructions and a physically sound conservative bound appropriate for explicit central difference time integration.\n- The safety factor is $\\eta = 0.9$.\n- When no active elements remain, set the candidate increment to $\\Delta t_{\\mathrm{cand}}^n = 0$ and terminate the simulation immediately.\n\nRequired outputs per test case:\n- The initial candidate global increment $\\Delta t_{\\mathrm{cand}}^0$ in $\\mathrm{s}$.\n- The minimum over all steps of the candidate global increment $\\min_n \\Delta t_{\\mathrm{cand}}^n$ in $\\mathrm{s}$.\n- The maximum over all steps of the candidate global increment $\\max_n \\Delta t_{\\mathrm{cand}}^n$ in $\\mathrm{s}$.\n- The total number of executed steps (an integer), i.e., the count of $\\Delta t_{\\mathrm{exec}}^n$ used before termination.\nFor the minimum and maximum, do not consider the final truncation used to exactly hit $T_{\\mathrm{end}}$; use only the stability-based candidates.\n\nUnits and formatting:\n- All lengths must be in $\\mathrm{m}$, densities in $\\mathrm{kg/m^3}$, moduli in $\\mathrm{Pa}$, and times in $\\mathrm{s}$. Express all time quantities in $\\mathrm{s}$.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case result is itself a list in the order $[\\Delta t_{\\mathrm{cand}}^0, \\min_n \\Delta t_{\\mathrm{cand}}^n, \\max_n \\Delta t_{\\mathrm{cand}}^n, \\text{steps}]$. For example: $[[a,b,c,d],[e,f,g,h],[i,j,k,l]]$. Use standard decimal or scientific notation for real numbers.\n\nTest suite:\n- Case $1$ (happy path, no erosion):\n  - $N = 4$.\n  - $\\rho = [7800, 7800, 7800, 7800]\\ \\mathrm{kg/m^3}$.\n  - $E_0 = [2.10 \\times 10^{11}, 2.10 \\times 10^{11}, 2.10 \\times 10^{11}, 2.10 \\times 10^{11}]\\ \\mathrm{Pa}$.\n  - $L_0 = [0.010, 0.012, 0.009, 0.011]\\ \\mathrm{m}$.\n  - $s = [0, 0, 0, 0]$.\n  - $g = [0, 0, 0, 0]$.\n  - $d_{\\mathrm{thr}} = [1, 1, 1, 1]$.\n  - $T_{\\mathrm{end}} = 1.0 \\times 10^{-4}\\ \\mathrm{s}$.\n- Case $2$ (erosion increases the global time step mid-run):\n  - $N = 5$.\n  - $\\rho = [2700, 2700, 7800, 7800, 7800]\\ \\mathrm{kg/m^3}$.\n  - $E_0 = [7.0 \\times 10^{10}, 7.0 \\times 10^{10}, 2.10 \\times 10^{11}, 2.10 \\times 10^{11}, 2.10 \\times 10^{11}]\\ \\mathrm{Pa}$.\n  - $L_0 = [0.010, 0.006, 0.008, 0.005, 0.007]\\ \\mathrm{m}$.\n  - $s = [0, 0, 0, 0, 0]$.\n  - $g = [0.02, 0.05, 0, 0.03, 0]$.\n  - $d_{\\mathrm{thr}} = [0.5, 0.5, 0.5, 0.5, 0.5]$.\n  - $T_{\\mathrm{end}} = 1.0 \\times 10^{-4}\\ \\mathrm{s}$.\n- Case $3$ (edge case, all elements erode almost immediately):\n  - $N = 3$.\n  - $\\rho = [1000, 1000, 1000]\\ \\mathrm{kg/m^3}$.\n  - $E_0 = [3.0 \\times 10^{9}, 3.0 \\times 10^{9}, 3.0 \\times 10^{9}]\\ \\mathrm{Pa}$.\n  - $L_0 = [0.004, 0.004, 0.004]\\ \\mathrm{m}$.\n  - $s = [0, 0, 0]$.\n  - $g = [0.5, 0.5, 0.5]$.\n  - $d_{\\mathrm{thr}} = [0.5, 0.5, 0.5]$.\n  - $T_{\\mathrm{end}} = 1.0 \\times 10^{-3}\\ \\mathrm{s}$.\n\nYour implementation should follow your derived stability bound and must manage the evolving set of active elements according to the rules above. The required final output format is a single line containing a list of three lists, one per test case, as described above, with all time quantities in $\\mathrm{s}$ and the step count as an integer.",
            "solution": "The problem of determining a stable time increment for an explicit dynamic simulation is fundamental to computational mechanics. The approach requires deriving the stability limit for the chosen time integration scheme—the explicit central difference method—as applied to the spatially discretized system—a bar modeled with finite elements. This limit, known as the Courant-Friedrichs-Lewy (CFL) condition, dictates that information (a physical wave) must not travel across more than one element in a single time step. We will derive this condition from first principles and then construct an algorithm to adapt the global time step based on the evolving material properties and mesh geometry.\n\n### Derivation of the Stability-Based Time Increment\n\n1.  **Continuum Equation of Motion**: The dynamics of a one-dimensional elastic bar, assuming small strains and no body forces, is governed by the momentum balance equation:\n    $$\n    \\rho \\frac{\\partial^2 u}{\\partial t^2} = \\frac{\\partial \\sigma}{\\partial x}\n    $$\n    where $\\rho$ is the material density, $u(x,t)$ is the axial displacement, and $\\sigma(x,t)$ is the axial stress.\n\n2.  **Constitutive and Kinematic Relations**: For a linear elastic material, the stress is related to strain $\\epsilon$ by Hooke's Law: $\\sigma = E \\epsilon$, where $E$ is Young's modulus. The small-strain assumption provides the kinematic relation $\\epsilon = \\frac{\\partial u}{\\partial x}$. Substituting these into the momentum equation yields the 1D wave equation:\n    $$\n    \\rho \\frac{\\partial^2 u}{\\partial t^2} = E \\frac{\\partial^2 u}{\\partial x^2} \\implies \\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2}\n    $$\n    where $c = \\sqrt{E/\\rho}$ is the material's longitudinal wave speed.\n\n3.  **Finite Element Semi-Discretization**: The continuous domain is discretized into finite elements. This process transforms the partial differential equation into a system of ordinary differential equations in time, known as the semi-discrete equation of motion:\n    $$\n    \\mathbf{M} \\ddot{\\mathbf{u}}(t) + \\mathbf{K} \\mathbf{u}(t) = \\mathbf{F}_{\\text{ext}}(t)\n    $$\n    Here, $\\mathbf{u}(t)$ is the vector of global nodal displacements, $\\ddot{\\mathbf{u}}(t)$ is the vector of nodal accelerations, $\\mathbf{M}$ is the global mass matrix, $\\mathbf{K}$ is the global stiffness matrix, and $\\mathbf{F}_{\\text{ext}}$ is the vector of external nodal forces, which is zero for this problem. For explicit methods, it is standard and computationally necessary to use a lumped (diagonal) mass matrix, $\\mathbf{M}_L$, which uncouples the equations. For a 1D linear bar element $i$ of length $L_i$ and constant cross-sectional area $A_i$, the element stiffness matrix $\\mathbf{k}_i$ and lumped mass matrix $\\mathbf{m}_{L,i}$ are:\n    $$\n    \\mathbf{k}_i = \\frac{A_i E_i}{L_i} \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix}, \\quad \\mathbf{m}_{L,i} = \\frac{\\rho_i A_i L_i}{2} \\begin{bmatrix} 1  0 \\\\ 0  1 \\end{bmatrix}\n    $$\n\n4.  **Central Difference Time Integration**: The explicit central difference scheme approximates the acceleration at step $n$ using nodal displacements at steps $n-1$, $n$, and $n+1$:\n    $$\n    \\ddot{\\mathbf{u}}^n \\approx \\frac{\\mathbf{u}^{n+1} - 2\\mathbf{u}^n + \\mathbf{u}^{n-1}}{(\\Delta t)^2}\n    $$\n    Substituting this into the semi-discrete equation $\\mathbf{M}_L \\ddot{\\mathbf{u}}^n + \\mathbf{K} \\mathbf{u}^n = \\mathbf{0}$ gives the update rule for the displacement vector:\n    $$\n    \\mathbf{u}^{n+1} = 2\\mathbf{u}^n - \\mathbf{u}^{n-1} - (\\Delta t)^2 \\mathbf{M}_L^{-1} \\mathbf{K} \\mathbf{u}^n\n    $$\n\n5.  **Stability Analysis**: The numerical stability of the central difference scheme is conditional. An error analysis shows that the scheme is stable if the time step $\\Delta t$ satisfies:\n    $$\n    \\Delta t \\le \\frac{2}{\\omega_{\\max}}\n    $$\n    where $\\omega_{\\max}$ is the highest natural frequency of the discretized system, given by the square root of the largest eigenvalue of the matrix pencil $(\\mathbf{K}, \\mathbf{M}_L)$, i.e., $\\omega_{\\max}^2 = \\lambda_{\\max}(\\mathbf{M}_L^{-1} \\mathbf{K})$.\n\n6.  **Element-wise Stability Bound**: Computing the global maximum eigenvalue $\\omega_{\\max}$ is computationally prohibitive for a runtime algorithm. A standard, conservative practice is to bound $\\omega_{\\max}$ by the maximum frequency of any individual element in the mesh, $\\omega_{\\max} \\le \\max_i (\\omega_{\\max}^{(i)})$. The highest frequency of a single element $i$, $\\omega_{\\max}^{(i)}$, can be found by solving the element-level eigenvalue problem: $(\\mathbf{k}_i - (\\omega^{(i)})^2 \\mathbf{m}_{L,i})\\mathbf{v} = \\mathbf{0}$. The maximum non-zero eigenvalue gives:\n    $$\n    (\\omega_{\\max}^{(i)})^2 = \\frac{4 E_i}{\\rho_i L_i^2} \\implies \\omega_{\\max}^{(i)} = \\frac{2}{L_i} \\sqrt{\\frac{E_i}{\\rho_i}} = \\frac{2 c_i}{L_i}\n    $$\n    Applying the stability condition to this elemental frequency gives the element's stability limit:\n    $$\n    \\Delta t_i \\le \\frac{2}{\\omega_{\\max}^{(i)}} = \\frac{2}{2c_i/L_i} = \\frac{L_i}{c_i}\n    $$\n    This is the CFL condition for element $i$: the time step must be no larger than the time required for a wave, traveling at speed $c_i$, to propagate across the element's length $L_i$.\n\n7.  **Adaptive Global Time Increment**: For the entire mesh to be stable, the global time step $\\Delta t$ must be smaller than the minimum of all elemental stability limits. Thus, at each step $n$, we compute a candidate global increment by applying a safety factor $\\eta$ to the minimum elemental time step over all currently active elements:\n    $$\n    \\Delta t_{\\mathrm{cand}}^n = \\eta \\min_{i \\in \\text{active}} \\left( \\frac{L_i^n}{c_i^n} \\right)\n    $$\n    The problem specifies that the length $L_i^n$, density $\\rho_i$, and Young's modulus $E_i^n$ are element-specific and can evolve. The modulus degrades with a scalar damage variable $d_i^n$ as $E_i^n = (1-d_i^n)E_{0,i}$. The wave speed is therefore also state-dependent: $c_i^n = \\sqrt{E_i^n / \\rho_i}$. The final expression for the candidate time increment is:\n    $$\n    \\Delta t_{\\mathrm{cand}}^n = \\eta \\min_{i \\in \\text{active}} \\left( L_i^n \\sqrt{\\frac{\\rho_i}{(1-d_i^n)E_{0,i}}} \\right)\n    $$\n\n### Algorithm Design\nThe runtime algorithm implements this derived formula within a simulation loop that tracks the evolution of each element's state and the set of active elements.\n\n1.  **Initialization**: For each test case, initialize numpy arrays for element properties: initial lengths ($L_0$), densities ($\\rho$), initial moduli ($E_0$), per-step strain increments ($s$), and per-step damage increments ($g$). Initialize state arrays for current length $L$, damage $d$, and modulus $E$. A boolean array `active_mask` tracks which elements are part of the simulation. Set simulation time $t=0$ and step count to 0.\n\n2.  **Simulation Loop**: The simulation proceeds as long as the current time $t$ is less than the prescribed end time $T_{\\mathrm{end}}$ and there is at least one active element.\n    a.  **Compute Candidate Increment**: At the beginning of each step, calculate the elemental stability limits $L_i^n / c_i^n$ for all elements where `active_mask` is true. Special care is taken for elements where the modulus $E_i^n$ might become zero (due to damage $d_i^n=1$); their contribution to the minimum is taken as infinite, effectively removing them from consideration for the time step limit. The minimum of these values is found, and the candidate global increment $\\Delta t_{\\mathrm{cand}}^n$ is computed by multiplying by the safety factor $\\eta=0.9$.\n    b.  **Collect Statistics**: The computed $\\Delta t_{\\mathrm{cand}}^n$ is recorded for later calculation of the initial, minimum, and maximum values over the simulation.\n    c.  **Determine Executed Increment**: The actual time step taken, $\\Delta t_{\\mathrm{exec}}^n$, is the minimum of the candidate increment and the time remaining to reach $T_{\\mathrm{end}}$.\n    d.  **Advance State**: The simulation time $t$ is incremented by $\\Delta t_{\\mathrm{exec}}^n$, and the step counter is increased.\n    e.  **Update Element Properties**: The length $L_i$, damage $d_i$, and modulus $E_i$ of all elements are updated according to the provided rules: $L_i^{n+1} = L_i^n(1+s_i)$ and $d_i^{n+1} = \\min(1, d_i^n + g_i)$.\n    f.  **Element Erosion**: After updating the damage, each element is checked against its erosion threshold $d_{\\mathrm{thr},i}$. If an element's damage meets or exceeds its threshold, its corresponding entry in `active_mask` is set to `False`, permanently removing it from subsequent time step calculations.\n\n3.  **Termination and Output**: The loop terminates when $t \\ge T_{\\mathrm{end}}$ or when `active_mask` contains no `True` values. The collected statistics ($\\Delta t_{\\mathrm{cand}}^0$, $\\min_n \\Delta t_{\\mathrm{cand}}^n$, $\\max_n \\Delta t_{\\mathrm{cand}}^n$, and total steps) are then formatted and returned for the test case.\n\nThis procedure ensures that the simulation remains numerically stable while adapting to changes in element properties and the active mesh configuration.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the adaptive time-stepping statistics based on the explicit central difference method\n    stability for a 1D bar with evolving properties and element erosion.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (happy path, no erosion)\n        {\n            \"N\": 4,\n            \"rho\": [7800, 7800, 7800, 7800],\n            \"E0\": [2.10e11, 2.10e11, 2.10e11, 2.10e11],\n            \"L0\": [0.010, 0.012, 0.009, 0.011],\n            \"s\": [0, 0, 0, 0],\n            \"g\": [0, 0, 0, 0],\n            \"d_thr\": [1, 1, 1, 1],\n            \"T_end\": 1.0e-4\n        },\n        # Case 2 (erosion increases the global time step mid-run)\n        {\n            \"N\": 5,\n            \"rho\": [2700, 2700, 7800, 7800, 7800],\n            \"E0\": [7.0e10, 7.0e10, 2.10e11, 2.10e11, 2.10e11],\n            \"L0\": [0.010, 0.006, 0.008, 0.005, 0.007],\n            \"s\": [0, 0, 0, 0, 0],\n            \"g\": [0.02, 0.05, 0, 0.03, 0],\n            \"d_thr\": [0.5, 0.5, 0.5, 0.5, 0.5],\n            \"T_end\": 1.0e-4\n        },\n        # Case 3 (edge case, all elements erode almost immediately)\n        {\n            \"N\": 3,\n            \"rho\": [1000, 1000, 1000],\n            \"E0\": [3.0e9, 3.0e9, 3.0e9],\n            \"L0\": [0.004, 0.004, 0.004],\n            \"s\": [0, 0, 0],\n            \"g\": [0.5, 0.5, 0.5],\n            \"d_thr\": [0.5, 0.5, 0.5],\n            \"T_end\": 1.0e-3\n        }\n    ]\n\n    all_results = []\n    eta = 0.9\n\n    for case_data in test_cases:\n        N = case_data[\"N\"]\n        T_end = case_data[\"T_end\"]\n        \n        # Convert lists to numpy arrays for vectorized operations\n        rho = np.array(case_data[\"rho\"], dtype=float)\n        E0 = np.array(case_data[\"E0\"], dtype=float)\n        s = np.array(case_data[\"s\"], dtype=float)\n        g = np.array(case_data[\"g\"], dtype=float)\n        d_thr = np.array(case_data[\"d_thr\"], dtype=float)\n        \n        # Initialize state variables\n        L = np.array(case_data[\"L0\"], dtype=float)\n        d = np.zeros(N, dtype=float)\n        active_mask = np.ones(N, dtype=bool)\n\n        current_time = 0.0\n        step_count = 0\n        dt_cand_history = []\n        \n        # Main simulation loop\n        while current_time  T_end and np.any(active_mask):\n            \n            # --- Step n: Calculation before advancing time ---\n\n            # 1. Compute current modulus based on damage from previous step\n            E = (1.0 - d) * E0\n\n            # 2. Compute stability-based candidate increment\n            L_active = L[active_mask]\n            rho_active = rho[active_mask]\n            E_active = E[active_mask]\n\n            # To avoid division by zero when E=0 (d=1), treat the term as infinity.\n            # E_active > 0 is a safe check.\n            c_squared_active = np.full_like(E_active, np.inf)\n            valid_E_mask = E_active > 0\n            c_squared_active[valid_E_mask] = E_active[valid_E_mask] / rho_active[valid_E_mask]\n            \n            # Element-wise stability limits (L/c)\n            dt_elems = L_active / np.sqrt(c_squared_active)\n            \n            dt_cand = eta * np.min(dt_elems)\n            dt_cand_history.append(dt_cand)\n\n            # 3. Determine executed time increment and advance time\n            time_to_end = T_end - current_time\n            dt_exec = min(dt_cand, time_to_end)\n            \n            current_time += dt_exec\n            step_count += 1\n            \n            # --- Update state for Step n+1 ---\n\n            # 4. Update element properties\n            L *= (1.0 + s)\n            d = np.minimum(1.0, d + g)\n\n            # 5. Apply erosion for the next step\n            # Element is removed if its new damage exceeds the threshold\n            eroded_mask = d >= d_thr\n            active_mask[eroded_mask] = False\n\n        # Post-processing for this test case\n        if not dt_cand_history:\n            # Case where simulation does not run (e.g., T_end=0 or no elements)\n            dt_cand_0 = 0.0\n            min_dt_cand = 0.0\n            max_dt_cand = 0.0\n        else:\n            dt_cand_0 = dt_cand_history[0]\n            min_dt_cand = min(dt_cand_history)\n            max_dt_cand = max(dt_cand_history)\n\n        all_results.append([dt_cand_0, min_dt_cand, max_dt_cand, step_count])\n\n    # Final print statement in the exact required format.\n    # The str() function on a list correctly formats it as '[...]'\n    # The outer join then assembles the final list of lists apecarance.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        }
    ]
}