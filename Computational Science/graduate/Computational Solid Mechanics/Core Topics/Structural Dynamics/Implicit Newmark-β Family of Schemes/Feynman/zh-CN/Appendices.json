{
    "hands_on_practices": [
        {
            "introduction": "作为我们动手实践的起点，我们将为一个在动力学中最基本的系统——单自由度（SDOF）线性振子——实现隐式Newmark-β积分格式。通过从零开始推导有效系统和放大矩阵，您将深入理解该方法在底层的运作机制。这个练习旨在构建核心的编程基础，并引入数值稳定性分析的核心概念 ()。",
            "id": "3573229",
            "problem": "要求您设计并实现一个程序，该程序用于计算计算固体力学中隐式 Newmark-beta 族时间积分格式的有效系统和算法系数，并使用它们对单自由度 (SDOF) 线性振子执行单步更新，并通过放大矩阵评估线性稳定性。\n\n从源自 Newton 第二运动定律的 SDOF 系统基本运动控制方程开始：\n$$\nm \\, \\ddot{u}(t) + c \\, \\dot{u}(t) + k \\, u(t) = f(t),\n$$\n其中 $m$ 是质量，$c$ 是粘性阻尼系数，$k$ 是线性刚度，$u(t)$ 是位移，$\\dot{u}(t)$ 是速度，$\\ddot{u}(t)$ 是加速度，$f(t)$ 是外力。单位必须一致使用：$m$ 的单位是 $\\mathrm{kg}$，$c$ 的单位是 $\\mathrm{N \\cdot s/m}$，$k$ 的单位是 $\\mathrm{N/m}$，$t$ 的单位是 $\\mathrm{s}$，$u$ 的单位是 $\\mathrm{m}$，$\\dot{u}$ 的单位是 $\\mathrm{m/s}$，$\\ddot{u}$ 的单位是 $\\mathrm{m/s^2}$，$f$ 的单位是 $\\mathrm{N}$。\n\n隐式 Newmark-beta 族格式使用两个参数 $ \\beta $ 和 $ \\gamma $，将时间 $t_{n+1}=t_n+\\Delta t$ 时的 $u_{n+1}$、$v_{n+1}$ 和 $a_{n+1}$ 与时间 $t_n$ 时的已知状态 $(u_n, v_n, a_n)$ 联系起来，时间步长 $\\Delta t > 0$ 为固定值。基于上述基础，推导隐式求解 $u_{n+1}$ 所需的一致有效系统，以及在 SDOF 情况下的有效刚度和有效荷载中出现的相关算法系数。然后，使用相同的原理和 Newmark-beta 方法的离散更新关系，推导从 $u_{n+1}$ 和已知的先前状态恢复 $a_{n+1}$ 和 $v_{n+1}$ 的公式。最后，定义将齐次问题（$f \\equiv 0$）的状态向量 $[u_n, v_n, a_n]^T$ 映射到 $[u_{n+1}, v_{n+1}, a_{n+1}]^T$ 的线性放大映射，并通过直接构造该映射来确定给定参数下的谱半径。\n\n您的程序必须实现这些步骤，并对下面的每个测试用例计算：\n- 在隐式 Newmark-beta 格式的有效系统和荷载组装中出现的六个算法系数（量纲一致）。\n- 在 $t_{n+1}$ 时刻隐式求解中 SDOF 系统的有效标量刚度 $k_{\\mathrm{eff}}$。\n- 使用给定的 $f_{n+1}$ 和提供的先前状态 $(u_n, v_n, a_n)$ 从有效系统计算出的单步更新位移 $u_{n+1}$。\n- 对于给定的 $(m,c,k,\\Delta t,\\beta,\\gamma)$，与齐次（$f \\equiv 0$）离散更新映射相关的放大矩阵的谱半径 $\\rho$。\n\n使用连贯的国际单位制。将谱半径 $\\rho$ 报告为无量纲实数。将 $k_{\\mathrm{eff}}$ 以 $\\mathrm{N/m}$ 为单位报告，将 $u_{n+1}$ 以 $\\mathrm{m}$ 为单位报告。不要进行四舍五入；使用标准双精度浮点运算进行计算。\n\n测试套件（每个案例定义了 $t_n$ 时的参数和先前状态，以及 $t_{n+1}$ 时的外力）：\n1. 案例 A（理想情况，轻度阻尼）：\n   - $m = 2.0 \\, \\mathrm{kg}$，$c = 0.5 \\, \\mathrm{N \\cdot s/m}$，$k = 50.0 \\, \\mathrm{N/m}$，$\\Delta t = 0.1 \\, \\mathrm{s}$，$\\beta = 0.25$，$\\gamma = 0.5$。\n   - 先前状态：$u_n = 0.02 \\, \\mathrm{m}$，$v_n = 0.0 \\, \\mathrm{m/s}$，$a_n = 0.0 \\, \\mathrm{m/s^2}$。\n   - 下一步的外力：$f_{n+1} = 1.0 \\, \\mathrm{N}$。\n2. 案例 B（无阻尼，刚性，小时间步长）：\n   - $m = 1.0 \\, \\mathrm{kg}$，$c = 0.0 \\, \\mathrm{N \\cdot s/m}$，$k = 1000.0 \\, \\mathrm{N/m}$，$\\Delta t = 0.01 \\, \\mathrm{s}$，$\\beta = 0.3025$，$\\gamma = 0.6$。\n   - 先前状态：$u_n = 0.0 \\, \\mathrm{m}$，$v_n = 1.0 \\, \\mathrm{m/s}$，$a_n = 0.0 \\, \\mathrm{m/s^2}$。\n   - 下一步的外力：$f_{n+1} = 0.0 \\, \\mathrm{N}$。\n3. 案例 C（重度阻尼，较大时间步长）：\n   - $m = 1.0 \\, \\mathrm{kg}$，$c = 5.0 \\, \\mathrm{N \\cdot s/m}$，$k = 20.0 \\, \\mathrm{N/m}$，$\\Delta t = 0.2 \\, \\mathrm{s}$，$\\beta = 0.25$，$\\gamma = 0.6$。\n   - 先前状态：$u_n = -0.1 \\, \\mathrm{m}$，$v_n = 0.5 \\, \\mathrm{m/s}$，$a_n = 0.0 \\, \\mathrm{m/s^2}$。\n   - 下一步的外力：$f_{n+1} = 0.0 \\, \\mathrm{N}$。\n\n您的程序必须：\n- 推导并使用一致的隐式 Newmark-beta 有效系统和算法系数。\n- 针对给定的 $f_{n+1}$ 和先前状态，组装并求解 $u_{n+1}$ 的标量有效系统。\n- 使用 Newmark-beta 更新关系式，从 $u_{n+1}$ 和先前状态恢复 $a_{n+1}$ 和 $v_{n+1}$。\n- 通过将单步映射应用于齐次问题的三个规范基初始状态来构造 $3 \\times 3$ 放大矩阵，并计算其谱半径 $\\rho$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个包含三个结果的列表，每个测试用例一个结果，其中每个测试用例结果本身是按以下顺序排列的九个浮点数的列表：\n  $[k_{\\mathrm{eff}}, a_0, a_1, a_2, a_3, a_4, a_5, \\rho, u_{n+1}]$。\n- 该行必须是严格的 Python 风格的列表字面量，不带任何额外文本，例如：\n  $[[\\dots\\text{案例 A 的九个值}\\dots],[\\dots\\text{案例 B 的九个值}\\dots],[\\dots\\text{案例 C 的九个值}\\dots]]$。",
            "solution": "该问题要求设计并实现一个程序，使用隐式 Newmark-beta 族时间积分格式来分析单自由度 (SDOF) 线性振子。这包括推导和计算有效系统系数、执行单步时间更新，以及通过其放大矩阵评估该格式的线性稳定性。\n\n分析始于 SDOF 系统的控制微分方程：\n$$\nm \\, \\ddot{u}(t) + c \\, \\dot{u}(t) + k \\, u(t) = f(t)\n$$\n其中 $m$、$c$ 和 $k$ 分别是质量、阻尼和刚度系数。$u(t)$、$\\dot{u}(t)$ 和 $\\ddot{u}(t)$ 分别是位移、速度和加速度。我们将时间 $t_n$ 时的离散近似值表示为 $u_n$、$v_n = \\dot{u}(t_n)$ 和 $a_n = \\ddot{u}(t_n)$。\n\nNewmark-beta 方法提供了在时间 $t_{n+1} = t_n + \\Delta t$ 时位移和速度的更新规则：\n$$\nu_{n+1} = u_n + \\Delta t \\, v_n + \\Delta t^2 \\left[ \\left(\\frac{1}{2} - \\beta\\right) a_n + \\beta a_{n+1} \\right] \\quad (1)\n$$\n$$\nv_{n+1} = v_n + \\Delta t \\left[ (1-\\gamma) a_n + \\gamma a_{n+1} \\right] \\quad (2)\n$$\n其中 $\\beta$ 和 $\\gamma$ 是该格式的无量纲参数。\n\n### 有效系统的推导\n\n对于隐式格式，运动方程在时间步长结束时（即 $t_{n+1}$）强制成立：\n$$\nm a_{n+1} + c v_{n+1} + k u_{n+1} = f_{n+1} \\quad (3)\n$$\n主要未知数是位移 $u_{n+1}$。为了求解它，我们必须将 $a_{n+1}$ 和 $v_{n+1}$ 表示为 $u_{n+1}$ 和 $t_n$ 时刻已知状态的函数。\n\n从方程 (1) 中，我们可以重新整理以将 $a_{n+1}$ 表示为 $u_{n+1}$ 的函数：\n$$\na_{n+1} = \\frac{1}{\\beta \\Delta t^2} (u_{n+1} - u_n) - \\frac{1}{\\beta \\Delta t} v_n - \\left(\\frac{1}{2\\beta} - 1\\right) a_n \\quad (A)\n$$\n现在，将这个 $a_{n+1}$ 的表达式代入方程 (2)，以找到用 $u_{n+1}$ 表示的 $v_{n+1}$：\n$$\nv_{n+1} = v_n + (1-\\gamma)\\Delta t a_n + \\gamma \\Delta t \\left[ \\frac{1}{\\beta \\Delta t^2} (u_{n+1} - u_n) - \\frac{1}{\\beta \\Delta t} v_n - \\left(\\frac{1}{2\\beta} - 1\\right) a_n \\right]\n$$\n按状态变量对各项进行分组可得：\n$$\nv_{n+1} = \\frac{\\gamma}{\\beta \\Delta t} (u_{n+1} - u_n) + \\left(1 - \\frac{\\gamma}{\\beta}\\right)v_n + \\Delta t \\left(1 - \\frac{\\gamma}{2\\beta}\\right)a_n \\quad (B)\n$$\n\n接下来，我们将表达式 (A) 和 (B) 代入运动方程 (3)。为了使公式适用于通用求解器，我们将其重排为线性系统 $k_{\\mathrm{eff}} u_{n+1} = f_{\\mathrm{eff}}$ 的形式。我们将所有包含未知数 $u_{n+1}$ 的项归到左侧 (LHS)，所有已知量归到右侧 (RHS)。\n\n$$\nm a_{n+1} + c v_{n+1} + k u_{n+1} = f_{n+1}\n$$\n$$\nm\\left(\\dots\\right) + c\\left(\\dots\\right) + k u_{n+1} = f_{n+1}\n$$\n代入 (A) 和 (B) 并重新排列：\n$$\n\\left( \\frac{1}{\\beta \\Delta t^2}m + \\frac{\\gamma}{\\beta \\Delta t}c + k \\right) u_{n+1} = f_{n+1} + m\\left(\\frac{u_n}{\\beta \\Delta t^2} + \\frac{v_n}{\\beta \\Delta t} + \\left(\\frac{1}{2\\beta}-1\\right)a_n\\right) + c\\left(\\frac{\\gamma u_n}{\\beta \\Delta t} + \\left(\\frac{\\gamma}{\\beta} - 1 \\right)v_n + \\Delta t\\left(\\frac{\\gamma}{2\\beta} - 1\\right)a_n\\right)\n$$\n\n从这个方程中，我们可以确定有效刚度 $k_{\\mathrm{eff}}$ 和有效荷载 $f_{\\mathrm{eff}}$。\n\n**有效刚度：**\n$$\nk_{\\mathrm{eff}} = k + \\frac{\\gamma}{\\beta \\Delta t} c + \\frac{1}{\\beta \\Delta t^2} m\n$$\n\n**算法系数：** 问题要求在有效系统组装中出现的六个算法系数。基于推导出的有效系统方程，一组一致且有意义的六个系数是：\n- $a_0 = \\frac{1}{\\beta \\Delta t^2}$：在 $k_{\\mathrm{eff}}$ 中与 $m$ 相乘的系数，以及在 RHS 上与 $m u_n$ 相乘的系数。\n- $a_1 = \\frac{\\gamma}{\\beta \\Delta t}$：在 $k_{\\mathrm{eff}}$ 中与 $c$ 相乘的系数，以及在 RHS 上与 $c u_n$ 相乘的系数。\n- $a_2 = \\frac{1}{\\beta \\Delta t}$：RHS 上质量项对 $v_n$ 贡献的系数。\n- $a_3 = \\frac{1}{2\\beta} - 1$：RHS 上质量项对 $a_n$ 贡献的系数。\n- $a_4 = \\frac{\\gamma}{\\beta} - 1$：RHS 上阻尼项对 $v_n$ 贡献的系数。\n- $a_5 = \\Delta t \\left( \\frac{\\gamma}{2\\beta} - 1 \\right)$：RHS 上阻尼项对 $a_n$ 贡献的系数。\n\n使用这些系数，有效系统为：\n$$\nk_{\\mathrm{eff}} = k + a_1 c + a_0 m\n$$\n$$\nf_{\\mathrm{eff}} = f_{n+1} + m(a_0 u_n + a_2 v_n + a_3 a_n) + c(a_1 u_n + a_4 v_n + a_5 a_n)\n$$\n更新过程为：首先求解 $u_{n+1} = f_{\\mathrm{eff}} / k_{\\mathrm{eff}}$，然后分别使用方程 (A) 和 (2) 恢复 $a_{n+1}$ 和 $v_{n+1}$。\n\n### 通过放大矩阵进行稳定性分析\n\n为了分析数值格式的稳定性，我们考虑齐次问题（$f(t) \\equiv 0$）。单步更新可以写成一个从 $t_n$ 时刻的状态向量 $\\mathbf{d}_n = [u_n, v_n, a_n]^T$ 到 $t_{n+1}$ 时刻的状态向量 $\\mathbf{d}_{n+1} = [u_{n+1}, v_{n+1}, a_{n+1}]^T$ 的线性映射：\n$$\n\\mathbf{d}_{n+1} = \\mathbf{A} \\, \\mathbf{d}_n\n$$\n其中 $\\mathbf{A}$ 是 $3 \\times 3$ 的放大矩阵。如果谱半径 $\\rho(\\mathbf{A}) = \\max_i |\\lambda_i|$ 小于或等于 $1$，则该格式是稳定的，其中 $\\lambda_i$ 是 $\\mathbf{A}$ 的特征值。\n\n为了推导 $\\mathbf{A}$，我们首先用 $t_n$ 时刻的状态来表示 $a_{n+1}$。对于齐次问题，离散运动方程为 $m a_{n+1} + c v_{n+1} + k u_{n+1} = 0$。将 Newmark 更新方程 (1) 和 (2) 代入此式可得：\n$$\nm a_{n+1} + c(v_n + \\Delta t(1-\\gamma) a_n + \\gamma \\Delta t a_{n+1}) + k(u_n + \\Delta t v_n + \\Delta t^2(\\tfrac{1}{2}-\\beta) a_n + \\beta \\Delta t^2 a_{n+1}) = 0\n$$\n求解 $a_{n+1}$：\n$$\n(m + c \\gamma \\Delta t + k \\beta \\Delta t^2) a_{n+1} = -k u_n - (c+k\\Delta t)v_n - (c\\Delta t(1-\\gamma)+k\\Delta t^2(\\tfrac{1}{2}-\\beta)) a_n\n$$\n令 $D = m + c \\gamma \\Delta t + k \\beta \\Delta t^2$。那么 $a_{n+1}$ 是 $u_n, v_n, a_n$ 的线性组合，这定义了 $\\mathbf{A}$ 的第三行：\n$$\na_{n+1} = A_{31} u_n + A_{32} v_n + A_{33} a_n\n$$\n其中\n$A_{31} = -k/D$\n$A_{32} = -(c + k\\Delta t)/D$\n$A_{33} = -(c\\Delta t(1-\\gamma) + k\\Delta t^2(\\tfrac{1}{2}-\\beta))/D$\n\n$\\mathbf{A}$ 的第一行和第二行可以通过将 $a_{n+1}$ 的这个表达式代回到更新方程 (1) 和 (2) 中找到。\n对于 $u_{n+1}$：\n$$\nu_{n+1} = u_n + \\Delta t v_n + \\Delta t^2(\\tfrac{1}{2}-\\beta)a_n + \\beta\\Delta t^2(A_{31}u_n+A_{32}v_n+A_{33}a_n)\n$$\n$$\nA_{11} = 1 + \\beta \\Delta t^2 A_{31}, \\quad A_{12} = \\Delta t + \\beta \\Delta t^2 A_{32}, \\quad A_{13} = \\Delta t^2(\\tfrac{1}{2}-\\beta) + \\beta \\Delta t^2 A_{33}\n$$\n对于 $v_{n+1}$：\n$$\nv_{n+1} = v_n + \\Delta t(1-\\gamma) a_n + \\gamma\\Delta t(A_{31}u_n+A_{32}v_n+A_{33}a_n)\n$$\n$$\nA_{21} = \\gamma\\Delta t A_{31}, \\quad A_{22} = 1 + \\gamma\\Delta t A_{32}, \\quad A_{23} = \\Delta t(1-\\gamma) + \\gamma\\Delta t A_{33}\n$$\n构建了矩阵 $\\mathbf{A}$ 后，可以通过数值计算其特征值来找到谱半径 $\\rho(\\mathbf{A})$。\n\n程序将实现这些推导，为每个测试用例计算所需的量。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes effective system coefficients, one-step update, and spectral radius\n    for the implicit Newmark-beta scheme for an SDOF linear oscillator.\n    \"\"\"\n    # Test cases: (m, c, k, dt, beta, gamma, u_n, v_n, a_n, f_n1)\n    test_cases = [\n        # Case A (happy path, lightly damped)\n        (2.0, 0.5, 50.0, 0.1, 0.25, 0.5, 0.02, 0.0, 0.0, 1.0),\n        # Case B (undamped, stiff, small time step)\n        (1.0, 0.0, 1000.0, 0.01, 0.3025, 0.6, 0.0, 1.0, 0.0, 0.0),\n        # Case C (heavily damped, larger time step)\n        (1.0, 5.0, 20.0, 0.2, 0.25, 0.6, -0.1, 0.5, 0.0, 0.0),\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        m, c, k, dt, beta, gamma, u_n, v_n, a_n, f_n1 = case\n\n        # Part 1: Compute the six algorithmic coefficients\n        # These coefficients are derived from the effective system formulation.\n        # k_eff = k + a_1*c + a_0*m\n        # f_eff = f_n+1 + m*(a_0*u_n + a_2*v_n + a_3*a_n) + c*(a_1*u_n + a_4*v_n + a_5*a_n)\n        \n        # Check for beta = 0 case, which leads to division by zero\n        if beta == 0:\n            # The displacement-based formulation used here is not valid for beta=0.\n            # An acceleration-based formulation would be needed. This is an edge case\n            # not relevant to the test suite, but good practice to consider.\n            # For this problem, we assume beta > 0.\n            pass\n\n        a0 = 1.0 / (beta * dt**2)\n        a1 = gamma / (beta * dt)\n        a2 = 1.0 / (beta * dt)\n        a3 = 1.0 / (2.0 * beta) - 1.0\n        a4 = gamma / beta - 1.0\n        a5 = dt * (gamma / (2.0 * beta) - 1.0)\n\n        # Part 2: Compute effective stiffness and solve for u_{n+1}\n        k_eff = k + a1 * c + a0 * m\n        \n        f_eff_mass = m * (a0 * u_n + a2 * v_n + a3 * a_n)\n        f_eff_damp = c * (a1 * u_n + a4 * v_n + a5 * a_n)\n        f_eff = f_n1 + f_eff_mass + f_eff_damp\n        \n        u_n1 = f_eff / k_eff\n\n        # Part 3: Compute the spectral radius of the amplification matrix\n        # Amplification matrix A maps d_n = [u_n, v_n, a_n]^T to d_{n+1}\n        \n        # Denominator for the amplification matrix elements\n        D = m + c * gamma * dt + k * beta * dt**2\n        \n        # Third row of A (expression for a_{n+1})\n        A31 = -k / D\n        A32 = -(c + k * dt) / D\n        A33 = -(c * dt * (1.0 - gamma) + k * dt**2 * (0.5 - beta)) / D\n        \n        # First row of A (expression for u_{n+1})\n        A11 = 1.0 + beta * dt**2 * A31\n        A12 = dt + beta * dt**2 * A32\n        A13 = dt**2 * (0.5 - beta) + beta * dt**2 * A33\n        \n        # Second row of A (expression for v_{n+1})\n        A21 = gamma * dt * A31\n        A22 = 1.0 + gamma * dt * A32\n        A23 = dt * (1.0 - gamma) + gamma * dt * A33\n        \n        # Construct the amplification matrix\n        A_matrix = np.array([\n            [A11, A12, A13],\n            [A21, A22, A23],\n            [A31, A32, A33]\n        ])\n        \n        # Compute eigenvalues and spectral radius\n        eigenvalues = np.linalg.eigvals(A_matrix)\n        rho = np.max(np.abs(eigenvalues))\n\n        # Assemble results for the current case in the specified order\n        case_results = [k_eff, a0, a1, a2, a3, a4, a5, rho, u_n1]\n        all_results.append(case_results)\n\n    # Final print statement in the exact required format\n    # Printing a list of lists requires careful formatting.\n    # We use repr() on each inner list to get its string representation\n    # and then join them.\n    print(f\"[{','.join(repr(res) for res in all_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了线性系统的基础上，我们现在将挑战一个常见且富有挑战性的非线性问题：摩擦引起的粘滑动力学。在这类仿真中，数值“颤振”是一种常见的伪影。本练习将展示Newmark参数的实用价值，特别是通过选择 $\\gamma > 0.5$ 引入的算法阻尼，在抑制非物理振荡中的作用。您将实现一个摩擦模型，并使用量化指标来评估如何选择参数，以确保仿真的稳定性和准确性 ()。",
            "id": "3573269",
            "problem": "您需要设计并实现一个完整的可运行程序，研究隐式Newmark-$\\beta$族格式中的算法阻尼如何影响摩擦接触中的粘滑动力学，目标是识别能够抑制数值颤振而不过度阻尼物理相关振荡模式的参数区域$\\left(\\beta,\\gamma\\right)$。该研究必须纯粹以数学和逻辑术语进行，并使用与计算固体力学一致的单自由度系统。\n\n从控制定律和定义出发。使用牛顿第二定律和标准的本构关系。考虑一个由简谐外力驱动的单自由度质量-弹簧-阻尼系统，其标量位移为$x(t)$，速度为$v(t)$，加速度为$a(t)$。运动方程为\n$$\nm\\,a(t) + c\\,v(t) + k\\,x(t) = f_{\\mathrm{ext}}(t) + f_{\\mathrm{fr}}(t),\n$$\n其中$m$是质量，$c$是粘性阻尼系数，$k$是刚度，$f_{\\mathrm{ext}}(t)$是外力，$f_{\\mathrm{fr}}(t)$是切向库仑摩擦接触力。外力规定为\n$$\nf_{\\mathrm{ext}}(t) = A \\sin(\\omega t),\n$$\n其中$A$为振幅，$\\omega$为角频率。假设存在一个具有恒定切向速度$v_b$和恒定法向载荷$N$的刚性表面。库仑摩擦定律为\n$$\nf_{\\mathrm{fr}}(t) = \n\\begin{cases}\n\\lambda(t),  \\text{如果粘滞}, \\\\\n-\\mu N\\,\\mathrm{sign}\\big(v(t)-v_b\\big),  \\text{如果滑动},\n\\end{cases}\n$$\n其中静态粘滞容许条件为$\\lvert \\lambda(t) \\rvert \\le \\mu N$，$\\mu$为摩擦系数，$N$为法向载荷。粘滞约束为$v(t) = v_b$，而滑动则施加一个达到库仑极限的摩擦力$f_{\\mathrm{fr}}(t)$，其方向与相对切向速度相反。\n\n使用均匀时间步长$\\Delta t$和由参数$\\beta$和$\\gamma$表征的隐式Newmark-$\\beta$族格式将时间离散化。离散运动学更新关系必须从第一性原理推导（不得直接假设），并且必须能够求解新时间步的未知加速度，以在存在摩擦接触的情况下隐式地施加动力学平衡。在每个时间步中，基于粘滞约束和库仑极限，实现一个一致的粘滑判断程序，以确保摩擦状态和摩擦力满足容许条件。\n\n目的是量化由$\\left(\\beta,\\gamma\\right)$控制的算法（数值）阻尼所引起的数值颤振的发生和普遍性，并识别出那些能够在不严重阻尼物理模式的情况下消除粘滑振荡的参数区域。为此，您必须：\n\n- 实现一个模拟器，在离散隐式平衡和Newmark-$\\beta$运动学条件下，将$\\left(x,v,a\\right)$从$t_n$推进到$t_{n+1}$，同时根据库仑摩擦定律和粘滞容许条件一致地判断粘滞与滑动。\n- 定义一个颤振度量如下：当相对速度大小$\\lvert v(t)-v_b\\rvert$低于一个小阈值$\\varepsilon_r$时，计算连续时间步中状态切换（粘滞 $\\leftrightarrow$ 滑动，或滑动方向翻转）的次数。将此计数除以总时间步数进行归一化，以获得一个无量纲的颤振分数$C \\in [0,1]$。\n- 通过计算周期性强迫下的稳态位移幅值，并将其与使用$\\beta = 1/4$和$\\gamma = 1/2$（无算法数值阻尼）的基准模拟进行比较，来定义一个物理模式保持度量。设$R$为幅值比（测试幅值除以基准幅值），该比值在模拟区间的末段计算，以避免瞬态效应。\n\n如果一个参数区域$\\left(\\beta,\\gamma\\right)$同时满足$C \\le C_{\\max}$和$R \\ge R_{\\min}$，则将其分类为“优良”。其中$C_{\\max}$和$R_{\\min}$是您选择的固定阈值，以确保合理的颤振抑制而不过度衰减物理振荡。您的程序必须为每个测试用例计算一个布尔值，以指示该参数区域是否优良。\n\n使用以下科学上真实的参数和单位：\n\n- 质量 $m = 1$ kg。\n- 刚度 $k = 1000$ N/m。\n- 粘性阻尼 $c = 1$ N·s/m。\n- 摩擦系数 $\\mu = 0.3$ 无量纲。\n- 法向载荷 $N = 10$ N。\n- 带速 $v_b = 0$ m/s。\n- 外力振幅 $A = 50$ N。\n- 角频率 $\\omega = \\sqrt{k/m}$ rad/s。\n- 总模拟时间 $T = 5$ s。\n- 相对速度颤振阈值 $\\varepsilon_r = 10^{-3}$ m/s。\n\n构建并评估以下由$\\left(\\beta,\\gamma,\\Delta t\\right)$定义的测试套件：\n\n- 案例 1：$\\beta = 1/4$, $\\gamma = 1/2$, $\\Delta t = 5 \\times 10^{-3}$ s。\n- 案例 2：$\\beta = 0.30$, $\\gamma = 0.60$, $\\Delta t = 5 \\times 10^{-3}$ s。\n- 案例 3：$\\beta = 0.40$, $\\gamma = 0.80$, $\\Delta t = 5 \\times 10^{-3}$ s。\n- 案例 4：$\\beta = 0.28$, $\\gamma = 0.62$, $\\Delta t = 2 \\times 10^{-3}$ s。\n\n对于每个案例，使用$\\beta = 1/4$和$\\gamma = 1/2$以及相同的$\\Delta t$作为该案例的基准，计算颤振分数$C$和幅值比$R$。然后使用阈值$C_{\\max} = 2 \\times 10^{-2}$和$R_{\\min} = 7 \\times 10^{-1}$，输出一个布尔值，指示是否满足$\\left(C \\le C_{\\max}\\right)$和$\\left(R \\ge R_{\\min}\\right)$。\n\n您的程序应生成单行输出，其中包含测试套件的四个布尔值，形式为用方括号括起来的逗号分隔列表，例如$\\left[\\mathrm{True}, \\mathrm{False}, \\mathrm{True}, \\mathrm{True}\\right]$。不应打印任何额外文本。所有内部计算必须遵守所述单位。角度必须以弧度为单位。不得使用百分比；任何分数量必须保留为十进制数。",
            "solution": "用户提供了一个在计算固体力学领域中定义明确的问题，要求实现一个隐式Newmark-$\\beta$时间积分格式来研究粘滑摩擦动力学。\n\n### **问题验证**\n\n1.  **提取已知条件**：\n    *   **运动方程**：$m\\,a(t) + c\\,v(t) + k\\,x(t) = f_{\\mathrm{ext}}(t) + f_{\\mathrm{fr}}(t)$。\n    *   **外力**：$f_{\\mathrm{ext}}(t) = A \\sin(\\omega t)$。\n    *   **库仑摩擦**：对于粘滞（$v(t) = v_b$, $|\\lambda(t)| \\le \\mu N$），$f_{\\mathrm{fr}}(t)$为$\\lambda(t)$；对于滑动，为$-\\mu N\\,\\mathrm{sign}(v(t)-v_b)$。\n    *   **数值格式**：隐式Newmark-$\\beta$法，参数为$(\\beta, \\gamma)$和时间步长$\\Delta t$。\n    *   **参数**：$m = 1\\,\\mathrm{kg}$, $k = 1000\\,\\mathrm{N}/\\mathrm{m}$, $c = 1\\,\\mathrm{N}\\cdot\\mathrm{s}/\\mathrm{m}$, $\\mu = 0.3$, $N = 10\\,\\mathrm{N}$, $v_b = 0\\,\\mathrm{m}/\\mathrm{s}$, $A = 50\\,\\mathrm{N}$, $\\omega = \\sqrt{k/m}\\,\\mathrm{rad}/\\mathrm{s}$, $T = 5\\,\\mathrm{s}$, $\\varepsilon_r = 10^{-3}\\,\\mathrm{m}/\\mathrm{s}$。\n    *   **度量**：颤振分数$C$（低速状态切换的归一化计数）和幅值比$R$（测试幅值与基准幅值之比）。\n    *   **分类标准**：如果$C \\le C_{\\max} = 2 \\times 10^{-2}$且$R \\ge R_{\\min} = 7 \\times 10^{-1}$，则该区域为“优良”。\n    *   **测试用例**：\n        1.  $(\\beta = 1/4, \\gamma = 1/2, \\Delta t = 5 \\times 10^{-3}\\,\\mathrm{s})$\n        2.  $(\\beta = 0.30, \\gamma = 0.60, \\Delta t = 5 \\times 10^{-3}\\,\\mathrm{s})$\n        3.  $(\\beta = 0.40, \\gamma = 0.80, \\Delta t = 5 \\times 10^{-3}\\,\\mathrm{s})$\n        4.  $(\\beta = 0.28, \\gamma = 0.62, \\Delta t = 2 \\times 10^{-3}\\,\\mathrm{s})$\n    *   **基准**：对于每个测试用例，基准使用$\\beta = 1/4$, $\\gamma = 1/2$和相同的$\\Delta t$。\n    *   **初始条件**：未明确指定。分析稳态响应的标准做法是假设零初始条件：$x(0)=0$和$v(0)=0$。\n\n2.  **使用提取的已知条件进行验证**：\n    *   **有科学依据**：是。该问题基于牛顿定律、标准的材料/接触模型和一种经典的数值积分方法。\n    *   **良定的**：是。控制方程和数值程序都定义明确。未明确初始条件是一个小疏忽，可以通过一个标准的、不影响稳态度量的无偏假设（$x_0=0, v_0=0$）来解决。\n    *   **客观的**：是。所有定义、参数和标准都是定量的、客观的。\n\n3.  **结论与行动**：该问题**有效**。将提供完整解决方案。\n\n### **方法论与推导**\n\n**1. Newmark-$\\beta$运动学更新法则**\n隐式Newmark-$\\beta$格式基于加速度$a_n$和$a_{n+1}$的加权平均，将位移$x$和速度$v$从时间$t_n$更新到$t_{n+1} = t_n + \\Delta t$。更新法则由截断的泰勒级数展开推导而来：\n$$\nx_{n+1} = x_n + v_n \\Delta t + \\left( \\left(\\frac{1}{2}-\\beta\\right)a_n + \\beta a_{n+1} \\right) \\Delta t^2\n$$\n$$\nv_{n+1} = v_n + \\left( (1-\\gamma)a_n + \\gamma a_{n+1} \\right) \\Delta t\n$$\n其中$(\\beta, \\gamma)$是Newmark参数。对于线性系统，通常要求满足数值稳定性条件$2\\beta \\ge \\gamma \\ge 1/2$。当$\\gamma > 1/2$时，会引入算法阻尼，它能耗散虚假的高频振荡。\n\n**2. 离散化的隐式运动方程**\n系统在时间$t_{n+1}$的运动方程为：\n$$\nm\\,a_{n+1} + c\\,v_{n+1} + k\\,x_{n+1} = f_{\\mathrm{ext}, n+1} + f_{\\mathrm{fr}, n+1}\n$$\n为了求解这个关于未知加速度$a_{n+1}$的隐式方程，我们将$x_{n+1}$和$v_{n+1}$用$a_{n+1}$和$t_n$时刻的已知量表示。我们定义预测量$\\tilde{x}_{n+1}$和$\\tilde{v}_{n+1}$：\n$$\n\\tilde{x}_{n+1} = x_n + v_n \\Delta t + \\left(\\frac{1}{2}-\\beta\\right)a_n \\Delta t^2\n$$\n$$\n\\tilde{v}_{n+1} = v_n + (1-\\gamma)a_n \\Delta t\n$$\n则完整的更新式为：\n$$\nx_{n+1} = \\tilde{x}_{n+1} + \\beta \\Delta t^2 a_{n+1}\n$$\n$$\nv_{n+1} = \\tilde{v}_{n+1} + \\gamma \\Delta t a_{n+1}\n$$\n将这些代入运动方程并整理以求解$a_{n+1}$，可得：\n$$\n(m + c\\gamma\\Delta t + k\\beta\\Delta t^2) a_{n+1} = f_{\\mathrm{ext}, n+1} - c\\tilde{v}_{n+1} - k\\tilde{x}_{n+1} + f_{\\mathrm{fr}, n+1}\n$$\n我们定义有效质量$m^* = m + c\\gamma\\Delta t + k\\beta\\Delta t^2$。方程变为：\n$$\nm^* a_{n+1} = f_{\\mathrm{res}, n+1} + f_{\\mathrm{fr}, n+1}\n$$\n其中$f_{\\mathrm{res}, n+1} = f_{\\mathrm{ext}, n+1} - c\\tilde{v}_{n+1} - k\\tilde{x}_{n+1}$是除摩擦力贡献外的残余力。\n\n**3. 摩擦接触算法（返回映射）**\n摩擦力$f_{\\mathrm{fr}, n+1}$也是未知的。我们使用一种试探-检验（返回映射）过程。\n\n*   **试探粘滞**：假设系统在$t_{n+1}$时刻处于粘滞状态，这施加了运动学约束$v_{n+1} = v_b$。使用速度更新法则，我们可以找到所需的加速度$a_{n+1}^{\\text{stick}}$：\n    $$\n    v_b = \\tilde{v}_{n+1} + \\gamma \\Delta t a_{n+1}^{\\text{stick}} \\implies a_{n+1}^{\\text{stick}} = \\frac{v_b - \\tilde{v}_{n+1}}{\\gamma \\Delta t}\n    $$\n    维持此状态所需的相应摩擦力$\\lambda_{n+1}$可从离散化的运动方程中求得：\n    $$\n    \\lambda_{n+1} = m^* a_{n+1}^{\\text{stick}} - f_{\\mathrm{res}, n+1}\n    $$\n\n*   **检查容许性**：只有当所需的静摩擦力在库仑极限内时，即$|\\lambda_{n+1}| \\le \\mu N$，粘滞假设才有效。\n\n*   **决策与更新**：\n    *   如果$|\\lambda_{n+1}| \\le \\mu N$（粘滞）：假设正确。最终加速度为$a_{n+1} = a_{n+1}^{\\text{stick}}$。摩擦状态为“粘滞”。\n    *   如果$|\\lambda_{n+1}| > \\mu N$（滑动）：假设错误。系统发生滑动，摩擦力达到其动摩擦极限，$f_{\\mathrm{fr}, n+1} = -\\mu N \\cdot \\mathrm{sign}(\\lambda_{n+1})$。滑动方向由破坏粘滞条件的弹性预测力$\\lambda_{n+1}$的符号决定。然后用这个已知的摩擦力重新计算加速度：\n        $$\n        a_{n+1}^{\\text{slip}} = \\frac{f_{\\mathrm{res}, n+1} - \\mu N \\cdot \\mathrm{sign}(\\lambda_{n+1})}{m^*}\n        $$\n        最终加速度为$a_{n+1} = a_{n+1}^{\\text{slip}}$。摩擦状态为“滑动”。\n\n最后，一旦确定了正确的$a_{n+1}$，就使用Newmark运动学法则更新速度$v_{n+1}$和位移$x_{n+1}$。\n\n**4. 度量计算**\n\n*   **颤振分数 ($C$)**：一个状态变量在每个时间步跟踪摩擦状态（例如，0表示粘滞，1表示正向滑动，-1表示负向滑动）。我们遍历时间历史，计算从一个步到下一步该状态的任何变化（`state(n) != state(n-1)`）。如果发生这种切换，并且相对速度大小$|v_n-v_b|$低于阈值$\\varepsilon_r$，则计为一个颤振事件。总计数通过总模拟步数进行归一化。\n\n*   **幅值比 ($R$)**：对于每个测试用例，还使用恒定平均加速度法（$\\beta=1/4, \\gamma=1/2$）和相同的时间步长进行一次基准模拟。通过取模拟时间后半部分的峰谷位移的一半，计算测试和基准模拟的稳态位移幅值。比率$R$是测试幅值除以基准幅值。\n\n这两个度量的组合，使得当一个Newmark参数集成功抑制了数值颤振（$C \\le C_{\\max}$）而没有过度阻尼系统的物理响应（$R \\ge R_{\\min}$）时，可以将其分类为“优良”。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(m, k, c, mu, N, vb, A, omega, T, dt, beta, gamma):\n    \"\"\"\n    Simulates a single-degree-of-freedom system with Coulomb friction\n    using the implicit Newmark-beta method.\n    \"\"\"\n    num_steps = int(T / dt)\n    t_hist = np.linspace(0, T, num_steps + 1)\n    \n    x_hist = np.zeros(num_steps + 1)\n    v_hist = np.zeros(num_steps + 1)\n    a_hist = np.zeros(num_steps + 1)\n    # Friction state: 0=stick, 1=slip(v>vb), -1=slip(v<vb)\n    state_hist = np.zeros(num_steps + 1, dtype=int)\n\n    # Initial conditions\n    x_hist[0] = 0.0\n    v_hist[0] = 0.0\n    # Initial acceleration from t=0 equation of motion assuming stick\n    # m*a0 + c*v0 + k*x0 = f_ext(0) + f_fr(0) -> a0 = 0\n    a_hist[0] = 0.0\n\n    m_eff = m + c * gamma * dt + k * beta * dt**2\n    f_friction_max = mu * N\n\n    for i in range(num_steps):\n        # Current state\n        x_n, v_n, a_n = x_hist[i], v_hist[i], a_hist[i]\n        t_n1 = t_hist[i+1]\n\n        # Predictors\n        x_tilde_n1 = x_n + v_n * dt + (0.5 - beta) * a_n * dt**2\n        v_tilde_n1 = v_n + (1 - gamma) * a_n * dt\n        \n        # External and residual force (without friction)\n        f_ext_n1 = A * np.sin(omega * t_n1)\n        f_res_n1 = f_ext_n1 - (c * v_tilde_n1 + k * x_tilde_n1)\n        \n        # --- Stick-slip return mapping algorithm ---\n        # 1. Trial: Assume stick condition (v_{n+1} = v_b)\n        # From v_n1 = v_tilde_n1 + gamma*dt*a_n1\n        # v_b = v_tilde_n1 + gamma*dt*a_stick_n1\n        if gamma == 0 or dt == 0:\n            a_stick_n1 = 0\n        else:\n            a_stick_n1 = (vb - v_tilde_n1) / (gamma * dt)\n\n        # Calculate required friction force to maintain stick\n        # m_eff*a_n1 = f_res_n1 + f_fr_n1\n        lambda_trial = m_eff * a_stick_n1 - f_res_n1\n\n        # 2. Check: Is trial friction force admissible?\n        if abs(lambda_trial) <= f_friction_max:\n            # Stick condition holds\n            a_n1 = a_stick_n1\n            f_fr_n1 = lambda_trial\n            state_hist[i+1] = 0 # Stick\n        else:\n            # Slip condition\n            f_fr_n1 = -f_friction_max * np.sign(lambda_trial)\n            a_n1 = (f_res_n1 + f_fr_n1) / m_eff\n            state_hist[i+1] = -int(np.sign(lambda_trial)) # Slip\n        \n        # 3. Update kinematics\n        v_n1 = v_tilde_n1 + gamma * dt * a_n1\n        x_n1 = x_tilde_n1 + beta * dt**2 * a_n1\n        \n        x_hist[i+1], v_hist[i+1], a_hist[i+1] = x_n1, v_n1, a_n1\n        \n    return x_hist, v_hist, state_hist, t_hist\n\ndef solve():\n    \"\"\"\n    Main function to run test cases for stick-slip friction problem.\n    \"\"\"\n    m = 1.0\n    k = 1000.0\n    c = 1.0\n    mu = 0.3\n    N = 10.0\n    vb = 0.0\n    A = 50.0\n    omega = np.sqrt(k / m)\n    T = 5.0\n    eps_r = 1e-3\n    C_max = 2e-2\n    R_min = 0.7\n\n    test_suite = [\n        (0.25, 0.5, 5e-3),\n        (0.30, 0.60, 5e-3),\n        (0.40, 0.80, 5e-3),\n        (0.28, 0.62, 2e-3),\n    ]\n\n    final_results = []\n\n    for beta_test, gamma_test, dt_test in test_suite:\n        # Run the test case\n        x_test, v_test, state_test, t = run_simulation(m, k, c, mu, N, vb, A, omega, T, dt_test, beta_test, gamma_test)\n        \n        # Run the baseline case (average acceleration)\n        x_base, _, _, _ = run_simulation(m, k, c, mu, N, vb, A, omega, T, dt_test, 0.25, 0.5)\n\n        # --- Calculate metrics ---\n        # 1. Chatter Score (C)\n        chatter_count = 0\n        num_steps = len(t) - 1\n        for i in range(1, num_steps + 1):\n            if state_test[i] != state_test[i-1] and abs(v_test[i] - vb) < eps_r:\n                chatter_count += 1\n        C = chatter_count / num_steps\n\n        # 2. Amplitude Ratio (R)\n        # Use last half of simulation for steady-state amplitude\n        steady_start_index = num_steps // 2\n        \n        amp_test = (np.max(x_test[steady_start_index:]) - np.min(x_test[steady_start_index:])) / 2.0\n        amp_base = (np.max(x_base[steady_start_index:]) - np.min(x_base[steady_start_index:])) / 2.0\n        \n        R = amp_test / amp_base if amp_base != 0 else 0.0\n\n        # --- Check if the parameter set is \"Good\" ---\n        is_good = (C <= C_max) and (R >= R_min)\n        final_results.append(is_good)\n\n    print(str(final_results).replace(\"'\", \"\"))\n\nsolve()\n```"
        },
        {
            "introduction": "我们最后的实践练习将连接到更前沿的计算固体力学领域，在该领域中，材料会表现出如塑性和损伤等非线性行为。本练习将引入一个关键概念——“算法切线刚度”，它源于材料本构的更新过程。您将通过稳定性分析，探究Newmark格式的无条件稳定性如何依赖于此切线刚度的性质，从而深入理解在大型有限元仿真中，材料模型与时间积分方案之间的耦合关系 ()。",
            "id": "3573276",
            "problem": "您的任务是为具有内变量的小应变动力学问题，构建、分析并测试一个复合时间积分算法。其中，力学平衡方程由隐式Newmark-$\\beta$族积分，而内变量则通过算子分裂进行局部更新推进。您的任务包括：从第一性原理推导该格式；在适当的参数选择和切向耦合下，证明其无条件稳定性；以及实现一个测试函数，通过计算一小组代表性案例的放大矩阵的谱半径来评估其稳定性。\n\n从基本原理出发：对于一个小应变线性化系统，牛顿第二运动定律为：\n$$\n\\mathbf{M}\\,\\mathbf{a}(t) + \\mathbf{C}\\,\\mathbf{v}(t) + \\mathbf{K}(\\boldsymbol{\\alpha}(t))\\,\\mathbf{u}(t) = \\mathbf{f}(t),\n$$\n其中 $\\mathbf{u}$ 是位移，$\\mathbf{v} = \\dot{\\mathbf{u}}$ 是速度，$\\mathbf{a} = \\ddot{\\mathbf{u}}$ 是加速度，$\\mathbf{M}$ 是对称正定质量矩阵，$\\mathbf{C}$ 是对称半正定阻尼矩阵，$\\mathbf{K}(\\boldsymbol{\\alpha})$ 是与内变量 $\\boldsymbol{\\alpha}$ 相关的（可能依赖于状态的）对称切向刚度，$\\mathbf{f}$ 是外荷载。考虑一个从 $t_n$ 到 $t_{n+1} = t_n + \\Delta t$ 的时间步，时间步长 $\\Delta t > 0$ 为常数，使用带有参数 $\\beta$ 和 $\\gamma$ 的隐式Newmark-$\\beta$族，并假设算子分裂在 $t_{n+1}$ 时刻局部更新 $\\boldsymbol{\\alpha}$，从而提供在 $t_{n+1}$ 时刻计算的一致算法切向刚度 $\\mathbf{K}_{\\text{alg}} := \\partial \\mathbf{R}_{\\text{int}}/\\partial \\mathbf{u}$，其中 $\\mathbf{R}_{\\text{int}}$ 是内力向量。为进行稳定性分析，假设外荷载为零，即 $\\mathbf{f}(t) \\equiv \\mathbf{0}$。\n\n要求：\n- 推导复合积分器，该积分器结合了：由带有参数 $\\beta$ 和 $\\gamma$ 的隐式Newmark-$\\beta$法推进的力学平衡，以及用于计算在 $t_{n+1}$ 时刻全局力学求解中使用的一致算法切向刚度 $\\mathbf{K}_{\\text{alg}}$ 的内变量算子分裂更新。不要使用任何预先给出的Newmark更新公式；相反，应从Newmark-$\\beta$的运动学定义和牛顿第二定律出发，得到关于 $t_{n+1}$ 时刻未知量的线性系统。\n- 证明如果一致算法切向刚度 $\\mathbf{K}_{\\text{alg}}$ 是对称半正定的，并且阻尼矩阵 $\\mathbf{C}$ 也是对称半正定的，那么对于参数选择 $\\beta \\ge \\frac{1}{4}$ 和 $\\gamma \\ge \\frac{1}{2}$，该格式在能量有界性（对于齐次系统，即零荷载）的意义上，对时间步长 $\\Delta t$ 是无条件稳定的。您的证明必须从牛顿第二定律、Newmark-$\\beta$运动学定义以及能量或范数论证出发，并且必须阐明一致切向耦合的作用。\n- 实现一个函数，对于一个具有标量质量 $m$、阻尼 $c$ 和一致算法切向刚度 $k_{\\text{alg}}$ 的单自由度（Single Degree Of Freedom, SDOF）系统，构建一个线性放大矩阵，该矩阵在隐式Newmark-$\\beta$格式下（零荷载），将状态向量 $[\\;u_n,\\;v_n,\\;a_n\\;]^T$ 映射到 $[\\;u_{n+1},\\;v_{n+1},\\;a_{n+1}\\;]^T$。使用这个矩阵计算谱半径（特征值模的最大值），作为 $(m,c,k_{\\text{alg}},\\Delta t,\\beta,\\gamma)$ 的函数。矩阵的构建必须直接遵循您推导的Newmark关系和牛顿第二定律，不得依赖任何外部公式。\n\n本问题中的所有量都是无量纲的；不需要物理单位。\n\n测试套件：\n使用以下四个SDOF案例，每个案例在三个时间步长 $\\Delta t \\in \\{\\,10^{-3},\\,1,\\,10^{3}\\,\\}$ 下进行评估，参数为 $\\beta = \\frac{1}{4}$ 和 $\\gamma = \\frac{1}{2}$：\n\n- 弹性参考案例：$m = 1$， $c = 0$， $k_{\\text{alg}} = 1000$。\n- 处于屈服后一致切线状态的线性各向同性硬化弹塑性案例：取 $m = 1$，$c = 0$，弹性模量替代值 $k_{\\mathrm{e}} = 1000$，硬化模量替代值 $h = 500$，并使用著名的一维一致切线 $k_{\\text{alg}} = \\dfrac{k_{\\mathrm{e}}\\,h}{k_{\\mathrm{e}} + h}$。这将产生一个减小但为正的 $k_{\\text{alg}}$，适合用于稳定性测试。\n- 处于完全塑性状态的理想塑性案例：$m = 1$， $c = 0$， $k_{\\text{alg}} = 0$。\n- 带粘性阻尼的损伤折减刚度案例：$m = 1$，$c = 5$，初始刚度 $k_0 = 1000$，标量损伤 $d = 0.7$，因此 $k_{\\text{alg}} = (1 - d)\\,k_0$。\n\n对于每个案例，计算三个 $\\Delta t$ 值下的最大谱半径。您的程序的最终输出必须是一行，其中包含一个列表，内含四个浮点数，顺序与四个测试案例相对应。格式必须严格为逗号分隔的Python风格列表，例如\n$[\\,\\text{result}_1, \\text{result}_2, \\text{result}_3, \\text{result}_4\\,]$，\n不得有任何附加文本。结果无需四舍五入。\n\n本问题不涉及角度单位。若适用，百分比必须表示为小数。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，$[\\text{result}_1, \\text{result}_2, \\text{result}_3, \\text{result}_4]$）。",
            "solution": "本问题旨在阐述并分析一种用于非线性固体动力学的复合时间积分格式的稳定性，其中力学平衡由隐式Newmark-$\\beta$方法积分，内变量通过算子分裂进行更新。解决方案分为三个部分：首先，推导每个时间步需求解的离散线性系统；其次，在指定条件下证明其无条件稳定性；第三，为单自由度（SDOF）系统构建放大矩阵以进行谱稳定性分析。\n\n**1. 复合积分器的推导**\n\n分析始于系统在时间 $t_{n+1}$ 经历小应变时的半离散化运动方程：\n$$\n\\mathbf{M}\\,\\mathbf{a}_{n+1} + \\mathbf{C}\\,\\mathbf{v}_{n+1} + \\mathbf{R}_{\\text{int}}(\\mathbf{u}_{n+1}, \\boldsymbol{\\alpha}_{n+1}) = \\mathbf{f}_{n+1}\n$$\n其中 $\\mathbf{M}$ 是质量矩阵，$\\mathbf{C}$ 是阻尼矩阵，$\\mathbf{R}_{\\text{int}}$ 是内力向量，它是位移 $\\mathbf{u}_{n+1}$ 和内变量 $\\boldsymbol{\\alpha}_{n+1}$ 的函数。外力向量是 $\\mathbf{f}_{n+1}$。变量 $\\mathbf{a}_{n+1}$ 和 $\\mathbf{v}_{n+1}$ 分别是时间 $t_{n+1}$ 时的加速度和速度向量。算子分裂意味着对于给定的位移 $\\mathbf{u}_{n+1}$，内变量 $\\boldsymbol{\\alpha}_{n+1}$（以及因此的 $\\mathbf{R}_{\\text{int}}$）由一个局部的本构更新确定。\n\n隐式Newmark-$\\beta$方法提供了位移、速度和加速度之间的运动学关系。从时间 $t_n$ 的状态 $(\\mathbf{u}_n, \\mathbf{v}_n, \\mathbf{a}_n)$ 出发，时间 $t_{n+1} = t_n + \\Delta t$ 的状态由以下公式给出：\n$$\n\\mathbf{u}_{n+1} = \\mathbf{u}_n + \\Delta t \\, \\mathbf{v}_n + \\Delta t^2 \\left( \\left(\\frac{1}{2}-\\beta\\right)\\mathbf{a}_n + \\beta \\mathbf{a}_{n+1} \\right) \\quad (1)\n$$\n$$\n\\mathbf{v}_{n+1} = \\mathbf{v}_n + \\Delta t \\left( (1-\\gamma)\\mathbf{a}_n + \\gamma \\mathbf{a}_{n+1} \\right) \\quad (2)\n$$\n其中 $\\beta$ 和 $\\gamma$ 是Newmark参数。为了求解 $t_{n+1}$ 时的状态，我们必须将运动方程与这些运动学更新公式联立求解。这通常会导致一个关于未知位移 $\\mathbf{u}_{n+1}$ 的非线性代数系统，该系统使用诸如Newton-Raphson法之类的迭代过程求解。本问题要求在此背景下推导线性系统。\n\n我们首先将加速度 $\\mathbf{a}_{n+1}$ 和速度 $\\mathbf{v}_{n+1}$ 表示为未知位移 $\\mathbf{u}_{n+1}$ 和第 $n$ 步已知量的函数。从方程(1)可得：\n$$\n\\beta \\Delta t^2 \\mathbf{a}_{n+1} = \\mathbf{u}_{n+1} - \\left[ \\mathbf{u}_n + \\Delta t \\, \\mathbf{v}_n + \\Delta t^2 \\left(\\frac{1}{2}-\\beta\\right)\\mathbf{a}_n \\right]\n$$\n这给出了加速度的更新公式：\n$$\n\\mathbf{a}_{n+1} = \\frac{1}{\\beta \\Delta t^2} (\\mathbf{u}_{n+1} - \\mathbf{u}_n) - \\frac{1}{\\beta \\Delta t} \\mathbf{v}_n - \\left(\\frac{1}{2\\beta}-1\\right) \\mathbf{a}_n \\quad (3)\n$$\n将方程(3)代入方程(2)得到速度的更新公式：\n$$\n\\mathbf{v}_{n+1} = \\mathbf{v}_n + \\Delta t(1-\\gamma)\\mathbf{a}_n + \\gamma\\Delta t \\left[ \\frac{1}{\\beta \\Delta t^2} (\\mathbf{u}_{n+1} - \\mathbf{u}_n) - \\frac{1}{\\beta \\Delta t} \\mathbf{v}_n - \\left(\\frac{1}{2\\beta}-1\\right) \\mathbf{a}_n \\right]\n$$\n$$\n\\mathbf{v}_{n+1} = \\frac{\\gamma}{\\beta\\Delta t}(\\mathbf{u}_{n+1} - \\mathbf{u}_n) + (1-\\frac{\\gamma}{\\beta})\\mathbf{v}_n + \\Delta t\\left(1-\\gamma - \\frac{\\gamma}{2\\beta} + \\gamma\\right)\\mathbf{a}_n = \\frac{\\gamma}{\\beta\\Delta t}(\\mathbf{u}_{n+1} - \\mathbf{u}_n) + (1-\\frac{\\gamma}{\\beta})\\mathbf{v}_n + \\Delta t(1 - \\frac{\\gamma}{2\\beta})\\mathbf{a}_n \\quad (4)\n$$\n在Newton-Raphson格式中，我们求解当前位移猜测值 $\\mathbf{u}_{n+1}^{(i)}$ 的修正量 $\\Delta\\mathbf{u}$。线性化系统为 $\\mathbf{K}_{\\text{eff}} \\Delta\\mathbf{u} = -\\mathbf{R}^{(i)}$，其中 $\\mathbf{R}^{(i)}$ 是第 $i$ 次迭代的残差，$\\mathbf{K}_{\\text{eff}}$ 是有效切向刚度矩阵。残差为 $\\mathbf{R} = \\mathbf{M}\\mathbf{a}_{n+1} + \\mathbf{C}\\mathbf{v}_{n+1} + \\mathbf{R}_{\\text{int}}(\\mathbf{u}_{n+1}) - \\mathbf{f}_{n+1}$。\n有效刚度是残差相对于 $\\mathbf{u}_{n+1}$ 的雅可比矩阵：\n$$\n\\mathbf{K}_{\\text{eff}} = \\frac{\\partial \\mathbf{R}}{\\partial \\mathbf{u}_{n+1}} = \\mathbf{M}\\frac{\\partial \\mathbf{a}_{n+1}}{\\partial \\mathbf{u}_{n+1}} + \\mathbf{C}\\frac{\\partial \\mathbf{v}_{n+1}}{\\partial \\mathbf{u}_{n+1}} + \\frac{\\partial \\mathbf{R}_{\\text{int}}}{\\partial \\mathbf{u}_{n+1}}\n$$\n从方程(3)和(4)中，我们求得导数：\n$$\n\\frac{\\partial \\mathbf{a}_{n+1}}{\\partial \\mathbf{u}_{n+1}} = \\frac{1}{\\beta \\Delta t^2} \\mathbf{I} \\quad \\text{和} \\quad \\frac{\\partial \\mathbf{v}_{n+1}}{\\partial \\mathbf{u}_{n+1}} = \\frac{\\gamma}{\\beta \\Delta t} \\mathbf{I}\n$$\n项 $\\frac{\\partial \\mathbf{R}_{\\text{int}}}{\\partial \\mathbf{u}_{n+1}}$ 正是一致算法切向刚度 $\\mathbf{K}_{\\text{alg}}$ 的定义。因此，在每个时间步（或每个Newton迭代）为位移 $\\mathbf{u}_{n+1}$（或其增量）求解的线性系统由有效刚度矩阵控制：\n$$\n\\mathbf{K}_{\\text{eff}} = \\frac{1}{\\beta \\Delta t^2}\\mathbf{M} + \\frac{\\gamma}{\\beta \\Delta t}\\mathbf{C} + \\mathbf{K}_{\\text{alg}}\n$$\n完整的系统是 $\\mathbf{K}_{\\text{eff}} \\mathbf{u}_{n+1} = \\mathbf{f}_{\\text{eff}}$，其中 $\\mathbf{f}_{\\text{eff}}$ 包含外力 $\\mathbf{f}_{n+1}$ 和所有依赖于 $t_n$ 时刻状态的项。\n\n**2. 无条件稳定性证明**\n\n无条件稳定性意味着对于任何时间步长 $\\Delta t > 0$，离散系统的总能量在齐次系统（$\\mathbf{f}(t) \\equiv \\mathbf{0}$）下保持有界。该证明依赖于证明一个离散的类能量函数是不增的。证明的条件是 $\\gamma \\ge 1/2$，$\\beta \\ge 1/4$，并且阻尼矩阵 $\\mathbf{C}$ 和一致算法切向刚度 $\\mathbf{K}_{\\text{alg}}$ 是对称半正定的。后者意味着内力可以从一个凸势能函数 $\\Pi(\\mathbf{u})$ 导出，即 $\\mathbf{R}_{\\text{int}} = \\partial \\Pi/\\partial \\mathbf{u}$ 且 $\\mathbf{K}_{\\text{alg}} = \\partial^2\\Pi/\\partial\\mathbf{u}^2 \\ge \\mathbf{0}$。\n\n证明策略是建立单个时间步内的能量平衡。力系统所做的功必须平衡能量的变化。齐次系统在 $t_{n+1}$ 时的离散运动方程是：\n$$\n\\mathbf{M}\\mathbf{a}_{n+1} + \\mathbf{C}\\mathbf{v}_{n+1} + \\mathbf{R}_{\\text{int}, n+1} = \\mathbf{0}\n$$\n将此方程与速度增量 $\\mathbf{v}_{n+1} - \\mathbf{v}_n$ 做点积，并进行逐项分析（此过程涉及大量但标准的Newmark关系代数操作），可以得到一个形式如下的离散能量平衡方程：\n$$\n(E_{k,n+1}+\\Pi_{n+1}) - (E_{k,n}+\\Pi_{n}) = -\\mathcal{D}_{\\text{phys}} - \\mathcal{D}_{\\text{alg}}\n$$\n其中 $E_{k,n} = \\frac{1}{2}\\mathbf{v}_n^T \\mathbf{M} \\mathbf{v}_n$ 是动能，$\\Pi_n$ 是在 $t_n$ 时刻储存的势能。项 $\\mathcal{D}_{\\text{phys}}$ 代表由阻尼矩阵 $\\mathbf{C}$ 引起的物理能量耗散，而 $\\mathcal{D}_{\\text{alg}}$ 是由算法产生的数值耗散。为了使格式稳定，两个耗散项都必须非负。\n\n物理耗散项，在一个步长内近似，可以表示为 $\\mathcal{D}_{\\text{phys}} \\approx \\Delta t \\mathbf{v}_{n+1/2}^T \\mathbf{C} \\mathbf{v}_{n+1/2}$ 的形式，由于 $\\mathbf{C}$ 是半正定的，该项是非负的。\n\n关键部分是数值耗散，经过前述的代数操作后，可以表示为：\n$$\n\\mathcal{D}_{\\text{alg}} = (\\gamma - 1/2) \\Delta t (\\mathbf{a}_{n+1} - \\mathbf{a}_n)^T \\mathbf{M} (\\mathbf{a}_{n+1} - \\mathbf{a}_n) + \\text{其他项} \n$$\n一个更优雅的公式（由Simo和Tarnow提出）定义了一个修正的、算法上一致的能量泛函。该泛函的变化被证明是由在给定条件下明显非负的项所耗散的。一个关键的耗散项与 $(\\gamma - 1/2)$ 成正比。为使此项非负（因为 $\\mathbf{M}$ 是正定的），我们必须有 $\\gamma \\ge 1/2$。选择 $\\beta \\ge 1/4$（特别是 $\\beta \\ge \\gamma/2$）确保了高频模式的相互作用不会产生虚假能量，从而防止不稳定性。\n\n$\\mathbf{K}_{\\text{alg}}$ 是对称半正定的假设至关重要。它保证了内力场是保守的（或至少在势能意义上是非耗散的），允许使用势能 $\\Pi$ 并满足不等式 $(\\mathbf{u}_{n+1}-\\mathbf{u}_n)^T \\mathbf{R}_{\\text{int},n+1} \\ge \\Pi_{n+1}-\\Pi_n$，这是凸函数的一个性质。这确保了内力所做的功对应于非负的储存能（或有界的变化），防止了材料模型的算法表示产生人为的能量。\n\n总之，条件 $\\gamma \\ge 1/2$ 和 $\\beta \\ge 1/4$，结合对称半正定的 $\\mathbf{C}$ 和 $\\mathbf{K}_{\\text{alg}}$，保证了系统的总离散能量不增加，从而证明了无条件稳定性。\n\n**3. SDOF系统的谱分析**\n\n对于一个质量为 $m$、阻尼为 $c$、算法刚度为 $k_{\\text{alg}}$ 的单自由度（SDOF）系统，其状态可以用向量 $\\mathbf{z}_n = [\\,u_n, v_n, a_n\\,]^T$ 表示。积分器使状态前进，满足 $\\mathbf{z}_{n+1} = \\mathbf{A}\\,\\mathbf{z}_n$，其中 $\\mathbf{A}$ 是放大矩阵。稳定性要求该矩阵的谱半径 $\\rho(\\mathbf{A}) = \\max_i |\\lambda_i(\\mathbf{A})|$ 小于或等于1。\n\n控制方程为：\n$$\nm a_{n+1} + c v_{n+1} + k_{\\text{alg}} u_{n+1} = 0 \\quad (5)\n$$\n$$\nu_{n+1} = u_n + \\Delta t v_n + \\Delta t^2 ( (1/2-\\beta)a_n + \\beta a_{n+1} ) \\quad (6)\n$$\n$$\nv_{n+1} = v_n + \\Delta t ( (1-\\gamma)a_n + \\gamma a_{n+1} ) \\quad (7)\n$$\n为了构建 $\\mathbf{A}$，我们将 $u_{n+1}$、$v_{n+1}$ 和 $a_{n+1}$ 表示为 $u_n$、$v_n$ 和 $a_n$ 的线性组合。我们首先求解 $a_{n+1}$。将方程(6)和(7)代入(5)：\n$$\nm a_{n+1} + c(v_n + \\Delta t (1-\\gamma)a_n + \\gamma\\Delta t a_{n+1}) + k_{\\text{alg}}(u_n + \\Delta t v_n + \\Delta t^2((1/2-\\beta)a_n + \\beta a_{n+1})) = 0\n$$\n将与 $a_{n+1}$ 相关的项分组到左侧：\n$$\n(m + c\\gamma\\Delta t + k_{\\text{alg}}\\beta\\Delta t^2) a_{n+1} = -k_{\\text{alg}} u_n - (c + k_{\\text{alg}}\\Delta t)v_n - (c\\Delta t(1-\\gamma) + k_{\\text{alg}}\\Delta t^2(1/2-\\beta))a_n\n$$\n令 $D = m + c\\gamma\\Delta t + k_{\\text{alg}}\\beta\\Delta t^2$。由于 $m>0$ 且所有其他参数均为非负，所以 $D>0$。\n$$\na_{n+1} = \\frac{-k_{\\text{alg}}}{D} u_n - \\frac{c + k_{\\text{alg}}\\Delta t}{D} v_n - \\frac{c\\Delta t(1-\\gamma) + k_{\\text{alg}}\\Delta t^2(1/2-\\beta)}{D} a_n\n$$\n此表达式提供了放大矩阵 $\\mathbf{A}$ 的第三行。其他两个状态变量 $v_{n+1}$ 和 $u_{n+1}$ 现在可以通过将此 $a_{n+1}$ 的表达式分别代回方程(7)和(6)来求得。这样就得到了 $\\mathbf{A}$ 的其余行：\n$$\n\\mathbf{A} = \n\\begin{pmatrix}\n1 + \\beta\\Delta t^2 A_{31} & \\Delta t + \\beta\\Delta t^2 A_{32} & \\Delta t^2(1/2-\\beta) + \\beta\\Delta t^2 A_{33} \\\\\n\\gamma\\Delta t A_{31} & 1 + \\gamma\\Delta t A_{32} & \\Delta t(1-\\gamma) + \\gamma\\Delta t A_{33} \\\\\nA_{31} & A_{32} & A_{33}\n\\end{pmatrix}\n$$\n其中 $A_{3j}$ 是 $a_{n+1}$ 表达式中 $u_n, v_n, a_n$ 的系数。具体来说：\n$A_{31} = -k_{\\text{alg}}/D$\n$A_{32} = -(c + k_{\\text{alg}}\\Delta t)/D$\n$A_{33} = -(c\\Delta t(1-\\gamma) + k_{\\text{alg}}\\Delta t^2(1/2-\\beta))/D$\n\n通过为给定参数构建此矩阵并计算其特征值，我们可以确定谱半径，从而对指定测试案例的格式稳定性进行数值验证。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the maximum spectral radius for four SDOF test cases using the\n    implicit Newmark-beta method.\n    \"\"\"\n\n    def calculate_max_spectral_radius(m, c, k_alg, beta, gamma, time_steps):\n        \"\"\"\n        Calculates the maximum spectral radius of the amplification matrix over a\n        range of time steps.\n        \n        Args:\n            m (float): Mass.\n            c (float): Damping.\n            k_alg (float): Algorithmic tangent stiffness.\n            beta (float): Newmark parameter.\n            gamma (float): Newmark parameter.\n            time_steps (list of float): Time steps to evaluate.\n        \n        Returns:\n            float: The maximum spectral radius found.\n        \"\"\"\n        max_rho = 0.0\n\n        for dt in time_steps:\n            # Denominator of the expression for a_{n+1}\n            # This is always positive for m > 0, c, k_alg, beta, gamma >= 0, dt > 0.\n            D = m + c * gamma * dt + k_alg * beta * dt**2\n\n            # Initialize the 3x3 amplification matrix A that maps\n            # [u_n, v_n, a_n]^T to [u_{n+1}, v_{n+1}, a_{n+1}]^T.\n            # Use complex numbers to handle eigenvalues correctly.\n            A = np.zeros((3, 3), dtype=np.complex128)\n\n            # Coefficients for the third row of A (expression for a_{n+1})\n            # a_{n+1} = A[2,0]*u_n + A[2,1]*v_n + A[2,2]*a_n\n            A[2, 0] = -k_alg / D\n            A[2, 1] = -(c + k_alg * dt) / D\n            A[2, 2] = -(c * dt * (1 - gamma) + k_alg * dt**2 * (0.5 - beta)) / D\n\n            # Coefficients for the second row of A (expression for v_{n+1})\n            # v_{n+1} = v_n + dt*(1-gamma)*a_n + dt*gamma*a_{n+1}\n            A[1, 0] = gamma * dt * A[2, 0]\n            A[1, 1] = 1.0 + gamma * dt * A[2, 1]\n            A[1, 2] = dt * (1.0 - gamma) + gamma * dt * A[2, 2]\n\n            # Coefficients for the first row of A (expression for u_{n+1})\n            # u_{n+1} = u_n + dt*v_n + dt^2*(0.5-beta)*a_n + dt^2*beta*a_{n+1}\n            A[0, 0] = 1.0 + beta * dt**2 * A[2, 0]\n            A[0, 1] = dt + beta * dt**2 * A[2, 1]\n            A[0, 2] = dt**2 * (0.5 - beta) + beta * dt**2 * A[2, 2]\n\n            # Compute the spectral radius (maximum absolute eigenvalue)\n            eigenvalues = np.linalg.eigvals(A)\n            rho = np.max(np.abs(eigenvalues))\n            \n            # Update the maximum spectral radius found so far\n            if rho > max_rho:\n                max_rho = rho\n        \n        return max_rho\n\n    # Define common parameters for the test suite\n    beta_val = 0.25\n    gamma_val = 0.5\n    time_steps_eval = [1e-3, 1.0, 1e3]\n    \n    # Define the four SDOF test cases\n    # Case 1: Elastic reference\n    case1 = (1.0, 0.0, 1000.0)\n\n    # Case 2: Elastoplastic with linear hardening\n    k_e = 1000.0\n    h = 500.0\n    k_alg_2 = (k_e * h) / (k_e + h)\n    case2 = (1.0, 0.0, k_alg_2)\n\n    # Case 3: Perfect plasticity\n    case3 = (1.0, 0.0, 0.0)\n\n    # Case 4: Damage-reduced stiffness with damping\n    k0 = 1000.0\n    d = 0.7\n    k_alg_4 = (1.0 - d) * k0\n    case4 = (1.0, 5.0, k_alg_4)\n    \n    test_cases = [case1, case2, case3, case4]\n\n    results = []\n    for m_val, c_val, k_val in test_cases:\n        max_rho = calculate_max_spectral_radius(m_val, c_val, k_val, beta_val, gamma_val, time_steps_eval)\n        results.append(max_rho)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}