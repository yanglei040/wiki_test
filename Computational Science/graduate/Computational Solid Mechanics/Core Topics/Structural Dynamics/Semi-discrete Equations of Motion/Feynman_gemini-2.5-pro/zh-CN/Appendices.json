{
    "hands_on_practices": [
        {
            "introduction": "显式时间积分方法，例如中心差分法，因其简单且每步计算成本低而广受欢迎。然而，它们只是有条件稳定的，这意味着时间步长 $\\Delta t$ 必须小于一个由系统最高固有频率决定的临界值。本练习  将指导您推导这个临界时间步长，并实现一个自适应时间步长算法。对于系统刚度随时间变化的问题（例如，在材料非线性或接触问题中），这是一项高效可靠求解的关键技能。",
            "id": "3599566",
            "problem": "考虑通过有限元空间离散化得到的线性弹性系统的半离散运动方程，其形式为 $ \\mathbf{M} \\ddot{\\mathbf{u}}(t) + \\mathbf{K}(t)\\, \\mathbf{u}(t) = \\mathbf{f}(t) $，其中 $ \\mathbf{M} \\in \\mathbb{R}^{n \\times n} $ 是对称正定质量矩阵，$ \\mathbf{K}(t) \\in \\mathbb{R}^{n \\times n} $ 是可能随时间变化的对称正定刚度矩阵，$ \\mathbf{f}(t) $ 是外力向量。假设自由振动进行稳定性分析，即 $ \\mathbf{f}(t) = \\mathbf{0} $。显式中心差分时间积分格式通过离散化 $ \\ddot{\\mathbf{u}}(t) $ 并代入半离散运动方程所得到的递推关系，在离散时间层级上以均匀时间步长 $ \\Delta t $ 来推进 $ \\mathbf{u}(t) $。\n\n严格从牛顿第二定律和有限元半离散化出发，从第一性原理推导应用于 $ \\mathbf{M} \\ddot{\\mathbf{u}}(t) + \\mathbf{K}(t)\\, \\mathbf{u}(t) = \\mathbf{0} $ 的显式中心差分法的谱稳定性条件。证明稳定性要求 $ \\Delta t \\leq \\Delta t_{\\mathrm{crit}} $，其中 $ \\Delta t_{\\mathrm{crit}} = \\dfrac{2}{\\omega_{\\max}} $，且 $ \\omega_{\\max} = \\sqrt{\\lambda_{\\max}} $，$ \\lambda_{\\max} $ 是对称广义特征值问题 $ \\mathbf{K}\\, \\boldsymbol{\\phi} = \\lambda\\, \\mathbf{M}\\, \\boldsymbol{\\phi} $ 的最大广义特征值。等价地，论证 $ \\lambda_{\\max} $ 等于相似变换矩阵 $ \\mathbf{M}^{-1/2}\\mathbf{K}\\mathbf{M}^{-1/2} $ 的谱半径，该矩阵与 $ \\mathbf{M}^{-1}\\mathbf{K} $ 具有相同的特征值。\n\n接下来，针对 $ \\mathbf{K}(t) $ 随时间变化的情景，设计一个安全的自适应时间步长规则，以确保显式中心差分格式保持稳定。该规则必须满足以下约束：\n\n- 必须使用一个安全系数 $ s \\in (0,1) $，应用于瞬时稳定性极限，即 $ \\Delta t_{\\mathrm{raw}}(t) = s \\dfrac{2}{\\sqrt{\\lambda_{\\max}(t)}} $。\n- 必须限制时间步长的变化率。设 $ r_{\\mathrm{up}} > 1 $ 为每步允许的最大乘法增加率，$ r_{\\mathrm{down}} > 1 $ 为每步允许的最大乘法减少率。在时间 $ t_n $ 和 $ t_{n+1} $，从 $ \\Delta t_n $ 到 $ \\Delta t_{n+1} $ 的更新必须满足\n  $$ \\Delta t_{n+1} \\leq \\min\\!\\big( \\Delta t_{\\mathrm{raw}}(t_{n+1}),\\, r_{\\mathrm{up}}\\, \\Delta t_n \\big), $$\n  并且当 $ \\Delta t_{\\mathrm{raw}}(t_{n+1}) $ 允许时，避免以快于以下界限减小\n  $$ \\Delta t_{n+1} \\geq \\frac{\\Delta t_n}{r_{\\mathrm{down}}}. $$\n  如果稳定性要求强制更剧烈的下降，那么为确保稳定，$ \\Delta t_{n+1} $ 必须设置为 $ \\Delta t_{\\mathrm{raw}}(t_{n+1}) $。\n- 它必须对所有时间层级 $ n $ 强制 $ \\Delta t_{\\min} \\leq \\Delta t_n \\leq \\Delta t_{\\max} $，其中 $ \\Delta t_{\\min} $ 和 $ \\Delta t_{\\max} $ 是预设的界限。\n\n为以下测试套件实现此算法。对每种情况，计算所需的量并返回指定的输出。所有时间步长值必须以秒为单位表示。所有浮点输出必须四舍五入到八位小数。\n\n- 情况1（恒定刚度，$ \\Delta t_{\\mathrm{crit}} $ 的验证和自适应下的恒定性）：\n  - $ n = 2 $，$ \\mathbf{M} = \\mathrm{diag}(2.0,\\, 1.0)\\, \\mathrm{kg} $，\n  - 连接到墙壁和质量块之间的弹簧通过 $ k_1 = 1200\\, \\mathrm{N/m} $，$ k_2 = 700\\, \\mathrm{N/m} $，$ k_3 = 900\\, \\mathrm{N/m} $ 定义 $ \\mathbf{K} $，其中\n    $$ \\mathbf{K} = \\begin{bmatrix} k_1 + k_2  -k_2 \\\\ -k_2  k_2 + k_3 \\end{bmatrix}. $$\n  - 使用 $ s = 0.95 $，$ r_{\\mathrm{up}} = 1.2 $，$ r_{\\mathrm{down}} = 1.5 $，$ \\Delta t_{\\min} = 10^{-6}\\, \\mathrm{s} $，$ \\Delta t_{\\max} = 10^{-2}\\, \\mathrm{s} $。在 $ [0,\\, 1]\\, \\mathrm{s} $ 内采样 $ 21 $ 个均匀间隔的时间点（尽管 $ \\mathbf{K} $ 是恒定的）。\n  - 输出一个列表 $ [\\Delta t_{\\mathrm{crit}},\\, \\Delta t_{\\mathrm{start}},\\, \\Delta t_{\\mathrm{end}}] $，单位为秒，其中 $ \\Delta t_{\\mathrm{crit}} = \\dfrac{2}{\\sqrt{\\lambda_{\\max}}} $，$ \\Delta t_{\\mathrm{start}} $ 是第一个自适应时间步长，$ \\Delta t_{\\mathrm{end}} $ 是最后一个自适应时间步长。\n\n- 情况2（逐渐变刚的系统，平滑变化下的自适应覆盖）：\n  - $ n = 3 $，$ \\mathbf{M} = \\mathrm{diag}(1.0,\\, 1.5,\\, 2.0)\\, \\mathrm{kg} $，\n  - 基础刚度来自一个三质量链，其弹簧连接到墙壁和相邻质量块之间：\n    $$ k_{\\mathrm{w}1} = 1000\\, \\mathrm{N/m},\\quad k_{12} = 1500\\, \\mathrm{N/m},\\quad k_{23} = 1200\\, \\mathrm{N/m},\\quad k_{\\mathrm{w}3} = 800\\, \\mathrm{N/m}, $$\n    $$ \\mathbf{K}_0 = \\begin{bmatrix} k_{\\mathrm{w}1} + k_{12}  -k_{12}  0 \\\\ -k_{12}  k_{12} + k_{23}  -k_{23} \\\\ 0  -k_{23}  k_{23} + k_{\\mathrm{w}3} \\end{bmatrix}. $$\n  - 附加刚度矩阵 $ \\mathbf{K}_1 = \\mathrm{diag}(500,\\, 400,\\, 300)\\, \\mathrm{N/m} $ 且 $ \\mathbf{K}(t) = \\mathbf{K}_0 + 0.5\\, t\\, \\mathbf{K}_1 $，对于 $ t \\in [0,\\, 1]\\, \\mathrm{s} $。\n  - 使用 $ s = 0.85 $，$ r_{\\mathrm{up}} = 1.15 $，$ r_{\\mathrm{down}} = 2.0 $，$ \\Delta t_{\\min} = 10^{-5}\\, \\mathrm{s} $，$ \\Delta t_{\\max} = 5 \\times 10^{-3}\\, \\mathrm{s} $。在 $ [0,\\, 1]\\, \\mathrm{s} $ 内采样 $ 51 $ 个均匀间隔的时间点。\n  - 输出一个列表 $ [\\Delta t_{\\min\\mathrm{series}},\\, \\Delta t_{\\max\\mathrm{series}},\\, \\mathrm{stable}] $，其中 $ \\Delta t_{\\min\\mathrm{series}} $ 和 $ \\Delta t_{\\max\\mathrm{series}} $ 是整个序列中的最小和最大自适应时间步长（秒），$ \\mathrm{stable} $ 是一个布尔值，当且仅当对于所有采样时间 $ \\Delta t_n \\le s \\dfrac{2}{\\sqrt{\\lambda_{\\max}(t_n)}} $ 时为 $ \\mathrm{True} $。\n\n- 情况3（刚度突变，测试速率限制的边界情况）：\n  - $ n = 3 $，$ \\mathbf{M} = \\mathrm{diag}(1.0,\\, 2.0,\\, 1.5)\\, \\mathrm{kg} $，\n  - 基础刚度 $ \\mathbf{K}_{\\mathrm{b}} $ 来自一个带弹簧的三质量链：\n    $$ k_{\\mathrm{w}1} = 900\\, \\mathrm{N/m},\\quad k_{12} = 1100\\, \\mathrm{N/m},\\quad k_{23} = 1000\\, \\mathrm{N/m},\\quad k_{\\mathrm{w}3} = 700\\, \\mathrm{N/m}, $$\n    $$ \\mathbf{K}_{\\mathrm{b}} = \\begin{bmatrix} k_{\\mathrm{w}1} + k_{12}  -k_{12}  0 \\\\ -k_{12}  k_{12} + k_{23}  -k_{23} \\\\ 0  -k_{23}  k_{23} + k_{\\mathrm{w}3} \\end{bmatrix}. $$\n  - 定义一个分段刚度 $ \\mathbf{K}(t) = \\mathbf{K}_{\\mathrm{b}} $ 对于 $ t  0.6\\, \\mathrm{s} $ 和 $ \\mathbf{K}(t) = 3\\, \\mathbf{K}_{\\mathrm{b}} $ 对于 $ t \\ge 0.6\\, \\mathrm{s} $。\n  - 使用 $ s = 0.90 $，$ r_{\\mathrm{up}} = 1.10 $，$ r_{\\mathrm{down}} = 1.30 $，$ \\Delta t_{\\min} = 10^{-5}\\, \\mathrm{s} $，$ \\Delta t_{\\max} = 5 \\times 10^{-3}\\, \\mathrm{s} $。在 $ [0,\\, 1]\\, \\mathrm{s} $ 内采样 $ 101 $ 个均匀间隔的时间点。\n  - 输出一个列表 $ [R_{\\mathrm{inc}},\\, R_{\\mathrm{dec}},\\, \\mathrm{stable}] $，其中 $ R_{\\mathrm{inc}} = \\max\\limits_{n} \\dfrac{\\Delta t_{n+1}}{\\Delta t_n} $ 和 $ R_{\\mathrm{dec}} = \\min\\limits_{n} \\dfrac{\\Delta t_{n+1}}{\\Delta t_n} $ 是整个序列上的值，而 $ \\mathrm{stable} $ 是如上定义的布尔值。\n\n你的程序应产生单行输出，包含所有三种情况的结果，格式为一个用方括号括起来的逗号分隔列表（例如，$ [\\mathrm{case1}, \\mathrm{case2}, \\mathrm{case3}] $），其中每个 $ \\mathrm{case} $ 本身是遵循上述规范的一个列表。所有浮点值必须以秒为单位，并四舍五入到八位小数，布尔值必须使用标准的Python大写形式 $ \\mathrm{True} $ 或 $ \\mathrm{False} $ 打印。",
            "solution": "该问题被评估为有效。它在科学上基于计算固体力学的原理，是适定的，并包含推导稳定性条件和实现指定的自适应时间步长算法所需的所有必要信息。\n\n### 第一部分：谱稳定性条件的推导\n\n分析始于经历自由振动的线性弹性系统的半离散运动方程：\n$$ \\mathbf{M} \\ddot{\\mathbf{u}}(t) + \\mathbf{K}(t)\\, \\mathbf{u}(t) = \\mathbf{0} $$\n此处，$ \\mathbf{M} $ 是对称正定质量矩阵，$ \\mathbf{K}(t) $ 是对称正定刚度矩阵。\n\n显式中心差分法使用一个二阶精度的有限差分公式来近似离散时间 $ t_n $ 处的加速度：\n$$ \\ddot{\\mathbf{u}}_n \\approx \\frac{\\mathbf{u}_{n+1} - 2\\mathbf{u}_n + \\mathbf{u}_{n-1}}{(\\Delta t)^2} $$\n其中 $ \\mathbf{u}_n = \\mathbf{u}(t_n) $ 且 $ \\Delta t $ 是时间步长。\n\n将此近似代入时间 $ t_n $ 的运动方程，并假设刚度矩阵是局部恒定的 $ \\mathbf{K}_n = \\mathbf{K}(t_n) $，我们得到：\n$$ \\mathbf{M} \\left( \\frac{\\mathbf{u}_{n+1} - 2\\mathbf{u}_n + \\mathbf{u}_{n-1}}{(\\Delta t)^2} \\right) + \\mathbf{K}_n \\mathbf{u}_n = \\mathbf{0} $$\n重新整理以求解下一个时间步的位移 $ \\mathbf{u}_{n+1} $，得到中心差分格式的递推关系：\n$$ \\mathbf{M} \\mathbf{u}_{n+1} = 2\\mathbf{M}\\mathbf{u}_n - \\mathbf{M}\\mathbf{u}_{n-1} - (\\Delta t)^2 \\mathbf{K}_n \\mathbf{u}_n $$\n由于 $ \\mathbf{M} $ 是可逆的，我们可以写成：\n$$ \\mathbf{u}_{n+1} = \\left( 2\\mathbf{I} - (\\Delta t)^2 \\mathbf{M}^{-1} \\mathbf{K}_n \\right) \\mathbf{u}_n - \\mathbf{u}_{n-1} $$\n\n对于 von Neumann 稳定性分析，我们分析系统各个模式的行为。我们将解投影到广义特征向量 $ \\boldsymbol{\\phi}_i $ 的基上，这些向量是广义特征值问题 $ \\mathbf{K} \\boldsymbol{\\phi}_i = \\lambda_i \\mathbf{M} \\boldsymbol{\\phi}_i $ 的解。特征值 $ \\lambda_i = \\omega_i^2 $ 是系统固有频率的平方。位移向量可以表示为这些模式的叠加：$ \\mathbf{u}(t) = \\sum_i q_i(t) \\boldsymbol{\\phi}_i $，其中 $q_i(t)$ 是模态坐标。这将系统解耦为一组单自由度（SDOF）振子：\n$$ \\ddot{q}_i(t) + \\omega_i^2 q_i(t) = 0 $$\n多自由度积分格式的稳定性由应用于最高频率 $ \\omega_{\\max} $ 模式的单自由度积分器的稳定性决定。\n\n将中心差分格式应用于频率为 $ \\omega $ 的模式的单自由度方程：\n$$ \\frac{q_{n+1} - 2q_n + q_{n-1}}{(\\Delta t)^2} + \\omega^2 q_n = 0 $$\n$$ q_{n+1} = (2 - (\\omega \\Delta t)^2) q_n - q_{n-1} $$\n为了分析此递推的稳定性，我们将其表述为一个一阶系统。设状态向量为 $ \\mathbf{z}_n = \\{ q_n, q_{n-1} \\}^T $。则更新为 $ \\mathbf{z}_{n+1} = \\mathbf{A} \\mathbf{z}_n $，其中 $ \\mathbf{A} $ 是放大矩阵：\n$$ \\mathbf{A} = \\begin{bmatrix} 2 - (\\omega \\Delta t)^2  -1 \\\\ 1  0 \\end{bmatrix} $$\n如果放大矩阵的谱半径 $ \\rho(\\mathbf{A}) $ 小于或等于 $ 1 $，则该格式是稳定的。$ \\mathbf{A} $ 的特征值 $ \\gamma $ 由特征方程 $ \\det(\\mathbf{A} - \\gamma \\mathbf{I}) = 0 $ 给出：\n$$ \\gamma^2 - (2 - (\\omega \\Delta t)^2)\\gamma + 1 = 0 $$\n根为：\n$$ \\gamma_{1,2} = \\frac{2 - (\\omega \\Delta t)^2 \\pm \\sqrt{(2 - (\\omega \\Delta t)^2)^2 - 4}}{2} $$\n对于稳定的、非耗散的响应，特征值 $ \\gamma $ 必须是单位圆上的复共轭对，这要求判别式为非正：\n$$ (2 - (\\omega \\Delta t)^2)^2 - 4 \\leq 0 $$\n$$ (2 - (\\omega \\Delta t)^2)^2 \\leq 4 $$\n$$ -2 \\leq 2 - (\\omega \\Delta t)^2 \\leq 2 $$\n这可以简化为 $ (\\omega \\Delta t)^2 \\leq 4 $，或 $ \\omega \\Delta t \\leq 2 $。在极限 $ \\omega \\Delta t = 2 $ 下，特征值合并于 $ \\gamma = -1 $。这会导致弱不稳定性（共振），因为在这种情况下放大矩阵不可对角化。超过此极限，一个特征值的模大于1，导致数值误差的指数增长。\n\n因此，为保证稳定性，条件 $ \\omega \\Delta t \\leq 2 $ 必须对系统中的所有频率都成立。最严格的约束由最高频率 $ \\omega_{\\max} $ 施加：\n$$ \\omega_{\\max} \\Delta t \\leq 2 \\implies \\Delta t \\leq \\frac{2}{\\omega_{\\max}} $$\n这定义了稳定性的临界时间步长 $ \\Delta t_{\\mathrm{crit}} = \\frac{2}{\\omega_{\\max}} $。\n最高频率通过 $ \\omega_{\\max} = \\sqrt{\\lambda_{\\max}} $ 与最大广义特征值 $ \\lambda_{\\max} $ of $ \\mathbf{K} \\boldsymbol{\\phi} = \\lambda \\mathbf{M} \\boldsymbol{\\phi} $ 相关。因此，稳定性条件是：\n$$ \\Delta t \\leq \\frac{2}{\\sqrt{\\lambda_{\\max}}} $$\n\n为了论证广义特征值问题和标准特征值问题之间的关系，我们可以对广义问题进行变换。由于 $ \\mathbf{M} $ 是对称正定的，其 Cholesky 因子或谱分解存在，使我们能够定义一个可逆矩阵 $ \\mathbf{M}^{-1/2} $。用 $ \\mathbf{M}^{-1/2} $ 左乘广义特征值问题，得到：\n$$ \\mathbf{M}^{-1/2} \\mathbf{K} \\boldsymbol{\\phi} = \\lambda \\mathbf{M}^{1/2} \\boldsymbol{\\phi} $$\n通过插入 $ \\mathbf{I} = \\mathbf{M}^{-1/2} \\mathbf{M}^{1/2} $ 并定义一个新向量 $ \\boldsymbol{\\psi} = \\mathbf{M}^{1/2} \\boldsymbol{\\phi} $，我们得到：\n$$ (\\mathbf{M}^{-1/2} \\mathbf{K} \\mathbf{M}^{-1/2}) \\boldsymbol{\\psi} = \\lambda \\boldsymbol{\\psi} $$\n这是一个关于矩阵 $ \\tilde{\\mathbf{K}} = \\mathbf{M}^{-1/2} \\mathbf{K} \\mathbf{M}^{-1/2} $ 的标准特征值问题。由于 $ \\mathbf{M} $ 和 $ \\mathbf{K} $ 是对称的， $ \\tilde{\\mathbf{K}} $ 也是对称的。其特征值 $ \\lambda $ 与对 $ (\\mathbf{K}, \\mathbf{M}) $ 的广义特征值相同。\n此外，矩阵 $ \\mathbf{M}^{-1}\\mathbf{K} $ 与 $ \\tilde{\\mathbf{K}} $ 相似（因为 $ \\mathbf{B}\\mathbf{A} $ 与 $ \\mathbf{A}\\mathbf{B} $ 相似），所以它们具有相同的特征值。因此，$ \\lambda_{\\max} $ 等价于对称矩阵 $ \\mathbf{M}^{-1/2}\\mathbf{K}\\mathbf{M}^{-1/2} $ 或非对称矩阵 $ \\mathbf{M}^{-1}\\mathbf{K} $ 的最大特征值（谱半径）。对称形式在数值计算中更受青睐。\n\n### 第二部分：自适应时间步长算法的实现\n\n自适应时间步长规则根据问题陈述中指定的逻辑实现。对于每种情况，我们计算一系列时间步长。\n设 $ \\Delta t_n $ 是第 $ n $ 步的时间步长，设 $ t_{n+1} $ 是为下一步 $ n+1 $ 评估刚度矩阵的时间。\n\n1.  计算瞬时最大角频率 $ \\omega_{\\max}(t_{n+1}) = \\sqrt{\\lambda_{\\max}(\\mathbf{K}(t_{n+1}), \\mathbf{M})} $。\n2.  计算原始的稳定性限制时间步长：$ \\Delta t_{\\mathrm{raw}}(t_{n+1}) = s \\frac{2}{\\omega_{\\max}(t_{n+1})} $。\n3.  从 $ \\Delta t_n $ 更新到 $ \\Delta t_{n+1} $ 的逻辑如下：\n    a. 根据最大减小率定义下限：$ \\Delta t_{\\mathrm{dec\\_lim}} = \\Delta t_n / r_{\\mathrm{down}} $。\n    b. 如果 $ \\Delta t_{\\mathrm{raw}}(t_{n+1})  \\Delta t_{\\mathrm{dec\\_lim}} $，为保证稳定性需要急剧减小。规则指定将新的时间步长设置为原始极限：$ \\Delta t_{\\mathrm{cand}} = \\Delta t_{\\mathrm{raw}}(t_{n+1}) $。\n    c. 否则，新步长受最大增加率和原始稳定性极限的限制：$ \\Delta t_{\\mathrm{inc\\_lim}} = r_{\\mathrm{up}} \\Delta t_n $，且 $ \\Delta t_{\\mathrm{cand}} = \\min(\\Delta t_{\\mathrm{raw}}(t_{n+1}), \\Delta t_{\\mathrm{inc\\_lim}}) $。\n4.  最后，这个候选步长被全局最小和最大界限所钳制：$ \\Delta t_{n+1} = \\min(\\Delta t_{\\max}, \\max(\\Delta t_{\\min}, \\Delta t_{\\mathrm{cand}})) $。\n5.  序列的第一个时间步长根据 $ t_0 $ 时的原始稳定性极限进行初始化，并由 $ \\Delta t_{\\min} $ 和 $ \\Delta t_{\\max} $ 钳制。\n6.  `stable` 布尔标志是通过检查对于所有步长 n 是否满足 $ \\Delta t_n \\le \\Delta t_{\\mathrm{raw}}(t_n) / s $ 来确定的。注意规则是 $ \\Delta t \\le 2/\\omega_{\\max} $，所以我们对照 $\\Delta t_{\\mathrm{raw}}/s$ 进行检查。然而，问题陈述的检查是 $ \\Delta t_n \\le s \\dfrac{2}{\\sqrt{\\lambda_{\\max}(t_n)}} $，即 $ \\Delta t_n \\le \\Delta t_{\\mathrm{raw}}(t_n) $。这是所实现的检查。\n\n以下代码实现了此逻辑，并计算了三个测试用例所需的输出。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef adaptive_time_stepping(times, M, K_func, s, r_up, r_down, dt_min, dt_max):\n    \"\"\"\n    Implements the adaptive time stepping algorithm.\n    \n    Returns:\n        dt_series: List of adaptive time steps.\n        dt_raw_series: List of raw stability-limited time steps.\n        is_stable: Boolean indicating if all steps were stable.\n    \"\"\"\n    num_samples = len(times)\n    dt_series = []\n    dt_raw_series = []\n    \n    # Initial step\n    t0 = times[0]\n    K0 = K_func(t0)\n    try:\n        eigvals = eigh(K0, M, eigvals_only=True)\n        lambda_max_0 = eigvals[-1]\n        w_max_0 = np.sqrt(lambda_max_0)\n        dt_raw_0 = s * 2.0 / w_max_0\n    except np.linalg.LinAlgError:\n        # Handle singular matrix cases if they were to occur, not expected here\n        dt_raw_0 = dt_min\n        \n    dt_raw_series.append(dt_raw_0)\n    \n    dt_current = min(dt_max, max(dt_min, dt_raw_0))\n    dt_series.append(dt_current)\n    \n    is_stable = (dt_current = dt_raw_0)\n\n    # Subsequent steps\n    for i in range(1, num_samples):\n        dt_prev = dt_series[-1]\n        t_i = times[i]\n        K_i = K_func(t_i)\n        \n        try:\n            eigvals = eigh(K_i, M, eigvals_only=True)\n            lambda_max_i = eigvals[-1]\n            if lambda_max_i = 0: # Physically unexpected but for robustness\n                 w_max_i = np.inf\n                 dt_raw_i = dt_min\n            else:\n                 w_max_i = np.sqrt(lambda_max_i)\n                 dt_raw_i = s * 2.0 / w_max_i\n        except np.linalg.LinAlgError:\n            dt_raw_i = dt_min\n            \n        dt_raw_series.append(dt_raw_i)\n        \n        # Adaptive rule\n        dt_decrease_limit = dt_prev / r_down\n        \n        if dt_raw_i  dt_decrease_limit:\n            dt_cand = dt_raw_i\n        else:\n            dt_increase_limit = dt_prev * r_up\n            dt_cand = min(dt_raw_i, dt_increase_limit)\n            \n        # Global bounds\n        dt_next = min(dt_max, max(dt_min, dt_cand))\n        dt_series.append(dt_next)\n        \n        if not (dt_next = dt_raw_i):\n            is_stable = False\n            \n    return dt_series, dt_raw_series, is_stable\n\ndef solve():\n    \"\"\"\n    Solves the three test cases and prints the results.\n    \"\"\"\n    all_results = []\n    ROUND_DIGITS = 8\n\n    # --- Case 1 ---\n    M1 = np.diag([2.0, 1.0])\n    k1, k2, k3 = 1200.0, 700.0, 900.0\n    K1_const = np.array([[k1 + k2, -k2], [-k2, k2 + k3]])\n    \n    def K_func1(t):\n        return K1_const\n        \n    params1 = {\n        's': 0.95, 'r_up': 1.2, 'r_down': 1.5,\n        'dt_min': 1e-6, 'dt_max': 1e-2\n    }\n    times1 = np.linspace(0, 1, 21)\n    \n    lambda_max_1 = eigh(K1_const, M1, eigvals_only=True)[-1]\n    dt_crit_1 = 2.0 / np.sqrt(lambda_max_1)\n    \n    dt_series1, _, _ = adaptive_time_stepping(times1, M1, K_func1, **params1)\n    dt_start_1 = dt_series1[0]\n    dt_end_1 = dt_series1[-1]\n    \n    all_results.append([\n        round(dt_crit_1, ROUND_DIGITS),\n        round(dt_start_1, ROUND_DIGITS),\n        round(dt_end_1, ROUND_DIGITS)\n    ])\n\n    # --- Case 2 ---\n    M2 = np.diag([1.0, 1.5, 2.0])\n    k_w1, k_12, k_23, k_w3 = 1000.0, 1500.0, 1200.0, 800.0\n    K0_2 = np.array([\n        [k_w1 + k_12, -k_12, 0],\n        [-k_12, k_12 + k_23, -k_23],\n        [0, -k_23, k_23 + k_w3]\n    ])\n    K1_2 = np.diag([500.0, 400.0, 300.0])\n    \n    def K_func2(t):\n        return K0_2 + 0.5 * t * K1_2\n\n    params2 = {\n        's': 0.85, 'r_up': 1.15, 'r_down': 2.0,\n        'dt_min': 1e-5, 'dt_max': 5e-3\n    }\n    times2 = np.linspace(0, 1, 51)\n    \n    dt_series2, _, is_stable2 = adaptive_time_stepping(times2, M2, K_func2, **params2)\n    dt_min_series2 = min(dt_series2)\n    dt_max_series2 = max(dt_series2)\n    \n    all_results.append([\n        round(dt_min_series2, ROUND_DIGITS),\n        round(dt_max_series2, ROUND_DIGITS),\n        is_stable2\n    ])\n    \n    # --- Case 3 ---\n    M3 = np.diag([1.0, 2.0, 1.5])\n    k_w1_3, k_12_3, k_23_3, k_w3_3 = 900.0, 1100.0, 1000.0, 700.0\n    Kb_3 = np.array([\n        [k_w1_3 + k_12_3, -k_12_3, 0],\n        [-k_12_3, k_12_3 + k_23_3, -k_23_3],\n        [0, -k_23_3, k_23_3 + k_w3_3]\n    ])\n    \n    def K_func3(t):\n        if t  0.6:\n            return Kb_3\n        else:\n            return 3.0 * Kb_3\n            \n    params3 = {\n        's': 0.90, 'r_up': 1.10, 'r_down': 1.30,\n        'dt_min': 1e-5, 'dt_max': 5e-3\n    }\n    times3 = np.linspace(0, 1, 101)\n    \n    dt_series3, _, is_stable3 = adaptive_time_stepping(times3, M3, K_func3, **params3)\n    \n    ratios = [dt_series3[i+1] / dt_series3[i] for i in range(len(dt_series3) - 1)]\n    R_inc = max(ratios)\n    R_dec = min(ratios)\n    \n    all_results.append([\n        round(R_inc, ROUND_DIGITS),\n        round(R_dec, ROUND_DIGITS),\n        is_stable3\n    ])\n\n    # --- Format and Print Output ---\n    def format_item(item):\n        if isinstance(item, float):\n            return f\"{item:.{ROUND_DIGITS}f}\"\n        return repr(item)\n\n    results_str_parts = []\n    for res_list in all_results:\n        res_list_str = [format_item(item) for item in res_list]\n        results_str_parts.append(f\"[{','.join(res_list_str)}]\")\n    \n    print(f\"[{','.join(results_str_parts)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "许多现实世界的工程系统包含具有截然不同刚度特性的组件。对整个系统使用由最硬部分决定的单一、全局小时间步长，在计算上通常是令人望而却步的。本练习  介绍算子分裂和子循环，这是一种优雅的多速率技术，允许系统的不同部分以不同的时间步长进行积分。您将实现这种分区方案，并学习如何数值评估其稳定性，这是设计高效稳健的仿真工具时的关键考量。",
            "id": "3599558",
            "problem": "考虑一个双自由度半离散结构模型，该模型通过使用有限元法（FEM）对线性弹性固体进行空间离散化得到。半离散运动方程的形式为 $M \\ddot{u} + K(u) u = f$，其中 $M$ 是质量矩阵，$K(u)$ 是刚度算子（可能依赖于位移 $u$），$f$ 是外力向量。本问题中，假设为线性弹性行为，因此 $K(u) \\equiv K$ 是恒定的。模型由一个位移为 $u_s$ 的“软”分量和一个位移为 $u_f$ 的“刚”分量组成，它们在界面处通过一个线性弹簧耦合。质量矩阵为 $M = \\operatorname{diag}(m_s, m_f)$，刚度矩阵为\n$$\nK = \\begin{bmatrix}\nk_s + k_c  -k_c \\\\\n-k_c  k_f + k_c\n\\end{bmatrix},\n$$\n且没有外力作用，$f = 0$。其中，$m_s$ 和 $m_f$ 是质量（单位：千克），$k_s$ 和 $k_f$ 是自刚度（单位：牛顿/米），$k_c$ 是界面处的耦合刚度（单位：牛顿/米）。位移 $u_s$ 和 $u_f$ 的单位为米，速度 $\\dot{u}_s$ 和 $\\dot{u}_f$ 的单位为米/秒，时间 $t$ 的单位为秒。\n\n目标是通过算子分裂来分解刚-软耦合，并对刚性分量实施子循环。具体来说，使用以下基于辛欧拉法的算子分裂策略，将系统从时间 $t^n$推进到 $t^{n+1} = t^n + \\Delta t$：\n\n- 刚性子循环：在 $m_{\\text{sub}}$ 个子步上对刚性分量 $(u_f, \\dot{u}_f)$ 进行演化，子步长为 $\\Delta t_f = \\Delta t / m_{\\text{sub}}$，在每个刚性子步内保持软位移的代理值恒定。该代理由一个带有参数 $\\alpha \\in [0,1]$ 的界面交换规则定义：\n$$\nu_s^\\alpha = (1 - \\alpha) u_s^n + \\alpha \\left(u_s^n + \\Delta t \\, \\dot{u}_s^n\\right).\n$$\n在每个子步上使用辛欧拉法更新，加速度为\n$$\n\\ddot{u}_f = -\\omega_f^2 \\, u_f + \\gamma_f \\, u_s^\\alpha,\n$$\n其中 $\\omega_f^2 = \\frac{k_f + k_c}{m_f}$ 且 $\\gamma_f = \\frac{k_c}{m_f}$。\n\n- 软分量更新：完成刚性子循环得到 $(u_f^{n+1}, \\dot{u}_f^{n+1})$ 后，在宏观步长 $\\Delta t$上使用辛欧拉法更新软分量 $(u_s, \\dot{u}_s)$，其加速度为\n$$\n\\ddot{u}_s = -\\omega_s^2 \\, u_s + \\gamma_s \\, u_f^\\alpha,\n$$\n其中 $\\omega_s^2 = \\frac{k_s + k_c}{m_s}$，$\\gamma_s = \\frac{k_c}{m_s}$，且\n$$\nu_f^\\alpha = (1 - \\alpha) u_f^n + \\alpha \\, u_f^{n+1}.\n$$\n\n在这两个更新中，应用辛欧拉公式：\n$$\n\\dot{u}^{n+1} = \\dot{u}^n + h \\, a(u^n), \\quad u^{n+1} = u^n + h \\, \\dot{u}^{n+1},\n$$\n其中使用上面指定的适当步长 $h$ 和加速度 $a(\\cdot)$。在每个宏观步中，软分量和刚分量按此顺序推进；加速度使用界面交换规则以避免联立求解，从而使该格式完全显式。\n\n必须通过单步放大矩阵的谱半径来评估这种分区和子循环格式的稳定性，该矩阵将宏观步状态 $(u_s^n,\\dot{u}_s^n,u_f^n,\\dot{u}_f^n)$ 映射到 $(u_s^{n+1},\\dot{u}_s^{n+1},u_f^{n+1},\\dot{u}_f^{n+1})$。对于给定的参数集，如果谱半径小于或等于 $1$（在数值容差范围内），则定义该格式为稳定，否则为不稳定。评估必须是纯数值的；不要依赖于除辛欧拉算子和线性系统定义所隐含的表达式之外的闭式解。\n\n你的任务是：\n\n- 精确实现所述的带刚性子循环和界面交换规则的算子分裂。\n- 构建全局宏观步放大算子并计算其谱半径。\n- 通过检查谱半径是否小于或等于 $1 + \\varepsilon$（其中 $\\varepsilon = 10^{-8}$）来决定稳定性，结果为布尔值。\n\n使用以下涵盖不同行为的科学合理参数集测试套件，包括强刚度对比、边界步长条件和子循环效应。所有量必须以其指定单位处理。\n\n- 测试1（理想情况，强对比度与安全子循环）：$m_s = 1.0$ 千克，$m_f = 0.05$ 千克，$k_s = 5000$ 牛顿/米，$k_f = 200000$ 牛顿/米，$k_c = 30000$ 牛顿/米，$\\Delta t = 0.002$ 秒，$m_{\\text{sub}} = 200$，$\\alpha = 0.5$。\n- 测试2（近边界软步长，重度子循环）：与测试1相同的质量和刚度，$\\Delta t = 0.010$ 秒，$m_{\\text{sub}} = 500$，$\\alpha = 0.5$。\n- 测试3（由宏观步违规引起的软不稳定性）：与测试1相同的质量和刚度，$\\Delta t = 0.012$ 秒，$m_{\\text{sub}} = 500$，$\\alpha = 0.5$。\n- 测试4（无子循环时的刚性不稳定性）：与测试1相同的质量和刚度，$\\Delta t = 0.002$ 秒，$m_{\\text{sub}} = 1$，$\\alpha = 0.5$。\n\n你的程序应生成一行输出，其中包含对测试的稳定性判定，格式为方括号内以逗号分隔的列表（例如，$[True,False,True]$）。使用Python布尔字面量 $True$ 或 $False$，不含其他文本。预期的输出列表长度等于测试用例的数量。",
            "solution": "首先评估问题陈述的有效性。\n\n### 步骤1：提取给定信息\n- **系统方程**：半离散运动方程 $M \\ddot{u} + K u = f$。\n- **模型**：线性弹性，因此 $K$ 是常数。具有“软”分量位移 $u_s$ 和“刚”分量位移 $u_f$ 的双自由度模型。\n- **矩阵和向量**：\n    - 质量矩阵：$M = \\operatorname{diag}(m_s, m_f)$。\n    - 刚度矩阵：$K = \\begin{bmatrix} k_s + k_c  -k_c \\\\ -k_c  k_f + k_c \\end{bmatrix}$。\n    - 外力：$f = 0$。\n- **参数**：质量 $m_s, m_f$ (kg)；刚度 $k_s, k_f, k_c$ (N/m)；位移 $u_s, u_f$ (m)；速度 $\\dot{u}_s, \\dot{u}_f$ (m/s)；时间 $t$ (s)。\n- **积分格式**：从时间 $t^n$ 到 $t^{n+1} = t^n + \\Delta t$ 的算子分裂。\n    1.  **刚性子循环**：\n        - 子步数：$m_{\\text{sub}}$。子步长：$\\Delta t_f = \\Delta t / m_{\\text{sub}}$。\n        - 界面交换规则（软分量代理）：$u_s^\\alpha = (1 - \\alpha) u_s^n + \\alpha \\left(u_s^n + \\Delta t \\, \\dot{u}_s^n\\right)$。\n        - 演化方程：$\\ddot{u}_f = -\\omega_f^2 \\, u_f + \\gamma_f \\, u_s^\\alpha$，其中 $\\omega_f^2 = \\frac{k_f + k_c}{m_f}$ 和 $\\gamma_f = \\frac{k_c}{m_f}$。\n        - 积分器：辛欧拉法。\n    2.  **软分量更新**：\n        - 步长：$\\Delta t$。\n        - 界面交换规则（刚分量代理）：$u_f^\\alpha = (1 - \\alpha) u_f^n + \\alpha \\, u_f^{n+1}$。\n        - 演化方程：$\\ddot{u}_s = -\\omega_s^2 \\, u_s + \\gamma_s \\, u_f^\\alpha$，其中 $\\omega_s^2 = \\frac{k_s + k_c}{m_s}$ 和 $\\gamma_s = \\frac{k_c}{m_s}$。\n        - 积分器：辛欧拉法。\n- **辛欧拉公式**：对于步长 $h$ 和加速度 $a(u)$，更新为 $\\dot{u}^{k+1} = \\dot{u}^k + h \\, a(u^k)$，然后是 $u^{k+1} = u^k + h \\, \\dot{u}^{k+1}$。\n- **任务**：\n    - 实现该格式。\n    - 构建宏观步放大算子。\n    - 计算其谱半径。\n    - 评估稳定性：如果谱半径 $\\le 1 + \\varepsilon$（其中 $\\varepsilon = 10^{-8}$），则格式稳定。\n- **测试用例**：\n    - 测试1: $m_s = 1.0$, $m_f = 0.05$, $k_s = 5000$, $k_f = 200000$, $k_c = 30000$, $\\Delta t = 0.002$, $m_{\\text{sub}} = 200$, $\\alpha = 0.5$。\n    - 测试2: 与测试1相同的 m, k。$\\Delta t = 0.010$, $m_{\\text{sub}} = 500$, $\\alpha = 0.5$。\n    - 测试3: 与测试1相同的 m, k。$\\Delta t = 0.012$, $m_{\\text{sub}} = 500$, $\\alpha = 0.5$。\n    - 测试4: 与测试1相同的 m, k。$\\Delta t = 0.002$, $m_{\\text{sub}} = 1$, $\\alpha = 0.5$。\n\n### 步骤2：使用提取的给定信息进行验证\n该问题是科学合理的。它提出了一个来自计算固体力学的标准模型和数值方法，用于处理刚-软动态系统。其公式涉及多速率算子分裂格式（子循环），这是常微分方程数值分析中的常用技术。所使用的积分器——辛欧拉法，是处理哈密顿系统的成熟方法，线性弹性动力学是其一例。\n\n该问题是适定的。任务是数值构建一个特定的线性算子（放大矩阵），并计算其谱半径以确定稳定性。所有参数、方程和算法步骤都已明确定义，从而为每个测试用例得出一个唯一的、可计算的结果。\n\n该问题是客观和完整的。它使用了精确的数学和物理术语。计算所需的所有数据都在四个测试用例中提供。问题陈述中没有矛盾或含糊之处。物理单位是一致的，参数值对于一个力学系统来说是合理的。\n\n因此，该问题不具有验证标准中列出的任何缺陷。\n\n### 步骤3：结论与行动\n该问题是有效的。将提供一个合理的解决方案。\n\n---\n\n### 解决方案\n\n所述数值格式的稳定性由单步放大矩阵的谱半径决定，该矩阵将系统状态从时间 $t^n$ 映射到 $t^{n+1}$。设状态向量为 $X(t) = [u_s(t), \\dot{u}_s(t), u_f(t), \\dot{u}_f(t)]^T$。时间步进算法定义了一个线性映射 $A$，使得 $X^{n+1} = A X^n$。当且仅当 $A$ 的谱半径 $\\rho(A) = \\max_i |\\lambda_i(A)|$（其中 $\\lambda_i$ 是 $A$ 的特征值）小于或等于 $1$ 时，该格式是稳定的。\n\n放大矩阵 $A$ 是一个 $4 \\times 4$ 矩阵。由于从 $X^n$ 到 $X^{n+1}$ 的整个更新过程是线性的，因此 $A$ 的各列可以通过数值方法确定。$A$ 的第 $j$ 列是将单步更新算法应用于第 $j$ 个标准基向量 $e_j$ 的结果。例如，$A$ 的第一列是通过将初始状态设置为 $X^n = e_1 = [1, 0, 0, 0]^T$ 并计算得到的状态 $X^{n+1}$ 来获得的。对所有四个基向量重复此过程以构建完整的矩阵 $A$。\n\n更新过程本身由两个主要阶段组成，在每个大小为 $\\Delta t$ 的宏观步中依次执行：\n\n1.  **刚性子循环**：刚性自由度 $(u_f, \\dot{u}_f)$ 在宏观区间 $[t^n, t^{n+1}]$ 上使用 $m_{\\text{sub}}$ 个大小为 $\\Delta t_f = \\Delta t / m_{\\text{sub}}$ 的更小时间步进行演化。在此子循环过程中，软分量的影响通过一个保持恒定的代理位移 $u_s^\\alpha = u_s^n + \\alpha \\Delta t \\dot{u}_s^n$ 来近似。对于从 $0$ 到 $m_{\\text{sub}}-1$ 的每个子步 $j$，从 $(u_{f,0}, \\dot{u}_{f,0}) = (u_f^n, \\dot{u}_f^n)$ 开始，我们应用辛欧拉法。加速度为 $a_f(u_{f,j}) = -\\omega_f^2 u_{f,j} + \\gamma_f u_s^\\alpha$。更新如下：\n    $$\n    \\dot{u}_{f,j+1} = \\dot{u}_{f,j} + \\Delta t_f \\, a_f(u_{f,j})\n    $$\n    $$\n    u_{f,j+1} = u_{f,j} + \\Delta t_f \\, \\dot{u}_{f,j+1}\n    $$\n    经过 $m_{\\text{sub}}$ 次迭代后，我们得到最终状态 $(u_f^{n+1}, \\dot{u}_f^{n+1}) = (u_{f,m_{\\text{sub}}}, \\dot{u}_{f,m_{\\text{sub}}})$。此操作是一个从 $X^n$到 $(u_f^{n+1}, \\dot{u}_f^{n+1})$ 的线性映射。\n\n2.  **软分量更新**：在刚性子循环之后，软自由度 $(u_s, \\dot{u}_s)$ 在整个宏观步长 $\\Delta t$ 上进行更新。来自刚性分量的影响现在通过代理 $u_f^\\alpha = (1 - \\alpha) u_f^n + \\alpha u_f^{n+1}$ 来近似，该代理使用了刚计算出的 $u_f^{n+1}$。加速度在宏观步开始时评估，$a_s(u_s^n) = -\\omega_s^2 u_s^n + \\gamma_s u_f^\\alpha$。然后辛欧拉更新为：\n    $$\n    \\dot{u}_s^{n+1} = \\dot{u}_s^n + \\Delta t \\, a_s(u_s^n)\n    $$\n    $$\n    u_s^{n+1} = u_s^n + \\Delta t \\, \\dot{u}_s^{n+1}\n    $$\n    此操作完成更新，得到 $(u_s^{n+1}, \\dot{u}_s^{n+1})$。\n\n通过组合这两个阶段，我们得到完整的变换 $X^n \\mapsto X^{n+1}$。数值实现将构建代表此变换的矩阵 $A$。然后，计算其特征值以找到谱半径。通过将此半径与 $1 + \\varepsilon$（其中 $\\varepsilon = 10^{-8}$）进行比较来确定稳定性。对测试套件中提供的每个参数集重复此过程。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It constructs the amplification matrix for each case, computes its\n    spectral radius, and determines stability.\n    \"\"\"\n    # Test cases defined as tuples of (ms, mf, ks, kf, kc, dt, m_sub, alpha)\n    test_cases = [\n        # Test 1 (happy path, strong contrast with safe subcycling)\n        (1.0, 0.05, 5000.0, 200000.0, 30000.0, 0.002, 200, 0.5),\n        # Test 2 (near-boundary soft step, heavy subcycling)\n        (1.0, 0.05, 5000.0, 200000.0, 30000.0, 0.010, 500, 0.5),\n        # Test 3 (soft instability by macro-step violation)\n        (1.0, 0.05, 5000.0, 200000.0, 30000.0, 0.012, 500, 0.5),\n        # Test 4 (stiff instability if no subcycling)\n        (1.0, 0.05, 5000.0, 200000.0, 30000.0, 0.002, 1, 0.5)\n    ]\n\n    # Stability tolerance\n    epsilon = 1e-8\n    results = []\n\n    for params in test_cases:\n        # Construct the amplification matrix for the current parameter set\n        A = get_amplification_matrix(params)\n        # Compute eigenvalues\n        eigenvalues = np.linalg.eigvals(A)\n        # Compute spectral radius (max of absolute values of eigenvalues)\n        spectral_radius = np.max(np.abs(eigenvalues))\n        # Check for stability against the tolerance\n        is_stable = spectral_radius = 1.0 + epsilon\n        results.append(is_stable)\n\n    # Format the results into the required output string\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef get_amplification_matrix(params):\n    \"\"\"\n    Constructs the 4x4 amplification matrix by applying the update scheme\n    to the four canonical basis vectors.\n    \n    Args:\n        params (tuple): A tuple containing the model and scheme parameters.\n        \n    Returns:\n        numpy.ndarray: The 4x4 amplification matrix.\n    \"\"\"\n    A = np.zeros((4, 4), dtype=np.float64)\n    basis_vectors = np.identity(4)\n\n    for i in range(4):\n        # The i-th column of the amplification matrix is the result of\n        # applying one time step to the i-th basis vector.\n        A[:, i] = perform_one_macro_step(basis_vectors[:, i], params)\n    return A\n\n\ndef perform_one_macro_step(X_n, params):\n    \"\"\"\n    Advances the system state X_n by one macro-step dt using the specified\n    operator-splitting scheme.\n    \n    Args:\n        X_n (numpy.ndarray): The state vector [us_n, udot_s_n, uf_n, udot_f_n] at time t^n.\n        params (tuple): A tuple containing the model and scheme parameters.\n        \n    Returns:\n        numpy.ndarray: The new state vector at time t^{n+1}.\n    \"\"\"\n    ms, mf, ks, kf, kc, dt, m_sub, alpha = params\n    us_n, udot_s_n, uf_n, udot_f_n = X_n\n\n    # Calculate derived constants\n    dt_f = dt / m_sub\n    omega_s_sq = (ks + kc) / ms\n    gamma_s = kc / ms\n    omega_f_sq = (kf + kc) / mf\n    gamma_f = kc / mf\n\n    # --- Stiff Subcycling Stage ---\n    # Proxy for soft displacement, held constant during subcycling\n    us_alpha = us_n + alpha * dt * udot_s_n\n\n    # Initialize stiff component state for subcycling\n    uf_sub = uf_n\n    udot_f_sub = udot_f_n\n\n    # Perform m_sub substeps for the stiff component\n    for _ in range(int(m_sub)):\n        # Stiff acceleration at the beginning of the substep\n        uddot_f = -omega_f_sq * uf_sub + gamma_f * us_alpha\n        \n        # Symplectic Euler update for the stiff component\n        udot_f_sub_new = udot_f_sub + dt_f * uddot_f\n        uf_sub_new = uf_sub + dt_f * udot_f_sub_new\n        \n        # Update state for the next substep\n        uf_sub, udot_f_sub = uf_sub_new, udot_f_sub_new\n\n    # Final state of the stiff component after subcycling\n    uf_np1 = uf_sub\n    udot_f_np1 = udot_f_sub\n    \n    # --- Soft Update Stage ---\n    # Proxy for stiff displacement, based on states at macro-steps n and n+1\n    uf_alpha = (1.0 - alpha) * uf_n + alpha * uf_np1\n    \n    # Soft acceleration at the beginning of the macro-step (using u_s^n)\n    uddot_s = -omega_s_sq * us_n + gamma_s * uf_alpha\n    \n    # Symplectic Euler update for the soft component over the macro-step dt\n    udot_s_np1 = udot_s_n + dt * uddot_s\n    us_np1 = us_n + dt * udot_s_np1\n    \n    # Assemble the final state vector at t^{n+1}\n    return np.array([us_np1, udot_s_np1, uf_np1, udot_f_np1])\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "半离散运动方程通常需要包含复杂的非线性现象，例如接触，它对系统的运动施加不等式约束（例如，一个物体不能穿透另一个物体）。本练习  超越了线性动力学的范畴，使用隐式时间积分和现代优化技术来应对这一挑战。您将把接触问题表述为一个凸二次规划问题，并使用交替方向乘子法 (ADMM) 进行求解，从而获得解决高级仿真软件中强大方法的实践经验。",
            "id": "3599599",
            "problem": "设计并实现一个求解器，该求解器使用交替方向乘子法 (ADMM) 或等效的交替最小二乘法 (ALS) 分裂，以在受到零位移处刚性天花板约束的单自由度线性弹性振子的半离散运动方程中施加单边接触约束。单个隐式后向欧拉时间步的半离散方程由牛顿第二定律和胡克定律得出，其形式如下：求解下一步位移 $u_{n+1}$ 和接触乘子 $\\lambda$，使得\n$$\nM \\ddot{u}_{n+1} + K u_{n+1} + B^{\\mathsf{T}} \\lambda = f_{n+1},\n$$\n其中运动学更新为 $u_{n+1} = u_n + h v_{n+1}$，$M$ 是质量，$K$ 是线性刚度，$f_{n+1}$ 是时间 $t_{n+1}$ 时的外加载荷，$h$ 是时间步长，$B$ 是线性化接触算子。对于定义的标量接触间隙函数 $g(u) = u$（施加 $u \\le 0$ 的刚性天花板约束），单边约束为 $g(u_{n+1}) \\le 0$。使用后向欧拉法消去加速度和速度，以获得关于 $u_{n+1}$ 的线性二次目标和单一线性不等式约束 $g(u_{n+1}) \\le 0$，且不引入任何阻尼。具体来说，推导有效系统\n$$\nH u_{n+1} + B^{\\mathsf{T}} \\lambda = r,\n$$\n其中 $H$ 和 $r$ 是 $M$、$K$、$h$、$u_n$、$v_n$ 和 $f_{n+1}$ 的函数，且对于 $g(u) = u$，$B = 1$。\n\n您的任务是：\n- 仅从牛顿第二定律和后向欧拉时间离散化出发，推导包含单边不等式 $g(u_{n+1}) \\le 0$ 的、关于 $u_{n+1}$ 的凸二次规划。\n- 构建缩放 ADMM 更新，以一致性形式求解该问题，其中辅助变量 $z$ 通过投影施加约束集 $\\mathcal{C} = (-\\infty, 0]$。使用带有罚参数 $\\rho  0$ 的标准缩放形式。更新结构必须在关于 $u$ 的最小二乘步和关于 $z$ 的投影步之间交替。\n- 实现 ADMM 迭代并监控：\n  1. 原始残差 $r_p^k = \\lVert g(u^k) - z^k \\rVert_2$。\n  2. 增广目标序列\n     $$\n     \\Phi_\\rho^k = \\tfrac{1}{2} u^{k\\mathsf{T}} H u^k - r^{\\mathsf{T}} u^k + I_{\\mathcal{C}}(z^k) + \\tfrac{\\rho}{2} \\lVert B u^k - z^k \\rVert_2^2,\n     $$\n     其中，如果 $z \\in \\mathcal{C}$，$I_{\\mathcal{C}}(z)$ 为 $0$，否则为 $+\\infty$。由于 $z$ 的更新是到 $\\mathcal{C}$ 上的精确投影，因此在迭代过程中 $I_{\\mathcal{C}}(z^k) = 0$。\n- 当原始残差和对偶残差均低于容差，或达到最大迭代次数时，停止迭代。在此设置下，缩放 ADMM 的对偶残差为 $s^k = \\rho \\lVert z^k - z^{k-1} \\rVert_2$。\n\n物理和数值单位及约定：\n- 将 $u$、$v$ 和 $h$ 的单位视为米和秒，$M$ 的单位视为千克，$K$ 的单位视为牛顿/米，$f$ 的单位视为牛顿，$\\lambda$ 的单位视为牛顿。尽管 ADMM 残差和增广目标函数使用算法单位，但请确保所有物理输入都遵守这些单位。\n- 不使用角度；无需指定角度单位。\n\n测试套件和要求输出：\n- 对以下三个测试用例使用相同的 ADMM 参数。对于所有用例，设置缩放 ADMM 罚参数 $\\rho = 1000$，最大迭代次数 $N_{\\max} = 200$，原始残差的绝对容差 $\\varepsilon_p = 10^{-10}$，对偶残差的绝对容差 $\\varepsilon_d = 10^{-10}$。\n- 对于每个用例，使用后向欧拉法根据给定数据构建 $H$ 和 $r$，然后从无约束解 $u^{0} = H^{-1} r$ 以及 $z^{0} = \\min(0, u^{0})$、$y^{0} = 0$ 开始运行 ADMM。\n- 测试用例（所有量必须与所列完全一致）：\n  1. 理想路径主动接触：$M = 1$, $K = 1000$, $h = 0.05$, $u_n = -0.01$, $v_n = 0$, $f_{n+1} = 30$。\n  2. 严格非主动接触：$M = 1$, $K = 1000$, $h = 0.05$, $u_n = -0.01$, $v_n = 0$, $f_{n+1} = 0$。\n  3. 边界（临界主动）接触：$M = 1$, $K = 1000$, $h = 0.05$, $u_n = -0.01$, $v_n = 0$, $f_{n+1} = 4$。\n- 对于每个测试用例，您的程序必须计算并返回：\n  1. 最终原始残差 $r_p$，作为一个四舍五入到六位小数的浮点数。\n  2. 一个布尔标志，指示增广目标序列 $\\{\\Phi_\\rho^k\\}_{k=0}^{k_{\\text{final}}}$ 是否非增，即对于所有 $k$，$\\Phi_\\rho^{k+1} \\le \\Phi_\\rho^{k} + \\delta$ 是否成立，其中 $\\delta = 10^{-12}$ 是一个数值松弛量。\n\n最终输出格式：\n- 您的程序应生成单行输出，包含三个测试用例的结果，形式为一个包含三个项目的逗号分隔列表，每个项目是一个双元素列表 $[r_p, \\text{flag}]$。例如，输出必须类似于 $[[0.0,True],[0.0,True],[0.0,True]]$，但要使用上述测试套件的实际计算值和布尔值。",
            "solution": "该问题是有效的，因为它在科学上基于计算固体力学的原理，在数学上是适定的，并且使用了客观、明确的语言和充足的数据进行了规定。我们开始进行求解。\n\n任务是求解带单边接触约束的单自由度线性弹性振子的半离散运动方程。解决方案将通过以下步骤展开：首先推导单个时间步的有效系统，将问题表述为凸二次规划，然后构建并实现一个交替方向乘子法 (ADMM) 算法。\n\n### 1. 有效系统的推导\n\n在时间 $t_{n+1}$ 的运动方程由牛顿第二定律给出，包括刚度和接触力：\n$$\nM \\ddot{u}_{n+1} + K u_{n+1} + B^{\\mathsf{T}} \\lambda = f_{n+1}\n$$\n其中 $M$ 是质量，$K$ 是刚度，$u_{n+1}$ 是位移，$\\ddot{u}_{n+1}$ 是加速度，$f_{n+1}$ 是外力，$\\lambda$ 是接触力乘子，$B^{\\mathsf{T}}$ 是线性化接触算子的转置。\n\n我们使用隐式后向欧拉法来离散化时间导数。速度 $v_{n+1}$ 和加速度 $\\ddot{u}_{n+1}$ 近似为：\n$$\nv_{n+1} = \\frac{u_{n+1} - u_n}{h}\n$$\n$$\n\\ddot{u}_{n+1} = \\frac{v_{n+1} - v_n}{h} = \\frac{1}{h} \\left( \\frac{u_{n+1} - u_n}{h} - v_n \\right) = \\frac{1}{h^2} (u_{n+1} - u_n - h v_n)\n$$\n其中 $u_n$ 和 $v_n$ 是前一时间步 $t_n$ 的位移和速度，$h$ 是时间步长。\n\n将 $\\ddot{u}_{n+1}$ 的表达式代入运动方程，得到：\n$$\nM \\left( \\frac{u_{n+1} - u_n - h v_n}{h^2} \\right) + K u_{n+1} + B^{\\mathsf{T}} \\lambda = f_{n+1}\n$$\n为了获得有效系统，我们重新排列各项，将包含未知位移 $u_{n+1}$ 的项分组到左侧，将所有已知量分组到右侧：\n$$\n\\frac{M}{h^2} u_{n+1} + K u_{n+1} + B^{\\mathsf{T}} \\lambda = f_{n+1} + \\frac{M}{h^2} (u_n + h v_n)\n$$\n提出 $u_{n+1}$ 后，我们得到指定的形式 $H u_{n+1} + B^{\\mathsf{T}} \\lambda = r$：\n$$\n\\left( \\frac{M}{h^2} + K \\right) u_{n+1} + B^{\\mathsf{T}} \\lambda = f_{n+1} + \\frac{M}{h^2} (u_n + h v_n)\n$$\n由此，我们确定有效刚度矩阵（在本例中为标量）$H$ 和有效力向量（标量）$r$：\n$$\nH = \\frac{M}{h^2} + K\n$$\n$$\nr = f_{n+1} + \\frac{M}{h^2} (u_n + h v_n)\n$$\n接触间隙函数为 $g(u) = u$，这意味着线性化算子 $B = \\frac{\\partial g}{\\partial u} = 1$。\n\n### 2. 二次规划表述\n\n方程 $H u_{n+1} - r = -B^{\\mathsf{T}}\\lambda$ 是一个受约束的能量泛函的平稳性条件。该问题可以表述为一个约束优化问题。无约束动力学对应于最小化二次目标函数 $\\mathcal{E}(u) = \\frac{1}{2} u H u - r u$。单边接触约束强制 $g(u_{n+1}) \\le 0$，对于 $g(u)=u$ 即为 $u_{n+1} \\le 0$。\n\n因此，问题是求解位移 $u_{n+1}$，该位移是以下凸二次规划 (QP) 问题的解：\n$$\n\\begin{aligned}\n \\underset{u_{n+1}}{\\text{minimize}}\n  \\frac{1}{2} u_{n+1} H u_{n+1} - r u_{n+1} \\\\\n \\text{subject to}\n  u_{n+1} \\le 0\n\\end{aligned}\n$$\n\n### 3. ADMM 表述与更新\n\n为使用 ADMM 求解此 QP 问题，我们引入一个辅助变量 $z$ 并将问题转换为一致性形式。约束 $u_{n+1} \\le 0$ 通过要求 $z \\in \\mathcal{C} = (-\\infty, 0]$ 并设置 $u_{n+1} = z$ 来施加。优化问题变为：\n$$\n\\begin{aligned}\n \\underset{u, z}{\\text{minimize}}\n  \\left(\\frac{1}{2} u H u - r u\\right) + I_{\\mathcal{C}}(z) \\\\\n \\text{subject to}\n  u - z = 0\n\\end{aligned}\n$$\n其中 $u$ 是我们的未知量 $u_{n+1}$，$I_{\\mathcal{C}}(z)$ 是集合 $\\mathcal{C}$ 的指示函数，当 $z \\in \\mathcal{C}$ 时其值为 $0$，否则为 $+\\infty$。\n\n此问题的缩放增广拉格朗日量为：\n$$\n\\mathcal{L}_{\\rho}(u, z, y) = \\frac{1}{2} u H u - r u + I_{\\mathcal{C}}(z) + \\frac{\\rho}{2} \\lVert u - z + y \\rVert_2^2 - \\frac{\\rho}{2}\\lVert y \\rVert_2^2\n$$\n其中 $y$ 是缩放对偶变量，$\\rho  0$ 是罚参数。ADMM 算法通过迭代地对 $\\mathcal{L}_{\\rho}$ 关于 $u$ 和 $z$ 进行最小化，然后更新对偶变量 $y$。对于第 $k$ 次迭代，更新步骤如下：\n\n1.  **$u$-最小化：** 我们通过最小化 $\\mathcal{L}_{\\rho}(u, z^k, y^k)$ 关于 $u$ 来更新 $u^{k+1}$。这需要求解 $\\nabla_u \\mathcal{L}_{\\rho} = 0$：\n    $$\n    H u - r + \\rho (u - z^k + y^k) = 0 \\implies (H + \\rho) u = r + \\rho(z^k - y^k)\n    $$\n    由于 $H$ 是标量， $u$ 的更新公式为：\n    $$\n    u^{k+1} = \\frac{r + \\rho(z^k - y^k)}{H + \\rho}\n    $$\n\n2.  **$z$-最小化：** 我们通过最小化 $\\mathcal{L}_{\\rho}(u^{k+1}, z, y^k)$ 关于 $z$ 来更新 $z^{k+1}$：\n    $$\n    z^{k+1} = \\underset{z}{\\arg\\min} \\left( I_{\\mathcal{C}}(z) + \\frac{\\rho}{2} \\lVert u^{k+1} - z + y^k \\rVert_2^2 \\right)\n    $$\n    这是一个投影问题。解是将点 $(u^{k+1} + y^k)$ 投影到集合 $\\mathcal{C} = (-\\infty, 0]$ 上。\n    $$\n    z^{k+1} = \\Pi_{\\mathcal{C}}(u^{k+1} + y^k) = \\min(0, u^{k+1} + y^k)\n    $$\n\n3.  **对偶变量更新：** 缩放对偶变量 $y$ 的更新方式如下：\n    $$\n    y^{k+1} = y^k + u^{k+1} - z^{k+1}\n    $$\n算法初始化为 $u^0 = H^{-1}r$，$z^0 = \\min(0, u^0)$ 和 $y^0 = 0$。\n\n### 4. 监控与停止准则\n\n算法的收敛性通过原始残差和对偶残差进行监控。\n-   **原始残差：** $r_p^{k+1} = \\lVert u^{k+1} - z^{k+1} \\rVert_2 = |u^{k+1} - z^{k+1}|$。它衡量了一致性约束 $u=z$ 的违反程度。\n-   **对偶残差：** $s_d^{k+1} = \\rho \\lVert z^{k+1} - z^k \\rVert_2 = \\rho |z^{k+1} - z^k|$。它衡量了辅助变量的变化，这与平稳性条件相关。\n\n当两个残差都低于各自的容差 $\\varepsilon_p$ 和 $\\varepsilon_d$，或达到最大迭代次数 $N_{\\max}$ 时，迭代终止。\n$$\nr_p^{k+1}  \\varepsilon_p \\quad \\text{and} \\quad s_d^{k+1}  \\varepsilon_d\n$$\n\n此外，我们监控增广目标序列 $\\Phi_\\rho^k$：\n$$\n\\Phi_\\rho^k = \\frac{1}{2} (u^k)^2 H - r u^k + \\frac{\\rho}{2} (u^k - z^k)^2\n$$\n问题要求检查此序列是否非增，即对于一个小的数值松弛量 $\\delta$，$\\Phi_\\rho^{k+1} \\le \\Phi_\\rho^k + \\delta$ 是否成立。此性质是检验算法正确实现和收敛行为的有用诊断工具。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_admm_case(case_data, admm_params):\n    \"\"\"\n    Runs the ADMM solver for a single test case.\n\n    Args:\n        case_data (tuple): Contains physical parameters (M, K, h, u_n, v_n, f_np1).\n        admm_params (dict): Contains ADMM parameters (rho, N_max, eps_p, eps_d, delta).\n\n    Returns:\n        list: A list containing the final primal residual (rounded) and a boolean\n              indicating if the objective function was non-increasing.\n    \"\"\"\n    M, K, h, u_n, v_n, f_np1 = case_data\n    rho = admm_params['rho']\n    N_max = admm_params['N_max']\n    eps_p = admm_params['eps_p']\n    eps_d = admm_params['eps_d']\n    delta = admm_params['delta']\n\n    # 1. Construct the effective system: H u + B^T lambda = r\n    # For this scalar problem, B = 1.\n    H = M / h**2 + K\n    r = f_np1 + (M / h**2) * (u_n + h * v_n)\n\n    # 2. ADMM Initialization, as per problem statement\n    # u^0 = H^{-1} r\n    u_k = r / H\n    # z^0 = min(0, u^0)\n    z_k = min(0.0, u_k)\n    # y^0 = 0\n    y_k = 0.0\n\n    obj_values = []\n    \n    # Calculate initial augmented objective Phi^0\n    # The term I_C(z^k) = 0 because z^k is always projected onto C.\n    # Phi_rho^k = 0.5 * u^k H u^k - r u^k + 0.5 * rho * ||u^k - z^k||^2\n    obj_k = 0.5 * H * u_k**2 - r * u_k + 0.5 * rho * (u_k - z_k)**2\n    obj_values.append(obj_k)\n    \n    final_rp = np.abs(u_k - z_k)\n    final_sd = np.inf # To avoid premature exit if z starts at the solution\n\n    # 3. ADMM Iteration Loop\n    for _ in range(N_max):\n        z_prev = z_k\n\n        # u-update (solve u-minimization problem)\n        u_k = (r + rho * (z_k - y_k)) / (H + rho)\n\n        # z-update (projection onto C = (-inf, 0])\n        z_k = min(0.0, u_k + y_k)\n\n        # y-update (dual variable update)\n        y_k = y_k + u_k - z_k\n\n        # Calculate current augmented objective Phi^{k+1}\n        obj_k = 0.5 * H * u_k**2 - r * u_k + 0.5 * rho * (u_k - z_k)**2\n        obj_values.append(obj_k)\n\n        # Calculate residuals for stopping criteria\n        # Primal residual r_p = ||u^k - z^k||_2\n        # Dual residual s_d = rho * ||z^k - z^{k-1}||_2\n        r_p = np.abs(u_k - z_k)\n        s_d = rho * np.abs(z_k - z_prev)\n\n        final_rp = r_p\n        \n        # Check for convergence\n        if r_p  eps_p and s_d  eps_d:\n            break\n\n    # 4. Check if the augmented objective sequence is non-increasing\n    is_non_increasing = True\n    for i in range(len(obj_values) - 1):\n        if obj_values[i+1] > obj_values[i] + delta:\n            is_non_increasing = False\n            break\n            \n    # 5. Return the required results\n    return [round(final_rp, 6), is_non_increasing]\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run the solver, and print results.\n    \"\"\"\n    # Define common ADMM parameters for all test cases\n    ADMM_PARAMS = {\n        'rho': 1000.0,\n        'N_max': 200,\n        'eps_p': 1e-10,\n        'eps_d': 1e-10,\n        'delta': 1e-12, # Slack for non-increasing objective check\n    }\n\n    # Define the test cases from the problem statement\n    # Each tuple is (M, K, h, u_n, v_n, f_{n+1})\n    test_cases = [\n        # 1. Happy-path active contact\n        (1.0, 1000.0, 0.05, -0.01, 0.0, 30.0),\n        # 2. Strictly inactive contact\n        (1.0, 1000.0, 0.05, -0.01, 0.0, 0.0),\n        # 3. Boundary (just active) contact\n        (1.0, 1000.0, 0.05, -0.01, 0.0, 4.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_admm_case(case, ADMM_PARAMS)\n        results.append(result)\n\n    # Format the final output string exactly as required\n    results_str = [f\"[{r[0]},{r[1]}]\" for r in results]\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```"
        }
    ]
}