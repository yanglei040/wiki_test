{
    "hands_on_practices": [
        {
            "introduction": "全局刚度矩阵的结构直接取决于网格拓扑、单元类型和自由度（DOF）的排序。本练习旨在从第一性原理出发，探讨一个规则的六面体网格如何生成一个具有特定对角线结构的稀疏矩阵。通过推导对角（DIA）和压缩稀疏行（CSR）两种存储格式的存储成本，您将深入理解不同存储方案的效率，并学会如何将其与有限元问题的几何特性联系起来。",
            "id": "3601714",
            "problem": "考虑一个在线性 $Q_1$ 单元的结构化三维六面体网格上对单位立方体域内的线性标量椭圆边值问题进行的有限元离散化。设每个笛卡尔坐标轴方向上有 $n$ 个网格节点（$n \\geq 3$），并采用字典序行主序的自然自由度（DOF）排序：$(i,j,k)$ 映射到全局索引 $p = i + n j + n^2 k$，其中 $i,j,k \\in \\{0,1,\\dots,n-1\\}$。假设每个节点有一个标量自由度。由于 $Q_1$ 形函数的局部性，组装后的全局刚度矩阵 $\\boldsymbol{K} \\in \\mathbb{R}^{N \\times N}$（其中 $N = n^3$）是稀疏的。特别地，对于内部节点，$\\boldsymbol{K}$ 在一个节点与所有和它共享至少一个单元的节点之间表现出非零耦合。将对角线（DIA）存储格式定义为：将 $\\boldsymbol{K}$ 中所有由恒定的（列索引减行索引）偏移量定义的对角线，每条都存储为一个长度为 $N$ 的完整数组，并为每条对角线附加一个整数偏移量。按标准方式定义压缩稀疏行（CSR）存储格式：一个长度为 $nnz$ 的值数组，一个长度为 $nnz$ 的整数列索引数组，以及一个长度为 $N+1$ 的行指针数组。\n\n从上面给出的 $Q_1$ 形函数支撑集和自然自由度排序的核心定义出发，并且不使用任何预先制表的模板计数或存储公式，推导：\n1. 在 DIA 格式下，$\\boldsymbol{K}$ 中存在的不同对角线的确切数量。\n2. 总 DIA 存储量与总 CSR 存储量之比的一个关于 $n$ 的精确闭式表达式，其中“总存储量”同等计算标量值条目和整数索引条目。\n\n将您的最终答案表示为一个双元行向量，第一个元素等于不同对角线的数量，第二个元素等于 DIA 与 CSR 的存储比率 $\\eta(n)$。不需要数值近似；请提供关于 $n$ 的闭式表达式。如果任何中间量需要计算格点或偏移量，请从有限元法（FEM）、对角线（DIA）和压缩稀疏行（CSR）定义的第一性原理出发进行推导。最终答案必须是按要求组织的单个解析表达式或一对解析表达式。不需要物理单位。",
            "solution": "问题陈述已经过验证，被认为是有效的。它在科学上基于有限元法（FEM）和数值线性代数的原理，问题定义良好，具有清晰和完整的定义集，并以客观、正式的语言表达。没有矛盾、歧义或事实上的不健全之处。因此，我们可以进行完整的解答。\n\n该解答需要推导与在结构化 $n \\times n \\times n$ 节点网格上进行 $Q_1$ 有限元离散化所产生的稀疏全局刚度矩阵 $\\boldsymbol{K}$ 相关的两个量。\n\n提供的关键信息包括：\n- 节点总数为 $N=n^3$。\n- 节点由 $(i,j,k)$ 索引，其中 $i,j,k \\in \\{0, 1, \\dots, n-1\\}$。\n- 一个字典序行主序映射将节点的三维索引 $(i,j,k)$ 转换为一维全局索引 $p$：\n$$p(i,j,k) = i + n j + n^2 k$$\n- 当且仅当对应于全局索引 $p$ 和 $q$ 的节点共享至少一个单元时，存在非零项 $\\boldsymbol{K}_{pq}$。对于 $Q_1$（三线性六面体）单元，这意味着节点 $p$ 与构成其所属的任何单元的顶点的所有节点耦合。\n\n### 第 1 部分：不同对角线的数量\n在 DIA 格式中，“对角线”对应于具有恒定偏移量 $d = c-r$ 的矩阵项 $(r,c)$ 集合。我们需要找到 $d$ 的唯一值的数量，其中对于至少一对 $(r,c)$，$\\boldsymbol{K}_{rc} \\neq 0$。\n\n设节点 $r$ 的坐标为 $(i_r, j_r, k_r)$，节点 $c$ 的坐标为 $(i_c, j_c, k_c)$。条件 $\\boldsymbol{K}_{rc} \\neq 0$ 意味着在有限元网格连接性的意义上，节点 $c$ 必须是节点 $r$ 的邻居。对于一个内部节点 $(i_r, j_r, k_r)$（其中 $1 \\le i_r, j_r, k_r \\le n-2$，由于 $n \\ge 3$ 故其存在），它属于 8 个相邻的六面体单元。构成这 8 个单元的所有唯一节点的集合形成一个以 $(i_r, j_r, k_r)$ 为中心的 $3 \\times 3 \\times 3$ 的节点立方体。\n因此，节点 $c$ 的坐标必须是 $(i_r + \\Delta i, j_r + \\Delta j, k_r + \\Delta k)$，其中 $\\Delta i, \\Delta j, \\Delta k \\in \\{-1, 0, 1\\}$。\n对于 $(\\Delta i, \\Delta j, \\Delta k)$ 有 $3^3 = 27$ 种这样的组合，它们定义了 26 个邻居节点加上节点本身。\n\n偏移量 $d = c-r$ 可以用网格索引的差值表示：\n$$\nd = p(i_c, j_c, k_c) - p(i_r, j_r, k_r) \\\\\n= (i_c + n j_c + n^2 k_c) - (i_r + n j_r + n^2 k_r) \\\\\n= (i_c - i_r) + n(j_c - j_r) + n^2(k_c - k_r) \\\\\n= \\Delta i + n \\Delta j + n^2 \\Delta k\n$$\n我们必须确定 27 个可能的整数向量 $(\\Delta i, \\Delta j, \\Delta k)$ 是否每个都产生唯一的偏移量 $d$。假设两个不同的向量 $(\\Delta i_1, \\Delta j_1, \\Delta k_1)$ 和 $(\\Delta i_2, \\Delta j_2, \\Delta k_2)$ 产生相同的偏移量：\n$$\n\\Delta i_1 + n \\Delta j_1 + n^2 \\Delta k_1 = \\Delta i_2 + n \\Delta j_2 + n^2 \\Delta k_2 \\\\\n\\implies (\\Delta i_1 - \\Delta i_2) + n(\\Delta j_1 - \\Delta j_2) + n^2(\\Delta k_1 - \\Delta k_2) = 0\n$$\n令 $\\delta_i = \\Delta i_1 - \\Delta i_2$，$\\delta_j = \\Delta j_1 - \\Delta j_2$，以及 $\\delta_k = \\Delta k_1 - \\Delta k_2$。由于 $\\Delta i, \\Delta j, \\Delta k \\in \\{-1, 0, 1\\}$，这些差值必须在 $\\{-2, -1, 0, 1, 2\\}$ 集合中。方程为 $\\delta_i + n\\delta_j + n^2\\delta_k = 0$。\n这个方程可以看作是数字 $0$ 的 $n$ 进制表示。我们可以证明唯一的解是 $\\delta_i = \\delta_j = \\delta_k = 0$。\n从方程中，我们有 $n^2\\delta_k = -(\\delta_i + n\\delta_j)$。\n取绝对值：$n^2 |\\delta_k| = |\\delta_i + n\\delta_j| \\le |\\delta_i| + n|\\delta_j|$。\n由于 $|\\delta_i| \\le 2$ 和 $|\\delta_j| \\le 2$，我们有 $n^2 |\\delta_k| \\le 2 + n(2) = 2(n+1)$。\n$|\\delta_k| \\le \\frac{2(n+1)}{n^2}$。\n对于 $n \\ge 3$，我们有 $n^2 > 2n+2 = 2(n+1)$，这意味着 $\\frac{2(n+1)}{n^2}  1$。\n由于 $|\\delta_k|$ 必须是整数，唯一的可能性是 $|\\delta_k|=0$，所以 $\\delta_k=0$。\n方程简化为 $\\delta_i + n\\delta_j = 0$，或 $\\delta_i = -n\\delta_j$。\n考虑到 $|\\delta_i| \\le 2$ 和 $n \\ge 3$，这个等式只有在 $\\delta_j=0$ 时才能成立，而这又意味着 $\\delta_i=0$。\n因此，$\\delta_i = \\delta_j = \\delta_k = 0$，这意味着 $(\\Delta i_1, \\Delta j_1, \\Delta k_1) = (\\Delta i_2, \\Delta j_2, \\Delta k_2)$。\n这证明了 27 个结构邻居关系中的每一个都对应一个唯一的整数偏移量。由于当 $n \\ge 3$ 时存在内部节点，所有 27 种类型的连接都存在于矩阵 $\\boldsymbol{K}$ 中。因此，恰好有 27 条不同的对角线。\n\n### 第 2 部分：DIA 存储与 CSR 存储的比率\n设 $\\eta(n)$ 为总 DIA 存储量与总 CSR 存储量之比。我们同等计算值条目和索引条目。\n\n**DIA 存储量 ($S_{DIA}$):**\nDIA 格式将 27 条对角线中的每一条都存储为一个长度为 $N=n^3$ 的完整数组。这计为 $27 \\times N = 27n^3$ 个值条目。此外，它为每条对角线存储一个整数偏移量，即 27 个整数条目。\n$$S_{DIA} = 27n^3 + 27$$\n\n**CSR 存储量 ($S_{CSR}$):**\nCSR 格式使用三个数组：一个长度为 $nnz$ 的值数组，一个长度为 $nnz$ 的列索引数组，以及一个长度为 $N+1$ 的行指针数组。$nnz$ 是 $\\boldsymbol{K}$ 中非零项的总数。\n$$S_{CSR} = nnz (\\text{值}) + nnz (\\text{索引}) + (N+1) (\\text{指针}) = 2 \\cdot nnz + n^3 + 1$$\n为了找到 $nnz$，我们对所有行的非零项数量求和。一行中的非零项数量对应于与该行节点相连的节点数量（包括其自身）。这个数量取决于节点的位置。\n\n1.  **节点分类和计数：**\n    -   **角节点：** $8$ 个节点。一个角节点（例如 $(0,0,0)$）连接到一个 $2 \\times 2 \\times 2$ 块中的节点。连接数：$2^3 = 8$。\n    -   **边节点（非角点）：** $12(n-2)$ 个节点。一个边节点（例如 $(0,0,k)$，其中 $1 \\le k \\le n-2$）连接到一个 $2 \\times 2 \\times 3$ 块中的节点。连接数：$2 \\times 2 \\times 3 = 12$。\n    -   **面节点（非边节点）：** $6(n-2)^2$ 个节点。一个面节点（例如 $(0,j,k)$，其中 $1 \\le j,k \\le n-2$）连接到一个 $2 \\times 3 \\times 3$ 块中的节点。连接数：$2 \\times 3 \\times 3 = 18$。\n    -   **内部节点：** $(n-2)^3$ 个节点。一个内部节点连接到一个 $3 \\times 3 \\times 3$ 块中的节点。连接数：$3^3 = 27$。\n\n2.  **$nnz$ 的计算：**\n    将所有节点的连接数相加得到 $nnz$：\n    $$nnz = 8 \\times 8 + 12(n-2) \\times 12 + 6(n-2)^2 \\times 18 + (n-2)^3 \\times 27$$\n    $$nnz = 64 + 144(n-2) + 108(n-2)^2 + 27(n-2)^3$$\n    令 $x = n-2$。该表达式是关于 $x$ 的多项式：$27x^3 + 108x^2 + 144x + 64$。\n    这是 $(3x+4)^3$ 的二项式展开：\n    $$(3x+4)^3 = (3x)^3 + 3(3x)^2(4) + 3(3x)(4)^2 + 4^3 = 27x^3 + 108x^2 + 144x + 64$$\n    将 $x = n-2$ 代回：\n    $$nnz = (3(n-2) + 4)^3 = (3n - 6 + 4)^3 = (3n - 2)^3$$\n\n3.  **最终存储量计算和比率：**\n    现在我们可以写出 $S_{CSR}$ 的表达式：\n    $$S_{CSR} = 2(3n-2)^3 + n^3 + 1$$\n    展开立方项：\n    $$(3n-2)^3 = 27n^3 - 54n^2 + 36n - 8$$\n    $$S_{CSR} = 2(27n^3 - 54n^2 + 36n - 8) + n^3 + 1$$\n    $$S_{CSR} = 54n^3 - 108n^2 + 72n - 16 + n^3 + 1$$\n    $$S_{CSR} = 55n^3 - 108n^2 + 72n - 15$$\n    存储比率 $\\eta(n)$ 为：\n    $$\\eta(n) = \\frac{S_{DIA}}{S_{CSR}} = \\frac{27n^3 + 27}{55n^3 - 108n^2 + 72n - 15}$$\n    这可以写作：\n    $$\\eta(n) = \\frac{27(n^3 + 1)}{55n^3 - 108n^2 + 72n - 15}$$\n    这是该比率的最终闭式表达式。\n\n最终答案包括两部分：对角线的数量和存储比率表达式。\n1. 对角线数量：$27$。\n2. 存储比率 $\\eta(n)$: $\\frac{27(n^3 + 1)}{55n^3 - 108n^2 + 72n - 15}$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n27  \\frac{27(n^3 + 1)}{55n^3 - 108n^2 + 72n - 15}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "除了非零元的数量，其在矩阵中的分布模式（即矩阵的轮廓或带宽）也对求解器的性能至关重要。本练习将介绍一种关键的优化技术——节点重排序，以减小矩阵带宽。您将亲手实践逆Cuthill-McKee（RCM）算法，这是一种广泛应用于此目的的经典图论算法。通过在一个非结构网格上执行RCM重排序并量化其带来的带宽缩减，您将掌握有限元分析中一个能够显著提升求解效率的核心预处理步骤。",
            "id": "3601692",
            "problem": "考虑一个二维线性弹性模型，该模型在非结构化网格上使用线性三角形单元通过有限元法 (FEM) 进行离散化。假设每个网格节点有一个标量位移自由度 (DOF)，因此全局剛度矩陣是对称的，并且当且仅当节点 $i$ 和 $j$ 同时出现在至少一个单元中时，才存在非零的非对角元 $K_{ij}$。这就在节点上导出了通常的邻接图。基于轮廓的方案的计算成本由矩阵带宽决定，对于给定的节点排序 $p:\\{1,\\dots,N\\}\\to\\{1,\\dots,N\\}$，其定义为\n$$\nb \\;=\\; \\max\\{\\, |p(i)-p(j)| \\;:\\; (i,j)\\ \\text{is an adjacency edge}\\,\\}.\n$$\n给定一个具有 $N=12$ 个节点的非结构化三角形网格，其节点由当前排序 $p_{\\text{old}}(i)=i$ 标记，单元连接关系如下\n$$\n(1,2,5),\\ (1,4,5),\\ (2,3,6),\\ (2,5,6),\\ (4,5,8),\\ (4,7,8),\\ (5,6,9),\\ (5,8,9),\\ (7,8,11),\\ (7,10,11),\\ (8,9,12),\\ (8,11,12).\n$$\n根据有限元法组装和图论的基本原理，构建由此连接关系所蕴含的邻接图。然后执行一轮 Reverse Cuthill-McKee (RCM) 重新排序以获得新的节点排序 $p_{\\text{new}}$，过程如下：\n- 选择度数最小的节点作为起始节点；如果度数相同，则选择标签最小的节点。\n- 执行广度优先搜索 (BFS)，在访问一个节点时，将其未访问过的邻居节点按度数非递减排序后入队；如果度数相同，则按标签递增排序。\n- Cuthill-McKee 排序是 BFS 的访问顺序；Reverse Cuthill-McKee 排序将该序列反转以产生 $p_{\\text{new}}$。\n\n计算原始排序 $p_{\\text{old}}$ 下的原始带宽 $b_{\\text{old}}$，新排序 $p_{\\text{new}}$ 下的新带宽 $b_{\\text{new}}$，以及带宽缩减率\n$$\nr \\;=\\; \\frac{b_{\\text{old}} - b_{\\text{new}}}{b_{\\text{old}}}.\n$$\n将最终比率 $r$ 表示为一个无单位的精确分数。",
            "solution": "该问题定义明确，在计算力学和数值线性代数领域具有坚实的科学基础。我们将进行完整解答。问题要求我们分析一个由有限元法 (FEM) 离散化产生的稀疏矩阵的带宽，使用 Reverse Cuthill-McKee (RCM) 算法执行带宽缩减重排序，并计算最终的改进效果。\n\n过程结构如下：\n1.  根据给定的单元连接关系构建邻接图，并确定每个节点的度数。\n2.  计算原始节点排序 $p_{\\text{old}}(i)=i$ 下的带宽 $b_{\\text{old}}$。\n3.  执行 RCM 算法以获得新的节点排序 $p_{\\text{new}}$。\n4.  计算新排序下的带宽 $b_{\\text{new}}$。\n5.  计算带宽缩减率 $r$。\n\n**1. 邻接图的构建与节点度数**\n\n全局刚度矩阵 $K$ 具有非零非对角元 $K_{ij}$ 当且仅当节点 $i$ 和 $j$ 共享至少一个单元。这就定义了邻接图的边。我们从给定的单元连接关系列表中推导出这些边：\n$(1,2,5), (1,4,5), (2,3,6), (2,5,6), (4,5,8), (4,7,8), (5,6,9), (5,8,9), (7,8,11), (7,10,11), (8,9,12), (8,11,12)$。\n\n从这 12 个单元中，我们整理出唯一的边，为全部 $N=12$ 个节点构建邻接表。一个节点 $i$ 的度数，记为 $\\text{deg}(i)$，是与其相邻的节点数量。\n\n-   节点 $1$：邻居 $\\{2, 4, 5\\}$。$\\text{deg}(1) = 3$。\n-   节点 $2$：邻居 $\\{1, 3, 5, 6\\}$。$\\text{deg}(2) = 4$。\n-   节点 $3$：邻居 $\\{2, 6\\}$。$\\text{deg}(3) = 2$。\n-   节点 $4$：邻居 $\\{1, 5, 7, 8\\}$。$\\text{deg}(4) = 4$。\n-   节点 $5$：邻居 $\\{1, 2, 4, 6, 8, 9\\}$。$\\text{deg}(5) = 6$。\n-   节点 $6$：邻居 $\\{2, 3, 5, 9\\}$。$\\text{deg}(6) = 4$。\n-   节点 $7$：邻居 $\\{4, 8, 10, 11\\}$。$\\text{deg}(7) = 4$。\n-   节点 $8$：邻居 $\\{4, 5, 7, 9, 11, 12\\}$。$\\text{deg}(8) = 6$。\n-   节点 $9$：邻居 $\\{5, 6, 8, 12\\}$。$\\text{deg}(9) = 4$。\n-   节点 $10$：邻居 $\\{7, 11\\}$。$\\text{deg}(10) = 2$。\n-   节点 $11$：邻居 $\\{7, 8, 10, 12\\}$。$\\text{deg}(11) = 4$。\n-   节点 $12$：邻居 $\\{8, 9, 11\\}$。$\\text{deg}(12) = 3$。\n\n**2. 原始带宽 $b_{\\text{old}}$**\n\n初始排序是单位排列，$p_{\\text{old}}(i) = i$，$i \\in \\{1, \\dots, 12\\}$。带宽 $b_{\\text{old}}$ 是图中所有边 $(i,j)$ 上 $|p_{\\text{old}}(i) - p_{\\text{old}}(j)| = |i-j|$ 的最大差值。我们检查所有边以找到这个最大值。\n\n例如，对于节点 $8$，其邻居是 $\\{4, 5, 7, 9, 11, 12\\}$。标签的差值为：\n$|8-4|=4$, $|8-5|=3$, $|8-7|=1$, $|8-9|=1$, $|8-11|=3$, $|8-12|=4$。\n节点 $8$ 的最大差值为 $4$。\n通过检查所有边，我们发现有几个实例产生了这个差值，例如边 $(1,5)$ 的 $|1-5|=4$，边 $(2,6)$ 的 $|2-6|=4$，边 $(7,11)$ 的 $|7-11|=4$，以及边 $(8,12)$ 的 $|8-12|=4$。不存在任何边 $(i,j)$ 使得 $|i-j| > 4$。\n因此，原始带宽为 $b_{\\text{old}} = 4$。\n\n**3. Reverse Cuthill-McKee (RCM) 重排序**\n\nRCM 算法按规定执行。\n\n**a. 起始节点选择：**\n我们寻找度数最小的节点。最小度数为 $2$，由节点 $3$ 和 $10$ 共享。根据平局决胜规则，我们选择标签最小的那个。因此，起始节点是 $3$。\n\n**b. 广度优先搜索 (BFS)：**\n我们用起始节点 $3$ 初始化一个队列 $Q$。设 $R$ 为存储 Cuthill-McKee (CM) 排序的列表。\n1.  $Q=[3]$。将 $3$ 出队，$R=(3)$。$3$ 的邻居是 $\\{2,6\\}$。两者度数均为 $4$。按标签平局决胜，我们将它们排序为 $(2,6)$。将 $2$ 入队，然后 $6$ 入队。$Q=[2,6]$。\n2.  $Q=[2,6]$。将 $2$ 出队，$R=(3,2)$。$2$ 的未访问邻居是 $\\{1,5\\}$。$\\text{deg}(1)=3$，$\\text{deg}(5)=6$。按度数排序：$(1,5)$。将 $1$ 入队，然后 $5$ 入队。$Q=[6,1,5]$。\n3.  $Q=[6,1,5]$。将 $6$ 出队，$R=(3,2,6)$。$6$ 的未访问邻居是 $\\{9\\}$。$\\text{deg}(9)=4$。将 $9$ 入队。$Q=[1,5,9]$。\n4.  $Q=[1,5,9]$。将 $1$ 出队，$R=(3,2,6,1)$。$1$ 的未访问邻居是 $\\{4\\}$。$\\text{deg}(4)=4$。将 $4$ 入队。$Q=[5,9,4]$。\n5.  $Q=[5,9,4]$。将 $5$ 出队，$R=(3,2,6,1,5)$。$5$ 的未访问邻居是 $\\{8\\}$。$\\text{deg}(8)=6$。将 $8$ 入队。$Q=[9,4,8]$。\n6.  $Q=[9,4,8]$。将 $9$ 出队，$R=(3,2,6,1,5,9)$。$9$ 的未访问邻居是 $\\{12\\}$。$\\text{deg}(12)=3$。将 $12$ 入队。$Q=[4,8,12]$。\n7.  $Q=[4,8,12]$。将 $4$ 出队，$R=(3,2,6,1,5,9,4)$。$4$ 的未访问邻居是 $\\{7\\}$。$\\text{deg}(7)=4$。将 $7$ 入队。$Q=[8,12,7]$。\n8.  $Q=[8,12,7]$。将 $8$ 出队，$R=(3,2,6,1,5,9,4,8)$。$8$ 的未访问邻居是 $\\{11\\}$。$\\text{deg}(11)=4$。将 $11$ 入队。$Q=[12,7,11]$。\n9.  $Q=[12,7,11]$。将 $12$ 出队，$R=(3,2,6,1,5,9,4,8,12)$。节点 $12$ 没有未访问的邻居。$Q=[7,11]$。\n10. $Q=[7,11]$。将 $7$ 出队，$R=(3,2,6,1,5,9,4,8,12,7)$。$7$ 的未访问邻居是 $\\{10\\}$。$\\text{deg}(10)=2$。将 $10$ 入队。$Q=[11,10]$。\n11. $Q=[11,10]$。将 $11$ 出队，$R=(3,2,6,1,5,9,4,8,12,7,11)$。节点 $11$ 没有未访问的邻居。$Q=[10]$。\n12. $Q=[10]$。将 $10$ 出队，$R=(3,2,6,1,5,9,4,8,12,7,11,10)$。节点 $10$ 没有未访问的邻居。$Q=[]$。\n\nCM 排序为 $R = (3, 2, 6, 1, 5, 9, 4, 8, 12, 7, 11, 10)$。\n\n**c. 新排序 $p_{\\text{new}}$：**\nRCM 排序是 CM 排序的反转。这定义了新的排列 $p_{\\text{new}}$，它将原始节点标签映射到从 $1$ 到 $12$ 的新位置。\nRCM 顺序：$(10, 11, 7, 12, 8, 4, 9, 5, 1, 6, 2, 3)$。\n映射 $p_{\\text{new}}$ 为：\n$p_{\\text{new}}(10)=1$, $p_{\\text{new}}(11)=2$, $p_{\\text{new}}(7)=3$, $p_{\\text{new}}(12)=4$, $p_{\\text{new}}(8)=5$, $p_{\\text{new}}(4)=6$, $p_{\\text{new}}(9)=7$, $p_{\\text{new}}(5)=8$, $p_{\\text{new}}(1)=9$, $p_{\\text{new}}(6)=10$, $p_{\\text{new}}(2)=11$, $p_{\\text{new}}(3)=12$。\n\n**4. 新带宽 $b_{\\text{new}}$**\n\n我们计算新带宽 $b_{\\text{new}} = \\max \\{ |p_{\\text{new}}(i) - p_{\\text{new}}(j)| \\}$，遍历所有边 $(i,j)$。\n我们来检查一些可能产生较大差值的边：\n-   边 $(1,4)$: $|p_{\\text{new}}(1) - p_{\\text{new}}(4)| = |9 - 6| = 3$。\n-   边 $(2,5)$: $|p_{\\text{new}}(2) - p_{\\text{new}}(5)| = |11 - 8| = 3$。\n-   边 $(4,7)$: $|p_{\\text{new}}(4) - p_{\\text{new}}(7)| = |6 - 3| = 3$。\n-   边 $(5,8)$: $|p_{\\text{new}}(5) - p_{\\text{new}}(8)| = |8 - 5| = 3$。\n-   边 $(6,9)$: $|p_{\\text{new}}(6) - p_{\\text{new}}(9)| = |10 - 7| = 3$。\n-   边 $(8,11)$: $|p_{\\text{new}}(8) - p_{\\text{new}}(11)| = |5 - 2| = 3$。\n-   边 $(9,12)$: $|p_{\\text{new}}(9) - p_{\\text{new}}(12)| = |7 - 4| = 3$。\n\n对所有 $23$ 条边的彻底检查证实，任何相连节点对在新标签下的最大差值为 $3$。\n因此，新带宽为 $b_{\\text{new}} = 3$。\n\n**5. 带宽缩减率 $r$**\n\n带宽缩减率 $r$ 定义为：\n$$\nr = \\frac{b_{\\text{old}} - b_{\\text{new}}}{b_{\\text{old}}}\n$$\n代入计算出的值：\n$$\nr = \\frac{4 - 3}{4} = \\frac{1}{4}\n$$\nRCM 重排序实现了 $25\\%$ 的带宽缩减。",
            "answer": "$$\\boxed{\\frac{1}{4}}$$"
        },
        {
            "introduction": "随着模型规模的增长，并行计算对于在合理时间内获得有限元分析结果变得不可或缺。然而，直接并行化标准的有限元组装过程会导致“竞争条件”，破坏计算的正确性。本项高级练习将探讨一种优雅的解决方案——单元着色，它通过将单元划分为互不冲突的组来实现无竞争的并行组装。通过形式化地设计并验证一个基于着色的并行组装算法，您将深入理解构建高性能、可扩展有限元软件的核心设计原则。",
            "id": "3601704",
            "problem": "考虑计算固体力学中一个线性椭圆边值问题的有限元法 (FEM) 离散化。离散的全局线性系统写作 $K u = f$，其中 $K \\in \\mathbb{R}^{n \\times n}$ 是全局刚度矩阵，$u \\in \\mathbb{R}^{n}$ 是全局位移向量，$f \\in \\mathbb{R}^{n}$ 是全局力向量。标准的单元组装公式为 $K \\leftarrow K + P_e^\\top K_e P_e$，其中 $K_e \\in \\mathbb{R}^{n_e \\times n_e}$ 是单元 $e$ 的单元刚度矩阵，$P_e$ 是将局部单元自由度 (DOF) 映射到全局自由度索引的布尔散布矩阵。压缩稀疏行 (CSR) 存储格式通过三个数组来表示一个稀疏矩阵：行指针数组 $indptr$、列索引数组 $indices$ 和数值数组 $data$。无竞争的并行组装要求任意两个并发线程都不会写入 $data$ 中的同一内存位置。\n\n设计并实现一个无竞争的并行 FEM 组装算法，该算法：\n- 从单元自由度邻接关系的并集中预先计算全局 CSR 稀疏结构，为每对全局自由度 $(i,j)$ 创建一个到 $data$ 中单个位置的唯一映射。\n- 使用单元着色（或等效地，使用确保每组自由度集不相交的图划分）来调度单元组装，使得同一颜色组中的单元不共享任何全局自由度。在同一颜色组内，单元可以无竞争地并行组装。\n- 从第一性原理出发，证明最终的 CSR 表示在任何行中都没有重复的列索引，并证明当所有单元矩阵 $K_e$ 都对称时，组装出的全局矩阵 $K$ 也是对称的。\n\n您必须从 FEM 组装、自由度邻接关系和矩阵对称性的基本定义出发。避免使用简便公式。组装过程必须以纯粹的数学和逻辑术语表达。不需要物理单位；所有输出均为布尔值。\n\n您的程序必须实现该算法，并为每个测试用例验证以下属性：\n1. 无竞争着色有效性：一个布尔值，指示所提供的着色是否为一种合适的单元着色，其中相同颜色的任意两个单元都不共享自由度。\n2. CSR无重复项：一个布尔值，指示所构建的 CSR 结构在任何行内是否都没有重复的列索引。\n3. 对称性保持：一个布尔值，指示组装后的全局矩阵 $K$ 是否对称，通过在 $10^{-12}$ 的数值容差内验证所有存储的条目是否满足 $K_{ij} = K_{ji}$ 来进行测试。\n\n测试套件：\n- 案例 1 (正常路径)：一个一维链，包含 $n = 5$ 个全局自由度和 4 个双节点单元，局部自由度列表为 $[0,1]$、$[1,2]$、$[2,3]$、$[3,4]$。每个单元都有一个对称的局部刚度矩阵 $K_e = \\begin{bmatrix}1  -1 \\\\ -1  1\\end{bmatrix}$。使用有效的着色 $[0,1,0,1]$。\n- 案例 2 (不连通分量)：两个不相交的一维链，包含 $n = 8$ 个全局自由度和 6 个双节点单元，局部自由度列表为 $[0,1]$、$[1,2]$、$[2,3]$、$[4,5]$、$[5,6]$、$[6,7]$。每个单元都有一个对称的局部刚度矩阵 $K_e = \\begin{bmatrix}2  -2 \\\\ -2  2\\end{bmatrix}$。使用有效的着色 $[0,1,0,0,1,0]$。\n- 案例 3 (无效着色)：与案例 1 相同的网格和对称的局部刚度矩阵，但使用无效的着色 $[0,0,0,0]$，其中相邻单元在同一颜色中共享自由度。\n- 案例 4 (对称性边界情况)：与案例 1 相同的网格，但第二个单元的单元矩阵非对称，例如 $K_e^{(2)} = \\begin{bmatrix}1  0 \\\\ -1  1\\end{bmatrix}$，而其他单元的矩阵为 $K_e = \\begin{bmatrix}1  -1 \\\\ -1  1\\end{bmatrix}$。使用有效的着色 $[0,1,0,1]$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例的结果必须是按顺序排列的三个布尔值的列表：$[$race\\_free, csr\\_no\\_duplicates, is\\_symmetric$]$。例如，输出应在一行上显示为 $[[\\text{True},\\text{True},\\text{True}],\\ldots]$。",
            "solution": "该问题要求在有限元法 (FEM) 的背景下，设计、实现并形式化论证一种用于全局刚度矩阵 $K$ 的无竞争并行组装算法。该解决方案必须针对特定属性进行验证：并行化方案的有效性（单元着色）、稀疏矩阵格式的结构完整性（无重复条目）以及矩阵对称性的保持。\n\n### 形式化与算法设计\n\n全局刚度矩阵 $K$ 的组装定义为映射到全局自由度 (DOF) 的单元刚度矩阵 $K_e$ 的总和：\n$$ K = \\sum_{e} P_e^\\top K_e P_e $$\n其中 $P_e$ 是单元 $e$ 的散布算子。一种直接、朴素的并行化方法是让多个线程同时组装不同的单元，但这可能导致竞争条件，因为两个单元可能共享一个全局自由度，从而试图同时写入同一个条目 $K_{ij}$。一个健壮的并行算法通过仔细调度组装过程来避免此问题。\n\n#### 步骤 1：稀疏模式预计算与 CSR 结构\n\n第一步是在进行任何数值组装之前确定 $K$ 的稀疏模式。仅当全局自由度 $i$ 和 $j$ 属于同一个单元时，条目 $K_{ij}$ 才为非零。设 $\\mathcal{D}_e$ 为单元 $e$ 的全局自由度索引集合。矩阵 $K$ 中所有非零位置 $(i, j)$ 的集合都包含在结构邻接集 $S$ 中：\n$$ S = \\bigcup_{e} \\{ (i, j) \\mid i \\in \\mathcal{D}_e, j \\in \\mathcal{D}_e \\} $$\n这个集合 $S$ 定义了完整的稀疏模式。由此，我们可以构建压缩稀疏行 (CSR) 表示，它由三个数组组成：`indptr`、`indices` 和 `data`。\n\n1.  对于每个全局行 $i$（从 $0$ 到 $n-1$），我们确定该行中所有非零条目的列索引集合 $C_i$：\n    $$ C_i = \\{ j \\mid (i, j) \\in S \\} = \\{ j \\mid \\exists e \\text{ such that } i \\in \\mathcal{D}_e \\text{ and } j \\in \\mathcal{D}_e \\} $$\n\n2.  `indices` 数组是每行已排序的列索引列表的串联。设 $C_i^{\\text{sorted}}$ 为 $C_i$ 中元素按升序排列的列表。`indices` 数组为 $[\\, C_0^{\\text{sorted}}, C_1^{\\text{sorted}}, \\dots, C_{n-1}^{\\text{sorted}} \\,]$。\n\n3.  `indptr` 数组存储指向 `indices` 和 `data` 数组中每行数据起始位置的指针。其定义如下：\n    $$ \\text{indptr}[0] = 0 $$\n    $$ \\text{indptr}[i+1] = \\text{indptr}[i] + |C_i| \\quad \\text{for } i = 0, \\dots, n-1 $$\n    非零条目的总数为 $\\text{nnz} = \\text{indptr}[n]$。\n\n4.  用于存储数值的 `data` 数组被初始化为一个长度为 $\\text{nnz}$ 的零向量。稀疏模式中的每一对 $(i, j)$ 都与 `data` 数组中的一个特定索引建立唯一映射。该映射通过在行 $i$ 的已排序的列索引中定位 $j$ 的位置来找到。\n\n#### 步骤 2：证明 CSR 行中无重复列索引\n\n问题要求证明所构建的 CSR 表示在任何行中都没有重复的列索引。\n\n**证明：**\n根据构造方法，对于每一行 $i$，我们首先形成集合 $C_i = \\{ j \\mid (i, j) \\in S \\}$。数学集合的一个基本性质是它不能包含重复元素。当我们从集合 $C_i$ 创建行 $i$ 的列索引列表时，我们是从一个唯一索引的集合中提取元素。因此，生成的列表 $C_i^{\\text{sorted}}$ 不包含重复项。由于 `indices` 数组中对应于行 $i$ 的分段，即 $\\text{indices}[\\text{indptr}[i]:\\text{indptr}[i+1]]$，恰好是 $C_i^{\\text{sorted}}$，因此可以保证它不含重复的列索引。这对所有行 $i = 0, \\dots, n-1$ 都成立。\n\n#### 步骤 3：用于无竞争并行化的单元着色\n\n为了实现无竞争的并行组装，我们将单元集合划分为不同的颜色组。问题将有效着色定义为：任何属于同一颜色组的两个单元都不共享任何全局自由度。形式上，设 $\\mathcal{E}$ 为所有单元的集合，$c(e)$ 为单元 $e$ 的颜色。当且仅当对于任何两个不同的单元 $e_1, e_2 \\in \\mathcal{E}$，该着色是有效的：\n$$ c(e_1) = c(e_2) \\implies \\mathcal{D}_{e_1} \\cap \\mathcal{D}_{e_2} = \\emptyset $$\n组装算法通过遍历颜色来进行。对于每种颜色，该颜色的所有单元都可以并行组装。\n\n**无竞争执行的论证：**\n考虑两个线程 $T_1$ 和 $T_2$，它们并发地组装两个具有相同颜色的不同单元 $e_1$ 和 $e_2$。线程 $T_1$ 会将 $K_{e_1}$ 的贡献加到条目 $K_{ij}$ 上，其中 $i, j \\in \\mathcal{D}_{e_1}$。线程 $T_2$ 会将 $K_{e_2}$ 的贡献加到条目 $K_{kl}$ 上，其中 $k, l \\in \\mathcal{D}_{e_2}$。由于着色是有效的，我们知道 $\\mathcal{D}_{e_1} \\cap \\mathcal{D}_{e_2} = \\emptyset$。这意味着 $T_1$ 访问的全局行（和列）索引集合 $\\mathcal{D}_{e_1}$ 与 $T_2$ 访问的索引集合 $\\mathcal{D}_{e_2}$ 是完全不相交的。因此，这些线程将写入全局 `data` 数组中不相交的条目集合，不会发生竞争条件。这一点由 `race_free` 布尔值验证。\n\n#### 步骤 4：对称性保持的证明\n\n问题要求证明如果所有单元刚度矩阵 $K_e$ 都是对称的，那么最终组装的全局矩阵 $K$ 也将是对称的。\n\n**证明：**\n1.  **假设：** 所有单元刚度矩阵都是对称的，即对于每个单元 $e$ 都有 $K_e = K_e^\\top$。\n\n2.  **全局矩阵定义：** 全局刚度矩阵是单元贡献的总和：$K = \\sum_e K^{(e)}$，其中 $K^{(e)} = P_e^\\top K_e P_e$。\n\n3.  **全局矩阵的转置：** 为了检查对称性，我们计算 $K$ 的转置：\n    $$ K^\\top = \\left( \\sum_e P_e^\\top K_e P_e \\right)^\\top $$\n    和的转置等于转置的和：\n    $$ K^\\top = \\sum_e (P_e^\\top K_e P_e)^\\top $$\n\n4.  **单元贡献的转置：** 我们对单元贡献项使用属性 $(ABC)^\\top = C^\\top B^\\top A^\\top$：\n    $$ (P_e^\\top K_e P_e)^\\top = (P_e)^\\top (K_e)^\\top (P_e^\\top)^\\top $$\n    转置的转置是原矩阵，所以 $(P_e^\\top)^\\top = P_e$。这得到：\n    $$ (P_e^\\top K_e P_e)^\\top = P_e^\\top K_e^\\top P_e $$\n\n5.  **应用对称性假设：** 我们假设 $K_e$ 是对称的，所以 $K_e^\\top = K_e$。将此代入步骤 4 的方程中：\n    $$ (P_e^\\top K_e P_e)^\\top = P_e^\\top K_e P_e $$\n    这表明每个单元的贡献在映射到全局系统后，其本身也是一个对称矩阵：$(K^{(e)})^\\top = K^{(e)}$。\n\n6.  **结论：** 全局矩阵 $K$ 是对称矩阵 ($K^{(e)}$) 的和。对称矩阵的和总是一个对称矩阵。因此：\n    $$ K^\\top = \\sum_e (K^{(e)})^\\top = \\sum_e K^{(e)} = K $$\n    这证明了如果所有 $K_e$ 都是对称的，那么组装的全局矩阵 $K$ 也是对称的。该属性由 `is_symmetric` 布尔值验证。\n\n下面的 Python 实现封装了这一逻辑，以对所提供的测试套件执行所需的验证。",
            "answer": "```python\nimport numpy as np\nfrom itertools import combinations\n\ndef evaluate_assembly_properties(n_dofs, elements, element_kes, coloring):\n    \"\"\"\n    Implements and verifies the properties of a race-free parallel FEM assembly algorithm.\n\n    Args:\n        n_dofs (int): Number of global degrees of freedom.\n        elements (list of list of int): List of element DOF connectivities.\n        element_kes (list of np.ndarray): List of local element stiffness matrices.\n        coloring (list of int): Element coloring for parallel scheduling.\n\n    Returns:\n        list of bool: A list containing three booleans:\n                      [race_free_coloring, csr_no_duplicates, is_symmetric]\n    \"\"\"\n    # 1. Verify race-free coloring validity\n    race_free_coloring = True\n    max_color = max(coloring) if coloring else -1\n    color_groups = [[] for _ in range(max_color + 1)]\n    for i, color in enumerate(coloring):\n        color_groups[color].append(i)\n\n    for group in color_groups:\n        if not race_free_coloring:\n            break\n        for e1_idx, e2_idx in combinations(group, 2):\n            dofs1 = set(elements[e1_idx])\n            dofs2 = set(elements[e2_idx])\n            if not dofs1.isdisjoint(dofs2):\n                race_free_coloring = False\n                break\n    \n    # 2. Precompute CSR sparsity structure\n    adj = [set() for _ in range(n_dofs)]\n    for dof_list in elements:\n        for i in dof_list:\n            for j in dof_list:\n                adj[i].add(j)\n\n    indptr = np.zeros(n_dofs + 1, dtype=int)\n    indices_list = []\n    for i in range(n_dofs):\n        sorted_cols = sorted(list(adj[i]))\n        indices_list.extend(sorted_cols)\n        indptr[i+1] = indptr[i] + len(sorted_cols)\n\n    indices = np.array(indices_list, dtype=int)\n    nnz = indptr[n_dofs]\n    data = np.zeros(nnz, dtype=float)\n\n    # 3. Verify absence of duplicate column indices in CSR\n    csr_no_duplicates = True\n    for i in range(n_dofs):\n        row_slice = indices[indptr[i]:indptr[i+1]]\n        if len(row_slice) != len(set(row_slice)):\n            csr_no_duplicates = False\n            break\n\n    # 4. Assemble the global stiffness matrix\n    # Create a map from (row, col) to data index for efficient assembly\n    ij_to_data_idx = {}\n    for i in range(n_dofs):\n        for k, j in enumerate(indices[indptr[i]:indptr[i+1]]):\n            ij_to_data_idx[(i, j)] = indptr[i] + k\n\n    for e_idx, dofs in enumerate(elements):\n        ke = element_kes[e_idx]\n        for i_local, i_global in enumerate(dofs):\n            for j_local, j_global in enumerate(dofs):\n                data_idx = ij_to_data_idx.get((i_global, j_global))\n                if data_idx is not None:\n                    data[data_idx] += ke[i_local, j_local]\n\n    # 5. Verify symmetry of the assembled matrix\n    is_symmetric = True\n    tolerance = 1e-12\n    for i in range(n_dofs):\n        if not is_symmetric:\n            break\n        for k in range(indptr[i], indptr[i+1]):\n            j = indices[k]\n            val_ij = data[k]\n            \n            # Find the corresponding (j, i) entry\n            data_idx_ji = ij_to_data_idx.get((j, i))\n            \n            # The sparsity pattern must be symmetric for the matrix to be symmetric\n            if data_idx_ji is None:\n                # If val_ij is non-zero, this is an asymmetry\n                if abs(val_ij) > tolerance:\n                    is_symmetric = False\n                    break\n                else: # val_ij is zero, so K_ji can be implicitly zero\n                    val_ji = 0.0\n            else:\n                 val_ji = data[data_idx_ji]\n\n            if abs(val_ij - val_ji) > tolerance:\n                is_symmetric = False\n                break\n                \n    return [race_free_coloring, csr_no_duplicates, is_symmetric]\n\n\ndef solve():\n    \"\"\"\n    Defines test cases and runs the verification algorithm, printing the results.\n    \"\"\"\n    \n    # Case 1: Happy path\n    ke1 = np.array([[1., -1.], [-1., 1.]])\n    case1 = {\n        \"n_dofs\": 5,\n        \"elements\": [[0, 1], [1, 2], [2, 3], [3, 4]],\n        \"element_kes\": [ke1] * 4,\n        \"coloring\": [0, 1, 0, 1]\n    }\n\n    # Case 2: Disconnected components\n    ke2 = np.array([[2., -2.], [-2., 2.]])\n    case2 = {\n        \"n_dofs\": 8,\n        \"elements\": [[0,1], [1,2], [2,3], [4,5], [5,6], [6,7]],\n        \"element_kes\": [ke2] * 6,\n        \"coloring\": [0, 1, 0, 0, 1, 0]\n    }\n\n    # Case 3: Invalid coloring\n    case3 = {\n        \"n_dofs\": 5,\n        \"elements\": [[0, 1], [1, 2], [2, 3], [3, 4]],\n        \"element_kes\": [ke1] * 4,\n        \"coloring\": [0, 0, 0, 0]\n    }\n\n    # Case 4: Symmetry edge case\n    ke4_nonsym = np.array([[1., 0.], [-1., 1.]])\n    case4 = {\n        \"n_dofs\": 5,\n        \"elements\": [[0, 1], [1, 2], [2, 3], [3, 4]],\n        \"element_kes\": [ke1, ke4_nonsym, ke1, ke1],\n        \"coloring\": [0, 1, 0, 1]\n    }\n\n    test_cases = [case1, case2, case3, case4]\n    \n    results = []\n    for case in test_cases:\n        result = evaluate_assembly_properties(**case)\n        results.append(result)\n\n    # Format the output as a string representation of a list of lists.\n    # Ex: [[True,True,True],[True,True,True],[False,True,True],[True,True,False]]\n    result_str = \",\".join([f\"[{','.join(map(str, r))}]\" for r in results])\n    print(f\"[{result_str.replace('t', 'T').replace('f', 'F')}]\")\n\nsolve()\n```"
        }
    ]
}