{
    "hands_on_practices": [
        {
            "introduction": "张量链 (TT) 分解的效率在很大程度上取决于其TT秩。一个重要的、但有时违反直觉的事实是，这些秩对张量的模式（或维度）顺序非常敏感。本练习  将指导您从理论上证明模式重排如何影响TT秩，并设计一种实用的启发式算法来寻找一个近似最优的模式顺序，从而显著降低存储和计算成本。",
            "id": "3583892",
            "problem": "设 $d \\in \\mathbb{N}$，并设 $X \\in \\mathbb{R}^{n_1 \\times n_2 \\times \\cdots \\times n_d}$ 为一个实数 $d$ 阶张量。考虑一个作用于 $d$ 个模式的置换 $\\pi \\in S_d$，并令 $X^\\pi$ 表示根据 $\\pi$ 重新排序其轴后的置换张量。$X$ 的张量列（Tensor-Train, TT）分解由一系列核（core）定义，其最小 TT 秩 $\\{r_k\\}_{k=1}^{d-1}$ 等于 $X$ 在连续模式切割下的矩阵展开的秩。具体来说，对于每个 $k \\in \\{1,\\ldots,d-1\\}$，定义一个展开，将前 $k$ 个模式与其余 $d-k$ 个模式分组，并注意 TT 秩 $r_k$ 等于该展开的矩阵秩。本问题要求您从数值线性代数和多线性代数的基本定义出发，确定模式置换对 TT 秩的影响，并设计和评估一种计算启发式方法，以选择一个使最大 TT 秩最小化的模式置换。\n\n您的任务是：\n1. 使用矩阵秩和矩阵化（展开）的定义，证明对于任何置换 $\\pi \\in S_d$，$X^\\pi$ 的 TT 秩满足\n$$\nr_k^\\pi \\;=\\; \\mathrm{rank}\\!\\left(\\mathrm{unfold}_{\\{\\pi(1),\\ldots,\\pi(k)\\}|\\{\\pi(k+1),\\ldots,\\pi(d)\\}}(X)\\right), \\quad k=1,\\ldots,d-1,\n$$\n其中 $\\mathrm{unfold}_{S|\\bar S}(X)$ 表示通过将 $S$ 中的模式分组为行、$\\bar S$ 中的模式分组为列，并保留由 $\\pi$ 导出的顺序而获得的矩阵。您的推导必须仅依赖于张量矩阵化和矩阵秩的基本定义，以及诸如代数秩在行和列置换下的不变性以及最小 TT 秩由展开的秩表征等经过验证的事实。\n\n2. 设计一种启发式方法来选择一个置换 $\\pi$，以试图最小化 $\\max_{k \\in \\{1,\\ldots,d-1\\}} r_k^\\pi$。该启发式方法必须仅能从 $X$ 的数据中计算得出，并应从第一性原理进行论证。您的启发式方法必须避免使用任何目标公式作为捷径，并应阐明所选策略为何倾向于降低最大 TT 秩的理由。\n\n3. 在一个完整的、可运行的程序中实现以下内容：\n   - 一个函数，用于通过形成适当的矩阵展开并计算其在 $\\mathbb{R}$ 上的秩，来计算给定张量 $X$ 和置换 $\\pi$ 的 TT 秩列表 $\\{r_k^\\pi\\}_{k=1}^{d-1}$。\n   - 对所有置换 $\\pi \\in S_d$ 进行穷举搜索，以找到所提供的小型测试张量的 $\\max_k r_k^\\pi$ 的最优最小值；这将为每个测试用例建立基准真相（ground truth）。\n   - 您的启发式方法，用于选择一个置换 $\\pi_{\\mathrm{heur}}$，并为每个测试用例计算 $\\max_k r_k^{\\pi_{\\mathrm{heur}}}$。\n   - 对于每个测试用例，输出一个布尔值，指示启发式方法是否达到了最优的最小最大 TT 秩（即 $\\max_k r_k^{\\pi_{\\mathrm{heur}}}$ 是否等于 $\\min_{\\pi \\in S_d} \\max_k r_k^\\pi$）。\n\n您必须使用以下在 $\\mathbb{R}$ 上的张量测试套件，其元素有精确定义：\n- 测试用例 1（通用稠密，$d=5$）：$X \\in \\mathbb{R}^{2 \\times 3 \\times 2 \\times 3 \\times 2}$，其元素 $X[i_1,i_2,i_3,i_4,i_5]$ 从具有固定种子的伪随机数生成器中确定性地抽取，确保在维度限制下具有通用的满秩。\n- 测试用例 2（克罗内克结构，$d=4$）：$X \\in \\mathbb{R}^{3 \\times 2 \\times 3 \\times 2}$ 定义为 $X[i,j,k,\\ell] = M[i,k] \\cdot N[j,\\ell]$，其中 $M \\in \\mathbb{R}^{3 \\times 3}$ 是秩为 1 的矩阵（构造为 $M = u v^\\top$，其中 $u \\in \\mathbb{R}^3, v \\in \\mathbb{R}^3$ 为非零向量），而 $N \\in \\mathbb{R}^{2 \\times 2}$ 是满秩矩阵（例如，单位矩阵）。\n- 测试用例 3（秩-1 可分，$d=6$）：$X \\in \\mathbb{R}^{2 \\times 2 \\times 2 \\times 2 \\times 2 \\times 2}$ 定义为 $X = g^{(1)} \\otimes g^{(2)} \\otimes g^{(3)} \\otimes g^{(4)} \\otimes g^{(5)} \\otimes g^{(6)}$，其中 $g^{(m)} \\in \\mathbb{R}^{2}$ 为非零向量，$m=1,\\ldots,6$。\n- 测试用例 4（结构化正则多项式和，$d=4$）：$X \\in \\mathbb{R}^{3 \\times 3 \\times 2 \\times 2}$ 定义为 $X = a \\otimes b \\otimes c \\otimes d \\;+\\; a \\otimes b \\otimes c' \\otimes d'$，其中 $a \\in \\mathbb{R}^3, b \\in \\mathbb{R}^3$ 在两项中固定且相同，而 $c,c' \\in \\mathbb{R}^2$，$d,d' \\in \\mathbb{R}^2$ 被选为线性无关对。\n\n所有秩必须通过基于奇异值分解（SVD）的数值秩计算为 $\\mathbb{R}$ 上的代数秩；角度单位不适用；不出现物理单位。您的程序应生成单行输出，其中包含四个测试用例的结果，格式为方括号括起来的逗号分隔列表（例如，$[r_1,r_2,r_3,r_4]$），其中每个 $r_t$ 是一个布尔值，指示启发式方法是否在测试用例 $t$ 上达到了最优的最小最大 TT 秩。\n\n您的推导和论证必须基于：\n- 矩阵秩和张量矩阵化的基本定义。\n- 最小张量列秩由连续展开的秩表征。\n- 关于矩阵秩在行和列置换下不变性的经过验证的事实。\n\n不允许使用其他快捷公式。实现必须是自包含的，不需要用户输入、外部文件或网络访问。最终输出必须严格遵循指定格式的单行。",
            "solution": "所述问题是有效的。它在数值线性代数中有科学依据，问题提出得当，且是客观的。它为张量分析中的一个标准但具有挑战性的问题提供了完整且一致的设置。下面开始求解。\n\n### 第 1 部分：置换张量的 TT 秩推导\n\n设 $X \\in \\mathbb{R}^{n_1 \\times n_2 \\times \\cdots \\times n_d}$ 为一个 $d$ 阶张量。设 $\\pi \\in S_d$ 为模式索引 $\\{1, \\ldots, d\\}$ 的一个置换。我们定义置换张量 $X^\\pi$ 为一个大小为 $n_{\\pi(1)} \\times \\cdots \\times n_{\\pi(d)}$ 的张量，其元素由下式给出\n$$ (X^\\pi)_{i_1, \\ldots, i_d} = X_{j_1, \\ldots, j_d} \\quad \\text{其中} \\quad j_{\\pi(k)} = i_k \\text{ 对于 } k=1, \\ldots, d。 $$\n该定义表明 $X^\\pi$ 的第 $k$ 个模式对应于 $X$ 的第 $\\pi(k)$ 个模式。\n\n根据最小张量列（TT）秩的定义，张量 $X^\\pi$ 的第 $k$ 个 TT 秩（我们记作 $r_k^\\pi$）是 $X^\\pi$ 的矩阵化（展开）的秩，该展开将其前 $k$ 个模式与其余 $d-k$ 个模式分组。\n$$ r_k^\\pi \\triangleq \\mathrm{rank}\\left(\\mathrm{unfold}_{\\{1, \\ldots, k\\} | \\{k+1, \\ldots, d\\}}(X^\\pi)\\right)。 $$\n让我们将右侧的矩阵展开表示为 $M_\\pi$。矩阵 $M_\\pi$ 的维度为 $(\\prod_{m=1}^k n_{\\pi(m)}) \\times (\\prod_{m=k+1}^d n_{\\pi(m)})$。其行由多重索引 $(i_1, \\ldots, i_k)$ 索引，其列由多重索引 $(i_{k+1}, \\ldots, i_d)$ 索引。对应于这些多重索引的矩阵位置上的元素是 $(X^\\pi)_{i_1, \\ldots, i_d}$。\n\n我们需要证明这个秩等价于直接作用于原始张量 $X$ 的另一个展开的秩：\n$$ r_k^\\pi = \\mathrm{rank}\\left(\\mathrm{unfold}_{\\{\\pi(1), \\ldots, \\pi(k)\\} | \\{\\pi(k+1), \\ldots, \\pi(d)\\}}(X)\\right)。 $$\n让我们将右侧的矩阵表示为 $M_X$。此展开的行模式为 $S = \\{\\pi(1), \\ldots, \\pi(k)\\}$，列模式为 $\\bar{S} = \\{\\pi(k+1), \\ldots, \\pi(d)\\}$。设 $X$ 的索引为 $(j_1, \\ldots, j_d)$，其中 $j_m \\in \\{1, \\ldots, n_m\\}$。矩阵 $M_X$ 的维度为 $(\\prod_{m \\in S} n_m) \\times (\\prod_{m \\in \\bar{S}} n_m)$。问题陈述中指定展开中的内部模式排序是“由 $\\pi$ 导出的”。这意味着行多重索引可以与元组 $(j_{\\pi(1)}, \\ldots, j_{\\pi(k)})$ 等同，列多重索引可以与 $(j_{\\pi(k+1)}, \\ldots, j_{\\pi(d)})$ 等同。对应于这些多重索引的矩阵位置上的元素是 $X_{j_1, \\ldots, j_d}$。\n\n让我们建立矩阵 $M_\\pi$ 和 $M_X$ 之间的对应关系。\n$M_\\pi$ 的任意元素对应于一个条目 $(X^\\pi)_{i_1, \\ldots, i_d}$，其中 $(i_1, \\ldots, i_k)$ 决定行，$(i_{k+1}, \\ldots, i_d)$ 决定列。根据定义，此值等于 $X_{j_1, \\ldots, j_d}$，其中 $j_{\\pi(m)} = i_m$ 对所有 $m=1, \\ldots, d$ 成立。\n\n$M_X$ 的任意元素对应于一个条目 $X_{j_1, \\ldots, j_d}$。其行由索引 $\\{j_m\\}_{m \\in S} = \\{j_{\\pi(1)}, \\ldots, j_{\\pi(k)}\\}$ 决定，其列由 $\\{j_m\\}_{m \\in \\bar{S}} = \\{j_{\\pi(k+1)}, \\ldots, j_{\\pi(d)}\\}$ 决定。\n\n如果我们将 $i_m = j_{\\pi(m)}$ 代入 $M_\\pi$ 的描述中，我们会发现：\n1.  两个矩阵包含的值集合是相同的，即张量 $X$ 的所有元素。\n2.  $M_\\pi$ 中一个元素的行由 $(i_1, \\ldots, i_k)$ 决定，这与 $(j_{\\pi(1)}, \\ldots, j_{\\pi(k)})$ 完全相同。这正是决定 $M_X$ 中相应元素行的索引集合。\n3.  $M_\\pi$ 中一个元素的列由 $(i_{k+1}, \\ldots, i_d)$ 决定，这与 $(j_{\\pi(k+1)}, \\ldots, j_{\\pi(d)})$ 完全相同。这正是决定 $M_X$ 中相应元素列的索引集合。\n\n鉴于问题指定“保留由 $\\pi$ 导出的顺序”，从多重索引到单一矩阵索引的字典序映射对两个矩阵是相同的。例如，$M_\\pi$ 中对应于 $(i_1, \\dots, i_k)$ 的行索引 $I$ 是 $I = \\sum_{m=1}^k (i_m-1) \\prod_{l=1}^{m-1} n_{\\pi(l)}$。$M_X$ 中对应于 $(j_{\\pi(1)}, \\dots, j_{\\pi(k)})$ 的行索引 $I'$ 是 $I'=\\sum_{m=1}^k (j_{\\pi(m)}-1) \\prod_{l=1}^{m-1} n_{\\pi(l)}$。由于 $i_m = j_{\\pi(m)}$，我们有 $I = I'$。类似的论证也适用于列索引。\n\n因此，这些矩阵不仅仅是彼此的置换；它们是完全相同的：$M_\\pi = M_X$。\n因此，它们的秩必须相等：\n$$ \\mathrm{rank}(M_\\pi) = \\mathrm{rank}(M_X)。 $$\n这完成了推导，证明了\n$$ r_k^\\pi = \\mathrm{rank}\\left(\\mathrm{unfold}_{\\{\\pi(1), \\ldots, \\pi(k)\\} | \\{\\pi(k+1), \\ldots, \\pi(d)\\}}(X)\\right), \\quad k=1, \\ldots, d-1。 $$\n这个结果是基础性的，因为它允许我们通过在原始张量 $X$ 上执行展开来确定任何模式置换的 TT 秩，而无需显式地构造 $X^\\pi$。\n\n### 第 2 部分：最小化最大 TT 秩的启发式设计\n\n我们的目标是找到一个置换 $\\pi \\in S_d$，以最小化 $\\max_{k \\in \\{1,\\ldots,d-1\\}} r_k^\\pi$。根据第 1 部分，这等价于最小化 $\\max_{k} \\mathrm{rank}(\\mathrm{unfold}_{\\{\\pi(1),\\ldots,\\pi(k)\\}|\\{\\pi(k+1),\\ldots,\\pi(d)\\}}(X))$。\n\n任何矩阵的秩都受其维数的限制。对于展开 $\\mathrm{unfold}_{S|\\bar{S}}(X)$，其秩的界限为：\n$$ \\mathrm{rank} \\le \\min\\left( \\prod_{i \\in S} n_i, \\prod_{j \\in \\bar{S}} n_j \\right)。 $$\n对于一个通用张量，这个界限通常是紧的。因此，一个合理的启发式方法是找到一个置换 $\\pi$，以最小化所有切割 $k \\in \\{1, \\ldots, d-1\\}$ 上这些界限的最大值：\n$$ \\min_{\\pi \\in S_d} \\max_{k \\in \\{1, \\ldots, d-1\\}} \\min\\left( \\prod_{m=1}^k n_{\\pi(m)}, \\prod_{m=k+1}^d n_{\\pi(m)} \\right)。 $$\n这是一个组合优化问题。贪心策略可以提供高质量的解。核心思想是平衡 TT 链两侧维度的累积乘积。TT 秩是由一系列对模式的二分决定的。为了保持最大秩较低，我们必须避免任何导致两个分区维度乘积非常大的二分。这意味着维度的累积乘积 $P_k(\\pi) = \\prod_{m=1}^k n_{\\pi(m)}$ 应尽可能平缓地增长。\n这表明可以采用一种从外到内构建置换的贪心算法。在每一步，我们将一个剩余的模式放置在置换链的可用端点之一。为了保持累积乘积的平衡，我们从可用模式中进行选择，并将其放置在链的“较轻”一侧（即当前维度乘积较小的一侧）。\n\n选择放置哪个模式可以基于，例如，选择维度最小的那个。这种策略旨在保持链末端（$k=1$ 和 $k=d-1$）附近切割的秩界限较低，并使乘积向中心缓慢增长。\n\n**启发式算法：**\n1.  初始化一个长度为 $d$ 的空置换列表 $\\pi$，以及左右指针 $l=0, r=d-1$。\n2.  维护一个未分配的模式索引列表。设它们的维度为 $\\{n_i\\}$。\n3.  初始化链左侧和右侧的累积乘积：$P_{left} = 1$, $P_{right} = 1$。\n4.  按维度大小升序对模式索引进行排序。\n5.  遍历排序后的模式索引。对于每个模式索引 $m$：\n    a. 如果 $P_{left} \\le P_{right}$，则将模式 $m$ 放置在当前左侧位置：$\\pi[l] = m$。更新 $P_{left} \\leftarrow P_{left} \\cdot n_m$ 并增加 $l$。\n    b. 否则，将模式 $m$ 放置在当前右侧位置：$\\pi[r] = m$。更新 $P_{right} \\leftarrow P_{right} \\cdot n_m$ 并减少 $r$。\n6.  得到的列表 $\\pi$ 即为所需的置换。\n\n这种启发式方法仅需张量维度即可计算，其合理性在于通过平衡维度乘积来最小化所有 TT 切割上的秩界限的原则。\n\n### 第 3 部分：实现\n\n实现包括创建指定的测试张量，一个用于计算给定置换的 TT 秩的函数，启发式函数，以及用于比较的穷举搜索以找到最优解。对于每个测试用例，我们确定启发式方法是否达到了真正的最小最大 TT 秩。",
            "answer": "```python\nimport numpy as np\nimport itertools\nfrom functools import reduce\n\ndef compute_tt_ranks(X, pi):\n    \"\"\"\n    Computes the TT ranks for a tensor X with modes permuted by pi.\n    As derived, this is equivalent to computing the ranks of contiguous\n    unfoldings of the transposed tensor X_perm = transpose(X, pi).\n\n    Args:\n        X (np.ndarray): The input d-mode tensor.\n        pi (tuple): A tuple of 0-indexed integers representing the mode permutation.\n\n    Returns:\n        list: A list of the d-1 TT ranks.\n    \"\"\"\n    d = X.ndim\n    if d = 1:\n        return []\n\n    # Permute the tensor's modes according to pi.\n    # This conceptually creates the tensor X^pi whose TT ranks are to be computed.\n    X_perm = np.transpose(X, pi)\n    \n    ranks = []\n    # Iterate through the d-1 contiguous cuts of the permuted tensor.\n    for k in range(1, d):\n        shape = X_perm.shape\n        # Unfold the permuted tensor across the k-th cut by reshaping into a matrix.\n        dim_rows = np.prod(shape[:k]).astype(int)\n        dim_cols = np.prod(shape[k:]).astype(int)\n        matrix = np.reshape(X_perm, (dim_rows, dim_cols))\n        \n        # Compute the algebraic rank of the resulting matrix.\n        # np.linalg.matrix_rank uses SVD and a tolerance, which is appropriate.\n        rank = np.linalg.matrix_rank(matrix)\n        ranks.append(rank)\n        \n    return ranks\n\ndef heuristic_permutation(dims):\n    \"\"\"\n    Computes a permutation pi that aims to minimize the maximum TT rank, based on\n    a greedy strategy of balancing the products of dimensions across the TT chain.\n\n    Args:\n        dims (tuple): The dimensions of the tensor.\n\n    Returns:\n        tuple: The heuristically chosen permutation.\n    \"\"\"\n    d = len(dims)\n    mode_indices = list(range(d))\n    \n    # Sort mode indices in ascending order of their corresponding dimension size.\n    # Python's `sorted` is stable, which provides deterministic tie-breaking.\n    sorted_modes = sorted(mode_indices, key=lambda i: dims[i])\n    \n    pi = [0] * d\n    left_ptr, right_ptr = 0, d - 1\n    prod_left, prod_right = 1, 1\n    \n    # Greedily build the permutation from the outside in.\n    # At each step, select the available mode with the smallest dimension.\n    for mode_idx in sorted_modes:\n        # Place this mode on the side of the chain with the smaller cumulative product.\n        if prod_left = prod_right:\n            pi[left_ptr] = mode_idx\n            prod_left *= dims[mode_idx]\n            left_ptr += 1\n        else:\n            pi[right_ptr] = mode_idx\n            prod_right *= dims[mode_idx]\n            right_ptr -= 1\n            \n    return tuple(pi)\n\ndef evaluate_case(X):\n    \"\"\"\n    Finds the optimal maximum TT rank via exhaustive search over all permutations\n    and compares it with the result from the heuristic.\n\n    Args:\n        X (np.ndarray): The test tensor.\n\n    Returns:\n        bool: True if the heuristic finds an optimal permutation, False otherwise.\n    \"\"\"\n    dims = X.shape\n    d = X.ndim\n    \n    if d = 1:\n        return True # Trivial case, no ranks to compute.\n\n    # --- Exhaustive search for ground truth ---\n    optimal_min_max_rank = float('inf')\n    all_permutations = itertools.permutations(range(d))\n\n    for pi in all_permutations:\n        ranks = compute_tt_ranks(X, pi)\n        current_max_rank = max(ranks) if ranks else 0\n        if current_max_rank  optimal_min_max_rank:\n            optimal_min_max_rank = current_max_rank\n\n    # --- Heuristic ---\n    pi_heuristic = heuristic_permutation(dims)\n    ranks_heuristic = compute_tt_ranks(X, pi_heuristic)\n    heuristic_max_rank = max(ranks_heuristic) if ranks_heuristic else 0\n\n    # --- Comparison ---\n    is_optimal = (heuristic_max_rank == optimal_min_max_rank)\n    return is_optimal\n\ndef define_test_cases():\n    \"\"\"Generates the four test tensors as specified in the problem.\"\"\"\n    test_suite = []\n\n    # Test Case 1: Generic dense tensor, d=5\n    rng = np.random.default_rng(seed=42)\n    X1 = rng.random(size=(2, 3, 2, 3, 2))\n    test_suite.append(X1)\n\n    # Test Case 2: Kronecker structure, d=4\n    u = np.array([1., 2., 3.])\n    v = np.array([4., 5., 6.])\n    M = np.outer(u, v)  # 3x3 rank-1 matrix\n    N = np.eye(2)       # 2x2 full-rank matrix\n    X2 = np.einsum('ik,jl->ijkl', M, N, dtype=np.float64)\n    test_suite.append(X2)\n\n    # Test Case 3: Rank-1 separable tensor, d=6\n    g_vectors = [\n        np.array([1.1, 2.2]), np.array([3.3, 1.1]), np.array([1.1, 4.4]),\n        np.array([2.2, 1.1]), np.array([1.1, 1.1]), np.array([2.2, 3.3])\n    ]\n    X3 = reduce(np.multiply.outer, g_vectors)\n    test_suite.append(X3)\n\n    # Test Case 4: Structured Canonical Polyadic sum, d=4\n    a = np.array([1., 2., 3.])\n    b = np.array([4., 5., 6.])\n    c = np.array([1., 0.])\n    d_vec = np.array([1., 1.])\n    c_p = np.array([0., 1.])\n    d_p = np.array([1., -1.])\n    T1 = reduce(np.multiply.outer, [a, b, c, d_vec])\n    T2 = reduce(np.multiply.outer, [a, b, c_p, d_p])\n    X4 = T1 + T2\n    test_suite.append(X4)\n    \n    return test_suite\n\ndef solve():\n    \"\"\"\n    Main function to run the evaluation on all test cases and print the results.\n    \"\"\"\n    test_cases = define_test_cases()\n    results = []\n\n    for X in test_cases:\n        is_optimal = evaluate_case(X)\n        results.append(is_optimal)\n\n    # The final print statement must follow the specified format exactly.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "在理解了张量链的结构后，一个自然的问题是它与分层Tucker (HT) 等其他格式相比如何。本练习  通过分析一个基本操作（即为正交性检查构建格拉姆矩阵）的计算成本，对这两种格式进行了具体的比较。这种分析有助于您建立关于这两种重要的张量网络结构之间性能权衡的直观理解。",
            "id": "3583915",
            "problem": "考虑一个以张量列（TT）格式以及层级塔克（HT）格式表示的 $d$ 阶张量。您将分析用于正交性检验的格拉姆矩阵的构建计算成本（浮点运算次数，计为加法和乘法之和），以及存储这些格拉姆矩阵所需的空间，然后在一系列科学标准假设下，通过比较TT和HT格式，将这些成本与总体复杂度联系起来。\n\n对于张量列（TT）格式：TT表示由 $d$ 个三维核 $\\mathcal{G}_{k} \\in \\mathbb{R}^{r_{k-1} \\times n \\times r_{k}}$（$k = 1, \\dots, d$）组成，其中边界秩 $r_{0} = r_{d} = 1$，内部秩 $r_{1}, \\dots, r_{d-1}$ 假定等于一个统一值 $r \\geq 1$。所有模态的物理维度大小相同，$n_{1} = \\dots = n_{d} = n \\geq 1$。为了检验TT核的左正交性，我们考虑从 $\\mathcal{G}_{k}$ 得到的左展开矩阵 $X_{k} \\in \\mathbb{R}^{(r_{k-1} n) \\times r_{k}}$，并构建格拉姆矩阵 $G_{k} = X_{k}^{\\top} X_{k} \\in \\mathbb{R}^{r_{k} \\times r_{k}}$。假设格拉姆矩阵是通过直接的稠密矩阵乘法形成的，除了计算 $X_{k}^{\\top} X_{k}$ 的常规算术计数外，不利用对称性。您必须分析在所有核 $k = 1, \\dots, d-1$ 上为左正交性检验构建所有格拉姆矩阵 $G_{k}$ 的总算術成本，以及存储这些格拉姆矩阵所需的标量元素总数。\n\n对于层级塔克（HT）格式：考虑一个具有 $d$ 个叶节点的平衡二叉维度树（假设 $d$ 是 $2$ 的幂），其中每个叶节点对应一个大小为 $n$ 的物理维度，并配备一个具有 $r_{\\ell} \\geq 1$ 列的基矩阵 $U_{\\ell} \\in \\mathbb{R}^{n \\times r_{\\ell}}$。每个内部节点 $t$ 都有一个转移张量 $B_{t} \\in \\mathbb{R}^{r_{t} \\times r_{t_{\\mathrm{left}}} \\times r_{t_{\\mathrm{right}}}}$，其内部秩统一为 $r_{t} = r$，子节点秩为 $r_{t_{\\mathrm{left}}} = r_{t_{\\mathrm{right}}} = r$。在标准的HT构造下，内部节点的节点基 $U_{t}$ 是通过组合其子节点的基和转移张量得到的。对于正交性检验，叶节点的格拉姆矩阵为 $G_{\\ell} = U_{\\ell}^{\\top} U_{\\ell} \\in \\mathbb{R}^{r_{\\ell} \\times r_{\\ell}}$，而在内部节点 $t$处，假设子节点的基是标准正交的，其格拉姆矩阵等于对 $B_{t}$ 的子索引进行收缩，从而得到 $G_{t} \\in \\mathbb{R}^{r \\times r}$。您必须分析在平衡二叉树中所有节点（叶节点和内部节点）上构建格拉姆矩阵的总算術成本，以及存储这些格拉姆矩阵所需的标量元素总数。\n\n在您的推導中，请使用以下科学标准作为基础：\n- 用于正交性检验的TT核及其左展开的定义。\n- 平衡二叉树上的HT节点基与转移张量的定义，以及当子基是标准正交时，通过收缩在内部节点产生格拉姆矩阵的方法。\n- 经过充分验证的稠密矩阵乘法（对于 $A \\in \\mathbb{R}^{m \\times p}$ 构建 $A^{\\top} A$）和稠密张量收缩的算術成本，计为标量乘加运算的总数。\n\n在推导出TT和HT的总算術成本和总存储量（以标量计）之后，通过比较TT和HT的算術成本，将它们与总体复杂度联系起来。您的最终答案应为该比率的单个闭式解析表达式\n$$R(d,n,r,r_{\\ell}) = \\frac{\\text{TT构建格拉姆矩阵的总浮点运算次数}}{\\text{HT构建格拉姆矩阵的总浮点运算次数}}。$$\n不要四舍五入；请提供 $R(d,n,r,r_{\\ell})$ 的精确表达式，不带单位。",
            "solution": "此问题的目标是分析和比较在张量列（TT）和层级塔克（HT）格式中表示的张量进行正交性检验时，构建格拉姆矩阵的计算成本（以浮点运算次数（flops）衡量）。该分析的最终结果将是推导出这些成本的比率。\n\n首先，我们讨论张量列（TT）格式。一个 $d$ 阶张量由 $d$ 个三维核 $\\mathcal{G}_{k} \\in \\mathbb{R}^{r_{k-1} \\times n \\times r_{k}}$（$k = 1, \\dots, d$）表示。边界秩为 $r_{0} = r_{d} = 1$，所有内部秩均为统一值 $r_{k} = r$（$k = 1, \\dots, d-1$）。物理维度大小是统一的，$n_{k}=n$。为检验左正交性，需为每个核的左展开 $X_{k} \\in \\mathbb{R}^{(r_{k-1} n) \\times r_{k}}$ 构建格拉姆矩阵 $G_{k} = X_{k}^{\\top} X_{k}$。分析针对索引为 $k = 1, \\dots, d-1$ 的核进行。\n\n对于一个矩阵 $A \\in \\mathbb{R}^{m \\times p}$，计算乘积 $A^{\\top}A$ 的标准成本约为 $2mp^{2}$ 次浮点运算（计算加法和乘法）。\n对于一个通用的TT核 $\\mathcal{G}_{k}$，其展开 $X_{k}$ 的维度为 $m = r_{k-1}n$ 和 $p = r_{k}$。因此，计算其格拉姆矩阵 $G_{k}$ 的浮点运算次数为 $2(r_{k-1}n)r_{k}^{2}$。\n\n我们必须在指定范围 $k = 1, \\dots, d-1$ 上对这些成本求和。\n对于第一个核（$k=1$），秩为 $r_{0}=1$ 和 $r_{1}=r$。计算成本为：\n$$ C_{1} = 2(r_{0}n)r_{1}^{2} = 2(1 \\cdot n)r^{2} = 2nr^{2} $$\n对于随后的内部核（$k=2, \\dots, d-1$），秩为 $r_{k-1}=r$ 和 $r_{k}=r$。每个此类核的成本为：\n$$ C_{k} = 2(r_{k-1}n)r_{k}^{2} = 2(rn)r^{2} = 2nr^{3} $$\n共有 $(d-1) - 2 + 1 = d-2$ 个这样的核。\nTT格式的总浮点运算次数，记为 $C_{\\text{TT}}$，是第一个核的成本与其它 $d-2$ 个内部核的成本之和：\n$$ C_{\\text{TT}} = C_{1} + \\sum_{k=2}^{d-1} C_{k} = 2nr^{2} + (d-2)2nr^{3} $$\n提取公因式 $2nr^{2}$ 得：\n$$ C_{\\text{TT}} = 2nr^{2}(1 + (d-2)r) $$\n为完整起见，存储这 $d-1$ 个格拉姆矩阵（每个大小为 $r \\times r$）所需的总空间为 $(d-1)r^2$ 个标量。\n\n接下来，我们分析层级塔克（HT）格式。该张量定义在一个具有 $d$ 个叶节点的平衡二叉树上，其中 $d$ 是 $2$ 的幂。这样的树有 $d-1$ 个内部节点。\n在 $d$ 个叶节点中的每一个（记为 $\\ell$）处，都有一个基矩阵 $U_{\\ell} \\in \\mathbb{R}^{n \\times r_{\\ell}}$。相应的格拉姆矩阵是 $G_{\\ell} = U_{\\ell}^{\\top} U_{\\ell} \\in \\mathbb{R}^{r_{\\ell} \\times r_{\\ell}}$。构建一个这样的矩阵的浮点运算次数是 $2nr_{\\ell}^{2}$。由于有 $d$ 个叶节点，所有叶节点的总成本是：\n$$ C_{\\text{leaves}} = d \\cdot (2nr_{\\ell}^{2}) = 2dnr_{\\ell}^{2} $$\n在 $d-1$ 个内部节点中的每一个（记为 $t$）处，都有一个转移张量 $B_{t} \\in \\mathbb{R}^{r_{t} \\times r_{t_{\\mathrm{left}}} \\times r_{t_{\\mathrm{right}}}}$。问题陈述中说明秩是统一的，$r_{t} = r_{t_{\\mathrm{left}}} = r_{t_{\\mathrm{right}}} = r$，因此 $B_{t} \\in \\mathbb{R}^{r \\times r \\times r}$。格拉姆矩阵 $G_t \\in \\mathbb{R}^{r \\times r}$ 是通过对子索引进行收缩而形成的。设 $B_t$ 的索引为 $(i,j,k)$，这对应于计算：\n$$ G_{t}(i, i') = \\sum_{j=1}^{r} \\sum_{k=1}^{r} B_{t}(i, j, k) B_{t}(i', j, k) $$\n这等价于构建矩阵乘积 $M M^{\\top}$，其中 $M \\in \\mathbb{R}^{r \\times r^2}$ 是 $B_t$ 的模-$1$ 矩阵化。成本为 $2r^4$ 次浮点运算。这 $d-1$ 个内部节点中的每一个都会产生此成本。所有内部节点的总成本为：\n$$ C_{\\text{interiors}} = (d-1)2r^{4} $$\nHT格式的总浮点运算次数 $C_{\\text{HT}}$ 是叶节点和内部节点成本的总和：\n$$ C_{\\text{HT}} = C_{\\text{leaves}} + C_{\\text{interiors}} = 2dnr_{\\ell}^{2} + (d-1)2r^{4} = 2(dnr_{\\ell}^{2} + (d-1)r^{4}) $$\n为完整起見，HT格拉姆矩阵的总存储量包括 $d$ 个大小为 $r_{\\ell} \\times r_{\\ell}$ 的矩阵和 $d-1$ 个大小为 $r \\times r$ 的矩阵，总共为 $dr_{\\ell}^{2} + (d-1)r^{2}$ 个标量。\n\n最后，我们构建所需的比率 $R(d, n, r, r_{\\ell})$，即TT总浮点运算次数与HT总浮点运算次数之比：\n$$ R(d, n, r, r_{\\ell}) = \\frac{C_{\\text{TT}}}{C_{\\text{HT}}} = \\frac{2nr^{2}(1 + (d-2)r)}{2(dnr_{\\ell}^{2} + (d-1)r^{4})} $$\n消去公因子 $2$ 后得到最终表达式：\n$$ R(d, n, r, r_{\\ell}) = \\frac{nr^{2}(1 + (d-2)r)}{dnr_{\\ell}^{2} + (d-1)r^{4}} $$",
            "answer": "$$\\boxed{\\frac{nr^{2}(1 + (d-2)r)}{dnr_{\\ell}^{2} + (d-1)r^{4}}}$$"
        },
        {
            "introduction": "高效的张量格式只有在操作它们的相关算法具有数值稳定性时才真正有用。本练习  深入探讨了在广泛使用的交替最小二乘 (ALS) 算法中出现的子问题的条件数。它揭示了张量网络的结构如何直接影响算法的敏感性，并探讨了如何通过正则化来缓解这些数值问题。",
            "id": "3583954",
            "problem": "考虑一个以张量链 (Tensor-Train, TT) 格式表示的 $d$ 阶张量 $\\mathcal{A} \\in \\mathbb{R}^{n_1 \\times \\cdots \\times n_d}$，其 TT 核为 $\\mathcal{G}_1,\\ldots,\\mathcal{G}_d$，TT 秩为 $r_0=1, r_1,\\ldots,r_d=1$。在针对位置 $k$ 的 TT 核的交替最小二乘 (Alternating Least Squares, ALS) 步骤中，向量化核 $x_k = \\operatorname{vec}(\\mathcal{G}_k)$ 的更新需要求解一个线性最小二乘问题\n$$\n\\min_{x \\in \\mathbb{R}^{p_k}} \\| U_k x - b_k \\|_2,\n$$\n其中 $U_k \\in \\mathbb{R}^{m_k \\times p_k}$ 是通过收缩固定的左右 TT 界面形成的第 $k$ 个展开矩阵，而 $b_k \\in \\mathbb{R}^{m_k}$ 是包含数据张量 $\\mathcal{A}$ 的收缩后的右侧项。假设 $U_k$ 具有满列秩，其奇异值为 $\\sigma_1(U_k) \\ge \\cdots \\ge \\sigma_{r_k}(U_k)  0$（其中 $r_k = p_k$）。定义展开条件数\n$$\n\\kappa_k \\;=\\; \\frac{\\sigma_1(U_k)}{\\sigma_{r_k}(U_k)}.\n$$\n仅从数值线性代数的核心定义（奇异值分解 (SVD)、Moore–Penrose 伪逆、算子范数）出发，完成以下任务：\n\n1. 推导一个最坏情况下的界，该界将 ALS 核更新解的相对扰动与右侧项 $b_k$ 的扰动联系起来，并纯粹用 $\\kappa_k$ 表示该界。假设存在精确数据关系 $b_k = U_k x_k^\\star$（对于某个 $x_k^\\star$），并考虑形式为 $b_k \\mapsto b_k + \\delta b_k$ 的扰动。\n\n2. 考虑对 ALS 更新进行 Tikhonov 正则化，\n$$\nx_{k,\\lambda} \\;=\\; \\arg\\min_{x \\in \\mathbb{R}^{p_k}} \\left( \\| U_k x - b_k \\|_2^2 + \\lambda^2 \\|x\\|_2^2 \\right),\n$$\n并推导正则化正规方程算子的条件数，将其表示为 $\\lambda$、$\\sigma_1(U_k)$ 和 $\\sigma_{r_k}(U_k)$ 的函数。\n\n3. 假设 $\\sigma_1(U_k) = 1200$，$\\sigma_{r_k}(U_k) = 0.75$，你需要选择一个正则化参数 $\\lambda \\ge 0$，使得正则化条件数最多为 $\\alpha = 10^3$。计算保证此正则化条件数界的最小 $\\lambda$。将你的答案四舍五入到四位有效数字。\n\n你的最终答案必须是一个实数。",
            "solution": "问题分为三个部分。我们将依次解决每个部分。该问题经验证是自洽的、有科学依据且适定的。\n\n**第 1 部分：非正则化最小二乘问题的最坏情况界**\n\n交替最小二乘 (ALS) 子问题是找到核更新 $x_k$，该更新解以下线性最小二乘问题：\n$$\n\\min_{x \\in \\mathbb{R}^{p_k}} \\| U_k x - b_k \\|_2\n$$\n鉴于矩阵 $U_k \\in \\mathbb{R}^{m_k \\times p_k}$ 具有满列秩，该问题的唯一解由正规方程给出：\n$$\nU_k^T U_k x_k = U_k^T b_k\n$$\n解可以使用 Moore-Penrose 伪逆 $U_k^\\dagger$ 表示：\n$$\nx_k = (U_k^T U_k)^{-1} U_k^T b_k = U_k^\\dagger b_k\n$$\n我们给定一个精确的基础解 $x_k^\\star$，使得 $b_k = U_k x_k^\\star$。右侧项的扰动 $\\delta b_k$ 导致新的右侧项 $b_k' = b_k + \\delta b_k$。相应的新解为：\n$$\nx_k' = U_k^\\dagger (b_k + \\delta b_k) = U_k^\\dagger b_k + U_k^\\dagger \\delta b_k = x_k^\\star + \\delta x_k\n$$\n解的扰动为 $\\delta x_k = x_k' - x_k^\\star = U_k^\\dagger \\delta b_k$。\n为了找到最坏情况下的相对误差，我们分析范数。取 2-范数，我们得到：\n$$\n\\|\\delta x_k\\|_2 = \\|U_k^\\dagger \\delta b_k\\|_2 \\le \\|U_k^\\dagger\\|_2 \\|\\delta b_k\\|_2\n$$\n算子范数 $\\|U_k^\\dagger\\|_2$ 是 $U_k^\\dagger$ 的最大奇异值。设 $U_k$ 的 SVD 为 $U_k = P \\Sigma Q^T$，其中 $\\Sigma = \\operatorname{diag}(\\sigma_1, \\dots, \\sigma_{p_k})$。由于 $U_k$ 是满列秩，因此 $p_k=r_k$，伪逆为 $U_k^\\dagger = Q \\Sigma^{-1} P^T$。$U_k^\\dagger$ 的奇异值是 $U_k$ 奇异值的倒数。$U_k^\\dagger$ 的最大奇异值是 $U_k$ 最小奇异值的倒数。\n$$\n\\|U_k^\\dagger\\|_2 = \\frac{1}{\\sigma_{\\min}(U_k)} = \\frac{1}{\\sigma_{r_k}(U_k)}\n$$\n将此代入 $\\|\\delta x_k\\|_2$ 的不等式中，得到：\n$$\n\\|\\delta x_k\\|_2 \\le \\frac{1}{\\sigma_{r_k}(U_k)} \\|\\delta b_k\\|_2\n$$\n为了得到 $x_k$ 的相对误差，我们除以 $\\|x_k^\\star\\|_2$。我们需要为 $\\frac{1}{\\|x_k^\\star\\|_2}$ 找一个界。从关系式 $b_k = U_k x_k^\\star$ 出发，我们有：\n$$\n\\|b_k\\|_2 = \\|U_k x_k^\\star\\|_2 \\le \\|U_k\\|_2 \\|x_k^\\star\\|_2 = \\sigma_1(U_k) \\|x_k^\\star\\|_2\n$$\n这给了我们 $\\|x_k^\\star\\|_2$ 的一个下界：\n$$\n\\|x_k^\\star\\|_2 \\ge \\frac{\\|b_k\\|_2}{\\sigma_1(U_k)}\n$$\n因此，$\\frac{1}{\\|x_k^\\star\\|_2} \\le \\frac{\\sigma_1(U_k)}{\\|b_k\\|_2}$。\n\n结合这些不等式，我们推导出相对扰动的界：\n$$\n\\frac{\\|\\delta x_k\\|_2}{\\|x_k^\\star\\|_2} \\le \\frac{1}{\\|x_k^\\star\\|_2} \\left( \\frac{1}{\\sigma_{r_k}(U_k)} \\|\\delta b_k\\|_2 \\right) \\le \\left( \\frac{\\sigma_1(U_k)}{\\|b_k\\|_2} \\right) \\left( \\frac{1}{\\sigma_{r_k}(U_k)} \\|\\delta b_k\\|_2 \\right) = \\frac{\\sigma_1(U_k)}{\\sigma_{r_k}(U_k)} \\frac{\\|\\delta b_k\\|_2}{\\|b_k\\|_2}\n$$\n使用展开条件数的定义 $\\kappa_k = \\frac{\\sigma_1(U_k)}{\\sigma_{r_k}(U_k)}$，我们得到最终的最坏情况界：\n$$\n\\frac{\\|\\delta x_k\\|_2}{\\|x_k^\\star\\|_2} \\le \\kappa_k \\frac{\\|\\delta b_k\\|_2}{\\|b_k\\|_2}\n$$\n\n**第 2 部分：正则化正规方程的条件数**\n\nTikhonov 正则化最小二乘问题定义为：\n$$\nx_{k,\\lambda} = \\arg\\min_{x \\in \\mathbb{R}^{p_k}} \\left( \\| U_k x - b_k \\|_2^2 + \\lambda^2 \\|x\\|_2^2 \\right)\n$$\n目标函数为 $J(x) = (U_k x - b_k)^T(U_k x - b_k) + \\lambda^2 x^T x$。为了找到最小值，我们计算关于 $x$ 的梯度并令其为零：\n$$\n\\nabla_x J(x) = 2 U_k^T(U_k x - b_k) + 2 \\lambda^2 x = 0\n$$\n$$\n(U_k^T U_k) x - U_k^T b_k + \\lambda^2 x = 0\n$$\n这就得到了正则化的正规方程：\n$$\n(U_k^T U_k + \\lambda^2 I) x = U_k^T b_k\n$$\n其中 $I$ 是大小为 $p_k \\times p_k$ 的单位矩阵。该线性系统的算子是矩阵 $C = U_k^T U_k + \\lambda^2 I$。\n对称正定矩阵 $C$ 在 2-范数下的条件数是其最大特征值与最小特征值之比：\n$$\n\\kappa_{2}(C) = \\frac{\\lambda_{\\max}(C)}{\\lambda_{\\min}(C)}\n$$\n矩阵 $U_k^T U_k$ 的特征值是 $U_k$ 奇异值的平方，即 $\\sigma_i(U_k)^2$。矩阵 $C$ 是 $U_k^T U_k$ 和一个缩放的单位矩阵 $\\lambda^2 I$ 的和。因此，$C$ 的特征值为 $\\lambda_i(C) = \\sigma_i(U_k)^2 + \\lambda^2$。\n$C$ 的最大特征值对应于 $U_k$ 的最大奇异值：\n$$\n\\lambda_{\\max}(C) = \\sigma_1(U_k)^2 + \\lambda^2\n$$\n$C$ 的最小特征值对应于 $U_k$ 的最小奇异值：\n$$\n\\lambda_{\\min}(C) = \\sigma_{r_k}(U_k)^2 + \\lambda^2\n$$\n因此，正则化正规方程算子的条件数为：\n$$\n\\kappa_{\\text{reg}} = \\kappa_{2}(C) = \\frac{\\sigma_1(U_k)^2 + \\lambda^2}{\\sigma_{r_k}(U_k)^2 + \\lambda^2}\n$$\n\n**第 3 部分：正则化参数 $\\lambda$ 的计算**\n\n我们已知数值 $\\sigma_1(U_k) = 1200$，$\\sigma_{r_k}(U_k) = 0.75$，以及正则化条件数的目标上界 $\\alpha = 10^3$。我们需要找到最小的 $\\lambda \\ge 0$ 使得 $\\kappa_{\\text{reg}} \\le \\alpha$。\n不等式为：\n$$\n\\frac{\\sigma_1(U_k)^2 + \\lambda^2}{\\sigma_{r_k}(U_k)^2 + \\lambda^2} \\le \\alpha\n$$\n我们来分析函数 $f(\\lambda) = \\frac{\\sigma_1(U_k)^2 + \\lambda^2}{\\sigma_{r_k}(U_k)^2 + \\lambda^2}$ 在 $\\lambda \\ge 0$ 时的性质。其导数为：\n$$\nf'(\\lambda) = \\frac{2\\lambda(\\sigma_{r_k}(U_k)^2 + \\lambda^2) - 2\\lambda(\\sigma_1(U_k)^2 + \\lambda^2)}{(\\sigma_{r_k}(U_k)^2 + \\lambda^2)^2} = \\frac{2\\lambda(\\sigma_{r_k}(U_k)^2 - \\sigma_1(U_k)^2)}{(\\sigma_{r_k}(U_k)^2 + \\lambda^2)^2}\n$$\n由于 $\\sigma_1(U_k) > \\sigma_{r_k}(U_k)$，项 $(\\sigma_{r_k}(U_k)^2 - \\sigma_1(U_k)^2)$ 为负。因此，对于 $\\lambda > 0$，$f'(\\lambda)  0$，这意味着 $f(\\lambda)$ 是关于 $\\lambda$ 的单调递减函数。条件数的最大值在 $\\lambda=0$ 时取得，为 $(\\frac{\\sigma_1(U_k)}{\\sigma_{r_k}(U_k)})^2 = (\\frac{1200}{0.75})^2 = 1600^2 = 2.56 \\times 10^6$，远大于 $\\alpha=10^3$。当 $\\lambda \\to \\infty$ 时，$f(\\lambda) \\to 1$。\n因为 $f(\\lambda)$ 是递减的，所以对于所有大于或等于等式成立时的 $\\lambda$ 值，不等式 $\\kappa_{\\text{reg}} \\le \\alpha$ 都将成立。为了找到满足条件的最小 $\\lambda$，我们求解方程：\n$$\n\\frac{\\sigma_1(U_k)^2 + \\lambda^2}{\\sigma_{r_k}(U_k)^2 + \\lambda^2} = \\alpha\n$$\n重新整理各项以求解 $\\lambda^2$：\n$$\n\\sigma_1(U_k)^2 + \\lambda^2 = \\alpha (\\sigma_{r_k}(U_k)^2 + \\lambda^2)\n$$\n$$\n\\sigma_1(U_k)^2 - \\alpha \\sigma_{r_k}(U_k)^2 = \\alpha \\lambda^2 - \\lambda^2\n$$\n$$\n\\lambda^2 = \\frac{\\sigma_1(U_k)^2 - \\alpha \\sigma_{r_k}(U_k)^2}{\\alpha - 1}\n$$\n现在，我们代入给定的数值：$\\sigma_1(U_k) = 1200$，$\\sigma_{r_k}(U_k) = 0.75$ 和 $\\alpha = 1000$。\n$$\n\\lambda^2 = \\frac{(1200)^2 - 1000 \\times (0.75)^2}{1000 - 1} = \\frac{1440000 - 1000 \\times 0.5625}{999}\n$$\n$$\n\\lambda^2 = \\frac{1440000 - 562.5}{999} = \\frac{1439437.5}{999} \\approx 1440.878378\n$$\n取平方根求 $\\lambda$：\n$$\n\\lambda = \\sqrt{\\frac{1439437.5}{999}} \\approx 37.9589035\n$$\n将结果四舍五入到四位有效数字，我们得到 $37.96$。",
            "answer": "$$\\boxed{37.96}$$"
        }
    ]
}