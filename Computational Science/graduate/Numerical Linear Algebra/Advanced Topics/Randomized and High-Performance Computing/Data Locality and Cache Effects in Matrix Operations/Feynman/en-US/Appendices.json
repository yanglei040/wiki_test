{
    "hands_on_practices": [
        {
            "introduction": "High performance often begins with understanding memory access at the most fundamental level: the cache line. This first exercise builds intuition for spatial locality by analyzing a common scenario—a nested loop traversing a 2D array. You will quantify how access strides affect the probability of hitting the same cache line, directly connecting high-level code patterns to the efficiency of low-level hardware operations. ",
            "id": "3542775",
            "problem": "Consider a two-dimensional array stored in row-major order with base address $a_0$. The address of element $(i,j)$, with element size $e$ bytes and leading dimension (number of columns) $ld$, is $a(i,j) = a_0 + e \\cdot (i \\cdot ld + j)$. A loop nest accesses the array elements at indices $(i \\cdot s_i, j \\cdot s_j)$ for $i \\in \\{0,1,\\dots,I-1\\}$ and $j \\in \\{0,1,\\dots,J-1\\}$, where $s_i$ and $s_j$ are positive integer strides. The machine has a cache whose cache line size is $C$ bytes. Assume the following:\n- The initial offset of the first accessed element within its cache line, i.e., $a(0,0) \\bmod C$, is uniformly distributed in $[0,C)$ and independent of all other factors.\n- The only source of misses considered is whether two successive accesses fall into the same cache line; ignore capacity, conflict, and temporal reuse beyond the immediately preceding access.\n- A cache line, once accessed, is available for the next access without eviction.\n\nFor the specific case with parameters $e = 8$, $C = 64$, $ld = 1024$, $I = 100$, $J = 50$, $s_i = 1$, and $s_j = 3$, model the entire execution as a sequence of $I \\cdot J$ accesses ordered by the nested loops, and define a “successive pair” as two consecutive accesses in this sequence. Using first principles of address arithmetic and modular reasoning on cache line boundaries, compute the fraction of successive pairs whose two addresses lie within the same cache line throughout the execution. Round your answer to $5$ significant figures.",
            "solution": "The user wants me to solve the following problem.\n**Problem Statement:**\nConsider a two-dimensional array stored in row-major order with base address $a_0$. The address of element $(i,j)$, with element size $e$ bytes and leading dimension (number of columns) $ld$, is $a(i,j) = a_0 + e \\cdot (i \\cdot ld + j)$. A loop nest accesses the array elements at indices $(i \\cdot s_i, j \\cdot s_j)$ for $i \\in \\{0,1,\\dots,I-1\\}$ and $j \\in \\{0,1,\\dots,J-1\\}$, where $s_i$ and $s_j$ are positive integer strides. The machine has a cache whose cache line size is $C$ bytes. Assume the following:\n- The initial offset of the first accessed element within its cache line, i.e., $a(0,0) \\bmod C$, is uniformly distributed in $[0,C)$ and independent of all other factors.\n- The only source of misses considered is whether two successive accesses fall into the same cache line; ignore capacity, conflict, and temporal reuse beyond the immediately preceding access.\n- A cache line, once accessed, is available for the next access without eviction.\n\nFor the specific case with parameters $e = 8$, $C = 64$, $ld = 1024$, $I = 100$, $J = 50$, $s_i = 1$, and $s_j = 3$, model the entire execution as a sequence of $I \\cdot J$ accesses ordered by the nested loops, and define a “successive pair” as two consecutive accesses in this sequence. Using first principles of address arithmetic and modular reasoning on cache line boundaries, compute the fraction of successive pairs whose two addresses lie within the same cache line throughout the execution. Round your answer to $5$ significant figures.\n\n### Step 1: Extract Givens\n- Array storage: Row-major order.\n- Base address: $a_0$.\n- Address of element $(i,j)$ in the array: $a(i,j) = a_0 + e \\cdot (i \\cdot ld + j)$.\n- Element size: $e = 8$ bytes.\n- Leading dimension (columns): $ld = 1024$.\n- Cache line size: $C = 64$ bytes.\n- Loop bounds: $i \\in \\{0, 1, \\dots, I-1\\}$ with $I=100$, and $j \\in \\{0, 1, \\dots, J-1\\}$ with $J=50$.\n- Access strides: $s_i = 1$, $s_j = 3$.\n- Array indices accessed at loop iteration $(i,j)$: $(i \\cdot s_i, j \\cdot s_j)$.\n- Initial offset assumption: The offset of the first accessed address, $a_0 \\pmod C$, is uniformly distributed in $[0, C)$.\n- Cache model: A hit occurs if and only if a successive access falls in the same cache line as its predecessor. All other cache effects are ignored.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded, rooted in the principles of computer architecture and numerical linear algebra concerning data locality. It is well-posed, providing all necessary parameters and a clearly defined, albeit simplified, cache model. The parameters are realistic. The language is objective and unambiguous. The problem requests a calculation based on a clearly specified model, which is a standard approach in performance analysis. The assumption of a standard nested loop order (outer loop on $i$, inner loop on $j$) is implicit but universally understood in this context. The problem is valid.\n\n### Step 3: Proceed to Solution\n\nThe address of the element accessed at loop iteration $(i,j)$ is given by substituting the effective indices $i' = i \\cdot s_i$ and $j' = j \\cdot s_j$ into the general address formula. Let $A(i,j)$ be this address:\n$$A(i,j) = a_0 + e \\cdot ((i \\cdot s_i) \\cdot ld + (j \\cdot s_j))$$\nTwo addresses, $A_1$ and $A_2$, reside within the same cache line of size $C$ if their integer division by $C$ yields the same quotient, i.e., $\\lfloor A_1/C \\rfloor = \\lfloor A_2/C \\rfloor$.\n\nLet $A_2 = A_1 + \\Delta A$, where $\\Delta A > 0$ is the difference in address between two successive memory accesses. The two accesses are in the same cache line if no cache line boundary is crossed between them. A cache line boundary is an address that is a multiple of $C$. The condition is that the interval $(A_1, A_1 + \\Delta A]$ contains no address of the form $k \\cdot C$ for some integer $k$.\n\nThis is equivalent to the condition $\\lfloor (A_1 + \\Delta A)/C \\rfloor = \\lfloor A_1/C \\rfloor$. Let $A_1 = qC + r$, where $q = \\lfloor A_1/C \\rfloor$ is the cache line number and $r = A_1 \\pmod C$ is the offset within the line, $r \\in [0, C)$. The condition becomes $\\lfloor (qC + r + \\Delta A)/C \\rfloor = q$, which simplifies to $\\lfloor (r + \\Delta A)/C \\rfloor = 0$. This holds if and only if $r + \\Delta A < C$.\n\nThe problem states that the initial offset $a_0 \\pmod C$ is uniformly distributed. Any subsequent address is $A(i,j) = a_0 + \\delta_{ij}$, where $\\delta_{ij} = e \\cdot (is_ild + js_j)$ is a constant for a given $(i,j)$. The offset of $A(i,j)$ within its cache line, $A(i,j) \\pmod C$, is therefore also uniformly distributed over $[0, C)$. Thus, for any given access, the probability that its offset $r$ is less than some value $v \\in [0,C)$ is $v/C$.\n\nThe probability of two successive addresses being in the same cache line, $P_{\\text{same}}$, is the probability that $r < C - \\Delta A$.\n- If $\\Delta A \\ge C$, then $C - \\Delta A \\le 0$, so the probability is $0$.\n- If $0 < \\Delta A < C$, the probability is $P(r < C - \\Delta A) = \\frac{C - \\Delta A}{C} = 1 - \\frac{\\Delta A}{C}$.\nCombining these, the probability of remaining in the same cache line for a forward address step of $\\Delta A$ is:\n$$P_{\\text{same}}(\\Delta A) = \\max\\left(0, 1 - \\frac{\\Delta A}{C}\\right)$$\n\nThe execution order follows standard nested loops, where the inner loop (over $j$) runs to completion for each iteration of the outer loop (over $i$). This gives rise to two types of successive access pairs:\n\n1.  **Inner loop transitions:** Access at $(i,j)$ followed by access at $(i, j+1)$ for $j \\in \\{0, 1, \\dots, J-2\\}$.\n2.  **Outer loop transitions:** Access at $(i, J-1)$ followed by access at $(i+1, 0)$ for $i \\in \\{0, 1, \\dots, I-2\\}$.\n\nWe calculate the address difference, $\\Delta A$, for each case.\n\n**Case 1: Inner loop transition**\nThe address difference is $\\Delta A_{\\text{inner}} = A(i, j+1) - A(i,j)$.\n$$\\Delta A_{\\text{inner}} = \\left[a_0 + e \\cdot (is_ild + (j+1)s_j)\\right] - \\left[a_0 + e \\cdot (is_ild + js_j)\\right]$$\n$$\\Delta A_{\\text{inner}} = e \\cdot s_j$$\nUsing the given parameters $e=8$ and $s_j=3$:\n$$\\Delta A_{\\text{inner}} = 8 \\cdot 3 = 24 \\text{ bytes}$$\n\n**Case 2: Outer loop transition**\nThe address difference is $\\Delta A_{\\text{outer}} = A(i+1, 0) - A(i, J-1)$.\n$$\\Delta A_{\\text{outer}} = \\left[a_0 + e \\cdot ((i+1)s_ild)\\right] - \\left[a_0 + e \\cdot (is_ild + (J-1)s_j)\\right]$$\n$$\\Delta A_{\\text{outer}} = e \\cdot [(i+1)s_ild - is_ild - (J-1)s_j] = e \\cdot [s_ild - (J-1)s_j]$$\nUsing parameters $e=8$, $s_i=1$, $ld=1024$, $J=50$, $s_j=3$:\n$$\\Delta A_{\\text{outer}} = 8 \\cdot [1 \\cdot 1024 - (50-1) \\cdot 3] = 8 \\cdot [1024 - 49 \\cdot 3]$$\n$$\\Delta A_{\\text{outer}} = 8 \\cdot [1024 - 147] = 8 \\cdot 877 = 7016 \\text{ bytes}$$\n\nNow we compute the probabilities of staying in the same cache line for each transition type, with $C = 64$ bytes.\n\nFor inner loop transitions: $\\Delta A_{\\text{inner}} = 24 < C = 64$.\n$$P_{\\text{same, inner}} = 1 - \\frac{\\Delta A_{\\text{inner}}}{C} = 1 - \\frac{24}{64} = 1 - \\frac{3}{8} = \\frac{5}{8}$$\nFor outer loop transitions: $\\Delta A_{\\text{outer}} = 7016 > C = 64$.\n$$P_{\\text{same, outer}} = \\max\\left(0, 1 - \\frac{7016}{64}\\right) = 0$$\n\nNext, we count the number of occurrences of each transition type. The total number of accesses is $I \\cdot J = 100 \\cdot 50 = 5000$. The total number of successive pairs is $N_{\\text{pairs}} = I \\cdot J - 1 = 4999$.\n\n-   Number of inner loop transitions, $N_{\\text{inner}}$: For each of the $I=100$ rows, there are $J-1=49$ transitions.\n    $$N_{\\text{inner}} = I \\cdot (J-1) = 100 \\cdot 49 = 4900$$\n-   Number of outer loop transitions, $N_{\\text{outer}}$: These occur at the end of each row except the last one.\n    $$N_{\\text{outer}} = I - 1 = 100 - 1 = 99$$\n    As a check, $N_{\\text{inner}} + N_{\\text{outer}} = 4900 + 99 = 4999 = N_{\\text{pairs}}$.\n\nThe fraction of successive pairs in the same cache line is the total expected number of such pairs divided by the total number of pairs.\nThe expected number of same-line pairs is the sum of the counts of each transition type multiplied by their respective probabilities:\n$$E[\\text{Hits}] = N_{\\text{inner}} \\cdot P_{\\text{same, inner}} + N_{\\text{outer}} \\cdot P_{\\text{same, outer}}$$\n$$E[\\text{Hits}] = 4900 \\cdot \\frac{5}{8} + 99 \\cdot 0 = \\frac{24500}{8} = 3062.5$$\nThe fraction, $F$, is this expected number divided by the total number of pairs:\n$$F = \\frac{E[\\text{Hits}]}{N_{\\text{pairs}}} = \\frac{3062.5}{4999}$$\n$$F \\approx 0.6126225245...$$\nRounding to $5$ significant figures, we get $0.61262$.",
            "answer": "$$\\boxed{0.61262}$$"
        },
        {
            "introduction": "After optimizing for individual cache lines, the next challenge is to manage the entire cache capacity to promote temporal locality. This practice explores tiling (or blocking), a cornerstone of high-performance computing, using the canonical example of a matrix transpose. By deriving the optimal tile size, you will learn how to structure algorithms to ensure the working set of data fits within the cache, maximizing data reuse and minimizing costly capacity misses. ",
            "id": "3542785",
            "problem": "Consider a blocked matrix transpose of a dense matrix from an input matrix $A \\in \\mathbb{R}^{n \\times n}$ to an output matrix $B \\in \\mathbb{R}^{n \\times n}$, both stored in row-major order. The algorithm processes square tiles of size $b \\times b$, reading a tile $\\mathcal{T}_A(i,j)$ from $A$ and writing its transpose into the corresponding tile $\\mathcal{T}_B(j,i)$ in $B$, until the entire matrix is transposed. Each matrix element occupies $s$ bytes. Assume an ideal two-level memory model with a single data cache that is fully associative, has Least Recently Used (LRU) replacement, and total capacity $M$ bytes. Assume a write-allocate, write-back policy, and neglect additional metadata space such as tag storage. The cache line size is irrelevant in this question; you may model capacity effects at the granularity of bytes, and you may ignore conflict misses because of full associativity.\n\nYou are to reason from first principles of the capacity model: a capacity miss occurs when the set of distinct data needed for reuse within a phase of computation exceeds the cache capacity $M$. For the blocked transpose, suppose the implementation is arranged so that, during the processing of a single pair of tiles $(i,j)$, all accesses remain within the two tiles $\\mathcal{T}_A(i,j)$ and $\\mathcal{T}_B(j,i)$ until that pair is completed.\n\nDerive, in closed form, the optimal integer tile size $b^{\\star}$ as a function of $M$ and $s$ that minimizes capacity misses by ensuring the two tiles can reside in cache simultaneously for the duration of their processing. Express your final answer as a single analytic expression. No numerical evaluation or rounding is required. The final answer must be a single symbolic mathematical expression.",
            "solution": "The blocked transpose processes $b \\times b$ tiles. Under the stated ideal cache model (fully associative with Least Recently Used (LRU) replacement and capacity $M$ bytes), capacity misses are governed by the working set size during the processing of a single tile pair. By assumption, the implementation confines its accesses to the two tiles $\\mathcal{T}_A(i,j)$ and $\\mathcal{T}_B(j,i)$ while transposing that pair.\n\nWe begin from the fundamental capacity principle: under LRU in a fully associative cache, all data that is reused without evictions will hit if the total distinct data referenced between uses does not exceed the cache capacity. Formally, if the reuse distance (measured in bytes) for any datum is at most $M$, then that datum will be present at its reuse and the access will be a cache hit.\n\nIn the present blocked transpose, the working set during one tile-pair processing is the union of the two tiles:\n- The tile $\\mathcal{T}_A(i,j)$ contains $b \\times b$ elements, occupying $b^{2} \\cdot s$ bytes.\n- The tile $\\mathcal{T}_B(j,i)$ contains $b \\times b$ elements, occupying $b^{2} \\cdot s$ bytes.\n\nTherefore, the total resident data required to keep both tiles in the cache simultaneously is\n$$\nW(b) \\;=\\; b^{2} s \\;+\\; b^{2} s \\;=\\; 2 b^{2} s.\n$$\nUnder the ideal capacity model, if $W(b) \\leq M$, then once the tiles are loaded into the cache, LRU will retain them until their processing completes, and the majority of intra-tile accesses will be served as hits (after the initial compulsory loads or write-allocate line fills). If $W(b) > M$, the cache cannot hold both tiles at once, and LRU will evict some portion of one tile while accessing the other, causing repeated capacity misses and thrashing.\n\nTo minimize capacity misses during the tile computation, one should choose the largest $b$ such that both tiles fit in the cache, i.e., such that $W(b) \\leq M$. This yields the inequality\n$$\n2 b^{2} s \\;\\leq\\; M.\n$$\nSolving for $b$ gives\n$$\nb^{2} \\;\\leq\\; \\frac{M}{2 s}\n\\qquad\\Longrightarrow\\qquad\nb \\;\\leq\\; \\sqrt{\\frac{M}{2 s}}.\n$$\nSince $b$ must be a positive integer, the optimal choice $b^{\\star}$ that maximizes $b$ under the capacity constraint is\n$$\nb^{\\star} \\;=\\; \\left\\lfloor \\sqrt{\\frac{M}{2 s}} \\right\\rfloor.\n$$\nThis expression ensures that the two $b \\times b$ tiles occupy at most $M$ bytes, so they can be retained in the cache throughout their processing under LRU, thereby minimizing capacity misses in the blocked transpose.",
            "answer": "$$\\boxed{\\left\\lfloor \\sqrt{\\frac{M}{2 s}} \\right\\rfloor}$$"
        },
        {
            "introduction": "Beyond capacity, cache performance can be degraded by a more subtle issue: conflict misses, where different data items repeatedly evict each other due to the cache's indexing scheme. This problem delves into the mechanics of set-associative caches and how memory layout interacts with them, demonstrating how a seemingly benign matrix stride can create performance pathologies. You will derive the minimal data padding required to mitigate these conflicts, a practical technique used in production-level numerical libraries. ",
            "id": "3542736",
            "problem": "Consider a computer system with a single-level data cache characterized by capacity $C$, associativity $A$, and cache line size $L$, all chosen as powers of two. For such a cache, the number of sets is $S = \\frac{C}{A L}$, and the set index for a memory address $a$ is defined by the widely used power-of-two mapping rule $s(a) = \\left( \\left\\lfloor \\frac{a}{L} \\right\\rfloor \\right) \\bmod S$. A dense matrix $M \\in \\mathbb{R}^{n \\times m}$ is stored in row-major order contiguous in memory with element size $b$ bytes, and the starting address of row $i$ is $\\alpha + i B$, where $B = m b + p$ is the row stride in bytes including an optional padding $p \\geq 0$. To ensure scientific realism and alignment-independent behavior, the padding $p$ must be chosen so that $B$ is an integer multiple of $L$.\n\nYou are given the specific parameters $C = 32 \\times 2^{10}$ bytes, $A = 8$, $L = 64$ bytes, $b = 8$ bytes (double precision), $m = 1024$, and a base address $\\alpha$ that is aligned to a cache line boundary so that $\\frac{\\alpha}{L} \\in \\mathbb{Z}$. Derive, from first principles of row-major layout and power-of-two set-indexing of caches, the minimal nonnegative padding $p$ in bytes so that consecutive rows $i$ and $i+1$ map to different cache sets, irrespective of $i$.\n\nExpress your final answer in bytes. No rounding is necessary.",
            "solution": "The problem requires finding the minimal non-negative padding $p$ for a row-major matrix such that consecutive rows do not map to the same cache sets. The core of the problem lies in understanding the relationship between memory addresses, the row stride, and the cache's set-indexing mechanism.\n\nFirst, we determine the cache geometry parameters from the givens. The cache capacity is $C = 32 \\times 2^{10}$ bytes, the associativity is $A = 8$, and the cache line size is $L = 64$ bytes. As all these are powers of two, we can write them as $C = 2^5 \\times 2^{10} = 2^{15}$ bytes, $A = 2^3$, and $L = 2^6$ bytes. The number of sets $S$ in the cache is given by the formula:\n$$S = \\frac{C}{A L} = \\frac{2^{15} \\text{ bytes}}{(8) \\cdot (64 \\text{ bytes})} = \\frac{2^{15}}{2^3 \\cdot 2^6} = \\frac{2^{15}}{2^9} = 2^6 = 64$$\nSo, there are $S=64$ sets in the cache.\n\nThe memory address $a$ is mapped to a set with index $s(a)$ given by the power-of-two mapping rule:\n$$s(a) = \\left( \\left\\lfloor \\frac{a}{L} \\right\\rfloor \\right) \\bmod S$$\nThe term $\\lfloor a/L \\rfloor$ represents the cache block address or block index of the memory address $a$.\n\nThe matrix is stored in row-major order. The starting memory address of row $i$ is $a_i = \\alpha + iB$, where $\\alpha$ is the base address of the matrix and $B$ is the row stride in bytes. The row stride is defined as $B = m b + p$, where $m=1024$ is the number of columns, $b=8$ bytes is the size of each element, and $p \\ge 0$ is the padding.\n\nThe problem imposes two critical constraints:\n1. The base address $\\alpha$ is aligned to a cache line boundary, which means $\\frac{\\alpha}{L}$ is an integer. Let $\\frac{\\alpha}{L} = k_{\\alpha}$ where $k_{\\alpha} \\in \\mathbb{Z}$.\n2. The row stride $B$ is an integer multiple of the cache line size $L$. This means $\\frac{B}{L}$ is an integer. Let $\\frac{B}{L} = k_{B}$ where $k_{B} \\in \\mathbb{Z}$.\n\nThe condition to be satisfied is that consecutive rows $i$ and $i+1$ map to different cache sets, for any row index $i$. This can be stated mathematically as $s(a_i) \\neq s(a_{i+1})$, where $a_i$ and $a_{i+1}$ are the starting addresses of row $i$ and row $i+1$, respectively.\n\nLet's analyze the set index for the start of row $i$, $s(a_i)$:\n$$s(a_i) = \\left( \\left\\lfloor \\frac{a_i}{L} \\right\\rfloor \\right) \\bmod S = \\left( \\left\\lfloor \\frac{\\alpha + iB}{L} \\right\\rfloor \\right) \\bmod S$$\nUsing the alignment constraints, we can simplify the floor expression:\n$$\\left\\lfloor \\frac{\\alpha + iB}{L} \\right\\rfloor = \\left\\lfloor \\frac{\\alpha}{L} + i\\frac{B}{L} \\right\\rfloor = \\lfloor k_{\\alpha} + i k_{B} \\rfloor$$\nSince $i$, $k_{\\alpha}$, and $k_{B}$ are all integers, their sum is an integer, so the floor operation is redundant.\n$$s(a_i) = (k_{\\alpha} + ik_{B}) \\bmod S$$\nSimilarly, for row $i+1$, the starting address is $a_{i+1} = \\alpha + (i+1)B$. The set index is:\n$$s(a_{i+1}) = (k_{\\alpha} + (i+1)k_{B}) \\bmod S = (k_{\\alpha} + ik_{B} + k_{B}) \\bmod S$$\n\nThe condition $s(a_i) \\neq s(a_{i+1})$ must hold for any $i$. This is equivalent to stating that the difference in set indices is non-zero (modulo $S$):\n$$(k_{\\alpha} + ik_{B} + k_{B}) - (k_{\\alpha} + ik_{B}) \\not\\equiv 0 \\pmod S$$\n$$k_{B} \\not\\equiv 0 \\pmod S$$\nThis simple condition—that the row stride in units of cache lines ($k_B$) must not be a multiple of the number of cache sets ($S$)—is the key to solving the problem.\n\nNow we must express $k_{B}$ in terms of the padding $p$ and apply the constraints.\n$$k_{B} = \\frac{B}{L} = \\frac{m b + p}{L}$$\nSubstituting the given values: $m=1024$, $b=8$, $L=64$.\n$$k_{B} = \\frac{1024 \\times 8 + p}{64} = \\frac{8192 + p}{64}$$\nThe constraint that $B$ must be a multiple of $L$ means $mb+p$ must be a multiple of $64$.\n$$1024 \\times 8 + p = 8192 + p$$\nSince $8192 = 128 \\times 64$, $8192$ is already a multiple of $64$. For the sum $8192+p$ to be a multiple of $64$, $p$ must also be a multiple of $64$.\nSo, we can write $p = q \\cdot L = 64q$ for some non-negative integer $q \\ge 0$.\n\nLet's substitute $p=64q$ back into the expression for $k_B$:\n$$k_{B} = \\frac{8192 + 64q}{64} = \\frac{8192}{64} + \\frac{64q}{64} = 128 + q$$\nNow we apply the condition $k_{B} \\not\\equiv 0 \\pmod S$ with $S=64$:\n$$128 + q \\not\\equiv 0 \\pmod{64}$$\nSince $128 = 2 \\times 64$, we have $128 \\equiv 0 \\pmod{64}$. The condition simplifies to:\n$$q \\not\\equiv 0 \\pmod{64}$$\nWe need to find the minimal non-negative padding $p$. This corresponds to finding the minimal non-negative integer $q$ that satisfies this condition. The possible values for $q$ are $0, 1, 2, \\dots$.\n- If $q=0$, then $q \\equiv 0 \\pmod{64}$. This violates the condition. This would correspond to $p=0$, which leads to consecutive rows mapping to the same set.\n- The smallest non-negative integer $q$ that is not a multiple of $64$ is $q=1$.\n\nTherefore, the minimal value for $q$ is $1$. The minimal padding $p$ is then:\n$$p_{min} = q_{min} \\cdot L = 1 \\cdot 64 = 64$$\nThe minimal non-negative padding required is $64$ bytes.",
            "answer": "$$\\boxed{64}$$"
        }
    ]
}