{
    "hands_on_practices": [
        {
            "introduction": "高性能计算的起点在于理解最基本的内存与缓存交互。这个练习将引导你通过第一性原理，量化分析具有特定步长（stride）的内存访问模式所体现出的空间局部性。通过计算连续内存访问命中同一缓存行（cache line）的概率，你将具体理解访问步长如何直接影响缓存效率，这是分析更复杂循环嵌套性能的基础。 ",
            "id": "3542775",
            "problem": "考虑一个以行主序存储的二维数组，其基地址为 $a_0$。元素 $(i,j)$ 的地址为 $a(i,j) = a_0 + e \\cdot (i \\cdot ld + j)$，其中元素大小为 $e$ 字节，领头维度（列数）为 $ld$。一个嵌套循环访问索引为 $(i \\cdot s_i, j \\cdot s_j)$ 的数组元素，其中 $i \\in \\{0,1,\\dots,I-1\\}$ 且 $j \\in \\{0,1,\\dots,J-1\\}$，$s_i$ 和 $s_j$ 是正整数步长。机器拥有一个高速缓存，其缓存行大小为 $C$ 字节。假设如下：\n- 首个被访问元素的初始偏移量，即 $a(0,0) \\pmod C$，在其缓存行内均匀分布于 $[0,C)$，且与所有其他因素无关。\n- 考虑的唯一未命中源是两次连续访问是否落入同一缓存行；忽略容量、冲突以及超出紧邻前一次访问的时间复用。\n- 一个缓存行一旦被访问，在下一次访问时仍然可用，不会被驱逐。\n\n对于参数为 $e = 8$，$C = 64$，$ld = 1024$，$I = 100$，$J = 50$，$s_i = 1$，$s_j = 3$ 的特定情况，将整个执行过程建模为一个由嵌套循环排序的 $I \\cdot J$ 次访问序列，并将序列中两次连续的访问定义为一个“连续对”。使用地址算术和关于缓存行边界的模运算推理的第一性原理，计算在整个执行过程中，两个地址位于同一缓存行内的连续对所占的比例。将您的答案四舍五入到 $5$ 位有效数字。",
            "solution": "用户想让我解决以下问题。\n**问题陈述：**\n考虑一个以行主序存储的二维数组，其基地址为 $a_0$。元素 $(i,j)$ 的地址为 $a(i,j) = a_0 + e \\cdot (i \\cdot ld + j)$，其中元素大小为 $e$ 字节，领头维度（列数）为 $ld$。一个嵌套循环访问索引为 $(i \\cdot s_i, j \\cdot s_j)$ 的数组元素，其中 $i \\in \\{0,1,\\dots,I-1\\}$ 且 $j \\in \\{0,1,\\dots,J-1\\}$，$s_i$ 和 $s_j$ 是正整数步长。机器拥有一个高速缓存，其缓存行大小为 $C$ 字节。假设如下：\n- 首个被访问元素的初始偏移量，即 $a(0,0) \\pmod C$，在其缓存行内均匀分布于 $[0,C)$，且与所有其他因素无关。\n- 考虑的唯一未命中源是两次连续访问是否落入同一缓存行；忽略容量、冲突以及超出紧邻前一次访问的时间复用。\n- 一个缓存行一旦被访问，在下一次访问时仍然可用，不会被驱逐。\n\n对于参数为 $e = 8$，$C = 64$，$ld = 1024$，$I = 100$，$J = 50$，$s_i = 1$，$s_j = 3$ 的特定情况，将整个执行过程建模为一个由嵌套循环排序的 $I \\cdot J$ 次访问序列，并将序列中两次连续的访问定义为一个“连续对”。使用地址算术和关于缓存行边界的模运算推理的第一性原理，计算在整个执行过程中，两个地址位于同一缓存行内的连续对所占的比例。将您的答案四舍五入到 $5$ 位有效数字。\n\n### 步骤 1：提取已知条件\n- 数组存储：行主序。\n- 基地址：$a_0$。\n- 数组中元素 $(i,j)$ 的地址：$a(i,j) = a_0 + e \\cdot (i \\cdot ld + j)$。\n- 元素大小：$e = 8$ 字节。\n- 领头维度（列数）：$ld = 1024$。\n- 缓存行大小：$C = 64$ 字节。\n- 循环边界：$i \\in \\{0, 1, \\dots, I-1\\}$，其中 $I=100$；$j \\in \\{0, 1, \\dots, J-1\\}$，其中 $J=50$。\n- 访问步长：$s_i = 1$, $s_j = 3$。\n- 循环迭代 $(i,j)$ 时访问的数组索引：$(i \\cdot s_i, j \\cdot s_j)$。\n- 初始偏移量假设：首个被访问地址的偏移量 $a_0 \\pmod C$ 在 $[0, C)$ 上均匀分布。\n- 缓存模型：当且仅当一次连续访问与其前驱落在同一缓存行中时，发生一次命中。所有其他缓存效应均被忽略。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题具有科学依据，其根源在于计算机体系结构和数值线性代数中关于数据局部性的原理。这个问题是良构的，提供了所有必要的参数和一个明确定义（尽管简化了）的缓存模型。参数是现实的。语言客观且无歧义。问题要求基于一个明确指定的模型进行计算，这是性能分析中的标准方法。关于标准嵌套循环顺序（外循环为 $i$，内循环为 $j$）的假设是隐含的，但在这种情况下是普遍理解的。该问题是有效的。\n\n### 步骤 3：开始求解\n\n在循环迭代 $(i,j)$ 时访问的元素地址，可以通过将有效索引 $i' = i \\cdot s_i$ 和 $j' = j \\cdot s_j$ 代入通用地址公式得到。设 $A(i,j)$ 为此地址：\n$$A(i,j) = a_0 + e \\cdot ((i \\cdot s_i) \\cdot ld + (j \\cdot s_j))$$\n两个地址 $A_1$ 和 $A_2$ 位于大小为 $C$ 的同一缓存行内，当且仅当它们除以 $C$ 的整数除法得到相同的商，即 $\\lfloor A_1/C \\rfloor = \\lfloor A_2/C \\rfloor$。\n\n设 $A_2 = A_1 + \\Delta A$，其中 $\\Delta A > 0$ 是两次连续内存访问的地址差。如果两次访问之间没有跨越缓存行边界，那么它们就在同一个缓存行中。缓存行边界是指 $C$ 的倍数的地址。条件是区间 $(A_1, A_1 + \\Delta A]$ 不包含任何形如 $k \\cdot C$（其中 $k$ 为整数）的地址。\n\n这等价于条件 $\\lfloor (A_1 + \\Delta A)/C \\rfloor = \\lfloor A_1/C \\rfloor$。设 $A_1 = qC + r$，其中 $q = \\lfloor A_1/C \\rfloor$ 是缓存行号，$r = A_1 \\pmod C$ 是行内偏移量，$r \\in [0, C)$。该条件变为 $\\lfloor (qC + r + \\Delta A)/C \\rfloor = q$，可简化为 $\\lfloor (r + \\Delta A)/C \\rfloor = 0$。此式当且仅当 $r + \\Delta A  C$ 时成立。\n\n问题陈述初始偏移量 $a_0 \\pmod C$ 是均匀分布的。任何后续地址为 $A(i,j) = a_0 + \\delta_{ij}$，其中 $\\delta_{ij} = e \\cdot (i \\cdot s_i \\cdot ld + j \\cdot s_j)$ 对于给定的 $(i,j)$ 是一个常数。因此，$A(i,j)$ 在其缓存行内的偏移量 $A(i,j) \\pmod C$ 也均匀分布在 $[0, C)$ 上。因此，对于任何给定的访问，其偏移量 $r$ 小于某个值 $v \\in [0,C)$ 的概率是 $v/C$。\n\n两次连续访问的地址位于同一缓存行的概率 $P_{\\text{same}}$，是 $r  C - \\Delta A$ 的概率。\n- 如果 $\\Delta A \\ge C$，那么 $C - \\Delta A \\le 0$，所以概率为 $0$。\n- 如果 $0  \\Delta A  C$，概率为 $P(r  C - \\Delta A) = \\frac{C - \\Delta A}{C} = 1 - \\frac{\\Delta A}{C}$。\n综合这些，对于一个大小为 $\\Delta A$ 的向前地址步进，保持在同一缓存行内的概率是：\n$$P_{\\text{same}}(\\Delta A) = \\max\\left(0, 1 - \\frac{\\Delta A}{C}\\right)$$\n\n执行顺序遵循标准的嵌套循环，其中内循环（对 $j$）在外循环（对 $i$）的每次迭代中都会完整运行一次。这会产生两种类型的连续访问对：\n\n1.  **内循环转移：** 在 $j \\in \\{0, 1, \\dots, J-2\\}$ 时，访问 $(i,j)$ 之后紧接着访问 $(i, j+1)$。\n2.  **外循环转移：** 在 $i \\in \\{0, 1, \\dots, I-2\\}$ 时，访问 $(i, J-1)$ 之后紧接着访问 $(i+1, 0)$。\n\n我们为每种情况计算地址差 $\\Delta A$。\n\n**情况 1：内循环转移**\n地址差为 $\\Delta A_{\\text{inner}} = A(i, j+1) - A(i,j)$。\n$$\\Delta A_{\\text{inner}} = \\left[a_0 + e \\cdot (is_ild + (j+1)s_j)\\right] - \\left[a_0 + e \\cdot (is_ild + js_j)\\right]$$\n$$\\Delta A_{\\text{inner}} = e \\cdot s_j$$\n使用给定参数 $e=8$ 和 $s_j=3$：\n$$\\Delta A_{\\text{inner}} = 8 \\cdot 3 = 24$$\n\n**情况 2：外循环转移**\n地址差为 $\\Delta A_{\\text{outer}} = A(i+1, 0) - A(i, J-1)$。\n$$\\Delta A_{\\text{outer}} = \\left[a_0 + e \\cdot ((i+1)s_ild)\\right] - \\left[a_0 + e \\cdot (is_ild + (J-1)s_j)\\right]$$\n$$\\Delta A_{\\text{outer}} = e \\cdot [(i+1)s_ild - is_ild - (J-1)s_j] = e \\cdot [s_ild - (J-1)s_j]$$\n使用参数 $e=8$, $s_i=1$, $ld=1024$, $J=50$, $s_j=3$：\n$$\\Delta A_{\\text{outer}} = 8 \\cdot [1 \\cdot 1024 - (50-1) \\cdot 3] = 8 \\cdot [1024 - 49 \\cdot 3]$$\n$$\\Delta A_{\\text{outer}} = 8 \\cdot [1024 - 147] = 8 \\cdot 877 = 7016$$\n\n现在我们计算每种转移类型下，保持在同一缓存行内的概率，其中 $C = 64$ 字节。\n\n对于内循环转移：$\\Delta A_{\\text{inner}} = 24  C = 64$。\n$$P_{\\text{same, inner}} = 1 - \\frac{\\Delta A_{\\text{inner}}}{C} = 1 - \\frac{24}{64} = 1 - \\frac{3}{8} = \\frac{5}{8}$$\n对于外循环转移：$\\Delta A_{\\text{outer}} = 7016 > C = 64$。\n$$P_{\\text{same, outer}} = \\max\\left(0, 1 - \\frac{7016}{64}\\right) = 0$$\n\n接下来，我们计算每种转移类型的发生次数。总访问次数为 $I \\cdot J = 100 \\cdot 50 = 5000$。连续对的总数为 $N_{\\text{pairs}} = I \\cdot J - 1 = 4999$。\n\n-   内循环转移的次数 $N_{\\text{inner}}$：对于 $I=100$ 行中的每一行，都有 $J-1=49$ 次转移。\n    $$N_{\\text{inner}} = I \\cdot (J-1) = 100 \\cdot 49 = 4900$$\n-   外循环转移的次数 $N_{\\text{outer}}$：这些转移发生在除最后一行外的每一行末尾。\n    $$N_{\\text{outer}} = I - 1 = 100 - 1 = 99$$\n    作为验证，$N_{\\text{inner}} + N_{\\text{outer}} = 4900 + 99 = 4999 = N_{\\text{pairs}}$。\n\n位于同一缓存行内的连续对的比例，是这类对的总期望数量除以总对数。\n同行对的期望数量是每种转移类型的次数乘以其各自概率的总和：\n$$E[\\text{Hits}] = N_{\\text{inner}} \\cdot P_{\\text{same, inner}} + N_{\\text{outer}} \\cdot P_{\\text{same, outer}}$$\n$$E[\\text{Hits}] = 4900 \\cdot \\frac{5}{8} + 99 \\cdot 0 = \\frac{24500}{8} = 3062.5$$\n这个比例 $F$ 是此期望数量除以总对数：\n$$F = \\frac{E[\\text{Hits}]}{N_{\\text{pairs}}} = \\frac{3062.5}{4999}$$\n$$F \\approx 0.6126225245...$$\n四舍五入到 $5$ 位有效数字，我们得到 $0.61262$。",
            "answer": "$$\\boxed{0.61262}$$"
        },
        {
            "introduction": "在理解了缓存行的基础之上，我们现在将目光投向整个缓存的容量。这个练习引入了“工作集”（working set）的概念以及“分块”（tiling/blocking）这一强大的优化技术。通过为矩阵转置推导最优的分块尺寸，你将学会如何对问题进行划分，以确保计算所需的核心数据能够完全驻留在缓存中，从而最大限度地减少代价高昂的容量未命中（capacity misses）。 ",
            "id": "3542785",
            "problem": "考虑一个稠密矩阵的分块转置操作，从输入矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 到输出矩阵 $B \\in \\mathbb{R}^{n \\times n}$，两者均以行主序存储。该算法处理大小为 $b \\times b$ 的方形数据块，从 $A$ 中读取一个块 $\\mathcal{T}_A(i,j)$，并将其转置写入 $B$ 中对应的块 $\\mathcal{T}_B(j,i)$，直到整个矩阵被转置完成。每个矩阵元素占用 $s$ 字节。假设一个理想的两级存储模型，其中有一个数据缓存，该缓存是全相联的，采用最近最少使用（LRU）替换策略，总容量为 $M$ 字节。假设采用写分配、写回策略，并忽略如标签存储之类的额外元数据空间。缓存行大小在本问题中不相关；您可以以字节为粒度对容量效应进行建模，并且由于是全相联缓存，可以忽略冲突不命中。\n\n您需要从容量模型的基本原理出发进行推理：当一个计算阶段内需要重用的不同数据的集合大小超过缓存容量 $M$ 时，就会发生容量不命中。对于分块转置，假设其实现方式是这样的：在处理单个块对 $(i,j)$ 的过程中，所有的访存都局限于两个块 $\\mathcal{T}_A(i,j)$ 和 $\\mathcal{T}_B(j,i)$ 之内，直到这对块处理完成。\n\n请以闭式解的形式，推导出最优整数块大小 $b^{\\star}$（作为 $M$ 和 $s$ 的函数），该大小通过确保两个块在处理期间能同时驻留在缓存中，从而最小化容量不命中。请将您的最终答案表示为单个解析表达式。不需要进行数值计算或四舍五入。最终答案必须是单个符号数学表达式。",
            "solution": "分块转置算法处理大小为 $b \\times b$ 的数据块。在所述的理想缓存模型（全相联，采用最近最少使用（LRU）替换策略，容量为 $M$ 字节）下，容量不命中由处理单个块对期间的工作集大小决定。根据假设，该实现在转置该块对时，将其访存操作限制在两个块 $\\mathcal{T}_A(i,j)$ 和 $\\mathcal{T}_B(j,i)$ 内。\n\n我们从基本的容量原理开始：在全相联缓存和LRU策略下，如果两次使用之间引用的不同数据的总量不超过缓存容量，那么所有被重用的数据在没有被驱逐的情况下都将命中缓存。形式上，如果任何数据项的重用距离（以字节为单位）至多为 $M$，那么该数据项在被重用时将存在于缓存中，此次访问将是一次缓存命中。\n\n在当前的分块转置问题中，处理一个块对期间的工作集是两个块的并集：\n- 块 $\\mathcal{T}_A(i,j)$ 包含 $b \\times b$ 个元素，占用 $b^{2} \\cdot s$ 字节。\n- 块 $\\mathcal{T}_B(j,i)$ 包含 $b \\times b$ 个元素，占用 $b^{2} \\cdot s$ 字节。\n\n因此，要将两个块同时保留在缓存中所需的总驻留数据量为\n$$\nW(b) = b^{2} s + b^{2} s = 2 b^{2} s\n$$\n在理想容量模型下，如果 $W(b) \\leq M$，那么一旦这两个块被加载到缓存中，LRU策略将保留它们直到处理完成，并且块内部的大多数访问都将作为缓存命中来处理（在初始的强制性加载或写分配行填充之后）。如果 $W(b)  M$，缓存无法同时容纳两个块，LRU策略将在访问一个块时驱逐另一个块的某些部分，从而导致重复的容量不命中和缓存颠簸。\n\n为了在块计算期间最小化容量不命中，应该选择能使两个块都能装入缓存的最大的 $b$，即满足 $W(b) \\leq M$。这得到了不等式\n$$\n2 b^{2} s \\leq M\n$$\n解出 $b$ 可得\n$$\nb^{2} \\leq \\frac{M}{2 s}\n\\qquad\\Longrightarrow\\qquad\nb \\leq \\sqrt{\\frac{M}{2 s}}\n$$\n由于 $b$ 必须是正整数，因此在容量约束下最大化 $b$ 的最优选择 $b^{\\star}$ 是\n$$\nb^{\\star} = \\left\\lfloor \\sqrt{\\frac{M}{2 s}} \\right\\rfloor\n$$\n该表达式确保了两个 $b \\times b$ 的块最多占用 $M$ 字节，因此在LRU策略下，它们可以在整个处理过程中被保留在缓存中，从而最小化分块转置中的容量不命中。",
            "answer": "$$\\boxed{\\left\\lfloor \\sqrt{\\frac{M}{2 s}} \\right\\rfloor}$$"
        },
        {
            "introduction": "现在，我们将把所学知识应用于科学计算中最关键的操作之一：通用矩阵乘法（GEMM）。这个高级练习模拟了一个结合了缓存感知分块与寄存器级优化的真实场景。通过确定一个能够在三个不同矩阵的内存占用之间取得平衡的最优块大小 $b^{\\\\star}$，你将看到这些原理如何被综合运用来实现复杂计算密集型核心程序（kernel）的峰值性能。 ",
            "id": "3542772",
            "problem": "考虑稠密通用矩阵-矩阵乘法 (GEMM) 操作 $C \\leftarrow C + AB$，作用于维度为 $n \\times n$ 的方阵，该操作通过一个三循环算法实现，并使用缓存感知分块和常驻寄存器的微内核进行增强，具体如下。计算被组织成大小为 $b \\times b$ 的外层块，用于处理子矩阵 $C[I:I+b-1,\\,J:J+b-1]$。沿 $k$ 维度的内层累加按宽度为 $r$ 的面板（寄存器分块大小为 $r$）进行。这样，对于每个 $k$ 面板，一个大小为 $b \\times r$ 的 $A$ 面板和一个大小为 $r \\times b$ 的 $B$ 面板会在更新 $C$ 的 $r \\times r$ 常驻寄存器微内核的所有调用中被重用。\n\n假设使用以下执行和内存模型：\n- 一级（L$1$）缓存的容量为 $M_1$ 字节，是采用最近最少使用（LRU）替换策略的全相联缓存，并且除了容量限制所隐含的未命中外，不产生冲突或强制性未命中。\n- 每个矩阵元素占用 $s$ 字节（例如，对于双精度浮点数，$s=8$）。L$1$ 缓存的一个固定比例 $\\phi \\in (0,1)$ 可用于当前 $k$ 面板更新的三个工作数据结构：大小为 $b \\times r$ 的 $A$ 面板，大小为 $r \\times b$ 的 $B$ 面板，以及大小为 $b \\times b$ 的 $C$ 块。缓存的剩余部分保留给代码、堆栈和不相关的数据。\n- 在最内层计算期间，$C$ 的 $r \\times r$ 微块保存在寄存器中，但完整的 $b \\times b$ 的 $C$ 块必须在给定的 $k$ 面板内的微块扫描过程中常驻于 L$1$ 缓存，以避免自我驱逐，从而最大限度地重用 L$1$ 缓存内的 $A$ 和 $B$ 面板。\n- 为分析目的，忽略对 $b$ 和 $r$ 的整数约束，并忽略写分配开销和缓存行效应。\n\n仅从这些假设以及关于工作集容量和重用的第一性原理出发，推导出一个容量约束，该约束保证在一次 $k$ 面板更新期间，$A$ 面板、$B$ 面板和 $C$ 块能够同时常驻于 L$1$ 缓存。然后，利用此约束，确定在固定寄存器分块大小 $r$ 的情况下，能够使 L$1$ 级重用最大化（等效于使 L$1$ 级的计算强度最大化）的块大小 $b$ 的值。\n\n请以 $M_1$、$r$、$s$ 和 $\\phi$ 的封闭形式解析表达式给出最优块大小 $b^{\\star}$ 的最终答案。不要对答案进行四舍五入，也请勿在最终表达式中包含单位。",
            "solution": "问题要求解分块矩阵-矩阵乘法算法 $C \\leftarrow C + AB$ 的最优块大小 $b^{\\star}$，以最大化一级（L$1$）缓存的重用。此优化是在固定寄存器分块大小 $r$ 的情况下进行的。\n\n求解过程分为三个阶段：\n1.  基于工作集的内存占用，建立 L$1$ 缓存的容量约束。\n2.  建立目标函数，即 L$1$ 的计算强度，并分析其相对于块大小 $b$ 的行为。\n3.  求解由此产生的约束优化问题，以找到最优块大小 $b^{\\star}$。\n\n**1. L$1$ 缓存容量约束**\n\n根据问题描述，单次 $k$ 面板更新需要三个数据结构同时常驻于 L$1$ 缓存：\n- 一个大小为 $b \\times r$ 的 $A$ 面板。\n- 一个大小为 $r \\times b$ 的 $B$ 面板。\n- 一个大小为 $b \\times b$ 的 $C$ 块。\n\n每个矩阵元素占用 $s$ 字节。各部分的内存占用如下：\n- $A$ 面板的内存：$M_A = (b \\times r) \\cdot s = sbr$ 字节。\n- $B$ 面板的内存：$M_B = (r \\times b) \\cdot s = srb$ 字节。\n- $C$ 块的内存：$M_C = (b \\times b) \\cdot s = sb^2$ 字节。\n\n该工作集所需的总内存是这三部分占用空间的总和：\n$$W(b, r) = M_A + M_B + M_C = sbr + srb + sb^2 = s(b^2 + 2br)$$\n问题指出，总 L$1$ 缓存容量 $M_1$ 的一部分比例 $\\phi$ 可用于这些数据结构。因此，工作集的总大小不能超过此可用容量。这给出了容量约束：\n$$s(b^2 + 2br) \\le \\phi M_1$$\n\n**2. 目标函数：L$1$ 计算强度**\n\n目标是最大化“L$1$ 级重用”。这等同于最大化 L$1$ 计算强度 $I_{L1}$，其定义为执行的浮点运算次数（FLOPS）与主存（或 L$2$ 缓存）和 L$1$ 缓存之间传输的数据量之比。\n\n我们考虑对矩阵 $C$ 的单个 $b \\times b$ 块的计算。这涉及将 $A$ 的一个 $b \\times n$ 子矩阵与 $B$ 的一个 $n \\times b$ 子矩阵相乘，并将结果累加到 $C$ 块中。此计算的总浮点运算次数为 $2nb^2$。\n\n计算这个 $C$ 块所需的 L$1$ 数据流量（未命中）由以下几部分组成：\n- 从下一级内存加载 $b \\times b$ 的 $C$ 块。该块随后保持常驻。流量：$sb^2$ 字节。\n- 加载矩阵 $A$ 和 $B$ 的必要部分。计算通过扫描 $k$ 维度进行。必须读取 $A$ 的整个 $b \\times n$ 条带和 $B$ 的整个 $n \\times b$ 条带。$A$ 的流量：$sbn$ 字节。$B$ 的流量：$snb$ 字节。\n- 将更新后的 $b \\times b$ 的 $C$ 块写回内存。流量：$sb^2$ 字节。\n\n一个 $b \\times b$ 块与更高级别内存之间的数据总移动量为：\n$$D_{L1}(b) = \\text{reads} + \\text{writes} = (sb^2 + sbn + snb) + sb^2 = s(2b^2 + 2nb)$$\n因此，L$1$ 计算强度为：\n$$I_{L1}(b) = \\frac{\\text{FLOPS}}{D_{L1}(b)} = \\frac{2nb^2}{s(2b^2 + 2nb)} = \\frac{2nb^2}{2s(b^2 + nb)} = \\frac{nb}{s(b+n)}$$\n为了找到使该函数最大化的块大小 $b$，我们分析其关于 $b$ 的导数。在寻找最优值时，可以忽略常数因子 $\\frac{n}{s}$。设 $f(b) = \\frac{b}{b+n}$。\n$$\\frac{df}{db} = \\frac{(b+n)(1) - b(1)}{(b+n)^2} = \\frac{n}{(b+n)^2}$$\n由于矩阵维度 $n$ 是正数，对于所有 $b \\ge 0$，都有 $\\frac{df}{db} > 0$。这表明计算强度 $I_{L1}(b)$ 是块大小 $b$ 的一个单调递增函数。\n\n**3. 约束优化**\n\n为了最大化单调递增的目标函数 $I_{L1}(b)$，我们必须选择满足第一节中推导的容量约束的 $b$ 的最大可能值。因此，最优块大小 $b^{\\star}$ 将是使约束变为等式时的 $b$ 值：\n$$s(b^2 + 2br) = \\phi M_1$$\n重新整理此方程得到一个关于 $b$ 的二次方程：\n$$b^2 + 2rb - \\frac{\\phi M_1}{s} = 0$$\n我们使用二次公式 $b = \\frac{-B \\pm \\sqrt{B^2 - 4AC}}{2A}$ 求解 $b$，其中系数为 $A=1$，$B=2r$，$C = -\\frac{\\phi M_1}{s}$：\n$$b = \\frac{-2r \\pm \\sqrt{(2r)^2 - 4(1)\\left(-\\frac{\\phi M_1}{s}\\right)}}{2(1)}$$\n$$b = \\frac{-2r \\pm \\sqrt{4r^2 + \\frac{4\\phi M_1}{s}}}{2}$$\n$$b = -r \\pm \\sqrt{r^2 + \\frac{\\phi M_1}{s}}$$\n由于 $b$ 代表物理块的维度，它必须是一个正数。项 $\\sqrt{r^2 + \\frac{\\phi M_1}{s}}$ 严格大于 $r$（因为 $\\phi, M_1, s$ 均为正数）。因此，我们必须选择正根以确保 $b > 0$。\n最优块大小 $b^{\\star}$ 为：\n$$b^{\\star} = \\sqrt{r^2 + \\frac{\\phi M_1}{s}} - r$$\n这个表达式代表了能使工作集容纳在可用 L$1$ 缓存内的最大可能块大小 $b$，从而在给定的算法结构下最大化 L$1$ 的重用。",
            "answer": "$$\\boxed{\\sqrt{r^{2} + \\frac{\\phi M_{1}}{s}} - r}$$"
        }
    ]
}