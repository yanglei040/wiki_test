{
    "hands_on_practices": [
        {
            "introduction": "分析预处理后的一维泊松问题是一个基础练习，它为我们理解预处理如何改变矩阵的谱性质提供了一个完美的“实验室”。这项实践将指导您推导雅可比（Jacobi）预处理系统条件数的精确解析表达式，从而将这一理论量与预处理共轭梯度法（PCG）的实际收敛速率直接联系起来。",
            "id": "3412964",
            "problem": "考虑对称正定矩阵 $A \\in \\mathbb{R}^{n \\times n}$，该矩阵来自于对一维泊松方程 $-u''(x) = f(x)$ 在区间 $[0,1]$ 上使用齐次狄利克雷边界条件、$n$ 个内部网格点和均匀步长 $h = 1/(n+1)$ 进行标准二阶中心有限差分格式离散化后得到。因此，$A = \\frac{1}{h^{2}} T$，其中 $T$ 是一个三对角托普利茨 (Toeplitz) 矩阵，其主对角线上的元素为 $2$，第一条次对角线和超对角线上的元素为 $-1$。令 $M = \\operatorname{diag}(A)$ 为雅可比预条件子。\n\n1) 从该离散化的基本原理出发，推导谱条件数 $\\kappa(M^{-1}A)$ 关于 $n$ 的一个精确的封闭形式表达式，其中对于任意对称正定矩阵 $B$，$\\kappa(B) = \\lambda_{\\max}(B) / \\lambda_{\\min}(B)$。然后将你的结果具体到 $n = 127$ 的情况，并保持表达式的精确性。\n\n2) 考虑对线性系统 $A x = b$ 应用带有预条件子 $M$ 的预条件共轭梯度 (PCG) 方法，从任意初始猜测开始。设相对 $A$-范数下的给定容差为 $\\epsilon = 10^{-6}$，即停止条件为 $\\|x_{k} - x_{\\star}\\|_{A} / \\|x_{0} - x_{\\star}\\|_{A} \\le \\epsilon$，其中 $x_{\\star}$ 是精确解，$\\|y\\|_{A} = \\sqrt{y^{\\top} A y}$ 表示 $A$-范数。仅使用从 $\\kappa(M^{-1}A)$ 推导出的最坏情况信息，预测保证达到此容差的最少 PCG 迭代次数 $k$ (整数)。将你的答案表示为一个封闭形式表达式的精确上取整，然后将其具体到 $n = 127$ 和 $\\epsilon = 10^{-6}$ 的情况。\n\n将最终答案表示为一个包含两个条目的行矩阵：第一项是 $\\kappa(M^{-1}A)$ 在 $n = 127$ 时的封闭形式表达式；第二项是在最坏情况界下，容差 $\\epsilon = 10^{-6}$ 所需的最少迭代次数 $k$ (整数)。无需单位。不要对任何非整数进行四舍五入；如果需要整数，请提供精确整数。",
            "solution": "首先验证问题，以确保其在科学上是合理的、适定的、客观的和完整的。\n\n### 步骤 1：提取已知条件\n- 矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 是对称正定 (SPD) 的，来自于对 $-u''(x) = f(x)$ 在 $[0,1]$ 上使用齐次狄利克雷边界条件进行中心有限差分格式离散化。\n- 有 $n$ 个内部网格点。\n- 网格步长是均匀的，$h = 1/(n+1)$。\n- $A = \\frac{1}{h^{2}} T$，其中 $T$ 是一个三对角托普利茨矩阵，主对角线元素为 $2$，第一条次对角线和超对角线元素为 $-1$。\n- 预条件子是雅可比预条件子，$M = \\operatorname{diag}(A)$。\n- 第 1 部分要求推导谱条件数 $\\kappa(M^{-1}A) = \\lambda_{\\max}(M^{-1}A) / \\lambda_{\\min}(M^{-1}A)$ 的封闭形式表达式，并将其具体化到 $n = 127$ 的情况。\n- 第 2 部分要求根据最坏情况收敛界，预测达到容差 $\\epsilon = 10^{-6}$ 所需的最小 PCG 迭代次数 $k$（整数）。\n- 停止准则是 $\\|x_{k} - x_{\\star}\\|_{A} / \\|x_{0} - x_{\\star}\\|_{A} \\le \\epsilon$，其中 $x_{\\star}$ 是精确解，$\\|y\\|_{A} = \\sqrt{y^{\\top} A y}$ 是 $A$-范数。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学基础：** 该问题是数值线性代数中的一个标准练习，涉及分析一个由著名偏微分方程（一维泊松方程）离散化产生的预处理系统。所有概念都是数值分析的基础。\n- **适定性：** 问题定义清晰。矩阵 $A$ 已知是 SPD，确保其对角元为正，这又意味着雅可比预条件子 $M$ 是 SPD 且可逆的。$M^{-1}A$ 的特征值是实数且为正，使得条件数是良定义的。PCG 迭代次数基于标准的先验误差界。存在唯一且有意义的解。\n- **客观性：** 问题使用精确、无歧义的数学语言陈述。\n- **完整性和一致性：** 提供了所有必要的定义和值（例如，$A$ 的结构、$M$ 的定义、用于具体化的 $n$ 和 $\\epsilon$ 的值）。没有矛盾之处。\n\n### 步骤 3：结论与行动\n该问题是有效的。将提供一个完整的解答。\n\n### 第 1 部分：谱条件数 $\\kappa(M^{-1}A)$ 的推导\n\n矩阵 $A$ 由 $A = \\frac{1}{h^2} T$ 给出，其中 $T$ 是 $n \\times n$ 矩阵：\n$$\nT = \\begin{pmatrix}\n2  -1    \\\\\n-1  2  -1   \\\\\n \\ddots  \\ddots  \\ddots  \\\\\n  -1  2  -1 \\\\\n   -1  2\n\\end{pmatrix}\n$$\n雅可比预条件子 $M$ 是 $A$ 的对角部分。由于 $T$ 的每个对角元都是 $2$，所以 $A$ 的每个对角元都是 $2/h^2$。因此，$M$ 是一个对角矩阵：\n$$\nM = \\operatorname{diag}(A) = \\frac{2}{h^2} I\n$$\n其中 $I$ 是 $n \\times n$ 的单位矩阵。$M$ 的逆矩阵是：\n$$\nM^{-1} = \\frac{h^2}{2} I\n$$\n现在，我们可以构建预处理矩阵 $M^{-1}A$：\n$$\nM^{-1}A = \\left(\\frac{h^2}{2} I\\right) \\left(\\frac{1}{h^2} T\\right) = \\frac{1}{2} T\n$$\n因此，$M^{-1}A$ 的特征值是 $T$ 的特征值的一半。矩阵 $T$ 的特征值是数值分析中的一个标准结果。对于这种形式的 $n \\times n$ 矩阵，其特征值 $\\mu_j$ 由下式给出：\n$$\n\\mu_j = 2 - 2\\cos\\left(\\frac{j\\pi}{n+1}\\right) \\quad \\text{for } j = 1, 2, \\ldots, n\n$$\n使用半角恒等式 $1 - \\cos(\\theta) = 2\\sin^2(\\theta/2)$，我们可以将其重写为：\n$$\n\\mu_j = 4\\sin^2\\left(\\frac{j\\pi}{2(n+1)}\\right) \\quad \\text{for } j = 1, 2, \\ldots, n\n$$\n那么 $M^{-1}A = \\frac{1}{2}T$ 的特征值 $\\lambda_j$ 是：\n$$\n\\lambda_j = \\frac{1}{2}\\mu_j = 2\\sin^2\\left(\\frac{j\\pi}{2(n+1)}\\right) \\quad \\text{for } j = 1, 2, \\ldots, n\n$$\n正弦函数在区间 $(0, \\pi/2)$ 上是严格递增的。对于 $j=1, \\ldots, n$，正弦函数的自变量 $\\frac{j\\pi}{2(n+1)}$ 都落在此区间内。因此，$M^{-1}A$ 的最小特征值对应于 $j=1$，最大特征值对应于 $j=n$。\n$$\n\\lambda_{\\min}(M^{-1}A) = \\lambda_1 = 2\\sin^2\\left(\\frac{\\pi}{2(n+1)}\\right)\n$$\n$$\n\\lambda_{\\max}(M^{-1}A) = \\lambda_n = 2\\sin^2\\left(\\frac{n\\pi}{2(n+1)}\\right)\n$$\n谱条件数 $\\kappa(M^{-1}A)$ 是最大特征值与最小特征值的比值：\n$$\n\\kappa(M^{-1}A) = \\frac{\\lambda_{\\max}(M^{-1}A)}{\\lambda_{\\min}(M^{-1}A)} = \\frac{2\\sin^2\\left(\\frac{n\\pi}{2(n+1)}\\right)}{2\\sin^2\\left(\\frac{\\pi}{2(n+1)}\\right)} = \\frac{\\sin^2\\left(\\frac{n\\pi}{2(n+1)}\\right)}{\\sin^2\\left(\\frac{\\pi}{2(n+1)}\\right)}\n$$\n我们可以使用恒等式 $\\sin(\\theta) = \\cos(\\pi/2 - \\theta)$ 来化简分子：\n$$\n\\sin\\left(\\frac{n\\pi}{2(n+1)}\\right) = \\sin\\left(\\frac{(n+1-1)\\pi}{2(n+1)}\\right) = \\sin\\left(\\frac{\\pi}{2} - \\frac{\\pi}{2(n+1)}\\right) = \\cos\\left(\\frac{\\pi}{2(n+1)}\\right)\n$$\n将此代入条件数的表达式中，得到：\n$$\n\\kappa(M^{-1}A) = \\frac{\\cos^2\\left(\\frac{\\pi}{2(n+1)}\\right)}{\\sin^2\\left(\\frac{\\pi}{2(n+1)}\\right)} = \\cot^2\\left(\\frac{\\pi}{2(n+1)}\\right)\n$$\n这就是条件数关于 $n$ 的封闭形式表达式。\n\n对于 $n=127$ 的特定情况，我们有 $n+1=128$。条件数为：\n$$\n\\kappa(M^{-1}A) = \\cot^2\\left(\\frac{\\pi}{2(128)}\\right) = \\cot^2\\left(\\frac{\\pi}{256}\\right)\n$$\n\n### 第 2 部分：PCG 迭代次数\n\n用于求解带有预条件子 $M$ 的方程组 $Ax=b$ 的预条件共轭梯度 (PCG) 方法的收敛性由预处理矩阵的条件数 $\\kappa \\equiv \\kappa(M^{-1}A)$ 决定。$A$-范数下误差的标准最坏情况界由下式给出：\n$$\n\\frac{\\|x_k - x_{\\star}\\|_{A}}{\\|x_0 - x_{\\star}\\|_{A}} \\le 2\\left(\\frac{\\sqrt{\\kappa} - 1}{\\sqrt{\\kappa} + 1}\\right)^k\n$$\n我们想要找到满足停止准则的最小整数 $k$：\n$$\n2\\left(\\frac{\\sqrt{\\kappa} - 1}{\\sqrt{\\kappa} + 1}\\right)^k \\le \\epsilon\n$$\n为了求解 $k$，我们首先分离出 $k$ 次方的项：\n$$\n\\left(\\frac{\\sqrt{\\kappa} - 1}{\\sqrt{\\kappa} + 1}\\right)^k \\le \\frac{\\epsilon}{2}\n$$\n对两边取自然对数。由于 $\\frac{\\sqrt{\\kappa} - 1}{\\sqrt{\\kappa} + 1}  1$，其对数为负，因此在除法后不等式反向：\n$$\nk \\ln\\left(\\frac{\\sqrt{\\kappa} - 1}{\\sqrt{\\kappa} + 1}\\right) \\le \\ln\\left(\\frac{\\epsilon}{2}\\right)\n$$\n$$\nk \\ge \\frac{\\ln(\\epsilon/2)}{\\ln\\left(\\frac{\\sqrt{\\kappa} - 1}{\\sqrt{\\kappa} + 1}\\right)} = \\frac{\\ln(2/\\epsilon)}{\\ln\\left(\\frac{\\sqrt{\\kappa} + 1}{\\sqrt{\\kappa} - 1}\\right)}\n$$\n最小整数 $k$ 是该表达式的上取整：\n$$\nk = \\left\\lceil \\frac{\\ln(2/\\epsilon)}{\\ln\\left(\\frac{\\sqrt{\\kappa} + 1}{\\sqrt{\\kappa} - 1}\\right)} \\right\\rceil\n$$\n现在我们具体到 $n = 127$ 和 $\\epsilon = 10^{-6}$ 的情况。从第 1 部分可知，$\\kappa = \\cot^2\\left(\\frac{\\pi}{256}\\right)$。因此，$\\sqrt{\\kappa} = \\cot\\left(\\frac{\\pi}{256}\\right)$，因为自变量在 $(0, \\pi/2)$ 区间内。\n将这些值代入 $k$ 的表达式中：\n$$\nk = \\left\\lceil \\frac{\\ln(2/10^{-6})}{\\ln\\left(\\frac{\\cot(\\pi/256) + 1}{\\cot(\\pi/256) - 1}\\right)} \\right\\rceil = \\left\\lceil \\frac{\\ln(2 \\times 10^6)}{\\ln\\left(\\frac{\\cot(\\pi/256) + 1}{\\cot(\\pi/256) - 1}\\right)} \\right\\rceil\n$$\n我们现在计算上取整函数内部表达式的值。\n分子是 $\\ln(2 \\times 10^6) = \\ln(2) + 6\\ln(10) \\approx 0.693147 + 6 \\times 2.302585 \\approx 14.508657$。\n余切函数的自变量是 $\\theta = \\pi/256 \\approx 0.0122718$ 弧度。\n所以，$\\sqrt{\\kappa} = \\cot(\\pi/256) \\approx 81.48735$。\n分母是 $\\ln\\left(\\frac{81.48735 + 1}{81.48735 - 1}\\right) = \\ln\\left(\\frac{82.48735}{80.48735}\\right) \\approx \\ln(1.024848) \\approx 0.024549$。\n该比值为 $\\frac{14.508657}{0.024549} \\approx 591.011$。\n最小整数迭代次数是该值的上取整：\n$$\nk = \\lceil 591.011 \\ldots \\rceil = 592\n$$",
            "answer": "$$\n\\boxed{\\begin{pmatrix} \\cot^{2}\\left(\\frac{\\pi}{256}\\right)  592 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "在分析了特定模型问题之后，我们现在将研究雅可比预处理对更广泛矩阵类别的有效性。这项练习聚焦于严格对角占优矩阵，这种结构在科学计算应用中频繁出现。通过将条件数推导为矩阵对角占优程度的函数，您将从第一性原理的层面更深入地理解雅可比预处理为何以及何时能保证有效。",
            "id": "3566253",
            "problem": "考虑一类具有非正非对角元的实对称严格对角占优矩阵，其描述如下。固定一个整数维度 $n \\geq 3$ 和一个参数 $0  \\sigma  1$。此参数用于量化统一的非对角强度，即对于每一行 $i$，比率 $\\sum_{j \\neq i} |a_{ij}| / a_{ii}$ 等于 $\\sigma$。定义矩阵 $A \\in \\mathbb{R}^{n \\times n}$，其元素为 $a_{ii} = d  0$ 且对所有 $i \\neq j$ 有 $a_{ij} = -\\dfrac{\\sigma d}{n-1}$。令 $M = \\mathrm{diag}(A)$ 表示雅可比预处理器，因此 $M^{-1}A$ 是雅可比预处理后的矩阵。从严格对角占优、雅可比预处理和 $2$-范数条件数的基本定义出发，推导 $2$-范数条件数 $\\kappa_{2}\\!\\left(M^{-1}A\\right)$ 作为 $n$ 和 $\\sigma$ 的函数的闭式表达式。在您的推导中，量化 $\\sigma$ 如何影响 $M^{-1}A$ 的谱，并从第一性原理出发，解释使雅可比预处理对对称严格对角占优问题有效的结构性条件。以闭式形式给出 $\\kappa_{2}\\!\\left(M^{-1}A\\right)$ 的最终表达式。不需要进行数值舍入。",
            "solution": "该问题要求推导雅可比预处理矩阵 $M^{-1}A$ 的 $2$-范数条件数的闭式表达式，其中 $A$ 属于一类特定的对称、严格对角占优矩阵。此外，还需要对预处理的有效性进行定性解释。\n\n首先，对问题陈述进行验证。\n已知条件如下：\n- 矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 的元素为 $a_{ii} = d  0$ 且对 $i \\neq j$ 有 $a_{ij} = -\\dfrac{\\sigma d}{n-1}$。\n- 维度为整数 $n \\geq 3$。\n- 参数 $\\sigma$ 满足 $0  \\sigma  1$。\n- 给定的非对角强度条件为 $\\sum_{j \\neq i} |a_{ij}| / a_{ii} = \\sigma$。\n- 预处理器是雅可比预处理器 $M = \\mathrm{diag}(A)$。\n- 目标表达式为 $\\kappa_{2}\\!\\left(M^{-1}A\\right)$。\n\n让我们验证矩阵 $A$ 的性质。\n1.  对称性：对于 $i \\neq j$，$a_{ij} = -\\frac{\\sigma d}{n-1}$ 且 $a_{ji} = -\\frac{\\sigma d}{n-1}$。因此，$a_{ij} = a_{ji}$，$A$ 是对称矩阵。\n2.  非正非对角元：对于 $i \\neq j$，$a_{ij} = -\\frac{\\sigma d}{n-1}$。因为 $\\sigma0$，$d0$ 且 $n \\geq 3$ (因此 $n-10$)，我们有 $a_{ij}  0$。此条件成立。\n3.  严格对角占优：我们必须检查是否对所有 $i$ 都有 $|a_{ii}|  \\sum_{j \\neq i} |a_{ij}|$。\n    - $|a_{ii}| = d$。\n    - $\\sum_{j \\neq i} |a_{ij}| = \\sum_{j \\neq i} \\left|-\\frac{\\sigma d}{n-1}\\right| = \\sum_{j \\neq i} \\frac{\\sigma d}{n-1}$。由于对于固定的 $i$，求和中有 $n-1$ 项，所以这个和是 $(n-1) \\left(\\frac{\\sigma d}{n-1}\\right) = \\sigma d$。\n    - 严格对角占优的条件是 $d  \\sigma d$。由于 $d0$，这等价于 $1  \\sigma$。这在问题陈述中已经给出 ($0  \\sigma  1$)。\n4.  指定的比率条件通过构造得到满足：$\\frac{\\sum_{j \\neq i} |a_{ij}|}{a_{ii}} = \\frac{\\sigma d}{d} = \\sigma$。\n\n问题是适定的、内部一致的，并基于标准的数值线性代数原理。我们可以继续求解。\n\n雅可比预处理器是 $A$ 的对角部分，$M = \\mathrm{diag}(A)$。由于对所有 $i$ 都有 $a_{ii} = d$，所以 $M$ 是一个标量矩阵 $M = dI$，其中 $I$ 是 $n \\times n$ 的单位矩阵。\n预处理器的逆是 $M^{-1} = \\frac{1}{d}I$。\n预处理后的矩阵是 $B = M^{-1}A = \\left(\\frac{1}{d}I\\right)A = \\frac{1}{d}A$。\n$B$ 的元素由 $b_{ij} = \\frac{1}{d}a_{ij}$ 给出。\n- 对于对角元素 ($i=j$)：$b_{ii} = \\frac{1}{d}a_{ii} = \\frac{1}{d}d = 1$。\n- 对于非对角元素 ($i \\neq j$)：$b_{ij} = \\frac{1}{d}a_{ij} = \\frac{1}{d}\\left(-\\frac{\\sigma d}{n-1}\\right) = -\\frac{\\sigma}{n-1}$。\n\n因此，矩阵 $B = M^{-1}A$ 的所有对角元素都等于 $1$，所有非对角元素都等于常数 $c = -\\frac{\\sigma}{n-1}$。这是一个特殊的结构，允许我们解析地确定其特征值。矩阵 $B$ 可以写成一个缩放单位矩阵的秩一更新：\n$$B = I + c(J-I) = (1-c)I + cJ$$\n其中 $J$ 是 $n \\times n$ 的全一矩阵。\n\n$J$ 的特征值是众所周知的。矩阵 $J$ 的秩为 $1$，其像空间由向量 $\\mathbf{1} = (1, 1, ..., 1)^T$ 张成。我们有 $J\\mathbf{1} = n\\mathbf{1}$，所以 $\\lambda=n$ 是 $J$ 的一个特征值。$J$ 的零空间维度为 $n-1$，对应于一个重数为 $n-1$ 的特征值 $\\lambda=0$。对应 $\\lambda=0$ 的特征向量是所有其分量之和为零的向量 $v$，即 $\\sum_{i=1}^n v_i = 0$。\n\n如果 $v$ 是 $J$ 的一个特征向量，其特征值为 $\\lambda_J$，那么它也是 $B$ 的一个特征向量：\n$$Bv = ((1-c)I + cJ)v = (1-c)v + c(Jv) = (1-c)v + c(\\lambda_J v) = ((1-c) + c\\lambda_J)v$$\n因此，$B$ 的特征值（记为 $\\lambda_B$）由 $\\lambda_B = (1-c) + c\\lambda_J$ 给出。\n\n使用 $J$ 的特征值：\n1.  对于特征值 $\\lambda_J = n$（重数为 $1$）：\n    $B$ 对应的特征值为 $\\lambda_1 = (1-c) + cn = 1 + c(n-1)$。\n    代入 $c = -\\frac{\\sigma}{n-1}$：\n    $$\\lambda_1 = 1 + \\left(-\\frac{\\sigma}{n-1}\\right)(n-1) = 1 - \\sigma$$\n2.  对于特征值 $\\lambda_J = 0$（重数为 $n-1$）：\n    $B$ 对应的特征值为 $\\lambda_2 = (1-c) + c(0) = 1-c$。\n    代入 $c = -\\frac{\\sigma}{n-1}$：\n    $$\\lambda_2 = 1 - \\left(-\\frac{\\sigma}{n-1}\\right) = 1 + \\frac{\\sigma}{n-1}$$\n\n$M^{-1}A$ 的谱由这两个不同的值组成。由于 $0  \\sigma  1$ 且 $n \\geq 3$：\n- $0  1-\\sigma  1$。\n- $1  1 + \\frac{\\sigma}{n-1}  1 + \\sigma$。\n比较它们，$1 - \\sigma  1 + \\frac{\\sigma}{n-1}$，因为 $-\\sigma  \\frac{\\sigma}{n-1}$ 等价于 $-1  \\frac{1}{n-1}$，这对 $n \\geq 3$ 成立。\n因此，$M^{-1}A$ 的最小和最大特征值是：\n$$\\lambda_{\\min}\\left(M^{-1}A\\right) = 1 - \\sigma$$\n$$\\lambda_{\\max}\\left(M^{-1}A\\right) = 1 + \\frac{\\sigma}{n-1}$$\n由于 $A$ 和 $M=dI$ 都是对称的，预处理后的矩阵 $B=M^{-1}A = (\\frac{1}{d})A$ 也是对称的。对于一个对称正定矩阵（所有特征值均为正，此条件在此成立，因为 $1-\\sigma  0$），其 $2$-范数条件数是最大特征值与最小特征值的比率。\n$$\\kappa_{2}\\!\\left(M^{-1}A\\right) = \\frac{\\lambda_{\\max}\\left(M^{-1}A\\right)}{\\lambda_{\\min}\\left(M^{-1}A\\right)} = \\frac{1 + \\frac{\\sigma}{n-1}}{1 - \\sigma}$$\n将其写成一个单独的分数：\n$$\\kappa_{2}\\!\\left(M^{-1}A\\right) = \\frac{\\frac{n-1+\\sigma}{n-1}}{1-\\sigma} = \\frac{n-1+\\sigma}{(n-1)(1-\\sigma)}$$\n\n现在，我们来回答问题的定性部分。\n\n$\\sigma$ 对 $M^{-1}A$ 谱的影响：\n参数 $\\sigma$ 直接控制 $M^{-1}A$ 特征值的分布范围。其谱由 $\\{1-\\sigma, 1+\\frac{\\sigma}{n-1}\\}$ 组成。\n- 当 $\\sigma \\to 0$ 时（更强的对角占优），$\\lambda_{\\min} \\to 1$ 且 $\\lambda_{\\max} \\to 1$。谱收缩到单一值 $1$。预处理后的矩阵趋近于单位矩阵，这对于迭代法是理想情况。\n- 当 $\\sigma \\to 1$ 时（更弱的对角占优），$\\lambda_{\\min} \\to 0$ 且 $\\lambda_{\\max} \\to 1+\\frac{1}{n-1}$。特征值范围 $\\lambda_{\\max}-\\lambda_{\\min}$ 趋近其最大值 $1+\\frac{1}{n-1} = \\frac{n}{n-1}$。这导致条件数发散。\n总之，$\\sigma$ 量化了预处理后谱与理想状态（所有特征值等于 $1$）的偏离程度。\n\n从第一性原理对雅可比预处理有效性的解释：\n解决 $Ax=b$ 问题的预处理器 $M$ 的有效性取决于预处理后的矩阵 $M^{-1}A$ 与单位矩阵 $I$ 的“接近”程度。对于对称正定矩阵，这通过条件数 $\\kappa_2(M^{-1}A)$ 来衡量，该值应尽可能接近 $1$。\n使雅可比预处理对此类问题有效的结构性条件是严格对角占优。\n1.  雅可比预处理器 $M = \\mathrm{diag}(A)$ 的设计目的是将系统矩阵的对角线归一化。预处理后的矩阵 $M^{-1}A$ 的元素为 $(M^{-1}A)_{ij} = a_{ij}/a_{ii}$。根据构造，其所有对角元素都为 $1$。\n2.  $A$ 的严格对角占优条件 $|a_{ii}|  \\sum_{j \\neq i} |a_{ij}|$，可以通过除以 $|a_{ii}| = a_{ii}$ 重写为：$1  \\sum_{j \\neq i} |a_{ij}/a_{ii}|$。\n3.  令 $B=M^{-1}A$。条件变为 $1  \\sum_{j \\neq i} |b_{ij}|$。\n4.  根据盖尔圆定理 (Gershgorin's Circle Theorem)，$B$ 的每个特征值 $\\lambda$ 必须位于复平面中至少一个圆盘内，该圆盘以 $b_{ii}$ 为中心，半径为 $R_i = \\sum_{j \\neq i} |b_{ij}|$。在我们的例子中，对所有 $i$ 都有 $b_{ii}=1$，半径为 $R_i = \\sum_{j \\neq i} |a_{ij}/a_{ii}| = \\sigma$。\n5.  因此，对于 $M^{-1}A$ 的任意特征值 $\\lambda$，我们有 $|\\lambda - 1| \\leq \\sigma$。这将所有特征值限制在实数区间 $[1-\\sigma, 1+\\sigma]$ 内。\n6.  由于 $0\\sigma1$，所有特征值都是正的，并且条件数有界：$\\kappa_2(M^{-1}A) \\leq \\frac{1+\\sigma}{1-\\sigma}$。\n这个界限表明，如果 $\\sigma$ 很小（即矩阵是强对角占优的），预处理后系统的特征值会紧密地聚集在 $1$ 附近，从而导致小的条件数和迭代方法（如共轭梯度法）的快速收敛。雅可比预处理器之所以有效，是因为严格对角占优的性质保证了这种聚集性。我们的精确计算结果 $\\kappa_{2}\\!\\left(M^{-1}A\\right) = \\frac{1+\\sigma/(n-1)}{1-\\sigma}$ 提供了一个更紧的界限和结果，从而加强了这一结论。",
            "answer": "$$\\boxed{\\frac{n-1+\\sigma}{(n-1)(1-\\sigma)}}$$"
        },
        {
            "introduction": "理论分析至关重要，但实际操作中也存在陷阱。这个计算练习旨在解决一个常见但关键的错误：以破坏共轭梯度法算子对称性的方式应用预处理器。通过一个精心构建的例子，您将观察到当算子非对称时CG算法的崩溃，并将其与正确实现的、保持对称性的PCG的成功收敛进行对比，从而巩固应用预处理迭代法时不可违背的核心要求。",
            "id": "3566284",
            "problem": "要求您构建并分析一个计算示例，以展示在数值线性代数中，迭代方法使用保对称预处理的必要性。重点在于共轭梯度（CG）法、预处理共轭梯度（PCG）法，以及将非对称预处理器应用于对称正定（SPD）线性系统所产生的影响。\n\n从以下基本概念出发：\n- 矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 是对称正定（SPD）的定义是：对于所有非零 $x \\in \\mathbb{R}^{n}$，满足 $A = A^{\\top}$ 且 $x^{\\top} A x \\gt 0$。\n- 共轭梯度（CG）法是为SPD算子推导的，这一要求确保了当算子为SPD时，存在定义明确的搜索方向和正步长。\n- 观察到使用任意可逆矩阵 $M$ 进行朴素左预处理，会将SPD算子 $A$ 替换为 $M^{-1} A$，而后者可能不是对称的（也可能无法定义一个有效的能量泛函），从而使CG方法的基本假设失效。\n- 预处理共轭梯度（PCG）法要求预处理器 $M$ 本身是SPD，并以保对称的方式使用，从而使得算子保持为 $A$，同时通过 $M^{-1}$ 的作用修改内积和残差更新，维持关键量的正定性。\n\n任务：\n1. 从标准的 $2$ 维离散拉普拉斯算子，在均匀 $n \\times n$ 网格上使用狄利克雷边界条件，构建一个SPD矩阵 $A$。使用五点差分格式形成维度为 $N = n^2$ 的矩阵 $A$，其主对角线元素为 $4$，对应网格邻居的非对角线元素为 $-1$（不涉及物理单位）。\n2. 定义一个非对称预处理器 $M = A J$，其中 $J \\in \\mathbb{R}^{N \\times N}$ 是一个块对角矩阵，其对角线上重复排列着 $2 \\times 2$ 的旋转 $90^\\circ$ 块 $K = \\begin{bmatrix} 0  1 \\\\ -1  0 \\end{bmatrix}$。注意 $J$ 是正交且斜对称的，因此 $J^{-1} = J^{\\top} = -J$，而朴素左预处理算子 $B = M^{-1} A = J^{-1}$ 是斜对称的。解释为什么直接在左预处理系统 $B x = M^{-1} b$ 上运行CG会违反SPD要求，并通过步长分母 $p^{\\top} B p$ 导致算法崩溃，因为当 $B$ 是斜对称时，对于任何非零 $p$，该分母都等于 $0$。\n3. 实现一个使用SPD预处理器的保对称PCG。使用一个对角（雅可比）预处理器 $M_{\\mathrm{sym}} = \\mathrm{diag}(A)$，对于给定的 $A$，该预处理器是SPD的。在此配置中，保持 $A$ 作为算子，并使用预处理残差 $z_k = M_{\\mathrm{sym}}^{-1} r_k$ 来应用PCG，确保诸如 $r_k^{\\top} z_k \\gt 0$ 的正不变量和基于 $p_k^{\\top} A p_k \\gt 0$ 的定义明确的步长 $\\alpha_k$。\n4. 作为基准，对 $A$ 运行普通CG（等同于使用单位预处理器的PCG）。\n\n对于所有任务，使用右端项 $b = \\mathbf{1} \\in \\mathbb{R}^{N}$（一个全为1的向量）。使用 $n = 10$，因此维度为 $N = 100$。使用相对残差容差 $\\varepsilon = 10^{-10}$ 和最大迭代次数 $500$。\n\n设计一个包含三种情况的测试套件：\n- 情况 $1$：将朴素左预处理CG应用于 $B = M^{-1} A$，其中 $M = A J$ 是非对称的。如果步长分母 $p^{\\top} B p$ 非正或数值上为零（即 $|p^{\\top} B p| \\leq \\delta$，其中 $\\delta$ 很小），则检测到算法崩溃，并返回一个哨兵结果。\n- 情况 $2$：将保对称PCG应用于 $A$，使用SPD预处理器 $M_{\\mathrm{sym}} = \\mathrm{diag}(A)$；当相对残差 $\\|r_k\\|_2 / \\|b\\|_2 \\leq \\varepsilon$ 时停止，并报告迭代次数。\n- 情况 $3$：将普通CG应用于 $A$，使用单位预处理器；在相同标准下停止，并报告迭代次数。\n\n输出规范：\n- 对于每个测试用例，返回一个整数：\n    - 对于情况 $1$：如果在收敛前检测到崩溃，返回 $-1$；否则返回达到容差时的迭代次数（由于 $B$ 是斜对称的特定构造，预期结果应为 $-1$）。\n    - 对于情况 $2$：返回PCG达到容差所需的迭代次数。\n    - 对于情况 $3$：返回普通CG达到容差所需的迭代次数。\n- 您的程序应生成单行输出，其中包含三个整数结果，以逗号分隔并用方括号括起，例如，$\\left[ r_1, r_2, r_3 \\right]$ 以文本形式呈现为 \"[r1,r2,r3]\"。\n\n约束：\n- 仅使用精确的浮点算术和线性代数运算；无外部随机性。\n- 通过保护CG迭代中的分母来确保数值稳定性，并通过 $B$ 的斜对称性为情况1确定性地定义崩溃。\n\n最终程序必须是完整的，无需用户输入即可运行，并且必须使用指定的参数实现这三种情况，以指定的格式返回结果。",
            "solution": "该问题陈述被评估为有效。它在数值线性代数方面有科学依据，问题定义明确，客观且内部一致。所有构建和执行此计算实验所需的数据和定义均已提供。\n\n目标是展示在使用共轭梯度（CG）法时，保对称预处理的必要性。我们将比较三种情景：（1）一种导致算法崩溃的朴素、非对称预处理方案，（2）一种正确的、保对称的预处理方案（PCG），以及（3）作为基准的标准、未预处理的CG方法。\n\n### 系统、向量和参数\n待求解的线性系统是 $Ax=b$。\n- 矩阵 $A \\in \\mathbb{R}^{N \\times N}$ 代表在均匀 $n \\times n$ 网格上使用狄利克雷边界条件的二维负拉普拉斯算子的五点有限差分格式。网格尺寸为 $n=10$，因此矩阵维度为 $N = n^2 = 100$。矩阵 $A$ 的主对角线元素为 $4$，对应网格中四个相邻邻居的非对角线元素为 $-1$。这种构造确保了 $A$ 是对称正定（SPD）的，这是标准CG方法收敛的基本要求。\n- 右端向量为 $b = \\mathbf{1} \\in \\mathbb{R}^{N}$，一个全为1的向量。\n- 解的初始猜测为 $x_0 = \\mathbf{0} \\in \\mathbb{R}^{N}$。\n- 当相对残差范数满足 $\\|r_k\\|_2 / \\|b\\|_2 \\leq \\varepsilon$ 时，迭代方法终止，其中容差为 $\\varepsilon = 10^{-10}$。最大迭代次数设置为 $500$。\n\n### 情况1：使用非对称预处理器的朴素左预处理CG\n这种情况说明了当CG的核心假设被违反时，它是如何失效的。我们对一个朴素左预处理系统应用CG。\n预处理器定义为 $M = AJ$，其中 $J \\in \\mathbb{R}^{N \\times N}$ 是一个由 $N/2 = 50$ 个 $2 \\times 2$ 斜对称旋转矩阵 $K = \\begin{bmatrix} 0  1 \\\\ -1  0 \\end{bmatrix}$ 组成的块对角矩阵。\n\n首先，我们分析 $J$ 的性质：\n1.  **斜对称性**：$K$ 的转置是 $K^{\\top} = \\begin{bmatrix} 0  -1 \\\\ 1  0 \\end{bmatrix} = -K$。由于 $J$ 是由 $K$ 块组成的块对角矩阵，所以 $J^{\\top}$ 是由 $K^{\\top}$ 块组成的块对角矩阵，这意味着 $J^{\\top} = -J$。因此，$J$ 是斜对称的。\n2.  **正交性**：我们计算 $K K^{\\top} = K(-K) = -K^2 = -\\begin{bmatrix} -1  0 \\\\ 0  -1 \\end{bmatrix} = I_2$。由于 $J J^{\\top}$ 是由 $K K^{\\top}$ 块组成的块对角矩阵，所以 $J J^{\\top} = I_N$。因此，$J$ 是一个正交矩阵，其逆是其转置，即 $J^{-1} = J^{\\top}$。\n\n结合这些性质，我们发现 $J^{-1} = J^{\\top} = -J$。\n\n左预处理系统为 $M^{-1} A x = M^{-1} b$。CG方法的算子变为 $B = M^{-1}A$。\n$$B = (AJ)^{-1}A = J^{-1}A^{-1}A = J^{-1}I = J^{-1}$$\n所以，算子是 $B = J^{-1}$。我们可以证明 $B$ 是斜对称的：\n$$B^{\\top} = (J^{-1})^{\\top} = (J^{\\top})^{-1} = (-J)^{-1} = -(J^{-1}) = -B$$\nCG算法要求算子是SPD。迭代中的一个关键步骤是计算步长：\n$$\\alpha_k = \\frac{r_k^{\\top} r_k}{p_k^{\\top} B p_k}$$\n分母是涉及算子 $B$ 的二次型。对于任何斜对称矩阵 $B$ 和任何非零向量 $p$，此二次型恒等于零：\n$$p^{\\top}Bp = (p^{\\top}Bp)^{\\top} = p^{\\top}B^{\\top}p = p^{\\top}(-B)p = -p^{\\top}Bp$$\n唯一等于其自身负值的标量是 $0$。因此，对于任何搜索方向 $p_k$，$p_k^{\\top} B p_k = 0$。这会导致除以零，使算法立即崩溃。我们将通过检查 $|p_k^{\\top} B p_k| \\le \\delta$（对于一个小的容差 $\\delta$）来检测这一点，如果成立，则报告失败，结果为 $-1$。\n\n### 情况2：保对称预处理共轭梯度（PCG）\n为了将预处理正确应用于SPD系统以供CG使用，预处理器 $M_{\\mathrm{sym}}$ 本身必须是SPD，并且其应用方式必须保持有效算子的对称性。PCG算法实现了这一点。\n\n在这里，我们使用一个简单而有效的SPD预处理器：雅可比（或对角）预处理器，$M_{\\mathrm{sym}} = \\mathrm{diag}(A)$。对于我们特定的矩阵 $A$，所有对角元素都是 $4$，所以 $M_{\\mathrm{sym}} = 4I$，这显然是SPD的。其逆为 $M_{\\mathrm{sym}}^{-1} = \\frac{1}{4}I$。\n\nPCG算法在步长计算（$p_k^\\top A p_k$）中保持了原始的SPD算子 $A$，确保了分母始终为正。预处理步骤涉及求解一个系统 $M_{\\mathrm{sym}} z_k = r_k$ 以获得预处理残差 $z_k$。这用于更新搜索方向：\n$$p_{k+1} = z_{k+1} + \\beta_{k+1} p_k, \\quad \\text{其中} \\quad \\beta_{k+1} = \\frac{r_{k+1}^{\\top} z_{k+1}}{r_k^{\\top} z_k}$$\n这种形式保证了该方法是定义明确的，并且通常比未预处理的CG收敛得更快。我们将报告达到收敛容差所需的迭代次数。\n\n### 情况3：标准共轭梯度（CG）\n这种情况作为我们的基准。我们将标准CG算法应用于原始的SPD系统 $Ax=b$。这在数学上等同于使用单位矩阵作为预处理器的PCG（$M=I$）。由于 $A$ 是SPD的，预计它会收敛，但可能比情况2中良好预处理的PCG要慢。我们将报告其迭代次数以进行比较。\n\n该计算实验将产生三个整数结果：每种情况的结果，从而证明正确选择和应用预处理器的关键重要性。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs and solves the three test cases as specified in the problem.\n    \"\"\"\n    n = 10\n    N = n * n\n    tol = 1e-10\n    max_iter = 500\n\n    def construct_A(n_grid):\n        \"\"\"Constructs the discrete 2D Laplacian matrix A.\"\"\"\n        n_dim = n_grid * n_grid\n        A = np.zeros((n_dim, n_dim))\n        for k in range(n_dim):\n            i, j = k // n_grid, k % n_grid\n            A[k, k] = 4\n            if i > 0: A[k, k - n_grid] = -1\n            if i  n_grid - 1: A[k, k + n_grid] = -1\n            if j > 0: A[k, k - 1] = -1\n            if j  n_grid - 1: A[k, k + 1] = -1\n        return A\n\n    A = construct_A(n)\n    b = np.ones(N)\n\n    def case1_solver():\n        \"\"\"\n        Case 1: Naive left-preconditioned CG.\n        Expected to break down. Returns -1 on breakdown or max_iter.\n        \"\"\"\n        # Construct the skew-symmetric operator B\n        J = np.zeros((N, N))\n        for i in range(N // 2):\n            J[2 * i, 2 * i + 1] = 1\n            J[2 * i + 1, 2 * i] = -1\n        \n        # Operator B = M^{-1}A = J^{-1} = -J\n        B = -J \n        # RHS b' = M^{-1}b = J^{-1}b = -Jb\n        b_prime = -J @ b\n        \n        x = np.zeros(N)\n        r_prime = b_prime.copy()  # Residual of the preconditioned system\n        p = r_prime.copy()\n        rs_old = r_prime @ r_prime\n        \n        norm_b = np.linalg.norm(b)\n        \n        for k in range(max_iter):\n            Bp = B @ p\n            pBp = p @ Bp\n            \n            # Breakdown check: denominator is zero for skew-symmetric operator\n            if abs(pBp) = 1e-15:\n                return -1\n            \n            alpha = rs_old / pBp\n            x += alpha * p\n            r_prime -= alpha * Bp\n            \n            # Convergence check uses the true residual r = b - Ax\n            r_true = b - A @ x\n            if np.linalg.norm(r_true) / norm_b  tol:\n                return k + 1\n            \n            rs_new = r_prime @ r_prime\n            beta = rs_new / rs_old\n            p = r_prime + (rs_new / rs_old) * p\n            rs_old = rs_new\n        \n        return -1 # Failure (max iterations reached)\n\n    def case2_solver():\n        \"\"\"\n        Case 2: Symmetry-preserving PCG with Jacobi preconditioner.\n        Expected to converge. Returns iteration count.\n        \"\"\"\n        x = np.zeros(N)\n        r = b.copy()\n        norm_b = np.linalg.norm(b)\n\n        # Initial residual check\n        if np.linalg.norm(r) / norm_b  tol:\n            return 0\n        \n        # Preconditioning step: M_sym = diag(A) = 4I, so z = M_inv * r = r / 4.0\n        z = r / 4.0\n        p = z.copy()\n        rz_old = r @ z\n        \n        for k in range(max_iter):\n            Ap = A @ p\n            pAp = p @ Ap\n            \n            alpha = rz_old / pAp\n            x += alpha * p\n            r -= alpha * Ap\n            \n            if np.linalg.norm(r) / norm_b  tol:\n                return k + 1\n            \n            z = r / 4.0\n            rz_new = r @ z\n            beta = rz_new / rz_old\n            p = z + beta * p\n            rz_old = rz_new\n            \n        return max_iter # Did not converge within max iterations\n\n    def case3_solver():\n        \"\"\"\n        Case 3: Standard CG (no preconditioning).\n        Expected to converge, but slower than Case 2. Returns iteration count.\n        \"\"\"\n        x = np.zeros(N)\n        r = b.copy()\n        norm_b = np.linalg.norm(b)\n\n        if np.linalg.norm(r) / norm_b  tol:\n            return 0\n        \n        p = r.copy()\n        rs_old = r @ r\n        \n        for k in range(max_iter):\n            Ap = A @ p\n            pAp = p @ Ap\n            \n            alpha = rs_old / pAp\n            x += alpha * p\n            r -= alpha * Ap\n            \n            if np.linalg.norm(r) / norm_b  tol:\n                return k + 1\n            \n            rs_new = r @ r\n            beta = rs_new / rs_old\n            p = r + (rs_new / rs_old) * p\n            rs_old = rs_new\n            \n        return max_iter # Did not converge within max iterations\n\n    # Run the three cases and collect the results\n    results = [\n        case1_solver(),\n        case2_solver(),\n        case3_solver()\n    ]\n\n    # Print the final output in the required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}