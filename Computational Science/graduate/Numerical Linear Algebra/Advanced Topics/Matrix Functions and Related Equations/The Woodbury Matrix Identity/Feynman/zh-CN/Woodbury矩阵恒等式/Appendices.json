{
    "hands_on_practices": [
        {
            "introduction": "本练习旨在从第一性原理出发，巩固您对伍德伯里矩阵恒等式背后机理的理解。您将通过分块矩阵求逆和舒尔补推导出该恒等式，并将其应用于求解一个低秩更新的线性系统。通过对比直接求解法与该恒等式方法的浮点运算（FLOPs）理论成本及数值结果，您将亲身体验到伍德伯里恒等式在计算效率上的巨大优势 。",
            "id": "3599105",
            "problem": "考虑方阵 $A \\in \\mathbb{R}^{n \\times n}$、$U \\in \\mathbb{R}^{n \\times k}$、$C \\in \\mathbb{R}^{k \\times k}$、$V \\in \\mathbb{R}^{k \\times n}$ 以及一个向量 $b \\in \\mathbb{R}^{n}$。您的任务是，从第一性原理出发，设计一种算法来计算 $(A + U C V)^{-1} b$。该算法需使用源于分块矩阵恒等式和舒尔补（Schur complement）的低秩更新策略，且不依赖任何预先给出的快捷公式。然后，实现直接计算（显式地构造 $(A + U C V)^{-1} b$）和低秩策略两种方法，验证两种结果在数值上是否一致，并在一个标准的稠密操作代价模型下估算计算节省量。所假定的代价模型基于经过充分检验的公式：使用常规的乘法-加法计数来构造稠密矩阵的乘积和总和，并通过一次LU分解（Lower-Upper factorization）后接三角求解来求解线性系统。具体来说，使用以下运算计数：\n- 一个 $n \\times n$ 稠密矩阵的LU分解：$\\frac{2}{3} n^3$ 次浮点运算（Floating Point Operations (FLOPs)）。\n- 对一个右侧项进行两次三角求解（在LU分解后）：每个右侧项 $2 n^2$ FLOPs。\n- 稠密矩阵-矩阵乘法 $(p \\times q)$ 乘以 $(q \\times r)$：$2 p q r$ FLOPs。\n- 稠密矩阵-向量乘法 $(p \\times q)$ 乘以 $(q \\times 1)$：$2 p q$ FLOPs。\n- 稠密矩阵加法 $(p \\times q)$：$p q$ FLOPs。\n- 通过LU分解和回代求一个 $m \\times m$ 矩阵的逆：$\\frac{8}{3} m^3$ FLOPs。\n\n在您的实现中，忽略稀疏性和数据特定的零结构；在代价模型中将所有矩阵视为稠密的。对于直接计算，显式构造 $(A + U C V)$，计算其逆，然后乘以 $b$。对于低秩策略，从分块矩阵求逆和舒尔补推导出一个方法，该方法仅需要：\n- 对 $A$ 进行一次LU分解，\n- 求解 $A y = b$，\n- 求解 $A Z = U$（有 $k$ 个右侧项），\n- 构造一个 $k \\times k$ 的辅助矩阵，\n- 求解一个 $k \\times k$ 的系统，\n- 执行必要的稠密乘积和加法。\n\n您的程序必须运行以下测试套件，其中 $n = 5$ 且 $k = 2$，使用指定的矩阵和向量。每个测试都是独立的。\n\n测试用例 1（良态基准）：\n- $A_1 = \\begin{bmatrix} 4  -1  0  0  0 \\\\ -1  4  -1  0  0 \\\\ 0  -1  4  -1  0 \\\\ 0  0  -1  4  -1 \\\\ 0  0  0  -1  4 \\end{bmatrix}$,\n- $U_1 = \\begin{bmatrix} 1  0 \\\\ 0  1 \\\\ 1  -1 \\\\ 2  1 \\\\ 0  1 \\end{bmatrix}$,\n- $V_1 = \\begin{bmatrix} 1  2  0  -1  0 \\\\ 0  1  1  0  -2 \\end{bmatrix}$,\n- $C_1 = \\begin{bmatrix} 2  -1 \\\\ 1  3 \\end{bmatrix}$,\n- $b_1 = \\begin{bmatrix} 1 \\\\ 0 \\\\ 3 \\\\ -1 \\\\ 2 \\end{bmatrix}$。\n\n测试用例 2（在 $U$ 中有零列的有效秩-1更新）：\n- $A_2 = \\begin{bmatrix} 3  -1  0  0  0 \\\\ -1  3  -1  0  0 \\\\ 0  -1  3  -1  0 \\\\ 0  0  -1  3  -1 \\\\ 0  0  0  -1  3 \\end{bmatrix}$,\n- $U_2 = \\begin{bmatrix} 1  0 \\\\ 0  0 \\\\ 1  0 \\\\ -1  0 \\\\ 2  0 \\end{bmatrix}$,\n- $V_2 = \\begin{bmatrix} 0  1  -1  0  2 \\\\ 0  0  0  0  0 \\end{bmatrix}$,\n- $C_2 = \\begin{bmatrix} 1  0.5 \\\\ 0.2  2 \\end{bmatrix}$,\n- $b_2 = \\begin{bmatrix} -1 \\\\ 2 \\\\ 0 \\\\ 3 \\\\ 1 \\end{bmatrix}$。\n\n测试用例 3（近奇异的 $A$ 对角线）：\n- $A_3 = \\operatorname{diag}\\left( 10^{-6}, 1, 2, 3, 4 \\right)$,\n- $U_3 = \\begin{bmatrix} 1  0 \\\\ 0.5  -0.2 \\\\ -0.3  0.1 \\\\ 0  0.4 \\\\ 0.2  -0.1 \\end{bmatrix}$,\n- $V_3 = \\begin{bmatrix} 0.1  0  0.3  -0.2  0 \\\\ 0  0.2  -0.1  0  0.4 \\end{bmatrix}$,\n- $C_3 = \\begin{bmatrix} 1.5  0.1 \\\\ 0  1.2 \\end{bmatrix}$,\n- $b_3 = \\begin{bmatrix} 0.5 \\\\ -0.5 \\\\ 0.25 \\\\ 1 \\\\ -0.75 \\end{bmatrix}$。\n\n对于每个测试用例，实现并计算：\n- 直接结果 $x_{\\text{direct}} = (A + U C V)^{-1} b$，通过显式求逆 $A + U C V$ 并乘以 $b$。\n- 低秩结果 $x_{\\text{lowrank}}$，根据分块矩阵求逆和舒尔补推导得出。\n- 最大绝对差 $\\max_{i} |(x_{\\text{direct}})_i - (x_{\\text{lowrank}})_i|$。\n- 一个布尔值验证，确认差值小于 $10^{-12}$ 的容差。\n- 在稠密代价模型下的 FLOP 计数，定义如下：\n  - 直接方法的总 FLOPs：\n    $$T_{\\text{direct}}(n,k) = 2 n k^2 + 2 n^2 k + n^2 + \\frac{8}{3} n^3 + 2 n^2.$$\n  - 低秩方法的总 FLOPs：\n    $$T_{\\text{lowrank}}(n,k) = \\frac{2}{3} n^3 + 2 n^2 + 2 n^2 k + 2 n k^2 + \\left( \\frac{8}{3} k^3 \\right) + k^2 + \\left( \\frac{2}{3} k^3 \\right) + 2 k^2 + 2 n k + 2 n k + n.$$\n- 节省比率 $R = \\frac{T_{\\text{direct}}(n,k)}{T_{\\text{lowrank}}(n,k)}$。\n\n您的程序应生成单行输出，其中包含所有测试用例的结果，形式为一个逗号分隔的列表，并用方括号括起来。列表中的每个条目本身也是一个包含五个元素的列表，顺序如下：\n$[\\text{verified}, \\text{max\\_abs\\_diff}, T_{\\text{direct}}, T_{\\text{lowrank}}, R]$。\n例如，输出格式必须为 $[[\\text{boolean}, \\text{float}, \\text{float}, \\text{float}, \\text{float}], [\\dots], [\\dots]]$。",
            "solution": "该问题要求设计并分析一种算法，以高效地计算向量 $x = (A + UCV)^{-1}b$，其方法是利用更新项 $UCV$ 的低秩结构。我们需要从第一性原理出发，使用分块矩阵恒等式来推导此算法，而不是直接陈述 Woodbury 矩阵恒等式。然后，将推导出的算法与直接计算方法在数值精度和计算代价方面进行比较，比较基于一个给定的浮点运算（FLOP）计数模型。\n\n### 低秩更新算法的推导\n\n问题的核心是找到满足方程 $(A + UCV)x = b$ 的向量 $x$，并假设矩阵 $(A + UCV)$ 是可逆的。我们可以将此问题表述为一个更大的、结构化的分块线性系统的解。考虑以下 $2 \\times 2$ 分块矩阵方程：\n$$\n\\begin{bmatrix} A  U \\\\ V  -C^{-1} \\end{bmatrix}\n\\begin{bmatrix} x' \\\\ y' \\end{bmatrix}\n=\n\\begin{bmatrix} b \\\\ 0 \\end{bmatrix}\n$$\n该系统要求矩阵 $C \\in \\mathbb{R}^{k \\times k}$ 是可逆的。分块方程展开为两个线性方程组：\n1. $Ax' + Uy' = b$\n2. $Vx' - C^{-1}y' = 0$\n\n通过直接操作第二个方程，我们可以用 $x'$ 来表示 $y'$：\n$$\nVx' = C^{-1}y' \\implies y' = CVx'\n$$\n将这个 $y'$ 的表达式代入第一个方程，得到：\n$$\nAx' + U(CVx') = b\n$$\n$$\n(A + UCV)x' = b\n$$\n这表明，我们分块系统解中的向量 $x'$ 正是我们寻求计算的向量 $x = (A + UCV)^{-1}b$。\n\n现在我们使用分块代入法求解该分块系统以得到 $x'$，这是舒尔补（Schur complement）概念的一个应用。我们假设矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 也是可逆的。从第一个方程 $Ax' + Uy' = b$，我们可以分离出 $x'$：\n$$\nAx' = b - Uy' \\implies x' = A^{-1}(b - Uy')\n$$\n接下来，我们将这个 $x'$ 的表达式代入第二个方程 $Vx' - C^{-1}y' = 0$：\n$$\nV(A^{-1}(b - Uy')) - C^{-1}y' = 0\n$$\n展开 $V$ 并重新整理各项以求解 $y'$：\n$$\nVA^{-1}b - VA^{-1}Uy' - C^{-1}y' = 0\n$$\n$$\nVA^{-1}b = VA^{-1}Uy' + C^{-1}y'\n$$\n$$\nVA^{-1}b = (VA^{-1}U + C^{-1})y'\n$$\n矩阵 $S = C^{-1} + VA^{-1}U$ 是分块矩阵 $\\begin{bmatrix} A  U \\\\ V  -C^{-1} \\end{bmatrix}$ 关于分块 $A$ 的舒尔补（Schur complement）。它是一个 $k \\times k$ 的矩阵。假设 $S$ 是可逆的，我们可以解出 $y'$：\n$$\ny' = (C^{-1} + VA^{-1}U)^{-1} VA^{-1}b\n$$\n最后，我们将这个 $y'$ 的结果代回到我们关于 $x'$ 的表达式中：\n$$\nx' = A^{-1}(b - Uy') = A^{-1}b - A^{-1}Uy'\n$$\n$$\nx = x' = A^{-1}b - A^{-1}U (C^{-1} + VA^{-1}U)^{-1} VA^{-1}b\n$$\n这个最终表达式提供了一种计算 $x$ 的算法，它避免了显式构造和求逆 $n \\times n$ 矩阵 $(A + UCV)$。当 $k \\ll n$ 时，这尤其有利，因为主要的计算瓶颈从对 $n \\times n$ 矩阵的操作转移到涉及 $A^{-1}$（可以预先分解）和对一个更小的 $k \\times k$ 矩阵求逆的操作。\n\n### 算法策略与代价分析\n\n推导出的公式引出了以下用于低秩更新方法的多步算法：\n1.  求解线性系统 $Ay_0 = b$ 以找到 $y_0 = A^{-1}b$。\n2.  求解 $k$ 个线性系统 $AZ = U$ 以找到 $n \\times k$ 矩阵 $Z = A^{-1}U$。\n3.  计算 $k \\times n$ 矩阵乘积 $VZ$。\n4.  计算 $k \\times k$ 矩阵 $C$ 的逆，即 $C^{-1}$。\n5.  构造 $k \\times k$ 的舒尔补矩阵 $S = C^{-1} + VZ$。\n6.  计算 $k \\times 1$ 向量 $w = Vy_0$。\n7.  求解 $k \\times k$ 线性系统 $Sz = w$ 以找到 $z = S^{-1}w$。\n8.  计算 $n \\times 1$ 更新向量 $x_{update} = Zz$。\n9.  计算最终解 $x = y_0 - x_{update}$。\n\n现在我们使用给定的 FLOP 计数，假设矩阵是稠密的且 $k \\ll n$，来分析直接方法和低秩方法的计算代价。\n\n**直接方法代价 ($T_{\\text{direct}}$):**\n1.  计算 $W = UC$：$U \\in \\mathbb{R}^{n \\times k}$, $C \\in \\mathbb{R}^{k \\times k}$。代价：$2nk^2$ FLOPs。\n2.  计算 $P = WV$：$W \\in \\mathbb{R}^{n \\times k}$, $V \\in \\mathbb{R}^{k \\times n}$。代价：$2nkn = 2n^2k$ FLOPs。\n3.  计算 $M = A + P$：两个 $n \\times n$ 矩阵。代价：$n^2$ FLOPs。\n4.  计算 $M^{-1}$：一个 $n \\times n$ 矩阵。代价：$\\frac{8}{3}n^3$ FLOPs。\n5.  计算 $x = M^{-1}b$：一个 $n \\times n$ 矩阵乘以一个 $n \\times 1$ 向量。代价：$2n^2$ FLOPs。\n\n总代价为 $T_{\\text{direct}}(n,k) = 2nk^2 + 2n^2k + n^2 + \\frac{8}{3}n^3 + 2n^2$。这与提供的公式相符。\n\n**低秩方法代价 ($T_{\\text{lowrank}}$):**\n1.  $A$ 的LU分解：一个 $n \\times n$ 矩阵。代价：$\\frac{2}{3}n^3$ FLOPs。\n2.  求解 $Ay_0=b$：对一个右侧项进行2次三角求解。代价：$2n^2$ FLOPs。\n3.  求解 $AZ=U$：$k$ 组2次三角求解。代价：$k(2n^2) = 2n^2k$ FLOPs。\n4.  计算 $VZ$：$V \\in \\mathbb{R}^{k \\times n}$, $Z \\in \\mathbb{R}^{n \\times k}$。代价：$2knk = 2nk^2$ FLOPs。\n5.  遵循问题规范的分解，我们明确计算与给定公式相匹配的代价：\n    - $\\frac{2}{3} n^3$：$A$ 的LU分解。\n    - $2 n^2$：求解 $y_0 = A^{-1}b$。\n    - $2 n^2 k$：求解 $Z = A^{-1}U$。\n    - $2 n k^2$：计算乘积 $VZ$。\n    - $\\frac{8}{3} k^3$：计算 $C^{-1}$。\n    - $k^2$：计算和 $S = C^{-1} + VZ$。\n    - $\\frac{2}{3} k^3$：$k \\times k$ 矩阵 $S$ 的LU分解。\n    - $2 k^2$：求解系统 $Sz = w$。\n    - $2nk$：计算乘积 $Vy_0$ 以得到右侧项 $w$。\n    - $2nk$：计算乘积 $Zz$。\n    - $n$：计算最终的向量减法 $x = y_0 - Zz$。\n\n将这些单项代价相加得到：\n$T_{\\text{lowrank}}(n,k) = \\frac{2}{3}n^3 + 2n^2 + 2n^2k + 2nk^2 + \\frac{8}{3}k^3 + k^2 + \\frac{2}{3}k^3 + 2k^2 + 2nk + 2nk + n$。\n这个表达式与提供的公式完全匹配。对于较大的 $n$，主要代价是 $A$ 的初始LU分解，为 $\\frac{2}{3}n^3$ FLOPs，相比于直接方法中的 $\\frac{8}{3}n^3$ 项，性能提升了4倍。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for the given test cases, comparing a direct method\n    and a low-rank update method for evaluating (A + UCV)^-1 * b.\n    \"\"\"\n    n = 5\n    k = 2\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1 (well-conditioned baseline)\n        {\n            \"A\": np.array([[4, -1, 0, 0, 0],\n                           [-1, 4, -1, 0, 0],\n                           [0, -1, 4, -1, 0],\n                           [0, 0, -1, 4, -1],\n                           [0, 0, 0, -1, 4]], dtype=float),\n            \"U\": np.array([[1, 0], [0, 1], [1, -1], [2, 1], [0, 1]], dtype=float),\n            \"V\": np.array([[1, 2, 0, -1, 0], [0, 1, 1, 0, -2]], dtype=float),\n            \"C\": np.array([[2, -1], [1, 3]], dtype=float),\n            \"b\": np.array([1, 0, 3, -1, 2], dtype=float)\n        },\n        # Test case 2 (effective rank-1 update)\n        {\n            \"A\": np.array([[3, -1, 0, 0, 0],\n                           [-1, 3, -1, 0, 0],\n                           [0, -1, 3, -1, 0],\n                           [0, 0, -1, 3, -1],\n                           [0, 0, 0, -1, 3]], dtype=float),\n            \"U\": np.array([[1, 0], [0, 0], [1, 0], [-1, 0], [2, 0]], dtype=float),\n            \"V\": np.array([[0, 1, -1, 0, 2], [0, 0, 0, 0, 0]], dtype=float),\n            \"C\": np.array([[1, 0.5], [0.2, 2]], dtype=float),\n            \"b\": np.array([-1, 2, 0, 3, 1], dtype=float)\n        },\n        # Test case 3 (near-singular A)\n        {\n            \"A\": np.diag([1e-6, 1, 2, 3, 4]),\n            \"U\": np.array([[1, 0], [0.5, -0.2], [-0.3, 0.1], [0, 0.4], [0.2, -0.1]], dtype=float),\n            \"V\": np.array([[0.1, 0, 0.3, -0.2, 0], [0, 0.2, -0.1, 0, 0.4]], dtype=float),\n            \"C\": np.array([[1.5, 0.1], [0, 1.2]], dtype=float),\n            \"b\": np.array([0.5, -0.5, 0.25, 1, -0.75], dtype=float)\n        }\n    ]\n\n    results = []\n    \n    # Calculate FLOP counts (these are constant for n=5, k=2)\n    # T_direct(n,k) = 2*n*k^2 + 2*n^2*k + n^2 + (8/3)*n^3 + 2*n^2\n    T_direct = (2*n*k**2 + 2*n**2*k + n**2 + (8/3)*n**3 + 2*n**2)\n    \n    # T_lowrank(n,k) as specified\n    T_lowrank = ((2/3)*n**3 + 2*n**2 + 2*n**2*k + 2*n*k**2 + \n                 (8/3)*k**3 + k**2 + (2/3)*k**3 + 2*k**2 + \n                 2*n*k + 2*n*k + n)\n\n    R = T_direct / T_lowrank\n\n    for case in test_cases:\n        A, U, C, V, b = case[\"A\"], case[\"U\"], case[\"C\"], case[\"V\"], case[\"b\"]\n\n        # Direct method\n        M = A + U @ C @ V\n        try:\n            M_inv = np.linalg.inv(M)\n            x_direct = M_inv @ b\n        except np.linalg.LinAlgError:\n            # In case M is singular, handle gracefully although not expected\n            x_direct = np.full_like(b, np.nan)\n\n        # Low-rank update method (Sherman-Morrison-Woodbury)\n        try:\n            # Step 1  2: Solve A y = b and A Z = U\n            y0 = np.linalg.solve(A, b)\n            Z = np.linalg.solve(A, U)\n            \n            # Step 3: Compute C_inv\n            C_inv = np.linalg.inv(C)\n            \n            # Step 4: Form the k x k Schur complement matrix\n            S = C_inv + V @ Z\n            \n            # Step 5  6: Solve the small k x k system\n            w = V @ y0\n            z = np.linalg.solve(S, w)\n\n            # Step 7  8: Compute final solution\n            x_update = Z @ z\n            x_lowrank = y0 - x_update\n        except np.linalg.LinAlgError:\n            # In case A, C, or S is singular\n            x_lowrank = np.full_like(b, np.nan)\n\n        # Comparison\n        max_abs_diff = np.max(np.abs(x_direct - x_lowrank))\n        verified = max_abs_diff  1e-12\n\n        results.append([verified, max_abs_diff, T_direct, T_lowrank, R])\n\n    # Final print statement in the exact required format.\n    # The string representation of a list is desired, joined by commas.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在科学计算中，我们经常遇到需要求解具有特定结构（如对称正定）的矩阵的线性系统。本练习将伍德伯里恒等式与一个常见的数值方法——乔列斯基分解相结合。您将学习如何利用已知的乔列斯基因子$L$（其中$A=LL^T$）来高效计算伍德伯里公式中的各项，用快速且稳定的三角求解代替抽象的矩阵求逆，从而加深对矩阵恒等式与高性能矩阵分解之间实践联系的理解 。",
            "id": "3599100",
            "problem": "给定一个可逆的对称正定 (SPD) 矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 及其稀疏 Cholesky 分解 $A = L L^T$，其中 $L$ 是下三角矩阵。同时给定矩阵 $U \\in \\mathbb{R}^{n \\times k}$、$V \\in \\mathbb{R}^{k \\times n}$ 以及一个可逆矩阵 $C \\in \\mathbb{R}^{k \\times k}$。考虑线性系统 $(A + U C V)\\,x = b$，其右端项 $b \\in \\mathbb{R}^{n}$ 已知。你的任务是：\n\n1. 仅使用矩阵逆的定义、三角系统的性质以及通过 Schur 补的分块矩阵求逆法则（作为推导的基本基础），推导一个有原则的算法来构造矩阵\n   $$\n   S = C^{-1} + V\\,A^{-1}\\,U\n   $$\n   该算法对于 $U$ 的每一列，都恰好使用关于 Cholesky 因子 $L$ 的两次三角求解（即形式为 $L y = u$ 和 $L^{\\top} w = y$ 的求解），并且避免显式地构造 $A^{-1}$。请提供理由，说明为何在给定的假设下，这种构造是正确的且稳定的。\n\n2. 基于第 1 部分的推导，再次依据基本原理，概述计算系统 $(A + U C V)\\,x = b$ 解 $x$ 的完整计算步骤，并强调在此过程中如何使用 $S$，以及如何仅需通过对 $L$ 和 $L^{\\top}$ 进行三角求解来使用 $A^{-1}$。\n\n3. 在一个程序中实现此算法，并执行以下测试套件。对于每个测试用例，确定性地构造指定的矩阵和向量，使用你的算法计算解 $x$，并使用稠密线性求解器直接求解 $(A + U C V)\\,x = b$ 来验证其正确性。为了验证，计算相对差异\n   $$\n   r = \\frac{\\| x_{\\text{woodbury}} - x_{\\text{direct}} \\|_2}{1 + \\| x_{\\text{direct}} \\|_2}\n   $$\n   如果 $r \\leq 10^{-10}$ 则返回布尔值 $\\text{True}$，否则返回 $\\text{False}$。本问题不涉及任何物理单位、角度或百分比。\n\n测试套件必须严格按照以下方式构造（所有随机生成必须使用指定的独立种子和标准正态分布的元素，且所有构造必须是确定性的）：\n\n- 情况 1 (一般顺利路径):\n  - $n = 6$，$k = 2$。\n  - 构造 $A$ 为 $A = M^{\\top} M + n I$，其中 $M$ 的元素由种子为 $1$ 的标准正态分布生成，$I$ 是单位矩阵。\n  - 使用种子为 $2$ 的标准正态分布元素构造 $U$。\n  - 使用种子为 $3$ 的标准正态分布元素构造 $V$。\n  - 构造 $C$ 为 $C = R^{\\top} R + k I$，其中 $R$ 的元素由种子为 $4$ 的标准正态分布生成。\n  - 使用种子为 $5$ 的标准正态分布元素构造 $b$。\n\n- 情况 2 (秩-1 更新):\n  - $n = 5$，$k = 1$。\n  - 构造 $A = M^{\\top} M + n I$，其中 $M$ 的元素由种子为 $11$ 的标准正态分布生成。\n  - 使用种子为 $12$ 的标准正态分布元素构造 $U$。\n  - 使用种子为 $13$ 的标准正态分布元素构造 $V$。\n  - 设置 $C = [2.5]$ (即 $C \\in \\mathbb{R}^{1 \\times 1}$ 等于标量 $2.5$）。\n  - 使用种子为 $15$ 的标准正态分布元素构造 $b$。\n\n- 情况 3 ($C$ 病态但可逆):\n  - $n = 7$，$k = 2$。\n  - 构造 $A = M^{\\top} M + n I$，其中 $M$ 的元素由种子为 $21$ 的标准正态分布生成。\n  - 使用种子为 $22$ 的标准正态分布元素构造 $U$。\n  - 使用种子为 $23$ 的标准正态分布元素构造 $V$。\n  - 设置 $C = \\text{diag}(10^{-8}, 0.5)$。\n  - 使用种子为 $25$ 的标准正态分布元素构造 $b$。\n\n- 情况 4 (类对称更新，$V = U^T$):\n  - $n = 5$，$k = 3$。\n  - 构造 $A = M^{\\top} M + n I$，其中 $M$ 的元素由种子为 $31$ 的标准正态分布生成。\n  - 使用种子为 $32$ 的标准正态分布元素构造 $U$。\n  - 设置 $V = U^T$。\n  - 设置 $C = \\operatorname{diag}(1.0,\\,2.0,\\,3.0)$。\n  - 使用种子为 $35$ 的标准正态分布元素构造 $b$。\n\n- 情况 5 (无更新: $U$ 为零矩阵):\n  - $n = 4$，$k = 2$。\n  - 构造 $A = M^{\\top} M + n I$，其中 $M$ 的元素由种子为 $41$ 的标准正态分布生成。\n  - 将 $U$ 设置为 $n \\times k$ 的零矩阵。\n  - 使用种子为 $43$ 的标准正态分布元素构造 $V$。\n  - 设置 $C = \\operatorname{diag}(1.0,\\,1.5)$。\n  - 使用种子为 $45$ 的标准正态分布元素构造 $b$。\n\n你的程序必须：\n- 使用 Cholesky 因子 $L$ 执行三角求解。\n- 对于 $U$ 的每一列，使用恰好两次三角求解来构造 $S = C^{-1} + V\\,A^{-1}\\,U$。\n- 使用你概述的步骤计算 $x$，这些步骤仅需要对 $L$ 和 $L^{\\top}$ 进行三角求解，以及一个涉及 $S$ 的小型稠密求解。\n- 通过与直接稠密求解 $(A + U C V)\\,x = b$ 的结果对比来验证 $x$。\n- 其唯一输出必须为单行，包含一个长度为 $5$ 的 Python 布尔值列表，每个值对应一个案例，并按上述顺序排列，例如 $[ \\text{True}, \\text{False}, \\dots ]$，无额外空格要求。\n\n最终输出格式必须是单行，包含用方括号括起来的、以逗号分隔的结果列表，例如 $[result1,result2,result3,result4,result5]$。",
            "solution": "该问题要求推导并实现一个算法，用于求解线性系统 $(A + U C V)\\,x = b$，其中 $A$ 是一个大型对称正定 (SPD) 矩阵，其 Cholesky 分解 $A=LL^T$ 已知，而 $U, C, V$ 代表一个低秩更新。更新的秩为 $k$，$k$ 是 $U$ 的列数和 $V$ 的行数，通常远小于 $n$。所用的方法基于 Woodbury 矩阵恒等式，该恒等式由分块矩阵求逆原理推导得出。\n\n### 第 1 部分：矩阵 $S$ 的原理推导与构造\n\nWoodbury 矩阵恒等式 $(A + UCV)^{-1} = A^{-1} - A^{-1}U(C^{-1} + VA^{-1}U)^{-1}VA^{-1}$ 提供了一种计算被修改后矩阵的逆的方法。该恒等式的核心是矩阵 $S = C^{-1} + VA^{-1}U$。我们的推导将从构造一个增广线性系统开始，该系统揭示了 $S$ 作为 Schur 补的角色。\n\n考虑以下 $2 \\times 2$ 分块线性系统：\n$$\n\\begin{pmatrix} A  U \\\\ V  -C^{-1} \\end{pmatrix} \\begin{pmatrix} y \\\\ z \\end{pmatrix} = \\begin{pmatrix} b \\\\ 0 \\end{pmatrix}\n$$\n该系统等价于以下方程组：\n1.  $A y + U z = b$\n2.  $V y - C^{-1} z = 0$\n\n根据方程 (2)，假设给定的 $C$ 是可逆的，我们有 $z = CVy$。将其代入方程 (1) 得：\n$$\nA y + U(CVy) = b \\implies (A + UCV)y = b\n$$\n这表明增广系统解中的向量 $y$ 正是我们所求的解向量 $x$。\n\n为了开发一个计算算法，我们可以使用分块消元法求解该增广系统。从方程 (1) 中，我们可以用 $z$ 表示 $y$：\n$$\ny = A^{-1}(b - Uz)\n$$\n将这个 $y$ 的表达式代入方程 (2)：\n$$\nV \\left( A^{-1}(b - Uz) \\right) - C^{-1} z = 0\n$$\n展开 $V$ 并重新整理各项以求解 $z$：\n$$\nV A^{-1} b - V A^{-1} U z - C^{-1} z = 0\n$$\n$$\nV A^{-1} b = (C^{-1} + V A^{-1} U) z\n$$\n我们定义矩阵 $S = C^{-1} + V A^{-1} U$。关于 $z$ 的方程变成一个 $k \\times k$ 的线性系统，$S z = V A^{-1} b$。矩阵 $S = C^{-1} + VA^{-1}U$ 是此分块矩阵中关于分块 $A$ 的舒尔补（Schur complement）的负值。\n\n任务是高效且稳定地构造 $S$，而不显式计算 $A^{-1}$。$S$ 的表达式为 $S = C^{-1} + V(A^{-1}U)$。关键的计算是矩阵乘积 $W = A^{-1}U$。这等价于求解矩阵方程 $AW = U$ 以得到未知矩阵 $W \\in \\mathbb{R}^{n \\times k}$。\n\n这个矩阵方程可以逐列求解。令 $u_j$ 为 $U$ 的第 $j$ 列，$w_j$ 为 $W$ 的第 $j$ 列。对于每个 $j \\in \\{1, \\dots, k\\}$，我们求解线性系统：\n$$\nA w_j = u_j\n$$\n我们已知 Cholesky 分解 $A = LL^T$，其中 $L$ 是一个下三角矩阵。代入此分解得到：\n$$\nL L^T w_j = u_j\n$$\n该系统通过两次三角求解在两个步骤内解出，这在计算上是高效的 ($O(n^2)$)：\na. **前向代入**：求解 $L y_j = u_j$ 得到中间向量 $y_j$。\nb. **回代**：求解 $L^T w_j = y_j$ 得到所求的列 $w_j$。\n\n对 $U$ 的 $k$ 列中的每一列都重复这个两步过程。这构成了对 $U$ 的每一列恰好进行两次三角求解。在所有列 $w_j$ 计算完毕后，将它们组合成矩阵 $W = [w_1, w_2, \\dots, w_k]$。\n\n构造 $S$ 的最后步骤是：\n1. 直接计算 $C^{-1}$。由于 $C$ 是一个小的 $k \\times k$ 矩阵（$k \\ll n$），这是一个计算成本低的操作。\n2. 计算矩阵乘积 $VW$。\n3. 计算和 $S = C^{-1} + VW$。\n\n**正确性与稳定性**：从增广系统进行的推导保证了这种构造在数学上是正确的。该过程的数值稳定性依赖于 $A$ 的性质。由于 $A$ 是对称正定的，其 Cholesky 分解是数值稳定的。问题进一步指明 $A$ 被构造为 $M^\\top M + nI$，这使其成为良态矩阵。使用良态因子 $L$ 求解三角系统也是一个稳定的过程。因此，在给定的假设下，$W=A^{-1}U$ 的计算是数值稳定的，并且 $S$ 的整体构造是鲁棒的。\n\n### 第 2 部分：求解 $(A+UCV)x = b$ 的完整算法\n\n基于上述推导，我们有了一套寻找解 $x$ 的完整步骤序列。策略是首先求解辅助向量 $z$，然后用它来求得 $x=y$。\n\n算法流程如下：\n1. **计算 $S$ 和 $x$ 的预备项**：\n    a. 计算 $W = A^{-1}U$。如第 1 部分所述，这涉及对每一列 $j=1, \\dots, k$ 使用 Cholesky 因子 $L$ 进行两次三角求解来解方程 $Aw_j = u_j$。\n    b. 计算 $z_b = A^{-1}b$。这是一个单一向量的求解问题 $Az_b = b$，同样通过两次三角求解完成：先解 $Ly_b=b$，再解 $L^T z_b = y_b$。\n\n2. **构造并求解 $k \\times k$ 系统**：\n    a. 计算 $S = C^{-1} + V W$。这需要一次小型矩阵求逆和一次矩阵乘法。\n    b. $z$ 系统的右端项是 $V A^{-1} b$，现在可以计算为 $t = V z_b$。\n    c. 求解稠密的 $k \\times k$ 线性系统 $S z = t$，得到向量 $z \\in \\mathbb{R}^k$。\n\n3. **计算最终解 $x$**：\n    a. 根据推导，$x = y = A^{-1}(b - Uz)$。\n    b. 我们可以将其重写为 $x = A^{-1}b - A^{-1}Uz$。\n    c. 代入预先计算好的量，我们得到 $x = z_b - Wz$。\n    d. 最终解通过一次矩阵向量乘积 $Wz$ 和一次向量减法得到。\n\n此算法高效地利用了问题的结构。它不需要求解一个涉及稠密矩阵 $A+UCV$ 的大型 $n \\times n$ 系统，而是需要一系列涉及稀疏/结构化矩阵 $A$（通过其因子 $L$）的操作和一个小型的稠密 $k \\times k$ 系统。总计算成本主要由涉及 $A$ 的初始求解决定，大约是用 $A$ 求解单个系统的成本的 $k$ 倍。当 $k \\ll n$ 时，这是非常有利的。\n\n### 第 3 部分：实现与验证\n\n以下 Python 程序实现了所推导的算法。它按规定构造了五个测试用例，使用概述的步骤计算解 $x_{\\text{woodbury}}$，并与通过标准稠密求解器求解 $(A+UCV)x=b$ 得到的直接解 $x_{\\text{direct}}$ 进行比较验证。计算相对差异，并为每个案例存储一个布尔结果。",
            "answer": "```python\nimport numpy as np\nfrom scipy import linalg\n\ndef solve_woodbury(A, U, C, V, b):\n    \"\"\"\n    Solves (A + UCV)x = b using the Woodbury matrix identity.\n    A is assumed to be SPD.\n    \"\"\"\n    n, k = U.shape\n    \n    # Step 1: Cholesky factorization of A\n    # A is guaranteed to be SPD by construction in the test cases.\n    try:\n        L = linalg.cholesky(A, lower=True)\n    except linalg.LinAlgError:\n        # Fallback for cases where A might not be perfectly SPD due to floating point.\n        # This should not happen with the problem's construction.\n        # A = A + tiny_identity_matrix\n        # L = ...\n        raise\n\n    # Step 2: Compute W = A^-1 * U\n    # Solve A*w_j = u_j for each column of U using the Cholesky factor\n    W = np.zeros_like(U)\n    if k  0:\n        for j in range(k):\n            # Solve Ly = u_j\n            y_j = linalg.solve_triangular(L, U[:, j], lower=True)\n            # Solve L^T w_j = y_j\n            w_j = linalg.solve_triangular(L.T, y_j, lower=False)\n            W[:, j] = w_j\n\n    # Step 3: Compute C_inv and S = C_inv + V * A^-1 * U\n    # Handle the k=0 case (e.g., U is n x 0)\n    if k  0:\n        C_inv = linalg.inv(C)\n        S = C_inv + V @ W\n    \n    # Step 4: Solve for x using the Woodbury formula\n    # x = A_inv*b - A_inv*U*S_inv*V*A_inv*b\n    # Let z_b = A_inv*b\n    # x = z_b - W*S_inv*V*z_b\n\n    # Compute z_b = A^-1 * b\n    y_b = linalg.solve_triangular(L, b, lower=True)\n    z_b = linalg.solve_triangular(L.T, y_b, lower=False)\n\n    if k  0:\n        # Compute t = V * z_b\n        t = V @ z_b\n        # Solve Sz = t for z (here z is the variable from derivation, not z_b)\n        aux_z = linalg.solve(S, t)\n        # Final solution x = z_b - W*z\n        x_woodbury = z_b - W @ aux_z\n    else: # If k=0, U is empty, so the update is zero. The system is Ax=b.\n        x_woodbury = z_b\n\n    return x_woodbury\n\ndef create_spd_matrix(n, seed):\n    \"\"\"Creates an n x n SPD matrix.\"\"\"\n    rng = np.random.default_rng(seed)\n    M = rng.standard_normal((n, n))\n    # A = M^T M ensures semi-definite. Adding n*I makes it well-conditioned and SPD.\n    return M.T @ M + n * np.eye(n)\n\n\ndef solve():\n    \"\"\"\n    Runs the test suite for the Woodbury identity solver.\n    \"\"\"\n    test_cases = [\n        {'n': 6, 'k': 2, 'seeds': {'A': 1, 'U': 2, 'V': 3, 'C': 4, 'b': 5}},\n        {'n': 5, 'k': 1, 'seeds': {'A': 11, 'U': 12, 'V': 13, 'C': None, 'b': 15}},\n        {'n': 7, 'k': 2, 'seeds': {'A': 21, 'U': 22, 'V': 23, 'C': None, 'b': 25}},\n        {'n': 5, 'k': 3, 'seeds': {'A': 31, 'U': 32, 'V': None, 'C': None, 'b': 35}},\n        {'n': 4, 'k': 2, 'seeds': {'A': 41, 'U': None, 'V': 43, 'C': None, 'b': 45}},\n    ]\n    \n    results = []\n    \n    # Tolerance for verification\n    TOL = 1e-10\n\n    # Case 1\n    case = test_cases[0]\n    n, k, seeds = case['n'], case['k'], case['seeds']\n    rng_u = np.random.default_rng(seeds['U'])\n    rng_v = np.random.default_rng(seeds['V'])\n    rng_c = np.random.default_rng(seeds['C'])\n    rng_b = np.random.default_rng(seeds['b'])\n    A = create_spd_matrix(n, seeds['A'])\n    U = rng_u.standard_normal((n, k))\n    V = rng_v.standard_normal((k, n))\n    R = rng_c.standard_normal((k, k))\n    C = R.T @ R + k * np.eye(k)\n    b = rng_b.standard_normal(n)\n\n    # Case 2\n    case2 = test_cases[1]\n    n2, k2, seeds2 = case2['n'], case2['k'], case2['seeds']\n    rng_u2 = np.random.default_rng(seeds2['U'])\n    rng_v2 = np.random.default_rng(seeds2['V'])\n    rng_b2 = np.random.default_rng(seeds2['b'])\n    A2 = create_spd_matrix(n2, seeds2['A'])\n    U2 = rng_u2.standard_normal((n2, k2))\n    V2 = rng_v2.standard_normal((k2, n2))\n    C2 = np.array([[2.5]])\n    b2 = rng_b2.standard_normal(n2)\n    \n    # Case 3\n    case3 = test_cases[2]\n    n3, k3, seeds3 = case3['n'], case3['k'], case3['seeds']\n    rng_u3 = np.random.default_rng(seeds3['U'])\n    rng_v3 = np.random.default_rng(seeds3['V'])\n    rng_b3 = np.random.default_rng(seeds3['b'])\n    A3 = create_spd_matrix(n3, seeds3['A'])\n    U3 = rng_u3.standard_normal((n3, k3))\n    V3 = rng_v3.standard_normal((k3, n3))\n    C3 = np.diag([1e-8, 0.5])\n    b3 = rng_b3.standard_normal(n3)\n\n    # Case 4\n    case4 = test_cases[3]\n    n4, k4, seeds4 = case4['n'], case4['k'], case4['seeds']\n    rng_u4 = np.random.default_rng(seeds4['U'])\n    rng_b4 = np.random.default_rng(seeds4['b'])\n    A4 = create_spd_matrix(n4, seeds4['A'])\n    U4 = rng_u4.standard_normal((n4, k4))\n    V4 = U4.T\n    C4 = np.diag([1.0, 2.0, 3.0])\n    b4 = rng_b4.standard_normal(n4)\n\n    # Case 5\n    case5 = test_cases[4]\n    n5, k5, seeds5 = case5['n'], case5['k'], case5['seeds']\n    rng_v5 = np.random.default_rng(seeds5['V'])\n    rng_b5 = np.random.default_rng(seeds5['b'])\n    A5 = create_spd_matrix(n5, seeds5['A'])\n    U5 = np.zeros((n5, k5))\n    V5 = rng_v5.standard_normal((k5, n5))\n    C5 = np.diag([1.0, 1.5])\n    b5 = rng_b5.standard_normal(n5)\n\n    all_params = [\n        (A, U, C, V, b),\n        (A2, U2, C2, V2, b2),\n        (A3, U3, C3, V3, b3),\n        (A4, U4, C4, V4, b4),\n        (A5, U5, C5, V5, b5)\n    ]\n    \n    for params in all_params:\n        A_p, U_p, C_p, V_p, b_p = params\n        \n        # Compute solution using Woodbury method\n        x_woodbury = solve_woodbury(A_p, U_p, C_p, V_p, b_p)\n        \n        # Compute direct solution for verification\n        M_full = A_p + U_p @ C_p @ V_p\n        x_direct = linalg.solve(M_full, b_p)\n        \n        # Compute relative discrepancy\n        discrepancy = linalg.norm(x_woodbury - x_direct) / (1 + linalg.norm(x_direct))\n        \n        results.append(discrepancy = TOL)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "此最终练习探讨了一种重要的应用模式：当需要求解具有相同更新矩阵但右侧向量不同的多个线性系统时，如何实现最高效率。本练习将指导您设计一种包含“预计算”和“求解”两个阶段的算法。通过一次性计算并复用伍德伯里公式中的固定部分，您将能显著加速后续每个系统的求解过程，从而在实践中掌握摊销分析这一重要的数值策略 。",
            "id": "3599117",
            "problem": "要求您基于数值线性代数的基本原理，设计并实现一个算法，以高效求解共享一个共同低秩更新的多个线性系统。目标是推导、论证并实现一个重用策略，用于对多个右端项 $b_i$ 重复求解形如 $(A + U C V) x_i = b_i$ 的系统，其中 $A \\in \\mathbb{R}^{n \\times n}$ 是可逆矩阵，而 $U \\in \\mathbb{R}^{n \\times k}$、$V \\in \\mathbb{R}^{k \\times n}$、$C \\in \\mathbb{R}^{k \\times k}$ 在多次求解中保持不变。您最终的程序必须同时实现一种直接法和一种加速法，该加速法会对所有右端项重用预计算结果。程序必须报告两种方法结果之间的量化一致性。\n\n请从数值线性代数的有效基础出发。您只能使用以下内容作为基础出发点：\n- 逆矩阵的定义：对于一个可逆矩阵 $M$，$M^{-1}$ 满足 $M M^{-1} = I$。\n- Schur 补的定义：给定一个分块矩阵 $\\begin{bmatrix} A  B \\\\ C  D \\end{bmatrix}$，其中 $A$ 和 $D$ 是方形可逆矩阵，则 $A$ 的 Schur 补为 $D - C A^{-1} B$，$D$ 的 Schur 补为 $A - B D^{-1} C$。\n- 从 Schur 补推导出的分块矩阵求逆公式，将其视为一个经过充分检验的事实。\n\n您的任务如下：\n- 根据分块矩阵求逆公式和 Schur 补的定义，推导出 $(A + U C V)^{-1}$ 的显式表达式，该表达式应使用 $A^{-1}$、$U$、$C$、$V$ 以及一个仅依赖于 $A$、$U$、$C$ 和 $V$ 的 $k \\times k$ 矩阵的逆来表示。利用此推导解释如何通过预计算和重用 $A^{-1} U$、$V A^{-1}$ 以及一个小的 $k \\times k$ 矩阵（记为 $S$）的稳定分解，来加速对多个 $b_i$ 求解 $(A + U C V) x_i = b_i$ 的过程。\n- 基于您的推导，设计一个算法，该算法需要：\n  1. 预计算并存储 $A$ 的分解，以便在所有后续求解中重用。\n  2. 在不显式构造 $A^{-1}$ 的情况下，预计算并存储 $A^{-1} U$ 和 $V A^{-1}$。\n  3. 构造您推导中得到的矩阵 $S$，并存储其稳定分解以供重用。\n  4. 对于每个右端项 $b_i$，仅使用以下操作求解 $(A + U C V) x_i = b_i$：\n     - 利用存储的分解进行关于 $A$ 和 $A^\\top$ 的求解。\n     - 利用存储的分解进行关于小矩阵 $S$ 的求解。\n     - 涉及预计算的 $A^{-1} U$ 和 $V A^{-1}$ 以及固定矩阵 $C$ 的矩阵-矩阵和矩阵-向量乘法。\n- 通过对完整矩阵 $A + U C V$ 进行一次性分解来直接求解系统，并以此作为验证，将得到的解与您加速方法产生的解进行比较。\n\n您的程序必须实现这两种方法，并为每个测试用例报告在所有给定的右端项 $b_i$ 中，直接解与加速解之间逐项绝对差的最大值。最终输出必须为单行，包含一个浮点数值列表，每个测试用例一个值，并按下列顺序排列。\n\n测试套件规范：\n- 测试用例 1 ($n = 5, k = 2$)：\n  - $A \\in \\mathbb{R}^{5 \\times 5}$ 是一个三对角矩阵，其主对角线元素为 $4$，第一副对角线和第一超对角线元素为 $-1$，即\n    $$\n    A = \\begin{bmatrix}\n    4  -1  0  0  0 \\\\\n    -1  4  -1  0  0 \\\\\n    0  -1  4  -1  0 \\\\\n    0  0  -1  4  -1 \\\\\n    0  0  0  -1  4\n    \\end{bmatrix}.\n    $$\n  - $U \\in \\mathbb{R}^{5 \\times 2}$ 的列为 $e_1$ 和 $e_3$，即\n    $$\n    U = \\begin{bmatrix}\n    1  0 \\\\\n    0  0 \\\\\n    0  1 \\\\\n    0  0 \\\\\n    0  0\n    \\end{bmatrix}.\n    $$\n  - $V \\in \\mathbb{R}^{2 \\times 5}$ 为\n    $$\n    V = \\begin{bmatrix}\n    1  0  1  0  0 \\\\\n    0  1  0  1  0\n    \\end{bmatrix}.\n    $$\n  - $C \\in \\mathbb{R}^{2 \\times 2}$ 为\n    $$\n    C = \\begin{bmatrix}\n    2  1 \\\\\n    -1  3\n    \\end{bmatrix}.\n    $$\n  - 三个右端项 $b_1, b_2, b_3 \\in \\mathbb{R}^{5}$：\n    $$\n    b_1 = \\begin{bmatrix} 1 \\\\ 1 \\\\ 1 \\\\ 1 \\\\ 1 \\end{bmatrix}, \\quad\n    b_2 = \\begin{bmatrix} 1 \\\\ 2 \\\\ 3 \\\\ 4 \\\\ 5 \\end{bmatrix}, \\quad\n    b_3 = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 1 \\end{bmatrix}.\n    $$\n\n- 测试用例 2 ($n = 6, k = 1$)：\n  - $A \\in \\mathbb{R}^{6 \\times 6}$ 是对角矩阵，对角线元素为 $1, 3, 5, 7, 9, 11$，即\n    $$\n    A = \\text{diag}(1, 3, 5, 7, 9, 11).\n    $$\n  - $U \\in \\mathbb{R}^{6 \\times 1}$ 为\n    $$\n    U = \\begin{bmatrix} 1 \\\\ 0 \\\\ 1 \\\\ 0 \\\\ 1 \\\\ 0 \\end{bmatrix}.\n    $$\n  - $V \\in \\mathbb{R}^{1 \\times 6}$ 为\n    $$\n    V = \\begin{bmatrix} 0  1  0  1  0  1 \\end{bmatrix}.\n    $$\n  - $C \\in \\mathbb{R}^{1 \\times 1}$ 是标量矩阵\n    $$\n    C = \\begin{bmatrix} 10 \\end{bmatrix}.\n    $$\n  - 三个右端项 $b_1, b_2, b_3 \\in \\mathbb{R}^{6}$：\n    $$\n    b_1 = \\begin{bmatrix} 1 \\\\ 1 \\\\ 1 \\\\ 1 \\\\ 1 \\\\ 1 \\end{bmatrix}, \\quad\n    b_2 = \\begin{bmatrix} 6 \\\\ 5 \\\\ 4 \\\\ 3 \\\\ 2 \\\\ 1 \\end{bmatrix}, \\quad\n    b_3 = \\begin{bmatrix} 0 \\\\ 0 \\\\ 1 \\\\ 0 \\\\ 0 \\\\ 0 \\end{bmatrix}.\n    $$\n\n- 测试用例 3 ($n = 4, k = 2$)：\n  - $A \\in \\mathbb{R}^{4 \\times 4}$ 是对角矩阵，对角线元素为 $10^{-3}, 2, 3, 4$，即\n    $$\n    A = \\text{diag}(10^{-3}, 2, 3, 4).\n    $$\n  - $U \\in \\mathbb{R}^{4 \\times 2}$ 为\n    $$\n    U = \\begin{bmatrix}\n    1  0 \\\\\n    0  1 \\\\\n    1  1 \\\\\n    0  1\n    \\end{bmatrix}.\n    $$\n  - $V \\in \\mathbb{R}^{2 \\times 4}$ 为\n    $$\n    V = \\begin{bmatrix}\n    1  -1  0  0 \\\\\n    0  1  1  0\n    \\end{bmatrix}.\n    $$\n  - $C \\in \\mathbb{R}^{2 \\times 2}$ 是奇异矩阵，由下式给出\n    $$\n    C = \\begin{bmatrix}\n    0  1 \\\\\n    0  0\n    \\end{bmatrix}.\n    $$\n  - 三个右端项 $b_1, b_2, b_3 \\in \\mathbb{R}^{4}$：\n    $$\n    b_1 = \\begin{bmatrix} 1 \\\\ 1 \\\\ 1 \\\\ 1 \\end{bmatrix}, \\quad\n    b_2 = \\begin{bmatrix} 1 \\\\ 0 \\\\ -1 \\\\ 0 \\end{bmatrix}, \\quad\n    b_3 = \\begin{bmatrix} 1 \\\\ 0 \\\\ 0 \\\\ 0 \\end{bmatrix}.\n    $$\n\n实现要求：\n- 您的程序必须为每个测试用例计算：\n  1. 直接解 $x_i^{\\mathrm{dir}}$，通过对 $A + U C V$ 进行一次性分解并对所有提供的右端项 $b_i$ 求解。\n  2. 加速解 $x_i^{\\mathrm{acc}}$，仅使用：\n     - 对 $A$ 的一次性分解，并重用于计算 $A^{-1} U$ 和 $A^{-1} b_i$。\n     - 对根据您的分析推导出的 $k \\times k$ 矩阵 $S$ 进行一次性构造和分解，并对所有右端项重用。\n     - 涉及 $U$、$V$、$C$、$A^{-1} U$ 和 $V A^{-1}$ 的矩阵乘积，但绝不显式构造 $A^{-1}$。\n- 对于每个测试用例，计算在所有给定右端项 $b_i$ 上逐项绝对差的最大值 $\\| x_i^{\\mathrm{dir}} - x_i^{\\mathrm{acc}} \\|_{\\infty}$。这些值必须以浮点数形式报告。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，结果顺序与上述测试用例的顺序一致。例如，如果有三个测试用例，输出必须类似于 $[r_1,r_2,r_3]$，其中每个 $r_j$ 是一个浮点数，表示测试用例 $j$ 的最大绝对差。",
            "solution": "问题陈述经确认为具有科学依据、提法恰当且客观。它提出了一个数值线性代数中的标准任务，即推导和应用 Woodbury 矩阵恒等式来高效求解带有低秩更新的线性系统。所有提供的数据和条件都是一致的，并且足以得到唯一解。\n\n### 加速公式的推导\n\n目标是找到一种高效计算 $x = (A + UCV)^{-1}b$ 的方法，其中 $A \\in \\mathbb{R}^{n \\times n}$ 是一个大型可逆矩阵，$U \\in \\mathbb{R}^{n \\times k}$、$C \\in \\mathbb{R}^{k \\times k}$、$V \\in \\mathbb{R}^{k \\times n}$ 表示一个低秩更新，且 $k \\ll n$。我们寻求一个依赖于 $A^{-1}$ 和一个小得多的 $k \\times k$ 矩阵的逆的 $(A + UCV)^{-1}$ 表达式。\n\n我们的出发点是给定的从 Schur 补推导出的分块矩阵求逆公式。我们可以通过构造一个适当的分块线性系统来推导所需的恒等式。方程 $(A + UCV)x = b$ 可以通过引入一个辅助变量 $y \\in \\mathbb{R}^k$ 来改写。\n\n我们定义一个方程组：\n1. $Ax + Uy = b$\n2. $-CVx + y = 0 \\implies y = CVx$\n\n将第二个方程中 $y$ 的表达式代入第一个方程，得到：\n$$A x + U(CVx) = b \\implies (A + UCV)x = b$$\n该方程组与原问题等价。我们可以将此系统表示为 $2 \\times 2$ 分块矩阵形式：\n$$\n\\begin{bmatrix} A  U \\\\ -CV  I_k \\end{bmatrix} \\begin{bmatrix} x \\\\ y \\end{bmatrix} = \\begin{bmatrix} b \\\\ 0 \\end{bmatrix}\n$$\n其中 $I_k$ 是 $k \\times k$ 单位矩阵。\n\n为了求得 $x$，我们需要计算该分块矩阵的逆。设该分块矩阵为 $M$：\n$$\nM = \\begin{bmatrix} P  Q \\\\ R  S' \\end{bmatrix} = \\begin{bmatrix} A  U \\\\ -CV  I_k \\end{bmatrix}\n$$\n我们使用分块矩阵求逆公式，该公式可以用分块 $P=A$ 的 Schur 补来表示。$A$ 的 Schur 补为 $S'_A = S' - R P^{-1} Q$。\n在我们的例子中，$P=A$，$Q=U$，$R=-CV$，$S'=I_k$。因此，Schur 补为：\n$$\nS'_A = I_k - (-CV)A^{-1}U = I_k + CVA^{-1}U\n$$\n按照题目建议，我们将这个 $k \\times k$ 矩阵记为 $S$，所以 $S = I_k + CVA^{-1}U$。我们必须假设 $S$ 是可逆的。问题的上下文，包括测试用例，表明该条件会成立。\n\n用 $P$ 的 Schur 补表示的分块矩阵求逆公式为：\n$$\nM^{-1} = \\begin{bmatrix}\nP^{-1} + P^{-1}Q(S'_A)^{-1}RP^{-1}  -P^{-1}Q(S'_A)^{-1} \\\\\n-(S'_A)^{-1}RP^{-1}  (S'_A)^{-1}\n\\end{bmatrix}\n$$\n解向量 $\\begin{bmatrix} x \\\\ y \\end{bmatrix}$ 由 $M^{-1} \\begin{bmatrix} b \\\\ 0 \\end{bmatrix}$ 给出。我们只对解 $x$ 感兴趣，它对应于结果的顶部块：\n$$\nx = (P^{-1} + P^{-1}Q(S'_A)^{-1}RP^{-1})b + (-P^{-1}Q(S'_A)^{-1})0\n$$\n$$\nx = (P^{-1} + P^{-1}Q(S'_A)^{-1}RP^{-1})b\n$$\n将此与 $x = (A+UCV)^{-1}b$ 进行比较，我们就得到了秩更新后矩阵的逆的表达式：\n$$\n(A+UCV)^{-1} = P^{-1} + P^{-1}Q(S'_A)^{-1}RP^{-1}\n$$\n代入 $P=A$，$Q=U$，$R=-CV$ 以及 $S'_A = S = I_k + CVA^{-1}U$：\n$$\n(A+UCV)^{-1} = A^{-1} + A^{-1}U(I_k + CVA^{-1}U)^{-1}(-CV)A^{-1}\n$$\n$$\n(A+UCV)^{-1} = A^{-1} - A^{-1}U(I_k + CVA^{-1}U)^{-1}CVA^{-1}\n$$\n这是 Woodbury 矩阵恒等式的一种形式。即使 $C$ 是奇异的，只要 $S=I_k + CVA^{-1}U$ 是可逆的，这个恒等式就成立。\n\n为了对多个右端项 $b_i$ 求解 $(A+UCV)x_i=b_i$，我们可以应用这个公式：\n$$\nx_i = (A+UCV)^{-1}b_i = A^{-1}b_i - A^{-1}U(I_k + CVA^{-1}U)^{-1}CVA^{-1}b_i\n$$\n这个表达式使得基于预计算和重用的高效求解策略成为可能。\n\n### 算法设计\n\n推导出的公式提示了一种算法，该算法避免了每次求解都构造和分解完整的 $n \\times n$ 矩阵 $A+UCV$ 的高昂代价，而是依赖于固定矩阵 $A$ 和小的 $k \\times k$ 矩阵 $S$ 的分解。\n\n**直接法算法：**\n1.  构造矩阵 $M = A + UCV$。此步骤成本为 $O(n^2k)$。\n2.  计算 $M$ 的一个稳定分解，例如 LU 分解。此步骤成本为 $O(n^3)$。\n3.  对于每个右端项 $b_i$，使用预计算的因子求解 $Mx_i=b_i$。每次求解的成本为 $O(n^2)$。\n\n**加速法算法：**\n公式 $x_i = A^{-1}b_i - A^{-1}U S^{-1} C V A^{-1}b_i$ 的结构指导了算法设计。\n\n**预计算阶段：**\n1.  计算 $A$ 的一个稳定分解（例如 LU 分解）以供重用。成本：$O(n^3)$。\n2.  通过求解系统 $AY=U$ 来计算矩阵 $A_{inv\\_U} = A^{-1}U$。这涉及到使用已分解的矩阵 $A$ 进行 $k$ 次求解。成本：$O(kn^2)$。注意，从未显式构造 $A^{-1}$。\n3.  通过求解 $A^T W = V^T$ 得到 $W$，然后令 $V_{A\\_inv} = W^T$ 来计算矩阵 $V_{A\\_inv} = VA^{-1}$。这涉及到使用 $A^T$ 进行 $k$ 次求解。成本：$O(kn^2)$。\n4.  构造 $k \\times k$ 矩阵 $S = I_k + C(V_{A\\_inv} U)$。成本：$O(k^2n)$。\n5.  计算 $S$ 的一个稳定分解。成本：$O(k^3)$。\n\n**单次求解阶段（对每个 $b_i$）：**\n为了计算 $x_i$，我们从右到左计算表达式，以保持矩阵-向量乘法的效率。\n$x_i = (A^{-1}b_i) - (A^{-1}U) [S^{-1} (C (V (A^{-1}b_i)))]$。\n1.  使用 $A$ 的分解求解 $Ay_i=b_i$ 来计算 $y_i = A^{-1}b_i$。成本：$O(n^2)$。\n2.  计算 $k \\times 1$ 向量 $v_i = V y_i$。成本：$O(kn)$。\n3.  计算 $k \\times 1$ 向量 $w_i = C v_i$。成本：$O(k^2)$。\n4.  使用 $S$ 的分解求解 $Sz_i=w_i$ 来计算 $z_i = S^{-1}w_i$。成本：$O(k^2)$。\n5.  使用预计算的矩阵 $A_{inv\\_U}$ 计算 $n \\times 1$ 的修正项 $u_i = A_{inv\\_U} z_i$。成本：$O(nk)$。\n6.  计算最终解 $x_i = y_i - u_i$。成本：$O(n)$。\n\n加速法求解阶段的总成本主要由单次关于 $A$ 的求解主导，其成本为 $O(n^2)$。如果 $A,U,C,V$ 在每次求解时都发生变化，这比直接法的预计算成本（$O(n^3)$）要高效得多。对于使用固定矩阵的多次求解，两种方法都有很高的初始预计算成本，但如果关于 $A$ 的求解特别便宜（例如，$A$ 是稀疏的或具有特殊结构），或者如果 $A$ 的分解已从先前的计算中获得，那么加速法提供了一个非常有优势的框架。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef direct_solve(A, U, C, V, B):\n    \"\"\"\n    Solves (A + UCV)x_i = b_i for each column b_i in B using a direct method.\n    \"\"\"\n    n, _ = A.shape\n    num_rhs = B.shape[1]\n    \n    # 1. Form the matrix M = A + UCV\n    M = A + U @ C @ V\n    \n    # 2. Compute a stable factorization of M\n    try:\n        lu_M, piv_M = linalg.lu_factor(M)\n    except linalg.LinAlgError:\n        # The matrix M is singular.\n        # This can happen in test case 3. Return NaNs in that case.\n        return np.full((n, num_rhs), np.nan)\n        \n    # 3. Solve for each right-hand side\n    X_dir = np.zeros((n, num_rhs))\n    for i in range(num_rhs):\n        b_i = B[:, i]\n        X_dir[:, i] = linalg.lu_solve((lu_M, piv_M), b_i)\n        \n    return X_dir\n\ndef accelerated_solve(A, U, C, V, B):\n    \"\"\"\n    Solves (A + UCV)x_i = b_i using the Woodbury matrix identity.\n    \"\"\"\n    n, k = U.shape\n    num_rhs = B.shape[1]\n    I_k = np.eye(k)\n\n    # --- Precomputation Phase ---\n    # 1. Compute a stable factorization of A\n    try:\n        lu_A, piv_A = linalg.lu_factor(A)\n    except linalg.LinAlgError:\n        # A is singular.\n        return np.full((n, num_rhs), np.nan)\n    \n    # 2. Compute A_inv_U = A^{-1}U\n    A_inv_U = linalg.lu_solve((lu_A, piv_A), U)\n    \n    # 3. Compute S = I_k + C * V * A^{-1} * U\n    S = I_k + C @ (V @ A_inv_U)\n\n    # 4. Compute a stable factorization of S\n    try:\n        lu_S, piv_S = linalg.lu_factor(S)\n    except linalg.LinAlgError:\n        # S is singular. The Woodbury identity does not apply directly.\n        # This means A+UCV is also singular.\n        return np.full((n, num_rhs), np.nan)\n\n    # --- Per-Solve Phase ---\n    X_acc = np.zeros((n, num_rhs))\n    for i in range(num_rhs):\n        b_i = B[:, i]\n        \n        # 1. Compute y_i = A^{-1}b_i\n        y_i = linalg.lu_solve((lu_A, piv_A), b_i)\n        \n        # 2. Compute v_i = V * y_i\n        v_i = V @ y_i\n        \n        # 3. Compute w_i = C * v_i\n        w_i = C @ v_i\n        \n        # 4. Compute z_i = S^{-1} * w_i\n        z_i = linalg.lu_solve((lu_S, piv_S), w_i)\n        \n        # 5. Compute correction u_i = A^{-1}U * z_i\n        u_i = A_inv_U @ z_i\n        \n        # 6. Compute final solution x_i = y_i - u_i\n        X_acc[:, i] = y_i - u_i\n        \n    return X_acc\n\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run solvers, and print results.\n    \"\"\"\n    # Test case 1: n=5, k=2\n    A1 = np.diag([4.0]*5) + np.diag([-1.0]*4, k=1) + np.diag([-1.0]*4, k=-1)\n    U1 = np.zeros((5, 2))\n    U1[0, 0] = 1.0\n    U1[2, 1] = 1.0\n    V1 = np.array([\n        [1.0, 0.0, 1.0, 0.0, 0.0],\n        [0.0, 1.0, 0.0, 1.0, 0.0]\n    ])\n    C1 = np.array([\n        [2.0, 1.0],\n        [-1.0, 3.0]\n    ])\n    B1 = np.array([\n        [1.0, 1.0, 1.0, 1.0, 1.0],\n        [1.0, 2.0, 3.0, 4.0, 5.0],\n        [0.0, 0.0, 0.0, 0.0, 1.0]\n    ]).T\n\n    # Test case 2: n=6, k=1\n    A2 = np.diag([1.0, 3.0, 5.0, 7.0, 9.0, 11.0])\n    U2 = np.array([[1.0, 0.0, 1.0, 0.0, 1.0, 0.0]]).T\n    V2 = np.array([[0.0, 1.0, 0.0, 1.0, 0.0, 1.0]])\n    C2 = np.array([[10.0]])\n    B2 = np.array([\n        [1.0, 1.0, 1.0, 1.0, 1.0, 1.0],\n        [6.0, 5.0, 4.0, 3.0, 2.0, 1.0],\n        [0.0, 0.0, 1.0, 0.0, 0.0, 0.0]\n    ]).T\n    \n    # Test case 3: n=4, k=2, C is singular\n    A3 = np.diag([1e-3, 2.0, 3.0, 4.0])\n    U3 = np.array([\n        [1.0, 0.0],\n        [0.0, 1.0],\n        [1.0, 1.0],\n        [0.0, 1.0]\n    ])\n    V3 = np.array([\n        [1.0, -1.0, 0.0, 0.0],\n        [0.0, 1.0, 1.0, 0.0]\n    ])\n    C3 = np.array([\n        [0.0, 1.0],\n        [0.0, 0.0]\n    ])\n    B3 = np.array([\n        [1.0, 1.0, 1.0, 1.0],\n        [1.0, 0.0, -1.0, 0.0],\n        [1.0, 0.0, 0.0, 0.0]\n    ]).T\n\n    test_cases = [\n        (A1, U1, C1, V1, B1),\n        (A2, U2, C2, V2, B2),\n        (A3, U3, C3, V3, B3)\n    ]\n    \n    results = []\n    for case in test_cases:\n        A, U, C, V, B = case\n        \n        # 1. Compute direct solution\n        X_dir = direct_solve(A, U, C, V, B)\n        \n        # 2. Compute accelerated solution\n        X_acc = accelerated_solve(A, U, C, V, B)\n        \n        # 3. Compute maximum absolute entrywise difference\n        # Handle NaN cases where matrices are singular\n        if np.isnan(X_dir).any() and np.isnan(X_acc).any():\n            max_abs_diff = 0.0 # Both methods correctly identified singularity\n        else:\n            max_abs_diff = np.max(np.abs(X_dir - X_acc))\n        results.append(max_abs_diff)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}