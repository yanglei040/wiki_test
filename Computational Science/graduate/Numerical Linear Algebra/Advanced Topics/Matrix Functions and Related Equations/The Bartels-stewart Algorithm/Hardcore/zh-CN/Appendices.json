{
    "hands_on_practices": [
        {
            "introduction": "在通过舒尔分解 (Schur decomposition) 将西尔维斯特方程 (Sylvester equation) 转化为三角形式后，Bartels-Stewart 算法的核心就转变为求解一个结构化的三角系统。本练习将引导你深入该过程的底层机制。通过推导一个标量递推公式，你将揭示求解过程中各元素间的依赖关系，并确定一个保证计算顺利进行的有效顺序，从而为理解整个算法奠定坚实的基础。",
            "id": "3584637",
            "problem": "考虑 Bartels–Stewart 算法 (BSA) 核心步骤中的 Sylvester 方程，该算法将一对通用矩阵约化为实舒尔型 (RSF)：给定上三角矩阵 $T \\in \\mathbb{R}^{n \\times n}$ 和 $S \\in \\mathbb{R}^{m \\times m}$ 以及右端项 $F \\in \\mathbb{R}^{n \\times m}$，求解未知矩阵 $Y \\in \\mathbb{R}^{n \\times m}$ 以满足\n$$\nT Y + Y S = F,\n$$\n\n1. 仅从矩阵乘法的定义以及 $T$ 和 $S$ 是上三角矩阵的性质出发，推导出一个关于 $Y$ 的元素 $y_{ij}$ 的显式标量递推公式，该公式用 $T$、$S$、$F$ 的元素以及 $Y$ 中已计算出的元素表示。你的推导必须分离出对角项，并系统地化简由上三角结构所产生的双重求和；不要引用任何现成的公式。\n\n2. 使用你的递推公式，为索引对 $(i,j)$ 提出一个计算顺序，以保证在计算 $y_{ij}$ 时，其所依赖的所有量都已被计算。从你的推导所揭示的依赖结构出发，对你的顺序进行逻辑论证。\n\n3. 将你的顺序应用于以下具体的 $3 \\times 3$ 实例：\n$$\nT=\\begin{pmatrix}\n2  1  -1\\\\\n0  3  2\\\\\n0  0  5\n\\end{pmatrix},\\quad\nS=\\begin{pmatrix}\n-1  2  0\\\\\n0  4  1\\\\\n0  0  6\n\\end{pmatrix},\\quad\nF=\\begin{pmatrix}\n1  0  2\\\\\n3  -1  1\\\\\n4  2  0\n\\end{pmatrix}.\n$$\n精确计算单个元素 $y_{23}$。将你的最终答案表示为一个精确的有理数；不要四舍五入。",
            "solution": "该问题是有效的，因为它代表了数值线性代数中的一个标准任务——求解上三角矩阵的 Sylvester 方程，这是 Bartels-Stewart 算法的核心。给定的矩阵和方程是良定义的，并且唯一解的存在性得到了保证，因为 $T$ 和 $-S$ 的谱是不相交的。具体来说，$T$ 的特征值为 $\\{2, 3, 5\\}$，$S$ 的特征值为 $\\{-1, 4, 6\\}$，所以 $-S$ 的特征值为 $\\{1, -4, -6\\}$。这些集合不相交，确保了对于所有 $i, j$ 都有 $t_{ii} + s_{jj} \\neq 0$，这是我们将要推导的递推公式的可解性条件。\n\n### 第1部分：标量递推公式的推导\n\nSylvester 方程由下式给出\n$$\nTY + YS = F\n$$\n其中 $T \\in \\mathbb{R}^{n \\times n}$ 和 $S \\in \\mathbb{R}^{m \\times m}$ 是上三角矩阵，$F \\in \\mathbb{R}^{n \\times m}$，$Y \\in \\mathbb{R}^{n \\times m}$。我们寻求矩阵 $Y$ 的元素 $y_{ij}$ 的标量公式。\n\n矩阵方程的第 $(i,j)$ 个元素由下式给出：\n$$\n(TY)_{ij} + (YS)_{ij} = f_{ij}\n$$\n其中 $i \\in \\{1, \\dots, n\\}$ 且 $j \\in \\{1, \\dots, m\\}$。\n\n使用矩阵乘法的定义，我们展开左边的两项：\n$$\n(TY)_{ij} = \\sum_{k=1}^{n} t_{ik} y_{kj}\n$$\n$$\n(YS)_{ij} = \\sum_{l=1}^{m} y_{il} s_{lj}\n$$\n\n现在，我们引入 $T$ 和 $S$ 的上三角结构。\n对于矩阵 $T$，$t_{ik} = 0$ 当 $i  k$ 时。因此，$(TY)_{ij}$ 的求和可以简化为从索引 $k=i$ 开始：\n$$\n(TY)_{ij} = \\sum_{k=i}^{n} t_{ik} y_{kj}\n$$\n对于矩阵 $S$，$s_{lj} = 0$ 当 $l  j$ 时。因此，$(YS)_{ij}$ 的求和可以简化为在索引 $l=j$ 处结束：\n$$\n(YS)_{ij} = \\sum_{l=1}^{j} y_{il} s_{lj}\n$$\n\n将这些代入分量方程中，得到：\n$$\n\\sum_{k=i}^{n} t_{ik} y_{kj} + \\sum_{l=1}^{j} y_{il} s_{lj} = f_{ij}\n$$\n\n我们的目标是解出 $y_{ij}$。为此，我们必须从两个求和中分离出包含 $y_{ij}$ 的项。\n在第一个和式 $\\sum_{k=i}^{n} t_{ik} y_{kj}$ 中，包含 $y_{ij}$ 的项在 $k=i$ 时出现。\n在第二个和式 $\\sum_{l=1}^{j} y_{il} s_{lj}$ 中，包含 $y_{ij}$ 的项在 $l=j$ 时出现。\n\n让我们从各自的和式中分离出这些项：\n$$\n\\left( t_{ii} y_{ij} + \\sum_{k=i+1}^{n} t_{ik} y_{kj} \\right) + \\left( \\sum_{l=1}^{j-1} y_{il} s_{lj} + y_{ij} s_{jj} \\right) = f_{ij}\n$$\n注意，当 $i=n$ 时，第一个和式 $\\sum_{k=i+1}^{n}$ 为空；当 $j=1$ 时，第二个和式 $\\sum_{l=1}^{j-1}$ 为空。\n\n现在，我们将含有 $y_{ij}$ 的项分组到左侧，并将所有其他项移到右侧：\n$$\nt_{ii} y_{ij} + y_{ij} s_{jj} = f_{ij} - \\sum_{k=i+1}^{n} t_{ik} y_{kj} - \\sum_{l=1}^{j-1} y_{il} s_{lj}\n$$\n提取 $y_{ij}$ 因子：\n$$\n(t_{ii} + s_{jj}) y_{ij} = f_{ij} - \\sum_{k=i+1}^{n} t_{ik} y_{kj} - \\sum_{l=1}^{j-1} y_{il} s_{lj}\n$$\n如前所述，唯一解的条件确保了对于所有有效的索引对 $(i,j)$，都有 $t_{ii} + s_{jj} \\neq 0$。因此，我们可以除以这个因子，得到 $y_{ij}$ 的显式标量递推公式：\n$$\ny_{ij} = \\frac{1}{t_{ii} + s_{jj}} \\left( f_{ij} - \\sum_{k=i+1}^{n} t_{ik} y_{kj} - \\sum_{l=1}^{j-1} y_{il} s_{lj} \\right)\n$$\n\n### 第2部分：计算顺序\n\n第1部分推导出的递推公式显示了计算 $y_{ij}$ 的依赖关系：\n$y_{ij}$ 依赖于：\n1.  $T$、$S$ 和 $F$ 的元素。这些是给定的。\n2.  $y_{kj}$ 元素，其中 $k  i$。这些是 $Y$ 中同一列 $j$ 但在第 $i$ 行下方的元素。\n3.  $y_{il}$ 元素，其中 $l  j$。这些是 $Y$ 中同一行 $i$ 但在第 $j$ 列左侧的元素。\n\n为确保计算顺序有效，我们必须在计算了 $y_{ij}$ 所依赖的所有元素之后才能计算它。让我们分析依赖结构。要计算位置 $(i,j)$ 的元素，我们需要同一列中其下方的所有元素，以及同一行中其左侧的所有元素。\n\n这表明了一种遍历矩阵 $Y$ 以满足这些依赖关系的顺序。一种有效的顺序是逐列计算 $Y$ 的元素，从左到右，在每一列中，从下到上。\n\n建议的顺序如下：\n遍历列 $j$ 从 $1$ 到 $m$。对于每一列 $j$，遍历行 $i$ 从 $n$ 到 $1$。计算的索引 $(i,j)$ 序列将是 $(n,1), (n-1,1), \\dots, (1,1)$，然后是 $(n,2), (n-1,2), \\dots, (1,2)$，依此类推，直到 $(n,m), \\dots, (1,m)$。\n\n论证：当我们使用此顺序计算 $y_{ij}$ 时：\n- 项 $\\sum_{k=i+1}^{n} t_{ik} y_{kj}$ 依赖于元素 $y_{(i+1)j}, \\dots, y_{nj}$。这些元素在同一列 $j$ 但在第 $i$ 行下方。由于我们是从 $n$ 到 $1$ 遍历行，这些元素在当前列的遍历中已经被计算。\n- 项 $\\sum_{l=1}^{j-1} y_{il} s_{lj}$ 依赖于元素 $y_{i1}, \\dots, y_{i(j-1)}$。这些元素在同一行 $i$ 但在第 $j$ 列的左侧。由于我们是从 $1$ 到 $m$ 遍历列，第 $1, \\dots, j-1$ 列中的所有元素都已被完全计算。\n\n因此，这个顺序保证了在计算 $y_{ij}$ 时，递推公式右侧所有需要的值都已知。另一种有效的顺序是遍历行 $i$ 从 $n$ 到 $1$，对于每一行，遍历列 $j$ 从 $1$ 到 $m$。\n\n### 第3部分：计算 $y_{23}$\n\n我们给定的矩阵是：\n$$\nT=\\begin{pmatrix}\n2  1  -1\\\\\n0  3  2\\\\\n0  0  5\n\\end{pmatrix},\\quad\nS=\\begin{pmatrix}\n-1  2  0\\\\\n0  4  1\\\\\n0  0  6\n\\end{pmatrix},\\quad\nF=\\begin{pmatrix}\n1  0  2\\\\\n3  -1  1\\\\\n4  2  0\n\\end{pmatrix}\n$$\n我们需要求 $y_{23}$。对于 $(i,j) = (2,3)$，其中 $n=3, m=3$，使用公式：\n$$\ny_{23} = \\frac{1}{t_{22} + s_{33}} \\left( f_{23} - \\sum_{k=3}^{3} t_{2k} y_{k3} - \\sum_{l=1}^{2} y_{2l} s_{l3} \\right)\n$$\n$$\ny_{23} = \\frac{1}{t_{22} + s_{33}} \\left( f_{23} - t_{23}y_{33} - (y_{21}s_{13} + y_{22}s_{23}) \\right)\n$$\n这表明要计算 $y_{23}$，我们首先需要计算 $y_{33}$、$y_{21}$ 和 $y_{22}$。我们将按照第2部分的顺序计算这些依赖项。\n\n1.  **计算 $y_{31}$：** 从列 $j=1$，行 $i=3$ 开始。\n    $y_{31} = \\frac{1}{t_{33}+s_{11}}(f_{31}) = \\frac{1}{5+(-1)}(4) = \\frac{4}{4} = 1$。\n\n2.  **计算 $y_{21}$：** 列 $j=1$，行 $i=2$。\n    $y_{21} = \\frac{1}{t_{22}+s_{11}}(f_{21} - t_{23}y_{31}) = \\frac{1}{3+(-1)}(3 - (2)(1)) = \\frac{1}{2}(1) = \\frac{1}{2}$。\n\n3.  **计算 $y_{32}$：** 列 $j=2$，行 $i=3$。\n    $y_{32} = \\frac{1}{t_{33}+s_{22}}(f_{32} - y_{31}s_{12}) = \\frac{1}{5+4}(2 - (1)(2)) = \\frac{1}{9}(0) = 0$。\n\n4.  **计算 $y_{22}$：** 列 $j=2$，行 $i=2$。\n    $y_{22} = \\frac{1}{t_{22}+s_{22}}(f_{22} - t_{23}y_{32} - y_{21}s_{12}) = \\frac{1}{3+4}(-1 - (2)(0) - (\\frac{1}{2})(2)) = \\frac{1}{7}(-1 - 1) = -\\frac{2}{7}$。\n\n5.  **计算 $y_{33}$：** 列 $j=3$，行 $i=3$。\n    $y_{33} = \\frac{1}{t_{33}+s_{33}}(f_{33} - (y_{31}s_{13} + y_{32}s_{23})) = \\frac{1}{5+6}(0 - ((1)(0) + (0)(1))) = \\frac{1}{11}(0) = 0$。\n\n6.  **最后，计算 $y_{23}$：** 列 $j=3$，行 $i=2$。\n    我们现在有了所有必要的值：\n    - $t_{22}=3, s_{33}=6$\n    - $f_{23}=1$\n    - $t_{23}=2$\n    - $s_{13}=0, s_{23}=1$\n    - $y_{33}=0$\n    - $y_{21}=1/2$\n    - $y_{22}=-2/7$\n\n    将这些值代入 $y_{23}$ 的公式中：\n    $$\n    y_{23} = \\frac{1}{3+6} \\left( 1 - (2)(0) - \\left( \\left(\\frac{1}{2}\\right)(0) + \\left(-\\frac{2}{7}\\right)(1) \\right) \\right)\n    $$\n    $$\n    y_{23} = \\frac{1}{9} \\left( 1 - 0 - \\left( 0 - \\frac{2}{7} \\right) \\right)\n    $$\n    $$\n    y_{23} = \\frac{1}{9} \\left( 1 + \\frac{2}{7} \\right)\n    $$\n    $$\n    y_{23} = \\frac{1}{9} \\left( \\frac{7}{7} + \\frac{2}{7} \\right)\n    $$\n    $$\n    y_{23} = \\frac{1}{9} \\left( \\frac{9}{7} \\right)\n    $$\n    $$\n    y_{23} = \\frac{1}{7}\n    $$\n元素 $y_{23}$ 的值为 $\\frac{1}{7}$。",
            "answer": "$$\\boxed{\\frac{1}{7}}$$"
        },
        {
            "introduction": "理解了基本的求解机制后，我们来探讨一个更深层次的问题：为何算法必须采用块回代，特别是要将实舒尔型 (real Schur form) 中的 $2 \\times 2$ 块作为一个整体来处理？本练习通过一个精心设计的思想实验，展示了当天真地忽略代表复共轭特征值的 $2 \\times 2$ 块的耦合时，会如何导致灾难性的误差放大。这个实践将让你深刻体会到块结构对于算法数值稳定性的关键作用。",
            "id": "3584620",
            "problem": "考虑西尔维斯特方程 $A X + X B = C$，其中 $A \\in \\mathbb{R}^{2 \\times 2}$ 是一个上三角矩阵，$B \\in \\mathbb{R}^{2 \\times 2}$ 是一个对应于一对共轭复特征值的实 $2 \\times 2$ 舒尔块。在 Bartels–Stewart 算法中，首先将矩阵化为实舒尔形式，然后通过分块回代法求解得到的三角西尔维斯特方程，并将 $2 \\times 2$ 的对角块作为原子主元处理。在本题中，您将构造一个反例，说明若简单地将 $B$ 中的 $2 \\times 2$ 舒尔块视为两个独立的 $1 \\times 1$ 标量（即，忽略非对角耦合），会产生灾难性的放大效应。然后，您将量化通过采用分块主元法所获得的改进。\n\n设\n$$\nA = \\begin{pmatrix}\n-1  1 \\\\\n0  -1\n\\end{pmatrix}, \\quad\nB = \\begin{pmatrix}\n1 + \\delta  M \\\\\n- M  1 + \\delta\n\\end{pmatrix}, \\quad\nC = \\begin{pmatrix}\n0  0 \\\\\n1  0\n\\end{pmatrix},\n$$\n其中参数 $M  0$ 和 $0  \\delta \\ll 1$ 是固定的。注意 $B$ 是复数对 $1 + \\delta \\pm i M$ 的实舒尔形式。\n\n1. 仅使用关于西尔维斯特方程和谱的基本事实（即，$A X + X B = C$ 有唯一解当且仅当 $A$ 和 $-B$ 的谱不相交），证明上述真实的西尔维斯特方程对于所有 $M  0$ 和 $\\delta  0$ 都是唯一可解的。\n\n2. 定义一个朴素的、忽略分块的方案，即用对角矩阵 $\\widetilde{B} = \\operatorname{diag}(1 + \\delta, 1 + \\delta)$ 替换 $B$，从而忽略非对角耦合。在这个朴素方案中，$X$ 的第二行解耦，并由标量三角系统 $(A + (1 + \\delta) I) X_{:,j} = C_{:,j}$（其中 $j \\in \\{1,2\\}$）计算得出。计算得到的数对 $(x_{21}^{\\mathrm{naive}}, x_{22}^{\\mathrm{naive}})$ 及其以 $\\delta$ 和 $M$ 表示的欧几里得范数。\n\n3. 在 Bartels–Stewart 算法所要求的正确的分块主元法中，变量 $(x_{21}, x_{22})$ 通过一个 $2 \\times 2$ 线性系统同时求解，该系统是通过将 $A X + X B = C$ 限制在 $X$ 的第二行和 $B$ 的 $2 \\times 2$ 舒尔块上得到的。推导关于 $(x_{21}, x_{22})$ 的 $2 \\times 2$ 系统，显式求解，并计算其以 $\\delta$ 和 $M$ 表示的欧几里得范数 $\\| (x_{21}, x_{22}) \\|_{2}$。\n\n4. 将改进因子定义为朴素范数与采用分块方法所得范数之比。用解析式表达该比率，然后针对具体的数值 $\\delta = 10^{-6}$ 和 $M = 1$ 计算其值。将最终答案四舍五入至三位有效数字。将最终答案表示为单个无单位的实数。",
            "solution": "本题要求分析一个特定的西尔维斯特方程 $A X + X B = C$，以说明 Bartels-Stewart 算法的一个关键稳定性特征。该分析涉及将一个朴素解法与正确的分块方法进行比较。\n\n给定的矩阵和参数为：\n$$\nA = \\begin{pmatrix}\n-1  1 \\\\\n0  -1\n\\end{pmatrix}, \\quad\nB = \\begin{pmatrix}\n1 + \\delta  M \\\\\n-M  1 + \\delta\n\\end{pmatrix}, \\quad\nC = \\begin{pmatrix}\n0  0 \\\\\n1  0\n\\end{pmatrix},\n$$\n其中 $M  0$ 且 $0  \\delta \\ll 1$。\n\n1. 唯一解的证明：\n西尔维斯特方程 $A X + X B = C$ 存在唯一解的充要条件是 $A$ 和 $-B$ 的谱（分别记为 $\\sigma(A)$ 和 $\\sigma(-B)$）不相交，即 $\\sigma(A) \\cap \\sigma(-B) = \\emptyset$。\n\n首先，我们确定 $A$ 的谱。由于 $A$ 是一个上三角矩阵，其特征值是其对角线元素。\n$$ \\sigma(A) = \\{-1\\} $$\n接下来，我们求 $B$ 的谱。$B$ 的特征值是特征方程 $\\det(B - \\lambda I) = 0$ 的根。\n$$ \\det \\begin{pmatrix} 1 + \\delta - \\lambda  M \\\\ -M  1 + \\delta - \\lambda \\end{pmatrix} = (1 + \\delta - \\lambda)^2 + M^2 = 0 $$\n$$ (1 + \\delta - \\lambda)^2 = -M^2 $$\n$$ 1 + \\delta - \\lambda = \\pm i M $$\n$$ \\lambda = 1 + \\delta \\mp i M $$\n所以，$B$ 的谱为 $\\sigma(B) = \\{1 + \\delta + i M, 1 + \\delta - i M\\}$。\n\n$-B$ 的谱由 $B$ 的特征值的相反数组成。\n$$ \\sigma(-B) = \\{-(1 + \\delta + i M), -(1 + \\delta - i M)\\} = \\{-1 - \\delta - i M, -1 - \\delta + i M\\} $$\n为了检查谱 $\\sigma(A)$ 和 $\\sigma(-B)$ 是否不相交，我们将 $\\sigma(A)$ 中的唯一元素 $-1$ 与 $\\sigma(-B)$ 中的元素进行比较。如果 $-1$ 是 $\\sigma(-B)$ 中的一个元素，那么我们会有 $-1 = -1 - \\delta \\pm i M$，化简后得到 $\\delta = \\pm i M$。这是一个矛盾，因为根据题设，$\\delta$ 和 $M$ 都是正实数。因此，$-1 \\notin \\sigma(-B)$，谱不相交。这证实了西尔维斯特方程 $A X + X B = C$ 有唯一解。\n\n2. 朴素的、忽略分块的方案：\n在此方案中，$B$ 被其对角部分 $\\widetilde{B} = \\operatorname{diag}(1 + \\delta, 1 + \\delta) = (1 + \\delta)I_{2}$ 近似，其中 $I_{2}$ 是 $2 \\times 2$ 的单位矩阵。西尔维斯特方程变为 $A X_{\\mathrm{naive}} + X_{\\mathrm{naive}}((1 + \\delta)I_{2}) = C$。提取 $X_{\\mathrm{naive}}$ 因子后得到 $(A + (1 + \\delta)I_{2}) X_{\\mathrm{naive}} = C$。\n\n我们计算矩阵 $A + (1+\\delta)I_{2}$：\n$$ A + (1+\\delta)I_{2} = \\begin{pmatrix} -1  1 \\\\ 0  -1 \\end{pmatrix} + \\begin{pmatrix} 1+\\delta  0 \\\\ 0  1+\\delta \\end{pmatrix} = \\begin{pmatrix} \\delta  1 \\\\ 0  \\delta \\end{pmatrix} $$\n需要求解的系统是：\n$$ \\begin{pmatrix} \\delta  1 \\\\ 0  \\delta \\end{pmatrix} \\begin{pmatrix} x_{11}  x_{12} \\\\ x_{21}  x_{22} \\end{pmatrix} = \\begin{pmatrix} 0  0 \\\\ 1  0 \\end{pmatrix} $$\n题目要求我们求 $X_{\\mathrm{naive}}$ 的第二行，我们称之为 $(x_{21}^{\\mathrm{naive}}, x_{22}^{\\mathrm{naive}})$。该行由矩阵方程的第二行确定，该行与第一行是解耦的。对于第一列 $(j=1)$，方程为 $0 \\cdot x_{11} + \\delta \\cdot x_{21} = 1$，可得 $x_{21}^{\\mathrm{naive}} = \\frac{1}{\\delta}$。对于第二列 $(j=2)$，方程为 $0 \\cdot x_{12} + \\delta \\cdot x_{22} = 0$，可得 $x_{22}^{\\mathrm{naive}} = 0$。\n因此，第二行的朴素解为 $(x_{21}^{\\mathrm{naive}}, x_{22}^{\\mathrm{naive}}) = (\\frac{1}{\\delta}, 0)$。\n\n该向量的欧几里得范数为：\n$$ \\|(x_{21}^{\\mathrm{naive}}, x_{22}^{\\mathrm{naive}})\\|_2 = \\sqrt{\\left(\\frac{1}{\\delta}\\right)^2 + 0^2} = \\frac{1}{\\delta} \\quad (\\text{因为 } \\delta  0) $$\n\n3. 正确的分块主元法：\nBartels-Stewart 算法使用基于 $A$ 的舒尔形式的分块回代法来求解 $X$。在这里，我们可以按行对 $A$ 和 $X$ 进行分块。设 $X_1 = (x_{11}, x_{12})$ 和 $X_2 = (x_{21}, x_{22})$ 分别是 $X$ 的第一行和第二行。西尔维斯特方程 $AX+XB=C$ 可以写成关于 $X$ 的行的分块形式：\n$$ \\begin{pmatrix} -1  1 \\\\ 0  -1 \\end{pmatrix} \\begin{pmatrix} X_1 \\\\ X_2 \\end{pmatrix} + \\begin{pmatrix} X_1 \\\\ X_2 \\end{pmatrix} B = \\begin{pmatrix} C_1 \\\\ C_2 \\end{pmatrix} $$\n展开后得到一个包含两个矩阵方程的系统：\n$$ -X_1 + X_2 + X_1 B = C_1 $$\n$$ -X_2 + X_2 B = C_2 $$\n第二个方程 $-X_2 + X_2 B = C_2$ 可以首先求解 $X_2$。其中 $X_2 = (x_{21}, x_{22})$，$C_2 = (1, 0)$（$C$ 的第二行），我们有：\n$$ X_2 (B - I_2) = C_2 $$\n矩阵 $(B - I_2)$ 为：\n$$ B - I_2 = \\begin{pmatrix} 1 + \\delta  M \\\\ -M  1 + \\delta \\end{pmatrix} - \\begin{pmatrix} 1  0 \\\\ 0  1 \\end{pmatrix} = \\begin{pmatrix} \\delta  M \\\\ -M  \\delta \\end{pmatrix} $$\n关于 $(x_{21}, x_{22})$ 的方程是 $(x_{21}, x_{22}) \\begin{pmatrix} \\delta  M \\\\ -M  \\delta \\end{pmatrix} = (1, 0)$。这对应于 $2 \\times 2$ 线性系统：\n$$ \\delta x_{21} - M x_{22} = 1 $$\n$$ M x_{21} + \\delta x_{22} = 0 $$\n由第二个方程，我们得到 $x_{21} = -\\frac{\\delta}{M} x_{22}$。将此代入第一个方程：\n$$ \\delta \\left(-\\frac{\\delta}{M} x_{22}\\right) - M x_{22} = 1 \\implies \\left(-\\frac{\\delta^2}{M} - M\\right) x_{22} = 1 $$\n$$ -\\frac{\\delta^2 + M^2}{M} x_{22} = 1 \\implies x_{22} = -\\frac{M}{\\delta^2 + M^2} $$\n代回以求得 $x_{21}$：\n$$ x_{21} = -\\frac{\\delta}{M} \\left(-\\frac{M}{\\delta^2 + M^2}\\right) = \\frac{\\delta}{\\delta^2 + M^2} $$\n第二行的正确解为 $(x_{21}, x_{22}) = \\left(\\frac{\\delta}{\\delta^2 + M^2}, -\\frac{M}{\\delta^2 + M^2}\\right)$。\n\n该向量的欧几里得范数为：\n$$ \\|(x_{21}, x_{22})\\|_2 = \\sqrt{\\left(\\frac{\\delta}{\\delta^2 + M^2}\\right)^2 + \\left(-\\frac{M}{\\delta^2 + M^2}\\right)^2} = \\sqrt{\\frac{\\delta^2 + M^2}{(\\delta^2 + M^2)^2}} = \\frac{1}{\\sqrt{\\delta^2 + M^2}} $$\n\n4. 改进因子：\n改进因子定义为朴素范数与采用分块方法所得范数之比。\n$$ \\text{比率} = \\frac{\\|(x_{21}^{\\mathrm{naive}}, x_{22}^{\\mathrm{naive}})\\|_2}{\\|(x_{21}, x_{22})\\|_2} = \\frac{1/\\delta}{1/\\sqrt{\\delta^2 + M^2}} = \\frac{\\sqrt{\\delta^2 + M^2}}{\\delta} $$\n对于具体数值 $\\delta = 10^{-6}$ 和 $M = 1$：\n$$ \\text{比率} = \\frac{\\sqrt{(10^{-6})^2 + 1^2}}{10^{-6}} = \\frac{\\sqrt{10^{-12} + 1}}{10^{-6}} $$\n$\\sqrt{1 + 10^{-12}}$ 的值非常接近 1。计算得出：\n$$ \\text{比率} \\approx \\frac{1}{10^{-6}} = 10^6 $$\n将此结果四舍五入至三位有效数字，得到 $1.00 \\times 10^6$。",
            "answer": "$$\\boxed{1.00 \\times 10^{6}}$$"
        },
        {
            "introduction": "最后一个练习将理论与计算实践联系起来，让你从分析走向验证。你将设计并实施一个数值实验，以量化研究求解精度与问题条件数（由谱分离度 $\\operatorname{sep}(A,B)$ 衡量）之间的关系。通过亲手构建具有可控谱邻近度的矩阵并评估求解器的性能，你将能够直观地观察到理论预测的现象：即使算法是向后稳定的，随着谱分离度的减小，前向误差也会显著增大。",
            "id": "3584663",
            "problem": "您将设计并执行一个数值实验，以研究基于 Bartels–Stewart 算法的西尔维斯特方程求解器的前向误差和残差如何随着谱分离度的减小而变化。其数学背景如下。考虑西尔维斯特方程 $A X - X B = C$，其中 $A \\in \\mathbb{R}^{n \\times n}$，$B \\in \\mathbb{R}^{n \\times n}$，$C \\in \\mathbb{R}^{n \\times n}$。当 $A$ 和 $B$ 的谱不相交时，由 $\\mathcal{L}(X) = A X - X B$ 定义的线性算子 $\\mathcal{L} : \\mathbb{R}^{n \\times n} \\to \\mathbb{R}^{n \\times n}$ 是唯一可解的。该算子的一个典型条件度量是分离度\n$$\n\\operatorname{sep}(A,B) = \\min_{\\|X\\|_F = 1} \\|A X - X B\\|_F,\n$$\n它等于克罗内克积形式的矩阵 $I_n \\otimes A - B^\\top \\otimes I_n$ 的最小奇异值，其中 $\\otimes$ 表示克罗内克积。Bartels–Stewart 算法通过将 $A$ 和 $B$ 约化为舒尔形式，然后对三角西尔维斯特系统执行结构化回代来求解西尔维斯特方程。\n\n您的任务是实现一个自包含的程序，该程序对一小组参数值测试套件执行以下步骤，并报告每种情况下的量化指标。\n\n1. 对于 $n = 4$，通过正交对角化 $A = Q \\Lambda^{(A)} Q^\\top$ 构建一个具有指定特征值\n$$\n\\lambda^{(A)} = [-1.0, -0.25, 0.75, 2.0]\n$$\n的固定对称矩阵 $A$，其中 $Q$ 是正交矩阵，$\\Lambda^{(A)} = \\operatorname{diag}(\\lambda^{(A)})$。对 $Q$ 使用确定性构造，以确保结果可复现。\n\n2. 对于给定测试套件中的每个邻近参数 $\\delta  0$，构建一个共享相同正交基的相应对称矩阵 $B$，其特征值为\n$$\n\\lambda^{(B)}(\\delta) = \\lambda^{(A)} + \\delta \\cdot \\mathbf{1},\n$$\n即 $B(\\delta) = Q \\Lambda^{(B)}(\\delta) Q^\\top$，其中 $\\Lambda^{(B)}(\\delta) = \\operatorname{diag}(\\lambda^{(B)}(\\delta))$，$\\mathbf{1}$ 是 $\\mathbb{R}^4$ 中的全一向量。这通过一个统一的平移 $\\delta$ 来控制谱的邻近度，确保 $\\min_{i,j} |\\lambda_i^{(A)} - \\lambda_j^{(B)}| = \\delta$。\n\n3. 对于一个固定的、确定性的 $X_\\star \\in \\mathbb{R}^{4 \\times 4}$，构造右侧项\n$$\nC(\\delta) = A X_\\star - X_\\star B(\\delta),\n$$\n使得 $X_\\star$ 是 $A X - X B(\\delta) = C(\\delta)$ 的精确解。\n\n4. 对于每个 $\\delta$，使用 Bartels–Stewart 算法（将两个矩阵约化为舒尔形式，求解三角系统，然后变换回来）数值求解西尔维斯特方程。您可以调用一个内部实现 Bartels–Stewart 算法的可信科学计算例程。\n\n5. 对于每个 $\\delta$，计算以下指标：\n   - 分离度\n     $$\n     \\operatorname{sep}(A,B(\\delta)) = \\sigma_{\\min}\\big(I_4 \\otimes A - B(\\delta)^\\top \\otimes I_4\\big),\n     $$\n     其中 $\\sigma_{\\min}$ 表示最小奇异值。\n   - 相对前向误差\n     $$\n     \\frac{\\|X_{\\text{num}}(\\delta) - X_\\star\\|_F}{\\|X_\\star\\|_F}.\n     $$\n   - 缩放残差（一种相对后向误差的代理）\n     $$\n     \\frac{\\|A X_{\\text{num}}(\\delta) - X_{\\text{num}}(\\delta) B(\\delta) - C(\\delta)\\|_F}{\\|A\\|_2 \\|X_{\\text{num}}(\\delta)\\|_F + \\|B(\\delta)\\|_2 \\|X_{\\text{num}}(\\delta)\\|_F + \\|C(\\delta)\\|_F}.\n     $$\n\n6. 使用以下邻近参数测试套件来探究随分离度减小的缩放情况：\n$$\n\\delta \\in \\{10^{-1},\\ 10^{-3},\\ 10^{-6},\\ 10^{-8}\\}.\n$$\n\n7. 您的程序必须是完全确定性的：正交矩阵 $Q$ 和精确解 $X_\\star$ 必须使用固定的种子或固定的公式构造。不允许任何外部输入。\n\n8. 最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果。对于指定顺序中的每个 $\\delta$，将三元组\n$$\n\\big[\\operatorname{sep}(A,B(\\delta)),\\ \\text{相对前向误差},\\ \\text{缩放残差}\\big]\n$$\n以相同的顺序附加到输出列表中，并将列表展平。具体来说，如果四个测试用例的三元组是 $(s_k, f_k, r_k)$，其中 $k=1,2,3,4$，那么输出必须是\n$$\n[s_1, f_1, r_1, s_2, f_2, r_2, s_3, f_3, r_3, s_4, f_4, r_4].\n$$\n\n科学基础与约束：\n- 使用标准矩阵分析中定义的弗罗贝尼乌斯范数 $\\|\\cdot\\|_F$ 和谱范数 $\\|\\cdot\\|_2$。\n- 解的唯一性得到保证，因为对于每个 $\\delta  0$，$A$ 和 $B(\\delta)$ 的谱是不相交的。\n- 分离度是线性算子矩阵 $I_4 \\otimes A - B(\\delta)^\\top \\otimes I_4$ 的最小奇异值，它量化了算子求逆 $\\mathcal{L}^{-1}$ 在弗罗贝尼乌斯范数下的条件数。\n- Bartels–Stewart 算法是通过舒尔分解后跟三角求解来解决西尔维斯特方程的标准、经过充分测试的方法。\n\n您的程序必须遵守指定的执行环境，并且不得需要任何输入。最终输出必须严格遵循上述单行、方括号、逗号分隔的格式。此任务不涉及物理单位或角度，因此不需要单位转换。输出为浮点数。",
            "solution": "该数值实验的目的是分析 Bartels-Stewart 算法在谱分离度减小的情况下求解西尔维斯特方程 $A X - X B = C$ 的性能。当 $A$ 和 $B$ 的谱变得更接近时，解 $X$ 的稳定性和准确性预计会下降，这对应于线性算子 $\\mathcal{L}(X) = AX - XB$ 变得越来越病态。我们将通过构建一系列具有受控谱邻近度的问题，并测量数值计算解的前向误差和残差来量化这种关系。\n\n实验结构如下：\n\n首先，我们为所涉及的矩阵建立一个确定性且可复现的基础。维度设置为 $n=4$。\n一个固定的对称矩阵 $A \\in \\mathbb{R}^{4 \\times 4}$ 被构造出来，其具有指定的特征值 $\\lambda^{(A)} = [-1.0, -0.25, 0.75, 2.0]$。构造遵循谱定理，$A = Q \\Lambda^{(A)} Q^\\top$，其中 $\\Lambda^{(A)} = \\operatorname{diag}(\\lambda^{(A)})$。为确保可复现性，正交矩阵 $Q \\in \\mathbb{R}^{4 \\times 4}$ 通过对一个固定的 $4 \\times 4$ 范德蒙德矩阵应用 QR 分解来确定性地生成。\n精确解，表示为 $X_\\star \\in \\mathbb{R}^{4 \\times 4}$，也使用一个带有固定种子的伪随机数生成器来确定性地生成。\n\n其次，对于测试套件 $\\{10^{-1}, 10^{-3}, 10^{-6}, 10^{-8}\\}$ 中的每个邻近参数 $\\delta$，我们构造一个相应的对称矩阵 $B(\\delta)$。该矩阵被设计为具有 $A$ 的特征值的均匀平移：$\\lambda^{(B)}(\\delta) = \\lambda^{(A)} + \\delta \\cdot \\mathbf{1}$，其中 $\\mathbf{1}$ 是全一向量。然后矩阵 $B(\\delta)$ 由 $B(\\delta) = Q \\Lambda^{(B)}(\\delta) Q^\\top$ 给出，其中 $\\Lambda^{(B)}(\\delta) = \\operatorname{diag}(\\lambda^{(B)}(\\delta))$。这种构造确保了 $A$ 和 $B(\\delta)$ 共享相同的特征向量（即 $Q$ 的列），并且它们特征值之间的最小距离恰好是 $\\delta$。\n\n第三，对于每对 $(A, B(\\delta))$，我们将右侧矩阵 $C(\\delta)$ 定义为 $C(\\delta) = A X_\\star - X_\\star B(\\delta)$。这个定义保证了预先定义的矩阵 $X_\\star$ 是西尔维斯特方程 $A X - X B(\\delta) = C(\\delta)$ 的精确解析解。\n\n第四，我们使用一个可信的库函数 `scipy.linalg.solve_sylvester` 来数值求解这个方程以得到 $X$，该函数实现了 Bartels-Stewart 算法。该算法首先计算 $A$ 和 $-B$ 的实舒尔分解，将方程转换为准三角形式，使用替换过程求解这个结构化系统，最后将解变换回原始基。对于方程 $A X - X B = C$，我们求解等价形式 $A X + X(-B) = C$。计算出的解表示为 $X_{\\text{num}}(\\delta)$。\n\n第五，对于每个 $\\delta$，我们计算三个量化指标来评估问题的条件和解的质量：\n1. 分离度, $\\operatorname{sep}(A, B(\\delta)) = \\min_{\\|X\\|_F=1} \\|A X - X B(\\delta)\\|_F$。这个量是西尔维斯特方程条件数的基本度量。它被计算为表示线性算子 $\\mathcal{L}$ 的 $n^2 \\times n^2$ 矩阵（以克罗内克积形式表示：$K = I_4 \\otimes A - B(\\delta)^\\top \\otimes I_4$）的最小奇异值 $\\sigma_{\\min}$。对于这个特定问题，由于 $A$ 和 $B(\\delta)$ 是对称且可交换的，可以证明分离度恰好等于 $\\delta$。我们对 $\\sigma_{\\min}(K)$ 的数值计算可用于验证这一点。\n2. 相对前向误差，定义为 $\\frac{\\|X_{\\text{num}}(\\delta) - X_\\star\\|_F}{\\|X_\\star\\|_F}$，其中 $\\|\\cdot\\|_F$ 是弗罗贝尼乌斯范数。该指标衡量计算解相对于已知精确解的准确性。根据扰动理论，前向误差预计大致与分离度的倒数 $1/\\operatorname{sep}(A,B(\\delta))$ 成正比。因此，我们预期当 $\\delta$ 减小时，这个误差会增长。\n3. 缩放残差，由 $\\frac{\\|A X_{\\text{num}}(\\delta) - X_{\\text{num}}(\\delta) B(\\delta) - C(\\delta)\\|_F}{\\|A\\|_2 \\|X_{\\text{num}}(\\delta)\\|_F + \\|B(\\delta)\\|_2 \\|X_{\\text{num}}(\\delta)\\|_F + \\|C(\\delta)\\|_F}$ 给出。这是一种相对后向误差的形式。它衡量计算解 $X_{\\text{num}}(\\delta)$ 满足原始方程的程度，并由所涉及矩阵的范数进行缩放。Bartels-Stewart 算法已知是后向稳定的，所以即使问题变得病态，这个值也预计会保持很小（在机器精度的量级上）。\n\n程序将对指定序列中的每个 $\\delta$ 执行这些步骤，并将计算出的指标三元组报告在一个展平的列表中。这使得可以直接观察到前向误差如何随着分离度的减小而变化，而后向误差则保持受控。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_sylvester, svdvals\n\ndef solve():\n    \"\"\"\n    Executes a numerical experiment to study the error scaling of a \n    Sylvester equation solver as spectral separation decreases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = {\n        \"n\": 4,\n        \"lambda_A\": np.array([-1.0, -0.25, 0.75, 2.0]),\n        \"delta_values\": [1e-1, 1e-3, 1e-6, 1e-8]\n    }\n\n    n = test_cases[\"n\"]\n    lambda_A_vals = test_cases[\"lambda_A\"]\n    delta_values = test_cases[\"delta_values\"]\n\n    # Step 1: Construct deterministic matrices Q and X_star\n    # To construct a deterministic orthogonal matrix Q, we perform QR decomposition\n    # on a fixed, well-conditioned matrix, such as a Vandermonde matrix.\n    v_pts = np.arange(1, n + 1)\n    V = np.vander(v_pts, increasing=True)\n    Q, _ = np.linalg.qr(V)\n\n    # To construct a deterministic exact solution X_star, we use a random\n    # number generator with a fixed seed.\n    rng = np.random.default_rng(seed=42)\n    X_star = rng.standard_normal((n, n))\n\n    # Construct the fixed matrix A from its spectral decomposition\n    Lambda_A = np.diag(lambda_A_vals)\n    A = Q @ Lambda_A @ Q.T\n    \n    # Ensure A is perfectly symmetric for numerical stability of subsequent ops\n    A = (A + A.T) / 2\n\n    # --- Main experiment loop ---\n    results = []\n    for delta in delta_values:\n        # Step 2: Construct B and C for the current delta\n        lambda_B_vals = lambda_A_vals + delta\n        Lambda_B = np.diag(lambda_B_vals)\n        B = Q @ Lambda_B @ Q.T\n        \n        # Ensure B is perfectly symmetric\n        B = (B + B.T) / 2\n\n        # Construct C such that X_star is the exact solution\n        C = A @ X_star - X_star @ B\n        \n        # Step 4: Solve the Sylvester equation numerically\n        # SciPy solves AX + XB = Q, so we solve AX + X(-B) = C\n        X_num = solve_sylvester(A, -B, C)\n        \n        # Step 5: Compute the metrics\n        \n        # Metric 1: Separation sep(A, B)\n        # This is the smallest singular value of I_n kron A - B.T kron I_n\n        I_n = np.identity(n)\n        K = np.kron(I_n, A) - np.kron(B.T, I_n)\n        svals = svdvals(K)\n        sep_AB = np.min(svals)\n        \n        # Metric 2: Relative forward error\n        norm_X_star_F = np.linalg.norm(X_star, 'fro')\n        forward_error = np.linalg.norm(X_num - X_star, 'fro') / norm_X_star_F\n        \n        # Metric 3: Scaled residual\n        # Residual R = A * X_num - X_num * B - C\n        R = A @ X_num - X_num @ B - C\n        norm_R_F = np.linalg.norm(R, 'fro')\n        \n        norm_A_2 = np.linalg.norm(A, 2)\n        norm_B_2 = np.linalg.norm(B, 2)\n        norm_X_num_F = np.linalg.norm(X_num, 'fro')\n        norm_C_F = np.linalg.norm(C, 'fro')\n        \n        # Denominator for scaling\n        denom = norm_A_2 * norm_X_num_F + norm_B_2 * norm_X_num_F + norm_C_F\n        \n        # Avoid division by zero, though highly unlikely here\n        if denom == 0:\n            scaled_residual = norm_R_F\n        else:\n            scaled_residual = norm_R_F / denom\n            \n        results.extend([sep_AB, forward_error, scaled_residual])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{x:.15e}' for x in results)}]\")\n\nsolve()\n```"
        }
    ]
}