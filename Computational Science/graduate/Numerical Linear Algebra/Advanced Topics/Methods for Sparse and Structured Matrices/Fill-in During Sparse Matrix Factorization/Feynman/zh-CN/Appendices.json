{
    "hands_on_practices": [
        {
            "introduction": "理论是抽象的，而一个简单的例子可以直观地揭示核心机制。这个练习  将带领你分析一个仅有四个节点的稀疏矩阵，它对应于图论中的一个 $4$-环图。通过手动模拟两种不同的消元顺序，你将亲眼见证填充（fill-in）是如何产生以及消元顺序如何直接决定填充项的位置，从而深刻理解排序在稀疏矩阵分解中的关键作用。",
            "id": "3545912",
            "problem": "考虑一个对称正定 (SPD) 矩阵 $A \\in \\mathbb{R}^{4 \\times 4}$，其稀疏模式对应于顶点集 $\\{1,2,3,4\\}$ 上的 4-圈图，即对所有 $i$，$a_{ii} \\neq 0$，且当且仅当 $\\{i,j\\} \\in \\{\\{1,2\\}, \\{2,3\\}, \\{3,4\\}, \\{4,1\\}\\}$ 时，$a_{ij} \\neq 0$，所有其他非对角线元素为零。假设此模式上的值为通用的非零值，从而没有意外的数值抵消影响结构性填充。我们在不进行主元选择的情况下执行 Cholesky 分解 $A = L L^{\\top}$，并纯粹在由顶点排序引发的消去图层面上分析填充。\n\n仅使用稀疏 Cholesky 分解的核心定义及其图论解释（即：在消去一个顶点的过程中，其所有尚未被消去的邻居在填充图中形成一个团；因子 $L$ 的非零模式对应于这个三角化图或弦化图的边），完成以下任务：\n\n- 对于两种排序 $\\pi_{1} = (1,2,3,4)$ 和 $\\pi_{2} = (2,3,4,1)$，精确地列出在每种排序下，除了 A 的原始稀疏性所隐含的位置之外，$L$ 的哪些严格下三角位置 $(i,j)$（其中 $i > j$）因填充而变为非零。\n- 使用弦化补全和完美消去排序的概念，解释为什么即使原始矩阵相同，两种填充模式的位置也可能不同。\n\n设 $f(\\pi)$ 表示使用排序 $\\pi$ 时，$L$ 中不在 $A$ 原始稀疏模式中的严格下三角填充项的总数。计算单个量 $|f(\\pi_{1}) - f(\\pi_{2})|$。请以精确整数形式提供最终答案，不带单位。无需四舍五入。",
            "solution": "该问题要求针对两种不同的排序，分析一个特定的稀疏对称正定 (SPD) 矩阵 $A \\in \\mathbb{R}^{4 \\times 4}$ 在 Cholesky 分解过程中的填充。分析将使用稀疏矩阵分解的图论模型进行。\n\n首先，我们定义图 $G=(V, E)$ 来表示矩阵 $A$ 的稀疏模式。顶点集为 $V = \\{1, 2, 3, 4\\}$。当且仅当条目 $a_{ij}$ 是指定的非对角非零元素时，边集 $E$ 包含一条边 $\\{i,j\\}$。根据问题描述，$a_{ij} \\neq 0$ 当且仅当 $\\{i,j\\} \\in \\{\\{1,2\\}, \\{2,3\\}, \\{3,4\\}, \\{4,1\\}\\}$。这个结构对应于一个长度为 4 的圈图，通常表示为 $C_4$。对角线元素 $a_{ii}$ 也是非零的，这在图表示中对于一个顶点是隐含的。\n\n$A$ 的严格下三角部分的非零元素对应于 $E$ 中的边。对于一条边 $\\{i,j\\}$，对应的矩阵位置是 $(\\max(i,j), \\min(i,j))$。因此，$A$ 的严格下三角部分的初始非零位置是 $(2,1)$、$(3,2)$、$(4,3)$ 和 $(4,1)$。\n\n填充项是在 Cholesky 因子 $L$ 中，在原始矩阵 $A$ 中为零的位置上新创建的非零元素。在图模型中，这对应于在消去过程中向图 $G$ 添加边。$L+L^{\\top}$ 的非零模式由最终的*填充图*（或*弦化图*）的边集给出，记作 $G^+$。\n\n对于一个排序 $\\pi$，消去过程逐个消去顶点。当一个顶点 $v$ 被消去时，它在当前图中所有尚未被消去的邻居被连接起来形成一个团。在此过程中添加的任何不在原始图 $G$ 中的边都代表一个填充。\n\n让我们分析给定的两种排序。\n\n**对排序 $\\pi_{1} = (1, 2, 3, 4)$ 的分析**\n\n我们从图 $G = (V, E)$ 开始，其中 $E = \\{\\{1,2\\}, \\{2,3\\}, \\{3,4\\}, \\{4,1\\}\\}$。我们将消去过程中生成的图序列表示为 $G_0, G_1, G_2, \\dots$，其中 $G_0=G$。\n\n1.  **消去顶点 $1$**：在 $G_0$ 中，顶点 1 的邻居是顶点 $\\{2,4\\}$。这些邻居在 $G_0$ 中没有边相连（即 $\\{2,4\\} \\notin E$）。为了形成一个团，我们必须添加边 $\\{2,4\\}$。这是一条填充边。新图为 $G_1 = (V, E \\cup \\{\\{2,4\\}\\})$。这个填充对应于 Cholesky 因子 $L$ 在位置 $(\\max(2,4), \\min(2,4)) = (4,2)$ 处的一个新的非零项。\n\n2.  **消去顶点 $2$**：现在我们考虑图 $G_1$。在 $G_1$ 中，顶点 2 的邻居是 $\\{1,3,4\\}$。未被消去的邻居（在 $\\pi_1$ 中出现在 2 之后的顶点）是 $\\{3,4\\}$。我们必须确保这些邻居形成一个团。边 $\\{3,4\\}$ 已经存在于原始图 $G_0$ 中（因此也存在于 $G_1$ 中）。因此，没有添加新的边。\n\n3.  **消去顶点 $3$**：我们考虑当前的图。顶点 3 的邻居是 $\\{2,4\\}$。唯一未被消去的邻居是顶点 4。只有一个顶点的集合平凡地构成一个团，所以没有添加新的边。\n\n4.  **消去顶点 $4$**：这是排序中的最后一个顶点，所以没有未被消去的邻居需要连接。没有填充发生。\n\n对于排序 $\\pi_1$，恰好发生一次填充。填充图为 $G_1^+ = (V, E \\cup \\{\\{2,4\\}\\})$。$L$ 中严格下三角非零元素对应的边集是 $\\{\\{1,2\\}, \\{2,3\\}, \\{3,4\\}, \\{4,1\\}, \\{2,4\\}\\}$。这些对应于位置 $(2,1), (3,2), (4,3), (4,1), (4,2)$。与原始非零元素相比，唯一的填充项在位置 $(4,2)$。\n因此，填充项的数量为 $f(\\pi_1) = 1$。\n\n**对排序 $\\pi_{2} = (2, 3, 4, 1)$ 的分析**\n\n我们再次从图 $G = (V, E)$ 开始。\n\n1.  **消去顶点 $2$**：在 $G_0$ 中，顶点 2 的邻居是 $\\{1,3\\}$。这些顶点没有边相连。为了形成一个团，我们添加边 $\\{1,3\\}$。这是一条填充边。新图为 $G_1 = (V, E \\cup \\{\\{1,3\\}\\})$。这个填充对应于 $L$ 在位置 $(\\max(1,3), \\min(1,3)) = (3,1)$ 处的一个新的非零项。\n\n2.  **消去顶点 $3$**：在当前图 $G_1$ 中，顶点 3 的邻居是 $\\{2,4,1\\}$。未被消去的邻居（在 $\\pi_2$ 中出现在 3 之后的顶点）是 $\\{4,1\\}$。我们必须检查 $\\{4,1\\}$ 是否是一条边。边 $\\{4,1\\}$ 在原始图 $G_0$ 中，所以没有添加新的边。\n\n3.  **消去顶点 $4$**：在当前图中，顶点 4 的邻居是 $\\{3,1\\}$，其中只有 $\\{1\\}$ 是未被消去的。不需要新的边。\n\n4.  **消去顶点 $1$**：这是最后一个顶点。没有填充发生。\n\n对于排序 $\\pi_2$，也恰好发生一次填充。填充图为 $G_2^+ = (V, E \\cup \\{\\{1,3\\}\\})$。填充项在位置 $(3,1)$。\n因此，填充项的数量为 $f(\\pi_2) = 1$。\n\n**关于填充模式差异的解释**\n\n填充模式之所以不同，是因为消去排序决定了原始图如何被三角化。如果一个图中每个长度为 4 或更长的圈都有一条*弦*（连接圈中两个不相邻顶点的边），那么这个图就是*弦*图（或*三角化*图）。稀疏 Cholesky 分解的过程隐式地计算了矩阵图的一个*弦化补全*，其中填充边就是添加的弦。\n\n初始图 $G$ 是一个 4-圈图，这是非弦图的最简单例子。因此，任何消去排序都会导致至少产生一条填充边来打破这个 4-圈。不产生任何填充的排序称为*完美消去排序* (PEO)，一个图拥有 PEO 当且仅当它是弦图。\n\n-   对于排序 $\\pi_1 = (1,2,3,4)$，消去过程添加了边 $\\{2,4\\}$。这条边作为圈 $1-2-3-4-1$ 的一条弦，将其分解为两个 3-圈（$1-2-4-1$ 和 $2-3-4-2$）。得到的填充图 $G_1^+$ 是弦图。填充的位置是 $(4,2)$。\n\n-   对于排序 $\\pi_2 = (2,3,4,1)$，该过程添加了边 $\\{1,3\\}$。这条边也作为同一个 4-圈的一条弦，但它将其分解为两个不同的 3-圈（$1-2-3-1$ 和 $1-3-4-1$）。得到的填充图 $G_2^+$ 也是弦图，但它与 $G_1^+$ 是不同的图。填充的位置是 $(3,1)$。\n\n这两种不同的排序导致了对原始图 $G$ 的两种不同的有效弦化补全。由于填充项正是与添加的弦相对应的矩阵位置，不同的弦化补全导致了不同的填充模式。尽管在这个特定的对称情况下，填充的总*数量*是相同的（都是 1），但它们的*位置*（$(4,2)$ vs. $(3,1)$）是不同的。\n\n**最终计算**\n\n问题要求计算 $|f(\\pi_1) - f(\\pi_2)|$ 的值。\n我们发现，对于排序 $\\pi_1$，严格下三角填充项的数量为 $f(\\pi_1) = 1$。\n对于排序 $\\pi_2$，严格下三角填充项的数量为 $f(\\pi_2) = 1$。\n因此，所求的量为：\n$$\n|f(\\pi_1) - f(\\pi_2)| = |1 - 1| = 0\n$$",
            "answer": "$$\\boxed{0}$$"
        },
        {
            "introduction": "既然排序至关重要，我们自然需要算法（启发式策略）来寻找一个好的消元顺序。这个练习  探讨了经典的最小度（Minimum Degree）启发式算法的一个“陷阱”案例。你将分析一个特殊构造的图，其中对两个度相同的节点进行消元会产生截然不同的填充量，这揭示了仅靠节点度数来预测填充是远远不够的，并启发我们思考更优的策略。",
            "id": "3545929",
            "problem": "考虑一个实对称正定矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 的不带数值主元选择的稀疏对称 Cholesky 分解，其中稀疏模式的演化由标准消去图模型控制：消去一个顶点 $v$ 会添加填充边，使其邻居集合 $N(v)$ 在当前图中成为一个团。\n\n构造以下由整数 $m \\geq 3$ 参数化的稀疏矩阵族。设顶点集划分为 $\\{x\\} \\cup \\{y\\} \\cup U \\cup V$，其中 $U = \\{u_1,\\dots,u_m\\}$ 且 $V = \\{v_1,\\dots,v_m\\}$。定义 $A$ 的结构模式（等价于初始图 $G$）如下：\n- $U$ 是一个独立集：对于所有 $1 \\leq i  j \\leq m$，$A_{u_i u_j} = 0$。\n- $V$ 是一个团：对于所有 $1 \\leq i  j \\leq m$，$A_{v_i v_j} \\neq 0$。\n- $x$ 仅与 $U$ 邻接：对于所有 $1 \\leq i \\leq m$，$A_{x u_i} \\neq 0$ 且 $A_{x y} = 0$，对于所有 $1 \\leq j \\leq m$，$A_{x v_j} = 0$。\n- $y$ 仅与 $V$ 邻接：对于所有 $1 \\leq j \\leq m$，$A_{y v_j} \\neq 0$ 且 $A_{x y} = 0$，对于所有 $1 \\leq i \\leq m$，$A_{y u_i} = 0$。\n- 对角线元素 $A_{ii} > 0$ 被选择得足够大以使 $A$ 对称正定；在这 $2m+2$ 个顶点中没有其他非对角非零元。\n\n假设使用最小度启发式算法来选择消去主元，并且在具有相同当前度数的顶点之间任意打破平局。在初始图 $G$ 中，注意 $\\deg(x) = m$ 和 $\\deg(y) = m$，而 $\\deg(u_i) = 1$ 和 $\\deg(v_j) = m$。为了分离出该启发式算法在必须于 $x$ 和 $y$ 之间做出选择时的行为，我们将注意力限制在 $\\{x\\} \\cup \\{y\\} \\cup U \\cup V$ 上的导出子图，在消去的某个阶段，先前被消去的顶点已经移除了任何度数更低的干扰项，因此 $x$ 和 $y$ 都是当前的最小度候选者。只使用基本规则，即消去一个顶点 $v$ 会精确地添加 $N(v)$ 中缺失的边，从而使 $N(v)$ 成为一个团。\n\n关于此构造中的填充行为以及最小度启发式算法潜在失败的结构性原因，以下哪些陈述是正确的？\n\nA. 如果启发式算法在 $y$ 之前选择 $x$，那么在第一个消去步骤中，它会在 $U$ 的顶点之间引入恰好 $\\binom{m}{2}$ 条新的填充边。\n\nB. 如果启发式算法在 $x$ 之前选择 $y$，那么在第一个消去步骤中，它会在 $V$ 的顶点之间引入恰好 $\\binom{m}{2}$ 条新的填充边。\n\nC. 在 $\\{x\\} \\cup \\{y\\} \\cup U \\cup V$ 上存在一个消去顺序，该顺序在此导出子图中产生零条新的填充边。\n\nD. 最小度启发式算法在此处可能表现不佳的结构性原因是，$x$ 和 $y$ 具有相同的度 $m$，但其邻居集合上的导出子图的密度截然不同：$N(x) = U$ 是一个独立集，而 $N(y) = V$ 是一个团，因此仅凭度数无法预测消去 $x$ 与消去 $y$ 所产生的即将到来的填充。",
            "solution": "对问题陈述进行验证。\n\n### 第1步：提取已知条件\n- **背景**：实对称正定矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 的稀疏对称 Cholesky 分解。\n- **方法**：不带数值主元选择的消去图模型。\n- **填充规则**：消去一个顶点 $v$ 会通过添加必要的填充边，使其邻居集合 $N(v)$ 成为一个团。\n- **图构造**：在一个划分为 $\\{x\\} \\cup \\{y\\} \\cup U \\cup V$ 的顶点集上构造一个图 $G$。\n- **参数**：$m$ 是一个整数，满足 $m \\geq 3$。\n- **顶点集**：$U = \\{u_1, u_2, \\dots, u_m\\}$ 和 $V = \\{v_1, v_2, \\dots, v_m\\}$。指定子图中的总顶点数为 $2m+2$。\n- **邻接结构**：\n    1.  $U$ 是一个独立集：对于任意 $1 \\leq i  j \\leq m$，边 $(u_i, u_j)$ 不存在。\n    2.  $V$ 是一个团：对于任意 $1 \\leq i  j \\leq m$，边 $(v_i, v_j)$ 存在。\n    3.  $x$ 仅与 $U$ 邻接：对于所有 $i=1,\\dots,m$，边 $(x, u_i)$ 存在。没有边 $(x,y)$、$(x,v_j)$。\n    4.  $y$ 仅与 $V$ 邻接：对于所有 $j=1,\\dots,m$，边 $(y, v_j)$ 存在。没有边 $(y,x)$、$(y,u_i)$。\n- **主元选择启发式算法**：使用最小度启发式算法。平局任意打破。\n- **情景**：问题要求在假设 $x$ 和 $y$ 是当前最小度候选者的情况下，分析该启发式算法的行为，以比较选择其中一个而不是另一个的后果。分析应基于初始图结构。\n\n### 第2步：使用提取的已知条件进行验证\n1.  **科学基础**：该问题在稀疏矩阵分解和图算法的既定理论中有充分的依据。消去图模型、最小度启发式算法以及填充、团和独立集等概念在数值线性代数和计算机科学中都是标准内容。\n2.  **适定性**：图结构定义明确。消去规则是标准的。问题要求分析特定选择的后果，这可以通过直接应用所述规则来确定。\n3.  **客观性**：问题以精确、客观的数学语言陈述。\n4.  **一致性**：让我们验证在顶点集 $S = \\{x, y\\} \\cup U \\cup V$ 上定义的图 $G$ 中的初始度数。\n    - 对于任何 $u_i \\in U$，其唯一的邻居是 $x$。所以 $\\deg(u_i) = 1$。\n    - 对于任何 $v_j \\in V$，其邻居是 $y$ 和 $V$ 中的其他 $m-1$ 个顶点。所以 $\\deg(v_j) = 1 + (m-1) = m$。\n    - 对于 $x$，其邻居是 $U$ 中的 $m$ 个顶点。所以 $\\deg(x) = m$。\n    - 对于 $y$，其邻居是 $V$ 中的 $m$ 个顶点。所以 $\\deg(y) = m$。\n    问题陈述提出了一个 $x$ 和 $y$ 是最小度候选者的情景。在初始图中，最小度为 $1$（由所有 $u_i$ 持有），而 $\\deg(x)=\\deg(y)=m$。问题的措辞“在消去的某个阶段，先前被消去的顶点已经移除了任何度数更低的干扰项”是一种教学手段，用以证明直接比较从初始图中消去 $x$ 和 $y$ 的合理性，即使它们不是初始的最小度节点。这种设置不是矛盾，而是一种将问题集中在关键概念点上的方式。因此，就其目的而言，该问题被认为是自洽的。\n\n### 第3步：结论与行动\n问题是有效的。它提出了一个关于最小度启发式算法行为的标准、有启发性的例子。我将继续进行解答。\n\n### 推导与选项分析\n\n设 $G_0$ 为所述的初始图。消去一个顶点 $v$ 所产生的填充边数是 $v$ 的不相邻邻居对的数量。如果邻居集合是 $N(v)$，其大小为 $k = \\deg(v)$，则顶点对的数量为 $\\binom{k}{2}$。如果 $N(v)$ 上的导出子图有 $e_{N(v)}$ 条边，则填充边的数量为 $\\binom{k}{2} - e_{N(v)}$。\n\n**选项A分析：**\n此选项考虑启发式算法从初始图中选择 $x$ 进行消去的情况。\n- 要被消去的顶点是 $x$。\n- 其邻居集合是 $N(x) = U = \\{u_1, \\dots, u_m\\}$。\n- $x$ 的度是 $\\deg(x) = |U| = m$。\n- 根据定义，$U$ 是一个独立集。这意味着在 $U$ 上的导出子图中的边数是 $e_{N(x)} = 0$。\n- 为了使 $N(x)$ 成为一个团，我们必须在 $U$ 中的每对顶点之间添加一条边。大小为 $m$ 的团中的边数是 $\\binom{m}{2}$。\n- 产生的填充边数是 $\\binom{m}{2} - e_{N(x)} = \\binom{m}{2} - 0 = \\binom{m}{2}$。\n- 该陈述声称消去 $x$ 会引入恰好 $\\binom{m}{2}$ 条新的填充边。这与我们的计算相符。\n\n因此，选项A是**正确的**。\n\n**选项B分析：**\n此选项考虑启发式算法从初始图中选择 $y$ 进行消去的情况。\n- 要被消去的顶点是 $y$。\n- 其邻居集合是 $N(y) = V = \\{v_1, \\dots, v_m\\}$。\n- $y$ 的度是 $\\deg(y) = |V| = m$。\n- 根据定义，$V$ 是一个团。这意味着在 $V$ 上的导出子图中的边数已经是最大的：$e_{N(y)} = \\binom{m}{2}$。\n- 邻居集合 $N(y)$ 已经是一个团，所以不需要新的边。\n- 产生的填充边数是 $\\binom{m}{2} - e_{N(y)} = \\binom{m}{2} - \\binom{m}{2} = 0$。\n- 该陈述声称消去 $y$ 会引入恰好 $\\binom{m}{2}$ 条新的填充边。我们的计算显示填充边为 0 条。因为 $m \\geq 3$，$\\binom{m}{2} = \\frac{m(m-1)}{2} \\geq 3$，这不等于 $0$。\n\n因此，选项B是**不正确的**。\n\n**选项C分析：**\n此选项询问对于给定子图中的顶点是否存在一个零填充消去顺序。如果每一步中，被消去顶点的邻居已经形成一个团，则该顺序产生零填充。这被称为完美消去顺序。\n让我们尝试构造这样一个顺序：\n1.  消去 $U = \\{u_1, \\dots, u_m\\}$ 中的顶点。对于任何 $u_i \\in U$，其邻居集合是 $N(u_i) = \\{x\\}$。只有一个顶点的集合平凡地是一个团。消去任何 $u_i$ 产生 0 填充。对所有 $u_i$ 重复此操作后，顶点 $x$ 没有邻居，即变为孤立的。\n2.  消去顶点 $x$。在 $U$ 中所有顶点被消去后，$N(x)$ 是空集。空集平凡地是一个团，所以消去 $x$ 产生 0 填充。\n3.  剩下的顶点是 $\\{y\\} \\cup V$。这些顶点上的图结构不变：$y$ 连接到 $V$ 的所有顶点，且 $V$ 是一个团。\n4.  消去顶点 $y$。其邻居集合是 $N(y) = V$。根据构造，$V$ 是一个团。因此，消去 $y$ 产生 0 填充。\n5.  剩下的顶点构成团 $V$。从一个团中消去任何顶点 $v$ 会留下一个更小的团。在剩余图中，$v$ 的邻居也形成一个团，因此不产生填充。例如，如果我们消去 $v_1$，其邻居 $\\{v_2, \\dots, v_m\\}$ 形成一个团。这个过程一直持续到所有顶点都被消去。\n\n一个零填充顺序的例子是 $(u_1, u_2, \\dots, u_m, x, y, v_1, v_2, \\dots, v_m)$。由于存在这样的顺序，该陈述为真。\n\n因此，选项C是**正确的**。\n\n**选项D分析：**\n此选项为最小度启发式算法在这种情况下行为提供了解释。让我们分析其组成部分：\n- **“最小度启发式算法在此处可能表现不佳的结构性原因……”**：该启发式算法可能表现不佳，因为在允许任意打破平局的情况下，它可能会选择在 $y$ 之前消去 $x$。如A所示，消去 $x$ 会产生 $\\binom{m}{2}$ 的填充。如C所示，存在一个产生 0 填充的最优顺序。因此，该启发式算法可能导致次优结果。这部分是正确的。\n- **“……是 $x$ 和 $y$ 具有相同的度 $m$……”**：从我们的初步分析可知，$\\deg(x) = m$ 和 $\\deg(y) = m$。这是正确的。因为度数相同，最小度启发式算法无法区分它们。\n- **“……但其邻居集合上的导出子图的密度截然不同……”**：$x$ 的邻居集合是 $N(x)=U$。$U$ 上的导出子图是一个独立集（有 0 条边）。$y$ 的邻居集合是 $N(y)=V$。$V$ 上的导出子图是一个团（有 $\\binom{m}{2}$ 条边）。$G[U]$ 的边密度为 0，$G[V]$ 的边密度为 1。这是一个巨大的差异。这部分是正确的。\n- **“……因此仅凭度数无法预测消去 $x$ 与消去 $y$ 所产生的即将到来的填充。”**：填充量取决于邻域的成团度，而不仅仅是其大小（度数）。由于 $\\deg(x)=\\deg(y)$，但填充量分别为 $\\binom{m}{2}$ 和 0，因此在这种情况下，度数是填充的一个不良预测指标。这个陈述正确地指出了这个例子旨在展示的启发式算法的局限性。\n\nD中的整个陈述是对问题的正确而深刻的分析。\n\n因此，选项D是**正确的**。",
            "answer": "$$\\boxed{ACD}$$"
        },
        {
            "introduction": "检验是否真正理解一个算法的最好方法，就是亲手实现它。这个编程挑战  将指导你从第一性原理出发，实现稀疏矩阵分解中的顶点消元过程。你将分别为自然顺序和近似最小度（Approximate Minimum Degree, AMD）启发式算法计算填充量，并将其应用于包含长无弦环和“中心节点”等不同拓扑特征的图上，直观地感受不同排序策略对填充控制的巨大影响。",
            "id": "3545869",
            "problem": "设 $A \\in \\mathbb{R}^{n \\times n}$ 是一个稀疏对称矩阵，其非零模式（忽略对角线元素）编码了一个定义在顶点集 $\\{0,1,\\dots,n-1\\}$ 上的无向图 $G(A)$，其中当且仅当 $a_{ij} \\neq 0$ 且 $i \\neq j$ 时，边 $\\{i,j\\}$ 存在。考虑由具有与 $A$ 相同稀疏模式（本问题中仅使用模式，而非数值）的对称正定(SPD)矩阵进行 Cholesky 分解所引发的 $G(A)$ 中顶点的消去过程，其中消去一个顶点会添加边，使其邻域成为一个团，从而沿着所选的消去顺序生成 $G(A)$ 的弦补全。在弦补全中，无弦环（长度至少为 $4$ 且环上非连续顶点之间没有边连接的环）必须通过添加弦来进行三角化。\n\n近似最小度(AMD)排序是一种启发式重排序策略，它通过在演化的填充图中反复消去当前度最小的顶点来逼近最小度排序。针对本问题，将近似最小度(AMD)排序精确定义如下：给定顶点集 $V$ 上的一个无向图 $G$，迭代地选择一个当前度最小的顶点 $v \\in V$（平局时选择顶点索引最小的），添加边使其邻域成为一个团，从图中移除 $v$，并继续此过程直到所有顶点都被消去。在此过程中添加的新边的总数即为该排序引入的填充。\n\n从以下基本原理出发：(i) 稀疏 Cholesky 分解的消去图模型，其中消去一个顶点会添加边以将其邻域补全为一个团；以及 (ii) 弦图的特征，即不存在长度至少为 $4$ 的无弦环的图。从第一性原理出发，推导并实现一个算法，该算法在给定对称稀疏模式的情况下，计算由 (a) 上述定义的 AMD 排序和 (b) 自然排序 $0,1,2,\\dots,n-1$ 所引入的填充。同时，对于作为无弦环的子图，计算将其三角化所需的理论最少弦数。对于一个有 $m$ 个顶点的无弦环，将其三角化所需添加的最小弦数为 $m-3$。\n\n通过指定它们的图 $G(A)$ 来构建以下稀疏矩阵 $A$ 的测试套件：\n\n- 测试用例 1 (一个“理想情况”的长环)：$G(A)$ 是一个在顶点 $\\{0,1,\\dots,7\\}$ 上的单一无弦环 $C_{8}$，其边为 $\\{(i,(i+1)\\bmod 8): i=0,1,\\dots,7\\}$。\n- 测试用例 2 (一个连接到高度数中心的长环，若提早消去该中心可能导致填充爆炸)：$G(A)$ 是一个在顶点 $\\{1,2,\\dots,20\\}$ 上的无弦环 $C_{20}$（其边为 $\\{(i,(i+1)\\bmod 20): i=1,2,\\dots,20\\}$，其中 $(20+1)\\bmod 20$ 被解释为 $1$）与一个中心顶点 $0$ 的并集，中心顶点通过边 $\\{(0,i): i=1,2,\\dots,20\\}$ 连接到所有环顶点。\n- 测试用例 3 (两个由一条桥连接且都连接到一个中心的长环)：$G(A)$ 是两个在顶点 $\\{1,2,\\dots,12\\}$ 和 $\\{13,14,\\dots,24\\}$ 上的无弦环 $C_{12}$ 的并集，第一个环的边为 $\\{(i,(i+1)): i=1,2,\\dots,11\\} \\cup \\{(12,1)\\}$，第二个环的边为 $\\{(j,(j+1)): j=13,14,\\dots,23\\} \\cup \\{(24,13)\\}$，以及连接两个环的桥边 $(1,13)$，还有一个通过边 $\\{(0,i): i=1,2,\\dots,24\\}$ 连接到所有环顶点的中心顶点 $0$。\n- 测试用例 4 (边界情况的最短环)：$G(A)$ 是一个在顶点 $\\{0,1,2,3\\}$ 上的无弦环 $C_{4}$，其边为 $\\{(0,1),(1,2),(2,3),(3,0)\\}$。\n\n对于每个测试用例：\n1. 计算在上述定义的 AMD 排序下引入的填充（添加的新边数）。\n2. 计算三角化存在的无弦环子图所需的理论最少弦数，等于对每个环长 $m$ 求和 $m-3$。\n3. 计算在自然排序 $0,1,2,\\dots,n-1$ 下的填充。\n\n你的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表形式的结果，顺序为\n$[\\text{AMD}_1,\\text{MIN}_1,\\text{NAT}_1,\\text{AMD}_2,\\text{MIN}_2,\\text{NAT}_2,\\text{AMD}_3,\\text{MIN}_3,\\text{NAT}_3,\\text{AMD}_4,\\text{MIN}_4,\\text{NAT}_4]$，\n其中 $\\text{AMD}_k$ 是测试用例 $k$ 的 AMD 填充，$\\text{MIN}_k$ 是测试用例 $k$ 中环子图的理论最少弦数，$\\text{NAT}_k$ 是测试用例 $k$ 的自然排序填充。所有输出必须为整数。本问题不涉及物理单位或角度单位。\n\n通过从消去图模型推导所有量，并严格通过在每个消去步骤中对邻域进行团补全来计算填充，而不是依赖于所述基本原理之外的外部自分解程序或预计算公式，来确保科学真实性。算法必须处理顶点被消去和边被添加时图的演化。\n\n程序必须完全自包含，不需要任何输入。它必须实现图的构建、AMD 和自然排序消去模拟，并以上述指定的确切格式生成单行输出。",
            "solution": "这个问题的核心是模拟图上的顶点消去过程，该过程模拟了稀疏对称正定矩阵 Cholesky 分解过程中产生的填充。填充（Fill-in）指的是在 Cholesky 因子 $L$ 中出现在原始矩阵 $A$ 中为零的位置上的新非零项。\n\n**1. 消去图模型**\n该过程在矩阵的图 $G(A)$ 上建模。当一个顶点 $v$ 被消去时，它在图当前状态下的邻居 $N(v)$ 被构成一个团。这意味着对于每对不同的顶点 $i, j \\in N(v)$，如果边 $(i, j)$ 尚不存在，则将其添加到图中。这条新添加的边代表一个填充元素。在整个消去过程中添加的此类边的总数就是总填充量。一个顶点 $v$ 被消去后，它及其所有关联的边将从后续步骤的考虑中移除。\n\n**2. 排序策略与填充计算**\n总填充量高度依赖于顶点的消去顺序。我们将实现并分析两种排序。\n\n**a) 自然排序**\n顶点按其自然索引顺序被消去：$0, 1, 2, \\dots, n-1$。通过模拟此固定顺序的消去过程来计算填充。\n\n**b) 近似最小度(AMD)排序**\n这是一种贪心启发式算法。在每一步中，我们调查所有*剩余*（尚未消去）顶点在*当前*图（包括之前步骤产生的任何填充）中的度。选择度最小的顶点进行消去。问题规定，平局由选择索引最小的顶点来打破。这种动态选择过程旨在通过首先消去稀疏邻域的顶点来减少填充。\n\n**3. 最小弦式填充**\n弦图是指不包含长度为 $4$ 或更长的无弦环的图。Cholesky 分解的过程通过添加作为弦的填充边，隐式地将原始图转换为弦图。对于一个给定的长度为 $m$ 的无弦环，将其三角化所需的理论最小弦数为 $m - 3$。这可作为该特定子结构“最佳可能”填充的基准。\n\n我们现在将这些原理应用于每个测试用例。AMD 和自然排序的填充将通过算法计算，而环的最小弦数将使用 $m-3$ 公式计算。\n\n**测试用例 1: $\\{0, \\dots, 7\\}$ 上的 $C_8$**\n- **图**: 一个有 $n=8$ 个顶点的环。边为 $\\{(i, (i+1) \\pmod 8) \\mid i \\in \\{0, \\dots, 7\\}\\}$。\n- **最小弦数 ($\\text{MIN}_1$)**: 该图是一个长度为 $m=8$ 的单一无弦环。最小弦数为 $m - 3 = 8 - 3 = 5$。\n- **自然排序填充 ($\\text{NAT}_1$)**:\n    1.  消去 $0$：邻居是 $\\{1, 7\\}$。添加边 $(1, 7)$。填充 = $1$。\n    2.  消去 $1$：剩余邻居是 $\\{2, 7\\}$。添加边 $(2, 7)$。填充 = $2$。\n    3.  消去 $2$：剩余邻居是 $\\{3, 7\\}$。添加边 $(3, 7)$。填充 = $3$。\n    4.  消去 $3$：剩余邻居是 $\\{4, 7\\}$。添加边 $(4, 7)$。填充 = $4$。\n    5.  消去 $4$：剩余邻居是 $\\{5, 7\\}$。添加边 $(5, 7)$。填充 = $5$。\n    6.  消去 $5$：剩余邻居是 $\\{6, 7\\}$。边 $(6, 7)$ 是原始边。无填充。\n    7.  消去 $6$ 和 $7$：无更多填充。\n    总填充为 $5$。\n- **AMD 排序填充 ($\\text{AMD}_1$)**: 最初，所有顶点的度都是 $2$。AMD 选择顶点 $0$ (最小索引)。由于平局打破规则和图的对称性，该过程与自然排序相同。消去顺序为 $0, 1, \\dots, 7$，总填充为 $5$。\n- **结果 1**: $[\\text{AMD}_1, \\text{MIN}_1, \\text{NAT}_1] = [5, 5, 5]$。\n\n**测试用例 2: $\\{1, \\dots, 20\\}$ 上的 $C_{20}$ 及中心点 $0$**\n- **图**: $n=21$。顶点 $0$ 连接到 $\\{1, \\dots, 20\\}$ 中的所有顶点。顶点 $\\{1, \\dots, 20\\}$ 形成一个环。\n- **最小弦数 ($\\text{MIN}_2$)**: 该图包含一个长度为 $m=20$ 的无弦环。所需的最小弦数为 $20 - 3 = 17$。\n- **自然排序填充 ($\\text{NAT}_2$)**:\n    1.  消去 $0$：邻居是 $\\{1, \\dots, 20\\}$，一个包含 $20$ 个顶点的集合。要使该集合成为一个团，我们需要 $\\binom{20}{2} = 190$ 条边。环已经提供了 $20$ 条边。因此，添加的填充为 $190 - 20 = 170$。\n    2.  消去 $0$ 后，$\\{1, \\dots, 20\\}$ 上的剩余图是一个完全图（一个团）。任何进一步的消去都不会增加填充。\n    总填充为 $170$。\n- **AMD 排序填充 ($\\text{AMD}_2$)**:\n    - 初始度数: $\\text{deg}(0) = 20$。对于 $i \\in \\{1, \\dots, 20\\}$，$\\text{deg}(i) = 3$ (连接到 $0$, $i-1$, 和 $i+1$ )。\n    - AMD 策略将重复从环中选择一个顶点。根据平局打破规则，消去顺序将从 $1, 2, 3, \\dots$ 开始。\n    1.  消去 $1$：邻居是 $\\{0, 2, 20\\}$。添加边 $(2, 20)$。填充 = $1$。\n    2.  消去 $2$：在更新后的图中，其剩余邻居是 $\\{0, 3, 20\\}$。添加边 $(3, 20)$。填充 = $2$。\n    3.  此模式继续。在消去 $k \\in \\{1, \\dots, 18\\}$ 时，会连接其邻居。在每一步，这会引入一条新的填充边。这会增加 $18$ 条边。\n    4.  消去 $19$：其剩余邻居 $\\{0, 20\\}$ 已经连接。无填充。\n    5.  在消去 $\\{1, \\dots, 19\\}$ 后，剩余顶点 $\\{0, 20\\}$ 及其相互连接已形成一个团，不会产生更多填充。\n    总填充为 $18$。\n- **结果 2**: $[\\text{AMD}_2, \\text{MIN}_2, \\text{NAT}_2] = [18, 17, 170]$。\n\n**测试用例 3: 两个 $C_{12}$，带桥和中心点**\n- **图**: $n=25$。中心点 $0$ 连接到 $\\{1, \\dots, 24\\}$。$C_{12}$ 在 $\\{1, \\dots, 12\\}$ 上。$C_{12}$ 在 $\\{13, \\dots, 24\\}$ 上。桥 $(1, 13)$。\n- **最小弦数 ($\\text{MIN}_3$)**: 两个长度为 $m=12$ 的无弦环。总最小弦数: $(12 - 3) + (12 - 3) = 9 + 9 = 18$。\n- **自然排序填充 ($\\text{NAT}_3$)**:\n    1.  消去 $0$：邻居是 $\\{1, \\dots, 24\\}$。顶点对的数量为 $\\binom{24}{2} = 276$。已存在的边有 $12$ (环 A) + $12$ (环 B) + $1$ (桥) = $25$ 条。填充为 $276 - 25 = 251$。\n    2.  不会产生更多填充。\n    总填充为 $251$。\n- **AMD 排序填充 ($\\text{AMD}_3$)**:\n    - 初始度数: $\\text{deg}(0)=24$。$\\text{deg}(1)=\\text{deg}(13)=4$。所有其他环顶点的度为 $3$。\n    - AMD 将首先消去度为 $3$ 的顶点，从 $2, 3, \\dots, 12$ 和 $14, 15, \\dots, 24$ 开始。\n    1.  消去环 A 的度为 3 的节点: $\\{2, \\dots, 12\\}$。根据平局打破规则，顺序为 $2, 3, \\dots$。消去 $k \\in \\{2..11\\}$ 使其邻居 $\\{0, k-1, k+1\\}$ 成为一个团。这会系统地将顶点连接到顶点 $1$。消去 $k=2$ 添加边 $(0,3)$ 和 $(1,3)$ 等。更仔细的追踪显示，为使第一个环成为弦图，会产生 9 个填充。\n    2.  消去环 B 的度为 3 的节点: 对称地，这会产生 9 个填充。\n    总填充为 $9 + 9 = 18$。\n- **结果 3**: $[\\text{AMD}_3, \\text{MIN}_3, \\text{NAT}_3] = [18, 18, 251]$。\n\n**测试用例 4: $\\{0,1,2,3\\}$ 上的 $C_4$**\n- **图**: 一个有 $n=4$ 个顶点的环。边为 $(0,1), (1,2), (2,3), (3,0)$。\n- **最小弦数 ($\\text{MIN}_4$)**: 一个长度为 $m=4$ 的无弦环。最小弦数: $4 - 3 = 1$。\n- **自然排序填充 ($\\text{NAT}_4$)**:\n    1.  消去 $0$：邻居是 $\\{1, 3\\}$。添加边 $(1, 3)$。填充 = $1$。\n    2.  消去 $1$：剩余邻居是 $\\{2, 3\\}$。边 $(2,3)$ 是原始边。无填充。\n    3.  消去 $2, 3$ 不会产生更多填充。\n    总填充为 $1$。\n- **AMD 排序填充 ($\\text{AMD}_4$)**: 所有顶点的度都是 $2$。AMD 选择 $0$，与自然排序相同。填充为 $1$。\n- **结果 4**: $[\\text{AMD}_4, \\text{MIN}_4, \\text{NAT}_4] = [1, 1, 1]$。\n\n**最终结果摘要**\n计算出的值的最终列表是：\n$[5, 5, 5, 18, 17, 170, 18, 18, 251, 1, 1, 1]$",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport itertools\n\ndef build_graph_case_1():\n    \"\"\"Builds adjacency matrix for test case 1: C8.\"\"\"\n    n = 8\n    adj = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        j = (i + 1) % n\n        adj[i, j] = 1\n        adj[j, i] = 1\n    min_chords = 8 - 3\n    return n, adj, min_chords\n\ndef build_graph_case_2():\n    \"\"\"Builds adjacency matrix for test case 2: C20 + Hub.\"\"\"\n    n = 21\n    adj = np.zeros((n, n), dtype=int)\n    hub = 0\n    # Cycle on vertices 1 to 20\n    for i in range(1, 21):\n        # (20 % 20) + 1 = 1, so (20,1) is the last edge\n        j = (i % 20) + 1 \n        adj[i, j] = 1\n        adj[j, i] = 1\n    # Hub connections\n    for i in range(1, 21):\n        adj[hub, i] = 1\n        adj[i, hub] = 1\n    min_chords = 20 - 3\n    return n, adj, min_chords\n\ndef build_graph_case_3():\n    \"\"\"Builds adjacency matrix for test case 3: two C12s, bridge, hub.\"\"\"\n    n = 25\n    adj = np.zeros((n, n), dtype=int)\n    hub = 0\n    # First cycle C12 on {1..12}\n    for i in range(1, 12):\n        adj[i, i + 1] = 1\n        adj[i + 1, i] = 1\n    adj[12, 1] = 1\n    adj[1, 12] = 1\n    # Second cycle C12 on {13..24}\n    for i in range(13, 24):\n        adj[i, i + 1] = 1\n        adj[i + 1, i] = 1\n    adj[24, 13] = 1\n    adj[13, 24] = 1\n    # Bridge\n    adj[1, 13] = 1\n    adj[13, 1] = 1\n    # Hub connections\n    for i in range(1, 25):\n        adj[hub, i] = 1\n        adj[i, hub] = 1\n    min_chords = (12 - 3) + (12 - 3)\n    return n, adj, min_chords\n\ndef build_graph_case_4():\n    \"\"\"Builds adjacency matrix for test case 4: C4.\"\"\"\n    n = 4\n    adj = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        j = (i + 1) % n\n        adj[i, j] = 1\n        adj[j, i] = 1\n    min_chords = 4 - 3\n    return n, adj, min_chords\n\ndef compute_natural_fill(n, adj_orig):\n    \"\"\"Computes fill for the natural ordering 0, 1, ..., n-1.\"\"\"\n    working_adj = adj_orig.copy()\n    fill_count = 0\n    eliminated = [False] * n\n\n    for v in range(n):\n        # Identify neighbors of v that have not been eliminated yet\n        neighbors = [j for j in range(n) if not eliminated[j] and j != v and working_adj[v, j]]\n        \n        # Add clique edges (fill-in) between pairs of neighbors\n        for i, j in itertools.combinations(neighbors, 2):\n            if not working_adj[i, j]:\n                working_adj[i, j] = 1\n                working_adj[j, i] = 1\n                fill_count += 1\n        \n        eliminated[v] = True\n        \n    return fill_count\n\ndef compute_amd_fill(n, adj_orig):\n    \"\"\"Computes fill for the Approximate Minimum Degree ordering.\"\"\"\n    working_adj = adj_orig.copy()\n    fill_count = 0\n    remaining_vertices = list(range(n))\n\n    while remaining_vertices:\n        # Calculate degrees for all remaining vertices in the current graph\n        degrees = {v: sum(1 for neighbor in remaining_vertices if working_adj[v, neighbor]) for v in remaining_vertices}\n        \n        # Find the vertex with the minimum degree, breaking ties with smallest index\n        v_to_elim = min(remaining_vertices, key=lambda v: (degrees[v], v))\n     \n        # Identify neighbors of the chosen vertex within the remaining graph\n        neighbors = [j for j in remaining_vertices if j != v_to_elim and working_adj[v_to_elim, j]]\n        \n        # Add clique edges (fill-in)\n        for i, j in itertools.combinations(neighbors, 2):\n            if not working_adj[i, j]:\n                working_adj[i, j] = 1\n                working_adj[j, i] = 1\n                fill_count += 1\n                \n        # Remove the vertex from the graph for subsequent steps\n        remaining_vertices.remove(v_to_elim)\n        \n    return fill_count\n\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and produce the final output.\n    \"\"\"\n    test_builders = [\n        build_graph_case_1,\n        build_graph_case_2,\n        build_graph_case_3,\n        build_graph_case_4,\n    ]\n\n    results = []\n    for builder in test_builders:\n        n, adj, min_chords = builder()\n        \n        # Compute fill for AMD ordering\n        amd_fill = compute_amd_fill(n, adj)\n        \n        # Compute fill for Natural ordering\n        natural_fill = compute_natural_fill(n, adj)\n        \n        # Store results in the required order\n        results.append(amd_fill)\n        results.append(min_chords)\n        results.append(natural_fill)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}