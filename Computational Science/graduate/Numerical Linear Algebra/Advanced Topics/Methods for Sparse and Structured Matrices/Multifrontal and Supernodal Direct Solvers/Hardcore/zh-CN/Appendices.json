{
    "hands_on_practices": [
        {
            "introduction": "本章的第一个练习将我们对稀疏分解的理解建立在其基础的图论模型之上。通过在一个小而结构化的矩阵上手动追踪消元过程，我们将精确地看到“填充”（即新非零元的产生）是如何发生的，以及它如何决定最终Cholesky因子的结构。这项练习对于形象化理解多阵面方法旨在管理的核心机制至关重要。",
            "id": "3560922",
            "problem": "考虑一个实对称正定 (SPD) 矩阵 $A \\in \\mathbb{R}^{6 \\times 6}$，其稀疏图 $G(A)$ 是一个采用自然行主序的 $2 \\times 3$ 矩形网格。也就是说，顶点集为 $\\{1,2,3,4,5,6\\}$，无向边集为\n$$\nE \\;=\\; \\{(1,2),(2,3),(4,5),(5,6),(1,4),(2,5),(3,6)\\}.\n$$\n假设非零值是与 $G(A)$ 一致的通用值，因此没有数值抵消导致结构性零值。执行一次不进行主元选择且不进行重排序的 Cholesky 分解（即消去顺序为 $1,2,3,4,5,6$）。使用稀疏 Cholesky 分解的图模型和消去树，从基本原理出发，推导 Cholesky 因子 $L$（对角线为正的下三角矩阵）的非零模式，并预测所有由消去过程产生的填充边。然后，通过多波前视角验证预测的模式：在消去每个顶点 $j$ 时，其当前具有更大索引的邻居形成一个团，这是波前矩阵的变量部分，并且这种饱和过程会相应地产生填充。\n\n您的任务是：\n- 仅使用核心定义，推导出消去树和 $L$ 的每一列的预测非零模式：在消去顶点 $j$ 时，将 $j$ 当前具有更大索引的邻居变为一个团；在消去树中，$j$ 的父节点是 $L$ 第 $j$ 列中最小的、大于 $j$ 的行索引。\n- 通过枚举波前矩阵中的变量集及其所暗示的填充边，从多波前视角独立验证相同的模式。\n- 确定在 $L$ 的严格下三角部分中产生的填充非零元的精确数量（即 $L$ 中对角线以下的、不对应于 $G(A)$ 原始边的非零元）。\n\n请报告 $L$ 严格下三角部分中填充项的精确计数作为最终答案。不要四舍五入。无需单位。",
            "solution": "首先对问题进行验证，以确保其是良定的、有科学依据且客观的。\n\n### 步骤 1：提取已知条件\n-   矩阵 $A$ 是一个实对称正定 (SPD) 矩阵，$A \\in \\mathbb{R}^{6 \\times 6}$。\n-   $A$ 的稀疏图记为 $G(A)$，其顶点集为 $V = \\{1, 2, 3, 4, 5, 6\\}$，无向边集为 $E = \\{(1,2), (2,3), (4,5), (5,6), (1,4), (2,5), (3,6)\\}$。这些顶点对应于一个采用自然行主序的 $2 \\times 3$ 网格。\n-   分解方法是 Cholesky 分解，$A = LL^T$，其中 $L$ 是下三角矩阵。\n-   消去顺序固定为 $(1, 2, 3, 4, 5, 6)$，不进行主元选择或重排序。\n-   假设：不发生偶然的数值抵消，因此符号分解能准确预测非零结构。\n\n### 步骤 2：使用提取的已知条件进行验证\n-   **有科学依据：** 该问题是数值线性代数领域的标准练习，特别是关于稀疏矩阵分解。所有概念（SPD 矩阵、Cholesky 分解、稀疏图、填充、消去树、多波前方法）都是成熟的概念。\n-   **良定：** 问题提供了一个完全指定的图和一个固定的消去顺序。对于 SPD 矩阵，Cholesky 分解存在且唯一。在没有数值抵消的情况下，因子 $L$ 的非零模式是唯一确定的。任务具体，能够得出确切的答案。\n-   **客观：** 问题使用精确的数学术语陈述，没有歧义或主观元素。\n\n### 步骤 3：结论与行动\n该问题被判定为**有效**。将提供完整解答。\n\n### 解答推导\n\n问题的核心是确定稀疏矩阵 $A$ 的 Cholesky 因子 $L$ 的非零结构。这个结构等同于填充图 $G^+(A)$ 的结构，该图是在符号消去过程中通过向原始图 $G(A)$ 添加“填充”边而得到的。\n\nCholesky 分解的图论模型通过逐个消去顶点来进行。当一个顶点 $k$ 被消去时，它当前具有更大索引的邻居集合通过添加任何缺失的边而形成一个团。这些新边就是“填充边”。在所有顶点被消去后的最终图就是填充图 $G^+(A)$。$L$ 的非零结构由以下规则给出：当且仅当 $(i,j)$ 是 $G^+(A)$ 中的一条边（包括表示对角线的自环 $(j,j)$）时，$L_{ij} \\neq 0$ 对 $i \\geq j$ 成立。\n\n令 $G_0 = G(A)$。我们将生成一系列图 $G_1, G_2, \\ldots, G_5$，其中 $G_k$ 是消去顶点 $k$ 后的图。\n\n**初始图 $G_0$：**\n$G_0 = (V,E)$ 的邻接表为：\n-   $\\text{adj}_0(1) = \\{2, 4\\}$\n-   $\\text{adj}_0(2) = \\{1, 3, 5\\}$\n-   $\\text{adj}_0(3) = \\{2, 6\\}$\n-   $\\text{adj}_0(4) = \\{1, 5\\}$\n-   $\\text{adj}_0(5) = \\{2, 4, 6\\}$\n-   $\\text{adj}_0(6) = \\{3, 5\\}$\n\n**步骤 1：消去顶点 1**\n-   在 $G_0$ 中，顶点 1 的邻居是 $\\{2, 4\\}$。\n-   具有更大索引的邻居集合也是 $\\{2, 4\\}$。\n-   这些邻居必须形成一个团。边 $(2,4)$ 在 $G_0$ 中不存在。\n-   **填充边：** 我们向图中添加边 $(2,4)$。这是第一个填充。\n-   新图为 $G_1 = (V, E \\cup \\{(2,4)\\})$。\n-   $L$ 的第 1 列的非零结构由 1 在 $G_0$ 中的邻居决定：$L_{11}, L_{21}, L_{41}$ 为非零。\n-   在消去树中，顶点 1 的父节点由 $\\text{parent}(1) = \\min\\{i > 1 \\mid L_{i1} \\neq 0\\} = \\min\\{2, 4\\} = 2$ 给出。\n\n**步骤 2：消去顶点 2**\n-   在 $G_1$ 中，顶点 2 的邻居是 $\\{1, 3, 5\\}$ (来自 $G_0$) 和 $\\{4\\}$ (来自填充)。因此，$\\text{adj}_1(2) = \\{1, 3, 4, 5\\}$。\n-   具有更大索引的邻居集合是 $\\{3, 4, 5\\}$。\n-   这些邻居必须形成一个团。\n    -   边 $(4,5)$ 在 $G_0$ 中存在。\n    -   边 $(3,4)$ 不存在。**填充边：** 添加 $(3,4)$。\n    -   边 $(3,5)$ 不存在。**填充边：** 添加 $(3,5)$。\n-   新图为 $G_2 = (V, E \\cup \\{(2,4), (3,4), (3,5)\\})$。\n-   $L$ 的第 2 列的非零结构由 2 在 $G_1$ 中的邻居决定：$L_{22}, L_{32}, L_{42}, L_{52}$ 为非零。\n-   $\\text{parent}(2) = \\min\\{i > 2 \\mid L_{i2} \\neq 0\\} = \\min\\{3, 4, 5\\} = 3$。\n\n**步骤 3：消去顶点 3**\n-   在 $G_2$ 中，顶点 3 的邻居是 $\\{2, 6\\}$ (来自 $G_0$) 和 $\\{4, 5\\}$ (来自填充)。因此，$\\text{adj}_2(3) = \\{2, 4, 5, 6\\}$。\n-   具有更大索引的邻居集合是 $\\{4, 5, 6\\}$。\n-   这些邻居必须形成一个团。\n    -   边 $(4,5)$ 在 $G_0$ 中存在。\n    -   边 $(5,6)$ 在 $G_0$ 中存在。\n    -   边 $(4,6)$ 不存在。**填充边：** 添加 $(4,6)$。\n-   新图为 $G_3 = (V, E \\cup \\{(2,4), (3,4), (3,5), (4,6)\\})$。\n-   $L$ 的第 3 列的非零结构对应于 3 在 $G_2$ 中的邻居：$L_{33}, L_{43}, L_{53}, L_{63}$ 为非零。\n-   $\\text{parent}(3) = \\min\\{i > 3 \\mid L_{i3} \\neq 0\\} = \\min\\{4, 5, 6\\} = 4$。\n\n**步骤 4：消去顶点 4**\n-   在 $G_3$ 中，顶点 4 的邻居是 $\\{1, 5\\}$ (来自 $G_0$) 和 $\\{2, 3, 6\\}$ (来自填充)。因此，$\\text{adj}_3(4) = \\{1, 2, 3, 5, 6\\}$。\n-   具有更大索引的邻居集合是 $\\{5, 6\\}$。\n-   这些邻居必须形成一个团。边 $(5,6)$ 已在 $G_0$ 中存在。无新填充。\n-   $G_4 = G_3$。\n-   $L$ 的第 4 列的非零结构对应于 4 在 $G_3$ 中的邻居：$L_{44}, L_{54}, L_{64}$ 为非零。\n-   $\\text{parent}(4) = \\min\\{i > 4 \\mid L_{i4} \\neq 0\\} = \\min\\{5, 6\\} = 5$。\n\n**步骤 5：消去顶点 5**\n-   在 $G_4$ 中，顶点 5 的邻居是 $\\{2, 4, 6\\}$ (来自 $G_0$) 和 $\\{3\\}$ (来自填充)。因此，$\\text{adj}_4(5) = \\{2, 3, 4, 6\\}$。\n-   具有更大索引的邻居集合是 $\\{6\\}$。单个顶点是一个平凡的团。无新填充。\n-   $G_5 = G_4$。\n-   $L$ 的第 5 列的非零结构对应于 5 在 $G_4$ 中的邻居：$L_{55}, L_{65}$ 为非零。\n-   $\\text{parent}(5) = \\min\\{i > 5 \\mid L_{i5} \\neq 0\\} = \\min\\{6\\} = 6$。\n\n**步骤 6：消去顶点 6**\n-   顶点 6 是最后一个顶点。它没有更大索引的邻居。过程完成。顶点 6 是消去树的根。\n\n**图消去法结果摘要：**\n\n1.  **消去树：** 父节点关系为 $1 \\to 2$, $2 \\to 3$, $3 \\to 4$, $4 \\to 5$, $5 \\to 6$。这形成一条路径：\n    $$1 \\to 2 \\to 3 \\to 4 \\to 5 \\to 6$$\n2.  **L 的非零模式：** 对于 $i>j$，$L_{ij}$ 的非零项对应于最终填充图 $G^+ = G_5$ 中的边 $(i,j)$。\n    -   第 1 列：$\\{1, 2, 4\\}$\n    -   第 2 列：$\\{2, 3, 4, 5\\}$\n    -   第 3 列：$\\{3, 4, 5, 6\\}$\n    -   第 4 列：$\\{4, 5, 6\\}$\n    -   第 5 列：$\\{5, 6\\}$\n    -   第 6 列：$\\{6\\}$\n3.  **填充边：** 共产生了 4 条填充边：$(2,4), (3,4), (3,5), (4,6)$。\n\n### 多波前验证\n\n多波前方法提供了另一种但等价的视角。在每一步 $k$，为顶点 $k$ 及其在当前图中具有更大索引的邻居形成一个小的、稠密的“波前矩阵”$F_k$。从 $F_k$ 中分解出 $k$ 会在这些邻居上产生一个“Schur 补”或“更新矩阵”，然后将其组装回主系统中。关键思想是这个更新矩阵是稠密的，这恰好对应于将这些邻居变成一个团。\n\n-   **波前矩阵 $F_1$：** 变量为 $\\{1\\} \\cup \\text{adj}_{G_0}(1, >1) = \\{1, 2, 4\\}$。从此 $3 \\times 3$ 矩阵中分解出 1，会在 $\\{2, 4\\}$ 上创建一个稠密的 $2 \\times 2$ 更新。这会为系统的 $(2,4)$ 项产生非零贡献，验证了填充边 $(2,4)$。\n\n-   **波前矩阵 $F_2$：** 变量为 $\\{2\\} \\cup \\text{adj}_{G_1}(2, >2) = \\{2, 3, 4, 5\\}$。从此 $4 \\times 4$ 矩阵中分解出 2，会在 $\\{3, 4, 5\\}$ 上创建一个稠密的 $3 \\times 3$ 更新。这验证了填充边 $(3,4)$ 和 $(3,5)$。\n\n-   **波前矩阵 $F_3$：** 变量为 $\\{3\\} \\cup \\text{adj}_{G_2}(3, >3) = \\{3, 4, 5, 6\\}$。从此 $4 \\times 4$ 矩阵中分解出 3，会在 $\\{4, 5, 6\\}$ 上创建一个稠密的 $3 \\times 3$ 更新。这验证了填充边 $(4,6)$。\n\n-   **波前矩阵 $F_4$：** 变量为 $\\{4\\} \\cup \\text{adj}_{G_3}(4, >4) = \\{4, 5, 6\\}$。分解出 4 会在 $\\{5, 6\\}$ 上创建一个稠密的 $2 \\times 2$ 更新。由于 $(5,6)$ 已经是一条边，这不会产生填充，但会填充一个已有的非零项。\n\n-   **波前矩阵 $F_5$：** 变量为 $\\{5\\} \\cup \\text{adj}_{G_4}(5, >5) = \\{5, 6\\}$。不产生新的填充。\n\n因此，多波前视角独立地确认了图消去模型生成的填充序列。\n\n### 填充计数确定\n\n$L$ 的严格下三角部分中的填充非零元是满足 $i>j$ 且 $L_{ij} \\neq 0$ 但 $A_{ij} = 0$ 的项 $L_{ij}$。这个数量与符号分解过程中产生的填充边数量相同。\n\n原始图 $G(A)$ 的上三角部分有 7 条边：$(1,2), (1,4), (2,3), (2,5), (3,6), (4,5), (5,6)$。\n填充图 $G^+(A)$ 包含所有这些边以及填充边。\n填充边为：\n1.  $(2,4)$\n2.  $(3,4)$\n3.  $(3,5)$\n4.  $(4,6)$\n\n这四条边对应于 Cholesky 因子 $L$ 的严格下三角部分中的填充非零元 $L_{42}$、$L_{43}$、$L_{53}$ 和 $L_{64}$。\n填充非零元的总数为 $4$。",
            "answer": "$$\n\\boxed{4}\n$$"
        },
        {
            "introduction": "在对填充有了符号层面的理解之后，这个练习将深入探讨多阵面方法的数值计算机制。我们将为一个经典的带状矩阵执行一个完整的 $LDL^{\\top}$ 分解，显式地构建每个阵面矩阵，执行消元，并计算传递给下一阶段的更新块。这项练习揭开了抽象的组装和分解过程的神秘面纱，展示了计算和数据的流动。",
            "id": "3560937",
            "problem": "考虑对称正定（SPD）带状矩阵\n$$\nA \\;=\\; \\begin{pmatrix}\n2  -1  0  0  0\\\\\n-1  2  -1  0  0\\\\\n0  -1  2  -1  0\\\\\n0  0  -1  2  -1\\\\\n0  0  0  -1  2\n\\end{pmatrix} \\in \\mathbb{R}^{5 \\times 5}.\n$$\n使用多波前法和变量 $\\{1,2,3,4,5\\}$ 的自然消元顺序，对矩阵 $A$ 执行完整的下三角-对角-下三角转置 (LDL$^{\\top}$) 分解，无需进行数值主元分析。假设使用标准的多波前术语：在每个步骤 $i$，在变量集 $\\{i,i+1\\}$（对于最后一步则为 $\\{5\\}$）上组装一个波前矩阵，合并任何来自先前已消元变量的贡献，消去主元 $i$ 以在剩余变量上产生一个贡献块，并将此贡献向前传播以供后续组装。明确列出在整个过程中直至分解完成所执行的波前组装、消元和更新（贡献）序列。\n\n完成分解后，根据你的因子计算 $\\det(A)$。你的最终答案必须是一个实数。不要四舍五入。",
            "solution": "该问题要求使用多波前法和自然消元顺序，对一个给定的对称正定（SPD）$5 \\times 5$ 矩阵 $A$ 进行完整的下三角-对角-下三角转置 ($LDL^{\\top}$) 分解。随后，我们必须根据得到的因子计算 $A$ 的行列式。\n\n首先，我们验证问题陈述的有效性。\n1.  **已知条件**：\n    *   矩阵 $A = \\begin{pmatrix} 2  -1  0  0  0\\\\ -1  2  -1  0  0\\\\ 0  -1  2  -1  0\\\\ 0  0  -1  2  -1\\\\ 0  0  0  -1  2 \\end{pmatrix}$。\n    *   分解方法是多波前 $LDL^{\\top}$ 分解。\n    *   消元顺序是变量 $\\{1,2,3,4,5\\}$ 的自然顺序。\n    *   规定的波前集对于 $i \\in \\{1,2,3,4\\}$ 是 $\\{i, i+1\\}$，对于 $i=5$ 是 $\\{5\\}$。\n\n2.  **有效性验证**：\n    *   该问题具有科学依据，涉及数值线性代数中的一个标准算法（多波前分解），并将其应用于一个经典的测试矩阵（一维离散拉普拉斯算子）。\n    *   该问题是适定的。对于一个 SPD 矩阵，存在唯一的 $LDL^{\\top}$ 分解。指定的消元顺序使得整个过程是确定性的。\n    *   该问题是客观和完整的，提供了所有必要信息，没有含糊不清的术语，前提是假设多波前法的标准定义，其中“贡献”是加性更新块（舒尔补更新）。\n\n问题有效。我们开始求解。\n\n多波前法按指定顺序逐步进行，每次消去一个变量。在每个步骤 $k$，组装一个波前矩阵 $F_k$。这个组装过程包括从原始矩阵 $A$ 中取出相应的元素，并加上来自先前已消元变量（在消元树中的子节点）的任何更新贡献。对于本问题，消元树是一条简单的路径 $1 \\to 2 \\to 3 \\to 4 \\to 5$，因此每个步骤 $k > 1$ 只从步骤 $k-1$ 接收一个贡献。\n\n波前矩阵 $F_k$ 相对于主元变量 $k$ 进行分块，其分解为：\n$$ F_k = \\begin{pmatrix} F_{11}  F_{12} \\\\ F_{21}  F_{22} \\end{pmatrix} = \\begin{pmatrix} I  0 \\\\ F_{21}F_{11}^{-1}  I \\end{pmatrix} \\begin{pmatrix} F_{11}  0 \\\\ 0  F_{22} - F_{21}F_{11}^{-1}F_{12} \\end{pmatrix} \\begin{pmatrix} I  F_{11}^{-1}F_{12} \\\\ 0  I \\end{pmatrix} $$\n最终因子 $D$ 的对角块是 $D_{kk} = F_{11}$。最终因子 $L$ 的元素由 $F_{21}F_{11}^{-1}$ 计算得出。项 $C_{k+1} = -F_{21}F_{11}^{-1}F_{12}$ 是传递给父节点的更新贡献块。\n\n**步骤 1：消去变量 1**\n波前集是 $\\{1, 2\\}$。初始波前矩阵 $F_1$ 由 $A$ 的相应子矩阵构成，因为没有先前的贡献。\n$$ F_1 = \\begin{pmatrix} A_{11}  A_{12} \\\\ A_{21}  A_{22} \\end{pmatrix} = \\begin{pmatrix} 2  -1 \\\\ -1  2 \\end{pmatrix} $$\n我们消去主元变量 1。主元块是 $D_{11} = 2$。\n因子 $L$ 中的相应元素是 $L_{21} = A_{21} D_{11}^{-1} = (-1) (2)^{-1} = -\\frac{1}{2}$。\n对于剩余变量 2 的更新贡献是一个 $1 \\times 1$ 矩阵 $C_2$，它将在下一步中被组装。\n$$ C_2 = -A_{21} D_{11}^{-1} A_{12} = -(-1)(2^{-1})(-1) = -\\frac{1}{2} $$\n\n**步骤 2：消去变量 2**\n波前集是 $\\{2, 3\\}$。波前矩阵 $F_2$ 通过取 $A$ 中索引为 $\\{2, 3\\}$ 的子矩阵，并将贡献 $C_2$ 加到对应于变量 2 的元素上进行组装。\n$$ F_2 = \\begin{pmatrix} A_{22}  A_{23} \\\\ A_{32}  A_{33} \\end{pmatrix} + \\begin{pmatrix} C_2  0 \\\\ 0  0 \\end{pmatrix} = \\begin{pmatrix} 2  -1 \\\\ -1  2 \\end{pmatrix} + \\begin{pmatrix} -\\frac{1}{2}  0 \\\\ 0  0 \\end{pmatrix} = \\begin{pmatrix} \\frac{3}{2}  -1 \\\\ -1  2 \\end{pmatrix} $$\n我们消去主元变量 2。主元块是 $D_{22} = \\frac{3}{2}$。\n因子 $L$ 中的元素是 $L_{32} = F_{2(2,1)} D_{22}^{-1} = (-1) (\\frac{3}{2})^{-1} = -\\frac{2}{3}$。\n对变量 3 的更新贡献是 $C_3$。\n$$ C_3 = -F_{2(2,1)} D_{22}^{-1} F_{2(1,2)} = -(-1)(\\frac{2}{3})(-1) = -\\frac{2}{3} $$\n\n**步骤 3：消去变量 3**\n波前集是 $\\{3, 4\\}$。波前矩阵 $F_3$ 由 $A$ 的相应部分和贡献 $C_3$ 组装而成。\n$$ F_3 = \\begin{pmatrix} A_{33}  A_{34} \\\\ A_{43}  A_{44} \\end{pmatrix} + \\begin{pmatrix} C_3  0 \\\\ 0  0 \\end{pmatrix} = \\begin{pmatrix} 2  -1 \\\\ -1  2 \\end{pmatrix} + \\begin{pmatrix} -\\frac{2}{3}  0 \\\\ 0  0 \\end{pmatrix} = \\begin{pmatrix} \\frac{4}{3}  -1 \\\\ -1  2 \\end{pmatrix} $$\n我们消去主元变量 3。主元块是 $D_{33} = \\frac{4}{3}$。\n因子 $L$ 中的元素是 $L_{43} = F_{3(2,1)} D_{33}^{-1} = (-1) (\\frac{4}{3})^{-1} = -\\frac{3}{4}$。\n对变量 4 的更新贡献是 $C_4$。\n$$ C_4 = -F_{3(2,1)} D_{33}^{-1} F_{3(1,2)} = -(-1)(\\frac{3}{4})(-1) = -\\frac{3}{4} $$\n\n**步骤 4：消去变量 4**\n波前集是 $\\{4, 5\\}$。波前矩阵 $F_4$ 由 $A$ 的相应部分和贡献 $C_4$ 组装而成。\n$$ F_4 = \\begin{pmatrix} A_{44}  A_{45} \\\\ A_{54}  A_{55} \\end{pmatrix} + \\begin{pmatrix} C_4  0 \\\\ 0  0 \\end{pmatrix} = \\begin{pmatrix} 2  -1 \\\\ -1  2 \\end{pmatrix} + \\begin{pmatrix} -\\frac{3}{4}  0 \\\\ 0  0 \\end{pmatrix} = \\begin{pmatrix} \\frac{5}{4}  -1 \\\\ -1  2 \\end{pmatrix} $$\n我们消去主元变量 4。主元块是 $D_{44} = \\frac{5}{4}$。\n因子 $L$ 中的元素是 $L_{54} = F_{4(2,1)} D_{44}^{-1} = (-1) (\\frac{5}{4})^{-1} = -\\frac{4}{5}$。\n对变量 5 的更新贡献是 $C_5$。\n$$ C_5 = -F_{4(2,1)} D_{44}^{-1} F_{4(1,2)} = -(-1)(\\frac{4}{5})(-1) = -\\frac{4}{5} $$\n\n**步骤 5：消去变量 5**\n波前集是 $\\{5\\}$。这是最后一步（消元树的根节点）。波前矩阵 $F_5$ 由 $A_{55}$ 和贡献 $C_5$ 组装而成。\n$$ F_5 = (A_{55}) + (C_5) = (2) + (-\\frac{4}{5}) = (\\frac{6}{5}) $$\n这个完全组装好的矩阵是最终的主元块，$D_{55} = \\frac{6}{5}$。分解完成。\n\n分解 $A = LDL^{\\top}$ 中得到的因子是：\n$$\nL = \\begin{pmatrix}\n1  0  0  0  0 \\\\\n-\\frac{1}{2}  1  0  0  0 \\\\\n0  -\\frac{2}{3}  1  0  0 \\\\\n0  0  -\\frac{3}{4}  1  0 \\\\\n0  0  0  -\\frac{4}{5}  1\n\\end{pmatrix},\n\\quad\nD = \\begin{pmatrix}\n2  0  0  0  0 \\\\\n0  \\frac{3}{2}  0  0  0 \\\\\n0  0  \\frac{4}{3}  0  0 \\\\\n0  0  0  \\frac{5}{4}  0 \\\\\n0  0  0  0  \\frac{6}{5}\n\\end{pmatrix}\n$$\n\n最后，我们计算 $A$ 的行列式。利用性质 $\\det(XYZ) = \\det(X)\\det(Y)\\det(Z)$，我们有：\n$$ \\det(A) = \\det(L)\\det(D)\\det(L^{\\top}) $$\n由于 $L$ 和 $L^{\\top}$ 是单位三角矩阵，它们的行列式都是 1。因此，$\\det(A) = \\det(D)$。对角矩阵 $D$ 的行列式是其对角元素的乘积。\n$$ \\det(A) = D_{11} \\cdot D_{22} \\cdot D_{33} \\cdot D_{44} \\cdot D_{55} $$\n$$ \\det(A) = 2 \\times \\frac{3}{2} \\times \\frac{4}{3} \\times \\frac{5}{4} \\times \\frac{6}{5} $$\n这是一个伸缩积：\n$$ \\det(A) = \\cancel{2} \\times \\frac{\\cancel{3}}{\\cancel{2}} \\times \\frac{\\cancel{4}}{\\cancel{3}} \\times \\frac{\\cancel{5}}{\\cancel{4}} \\times \\frac{6}{\\cancel{5}} = 6 $$\n矩阵 $A$ 的行列式是 $6$。",
            "answer": "$$\n\\boxed{6}\n$$"
        },
        {
            "introduction": "这最后一个综合性练习将理论与实践联系起来，处理一个更实际的场景，其中涉及二维网格和强大的嵌套剖分排序。您将编写一个程序来进行符号分析，以预测多阵面求解器的内存需求，然后用实际的数值分解来验证您的预测。这个动手编程挑战将巩固抽象图算法与稀疏直接求解器实际性能之间的联系。",
            "id": "3560941",
            "problem": "设计并实现一个完整的、可运行的程序。该程序执行基于原理的符号分析，以预测在二维网格上由嵌套剖分排序所产生的组装树上的多波前方法的前沿矩阵维度，然后将预测的每个前沿矩阵的内存占用与通过实际数值分解获得的结果进行验证。您的分析和实现必须基于稀疏 Cholesky 分解和图消去的基本定义，且不使用任何专门的稀疏直接求解器库。\n\n设定如下。令 $A \\in \\mathbb{R}^{n \\times n}$ 是一个实对称正定 (SPD) 矩阵，该矩阵源于在 $N \\times N$ 内部网格上对带有齐次狄利克雷（Dirichlet）边界条件的负拉普拉斯算子的标准五点有限差分格式离散化，因此 $n = N^2$。考虑一个嵌套剖分 (ND) 排序，其分隔符层次结构为 $k$ 级，通过递归地用宽度为 $1$ 的分隔符二分网格域来构建。分隔符的方向在连续的层级之间交替（从 $0$ 开始索引的偶数层为垂直，奇数层为水平）。该排序采用标准的嵌套剖分顺序，即在每次递归中，子域在其分隔符之前被排序。对于足够小的子域或当递归达到第 $k$ 级时，终止递归并按行主序对剩余节点进行排序。\n\n您的任务：\n\n- 符号化地预测在 ND 排序下，沿组装树的前沿矩阵维度 $\\{F_i\\}_{i=1}^n$。在标量（每波前一个变量）多波前解释中，第 $i$ 个前沿维度等于 $F_i = 1 + d_i$，其中 $d_i$ 是第 $i$ 个变量在其消去时刻，在填充图中的后续邻居数量。使用图消去规则：在消去一个变量时，其所有后续邻居构成一个团（添加填充边），这是标准的稀疏 Cholesky 填充规则。\n\n- 通过对每个前沿矩阵的对称稠密存储求和，计算预测的总内存占用 $M_{\\mathrm{pred}}$，即 $M_{\\mathrm{pred}} = \\sum_{i=1}^n \\frac{F_i(F_i+1)}{2}$，单位为浮点数数量。\n\n- 通过对置换后的系统 $P A P^\\top$ 进行实际的数值 Cholesky 分解（使用稠密算术）来独立验证上述预测，其中 $P$ 编码了 ND 排序。令 $L$ 为下三角 Cholesky 因子。对于每一列 $j$，将实际的前沿维度定义为 $F_j^{(\\mathrm{num})} = \\#\\{i \\mid i \\ge j, L_{i,j} \\ne 0\\}$（计算对角线元素），并计算 $M_{\\mathrm{act}} = \\sum_{j=1}^n \\frac{F_j^{(\\mathrm{num})}(F_j^{(\\mathrm{num})}+1)}{2}$。使用 $10^{-12}$ 的严格浮点数阈值来判断 $L$ 中的非零元。\n\n- 对每个测试用例，报告绝对差 $\\Delta = |M_{\\mathrm{pred}} - M_{\\mathrm{act}}|$，结果为浮点数。\n\n将您的推导建立在以下基础定义和经过充分检验的事实之上：\n- 一个实对称正定 (SPD) 矩阵允许唯一的 Cholesky 分解 $A = L L^\\top$，其中 $L$ 是下三角矩阵。\n- 在给定排序的稀疏 Cholesky 分解中，消去一个变量会在其后续邻居之间形成一个团；此规则描述了填充和因子的非零模式。\n- 在标量多波前方法中，为变量创建的第 $i$ 个前沿矩阵包含主元以及在消去时通过填充与其耦合的所有变量；因此，其维度等于主元加上其在当前填充图中的后续邻居数量。\n\n您的程序必须实现：\n- 为 $N \\times N$ 网格上的五点模板和齐次狄利克雷边界条件构建 $A$，因此每个内部节点的对角线元素为 $4$，对其网格邻居（如果存在）的非对角线元素为 $-1$。\n- 按照指定的方式构建具有 $k$ 级分隔符层次结构的嵌套剖分排序。\n- 在置换图上进行符号消去以计算 $\\{F_i\\}$ 和 $M_{\\mathrm{pred}}$。\n- 在 $P A P^\\top$ 上进行稠密数值 Cholesky 分解以计算 $\\{F_i^{(\\mathrm{num})}\\}$ 和 $M_{\\mathrm{act}}$。\n- 每个测试用例的绝对差 $\\Delta$。\n\n测试套件和答案规范：\n- 使用以下三个测试用例：\n  - 测试用例 1：$N = 4$，$k = 2$。\n  - 测试用例 2：$N = 6$，$k = 2$。\n  - 测试用例 3：$N = 8$，$k = 3$。\n- 对每个用例，输出绝对差 $\\Delta$ 作为浮点数。\n- 您的程序应生成单行输出，其中包含三个结果，以逗号分隔并用方括号括起来（例如，$[x_1,x_2,x_3]$）。\n\n不涉及物理单位。如果出现任何角度，默认单位为弧度，但本问题不涉及角度。最终输出必须是浮点数。代码必须是自包含的，不需要输入，并且只使用允许的库。",
            "solution": "该问题要求对方格网上五点有限差分模板产生的矩阵的稀疏 Cholesky 分解进行两方面的分析。第一个方面是基于图消去的符号分析，以预测多波前求解器的内存占用。第二个方面是直接进行数值分解，以计算实际的内存占用。目标是验证这两个量的理论等价性。解决方案的结构如下：构建问题矩阵、生成指定的嵌套剖分排序、符号化预测内存使用情况，以及最后的数值验证。\n\n### 1. 矩阵和图的构建\n问题定义在一个 $N \\times N$ 的内部网格上，这导致了 $n = N^2$ 个变量或节点。矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 代表了使用标准五点模板和齐次狄利克雷边界条件离散化的负拉普拉斯算子。网格上的每个节点 $(r, c)$，其中 $0 \\le r, c  N$，对应于 $A$ 中的一行/一列 $i = rN+c$。矩阵元素定义如下：\n$$\nA_{ii} = 4\n$$\n$$\nA_{ij} = -1 \\quad \\text{如果节点 } j \\text{ 是节点 } i \\text{ 的网格邻居}\n$$\n$$\nA_{ij} = 0 \\quad \\text{其他情况}\n$$\n这个矩阵 $A$ 是对称正定 (SPD) 的。$A$ 的非零结构定义了一个无向图 $G=(V, E)$，其中 $V = \\{0, 1, \\dots, n-1\\}$ 是节点集，当且仅当 $i \\ne j$ 且 $A_{ij} \\ne 0$ 时，边 $(i, j) \\in E$ 存在。\n\n### 2. 嵌套剖分排序\n稀疏 Cholesky 分解的效率严重依赖于变量的排序。问题指定了嵌套剖分 (ND) 排序，这是一种“分而治之”的算法，以其在网格问题上产生低填充而闻名。ND 算法递归地划分网格图。\n\n对于给定的网格域，过程如下：\n- 识别一组称为分隔符的节点，以将域分成两个不相连的子域。\n- 然后在两个子域上递归调用该算法。\n- 最终的排序是第一个子域的排序、第二个子域的排序以及最后的分隔符节点的排序的拼接。\n\n问题指定了一个 $k$ 级层次结构，其中递归在第 $k$ 级终止。在每个层级，分隔符的方向交替变化，从第 $l=0$ 层的垂直方向开始。\n- 在偶数层 $l$，当前域被一个垂直分隔符分割。对于宽度为 $W$ 的域，分隔符是位于索引 $\\lfloor W/2 \\rfloor$ 的节点列。\n- 在奇数层 $l$，当前域被一个水平分隔符分割。对于高度为 $H$ 的域，分隔符是位于索引 $\\lfloor H/2 \\rfloor$ 的节点行。\n- 当递归在第 $k$ 级终止或域是平凡的时，剩余的节点按标准的行主序遍历进行排序。\n\n这个过程产生一个置换 $P$，该置换对变量重新排序。然后对置换后的矩阵 $P A P^\\top$ 进行分解。\n\n### 3. 符号分解和预测内存占用 ($M_{\\mathrm{pred}}$)\n稀疏矩阵 $A$（对于给定的排序）的 Cholesky 因子 $L$ 的结构可以在不计算任何数值的情况下确定。填充，即在 $L$ 中原本为零的位置上创建非零元，是由图消去过程控制的。关键规则是：当一个节点 $i$ 被消去时，所有在排序中出现在其后的邻居（“后续邻居”）变成一个团，这意味着在任何一对尚未连接的此类邻居之间添加填充边。\n\n在标量多波前方法中，当每个变量被消去时，会为其组装一个小的、稠密的“前沿矩阵”。变量 $i$ 的前沿矩阵涉及变量 $i$ 本身（主元）以及在消去时刻图中它的所有后续邻居。因此，这个前沿矩阵的维度 $F_i$ 是 $1 + d_i$，其中 $d_i$ 是节点 $i$ 的后续邻居的数量。\n\n符号分析在置换图上模拟了这个过程：\n1. 创建 $P A P^\\top$ 的置换图的邻接表表示。\n2. 从 $i=0$ 到 $n-1$ 遍历节点。\n3. 在每一步 $i$，识别后续邻居的集合，并使用其大小 $d_i$ 来计算 $F_i = 1+d_i$。\n4. 在这些后续邻居的所有对之间向图中添加填充边。\n5. 对所有节点重复此过程。\n\n预测的内存占用 $M_{\\mathrm{pred}}$ 是所有稠密前沿矩阵所需的总存储量，假设为对称存储。计算公式如下：\n$$\nM_{\\mathrm{pred}} = \\sum_{i=1}^{n} \\frac{F_i (F_i + 1)}{2}\n$$\n这个量是因子所需内存的直接度量。\n\n### 4. 数值分解和实际内存占用 ($M_{\\mathrm{act}}$)\n为了验证符号预测，我们执行实际的数值 Cholesky 分解 $P A P^\\top = L L^\\top$。首先构建矩阵 $A$，然后根据 ND 排序 $P$ 对其进行置换，形成 $A' = P A P^\\top$。使用 `numpy.linalg.cholesky` 函数来计算 $A'$ 的下三角因子 $L$。\n\n计算出的因子 $L$ 的结构揭示了“实际的”前沿维度。对于 $L$ 的每一列 $j$，对角线或其下方的非零元素数量，$L_{i,j}$ for $i \\ge j$，对应于与变量 $j$ 相关的前沿矩阵的大小（或者更准确地说，是超节点的大小）。在浮点运算中，需要一个严格的阈值来识别非零元。问题指定了 $10^{-12}$ 的阈值。因此，数值方法导出的列 $j$ 的前沿维度为：\n$$\nF_j^{(\\mathrm{num})} = \\#\\{i \\mid i \\ge j, |L_{ij}| > 10^{-12}\\}\n$$\n实际的内存占用 $M_{\\mathrm{act}}$ 的计算方式与预测的类似：\n$$\nM_{\\mathrm{act}} = \\sum_{j=1}^{n} \\frac{F_j^{(\\mathrm{num})} (F_j^{(\\mathrm{num})} + 1)}{2}\n$$\n\n### 5. 比较\n稀疏 Cholesky 分解的基本定理指出，在精确算术中，符号和数值方法必须产生相同的结构。因此，我们预期对于所有的 $i$，都有 $F_i = F_i^{(\\mathrm{num})}$，从而 $M_{\\mathrm{pred}} = M_{\\mathrm{act}}$。最后一步是计算绝对差 $\\Delta = |M_{\\mathrm{pred}} - M_{\\mathrm{act}}|$。任何非零结果都将表明由浮点算术引起的差异，其中一个本应为零的值变成了一个小的非零数（或反之）并超过了所选的阈值。对于一个适定问题和稳定的分解，我们预期 $\\Delta = 0.0$。",
            "answer": "```python\nimport numpy as np\n\ndef coord_to_idx(r, c, N):\n    \"\"\"Maps a 2D grid coordinate to a 1D index.\"\"\"\n    return r * N + c\n\ndef _nd_recursive(domain, level, k):\n    \"\"\"\n    Recursive helper for nested dissection.\n    - domain: tuple (r_min, r_max, c_min, c_max)\n    - level: current recursion level\n    - k: max recursion level\n    \"\"\"\n    r_min, r_max, c_min, c_max = domain\n    \n    if r_min > r_max or c_min > c_max:\n        return []\n\n    height = r_max - r_min + 1\n    width = c_max - c_min + 1\n\n    if level >= k or (height == 1 and width == 1):\n        nodes = []\n        for r in range(r_min, r_max + 1):\n            for c in range(c_min, c_max + 1):\n                nodes.append((r, c))\n        return nodes\n\n    order = []\n    split_made = False\n\n    # Alternate split orientation based on level\n    if level % 2 == 0:  # Even level: vertical split\n        if width > 1:\n            c_sep = c_min + width // 2\n            order.extend(_nd_recursive((r_min, r_max, c_min, c_sep - 1), level + 1, k))\n            order.extend(_nd_recursive((r_min, r_max, c_sep + 1, c_max), level + 1, k))\n            sep_nodes = [(r, c_sep) for r in range(r_min, r_max + 1)]\n            order.extend(sep_nodes)\n            split_made = True\n    else:  # Odd level: horizontal split\n        if height > 1:\n            r_sep = r_min + height // 2\n            order.extend(_nd_recursive((r_min, r_sep - 1, c_min, c_max), level + 1, k))\n            order.extend(_nd_recursive((r_sep + 1, r_max, c_min, c_max), level + 1, k))\n            sep_nodes = [(r_sep, c) for c in range(c_min, c_max + 1)]\n            order.extend(sep_nodes)\n            split_made = True\n\n    # If the prescribed split was not possible (e.g., vertical split on a column vector),\n    # treat the domain as a leaf node.\n    if not split_made:\n        nodes = []\n        for r in range(r_min, r_max + 1):\n            for c in range(c_min, c_max + 1):\n                nodes.append((r, c))\n        return nodes\n        \n    return order\n\n\ndef generate_nd_ordering(N, k):\n    \"\"\"Generates the nested dissection permutation for an N x N grid.\"\"\"\n    n = N * N\n    ordered_coords = _nd_recursive((0, N - 1, 0, N - 1), 0, k)\n    \n    p_inv = [coord_to_idx(r, c, N) for r, c in ordered_coords]\n    \n    p = np.zeros(n, dtype=int)\n    for new_idx, old_idx in enumerate(p_inv):\n        p[old_idx] = new_idx\n        \n    return p_inv, p\n\ndef symbolic_factorization(N, p):\n    \"\"\"Performs symbolic factorization to predict frontal matrix dimensions.\"\"\"\n    n = N * N\n    \n    # Build original adjacency list\n    adj = [set() for _ in range(n)]\n    for r in range(N):\n        for c in range(N):\n            idx = coord_to_idx(r, c, N)\n            if r + 1  N:\n                neighbor_idx = coord_to_idx(r + 1, c, N)\n                adj[idx].add(neighbor_idx)\n                adj[neighbor_idx].add(idx)\n            if c + 1  N:\n                neighbor_idx = coord_to_idx(r, c + 1, N)\n                adj[idx].add(neighbor_idx)\n                adj[neighbor_idx].add(idx)\n\n    # Create permuted adjacency list\n    adj_perm = [set() for _ in range(n)]\n    for u in range(n):\n        for v in adj[u]:\n            p_u, p_v = p[u], p[v]\n            adj_perm[p_u].add(p_v)\n\n    frontal_dims = []\n    for i in range(n):\n        later_neighbors = {j for j in adj_perm[i] if j > i}\n        frontal_dims.append(1 + len(later_neighbors))\n        \n        neighbors_list = list(later_neighbors)\n        for idx1 in range(len(neighbors_list)):\n            for idx2 in range(idx1 + 1, len(neighbors_list)):\n                u, v = neighbors_list[idx1], neighbors_list[idx2]\n                adj_perm[u].add(v)\n                adj_perm[v].add(u)\n        \n    m_pred = sum(f * (f + 1) / 2.0 for f in frontal_dims)\n    return m_pred\n\ndef numeric_factorization(N, p_inv):\n    \"\"\"Performs numeric Cholesky factorization and measures frontal dimensions.\"\"\"\n    n = N * N\n    \n    A = np.zeros((n, n), dtype=float)\n    for r in range(N):\n        for c in range(N):\n            i = coord_to_idx(r, c, N)\n            A[i, i] = 4.0\n            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nr, nc = r + dr, c + dc\n                if 0 = nr  N and 0 = nc  N:\n                    j = coord_to_idx(nr, nc, N)\n                    A[i, j] = -1.0\n\n    A_perm = A[np.ix_(p_inv, p_inv)]\n    \n    L = np.linalg.cholesky(A_perm)\n    \n    frontal_dims_num = []\n    for j in range(n):\n        non_zeros = np.sum(np.abs(L[j:, j]) > 1e-12)\n        frontal_dims_num.append(non_zeros)\n        \n    m_act = sum(f * (f + 1) / 2.0 for f in frontal_dims_num)\n    return m_act\n\ndef solve():\n    \"\"\"Main function to run test cases and compute the difference in memory footprints.\"\"\"\n    test_cases = [\n        (4, 2),\n        (6, 2),\n        (8, 3),\n    ]\n\n    results = []\n    for N, k in test_cases:\n        p_inv, p = generate_nd_ordering(N, k)\n        \n        m_pred = symbolic_factorization(N, p)\n        m_act = numeric_factorization(N, p_inv)\n        \n        delta = abs(m_pred - m_act)\n        results.append(delta)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}