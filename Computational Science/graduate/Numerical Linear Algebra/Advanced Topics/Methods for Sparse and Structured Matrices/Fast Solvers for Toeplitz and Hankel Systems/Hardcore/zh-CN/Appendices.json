{
    "hands_on_practices": [
        {
            "introduction": "通过快速傅里叶变换（FFT）加速的循环嵌入是实现托普利茨（Toeplitz）矩阵快速向量乘法（MVM）的基石技术。然而，该方法的效率和准确性严重依赖于一个关键参数：循环矩阵的嵌入尺寸 $m$。本实践练习将指导你亲手实现这一核心算法，并探索如何在计算成本与由矩阵生成符号的平滑度决定的混叠误差之间进行权衡 ()。",
            "id": "3545696",
            "problem": "考虑一个由在 $[0,2\\pi)$ 上的双边傅里叶级数符号 $g(\\theta)$ 生成的 $n \\times n$ 对称Toeplitz矩阵族。该符号通过满足 $t_{-k} = t_k$ 的实数、非负傅里叶系数 $\\{t_k\\}_{k \\in \\mathbb{N}_0}$ 来定义。Toeplitz矩阵 $T_n$ 的元素为 $(T_n)_{ij} = t_{|i-j|}$，其中 $1 \\leq i,j \\leq n$。任务是使用循环嵌入和快速傅里叶变换（FFT）高效地计算矩阵向量乘积 $y = T_n x$，并优化嵌入尺寸以最小化混叠效应。\n\n基础原理：\n- 离散傅里叶变换（DFT）可以对角化循环矩阵。长度为 $m$ 的核与长度为 $m$ 的向量的循环卷积可通过FFT在 $\\mathcal{O}(m \\log m)$ 时间内计算。\n- 傅里叶级数表示 $g(\\theta) = \\sum_{k \\in \\mathbb{Z}} t_k \\mathrm{e}^{-\\mathrm{i} k \\theta}$（其中 $t_{-k}=t_k$）在 $m$ 阶循环群上定义了一个平移不变核。在 $m$ 点网格上对 $g(\\theta)$ 进行采样，会产生一个循环矩阵，其时域核等于傅里叶系数的周期求和。\n\n混叠与周期求和原理：\n- 在 $m$ 个等距点上对 $g(\\theta)$ 进行采样并应用逆DFT，会产生一个时域序列 $c[r]$（$0 \\leq r  m$），它等于傅里叶系数的周期求和：\n$$\nc[r] = \\sum_{\\ell \\in \\mathbb{Z}} t_{\\lvert r + \\ell m \\rvert}.\n$$\n- 计算 $c$ 与补零的 $x$ 的循环卷积，可以近似得到 $T_n x$。与精确Toeplitz乘积的差异可以由周期求和尾部引起的混叠误差来界定。\n\n符号平滑度模型：\n- 指数衰减（解析符号）：$t_k = C \\mathrm{e}^{-\\alpha k}$，对于 $k \\geq 0$，参数为 $C  0, \\alpha  0$。\n- 代数衰减（有限平滑度）：$t_k = C (1+k)^{-p}$，对于 $k \\geq 0$，参数为 $C  0, p  1$。\n\n$\\{t_k\\}$ 周期求和的混叠误差界：\n- 对于指数衰减，任意固定 $r$ 的周期混叠尾部有界：\n$$\nE_{\\mathrm{alias}}^{\\mathrm{exp}}(m) \\leq 2 C \\frac{\\mathrm{e}^{-\\alpha m}}{1 - \\mathrm{e}^{-\\alpha m}}.\n$$\n- 对于代数衰减，任意固定 $r$ 的周期混叠尾部有界：\n$$\nE_{\\mathrm{alias}}^{\\mathrm{alg}}(m) \\leq 2 C \\zeta(p) m^{-p},\n$$\n其中 $\\zeta(p)$ 是在 $p$ 点求值的Riemann zeta函数。\n\n优化目标：\n- 给定 $n$、一个已知参数的平滑度模型和一个容差 $\\varepsilon$，选择最小的2的幂次的嵌入尺寸 $m$，使得所选模型的混叠误差界最多为 $\\varepsilon$，同时确保 $m \\geq 2n$，以使循环卷积窗口能覆盖线性范围而不会发生输入的环绕。\n\n实现细节：\n- 使用恒等式 $c[r] = \\sum_{\\ell \\in \\mathbb{Z}} t_{\\lvert r + \\ell m \\rvert}$ 构建周期核 $c[r]$，通过忽略低于阈值 $\\tau$ 的项进行截断。由于在两种模型下 $t_k$ 随 $k$ 单调递减，一个对 $\\ell \\geq 1$ 的简单循环就足够了，当 $t_{r + \\ell m}$ 和 $t_{\\ell m - r}$ 都低于 $\\tau$ 时停止。对于 $r=0$，使用 $c[0] = t_0 + 2\\sum_{\\ell \\geq 1} t_{\\ell m}$ 并在 $\\tau$ 处截断。\n- 使用FFT，通过计算 $c$ 与补零至长度为 $m$ 的 $x$ 的循环卷积，来计算近似乘积 $y_{\\mathrm{FFT}}$。\n- 通过直接求和 $y_i = \\sum_{j=1}^n t_{\\lvert i-j \\rvert} x_j$ 来计算精确乘积 $y_{\\mathrm{exact}}$。\n- 测量相对误差 $\\|y_{\\mathrm{FFT}} - y_{\\mathrm{exact}}\\|_{\\infty}/\\|y_{\\mathrm{exact}}\\|_{\\infty}$。\n\n测试套件：\n对于以下每个测试用例，使用容差 $\\varepsilon = 10^{-8}$ 和截断阈值 $\\tau = 10^{-12}$。\n\n1. 指数衰减（解析符号）：\n   - $n = 64$, $C = 1$, $\\alpha = 0.5$。\n2. 代数衰减（有限平滑度）：\n   - $n = 64$, $C = 1$, $p = 2.2$。\n3. 指数衰减（解析符号，衰减更快）：\n   - $n = 128$, $C = 1$, $\\alpha = 1.0$。\n4. 代数衰减（有限平滑度，更平滑）：\n   - $n = 128$, $C = 1$, $p = 3.0$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个结果是对应测试用例的相对 $\\ell_{\\infty}$ 误差（一个浮点数），顺序与上面列出的一致。例如：\"[e1,e2,e3,e4]\"。",
            "solution": "用户提供了一个数值线性代数领域的问题，具体涉及对称Toeplitz矩阵 $T_n$ 的快速矩阵向量乘积计算。所提出的方法包括将 $n \\times n$ 的Toeplitz矩阵嵌入到一个更大的 $m \\times m$ 循环矩阵中，并使用快速傅里叶变换（FFT）在 $\\mathcal{O}(m \\log m)$ 时间内高效地执行卷积。\n\n### 步骤1：问题验证\n\n在尝试解决方案之前，对问题进行严格的验证。\n\n- **提取已知条件**：\n    - **矩阵**：大小为 $n \\times n$ 的对称Toeplitz矩阵 $T_n$，其元素为 $(T_n)_{ij} = t_{\\lvert i-j \\rvert}$。\n    - **系数**：序列 $\\{t_k\\}_{k \\in \\mathbb{N}_0}$ 是实数、非负且偶的 ($t_{-k} = t_k$)。\n    - **任务**：使用大小为 $m \\times m$ 的循环嵌入和FFT计算 $y = T_n x$。\n    - **循环核**：循环矩阵的第一列 $c$ 由周期求和 $c[r] = \\sum_{\\ell \\in \\mathbb{Z}} t_{\\lvert r + \\ell m \\rvert}$ 定义。\n    - **系数衰减模型**：\n        1. 指数（解析）：$t_k = C \\mathrm{e}^{-\\alpha k}$，对于 $k \\geq 0$，参数为 $C  0, \\alpha  0$。\n        2. 代数（有限平滑度）：$t_k = C (1+k)^{-p}$，对于 $k \\geq 0$，参数为 $C  0, p  1$。\n    - **混叠误差界**：为每种衰减模型，都提供了由于周期求和导致的循环核误差的显式公式。\n        - 指数：$E_{\\mathrm{alias}}^{\\mathrm{exp}}(m) \\leq 2 C \\frac{\\mathrm{e}^{-\\alpha m}}{1 - \\mathrm{e}^{-\\alpha m}}$。\n        - 代数：$E_{\\mathrm{alias}}^{\\mathrm{alg}}(m) \\leq 2 C \\zeta(p) m^{-p}$。\n    - **优化目标**：对于给定的 $n$、衰减模型和容差 $\\varepsilon$，找到最小的2的幂次的整数 $m$，使得 $m \\geq 2n$ 且对应的混叠误差界不大于 $\\varepsilon$。\n    - **实现细节**：\n        - 核的构建涉及当项小于阈值 $\\tau$ 时截断 $c[r]$ 的求和。\n        - 最终误差通过相对 $\\ell_{\\infty}$ 范数测量：$\\|y_{\\mathrm{FFT}} - y_{\\mathrm{exact}}\\|_{\\infty}/\\|y_{\\mathrm{exact}}\\|_{\\infty}$。\n    - **测试套件参数**：指定了四个测试用例，包含 $n, C, \\alpha, p$ 的值。给定的容差为 $\\varepsilon = 10^{-8}$ 和 $\\tau = 10^{-12}$。\n\n- **验证结论**：\n    - **科学依据**：该问题是傅里叶分析在数值线性代数中的一个经典应用。对Toeplitz系统使用循环预条件子和快速卷积是一种成熟的基础技术。符号的平滑度（傅里叶系数的衰减）与循环近似的收敛性之间的联系是该领域的核心概念。提供的误差界是标准结果。该问题在科学和数学上是合理的。\n    - **问题适定且完整**：问题定义清晰。所有必要的参数、模型和目标都已指定。嵌入尺寸 $m$ 的优化目标是明确的。唯一未指定的是输入向量 $x$。在测试数值算法的准确性时，标准做法是使用固定或随机的向量。使用由固定种子生成的伪随机数向量是一种有效且标准的完成问题规范的方法。\n    - **客观性**：语言精确且数学化，没有任何主观性或歧义性。\n\n问题被判定为**有效**。这是一个适定且有科学依据的计算数学练习。可以继续进行解决方案的推导。\n\n### 步骤2：解决方案推导\n\n解决方案涉及为四个测试用例中的每一个实现所述算法。将为每个测试用例生成一个随机向量 $x$ 以执行计算。为了可复现性，使用一个具有固定种子的伪随机数生成器。\n\n**每个测试用例的算法大纲：**\n\n1.  **参数设置**：分离当前测试用例的参数：$n$、模型类型（'exponential' 或 'algebraic'）以及模型参数（$C, \\alpha$ 或 $C, p$）。设置容差 $\\varepsilon = 10^{-8}$ 和 $\\tau = 10^{-12}$。\n\n2.  **确定嵌入尺寸 $m$**：\n    -   将 $m$ 初始化为大于或等于 $2n$ 的最小的2的幂。这确保了线性卷积能够正确计算而没有环绕效应。\n    -   进入一个循环：\n        -   根据当前 $m$ 的指定模型计算混叠误差界。对于代数模型，这需要`scipy.special`中可用的Riemann zeta函数 $\\zeta(p)$。\n        -   如果计算出的界小于或等于容差 $\\varepsilon$，则退出循环。\n        -   否则，将 $m$ 的值加倍并继续循环。\n\n3.  **生成测试数据**：\n    -   创建大小为 $n$ 的输入向量 $x$，其条目从 $[0, 1)$ 上的均匀分布中抽取。\n    -   定义一个辅助函数 `t_k_func(k)`，根据指定的衰减模型计算系数 $t_k$。\n\n4.  **计算精确乘积 $y_{\\mathrm{exact}}$**：\n    -   生成Toeplitz矩阵 $T_n$ 的第一列，它由 $[t_0, t_1, \\dots, t_{n-1}]$ 组成。\n    -   使用函数 `scipy.linalg.toeplitz` 构建完整的 $n \\times n$ 对称Toeplitz矩阵 $T_n$。\n    -   计算精确的矩阵向量乘积 $y_{\\mathrm{exact}} = T_n x$。\n\n5.  **计算近似乘积 $y_{\\mathrm{FFT}}$**：\n    -   **构建循环核 $c$**：创建一个长度为 $m$ 的向量 $c$。基于恒等式 $c[r] = \\sum_{\\ell \\in \\mathbb{Z}} t_{|r+\\ell m|}$ 和 $t_k$ 的偶性，$c$ 相对于中点 $m/2$ 也是偶的，即 $c[r] = c[m-r]$。利用此对称性提高效率。\n        -   通过对级数 $t_r + \\sum_{\\ell=1}^{\\infty} (t_{\\ell m - r} + t_{\\ell m + r})$ 求和（对于 $r=0$ 有特殊形式），计算 $r \\in [0, m/2]$ 时的 $c[r]$。当待加项低于阈值 $\\tau$ 时，截断对 $\\ell$ 的求和。\n        -   使用对称性 $c[r] = c[m-r]$ 填充 $r \\in (m/2, m)$ 的剩余条目 $c[r]$。\n    -   **通过FFT进行循环卷积**：\n        -   将输入向量 $x$ 补零至长度 $m$。\n        -   使用 `numpy.fft.fft` 计算核 $c$ 和补零向量 $x$ 的DFT。\n        -   将DFT结果逐元素相乘。\n        -   使用 `numpy.fft.ifft` 计算乘积的逆DFT。结果即为循环卷积。\n        -   提取所得向量的前 $n$ 个分量，并取其实部（以丢弃由浮点不精确性产生的可忽略的虚部）。这就是近似乘积 $y_{\\mathrm{FFT}}$。\n\n6.  **计算相对误差**：使用 $\\ell_{\\infty}$-范数计算相对误差：\n    $$\n    \\text{error} = \\frac{\\|y_{\\mathrm{FFT}} - y_{\\mathrm{exact}}\\|_{\\infty}}{\\|y_{\\mathrm{exact}}\\|_{\\infty}}\n    $$\n    进行检查以处理 $\\|y_{\\mathrm{exact}}\\|_{\\infty}$ 可能为零的情况。\n\n7.  **存储并报告**：存储计算出的误差。处理完所有测试用例后，将结果格式化为指定的单个字符串。\n\n此系统化流程在最终答案中提供的Python代码中实现。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import toeplitz\nfrom scipy.special import zeta\n\ndef solve():\n    \"\"\"\n    Computes the matrix-vector product y = T_n x for a symmetric Toeplitz\n    matrix T_n using a circulant embedding and FFT, and evaluates the\n    accuracy against a direct computation.\n    \"\"\"\n    # Define problem constants and test suite\n    TOL_EPS = 1e-8\n    TOL_TAU = 1e-12\n\n    test_cases = [\n        {'n': 64, 'model': 'exponential', 'params': {'C': 1.0, 'alpha': 0.5}},\n        {'n': 64, 'model': 'algebraic', 'params': {'C': 1.0, 'p': 2.2}},\n        {'n': 128, 'model': 'exponential', 'params': {'C': 1.0, 'alpha': 1.0}},\n        {'n': 128, 'model': 'algebraic', 'params': {'C': 1.0, 'p': 3.0}},\n    ]\n\n    results = []\n    # Use a seeded random number generator for reproducible results\n    rng = np.random.default_rng(12345)\n\n    for case in test_cases:\n        n = case['n']\n        model = case['model']\n        params = case['params']\n\n        # Define the tk generator function based on the model\n        if model == 'exponential':\n            C, alpha = params['C'], params['alpha']\n            t_k_func = lambda k: C * np.exp(-alpha * np.abs(k))\n        else: # algebraic\n            C, p = params['C'], params['p']\n            t_k_func = lambda k: C * (1 + np.abs(k))**(-p)\n\n        # 1. Determine the optimal embedding size m\n        # Smallest power of two >= 2n\n        m = 1  int(np.ceil(np.log2(max(1, 2 * n))))\n        \n        while True:\n            if model == 'exponential':\n                denom = 1 - np.exp(-alpha * m)\n                bound = 2 * C * np.exp(-alpha * m) / denom if denom > 0 else float('inf')\n            else: # algebraic\n                bound = 2 * C * zeta(p) * (m**(-p))\n            \n            if bound = TOL_EPS:\n                break\n            m *= 2\n            \n        # 2. Generate test vector x\n        x = rng.random(n)\n        \n        # 3. Compute the exact matrix-vector product\n        t_coeffs = t_k_func(np.arange(n))\n        T_n = toeplitz(t_coeffs)\n        y_exact = T_n @ x\n\n        # 4. Compute the approximate product using FFT\n        # 4.1 Construct the circulant kernel c\n        c = np.zeros(m)\n        \n        # Compute c[0] through c[m/2] by summing the periodic terms\n        for r in range(m // 2 + 1):\n            c[r] = t_k_func(r)\n            ell = 1\n            while True:\n                if r == 0:\n                    # For r=0, term is t(lm) + t(-lm) = 2*t(lm)\n                    term = 2 * t_k_func(ell * m)\n                else:\n                    # For r>0, term is t(lm+r) + t(lm-r)\n                    term = t_k_func(ell * m - r) + t_k_func(ell * m + r)\n                \n                if term = TOL_TAU:\n                    break\n                \n                c[r] += term\n                ell += 1\n        \n        # Exploit symmetry c[r] = c[m-r] for the other half of the kernel\n        for r in range(1, m // 2):\n            c[m - r] = c[r]\n\n        # 4.2 Perform circular convolution via FFT\n        x_pad = np.zeros(m)\n        x_pad[:n] = x\n        \n        y_pad = np.fft.ifft(np.fft.fft(c) * np.fft.fft(x_pad))\n        # Result should be real; take real part to discard numerical noise\n        y_fft = np.real(y_pad[:n])\n        \n        # 5. Calculate the relative l-infinity error\n        norm_y_exact = np.linalg.norm(y_exact, np.inf)\n        if norm_y_exact == 0:\n            error = 0.0\n        else:\n            error = np.linalg.norm(y_fft - y_exact, np.inf) / norm_y_exact\n            \n        results.append(error)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "在掌握了快速矩阵向量乘法后，我们进而关注完整的线性系统求解器。尽管像Levinson-Durbin这样的经典快速算法非常高效，但它们在处理病态矩阵时可能会表现出数值不稳定性。本实践设计了一个直接的计算实验，旨在比较经典的Levinson-Durbin算法与一种稳健的、带主元的数值方法（作为Gohberg–Kailath–Olshevsky（GKO）等现代算法的代表）的性能，从而揭示为何在面对具有挑战性的问题时，开发更先进的稳定算法是必不可少的 ()。",
            "id": "3545692",
            "problem": "从一个在单位圆上具有零点的符号（symbol）出发，构建一个 Hermitian Toeplitz 线性系统族，并设计一个参数化实验，以在零点趋近 $\\{e^{\\pm i\\theta_0}\\}$ 时，比较 Levinson–Durbin 递归与 Gohberg–Kailath–Olshevsky (GKO) 范式之间的数值稳定性和准确性。请从以下基础出发。\n\n一个大小为 $n\\times n$ 的 Toeplitz 矩阵 $T_n(f)$ 是由一个 $2\\pi$ 周期符号 $f(\\theta)$ 通过其傅里葉系数生成的。对于一个函数 $f(\\theta)$，其傅里葉系数为 $c_k = \\frac{1}{2\\pi}\\int_0^{2\\pi} f(\\theta)e^{-ik\\theta}\\,d\\theta$（其中 $k$ 为整数），Toeplitz 矩阵定义为 $[T_n(f)]_{ij} = c_{i-j}$（其中 $i,j \\in \\{1,2,\\dots,n\\}$），并约定 $c_{-k} = \\overline{c_k}$ 以确保其 Hermitian 结构。\n\n考虑以下符号族：\n$$\nf_{\\delta,\\theta_0}(\\theta) = \\delta + 2 - 2\\cos(\\theta - \\theta_0),\n$$\n其中 $\\delta  0$ 是一个小参数，$\\theta_0 \\in (0,\\pi)$ 是一个固定值。函数 $f_{\\delta,\\theta_0}(\\theta)$对所有 $\\theta$ 都是非负的，并且在 $\\delta = 0$ 时于 $\\theta = \\theta_0$ 处有一个零点，因此当 $\\delta \\to 0^+$ 时，相关的 Toeplitz 矩阵会变得越来越病态。推导 $f_{\\delta,\\theta_0}(\\theta)$ 的傅里葉系数，并使用它们构建一个 Hermitian Toeplitz 矩阵 $T_n(f_{\\delta,\\theta_0})$，其第一列为 $c$，第一行为 $r$。选择一个确定性的非零目标解向量 $x_{\\text{true}} \\in \\mathbb{C}^n$，构建右端项 $b = T_n(f_{\\delta,\\theta_0}) x_{\\text{true}}$，并用两种方法求解方程组 $T_n(f_{\\delta,\\theta_0}) x = b$：\n- 专门用于 Hermitian Toeplitz 矩阵的 Levinson–Durbin 递归。\n- 一种 Gohberg–Kailath–Olshevsky (GKO) 风格的带主元方法。在此实验中，需要通过对密集的 Toeplitz 矩阵应用经典的部分主元 Gaussian 消去法来模拟 GKO 的主元选择和稳健性，接受快速复杂度的损失，但专注于当零点趋近单位圆时的稳定性和准确性。\n\n对于每种方法计算出的解 $\\hat{x}$，评估以下可量化指标：\n1. 相对解误差 $E = \\frac{\\| \\hat{x} - x_{\\text{true}} \\|_2}{\\| x_{\\text{true}} \\|_2}$。\n2. 相对残差范数 $R = \\frac{\\| b - T_n(f_{\\delta,\\theta_0}) \\hat{x} \\|_2}{\\| b \\|_2}$。\n3. 2-范数条件数 $\\kappa_2(T_n(f_{\\delta,\\theta_0})) = \\|T_n(f_{\\delta,\\theta_0})\\|_2 \\cdot \\|T_n(f_{\\delta,\\theta_0})^{-1}\\|_2$。\n\n设计并运行一个参数化实验，使用以下 $(n,\\theta_0,\\delta)$ 值的测试套件，在一系列条件水平和角度上探究稳定性和准确性：\n- 测试用例 1: $(n,\\theta_0,\\delta) = (32,\\frac{\\pi}{4},10^{-2})$。\n- 测试用例 2: $(n,\\theta_0,\\delta) = (64,\\frac{\\pi}{3},10^{-6})$。\n- 测试用例 3: $(n,\\theta_0,\\delta) = (64,0.01,10^{-8})$。\n- 测试用例 4: $(n,\\theta_0,\\delta) = (16,\\pi - 0.01,10^{-9})$。\n- 测试用例 5: $(n,\\theta_0,\\delta) = (8,\\frac{\\pi}{6},10^{-12})$。\n\n为了可复现性，选择一个由下式定义的确定性非零向量 $x_{\\text{true}}$\n$$\nx_{\\text{true}}[j] = \\sin\\left(\\frac{2\\pi j}{n}\\right) + \\frac{1}{2}\\cos\\left(\\frac{4\\pi j}{n}\\right), \\quad j=0,1,\\dots,n-1,\n$$\n并将其视为嵌入在 $\\mathbb{C}^n$ 中的实向量。\n\n程序必须：\n- 为每个测试用例，根据推导出的傅里葉系数精确构建 $T_n(f_{\\delta,\\theta_0})$。\n- 从 $x_{\\text{true}}$ 计算 $b$。\n- 通过 Levinson–Durbin 递归和带主元的 Gaussian 消去法（作为 GKO 风格稳定性的代理）求解方程组。\n- 为每种方法和每个矩阵计算三个指标 $(E,R,\\kappa_2)$。\n- 生成单行输出，其中包含一个用方括号括起来的逗号分隔的结果列表。对于每个测试用例，按以下顺序输出五个浮点数：\n$$\n\\left[E_{\\text{LD}},E_{\\text{GKO}},R_{\\text{LD}},R_{\\text{GKO}},\\kappa_2\\right],\n$$\n并将这五个测试用例的数组连接成一个扁平化的列表。例如，最终输出格式必须是：\n$$\n\\left[ E_{\\text{LD}}^{(1)}, E_{\\text{GKO}}^{(1)}, R_{\\text{LD}}^{(1)}, R_{\\text{GKO}}^{(1)}, \\kappa_2^{(1)}, \\dots, E_{\\text{LD}}^{(5)}, E_{\\text{GKO}}^{(5)}, R_{\\text{LD}}^{(5)}, R_{\\text{GKO}}^{(5)}, \\kappa_2^{(5)} \\right].\n$$\n不涉及物理单位，所有角度均以弧度为单位。输出必须是严格的一行，遵循所描述的列表格式，并且数值表示为十进制浮点数。",
            "solution": "用户提供的问题是有效的。它在数值线性代数中有科学依据，特别是关于结构化线性系统。问题设定是良置的：对于 $\\delta  0$，符号 $f_{\\delta,\\theta_0}(\\theta)$ 是严格为正的，这保证了 Hermitian Toeplitz 矩阵 $T_n(f)$ 是正定的，因而是可逆的。所有的定义、参数和实验目标都得到了精确和客观的规定，构成了一个完整且无矛盾的问题陈述。\n\n### 第1步：傅里葉系数的推导与矩阵结构\n\n该问题要求从符号 $f_{\\delta,\\theta_0}(\\theta) = \\delta + 2 - 2\\cos(\\theta - \\theta_0)$ 构建一个 Hermitian Toeplitz 矩阵族 $T_n(f_{\\delta,\\theta_0})$。Toeplitz 矩阵的元素 $[T_n(f)]_{ij} = c_{i-j}$ 是符号 $f$ 的傅里葉系数。第 $k$ 个傅里葉系数 $c_k$ 定义为：\n$$\nc_k = \\frac{1}{2\\pi}\\int_0^{2\\pi} f_{\\delta,\\theta_0}(\\theta)e^{-ik\\theta}\\,d\\theta\n$$\n我们代入 $f_{\\delta,\\theta_0}(\\theta)$ 的表达式：\n$$\nc_k = \\frac{1}{2\\pi}\\int_0^{2\\pi} (\\delta + 2 - 2\\cos(\\theta - \\theta_0))e^{-ik\\theta}\\,d\\theta\n$$\n我们可以将积分分为两部分：\n1.  常数项：$\\frac{1}{2\\pi}\\int_0^{2\\pi} (\\delta + 2)e^{-ik\\theta}\\,d\\theta$。当 $k=0$ 时，该积分计算结果为 $\\delta + 2$；当 $k \\ne 0$ 时，结果为 $0$。\n2.  余弦项：我们使用欧拉公式 $\\cos(x) = \\frac{e^{ix} + e^{-ix}}{2}$，将 $-2\\cos(\\theta - \\theta_0)$ 写为 $-e^{i(\\theta - \\theta_0)} - e^{-i(\\theta - \\theta_0)} = -e^{-i\\theta_0}e^{i\\theta} - e^{i\\theta_0}e^{-i\\theta}$。\n    积分变为：\n    $$\n    -\\frac{1}{2\\pi}\\int_0^{2\\pi} (e^{-i\\theta_0}e^{i\\theta} + e^{i\\theta_0}e^{-i\\theta})e^{-ik\\theta}\\,d\\theta = -\\frac{e^{-i\\theta_0}}{2\\pi}\\int_0^{2\\pi} e^{i(1-k)\\theta}\\,d\\theta - \\frac{e^{i\\theta_0}}{2\\pi}\\int_0^{2\\pi} e^{-i(1+k)\\theta}\\,d\\theta\n    $$\n    第一个积分仅在 $1-k=0$（即 $k=1$）时非零，其值为 $-e^{-i\\theta_0}$。第二个积分仅在 $1+k=0$（即 $k=-1$）时非零，其值为 $-e^{i\\theta_0}$。\n\n结合这些结果，傅里葉系数为：\n-   当 $k=0$ 时：$c_0 = \\delta + 2$。\n-   当 $k=1$ 时：$c_1 = -e^{-i\\theta_0}$。\n-   当 $k=-1$ 时：$c_{-1} = -e^{i\\theta_0}$。\n-   当 $|k| \\ge 2$ 时：$c_k = 0$。\n\nHermitian 属性 $c_{-k} = \\overline{c_k}$ 得到满足，因为 $c_{-1} = -e^{i\\theta_0} = -(\\cos\\theta_0 + i\\sin\\theta_0)$ 且 $\\overline{c_1} = \\overline{-e^{-i\\theta_0}} = -\\overline{\\cos(-\\theta_0) + i\\sin(-\\theta_0)} = -(\\cos\\theta_0 - i\\sin\\theta_0)$，这不等于 $c_{-1}$。检查：$\\overline{c_1} = \\overline{-e^{-i\\theta_0}} = -e^{i\\theta_0} = c_{-1}$。该属性得到满足。由于 $|k| \\ge 2$ 时系数 $c_k$ 为零，所得到的 $n \\times n$ 矩阵 $T_n(f_{\\delta,\\theta_0})$ 是一个 Hermitian 三对角 Toeplitz 矩阵：\n$$\nT_n = \\begin{pmatrix}\nc_0   c_{-1}   0  \\dots   0 \\\\\nc_1   c_0   c_{-1}  \\dots   0 \\\\\n0  c_1   c_0  \\ddots  \\vdots \\\\\n\\vdots    \\ddots  \\ddots  c_0  c_{-1} \\\\\n0  \\dots  0  c_1   c_0\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\delta+2  \\overline{c_1}  0  \\dots  0 \\\\\nc_1  \\delta+2  \\overline{c_1}  \\dots  0 \\\\\n0  c_1  \\delta+2  \\ddots  \\vdots \\\\\n\\vdots  \\ddots  \\ddots  \\delta+2  \\overline{c_1} \\\\\n0  \\dots  0  c_1  \\delta+2\n\\end{pmatrix}\n$$\n其中 $c_1 = -e^{-i\\theta_0}$。\n\n### 第2步：算法设计与实验设置\n\n该实验比较了两种求解线性系统 $T_n x = b$ 的算法。定义了向量 $x_{\\text{true}}$，并计算右端项 $b = T_n x_{\\text{true}}$ 以建立用于准确性分析的基准真相。\n\n1.  **Levinson–Durbin 递归**：这是一种用于求解具有 Toeplitz 矩阵结构的线性系统的快速算法，复杂度为 $O(n^2)$。对于由其第一列 $c = [c_0, c_1, \\dots, c_{n-1}]^T$ 定义的 Hermitian Toeplitz 矩阵，该算法迭代地构建解。它对于正定矩阵是数值稳定的。然而，随着 $\\delta \\to 0$，$T_n$ 变得病态，算法的准确性可能由于没有主元机制而因舍入误差的传播而降低。将使用标准实现，例如 `scipy.linalg.solve_toeplitz`。\n\n2.  **GKO 风格的带主元方法（代理）**：Gohberg–Kailath–Olshevsky (GKO) 算法是一种用于结构化矩阵的快速 $O(n^2)$ 求解器，可以引入主元选择以实现数值稳定性。主元选择会破坏矩阵结构，使得算法变得显著更复杂。作为稳定、带主元的快速求解器的代理，该问题指定在密集矩阵上使用经典的部分主元 Gaussian 消去法 (GEPP)。虽然其复杂度较高，为 $O(n^3)$，但它可作为数值稳定性的基线，用于与非主元的 Levinson-Durbin 方法进行比较。GEPP 是用于一般稠密线性系统的标准稳健算法，并在诸如 `numpy.linalg.solve` 的例程中实现。\n\n### 第3步：评估指标\n\n每种方法的性能由三个指标量化：\n\n1.  **相对解误差 ($E$)**：衡量计算解 $\\hat{x}$ 与已知真解 $x_{\\text{true}}$ 的接近程度。\n    $$\n    E = \\frac{\\| \\hat{x} - x_{\\text{true}} \\|_2}{\\| x_{\\text{true}} \\|_2}\n    $$\n2.  **相对残差范数 ($R$)**：衡量计算解满足原始方程的程度。小残差表示 $\\hat{x}$ 是一个邻近问题 $T_n x = b + \\Delta b$ 的精确解。\n    $$\n    R = \\frac{\\| b - T_n \\hat{x} \\|_2}{\\| b \\|_2}\n    $$\n3.  **2-范数条件数 ($\\kappa_2$)**：矩阵 $T_n$ 的一个内在属性，它界定了输入数据（包括 $T_n$ 和 $b$）中的误差到输出解 $x$ 的放大程度。大的条件数表示一个病态问题，其中小的输入扰动可能导致解的巨大变化。\n    $$\n    \\kappa_2(T_n) = \\|T_n\\|_2 \\cdot \\|T_n^{-1}\\|_2\n    $$\n    对于给定的方法，我们期望存在近似关系 $E \\lesssim \\kappa_2(T_n) (R + \\epsilon_{\\text{mach}})$，其中 $\\epsilon_{\\text{mach}}$ 是机器精度。\n\n该实验系统地改变参数 $(n, \\theta_0, \\delta)$，以观察矩阵大小、符号近零点的位置以及接近奇异性的程度如何影响稳定性和准确性。随着 $\\delta$ 趋近于 $0$，$\\kappa_2(T_n)$ 预计会变得很大，这对求解器的数值稳定性提出了挑战。期望是 GEPP 代理由于其主元策略，在严重病态的情况下能比非主元的 Levinson-Durbin 递归保持更好的准确性（更小的 $E$）。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import toeplitz, solve_toeplitz\n\ndef solve():\n    \"\"\"\n    Designs and runs a parameterized experiment to compare the numerical stability\n    of Levinson-Durbin recursion and a GKO-style pivoted approach (proxied by GEPP)\n    for solving ill-conditioned Hermitian Toeplitz linear systems.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (32, np.pi/4, 1e-2),\n        (64, np.pi/3, 1e-6),\n        (64, 0.01, 1e-8),\n        (16, np.pi - 0.01, 1e-9),\n        (8, np.pi/6, 1e-12),\n    ]\n\n    results = []\n    for n, theta0, delta in test_cases:\n        # Step 1: Construct the Hermitian Toeplitz matrix T_n\n        \n        # Derive the Fourier coefficients c_k from the symbol.\n        # c_0 = delta + 2\n        # c_1 = -exp(-i*theta0)\n        # c_k = 0 for |k| >= 2\n        c0 = delta + 2.0\n        c1 = -np.exp(-1j * theta0)\n        \n        # The first column of the Toeplitz matrix\n        c_col = np.zeros(n, dtype=np.complex128)\n        c_col[0] = c0\n        if n > 1:\n            c_col[1] = c1\n\n        # The first row of the Hermitian Toeplitz matrix.\n        # r_k = c_{-k} = conjugate(c_k)\n        r_row = np.conjugate(c_col)\n\n        # Construct the dense matrix T_n.\n        # This is a tridiagonal Hermitian Toeplitz matrix.\n        T = toeplitz(c_col, r_row)\n\n        # Step 2: Define the true solution x_true and compute the RHS b\n        j = np.arange(n)\n        x_true = np.sin(2 * np.pi * j / n) + 0.5 * np.cos(4 * np.pi * j / n)\n        x_true = x_true.astype(np.complex128) # Treat as complex vector\n        \n        b = T @ x_true\n        \n        # Step 3: Solve the system T*x = b using both methods.\n        \n        # Method 1: Levinson-Durbin recursion\n        # scipy.linalg.solve_toeplitz uses Levinson-Durbin for Hermitian matrices.\n        # It takes the first column `c_col` as input.\n        x_ld = solve_toeplitz(c_col, b)\n        \n        # Method 2: GKO-style proxy (Gaussian Elimination with Partial Pivoting)\n        # numpy.linalg.solve uses LAPACK's gesv, which implements GEPP.\n        x_gko = np.linalg.solve(T, b)\n\n        # Step 4: Compute the evaluation metrics\n        \n        # Norms for relative error and residual calculations\n        norm_xtrue = np.linalg.norm(x_true, 2)\n        norm_b = np.linalg.norm(b, 2)\n\n        # Relative solution error E\n        E_ld = np.linalg.norm(x_ld - x_true, 2) / norm_xtrue if norm_xtrue > 0 else 0.0\n        E_gko = np.linalg.norm(x_gko - x_true, 2) / norm_xtrue if norm_xtrue > 0 else 0.0\n\n        # Relative residual norm R\n        R_ld = np.linalg.norm(b - T @ x_ld, 2) / norm_b if norm_b > 0 else 0.0\n        R_gko = np.linalg.norm(b - T @ x_gko, 2) / norm_b if norm_b > 0 else 0.0\n\n        # 2-norm condition number kappa_2\n        kappa2 = np.linalg.cond(T, p=2)\n\n        results.extend([E_ld, E_gko, R_ld, R_gko, kappa2])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{v:.15e}' for v in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "“快速求解器”的最终目标无疑是追求极致的速度，但理论上的计算复杂度（例如，$O(n \\log n)$）并不能完全反映在现代硬件上的真实性能。本实践将引导你从理论走向现实，通过构建一个性能模型来量化分析关键硬件限制（如内存带宽和缓存大小）对算法速度的影响。你将亲身体会到，不同的算法实现细节（例如，选用不同的FFT算法）将如何在实际中导致显著的性能差异，从而更深刻地理解高性能计算的精髓 ()。",
            "id": "3545756",
            "problem": "一项性能建模任务的目标是量化用于Toeplitz系统的快速求解器的性能。该求解器利用快速傅里叶变换 (FFT) 通过循环嵌入来加速Toeplitz矩阵向量乘法 (MVM)。任务是量化当使用分裂基FFT与基-$2$ Cooley–Tukey FFT时，预测的端到端求解器加速比，并通过一个简单的roofline-style模型，明确地阐明在现代中央处理器 (CPU) 上，缓存可容纳或缓存不可容纳的状态如何改变这些加速比。\n\n需要实现一个程序，用以计算一个Krylov子空间求解器的预测端到端运行时间。该求解器使用 $k$ 次迭代，其中每次迭代主要由一个使用FFT计算的Toeplitz MVM和标准的向量运算主导。假设Toeplitz矩阵在迭代过程中固定不变且为厄米特正定矩阵，因此适用共轭梯度法（Conjugate Gradient）。将在相同的求解器结构内比较两种FFT的实现：\n- 一种基-$2$ Cooley–Tukey FFT（记为 $\\mathrm{CT}$），\n- 一种分裂基 FFT（记为 $\\mathrm{SR}$）。\n\n必须使用以下基本且经过充分检验的数学事实作为基础：\n- 一个大小为 $n$ 的 Toeplitz MVM 可通过嵌入到一个长度为 $m \\ge 2n-1$ 的循环卷积中，并利用 FFT 来计算该卷积。为提高计算效率，使用 2 的幂次作为嵌入长度 $L = 2^{\\lceil \\log_2(2n-1) \\rceil}$。\n- 对于一个具有固定核的 Toeplitz MVM，需要对长度为 $L$ 的核进行一次性的 FFT 预计算。随后的每次 MVM 需要对长度为 $L$ 的填充输入进行一次正向 FFT，一次长度为 $L$ 的逐元素复数乘法，以及一次长度为 $L$ 的逆向 FFT。\n- 在双精度复数算术中，每个复数占用 $16$ 字节。\n- 采用 roofline-style 性能模型：对于任何总浮点运算 (FLOP) 次数为 $F$、总内存流量为 $M$ 字节的操作，在峰值浮点速率为 $P$ FLOP/s、持续内存带宽为 $B$ 字节/秒的 CPU 上，其时间被建模为计算时间和内存时间的最大值：\n$$\nT = \\max\\left(\\frac{F}{P}, \\frac{M}{B}\\right).\n$$\n\n按如下方式对运算次数和内存流量进行建模。\n\n1) FFT 算术功。对于长度为 $L$ 的复数 FFT：\n- 基-$2$ Cooley–Tukey 模型：FLOPs $F_{\\mathrm{CT}}(L) = c_{\\mathrm{CT}}\\, L \\log_2 L$，其中 $c_{\\mathrm{CT}} = 10$。\n- 分裂基模型：FLOPs $F_{\\mathrm{SR}}(L) = c_{\\mathrm{SR}}\\, L \\log_2 L$，其中 $c_{\\mathrm{SR}} = 9$。\n\n2) FFT 内存流量。对于在容量为 $C$ 字节的缓存上执行的长度为 $L$ 的复数 FFT：\n- 如果工作集可被缓存容纳，即 $16L \\le C$，则假设每次 FFT 有两次完整的数组扫描，因此 $M_{\\mathrm{fit}}(L) = 2 \\cdot 16 L$ 字节。\n- 如果无法容纳，则假设每层有依赖于算法的流式传输遍数：\n$$\nM_{\\mathrm{CT,miss}}(L) = \\rho_{\\mathrm{CT}} \\cdot 16 L \\log_2 L,\\quad \\rho_{\\mathrm{CT}} = 2.0,\n$$\n$$\nM_{\\mathrm{SR,miss}}(L) = \\rho_{\\mathrm{SR}} \\cdot 16 L \\log_2 L,\\quad \\rho_{\\mathrm{SR}} = 1.7.\n$$\n如果 $16L \\le C$，则使用 $M_{\\mathrm{FFT}}(L) = M_{\\mathrm{fit}}(L)$，否则使用 $M_{\\mathrm{FFT}}(L) = M_{\\mathrm{algo,miss}}(L)$。\n\n3) 用于卷积的逐元素复数乘法。对于长度 $L$，假设 $F_{\\times}(L) = 6L$ FLOPs 和内存 $M_{\\times}(L) = 3 \\cdot 16 L$ 字节（读取两个输入，写入一个输出）。\n\n4) 每次共轭梯度迭代中作用于长度为 $n$ 的向量的向量运算：\n- 两次点积，每次建模为 $F_{\\mathrm{dot}}(n) = 8n$ FLOPs 和 $M_{\\mathrm{dot}}(n) = 2 \\cdot 16 n$ 字节。\n- 三次 AXPY 运算 $z \\leftarrow \\alpha x + y$（其中 $\\alpha$ 为复数），每次建模为 $F_{\\mathrm{axpy}}(n) = 8n$ FLOPs 和 $M_{\\mathrm{axpy}}(n) = 3 \\cdot 16 n$ 字节。\n对于向量运算，内存流量按上述方式建模，不考虑 $C$；这些是流式向量核。\n\n给定 $n$、$k$、$P$、$B$ 和 $C$：\n- 计算 $L = 2^{\\lceil \\log_2(2n-1) \\rceil}$。\n- 预计算时间：对长度为 $L$ 的核进行一次 FFT。\n- Toeplitz MVM 的每次迭代时间：一次长度为 $L$ 的正向 FFT，一次长度为 $L$ 的逐元素复数乘法，以及一次长度为 $L$ 的逆向 FFT。\n- 向量运算的每次迭代时间：两次点积和三次在长度为 $n$ 的向量上的 AXPY 运算。\n- 算法 $\\mathrm{algo} \\in \\{\\mathrm{CT}, \\mathrm{SR}\\}$ 的总端到端时间：\n$$\nT_{\\mathrm{algo}} = T_{\\mathrm{FFT,pre}}^{(\\mathrm{algo})}(L) + k \\left( T_{\\mathrm{FFT,fwd}}^{(\\mathrm{algo})}(L) + T_{\\times}(L) + T_{\\mathrm{FFT,inv}}^{(\\mathrm{algo})}(L) + 2T_{\\mathrm{dot}}(n) + 3T_{\\mathrm{axpy}}(n) \\right),\n$$\n其中，每个分量的时间根据该分量和算法的相应 $F$ 和 $M$ 模型计算为 $T=\\max(F/P, M/B)$。\n\n对于每个测试用例，程序必须输出预测的加速比\n$$\nS = \\frac{T_{\\mathrm{CT}}}{T_{\\mathrm{SR}}},\n$$\n该值表示为一个浮点数，四舍五入到小数点后六位，不带单位。\n\n测试套件。请精确使用以下四个测试用例，每个用例为一个元组 $(n,k,P,B,C)$：\n- 案例 1（小规模，缓存可容纳，中等带宽）：$(n,k,P,B,C) = (4096,\\,100,\\,3\\times 10^{11},\\,1\\times 10^{11},\\,32\\times 10^{6})$。\n- 案例 2（小规模，缓存可容纳，高带宽）：$(n,k,P,B,C) = (4096,\\,100,\\,3\\times 10^{11},\\,4\\times 10^{11},\\,32\\times 10^{6})$。\n- 案例 3（大规模，缓存不可容纳，中等带宽）：$(n,k,P,B,C) = (10^{6},\\,30,\\,3\\times 10^{11},\\,1\\times 10^{11},\\,32\\times 10^{6})$。\n- 案例 4（边界规模，在较小缓存下不可容纳）：$(n,k,P,B,C) = (524288,\\,20,\\,3\\times 10^{11},\\,1\\times 10^{11},\\,16\\times 10^{6})$。\n\n最终输出格式。程序应该生成单行输出，其中包含按测试套件顺序排列的四个加速比，形式为用方括号括起来的逗号分隔列表，每个加速比四舍五入到小数点后六位。例如，格式必须如下所示：\"[1.000000,1.123456,1.234567,1.345678]\"。",
            "solution": "用户提供的问题被评估为有效。它在数值线性代数和高性能计算原理方面有科学依据，问题阐述清晰，定义和参数集完整一致，并且陈述客观。因此，提供一个解决方案。\n\n目标是计算加速比 $S = T_{\\mathrm{CT}} / T_{\\mathrm{SR}}$，其中 $T_{\\mathrm{CT}}$ 和 $T_{\\mathrm{SR}}$ 分别是使用基-2 Cooley-Tukey (CT) 和分裂基 (SR) FFT 算法的共轭梯度求解器的总执行时间。该解决方案是通过系统地应用所提供的性能模型推导出来的。\n\n首先，对于给定的问题规模 $n$，确定循环嵌入所需的 FFT 长度 $L$。一个大小为 $n$ 的 Toeplitz MVM 被嵌入到一个长度至少为 $2n-1$ 的循环卷积中。为了获得最佳的 FFT 性能，它被填充到下一个 2 的幂：\n$$\nL = 2^{\\lceil \\log_2(2n-1) \\rceil}\n$$\n$\\log_2 L$ 的值就是指数 $\\lceil \\log_2(2n-1) \\rceil$。\n\n接下来，我们使用指定的 roofline 模型为每个基本操作建立时间成本：$T = \\max(F/P, M/B)$，其中 $F$ 是浮点运算次数，$M$ 是以字节为单位的内存流量，$P$ 是峰值浮点速率，$B$ 是内存带宽。\n\n我们计算求解器中涉及的五个基本操作中每个操作的时间：\n\n1.  **FFT 时间 ($T_{\\mathrm{FFT}}$)**：成本取决于算法（$\\mathrm{CT}$ 或 $\\mathrm{SR}$）。对于长度为 $L$ 的 FFT，FLOP 计数为：\n    - $F_{\\mathrm{CT}}(L) = c_{\\mathrm{CT}}\\, L \\log_2 L$，其中 $c_{\\mathrm{CT}} = 10$。\n    - $F_{\\mathrm{SR}}(L) = c_{\\mathrm{SR}}\\, L \\log_2 L$，其中 $c_{\\mathrm{SR}} = 9$。\n    内存流量 $M_{\\mathrm{FFT}}(L)$ 取决于大小为 $16L$ 字节的工作集是否能装入容量为 $C$ 的缓存中。\n    - 如果 $16L \\le C$（缓存可容纳），两种算法的 $M_{\\mathrm{fit}}(L) = 2 \\cdot 16 L = 32L$。\n    - 如果 $16L  C$（缓存不可容纳），流量是依赖于算法的：\n      - $M_{\\mathrm{CT,miss}}(L) = \\rho_{\\mathrm{CT}} \\cdot 16 L \\log_2 L$，其中 $\\rho_{\\mathrm{CT}} = 2.0$。\n      - $M_{\\mathrm{SR,miss}}(L) = \\rho_{\\mathrm{SR}} \\cdot 16 L \\log_2 L$，其中 $\\rho_{\\mathrm{SR}} = 1.7$。\n    对于给定的算法 $\\mathrm{algo} \\in \\{\\mathrm{CT}, \\mathrm{SR}\\}$，FFT 时间为：\n    $$\n    T_{\\mathrm{FFT}}^{(\\mathrm{algo})}(L) = \\max\\left(\\frac{F_{\\mathrm{algo}}(L)}{P}, \\frac{M_{\\mathrm{FFT}}^{(\\mathrm{algo})}(L)}{B}\\right)\n    $$\n\n2.  **逐元素乘法时间 ($T_{\\times}$)**：对于长度为 $L$ 的向量上的卷积步骤，FLOP 计数为 $F_{\\times}(L) = 6L$，内存流量为 $M_{\\times}(L) = 3 \\cdot 16 L = 48L$。时间为：\n    $$\n    T_{\\times}(L) = \\max\\left(\\frac{6L}{P}, \\frac{48L}{B}\\right)\n    $$\n\n3.  **点积时间 ($T_{\\mathrm{dot}}$)**：对于长度为 $n$ 的向量，FLOP 计数为 $F_{\\mathrm{dot}}(n) = 8n$，内存流量为 $M_{\\mathrm{dot}}(n) = 2 \\cdot 16 n = 32n$。时间为：\n    $$\n    T_{\\mathrm{dot}}(n) = \\max\\left(\\frac{8n}{P}, \\frac{32n}{B}\\right)\n    $$\n\n4.  **AXPY 时间 ($T_{\\mathrm{axpy}}$)**：对于长度为 $n$ 的向量，FLOP 计数为 $F_{\\mathrm{axpy}}(n) = 8n$，内存流量为 $M_{\\mathrm{axpy}}(n) = 3 \\cdot 16 n = 48n$。时间为：\n    $$\n    T_{\\mathrm{axpy}}(n) = \\max\\left(\\frac{8n}{P}, \\frac{48n}{B}\\right)\n    $$\n\n每种算法的总端到端时间是预计算时间与 $k$ 次迭代时间的总和。预计算包括对 Toeplitz 核的一次 FFT。每次迭代涉及一次 Toeplitz MVM（两次 FFT 和一次逐元素乘法）和向量运算（两次点积和三次 AXPY）。逆向 FFT 的成本模型与正向 FFT 的成本模型相同。\n\n算法 $\\mathrm{algo} \\in \\{\\mathrm{CT}, \\mathrm{SR}\\}$ 的总时间是：\n$$\nT_{\\mathrm{algo}} = T_{\\mathrm{FFT,pre}}^{(\\mathrm{algo})}(L) + k \\cdot \\left( T_{\\mathrm{FFT,fwd}}^{(\\mathrm{algo})}(L) + T_{\\mathrm{FFT,inv}}^{(\\mathrm{algo})}(L) + T_{\\times}(L) + 2 \\cdot T_{\\mathrm{dot}}(n) + 3 \\cdot T_{\\mathrm{axpy}}(n) \\right)\n$$\n这可以简化为：\n$$\nT_{\\mathrm{algo}} = (1 + 2k) \\cdot T_{\\mathrm{FFT}}^{(\\mathrm{algo})}(L) + k \\cdot \\left( T_{\\times}(L) + 2 \\cdot T_{\\mathrm{dot}}(n) + 3 \\cdot T_{\\mathrm{axpy}}(n) \\right)\n$$\n\n对每个测试用例 $(n, k, P, B, C)$ 的过程是，首先使用上述公式和相应的参数计算 $T_{\\mathrm{CT}}$ 和 $T_{\\mathrm{SR}}$。然后将最终的加速比计算为比率 $S = T_{\\mathrm{CT}} / T_{\\mathrm{SR}}$。每个案例的最终结果四舍五入到小数点后六位。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to calculate and print the speedup factors for the given test cases.\n    \"\"\"\n    # Test suite: each element is a tuple (n, k, P, B, C)\n    test_cases = [\n        # Case 1 (small, cache-fitting, moderate bandwidth)\n        (4096, 100, 3e11, 1e11, 32e6),\n        # Case 2 (small, cache-fitting, high bandwidth)\n        (4096, 100, 3e11, 4e11, 32e6),\n        # Case 3 (large, non-fitting, moderate bandwidth)\n        (1e6, 30, 3e11, 1e11, 32e6),\n        # Case 4 (boundary-scale, non-fitting under smaller cache)\n        (524288, 20, 3e11, 1e11, 16e6),\n    ]\n\n    # Algorithm-specific parameters\n    # Radix-2 Cooley-Tukey (CT)\n    params_ct = {'c_fft': 10.0, 'rho_fft': 2.0}\n    # Split-Radix (SR)\n    params_sr = {'c_fft': 9.0, 'rho_fft': 1.7}\n\n    results = []\n\n    for n, k, P, B, C in test_cases:\n        # Cast n to int if it's float from scientific notation 1e6\n        n = int(n)\n        \n        # Calculate total time for CT algorithm\n        t_ct = calculate_total_time(n, k, P, B, C, params_ct)\n\n        # Calculate total time for SR algorithm\n        t_sr = calculate_total_time(n, k, P, B, C, params_sr)\n\n        # Compute speedup and round to 6 decimal places\n        speedup = t_ct / t_sr\n        results.append(f\"{speedup:.6f}\")\n\n    # Print the results in the required format\n    print(f\"[{','.join(results)}]\")\n\ndef get_op_time(F, M, P, B):\n    \"\"\"\n    Computes the time for an operation using the roofline model.\n    T = max(time_compute, time_memory)\n    \"\"\"\n    time_compute = F / P\n    time_memory = M / B\n    return max(time_compute, time_memory)\n\ndef calculate_total_time(n, k, P, B, C, algo_params):\n    \"\"\"\n    Calculates the total end-to-end time for a given algorithm configuration.\n    \"\"\"\n    # 1. Calculate FFT length L\n    # Ensure 2*n-1 is at least 1 for log2\n    m_val = max(1, 2 * n - 1)\n    log2L = np.ceil(np.log2(m_val))\n    L = 1  int(log2L)\n\n    # Convert log2L to float for multiplication\n    log2L_float = float(log2L)\n\n    # 2. Calculate time for each elementary operation\n    \n    # FFT time T_fft\n    c_fft = algo_params['c_fft']\n    rho_fft = algo_params['rho_fft']\n    bytes_per_complex = 16\n\n    F_fft = c_fft * L * log2L_float\n    \n    # Check cache-fit condition\n    if bytes_per_complex * L = C:\n        # Cache-fit\n        M_fft = 2.0 * bytes_per_complex * L\n    else:\n        # Cache-miss\n        M_fft = rho_fft * bytes_per_complex * L * log2L_float\n        \n    T_fft = get_op_time(F_fft, M_fft, P, B)\n\n    # Elementwise multiplication time T_mul\n    F_mul = 6.0 * L\n    M_mul = 3.0 * bytes_per_complex * L\n    T_mul = get_op_time(F_mul, M_mul, P, B)\n\n    # Dot product time T_dot\n    F_dot = 8.0 * n\n    M_dot = 2.0 * bytes_per_complex * n\n    T_dot = get_op_time(F_dot, M_dot, P, B)\n    \n    # AXPY time T_axpy\n    F_axpy = 8.0 * n\n    M_axpy = 3.0 * bytes_per_complex * n\n    T_axpy = get_op_time(F_axpy, M_axpy, P, B)\n    \n    # 3. Aggregate total time\n    # T_total = T_precompute + k * T_iteration\n    # T_precompute = 1 * T_fft\n    # T_iteration = (2 * T_fft + T_mul) + (2 * T_dot + 3 * T_axpy)\n    total_time = (1 + 2 * k) * T_fft + k * (T_mul + 2 * T_dot + 3 * T_axpy)\n\n    return total_time\n\n# Execute the solver\nsolve()\n```"
        }
    ]
}