{
    "hands_on_practices": [
        {
            "introduction": "本练习旨在通过一个具体的、小规模的矩阵，让您亲手实践Sturm序列的核心思想。通过逐步计算在特定位移点$\\lambda$处多项式序列$\\{p_k(\\lambda)\\}$的符号，您将直接体验符号变化次数如何对应于小于该位移的特征值数量。掌握这种基础计算是理解和实现更复杂算法的第一步。",
            "id": "3582435",
            "problem": "考虑由下式给出的实对称三对角矩阵$A \\in \\mathbb{R}^{4 \\times 4}$\n$$\nA \\;=\\;\n\\begin{pmatrix}\n4   1  0  0 \\\\\n1   2  1  0 \\\\\n0   1  2  1 \\\\\n0   0  1  3\n\\end{pmatrix}.\n$$\n对于$\\lambda \\in \\mathbb{R}$，令$p_k(\\lambda)$表示$A - \\lambda I$的$k \\times k$阶主子式的行列式，并约定$p_0(\\lambda) = 1$。定义两个位移$\\lambda_1 = \\tfrac{3}{2}$和$\\lambda_2 = \\tfrac{5}{2}$，其中$\\lambda_1  \\lambda_2$。仅使用Sturm序列的基本定义及其在实对称矩阵特征值计数中的作用，评估当$k = 0, 1, 2, 3, 4$时$p_k(\\lambda_1)$和$p_k(\\lambda_2)$的符号，确定$A$的严格小于$\\lambda_1$和$\\lambda_2$的特征值数量$\\nu(\\lambda_1)$和$\\nu(\\lambda_2)$，并将差值$\\nu(\\lambda_2) - \\nu(\\lambda_1)$解释为$A$在半开区间$(\\lambda_1, \\lambda_2]$内的特征值数量。请以精确整数形式给出$(\\lambda_1,\\lambda_2]$内的特征值数量（无需四舍五入）。",
            "solution": "本题要求使用Sturm序列的性质来计算给定$4 \\times 4$实对称三对角矩阵在特定区间内的特征值数量。\n\n对于一个实对称三对角矩阵$A$，其严格小于给定值$\\lambda$的特征值数量，记为$\\nu(\\lambda)$，等于序列$\\{p_0(\\lambda), p_1(\\lambda), \\dots, p_n(\\lambda)\\}$中的符号变化次数，其中$p_k(\\lambda) = \\det(A_k - \\lambda I_k)$。如果任意$p_k(\\lambda) = 0$，在计数时通常将其符号视为与$p_{k-1}(\\lambda)$的符号相反。\n\n给定的矩阵为$A = \\begin{pmatrix} d_1  e_1  0  0 \\\\ e_1  d_2  e_2  0 \\\\ 0  e_2  d_3  e_3 \\\\ 0  0  e_3  d_4 \\end{pmatrix}$，其中$d_1=4$，$d_2=2$，$d_3=2$，$d_4=3$，且$e_1=e_2=e_3=1$。多项式$p_k(\\lambda)$满足三项递推关系：\n对于$k \\ge 2$，$p_k(\\lambda) = (d_k - \\lambda) p_{k-1}(\\lambda) - e_{k-1}^2 p_{k-2}(\\lambda)$。\n\n多项式序列定义如下：\n$p_0(\\lambda) = 1$\n$p_1(\\lambda) = d_1 - \\lambda = 4 - \\lambda$\n对于$k=2,3,4$，我们使用递推关系，其中对所有$k$都有$e_k=1$：$p_k(\\lambda) = (d_k - \\lambda) p_{k-1}(\\lambda) - p_{k-2}(\\lambda)$。\n\n$p_2(\\lambda) = (d_2 - \\lambda)p_1(\\lambda) - p_0(\\lambda) = (2 - \\lambda)(4 - \\lambda) - 1 = \\lambda^2 - 6\\lambda + 8 - 1 = \\lambda^2 - 6\\lambda + 7$\n\n$p_3(\\lambda) = (d_3 - \\lambda)p_2(\\lambda) - p_1(\\lambda) = (2 - \\lambda)(\\lambda^2 - 6\\lambda + 7) - (4 - \\lambda) = (2\\lambda^2 - 12\\lambda + 14 - \\lambda^3 + 6\\lambda^2 - 7\\lambda) - (4 - \\lambda) = -\\lambda^3 + 8\\lambda^2 - 19\\lambda + 14 - 4 + \\lambda = -\\lambda^3 + 8\\lambda^2 - 18\\lambda + 10$\n\n$p_4(\\lambda) = (d_4 - \\lambda)p_3(\\lambda) - p_2(\\lambda) = (3 - \\lambda)(-\\lambda^3 + 8\\lambda^2 - 18\\lambda + 10) - (\\lambda^2 - 6\\lambda + 7) = (-3\\lambda^3 + 24\\lambda^2 - 54\\lambda + 30 + \\lambda^4 - 8\\lambda^3 + 18\\lambda^2 - 10\\lambda) - (\\lambda^2 - 6\\lambda + 7) = \\lambda^4 - 11\\lambda^3 + 42\\lambda^2 - 64\\lambda + 30 - \\lambda^2 + 6\\lambda - 7 = \\lambda^4 - 11\\lambda^3 + 41\\lambda^2 - 58\\lambda + 23$\n\n现在，我们在这两个给定的位移点$\\lambda_1 = \\frac{3}{2}$和$\\lambda_2 = \\frac{5}{2}$处计算此序列的值。\n\n**在$\\lambda_1 = \\frac{3}{2}$处的计算：**\n$p_0(\\frac{3}{2}) = 1$\n$p_1(\\frac{3}{2}) = 4 - \\frac{3}{2} = \\frac{5}{2}$\n$p_2(\\frac{3}{2}) = (\\frac{3}{2})^2 - 6(\\frac{3}{2}) + 7 = \\frac{9}{4} - 9 + 7 = \\frac{9}{4} - 2 = \\frac{1}{4}$\n$p_3(\\frac{3}{2}) = -(\\frac{3}{2})^3 + 8(\\frac{3}{2})^2 - 18(\\frac{3}{2}) + 10 = -\\frac{27}{8} + 8(\\frac{9}{4}) - 27 + 10 = -\\frac{27}{8} + 18 - 17 = 1 - \\frac{27}{8} = -\\frac{19}{8}$\n$p_4(\\frac{3}{2}) = (\\frac{3}{2})^4 - 11(\\frac{3}{2})^3 + 41(\\frac{3}{2})^2 - 58(\\frac{3}{2}) + 23 = \\frac{81}{16} - \\frac{297}{8} + \\frac{369}{4} - 87 + 23 = \\frac{81 - 594 + 1476 - 1024}{16} = \\frac{1557 - 1618}{16} = -\\frac{61}{16}$\n\n当$k=0, 1, 2, 3, 4$时，序列$\\{p_k(\\frac{3}{2})\\}$的符号为$\\{+, +, +, -, -\\}$。\n该序列中的符号变化次数是非同号连续项的计数。在$p_2(\\frac{3}{2})$和$p_3(\\frac{3}{2})$之间有一次符号变化。\n因此，$A$的严格小于$\\frac{3}{2}$的特征值数量为$\\nu(\\lambda_1) = \\nu(\\frac{3}{2}) = 1$。\n\n**在$\\lambda_2 = \\frac{5}{2}$处的计算：**\n$p_0(\\frac{5}{2}) = 1$\n$p_1(\\frac{5}{2}) = 4 - \\frac{5}{2} = \\frac{3}{2}$\n$p_2(\\frac{5}{2}) = (\\frac{5}{2})^2 - 6(\\frac{5}{2}) + 7 = \\frac{25}{4} - 15 + 7 = \\frac{25}{4} - 8 = -\\frac{7}{4}$\n$p_3(\\frac{5}{2}) = -(\\frac{5}{2})^3 + 8(\\frac{5}{2})^2 - 18(\\frac{5}{2}) + 10 = -\\frac{125}{8} + 8(\\frac{25}{4}) - 45 + 10 = -\\frac{125}{8} + 50 - 35 = 15 - \\frac{125}{8} = \\frac{120-125}{8} = -\\frac{5}{8}$\n$p_4(\\frac{5}{2}) = (\\frac{5}{2})^4 - 11(\\frac{5}{2})^3 + 41(\\frac{5}{2})^2 - 58(\\frac{5}{2}) + 23 = \\frac{625}{16} - \\frac{1375}{8} + \\frac{1025}{4} - 145 + 23 = \\frac{625 - 2750 + 4100 - 1952}{16} = \\frac{4725 - 4702}{16} = \\frac{23}{16}$\n\n当$k=0, 1, 2, 3, 4$时，序列$\\{p_k(\\frac{5}{2})\\}$的符号为$\\{+, +, -, -, +\\}$。\n从$p_1(\\frac{5}{2})$到$p_2(\\frac{5}{2})$有一次符号变化，从$p_3(\\frac{5}{2})$到$p_4(\\frac{5}{2})$有另一次符号变化。\n因此，$A$的严格小于$\\frac{5}{2}$的特征值数量为$\\nu(\\lambda_2) = \\nu(\\frac{5}{2}) = 2$。\n\n**差值的解释**\n数量$\\nu(\\lambda_2) - \\nu(\\lambda_1)$计算了$A$在区间$[\\lambda_1, \\lambda_2)$内的特征值数量。由于$p_4(\\lambda) = \\det(A - \\lambda I)$，$p_4(\\lambda)$的根是$A$的特征值。因为$p_4(\\lambda_1) = -\\frac{61}{16} \\neq 0$且$p_4(\\lambda_2) = \\frac{23}{16} \\neq 0$，所以$\\lambda_1$和$\\lambda_2$都不是$A$的特征值。因此，半开区间$(\\lambda_1, \\lambda_2]$内的特征值数量与开区间$(\\lambda_1, \\lambda_2)$内的特征值数量相同，均由$\\nu(\\lambda_2) - \\nu(\\lambda_1)$给出。\n\n$(\\lambda_1, \\lambda_2] = (\\frac{3}{2}, \\frac{5}{2}]$内的特征值数量为：\n$$\\nu(\\lambda_2) - \\nu(\\lambda_1) = 2 - 1 = 1$$\n因此，在区间$(\\frac{3}{2}, \\frac{5}{2}]$内，$A$恰好有一个特征值。",
            "answer": "$$\\boxed{1}$$"
        },
        {
            "introduction": "在掌握了基本的计数方法后，本练习将引导您探索特征值计算中一个常见且重要的特殊情况。当一个三对角矩阵因某个次对角线元素为零而呈现块对角结构时，其特征值问题也随之解耦。本练习将展示Sturm计数性质如何巧妙地反映这种分解，并引出“降阶”(deflation)这一关键概念，它是加速实用特征值算法的核心策略。",
            "id": "3582454",
            "problem": "考虑实对称三对角矩阵$T \\in \\mathbb{R}^{7 \\times 7}$，其对角线元素为$a_1, \\dots, a_7$，次/超对角线元素为$b_1, \\dots, b_6$，具体形式如下\n$$\nT =\n\\begin{pmatrix}\n4  1  0  0  0  0  0 \\\\\n1  -2  -1  0  0  0  0 \\\\\n0  -1  5  0  0  0  0 \\\\\n0  0  0  2  2  0  0 \\\\\n0  0  0  2  0  -1  0 \\\\\n0  0  0  0  -1  3  1 \\\\\n0  0  0  0  0  1  -1\n\\end{pmatrix},\n$$\n因此，非对角线元素$b_3 = 0$，$T$是关于$(3,4)$分割的块对角矩阵。令位移为$\\sigma = 1$。从应用于$T - \\sigma I$的实对称三对角矩阵的Sturm序列的核心定义出发，解释为什么一个为零的非对角线元素$b_k = 0$会导致小于$\\sigma$的特征值数量分解为前导和后随三对角主子块上独立计数的加和。然后，对于上述给定的$T$和$\\sigma$，计算每个块的Sturm计数，从而得到$T$的Sturm计数。最后，简要阐述在使用惯量（inertia）的特征值算法（如二分法或多重相对鲁棒表示法(MRRR)）中，如何利用这种结构分解进行缩减（deflation）。\n\n报告$T$的严格小于$\\sigma$的特征值的总数$N$。最终答案只提供$N$。",
            "solution": "本题的核心是利用Sturm序列的性质来计算一个块对角实对称三对角矩阵$T$的严格小于给定偏移$\\sigma$的特征值数量。\n\n**第一部分：加性分解原理**\n\n设$T$是一个$n \\times n$的实对称三对角矩阵，其对角线元素为$a_1, \\dots, a_n$，次/超对角线元素为$b_1, \\dots, b_{n-1}$。令$p_k(\\lambda)$为$T$的前导$k \\times k$主子矩阵的特征多项式。多项式序列$\\{p_k(\\lambda)\\}_{k=0}^n$由以下三项递推关系定义：\n$$p_k(\\lambda) = (a_k - \\lambda)p_{k-1}(\\lambda) - b_{k-1}^2 p_{k-2}(\\lambda), \\quad \\text{for } k \\ge 2$$\n初始条件为$p_0(\\lambda) = 1$和$p_1(\\lambda) = a_1 - \\lambda$。\n\n$T$的严格小于实数$\\sigma$的特征值数量，记为$N(\\sigma)$，由求值后序列$\\{p_0(\\sigma), p_1(\\sigma), \\dots, p_n(\\sigma)\\}$中的符号变化次数给出。这个序列被称为Sturm序列。\n\n现在，考虑某个次对角线元素$b_k$为零的情况，其中$k \\in \\{1, \\dots, n-1\\}$。这意味着矩阵$T$是块对角矩阵：\n$$T = \\begin{pmatrix} T_1  0 \\\\ 0  T_2 \\end{pmatrix}$$\n其中$T_1$是前导$k \\times k$主子块，$T_2$是后随$(n-k) \\times (n-k)$主子块。$T$的特征谱是$T_1$和$T_2$特征谱的并集。因此，$T$小于$\\sigma$的特征值数量必须是$T_1$和$T_2$计数之和：$N(\\sigma) = N_1(\\sigma) + N_2(\\sigma)$。\n\n我们可以在Sturm序列的框架内正式证明这一点。序列$\\{p_0(\\sigma), \\dots, p_k(\\sigma)\\}$正是块$T_1$的Sturm序列。设块$T_2$的Sturm序列（使用其自身的局部索引）为$\\{q_0(\\sigma), \\dots, q_{n-k}(\\sigma)\\}$。当$b_k=0$时，通过归纳法可以证明，对于$j=1, \\dots, n-k$：\n$$p_{k+j}(\\lambda) = q_j(\\lambda) p_k(\\lambda)$$\n因此，在$\\sigma$处求值的$T$的完整Sturm序列是：\n$$\\{ p_0(\\sigma), \\dots, p_k(\\sigma), q_1(\\sigma)p_k(\\sigma), \\dots, q_{n-k}(\\sigma)p_k(\\sigma) \\}$$\n总的符号变化次数$N(\\sigma)$是序列第一部分$\\{p_0(\\sigma), \\dots, p_k(\\sigma)\\}$（计为$N_1(\\sigma)$）和第二部分$\\{p_k(\\sigma), q_1(\\sigma)p_k(\\sigma), \\dots, q_{n-k}(\\sigma)p_k(\\sigma)\\}$中符号变化次数之和。假设$p_k(\\sigma) \\neq 0$，第二部分的符号变化次数与$\\{1, q_1(\\sigma), \\dots, q_{n-k}(\\sigma)\\}$中的符号变化次数相同，而由于$q_0(\\sigma)=1$，这恰好是$N_2(\\sigma)$。因此，$N(\\sigma) = N_1(\\sigma) + N_2(\\sigma)$，证实了加性分解。\n\n**第二部分：针对给定矩阵和位移的计算**\n\n给定的矩阵$T$因$b_3 = T_{3,4} = 0$而分裂成一个$3 \\times 3$的块$T_1$和一个$4 \\times 4$的块$T_2$。\n$$T_1 = \\begin{pmatrix} 4  1  0 \\\\ 1  -2  -1 \\\\ 0  -1  5 \\end{pmatrix}, \\quad T_2 = \\begin{pmatrix} 2  2  0  0 \\\\ 2  0  -1  0 \\\\ 0  -1  3  1 \\\\ 0  0  1  -1 \\end{pmatrix}$$\n我们需要找到$T$的严格小于位移$\\sigma = 1$的特征值数量。我们分别计算每个块的Sturm序列计数。\n\n**块$T_1$：**\n对角线元素为$a=(4, -2, 5)$，次对角线元素为$b=(1, -1)$。位移为$\\sigma=1$。\n- $p_0(1) = 1$\n- $p_1(1) = (a_1 - \\sigma) = 4 - 1 = 3$\n- $p_2(1) = (a_2 - \\sigma)p_1(1) - b_1^2 p_0(1) = (-2 - 1)(3) - (1)^2(1) = -9 - 1 = -10$\n- $p_3(1) = (a_3 - \\sigma)p_2(1) - b_2^2 p_1(1) = (5 - 1)(-10) - (-1)^2(3) = 4(-10) - 3 = -43$\n值的序列是$\\{1, 3, -10, -43\\}$，符号序列是$\\{+, +, -, -\\}$。有一个符号变化，所以$N_1(1) = 1$。\n\n**块$T_2$：**\n对角线元素为$a'=(2, 0, 3, -1)$，次对角线元素为$b'=(2, -1, 1)$。位移为$\\sigma=1$。\n- $q_0(1) = 1$\n- $q_1(1) = (a_1' - \\sigma) = 2 - 1 = 1$\n- $q_2(1) = (a_2' - \\sigma)q_1(1) - (b_1')^2 q_0(1) = (0 - 1)(1) - (2)^2(1) = -1 - 4 = -5$\n- $q_3(1) = (a_3' - \\sigma)q_2(1) - (b_2')^2 q_1(1) = (3 - 1)(-5) - (-1)^2(1) = 2(-5) - 1 = -11$\n- $q_4(1) = (a_4' - \\sigma)q_3(1) - (b_3')^2 q_2(1) = (-1 - 1)(-11) - (1)^2(-5) = (-2)(-11) + 5 = 22 + 5 = 27$\n值的序列是$\\{1, 1, -5, -11, 27\\}$，符号序列是$\\{+, +, -, -, +\\}$。有两个符号变化，所以$N_2(1) = 2$。\n\n**总计数：**\n$T$的严格小于$\\sigma=1$的特征值总数$N$是两个块的计数之和：\n$$N = N_1(1) + N_2(1) = 1 + 2 = 3$$\n\n**第三部分：利用分解进行缩减**\n\n当非对角线元素$b_k$为零时，特征值问题的这种分解被称为缩减（deflation）。像QR算法、二分法或MRRR等特征值算法利用此属性来显著提高效率。算法不是解决一个大的$n \\times n$问题，而是可以为块$T_1$（大小为$k \\times k$）和$T_2$（大小为$(n-k) \\times (n-k)$）解决两个更小的独立问题。由于许多特征值算法的复杂度与矩阵大小的三次方（如$\\mathcal{O}(n^3)$）相关，这种分解导致计算成本大幅降低到$\\mathcal{O}(k^3 + (n-k)^3)$。\n\n在使用惯量（特征值计数）的算法（如二分法和MRRR）的背景下，这种结构分解是基础性的。块对角矩阵的惯量是其各块惯量之和，我们的计算$N(\\sigma) = N_1(\\sigma)+N_2(\\sigma)$正是这一原理的直接应用。在实践中，如果迭代方法导致某个非对角线元素在数值上变得可以忽略不计，则将其设置为零，问题就被缩减，子问题则被递归解决。这是现代特征值软件实现高性能的关键策略。",
            "answer": "$$\\boxed{3}$$"
        },
        {
            "introduction": "最后的这项练习将引导您从分立的概念走向完整的算法实现。它要求您综合运用Sturm序列、格尔什戈林圆盘定理(Gershgorin's theorem)和区间二分法，从零开始构建一个稳健的特征值求解器。通过构造具有特定谱特性的矩阵，并应用您编写的算法找出其特征值，您将对这些理论工具如何融合成强大的数值方法获得深刻的实践洞见。",
            "id": "3586237",
            "problem": "构造一个完整的、可运行的程序。该程序针对一组给定的特征值簇，构建一个对称三对角矩阵$T \\in \\mathbb{R}^{n \\times n}$，使其特征值聚集在指定的中心附近，然后选择能够隔离每个簇的初始区间，以便在Sturm计数法的指导下，通过二分法将每个簇内的所有特征值细化到精度$\\varepsilon$，且时间复杂度为$\\mathcal{O}(n \\log(1/\\varepsilon))$。设计和分析必须基于数值线性代数中的以下基本原理：对称矩阵特征值的刻画、用于特征值定位的Gershgorin定理，以及对称三对角矩阵的Sturm计数性质。除这些基本要素外，不应假设任何快捷公式或提示。\n\n您必须完全以纯数学和算法术语实现以下内容：\n\n1.  给定$n$、簇中心列表$\\{c_k\\}$、簇大小列表$\\{m_k\\}$（满足$\\sum_k m_k = n$）、簇半宽列表$\\{w_k\\}$、簇内耦合的内部次对角线元素大小$s$，以及簇间耦合的边界次对角线元素大小$\\delta$，构造一个对称三对角矩阵$T$，其对角线为$d \\in \\mathbb{R}^n$，次/超对角线为$e \\in \\mathbb{R}^{n-1}$，使得$T$的特征值围绕每个$c_k$形成大小为$m_k$的簇。为了确保可复现性并避免随机性，应确定性地在$[c_k - w_k, c_k + w_k]$内为每个簇分配对角线元素，将簇内的次对角线元素设置为$s$，并将跨越簇边界的次对角线元素设置为$\\delta$。该矩阵必须是实对称三对角矩阵。\n\n2.  对每个簇$k$，选择一个初始区间$[L_k, U_k]$，保证该区间恰好包含$T$的$m_k$个特征值。使用Gershgorin型行界来获取$L_k$和$U_k$，方法是聚合属于簇$k$的所有行的区间\n$$\n[d_i - (|e_{i-1}| + |e_i|),\\; d_i + (|e_{i-1}| + |e_i|)],\n$$\n其中$e_0 = 0$且$e_n = 0$，并取左端点的最小值为$L_k$，右端点的最大值为$U_k$。您的程序必须通过Sturm计数法验证$[L_k, U_k]$是否恰好包含$m_k$个特征值；如果不包含，则必须通过适度扩展或收缩来调整$[L_k, U_k]$，直到计数值等于$m_k$，同时保持在$T$的全局Gershgorin界内。\n\n3.  实现标量$x \\in \\mathbb{R}$的$T - x I$的下三角-对角-下三角转置($LDL^\\top$)分解，并利用Sturm计数性质计算$T$中严格小于$x$的特征值数量。每次求值的计数必须在$\\mathcal{O}(n)$时间内完成。然后，实现一个区间二分程序，从已验证的簇区间$[L_k, U_k]$开始，利用计数的单调性重复分割区间以隔离每个特征值。对每个特征值达到绝对精度$\\varepsilon$，并确保总复杂度为$\\mathcal{O}(n \\log(1/\\varepsilon))$。\n\n4.  对每个测试用例，输出通过二分法找到的特征值列表，按非递减顺序排序，绝对精度至多为$\\varepsilon$。\n\n使用以下测试套件来验证您的实现。每个测试用例指定$(n, \\{c_k\\}, \\{m_k\\}, \\{w_k\\}, s, \\delta, \\varepsilon)$:\n\n-   测试用例 1: $n = 10$, $\\{c_k\\} = [0.0, 5.0]$, $\\{m_k\\} = [4, 6]$, $\\{w_k\\} = [0.2, 0.3]$, $s = 0.05$, $\\delta = 10^{-6}$, $\\varepsilon = 10^{-8}$。\n-   测试用例 2: $n = 12$, $\\{c_k\\} = [-2.0, 0.5, 3.0]$, $\\{m_k\\} = [3, 5, 4]$, $\\{w_k\\} = [0.1, 0.15, 0.2]$, $s = 0.02$, $\\delta = 10^{-8}$, $\\varepsilon = 10^{-7}$。\n-   测试用例 3 (边界情况：近简并簇): $n = 8$, $\\{c_k\\} = [1.0]$, $\\{m_k\\} = [8]$, $\\{w_k\\} = [10^{-4}]$, $s = 10^{-5}$, $\\delta = 10^{-12}$, $\\varepsilon = 10^{-10}$。\n-   测试用例 4 (极端分布): $n = 15$, $\\{c_k\\} = [-10.0, 0.0, 10.0]$, $\\{m_k\\} = [5, 5, 5]$, $\\{w_k\\} = [0.5, 0.5, 0.5]$, $s = 0.1$, $\\delta = 10^{-9}$, $\\varepsilon = 10^{-9}$。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个元素是对应测试用例的特征值（浮点数）的Python列表，并按非递减顺序排序。例如，格式必须是\n$$\n[\\,[\\lambda_{1,1}, \\dots, \\lambda_{1,n_1}],\\; [\\lambda_{2,1}, \\dots, \\lambda_{2,n_2}],\\; \\dots\\,],\n$$\n不打印任何额外文本。\n\n本问题不涉及物理单位。不出现角度。不出现百分比。所有数值公差均为绝对值，并在每个测试用例中指定为标量$\\varepsilon$。",
            "solution": "本题要求基于基本原理，实现一种用于寻找对称三对角矩阵特征值的稳健算法。解决方案将按照问题中概述的任务顺序构建：\n1.  确定性地构建具有指定特征值聚类性质的对称三对角矩阵$T$。\n2.  应用通过$LDL^\\top$分解实现的Sturm序列性质来计算特征值数量。\n3.  在源自Gershgorin定理的区间内隔离特征值簇，然后使用Sturm计数进行验证。\n4.  使用区间二分算法计算所有特征值，达到指定精度$\\varepsilon$。\n\n**1. 对称三对角矩阵的构建**\n\n一个实对称三对角矩阵$T \\in \\mathbb{R}^{n \\times n}$完全由其对角线元素$d_1, \\dots, d_n$和其次对角线元素$e_1, \\dots, e_{n-1}$定义。问题指明了如何构造$d$和$e$以创建一个特征值分组聚集的矩阵。属于簇$k$的行的对角线元素$d_i$是从区间$[c_k - w_k, c_k + w_k]$中确定性选择的。为确保可复现性，我们使用线性间距来分布这$m_k$个元素。\n$$\nd_i = (c_k - w_k) + (j-1) \\frac{2 w_k}{m_k - 1} \\quad (\\text{若 } m_k  1), \\quad \\text{或} \\quad d_i = c_k \\quad (\\text{若 } m_k = 1).\n$$\n次对角线元素$e_i$控制耦合：在簇内，$e_i = s$；在簇间边界，$e_i = \\delta$。由于$\\delta \\ll s$，完整矩阵$T$的特征值将接近于通过设置$\\delta=0$得到的块对角矩阵的特征值。\n\n**2. Sturm序列性质与特征值计数**\n\n对称三对角矩阵$T$的Sturm序列性质提供了一种计算其特征值数量的方法。对于给定的标量$x$，$T$中严格小于$x$的特征值数量$N(x)$，可以通过分析移位矩阵$T - xI = L D L^\\top$的$LDL^\\top$分解来稳定地计算。根据西尔维斯特惯性定律，$N(x)$等于对角矩阵$D$中负元素的数量。$D$的对角元素$\\delta_i$可以通过递推关系计算：\n$$\n\\begin{align*}\n\\delta_1 = d_1 - x \\\\\n\\delta_i = (d_i - x) - \\frac{e_{i-1}^2}{\\delta_{i-1}}, \\quad \\text{对于 } i=2, \\dots, n.\n\\end{align*}\n$$\n此计算需要$\\mathcal{O}(n)$次操作。\n\n**3. 初始区间选择与验证**\n\nGershgorin圆盘定理指出，$T$的每个特征值至少位于一个Gershgorin圆盘$G_i = \\{ z \\in \\mathbb{C} : |z - d_i| \\le |e_{i-1}| + |e_i| \\}$中（$e_0 = e_n = 0$）。为了找到簇$k$的初始区间，我们取属于该簇的所有行的Gershgorin区间的并集。设$I_k$为对应于簇$k$的索引集合，初始区间为：\n$$\n[L_k, U_k] = \\left[ \\min_{i \\in I_k} (d_i - R_i), \\max_{i \\in I_k} (d_i + R_i) \\right].\n$$\n我们必须使用Sturm计数法验证区间$[L_k, U_k]$是否恰好包含$m_k$个特征值，即检查$N(U_k) - N(L_k)$是否等于$m_k$。\n\n**4. 用于特征值计算的二分算法**\n\n一旦验证了一个区间$[L, U]$恰好包含$m$个特征值，我们就可以使用二分法来找到它们。一种基于堆栈的二分法是高效地找到所有$m$个特征值的方法。\n1. 初始化一个堆栈，并将初始验证过的区间$[L, U]$推入栈中。\n2. 当堆栈不为空时，弹出一个区间$[a, b]$。\n3. 如果区间宽度$b-a$小于所需精度$\\varepsilon$，则报告该区间的中点为该区间内所有特征值的近似值。\n4. 否则，将区间二等分于中点$mid$，并根据Sturm计数将包含特征值的子区间$[a, mid]$和/或$[mid, b]$推回堆栈。\n此过程持续进行，直到所有特征值都被细化到所需的精度$\\varepsilon$。\n\n**5. 复杂度分析**\n\n单次Sturm计数$N(x)$的成本为$\\mathcal{O}(n)$。二分算法将一个宽度为$W$的区间细化到宽度为$\\varepsilon$大约需要$\\log_2(W/\\varepsilon)$步。在我们的基于堆栈的方法中，二分树每一层级的总工作量为$\\mathcal{O}(n)$。因此，找到所有特征值的总复杂度为$\\mathcal{O}(n \\log_2(W/\\varepsilon))$，这简化为目标复杂度$\\mathcal{O}(n \\log(1/\\varepsilon))$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n\n    test_cases = [\n        # n, {c_k}, {m_k}, {w_k}, s, delta, eps\n        (10, [0.0, 5.0], [4, 6], [0.2, 0.3], 0.05, 1e-6, 1e-8),\n        (12, [-2.0, 0.5, 3.0], [3, 5, 4], [0.1, 0.15, 0.2], 0.02, 1e-8, 1e-7),\n        (8, [1.0], [8], [1e-4], 1e-5, 1e-12, 1e-10),\n        (15, [-10.0, 0.0, 10.0], [5, 5, 5], [0.5, 0.5, 0.5], 0.1, 1e-9, 1e-9),\n    ]\n\n    results = []\n    for case in test_cases:\n        n, c_k, m_k, w_k, s, delta, eps = case\n        eigenvalues = find_eigenvalues_for_case(n, c_k, m_k, w_k, s, delta, eps)\n        results.append(eigenvalues)\n\n    # Format the final output string exactly as required.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef build_tridiagonal_matrix(n, cluster_centers, cluster_sizes, cluster_widths, s, delta):\n    \"\"\"\n    Constructs the symmetric tridiagonal matrix T as two arrays:\n    d (diagonal) and e (sub-diagonal).\n    \"\"\"\n    d = np.zeros(n)\n    e = np.zeros(n - 1)\n    \n    current_idx = 0\n    cluster_boundaries = np.cumsum(cluster_sizes) - 1\n\n    for i in range(len(cluster_sizes)):\n        c, m, w = cluster_centers[i], cluster_sizes[i], cluster_widths[i]\n        \n        # Set diagonal elements deterministically\n        if m  1:\n            d[current_idx : current_idx + m] = np.linspace(c - w, c + w, m)\n        elif m == 1:\n            d[current_idx] = c\n            \n        # Set off-diagonal elements\n        if m  1:\n            e[current_idx : current_idx + m - 1] = s\n            \n        current_idx += m\n\n    # Set boundary off-diagonals\n    for boundary_idx in cluster_boundaries[:-1]:\n        e[boundary_idx] = delta\n        \n    return d, e\n\ndef sturm_count(x, d, e):\n    \"\"\"\n    Computes the Sturm count N(x), the number of eigenvalues of T strictly less than x.\n    This is implemented using the LDL^T factorization pivots.\n    \"\"\"\n    n = len(d)\n    count = 0\n    \n    delta_i = d[0] - x\n    if delta_i  0:\n        count += 1\n        \n    for i in range(1, n):\n        # A small perturbation to avoid division by zero.\n        if abs(delta_i) == 0.0:\n            delta_i = 1e-30 \n        \n        delta_i = (d[i] - x) - (e[i - 1]**2) / delta_i\n        if delta_i  0:\n            count += 1\n\n    return count\n\ndef find_eigenvalues_for_case(n, cluster_centers, cluster_sizes, cluster_widths, s, delta, eps):\n    \"\"\"\n    Orchestrates the entire eigenvalue computation for a single test case.\n    \"\"\"\n    d, e = build_tridiagonal_matrix(n, cluster_centers, cluster_sizes, cluster_widths, s, delta)\n    \n    all_eigenvalues = []\n    \n    cluster_start_indices = [0] + list(np.cumsum(cluster_sizes[:-1]))\n\n    for i in range(len(cluster_centers)):\n        m_k = cluster_sizes[i]\n        start_idx = cluster_start_indices[i]\n        end_idx = start_idx + m_k\n\n        # 1. Determine initial interval for the cluster using Gershgorin disks\n        L_k, U_k = 0, 0\n        for j in range(start_idx, end_idx):\n            radius = 0\n            if j  0:\n                radius += abs(e[j - 1])\n            if j  n - 1:\n                radius += abs(e[j])\n            \n            gj_min = d[j] - radius\n            gj_max = d[j] + radius\n\n            if j == start_idx:\n                L_k, U_k = gj_min, gj_max\n            else:\n                L_k = min(L_k, gj_min)\n                U_k = max(U_k, gj_max)\n        \n        # 2. Verify and adjust interval\n        max_adjust_iter = 10\n        for _ in range(max_adjust_iter):\n            count = sturm_count(U_k, d, e) - sturm_count(L_k, d, e)\n            if count == m_k:\n                break\n            elif count  m_k: # Interval too wide\n                width = U_k - L_k\n                U_k -= 0.01 * width\n                L_k += 0.01 * width\n            else: # Interval too narrow\n                width = U_k - L_k\n                U_k += 0.01 * width\n                L_k -= 0.01 * width\n        \n        # 3. Bisection to find eigenvalues in the verified interval\n        bisection_stack = [(L_k, U_k)]\n\n        while bisection_stack:\n            low, high = bisection_stack.pop()\n\n            if high - low  eps:\n                num_in_sub = sturm_count(high, d, e) - sturm_count(low, d, e)\n                if num_in_sub  0:\n                    all_eigenvalues.extend([(low + high) / 2.0] * num_in_sub)\n                continue\n\n            mid = (low + high) / 2.0\n            \n            count_at_low = sturm_count(low, d, e)\n            count_at_mid = sturm_count(mid, d, e)\n            count_at_high = sturm_count(high, d, e)\n            \n            # Sub-interval [low, mid)\n            if count_at_mid  count_at_low:\n                bisection_stack.append((low, mid))\n            \n            # Sub-interval [mid, high)\n            if count_at_high  count_at_mid:\n                bisection_stack.append((mid, high))\n\n    return sorted(all_eigenvalues)\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}