{
    "hands_on_practices": [
        {
            "introduction": "围道积分特征求解器的有效性取决于其构建滤波器的能力，该滤波器能够放大期望的本征值同时抑制不需要的本征值。本练习通过推导单位圆围道下的显式有理滤波器来探讨这一原理。通过分析此滤波器，我们可以定量地将算法的收敛率与围道和不需要的本征值之间的几何间距联系起来，从而对收敛机制建立具体的理解。",
            "id": "3541067",
            "problem": "考虑一个具有实谱的实对称（厄米）矩阵 $A \\in \\mathbb{R}^{n \\times n}$，假设目标是计算其所有特征值位于实区间 $\\left[-r, r\\right]$（其中 $r \\in (0,1)$）内的特征对。一种基于谱投影的标准围道积分特征求解器近似计算\n$$\nP = \\frac{1}{2\\pi i} \\oint_{\\Gamma} (zI - A)^{-1} \\, dz,\n$$\n其中 $\\Gamma$ 是复平面中以原点为中心、逆时针方向的单位圆，该积分通过在参数化 $z(\\theta)=\\exp(i\\theta)$（$\\theta \\in [0,2\\pi)$）上使用 $M$ 点梯形法则进行近似。由此产生的有理滤波器 $R_M(A)$ 被用作子空间迭代，将子空间 $V$ 映射到 $R_M(A)V$。在此设置下，与不期望的特征值（在 $\\Gamma$ 之外的特征值）相关的分量的渐近收缩因子的上界，是该滤波器在不期望的特征值上获得的最大标量幅值与在期望的特征值上获得的最小标量幅值之比。\n\n假设所有期望的特征值都位于 $\\left[-r, r\\right]$ 内，所有不期望的特征值都位于单位圆外，且最近的不期望特征值为 $\\lambda_{\\star} = 1 + s$，其中 $s0$。基于上述定义、单位圆参数化和 $M$ 点梯形法则，推导由求积诱导的显式标量有理滤波器，用它来界定作为 $s$、$M$ 和 $r$ 的函数的收缩因子，然后确定保证每次迭代有预定收缩因子 $q \\in (0,1)$ 的最小间距 $s_{\\min}$，即确保滤波器在不期望的特征值上的最大幅值与在期望的特征值上的最小幅值之比最多为 $q$。以 $M$、$r$ 和 $q$ 的单个闭式解析表达式给出 $s_{\\min}$ 的最终答案。无需四舍五入。",
            "solution": "问题要求解出不期望的特征值与单位圆之间的最小间距 $s_{\\min}$，以保证围道积分特征求解器具有特定的收缩率。推导过程分为三个主要步骤：首先，我们确定由数值求积诱导的标量有理滤波器 $R_M(\\lambda)$ 的显式形式；其次，我们为期望和不期望的特征值建立该滤波器幅值的界；最后，我们使用这些界来求解所需的间距 $s$。\n\n**步骤1：标量有理滤波器的推导**\n\n矩阵 $A$ 的特征值问题的谱投影 $P$ 由围道积分给出\n$$\nP = \\frac{1}{2\\pi i} \\oint_{\\Gamma} (zI - A)^{-1} \\, dz\n$$\n其中 $\\Gamma$ 是包围期望特征值的围道。该投影作用于与特征值 $\\lambda$ 对应的特征向量上的行为由标量函数所支配\n$$\np(\\lambda) = \\frac{1}{2\\pi i} \\oint_{\\Gamma} (z - \\lambda)^{-1} \\, dz\n$$\n问题指明 $\\Gamma$ 是单位圆，由 $z(\\theta) = \\exp(i\\theta)$（$\\theta \\in [0, 2\\pi)$）参数化。微分是 $dz = i\\exp(i\\theta)d\\theta$。将此代入 $p(\\lambda)$ 的积分中可得\n$$\np(\\lambda) = \\frac{1}{2\\pi i} \\int_{0}^{2\\pi} \\frac{1}{\\exp(i\\theta) - \\lambda} i\\exp(i\\theta) d\\theta = \\frac{1}{2\\pi} \\int_{0}^{2\\pi} \\frac{\\exp(i\\theta)}{\\exp(i\\theta) - \\lambda} d\\theta\n$$\n问题陈述该积分使用 $M$ 点梯形法则进行近似。区间是 $[0, 2\\pi)$，步长是 $h = \\frac{2\\pi}{M}$。求积点是 $\\theta_k = \\frac{2\\pi k}{M}$，其中 $k \\in \\{0, 1, \\dots, M-1\\}$。单位圆上的相应点是 $z_k = \\exp(i\\theta_k) = \\exp(i \\frac{2\\pi k}{M})$，即 $M$ 次单位根。\n\n定义了标量有理滤波器 $R_M(\\lambda)$ 的梯形法则近似由下式给出\n$$\nR_M(\\lambda) = \\frac{h}{2\\pi} \\sum_{k=0}^{M-1} \\frac{z_k}{z_k - \\lambda} = \\frac{1}{M} \\sum_{k=0}^{M-1} \\frac{z_k}{z_k - \\lambda}\n$$\n我们可以将和中的项重写为 $\\frac{z_k}{z_k - \\lambda} = 1 + \\frac{\\lambda}{z_k - \\lambda}$。这给出\n$$\nR_M(\\lambda) = \\frac{1}{M} \\sum_{k=0}^{M-1} \\left(1 + \\frac{\\lambda}{z_k - \\lambda}\\right) = 1 + \\frac{\\lambda}{M} \\sum_{k=0}^{M-1} \\frac{1}{z_k - \\lambda}\n$$\n该和可以使用一个相关有理函数的部分分式展开来求值。考虑多项式 $p(z) = z^M - 1$，其根是点 $z_k$。其对数导数为\n$$\n\\frac{p'(z)}{p(z)} = \\frac{Mz^{M-1}}{z^M - 1} = \\sum_{k=0}^{M-1} \\frac{1}{z - z_k}\n$$\n在 $z=\\lambda$ 处求值并整理符号，得到\n$$\n\\sum_{k=0}^{M-1} \\frac{1}{z_k - \\lambda} = - \\sum_{k=0}^{M-1} \\frac{1}{\\lambda - z_k} = - \\frac{M\\lambda^{M-1}}{\\lambda^M - 1}\n$$\n将此代回 $R_M(\\lambda)$ 的表达式中：\n$$\nR_M(\\lambda) = 1 + \\frac{\\lambda}{M} \\left( - \\frac{M\\lambda^{M-1}}{\\lambda^M - 1} \\right) = 1 - \\frac{\\lambda^M}{\\lambda^M - 1} = \\frac{(\\lambda^M - 1) - \\lambda^M}{\\lambda^M - 1} = \\frac{-1}{\\lambda^M - 1}\n$$\n因此，显式标量有理滤波器是\n$$\nR_M(\\lambda) = \\frac{1}{1 - \\lambda^M}\n$$\n\n**步骤2：界定收缩因子**\n\n渐近收缩因子由不期望的特征值上的最大滤波器幅值与期望的特征值上的最小滤波器幅值之比来界定。设此界为 $\\eta$。\n$$\n\\eta \\le \\frac{\\sup_{\\lambda_{\\text{out}}} |R_M(\\lambda_{\\text{out}})|}{\\inf_{\\lambda_{\\text{in}}} |R_M(\\lambda_{\\text{in}})|}\n$$\n特征值 $\\lambda$ 是实数。期望的特征值 $\\lambda_{\\text{in}}$ 在 $[-r, r]$ 内，其中 $r \\in (0,1)$。不期望的特征值 $\\lambda_{\\text{out}}$ 在单位圆外，最近的一个与单位圆的距离为 $s0$，即 $|\\lambda_{\\text{out}}| \\ge 1+s$。\n\n首先，我们分析分母，即期望特征值上的最小滤波器幅值：\n$$\n\\inf_{\\lambda_{\\text{in}} \\in [-r, r]} |R_M(\\lambda_{\\text{in}})| = \\inf_{\\lambda \\in [-r, r]} \\left| \\frac{1}{1 - \\lambda^M} \\right| = \\frac{1}{\\sup_{\\lambda \\in [-r, r]} |1 - \\lambda^M|}\n$$\n对于任何 $|\\lambda| \\le r$ 的实数 $\\lambda$，我们有 $|\\lambda^M| \\le r^M$。根据三角不等式， $|1 - \\lambda^M| \\le 1 + |\\lambda^M| \\le 1 + r^M$。如果 $M$ 是奇数，则此上界在 $\\lambda=-r$ 处达到。如果 $M$ 是偶数，则最大值为 $1$。为了得到一个对任何 $M$ 都有效的界，我们取滤波器分母的最坏情况（最大）值，即 $1+r^M$。因此，我们为期望特征值上的滤波器幅值建立了一个下界：\n$$\n\\inf_{\\lambda_{\\text{in}}} |R_M(\\lambda_{\\text{in}})| \\ge \\frac{1}{1 + r^M}\n$$\n接下来，我们分析分子，即不期望的特征值上的最大滤波器幅值：\n$$\n\\sup_{\\lambda_{\\text{out}}} |R_M(\\lambda_{\\text{out}})| = \\sup_{|\\lambda| \\ge 1+s, \\lambda \\in \\mathbb{R}} \\left| \\frac{1}{1 - \\lambda^M} \\right| = \\frac{1}{\\inf_{|\\lambda| \\ge 1+s, \\lambda \\in \\mathbb{R}} |1 - \\lambda^M|}\n$$\n我们需要找到 $|1 - \\lambda^M|$ 在实数 $\\lambda$（满足 $\\lambda \\ge 1+s$ 或 $\\lambda \\le -(1+s)$）上的最小值。\n- 如果 $\\lambda \\ge 1+s$，则 $\\lambda^M \\ge (1+s)^M  1$。函数 $|1 - \\lambda^M| = \\lambda^M - 1$ 是单调递增的。它在这个域上的最小值在 $\\lambda = 1+s$ 处取得，值为 $(1+s)^M - 1$。\n- 如果 $\\lambda \\le -(1+s)$，设 $\\lambda = -x$，其中 $x \\ge 1+s$。函数为 $|1 - (-x)^M|$。\n  - 如果 $M$ 是偶数：$|1 - x^M| = x^M - 1$。最小值在 $x=1+s$ 处取得，值为 $(1+s)^M - 1$。\n  - 如果 $M$ 是奇数：$|1 + x^M| = 1 + x^M$。最小值在 $x=1+s$ 处取得，值为 $1 + (1+s)^M$。\n在整个不期望特征值的域上， $|1 - \\lambda^M|$ 的总最小值是 $\\min((1+s)^M - 1, 1 + (1+s)^M) = (1+s)^M - 1$。\n因此，不期望特征值上的最大滤波器幅值为\n$$\n\\sup_{\\lambda_{\\text{out}}} |R_M(\\lambda_{\\text{out}})| = \\frac{1}{(1+s)^M - 1}\n$$\n结合这些结果，我们得到收缩因子的界：\n$$\n\\eta \\le \\frac{1/((1+s)^M - 1)}{1/(1+r^M)} = \\frac{1+r^M}{(1+s)^M - 1}\n$$\n\n**步骤3：确定最小间距 $s_{\\min}$**\n\n给定期望的收缩因子最多为 $q$，其中 $q \\in (0,1)$。我们将我们的界设为小于或等于 $q$，并解出 $s$。\n$$\n\\frac{1+r^M}{(1+s)^M - 1} \\le q\n$$\n由于 $q$ 和 $(1+s)^M - 1$ 都是正数，我们可以重排不等式：\n$$\n(1+s)^M - 1 \\ge \\frac{1+r^M}{q}\n$$\n$$\n(1+s)^M \\ge 1 + \\frac{1+r^M}{q}\n$$\n对两边取 $M$ 次方根（对于正基数，这是一个单调操作）：\n$$\n1+s \\ge \\left(1 + \\frac{1+r^M}{q}\\right)^{1/M}\n$$\n$$\ns \\ge \\left(1 + \\frac{1+r^M}{q}\\right)^{1/M} - 1\n$$\n这个不等式给出了确保期望收缩率的 $s$ 的条件。最小间距 $s_{\\min}$ 是满足此条件的 $s$ 的最小值。\n$$\ns_{\\min} = \\left(1 + \\frac{1+r^M}{q}\\right)^{1/M} - 1\n$$\n这就是所要求的 $s_{\\min}$ 关于 $M$、$r$ 和 $q$ 的闭式解析表达式。",
            "answer": "$$\n\\boxed{\\left(1 + \\frac{1+r^M}{q}\\right)^{1/M} - 1}\n$$"
        },
        {
            "introduction": "虽然第一个练习分析了简单的圆形轮廓，但现实世界的问题通常受益于更量身定制的轮廓形状，例如椭圆，以便更紧密地包围目标本征值。本计算练习旨在探索选择椭圆轮廓几何形状时固有的权衡：一个更“紧密”的轮廓可以提高滤波器的选择性，但也可能使求积点更靠近本征值，从而导致需求解的线性方程组变得病态。这项练习提供了评估关键性能和稳定性指标（如滤波器衰减率和条件数）的实践经验，这些指标为FEAST算法的实际应用提供了指导。",
            "id": "3541079",
            "problem": "考虑一个厄米（因此也是正规）矩阵 $A \\in \\mathbb{C}^{n \\times n}$，其谱 $\\{\\lambda_i\\}_{i=1}^n$ 由对角线元素明确给出\n$$\n\\operatorname{diag}(A) = \\left[-1.5,\\,-1.2,\\,-0.9,\\,-0.8,\\,-0.3,\\,-0.1,\\,0.0,\\,0.15,\\,0.25,\\,0.8,\\,1.2,\\,1.5\\right].\n$$\n设 $\\Gamma$ 是复平面中一个以 $0$ 为中心、半长轴为 $a$（沿实轴）、半短轴为 $b$（沿虚轴）的椭圆，其参数化形式为\n$$\nz(\\theta) = a\\cos\\theta + \\mathrm{i}\\,b\\sin\\theta,\\quad \\theta \\in [0,2\\pi).\n$$\n围道积分滤波器对角化（FEAST）算法是一种基于围道积分的特征值求解器，它应用一个有理滤波器来近似谱投影子，该投影子将空间投影到与 $\\Gamma$ 内部特征值相关的不变子空间上。滤波器的质量，以及 FEAST 算法的每次迭代收敛性，取决于围道的几何形状以及谱与围道之间的谱隙。对于 $z \\in \\Gamma$，必须求解移位线性系统 $(zI - A)x = y$，其数值条件会影响稳定性和计算成本。本问题要求您对于 $\\Gamma$ 上的一个固定的梯形求积，量化椭圆离心率和到 $\\Gamma$ 的谱隙如何影响：\n- 沿 $\\Gamma$ 的 $(zI-A)$ 的最坏情况 2-范数条件数，以及\n- 一个根据 $\\Gamma$ 内外特征值之间的有理滤波器衰减推导出的先验 FEAST 收敛率代理指标。\n\n使用以下基本事实：\n- 对于正规矩阵 $A$，$(zI-A)$ 的奇异值是点 $z$ 到各特征值 $\\{\\lambda_i\\}$ 的距离，因此 2-范数条件数为\n$$\n\\kappa_2(zI-A) = \\frac{\\max_i |z-\\lambda_i|}{\\min_i |z-\\lambda_i|}.\n$$\n- 投影到 $\\Gamma$ 内部特征值上的谱投影子是\n$$\nP = \\frac{1}{2\\pi \\mathrm{i}}\\oint_{\\Gamma} (zI-A)^{-1}\\,\\mathrm{d}z,\n$$\n并且，当节点数足够大时，对解析周期被积函数应用关于角度参数 $\\theta$ 的均匀梯形求积，可以得到一个指数级精确的有理近似。\n\n您的任务：\n1. 使用角度参数 $\\theta$ 中的 $m$ 个节点（$\\theta_k = 2\\pi k/m$，其中 $k \\in \\{0,1,\\dots,m-1\\}$）的均匀梯形法则，实现谱投影子的一个近似。使用上面给出的参数化 $z(\\theta)$，并将相应的求积权重取为 $\\theta$ 中的步长与雅可比行列式 $\\mathrm{d}z/\\mathrm{d}\\theta$ 的乘积，再除以 $1/(2\\pi \\mathrm{i})$。由此，将实点 $\\lambda$ 处的标量有理滤波器响应定义为 $(z-\\lambda)^{-1}$ 在 $\\Gamma$ 上的柯西积分的求积近似。您必须计算所有谱点 $\\lambda \\in \\{\\lambda_i\\}$ 的复数滤波器值 $r(\\lambda)$。\n2. 对于给定的椭圆，将满足 $(\\lambda/a)^2  1$ 的特征值 $\\lambda$ 定义为内部谱集（注意所有特征值都是实数）。将相对于 $\\{\\lambda_i\\}$ 的补集定义为外部谱集。\n3. 将椭圆的离心率定义为\n$$\ne = \\sqrt{1 - \\frac{b^2}{a^2}},\n$$\n并将外部谱集到围道的谱隙定义为\n$$\n\\delta_{\\text{out}} = \\min_{\\lambda \\in \\text{exterior}} \\min_{\\theta \\in [0,2\\pi)} |z(\\theta) - \\lambda|.\n$$\n通过对用于滤波器的相同求积节点进行采样来近似 $\\delta_{\\text{out}}$。\n4. 将沿围道的最坏情况条件数计算为\n$$\n\\kappa_{\\max} = \\max_{k \\in \\{0,\\dots,m-1\\}} \\kappa_2\\big(z(\\theta_k)I - A\\big),\n$$\n使用上述关于正规性的事实。\n5. 设 $r(\\lambda)$ 表示在 $\\lambda$ 处评估的有理滤波器。将先验的每次迭代 FEAST 收敛率代理指标定义为\n$$\n\\gamma = \\frac{\\max_{\\lambda \\in \\text{exterior}} |r(\\lambda)|}{\\min_{\\lambda \\in \\text{interior}} |r(\\lambda)|}.\n$$\n该量捕捉了外部和内部谱分量之间的衰减比。\n\n所有计算均使用 $m=64$ 个节点。为保证数值稳健性，请使用上面给出的 $A$ 的精确对角线元素，不要添加扰动。\n\n测试套件：\n为以下椭圆 $(a,b)$ 评估元组 $(e,\\delta_{\\text{out}},\\kappa_{\\max},\\gamma)$：\n- 测试 1：$(a,b) = (0.5,\\,0.49)$，\n- 测试 2：$(a,b) = (0.6,\\,0.59)$，\n- 测试 3：$(a,b) = (0.6,\\,0.20)$，\n- 测试 4：$(a,b) = (0.7,\\,0.20)$，\n- 测试 5：$(a,b) = (0.78,\\,0.20)$。\n\n注意事项和要求：\n- 所有角度均以弧度为单位。\n- 所有输出均为无量纲实数。\n- 您的程序必须生成单行输出，其中包含五个结果的列表，每个结果本身是按 $[e, \\delta_{\\text{out}}, \\kappa_{\\max}, \\gamma]$ 顺序排列的四个浮点数的列表。例如，要求的整体格式是\n$$\n\\big[\\,[e_1,\\delta_1,\\kappa_1,\\gamma_1],\\,[e_2,\\delta_2,\\kappa_2,\\gamma_2],\\,\\dots,\\,[e_5,\\delta_5,\\kappa_5,\\gamma_5]\\,\\big].\n$$\n不应打印任何额外文本。",
            "solution": "问题陈述是有效的。这是一个在数值线性代数领域内，特别是在关于像 FEAST 算法这样的围道积分特征值求解器分析方面，一个适定、有科学依据且客观的问题。计算所需的所有数据、定义和常数均已提供，不存在内部矛盾、歧义或违反科学原理之处。该问题要求计算特定的度量指标，用以表征 FEAST 算法在给定矩阵和一组椭圆围道下的性能和稳定性。\n\n解决方案通过为每个测试案例实施指定的计算来进行。厄米矩阵 $A \\in \\mathbb{C}^{n \\times n}$ 是对角的，其谱 $\\{\\lambda_i\\}_{i=1}^n$ 作为实值项给出：\n$$\n\\{\\lambda_i\\} = \\{-1.5, -1.2, -0.9, -0.8, -0.3, -0.1, 0.0, 0.15, 0.25, 0.8, 1.2, 1.5\\}.\n$$\n复围道 $\\Gamma$ 是一个以原点为中心、半轴为 $a$ 和 $b$ 的椭圆，参数化为 $z(\\theta) = a\\cos\\theta + \\mathrm{i}b\\sin\\theta$，其中 $\\theta \\in [0, 2\\pi)$。所有计算将使用包含 $m=64$ 个节点的均匀梯形求积法则，$\\theta_k = 2\\pi k/m$，其中 $k \\in \\{0, 1, \\dots, m-1\\}$。\n\n对于由一对半轴 $(a,b)$ 定义的每个测试案例，我们计算一个包含四个值的元组 $(e, \\delta_{\\text{out}}, \\kappa_{\\max}, \\gamma)$。计算步骤如下：\n\n1.  **离心率, $e$**: 此值量化了椭圆的形状。它直接根据其定义计算：\n    $$\n    e = \\sqrt{1 - \\frac{b^2}{a^2}}.\n    $$\n\n2.  **谱集**：谱 $\\{\\lambda_i\\}$ 根据半长轴 $a$ 分为两个集合。内部集包含满足 $|\\lambda_i|  a$ 的特征值 $\\lambda_i$，外部集包含满足 $|\\lambda_i| \\ge a$ 的特征值 $\\lambda_i$。这些集合对于定义谱隙和收敛代理指标至关重要。\n\n3.  **求积节点和导数**：围道上的 $m=64$ 个求积点 $z_k = z(\\theta_k)$ 和导数值 $z'(\\theta_k) = \\frac{\\mathrm{d}z}{\\mathrm{d}\\theta}\\big|_{\\theta_k}$ 被预先计算，以用于后续步骤。\n    $$\n    z_k = a\\cos(\\theta_k) + \\mathrm{i}b\\sin(\\theta_k)\n    $$\n    $$\n    z'(\\theta_k) = -a\\sin(\\theta_k) + \\mathrm{i}b\\cos(\\theta_k)\n    $$\n\n4.  **到围道的谱隙, $\\delta_{\\text{out}}$**：该度量衡量从围道 $\\Gamma$ 到外部集中任何特征值的最小距离。通常，较大的谱隙更有利。它通过找到任何求积节点 $z_k$ 到任何外部特征值 $\\lambda_{\\text{ext}}$ 的最小距离来近似：\n    $$\n    \\delta_{\\text{out}} = \\min_{\\lambda \\in \\text{exterior}} \\min_{k \\in \\{0,\\dots,m-1\\}} |z_k - \\lambda|.\n    $$\n\n5.  **最坏情况条件数, $\\kappa_{\\max}$**：该度量量化了 FEAST 算法中必须求解的线性系统的数值稳定性。对于正规矩阵 $A$，$(zI-A)$ 的 2-范数条件数是点 $z$ 到谱的最大距离与最小距离之比。我们计算该值在所有求积节点 $z_k$ 上的最大值：\n    $$\n    \\kappa_{\\max} = \\max_{k \\in \\{0,\\dots,m-1\\}} \\kappa_2(z_kI - A) = \\max_{k \\in \\{0,\\dots,m-1\\}} \\frac{\\max_i |z_k - \\lambda_i|}{\\min_i |z_k - \\lambda_i|}.\n    $$\n\n6.  **有理滤波器响应, $r(\\lambda)$，和收敛代理指标, $\\gamma$**：有理滤波器 $r(\\lambda)$ 是柯西积分 $\\frac{1}{2\\pi \\mathrm{i}} \\oint_\\Gamma (z-\\lambda)^{-1}\\,\\mathrm{d}z$ 的数值近似，对于 $\\Gamma$ 内部的 $\\lambda$，该积分值为 $1$，对于外部的 $\\lambda$，该积分值为 $0$。在参数化积分上使用梯形法则，其值为：\n    $$\n    r(\\lambda) = \\frac{1}{2\\pi \\mathrm{i}} \\sum_{k=0}^{m-1} \\frac{1}{z_k - \\lambda} z'(\\theta_k) \\frac{2\\pi}{m} = \\frac{1}{m\\mathrm{i}} \\sum_{k=0}^{m-1} \\frac{z'(\\theta_k)}{z_k - \\lambda}.\n    $$\n    收敛率代理指标 $\\gamma$ 是外部特征值的最大滤波器响应与内部特征值的最小滤波器响应之比。较小的 $\\gamma$ 表示更好的滤波效果和更快的收敛速度。\n    $$\n    \\gamma = \\frac{\\max_{\\lambda \\in \\text{exterior}} |r(\\lambda)|}{\\min_{\\lambda \\in \\text{interior}} |r(\\lambda)|}.\n    $$\n\n这些步骤被系统地应用于五个测试案例中的每一个，并收集生成的四元素元组。最终的实现封装在一个 Python 脚本中。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes FEAST algorithm performance metrics for a series of elliptical contours.\n    \"\"\"\n\n    # Given spectrum of the diagonal Hermitian matrix A\n    LAMBDAS = np.array([\n        -1.5, -1.2, -0.9, -0.8, -0.3, -0.1, 0.0, 0.15, 0.25, 0.8, 1.2, 1.5\n    ])\n    M = 64  # Number of quadrature nodes\n\n    def calculate_metrics(a, b):\n        \"\"\"\n        Calculates the four required metrics for a given ellipse (a, b).\n        \n        Args:\n            a (float): Semi-axis of the ellipse along the real axis.\n            b (float): Semi-axis of the ellipse along the imaginary axis.\n\n        Returns:\n            list: A list containing [e, delta_out, kappa_max, gamma].\n        \"\"\"\n        \n        # 1. Eccentricity\n        e = np.sqrt(1 - (b/a)**2)\n\n        # 2. Setup quadrature nodes and derivatives\n        thetas = 2 * np.pi * np.arange(M) / M\n        z_nodes = a * np.cos(thetas) + 1j * b * np.sin(thetas)\n        dz_dtheta_nodes = -a * np.sin(thetas) + 1j * b * np.cos(thetas)\n\n        # 3. Partition spectrum and calculate spectral gap delta_out\n        interior_mask = np.abs(LAMBDAS)  a\n        exterior_mask = ~interior_mask\n        \n        interior_lambdas = LAMBDAS[interior_mask]\n        exterior_lambdas = LAMBDAS[exterior_mask]\n\n        # Calculate distances from exterior eigenvalues to contour nodes\n        # Broadcasting: (num_ext_lambdas, 1) - (M,) -> (num_ext_lambdas, M)\n        dist_matrix_ext = np.abs(exterior_lambdas[:, np.newaxis] - z_nodes)\n        \n        if dist_matrix_ext.size > 0:\n            delta_out = np.min(dist_matrix_ext)\n        else:\n            delta_out = np.inf # Should not happen with given test cases\n\n        # 4. Worst-case conditioning kappa_max\n        # Broadcasting: (M, 1) - (num_lambdas,) -> (M, num_lambdas)\n        dist_matrix_all = np.abs(z_nodes[:, np.newaxis] - LAMBDAS)\n        \n        max_dists_per_zk = np.max(dist_matrix_all, axis=1)\n        min_dists_per_zk = np.min(dist_matrix_all, axis=1)\n        \n        # Avoid division by zero if a node lands on an eigenvalue (unlikely)\n        kappas = np.divide(max_dists_per_zk, min_dists_per_zk, \n                           out=np.full_like(max_dists_per_zk, np.inf), \n                           where=min_dists_per_zk!=0)\n        kappa_max = np.max(kappas)\n\n        # 5. Filter response r(lambda) and convergence proxy gamma\n        # Broadcasting: (M,) / ((num_lambdas, 1) - (M,)) -> (num_lambdas, M)\n        # Note the expression z-lambda in the denominator\n        integrand = dz_dtheta_nodes / (z_nodes - LAMBDAS[:, np.newaxis])\n        r_values = (1 / (M * 1j)) * np.sum(integrand, axis=1)\n        \n        r_interior = r_values[interior_mask]\n        r_exterior = r_values[exterior_mask]\n\n        if r_interior.size == 0 or r_exterior.size == 0:\n            gamma = np.inf # Should not happen\n        else:\n            max_r_ext = np.max(np.abs(r_exterior))\n            min_r_int = np.min(np.abs(r_interior))\n            gamma = max_r_ext / min_r_int if min_r_int != 0 else np.inf\n\n        return [e, delta_out, kappa_max, gamma]\n\n    test_cases = [\n        (0.5, 0.49),\n        (0.6, 0.59),\n        (0.6, 0.20),\n        (0.7, 0.20),\n        (0.78, 0.20),\n    ]\n\n    results = []\n    for a_val, b_val in test_cases:\n        result = calculate_metrics(a_val, b_val)\n        results.append(result)\n\n    # Format the final output string to match the problem specification\n    # e.g., [[e1,d1,k1,g1],[e2,d2,k2,g2],...] with no spaces\n    inner_strings = [f\"[{','.join(map(str, res))}]\" for res in results]\n    final_output = f\"[{','.join(inner_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n\n```"
        },
        {
            "introduction": "包括FEAST在内的许多本征求解器的收敛理论对于厄米矩阵或正规矩阵最为简单。本练习将研究更具挑战性的近始矩阵情况，其中本征值聚集且本征向量几乎线性相关。我们将分析离散FEAST滤波器如何作用于一个 $2 \\times 2$ 的若尔当块（它模拟了这种近简并性），重点关注滤波器抑制导致病态的“幂零”部分的表现。这个高级练习揭示了一个令人惊讶但重要的现象：求积点数量的奇偶性显著影响算法处理近始性的能力，从而解释了收敛过程中可能出现的停滞现象。",
            "id": "3541135",
            "problem": "考虑由下式定义的 $2\\times 2$ 上三角矩阵族 $\\{A_{\\epsilon}\\}_{\\epsilon\\ge 0}$\n$$\nA_{\\epsilon} = \\begin{bmatrix} \\lambda+\\epsilon  1 \\\\ 0  \\lambda-\\epsilon \\end{bmatrix}\n= \\lambda I + N + \\epsilon \\begin{bmatrix} 1  0 \\\\ 0  -1 \\end{bmatrix},\n\\quad\nN = \\begin{bmatrix} 0  1 \\\\ 0  0 \\end{bmatrix},\\quad N^2=0,\n$$\n使得 $A_0 = \\lambda I + N$ 是一个特征值为 $\\lambda$ 的 $2\\times 2$ 若尔当块。设谱投影算子 $\\Pi$ 投射到与被正向简单闭合围线 $\\Gamma$ 所包围的特征值相关联的不变子空间上，由里斯积分给出\n$$\n\\Pi = \\frac{1}{2\\pi i} \\oint_{\\Gamma} (zI - A_{\\epsilon})^{-1}\\,dz.\n$$\n围道积分特征求解器 (FEAST) 通过使用求积法则近似围道积分来构造有理滤波器。使用以 $c\\in\\mathbb{C}$ 为中心、半径为 $r0$ 的圆形围线 $\\Gamma$，参数化为 $z(\\theta) = c + r e^{i\\theta}$，并采用具有 $K$ 个等距节点 $\\theta_k = \\tfrac{2\\pi k}{K}$（$k=0,1,\\dots,K-1$）的梯形法则，可得到离散 FEAST 滤波器\n$$\nF_K(A_{\\epsilon};c,r) \\equiv \\sum_{k=0}^{K-1} \\omega_k \\left(z_k I - A_{\\epsilon}\\right)^{-1}, \n\\quad z_k = c + r e^{i\\theta_k}, \n\\quad \\omega_k = \\frac{\\Delta\\theta}{2\\pi i} z'(\\theta_k) = \\frac{r e^{i\\theta_k}}{K},\n$$\n其中 $\\Delta\\theta = \\tfrac{2\\pi}{K}$ 且 $z'(\\theta) = i r e^{i\\theta}$。对于若尔当极限 $\\epsilon=0$ 和 $c=\\lambda$，预解式具有幂零展开\n$$\n(zI - A_0)^{-1} = (z - \\lambda)^{-1} I + (z - \\lambda)^{-2} N,\n$$\n因此，一次 FEAST 应用对应于离散矩和\n$$\nF_K(A_0;\\lambda,r)\n= \\left(\\sum_{k=0}^{K-1} \\omega_k (z_k-\\lambda)^{-1}\\right) I \n+ \\left(\\sum_{k=0}^{K-1} \\omega_k (z_k-\\lambda)^{-2}\\right) N.\n$$\n从第一性原理出发，分析离散矩在 $\\epsilon\\to 0$ 时的行为，以及 FEAST 的子空间迭代如何滤除幂零贡献。具体而言：\n- 使用上述求积法则，推导当 $\\epsilon=0$ 时幂零项系数的相消模式。证明对于任意 $K\\ge 2$，幂零项完全消失，而对于 $K=1$，它以明确的量级持续存在。\n- 对于 $\\epsilon0$，计算由离散滤波器产生的非对角系数，\n$$\n\\alpha_{K}(\\epsilon) \\equiv \\left[F_K(A_{\\epsilon};\\lambda,r)\\right]_{12} = \\sum_{k=0}^{K-1} \\omega_k \\left((z_k-\\lambda-\\epsilon)^{-1}(z_k-\\lambda+\\epsilon)^{-1}\\right),\n$$\n并为其衰减建立一个区分 $K$ 的奇偶性的小 $\\epsilon$ 渐近预测。\n- 解释 FEAST 子空间迭代中的停滞模式：将 $\\alpha_K(\\epsilon)$ 解释为单次滤波器应用后保留的残余幂零贡献，并将其依赖于奇偶性的行为与重复 FEAST 步骤是能立即消除幂零部分，还是只能以受 $\\epsilon$ 和 $K$ 控制的速率减小它相关联。\n\n实现要求：\n- 固定 $\\lambda=0$ 且 $c=\\lambda=0$。\n- 固定 $r=0.5$。\n- 使用复数算术，完全按照上述定义实现离散 FEAST 滤波器 $F_K(A_{\\epsilon};0,0.5)$。\n- 对每个测试用例，计算标量 $\\alpha_K(\\epsilon)$，即 $F_K(A_{\\epsilon};0,0.5)$ 的 $(1,2)$ 元的模，也即计算 $\\left|\\left[F_K(A_{\\epsilon};0,0.5)\\right]_{12}\\right|$ 作为实值浮点数。\n\n测试套件：\n- 情况 1 (边界，单节点)：$\\epsilon = 0.0$, $K = 1$。\n- 情况 2 (最小精确相消)：$\\epsilon = 0.0$, $K = 2$。\n- 情况 3 (近始，偶数精确性)：$\\epsilon = 10^{-6}$, $K = 2$。\n- 情况 4 (近始，奇数主阶非零)：$\\epsilon = 10^{-6}$, $K = 3$。\n- 情况 5 (中度近始，奇数缩放)：$\\epsilon = 10^{-3}$, $K = 3$。\n- 情况 6 (更高奇数，更强抑制)：$\\epsilon = 10^{-3}$, $K = 5$。\n\n你的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，“[result1,result2,result3,result4,result5,result6]”），其中每个结果是对应测试用例的实值浮点数 $\\left|\\left[F_K(A_{\\epsilon};0,0.5)\\right]_{12}\\right|$。",
            "solution": "该问题要求分析离散 FEAST 滤波器 $F_K(A_{\\epsilon};c,r)$ 应用于一族近始矩阵 $A_{\\epsilon}$ 时的行为。分析重点在于滤波后矩阵的 $(1,2)$ 元（记为 $\\alpha_K(\\epsilon)$）的行为，特别是其对求积点数 $K$ 和扰动参数 $\\epsilon$ 的依赖性。\n\n首先，我们建立必要的矩阵逆。预解式 $(zI - A_{\\epsilon})^{-1}$ 是分析的核心。给定 $A_{\\epsilon} = \\begin{bmatrix} \\lambda+\\epsilon  1 \\\\ 0  \\lambda-\\epsilon \\end{bmatrix}$，其逆为：\n$$\n(zI - A_{\\epsilon})^{-1} = \\begin{bmatrix} z - (\\lambda+\\epsilon)  -1 \\\\ 0  z - (\\lambda-\\epsilon) \\end{bmatrix}^{-1}\n= \\frac{1}{(z - \\lambda - \\epsilon)(z - \\lambda + \\epsilon)}\n\\begin{bmatrix} z - (\\lambda-\\epsilon)  1 \\\\ 0  z - (\\lambda+\\epsilon) \\end{bmatrix}\n$$\n预解式的 $(1,2)$ 元是 $\\frac{1}{(z - \\lambda - \\epsilon)(z - \\lambda + \\epsilon)}$。\n待计算的量 $\\alpha_K(\\epsilon)$ 是离散滤波器 $F_K(A_{\\epsilon};\\lambda,r)$ 的 $(1,2)$ 元。使用滤波器的定义，我们有：\n$$\n\\alpha_{K}(\\epsilon) \\equiv \\left[F_K(A_{\\epsilon};\\lambda,r)\\right]_{12} = \\sum_{k=0}^{K-1} \\omega_k \\left[(z_k I - A_{\\epsilon})^{-1}\\right]_{12} = \\sum_{k=0}^{K-1} \\omega_k \\frac{1}{(z_k - \\lambda - \\epsilon)(z_k - \\lambda + \\epsilon)}\n$$\n对于以 $c=\\lambda$ 为中心的指定圆形围线，求积节点为 $z_k = \\lambda + r e^{i\\theta_k}$，权重为 $\\omega_k = \\frac{r e^{i\\theta_k}}{K}$。将这些代入 $\\alpha_K(\\epsilon)$ 的表达式中可得：\n$$\n\\alpha_{K}(\\epsilon) = \\sum_{k=0}^{K-1} \\frac{r e^{i\\theta_k}}{K} \\frac{1}{(r e^{i\\theta_k} - \\epsilon)(r e^{i\\theta_k} + \\epsilon)} = \\sum_{k=0}^{K-1} \\frac{r e^{i\\theta_k}}{K} \\frac{1}{r^2 e^{i2\\theta_k} - \\epsilon^2}\n$$\n\n现在我们来处理具体的分析任务。\n\n**1. 若尔当极限分析 ($\\epsilon=0$)**\n\n当 $\\epsilon=0$ 时，矩阵成为一个若尔当块 $A_0 = \\lambda I + N$。$\\alpha_K(0)$ 的表达式简化为：\n$$\n\\alpha_K(0) = \\sum_{k=0}^{K-1} \\frac{r e^{i\\theta_k}}{K} \\frac{1}{r^2 e^{i2\\theta_k}} = \\frac{1}{Kr} \\sum_{k=0}^{K-1} e^{-i\\theta_k}\n$$\n该和是 $K$ 次单位根的几何级数。具体来说，当 $\\theta_k = \\frac{2\\pi k}{K}$ 时，该和为 $\\sum_{k=0}^{K-1} (e^{-i2\\pi/K})^k$。\n几何级数 $\\sum_{k=0}^{K-1} q^k$ 的和，当 $q\\neq 1$ 时等于 $\\frac{1-q^K}{1-q}$，当 $q=1$ 时等于 $K$。\n\n-   当 $K=1$ 时，公比为 $e^{-i2\\pi} = 1$。和为 $1$。因此，\n    $$\n    \\alpha_1(0) = \\frac{1}{(1)r} \\cdot 1 = \\frac{1}{r}\n    $$\n    幂零贡献持续存在，其量级与围线半径 $r$ 成反比。\n\n-   当 $K \\ge 2$ 时，公比为 $q = e^{-i2\\pi/K} \\neq 1$。和为：\n    $$\n    \\sum_{k=0}^{K-1} (e^{-i2\\pi/K})^k = \\frac{1 - (e^{-i2\\pi/K})^K}{1 - e^{-i2\\pi/K}} = \\frac{1 - e^{-i2\\pi}}{1 - e^{-i2\\pi/K}} = \\frac{1-1}{1 - e^{-i2\\pi/K}} = 0\n    $$\n    因此，对于任意 $K \\ge 2$：\n    $$\n    \\alpha_K(0) = 0\n    $$\n    这表明，当使用具有 $K \\ge 2$ 个节点的梯形法则来近似若尔当块预解式展开中 $(z-\\lambda)^{-2}N$ 项的围线积分时，幂零项系数会精确相消。\n\n**2. $\\epsilon  0$ 的渐近分析**\n\n对于满足 $|\\epsilon|  r$ 的小 $\\epsilon$，我们通过对分母项进行泰勒级数展开来分析 $\\alpha_K(\\epsilon)$：\n$$\n\\frac{1}{r^2 e^{i2\\theta_k} - \\epsilon^2} = \\frac{1}{r^2 e^{i2\\theta_k}} \\left( \\frac{1}{1 - (\\epsilon/r)^2 e^{-i2\\theta_k}} \\right) = \\frac{e^{-i2\\theta_k}}{r^2} \\sum_{j=0}^{\\infty} \\left(\\frac{\\epsilon}{r}\\right)^{2j} e^{-i2j\\theta_k}\n$$\n将此代入 $\\alpha_K(\\epsilon)$ 的表达式中：\n$$\n\\alpha_K(\\epsilon) = \\sum_{k=0}^{K-1} \\frac{r e^{i\\theta_k}}{K} \\left( \\frac{e^{-i2\\theta_k}}{r^2} \\sum_{j=0}^{\\infty} \\left(\\frac{\\epsilon}{r}\\right)^{2j} e^{-i2j\\theta_k} \\right) = \\frac{1}{Kr} \\sum_{j=0}^{\\infty} \\left(\\frac{\\epsilon}{r}\\right)^{2j} \\sum_{k=0}^{K-1} e^{-i(2j+1)\\theta_k}\n$$\n内层和 $\\sum_{k=0}^{K-1} e^{-i(2j+1)2\\pi k/K}$ 是另一个单位根的几何和。如果 $K$ 整除 $2j+1$，则其值为 $K$，否则为 $0$。我们考虑 $K$ 的奇偶性。\n\n-   **偶数 $K$**：设 $K=2p$，其中 $p \\ge 1$ 为整数。偶数的整数倍总是偶数，$mK=m(2p)$。然而，对于任意整数 $j \\ge 0$，$2j+1$ 总是奇数。因此，$2j+1$ 永远不可能是偶数 $K$ 的倍数。这意味着内层和对所有 $j \\ge 0$ 均为零。因此，对于任意偶数 $K \\ge 2$：\n    $$\n    \\alpha_K(\\epsilon) = 0\n    $$\n    这是一个显著的结果：具有偶数个节点的离散滤波器不仅对始情况 $\\epsilon=0$ 完全消除了非对角耦合，而且对非始的、近简并情况 $\\epsilon0$ 也同样如此。\n\n-   **奇数 $K$**：设 $K=2p+1$，其中 $p \\ge 1$ 为整数。现在 $K$ 有可能整除 $2j+1$。$\\alpha_K(\\epsilon)$ 的级数展开将包含非零项。主阶项对应于使 $K$ 整除 $2j+1$ 的最小非负整数 $j$。由于 $K$ 是奇数，我们可以选择乘数 $m=1$，得到 $2j+1=K$，即 $j = (K-1)/2$。由于 $K$ 是奇数，这是一个整数。下一个非零项将出现在 $2j+1=3K$ 时，即 $j=(3K-1)/2$。对于小 $\\epsilon$ 的渐近预测，我们只需要主阶项，其中 $j=(K-1)/2$：\n    $$\n    \\alpha_K(\\epsilon) = \\frac{1}{Kr} \\left( \\left(\\frac{\\epsilon}{r}\\right)^{2j} \\cdot K \\right) + O(\\epsilon^{2j+2}) \\quad \\text{其中 } j=\\frac{K-1}{2}\n    $$\n    $$\n    \\alpha_K(\\epsilon) = \\frac{1}{r} \\left(\\frac{\\epsilon}{r}\\right)^{K-1} + O(\\epsilon^{K+1}) = \\frac{\\epsilon^{K-1}}{r^K} + O(\\epsilon^{K+1})\n    $$\n    对于奇数 $K$，非对角系数非零，并以 $\\epsilon^{K-1}$ 的速度衰减。\n\n**3. FEAST 停滞模式的解释**\n\n量 $\\alpha_K(\\epsilon)$ 表示一次 FEAST 滤波器应用后的残余幂零贡献，即持续存在的非对角耦合。FEAST 中的子空间迭代旨在投影出所需不变子空间之外的分量。对于近始问题，这对应于分离与聚集特征值相关的特征向量。\n\n-   当使用**偶数**个求积点 ($K \\ge 2$) 时，$\\alpha_K(\\epsilon)=0$。滤波后的矩阵 $F_K(A_{\\epsilon};\\lambda,r)$ 是对角的（其 $(1,2)$ 元为零，并且由于 $A_\\epsilon$ 的结构，其 $(2,1)$ 元也为零）。这意味着滤波器在单一步骤中就完美地解耦了张成不变子空间的基向量。FEAST 的子空间迭代将立即收敛到正确的子空间，而不会出现与近简并性相关的任何停滞。\n\n-   当使用**奇数**个求积点 ($K$) 时，$\\alpha_K(\\epsilon) \\approx \\epsilon^{K-1}/r^K \\neq 0$。滤波后的矩阵仍然是上三角矩阵，但带有一个微小但非零的非对角元。这意味着单次滤波器应用并不能完全解耦特征向量。相反，它将耦合从 $A_\\epsilon$ 中的 $O(1)$ 减小到 $O(\\epsilon^{K-1})$。重复应用 FEAST 将继续减小这种耦合，但收敛速度将受此因素限制。对于非常小的 $\\epsilon$，收敛最初可能看起来很快，但一旦子空间中的误差达到 $|\\alpha_K(\\epsilon)|$ 的量级，就会“停滞”或显著减慢。改进的速率变成关于 $\\epsilon$ 的代数速率，而不是像分离良好的特征值那样的几何速率。增加（奇数）节点数 $K$ 可以改善对幂零部分的抑制，因为残差随 $\\epsilon$ 衰减得更快（如 $\\epsilon^{K-1}$）。\n\n总之，FEAST 算法中求积节点数 $K$ 的奇偶性对其在近始问题上的性能至关重要。对于这个 $2 \\times 2$ 模型，偶数 $K$ 提供了非对角耦合的精确消除，避免了停滞，而奇数 $K$ 则导致了可预测的残余耦合，这解释了在实践中观察到的典型停滞行为。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the magnitude of the (1,2) entry of the discrete FEAST filter \n    for a family of nearly-defective matrices.\n    \"\"\"\n    \n    # Fixed parameters from the problem statement\n    r = 0.5  # Contour radius\n    # lambda and c are zero\n\n    test_cases = [\n        # (epsilon, K)\n        (0.0, 1),\n        (0.0, 2),\n        (1e-6, 2),\n        (1e-6, 3),\n        (1e-3, 3),\n        (1e-3, 5),\n    ]\n\n    results = []\n\n    def compute_alpha(epsilon: float, K: int, r_val: float) - float:\n        \"\"\"\n        Calculates the scalar quantity alpha_K(epsilon) as the magnitude \n        of the (1,2) entry of the discrete FEAST filter F_K(A_epsilon; 0, r).\n\n        alpha_K(epsilon) = sum_{k=0}^{K-1} omega_k * 1/((z_k - epsilon)*(z_k + epsilon))\n                         = sum_{k=0}^{K-1} omega_k / (z_k^2 - epsilon^2)\n        \n        where z_k = r * exp(i*theta_k) and omega_k = r * exp(i*theta_k) / K = z_k / K.\n        \"\"\"\n        \n        alpha = 0.0 + 0.0j\n        \n        # This handles the K=0 case, though not in test suite.\n        if K == 0:\n            return 0.0\n\n        for k in range(K):\n            # Quadrature node\n            theta_k = 2 * np.pi * k / K\n            z_k = r_val * np.exp(1j * theta_k)\n            \n            # Quadrature weight\n            # The definition is omega_k = (r * exp(i*theta_k)) / K\n            # This is simply z_k / K\n            omega_k = z_k / K\n            \n            # Denominator term\n            # In the degenerate case epsilon=0, z_k**2 could be zero if r=0, but r=0.5\n            denominator = z_k**2 - epsilon**2\n            \n            # Add the contribution from the k-th node\n            # The formula for the (1,2) entry is derived in the text\n            if np.abs(denominator)  1e-18: # Avoid division by zero for exotic cases\n                # This branch is not expected to be hit with the given parameters,\n                # as |z_k|=r=0.5 and epsilon is small.\n                # A more robust implementation might need careful handling here.\n                # For this problem, it is safe.\n                pass\n            \n            alpha += omega_k / denominator\n\n        return np.abs(alpha)\n\n    for epsilon, K in test_cases:\n        result = compute_alpha(epsilon, K, r)\n        results.append(result)\n\n    # Format the final output as a comma-separated list in brackets\n    print(f\"[{','.join(f'{res:.16e}' for res in results)}]\")\n\nsolve()\n```"
        }
    ]
}