{
    "hands_on_practices": [
        {
            "introduction": "轮廓积分特征求解器的有效性取决于其创建一个能将目标特征值与非目标特征值分离开的“滤波器”的能力。本练习将深入探讨这一机制的核心，通过推导一个简单滤波器的数学形式，并量化收敛速度与“谱间隙”（即非目标特征值到积分轮廓的距离）之间的关系。完成此练习将使您对这些方法为何有效以及是什么决定了其性能有一个定量的理解。",
            "id": "3541067",
            "problem": "考虑一个具有实谱的实对称（厄米）矩阵 $A \\in \\mathbb{R}^{n \\times n}$，假设目标是计算其特征值位于实区间 $\\left[-r, r\\right]$（其中 $r \\in (0,1)$）内的所有特征对。一个基于谱投影子的标准围道积分特征求解器近似计算\n$$\nP = \\frac{1}{2\\pi i} \\oint_{\\Gamma} (zI - A)^{-1} \\, dz,\n$$\n其中 $\\Gamma$ 是复平面中以原点为中心、逆时针方向的单位圆，该积分通过在参数化 $z(\\theta)=\\exp(i\\theta)$（$\\theta \\in [0,2\\pi)$）上使用 $M$ 点梯形法则进行近似。得到的有理滤波器 $R_M(A)$ 被用作子空间迭代，将子空间 $V$ 映射到 $R_M(A)V$。在此设定下，与不需要的特征值（即 $\\Gamma$ 之外的特征值）相关的分量的渐近收敛因子有一个上界，该上界为滤波器在不需要的特征值上取得的最大标量幅值与在所需特征值上取得的最小标量幅值之比。\n\n假设所有需要的特征值都位于 $\\left[-r, r\\right]$ 内，所有不需要的特征值都位于单位圆外，且最近的不需要的特征值为 $\\lambda_{\\star} = 1 + s$（对于某个 $s>0$）。根据以上定义、单位圆参数化和 $M$ 点梯形法则，推导出由数值求积得到的显式标量有理滤波器，用它来限定作为 $s$、$M$ 和 $r$ 的函数的收敛因子，然后确定保证每次迭代有预设收敛因子 $q \\in (0,1)$ 的最小间距 $s_{\\min}$，即确保滤波器在不需要的特征值上的最大幅值与在所需特征值上的最小幅值之比最多为 $q$。请用一个关于 $M$、$r$ 和 $q$ 的单一闭式解析表达式给出 $s_{\\min}$ 的最终答案。不需要四舍五入。",
            "solution": "问题要求计算不需要的特征值与单位圆之间的最小间距 $s_{\\min}$，以保证围道积分特征求解器达到特定的收敛速率。推导过程分为三个主要步骤：首先，我们确定由数值求积导出的标量有理滤波器 $R_M(\\lambda)$ 的显式形式；其次，我们为所需和不需要的特征值建立该滤波器幅值的界；最后，我们利用这些界求解所需的间距 $s$。\n\n**第一步：标量有理滤波器的推导**\n\n矩阵 $A$ 的特征值问题的谱投影子 $P$ 由围道积分给出\n$$\nP = \\frac{1}{2\\pi i} \\oint_{\\Gamma} (zI - A)^{-1} \\, dz\n$$\n其中 $\\Gamma$ 是一个包围所需特征值的围道。该投影子作用于与特征值 $\\lambda$ 对应的特征向量上的行为由标量函数所决定\n$$\np(\\lambda) = \\frac{1}{2\\pi i} \\oint_{\\Gamma} (z - \\lambda)^{-1} \\, dz\n$$\n问题指明 $\\Gamma$ 是单位圆，参数化为 $z(\\theta) = \\exp(i\\theta)$，其中 $\\theta \\in [0, 2\\pi)$。其微分为 $dz = i\\exp(i\\theta)d\\theta$。将此代入 $p(\\lambda)$ 的积分中得到\n$$\np(\\lambda) = \\frac{1}{2\\pi i} \\int_{0}^{2\\pi} \\frac{1}{\\exp(i\\theta) - \\lambda} i\\exp(i\\theta) d\\theta = \\frac{1}{2\\pi} \\int_{0}^{2\\pi} \\frac{\\exp(i\\theta)}{\\exp(i\\theta) - \\lambda} d\\theta\n$$\n问题说明该积分使用 $M$ 点梯形法则进行近似。区间为 $[0, 2\\pi)$，步长为 $h = \\frac{2\\pi}{M}$。求积点为 $\\theta_k = \\frac{2\\pi k}{M}$，其中 $k \\in \\{0, 1, \\dots, M-1\\}$。单位圆上对应的点为 $z_k = \\exp(i\\theta_k) = \\exp(i \\frac{2\\pi k}{M})$，即 $M$ 次单位根。\n\n梯形法则近似定义了标量有理滤波器 $R_M(\\lambda)$，其表达式为\n$$\nR_M(\\lambda) = \\frac{h}{2\\pi} \\sum_{k=0}^{M-1} \\frac{z_k}{z_k - \\lambda} = \\frac{1}{M} \\sum_{k=0}^{M-1} \\frac{z_k}{z_k - \\lambda}\n$$\n我们可以将和中的项重写为 $\\frac{z_k}{z_k - \\lambda} = 1 + \\frac{\\lambda}{z_k - \\lambda}$。这样得到\n$$\nR_M(\\lambda) = \\frac{1}{M} \\sum_{k=0}^{M-1} \\left(1 + \\frac{\\lambda}{z_k - \\lambda}\\right) = 1 + \\frac{\\lambda}{M} \\sum_{k=0}^{M-1} \\frac{1}{z_k - \\lambda}\n$$\n这个和可以用一个相关有理函数的部分分式展开来计算。考虑多项式 $p(z) = z^M - 1$，其根为点 $z_k$。它的对数导数是\n$$\n\\frac{p'(z)}{p(z)} = \\frac{Mz^{M-1}}{z^M - 1} = \\sum_{k=0}^{M-1} \\frac{1}{z - z_k}\n$$\n在 $z=\\lambda$ 处求值并整理符号可得\n$$\n\\sum_{k=0}^{M-1} \\frac{1}{z_k - \\lambda} = - \\sum_{k=0}^{M-1} \\frac{1}{\\lambda - z_k} = - \\frac{M\\lambda^{M-1}}{\\lambda^M - 1}\n$$\n将此代回 $R_M(\\lambda)$ 的表达式中：\n$$\nR_M(\\lambda) = 1 + \\frac{\\lambda}{M} \\left( - \\frac{M\\lambda^{M-1}}{\\lambda^M - 1} \\right) = 1 - \\frac{\\lambda^M}{\\lambda^M - 1} = \\frac{(\\lambda^M - 1) - \\lambda^M}{\\lambda^M - 1} = \\frac{-1}{\\lambda^M - 1}\n$$\n因此，显式的标量有理滤波器为\n$$\nR_M(\\lambda) = \\frac{1}{1 - \\lambda^M}\n$$\n\n**第二步：限定收敛因子**\n\n渐近收敛因子由滤波器在不需要的特征值上的最大幅值与在所需特征值上的最小幅值之比来限定。设此界为 $\\eta$。\n$$\n\\eta \\le \\frac{\\sup_{\\lambda_{\\text{out}}} |R_M(\\lambda_{\\text{out}})|}{\\inf_{\\lambda_{\\text{in}}} |R_M(\\lambda_{\\text{in}})|}\n$$\n特征值 $\\lambda$ 是实数。所需特征值 $\\lambda_{\\text{in}}$ 位于 $[-r, r]$ 内，其中 $r \\in (0,1)$。不需要的特征值 $\\lambda_{\\text{out}}$ 位于单位圆外，最近的一个与单位圆的距离为 $s>0$，即 $|\\lambda_{\\text{out}}| \\ge 1+s$。\n\n首先，我们分析分母，即滤波器在所需特征值上的最小幅值：\n$$\n\\inf_{\\lambda_{\\text{in}} \\in [-r, r]} |R_M(\\lambda_{\\text{in}})| = \\inf_{\\lambda \\in [-r, r]} \\left| \\frac{1}{1 - \\lambda^M} \\right| = \\frac{1}{\\sup_{\\lambda \\in [-r, r]} |1 - \\lambda^M|}\n$$\n对于任何满足 $|\\lambda| \\le r$ 的实数 $\\lambda$，我们有 $|\\lambda^M| \\le r^M$。根据三角不等式， $|1 - \\lambda^M| \\le 1 + |\\lambda^M| \\le 1 + r^M$。如果 $M$ 为奇数，在 $\\lambda=-r$ 处达到此上界。如果 $M$ 为偶数，最大值为 $1$。为了得到一个对任何 $M$ 都有效的界，我们取滤波器分母的最坏情况（最大）值，即 $1+r^M$。因此，我们为滤波器在所需特征值上的幅值建立一个下界：\n$$\n\\inf_{\\lambda_{\\text{in}}} |R_M(\\lambda_{\\text{in}})| \\ge \\frac{1}{1 + r^M}\n$$\n接下来，我们分析分子，即滤波器在不需要的特征值上的最大幅值：\n$$\n\\sup_{\\lambda_{\\text{out}}} |R_M(\\lambda_{\\text{out}})| = \\sup_{|\\lambda| \\ge 1+s, \\lambda \\in \\mathbb{R}} \\left| \\frac{1}{1 - \\lambda^M} \\right| = \\frac{1}{\\inf_{|\\lambda| \\ge 1+s, \\lambda \\in \\mathbb{R}} |1 - \\lambda^M|}\n$$\n我们需要找到 $|1 - \\lambda^M|$ 在实数 $\\lambda$ 满足 $\\lambda \\ge 1+s$ 或 $\\lambda \\le -(1+s)$ 条件下的最小值。\n- 如果 $\\lambda \\ge 1+s$，那么 $\\lambda^M \\ge (1+s)^M > 1$。函数 $|1 - \\lambda^M| = \\lambda^M - 1$ 是单调递增的。在此定义域上，其最小值在 $\\lambda = 1+s$ 处取得，值为 $(1+s)^M - 1$。\n- 如果 $\\lambda \\le -(1+s)$，令 $\\lambda = -x$ 其中 $x \\ge 1+s$。函数为 $|1 - (-x)^M|$。\n  - 如果 $M$ 是偶数：$|1 - x^M| = x^M - 1$。最小值在 $x=1+s$ 处取得，值为 $(1+s)^M - 1$。\n  - 如果 $M$ 是奇数：$|1 + x^M| = 1 + x^M$。最小值在 $x=1+s$ 处取得，值为 $1 + (1+s)^M$。\n在所有不需要的特征值的整个定义域上， $|1 - \\lambda^M|$ 的总最小值为 $\\min((1+s)^M - 1, 1 + (1+s)^M) = (1+s)^M - 1$。\n因此，滤波器在不需要的特征值上的最大幅值为\n$$\n\\sup_{\\lambda_{\\text{out}}} |R_M(\\lambda_{\\text{out}})| = \\frac{1}{(1+s)^M - 1}\n$$\n结合这些结果，我们得到收敛因子的界：\n$$\n\\eta \\le \\frac{1/((1+s)^M - 1)}{1/(1+r^M)} = \\frac{1+r^M}{(1+s)^M - 1}\n$$\n\n**第三步：确定最小间距 $s_{\\min}$**\n\n给定所需收敛因子最多为 $q$，其中 $q \\in (0,1)$。我们将我们的界设为小于或等于 $q$ 并求解 $s$。\n$$\n\\frac{1+r^M}{(1+s)^M - 1} \\le q\n$$\n由于 $q$ 和 $(1+s)^M - 1$ 都是正数，我们可以重排不等式：\n$$\n(1+s)^M - 1 \\ge \\frac{1+r^M}{q}\n$$\n$$\n(1+s)^M \\ge 1 + \\frac{1+r^M}{q}\n$$\n对两边取 $M$ 次方根（对于正基数，这是一个单调操作）：\n$$\n1+s \\ge \\left(1 + \\frac{1+r^M}{q}\\right)^{1/M}\n$$\n$$\ns \\ge \\left(1 + \\frac{1+r^M}{q}\\right)^{1/M} - 1\n$$\n这个不等式给出了保证所需收敛速率的关于 $s$ 的条件。最小间距 $s_{\\min}$ 是满足此条件的 $s$ 的最小值。\n$$\ns_{\\min} = \\left(1 + \\frac{1+r^M}{q}\\right)^{1/M} - 1\n$$\n这就是所要求的关于 $M$、$r$ 和 $q$ 的 $s_{\\min}$ 的闭式解析表达式。",
            "answer": "$$\n\\boxed{\\left(1 + \\frac{1+r^M}{q}\\right)^{1/M} - 1}\n$$"
        },
        {
            "introduction": "尽管滤波器的选择性决定了收敛速度，但积分轮廓的几何形状也对算法的数值稳定性有关键影响。这个动手编程练习将通过研究椭圆轮廓的形状如何同时影响滤波器性能和必须求解的线性系统的条件数，来探索收敛性与稳定性之间的基本权衡。这项实践将使您掌握为FEAST算法设计有效且稳健的轮廓的实用见解。",
            "id": "3541079",
            "problem": "考虑厄米（因此也是正规）矩阵 $A \\in \\mathbb{C}^{n \\times n}$，其谱 $\\{\\lambda_i\\}_{i=1}^n$ 由对角线元素明确给出\n$$\n\\operatorname{diag}(A) = \\left[-1.5,\\,-1.2,\\,-0.9,\\,-0.8,\\,-0.3,\\,-0.1,\\,0.0,\\,0.15,\\,0.25,\\,0.8,\\,1.2,\\,1.5\\right].\n$$\n设 $\\Gamma$ 为复平面中以 $0$ 为中心、半轴分别为 $a$（沿实轴）和 $b$（沿虚轴）的椭圆，其参数化为\n$$\nz(\\theta) = a\\cos\\theta + \\mathrm{i}\\,b\\sin\\theta,\\quad \\theta \\in [0,2\\pi).\n$$\n通过围线积分的滤波器对角化（FEAST）算法是一种围线积分特征求解器，它应用一个有理滤波器来近似谱投影算子，该算子将空间投影到与 $\\Gamma$ 内部的特征值相关联的不变子空间上。滤波器的质量，以及 FEAST 算法每次迭代的收敛性，取决于围线的几何形状以及谱与围线之间的谱隙。必须求解 $z \\in \\Gamma$ 的移位线性系统 $(zI - A)x = y$，其数值条件数会影响稳定性和计算成本。本问题要求您对于 $\\Gamma$ 上的固定梯形求積，量化椭圆的离心率和到 $\\Gamma$ 的谱隙如何影响：\n- 沿 $\\Gamma$ 的 $(zI-A)$ 的最坏情况 2-范数条件数，以及\n- 从 $\\Gamma$ 内外特征值之间的有理滤波器衰減导出的先验 FEAST 收敛率代理指标。\n\n使用以下基本事实：\n- 对于正规矩阵 $A$，$(zI-A)$ 的奇异值是 $z$ 到特征值 $\\{\\lambda_i\\}$ 的距离，因此 2-范数条件数为\n$$\n\\kappa_2(zI-A) = \\frac{\\max_i |z-\\lambda_i|}{\\min_i |z-\\lambda_i|}.\n$$\n- 投影到 $\\Gamma$ 内部特征值上的谱投影算子为\n$$\nP = \\frac{1}{2\\pi \\mathrm{i}}\\oint_{\\Gamma} (zI-A)^{-1}\\,\\mathrm{d}z,\n$$\n并且，当节点数足够大时，对解析周期被积函数应用角度参数 $\\theta$ 的均匀梯形求积，会得到指数级精确的有理近似。\n\n您的任务：\n1. 使用均匀梯形法则和 $m$ 个节点（角度参数 $\\theta$ 中，$\\theta_k = 2\\pi k/m$，其中 $k \\in \\{0,1,\\dots,m-1\\}$）来实现谱投影算子的近似。使用上面给出的参数化 $z(\\theta)$，并将相应的求积权重取为 $\\theta$ 中的步长与导数 $\\mathrm{d}z/\\mathrm{d}\\theta$ 的乘积，再按 $1/(2\\pi \\mathrm{i})$ 进行缩放。由此，将实点 $\\lambda$ 处的标量有理滤波器响应定义为 $(z-\\lambda)^{-1}$ 在 $\\Gamma$ 上的柯西积分的求积近似。您必须计算所有谱点 $\\lambda \\in \\{\\lambda_i\\}$ 的复数滤波器值 $r(\\lambda)$。\n2. 对于给定的椭圆，将内部谱集定义为满足 $(\\lambda/a)^2  1$ 的特征值 $\\lambda$（注意所有特征值都是实数）。将外部谱集定义为相对于 $\\{\\lambda_i\\}$ 的补集。\n3. 将椭圆的离心率定义为\n$$\ne = \\sqrt{1 - \\frac{b^2}{a^2}},\n$$\n并为外部谱集定义到围线的谱隙为\n$$\n\\delta_{\\text{out}} = \\min_{\\lambda \\in \\text{exterior}} \\min_{\\theta \\in [0,2\\pi)} |z(\\theta) - \\lambda|.\n$$\n通过采样用于滤波器的相同求积节点来近似 $\\delta_{\\text{out}}$。\n4. 计算沿围线的最坏情况条件数为\n$$\n\\kappa_{\\max} = \\max_{k \\in \\{0,\\dots,m-1\\}} \\kappa_2\\big(z(\\theta_k)I - A\\big),\n$$\n使用上面的正规性事实。\n5. 设 $r(\\lambda)$表示在$\\lambda$处求值的有理滤波器。定义一个先验的每次迭代的 FEAST 收敛率代理指标为\n$$\n\\gamma = \\frac{\\max_{\\lambda \\in \\text{exterior}} |r(\\lambda)|}{\\min_{\\lambda \\in \\text{interior}} |r(\\lambda)|}.\n$$\n该量捕捉了外部和内谱分量之间的衰减比。\n\n所有计算均使用 $m=64$ 个节点。为保证数值稳健性，请使用上面给出的 $A$ 的精确对角线元素，不要添加扰动。\n\n测试套件：\n为以下椭圆 $(a,b)$ 计算元组 $(e,\\delta_{\\text{out}},\\kappa_{\\max},\\gamma)$：\n- 测试 $1$：$(a,b) = (0.5,\\,0.49)$，\n- 测试 $2$：$(a,b) = (0.6,\\,0.59)$，\n- 测试 $3$：$(a,b) = (0.6,\\,0.20)$，\n- 测试 $4$：$(a,b) = (0.7,\\,0.20)$，\n- 测试 $5$：$(a,b) = (0.78,\\,0.20)$。\n\n注意事项和要求：\n- 所有角度均以弧度为单位。\n- 所有输出均为无量纲实数。\n- 您的程序必须生成单行输出，其中包含一个包含五个结果的列表，每个结果本身是按顺序 $[e, \\delta_{\\text{out}}, \\kappa_{\\max}, \\gamma]$ 排列的四个浮点数的列表。例如，要求的整体格式为\n$$\n\\big[\\,[e_1,\\delta_1,\\kappa_1,\\gamma_1],\\,[e_2,\\delta_2,\\kappa_2,\\gamma_2],\\,\\dots,\\,[e_5,\\delta_5,\\kappa_5,\\gamma_5]\\,\\big].\n$$\n不应打印任何额外文本。",
            "solution": "问题陈述是有效的。这是一个在数值线性代数领域内的适定、有科学依据且客观的问题，具体涉及对 FEAST 算法等围线积分特征求解器的分析。计算所需的所有数据、定义和常数均已提供，不存在内部矛盾、模糊不清或违反科学原则之处。该问题要求计算特定指标，以表征 FEAST 算法对于给定矩阵和一组椭圆围线的性能和稳定性。\n\n解决方案通过为每个测试案例实施指定的计算来展开。厄米矩阵 $A \\in \\mathbb{C}^{n \\times n}$ 是对角矩阵，其谱 $\\{\\lambda_i\\}_{i=1}^n$ 作为实值元素给出：\n$$\n\\{\\lambda_i\\} = \\{-1.5, -1.2, -0.9, -0.8, -0.3, -0.1, 0.0, 0.15, 0.25, 0.8, 1.2, 1.5\\}.\n$$\n复围线 $\\Gamma$ 是一个以原点为中心、半轴为 $a$ 和 $b$ 的椭圆，参数化为 $z(\\theta) = a\\cos\\theta + \\mathrm{i}b\\sin\\theta$，其中 $\\theta \\in [0, 2\\pi)$。所有计算将使用均匀梯形求积法则，有 $m=64$ 个节点，$\\theta_k = 2\\pi k/m$，其中 $k \\in \\{0, 1, \\dots, m-1\\}$。\n\n对于每个由一对半轴 $(a,b)$ 定义的测试案例，我们计算一个包含四个值的元组 $(e, \\delta_{\\text{out}}, \\kappa_{\\max}, \\gamma)$。计算步骤如下：\n\n1.  **离心率, $e$**：该值量化了椭圆的形状。它直接根据其定义计算：\n    $$\n    e = \\sqrt{1 - \\frac{b^2}{a^2}}.\n    $$\n\n2.  **谱集**：谱 $\\{\\lambda_i\\}$ 根据半轴 $a$ 被划分为两个集合。内部集包含满足 $|\\lambda_i|  a$ 的特征值 $\\lambda_i$，而外部集包含满足 $|\\lambda_i| \\ge a$ 的特征值 $\\lambda_i$。这些集合对于定义谱隙和收敛代理指标至关重要。\n\n3.  **求积节点和导数**：预先计算围线上的 $m=64$ 个求积点 $z_k = z(\\theta_k)$ 和导数值 $z'(\\theta_k) = \\frac{\\mathrm{d}z}{\\mathrm{d}\\theta}\\big|_{\\theta_k}$，以供后续步骤使用。\n    $$\n    z_k = a\\cos(\\theta_k) + \\mathrm{i}b\\sin(\\theta_k)\n    $$\n    $$\n    z'(\\theta_k) = -a\\sin(\\theta_k) + \\mathrm{i}b\\cos(\\theta_k)\n    $$\n\n4.  **到围线的谱隙, $\\delta_{\\text{out}}$**：此指标衡量从围线 $\\Gamma$ 到外部集中任何特征值的最小距离。通常情况下，较大的谱隙更为有利。它通过找到任意求积节点 $z_k$ 到任意外部特征值 $\\lambda_{\\text{ext}}$ 的最小距离来近似：\n    $$\n    \\delta_{\\text{out}} = \\min_{\\lambda \\in \\text{exterior}} \\min_{k \\in \\{0,\\dots,m-1\\}} |z_k - \\lambda|.\n    $$\n\n5.  **最坏情况条件数, $\\kappa_{\\max}$**：该指标量化了 FEAST 算法中必须求解的线性系统的数值稳定性。对于正规矩阵 $A$，$(zI-A)$ 的 2-范数条件数是 $z$ 到谱的最大距离与最小距离之比。我们计算此值在所有求积节点 $z_k$ 上的最大值：\n    $$\n    \\kappa_{\\max} = \\max_{k \\in \\{0,\\dots,m-1\\}} \\kappa_2(z_kI - A) = \\max_{k \\in \\{0,\\dots,m-1\\}} \\frac{\\max_i |z_k - \\lambda_i|}{\\min_i |z_k - \\lambda_i|}.\n    $$\n\n6.  **有理滤波器响应, $r(\\lambda)$，和收敛代理指标, $\\gamma$**：有理滤波器 $r(\\lambda)$ 是柯西积分 $\\frac{1}{2\\pi \\mathrm{i}} \\oint_\\Gamma (z-\\lambda)^{-1}\\,\\mathrm{d}z$ 的数值近似，对于 $\\Gamma$ 内部的 $\\lambda$ 其值为 $1$，对于外部的 $\\lambda$ 其值为 $0$。对参数化积分使用梯形法则，其值为：\n    $$\n    r(\\lambda) = \\frac{1}{2\\pi \\mathrm{i}} \\sum_{k=0}^{m-1} \\frac{1}{z_k - \\lambda} z'(\\theta_k) \\frac{2\\pi}{m} = \\frac{1}{m\\mathrm{i}} \\sum_{k=0}^{m-1} \\frac{z'(\\theta_k)}{z_k - \\lambda}.\n    $$\n    收敛率代理指标 $\\gamma$ 是外部特征值的最大滤波器响应与内部特征值的最小滤波器响应之比。较小的 $\\gamma$ 表示更好的滤波效果和更快的收敛速度。\n    $$\n    \\gamma = \\frac{\\max_{\\lambda \\in \\text{exterior}} |r(\\lambda)|}{\\min_{\\lambda \\in \\text{interior}} |r(\\lambda)|}.\n    $$\n\n这些步骤被系统地应用于五个测试案例中的每一个，并收集所得的四元素元组。最终的实现封装在一个 Python 脚本中。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes FEAST algorithm performance metrics for a series of elliptical contours.\n    \"\"\"\n\n    # Given spectrum of the diagonal Hermitian matrix A\n    LAMBDAS = np.array([\n        -1.5, -1.2, -0.9, -0.8, -0.3, -0.1, 0.0, 0.15, 0.25, 0.8, 1.2, 1.5\n    ])\n    M = 64  # Number of quadrature nodes\n\n    def calculate_metrics(a, b):\n        \"\"\"\n        Calculates the four required metrics for a given ellipse (a, b).\n        \n        Args:\n            a (float): Semi-axis of the ellipse along the real axis.\n            b (float): Semi-axis of the ellipse along the imaginary axis.\n\n        Returns:\n            list: A list containing [e, delta_out, kappa_max, gamma].\n        \"\"\"\n        \n        # 1. Eccentricity\n        e = np.sqrt(1 - (b/a)**2)\n\n        # 2. Setup quadrature nodes and derivatives\n        thetas = 2 * np.pi * np.arange(M) / M\n        z_nodes = a * np.cos(thetas) + 1j * b * np.sin(thetas)\n        dz_dtheta_nodes = -a * np.sin(thetas) + 1j * b * np.cos(thetas)\n\n        # 3. Partition spectrum and calculate spectral gap delta_out\n        interior_mask = np.abs(LAMBDAS)  a\n        exterior_mask = ~interior_mask\n        \n        interior_lambdas = LAMBDAS[interior_mask]\n        exterior_lambdas = LAMBDAS[exterior_mask]\n\n        # Calculate distances from exterior eigenvalues to contour nodes\n        # Broadcasting: (num_ext_lambdas, 1) - (M,) -> (num_ext_lambdas, M)\n        dist_matrix_ext = np.abs(exterior_lambdas[:, np.newaxis] - z_nodes)\n        \n        if dist_matrix_ext.size > 0:\n            delta_out = np.min(dist_matrix_ext)\n        else:\n            delta_out = np.inf # Should not happen with given test cases\n\n        # 4. Worst-case conditioning kappa_max\n        # Broadcasting: (M, 1) - (num_lambdas,) -> (M, num_lambdas)\n        dist_matrix_all = np.abs(z_nodes[:, np.newaxis] - LAMBDAS)\n        \n        max_dists_per_zk = np.max(dist_matrix_all, axis=1)\n        min_dists_per_zk = np.min(dist_matrix_all, axis=1)\n        \n        # Avoid division by zero if a node lands on an eigenvalue (unlikely)\n        kappas = np.divide(max_dists_per_zk, min_dists_per_zk, \n                           out=np.full_like(max_dists_per_zk, np.inf), \n                           where=min_dists_per_zk!=0)\n        kappa_max = np.max(kappas)\n\n        # 5. Filter response r(lambda) and convergence proxy gamma\n        # Broadcasting: (M,) / ((num_lambdas, 1) - (M,)) -> (num_lambdas, M)\n        # Note the expression z-lambda in the denominator\n        integrand = dz_dtheta_nodes / (z_nodes - LAMBDAS[:, np.newaxis])\n        r_values = (1 / (M * 1j)) * np.sum(integrand, axis=1)\n        \n        r_interior = r_values[interior_mask]\n        r_exterior = r_values[exterior_mask]\n\n        if r_interior.size == 0 or r_exterior.size == 0:\n            gamma = np.inf # Should not happen\n        else:\n            max_r_ext = np.max(np.abs(r_exterior))\n            min_r_int = np.min(np.abs(r_interior))\n            gamma = max_r_ext / min_r_int if min_r_int != 0 else np.inf\n\n        return [e, delta_out, kappa_max, gamma]\n\n    test_cases = [\n        (0.5, 0.49),\n        (0.6, 0.59),\n        (0.6, 0.20),\n        (0.7, 0.20),\n        (0.78, 0.20),\n    ]\n\n    results = []\n    for a_val, b_val in test_cases:\n        result = calculate_metrics(a_val, b_val)\n        results.append(result)\n\n    # Format the final output string to match the problem specification\n    # e.g., [[e1,d1,k1,g1],[e2,d2,k2,g2],...] with no spaces\n    inner_strings = [f\"[{','.join(map(str, res))}]\" for res in results]\n    final_output = f\"[{','.join(inner_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n\n```"
        },
        {
            "introduction": "现实世界的问题常常包含聚集的特征值，导致矩阵接近亏损，这对许多特征求解器构成了重大挑战。这个高级实践研究了FEAST算法在这种困难情况下的行为，使用一个 $2\\times 2$ 的Jordan块模型来揭示求积点数量与算法处理幂零部分能力之间一个令人惊讶的关系。这个练习解释了常见的收敛停滞现象，并揭示了如何通过谨慎选择求积方法来缓解这一问题。",
            "id": "3541135",
            "problem": "考虑由下式定义的 $2\\times 2$ 上三角矩阵族 $\\{A_{\\epsilon}\\}_{\\epsilon\\ge 0}$\n$$\nA_{\\epsilon} = \\begin{bmatrix} \\lambda+\\epsilon  1 \\\\ 0  \\lambda-\\epsilon \\end{bmatrix}\n= \\lambda I + N + \\epsilon \\begin{bmatrix} 1  0 \\\\ 0  -1 \\end{bmatrix},\n\\quad\nN = \\begin{bmatrix} 0  1 \\\\ 0  0 \\end{bmatrix},\\quad N^2=0,\n$$\n因此 $A_0 = \\lambda I + N$ 是一个特征值为 $\\lambda$ 的 $2\\times 2$ Jordan 块。设谱投影算子 $\\Pi$ 投射到由正向单闭合围线 $\\Gamma$ 所包围的特征值相关联的不变子空间上，该算子由 Riesz 积分给出\n$$\n\\Pi = \\frac{1}{2\\pi i} \\oint_{\\Gamma} (zI - A_{\\epsilon})^{-1}\\,dz.\n$$\n轮廓积分特征求解器 (FEAST) 通过使用求积法则近似轮廓积分来构造有理滤波器。使用中心为 $c\\in\\mathbb{C}$、半径为 $r>0$ 的圆形围线 $\\Gamma$，参数化为 $z(\\theta) = c + r e^{i\\theta}$，并采用具有 $K$ 个等距节点 $\\theta_k = \\tfrac{2\\pi k}{K}$ (其中 $k=0,1,\\dots,K-1$) 的梯形法则，得到离散 FEAST 滤波器\n$$\nF_K(A_{\\epsilon};c,r) \\equiv \\sum_{k=0}^{K-1} \\omega_k \\left(z_k I - A_{\\epsilon}\\right)^{-1}, \n\\quad z_k = c + r e^{i\\theta_k}, \n\\quad \\omega_k = \\frac{\\Delta\\theta}{2\\pi i} z'(\\theta_k) = \\frac{r e^{i\\theta_k}}{K},\n$$\n其中 $\\Delta\\theta = \\tfrac{2\\pi}{K}$ 且 $z'(\\theta) = i r e^{i\\theta}$。对于 Jordan 极限 $\\epsilon=0$ 和 $c=\\lambda$，预解式具有幂零展开\n$$\n(zI - A_0)^{-1} = (z - \\lambda)^{-1} I + (z - \\lambda)^{-2} N,\n$$\n因此，一次 FEAST 应用对应于离散矩求和\n$$\nF_K(A_0;\\lambda,r)\n= \\left(\\sum_{k=0}^{K-1} \\omega_k (z_k-\\lambda)^{-1}\\right) I \n+ \\left(\\sum_{k=0}^{K-1} \\omega_k (z_k-\\lambda)^{-2}\\right) N.\n$$\n从第一性原理出发，分析离散矩在 $\\epsilon\\to 0$ 时的行为，以及 FEAST 的子空间迭代如何濾除幂零贡献。具体而言：\n- 使用上述求积法则，推导当 $\\epsilon=0$ 时幂零项系数的相消模式。证明对于任意 $K\\ge 2$，幂零项完全消失，而对于 $K=1$ 它仍然存在且具有明确的量值。\n- 对于 $\\epsilon>0$，计算由离散滤波器产生的非对角系数，\n$$\n\\alpha_{K}(\\epsilon) \\equiv \\left[F_K(A_{\\epsilon};\\lambda,r)\\right]_{12} = \\sum_{k=0}^{K-1} \\omega_k \\left((z_k-\\lambda-\\epsilon)^{-1}(z_k-\\lambda+\\epsilon)^{-1}\\right),\n$$\n并为其衰减建立一个区分 $K$ 的奇偶性的小 $\\epsilon$ 渐近预测。\n- 解释 FEAST 子空间迭代中的停滯模式：将 $\\alpha_K(\\epsilon)$ 解释为单次滤波器应用后保留的残余幂零贡献，并将其依赖于奇偶性的行为与重复 FEAST 步骤是否能立即消除幂零部分或只能以由 $\\epsilon$ 和 $K$ 控制的速率减小它联系起来。\n\n实现要求：\n- 固定 $\\lambda=0$ 和 $c=\\lambda=0$。\n- 固定 $r=0.5$。\n- 使用复数算术，完全按照上述定义实现离散 FEAST 滤波器 $F_K(A_{\\epsilon};0,0.5)$。\n- 对于每个测试用例，计算标量 $\\alpha_K(\\epsilon)$，即 $F_K(A_{\\epsilon};0,0.5)$ 的 $(1,2)$ 元的模，也就是计算 $\\left|\\left[F_K(A_{\\epsilon};0,0.5)\\right]_{12}\\right|$ 作为实值浮点数。\n\n测试套件：\n- 案例 1 (边界，单节点)：$\\epsilon = 0.0$, $K = 1$。\n- 案例 2 (最小精确相消)：$\\epsilon = 0.0$, $K = 2$。\n- 案例 3 (近亏损，偶数宇称精确性)：$\\epsilon = 10^{-6}$, $K = 2$。\n- 案例 4 (近亏损，奇数宇称首项非零)：$\\epsilon = 10^{-6}$, $K = 3$。\n- 案例 5 (中度近亏损，奇数宇称缩放)：$\\epsilon = 10^{-3}$, $K = 3$。\n- 案例 6 (更高阶奇数宇称，更强抑制)：$\\epsilon = 10^{-3}$, $K = 5$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3,result4,result5,result6]”），其中每个结果是相应测试用例的实值浮点数 $\\left|\\left[F_K(A_{\\epsilon};0,0.5)\\right]_{12}\\right|$。",
            "solution": "该问题要求分析离散 FEAST 滤波器 $F_K(A_{\\epsilon};c,r)$ 应用于一族近亏损矩阵 $A_{\\epsilon}$ 时的行为。分析的重点是滤波后矩阵的 $(1,2)$ 元（记为 $\\alpha_K(\\epsilon)$）的行为，特别是其对求积点数 $K$ 和扰动参数 $\\epsilon$ 的依赖性。\n\n首先，我们求出必要的逆矩阵。预解式 $(zI - A_{\\epsilon})^{-1}$ 是分析的核心。给定 $A_{\\epsilon} = \\begin{bmatrix} \\lambda+\\epsilon  1 \\\\ 0  \\lambda-\\epsilon \\end{bmatrix}$，其逆矩阵为：\n$$\n(zI - A_{\\epsilon})^{-1} = \\begin{bmatrix} z - (\\lambda+\\epsilon)  -1 \\\\ 0  z - (\\lambda-\\epsilon) \\end{bmatrix}^{-1}\n= \\frac{1}{(z - \\lambda - \\epsilon)(z - \\lambda + \\epsilon)}\n\\begin{bmatrix} z - (\\lambda-\\epsilon)  1 \\\\ 0  z - (\\lambda-\\epsilon) \\end{bmatrix}\n$$\n预解式的 $(1,2)$ 元是 $\\frac{1}{(z - \\lambda - \\epsilon)(z - \\lambda + \\epsilon)}$。\n待计算的量 $\\alpha_K(\\epsilon)$ 是离散滤波器 $F_K(A_{\\epsilon};\\lambda,r)$ 的 $(1,2)$ 元。根据滤波器的定义，我们有：\n$$\n\\alpha_{K}(\\epsilon) \\equiv \\left[F_K(A_{\\epsilon};\\lambda,r)\\right]_{12} = \\sum_{k=0}^{K-1} \\omega_k \\left[(z_k I - A_{\\epsilon})^{-1}\\right]_{12} = \\sum_{k=0}^{K-1} \\omega_k \\frac{1}{(z_k - \\lambda - \\epsilon)(z_k - \\lambda + \\epsilon)}\n$$\n对于以 $c=\\lambda$ 为中心的指定圆形围线，求积点为 $z_k = \\lambda + r e^{i\\theta_k}$，权重为 $\\omega_k = \\frac{r e^{i\\theta_k}}{K}$。将这些代入 $\\alpha_K(\\epsilon)$ 的表达式中可得：\n$$\n\\alpha_{K}(\\epsilon) = \\sum_{k=0}^{K-1} \\frac{r e^{i\\theta_k}}{K} \\frac{1}{(r e^{i\\theta_k} - \\epsilon)(r e^{i\\theta_k} + \\epsilon)} = \\sum_{k=0}^{K-1} \\frac{r e^{i\\theta_k}}{K} \\frac{1}{r^2 e^{i2\\theta_k} - \\epsilon^2}\n$$\n\n现在我们来处理具体的分析任务。\n\n**1. Jordan 极限分析 ($\\epsilon=0$)**\n\n当 $\\epsilon=0$ 时，矩阵变为一个 Jordan 块 $A_0 = \\lambda I + N$。$\\alpha_K(0)$ 的表达式简化为：\n$$\n\\alpha_K(0) = \\sum_{k=0}^{K-1} \\frac{r e^{i\\theta_k}}{K} \\frac{1}{r^2 e^{i2\\theta_k}} = \\frac{1}{Kr} \\sum_{k=0}^{K-1} e^{-i\\theta_k}\n$$\n该和式是单位的 $K$ 次根的几何级数。具体来说，当 $\\theta_k = \\frac{2\\pi k}{K}$ 时，和为 $\\sum_{k=0}^{K-1} (e^{-i2\\pi/K})^k$。\n几何级数 $\\sum_{k=0}^{K-1} q^k$ 的和在 $q\\neq 1$ 时等于 $\\frac{1-q^K}{1-q}$，在 $q=1$ 时等于 $K$。\n\n- 对于 $K=1$，公比为 $e^{-i2\\pi} = 1$。和为 $1$。因此，\n    $$\n    \\alpha_1(0) = \\frac{1}{(1)r} \\cdot 1 = \\frac{1}{r}\n    $$\n    幂零贡献仍然存在，其量值与围线半径 $r$ 成反比。\n\n- 对于 $K \\ge 2$，公比为 $q = e^{-i2\\pi/K} \\neq 1$。和为：\n    $$\n    \\sum_{k=0}^{K-1} (e^{-i2\\pi/K})^k = \\frac{1 - (e^{-i2\\pi/K})^K}{1 - e^{-i2\\pi/K}} = \\frac{1 - e^{-i2\\pi}}{1 - e^{-i2\\pi/K}} = \\frac{1-1}{1 - e^{-i2\\pi/K}} = 0\n    $$\n    因此，对于任意 $K \\ge 2$：\n    $$\n    \\alpha_K(0) = 0\n    $$\n    这表明，当使用具有 $K \\ge 2$ 个节点的梯形法则来近似 Jordan 块预解式展开中的 $(z-\\lambda)^{-2}N$ 项的围线积分时，幂零项系数会精确相消。\n\n**2. $\\epsilon > 0$ 的渐近分析**\n\n对于满足 $|\\epsilon|  r$ 的小 $\\epsilon$，我们通过对分母项进行泰勒级数展开来分析 $\\alpha_K(\\epsilon)$：\n$$\n\\frac{1}{r^2 e^{i2\\theta_k} - \\epsilon^2} = \\frac{1}{r^2 e^{i2\\theta_k}} \\left( \\frac{1}{1 - (\\epsilon/r)^2 e^{-i2\\theta_k}} \\right) = \\frac{e^{-i2\\theta_k}}{r^2} \\sum_{j=0}^{\\infty} \\left(\\frac{\\epsilon}{r}\\right)^{2j} e^{-i2j\\theta_k}\n$$\n将此代入 $\\alpha_K(\\epsilon)$ 的表达式中：\n$$\n\\alpha_K(\\epsilon) = \\sum_{k=0}^{K-1} \\frac{r e^{i\\theta_k}}{K} \\left( \\frac{e^{-i2\\theta_k}}{r^2} \\sum_{j=0}^{\\infty} \\left(\\frac{\\epsilon}{r}\\right)^{2j} e^{-i2j\\theta_k} \\right) = \\frac{1}{Kr} \\sum_{j=0}^{\\infty} \\left(\\frac{\\epsilon}{r}\\right)^{2j} \\sum_{k=0}^{K-1} e^{-i(2j+1)\\theta_k}\n$$\n内层和 $\\sum_{k=0}^{K-1} e^{-i(2j+1)2\\pi k/K}$ 是另一个单位根的几何和。如果 $K$ 整除 $2j+1$，则其值等于 $K$，否则等于 $0$。我们考虑 $K$ 的奇偶性。\n\n- **偶数 $K$**：设 $K=2p$，其中 $p \\ge 1$ 为整数。偶数的整数倍总是偶数，$mK=m(2p)$。然而，对于任何整数 $j \\ge 0$，$2j+1$ 总是奇数。因此，$2j+1$ 永远不可能是偶数 $K$ 的倍数。这意味着对于所有 $j \\ge 0$，内层和均为零。因此，对于任意偶数 $K \\ge 2$：\n    $$\n    \\alpha_K(\\epsilon) = 0\n    $$\n    这是一个显著的结果：具有偶数个节点的离散滤波器不仅对亏损情况 $\\epsilon=0$ 完全消除了非对角耦合，而且对非亏損、近简并情况 $\\epsilon>0$ 也同样如此。\n\n- **奇数 $K$**：设 $K=2p+1$，其中 $p \\ge 1$ 为整数。现在 $K$ 可能整除 $2j+1$。$\\alpha_K(\\epsilon)$ 的级数展开将包含非零项。首项对应于使 $K$ 整除 $2j+1$ 的最小非负整数 $j$。由于 $K$ 是奇数，我们可以选择乘数 $m=1$，得到 $2j+1=K$，即 $j = (K-1)/2$。因为 $K$ 是奇数，所以这是一个整数。下一个非零项将出现在 $2j+1=3K$ 时，即 $j=(3K-1)/2$。对于小 $\\epsilon$ 的渐近预测，我们只需要首项，其中 $j=(K-1)/2$：\n    $$\n    \\alpha_K(\\epsilon) = \\frac{1}{Kr} \\left( \\left(\\frac{\\epsilon}{r}\\right)^{2j} \\cdot K \\right) + O(\\epsilon^{2j+2}) \\quad \\text{with } j=\\frac{K-1}{2}\n    $$\n    $$\n    \\alpha_K(\\epsilon) = \\frac{1}{r} \\left(\\frac{\\epsilon}{r}\\right)^{K-1} + O(\\epsilon^{K+1}) = \\frac{\\epsilon^{K-1}}{r^K} + O(\\epsilon^{K+1})\n    $$\n    对于奇数 $K$，非对角系数非零，并以 $\\epsilon^{K-1}$ 的速率衰减。\n\n**3. FEAST 停滯模式的解释**\n\n量 $\\alpha_K(\\epsilon)$ 代表了应用一次 FEAST 滤波器后残余的幂零贡献，即持续存在的非对角耦合。FEAST 中的子空间迭代旨在投影出所需不变子空间之外的分量。对于近亏损问题，这对应于分离与聚集的特征值相关的特征向量。\n\n- 当使用**偶数**个求积点（$K \\ge 2$）时，$\\alpha_K(\\epsilon)=0$。滤波后的矩阵 $F_K(A_{\\epsilon};\\lambda,r)$ 是对角矩阵（其 $(1,2)$ 元为零，并且根据 $A_\\epsilon$ 的结构其 $(2,1)$ 元也为零）。这意味着滤波器在单一步骤中就完美地解耦了张成不变子空间的基向量。FEAST 的子空间迭代将立即收敛到正确的子空间，不会出现任何与近简并相关的停滞。\n\n- 当使用**奇数**个求积点（$K$）时，$\\alpha_K(\\epsilon) \\approx \\epsilon^{K-1}/r^K \\neq 0$。滤波后的矩阵仍然是上三角矩阵，但具有一个小的非零非对角元素。这意味着单次滤波器应用不能完全解耦特征向量。相反，它将耦合从 $A_\\epsilon$ 中的 $O(1)$ 减小到 $O(\\epsilon^{K-1})$。重复应用 FEAST 将继续减小这种耦合，但收敛速率将受此因素限制。对于非常小的 $\\epsilon$，收敛最初可能看起来很快，但一旦子空间中的误差达到 $|\\alpha_K(\\epsilon)|$ 的量级，收敛就会“停滞”或急剧减慢。改进的速率变成关于 $\\epsilon$ 的代数速率，而不是像分離良好的特征值那样的几何速率。增加（奇数）节点数 $K$ 可以改善对幂零部分的抑制，因为残差随 $\\epsilon$ 衰减得更快（如 $\\epsilon^{K-1}$）。\n\n总之，FEAST 算法中求积节点数 $K$ 的奇偶性对其在近亏损问题上的性能至关重要。对于这个 $2 \\times 2$ 模型，偶数 $K$ 提供了非对角耦合的精确相消，从而避免了停滞，而奇数 $K$ 则导致了可预测的残余耦合，这解释了实践中观察到的典型停滞行为。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the magnitude of the (1,2) entry of the discrete FEAST filter \n    for a family of nearly-defective matrices.\n    \"\"\"\n    \n    # Fixed parameters from the problem statement\n    r = 0.5  # Contour radius\n    # lambda and c are zero\n\n    test_cases = [\n        # (epsilon, K)\n        (0.0, 1),\n        (0.0, 2),\n        (1e-6, 2),\n        (1e-6, 3),\n        (1e-3, 3),\n        (1e-3, 5),\n    ]\n\n    results = []\n\n    def compute_alpha(epsilon: float, K: int, r_val: float) - float:\n        \"\"\"\n        Calculates the scalar quantity alpha_K(epsilon) as the magnitude \n        of the (1,2) entry of the discrete FEAST filter F_K(A_epsilon; 0, r).\n\n        alpha_K(epsilon) = sum_{k=0}^{K-1} omega_k * 1/((z_k - epsilon)*(z_k + epsilon))\n                         = sum_{k=0}^{K-1} omega_k / (z_k^2 - epsilon^2)\n        \n        where z_k = r * exp(i*theta_k) and omega_k = r * exp(i*theta_k) / K = z_k / K.\n        \"\"\"\n        \n        alpha = 0.0 + 0.0j\n        \n        # This handles the K=0 case, though not in test suite.\n        if K == 0:\n            return 0.0\n\n        for k in range(K):\n            # Quadrature node\n            theta_k = 2 * np.pi * k / K\n            z_k = r_val * np.exp(1j * theta_k)\n            \n            # Quadrature weight\n            # The definition is omega_k = (r * exp(i*theta_k)) / K\n            # This is simply z_k / K\n            omega_k = z_k / K\n            \n            # Denominator term\n            # In the degenerate case epsilon=0, z_k**2 could be zero if r=0, but r=0.5\n            denominator = z_k**2 - epsilon**2\n            \n            # Add the contribution from the k-th node\n            # The formula for the (1,2) entry is derived in the text\n            if np.abs(denominator)  1e-18: # Avoid division by zero for exotic cases\n                # This branch is not expected to be hit with the given parameters,\n                # as |z_k|=r=0.5 and epsilon is small.\n                # A more robust implementation might need careful handling here.\n                # For this problem, it is safe.\n                pass\n            \n            alpha += omega_k / denominator\n\n        return np.abs(alpha)\n\n    for epsilon, K in test_cases:\n        result = compute_alpha(epsilon, K, r)\n        results.append(result)\n\n    # Format the final output as a comma-separated list in brackets\n    print(f\"[{','.join(f'{res:.16e}' for res in results)}]\")\n\nsolve()\n```"
        }
    ]
}