{
    "hands_on_practices": [
        {
            "introduction": "矩阵乘法不仅仅是一种计算工具，它所代表的线性变换具有丰富的代数性质。与标量乘法不同，矩阵乘法通常不满足交换律。本练习将让你通过计算交换子 $[A,B]=AB-BA$ 来直接感受这一基本性质，并使用算子范数来量化非交换的程度，从而将抽象的代数概念与具体的数值联系起来 。",
            "id": "3559507",
            "problem": "设 $n=4$。考虑由下式给出的矩阵 $A \\in \\mathbb{R}^{4 \\times 4}$ 和 $B \\in \\mathbb{R}^{4 \\times 4}$\n$$\nA=\\begin{pmatrix}\n0  1  0  0 \\\\\n0  0  1  0 \\\\\n0  0  0  1 \\\\\n0  0  0  0\n\\end{pmatrix}, \\qquad\nB=\\operatorname{diag}(1,3,-2,7)=\\begin{pmatrix}\n1  0  0  0 \\\\\n0  3  0  0 \\\\\n0  0  -2  0 \\\\\n0  0  0  7\n\\end{pmatrix}.\n$$\n仅使用矩阵-矩阵乘法和诱导矩阵范数的基本定义，执行以下步骤：\n- 显式计算换位子 $[A,B]=AB-BA$ 并验证 $AB \\neq BA$。\n- 使用由欧几里得范数诱导的算子范数的定义，即\n$$\n\\|M\\|_{2}=\\sup_{x \\neq 0} \\frac{\\|Mx\\|_{2}}{\\|x\\|_{2}},\n$$\n精确计算 $\\|[A,B]\\|_{2}$，并从第一性原理（矩阵乘法法则、对称矩阵的性质和瑞利商）出发证明每一步。\n\n将您的最终答案以单个实数的形式给出。无需四舍五入。",
            "solution": "该问题提法明确且自成体系。所有必需的矩阵和定义均已给出，不存在科学或逻辑上的矛盾。我们可以着手求解。\n\n该问题要求完成两个主要任务：首先，对于给定的矩阵 $A$ 和 $B$，计算其换位子 $[A,B]=AB-BA$ 并验证它们不对易；其次，使用基本原理计算该换位子的诱导 $2$-范数 $\\|[A,B]\\|_{2}$。\n\n设矩阵 $A$ 和 $B$ 定义如下：\n$$\nA=\\begin{pmatrix}\n0  1  0  0 \\\\\n0  0  1  0 \\\\\n0  0  0  1 \\\\\n0  0  0  0\n\\end{pmatrix}, \\qquad\nB=\\begin{pmatrix}\n1  0  0  0 \\\\\n0  3  0  0 \\\\\n0  0  -2  0 \\\\\n0  0  0  7\n\\end{pmatrix}.\n$$\n\n首先，我们计算乘积 $AB$。对于一个通用矩阵 $M$ 和一个对角矩阵 $D$，乘积 $MD$ 是将矩阵 $M$ 的第 $j$ 列乘以 $D$ 的第 $j$ 个对角元素的矩阵。\n因此，$AB$ 的各列是 $A$ 的各列分别乘以 $B$ 的对角元素 $1$、$3$、$-2$ 和 $7$。\n$$\nAB = \\begin{pmatrix}\n0 \\cdot 1  1 \\cdot 3  0 \\cdot (-2)  0 \\cdot 7 \\\\\n0 \\cdot 1  0 \\cdot 3  1 \\cdot (-2)  0 \\cdot 7 \\\\\n0 \\cdot 1  0 \\cdot 3  0 \\cdot (-2)  1 \\cdot 7 \\\\\n0 \\cdot 1  0 \\cdot 3  0 \\cdot (-2)  0 \\cdot 7\n\\end{pmatrix} = \\begin{pmatrix}\n0  3  0  0 \\\\\n0  0  -2  0 \\\\\n0  0  0  7 \\\\\n0  0  0  0\n\\end{pmatrix}.\n$$\n\n接下来，我们计算乘积 $BA$。对于一个通用矩阵 $M$ 和一个对角矩阵 $D$，乘积 $DM$ 是将矩阵 $M$ 的第 $i$ 行乘以 $D$ 的第 $i$ 个对角元素的矩阵。\n因此，$BA$ 的各行是 $A$ 的各行分别乘以 $B$ 的对角元素。\n$$\nBA = \\begin{pmatrix}\n1 \\cdot 0  1 \\cdot 1  1 \\cdot 0  1 \\cdot 0 \\\\\n3 \\cdot 0  3 \\cdot 0  3 \\cdot 1  3 \\cdot 0 \\\\\n-2 \\cdot 0  -2 \\cdot 0  -2 \\cdot 0  -2 \\cdot 1 \\\\\n7 \\cdot 0  7 \\cdot 0  7 \\cdot 0  7 \\cdot 0\n\\end{pmatrix} = \\begin{pmatrix}\n0  1  0  0 \\\\\n0  0  3  0 \\\\\n0  0  0  -2 \\\\\n0  0  0  0\n\\end{pmatrix}.\n$$\n\n通过比较得到的矩阵，我们看到 $(AB)_{12} = 3$ 而 $(BA)_{12} = 1$。由于至少有一个元素不同，这两个矩阵不相等，从而验证了 $AB \\neq BA$。\n\n现在，我们计算换位子，记作 $C$：\n$$\nC = [A,B] = AB - BA = \\begin{pmatrix}\n0  3  0  0 \\\\\n0  0  -2  0 \\\\\n0  0  0  7 \\\\\n0  0  0  0\n\\end{pmatrix} - \\begin{pmatrix}\n0  1  0  0 \\\\\n0  0  3  0 \\\\\n0  0  0  -2 \\\\\n0  0  0  0\n\\end{pmatrix} = \\begin{pmatrix}\n0  2  0  0 \\\\\n0  0  -5  0 \\\\\n0  0  0  9 \\\\\n0  0  0  0\n\\end{pmatrix}.\n$$\n\n问题的第二部分要求我们计算 $\\|C\\|_{2}$。矩阵 $M$ 的诱导 $2$-范数定义为：\n$$\n\\|M\\|_{2} = \\sup_{x \\neq 0} \\frac{\\|Mx\\|_{2}}{\\|x\\|_{2}} = \\sup_{\\|x\\|_{2}=1} \\|Mx\\|_{2}.\n$$\n处理范数的平方会更方便：\n$$\n\\|M\\|_{2}^2 = \\sup_{\\|x\\|_{2}=1} \\|Mx\\|_{2}^2.\n$$\n向量 $v$ 的欧几里得范数的平方是 $v^T v$。因此，$\\|Mx\\|_{2}^2 = (Mx)^T(Mx) = x^T M^T M x$。\n将此代入范数平方的表达式中，得到：\n$$\n\\|M\\|_{2}^2 = \\sup_{\\|x\\|_{2}=1} x^T M^T M x.\n$$\n表达式 $\\frac{x^T M^T M x}{x^T x}$ 是矩阵 $M^T M$ 的瑞利商（Rayleigh quotient）。矩阵 $M^T M$ 是对称且半正定的。根据瑞利-里兹定理（Rayleigh-Ritz theorem），对称矩阵的瑞利商的上确界是其最大特征值 $\\lambda_{\\max}(M^T M)$。因此，$\\|M\\|_{2}^2 = \\lambda_{\\max}(M^T M)$，这意味着 $\\|M\\|_{2} = \\sqrt{\\lambda_{\\max}(M^T M)}$。\n\n我们将此原理应用于我们的换位子矩阵 $C$。首先，我们计算 $C^T$，然后计算 $C^T C$：\n$$\nC = \\begin{pmatrix}\n0  2  0  0 \\\\\n0  0  -5  0 \\\\\n0  0  0  9 \\\\\n0  0  0  0\n\\end{pmatrix}, \\qquad\nC^T = \\begin{pmatrix}\n0  0  0  0 \\\\\n2  0  0  0 \\\\\n0  -5  0  0 \\\\\n0  0  9  0\n\\end{pmatrix}.\n$$\n现在，我们计算乘积 $C^T C$：\n$$\nC^T C = \\begin{pmatrix}\n0  0  0  0 \\\\\n2  0  0  0 \\\\\n0  -5  0  0 \\\\\n0  0  9  0\n\\end{pmatrix}\n\\begin{pmatrix}\n0  2  0  0 \\\\\n0  0  -5  0 \\\\\n0  0  0  9 \\\\\n0  0  0  0\n\\end{pmatrix} = \\begin{pmatrix}\n0  0  0  0 \\\\\n0  4  0  0 \\\\\n0  0  25  0 \\\\\n0  0  0  81\n\\end{pmatrix}.\n$$\n矩阵 $C^T C$ 是一个对角矩阵。对角矩阵的特征值就是其对角元素。因此，$C^T C$ 的特征值为 $\\lambda_1 = 0$、$\\lambda_2 = 4$、$\\lambda_3 = 25$ 和 $\\lambda_4 = 81$。\n\n最大特征值为 $\\lambda_{\\max}(C^T C) = 81$。\n使用从第一性原理推导出的关系，我们有：\n$$\n\\|C\\|_{2}^2 = \\lambda_{\\max}(C^T C) = 81.\n$$\n取平方根，得到诱导 $2$-范数的值：\n$$\n\\|C\\|_{2} = \\sqrt{81} = 9.\n$$\n因此，$\\|[A,B]\\|_{2}$ 的精确值为 $9$。",
            "answer": "$$\\boxed{9}$$"
        },
        {
            "introduction": "在许多科学与工程应用中，矩阵绝大多数是稀疏的，即大部分元素为零，因此使用朴素的乘法算法将极其低效。本练习挑战你像算法设计者一样思考，利用图论来对矩阵的稀疏性进行建模，并推导乘积中非零元素数量（即“填充”）的上限，这是决定稀疏矩阵运算内存和计算成本的关键因素 。",
            "id": "3559483",
            "problem": "设 $A \\in \\mathbb{R}^{m \\times n}$ 和 $B \\in \\mathbb{R}^{n \\times p}$ 为具有一般非零值的稀疏矩阵（假设乘积中任何结构上的非零元在数值上非零的概率为一，即没有对抗性抵消）。考虑二分图 $G_A = (R \\cup J, E_A)$ 和 $G_B = (J \\cup K, E_B)$，它们分别编码了 $A$ 和 $B$ 的稀疏模式，其中 $R = \\{1,2,\\dots,m\\}$ 为 $A$ 的行索引，$J = \\{1,2,\\dots,n\\}$ 为共享的内积维度索引，$K = \\{1,2,\\dots,p\\}$ 为 $B$ 的列索引。对于 $j \\in J$，定义度 $a_j = |\\{ i \\in R : (i,j) \\in E_A \\}|$，即矩阵 $A$ 第 $j$ 列的非零元数量，以及 $b_j = |\\{ k \\in K : (j,k) \\in E_B \\}|$，即矩阵 $B$ 第 $j$ 行的非零元数量。\n\n要求您为 $C = AB$ 设计一个乘法算法，该算法通过操作二分图 $G_A$ 和 $G_B$ 并使用数据结构来利用 $A$ 和 $B$ 稀疏模式中的重叠部分，以避免当多个内积索引 $j \\in J$ 对同一输出位置有贡献时产生的冗余工作。具体来说，该算法必须：\n- 在一个符号阶段计算 $C$ 的结构模式，该阶段避免当通过多个 $j \\in J$ 到达相同位置 $(i,k)$ 时重复插入。\n- 在随后的一个数值计算阶段，仅使用符号阶段中识别出的结构上必要的标量乘法和加法来计算数值。\n- 可用标准稀疏格式实现，例如 $A$ 使用压缩稀疏行 (CSR) 格式，$B$ 使用压缩稀疏列 (CSC) 格式，其渐进工作量由度 $\\{a_j\\}_{j=1}^{n}$ 和 $\\{b_j\\}_{j=1}^{n}$ 界定。\n\n从矩阵乘法的基本定义 $C_{ik} = \\sum_{j=1}^{n} A_{ij} B_{jk}$，以及图论解释（即 $C_{ik}$ 中存在一个结构性非零元，当且仅当存在某个 $j \\in J$ 使得 $(i,j) \\in E_A$ 且 $(j,k) \\in E_B$）出发，推导 $C$ 中结构性非零元总数的一个最坏情况上界，该上界仅依赖于度 $\\{a_j\\}_{j=1}^{n}$ 和 $\\{b_j\\}_{j=1}^{n}$（不要引入特定于问题的常数或可调参数）。将此界表示为仅含 $\\{a_j\\}$ 和 $\\{b_j\\}$ 的单个封闭形式解析表达式。\n\n您的最终数值输出应该是这个界，写成单个解析表达式。不要给出不等式，也不要给出方程；只提供界表达式本身。无需四舍五入，也无物理单位适用。",
            "solution": "该问题要求计算乘积矩阵 $C = AB$ 中结构性非零元数量的最坏情况上界，其中 $A \\in \\mathbb{R}^{m \\times n}$ 和 $B \\in \\mathbb{R}^{n \\times p}$ 是稀疏矩阵。该界必须完全用给定的度 $\\{a_j\\}_{j=1}^{n}$ 和 $\\{b_j\\}_{j=1}^{n}$ 来表示。\n\n首先，我们必须对问题陈述进行验证。\n该问题在数值线性代数和图论领域具有科学依据。它使用了稀疏矩阵乘法、稀疏模式的图表示以及基于度的分析的标准定义。“无对抗性抵消”之类的假设在稀疏矩阵算法分析中很常见，用于将结构属性与数值属性分开。这个问题是适定的，因为它要求基于一组完整的给定条件推导出一个具体的、可导出的量（最坏情况上界）。其语言客观、正式。没有矛盾、信息缺失或伪科学主张。该问题是稀疏矩阵计算理论分析中的一个有效且标准的练习。我们可以继续进行求解。\n\n乘积矩阵 $C$ 中位置 $(i, k)$ 处的元素由矩阵乘法法则定义：\n$$\nC_{ik} = \\sum_{j=1}^{n} A_{ij} B_{jk}\n$$\n如果存在至少一个索引 $j \\in \\{1, 2, \\dots, n\\}$ 使得 $A_{ij}$ 和 $B_{jk}$ 都结构性非零，则位置 $(i, k)$ 处存在一个结构性非零元。问题陈述指出，我们可以假设如果存在结构性非零元，则其数值也非零。让我们将 $C$ 中结构性非零元的数量表示为 $nnz(C)$。\n\n问题提供了一个图论解释。$A$ 的稀疏模式由二分图 $G_A = (R \\cup J, E_A)$ 编码，其中当且仅当 $A_{ij} \\neq 0$ 时，边 $(i, j) \\in E_A$ 存在。类似地，$B$ 的稀疏性由 $G_B = (J \\cup K, E_B)$ 表示，其中当且仅当 $B_{jk} \\neq 0$ 时，边 $(j, k) \\in E_B$ 存在。\n\n在这个框架中，如果存在一条从顶点 $i \\in R$ 经过某个中间顶点 $j \\in J$ 到达顶点 $k \\in K$ 的长度为 2 的路径，则存在一个结构性非零元 $C_{ik}$。因此，与 $C$ 中结构性非零元对应的所有对 $(i, k)$ 的集合，我们可以表示为 $S_C$，是：\n$$\nS_C = \\{ (i,k) \\in R \\times K \\mid \\exists j \\in J \\text{ such that } (i,j) \\in E_A \\text{ and } (j,k) \\in E_B \\}\n$$\n需要界定的量是 $nnz(C) = |S_C|$。\n\n让我们分析单个中间索引 $j \\in J$ 的贡献。对于一个固定的 $j$，接收贡献的对 $(i, k)$ 的集合由 $A$ 的第 $j$ 列和 $B$ 的第 $j$ 行中的非零元决定。设 $R_j$ 是 $A$ 的第 $j$ 列有非零元的行索引集合，而 $K_j$ 是 $B$ 的第 $j$ 行有非零元的列索引集合。\n$$\nR_j = \\{ i \\in R \\mid (i,j) \\in E_A \\}\n$$\n$$\nK_j = \\{ k \\in K \\mid (j,k) \\in E_B \\}\n$$\n问题将这些集合的基数定义为度 $a_j$ 和 $b_j$：\n$$\na_j = |R_j| = |\\{ i \\in R : (i,j) \\in E_A \\}|\n$$\n$$\nb_j = |K_j| = |\\{ k \\in K : (j,k) \\in E_B \\}|\n$$\n对于一个固定的 $j$，在 $A$ 的第 $j$ 列和 $B$ 的第 $j$ 行的外积中结构性非零的位置集合是笛卡尔积 $R_j \\times K_j$。这个集合中的元素数量是 $|R_j \\times K_j| = |R_j| \\cdot |K_j| = a_j b_j$。\n\n$C$ 中结构性非零位置的总集合 $S_C$ 是这些集合在所有可能的中间索引 $j \\in J$ 上的并集：\n$$\nS_C = \\bigcup_{j=1}^{n} (R_j \\times K_j)\n$$\n我们被要求给出这个集合大小的最坏情况上界，即 $nnz(C) = |S_C|$。集合并集的大小受各个集合大小之和的限制。这个性质被称为并集界或布尔不等式，是容斥原理的直接推论。\n$$\nnnz(C) = \\left| \\bigcup_{j=1}^{n} (R_j \\times K_j) \\right| \\le \\sum_{j=1}^{n} |R_j \\times K_j|\n$$\n代入每个笛卡尔积大小的表达式，我们得到：\n$$\nnnz(C) \\le \\sum_{j=1}^{n} a_j b_j\n$$\n这个不等式为 $C$ 中结构性非零元的数量提供了一个上界，该上界仅依赖于给定的度 $\\{a_j\\}$ 和 $\\{b_j\\}$。\n\n为了确认这是最紧的上界（即最坏情况界），我们必须能够构造一个达到该界的情景。等式成立当且仅当对于所有 $j \\in \\{1, \\dots, n\\}$，集合 $R_j \\times K_j$ 两两不相交。也就是说，对于任何 $j_1 \\neq j_2$，有 $(R_{j_1} \\times K_{j_1}) \\cap (R_{j_2} \\times K_{j_2}) = \\emptyset$。\n\n保证这种不相交性的一个充分条件是选择行索引集合 $\\{R_j\\}_{j=1}^n$ 两两不相交，或者选择列索引集合 $\\{K_j\\}_{j=1}^n$ 两两不相交。例如，如果对于 $j_1 \\neq j_2$ 有 $R_{j_1} \\cap R_{j_2} = \\emptyset$，那么 $(R_{j_1} \\times K_{j_1}) \\cap (R_{j_2} \\times K_{j_2}) = (R_{j_1} \\cap R_{j_2}) \\times (K_{j_1} \\cap K_{j_2}) = \\emptyset \\times (K_{j_1} \\cap K_{j_2}) = \\emptyset$。只要矩阵维度 $m$ 和 $p$ 足够大（例如，$m \\ge \\sum a_j$ 或 $p \\ge \\sum b_j$），这样的构造就是可能的。\n\n由于问题要求一个*仅*依赖于度 $\\{a_j\\}$ 和 $\\{b_j\\}$ 而不依赖于维度 $m$ 和 $p$ 的界，我们必须提供一个普遍成立的界。界 $\\sum_{j=1}^{n} a_j b_j$ 是普遍有效的，并且它代表了对于符合给定度的特定稀疏模式可达到的最大非零元数量。因此，这是正确的最坏情况上界。\n\n这个量，$\\sum_{j=1}^{n} a_j b_j$，也代表了计算中所需的标量乘法 $A_{ij} B_{jk}$ 的总数，在考虑任何加法之前，通常被称为浮点运算次数 (flops)。输出非零元数量的最坏情况是，每个标量乘积都对乘积矩阵 $C$ 中的一个唯一条目做出贡献，这对应于没有重叠的情况。\n\n因此，$C$ 中结构性非零元总数的最坏情况上界是 $A$ 的第 $j$ 列非零元数量与 $B$ 的第 $j$ 行非零元数量的乘积，对所有中间索引 $j$ 求和。",
            "answer": "$$\n\\boxed{\\sum_{j=1}^{n} a_j b_j}\n$$"
        },
        {
            "introduction": "在数字计算机上进行的数值计算会受到浮点舍入误差的影响，运算的顺序会显著影响最终结果的精度。本练习将指导你对矩阵乘法进行前向误差分析。通过比较简单的顺序求和与分块累加方法，你将学习如何从第一性原理出发推导误差界，甚至优化算法参数（如块大小）以增强数值稳定性 。",
            "id": "3559509",
            "problem": "设 $A \\in \\mathbb{R}^{m \\times k}$ 和 $B \\in \\mathbb{R}^{k \\times n}$，考虑通过计算内积 $c_{ij} = \\sum_{t=1}^{k} a_{it} b_{tj}$ 来计算 $C = AB$，其中 $i \\in \\{1,\\dots,m\\}$ 且 $j \\in \\{1,\\dots,n\\}$。假设使用标准的浮点运算法则，采用舍入到最近（rounding to nearest）和单位舍入误差（机器精度）$u$，其模型为 $\\mathrm{fl}(x \\circ y) = (x \\circ y)(1 + \\delta)$，其中对于 $\\circ \\in \\{+, \\times\\}$ 有 $|\\delta| \\le u$，并且舍入误差是独立的。\n\n对于每个 $c_{ij}$，考虑两种算法：\n\n- 标量累加：将 $c_{ij}$ 计算为 $k$ 个标量乘积 $a_{it} b_{tj}$ 的单个顺序和。\n\n- 块内积累加，块大小为 $s$：将索引集 $\\{1,\\dots,k\\}$ 分割成 $r = \\lceil k/s \\rceil$ 个大小为 $s$ 的连续块（最后一块可能较短）。对于每个块 $q \\in \\{1,\\dots,r\\}$，使用与第一种算法相同的标量累加方法形成部分和 $p^{(q)}_{ij} = \\sum_{t=(q-1)s+1}^{\\min(qs,k)} a_{it} b_{tj}$，然后将这 $r$ 个部分和顺序相加得到 $c_{ij}$。\n\n仅从浮点模型和矩阵乘法的定义出发，推导两种算法计算出的 $c_{ij}$ 的前向误差界。误差界需用 $u$, $k$, $s$ 和 $S_{ij} := \\sum_{t=1}^{k} |a_{it}|\\,|b_{tj}|$ 来表示。你的推导必须是显式的，并且不得假设任何已有的求和误差界；你应该从浮点模型开始构建它们。\n\n在 $ku \\ll 1$ 和 $su \\ll 1$ 的简化条件下，提取块累加误差界中关于 $u$ 的主阶项，并提出一个块大小 $s$（为最小化目的，将其视为实变量），使得该主阶项作为 $k$ 的函数达到最小。请以一个关于 $k$ 的封闭形式符号表达式给出最佳 $s$ 的最终答案。",
            "solution": "在进行解答之前，对问题陈述进行了严格验证。\n\n### 步骤1：提取已知条件\n- 矩阵：$A \\in \\mathbb{R}^{m \\times k}$ 和 $B \\in \\mathbb{R}^{k \\times n}$。\n- 乘积：$C = AB$。\n- 元素计算：$c_{ij} = \\sum_{t=1}^{k} a_{it} b_{tj}$，其中 $i \\in \\{1,\\dots,m\\}$ 且 $j \\in \\{1,\\dots,n\\}$。\n- 浮点模型：$\\mathrm{fl}(x \\circ y) = (x \\circ y)(1 + \\delta)$，其中对于 $\\circ \\in \\{+, \\times\\}$ 有 $|\\delta| \\le u$。\n- 单位舍入误差：$u$。\n- 舍入误差是独立的。\n- 算法1（标量累加）：$c_{ij}$ 计算为 $k$ 个乘积 $a_{it} b_{tj}$ 的单个顺序和。\n- 算法2（块内积累加）：\n  - 块大小：$s$。\n  - 块数量：$r = \\lceil k/s \\rceil$。\n  - 部分和：$p^{(q)}_{ij} = \\sum_{t=(q-1)s+1}^{\\min(qs,k)} a_{it} b_{tj}$，使用标量累加计算。\n  - 最终和：$c_{ij}$ 是 $r$ 个部分和 $p^{(q)}_{ij}$ 的顺序和。\n- 误差界定义：用 $u$、$k$、$s$ 和 $S_{ij} := \\sum_{t=1}^{k} |a_{it}|\\,|b_{tj}|$ 表示。\n- 推导要求：从浮点模型显式构建，不假设已有的求和误差界。\n- 简化条件：$ku \\ll 1$ 和 $su \\ll 1$。\n- 最终任务：提取块累加误差界的主阶项，找到使该项最小化的块大小 $s$（作为实变量），并以 $k$ 的函数形式给出 $s$。\n\n### 步骤2：使用提取的已知条件进行验证\n- **科学性：** 该问题是浮点算法前向误差分析中的一个标准练习，这是数值线性代数的核心课题。所提供的浮点模型是此类分析的一个基础且广泛使用的模型。\n- **适定性：** 问题陈述清晰，提供了所有必要的定义和约束。它要求进行特定的推导和优化，从而得到一个唯一的、有意义的符号答案。\n- **客观性：** 语言正式、精确，不含任何主观或基于观点的内容。\n- **完整性与一致性：** 问题是自洽且内部一致的。所有术语都已定义。\n- **其他标准：** 问题不违反任何其他验证标准。它并非无关紧要、不切实际或不适定的。\n\n### 步骤3：结论与行动\n此问题是**有效的**。将提供完整解答。\n\n### 误差界的推导\n\n我们首先建立一个关于形如 $(1+\\delta)$ 的项的乘积误差的标准结果。设 $\\theta_n$ 定义为 $\\prod_{i=1}^n (1+\\delta_i) = 1 + \\theta_n$，其中 $|\\delta_i| \\le u$。对于 $nu \\ll 1$，一个标准的界是 $|\\theta_n| \\le \\frac{nu}{1-nu}$。我们用 $\\gamma_n$ 表示这个量。因此， $|\\theta_n| \\le \\gamma_n$。\n\n#### 算法1：标量累加\n我们来分析单个元素 $c_{ij}$ 的计算，为简化符号，我们暂时将其表示为 $c = \\sum_{t=1}^k a_t b_t$。该算法通过先计算乘积 $\\hat{p}_t = \\mathrm{fl}(a_t b_t)$，然后顺序求和来计算 $\\hat{c}$。\n\n每个乘积的计算都会引入一个误差：\n$$ \\hat{p}_t = a_t b_t (1 + \\delta_t), \\quad |\\delta_t| \\le u $$\n顺序求和的执行过程如下：\n$$ s_1 = \\hat{p}_1 $$\n$$ s_q = \\mathrm{fl}(s_{q-1} + \\hat{p}_q) = (s_{q-1} + \\hat{p}_q)(1 + \\eta_q), \\quad |\\eta_q| \\le u \\quad \\text{for } q = 2, \\dots, k $$\n最终计算值为 $\\hat{c} = s_k$。展开 $s_k$ 的递推式可得：\n$$ \\hat{c} = \\sum_{t=1}^k \\hat{p}_t \\prod_{q=t+1}^k (1+\\eta_q) $$\n其中当 $t=k$ 时，空积为 $1$。代入 $\\hat{p}_t$ 的表达式：\n$$ \\hat{c} = \\sum_{t=1}^k a_t b_t (1+\\delta_t) \\prod_{q=t+1}^k (1+\\eta_q) $$\n设 $1+\\epsilon_t = (1+\\delta_t) \\prod_{q=t+1}^k (1+\\eta_q)$。项 $a_t b_t$ 受到一次乘法和 $k-t$ 次加法的影响，总共是 $k-t+1$ 次浮点运算。因此，累积的相对误差 $\\epsilon_t$ 的界为 $|\\epsilon_t| \\le \\gamma_{k-t+1}$。\n\n计算 $c$ 的绝对误差为 $E = \\hat{c} - c$：\n$$ E = \\hat{c} - c = \\sum_{t=1}^k a_t b_t (1+\\epsilon_t) - \\sum_{t=1}^k a_t b_t = \\sum_{t=1}^k a_t b_t \\epsilon_t $$\n使用三角不等式对误差的大小进行界定：\n$$ |E| \\le \\sum_{t=1}^k |a_t b_t| |\\epsilon_t| \\le \\sum_{t=1}^k |a_t b_t| \\gamma_{k-t+1} $$\n因为 $\\gamma_n$ 是 $n$ 的单调递增函数，我们可以使用界的最大可能值，该值在 $t=1$ 时出现（即 $\\gamma_k$）：\n$$ |E| \\le \\gamma_k \\sum_{t=1}^k |a_t b_t| $$\n重新引入索引 $i$ 和 $j$，并使用定义 $S_{ij} = \\sum_{t=1}^{k} |a_{it}|\\,|b_{tj}|$，我们得到标量累加的前向误差界：\n$$ |\\hat{c}_{ij} - c_{ij}| \\le \\gamma_k S_{ij} = \\frac{ku}{1-ku} S_{ij} $$\n\n#### 算法2：块内积累加\n该算法有两个阶段。首先，计算 $r = \\lceil k/s \\rceil$ 个部分和。其次，将这些部分和相加。设 $I_q$ 为第 $q$ 个块的索引集，即 $I_q = \\{(q-1)s+1, \\dots, \\min(qs, k)\\}$，并设 $s_q = |I_q|$。注意，对于 $q  r$ 有 $s_q=s$，且 $s_r \\le s$。第 $q$ 个块的真实部分和为 $P^{(q)}_{ij} = \\sum_{t \\in I_q} a_{it} b_{tj}$。\n\n**阶段1误差：** 每个部分和 $\\hat{p}^{(q)}_{ij}$ 是通过对 $s_q$ 个项进行标量累加来计算的。使用算法1的结果，每个计算出的部分和的误差为：\n$$ |\\hat{p}^{(q)}_{ij} - P^{(q)}_{ij}| \\le \\gamma_{s_q} \\sum_{t \\in I_q} |a_{it}b_{tj}| $$\n因为对于所有 $q$ 都有 $s_q \\le s$，且 $\\gamma_n$ 是 $n$ 的增函数，所以我们有 $\\gamma_{s_q} \\le \\gamma_s$。因此：\n$$ |\\hat{p}^{(q)}_{ij} - P^{(q)}_{ij}| \\le \\gamma_s \\sum_{t \\in I_q} |a_{it}b_{tj}| $$\n将这些界在所有块上求和，得到阶段1的总误差：\n$$ \\sum_{q=1}^r |\\hat{p}^{(q)}_{ij} - P^{(q)}_{ij}| \\le \\gamma_s \\sum_{q=1}^r \\sum_{t \\in I_q} |a_{it}b_{tj}| = \\gamma_s S_{ij} $$\n\n**阶段2误差：** 最终值 $\\hat{c}_{ij}$ 是 $r$ 个计算出的部分和 $\\hat{p}^{(q)}_{ij}$ 的顺序浮点和。这是一个包含 $r$ 个项的和，涉及 $r-1$ 次加法。这次求和的误差是：\n$$ |\\hat{c}_{ij} - \\sum_{q=1}^r \\hat{p}^{(q)}_{ij}| \\le \\gamma_{r-1} \\sum_{q=1}^r |\\hat{p}^{(q)}_{ij}| $$\n为了界定这个误差，我们需要界定 $|\\hat{p}^{(q)}_{ij}|$：\n$$ |\\hat{p}^{(q)}_{ij}| = |P^{(q)}_{ij} + (\\hat{p}^{(q)}_{ij} - P^{(q)}_{ij})| \\le |P^{(q)}_{ij}| + |\\hat{p}^{(q)}_{ij} - P^{(q)}_{ij}| $$\n$$ |\\hat{p}^{(q)}_{ij}| \\le \\sum_{t \\in I_q} |a_{it}b_{tj}| + \\gamma_s \\sum_{t \\in I_q} |a_{it}b_{tj}| = (1+\\gamma_s) \\sum_{t \\in I_q} |a_{it}b_{tj}| $$\n对 $q$ 从 $1$ 到 $r$ 求和：\n$$ \\sum_{q=1}^r |\\hat{p}^{(q)}_{ij}| \\le (1+\\gamma_s) \\sum_{q=1}^r \\sum_{t \\in I_q} |a_{it}b_{tj}| = (1+\\gamma_s) S_{ij} $$\n将此代入阶段2的误差界：\n$$ |\\hat{c}_{ij} - \\sum_{q=1}^r \\hat{p}^{(q)}_{ij}| \\le \\gamma_{r-1}(1+\\gamma_s) S_{ij} $$\n\n**总误差：** 总误差是两个阶段误差之和。设 $c_{ij} = \\sum P^{(q)}_{ij}$ 和 $\\sum \\hat{p}^{(q)}_{ij} = \\sum(P^{(q)}_{ij} + (\\hat{p}^{(q)}_{ij} - P^{(q)}_{ij}))$。\n$$ \\hat{c}_{ij} - c_{ij} = (\\hat{c}_{ij} - \\sum_{q=1}^r \\hat{p}^{(q)}_{ij}) + (\\sum_{q=1}^r \\hat{p}^{(q)}_{ij} - \\sum_{q=1}^r P^{(q)}_{ij}) $$\n使用三角不等式：\n$$ |\\hat{c}_{ij} - c_{ij}| \\le |\\hat{c}_{ij} - \\sum_{q=1}^r \\hat{p}^{(q)}_{ij}| + |\\sum_{q=1}^r (\\hat{p}^{(q)}_{ij} - P^{(q)}_{ij})| $$\n$$ |\\hat{c}_{ij} - c_{ij}| \\le \\gamma_{r-1}(1+\\gamma_s) S_{ij} + \\sum_{q=1}^r |\\hat{p}^{(q)}_{ij} - P^{(q)}_{ij}| $$\n$$ |\\hat{c}_{ij} - c_{ij}| \\le \\gamma_{r-1}(1+\\gamma_s) S_{ij} + \\gamma_s S_{ij} $$\n$$ |\\hat{c}_{ij} - c_{ij}| \\le (\\gamma_s + \\gamma_{r-1} + \\gamma_s\\gamma_{r-1}) S_{ij} $$\n这就是块累加算法的前向误差界。\n\n### 主阶项误差界的最小化\n我们已知简化条件 $ku \\ll 1$ 和 $su \\ll 1$。这意味着任何形如 $Nu$（其中 $N \\le k$）的项都很小。在这种条件下，我们可以近似 $\\gamma_N = \\frac{Nu}{1-Nu} \\approx Nu$。\n块累加的误差界变为：\n$$ |\\hat{c}_{ij} - c_{ij}| \\lesssim (su + (r-1)u + (su)((r-1)u)) S_{ij} $$\n通过忽略含 $u^2$ 的项，可以找到关于 $u$ 的主阶项：\n$$ |\\hat{c}_{ij} - c_{ij}|_{\\text{leading}} \\approx (s + r - 1) u S_{ij} $$\n为了最小化这个界，我们需要最小化因子 $f(s) = s + r - 1$。题目允许将 $s$ 视为一个连续实变量。因此，我们可以用近似 $r \\approx k/s$ 来代替 $r = \\lceil k/s \\rceil$。\n需要最小化的函数变为：\n$$ f(s) = s + \\frac{k}{s} - 1 $$\n为求最小值，我们计算 $f(s)$ 对 $s$ 的导数并令其为零：\n$$ \\frac{df}{ds} = 1 - \\frac{k}{s^2} $$\n令导数为零：\n$$ 1 - \\frac{k}{s^2} = 0 \\implies s^2 = k \\implies s = \\sqrt{k} $$\n我们取正根，因为 $s$ 必须是正的块大小。为确认这是一个最小值，我们检查二阶导数：\n$$ \\frac{d^2f}{ds^2} = \\frac{2k}{s^3} $$\n对于 $s = \\sqrt{k} > 0$ 和 $k > 0$，二阶导数为正，确认了 $s = \\sqrt{k}$ 对应一个局部最小值。因此，使主阶误差界最小化的最佳块大小是 $s = \\sqrt{k}$。",
            "answer": "$$\\boxed{\\sqrt{k}}$$"
        }
    ]
}