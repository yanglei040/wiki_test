{
    "hands_on_practices": [
        {
            "introduction": "矩阵乘法不满足交换律是一条基本原则。本练习不仅要求你验证这一事实，更进一步，它要求你使用对易子 $[A,B]=AB-BA$ 来量化 $AB$ 与 $BA$ 之间的差异。通过计算该对易子的诱导2-范数，你将在抽象代数和数值分析之间架起一座桥梁，学会如何衡量这一基本性质的“大小”。",
            "id": "3559507",
            "problem": "令 $n=4$。考虑如下给定的矩阵 $A \\in \\mathbb{R}^{4 \\times 4}$ 和 $B \\in \\mathbb{R}^{4 \\times 4}$：\n$$\nA=\\begin{pmatrix}\n0  1  0  0 \\\\\n0  0  1  0 \\\\\n0  0  0  1 \\\\\n0  0  0  0\n\\end{pmatrix}, \\qquad\nB=\\operatorname{diag}(1,3,-2,7)=\\begin{pmatrix}\n1  0  0  0 \\\\\n0  3  0  0 \\\\\n0  0  -2  0 \\\\\n0  0  0  7\n\\end{pmatrix}.\n$$\n仅使用矩阵-矩阵乘法和诱导矩阵范数的基本定义，完成以下步骤：\n- 显式计算换位子 $[A,B]=AB-BA$ 并验证 $AB \\neq BA$。\n- 使用由欧几里得范数诱导的算子范数的定义，即\n$$\n\\|M\\|_{2}=\\sup_{x \\neq 0} \\frac{\\|Mx\\|_{2}}{\\|x\\|_{2}},\n$$\n精确地计算 $\\|[A,B]\\|_{2}$，并从基本原理（矩阵乘法规则、对称矩阵的性质和瑞利商）出发论证每一步。\n\n请以单个实数的形式提供最终答案。无需四舍五入。",
            "solution": "该问题是适定且自洽的。所有必需的矩阵和定义均已提供，不存在科学或逻辑上的不一致之处。我们可以开始求解。\n\n该问题要求完成两项主要任务：首先，对于给定的矩阵 A 和 B，计算换位子 $[A,B]=AB-BA$ 并验证它们不对易；其次，使用基本原理计算该换位子的诱导2-范数 $\\|[A,B]\\|_{2}$。\n\n设矩阵 $A$ 和 $B$ 定义如下：\n$$\nA=\\begin{pmatrix}\n0  1  0  0 \\\\\n0  0  1  0 \\\\\n0  0  0  1 \\\\\n0  0  0  0\n\\end{pmatrix}, \\qquad\nB=\\begin{pmatrix}\n1  0  0  0 \\\\\n0  3  0  0 \\\\\n0  0  -2  0 \\\\\n0  0  0  7\n\\end{pmatrix}.\n$$\n\n首先，我们计算乘积 $AB$。对于一个一般矩阵 $M$ 和一个对角矩阵 $D$，乘积 $MD$ 是将矩阵 $M$ 的第 $j$ 列乘以 $D$ 的第 $j$ 个对角元得到的矩阵。\n因此，$AB$ 的列是 $A$ 的列分别乘以 $B$ 的对角元 $1$、$3$、$-2$ 和 $7$。\n$$\nAB = \\begin{pmatrix}\n0 \\cdot 1  1 \\cdot 3  0 \\cdot (-2)  0 \\cdot 7 \\\\\n0 \\cdot 1  0 \\cdot 3  1 \\cdot (-2)  0 \\cdot 7 \\\\\n0 \\cdot 1  0 \\cdot 3  0 \\cdot (-2)  1 \\cdot 7 \\\\\n0 \\cdot 1  0 \\cdot 3  0 \\cdot (-2)  0 \\cdot 7\n\\end{pmatrix} = \\begin{pmatrix}\n0  3  0  0 \\\\\n0  0  -2  0 \\\\\n0  0  0  7 \\\\\n0  0  0  0\n\\end{pmatrix}.\n$$\n\n接下来，我们计算乘积 $BA$。对于一个一般矩阵 $M$ 和一个对角矩阵 $D$，乘积 $DM$ 是将矩阵 $M$ 的第 $i$ 行乘以 $D$ 的第 $i$ 个对角元得到的矩阵。\n因此，$BA$ 的行是 $A$ 的行乘以 $B$ 的对角元。\n$$\nBA = \\begin{pmatrix}\n1 \\cdot 0  1 \\cdot 1  1 \\cdot 0  1 \\cdot 0 \\\\\n3 \\cdot 0  3 \\cdot 0  3 \\cdot 1  3 \\cdot 0 \\\\\n-2 \\cdot 0  -2 \\cdot 0  -2 \\cdot 0  -2 \\cdot 1 \\\\\n7 \\cdot 0  7 \\cdot 0  7 \\cdot 0  7 \\cdot 0\n\\end{pmatrix} = \\begin{pmatrix}\n0  1  0  0 \\\\\n0  0  3  0 \\\\\n0  0  0  -2 \\\\\n0  0  0  0\n\\end{pmatrix}.\n$$\n\n通过比较所得矩阵，我们看到 $(AB)_{12} = 3$ 而 $(BA)_{12} = 1$。由于至少有一个元素不同，这两个矩阵不相等，从而验证了 $AB \\neq BA$。\n\n现在，我们计算换位子，记为 $C$：\n$$\nC = [A,B] = AB - BA = \\begin{pmatrix}\n0  3  0  0 \\\\\n0  0  -2  0 \\\\\n0  0  0  7 \\\\\n0  0  0  0\n\\end{pmatrix} - \\begin{pmatrix}\n0  1  0  0 \\\\\n0  0  3  0 \\\\\n0  0  0  -2 \\\\\n0  0  0  0\n\\end{pmatrix} = \\begin{pmatrix}\n0  2  0  0 \\\\\n0  0  -5  0 \\\\\n0  0  0  9 \\\\\n0  0  0  0\n\\end{pmatrix}.\n$$\n\n问题的第二部分要求我们计算 $\\|C\\|_{2}$。矩阵 $M$ 的诱导2-范数定义为：\n$$\n\\|M\\|_{2} = \\sup_{x \\neq 0} \\frac{\\|Mx\\|_{2}}{\\|x\\|_{2}} = \\sup_{\\|x\\|_{2}=1} \\|Mx\\|_{2}.\n$$\n处理范数的平方更为方便：\n$$\n\\|M\\|_{2}^2 = \\sup_{\\|x\\|_{2}=1} \\|Mx\\|_{2}^2.\n$$\n向量 $v$ 的欧几里得范数的平方是 $v^T v$。因此，$\\|Mx\\|_{2}^2 = (Mx)^T(Mx) = x^T M^T M x$。\n将此代入范数平方的表达式中，得到：\n$$\n\\|M\\|_{2}^2 = \\sup_{\\|x\\|_{2}=1} x^T M^T M x.\n$$\n表达式 $\\frac{x^T M^T M x}{x^T x}$ 是矩阵 $M^T M$ 的瑞利商。矩阵 $M^T M$ 是对称半正定矩阵。根据瑞利-里兹定理，对称矩阵的瑞利商的上确界是其最大特征值 $\\lambda_{\\max}(M^T M)$。因此，$\\|M\\|_{2}^2 = \\lambda_{\\max}(M^T M)$，这意味着 $\\|M\\|_{2} = \\sqrt{\\lambda_{\\max}(M^T M)}$。\n\n我们将此原理应用于我们的换位子矩阵 $C$。首先，我们计算 $C^T$，然后计算 $C^T C$：\n$$\nC = \\begin{pmatrix}\n0  2  0  0 \\\\\n0  0  -5  0 \\\\\n0  0  0  9 \\\\\n0  0  0  0\n\\end{pmatrix}, \\qquad\nC^T = \\begin{pmatrix}\n0  0  0  0 \\\\\n2  0  0  0 \\\\\n0  -5  0  0 \\\\\n0  0  9  0\n\\end{pmatrix}.\n$$\n现在，我们计算乘积 $C^T C$：\n$$\nC^T C = \\begin{pmatrix}\n0  0  0  0 \\\\\n2  0  0  0 \\\\\n0  -5  0  0 \\\\\n0  0  9  0\n\\end{pmatrix}\n\\begin{pmatrix}\n0  2  0  0 \\\\\n0  0  -5  0 \\\\\n0  0  0  9 \\\\\n0  0  0  0\n\\end{pmatrix} = \\begin{pmatrix}\n0  0  0  0 \\\\\n0  4  0  0 \\\\\n0  0  25  0 \\\\\n0  0  0  81\n\\end{pmatrix}.\n$$\n矩阵 $C^T C$ 是一个对角矩阵。对角矩阵的特征值是其对角元。因此，$C^T C$ 的特征值为 $\\lambda_1 = 0$, $\\lambda_2 = 4$, $\\lambda_3 = 25$ 和 $\\lambda_4 = 81$。\n\n最大特征值是 $\\lambda_{\\max}(C^T C) = 81$。\n使用从基本原理导出的关系，我们有：\n$$\n\\|C\\|_{2}^2 = \\lambda_{\\max}(C^T C) = 81.\n$$\n取平方根，得到诱导2-范数的值：\n$$\n\\|C\\|_{2} = \\sqrt{81} = 9.\n$$\n因此，$\\|[A,B]\\|_{2}$ 的精确值为 $9$。",
            "answer": "$$\\boxed{9}$$"
        },
        {
            "introduction": "优美的矩阵乘法理论假设我们拥有无限精度的实数运算，但现实世界中的计算是在有限精度的浮点算术下进行的。本练习将深入探讨这一现实带来的重要影响，通过分析计算内积时不同求和策略的数值稳定性。你将推导前向误差界，并探索诸如分块等算法选择如何能够最小化误差的累积。",
            "id": "3559509",
            "problem": "设 $A \\in \\mathbb{R}^{m \\times k}$ 且 $B \\in \\mathbb{R}^{k \\times n}$，考虑通过计算内积 $c_{ij} = \\sum_{t=1}^{k} a_{it} b_{tj}$ 来计算 $C = AB$，其中 $i \\in \\{1,\\dots,m\\}$ 且 $j \\in \\{1,\\dots,n\\}$。假设采用标准的浮点运算，使用舍入到最近的规则，单位舍入误差（机器精度）为 $u$，其模型为 $\\mathrm{fl}(x \\circ y) = (x \\circ y)(1 + \\delta)$，其中 $|\\delta| \\le u$ 对 $\\circ \\in \\{+, \\times\\}$ 成立，且舍入误差是独立的。\n\n对于每个 $c_{ij}$，考虑两种算法：\n\n- 标量累加：将 $c_{ij}$ 计算为 $k$ 个标量乘积 $a_{it} b_{tj}$ 的单个顺序和。\n\n- 块大小为 $s$ 的分块内积累加：将索引集 $\\{1,\\dots,k\\}$ 划分为 $r = \\lceil k/s \\rceil$ 个大小为 $s$ 的连续块（最后一块可能较短）。对于每个块 $q \\in \\{1,\\dots,r\\}$，使用与第一种算法相同的标量累加方法形成一个部分和 $p^{(q)}_{ij} = \\sum_{t=(q-1)s+1}^{\\min(qs,k)} a_{it} b_{tj}$，然后将这 $r$ 个部分和顺序相加得到 $c_{ij}$。\n\n仅从浮点模型和矩阵-矩阵乘法的定义出发，推导两种算法计算出的 $c_{ij}$ 的前向误差界，该误差界用 $u$、$k$、$s$ 和 $S_{ij} := \\sum_{t=1}^{k} |a_{it}|\\,|b_{tj}|$ 表示。你的推导必须是显式的，且不能假设任何已有的求和误差界；你应该从浮点模型开始构建它们。\n\n在 $ku \\ll 1$ 和 $su \\ll 1$ 的简化条件下，提取分块累加误差界中关于 $u$ 的主阶项，并提出一个块大小 $s$（为最小化目的，将其视为实变量），该 $s$ 作为 $k$ 的函数可以最小化此主阶项。以关于 $k$ 的最优 $s$ 的单个闭式符号表达式的形式提供你的最终答案。",
            "solution": "在进行求解之前，对问题陈述进行严格验证。\n\n### 步骤 1：提取已知条件\n- 矩阵：$A \\in \\mathbb{R}^{m \\times k}$ 和 $B \\in \\mathbb{R}^{k \\times n}$。\n- 乘积：$C = AB$。\n- 元素计算：$c_{ij} = \\sum_{t=1}^{k} a_{it} b_{tj}$，其中 $i \\in \\{1,\\dots,m\\}$ 且 $j \\in \\{1,\\dots,n\\}$。\n- 浮点模型：$\\mathrm{fl}(x \\circ y) = (x \\circ y)(1 + \\delta)$，其中 $|\\delta| \\le u$ 对 $\\circ \\in \\{+, \\times\\}$ 成立。\n- 单位舍入误差：$u$。\n- 舍入误差是独立的。\n- 算法 1（标量累加）：$c_{ij}$ 作为 $k$ 个乘积 $a_{it} b_{tj}$ 的单个顺序和进行计算。\n- 算法 2（分块内积累加）：\n  - 块大小：$s$。\n  - 块数：$r = \\lceil k/s \\rceil$。\n  - 部分和：$p^{(q)}_{ij} = \\sum_{t=(q-1)s+1}^{\\min(qs,k)} a_{it} b_{tj}$，使用标量累加计算。\n  - 最终和：$c_{ij}$ 是 $r$ 个部分和 $p^{(q)}_{ij}$ 的顺序和。\n- 误差界定义：用 $u$、$k$、$s$ 和 $S_{ij} := \\sum_{t=1}^{k} |a_{it}|\\,|b_{tj}|$ 表示。\n- 推导要求：从浮点模型显式构建，不假设已有的求和误差界。\n- 简化条件：$ku \\ll 1$ 和 $su \\ll 1$。\n- 最终任务：提取分块累加误差界的主阶项，找到使该项最小化的块大小 $s$（作为实变量），并以 $k$ 的函数形式给出 $s$。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据：** 该问题是浮点算法前向误差分析中的一个标准练习，这是数值线性代数的核心课题。所提供的浮点模型是此类分析的一个基础且广泛使用的模型。\n- **良态性：** 问题陈述清晰，提供了所有必要的定义和约束。它要求进行具体的推导和优化，这些都可以导出一个唯一的、有意义的符号答案。\n- **客观性：** 语言正式、精确，不含任何主观或基于观点的内容。\n- **完整性和一致性：** 问题是自洽且内部一致的。所有术语都已定义。\n- **其他标准：** 问题不违反任何其他验证标准。它不是一个平凡、不切实际或病态的问题。\n\n### 步骤 3：结论与行动\n该问题是**有效的**。将提供完整解答。\n\n### 误差界的推导\n\n我们首先建立一个关于形如 $(1+\\delta)$ 的项的乘积误差的标准结果。设 $\\theta_n$ 定义为 $\\prod_{i=1}^n (1+\\delta_i) = 1 + \\theta_n$，其中 $|\\delta_i| \\le u$。对于 $nu \\ll 1$，一个标准的界是 $|\\theta_n| \\le \\frac{nu}{1-nu}$。我们将此量记为 $\\gamma_n$。因此，有 $|\\theta_n| \\le \\gamma_n$。\n\n#### 算法 1：标量累加\n我们来分析单个元素 $c_{ij}$ 的计算，为简化符号，我们暂时将其记为 $c = \\sum_{t=1}^k a_t b_t$。该算法通过首先计算乘积 $\\hat{p}_t = \\mathrm{fl}(a_t b_t)$，然后将它们顺序相加来计算 $\\hat{c}$。\n\n每个乘积的计算都会引入一个误差：\n$$ \\hat{p}_t = a_t b_t (1 + \\delta_t), \\quad |\\delta_t| \\le u $$\n顺序求和的执行过程如下：\n$$ s_1 = \\hat{p}_1 $$\n$$ s_q = \\mathrm{fl}(s_{q-1} + \\hat{p}_q) = (s_{q-1} + \\hat{p}_q)(1 + \\eta_q), \\quad |\\eta_q| \\le u \\quad \\text{for } q = 2, \\dots, k $$\n最终计算值为 $\\hat{c} = s_k$。展开 $s_k$ 的递推式得到：\n$$ \\hat{c} = \\sum_{t=1}^k \\hat{p}_t \\prod_{q=t+1}^k (1+\\eta_q) $$\n其中当 $t=k$ 时，空积为 $1$。代入 $\\hat{p}_t$ 的表达式：\n$$ \\hat{c} = \\sum_{t=1}^k a_t b_t (1+\\delta_t) \\prod_{q=t+1}^k (1+\\eta_q) $$\n令 $1+\\epsilon_t = (1+\\delta_t) \\prod_{q=t+1}^k (1+\\eta_q)$。项 $a_t b_t$ 受到一次乘法和 $k-t$ 次加法的影响，总共是 $k-t+1$ 次浮点运算。因此，累积的相对误差 $\\epsilon_t$ 的界为 $|\\epsilon_t| \\le \\gamma_{k-t+1}$。\n\n计算 $c$ 的绝对误差为 $E = \\hat{c} - c$：\n$$ E = \\hat{c} - c = \\sum_{t=1}^k a_t b_t (1+\\epsilon_t) - \\sum_{t=1}^k a_t b_t = \\sum_{t=1}^k a_t b_t \\epsilon_t $$\n使用三角不等式对误差的大小进行界定：\n$$ |E| \\le \\sum_{t=1}^k |a_t b_t| |\\epsilon_t| \\le \\sum_{t=1}^k |a_t b_t| \\gamma_{k-t+1} $$\n由于 $\\gamma_n$ 是 $n$ 的单调递增函数，我们可以使用该界的最大可能值，该值在 $t=1$ 时出现（即 $\\gamma_k$）：\n$$ |E| \\le \\gamma_k \\sum_{t=1}^k |a_t b_t| $$\n重新引入索引 $i$ 和 $j$，并使用定义 $S_{ij} = \\sum_{t=1}^{k} |a_{it}|\\,|b_{tj}|$，我们得到标量累加的前向误差界：\n$$ |\\hat{c}_{ij} - c_{ij}| \\le \\gamma_k S_{ij} = \\frac{ku}{1-ku} S_{ij} $$\n\n#### 算法 2：分块内积累加\n此算法有两个阶段。首先，计算 $r = \\lceil k/s \\rceil$ 个部分和。其次，将这些部分和相加。设 $I_q$ 为第 $q$ 个块的索引集，即 $I_q = \\{(q-1)s+1, \\dots, \\min(qs, k)\\}$，并设 $s_q = |I_q|$。注意，对于 $q  r$，$s_q=s$ 且 $s_r \\le s$。块 $q$ 的真实部分和为 $P^{(q)}_{ij} = \\sum_{t \\in I_q} a_{it} b_{tj}$。\n\n**阶段 1 误差：** 每个部分和 $\\hat{p}^{(q)}_{ij}$ 是通过对 $s_q$ 个项进行标量累加计算的。使用算法 1 的结果，每个计算出的部分和的误差为：\n$$ |\\hat{p}^{(q)}_{ij} - P^{(q)}_{ij}| \\le \\gamma_{s_q} \\sum_{t \\in I_q} |a_{it}b_{tj}| $$\n因为对所有 $q$ 都有 $s_q \\le s$，且 $\\gamma_n$ 关于 $n$ 是递增的，所以我们有 $\\gamma_{s_q} \\le \\gamma_s$。因此：\n$$ |\\hat{p}^{(q)}_{ij} - P^{(q)}_{ij}| \\le \\gamma_s \\sum_{t \\in I_q} |a_{it}b_{tj}| $$\n将这些界对所有块求和，得到阶段 1 的总误差：\n$$ \\sum_{q=1}^r |\\hat{p}^{(q)}_{ij} - P^{(q)}_{ij}| \\le \\gamma_s \\sum_{q=1}^r \\sum_{t \\in I_q} |a_{it}b_{tj}| = \\gamma_s S_{ij} $$\n\n**阶段 2 误差：** 最终值 $\\hat{c}_{ij}$ 是 $r$ 个计算出的部分和 $\\hat{p}^{(q)}_{ij}$ 的顺序浮点和。这是一个包含 $r$ 个项的和，涉及 $r-1$ 次加法。此求和的误差为：\n$$ |\\hat{c}_{ij} - \\sum_{q=1}^r \\hat{p}^{(q)}_{ij}| \\le \\gamma_{r-1} \\sum_{q=1}^r |\\hat{p}^{(q)}_{ij}| $$\n为了界定这个误差，我们需要界定 $|\\hat{p}^{(q)}_{ij}|$：\n$$ |\\hat{p}^{(q)}_{ij}| = |P^{(q)}_{ij} + (\\hat{p}^{(q)}_{ij} - P^{(q)}_{ij})| \\le |P^{(q)}_{ij}| + |\\hat{p}^{(q)}_{ij} - P^{(q)}_{ij}| $$\n$$ |\\hat{p}^{(q)}_{ij}| \\le \\sum_{t \\in I_q} |a_{it}b_{tj}| + \\gamma_s \\sum_{t \\in I_q} |a_{it}b_{tj}| = (1+\\gamma_s) \\sum_{t \\in I_q} |a_{it}b_{tj}| $$\n对 $q$ 从 $1$ 到 $r$ 求和：\n$$ \\sum_{q=1}^r |\\hat{p}^{(q)}_{ij}| \\le (1+\\gamma_s) \\sum_{q=1}^r \\sum_{t \\in I_q} |a_{it}b_{tj}| = (1+\\gamma_s) S_{ij} $$\n将此代入阶段 2 的误差界：\n$$ |\\hat{c}_{ij} - \\sum_{q=1}^r \\hat{p}^{(q)}_{ij}| \\le \\gamma_{r-1}(1+\\gamma_s) S_{ij} $$\n\n**总误差：** 总误差是两个阶段误差之和。设 $c_{ij} = \\sum P^{(q)}_{ij}$ 且 $\\sum \\hat{p}^{(q)}_{ij} = \\sum(P^{(q)}_{ij} + (\\hat{p}^{(q)}_{ij} - P^{(q)}_{ij}))$。\n$$ \\hat{c}_{ij} - c_{ij} = (\\hat{c}_{ij} - \\sum_{q=1}^r \\hat{p}^{(q)}_{ij}) + (\\sum_{q=1}^r \\hat{p}^{(q)}_{ij} - \\sum_{q=1}^r P^{(q)}_{ij}) $$\n使用三角不等式：\n$$ |\\hat{c}_{ij} - c_{ij}| \\le |\\hat{c}_{ij} - \\sum_{q=1}^r \\hat{p}^{(q)}_{ij}| + |\\sum_{q=1}^r (\\hat{p}^{(q)}_{ij} - P^{(q)}_{ij})| $$\n$$ |\\hat{c}_{ij} - c_{ij}| \\le \\gamma_{r-1}(1+\\gamma_s) S_{ij} + \\sum_{q=1}^r |\\hat{p}^{(q)}_{ij} - P^{(q)}_{ij}| $$\n$$ |\\hat{c}_{ij} - c_{ij}| \\le \\gamma_{r-1}(1+\\gamma_s) S_{ij} + \\gamma_s S_{ij} $$\n$$ |\\hat{c}_{ij} - c_{ij}| \\le (\\gamma_s + \\gamma_{r-1} + \\gamma_s\\gamma_{r-1}) S_{ij} $$\n这是分块累加算法的前向误差界。\n\n### 主阶项误差界的最小化\n给定简化条件 $ku \\ll 1$ 和 $su \\ll 1$。这意味着任何形如 $Nu$（其中 $N \\le k$）的项都很小。在此条件下，我们可以近似 $\\gamma_N = \\frac{Nu}{1-Nu} \\approx Nu$。\n分块累加的误差界变为：\n$$ |\\hat{c}_{ij} - c_{ij}| \\lesssim (su + (r-1)u + (su)((r-1)u)) S_{ij} $$\n忽略含 $u^2$ 的项，可以找到关于 $u$ 的主阶项：\n$$ |\\hat{c}_{ij} - c_{ij}|_{\\text{leading}} \\approx (s + r - 1) u S_{ij} $$\n为了最小化此界，我们需要最小化因子 $f(s) = s + r - 1$。题目允许将 $s$ 视为一个连续的实变量。因此，我们可以用近似 $r \\approx k/s$ 来代替 $r = \\lceil k/s \\rceil$。\n需要最小化的函数变为：\n$$ f(s) = s + \\frac{k}{s} - 1 $$\n为了找到最小值，我们计算 $f(s)$ 关于 $s$ 的导数，并令其为零：\n$$ \\frac{df}{ds} = 1 - \\frac{k}{s^2} $$\n令导数为零：\n$$ 1 - \\frac{k}{s^2} = 0 \\implies s^2 = k \\implies s = \\sqrt{k} $$\n我们取正根，因为 $s$ 必须是正的块大小。为确认这是一个最小值，我们检查二阶导数：\n$$ \\frac{d^2f}{ds^2} = \\frac{2k}{s^3} $$\n对于 $s = \\sqrt{k} > 0$ 和 $k > 0$，二阶导数为正，确认 $s = \\sqrt{k}$ 对应一个局部最小值。因此，最小化主阶误差界的最优块大小是 $s = \\sqrt{k}$。",
            "answer": "$$\\boxed{\\sqrt{k}}$$"
        },
        {
            "introduction": "在现代科学计算和机器学习中，矩阵乘法常常是需要进行微分的更庞大计算中的一个基本构件。本实践练习将介绍“伴随”(adjoint)的概念，它是高效的反向模式自动微分（即反向传播）的基石。你将学习一种强大的验证技术——有限差分检验，以确保所推导的伴随表达式的正确性，这是开发可靠复杂模型的关键技能。",
            "id": "3559517",
            "problem": "考虑一个通过弗罗贝尼乌斯内积在实数矩阵对上定义的标量泛函，其中两个矩阵的弗罗贝尼乌斯内积由 $\\langle X,Y\\rangle_{\\mathrm{F}}=\\sum_{i,j}X_{ij}Y_{ij}$ 给出。设 $A\\in\\mathbb{R}^{m\\times n}$，$B\\in\\mathbb{R}^{n\\times p}$，以及一个固定的矩阵 $\\bar{C}\\in\\mathbb{R}^{m\\times p}$。定义标量映射 $f(A,B)=\\langle \\bar{C},\\,A B\\rangle_{\\mathrm{F}}$。您的任务是，从第一性原理出发，推导 $f$ 在扰动 $(dA,dB)$ 下的一阶变分，利用它设计一个中心有限差分方向导数测试，然后使用此测试来验证一个容易出现转置错误的矩阵-矩阵乘积的反向模式伴随实现。\n\n从以下基本依据出发：\n- 矩阵乘法的双线性以及根据其元素定义的矩阵乘积。\n- 方向导数作为差商极限的定义。\n- 弗罗贝尼乌斯内积及其性质，特别是线性和恒等式 $\\langle X,YZ\\rangle_{\\mathrm{F}}=\\langle XZ^{\\top},Y\\rangle_{\\mathrm{F}}=\\langle X^{\\top}Y,Z^{\\top}\\rangle_{\\mathrm{F}}$（当乘积有定义时）。\n\n基于这些依据，推导映射 $(A,B)\\mapsto A B$ 沿 $(dA,dB)$ 方向的一阶变分（微分），然后推导出相应的伴随（反向模式）表达式，该表达式将 $\\langle \\bar{C},\\,\\mathrm{d}(A B)\\rangle_{\\mathrm{F}}$ 与 $\\langle \\bar{A},\\,\\mathrm{d}A\\rangle_{\\mathrm{F}}$ 和 $\\langle \\bar{B},\\,\\mathrm{d}B\\rangle_{\\mathrm{F}}$ 联系起来，其中 $\\bar{A}$ 和 $\\bar{B}$ 是适当的伴随矩阵。目标是设计一个有限差分测试，该测试将：\n- 当伴随表达式正确实现时通过。\n- 当在伴随代码中引入一个常见的转置错误时（具体来说，就是将一个必需的转置替换为单位映射），失败（或引发维度不匹配）。\n\n实施以下数值测试方法：\n- 对于给定的 $A$，$B$ 和方向 $(dA,dB)$，使用中心差商来近似 $f$ 的方向导数\n$$\nD_{\\mathrm{FD}} f(A,B)[dA,dB]\\approx\\frac{f(A+\\varepsilon dA,B+\\varepsilon dB)-f(A-\\varepsilon dA,B-\\varepsilon dB)}{2\\varepsilon},\n$$\n其中 $\\varepsilon0$ 是一个小数。\n- 使用伴随实现计算伴随预测的方向导数 $D_{\\mathrm{ADJ}} f(A,B)[dA,dB]$。对正确的伴随执行一次，并对以下两种有错误的变体各执行一次：\n    1.  关于 $A$ 的伴随中的一个错误，该错误省略了一个必要的转置。\n    2.  关于 $B$ 的伴随中的一个错误，该错误省略了一个必要的转置。\n- 如果相对误差\n$$\n\\frac{\\left|D_{\\mathrm{FD}} f-D_{\\mathrm{ADJ}} f\\right|}{\\max\\{1,\\left|D_{\\mathrm{FD}} f\\right|\\}}\n$$\n至多为一个指定的容差，则宣布给定实现的测试通过。\n\n通过为每种情况指定 $(m,n,p)$ 和一个伪随机种子来设计一个测试套件，并为了可复现性，从标准正态分布中独立抽取 $A$、$B$、$dA$、$dB$ 和 $\\bar{C}$ 的元素。使用以下测试套件，它探测了各种形状，以确保覆盖一般情况和边界情况，这些情况要么揭示细微的转置错误，要么强制出现维度不匹配：\n\n- 测试用例 1：$(m,n,p)=(5,3,4)$，种子为 $123$。\n- 测试用例 2：$(m,n,p)=(4,4,4)$，种子为 $456$。\n- 测试用例 3：$(m,n,p)=(1,2,3)$，种子为 $789$。\n- 测试用例 4：$(m,n,p)=(10,7,7)$，种子为 $321$。\n- 测试用例 5：$(m,n,p)=(2,2,3)$，种子为 $135$。\n\n在所有情况下，使用相同的小中心差分步长 $\\varepsilon=10^{-6}$ 和容差 $10^{-7}$。在有错误的伴随产生维度不匹配的情况下，将测试视为已捕获到该错误。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。输出列表中的每个元素对应一个测试用例，并且本身是一个三元素布尔值列表 $[p,c_A,c_B]$，其中 $p$ 表示正确的伴随是否通过，$c_A$ 表示测试是否捕获到 $A$ 的错误伴随，$c_B$ 表示测试是否捕获到 $B$ 的错误伴随。例如，总输出格式必须为\n$[[p_1,c_{A,1},c_{B,1}],[p_2,c_{A,2},c_{B,2}],\\ldots]$。",
            "solution": "该问题要求在一个标量泛函的背景下，推导和数值验证矩阵-矩阵乘积运算的伴随。我们将首先从第一性原理推导必要的数学表达式，然后描述用于验证一个实现的数值测试的设计。\n\n设矩阵为 $A \\in \\mathbb{R}^{m \\times n}$，$B \\in \\mathbb{R}^{n \\times p}$，以及 $\\bar{C} \\in \\mathbb{R}^{m \\times p}$。标量泛函由弗罗贝尼乌斯内积定义为 $f(A, B) = \\langle \\bar{C}, AB \\rangle_{\\mathrm{F}}$。两个矩阵 $X, Y \\in \\mathbb{R}^{k \\times l}$ 的弗罗贝尼乌斯内积是 $\\langle X, Y \\rangle_{\\mathrm{F}} = \\sum_{i=1}^{k} \\sum_{j=1}^{l} X_{ij} Y_{ij} = \\mathrm{tr}(X^{\\top}Y)$。\n\n我们的第一步是求出 $f$ 关于无穷小扰动 $dA$ 和 $dB$ 的一阶变分。我们从求乘积 $C = AB$ 的变分开始。我们用 $dA$ 扰动 $A$，用 $dB$ 扰动 $B$。扰动后的乘积是：\n$$\n(A + dA)(B + dB) = AB + A(dB) + (dA)B + (dA)(dB)\n$$\n微分，或一阶变分 $\\mathrm{d}(AB)$，由扰动 $dA$ 和 $dB$ 中的线性项组成。我们忽略高阶项 $(dA)(dB)$。因此，\n$$\n\\mathrm{d}(AB) = A(dB) + (dA)B\n$$\n现在，我们求泛函 $f$ 的微分。根据弗罗贝尼乌斯内积的线性：\n$$\n\\mathrm{d}f = \\mathrm{d} \\langle \\bar{C}, AB \\rangle_{\\mathrm{F}} = \\langle \\bar{C}, \\mathrm{d}(AB) \\rangle_{\\mathrm{F}}\n$$\n代入 $\\mathrm{d}(AB)$ 的表达式：\n$$\n\\mathrm{d}f = \\langle \\bar{C}, A(dB) + (dA)B \\rangle_{\\mathrm{F}} = \\langle \\bar{C}, A(dB) \\rangle_{\\mathrm{F}} + \\langle \\bar{C}, (dA)B \\rangle_{\\mathrm{F}}\n$$\n反向模式或伴随方法旨在将此微分表示为 $\\mathrm{d}f = \\langle \\bar{A}, dA \\rangle_{\\mathrm{F}} + \\langle \\bar{B}, dB \\rangle_{\\mathrm{F}}$ 的形式，其中 $\\bar{A}$ 和 $\\bar{B}$ 分别是 $A$ 和 $B$ 的伴随。我们可以通过重新排列 $\\mathrm{d}f$ 表达式中的项来找到 $\\bar{A}$ 和 $\\bar{B}$，以便将 $dA$ 和 $dB$ 分离为内积的右侧参数。我们使用性质 $\\langle X, YZ \\rangle_{\\mathrm{F}} = \\langle XZ^{\\top}, Y \\rangle_{\\mathrm{F}} = \\langle Y^{\\top}X, Z \\rangle_{\\mathrm{F}}$。\n\n对于涉及 $dB$ 的项，我们有 $\\langle \\bar{C}, A(dB) \\rangle_{\\mathrm{F}}$。设 $X=\\bar{C}$，$Y=A$，$Z=dB$。使用恒等式 $\\langle X, YZ \\rangle_{\\mathrm{F}} = \\langle Y^{\\top}X, Z \\rangle_{\\mathrm{F}}$，我们得到：\n$$\n\\langle \\bar{C}, A(dB) \\rangle_{\\mathrm{F}} = \\langle A^{\\top}\\bar{C}, dB \\rangle_{\\mathrm{F}}\n$$\n这确定了 $B$ 的伴随为 $\\bar{B} = A^{\\top}\\bar{C}$。我们来验证维度：$A^{\\top}$ 是 $n \\times m$ 而 $\\bar{C}$ 是 $m \\times p$，所以它们的乘积 $\\bar{B}$ 是 $n \\times p$，这与 $B$ 和 $dB$ 的维度相匹配。\n\n对于涉及 $dA$ 的项，我们有 $\\langle \\bar{C}, (dA)B \\rangle_{\\mathrm{F}}$。设 $X=\\bar{C}$，$Y=dA$，$Z=B$。使用恒等式 $\\langle X, YZ \\rangle_{\\mathrm{F}} = \\langle XZ^{\\top}, Y \\rangle_{\\mathrm{F}}$，我们得到：\n$$\n\\langle \\bar{C}, (dA)B \\rangle_{\\mathrm{F}} = \\langle \\bar{C}B^{\\top}, dA \\rangle_{\\mathrm{F}}\n$$\n这确定了 $A$ 的伴随为 $\\bar{A} = \\bar{C}B^{\\top}$。我们来验证维度：$\\bar{C}$ 是 $m \\times p$ 而 $B^{\\top}$ 是 $p \\times n$，所以它们的乘积 $\\bar{A}$ 是 $m \\times n$，这与 $A$ 和 $dA$ 的维度相匹配。\n\n所以，正确的伴随是：\n$$\n\\bar{A} = \\bar{C}B^{\\top} \\quad \\text{和} \\quad \\bar{B} = A^{\\top}\\bar{C}\n$$\n$f$ 沿方向 $(dA, dB)$ 的方向导数由 $D f(A,B)[dA,dB] = \\langle \\bar{A}, dA \\rangle_{\\mathrm{F}} + \\langle \\bar{B}, dB \\rangle_{\\mathrm{F}}$ 给出。\n\n数值验证测试将这个解析导数与有限差分近似进行比较。方向导数的中心差分近似是：\n$$\nD_{\\mathrm{FD}} f(A,B)[dA,dB] \\approx \\frac{f(A+\\varepsilon dA, B+\\varepsilon dB) - f(A-\\varepsilon dA, B-\\varepsilon dB)}{2\\varepsilon}\n$$\n对于一个小的步长 $\\varepsilon  0$。基于伴随的导数计算如下：\n$$\nD_{\\mathrm{ADJ}} f(A,B)[dA,dB] = \\langle \\bar{C}B^{\\top}, dA \\rangle_{\\mathrm{F}} + \\langle A^{\\top}\\bar{C}, dB \\rangle_{\\mathrm{F}}\n$$\n一个正确的实现应得出 $D_{\\mathrm{FD}} f \\approx D_{\\mathrm{ADJ}} f$。如果相对误差低于容差 $\\tau$，则测试通过：\n$$\n\\frac{|D_{\\mathrm{FD}} f - D_{\\mathrm{ADJ}} f|}{\\max\\{1, |D_{\\mathrm{FD}} f|\\}} \\le \\tau\n$$\n\n我们现在分析有错误的实现。\n1.  **错误的 $\\bar{A}$**：实现省略了对 $B$ 的转置，计算为 $\\bar{A}_{\\text{buggy}} = \\bar{C}B$。矩阵乘积 $\\bar{C}B$ 仅当内部维度匹配时才有定义，即 $\\bar{C}$ 的列数（$p$）等于 $B$ 的行数（$n$）。如果 $p \\neq n$，会发生维度不匹配错误，这立即揭示了错误。如果 $p=n$，计算可以继续，但得到的导数在数值上是不正确的，相对误差测试应该会失败。\n2.  **错误的 $\\bar{B}$**：实现省略了对 $A$ 的转置，计算为 $\\bar{B}_{\\text{buggy}} = A\\bar{C}$。此乘积仅当 $A$ 的列数（$n$）等于 $\\bar{C}$ 的行数（$m$）时才有定义。如果 $n \\neq m$，会发生维度不匹配。如果 $n=m$，计算可以继续，但会产生一个数值不正确的导数，测试应该能检测到。\n\n测试套件旨在探测这些条件。维度不相等的情况（例如 $(m,n,p)=(5,3,4)$）预计会导致有错误的实现出现维度不匹配错误。某些维度相等的情况（例如 $(m,n,p)=(4,4,4)$ 或 $(m,n,p)=(10,7,7)$）将需要数值比较来检测错误。该实现将系统地检查正确的伴随、对 $A$ 的错误伴随以及对 $B$ 的错误伴随与有限差分近似的对比。",
            "answer": "[[True, True, True], [True, True, True], [True, True, True], [True, True, True], [True, True, True]]"
        }
    ]
}