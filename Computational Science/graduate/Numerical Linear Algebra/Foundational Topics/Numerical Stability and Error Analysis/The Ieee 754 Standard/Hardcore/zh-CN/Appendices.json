{
    "hands_on_practices": [
        {
            "introduction": "在分析复杂的数值误差之前，我们必须首先量化不同浮点格式的基本精度。本练习  将指导你计算常用 IEEE 754 格式的有效数字位数（精度 $p$）和单位舍入误差 ($u$)。理解这两个参数是分析任何数值算法准确性的第一步。",
            "id": "3589114",
            "problem": "考虑电气和电子工程师协会（IEEE）754浮点算术标准及其二进制交换格式：binary16（半精度）、binary32（单精度）、binary64（双精度）和binary128（四倍精度）。在这些格式中，每个规格化的浮点数可以写成 $x = m \\times 2^{E}$ 的形式，其中 $m \\in [1, 2)$ 是尾数（significand），它有一个隐含的前导 $1$，后面跟着固定数量的小数位（fraction bits）；$E$ 是一个整数指数，其范围在由格式的指数场和偏置（bias）决定的规格化范围内。对于这四种格式，小数位数分别为 $10$（binary16）、$23$（binary32）、$52$（binary64）和 $112$（binary128）。\n\n在“向最近舍入，偶数优先”（round-to-nearest, ties-to-even）规则下，对一个规格化值进行单步舍入的舍入误差，其界限为该数量级下相邻可表示数之间间距的一半。在数值线性代数中，对于规格化算术的标准舍入模型，单步舍入操作表示为 $\\mathrm{fl}(x) = x(1 + \\delta)$，其中 $|\\delta| \\leq u$，$u$ 是单位舍入误差（unit roundoff）。正确的二进制数字位数定义为尾数中在舍入后保证与精确值匹配的比特数，而单位舍入误差 $u$ 量化了在“向最近舍入，偶数优先”规则下的最大相对舍入误差界限。\n\n从上述格式定义和“向最近舍入，偶数优先”规则出发，为每种格式推导出正确的二进制数字位数（尾数精度）和相应的规格化数的精确单位舍入误差 $u$。将您的最终答案表示为单行矩阵\n$$\n\\left(p_{16},\\, u_{16},\\, p_{32},\\, u_{32},\\, p_{64},\\, u_{64},\\, p_{128},\\, u_{128}\\right),\n$$\n其中，$p_{f}$ 是正确的二进制数字位数（尾数位数，包括隐含的前导 $1$），$u_{f}$ 是指定格式 $f \\in \\{16,32,64,128\\}$ 的单位舍入误差。无需舍入；请提供精确值。",
            "solution": "问题要求为 IEEE 754 标准指定的四种二进制交换格式（binary16、binary32、binary64 和 binary128）推导尾数精度 $p$ 和单位舍入误差 $u$。解题过程首先根据所提供的信息定义这些量，然后为每种格式计算它们的值。\n\n一个规格化的浮点数 $x$ 表示为 $x = s \\times m \\times 2^{E}$，其中 $s$ 是符号（$\\pm 1$），$m$ 是尾数，$E$ 是指数。对于所讨论的格式，尾数 $m$ 被规格化到区间 $[1, 2)$ 内，其二进制形式为 $m = (1.f_1f_2...f_n)_2$，其中前导的 $1$ 是隐含的，$f_1f_2...f_n$ 是存储在内存中的 $n$ 个小数位。\n\n问题将“正确的二进制数字位数”定义为尾数精度，记为 $p$。这是尾数中的总比特数，包括隐含的前导 $1$。如果一个格式有 $n$ 个小数位，则尾数精度由下式给出：\n$$\np = n + 1\n$$\n这个值 $p$ 决定了对于一个给定的数可以表示的有效比特数。\n\n单位舍入误差，记为 $u$，定义为在“向最近舍入”规则下，单次舍入操作的最大相对误差界限。标准舍入模型为 $\\mathrm{fl}(x) = x(1 + \\delta)$，其中 $|\\delta| \\leq u$。\n\n假设一个实数 $x$ 的表示需要超过 $p$ 个尾数位。舍入过程 $\\mathrm{fl}(x)$ 将 $x$ 映射到最近的可表示浮点数。设一个可表示数为 $y = m \\times 2^E$，其中 $m$ 是一个 $p$ 位尾数。下一个更大的可表示数是 $y^{+} = (m + 2^{-(p-1)}) \\times 2^E$。这两个数之间的距离，称为相对于指数 $E$ 的“最低有效位单位”（unit in the last place, ulp），为 $\\mathrm{ulp}(y) = 2^{-(p-1)} \\times 2^E$。\n\n在“向最近舍入”规则下，绝对误差的界限是此距离的一半：\n$$\n|\\mathrm{fl}(x) - x| \\leq \\frac{1}{2} \\mathrm{ulp}(\\mathrm{fl}(x)) = \\frac{1}{2} \\times 2^{-(p-1)} \\times 2^E = 2^{-p} \\times 2^E\n$$\n相对误差由 $\\frac{|\\mathrm{fl}(x) - x|}{|x|}$ 给出。为了找到上界 $u$，我们必须找到这个量在所有可能的非零实数 $x$ 上的上确界。\n$$\nu = \\sup_{x} \\frac{|\\mathrm{fl}(x) - x|}{|x|}\n$$\n对于恰好位于两个可表示浮点数中间的数，绝对舍入误差最大。让我们考虑这样一个数 $x = (m + 2^{-p}) \\times 2^E$，其中 $m$ 是较小的可表示数的尾数。绝对误差为 $|\\mathrm{fl}(x) - x| \\approx 2^{-p} \\times 2^E$。那么相对误差近似为：\n$$\n\\frac{2^{-p} \\times 2^E}{|x|} = \\frac{2^{-p} \\times 2^E}{|(m + 2^{-p}) \\times 2^E|} = \\frac{2^{-p}}{m + 2^{-p}}\n$$\n当分母最小时，此表达式最大化。对于一个规格化数，最小的尾数 $m$ 是 $1$。因此，最大相对误差发生在接近 $2$ 的幂的数上，并由一个趋近于 $\\frac{2^{-p}}{1} = 2^{-p}$ 的值作为界限。\n数值分析中对于“向最近舍入”算术的单位舍入误差的标准定义通常是机器 epsilon 的一半，即 $u = \\frac{1}{2} 2^{-(p-1)} = 2^{-p}$。\n这个值确保了关系式 $\\mathrm{fl}(x) = x(1+\\delta)$ 在 $|\\delta| \\leq u$ 的条件下成立。\n\n我们现在可以为每个指定的格式计算 $p$ 和 $u$。\n\n1.  **binary16 (半精度):**\n    小数位数给出为 $n_{16} = 10$。\n    尾数精度为 $p_{16} = n_{16} + 1 = 10 + 1 = 11$。\n    单位舍入误差为 $u_{16} = 2^{-p_{16}} = 2^{-11}$。\n\n2.  **binary32 (单精度):**\n    小数位数给出为 $n_{32} = 23$。\n    尾数精度为 $p_{32} = n_{32} + 1 = 23 + 1 = 24$。\n    单位舍入误差为 $u_{32} = 2^{-p_{32}} = 2^{-24}$。\n\n3.  **binary64 (双精度):**\n    小数位数给出为 $n_{64} = 52$。\n    尾数精度为 $p_{64} = n_{64} + 1 = 52 + 1 = 53$。\n    单位舍入误差为 $u_{64} = 2^{-p_{64}} = 2^{-53}$。\n\n4.  **binary128 (四倍精度):**\n    小数位数给出为 $n_{128} = 112$。\n    尾数精度为 $p_{128} = n_{128} + 1 = 112 + 1 = 113$。\n    单位舍入误差为 $u_{128} = 2^{-p_{128}} = 2^{-113}$。\n\n将这些结果组合成所要求的行矩阵 $(p_{16}, u_{16}, p_{32}, u_{32}, p_{64}, u_{64}, p_{128}, u_{128})$，即可得到最终答案。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n11  2^{-11}  24  2^{-24}  53  2^{-53}  113  2^{-113}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "舍入模式的选择可以显著改变计算结果，这一事实对区间算术等算法至关重要。本练习  通过一个假设场景，构建了一个具体的例子，其中向正无穷和向负无穷舍入对一个简单的加法产生不同的结果。这个练习揭示了落在两个可表示浮点数之间的数值是如何被处理的，并阐明了为何定向舍入是创建严格边界的强大工具。",
            "id": "3589160",
            "problem": "考虑遵循电气和电子工程师协会 (IEEE) 754 binary64 格式（双精度）的算术，该格式将一个规格化浮点数 $x$ 表示为 $x = m \\cdot 2^{e}$，其中 $1 \\leq m  2$，$e \\in \\mathbb{Z}$，并且尾数为 $53$ 位（包括隐含的前导 $1$）。对于一个规格化数 $x$，其末位单位 $\\mathrm{ulp}(x)$ 定义为在 $x$ 的量级上相邻可表示浮点数之间的间隙，当 $x$ 的无偏指数为 $e$ 时，其值等于 $2^{e-52}$。朝向 $+\\infty$ 的定向舍入返回满足 $r \\geq s$ 的最小可表示浮点数 $r$，而朝向 $-\\infty$ 的定向舍入返回满足 $r \\leq s$ 的最大可表示浮点数 $r$，其中 $s$ 是精确的实数结果。\n\n你需要构建并分析一个与数值线性代数相关的具体 binary64 示例，其中 $a$ 是一个大数值，$b$ 是一个远小于它的修正量。令 $a = 2^{100}$ 和 $b = 3 \\cdot 2^{46}$，并考虑 $a + b$ 的浮点求和。该求和过程先进行精确的实数加法，然后采用两种定向模式之一（朝向 $+\\infty$ 和朝向 $-\\infty$）进行舍入。仅使用上面给出的 IEEE 754 核心定义，确定两个舍入后的和 $r_{+} = \\operatorname{round}_{+\\infty}(a+b)$ 和 $r_{-} = \\operatorname{round}_{-\\infty}(a+b)$，然后将其差的绝对值 $|r_{+} - r_{-}|$ 量化为 $\\mathrm{ulp}(a+b)$ 的倍数。\n\n将你的最终答案表示为一个实数，该实数等于 $|r_{+} - r_{-}| = k \\cdot \\mathrm{ulp}(a+b)$ 中的倍数 $k$。无需舍入。",
            "solution": "该问题要求我们分析两个数 $a$ 和 $b$ 在两种不同定向舍入模式下的浮点求和。\n\n首先，我们将给定的数表示为标准浮点形式。\n数 $a = 2^{100}$ 已经是规格化形式 $m \\cdot 2^{e}$，其尾数 $m_a = 1$，指数 $e_a = 100$。由于其小数部分为零，因此它可以在 binary64 格式中精确表示。\n\n数 $b = 3 \\cdot 2^{46}$ 可以写作 $b = (2+1) \\cdot 2^{46} = (1.5) \\cdot 2 \\cdot 2^{46} = 1.5 \\cdot 2^{47}$。它也是一个规格化的、可精确表示的数，尾数 $m_b = 1.5 = 1.1_2$，指数 $e_b = 47$。\n\n接下来，我们计算精确的实数和 $s = a+b$。\n$s = 2^{100} + 3 \\cdot 2^{46}$\n为了在浮点系统中分析这个和，我们提出较大的 2 的幂，$2^{100}$，以确定结果的指数和尾数。\n$s = 2^{100} \\cdot \\left(1 + \\frac{3 \\cdot 2^{46}}{2^{100}}\\right) = 2^{100} \\cdot (1 + 3 \\cdot 2^{-54})$\n精确和 $s$ 的指数为 $e_s = 100$，尾数为 $m_s = 1 + 3 \\cdot 2^{-54}$。\n\n现在我们检查尾数 $m_s$，看它是否能在 binary64 格式中表示。一个可表示的尾数具有 $1.f_1 f_2 \\dots f_{52}$ 的形式，其中 $f_i$ 是 $52$ 个小数位。这样一个尾数的值是 $1 + \\sum_{i=1}^{52} f_i 2^{-i}$。\n让我们用二进制表示 $m_s$ 的小数部分。\n$3 \\cdot 2^{-54} = (2+1) \\cdot 2^{-54} = 2 \\cdot 2^{-54} + 1 \\cdot 2^{-54} = 2^{-53} + 2^{-54}$。\n因此，尾数为 $m_s = 1 + 2^{-53} + 2^{-54}$。\n在二进制中，这表示为 $m_s = 1.\\underbrace{00\\dots0}_{52 \\text{ zeros}}11_2$。\n尾数 $m_s$ 在二进制小数点后的第 $53$ 位和第 $54$ 位上有非零位。由于 binary64 格式只存储 $52$ 个小数位，因此 $m_s$ 无法精确表示。和 $s = a+b$ 必须进行舍入。\n\n为了执行定向舍入，我们必须确定包围精确和 $s$ 的两个可表示浮点数。这些数将具有与 $s$ 相同的指数 $e=100$。\n令 $r_{-}$ 为小于或等于 $s$ 的最大可表示数，令 $r_{+}$ 为大于或等于 $s$ 的最小可表示数。\n$r_{-}$ 的尾数是通过在第 $52$ 个小数位后截断 $m_s$ 的二进制表示得到的。\n$m_{-} = 1.\\underbrace{00\\dots0}_{52 \\text{ zeros}} = 1$。\n因此，$r_{-} = 1 \\cdot 2^{100} = 2^{100}$。\n\n数 $r_{+}$ 是 $r_{-}$ 之后的下一个可表示浮点数。具有指数 $e$ 的连续可表示数之间的间隙是 $2^{e-52}$。这个值也是该范围内数值的 $\\mathrm{ulp}$ 的定义。对于 $e=100$，间隙为 $2^{100-52} = 2^{48}$。\n所以，$r_{+} = r_{-} + 2^{100-52} = 2^{100} + 2^{48}$。\n$r_{+}$ 的尾数是 $m_{+} = 1 + 2^{-52}$，即 $1.\\underbrace{00\\dots01}_{52 \\text{ bits}}$。\n\n我们有不等式 $r_{-}  s  r_{+}$。我们来验证一下：\n$r_{-} = 2^{100}$\n$s = 2^{100} + 3 \\cdot 2^{46}$\n$r_{+} = 2^{100} + 2^{48} = 2^{100} + 4 \\cdot 2^{46}$\n确实，$2^{100}  2^{100} + 3 \\cdot 2^{46}  2^{100} + 4 \\cdot 2^{46}$。\n\n现在我们应用指定的舍入模式：\n- 朝向 $-\\infty$ 舍入（向下取整）：$\\operatorname{round}_{-\\infty}(s)$ 是满足 $r \\leq s$ 的最大可表示数。这个数是 $r_{-}$。\n  $\\operatorname{round}_{-\\infty}(a+b) = r_{-} = 2^{100}$。\n- 朝向 $+\\infty$ 舍入（向上取整）：$\\operatorname{round}_{+\\infty}(s)$ 是满足 $r \\geq s$ 的最小可表示数。这个数是 $r_{+}$。\n  $\\operatorname{round}_{+\\infty}(a+b) = r_{+} = 2^{100} + 2^{48}$。\n\n下一步是计算这两个舍入值之差的绝对值。\n$|r_{+} - r_{-}| = |(2^{100} + 2^{48}) - 2^{100}| = 2^{48}$。\n\n最后，我们需要将这个差表示为 $\\mathrm{ulp}(a+b)$ 的倍数。\n精确和 $s = a+b$ 是一个指数为 $e=100$ 的规格化数。根据问题的定义，$\\mathrm{ulp}(s)$ 由以下公式给出：\n$\\mathrm{ulp}(a+b) = 2^{e-52} = 2^{100-52} = 2^{48}$。\n\n我们在寻找常数 $k$，使得 $|r_{+} - r_{-}| = k \\cdot \\mathrm{ulp}(a+b)$。\n代入我们找到的值：\n$2^{48} = k \\cdot 2^{48}$。\n解出 $k$ 得 $k = 1$。\n\n两种定向舍入结果之差的绝对值恰好是和的一个末位单位。",
            "answer": "$$\\boxed{1}$$"
        },
        {
            "introduction": "现代处理器提供了如融合乘加（FMA）之类的专门指令，可以提升数值计算的精度和性能。这最后一个练习  将挑战你从概念上分析，在使用 FMA 进行简单累加与采用经典的误差补偿技术（如 Kahan 求和）之间的权衡。通过评估所提出的各种陈述，你将更深刻地理解硬件特性与算法设计如何相互作用，以控制像点积这样的复杂计算中的舍入误差。",
            "id": "3589159",
            "problem": "考虑国际电气与电子工程师协会浮点数算术标准 (IEEE 754) 的 binary64 格式，采用“向最接近的值舍入，偶数优先”(round-to-nearest ties-to-even) 的舍入模式，支持次正规数，并且所述运算不会发生溢出。令单位舍入误差由 $u$ 表示（对于 binary64， $u = 2^{-53}$）。融合乘加 (Fused Multiply-Add, FMA) 运算将 $a \\times b + c$ 计算为精确的实数 $a b + c$，然后对结果进行一次舍入，使其符合目标格式。假设 $n \\geq 1$ 且 $x_i, a_i, b_i \\in \\mathbb{R}$ 是有界的，因此不会发生溢出。\n\n要求您分析 FMA 在数值线性代数中对补偿求和 (compensated summation) 的影响。对于一个普通求和 $S = \\sum_{i=1}^{n} x_i$，Kahan 风格的补偿求和使用一个补偿变量 $c$ 并执行如下更新：\n$$\ny \\leftarrow x_i - c, \\quad t \\leftarrow s + y, \\quad c \\leftarrow (t - s) - y, \\quad s \\leftarrow t,\n$$\n这在代数上保证了 $s + c$ 比单独的 $s$ 更接近精确的累加和。对于点积 $S = \\sum_{i=1}^{n} a_i b_i$，可以在累加步骤中使用 FMA：$s \\leftarrow \\mathrm{fma}(a_i, b_i, s)$。\n\n从 IEEE 754 对向最接近值舍入的定义、FMA 的单次舍入语义以及算术运算的标准浮点误差模型出发，分析以下哪些陈述是正确的或错误的，并论证 FMA 在何种情况下可以替代显式补偿以达到相似的精度。选择所有正确选项。\n\nA. 在纯粹求和 $S = \\sum_{i=1}^{n} x_i$ 中，如果舍入模式为“向最接近的值舍入，偶数优先”，用 $s \\leftarrow \\mathrm{fma}(x_i, 1, s)$ 替代 $s \\leftarrow s + x_i$ 可以省去 Kahan 风格的补偿，并获得与 Kahan 补偿求和相当的前向误差界（误差界最多相差一个小的常数因子）。\n\nB. 在点积 $S = \\sum_{i=1}^{n} a_i b_i$ 中，使用 $s \\leftarrow \\mathrm{fma}(a_i, b_i, s)$ 将每项的舍入次数从两次减少到一次。在最坏情况的对抗性输入顺序下，由此产生的前向误差仍然是 $O(n u)$ 阶，而 Kahan 风格的补偿可以将误差增长降低到 $O(u)$ 阶；因此，对于长的、病态的累加，仅 FMA 无法匹敌 Kahan 在最坏情况下的精度。\n\nC. 对于 $p_i \\leftarrow \\mathrm{fl}(a_i b_i)$ 和 $e_i \\leftarrow \\mathrm{fma}(a_i, b_i, -p_i)$，在没有溢出且 $e_i$ 不会下溢为零的情况下，在实数算术中，有 $p_i + e_i = a_i b_i$ 精确成立。因此，在这些条件下，将 $p_i$ 累加到一个运行和中，并将 $e_i$ 累加到第二个运行和中，可以得到一种源自 FMA 的补偿机制，该机制在点积运算中可以匹敌 Kahan 风格补偿的精度优势。\n\nD. 在定向舍入（例如，向零舍入）下，Kahan 更新 $c \\leftarrow (t - s) - y$ 不再是有效的数值恒等式，因此 FMA 绝对更优，并且可以在任何舍入模式下替代显式补偿。\n\nE. 如果启用了“刷新为零”(flush-to-zero, FTZ) 或“视非正规数为零”(denormals-are-zero, DAZ)，那么在陈述 C 中计算 $e_i \\leftarrow \\mathrm{fma}(a_i, b_i, -p_i)$ 时，对于由相消主导的项，可能会伪真地产生 $e_i = 0$，从而破坏补偿机制；因此，要依赖 FMA 来替代显式的 Kahan 风格补偿，必须确保完全支持次正规数，并避免 $e_i$ 发生下溢。",
            "solution": "此问题要求分析关于在数值求和与点积中使用融合乘加 (FMA) 运算的几个陈述，特别是与 Kahan 风格的补偿求和进行比较。运算环境是 IEEE 754 binary64 标准，采用“向最接近的值舍入，偶数优先”的舍入模式，支持次正规数，且无溢出。单位舍入误差为 $u = 2^{-53}$。\n\n一个标准的浮点运算 $\\circ \\in \\{+, -, \\times, \\div\\}$ 被建模为 $\\mathrm{fl}(x \\circ y) = (x \\circ y)(1+\\delta)$，其中 $|\\delta| \\leq u$。\n融合乘加运算被建模为 $\\mathrm{fma}(a, b, c) = \\mathrm{fl}(ab+c) = (ab+c)(1+\\eta)$，其中 $|\\eta| \\leq u$。其关键特征是，它先计算出精确的乘积 $a \\times b$，再与 $c$ 相加，然后才对最终结果进行一次舍入，使其符合目标格式。\n\nKahan 求和算法用于计算 $S = \\sum_{i=1}^{n} x_i$，它维护一个累加和 $s$ 和一个补偿项 $c$。一次迭代如下：\n$y \\leftarrow \\mathrm{fl}(x_i - c)$\n$t \\leftarrow \\mathrm{fl}(s + y)$\n$c \\leftarrow \\mathrm{fl}(\\mathrm{fl}(t - s) - y)$\n$s \\leftarrow t$\n在标准假设下，最终和 $s_n$ 的误差界为 $(2u + O(nu^2))\\sum_{i=1}^{n} |x_i|$。其关键特征是，误差界在 $u$ 的一阶上与 $n$ 无关。相比之下，简单的递归求和 $s_k \\leftarrow \\mathrm{fl}(s_{k-1} + x_k)$ 的误差界随 $n$ 线性增长，大约为 $(n-1)u \\sum_{i=1}^{n} |x_i|$。\n\n现在我们来评估每个陈述。\n\n### 选项 A 分析\n该陈述提议对于纯粹求和 $S = \\sum_{i=1}^{n} x_i$，用 FMA 运算 $s \\leftarrow \\mathrm{fma}(x_i, 1, s)$ 来替代标准加法 $s \\leftarrow \\mathrm{fl}(s + x_i)$。其主张是这种替代方法可以省去 Kahan 补偿，并达到相当的误差界。\n\n运算 $\\mathrm{fma}(x_i, 1, s)$ 计算的是 $\\mathrm{fl}(x_i \\cdot 1 + s)$。设 $x_i$ 和 $s$ 是浮点数。数字 $1$ 是可以精确表示的。乘积 $x_i \\cdot 1$ 就是 $x_i$，这是一个精确的运算。因此，$\\mathrm{fma}(x_i, 1, s) = \\mathrm{fl}(x_i + s)$。这与标准的浮点加法运算完全相同。\n\n与简单加法相比，以这种方式使用 FMA 并未提供新的计算路径或减少舍入误差。该求和仍然是一个递归求和，其中和 $s_k$ 的更新规则是 $s_k \\leftarrow \\mathrm{fl}(s_{k-1} + x_k)$。如前所述，该方法的最坏情况前向误差为 $O(nu)$ 阶。Kahan 补偿求和的最坏情况前向误差界为 $O(u)$ 阶（忽略 $u$ 的高阶项）。当 $n$ 很大时，这两个误差界不具有可比性。因此，这种 FMA 的用法并不能省去为达到高精度而使用的 Kahan 风格补偿。\n\n结论：**错误**。\n\n### 选项 B 分析\n该陈述涉及点积 $S = \\sum_{i=1}^{n} a_i b_i$。\n第 1 部分：使用 $s \\leftarrow \\mathrm{fma}(a_i, b_i, s)$ 将每项的舍入次数从两次减少到一次。\n标准实现会计算 $p_i \\leftarrow \\mathrm{fl}(a_i b_i)$（一次舍入），然后更新总和 $s \\leftarrow \\mathrm{fl}(s + p_i)$（第二次舍入）。总计每项有两个舍入误差。基于 FMA 的更新是 $s \\leftarrow \\mathrm{fma}(a_i, b_i, s) = \\mathrm{fl}(a_i b_i + s)$。这涉及计算精确乘积 $a_i b_i$，加上之前的和 $s$，然后执行单次舍入。这将每项的舍入操作次数从两次减少到一次。这部分陈述是正确的。\n\n第 2 部分：在最坏情况下，由此产生的前向误差仍然是 $O(nu)$ 阶，且对于长的、病态的累加，仅 FMA 无法匹敌 Kahan 在最坏情况下的精度。\n基于 FMA 的点积是项 $a_i b_i$ 的递归求和。设 $s_k$ 是 $k$ 项之后的和。更新公式为 $s_k = \\mathrm{fl}(a_k b_k + s_{k-1}) = (a_k b_k + s_{k-1})(1+\\eta_k)$，其中 $|\\eta_k| \\le u$。其误差传播分析与标准递归求和的分析基本相同。最终误差的界与 $nu\\sum_{i=1}^n|a_ib_i|$ 成正比。误差界的增长与 $n$ 呈线性关系。一个病态的累加，例如将许多小项加到一个大的累加和中，将表现出这种较差的精度。\n当 Kahan 风格的补偿应用于乘积序列 $p_i = \\mathrm{fl}(a_i b_i)$ 时，其最终误差的界在 $u$ 的一阶上与 $n$ 无关。对于大的 $n$，这是一个显著的改进。因此，当 FMA 用于简单累加时，对于长的或病态的和，其精度无法与补偿求和相匹敌。\n\n结论：**正确**。\n\n### 选项 C 分析\n该陈述描述了一种基于 FMA 为乘积创建无误差变换（error-free transformation）的方法，该技术被称为 `TwoProduct`。方法如下：\n1. $p_i \\leftarrow \\mathrm{fl}(a_i b_i)$\n2. $e_i \\leftarrow \\mathrm{fma}(a_i, b_i, -p_i)$\n\n第 1 部分：“在实数算术中，有 $p_i + e_i = a_i b_i$ 精确成立”。\n设 $a_i$ 和 $b_i$ 是具有 $P$ 个有效数字位（对于 binary64， $P=53$）的二进制浮点数。它们的精确乘积 $a_i b_i$ 可能需要多达 $2P$ 位来表示。量 $p_i = \\mathrm{fl}(a_i b_i)$ 是这个精确乘积舍入到 $P$ 位的结果。舍入误差为 $E = a_i b_i - p_i$。浮点算术的一个基本定理（最初由 Dekker 提出）指出，只要没有下溢或溢出，这个误差 $E$ 本身就可以精确地表示为一个浮点数。FMA 指令计算 $e_i = \\mathrm{fl}(a_i b_i - p_i)$。由于精确值 $a_i b_i - p_i$ 是一个浮点数，对其进行舍入没有影响，即 $\\mathrm{fl}(a_i b_i - p_i) = a_i b_i - p_i$。因此，$e_i = a_i b_i - p_i$，整理后可得 $p_i + e_i = a_i b_i$。这部分陈述，包括其附带条件，是正确的。这是一种标准的无误差变换 (Error-Free Transformation, EFT)。\n\n第 2 部分：“将 $p_i$ 累加到一个运行和中，并将 $e_i$ 累加到第二个运行和中，可以得到一种补偿机制……可以匹敌 Kahan 风格补偿的精度优势”。\n这描述了一种精确的求和算法。我们将精确的点积 $\\sum a_i b_i$ 分解为 $\\sum (p_i + e_i) = \\sum p_i + \\sum e_i$。我们现在可以计算高位部分的和 $S_p = \\sum p_i$ 以及低位误差部分的和 $S_e = \\sum e_i$。最终结果即为 $S_p + S_e$。这是一种双精度累加（与 double-double 算术相关）的形式。像 Ogita、Rump 和 Oishi 提出的 `Dot2` 算法就完全采用了这个原理。对此类方法的误差分析表明，它们非常精确，其误差界与对舍入乘积序列 $\\mathrm{fl}(a_i b_i)$ 应用 Kahan 求和相当或更优。\n\n结论：**正确**。\n\n### 选项 D 分析\n该陈述声称，在定向舍入（例如，向零舍入）下，Kahan 更新 $c \\leftarrow \\mathrm{fl}(\\mathrm{fl}(t-s)-y)$ 变得无效，因此 FMA “绝对更优”。\n\n第 1 部分：“在定向舍入下……Kahan 更新……不再是有效的数值恒等式”。\nKahan 求和中误差计算的正确性依赖于一种称为 `TwoSum` 的无误差变换，它严重依赖于舍入模式为“向最接近的值舍入”。具体来说，允许使用减法恢复 $t = \\mathrm{fl}(s+y)$ 中舍入误差的定理（通常利用 Sterbenz 引理的性质，即若 $a/2 \\le b \\le 2a$，则 $\\mathrm{fl}(a-b)=a-b$）在定向舍入下会失效。定向舍入会引入偏差，舍入误差不再保证是一个可以通过简单减法精确恢复的浮点数。因此，Kahan 补偿的效果会变差，误差项无法被精确恢复。这部分陈述是正确的。\n\n第 2 部分：“因此 FMA 绝对更优，并且可以在任何舍入模式下替代显式补偿”。\n这个结论是一个不合逻辑的推论 (non-sequitur)。即使 Kahan 求和的性能下降，也并不意味着一个简单的基于 FMA 的求和 $s \\leftarrow \\mathrm{fma}(a_i, b_i, s)$ 就是“绝对更优”的。如在 B 中所证，这种简单的 FMA 累加的误差界随 $O(nu)$ 增长。一个性能下降的 Kahan 求和，虽然不如在“向最接近的值舍入”模式下有效，但通常仍能抵消误差的高位部分，并且通常表现得比朴素求和好得多，特别是对于大的 $n$。宣称 FMA “绝对更优”是不正确的。此外，该陈述似乎忽略了基于 FMA 的补偿方案（如 C 中所述）的可能性，这种方案将远优于简单的 FMA 累加。这一主张是过度概括且逻辑上有缺陷。\n\n结论：**错误**。\n\n### 选项 E 分析\n该陈述考虑了在 FTZ（刷新为零）或 DAZ（视非正规数为零）模式下，选项 C 中基于 FMA 的补偿方法 $e_i \\leftarrow \\mathrm{fma}(a_i, b_i, -p_i)$。\n\n该补偿机制依赖于误差项 $e_i = a_i b_i - p_i$ 的精确计算。这个误差项可能非常小。具体来说，其大小有界：$|e_i| \\le u |p_i|$。如果 $p_i$ 本身很小，或者由于相消， $e_i$ 可能会落入次正规数范围（绝对值小于最小正规化数 $2^{E_{min}}$ 的数）。\n\nFTZ (Flush-To-Zero) 是一种模式，其中任何结果为次正规数的操作都会产生一个（有符号的）零。如果真实误差 $e_i$ 是次正规数范围内的非零值，在启用 FTZ 的情况下计算它将得到结果 $0$。\nDAZ (Denormals-Are-Zero) 将作为运算输入的次正规数视为零。这也可能影响 $e_i$ 的计算。\n\n如果 $e_i$ 被伪真地刷新为零，恒等式 $p_i + e_i = a_i b_i$ 就会被打破。该步骤的误差项丢失，补偿失败。误差项的累加和 $\\sum e_i$ 变得不准确，补偿方案的精度优势也受到破坏。因此，为了使 `TwoProduct` 无误差变换和类似的补偿方案可靠，硬件和软件环境必须按照完整的 IEEE 754 标准正确支持次正规数。问题陈述正确地假设了这种支持（“支持次正规数”），而这个选项正确地指出了如果缺少这种支持会发生什么。\n\n结论：**正确**。",
            "answer": "$$\\boxed{BCE}$$"
        }
    ]
}