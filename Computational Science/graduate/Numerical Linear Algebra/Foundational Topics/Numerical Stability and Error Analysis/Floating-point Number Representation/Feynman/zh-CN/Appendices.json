{
    "hands_on_practices": [
        {
            "introduction": "我们从一个看似简单的任务开始：在标准的浮点格式中表示数字 $0.1$。这项练习  之所以至关重要，是因为它揭示了表示误差的核心概念。这种误差的根源在于，许多有限的十进制小数在二进制中会变成无限循环小数。通过亲手推导其二进制表示并应用舍入规则，你将具体理解为何即使是基础的数字也常常被不精确地存储。",
            "id": "3546541",
            "problem": "给定由电气和电子工程师协会 (IEEE) 754 binary64 格式定义的以2为基数（二进制）的浮点系统，回顾以下基本定义。一个规格化浮点数的形式为 $x = \\pm (1 + f)\\,2^{e}$，其中 $f \\in [0,1)$ 在二进制下最多有 $p-1$ 个小数位（对于 binary64，计入隐含的前导位，p=53），$e$ 是一个整数指数。舍入模式是就近舍入，当出现平局时向偶数有效数舍入。实数 $x$ 通过此规则舍入到最接近的可表示浮点数，从而映射到其浮点值 $\\operatorname{fl}(x)$。\n\n仅从这些定义和有理数二进制展开的第一性原理出发，对 $x = 0.1$ 执行以下操作：\n- 推导出 $x$ 的无限二进制展开，并确定其循环节。\n- 通过确定其精确的规格化有效数和指数，来确定唯一的最近 binary64 表示 $\\operatorname{fl}(0.1)$，该表示形式为 $(1 + f)\\,2^{e}$，其中 $f$ 是一个分子和分母均为整数的有理数。\n- 计算精确误差 $\\operatorname{fl}(0.1) - 0.1$，结果表示为一个最简有理数。\n\n你的最终答案必须是仅由单个最简有理数给出的精确误差 $\\operatorname{fl}(0.1) - 0.1$。无需舍入。不要包含单位。",
            "solution": "此任务要求解当实数 $x = 0.1$ 在 IEEE 754 binary64 浮点格式中表示时产生的精确舍入误差。此任务需要三个主要步骤：首先，确定 $x=0.1$ 的二进制展开；其次，应用指定的舍入规则找到其 binary64 表示 $\\operatorname{fl}(0.1)$；第三，计算误差 $\\operatorname{fl}(0.1) - 0.1$。\n\n首先，我们将 $x=0.1$ 表示为有理数 $x = \\frac{1}{10}$。我们推导其二进制展开，其形式为 $x = (0.b_1 b_2 b_3 \\dots)_2 = \\sum_{i=1}^{\\infty} b_i 2^{-i}$，其中 $b_i \\in \\{0, 1\\}$。比特 $b_i$ 可以通过连续乘以2并取整数部分的方法求得。\n设 $x_0 = x = \\frac{1}{10}$。\n$2x_0 = \\frac{2}{10} = \\frac{1}{5}$。整数部分是 $b_1 = \\lfloor \\frac{1}{5} \\rfloor = 0$。小数部分是 $x_1 = \\frac{1}{5}$。\n$2x_1 = \\frac{2}{5}$。整数部分是 $b_2 = \\lfloor \\frac{2}{5} \\rfloor = 0$。小数部分是 $x_2 = \\frac{2}{5}$。\n$2x_2 = \\frac{4}{5}$。整数部分是 $b_3 = \\lfloor \\frac{4}{5} \\rfloor = 0$。小数部分是 $x_3 = \\frac{4}{5}$。\n$2x_3 = \\frac{8}{5} = 1 + \\frac{3}{5}$。整数部分是 $b_4 = \\lfloor \\frac{8}{5} \\rfloor = 1$。小数部分是 $x_4 = \\frac{3}{5}$。\n$2x_4 = \\frac{6}{5} = 1 + \\frac{1}{5}$。整数部分是 $b_5 = \\lfloor \\frac{6}{5} \\rfloor = 1$。小数部分是 $x_5 = \\frac{1}{5}$。\n在这一步，我们发现 $x_5 = x_1$。小数部分的序列现在将开始重复，因此从 $b_2$ 开始的相应比特也将重复。重复的比特块是 $b_2 b_3 b_4 b_5$，即 $0011$。\n因此，$0.1$ 的二进制展开是 $x = (0.0001100110011\\dots)_2$，可以紧凑地写为 $x = (0.0\\overline{0011})_2$。循环节是序列 $0011$。\n\n接下来，我们确定 $x$ 的 binary64 表示。一个规格化浮点数的形式为 $\\pm (1+f) \\cdot 2^e$。我们必须将 $x$ 重写为这种科学记数法形式。\n$x = (0.000110011\\dots)_2$。\n为了规格化，我们将二进制小数点向右移动 $4$ 位：\n$x = (1.100110011\\dots)_2 \\times 2^{-4}$。\n由此，我们确定指数 $e = -4$。理想有效数是 $M = (1.100110011\\dots)_2$。\n\nbinary64 格式对有效数使用 $p=53$ 位的精度（1个隐含位和 $p-1=52$ 个小数位）。我们必须将理想有效数舍入到 $52$ 个小数位。这等价于将值 $x \\cdot 2^{52-e}$ 舍入到最近的整数，得到一个53位的整数有效数 $S$，然后计算表示值 $\\operatorname{fl}(x) = S \\cdot 2^{e-52}$。\n\n需要舍入的值是 $x \\cdot 2^{52-e} = \\frac{1}{10} \\cdot 2^{52 - (-4)} = \\frac{1}{10} \\cdot 2^{56} = \\frac{2^{55}}{5}$。\n为了将此值舍入到最近的整数，我们分析其小数部分。我们可以使用模运算来求 $2^{55}$ 除以 $5$ 的余数。\n$2^1 \\equiv 2 \\pmod 5$\n$2^2 \\equiv 4 \\equiv -1 \\pmod 5$\n$2^4 \\equiv (-1)^2 \\equiv 1 \\pmod 5$\n我们可以将 $55$ 写成 $55 = 4 \\cdot 13 + 3$。\n所以，$2^{55} = 2^{4 \\cdot 13 + 3} = (2^4)^{13} \\cdot 2^3 \\equiv 1^{13} \\cdot 8 \\equiv 8 \\equiv 3 \\pmod 5$。\n这意味着对于某个整数 $k$，$2^{55} = 5k + 3$。\n所以，需要舍入的值是 $\\frac{5k+3}{5} = k + \\frac{3}{5}$。\n因为小数部分 $\\frac{3}{5} = 0.6$ 大于 $0.5$，所以我们向上舍入到 $k+1$。这不是平局情况，所以“偶数优先”规则不适用。\n舍入后的整数有效数是 $S = k+1 = \\frac{2^{55}-3}{5} + 1 = \\frac{2^{55}-3+5}{5} = \\frac{2^{55}+2}{5}$。\n\n因此，$0.1$ 的 binary64 表示为：\n$\\operatorname{fl}(0.1) = S \\cdot 2^{e-52} = \\frac{(2^{55}+2)/5}{2^{56}} = \\frac{2^{55}+2}{5 \\cdot 2^{56}}$。\n我们可以简化这个表达式：\n$\\operatorname{fl}(0.1) = \\frac{2^{55}}{5 \\cdot 2^{56}} + \\frac{2}{5 \\cdot 2^{56}} = \\frac{1}{5 \\cdot 2} + \\frac{1}{5 \\cdot 2^{55}} = \\frac{1}{10} + \\frac{1}{5 \\cdot 2^{55}}$。\n\n最后，我们计算精确误差 $E = \\operatorname{fl}(0.1) - 0.1$。\n$E = \\left(\\frac{1}{10} + \\frac{1}{5 \\cdot 2^{55}}\\right) - \\frac{1}{10}$。\n$E = \\frac{1}{5 \\cdot 2^{55}}$。\n这个分数已经是最简形式，因为它分子为1。",
            "answer": "$$\\boxed{\\frac{1}{5 \\cdot 2^{55}}}$$"
        },
        {
            "introduction": "在了解了数字可能被不精确存储之后，我们现在来探究这对算术运算会产生何种后果。这项练习  展示了数值计算中最臭名昭著的陷阱之一：灾难性相消。通过在 `binary32` 格式下模拟两个非常接近的数字的减法，你将观察到初始的表示误差如何被放大，最终导致结果的有效数字大量损失，这突显了这种常见数值不稳定性的危险。",
            "id": "3642283",
            "problem": "考虑在电气与电子工程师协会（IEEE $754$）浮点数算术标准中执行的算术，具体为 binary$32$ 格式，该格式具有一位符号位、八位指数位（偏置值为 $127$），以及 $23$ 位小数位（对于规格化数，其含有一个隐藏的前导 $1$）。两个十进制输入 $x = 123456.78$ 和 $y = 123456.77$ 首先使用“向最近取整，偶数优先”的规则转换为 binary$32$ 格式，然后在相同的规则下执行减法 $x - y$ 并将结果正确舍入为 binary$32$ 格式。仅从 binary$32$ 的结构定义和规格化出发，确定硬件为该减法运算返回的精确十进制值。\n\n将最终答案表示为一个精确的十进制数。无需单位。",
            "solution": "该问题要求我们模拟在遵循IEEE 754 binary32标准的硬件中，对两个相近的十进制数进行转换和减法运算的过程，以演示灾难性相消的效应。\n\n**1. 确定相关的浮点精度 (ULP)**\n\n首先，我们必须确定输入数字 $x = 123456.78$ 和 $y = 123456.77$ 的量级。我们可以找到界定它们的2的幂：\n$$2^{16} = 65536$$\n$$2^{17} = 131072$$\n由于 $2^{16}  x, y  2^{17}$，这些数字的任何规格化binary32表示都将具有一个无偏指数 $E=16$。\n在这种格式下，一个规格化数的值由 $v = (-1)^s \\times (1.f)_2 \\times 2^E$ 给出，其中 $s$ 是符号位，$f$ 是23位小数部分。存储在8位指数域中的偏置指数是 $e = E + 127 = 16 + 127 = 143$。\n\n这个范围内的数字的精度由有效数（significand）的最低有效位的值决定。这被称为最后一位的单位（Unit in the Last Place, ULP）。\n$$\\text{ULP} = 2^E \\times 2^{-23} = 2^{16} \\times 2^{-23} = 2^{-7}$$\n作为十进制数，ULP是：\n$$\\text{ULP} = \\frac{1}{128} = 0.0078125$$\n在 $[2^{16}, 2^{17})$ 范围内的实数，将被舍入到最接近的ULP整数倍。\n\n**2. 将输入 `x` 转换为 binary32 格式**\n\n为了找到 $x = 123456.78$ 的binary32表示，我们将 $x$ 除以ULP，以确定它最接近哪个倍数。\n$$\\frac{x}{\\text{ULP}} = \\frac{123456.78}{0.0078125} = 123456.78 \\times 128 = 15802467.84$$\n这个数字表示按 $2^{23}$ 缩放后的有效数。根据“向最近取整，偶数优先”的规则，我们必须将其舍入到最近的整数。由于小数部分 $0.84$ 大于 $0.5$，我们向上取整。\n$$N_x = \\text{round}(15802467.84) = 15802468$$\n$x$ 的存储值，我们称之为 $x_{b32}$，是ULP的这个整数倍。\n$$x_{b32} = N_x \\times \\text{ULP} = 15802468 \\times 0.0078125 = 123456.78125$$\n\n**3. 将输入 `y` 转换为 binary32 格式**\n\n我们对 $y = 123456.77$ 重复相同的过程。\n$$\\frac{y}{\\text{ULP}} = \\frac{123456.77}{0.0078125} = 123456.77 \\times 128 = 15802466.56$$\n小数部分 $0.56$ 大于 $0.5$，所以我们向上取整。注意，这不是一个平局（tie），所以规则中“偶数优先”的部分没有被触发。\n$$N_y = \\text{round}(15802466.56) = 15802467$$\n$y$ 的存储值，我们称之为 $y_{b32}$，是：\n$$y_{b32} = N_y \\times \\text{ULP} = 15802467 \\times 0.0078125 = 123456.7734375$$\n\n**4. 执行减法并确定最终结果**\n\n硬件对存储的表示 $x_{b32}$ 和 $y_{b32}$ 执行减法。这次减法的精确结果是：\n$$d = x_{b32} - y_{b32} = 123456.78125 - 123456.7734375 = 0.0078125$$\n最后一步是确保这个结果 $d$ 能被正确地存储在一个binary32寄存器中，这可能涉及另一次舍入。我们必须检查 $d$ 是否是精确可表示的。\n$$d = 0.0078125 = \\frac{1}{128} = 2^{-7}$$\n这个值可以写成规格化浮点形式 $1.0_2 \\times 2^{-7}$。\n- 符号为正 ($s=0$) 。\n- 有效数是 $1.0_2$，所以小数部分 $f$ 全为零。\n- 无偏指数是 $E = -7$。\n这个指数在规格化binary32数的有效范围 $[-126, 127]$ 之内。由于该值是2的幂，它在二进制浮点格式中是精确可表示的。因此，最终结果不需要舍入。\n\n硬件返回的值是存储值相减的精确结果。",
            "answer": "$$\n\\boxed{0.0078125}\n$$"
        },
        {
            "introduction": "在探究了表示误差和灾难性相消的陷阱后，我们现在转向一个建设性的挑战：设计能够抵御浮点数限制的算法。斜边计算公式 $\\sqrt{a^2 + b^2}$ 的一个直接实现，很容易因为不必要的中间上溢或下溢而失败。这个动手实践问题  将指导你通过代数变换来重构表达式，从而开发一个数值稳定的函数，以避免这些错误，并强调了在数值计算中精心进行算法设计的重要性。",
            "id": "3231635",
            "problem": "您需要实现一个鲁棒的数值程序，通过计算 $\\sqrt{a^{2} + b^{2}}$ 来为两个实数输入计算斜边。该计算方式应避免不必要的上溢和下溢，同时遵循电气与电子工程师协会（IEEE）浮点算术标准（IEEE 754）的语义，包括处理特殊值，如非数值（NaN）和正无穷大。此任务的基本依据是浮点表示的核心定义，其中有限实数表示为 $x = (-1)^{s} \\, m \\, 2^{e}$，其中 $s \\in \\{0,1\\}$，$m \\in [1,2)$（对于规格化数）或 $m \\in (0,1)$（对于非规格化数），以及整数指数 $e$。此外，还需依据以下运算事实：乘法和加法会四舍五入到最接近的可表示值，产生超过最大可表示有限值的操作会得到 $+\\infty$，而产生小于最小正可表示非规格化值的操作会得到 $0$。\n\n设计并实现一个算法，给定任何实数输入 $a$ 和 $b$（包括负值），为 $\\sqrt{a^{2} + b^{2}}$ 生成一个数值稳定的值，且在对 $a$ 或 $b$ 进行平方会导致上溢或下溢时，避免直接进行平方运算。您的算法必须：\n- 基于上述浮点表示，使用代数变换，在组合各项之前提出主导量级，以确保当真实的数学结果是可表示的有限数时，计算保持在安全范围内。\n- 通过使用量级来正确处理符号，因为 $\\sqrt{a^{2} + b^{2}}$ 仅取决于 $|a|$ 和 $|b|$。\n- 遵循 IEEE 754 对特殊值的语义：如果任一输入为 $+\\infty$ 或 $-\\infty$，结果必须为 $+\\infty$；如果两个输入都不是无穷大且至少一个输入是 NaN，结果必须是 NaN；如果两个输入都是零，结果必须是 $0$。\n- 当最终的数学正确结果是有限数时，避免中间步骤中不必要的上溢或下溢。\n\n此问题不涉及物理单位。不涉及角度。不涉及百分比。\n\n将您的程序实现为一个函数，将其应用于以下测试套件，并按要求格式生成输出。\n\n测试套件（每个项目为一对 $(a,b)$）：\n1. $(a,b) = (3 \\times 10^{100}, \\; 4 \\times 10^{100})$\n2. $(a,b) = (1 \\times 10^{308}, \\; 1)$\n3. $(a,b) = (3 \\times 10^{-200}, \\; 4 \\times 10^{-200})$\n4. $(a,b) = (0, \\; 0)$\n5. $(a,b) = (+\\infty, \\; 1)$\n6. $(a,b) = (\\operatorname{NaN}, \\; +\\infty)$\n7. $(a,b) = (1.7976931348623157 \\times 10^{308}, \\; 1.7976931348623157 \\times 10^{308})$\n8. $(a,b) = (1 \\times 10^{-320}, \\; 1 \\times 10^{-320})$\n9. $(a,b) = (-3 \\times 10^{100}, \\; 4 \\times 10^{100})$\n10. $(a,b) = (1 \\times 10^{308}, \\; 1 \\times 10^{-309})$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含将您的鲁棒斜边函数应用于所有测试用例的结果，结果为逗号分隔的列表，并用方括号括起来。对浮点数使用默认的字符串表示，允许 $+\\infty$ 和 $\\operatorname{NaN}$ 作为其运行时表示形式出现（例如，“inf”和“nan”）。例如，输出行可能看起来像“[result1,result2, ... ,result10]”。",
            "solution": "本任务要求设计一个鲁棒的算法来计算斜边 $h = \\sqrt{a^2 + b^2}$，该算法需要能避免在使用有限精度浮点算术（如IEEE 754标准）时可能出现的数值错误。\n\n直接实现此公式的主要问题在于中间的平方运算，$a^2$ 和 $b^2$。对于标准的双精度浮点数（`float64`），可表示的最大有限值约为 $1.798 \\times 10^{308}$。如果 $|a|$ 或 $|b|$ 超过此值的平方根（约 $1.34 \\times 10^{154}$），其平方将上溢至正无穷大（$+\\infty$）。例如，如果 $a = 10^{200}$ 且 $b = 10^{200}$，朴素的计算将得到 $\\sqrt{(10^{200})^2 + (10^{200})^2} \\rightarrow \\sqrt{\\infty + \\infty} \\rightarrow \\infty$。然而，真实的数学结果是 $\\sqrt{2 \\times (10^{200})^2} = \\sqrt{2} \\times 10^{200}$，这是一个完全可以表示的值。\n\n相反，最小的正规格化双精度值约为 $2.225 \\times 10^{-308}$。如果 $|a|$ 和 $|b|$ 都非常小（例如，非规格化数），它们的平方可能会下溢为零。例如，如果 $a = 10^{-200}$ 且 $b = 10^{-200}$，朴素的计算将导致 $\\sqrt{(10^{-200})^2 + (10^{-200})^2} \\rightarrow \\sqrt{0 + 0} \\rightarrow 0$。这个结果丢失了所有精度，而真实结果是 $\\sqrt{2} \\times 10^{-200}$，一个非零、可表示的数。\n\n为了构建一个鲁棒的算法，我们必须对表达式进行代数重构，以防止这些中间计算失败。解决方案在于通过提出具有最大量级的项来缩放问题。设 $x = |a|$ 和 $y = |b|$，因为斜边仅取决于输入的量级。不失一般性，我们假设 $x \\ge y$。\n\n计算过程如下：\n$$ h = \\sqrt{x^2 + y^2} $$\n我们从平方根下的表达式中提出较大的项 $x$：\n$$ h = \\sqrt{x^2 \\left(1 + \\frac{y^2}{x^2}\\right)} $$\n这可以重写为：\n$$ h = \\sqrt{x^2} \\sqrt{1 + \\left(\\frac{y}{x}\\right)^2} $$\n由于 $x = |a|$ 是非负的，$\\sqrt{x^2} = x$。表达式变为：\n$$ h = x \\sqrt{1 + \\left(\\frac{y}{x}\\right)^2} $$\n这种缩放后的公式在数值上是稳定的。比率 $r = y/x$ 保证在区间 $[0, 1]$ 内，因为我们选择了 $x$ 作为两个量级的最大值。因此，对这个比率求平方 $r^2$ 永远不会导致上溢。虽然如果 $y$ 远小于 $x$，$r^2$ 可能会下溢为 $0$，但这是一种良性的精度损失；在这种情况下，$h \\approx \\sqrt{x^2} = x$，算法正确地计算出 $x \\sqrt{1+0} = x$。最后的乘法 $x$ 将结果重新缩放回原始量级。如果真实的数学结果本身大于最大可表示的浮点数，这最后一步可能会正确地导致上溢至 $+\\infty$。\n\n除了核心的数值逻辑，算法还必须正确处理 IEEE 754 定义的特殊值，如问题中所述。这些检查的顺序至关重要，并遵循问题指定的优先级。\n\n完整的鲁棒算法结构如下：\n1.  **处理无穷大**：首先，检查输入 $a$ 或 $b$ 是否为正或负无穷大。如果是，结果为正无穷大（$+\\infty$）。\n2.  **处理 NaN**：如果两个输入都不是无穷大，则检查任一输入是否为非数值（NaN）。如果是，结果为 NaN。\n3.  **量级和排序**：取输入的绝对值，$x = |a|$ 和 $y = |b|$。确定较大的量级（我们称之为 `large`）和较小的量级（`small`）。\n4.  **零情况**：如果 `large` 为 $0$，则意味着 $x$ 和 $y$ 均为 $0$，结果为 $0$。\n5.  **缩放计算**：如果 `large` 非零，计算比率 $r = \\text{small}/\\text{large}$。\n6.  **最终结果**：最终结果计算为 $\\text{large} \\times \\sqrt{1 + r^2}$。此过程保证了当最终结果也可表示时，中间计算保持在可表示的范围内。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a robust procedure to compute the hypotenuse sqrt(a^2 + b^2)\n    and applies it to a suite of test cases.\n    \"\"\"\n\n    def robust_hypot(a: float, b: float) - float:\n        \"\"\"\n        Computes sqrt(a^2 + b^2) without unnecessary overflow or underflow.\n\n        Args:\n            a: A real number.\n            b: A real number.\n\n        Returns:\n            The numerically stable result of sqrt(a^2 + b^2), respecting\n            IEEE 754 semantics for special values.\n        \"\"\"\n        # Per the problem statement, infinity has precedence over NaN.\n        # Rule: If either input is +/- infinity, the result is +infinity.\n        if np.isinf(a) or np.isinf(b):\n            return np.inf\n\n        # Rule: If neither is infinite and at least one is NaN, the result is NaN.\n        if np.isnan(a) or np.isnan(b):\n            return np.nan\n\n        # Use absolute values for the main computation as the result depends on magnitudes.\n        x = abs(a)\n        y = abs(b)\n\n        # Sort to determine the larger and smaller magnitudes.\n        if x  y:\n            large = x\n            small = y\n        else:\n            large = y\n            small = x\n\n        # If the largest component is 0, then both inputs must be 0.\n        if large == 0.0:\n            return 0.0\n\n        # The core of the robust algorithm: scale by the largest component\n        # to ensure the ratio is = 1, preventing overflow when squared.\n        ratio = small / large\n        \n        # The final result is computed using the scaled-down value and then\n        # scaled back up by multiplying with 'large'.\n        # This approach avoids intermediate overflow/underflow.\n        return large * np.sqrt(1.0 + ratio**2)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (3e100, 4e100),\n        (1e308, 1.0),\n        (3e-200, 4e-200),\n        (0.0, 0.0),\n        (np.inf, 1.0),\n        (np.nan, np.inf),\n        (np.finfo(np.float64).max, np.finfo(np.float64).max),\n        (1e-320, 1e-320),\n        (-3e100, 4e100),\n        (1e308, 1e-309)\n    ]\n\n    results = []\n    for a, b in test_cases:\n        result = robust_hypot(a, b)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The default string representation for floats handles \"inf\" and \"nan\".\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}