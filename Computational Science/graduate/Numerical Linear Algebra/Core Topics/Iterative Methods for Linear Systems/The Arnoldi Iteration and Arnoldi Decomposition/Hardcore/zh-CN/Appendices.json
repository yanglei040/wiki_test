{
    "hands_on_practices": [
        {
            "introduction": "本练习将指导你构建一个混合精度 Arnoldi 迭代算法，这是一个在高性能计算中常见的优化策略。你将学习如何巧妙地结合半精度浮点数（如 FP16）进行快速的矩阵向量乘法，同时使用双精度（如 FP64）来保证格拉姆-施密特正交化过程的数值稳定性。通过在行为良好的矩阵上验证该算法的 Ritz 值的准确性，你将亲身体验在不牺牲过多精度的情况下换取计算速度的权衡艺术。",
            "id": "3584299",
            "problem": "您需要设计并实现一个混合精度 Arnoldi 迭代，为实方阵 $A \\in \\mathbb{R}^{n \\times n}$ 构建 Arnoldi 分解，其中矩阵向量乘积使用半精度浮点格式，所有正交化步骤使用双精度。该混合精度方案必须遵循以下原则：在第 $j$ 次迭代时，给定单位向量 $q_j \\in \\mathbb{R}^n$，通过半精度乘积计算进入 Arnoldi 正交化阶段的新向量 $w$，即 $w = \\operatorname{float64}\\!\\left(\\operatorname{float16}(A) \\cdot \\operatorname{float16}(q_j)\\right)$，然后在完全双精度的环境下完成带重正交化的修正 Gram–Schmidt 过程。此处，$\\operatorname{float16}(\\cdot)$ 表示量化到半精度浮点格式，而 $\\operatorname{float64}(\\cdot)$ 表示转回双精度。\n\n您的推导和实现必须仅基于以下基本定义和事实：\n- Arnoldi 过程为 Krylov 子空间 $\\mathcal{K}_k(A,q_1) = \\operatorname{span}\\{q_1, A q_1, \\dots, A^{k-1} q_1\\}$ 构建一个标准正交基 $V_k = [q_1,\\dots,q_k] \\in \\mathbb{R}^{n \\times k}$ 以及一个实上 Hessenberg 矩阵 $H_k \\in \\mathbb{R}^{k \\times k}$，使得 $A V_k \\approx V_k H_k + h_{k+1,k} q_{k+1} e_k^\\top$，其中 $e_k \\in \\mathbb{R}^k$ 是第 $k$ 个标准基向量，$h_{k+1,k} \\ge 0$ 是决定过程是否中断的次对角线元素。\n- Ritz 值是 $H_k$ 的特征值，在精确算术中且 $k = n$ 时，它们与 $A$ 的特征值一致，因为 $H_n = V_n^\\top A V_n$ 与 $A$ 正交相似。\n\n您的程序必须：\n1. 完全按照上述规定实现混合精度 Arnoldi 迭代，使用带一步重正交化的修正 Gram-Schmidt 过程在完全双精度的环境下构建 $V_k$ 和 $H_k$。\n2. 对于下述每个测试用例，运行 $k$ 步（如果 $h_{j+1,j} = 0$ 则提前终止），在双精度下计算 Ritz 值（$H_k$ 的特征值），并将其与在双精度下计算的 $A$ 的真实特征值进行比较。使用最小化绝对差之和的 Ritz 值到真实特征值的最小一对一分配，并报告匹配对中的最大绝对差是否在指定容差范围内。\n3. 如果在任一测试用例的处理过程中出现任何非有限数（非数值或无穷大），则报告该测试用例失败。\n\n您必须使用一个从可复现分布中抽取的固定初始向量 $q_1$：其各元素从标准正态分布中独立抽样，然后归一化为单位长度，随机种子设置为一个固定整数。\n\n通过您的实现和推理，解释为什么该方案会根据矩阵的不同而成功或失败，且仅使用上述基本事实和可靠的数值推理。您不得引入任何外部公式来简化上述事实所要求的推理过程。\n\n矩阵族和测试套件：\n- 对于下述每个案例，请完全按照规定构造矩阵 $A$，选择 $n$ 和 $k$，并使用给定的容差 $\\tau$。每个案例的输出是一个布尔值，指示匹配的 Ritz 值与 $A$ 的真实特征值之间的最大绝对偏差是否不大于 $\\tau$。\n- 五个测试用例是：\n  1. 案例名称：SPD_tridiag_good。构造 $A \\in \\mathbb{R}^{n \\times n}$ 为对称三对角矩阵，其主对角线元素等于 $1$，第一副对角线元素等于 $-1/2$；即 $A = \\operatorname{tridiag}(-\\tfrac{1}{2}, 1, -\\tfrac{1}{2})$。使用 $n = 30$，$k = n$，容差 $\\tau = 5 \\cdot 10^{-3}$。\n  2. 案例名称：Diagonal_fp16_exact_good。构造 $A = \\operatorname{diag}(d_1,\\dots,d_n)$，其元素在集合 $\\{1, \\tfrac{1}{2}, \\tfrac{1}{4}, \\tfrac{1}{8}, \\tfrac{1}{16}\\}$ 中循环，并乘以交替符号，即 $d_i = s_i \\cdot 2^{-r_i}$，其中 $s_i \\in \\{+1,-1\\}$ 随 $i$ 交替，而 $r_i$ 在 $\\{0,1,2,3,4\\}$ 中循环。使用 $n = 25$，$k = n$，容差 $\\tau = 5 \\cdot 10^{-3}$。\n  3. 案例名称：NonNormal_shift_fail。构造 $A = D + \\alpha N$，其中 $D = \\operatorname{diag}(d_1,\\dots,d_n)$ 的 $d_i$ 在 $[0.9, 1.1]$ 上线性间隔，$N \\in \\mathbb{R}^{n \\times n}$ 在第一上副对角线上为 1，其余为 0，且 $\\alpha = 20$。使用 $n = 30$，$k = n$，容差 $\\tau = 10^{-2}$。\n  4. 案例名称：Clustered_diag_fail。构造 $A = \\operatorname{diag}(1 + i \\cdot 10^{-4})$，其中 $i = 0,1,\\dots,n-1$。使用 $n = 30$，$k = n$，容差 $\\tau = 3 \\cdot 10^{-4}$。\n  5. 案例名称：Overflow_fp16_fail。构造 $A = s I + N$，其中 $s = 70000$，$I$ 是单位矩阵，$N$ 在第一上副对角线上为 1，其余为 0。使用 $n = 20$，$k = n$，容差 $\\tau = 10^{-1}$。\n\n距离和匹配规范：\n- 令 $\\{\\theta_1,\\dots,\\theta_m\\}$ 是执行 $m \\le k$ 步后从 $H_m$ 获得的 Ritz 值（如果没有中断，则 $m=k$）。令 $\\{\\lambda_1,\\dots,\\lambda_n\\}$ 是在双精度下计算的 $A$ 的特征值。计算 $\\{\\theta_j\\}_{j=1}^m$ 与 $\\{\\lambda_i\\}_{i=1}^n$ 的一个大小为 $m$ 的子集之间的最小成本匹配，该匹配最小化 $\\sum_{j=1}^m \\lvert \\theta_j - \\lambda_{\\pi(j)} \\rvert$，其中 $\\pi$ 是一个单射映射。如果 $m = k$，所有涉及的数值都是有限的，并且 $\\max_{1 \\le j \\le m} \\lvert \\theta_j - \\lambda_{\\pi(j)} \\rvert \\le \\tau$，则报告成功。\n\n不涉及角度单位。不涉及物理单位。所有答案均为无单位数字。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含五个测试用例的结果，格式为一个逗号分隔的、用方括号括起来的 Python 风格布尔值列表（例如，“[True,False,True,False,True]”）。\n\n您提交的必须是一个完整的、可运行的程序，该程序能够按规定构造矩阵，运行混合精度 Arnoldi 方案，计算 Ritz 值，执行匹配，评估容差测试，并以上述确切格式打印最终列表。不允许用户输入，除了指定的用于初始化 $q_1$ 的固定种子外，不得使用其他随机性。",
            "solution": "我们从 Arnoldi 构造和 Ritz 值的定义开始。给定 $A \\in \\mathbb{R}^{n \\times n}$ 和一个单位向量 $q_1 \\in \\mathbb{R}^n$，Arnoldi 过程构建标准正交向量 $q_1,\\dots,q_k$ 和标量 $h_{i,j}$，形成具有上 Hessenberg 结构 的 $H_k \\in \\mathbb{R}^{k \\times k}$，使得\n$$\nA V_k = V_k H_k + h_{k+1,k} q_{k+1} e_k^\\top,\n$$\n其中 $V_k = [q_1,\\dots,q_k] \\in \\mathbb{R}^{n \\times k}$ 具有标准正交列，$e_k \\in \\mathbb{R}^k$ 是第 $k$ 个基向量。$H_k$ 的特征值是 Ritz 值，也是 $A$ 的近似特征值。在精确算术中且 $k=n$ 时，$V_n$ 是一个标准正交基，$H_n = V_n^\\top A V_n$ 与 $A$ 正交相似，因此其特征值与 $A$ 的特征值完全相同。\n\n我们现在设计一个符合这些原则的混合精度方案。矩阵向量乘积 $A q_j$ 是我们唯一以降低的精度执行的步骤，用以模拟应用 $A$ 速度快但精度低的硬件，同时我们保持高精度下正交化的稳定性。具体来说，给定双精度的 $q_j$，我们计算\n$$\nw = \\operatorname{float64}\\!\\left(\\operatorname{float16}(A) \\cdot \\operatorname{float16}(q_j)\\right),\n$$\n然后使用双精度的修正 Gram–Schmidt 过程将 $w$ 与当前基向量 $\\{q_i\\}_{i=1}^j$ 正交化：\n$$\nh_{i,j} = q_i^\\top w, \\quad w \\leftarrow w - h_{i,j} q_i \\quad \\text{对于 } i = 1,\\dots,j,\n$$\n并进行一次重正交化以抑制舍入误差的累积：\n$$\n\\hat{h}_{i,j} = q_i^\\top w, \\quad h_{i,j} \\leftarrow h_{i,j} + \\hat{h}_{i,j}, \\quad w \\leftarrow w - \\hat{h}_{i,j} q_i \\quad \\text{对于 } i = 1,\\dots,j.\n$$\n然后，我们在双精度下设置 $h_{j+1,j} = \\lVert w \\rVert_2$。如果 $h_{j+1,j} = 0$，我们宣布分解中断并停止；否则，$q_{j+1} = w / h_{j+1,j}$。得到的 $H_k$ 是上 Hessenberg 矩阵，其元素 $h_{i,j}$ 位于次对角线及其上方。\n\n混合精度的基本原理如下。使用半精度计算 $A q_j$ 会引入有限精度线性算子应用中典型的扰动。如果我们记 $\\widetilde{A} = \\operatorname{float16}(A)$，以及 $q_j^{(16)} = \\operatorname{float16}(q_j)$，那么进入正交化阶段的实际向量是 $w = \\widetilde{A} q_j^{(16)}$ 转换回双精度后的结果。相对于精确算术，存在两个扰动源：(i) 用 $\\widetilde{A}$ 替换 $A$（一个线性算子扰动），以及 (ii) 用 $q_j^{(16)}$ 替换 $q_j$（引入了非线性，因为每次迭代中 $q_j$ 的舍入方式都不同）。然而，在双精度下使用带重正交化的修正 Gram-Schmidt 过程可以使基向量保持接近标准正交，从而控制了可能污染 $H_k$ 的正交性损失。\n\n为了评估准确性，我们将 Ritz 值（$H_k$ 的特征值）与在双精度下计算的 $A$ 的真实特征值进行比较。由于 Arnoldi 投影根据初始向量和子空间的不同，会针对谱的某些部分，我们在所有情况下都强制 $k=n$，以便在精确算术中 $H_n$ 与 $A$ 正交相似。在混合精度下，偏差源于受扰动的乘积，但对于良态且良好缩放的矩阵， $H_n$ 的特征值应保持接近 $A$ 的特征值。\n\n我们现在论证预期的成功和失败模式：\n- 对于对称、良好缩放且其元素可在半精度下精确表示的问题，方案会成功：如果 $A$ 的元素可在半精度下精确表示（例如，主对角线为 $1$、副对角线为 $-1/2$ 的对称三对角矩阵），则 $\\widetilde{A} = A$。剩下的唯一矩阵向量积误差来自在乘积前将 $q_j$ 四舍五入到半精度。这种每次迭代的扰动量级约为半精度的机器精度，大约是 $\\varepsilon_{16} \\approx 2^{-10} \\approx 10^{-3}$。当 $k=n$ 且使用双精度正交化时，对于良态矩阵，对 $H_n$ 谱的累积效应通常是温和的，因此 Ritz 值与真实特征值的匹配误差在几个 $\\varepsilon_{16}$ 的量级内，例如 $5 \\cdot 10^{-3}$。\n- 对于高度非正规矩阵，方案会失败：对于 $A = D + \\alpha N$，其中 $N$ 是严格上移位矩阵且 $\\alpha$ 很大，$A$ 的特征值为 $\\{d_i\\}$，但高度非正规。特征值对扰动极其敏感；算子或迭代的微小非正规扰动可能导致 Ritz 值即使在 $k=n$ 时也显著偏离真实特征值。这类 $A$ 的伪谱很大，混合精度矩阵向量乘积对 $A$ 产生的有效扰动，在非正规基下衡量时，可能产生大于 $10^{-2}$ 的差异。\n- 对于紧密聚集的特征值，方案会失败：如果 $A$ 是对角矩阵，其元素为 $1 + i \\cdot 10^{-4}$，则特征值之间的间距为 $10^{-4}$。半精度在 1 附近的单位舍入误差约为 $10^{-3}$，这超过了特征值的聚集间隙。混合精度矩阵向量乘积无法可靠地分辨该尺度的特征值差异，因此匹配的 Ritz 值将不会在 $3 \\cdot 10^{-4}$ 的容差内接近真实特征值。\n- 由于半精度溢出，方案会失败：半精度的最大有限数值约为 $6.5504 \\cdot 10^{4}$。如果我们用 $s = 70000$ 缩放 $A$，那么 $\\operatorname{float16}(A)$ 在对角线上将包含无穷大。随后的矩阵向量乘积会产生非有限值，导致过程失败。\n\n算法设计：\n1. 实现混合精度 Arnoldi 迭代，其中矩阵向量乘积计算为 $w = \\operatorname{float64}\\!\\big(\\operatorname{float16}(A) \\cdot \\operatorname{float16}(q_j)\\big)$。\n2. 使用双精度的修正 Gram–Schmidt 过程和重正交化计算 $H_k$ 和 $V_k$。\n3. 将 Ritz 值计算为双精度下 $H_k$ 的特征值。\n4. 计算双精度下 $A$ 的真实特征值。\n5. 解决最小分配问题以匹配 Ritz 值和特征值，最小化绝对差之和，并计算匹配对之间的最大绝对差。\n6. 如果没有中断（$m = k$），所有中间值都是有限的，且最大差异不大于容差，则声明成功。\n\n测试套件覆盖范围：\n- SPD_tridiag_good 检验了具有精确半精度可表示性和良好条件数的“理想路径”。\n- Diagonal_fp16_exact_good 测试了当 $A$ 为对角矩阵且其值可在半精度下精确表示时的正确性，仅强调每次迭代舍入 $q_j$ 的影响。\n- NonNormal_shift_fail 检验了非正规敏感性。\n- Clustered_diag_fail 是一个针对半精度单位舍入误差尺度的边界情况。\n- Overflow_fp16_fail 测试了由于半精度动态范围限制导致的灾难性失败。\n\n最终程序将显式构造每个矩阵，使用固定种子的初始向量运行混合精度 Arnoldi 迭代，执行匹配和容差检查，并以要求的格式单行打印布尔结果列表。",
            "answer": "```python\nimport numpy as np\nfrom scipy import linalg\nfrom scipy.optimize import linear_sum_assignment\n\ndef arnoldi_mixed_precision(A, k, seed=42):\n    \"\"\"\n    Mixed-precision Arnoldi:\n    - Matvec w = float64( float16(A) @ float16(q_j) )\n    - Orthogonalization in float64 with MGS + reorthogonalization.\n    Returns V (n x m), H (m x m), m actual steps performed.\n    Stops early on breakdown or non-finite values.\n    \"\"\"\n    n = A.shape[0]\n    # Initial vector q1: random normal with fixed seed, normalized\n    rng = np.random.default_rng(seed)\n    q = rng.standard_normal(n)\n    q_norm = np.linalg.norm(q)\n    if not np.isfinite(q_norm) or q_norm == 0.0:\n        return None, None, 0\n    q = q / q_norm\n\n    # Prepare float16 version of A once (as per scheme)\n    A_fp16 = A.astype(np.float16)\n\n    V = np.zeros((n, k), dtype=np.float64)\n    H = np.zeros((k, k), dtype=np.float64)\n\n    V[:, 0] = q\n\n    for j in range(k):\n        # Compute w = A q_j using half precision for both A and q_j\n        try:\n            qj_fp16 = V[:, j].astype(np.float16)\n            w_fp16 = A_fp16 @ qj_fp16\n        except Exception:\n            # In case of incompatible sizes or others\n            return V[:, :j], H[:j, :j], j\n        w = w_fp16.astype(np.float64)\n\n        # Check finiteness\n        if not np.all(np.isfinite(w)):\n            return V[:, :j], H[:j, :j], j\n\n        # Modified Gram-Schmidt\n        for i in range(j + 1):\n            hij = np.dot(V[:, i], w)\n            H[i, j] += hij\n            w = w - hij * V[:, i]\n\n        # Reorthogonalization\n        for i in range(j + 1):\n            hij = np.dot(V[:, i], w)\n            H[i, j] += hij\n            w = w - hij * V[:, i]\n\n        h_next = np.linalg.norm(w)\n        if not np.isfinite(h_next):\n            return V[:, :j], H[:j, :j], j\n        if j + 1  k:\n            H[j + 1, j] = h_next\n\n        if h_next == 0.0 or j + 1 == k:\n            # Breakdown or finish\n            m = j + 1\n            return V[:, :m], H[:m, :m], m\n        V[:, j + 1] = w / h_next\n\n    # Normally not reached\n    m = k\n    return V[:, :m], H[:m, :m], m\n\n\ndef construct_matrix(case_name, n):\n    if case_name == \"SPD_tridiag_good\":\n        A = np.zeros((n, n), dtype=np.float64)\n        diag = 1.0\n        off = -0.5\n        np.fill_diagonal(A, diag)\n        idx = np.arange(n - 1)\n        A[idx, idx + 1] = off\n        A[idx + 1, idx] = off\n        return A\n    elif case_name == \"Diagonal_fp16_exact_good\":\n        vals = []\n        signs = [1.0, -1.0]\n        powers = [0, 1, 2, 3, 4]  # 1, 1/2, 1/4, 1/8, 1/16\n        for i in range(n):\n            s = signs[i % 2]\n            r = powers[i % len(powers)]\n            vals.append(s * (2.0 ** (-r)))\n        return np.diag(np.array(vals, dtype=np.float64))\n    elif case_name == \"NonNormal_shift_fail\":\n        d = np.linspace(0.9, 1.1, n)\n        D = np.diag(d)\n        N = np.zeros((n, n), dtype=np.float64)\n        idx = np.arange(n - 1)\n        N[idx, idx + 1] = 1.0\n        alpha = 20.0\n        return D + alpha * N\n    elif case_name == \"Clustered_diag_fail\":\n        d = 1.0 + (np.arange(n, dtype=np.float64)) * 1e-4\n        return np.diag(d)\n    elif case_name == \"Overflow_fp16_fail\":\n        A = np.zeros((n, n), dtype=np.float64)\n        s = 70000.0\n        np.fill_diagonal(A, s)\n        idx = np.arange(n - 1)\n        A[idx, idx + 1] = 1.0\n        return A\n    else:\n        raise ValueError(\"Unknown case name\")\n\n\ndef match_and_max_diff(ritz_vals, true_eigs):\n    \"\"\"\n    Match each Ritz value to a distinct true eigenvalue minimizing total absolute difference.\n    Returns max absolute difference among matched pairs.\n    \"\"\"\n    r = np.array(ritz_vals, dtype=np.complex128)\n    lam = np.array(true_eigs, dtype=np.complex128)\n\n    # Cost matrix: absolute differences\n    cost = np.abs(r[:, None] - lam[None, :])\n    # Solve assignment: assign each Ritz to a unique eigenvalue\n    row_ind, col_ind = linear_sum_assignment(cost)\n    diffs = cost[row_ind, col_ind]\n    max_diff = np.max(diffs) if diffs.size  0 else np.inf\n    return float(np.real(max_diff))\n\n\ndef evaluate_case(case_name, n, k, tol, seed=12345):\n    A = construct_matrix(case_name, n)\n    # Run mixed-precision Arnoldi\n    V, H, m = arnoldi_mixed_precision(A, k, seed=seed)\n\n    # Conditions for failure\n    if V is None or H is None:\n        return False\n    if m != k:\n        return False\n    if not np.all(np.isfinite(H)) or not np.all(np.isfinite(V)):\n        return False\n\n    # Compute Ritz values: eigenvalues of H\n    try:\n        ritz_vals = linalg.eigvals(H)\n    except Exception:\n        return False\n    if not np.all(np.isfinite(ritz_vals)):\n        return False\n\n    # True eigenvalues of A in double precision\n    try:\n        true_eigs = linalg.eigvals(A)\n    except Exception:\n        return False\n    if not np.all(np.isfinite(true_eigs)):\n        return False\n\n    # Match and compute maximum absolute difference\n    max_diff = match_and_max_diff(ritz_vals, true_eigs)\n    if not np.isfinite(max_diff):\n        return False\n\n    return bool(max_diff = tol)\n\n\ndef solve():\n    # Define the test cases exactly as specified\n    test_cases = [\n        (\"SPD_tridiag_good\", 30, 30, 5e-3),\n        (\"Diagonal_fp16_exact_good\", 25, 25, 5e-3),\n        (\"NonNormal_shift_fail\", 30, 30, 1e-2),\n        (\"Clustered_diag_fail\", 30, 30, 3e-4),\n        (\"Overflow_fp16_fail\", 20, 20, 1e-1),\n    ]\n    results = []\n    for name, n, k, tol in test_cases:\n        res = evaluate_case(name, n, k, tol, seed=2024)\n        results.append(res)\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "在上一个练习的基础上，本次实践将让你扮演一名“数值侦探”，使用你已构建的混合精度算法来探索其失效的边界。你将通过一系列精心设计的数值实验，研究当矩阵具有高度非正规性、特征值紧密聚集或数值超出半精度表示范围时，算法的精度为何会急剧下降甚至崩溃。这个过程将深化你对有限精度算术与矩阵谱特性之间相互作用的理解。",
            "id": "3584299",
            "problem": "你需要设计并实现一个混合精度 Arnoldi 迭代，为一个实方阵 $A \\in \\mathbb{R}^{n \\times n}$ 构建 Arnoldi 分解。其中，矩阵向量乘积使用半精度浮点格式，而所有正交化步骤使用双精度。该混合精度方案必须遵循以下原则：在第 $j$ 次迭代中，给定单位向量 $q_j \\in \\mathbb{R}^n$，通过半精度乘积计算进入 Arnoldi 正交化阶段的新向量 $w$，即 $w = \\operatorname{float64}\\!\\left(\\operatorname{float16}(A) \\cdot \\operatorname{float16}(q_j)\\right)$，然后在完全双精度的环境下，使用带重正交的修正 Gram–Schmidt 过程完成计算。此处，$\\operatorname{float16}(\\cdot)$ 表示量化为半精度浮点格式，而 $\\operatorname{float64}(\\cdot)$ 表示转换回双精度。\n\n你的推导和实现必须仅基于以下基本定义和事实：\n- Arnoldi 过程为 Krylov 子空间 $\\mathcal{K}_k(A,q_1) = \\operatorname{span}\\{q_1, A q_1, \\dots, A^{k-1} q_1\\}$ 构建一个标准正交基 $V_k = [q_1,\\dots,q_k] \\in \\mathbb{R}^{n \\times k}$ 和一个实上 Hessenberg 矩阵 $H_k \\in \\mathbb{R}^{k \\times k}$，使得 $A V_k \\approx V_k H_k + h_{k+1,k} q_{k+1} e_k^\\top$ 成立。其中 $e_k \\in \\mathbb{R}^k$ 是第 $k$ 个标准基向量，$h_{k+1,k} \\ge 0$ 是决定过程是否中断的次对角线元素。\n- Ritz 值是 $H_k$ 的特征值。在精确算术中，当 $k = n$ 时，它们与 $A$ 的特征值完全相同，因为 $H_n = V_n^\\top A V_n$ 与 $A$ 是正交相似的。\n\n你的程序必须：\n1. 完全按照上述规定实现混合精度 Arnoldi 迭代，使用带一步重正交的修正 Gram–Schmidt 过程，在完全双精度的环境下构建 $V_k$ 和 $H_k$。\n2. 对于下述每个测试用例，运行 $k$ 步（如果 $h_{j+1,j} = 0$ 则提前终止），以双精度计算 Ritz 值（即 $H_k$ 的特征值），并将其与以双精度计算的 $A$ 的真实特征值进行比较。使用最小化绝对差之和的最小一一分配方法，将 Ritz 值分配给真实特征值，并报告匹配对中的最大绝对差是否在预定容差范围内。\n3. 如果在某个测试用例的处理过程中出现任何非有限数（非数值或无穷大），则报告该测试用例失败。\n\n你必须使用一个从可复现分布中抽取的固定初始向量 $q_1$：其各分量从标准正态分布中独立采样，然后归一化为单位长度，随机种子设为一个固定的整数。\n\n通过你的实现和推理，解释该方案为何会根据矩阵的不同而成功或失败，且只能使用上述基本事实和合理的数值推理。你不得引入任何可以绕过上述事实所要求的推理过程的外部公式。\n\n矩阵族和测试套件：\n- 对于以下每个用例，请完全按照规定构建矩阵 $A$，选择 $n$ 和 $k$，并使用给定的容差 $\\tau$。每个用例的输出是一个布尔值，表示匹配的 Ritz 值与 $A$ 的真实特征值之间的最大绝对差异是否不大于 $\\tau$。\n- 五个测试用例如下：\n  1. 用例名称：SPD_tridiag_good。构建 $A \\in \\mathbb{R}^{n \\times n}$ 为一个对称三对角矩阵，其主对角线元素为 $1$，第一副对角线元素为 $-1/2$；即 $A = \\operatorname{tridiag}(-\\tfrac{1}{2}, 1, -\\tfrac{1}{2})$。使用 $n = 30$，$k = n$，容差 $\\tau = 5 \\cdot 10^{-3}$。\n  2. 用例名称：Diagonal_fp16_exact_good。构建 $A = \\operatorname{diag}(d_1,\\dots,d_n)$，其元素在集合 $\\{1, \\tfrac{1}{2}, \\tfrac{1}{4}, \\tfrac{1}{8}, \\tfrac{1}{16}\\}$ 中循环，并乘以交替的符号，即 $d_i = s_i \\cdot 2^{-r_i}$，其中 $s_i \\in \\{+1,-1\\}$ 随 $i$ 交替变化，$r_i$ 在 $\\{0,1,2,3,4\\}$ 中循环。使用 $n = 25$，$k = n$，容差 $\\tau = 5 \\cdot 10^{-3}$。\n  3. 用例名称：NonNormal_shift_fail。构建 $A = D + \\alpha N$，其中 $D = \\operatorname{diag}(d_1,\\dots,d_n)$ 且 $d_i$ 在 $[0.9, 1.1]$ 区间内线性分布，$N \\in \\mathbb{R}^{n \\times n}$ 在第一超对角线上为 1，其余位置为 0，且 $\\alpha = 20$。使用 $n = 30$，$k = n$，容差 $\\tau = 10^{-2}$。\n  4. 用例名称：Clustered_diag_fail。构建 $A = \\operatorname{diag}(1 + i \\cdot 10^{-4})$，其中 $i = 0,1,\\dots,n-1$。使用 $n = 30$，$k = n$，容差 $\\tau = 3 \\cdot 10^{-4}$。\n  5. 用例名称：Overflow_fp16_fail。构建 $A = s I + N$，其中 $s = 70000$，$I$ 是单位矩阵，$N$ 在第一超对角线上为 1，其余位置为 0。使用 $n = 20$，$k = n$，容差 $\\tau = 10^{-1}$。\n\n距离与匹配规范：\n- 设 $\\{\\theta_1,\\dots,\\theta_m\\}$ 是执行 $m \\le k$ 步后从 $H_m$ 得到的 Ritz 值（如果没有中断，则 $m=k$）。设 $\\{\\lambda_1,\\dots,\\lambda_n\\}$ 是在双精度下计算的 $A$ 的特征值。计算 $\\{\\theta_j\\}_{j=1}^m$ 与 $\\{\\lambda_i\\}_{i=1}^n$ 的一个大小为 $m$ 的子集之间的最小成本匹配，使得 $\\sum_{j=1}^m \\lvert \\theta_j - \\lambda_{\\pi(j)} \\rvert$ 最小化，其中 $\\pi$ 是一个单射。如果 $m = k$，所有涉及的数值都是有限的，并且 $\\max_{1 \\le j \\le m} \\lvert \\theta_j - \\lambda_{\\pi(j)} \\rvert \\le \\tau$，则报告成功。\n\n不涉及角度单位。不涉及物理单位。所有答案都是无单位的数字。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含五个测试用例的结果，格式为方括号括起来的、以逗号分隔的 Python 风格的布尔值列表（例如，“[True,False,True,False,True]”）。\n\n你提交的必须是一个完整、可运行的程序，该程序按规定构建矩阵，运行混合精度 Arnoldi 方案，计算 Ritz 值，执行匹配，评估容差测试，并以上述确切格式打印最终列表。不允许用户输入，除了指定的固定种子初始化 $q_1$ 外，不得使用其他随机性。",
            "solution": "我们从 Arnoldi 构造和 Ritz 值的定义开始。给定 $A \\in \\mathbb{R}^{n \\times n}$ 和一个单位向量 $q_1 \\in \\mathbb{R}^n$，Arnoldi 过程会构建标准正交向量 $q_1,\\dots,q_k$ 和标量 $h_{i,j}$，这些标量构成一个具有上 Hessenberg 结构的矩阵 $H_k \\in \\mathbb{R}^{k \\times k}$，使得\n$$\nA V_k = V_k H_k + h_{k+1,k} q_{k+1} e_k^\\top,\n$$\n其中 $V_k = [q_1,\\dots,q_k] \\in \\mathbb{R}^{n \\times k}$ 的列是标准正交的，$e_k \\in \\mathbb{R}^k$ 是第 $k$ 个基向量。$H_k$ 的特征值是 Ritz 值，它们是 $A$ 的特征值的近似。在精确算术中，当 $k = n$ 时，$V_n$ 是一个标准正交基，$H_n = V_n^\\top A V_n$ 与 $A$ 正交相似，因此它与 $A$ 具有完全相同的特征值。\n\n现在我们设计一个与这些原则一致的混合精度方案。矩阵向量乘积 $A q_j$ 是我们唯一以降低的精度执行的步骤，目的是模拟应用 $A$ 速度快但精度低的硬件，同时在高精度下保持正交化的稳定性。具体来说，给定双精度的 $q_j$，我们计算\n$$\nw = \\operatorname{float64}\\!\\left(\\operatorname{float16}(A) \\cdot \\operatorname{float16}(q_j)\\right),\n$$\n然后使用双精度的修正 Gram–Schmidt 过程将 $w$ 与当前基向量 $\\{q_i\\}_{i=1}^j$ 正交化：\n$$\nh_{i,j} = q_i^\\top w, \\quad w \\leftarrow w - h_{i,j} q_i \\quad \\text{for } i = 1,\\dots,j,\n$$\n并进行一次重正交以抑制舍入误差的累积：\n$$\n\\hat{h}_{i,j} = q_i^\\top w, \\quad h_{i,j} \\leftarrow h_{i,j} + \\hat{h}_{i,j}, \\quad w \\leftarrow w - \\hat{h}_{i,j} q_i \\quad \\text{for } i = 1,\\dots,j.\n$$\n然后我们在双精度下设置 $h_{j+1,j} = \\lVert w \\rVert_2$。如果 $h_{j+1,j} = 0$，我们宣布过程分解并停止；否则，$q_{j+1} = w / h_{j+1,j}$。得到的 $H_k$ 是上 Hessenberg 矩阵，其元素 $h_{i,j}$ 位于次对角线及其上方。\n\n混合精度的基本原理如下。使用半精度计算 $A q_j$ 会引入典型有限精度线性算子应用中的扰动。如果我们记 $\\widetilde{A} = \\operatorname{float16}(A)$ 和 $q_j^{(16)} = \\operatorname{float16}(q_j)$，那么实际进入正交化过程的向量是转换回双精度的 $w = \\widetilde{A} q_j^{(16)}$。相对于精确算术，这里有两个扰动源：(i) 用 $\\widetilde{A}$ 替换 $A$（一个线性算子扰动），以及 (ii) 用 $q_j^{(16)}$ 替换 $q_j$（引入了非线性，因为每次迭代中 $q_j$ 的舍入方式都不同）。然而，在双精度下使用带重正交的修正 Gram–Schmidt 过程可以使基向量近似保持标准正交，从而控制正交性的损失，否则这种损失会污染 $H_k$。\n\n为了评估准确性，我们将 Ritz 值（$H_k$ 的特征值）与在双精度下计算的 $A$ 的真实特征值进行比较。由于 Arnoldi 投影根据初始向量和子空间的不同会针对谱的特定部分，我们在所有情况下都强制 $k = n$，这样在精确算术中 $H_n$ 就与 $A$ 正交相似。在混合精度下，偏差源于受扰动的乘积，但对于良态且尺度适中的矩阵，$H_n$ 的特征值应与 $A$ 的特征值保持接近。\n\n我们现在论证预期的成功和失败模式：\n- 对于条目可在半精度下精确表示的对称、尺度适中的问题，会成功：如果 $A$ 的条目可以在半精度下精确表示（例如，主对角线为 $1$、副对角线为 $-1/2$ 的对称三对角矩阵），那么 $\\widetilde{A} = A$。唯一剩下的矩阵向量乘积误差来自于乘积前将 $q_j$ 舍入到半精度。这种每次迭代的扰动量级为半精度的机器 ε，约 $\\varepsilon_{16} \\approx 2^{-10} \\approx 10^{-3}$。当 $k=n$ 且使用双精度正交化时，对于良态矩阵，对 $H_n$ 谱的累积效应通常是温和的，因此 Ritz 值与真实特征值的匹配误差在 $\\varepsilon_{16}$ 的几倍之内，例如 $5 \\cdot 10^{-3}$。\n- 对于高度非正规矩阵，会失败：对于 $A = D + \\alpha N$，其中 $N$ 是严格上移位矩阵且 $\\alpha$ 很大，$A$ 的特征值为 $\\{d_i\\}$，但它是高度非正规的。其特征值对扰动极其敏感；即使当 $k=n$ 时，算子或迭代中的小的非正规扰动也可能导致 Ritz 值显著偏离真实特征值。这类 $A$ 的伪谱很大，混合精度矩阵向量乘积对 $A$ 的有效扰动量，在非正规基下衡量时，可能产生大于 $10^{-2}$ 的差异。\n- 对于紧密聚簇的特征值，会失败：如果 $A$ 是一个对角矩阵，其元素为 $1 + i \\cdot 10^{-4}$，那么特征值之间的间隔为 $10^{-4}$。半精度在 1 附近的单位舍入误差约为 $10^{-3}$，这超过了特征值的聚簇间隙。混合精度矩阵向量乘积无法可靠地分辨该尺度上的特征值差异，因此匹配的 Ritz 值将不会在真实特征值的 $3 \\cdot 10^{-4}$ 范围内。\n- 因半精度溢出而失败：半精度的最大有限数值约为 $6.5504 \\cdot 10^{4}$。如果我们用 $s = 70000$ 来缩放 $A$，那么 $\\operatorname{float16}(A)$ 的对角线上将包含无穷大。随后的矩阵向量乘积会产生非有限值，导致过程失败。\n\n算法设计：\n1. 实现混合精度 Arnoldi 迭代，其中矩阵向量乘积计算为 $w = \\operatorname{float64}\\!\\big(\\operatorname{float16}(A) \\cdot \\operatorname{float16}(q_j)\\big)$。\n2. 在双精度下使用带重正交的修正 Gram–Schmidt 过程来计算 $H_k$ 和 $V_k$。\n3. 在双精度下计算 $H_k$ 的特征值作为 Ritz 值。\n4. 在双精度下计算 $A$ 的真实特征值。\n5. 解决一个最小分配问题来匹配 Ritz 值和特征值，最小化绝对差之和，并计算匹配对上的最大绝对差。\n6. 如果没有中断（$m = k$），所有中间值都是有限的，并且最大差异不大于容差，则宣布成功。\n\n测试套件覆盖范围：\n- SPD_tridiag_good 测试了具有精确半精度表示能力和良好条件的“理想路径”。\n- Diagonal_fp16_exact_good 测试了当 $A$ 是对角矩阵且其值可在半精度下精确表示时的正确性，重点在于每次迭代中对 $q_j$ 进行舍入的影响。\n- NonNormal_shift_fail 测试了非正规敏感性。\n- Clustered_diag_fail 是一个针对半精度单位舍入误差尺度的边界情况测试。\n- Overflow_fp16_fail 测试了由于半精度动态范围限制导致的灾难性失败。\n\n最终程序会显式构建每个矩阵，使用固定种子的初始向量运行混合精度 Arnoldi 迭代，执行匹配和容差检查，并按要求格式打印一行包含布尔结果列表的输出。",
            "answer": "```python\nimport numpy as np\nfrom scipy import linalg\nfrom scipy.optimize import linear_sum_assignment\n\ndef arnoldi_mixed_precision(A, k, seed=42):\n    \"\"\"\n    Mixed-precision Arnoldi:\n    - Matvec w = float64( float16(A) @ float16(q_j) )\n    - Orthogonalization in float64 with MGS + reorthogonalization.\n    Returns V (n x m), H (m x m), m actual steps performed.\n    Stops early on breakdown or non-finite values.\n    \"\"\"\n    n = A.shape[0]\n    # Initial vector q1: random normal with fixed seed, normalized\n    rng = np.random.default_rng(seed)\n    q = rng.standard_normal(n)\n    q_norm = np.linalg.norm(q)\n    if not np.isfinite(q_norm) or q_norm == 0.0:\n        return None, None, 0\n    q = q / q_norm\n\n    # Prepare float16 version of A once (as per scheme)\n    A_fp16 = A.astype(np.float16)\n\n    V = np.zeros((n, k), dtype=np.float64)\n    H = np.zeros((k, k), dtype=np.float64)\n\n    V[:, 0] = q\n\n    for j in range(k):\n        # Compute w = A q_j using half precision for both A and q_j\n        try:\n            qj_fp16 = V[:, j].astype(np.float16)\n            w_fp16 = A_fp16 @ qj_fp16\n        except Exception:\n            # In case of incompatible sizes or others\n            return V[:, :j], H[:j, :j], j\n        w = w_fp16.astype(np.float64)\n\n        # Check finiteness\n        if not np.all(np.isfinite(w)):\n            return V[:, :j], H[:j, :j], j\n\n        # Modified Gram-Schmidt\n        for i in range(j + 1):\n            hij = np.dot(V[:, i], w)\n            H[i, j] += hij\n            w = w - hij * V[:, i]\n\n        # Reorthogonalization\n        for i in range(j + 1):\n            hij = np.dot(V[:, i], w)\n            H[i, j] += hij\n            w = w - hij * V[:, i]\n\n        h_next = np.linalg.norm(w)\n        if not np.isfinite(h_next):\n            return V[:, :j], H[:j, :j], j\n        if j + 1  k:\n            H[j + 1, j] = h_next\n\n        if h_next == 0.0 or j + 1 == k:\n            # Breakdown or finish\n            m = j + 1\n            return V[:, :m], H[:m, :m], m\n        V[:, j + 1] = w / h_next\n\n    # Normally not reached\n    m = k\n    return V[:, :m], H[:m, :m], m\n\n\ndef construct_matrix(case_name, n):\n    if case_name == \"SPD_tridiag_good\":\n        A = np.zeros((n, n), dtype=np.float64)\n        diag = 1.0\n        off = -0.5\n        np.fill_diagonal(A, diag)\n        idx = np.arange(n - 1)\n        A[idx, idx + 1] = off\n        A[idx + 1, idx] = off\n        return A\n    elif case_name == \"Diagonal_fp16_exact_good\":\n        vals = []\n        signs = [1.0, -1.0]\n        powers = [0, 1, 2, 3, 4]  # 1, 1/2, 1/4, 1/8, 1/16\n        for i in range(n):\n            s = signs[i % 2]\n            r = powers[i % len(powers)]\n            vals.append(s * (2.0 ** (-r)))\n        return np.diag(np.array(vals, dtype=np.float64))\n    elif case_name == \"NonNormal_shift_fail\":\n        d = np.linspace(0.9, 1.1, n)\n        D = np.diag(d)\n        N = np.zeros((n, n), dtype=np.float64)\n        idx = np.arange(n - 1)\n        N[idx, idx + 1] = 1.0\n        alpha = 20.0\n        return D + alpha * N\n    elif case_name == \"Clustered_diag_fail\":\n        d = 1.0 + (np.arange(n, dtype=np.float64)) * 1e-4\n        return np.diag(d)\n    elif case_name == \"Overflow_fp16_fail\":\n        A = np.zeros((n, n), dtype=np.float64)\n        s = 70000.0\n        np.fill_diagonal(A, s)\n        idx = np.arange(n - 1)\n        A[idx, idx + 1] = 1.0\n        return A\n    else:\n        raise ValueError(\"Unknown case name\")\n\n\ndef match_and_max_diff(ritz_vals, true_eigs):\n    \"\"\"\n    Match each Ritz value to a distinct true eigenvalue minimizing total absolute difference.\n    Returns max absolute difference among matched pairs.\n    \"\"\"\n    r = np.array(ritz_vals, dtype=np.complex128)\n    lam = np.array(true_eigs, dtype=np.complex128)\n\n    # Cost matrix: absolute differences\n    cost = np.abs(r[:, None] - lam[None, :])\n    # Solve assignment: assign each Ritz to a unique eigenvalue\n    row_ind, col_ind = linear_sum_assignment(cost)\n    diffs = cost[row_ind, col_ind]\n    max_diff = np.max(diffs) if diffs.size  0 else np.inf\n    return float(np.real(max_diff))\n\n\ndef evaluate_case(case_name, n, k, tol, seed=12345):\n    A = construct_matrix(case_name, n)\n    # Run mixed-precision Arnoldi\n    V, H, m = arnoldi_mixed_precision(A, k, seed=seed)\n\n    # Conditions for failure\n    if V is None or H is None:\n        return False\n    if m != k:\n        return False\n    if not np.all(np.isfinite(H)) or not np.all(np.isfinite(V)):\n        return False\n\n    # Compute Ritz values: eigenvalues of H\n    try:\n        ritz_vals = linalg.eigvals(H)\n    except Exception:\n        return False\n    if not np.all(np.isfinite(ritz_vals)):\n        return False\n\n    # True eigenvalues of A in double precision\n    try:\n        true_eigs = linalg.eigvals(A)\n    except Exception:\n        return False\n    if not np.all(np.isfinite(true_eigs)):\n        return False\n\n    # Match and compute maximum absolute difference\n    max_diff = match_and_max_diff(ritz_vals, true_eigs)\n    if not np.isfinite(max_diff):\n        return False\n\n    return bool(max_diff = tol)\n\n\ndef solve():\n    # Define the test cases exactly as specified\n    test_cases = [\n        (\"SPD_tridiag_good\", 30, 30, 5e-3),\n        (\"Diagonal_fp16_exact_good\", 25, 25, 5e-3),\n        (\"NonNormal_shift_fail\", 30, 30, 1e-2),\n        (\"Clustered_diag_fail\", 30, 30, 3e-4),\n        (\"Overflow_fp16_fail\", 20, 20, 1e-1),\n    ]\n    results = []\n    for name, n, k, tol in test_cases:\n        res = evaluate_case(name, n, k, tol, seed=2024)\n        results.append(res)\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "本次实践将你的技能从关注“精度”提升到关注“稳健性”。你将学习如何依据 IEEE 754 浮点算术标准，设计并实现一个能够“防御”算术异常的 Arnoldi 迭代器。通过主动检测和处理非数值（NaN）的传播以及捕获除零等异常，你将学会如何构建在面对数据损坏或数值退化时仍能继续执行并给出诊断信息的、真正意义上的产品级数值代码。",
            "id": "3589150",
            "problem": "考虑在电气与电子工程师协会浮点算术标准 (IEEE 754) 框架内实现 Arnoldi 迭代。目标是使用矩阵-向量递推为 Krylov 子空间构建一个标准正交基，同时研究并控制静默非数字 (NaN) 值与信号 NaN 值在 IEEE 754 语义下的传播方式。Arnoldi 过程通过对起始向量重复应用矩阵，然后进行 Gram–Schmidt 正交化来构造向量。设 $A \\in \\mathbb{R}^{n \\times n}$ 是一个实矩阵，$v_1 \\in \\mathbb{R}^n$ 是一个范数 $\\|v_1\\|_2 = 1$ 的非零起始向量，并设 $m \\in \\mathbb{N}$ 是所需的 Arnoldi 步数。定义 Krylov 子空间 $\\mathcal{K}_m(A,v_1) = \\operatorname{span}\\{v_1, Av_1, A^2 v_1, \\dots, A^{m-1} v_1\\}$。Arnoldi 迭代通过计算 $y = A v_k$，使用内积将 $y$ 与先前构造的标准正交向量 $\\{q_j\\}_{j=1}^k$ 进行正交化，然后归一化以获得 $v_{k+1}$。Hessenberg 系数 $h_{j,k}$ 满足对于 $j \\in \\{1,\\dots,k\\}$ 有 $y \\leftarrow y - h_{j,k} q_j$，然后 $h_{k+1,k} = \\|y\\|_2$ 且 $v_{k+1} = y / h_{k+1,k}$。该迭代方案从根本上基于线性代数运算：矩阵-向量乘法、内积和向量范数。\n\n在 IEEE 754 算术中，静默 NaN (qNaN) 被设计为在算术运算中传播而不引发异常，而信号 NaN (sNaN) 被设计为在运算中使用时引发无效操作异常。该标准为无效操作、除以零、上溢和下溢暴露了异常标志。在实践中，许多编程环境在加载时会悄悄地将信号 NaN 转换为静默 NaN，并主要通过运行时控件来暴露对无效操作和除以零的异常处理。这些事实是众所周知的，并构成了在迭代线性代数程序中检测和控制数值危险事件的基础。\n\n设计并实现一个稳健的 Arnoldi 迭代，该迭代遵循以下原则：\n- 根据 IEEE 754 无效操作和除以零的异常标志，检测无效算术事件的首次发生，并在算术运算前后检测操作数中是否存在任何非有限值（静默 NaN 或无穷大）。\n- 隔离第一个出错的索引，以防止迭代的全局性崩溃。隔离可以通过将受影响的分量置零，并在迭代中使用的暂存矩阵中清理相应的行来执行，以限制从首次出现处开始的进一步传播。\n- 通过应用防御性补救策略，将 Arnoldi 过程继续执行指定的步数 $m$：如果归一化导致除以零（例如，当 $y=0$ 时），捕获 IEEE 异常，记录该事件，并注入一个与当前基正交化的替换方向以继续进行。\n\n您必须编写一个完整、可运行的程序，该程序使用编程环境提供的 IEEE 754 异常控制来检测无效操作和除以零，同时还明确检查非有限值以识别静默 NaN 的传播。程序必须实现带有经典 Gram–Schmidt 正交化和上述防御策略的 Arnoldi 迭代。\n\n使用以下测试套件，每个案例指定 $(A, v_0, m)$ 和任何扰动：\n\n- 案例 1 (正常路径)：设 $n = 6$。构造 $D = \\operatorname{diag}(1,2,3,4,5,6)$，使用固定的伪随机种子 $42$ 生成一个随机矩阵 $G \\in \\mathbb{R}^{n \\times n}$，计算 $\\operatorname{QR}$ 分解 $G = QR$（其中 $Q \\in \\mathbb{R}^{n \\times n}$ 是正交的），并设 $A = Q^\\top D Q$。设 $v_0 = \\frac{1}{\\sqrt{n}} \\mathbf{1}$，其中 $\\mathbf{1} \\in \\mathbb{R}^n$ 是全为一的向量。设 $m = 4$。\n\n- 案例 2 (静默 NaN 传播)：从与案例 1 相同的 $A$ 开始，将以零为基准的坐标 $(2,4)$ 索引的矩阵元素设置为 NaN (静默 NaN)。即，设 $A[2,4] = \\mathrm{NaN}$ 并保持所有其他条目不变。使用相同的 $v_0$ 和 $m = 4$。\n\n- 案例 3 (除以零补救)：设 $n = 6$ 且 $A = \\operatorname{diag}(0,1,2,3,4,5)$。设 $v_0 = e_1$，其中 $e_1$ 是 $\\mathbb{R}^6$ 中的第一个标准基向量。设 $m = 3$。\n\n对于每个测试用例，您的程序必须输出一个三元组 $[b,i,s]$，其中：\n- $b$ 是一个布尔值，如果您的防御策略检测到了第一个无效事件（操作数中的非有限值检测或无效/除以零的 IEEE 异常），则为 $true$，否则为 $false$。\n- $i$ 是一个整数，表示在向量中检测到的第一个非有限操作数的从零开始的索引（如果适用）；如果第一个事件是没有特定分量索引的 IEEE 异常，则输出 $-1$。\n- $s$ 是一个整数，等于例程成功完成的 Arnoldi 步数（如果您的防御措施成功地使过程继续，则应等于 $m$）。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，$[ [b_1,i_1,s_1], [b_2,i_2,s_2], [b_3,i_3,s_3] ]$）。不涉及物理单位。不涉及角度。所有布尔值、整数和列表均按所示的纯文本形式表示。\n\n设计必须是通用的和纯数学的：使用所描述的实数矩阵和向量、使用欧几里得范数的经典 Gram–Schmidt 正交化以及 IEEE 754 异常控制来实现 Arnoldi 迭代，以检测和隔离第一次无效事件的发生而不中断过程。不要使用任何外部文件或输入；所有内容都必须在程序内部使用指定的参数进行计算。",
            "solution": "问题陈述经评估为**有效**。它在数值线性代数和计算机算术领域具有科学依据，描述了著名的 Arnoldi 迭代和标准的 IEEE 754 浮点语义。该问题是适定的，为每个测试案例提供了一组特定的输入和一个明确的目标。虽然存在一些微小的模糊之处，例如同时使用 $v_0$ 和 $v_1$ 作为起始向量，但这些问题可以根据上下文和该领域的标准惯例轻松解决。所要求的防御策略，包括分量隔离和通过向量注入进行补救，都得到了明确描述，因此是可形式化的，即使它们是为本练习目的而设定的特定、人为的要求。该问题是一项非凡的、可验证的计算任务。\n\n该解决方案需要使用经典 Gram-Schmidt (CGS) 正交化方法实现一个稳健的 Arnoldi 迭代。任务的核心是集成用于检测和处理 IEEE 754 标准规定的特定数值异常和非有限值的机制。算法执行指定的步数 $m$，并报告首次检测到的数值异常。\n\n设 $A \\in \\mathbb{R}^{n \\times n}$ 为输入矩阵，$v_{start} \\in \\mathbb{R}^n$ 为起始向量，$m \\in \\mathbb{N}$ 为迭代次数。标准正交基向量使用编程中常见的 0-基索引表示为 $\\{q_k\\}_{k=0}^{m-1}$。\n\n算法结构如下：\n\n1.  **初始化**：\n    将起始向量 $v_{start}$ 归一化以产生第一个基向量 $q_0 = v_{start} / \\|v_{start}\\|_2$。用 $q_0$ 初始化一个基向量列表。初始化状态变量以跟踪是否检测到事件 ($b_{detected}$)、第一个出错分量的索引 ($i_{offending}$) 以及完成的步数 ($s_{steps}$)。\n\n2.  **Arnoldi 迭代循环**：\n    主循环迭代 $m$ 次， $k$ 从 $0$ 到 $m-1$，以生成后续的基向量 $q_1, \\dots, q_m$。每一步都涉及三个主要阶段：矩阵-向量乘法、经典 Gram-Schmidt 正交化和归一化。\n\n3.  **防御与监控策略**：\n    采用双管齐下的策略来满足问题对稳健性的要求。\n\n    a. **非有限值的主动检测**：在关键算术运算前后，使用 `numpy.isfinite()` 检查操作数和结果中是否存在非有限值（静默 NaN 或无穷大）。这对于检测静默 NaN 的传播至关重要，因为默认情况下它们不会引发 IEEE 754 异常。如果在向量的索引 $j$ 处发现非有限值且之前未记录任何事件，则记录该事件（$b_{detected} \\leftarrow \\text{true}$, $i_{offending} \\leftarrow j$）。根据问题的“隔离”指令，受影响的向量分量被设置为 $0.0$，矩阵 $A$ 的相应行 $j$ 也被置零，以防止从该源头进一步传播。此策略是处理案例 2 的核心，该案例中一个 `NaN` 被预先注入到矩阵 $A$ 中。\n\n    b. **IEEE 754 异常的被动处理**：易于引发异常的核心算术运算，特别是归一化步骤，被封装在一个 `try...except` 块中，该块由一个 `numpy.errstate` 上下文管理器控制，该管理器配置为对 `invalid` 操作（例如 $0/0$, $\\infty - \\infty$）和 `divide`-by-zero 错误引发 `FloatingPointError`。这直接满足了“捕获 IEEE 异常”的要求。\n    \n    如果要归一化的向量（设为 $w$）的范数为零，则除法 $w / \\|w\\|_2$ 将触发 `invalid` 操作异常 ($0/0$)。这是案例 3 中预期的失败模式。捕获此异常后，记录该事件（$b_{detected} \\leftarrow \\text{true}$，$i_{offending} \\leftarrow -1$，因为这是一个标量操作）。然后调用“补救策略”：生成一个新的随机向量（使用固定的、依赖于步数的种子以保证可复现性），与所有先前计算出的基向量 $\\{q_0, \\dots, q_k\\}$ 正交化，并归一化以作为下一个基向量 $q_{k+1}$。这使得迭代能够在发生崩溃的情况下仍能完成全部 $m$ 步。\n\n4.  **经典 Gram-Schmidt (CGS) 正交化**：\n    在第 $k$ 步，计算向量 $y = A q_k$。为了获得一个与现有基 $\\{q_0, \\dots, q_k\\}$ 正交的向量 $w$，应用 CGS。将一个工作副本 $w$ 初始化为 $y$。然后，对于从 $0$ 到 $k$ 的每个 $j$，减去沿 $q_j$ 的分量：$w \\leftarrow w - h_{j,k} q_j$，其中系数 $h_{j,k}$ 是通过*原始*向量 $y$ 计算得出的，即 $h_{j,k} = q_j^\\top y$。这种坚持对所有投影都使用原始向量的做法是 CGS 与修正 Gram-Schmidt 的区别所在。\n\n5.  **最终输出**：\n    完成 $m$ 步后，函数返回一个包含最终状态的列表：$[b_{detected}, i_{offending}, s_{steps}]$。对问题陈述中提供的每个测试案例重复此过程。最终的结果列表将按照要求精确格式化。\n\n该设计直接实现了指定的 Arnoldi 过程，同时集成了所需的能感知 IEEE 754 的监控和处理逻辑。使用 `isfinite` 进行的主动检查满足了检测静默 NaN 传播的要求，而被动的 `try/except` 结构满足了捕获显式异常并应用补救策略的要求。",
            "answer": "```python\nimport numpy as np\n\ndef robust_arnoldi(A, v0, m):\n    \"\"\"\n    Implements the Arnoldi iteration with robust error handling for IEEE 754 exceptions.\n\n    Args:\n        A (np.ndarray): The matrix for the iteration. A copy will be used as it may be modified.\n        v0 (np.ndarray): The starting vector.\n        m (int): The number of Arnoldi steps to perform.\n\n    Returns:\n        list: A list [b, i, s] where b is a boolean for event detection,\n              i is the index of the first offense (-1 if not applicable),\n              and s is the number of completed steps.\n    \"\"\"\n    n = A.shape[0]\n    A_work = A.copy()  # Use a working copy of the matrix\n    \n    b_detected = False\n    i_offending = -1\n    s_steps = 0\n    \n    q_vectors = []\n    \n    # Initialize with the starting vector\n    norm_v0 = np.linalg.norm(v0)\n    if norm_v0 == 0:\n        # Starting with a zero vector is an immediate failure.\n        # Although not specified in test cases, this is a sensible check.\n        return [True, -1, 0]\n        \n    q0 = v0 / norm_v0\n    q_vectors.append(q0)\n    \n    # Main Arnoldi loop\n    for k in range(m):\n        q_k = q_vectors[k]\n        \n        # 1. Matrix-vector product: y = A @ q_k\n        y = A_work @ q_k\n        \n        # Proactive check for non-finite values (e.g., from a NaN in the matrix)\n        if not b_detected and not np.all(np.isfinite(y)):\n            b_detected = True\n            # Find the first non-finite index\n            i_offending = int(np.where(~np.isfinite(y))[0][0])\n            # Apply isolation strategy as per the problem description\n            y[i_offending] = 0.0\n            A_work[i_offending, :] = 0.0\n        \n        # 2. Classical Gram-Schmidt (CGS)\n        w = y.copy()  # Vector that will be orthogonalized\n        for j in range(k + 1):\n            q_j = q_vectors[j]\n            \n            # Coefficient computation using the original vector y\n            h_jk = np.dot(q_j, y)\n            \n            # Check if the inner product produced a NaN\n            if not b_detected and not np.isfinite(h_jk):\n                b_detected = True\n                i_offending = -1  # Scalar operation\n                h_jk = 0.0  # Sanitize to prevent further propagation\n            \n            if not np.isfinite(h_jk):\n                h_jk = 0.0 # Sanitize anyway\n\n            # Subtract projection from the working vector w\n            w = w - h_jk * q_j\n\n            # Check for non-finites after subtraction\n            if not b_detected and not np.all(np.isfinite(w)):\n                b_detected = True\n                i_offending = int(np.where(~np.isfinite(w))[0][0])\n                # No specific salvage for this, but the event is recorded\n        \n        # 3. Normalization and Salvage\n        norm_w = np.linalg.norm(w)\n        next_q = np.zeros(n)\n        \n        try:\n            # Configure to raise exceptions for division by zero or invalid ops\n            with np.errstate(divide='raise', invalid='raise'):\n                # This division is the critical operation. If norm_w is 0,\n                # np.linalg.norm is safe, but this raw division will fault.\n                # 0/0 - invalid op; x/0 - div by zero.\n                if norm_w == 0:\n                    # Manually trigger the logic that would be caught by the exception\n                    # This makes the behavior more predictable across platforms\n                    raise FloatingPointError\n                next_q = w / norm_w\n                \n        except FloatingPointError:\n            # Catch the exception, as required. This happens on breakdown.\n            if not b_detected:\n                b_detected = True\n                i_offending = -1  # Event is a scalar operation\n                \n            # Invoke salvage strategy\n            rand_gen = np.random.default_rng(seed=k)  # Reproducible seed per step\n            while True:\n                new_vec = rand_gen.standard_normal(size=n)\n                # Orthogonalize against all existing basis vectors\n                for j in range(k + 1):\n                    new_vec -= np.dot(q_vectors[j], new_vec) * q_vectors[j]\n                \n                norm_new_vec = np.linalg.norm(new_vec)\n                # Ensure the new random vector is non-zero after projection\n                if norm_new_vec  1e-12:\n                    next_q = new_vec / norm_new_vec\n                    break\n        \n        q_vectors.append(next_q)\n        s_steps += 1\n            \n    return [b_detected, i_offending, s_steps]\n\n\ndef solve():\n    \"\"\"\n    Sets up and runs the test cases for the robust Arnoldi implementation.\n    \"\"\"\n    # Case 1: Happy path\n    n1 = 6\n    D1 = np.diag([1.0, 2.0, 3.0, 4.0, 5.0, 6.0])\n    rng_G = np.random.default_rng(42)\n    G1 = rng_G.standard_normal(size=(n1, n1))\n    Q1, _ = np.linalg.qr(G1)\n    A1 = Q1.T @ D1 @ Q1\n    v0_1 = np.ones(n1) / np.sqrt(n1)\n    m1 = 4\n\n    # Case 2: Quiet NaN propagation\n    A2 = A1.copy()\n    A2[2, 4] = np.nan\n    v0_2 = v0_1.copy()\n    m2 = 4\n\n    # Case 3: Division by zero salvage\n    n3 = 6\n    A3 = np.diag([0.0, 1.0, 2.0, 3.0, 4.0, 5.0])\n    v0_3 = np.zeros(n3)\n    v0_3[0] = 1.0\n    m3 = 3\n    \n    test_cases = [\n        (A1, v0_1, m1),\n        (A2, v0_2, m2),\n        (A3, v0_3, m3),\n    ]\n\n    results = []\n    for A, v0, m in test_cases:\n        result = robust_arnoldi(A, v0, m)\n        results.append(result)\n        \n    # Format the output string exactly as specified.\n    # Python's default list-to-string conversion adds spaces. Let's build it manually.\n    result_strings = []\n    for res in results:\n        b_str = 'true' if res[0] else 'false'\n        result_strings.append(f\"[{b_str},{res[1]},{res[2]}]\")\n    \n    final_output_str = f\"[{','.join(result_strings)}]\"\n    \n    print(final_output_str)\n\nsolve()\n```"
        }
    ]
}