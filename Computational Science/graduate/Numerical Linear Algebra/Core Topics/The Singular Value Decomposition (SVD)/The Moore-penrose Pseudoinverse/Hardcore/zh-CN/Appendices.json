{
    "hands_on_practices": [
        {
            "introduction": "摩尔-彭若斯伪逆的计算与奇异值分解 (SVD) 紧密相连。本练习  将通过一个具体的数值例子，指导您从给定的 SVD 因子 $U$、$V$ 和 $\\Sigma$ 出发，一步步手动构建伪逆矩阵 $A^{+}$。这是掌握伪逆核心定义 $A^{+} = V \\Sigma^{+} U^{\\top}$ 并理解其构造方式的基础实践。",
            "id": "3592295",
            "problem": "设 $A \\in \\mathbb{R}^{3 \\times 2}$ 的奇异值分解 (SVD) 为 $A = U \\Sigma V^{\\top}$，其中\n$$\nU \\;=\\;\n\\begin{bmatrix}\n\\frac{1}{\\sqrt{2}}  \\frac{1}{\\sqrt{2}}  0 \\\\\n0  0  1 \\\\\n-\\frac{1}{\\sqrt{2}}  \\frac{1}{\\sqrt{2}}  0\n\\end{bmatrix},\n\\qquad\n\\Sigma \\;=\\;\n\\begin{bmatrix}\n6  0 \\\\\n0  2 \\\\\n0  0\n\\end{bmatrix},\n\\qquad\nV \\;=\\;\n\\begin{bmatrix}\n\\frac{3}{5}  \\frac{4}{5} \\\\\n-\\frac{4}{5}  \\frac{3}{5}\n\\end{bmatrix}.\n$$\n仅使用 Moore–Penrose 伪逆的定义性质和奇异值分解 (SVD) 的定义，从所给的因子中显式地推导出 Moore–Penrose 伪逆 $A^{+}$。然后，以单一闭式表达式的形式给出 $A^{+}$ 的 $(2,3)$ 元素的精确值。不要使用任何不是这些定义直接推论的结果。无需四舍五入。",
            "solution": "该问题是有效的，因为它是自洽的，在数值线性代数中有科学依据，并且在数学上是适定的。存在唯一解，并且可以从所提供的信息中推导出来。\n\n任务是在给定矩阵 $A$ 的奇异值分解 (SVD) $A = U \\Sigma V^{\\top}$ 的情况下，求其 Moore-Penrose 伪逆 $A^{+}$ 的 $(2,3)$ 元素。推导过程必须严格遵守伪逆的定义性质。\n\n矩阵 $A$ 的 Moore-Penrose 伪逆（记作 $A^{+}$）是满足以下四个 Penrose 条件的唯一矩阵：\n1.  $A A^{+} A = A$\n2.  $A^{+} A A^{+} = A^{+}$\n3.  $(A A^{+})^{\\top} = A A^{+}$\n4.  $(A^{+} A)^{\\top} = A^{+} A$\n\n给定 $A \\in \\mathbb{R}^{3 \\times 2}$ 的 SVD 分解各部分：\n$$\nU \\;=\\;\n\\begin{bmatrix}\n\\frac{1}{\\sqrt{2}}  \\frac{1}{\\sqrt{2}}  0 \\\\\n0  0  1 \\\\\n-\\frac{1}{\\sqrt{2}}  \\frac{1}{\\sqrt{2}}  0\n\\end{bmatrix},\n\\qquad\n\\Sigma \\;=\\;\n\\begin{bmatrix}\n6  0 \\\\\n0  2 \\\\\n0  0\n\\end{bmatrix},\n\\qquad\nV \\;=\\;\n\\begin{bmatrix}\n\\frac{3}{5}  \\frac{4}{5} \\\\\n-\\frac{4}{5}  \\frac{3}{5}\n\\end{bmatrix}.\n$$\n此处，$U \\in \\mathbb{R}^{3 \\times 3}$ 和 $V \\in \\mathbb{R}^{2 \\times 2}$ 是正交矩阵（$U^{\\top}U=I$ 且 $V^{\\top}V=I$），而 $\\Sigma$ 是一个矩形对角矩阵。\n\n我们提出伪逆的候选形式为 $A^{+} = V \\Sigma^{+} U^{\\top}$。矩阵 $\\Sigma^{+} \\in \\mathbb{R}^{2 \\times 3}$ 是 $\\Sigma$ 的伪逆。它的构造方法是取每个非零奇异值的倒数，然后转置所得矩阵。$\\Sigma$ 中的非零奇异值为 $\\sigma_1 = 6$ 和 $\\sigma_2 = 2$。\n$$\n\\Sigma^{+} \\;=\\;\n\\begin{bmatrix}\n\\frac{1}{6}  0  0 \\\\\n0  \\frac{1}{2}  0\n\\end{bmatrix}.\n$$\n为了严格证明使用 $A^{+} = V \\Sigma^{+} U^{\\top}$ 的合理性，我们必须证明它满足四个 Penrose 条件。\n\n1.  $A A^{+} A = (U \\Sigma V^{\\top})(V \\Sigma^{+} U^{\\top})(U \\Sigma V^{\\top}) = U \\Sigma (V^{\\top}V) \\Sigma^{+} (U^{\\top}U) \\Sigma V^{\\top} = U (\\Sigma \\Sigma^{+} \\Sigma) V^{\\top}$。\n    乘积 $\\Sigma\\Sigma^{+}\\Sigma$ 为：\n    $$\n    \\Sigma \\Sigma^{+} \\Sigma = \\left( \\begin{bmatrix} 6  0 \\\\ 0  2 \\\\ 0  0 \\end{bmatrix} \\begin{bmatrix} \\frac{1}{6}  0  0 \\\\ 0  \\frac{1}{2}  0 \\end{bmatrix} \\right) \\Sigma = \\begin{bmatrix} 1  0  0 \\\\ 0  1  0 \\\\ 0  0  0 \\end{bmatrix} \\begin{bmatrix} 6  0 \\\\ 0  2 \\\\ 0  0 \\end{bmatrix} = \\begin{bmatrix} 6  0 \\\\ 0  2 \\\\ 0  0 \\end{bmatrix} = \\Sigma.\n    $$\n    因此，$A A^{+} A = U \\Sigma V^{\\top} = A$。第一个条件满足。\n\n2.  $A^{+} A A^{+} = (V \\Sigma^{+} U^{\\top})(U \\Sigma V^{\\top})(V \\Sigma^{+} U^{\\top}) = V \\Sigma^{+} (U^{\\top}U) \\Sigma (V^{\\top}V) \\Sigma^{+} U^{\\top} = V (\\Sigma^{+} \\Sigma \\Sigma^{+}) U^{\\top}$。\n    乘积 $\\Sigma^{+}\\Sigma\\Sigma^{+}$ 为：\n    $$\n    \\Sigma^{+} \\Sigma \\Sigma^{+} = \\left( \\begin{bmatrix} \\frac{1}{6}  0  0 \\\\ 0  \\frac{1}{2}  0 \\end{bmatrix} \\begin{bmatrix} 6  0 \\\\ 0  2 \\\\ 0  0 \\end{bmatrix} \\right) \\Sigma^{+} = \\begin{bmatrix} 1  0 \\\\ 0  1 \\end{bmatrix} \\begin{bmatrix} \\frac{1}{6}  0  0 \\\\ 0  \\frac{1}{2}  0 \\end{bmatrix} = \\Sigma^{+}.\n    $$\n    因此，$A^{+} A A^{+} = V \\Sigma^{+} U^{\\top} = A^{+}$。第二个条件满足。\n\n3.  $(A A^{+})^{\\top} = A A^{+}$。乘积为 $A A^{+} = U \\Sigma V^{\\top}V \\Sigma^{+} U^{\\top} = U (\\Sigma \\Sigma^{+}) U^{\\top}$。矩阵 $\\Sigma \\Sigma^{+} = \\begin{bmatrix} 1  0  0 \\\\ 0  1  0 \\\\ 0  0  0 \\end{bmatrix}$ 是对角矩阵，因此是对称的，$(\\Sigma \\Sigma^{+})^{\\top} = \\Sigma \\Sigma^{+}$。所以，$(A A^{+})^{\\top} = (U (\\Sigma \\Sigma^{+}) U^{\\top})^{\\top} = U (\\Sigma \\Sigma^{+})^{\\top} U^{\\top} = U (\\Sigma \\Sigma^{+}) U^{\\top} = A A^{+}$。第三个条件满足。\n\n4.  $(A^{+} A)^{\\top} = A^{+} A$。乘积为 $A^{+} A = V \\Sigma^{+} U^{\\top}U \\Sigma V^{\\top} = V (\\Sigma^{+} \\Sigma) V^{\\top}$。矩阵 $\\Sigma^{+} \\Sigma = \\begin{bmatrix} 1  0 \\\\ 0  1 \\end{bmatrix}$ 是单位矩阵，它是对称的。所以，$(A^{+} A)^{\\top} = (V (\\Sigma^{+} \\Sigma) V^{\\top})^{\\top} = V (\\Sigma^{+} \\Sigma)^{\\top} V^{\\top} = V (\\Sigma^{+} \\Sigma) V^{\\top} = A^{+} A$。第四个条件满足。\n\n推导证实了 $A^{+} = V \\Sigma^{+} U^{\\top}$ 确实是 Moore-Penrose 伪逆。我们现在计算其 $(2,3)$ 元素，记为 $A^{+}_{23}$。\n$A^{+} = V \\Sigma^{+} U^{\\top}$。元素 $A^{+}_{23}$ 是乘积 $V\\Sigma^{+}$ 的第二行与 $U^{\\top}$ 的第三列的点积。\n\n首先，我们求 $V\\Sigma^{+}$ 的第二行：\n$$\n\\left( V\\Sigma^{+} \\right)_{2,:} = \\begin{pmatrix} -\\frac{4}{5}  \\frac{3}{5} \\end{pmatrix} \\begin{pmatrix} \\frac{1}{6}  0  0 \\\\ 0  \\frac{1}{2}  0 \\end{pmatrix} = \\begin{pmatrix} \\left(-\\frac{4}{5}\\right)\\left(\\frac{1}{6}\\right)  \\left(-\\frac{4}{5}\\right)(0) + \\left(\\frac{3}{5}\\right)\\left(\\frac{1}{2}\\right)  0 \\end{pmatrix}\n$$\n$$\n= \\begin{pmatrix} -\\frac{4}{30}  \\frac{3}{10}  0 \\end{pmatrix} = \\begin{pmatrix} -\\frac{2}{15}  \\frac{3}{10}  0 \\end{pmatrix}.\n$$\n接下来，我们确定 $U^{\\top}$ 的第三列。转置 $U$ 得到：\n$$\nU^{\\top} \\;=\\;\n\\begin{bmatrix}\n\\frac{1}{\\sqrt{2}}  0  -\\frac{1}{\\sqrt{2}} \\\\\n\\frac{1}{\\sqrt{2}}  0  \\frac{1}{\\sqrt{2}} \\\\\n0  1  0\n\\end{bmatrix}.\n$$\n$U^{\\top}$ 的第三列是 $\\begin{pmatrix} -\\frac{1}{\\sqrt{2}}  \\frac{1}{\\sqrt{2}}  0 \\end{pmatrix}^{\\top}$。\n\n最后，我们计算点积以求得 $A^{+}_{23}$：\n$$\nA^{+}_{23} = \\left(-\\frac{2}{15}\\right) \\left(-\\frac{1}{\\sqrt{2}}\\right) + \\left(\\frac{3}{10}\\right) \\left(\\frac{1}{\\sqrt{2}}\\right) + (0)(0)\n$$\n$$\nA^{+}_{23} = \\frac{2}{15\\sqrt{2}} + \\frac{3}{10\\sqrt{2}}.\n$$\n为了合并这些项，我们使用公分母 $30\\sqrt{2}$：\n$$\nA^{+}_{23} = \\frac{4}{30\\sqrt{2}} + \\frac{9}{30\\sqrt{2}} = \\frac{13}{30\\sqrt{2}}.\n$$\n分母有理化后得到最终的闭式表达式：\n$$\nA^{+}_{23} = \\frac{13\\sqrt{2}}{30 \\times 2} = \\frac{13\\sqrt{2}}{60}.\n$$",
            "answer": "$$\\boxed{\\frac{13\\sqrt{2}}{60}}$$"
        },
        {
            "introduction": "伪逆不仅仅是求解线性方程的工具，它还定义了两个重要的几何对象：投影算子 $AA^{+}$ 和 $A^{+}A$。本练习  将通过一个精心设计的反例，揭示为何这两个算子通常不相等，并引导您分析它们的几何意义，即分别作为到列空间和行空间上的正交投影。通过这个练习，您将更深刻地理解伪逆在几何投影中的作用。",
            "id": "3592297",
            "problem": "设 $A \\in \\mathbb{R}^{2 \\times 2}$ 是奇异矩阵\n$$\nA \\;=\\; \\begin{pmatrix} 1  1 \\\\ 0  0 \\end{pmatrix}.\n$$\n仅利用任意实矩阵的奇异值分解（SVD）的存在性以及通过 SVD 定义的 Moore–Penrose（MP）伪逆，从第一性原理出发，完成以下步骤：\n\n1. 计算 SVD $A = U \\Sigma V^{\\top}$，确定非零奇异值和相应的奇异向量。利用此结果构造 MP 伪逆 $A^{+} = V \\Sigma^{+} U^{\\top}$。\n\n2. 显式计算两个矩阵 $A A^{+}$ 和 $A^{+} A$。直接（通过计算）验证 $A A^{+} \\neq A^{+} A$。\n\n3. 通过直接的线性代数分析（求解列空间和相关齐次方程组的解），确定 $A A^{+}$ 和 $A^{+} A$ 的值域和零空间。将每个空间表示为 $\\mathbb{R}^{2}$ 中向量的张成空间。\n\n4. 设 $\\|\\cdot\\|_{F}$ 表示 Frobenius 范数，对于任意实矩阵 $M$，其定义为 $\\|M\\|_{F}^{2} = \\sum_{i,j} M_{ij}^{2}$。计算标量 $\\|A A^{+} - A^{+} A\\|_{F}^{2}$。\n\n你的最终答案必须是步骤 4 中得到的单个实数。无需四舍五入。",
            "solution": "我们从奇异值分解（SVD）的存在性及其在定义 Moore–Penrose（MP）伪逆中的应用出发。对于任意实矩阵 $A$，存在正交矩阵 $U$ 和 $V$ 以及一个对角线元素为非负数（奇异值）的对角矩阵 $\\Sigma$，使得 $A = U \\Sigma V^{\\top}$。如果 $\\Sigma$ 的对角线元素为 $\\sigma_{1} \\ge \\sigma_{2} \\ge \\cdots \\ge 0$，则 MP 伪逆定义为 $A^{+} = V \\Sigma^{+} U^{\\top}$，其中 $\\Sigma^{+}$ 将每个非零的 $\\sigma_{i}$ 替换为 $\\sigma_{i}^{-1}$，并保持零元素不变。\n\n步骤 1：计算 $A$ 的 SVD，然后计算 $A^{+}$。\n\n我们有\n$$\nA = \\begin{pmatrix} 1  1 \\\\ 0  0 \\end{pmatrix}.\n$$\n计算 $A A^{\\top}$ 和 $A^{\\top} A$：\n$$\nA A^{\\top} = \\begin{pmatrix} 2  0 \\\\ 0  0 \\end{pmatrix}, \n\\qquad\nA^{\\top} A = \\begin{pmatrix} 1  1 \\\\ 1  1 \\end{pmatrix}.\n$$\n$A A^{\\top}$ 的特征值为 $2$ 和 $0$，因此奇异值为 $\\sigma_{1} = \\sqrt{2}$ 和 $\\sigma_{2} = 0$。$A A^{\\top}$ 对应于特征值 $2$ 的单位特征向量是 $u_{1} = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}$，对应于特征值 $0$ 的单位特征向量是 $u_{2} = \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix}$。因此我们可以取\n$$\nU = \\begin{pmatrix} 1  0 \\\\ 0  1 \\end{pmatrix}, \n\\qquad\n\\Sigma = \\begin{pmatrix} \\sqrt{2}  0 \\\\ 0  0 \\end{pmatrix}.\n$$\n相应的右奇异向量 $v_{1}$ 通过 $v_{1} = \\frac{1}{\\sigma_{1}} A^{\\top} u_{1}$ 得到：\n$$\nA^{\\top} u_{1} = \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}, \n\\quad\nv_{1} = \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}.\n$$\n选择 $v_{2}$ 为一个与 $v_{1}$ 正交的单位向量，例如\n$$\nv_{2} = \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 1 \\\\ -1 \\end{pmatrix}.\n$$\n因此\n$$\nV = \\begin{pmatrix} \\frac{1}{\\sqrt{2}}  \\frac{1}{\\sqrt{2}} \\\\ \\frac{1}{\\sqrt{2}}  -\\frac{1}{\\sqrt{2}} \\end{pmatrix}.\n$$\n那么伪逆是\n$$\n\\Sigma^{+} = \\begin{pmatrix} \\frac{1}{\\sqrt{2}}  0 \\\\ 0  0 \\end{pmatrix},\n\\qquad\nA^{+} = V \\Sigma^{+} U^{\\top} = V \\Sigma^{+}.\n$$\n显式计算 $A^{+}$：\n$$\nA^{+} = \\begin{pmatrix} \\frac{1}{\\sqrt{2}}  \\frac{1}{\\sqrt{2}} \\\\ \\frac{1}{\\sqrt{2}}  -\\frac{1}{\\sqrt{2}} \\end{pmatrix}\n\\begin{pmatrix} \\frac{1}{\\sqrt{2}}  0 \\\\ 0  0 \\end{pmatrix}\n=\n\\begin{pmatrix} \\frac{1}{2}  0 \\\\ \\frac{1}{2}  0 \\end{pmatrix}.\n$$\n\n步骤 2：计算 $A A^{+}$ 和 $A^{+} A$ 并验证它们不相等。\n\n首先，\n$$\nA A^{+} = \\begin{pmatrix} 1  1 \\\\ 0  0 \\end{pmatrix}\n\\begin{pmatrix} \\frac{1}{2}  0 \\\\ \\frac{1}{2}  0 \\end{pmatrix}\n=\n\\begin{pmatrix} 1  0 \\\\ 0  0 \\end{pmatrix}.\n$$\n接着，\n$$\nA^{+} A = \\begin{pmatrix} \\frac{1}{2}  0 \\\\ \\frac{1}{2}  0 \\end{pmatrix}\n\\begin{pmatrix} 1  1 \\\\ 0  0 \\end{pmatrix}\n=\n\\begin{pmatrix} \\frac{1}{2}  \\frac{1}{2} \\\\ \\frac{1}{2}  \\frac{1}{2} \\end{pmatrix}.\n$$\n这两个矩阵显然不相等，所以 $A A^{+} \\neq A^{+} A$。\n\n步骤 3：确定 $A A^{+}$ 和 $A^{+} A$ 的值域和零空间。\n\n对于 $A A^{+}$：\n$$\nA A^{+} = \\begin{pmatrix} 1  0 \\\\ 0  0 \\end{pmatrix}.\n$$\n值域是 $A A^{+}$ 的列空间，即\n$$\n\\operatorname{range}(A A^{+}) = \\operatorname{span}\\!\\left\\{ \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} \\right\\}.\n$$\n零空间是满足 $(A A^{+}) x = 0$ 的 $x = \\begin{pmatrix} x_{1} \\\\ x_{2} \\end{pmatrix}$ 的集合，即\n$$\n\\begin{pmatrix} 1  0 \\\\ 0  0 \\end{pmatrix} \\begin{pmatrix} x_{1} \\\\ x_{2} \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix} \\;\\;\\Longrightarrow\\;\\; x_{1} = 0,\n$$\n所以\n$$\n\\operatorname{null}(A A^{+}) = \\operatorname{span}\\!\\left\\{ \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix} \\right\\}.\n$$\n\n对于 $A^{+} A$：\n$$\nA^{+} A = \\begin{pmatrix} \\frac{1}{2}  \\frac{1}{2} \\\\ \\frac{1}{2}  \\frac{1}{2} \\end{pmatrix}.\n$$\n其值域是其列向量的张成空间；两列都等于 $\\frac{1}{2} \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}$，因此\n$$\n\\operatorname{range}(A^{+} A) = \\operatorname{span}\\!\\left\\{ \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix} \\right\\}.\n$$\n其零空间由满足 $(A^{+} A) x = 0$ 的 $x$ 组成，即\n$$\n\\begin{pmatrix} \\frac{1}{2}  \\frac{1}{2} \\\\ \\frac{1}{2}  \\frac{1}{2} \\end{pmatrix} \\begin{pmatrix} x_{1} \\\\ x_{2} \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix} \\;\\;\\Longrightarrow\\;\\; x_{1} + x_{2} = 0,\n$$\n所以\n$$\n\\operatorname{null}(A^{+} A) = \\operatorname{span}\\!\\left\\{ \\begin{pmatrix} 1 \\\\ -1 \\end{pmatrix} \\right\\}.\n$$\n\n步骤 4：计算 $\\|A A^{+} - A^{+} A\\|_{F}^{2}$。\n\n计算差值\n$$\nD \\;=\\; A A^{+} - A^{+} A \\;=\\; \\begin{pmatrix} 1  0 \\\\ 0  0 \\end{pmatrix} - \\begin{pmatrix} \\frac{1}{2}  \\frac{1}{2} \\\\ \\frac{1}{2}  \\frac{1}{2} \\end{pmatrix}\n\\;=\\; \\begin{pmatrix} \\frac{1}{2}  -\\frac{1}{2} \\\\ -\\frac{1}{2}  -\\frac{1}{2} \\end{pmatrix}.\n$$\nFrobenius 范数的平方是其所有元素平方的和：\n$$\n\\|D\\|_{F}^{2} \\;=\\; \\left(\\frac{1}{2}\\right)^{2} + \\left(-\\frac{1}{2}\\right)^{2} + \\left(-\\frac{1}{2}\\right)^{2} + \\left(-\\frac{1}{2}\\right)^{2}\n\\;=\\; \\frac{1}{4} + \\frac{1}{4} + \\frac{1}{4} + \\frac{1}{4}\n\\;=\\; 1.\n$$\n因此，所求的标量值为 $1$。",
            "answer": "$$\\boxed{1}$$"
        },
        {
            "introduction": "将理论算法转化为可靠的计算机程序时，我们必须面对有限精度浮点运算带来的挑战，特别是如何处理那些接近于零的奇异值。这个实践练习  要求您设计并实现一个数值稳定的伪逆计算算法，其中包含了基于容差的秩决定策略。通过这个练习，您将把抽象的理论与数值线性代数中的实际问题联系起来，并学会如何编写能够处理真实世界数据中不精确性的稳健代码。",
            "id": "3592271",
            "problem": "设计一个数值稳定的算法，使用奇异值分解来计算实矩阵 $A$ 的 Moore–Penrose 伪逆 $A^{+}$，并使用一个显式容差 $\\tau$ 来确定数值秩。从数值线性代数的核心定义和公认事实出发。你的算法必须通过不等式 $\\,\\sigma_{i}  \\tau\\,$ 来判断哪些奇异值应被视为数值上非零，并据此构造 $A^{+}$，而不能依赖题目描述中的任何捷径公式。在你的推理和实现中，你必须根据浮点单位舍入误差 $u$ 和谱范数 $\\lVert A \\rVert_{2}$ 来证明选择 $\\tau$ 的合理性。你必须完成以下任务：\n\n- 使用通过 Penrose 条件和奇异值分解定义的 Moore–Penrose 伪逆作为基本依据。\n- 从带有单位舍入误差 $u$ 的浮点模型、奇异值分解和矩阵乘法的后向误差标准界，以及由欧几里得范数诱导的范数出发，论证形式为 $\\tau = \\alpha\\,u\\,\\lVert A \\rVert_{2}$ 的容差的合理性，其中 $\\alpha$ 是一个依赖于维度的因子。\n- 实现一个算法，该算法使用此容差通过奇异值分解计算 $A^{+}$，并数值上验证 Penrose 条件。\n\n程序必须在纯数学意义上运行。不涉及任何物理单位。所有角度（如果有）都应被视为无量纲实数。\n\n你的程序必须产生单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表。对于每个测试用例，你必须输出一个布尔值，当且仅当所有要求的数值验证都通过时为 $\\texttt{True}$，否则为 $\\texttt{False}$。每个测试用例的验证包括：\n\n- 使用谱范数验证四个 Penrose 条件，即 $A A^{+} A = A$、$A^{+} A A^{+} = A^{+}$、$(A A^{+})^{\\mathsf{T}} = A A^{+}$ 和 $(A^{+} A)^{\\mathsf{T}} = A^{+} A$，其误差需在由浮点单位舍入误差导出的容差范围内。具体来说，定义残差\n$$\n\\rho_{1} = \\frac{\\lVert A A^{+} A - A \\rVert_{2}}{\\max(1, \\lVert A \\rVert_{2})},\\quad\n\\rho_{2} = \\frac{\\lVert A^{+} A A^{+} - A^{+} \\rVert_{2}}{\\max(1, \\lVert A^{+} \\rVert_{2})},\n$$\n$$\n\\rho_{3} = \\frac{\\lVert (A A^{+})^{\\mathsf{T}} - A A^{+} \\rVert_{2}}{\\max(1, \\lVert A A^{+} \\rVert_{2})},\\quad\n\\rho_{4} = \\frac{\\lVert (A^{+} A)^{\\mathsf{T}} - A^{+} A \\rVert_{2}}{\\max(1, \\lVert A^{+} A \\rVert_{2})}.\n$$\n如果对于所有的 $j \\in \\{1,2,3,4\\}$ 都有 $\\rho_{j} \\le c\\,u$，则声明 Penrose 条件得到验证，其中 $c = 100\\,\\max(m,n)$，$m$ 和 $n$ 是矩阵 $A$ 的维度。\n\n- 验证数值秩等于严格大于容差 $\\tau$ 的奇异值数量，其中 $\\tau$ 按 $\\tau = \\max(m,n)\\,u\\,\\lVert A \\rVert_{2}$ 计算。\n\n测试套件和构造细节：\n\n你必须实现以下确定性测试套件。对于每个测试用例，通过组合标准正交因子和对角奇异值矩阵来构造具有指定奇异谱的矩阵 $A$。在所有需要随机性的地方使用固定的伪随机种子 $2025$，以确保所有构造过程都是确定性的。\n\n对于给定的维度对 $(m,n)$ 和奇异值列表 $\\{\\sigma_{1},\\dots,\\sigma_{r}\\}$（其中 $r \\le \\min(m,n)$），构造 $A$ 为 $A = U_{m \\times r}\\,\\Sigma_{r \\times r}\\,V_{n \\times r}^{\\mathsf{T}}$，其中 $U_{m \\times r}$ 和 $V_{n \\times r}$ 具有标准正交列，且 $\\Sigma_{r \\times r} = \\mathrm{diag}(\\sigma_{1},\\dots,\\sigma_{r})$。当指定有噪声时，添加一个谱范数如下文规定的扰动 $\\Delta A$。在所有情况下，程序都必须使用上述容差规则通过奇异值分解计算 $A^{+}$，并验证所述条件。\n\n提供以下测试用例：\n\n- 测试用例 1（理想情况，方阵，良态）：$m = 5$，$n = 5$，奇异值为 $\\{4, 3, 2, 1, 1/2\\}$，无噪声。\n- 测试用例 2（高矩阵，秩亏）：$m = 6$，$n = 4$，奇异值为 $\\{12, 8, 5\\}$，无噪声。精确秩为 $3$。\n- 测试用例 3（宽矩阵，有接近舍入误差尺度的小奇异值）：$m = 4$，$n = 6$，奇异值为 $\\{5, 1000\\,u, 10^{-16}, 0\\}$，无噪声。在容差规则下，预期的数值秩为 $2$，因为 $\\tau \\approx \\max(m,n)\\,u\\,\\lVert A \\rVert_{2} \\approx 6\\,u\\,5$，所以 $\\sigma_{1}$ 和 $\\sigma_{2}$ 大于 $\\tau$，其余则不大于。\n- 测试用例 4（零矩阵边缘情况）：$m = 3$，$n = 7$，奇异值为 $\\{\\}$，无噪声。数值秩为 $0$，$A^{+}$ 应为大小为 $n \\times m$ 的零矩阵。\n- 测试用例 5（低于容差尺度的噪声）：$m = 7$，$n = 5$，奇异值为 $\\{3, 2, 1\\}$，添加一个谱范数为 $\\lVert \\Delta A \\rVert_{2} = 1 \\cdot u \\cdot \\lVert A \\rVert_{2}$ 的扰动 $\\Delta A$。在容差规则 $\\tau = \\max(m,n)\\,u\\,\\lVert A \\rVert_{2}$ 下，数值秩应保持为 $3$，因为噪声水平严格低于 $\\tau$。\n\n你的程序必须：\n\n- 使用容差 $\\tau = \\max(m,n)\\,u\\,\\lVert A \\rVert_{2}$ 通过奇异值分解计算 $A^{+}$ 以确定秩。\n- 对于每个测试用例，报告一个布尔值。当且仅当所有四个 Penrose 残差都满足 $\\rho_{j} \\le c\\,u$（其中 $c = 100\\,\\max(m,n)$），并且数值秩等于根据用于构造 $A$ 的真实奇异谱计算出的、严格大于 $\\tau$ 的奇异值数量时，该值为 $\\texttt{True}$。\n- 产生单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表，例如 $\\texttt{[True,False,True,True,True]}$。\n\n这个问题陈述中的所有数学符号和数字，包括维度大小、容差和常数，都按要求用 LaTeX 表示。",
            "solution": "该问题要求设计、论证并实现一个用于计算实矩阵 $A \\in \\mathbb{R}^{m \\times n}$ 的 Moore-Penrose 伪逆 $A^{+}$ 的数值稳定算法。该方法的核心是奇异值分解（SVD），并结合一个经过审慎论证的、用于确定数值秩的容差。解决方案必须依据 Penrose 定义条件和特定的秩一致性检查进行验证。\n\n### 理论基础：Moore-Penrose 伪逆\n\n对于任意实矩阵 $A \\in \\mathbb{R}^{m \\times n}$，Moore-Penrose 伪逆是满足以下四个 Penrose 条件的唯一矩阵 $A^{+} \\in \\mathbb{R}^{n \\times m}$：\n1.  $A A^{+} A = A$\n2.  $A^{+} A A^{+} = A^{+}$\n3.  $(A A^{+})^{\\mathsf{T}} = A A^{+}$ （乘积 $A A^{+}$ 是一个对称矩阵）\n4.  $(A^{+} A)^{\\mathsf{T}} = A^{+} A$ （乘积 $A^{+} A$ 是一个对称矩阵）\n\n从几何上讲，$A A^{+}$ 是到 $A$ 的值域（其列空间）上的正交投影矩阵，而 $A^{+} A$ 是到 $A^{\\mathsf{T}}$ 的值域（其行空间）上的正交投影矩阵。\n\n奇异值分解（SVD）为构造 $A^{+}$ 提供了一条直接且数值稳定的途径。$A$ 的 SVD 是指分解式 $A = U \\Sigma V^{\\mathsf{T}}$，其中：\n-   $U \\in \\mathbb{R}^{m \\times m}$ 是一个正交矩阵，其列是 $A$ 的左奇异向量。\n-   $V \\in \\mathbb{R}^{n \\times n}$ 是一个正交矩阵，其列是 $A$ 的右奇异向量。\n-   $\\Sigma \\in \\mathbb{R}^{m \\times n}$ 是一个矩形对角矩阵，其对角元素 $\\Sigma_{ii} = \\sigma_i$ 是 $A$ 的奇异值，按非递增顺序排列：$\\sigma_1 \\ge \\sigma_2 \\ge \\dots \\ge \\sigma_{\\min(m,n)} \\ge 0$。\n\n给定此分解，伪逆 $A^{+}$ 定义为 $A^{+} = V \\Sigma^{+} U^{\\mathsf{T}}$。矩阵 $\\Sigma^{+} \\in \\mathbb{R}^{n \\times m}$ 是通过转置 $\\Sigma$ 并对其非零对角元素取倒数来构造的。具体来说，如果 $A$ 的秩为 $r$，则 $\\sigma_1, \\dots, \\sigma_r  0$ 且当 $i  r$ 时 $\\sigma_{i}=0$。那么 $\\Sigma^{+}$ 的对角元素由下式给出：\n$$\n(\\Sigma^{+})_{ii} = \\begin{cases} 1/\\sigma_i  \\text{if } \\sigma_i  0 \\\\ 0  \\text{if } \\sigma_i = 0 \\end{cases}\n$$\n\n### 数值稳定性与秩的确定\n\n在有限精度浮点运算中，一个非常小的非零奇异值与一个真正的零之间的区别会被舍入误差所模糊。SVD 的标准后向误差分析表明，计算出的分解 $\\hat{U} \\hat{\\Sigma} \\hat{V}^{\\mathsf{T}}$ 是一个邻近矩阵 $A+E$ 的精确 SVD，其中扰动 $E$ 的范数有界，满足 $\\|E\\|_2 \\le p(m,n) u \\|A\\|_2$。这里，$u$ 是浮点系统的单位舍入误差，$p(m,n)$ 是一个关于矩阵维度 $m$ 和 $n$ 的低次多项式。\n\n根据关于奇异值的 Weyl 扰动定理，计算出的奇异值 $\\hat{\\sigma}_i$ 与 $A$ 的真实奇异值 $\\sigma_i$ 之差最多为 $\\|E\\|_2$。因此，$|\\hat{\\sigma}_i - \\sigma_i| \\le p(m,n) u \\|A\\|_2$。这意味着任何小于此界的奇异值在计算上都与零无法区分。对这样的小值求逆将是数值上的灾难，因为它会以一个很大的因子（$1/\\sigma_i$）放大噪声。\n\n这使得引入*数值秩*的概念成为必要：即被认为在数值上不等于零的奇异值的数量。我们通过计算超过某个容差 $\\tau$ 的奇异值的数量来定义数值秩 $k$。对此容差，一个标准的、合理的选择是形式为 $\\tau = \\alpha u \\|A\\|_2$ 的值，其中 $\\|A\\|_2 = \\sigma_1$ 是最大的奇异值。问题指定选择 $\\tau = \\max(m,n) u \\|A\\|_2$。这个选择将比例常数设为 $\\alpha = \\max(m,n)$，这是对后向误差界中依赖于维度的因子 $p(m,n)$ 的一个简单而有效的启发式估计。\n\n### 计算 $A^{+}$ 的算法设计\n\n计算 $A^{+}$ 的算法如下：\n1.  给定输入矩阵 $A \\in \\mathbb{R}^{m \\times n}$。\n2.  计算 $A$ 的 SVD，得到 $U$、奇异值向量 $s$ 和 $V^{\\mathsf{T}}$。为提高数值效率，一个“瘦”SVD 就足够了，其中 $U$ 是 $m \\times k$，$s$ 是长度为 $k$ 的向量，$V^{\\mathsf{T}}$ 是 $k \\times n$，且 $k=\\min(m,n)$。\n3.  确定谱范数 $\\|A\\|_2$。如果 $s$ 不为空，则 $\\|A\\|_2 = s_1$；否则 $\\|A\\|_2 = 0$。\n4.  计算数值容差 $\\tau = \\max(m,n) u \\|A\\|_2$，其中 $u$ 是浮点类型的机器ε。\n5.  确定数值秩，记为 $k_{\\text{num}}$，即满足 $s_i  \\tau$ 的奇异值 $s_i$ 的数量。\n6.  构造一个与 $s$ 大小相同的新向量 $s_{\\text{inv}}$。对于每个 $s_i$，如果 $s_i  \\tau$，则对应的元素 $(s_{\\text{inv}})_i$ 为 $1/s_i$，否则为 $0$。\n7.  使用 SVD 的分量和 $s_{\\text{inv}}$ 构造伪逆 $A^{+}$：$A^{+} = V \\cdot \\text{diag}(s_{\\text{inv}}) \\cdot U^{\\mathsf{T}}$。\n\n### 验证协议\n\n问题要求对每个测试用例执行严格的验证协议。\n1.  **秩验证**：算法计算出的数值秩 $k_{\\text{num}}$ 必须等于一个参考秩。该参考秩定义为来自真实谱（用于构造测试矩阵 $A$）的奇异值中，严格大于为最终矩阵 $A$ 计算出的容差 $\\tau$ 的奇异值的数量。此测试验证了秩确定步骤对于矩阵构造和（如果适用）噪声添加过程中引入的扰动具有鲁棒性。\n2.  **Penrose 条件验证**：必须对四个 Penrose 条件进行数值检查。这是通过计算问题陈述中指定的残差 $\\rho_1, \\rho_2, \\rho_3, \\rho_4$ 来完成的。每个残差是误差的谱范数，通过期望量的范数（如果范数很小则用 $1$）进行归一化，以使比较具有尺度不变性。如果所有四个残差都满足 $\\rho_j \\le c u$，其中容差因子为 $c = 100 \\max(m,n)$，则测试通过。这个较大的因子考虑了在形成残差本身的矩阵乘法过程中浮点误差的累积。对这些条件的成功验证证实了计算出的矩阵 $A^{+}$ 在一个合理的数值容差范围内，其行为确实与真实的 Moore-Penrose 伪逆一致。\n\n这两个验证结果（秩验证和 Penrose 条件验证）的逻辑与（AND）决定了每个测试用例的布尔结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for Moore-Penrose pseudoinverse computation.\n    \"\"\"\n    \n    # Unit roundoff for double precision floating-point arithmetic\n    # Note: np.finfo(float).eps is machine epsilon (2^-52), while unit roundoff is technically eps/2 (2^-53).\n    # Using eps is a common practice and is absorbed by the heuristic constants in the tolerances.\n    u = np.finfo(float).eps\n    \n    # Fixed seed for deterministic test case generation\n    rng = np.random.default_rng(2025)\n\n    test_cases = [\n        {'m': 5, 'n': 5, 'sv': [4, 3, 2, 1, 0.5], 'noise_factor': 0},\n        {'m': 6, 'n': 4, 'sv': [12, 8, 5], 'noise_factor': 0},\n        {'m': 4, 'n': 6, 'sv': [5, 1000 * u, 1e-16, 0], 'noise_factor': 0},\n        {'m': 3, 'n': 7, 'sv': [], 'noise_factor': 0},\n        {'m': 7, 'n': 5, 'sv': [3, 2, 1], 'noise_factor': 1.0},\n    ]\n\n    results = []\n    for case in test_cases:\n        m, n, sv_list, noise_factor = case['m'], case['n'], case['sv'], case['noise_factor']\n        \n        # --- Matrix Construction ---\n        r = len(sv_list)\n        if r > 0:\n            # Generate U0 and V0 with orthonormal columns\n            U0_rand = rng.standard_normal((m, r))\n            U0, _ = np.linalg.qr(U0_rand)\n            \n            V0_rand = rng.standard_normal((n, r))\n            V0, _ = np.linalg.qr(V0_rand)\n            \n            Sigma0 = np.diag(sv_list)\n            A0 = U0 @ Sigma0 @ V0.T\n        else:\n            A0 = np.zeros((m, n))\n\n        # Add noise if specified\n        A = A0\n        if noise_factor > 0:\n            norm_A0 = sv_list[0] if r > 0 else 0\n            if norm_A0 > 0:\n                E = rng.standard_normal((m, n))\n                norm_E = np.linalg.norm(E, 2)\n                if norm_E > 1e-12: # Avoid division by zero for unlikely zero random matrix\n                    delta_A = E / norm_E * (noise_factor * u * norm_A0)\n                    A = A0 + delta_A\n        \n        # --- Pseudoinverse Calculation and Verification ---\n        is_valid = calculate_and_verify(A, m, n, np.array(sv_list), u, rng)\n        results.append(is_valid)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef calculate_and_verify(A, m, n, ground_truth_sv, u, rng):\n    \"\"\"\n    Computes the pseudoinverse of A and verifies the required conditions.\n    \n    Returns:\n        bool: True if all validations pass, False otherwise.\n    \"\"\"\n    \n    # --- 1. Compute Pseudoinverse A_plus and its Numerical Rank ---\n    # Use 'full_matrices=False' for thin SVD efficiency\n    U, s, Vh = np.linalg.svd(A, full_matrices=False)\n    \n    norm_A = s[0] if s.size > 0 else 0.0\n    tau = max(m, n) * u * norm_A\n    \n    computed_rank = np.sum(s > tau)\n    \n    s_inv = np.where(s > tau, 1.0 / s, 0.0)\n    \n    # Construct Sigma_plus of appropriate size k x k where k=len(s)\n    Sigma_plus = np.diag(s_inv)\n    \n    # A_plus = V @ Sigma_plus @ U.T\n    # Vh is V.T, so V = Vh.T\n    # Dimensions: Vh.T is n x k, Sigma_plus is k x k, U.T is k x m\n    k_svd = Vh.shape[0]\n    A_plus = (Vh.T[:, :k_svd]) @ Sigma_plus @ (U.T[:k_svd, :])\n\n    # --- 2. Rank Verification ---\n    # The reference rank is based on ground-truth singular values vs tolerance from final matrix A\n    reference_rank = np.sum(ground_truth_sv > tau)\n    rank_ok = (computed_rank == reference_rank)\n    \n    # --- 3. Penrose Conditions Verification ---\n    c_penrose = 100 * max(m, n)\n    tol_penrose = c_penrose * u\n    \n    # Pre-compute norms to avoid re-calculation and handle zero matrices\n    # norm_A is already computed\n    norm_A_plus = np.linalg.norm(A_plus, 2)\n    \n    # rho_1: || A A+ A - A ||_2 / max(1, ||A||_2)\n    res1 = A @ A_plus @ A - A\n    rho1 = np.linalg.norm(res1, 2) / max(1.0, norm_A)\n    \n    # rho_2: || A+ A A+ - A+ ||_2 / max(1, ||A+||_2)\n    res2 = A_plus @ A @ A_plus - A_plus\n    rho2 = np.linalg.norm(res2, 2) / max(1.0, norm_A_plus)\n    \n    # rho_3: || (A A+)^T - (A A+) ||_2 / max(1, ||A A+||_2)\n    P3 = A @ A_plus\n    res3 = P3.T - P3\n    rho3 = np.linalg.norm(res3, 2) / max(1.0, np.linalg.norm(P3, 2))\n\n    # rho_4: || (A+ A)^T - (A+ A) ||_2 / max(1, ||A+ A||_2)\n    P4 = A_plus @ A\n    res4 = P4.T - P4\n    rho4 = np.linalg.norm(res4, 2) / max(1.0, np.linalg.norm(P4, 2))\n    \n    penrose_ok = (rho1 = tol_penrose) and \\\n                 (rho2 = tol_penrose) and \\\n                 (rho3 = tol_penrose) and \\\n                 (rho4 = tol_penrose)\n                 \n    return rank_ok and penrose_ok\n    \nsolve()\n```"
        }
    ]
}