{
    "hands_on_practices": [
        {
            "introduction": "矩阵的条件数衡量其对扰动的敏感性。对于正规方程矩阵 $A^TA$ 而言，其条件数与矩阵 $A$ 的列向量之间的几何关系密切相关。本练习通过一个清晰的解析示例，展示了当 $A$ 的列向量接近线性相关时，为何 $A^TA$ 的条件数会急剧增大，从而揭示了正规方程潜在病态问题的根源。",
            "id": "2162074",
            "problem": "在数值线性代数中，矩阵的条件数是衡量其对输入数据误差敏感性的一个关键指标。对于一个线性最小二乘问题 $A\\mathbf{x} \\approx \\mathbf{b}$，其敏感性由正规方程矩阵 $A^TA$ 的条件数决定。当矩阵 $A$ 的列向量近似线性相关时，通常会出现病态。\n\n考虑一个简单的 $2 \\times 2$ 矩阵 $A$，其列向量代表平面上的两个基向量。第一列是向量 $\\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}$，第二列是向量 $\\begin{pmatrix} \\cos\\theta \\\\ \\sin\\theta \\end{pmatrix}$，其中 $\\theta$（以弧度为单位）是两个向量之间的夹角。假设 $\\theta$ 是一个小的正角。因此，矩阵 $A$ 由 $A = \\begin{pmatrix} 1 & \\cos\\theta \\\\ 0 & \\sin\\theta \\end{pmatrix}$ 给出。\n\n求在 $\\theta \\to 0^+$ 的极限情况下，相关正规方程矩阵 $A^TA$ 的2-范数条件数的主阶渐近表达式。你的答案应该是一个用 $\\theta$ 表示的简单表达式，它能捕捉小角度下的主导行为。",
            "solution": "题目要求我们求出当 $\\theta \\to 0^{+}$ 时，对于矩阵 $A=\\begin{pmatrix} 1 & \\cos\\theta \\\\ 0 & \\sin\\theta \\end{pmatrix}$，其正规方程矩阵 $A^{T}A$ 的2-范数条件数。对于一个对称正定矩阵 $M$，其2-范数条件数为 $\\kappa_{2}(M)=\\frac{\\lambda_{\\max}(M)}{\\lambda_{\\min}(M)}$，其中 $\\lambda_{\\max}$ 和 $\\lambda_{\\min}$ 分别是 $M$ 的最大和最小特征值。\n\n计算 $A^{T}A$：\n$$\nA^{T}=\\begin{pmatrix} 1 & 0 \\\\ \\cos\\theta & \\sin\\theta \\end{pmatrix}, \\quad\nA^{T}A=\\begin{pmatrix} 1 & \\cos\\theta \\\\ \\cos\\theta & 1 \\end{pmatrix}.\n$$\n矩阵 $\\begin{pmatrix} 1 & \\cos\\theta \\\\ \\cos\\theta & 1 \\end{pmatrix}$ 的特征值为\n$$\n\\lambda_{\\pm}=1 \\pm \\cos\\theta.\n$$\n因此，\n$$\n\\kappa_{2}(A^{T}A)=\\frac{\\lambda_{\\max}}{\\lambda_{\\min}}=\\frac{1+\\cos\\theta}{1-\\cos\\theta}.\n$$\n对于小的 $\\theta$，使用泰勒展开 $\\cos\\theta=1-\\frac{\\theta^{2}}{2}+O(\\theta^{4})$。因此\n$$\n1-\\cos\\theta=\\frac{\\theta^{2}}{2}+O(\\theta^{4}), \\quad 1+\\cos\\theta=2-\\frac{\\theta^{2}}{2}+O(\\theta^{4}).\n$$\n于是\n$$\n\\kappa_{2}(A^{T}A)=\\frac{2-\\frac{\\theta^{2}}{2}+O(\\theta^{4})}{\\frac{\\theta^{2}}{2}+O(\\theta^{4})}\n=\\frac{4}{\\theta^{2}}+O(1),\n$$\n所以当 $\\theta \\to 0^{+}$ 时的主阶渐近行为是\n$$\n\\kappa_{2}(A^{T}A)\\sim \\frac{4}{\\theta^{2}}.\n$$",
            "answer": "$$\\boxed{\\frac{4}{\\theta^{2}}}$$"
        },
        {
            "introduction": "巨大的条件数预示着潜在的数值问题，但误差究竟从何而来？本练习将深入探讨其具体机制。我们将通过一个精心设计的例子，展示在计算 $A^TA$ 这一初始步骤中，由于两个几乎相等的大数相减，是如何导致“灾难性抵消”的。通过量化分析，您将看到，即使是矩阵中单个元素的计算误差，也可能对最终解的精度造成毁灭性的影响。",
            "id": "3540706",
            "problem": "考虑一个实数 $2 \\times 2$ 矩阵 $A$，其列向量为 $c_{1}$ 和 $c_{2}$，定义为 $c_{1} = \\begin{pmatrix} M \\\\ M \\end{pmatrix}$ 和 $c_{2} = \\begin{pmatrix} M \\\\ -M + \\delta \\end{pmatrix}$，其中 $M > 0$ 和 $\\delta > 0$ 满足 $0 < \\delta \\ll M$。令 $S = A^{T}A$ 为格拉姆矩阵。假设构成 $S$ 的内积是在标准的浮点算术中计算的，该算术遵循模型 $\\operatorname{fl}(x \\circ y) = (x \\circ y)(1 + \\varepsilon)$，其中对于每个基本运算 $\\circ \\in \\{+, -, \\times\\}$ 都有 $|\\varepsilon| \\leq u$，并且单位舍入误差 $u$ 满足 $\\delta < Mu$。在此假设下，当通过内积直接计算时，$S$ 的非对角元素 $s_{12}$ 会遭受灾难性抵消，而对角元素 $s_{11}$ 和 $s_{22}$ 产生的相对误差与 $s_{12}$ 相比可以忽略不计。\n\n现在考虑使用正规方程 $Sx = A^{T}b$ 求解最小二乘问题 $\\min_{x \\in \\mathbb{R}^{2}} \\|Ax - b\\|_{2}$，其中右端项为特定的 $b = c_{2}$。为了分离非对角误差的影响，假设 $A^{T}b$ 是在精确算术中形成的，并且 $S$ 的对角线元素 $s_{11}$ 和 $s_{22}$ 是精确的，但由于抵消，计算出的非对角元素为 $\\widetilde{s}_{12} = 0$。\n\n仅从格拉姆矩阵和正规方程的定义，以及上述浮点误差模型出发，确定解的相对前向误差，\n$$\n\\frac{\\|x_{\\text{comp}} - x_{\\star}\\|_{2}}{\\|x_{\\star}\\|_{2}},\n$$\n其中 $x_{\\star}$ 是精确的最小二乘解，$x_{\\text{comp}}$ 是通过求解将非对角元素设置为 $\\widetilde{s}_{12} = 0$ 的扰动正规方程得到的解。将你的最终答案表示为仅包含 $M$ 和 $\\delta$ 的闭式解析表达式。",
            "solution": "我们首先根据定义计算格拉姆矩阵 $S = A^{T}A$ 的元素。列向量为 $c_{1} = \\begin{pmatrix} M \\\\ M \\end{pmatrix}$ 和 $c_{2} = \\begin{pmatrix} M \\\\ -M + \\delta \\end{pmatrix}$。格拉姆矩阵的元素是内积 $s_{ij} = c_{i}^{T} c_{j}$：\n$$\ns_{11} = c_{1}^{T} c_{1} = M^{2} + M^{2} = 2M^{2},\n$$\n$$\ns_{22} = c_{2}^{T} c_{2} = M^{2} + (-M + \\delta)^{2} = M^{2} + (M^{2} - 2M\\delta + \\delta^{2}) = 2M^{2} - 2M\\delta + \\delta^{2},\n$$\n$$\ns_{12} = c_{1}^{T} c_{2} = M \\cdot M + M \\cdot (-M + \\delta) = M^{2} - M^{2} + M\\delta = M\\delta.\n$$\n\n因此，$s_{12}$ 相对于 $s_{11}$ 和 $s_{22}$ 来说很小，因为它是由符号相反的 $M^{2}$ 项相互抵消产生的，留下一个量级为 $M\\delta$ 的残余项。在 $\\delta < Mu$ 的浮点假设下，通过计算两个乘积 $M \\cdot M$ 和 $M \\cdot (-M + \\delta)$ 并将它们相加来直接计算 $s_{12}$ 会得到\n$$\n\\operatorname{fl}(M) \\approx M,\\quad \\operatorname{fl}(-M + \\delta) \\approx -M,\n$$\n因此\n$$\n\\operatorname{fl}(s_{12}) = \\operatorname{fl}(M \\cdot M + M \\cdot (-M + \\delta)) \\approx \\operatorname{fl}(M^{2} + M \\cdot (-M)) = \\operatorname{fl}(M^{2} - M^{2}) \\approx 0.\n$$\n因此，计算出的非对角元素 $\\widetilde{s}_{12} = 0$，而主要由平方和构成的 $s_{11}$ 和 $s_{22}$，在相同的算术模型下具有可忽略的相对误差。非对角元素的相对误差为\n$$\n\\frac{| \\widetilde{s}_{12} - s_{12} |}{| s_{12} |} = \\frac{|0 - M\\delta|}{|M\\delta|} = 1,\n$$\n与良好缩放量中的典型相对误差相比，这个误差很大。\n\n我们现在量化其对 $b = c_{2}$ 的最小二乘问题的正规方程解的影响。首先，精确计算 $y = A^{T} b$：\n$$\ny = \\begin{pmatrix} c_{1}^{T} b \\\\ c_{2}^{T} b \\end{pmatrix} = \\begin{pmatrix} c_{1}^{T} c_{2} \\\\ c_{2}^{T} c_{2} \\end{pmatrix} = \\begin{pmatrix} s_{12} \\\\ s_{22} \\end{pmatrix} = \\begin{pmatrix} M\\delta \\\\ 2M^{2} - 2M\\delta + \\delta^{2} \\end{pmatrix}.\n$$\n\n精确的正规方程为 $S x = y$，其中\n$$\nS = \\begin{pmatrix} s_{11} & s_{12} \\\\ s_{12} & s_{22} \\end{pmatrix} = \\begin{pmatrix} 2M^{2} & M\\delta \\\\ M\\delta & 2M^{2} - 2M\\delta + \\delta^{2} \\end{pmatrix}.\n$$\n观察到 $b = c_{2}$ 位于 $A$ 的列空间中；因为当 $M > 0$ 时，$A$ 是 $2 \\times 2$ 的非奇异矩阵，所以最小二乘解与 $Ax = b$ 的精确解一致，即 $x_{\\star} = \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix}$。这也可以通过直接求解精确的正规方程得出：由于 $y = \\begin{pmatrix} s_{12} \\\\ s_{22} \\end{pmatrix}$ 且 $S$ 是格拉姆矩阵，将 $b$ 表示为列向量的线性组合且系数为 $(0,1)$ 的解 $x_{\\star}$ 满足 $S x_{\\star} = y$。\n\n接下来，考虑扰动后的正规方程，其中非对角元素被设为零，而对角元素保持精确：\n$$\n\\widetilde{S} = \\begin{pmatrix} s_{11} & 0 \\\\ 0 & s_{22} \\end{pmatrix} = \\begin{pmatrix} 2M^{2} & 0 \\\\ 0 & 2M^{2} - 2M\\delta + \\delta^{2} \\end{pmatrix}.\n$$\n我们用精确的右端项 $y$ 求解 $\\widetilde{S} x_{\\text{comp}} = y$。由于 $\\widetilde{S}$ 是对角矩阵，解的各分量是解耦的：\n$$\nx_{\\text{comp},1} = \\frac{y_{1}}{s_{11}} = \\frac{s_{12}}{s_{11}} = \\frac{M\\delta}{2M^{2}} = \\frac{\\delta}{2M}, \\quad x_{\\text{comp},2} = \\frac{y_{2}}{s_{22}} = \\frac{s_{22}}{s_{22}} = 1.\n$$\n因此，\n$$\nx_{\\text{comp}} = \\begin{pmatrix} \\frac{\\delta}{2M} \\\\ 1 \\end{pmatrix}, \\quad x_{\\star} = \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix}.\n$$\n\n前向误差为\n$$\n\\|x_{\\text{comp}} - x_{\\star}\\|_{2} = \\left\\| \\begin{pmatrix} \\frac{\\delta}{2M} \\\\ 0 \\end{pmatrix} \\right\\|_{2} = \\frac{\\delta}{2M}.\n$$\n精确解的范数为\n$$\n\\|x_{\\star}\\|_{2} = \\left\\| \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix} \\right\\|_{2} = 1.\n$$\n因此，相对前向误差为\n$$\n\\frac{\\|x_{\\text{comp}} - x_{\\star}\\|_{2}}{\\|x_{\\star}\\|_{2}} = \\frac{\\delta}{2M}.\n$$\n\n这个闭式表达式直接量化了在抵消情况下形成 $A^{T}A$ 时，非对角元素中产生的巨大相对误差所造成的影响：它在解中注入了一个大小为 $\\delta/(2M)$ 的伪分量，尽管沿 $c_{1}$ 的真实系数为零。当 $\\delta$ 固定，$M$ 增大时，非对角元素 $s_{12} = M\\delta$ 在浮点运算中越来越容易受到抵消的影响，而由此引起的相对前向误差 $\\delta/(2M)$ 则变得更小；然而，对于固定的单位舍入误差 $u$ 和约束条件 $\\delta < Mu$，可以选择与 $Mu$ 成比例的 $\\delta$ 来维持一个预定的误差水平，这说明了正规方程对存在抵消的内积形成的敏感性。",
            "answer": "$$\\boxed{\\frac{\\delta}{2M}}$$"
        },
        {
            "introduction": "现在，让我们将理论分析与计算实践联系起来。这个练习要求您编写代码，以探索正规方程在不同浮点精度下的稳定性。通过基于条件数和机器精度推导一个简单的“稳定性预测不等式”，您将能够绘制出一个“相图”，清晰地界定正规方程在何种情况下是可靠的，以及在何处会失效，并通过数值实验来验证这些预测。",
            "id": "3540736",
            "problem": "考虑纯数学意义上的超定线性最小二乘问题。设 $A \\in \\mathbb{R}^{m \\times n}$，其中 $m \\ge n$ 且 $A$ 为列满秩矩阵，并设 $b \\in \\mathbb{R}^m$。最小二乘解是在 $x \\in \\mathbb{R}^n$ 上最小化 $\\|Ax - b\\|_2$ 的解。一种经典算法是求解正规方程 $A^\\top A x = A^\\top b$。对于单位舍入（机器 epsilon）为 $\\epsilon_{\\text{mach}}$ 的浮点运算，众所周知，与使用更稳定方法求解最小二乘问题相比，求解正规方程会遭遇放大的条件数问题。你将构建一个受控的矩阵族，以研究在何种情况下正规方程在单精度和双精度下是可接受的，并将其与一个区分数值稳定区和不稳定区的预测不等式联系起来。\n\n从以下基本基础出发：\n- 列满秩矩阵的 $2$-范数条件数的定义为 $\\kappa_2(A) = \\sigma_{\\max}(A)/\\sigma_{\\min}(A)$，其中 $\\sigma_{\\max}(A)$ 和 $\\sigma_{\\min}(A)$ 分别是 $A$ 的最大和最小奇异值。\n- 正规方程矩阵为 $A^\\top A$，它是一个对称正定矩阵，其 $2$-范数条件数为 $\\kappa_2(A^\\top A) = \\kappa_2(A)^2$。\n- 单位舍入为 $\\epsilon_{\\text{mach}}$ 的浮点运算的一阶舍入模型指出，每个基本算术运算都会产生一个相对误差，其界限（一阶近似）是 $\\epsilon_{\\text{mach}}$ 的一个常数倍，并且使用后向稳定方法求解一个良态线性系统时，其前向误差在相应范数下与条件数乘以 $\\epsilon_{\\text{mach}}$ 成正比。\n\n你的任务是：\n1. 对参数 $\\gamma \\ge 0$，构造一个参数化矩阵族 $A(\\gamma) \\in \\mathbb{R}^{m \\times 2}$，其奇异值指定为 $\\sigma_1 = 1$ 和 $\\sigma_2 = 10^{-\\gamma}$。确保 $m \\ge 2$ 且矩阵为列满秩。使用一个标准正交基 $U \\in \\mathbb{R}^{m \\times 2}$ 来构造 $A(\\gamma) = U \\operatorname{diag}(\\sigma_1, \\sigma_2)$，使得 $\\kappa_2(A(\\gamma)) = 10^{\\gamma}$。选择一个固定的非零向量 $x_\\star \\in \\mathbb{R}^2$ 并设置 $b(\\gamma) = A(\\gamma) x_\\star$。\n2. 使用上述浮点模型和条件数性质，从第一性原理出发，推导一个预测不等式。该不等式仅基于 $\\kappa_2(A)$、$\\epsilon_{\\text{mach}}$ 和一个容差 $\\tau > 0$，用于判断在给定精度下求解正规方程是否应被视为数值上可接受。你的推导必须从求解线性系统的敏感性以及关系式 $\\kappa_2(A^\\top A) = \\kappa_2(A)^2$ 开始。将“可接受”精确定义为：产生的解 $x$ 的相对误差满足 $\\|x - x_\\star\\|_2 / \\|x_\\star\\|_2 \\le \\tau$。\n3. 实现一个程序，对于下述每个测试用例，执行以下操作：\n   - 确定性地构造 $A(\\gamma)$ 和 $b(\\gamma)$。\n   - 分别在单精度（$32$ 位浮点数的 $\\epsilon_{\\text{mach}}$）和双精度（$64$ 位浮点数的 $\\epsilon_{\\text{mach}}$）下求解正规方程，以获得 $x^{(32)}(\\gamma)$ 和 $x^{(64)}(\\gamma)$。$A(\\gamma)$ 和 $b(\\gamma)$ 的构造可以在更高精度下进行，但 $A^\\top A$ 和 $A^\\top b$ 的形成以及求解过程必须在目标精度下执行。\n   - 计算测得的相对误差 $e^{(p)}(\\gamma) = \\|x^{(p)}(\\gamma) - x_\\star\\|_2/\\|x_\\star\\|_2$，其中 $p \\in \\{32,64\\}$。\n   - 使用你推导出的不等式，在每个精度下计算预测的稳定性分类。该不等式必须用 $\\kappa_2(A(\\gamma))$、相应精度的 $\\epsilon_{\\text{mach}}$ 和 $\\tau$ 来表示。\n   - 将一个“阶段”类别编码为 $\\{0,1,2,3\\}$ 中的一个整数：\n     - $0$：单精度和双精度都可接受，\n     - $1$：单精度不可接受而双精度可接受，\n     - $2$：单精度可接受而双精度不可接受，\n     - $3$：两者都不可接受。\n     该类别需要生成两次：一次基于预测不等式（“预测类别”），一次基于测量误差（“测量类别”）。\n4. 测试套件必须使用以下固定参数：\n   - $m = 200$, $n = 2$,\n   - $x_\\star = [1,-1]^\\top$,\n   - 容差 $\\tau = 10^{-3}$,\n   - 参数值 $\\gamma \\in \\{0.5,\\, 2.2,\\, 6.0,\\, 6.3,\\, 6.4,\\, 8.0\\}$,\n   - 用于构造 $U$ 的固定随机种子，以确保结果是确定性的。\n5. 最终输出格式：你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素对应于给定顺序的一个 $\\gamma$ 值，并且本身是一个包含两个整数的列表 $[\\text{predicted\\_category},\\text{measured\\_category}]$。例如，一个包含两个测试用例的输出可能如下所示：”[[0,0],[1,1]]”。该行中任何地方都不能有空格。\n\n此问题不涉及物理单位。所有角度（如果有的话）均不存在。所有结果均为无量纲。最终列表的每个元素必须是整数。你的代码必须是完全自包含的，并能生成确切的最终输出格式。",
            "solution": "此问题被评估为有效。它是一个适定、有科学依据的数值线性代数问题，内容自包含，没有矛盾或歧义。它要求进行标准的理论推导，然后通过数值实验来说明一个基本概念：最小二乘问题的正规方程的病态性。\n\n### 1. 预测不等式的推导\n\n目标是推导一个不等式，用于预测正规方程的数值解何时是“可接受的”。“可接受”定义为计算出的解 $x$ 的相对误差受容差 $\\tau$ 的限制。\n$$ \\frac{\\|x - x_\\star\\|_2}{\\|x_\\star\\|_2} \\le \\tau $$\n其中 $x_\\star$ 是精确解。\n\n正规方程由 $A^\\top A x = A^\\top b$ 给出。我们可以将其表示为一个标准线性系统 $Mx = y$，其中矩阵为 $M = A^\\top A$，右侧项为 $y = A^\\top b$。问题指出，对于所构造的测试用例，$b = A x_\\star$，这意味着 $x_\\star$ 是最小二乘问题以及正规方程的精确解，因为 $A^\\top A x_\\star = A^\\top (A x_\\star) = A^\\top b$。\n\n分析的核心在于用浮点运算求解线性系统 $Mx = y$ 的前向误差。对于一个后向稳定的线性系统求解器（例如基于 Cholesky 分解的求解器，适用于对称正定矩阵 $M = A^\\top A$），标准误差分析给出了计算解 $\\hat{x}$ 的相对误差的如下界限：\n$$ \\frac{\\|\\hat{x} - x_\\star\\|_2}{\\|x_\\star\\|_2} \\le c \\cdot \\kappa_2(M) \\cdot \\epsilon_{\\text{mach}} $$\n这里，$\\epsilon_{\\text{mach}}$ 是所用浮点精度的机器 epsilon（单位舍入），$\\kappa_2(M)$ 是矩阵 $M$ 的 $2$-范数条件数，$c$ 是一个数量级为 $1$ 的常数，取决于矩阵的维度和算法的细节。这个界限包含了形成系统 $(M, y)$ 和求解它的两部分误差。\n\n问题给出了原始矩阵 $A$ 的条件数与正规方程矩阵 $M=A^\\top A$ 的条件数之间的关键关系：\n$$ \\kappa_2(A^\\top A) = \\kappa_2(A)^2 $$\n将此代入误差界限，我们得到：\n$$ \\frac{\\|\\hat{x} - x_\\star\\|_2}{\\|x_\\star\\|_2} \\le c \\cdot \\kappa_2(A)^2 \\cdot \\epsilon_{\\text{mach}} $$\n为了按要求创建一个简单的一阶预测器，我们可以通过取常数 $c=1$ 来模拟其行为。这给出了相对误差的直接估计：\n$$ e_{\\text{pred}} \\approx \\kappa_2(A)^2 \\cdot \\epsilon_{\\text{mach}} $$\n如果测量误差不大于 $\\tau$，则该解被认为是“可接受的”。因此，我们可以通过检查我们的估计误差界限是否在此容差范围内来预测其可接受性：\n$$ \\kappa_2(A)^2 \\cdot \\epsilon_{\\text{mach}} \\le \\tau $$\n这就是预测不等式。对于具有 $\\kappa_2(A(\\gamma)) = 10^{\\gamma}$ 的特定参数化矩阵族 $A(\\gamma)$，该不等式变为：\n$$ (10^\\gamma)^2 \\cdot \\epsilon_{\\text{mach}} \\le \\tau \\quad \\implies \\quad 10^{2\\gamma} \\cdot \\epsilon_{\\text{mach}} \\le \\tau $$\n这个不等式将用于对单精度（$\\epsilon_{\\text{mach}} \\approx 1.19 \\times 10^{-7}$）和双精度（$\\epsilon_{\\text{mach}} \\approx 2.22 \\times 10^{-16}$）的预测稳定性进行分类。\n\n### 2. 数值实验设计\n\n该实现将系统地测试这一预测。对于测试套件 $\\{0.5, 2.2, 6.0, 6.3, 6.4, 8.0\\}$ 中的每个参数 $\\gamma$：\n\n1.  **矩阵构造**：使用固定的随机种子生成一个矩阵 $R \\in \\mathbb{R}^{200 \\times 2}$。对 $R$ 进行 QR 分解，得到一个具有标准正交列的矩阵 $U \\in \\mathbb{R}^{200 \\times 2}$。对于所有测试用例，这个 $U$ 都是固定的。然后构造矩阵 $A(\\gamma)$ 为 $A(\\gamma) = U \\Sigma(\\gamma)$，其中 $\\Sigma(\\gamma) = \\operatorname{diag}(1, 10^{-\\gamma})$。这种构造确保了 $A(\\gamma)$ 的奇异值确实是 $1$ 和 $10^{-\\gamma}$，因此 $\\kappa_2(A(\\gamma)) = 10^\\gamma$。向量 $b(\\gamma)$ 被设置为 $A(\\gamma)x_\\star$，其中 $x_\\star = [1, -1]^\\top$。这确保了精确解是已知的，并且最小二乘问题的残差为零。\n\n2.  **求解与误差测量**：对于每种精度（32 位和 64 位），执行以下步骤：\n    a. 将矩阵 $A(\\gamma)$ 和向量 $b(\\gamma)$ 转换为目标精度。\n    b. 使用该目标精度的算术运算来形成正规方程矩阵 $A^\\top A$ 和向量 $A^\\top b$。\n    c. 求解线性系统 $(A^\\top A)x = (A^\\top b)$，以找到精度为 $p \\in \\{32, 64\\}$ 的计算解 $x^{(p)}(\\gamma)$。\n    d. 计算测得的相对误差 $e^{(p)}(\\gamma) = \\|x^{(p)}(\\gamma) - x_\\star\\|_2 / \\|x_\\star\\|_2$。\n\n3.  **分类**：\n    -   **预测类别**：对于每种精度 $p$，评估不等式 $10^{2\\gamma} \\cdot \\epsilon_{\\text{mach}}^{(p)} \\le \\tau$。如果不等式成立，则该精度被认为是可接受的。\n    -   **测量类别**：对于每种精度 $p$，将测得的误差 $e^{(p)}(\\gamma)$ 与容差 $\\tau$ 进行比较。如果 $e^{(p)}(\\gamma) \\le \\tau$，则该解被认为是可接受的。\n    -   根据对单精度和双精度的这些可接受性检查，按照问题陈述中指定的规则，为预测和测量结果分别分配一个来自 $\\{0, 1, 2, 3\\}$ 的类别。类别 $2$（单精度可接受，双精度不可接受）预计不会出现。\n\n此过程为每个 $\\gamma$ 值生成一对类别 $[\\text{predicted\\_category}, \\text{measured\\_category}]$，然后将其格式化为最终输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the numerical analysis problem concerning the conditioning of normal equations.\n    \"\"\"\n    # Task 4: Fixed parameters\n    m = 200\n    n = 2\n    x_star = np.array([1.0, -1.0], dtype=np.float64)\n    tau = 1e-3\n    gamma_values = [0.5, 2.2, 6.0, 6.3, 6.4, 8.0]\n    random_seed = 42\n\n    # Machine epsilon for single and double precision\n    eps_32 = np.finfo(np.float32).eps\n    eps_64 = np.finfo(np.float64).eps\n\n    # Generate a fixed orthonormal basis U\n    np.random.seed(random_seed)\n    # Generate a random m x n matrix\n    R = np.random.randn(m, n)\n    # Use QR decomposition to get an orthonormal basis for its column space\n    U, _ = np.linalg.qr(R)\n    U = U.astype(np.float64)\n\n    results = []\n\n    # Helper function for categorization\n    def get_category(single_ok, double_ok):\n        if single_ok and double_ok:\n            return 0  # Both acceptable\n        elif not single_ok and double_ok:\n            return 1  # Single unacceptable, double acceptable\n        elif single_ok and not double_ok:\n            return 2  # Single acceptable, double unacceptable (not expected)\n        else: # not single_ok and not double_ok\n            return 3  # Both unacceptable\n\n    for gamma in gamma_values:\n        # Task 1: Construct matrix A(gamma) and vector b(gamma)\n        # Use high precision (float64) for the \"true\" A and b\n        sigma1 = 1.0\n        sigma2 = 10.0**(-gamma)\n        Sigma = np.diag([sigma1, sigma2]).astype(np.float64)\n        A = U @ Sigma\n        b = A @ x_star\n\n        kappa_A = 10.0**gamma\n\n        # Task 2: Use the derived predictor inequality\n        # Predict acceptability for single precision (32-bit)\n        pred_single_ok = (kappa_A**2 * eps_32) = tau\n        # Predict acceptability for double precision (64-bit)\n        pred_double_ok = (kappa_A**2 * eps_64) = tau\n\n        predicted_category = get_category(pred_single_ok, pred_double_ok)\n\n        # Task 3: Solve normal equations and measure errors\n        # Solve for single precision (float32)\n        A_32 = A.astype(np.float32)\n        b_32 = b.astype(np.float32)\n        AtA_32 = A_32.T @ A_32\n        Atb_32 = A_32.T @ b_32\n        x_32 = np.linalg.solve(AtA_32, Atb_32)\n        err_32 = np.linalg.norm(x_32 - x_star) / np.linalg.norm(x_star)\n        meas_single_ok = err_32 = tau\n\n        # Solve for double precision (float64)\n        A_64 = A.astype(np.float64)\n        b_64 = b.astype(np.float64)\n        AtA_64 = A_64.T @ A_64\n        Atb_64 = A_64.T @ b_64\n        x_64 = np.linalg.solve(AtA_64, Atb_64)\n        err_64 = np.linalg.norm(x_64 - x_star) / np.linalg.norm(x_star)\n        meas_double_ok = err_64 = tau\n\n        measured_category = get_category(meas_single_ok, meas_double_ok)\n\n        results.append([predicted_category, measured_category])\n\n    # Task 5: Final output format\n    # The format \"[p,m]\" must be produced without spaces.\n    formatted_results = [f\"[{res[0]},{res[1]}]\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}