{
    "hands_on_practices": [
        {
            "introduction": "要评估 Householder 方法的效率，理解其计算成本至关重要。本练习  将引导你从第一性原理出发，逐步进行浮点运算（FLOP）计数，从而揭示该算法的 $O(n^3)$ 复杂度。这种分析不仅对于比较不同算法和预测性能至关重要，也加深了对算法内部工作细节的理解。",
            "id": "3572232",
            "problem": "考虑一个实对称矩阵 $A \\in \\mathbb{R}^{n \\times n}$，以及使用 Householder 反射将其约化为三对角形式的过程。在 $1 \\leq k \\leq n-2$ 的每一步 $k$ 中，该算法作用于尾部子矩阵 $A^{(k)} \\in \\mathbb{R}^{m \\times m}$，其中 $m = n - k$。令 $a = A_{k+1:n, k} \\in \\mathbb{R}^{m}$ 表示在其第一个分量以下要被消元的子向量。构造一个 Householder 反射镜 $H = I - \\tau w w^{\\mathsf{T}}$，其中 $w \\in \\mathbb{R}^{m}$ 且标量 $\\tau \\in \\mathbb{R}$，使得 $H$ 将 $a$ 中除第一个元素外的所有元素都置为零。对称更新通过秩-2 公式将 $H$ 从两侧应用于 $A^{(k)}$：\n$$\ny = A^{(k)} w, \\quad \\alpha = \\frac{\\tau}{2} w^{\\mathsf{T}} y, \\quad y := y - \\alpha w, \\quad A^{(k)} := A^{(k)} - w y^{\\mathsf{T}} - y w^{\\mathsf{T}},\n$$\n并且只更新 $A^{(k)}$ 的下三角部分。\n\n使用以下浮点运算 (FLOP) 模型：每次浮点加法或乘法计为 1 FLOP；除法、平方根、比较和内存操作不计数。在计算内积或矩阵向量乘积时，显式地计算所有乘法和加法。在构造 Householder 向量 $w$ 时，计算欧几里得范数 $\\|a\\|_{2}$ 和内积 $w^{\\mathsf{T}} w$，并认为第一个分量的修改 $w_1 := w_1 + \\operatorname{sign}(w_1)\\|a\\|_{2}$ 在此模型下耗费 1 FLOP。\n\n从第一性原理出发，推导：\n- 在步骤 $k$ 中构造 $w$ 和 $\\tau$ 所需的 FLOP 计数，作为 $m$ 的函数，\n- 使用上述对称秩-2 更新将 $H$ 应用于 $A^{(k)}$ 所需的 FLOP 计数，仅计算下三角部分的更新，以及\n- 每步的总成本 $C_k$，用 $m$ 表示。\n\n然后将 $C_k$ 对 $k$ 求和，得到一个关于 $n$ 的单一简化闭式解析表达式，表示在此模型下将 $A$ 约化为三对角形式所需的总 FLOP 数。请提供精确的最终表达式，不要四舍五入。",
            "solution": "首先根据指定标准对用户提供的问题进行验证。\n\n### 问题验证\n\n**第 1 步：提取已知条件**\n- 矩阵：实对称矩阵 $A \\in \\mathbb{R}^{n \\times n}$。\n- 算法：使用 Householder 反射约化为三对角形式。\n- 步骤：$k$ 从 $1$ 到 $n-2$。\n- 子矩阵：在步骤 $k$，算法作用于 $A^{(k)} \\in \\mathbb{R}^{m \\times m}$，其中 $m = n - k$。\n- 目标向量：$a = A_{k+1:n, k} \\in \\mathbb{R}^{m}$。\n- Householder 反射镜：$H = I - \\tau w w^{\\mathsf{T}}$，其中 $w \\in \\mathbb{R}^{m}$ 且 $\\tau \\in \\mathbb{R}$。\n- 对称更新公式：\n  1. $y = A^{(k)} w$\n  2. $\\alpha = \\frac{\\tau}{2} w^{\\mathsf{T}} y$\n  3. $y := y - \\alpha w$\n  4. $A^{(k)} := A^{(k)} - w y^{\\mathsf{T}} - y w^{\\mathsf{T}}$\n- 更新约束：只更新 $A^{(k)}$ 的下三角部分。\n- FLOP 模型：\n  - 加法或乘法：1 FLOP。\n  - 除法、平方根、比较、内存操作：0 FLOPs。\n  - 内积/矩阵向量乘积：显式计算所有加法和乘法。\n- Householder 向量构造：\n  - 计算欧几里得范数 $\\|a\\|_{2}$。\n  - 计算内积 $w^{\\mathsf{T}} w$。\n  - 修改 $w_1 := w_1 + \\operatorname{sign}(w_1)\\|a\\|_{2}$ 的成本为 1 FLOP。\n\n**第 2 步：使用提取的已知条件进行验证**\n- **科学性：** 该问题描述了对称矩阵三对角化的标准且正确的算法，这是数值线性代数中的一个基本课题。所提供的秩-2 更新公式是一种已知的有效实现。\n- **适定性：** 该问题提供了一套清晰的指令和一个特定的计算成本模型，从而可以得到一个唯一确定的总 FLOP 计数的解析解。\n- **客观性：** 问题以精确的数学和算法术语陈述，没有主观性。\n- **完整性与一致性：** 问题是自洽的。所有必要的公式、变量和成本分配都已明确提供。没有矛盾之处。\n\n**第 3 步：结论与行动**\n该问题是有效的，因为它是科学合理的、适定的、客观的和自洽的。我将继续推导解答。\n\n### 详细解答\n\n浮点运算 (FLOPs) 的总数是通过对约化过程中每一步 $k$ (从 $k=1$ 到 $k=n-2$) 的成本求和来确定的。在每一步 $k$ 中，子问题的规模由 $m=n-k$ 决定。$m$ 的范围是从 $n-1$ (当 $k=1$) 递减到 $2$ (当 $k=n-2$)。我们将推导单步成本作为 $m$ 的函数，然后在适当的 $m$ 范围内求和。\n\n**在步骤 $k$ 中构造 $w$ 和 $\\tau$ 的 FLOP 计数**\n\n在步骤 $k$ 中，我们对一个向量 $a \\in \\mathbb{R}^{m}$ 进行操作。根据问题陈述，Householder 向量 $w$ 和标量 $\\tau$ 的构造过程如下：\n1.  **计算 $\\|a\\|_{2}$**：这需要计算平方和 $\\sum_{i=1}^{m} a_i^2$。这涉及到 $m$ 次乘法 (用于计算平方 $a_i^2$) 和 $m-1$ 次加法。规定平方根操作的成本为 0 FLOPs。\n    计算 $\\|a\\|_2$ 的成本：$m + (m-1) = 2m-1$ FLOPs。\n2.  **构造 $w$**：向量 $w$ 是通过修改 $a$ 的第一个分量而形成的。假设 $w$ 用 $a$ 的值初始化，则具体的更新是 $w_1 := a_1 + \\operatorname{sign}(a_1)\\|a\\|_{2}$。问题明确指出此操作耗费 1 FLOP。\n    构造 $w$ 的成本：1 FLOP。\n3.  **计算 $w^{\\mathsf{T}}w$**：问题指示要“计算内积 $w^{\\mathsf{T}}w$”。这涉及到计算 $\\sum_{i=1}^{m} w_i^2$，需要 $m$ 次乘法和 $m-1$ 次加法。\n    计算 $w^{\\mathsf{T}}w$ 的成本：$m + (m-1) = 2m-1$ FLOPs。\n4.  **计算 $\\tau$**：标量 $\\tau$ 由 $\\tau = 2 / (w^{\\mathsf{T}}w)$ 给出。规定除法操作是免费的。\n    计算 $\\tau$ 的成本：0 FLOPs。\n\n构造 $w$ 和 $\\tau$ 的总 FLOP 计数是这些成本的总和：\n成本$_{w,\\tau}(m) = (2m-1) + 1 + (2m-1) = 4m-2$ FLOPs。\n\n**将更新应用于 $A^{(k)}$ 的 FLOP 计数**\n\n对称更新 $A^{(k)} \\leftarrow H A^{(k)} H$ 通过所提供的秩-2 更新公式执行：\n1.  **$y = A^{(k)} w$**：这是一个矩阵向量乘积，其中 $A^{(k)}$ 是一个对称的 $m \\times m$ 矩阵。一个标准的对称矩阵向量乘积的高效算法，只访问下（或上）三角元素，大约需要 $m^2$ 次乘法和 $m^2$ 次加法。更精确地说，它耗费 $2m^2$ FLOPs。\n    计算 $y$ 的成本：$2m^2$ FLOPs。\n2.  **$\\alpha = \\frac{\\tau}{2} w^{\\mathsf{T}} y$**：这涉及一个内积和一个标量乘法。\n    - 内积 $w^{\\mathsf{T}}y = \\sum_{i=1}^m w_i y_i$ 耗费 $m$ 次乘法和 $m-1$ 次加法，总计 $2m-1$ FLOPs。\n    - 将所得标量乘以 $\\frac{\\tau}{2}$ 耗费 1 FLOP。\n    计算 $\\alpha$ 的成本：$(2m-1) + 1 = 2m$ FLOPs。\n3.  **$y := y - \\alpha w$**：这是一个带缩放的向量加法 (AXPY 操作)。它涉及一次标量-向量乘法 ($\\alpha w$) 和一次向量减法。\n    - $\\alpha w$ 耗费 $m$ 次乘法。\n    - 减法耗费 $m$ 次加法。\n    更新 $y$ 的成本：$m+m=2m$ FLOPs。\n    为与原始的 $y=A^{(k)}w$ 相区分，我们将更新后的向量称为 $y_{new}$。\n4.  **$A^{(k)} := A^{(k)} - w y_{new}^{\\mathsf{T}} - y_{new} w^{\\mathsf{T}}$**：这是一个对称秩-2 更新。我们只更新 $A^{(k)}$ 的下三角部分，它有 $m(m+1)/2$ 个元素。\n    - 对于 $m$ 个对角元素中的每一个，更新为 $A_{ii} := A_{ii} - 2 w_i (y_{new})_i$。这耗费 1 次乘法用于 $w_i (y_{new})_i$，1 次乘法用于乘以 2，以及 1 次减法，总计 3 FLOPs。所有对角元素的总成本是 $3m$ FLOPs。\n    - 对于 $m(m-1)/2$ 个下三角非对角元素中的每一个，更新为 $A_{ij} := A_{ij} - w_i (y_{new})_j - w_j (y_{new})_i$。这耗费 2 次乘法和 2 次减法，总计 4 FLOPs。所有非对角元素的总成本是 $4 \\times \\frac{m(m-1)}{2} = 2m(m-1) = 2m^2 - 2m$ FLOPs。\n    更新 $A^{(k)}$ 的成本：$3m + (2m^2 - 2m) = 2m^2 + m$ FLOPs。\n\n应用更新的总 FLOP 计数是这些成本的总和：\n成本$_{apply}(m) = 2m^2 + 2m + 2m + (2m^2+m) = 4m^2+5m$ FLOPs。\n\n**每步总成本 $C_k$ 和总 FLOP 计数**\n\n单步 $k$ 的总成本 $C_k$ 是构造反射镜的成本和应用它的成本之和：\n$C_k(m) = \\text{成本}_{w,\\tau}(m) + \\text{成本}_{apply}(m) = (4m-2) + (4m^2+5m) = 4m^2 + 9m - 2$。\n\n为了找到总 FLOP 数，我们必须对所有步骤 $k=1, \\dots, n-2$ 的 $C_k$ 求和。这等价于对 $m=n-k$ 从 $m=n-1$ 递减到 $m=2$ 求和。\n总 FLOPs = $\\sum_{k=1}^{n-2} C_k = \\sum_{m=2}^{n-1} (4m^2 + 9m - 2)$。\n\n我们可以使用标准的幂和公式来计算这个和：$\\sum_{j=1}^{N} j = \\frac{N(N+1)}{2}$ 和 $\\sum_{j=1}^{N} j^2 = \\frac{N(N+1)(2N+1)}{6}$。\n总 FLOPs = $4\\sum_{m=2}^{n-1} m^2 + 9\\sum_{m=2}^{n-1} m - 2\\sum_{m=2}^{n-1} 1$。\n\n1.  $\\sum_{m=2}^{n-1} m^2 = \\left(\\sum_{m=1}^{n-1} m^2\\right) - 1^2 = \\frac{(n-1)n(2n-1)}{6} - 1$。\n2.  $\\sum_{m=2}^{n-1} m = \\left(\\sum_{m=1}^{n-1} m\\right) - 1 = \\frac{(n-1)n}{2} - 1$。\n3.  $\\sum_{m=2}^{n-1} 1 = (n-1) - 2 + 1 = n-2$。\n\n将这些代入总和中：\n总 FLOPs = $4\\left(\\frac{n(n-1)(2n-1)}{6} - 1\\right) + 9\\left(\\frac{n(n-1)}{2} - 1\\right) - 2(n-2)$\n$= \\frac{2}{3}n(n-1)(2n-1) - 4 + \\frac{9}{2}n(n-1) - 9 - 2(n-2)$\n$= \\frac{2}{3}(2n^3 - 3n^2 + n) - 4 + \\frac{9}{2}(n^2 - n) - 9 - 2n + 4$\n$= \\frac{4}{3}n^3 - 2n^2 + \\frac{2}{3}n + \\frac{9}{2}n^2 - \\frac{9}{2}n - 2n - 9$\n$= \\frac{4}{3}n^3 + \\left(-2 + \\frac{9}{2}\\right)n^2 + \\left(\\frac{2}{3} - \\frac{9}{2} - 2\\right)n - 9$\n$= \\frac{4}{3}n^3 + \\left(\\frac{-4+9}{2}\\right)n^2 + \\left(\\frac{4-27-12}{6}\\right)n - 9$\n$= \\frac{4}{3}n^3 + \\frac{5}{2}n^2 - \\frac{35}{6}n - 9$。\n\n这就是总 FLOP 数的最终简化闭式解析表达式。",
            "answer": "$$\\boxed{\\frac{4}{3}n^3 + \\frac{5}{2}n^2 - \\frac{35}{6}n - 9}$$"
        },
        {
            "introduction": "理论上的等价并不总意味着数值上的等价，在浮点运算中，一个看似微不足道的选择可能导致严重的误差。本练习  探讨了在构造 Householder 向量时选择符号这一关键决策，展示了“正确”的选择如何避免灾难性的相消误差。掌握这一点对于编写稳健、精确的数值代码至关重要。",
            "id": "2402000",
            "problem": "考虑实对称矩阵\n$$\nA(\\delta)=\n\\begin{pmatrix}\n2  1  \\delta  0\\\\\n1  3  0  0\\\\\n\\delta  0  4  0\\\\\n0  0  0  5\n\\end{pmatrix},\n$$\n其中 $\\delta0$ 是一个实数参数，且 $\\delta \\ll 1$。在 Householder 三对角化的第一步中，构造一个 Householder 反射矩阵 $H=I-2uu^{\\mathsf{T}}$ 作用于末尾的 $(n-1)$ 维子空间，以消去第一列对角线以下的元素。令 $x\\in\\mathbb{R}^{3}$ 表示由 $A(\\delta)$ 第一列中位于 $(1,1)$ 位置下方的元素构成的子向量，即 $x=A(\\delta)_{2:4,1}$。Householder 向量的一个标准构造方法是使用 $v=x\\pm \\alpha e_1$，其中 $\\alpha=\\|x\\|_2$ 且 $e_1=(1,0,0)^{\\mathsf{T}}$，然后进行归一化 $u=v/\\|v\\|_2$。在这里，两种符号的选择对应于两个代数上等价但在数值上不同的反射矩阵。\n\n定义 $v_{\\text{right}}=x+\\alpha e_1$ 和 $v_{\\text{wrong}}=x-\\alpha e_1$。计算下式的精确、闭式解析表达式：\n$$\n\\kappa(\\delta)=\\frac{\\left| \\left(v_{\\text{wrong}}\\right)_1 \\right|}{\\left| \\left(v_{\\text{right}}\\right)_1 \\right|},\n$$\n其中 $\\left(v\\right)_1$ 表示向量 $v$ 的第一个分量。你的最终答案必须是只含 $\\delta$ 的单个简化解析表达式，不得进行数值近似。",
            "solution": "所述问题具有科学依据，是适定的、客观的且自洽的。这是数值线性代数中关于构造 Householder 反射矩阵数值稳定性的一个标准练习。我们开始求解。\n\n给定矩阵为\n$$\nA(\\delta)=\n\\begin{pmatrix}\n2  1  \\delta  0\\\\\n1  3  0  0\\\\\n\\delta  0  4  0\\\\\n0  0  0  5\n\\end{pmatrix}\n$$\n其中 $\\delta  0$ 是一个实数参数。\n\nHouseholder 三对角化的第一步是针对矩阵的第一列。构造反射矩阵所需的向量 $x$ 是 $A(\\delta)$ 第一列中位于主对角线元素 $A(\\delta)_{1,1}$ 下方的子向量。$A(\\delta)$ 的第一列是 $(2, 1, \\delta, 0)^{\\mathsf{T}}$。因此，子向量 $x \\in \\mathbb{R}^3$ 由下式给出\n$$\nx = \\begin{pmatrix} 1 \\\\ \\delta \\\\ 0 \\end{pmatrix}.\n$$\nHouseholder 向量 $v$ 的构造基于 $v = x \\pm \\alpha e_1$，其中 $\\alpha = \\|x\\|_2$，而 $e_1$ 是 $\\mathbb{R}^3$ 中的第一个标准基向量，$e_1 = (1, 0, 0)^{\\mathsf{T}}$。首先，我们计算向量 $x$ 的欧几里得范数 $\\alpha$：\n$$\n\\alpha = \\|x\\|_2 = \\sqrt{1^2 + \\delta^2 + 0^2} = \\sqrt{1 + \\delta^2}.\n$$\n问题定义了两种可能的未归一化 Householder 向量：\n$$\nv_{\\text{right}} = x + \\alpha e_1\n$$\n$$\nv_{\\text{wrong}} = x - \\alpha e_1\n$$\n在数值算法中，标准的“正确”选择是使 $x \\pm \\alpha e_1$ 中的符号与 $x$ 的第一个分量的符号相同，以避免相消误差 (subtractive cancellation)。由于 $(x)_1 = 1  0$，因此数值上稳定的选择是 $v_{\\text{right}}$。问题要求计算一个涉及两种选择的比率。\n\n我们来显式地构造这些向量：\n$$\nv_{\\text{right}} = \\begin{pmatrix} 1 \\\\ \\delta \\\\ 0 \\end{pmatrix} + \\sqrt{1 + \\delta^2} \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 1 + \\sqrt{1 + \\delta^2} \\\\ \\delta \\\\ 0 \\end{pmatrix}\n$$\n$$\nv_{\\text{wrong}} = \\begin{pmatrix} 1 \\\\ \\delta \\\\ 0 \\end{pmatrix} - \\sqrt{1 + \\delta^2} \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 1 - \\sqrt{1 + \\delta^2} \\\\ \\delta \\\\ 0 \\end{pmatrix}\n$$\n我们需要计算比率 $\\kappa(\\delta)$，其定义为\n$$\n\\kappa(\\delta)=\\frac{\\left| \\left(v_{\\text{wrong}}\\right)_1 \\right|}{\\left| \\left(v_{\\text{right}}\\right)_1 \\right|}.\n$$\n第一个分量分别是 $(v_{\\text{right}})_1 = 1 + \\sqrt{1 + \\delta^2}$ 和 $(v_{\\text{wrong}})_1 = 1 - \\sqrt{1 + \\delta^2}$。\n\n我们计算这些分量的绝对值。因为 $\\delta  0$，我们有 $\\delta^2  0$，这意味着 $1 + \\delta^2  1$，因此 $\\sqrt{1 + \\delta^2}  1$。\n项 $(v_{\\text{right}})_1 = 1 + \\sqrt{1 + \\delta^2}$ 是严格为正的，所以其绝对值就是它本身：\n$$\n\\left| \\left(v_{\\text{right}}\\right)_1 \\right| = 1 + \\sqrt{1 + \\delta^2}.\n$$\n项 $(v_{\\text{wrong}})_1 = 1 - \\sqrt{1 + \\delta^2}$ 是严格为负的。其绝对值是该项的相反数：\n$$\n\\left| \\left(v_{\\text{wrong}}\\right)_1 \\right| = - (1 - \\sqrt{1 + \\delta^2}) = \\sqrt{1 + \\delta^2} - 1.\n$$\n现在，我们可以写出 $\\kappa(\\delta)$ 的表达式：\n$$\n\\kappa(\\delta) = \\frac{\\sqrt{1 + \\delta^2} - 1}{\\sqrt{1 + \\delta^2} + 1}.\n$$\n这个表达式是正确的，但可以进一步简化，特别是为了获得一个在 $\\delta$ 很小（如 $\\delta \\ll 1$ 所暗示的）时进行数值计算更为稳健的形式。这可以通过分子有理化来实现。我们将分子和分母同乘以分子的共轭项，即 $(\\sqrt{1 + \\delta^2} + 1)$：\n$$\n\\kappa(\\delta) = \\left( \\frac{\\sqrt{1 + \\delta^2} - 1}{\\sqrt{1 + \\delta^2} + 1} \\right) \\times \\left( \\frac{\\sqrt{1 + \\delta^2} + 1}{\\sqrt{1 + \\delta^2} + 1} \\right).\n$$\n分子简化为平方差：\n$$\n(\\sqrt{1 + \\delta^2} - 1)(\\sqrt{1 + \\delta^2} + 1) = (\\sqrt{1 + \\delta^2})^2 - 1^2 = (1 + \\delta^2) - 1 = \\delta^2.\n$$\n分母变为一个平方：\n$$\n(\\sqrt{1 + \\delta^2} + 1)(\\sqrt{1 + \\delta^2} + 1) = (\\sqrt{1 + \\delta^2} + 1)^2.\n$$\n结合这些结果，得到 $\\kappa(\\delta)$ 的最终简化闭式表达式：\n$$\n\\kappa(\\delta) = \\frac{\\delta^2}{(\\sqrt{1 + \\delta^2} + 1)^2}.\n$$\n这种形式避免了中间表达式分子中存在的相消误差，这也是区分 $v_{\\text{right}}$ 和 $v_{\\text{wrong}}$ 的全部意义所在。",
            "answer": "$$\\boxed{\\frac{\\delta^2}{\\left(\\sqrt{1 + \\delta^2} + 1\\right)^2}}$$"
        },
        {
            "introduction": "理解一个算法的最终检验是亲手实现它。这个动手编程练习  将挑战你从零开始构建 Householder 三角化算法，并在实际中检验其数值特性。通过构造具有已知特征值的矩阵，并将其与最终得到的三角矩阵的特征值进行比较，你将能够直观地洞察这一基石算法在有限精度算术环境下的优美特性与实际限制。",
            "id": "3572312",
            "problem": "考虑一个实对称矩阵 $A \\in \\mathbb{R}^{n \\times n}$。线性代数中的一个基本事实是，正交相似变换保持谱不变：如果 $Q \\in \\mathbb{R}^{n \\times n}$ 是正交矩阵，那么 $Q^\\top A Q$ 与 $A$ 具有相同的特征值多重集。一个经过充分测试的将对称矩阵约化为三对角形式的算法是 Householder 变换方法。该方法构造一系列对称正交反射器，将第一副对角线下方的元素置零，从而得到一个三对角矩阵 $T$ 和一个累积的正交矩阵 $Q$，使得 $Q^\\top A Q = T$。作用于向量 $x \\in \\mathbb{R}^m$ 的 Householder 反射器使用 $v = \\dfrac{x - \\alpha e_1}{\\lVert x - \\alpha e_1 \\rVert_2}$（其中 $\\alpha = -\\operatorname{sign}(x_1)\\lVert x \\rVert_2$）和 $H = I_m - 2 v v^\\top$ 将 $x$ 映射到 $\\alpha e_1$。\n\n在浮点运算中，计算出的量会受到舍入误差的影响。$T$ 和 $A$ 的观测特征值可能会表现出微小的差异，因为计算得到的 $Q$ 和 $T$ 对应于一个邻近的矩阵 $A + E$，其中 $E$ 是由舍入引起的微小扰动。您的任务是，从第一性原理出发，实现对称矩阵的 Householder 三对角化，构造具有已知特征结构的测试矩阵，并量化由舍入引起的谱差异。\n\n实现一个程序，该程序：\n- 为每个测试用例构造一个确定性的正交矩阵 $V \\in \\mathbb{R}^{n \\times n}$ 和一个具有指定特征值的对角矩阵 $\\Lambda = \\operatorname{diag}(\\lambda_1,\\dots,\\lambda_n)$，然后构成对称矩阵 $A = V \\Lambda V^\\top$。其特征结构是构造已知的：$A$ 的特征值为 $\\{\\lambda_i\\}_{i=1}^n$，特征向量由 $V$ 的列向量给出。\n- 使用 Householder 反射器将 $A$ 约化为三对角形式：计算 $Q$ 和 $T$ 使得 $Q^\\top A Q = T$，其中 $T$ 是实对称三对角矩阵，$Q$ 是正交矩阵。\n- 为每个测试用例计算以下量化输出：\n  1. $d_{AT} = \\max_i \\left| \\mu_i(T) - \\mu_i(A) \\right|$，其中 $\\{\\mu_i(\\cdot)\\}$ 是指定矩阵的特征值，按非递减顺序排序。这量化了由于舍入引起的 $T$ 和 $A$ 的谱之间的差异。\n  2. $d_{A,\\Lambda} = \\max_i \\left| \\mu_i(A) - \\lambda_i \\right|$，其中两个序列都按非递减顺序排序。这量化了 $A$ 的数值计算特征值与构造时使用的已知特征值之间的差异。\n  3. $e_{\\text{orth}} = \\lVert Q^\\top Q - I_n \\rVert_F$，即与正交性的偏离的弗罗贝尼乌斯范数。\n  4. $e_{\\text{sim}} = \\lVert Q^\\top A Q - T \\rVert_F$，即衡量相似变换残差的弗罗贝尼乌斯范数。\n所有范数分别是标准的欧几里得范数和弗罗贝尼乌斯范数。\n\n所有计算均使用双精度浮点算术。不涉及角度，因此无需指定角度单位。不涉及物理单位。所有数值输出均表示为标准实数。\n\n用于覆盖一般和边缘场景的测试套件：\n- 情况1（一般良态）：$n = 5$，特征值 $\\lambda = [1, 2, 3, 4, 5]$。\n- 情况2（近乎重复的特征值）：$n = 8$，特征值 $\\lambda = [1, 1 + 10^{-12}, 2, 2 + 10^{-12}, 3, 3 + 10^{-12}, 4, 4 + 10^{-12}]$。\n- 情况3（大动态范围）：$n = 10$，特征值 $\\lambda = [10^{-8}, 10^{-6}, 10^{-4}, 10^{-2}, 1, 10, 10^{3}, 10^{5}, 10^{7}, 10^{9}]$。\n- 情况4（小维度边界）：$n = 2$，特征值 $\\lambda = [1, 10^{-15}]$。\n- 情况5（平凡边界）：$n = 1$，特征值 $\\lambda = [42]$。\n\n确定性正交基构造要求：对于每个 $n$，通过取矩阵 $M \\in \\mathbb{R}^{n \\times n}$（其元素为 $M_{ij} = \\sin((i+1)(j+1)) + \\cos((i+1) - 0.3(j+1)) + 0.5 \\cdot \\delta_{ij}$）来构造 $V$，对其进行完全列正交化（例如，通过标准的QR分解）以获得 $M = QR$（其中 $Q$ 是正交的），然后如果 $\\det(Q)  0$，则翻转 $Q$ 的第一列的符号以确保右手定向。使用这个 $Q$ 作为 $V$。\n\n最终输出格式规范：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个元素对应一个测试用例的结果，而每个结果本身是按 $[d_{AT}, d_{A,\\Lambda}, e_{\\text{orth}}, e_{\\text{sim}}]$ 顺序排列的四个实数的列表。例如，输出应类似于 $[[x_1, y_1, z_1, w_1],[x_2, y_2, z_2, w_2],\\dots]$，不带任何附加文本。\n\n程序必须是自包含的，不需要用户输入，并遵循指定的运行时环境。",
            "solution": "用户提供的问题是数值线性代数中一个明确定义的任务。它要求实现实对称矩阵的 Householder 三对角化算法，并随后对浮点计算中固有的数值误差进行定量分析。该问题在科学上是合理的、自包含的且客观的。它指定了算法、测试矩阵的构造、要计算的精确度量以及输出格式。因此，该问题是有效的，我将着手提供完整解答。\n\n### 原理与方法论\n\n问题的核心是使用正交变换 $Q$ 将一个实对称矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 约化为一个相似的三对角矩阵 $T$，使得 $T = Q^\\top A Q$。理论上，$T$ 的特征值与 $A$ 的特征值完全相同。然而，在实践中，浮点运算会引入微小的误差。本练习旨在实现这一约化过程并量化这些误差。\n\n该方法论包括三个主要阶段：\n1.  构造一个具有已知特征结构的测试矩阵 $A$。\n2.  应用 Householder 三对角化算法以获得 $T$ 和 $Q$。\n3.  计算误差度量以评估实现的准确性和稳定性。\n\n#### 1. 测试矩阵的构造\n\n为了创建一个可验证的测试用例，我们构造一个具有已知特征值集合 $\\{\\lambda_i\\}_{i=1}^n$ 的对称矩阵 $A$。这是通过指定一个对角矩阵 $\\Lambda = \\operatorname{diag}(\\lambda_1, \\dots, \\lambda_n)$ 和一个确定性的正交矩阵 $V \\in \\mathbb{R}^{n \\times n}$ 来实现的。然后通过相似变换 $A = V \\Lambda V^\\top$ 形成矩阵 $A$。根据相似变换的性质，$A$ 的特征值恰好是 $\\Lambda$ 的对角元素，而 $V$ 的列是相应的特征向量。\n\n正交矩阵 $V$ 的确定性构造如下：\n- 对于给定的维度 $n$，生成一个矩阵 $M \\in \\mathbb{R}^{n \\times n}$，其元素为 $M_{ij} = \\sin((i+1)(j+1)) + \\cos((i+1) - 0.3(j+1)) + 0.5 \\delta_{ij}$，其中索引 $i, j$ 的范围从 $0$ 到 $n-1$，$\\delta_{ij}$ 是克罗内克δ函数。\n- 对 $M$ 执行 QR 分解，得到 $M = QR_M$，其中 $Q$ 是正交矩阵，$R_M$ 是上三角矩阵。这个 $Q$ 构成了我们的初始正交基。\n- 为确保一致的定向，我们检查 $Q$ 的行列式。如果 $\\det(Q)  0$，则翻转 $Q$ 的第一列的符号。这个最终的正交矩阵用作 $V$。\n\n#### 2. Householder 三对角化\n\n将 $A$ 约化为三对角矩阵 $T$ 是迭代执行的。该过程包括 $n-2$ 步。在第 $k$ 步（对于 $k=0, 1, \\dots, n-3$），我们在矩阵的第 $k$ 列和第 $k$ 行中，分别在副对角线/超对角线元素的下方和右侧引入零。\n\n这是通过使用 Householder 反射器实现的。Householder 反射器是一个正交、对称的矩阵 $P = I - 2vv^\\top$，其中 $v$ 是一个单位向量。它将一个向量反射到与 $v$ 正交的超平面上。\n\n在第 $k$ 步，我们考虑由元素 $A_{k+1:n, k}$ 组成的向量 $x \\in \\mathbb{R}^{n-k-1}$。我们构造一个反射器 $P_k$，它将 $x$ 映射到第一个标准基向量的倍数，即 $P_k x = \\alpha e_1$。这将除了 $x$ 的第一个元素之外的所有元素都置为零。反射器的参数是：\n- $\\alpha = -\\operatorname{sign}(x_1) \\lVert x \\rVert_2$。选择这个符号是为了在计算 $x - \\alpha e_1$ 时避免灾难性抵消。我们采用约定 $\\operatorname{sign}(0) = 1$。\n- Householder 向量是 $v = \\frac{x - \\alpha e_1}{\\lVert x - \\alpha e_1 \\rVert_2}$。\n\n反射器 $P_k$ 是一个 $(n-k-1) \\times (n-k-1)$ 的矩阵。为了将其应用于整个 $n \\times n$ 矩阵 $A$，它被嵌入到一个 $n \\times n$ 的单位矩阵中，形成 $Q_k = \\begin{pmatrix} I_k  0 \\\\ 0  P_k \\end{pmatrix}$。然后通过相似变换更新矩阵：$A \\to Q_k A Q_k$。对 $k=0, \\dots, n-3$ 重复此过程。\n\n总的正交变换是各个反射器的乘积：$Q = Q_0 Q_1 \\dots Q_{n-3}$。最终的三对角矩阵是 $T = Q^\\top A Q$。\n\n每一步对 $A$ 和 $Q$ 的更新必须高效地执行，而无需显式地构造大的矩阵 $Q_k$。\n- **更新A：** 变换 $A \\to Q_k A Q_k$ 等价于 $A \\to (I-2\\hat{v}\\hat{v}^\\top) A (I-2\\hat{v}\\hat{v}^\\top)$，其中 $\\hat{v}$ 是在向量 $v$ 前面填充 $k+1$ 个零得到的向量。这个更新可以高效地计算为 $A \\to A - 2(w\\hat{v}^\\top + \\hat{v}w^\\top)$，其中 $w = p - (\\hat{v}^\\top p)\\hat{v}$ 且 $p=A\\hat{v}$。\n- **累积Q：** 总变换 $Q$ 初始化为 $I_n$。在每一步，它通过 $Q \\to Q Q_k$ 进行更新。这可以计算为 $Q \\to Q - 2(Q\\hat{v})\\hat{v}^\\top$。\n\n#### 3. 误差量化\n\n三对角化之后，我们计算四个度量来量化数值误差：\n1.  $d_{AT} = \\max_i \\left| \\mu_i(T) - \\mu_i(A) \\right|$：计算得到的三对角矩阵 $T$ 的排序特征值与原始矩阵 $A$ 的排序特征值（数值计算得出）之间的最大绝对差。这衡量了三对角化过程引起的谱漂移。\n2.  $d_{A,\\Lambda} = \\max_i \\left| \\mu_i(A) - \\lambda_i \\right|$：$A$ 的数值计算排序特征值与指定的排序特征值 $\\lambda_i$ 之间的最大绝对差。这衡量了从已知特征结构构造 $A$ 时引入的误差。\n3.  $e_{\\text{orth}} = \\lVert Q^\\top Q - I_n \\rVert_F$：累积变换矩阵 $Q$ 与完美正交性偏差的弗罗贝尼乌斯范数。\n4.  $e_{\\text{sim}} = \\lVert Q^\\top A Q - T \\rVert_F$：相似变换残差的弗罗贝尼乌斯范数。这衡量了计算得到的 $T$ 和 $Q$ 满足方程 $T=Q^\\top A Q$ 的程度。\n\n这些度量全面地反映了所实现算法的数值质量。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the Householder tridiagonalization tests and print results.\n    \"\"\"\n\n    # Test suite as defined in the problem statement\n    test_cases = [\n        (5, np.array([1, 2, 3, 4, 5], dtype=float)),\n        (8, np.array([1, 1 + 1e-12, 2, 2 + 1e-12, 3, 3 + 1e-12, 4, 4 + 1e-12], dtype=float)),\n        (10, np.array([1e-8, 1e-6, 1e-4, 1e-2, 1, 10, 1e3, 1e5, 1e7, 1e9], dtype=float)),\n        (2, np.array([1, 1e-15], dtype=float)),\n        (1, np.array([42], dtype=float))\n    ]\n\n    results = []\n    \n    for n, lambdas in test_cases:\n        # 1. CONSTRUCT THE TEST MATRIX A\n        # Deterministically construct the orthogonal matrix V\n        i_ = np.arange(1, n + 1)\n        j_ = np.arange(1, n + 1)\n        I, J = np.meshgrid(i_, j_, indexing='ij')\n        M = np.sin(I * J) + np.cos(I - 0.3 * J) + 0.5 * np.identity(n)\n        \n        V, _ = np.linalg.qr(M)\n        if np.linalg.det(V)  0:\n            V[:, 0] *= -1\n            \n        Lambda_diag = np.diag(lambdas)\n        A = V @ Lambda_diag @ V.T\n\n        # 2. HOUSEHOLDER TRIDIAGONALIZATION\n        T = A.copy()\n        Q = np.identity(n, dtype=float)\n\n        for k in range(n - 2):\n            # Define the vector x to be annihilated\n            x = T[k + 1:, k]\n            x_norm = np.linalg.norm(x)\n\n            # Skip if the sub-column is already zero\n            if x_norm  np.finfo(float).eps:\n                continue\n\n            # Numerically stable choice for alpha\n            sign_x0 = np.copysign(1.0, x[0]) if x.size > 0 else 1.0\n            alpha = -sign_x0 * x_norm\n\n            # Construct the Householder vector v\n            u = x.copy()\n            u[0] -= alpha\n            u_norm = np.linalg.norm(u)\n            \n            if u_norm  np.finfo(float).eps:\n                continue\n\n            v_sub = u / u_norm\n            \n            # Embed v into a full-size vector\n            v_full = np.zeros(n, dtype=float)\n            v_full[k + 1:] = v_sub\n\n            # Efficiently update T and Q\n            # Update T -> H T H = T - 2(w v^T + v w^T) where w = p - (v^T p)v, p = Tv\n            p = T @ v_full\n            w = p - np.dot(p, v_full) * v_full\n            T -= 2 * (np.outer(w, v_full) + np.outer(v_full, w))\n\n            # Update Q -> Q H = Q - 2(Qv)v^T\n            Q -= 2 * np.outer(Q @ v_full, v_full)\n\n        # Clean T to be perfectly tridiagonal by zeroing out rounding errors\n        T_clean = np.triu(np.tril(T, 1), -1)\n\n        # 3. COMPUTE QUANTITATIVE OUTPUTS\n        # Eigenvalues must be sorted for comparison\n        lambda_known_sorted = np.sort(lambdas)\n        mu_A_sorted = np.sort(np.linalg.eigvalsh(A))\n        mu_T_sorted = np.sort(np.linalg.eigvalsh(T_clean))\n\n        # d_AT: Difference between eigenvalues of T and A\n        d_AT = np.max(np.abs(mu_T_sorted - mu_A_sorted))\n        \n        # d_A,Lambda: Difference between computed eigenvalues of A and known eigenvalues\n        d_A_Lambda = np.max(np.abs(mu_A_sorted - lambda_known_sorted))\n        \n        # e_orth: Orthogonality error of Q\n        e_orth = np.linalg.norm(Q.T @ Q - np.identity(n), 'fro')\n        \n        # e_sim: Similarity transformation residual\n        e_sim = np.linalg.norm(Q.T @ A @ Q - T_clean, 'fro')\n\n        results.append([d_AT, d_A_Lambda, e_orth, e_sim])\n\n    # Final print statement in the exact required format\n    # Using str.replace to remove spaces for compact output matching the spec\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```"
        }
    ]
}