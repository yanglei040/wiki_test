{
    "hands_on_practices": [
        {
            "introduction": "在深入探讨标准的Householder三对角化算法细节之前，理解其为何被设计为一系列结构化变换至关重要。本练习将通过一个具体的反例，演示“填充”（fill-in）现象：即对稀疏矩阵应用一个朴素的、稠密的相似变换会如何破坏其结构。通过亲手计算一个特定的非对角元素，你将直观地理解为何保持矩阵的稀疏性是该算法设计的首要考虑之一，从而领会标准算法中逐次消元的精妙之处。",
            "id": "3572243",
            "problem": "设 $n \\geq 4$ 并考虑对称三对角矩阵 $A \\in \\mathbb{R}^{n \\times n}$，其定义为 $A_{i,i} = i$（$1 \\leq i \\leq n$），$A_{i,i+1} = A_{i+1,i} = 1$（$1 \\leq i \\leq n-1$），以及其他情况下的 $A_{i,j} = 0$。设 $v \\in \\mathbb{R}^{n}$ 是一个各项元素均相同的单位向量，$v = \\frac{1}{\\sqrt{n}} (1,1,\\dots,1)^{\\mathsf{T}}$，并设 $H = I - 2 v v^{\\mathsf{T}}$ 为 Householder 反射矩阵。考虑朴素的双边相似变换 $B = H A H$。\n\n从 Householder 反射矩阵和三对角矩阵的定义出发，推导元素 $B_{1,n}$ 的精确值，该元素位于 $A$ 的原始三对角带之外很远的位置。请以关于 $n$ 的封闭形式表达式给出最终答案。无需四舍五入。",
            "solution": "首先根据指定准则对问题进行验证。\n\n### 步骤 1：提取已知条件\n- $n \\in \\mathbb{Z}$ 且 $n \\geq 4$。\n- $A \\in \\mathbb{R}^{n \\times n}$ 是一个对称三对角矩阵。\n- $A$ 的元素定义如下：\n  - $A_{i,i} = i$（$1 \\leq i \\leq n$）。\n  - $A_{i,i+1} = A_{i+1,i} = 1$（$1 \\leq i \\leq n-1$）。\n  - $A_{i,j} = 0$（$|i-j| > 1$）。\n- $v \\in \\mathbb{R}^{n}$ 是向量 $v = \\frac{1}{\\sqrt{n}} (1,1,\\dots,1)^{\\mathsf{T}}$。\n- $H$ 是由 $H = I - 2 v v^{\\mathsf{T}}$ 定义的 Householder 反射矩阵。\n- $B$ 是相似变换 $B = H A H$ 得到的矩阵。\n- 目标是求出元素 $B_{1,n}$ 的值。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题是一个定义明确的线性代数练习。\n- **科学依据**：对称三对角矩阵、Householder 反射矩阵和相似变换的定义都是标准的、数学上严格的。所定义的向量 $v$ 是一个单位向量，因为 $\\|v\\|^2_2 = \\sum_{i=1}^n (\\frac{1}{\\sqrt{n}})^2 = \\sum_{i=1}^n \\frac{1}{n} = 1$。该问题在数学上是合理的。\n- **适定性**：矩阵 $B$ 由 $A$ 和 $H$ 的定义唯一确定。因此，它的元素（包括 $B_{1,n}$）也是唯一确定的。该问题要求一个具体、可计算的量。\n- **客观性**：该问题使用精确的数学语言陈述，没有任何主观性或模糊性。\n经判定，该问题是完整的、一致的且可形式化的。\n\n### 步骤 3：结论与行动\n该问题有效。将提供完整的解答。\n\n### $B_{1,n}$ 的推导\n矩阵 $B$ 由相似变换 $B = HAH$ 给出。代入 Householder 矩阵的定义 $H = I - 2vv^{\\mathsf{T}}$，我们得到：\n$$B = (I - 2vv^{\\mathsf{T}})A(I - 2vv^{\\mathsf{T}})$$\n展开此乘积可得：\n$$B = IAI - 2IAvv^{\\mathsf{T}} - 2vv^{\\mathsf{T}}AI + (-2vv^{\\mathsf{T}})(-2Avv^{\\mathsf{T}})$$\n$$B = A - 2Avv^{\\mathsf{T}} - 2vv^{\\mathsf{T}}A + 4(vv^{\\mathsf{T}})A(vv^{\\mathsf{T}})$$\n由于 $v^{\\mathsf{T}}A v$ 是一个标量，我们可以写成 $(vv^{\\mathsf{T}})A(vv^{\\mathsf{T}}) = v(v^{\\mathsf{T}}Av)v^{\\mathsf{T}} = (v^{\\mathsf{T}}Av)vv^{\\mathsf{T}}$。\n$$B = A - 2Avv^{\\mathsf{T}} - 2vv^{\\mathsf{T}}A + 4(v^{\\mathsf{T}}Av)vv^{\\mathsf{T}}$$\n我们想要求解元素 $B_{1,n}$，它可以用标准基向量 $e_1 = (1,0,\\dots,0)^{\\mathsf{T}}$ 和 $e_n = (0,\\dots,0,1)^{\\mathsf{T}}$ 表示为 $B_{1,n} = e_1^{\\mathsf{T}} B e_n$。\n$$B_{1,n} = e_1^{\\mathsf{T}} A e_n - 2e_1^{\\mathsf{T}} A v v^{\\mathsf{T}} e_n - 2e_1^{\\mathsf{T}} v v^{\\mathsf{T}} A e_n + 4(v^{\\mathsf{T}}Av) e_1^{\\mathsf{T}} v v^{\\mathsf{T}} e_n$$\n利用矩阵乘法的结合律，我们可以对标量项进行分组：\n$$B_{1,n} = A_{1,n} - 2(e_1^{\\mathsf{T}}Av)(v^{\\mathsf{T}}e_n) - 2(e_1^{\\mathsf{T}}v)(v^{\\mathsf{T}}Ae_n) + 4(e_1^{\\mathsf{T}}v)(v^{\\mathsf{T}}e_n)(v^{\\mathsf{T}}Av)$$\n我们现在计算这个表达式的每个组成部分。\n\n1.  $A_{1,n}$：由于 $A$ 是一个三对角矩阵，且问题说明 $n \\geq 4$，我们有 $|1-n| = n-1 \\geq 3$。元素 $(1,n)$ 位于三对角带之外，因此 $A_{1,n} = 0$。\n\n2.  $e_1^{\\mathsf{T}}v$ 和 $v^{\\mathsf{T}}e_n$：向量 $v$ 由 $v_i = \\frac{1}{\\sqrt{n}}$ (对于所有 $i \\in \\{1, \\dots, n\\}$) 给出。\n    $$e_1^{\\mathsf{T}}v = v_1 = \\frac{1}{\\sqrt{n}}$$\n    $$v^{\\mathsf{T}}e_n = v_n = \\frac{1}{\\sqrt{n}}$$\n\n3.  $e_1^{\\mathsf{T}}Av$：此项是 $A$ 的第一行与向量 $v$ 的乘积。$A$ 的第一行由 $(A_{1,1}, A_{1,2}, 0, ..., 0) = (1, 1, 0, ..., 0)$ 给出。\n    $$e_1^{\\mathsf{T}}Av = (e_1^{\\mathsf{T}}A)v = (1, 1, 0, \\dots, 0) \\begin{pmatrix} 1/\\sqrt{n} \\\\ 1/\\sqrt{n} \\\\ \\vdots \\\\ 1/\\sqrt{n} \\end{pmatrix} = 1 \\cdot \\frac{1}{\\sqrt{n}} + 1 \\cdot \\frac{1}{\\sqrt{n}} = \\frac{2}{\\sqrt{n}}$$\n\n4.  $v^{\\mathsf{T}}Ae_n$：此项是 $v^{\\mathsf{T}}$ 与 $A$ 的第 $n$ 列的乘积。$A$ 的第 $n$ 列由 $(0, ..., 0, A_{n-1,n}, A_{n,n})^{\\mathsf{T}} = (0, ..., 0, 1, n)^{\\mathsf{T}}$ 给出。\n    $$v^{\\mathsf{T}}Ae_n = v^{\\mathsf{T}}(Ae_n) = (\\frac{1}{\\sqrt{n}}, \\dots, \\frac{1}{\\sqrt{n}}) \\begin{pmatrix} 0 \\\\ \\vdots \\\\ 0 \\\\ 1 \\\\ n \\end{pmatrix} = \\frac{1}{\\sqrt{n}} \\cdot 1 + \\frac{1}{\\sqrt{n}} \\cdot n = \\frac{n+1}{\\sqrt{n}}$$\n\n5.  $v^{\\mathsf{T}}Av$：这是一个瑞利商。设 $\\mathbf{1}$ 是全 1 向量，则 $v = \\frac{1}{\\sqrt{n}}\\mathbf{1}$。那么 $v^{\\mathsf{T}}Av = (\\frac{1}{\\sqrt{n}}\\mathbf{1}^{\\mathsf{T}})A(\\frac{1}{\\sqrt{n}}\\mathbf{1}) = \\frac{1}{n} \\mathbf{1}^{\\mathsf{T}}A\\mathbf{1}$。项 $\\mathbf{1}^{\\mathsf{T}}A\\mathbf{1}$ 是矩阵 $A$ 中所有元素的总和。我们可以通过对角线元素和非对角线元素求和来计算这个总和。\n    对角线元素之和：$\\sum_{i=1}^n A_{i,i} = \\sum_{i=1}^n i = \\frac{n(n+1)}{2}$。\n    非对角线元素之和：主对角线上方有 $n-1$ 个等于 $1$ 的元素，主对角线下方有 $n-1$ 个等于 $1$ 的元素。总和为 $2(n-1)$。\n    所有元素之和：$\\mathbf{1}^{\\mathsf{T}}A\\mathbf{1} = \\frac{n(n+1)}{2} + 2(n-1) = \\frac{n^2+n+4n-4}{2} = \\frac{n^2+5n-4}{2}$。\n    因此，\n    $$v^{\\mathsf{T}}Av = \\frac{1}{n} \\left( \\frac{n^2+5n-4}{2} \\right) = \\frac{n^2+5n-4}{2n}$$\n\n现在我们将这些值代回 $B_{1,n}$ 的表达式中：\n$$B_{1,n} = 0 - 2\\left(\\frac{2}{\\sqrt{n}}\\right)\\left(\\frac{1}{\\sqrt{n}}\\right) - 2\\left(\\frac{1}{\\sqrt{n}}\\right)\\left(\\frac{n+1}{\\sqrt{n}}\\right) + 4\\left(\\frac{n^2+5n-4}{2n}\\right)\\left(\\frac{1}{\\sqrt{n}}\\right)\\left(\\frac{1}{\\sqrt{n}}\\right)$$\n$$B_{1,n} = -2\\left(\\frac{2}{n}\\right) - 2\\left(\\frac{n+1}{n}\\right) + 4\\left(\\frac{n^2+5n-4}{2n}\\right)\\left(\\frac{1}{n}\\right)$$\n$$B_{1,n} = -\\frac{4}{n} - \\frac{2n+2}{n} + \\frac{2(n^2+5n-4)}{n^2}$$\n合并前两项：\n$$B_{1,n} = \\frac{-4 - 2n - 2}{n} + \\frac{2n^2+10n-8}{n^2} = \\frac{-2n-6}{n} + \\frac{2n^2+10n-8}{n^2}$$\n通分到共同分母 $n^2$：\n$$B_{1,n} = \\frac{n(-2n-6)}{n^2} + \\frac{2n^2+10n-8}{n^2}$$\n$$B_{1,n} = \\frac{-2n^2-6n + 2n^2+10n-8}{n^2}$$\n$$B_{1,n} = \\frac{4n-8}{n^2}$$\n\n这个表达式给出了元素 $B_{1,n}$ 作为 $n$ 的函数的精确值。这种使用稠密反射矩阵的相似变换在稀疏矩阵的对角线远处创建非零元素的效果，被称为填充（fill-in）。",
            "answer": "$$\\boxed{\\frac{4n-8}{n^2}}$$"
        },
        {
            "introduction": "一个稳健的数值算法不仅要保证理论上的正确性，还必须能在浮点运算的舍入误差面前保持稳定。Householder向量的构造包含一个关键的符号选择，其目的是为了避免“灾难性抵消”（subtractive cancellation）这一常见的数值不稳定源头。本练习  将引导你分析在一个包含微小参数的特定情境下，两种不同符号选择所带来的差异，通过量化比较，你将深刻理解为何一种选择是数值上“正确”的，而另一种则是“错误”的。",
            "id": "2402000",
            "problem": "考虑实对称矩阵\n$$\nA(\\delta)=\n\\begin{pmatrix}\n2  1  \\delta  0\\\\\n1  3  0  0\\\\\n\\delta  0  4  0\\\\\n0  0  0  5\n\\end{pmatrix},\n$$\n其中 $\\delta>0$ 是一个实数参数，且 $\\delta \\ll 1$。在 Householder 三对角化的第一步中，构造一个 Householder 反射矩阵 $H=I-2uu^{\\mathsf{T}}$ 作用于尾部的 $(n-1)$ 维子空间，以消去第一列对角线下方的元素。令 $x\\in\\mathbb{R}^{3}$ 表示由 $A(\\delta)$ 第一列中 $(1,1)$ 位置下方的元素构成的子向量，即 $x=A(\\delta)_{2:4,1}$。Householder 向量的标准构造方法是使用 $v=x\\pm \\alpha e_1$，其中 $\\alpha=\\|x\\|_2$ 且 $e_1=(1,0,0)^{\\mathsf{T}}$，然后进行归一化 $u=v/\\|v\\|_2$。在这里，两种符号的选择对应于两个代数上等价但在数值上不同的反射矩阵。\n\n定义 $v_{\\text{right}}=x+\\alpha e_1$ 和 $v_{\\text{wrong}}=x-\\alpha e_1$。计算\n$$\n\\kappa(\\delta)=\\frac{\\left| \\left(v_{\\text{wrong}}\\right)_1 \\right|}{\\left| \\left(v_{\\text{right}}\\right)_1 \\right|}\n$$\n的精确、闭式解析表达式，其中 $\\left(v\\right)_1$ 表示向量 $v$ 的第一个分量。你的最终答案必须是只含 $\\delta$ 的单个简化解析表达式，不得进行数值近似。",
            "solution": "该问题陈述科学严谨、定义明确、客观且自成体系。这是数值线性代数中一个关于构造 Householder 反射矩阵数值稳定性的标准练习。我们开始求解。\n\n给定的矩阵是\n$$\nA(\\delta)=\n\\begin{pmatrix}\n2  1  \\delta  0\\\\\n1  3  0  0\\\\\n\\delta  0  4  0\\\\\n0  0  0  5\n\\end{pmatrix}\n$$\n其中 $\\delta > 0$ 是一个实数参数。\n\nHouseholder 三对角化的第一步是针对矩阵的第一列。构造反射矩阵所需的向量 $x$ 是 $A(\\delta)$ 第一列中位于主对角线元素 $A(\\delta)_{1,1}$ 下方的子向量。$A(\\delta)$ 的第一列是 $(2, 1, \\delta, 0)^{\\mathsf{T}}$。因此，子向量 $x \\in \\mathbb{R}^3$ 由下式给出\n$$\nx = \\begin{pmatrix} 1 \\\\ \\delta \\\\ 0 \\end{pmatrix}.\n$$\nHouseholder 向量 $v$ 的构造基于 $v = x \\pm \\alpha e_1$，其中 $\\alpha = \\|x\\|_2$ 且 $e_1$ 是 $\\mathbb{R}^3$ 中的第一个标准基向量，$e_1 = (1, 0, 0)^{\\mathsf{T}}$。首先，我们计算向量 $x$ 的欧几里得范数 $\\alpha$：\n$$\n\\alpha = \\|x\\|_2 = \\sqrt{1^2 + \\delta^2 + 0^2} = \\sqrt{1 + \\delta^2}.\n$$\n问题定义了未归一化的 Householder 向量的两种可能选择：\n$$\nv_{\\text{right}} = x + \\alpha e_1\n$$\n$$\nv_{\\text{wrong}} = x - \\alpha e_1\n$$\n在数值算法中，标准的“正确”选择是使 $x \\pm \\alpha e_1$ 中的符号与 $x$ 的第一个分量的符号相匹配，以避免相消减（subtractive cancellation）。由于 $(x)_1 = 1 > 0$，数值上稳定的选择是 $v_{\\text{right}}$。问题要求计算一个涉及两种选择的比率。\n\n我们来明确地构造这些向量：\n$$\nv_{\\text{right}} = \\begin{pmatrix} 1 \\\\ \\delta \\\\ 0 \\end{pmatrix} + \\sqrt{1 + \\delta^2} \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 1 + \\sqrt{1 + \\delta^2} \\\\ \\delta \\\\ 0 \\end{pmatrix}\n$$\n$$\nv_{\\text{wrong}} = \\begin{pmatrix} 1 \\\\ \\delta \\\\ 0 \\end{pmatrix} - \\sqrt{1 + \\delta^2} \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 1 - \\sqrt{1 + \\delta^2} \\\\ \\delta \\\\ 0 \\end{pmatrix}\n$$\n我们需要计算比率 $\\kappa(\\delta)$，其定义为\n$$\n\\kappa(\\delta)=\\frac{\\left| \\left(v_{\\text{wrong}}\\right)_1 \\right|}{\\left| \\left(v_{\\text{right}}\\right)_1 \\right|}.\n$$\n第一个分量分别是 $(v_{\\text{right}})_1 = 1 + \\sqrt{1 + \\delta^2}$ 和 $(v_{\\text{wrong}})_1 = 1 - \\sqrt{1 + \\delta^2}$。\n\n我们计算这些分量的绝对值。由于 $\\delta > 0$，我们有 $\\delta^2 > 0$，这意味着 $1 + \\delta^2 > 1$，因此 $\\sqrt{1 + \\delta^2} > 1$。\n项 $(v_{\\text{right}})_1 = 1 + \\sqrt{1 + \\delta^2}$ 是严格为正的，所以其绝对值就是它本身：\n$$\n\\left| \\left(v_{\\text{right}}\\right)_1 \\right| = 1 + \\sqrt{1 + \\delta^2}.\n$$\n项 $(v_{\\text{wrong}})_1 = 1 - \\sqrt{1 + \\delta^2}$ 是严格为负的。其绝对值是该项的相反数：\n$$\n\\left| \\left(v_{\\text{wrong}}\\right)_1 \\right| = - (1 - \\sqrt{1 + \\delta^2}) = \\sqrt{1 + \\delta^2} - 1.\n$$\n现在，我们可以写出 $\\kappa(\\delta)$ 的表达式：\n$$\n\\kappa(\\delta) = \\frac{\\sqrt{1 + \\delta^2} - 1}{\\sqrt{1 + \\delta^2} + 1}.\n$$\n这个表达式是正确的，但可以进一步简化，特别是为了在 $\\delta$ 很小（如 $\\delta \\ll 1$ 所暗示的）时，获得一个在数值计算上更稳健的形式。这可以通过分子有理化来实现。我们将分子和分母同乘以分子的共轭项，即 $(\\sqrt{1 + \\delta^2} + 1)$：\n$$\n\\kappa(\\delta) = \\left( \\frac{\\sqrt{1 + \\delta^2} - 1}{\\sqrt{1 + \\delta^2} + 1} \\right) \\times \\left( \\frac{\\sqrt{1 + \\delta^2} + 1}{\\sqrt{1 + \\delta^2} + 1} \\right).\n$$\n分子简化为平方差：\n$$\n(\\sqrt{1 + \\delta^2} - 1)(\\sqrt{1 + \\delta^2} + 1) = (\\sqrt{1 + \\delta^2})^2 - 1^2 = (1 + \\delta^2) - 1 = \\delta^2.\n$$\n分母变成一个平方：\n$$\n(\\sqrt{1 + \\delta^2} + 1)(\\sqrt{1 + \\delta^2} + 1) = (\\sqrt{1 + \\delta^2} + 1)^2.\n$$\n结合这些结果，得到 $\\kappa(\\delta)$ 的最终、简化的闭式表达式：\n$$\n\\kappa(\\delta) = \\frac{\\delta^2}{(\\sqrt{1 + \\delta^2} + 1)^2}.\n$$\n这种形式避免了中间表达式分子中存在的相消减问题，这也是区分 $v_{\\text{right}}$ 和 $v_{\\text{wrong}}$ 的全部意义所在。",
            "answer": "$$\\boxed{\\frac{\\delta^2}{\\left(\\sqrt{1 + \\delta^2} + 1\\right)^2}}$$"
        },
        {
            "introduction": "理论为我们提供了坚实的基础，但真正的理解往往源于亲手实现和经验观察。作为一项总结性实践，本练习  要求你从零开始，完整地实现Householder三对角化算法，从而跨越抽象概念与计算现实之间的鸿沟。通过构造具有已知特征值的矩阵，并随后度量计算结果与理论值的偏差（包括正交性、相似变换残差和谱精度），你将在有限精度计算的世界中，获得关于数值算法实际表现的宝贵洞见。",
            "id": "3572312",
            "problem": "考虑一个实对称矩阵 $A \\in \\mathbb{R}^{n \\times n}$。线性代数中的一个基本事实是，正交相似变换保持谱不变：如果 $Q \\in \\mathbb{R}^{n \\times n}$ 是正交矩阵，则 $Q^\\top A Q$ 与 $A$ 具有相同的特征值多重集。一个经过充分测试的将对称矩阵约化为三对角形式的算法是Householder变换方法，该方法构造一系列对称正交反射器，消去第一亚对角线下方的元素，最终得到一个三对角矩阵 $T$ 和一个累积的正交矩阵 $Q$，使得 $Q^\\top A Q = T$。作用于向量 $x \\in \\mathbb{R}^m$ 的Householder反射器使用 $v = \\dfrac{x - \\alpha e_1}{\\lVert x - \\alpha e_1 \\rVert_2}$，其中 $\\alpha = -\\operatorname{sign}(x_1)\\lVert x \\rVert_2$，以及 $H = I_m - 2 v v^\\top$ 将 $x$ 映射到 $\\alpha e_1$。\n\n在浮点运算中，计算出的量会受到舍入误差的影响。观测到的 $T$ 和 $A$ 的特征值可能会表现出微小的差异，因为计算出的 $Q$ 和 $T$ 对应于一个邻近的矩阵 $A + E$，其中 $E$ 是由舍入引起的微小扰动。您的任务是，从第一性原理出发，为对称矩阵实现Householder三对角化，构造具有已知特征结构的测试矩阵，并量化由舍入引起的谱差异。\n\n实现一个程序，该程序：\n- 对于每个测试用例，构造一个确定的正交矩阵 $V \\in \\mathbb{R}^{n \\times n}$ 和一个具有规定特征值的对角矩阵 $\\Lambda = \\operatorname{diag}(\\lambda_1,\\dots,\\lambda_n)$，然后构成对称矩阵 $A = V \\Lambda V^\\top$。其特征结构是构造已知的：$A$ 的特征值为 $\\{\\lambda_i\\}_{i=1}^n$，特征向量由 $V$ 的列给出。\n- 使用Householder反射器将 $A$ 约化为三对角形式：计算 $Q$ 和 $T$，使得 $Q^\\top A Q = T$，其中 $T$ 是实对称三对角矩阵，而 $Q$ 是正交矩阵。\n- 为每个测试用例计算以下定量输出：\n  1. $d_{AT} = \\max_i \\left| \\mu_i(T) - \\mu_i(A) \\right|$，其中 $\\{\\mu_i(\\cdot)\\}$ 是指定矩阵的特征值，按非递减顺序排序。这量化了由于舍入，$T$ 和 $A$ 的谱之间的差异。\n  2. $d_{A,\\Lambda} = \\max_i \\left| \\mu_i(A) - \\lambda_i \\right|$，其中两个序列都按非递减顺序排序。这量化了数值计算出的 $A$ 的特征值与构造时使用的已知特征值之间的差异。\n  3. $e_{\\text{orth}} = \\lVert Q^\\top Q - I_n \\rVert_F$，即偏离正交性的弗罗贝尼乌斯范数。\n  4. $e_{\\text{sim}} = \\lVert Q^\\top A Q - T \\rVert_F$，即衡量相似变换残差的弗罗贝尼乌斯范数。\n所有范数分别为标准的欧几里得范数和弗罗贝尼乌斯范数。\n\n所有计算均使用双精度浮点算术。不涉及角度，因此无需指定角度单位。不涉及物理单位。所有数值输出均表示为标准实数。\n\n用于覆盖一般和边缘场景的测试套件：\n- 情况 $1$ (一般良态)：$n = 5$，特征值 $\\lambda = [1, 2, 3, 4, 5]$。\n- 情况 $2$ (近乎重复的特征值)：$n = 8$，特征值 $\\lambda = [1, 1 + 10^{-12}, 2, 2 + 10^{-12}, 3, 3 + 10^{-12}, 4, 4 + 10^{-12}]$。\n- 情况 $3$ (大动态范围)：$n = 10$，特征值 $\\lambda = [10^{-8}, 10^{-6}, 10^{-4}, 10^{-2}, 1, 10, 10^{3}, 10^{5}, 10^{7}, 10^{9}]$。\n- 情况 $4$ (小维度边界)：$n = 2$，特征值 $\\lambda = [1, 10^{-15}]$。\n- 情况 $5$ (平凡边界)：$n = 1$，特征值 $\\lambda = [42]$。\n\n确定性正交基构造要求：对于每个 $n$，通过取矩阵 $M \\in \\mathbb{R}^{n \\times n}$（其元素为 $M_{ij} = \\sin((i+1)(j+1)) + \\cos((i+1) - 0.3(j+1)) + 0.5 \\cdot \\delta_{ij}$），对其进行全列正交化（例如，通过标准的QR分解）以获得 $M = QR$（其中 $Q$ 是正交的），然后如果 $\\det(Q) < 0$，则翻转 $Q$ 的第一列的符号以确保右手定则方向。使用此 $Q$ 作为 $V$。\n\n最终输出格式规范：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，每个元素对应一个测试用例的结果，每个结果本身是按 $[d_{AT}, d_{A,\\Lambda}, e_{\\text{orth}}, e_{\\text{sim}}]$ 顺序排列的四个实数的列表。例如，输出应类似于 $[[x_1, y_1, z_1, w_1],[x_2, y_2, z_2, w_2],\\dots]$，不含附加文本。\n\n程序必须是自包含的，无需用户输入，并遵循规定的运行时环境。",
            "solution": "用户提供的问题是数值线性代数中一个明确定义的任务。它要求实现用于实对称矩阵的Householder三对角化算法，并随后对浮点计算中固有的数值误差进行定量分析。该问题在科学上是合理的、自包含的且客观的。它指定了算法、测试矩阵的构造、要计算的精确指标以及输出的格式。因此，该问题是有效的，我将提供一个完整的解决方案。\n\n### 原理与方法论\n\n问题的核心是使用正交变换 $Q$ 将一个实对称矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 约化为一个相似的三对角矩阵 $T$，使得 $T = Q^\\top A Q$。理论上，$T$ 的特征值与 $A$ 的特征值完全相同。然而，在实践中，浮点运算会引入微小的误差。本练习旨在实现约化过程并量化这些误差。\n\n该方法论包括三个主要阶段：\n1.  构造具有已知特征结构的测试矩阵 $A$。\n2.  应用Householder三对角化算法以获得 $T$ 和 $Q$。\n3.  计算误差度量以评估实现的准确性和稳定性。\n\n#### 1. 测试矩阵构造\n\n为了创建一个可验证的测试用例，我们构造一个具有已知特征值集合 $\\{\\lambda_i\\}_{i=1}^n$ 的对称矩阵 $A$。这是通过指定一个对角矩阵 $\\Lambda = \\operatorname{diag}(\\lambda_1, \\dots, \\lambda_n)$ 和一个确定的正交矩阵 $V \\in \\mathbb{R}^{n \\times n}$ 来实现的。然后，通过相似变换 $A = V \\Lambda V^\\top$ 形成矩阵 $A$。根据相似变换的性质，$A$ 的特征值恰好是 $\\Lambda$ 的对角元素，而 $V$ 的列是相应的特征向量。\n\n正交矩阵 $V$ 按以下方式确定性地构造：\n- 对于给定的维度 $n$，生成一个矩阵 $M \\in \\mathbb{R}^{n \\times n}$，其元素为 $M_{ij} = \\sin((i+1)(j+1)) + \\cos((i+1) - 0.3(j+1)) + 0.5 \\delta_{ij}$，其中索引 $i, j$ 的范围从 $0$ 到 $n-1$，$\\delta_{ij}$ 是克罗内克δ函数。\n- 对 $M$ 执行QR分解，得到 $M = QR_M$，其中 $Q$ 是正交的，$R_M$ 是上三角矩阵。这个 $Q$ 构成了我们的初始正交基。\n- 为确保一致的方向，我们检查 $Q$ 的行列式。如果 $\\det(Q) < 0$，则翻转 $Q$ 的第一列的符号。这个最终的正交矩阵用作 $V$。\n\n#### 2. Householder三对角化\n\n将 $A$ 约化为三对角矩阵 $T$ 是迭代进行的。该过程包括 $n-2$ 个步骤。在步骤 $k$（对于 $k=0, 1, \\dots, n-3$），我们在矩阵的第 $k$ 列和第 $k$ 行中，分别在亚对角线/超对角线元素的下方和右侧引入零。\n\n这是通过使用Householder反射器实现的。Householder反射器是一个正交、对称的矩阵 $P = I - 2vv^\\top$，其中 $v$ 是一个单位向量。它将一个向量反射过与 $v$ 正交的超平面。\n\n在步骤 $k$，我们考虑由元素 $A_{k+1:n, k}$ 构成的向量 $x \\in \\mathbb{R}^{n-k-1}$。我们构造一个反射器 $P_k$，将 $x$ 映射到第一个标准基向量的倍数，即 $P_k x = \\alpha e_1$。这会消去 $x$ 中除第一个元素外的所有元素。反射器的参数为：\n- $\\alpha = -\\operatorname{sign}(x_1) \\lVert x \\rVert_2$。选择这个符号是为了在计算 $x - \\alpha e_1$ 时避免灾难性抵消。我们采用约定 $\\operatorname{sign}(0) = 1$。\n- Householder向量是 $v = \\frac{x - \\alpha e_1}{\\lVert x - \\alpha e_1 \\rVert_2}$。\n\n反射器 $P_k$ 是一个 $(n-k-1) \\times (n-k-1)$ 的矩阵。为了将其应用于完整的 $n \\times n$ 矩阵 $A$，它被嵌入到一个 $n \\times n$ 的单位矩阵中，形成 $Q_k = \\begin{pmatrix} I_k  0 \\\\ 0  P_k \\end{pmatrix}$。然后通过相似变换更新矩阵：$A \\to Q_k A Q_k$。对 $k=0, \\dots, n-3$ 重复此过程。\n\n总的正交变换是各个反射器的乘积：$Q = Q_0 Q_1 \\dots Q_{n-3}$。最终的三对角矩阵是 $T = Q^\\top A Q$。\n\n每一步对 $A$ 和 $Q$ 的更新必须高效地执行，而无需显式地构造大的矩阵 $Q_k$。\n- **更新 A：** 变换 $A \\to Q_k A Q_k$ 等价于 $A \\to (I-2\\hat{v}\\hat{v}^\\top) A (I-2\\hat{v}\\hat{v}^\\top)$，其中 $\\hat{v}$ 是向量 $v$ 前面填充 $k+1$ 个零。此更新可以高效地计算为 $A \\to A - 2(w\\hat{v}^\\top + \\hat{v}w^\\top)$，其中 $w = p - (\\hat{v}^\\top p)\\hat{v}$ 且 $p=A\\hat{v}$。\n- **累积 Q：** 总变换 $Q$ 初始化为 $I_n$。在每一步，它通过 $Q \\to Q Q_k$ 进行更新。这可以计算为 $Q \\to Q - 2(Q\\hat{v})\\hat{v}^\\top$。\n\n#### 3. 误差量化\n\n三对角化之后，我们计算四个度量来量化数值误差：\n1.  $d_{AT} = \\max_i \\left| \\mu_i(T) - \\mu_i(A) \\right|$：计算出的三对角矩阵 $T$ 的排序特征值与原始矩阵 $A$ 的排序特征值（数值计算）之间的最大绝对差。这衡量了三对角化过程引起的光谱漂移。\n2.  $d_{A,\\Lambda} = \\max_i \\left| \\mu_i(A) - \\lambda_i \\right|$：数值计算的 $A$ 的排序特征值与规定的排序特征值 $\\lambda_i$ 之间的最大绝对差。这衡量了从已知特征结构构造 $A$ 时引入的误差。\n3.  $e_{\\text{orth}} = \\lVert Q^\\top Q - I_n \\rVert_F$：累积的变换矩阵 $Q$ 偏离完美正交性的弗罗贝尼乌斯范数。\n4.  $e_{\\text{sim}} = \\lVert Q^\\top A Q - T \\rVert_F$：相似变换的残差的弗罗贝尼乌斯范数。这衡量了计算出的 $T$ 和 $Q$ 满足方程 $T=Q^\\top A Q$ 的程度。\n\n这些度量为所实现算法的数值质量提供了全面的图景。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the Householder tridiagonalization tests and print results.\n    \"\"\"\n\n    # Test suite as defined in the problem statement\n    test_cases = [\n        (5, np.array([1, 2, 3, 4, 5], dtype=float)),\n        (8, np.array([1, 1 + 1e-12, 2, 2 + 1e-12, 3, 3 + 1e-12, 4, 4 + 1e-12], dtype=float)),\n        (10, np.array([1e-8, 1e-6, 1e-4, 1e-2, 1, 10, 1e3, 1e5, 1e7, 1e9], dtype=float)),\n        (2, np.array([1, 1e-15], dtype=float)),\n        (1, np.array([42], dtype=float))\n    ]\n\n    results = []\n    \n    for n, lambdas in test_cases:\n        # 1. CONSTRUCT THE TEST MATRIX A\n        # Deterministically construct the orthogonal matrix V\n        i_ = np.arange(1, n + 1)\n        j_ = np.arange(1, n + 1)\n        I, J = np.meshgrid(i_, j_, indexing='ij')\n        M = np.sin(I * J) + np.cos(I - 0.3 * J) + 0.5 * np.identity(n)\n        \n        V, _ = np.linalg.qr(M)\n        if np.linalg.det(V)  0:\n            V[:, 0] *= -1\n            \n        Lambda_diag = np.diag(lambdas)\n        A = V @ Lambda_diag @ V.T\n\n        # 2. HOUSEHOLDER TRIDIAGONALIZATION\n        T = A.copy()\n        Q = np.identity(n, dtype=float)\n\n        for k in range(n - 2):\n            # Define the vector x to be annihilated\n            x = T[k + 1:, k]\n            x_norm = np.linalg.norm(x)\n\n            # Skip if the sub-column is already zero\n            if x_norm  np.finfo(float).eps:\n                continue\n\n            # Numerically stable choice for alpha\n            sign_x0 = np.copysign(1.0, x[0]) if x.size > 0 else 1.0\n            alpha = -sign_x0 * x_norm\n\n            # Construct the Householder vector v\n            u = x.copy()\n            u[0] -= alpha\n            u_norm = np.linalg.norm(u)\n            \n            if u_norm  np.finfo(float).eps:\n                continue\n\n            v_sub = u / u_norm\n            \n            # Embed v into a full-size vector\n            v_full = np.zeros(n, dtype=float)\n            v_full[k + 1:] = v_sub\n\n            # Efficiently update T and Q\n            # Update T -> H T H = T - 2(w v^T + v w^T) where w = p - (v^T p)v, p = Tv\n            p = T @ v_full\n            w = p - np.dot(p, v_full) * v_full\n            T -= 2 * (np.outer(w, v_full) + np.outer(v_full, w))\n\n            # Update Q -> Q H = Q - 2(Qv)v^T\n            Q -= 2 * np.outer(Q @ v_full, v_full)\n\n        # Clean T to be perfectly tridiagonal by zeroing out rounding errors\n        T_clean = np.triu(np.tril(T, 1), -1)\n\n        # 3. COMPUTE QUANTITATIVE OUTPUTS\n        # Eigenvalues must be sorted for comparison\n        lambda_known_sorted = np.sort(lambdas)\n        mu_A_sorted = np.sort(np.linalg.eigvalsh(A))\n        mu_T_sorted = np.sort(np.linalg.eigvalsh(T_clean))\n\n        # d_AT: Difference between eigenvalues of T and A\n        d_AT = np.max(np.abs(mu_T_sorted - mu_A_sorted))\n        \n        # d_A,Lambda: Difference between computed eigenvalues of A and known eigenvalues\n        d_A_Lambda = np.max(np.abs(mu_A_sorted - lambda_known_sorted))\n        \n        # e_orth: Orthogonality error of Q\n        e_orth = np.linalg.norm(Q.T @ Q - np.identity(n), 'fro')\n        \n        # e_sim: Similarity transformation residual\n        e_sim = np.linalg.norm(Q.T @ A @ Q - T_clean, 'fro')\n\n        results.append([d_AT, d_A_Lambda, e_orth, e_sim])\n\n    # Final print statement in the exact required format\n    # Using str.replace to remove spaces for compact output matching the spec\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```"
        }
    ]
}