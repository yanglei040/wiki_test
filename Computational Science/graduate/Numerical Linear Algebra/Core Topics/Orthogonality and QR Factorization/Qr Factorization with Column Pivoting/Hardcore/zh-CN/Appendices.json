{
    "hands_on_practices": [
        {
            "introduction": "要真正掌握带列主元的 QR 分解，手工推导其每一步至关重要。本练习 () 将引导你对一个参数化矩阵进行精确的符号计算，让你亲身体验列选择、Householder 反射构造以及矩阵更新的完整流程。通过这个过程，你将对算法的内部工作机制建立起深刻而具体的理解。",
            "id": "1057841",
            "problem": "考虑由三个正实数参数 $\\delta, \\gamma, \\beta$ 定义的 $4 \\times 4$ 实矩阵 $A$：\n$$\nA(\\delta, \\gamma, \\beta) = \\begin{pmatrix}\n\\delta  0  0  1 \\\\\n0  \\gamma  0  1 \\\\\n0  0  \\beta  1 \\\\\n0  0  0  1\n\\end{pmatrix}\n$$\n参数满足约束条件 $0  \\delta  \\gamma  \\beta  1/2$。\n\n我们对 $A$ 执行带列主元的 QR 分解，得到分解式 $AP=QR$，其中 $P$ 是一个置换矩阵，$Q$ 是一个正交矩阵，$R$ 是一个上三角矩阵。因子 $Q$ 和 $R$ 是通过 Householder 反射构建的。\n\n列主元策略如下：在每一步 $k=1, 2, 3$ 中，我们考虑上一步所得矩阵的第 $k$ 行到第 $4$ 行以及第 $k$ 列到第 $4$ 列组成的子矩阵。将该子矩阵中欧几里得范数最大的列与第 $k$ 列交换。\n\n用于在向量 $x$ 中引入零的 Householder 反射由矩阵 $H = I - 2 \\frac{vv^T}{v^T v}$ 给出，其中 Householder 向量定义为 $v = x + \\text{sgn}(x_1)\\|x\\|_2 e_1$，$x_1$ 是 $x$ 的第一个分量。我们采用约定 $\\text{sgn}(0)=1$。\n\n您的任务是确定最终上三角矩阵 $R$ 的元素 $R_{23}$。",
            "solution": "我们寻求在所述的带列主元的 Householder QR 分解下，$R$ 矩阵的 $(2,3)$ 元素。\n首先，记 $A = A(\\delta, \\gamma, \\beta)$。\n**第 1 步（主元选择与第一次 Householder 变换）：**\n计算各列的范数：$\\|A_{:,1}\\|_2 = \\delta$, $\\|A_{:,2}\\|_2 = \\gamma$, $\\|A_{:,3}\\|_2 = \\beta$, $\\|A_{:,4}\\|_2 = \\sqrt{1^2+1^2+1^2+1^2}=2$。由于 $\\beta  1/2$，范数最大的列是第四列。因此，我们将第 1 列和第 4 列交换。置换后的矩阵为：\n$$A^{(1)} = A P_1 = \\begin{pmatrix}1  0  0  \\delta \\\\ 1  \\gamma  0  0 \\\\ 1  0  \\beta  0 \\\\ 1  0  0  0 \\end{pmatrix}$$\n对第一列 $x_1 = (1,1,1,1)^T$ 应用 Householder 变换。$\\|x_1\\|_2=2$，$\\text{sgn}(x_{1,1})=1$。Householder 向量 $v_1 = x_1 + 2e_1 = (3,1,1,1)^T$。$v_1^Tv_1=12$。变换矩阵 $H_1 = I - \\frac{1}{6}v_1v_1^T$。\n应用 $H_1$ 得到 $A^{(2)} = H_1 A^{(1)}$:\n$$A^{(2)} = \\begin{pmatrix} -2  -\\frac{\\gamma}{2}  -\\frac{\\beta}{2}  -\\frac{\\delta}{2} \\\\ 0  \\frac{5\\gamma}{6}  -\\frac{\\beta}{6}  -\\frac{\\delta}{2} \\\\ 0  -\\frac{\\gamma}{6}  \\frac{5\\beta}{6}  -\\frac{\\delta}{2} \\\\ 0  -\\frac{\\gamma}{6}  -\\frac{\\beta}{6}  -\\frac{\\delta}{2} \\end{pmatrix}$$\n\n**第 2 步（主元选择与第二次 Householder 变换）：**\n在 $A^{(2)}$ 的右下 $3 \\times 3$ 子矩阵中选择主元。子列的范数为：\n- 第 2 列：$\\|(5\\gamma/6, -\\gamma/6, -\\gamma/6)^T\\|_2 = \\frac{\\sqrt{27}\\gamma}{6} = \\frac{\\sqrt{3}}{2}\\gamma$\n- 第 3 列：$\\|(-\\beta/6, 5\\beta/6, -\\beta/6)^T\\|_2 = \\frac{\\sqrt{27}\\beta}{6} = \\frac{\\sqrt{3}}{2}\\beta$\n- 第 4 列：$\\|(-\\delta/2, -\\delta/2, -\\delta/2)^T\\|_2 = \\frac{\\sqrt{3}\\delta}{2}$\n由于 $\\beta > \\gamma > \\delta$，范数最大的是第 3 列。我们将 $A^{(2)}$ 的第 2 列和第 3 列交换，得到 $A^{(3)}$：\n$$A^{(3)} = \\begin{pmatrix} -2  -\\frac{\\beta}{2}  -\\frac{\\gamma}{2}  -\\frac{\\delta}{2} \\\\ 0  -\\frac{\\beta}{6}  \\frac{5\\gamma}{6}  -\\frac{\\delta}{2} \\\\ 0  \\frac{5\\beta}{6}  -\\frac{\\gamma}{6}  -\\frac{\\delta}{2} \\\\ 0  -\\frac{\\beta}{6}  -\\frac{\\gamma}{6}  -\\frac{\\delta}{2} \\end{pmatrix}$$\n现在对 $A^{(3)}$ 的第 2 列从第 2 个元素开始的向量 $x_2 = (-\\beta/6, 5\\beta/6, -\\beta/6)^T$ 应用 Householder 变换。$\\|x_2\\|_2 = \\frac{\\sqrt{3}}{2}\\beta$，$\\text{sgn}(x_{2,1})=-1$。Householder 向量为 $v_2 = x_2 - \\|x_2\\|_2 e_1 = (-\\frac{\\beta}{6}-\\frac{\\sqrt{3}}{2}\\beta, \\frac{5\\beta}{6}, -\\frac{\\beta}{6})^T = -\\frac{\\beta}{6}(1+3\\sqrt{3}, -5, 1)^T$。\n\n**第 3 步（计算 $R_{23}$）：**\n$R_{23}$ 是更新后的 $A^{(3)}$ 的 $(2,3)$ 元素。这是通过对 $A^{(3)}$ 的第 3 列的子向量 $y = (5\\gamma/6, -\\gamma/6, -\\gamma/6)^T$ 应用 $3 \\times 3$ 的 Householder 变换 $\\tilde{H}_2$ 后得到的向量的第一个分量。\n该分量为 $y'_1 = y_1 - 2 \\frac{v_2^T y}{v_2^T v_2} v_{2,1}$。我们计算所需项：\n$$v_2^T y = \\left(-\\frac{\\beta\\gamma}{36}\\right) \\left[ (1+3\\sqrt{3}) \\cdot 5 + (-5) \\cdot (-1) + 1 \\cdot (-1) \\right] = -\\frac{\\beta\\gamma}{36}(9+15\\sqrt{3})$$\n$$v_2^T v_2 = \\left(\\frac{\\beta}{6}\\right)^2 \\left[ (1+3\\sqrt{3})^2 + (-5)^2 + 1^2 \\right] = \\frac{\\beta^2}{36}(1+6\\sqrt{3}+27+25+1) = \\frac{\\beta^2}{6}(9+\\sqrt{3})$$\n代入 $R_{23}$ 的表达式：\n$$R_{23} = \\frac{5\\gamma}{6} - 2 \\frac{-\\beta\\gamma(9+15\\sqrt{3})/36}{\\beta^2(9+\\sqrt{3})/6} \\left(-\\frac{\\beta}{6}(1+3\\sqrt{3})\\right)$$\n$$R_{23} = \\frac{5\\gamma}{6} - \\frac{\\gamma(9+15\\sqrt{3})(1+3\\sqrt{3})}{18(9+\\sqrt{3})} = \\frac{5\\gamma}{6} - \\frac{\\gamma(144+42\\sqrt{3})}{18(9+\\sqrt{3})}$$\n对分数部分进行有理化：$\\frac{144+42\\sqrt{3}}{18(9+\\sqrt{3})} = \\frac{24+7\\sqrt{3}}{3(9+\\sqrt{3})} = \\frac{(24+7\\sqrt{3})(9-\\sqrt{3})}{3(81-3)} = \\frac{195+39\\sqrt{3}}{234} = \\frac{5+\\sqrt{3}}{6}$。\n$$R_{23} = \\frac{5\\gamma}{6} - \\gamma\\left(\\frac{5+\\sqrt{3}}{6}\\right) = \\frac{5\\gamma - 5\\gamma - \\sqrt{3}\\gamma}{6} = -\\frac{\\sqrt{3}\\gamma}{6}$$\n由于最后的 Householder 变换 $H_3$ 不影响第 2 行，这便是最终结果。",
            "answer": "$$\\boxed{-\\frac{\\sqrt{3}\\gamma}{6}}$$"
        },
        {
            "introduction": "理解算法的执行步骤是一回事，洞察其为何有效则是更高层次的理解。本练习 () 旨在搭建从“如何做”到“为什么”的桥梁，通过分析一个由小参数 $\\epsilon$ 控制的近秩亏矩阵，你将分析并预测上三角矩阵 $R$ 的对角元素的大小模式。这个练习清晰地揭示了列主元 QR 分解如何将原矩阵 $A$ 中的线性相关性（或近似相关性）反映在 $R$ 的对角线结构上，这正是其“秩揭示”能力的核心。",
            "id": "3549747",
            "problem": "考虑由下式定义的近秩亏矩阵 $A(\\epsilon) \\in \\mathbb{R}^{3 \\times 3}$\n$$\nA(\\epsilon) = \\begin{bmatrix}\n1  1  1 \\\\\n1  1  1+\\epsilon \\\\\n1  1+\\epsilon  1\n\\end{bmatrix},\n$$\n其中 $\\epsilon > 0$ 是一个足够小的数。对其进行带列主元选择的Householder正交三角（QR）分解，即寻找标准正交矩阵 $Q \\in \\mathbb{R}^{3 \\times 3}$、上三角矩阵 $R \\in \\mathbb{R}^{3 \\times 3}$ 和排列矩阵 $P \\in \\mathbb{R}^{3 \\times 3}$，使得\n$$\nQ^{\\top} A(\\epsilon) P = R,\n$$\n每一步的主元选择准则是在剩余（更新后的）列中选择具有最大列$2$-范数的列；如果范数完全相等，则选择列索引最小的列来打破僵局。遵循 $R$ 的对角线元素为非负的约定。\n\n仅从Householder反射变换的定义和列主元选择准则出发，执行第一次主元决策，然后解析地预测该算法产生的对角线元素大小 $|R_{11}|$、$|R_{22}|$ 和 $|R_{33}|$，并用 $\\epsilon$ 精确表示。你的最终答案必须是包含作为 $\\epsilon$ 函数的 $|R_{11}|$、$|R_{22}|$ 和 $|R_{33}|$ 的单一闭式解析表达式，并排列成一个行矩阵。不需要进行数值近似或舍入。",
            "solution": "问题要求解对矩阵 $A(\\epsilon)$ 进行带列主元选择的Householder QR分解所得到的上三角矩阵 $R$ 的对角线元素的大小 $|R_{11}|$、$|R_{22}|$ 和 $|R_{33}|$。该分解的形式为 $Q^{\\top} A(\\epsilon) P = R$，其中 $Q$ 是标准正交矩阵，$P$ 是排列矩阵，$R$ 是对角线元素为非负的上三角矩阵。\n\n给定的矩阵是：\n$$\nA(\\epsilon) = \\begin{bmatrix}\n1  1  1 \\\\\n1  1  1+\\epsilon \\\\\n1  1+\\epsilon  1\n\\end{bmatrix}\n$$\n设 $A(\\epsilon)$ 的列向量为 $a_1, a_2, a_3$。\n\n**第1步：第一次主元选择**\n列主元选择策略要求选择具有最大2-范数的列。我们计算 $A(\\epsilon)$ 各列的2-范数的平方：\n$$\n\\|a_1\\|_2^2 = 1^2 + 1^2 + 1^2 = 3\n$$\n$$\n\\|a_2\\|_2^2 = 1^2 + 1^2 + (1+\\epsilon)^2 = 1 + 1 + 1 + 2\\epsilon + \\epsilon^2 = 3 + 2\\epsilon + \\epsilon^2\n$$\n$$\n\\|a_3\\|_2^2 = 1^2 + (1+\\epsilon)^2 + 1^2 = 1 + 1 + 2\\epsilon + \\epsilon^2 + 1 = 3 + 2\\epsilon + \\epsilon^2\n$$\n由于 $\\epsilon > 0$，我们有 $3 + 2\\epsilon + \\epsilon^2 > 3$。因此，$||a_2||_2$ 和 $||a_3||_2$ 都大于 $||a_1||_2$。第2列和第3列之间出现了范数相等的情况。打破僵局的规则是选择索引最小的列，所以我们选择列 $a_2$ 作为第一个主元。\n\n这需要交换第1列和第2列。排列矩阵为 $P_1 = \\begin{bmatrix} 0  1  0 \\\\ 1  0  0 \\\\ 0  0  1 \\end{bmatrix}$。第一步要变换的矩阵是 $A' = A(\\epsilon)P_1$：\n$$\nA' = \\begin{bmatrix}\n1  1  1 \\\\\n1  1  1+\\epsilon \\\\\n1+\\epsilon  1  1\n\\end{bmatrix}\n$$\n$A'$ 的第一列是主元列，也就是原始的 $a_2$。$R$ 的第一个对角线元素，记为 $R_{11}$，是该主元列的2-范数。根据约定，$R_{11} \\ge 0$。\n$$\n|R_{11}| = R_{11} = \\|a_2\\|_2 = \\sqrt{3 + 2\\epsilon + \\epsilon^2}\n$$\n\n**第2步：第二次主元选择**\n将第一个Householder变换 $Q_1^{\\top}$ 应用于 $A'$，得到 $A^{(2)} = Q_1^{\\top} A' = Q_1^{\\top} A(\\epsilon) P_1$。该矩阵具有以下结构：\n$$\nA^{(2)} = \\begin{bmatrix}\nR_{11}  R_{12}  R_{13} \\\\\n0     \\\\\n0  M_{2\\times2}  \n\\end{bmatrix}\n$$\n其中 $M_{2\\times2}$ 是一个 $2 \\times 2$ 的子矩阵，其列需要被评估以进行下一次主元选择。设子矩阵 $M_{2\\times2}$ 的列为 $\\tilde{c}_2$ 和 $\\tilde{c}_3$。它们对应于 $A'$ 的第二列和第三列的更新版本。\n\n这些子列的长度可以在不显式构造Householder矩阵的情况下计算出来。由于变换 $Q_1^{\\top}$ 是正交的，它保持列范数不变。$A'$ 的原始第二列和第三列分别是 $a_1$ 和 $a_3$。变换后，设它们为 $c_2 = Q_1^{\\top} a_1$ 和 $c_3 = Q_1^{\\top} a_3$。我们有 $c_2 = [R_{12}, \\tilde{c}_2^\\top]^\\top$ 和 $c_3 = [R_{13}, \\tilde{c}_3^\\top]^\\top$。根据范数守恒：\n$$\n\\|\\tilde{c}_2\\|_2^2 = \\|c_2\\|_2^2 - R_{12}^2 = \\|a_1\\|_2^2 - R_{12}^2\n$$\n$$\n\\|\\tilde{c}_3\\|_2^2 = \\|c_3\\|_2^2 - R_{13}^2 = \\|a_3\\|_2^2 - R_{13}^2\n$$\n元素 $R_{12}$ 和 $R_{13}$ 是 $a_1$ 和 $a_3$ 在归一化主元列 $a_2/\\|a_2\\|_2$ 上的投影。\n$$\nR_{12} = \\frac{\\langle a_2, a_1 \\rangle}{\\|a_2\\|_2} = \\frac{1 \\cdot 1 + 1 \\cdot 1 + (1+\\epsilon) \\cdot 1}{\\sqrt{3+2\\epsilon+\\epsilon^2}} = \\frac{3+\\epsilon}{\\sqrt{3+2\\epsilon+\\epsilon^2}}\n$$\n$$\nR_{13} = \\frac{\\langle a_2, a_3 \\rangle}{\\|a_2\\|_2} = \\frac{1 \\cdot 1 + 1 \\cdot (1+\\epsilon) + (1+\\epsilon) \\cdot 1}{\\sqrt{3+2\\epsilon+\\epsilon^2}} = \\frac{1+1+\\epsilon+1+\\epsilon}{\\sqrt{3+2\\epsilon+\\epsilon^2}} = \\frac{3+2\\epsilon}{\\sqrt{3+2\\epsilon+\\epsilon^2}}\n$$\n将这些代入范数方程中：\n$$\n\\|\\tilde{c}_2\\|_2^2 = 3 - \\left(\\frac{3+\\epsilon}{\\sqrt{3+2\\epsilon+\\epsilon^2}}\\right)^2 = \\frac{3(3+2\\epsilon+\\epsilon^2) - (9+6\\epsilon+\\epsilon^2)}{3+2\\epsilon+\\epsilon^2} = \\frac{2\\epsilon^2}{3+2\\epsilon+\\epsilon^2}\n$$\n$$\n\\|\\tilde{c}_3\\|_2^2 = (3+2\\epsilon+\\epsilon^2) - \\left(\\frac{3+2\\epsilon}{\\sqrt{3+2\\epsilon+\\epsilon^2}}\\right)^2 = \\frac{(3+2\\epsilon+\\epsilon^2)^2 - (3+2\\epsilon)^2}{3+2\\epsilon+\\epsilon^2}\n$$\n对分子使用平方差恒等式 $u^2-v^2=(u-v)(u+v)$，其中 $u=3+2\\epsilon+\\epsilon^2$，$v=3+2\\epsilon$：\n$$\n\\|\\tilde{c}_3\\|_2^2 = \\frac{(\\epsilon^2)(6+4\\epsilon+\\epsilon^2)}{3+2\\epsilon+\\epsilon^2}\n$$\n为了选择第二个主元，我们比较 $\\|\\tilde{c}_2\\|_2^2$ 和 $\\|\\tilde{c}_3\\|_2^2$。由于 $\\epsilon > 0$，我们只需要比较分子 $2\\epsilon^2$ 和 $\\epsilon^2(6+4\\epsilon+\\epsilon^2)$，这可以简化为比较 $2$ 和 $6+4\\epsilon+\\epsilon^2$。因为 $\\epsilon > 0$，很明显 $6+4\\epsilon+\\epsilon^2 > 2$。\n因此，$\\|\\tilde{c}_3\\|_2 > \\|\\tilde{c}_2\\|_2$，第二个主元列是 $\\tilde{c}_3$。这对应于 $A'$ 的第三列，即原始的 $a_3$。$R$ 的第二个对角线元素因此是：\n$$\n|R_{22}| = R_{22} = \\|\\tilde{c}_3\\|_2 = \\sqrt{\\frac{\\epsilon^2(6+4\\epsilon+\\epsilon^2)}{3+2\\epsilon+\\epsilon^2}} = \\frac{\\epsilon\\sqrt{6+4\\epsilon+\\epsilon^2}}{\\sqrt{3+2\\epsilon+\\epsilon^2}}\n$$\n\n**第3步：确定第三个对角线元素**\n我们可以利用行列式的性质来确定 $|R_{33}|$，而无需显式地执行第二次Householder变换。对于分解 $AP=QR$ (或 $Q^\\top AP=R$)，我们有：\n$$\n\\det(A) \\det(P) = \\det(Q) \\det(R)\n$$\n排列矩阵的行列式 $\\det(P)$ 是 $\\pm 1$。正交矩阵的行列式 $\\det(Q)$ 也是 $\\pm 1$。对两边取绝对值得到：\n$$\n|\\det(A)| = |\\det(R)|\n$$\n上三角矩阵的行列式是对角线元素的乘积：$\\det(R) = R_{11}R_{22}R_{33}$。由于我们有约定 $R_{ii} \\ge 0$，这意味着 $|\\det(R)| = R_{11}R_{22}R_{33}$。\n我们来计算 $A(\\epsilon)$ 的行列式：\n$$\n\\det(A(\\epsilon)) = \\det \\begin{bmatrix}\n1  1  1 \\\\\n1  1  1+\\epsilon \\\\\n1  1+\\epsilon  1\n\\end{bmatrix} = 1(1(1) - (1+\\epsilon)^2) - 1(1(1) - 1(1+\\epsilon)) + 1(1(1+\\epsilon) - 1(1))\n$$\n$$\n= (1 - (1+2\\epsilon+\\epsilon^2)) - (1 - 1 - \\epsilon) + (1+\\epsilon - 1) = (-2\\epsilon - \\epsilon^2) - (-\\epsilon) + \\epsilon = -2\\epsilon - \\epsilon^2 + 2\\epsilon = -\\epsilon^2\n$$\n因此，$|\\det(A(\\epsilon))| = \\epsilon^2$。我们有：\n$$\nR_{11} R_{22} R_{33} = \\epsilon^2\n$$\n所以，$|R_{33}| = R_{33} = \\frac{\\epsilon^2}{R_{11}R_{22}}$。代入 $R_{11}$ 和 $R_{22}$ 的表达式：\n$$\nR_{11} R_{22} = \\left(\\sqrt{3+2\\epsilon+\\epsilon^2}\\right) \\left(\\frac{\\epsilon\\sqrt{6+4\\epsilon+\\epsilon^2}}{\\sqrt{3+2\\epsilon+\\epsilon^2}}\\right) = \\epsilon\\sqrt{6+4\\epsilon+\\epsilon^2}\n$$\n最后，\n$$\n|R_{33}| = R_{33} = \\frac{\\epsilon^2}{\\epsilon\\sqrt{6+4\\epsilon+\\epsilon^2}} = \\frac{\\epsilon}{\\sqrt{6+4\\epsilon+\\epsilon^2}}\n$$\n\n对角线元素的大小为：\n$|R_{11}| = \\sqrt{3+2\\epsilon+\\epsilon^2}$\n$|R_{22}| = \\frac{\\epsilon\\sqrt{6+4\\epsilon+\\epsilon^2}}{\\sqrt{3+2\\epsilon+\\epsilon^2}}$\n$|R_{33}| = \\frac{\\epsilon}{\\sqrt{6+4\\epsilon+\\epsilon^2}}$\n按照要求将这些排列成一个行矩阵，就得到了最终结果。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} \\sqrt{3+2\\epsilon+\\epsilon^2}  \\frac{\\epsilon\\sqrt{6+4\\epsilon+\\epsilon^2}}{\\sqrt{3+2\\epsilon+\\epsilon^2}}  \\frac{\\epsilon}{\\sqrt{6+4\\epsilon+\\epsilon^2}} \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "理论的价值最终体现在其解决实际问题的能力上。本练习 () 是一个综合性的计算实践，将带你从理论走向应用，解决数值线性代数中一个经典挑战：求解病态最小二乘问题。通过编程实现，你将直观地对比使用列主元 QR 分解和传统正规方程法在处理近线性相关列时的数值稳定性差异，从而深刻体会到在实际计算中选择数值稳健算法的至关重要性。",
            "id": "3275467",
            "problem": "您将实现一个程序，通过构造和测量来演示，当设计矩阵的两列几乎相同时，用于线性最小二乘的正规方程公式如何在数值上发生秩亏损，而基于带列主元的 QR 分解的秩揭示分解法则仍然能够识别正确的数值秩并产生一个稳定的最小二乘解。请完全使用纯数值线性代数的术语进行操作。\n\n考虑一个最小化超定线性系统残差的欧几里得范数的最小二乘问题，\n$$\n\\min_{x \\in \\mathbb{R}^n} \\| A x - b \\|_2,\n$$\n其中合成矩阵 $A \\in \\mathbb{R}^{m \\times n}$ 按如下方式构造。设 $m = 5$，$n = 3$。定义标准基向量 $e_1, e_2, e_3 \\in \\mathbb{R}^5$。对于给定的参数 $\\epsilon \\ge 0$，设置\n$$\nc_1 = e_1, \\quad c_2 = e_1 + \\epsilon\\, e_2, \\quad c_3 = e_3,\n$$\n并组装成\n$$\nA(\\epsilon) = \\begin{bmatrix} c_1  c_2  c_3 \\end{bmatrix} \\in \\mathbb{R}^{5 \\times 3}.\n$$\n取右侧向量为\n$$\nb = \\begin{bmatrix} 1 \\\\ -3 \\\\ 2 \\\\ 0 \\\\ 0 \\end{bmatrix} \\in \\mathbb{R}^5.\n$$\n\n推导的基本依据：\n- 根据最小二乘的一阶最优性条件，任何最小化子 $x$ 都满足正规方程\n$$\nA^\\top A \\, x = A^\\top b.\n$$\n- $2$-范数下的条件数定义为 $\\kappa_2(M) = \\sigma_{\\max}(M) / \\sigma_{\\min}(M)$，其中 $M$ 为一个满秩矩阵，$\\sigma_{\\max}$ 和 $\\sigma_{\\min}$ 分别是最大和最小奇异值。\n- 对于任何 $A$，当 $A$ 具有满列秩时，$A^\\top A$ 的奇异值是 $A$ 的奇异值的平方，因此 $\\kappa_2(A^\\top A) = \\kappa_2(A)^2$。\n- 带列主元的 QR 分解是将矩阵分解为 $A P = Q R$ 的形式，其中 $P$ 是一个置换矩阵，$Q$ 的列标准正交，$R$ 是一个上三角矩阵。通过将 $R$ 的对角线元素的大小与容差 $\\tau = \\max(m,n)\\,\\varepsilon_{\\mathrm{mach}}\\,\\|A\\|_2$ 进行比较，可以揭示数值秩 $r$，其中 $\\varepsilon_{\\mathrm{mach}}$ 是浮点运算的机器ε。\n\n您的任务：\n1. 实现一个使用修正 Gram–Schmidt 法计算 $Q$、$R$ 和一个编码 $P$ 的置换的秩揭示 QR 分解（带列主元），以及一个通过将 $R$ 的对角线元素与上述容差 $\\tau$ 比较确定的数值秩 $r$。请使用双精度浮点运算。\n2. 为每个指定的 $\\epsilon$ 值计算以下量：\n   - 通过奇异值分解计算的 $A(\\epsilon)$ 的秩，记为 $\\mathrm{rank}(A)$。\n   - 通过奇异值分解计算的 $A(\\epsilon)^\\top A(\\epsilon)$ 的秩，记为 $\\mathrm{rank}(A^\\top A)$。\n   - 由您实现的带列主元的 QR 分解如上所述识别的数值秩 $r_{\\mathrm{QR}}$。\n   - $2$-范数条件数 $\\kappa_2(A)$ 和 $\\kappa_2(A^\\top A)$。\n   - 通过显式构造 $G = A^\\top A$ 并使用直接线性求解器求解 $G x = A^\\top b$ 来计算的最小二乘解。如果 $\\mathrm{rank}(G)  n$，则将系统视为数值奇异且不求解；在这种情况下，报告一个如下所述的特殊值。\n   - 通过您实现的带列主元的 QR 分解计算的最小二乘解。使用数值秩 $r_{\\mathrm{QR}}$ 求解降阶的三角系统 $R_{1:r,1:r} y = (Q^\\top b)_{1:r}$，然后通过置换映射回原始变量顺序以获得 $x_{\\mathrm{QR}}$，其余分量设置为零。这将产生一个与检测到的数值秩一致的基本解（通过将自由变量设置为零得到）。\n3. 对于每种情况，报告残差范数和解的范数：\n   - 正规方程解的残差范数 $\\|A x_{\\mathrm{NE}} - b\\|_2$。如果 $\\mathrm{rank}(A^\\top A)  n$，则将此残差报告为浮点数 NaN (非数字)。\n   - QR 解的残差范数 $\\|A x_{\\mathrm{QR}} - b\\|_2$。\n   - QR 解的欧几里得范数 $\\|x_{\\mathrm{QR}}\\|_2$。\n4. 对 $\\epsilon$ 使用以下测试套件：\n   - $\\epsilon = 10^{-8}$，表示两列相差 $10^{-8}$。\n   - $\\epsilon = 0$，表示两列完全相同（真实的秩亏损）。\n   - $\\epsilon = 10^{-4}$，表示较温和的近似共线性。\n5. 最终输出格式：\n   - 您的程序应生成单行输出，包含一个逗号分隔的列表，列表包含三个项目，每个项目是按上述测试套件顺序排列的一个测试用例的列表。\n   - 对于每个测试用例，输出列表\n     $$\n     [\\mathrm{rank}(A),\\ \\mathrm{rank}(A^\\top A),\\ r_{\\mathrm{QR}},\\ \\kappa_2(A),\\ \\kappa_2(A^\\top A),\\ \\|A x_{\\mathrm{NE}} - b\\|_2,\\ \\|A x_{\\mathrm{QR}} - b\\|_2,\\ \\|x_{\\mathrm{QR}}\\|_2].\n     $$\n   - 如果 $\\mathrm{rank}(A^\\top A)  n$，则如前所述将正规方程的残差输出为 NaN。所有条目必须是基本数值类型（整数或浮点数）。整个输出必须是单行上的 Python 风格的列表的列表，例如：[[...],[...],[...]]。\n\n注意：\n- 不涉及角度；不需要角度单位。\n- 没有物理单位；报告纯标量值。\n- 确保您的实现是确定性的，并且核心计算仅使用双精度算术，除非语言默认值另有规定。",
            "solution": "该问题已经过验证，被确定为数值线性代数领域中一个有效且适定的问题。它具有科学依据，是客观的，并包含了进行研究所需的所有必要信息。\n\n任务是展示使用带列主元的秩揭示QR分解求解线性最小二乘问题，相比于传统的正规方程方法，在数值稳定性上的优越性，特别是当设计矩阵 $A$ 具有近似共线的列时。\n\n线性最小二乘问题是寻找 $x \\in \\mathbb{R}^n$，使得对于给定的矩阵 $A \\in \\mathbb{R}^{m \\times n}$ 和向量 $b \\in \\mathbb{R}^m$，残差的欧几里得范数 $\\|Ax - b\\|_2$ 最小。\n\n对于 $m=5$ 和 $n=3$，特定的矩阵 $A(\\epsilon)$ 由列向量 $c_1, c_2, c_3 \\in \\mathbb{R}^5$ 构造如下：\n$$\nc_1 = \\begin{bmatrix} 1 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 0 \\end{bmatrix}, \\quad\nc_2 = \\begin{bmatrix} 1 \\\\ \\epsilon \\\\ 0 \\\\ 0 \\\\ 0 \\end{bmatrix}, \\quad\nc_3 = \\begin{bmatrix} 0 \\\\ 0 \\\\ 1 \\\\ 0 \\\\ 0 \\end{bmatrix}.\n$$\n矩阵 $A(\\epsilon)$ 由这些列组成，$A(\\epsilon) = \\begin{bmatrix} c_1  c_2  c_3 \\end{bmatrix}$。右侧向量给定为 $b = [1, -3, 2, 0, 0]^\\top$。\n\n当参数 $\\epsilon$ 接近 $0$ 时，列 $c_1$ 和 $c_2$ 变得近似线性相关。这使得矩阵 $A(\\epsilon)$ 病态。分析将针对 $\\epsilon \\in \\{10^{-8}, 0, 10^{-4}\\}$ 进行。\n\n### 方法论\n\n将实现并比较两种方法。\n\n**1. 正规方程 (NE)**\n最小二乘问题的解必须满足正规方程：\n$$\nA^\\top A x = A^\\top b.\n$$\n此方法涉及显式构造格拉姆矩阵 $G = A^\\top A$ 和修改后的右侧向量 $A^\\top b$，然后求解 $n \\times n$ 线性系统 $Gx = A^\\top b$。此方法的一个关键问题是 $G$ 的条件数是 $A$ 的条件数的平方，即 $\\kappa_2(A^\\top A) = \\kappa_2(A)^2$。这种平方关系可能导致数值精度的显著损失，并可能使一个计算上满秩的问题表现为奇异。\n\n对于每个 $\\epsilon$，我们首先使用标准的奇异值分解 (SVD) 方法计算 $G = A^\\top A$ 的秩。如果 $\\mathrm{rank}(G)  n$，则该矩阵被认为是数值奇异的，我们将不尝试求解该系统。在这种情况下，残差范数 $\\|A x_{\\mathrm{NE}} - b\\|_2$ 将报告为“非数字”(NaN)。否则，我们求解系统得到 $x_{\\mathrm{NE}}$ 并计算相应的残差范数。\n\n**2. 带列主元的 QR 分解**\n一种数值上更稳定的方法是使用 $A$ 的 QR 分解。具体来说，我们将使用带列主元的秩揭示 QR 分解，其形式为：\n$$\nAP = QR,\n$$\n其中 $P$ 是一个置换矩阵，$Q$ 是一个具有标准正交列的矩阵，$R$ 是一个上三角矩阵。最小二乘问题变为 $\\min_x \\|Q R P^\\top x - b\\|_2$。令 $y = P^\\top x$，问题等价于 $\\min_y \\|Ry - Q^\\top b\\|_2$，因为乘以正交矩阵 $Q^\\top$ 不会改变欧几里得范数。\n\n实现将使用带列主元的修正 Gram-Schmidt (MGS) 算法。在分解的每一步 $k$，选择剩余欧几里得范数最大的列作为主元，换到第 $k$ 个位置，然后用于形成 $Q$ 的第 $k$ 列和 $R$ 的第 $k$ 行。\n\n一个关键方面是确定数值秩 $r_{\\mathrm{QR}}$。这是通过将 $R$ 的对角元素的大小与容差 $\\tau$ 进行比较来完成的：\n$$\n\\tau = \\max(m,n)\\,\\varepsilon_{\\mathrm{mach}}\\,\\|A\\|_2,\n$$\n其中 $\\varepsilon_{\\mathrm{mach}}$ 是双精度浮点运算的机器ε。如果 $|R_{kk}|  \\tau$，则认为矩阵在步骤 $k$ 处数值上是秩亏损的，数值秩设为 $r_{\\mathrm{QR}} = k$。\n\n一旦找到了 $Q$、$R$、置换 $P$（由索引向量表示）和数值秩 $r_{\\mathrm{QR}}$，就可以计算解 $x_{\\mathrm{QR}}$。我们求解降秩的上三角系统：\n$$\nR_{1:r, 1:r} \\, y_{1:r} = (Q^\\top b)_{1:r},\n$$\n其中 $r=r_{\\mathrm{QR}}$，使用回代法求解。大小为 $n$ 的解向量 $y$ 通过将其前 $r$ 个分量设置为 $y_{1:r}$，其余 $n-r$ 个分量设置为零来构成。这对应于找到一个基本解。最后，反转置换以找到原始坐标中的解：$x_{\\mathrm{QR}} = Py$。这是通过根据置换向量将 $y$ 的分量赋给 $x_{\\mathrm{QR}}$ 来实现的。\n\n### 计算量\n对于每个 $\\epsilon$ 值，将计算并报告以下量：\n- $\\mathrm{rank}(A)$: 通过 SVD 计算的 $A(\\epsilon)$ 的秩。\n- $\\mathrm{rank}(A^\\top A)$: 通过 SVD 计算的 $A(\\epsilon)^\\top A(\\epsilon)$ 的秩。\n- $r_{\\mathrm{QR}}$: 从我们实现的带列主元的 QR 分解得到的数值秩。\n- $\\kappa_2(A)$: $A(\\epsilon)$ 的 $2$-范数条件数。\n- $\\kappa_2(A^\\top A)$: $A(\\epsilon)^\\top A(\\epsilon)$ 的 $2$-范数条件数。\n- $\\|A x_{\\mathrm{NE}} - b\\|_2$: 正规方程解的残差范数（或 NaN）。\n- $\\|A x_{\\mathrm{QR}} - b\\|_2$: QR 解的残差范数。\n- $\\|x_{\\mathrm{QR}}\\|_2$: QR 解的欧几里得范数。\n\n这种比较分析旨在突显正规方程的数值陷阱以及秩揭示 QR 方法在解决最小二乘问题时的鲁棒性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef qr_pivot_mgs(A):\n    \"\"\"\n    Computes a rank-revealing QR factorization with column pivoting using\n    Modified Gram-Schmidt. The factorization is of the form AP = QR.\n\n    Args:\n        A (np.ndarray): The matrix to factorize, of size m x n.\n\n    Returns:\n        Q (np.ndarray): m x n matrix with orthonormal columns.\n        R (np.ndarray): n x n upper triangular matrix.\n        p (list): Permutation vector of length n. A_permuted[:, k] is A[:, p[k]].\n        rank (int): Numerical rank of the matrix.\n    \"\"\"\n    m, n = A.shape\n    V = A.copy()\n    Q = np.zeros((m, n))\n    R = np.zeros((n, n))\n    p = list(range(n))\n\n    A_norm = np.linalg.norm(A, 2)\n    # Handle the case of a zero matrix for robustness\n    if A_norm == 0:\n        return Q, R, p, 0\n    \n    tol = max(m, n) * np.finfo(float).eps * A_norm\n    \n    numerical_rank = n  # Assume full rank initially\n\n    for k in range(n):\n        # Find the column with the largest 2-norm in the remaining submatrix V[:, k:]\n        col_norms = np.linalg.norm(V[:, k:], axis=0)\n        best_col_idx_local = np.argmax(col_norms)\n        best_col_idx_global = k + best_col_idx_local\n        \n        # Swap columns in V and update the permutation vector p\n        if best_col_idx_global != k:\n            V[:, [k, best_col_idx_global]] = V[:, [best_col_idx_global, k]]\n            p[k], p[best_col_idx_global] = p[best_col_idx_global], p[k]\n            \n        # The diagonal element R[k, k] is the norm of the current pivot column\n        R[k, k] = np.linalg.norm(V[:, k])\n\n        # Check for rank deficiency against the tolerance\n        if R[k, k]  tol:\n            numerical_rank = k\n            break\n\n        # Normalize the k-th column of V to get the k-th column of Q\n        Q[:, k] = V[:, k] / R[k, k]\n\n        # Orthogonalize the remaining columns of V against the new basis vector Q[:, k]\n        for j in range(k + 1, n):\n            R[k, j] = np.dot(Q[:, k], V[:, j])\n            V[:, j] -= R[k, j] * Q[:, k]\n            \n    return Q, R, p, numerical_rank\n\ndef back_substitution(R, c):\n    \"\"\"Solves Rx = c for an upper triangular matrix R.\"\"\"\n    n = R.shape[0]\n    x = np.zeros(n)\n    for i in range(n - 1, -1, -1):\n        if R[i, i] == 0:\n            # This should ideally not be reached if the system is well-posed.\n            # R is from a rank-revealing QR, so R[i,i] > tol > 0.\n            raise np.linalg.LinAlgError(\"Singular matrix in back substitution.\")\n        dot_product = np.dot(R[i, i+1:], x[i+1:])\n        x[i] = (c[i] - dot_product) / R[i, i]\n    return x\n\ndef solve():\n    \"\"\"\n    Main function to run the numerical experiment for the specified epsilon values.\n    \"\"\"\n    test_cases = [1e-8, 0.0, 1e-4]\n    m, n = 5, 3\n    b = np.array([1., -3., 2., 0., 0.])\n    \n    results = []\n\n    for epsilon in test_cases:\n        # 1. Construct the matrix A for the given epsilon\n        A = np.zeros((m, n), dtype=float)\n        A[0, 0] = 1.0\n        A[0, 1] = 1.0\n        A[1, 1] = epsilon\n        A[2, 2] = 1.0\n\n        # 2. Compute ranks and condition numbers\n        rank_A = np.linalg.matrix_rank(A)\n        G = A.T @ A\n        rank_G = np.linalg.matrix_rank(G)\n        \n        # Condition number is Inf for singular matrices\n        cond_A = np.linalg.cond(A, 2)\n        cond_G = np.linalg.cond(G, 2)\n      \n        # 3. Solve via Normal Equations\n        if rank_G  n:\n            res_norm_NE = np.nan\n        else:\n            try:\n                x_NE = np.linalg.solve(G, A.T @ b)\n                res_norm_NE = np.linalg.norm(A @ x_NE - b, 2)\n            except np.linalg.LinAlgError:\n                # Fails if G is singular despite rank check, due to floating point limits\n                res_norm_NE = np.nan\n\n        # 4. Solve via QR with column pivoting\n        Q, R, p_indices, r_QR = qr_pivot_mgs(A)\n        \n        c = Q.T @ b\n        \n        y = np.zeros(n)\n        if r_QR > 0:\n            # Solve the reduced upper-triangular system\n            R_r = R[:r_QR, :r_QR]\n            c_r = c[:r_QR]\n            y_r = back_substitution(R_r, c_r)\n            y[:r_QR] = y_r\n        \n        # Un-permute the solution vector y to get x_QR\n        x_QR = np.zeros(n)\n        x_QR[p_indices] = y\n        \n        res_norm_QR = np.linalg.norm(A @ x_QR - b, 2)\n        sol_norm_QR = np.linalg.norm(x_QR, 2)\n\n        # 5. Assemble and store results for this case\n        case_result = [\n            rank_A,\n            rank_G,\n            r_QR,\n            cond_A,\n            cond_G,\n            res_norm_NE,\n            res_norm_QR,\n            sol_norm_QR\n        ]\n        results.append(case_result)\n        \n    # Print the final list of lists in the required format.\n    # The str() function provides the specified \"Python-style list-of-lists\" format.\n    print(str(results))\n\nsolve()\n```"
        }
    ]
}