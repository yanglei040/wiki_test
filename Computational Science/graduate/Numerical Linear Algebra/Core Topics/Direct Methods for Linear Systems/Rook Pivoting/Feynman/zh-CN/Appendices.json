{
    "hands_on_practices": [
        {
            "introduction": "高斯消元的每一步，无论采用何种主元策略，其核心都是一个秩-1更新。这个练习将引导你从第一性原理出发，对一个通用的符号矩阵执行单步车选主元（rook pivoting）操作，并推导出其舒尔补（Schur complement）的更新公式 。通过这个过程，你将深刻理解LU分解算法背后的底层代数结构，这是掌握更复杂数值线性代数技巧的基石。",
            "id": "3575125",
            "problem": "设 $A \\in \\mathbb{F}^{4 \\times 4}$ 是一个符号矩阵，其元素为 $a_{rs}$（$r,s \\in \\{1,2,3,4\\}$），其中 $\\mathbb{F}$ 是一个域，例如实数域。考虑执行一步带车选主元（rook pivoting）的LU分解，其中车选主元搜索已将元素 $a_{ij}$ 确定为主元。你应用一个行置换矩阵 $P_1$ 和一个列置换矩阵 $Q_1$ 将 $a_{ij}$ 移动到位置 $(1,1)$，得到 $A^{(1)} = P_1 A Q_1$。定义集合 $\\{1,2,3,4\\}$ 上的置换 $\\pi$ 和 $\\sigma$ 如下：$\\pi(1)=i$，$\\pi(i)=1$，对所有其他 $r$ 有 $\\pi(r)=r$；以及 $\\sigma(1)=j$，$\\sigma(j)=1$，对所有其他 $s$ 有 $\\sigma(s)=s$。置换矩阵由这些置换构建而成：$P_1 = \\sum_{r=1}^{4} e_r e_{\\pi(r)}^{\\top}$ 和 $Q_1 = \\sum_{s=1}^{4} e_{\\sigma(s)} e_s^{\\top}$，其中 $e_k$ 表示 $\\mathbb{F}^{4}$ 中的第 $k$ 个标准基向量。\n\n从高斯消元法的基本定义（即通过单位下三角消元算子左乘作用于 $A^{(1)}$）以及由以 $(1,1)$ 为主元位置所引出的相应分块出发，构建一个精确的序列，该序列包含 $P_1$、$Q_1$、将主元下方第一列元素清零的消元乘子，以及尾部子矩阵的更新。使用以下记法约定，用原始符号元素 $a_{rs}$ 显式地表示更新后的 $3 \\times 3$ 尾部子矩阵的元素：\n- 设 $R = \\{1,2,3,4\\} \\setminus \\{i\\}$ 表示不包括主元行 $i$ 的行索引集合，这些索引按置换 $\\pi$ 排序，从而对应于 $A^{(1)}$ 的第 $2,3,4$ 行。\n- 设 $C = \\{1,2,3,4\\} \\setminus \\{j\\}$ 表示不包括主元列 $j$ 的列索引集合，这些索引按置换 $\\sigma$ 排序，从而对应于 $A^{(1)}$ 的第 $2,3,4$ 列。\n- 用 $A_{R,j} \\in \\mathbb{F}^{3 \\times 1}$ 表示元素为 $a_{rj}$（$r \\in R$）的列向量。\n- 用 $A_{i,C} \\in \\mathbb{F}^{1 \\times 3}$ 表示元素为 $a_{ic}$（$c \\in C$）的行向量。\n- 用 $A_{R,C} \\in \\mathbb{F}^{3 \\times 3}$ 表示元素为 $a_{rc}$（$r \\in R$ 且 $c \\in C$）的子矩阵。\n\n你的任务是，从分块高斯消元法的基本原理出发，推导出在主元 $a_{ij}$ 被移动到 $(1,1)$ 位置并用于消除主元下方的第一列之后，所用的消元乘子以及更新后的 $3 \\times 3$ 尾部子矩阵的精确公式。\n\n最终答案必须是，用原始元素 $a_{rs}$ 表示的、关于更新后的 $3 \\times 3$ 尾部子矩阵的单一闭式解析表达式。",
            "solution": "该问题陈述是数值线性代数中的一个有效练习，要求在带车选主元的一步LU分解的背景下，推导舒尔补更新公式。该问题是自洽的、有科学依据且适定的，其假设主元元素 $a_{ij}$ 非零，这是该过程的标准要求。\n\n任务是推导在将矩阵 $A \\in \\mathbb{F}^{4 \\times 4}$ 的 $(i,j)$ 位置的主元元素 $a_{ij}$ 移动到 $(1,1)$ 位置并执行一步高斯消元后，所用的消元乘子以及更新后的 $3 \\times 3$ 尾部子矩阵。\n\n设初始矩阵为 $A$，其符号元素为 $a_{rs}$，$r,s \\in \\{1,2,3,4\\}$。主元元素是 $a_{ij}$。为了将该主元移动到 $(1,1)$ 位置，我们应用一个行置换和一个列置换。\n\n行置换 $\\pi$ 被定义为交换索引 $1$ 和 $i$ 的对换：$\\pi(1)=i$，$\\pi(i)=1$，对 $k \\in \\{1,2,3,4\\} \\setminus \\{1,i\\}$ 有 $\\pi(k)=k$。相应的置换矩阵是 $P_1$。用 $P_1$ 左乘 $A$ 会交换 $A$ 的第 $1$ 行和第 $i$ 行。\n\n列置换 $\\sigma$ 被定义为交换索引 $1$ 和 $j$ 的对换：$\\sigma(1)=j$，$\\sigma(j)=1$，对 $k \\in \\{1,2,3,4\\} \\setminus \\{1,j\\}$ 有 $\\sigma(k)=k$。相应的置换矩阵是 $Q_1$。用 $Q_1$ 右乘一个矩阵会交换其第 $1$ 列和第 $j$ 列。\n\n置换后的矩阵是 $A^{(1)} = P_1 A Q_1$。$A^{(1)}$ 在 $(1,1)$ 位置的元素由下式给出：\n$$ A^{(1)}_{11} = (P_1 A Q_1)_{11} = a_{\\pi(1), \\sigma(1)} = a_{ij} $$\n这证实了所选主元 $a_{ij}$ 现在处于操作所需的 $(1,1)$ 位置。\n\n我们现在基于 $(1,1)$ 主元将 $A^{(1)}$ 划分为一个 $2 \\times 2$ 的分块结构：\n$$ A^{(1)} = \\begin{pmatrix} a_{11}^{(1)}  A_{12}^{(1)} \\\\ A_{21}^{(1)}  A_{22}^{(1)} \\end{pmatrix} $$\n其中 $a_{11}^{(1)}$ 是一个 $1 \\times 1$ 的标量，$A_{12}^{(1)}$ 是一个 $1 \\times 3$ 的行向量，$A_{21}^{(1)}$ 是一个 $3 \\times 1$ 的列向量，而 $A_{22}^{(1)}$ 是 $3 \\times 3$ 的尾部子矩阵。\n\n我们必须使用问题陈述中提供的记法，将这些分块与原始矩阵 $A$ 的子矩阵联系起来。\n- 主元是 $a_{11}^{(1)} = a_{ij}$。\n- $A^{(1)}$ 第一列的次对角线部分 $A_{21}^{(1)}$，由矩阵 $A$ 的第 $j$ 列的元素组成，其行已按 $\\pi$ 置换。所涉及的行由 $r' \\in \\{2,3,4\\}$ 索引，它们对应于原始行索引 $\\pi(r')$。这个索引集合 $\\{\\pi(2), \\pi(3), \\pi(4)\\}$ 恰好是 $R = \\{1,2,3,4\\} \\setminus \\{i\\}$。问题将 $A_{R,j}$ 定义为元素为 $a_{rj}$（$r \\in R$）的列向量，并按置换 $\\pi$ 排序。因此，$A_{21}^{(1)} = A_{R,j}$。\n- 类似地，$A^{(1)}$ 第一行的非对角线部分 $A_{12}^{(1)}$，由矩阵 $A$ 的第 $i$ 行的元素组成，其列已按 $\\sigma$ 置换。所涉及的列由 $s' \\in \\{2,3,4\\}$ 索引，它们对应于原始列索引 $\\sigma(s')$。这个索引集合 $\\{\\sigma(2), \\sigma(3), \\sigma(4)\\}$ 恰好是 $C = \\{1,2,3,4\\} \\setminus \\{j\\}$。问题将 $A_{i,C}$ 定义为元素为 $a_{ic}$（$c \\in C$）的行向量，并按置换 $\\sigma$ 排序。因此，$A_{12}^{(1)} = A_{i,C}$。\n- $3 \\times 3$ 的尾部子矩阵 $A_{22}^{(1)}$，其元素为 $A^{(1)}_{r's'} = a_{\\pi(r'), \\sigma(s')}$，其中 $r',s' \\in \\{2,3,4\\}$。它的行由 $R$（按 $\\pi$ 排序）索引，列由 $C$（按 $\\sigma$ 排序）索引。这与问题中给出的 $A_{R,C}$ 的定义完全对应。因此，$A_{22}^{(1)} = A_{R,C}$。\n\n因此，分块矩阵为：\n$$ A^{(1)} = \\begin{pmatrix} a_{ij}  A_{i,C} \\\\ A_{R,j}  A_{R,C} \\end{pmatrix} $$\n高斯消元法的第一步是用一个单位下三角消元矩阵 $L_1$ 左乘 $A^{(1)}$，以将第一列中主元下方的元素清零。该矩阵具有以下分块形式：\n$$ L_1 = \\begin{pmatrix} 1  \\mathbf{0}^{\\top} \\\\ -l  I_3 \\end{pmatrix} $$\n其中 $I_3$ 是 $3 \\times 3$ 的单位矩阵，$\\mathbf{0}^{\\top}$ 是 $1 \\times 3$ 的零向量，而 $l$ 是 $3 \\times 1$ 的消元乘子列向量。\n\n将 $L_1$ 应用于 $A^{(1)}$ 得到：\n$$ L_1 A^{(1)} = \\begin{pmatrix} 1  \\mathbf{0}^{\\top} \\\\ -l  I_3 \\end{pmatrix} \\begin{pmatrix} a_{ij}  A_{i,C} \\\\ A_{R,j}  A_{R,C} \\end{pmatrix} = \\begin{pmatrix} a_{ij}  A_{i,C} \\\\ A_{R,j} - l a_{ij}  A_{R,C} - l A_{i,C} \\end{pmatrix} $$\n为了实现消元，左下角的分块必须是零向量：\n$$ A_{R,j} - l a_{ij} = \\mathbf{0} $$\n假设主元 $a_{ij}$ 非零，我们求解乘子向量 $l$：\n$$ l = \\frac{1}{a_{ij}} A_{R,j} = a_{ij}^{-1} A_{R,j} $$\n这些就是消元乘子。\n\n将这个 $l$ 的表达式代回到矩阵乘法的结果中，我们得到经过一步消元后的矩阵：\n$$ L_1 A^{(1)} = \\begin{pmatrix} a_{ij}  A_{i,C} \\\\ \\mathbf{0}  A_{R,C} - (a_{ij}^{-1} A_{R,j}) A_{i,C} \\end{pmatrix} = \\begin{pmatrix} a_{ij}  A_{i,C} \\\\ \\mathbf{0}  A_{R,C} - a_{ij}^{-1} A_{R,j} A_{i,C} \\end{pmatrix} $$\n更新后的 $3 \\times 3$ 尾部子矩阵是右下角的分块，也就是矩阵 $A^{(1)}$ 中主元 $a_{ij}$ 的舒尔补。其公式为：\n$$ A_{\\text{updated}} = A_{R,C} - a_{ij}^{-1} A_{R,j} A_{i,C} $$\n该表达式完全用问题陈述中定义的量来表述，而这些量本身是基于原始符号元素 $a_{rs}$ 定义的。项 $A_{R,j} A_{i,C}$ 表示一个列向量和一个行向量的外积，其结果是一个 $3 \\times 3$ 的秩一矩阵，用于更新原始子矩阵 $A_{R,C}$。",
            "answer": "$$\n\\boxed{A_{R,C} - a_{ij}^{-1} A_{R,j} A_{i,C}}\n$$"
        },
        {
            "introduction": "掌握了理论基础后，将算法应用于具体数值计算是必不可少的实践环节。此练习为你提供了一个结构清晰的$8 \\times 8$矩阵，要求你逐步执行车选主元分解的前几个步骤 。这个过程不仅能让你熟练运用主元的迭代搜索策略，还能让你在实际操作中体会行与列的置换、乘数的计算以及后续矩阵的更新过程，从而巩固对整个算法流程的理解。",
            "id": "3575078",
            "problem": "考虑对矩阵\n$$\nA=\\begin{pmatrix}\n1  2  0  0  0  0  0  0\\\\\n5  0  9  0  0  0  0  0\\\\\n0  6  0  3  0  0  0  0\\\\\n0  0  8  0  4  0  0  0\\\\\n0  0  0  7  0  5  0  0\\\\\n0  0  0  0  6  0  2  0\\\\\n0  0  0  0  0  7  0  1\\\\\n0  0  0  0  0  0  8  0\n\\end{pmatrix}\n$$\n进行带行和列置换的下-上（LU）分解形式的分块高斯消元。\n在活性子矩阵上使用车步主元法（rook pivoting），即通过交替进行行和列搜索的方式，来选择一个在其所在行和所在列中绝对值同时达到最大的元素作为主元。执行第一个分块大小为 $b=3$ 的分块分解，这意味着您必须选择并应用三个主元（可能伴随行和列交换）来分解前导分块。严格遵循带置换的LU分解的标准框架：在分块的第 $k$ 步，操作范围为第 $k$ 行至第 $n$ 行以及第 $k$ 列至第 $n$ 列。如果车步搜索在位置 $(i,j)$（其中 $i\\geq k$ 且 $j\\geq k$）确定了一个主元，则在计算乘子并执行秩-1更新之前，先应用行交换将第 $i$ 行换至第 $k$ 行，并应用列交换将第 $j$ 列换至第 $k$ 列。\n\n完成以下任务，并展示中间矩阵以及由更新产生的精确有理数值：\n\n- 确定在第一个分块中应用的行置换和列置换（将它们按每个主元应用时的顺序，以对换乘积的形式列出）。\n- 计算前三列中的乘子，这些乘子填充了此分块对应的 $L$ 因子的严格下三角部分。\n- 形成第三个主元之后的尾随更新子矩阵，即第4至8行和第4至8列的舒尔补（Schur complement），并明确写出该矩阵。\n\n最后，报告在第一个分块中选出的三个车步主元的绝对值之积。请提供精确值，无需四舍五入。您的最终数值答案必须仅为这三个绝对值的乘积，表示为单个实数，不附加任何评论。",
            "solution": "用户提供了一个数值线性代数领域的有效问题陈述。任务是使用车步主元法对一个给定的 $8 \\times 8$ 矩阵 $A$ 执行 LU 分解的前三个步骤（$b=3$）。我将执行所要求的步骤，并使用精确有理数运算显示所有中间计算过程。\n\n初始矩阵为：\n$$ A^{(1)} = A = \\begin{pmatrix}\n1  2  0  0  0  0  0  0\\\\\n5  0  9  0  0  0  0  0\\\\\n0  6  0  3  0  0  0  0\\\\\n0  0  8  0  4  0  0  0\\\\\n0  0  0  7  0  5  0  0\\\\\n0  0  0  0  6  0  2  0\\\\\n0  0  0  0  0  7  0  1\\\\\n0  0  0  0  0  0  8  0\n\\end{pmatrix} $$\n\n该过程包括三个步骤（$k=1, 2, 3$）。\n\n**第1步：第一个主元（$k=1$）**\n\n活性子矩阵是整个矩阵 $A^{(1)}$。我们从左上角元素 $A^{(1)}_{1,1} = 1$ 开始进行车步主元搜索。\n1.  第1行中的最大绝对值为 $|A^{(1)}_{1,2}| = 2$。搜索移动到第2列。\n2.  第2列中的最大绝对值为 $|A^{(1)}_{3,2}| = 6$。搜索移动到第3行。\n3.  第3行中的最大绝对值为 $|A^{(1)}_{3,2}| = 6$。搜索停留在第2列。\n4.  第2列中的最大绝对值为 $|A^{(1)}_{3,2}| = 6$。搜索已经稳定。\n\n第一个主元是 $p_1 = 6$，位于 $(i,j) = (3,2)$。\n为了将该主元移到位置 $(1,1)$，我们应用行置换 $P_1 = (1,3)$ 和列置换 $Q_1 = (1,2)$。\n将这些置换应用于 $A^{(1)}$：\n$$ A_{perm}^{(1)} = P_1 A^{(1)} Q_1 = \\begin{pmatrix}\n6  0  0  3  0  0  0  0\\\\\n0  5  9  0  0  0  0  0\\\\\n2  1  0  0  0  0  0  0\\\\\n0  0  8  0  4  0  0  0\\\\\n0  0  0  7  0  5  0  0\\\\\n0  0  0  0  6  0  2  0\\\\\n0  0  0  0  0  7  0  1\\\\\n0  0  0  0  0  0  8  0\n\\end{pmatrix} $$\n第一列的乘子计算公式为 $l_{i1} = A_{perm, i1}^{(1)}/p_1$（对于 $i > 1$）。在对角线下方的第一列中，唯一的非零元素是 $A_{perm, 31}^{(1)} = 2$。\n乘子向量为 $l_1 = [0, 1/3, 0, 0, 0, 0, 0]^T$。\n秩-1更新会影响尾随子矩阵 $A^{(1)}_{perm}[2:8, 2:8]$。更新操作为 $A_{22} \\leftarrow A_{22} - l_1 u_1^T$，其中 $u_1^T = A_{perm}^{(1)}[1, 2:8] = [0, 0, 3, 0, 0, 0, 0]$。\n在外积 $l_1 u_1^T$ 中唯一的非零项对应于 $l_{31} \\cdot u_{14} = (1/3) \\cdot 3 = 1$。这会更新全局位置 $(3,4)$ 处的元素。\n得到的矩阵（乘子存储在第一列中）为：\n$$ A^{(2)} = \\begin{pmatrix}\n6  0  0  3  0  0  0  0\\\\\n0  5  9  0  0  0  0  0\\\\\n1/3  1  0  -1  0  0  0  0\\\\\n0  0  8  0  4  0  0  0\\\\\n0  0  0  7  0  5  0  0\\\\\n0  0  0  0  6  0  2  0\\\\\n0  0  0  0  0  7  0  1\\\\\n0  0  0  0  0  0  8  0\n\\end{pmatrix} $$\n\n**第2步：第二个主元（$k=2$）**\n\n活性子矩阵是 $A^{(2)}[2:8, 2:8]$。我们从 $A^{(2)}_{2,2}=5$ 开始搜索主元。\n1.  子矩阵的第一行（即全局第2行）中的最大绝对值为 $|A^{(2)}_{2,3}| = 9$。搜索移动到子矩阵的第二列（即全局第3列）。\n2.  该子矩阵列中的最大绝对值为 $|A^{(2)}_{2,3}| = 9$。搜索已经稳定。\n\n第二个主元是 $p_2 = 9$，位于全局位置 $(i,j) = (2,3)$。\n为了将其移到位置 $(2,2)$，我们应用 $k=2$ 时的置换。行 $i=2$ 已经是正确的，所以 $P_2 = I$。我们交换列 $j=3$ 和 $k=2$，所以 $Q_2 = (2,3)$。\n将 $Q_2$ 应用于 $A^{(2)}$：\n$$ A_{perm}^{(2)} = A^{(2)} Q_2 = \\begin{pmatrix}\n6  0  0  3  0  0  0  0\\\\\n0  9  5  0  0  0  0  0\\\\\n1/3  0  1  -1  0  0  0  0\\\\\n0  8  0  0  4  0  0  0\\\\\n0  0  0  7  0  5  0  0\\\\\n0  0  0  0  6  0  2  0\\\\\n0  0  0  0  0  7  0  1\\\\\n0  0  0  0  0  0  8  0\n\\end{pmatrix} $$\n第二列的乘子来自 $A_{perm}^{(2)}[3:8, 2]/p_2$。唯一的非零项是 $A_{perm, 42}^{(2)}=8$。\n乘子向量为 $l_2 = [0, 8/9, 0, 0, 0, 0]^T$。\n更新操作为 $A_{33} \\leftarrow A_{33} - l_2 u_2^T$，其中 $u_2^T = A_{perm}^{(2)}[2, 3:8] = [5, 0, 0, 0, 0, 0]$。\n在 $l_2 u_2^T$ 中唯一的非零项对应于 $l_{42} \\cdot u_{23} = (8/9) \\cdot 5 = 40/9$。这会更新全局位置 $(4,3)$。$A^{(3)}_{4,3} = A_{perm, 43}^{(2)} - 40/9 = 0 - 40/9 = -40/9$。\n矩阵变为：\n$$ A^{(3)} = \\begin{pmatrix}\n6  0  0  3  0  0  0  0\\\\\n0  9  5  0  0  0  0  0\\\\\n1/3  0  1  -1  0  0  0  0\\\\\n0  8/9  -40/9  0  4  0  0  0\\\\\n0  0  0  7  0  5  0  0\\\\\n0  0  0  0  6  0  2  0\\\\\n0  0  0  0  0  7  0  1\\\\\n0  0  0  0  0  0  8  0\n\\end{pmatrix} $$\n\n**第3步：第三个主元（$k=3$）**\n\n活性子矩阵是 $A^{(3)}[3:8, 3:8]$。我们从 $A^{(3)}_{3,3}=1$ 开始搜索主元。\n1.  子矩阵的第一行（全局第3行）中的最大绝对值为 $|-1|=1$，存在相等情况。我们可以停留在第一列（全局第3列）。\n2.  该子矩阵列中的最大绝对值为 $|A^{(3)}_{4,3}| = |-40/9| \\approx 4.44$。搜索移动到子矩阵的第二行（全局第4行）。\n3.  该子矩阵行（全局第4行）中的最大绝对值为 $|-40/9|$，因为 $|-40/9|>|4|$。搜索停留在当前列。\n4.  搜索已经稳定。\n\n第三个主元是 $p_3 = -40/9$，位于全局位置 $(i,j) = (4,3)$。\n为了将其移到位置 $(3,3)$，我们交换行 $i=4$ 和 $k=3$，所以 $P_3=(3,4)$。列 $j=3$ 是正确的，所以 $Q_3=I$。\n将 $P_3$ 应用于 $A^{(3)}$ 会交换第3行和第4行，包括已存储的乘子：\n$$ A_{perm}^{(3)} = P_3 A^{(3)} = \\begin{pmatrix}\n6  0  0  3  0  0  0  0\\\\\n0  9  5  0  0  0  0  0\\\\\n0  8/9  -40/9  0  4  0  0  0\\\\\n1/3  0  1  -1  0  0  0  0\\\\\n0  0  0  7  0  5  0  0\\\\\n0  0  0  0  6  0  2  0\\\\\n0  0  0  0  0  7  0  1\\\\\n0  0  0  0  0  0  8  0\n\\end{pmatrix} $$\n乘子为 $l_{i3} = A_{perm, i3}^{(3)}/p_3$（对于 $i > 3$）。唯一的非零项是 $A_{perm, 43}^{(3)}=1$。\n乘子向量为 $l_3 = [1/(-40/9), 0, ...]^T = [-9/40, 0, 0, 0, 0]^T$。\n更新操作为 $A_{44} \\leftarrow A_{44} - l_3 u_3^T$，其中 $u_3^T = A_{perm}^{(3)}[3, 4:8] = [0, 4, 0, 0, 0]$。\n在 $l_3 u_3^T$ 中唯一的非零项是 $l_{43} \\cdot u_{35} = (-9/40) \\cdot 4 = -36/40 = -9/10$。这会更新全局位置 $(4,5)$。$A^{(4)}_{4,5} = A_{perm, 45}^{(3)} - (-9/10) = 0 + 9/10 = 9/10$。\n\n**结果总结**\n\n1.  **行和列置换**：\n    - 第1步 ($k=1$)：行置换 $P_1=(1,3)$，列置换 $Q_1=(1,2)$。\n    - 第2步 ($k=2$)：行置换 $P_2=I$ (单位阵)，列置换 $Q_2=(2,3)$。\n    - 第3步 ($k=3$)：行置换 $P_3=(3,4)$，列置换 $Q_3=I$ (单位阵)。\n\n2.  **L因子中的乘子**：\n    填充前三列对应的L因子严格下三角部分的乘子是：\n    - 第1列：$l_{41}=1/3$。所有其他 $l_{i1}=0$（对于 $i>1$）。\n    - 第2列：$l_{32}=8/9$。所有其他 $l_{i2}=0$（对于 $i>2$）。\n    - 第3列：$l_{43}=-9/40$。所有其他 $l_{i3}=0$（对于 $i>3$）。\n\n3.  **尾随更新子矩阵（舒尔补）**：\n    这是子矩阵 $A^{(4)}[4:8, 4:8]$。根据最终的更新，它为：\n    $$ S = \\begin{pmatrix}\n    -1  9/10  0  0  0\\\\\n    7  0  5  0  0\\\\\n    0  6  0  2  0\\\\\n    0  0  7  0  1\\\\\n    0  0  0  8  0\n    \\end{pmatrix} $$\n\n**最终计算**\n\n选出的三个主元是 $p_1=6$，$p_2=9$ 和 $p_3=-40/9$。\n它们的绝对值之积是：\n$$ |p_1| \\cdot |p_2| \\cdot |p_3| = |6| \\cdot |9| \\cdot \\left|-\\frac{40}{9}\\right| = 6 \\cdot 9 \\cdot \\frac{40}{9} = 6 \\cdot 40 = 240 $$\n这就是所要求的最终数值答案。",
            "answer": "$$\n\\boxed{240}\n$$"
        },
        {
            "introduction": "车选主元策略为何值得我们学习？它的真正价值在于其在数值稳定性与计算成本之间取得了精妙的平衡，尤其是在处理某些“困难”矩阵时，其表现优于更常见的部份主元法（partial pivoting）。这个综合性的编程实践旨在让你通过编写代码和设计数值实验来亲身验证这一点 。你将实现两种主元策略，并在一系列精心挑选的病态矩阵上进行测试，通过比较元素增长因子和后向误差，直观地揭示车选主元的优越性。",
            "id": "3575115",
            "problem": "实现两种针对非奇异方阵的高斯消去法求解器：一种使用部分（行）主元法，另一种使用车选主元法。从高斯消去法的基本定义出发，该方法将一个矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 分解为三角因子和置换矩阵，使得 $P A = L U$（部分主元法）或 $P A Q = L U$（车选主元法）成立。其中，$P$ 和 $Q$ 是置换矩阵，$L$ 是单位下三角矩阵，$U$ 是上三角矩阵。车选主元策略选择的主元在其当前列中是绝对值最大的元素，并且在交替搜索后，在其对应的行中（在活动子矩阵内）也是绝对值最大的元素。您必须从第一性原理出发实现这两种策略，不得调用库中的分解例程。\n\n使用这两个求解器，对一系列日益病态的矩阵进行经验性研究，并找出部分主元法“失效”而车选主元法仍能保持可接受的范数反向误差的情形。“失效”的概念必须从基于反向误差和元素增长的第一性原理推导得出。具体而言：\n\n- 对于 $A x = b$ 的计算解 $\\hat{x}$，定义范数反向误差\n$$\n\\eta(A,b,\\hat{x}) = \\frac{\\lVert b - A \\hat{x}\\rVert_{2}}{\\lVert A\\rVert_{2}\\,\\lVert \\hat{x}\\rVert_{2} + \\lVert b\\rVert_{2}},\n$$\n该误差衡量了使 $\\hat{x}$ 成为精确解所需的最小相对扰动。这是衡量可接受数值行为的基础指标。\n\n- 定义元素增长因子\n$$\n\\rho = \\frac{\\max_{i,j} |U_{ij}|}{\\max_{i,j} |A_{ij}|},\n$$\n该因子衡量消去过程中元素的放大程度，可作为实际的风险指标。\n\n对于每个测试用例，使用精确的右端项 $b = A \\,\\mathbf{1}$，其中 $\\mathbf{1} \\in \\mathbb{R}^{n}$ 是全为 1 的向量。使用部分主元法计算 $\\hat{x}_{\\mathrm{pp}}$，使用车选主元法计算 $\\hat{x}_{\\mathrm{rook}}$，并评估 $\\eta(A,b,\\hat{x}_{\\mathrm{pp}})$、$\\eta(A,b,\\hat{x}_{\\mathrm{rook}})$ 以及在部分主元分解过程中观察到的增长因子 $\\rho_{\\mathrm{pp}}$。如果部分主元法的反向误差超过固定容差或观察到的增长因子超过固定界限，则宣布部分主元法“失效”；而如果车选主元法的反向误差在容差范围内，则认为其“可接受”。使用以下接受标准：\n- 可接受的反向误差容差：$\\eta \\le 5\\times 10^{-12}$。\n- 部分主元法失效的增长阈值：$\\rho_{\\mathrm{pp}} > 10^{3}$。\n\n测试矩阵族。构建以下参数化、确定性的矩阵族（其定义中使用基于 1 的索引，必须小心地将其映射到基于 0 的程序索引）：\n\n- 阶为 $n$ 的 Wilkinson 矩阵 $W_{n}$：\n$$\n(W_n)_{ij} = \\begin{cases}\n1,  i \\le j,\\\\\n-1,  i > j.\n\\end{cases}\n$$\n\n- 阶为 $n$ 的 Lotkin 矩阵 $L_{n}$：\n$$\n(L_n)_{1j} = 1 \\text{ for } 1 \\le j \\le n, \\quad (L_n)_{ij} = \\frac{1}{i + j - 1} \\text{ for } 2 \\le i \\le n, \\, 1 \\le j \\le n.\n$$\n\n- 节点为 $\\{t_i\\}_{i=1}^n$ 的阶为 $n$ 的 Vandermonde 矩阵 $V_{n}(\\alpha)$：\n$$\nt_i = \\alpha_0 + \\frac{i-1}{n-1}(\\alpha_1 - \\alpha_0), \\quad 0  \\alpha_0  \\alpha_1  1, \\quad V_{ij} = t_i^{\\,j-1}.\n$$\n所有 Vandermonde 测试均使用 $(\\alpha_0,\\alpha_1)=(0.9,1.0)$。\n\n- 带参数 $s \\in (0,1)$ 和 $c = \\sqrt{1 - s^{2}}$ 的阶为 $n$ 的 Kahan 型上三角矩阵族 $K_{n}(s)$：\n$$\n(K_n(s))_{ii} = 1 \\text{ for } 1 \\le i \\le n,\\quad (K_n(s))_{ij} = -c \\text{ for } 1 \\le i  j \\le n,\\quad (K_n(s))_{i1} = s^{\\,i-1} \\text{ for } 1 \\le i \\le n.\n$$\n此处明确定义该矩阵族，以提供一个额外的、可调的三角矩阵案例。\n\n您的程序必须实现：\n- 一个部分主元高斯消去法，返回 $P$、$L$、$U$、作为索引映射的行置换以及元素增长因子 $\\rho_{\\mathrm{pp}}$。\n- 一个车选主元高斯消去法，返回 $P$、$Q$、$L$、$U$、行和列索引映射及其元素增长因子 $\\rho_{\\mathrm{rook}}$。\n\n使用前向和后向替换法求解分解所蕴含的三角系统，注意根据 $P A = L U$（部分）和 $P A Q = L U$（车选）正确应用 $P$ 和 $Q$。为每个求解器在每个测试中计算 $\\eta$。\n\n测试套件。为确保覆盖良性、临界和对抗性情况，请运行以下七个案例：\n\n- 案例 1：Wilkinson 矩阵，$n=8$。\n- 案例 2：Wilkinson 矩阵，$n=16$。\n- 案例 3：Lotkin 矩阵，$n=8$。\n- 案例 4：Lotkin 矩阵，$n=12$。\n- 案例 5：Vandermonde 矩阵，$n=10$，$(\\alpha_0,\\alpha_1)=(0.9,1.0)$。\n- 案例 6：Vandermonde 矩阵，$n=12$，$(\\alpha_0,\\alpha_1)=(0.95,1.0)$。\n- 案例 7：Kahan 型矩阵，$n=12$，$s=0.99$。\n\n对于每个案例，输出指标\n$$\n\\mathsf{flag} = \\begin{cases}\n1,  \\text{如果部分主元法失效且车选主元法具有可接受的反向误差},\\\\\n0,  \\text{其他情况}.\n\\end{cases}\n$$\n具体来说，“部分主元法失效”意味着 $\\eta(A,b,\\hat{x}_{\\mathrm{pp}})  5\\times 10^{-12}$ 或 $\\rho_{\\mathrm{pp}}  10^{3}$，“车选主元法可接受”意味着 $\\eta(A,b,\\hat{x}_{\\mathrm{rook}}) \\le 5\\times 10^{-12}$。\n\n最终输出格式。您的程序应生成单行输出，其中包含七个标志，格式为方括号内以逗号分隔的列表（例如，“[0,1,0,0,0,0,0]”），按顺序对应案例 1 到 7。本任务不涉及物理单位或角度。所有数值比较都应使用标准双精度浮点数进行。",
            "solution": "用户提供的问题被评估为有效。这是一个适定的、有科学依据的数值线性代数问题，具有清晰、客观的标准和一套完整的规范。任务是实现并经验性地比较带部分主元的高斯消去法和带车象主元的高斯消去法，重点关注前者表现出数值不稳定性而后者保持稳定的场景。\n\n### 1. 带主元的高斯消去法原理\n\n高斯消去法是求解线性系统 $A x = b$ 的基本算法，其中 $A \\in \\mathbb{R}^{n \\times n}$ 是一个非奇异方阵。其核心思想是将矩阵 $A$ 分解为一个下三角矩阵 $L$ 和一个上三角矩阵 $U$ 的乘积。为了确保数值稳定性，尤其是在处理病态矩阵时，该过程会辅以主元法，即交换矩阵的行和/或列。\n\n对于部分（行）主元法，分解形式为 $P A = L U$；对于涉及列交换的策略（如车象主元法），分解形式为 $P A Q = L U$。这里，$P$ 和 $Q$ 是置换矩阵，$L$ 是单位下三角矩阵（对角线元素为 1），$U$ 是上三角矩阵。该过程在 $A$ 的一个副本上就地执行。经过 $k-1$ 步后，矩阵 $A^{(k-1)}$ 的前 $k-1$ 列已经最终确定。在第 $k$ 步（对于 $k=0, \\dots, n-2$），从活动子矩阵 $A^{(k-1)}_{k:n, k:n}$ 中选择一个主元。经过行和/或列交换后，主元位于位置 $(k,k)$。然后，根据主元下方第 $k$ 列的元素计算乘数，并用这些乘数将主元行乘以适当倍数后从后续行中减去，从而在第 $k$ 列对角线下方引入零。\n\n### 2. 主元策略\n\n#### 2.1. 部分（行）主元法\n\n部分主元法是最常见的策略。在消去的每一步 $k$，算法在当前主元列中、对角线及其下方搜索绝对值最大的元素。\n设活动矩阵为 $A$。在第 $k$ 步（$k \\in \\{0, \\dots, n-2\\}$），我们找到一个索引 $p \\ge k$ 使得：\n$$ |A_{pk}| = \\max_{i=k, \\dots, n-1} |A_{ik}| $$\n然后交换第 $k$ 行和第 $p$ 行。这个置换被记录在一个置换矩阵 $P$ 中（或更高效地，一个置换向量中）。其目标是使乘数 $m_{ik} = A_{ik}/A_{kk}$ 的绝对值尽可能小（即 $|m_{ik}| \\le 1$），这有助于控制消去过程中元素的增长。\n\n得到的分解是 $PA = LU$。\n\n#### 2.2. 车选主元法\n\n车选主元法是一种更强健但计算成本更高的主元策略。它旨在找到一个在活动子矩阵内既是其所在行的最大值又是其所在列的最大值的主元。这是通过迭代搜索实现的。在第 $k$ 步，设活动子矩阵为 $A_{k:n, k:n}$。\n\n搜索过程如下：\n1. 初始化一个候选主元，例如在 $(p, q) = (k, k)$。\n2. 在当前主元的列 $q$ 中（在行 $i \\ge k$ 中）搜索绝对值最大的元素。设其位置为 $(p', q)$。如果此元素大于当前主元 $|A_{pq}|$，则更新主元行：$p \\leftarrow p'$。\n3. 在新更新的主元行 $p$ 中（在列 $j \\ge k$ 中）搜索绝对值最大的元素。设其位置为 $(p, q')$。\n4. 如果此元素大于当前主元 $|A_{pq}|$，则更新主元列：$q \\leftarrow q'$，并返回第 2 步。\n5. 如果主元 $|A_{pq}|$ 是其列中（从第 2 步）绝对值最大的元素，则搜索稳定并终止。元素 $A_{pq}$ 被选为主元。\n\n一旦选定位于 $(p, q)$ 的主元，就交换第 $k$ 行与第 $p$ 行，以及第 $k$ 列与第 $q$ 列。这些置换被记录在矩阵 $P$ 和 $Q$ 中。得到的分解是 $PAQ = LU$。\n\n### 3. 求解线性系统\n\n一旦计算出 LU 分解，求解 $Ax=b$ 的过程分两个阶段进行，即前向和后向替换法。\n\n- **对于部分主元法 ($PA=LU$)**：系统 $Ax=b$ 被重写为 $LUx = Pb$。\n    1. 计算置换后的右端向量 $b' = Pb$。\n    2. 对下三角系统 $Ly = b'$ 求解 $y$（前向替换法）。\n    3. 对上三角系统 $Ux = y$ 求解 $x$（后向替换法）。\n\n- **对于车选主元法 ($PAQ=LU$)**：系统 $Ax=b$ 被重写为 $LU(Q^T x) = Pb$。令 $z = Q^T x$。\n    1. 计算 $b' = Pb$。\n    2. 对 $Lz = b'$ 求解 $z$（前向替换法）。\n    3. 对 $Uy = z$ 求解 $y$（后向替换法）。\n    4. 通过应用列置换恢复解 $x$：$x = Qy$。\n\n### 4. 数值稳定性评估\n\n数值解的质量和稳定性通过两个指标进行评估。\n\n- **元素增长因子 ($\\rho$)**：定义为\n  $$ \\rho = \\frac{\\max_{i,j} |U_{ij}|}{\\max_{i,j} |A_{ij}|} $$\n  大的增长因子表明消去过程中的中间值变得比初始矩阵元素大得多，这是舍入误差放大的主要来源。问题为部分主元法指定了失效阈值 $\\rho_{\\mathrm{pp}}  10^3$。\n\n- **范数反向误差 ($\\eta$)**：对于一个计算解 $\\hat{x}$，其反向误差为\n  $$ \\eta(A,b,\\hat{x}) = \\frac{\\lVert b - A \\hat{x}\\rVert_{2}}{\\lVert A\\rVert_{2}\\,\\lVert \\hat{x}\\rVert_{2} + \\lVert b\\rVert_{2}} $$\n  这个量度衡量了使 $\\hat{x}$ 成为问题 $(A, b)$ 的一个精确解所需的最小相对扰动。它是对计算解质量的直接度量，与问题的条件数无关。问题指定了可接受的容差为 $\\eta \\le 5 \\times 10^{-12}$。\n\n### 5. 方法论\n\n对于七个测试用例中的每一个，执行以下步骤：\n1. 构建指定的大小为 $n \\times n$ 的测试矩阵 $A$。\n2. 将右端向量设为 $b = A\\mathbf{1}$，其中 $\\mathbf{1}$ 是全为 1 的向量。因此，精确解为 $x = \\mathbf{1}$。\n3. 使用实现的带部分主元的高斯消去法求解系统，得到 $\\hat{x}_{\\mathrm{pp}}$ 和增长因子 $\\rho_{\\mathrm{pp}}$。\n4. 使用带车象主元的高斯消去法求解系统，得到 $\\hat{x}_{\\mathrm{rook}}$。\n5. 计算反向误差 $\\eta_{\\mathrm{pp}} = \\eta(A,b,\\hat{x}_{\\mathrm{pp}})$ 和 $\\eta_{\\mathrm{rook}} = \\eta(A,b,\\hat{x}_{\\mathrm{rook}})$。\n6. 如果部分主元法被认为“失效”而车象主元法“可接受”，则将标志设为 $1$，否则设为 $0$。部分主元法的“失效”定义为 $\\eta_{\\mathrm{pp}}  5 \\times 10^{-12}$ 或 $\\rho_{\\mathrm{pp}}  10^3$。车象主元法的“可接受”定义为 $\\eta_{\\mathrm{rook}} \\le 5 \\times 10^{-12}$。这个逻辑决定了每个案例的最终输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Ensure consistent use of 64-bit floating point numbers.\nDTYPE = np.float64\n\ndef make_wilkinson(n):\n    \"\"\"Constructs the Wilkinson matrix W_n of order n.\"\"\"\n    A = np.ones((n, n), dtype=DTYPE)\n    for i in range(n):\n        for j in range(n):\n            if i  j:\n                A[i, j] = -1.0\n    return A\n\ndef make_lotkin(n):\n    \"\"\"Constructs the Lotkin matrix L_n of order n.\"\"\"\n    A = np.zeros((n, n), dtype=DTYPE)\n    A[0, :] = 1.0\n    for i in range(1, n):\n        for j in range(n):\n            A[i, j] = 1.0 / (i + j + 1)\n    return A\n\ndef make_vandermonde(n, alpha0, alpha1):\n    \"\"\"Constructs a Vandermonde matrix V_n of order n.\"\"\"\n    t = alpha0 + (np.arange(n, dtype=DTYPE) / (n - 1)) * (alpha1 - alpha0)\n    # A[i, j] = t[i]**j\n    return np.power.outer(t, np.arange(n, dtype=DTYPE))\n\ndef make_kahan_type(n, s):\n    \"\"\"Constructs the Kahan-type matrix K_n(s) of order n.\"\"\"\n    A = np.zeros((n, n), dtype=DTYPE)\n    c = np.sqrt(1 - s**2)\n    # Upper triangle\n    for i in range(n):\n        for j in range(i + 1, n):\n            A[i, j] = -c\n    # Diagonal\n    np.fill_diagonal(A, 1.0)\n    # First column\n    for i in range(n):\n        A[i, 0] = s**i\n    return A\n\ndef lu_partial_pivot(A):\n    \"\"\"\n    Performs LU factorization with partial pivoting: P A = L U.\n    Operates in-place on matrix A.\n    Returns:\n        A: Matrix containing L (lower) and U (upper) factors.\n        piv: Permutation vector representing P.\n        rho: Element growth factor.\n    \"\"\"\n    n = A.shape[0]\n    piv = np.arange(n)\n    max_abs_A = np.max(np.abs(A))\n    if max_abs_A == 0:\n        return A, piv, 1.0\n    \n    for k in range(n - 1):\n        # Find pivot in column k\n        max_row_idx = k + np.argmax(np.abs(A[k:, k]))\n        \n        # Swap rows\n        if max_row_idx != k:\n            A[[k, max_row_idx]] = A[[max_row_idx, k]]\n            piv[[k, max_row_idx]] = piv[[max_row_idx, k]]\n            \n        # Check for singularity\n        if A[k, k] == 0:\n            continue\n            \n        # Elimination\n        multipliers = A[k+1:, k] / A[k, k]\n        A[k+1:, k] = multipliers\n        A[k+1:, k+1:] -= np.outer(multipliers, A[k, k+1:])\n        \n    U = np.triu(A)\n    max_abs_U = np.max(np.abs(U))\n    rho = max_abs_U / max_abs_A\n    \n    return A, piv, rho\n\ndef lu_rook_pivot(A):\n    \"\"\"\n    Performs LU factorization with rook pivoting: P A Q = L U.\n    Operates in-place on matrix A.\n    Returns:\n        A: Matrix containing L (lower) and U (upper) factors.\n        piv: Row permutation vector representing P.\n        qiv: Column permutation vector representing Q.\n        rho: Element growth factor.\n    \"\"\"\n    n = A.shape[0]\n    piv = np.arange(n)\n    qiv = np.arange(n)\n    max_abs_A = np.max(np.abs(A))\n    if max_abs_A == 0:\n        return A, piv, qiv, 1.0\n\n    for k in range(n - 1):\n        # Rook pivot search\n        r, c = k, k\n        while True:\n            # Find max in column c\n            r_new = k + np.argmax(np.abs(A[k:, c]))\n            if np.abs(A[r_new, c])  np.abs(A[r, c]):\n                r = r_new\n\n            # Find max in row r\n            c_new = k + np.argmax(np.abs(A[r, k:]))\n            if np.abs(A[r, c_new])  np.abs(A[r, c]):\n                c = c_new\n                continue # Restart search in new column\n            \n            # The search has stabilized\n            break\n            \n        # Swap rows\n        if r != k:\n            A[[k, r]] = A[[r, k]]\n            piv[[k, r]] = piv[[r, k]]\n        \n        # Swap columns\n        if c != k:\n            A[:, [k, c]] = A[:, [c, k]]\n            qiv[[k, c]] = qiv[[c, k]]\n\n        # Check for singularity\n        if A[k, k] == 0:\n            continue\n\n        # Elimination\n        multipliers = A[k+1:, k] / A[k, k]\n        A[k+1:, k] = multipliers\n        A[k+1:, k+1:] -= np.outer(multipliers, A[k, k+1:])\n\n    U = np.triu(A)\n    max_abs_U = np.max(np.abs(U))\n    rho = max_abs_U / max_abs_A\n    \n    return A, piv, qiv, rho\n\ndef solve_lu_system(LU, piv, qiv, b):\n    \"\"\"\n    Solves Ax=b given LU factorization.\n    - Partial pivoting: PA=LU - LUx=Pb\n    - Rook pivoting: PAQ=LU - LU(Q^T x) = Pb\n    \"\"\"\n    n = LU.shape[0]\n    \n    # Apply row permutations to b: y = Pb\n    # piv contains original indices. We need b[piv]\n    b_p = b[piv]\n    \n    # Forward substitution: Lz = b_p\n    # L has ones on diagonal.\n    z = np.zeros(n, dtype=DTYPE)\n    for i in range(n):\n        z[i] = b_p[i] - LU[i, :i] @ z[:i]\n        \n    # Backward substitution: Ux = z (partial) or Uy = z (rook)\n    y = np.zeros(n, dtype=DTYPE)\n    for i in range(n - 1, -1, -1):\n        if LU[i, i] == 0:\n           y[i] = np.inf # singular\n        else:\n           y[i] = (z[i] - LU[i, i+1:] @ y[i+1:]) / LU[i, i]\n           \n    if qiv is None: # Partial pivoting\n        return y\n    else: # Rook pivoting, need to undo column permutations: x = Qy\n        x = np.zeros(n, dtype=DTYPE)\n        x[qiv] = y\n        return x\n\ndef calculate_backward_error(A, b, x_hat):\n    \"\"\"Computes the normwise backward error.\"\"\"\n    n = A.shape[0]\n    if np.all(x_hat == 0): return 0.0\n    \n    # Use machine precision for norms if available, otherwise default to dtype\n    res_norm = np.linalg.norm(b - A @ x_hat, 2)\n    A_norm = np.linalg.norm(A, 2)\n    x_hat_norm = np.linalg.norm(x_hat, 2)\n    b_norm = np.linalg.norm(b, 2)\n    \n    denominator = A_norm * x_hat_norm + b_norm\n    if denominator == 0:\n        return res_norm # or handle as an error\n    \n    return res_norm / denominator\n\ndef solve():\n    \"\"\"Main function to run test cases and produce the final output.\"\"\"\n    \n    test_cases = [\n        {'type': 'wilkinson', 'n': 8},\n        {'type': 'wilkinson', 'n': 16},\n        {'type': 'lotkin', 'n': 8},\n        {'type': 'lotkin', 'n': 12},\n        {'type': 'vandermonde', 'n': 10, 'alpha0': 0.9, 'alpha1': 1.0},\n        {'type': 'vandermonde', 'n': 12, 'alpha0': 0.95, 'alpha1': 1.0},\n        {'type': 'kahan', 'n': 12, 's': 0.99},\n    ]\n\n    results = []\n    \n    ETA_TOLERANCE = 5e-12\n    RHO_THRESHOLD = 1e3\n\n    for case in test_cases:\n        if case['type'] == 'wilkinson':\n            A = make_wilkinson(case['n'])\n        elif case['type'] == 'lotkin':\n            A = make_lotkin(case['n'])\n        elif case['type'] == 'vandermonde':\n            A = make_vandermonde(case['n'], case['alpha0'], case['alpha1'])\n        elif case['type'] == 'kahan':\n            A = make_kahan_type(case['n'], case['s'])\n        \n        n = A.shape[0]\n        # Exact solution is x = [1, 1, ..., 1]^T\n        b = A @ np.ones(n, dtype=DTYPE)\n\n        # Partial Pivoting\n        A_pp = A.copy()\n        LU_pp, piv_pp, rho_pp = lu_partial_pivot(A_pp)\n        x_pp = solve_lu_system(LU_pp, piv_pp, None, b)\n        eta_pp = calculate_backward_error(A, b, x_pp)\n\n        # Rook Pivoting\n        A_rook = A.copy()\n        LU_rook, piv_r, qiv_r, _ = lu_rook_pivot(A_rook)\n        x_rook = solve_lu_system(LU_rook, piv_r, qiv_r, b)\n        eta_rook = calculate_backward_error(A, b, x_rook)\n\n        # Evaluate conditions\n        pp_fails = (eta_pp  ETA_TOLERANCE) or (rho_pp  RHO_THRESHOLD)\n        rook_ok = (eta_rook = ETA_TOLERANCE)\n        \n        flag = 1 if (pp_fails and rook_ok) else 0\n        results.append(flag)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}