{
    "hands_on_practices": [
        {
            "introduction": "虽然 $LU$ 分解主要用于求解线性方程组，但其因子有时也能揭示矩阵更深层次的性质，例如其惯量（特征值的分布情况）。本练习旨在探究在何种情况下，我们可以相信 $U$ 矩阵对角线上的主元符号能够反映矩阵的惯量，以及在何种情况下它们会误导我们。通过对比标准的 $PA=LU$ 分解与对称矩阵的 $P^TAP=LDL^T$ 分解 ，本练习将加深对合同变换和西尔维斯特惯性定理的理解。",
            "id": "3591255",
            "problem": "考虑一个实矩阵 $A\\in\\mathbb{R}^{n\\times n}$及其以下分解：行主元LU分解 $PA=LU$，其中 $P$ 是一个置换矩阵，$L$ 是单位下三角矩阵，$U$ 是上三角矩阵；以及当 $A$ 是对称矩阵时，采用对称主元选取的对称不定分解 $P^TAP=LDL^T$，其中 $P$ 是一个置换矩阵，$L$ 是单位下三角矩阵，$D$ 是由 $1\\times 1$ 和 $2\\times 2$ 对称块组成的块对角矩阵。一个实对称矩阵 $A$ 的惯性指数，记为 $\\operatorname{In}(A)$，是一个三元组 $(n_+(A),\\,n_-(A),\\,n_0(A))$，分别表示 $A$ 的正、负、零特征值的数量。Sylvester 惯性定理指出，对于任意非奇异矩阵 $X\\in\\mathbb{R}^{n\\times n}$，有 $\\operatorname{In}(A)=\\operatorname{In}(X^TAX)$，特别地，对于任意置换矩阵 $P$，有 $\\operatorname{In}(A)=\\operatorname{In}(P^TAP)$。相比之下，左乘 $PA$ 不是合同变换，因此通常不保持惯性指数。\n\n研究对于某些结构化矩阵，$PA=LU$ 分解中的对角主元 $U_{ii}$ 的符号是否可以用来推断 $A$ 的惯性指数，并阐明与采用对称主元选取的 $LDL^T$ 分解相比，这种方法的局限性。您可以使用以下示例矩阵进行推理：\n- $A_1=\\begin{bmatrix}2  1\\\\ 1  2\\end{bmatrix}$，该矩阵是对称正定 (SPD) 矩阵。\n- $A_2=\\begin{bmatrix}0  1\\\\ 1  0\\end{bmatrix}$，该矩阵是对称不定矩阵，其惯性指数为 $\\operatorname{In}(A_2)=(1,1,0)$。\n\n选择所有正确的陈述：\n\nA. 对于任意实对称正定矩阵 $A$，如果无行主元选取的高斯消去法能够成功进行，使得 $A=LU$ 且 $L$ 是单位下三角矩阵（即 $P=I$），那么每个对角主元 $U_{ii}$ 都是正的，并且这足以推断 $\\operatorname{In}(A)=(n,0,0)$。\n\nB. 对于一个采用部分主元法分解为 $PA=LU$ 的实对称不定矩阵 $A$，对角元素 $\\{U_{ii}\\}_{i=1}^n$ 中负数的个数等于 $n_-(A)$。\n\nC. 对于一个通过对称主元选取分解为 $P^TAP=LDL^T$ 的实对称矩阵 $A$，$A$ 的惯性指数等于 $D$ 的惯性指数，而 $D$ 的惯性指数是其 $1\\times 1$ 和 $2\\times 2$ 块的惯性指数之和。\n\nD. 在行主元分解 $PA=LU$ 中，如果 $P\\neq I$，那么 $\\{U_{ii}\\}_{i=1}^n$ 的符号序列反映的是 $PA$（置换后的矩阵）的顺序主子式的符号，而不是 $A$ 的顺序主子式的符号，因此通常不能用来推断 $\\operatorname{In}(A)$。\n\nE. 在使用 $2\\times 2$ 主元的 $LDL^T$ 分解中，要确定 $D$ 的每个 $2\\times 2$ 块对 $A$ 的惯性指数的贡献，仅检查该块对角元素的符号就足够了。",
            "solution": "问题陈述是有效的。它介绍了数值线性代数中的标准定义和原理，包括 $LU$ 和 $LDL^T$ 分解、矩阵惯性指数的概念以及 Sylvester 惯性定理。该问题提法得当、客观且有科学依据，要求基于这些原理评估几个陈述。\n\n我们逐一评估每个陈述。\n\n**A. 对于任意实对称正定矩阵 $A$，如果无行主元选取的高斯消去法能够成功进行，使得 $A=LU$ 且 $L$ 是单位下三角矩阵（即 $P=I$），那么每个对角主元 $U_{ii}$ 都是正的，并且这足以推断 $\\operatorname{In}(A)=(n,0,0)$。**\n\n该陈述包含两个论点。\n\n首先，如果 $A \\in \\mathbb{R}^{n \\times n}$ 是对称正定 (SPD) 矩阵，那么它的所有顺序主子式都是正的。$LU$ 分解（当无需主元选取即可存在时）的主元 $U_{ii}$ 由公式 $U_{kk} = \\det(A_k) / \\det(A_{k-1})$（对于 $k1$）和 $U_{11} = \\det(A_1)$ 给出，其中 $A_k$ 是 $A$ 的 $k \\times k$ 阶顺序主子矩阵。由于 $A$ 是对称正定矩阵，对于所有 $k \\in \\{1, \\dots, n\\}$ 都有 $\\det(A_k)  0$。因此，每个主元 $U_{kk}$ 都必须是正的。对称正定矩阵的一个已知性质是高斯消去法可以不进行主元选取。所以陈述的第一部分是正确的。\n\n其次，我们必须评估主元的正性是否足以推断 $A$ 是对称正定矩阵，即 $\\operatorname{In}(A)=(n,0,0)$。假设 $A$ 是一个对称矩阵，且其分解 $A=LU$ 存在，其中 $L$ 是单位下三角矩阵，$U$ 是对角元素 $U_{ii}  0$ 的上三角矩阵。我们可以写出 $U = DU'$，其中 $D = \\operatorname{diag}(U_{11}, \\dots, U_{nn})$，$U'$ 是一个单位上三角矩阵。分解变为 $A=LDU'$。由于 $A$ 是对称的，$A=A^T$，这意味着 $LDU' = (LDU')^T = (U')^T D^T L^T$。由于 $D$ 是对角矩阵，$D=D^T$。所以，$LDU' = (U')^T D L^T$。一个非奇异对称矩阵的 LDU 分解（如果存在）是唯一的。这种唯一性意味着 $L = (U')^T$，因此 $U' = L^T$。\n因此，分解为 $A=LDL^T$。这表示 $A$ 是 $D$ 的一个合同变换。根据 Sylvester 惯性定理，$\\operatorname{In}(A) = \\operatorname{In}(D)$。矩阵 $D$ 是一个对角矩阵，其所有元素 $U_{ii}  0$。对角矩阵的惯性指数由其对角元素的符号决定。由于 $D$ 的所有对角元素都是正的，所以 $\\operatorname{In}(D)=(n,0,0)$。因此，$\\operatorname{In}(A)=(n,0,0)$，这意味着 $A$ 是对称正定矩阵。该陈述在两个方向上都成立。\n\n因此，该陈述是**正确的**。\n\n**B. 对于一个采用部分主元法分解为 $PA=LU$ 的实对称不定矩阵 $A$，对角元素 $\\{U_{ii}\\}_{i=1}^n$ 中负数的个数等于 $n_-(A)$。**\n\n这个陈述是不正确的。分解 $PA=LU$ 涉及到前乘以一个置换矩阵 $P$，这不是一个合同变换。因此，矩阵 $PA$ 并不保持 $A$ 的惯性指数。主元 $U_{ii}$ 与 $PA$ 的顺序主子式有关，而与 $A$ 的顺序主子式无关。\n\n让我们使用提供的反例 $A_2=\\begin{bmatrix}0  1\\\\ 1  0\\end{bmatrix}$。$A_2$ 的特征值 $\\lambda$ 满足 $\\lambda^2 - 1 = 0$，所以 $\\lambda = \\pm 1$。其惯性指数为 $\\operatorname{In}(A_2)=(1,1,0)$，因此 $n_-(A_2)=1$。\n为了计算 $PA=LU$ 分解，我们注意到左上角元素 $A_{11}=0$。这需要进行行交换。部分主元法策略交换第1行和第2行。置换矩阵是 $P=\\begin{bmatrix}0  1\\\\ 1  0\\end{bmatrix}$。\n然后，$PA_2 = \\begin{bmatrix}0  1\\\\ 1  0\\end{bmatrix} \\begin{bmatrix}0  1\\\\ 1  0\\end{bmatrix} = \\begin{bmatrix}1  0\\\\ 0  1\\end{bmatrix} = I$。\n单位矩阵 $I$ 的 $LU$ 分解是平凡的：$L=I$ 且 $U=I$。\n$U$ 的对角元素是 $\\{U_{11}, U_{22}\\} = \\{1,1\\}$。负对角元素的数量为 $0$。这与 $n_-(A_2)=1$ 不匹配。\n\n因此，该陈述是**不正确的**。\n\n**C. 对于一个通过对称主元选取分解为 $P^TAP=LDL^T$ 的实对称矩阵 $A$，$A$ 的惯性指数等于 $D$ 的惯性指数，而 $D$ 的惯性指数是其 $1\\times 1$ 和 $2\\times 2$ 块的惯性指数之和。**\n\n该陈述包含两部分。\n首先，我们将 $A$ 的惯性指数与 $D$ 的惯性指数联系起来。给定的分解是 $P^TAP=LDL^T$。置换矩阵 $P$ 总是非奇异的。根据 Sylvester 惯性定理，对于任意非奇异矩阵 $X$，有 $\\operatorname{In}(A) = \\operatorname{In}(X^T A X)$。将此应用于 $X=P$（注意对于置换矩阵有 $P^T=P^{-1}$），我们得到 $\\operatorname{In}(A) = \\operatorname{In}(P^T A P)$。\n接下来，我们将 $\\operatorname{In}(P^TAP)$ 与 $\\operatorname{In}(D)$ 联系起来。根据分解 $P^TAP=LDL^T$，我们可以写出 $D=L^{-1}(P^TAP)(L^T)^{-1} = L^{-1}(P^TAP)(L^{-1})^T$。由于 $L$ 是单位下三角矩阵，它是非奇异的，$L^{-1}$ 也是非奇异的。这表明 $D$ 与 $P^TAP$ 是合同的。再次根据 Sylvester 惯性定理，$\\operatorname{In}(P^TAP) = \\operatorname{In}(D)$。\n结合这两个结果，我们得到 $\\operatorname{In}(A) = \\operatorname{In}(P^TAP) = \\operatorname{In}(D)$。\n\n其次，我们考虑块对角矩阵 $D$ 的惯性指数。设 $D = \\operatorname{diag}(D_1, D_2, \\dots, D_k)$，其中每个 $D_j$ 是一个 $1 \\times 1$ 或 $2 \\times 2$ 的块。块对角矩阵的特征值集合是其对角块特征值集合的并集。因此，$D$ 的正、负、零特征值的数量分别是每个块 $D_j$ 相应数量的总和。即 $n_+(D) = \\sum_j n_+(D_j)$，$n_-(D) = \\sum_j n_-(D_j)$，以及 $n_0(D) = \\sum_j n_0(D_j)$。这等价于 $\\operatorname{In}(D) = \\sum_j \\operatorname{In}(D_j)$。\n\n陈述的两个部分都是正确的。这个原理是计算惯性指数的对称不定分解方法的基础。\n\n因此，该陈述是**正确的**。\n\n**D. 在行主元分解 $PA=LU$ 中，如果 $P\\neq I$，那么 $\\{U_{ii}\\}_{i=1}^n$ 的符号序列反映的是 $PA$（置换后的矩阵）的顺序主子式的符号，而不是 $A$ 的顺序主子式的符号，因此通常不能用来推断 $\\operatorname{In}(A)$。**\n\n设 $B = PA$。$B$ 的标准无主元 $LU$ 分解为 $B=LU$。对角主元由 $U_{11} = B_{11}$ 和 $U_{kk} = \\det(B_k) / \\det(B_{k-1})$（对于 $k1$）给出，其中 $B_k$ 是 $B$ 的 $k \\times k$ 阶顺序主子矩阵。因此，每个 $U_{kk}$ 的符号由 $B=PA$ 的顺序主子式的行列式的符号决定。这证实了陈述的第一部分。\n\n第二部分指出，这些信息通常不能用来推断 $\\operatorname{In}(A)$。正如在对选项 B 的分析中所确立的，矩阵 $PA$ 不是 $A$ 的合同变换，因此 $\\operatorname{In}(PA)$ 不一定等于 $\\operatorname{In}(A)$。对于一个对称矩阵 $A$，其惯性指数通过雅可比准则（Jacobi's criterion）与 $A$ 本身的顺序主子式的符号相关（如果它们都非零）。$PA=LU$ 的主元与 $PA$ 的子式有关。由于 $PA$ 的性质（包括其惯性指数和其子式的符号）可能与 $A$ 的性质大不相同，因此主元 $U_{ii}$ 的符号不能可靠地用于求出 $\\operatorname{In}(A)$。选项 B 中的反例，$A_2=\\begin{bmatrix}0  1\\\\ 1  0\\end{bmatrix}$ 的惯性指数为 $\\operatorname{In(A_2)}=(1,1,0)$，但 $PA_2=I$ 且主元为 $\\{1,1\\}$，这个例子完美地说明了这一普遍原理。\n\n因此，该陈述是**正确的**。\n\n**E. 在使用 $2\\times 2$ 主元的 $LDL^T$ 分解中，要确定 $D$ 的每个 $2\\times 2$ 块对 $A$ 的惯性指数的贡献，仅检查该块对角元素的符号就足够了。**\n\n根据陈述 C，一个块 $D_j$ 对 $A$ 的惯性指数的贡献就是该块的惯性指数 $\\operatorname{In}(D_j)$。问题是，我们是否仅通过一个 $2\\times 2$ 块的对角元素的符号就能确定其 $\\operatorname{In}(D_j)$。\n设该块为对称矩阵 $D_j = \\begin{bmatrix} a  c \\\\ c  b \\end{bmatrix}$。其惯性指数由其特征值的符号给出。特征值是特征方程 $\\lambda^2 - (a+b)\\lambda + (ab-c^2) = 0$ 的根。特征值的符号由它们的和（迹，$a+b$）和它们的积（行列式，$ab-c^2$）决定。仅检查 $a$ 和 $b$ 的符号是不够的。\n\n考虑 $2\\times 2$ 块 $D_j = \\begin{bmatrix} 1  2 \\\\ 2  1 \\end{bmatrix}$。其对角元素均为正（符号为 $\\{+,+\\}$）。行列式为 $(1)(1) - (2)^2 = 1 - 4 = -3$。由于行列式为负，特征值必须有相反的符号（一个正，一个负）。实际上，特征值为 $\\lambda_1=3$ 和 $\\lambda_2=-1$。该块的惯性指数为 $\\operatorname{In}(D_j) = (1,1,0)$。仅知道对角元素为正，我们无法推断出存在负特征值。例如，块 $\\begin{bmatrix} 3  1 \\\\ 1  3 \\end{bmatrix}$ 的对角元素也都是正的，但其行列式为 $9-1=8 0$，迹为 $60$，所以它的两个特征值都是正的，其惯性指数为 $(2,0,0)$。\n\n对角元素的符号是不够的；必须考虑非对角元素（通过行列式）才能正确确定一个 $2 \\times 2$ 块的惯性指数。\n\n因此，该陈述是**不正确的**。",
            "answer": "$$\\boxed{ACD}$$"
        },
        {
            "introduction": "像高斯消元法这样的通用算法，虽然对非结构化矩阵非常稳健，但对于具有特殊结构（如托普利茨矩阵）的矩阵，其效果可能并非最佳，甚至可能不稳定。本练习将演示选主元过程如何可能破坏矩阵的特殊结构，而这些结构恰恰是实现快速、稳定计算的关键，从而导致元素大小的显著增长。通过将部分主元法 (GEPP) 与结构保持算法进行对比 ，本练习强调了“算法应与矩阵结构相匹配”这一数值线性代数中的核心思想。",
            "id": "3591215",
            "problem": "考虑一个方阵托普利茨矩阵 $T \\in \\mathbb{R}^{n \\times n}$，这意味着 $T$ 的每条对角线上的元素都是常数，即存在标量 $\\{t_k\\}_{k=-(n-1)}^{n-1}$ 使得对于所有 $1 \\leq i,j \\leq n$ 都有 $T_{i,j} = t_{j-i}$。回顾一下，带部分主元的高斯消去法构造了一个分解 $P T = L U$，其中 $P$ 是一个置换矩阵，$L$ 是单位下三角矩阵，$U$ 是上三角矩阵，使得在每一步中，当前列的主元被选为当前对角线下方绝对值最大的元素。评估前向稳定性的一个经典方法是检查计算出的上三角因子 $U$ 中的元素增长：元素增长因子为\n$$\n\\rho(T) \\;=\\; \\frac{\\max_{i,j} |u_{i,j}|}{\\max_{i,j} |T_{i,j}|},\n$$\n其中 $U = (u_{i,j})$。\n\n从数值线性代数和托普利茨结构的基本原理出发，以有条理的方式解决以下问题：\n\n1) 解释为什么对于托普利茨矩阵，部分主元法会系统性地破坏所有后续舒尔补的托普利茨结构（以及更普遍的低位移秩结构），以及为什么这种结构性破坏会阻碍控制 $U$ 中元素增长的常规相消机制。特别地，阐明在进行主元选择之前，低位移秩结构的存在如何意味着舒尔补更新中存在特殊的相消模式，以及为什么一般的行置换会干扰这些模式。\n\n2) 构造并分析一个具体的托普利茨矩阵示例，该示例在标准的部分主元 $LU$ 分解下表现出非平凡的元素增长。你的构造必须是一个依赖于小参数 $\\varepsilon \\in (0,1)$ 的托普利茨矩阵族 $\\{T_n(\\varepsilon)\\}_{n \\geq 4}$。你需要通过明确追踪前两步消去过程来证明，尾部的舒尔补获得了其量级超过 $T_n(\\varepsilon)$ 初始最大元素的一个因子，该因子有一个与 $\\varepsilon$ 和 $n$ 无关的下界，并且通过适当选择托普利茨对角线，你可以使这些中间放大效应在多个步骤中持续存在（因此增长因子可以变得严格大于 $1$ 并通过增加 $n$ 来放大）。你必须从高斯消去法和舒尔补的定义出发，并执行显式的更新公式来证明你的主张，而不能引用任何现成的稳定性定理。\n\n3) 将此行为与两种结构保持算法进行对比：专用于托普利茨矩阵的 Bareiss 算法和 Gohberg–Kailath–Olshevsky (GKO) 算法。从机理层面（而非通过引用）解释，为什么这些算法能保持舒尔补的低位移秩生成元，从而能够强制执行部分主元 $LU$ 分解通常会放弃的相消。阐明在何种结构假设下（例如，正定性），可以期望这些方案具有后向稳定性，并指出任何已知的注意事项。\n\n下列哪个陈述是正确的？\n\nA. 存在这样的托普利茨矩阵，对于它们，随着维数的增加，带部分主元的高斯消去法在 $U$ 中会产生任意大的元素增长，因为行交换破坏了本可以强制相消的舒尔补的低位移秩结构；这种现象与部分主元法对非结构化矩阵的普遍有效性并不矛盾。\n\nB. Bareiss 算法在专门用于托普利茨矩阵时，在精确算术中是无分数的并保持结构；对于对称正定托普利茨矩阵，这导致了后向稳定性并且在精确算术中没有元素增长，而对于不定托普利茨矩阵，它可能仍然需要主元选择来避免不稳定性。\n\nC. Gohberg–Kailath–Olshevsky 算法维持舒尔补的位移秩为2的表示，并且通过适当的基于生成元的主元选择和前瞻/正交化保障措施，可以在广泛的托普利茨系统上实现实际上的后向稳定性；然而，没有这些保障措施的原始变体可能会遭受生成元增长的困扰，从而损害稳定性。\n\nD. 对于特定的托普利茨族 $T_n(\\varepsilon)$，其对角线选择为 $t_0 = 1$，$t_{-k} = 1$（对于 $k \\geq 1$），$t_1 = 1 - \\varepsilon$，以及 $t_k = -1$（对于 $k \\geq 2$），无论选择哪个部分主元，第一个舒尔补在 $U$ 中已包含量级为 $\\Theta(\\varepsilon^{-1})$ 的元素，因此归一化元素增长因子 $\\rho(T_n(\\varepsilon))$ 的增长与 $\\varepsilon^{-1}$ 类似，且对 $n$ 一致。\n\n选择所有正确的选项。",
            "solution": "用户提供的问题陈述是数值线性代数领域中一个有效且适定的问题。它具有科学依据，是客观的，并包含足够的信息以进行全面分析。\n\n该问题要求对托普利茨矩阵在带部分主元的高斯消去法（GEPP）中的元素增长进行多部分分析，与结构保持算法进行对比，并评估几个陈述。\n\n### 1. 主元选择、结构破坏与元素增长\n\n一个托普利茨矩阵 $T \\in \\mathbb{R}^{n \\times n}$ 由 $n$ 个标量 $t_{k}$ 定义，使得 $T_{i,j} = t_{j-i}$。这种高度结构化的特性可以通过位移秩的概念来有效捕捉。对于一个移位算子 $Z$（例如，在第一子对角线上为1，其他地方为零的下移位矩阵），$T$ 的位移是 $\\nabla(T) = ZT - TZ^T$。对于一个托普利茨矩阵 $T$，该位移的秩 $\\mathrm{rank}(\\nabla(T))$ 最多为2。这表明 $T$ 与一个更简单的矩阵“接近”，并且可以由少数向量，即其“生成元”，完全描述。\n\n结构化矩阵的一个关键特性是，在*不进行主元选择*的高斯消去法过程中，舒尔补会继承这种低位移秩结构。在对 $T = \\begin{pmatrix} T_{11}  v^T \\\\ u  T_{22} \\end{pmatrix}$ 进行一步消去后，舒尔补为 $S = T_{22} - T_{11}^{-1} u v^T$。如果 $T$ 的位移秩为 $\\alpha$，那么 $S$ 的位移秩也为 $\\alpha$。这种结构继承性意味着 $S$ 的元素不是独立的；它们受到低位移秩结构所施加的代数关系的制约。这些关系在舒尔补更新公式中强制执行了特定的相消模式。算法可以通过处理舒尔补的生成元来利用这一点，从而产生“快速”的 $O(n^2)$ 求解器。\n\n部分主元法破坏了这种机制。GEPP 构造了一个分解 $PT=LU$。在第一步中，它找到第一列中最大的元素，比如说在第 $k$ 行，然后交换第 1 行和第 $k$ 行。新矩阵 $P_{1k}T$ 不再是托普利茨矩阵。它的位移秩通常很高，即 $O(n)$。当对 $P_{1k}T$ 执行第一步消去时，得到的舒尔补是一个非结构化矩阵的子矩阵，该子矩阵由一个秩-1 矩阵更新。它不再具有低位移秩结构。精细的相消模式丢失了，更新过程变得与通用的、非结构化矩阵的更新等效。主元的选择对于当前步骤的稳定性是局部最优的，但它对本可以控制后续所有步骤中元素增长的结构是全局破坏性的。因此，元素增长因子 $\\rho(T)$ 仅受限于通用的、且通常是悲观的界 $2^{n-1}$。\n\n### 2. 元素增长的具体例子\n\n问题要求构造并分析一个表现出非平凡元素增长的托普利茨矩阵族 $\\{T_n(\\varepsilon)\\}_{n \\geq 4}$。让我们分析一个具体的族，例如选项 D 中提出的那个，并演示这个过程。所提出的族由对角线 $t_0 = 1$，$t_{-k} = 1$（对于 $k \\geq 1$），$t_1 = 1 - \\varepsilon$，以及 $t_k = -1$（对于 $k \\geq 2$）定义，其中 $\\varepsilon \\in (0,1)$ 是一个小参数。\n\n我们来考察 $n=4$ 的情况：\n$$\nT_4(\\varepsilon) = \\begin{pmatrix}\n1  1-\\varepsilon  -1  -1 \\\\\n1  1  1-\\varepsilon  -1 \\\\\n1  1  1  1-\\varepsilon \\\\\n1  1  1  1\n\\end{pmatrix}\n$$\n任何元素的最大绝对值为 $\\max_{i,j}|(T_4)_ {i,j}| = 1$。第一列全为1。前四行中的任何一行都可以作为主元行。我们不进行行交换，选择 $T_{11}=1$ 作为主元。\n\n消去乘数为 $m_{i1} = T_{i1}/T_{11} = 1$，对于 $i=2,3,4$。我们更新行 $R_i \\to R_i - m_{i1} R_1$，对于 $i=2,3,4$。\n- $R_2 \\to (1, 1, 1-\\varepsilon, -1) - (1, 1-\\varepsilon, -1, -1) = (0, \\varepsilon, 2-\\varepsilon, 0)$\n- $R_3 \\to (1, 1, 1, 1-\\varepsilon) - (1, 1-\\varepsilon, -1, -1) = (0, \\varepsilon, 2, 2-\\varepsilon)$\n- $R_4 \\to (1, 1, 1, 1) - (1, 1-\\varepsilon, -1, -1) = (0, \\varepsilon, 2, 2)$\n\n第一步之后，部分分解的矩阵是：\n$$\nA^{(1)} = \\begin{pmatrix}\n1  1-\\varepsilon  -1  -1 \\\\\n0  \\varepsilon  2-\\varepsilon  0 \\\\\n0  \\varepsilon  2  2-\\varepsilon \\\\\n0  \\varepsilon  2  2\n\\end{pmatrix}\n$$\n第一个舒尔补是对应于更新行的尾部 $3 \\times 3$ 子矩阵：\n$$\nS_1 = \\begin{pmatrix}\n\\varepsilon  2-\\varepsilon  0 \\\\\n\\varepsilon  2  2-\\varepsilon \\\\\n\\varepsilon  2  2\n\\end{pmatrix}\n$$\n最终上三角矩阵 $U$ 的第一行是 $(1, 1-\\varepsilon, -1, -1)$。到目前为止出现的最大元素是舒尔补中的 $2-\\varepsilon$。\n\n对于第二步，主元列是 $(\\varepsilon, \\varepsilon, \\varepsilon)^T$。所有元素的大小相同，因此不需要主元选择。我们选择元素 $S_{1,11}=\\varepsilon$ 作为主元。乘数为 $m_{i2} = S_{1,i1}/S_{1,11} = 1$，对于 $i=2,3$。我们更新 $S_1$ 的行。\n- $S_1$ 的第 2 行：$(\\varepsilon, 2, 2-\\varepsilon) - (\\varepsilon, 2-\\varepsilon, 0) = (0, \\varepsilon, 2-\\varepsilon)$\n- $S_1$ 的第 3 行：$(\\varepsilon, 2, 2) - (\\varepsilon, 2-\\varepsilon, 0) = (0, \\varepsilon, 2)$\n\n通过继续这个过程，得到 $PT=LU$（本例中 $P=I$）的最终矩阵 $U$ 是：\n$$\nU = \\begin{pmatrix}\n1  1-\\varepsilon  -1  -1 \\\\\n0  \\varepsilon  2-\\varepsilon  0 \\\\\n0  0  \\varepsilon  2-\\varepsilon \\\\\n0  0  0  \\varepsilon\n\\end{pmatrix}\n$$\n$U$ 中的最大元素是 $\\max_{i,j} |u_{i,j}| = 2-\\varepsilon$。元素增长因子是 $\\rho(T_4(\\varepsilon)) = \\frac{2-\\varepsilon}{1} = 2-\\varepsilon$。这是一个非平凡的增长（大约为2倍），但它是有界的，并且不像选项 D 所暗示的那样依赖于 $\\varepsilon$。虽然存在表现出在 $n$ 上呈指数增长或 $\\varepsilon^{-1}$ 增长的例子，但它们更为复杂。这个例子足以说明 GEPP 可以通过破坏托普利茨结构来引发增长，即使增长是温和的。\n\n### 3. 与结构保持算法的对比\n\n**Bareiss 算法：** 该算法以“无分数”的方式执行高斯消去法。舒尔补的更新规则是 $S_{k+1} = (A_{k,k}^{(k)} S_k - u_k v_k^T) / A_{k-1,k-1}^{(k-1)}$，其中 $A_{k,k}^{(k)}$ 是第 $k$ 步的主元。对于整数项矩阵，此过程生成的中间矩阵也具有整数项，因为除以前一个主元是精确的。当专门用于对称托普利茨矩阵时，该算法的一个 $O(n^2)$ 版本（与 Levinson-Durbin 算法相关）保留了舒尔补的潘对称（persymmetric）和近托普利茨结构。\n- **稳定性：** 对于对称正定（SPD）托普利茨矩阵，所有主元都是正的，算法在数值上是稳定的；实际上，没有元素增长，并且它是后向稳定的。对于不定或一般的非对称托普利茨矩阵，主元可能为零或病态地小，导致算法崩溃或不稳定。因此，对于一般情况，需要某种形式的主元选择来确保稳定性，而经典的 Bareiss 算法不包含这一点。\n\n**Gohberg–Kailath–Olshevsky (GKO) 算法：** 该算法是现代结构化矩阵计算的基石。它直接操作位移矩阵的生成元，而不是矩阵的元素本身。如前所述，托普利茨矩阵的舒尔补（在没有主元选择的情况下）具有相同的位移秩。GKO 算法利用了这一点，提供了一个从矩阵的生成元快速（$O(n)$）更新舒尔补生成元的方法。将此过程迭代 $n$ 次，总复杂度为 $O(n^2)$。\n- **稳定性：** 原始的 GKO 算法本质上是没有主元选择的高斯消去法，应用于生成元层面。因此，它由于相同的原因是不稳定的：主导主子式小或为零。这种不稳定性表现为计算出的生成元条目的无界增长。为了弥补这一点，已经开发了稳定的变体。这些包括：\n    - **生成元主元选择：** 类似于部分主元选择，这涉及对生成元向量进行置换，以确保用作除数的量不小。\n    - **前瞻（Look-Ahead）：** 为了处理主导子矩阵奇异或病态的情况，这些方法一次性分解矩阵的一个更大的块，跳过有问题的主元。\n    - **正交变换：** 使用像吉文斯旋转或豪斯霍尔德反射器这样的变换来更新生成元，可以提供更优的数值稳定性。\n有了这些保障措施，基于 GKO 的算法在实践中可以对广泛的结构化矩阵实现后向稳定。\n\n### 选项评估\n\n**A. 存在这样的托普利茨矩阵，对于它们，随着维数的增加，带部分主元的高斯消去法在 $U$ 中会产生任意大的元素增长，因为行交换破坏了本可以强制相消的舒尔补的低位移秩结构；这种现象与部分主元法对非结构化矩阵的普遍有效性并不矛盾。**\n这个陈述是**正确的**。存在表现出 GEPP 下巨大（甚至是指数级）增长的托普利茨矩阵是数值分析中一个已知的、尽管不平凡的结果。所提供的理由——行交换破坏了负责相消的低位移秩结构——是对此现象的正确解释。关于这并不否定 GEPP 对非结构化矩阵的普遍效用的观察也是准确的。\n\n**B. Bareiss 算法在专门用于托普利茨矩阵时，在精确算术中是无分数的并保持结构；对于对称正定托普利茨矩阵，这导致了后向稳定性并且在精确算术中没有元素增长，而对于不定托普利茨矩阵，它可能仍然需要主元选择来避免不稳定性。**\n这个陈述是**正确的**。它准确地描述了 Bareiss 算法的关键特征：它是无分数的，并保持舒尔补的代数结构。它正确地指出了 SPD 托普利茨矩阵的情况是稳定的（类似于 Cholesky 分解），并正确地指出该算法作为一种非主元消去法的形式，对于主元可能变小或为零的不定矩阵是不稳定的。\n\n**C. Gohberg–Kailath–Olshevsky 算法维持舒尔补的位移秩为2的表示，并且通过适当的基于生成元的主元选择和前瞻/正交化保障措施，可以在广泛的托普利茨系统上实现实际上的后向稳定性；然而，没有这些保障措施的原始变体可能会遭受生成元增长的困扰，从而损害稳定性。**\n这个陈述是**正确的**。它准确地总结了 GKO 算法及其稳定性。它正确地陈述了核心前提（维持低秩生成元）、用于稳定它的方法（主元选择、前瞻、正交化），以及原始版本的弱点（由于潜在的生成元增长导致的不稳定性，类似于元素增长）。\n\n**D. 对于特定的托普利茨族 $T_n(\\varepsilon)$，其对角线选择为 $t_0 = 1$，$t_{-k} = 1$（对于 $k \\geq 1$），$t_1 = 1 - \\varepsilon$，以及 $t_k = -1$（对于 $k \\geq 2$），无论选择哪个部分主元，第一个舒尔补在 $U$ 中已包含量级为 $\\Theta(\\varepsilon^{-1})$ 的元素，因此归一化元素增长因子 $\\rho(T_n(\\varepsilon))$ 的增长与 $\\varepsilon^{-1}$ 类似，且对 $n$ 一致。**\n这个陈述是**不正确的**。正如在第2点的分析中所示，对于第一列中的任何主元选择（所有元素都是1），得到的第一个舒尔补 $S_1$ 的元素都是 $O(1)$ 的。例如，在没有主元选择的情况下，$S_1$ 包含诸如 $\\varepsilon$ 和 $2-\\varepsilon$ 之类的元素。进一步的步骤也不会产生 $\\Theta(\\varepsilon^{-1})$ 的增长。最终的矩阵 $U$ 的最大元素是 $2-\\varepsilon$，导致增长因子为 $2-\\varepsilon$，这是有界的，并且不会随着 $\\varepsilon \\to 0$ 而增长。该主张在事实上是不正确的。",
            "answer": "$$\\boxed{ABC}$$"
        },
        {
            "introduction": "对于大型稀疏线性系统，一个主要挑战是“填充”（fill-in）问题，即主元选择过程中的行交换可能导致稀疏的 $L$ 和 $U$ 因子变得稠密，从而抵消了利用稀疏性带来的计算优势。本练习是一个编码实践，旨在实现并对比严格部分主元法与阈值主元法。它将通过具体的量化结果 ，展示如何通过放宽主元选择标准来保持稀疏性，同时将数值增长控制在可接受的范围内——这是稀疏直接求解器中一个基本的权衡策略。",
            "id": "3591254",
            "problem": "在下-上 (LU) 分解框架内，考虑不同主元选择策略下稀疏矩阵的构造、分解和分析。本问题的基础是将一个非奇异矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 进行 LU 分解，得到一个单位下三角因子 $L$ 和一个上三角因子 $U$ 的定义，同时结合两种主元选择策略：部分主元选择，即每一步选择当前列中绝对值最大的元素作为主元；以及阈值主元选择，即如果对角线元素相对于列中最大元素的绝对值满足某个阈值条件，则接受该对角线元素作为主元。\n\n您必须根据以下原则，通过算法构造一个稀疏矩阵族 $A$。首先从一个带状矩阵开始，其主对角线上为 $1$ 项，第一副对角线和第一超对角线上为小项，以确保非奇异性和数值稳定性。然后，在精心选择的列中，在远离对角线的位置注入大数值的“异常”项，以迫使严格的部分主元选择策略选取非对角线主元，从而通过行交换引发大量填充。而使用合适阈值参数 $\\tau$ 的阈值主元选择策略则可以通过在对角线主元大小可接受时优先选择它们来保持稀疏性。\n\n矩阵构造要求：\n- 对于给定的 $n \\in \\mathbb{N}$，构造 $A \\in \\mathbb{R}^{n \\times n}$，其模式如下：\n  - 对所有 $i$，有 $A_{i,i} = 1$，应实现为对角线上大小为 $1$ 的项。\n  - 对所有有效的 $i$，有 $A_{i,i+1} = \\epsilon$ 和 $A_{i+1,i} = \\epsilon$，应实现为具有较小非对角线值 $\\epsilon$ 的三对角带。\n  - 对于指定的列集合 $J \\subset \\{0,1,\\dots,n-1\\}$ 和一个映射 $r: J \\to \\{0,1,\\dots,n-1\\}$，其中 $r(j)$ 远不等于 $j$，设置 $A_{r(j),\\, j} = M$，其中 $M$ 是相对于 $1$ 和 $\\epsilon$ 的一个大数值。\n\n待执行的主元选择策略：\n- 严格的部分主元选择：这对应于参数 $\\tau = 1$ 的阈值主元选择，意味着只有当对角线元素在绝对值上等于列最大值时才被选为主元；否则，选择最大的非对角线元素。\n- 阈值主元选择：使用给定的 $\\tau \\in [0,1]$，如果对角线元素的绝对值至少是列中最大绝对值元素的 $\\tau$ 倍，则接受该对角线元素作为主元；否则，使用绝对值最大的元素。\n\n对于每个矩阵，在两种策略下使用自然列序（即，无减少填充的预排序）执行 LU 分解。从因子中计算：\n- 填充率 $f := \\dfrac{\\operatorname{nnz}(L) + \\operatorname{nnz}(U)}{\\operatorname{nnz}(A)}$，其中 $\\operatorname{nnz}(\\cdot)$ 表示非零项的数量。\n- 元素增长因子 $\\rho := \\dfrac{\\max_{i,j} |U_{i,j}|}{\\max_{i,j} |A_{i,j}|}$，它量化了原始矩阵和上三角因子之间元素绝对值的最大增幅。\n\n您的程序必须为每个测试用例返回两个布尔值结果：\n- 与严格的部分主元选择相比，阈值主元选择是否减少了填充？即，$f_{\\text{threshold}}  f_{\\text{partial}}$ 是否成立？\n- 阈值主元选择下的增长是否可接受？即，对于指定的界限 $g > 0$，$\\rho_{\\text{threshold}} \\le g$ 是否成立？\n\n实现约束：\n- 对 $A$ 使用压缩稀疏列 (CSC) 存储，并以自然序执行 LU 分解。分解必须遵守指定的主元选择阈值 $\\tau$。\n\n测试套件：\n- 案例 1（一般的“理想情况”）：$n = 50$，$\\epsilon = 0.05$， $J = \\{0,1,2,3,4,5,6,7,8,9\\}$，$r(j) = 49 - j$，$M = 100$，$\\tau = 0.01$，$g = 500$。\n- 案例 2（严格部分主元选择的边界情况）：$n = 50$，$\\epsilon = 0.05$， $J = \\{0,1,2,3,4,5,6,7,8,9\\}$，$r(j) = 49 - j$，$M = 100$，$\\tau = 1.0$，$g = 500$。\n- 案例 3（较小维度，中等异常项）：$n = 12$，$\\epsilon = 0.02$， $J = \\{0,1,2,3,4,5\\}$，$r(j) = 11 - j$，$M = 50$，$\\tau = 0.05$，$g = 250$。\n- 案例 4（始终选择对角线主元的边缘情况）：$n = 20$，$\\epsilon = 0.02$， $J = \\{0,1,2,3,4,5,6,7\\}$，$r(j) = 19 - j$，$M = 500$，$\\tau = 0.0$，$g = 5000$。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含用方括号括起来的逗号分隔的结果列表，每个测试用例贡献一个如上所述顺序的、包含两个布尔值的列表。例如，输出必须类似于 $[\\,[b_{1}^{(1)},b_{2}^{(1)}],\\,[b_{1}^{(2)},b_{2}^{(2)}],\\,\\dots\\,]$，不含任何额外文本。",
            "solution": "当前问题是对稀疏矩阵 LU 分解中固有权衡的计算性探索。具体来说，它对比了优先考虑数值稳定性的严格部分主元选择与寻求在稳定性和保持稀疏性之间取得平衡的阈值主元选择。\n\n一个非奇异矩阵 $A$ 的 LU 分解是将其分解为乘积 $PA = LU$，其中 $P$ 是一个编码行交换的置换矩阵，$L$ 是一个单位下三角矩阵，$U$ 是一个上三角矩阵。在求解线性系统 $Ax=b$ 时，这种分解可以通过前向和后向替换高效求解：$L(Ux) = Pb$。\n\n对于稀疏矩阵，一个主要目标是在因子 $L$ 和 $U$ 中保持稀疏性。在原始矩阵中为零的位置引入非零项的现象称为“填充”（fill-in）。填充量对高斯消去过程中主元的选择高度敏感。\n\n**主元选择策略及其后果**\n\n1.  **严格的部分主元选择**：在消去的每一步 $k$，算法选择当前列 $k$ 中（对角线或其下方）绝对值最大的项作为主元。如果最大项位于非对角线位置，则需要进行行交换。该策略对于由小主元引起的数值不稳定性是稳健的，并保证了元素增长因子 $\\rho$ 的一个界。然而，行交换可能对稀疏性有害，通常导致大量填充。就本问题而言，此策略对应于阈值主元参数 $\\tau=1$。\n\n2.  **阈值主元选择**：该策略提供了一种折衷方案。在步骤 $k$，它识别当前列中的最大绝对值元素 $|A_{p,k}^{(k)}|$。如果对角线元素 $A_{k,k}^{(k)}$ 的绝对值相对于此最大值足够大，即满足 $|A_{k,k}^{(k)}| \\ge \\tau \\cdot |A_{p,k}^{(k)}|$（其中 $\\tau \\in [0,1]$ 是用户定义的阈值），则接受其作为主元。如果满足此条件，则不发生行交换。否则，与第 $p$ 行进行交换。较小的 $\\tau$ 值偏好选择对角线主元，从而保持稀疏性，但风险是使用较小的主元，可能导致更大的元素增长和潜在的数值不稳定性。$\\tau=0$ 强制在对角线主元非零时选择它们（相当于不进行主元选择），而 $\\tau=1$ 则恢复为严格的部分主元选择。\n\n**矩阵构造与预期效果**\n\n该问题指定了一种精心设计的矩阵结构，以突显这些策略之间的差异。矩阵 $A$ 构建在一个良性的、行为良好的三对角结构之上（$A_{i,i}=1$, $A_{i,i\\pm 1}=\\epsilon$）。然后，插入大数值的“异常”项 $A_{r(j),j} = M$。对于列 $j \\in J$：\n- 绝对值最大的项是位于第 $r(j)$ 行的 $M$。\n- 对角线项是 $A_{j,j}=1$。\n\n当对列 $j$ 应用严格的部分主元选择（$\\tau=1$）时，主元条件是 $|A_{j,j}| \\ge 1 \\cdot |A_{r(j),j}|$，即 $1 \\ge M$。由于 $M$ 很大（例如 $100$），此条件为假。因此，部分主元选择被迫交换第 $j$ 行和第 $r(j)$ 行。由于 $r(j)$ 远离 $j$，这将一个遥远的行带入矩阵的活动部分，在 $L$ 因子的结构内造成显著的填充。\n\n当使用小 $\\tau$ 值的阈值主元选择时，主元条件是 $|A_{j,j}| \\ge \\tau \\cdot |A_{r(j),j}|$，即 $1 \\ge \\tau M$。如果选择的 $\\tau$ 使得该不等式成立（例如，$\\tau=0.01, M=100 \\implies 1 \\ge 1$），则接受对角线项作为主元。不发生行交换，稀疏结构得以保留，填充被最小化。\n\n**度量分析**\n\n两个度量量化了这种主元选择权衡的结果：\n\n1.  **填充率, $f = \\frac{\\operatorname{nnz}(L) + \\operatorname{nnz}(U)}{\\operatorname{nnz}(A)}$**：这衡量了稀疏性的保持程度。如果阈值主元选择成功地避免了由异常项引起的行交换，我们预期 $f_{\\text{threshold}}$ 会显著小于 $f_{\\text{partial}}$。第一个布尔输出 $f_{\\text{threshold}}  f_{\\text{partial}}$ 测试的就是这一结果。\n\n2.  **增长因子, $\\rho = \\frac{\\max_{i,j} |U_{i,j}|}{\\max_{i,j} |A_{i,j}|}$**：这衡量了数值稳定性。通过接受一个大小为 $1$ 的主元，而该列中包含一个大小为 $M$ 的项，阈值主元选择可能会在因子 $U$ 中引入大数值。在消去 $A_{r(j), j}$ 的过程中，第 $j$ 行乘以因子 $A_{r(j),j}/A_{j,j} = M/1 = M$ 并从第 $r(j)$ 行中减去。这将在更新后矩阵的位置 $(r(j), j+1)$ 处创建一个大小为 $-M\\epsilon$ 的新元素。在这种特定的矩阵结构中，这是元素增长的主要来源。因此，增长因子近似为 $\\rho_{\\text{threshold}} \\approx \\frac{|M\\epsilon|}{M} = |\\epsilon|$，这是一个小值。第二个布尔输出 $\\rho_{\\text{threshold}} \\le g$ 检查此增长是否在可接受范围内。\n\n**算法实现**\n\n对于每个测试用例，执行以下过程：\n1.  以稀疏格式构造大小为 $n \\times n$ 的矩阵 $A$，具体使用 `scipy.sparse.lil_matrix` 以实现高效的逐元素赋值，之后转换为 `csc_matrix` 以进行分解。\n2.  填充三对角元素和指定的异常项。\n3.  计算 $\\operatorname{nnz}(A)$ 和 $\\max_{i,j} |A_{i,j}| = M$。\n4.  通过调用 `scipy.sparse.linalg.splu` 并设置 `permc_spec='NATURAL'` 和 `diag_pivot_thresh=1.0` 来执行严格部分主元选择的 LU 分解。将所得 $L$ 和 $U$ 因子的非零元数目相加，以计算 $f_{\\text{partial}}$。\n5.  通过调用 `splu` 并设置 `permc_spec='NATURAL'` 和 `diag_pivot_thresh=\\tau`（测试用例中的值）来执行阈值主元选择的 LU 分解。\n6.  从第二次分解中，通过对新因子的非零元求和来计算 $f_{\\text{threshold}}$。\n7.  找到新 $U$ 因子数据中的最大绝对值 $\\max|U_{i,j}|$，并计算 $\\rho_{\\text{threshold}}$。\n8.  最后，评估两个布尔条件 $[f_{\\text{threshold}}  f_{\\text{partial}}, \\rho_{\\text{threshold}} \\le g]$，并存储结果。对所有测试用例重复此过程。",
            "answer": "```python\nimport numpy as np\nimport scipy.sparse as sp\nfrom scipy.sparse.linalg import splu\n\n# Set the environment according to the problem statement.\n# language: Python, version: 3.12\n# libraries: numpy==1.23.5, scipy==1.11.4\n\ndef run_factorization_analysis(n, epsilon, J, r_map, M, tau_thresh, g):\n    \"\"\"\n    Constructs a sparse matrix and analyzes its LU factorization under two\n    pivoting strategies.\n\n    Args:\n        n (int): Dimension of the matrix.\n        epsilon (float): Magnitude of off-diagonal entries in the tridiagonal band.\n        J (set): Set of column indices for rogue entries.\n        r_map (callable): Function mapping a column index j to a row index r(j).\n        M (float): Magnitude of the rogue entries.\n        tau_thresh (float): Threshold for threshold pivoting.\n        g (float): Growth factor bound.\n\n    Returns:\n        tuple[bool, bool]: A tuple of two booleans:\n                           (reduces_fill, acceptable_growth)\n    \"\"\"\n    # 1. Construct the matrix A using LIL format for efficient construction.\n    A = sp.lil_matrix((n, n), dtype=np.float64)\n\n    # Add tridiagonal band\n    for i in range(n):\n        A[i, i] = 1.0\n        if i  n - 1:\n            A[i, i + 1] = epsilon\n            A[i + 1, i] = epsilon\n    \n    # Add rogue entries\n    for j in J:\n        A[r_map(j), j] = M\n\n    # Convert to CSC format for factorization\n    A_csc = A.tocsc()\n    nnz_A = A_csc.nnz\n    max_A = M  # Max magnitude in A is M by construction\n\n    # 2. Factorize with strict partial pivoting (tau = 1.0)\n    # The 'NATURAL' permutation spec ensures no column reordering.\n    lu_partial = splu(A_csc, permc_spec='NATURAL', diag_pivot_thresh=1.0)\n    nnz_partial = lu_partial.L.nnz + lu_partial.U.nnz\n    f_partial = nnz_partial / nnz_A\n\n    # 3. Factorize with threshold pivoting (given tau)\n    lu_threshold = splu(A_csc, permc_spec='NATURAL', diag_pivot_thresh=tau_thresh)\n    nnz_threshold = lu_threshold.L.nnz + lu_threshold.U.nnz\n    f_threshold = nnz_threshold / nnz_A\n    \n    # Find max element in U for growth factor calculation.\n    # U.data can contain explicit zeros, so filter them out if necessary,\n    # though max(abs(..)) handles it. If U.data is empty, max would fail.\n    max_U_thresh = 0.0\n    if lu_threshold.U.data.size > 0:\n        max_U_thresh = np.max(np.abs(lu_threshold.U.data))\n    \n    rho_threshold = max_U_thresh / max_A\n\n    # 4. Evaluate the boolean conditions\n    reduces_fill = f_threshold  f_partial\n    acceptable_growth = rho_threshold = g\n\n    return [reduces_fill, acceptable_growth]\n\ndef solve():\n    \"\"\"\n    Defines and runs the test suite for the LU factorization problem.\n    \"\"\"\n    test_cases = [\n        # Case 1: General \"happy path\"\n        {'n': 50, 'epsilon': 0.05, 'J': set(range(10)), 'r_map': lambda j: 49 - j, \n         'M': 100, 'tau': 0.01, 'g': 500},\n        # Case 2: Boundary for strict partial pivoting\n        {'n': 50, 'epsilon': 0.05, 'J': set(range(10)), 'r_map': lambda j: 49 - j, \n         'M': 100, 'tau': 1.0, 'g': 500},\n        # Case 3: Smaller dimension, moderate rogue entries, threshold too high\n        {'n': 12, 'epsilon': 0.02, 'J': set(range(6)), 'r_map': lambda j: 11 - j, \n         'M': 50, 'tau': 0.05, 'g': 250},\n        # Case 4: Edge case of always-diagonal pivoting (no pivoting)\n        {'n': 20, 'epsilon': 0.02, 'J': set(range(8)), 'r_map': lambda j: 19 - j, \n         'M': 500, 'tau': 0.0, 'g': 5000},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_factorization_analysis(\n            n=case['n'],\n            epsilon=case['epsilon'],\n            J=case['J'],\n            r_map=case['r_map'],\n            M=case['M'],\n            tau_thresh=case['tau'],\n            g=case['g']\n        )\n        results.append(result)\n\n    # Format the final output string exactly as required.\n    # e.g., [[true,true],[false,true],...]\n    formatted_results = []\n    for res_pair in results:\n        s = f\"[{str(res_pair[0]).lower()},{str(res_pair[1]).lower()}]\"\n        formatted_results.append(s)\n    \n    final_string = f\"[{','.join(formatted_results)}]\"\n    print(final_string)\n\nsolve()\n```"
        }
    ]
}