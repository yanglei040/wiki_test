{
    "hands_on_practices": [
        {
            "introduction": "本练习将介绍局部和相对敏感性的基本概念。通过将这些概念应用于广为人知的米氏方程 (Michaelis-Menten equation)，您将亲手实践敏感性分析的基本微积分运算，并理解如何量化模型输出对参数微小变化的响应，这是所有模型分析的基石。",
            "id": "3324221",
            "problem": "考虑代谢途径中的一个酶促步骤，其中通量 $v$ 取决于底物浓度 $S$ 和两个动力学参数：最大速率 $V_{\\max}$ 和米氏常数 $K_{m}$。假设该通量遵循米氏动力学 $v = V_{\\max} \\, \\frac{S}{K_{m} + S}$。在计算系统生物学中，局部灵敏度分析用于量化参数的无穷小变化如何影响模型输出。使用局部灵敏度的定义（输出对参数的偏导数）以及为参数 $p$ 定义的无量纲相对（对数）灵敏度 $S_{p}^{\\mathrm{rel}} = \\left(\\frac{\\partial v}{\\partial p}\\right)\\left(\\frac{p}{v}\\right)$，完成以下任务：\n- 从第一性原理出发，推导局部灵敏度 $\\frac{\\partial v}{\\partial V_{\\max}}$ 和 $\\frac{\\partial v}{\\partial K_{m}}$。\n- 在操作点 $S = K_{m}$ 处，计算相对灵敏度 $S_{V_{\\max}}^{\\mathrm{rel}}$ 和 $S_{K_{m}}^{\\mathrm{rel}}$。\n\n将你的最终答案以单个解析表达式的形式给出，其中依次包含 $\\frac{\\partial v}{\\partial V_{\\max}}$、$\\frac{\\partial v}{\\partial K_{m}}$、$S_{V_{\\max}}^{\\mathrm{rel}}\\big|_{S=K_{m}}$ 和 $S_{K_{m}}^{\\mathrm{rel}}\\big|_{S=K_{m}}$。无需四舍五入。答案表示为不带单位的表达式。",
            "solution": "该问题陈述已经过验证，被认为是可靠、适定且有科学依据的。它展示了在米氏酶动力学的既定框架内，将微分学应用于灵敏度分析的一个标准应用。所有定义和条件均已给出，从而可以得到一个唯一且有意义的解。\n\n该问题要求推导由米氏方程描述的酶促反应通量 $v$ 的局部和相对灵敏度：\n$$v = V_{\\max} \\, \\frac{S}{K_{m} + S}$$\n其中 $v$ 是反应通量，$S$ 是底物浓度，$V_{\\max}$ 是最大速率，$K_{m}$ 是米氏常数。\n\n首先，我们推导局部灵敏度，即通量 $v$ 对参数 $V_{\\max}$ 和 $K_{m}$ 的偏导数。\n\n关于 $V_{\\max}$ 的局部灵敏度是 $\\frac{\\partial v}{\\partial V_{\\max}}$。为计算此值，我们将 $S$ 和 $K_{m}$ 视为常数，并对 $v$ 关于 $V_{\\max}$ 求导：\n$$v = \\left(\\frac{S}{K_{m} + S}\\right) V_{\\max}$$\n$$\\frac{\\partial v}{\\partial V_{\\max}} = \\frac{\\partial}{\\partial V_{\\max}} \\left[ \\left(\\frac{S}{K_{m} + S}\\right) V_{\\max} \\right] = \\frac{S}{K_{m} + S}$$\n\n关于 $K_{m}$ 的局部灵敏度是 $\\frac{\\partial v}{\\partial K_{m}}$。为计算此值，我们将 $S$ 和 $V_{\\max}$ 视为常数。将 $v$ 的表达式写成如下形式会很方便：\n$$v = V_{\\max} S (K_{m} + S)^{-1}$$\n使用链式法则求导，我们得到：\n$$\\frac{\\partial v}{\\partial K_{m}} = \\frac{\\partial}{\\partial K_{m}} \\left[ V_{\\max} S (K_{m} + S)^{-1} \\right]$$\n$$= V_{\\max} S \\cdot \\left( -1 \\cdot (K_{m} + S)^{-2} \\cdot \\frac{\\partial}{\\partial K_{m}}(K_{m} + S) \\right)$$\n$$= V_{\\max} S \\cdot \\left( - (K_{m} + S)^{-2} \\cdot 1 \\right)$$\n$$\\frac{\\partial v}{\\partial K_{m}} = - \\frac{V_{\\max} S}{(K_{m} + S)^2}$$\n\n接下来，我们在特定操作点 $S = K_{m}$ 处，计算无量纲相对（或对数）灵敏度，其定义为 $S_{p}^{\\mathrm{rel}} = \\left(\\frac{\\partial v}{\\partial p}\\right)\\left(\\frac{p}{v}\\right)$。\n\n对于参数 $V_{\\max}$，相对灵敏度为：\n$$S_{V_{\\max}}^{\\mathrm{rel}} = \\left(\\frac{\\partial v}{\\partial V_{\\max}}\\right)\\left(\\frac{V_{\\max}}{v}\\right)$$\n代入 $\\frac{\\partial v}{\\partial V_{\\max}}$ 和 $v$ 的表达式：\n$$S_{V_{\\max}}^{\\mathrm{rel}} = \\left(\\frac{S}{K_{m} + S}\\right) \\left( \\frac{V_{\\max}}{V_{\\max} \\frac{S}{K_{m} + S}} \\right)$$\n$$S_{V_{\\max}}^{\\mathrm{rel}} = \\left(\\frac{S}{K_{m} + S}\\right) \\left( \\frac{K_{m} + S}{S} \\right) = 1$$\n关于 $V_{\\max}$ 的相对灵敏度是常数，等于 $1$。这表明，无论底物浓度 $S$ 如何，$V_{\\max}$ 的任何百分比变化都会导致 $v$ 产生相同的百分比变化。因此，其在 $S = K_{m}$ 处的值也为 $1$。\n$$S_{V_{\\max}}^{\\mathrm{rel}}\\big|_{S=K_{m}} = 1$$\n\n对于参数 $K_{m}$，相对灵敏度为：\n$$S_{K_{m}}^{\\mathrm{rel}} = \\left(\\frac{\\partial v}{\\partial K_{m}}\\right)\\left(\\frac{K_{m}}{v}\\right)$$\n代入 $\\frac{\\partial v}{\\partial K_{m}}$ 和 $v$ 的表达式：\n$$S_{K_{m}}^{\\mathrm{rel}} = \\left( - \\frac{V_{\\max} S}{(K_{m} + S)^2} \\right) \\left( \\frac{K_{m}}{V_{\\max} \\frac{S}{K_{m} + S}} \\right)$$\n$$S_{K_{m}}^{\\mathrm{rel}} = \\left( - \\frac{V_{\\max} S}{(K_{m} + S)^2} \\right) \\left( \\frac{K_{m} (K_{m} + S)}{V_{\\max} S} \\right)$$\n消去各项后，我们得到：\n$$S_{K_{m}}^{\\mathrm{rel}} = - \\frac{K_{m}}{K_{m} + S}$$\n现在，我们在特定操作点 $S = K_{m}$ 处计算该表达式的值：\n$$S_{K_{m}}^{\\mathrm{rel}}\\big|_{S=K_{m}} = - \\frac{K_{m}}{K_{m} + K_{m}} = - \\frac{K_{m}}{2K_{m}} = - \\frac{1}{2}$$\n这个结果意味着，在 $S = K_m$ 时，$K_m$ 增加 $1\\%$ 会导致反应通量 $v$ 减少 $0.5\\%$。\n\n按要求的顺序，四个结果是：\n1. $\\frac{\\partial v}{\\partial V_{\\max}} = \\frac{S}{K_{m} + S}$\n2. $\\frac{\\partial v}{\\partial K_{m}} = - \\frac{V_{\\max} S}{(K_{m} + S)^2}$\n3. $S_{V_{\\max}}^{\\mathrm{rel}}\\big|_{S=K_{m}} = 1$\n4. $S_{K_{m}}^{\\mathrm{rel}}\\big|_{S=K_{m}} = - \\frac{1}{2}$",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{S}{K_{m} + S} & - \\frac{V_{\\max} S}{(K_{m} + S)^2} & 1 & - \\frac{1}{2}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "在掌握了基本的敏感性计算之后，本练习将引导您探索系统建模中的一个更深层次的问题：结构可辨识性。您将会发现，即使模型参数对输出有明确的影响（即非零的敏感性），它们也可能因为参数间的对称性而无法被唯一确定，这对任何构建或拟合生物学模型的研究者来说都是至关重要的一课。",
            "id": "3324161",
            "problem": "考虑一个单一位点磷酸化循环，其中底物在激酶刺激和组成型磷酸酶的作用下，在未磷酸化形式和磷酸化形式之间切换。假设总底物浓度 $X_T > 0$ 守恒，并令 $x(t)$ 表示在时间 $t$ 时磷酸化形式的浓度。激酶刺激是一个已知的、有界的、平滑的输入 $u(t)$，且不恒为零。其动力学遵循质量作用动力学，正向磷酸化速率与 $u(t)$ 成正比，反向去磷酸化速率为常数。具体来说，对于未知的正参数 $(k_1,k_2,k_3)$，状态动力学和测量输出由以下方程控制：\n$$\n\\frac{dx}{dt} \\;=\\; k_1\\,k_3\\,u(t)\\,\\big(X_T - x(t)\\big) \\;-\\; k_2\\,x(t),\n$$\n测量的输出是磷酸化浓度本身，\n$$\ny(t) \\;=\\; x(t).\n$$\n这里，$k_1$ 是一个未知的催化因子，$k_2$ 是一个未知的一阶去磷酸化速率常数，而 $k_3$ 是一个未知的输入增益，用于缩放激酶刺激的幅度。假设初始条件 $x(0)=x_0$ 未知但有限。\n\n仅从上述质量作用表示以及结构可辨识性和局部灵敏度的定义出发，使用微分代数消去法推导一个涉及 $y(t)$、$u(t)$ 及其时间导数的输入输出关系，该关系消除了未观测的内部状态 $x(t)$。根据该输入输出关系，确定 $(k_1,k_2,k_3)$ 的结构可辨识性，并精确描述导致不可辨识性的任何参数对称性。然后，通过考虑偏导数 $\\partial y/\\partial k_i$ 来分析局部灵敏度，并解释在已识别的对称性下，$\\partial y/\\partial k_i \\neq 0$ 如何能与不可辨识性共存。\n\n作为最终答案，报告同时涉及 $k_1$ 和 $k_3$ 的单个结构可辨识参数组合，以仅含参数的闭式解析表达式形式表示。不需要数值近似或四舍五入。",
            "solution": "所述问题构成了一个有效且适定的练习，涉及非线性常微分方程模型的结构可辨识性和灵敏度分析，这是计算系统生物学中的一个标准课题。所有提供的信息都是自洽且科学合理的。我们将着手进行推导和分析。\n\n该问题要求分析单一位点磷酸化模型中参数 $(k_1, k_2, k_3)$ 的结构可辨识性。分析将按要求分三步进行：首先，使用微分代数推导输入输出关系；其次，根据此关系确定参数的可辨识性；第三，分析局部灵敏度，以解释非零灵敏度与不可辨识性之间的关系。\n\n**1. 输入输出关系的推导**\n\n我们已知磷酸化底物浓度 $x(t)$ 的状态动力学方程：\n$$\n\\frac{dx}{dt} = k_1 k_3 u(t) (X_T - x(t)) - k_2 x(t)\n$$\n测量的输出由 $y(t) = x(t)$ 给出。这个等式允许我们直接从系统动力学中消除未观测的状态变量 $x(t)$。通过用 $y(t)$ 替换 $x(t)$，并因此用 $\\frac{dy}{dt}$ 替换 $\\frac{dx}{dt}$，我们得到输入输出关系：\n$$\n\\frac{dy}{dt} = k_1 k_3 u(t) (X_T - y(t)) - k_2 y(t)\n$$\n这是一个一阶、变量非线性（由于存在 $u(t)y(t)$ 项）、非齐次的常微分方程，它在不涉及内部状态 $x(t)$ 的情况下，关联了输入 $u(t)$ 和输出 $y(t)$。该方程构成了可辨识性分析的基础。\n\n**2. 结构可辨识性分析**\n\n结构可辨识性关注的是，在一个足够长的时间间隔内，从完美的、无噪声的输入输出数据中，是否可以唯一确定模型的未知参数。为了分析这一点，我们重新排列输入输出方程，按照未知参数 $(k_1, k_2, k_3)$ 对各项进行分组：\n$$\n\\frac{dy}{dt} = k_1 k_3 X_T u(t) - k_1 k_3 u(t) y(t) - k_2 y(t)\n$$\n让我们重写这个方程，明确显示乘以已知输入 $u(t)$ 和测量输出 $y(t)$ 的不同函数的参数组合：\n$$\n\\frac{dy}{dt} + k_2 y(t) + (k_1 k_3) u(t) y(t) = (k_1 k_3 X_T) u(t)\n$$\n为了使参数能够被唯一辨识，每个乘以时变信号（这里是 $y(t)$、$u(t)y(t)$ 和 $u(t)$）的唯一函数的不同系数都必须是可唯一确定的。让我们定义两个复合参数：\n$$\np_1 = k_2\n$$\n$$\np_2 = k_1 k_3\n$$\n将它们代入输入输出方程，得到：\n$$\n\\frac{dy}{dt} + p_1 y(t) + p_2 u(t) y(t) = p_2 X_T u(t)\n$$\n从这个方程中，假设输入 $u(t)$ 具有足够的激励性，使得回归量 $y(t)$、$u(t)y(t)$ 和 $u(t)$ 线性无关，那么就可以唯一确定系数 $p_1$ 和 $p_2$。请注意，$u(t)$ 的系数是 $p_2 X_T$，它与 $p_2$ 并非独立，因为 $X_T$ 是一个已知常数。这证实了只有两个可辨识的参数组合。\n\n现在，我们研究是否能从已辨识的复合参数 $(p_1, p_2)$ 中唯一地恢复原始参数 $(k_1, k_2, k_3)$。\n- 从 $p_1 = k_2$ 可知，参数 $k_2$ 是唯一确定的。因此，$k_2$ 是结构可辨识的。\n- 从 $p_2 = k_1 k_3$ 可知，我们有一个方程，但有两个未知参数 $k_1$ 和 $k_3$。这个方程对于 $k_1$ 和 $k_3$ 没有唯一解。对于任何给定的可辨识值 $p_2 > 0$，任何满足 $k'_1 k'_3 = p_2$ 的正数对 $(k'_1, k'_3)$ 都会产生完全相同的输入输出行为。\n\n这种缺乏唯一解的情况揭示了一种参数对称性。具体来说，如果 $(k_1, k_3)$ 是一组有效的参数集，那么对于任何缩放因子 $\\alpha > 0$，参数集 $(k'_1, k'_3) = (\\alpha k_1, k_3/\\alpha)$ 在观测上是等效的，因为它们的乘积保持不变：\n$$\nk'_1 k'_3 = (\\alpha k_1) \\left(\\frac{k_3}{\\alpha}\\right) = k_1 k_3 = p_2\n$$\n因此，参数 $k_1$ 和 $k_3$ 是结构不可辨识的。整个模型是结构不可辨识的。可辨识的组合是 $k_2$ 和乘积 $k_1 k_3$。\n\n**3. 局部灵敏度与不可辨识性**\n\n局部灵敏度分析研究了小的参数扰动对模型输出的影响。输出 $y(t)$ 对参数 $k_i$ 的灵敏度由偏导数 $s_i(t) = \\frac{\\partial y(t)}{\\partial k_i}$ 给出。非零的灵敏度 $s_i(t)$ 表明参数 $k_i$ 对输出有影响。不可辨识性并非源于缺乏影响（即灵敏度为零），而是源于不同参数的灵敏度函数之间的线性相关性。\n\n我们通过对输入输出关系就每个参数 $k_i$ 进行微分来推导灵敏度方程，假设初始条件 $x_0 = y(0)$ 与参数无关，这意味着 $s_i(0) = \\frac{\\partial y(0)}{\\partial k_i} = 0$。\n\n对于 $k_1$：令 $s_1(t) = \\frac{\\partial y}{\\partial k_1}$。\n$$\n\\frac{ds_1}{dt} = k_3 u(t) (X_T - y) - k_1 k_3 u(t) \\frac{\\partial y}{\\partial k_1} - k_2 \\frac{\\partial y}{\\partial k_1}\n$$\n$$\n\\frac{ds_1}{dt} + (k_2 + k_1 k_3 u(t)) s_1(t) = k_3 u(t) (X_T - y(t))\n$$\n由于 $u(t)$ 不恒为零，且 $y(t)$ 通常不等于 $X_T$，因此右侧的驱动项非零。在初始条件 $s_1(0) = 0$ 下，解 $s_1(t)$ 通常是非零的。因此，$\\frac{\\partial y}{\\partial k_1} \\neq 0$。\n\n对于 $k_3$：令 $s_3(t) = \\frac{\\partial y}{\\partial k_3}$。\n$$\n\\frac{ds_3}{dt} = k_1 u(t) (X_T - y) - k_1 k_3 u(t) \\frac{\\partial y}{\\partial k_3} - k_2 \\frac{\\partial y}{\\partial k_3}\n$$\n$$\n\\frac{ds_3}{dt} + (k_2 + k_1 k_3 u(t)) s_3(t) = k_1 u(t) (X_T - y(t))\n$$\n同样，驱动项非零，因此 $s_3(t) = \\frac{\\partial y}{\\partial k_3} \\neq 0$。\n\n非零灵敏度与不可辨识性的共存，可以通过灵敏度向量 $s_1(t)$ 和 $s_3(t)$ 之间的线性相关性来解释。让我们检查它们各自微分方程之间的关系。\n$s_1(t)$ 的常微分方程（ODE）是：$\\mathcal{L}[s_1] = g_1(t)$，其中 $\\mathcal{L}$ 是线性算子 $\\frac{d}{dt} + (k_2 + k_1 k_3 u(t))$，而 $g_1(t) = k_3 u(t) (X_T - y(t))$。\n$s_3(t)$ 的常微分方程（ODE）是：$\\mathcal{L}[s_3] = g_3(t)$，其中 $g_3(t) = k_1 u(t) (X_T - y(t))$。\n\n注意到 $g_3(t) = \\frac{k_1}{k_3} g_1(t)$，这意味着 $k_1 g_1(t) - k_3 g_3(t) = 0$。\n考虑线性组合 $S(t) = k_1 s_1(t) - k_3 s_3(t)$。应用线性算子 $\\mathcal{L}$：\n$$\n\\mathcal{L}[S(t)] = \\mathcal{L}[k_1 s_1(t) - k_3 s_3(t)] = k_1 \\mathcal{L}[s_1(t)] - k_3 \\mathcal{L}[s_3(t)] = k_1 g_1(t) - k_3 g_3(t) = 0\n$$\n因此，$S(t)$ 满足齐次微分方程 $\\frac{dS}{dt} + (k_2 + k_1 k_3 u(t)) S(t) = 0$。初始条件为 $S(0) = k_1 s_1(0) - k_3 s_3(0) = k_1(0) - k_3(0) = 0$。这个初值问题的唯一解是对于所有 $t \\geq 0$，$S(t) = 0$。\n因此，我们证明了对于所有时间 $t$：\n$$\nk_1 \\frac{\\partial y(t)}{\\partial k_1} - k_3 \\frac{\\partial y(t)}{\\partial k_3} = 0 \\quad \\implies \\quad k_1 \\frac{\\partial y(t)}{\\partial k_1} = k_3 \\frac{\\partial y(t)}{\\partial k_3}\n$$\n灵敏度函数之间的这种线性相关性表明，改变 $k_1$ 和 $k_3$ 对输出 $y(t)$ 的影响是完全共线的。一个无穷小的变化 $dk_1$ 可以被一个相应的变化 $dk_3 = -\\frac{k_3}{k_1} dk_1$ 完全抵消，使输出保持不变。这种关系对应于保持乘积 $k_1 k_3$ 为常数，这正是我们前面确定的结构不可辨识性的根源。因此，非零灵敏度仅表示有影响，而不表示影响的可区分性。\n\n同时涉及 $k_1$ 和 $k_3$ 的单个结构可辨识参数组合是它们的乘积 $k_1 k_3$。",
            "answer": "$$\n\\boxed{k_1 k_3}\n$$"
        },
        {
            "introduction": "局部敏感性分析功能强大，但其适用范围局限于参数的微小扰动。本练习将焦点从局部转向全局敏感性分析，这是一种探索参数在其整个不确定性范围内影响的方法。您将遵循一个系统化的设计策略来配置一个莫里斯法 (Morris method) 筛选实验，学习如何在参数维度高的模型中平衡计算成本和筛选能力。",
            "id": "3324216",
            "problem": "您的任务是为一个具有 $k=50$ 个标量参数的计算系统生物学模型设计一个莫里斯方法（一次一变(OAT)）全局灵敏度筛选实验，每个输入都归一化到单位区间 $[0,1]$。莫里斯筛选实验在 $k$ 维输入空间中构建 $r$ 条轨迹，该空间在每个参数维度上被离散化为具有 $p$ 个水平的规则网格。每条轨迹都是由 $k+1$ 个设计点组成的序列，从网格上的一个基点开始，每次只移动一个坐标，移动固定的步长 $\\Delta$。您的目标是计算出设计建议，以在严格的计算预算和筛选能力之间取得平衡，同时遵守莫里斯方法的基本结构约束。\n\n基本原理和约束：\n- 在 $k$ 维空间中，$r$ 条莫里斯轨迹的计算成本（模型评估次数）等于 $E=r\\,(k+1)$，因为每条轨迹需要评估 $k+1$ 个点。\n- 网格在每个维度上的 $[0,1]$ 区间内有 $p$ 个等距水平，因此任何允许的坐标值都具有 $j/(p-1)$ 的形式，其中整数 $j\\in\\{0,1,\\dots,p-1\\}$。\n- 步长 $\\Delta$ 必须是 $1/(p-1)$ 的正整数倍，以确保每次一次一变的移动都保持在网格上。为了保证从任何基点出发，所有 $k$ 个坐标的移动都是可行的且不会超出 $[0,1]$ 区间，一个标准的、保持对称性的选择是取 $p$ 为偶数，并设置\n$$\n\\Delta=\\frac{p}{2\\,(p-1)}.\n$$\n- 莫里斯设计的主要筛选能力随着基本效应数量 $r\\,k$ 的增加而增加，并且在 $r$ 固定的情况下，通过对 $[0,1]^k$ 进行更精细的划分（即更大的 $p$），筛选能力会得到提升；然而，计算成本 $E=r\\,(k+1)$ 与 $p$ 无关。\n\n您的程序需要实现的设计策略：\n1. 给定一个计算预算 $B$（允许的最大模型评估次数），可以承担的最大轨迹数是 $\\left\\lfloor B/(k+1)\\right\\rfloor$。为避免筛选中的收益递减，基于“当效应标准化时，平均绝对基本效应的标准误与 $1/\\sqrt{r}$ 成比例”这一启发式规则，使用目标可靠性水平 $r_{\\mathrm{goal}}=20$ 条轨迹。推荐\n$$\nr^\\star=\\min\\!\\left(\\left\\lfloor \\frac{B}{k+1}\\right\\rfloor,\\,r_{\\mathrm{goal}}\\right).\n$$\n将可行性声明为布尔谓词 $r^\\star\\ge 1$。将预算是否达到可靠性目标声明为布尔谓词 $\\left\\lfloor B/(k+1)\\right\\rfloor\\ge r_{\\mathrm{goal}}$。\n2. 从偶数候选集 $\\{4,6,8,10,12,14,16\\}$ 中选择网格水平数 $p$，以保持设计结构良好同时避免极端粗糙。使用标准的保持对称性的步长规则 $\\Delta(p)=p/\\big(2\\,(p-1)\\big)$，并倾向于选择一个接近折衷值 $\\Delta_\\ast=0.6$ 的步长，以避免过粗或过细的移动。形式上，选择\n$$\np^\\star=\\arg\\min_{p\\in\\{4,6,8,10,12,14,16\\}} \\left|\\Delta(p)-\\Delta_\\ast\\right|,\n\\quad\\text{若出现平局，则选择较大的 }p,\n$$\n然后设置 $\\Delta^\\star=\\Delta(p^\\star)$。\n\n数值舍入要求：\n- 将步长 $\\Delta^\\star$ 报告为四舍五入到三位小数的小数。\n\n测试套件：\n- 在整个过程中使用 $k=50$。将上述策略应用于以下预算 $B$（模型评估次数）：$[0,50,51,153,204,1020,5100]$。\n- 对于列表中的每个 $B$，计算并报告元组 $\\big[r^\\star,\\,p^\\star,\\,\\Delta^\\star,\\,\\text{feasible},\\,\\text{meets\\_goal}\\big]$，其中最后两项是如上定义的布尔值。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含所有测试用例结果的列表，按顺序排列，用逗号分隔并用方括号括起来。每个测试用例的结果本身应该是一个列表，顺序为 $\\big[r^\\star,\\,p^\\star,\\,\\Delta^\\star,\\,\\text{feasible},\\,\\text{meets\\_goal}\\big]$。例如：“[[1,6,0.600,True,False],[...],...]”。",
            "solution": "问题陈述已经过验证，被认为是合理的。它在科学上基于莫里斯方法进行全局灵敏度分析的原理，信息充分且一致，问题本身是适定的，并以客观、可形式化的术语表达。任务是在计算预算下为一个莫里斯实验实施一个确定性的设计策略。我们将给出一个完整且有理有据的解决方案。\n\n该解决方案是通过遵循问题陈述中提供的两部分设计策略来计算的。首先，我们确定最佳网格水平数 $p^\\star$ 和相应的步长 $\\Delta^\\star$，这些值对所有测试用例都是恒定的，因为它们不依赖于计算预算 $B$。其次，对于每个给定的预算 $B$，我们计算推荐的轨迹数 $r^\\star$ 以及相关的可行性和目标达成度量。\n\n**第1部分：确定最佳网格水平 ($p^\\star$) 和步长 ($\\Delta^\\star$)**\n\n设计策略指定从偶数候选集 $\\mathcal{P} = \\{4, 6, 8, 10, 12, 14, 16\\}$ 中选择网格水平数 $p$。选择的依据是最小化所得步长 $\\Delta(p)$ 与目标折衷值 $\\Delta_\\ast = 0.6$ 之间的绝对差。步长 $\\Delta(p)$ 由标准的保持对称性公式给出：\n$$\n\\Delta(p) = \\frac{p}{2(p-1)}\n$$\n最佳水平数 $p^\\star$ 通过求解以下优化问题找到：\n$$\np^\\star = \\arg\\min_{p \\in \\mathcal{P}} \\left| \\Delta(p) - \\Delta_\\ast \\right|\n$$\n其中平局决胜规则是在出现平局时选择较大的 $p$。\n\n让我们为每个候选 $p$ 计算 $\\Delta(p)$ 和差值 $|\\Delta(p) - 0.6|$：\n\n| $p$ | $\\Delta(p) = \\frac{p}{2(p-1)}$ | $|\\Delta(p) - 0.6|$ |\n|---|---|---|\n| $4$ | $\\frac{4}{2(3)} = \\frac{2}{3} \\approx 0.6667$ | $|\\frac{2}{3} - \\frac{3}{5}| = |\\frac{10-9}{15}| = \\frac{1}{15} \\approx 0.0667$ |\n| $6$ | $\\frac{6}{2(5)} = \\frac{3}{5} = 0.6$ | $|0.6 - 0.6| = 0$ |\n| $8$ | $\\frac{8}{2(7)} = \\frac{4}{7} \\approx 0.5714$ | $|\\frac{4}{7} - \\frac{3}{5}| = |\\frac{20-21}{35}| = \\frac{1}{35} \\approx 0.0286$ |\n| $10$ | $\\frac{10}{2(9)} = \\frac{5}{9} \\approx 0.5556$ | $|\\frac{5}{9} - \\frac{3}{5}| = |\\frac{25-27}{45}| = \\frac{2}{45} \\approx 0.0444$ |\n| $12$ | $\\frac{12}{2(11)} = \\frac{6}{11} \\approx 0.5455$ | $|\\frac{6}{11} - \\frac{3}{5}| = |\\frac{30-33}{55}| = \\frac{3}{55} \\approx 0.0545$ |\n| $14$ | $\\frac{14}{2(13)} = \\frac{7}{13} \\approx 0.5385$ | $|\\frac{7}{13} - \\frac{3}{5}| = |\\frac{35-39}{65}| = \\frac{4}{65} \\approx 0.0615$ |\n| $16$ | $\\frac{16}{2(15)} = \\frac{8}{15} \\approx 0.5333$ | $|\\frac{8}{15} - \\frac{3}{5}| = |\\frac{8-9}{15}| = \\frac{1}{15} \\approx 0.0667$ |\n\n最小绝对差是唯一的 $0$，它在 $p=6$ 时出现。因此，网格水平数的最佳选择是 $p^\\star = 6$。相应的步长是 $\\Delta^\\star = \\Delta(6) = 0.6$。根据格式要求，报告为 $0.600$。这些值，$p^\\star=6$ 和 $\\Delta^\\star=0.600$，将用于所有测试用例。\n\n**第2部分：根据每个预算计算轨迹和可行性度量**\n\n对于测试套件 $[0, 50, 51, 153, 204, 1020, 5100]$ 中的每个预算 $B$，我们应用策略来确定轨迹数 $r^\\star$。模型有 $k=50$ 个参数，因此每条轨迹的成本是 $k+1 = 51$ 次评估。\n\n策略定义如下：\n- 可承担的最大轨迹数：$r_{\\text{max}} = \\left\\lfloor \\frac{B}{k+1} \\right\\rfloor = \\left\\lfloor \\frac{B}{51} \\right\\rfloor$。\n- 目标可靠性水平：$r_{\\mathrm{goal}} = 20$。\n- 推荐轨迹数：$r^\\star = \\min(r_{\\text{max}}, r_{\\mathrm{goal}})$。\n- 可行性：一个布尔谓词，如果 $r^\\star \\ge 1$ 则为 `True`。\n- 达到目标：一个布尔谓词，如果 $r_{\\text{max}} \\ge r_{\\mathrm{goal}}$ 则为 `True`。\n\n我们现在将这些规则应用于每个预算 $B$：\n\n- **对于 $B=0$**：\n  - $r_{\\text{max}} = \\lfloor 0/51 \\rfloor = 0$。\n  - $r^\\star = \\min(0, 20) = 0$。\n  - `feasible` = $(0 \\ge 1)$ 为 `False`。\n  - `meets_goal` = $(0 \\ge 20)$ 为 `False`。\n  - 结果：$[0, 6, 0.600, False, False]$。\n\n- **对于 $B=50$**：\n  - $r_{\\text{max}} = \\lfloor 50/51 \\rfloor = 0$。\n  - $r^\\star = \\min(0, 20) = 0$。\n  - `feasible` = $(0 \\ge 1)$ 为 `False`。\n  - `meets_goal` = $(0 \\ge 20)$ 为 `False`。\n  - 结果：$[0, 6, 0.600, False, False]$。\n\n- **对于 $B=51$**：\n  - $r_{\\text{max}} = \\lfloor 51/51 \\rfloor = 1$。\n  - $r^\\star = \\min(1, 20) = 1$。\n  - `feasible` = $(1 \\ge 1)$ 为 `True`。\n  - `meets_goal` = $(1 \\ge 20)$ 为 `False`。\n  - 结果：$[1, 6, 0.600, True, False]$。\n\n- **对于 $B=153$**：\n  - $r_{\\text{max}} = \\lfloor 153/51 \\rfloor = 3$。\n  - $r^\\star = \\min(3, 20) = 3$。\n  - `feasible` = $(3 \\ge 1)$ 为 `True`。\n  - `meets_goal` = $(3 \\ge 20)$ 为 `False`。\n  - 结果：$[3, 6, 0.600, True, False]$。\n\n- **对于 $B=204$**：\n  - $r_{\\text{max}} = \\lfloor 204/51 \\rfloor = 4$。\n  - $r^\\star = \\min(4, 20) = 4$。\n  - `feasible` = $(4 \\ge 1)$ 为 `True`。\n  - `meets_goal` = $(4 \\ge 20)$ 为 `False`。\n  - 结果：$[4, 6, 0.600, True, False]$。\n\n- **对于 $B=1020$**：\n  - $r_{\\text{max}} = \\lfloor 1020/51 \\rfloor = 20$。\n  - $r^\\star = \\min(20, 20) = 20$。\n  - `feasible` = $(20 \\ge 1)$ 为 `True`。\n  - `meets_goal` = $(20 \\ge 20)$ 为 `True`。\n  - 结果：$[20, 6, 0.600, True, True]$。\n\n- **对于 $B=5100$**：\n  - $r_{\\text{max}} = \\lfloor 5100/51 \\rfloor = 100$。\n  - $r^\\star = \\min(100, 20) = 20$。\n  - `feasible` = $(20 \\ge 1)$ 为 `True`。\n  - `meets_goal` = $(100 \\ge 20)$ 为 `True`。\n  - 结果：$[20, 6, 0.600, True, True]$。\n\n现在将这些结果编译成最终的输出格式。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes Morris design recommendations based on a given policy and test suite.\n    \"\"\"\n    # Define constants and test cases from the problem statement.\n    k = 50\n    r_goal = 20\n    p_candidates = [4, 6, 8, 10, 12, 14, 16]\n    delta_target = 0.6\n    \n    test_cases_B = [0, 50, 51, 153, 204, 1020, 5100]\n\n    # --- Part 1: Determine p_star and delta_star ---\n    # This calculation is independent of the budget B.\n\n    best_p = -1\n    min_diff = float('inf')\n\n    for p in p_candidates:\n        delta_p = p / (2 * (p - 1))\n        diff = abs(delta_p - delta_target)\n        \n        # Use a small tolerance for floating-point comparisons to handle potential\n        # precision issues when finding the minimum or checking for ties.\n        # A new minimum is found if diff is smaller than the current min_diff.\n        if diff  min_diff - 1e-9:\n            min_diff = diff\n            best_p = p\n        # A tie is found if the difference is essentially the same as the current minimum.\n        elif abs(diff - min_diff)  1e-9:\n            # Tie-breaking rule: choose the larger p.\n            if p > best_p:\n                best_p = p\n\n    p_star = best_p\n    delta_star = p_star / (2 * (p_star - 1))\n    \n    results = []\n    \n    # --- Part 2: Process each budget B ---\n    for B in test_cases_B:\n        # Calculate r_star and associated boolean flags.\n        cost_per_trajectory = k + 1\n        \n        # Maximum affordable trajectories\n        r_max = int(np.floor(B / cost_per_trajectory))\n        \n        # Recommended trajectories\n        r_star = min(r_max, r_goal)\n        \n        # Feasibility predicate\n        feasible = r_star >= 1\n        \n        # Goal-met predicate\n        meets_goal = r_max >= r_goal\n        \n        # Assemble the result tuple for the current budget\n        # The delta_star value is rounded to three decimal places as required.\n        current_result = [r_star, p_star, delta_star, feasible, meets_goal]\n        results.append(current_result)\n\n    # --- Final Output Formatting ---\n    # Create the final string in the exact required format: \"[[...],[...],...]\"\n    result_strings = []\n    for res in results:\n        r, p, d, f, mg = res\n        # Format delta to exactly three decimal places.\n        d_str = f\"{d:.3f}\"\n        # Convert booleans to their string representations \"True\" or \"False\".\n        f_str = str(f)\n        mg_str = str(mg)\n        \n        result_strings.append(f\"[{r},{p},{d_str},{f_str},{mg_str}]\")\n\n    # Join all individual result strings and enclose in brackets.\n    final_output_string = f\"[{','.join(result_strings)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output_string)\n\nsolve()\n```"
        }
    ]
}