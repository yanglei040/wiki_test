{
    "hands_on_practices": [
        {
            "introduction": "基因调控网络是由一系列称为“网络基序”的可重复出现的小型调控模式构成的。这些基序各自具有独特的动态功能，理解它们是掌握复杂网络行为的第一步。本练习将引导您通过分析一个经典的非相干前馈环路（incoherent feedforward loop, I1-FFL）模型，来揭示其实现“完美适应”功能的内在机理，即输出信号在短暂响应后能恢复到刺激前的稳态水平。通过线性化和解析推导，您将亲身体验如何从网络结构推断其动态功能，这是系统生物学中的一项核心技能。",
            "id": "3314916",
            "problem": "考虑一个基因调控网络中的非相干前馈环，其中上游转录因子 $x$ 通过两条路径调控目标基因产物 $y$：一条是直接激活 $x \\to y$，另一条是间接抑制 $x \\to z \\to y$，其中 $z$ 抑制 $y$。假设 $x$、$y$ 和 $z$ 是无量纲浓度（通过参考浓度归一化），时间单位为小时。$y$ 和 $z$ 的动力学由带有产生项和一阶降解项的常微分方程决定，\n$$\n\\frac{dy}{dt} \\;=\\; \\alpha_y\\, a(x)\\, r(z) \\;-\\; \\beta_y\\, y, \n\\qquad\n\\frac{dz}{dt} \\;=\\; \\alpha_z\\, b(x) \\;-\\; \\beta_z\\, z,\n$$\n其中 $\\alpha_y$ 和 $\\alpha_z$ 是正常数产生速率尺度，$\\beta_y$ 和 $\\beta_z$ 是正常数一阶降解速率（单位为 $\\mathrm{h}^{-1}$），$a(x)$ 是关于 $x$ 的平滑递增激活函数，$r(z)$ 是关于 $z$ 的平滑递减抑制函数，而 $b(x)$ 是关于 $x$ 的平滑递增激活函数。设 $x(t)$ 是一个外源输入，在 $t=0$ 时发生一个小的阶跃，从基线值 $x_0$ 变为 $x_0 + \\Delta x$，其中 $|\\Delta x| \\ll 1$。设 $(y^\\ast, z^\\ast)$ 表示在 $x=x_0$ 处的唯一稳定稳态。\n\n对系统在稳态附近进行线性化，考虑小微扰 $\\delta y(t) = y(t) - y^\\ast$、$\\delta z(t) = z(t) - z^\\ast$ 和 $\\delta x(t) = x(t) - x_0$，并定义稳态灵敏度\n$$\np \\;=\\; \\left.\\frac{\\partial}{\\partial x}\\big(\\alpha_y\\, a(x)\\, r(z)\\big)\\right|_{(x_0,z^\\ast)}, \n\\quad\nc \\;=\\; \\left.\\frac{\\partial}{\\partial z}\\big(\\alpha_y\\, a(x)\\, r(z)\\big)\\right|_{(x_0,z^\\ast)}, \n\\quad\nq \\;=\\; \\left.\\frac{\\partial}{\\partial x}\\big(\\alpha_z\\, b(x)\\big)\\right|_{x_0},\n$$\n由于激活和抑制作用，有 $p0$，$q0$ 和 $c0$。假设降解速率不同，即 $\\beta_y \\neq \\beta_z$，并且 $y$ 的动态比 $z$ 快，即 $\\beta_y  \\beta_z  0$。\n\n仅使用小信号线性化和线性系统分析，施加 $y$ 对 $x$ 的阶跃实现完美适应的条件（即阶跃后 $y$ 的稳态变化为零），并推导出以下量的闭式解析表达式：\n- 适应振幅 $A^\\star$，定义为在响应阶跃 $\\delta x(t) = \\Delta x\\, u(t)$（其中 $u(t)$ 是单位阶跃）时，$t \\ge 0$ 范围内 $\\delta y(t)$ 的最大值，\n- 适应时间 $t^\\star$，定义为达到该最大值时的时间。\n\n将您的最终答案表示为由 $p$、$q$、$c$、$\\beta_y$、$\\beta_z$ 和 $\\Delta x$ 构成的表达式对。陈述您使用的任何附加条件。您必须将时间 $t^\\star$ 以小时为单位表示，并将振幅 $A^\\star$ 表示为无量纲量。以闭式形式提供最终表达式；无需进行数值计算或四舍五入。",
            "solution": "问题要求解一个展现出完美适应的线性化非相干前馈环的适应振幅 $A^\\star$ 和适应时间 $t^\\star$。\n\n首先，我们在对应于输入 $x=x_0$ 的稳态 $(y^\\ast, z^\\ast)$ 附近对给定的常微分方程组进行线性化。微扰定义为 $\\delta y(t) = y(t) - y^\\ast$、$\\delta z(t) = z(t) - z^\\ast$ 和 $\\delta x(t) = x(t) - x_0$。\n\n$y$ 的产生速率是 $f(x, z) = \\alpha_y a(x) r(z)$，$z$ 的产生速率是 $g(x) = \\alpha_z b(x)$。线性化系统得到：\n$$\n\\frac{d(\\delta y)}{dt} \\approx \\left.\\frac{\\partial f}{\\partial x}\\right|_{(x_0, z^\\ast)} \\delta x(t) + \\left.\\frac{\\partial f}{\\partial z}\\right|_{(x_0, z^\\ast)} \\delta z(t) - \\beta_y \\delta y(t)\n$$\n$$\n\\frac{d(\\delta z)}{dt} \\approx \\left.\\frac{dg}{dx}\\right|_{x_0} \\delta x(t) - \\beta_z \\delta z(t)\n$$\n使用所提供的灵敏度 $p$、$c$ 和 $q$ 的定义，线性化系统为：\n$$\n\\frac{d(\\delta y)}{dt} = p\\, \\delta x(t) + c\\, \\delta z(t) - \\beta_y \\delta y(t) \\quad (1)\n$$\n$$\n\\frac{d(\\delta z)}{dt} = q\\, \\delta x(t) - \\beta_z \\delta z(t) \\quad (2)\n$$\n\n接下来，我们施加完美适应的条件。完美适应意味着对于一个持续的输入阶跃变化 $\\delta x(t) = \\Delta x$，输出的稳态微扰为零。设新的稳态微扰为 $\\delta y_{ss}$ 和 $\\delta z_{ss}$。在此稳态下，时间导数为零。\n从方程（2），当 $d(\\delta z)/dt = 0$ 且 $\\delta x = \\Delta x$ 时：\n$$\n0 = q\\, \\Delta x - \\beta_z \\delta z_{ss} \\implies \\delta z_{ss} = \\frac{q}{\\beta_z} \\Delta x\n$$\n从方程（1），当 $d(\\delta y)/dt = 0$ 且 $\\delta x = \\Delta x$ 时：\n$$\n0 = p\\, \\Delta x + c\\, \\delta z_{ss} - \\beta_y \\delta y_{ss}\n$$\n完美适应的条件是 $\\delta y_{ss} = 0$。将此代入上式可得：\n$$\n0 = p\\, \\Delta x + c\\, \\delta z_{ss} = p\\, \\Delta x + c \\left(\\frac{q}{\\beta_z} \\Delta x\\right)\n$$\n由于此式必须对任何非零的 $\\Delta x$ 成立，我们得到参数的约束条件：\n$$\np + \\frac{cq}{\\beta_z} = 0 \\implies p \\beta_z = -cq\n$$\n这就是完美适应的条件，我们将用它来简化后续的表达式。给定的符号（$p0, q0, c0, \\beta_z0$）与此关系一致。\n\n现在，我们求解阶跃输入 $\\delta x(t) = \\Delta x\\, u(t)$（其中 $u(t)$ 是单位阶跃函数）下的线性化系统。初始条件为 $\\delta y(0)=0$ 和 $\\delta z(0)=0$，因为系统在 $t0$ 时处于稳态。\n\n对于 $t \\ge 0$，方程（2）变为：\n$$\n\\frac{d(\\delta z)}{dt} + \\beta_z \\delta z(t) = q\\, \\Delta x\n$$\n这是一个带常数强迫项的一阶线性常微分方程。初始条件为 $\\delta z(0)=0$ 的解是：\n$$\n\\delta z(t) = \\frac{q \\Delta x}{\\beta_z} (1 - \\exp(-\\beta_z t))\n$$\n\n接下来，我们将此解和 $\\delta x(t) = \\Delta x$ 代入方程（1），对于 $t \\ge 0$：\n$$\n\\frac{d(\\delta y)}{dt} + \\beta_y \\delta y(t) = p\\, \\Delta x + c \\left[ \\frac{q \\Delta x}{\\beta_z} (1 - \\exp(-\\beta_z t)) \\right]\n$$\n$$\n\\frac{d(\\delta y)}{dt} + \\beta_y \\delta y(t) = \\left(p + \\frac{cq}{\\beta_z}\\right) \\Delta x - \\frac{cq \\Delta x}{\\beta_z} \\exp(-\\beta_z t)\n$$\n使用完美适应条件 $p + cq/\\beta_z = 0$，方程简化为：\n$$\n\\frac{d(\\delta y)}{dt} + \\beta_y \\delta y(t) = -\\frac{cq \\Delta x}{\\beta_z} \\exp(-\\beta_z t)\n$$\n我们也可以代入 $-cq/\\beta_z = p$：\n$$\n\\frac{d(\\delta y)}{dt} + \\beta_y \\delta y(t) = p\\, \\Delta x \\exp(-\\beta_z t)\n$$\n这是一个一阶线性常微分方程。解可以通过使用积分因子 $\\exp(\\beta_y t)$ 求得。\n$$\n\\frac{d}{dt} (\\delta y(t) \\exp(\\beta_y t)) = p\\, \\Delta x \\exp(-\\beta_z t) \\exp(\\beta_y t) = p\\, \\Delta x \\exp((\\beta_y - \\beta_z)t)\n$$\n从 $0$ 到 $t$ 积分：\n$$\n\\delta y(t) \\exp(\\beta_y t) - \\delta y(0) \\exp(0) = \\int_0^t p\\, \\Delta x \\exp((\\beta_y - \\beta_z)\\tau) d\\tau\n$$\n使用 $\\delta y(0)=0$ 和给定条件 $\\beta_y \\neq \\beta_z$：\n$$\n\\delta y(t) \\exp(\\beta_y t) = p\\, \\Delta x \\left[ \\frac{\\exp((\\beta_y - \\beta_z)\\tau)}{\\beta_y - \\beta_z} \\right]_0^t = \\frac{p\\, \\Delta x}{\\beta_y-\\beta_z} (\\exp((\\beta_y - \\beta_z)t) - 1)\n$$\n乘以 $\\exp(-\\beta_y t)$ 得到 $\\delta y(t)$ 的解：\n$$\n\\delta y(t) = \\frac{p\\, \\Delta x}{\\beta_y - \\beta_z} (\\exp(-\\beta_z t) - \\exp(-\\beta_y t))\n$$\n问题将适应振幅 $A^\\star$ 定义为 $t \\ge 0$ 时 $\\delta y(t)$ 的最大值，将 $t^\\star$ 定义为达到此最大值的时间。对于 $t0$ 的非平凡最大值要求函数 $\\delta y(t)$ 从 $0$ 开始初始增加。由于 $p0$ 且 $\\beta_y  \\beta_z  0$，初始斜率的符号由 $\\Delta x$ 决定。为了得到正响应，我们要求 $\\Delta x  0$。我们将其陈述为一个附加条件。\n\n为了找到最大值出现的时间 $t^\\star$，我们将 $\\delta y(t)$ 的导数设为零：\n$$\n\\frac{d(\\delta y)}{dt} = \\frac{p\\, \\Delta x}{\\beta_y - \\beta_z} (-\\beta_z \\exp(-\\beta_z t) + \\beta_y \\exp(-\\beta_y t)) = 0\n$$\n由于前置因子非零，这意味着：\n$$\n\\beta_y \\exp(-\\beta_y t^\\star) = \\beta_z \\exp(-\\beta_z t^\\star)\n$$\n$$\n\\frac{\\beta_y}{\\beta_z} = \\frac{\\exp(-\\beta_z t^\\star)}{\\exp(-\\beta_y t^\\star)} = \\exp((\\beta_y - \\beta_z)t^\\star)\n$$\n通过取自然对数求解 $t^\\star$：\n$$\n\\ln\\left(\\frac{\\beta_y}{\\beta_z}\\right) = (\\beta_y - \\beta_z) t^\\star\n$$\n$$\nt^\\star = \\frac{\\ln(\\beta_y / \\beta_z)}{\\beta_y - \\beta_z}\n$$\n这是适应时间的表达式。由于 $\\beta_y$ 和 $\\beta_z$ 是单位为 $\\mathrm{h}^{-1}$ 的速率，所以 $t^\\star$ 的单位是小时。\n\n适应振幅 $A^\\star$ 是 $\\delta y(t)$ 在 $t=t^\\star$ 时的值：\n$$\nA^\\star = \\delta y(t^\\star) = \\frac{p\\, \\Delta x}{\\beta_y - \\beta_z} (\\exp(-\\beta_z t^\\star) - \\exp(-\\beta_y t^\\star))\n$$\n根据最大值处的条件，我们有 $\\exp(-\\beta_y t^\\star) = \\frac{\\beta_z}{\\beta_y} \\exp(-\\beta_z t^\\star)$。将此代入 $A^\\star$ 的表达式中：\n$$\nA^\\star = \\frac{p\\, \\Delta x}{\\beta_y - \\beta_z} \\left(\\exp(-\\beta_z t^\\star) - \\frac{\\beta_z}{\\beta_y} \\exp(-\\beta_z t^\\star)\\right) = \\frac{p\\, \\Delta x}{\\beta_y - \\beta_z} \\exp(-\\beta_z t^\\star) \\left(1 - \\frac{\\beta_z}{\\beta_y}\\right)\n$$\n$$\nA^\\star = \\frac{p\\, \\Delta x}{\\beta_y - \\beta_z} \\exp(-\\beta_z t^\\star) \\left(\\frac{\\beta_y - \\beta_z}{\\beta_y}\\right) = \\frac{p\\, \\Delta x}{\\beta_y} \\exp(-\\beta_z t^\\star)\n$$\n现在我们计算 $\\exp(-\\beta_z t^\\star)$：\n$$\n-\\beta_z t^\\star = -\\beta_z \\frac{\\ln(\\beta_y / \\beta_z)}{\\beta_y - \\beta_z} = \\frac{-\\beta_z}{\\beta_y - \\beta_z} \\ln\\left(\\frac{\\beta_y}{\\beta_z}\\right) = \\ln\\left[ \\left(\\frac{\\beta_y}{\\beta_z}\\right)^{-\\frac{\\beta_z}{\\beta_y - \\beta_z}} \\right]\n$$\n因此，$\\exp(-\\beta_z t^\\star) = \\left(\\frac{\\beta_y}{\\beta_z}\\right)^{-\\frac{\\beta_z}{\\beta_y - \\beta_z}}$。\n将此代入 $A^\\star$ 的表达式中：\n$$\nA^\\star = \\frac{p\\, \\Delta x}{\\beta_y} \\left(\\frac{\\beta_y}{\\beta_z}\\right)^{-\\frac{\\beta_z}{\\beta_y - \\beta_z}}\n$$\n这是适应振幅的表达式。该量按要求是无量纲的。\n\n适应振幅 $A^\\star$ 和适应时间 $t^\\star$ 的最终表达式如下所示。使用的一个附加条件是 $\\Delta x  0$，以确保在 $t0$ 时存在非平凡的最大值。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{p \\Delta x}{\\beta_y} \\left(\\frac{\\beta_y}{\\beta_z}\\right)^{-\\frac{\\beta_z}{\\beta_y - \\beta_z}} \\\\\n\\\\\n\\frac{\\ln\\left(\\frac{\\beta_y}{\\beta_z}\\right)}{\\beta_y - \\beta_z}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "在构建了基因调控网络的拓扑结构之后，下一个关键步骤是从实验获得的时间序列数据中估计模型的动力学参数。这个过程充满了挑战，尤其是在处理数据噪声和模型的“刚性”（stiffness）问题时，后者指的是系统中存在多个时间尺度的动态过程。本练习将让您对比两种主流的参数推断方法：计算上较为高效但对噪声敏感的“梯度匹配法”，以及结果更精确但计算成本高昂的“基于常微分方程（ODE）的直接拟合”。通过这个实践，您将深入理解不同推断策略在准确性和计算资源之间的权衡，并掌握处理实际建模问题时的关键考量。",
            "id": "3314906",
            "problem": "基因调控网络 (GRN) 模型用于描述基因表达组分（如信使核糖核酸 (mRNA) 和蛋白质）在调控相互作用下的动力学。从分子生物学的中心法则和质量作用动力学出发，考虑一个具有两个动力学变量的负向自动调控单基因回路：mRNA 浓度 $m(t)$ 和蛋白质浓度 $p(t)$。该系统由以下常微分方程 (ODE) 建模：\n$$\n\\frac{dm}{dt} = \\frac{\\alpha}{1 + \\left(\\frac{p}{K}\\right)^n} - \\delta_m\\, m, \\quad\n\\frac{dp}{dt} = \\beta\\, m - \\delta_p\\, p,\n$$\n其中 $\\alpha$ 是最大转录速率，$K$ 是抑制阈值，$n$ 是 Hill 系数，$\\beta$ 是翻译速率，$\\delta_m$ 是 mRNA 降解速率，$\\delta_p$ 是蛋白质降解速率。由于尺度分离 $ \\delta_m \\gg \\delta_p $，系统出现刚性问题，这使得 $m(t)$ 比 $p(t)$ 松弛得快得多。时间是无量纲的，所有要求的输出都是无单位的。合成观测数据是通过使用已知参数对 ODE 进行积分以获得真实轨迹 $m(t)$ 和 $p(t)$，并在固定时间范围 $[0,T]$ 内以均匀间隔 $\\Delta t$ 对其进行采样，然后对每个物种施加均值为零、标准差为 $\\sigma$ 的独立加性高斯噪声而生成的。\n\n两种参数推断策略将被比较：\n- 带平滑惩罚的梯度匹配：给定带噪声的样本 $\\{(t_k, y_m(t_k)), (t_k, y_p(t_k))\\}_{k=0}^{N-1}$，通过具有平滑参数 $s$ 的三次平滑样条获得平滑函数 $\\tilde m(t)$ 和 $\\tilde p(t)$；然后在采样时间点估计时间导数 $\\frac{d\\tilde m}{dt}$ 和 $\\frac{d\\tilde p}{dt}$。使用这些导数，通过对模型残差进行线性最小二乘拟合来估计 $\\delta_m$ 和 $\\delta_p$。具体来说，定义残差序列\n$$\nr_m(t_k) = \\frac{\\alpha}{1 + \\left(\\frac{\\tilde p(t_k)}{K}\\right)^n} - \\frac{d\\tilde m}{dt}(t_k), \\quad\nr_p(t_k) = \\beta\\,\\tilde m(t_k) - \\frac{d\\tilde p}{dt}(t_k),\n$$\n并估计\n$$\n\\hat{\\delta}_m = \\frac{\\sum_{k=0}^{N-1} \\tilde m(t_k)\\, r_m(t_k)}{\\sum_{k=0}^{N-1} \\tilde m(t_k)^2}, \\quad\n\\hat{\\delta}_p = \\frac{\\sum_{k=0}^{N-1} \\tilde p(t_k)\\, r_p(t_k)}{\\sum_{k=0}^{N-1} \\tilde p(t_k)^2},\n$$\n如有必要，通过截断到一个小的正值来强制执行约束 $\\hat{\\delta}_m  0$ 和 $\\hat{\\delta}_p  0$。平滑样条使用一个平滑参数 $s$ 来控制对曲率的惩罚，从而在导数估计中引入偏差，并因此在参数估计中引入偏差；该偏差将被量化为 $\\Delta t$ 的函数。\n- 使用最小二乘数据拟合的完全 ODE 积分：通过最小化数值 ODE 解 $x(t;\\delta_m,\\delta_p)$ 与在采样时间点评估的带噪声观测值之间的平方差异之和来估计 $\\delta_m$ 和 $\\delta_p$。优化变量被约束为正。ODE 积分应使用刚性求解器。\n\n推导和算法设计的基本依据：\n- 质量作用式的生成和降解项以及 Hill 型的抑制动力学是 GRN 建模中标准且广泛使用的方法。\n- 观测模型是 $y_m(t_k) = m(t_k) + \\varepsilon_{m,k}$ 和 $y_p(t_k) = p(t_k) + \\varepsilon_{p,k}$，其中 $\\varepsilon_{m,k}, \\varepsilon_{p,k} \\sim \\mathcal{N}(0,\\sigma^2)$ 独立同分布。\n- 梯度匹配将平滑数据中估计的导数与 ODE 右侧对齐，以使用最小二乘投影推断参数。\n- 完全 ODE 积分估计通过最小化模型预测与测量数据之间的差异来拟合参数，并利用刚性数值积分。\n\n你的任务：\n1. 使用上述 ODE 和以下参数模拟真实轨迹\n$$\n\\alpha = 100,\\ \\beta = 1,\\ K = 50,\\ n = 2,\\ \\delta_m^{\\mathrm{true}} = 5,\\ \\delta_p^{\\mathrm{true}} = 0.5.\n$$\n使用初始条件\n$$\nm(0) = 0,\\quad p(0) = 0,\n$$\n时间范围\n$$\nT = 10,\n$$\n并对 $m$ 和 $p$ 的样本添加独立的、具有\n$$\n\\sigma = 0.5\n$$\n的高斯噪声。假设推断过程已知初始条件。\n2. 对于梯度匹配，使用三次平滑样条，其固定的平滑参数 $s$ 在不同物种间共享，由下式给出\n$$\ns = \\sigma^2\\, T,\n$$\n并如上所述计算 $\\hat{\\delta}_m$ 和 $\\hat{\\delta}_p$。\n3. 对于基于完全 ODE 的推断，使用刚性 ODE 求解器和初始猜测值\n$$\n\\delta_m^{(0)} = 2.5,\\quad \\delta_p^{(0)} = 1.0,\n$$\n通过最小二乘拟合来估计 $\\delta_m$ 和 $\\delta_p$，并在优化过程中强制执行正值约束。\n4. 对每个采样间隔 $\\Delta t$，通过计算两个参数的平均绝对相对误差来量化每种方法的偏差：\n$$\nb_{\\mathrm{gm}}(\\Delta t) = \\frac{1}{2}\\left(\\frac{\\left|\\hat{\\delta}_m - \\delta_m^{\\mathrm{true}}\\right|}{\\delta_m^{\\mathrm{true}}} + \\frac{\\left|\\hat{\\delta}_p - \\delta_p^{\\mathrm{true}}\\right|}{\\delta_p^{\\mathrm{true}}}\\right),\n$$\n$$\nb_{\\mathrm{ode}}(\\Delta t) = \\frac{1}{2}\\left(\\frac{\\left|\\hat{\\delta}_m^{\\mathrm{ode}} - \\delta_m^{\\mathrm{true}}\\right|}{\\delta_m^{\\mathrm{true}}} + \\frac{\\left|\\hat{\\delta}_p^{\\mathrm{ode}} - \\delta_p^{\\mathrm{true}}\\right|}{\\delta_p^{\\mathrm{true}}}\\right).\n$$\n5. 对测试集中的每个 $\\Delta t$，计算数据对 $\\left[b_{\\mathrm{gm}}(\\Delta t),\\, b_{\\mathrm{ode}}(\\Delta t)\\right]$：\n$$\n\\Delta t \\in \\{0.02,\\ 0.05,\\ 0.1,\\ 0.2,\\ 0.5\\}.\n$$\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，列表中的每个条目是一个双元素浮点数列表，对应于在指定 $\\Delta t$ 值下的 $\\left[b_{\\mathrm{gm}}(\\Delta t),\\, b_{\\mathrm{ode}}(\\Delta t)\\right]$，顺序与上面列出的一致。例如，输出应具有以下形式\n$$\n\\left[\\left[b_{\\mathrm{gm}}(0.02),b_{\\mathrm{ode}}(0.02)\\right],\\left[b_{\\mathrm{gm}}(0.05),b_{\\mathrm{ode}}(0.05)\\right],\\dots\\right].\n$$\n所有输出都是无单位的小数。",
            "solution": "该问题要求比较基因调控网络模型的两种参数推断方法。解决方案的设计是首先模拟合成数据，然后应用每种推断方法来估计关键参数，最后量化其准确性。\n\n首先，对基因调控网络进行精确的模拟以生成基准真实数据。该系统由一对耦合的常微分方程 (ODE) 描述，模拟一个负向自动调控的基因。转录过程用表示抑制的 Hill 函数建模，所有其他生成/降解步骤遵循质量作用动力学。给定的 ODE 系统是：\n$$\n\\frac{dm}{dt} = \\frac{\\alpha}{1 + \\left(\\frac{p}{K}\\right)^n} - \\delta_m\\, m\n$$\n$$\n\\frac{dp}{dt} = \\beta\\, m - \\delta_p\\, p\n$$\n我们使用指定的真实参数值对该系统进行数值积分：$\\alpha = 100$，$\\beta = 1$，$K = 50$，$n = 2$，$\\delta_m^{\\mathrm{true}} = 5$，以及 $\\delta_p^{\\mathrm{true}} = 0.5$。积分在时间范围 $t \\in [0, T]$（其中 $T=10$）上进行，从初始条件 $m(0) = 0$ 和 $p(0) = 0$ 开始。降解速率之间的显著差异 ($\\delta_m \\gg \\delta_p$) 给系统带来刚性，这需要使用专门的数值求解器，如向后微分公式 (BDF) 方法，以确保稳定高效的积分。从连续的真实解轨迹 $m(t)$ 和 $p(t)$ 中，为指定的采样间隔列表 $\\Delta t \\in \\{0.02, 0.05, 0.1, 0.2, 0.5\\}$ 生成合成数据集。对于每个 $\\Delta t$，在离散时间点 $t_k = k \\Delta t$ 对真实解进行采样，并向 mRNA ($m$) 和蛋白质 ($p$) 的浓度样本中添加均值为 $0$、标准差为 $\\sigma=0.5$ 的独立加性高斯噪声，从而得到带噪声的观测值 $\\{y_m(t_k), y_p(t_k)\\}$。\n\n准备好合成数据后，实施两种不同的参数推断策略来估计降解速率 $\\delta_m$ 和 $\\delta_p$，假设所有其他模型参数（$\\alpha, \\beta, K, n$）已知。\n\n第一种策略是梯度匹配。该方法的原理是通过将微分方程转换为代数方程来避免重复求解 ODE 这一计算密集型任务。这是通过首先从噪声数据中获得状态轨迹的光滑、可微的近似来实现的。我们对每个时间序列数据集 $\\{t_k, y_m(t_k)\\}$ 和 $\\{t_k, y_p(t_k)\\}$ 拟合一个三次平滑样条。问题指定了一个固定的平滑参数 $s = \\sigma^2 T = (0.5)^2 \\times 10 = 2.5$。这些表示为 $\\tilde{m}(t)$ 和 $\\tilde{p}(t)$ 的样条随后被用来估计在采样点 $t_k$ 的状态值及其一阶导数。通过将这些估计值代入 ODE，我们得到一个在目标参数 $\\delta_m$ 和 $\\delta_p$ 上线性的代数系统：\n$$\n\\delta_m \\tilde{m}(t_k) \\approx \\frac{\\alpha}{1 + (\\tilde{p}(t_k)/K)^n} - \\frac{d\\tilde{m}}{dt}(t_k) \\equiv r_m(t_k)\n$$\n$$\n\\delta_p \\tilde{p}(t_k) \\approx \\beta \\tilde{m}(t_k) - \\frac{d\\tilde{p}}{dt}(t_k) \\equiv r_p(t_k)\n$$\n该系统以最小二乘法求解 $\\delta_m$ 和 $\\delta_p$，得到问题陈述中定义的估计量 $\\hat{\\delta}_m$ 和 $\\hat{\\delta}_p$。通过将任何非正估计值截断为一个小的机器精度值来强制执行正值的物理约束。\n\n第二种策略是基于完全 ODE 的拟合方法。这是一种更直接的方法，包括找到参数集 $(\\hat{\\delta}_m^{\\mathrm{ode}}, \\hat{\\delta}_p^{\\mathrm{ode}})$ 以最小化完整模型的预测轨迹与观测到的噪声数据之间的差异。差异由所有时间点和两个物种的平方误差和 (SSE) 来量化：\n$$\n\\mathrm{SSE}(\\delta_m, \\delta_p) = \\sum_{k=0}^{N-1} \\left[ (m(t_k; \\delta_m, \\delta_p) - y_m(t_k))^2 + (p(t_k; \\delta_m, \\delta_p) - y_p(t_k))^2 \\right]\n$$\n这里，$m(t_k; \\delta_m, \\delta_p)$ 和 $p(t_k; \\delta_m, \\delta_p)$ 表示使用给定候选参数集 $(\\delta_m, \\delta_p)$ 对 ODE 系统进行数值求解得到的结果。为了解决这个非线性优化问题，我们采用 L-BFGS-B 算法，这是一种适用于箱型约束问题的拟牛顿法。这使得可以自然地强制执行正值约束 $\\delta_m  0$ 和 $\\delta_p  0$。优化从猜测值 $(\\delta_m^{(0)}, \\delta_p^{(0)}) = (2.5, 1.0)$ 开始。SSE 目标函数的每次评估都需要对刚性 ODE 系统进行一次完整的数值积分。\n\n最后，对于每个采样间隔 $\\Delta t$，通过计算两个参数的平均绝对相对误差来量化两种方法的估计精度，该误差可作为偏差的度量：$b_{\\mathrm{gm}}(\\Delta t)$ 和 $b_{\\mathrm{ode}}(\\Delta t)$。为测试集中的每个 $\\Delta t$ 计算偏差值对 $[b_{\\mathrm{gm}}(\\Delta t), b_{\\mathrm{ode}}(\\Delta t)]$，并将其格式化为指定的输出结构，从而便于直接比较两种推断方法在不同数据采样密度下的性能。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nfrom scipy.interpolate import UnivariateSpline\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Simulates a gene regulatory network, applies two parameter inference methods,\n    and compares their bias as a function of data sampling rate.\n    \"\"\"\n    # --- Problem Parameters ---\n    # True parameters for data generation\n    alpha = 100.0\n    beta = 1.0\n    K = 50.0\n    n = 2.0\n    delta_m_true = 5.0\n    delta_p_true = 0.5\n    \n    # Simulation and data parameters\n    m0, p0 = 0.0, 0.0\n    T = 10.0\n    sigma = 0.5\n    \n    # Inference parameters\n    s = sigma**2 * T\n    delta_m_guess, delta_p_guess = 2.5, 1.0\n    \n    # Test suite for sampling intervals\n    delta_t_values = [0.02, 0.05, 0.1, 0.2, 0.5]\n    \n    # Set a seed for reproducibility of noise generation\n    rng = np.random.default_rng(0)\n    \n    # Small positive value for positivity constraints\n    eps = np.finfo(float).eps\n\n    # --- Helper Functions ---\n    def ode_system(t, y, p_ode):\n        \"\"\"Defines the ODE system for the gene regulatory network.\"\"\"\n        m, p = y\n        alpha_loc, K_loc, n_loc, beta_loc, delta_m_loc, delta_p_loc = p_ode\n        dmdt = alpha_loc / (1.0 + (p / K_loc)**n_loc) - delta_m_loc * m\n        dpdt = beta_loc * m - delta_p_loc * p\n        return [dmdt, dpdt]\n\n    # --- 1. Generate True Trajectory ---\n    # The true trajectory is computed once with high precision.\n    true_params = (alpha, K, n, beta, delta_m_true, delta_p_true)\n    sol_true = solve_ivp(\n        lambda t, y: ode_system(t, y, true_params),\n        [0, T],\n        [m0, p0],\n        method='BDF',\n        dense_output=True,\n        rtol=1e-6,\n        atol=1e-9\n    )\n\n    results = []\n    \n    # --- Loop over specified sampling intervals ---\n    for dt in delta_t_values:\n        # --- 2. Generate Noisy Observations ---\n        num_points = int(round(T / dt)) + 1\n        t_obs = np.linspace(0, T, num_points)\n        \n        true_data = sol_true.sol(t_obs)\n        noise = rng.normal(0, sigma, size=true_data.shape)\n        y_obs = true_data + noise\n        y_m_obs, y_p_obs = y_obs[0, :], y_obs[1, :]\n\n        # --- Method 1: Gradient Matching ---\n        spl_m = UnivariateSpline(t_obs, y_m_obs, s=s, k=3)\n        spl_p = UnivariateSpline(t_obs, y_p_obs, s=s, k=3)\n        \n        m_tilde = spl_m(t_obs)\n        p_tilde = spl_p(t_obs)\n        dm_dt_tilde = spl_m.derivative(n=1)(t_obs)\n        dp_dt_tilde = spl_p.derivative(n=1)(t_obs)\n        \n        r_m_gm = alpha / (1.0 + (p_tilde / K)**n) - dm_dt_tilde\n        r_p_gm = beta * m_tilde - dp_dt_tilde\n        \n        hat_delta_m_gm = np.dot(m_tilde, r_m_gm) / np.dot(m_tilde, m_tilde)\n        hat_delta_p_gm = np.dot(p_tilde, r_p_gm) / np.dot(p_tilde, p_tilde)\n        \n        hat_delta_m_gm = max(hat_delta_m_gm, eps)\n        hat_delta_p_gm = max(hat_delta_p_gm, eps)\n        \n        b_gm = 0.5 * (\n            abs(hat_delta_m_gm - delta_m_true) / delta_m_true +\n            abs(hat_delta_p_gm - delta_p_true) / delta_p_true\n        )\n\n        # --- Method 2: Full ODE Integration Fitting ---\n        def objective_func(params_to_opt, t, y_m, y_p):\n            \"\"\"Objective function for ODE-based least-squares fitting.\"\"\"\n            delta_m_opt, delta_p_opt = params_to_opt\n            current_params = (alpha, K, n, beta, delta_m_opt, delta_p_opt)\n            \n            sol_fit = solve_ivp(\n                lambda t_eval, y: ode_system(t_eval, y, current_params),\n                [0, T],\n                [m0, p0],\n                method='BDF',\n                t_eval=t,\n                rtol=1e-6,\n                atol=1e-9\n            )\n            \n            if sol_fit.status != 0 or sol_fit.y.shape[1] != len(t):\n                return np.inf\n\n            m_sol, p_sol = sol_fit.y\n            sse = np.sum((m_sol - y_m)**2) + np.sum((p_sol - y_p)**2)\n            return sse\n\n        opt_result = minimize(\n            objective_func,\n            x0=[delta_m_guess, delta_p_guess],\n            args=(t_obs, y_m_obs, y_p_obs),\n            method='L-BFGS-B',\n            bounds=[(eps, None), (eps, None)]\n        )\n        \n        hat_delta_m_ode, hat_delta_p_ode = opt_result.x\n        \n        b_ode = 0.5 * (\n            abs(hat_delta_m_ode - delta_m_true) / delta_m_true +\n            abs(hat_delta_p_ode - delta_p_true) / delta_p_true\n        )\n        \n        results.append([b_gm, b_ode])\n        \n    # --- Final Output Formatting ---\n    # The output format must exactly match [[b_gm1,b_ode1],[b_gm2,b_ode2],...]\n    formatted_results = [f\"[{res[0]},{res[1]}]\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}