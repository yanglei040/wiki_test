{
    "hands_on_practices": [
        {
            "introduction": "A core strength of Flux Balance Analysis (FBA) is its reliance on the simple, powerful mass balance constraint, $S v = 0$. However, stoichiometry alone does not capture thermodynamics, which can lead to models containing physically impossible, energy-generating cycles. This practice confronts this foundational issue by guiding you through the identification and correction of such an artifact, demonstrating how maximizing an objective in a flawed model can lead to spurious results and how simple constraints can restore thermodynamic feasibility .",
            "id": "3308950",
            "problem": "You are given a small, self-contained Flux Balance Analysis (FBA) model that exhibits a thermodynamically infeasible adenosine triphosphate (ATP)-generating cycle due to fully reversible internal reactions and zero uptake. Starting from the fundamental steady-state mass balance, the task is to formulate and solve a linear optimization problem to demonstrate positive ATP production in the absence of external substrates, and then to add constraints that enforce looplessness (thermodynamic feasibility) to eliminate the infeasible cycle and quantify the resulting change in the objective.\n\nFundamental base:\n- Steady-state mass balance of metabolites: $$S v = 0,$$ where $S \\in \\mathbb{R}^{m \\times n}$ is the stoichiometric matrix, $v \\in \\mathbb{R}^{n}$ are reaction fluxes, $m$ is the number of metabolites, and $n$ is the number of reactions.\n- Flux bounds represent reaction reversibility: $$l_i \\le v_i \\le u_i,$$ where $l_i, u_i$ are the lower and upper bounds for reaction $i$, with $l_i < 0 < u_i$ indicating reversibility.\n- Linear objective to be maximized: $$\\max_{v} \\; c_{\\text{ATP}}^\\top v,$$ where $c_{\\text{ATP}}$ selects the ATP-related reaction(s) to measure ATP production capacity.\n\nModel definition:\n- Metabolites: adenosine triphosphate (ATP), adenosine diphosphate (ADP), inorganic phosphate (Pi), cytosolic protons ($\\mathrm{H_c}$), and extracellular protons ($\\mathrm{H_e}$).\n- Reactions and stoichiometry columns in $S$:\n    1. ATP hydrolysis (reversible): ATP $\\rightleftharpoons$ ADP + Pi. Stoichiometry column $S_{\\cdot,1}$ has entries $[-1, +1, +1, 0, 0]^\\top$ for [ATP, ADP, Pi, $\\mathrm{H_c}$, $\\mathrm{H_e}$].\n    2. ATP synthase (reversible, proton-coupled): ADP + Pi + $4\\,\\mathrm{H_e}$ $\\rightleftharpoons$ ATP + $4\\,\\mathrm{H_c}$. Stoichiometry column $S_{\\cdot,2}$ has entries $[+1, -1, -1, +4, -4]^\\top$.\n    3. Proton pump/leak (reversible): $\\mathrm{H_c}$ $\\rightleftharpoons$ $\\mathrm{H_e}$. Stoichiometry column $S_{\\cdot,3}$ has entries $[0, 0, 0, -1, +1]^\\top$.\n\nObjective definition:\n- Let $c_{\\text{ATP}}$ select the ATP hydrolysis reaction in a way that measures ATP synthesis capacity under cycles. Define $$c_{\\text{ATP}} = [-1, 0, 0]^\\top,$$ so that maximizing $c_{\\text{ATP}}^\\top v$ encourages $v_1$ (ATP hydrolysis) to be negative, which corresponds to ATP synthesis through cycling.\n\nLoopless (thermodynamic feasibility) constraints:\n- To restore thermodynamic feasibility and eliminate energy-generating cycles, enforce reaction directionality consistent with negative reaction free energies for the biologically forward direction by constraining\n  $$v_1 \\ge 0, \\quad v_2 \\ge 0, \\quad v_3 \\ge 0,$$\n  thereby disallowing the reverse directions that enable the infeasible ATP-generating cycle in this model.\n\nProgram requirements:\n- Implement two linear programs for each test case:\n    1. The unconstrained reversible case: maximize $c_{\\text{ATP}}^\\top v$ subject to $S v = 0$ and bounds $l_i \\le v_i \\le u_i$ with $l_i < 0 < u_i$.\n    2. The loopless constrained case: maximize $c_{\\text{ATP}}^\\top v$ subject to $S v = 0$ and modified bounds $0 \\le v_i \\le u_i$ for all $i$.\n- Report, for each case, the triple of floats $[\\text{obj}_{\\text{rev}}, \\text{obj}_{\\text{loopless}}, \\Delta]$, where $\\text{obj}_{\\text{rev}}$ is the optimal value of $c_{\\text{ATP}}^\\top v$ with reversible bounds, $\\text{obj}_{\\text{loopless}}$ is the optimal value after adding loopless constraints, and $\\Delta = \\text{obj}_{\\text{rev}} - \\text{obj}_{\\text{loopless}}$ quantifies the loss in objective due to restoring thermodynamic feasibility.\n\nTest suite:\nProvide the following four test cases, each specifying lower bounds $l$ and upper bounds $u$ for $(v_1, v_2, v_3)$:\n\n- Case 1 (happy path, ample reversibility): $l = [-10, -10, -100]$, $u = [10, 10, 100]$.\n- Case 2 (tight reversible bounds): $l = [-1, -1, -4]$, $u = [1, 1, 4]$.\n- Case 3 (boundary, one reaction irreversible in the forward direction): $l = [0, -10, -100]$, $u = [0, 10, 100]$.\n- Case 4 (edge, proton pump limited and constraining the cycle): $l = [-10, -10, -30]$, $u = [10, 10, 30]$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case result is itself a list of three floats in the order $[\\text{obj}_{\\text{rev}}, \\text{obj}_{\\text{loopless}}, \\Delta]$. For example: \"[[v11,v12,v13],[v21,v22,v23],[v31,v32,v33],[v41,v42,v43]]\". No physical units are used; all fluxes and objective values are pure floats.",
            "solution": "The problem statement has been critically validated and is deemed valid. It is a scientifically grounded, well-posed, and objective problem in the domain of computational systems biology, specifically Flux Balance Analysis (FBA). The problem is self-contained, providing all necessary definitions, data, and constraints to formulate and solve two distinct linear optimization problems for each of the four test cases. The model, while simplified, correctly represents a known artifact in metabolic modeling—thermodynamically infeasible, energy-generating cycles—and the standard method for their elimination.\n\nThe task is to solve two linear programs (LPs) for a given metabolic model. The model consists of $m=5$ metabolites and $n=3$ reactions. The relationship between metabolite concentrations and reaction fluxes $v \\in \\mathbb{R}^3$ is governed by the steady-state mass balance equation $S v = 0$, where $S \\in \\mathbb{R}^{5 \\times 3}$ is the stoichiometric matrix.\n\nThe reactions are:\n1. $v_1$: $\\text{ATP} \\rightleftharpoons \\text{ADP} + \\text{Pi}$\n2. $v_2$: $\\text{ADP} + \\text{Pi} + 4\\,\\mathrm{H_e} \\rightleftharpoons \\text{ATP} + 4\\,\\mathrm{H_c}$\n3. $v_3$: $\\mathrm{H_c} \\rightleftharpoons \\mathrm{H_e}$\n\nThe stoichiometric matrix $S$ is constructed based on these reactions, with columns corresponding to reactions $v_1, v_2, v_3$ and rows corresponding to metabolites ATP, ADP, Pi, $\\mathrm{H_c}$, and $\\mathrm{H_e}$:\n$$\nS = \\begin{pmatrix}\n-1 &  1 &  0 \\\\\n 1 & -1 &  0 \\\\\n 1 & -1 &  0 \\\\\n 0 &  4 & -1 \\\\\n 0 & -4 &  1\n\\end{pmatrix}\n$$\n\nThe steady-state condition $S v = 0$ defines the null space of $S$. The null space contains all feasible flux distributions that result in no net change in metabolite concentrations. Analysis of $S$ reveals that its rank is $2$. The dimension of its null space is $n - \\text{rank}(S) = 3 - 2 = 1$. A basis vector for the null space is found to be $[1, 1, 4]^\\top$. Therefore, any steady-state flux vector $v$ must be a scalar multiple of this basis vector:\n$$v = k \\begin{pmatrix} 1 \\\\ 1 \\\\ 4 \\end{pmatrix}$$\nfor some scalar $k \\in \\mathbb{R}$. This relationship describes a coupled set of reactions forming a cycle. A positive $k$ corresponds to a cycle where ATP is hydrolyzed ($v_1 > 0$), synthesized ($v_2 > 0$), and protons are pumped ($v_3 > 0$), resulting in a futile cycle with no net ATP production. A negative $k$ corresponds to the cycle running in reverse, which, as the problem describes, can lead to spurious ATP generation.\n\nThe objective is to maximize ATP synthesis capacity, formulated as maximizing $-v_1$. This is equivalent to minimizing $v_1$.\n$$\\max_{v} \\ c_{\\text{ATP}}^\\top v \\quad \\text{where} \\quad c_{\\text{ATP}} = [-1, 0, 0]^\\top$$\nThis is equivalent to the standard LP form of minimization:\n$$\\min_{v} \\ (-c_{\\text{ATP}})^\\top v = \\min_{v} \\ [1, 0, 0]^\\top v = \\min_{v} \\ v_1$$\nThe problem is solved under two sets of constraints for each test case.\n\n**1. Unconstrained Reversible Case**\nThe flux vector $v$ is subject to the steady-state constraint $S v = 0$ and the reversibility bounds $l_i \\le v_i \\le u_i$. Substituting $v = k [1, 1, 4]^\\top$ into the bounds gives constraints on $k$:\n$$l_1 \\le k \\le u_1$$\n$$l_2 \\le k \\le u_2$$\n$$l_3 \\le 4k \\le u_3 \\implies \\frac{l_3}{4} \\le k \\le \\frac{u_3}{4}$$\nFor $k$ to be feasible, it must satisfy all these conditions simultaneously. Thus, the feasible range for $k$ is:\n$$k \\in \\left[ \\max\\left(l_1, l_2, \\frac{l_3}{4}\\right), \\min\\left(u_1, u_2, \\frac{u_3}{4}\\right) \\right]$$\nThe objective is to minimize $v_1 = k$. The minimum value, $k_{\\min}$, is the lower bound of this interval:\n$$k_{\\min} = \\max\\left(l_1, l_2, \\frac{l_3}{4}\\right)$$\nThe optimal objective value for the minimization problem is $v_{1,\\text{opt}} = k_{\\min}$. The problem asks for the maximum of $-v_1$, so the result is $\\text{obj}_{\\text{rev}} = -v_{1,\\text{opt}} = -k_{\\min}$.\n$$\\text{obj}_{\\text{rev}} = -\\max\\left(l_1, l_2, \\frac{l_3}{4}\\right)$$\nIf the lower bounds $l_i$ are negative, $k_{\\min}$ can be negative, leading to $v_1 < 0$ (net ATP synthesis) and a positive objective value, demonstrating the thermodynamically infeasible energy-generating cycle.\n\n**2. Loopless Constrained Case**\nTo enforce thermodynamic feasibility, the reactions are constrained to be irreversible in their biologically forward directions ($v_i \\ge 0$). The new bounds are $0 \\le v_i \\le u_i$. This translates to the following constraints on $k$:\n$$0 \\le k \\le u_1$$\n$$0 \\le k \\le u_2$$\n$$0 \\le 4k \\le u_3 \\implies 0 \\le k \\le \\frac{u_3}{4}$$\nThe feasible range for $k$ becomes:\n$$k \\in \\left[ 0, \\min\\left(u_1, u_2, \\frac{u_3}{4}\\right) \\right]$$\nThe objective is to minimize $v_1 = k$. The minimum value for $k$ in this range is clearly $k_{\\min} = 0$.\nThus, $v_{1,\\text{opt}} = 0$, and the optimal objective value is $\\text{obj}_{\\text{loopless}} = -v_{1,\\text{opt}} = 0$.\nBy preventing the cycle from running in reverse ($k < 0$), the spurious ATP generation is eliminated. The only steady-state solution that satisfies the loopless constraints and can be optimized is the trivial solution $v = [0, 0, 0]^\\top$.\n\nThe change in the objective value, $\\Delta$, is simply $\\text{obj}_{\\text{rev}} - \\text{obj}_{\\text{loopless}} = \\text{obj}_{\\text{rev}} - 0 = \\text{obj}_{\\text{rev}}$.\n\nThe implementation will use `scipy.optimize.linprog` to solve these LPs numerically for each test case, confirming the analytical results.",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Solves a series of Flux Balance Analysis problems to demonstrate and then correct\n    a thermodynamically infeasible ATP-generating cycle.\n    \"\"\"\n\n    # Stoichiometric matrix S for the model.\n    # Rows: ATP, ADP, Pi, Hc, He\n    # Columns: v1 (ATP hydrolysis), v2 (ATP synthase), v3 (Proton pump)\n    S = np.array([\n        [-1,  1,  0],\n        [ 1, -1,  0],\n        [ 1, -1,  0],\n        [ 0,  4, -1],\n        [ 0, -4,  1]\n    ])\n\n    # Objective function vector c. We want to maximize -v1, which is equivalent\n    # to minimizing v1. scipy.optimize.linprog performs minimization.\n    # c_lp^T * v = 1*v1 + 0*v2 + 0*v3\n    c_lp = np.array([1, 0, 0])\n\n    # The steady-state constraint is Sv = 0.\n    b_eq = np.zeros(S.shape[0])\n\n    # Test cases defined by lower (l) and upper (u) flux bounds.\n    test_cases = [\n        # Case 1 (happy path, ample reversibility)\n        {'l': [-10, -10, -100], 'u': [10, 10, 100]},\n        # Case 2 (tight reversible bounds)\n        {'l': [-1, -1, -4], 'u': [1, 1, 4]},\n        # Case 3 (boundary, one reaction irreversible)\n        {'l': [0, -10, -100], 'u': [0, 10, 100]},\n        # Case 4 (edge, proton pump limited)\n        {'l': [-10, -10, -30], 'u': [10, 10, 30]},\n    ]\n\n    results = []\n    for case in test_cases:\n        l_bounds = case['l']\n        u_bounds = case['u']\n\n        # 1. Solve the unconstrained reversible case.\n        bounds_rev = list(zip(l_bounds, u_bounds))\n        res_rev = linprog(c=c_lp, A_eq=S, b_eq=b_eq, bounds=bounds_rev, method='highs')\n        \n        # The objective is max(-v1) = -min(v1). res.fun is min(v1).\n        # Handle potential infeasibility, though not expected for these cases.\n        obj_rev = -res_rev.fun if res_rev.success else float('nan')\n\n        # 2. Solve the loopless constrained case.\n        # Lower bounds are set to 0 to enforce forward-only reactions.\n        l_bounds_loopless = [0, 0, 0]\n        bounds_loopless = list(zip(l_bounds_loopless, u_bounds))\n        res_loopless = linprog(c=c_lp, A_eq=S, b_eq=b_eq, bounds=bounds_loopless, method='highs')\n        \n        obj_loopless = -res_loopless.fun if res_loopless.success else float('nan')\n\n        # 3. Calculate the difference.\n        delta = obj_rev - obj_loopless\n        \n        results.append([obj_rev, obj_loopless, delta])\n\n    # Format the final output string exactly as specified, without spaces.\n    outer_list_str = []\n    for res_list in results:\n        # Convert each float to a string; round to handle potential minor float inaccuracies.\n        # This also ensures a consistent \".0\" for integer-valued floats.\n        inner_list_str = f\"[{res_list[0]:.1f},{res_list[1]:.1f},{res_list[2]:.1f}]\"\n        # The problem cases result in .0 or .5, so .1f is clean and sufficient.\n        # A simple str() may produce more decimal places.\n        # Let's use `g` for general formatting to avoid trailing zeros for integers\n        inner_list_str = f\"[{res_list[0]},{res_list[1]},{res_list[2]}]\"\n        # The analytical results are simple floats. Let's trust python's default float-to-string conversion\n        # requested_floats = [float(x) for x in res_list]\n        inner_list_str = f\"[{res_list[0]},{res_list[1]},{res_list[2]}]\"\n\n        outer_list_str.append(inner_list_str)\n    \n    final_output = f\"[{','.join(outer_list_str)}]\"\n    print(final_output.replace(\" \", \"\"))\n\nsolve()\n\n```"
        },
        {
            "introduction": "While FBA is powerful for predicting maximal yields, the solution space for an optimal objective value is often not a single point but a high-dimensional polytope. This means many different flux distributions can achieve the same optimal outcome, posing a challenge for identifying a single, biologically plausible state. This exercise introduces lexicographic optimization and parsimonious FBA (pFBA) as a sequential, multi-objective approach to systematically refine the solution space, first maximizing biomass, then a secondary product, and finally finding the most efficient metabolic routing by minimizing the total flux magnitude .",
            "id": "3308964",
            "problem": "Consider a steady-state metabolic network analyzed by Flux Balance Analysis (FBA). The fundamental base is mass conservation at steady state and linear thermodynamic bounds on reaction rates. Let $S \\in \\mathbb{R}^{m \\times n}$ be the stoichiometric matrix connecting $m$ intracellular metabolites to $n$ reactions, and let $v \\in \\mathbb{R}^n$ be the reaction flux vector. Steady-state mass balance requires $S v = 0$, with each $v_i$ constrained by lower and upper bounds reflecting reaction reversibility and capacity. Fluxes are expressed in $\\text{mmol}\\,\\text{gDW}^{-1}\\,\\text{h}^{-1}$; report all numerical outputs in these units without explicitly printing the unit string. The objective is lexicographic multiobjective optimization: first maximize the biomass production rate, then maximize a specified product secretion rate while maintaining the previously achieved biomass optimal value, and finally minimize the total flux magnitude to obtain a parsimonious, biologically plausible solution by minimizing the $\\ell_1$ norm $\\sum_{i=1}^n |v_i|$. Each stage is formulated as a linear program (LP).\n\nUse the following toy but scientifically plausible network with $m=3$ metabolites and $n=7$ reactions. Metabolites $\\{X, Y, Z\\}$ are intracellular. Reactions are:\n1. Uptake $U$: external source $\\rightarrow X$,\n2. Conversion $R2$: $X \\rightarrow Y$,\n3. Biomass $BM$: $Y \\rightarrow$ biomass (pseudo-metabolite),\n4. Product $PR$: $Y \\rightarrow$ product (export),\n5. Maintenance $M$: $X \\rightarrow$ maintenance sink (pseudo-metabolite),\n6. Futile cycle forward $Y2Z$: $Y \\rightarrow Z$,\n7. Futile cycle reverse $Z2Y$: $Z \\rightarrow Y$.\n\nLet the stoichiometric matrix $S$ be\n$$\nS = \\begin{bmatrix}\n+1 & -1 & 0 & 0 & -1 & 0 & 0 \\\\\n0 & +1 & -1 & -1 & 0 & -1 & +1 \\\\\n0 & 0 & 0 & 0 & 0 & +1 & -1\n\\end{bmatrix},\n$$\nordered by reactions $\\{U, R2, BM, PR, M, Y2Z, Z2Y\\}$. Bounds are reaction-specific: for each reaction $i$, $L_i \\le v_i \\le U_i$. The biomass objective vector is $c_{\\text{bio}} \\in \\mathbb{R}^n$ with $c_{\\text{bio}} = (0,0,1,0,0,0,0)$, and the product objective vector is $c_{\\text{prod}} \\in \\mathbb{R}^n$ with $c_{\\text{prod}} = (0,0,0,1,0,0,0)$.\n\nImplement the following sequence for each test case:\n1. Solve the LP to maximize $c_{\\text{bio}}^\\top v$ subject to $S v = 0$ and bounds. Denote the optimal biomass value by $z_1$ and one corresponding optimal flux by $v^{(1)}$.\n2. Add the equality constraint $c_{\\text{bio}}^\\top v = z_1$, and solve the LP to maximize $c_{\\text{prod}}^\\top v$ subject to $S v = 0$, bounds, and the added equality. Denote the optimal product value by $z_2$ and one corresponding optimal flux by $v^{(2)}$.\n3. Add the equality constraints $c_{\\text{bio}}^\\top v = z_1$ and $c_{\\text{prod}}^\\top v = z_2$, and solve the LP to minimize $\\sum_{i=1}^n |v_i|$ subject to $S v = 0$, bounds, and the two equalities. Formulate this as a linear program by introducing auxiliary variables $s_i \\ge 0$ with constraints $v_i - s_i \\le 0$ and $-v_i - s_i \\le 0$, and minimize $\\sum_i s_i$. Denote the resulting parsimonious flux as $v^\\star$, and its $\\ell_1$ norm as $\\|v^\\star\\|_1 = \\sum_i |v^\\star_i|$.\n\nTest Suite. For coverage, solve four test cases by varying a subset of bounds. In all cases, unless specified otherwise, reaction bounds are:\n- $0 \\le v_{R2} \\le 1000$, $0 \\le v_{BM} \\le 1000$, $0 \\le v_{PR} \\le 1000$, $0 \\le v_{Y2Z} \\le 1000$, $0 \\le v_{Z2Y} \\le 1000$.\nCase-specific bounds:\n- Case 1 (happy path, biomass dominates): $0 \\le v_U \\le 10$, $2 \\le v_M \\le 1000$, $0 \\le v_{BM} \\le 1000$, $0 \\le v_{PR} \\le 1000$.\n- Case 2 (biomass capped; product fills remaining capacity): $0 \\le v_U \\le 12$, $2 \\le v_M \\le 1000$, $0 \\le v_{BM} \\le 8$, $0 \\le v_{PR} \\le 1000$.\n- Case 3 (product blocked): $0 \\le v_U \\le 12$, $2 \\le v_M \\le 1000$, $0 \\le v_{BM} \\le 1000$, $0 \\le v_{PR} \\le 0$.\n- Case 4 (no uptake, no maintenance): $0 \\le v_U \\le 0$, $0 \\le v_M \\le 1000$, $0 \\le v_{BM} \\le 1000$, $0 \\le v_{PR} \\le 1000$.\n\nRequired final output format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each inner list corresponds to one test case and contains the final parsimonious flux vector $v^\\star$ ordered as $(v_U, v_{R2}, v_{BM}, v_{PR}, v_M, v_{Y2Z}, v_{Z2Y})$. Express fluxes in $\\text{mmol}\\,\\text{gDW}^{-1}\\,\\text{h}^{-1}$ and round each entry to six decimal places. For example: \"[[vU,vR2,vBM,vPR,vM,vY2Z,vZ2Y],[...],...]\". All numerical answers are floats.",
            "solution": "The user has specified a computational problem in the domain of systems biology, specifically Flux Balance Analysis (FBA). The task is to determine the optimal metabolic flux distribution for a given toy network under several conditions using a lexicographic multi-objective optimization approach. The solution requires a sequence of three linear programs (LPs) to be solved for each condition.\n\nThe problem is first validated for scientific soundness, completeness, and clarity.\n- **Scientific Grounding**: The problem is based on Flux Balance Analysis, a standard, well-established method in computational systems biology. The core equation $S v = 0$ represents the law of mass conservation at steady state. The use of linear programming to optimize a biological objective (e.g., biomass production) is the fundamental technique of FBA. The lexicographic optimization and the final parsimony step (minimization of $\\ell_1$ norm of fluxes) are common and valid extensions to handle multiple objectives and find biologically realistic, efficient solutions. The toy network, while simple, consists of plausible reaction types. Thus, the problem is scientifically grounded.\n- **Well-Posedness**: The problem is formulated as a series of linear programming tasks. Given a non-empty, bounded feasible region (a polytope defined by mass balance and flux bounds), an LP is guaranteed to have a solution. The necessary components—the stoichiometric matrix $S$, objective vectors $c_{\\text{bio}}$ and $c_{\\text{prod}}$, and reaction bounds for four distinct test cases—are all explicitly provided. The sequence of optimization steps is clearly defined. The problem is self-contained, unambiguous, and well-posed.\n- **Objectivity**: The problem is stated in precise mathematical and scientific language, free of subjective claims or bias.\n\nThe problem is deemed valid and a solution can be constructed.\n\nThe solution is implemented by applying a three-stage lexicographic optimization procedure for each of the four test cases defined by different reaction bounds.\n\n**Stage 1: Maximize Biomass Production**\nThe primary objective is to maximize the flux through the biomass reaction, $v_{BM}$. This is formulated as the following linear program:\n$$\n\\begin{array}{ll}\n\\text{maximize} & z_1 = c_{\\text{bio}}^\\top v \\\\\n\\text{subject to} & S v = 0 \\\\\n& L \\le v \\le U\n\\end{array}\n$$\nwhere $v \\in \\mathbb{R}^n$ is the vector of reaction fluxes, $S \\in \\mathbb{R}^{m \\times n}$ is the stoichiometric matrix, $c_{\\text{bio}} = (0,0,1,0,0,0,0)^\\top$ is the objective vector for biomass, and $L$ and $U$ are vectors of lower and upper bounds on the fluxes, respectively. The specific bounds are defined for each test case. This LP is solved to find the maximum possible biomass production rate, $z_1$.\n\n**Stage 2: Maximize Product Secretion**\nThe second objective is to maximize the flux through the product secretion reaction, $v_{PR}$, under the condition that the biomass production rate is maintained at its optimum, $z_1$. This is a new LP that inherits all constraints from Stage 1, with one additional equality constraint:\n$$\n\\begin{array}{ll}\n\\text{maximize} & z_2 = c_{\\text{prod}}^\\top v \\\\\n\\text{subject to} & S v = 0 \\\\\n& c_{\\text{bio}}^\\top v = z_1 \\\\\n& L \\le v \\le U\n\\end{array}\n$$\nwhere $c_{\\text{prod}} = (0,0,0,1,0,0,0)^\\top$ is the objective vector for the product. This LP finds the maximum product secretion rate, $z_2$, achievable without compromising maximal biomass production.\n\n**Stage 3: Minimize Total Flux (Parsimonious FBA)**\nThe solution space may still allow for multiple flux distributions that satisfy the optimal values $z_1$ and $z_2$. A common approach to select a single, biologically meaningful solution is to find the one that minimizes the total metabolic effort, approximated by the sum of the magnitudes of all fluxes (the $\\ell_1$ norm of $v$). This is known as parsimonious FBA (pFBA). The objective is to minimize $\\sum_{i=1}^n |v_i|$. This non-linear objective can be converted into a linear one by introducing auxiliary variables $s_i \\ge 0$ for each flux $v_i$, where $s_i \\ge |v_i|$. This is enforced by two linear inequalities: $v_i \\le s_i$ and $-v_i \\le s_i$. The final LP is:\n$$\n\\begin{array}{ll}\n\\text{minimize} & \\sum_{i=1}^n s_i \\\\\n\\text{subject to} & S v = 0 \\\\\n& c_{\\text{bio}}^\\top v = z_1 \\\\\n& c_{\\text{prod}}^\\top v = z_2 \\\\\n& v - s \\le 0 \\\\\n& -v - s \\le 0 \\\\\n& L \\le v \\le U \\\\\n& s \\ge 0\n\\end{array}\n$$\nThe optimization variable for this LP is the augmented vector $(v^\\top, s^\\top)^\\top \\in \\mathbb{R}^{2n}$. The resulting flux vector $v^\\star$ from this final stage is the unique, parsimonious solution that maximizes biomass, then product, then minimizes total flux magnitude. This procedure is systematically applied to obtain the solution for each of the four provided test cases. The implementation utilizes the `scipy.optimize.linprog` function to solve each LP.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the Flux Balance Analysis for all test cases.\n    \"\"\"\n    \n    # Stoichiometric matrix S for metabolites {X, Y, Z} and reactions {U, R2, BM, PR, M, Y2Z, Z2Y}\n    S = np.array([\n        [1, -1, 0, 0, -1, 0, 0],   # Metabolite X\n        [0, 1, -1, -1, 0, -1, 1],   # Metabolite Y\n        [0, 0, 0, 0, 0, 1, -1]    # Metabolite Z\n    ])\n    \n    m, n = S.shape\n\n    # General bounds for reactions unless specified otherwise in a test case.\n    # U, R2, BM, PR, M, Y2Z, Z2Y\n    general_bounds = {\n        'R2': (0, 1000), 'BM': (0, 1000), 'PR': (0, 1000),\n        'Y2Z': (0, 1000), 'Z2Y': (0, 1000)\n    }\n\n    # Define the four test cases by their specific bounds\n    test_cases = [\n        # Case 1: Happy path, biomass dominates\n        {**general_bounds, 'U': (0, 10), 'M': (2, 1000)},\n        # Case 2: Biomass capped; product fills remaining capacity\n        {**general_bounds, 'U': (0, 12), 'M': (2, 1000), 'BM': (0, 8)},\n        # Case 3: Product blocked\n        {**general_bounds, 'U': (0, 12), 'M': (2, 1000), 'PR': (0, 0)},\n        # Case 4: No uptake, no maintenance\n        {**general_bounds, 'U': (0, 0), 'M': (0, 1000)}\n    ]\n    \n    # Order of reactions for constructing the bounds list\n    reaction_order = ['U', 'R2', 'BM', 'PR', 'M', 'Y2Z', 'Z2Y']\n\n    results = []\n    for case_bounds_dict in test_cases:\n        bounds = [case_bounds_dict[reac] for reac in reaction_order]\n        v_star = solve_fba_case(S, bounds, n, m)\n        # Round to six decimal places and format for output\n        rounded_v = [f\"{val:.6f}\" for val in v_star]\n        results.append(f\"[{','.join(rounded_v)}]\")\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef solve_fba_case(S, bounds, n, m):\n    \"\"\"\n    Solves the 3-stage lexicographic FBA for a given set of bounds.\n    \"\"\"\n    b_eq = np.zeros(m)\n    c_bio_max = np.array([0, 0, -1, 0, 0, 0, 0]) # maximize v_BM\n    c_prod_max = np.array([0, 0, 0, -1, 0, 0, 0]) # maximize v_PR\n\n    # Stage 1: Maximize biomass\n    res1 = linprog(c=c_bio_max, A_eq=S, b_eq=b_eq, bounds=bounds, method='highs')\n    if not res1.success:\n        # If infeasible (e.g., negative growth), optimal is 0\n        z1 = 0.0\n    else:\n        z1 = -res1.fun # LP minimizes, so we negate to get the maximum\n\n    # Stage 2: Maximize product, fixing biomass\n    c_bio_objective_row = np.array([0, 0, 1, 0, 0, 0, 0])\n    A_eq2 = np.vstack([S, c_bio_objective_row])\n    b_eq2 = np.hstack([b_eq, z1])\n    \n    res2 = linprog(c=c_prod_max, A_eq=A_eq2, b_eq=b_eq2, bounds=bounds, method='highs')\n    if not res2.success:\n        z2 = 0.0\n    else:\n        z2 = -res2.fun\n        \n    # Stage 3: Minimize L1 norm of fluxes (parsimonious FBA)\n    # Variables: [v_1, ..., v_n, s_1, ..., s_n]\n    c3 = np.hstack([np.zeros(n), np.ones(n)])\n    \n    # Equality constraints: Sv=0, c_bio^T v = z1, c_prod^T v = z2\n    c_prod_objective_row = np.array([0, 0, 0, 1, 0, 0, 0])\n    A_eq3_template = np.vstack([S, c_bio_objective_row, c_prod_objective_row])\n    A_eq3 = np.hstack([A_eq3_template, np.zeros((m + 2, n))])\n    b_eq3 = np.hstack([b_eq, z1, z2])\n    \n    # Inequality constraints for L1 norm: v-s <= 0, -v-s <= 0\n    I_n = np.identity(n)\n    A_ub3 = np.vstack([\n        np.hstack([I_n, -I_n]),\n        np.hstack([-I_n, -I_n])\n    ])\n    b_ub3 = np.zeros(2 * n)\n    \n    # Bounds for augmented variables\n    bounds3 = bounds + [(0, None) for _ in range(n)]\n\n    res3 = linprog(c=c3, A_ub=A_ub3, b_ub=b_ub3, A_eq=A_eq3, b_eq=b_eq3, bounds=bounds3, method='highs')\n\n    if not res3.success:\n        # In case of numerical issues or if no solution exists, return zeros.\n        # This shouldn't happen with the given valid problem setup.\n        return np.zeros(n)\n        \n    v_star = res3.x[:n]\n    # Clean up small numerical errors close to zero\n    v_star[np.isclose(v_star, 0)] = 0\n    \n    return v_star\n\nsolve()\n```"
        },
        {
            "introduction": "An optimal flux distribution from FBA represents a single snapshot of cellular metabolism under specific conditions. To understand the model's predictive power more deeply, we must probe how this optimal state responds to environmental changes. This practice leverages the dual solution of the linear program, using shadow prices to perform sensitivity analysis. You will learn to predict how the maximum biomass yield changes in response to variations in nutrient uptake limits, providing a powerful, computationally efficient method to explore the landscape of metabolic capabilities without repeatedly re-solving the entire optimization problem .",
            "id": "3309004",
            "problem": "Consider a Flux Balance Analysis (FBA) problem posed as Linear Programming (LP) at steady state. The fundamental base is the steady-state mass balance condition expressed by the stoichiometric matrix $S$ and flux vector $v$, namely $S v = 0$, together with physically meaningful lower and upper bounds $l \\le v \\le u$ on each reaction flux, and a linear objective function that represents the biomass production to be maximized. The LP is thus: maximize $c^{\\top} v$ subject to $S v = 0$ and $l \\le v \\le u$. Shadow prices (dual variables) associated with constraints quantify the local sensitivity of the optimal value to right-hand-side perturbations.\n\nConstruct a minimal, scientifically sound FBA-like model with four flux variables $v = [v_{\\mathrm{ex}}, v_{\\mathrm{tr}}, v_{\\mathrm{bio}}, v_{\\mathrm{by}}]^{\\top}$ representing, respectively, an exchange flux with the environment ($v_{\\mathrm{ex}}$), an import/transport flux from the environment into the internal compartment ($v_{\\mathrm{tr}}$), a biomass production flux ($v_{\\mathrm{bio}}$), and a byproduct secretion flux ($v_{\\mathrm{by}}$). Enforce steady-state constraints for the external and internal pools as equalities:\n- External pool conservation: $v_{\\mathrm{ex}} + v_{\\mathrm{tr}} = 0$.\n- Internal glucose balance: $v_{\\mathrm{tr}} - v_{\\mathrm{bio}} - v_{\\mathrm{by}} = 0$.\n\nSet bounds to encode the biophysical meanings:\n- Exchange flux bound representing uptake capacity: $l_i \\le v_{\\mathrm{ex}} \\le 0$, where $l_i \\le 0$ (negative values denote allowed uptake magnitude).\n- Transport flux nonnegativity and optional capacity cap: $0 \\le v_{\\mathrm{tr}} \\le U_{\\mathrm{tr}}$.\n- Biomass flux nonnegativity and optional capacity cap: $0 \\le v_{\\mathrm{bio}} \\le U_{\\mathrm{bio}}$.\n- Byproduct flux nonnegativity with a large upper bound: $0 \\le v_{\\mathrm{by}} \\le U_{\\mathrm{by}}$.\n\nLet the objective be to maximize biomass, i.e., $c = [0, 0, 1, 0]^{\\top}$ so the objective is $c^{\\top} v = v_{\\mathrm{bio}}$. Under these constraints, the LP has a well-defined optimum whenever the bounds are consistent, and the shadow price (dual variable) corresponding to the lower bound of $v_{\\mathrm{ex}}$ determines the local right-hand-side sensitivity of the optimal value to perturbations of $l_i$.\n\nYour task is to implement a complete program that, for each test case in the test suite below, performs the following steps:\n1. Solve the primal LP once to obtain the optimal objective value $z^{\\star}$ and the dual information for the bound constraints.\n2. Compute the correct right-hand-side derivative of the optimal value with respect to the parameter $l_i$ using the dual solution associated with the lower bound of $v_{\\mathrm{ex}}$. Be precise about sign conventions: the LP solver minimizes; you must correctly relate the minimization duals to the original maximization objective to form the predicted change in $z^{\\star}$ for a perturbation $\\Delta l_i$.\n3. Predict the change in the optimal objective value for the specified perturbation $\\Delta l_i$ using the sensitivity derivative you computed.\n4. Re-solve the primal LP with the perturbed lower bound $l_i + \\Delta l_i$ to obtain the new optimal value $\\tilde{z}^{\\star}$ and compute the actual change $\\tilde{z}^{\\star} - z^{\\star}$.\n5. Return, for each test case, the absolute difference between the predicted change and the actual change as a floating-point number.\n\nUse the following fixed stoichiometry, bounds (with $U_{\\mathrm{by}}$ chosen sufficiently large, e.g., $U_{\\mathrm{by}} = 10^{6}$), and objective:\n- Equality constraints matrix $A_{\\mathrm{eq}}$ and right-hand side $b_{\\mathrm{eq}}$:\n  $$A_{\\mathrm{eq}} =\n  \\begin{bmatrix}\n  1 & 1 & 0 & 0 \\\\\n  0 & 1 & -1 & -1\n  \\endbmatrix}, \\quad\n  b_{\\mathrm{eq}} =\n  \\begin{bmatrix}\n  0 \\\\\n  0\n  \\end{bmatrix}.$$\n- Objective vector for minimization is $-c$:\n  $$c_{\\mathrm{min}} = \\begin{bmatrix} 0 \\\\ 0 \\\\ -1 \\\\ 0 \\end{bmatrix}.$$\n\nTest suite of parameter values $(l_i, \\Delta l_i, U_{\\mathrm{tr}}, U_{\\mathrm{bio}})$ to be used:\n- Case $1$ (happy path, binding lower bound): $l_i = -10.0$, $\\Delta l_i = 0.5$, $U_{\\mathrm{tr}} = +\\infty$, $U_{\\mathrm{bio}} = +\\infty$.\n- Case $2$ (happy path with negative perturbation): $l_i = -10.0$, $\\Delta l_i = -1.2$, $U_{\\mathrm{tr}} = +\\infty$, $U_{\\mathrm{bio}} = +\\infty$.\n- Case $3$ (boundary at zero uptake): $l_i = 0.0$, $\\Delta l_i = -2.0$, $U_{\\mathrm{tr}} = +\\infty$, $U_{\\mathrm{bio}} = +\\infty$.\n- Case $4$ (non-binding lower bound due to transport capacity): $l_i = -10.0$, $\\Delta l_i = 1.0$, $U_{\\mathrm{tr}} = 5.0$, $U_{\\mathrm{bio}} = +\\infty$.\n- Case $5$ (non-binding lower bound due to biomass cap): $l_i = -10.0$, $\\Delta l_i = -3.0$, $U_{\\mathrm{tr}} = +\\infty$, $U_{\\mathrm{bio}} = 4.0$.\n\nScientific realism and self-consistency are ensured as follows: the external pool equality $v_{\\mathrm{ex}} + v_{\\mathrm{tr}} = 0$ enforces that internal transport equals net uptake from the environment, the internal balance enforces that intake is split between growth and byproduct, and bounds encode uptake capacity ($l_i$), transport capacity ($U_{\\mathrm{tr}}$), and growth capacity ($U_{\\mathrm{bio}}$). The resulting LP is feasible whenever $l_i \\le 0$ and $U_{\\mathrm{tr}}$, $U_{\\mathrm{bio}}$ are nonnegative.\n\nFinal output format requirement: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each floating-point number rounded to six decimal places. For example: \"[$x_1$,$x_2$,$x_3$,$x_4$,$x_5$]\" where each $x_k$ is the absolute difference for case $k$.\n\nNo physical units or angle units apply here; all quantities are dimensionless rates and bounds. The final outputs must be floating-point numbers.",
            "solution": "The problem requires the implementation of a Flux Balance Analysis (FBA) model and the use of sensitivity analysis based on Linear Programming (LP) duality. We are asked to compare the predicted change in the optimal biomass production, derived from shadow prices, with the actual change computed by re-solving the LP with a perturbed parameter.\n\nThe FBA model is defined by a set of linear equality and inequality constraints on a vector of reaction fluxes $v = [v_{\\mathrm{ex}}, v_{\\mathrm{tr}}, v_{\\mathrm{bio}}, v_{\\mathrm{by}}]^{\\top}$. The objective is to maximize the biomass flux, $v_{\\mathrm{bio}}$.\n\nThe problem can be formulated as a standard LP problem. The objective is to maximize $z = c^{\\top}v$, where $c = [0, 0, 1, 0]^{\\top}$. The constraints are:\n$1$. Equality constraints: $A_{\\mathrm{eq}}v = b_{\\mathrm{eq}}$, where\n$$A_{\\mathrm{eq}} = \\begin{bmatrix} 1 & 1 & 0 & 0 \\\\ 0 & 1 & -1 & -1 \\end{bmatrix}, \\quad b_{\\mathrm{eq}} = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}$$\nThese equations enforce steady-state mass balance for the external pool and the internal metabolite, respectively.\n\n$2$. Bound constraints: $l \\le v \\le u$. For a given test case with parameters $(l_i, \\Delta l_i, U_{\\mathrm{tr}}, U_{\\mathrm{bio}})$, these bounds are:\n- $l_i \\le v_{\\mathrm{ex}} \\le 0$\n- $0 \\le v_{\\mathrm{tr}} \\le U_{\\mathrm{tr}}$\n- $0 \\le v_{\\mathrm{bio}} \\le U_{\\mathrm{bio}}$\n- $0 \\le v_{\\mathrm{by}} \\le U_{\\mathrm{by}}$, where $U_{\\mathrm{by}}$ is a large constant, given as $10^6$.\n\nSince standard LP solvers, including `scipy.optimize.linprog`, are typically formulated as minimization problems, we convert our maximization problem into an equivalent minimization problem. Maximizing $z = c^{\\top}v$ is equivalent to minimizing $z_{\\mathrm{min}} = -z = -c^{\\top}v$. The objective vector for the minimization problem is thus $c_{\\mathrm{min}} = -c = [0, 0, -1, 0]^{\\top}$.\n\nThe core of the task is sensitivity analysis. In LP, the dual variables (or shadow prices) provide information on how the optimal objective value changes with respect to small perturbations in the right-hand-side (RHS) of the constraints. Let $z_{\\mathrm{min}}^{\\star}(b_k)$ be the optimal value of the minimization problem as a function of the RHS of the $k$-th constraint. The sensitivity theorem states that the dual variable $\\lambda_k$ associated with the $k$-th constraint is equal to the partial derivative of the optimal objective value with respect to $b_k$:\n$$\\lambda_k = \\frac{\\partial z_{\\mathrm{min}}^{\\star}}{\\partial b_k}$$\n\nWe are interested in the sensitivity with respect to the lower bound of the exchange flux, $v_{\\mathrm{ex}} \\ge l_i$. This is one of the bound constraints provided to the solver. Let's write this constraint in a standard \"$\\le$\" form: $-v_{\\mathrm{ex}} \\le -l_i$. The RHS of this constraint is $-l_i$. However, modern solvers like `scipy.optimize.linprog` handle bound constraints $v_j \\ge l_j$ directly. The associated dual variable, which we can call $\\lambda_{l, j}$, represents the sensitivity of the objective with respect to the bound value itself:\n$$\\lambda_{l, j} = \\frac{\\partial z_{\\mathrm{min}}^{\\star}}{\\partial l_j}$$\nThe `scipy.optimize.linprog` function, when using the `highs` method, returns these duals in the `lower.marginals` attribute of its result object.\n\nThe problem asks for the sensitivity of the original maximization objective, $z^{\\star}$, with respect to $l_i$. Since $z^{\\star} = -z_{\\mathrm{min}}^{\\star}$, we can use the chain rule:\n$$\\frac{\\partial z^{\\star}}{\\partial l_i} = \\frac{\\partial (-z_{\\mathrm{min}}^{\\star})}{\\partial l_i} = -\\frac{\\partial z_{\\mathrm{min}}^{\\star}}{\\partial l_i}$$\nFor the exchange flux $v_{\\mathrm{ex}}$ (which is the first variable, $j=1$), the sensitivity is:\n$$\\frac{\\partial z^{\\star}}{\\partial l_i} = -\\lambda_{l, 1}$$\nwhere $\\lambda_{l,1}$ is the dual variable for the lower bound on $v_{\\mathrm{ex}}$ returned by the minimization solver.\n\nUsing this derivative, we can predict the change in the optimal objective value, $\\Delta z_{\\text{pred}}$, for a small perturbation $\\Delta l_i$ using a first-order Taylor approximation:\n$$\\Delta z_{\\text{pred}} = z^{\\star}(l_i + \\Delta l_i) - z^{\\star}(l_i) \\approx \\frac{\\partial z^{\\star}}{\\partial l_i} \\cdot \\Delta l_i = (-\\lambda_{l, 1}) \\cdot \\Delta l_i$$\nThis prediction is accurate as long as the perturbation $\\Delta l_i$ is small enough not to cause a change in the set of active constraints at the optimum (i.e., no basis change occurs).\n\nThe overall algorithm for each test case is as follows:\n$1$. **Initial Solution**: Formulate and solve the initial LP for the given parameters $(l_i, U_{\\mathrm{tr}}, U_{\\mathrm{bio}})$. The `scipy.optimize.linprog` function is used with $c_{\\mathrm{min}}$, $A_{\\mathrm{eq}}$, $b_{\\mathrm{eq}}$, and the specified bounds. From the result, we obtain the optimal objective value of the minimization, $z_{\\mathrm{min}}^{\\star}$, and the dual variable for the lower bound of $v_{\\mathrm{ex}}$, $\\lambda_{l,1} = \\text{result.lower.marginals}[0]$. The optimal value for the maximization problem is $z^{\\star} = -z_{\\mathrm{min}}^{\\star}$.\n\n$2$. **Prediction**: Calculate the predicted change $\\Delta z_{\\text{pred}}$ using the sensitivity formula: $\\Delta z_{\\text{pred}} = (-\\lambda_{l, 1}) \\cdot \\Delta l_i$.\n\n$3$. **Perturbed Solution**: Modify the lower bound of $v_{\\mathrmex}$ to $l_i' = l_i + \\Delta l_i$. Re-solve the LP with this new bound to find the new optimal objective value, $\\tilde{z}_{\\mathrm{min}}^{\\star}$. The new value for the maximization problem is $\\tilde{z}^{\\star} = -\\tilde{z}_{\\mathrm{min}}^{\\star}$.\n\n$4$. **Actual Change**: Compute the actual change in the objective value: $\\Delta z_{\\text{actual}} = \\tilde{z}^{\\star} - z^{\\star}$.\n\n$5$. **Comparison**: Calculate the absolute difference between the predicted and actual change: $|\\Delta z_{\\text{pred}} - \\Delta z_{\\text{actual}}|$. This value quantifies the accuracy of the linear sensitivity analysis for the given perturbation.\n\nThis procedure will be systematically applied to each of the five test cases provided. The numerical implementation must handle infinite bounds by passing `None` or `numpy.inf` to the solver, as appropriate.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef run_fba_sensitivity_case(params):\n    \"\"\"\n    Solves one FBA sensitivity analysis case.\n    \n    Args:\n        params (tuple): A tuple containing (l_i, delta_l_i, U_tr, U_bio).\n\n    Returns:\n        float: The absolute difference between predicted and actual change\n               in the optimal objective value.\n    \"\"\"\n    l_i, delta_l_i, U_tr, U_bio = params\n    \n    # Define the constant components of the LP problem\n    # Objective for minimization (scipy.optimize.linprog minimizes)\n    c_min = np.array([0, 0, -1, 0])\n    \n    # Equality constraints: A_eq * v = b_eq\n    A_eq = np.array([\n        [1, 1, 0, 0],  # External pool: v_ex + v_tr = 0\n        [0, 1, -1, -1]  # Internal balance: v_tr - v_bio - v_by = 0\n    ])\n    b_eq = np.array([0, 0])\n    \n    # Define a large upper bound for the byproduct flux\n    U_by = 1e6\n\n    # Scipy's linprog uses None for infinite bounds\n    U_tr_scipy = U_tr if np.isfinite(U_tr) else None\n    U_bio_scipy = U_bio if np.isfinite(U_bio) else None\n\n    # 1. Solve the primal LP to get the initial optimal value and duals\n    bounds_initial = [\n        (l_i, 0),             # l_i <= v_ex <= 0\n        (0, U_tr_scipy),      # 0 <= v_tr <= U_tr\n        (0, U_bio_scipy),     # 0 <= v_bio <= U_bio\n        (0, U_by)             # 0 <= v_by <= U_by\n    ]\n    \n    res_initial = linprog(\n        c=c_min, A_eq=A_eq, b_eq=b_eq, bounds=bounds_initial, method='highs'\n    )\n\n    if not res_initial.success:\n        return np.nan\n\n    # The objective is to maximize v_bio, so z_star = -z_min\n    z_star = -res_initial.fun\n    \n    # 2. Compute the derivative from the dual solution\n    # The dual for the lower bound v_ex >= l_i is given by `lower.marginals[0]`.\n    # This marginal is d(z_min)/d(l_i).\n    # The sensitivity for the maximization problem is d(z_max)/d(l_i) = -d(z_min)/d(l_i).\n    lambda_l_ex = res_initial.lower.marginals[0]\n    sensitivity = -lambda_l_ex\n\n    # 3. Predict the change in the optimal objective value\n    predicted_change = sensitivity * delta_l_i\n    \n    # 4. Re-solve the primal LP with the perturbed lower bound\n    l_i_perturbed = l_i + delta_l_i\n    bounds_perturbed = [\n        (l_i_perturbed, 0),\n        (0, U_tr_scipy),\n        (0, U_bio_scipy),\n        (0, U_by)\n    ]\n    \n    res_perturbed = linprog(\n        c=c_min, A_eq=A_eq, b_eq=b_eq, bounds=bounds_perturbed, method='highs'\n    )\n\n    if not res_perturbed.success:\n        return np.nan\n\n    # Get the new optimal value\n    z_star_perturbed = -res_perturbed.fun\n    \n    # 5. Compute the actual change\n    actual_change = z_star_perturbed - z_star\n    \n    # 6. Return the absolute difference between predicted and actual change\n    return abs(predicted_change - actual_change)\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    # Test suite: (l_i, delta_l_i, U_tr, U_bio)\n    test_cases = [\n        (-10.0, 0.5, np.inf, np.inf),    # Case 1\n        (-10.0, -1.2, np.inf, np.inf),   # Case 2\n        (0.0, -2.0, np.inf, np.inf),    # Case 3\n        (-10.0, 1.0, 5.0, np.inf),      # Case 4\n        (-10.0, -3.0, np.inf, 4.0),     # Case 5\n    ]\n\n    results = []\n    for case in test_cases:\n        diff = run_fba_sensitivity_case(case)\n        results.append(f\"{diff:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```"
        }
    ]
}