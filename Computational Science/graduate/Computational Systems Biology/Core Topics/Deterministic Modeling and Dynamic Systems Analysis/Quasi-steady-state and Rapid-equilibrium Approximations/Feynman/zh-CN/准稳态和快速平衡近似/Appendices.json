{
    "hands_on_practices": [
        {
            "introduction": "掌握任何近似方法的第一步都是从第一性原理出发进行推导。本练习将指导你从基本反应机理出发，分别在准稳态近似（QSSA）和快速平衡近似（REA）的假设下推导米氏方程。最终，你将量化使用更简单的REA所引入的精确数学误差，从而揭示这两种近似方法趋于一致的确切条件。",
            "id": "3342035",
            "problem": "考虑一个由基元质量作用动力学控制的单底物酶促反应机理，\n$$\nE + S \\xrightleftharpoons[k_{-1}]{k_{1}} ES \\xrightarrow{k_{2}} E + P,\n$$\n其中总酶浓度守恒 $$E_{\\mathrm{T}} = [E] + [ES],$$ 反应速率定义为 $$v(t) = \\frac{d[P]}{dt} = k_{2}\\,[ES](t)。$$ 令准稳态近似（QSSA）表示复合物浓度满足 $$\\frac{d[ES]}{dt} \\approx 0,$$ 的体系，并令快速平衡近似（REA）表示结合和解离步骤的平衡速度远快于产物生成速度的体系，因此 $$k_{1}\\,[E]\\,[S] \\approx k_{-1}\\,[ES]。$$ 定义米氏常数 $$K_{M} \\equiv \\frac{k_{-1} + k_{2}}{k_{1}}$$ 和解离常数 $$K_{d} \\equiv \\frac{k_{-1}}{k_{1}}。$$\n\n从上述质量作用微分方程和定义出发，完成以下任务：\n- 在不使用任何预先推导的快捷公式的情况下，推导稳态反应速率 $v$ 关于 $E_{\\mathrm{T}}$、$S$、$k_{1}$、$k_{-1}$ 和 $k_{2}$ 的QSSA表达式。\n- 使用REA，明确证明当 $k_{2} \\ll k_{-1}$ 时，有 $K_{M} \\approx K_{d}$，并得到相应的 $v$ 关于 $E_{\\mathrm{T}}$、$S$ 和 $K_{d}$ 的REA表达式。\n- 对于有限的 $k_{2}$（不一定满足 $k_{2} \\ll k_{-1}$），通过定义相对误差\n$$\n\\delta(S) \\equiv \\frac{v_{\\mathrm{REA}}(S)}{v_{\\mathrm{QSSA}}(S)} - 1,\n$$\n来量化当用 $K_{d}$ 代替 $K_{M}$ 时速率产生的误差，并推导 $\\delta(S)$ 关于 $K_{d}$、$k_{2}$、$k_{-1}$ 和 $S$ 的闭式解析表达式。\n\n最后，确定在所有底物浓度 $S \\ge 0$ 的范围内 $\\delta(S)$ 的上确界，并将此上确界表示为关于 $k_{2}$ 和 $k_{-1}$ 的单个闭式解析表达式。仅报告此上确界作为您的最终答案。无需进行数值取整。",
            "solution": "该问题陈述被评估为有效。它在科学上基于化学动力学和酶促反应机理的原理，特别是米氏-门顿模型。该问题是适定的，提供了一套完整且一致的定义和约束（`E + S \\xrightleftharpoons[k_{-1}]{k_{1}} ES \\xrightarrow{k_{2}} E + P`、总酶守恒以及对QSSA、REA、$K_{M}$、$K_{d}$ 和 $\\delta(S)$ 的定义）。语言客观而精确，任务是可形式化的数学推导。该问题没有任何使其无效的缺陷。我们开始进行解答。\n\n基元反应体系由下式给出\n$$ E + S \\xrightleftharpoons[k_{-1}]{k_{1}} ES \\xrightarrow{k_{2}} E + P $$\n酶-底物复合物浓度 $[ES]$ 的变化率由质量作用常微分方程描述：\n$$ \\frac{d[ES]}{dt} = k_{1}\\,[E]\\,[S] - k_{-1}\\,[ES] - k_{2}\\,[ES] = k_{1}\\,[E]\\,[S] - (k_{-1} + k_{2})\\,[ES] $$\n我们还知道总酶浓度是守恒的：\n$$ E_{\\mathrm{T}} = [E] + [ES] $$\n这意味着游离酶浓度为 $[E] = E_{\\mathrm{T}} - [ES]$。\n\n**准稳态近似（QSSA）速率的推导**\n\n准稳态近似（QSSA）假设中间复合物 $[ES]$ 的浓度变化远慢于底物 $[S]$ 和产物 $[P]$ 的浓度变化。这在数学上表述为 $\\frac{d[ES]}{dt} \\approx 0$。将此近似应用于 $[ES]$ 的速率方程：\n$$ k_{1}\\,[E]\\,[S] - (k_{-1} + k_{2})\\,[ES] \\approx 0 $$\n$$ k_{1}\\,[E]\\,[S] \\approx (k_{-1} + k_{2})\\,[ES] $$\n现在，我们将游离酶浓度的表达式 $[E] = E_{\\mathrm{T}} - [ES]$ 代入QSSA方程：\n$$ k_{1}\\,(E_{\\mathrm{T}} - [ES])\\,[S] = (k_{-1} + k_{2})\\,[ES] $$\n我们的目标是求解 $[ES]$，用通常已知的 $E_{\\mathrm{T}}$ 和 $[S]$ 来表示。我们展开左侧：\n$$ k_{1}\\,E_{\\mathrm{T}}\\,[S] - k_{1}\\,[ES]\\,[S] = (k_{-1} + k_{2})\\,[ES] $$\n将所有包含 $[ES]$ 的项组合在一起：\n$$ k_{1}\\,E_{\\mathrm{T}}\\,[S] = (k_{-1} + k_{2})\\,[ES] + k_{1}\\,[ES]\\,[S] $$\n$$ k_{1}\\,E_{\\mathrm{T}}\\,[S] = [ES]\\,(k_{-1} + k_{2} + k_{1}\\,[S]) $$\n求解 $[ES]$：\n$$ [ES] = \\frac{k_{1}\\,E_{\\mathrm{T}}\\,[S]}{k_{-1} + k_{2} + k_{1}\\,[S]} $$\n反应速率 $v$ 定义为产物生成速率，$v = \\frac{d[P]}{dt} = k_{2}\\,[ES]$。代入 $[ES]$ 的QSSA表达式，得到QSSA速率，我们记为 $v_{\\mathrm{QSSA}}$：\n$$ v_{\\mathrm{QSSA}}(S) = k_{2} \\left( \\frac{k_{1}\\,E_{\\mathrm{T}}\\,[S]}{k_{-1} + k_{2} + k_{1}\\,[S]} \\right) = \\frac{k_{1}\\,k_{2}\\,E_{\\mathrm{T}}\\,[S]}{k_{1}\\,[S] + k_{-1} + k_{2}} $$\n这就是在QSSA下，稳态反应速率关于 $E_{\\mathrm{T}}$、$S$、$k_{1}$、$k_{-1}$ 和 $k_{2}$ 的表达式。使用所给的米氏常数定义 $K_{M} \\equiv \\frac{k_{-1} + k_{2}}{k_{1}}$，通过将分子和分母同除以 $k_{1}$，可以将其写成更熟悉的米氏-门顿形式：\n$$ v_{\\mathrm{QSSA}}(S) = \\frac{k_{2}\\,E_{\\mathrm{T}}\\,[S]}{[S] + \\frac{k_{-1} + k_{2}}{k_{1}}} = \\frac{k_{2}\\,E_{\\mathrm{T}}\\,[S]}{K_{M} + [S]} $$\n\n**快速平衡近似（REA）的分析**\n\n当催化步骤远慢于结合/解离步骤时，即 $k_{2} \\ll k_{-1}$，快速平衡近似（REA）是有效的。在此极限下，第一个反应 $E + S \\xrightleftharpoons[k_{-1}]{k_{1}} ES$ 被假定处于平衡状态。\n\n首先，我们证明当 $k_{2} \\ll k_{-1}$ 时，$K_{M} \\approx K_{d}$。定义如下：\n$$ K_{M} = \\frac{k_{-1} + k_{2}}{k_{1}} \\quad \\text{和} \\quad K_{d} = \\frac{k_{-1}}{k_{1}} $$\n如果 $k_{2} \\ll k_{-1}$，那么 $k_{-1} + k_{2}$ 这一项可以近似为 $k_{-1}$。因此：\n$$ K_{M} = \\frac{k_{-1} + k_{2}}{k_{1}} \\approx \\frac{k_{-1}}{k_{1}} = K_{d} $$\n这证实了在指定条件下的关系。\n\n接下来，我们推导速率的REA表达式。REA表明正向和反向结合反应处于平衡状态：\n$$ k_{1}\\,[E]\\,[S] \\approx k_{-1}\\,[ES] $$\n整理可得：\n$$ \\frac{[E]\\,[S]}{[ES]} \\approx \\frac{k_{-1}}{k_{1}} = K_{d} $$\n由此，我们将 $[ES]$ 表示为 $[ES] = \\frac{[E]\\,[S]}{K_{d}}$。利用守恒定律 $[E] = E_{\\mathrm{T}} - [ES]$：\n$$ [ES] = \\frac{(E_{\\mathrm{T}} - [ES])\\,[S]}{K_{d}} $$\n求解 $[ES]$：\n$$ [ES]\\,K_{d} = E_{\\mathrm{T}}\\,[S] - [ES]\\,[S] $$\n$$ [ES]\\,K_{d} + [ES]\\,[S] = E_{\\mathrm{T}}\\,[S] $$\n$$ [ES]\\,(K_{d} + [S]) = E_{\\mathrm{T}}\\,[S] $$\n$$ [ES] = \\frac{E_{\\mathrm{T}}\\,[S]}{K_{d} + [S]} $$\n于是，REA速率 $v_{\\mathrm{REA}}$ 为 $v_{\\mathrm{REA}} = k_{2}\\,[ES]$：\n$$ v_{\\mathrm{REA}}(S) = \\frac{k_{2}\\,E_{\\mathrm{T}}\\,[S]}{K_{d} + [S]} $$\n这给出了速率关于 $E_{\\mathrm{T}}$、$S$、$k_{2}$ 和 $K_{d}$ 的表达式。\n\n**相对误差 $\\delta(S)$ 的推导**\n\n相对误差定义为 $\\delta(S) \\equiv \\frac{v_{\\mathrm{REA}}(S)}{v_{\\mathrm{QSSA}}(S)} - 1$。使用速率的米氏-门顿形式：\n$$ v_{\\mathrm{QSSA}}(S) = \\frac{k_{2}\\,E_{\\mathrm{T}}\\,[S]}{K_{M} + [S]} \\quad \\text{和} \\quad v_{\\mathrm{REA}}(S) = \\frac{k_{2}\\,E_{\\mathrm{T}}\\,[S]}{K_{d} + [S]} $$\n比值 $\\frac{v_{\\mathrm{REA}}(S)}{v_{\\mathrm{QSSA}}(S)}$ 为：\n$$ \\frac{v_{\\mathrm{REA}}(S)}{v_{\\mathrm{QSSA}}(S)} = \\frac{\\frac{k_{2}\\,E_{\\mathrm{T}}\\,[S]}{K_{d} + [S]}}{\\frac{k_{2}\\,E_{\\mathrm{T}}\\,[S]}{K_{M} + [S]}} = \\frac{K_{M} + [S]}{K_{d} + [S]} $$\n现在，我们计算 $\\delta(S)$：\n$$ \\delta(S) = \\frac{K_{M} + [S]}{K_{d} + [S]} - 1 = \\frac{K_{M} + [S] - (K_{d} + [S])}{K_{d} + [S]} = \\frac{K_{M} - K_{d}}{K_{d} + [S]} $$\n为了用 $K_{d}$、$k_{2}$、$k_{-1}$ 和 $S$ 来表示它，我们首先计算 $K_{M} - K_{d}$ 这一项：\n$$ K_{M} - K_{d} = \\frac{k_{-1} + k_{2}}{k_{1}} - \\frac{k_{-1}}{k_{1}} = \\frac{k_{2}}{k_{1}} $$\n我们需要消去 $k_{1}$。根据定义 $K_{d} = \\frac{k_{-1}}{k_{1}}$，我们有 $k_{1} = \\frac{k_{-1}}{K_{d}}$。将此代入 $K_{M} - K_{d}$ 的表达式中：\n$$ K_{M} - K_{d} = \\frac{k_{2}}{k_{-1}/K_{d}} = \\frac{k_{2}\\,K_{d}}{k_{-1}} $$\n最后，我们将此结果代回 $\\delta(S)$ 的表达式中：\n$$ \\delta(S) = \\frac{\\frac{k_{2}\\,K_{d}}{k_{-1}}}{K_{d} + S} = \\frac{k_{2}\\,K_{d}}{k_{-1}\\,(K_{d} + S)} $$\n这就是所要求的 $\\delta(S)$ 的闭式表达式。\n\n**$\\delta(S)$ 的上确界的确定**\n\n我们需要找到在所有非负底物浓度 $S \\ge 0$ 下 $\\delta(S)$ 的上确界。表达式为：\n$$ \\delta(S) = \\frac{k_{2}\\,K_{d}}{k_{-1}\\,(K_{d} + S)} $$\n速率常数 $k_2$、$k_{-1}$ 和解离常数 $K_d$ 都是正常数。令 $C = \\frac{k_{2}\\,K_{d}}{k_{-1}}$。则 $\\delta(S) = \\frac{C}{K_{d} + S}$。\n为了在定义域 $S \\in [0, \\infty)$ 上找到此函数的上确界，我们分析其作为 $S$ 的函数的行为。分子是一个正常数，而分母 $K_d + S$ 是一个正的且关于 $S$ 严格递增的函数。因此，对于 $S \\ge 0$，$\\delta(S)$ 是一个关于 $S$ 的严格递减函数。\n在数学上，我们可以通过检查其对 $S$ 的导数来证实这一点：\n$$ \\frac{d\\delta}{dS} = \\frac{d}{dS} \\left( \\frac{k_{2}\\,K_{d}}{k_{-1}} (K_{d} + S)^{-1} \\right) = \\frac{k_{2}\\,K_{d}}{k_{-1}} \\cdot (-1) \\cdot (K_{d} + S)^{-2} = -\\frac{k_{2}\\,K_{d}}{k_{-1}\\,(K_{d} + S)^2} $$\n因为所有常数和 $(K_d+S)^2$ 都是正的，所以对于所有 $S \\ge 0$，$\\frac{d\\delta}{dS}  0$。\n对于在区间 $[0, \\infty)$ 上的严格递减函数，其最大值，也就是上确界，在定义域的下边界处取得，即 $S = 0$。\n所以，我们计算 $S=0$ 时的 $\\delta(S)$：\n$$ \\sup_{S \\ge 0} \\delta(S) = \\delta(0) = \\frac{k_{2}\\,K_{d}}{k_{-1}\\,(K_{d} + 0)} = \\frac{k_{2}\\,K_{d}}{k_{-1}\\,K_{d}} $$\n$K_{d}$ 项相互抵消，得到相对误差上确界的最终表达式：\n$$ \\sup_{S \\ge 0} \\delta(S) = \\frac{k_{2}}{k_{-1}} $$\n该表达式即为所要求的关于 $k_{2}$ 和 $k_{-1}$ 的上确界。",
            "answer": "$$\\boxed{\\frac{k_{2}}{k_{-1}}}$$"
        },
        {
            "introduction": "虽然标准准稳态近似（sQSSA）功能强大，但它建立在酶是真正意义上的痕量催化剂这一假设之上。本练习将探讨当这一假设被打破时会发生什么——这在细胞信号通路中是常见情景。你将通过编程实现并比较精确模型、失效的标准QSSA模型以及一个更稳健的版本——总准稳态近似（tQSSA）模型，从而在实践中理解何时以及为何需要不同的近似方法。",
            "id": "3342068",
            "problem": "考虑人工酶网络 $E + S \\underset{k_{-1}}{\\stackrel{k_1}{\\rightleftharpoons}} ES \\xrightarrow{k_2} E + P$，其满足守恒定律 $E + ES = E_0$ 和 $S + ES + P = S_0$，其中 $k_1$、$k_{-1}$、$k_2$、$E_0$ 和 $S_0$ 均为正常数，且 $E_0 \\approx S_0$。其控制动力学遵循质量作用定律。目标是评估在何种条件下，标准准稳态近似 (QSSA) 失效，而总准稳态近似 (tQSSA) 能产生 $O(\\epsilon)$ 阶的精度，并量化该近似误差作为 $\\epsilon = E_0/S_0$ 的函数。\n\n仅从质量作用动力学和守恒定律出发，推导并实现三种动力学模型：精确质量作用系统、标准准稳态近似 (QSSA) 和总准稳态近似 (tQSSA)。对于每个模型，在一个固定的时间范围内计算 $S(t)$ 和 $P(t)$ 的时间进程。然后，对于每组参数，计算每种近似与精确质量作用动力学相比，在 $S(t)$ 和 $P(t)$ 上的最大绝对误差，并通过报告比值 $\\max_t |S_{\\text{tQSSA}}(t) - S_{\\text{exact}}(t)| / \\epsilon$ 和 $\\max_t |P_{\\text{tQSSA}}(t) - P_{\\text{exact}}(t)| / \\epsilon$，来量化 tQSSA 误差相对于 $\\epsilon$ 的标度关系。\n\n您的程序必须：\n- 使用质量作用动力学为 $S(t)$、$ES(t)$ 和 $P(t)$ 建立精确系统，并与守恒关系 $E(t) = E_0 - ES(t)$ 保持一致。\n- 通过强制复合物 $ES$ 在相对于缓慢的底物动力学而言的快速时间尺度上达到准稳态，并将 $S(t)$ 作为慢变量，来建立标准 QSSA 模型。\n- 通过将总底物 $S_T(t) = S(t) + ES(t)$ 作为慢变量，并对 $ES$ 施加与守恒定律一致的准稳态，来建立 tQSSA 模型。\n- 在公共时间网格上对所有模型进行数值积分，并计算所要求的误差度量。\n\n要求科学真实性和内部一致性。问题陈述中不允许使用任何快捷公式；所有近似都必须在您的解答中从质量作用动力学和守恒的第一性原理推导得出。所有数学实体都必须用 LaTeX 书写。\n\n使用以下参数集测试套件，它涵盖了典型和边缘情况下的体系：\n- 情况 A (标准 QSSA 的理想路径)：$k_1 = 10$，$k_{-1} = 1$，$k_2 = 1$，$S_0 = 1$，$E_0 = 0.01$，$\\epsilon = 0.01$，最终时间 $T = 10$。\n- 情况 B (标准 QSSA 因 $E_0 \\approx S_0/2$ 而受压)：$k_1 = 10$，$k_{-1} = 1$，$k_2 = 1$，$S_0 = 1$，$E_0 = 0.5$，$\\epsilon = 0.5$，最终时间 $T = 10$。\n- 情况 C (标准 QSSA 因 $E_0 \\approx S_0$ 而受压)：$k_1 = 10$，$k_{-1} = 1$，$k_2 = 1$，$S_0 = 1$，$E_0 = 1$，$\\epsilon = 1$，最终时间 $T = 10$。\n- 情况 D (快速平衡体系，边缘情况覆盖)：$k_1 = 10$，$k_{-1} = 100$，$k_2 = 0.1$，$S_0 = 1$，$E_0 = 0.5$，$\\epsilon = 0.5$，最终时间 $T = 10$。\n\n所有浓度以任意一致的单位表示，时间以秒为单位。最终的数值输出中无需包含物理单位，这些输出是无量纲误差。最终输出必须是单行，包含一个逗号分隔的 Python 风格列表，其中每个测试用例贡献一个包含六个浮点数的列表，顺序为\n$$\\left[ \\max_t |S_{\\text{QSSA}}(t) - S_{\\text{exact}}(t)|, \\max_t |S_{\\text{tQSSA}}(t) - S_{\\text{exact}}(t)|, \\max_t |P_{\\text{QSSA}}(t) - P_{\\text{exact}}(t)|, \\max_t |P_{\\text{tQSSA}}(t) - P_{\\text{exact}}(t)|, \\frac{\\max_t |S_{\\text{tQSSA}}(t) - S_{\\text{exact}}(t)|}{\\epsilon}, \\frac{\\max_t |P_{\\text{tQSSA}}(t) - P_{\\text{exact}}(t)|}{\\epsilon} \\right].$$\n\n您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表形式的结果（例如，$\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3\\right]$），其中每个 $\\text{result}_i$ 本身是为情况 A、情况 B、情况 C 和情况 D 分别计算的、按指定顺序排列的六个浮点数列表。",
            "solution": "用户提供的问题是计算系统生物学中一个适定的标准练习，特别是在酶动力学分析方面。它有科学依据，内部一致，并要求从第一性原理推导和比较基本模型。\n\n问题围绕 Michaelis-Menten 反应机理展开：\n$$\nE + S \\underset{k_{-1}}{\\stackrel{k_1}{\\rightleftharpoons}} ES \\xrightarrow{k_2} E + P\n$$\n其中 $E$ 是酶，$S$ 是底物，$ES$ 是酶-底物复合物，$P$ 是产物。速率常数为 $k_1$、$k_{-1}$ 和 $k_2$。该系统受两个守恒定律约束：\n1.  酶守恒：总酶浓度 $E_0$ 是恒定的。\n    $$E(t) + ES(t) = E_0$$\n2.  底物物质守恒：底物的总量，无论是游离的、络合的还是已转化为产物的，都是恒定的，等于初始底物浓度 $S_0$。\n    $$S(t) + ES(t) + P(t) = S_0$$\n\n该分析需要推导和数值求解三个不同的动力学模型。\n\n### 模型 1：精确质量作用模型\n\n该模型直接从质量作用定律推导得出，该定律指出反应速率与反应物浓度的乘积成正比。正向结合、反向解离和催化步骤的速率分别为：\n$$\nv_1 = k_1 E(t) S(t)\n$$\n$$\nv_{-1} = k_{-1} ES(t)\n$$\n$$\nv_2 = k_2 ES(t)\n$$\n物质 $S$、$ES$ 和 $P$ 的浓度变化率由以下常微分方程组 (ODE) 给出：\n$$\n\\frac{dS}{dt} = -v_1 + v_{-1} = -k_1 E(t) S(t) + k_{-1} ES(t)\n$$\n$$\n\\frac{dES}{dt} = v_1 - v_{-1} - v_2 = k_1 E(t) S(t) - k_{-1} ES(t) - k_2 ES(t)\n$$\n$$\n\\frac{dP}{dt} = v_2 = k_2 ES(t)\n$$\n利用酶守恒定律，我们通过代入 $E(t) = E_0 - ES(t)$ 来消除 $E(t)$。这降低了系统的维度。ODE 变为：\n$$\n\\frac{dS}{dt} = -k_1 (E_0 - ES(t)) S(t) + k_{-1} ES(t)\n$$\n$$\n\\frac{dES}{dt} = k_1 (E_0 - ES(t)) S(t) - (k_{-1} + k_2) ES(t)\n$$\n一旦 $S(t)$ 和 $ES(t)$ 已知，产物浓度 $P(t)$ 可以在任何时间 $t$ 通过第二个守恒定律代数确定：$P(t) = S_0 - S(t) - ES(t)$。因此，精确动力学由一个关于 $S(t)$ 和 $ES(t)$ 的耦合非线性 ODE 系统描述，初始条件为 $S(0) = S_0$ 和 $ES(0) = 0$。\n\n### 模型 2：标准准稳态近似 (sQSSA 或 QSSA)\n\n当酶-底物复合物 $ES$ 的浓度平衡速度远快于底物 $S$ 的浓度时，QSSA 适用。这种时间尺度分离通常在总酶浓度远小于初始底物浓度 ($E_0 \\ll S_0$) 时有效。该近似假设 $ES$ 迅速达到准稳态，即 $\\frac{dES}{dt} \\approx 0$。\n将此条件应用于 $ES$ 的 ODE：\n$$\nk_1 (E_0 - ES(t)) S(t) - (k_{-1} + k_2) ES(t) \\approx 0\n$$\n我们可以求解此代数方程，用慢变量 $S$ 表示 $ES$：\n$$\nk_1 E_0 S(t) \\approx (k_1 S(t) + k_{-1} + k_2) ES(t)\n$$\n$$\nES_{\\text{qssa}}(S) = \\frac{k_1 E_0 S(t)}{k_1 S(t) + k_{-1} + k_2} = \\frac{E_0 S(t)}{S(t) + K_M}\n$$\n其中 $K_M = \\frac{k_{-1} + k_2}{k_1}$ 是 Michaelis 常数。此表达式将快变量 $ES$ 的浓度与慢变量 $S$ 的浓度联系起来。\n\n然后，通过将此表达式代入 $S$ 的 ODE，可以得到慢变量 $S$ 的动力学。一个更简单的方法是考虑产物的生成速率，它决定了底物的消耗速率。产物的变化率为 $\\frac{dP}{dt} = k_2 ES$。在 QSSA 中，我们也可以假设被络合在复合物中的底物量与总底物相比可以忽略不计，因此 $S(t)+P(t) \\approx S_0$。这意味着 $\\frac{dS}{dt} = -\\frac{dP}{dt}$。\n$$\n\\frac{dS}{dt} \\approx -k_2 ES_{\\text{qssa}}(S) = - \\frac{k_2 E_0 S(t)}{S(t) + K_M}\n$$\n这就是著名的 Michaelis-Menten 方程。QSSA 模型将系统简化为关于 $S(t)$ 的单个 ODE，初始条件为 $S(0)=S_0$。然后，产物浓度可以从简化的守恒定律 $P(t) = S_0 - S(t)$ 中简单地得到。\n\n### 模型 3：总准稳态近似 (tQSSA)\n\n当 sQSSA 的核心假设 $E_0 \\ll S_0$ 被违反时，它会失效。当 $E_0$ 与 $S_0$ 相当时，总底物的很大一部分可能被络合在 $ES$ 复合物中，使得简化的守恒定律 $S(t)+P(t) \\approx S_0$ 无效。\ntQSSA 通过选择一个不同的慢变量来解决这个问题：总底物 $S_T(t) = S(t) + ES(t)$。$S_T$ 的动力学从精确的质量作用方程推导而来：\n$$\n\\frac{dS_T}{dt} = \\frac{dS}{dt} + \\frac{dES}{dt} = \\left(-k_1 E S + k_{-1} ES\\right) + \\left(k_1 E S - (k_{-1} + k_2) ES\\right) = -k_2 ES(t)\n$$\n这个 ODE 是精确的。当我们将快变量 $ES$ 与慢变量 $S_T$ 关联时，引入了近似。我们仍然对 $ES$ 使用准稳态假设 $\\frac{dES}{dt} \\approx 0$，这得到：\n$$\nk_1 (E_0 - ES)(S) - (k_{-1} + k_2) ES = 0\n$$\n但是，我们现在将 $S = S_T - ES$ 代入此方程：\n$$\nk_1 (E_0 - ES)(S_T - ES) - (k_{-1} + k_2) ES = 0\n$$\n两边除以 $k_1$ 并重新整理，得到一个关于 $ES$ 的、以 $S_T$ 表示的二次方程：\n$$\n(E_0 - ES)(S_T - ES) - K_M ES = 0\n$$\n$$\nE_0 S_T - E_0 ES - S_T ES + ES^2 - K_M ES = 0\n$$\n$$\nES^2 - (E_0 + S_T + K_M)ES + E_0 S_T = 0\n$$\n具有物理意义的解是两个根中较小的一个，这确保了 $ES \\le E_0$ 和 $ES \\le S_T$：\n$$\nES_{\\text{tqssa}}(S_T) = \\frac{(E_0 + S_T + K_M) - \\sqrt{(E_0 + S_T + K_M)^2 - 4 E_0 S_T}}{2}\n$$\n那么 tQSSA 模型就是关于 $S_T(t)$ 的单个 ODE：\n$$\n\\frac{dS_T}{dt} = -k_2 ES_{\\text{tqssa}}(S_T(t))\n$$\n初始条件为 $S_T(0) = S(0) + ES(0) = S_0 + 0 = S_0$。求解出 $S_T(t)$ 后，可以恢复其他物质的浓度。根据完整的守恒定律 $S+ES+P=S_0$，我们有 $S_T+P=S_0$，所以 $P(t) = S_0 - S_T(t)$。游离底物为 $S(t) = S_T(t) - ES_{\\text{tqssa}}(S_T(t))$。\n\n### 数值解与误差分析\n这三个 ODE 系统在指定的时间间隔内进行数值求解。sQSSA 和 tQSSA 得到的 $S(t)$ 和 $P(t)$ 轨迹与精确质量作用模型的解进行比较。计算每种近似在整个时间过程中的最大绝对误差。最后，为了验证 tQSSA 的理论精度为 $O(\\epsilon)$ 阶（其中 $\\epsilon = E_0/S_0$），计算最大误差与 $\\epsilon$ 的比值。在近似有效的体系中，该比值预计为 $O(1)$ 阶。",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Derives, solves, and compares exact, QSSA, and tQSSA models for an\n    enzyme-substrate system across different parameter regimes.\n    \"\"\"\n    \n    test_cases = [\n        # Case A: k1, k-1, k2, S0, E0, T (epsilon = E0/S0 = 0.01)\n        (10.0, 1.0, 1.0, 1.0, 0.01, 10.0),\n        # Case B: k1, k-1, k2, S0, E0, T (epsilon = E0/S0 = 0.5)\n        (10.0, 1.0, 1.0, 1.0, 0.5, 10.0),\n        # Case C: k1, k-1, k2, S0, E0, T (epsilon = E0/S0 = 1.0)\n        (10.0, 1.0, 1.0, 1.0, 1.0, 10.0),\n        # Case D: k1, k-1, k2, S0, E0, T (epsilon = E0/S0 = 0.5)\n        (10.0, 100.0, 0.1, 1.0, 0.5, 10.0),\n    ]\n    \n    results = []\n    for case_params in test_cases:\n        results.append(process_case(case_params))\n    \n    # Format the final output string as a list of lists.\n    # str(list) produces the python-style list format '[item1, item2, ...]'\n    # which is then joined by commas and enclosed in an outer list.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef process_case(params):\n    \"\"\"\n    Solves the three models for a single parameter set and computes error metrics.\n    \"\"\"\n    k1, k_1, k2, S0, E0, T = params\n    epsilon = E0 / S0\n    KM = (k_1 + k2) / k1\n    t_span = [0, T]\n    # Use a common time grid for all solvers to ensure fair comparison.\n    t_eval = np.linspace(t_span[0], t_span[1], 1001)\n\n    # --- 1. Exact Mass-Action Model ---\n    def exact_model(t, y):\n        S, ES = y\n        # dS/dt\n        dSdt = -k1 * (E0 - ES) * S + k_1 * ES\n        # dES/dt\n        dESdt = k1 * (E0 - ES) * S - (k_1 + k2) * ES\n        return [dSdt, dESdt]\n\n    y0_exact = [S0, 0.0]\n    sol_exact = solve_ivp(exact_model, t_span, y0_exact, t_eval=t_eval, method='LSODA', rtol=1e-9, atol=1e-12)\n    S_exact = sol_exact.y[0, :]\n    ES_exact = sol_exact.y[1, :]\n    P_exact = S0 - S_exact - ES_exact\n\n    # --- 2. Standard QSSA (sQSSA) Model ---\n    def qssa_model(t, y):\n        S = y[0]\n        # dS/dt = -V_max * S / (K_M + S), where V_max = k2 * E0\n        dSdt = - (k2 * E0 * S) / (S + KM)\n        return [dSdt]\n\n    y0_qssa = [S0]\n    sol_qssa = solve_ivp(qssa_model, t_span, y0_qssa, t_eval=t_eval, method='LSODA', rtol=1e-9, atol=1e-12)\n    S_qssa = sol_qssa.y[0, :]\n    P_qssa = S0 - S_qssa\n\n    # --- 3. Total QSSA (tQSSA) Model ---\n    def tqssa_model(t, y):\n        ST = y[0]\n        # Avoid division by zero or negative sqrt if ST becomes very small\n        if ST  1e-12: ST = 0\n        # ES is the solution to ES^2 - (E0+ST+KM)ES + E0*ST = 0\n        b = E0 + ST + KM\n        c = E0 * ST\n        # Using the smaller, physically meaningful root\n        ES = (b - np.sqrt(b**2 - 4*c)) / 2 if b**2 - 4*c = 0 else 0\n        # dST/dt = -k2*ES\n        dSTdt = -k2 * ES\n        return [dSTdt]\n\n    y0_tqssa = [S0]\n    sol_tqssa = solve_ivp(tqssa_model, t_span, y0_tqssa, t_eval=t_eval, method='LSODA', rtol=1e-9, atol=1e-12)\n    ST_tqssa = sol_tqssa.y[0, :]\n\n    # Recover S and P from the tQSSA solution\n    # Vectorized calculation for ES_tqssa from ST_tqssa\n    b_vec = E0 + ST_tqssa + KM\n    c_vec = E0 * ST_tqssa\n    discriminant = b_vec**2 - 4*c_vec\n    # Ensure discriminant is non-negative\n    discriminant[discriminant  0] = 0\n    ES_tqssa = (b_vec - np.sqrt(discriminant)) / 2\n    \n    S_tqssa = ST_tqssa - ES_tqssa\n    P_tqssa = S0 - ST_tqssa\n\n    # --- Error Calculation ---\n    max_err_S_qssa = np.max(np.abs(S_qssa - S_exact))\n    max_err_S_tqssa = np.max(np.abs(S_tqssa - S_exact))\n    \n    max_err_P_qssa = np.max(np.abs(P_qssa - P_exact))\n    max_err_P_tqssa = np.max(np.abs(P_tqssa - P_exact))\n    \n    # Quantify scaling of tQSSA error with respect to epsilon\n    scaled_err_S_tqssa = max_err_S_tqssa / epsilon\n    scaled_err_P_tqssa = max_err_P_tqssa / epsilon\n    \n    return [\n        max_err_S_qssa, max_err_S_tqssa,\n        max_err_P_qssa, max_err_P_tqssa,\n        scaled_err_S_tqssa, scaled_err_P_tqssa\n    ]\n\nif __name__ == \"__main__\":\n    solve()\n\n```"
        },
        {
            "introduction": "模型简化的最终目标是使复杂的生物系统变得易于分析，同时保留其核心功能。这最后一个练习将QSSA和REA应用于一个核心信号模体——MAPK级联反应。其目的是证明一个经过仔细简化的模型仍然能够捕捉到如超敏性（ultrasensitivity）和双稳性（bistability）等复杂的涌现特性，从而展示这些近似方法在产生生物学洞见方面的强大威力。",
            "id": "3342115",
            "problem": "考虑一个具有分布式双重磷酸化作用的丝裂原活化蛋白激酶 (MAPK) 级联的单个模块。设底物有三种磷酸化状态，记为 $S_0$、$S_1$ 和 $S_2$。一种激酶（酶）催化 $S_0 \\rightarrow S_1$ 和 $S_1 \\rightarrow S_2$ 的转换，而一种磷酸酶（酶）催化 $S_2 \\rightarrow S_1$ 和 $S_1 \\rightarrow S_0$ 的转换。完整机理模型根据质量作用定律包含显式的酶-底物复合物，并遵守总酶量守恒。简化模型必须通过对酶-底物中间体使用准稳态近似 (QSSA) 和对 $S_2$ 激活激酶的反馈过程使用快速平衡近似 (REA) 来推导。\n\n使用的基本原理：\n- 质量作用定律：如果物种 $A$ 和 $B$ 以速率常数 $k$ 发生反应，则反应速率为 $k [A][B]$。\n- 单步酶动力学遵循结合和催化事件，其结合速率为 $k_{\\text{on}}$，解离速率为 $k_{\\text{off}}$，催化速率为 $k_{\\text{cat}}$。\n- 守恒关系：总酶量等于其游离形式和结合形式的总和。\n\n完整机理模型规范：\n- 物种：$S_0$、$S_1$、$S_2$、$C_1$、$C_2$、$D_1$、$D_2$、$E_{\\text{act}}^{\\text{free}}$。其中，$C_1$ 和 $C_2$ 分别是 $S_0$ 和 $S_1$ 的激酶-底物复合物；$D_1$ 和 $D_2$ 分别是 $S_1$ 和 $S_2$ 的磷酸酶-底物复合物；$E_{\\text{act}}^{\\text{free}}$ 是游离活性激酶。\n- 激酶步骤的参数：对于 $S_0 \\rightarrow S_1$ 为 $k_{1}^{\\text{on}}$、$k_{1}^{\\text{off}}$、$k_{1}^{\\text{cat}}$，对于 $S_1 \\rightarrow S_2$ 为 $k_{2}^{\\text{on}}$、$k_{2}^{\\text{off}}$、$k_{2}^{\\text{cat}}$。\n- 磷酸酶步骤的参数：对于 $S_1 \\rightarrow S_0$ 为 $k_{f1}^{\\text{on}}$、$k_{f1}^{\\text{off}}$、$k_{f1}^{\\text{cat}}$，对于 $S_2 \\rightarrow S_1$ 为 $k_{f2}^{\\text{on}}$、$k_{f2}^{\\text{off}}$、$k_{f2}^{\\text{cat}}$。\n- 酶总量：$E_{\\text{tot}}$ (激酶总容量)，$F_{\\text{tot}}$ (磷酸酶总容量)。游离磷酸酶为 $F^{\\text{free}} = F_{\\text{tot}} - D_1 - D_2$。游离活性激酶为 $E^{\\text{free}} = E_{\\text{act}}^{\\text{free}} - C_1 - C_2$。\n- 反馈激活：游离非活性激酶 $E_{\\text{inact}}^{\\text{free}} = E_{\\text{tot}} - E_{\\text{act}}^{\\text{free}} - C_1 - C_2$ 通过与 $S_2$ 结合而转化为游离活性激酶，其结合速率为 $k_{a}^{\\text{on}}$，解离速率为 $k_{a}^{\\text{off}}$。为了实现协同激活，假设对 $S_2$ 的质量作用阶数为 $p$，因此激活反应速率为 $k_{a}^{\\text{on}} S_2^{p} E_{\\text{inact}}^{\\text{free}}$，失活速率为 $k_{a}^{\\text{off}} E_{\\text{act}}^{\\text{free}}$。\n- 完整模型的常微分方程 (ODE) 是根据结合、解离、催化和激活/失活的质量作用定律构建的。待测量的输出是完全磷酸化底物的稳态分数 $y = S_2 / S_{\\text{tot}}$，其中 $S_{\\text{tot}} = S_0 + S_1 + S_2 + C_1 + C_2 + D_1 + D_2$ 根据构造是守恒的。\n\n简化模型要求：\n- 应用准稳态近似 (QSSA) 消除 $C_1$、$C_2$、$D_1$ 和 $D_2$，从而用 $S_0$、$S_1$、$S_2$ 和酶总量表示四个转换的有效速率。\n- 应用快速平衡近似 (REA) 消除 $E_{\\text{act}}^{\\text{free}}$，代之以一个由 $S_2$ 激活的 $E_{\\text{tot}}$ 的代数分数，该激活具有协同阶数 $p$，因此活性分数通过一个由 $k_{a}^{\\text{on}}$ 和 $k_{a}^{\\text{off}}$ 决定的平衡关系依赖于 $S_2$。\n- 简化模型的 ODE 必须仅用 $S_0$、$S_1$、$S_2$ 和参数表示，不含显式复合物或 $E_{\\text{act}}^{\\text{free}}$ 的动力学过程。\n\n您的程序必须：\n- 对指定的参数值，将完整模型和简化模型都数值积分至稳态。\n- 对于剂量-反应分析，在保持其他参数固定的情况下，在规定范围内改变 $E_{\\text{tot}}$，计算稳态输出 $y$，并通过在半最大反应处使用 $\\log\\left(\\frac{y}{1-y}\\right)$ 对 $\\log(E_{\\text{tot}})$ 的导数（在 $y = 0.5$ 附近求值）来估计有效希尔系数 $n_{\\text{H}}$。\n- 通过检查两个模型是否都表现出大于阈值的 $n_{\\text{H}}$，并且 $n_{\\text{H}}$ 的差异在容差范围内，来确定超敏性再现性。\n- 通过检查（对于包括正反馈（$p \\geq 2$）在内的固定参数）从两个不同的 $S_2$ 初始条件达到的稳态在每个模型中是否不同，来确定双稳态再现性。\n\n测试套件：\n- 案例 1 (超敏性区间)：选择的参数使得激酶和磷酸酶都在接近饱和的状态下运行，其 $K_m$ 值相对于底物丰度较小。使用 $S_{\\text{tot}} = 1$，$k_{1}^{\\text{on}} = 100$，$k_{1}^{\\text{off}} = 1$，$k_{1}^{\\text{cat}} = 1$，$k_{2}^{\\text{on}} = 100$，$k_{2}^{\\text{off}} = 1$，$k_{2}^{\\text{cat}} = 1$，$k_{f1}^{\\text{on}} = 100$，$k_{f1}^{\\text{off}} = 1$，$k_{f1}^{\\text{cat}} = 1$，$k_{f2}^{\\text{on}} = 100$，$k_{f2}^{\\text{off}} = 1$，$k_{f2}^{\\text{cat}} = 1$，$F_{\\text{tot}} = 0.05$，$k_{a}^{\\text{on}} = 0$，$k_{a}^{\\text{off}} = 0$，$p = 1$。在 $0.005$ 和 $0.2$ 之间对 $E_{\\text{tot}}$ 进行 50 个点的扫描。如果两个模型都有 $n_{\\text{H}} \\geq 1.7$ 且 $|n_{\\text{H}}^{\\text{full}} - n_{\\text{H}}^{\\text{red}}| \\leq 0.7$，则超敏性再现性为 $True$。\n- 案例 2 (非超敏性边界区间)：增加酶总量以降低饱和度。使用与案例 1 相同的速率，但 $F_{\\text{tot}} = 0.5$。在 $0.005$ 和 $0.5$ 之间对 $E_{\\text{tot}}$ 进行 50 个点的扫描。如果两个模型都有 $n_{\\text{H}} \\leq 1.3$，则非超敏性再现性为 $True$。\n- 案例 3 (具有正反馈的双稳态)：选择的参数旨在通过 $S_2$ 诱导激酶的协同激活。使用 $S_{\\text{tot}} = 1$，$k_{1}^{\\text{on}} = 100$，$k_{1}^{\\text{off}} = 1$，$k_{1}^{\\text{cat}} = 1$，$k_{2}^{\\text{on}} = 100$，$k_{2}^{\\text{off}} = 1$，$k_{2}^{\\text{cat}} = 1$，$k_{f1}^{\\text{on}} = 100$，$k_{f1}^{\\text{off}} = 1$，$k_{f1}^{\\text{cat}} = 1$，$k_{f2}^{\\text{on}} = 100$，$k_{f2}^{\\text{off}} = 1$，$k_{f2}^{\\text{cat}} = 1$，$E_{\\text{tot}} = 0.12$，$F_{\\text{tot}} = 0.05$，$k_{a}^{\\text{on}} = 100$，$k_{a}^{\\text{off}} = 1$，$p = 2$。一次使用 $(S_0,S_1,S_2) = (1,0,0)$ 初始化，另一次使用 $(S_0,S_1,S_2) = (0,0,1)$ 初始化。如果对于完整模型和简化模型，两个 $S_2$ 的稳态值差异均至少为 $0.1$，则双稳态再现性为 $True$。\n\n输出规范：\n- 对于上述三个测试案例，您的程序必须为每个案例计算一个布尔值：\n    - 案例 1：如果超敏性再现性成立，则为 $True$，否则为 $False$。\n    - 案例 2：如果非超敏性再现性成立，则为 $True$，否则为 $False$。\n    - 案例 3：如果双稳态再现性成立，则为 $True$，否则为 $False$。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，例如 $[b_1,b_2,b_3]$，其中每个 $b_i$ 是 $True$ 或 $False$，不含额外文本。",
            "solution": "用户提供了一个计算系统生物学问题，要求推导和仿真 MAPK 级联的两个模型：一个完整的机理模型和一个基于准稳态近似 (QSSA) 和快速平衡近似 (REA) 的简化模型。任务是验证该问题，如果有效，则实现这两个模型，为三个不同的测试案例运行仿真，并根据指定标准评估简化模型是否成功再现了完整模型的动态行为（超敏性和双稳态）。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n\n-   **系统**：单模块、分布式双重磷酸化 MAPK 级联。\n-   **物种（状态）**：底物 $S_0, S_1, S_2$；激酶-底物复合物 $C_1 = E \\cdot S_0$，$C_2 = E \\cdot S_1$；磷酸酶-底物复合物 $D_1 = F \\cdot S_1$，$D_2 = F \\cdot S_2$；游离活性激酶 $E_{\\text{act}}^{\\text{free}}$。\n-   **反应**：激酶 E 催化 $S_0 \\rightarrow S_1$ 和 $S_1 \\rightarrow S_2$。磷酸酶 F 催化 $S_2 \\rightarrow S_1$ 和 $S_1 \\rightarrow S_0$。\n-   **动力学**：所有结合、解离、催化以及激活/失活步骤均遵循质量作用定律。\n-   **参数 (激酶)**：对于 $E+S_0 \\leftrightarrow C_1 \\rightarrow E+S_1$ 为 $(k_1^{\\text{on}}, k_1^{\\text{off}}, k_1^{\\text{cat}})$；对于 $E+S_1 \\leftrightarrow C_2 \\rightarrow E+S_2$ 为 $(k_2^{\\text{on}}, k_2^{\\text{off}}, k_2^{\\text{cat}})$。\n-   **参数 (磷酸酶)**：对于 $F+S_1 \\leftrightarrow D_1 \\rightarrow F+S_0$ 为 $(k_{f1}^{\\text{on}}, k_{f1}^{\\text{off}}, k_{f1}^{\\text{cat}})$；对于 $F+S_2 \\leftrightarrow D_2 \\rightarrow F+S_1$ 为 $(k_{f2}^{\\text{on}}, k_{f2}^{\\text{off}}, k_{f2}^{\\text{cat}})$。\n-   **反馈激活**：$pS_2 + E_{\\text{inact}}^{\\text{free}} \\rightleftharpoons E_{\\text{act}}^{\\text{free}}$，速率分别为 $k_a^{\\text{on}}$ 和 $k_a^{\\text{off}}$。激活速率为 $k_{a}^{\\text{on}} S_2^{p} E_{\\text{inact}}^{\\text{free}}$，失活速率为 $k_{a}^{\\text{off}} E_{\\text{act}}^{\\text{free}}$。\n-   **守恒定律**：\n    -   总底物：$S_{\\text{tot}} = S_0 + S_1 + S_2 + C_1 + C_2 + D_1 + D_2$。\n    -   总激酶：$E_{\\text{tot}} = E_{\\text{inact}}^{\\text{free}} + E_{\\text{act}}^{\\text{free}} + C_1 + C_2$。\n    -   总磷酸酶：$F_{\\text{tot}} = F^{\\text{free}} + D_1 + D_2$。\n-   **模型简化近似**：对 $C_1, C_2, D_1, D_2$ 使用 QSSA；对激酶激活反馈回路使用 REA。\n-   **输出度量**：完全磷酸化底物的稳态分数 $y = S_2 / S_{\\text{tot}}$。\n-   **希尔系数**：$n_{\\text{H}} = d(\\log(y/(1-y)))/d(\\log(E_{\\text{tot}}))$，在 $y=0.5$ 附近。\n-   **测试案例和标准**：为三个测试超敏性和双稳态再现性的案例提供了具体的参数集和条件。\n\n**步骤 2：使用提取的已知条件进行验证**\n\n1.  **科学上合理**：该问题在化学动力学、酶动力学和系统生物学原理方面有充分的依据。MAPK 级联是一个典型的模型系统，而质量作用、QSSA 和 REA 的使用是标准技术。\n2.  **良态的**：问题是良态的。它需要对常微分方程 (ODE) 系统进行数值求解，对此存在成熟的数值方法。成功标准由定量阈值定义。\n3.  **客观的**：问题以精确、客观和数学化的语言陈述。\n4.  **不完整性/矛盾**：问题陈述大体上是完整和自洽的。在输出 $y = S_2 / S_{\\text{tot}}$ 的定义中存在一个微小的歧义。在模型简化的背景下，简化模型中的状态变量 $S_2$ 代表双重磷酸化形式底物的总浓度。为了进行有意义的比较，完整模型中相应的量必须是游离底物 ($S_2$) 和被隔离在复合物中（即 $D_2$，也就是 $F \\cdot S_2$）的底物之和。因此，完整模型的输出被解释为 $y_{\\text{full}} = ([S_2] + [D_2]) / S_{\\text{tot}}$，而简化模型的输出为 $y_{\\text{red}} = [S_2] / S_{\\text{tot}}$。类似的解释也适用于对“$S_2$ 的稳态值”进行双稳态检查。这种解释在科学上是必要的，以确保两个模型之间的有效比较。\n5.  **其他缺陷**：该问题未表现出清单中的任何其他缺陷。它是指定领域内一个标准的、非平凡的问题。\n\n**步骤 3：结论和行动**\n\n问题被判定为**有效**。将提供一个解决方案。\n\n### 基于原理的解决方案设计\n\n该解决方案需要构建和求解同一生物系统的两个不同数学模型。\n\n**1. 完整机理模型**\n\n该模型是使用质量作用定律将指定的基元反应直接转换为 ODE 系统。\n-   **状态变量**：所有八个物种的浓度：$S_0, S_1, S_2, C_1, C_2, D_1, D_2, E_{\\text{act}}^{\\text{free}}$。\n-   **ODEs**：为每个物种编写一个 ODE，描述其变化速率为产生它的反应速率之和减去消耗它的反应速率之和。例如，复合物 $C_1$ 的形成速率为 $k_1^{\\text{on}} [E_{\\text{act}}^{\\text{free}}] [S_0]$，而其解离速率为 $k_1^{\\text{off}} [C_1]$，其催化转化速率为 $k_1^{\\text{cat}} [C_1]$。\n-   **依赖关系**：变化速率取决于其他物种的浓度。游离酶 $E_{\\text{act}}^{\\text{free}}$ 和 $F^{\\text{free}}$ 的浓度在每个时间步长通过使用守恒定律代数确定：$F^{\\text{free}} = F_{\\text{tot}} - D_1 - D_2$ 和 $E_{\\text{inact}}^{\\text{free}} = E_{\\text{tot}} - E_{\\text{act}}^{\\text{free}} - C_1 - C_2$，后者用于反馈项中。\n\n**2. 简化模型 (QSSA + REA)**\n\n该模型通过消除快变量来简化完整系统。\n-   **准稳态近似 (QSSA)**：酶-底物复合物 ($C_1, C_2, D_1, D_2$) 的浓度被假定比底物浓度更快地达到平衡。通过将其时间导数设为零（$d[C_1]/dt=0$ 等），我们推导出其浓度的代数表达式。这导出了熟悉的磷酸化和去磷酸化反应的米氏-门顿型速率定律。对于作用于多种底物的酶（例如，激酶 E 作用于 $S_0$ 和 $S_1$，磷酸酶 F 作用于 $S_1$ 和 $S_2$），底物之间互为竞争性抑制剂，这反映在速率定律的分母中。\n    -   有效磷酸化速率 $v_1 (S_0 \\rightarrow S_1)$ 和 $v_2 (S_1 \\rightarrow S_2)$ 变为：\n        $$ v_1 = \\frac{k_{1}^{\\text{cat}} E_{\\text{act}}^{\\text{total}} S_0 / K_{M1}}{1 + S_0/K_{M1} + S_1/K_{M2}}, \\quad v_2 = \\frac{k_{2}^{\\text{cat}} E_{\\text{act}}^{\\text{total}} S_1 / K_{M2}}{1 + S_0/K_{M1} + S_1/K_{M2}} $$\n        其中 $K_{Mi} = (k_{i}^{\\text{off}} + k_{i}^{\\text{cat}}) / k_{i}^{\\text{on}}$。\n    -   有效的去磷酸化速率 $v_{f1} (S_1 \\rightarrow S_0)$ 和 $v_{f2} (S_2 \\rightarrow S_1)$ 是类似的，用 $F_{\\text{tot}}$ 替换 $E_{\\text{act}}^{\\text{total}}$。\n-   **快速平衡近似 (REA)**：假定 $S_2$ 对激酶的激活/失活处于快速平衡状态。这使我们能够将活性激酶的总量 $E_{\\text{act}}^{\\text{total}}$ 表示为 $S_2$ 的代数函数。将平衡条件 $k_a^{\\text{on}} [S_2]^p [E_{\\text{inact}}] = k_a^{\\text{off}} [E_{\\text{act}}]$ 应用于活性和非活性激酶的总池，得到一个希尔型函数：\n    $$ E_{\\text{act}}^{\\text{total}} = E_{\\text{tot}} \\frac{[S_2]^p}{K_A^p + [S_2]^p} $$\n    等等，质量作用写为 $pS_2 + E_{inact} \\leftrightarrow E_{act}$，所以平衡是 $K_A = [E_{inact}][S_2]^p/[E_{act}]$。重新推导可得 $E_{\\text{act}} / E_{tot} = ([S_2]^p/K_A) / (1 + [S_2]^p/K_A) = [S_2]^p / (K_A + [S_2]^p)$，其中 $K_A = k_a^{\\text{off}}/k_a^{\\text{on}}$。对于没有反馈的情况 ($k_a^{\\text{on}}=k_a^{\\text{off}}=0$)，我们假设激酶是组成性活性的，$E_{\\text{act}}^{\\text{total}} = E_{\\text{tot}}$。\n-   **状态变量和 ODEs**：简化模型只跟踪慢变量 $S_0, S_1, S_2$。利用底物守恒 $S_{\\text{tot}} = S_0 + S_1 + S_2$，我们可以将系统简化为两个 ODE，例如关于 $S_1$ 和 $S_2$ 的方程：\n    $$ \\frac{dS_1}{dt} = v_1 - v_2 + v_{f2} - v_{f1}, \\quad \\frac{dS_2}{dt} = v_2 - v_{f2} $$\n\n**3. 数值仿真与分析**\n-   **稳态**：两个 ODE 系统都在足够长的时间段内进行数值积分，以确保它们达到稳态。`scipy.integrate.solve_ivp` 函数与一个刚性求解器（`Radau`）适用于此。\n-   **希尔系数 ($n_H$)**：对于超敏性分析，生成输出 $y$ 对总激酶 $E_{\\text{tot}}$ 的剂量-反应曲线。该曲线被转换为 logit-log 空间（$X = \\log(E_{\\text{tot}})$，$Y = \\log(y/(1-y))$）。通过对该区域中半最大反应点（$y=0.5$）附近的一个小数据点窗口执行线性回归，将希尔系数估计为局部斜率 $dY/dX$。\n-   **双稳态**：通过从两个不同的初始条件仿真系统来测试：一个初始条件是所有底物都为 $S_0$（“低”态），另一个是所有底物都为 $S_2$（“高”态）。如果系统对于输出物种稳定在两个不同的稳态浓度，则它是双稳态的。\n\n通过实施这些步骤，程序可以系统地评估三个测试案例，并确认简化模型是否精确地再现了完整机理模型的复杂动态行为。",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Main function to solve the three test cases for the MAPK cascade problem.\n    \"\"\"\n\n    # --- Full Model ODE System ---\n    def full_model_ode(t, y, params):\n        S0, S1, S2, C1, C2, D1, D2, E_act_free = y\n        \n        k1_on, k1_off, k1_cat, k2_on, k2_off, k2_cat, \\\n        kf1_on, kf1_off, kf1_cat, kf2_on, kf2_off, kf2_cat, \\\n        ka_on, ka_off, p, Etot, Ftot, Stot = params\n\n        # Clamp concentrations to be non-negative to handle numerical artifacts\n        y[y  0] = 0\n        S0, S1, S2, C1, C2, D1, D2, E_act_free = y\n\n        # Algebraic calculation of free molecular species from conservation laws\n        F_free = Ftot - D1 - D2\n        E_inact_free = Etot - E_act_free - C1 - C2\n        \n        # Reaction rates from Law of Mass Action\n        r_bind_C1 = k1_on * E_act_free * S0\n        r_unbind_C1 = k1_off * C1\n        r_cat_C1 = k1_cat * C1\n\n        r_bind_C2 = k2_on * E_act_free * S1\n        r_unbind_C2 = k2_off * C2\n        r_cat_C2 = k2_cat * C2\n\n        r_bind_D1 = kf1_on * F_free * S1\n        r_unbind_D1 = kf1_off * D1\n        r_cat_D1 = kf1_cat * D1\n\n        r_bind_D2 = kf2_on * F_free * S2\n        r_unbind_D2 = kf2_off * D2\n        r_cat_D2 = kf2_cat * D2\n        \n        # Feedback activation/deactivation rates\n        r_activate_E = ka_on * (S2**p) * E_inact_free\n        r_deactivate_E = ka_off * E_act_free\n\n        # ODEs for each species\n        dS0_dt = -r_bind_C1 + r_unbind_C1 + r_cat_D1\n        dS1_dt = r_cat_C1 - r_bind_C2 + r_unbind_C2 + r_cat_D2 - r_bind_D1 + r_unbind_D1\n        dS2_dt = r_cat_C2 - r_bind_D2 + r_unbind_D2\n        dC1_dt = r_bind_C1 - r_unbind_C1 - r_cat_C1\n        dC2_dt = r_bind_C2 - r_unbind_C2 - r_cat_C2\n        dD1_dt = r_bind_D1 - r_unbind_D1 - r_cat_D1\n        dD2_dt = r_bind_D2 - r_unbind_D2 - r_cat_D2\n        dE_act_free_dt = (-r_bind_C1 + r_unbind_C1 + r_cat_C1) + \\\n                         (-r_bind_C2 + r_unbind_C2 + r_cat_C2) + \\\n                         r_activate_E - r_deactivate_E\n        \n        return [dS0_dt, dS1_dt, dS2_dt, dC1_dt, dC2_dt, dD1_dt, dD2_dt, dE_act_free_dt]\n\n    # --- Reduced Model ODE System (QSSA + REA) ---\n    def reduced_model_ode(t, y, params):\n        S1, S2 = y\n        y[y  0] = 0\n        S1, S2 = y\n\n        k1_cat, k2_cat, kf1_cat, kf2_cat, \\\n        KM1, KM2, KMF1, KMF2, \\\n        ka_on, ka_off, p, Etot, Ftot, Stot = params\n\n        S0 = Stot - S1 - S2\n        if S0  0: S0 = 0\n\n        # REA for kinase activation\n        if ka_on  0:\n            KA = ka_off / ka_on\n            E_act_total = Etot * (S2**p) / (KA + S2**p)\n        else: # No feedback: constitutively active kinase\n            E_act_total = Etot\n\n        # QSSA-derived Michaelis-Menten rates with competitive inhibition\n        kin_denom = 1.0 + S0 / KM1 + S1 / KM2\n        v1 = (k1_cat * E_act_total * S0 / KM1) / kin_denom\n        v2 = (k2_cat * E_act_total * S1 / KM2) / kin_denom\n        \n        phos_denom = 1.0 + S1 / KMF1 + S2 / KMF2\n        vf1 = (kf1_cat * Ftot * S1 / KMF1) / phos_denom\n        vf2 = (kf2_cat * Ftot * S2 / KMF2) / phos_denom\n\n        # ODEs for the two independent substrate species\n        dS1_dt = v1 - v2 + vf2 - vf1\n        dS2_dt = v2 - vf2\n        \n        return [dS1_dt, dS2_dt]\n\n    # --- Helper function to find steady state ---\n    def get_steady_state(ode_func, y0, t_span, params):\n        sol = solve_ivp(ode_func, t_span, y0, args=(params,), method='Radau', atol=1e-8, rtol=1e-8)\n        if sol.status != 0:\n            return np.full_like(y0, -1.0)\n        return sol.y[:, -1]\n\n    # --- Helper function to estimate Hill coefficient ---\n    def calculate_hill(e_tots, responses):\n        valid_indices = np.where(responses = 0)[0]\n        if len(valid_indices)  3: return np.nan\n        e_tots, responses = e_tots[valid_indices], responses[valid_indices]\n        \n        responses = np.clip(responses, 1e-9, 1.0 - 1e-9)\n        log_etots = np.log(e_tots)\n        logit_y = np.log(responses / (1.0 - responses))\n\n        if not np.any(responses  0.05): return 1.0\n\n        ec50_idx = np.argmin(np.abs(responses - 0.5))\n        \n        num_points_fit = 5\n        start_idx = max(0, ec50_idx - num_points_fit // 2)\n        end_idx = min(len(log_etots), start_idx + num_points_fit)\n        \n        if end_idx - start_idx  2:\n            if start_idx  0: start_idx = max(0, end_idx - num_points_fit)\n            else: end_idx = min(len(log_etots), start_idx + num_points_fit)\n        if end_idx - start_idx  2: return np.nan\n\n        x_fit, y_fit = log_etots[start_idx:end_idx], logit_y[start_idx:end_idx]\n        \n        try:\n            slope, _ = np.polyfit(x_fit, y_fit, 1)\n            return slope\n        except (np.linalg.LinAlgError, FloatingPointError):\n            return np.nan\n\n    # --- Test Cases Definition ---\n    base_params = {\n        'S_tot': 1.0, 'k1_on': 100, 'k1_off': 1, 'k1_cat': 1,\n        'k2_on': 100, 'k2_off': 1, 'k2_cat': 1, 'kf1_on': 100,\n        'kf1_off': 1, 'kf1_cat': 1, 'kf2_on': 100, 'kf2_off': 1, 'kf2_cat': 1\n    }\n    test_cases = [\n        {'case': 1, 'F_tot': 0.05, 'ka_on': 0, 'ka_off': 0, 'p': 1, 'E_tot_range': np.linspace(0.005, 0.2, 50)},\n        {'case': 2, 'F_tot': 0.5, 'ka_on': 0, 'ka_off': 0, 'p': 1, 'E_tot_range': np.linspace(0.005, 0.5, 50)},\n        {'case': 3, 'E_tot': 0.12, 'F_tot': 0.05, 'ka_on': 100, 'ka_off': 1, 'p': 2}\n    ]\n\n    results = []\n    t_span = (0, 1e6)\n\n    for case_params in test_cases:\n        p = {**base_params, **case_params}\n        \n        # --- Common parameters for both models ---\n        Stot, k1_on, k1_off, k1_cat, k2_on, k2_off, k2_cat = p['S_tot'], p['k1_on'], p['k1_off'], p['k1_cat'], p['k2_on'], p['k2_off'], p['k2_cat']\n        kf1_on, kf1_off, kf1_cat, kf2_on, kf2_off, kf2_cat = p['kf1_on'], p['kf1_off'], p['kf1_cat'], p['kf2_on'], p['kf2_off'], p['kf2_cat']\n        ka_on, ka_off, p_val, Ftot = p['ka_on'], p['ka_off'], p['p'], p['F_tot']\n\n        params_full_base = (k1_on, k1_off, k1_cat, k2_on, k2_off, k2_cat,\n                            kf1_on, kf1_off, kf1_cat, kf2_on, kf2_off, kf2_cat,\n                            ka_on, ka_off, p_val) \n        KM1 = (k1_off + k1_cat) / k1_on\n        KM2 = (k2_off + k2_cat) / k2_on\n        KMF1 = (kf1_off + kf1_cat) / kf1_on\n        KMF2 = (kf2_off + kf2_cat) / kf2_on\n        params_red_base = (k1_cat, k2_cat, kf1_cat, kf2_cat,\n                           KM1, KM2, KMF1, KMF2, ka_on, ka_off, p_val)\n\n        if case_params['case'] in [1, 2]: # Ultrasensitivity analysis\n            y_full_res = np.zeros_like(p['E_tot_range'])\n            y_red_res = np.zeros_like(p['E_tot_range'])\n            \n            y0_full = np.array([Stot, 0, 0, 0, 0, 0, 0, 0])\n            y0_red = np.array([0, 0])\n            \n            for i, Etot in enumerate(p['E_tot_range']):\n                params_full = (*params_full_base, Etot, Ftot, Stot)\n                ss_full = get_steady_state(full_model_ode, y0_full, t_span, params_full)\n                y_full_res[i] = (ss_full[2] + ss_full[6]) / Stot if ss_full[0] = 0 else -1\n\n                params_red = (*params_red_base, Etot, Ftot, Stot)\n                ss_red = get_steady_state(reduced_model_ode, y0_red, t_span, params_red)\n                y_red_res[i] = ss_red[1] / Stot if ss_red[0] = 0 else -1\n            \n            nh_full = calculate_hill(p['E_tot_range'], y_full_res)\n            nh_red = calculate_hill(p['E_tot_range'], y_red_res)\n            \n            case_result = False\n            if np.isnan(nh_full) or np.isnan(nh_red):\n                case_result = False\n            elif case_params['case'] == 1:\n                case_result = (nh_full = 1.7 and nh_red = 1.7 and abs(nh_full - nh_red) = 0.7)\n            elif case_params['case'] == 2:\n                case_result = (nh_full = 1.3 and nh_red = 1.3)\n            results.append(case_result)\n\n        elif case_params['case'] == 3: # Bistability analysis\n            Etot = p['E_tot']\n            params_full = (*params_full_base, Etot, Ftot, Stot)\n            params_red = (*params_red_base, Etot, Ftot, Stot)\n            \n            # Initial condition 1: low S2\n            y0_full_low = np.array([Stot, 0, 0, 0, 0, 0, 0, 0])\n            ss_full_low = get_steady_state(full_model_ode, y0_full_low, t_span, params_full)\n            s2_full_low = (ss_full_low[2] + ss_full_low[6]) if ss_full_low[0] = 0 else -1\n            \n            y0_red_low = np.array([0, 0])\n            ss_red_low = get_steady_state(reduced_model_ode, y0_red_low, t_span, params_red)\n            s2_red_low = ss_red_low[1] if ss_red_low[0] = 0 else -1\n\n            # Initial condition 2: high S2\n            y0_full_high = np.array([0, 0, Stot, 0, 0, 0, 0, 0])\n            ss_full_high = get_steady_state(full_model_ode, y0_full_high, t_span, params_full)\n            s2_full_high = (ss_full_high[2] + ss_full_high[6]) if ss_full_high[0] = 0 else -1\n\n            y0_red_high = np.array([0, Stot])\n            ss_red_high = get_steady_state(reduced_model_ode, y0_red_high, t_span, params_red)\n            s2_red_high = ss_red_high[1] if ss_red_high[0] = 0 else -1\n\n            bistable_full = abs(s2_full_low - s2_full_high) = 0.1\n            bistable_red = abs(s2_red_low - s2_red_high) = 0.1\n\n            results.append(bistable_full and bistable_red)\n    \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}