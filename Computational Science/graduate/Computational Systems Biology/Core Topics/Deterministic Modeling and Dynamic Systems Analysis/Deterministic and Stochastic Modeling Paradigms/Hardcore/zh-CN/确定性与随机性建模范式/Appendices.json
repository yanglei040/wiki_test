{
    "hands_on_practices": [
        {
            "introduction": "理论学习之后，最好的巩固方式莫过于亲身实践。我们从一个基础但极为重要的模型开始：一个简化的基因表达过程，其中分子以恒定速率产生并以与其数量成正比的速率降解。通过求解化学主方程 (Chemical Master Equation, CME)，你将推导出该系统在长时间演化后达到的稳态概率分布。这个练习旨在揭示一个核心原理：对于这类线性反应系统，内在噪声会使得分子数服从泊松分布，这是理解细胞内随机性的基石。",
            "id": "3300898",
            "problem": "考虑一个充分混合的单细胞系统，其中基因产物的拷贝数 $n(t) \\in \\{0,1,2,\\dots\\}$ 作为一个连续时间马尔可夫跳跃过程演化，其基本反应如下：生成（出生）以恒定速率 $k_b  0$ 增加一个分子，降解（死亡）以与当前拷贝数成正比的速率移除一个分子，速率常数为 $k_d  0$。这对应于反应式 $\\varnothing \\xrightarrow{k_b} X$ 和 $X \\xrightarrow{k_d} \\varnothing$，其中降解遵循质量作用定律。令 $P(n,t)$ 表示系统在时刻 $t$ 有 $n$ 个分子的概率。\n\n从这些反应所对应的 $P(n,t)$ 的柯尔莫哥洛夫前向方程（也称为化学主方程（CME））出发，在假设稳态分布存在且马尔可夫链为正常返的条件下，推导 $n \\in \\mathbb{N}_0$ 的稳态概率质量函数 $P(n)$。用封闭形式表示该稳态分布，并根据一个著名的离散分布及其均值来识别它。然后，使用大系统尺寸极限下期望拷贝数的确定性对应方程 $dn/dt = k_b - k_d n$，讨论确定性稳态与稳态随机分布均值的一致性。\n\n你的最终答案必须是稳态 $P(n)$ 作为 $n$、$k_b$ 和 $k_d$ 的函数的封闭形式表达式。无需四舍五入，也无需单位，因为 $P(n)$ 是无量纲的。",
            "solution": "问题陈述已经过验证，被认为是可靠、适定且有科学依据的。它呈现了一个经典的生灭过程，这是随机化学动力学中的一个基本模型。我们可以开始求解。\n\n该系统由两个基本反应描述：\n1. 生成：$\\varnothing \\xrightarrow{k_b} X$，具有恒定的倾向性 $a_1(n) = k_b$。此反应使分子数 $n$ 增加 1。\n2. 降解：$X \\xrightarrow{k_d} \\varnothing$，具有质量作用倾向性 $a_2(n) = k_d n$。此反应使分子数 $n$ 减少 1。参数 $k_b$ 和 $k_d$ 是正常数。\n\n系统的状态是整数拷贝数 $n \\in \\{0, 1, 2, \\dots\\}$。令 $P(n,t)$ 为在时刻 $t$ 处于状态 $n$ 的概率。$P(n,t)$ 的时间演化由柯尔莫哥洛夫前向方程，也即化学主方程（CME）所支配。$P(n,t)$ 的变化率由流入和流出状态 $n$ 的概率流平衡给出：\n$$\n\\frac{dP(n,t)}{dt} = (\\text{流入流}) - (\\text{流出流})\n$$\n对于一般状态 $n \\ge 1$，流入状态 $n$ 的概率流来自状态 $n-1$ 的生成（速率为 $k_b$）和状态 $n+1$ 的降解（速率为 $k_d(n+1)$）。流出状态 $n$ 的概率流通过生成流向状态 $n+1$（速率为 $k_b$），通过降解流向状态 $n-1$（速率为 $k_d n$）。因此，对于 $n \\ge 1$：\n$$\n\\frac{dP(n,t)}{dt} = k_b P(n-1,t) + k_d(n+1)P(n+1,t) - (k_b + k_d n)P(n,t)\n$$\n对于边界情况 $n=0$，状态 $n-1$ 是不可能的。流入状态 0 的概率流只能通过状态 1 的降解发生。流出状态 0 的概率流只能通过生成流向状态 1。因此：\n$$\n\\frac{dP(0,t)}{dt} = k_d P(1,t) - k_b P(0,t)\n$$\n问题要求解稳态概率质量函数 $P(n)$，它是 $P(n,t)$ 在 $t \\to \\infty$ 时的极限。在稳态下，对所有 $n$ 都有 $\\frac{dP(n,t)}{dt} = 0$。令 $P(n)$ 表示稳态概率 $P(n, \\infty)$。方程组变为：\n对于 $n \\ge 1$：\n$$\n0 = k_b P(n-1) + k_d(n+1)P(n+1) - (k_b + k_d n)P(n) \\quad (*_1)\n$$\n对于 $n=0$：\n$$\n0 = k_d P(1) - k_b P(0) \\quad (*_2)\n$$\n这是一个生灭过程，其稳态条件意味着任意两个相邻状态之间的净概率流必须为零。这个条件被称为细致平衡。从状态 $n$ 到 $n+1$ 的流是由于生成（$k_b P(n)$），而从状态 $n+1$ 到 $n$ 的流是由于降解（$k_d(n+1)P(n+1)$）。细致平衡条件是：\n$$\nk_b P(n) = k_d(n+1)P(n+1) \\quad \\text{对于 } n \\ge 0\n$$\n这个单一的递推关系等价于无限线性方程组 $(*_1)$ 和 $(*_2)$。例如，对于 $n=0$，它给出 $k_b P(0) = k_d P(1)$，这正是方程 $(*_2)$。将 $k_d(n+1)P(n+1) = k_b P(n)$ 以及通过移动索引得到的 $k_d n P(n) = k_b P(n-1)$ 代入方程 $(*_1)$，我们得到 $0 = k_d n P(n) + k_b P(n) - (k_b + k_d n)P(n) = 0$，从而证实了其有效性。\n\n我们可以求解这个递推关系，用 $P(0)$ 来表示 $P(n)$：\n$$\nP(n+1) = \\frac{k_b}{k_d(n+1)} P(n)\n$$\n我们迭代以找到通式：\n对于 $n=0$：$P(1) = \\frac{k_b}{k_d(1)}P(0)$\n对于 $n=1$：$P(2) = \\frac{k_b}{k_d(2)}P(1) = \\frac{k_b}{k_d(2)}\\frac{k_b}{k_d(1)}P(0) = \\frac{1}{2 \\cdot 1}\\left(\\frac{k_b}{k_d}\\right)^2 P(0)$\n对于 $n=2$：$P(3) = \\frac{k_b}{k_d(3)}P(2) = \\frac{k_b}{k_d(3)} \\frac{1}{2}\\left(\\frac{k_b}{k_d}\\right)^2 P(0) = \\frac{1}{3 \\cdot 2 \\cdot 1}\\left(\\frac{k_b}{k_d}\\right)^3 P(0)$\n通过归纳法，$P(n)$ 的通项表达式为：\n$$\nP(n) = \\frac{1}{n!} \\left(\\frac{k_b}{k_d}\\right)^n P(0)\n$$\n为了求得 $P(0)$，我们使用归一化条件，即所有概率之和必须为 1：\n$$\n\\sum_{n=0}^{\\infty} P(n) = 1\n$$\n代入我们得到的 $P(n)$ 表达式：\n$$\n\\sum_{n=0}^{\\infty} \\frac{1}{n!} \\left(\\frac{k_b}{k_d}\\right)^n P(0) = 1\n$$\n$$\nP(0) \\sum_{n=0}^{\\infty} \\frac{1}{n!} \\left(\\frac{k_b}{k_d}\\right)^n = 1\n$$\n这个和是指数函数的泰勒级数展开式，$\\sum_{k=0}^{\\infty} \\frac{x^k}{k!} = \\exp(x)$。令 $x = k_b/k_d$，我们有：\n$$\nP(0) \\exp\\left(\\frac{k_b}{k_d}\\right) = 1\n$$\n这给出 $P(0) = \\exp\\left(-\\frac{k_b}{k_d}\\right)$。\n将此结果代回 $P(n)$ 的表达式，我们得到稳态概率质量函数的最终封闭形式表达式：\n$$\nP(n) = \\frac{1}{n!} \\left(\\frac{k_b}{k_d}\\right)^n \\exp\\left(-\\frac{k_b}{k_d}\\right)\n$$\n这是参数为 $\\lambda = \\frac{k_b}{k_d}$ 的泊松分布的概率质量函数。参数为 $\\lambda$ 的泊松分布随机变量的均值为 $\\lambda$。因此，稳态下的平均拷贝数是：\n$$\n\\langle n \\rangle = \\frac{k_b}{k_d}\n$$\n接下来，我们分析其确定性对应模型。拷贝数 $n$ 的确定性速率方程由下式给出：\n$$\n\\frac{dn}{dt} = k_b - k_d n\n$$\n通过将时间导数设为零，可以找到确定性稳态 $n_{ss}$：\n$$\n0 = k_b - k_d n_{ss}\n$$\n求解 $n_{ss}$ 得：\n$$\nn_{ss} = \\frac{k_b}{k_d}\n$$\n通过比较，我们发现稳态随机分布的均值 $\\langle n \\rangle$ 与确定性速率方程的稳态解 $n_{ss}$ 完全相等。这种完美的一致性是仅包含零级和一级反应（即线性倾向性）的系统的特有属性。确定性模型可以看作是忽略了涨落的近似，在这种情况下，它正确地预测了完整随机系统的平均行为。对于涉及更高级数反应（非线性倾向性）的系统，这个等式通常不成立，随机模型的均值会偏离确定性模型的预测值。",
            "answer": "$$\n\\boxed{\\frac{1}{n!} \\left( \\frac{k_b}{k_d} \\right)^{n} \\exp\\left(-\\frac{k_b}{k_d}\\right)}\n$$"
        },
        {
            "introduction": "在理解了系统的最终稳态之后，我们自然会问：系统是如何随时间演化至此的？这个练习将引导你直接比较确定性模型和随机模型的动态行为。你将分别为同一个化学反应系统推导并求解浓度随时间变化的常微分方程 (Ordinary Differential Equation, ODE) 以及分子数均值和方差的动力学方程。通过这项实践，你能够清晰地看到两种范式之间的联系与区别，特别是理解到，虽然随机模型的平均行为可能与确定性模型一致，但它额外提供了关于系统波动（即噪声）的关键信息。",
            "id": "3300946",
            "problem": "考虑一个在固定体积内的充分混合的等温反应体系，其中物种 $A$ 通过与由恒化器维持浓度的物种 $B$ 相互作用而被合成和移除。该反应网络包含以下反应：\n\n1. 零级合成：$\\varnothing \\rightarrow A$，速率常数为 $k_0$，单位为 $\\mathrm{mol}\\,\\mathrm{L}^{-1}\\,\\mathrm{s}^{-1}$。\n2. $B$催化移除：$A + B \\rightarrow B$，质量作用速率常数为 $k_1$，单位为 $\\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1}$。\n3. 一级降解：$A \\rightarrow \\varnothing$，速率常数为 $k_2$，单位为 $\\mathrm{s}^{-1}$。\n\n假设 $[B](t)$ 由恒化器在所有时间内维持恒定，即 $[B](t) = [B](0)$，并专注于 $k_2 = 0$ 的特殊情况。使用质量作用定律和标准的确定性化学动力学，推导浓度轨迹 $[A](t)$ 的常微分方程，并在 $[B](t)$ 恒定的假设下，针对 $k_2 = 0$ 的情况解析求解该方程。然后，对于基于化学主方程（CME）的随机性描述，将体积 $V$（单位 L）中 $A$ 的分子数建模为连续时间生灭过程，其出生倾向性为 $\\lambda = k_0 V N_\\mathrm{A}$，死亡倾向性为 $\\mu n$，其中 $\\mu = k_1 [B](0)$，$n$ 是 $A$ 的分子数，$N_\\mathrm{A} = 6.02214076 \\times 10^{23}\\,\\mathrm{mol}^{-1}$ 是阿伏伽德罗常数。推导该过程的均值 $E[n(t)]$ 和方差 $\\mathrm{Var}[n(t)]$，用 $\\lambda$、$\\mu$ 和初始分子数 $n(0)$ 表示，并假设初始分子数是精确已知的（初始方差为零）。\n\n对于以下每个测试案例，需计算并给出在指定评估时间 $T$ 时的三个值：确定性浓度 $[A](T)$（单位为 $\\mathrm{mol}\\,\\mathrm{L}^{-1}$）、随机性平均分子数 $E[n(T)]$ 和随机性方差 $\\mathrm{Var}[n(T)]$。所有数值结果应四舍五入到六位小数。\n\n测试套件（每个案例提供 $(V, k_0, k_1, [B](0), [A](0), n(0), T)$）：\n\n案例 1（常规“顺利”路径）：\n- $V = 1.0 \\times 10^{-15}\\,\\mathrm{L}$\n- $k_0 = 2.0 \\times 10^{-8}\\,\\mathrm{mol}\\,\\mathrm{L}^{-1}\\,\\mathrm{s}^{-1}$\n- $k_1 = 1.0 \\times 10^{6}\\,\\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1}$\n- $[B](0) = 5.0 \\times 10^{-7}\\,\\mathrm{mol}\\,\\mathrm{L}^{-1}$\n- $[A](0) = 1.0 \\times 10^{-7}\\,\\mathrm{mol}\\,\\mathrm{L}^{-1}$\n- $n(0) = 60$（一个一致的、固定的整数初始化）\n- $T = 10.0\\,\\mathrm{s}$\n\n案例 2（边界条件，$[B](0) = 0$，无移除）：\n- $V = 1.0 \\times 10^{-15}\\,\\mathrm{L}$\n- $k_0 = 1.0 \\times 10^{-9}\\,\\mathrm{mol}\\,\\mathrm{L}^{-1}\\,\\mathrm{s}^{-1}$\n- $k_1 = 5.0 \\times 10^{5}\\,\\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1}$\n- $[B](0) = 0.0\\,\\mathrm{mol}\\,\\mathrm{L}^{-1}$\n- $[A](0) = 0.0\\,\\mathrm{mol}\\,\\mathrm{L}^{-1}$\n- $n(0) = 0$\n- $T = 100.0\\,\\mathrm{s}$\n\n案例 3（$[B](0)$ 较大时的快速弛豫）：\n- $V = 1.0 \\times 10^{-15}\\,\\mathrm{L}$\n- $k_0 = 5.0 \\times 10^{-9}\\,\\mathrm{mol}\\,\\mathrm{L}^{-1}\\,\\mathrm{s}^{-1}$\n- $k_1 = 2.0 \\times 10^{7}\\,\\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1}$\n- $[B](0) = 1.0 \\times 10^{-6}\\,\\mathrm{mol}\\,\\mathrm{L}^{-1}$\n- $[A](0) = 3.0 \\times 10^{-7}\\,\\mathrm{mol}\\,\\mathrm{L}^{-1}$\n- $n(0) = 181$\n- $T = 0.1\\,\\mathrm{s}$\n\n最终答案应格式化为单个列表，形式为 $[a_1,m_1,v_1,a_2,m_2,v_2,a_3,m_3,v_3]$，其中 $a_i$ 是 $[A](T)$，$m_i$ 是 $E[n(T)]$，$v_i$ 是 $\\mathrm{Var}[n(T)]$。",
            "solution": "用户要求我解决一个计算系统生物学的问题。\n\n这是我的计划：\n1.  **我必须首先验证问题陈述。** 我将遵循概述的严格协议。\n    *   **第 1 步：提取已知条件。** 我将逐字列出所有给定的反应、参数、定义和测试案例。\n    *   **第 2 步：验证。** 我将检查问题的科学合理性、适定性、客观性以及所有其他标准。\n        *   这些反应是标准的化学动力学反应：零级合成、二级反应（由于[B]恒定，实际上是一级反应）和一级降解。这是有科学依据的。\n        *   问题要求推导常微分方程和生灭过程的矩方程。这是确定性建模和随机性建模中的一个标准任务。\n        *   提供的参数和单位似乎是一致的。我应该仔细检查单位。\n            *   $k_0$: $\\mathrm{mol}\\,\\mathrm{L}^{-1}\\,\\mathrm{s}^{-1}$。浓度的变化率。正确。\n            *   $k_1$: $\\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1}$。$A+B \\rightarrow B$ 的速率常数。速率定律为 $k_1[A][B]$，单位为 $(\\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1}) (\\mathrm{mol}\\,\\mathrm{L}^{-1}) (\\mathrm{mol}\\,\\mathrm{L}^{-1}) = \\mathrm{mol}\\,\\mathrm{L}^{-1}\\,\\mathrm{s}^{-1}$。正确。\n            *   $k_2$: $\\mathrm{s}^{-1}$。$A \\rightarrow \\varnothing$ 的速率常数。速率定律为 $k_2[A]$，单位为 $(\\mathrm{s}^{-1}) (\\mathrm{mol}\\,\\mathrm{L}^{-1}) = \\mathrm{mol}\\,\\mathrm{L}^{-1}\\,\\mathrm{s}^{-1}$。正确。\n        *   问题定义了随机模型的倾向性：\n            *   出生倾向性 $\\lambda = k_0 V N_\\mathrm{A}$。我们来检查单位。$k_0$ 的单位是 $\\mathrm{mol}\\,\\mathrm{L}^{-1}\\,\\mathrm{s}^{-1}$。$V$ 的单位是 $\\mathrm{L}$。$N_\\mathrm{A}$ 的单位是 $\\mathrm{mol}^{-1}$。所以 $\\lambda$ 的单位是 $(\\mathrm{mol}\\,\\mathrm{L}^{-1}\\,\\mathrm{s}^{-1}) (\\mathrm{L}) (\\mathrm{mol}^{-1}) = \\mathrm{s}^{-1}$。这是零级反应倾向性的单位，表示单位时间内的事件数。这是正确的。\n            *   死亡倾向性 $\\mu n$。其中 $\\mu = k_1 [B](0)$。我们来检查单位。$k_1$ 的单位是 $\\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1}$。$[B](0)$ 的单位是 $\\mathrm{mol}\\,\\mathrm{L}^{-1}$。所以 $\\mu$ 的单位是 $(\\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1}) (\\mathrm{mol}\\,\\mathrm{L}^{-1}) = \\mathrm{s}^{-1}$。这是一级过程的速率常数单位。倾向性是 $\\mu n$，这对于一级反应是标准的，其中 $n$ 是分子数。这也是正确的。\n        *   问题陈述要求专注于 $k_2=0$ 的特殊情况。这是一个有效的简化。\n        *   测试案例提供了所有必要的参数。\n            *   确定性模型和随机性模型的初始条件 $[A](0)$ 和 $n(0)$ 分别给出。我应该检查它们是否一致。$n(0) = [A](0) \\times V \\times N_\\mathrm{A}$。\n                *   案例 1：$1.0 \\times 10^{-7}\\,\\mathrm{mol}\\,\\mathrm{L}^{-1} \\times 1.0 \\times 10^{-15}\\,\\mathrm{L} \\times 6.02214076 \\times 10^{23}\\,\\mathrm{mol}^{-1} = 60.2214...$。问题给出 $n(0) = 60$。这有一个轻微的差异，但被明确说明为“一个一致的、固定的整数初始化”。这意味着我们应该对随机部分使用 $n(0)=60$，而不是从 $[A](0)$ 计算出的值。这是问题陈述中为使用整数分子数而作出的刻意选择，这在物理上是现实的。这并不会使问题无效，只是为两个模型指定了不同的初始条件。这在比较确定性模拟和随机性模拟时很常见。\n                *   案例 2：$[A](0) = 0.0 \\implies n(0)$ 应该是 $0$。问题给出 $n(0) = 0$。这是一致的。\n                *   案例 3：$3.0 \\times 10^{-7}\\,\\mathrm{mol}\\,\\mathrm{L}^{-1} \\times 1.0 \\times 10^{-15}\\,\\mathrm{L} \\times 6.02214076 \\times 10^{23}\\,\\mathrm{mol}^{-1} = 180.664...$。问题给出 $n(0) = 181$。同样，是一个刻意的整数初始化。\n        *   问题的结构清晰。它是适定的和客观的。\n    *   **第 3 步：结论与行动。** 问题看起来完全有效。这是一个来自化学动力学和随机过程的标准问题，定义明确且科学上合理。我将继续进行解答。\n\n2.  **推导确定性解。**\n    *   反应是：\n        1.  $\\varnothing \\stackrel{k_0}{\\longrightarrow} A$\n        2.  $A + B \\stackrel{k_1}{\\longrightarrow} B$\n        3.  $A \\stackrel{k_2}{\\longrightarrow} \\varnothing$\n    *   根据质量作用定律，A 的浓度 $[A]$ 的速率定律为：\n        $$ \\frac{d[A]}{dt} = (\\text{生成速率}) - (\\text{消耗速率}) $$\n        $$ \\frac{d[A]}{dt} = k_0 - k_1[A][B] - k_2[A] $$\n    *   问题陈述指出 $[B](t) = [B](0)$（常数），我们必须考虑 $k_2=0$ 的情况。\n    *   因此，常微分方程简化为：\n        $$ \\frac{d[A]}{dt} = k_0 - k_1[B](0)[A] $$\n    *   我们定义一个常数 $\\mu' = k_1[B](0)$。$\\mu'$ 的单位是 $(\\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1})(\\mathrm{mol}\\,\\mathrm{L}^{-1}) = \\mathrm{s}^{-1}$。\n    *   常微分方程为：\n        $$ \\frac{d[A]}{dt} = k_0 - \\mu' [A] $$\n    *   这是一个一阶线性常微分方程。我们可以通过分离变量来求解。\n    *   分离变量：\n        $$ \\frac{d[A]}{k_0 - \\mu' [A]} = dt $$\n    *   从初始状态 $([A](0), 0)$ 到 $([A](t), t)$ 对两边进行积分：\n        $$ \\int_{[A](0)}^{[A](t)} \\frac{d[A]'}{k_0 - \\mu' [A]'} = \\int_0^t dt' $$\n        假设 $\\mu' \\neq 0$：\n        $$ \\left[ -\\frac{1}{\\mu'} \\ln|k_0 - \\mu' [A]'| \\right]_{[A](0)}^{[A](t)} = t $$\n        $$ \\ln\\left(\\frac{k_0 - \\mu' [A](t)}{k_0 - \\mu' [A](0)}\\right) = -\\mu' t $$\n        $$ k_0 - \\mu' [A](t) = (k_0 - \\mu' [A](0)) e^{-\\mu' t} $$\n        $$ \\mu' [A](t) = k_0 - (k_0 - \\mu' [A](0)) e^{-\\mu' t} $$\n        $$ [A](t) = \\frac{k_0}{\\mu'} - \\left(\\frac{k_0}{\\mu'} - [A](0)\\right) e^{-\\mu' t} $$\n    *   稳态浓度为 $[A]_{ss} = k_0 / \\mu'$。解可以写成：\n        $$ [A](t) = [A]_{ss} + ([A](0) - [A]_{ss}) e^{-\\mu' t} $$\n        其中 $\\mu' = k_1 [B](0)$。\n    *   特殊情况：如果 $\\mu' = 0$（当 $[B](0) = 0$ 时发生），常微分方程变为：\n        $$ \\frac{d[A]}{dt} = k_0 $$\n    *   用初始条件 $[A](0)$ 积分得到：\n        $$ [A](t) = [A](0) + k_0 t $$\n\n3.  **推导随机均值和方差。**\n    *   该系统被建模为物种 A 分子数 $n$ 的线性生灭过程。\n    *   出生反应：$\\varnothing \\rightarrow A$。倾向性是常数：$a_1 = \\lambda = k_0 V N_\\mathrm{A}$。\n    *   死亡反应：$A \\rightarrow \\varnothing$。倾向性是 $n$ 的线性函数：$a_2(n) = \\mu n$，其中 $\\mu = k_1 [B](0)$。注意 $\\mu'=\\mu$ 的一致性。\n    *   均值 $\\langle n(t) \\rangle = E[n(t)]$ 的时间演化由以下常微分方程控制：\n        $$ \\frac{d\\langle n \\rangle}{dt} = \\sum_{j} \\langle a_j(n) v_j \\rangle = \\langle \\lambda \\cdot (+1) \\rangle + \\langle \\mu n \\cdot (-1) \\rangle = \\lambda - \\mu \\langle n \\rangle $$\n    *   这是一个关于 $\\langle n \\rangle$ 的一阶线性常微分方程。假设 $\\mu \\neq 0$，其解（初始条件为 $n(0)$）在形式上与确定性情况相同：\n        $$ \\langle n(t) \\rangle = \\frac{\\lambda}{\\mu} + \\left(n(0) - \\frac{\\lambda}{\\mu}\\right)e^{-\\mu t} $$\n    *   如果 $\\mu = 0$，常微分方程为 $\\frac{d\\langle n \\rangle}{dt} = \\lambda$。解为：\n        $$ \\langle n(t) \\rangle = n(0) + \\lambda t $$\n    *   为了求方差 $\\mathrm{Var}[n(t)] = V(t) = \\langle n^2 \\rangle - \\langle n \\rangle^2$，我们首先推导二阶矩 $\\langle n^2 \\rangle$ 的常微分方程：\n        $$ \\frac{d\\langle n^2 \\rangle}{dt} = \\sum_{j} \\langle a_j(n) ((n+v_j)^2 - n^2) \\rangle $$\n        $$ \\frac{d\\langle n^2 \\rangle}{dt} = \\langle \\lambda((n+1)^2 - n^2) \\rangle + \\langle \\mu n((n-1)^2 - n^2) \\rangle $$\n        $$ \\frac{d\\langle n^2 \\rangle}{dt} = \\langle \\lambda(2n+1) \\rangle + \\langle \\mu n(-2n+1) \\rangle $$\n        $$ \\frac{d\\langle n^2 \\rangle}{dt} = \\lambda(2\\langle n \\rangle+1) + \\mu(-2\\langle n^2 \\rangle+\\langle n \\rangle) = -2\\mu\\langle n^2 \\rangle + (2\\lambda+\\mu)\\langle n \\rangle + \\lambda $$\n    *   现在，我们推导方差 $V(t)$ 的常微分方程：\n        $$ \\frac{dV}{dt} = \\frac{d\\langle n^2 \\rangle}{dt} - \\frac{d\\langle n \\rangle^2}{dt} = \\frac{d\\langle n^2 \\rangle}{dt} - 2\\langle n \\rangle \\frac{d\\langle n \\rangle}{dt} $$\n        $$ \\frac{dV}{dt} = [-2\\mu\\langle n^2 \\rangle + (2\\lambda+\\mu)\\langle n \\rangle + \\lambda] - 2\\langle n \\rangle(\\lambda - \\mu \\langle n \\rangle) $$\n        $$ \\frac{dV}{dt} = -2\\mu\\langle n^2 \\rangle + 2\\lambda\\langle n \\rangle + \\mu\\langle n \\rangle + \\lambda - 2\\lambda\\langle n \\rangle + 2\\mu\\langle n \\rangle^2 $$\n        $$ \\frac{dV}{dt} = -2\\mu(\\langle n^2 \\rangle - \\langle n \\rangle^2) + \\mu\\langle n \\rangle + \\lambda $$\n        $$ \\frac{dV}{dt} = -2\\mu V(t) + \\mu\\langle n(t) \\rangle + \\lambda $$\n    *   这是一个关于 $V(t)$ 的一阶线性常微分方程。我们使用积分因子 $e^{2\\mu t}$ 求解，初始条件为 $V(0)=0$（因为 $n(0)$ 是已知整数）。\n        $$ V(t) = e^{-2\\mu t} \\int_0^t e^{2\\mu s} (\\mu\\langle n(s) \\rangle + \\lambda) ds $$\n    *   代入 $\\langle n(s) \\rangle = \\frac{\\lambda}{\\mu} + (n(0) - \\frac{\\lambda}{\\mu})e^{-\\mu s}$：\n        $$ \\mu\\langle n(s) \\rangle + \\lambda = \\mu\\left(\\frac{\\lambda}{\\mu} + \\left(n(0) - \\frac{\\lambda}{\\mu}\\right)e^{-\\mu s}\\right) + \\lambda = 2\\lambda + \\mu\\left(n(0) - \\frac{\\lambda}{\\mu}\\right)e^{-\\mu s} $$\n    *   积分变为：\n        $$ \\int_0^t e^{2\\mu s} \\left( 2\\lambda + \\mu\\left(n(0) - \\frac{\\lambda}{\\mu}\\right)e^{-\\mu s} \\right) ds $$\n        $$ = \\int_0^t 2\\lambda e^{2\\mu s} ds + \\int_0^t \\mu\\left(n(0) - \\frac{\\lambda}{\\mu}\\right) e^{\\mu s} ds $$\n        $$ = 2\\lambda \\left[\\frac{e^{2\\mu s}}{2\\mu}\\right]_0^t + \\mu\\left(n(0) - \\frac{\\lambda}{\\mu}\\right) \\left[\\frac{e^{\\mu s}}{\\mu}\\right]_0^t $$\n        $$ = \\frac{\\lambda}{\\mu}(e^{2\\mu t} - 1) + \\left(n(0) - \\frac{\\lambda}{\\mu}\\right)(e^{\\mu t} - 1) $$\n    *   乘以 $e^{-2\\mu t}$：\n        $$ V(t) = \\frac{\\lambda}{\\mu}(1 - e^{-2\\mu t}) + \\left(n(0) - \\frac{\\lambda}{\\mu}\\right)(e^{-\\mu t} - e^{-2\\mu t}) $$\n    *   特殊情况：如果 $\\mu = 0$，方差的常微分方程变为 $\\frac{dV}{dt} = \\lambda$。在 $V(0)=0$ 的条件下，解为：\n        $$ V(t) = \\lambda t $$\n\n4.  **数值计算策略**\n    对于每个测试案例，我们提取参数 $(V, k_0, k_1, [B](0), [A](0), n(0), T)$。我们还使用常数 $N_\\mathrm{A} = 6.02214076 \\times 10^{23}\\,\\mathrm{mol}^{-1}$。\n    首先，计算确定性模型和随机性模型的复合参数：\n    - 确定性衰减率：$\\mu' = k_1 [B](0)$。\n    - 随机性出生率（倾向性）：$\\lambda = k_0 V N_\\mathrm{A}$。\n    - 随机性死亡速率常数：$\\mu = k_1 [B](0)$。\n    我们检查 $\\mu = 0$ 是否成立。\n    如果 $\\mu  0$：\n    - $[A](T) = (k_0/\\mu') + ([A](0) - k_0/\\mu') e^{-\\mu' T}$\n    - $E[n(T)] = (\\lambda/\\mu) + (n(0) - \\lambda/\\mu) e^{-\\mu T}$\n    - $\\mathrm{Var}[n(T)] = (\\lambda/\\mu)(1 - e^{-2\\mu T}) + (n(0) - \\lambda/\\mu)(e^{-\\mu T} - e^{-2\\mu T})$\n    如果 $\\mu = 0$：\n    - $[A](T) = [A](0) + k_0 T$\n    - $E[n(T)] = n(0) + \\lambda T$\n    - $\\mathrm{Var}[n(T)] = \\lambda T$\n\n    然后使用这些公式计算每个案例的结果，并格式化为六位小数。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the deterministic concentration, and stochastic mean and variance\n    for a chemical reaction system under three different test cases.\n    \"\"\"\n    \n    # Avogadro's constant\n    NA = 6.02214076e23  # mol^-1\n\n    # Test suite: (V, k0, k1, B0, A0, n0, T)\n    test_cases = [\n        # Case 1 (general \"happy path\")\n        {\n            \"V\": 1.0e-15,      # L\n            \"k0\": 2.0e-8,      # mol L^-1 s^-1\n            \"k1\": 1.0e6,       # L mol^-1 s^-1\n            \"B0\": 5.0e-7,      # mol L^-1\n            \"A0\": 1.0e-7,      # mol L^-1\n            \"n0\": 60,          # dimensionless\n            \"T\": 10.0          # s\n        },\n        # Case 2 (boundary condition with B0 = 0)\n        {\n            \"V\": 1.0e-15,\n            \"k0\": 1.0e-9,\n            \"k1\": 5.0e5,\n            \"B0\": 0.0,\n            \"A0\": 0.0,\n            \"n0\": 0,\n            \"T\": 100.0\n        },\n        # Case 3 (fast relaxation with large B0)\n        {\n            \"V\": 1.0e-15,\n            \"k0\": 5.0e-9,\n            \"k1\": 2.0e7,\n            \"B0\": 1.0e-6,\n            \"A0\": 3.0e-7,\n            \"n0\": 181,\n            \"T\": 0.1\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        V = case[\"V\"]\n        k0 = case[\"k0\"]\n        k1 = case[\"k1\"]\n        B0 = case[\"B0\"]\n        A0 = case[\"A0\"]\n        n0 = case[\"n0\"]\n        T = case[\"T\"]\n        \n        # Calculate composite parameters\n        mu = k1 * B0          # s^-1 (for both models)\n        lambd = k0 * V * NA   # s^-1 (stochastic birth rate)\n\n        # Initialize results for the current case\n        det_A_T = 0.0\n        stoch_mean_T = 0.0\n        stoch_var_T = 0.0\n\n        if mu > 0:\n            # Deterministic solution\n            A_ss = k0 / mu\n            det_A_T = A_ss + (A0 - A_ss) * np.exp(-mu * T)\n            \n            # Stochastic mean\n            n_ss = lambd / mu\n            stoch_mean_T = n_ss + (n0 - n_ss) * np.exp(-mu * T)\n            \n            # Stochastic variance\n            term1 = n_ss * (1 - np.exp(-2 * mu * T))\n            term2 = (n0 - n_ss) * (np.exp(-mu * T) - np.exp(-2 * mu * T))\n            stoch_var_T = term1 + term2\n        else: # mu == 0 case\n            # Deterministic solution\n            det_A_T = A0 + k0 * T\n            \n            # Stochastic mean\n            stoch_mean_T = n0 + lambd * T\n            \n            # Stochastic variance\n            stoch_var_T = lambd * T\n            \n        results.extend([det_A_T, stoch_mean_T, stoch_var_T])\n\n    # Format output to six decimal places as required\n    formatted_results = [f'{val:.6f}' for val in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "掌握了线性系统的基础后，我们将挑战一个更复杂且在生物学上意义重大的非线性系统——基因拨动开关 (toggle switch)，它是合成生物学中的一个标志性设计。确定性模型会预测该系统具有两个稳定状态（双稳态），但无法描述系统如何在噪声驱动下在两个状态之间切换。这项高级实践将要求你使用随机模拟算法 (Stochastic Simulation Algorithm, SSA) 和前向通量采样 (Forward Flux Sampling, FFS) 等计算方法来量化这种稀有事件的速率。这个练习将淋漓尽致地展现随机建模的威力，它能够揭示和量化确定性模型无法触及的关键生物学过程，例如细胞命运决定等。",
            "id": "3300870",
            "problem": "考虑一个在蛋白质层面建模的互抑制基因开关网络，其中包含两个物种 $X$ 和 $Y$，其在系统状态中的拷贝数由 $(x,y)\\in\\mathbb{N}_0^2$ 给出。$X$ 的生成受到 $Y$ 的抑制，$Y$ 的生成受到 $X$ 的抑制。其随机动力学由化学主方程 (CME) 控制，该方程将系统建模为非负整数对格点上的一个连续时间马尔可夫链，其反应和倾向性函数规定如下。反应包括：(1) $X$ 的生成，化学计量变化为 $(+1,0)$；(2) $X$ 的降解，化学计量变化为 $(-1,0)$；(3) $Y$ 的生成，化学计量变化为 $(0,+1)$；以及 (4) $Y$ 的降解，化学计量变化为 $(0,-1)$。相应的倾向性函数为 $a_1(x,y)=\\alpha_X/(1+(y/K)^n)$、$a_2(x,y)=\\delta_X x$、$a_3(x,y)=\\alpha_Y/(1+(x/K)^n)$ 和 $a_4(x,y)=\\delta_Y y$，其中 $\\alpha_X$ 和 $\\alpha_Y$ 是最大生成速率 (单位为 $\\text{molecules}\\cdot\\text{min}^{-1}$)，$K$ 是抑制阈值 (单位为 $\\text{molecules}$)，$n$ 是 Hill 系数，$\\delta_X$ 和 $\\delta_Y$ 是一阶降解速率 (单位为 $\\text{min}^{-1}$)。CME 的无穷小生成元 $\\mathcal{L}$ 作用于函数 $f:\\mathbb{N}_0^2\\to\\mathbb{R}$ 的方式如下\n$$\n(\\mathcal{L}f)(x,y)=\\sum_{j=1}^4 a_j(x,y)\\left[f\\big((x,y)+\\nu_j\\big)-f(x,y)\\right],\n$$\n其中 $\\nu_1=(1,0)$, $\\nu_2=(-1,0)$, $\\nu_3=(0,1)$, 和 $\\nu_4=(0,-1)$。\n\n在确定性极限（平均场）下，期望浓度满足常微分方程 $dx/dt=\\alpha_X/(1+(y/K)^n)-\\delta_X x$ 和 $dy/dt=\\alpha_Y/(1+(x/K)^n)-\\delta_Y y$。对于合适的参数值，该系统表现出双稳态，具有两个吸引盆，分别对应高 $Y$ 低 $X$（记该盆为 $A$）和高 $X$ 低 $Y$（记该盆为 $B$）。随机性会引发从 $A$ 到 $B$ 的稀有转换事件。\n\n你的任务是根据上述内容建立 CME 状态表示，并实现一个稀有事件模拟策略，使用前向通量采样 (FFS) 来估计从吸引盆 $A$ 到吸引盆 $B$ 的转换速率 $k_{A\\to B}$ (单位为 $\\text{min}^{-1}$)。使用标量序参量 $\\phi(x,y)=x-y$，并在状态空间中定义以下区域和界面：吸引盆 $A$ 为 $\\{\\phi\\le \\phi_A\\}$，吸引盆 $B$ 为 $\\{\\phi\\ge \\phi_B\\}$，以及一系列中间界面 $\\lambda_0, \\lambda_1, \\dots, \\lambda_{m-1}$，其中界面满足 $\\phi_A  \\lambda_0  \\lambda_1  \\dots  \\lambda_{m-1}  \\phi_B$。\n\n前向通量采样通过以下乘积来估计速率 $k_{A\\to B}$：\n$$\nk_{A\\to B}=\\Phi_A \\times \\prod_{k=0}^{m-1} P(\\lambda_{k+1}\\mid \\lambda_k),\n$$\n其中 $\\Phi_A$ 是源于 $A$ 并穿过 $\\lambda_0$ 的轨迹通量，$P(\\lambda_{k+1}\\mid\\lambda_k)$ 是指轨迹位于 $\\lambda_k$ 时，在返回 $A$ 之前到达界面 $\\lambda_{k+1}$ 的条件概率。在实现层面：\n- 通过随机模拟算法（SSA；也称为 Gillespie 算法）模拟随机动力学来估计 $\\Phi_A$。模拟从 $A$ 盆深处的一个初始状态开始，累积在 $A$ 中花费的总时间，并计算直接从 $A$ 穿越 $\\lambda_0$ 的次数。将穿越次数除以在 $A$ 中花费的总时间，计算出 $\\Phi_A$。\n- 对于每个阶段 $k$，从在 $\\lambda_k$ 保存的一组穿越状态开始，启动固定数量的 SSA 试探轨迹。这些轨迹在返回 $A$ 或到达下一个界面（在最后阶段则为 $B$）时终止。将成功的试探轨迹所占的比例作为 $P(\\lambda_{k+1}\\mid\\lambda_k)$ 的估计值。",
            "solution": "该问题要求为一个基因开关的随机模型估计稀有事件转换速率 $k_{A\\to B}$。该估计将使用前向通量采样 (FFS) 算法进行。解决方案首先详细介绍数学模型和模拟原理，然后对 FFS 的实现进行算法描述。\n\n**1. 系统模型与动力学**\n\n该系统由两种相互抑制的蛋白质物种 $X$ 和 $Y$ 组成。系统的状态由这些蛋白质的整数值拷贝数 $(x,y) \\in \\mathbb{N}_0^2$ 给出。系统的随机演化被建模为一个连续时间马尔可夫链，由化学主方程 (CME) 控制。其动力学由四个基本反应定义：每个物种的生成和降解。\n\n反应及其对应的状态转换向量 $\\nu_j$ 如下：\n1. $X$ 的生成：$\\nu_1 = (+1, 0)$\n2. $X$ 的降解：$\\nu_2 = (-1, 0)$\n3. $Y$ 的生成：$\\nu_3 = (0, +1)$\n4. $Y$ 的降解：$\\nu_4 = (0, -1)$\n\n每个反应的速率由其倾向性函数 $a_j(x,y)$ 决定：\n1. $a_1(x,y) = \\frac{\\alpha_X}{1 + (y/K)^n}$ ($X$ 的生成，受 $Y$ 抑制)\n2. $a_2(x,y) = \\delta_X x$ ($X$ 的一阶降解)\n3. $a_3(x,y) = \\frac{\\alpha_Y}{1 + (x/K)^n}$ ($Y$ 的生成，受 $X$ 抑制)\n4. $a_4(x,y) = \\delta_Y y$ ($Y$ 的一阶降解)\n\n此处，$\\alpha_X$ 和 $\\alpha_Y$ 是最大生成速率，$\\delta_X$ 和 $\\delta_Y$ 是降解速率常数，$K$ 是抑制阈值，$n$ 是控制抑制陡峭程度的 Hill 系数。\n\n**2. 随机模拟算法 (SSA)**\n\n为了生成该随机系统的动力学精确轨迹，我们采用 Gillespie 随机模拟算法 (SSA)。SSA 是一个模拟每个反应事件的蒙特卡洛过程。对于在时间 $t$ 处于状态 $(x,y)$ 的系统，单个 SSA 步骤包括：\n1. 计算所有倾向性函数 $a_j(x,y)$，其中 $j \\in \\{1,2,3,4\\}$。\n2. 计算总倾向性 $a_{\\text{tot}}(x,y) = \\sum_{j=1}^4 a_j(x,y)$。\n3. 从速率为 $a_{\\text{tot}}$ 的指数分布中抽样，生成到下一次反应发生的时间间隔 $\\Delta t$：$\\Delta t = \\frac{1}{a_{\\text{tot}}} \\ln(\\frac{1}{r_1})$，其中 $r_1$ 是在 $(0,1]$ 内均匀分布的随机数。\n4. 确定发生哪个反应。第 $j$ 个反应被选择的概率为 $a_j/a_{\\text{tot}}$。这通过抽取第二个在 $(0,1]$ 内均匀分布的随机数 $r_2$ 并找到满足 $\\sum_{k=1}^j a_k(x,y) \\ge r_2 a_{\\text{tot}}(x,y)$ 的最小整数 $j$ 来实现。\n5. 更新系统状态和时间：$(x,y) \\to (x,y) + \\nu_j$ 和 $t \\to t + \\Delta t$。\n\n**3. 用于稀有事件速率估计的前向通量采样 (FFS)**\n\n从高 $Y$/低 $X$ 盆 ($A$) 到高 $X$/低 $Y$ 盆 ($B$) 的转换是一个稀有事件。FFS 是一种通过将转换分解为一系列更可能发生的子事件来有效估计速率 $k_{A \\to B}$ 的方法。这是通过在状态空间中定义一系列介于吸引盆 $A$ 和 $B$ 之间的不相交界面来实现的。\n\n使用序参量 $\\phi(x,y) = x-y$ 来区分吸引盆并定义界面。吸引盆 $A$ 定义为 $\\phi \\le \\phi_A$ 的状态集合，吸引盆 $B$ 定义为 $\\phi \\ge \\phi_B$ 的状态集合。在两个吸引盆之间放置一组 $m$ 个界面 $\\lambda_0, \\lambda_1, \\ldots, \\lambda_{m-1}$，使得 $\\phi_A  \\lambda_0  \\lambda_1  \\cdots  \\lambda_{m-1}  \\phi_B$。\n\nFFS 算法将速率 $k_{A\\to B}$ 估计为离开吸引盆 $A$ 并穿过第一个界面 $\\lambda_0$ 的轨迹通量，与一系列到达下一个界面的条件概率的乘积：\n$$\nk_{A\\to B} = \\Phi_A \\times P(\\lambda_1 \\mid \\lambda_0) \\times P(\\lambda_2 \\mid \\lambda_1) \\times \\cdots \\times P(\\phi_B \\mid \\lambda_{m-1}) = \\Phi_A \\prod_{k=0}^{m-1} P(\\lambda_{k+1} \\mid \\lambda_k)\n$$\n其中 $\\lambda_m$ 被视为吸引盆 $B$ 的边界 $\\phi_B$。\n\n实现分为两个主要阶段：\n\n**阶段 1：通量估计 $(\\Phi_A)$**\n在吸引盆 $A$ 深处的一个状态启动 SSA 模拟。模拟运行很长一段时间，在此期间累积系统在吸引盆 $A$ 中花费的总时间，记为 $T_A^{sim}$。我们计算轨迹从 $\\phi \\le \\phi_A$ 的状态穿过到 $\\phi > \\lambda_0$ 的状态的次数 $N_c$。然后将通量估计为 $\\Phi_A = N_c / T_A^{sim}$。在此阶段，会收集并保存 $N_0$ 个刚穿过 $\\lambda_0$ 后的唯一状态，以用于初始化算法的下一阶段。\n\n**阶段 2：条件概率估计 $(P(\\lambda_{k+1} \\mid \\lambda_k))$**\n此阶段是迭代的。对于每个界面 $\\lambda_k$ (其中 $k=0, \\ldots, m-1$)：\n1. 启动一组 $M$ 次试探轨迹。这些试探的起始状态通过从在界面 $\\lambda_k$ 保存的构型集合中（有放回地）抽样来选择。\n2. 每个 SSA 试探轨迹被模拟，直到它因返回吸引盆 $A$（状态满足 $\\phi \\le \\phi_A$，计为失败）或到达下一个界面 $\\lambda_{k+1}$（状态满足 $\\phi \\ge \\lambda_{k+1}$，计为成功）而终止。\n3. 条件概率 $P(\\lambda_{k+1} \\mid \\lambda_k)$ 被估计为成功试探的比例：$N_{\\text{success}} / M$。\n4. 收集成功轨迹在穿过 $\\lambda_{k+1}$ 时的状态。这个新的状态集合将用作下一个界面 $\\lambda_{k+1}$ 处试探的起始池。\n\n如果在任何阶段没有可用的起始构型（因为前一阶段没有成功的试探），则链条中断，总速率 $k_{A\\to B}$ 为零。最后，通过将通量 $\\Phi_A$ 与所有估计的条件概率相乘来计算总速率。提供的代码为三个测试案例中的每一个都实现了此逻辑。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the Forward Flux Sampling algorithm to estimate the switching rate \n    for a stochastic toggle-switch model for three specified test cases.\n    \"\"\"\n\n    # Set a fixed seed for reproducibility as required by the problem.\n    np.random.seed(42)\n\n    def calculate_propensities(state, params):\n        \"\"\"Calculates the propensities for the four reactions.\"\"\"\n        x, y = state\n        alpha_X, alpha_Y, delta_X, delta_Y, K, n = params['alpha_X'], params['alpha_Y'], params['delta_X'], params['delta_Y'], params['K'], params['n']\n        \n        a1 = alpha_X / (1 + (y / K)**n)  # Production of X\n        a2 = delta_X * x                 # Degradation of X\n        a3 = alpha_Y / (1 + (x / K)**n)  # Production of Y\n        a4 = delta_Y * y                 # Degradation of Y\n        \n        return np.array([a1, a2, a3, a4])\n\n    def ssa_step(state, params):\n        \"\"\"Performs a single step of the Gillespie SSA.\"\"\"\n        propensities = calculate_propensities(state, params)\n        total_propensity = np.sum(propensities)\n        \n        if total_propensity == 0:\n            return state, np.inf\n        \n        # Time to next reaction\n        dt = np.random.exponential(1.0 / total_propensity)\n        \n        # Choose which reaction occurs\n        r = np.random.uniform(0, 1) * total_propensity\n        \n        stoichiometry = np.array([[1, 0], [-1, 0], [0, 1], [0, -1]])\n        \n        if r  propensities[0]:\n            reaction_idx = 0\n        elif r  propensities[0] + propensities[1]:\n            reaction_idx = 1\n        elif r  propensities[0] + propensities[1] + propensities[2]:\n            reaction_idx = 2\n        else:\n            reaction_idx = 3\n            \n        new_state = tuple(np.add(state, stoichiometry[reaction_idx]))\n        \n        return new_state, dt\n\n    def order_parameter(state):\n        \"\"\"Calculates the order parameter phi(x,y) = x - y.\"\"\"\n        return state[0] - state[1]\n\n    def run_ffs_case(case_params):\n        \"\"\"Runs the full Forward Flux Sampling simulation for a single case.\"\"\"\n        \n        # --- Phase 0: Flux Estimation (Phi_A) ---\n        time_in_A = 0.0\n        crossings_of_lambda0 = 0\n        saved_crossings = []\n        \n        state = case_params['initial_state']\n        \n        # Unpack FFS parameters\n        interfaces = case_params['interfaces']\n        phi_A = case_params['phi_A']\n        phi_B = case_params['phi_B']\n        lambda_0 = interfaces[0]\n        T_A_budget = case_params['T_A']\n        N_0_max = case_params['N_0']\n\n        # Flux sampling phase\n        while time_in_A  T_A_budget:\n            phi_before = order_parameter(state)\n            \n            new_state, dt = ssa_step(state, case_params)\n            \n            if phi_before = phi_A:\n                time_in_A += dt\n                phi_after = order_parameter(new_state)\n                # Check for crossing from A to outside lambda_0\n                if phi_after > lambda_0:\n                    crossings_of_lambda0 += 1\n                    if len(saved_crossings)  N_0_max:\n                        saved_crossings.append(new_state)\n            \n            state = new_state\n\n        if time_in_A == 0:\n            flux_A = 0.0\n        else:\n            flux_A = crossings_of_lambda0 / time_in_A\n        \n        if flux_A == 0.0 or not saved_crossings:\n            return 0.0\n            \n        # --- Interface Sampling Phases ---\n        cond_probs = []\n        current_configs = saved_crossings\n        \n        full_interface_list = interfaces + [phi_B]\n        \n        for k in range(len(interfaces)):\n            if not current_configs:\n                # If no configurations reached the previous interface, the chain is broken.\n                cond_probs.append(0.0)\n                continue\n                \n            lambda_k_plus_1 = full_interface_list[k+1]\n            \n            num_trials = case_params['M']\n            successes = 0\n            next_configs = []\n            \n            # Sample starting configurations for the trials, with replacement\n            start_indices = np.random.randint(0, len(current_configs), size=num_trials)\n            \n            for idx in start_indices:\n                trial_state = current_configs[idx]\n                \n                # Run trial SSA from the starting configuration\n                while True:\n                    phi = order_parameter(trial_state)\n                    \n                    # Check for termination conditions\n                    if phi = phi_A: # Returned to basin A (failure)\n                        break \n                    if phi >= lambda_k_plus_1: # Reached next interface (success)\n                        successes += 1\n                        next_configs.append(trial_state)\n                        break\n                    \n                    trial_state, _ = ssa_step(trial_state, case_params)\n            \n            prob_k = successes / num_trials if num_trials > 0 else 0.0\n            cond_probs.append(prob_k)\n            \n            current_configs = next_configs\n\n        # --- Final Rate Calculation ---\n        total_prob_product = np.prod(cond_probs)\n        k_A_to_B = flux_A * total_prob_product\n        \n        return k_A_to_B\n\n    test_cases = [\n        # Case 1 (symmetric, moderate bistability)\n        {\n            'alpha_X': 20, 'alpha_Y': 20, 'delta_X': 1, 'delta_Y': 1, 'K': 10, 'n': 2,\n            'phi_A': -14, 'interfaces': [-12, -8, -4, 0, 4, 8], 'phi_B': 12,\n            'initial_state': (0, 20), 'T_A': 250, 'N_0': 20, 'M': 10\n        },\n        # Case 2 (asymmetric production favoring X)\n        {\n            'alpha_X': 22, 'alpha_Y': 18, 'delta_X': 1, 'delta_Y': 1, 'K': 10, 'n': 2,\n            'phi_A': -14, 'interfaces': [-12, -8, -4, 0, 4, 8], 'phi_B': 12,\n            'initial_state': (0, 18), 'T_A': 250, 'N_0': 20, 'M': 10\n        },\n        # Case 3 (higher copy-number, reduced noise)\n        {\n            'alpha_X': 26, 'alpha_Y': 26, 'delta_X': 1, 'delta_Y': 1, 'K': 10, 'n': 2,\n            'phi_A': -14, 'interfaces': [-12, -8, -4, 0, 4, 8], 'phi_B': 12,\n            'initial_state': (0, 26), 'T_A': 300, 'N_0': 20, 'M': 10\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        rate = run_ffs_case(case)\n        results.append(rate)\n\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\n# Execute the solver\nsolve()\n\n```"
        }
    ]
}