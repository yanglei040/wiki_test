{
    "hands_on_practices": [
        {
            "introduction": "米氏方程是酶动力学的基石，但其推导依赖于准稳态近似（QSSA），该近似假设总酶浓度远低于底物浓度。本练习 () 将挑战你超越这一限制，通过使用更具普适性的反应物稳态近似（RSA）来推导反应速率。通过量化两种近似之间的偏差，你将更深刻地理解经典模型的有效性边界，以及在何种条件下必须采用更严谨的方法，尤其是在模拟酶浓度可能很高的细胞环境时。",
            "id": "3306028",
            "problem": "一种单底物酶通过基元反应式 $E + S \\rightleftharpoons ES \\rightarrow E + P$ 催化底物转化为产物，其正向结合速率常数为 $k_{1}$，解离速率常数为 $k_{-1}$，催化转换速率常数为 $k_{\\text{cat}}$。初始条件为 $[S](0)= [S]_0$, $[E](0) = [E]_{\\text{tot}}$, $[ES](0)=0$ 和 $[P](0)=0$。定义总酶浓度 $[E]_{\\text{tot}}$，米氏常数 $K_{M} = (k_{-1} + k_{\\text{cat}})/k_{1}$，酶底物比 $\\epsilon = [E]_{\\text{tot}}/[S]_0$，以及无量纲参数 $\\alpha = K_{M}/[S]_0$。\n\n从质量作用定律和守恒关系 $[E]_{\\text{tot}} = [E] + [ES]$ 与 $[S]_{T} = [S] + [ES] + [P]$ 出发，使用反应物稳态近似 (RSA)，即在快速瞬态上 $[S]_{T}$ 保持近似恒定且等于 $[S]_0$，而 $[P]$ 保持可忽略不计，来计算初始速率 $v_{0}^{\\text{RSA}}$。其中 $v_{0}^{\\text{RSA}} = k_{\\text{cat}} [ES]^{*}$，$[ES]^{*}$ 是通过在快速时间尺度上令 $\\mathrm{d}[ES]/\\mathrm{d}t \\approx 0$ 得到的准稳态复合物浓度。然后，令 $v_{0}^{\\text{QSSA}}$ 表示由标准准稳态近似给出的经典米氏-门腾初始速率。定义无量纲相对偏差\n$$\n\\delta(\\epsilon,\\alpha) = \\frac{v_{0}^{\\text{RSA}} - v_{0}^{\\text{QSSA}}}{v_{0}^{\\text{QSSA}}}.\n$$\n将 $\\delta(\\epsilon,\\alpha)$ 表示为 $\\epsilon$ 和 $\\alpha$ 的闭式函数。\n\n你的最终答案必须是 $\\delta(\\epsilon,\\alpha)$ 的单个闭式解析表达式。无需四舍五入，最终表达式不应报告单位。",
            "solution": "用户希望找到使用反应物稳态近似 ($v_{0}^{\\text{RSA}}$) 计算的初始反应速率与经典米氏-门腾初始速率 ($v_{0}^{\\text{QSSA}}$) 之间的相对偏差 $\\delta(\\epsilon,\\alpha)$。\n\n### 步骤 1：验证问题陈述\n\n**1.1. 提取已知条件**\n- **反应式：** $E + S \\rightleftharpoons ES \\rightarrow E + P$\n- **速率常数：** 正向结合 $k_1$，解离 $k_{-1}$，催化转换 $k_{\\text{cat}}$\n- **初始条件：** $[S](0) = [S]_0$, $[E](0) = [E]_{\\text{tot}}$, $[ES](0) = 0$, $[P](0) = 0$\n- **定义：**\n    - 总酶浓度：$[E]_{\\text{tot}} = [E] + [ES]$\n    - 米氏常数：$K_{M} = \\frac{k_{-1} + k_{\\text{cat}}}{k_1}$\n    - 酶底物比：$\\epsilon = \\frac{[E]_{\\text{tot}}}{[S]_0}$\n    - 无量纲米氏常数：$\\alpha = \\frac{K_{M}}{[S]_0}$\n- **守恒关系：** $[S]_{T} = [S] + [ES] + [P]$\n- **反应物稳态近似 (RSA)：**\n    - 在一个快速瞬态时间尺度上，$[S]_{T} \\approx [S]_0$ 且 $[P] \\approx 0$，这意味着 $[S] + [ES] \\approx [S]_0$。\n    - 初始速率为 $v_{0}^{\\text{RSA}} = k_{\\text{cat}} [ES]^{*}$，其中 $[ES]^{*}$ 是在此近似下通过令 $\\mathrm{d}[ES]/\\mathrm{d}t \\approx 0$ 得到的解。\n- **经典初始速率 ($v_{0}^{\\text{QSSA}}$)：** 来自标准准稳态近似(QSSA)的初始速率。\n- **相对偏差：** $\\delta(\\epsilon,\\alpha) = \\frac{v_{0}^{\\text{RSA}} - v_{0}^{\\text{QSSA}}}{v_{0}^{\\text{QSSA}}}$\n\n**1.2. 使用提取的已知条件进行验证**\n该问题具有科学依据，提法恰当且客观。它涉及酶动力学中的标准概念，即米氏-门腾模型及其推导所基于的假设。标准 QSSA 和反应物稳态近似（也称为总 QSSA 或 tQSSA）之间的区别是计算系统生物学中一个公认的课题，适用于酶浓度相对于底物浓度不可忽略的条件。所有术语都已正式定义，所要求的推导在数学上是可行的，并且没有违反任何科学原理。问题是有效的。\n\n### 步骤 2：经典初始速率 ($v_{0}^{\\text{QSSA}}$) 的推导\n酶-底物复合物 $[ES]$ 的质量作用定律为：\n$$\n\\frac{\\mathrm{d}[ES]}{\\mathrm{d}t} = k_1 [E][S] - k_{-1} [ES] - k_{\\text{cat}} [ES] = k_1 [E][S] - (k_{-1} + k_{\\text{cat}})[ES]\n$$\n标准准稳态近似 (QSSA) 假设复合物 $[ES]$ 的浓度迅速达到稳态，即 $\\frac{\\mathrm{d}[ES]}{\\mathrm{d}t} \\approx 0$。它还假设酶浓度远小于底物浓度 ($[E]_{\\text{tot}} \\ll [S]_0$)，因此由于复合物形成引起的底物消耗可以忽略不计，我们可以在计算初始速率时近似认为 $[S] \\approx [S]_0$。\n令 $\\frac{\\mathrm{d}[ES]}{\\mathrm{d}t} = 0$：\n$$\nk_1 [E][S] = (k_{-1} + k_{\\text{cat}})[ES]\n$$\n使用酶守恒定律 $[E] = [E]_{\\text{tot}} - [ES]$ 和近似 $[S] \\approx [S]_0$：\n$$\nk_1 ([E]_{\\text{tot}} - [ES]) [S]_0 = (k_{-1} + k_{\\text{cat}})[ES]\n$$\n求解 $[ES]$：\n$$\nk_1 [E]_{\\text{tot}} [S]_0 = [ES] (k_1 [S]_0 + k_{-1} + k_{\\text{cat}})\n$$\n$$\n[ES]_{\\text{QSSA}} = \\frac{k_1 [E]_{\\text{tot}} [S]_0}{k_1 [S]_0 + k_{-1} + k_{\\text{cat}}}\n$$\n将分子和分母同除以 $k_1$ 并使用定义 $K_M = \\frac{k_{-1} + k_{\\text{cat}}}{k_1}$：\n$$\n[ES]_{\\text{QSSA}} = \\frac{[E]_{\\text{tot}} [S]_0}{[S]_0 + K_M}\n$$\n初始速率为 $v_0 = k_{\\text{cat}}[ES]$，所以：\n$$\nv_{0}^{\\text{QSSA}} = k_{\\text{cat}} \\frac{[E]_{\\text{tot}} [S]_0}{K_M + [S]_0}\n$$\n\n### 步骤 3：反应物稳态近似速率 ($v_{0}^{\\text{RSA}}$) 的推导\nRSA 也从复合物的稳态假设开始，即 $\\frac{\\mathrm{d}[ES]}{\\mathrm{d}t} \\approx 0$：\n$$\nk_1 [E][S] = (k_{-1} + k_{\\text{cat}})[ES]\n$$\n然而，它并不假设 $[S] \\approx [S]_0$。相反，它使用了在快速时间尺度上更普适的底物守恒关系：$[S] + [ES] = [S]_0$，这意味着 $[S] = [S]_0 - [ES]$。将这个关系与 $[E] = [E]_{\\text{tot}} - [ES]$ 一起代入稳态方程：\n$$\nk_1 ([E]_{\\text{tot}} - [ES])([S]_0 - [ES]) = (k_{-1} + k_{\\text{cat}})[ES]\n$$\n令 $[ES]^{*}$ 为此近似下的稳态浓度。方程两边同除以 $k_1$ 并使用 $K_M$ 的定义：\n$$\n([E]_{\\text{tot}} - [ES]^{*})([S]_0 - [ES]^{*}) = K_M [ES]^{*}\n$$\n展开左侧得到关于 $[ES]^{*}$ 的二次方程：\n$$\n[E]_{\\text{tot}}[S]_0 - ([E]_{\\text{tot}} + [S]_0)[ES]^{*} + ([ES]^{*})^2 = K_M [ES]^{*}\n$$\n$$\n([ES]^{*})^2 - ([E]_{\\text{tot}} + [S]_0 + K_M)[ES]^{*} + [E]_{\\text{tot}}[S]_0 = 0\n$$\n这是一个形如 $ax^2+bx+c=0$ 的二次方程，其中 $x=[ES]^{*}$，$a=1$，$b= -([E]_{\\text{tot}} + [S]_0 + K_M)$，以及 $c= [E]_{\\text{tot}}[S]_0$。解为：\n$$\n[ES]^{*} = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} = \\frac{([E]_{\\text{tot}} + [S]_0 + K_M) \\pm \\sqrt{([E]_{\\text{tot}} + [S]_0 + K_M)^2 - 4[E]_{\\text{tot}}[S]_0}}{2}\n$$\n为了得到物理上有意义的解，当 $[E]_{\\text{tot}} \\to 0$ 时，$[ES]^{*}$ 必须趋近于 0。“+”根不满足这个条件。因此，我们必须选择“-”根：\n$$\n[ES]^{*} = \\frac{1}{2} \\left( [E]_{\\text{tot}} + [S]_0 + K_M - \\sqrt{([E]_{\\text{tot}} + [S]_0 + K_M)^2 - 4[E]_{\\text{tot}}[S]_0} \\right)\n$$\n因此，初始速率为：\n$$\nv_{0}^{\\text{RSA}} = k_{\\text{cat}}[ES]^{*} = \\frac{k_{\\text{cat}}}{2} \\left( [E]_{\\text{tot}} + [S]_0 + K_M - \\sqrt{([E]_{\\text{tot}} + [S]_0 + K_M)^2 - 4[E]_{\\text{tot}}[S]_0} \\right)\n$$\n\n### 步骤 4：将速率表示为无量纲形式并计算 $\\delta(\\epsilon, \\alpha)$\n使用定义 $\\epsilon = [E]_{\\text{tot}}/[S]_0$ 和 $\\alpha = K_M/[S]_0$，我们重写速率表达式。\n对于 $v_{0}^{\\text{QSSA}}$：\n$$\nv_{0}^{\\text{QSSA}} = k_{\\text{cat}} \\frac{(\\epsilon[S]_0) [S]_0}{\\alpha[S]_0 + [S]_0} = k_{\\text{cat}} \\frac{\\epsilon[S]_0^2}{[S]_0(\\alpha + 1)} = \\frac{k_{\\text{cat}}\\epsilon[S]_0}{1+\\alpha}\n$$\n对于 $v_{0}^{\\text{RSA}}$：\n$$\nv_{0}^{\\text{RSA}} = \\frac{k_{\\text{cat}}}{2} \\left( \\epsilon[S]_0 + [S]_0 + \\alpha[S]_0 - \\sqrt{(\\epsilon[S]_0 + [S]_0 + \\alpha[S]_0)^2 - 4(\\epsilon[S]_0)[S]_0} \\right)\n$$\n提出公因子 $[S]_0$：\n$$\nv_{0}^{\\text{RSA}} = \\frac{k_{\\text{cat}}[S]_0}{2} \\left( \\epsilon + 1 + \\alpha - \\sqrt{(\\epsilon + 1 + \\alpha)^2 - 4\\epsilon} \\right)\n$$\n现在我们计算比率 $\\frac{v_{0}^{\\text{RSA}}}{v_{0}^{\\text{QSSA}}}$：\n$$\n\\frac{v_{0}^{\\text{RSA}}}{v_{0}^{\\text{QSSA}}} = \\frac{\\frac{k_{\\text{cat}}[S]_0}{2} \\left( \\epsilon + 1 + \\alpha - \\sqrt{(\\epsilon + 1 + \\alpha)^2 - 4\\epsilon} \\right)}{\\frac{k_{\\text{cat}}\\epsilon[S]_0}{1+\\alpha}} = \\frac{1+\\alpha}{2\\epsilon} \\left( \\epsilon + 1 + \\alpha - \\sqrt{(\\epsilon + 1 + \\alpha)^2 - 4\\epsilon} \\right)\n$$\n相对偏差为 $\\delta(\\epsilon,\\alpha) = \\frac{v_{0}^{\\text{RSA}}}{v_{0}^{\\text{QSSA}}} - 1$。\n该表达式可以通过对括号中的项进行有理化来简化。令 $A = \\epsilon + 1 + \\alpha$ 和 $B = 4\\epsilon$。该项为 $A - \\sqrt{A^2-B}$。\n$$\nA - \\sqrt{A^2-B} = \\frac{(A - \\sqrt{A^2-B})(A + \\sqrt{A^2-B})}{A + \\sqrt{A^2-B}} = \\frac{A^2 - (A^2-B)}{A + \\sqrt{A^2-B}} = \\frac{B}{A + \\sqrt{A^2-B}}\n$$\n将此代回到比率的表达式中：\n$$\n\\frac{v_{0}^{\\text{RSA}}}{v_{0}^{\\text{QSSA}}} = \\frac{1+\\alpha}{2\\epsilon} \\left( \\frac{4\\epsilon}{\\epsilon + 1 + \\alpha + \\sqrt{(\\epsilon + 1 + \\alpha)^2 - 4\\epsilon}} \\right) = \\frac{2(1+\\alpha)}{\\epsilon + 1 + \\alpha + \\sqrt{(\\epsilon + 1 + \\alpha)^2 - 4\\epsilon}}\n$$\n最后，我们可以写出 $\\delta(\\epsilon,\\alpha)$ 的表达式：\n$$\n\\delta(\\epsilon,\\alpha) = \\frac{2(1+\\alpha)}{\\epsilon + 1 + \\alpha + \\sqrt{(\\epsilon + 1 + \\alpha)^2 - 4\\epsilon}} - 1\n$$\n这就是相对偏差的闭式解析表达式。",
            "answer": "$$\n\\boxed{\\frac{2(1+\\alpha)}{\\epsilon + 1 + \\alpha + \\sqrt{(\\epsilon + 1 + \\alpha)^{2} - 4\\epsilon}} - 1}\n$$"
        },
        {
            "introduction": "现实世界中的酶通常是动态分子，其构象状态之间的转换时间尺度与催化相当甚至更慢，这导致了简单的稳态模型无法捕捉的复杂动力学行为。在此实践中 ()，你将通过对一个具有缓慢变构转换的酶应用时间尺度分离的方法来探索此类系统。推导前稳态“爆发”动力学的过程将揭示，表观催化常数 $k_{\\text{cat}}^{\\text{app}}$ 如何作为一个依赖于时间的量而出现，这为谨慎解释实验测定的动力学参数提供了至关重要的一课。",
            "id": "3306005",
            "problem": "一种酶在非活性构象和活性构象之间表现出变构转换。令非活性游离酶表示为 $E_I$，活性游离酶表示为 $E_A$，与底物结合的活性复合物表示为 $C$。该酶以一级速率在不同构象之间相互转换：激活 $E_I \\xrightarrow{k_a} E_A$ 和失活 $E_A \\xrightarrow{k_i} E_I$。只有活性构象能结合底物 $S$ 并根据基元步骤 $E_A + S \\xrightleftharpoons[k_{\\text{off}}]{k_{\\text{on}}} C \\xrightarrow{k_{\\text{cat}}} E_A + P$ 催化产物生成。假设存在以下与实验相关的条件：\n- 底物浓度 $S$ 通过一个大型恒化器储库保持恒定。\n- 总酶浓度 $E_{\\text{tot}}$ 是守恒的，且远小于 $S$。\n- 与变构转换相比，结合/解离和催化过程是快速的；具体来说，$k_{\\text{on}} S + k_{\\text{off}} + k_{\\text{cat}} \\gg k_a + k_i$。\n- 无论酶是否与底物结合，变构转换都以相同的速率 $k_a$ 和 $k_i$ 发生（也就是说，构象转变与底物占据无关）。\n- 在时间 $t=0$ 时，即酶和底物混合后，总酶群体中有比例为 $p_0 \\in [0,1]$ 的部分处于活性构象簇（包括 $E_A$ 和 $C$），且没有产物生成。\n\n仅从质量作用定律和这些假设出发，在准稳态近似（QSSA）下推导前稳态产物生成的动力学。然后，考虑一位实验者在固定的底物浓度 $S$ 下，通过测量在持续时间为 $T$ 的有限观测窗口内生成的产物，并除以 $T$ 来估算初始“速率”。证明该速率对 $S$ 保持米氏-门腾 (MM) 依赖性，并通过 $v_{\\text{app}}(T,S) = E_{\\text{tot}}\\,k_{\\text{cat}}^{\\text{app}}(T)\\,\\dfrac{S}{K_M + S}$ 定义其表观催化速率常数 $k_{\\text{cat}}^{\\text{app}}(T)$，其中 $K_M$ 是由基元结合和催化步骤产生的米氏常数。\n\n$k_{\\text{cat}}^{\\text{app}}(T)$ 关于 $k_a$、 $k_i$、 $k_{\\text{cat}}$、 $p_0$ 和 $T$ 的闭合形式解析表达式是什么？用单位 $\\text{s}^{-1}$ 表示你的最终结果。最终答案必须是单个解析表达式。",
            "solution": "该问题要求在特定的前稳态条件下，推导变构酶的表观催化速率常数 $k_{\\text{cat}}^{\\text{app}}(T)$。\n\n### 步骤 1：模型构建\n该系统涉及两种酶构象，活性 ($E_A$) 和非活性 ($E_I$)，以及一个由活性状态形成的底物结合复合物 ($C$)。总酶浓度 $E_{\\text{tot}}$ 是守恒的：\n$$[E_I] + [E_A] + [C] = E_{\\text{tot}}$$\n我们将处于活性构象簇中的酶的总浓度定义为 $x(t) = [E_A](t) + [C](t)$，将处于非活性构象簇中的浓度定义为 $y(t) = [E_I](t)$。守恒定律变为 $x(t) + y(t) = E_{\\text{tot}}$。\n\n问题指出了两个不同的时间尺度：\n1.  **快速时间尺度**：底物结合/解离和催化。基元步骤为 $E_A + S \\xrightleftharpoons[k_{\\text{off}}]{k_{\\text{on}}} C \\xrightarrow{k_{\\text{cat}}} E_A + P$。\n2.  **慢速时间尺度**：活性和非活性构象之间的变构相互转换。\n\n这种分离由条件 $k_{\\text{on}} S + k_{\\text{off}} + k_{\\text{cat}} \\gg k_a + k_i$ 来证明是合理的。\n\n### 步骤 2：对快速动力学使用准稳态近似（QSSA）\n在快速时间尺度上，活性酶的总浓度 $x(t)$ 可以被视为一个常数参数。这个群体在游离活性形式 $[E_A]$ 和底物结合形式 $[C]$ 之间的分布迅速达到准稳态。由这些快速反应引起的复合物 $[C]$ 的变化率是：\n$$\\frac{d[C]}{dt} = k_{\\text{on}}[E_A][S] - (k_{\\text{off}} + k_{\\text{cat}})[C]$$\n应用 QSSA，我们设 $\\frac{d[C]}{dt} \\approx 0$：\n$$k_{\\text{on}}[E_A][S] \\approx (k_{\\text{off}} + k_{\\text{cat}})[C]$$\n使用定义 $x = [E_A] + [C]$，我们代入 $[E_A] = x - [C]$：\n$$k_{\\text{on}}(x - [C])[S] = (k_{\\text{off}} + k_{\\text{cat}})[C]$$\n求解 $[C]$：\n$$k_{\\text{on}}x[S] = (k_{\\text{off}} + k_{\\text{cat}} + k_{\\text{on}}[S])[C]$$\n$$[C] = x \\frac{k_{\\text{on}}[S]}{k_{\\text{off}} + k_{\\text{cat}} + k_{\\text{on}}[S]} = x \\frac{[S]}{\\frac{k_{\\text{off}} + k_{\\text{cat}}}{k_{\\text{on}}} + [S]}$$\n问题将米氏常数定义为 $K_M = \\frac{k_{\\text{off}} + k_{\\text{cat}}}{k_{\\text{on}}}$。因此，在任意时刻 $t$，底物结合复合物的浓度与总活性酶浓度 $x(t)$ 的关系如下：\n$$[C](t) = x(t) \\frac{[S]}{K_M + [S]}$$\n产物生成的瞬时速率为 $v(t) = \\frac{d[P]}{dt} = k_{\\text{cat}}[C](t)$：\n$$v(t) = k_{\\text{cat}} x(t) \\frac{[S]}{K_M + [S]}$$\n\n### 步骤 3：慢变量的动力学\n现在我们对慢变量 $x(t)$ 的演化进行建模。“无论酶是否与底物结合，变构转换都以相同的速率 $k_a$ 和 $k_i$ 发生”这一陈述意味着，活性构象簇中的每个分子（$E_A$ 或 $C$）都有一个内在倾向 $k_i$ 转换到非活性状态，而非活性构象簇中的每个分子（$E_I$）都有一个内在倾向 $k_a$ 转换到活性状态。\n从活性构象簇到非活性构象簇的总转换速率为 $k_i([E_A] + [C]) = k_i x$。\n从非活性构象簇到活性构象簇的总转换速率为 $k_a[E_I] = k_a y$。\n因此，总活性酶浓度的变化率为：\n$$\\frac{dx}{dt} = k_a y - k_i x$$\n代入 $y = E_{\\text{tot}} - x$：\n$$\\frac{dx}{dt} = k_a(E_{\\text{tot}} - x) - k_i x = k_a E_{\\text{tot}} - (k_a + k_i)x$$\n这是一个关于 $x(t)$ 的一阶线性常微分方程。通解为：\n$$x(t) = \\frac{k_a E_{\\text{tot}}}{k_a + k_i} + A \\exp(-(k_a + k_i)t)$$\n其中 $A$ 是一个积分常数。我们使用 $t=0$ 时的初始条件：比例为 $p_0$ 的酶处于活性构象簇中，所以 $x(0) = p_0 E_{\\text{tot}}$。\n$$p_0 E_{\\text{tot}} = \\frac{k_a E_{\\text{tot}}}{k_a + k_i} + A$$\n$$A = \\left(p_0 - \\frac{k_a}{k_a + k_i}\\right) E_{\\text{tot}}$$\n我们将活性酶的平衡比例定义为 $p_{\\text{eq}} = \\frac{k_a}{k_a + k_i}$。$x(t)$ 的解变为：\n$$x(t) = p_{\\text{eq}} E_{\\text{tot}} + (p_0 - p_{\\text{eq}}) E_{\\text{tot}} \\exp(-(k_a + k_i)t)$$\n$$x(t) = E_{\\text{tot}} \\left[ p_{\\text{eq}} + (p_0 - p_{\\text{eq}}) \\exp(-(k_a + k_i)t) \\right]$$\n\n### 步骤 4：表观速率的计算\n在时刻 $T$ 的总产物浓度 $[P](T)$ 是瞬时速率 $v(t)$ 从 $t=0$ 到 $t=T$ 的积分，给定 $[P](0) = 0$。\n$$[P](T) = \\int_0^T v(t) dt = \\int_0^T k_{\\text{cat}} x(t) \\frac{[S]}{K_M + [S]} dt$$\n由于 $[S]$ 是常数，我们可以将依赖于底物的项提取出来：\n$$[P](T) = k_{\\text{cat}} \\frac{[S]}{K_M + [S]} \\int_0^T x(t) dt$$\n现在，我们对 $x(t)$ 进行积分：\n$$\\int_0^T x(t) dt = E_{\\text{tot}} \\int_0^T \\left[ p_{\\text{eq}} + (p_0 - p_{\\text{eq}}) \\exp(-(k_a + k_i)t) \\right] dt$$\n$$= E_{\\text{tot}} \\left[ p_{\\text{eq}}t - \\frac{p_0 - p_{\\text{eq}}}{k_a + k_i} \\exp(-(k_a + k_i)t) \\right]_0^T$$\n$$= E_{\\text{tot}} \\left[ \\left( p_{\\text{eq}}T - \\frac{p_0 - p_{\\text{eq}}}{k_a + k_i} \\exp(-(k_a + k_i)T) \\right) - \\left( 0 - \\frac{p_0 - p_{\\text{eq}}}{k_a + k_i} \\right) \\right]$$\n$$= E_{\\text{tot}} \\left[ p_{\\text{eq}}T + \\frac{p_0 - p_{\\text{eq}}}{k_a + k_i} (1 - \\exp(-(k_a + k_i)T)) \\right]$$\n表观速率 $v_{\\text{app}}(T,S)$ 定义为 $[P](T)/T$：\n$$v_{\\text{app}}(T,S) = \\frac{[P](T)}{T} = k_{\\text{cat}} \\frac{[S]}{K_M + [S]} \\frac{1}{T} E_{\\text{tot}} \\left[ p_{\\text{eq}}T + \\frac{p_0 - p_{\\text{eq}}}{k_a + k_i} (1 - \\exp(-(k_a + k_i)T)) \\right]$$\n重新整理各项以匹配所需形式 $v_{\\text{app}}(T,S) = E_{\\text{tot}}\\,k_{\\text{cat}}^{\\text{app}}(T)\\,\\dfrac{S}{K_M + S}$：\n$$v_{\\text{app}}(T,S) = E_{\\text{tot}} \\left( k_{\\text{cat}} \\left[ p_{\\text{eq}} + (p_0 - p_{\\text{eq}}) \\frac{1 - \\exp(-(k_a + k_i)T)}{T(k_a + k_i)} \\right] \\right) \\frac{[S]}{K_M + [S]}$$\n\n### 步骤 5：$k_{\\text{cat}}^{\\text{app}}(T)$ 的最终表达式\n通过将我们推导出的 $v_{\\text{app}}(T,S)$ 表达式与目标形式进行比较，我们可以确定 $k_{\\text{cat}}^{\\text{app}}(T)$：\n$$k_{\\text{cat}}^{\\text{app}}(T) = k_{\\text{cat}} \\left[ p_{\\text{eq}} + (p_0 - p_{\\text{eq}}) \\frac{1 - \\exp(-(k_a + k_i)T)}{T(k_a + k_i)} \\right]$$\n最后，我们代入 $p_{\\text{eq}} = \\frac{k_a}{k_a + k_i}$ 的定义：\n$$k_{\\text{cat}}^{\\text{app}}(T) = k_{\\text{cat}} \\left[ \\frac{k_a}{k_a + k_i} + \\left( p_0 - \\frac{k_a}{k_a + k_i} \\right) \\frac{1 - \\exp(-(k_a + k_i)T)}{T(k_a + k_i)} \\right]$$\n该表达式给出了表观催化速率常数，它是基本速率常数、初始活性比例和观测时间 $T$ 的函数。$k_{\\text{cat}}$ 的单位是 $\\text{s}^{-1}$，而方括号中的项是无量纲的，因此整个表达式的单位由 $k_{\\text{cat}}$ 决定。",
            "answer": "$$\\boxed{k_{\\text{cat}} \\left[ \\frac{k_a}{k_a + k_i} + \\left( p_0 - \\frac{k_a}{k_a + k_i} \\right) \\frac{1 - \\exp(-(k_a + k_i)T)}{T(k_a + k_i)} \\right]}$$"
        },
        {
            "introduction": "Monod-Wyman-Changeux (MWC) 模型是描述变构调控的强大框架，但其多参数的特性引发了一个关键的系统级问题：哪些参数是控制酶协同行为的最关键驱动因素？这个高级计算练习 () 将指导你使用索博尔指数（Sobol indices）进行全局敏感性分析（GSA），以剖析 MWC 模型。通过对变构常数 $L$、亲和力比率 $c$ 和解离常数 $K_R$ 对酶响应斜率的影响进行排序，你将学会一种前沿技术，用于识别复杂生物网络中的关键控制点。",
            "id": "3306051",
            "problem": "要求您实现一个完整的程序，对 Monod–Wyman–Changeux (MWC) 变构酶模型在半饱和状态下的响应斜率进行全局灵敏度分析，并使用定向扰动模拟来验证其参数影响力的排序。该分析必须针对多个参数范围和抽样预算（共同构成一个测试套件）进行。您的程序必须计算各参数的一阶和全阶 Sobol 灵敏度指数，并确定哪个参数对半饱和状态下的响应斜率影响最大。然后，程序必须通过围绕一个标称值扰动每个参数，并比较由此产生的对斜率的效应大小，来验证该排序。\n\n该模型的基础是具有两种构象状态——松弛 (R) 态和紧张 (T) 态——的平衡结合框架，适用于一个含有 $n$ 个相同结合位点的酶（即 Monod–Wyman–Changeux 变构模型）。设底物浓度为 $S$，定义无量纲变量 $\\alpha = S/K_R$，其中 $K_R$ 是 R 态的解离常数。设 $L$ 为变构平衡常数（在没有底物时 T 态与 R 态的浓度比），$c$ 为 R 态与 T 态解离常数的比值，其中 $0  c  1$ 表示 R 态具有更高的亲和力。\n\nR 态和 T 态的结合多项式分别为 $Q_R(\\alpha) = (1 + \\alpha)^n$ 和 $Q_T(\\alpha) = L (1 + c \\alpha)^n$。平均分数占据率 $Y(\\alpha)$ 由一个热力学恒等式定义，该恒等式将平均结合配体数与结合多项式之和的自然对数导数相关联，即：\n$$\nY(\\alpha) = \\frac{1}{n} \\alpha \\frac{d}{d\\alpha} \\ln\\left(Q_R(\\alpha) + Q_T(\\alpha)\\right).\n$$\n该定义确保了推导过程植根于配体结合的平衡统计力学，具有严格性。半饱和点 $K_{0.5}$ 定义为使 $Y(\\alpha) = 0.5$ 时的底物浓度 $S$，此时 $\\alpha = S / K_R$。半饱和状态下的响应斜率是导数 $\\left.\\frac{dY}{dS}\\right|_{S = K_{0.5}}$，其物理单位为微摩尔的倒数 (1/µM)。该斜率可通过对 $Y(\\alpha)$ 关于 $\\alpha$ 求导，并使用链式法则 $\\frac{dY}{dS} = \\frac{1}{K_R} \\frac{dY}{d\\alpha}$，在半饱和点进行计算。\n\n您必须使用 Sobol 指数进行全局灵敏度分析，以量化每个参数（$L$、$c$、$K_R$）对函数 $f(L, c, K_R) = \\left.\\frac{dY}{dS}\\right|_{S = K_{0.5}}$ 方差的贡献。请遵循一种有效且广泛使用的方法，使用 Saltelli 抽样方案（包含两个独立的基样本矩阵和适当的估计量）来计算一阶和全阶 Sobol 指数。参数必须根据以下指定范围内的分布独立抽样：\n- $L$：在 $[L_{\\min}, L_{\\max}]$ 上服从对数均匀分布。\n- $c$：在 $[c_{\\min}, c_{\\max}]$ 上服从均匀分布。\n- $K_R$：在 $[K_{R,\\min}, K_{R,\\max}]$ 上服从对数均匀分布。\n\n您还必须通过执行定向扰动模拟来验证灵敏度排序：对于 $L$ 和 $K_R$，选择对数标度上的中点（即几何平均值）作为标称参数集；对于 $c$，选择线性标度上的中点（即算术平均值）。对每个参数，将其标称值沿两个方向进行微小的分数扰动 $\\varepsilon$，并计算斜率相对于基线的平均绝对变化。平均变化最大的参数定义了验证排序。将此验证排序与 Sobol 全阶排序进行比较。\n\n请实现以下测试套件，其中对于每个测试用例，您必须使用指定的范围、酶位点数 $n$、样本大小 $N$ 和扰动分数 $\\varepsilon$。$K_R$ 的单位是微摩尔 ($\\mu$M)，斜率必须以微摩尔的倒数 (1/µM) 计算和报告。\n\n- 测试用例 1 (理想路径，中等协同性):\n  - $n = 4$\n  - $L \\in [10^2, 10^5]$\n  - $c \\in [0.01, 0.5]$\n  - $K_R \\in [0.5, 50]$ $\\mu$M\n  - $N = 1000$\n  - $\\varepsilon = 0.10$\n  - 使用固定的随机种子以保证可复现性。\n\n- 测试用例 2 (强 T 态偏向，较高协同性):\n  - $n = 6$\n  - $L \\in [10^3, 10^6]$\n  - $c \\in [0.001, 0.2]$\n  - $K_R \\in [0.1, 10]$ $\\mu$M\n  - $N = 1200$\n  - $\\varepsilon = 0.05$\n  - 使用固定的随机种子以保证可复现性。\n\n- 测试用例 3 (弱协同性，接近非协同机制):\n  - $n = 3$\n  - $L \\in [10^0, 10^2]$\n  - $c \\in [0.5, 0.99]$\n  - $K_R \\in [1, 100]$ $\\mu$M\n  - $N = 800$\n  - $\\varepsilon = 0.10$\n  - 使用固定的随机种子以保证可复现性。\n\n对于每个测试用例，您的程序必须：\n1. 根据指定的分布和 $N$ 为矩阵 $A$ 和 $B$ 抽样参数集。\n2. 计算 $L$、$c$ 和 $K_R$ 的一阶和全阶 Sobol 指数。\n3. 确定一阶和全阶指数中排名最高的参数索引，其中 $0$ 对应 $L$，$1$ 对应 $c$，$2$ 对应 $K_R$。\n4. 执行定向扰动验证，并确定全阶排序中的最高排名参数是否与扰动排序中的最高排名参数匹配。\n5. 计算标称参数集下的基线斜率，以 $1/\\mu$M 表示。\n\n最终输出格式：\n您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表，其中每个测试用例的结果本身是包含四个条目的列表：\n- 按全阶 Sobol 指数排名的最高参数索引（一个在 $\\{0,1,2\\}$ 中的整数）。\n- 按一阶 Sobol 指数排名的最高参数索引（一个在 $\\{0,1,2\\}$ 中的整数）。\n- 一个布尔值，指示按全阶 Sobol 指数排名的最高参数是否与按扰动验证排名的最高参数匹配。\n- 标称参数集下的基线斜率（一个以 $1/\\mu$M 为单位的浮点数）。\n\n例如，最终输出必须采用以下形式：\n$$\n[\\,[i_{T,1}, i_{S,1}, \\text{bool}_1, s_1],\\,[i_{T,2}, i_{S,2}, \\text{bool}_2, s_2],\\,[i_{T,3}, i_{S,3}, \\text{bool}_3, s_3]\\,]\n$$\n其中 $i_{T,k}$ 和 $i_{S,k}$ 分别是测试用例 $k$ 的全阶和一阶排名最高的索引，$\\text{bool}_k$ 是验证布尔值，$s_k$ 是以 $1/\\mu$M 为单位的基线斜率。\n\n所有计算都必须具有科学真实性和数值鲁棒性。请确保始终使用一致的单位，并确保程序是自包含的，不需要输入，并严格按照指定格式打印一行输出。",
            "solution": "经过严格的验证过程，用户提供的问题被评估为 **有效**。该问题在科学上基于酶动力学和灵敏度分析的原理，其定义和约束条件完整且一致，表述客观，是一个适定问题。该问题要求实现一个计算工作流，用以分析一个已建立的生物物理模型——用于描述变构效应的 Monod-Wyman-Changeux (MWC) 模型——的灵敏度。\n\n解决方案首先为目标量（即酶在半饱和状态下的响应斜率）构建数学模型。随后，实现使用 Sobol 指数的全局灵敏度分析，并辅以局部扰动分析进行验证。\n\n### 1. MWC 模型与响应斜率\n\nMWC 模型描述了一种具有 $n$ 个相同结合位点的变构蛋白质，该蛋白质存在于两种构象状态：高亲和力的松弛 (R) 态和低亲和力的紧张 (T) 态。关键参数如下：\n- $L$：变构平衡常数，表示在没有底物时 T 态与 R 态的比例。\n- $c$：非排他性参数，定义为解离常数之比 $K_R/K_T$。值 $c \\in (0, 1)$ 表示 R 态对底物具有更高的亲和力。\n- $K_R$：底物从 R 态的一个位点解离的微观解离常数。\n\n底物浓度 $S$ 被归一化为 $\\alpha = S/K_R$。系统的行为由总结合多项式 $Z(\\alpha)$ 概括，它是 R 态和 T 态多项式之和：\n$$\nZ(\\alpha) = Q_R(\\alpha) + Q_T(\\alpha) = (1 + \\alpha)^n + L(1 + c\\alpha)^n\n$$\n酶的分数饱和度 $Y(\\alpha)$，表示每个原聚体上平均结合的配体数除以 $n$，由以下热力学关系给出：\n$$\nY(\\alpha) = \\frac{1}{n} \\alpha \\frac{d}{d\\alpha} \\ln(Z(\\alpha)) = \\frac{\\alpha}{n} \\frac{Z'(\\alpha)}{Z(\\alpha)}\n$$\n其中 $Z'(\\alpha)$ 是 $Z(\\alpha)$ 关于 $\\alpha$ 的一阶导数。具体表达式为：\n$$\nY(\\alpha) = \\alpha \\frac{(1+\\alpha)^{n-1} + Lc(1+c\\alpha)^{n-1}}{(1+\\alpha)^n + L(1+c\\alpha)^n}\n$$\n模型评估函数 $f(L, c, K_R)$ 计算半饱和状态下的响应斜率 $\\left.\\frac{dY}{dS}\\right|_{S=K_{0.5}}$。这需要一个两步过程：\n\n**第一步：确定半饱和点 ($K_{0.5}$)**\n半饱和浓度 $S=K_{0.5}$ 由条件 $Y(\\alpha) = 0.5$ 定义，其中 $\\alpha = K_{0.5}/K_R$。这个非线性方程 $Y(\\alpha) - 0.5 = 0$ 必须数值求解以得到 $\\alpha_{0.5}$。由于 $Y(\\alpha)$ 是 $\\alpha$ 的一个从 $Y(0)=0$ 到 $Y(\\infty)=1$ 的单调递增函数，因此存在唯一的根。一个鲁棒的数值求根算法，如 Brent 方法，适用于此任务，可应用于一个足够大的括号区间（例如 $[10^{-9}, 10^4/c]$）。\n\n**第二步：计算 $\\alpha_{0.5}$ 处的斜率**\n所需斜率为 $\\frac{dY}{dS}$，它通过链式法则与 $\\frac{dY}{d\\alpha}$ 相关联：$\\frac{dY}{dS} = \\frac{dY}{d\\alpha} \\frac{d\\alpha}{dS} = \\frac{1}{K_R} \\frac{dY}{d\\alpha}$。我们需要计算 $Y(\\alpha)$ 的解析导数，并在 $\\alpha_{0.5}$ 处求值。导数 $\\frac{dY}{d\\alpha}$ 通过对 $Y(\\alpha)$ 的表达式求导得到：\n$$\n\\frac{dY}{d\\alpha} = \\frac{1}{n} \\frac{d}{d\\alpha} \\left( \\alpha \\frac{Z'(\\alpha)}{Z(\\alpha)} \\right) = \\frac{1}{n} \\left[ \\frac{Z'}{Z} + \\alpha \\frac{Z''Z - (Z')^2}{Z^2} \\right]\n$$\n其中 $Z''(\\alpha)$ 是 $Z(\\alpha)$ 的二阶导数。这些导数是：\n$$\nZ'(\\alpha) = n(1+\\alpha)^{n-1} + Lnc(1+c\\alpha)^{n-1}\n$$\n$$\nZ''(\\alpha) = n(n-1)(1+\\alpha)^{n-2} + Ln(n-1)c^2(1+c\\alpha)^{n-2}\n$$\n这些表达式可以精确计算斜率 $f(L, c, K_R) = \\frac{1}{K_R} \\left.\\frac{dY}{d\\alpha}\\right|_{\\alpha_{0.5}}$。\n\n### 2. 全局灵敏度分析 (Sobol 指数)\n\n为量化输入参数（$L$、$c$、$K_R$）的不确定性对输出斜率方差的贡献，我们计算一阶（$S_i$）和全阶（$ST_i$）Sobol 指数。为此采用 Saltelli 抽样方法。\n\n1.  **抽样**：生成两个大小为 $N \\times k$（其中 $N$ 是样本大小，$k=3$ 是参数数量）的独立基样本矩阵 $A$ 和 $B$。每个参数的样本从其指定的分布中抽取：$c$ 服从均匀分布，$L$ 和 $K_R$ 服从对数均匀分布。一个在 $[x_{\\min}, x_{\\max}]$ 上的对数均匀样本可以通过从 $[\\log_{10}(x_{\\min}), \\log_{10}(x_{\\max})]$ 中抽取一个均匀样本 $u$ 并计算 $10^u$ 来获得。\n2.  **模型评估**：对 $A$ 和 $B$ 中的所有样本点评估模型函数 $f(p)$，得到输出向量 $y_A$ 和 $y_B$。然后，对于每个参数 $i=1, ..., k$，通过取 $A$ 的所有列（除了第 $i$ 列，该列取自 $B$）来形成一个新矩阵 $C_i$。对每个 $C_i$ 评估模型，得到向量 $y_{C_i}$。这总共需要 $N \\times (k+2)$ 次模型评估。\n3.  **指数估计**：使用 Jansen/Saltelli 估计量来估计 Sobol 指数，这些估计量以其鲁棒性而闻名。\n    - 一阶指数 $S_i$，衡量参数 $P_i$ 对输出方差的直接贡献，估计如下：\n      $$ S_i = \\frac{\\frac{1}{N}\\sum_{j=1}^N y_{B,j} (y_{C_i,j} - y_{A,j})}{\\text{Var}(y_A)} $$\n    - 全阶指数 $ST_i$，衡量直接贡献以及与所有其他参数相互作用的贡献，估计如下：\n      $$ ST_i = \\frac{\\frac{1}{2N}\\sum_{j=1}^N (y_{A,j} - y_{C_i,j})^2}{\\text{Var}(y_A)} $$\n$ST_i$ 最大的参数被认为是最具影响力的。\n\n### 3. 扰动验证\n\n来自全局灵敏度分析的排序使用局部灵敏度方法进行验证。通过取对数均匀分布参数（$L$、$K_R$）的几何平均值和均匀分布参数（$c$）的算术平均值来定义一个标称参数集。\n$$\nL_{nom} = \\sqrt{L_{\\min}L_{\\max}}, \\quad c_{nom} = \\frac{c_{\\min}+c_{\\max}}{2}, \\quad K_{R,nom} = \\sqrt{K_{R,\\min}K_{R,\\max}}\n$$\n计算基线斜率 $M_0 = f(L_{nom}, c_{nom}, K_{R,nom})$。然后，每个参数 $p_i$ 被单独扰动一个分数 $\\pm\\varepsilon$：$p_i(1+\\varepsilon)$ 和 $p_i(1-\\varepsilon)$，并重新评估模型以获得扰动后的斜率 $M_{i,+}$ 和 $M_{i,-}$。计算平均绝对变化或效应大小 $\\Delta_i$：\n$$\n\\Delta_i = \\frac{1}{2} \\left( |M_{i,+} - M_0| + |M_{i,-} - M_0| \\right)\n$$\n效应大小 $\\Delta_i$ 最大的参数被确定为在这种局部意义上最敏感的参数。如果全阶 Sobol 指数中排名最高的参数与扰动分析中排名最高的参数匹配，则验证成功。\n\n### 4. 实现算法\n\n整个程序对问题陈述中指定的三个测试用例分别执行上述过程。对于每个用例：\n1.  为保证可复现性，设置一个固定的随机种子。\n2.  使用 Saltelli 方案生成参数样本。\n3.  对所有必需的样本点评估模型函数 `get_slope_for_params`，并通过返回 `NaN` 来处理潜在的数值问题。\n4.  过滤掉导致 `NaN` 的样本，以确保鲁棒的指数计算。\n5.  计算一阶（$S_i$）和全阶（$ST_i$）Sobol 指数。记录具有最大 $S_i$ 和 $ST_i$ 的参数的索引。\n6.  围绕标称参数集执行扰动分析，以找到局部上最具影响力的参数。\n7.  将 $ST_i$ 分析中排名最高的参数与扰动分析中排名最高的参数进行比较。\n8.  收集该测试用例的结果——最高 $ST_i$ 索引、最高 $S_i$ 索引、验证比较的布尔结果以及基线斜率。\n9.  最后，将所有测试用例的收集结果格式化为指定的单个字符串并打印。",
            "answer": "```python\n# language: Python\n# version: 3.12\n# libraries:\n#   - name: numpy\n#     version: 1.23.5\n#   - name: scipy\n#     version: 1.11.4\n\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef mwc_model_Y(alpha, n, L, c):\n    \"\"\"\n    Calculates the fractional saturation Y for the MWC model using given parameters.\n    The function is vectorized to handle numpy arrays for alpha.\n    \"\"\"\n    _1_plus_alpha = 1.0 + alpha\n    _1_plus_c_alpha = 1.0 + c * alpha\n    \n    # Use np.power for robust and vectorized exponentiation.\n    # Direct computation is stable for the small values of n in this problem.\n    numerator_term1 = np.power(_1_plus_alpha, n - 1)\n    numerator_term2 = L * c * np.power(_1_plus_c_alpha, n - 1)\n    \n    denominator_term1 = np.power(_1_plus_alpha, n)\n    denominator_term2 = L * np.power(_1_plus_c_alpha, n)\n    \n    denominator = denominator_term1 + denominator_term2\n    # Prevent division by zero, although it's unlikely for alpha >= 0.\n    if isinstance(denominator, np.ndarray):\n        denominator[np.abs(denominator)  1e-12] = 1e-12\n    elif np.abs(denominator)  1e-12:\n        denominator = 1e-12\n\n    return alpha * (numerator_term1 + numerator_term2) / denominator\n\ndef mwc_model_slope(alpha_05, n, L, c, K_R):\n    \"\"\"\n    Calculates the slope dY/dS at the half-saturation point alpha_05.\n    \"\"\"\n    alpha = alpha_05\n    _1_plus_alpha = 1.0 + alpha\n    _1_plus_c_alpha = 1.0 + c * alpha\n\n    Z = np.power(_1_plus_alpha, n) + L * np.power(_1_plus_c_alpha, n)\n    Z_p = n * np.power(_1_plus_alpha, n - 1) + L * n * c * np.power(_1_plus_c_alpha, n - 1)\n    \n    if n > 1:\n        Z_pp = n * (n - 1) * np.power(_1_plus_alpha, n - 2) + L * n * (n - 1) * c**2 * np.power(_1_plus_c_alpha, n - 2)\n    else:\n        Z_pp = 0.0\n\n    dY_d_alpha_num = Z * Z_p + alpha * (Z * Z_pp - Z_p**2)\n    dY_d_alpha_den = n * Z**2\n    \n    if np.abs(dY_d_alpha_den)  1e-12:\n        return np.nan\n\n    dY_d_alpha = dY_d_alpha_num / dY_d_alpha_den\n    return dY_d_alpha / K_R\n\ndef get_slope_for_params(L, c, K_R, n):\n    \"\"\"\n    Model function f(L, c, K_R) that computes the slope dY/dS at S_0.5.\n    This involves finding alpha_0.5 through root finding and then calculating the derivative.\n    \"\"\"\n    try:\n        # Define a robust bracketing interval for the root finder.\n        # The root alpha_0.5 is typically between 1 and 1/c.\n        lower_bound, upper_bound = 1e-9, 1e4 / c\n        # Check if the function crosses 0.5 within the bracket.\n        if mwc_model_Y(upper_bound, n, L, c)  0.5:\n            return np.nan # Root is outside the generous search interval, indicates instability.\n        \n        alpha_05 = brentq(lambda alpha: mwc_model_Y(alpha, n, L, c) - 0.5, lower_bound, upper_bound, xtol=1e-10, rtol=1e-10)\n    except (ValueError, RuntimeError):\n        # brentq fails if root is not bracketed or if other issues arise.\n        return np.nan\n        \n    return mwc_model_slope(alpha_05, n, L, c, K_R)\n\ndef process_case(case):\n    \"\"\"\n    Runs the full analysis for a single test case.\n    \"\"\"\n    N, n, k = case[\"N\"], case[\"n\"], 3\n    L_min, L_max = case[\"L_range\"]\n    c_min, c_max = case[\"c_range\"]\n    KR_min, KR_max = case[\"KR_range\"]\n    epsilon = case[\"epsilon\"]\n    \n    np.random.seed(case[\"seed\"])\n\n    # 1. Sobol Analysis: Sampling and Evaluation\n    base_samples = np.random.rand(N, 2 * k)\n    \n    def transform(samples_col, dist, p_min, p_max):\n        return 10**(np.log10(p_min) + samples_col * (np.log10(p_max) - np.log10(p_min))) if dist == 'log' else p_min + samples_col * (p_max - p_min)\n\n    A = np.column_stack([transform(base_samples[:, 0], 'log', L_min, L_max), \n                           transform(base_samples[:, 1], 'linear', c_min, c_max), \n                           transform(base_samples[:, 2], 'log', KR_min, KR_max)])\n    \n    B = np.column_stack([transform(base_samples[:, 3], 'log', L_min, L_max), \n                           transform(base_samples[:, 4], 'linear', c_min, c_max), \n                           transform(base_samples[:, 5], 'log', KR_min, KR_max)])\n\n    y_A = np.array([get_slope_for_params(L, c, KR, n) for L, c, KR in A])\n    y_B = np.array([get_slope_for_params(L, c, KR, n) for L, c, KR in B])\n\n    y_C_all = np.zeros((N, k))\n    for i in range(k):\n        C_i = np.copy(A)\n        C_i[:, i] = B[:, i]\n        y_C_all[:, i] = np.array([get_slope_for_params(L, c, KR, n) for L, c, KR in C_i])\n\n    valid_mask = ~np.isnan(y_A)  ~np.isnan(y_B)  ~np.any(np.isnan(y_C_all), axis=1)\n    \n    y_A, y_B, y_C_all = y_A[valid_mask], y_B[valid_mask], y_C_all[valid_mask]\n\n    if len(y_A)  20: # Require a minimum number of valid samples\n        return [None, None, False, None]\n\n    # 2. Sobol Index Calculation\n    S, ST = np.zeros(k), np.zeros(k)\n    var_y_A = np.var(y_A)\n    if var_y_A > 1e-12:\n        for i in range(k):\n            S[i] = np.mean(y_B * (y_C_all[:, i] - y_A)) / var_y_A\n            ST[i] = np.mean((y_A - y_C_all[:, i])**2) / (2 * var_y_A)\n\n    top_param_ST = np.argmax(ST)\n    top_param_S = np.argmax(S)\n\n    # 3. Perturbation Validation\n    L_nom = 10**np.mean(np.log10([L_min, L_max]))\n    c_nom = np.mean([c_min, c_max])\n    KR_nom = 10**np.mean(np.log10([KR_min, KR_max]))\n    params_nom = [L_nom, c_nom, KR_nom]\n\n    slope_baseline = get_slope_for_params(*params_nom, n)\n    if np.isnan(slope_baseline):\n        return [int(top_param_ST), int(top_param_S), False, np.nan]\n\n    effect_sizes = np.zeros(k)\n    for i in range(k):\n        params_plus, params_minus = list(params_nom), list(params_nom)\n        params_plus[i] *= (1 + epsilon)\n        params_minus[i] *= (1 - epsilon)\n        slope_plus = get_slope_for_params(*params_plus, n)\n        slope_minus = get_slope_for_params(*params_minus, n)\n        \n        if np.isnan(slope_plus) or np.isnan(slope_minus):\n            effect_sizes[i] = -1.0 # Mark as invalid\n        else:\n            effect_sizes[i] = 0.5 * (np.abs(slope_plus - slope_baseline) + np.abs(slope_minus - slope_baseline))\n    \n    validation_match = False\n    if not np.any(effect_sizes  0):\n        top_param_perturb = np.argmax(effect_sizes)\n        validation_match = (top_param_ST == top_param_perturb)\n\n    return [int(top_param_ST), int(top_param_S), bool(validation_match), float(slope_baseline)]\n\ndef solve():\n    test_cases = [\n        {\"n\": 4, \"L_range\": [10**2, 10**5], \"c_range\": [0.01, 0.5], \"KR_range\": [0.5, 50],\n         \"N\": 1000, \"epsilon\": 0.10, \"seed\": 123},\n        {\"n\": 6, \"L_range\": [10**3, 10**6], \"c_range\": [0.001, 0.2], \"KR_range\": [0.1, 10],\n         \"N\": 1200, \"epsilon\": 0.05, \"seed\": 456},\n        {\"n\": 3, \"L_range\": [10**0, 10**2], \"c_range\": [0.5, 0.99], \"KR_range\": [1, 100],\n         \"N\": 800, \"epsilon\": 0.10, \"seed\": 789}\n    ]\n\n    all_results = [process_case(case) for case in test_cases]\n    \n    # Format the final output string exactly as required\n    output_str = str(all_results).replace(\" \", \"\").replace(\"True\", \"true\").replace(\"False\", \"false\")\n    print(output_str)\n\nsolve()\n\n```"
        }
    ]
}