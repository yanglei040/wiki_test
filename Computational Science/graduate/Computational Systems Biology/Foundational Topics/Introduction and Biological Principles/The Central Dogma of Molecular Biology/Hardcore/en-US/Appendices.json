{
    "hands_on_practices": [
        {
            "introduction": "The fidelity of information transfer is a cornerstone of the central dogma. This first exercise explores the reliability of protein synthesis by modeling it as a series of independent probabilistic events. By applying the principles of Bernoulli trials, you will derive the probability of synthesizing a perfect protein of length $L$ given a small per-codon error rate $p$, and learn how to approximate the impact of these errors using series expansions, a common technique in quantitative biology .",
            "id": "3355092",
            "problem": "A messenger ribonucleic acid (mRNA) of length $L$ codons is translated into a polypeptide by the ribosome. Assume a simplified fidelity model in which, at each codon, a translation error occurs independently with probability $p$ and, conditional on an error, any error event renders the resulting protein nonfunctional. Under these assumptions, the central dogma of molecular biology motivates a Bernoulli-trial description of translation at the codon level, tied to the flow of information from nucleic acid sequence to protein sequence.\n\nStarting from first principles of independent Bernoulli trials and without invoking any pre-derived closed-form expressions, do the following:\n\n- Derive an expression for the probability $P_0$ that the translation of the entire protein is error-free (i.e., no codon suffers an error).\n\n- Using the definition of the natural logarithm $\\ln(\\cdot)$ and a series expansion valid for small $p$ with $|p|1$, derive the cubic-order truncation (retain terms through order $p^3$) of $\\ln P_0$ in terms of $L$ and $p$.\n\nState any convergence conditions you use. Your final answer must consist of two expressions: the exact $P_0$ and the cubic-order truncation of $\\ln P_0$. No numerical evaluation is required, and no units are needed. Do not include any remainder symbols in the final expression; include only the retained terms up to and including order $p^3$.",
            "solution": "The problem statement is critically evaluated for validity prior to attempting a solution.\n\n### Step 1: Extract Givens\n- A messenger ribonucleic acid (mRNA) has a length of $L$ codons.\n- Translation is modeled as a sequence of independent Bernoulli trials, one for each codon.\n- The probability of a translation error at any single codon is $p$.\n- Any single error renders the resulting protein nonfunctional.\n- The first task is to derive an expression for $P_0$, the probability of an error-free translation of the entire mRNA.\n- The second task is to derive the cubic-order truncation of $\\ln P_0$ in terms of $L$ and $p$, using a series expansion for small $p$ where $|p|1$.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded:** The problem is grounded in the central dogma of molecular biology and uses a standard, albeit simplified, probabilistic model for translation fidelity. The use of Bernoulli trials to model independent error events is a common and valid approach in computational systems biology.\n- **Well-Posed:** The problem is well-posed. It provides all necessary parameters ($L$, $p$) and assumptions (independence) to derive the requested quantities. The objectives are clear and lead to unique mathematical expressions.\n- **Objective:** The language is formal, precise, and devoid of subjective or ambiguous terminology.\n\n### Step 3: Verdict and Action\nThe problem is deemed **valid** as it is scientifically grounded, well-posed, and objective. It contains no logical inconsistencies, factual errors, or ambiguities. A solution will be derived following the specified tasks.\n\n### Derivation of the Solution\n\nThe problem asks for two derivations based on a probabilistic model of protein translation.\n\n**Part 1: Derivation of the error-free translation probability, $P_0$**\n\nThe translation of an mRNA of length $L$ codons is modeled as a sequence of $L$ independent Bernoulli trials. For each trial (i.e., for each codon), there are two possible outcomes:\n1.  **Success:** The codon is translated correctly.\n2.  **Failure:** An error occurs during the translation of the codon.\n\nThe probability of an error (failure) at any given codon is given as $p$. The probability of a correct translation (success) at any given codon is therefore the complement, $1-p$.\n\nLet $S_i$ be the event that the $i$-th codon is translated correctly, for $i \\in \\{1, 2, \\dots, L\\}$. The probability of this event is:\n$$P(S_i) = 1-p$$\n\nThe event of an error-free translation of the entire protein corresponds to the correct translation of all $L$ codons. This is the intersection of the events $S_1, S_2, \\dots, S_L$. The probability of this compound event is denoted by $P_0$.\n$$P_0 = P(S_1 \\cap S_2 \\cap \\dots \\cap S_L)$$\n\nThe problem states that the error events at each codon are independent. Consequently, the success events $S_i$ are also independent. For a set of independent events, the probability of their intersection is the product of their individual probabilities.\n$$P_0 = P(S_1) \\times P(S_2) \\times \\dots \\times P(S_L)$$\n\nSubstituting the probability $P(S_i) = 1-p$ for each of the $L$ terms in the product, we have:\n$$P_0 = \\underbrace{(1-p) \\times (1-p) \\times \\dots \\times (1-p)}_{L \\text{ times}}$$\n\nThis simplifies to:\n$$P_0 = (1-p)^L$$\nThis expression represents the probability that a protein of length $L$ codons is synthesized without any errors, given a per-codon error probability of $p$.\n\n**Part 2: Derivation of the cubic-order truncation of $\\ln P_0$**\n\nWe begin with the expression for $P_0$ derived above and take its natural logarithm:\n$$\\ln P_0 = \\ln((1-p)^L)$$\n\nUsing the logarithmic property $\\ln(a^b) = b \\ln(a)$, we can bring the exponent $L$ to the front:\n$$\\ln P_0 = L \\ln(1-p)$$\n\nThe problem requires a series expansion for small $p$, specifically for $|p|1$. The Maclaurin series for the natural logarithm function $\\ln(1+x)$ is given by:\n$$\\ln(1+x) = \\sum_{n=1}^{\\infty} (-1)^{n-1} \\frac{x^n}{n} = x - \\frac{x^2}{2} + \\frac{x^3}{3} - \\frac{x^4}{4} + \\dots$$\nThis series converges for $-1  x \\le 1$.\n\nTo find the series for $\\ln(1-p)$, we substitute $x = -p$ into the expansion. The condition on $p$, $|p|1$, ensures that $x=-p$ is within the interval of convergence $(-1, 1)$.\n$$\\ln(1-p) = (-p) - \\frac{(-p)^2}{2} + \\frac{(-p)^3}{3} - \\frac{(-p)^4}{4} + \\dots$$\nSimplifying the terms yields:\n$$\\ln(1-p) = -p - \\frac{p^2}{2} - \\frac{p^3}{3} - \\frac{p^4}{4} - \\dots$$\nOr, in summation notation:\n$$\\ln(1-p) = -\\sum_{n=1}^{\\infty} \\frac{p^n}{n}$$\n\nThe problem asks for the cubic-order truncation, which means we retain all terms up to and including the term with $p^3$.\n$$\\ln(1-p) \\approx -p - \\frac{p^2}{2} - \\frac{p^3}{3}$$\n\nFinally, we substitute this truncated series back into our expression for $\\ln P_0$:\n$$\\ln P_0 = L \\ln(1-p) \\approx L \\left( -p - \\frac{p^2}{2} - \\frac{p^3}{3} \\right)$$\nDistributing the factor of $L$ gives the final expression for the cubic-order approximation of $\\ln P_0$:\n$$\\ln P_0 \\approx -Lp - \\frac{Lp^2}{2} - \\frac{Lp^3}{3}$$\nThis approximation is valid for small values of the error probability $p$.\n\nThe two required expressions have been derived from first principles as requested.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n(1-p)^L  -Lp - \\frac{Lp^2}{2} - \\frac{Lp^3}{3}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "Beyond fidelity, the efficiency of gene expression is governed by kinetics. This practice delves into the speed of translation, demonstrating how it is influenced by the availability of cellular resources such as transfer RNAs (tRNAs). You will develop a model that connects tRNA abundance directly to the rate of ribosome elongation, applying it to a practical scenario of codon optimization to see how synonymous codon changes can dramatically alter the time required to produce a protein .",
            "id": "3355123",
            "problem": "Consider a minimal stochastic model of ribosome-driven translation elongation within the Central Dogma of Molecular Biology, in which a ribosome decodes a messenger ribonucleic acid (mRNA) one codon at a time using cognate transfer ribonucleic acid (tRNA). Assume each codon-specific elongation step is memoryless (exponentially distributed waiting time) with a codon-dependent rate. Let the instantaneous elongation rate for codon $c$, denoted $k_{e}(c)$, satisfy $k_{e}(c) = k_{0}\\, a_{c}$, where $a_{c}$ is the relative abundance of cognate tRNA for codon $c$, and $k_{0}$ is a ribosome- and condition-specific proportionality constant. You may assume independence of successive elongation steps and stationarity of $a_{c}$ over the timescale of translation.\n\nStarting from these modeling assumptions and fundamental facts about exponential waiting-time processes and linearity of expectation, derive an analytic expression for the expected total elongation time for an mRNA with codon sequence $\\{c_{j}\\}_{j=1}^{n}$. Then, evaluate this expression numerically for the following scenario.\n\nLet $n = 12$ and the original codon sequence be\n$\\{\\text{AAA}, \\text{GCT}, \\text{CTT}, \\text{GAA}, \\text{TTT}, \\text{ATA}, \\text{CGT}, \\text{TCT}, \\text{GGT}, \\text{CAA}, \\text{TTA}, \\text{GCA}\\}$.\nA set of synonymous substitutions yields the optimized sequence\n$\\{\\text{AAG}, \\text{GCC}, \\text{CTG}, \\text{GAG}, \\text{TTC}, \\text{ATT}, \\text{CGC}, \\text{TCC}, \\text{GGC}, \\text{CAG}, \\text{CTG}, \\text{GCC}\\}$.\nUse $k_{0} = 20$ in units of $\\text{s}^{-1}$.\n\nCodon-specific tRNA relative abundances $a_{c}$ (dimensionless) are provided below:\n- $\\text{AAA}: 0.65$, $\\text{AAG}: 0.95$\n- $\\text{GCT}: 0.50$, $\\text{GCC}: 0.90$, $\\text{GCA}: 0.70$\n- $\\text{CTT}: 0.40$, $\\text{CTG}: 1.10$\n- $\\text{GAA}: 0.60$, $\\text{GAG}: 0.85$\n- $\\text{TTT}: 0.45$, $\\text{TTC}: 0.80$\n- $\\text{ATA}: 0.30$, $\\text{ATT}: 0.75$\n- $\\text{CGT}: 0.35$, $\\text{CGC}: 0.88$\n- $\\text{TCT}: 0.55$, $\\text{TCC}: 0.92$\n- $\\text{GGT}: 0.50$, $\\text{GGC}: 1.00$\n- $\\text{CAA}: 0.48$, $\\text{CAG}: 0.89$\n- $\\text{TTA}: 0.42$\n\nCompute the expected total elongation time before substitutions, $T_{\\text{before}}$, and after substitutions, $T_{\\text{after}}$, and report the change $\\Delta T = T_{\\text{after}} - T_{\\text{before}}$ in $\\text{s}$. Round your final reported value of $\\Delta T$ to four significant figures. Express the answer in $\\text{s}$.",
            "solution": "We begin from the Central Dogma workflow where a ribosome translates an mRNA into a polypeptide by decoding codons using cognate tRNA. Under the stated assumptions, each codon-specific elongation step has a memoryless waiting time, modeled as an exponential random variable. For codon $c$, the waiting time $X_{c}$ has rate $k_{e}(c)$, so $X_{c} \\sim \\text{Exp}(k_{e}(c))$. A well-tested fact is that for an exponential random variable with rate $k$, the expected value is $\\mathbb{E}[X] = \\frac{1}{k}$. Another foundational property is linearity of expectation, which does not require independence: for random variables $X_{1},\\dots,X_{n}$, $\\mathbb{E}\\left[\\sum_{j=1}^{n} X_{j}\\right] = \\sum_{j=1}^{n} \\mathbb{E}[X_{j}]$. Independence here supports modeling assumptions but is not required for the expectation summation.\n\nLet the mRNA codon sequence be $\\{c_{j}\\}_{j=1}^{n}$. The total elongation time $T$ is the sum of codon-specific decoding times, $T = \\sum_{j=1}^{n} X_{c_{j}}$. Using $\\mathbb{E}[X_{c_{j}}] = \\frac{1}{k_{e}(c_{j})}$, we obtain\n$$\n\\mathbb{E}[T] \\;=\\; \\sum_{j=1}^{n} \\frac{1}{k_{e}(c_{j})}.\n$$\nBy the model, $k_{e}(c) = k_{0}\\, a_{c}$, where $a_{c}$ is the codon’s cognate tRNA relative abundance and $k_{0}$ captures ribosome- and condition-specific proportionality. Substituting yields the analytic expression\n$$\n\\mathbb{E}[T] \\;=\\; \\sum_{j=1}^{n} \\frac{1}{k_{0}\\, a_{c_{j}}}\n\\;=\\; \\frac{1}{k_{0}} \\sum_{j=1}^{n} \\frac{1}{a_{c_{j}}}.\n$$\n\nWe now evaluate this for the specified sequences with $n = 12$ and $k_{0} = 20$ in units of $\\text{s}^{-1}$.\n\nFor the original sequence $\\{\\text{AAA}, \\text{GCT}, \\text{CTT}, \\text{GAA}, \\text{TTT}, \\text{ATA}, \\text{CGT}, \\text{TCT}, \\text{GGT}, \\text{CAA}, \\text{TTA}, \\text{GCA}\\}$, we compute\n$$\nT_{\\text{before}} \\;=\\; \\frac{1}{20} \\left(\n\\frac{1}{0.65} + \\frac{1}{0.50} + \\frac{1}{0.40} + \\frac{1}{0.60} + \\frac{1}{0.45} + \\frac{1}{0.30} + \\frac{1}{0.35} + \\frac{1}{0.55} + \\frac{1}{0.50} + \\frac{1}{0.48} + \\frac{1}{0.42} + \\frac{1}{0.70}\n\\right).\n$$\nEvaluate the reciprocals:\n- $\\frac{1}{0.65} = 1.53846153846$,\n- $\\frac{1}{0.50} = 2$,\n- $\\frac{1}{0.40} = 2.5$,\n- $\\frac{1}{0.60} = 1.66666666667$,\n- $\\frac{1}{0.45} = 2.22222222222$,\n- $\\frac{1}{0.30} = 3.33333333333$,\n- $\\frac{1}{0.35} = 2.85714285714$,\n- $\\frac{1}{0.55} = 1.81818181818$,\n- $\\frac{1}{0.50} = 2$,\n- $\\frac{1}{0.48} = 2.08333333333$,\n- $\\frac{1}{0.42} = 2.38095238095$,\n- $\\frac{1}{0.70} = 1.42857142857$.\nSumming these gives\n$$\n\\sum_{j=1}^{12} \\frac{1}{a_{c_{j}}} \\;=\\; 25.82886557885,\n$$\nso\n$$\nT_{\\text{before}} \\;=\\; \\frac{25.82886557885}{20} \\;=\\; 1.2914432789425.\n$$\n\nFor the optimized sequence $\\{\\text{AAG}, \\text{GCC}, \\text{CTG}, \\text{GAG}, \\text{TTC}, \\text{ATT}, \\text{CGC}, \\text{TCC}, \\text{GGC}, \\text{CAG}, \\text{CTG}, \\text{GCC}\\}$, we compute\n$$\nT_{\\text{after}} \\;=\\; \\frac{1}{20} \\left(\n\\frac{1}{0.95} + \\frac{1}{0.90} + \\frac{1}{1.10} + \\frac{1}{0.85} + \\frac{1}{0.80} + \\frac{1}{0.75} + \\frac{1}{0.88} + \\frac{1}{0.92} + \\frac{1}{1.00} + \\frac{1}{0.89} + \\frac{1}{1.10} + \\frac{1}{0.90}\n\\right).\n$$\nEvaluate the reciprocals:\n- $\\frac{1}{0.95} = 1.05263157895$,\n- $\\frac{1}{0.90} = 1.11111111111$,\n- $\\frac{1}{1.10} = 0.909090909091$,\n- $\\frac{1}{0.85} = 1.17647058824$,\n- $\\frac{1}{0.80} = 1.25$,\n- $\\frac{1}{0.75} = 1.33333333333$,\n- $\\frac{1}{0.88} = 1.13636363636$,\n- $\\frac{1}{0.92} = 1.08695652174$,\n- $\\frac{1}{1.00} = 1$,\n- $\\frac{1}{0.89} = 1.12359550562$,\n- $\\frac{1}{1.10} = 0.909090909091$,\n- $\\frac{1}{0.90} = 1.11111111111$.\nSumming these gives\n$$\n\\sum_{j=1}^{12} \\frac{1}{a_{c_{j}}} \\;=\\; 13.19975520464,\n$$\nso\n$$\nT_{\\text{after}} \\;=\\; \\frac{13.19975520464}{20} \\;=\\; 0.6599877602320.\n$$\n\nThe change in expected total elongation time is\n$$\n\\Delta T \\;=\\; T_{\\text{after}} - T_{\\text{before}} \\;=\\; 0.6599877602320 \\,-\\, 1.2914432789425 \\;=\\; -0.6314555187105.\n$$\nRounded to four significant figures, $\\Delta T = -0.6315$ in $\\text{s}$.",
            "answer": "$$\\boxed{-0.6315}$$"
        },
        {
            "introduction": "To gain a holistic understanding of gene expression, we must integrate its individual stages into a cohesive system. This final practice challenges you to model the entire central dogma pathway—from promoter activation to transcription and translation—using the powerful framework of queuing theory. By conceptualizing the process as a tandem queue, you will learn to calculate the utilization $\\rho_i$ of each stage, identify systemic bottlenecks, and assess the overall stability of the gene expression production line, a core skill in computational systems biology .",
            "id": "3355173",
            "problem": "Consider a three-stage abstraction of the Central Dogma of Molecular Biology, framed as a tandem queue in computational systems biology. The stages are: (i) DNA promoter switching that controls transcription initiation, (ii) messenger ribonucleic acid (mRNA) synthesis by ribonucleic acid polymerase, and (iii) protein synthesis by ribosomes modeled by the Totally Asymmetric Simple Exclusion Process (TASEP). The objective is to identify bottlenecks by computing queue utilizations and to assess stability of the tandem system under steady-state conditions. Your program must compute, for each provided test case, the utilizations of the three stages and determine the bottleneck station and stability flag, then aggregate results as specified.\n\nUse the following scientifically grounded base assumptions and definitions:\n\n- The Central Dogma states that deoxyribonucleic acid (DNA) is transcribed into messenger ribonucleic acid (mRNA), which is translated into protein.\n- The promoter toggles between $ON$ and $OFF$ states with rates $k_\\mathrm{on}$ and $k_\\mathrm{off}$ (units $\\mathrm{s}^{-1}$). At steady state for a two-state continuous-time Markov process, the fraction of time in the $ON$ state is $P_\\mathrm{ON} = \\dfrac{k_\\mathrm{on}}{k_\\mathrm{on} + k_\\mathrm{off}}$.\n- When the promoter is $ON$, transcription initiation events occur as a Poisson process with maximal rate $r_\\mathrm{tx}$ (units $\\mathrm{s}^{-1}$), yielding an average transcription initiation rate $\\lambda_m = P_\\mathrm{ON}\\, r_\\mathrm{tx}$ (units $\\mathrm{s}^{-1}$).\n- The transcription elongation and termination are modeled as a single-server queue with service rate $\\mu_m$ (units $\\mathrm{s}^{-1}$) per transcript completion. The stage-$2$ utilization is $\\rho_2 = \\lambda_m / \\mu_m$.\n- Ribosome translation is approximated by the Totally Asymmetric Simple Exclusion Process (TASEP) at low initiation density, where the mean hopping rate per codon is $p$ (units $\\mathrm{codons}\\,\\mathrm{s}^{-1}$) and the polypeptide length is $L$ (units $\\mathrm{codons}$). Under the low-density regime, the effective service rate for completing one protein on one mRNA is approximated by $\\mu_p = p / L$ (units $\\mathrm{s}^{-1}$), yielding stage-$3$ utilization $\\rho_3 = \\lambda_m / \\mu_p$.\n- For diagnostic completeness, treat the promoter gate as a stage-$1$ resource with a utilization proxy $\\rho_1 = P_\\mathrm{ON}$.\n- Define the bottleneck as the station index $i \\in \\{1,2,3\\}$ whose utilization $\\rho_i$ is maximal; in case of ties, choose the smallest index.\n- Define the tandem system as stable if and only if $\\rho_2  1$ and $\\rho_3  1$. Note that $\\rho_1 \\le 1$ by definition and does not contribute to instability.\n\nYour task is to implement a program that, for each test case, computes the list $[\\rho_1, \\rho_2, \\rho_3, i_\\mathrm{bottleneck}, \\mathrm{stable}]$, where $\\rho_1$, $\\rho_2$, and $\\rho_3$ are floats, $i_\\mathrm{bottleneck}$ is an integer in $\\{1,2,3\\}$, and $\\mathrm{stable}$ is a boolean. No physical angles are involved. Rates must be handled consistently in $\\mathrm{s}^{-1}$ for $k_\\mathrm{on}$, $k_\\mathrm{off}$, $r_\\mathrm{tx}$, and $\\mu_m$, in $\\mathrm{codons}\\,\\mathrm{s}^{-1}$ for $p$, and in $\\mathrm{codons}$ for $L$.\n\nUse the following test suite of parameter sets to ensure coverage of typical and edge-case behaviors:\n\n- Test case $1$ (balanced utilization): $k_\\mathrm{on} = 0.05\\,\\mathrm{s}^{-1}$, $k_\\mathrm{off} = 0.10\\,\\mathrm{s}^{-1}$, $r_\\mathrm{tx} = 0.10\\,\\mathrm{s}^{-1}$, $\\mu_m = 0.05\\,\\mathrm{s}^{-1}$, $p = 15\\,\\mathrm{codons}\\,\\mathrm{s}^{-1}$, $L = 300\\,\\mathrm{codons}$.\n- Test case $2$ (translation-limited): $k_\\mathrm{on} = 0.05\\,\\mathrm{s}^{-1}$, $k_\\mathrm{off} = 0.10\\,\\mathrm{s}^{-1}$, $r_\\mathrm{tx} = 0.10\\,\\mathrm{s}^{-1}$, $\\mu_m = 0.05\\,\\mathrm{s}^{-1}$, $p = 5\\,\\mathrm{codons}\\,\\mathrm{s}^{-1}$, $L = 300\\,\\mathrm{codons}$.\n- Test case $3$ (transcription-limited): $k_\\mathrm{on} = 0.05\\,\\mathrm{s}^{-1}$, $k_\\mathrm{off} = 0.10\\,\\mathrm{s}^{-1}$, $r_\\mathrm{tx} = 0.10\\,\\mathrm{s}^{-1}$, $\\mu_m = 0.02\\,\\mathrm{s}^{-1}$, $p = 15\\,\\mathrm{codons}\\,\\mathrm{s}^{-1}$, $L = 300\\,\\mathrm{codons}$.\n- Test case $4$ (nearly always $ON$, high throughput demand): $k_\\mathrm{on} = 10\\,\\mathrm{s}^{-1}$, $k_\\mathrm{off} = 0.01\\,\\mathrm{s}^{-1}$, $r_\\mathrm{tx} = 1\\,\\mathrm{s}^{-1}$, $\\mu_m = 0.10\\,\\mathrm{s}^{-1}$, $p = 50\\,\\mathrm{codons}\\,\\mathrm{s}^{-1}$, $L = 100\\,\\mathrm{codons}$.\n- Test case $5$ (boundary condition at $\\rho_3 = 1$): $k_\\mathrm{on} = 0.20\\,\\mathrm{s}^{-1}$, $k_\\mathrm{off} = 0.20\\,\\mathrm{s}^{-1}$, $r_\\mathrm{tx} = 0.05\\,\\mathrm{s}^{-1}$, $\\mu_m = 0.10\\,\\mathrm{s}^{-1}$, $p = 10\\,\\mathrm{codons}\\,\\mathrm{s}^{-1}$, $L = 400\\,\\mathrm{codons}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each test case, output the list $[\\rho_1, \\rho_2, \\rho_3, i_\\mathrm{bottleneck}, \\mathrm{stable}]$, and aggregate all five test case results into one list, for example $[[\\dots],[\\dots],[\\dots],[\\dots],[\\dots]]$ in a single line with comma separators and square brackets.",
            "solution": "The user-provided problem has been validated and found to be scientifically grounded, well-posed, and self-contained. The model is a recognized simplification in computational systems biology, employing principles from Markov processes and queuing theory to abstract the Central Dogma. All parameters, definitions, and constraints are clearly specified, forming a solvable computational problem.\n\nThe solution proceeds by systematically calculating the required metrics for each test case based on the provided definitions. The process involves a step-by-step evaluation of a three-stage tandem queue representing gene expression.\n\n**Step 1: Stage-$1$ Utilization (Promoter Gating)**\n\nThe first stage models the stochastic switching of a gene's promoter between an $ON$ and an $OFF$ state. This is described as a two-state continuous-time Markov process with transition rates $k_\\mathrm{on}$ (for $OFF \\rightarrow ON$) and $k_\\mathrm{off}$ (for $ON \\rightarrow OFF$), both in units of $\\mathrm{s}^{-1}$.\n\nAt steady state, the fraction of time the promoter spends in the $ON$ state, $P_\\mathrm{ON}$, is given by:\n$$P_\\mathrm{ON} = \\frac{k_\\mathrm{on}}{k_\\mathrm{on} + k_\\mathrm{off}}$$\nThis quantity is dimensionless. As per the problem definition, this probability serves as a proxy for the utilization of the promoter resource, denoted as $\\rho_1$.\n$$\\rho_1 = P_\\mathrm{ON}$$\n\n**Step 2: Stage-$2$ Utilization (mRNA Synthesis)**\n\nThe second stage models the transcription of DNA into messenger RNA (mRNA). Transcription initiation is a Poisson process that can only occur when the promoter is in the $ON$ state. The maximal rate of initiation is $r_\\mathrm{tx}$ (in $\\mathrm{s}^{-1}$). The average rate of transcription initiation, $\\lambda_m$, is therefore the maximal rate modulated by the probability of the promoter being active:\n$$\\lambda_m = P_\\mathrm{ON} \\cdot r_\\mathrm{tx}$$\nThe units of $\\lambda_m$ are $\\mathrm{s}^{-1}$.\n\nThe subsequent processes of mRNA elongation and termination are modeled as a single-server queue with a service rate $\\mu_m$ (in $\\mathrm{s}^{-1}$), which represents the rate of completing one mRNA transcript. The utilization of this transcription machinery, $\\rho_2$, is the ratio of the arrival rate of initiation events ($\\lambda_m$) to the service rate of transcript completion ($\\mu_m$), a standard result from queuing theory.\n$$\\rho_2 = \\frac{\\lambda_m}{\\mu_m}$$\nThis utilization is a dimensionless quantity.\n\n**Step 3: Stage-$3$ Utilization (Protein Synthesis)**\n\nThe third stage models the translation of mRNA into protein by ribosomes. This process is approximated by the Totally Asymmetric Simple Exclusion Process (TASEP). In the low-density regime specified, the effective service rate for completing one polypeptide chain, $\\mu_p$, can be calculated. It depends on the mean hopping rate of a ribosome along the mRNA, $p$ (in $\\mathrm{codons}\\,\\mathrm{s}^{-1}$), and the length of the polypeptide to be synthesized, $L$ (in $\\mathrm{codons}$). The time to traverse the mRNA is approximately $L/p$, so the rate of completion is the reciprocal:\n$$\\mu_p = \\frac{p}{L}$$\nThe units of $\\mu_p$ are $\\mathrm{s}^{-1}$.\n\nThe arrival rate of tasks (i.e., new translations) to this stage is assumed to be the steady-state output rate from the transcription stage, which equals the transcription initiation rate $\\lambda_m$. Therefore, the utilization of the translation machinery, $\\rho_3$, is the ratio of the arrival rate $\\lambda_m$ to the protein synthesis service rate $\\mu_p$:\n$$\\rho_3 = \\frac{\\lambda_m}{\\mu_p}$$\nThis utilization is also dimensionless.\n\n**Step 4: Bottleneck Identification**\n\nThe bottleneck of the three-stage system is defined as the station with the highest utilization. The set of utilizations is $\\{\\rho_1, \\rho_2, \\rho_3\\}$. The bottleneck station index, $i_\\mathrm{bottleneck}$, is the index $i \\in \\{1, 2, 3\\}$ that maximizes $\\rho_i$.\n$$i_\\mathrm{bottleneck} = \\underset{i \\in \\{1, 2, 3\\}}{\\mathrm{argmax}} \\{\\rho_i\\}$$\nIn the event of a tie in utilization values, the problem specifies that the smallest station index should be chosen. For instance, if $\\rho_2 = \\rho_3$ and this value is the maximum, the bottleneck is station $2$.\n\n**Step 5: System Stability Analysis**\n\nThe stability of the tandem queuing system is determined by the utilizations of the processing stages (stages $2$ and $3$). According to queuing theory, a queue is stable if its utilization is strictly less than $1$. If utilization is greater than or equal to $1$, the queue length will grow indefinitely, leading to instability. The problem defines the system as stable if and only if both stage-$2$ and stage-$3$ utilizations are below this threshold.\n$$\\mathrm{stable} = (\\rho_2  1) \\land (\\rho_3  1)$$\nThe stage-$1$ utilization, $\\rho_1 = P_\\mathrm{ON}$, is a probability and is therefore bounded by $0$ and $1$ ($0 \\le \\rho_1 \\le 1$). It does not represent a queue that can grow infinitely and is correctly excluded from the stability condition.\n\n**Computational Implementation**\n\nA program is implemented to perform these calculations for each of the five provided test cases. For each case, it computes the five-element list $[\\rho_1, \\rho_2, \\rho_3, i_\\mathrm{bottleneck}, \\mathrm{stable}]$ and aggregates these lists into a final result.\n```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes utilizations, bottleneck, and stability for a three-stage model of gene expression.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (k_on, k_off, r_tx, mu_m, p, L)\n    test_cases = [\n        # Test case 1 (balanced utilization)\n        (0.05, 0.10, 0.10, 0.05, 15, 300),\n        # Test case 2 (translation-limited)\n        (0.05, 0.10, 0.10, 0.05, 5, 300),\n        # Test case 3 (transcription-limited)\n        (0.05, 0.10, 0.10, 0.02, 15, 300),\n        # Test case 4 (nearly always ON, high throughput demand)\n        (10.0, 0.01, 1.0, 0.10, 50, 100),\n        # Test case 5 (boundary condition at rho_3 = 1)\n        (0.20, 0.20, 0.05, 0.10, 10, 400),\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        k_on, k_off, r_tx, mu_m, p, L = case\n\n        # Step 1: Stage-1 Utilization (Promoter Gating)\n        # P_ON is the fraction of time the promoter is in the ON state.\n        # This is also the proxy for stage-1 utilization, rho_1.\n        p_on = k_on / (k_on + k_off)\n        rho_1 = p_on\n\n        # Step 2: Stage-2 Utilization (mRNA Synthesis)\n        # lambda_m is the average transcription initiation rate.\n        lambda_m = p_on * r_tx\n        # rho_2 is the utilization of the transcription machinery.\n        rho_2 = lambda_m / mu_m\n\n        # Step 3: Stage-3 Utilization (Protein Synthesis)\n        # mu_p is the effective service rate for protein completion.\n        mu_p = p / L\n        # rho_3 is the utilization of the translation machinery.\n        rho_3 = lambda_m / mu_p\n\n        utilizations = np.array([rho_1, rho_2, rho_3])\n\n        # Step 4: Bottleneck Identification\n        # Find the index of the maximum utilization.\n        # np.argmax returns the first occurrence in case of a tie, which matches the rule.\n        # Add 1 to convert from 0-based index to 1-based station index.\n        i_bottleneck = int(np.argmax(utilizations) + 1)\n\n        # Step 5: System Stability Analysis\n        # System is stable if and only if rho_2  1 and rho_3  1.\n        is_stable = (rho_2  1.0) and (rho_3  1.0)\n\n        # Assemble the results for the current test case.\n        case_result = [rho_1, rho_2, rho_3, i_bottleneck, is_stable]\n        all_results.append(case_result)\n\n    # Final print statement in the exact required format.\n    # The format is a string representation of a list of lists.\n    # The example f\"[{','.join(map(str, results))}]\" works perfectly for this.\n    print(f\"[{','.join(map(str, all_results))}]\".replace(\" \", \"\"))\n\n# solve() is not called here to prevent execution in this context,\n# but it is the function that generates the answer.\n```",
            "answer": "[[0.3333333333333333,0.6666666666666666,0.6666666666666666,2,True],[0.3333333333333333,0.6666666666666666,2.0,3,False],[0.3333333333333333,1.6666666666666665,0.6666666666666666,2,False],[0.999000999000999,9.99000999000999,1.9980019980019982,2,False],[0.5,0.25,1.0,3,False]]"
        }
    ]
}