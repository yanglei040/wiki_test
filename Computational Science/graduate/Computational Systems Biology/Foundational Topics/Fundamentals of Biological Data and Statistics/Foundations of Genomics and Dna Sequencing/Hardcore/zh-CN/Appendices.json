{
    "hands_on_practices": [
        {
            "introduction": "测序仪的原始输出并非直接是 A、C、G、T 这些碱基字母，而是必须经过解读的模拟信号。本练习将通过构建一个基础的碱基识别模型来揭开这一过程的神秘面纱，让您亲身体验如何运用概率模型将原始光信号转化为带有质量分数的碱基序列。通过这个实践 ()，您将深入理解测序数据的统计本质，以及碱基质量分数 (Phred score) 的真正来源。",
            "id": "3310871",
            "problem": "给定一个用于合成法测序 (sequencing-by-synthesis) 信号的概率模型，该模型在一个四通道 Illumina 系统中工作。其中，每个循环在对应于核苷酸腺嘌呤 (A)、胞嘧啶 (C)、鸟嘌呤 (G) 和胸腺嘧啶 (T) 的通道空间中发射一个强度向量。在循环索引为 $i$ 时，观测到的强度向量表示为 $\\mathbf{y}_i \\in \\mathbb{R}^4$，每个循环的标量尺度因子为 $s_i \\in \\mathbb{R}_{\\ge 0}$，背景基线向量为 $\\boldsymbol{\\beta} \\in \\mathbb{R}^4$，各通道的噪声方差汇集在对角协方差 $\\operatorname{diag}(\\boldsymbol{\\sigma}^2)$ 中，其中 $\\boldsymbol{\\sigma}^2 \\in \\mathbb{R}^4_{>0}$。校准（串扰）矩阵 $\\mathbf{C} \\in \\mathbb{R}^{4 \\times 4}$ 将一个独热编码的碱基向量映射到预期的归一化通道均值，因此碱基 $b \\in \\{A,C,G,T\\}$ 的预期平均强度是列向量 $\\boldsymbol{\\mu}_b = \\mathbf{C}_{:,b}$。生成信号模型由缩放后的均值、基线以及加性噪声之和给出：\n$$\n\\mathbf{y}_i = s_i \\boldsymbol{\\mu}_b + \\boldsymbol{\\beta} + \\boldsymbol{\\varepsilon}_i, \\quad \\boldsymbol{\\varepsilon}_i \\sim \\mathcal{N}\\!\\left(\\mathbf{0}, \\operatorname{diag}(\\boldsymbol{\\sigma}^2)\\right).\n$$\n假设通道噪声是独立且服从高斯分布的，并且以每个循环的碱基为条件，各个循环是独立的。碱基的先验概率集合为 $\\mathbf{p} = [p(A),p(C),p(G),p(T)]$，其中 $p(A)+p(C)+p(G)+p(T)=1$ 且对于每个碱基 $b$ 都有 $p(b)>0$。\n\n您的任务是为每个循环 $i$ 计算：\n1. 最大似然碱基判读，定义为在所述高斯模型下使似然度 $p(\\mathbf{y}_i \\mid b)$ 最大化的碱基 $\\hat{b}_i$。如果在容忍度阈值 $\\tau$ 内出现相等情况，则选择按字典序 $A \\rightarrow 0, C \\rightarrow 1, G \\rightarrow 2, T \\rightarrow 3$ 具有最小索引的碱基。\n2. 所选碱基判读的 Phred 质量得分 $Q_i$，其定义为从后验错误概率进行的标准转换，\n$$\nQ_i = -10 \\log_{10}\\!\\left(P_{\\text{err},i}\\right),\n$$\n其中 $P_{\\text{err},i} = 1 - P(\\hat{b}_i \\mid \\mathbf{y}_i)$，而 $P(b \\mid \\mathbf{y}_i)$ 使用贝叶斯定理，结合提供的先验概率 $\\mathbf{p}$ 和上述生成模型所隐含的高斯似然度 $p(\\mathbf{y}_i \\mid b)$ 来计算。对概率进行数值稳定的计算，当 $P_{\\text{err},i}$ 在数值上为零时，将其视为 $10^{-300}$ 以避免出现未定义的对数。将所有质量得分表示为四舍五入到两位小数的浮点数。\n\n碱基索引如下：$A \\rightarrow 0, C \\rightarrow 1, G \\rightarrow 2, T \\rightarrow 3$。在此问题中，强度没有物理单位。\n\n实现一个完整的程序，给定以下参数集的测试套件，生成指定的输出。对于每个测试用例，输出一个包含两个列表的对：第一个列表包含每个循环的碱基判读，表示为 $\\{0,1,2,3\\}$ 中的整数；第二个列表包含相应的 Q 得分，表示为四舍五入到两位小数的浮点数。将所有提供的测试用例的结果聚合到单行中，作为一个用方括号括起来的逗号分隔列表，其中顶层列表的每个元素对应一个测试用例，并且本身就是一个如上所述的双元素列表。\n\n对所有测试用例使用 $10^{-12}$ 的相等容忍度 $\\tau$。\n\n测试套件：\n- 测试用例 1 (理想情况，低噪声):\n  - 校准矩阵:\n    $$\n    \\mathbf{C}^{(1)} = \\begin{bmatrix}\n    1.0  0.1  0.1  0.1 \\\\\n    0.1  1.0  0.1  0.1 \\\\\n    0.1  0.1  1.0  0.1 \\\\\n    0.1  0.1  0.1  1.0\n    \\end{bmatrix}.\n    $$\n  - 方差: $\\boldsymbol{\\sigma}^{2\\,(1)} = [0.05, 0.05, 0.05, 0.05]$。\n  - 基线: $\\boldsymbol{\\beta}^{(1)} = [0.0, 0.0, 0.0, 0.0]$。\n  - 每个循环的尺度: $\\mathbf{s}^{(1)} = [1.0, 1.0, 1.0, 1.0, 1.0]$。\n  - 先验概率: $\\mathbf{p}^{(1)} = [0.25, 0.25, 0.25, 0.25]$。\n  - 观测值:\n    $$\n    \\mathbf{Y}^{(1)} = \\begin{bmatrix}\n    1.20  0.10  0.10  0.10 \\\\\n    0.10  1.10  0.10  0.10 \\\\\n    0.20  0.10  1.30  0.10 \\\\\n    0.10  0.10  0.10  1.25 \\\\\n    0.30  0.20  0.90  0.20\n    \\end{bmatrix}.\n    $$\n- 测试用例 2 (高噪声，模糊信号):\n  - 校准矩阵:\n    $$\n    \\mathbf{C}^{(2)} = \\begin{bmatrix}\n    1.0  0.1  0.1  0.1 \\\\\n    0.1  1.0  0.1  0.1 \\\\\n    0.1  0.1  1.0  0.1 \\\\\n    0.1  0.1  0.1  1.0\n    \\end{bmatrix}.\n    $$\n  - 方差: $\\boldsymbol{\\sigma}^{2\\,(2)} = [0.5, 0.5, 0.5, 0.5]$。\n  - 基线: $\\boldsymbol{\\beta}^{(2)} = [0.0, 0.0, 0.0, 0.0]$。\n  - 每个循环的尺度: $\\mathbf{s}^{(2)} = [1.0, 1.0, 1.0]$。\n  - 先验概率: $\\mathbf{p}^{(2)} = [0.25, 0.25, 0.25, 0.25]$。\n  - 观测值:\n    $$\n    \\mathbf{Y}^{(2)} = \\begin{bmatrix}\n    0.50  0.50  0.50  0.50 \\\\\n    0.60  0.50  0.50  0.40 \\\\\n    0.50  0.40  0.60  0.50\n    \\end{bmatrix}.\n    $$\n- 测试用例 3 (非均匀先验概率，异构校准和方差):\n  - 校准矩阵:\n    $$\n    \\mathbf{C}^{(3)} = \\begin{bmatrix}\n    0.9  0.2  0.2  0.2 \\\\\n    0.2  0.9  0.3  0.2 \\\\\n    0.2  0.3  0.9  0.2 \\\\\n    0.2  0.2  0.2  0.9\n    \\end{bmatrix}.\n    $$\n  - 方差: $\\boldsymbol{\\sigma}^{2\\,(3)} = [0.1, 0.2, 0.1, 0.2]$。\n  - 基线: $\\boldsymbol{\\beta}^{(3)} = [0.05, 0.05, 0.05, 0.05]$。\n  - 每个循环的尺度: $\\mathbf{s}^{(3)} = [1.0, 0.8, 1.2]$。\n  - 先验概率: $\\mathbf{p}^{(3)} = [0.10, 0.40, 0.40, 0.10]$。\n  - 观测值:\n    $$\n    \\mathbf{Y}^{(3)} = \\begin{bmatrix}\n    0.95  0.13  0.10  0.10 \\\\\n    0.20  0.75  0.30  0.20 \\\\\n    0.20  0.25  1.10  0.20\n    \\end{bmatrix}.\n    $$\n- 测试用例 4 (边界情况：零强度，低噪声):\n  - 校准矩阵:\n    $$\n    \\mathbf{C}^{(4)} = \\begin{bmatrix}\n    1.0  0.1  0.1  0.1 \\\\\n    0.1  1.0  0.1  0.1 \\\\\n    0.1  0.1  1.0  0.1 \\\\\n    0.1  0.1  0.1  1.0\n    \\end{bmatrix}.\n    $$\n  - 方差: $\\boldsymbol{\\sigma}^{2\\,(4)} = [0.05, 0.05, 0.05, 0.05]$。\n  - 基线: $\\boldsymbol{\\beta}^{(4)} = [0.0, 0.0, 0.0, 0.0]$。\n  - 每个循环的尺度: $\\mathbf{s}^{(4)} = [1.0, 1.0]$。\n  - 先验概率: $\\mathbf{p}^{(4)} = [0.25, 0.25, 0.25, 0.25]$。\n  - 观测值:\n    $$\n    \\mathbf{Y}^{(4)} = \\begin{bmatrix}\n    0.00  0.00  0.00  0.00 \\\\\n    0.00  0.00  0.00  0.00\n    \\end{bmatrix}.\n    $$\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个元素对应一个测试用例，并且本身就是一个双元素列表：第一个列表包含每个循环的整数碱基判读（使用映射 $A \\rightarrow 0, C \\rightarrow 1, G \\rightarrow 2, T \\rightarrow 3$），第二个列表包含每个循环对应的 Phred 质量得分（四舍五入到两位小数）。例如，输出格式必须为\n$$\n[\\,[\\,[\\text{calls}^{(1)}],\\,[\\text{qscores}^{(1)}]\\,],\\,\\ldots,\\,[\\,[\\text{calls}^{(4)}],\\,[\\text{qscores}^{(4)}]\\,]\\,].\n$$",
            "solution": "该问题要求为一个简化的四通道合成法测序系统实现一个统计碱基判读算法。我们需要确定每个测序循环中最可能的 DNA 碱基，并使用 Phred 质量得分来量化该判读的置信度。这将通过对所提供的生成信号模型应用概率论原理，特别是最大似然估计和贝叶斯推断来完成。\n\n每个循环 $i$ 的过程涉及两个主要计算：\n1.  **最大似然 (ML) 碱基判读**：找到最有可能生成观测强度向量 $\\mathbf{y}_i$ 的碱基 $\\hat{b}_i$。\n2.  **Phred 质量得分 ($Q_i$) 计算**：根据其后验错误概率，为判读 $\\hat{b}_i$ 计算一个质量得分。\n\n我们将基于基本原理分析每个步骤。\n\n**原理 1：高斯信号模型和似然度**\n\n在循环 $i$ 中，对于给定的碱基 $b \\in \\{A,C,G,T\\}$，观测到的强度向量 $\\mathbf{y}_i \\in \\mathbb{R}^4$ 的生成模型是：\n$$\n\\mathbf{y}_i = s_i \\boldsymbol{\\mu}_b + \\boldsymbol{\\beta} + \\boldsymbol{\\varepsilon}_i, \\quad \\boldsymbol{\\varepsilon}_i \\sim \\mathcal{N}\\!\\left(\\mathbf{0}, \\operatorname{diag}(\\boldsymbol{\\sigma}^2)\\right)\n$$\n其中 $\\boldsymbol{\\mu}_b$ 是校准矩阵 $\\mathbf{C}$ 中对应于碱基 $b$ 的列。此方程表明，观测到的信号是一个缩放后的理想信号 $s_i \\boldsymbol{\\mu}_b$、一个恒定的背景基线 $\\boldsymbol{\\beta}$ 和加性高斯噪声 $\\boldsymbol{\\varepsilon}_i$ 的总和。\n\n该模型意味着，给定碱基 $b$ 时观测到 $\\mathbf{y}_i$ 的条件概率服从多元正态分布：\n$$\n\\mathbf{y}_i \\mid b \\sim \\mathcal{N}\\!\\left(s_i \\boldsymbol{\\mu}_b + \\boldsymbol{\\beta}, \\operatorname{diag}(\\boldsymbol{\\sigma}^2)\\right)\n$$\n概率密度函数 (PDF)，它作为似然度 $p(\\mathbf{y}_i \\mid b)$，是：\n$$\np(\\mathbf{y}_i \\mid b) = \\frac{1}{\\sqrt{(2\\pi)^4 \\det(\\operatorname{diag}(\\boldsymbol{\\sigma}^2))}} \\exp\\left(-\\frac{1}{2} (\\mathbf{y}_i - (s_i \\boldsymbol{\\mu}_b + \\boldsymbol{\\beta}))^T (\\operatorname{diag}(\\boldsymbol{\\sigma}^2))^{-1} (\\mathbf{y}_i - (s_i \\boldsymbol{\\mu}_b + \\boldsymbol{\\beta}))\\right)\n$$\n由于噪声协方差矩阵 $\\boldsymbol{\\Sigma} = \\operatorname{diag}(\\boldsymbol{\\sigma}^2)$ 是对角矩阵，各通道是独立的。指数的参数，即马氏距离的平方，简化为加权平方误差和 (WSSE)：\n$$\n\\chi^2(\\mathbf{y}_i, b) = \\sum_{j=0}^{3} \\frac{(y_{i,j} - (s_i C_{j,b} + \\beta_j))^2}{\\sigma_j^2}\n$$\n其中碱基索引 $b$ 映射到 $\\mathbf{C}$ 的相应列，而 $j \\in \\{0,1,2,3\\}$ 索引四个通道。\n\n**原理 2：最大似然碱基判读**\n\nML 碱基判读 $\\hat{b}_i$ 是使似然函数最大化的碱基：\n$$\n\\hat{b}_i = \\arg\\max_{b \\in \\{A,C,G,T\\}} p(\\mathbf{y}_i \\mid b)\n$$\n最大化似然度 $p(\\mathbf{y}_i \\mid b)$ 等价于最大化其自然对数 $\\ln p(\\mathbf{y}_i \\mid b)$，这在计算上更稳定。\n$$\n\\ln p(\\mathbf{y}_i \\mid b) = -\\frac{1}{2} \\sum_{j=0}^{3} \\ln(2\\pi \\sigma_j^2) - \\frac{1}{2} \\sum_{j=0}^{3} \\frac{(y_{i,j} - (s_i C_{j,b} + \\beta_j))^2}{\\sigma_j^2}\n$$\n由于第一项相对于碱基 $b$ 是常数，最大化对数似然等价于最小化 WSSE 项 $\\chi^2(\\mathbf{y}_i, b)$。\n\nML 碱基判读的算法如下：\n1.  对于每个循环 $i$ 和四个碱基中的每一个 $b$，计算对数似然 $\\ln p(\\mathbf{y}_i \\mid b)$。\n2.  将对数似然转换为线性尺度的似然度：$L_b = \\exp(\\ln p(\\mathbf{y}_i \\mid b))$。\n3.  找到最大似然度 $L_{max} = \\max_{b} L_b$。\n4.  识别候选碱基集 $S_{cand} = \\{ b \\mid L_{max} - L_b  \\tau \\}$，其中 $\\tau=10^{-12}$ 是给定的容忍度。\n5.  最终的碱基判读 $\\hat{b}_i$ 是 $S_{cand}$ 中具有最小字典序索引（$A \\rightarrow 0, C \\rightarrow 1, G \\rightarrow 2, T \\rightarrow 3$）的碱基。\n\n**原理 3：贝叶斯推断和 Phred 质量得分**\n\nPhred 质量得分 $Q_i$ 由后验错误概率 $P_{\\text{err},i}$ 推导得出。要计算这个值，我们首先需要给定观测值 $\\mathbf{y}_i$ 时每个碱基 $b$ 的后验概率，表示为 $P(b \\mid \\mathbf{y}_i)$。使用贝叶斯定理：\n$$\nP(b \\mid \\mathbf{y}_i) = \\frac{p(\\mathbf{y}_i \\mid b) p(b)}{p(\\mathbf{y}_i)} = \\frac{p(\\mathbf{y}_i \\mid b) p(b)}{\\sum_{b'} p(\\mathbf{y}_i \\mid b') p(b')}\n$$\n其中 $p(b)$ 是每个碱基给定的先验概率，分母是边际似然（证据），一个确保后验概率之和为 1 的归一化常数。\n\n对于判读 $\\hat{b}_i$ 的后验错误概率是真实碱基是任何其他碱基的概率：\n$$\nP_{\\text{err},i} = P(\\text{base} \\neq \\hat{b}_i \\mid \\mathbf{y}_i) = 1 - P(\\hat{b}_i \\mid \\mathbf{y}_i) = \\sum_{b \\neq \\hat{b}_i} P(b \\mid \\mathbf{y}_i)\n$$\n然后，Phred 得分定义为：\n$$\nQ_i = -10 \\log_{10}(P_{\\text{err},i})\n$$\n\n**原理 4：数值稳定计算**\n\n直接计算似然度和后验概率可能导致数值下溢，因为这些值可能非常小。在对数空间中进行计算是标准做法。令 $\\lambda_b = \\ln(p(\\mathbf{y}_i \\mid b) p(b)) = \\ln p(\\mathbf{y}_i \\mid b) + \\ln p(b)$ 为对数联合概率。后验概率的对数是：\n$$\n\\ln P(b \\mid \\mathbf{y}_i) = \\lambda_b - \\ln\\left(\\sum_{b'} \\exp(\\lambda_{b'})\\right)\n$$\n求和项使用 log-sum-exp 技巧进行稳定计算。令 $\\lambda_{max} = \\max_{b'} \\lambda_{b'}$。那么：\n$$\n\\ln\\left(\\sum_{b'} \\exp(\\lambda_{b'})\\right) = \\lambda_{max} + \\ln\\left(\\sum_{b'} \\exp(\\lambda_{b'} - \\lambda_{max})\\right)\n$$\n这避免了指数运算中的上溢和求和中的下溢。一旦计算出对数后验概率 $\\ln P(b \\mid \\mathbf{y}_i)$，我们就可以找到 $P(\\hat{b}_i \\mid \\mathbf{y}_i) = \\exp(\\ln P(\\hat{b}_i \\mid \\mathbf{y}_i))$，并随后得到 $P_{\\text{err},i}$。问题规定，如果 $P_{\\text{err},i}$ 在数值上为零，则应将其视为 $10^{-300}$，以防止在计算 $Q_i$ 时出现未定义的对数。\n\n通过结合这些原理，我们可以构建一个算法来处理所提供的测试套件并生成所需的碱基判读和质量得分。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Solves the DNA sequencing base calling problem for all test cases.\n    \"\"\"\n    \n    # Base mapping and problem constants\n    base_map = {'A': 0, 'C': 1, 'G': 2, 'T': 3}\n    bases = ['A', 'C', 'G', 'T']\n    num_bases = 4\n    tau = 1e-12\n    p_err_floor = 1e-300\n\n    # Test Suite\n    test_cases = [\n        # Test case 1\n        {\n            \"C\": np.array([\n                [1.0, 0.1, 0.1, 0.1],\n                [0.1, 1.0, 0.1, 0.1],\n                [0.1, 0.1, 1.0, 0.1],\n                [0.1, 0.1, 0.1, 1.0]\n            ]),\n            \"sigma_sq\": np.array([0.05, 0.05, 0.05, 0.05]),\n            \"beta\": np.array([0.0, 0.0, 0.0, 0.0]),\n            \"s\": np.array([1.0, 1.0, 1.0, 1.0, 1.0]),\n            \"p\": np.array([0.25, 0.25, 0.25, 0.25]),\n            \"Y\": np.array([\n                [1.20, 0.10, 0.10, 0.10],\n                [0.10, 1.10, 0.10, 0.10],\n                [0.20, 0.10, 1.30, 0.10],\n                [0.10, 0.10, 0.10, 1.25],\n                [0.30, 0.20, 0.90, 0.20]\n            ])\n        },\n        # Test case 2\n        {\n            \"C\": np.array([\n                [1.0, 0.1, 0.1, 0.1],\n                [0.1, 1.0, 0.1, 0.1],\n                [0.1, 0.1, 1.0, 0.1],\n                [0.1, 0.1, 0.1, 1.0]\n            ]),\n            \"sigma_sq\": np.array([0.5, 0.5, 0.5, 0.5]),\n            \"beta\": np.array([0.0, 0.0, 0.0, 0.0]),\n            \"s\": np.array([1.0, 1.0, 1.0]),\n            \"p\": np.array([0.25, 0.25, 0.25, 0.25]),\n            \"Y\": np.array([\n                [0.50, 0.50, 0.50, 0.50],\n                [0.60, 0.50, 0.50, 0.40],\n                [0.50, 0.40, 0.60, 0.50]\n            ])\n        },\n        # Test case 3\n        {\n            \"C\": np.array([\n                [0.9, 0.2, 0.2, 0.2],\n                [0.2, 0.9, 0.3, 0.2],\n                [0.2, 0.3, 0.9, 0.2],\n                [0.2, 0.2, 0.2, 0.9]\n            ]),\n            \"sigma_sq\": np.array([0.1, 0.2, 0.1, 0.2]),\n            \"beta\": np.array([0.05, 0.05, 0.05, 0.05]),\n            \"s\": np.array([1.0, 0.8, 1.2]),\n            \"p\": np.array([0.10, 0.40, 0.40, 0.10]),\n            \"Y\": np.array([\n                [0.95, 0.13, 0.10, 0.10],\n                [0.20, 0.75, 0.30, 0.20],\n                [0.20, 0.25, 1.10, 0.20]\n            ])\n        },\n        # Test case 4\n        {\n            \"C\": np.array([\n                [1.0, 0.1, 0.1, 0.1],\n                [0.1, 1.0, 0.1, 0.1],\n                [0.1, 0.1, 1.0, 0.1],\n                [0.1, 0.1, 0.1, 1.0]\n            ]),\n            \"sigma_sq\": np.array([0.05, 0.05, 0.05, 0.05]),\n            \"beta\": np.array([0.0, 0.0, 0.0, 0.0]),\n            \"s\": np.array([1.0, 1.0]),\n            \"p\": np.array([0.25, 0.25, 0.25, 0.25]),\n            \"Y\": np.array([\n                [0.00, 0.00, 0.00, 0.00],\n                [0.00, 0.00, 0.00, 0.00]\n            ])\n        }\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        C, sigma_sq, beta, s_vec, p, Y = case[\"C\"], case[\"sigma_sq\"], case[\"beta\"], case[\"s\"], case[\"p\"], case[\"Y\"]\n        \n        calls_per_case = []\n        qscores_per_case = []\n        \n        num_cycles = Y.shape[0]\n        \n        log_priors = np.log(p)\n        log_likelihood_const = -0.5 * np.sum(np.log(2 * np.pi * sigma_sq))\n\n        for i in range(num_cycles):\n            y_i = Y[i, :]\n            s_i = s_vec[i]\n            \n            log_likelihoods = np.zeros(num_bases)\n            \n            for b_idx in range(num_bases):\n                mu_b = C[:, b_idx]\n                expected_mean = s_i * mu_b + beta\n                \n                # Calculate WSSE (chi-squared)\n                wsse = np.sum(((y_i - expected_mean)**2) / sigma_sq)\n                \n                # Log likelihood\n                log_likelihoods[b_idx] = log_likelihood_const - 0.5 * wsse\n            \n            # --- Maximum Likelihood Base Call ---\n            likelihoods = np.exp(log_likelihoods)\n            max_likelihood = np.max(likelihoods)\n            tied_indices = np.where(max_likelihood - likelihoods  tau)[0]\n            ml_base_call = np.min(tied_indices)\n            calls_per_case.append(int(ml_base_call))\n            \n            # --- Phred Quality Score Calculation ---\n            # Log joint probabilities\n            log_joint = log_likelihoods + log_priors\n            \n            # Log-sum-exp for normalization\n            log_joint_max = np.max(log_joint)\n            log_marginal = log_joint_max + np.log(np.sum(np.exp(log_joint - log_joint_max)))\n            \n            # Log posteriors\n            log_posteriors = log_joint - log_marginal\n            posteriors = np.exp(log_posteriors)\n            \n            p_correct = posteriors[ml_base_call]\n            p_err = 1.0 - p_correct\n            \n            # Handle numerical zero\n            if p_err  p_err_floor:\n                p_err = p_err_floor\n            \n            q_score = -10 * np.log10(p_err)\n            qscores_per_case.append(round(q_score, 2))\n            \n        all_results.append([calls_per_case, qscores_per_case])\n\n    # Format the final output string\n    result_strings = []\n    for calls, qscores in all_results:\n        calls_str = f\"[{','.join(map(str, calls))}]\"\n        qscores_str = f\"[{','.join([f'{q:.2f}' for q in qscores])}]\"\n        result_strings.append(f\"[{calls_str},{qscores_str}]\")\n    \n    final_output = f\"[{','.join(result_strings)}]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "在获得测序读段后，一个核心问题是：“我们测序的深度足够覆盖整个基因组吗？”。本练习将带您深入经典的Lander-Waterman模型，运用泊松过程的统计原理来定量回答这个问题。通过从第一性原理出发，推导基因组的期望覆盖度、未覆盖区域的长度分布以及最大空隙尺寸 ()，您将对测序深度如何影响基因组拼接的可行性建立起深刻的数学直觉。",
            "id": "3310820",
            "problem": "考虑一个长度为 $L$ 的线性参考基因组，单位为碱基对 (bp)。一项全基因组随机霰弹法测序实验产生固定长度为 $\\ell$ 的短读长 (reads)，其起始位置被建模为沿基因组的齐次泊松点过程，其率为 $\\lambda$ (读长/碱基对)。平均每个碱基的覆盖度定义为 $c = \\lambda \\ell$。假设读长是独立且均匀放置的，并且在给定的泊松模型下，不同位置的覆盖事件是独立的。\n\n仅从这些定义以及齐次泊松过程及其更新结构的性质出发，进行以下推导：\n1. 推导保持未覆盖的碱基的期望分数，作为覆盖度 $c$ 的函数。\n2. 推导未覆盖间隙长度（接收到零覆盖的连续碱基对片段）的概率分布。请明确说明您的结果是否以间隙为正为条件，如果是，也请给出无条件的混合结构。\n3. 使用独立同分布样本的极值理论，推导基因组上期望的最大未覆盖间隙长度的近似值，用 $L$、$\\ell$、$c$ 和普适常数表示。\n\n然后，对参数 $L = 1.0 \\times 10^{7}$ bp, $\\ell = 100$ bp, 和 $c = 5.0$ 对您的近似值进行数值评估。将最终数值答案四舍五入到 4 位有效数字，并以碱基对 (bp) 表示。您的最终答案必须是一个实数。",
            "solution": "该问题要求基于 Lander-Waterman 模型，推导与通过随机霰弹法测序的基因组中未覆盖区域相关的公式。该模型假设读长的起始位置遵循齐次泊松点过程。我们将按顺序处理问题的每个部分。\n\n设 $L$ 为基因组长度，$\\ell$ 为固定读长长度，$\\lambda$ 为读长起始位置的泊松过程的率。平均覆盖度由 $c = \\lambda \\ell$ 给出。\n\n**1. 未覆盖碱基的期望分数**\n\n为了找到基因组未覆盖部分的期望分数，我们可以计算任意单个碱基对未被覆盖的概率，然后利用该过程的齐次性。\n\n考虑基因组中任意位置 $x$ 处的一个碱基。如果至少有一个读长与该碱基重叠，则该碱基被覆盖。一个长度为 $\\ell$、起始于位置 $s$ 的读长覆盖碱基区间 $[s, s+\\ell-1]$（使用整数坐标）。对于连续坐标系，起始于 $s$ 的读长覆盖区间 $[s, s+\\ell)$。\n\n一个起始于 $s$ 的读长覆盖位置 $x$ 的条件是 $s \\le x  s+\\ell$，这等价于 $x-\\ell  s \\le x$。这为能够覆盖位置 $x$ 的读长的起始位置定义了一个长度为 $\\ell$ 的区间。\n\n在任何长度为 $I$ 的区间内，读长起始的数量 $K$ 是一个服从均值为 $\\lambda I$ 的泊松分布的随机变量。因此，覆盖位置 $x$ 的读长数量（我们称之为 $K_x$）是一个泊松分布的随机变量，其均值为 $\\lambda \\times \\ell = c$。\n$$P(K_x = k) = \\frac{c^k e^{-c}}{k!}$$\n当且仅当覆盖位置 $x$ 的读长数量为零（即 $K_x = 0$）时，该位置的碱基是未覆盖的。此事件的概率为：\n$$P(\\text{base at } x \\text{ is uncovered}) = P(K_x = 0) = \\frac{c^0 e^{-c}}{0!} = e^{-c}$$\n由于该过程是齐次的（读长均匀放置），这个概率对于所有位置 $x$ 都是相同的（对于大基因组 $L \\gg \\ell$，忽略末端效应）。根据期望的线性性质，未覆盖碱基的期望数量是 $L \\times P(\\text{uncovered}) = L e^{-c}$。\n保持未覆盖的碱基的期望分数 $F_u$，是未覆盖碱基的期望数量除以总长度 $L$：\n$$F_u = \\frac{L e^{-c}}{L} = e^{-c}$$\n\n**2. 未覆盖间隙长度的概率分布**\n\n未覆盖间隙是指具有零覆盖度的连续碱基片段。我们可以通过考虑连续读长起始位置之间的间距来为这些间隙的长度建模。读长起始位置 $\\{s_i\\}$ 构成一个率为 $\\lambda$ 的泊松点过程。在此过程中，连续事件之间的距离 $X_i = s_{i+1} - s_i$ 是独立同分布 (i.i.d.) 的指数随机变量，其率为 $\\lambda$。其概率密度函数 (PDF) 为 $f_X(x) = \\lambda e^{-\\lambda x}$，其中 $x \\ge 0$。\n\n一个起始于 $s_i$ 的读长覆盖区间 $[s_i, s_i+\\ell)$。如果下一个读长起始于 $s_{i+1}$，它覆盖区间 $[s_{i+1}, s_{i+1}+\\ell)$。当且仅当第一个读长覆盖范围的终点 $s_i+\\ell$ 小于下一个读长的起点 $s_{i+1}$ 时，这两个读长之间会出现覆盖间隙。这个条件是 $s_i+\\ell  s_{i+1}$，或者 $s_{i+1}-s_i > \\ell$。用读长间距 $X = s_{i+1}-s_i$ 来表示，如果 $X > \\ell$，则形成一个间隙。\n\n未覆盖连续片段的长度是 $G = s_{i+1} - (s_i+\\ell) = X - \\ell$。仅当 $X > \\ell$ 时，该长度为正。\n\n首先，我们计算在任意两个连续读长之间形成正长度间隙的概率。这个概率是：\n$$P(G > 0) = P(X > \\ell) = \\int_{\\ell}^{\\infty} \\lambda e^{-\\lambda x} dx = [-e^{-\\lambda x}]_{\\ell}^{\\infty} = e^{-\\lambda \\ell} = e^{-c}$$\n不形成间隙（即读长重叠）的概率是 $P(G \\le 0) = P(X \\le \\ell) = 1 - e^{-c}$。\n\n现在，我们推导间隙长度 $G$ 在其为正 ($G>0$) 的条件下的分布。这是在 $X>\\ell$ 的条件下 $X-\\ell$ 的分布。对于 $g \\ge 0$ 的累积分布函数 (CDF) 是：\n$$P(G \\le g | G > 0) = P(X - \\ell \\le g | X > \\ell) = \\frac{P(\\ell  X \\le \\ell + g)}{P(X > \\ell)}$$\n分子的计算如下：\n$$P(\\ell  X \\le \\ell + g) = F_X(\\ell+g) - F_X(\\ell) = (1 - e^{-\\lambda(\\ell+g)}) - (1 - e^{-\\lambda\\ell}) = e^{-\\lambda\\ell} - e^{-\\lambda\\ell}e^{-\\lambda g} = e^{-c}(1 - e^{-\\lambda g})$$\n分母是 $P(X > \\ell) = e^{-c}$。\n因此，间隙长度的条件累积分布函数是：\n$$F_{G|G>0}(g) = \\frac{e^{-c}(1 - e^{-\\lambda g})}{e^{-c}} = 1 - e^{-\\lambda g}$$\n这是一个率为 $\\lambda$ 的指数分布的累积分布函数。因此，在为正的条件下，未覆盖间隙的长度服从率为 $\\lambda = c/\\ell$ 的指数分布。条件概率密度函数为 $f_{G|G>0}(g) = \\lambda e^{-\\lambda g}$，其中 $g \\ge 0$。\n\n间隙长度 $G$ 的无条件分布是一个混合模型。它在 $G=0$ 处有一个离散质量（代表没有间隙），对于 $G>0$ 有一个连续部分：\n- 间隙长度为零的概率为 $P(G \\le 0) = 1 - e^{-c}$。\n- 间隙长度为正且服从率为 $\\lambda$ 的指数分布的概率为 $P(G > 0) = e^{-c}$。\n\n无条件的“概率密度函数”可以用狄拉克-德尔塔函数 $\\delta(g)$ 写成：\n$$f_G(g) = (1-e^{-c})\\delta(g) + e^{-c} \\lambda e^{-\\lambda g} \\cdot I(g>0)$$\n其中 $I(g>0)$ 是正数 $g$ 的指示函数。\n\n**3. 期望的最大未覆盖间隙长度**\n\n我们需要找到整个基因组中所有未覆盖间隙的最大值的期望。形成间隙的机会数量是读长间的区间数，约等于读长数 $N_{reads}$。读长的期望数量是 $E[N_{reads}] = \\lambda L$。正长度间隙的数量 $n$ 是读长数乘以形成间隙的概率 $e^{-c}$。所以，间隙的期望数量是：\n$$n = E[N_{gaps}] = (\\lambda L) e^{-c}$$\n这 $n$ 个间隙的长度 $G_1, G_2, \\ldots, G_n$ 是来自率为 $\\lambda$ 的指数分布的独立同分布样本。我们想找到这些样本的最大值的期望值，即 $G_{max} = \\max(G_1, \\ldots, G_n)$。\n\n$n$ 个独立同分布的 $\\text{Exp}(\\lambda)$ 变量的最大值的精确期望值由以下公式给出：\n$$E[G_{max}] = \\frac{1}{\\lambda} H_n = \\frac{1}{\\lambda} \\sum_{k=1}^{n} \\frac{1}{k}$$\n其中 $H_n$ 是第 $n$ 个调和数。对于大的 $n$，调和数可以近似为 $H_n \\approx \\ln(n) + \\gamma$，其中 $\\gamma \\approx 0.5772$ 是欧拉-马歇罗尼常数。这个近似来自于极值理论，其中中心化和尺度化的最大值收敛于 Gumbel 分布。\n\n使用这个近似，我们有：\n$$E[G_{max}] \\approx \\frac{1}{\\lambda}(\\ln(n) + \\gamma)$$\n代入 $n = \\lambda L e^{-c}$ 和 $\\lambda = c/\\ell$：\n$$E[G_{max}] \\approx \\frac{\\ell}{c} \\left( \\ln(\\lambda L e^{-c}) + \\gamma \\right)$$\n我们可以展开对数：\n$$E[G_{max}] \\approx \\frac{\\ell}{c} \\left( \\ln(\\lambda) + \\ln(L) - c + \\gamma \\right)$$\n再次代入 $\\lambda=c/\\ell$：\n$$E[G_{max}] \\approx \\frac{\\ell}{c} \\left( \\ln\\left(\\frac{c}{\\ell}\\right) + \\ln(L) - c + \\gamma \\right) = \\frac{\\ell}{c} \\left( \\ln(c) - \\ln(\\ell) + \\ln(L) - c + \\gamma \\right)$$\n$$E[G_{max}] \\approx \\frac{\\ell}{c} \\left( \\ln\\left(\\frac{L}{\\ell}\\right) + \\ln(c) - c + \\gamma \\right)$$\n这个表达式提供了期望的最大未覆盖间隙长度的近似值。\n\n**数值评估**\n\n我们给定的参数是：\n- $L = 1.0 \\times 10^{7}$ bp\n- $\\ell = 100$ bp\n- $c = 5.0$\n- 我们使用常数 $\\gamma \\approx 0.57721566$\n\n首先，我们计算括号内的各项：\n- $\\frac{L}{\\ell} = \\frac{1.0 \\times 10^{7}}{100} = 1.0 \\times 10^{5}$\n- $\\ln\\left(\\frac{L}{\\ell}\\right) = \\ln(10^5) = 5 \\ln(10) \\approx 5 \\times 2.302585 = 11.512925$\n- $\\ln(c) = \\ln(5.0) \\approx 1.609438$\n- $c$ 的值是 $5.0$。\n\n现在，我们将这些值代入推导出的 $E[G_{max}]$ 公式中：\n$$E[G_{max}] \\approx \\frac{100}{5.0} \\left( 11.512925 + 1.609438 - 5.0 + 0.577216 \\right)$$\n$$E[G_{max}] \\approx 20 \\left( 13.122363 - 5.0 + 0.577216 \\right)$$\n$$E[G_{max}] \\approx 20 \\left( 8.122363 + 0.577216 \\right)$$\n$$E[G_{max}] \\approx 20 \\left( 8.699579 \\right)$$\n$$E[G_{max}] \\approx 173.99158$$\n问题要求将最终答案四舍五入到 4 位有效数字。\n$$E[G_{max}] \\approx 174.0 \\text{ bp}$$\n这是基因组中未接收到任何序列覆盖的最大连续区域的期望长度。",
            "answer": "$$\\boxed{174.0}$$"
        },
        {
            "introduction": "拥有了测序读段之后，最常见的应用之一就是将它们比对回已知的参考基因组上，这是一个巨大的计算搜索挑战。现代的比对工具普遍采用高效的“种子-延伸”(seed-and-extend) 策略来应对这一挑战。本练习 () 将让您亲手实现这一核心算法，利用基于FM索引的精确种子匹配来快速筛选候选区域，并随后进行延伸验证，从而深刻理解生物信息学算法在速度与灵敏度之间权衡的精髓。",
            "id": "3310867",
            "problem": "给定一个参考脱氧核糖核酸（DNA）字符串，你需要使用 Ferragina–Manzini (FM) 索引实现一个基于特定原则的“种子-延伸”（seed-and-extend）候选定位枚举器。任务是，对于每个给定的测序片段（read），计算出其在参考序列中的所有候选起始位置。在这些位置上，测序片段能够以至多 $k$ 个错配进行比对，并且需要满足由精确种子匹配约束定义的种子筛选条件。\n\n使用的基本概念和定义：\n- DNA 被建模为基于字母表 $\\Sigma = \\{\\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{T}\\}$ 的字符串。\n- 分子生物学的中心法则确立了DNA序列编码遗传信息；在计算层面，测序片段比对被表述为在参考基因组中搜索子字符串。\n- FM 索引源于 Burrows–Wheeler 变换（BWT），它允许通过后向搜索（backward search）进行高效的精确子字符串查找。请基于字符串 $S\\$$ 构建 FM 索引，其中 $S$ 是参考序列，而 $\\$$ 是一个字典序小于 $\\Sigma$ 中任何字符的哨兵字符。\n- 令 $n = |S\\$|$ 表示附加哨兵字符后文本的长度。FM 索引包含：\n  1. BWT 字符串 $B$，其定义为 $B[i] = S\\$\\big[(\\mathrm{SA}[i] - 1) \\bmod n\\big]$，其中 $\\mathrm{SA}$ 是 $S\\$$ 的后缀数组。\n  2. 数组 $C(c)$，给出在 $S\\$$ 中字典序小于字符 $c$ 的字符总数。\n  3. 出现次数函数 $\\mathrm{Occ}(c, i)$，返回字符 $c$ 在前缀 $B[0:i)$ 中出现的次数，其中 $0 \\le i \\le n$。\n- 后向搜索使用 last-first (LF) 映射执行。对于一个模式 $P$ 和一个后缀数组排名区间 $[l, r)$，使用字符 $c$ 进行更新会产生一个新的区间\n  $$l' = C(c) + \\mathrm{Occ}(c, l), \\quad r' = C(c) + \\mathrm{Occ}(c, r),$$\n  从 $P$ 的最后一个字符迭代到第一个字符。如果在任何步骤中 $l' \\ge r'$，则模式不存在。否则，$P$ 的精确匹配位置由后缀数组位置 $\\mathrm{SA}[l:r)$ 给出。\n\n种子-延伸筛选：\n- 给定一个长度为 $L$ 的测序片段 $R$，一个种子长度 $m$，以及一个整数 $f \\ge 1$，通过在偏移量 $o_j = jm$（对于所有满足 $o_j + m \\le L$ 的整数 $j$）处提取子字符串 $R[o_j : o_j + m]$ 来形成不相交的种子。令 $t = \\left\\lfloor \\frac{L}{m} \\right\\rfloor$ 表示这些种子的数量。\n- 如果至少有 $f$ 个种子在 $S$ 中有精确匹配，且这些匹配与在 $x$ 处的比对一致，则 $S$ 中的一个候选起始位置 $x$ 通过筛选。形式上，对于一个位于偏移量 $o$ 处的种子，其在 $S$ 中的任何精确匹配位置 $p$ 都意味着一个候选比对起始位置 $x = p - o$。计算支持给定 $x$ 的种子数量，仅当该数量至少为 $f$ 时才保留 $x$。\n- 筛选之后，执行延伸：计算 $R$ 与 $S[x : x + L]$ 之间的错配数，如果此数目至多为 $k$，则保留 $x$。有效的起始位置必须满足 $0 \\le x \\le |S| - L$。\n\n用于参数选择的原则性保证：\n- 为允许最多 $k$ 个错配，一个经典的鸽巢原理论证确保，如果将测序片段划分为 $k + 1$ 个不相交的片段，则至少有一个片段必须是无错配的。这启发我们为保证完整性，选择种子长度 $m \\approx \\left\\lfloor \\frac{L}{k + 1} \\right\\rfloor$ 和筛选要求 $f = 1$。使用 $f  1$ 的更强筛选标准是有效的，但在存在错配时可能会排除真实的比对。\n\n算法要求：\n- 为给定的参考序列 $S$ 构建 FM 索引。\n- 对于每个测序片段和参数集 $(L, k, m, f)$，仅使用精确的 FM 索引种子搜索加上直接比较的延伸方法，计算出 $S$ 中满足筛选和错配约束的候选起始位置集合。\n- 所有区间和索引必须自洽。对 $S$ 中的位置使用从零开始的索引。哨兵索引和超出范围的候选位置必须被丢弃。\n\n测试套件：\n- 使用参考序列 $S = \\text{\"ACGTACGTACGTACGTACGTACGT\"}$，其长度 $|S| = 24$。\n- 对于每个测试用例，程序应按升序生成有效的候选起始位置的排序列表。\n- 测试用例：\n  1. 案例 A（正常路径）：$R_1 = \\text{\"ACGTACGTACG\"}$，$L = 11$，$k = 1$，$m = 5$，$f = 1$。\n  2. 案例 B（边界 k=0）：$R_2 = \\text{\"GTACGT\"}$，$L = 6$，$k = 0$，$m = 3$，$f = 2$。\n  3. 案例 C（靠近末端的边界）：$R_3 = \\text{\"ACGTACG\"}$，$L = 7$，$k = 2$，$m = 3$，$f = 1$。\n  4. 案例 D（严格筛选边界情况）：$R_4 = \\text{\"AAGTACGTA\"}$，$L = 9$，$k = 1$，$m = 4$，$f = 2$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个方括号括起来的逗号分隔列表（例如，$\\text{[result1,result2,result3,result4]}$），其中每个 $\\text{result}$ 本身是一个整数列表，表示相应测试用例的候选起始位置。\n- 列表必须按升序排序，且整体输出必须只有一行，不含任何额外文本。",
            "solution": "任务是实现一个“种子-延伸”（seed-and-extend）测序片段比对算法，该算法枚举给定 DNA 测序片段在参考序列内的所有候选起始位置。解决方案必须遵循指定的算法原则，使用 Ferragina–Manzini (FM) 索引进行高效的种子搜索。该过程包括三个主要阶段：FM 索引构建、基于种子的筛选和基于延伸的验证。\n\n### 1. FM 索引构建\n\nFM 索引是一种压缩全文索引，能够高效地对文本中的任意模式进行计数和定位。构建 FM 索引是比对算法的先决条件。我们从参考 DNA 字符串 $S$ 开始。\n\n_步骤 1：文本准备_\n首先，将一个哨兵字符 $\\$$ 附加到参考字符串 $S$ 的末尾，该字符的字典序小于 DNA 字母表 $\\Sigma = \\{\\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{T}\\}$ 中的任何字符。这样就创建了长度为 $n = |S| + 1$ 的文本 $T = S\\$$。哨兵字符确保了 $T$ 的每个后缀都是唯一的，并且后缀数组对应于索引 $0$ 到 $n-1$ 的一个排列。\n\n_步骤 2：后缀数组 (SA)_\n文本 $T$ 的后缀数组 $\\mathrm{SA}$ 是一个长度为 $n$ 的整数数组。$\\mathrm{SA}[i]$ 存储了 $T$ 中字典序第 $i$ 小的后缀的起始位置。对于像本题中提供的小文本，可以通过生成所有后缀，将它们与起始索引配对，然后对这些配对进行排序来构建后缀数组。\n\n_步骤 3：Burrows–Wheeler 变换 (BWT)_\nBWT 生成 $T$ 中字符的一个排列，记为字符串 $B$。其定义关系为 $B[i] = T[(\\mathrm{SA}[i] - 1) \\bmod n]$，其中 $i \\in [0, n-1]$。从概念上讲，$B$ 是一个矩阵的最后一列，该矩阵的行是 $T$ 的所有循环移位按字典序排序后得到的。字符串 $B$ 具有一个关键特性，即倾向于将相同字符聚集在一起，这使其高度可压缩且适合高效查询。\n\n_步骤 4：C 表和出现次数函数_\n为实现高效搜索，需要构建两个辅助数据结构：\n1.  **C 表**：数组 $C(c)$ 存储了 $T$ 中字典序小于字符 $c$ 的字符总数。该表使我们能立即找到后缀数组中所有以特定字符 $c$ 开头的后缀的起始排名区块。\n2.  **出现次数函数 ($\\mathrm{Occ}$)**：函数 $\\mathrm{Occ}(c, i)$ 返回字符 $c$ 在 BWT 字符串前缀 $B[0:i)$ 中出现的次数。为提高计算效率，此函数的值会被预先计算并存储在一个二维数组中，其中一维代表字母表中的字符，另一维代表在 $B$ 中的位置。\n\n### 2. 通过后向搜索进行精确种子查找\n\n构建好 FM 索引后，我们可以使用一种称为后向搜索的算法来执行高效的精确字符串匹配。该算法能找到与所有以前缀 $P$ 开头的后缀相对应的后缀数组区间 $[l, r)$。\n\n搜索过程从右到左迭代模式 $P$ 的字符。从完整的后缀数组区间 $[l, r) = [0, n)$ 开始，根据 last-first (LF) 映射性质，用 $P$ 中的每个字符 $c$ 来更新区间：\n$$l_{\\text{new}} = C(c) + \\mathrm{Occ}(c, l_{\\text{old}})$$\n$$r_{\\text{new}} = C(c) + \\mathrm{Occ}(c, r_{\\text{old}})$$\n如果在任何时候 $l_{\\text{new}} \\ge r_{\\text{new}}$，则模式 $P$ 不存在于文本 $T$ 中。如果循环完成，最终的区间 $[l, r)$ 标识了以 $P$ 为前缀的后缀范围 $\\mathrm{SA}[l \\dots r-1]$。对于 $i \\in [l, r)$，值 $\\mathrm{SA}[i]$ 就是 $P$ 在 $T$ 中精确匹配的起始位置。\n\n### 3. 种子-延伸筛选与验证\n\n该策略使用短的精确匹配（种子）来快速识别一小组有希望的候选比对位置，然后在代价更高的延伸步骤中对这些位置进行验证。\n\n_步骤 1：播种_\n给定一个长度为 $L$ 的测序片段 $R$、一个种子长度 $m$ 和一个筛选阈值 $f$，该测序片段被划分为 $t = \\lfloor L/m \\rfloor$ 个不相交的种子。第 $j$ 个种子（使用从 0 开始的索引）是子字符串 $R[o_j : o_j + m]$，其中偏移量为 $o_j = jm$，对于 $j \\in [0, t-1]$。\n\n_步骤 2：筛选_\n对于这 $t$ 个种子中的每一个，我们使用 FM 索引上的后向搜索算法来找到其在参考字符串 $S$ 中的所有精确匹配位置 $\\{p_0, p_1, \\ldots\\}$。对于位于测序片段中偏移量为 $o_j$ 的种子，其每个匹配位置 $p$ 都意味着整个测序片段的一个候选起始位置，计算为 $x = p - o_j$。为每个潜在的起始位置 $x$ 维护一个计数器。我们遍历所有种子及其所有匹配，每当一个 $x$ 被推断出来时，就为其对应的计数器加一。处理完所有种子后，我们应用筛选标准：仅当候选起始位置 $x$ 的计数器值至少为 $f$ 时才保留它。这意味着来自测序片段的至少 $f$ 个不同种子支持一个从 $x$ 开始的比对。\n\n_步骤 3：延伸与验证_\n最后一个阶段验证经过筛选的候选位置。对于每个通过筛选的候选起始位置 $x$，我们执行两项检查：\n1.  **边界检查**：比对必须完全位于参考序列 $S$ 内部。这要求 $0 \\le x \\le |S| - L$。超出此范围的候选位置将被丢弃。\n2.  **错配计数**：计算测序片段 $R$ 与相应的参考子串 $S[x : x + L]$ 之间的错配数。如果该计数小于或等于允许的最大值 $k$，则位置 $x$ 被接受为有效的比对位置。\n\n每个测序片段的最终输出是所有此类经过验证的起始位置的排序列表。这种压缩索引和启发式筛选的原则性组合，实现了一个高效而又灵敏的测序片段比对过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import Counter\n\nclass FMIndex:\n    \"\"\"\n    An implementation of the Ferragina–Manzini (FM) index.\n    \"\"\"\n    def __init__(self, text, alphabet):\n        \"\"\"\n        Constructs the FM index for a given text.\n        Args:\n            text (str): The input string, ending with a sentinel '$'.\n            alphabet (list): A list of characters in the alphabet, sorted lexicographically.\n        \"\"\"\n        self.text = text\n        self.alphabet = alphabet\n        self.n = len(text)\n        self.char_map = {c: i for i, c in enumerate(self.alphabet)}\n\n        # 1. Suffix Array (SA) construction\n        suffixes = sorted([(self.text[i:], i) for i in range(self.n)])\n        self.sa = np.array([s[1] for s in suffixes], dtype=np.int32)\n\n        # 2. Burrows–Wheeler Transform (BWT) string B\n        bwt_chars = []\n        for i in range(self.n):\n            bwt_chars.append(self.text[(self.sa[i] - 1) % self.n])\n        self.bwt = \"\".join(bwt_chars)\n\n        # 3. C-Table (counts of chars lexicographically smaller than c)\n        self.c_table = {}\n        counts = Counter(self.text)\n        total = 0\n        for char in self.alphabet:\n            self.c_table[char] = total\n            total += counts.get(char, 0)\n        \n        # 4. Occurrence (Occ) table\n        self.occ = np.zeros((len(self.alphabet), self.n + 1), dtype=np.int32)\n        for i in range(self.n):\n            self.occ[:, i + 1] = self.occ[:, i]\n            if self.bwt[i] in self.char_map:\n                char_idx = self.char_map[self.bwt[i]]\n                self.occ[char_idx, i + 1] += 1\n\n    def _get_occ(self, char, index):\n        \"\"\" Helper to query the Occ table. \"\"\"\n        return self.occ[self.char_map[char], index]\n\n    def search(self, pattern):\n        \"\"\"\n        Performs backward search to find exact matches of a pattern.\n        Args:\n            pattern (str): The pattern to search for.\n        Returns:\n            list: A sorted list of starting positions of the pattern in the original text.\n        \"\"\"\n        if not pattern:\n            return []\n        \n        l, r = 0, self.n\n        for char in reversed(pattern):\n            if char not in self.char_map:\n                return []\n            \n            l = self.c_table[char] + self._get_occ(char, l)\n            r = self.c_table[char] + self._get_occ(char, r)\n            \n            if l >= r:\n                return []\n        \n        return sorted([self.sa[i] for i in range(l, r)])\n\ndef find_candidates(fm_index, S, R, k, m, f):\n    \"\"\"\n    Implements the seed-and-extend mapping algorithm.\n    Args:\n        fm_index (FMIndex): The pre-computed FM index of the reference.\n        S (str): The reference DNA string.\n        R (str): The read DNA string.\n        k (int): Maximum allowed mismatches.\n        m (int): Seed length.\n        f (int): Minimum number of seeds required to support a candidate.\n    Returns:\n        list: A sorted list of valid start positions.\n    \"\"\"\n    L = len(R)\n    s_len = len(S)\n    \n    candidate_supports = Counter()\n    num_seeds = L // m\n    \n    for j in range(num_seeds):\n        offset = j * m\n        seed = R[offset : offset + m]\n        \n        match_positions = fm_index.search(seed)\n        \n        for p in match_positions:\n            candidate_start = p - offset\n            candidate_supports[candidate_start] += 1\n            \n    filtered_starts = []\n    for start_pos, count in candidate_supports.items():\n        if count >= f:\n            filtered_starts.append(start_pos)\n            \n    valid_starts = []\n    for x in sorted(filtered_starts):\n        if 0 = x = s_len - L:\n            mismatches = 0\n            ref_substring = S[x : x + L]\n            for i in range(L):\n                if R[i] != ref_substring[i]:\n                    mismatches += 1\n            if mismatches = k:\n                valid_starts.append(x)\n                \n    return valid_starts\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and produce the final output.\n    \"\"\"\n    S = \"ACGTACGTACGTACGTACGTACGT\"\n    alphabet = ['$', 'A', 'C', 'G', 'T']\n    \n    text_with_sentinel = S + '$'\n    fm_index = FMIndex(text_with_sentinel, alphabet)\n\n    test_cases = [\n        # (R, L, k, m, f) - L is provided but len(R) is used as it's equivalent\n        (\"ACGTACGTACG\", 11, 1, 5, 1), # Case A\n        (\"GTACGT\", 6, 0, 3, 2),       # Case B\n        (\"ACGTACG\", 7, 2, 3, 1),       # Case C\n        (\"AAGTACGTA\", 9, 1, 4, 2)     # Case D\n    ]\n\n    results = []\n    for R, L, k, m, f in test_cases:\n        result = find_candidates(fm_index, S, R, k, m, f)\n        results.append(result)\n\n    # Format the output string to be exactly as required\n    print(f\"[{','.join(map(str, results))}]\".replace(\" \", \"\"))\n\nsolve()\n```"
        }
    ]
}