{
    "hands_on_practices": [
        {
            "introduction": "本练习将深入探讨控制族系错误率（FWER）的基本方法，即在所有检验中至少犯一个第一类错误的概率。通过对一组给定的 $p$ 值手动应用 Bonferroni、Holm 和 Hochberg 程序，你将对它们的运作机制和相对统计功效有一个具体的理解。这个练习对于建立关于最严格多重检验校正形式中内在权衡的直觉至关重要。",
            "id": "3351050",
            "problem": "在一项计算系统生物学研究中，一位研究人员评估了一组由五个不相交的通路组成的特定集合，在两种条件下通路活性的差异。每个通路都由来自独立基因集的综合评分来表示。对每个通路都进行了一次假设检验，使用一种经过良好校准并能产生有效$p$值的检验方法，来比较不同条件下的活性评分。通路水平的检验被假定满足逐步族系错误率(FWER)控制程序有效的条件，例如检验统计量的独立性或正相关性。\n\n该研究人员旨在使用三种经典程序将族系错误率(FWER)控制在$\\alpha=0.05$的水平：Bonferroni校正、Holm降步法和Hochberg升步法。五个通路排序后的$p$值为$p_{(1)}=0.002$、$p_{(2)}=0.01$、$p_{(3)}=0.03$、$p_{(4)}=0.07$和$p_{(5)}=0.2$，总共有$m=5$个假设。\n\n从FWER和有效多重检验程序的核心定义出发，确定每种方法拒绝了多少个原假设。请以(Bonferroni, Holm, Hochberg)的顺序，用一行三个数字报告你的最终答案。无需四舍五入。",
            "solution": "首先验证问题陈述，以确保其科学基础扎实、问题定义明确、客观且完整。\n\n### 步骤1：提取已知条件\n- 假设（通路）总数，$m = 5$。\n- 期望的族系错误率(FWER)控制水平，$\\alpha = 0.05$。\n- 五个假设检验针对不相交的通路，并且它们的检验统计量被假定为独立或表现出正相关，这使得Holm和Hochberg程序的使用是有效的。\n- 来自假设检验的排序后的$p$值为：\n  - $p_{(1)} = 0.002$\n  - $p_{(2)} = 0.01$\n  - $p_{(3)} = 0.03$\n  - $p_{(4)} = 0.07$\n  - $p_{(5)} = 0.2$\n- 需要评估的三种多重检验程序是：Bonferroni校正、Holm降步法和Hochberg升步法。\n\n### 步骤2：使用提取的已知条件进行验证\n- **科学基础扎实：** 该问题牢固地植根于统计推断，特别是多重假设检验，这是计算系统生物学和许多其他科学领域中的一个关键课题。Bonferroni、Holm和Hochberg程序是控制FWER的标准、成熟方法。所提供的假设（独立性或正相关性）是证明这些程序有效的标准条件。\n- **问题定义明确：** 该问题定义清晰，包含了所有必要的数值（$m$、$\\alpha$和$p$值集合）以及一个具体的目标（确定每种方法的拒绝数量）。通过应用这三种程序的定义，可以得出一个唯一且有意义的解。\n- **客观性：** 问题以精确、定量和无偏见的语言陈述。没有主观因素或观点。\n\n### 步骤3：结论与行动\n该问题是有效的。它是多重假设检验基本原理的直接且表述清晰的应用。将继续进行求解。\n\n目标是确定由三种旨在将族系错误率(FWER)控制在$\\alpha = 0.05$水平的多重检验程序各自拒绝的原假设数量。FWER是在一系列假设检验中犯至少一个I类错误（错误地拒绝一个真实的原假设）的概率。给定$m=5$个假设，其排序后的$p$值为$p_{(1)} \\le p_{(2)} \\le p_{(3)} \\le p_{(4)} \\le p_{(5)}$。\n\n**1. Bonferroni校正**\n\nBonferroni校正是一种单步法，如果任何原假设$H_i$对应的$p$值$p_i$满足不等式：\n$$p_i \\le \\frac{\\alpha}{m}$$\n则拒绝该原假设。\n在本例中，调整后的显著性阈值为$\\frac{0.05}{5} = 0.01$。我们将每个$p$值与此阈值进行比较。\n- $p_{(1)} = 0.002 \\le 0.01$。拒绝原假设$H_{(1)}$。\n- $p_{(2)} = 0.01 \\le 0.01$。拒绝原假设$H_{(2)}$。\n- $p_{(3)} = 0.03  0.01$。不拒绝原假设$H_{(3)}$。\n- $p_{(4)} = 0.07  0.01$。不拒绝原假设$H_{(4)}$。\n- $p_{(5)} = 0.2  0.01$。不拒绝原假设$H_{(5)}$。\n\nBonferroni程序拒绝了两个假设。\n\n**2. Holm降步法**\n\nHolm法是一种序贯降步法，其功效统一优于Bonferroni校正。该程序将排序后的$p$值与一系列递减保守的阈值进行检验。对于$j = 1, 2, \\dots, m$，我们比较$p_{(j)}$与$\\frac{\\alpha}{m - j + 1}$。该程序从最小的$p$值开始，在第一个不满足不等式的地方停止。\n\n- **步骤1 ($j=1$):** 比较$p_{(1)}$与$\\frac{\\alpha}{m - 1 + 1} = \\frac{0.05}{5} = 0.01$。\n  $p_{(1)} = 0.002 \\le 0.01$。条件满足。我们拒绝$H_{(1)}$并进入下一步。\n\n- **步骤2 ($j=2$):** 比较$p_{(2)}$与$\\frac{\\alpha}{m - 2 + 1} = \\frac{0.05}{4} = 0.0125$。\n  $p_{(2)} = 0.01 \\le 0.0125$。条件满足。我们拒绝$H_{(2)}$并进入下一步。\n\n- **步骤3 ($j=3$):** 比较$p_{(3)}$与$\\frac{\\alpha}{m - 3 + 1} = \\frac{0.05}{3} \\approx 0.0167$。\n  $p_{(3)} = 0.03  0.0167$。条件不满足。程序停止。\n\n根据Holm程序，我们拒绝假设$H_{(1)}$和$H_{(2)}$，并且不拒绝$H_{(3)}$、$H_{(4)}$和$H_{(5)}$。因此，Holm程序拒绝了两个假设。\n\n**3. Hochberg升步法**\n\nHochberg程序是一种序贯升步法，在给定的独立性或正相关性假设下，其功效统一优于Holm程序。它从最大的$p$值开始，向最小的$p$值进行。目标是找到满足以下条件的最大索引$k \\in \\{1, 2, \\dots, m\\}$：\n$$p_{(k)} \\le \\frac{\\alpha}{m - k + 1}$$\n如果找到了这样的$k$，则所有假设$H_{(1)}, \\dots, H_{(k)}$都被拒绝。\n\n- **步骤1 (检验$k=5$):** 比较$p_{(5)}$与$\\frac{\\alpha}{m - 5 + 1} = \\frac{0.05}{1} = 0.05$。\n  $p_{(5)} = 0.2  0.05$。条件不满足。\n\n- **步骤2 (检验$k=4$):** 比较$p_{(4)}$与$\\frac{\\alpha}{m - 4 + 1} = \\frac{0.05}{2} = 0.025$。\n  $p_{(4)} = 0.07  0.025$。条件不满足。\n\n- **步骤3 (检验$k=3$):** 比较$p_{(3)}$与$\\frac{\\alpha}{m - 3 + 1} = \\frac{0.05}{3} \\approx 0.0167$。\n  $p_{(3)} = 0.03  0.0167$。条件不满足。\n\n- **步骤4 (检验$k=2$):** 比较$p_{(2)}$与$\\frac{\\alpha}{m - 2 + 1} = \\frac{0.05}{4} = 0.0125$。\n  $p_{(2)} = 0.01 \\le 0.0125$。条件满足。\n\n满足不等式的最大索引是$k=2$。因此，Hochberg程序拒绝从$H_{(1)}$到$H_{(k=2)}$的所有假设，即包括$H_{(1)}$和$H_{(2)}$。Hochberg程序拒绝了两个假设。\n\n总结如下：\n- Bonferroni拒绝计数：$2$\n- Holm拒绝计数：$2$\n- Hochberg拒绝计数：$2$\n最终答案是这三个计数的行向量。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n2  2  2\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "尽管控制 FWER 非常严格，但计算生物学中的许多大规模分析优先考虑控制错误发现率（FDR），即在所有发现中假阳性的预期比例。本练习对比了广泛使用的 Benjamini-Hochberg (BH) 程序与更为保守的 Benjamini-Yekutieli (BY) 方法，后者在任意依赖结构下仍然有效。这种比较阐明了关于数据假设与分析统计功效之间的关键关系。",
            "id": "3350985",
            "problem": "在一个用于转录调控模块的计算系统生物学流程中，进行了一次小规模的差异表达筛选。你使用一个校准良好的检验来测试 $m=6$ 个预先指定的基因在两种条件下的差异活性，该检验的零分布 $p$ 值是有效的。观测到的 $p$ 值为 $\\left(0.001,\\,0.004,\\,0.02,\\,0.06,\\,0.08,\\,0.3\\right)$，你可以假设它们已经按升序排列。你希望使用 Benjamini–Hochberg (BH) 步进程序，在独立性或正相关性的条件下，将错误发现率 (FDR) 控制在 $\\alpha=0.1$ 的水平。并与使用调和校正因子 $c(m)=\\sum_{i=1}^{m} 1/i$ 在任意依赖性条件下控制 FDR 的 Benjamini–Yekutieli (BY) 步进程序进行比较。设 $R_{\\mathrm{BH}}$ 表示在水平 $\\alpha$ 下使用 BH 程序拒绝的假设数量，设 $R_{\\mathrm{BY}}$ 表示在水平 $\\alpha$ 下使用带调和校正的 BY 程序拒绝的假设数量。\n\n计算差值 $D=R_{\\mathrm{BH}}-R_{\\mathrm{BY}}$。将 $D$ 报告为单个整数。无需四舍五入。",
            "solution": "我们从多重检验错误率和步进程序的核心定义开始。错误发现率 (FDR) 是在所有被拒绝的假设中，错误拒绝的假设所占的期望比例。Benjamini–Hochberg (BH) 程序是一种步进法，在独立性或某些正相关结构下，它能将 FDR 控制在目标水平 $\\alpha$。Benjamini–Yekutieli (BY) 程序通过将 $\\alpha$ 替换为一个更保守的水平 $\\alpha/c(m)$，将 BH 程序推广到任意依赖性的情况，其中 $c(m)=\\sum_{i=1}^{m} 1/i$ 是第 $m$ 个调和数。\n\n给定已排序的 $p$ 值 $p_{(1)} \\leq p_{(2)} \\leq \\cdots \\leq p_{(m)}$ 和目标水平 $\\alpha$，BH 步进规则找到满足以下条件的最大索引 $k_{\\mathrm{BH}}$：\n$$\np_{(k_{\\mathrm{BH}})} \\leq \\frac{k_{\\mathrm{BH}}}{m}\\,\\alpha,\n$$\n然后恰好拒绝索引为 $1,2,\\ldots,k_{\\mathrm{BH}}$ 的假设。拒绝的数量为 $R_{\\mathrm{BH}}=k_{\\mathrm{BH}}$。类似地，BY 步进规则使用调整后的临界值 $\\alpha/c(m)$，找到满足以下条件的最大 $k_{\\mathrm{BY}}$：\n$$\np_{(k_{\\mathrm{BY}})} \\leq \\frac{k_{\\mathrm{BY}}}{m}\\,\\frac{\\alpha}{c(m)}=\\frac{k_{\\mathrm{BY}}}{m\\,c(m)}\\,\\alpha,\n$$\n并拒绝 $1,2,\\ldots,k_{\\mathrm{BY}}$，因此 $R_{\\mathrm{BY}}=k_{\\mathrm{BY}}$。\n\n将 BH 程序应用于给定数据。这里 $m=6$, $\\alpha=0.1$，已排序的 $p$ 值为：\n$$\np_{(1)}=0.001,\\quad p_{(2)}=0.004,\\quad p_{(3)}=0.02,\\quad p_{(4)}=0.06,\\quad p_{(5)}=0.08,\\quad p_{(6)}=0.3.\n$$\n计算 $i=1,\\ldots,6$ 的 BH 临界值 $\\frac{i}{m}\\alpha=\\frac{i}{6}\\cdot 0.1$：\n$$\n\\frac{1}{6}\\cdot 0.1=\\frac{1}{60}\\approx 0.016\\overline{6},\\quad\n\\frac{2}{6}\\cdot 0.1=\\frac{1}{30}\\approx 0.033\\overline{3},\\quad\n\\frac{3}{6}\\cdot 0.1=\\frac{1}{20}=0.05,\n$$\n$$\n\\frac{4}{6}\\cdot 0.1=\\frac{2}{30}=\\frac{1}{15}\\approx 0.066\\overline{6},\\quad\n\\frac{5}{6}\\cdot 0.1=\\frac{1}{12}\\approx 0.083\\overline{3},\\quad\n\\frac{6}{6}\\cdot 0.1=0.1.\n$$\n将每个 $p_{(i)}$ 与其临界值进行比较：\n- 对于 $i=1$: $0.001 \\leq 0.016\\overline{6}$ 成立。\n- 对于 $i=2$: $0.004 \\leq 0.033\\overline{3}$ 成立。\n- 对于 $i=3$: $0.02 \\leq 0.05$ 成立。\n- 对于 $i=4$: $0.06 \\leq 0.066\\overline{6}$ 成立。\n- 对于 $i=5$: $0.08 \\leq 0.083\\overline{3}$ 成立。\n- 对于 $i=6$: $0.3 \\leq 0.1$ 不成立。\n\n满足该不等式的最大索引为 $k_{\\mathrm{BH}}=5$，因此 $R_{\\mathrm{BH}}=5$。\n\n接下来应用 BY 程序。首先计算 $m=6$ 时的调和因子：\n$$\nc(6)=\\sum_{i=1}^{6}\\frac{1}{i}=1+\\frac{1}{2}+\\frac{1}{3}+\\frac{1}{4}+\\frac{1}{5}+\\frac{1}{6}.\n$$\n使用公分母 $60$，我们得到\n$$\nc(6)=\\frac{60+30+20+15+12+10}{60}=\\frac{147}{60}=\\frac{49}{20}.\n$$\nBY 临界值为\n$$\n\\frac{i}{m}\\cdot \\frac{\\alpha}{c(m)}=\\frac{i}{6}\\cdot \\frac{0.1}{49/20}=\\frac{i}{6}\\cdot \\frac{0.1\\cdot 20}{49}=\\frac{i}{6}\\cdot \\frac{2}{49}.\n$$\n等价地，\n$$\n\\frac{i}{m\\,c(m)}\\,\\alpha=\\frac{i}{6\\cdot (49/20)}\\cdot 0.1=\\frac{i}{14.7}\\cdot 0.1=\\frac{i}{147}.\n$$\n因此，对于 $i=1,\\ldots,6$，BY 阈值恰好为 $\\frac{i}{147}$。比较：\n- 对于 $i=1$: $p_{(1)}=0.001 \\leq \\frac{1}{147}\\approx 0.0068027$ 成立。\n- 对于 $i=2$: $p_{(2)}=0.004 \\leq \\frac{2}{147}\\approx 0.013605$ 成立。\n- 对于 $i=3$: $p_{(3)}=0.02 \\leq \\frac{3}{147}\\approx 0.020408$ 成立。\n- 对于 $i=4$: $p_{(4)}=0.06 \\leq \\frac{4}{147}\\approx 0.027211$ 不成立。\n- 对于 $i=5$: $p_{(5)}=0.08 \\leq \\frac{5}{147}\\approx 0.034014$ 不成立。\n- 对于 $i=6$: $p_{(6)}=0.3 \\leq \\frac{6}{147}\\approx 0.040816$ 不成立。\n\n满足该不等式的最大索引为 $k_{\\mathrm{BY}}=3$，因此 $R_{\\mathrm{BY}}=3$。\n\n因此，所求的差值为\n$$\nD=R_{\\mathrm{BH}}-R_{\\mathrm{BY}}=5-3=2.\n$$\n无需四舍五入，整数结果为 $2$。",
            "answer": "$$\\boxed{2}$$"
        },
        {
            "introduction": "有效的实验设计是产生有影响力的科学研究的基石，在高通量生物学时代，这要求进行考虑了多重检验的先验功效分析。这个高级计算练习模拟了在应用 Benjamini-Hochberg 校正后，为达到期望的平均功效而确定所需最小样本量的过程。通过解决这个问题，你将弥合统计理论与规划资源密集型“组学”研究的实际问题之间的鸿沟。",
            "id": "3351015",
            "problem": "您正在研究在大规模、独立的双边检验中，基因表达均值变化的统计功效。该研究在标准正态模型和已知方差的设定下进行，这是计算系统生物学中的常见情景。一部分比例为 $\\pi_1$ 的基因表现出非零效应，而剩余比例为 $\\pi_0 = 1 - \\pi_1$ 的基因遵循零假设。对于每次检验，您采样 $n$ 个独立重复样本，并对已知方差的总体均值进行双边z检验，然后使用 Benjamini–Hochberg (BH) 程序进行多重检验校正，以控制错误发现率（FDR）。\n\n基本基础：\n- 在零假设下，标准化检验统计量 $Z$ 满足 $Z \\sim \\mathcal{N}(0,1)$，其中 $\\mathcal{N}$ 表示均值为 $0$、方差为 $1$ 的正态分布。\n- 在效应大小为 $\\mu$、已知标准差为 $\\sigma$ 的非零假设下，根据独立同分布正态数据的中心极限定理，样本均值 $\\bar{X}$ 满足 $\\bar{X} \\sim \\mathcal{N}(\\mu, \\sigma^2/n)$。因此，标准化统计量满足 $Z \\sim \\mathcal{N}(\\delta, 1)$，其中 $\\delta = \\sqrt{n}\\mu/\\sigma$。\n- 双边p值为 $p = 2\\left(1 - \\Phi(|Z|)\\right)$，其中 $\\Phi$ 是标准正态分布的累积分布函数。\n\n多重检验模型：\n- 设 $m$ 为检验次数，并假设各检验相互独立。在错误发现率（FDR）水平为 $q$（取 $q = \\alpha$）时，BH程序会拒绝所有p值小于或等于一个依赖于数据的阈值 $\\tau$ 的检验。\n- 当 $m$ 很大时，p值的经验分布收敛于混合分布 $F(t) = \\pi_0 t + \\pi_1 F_1(t)$，其中 $F_1(t) = \\mathbb{P}(p \\le t \\mid H_1)$ 是非零假设下p值的分布。在独立性假设下，当 $m \\to \\infty$ 时，BH阈值 $\\tau$ 渐近地满足不动点方程 $\\tau = q F(\\tau)$。\n\n功效：\n- 非零检验的平均功效等于 $\\mathbb{P}(p \\le \\tau \\mid H_1) = F_1(\\tau)$。\n- 对于双边检验，定义 $z_{t/2} = \\Phi^{-1}(1 - t/2)$，其中 $\\Phi^{-1}$ 是逆累积分布函数。由于 $p \\le t$ 等价于 $|Z| \\ge z_{t/2}$，我们有 $F_1(t) = \\mathbb{P}(|Z| \\ge z_{t/2} \\mid Z \\sim \\mathcal{N}(\\delta,1)) = \\left(1 - \\Phi\\left(z_{t/2} - \\delta\\right)\\right) + \\Phi\\left(-z_{t/2} - \\delta\\right)$。\n\n任务：\n- 编写一个完整、可运行的程序，对于一组给定的参数 $(m, \\pi_1, \\mu, \\sigma, \\alpha)$，计算使得平均功效 $F_1(\\tau)$ 至少为 $0.8$ 的最小整数 $n$。使用由不动点方程 $\\tau = q F(\\tau)$ 定义的渐近 BH 阈值，其中 $q = \\alpha$ 且 $F(t) = \\pi_0 t + \\pi_1 F_1(t)$。\n- 假设每次检验都是独立的，并且是已知 $\\sigma$ 的双边z检验。\n- 如果在 $n \\le 100{,}000$ 的范围内不存在这样的 $n$，则对该测试用例报告 $-1$。\n\n重要说明：\n- 此问题中没有物理单位。\n- 百分比必须作为小数处理；例如，FDR 水平 $q = \\alpha = 0.05$ 意味着 $q = 0.05$。\n\n测试套件：\n为以下参数集计算最小的 $n$。每个参数集是一个元组 $(m, \\pi_1, \\mu, \\sigma, \\alpha)$。\n1. $(10{,}000, 0.1, 0.5, 1, 0.05)$\n2. $(10{,}000, 0.05, 0.4, 1, 0.05)$\n3. $(10{,}000, 0.2, 0.5, 1, 0.01)$\n4. $(10{,}000, 0.1, 1.0, 1, 0.05)$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的整数列表，其顺序与测试套件中的顺序相同。例如，打印的输出必须与 $[n_1,n_2,n_3,n_4]$ 完全一样，没有空格。",
            "solution": "该问题在科学上是合理的、定义明确的且客观的。它完全基于统计假设检验的既定原则，包括正态分布的性质、p值的定义，以及用于控制错误发现率（FDR）的Benjamini–Hochberg程序的渐近理论。每个测试用例都提供了所有必要的参数（$m$, $\\pi_1$, $\\mu$, $\\sigma$, $\\alpha$），使问题自成一体。任务要求找到满足明确定义的功效约束的最小整数 $n$，这是一个可形式化和可解决的计算问题。\n\n目标是找到最小的整数样本量 $n$，使得非零检验的平均功效（表示为 $F_1(\\tau)$）至少为 $0.8$。解决策略涉及搜索这个最优的 $n$。一个关键的观察是，平均功效 $F_1(\\tau)$ 是样本量 $n$ 的单调递增函数。更大的 $n$ 会导致更大的标准化效应大小 $\\delta$，从而增加每个单独检验的功效。这反过来又会同时增加多重检验阈值 $\\tau$ 和最终的平均功效 $F_1(\\tau)$。鉴于这种单调性，二分搜索算法是在指定搜索空间 $[1, 100{,}000]$ 内找到最小 $n$ 的一种高效方法。\n\n对于任何给定的样本量 $n$，计算平均功效是一个必须解决的子问题。此计算过程分为三个主要步骤：\n\n1.  **计算标准化效应大小**：功效计算的基础是备择假设下检验统计量 $Z$ 的分布，即 $Z \\sim \\mathcal{N}(\\delta, 1)$。非中心化参数 $\\delta$ 包含了样本量 $n$、真实平均效应大小 $\\mu$ 和已知标准差 $\\sigma$ 的综合影响。其计算公式为：\n    $$ \\delta = \\frac{\\sqrt{n}\\mu}{\\sigma} $$\n\n2.  **确定多重检验阈值 $\\tau$**：问题指定使用渐近的 Benjamini–Hochberg (BH) 阈值 $\\tau$。该阈值是不动点方程 $\\tau = q F(\\tau)$ 的非平凡解，其中 $q$ 是目标 FDR 水平（此处 $q=\\alpha$），$F(t)$ 是所有检验的p值的累积分布函数（CDF）。p值分布是来自零假设检验的均匀分布和来自非零假设检验的分布的混合：\n    $$ F(t) = \\pi_0 t + \\pi_1 F_1(t) $$\n    其中 $\\pi_0 = 1 - \\pi_1$。项 $F_1(t)$ 是备择假设下p值的CDF，$F_1(t) = \\mathbb{P}(p \\le t \\mid H_1)$。对于双边z检验，p值 $p \\le t$ 等价于检验统计量 $|Z|$ 大于或等于临界值 $z_{t/2} = \\Phi^{-1}(1 - t/2)$，其中 $\\Phi$ 是标准正态CDF。因此，$F_1(t)$ 是概率 $\\mathbb{P}(|Z| \\ge z_{t/2} \\mid Z \\sim \\mathcal{N}(\\delta,1))$，其解析形式为：\n    $$ F_1(t) = \\left(1 - \\Phi\\left(z_{t/2} - \\delta\\right)\\right) + \\Phi\\left(-z_{t/2} - \\delta\\right) $$\n    不动点方程 $\\tau = \\alpha \\left( (1-\\pi_1)\\tau + \\pi_1 F_1(\\tau) \\right)$ 需要数值求解。一种稳健的方法是不动点迭代。从初始估计 $\\tau_0 = \\alpha$ 开始，我们迭代方程 $\\tau_{k+1} = \\alpha F(\\tau_k)$ 直到 $\\tau_k$ 的值收敛。\n\n3.  **计算平均功效**：一旦确定了收敛的阈值 $\\tau$，根据定义，非零检验的平均功效就是 $F_1(\\tau)$。该值使用上一步中 $F_1(t)$ 的公式，在计算出的阈值 $\\tau$ 处求值得到。\n\n完整的算法集成了这些组件。在 $[1, 100{,}000]$ 的范围内对 $n$ 执行二分搜索。对于搜索中的每个候选值 $n$：\n- 使用上述三步过程计算相应的功效。\n- 如果计算出的功效大于或等于目标值 $0.8$，则当前的 $n$ 是一个潜在解，我们在当前范围的下半部分搜索更小的 $n$。\n- 如果功效小于 $0.8$，则候选的 $n$ 太小，我们必须在范围的上半部分进行搜索。\n当找到满足功效要求的最小整数 $n$ 时，搜索终止。如果在 $n=100{,}000$ 时的功效仍低于 $0.8$，则在约束条件下不存在解，结果报告为 $-1$。",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Computes the minimal integer sample size n for a series of multiple testing scenarios\n    to achieve a target average power of 0.8.\n    \"\"\"\n    test_cases = [\n        # (m, pi1, mu, sigma, alpha)\n        (10000, 0.1, 0.5, 1, 0.05),\n        (10000, 0.05, 0.4, 1, 0.05),\n        (10000, 0.2, 0.5, 1, 0.01),\n        (10000, 0.1, 1.0, 1, 0.05),\n    ]\n\n    results = []\n    for case in test_cases:\n        # The number of tests m is provided but not used in the asymptotic formulation,\n        # which is consistent with the problem statement (m -> infinity).\n        m, pi1, mu, sigma, alpha = case\n        \n        def get_power_for_n(n):\n            \"\"\"\n            For a given n, calculates the average power F_1(tau).\n            This involves solving the fixed-point equation for tau.\n            \"\"\"\n            if n == 0:\n                return 0.0\n            \n            delta = np.sqrt(n) * mu / sigma\n            pi0 = 1.0 - pi1\n\n            def F1_t(t):\n                \"\"\"Calculates the CDF of p-values under the alternative hypothesis.\"\"\"\n                if t == 0: return 0.0\n                if t >= 1: return 1.0\n\n                # Use errstate to prevent warnings for t near 0, where ppf(1) -> inf.\n                with np.errstate(divide='ignore', invalid='ignore'):\n                    z_half_t = norm.ppf(1.0 - t / 2.0)\n                \n                # If t is so small that z_half_t is infinite, power is effectively 0.\n                if np.isinf(z_half_t):\n                    return 0.0\n\n                power = (1.0 - norm.cdf(z_half_t - delta)) + norm.cdf(-z_half_t - delta)\n                return power\n\n            def F_t(t):\n                \"\"\"Calculates the mixture CDF of p-values.\"\"\"\n                t_clipped = np.clip(t, 0.0, 1.0)\n                return pi0 * t_clipped + pi1 * F1_t(t_clipped)\n\n            # Solve for tau using fixed-point iteration.\n            # Start with tau = alpha, which is an upper bound on the solution.\n            tau = float(alpha)\n            for _ in range(100):  # 100 iterations are sufficient for convergence.\n                tau_next = alpha * F_t(tau)\n                if abs(tau_next - tau)  1e-12:\n                    tau = tau_next\n                    break\n                tau = tau_next\n            \n            # The average power is F1(tau).\n            return F1_t(tau)\n\n        # Binary search for the minimal n in the range [1, 100000].\n        low = 1\n        high = 100000\n        min_n = -1\n\n        while low = high:\n            mid_n = low + (high - low) // 2\n            if mid_n == 0:\n                low = 1\n                continue\n            \n            power = get_power_for_n(mid_n)\n            \n            if power >= 0.8:\n                # This n is a potential solution. Try to find a smaller one.\n                min_n = mid_n\n                high = mid_n - 1\n            else:\n                # This n is too small. Increase it.\n                low = mid_n + 1\n\n        results.append(min_n)\n        \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}