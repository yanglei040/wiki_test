{
    "hands_on_practices": [
        {
            "introduction": "当我们拥有高质量的测序读段后，下一步通常是将其比对到参考基因组上，并理解它们所覆盖的基因组特征，例如基因、转录本和外显子。通用特征格式第三版（GFF3）是描述这些复杂层级结构注释的标准文件格式。掌握如何解析这种格式对于从基因组注释中提取生物学见解至关重要。\n\n本实践  要求你解析 GFF3 记录并重建转录本的结构。通过将外显子与其父级 mRNA 关联，再将 mRNA 与其父级基因关联，你将学会如何以编程方式处理基因模型，这是转录组学和比较基因组学分析中的一项核心技能。这个练习强调了数据标准中层次关系的重要性以及如何通过算法来解释它们。",
            "id": "3291684",
            "problem": "您将得到一份基于通用特征格式第3版（GFF3）数据标准的描述和约束。该标准在计算系统生物学中被广泛用于表示基因组特征及其关系。目标是从符合GFF3规范的特征记录中重建转录本外显子链，并根据规范检测无效的 Parent 关系。\n\n基本依据：使用GFF3规范的权威规则。通用特征格式第3版（GFF3）是一种以制表符分隔的格式，每行特征有九个字段：序列标识符、来源、类型、起始、终止、得分、链、相位和属性。属性字段包含键值对，如标识符和关系。以下事实被用作基本规则：\n- 坐标是基于 $1$ 的，并且是包含性的。一个特征具有起始坐标 $s$ 和终止坐标 $e$，其中 $s \\le e$。\n- 父子关系通过键为 $ID$ 和 $Parent$ 的属性来表达。子特征通过 $Parent$ 标签列出其父特征；多个父特征用逗号分隔。\n- 类型为 gene、信使RNA（mRNA）和 exon 的特征必须遵循以下亲本关系约束：mRNA 的 $Parent$ 必须引用一个 gene，而 exon 的 $Parent$ 必须引用一个 mRNA。gene 不应有 $Parent$ 标签。\n- 转录本外显子链的顺序取决于链的方向：在正链 $+$ 上，按基因组坐标升序排列；在负链 $-$ 上，按基因组坐标降序排列。起始坐标相同时，应根据终止坐标来决定顺序。\n\n任务：对于提供的每个GFF3片段，为每个mRNA重建外显子链，并检测是否存在任何无效的 $Parent$ 引用。无效的定义如下：\n- 一个 $Parent$ 标识符在已定义的特征 $ID$ 中不存在，或\n- 一个 $Parent$ 存在但类型错误（例如，一个 exon 引用了一个 gene），或\n- 一个 gene 行根本不应含有 $Parent$ 属性。\n\n算法要求：\n- 解析特征，并为mRNA构建从 $ID$ 到类型和链的映射。\n- 对于每个 exon，如果其父特征存在且类型为 mRNA，则将其与每个 $Parent$ mRNA关联起来。\n- 对于每个 mRNA，对其关联的 exon 进行排序以形成其外显子链。对于 $+$ 链，按 $(s,e)$ 升序排序；对于 $-$ 链，按 $(s,e)$ 降序排序，其中 $e$ 用于打破起始坐标的平局。\n- 使用上述规则检测无效的 $Parent$ 引用。\n- 计算复杂度应根据原理进行论证，主要依赖于字典查找和排序操作。\n\n输入模型：您的程序必须将测试套件作为字符串内嵌；不允许外部输入。每个GFF3片段都包含有效的、以制表符分隔的记录，使用九个字段以及包含 $ID$ 和 $Parent$ 标签的属性。\n\n测试套件：\n- 案例1（正链，单个转录本，有序外显子）：基因 $g1$，mRNA $t1$ ($Parent=g1$)，外显子位于坐标 $[100,200]$ 和 $[300,400]$，两者都具有 $Parent=t1$ 和链 $+$。\n- 案例2（负链，单个转录本，无序外显子）：基因 $g2$，mRNA $t2$ ($Parent=g2$)，外显子位于 $[450,480]$ 和 $[500,600]$，两者都具有 $Parent=t2$ 和链 $-$；输出的外显子链必须按起始坐标降序排列，使得起始坐标为 $500$ 的外显子在起始坐标为 $450$ 的外显子之前。\n- 案例3（无效的父引用）：基因 $g3$，mRNA $t3$ ($Parent=g3$)；外显子位于 $[200,250]$（其 $Parent=t3$）和 $[260,300]$（其 $Parent=mr\\_unknown$，不存在）。无效 $Parent$ 检测必须为真；$t3$ 的外显子链必须只包含其有效的外显子。\n- 案例4（多个父特征，其中一个无效）：基因 $g4$，mRNA $t4$ ($Parent=g4$)；一个外显子位于 $[150,180]$，其 $Parent=t4,t4b$（其中 $t4b$ 缺失），另一个外显子位于 $[800,900]$，其 $Parent=t4$。无效 $Parent$ 检测必须为真；$t4$ 的链必须包含两个外显子，在链 $+$ 上按升序排列。\n- 案例5（边界条件：排序中的平局处理和多个转录本）：基因 $g5$；mRNA $t5$ 和 $t5b$ (两者的 $Parent=g5$)，全部在链 $+$ 上。对于 $t5$，外显子位于 $[100,150]$、$[100,120]$ 和 $[160,170]$。对于 $t5b$，外显子位于 $[210,220]$ 和 $[300,320]$。由于终止坐标的平局处理，$t5$ 的链必须将 $[100,120]$ 排在 $[100,150]$ 之前，然后是 $[160,170]$。$t5b$ 的链必须是 $[210,220]$ 紧随其后的是 $[300,320]$。\n\n输出格式：\n- 对于每个测试案例，输出一个形式为 $[B,N,C]$ 的列表，其中 $B$ 是一个布尔值，指示是否检测到任何无效的 $Parent$ 引用；$N$ 是一个整数，等于重建的mRNA数量；$C$ 是一个外显子链的列表（每个mRNA一个，按mRNA的 $ID$ 字典序排序）。每个外显子链必须是一个由转录本顺序的起始和终止坐标连接而成的整数列表，形式为 $[s_1,e_1,s_2,e_2,\\dots]$。\n- 您的程序应生成单行输出，其中包含五个测试案例的结果，形式为用方括号括起来的逗号分隔列表，例如：$[[\\dots],[\\dots],[\\dots],[\\dots],[\\dots]]$。\n\n答案类型：所有输出必须是布尔值、整数、浮点数或这些类型的列表。除了标准列表格式化产生的方括号外，输出中不能有任何字符串。\n\n您的程序必须是一个完整的、可运行的Python程序，该程序内部嵌入测试套件并遵守指定的输出格式。不允许使用外部输入或文件。",
            "solution": "该问题要求根据通用特征格式第3版（GFF3）规范，重建转录本外显子链并验证父子关系。解决方案实现为一个系统的、多遍扫描的算法，该算法首先解析和索引所有基因组特征，然后验证它们的关系并重建转录本模型，最后组装和格式化输出。\n\n该算法的核心依赖于高效的数据结构，主要是字典（哈希映射），用于存储和检索特征信息。这确保了诸如通过其标识符（$ID$）查找特征等操作在平均情况下以常数时间完成，这对性能至关重要。\n\n处理每个GFF3片段的过程如下：\n\n**步骤1：解析和索引**\n\n首先，我们处理原始的GFF3数据。每一行代表一个基因组特征，被解析为其九个组成字段。其中，我们关心的是特征 `type`（字段 $3$）、`start` 和 `end` 坐标（字段 $4$ 和 $5$）、`strand`（字段 $7$）以及 `attributes`（字段 $9$）。\n\n`attributes` 字段是一个以分号分隔的 `key=value` 对列表，我们解析它以提取唯一的特征 `ID` 和任何 `Parent` 标识符。由于 `Parent` 属性可以指定多个以逗号分隔的父特征，因此这些父特征被解析为一个字符串列表。\n\n所有解析出的特征都存储在一个主字典中，我们称之为 `feature_map`。该字典将每个特征的 `ID` 映射到一个包含其基本属性的对象：`type`、`strand` 和 `Parent` ID列表。坐标与 exon 特征一起临时存储，以备后用。这种索引至关重要，因为它允许在验证父子链接时进行快速查找（平均时间复杂度为 $O(1)$）。同时，还维护了一个包含所有 `mRNA` 特征 `ID` 的单独列表。\n\n**步骤2：验证和外显子关联**\n\n第二遍扫描会遍历所有解析出的特征，以验证问题中指定的亲本关系规则，并将 exon 与其父 mRNA 关联起来。一个布尔标志 `invalid_parent_detected` 被初始化为 `false`，如果发现任何违反规则的情况，它将被设置为 `true`。\n\n验证规则的应用如下：\n1.  **带 `Parent` 的基因**：如果发现 `type` 为 'gene' 的特征具有 `Parent` 属性，则将 `invalid_parent_detected` 设置为 `true`。\n2.  **mRNA 亲本关系**：对于每个 `type` 为 'mRNA' 的特征，我们遍历其 `Parent` ID。对于每个父ID `p_id`：\n    - 如果 `p_id` 不在 `feature_map` 的键中，则父特征不存在。`invalid_parent_detected` 设置为 `true`。\n    - 如果 `p_id` 存在，我们检查 `feature_map[p_id].type` 是否为 'gene'。如果不是，则父特征类型错误，`invalid_parent_detected` 设置为 `true`。\n3.  **Exon 亲本关系**：对于每个 `type` 为 'exon' 的特征，我们遍历其 `Parent` ID。对于每个父ID `p_id`：\n    - 如果 `p_id` 不在 `feature_map` 中，`invalid_parent_detected` 设置为 `true`。\n    - 如果 `p_id` 存在，我们检查 `feature_map[p_id].type` 是否为 'mRNA'。如果不是，`invalid_parent_detected` 设置为 `true`。如果它是一个有效的 'mRNA' 父特征，则该 exon 的坐标 $(s, e)$ 被添加到一个与该 `p_id` 关联的列表中，该列表位于一个单独的字典 `mrna_to_exons` 中。这个字典将每个 mRNA `ID` 映射到其组成 exon 的列表。\n\n**步骤3：外显子链组装和排序**\n\n验证之后，`mrna_to_exons` 字典包含了所有有效的 mRNA 到 exon 的关联。最后一步是为每个 mRNA 构建有序的外显子链。\n\n首先，对 mRNA 的 `ID`进行字典序排序，以确保最终链列表的输出顺序是确定的。然后，对于每个 mRNA：\n- 检索关联的 exon 列表。\n- 从 `feature_map` 中查找该 mRNA 的 `strand`。\n- exon 的排序顺序由 `strand` 决定：\n    - 对于正链（`+`），exon 按其 `start` 坐标升序排序。`start` 坐标的平局由 `end` 坐标（同样是升序）打破。这对应于对坐标对 $(s, e)$ 进行字典序排序。\n    - 对于负链（`-`），exon 按其 `start` 坐标降序排序。平局由 `end` 坐标（同样是降序）打破。这相当于对坐标对 $(s, e)$ 进行反向字典序排序。\n- 排序后的 exon 坐标对列表随后被展平成一个单一的整数列表，形式为 $[s_1, e_1, s_2, e_2, \\dots]$。\n\n**最终输出生成**\n\n对于每个测试案例，最终结果是一个三元列表 $[B, N, C]$，其中：\n- $B$ 是 `invalid_parent_detected` 布尔标志。\n- $N$ 是在输入片段中找到的 `mRNA` 特征的总数。\n- $C$ 是展平并排序的外显子链列表，根据字典序排序的 mRNA `ID` 进行排序。\n\n**计算复杂度**\n\n设 $N$ 为GFF3片段中的特征（行）数量。\n- 解析和索引阶段（步骤1）需要对 $N$ 行进行单次遍历，字典插入的平均时间复杂度为 $O(1)$。此阶段的时间复杂度为 $O(N)$。\n- 验证和关联阶段（步骤2）涉及对 $N$ 个特征的另一次遍历。对于每个特征，我们可能需要检查少量的父特征。每次检查都是一次字典查找（$O(1)$）。此阶段的时间复杂度也近似为 $O(N)$。\n- 组装和排序阶段（步骤3）主要由为每个 mRNA 排序 exon 的操作主导。如果有 $K$ 个 mRNA，第 $k$ 个 mRNA 有 $E_k$ 个 exon，总时间为 $\\sum_{k=1}^{K} O(E_k \\log E_k)$。在最坏情况下，即所有 $N$ 个特征都是单个转录本的 exon，时间复杂度变为 $O(N \\log N)$。对 $K$ 个 mRNA ID 进行排序需要 $O(K \\log K)$。\n因此，整体复杂度由排序主导，形成了一个高效的 $O(N \\log N)$ 算法。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the GFF3 transcript reconstruction and validation problem.\n    This function embeds the test suite and processes each case according to GFF3 rules.\n    \"\"\"\n    test_cases_gff3 = [\n        # Case 1: positive strand, single transcript, ordered exons\n        \"\"\"\nchr1\\t.\\tgene\\t100\\t400\\t.\\t+\\t.\\tID=g1\nchr1\\t.\\tmRNA\\t100\\t400\\t.\\t+\\t.\\tID=t1;Parent=g1\nchr1\\t.\\texon\\t100\\t200\\t.\\t+\\t.\\tID=e1;Parent=t1\nchr1\\t.\\texon\\t300\\t400\\t.\\t+\\t.\\tID=e2;Parent=t1\n        \"\"\",\n        # Case 2: negative strand, single transcript, out-of-order exons\n        \"\"\"\nchr2\\t.\\tgene\\t450\\t600\\t.\\t-\\t.\\tID=g2\nchr2\\t.\\tmRNA\\t450\\t600\\t.\\t-\\t.\\tID=t2;Parent=g2\nchr2\\t.\\texon\\t500\\t600\\t.\\t-\\t.\\tID=e3;Parent=t2\nchr2\\t.\\texon\\t450\\t480\\t.\\t-\\t.\\tID=e4;Parent=t2\n        \"\"\",\n        # Case 3: invalid parent reference (nonexistent)\n        \"\"\"\nchr3\\t.\\tgene\\t200\\t300\\t.\\t+\\t.\\tID=g3\nchr3\\t.\\tmRNA\\t200\\t300\\t.\\t+\\t.\\tID=t3;Parent=g3\nchr3\\t.\\texon\\t200\\t250\\t.\\t+\\t.\\tID=e5;Parent=t3\nchr3\\t.\\texon\\t260\\t300\\t.\\t+\\t.\\tID=e6;Parent=mr_unknown\n        \"\"\",\n        # Case 4: multiple parents with one invalid\n        \"\"\"\nchr4\\t.\\tgene\\t150\\t900\\t.\\t+\\t.\\tID=g4\nchr4\\t.\\tmRNA\\t150\\t900\\t.\\t+\\t.\\tID=t4;Parent=g4\nchr4\\t.\\texon\\t150\\t180\\t.\\t+\\t.\\tID=e7;Parent=t4,t4b\nchr4\\t.\\texon\\t800\\t900\\t.\\t+\\t.\\tID=e8;Parent=t4\n        \"\"\",\n        # Case 5: boundary conditions: tie-breaking and multiple transcripts\n        \"\"\"\nchr5\\t.\\tgene\\t100\\t320\\t.\\t+\\t.\\tID=g5\nchr5\\t.\\tmRNA\\t100\\t170\\t.\\t+\\t.\\tID=t5;Parent=g5\nchr5\\t.\\tmRNA\\t210\\t320\\t.\\t+\\t.\\tID=t5b;Parent=g5\nchr5\\t.\\texon\\t100\\t150\\t.\\t+\\t.\\tID=e9;Parent=t5\nchr5\\t.\\texon\\t100\\t120\\t.\\t+\\t.\\tID=e10;Parent=t5\nchr5\\t.\\texon\\t160\\t170\\t.\\t+\\t.\\tID=e11;Parent=t5\nchr5\\t.\\texon\\t210\\t220\\t.\\t+\\t.\\tID=e12;Parent=t5b\nchr5\\t.\\texon\\t300\\t320\\t.\\t+\\t.\\tID=e13;Parent=t5b\n        \"\"\"\n    ]\n\n    results = []\n    \n    for gff3_data in test_cases_gff3:\n        lines = [line for line in gff3_data.strip().split('\\n') if line.strip()]\n        \n        feature_map = {}\n        all_features = [] # To iterate over in the second pass\n\n        # Pass 1: Parse and index all features\n        for line in lines:\n            fields = line.strip().split('\\t')\n            seqid, source, ftype, start, end, score, strand, phase, attributes_str = fields\n            start, end = int(start), int(end)\n\n            # Parse attributes\n            attrs = {}\n            for part in attributes_str.split(';'):\n                if '=' in part:\n                    key, value = part.split('=', 1)\n                    attrs[key] = value\n\n            feature_id = attrs.get('ID')\n            parents = attrs.get('Parent', '').split(',') if attrs.get('Parent') else []\n\n            feature_info = {\n                'id': feature_id,\n                'type': ftype,\n                'start': start,\n                'end': end,\n                'strand': strand,\n                'parents': parents\n            }\n            \n            if feature_id:\n                feature_map[feature_id] = feature_info\n            \n            all_features.append(feature_info)\n\n        invalid_parent_found = False\n        mrna_ids = sorted([fid for fid, finfo in feature_map.items() if finfo['type'] == 'mRNA'])\n        mrna_to_exons = {mid: [] for mid in mrna_ids}\n        \n        # Pass 2: Validate relationships and associate exons\n        for feature in all_features:\n            ftype = feature['type']\n            parents = feature['parents']\n\n            if ftype == 'gene' and parents:\n                invalid_parent_found = True\n\n            elif ftype == 'mRNA':\n                if not parents: # An mRNA must have a parent\n                  invalid_parent_found = True\n                for parent_id in parents:\n                    if parent_id not in feature_map:\n                        invalid_parent_found = True\n                    elif feature_map.get(parent_id, {}).get('type') != 'gene':\n                        invalid_parent_found = True\n            \n            elif ftype == 'exon':\n                if not parents: # An exon must have a parent\n                  invalid_parent_found = True\n                for parent_id in parents:\n                    if parent_id not in feature_map:\n                        invalid_parent_found = True\n                    else:\n                        parent_feature = feature_map.get(parent_id)\n                        if parent_feature and parent_feature.get('type') == 'mRNA':\n                            # This check handles cases where an exon parent is a valid mRNA\n                            # but that mRNA is not in the list of mRNAs to be processed (e.g. from another gene).\n                            if parent_id in mrna_to_exons:\n                                mrna_to_exons[parent_id].append((feature['start'], feature['end']))\n                        else:\n                            invalid_parent_found = True\n        \n        # Pass 3: Sort exons and format output\n        exon_chains = []\n        for mrna_id in mrna_ids:\n            exons = mrna_to_exons[mrna_id]\n            strand = feature_map[mrna_id]['strand']\n            \n            if strand == '+':\n                exons.sort(key=lambda x: (x[0], x[1]))\n            elif strand == '-':\n                exons.sort(key=lambda x: (x[0], x[1]), reverse=True)\n            \n            chain = [coord for exon_coords in exons for coord in exon_coords]\n            exon_chains.append(chain)\n\n        results.append([invalid_parent_found, len(mrna_ids), exon_chains])\n\n    # Format the final output string exactly as specified.\n    # The default string representation of lists, booleans, and integers is used.\n    output_str = '[' + ','.join(map(str, results)) + ']'\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "一个生物数据集的价值不仅在于其核心测量数据，还在于描述其来源和生成过程的元数据。如果没有丰富且结构化的元数据来描述实验背景（如样本来源、处理方法和实验条件），生物数据集本身是不完整的。FAIR 原则（可发现、可访问、可互操作、可重用）尤其强调了机器可读元数据对于科学研究可重复性和价值最大化的重要性。\n\n最后的这个练习  将你的视野从基因组数据本身扩展到关键的元数据管理领域。你将设计一个 JSON Schema 来为一个单细胞 RNA 测序研究的样本信息强制执行数据标准。这项任务展示了如何利用形式化的模式来保证数据的完整性和一致性，从而使大规模数据集成和分析变得可行和可靠。",
            "id": "3291672",
            "problem": "您的任务是为单细胞核糖核酸测序（scRNA-seq; single-cell RNA sequencing）研究中的样本元数据设计并以编程方式强制执行一个数据标准。其目标是将数据完整性和互操作性的首要原则，例如可查找（Findable）、可访问（Accessible）、可互操作（Interoperable）、可重用（Reusable）（简称FAIR原则），转化为一个具体的验证方案，用于以JavaScript对象表示法（JSON; JavaScript Object Notation）表示的表格记录。从数理逻辑和集合论的角度来看，一个模式（schema）通过在指定域上建立类型约束、集合成员关系（枚举）和数值顺序关系来规定可接受的值。\n\n从以下基本依据出发：\n- 类型即集合：字符串字段的值取自所有有限字符序列的集合，整数字段的值取自整数集合 $\\mathbb{Z}$，数字字段的值取自实数集合 $\\mathbb{R}$。\n- 集合成员约束：枚举约束要求 $x \\in S$，其中 $S$ 是一个明确列出的有限集合。\n- 顺序约束：数值范围表示为 $a \\le x \\le b$，其中 $a$ 是下界，$b$ 是上界，取值于 $\\mathbb{R}$ 或 $\\mathbb{Z}$ 内。\n\n请提出一个JSON Schema，对每条记录 $r$ 强制执行以下属性：\n- 必填字段及其类型：\n  - $sample\\_id$: 字符串。\n  - $species$: 字符串，枚举值为 $S\\_{\\text{species}} = \\{\\text{\"Homo sapiens\"}, \\text{\"Mus musculus\"}\\}$。\n  - $tissue$: 字符串，枚举值为 $S\\_{\\text{tissue}} = \\{\\text{\"lung\"}, \\text{\"liver\"}, \\text{\"kidney\"}\\}$。\n  - $platform$: 字符串，枚举值为 $S\\_{\\text{platform}} = \\{\\text{\"10x Genomics\"}, \\text{\"Smart-seq2\"}, \\text{\"Drop-seq\"}\\}$。\n  - $umi\\_count$: 整数，范围约束为 $1 \\le umi\\_count \\le 10^6$。\n  - $mito\\_fraction$: 数字，范围约束为 $0 \\le mito\\_fraction \\le 1$，以小数形式表示（不要使用百分号）。\n  - $doublet\\_probability$: 数字，范围约束为 $0 \\le doublet\\_probability \\le 1$，以小数形式表示（不要使用百分号）。\n  - $age\\_years$: 整数，范围约束为 $0 \\le age\\_years \\le 120$，以年为单位表示。\n  - $sex$: 字符串，枚举值为 $S\\_{\\text{sex}} = \\{\\text{\"male\"}, \\text{\"female\"}, \\text{\"unknown\"}\\}$。\n- 可选字段可以存在，但不是必需的。任何存在的字段都必须符合其声明的类型和任何适用的约束。\n- 可以存在上面未列出的额外属性；只要所有必填字段满足约束，它们就不会影响验证结果。\n\n您的程序必须：\n1. 将上述模式构建为一个内部数据对象。\n2. 根据该模式验证一个包含五条记录的测试套件，为每条记录生成一个布尔有效性值，其中 $\\text{True}$ 表示记录符合模式，$\\text{False}$ 表示不符合。\n3. 演示对三种特定格式错误的记录的检测：\n   - 缺少必填字段。\n   - 枚举违规（值不在要求的集合中）。\n   - 数值范围违规（值超出要求的边界）。\n4. 使用以下具有明确值的测试套件：\n   - 记录A（正常情况）：$sample\\_id$ = \"SC0001\", $species$ = \"Homo sapiens\", $tissue$ = \"lung\", $platform$ = \"10x Genomics\", $umi\\_count$ = $50000$, $mito\\_fraction$ = $0.08$, $doublet\\_probability$ = $0.05$, $age\\_years$ = $34$, $sex$ = \"female\"。\n   - 记录B（边界条件）：$sample\\_id$ = \"SC0002\", $species$ = \"Mus musculus\", $tissue$ = \"liver\", $platform$ = \"Smart-seq2\", $umi\\_count$ = $1$, $mito\\_fraction$ = $0.0$, $doublet\\_probability$ = $1.0$, $age\\_years$ = $0$, $sex$ = \"male\"。\n   - 记录C（缺少必填字段）：$sample\\_id$ = \"SC0003\", $tissue$ = \"kidney\", $platform$ = \"Drop-seq\", $umi\\_count$ = $20000$, $mito\\_fraction$ = $0.12$, $doublet\\_probability$ = $0.1$, $age\\_years$ = $12$, $sex$ = \"unknown\"。$species$ 字段被有意省略。\n   - 记录D（枚举违规）：$sample\\_id$ = \"SC0004\", $species$ = \"Drosophila melanogaster\", $tissue$ = \"lung\", $platform$ = \"10x Genomics\", $umi\\_count$ = $30000$, $mito\\_fraction$ = $0.07$, $doublet\\_probability$ = $0.02$, $age\\_years$ = $5$, $sex$ = \"female\"。\n   - 记录E（数值范围违规）：$sample\\_id$ = \"SC0005\", $species$ = \"Homo sapiens\", $tissue$ = \"liver\", $platform$ = \"Smart-seq2\", $umi\\_count$ = $500000$, $mito\\_fraction$ = $1.2$, $doublet\\_probability$ = $0.03$, $age\\_years$ = $27$, $sex$ = \"male\"。\n5. 最终输出格式必须是单行，包含用方括号括起来的逗号分隔列表。例如，如果记录A到E的结果是 $[v\\_A, v\\_B, v\\_C, v\\_D, v\\_E]$ 且 $v\\_i \\in \\{\\text{True}, \\text{False}\\}$，则需精确打印 \"[True,False,True,False,True]\"。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表的结果（例如，\"[result1,result2,result3,result4,result5]\"）。所有测试用例的答案都必须是布尔值。",
            "solution": "该解决方案基于既有的数据完整性原则和模式的形式语义。我们从这样一个观点出发：模式定义了字段域笛卡尔积的一个子集，通过与由类型、枚举和区间边界定义的集合求交集来强制执行约束。\n\n1. 将类型定义为集合。对每个字段 $f$，赋一个类型 $T\\_f$：\n   - 对字符串，$T\\_f$ 是有限字符序列的集合。\n   - 对整数，$T\\_f = \\mathbb{Z}$。\n   - 对数字，$T\\_f = \\mathbb{R}$。\n\n2. 定义必填字段。令 $R$ 为必填字段名的集合。一条记录 $r$ 是可接受的，当且仅当 $\\forall f \\in R$, $f \\in \\text{dom}(r)$，其中 $\\text{dom}(r)$ 是 $r$ 中存在的键的集合。这强制了字段的存在性。\n\n3. 强制执行类型约束。对每个存在的字段 $f$，检查 $r[f] \\in T\\_f$。在代码中，这是一个运行时类型测试。对于整数字段，我们必须确保 $r[f] \\in \\mathbb{Z}$ 并排除布尔值，因为在许多编程语言中，布尔值是整数的子类型；因此我们明确要求 $r[f]$ 是一个整数而不是布尔值。\n\n4. 强制执行枚举约束。对于带枚举的字段，令 $S\\_f$ 为允许的有限集合。要求 $r[f] \\in S\\_f$。这实现了集合成员谓词 $x \\in S$。\n\n5. 强制执行数值范围。对于具有包含边界的数字字段，如果一个值 $x$ 满足 $a \\le x \\le b$，则它是有效的，其中 $a$ 和 $b$ 分别是最小值和最大值。此处：\n   - $1 \\le umi\\_count \\le 10^6$ 表示唯一分子标识符计数。\n   - $0 \\le mito\\_fraction \\le 1$ 和 $0 \\le doublet\\_probability \\le 1$，值以小数表示。\n   - $0 \\le age\\_years \\le 120$。\n\n6. 组合验证器。验证器函数遍历必填字段以检查其存在性，然后遍历属性以：\n   - 断言类型，\n   - 当定义了枚举时应用枚举检查，\n   - 当定义了最小值和最大值时应用检查。\n   任何违规都会产生布尔值 $\\text{False}$；否则返回 $\\text{True}$。\n\n7. 应用于测试套件：\n   - 记录A满足所有约束：类型匹配，所有必填字段都存在，枚举有效，数值在范围内；因此结果为 $\\text{True}$。\n   - 记录B检查边界的包含性：$umi\\_count = 1$、$mito\\_fraction = 0.0$、$doublet\\_probability = 1.0$、$age\\_years = 0$ 都在包含边界内，且枚举有效；因此结果为 $\\text{True}$。\n   - 记录C省略了必填字段 $species$。根据步骤2，$\\exists f \\in R$ 使得 $f \\notin \\text{dom}(r)$，因此结果为 $\\text{False}$。\n   - 记录D将 $species$ 设置为“Drosophila melanogaster”，这违反了 $S\\_{\\text{species}}$。由于 $r[\\text{species}] \\notin S\\_{\\text{species}}$，因此结果为 $\\text{False}$。\n   - 记录E将 $mito\\_fraction$ 设置为 $1.2$，这违反了 $0 \\le mito\\_fraction \\le 1$。因为 $1.2 \\notin [0,1]$，因此结果为 $\\text{False}$。\n\n8. 输出聚合。收集五个布尔值 $[v\\_A, v\\_B, v\\_C, v\\_D, v\\_E]$ 并按要求格式单行打印。这满足了可测试性要求，并演示了基于模式的验证检测到三个格式错误的记录。\n\n这种方法直接实现了来自类型、枚举和数值区间的约束的交集，通过严格遵守共享模式使数据具有互操作性，从而与FAIR原则保持一致。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\n# We use only the Python standard library.\nfrom typing import Any, Dict, List\n\ndef is_integer(value: Any) -> bool:\n    # Exclude booleans (which are subclasses of int in Python)\n    return isinstance(value, int) and not isinstance(value, bool)\n\ndef is_number(value: Any) -> bool:\n    # Accept ints and floats, but exclude booleans\n    return (isinstance(value, int) and not isinstance(value, bool)) or isinstance(value, float)\n\ndef validate_record(record: Dict[str, Any], schema: Dict[str, Any]) -> bool:\n    # Check required fields presence\n    for req in schema.get(\"required\", []):\n        if req not in record:\n            return False\n\n    properties = schema.get(\"properties\", {})\n\n    # Validate each property that appears in the record and is defined in the schema\n    for key, prop in properties.items():\n        if key not in record:\n            # If not present, skip unless it's required (handled above)\n            continue\n        value = record[key]\n        # Type checks\n        expected_type = prop.get(\"type\")\n        if expected_type == \"string\":\n            if not isinstance(value, str):\n                return False\n        elif expected_type == \"integer\":\n            if not is_integer(value):\n                return False\n        elif expected_type == \"number\":\n            if not is_number(value):\n                return False\n        else:\n            # Unknown type in schema; for robustness, consider invalid\n            return False\n\n        # Enumeration check\n        enum_values = prop.get(\"enum\")\n        if enum_values is not None:\n            if value not in enum_values:\n                return False\n\n        # Range checks (minimum and maximum, inclusive)\n        if expected_type in (\"integer\", \"number\"):\n            if \"minimum\" in prop:\n                if value  prop[\"minimum\"]:\n                    return False\n            if \"maximum\" in prop:\n                if value > prop[\"maximum\"]:\n                    return False\n\n    # All checks passed\n    return True\n\ndef solve():\n    # Define the JSON Schema as a Python dictionary\n    schema = {\n        \"type\": \"object\",\n        \"required\": [\n            \"sample_id\",\n            \"species\",\n            \"tissue\",\n            \"platform\",\n            \"umi_count\",\n            \"mito_fraction\",\n            \"doublet_probability\",\n            \"age_years\",\n            \"sex\"\n        ],\n        \"properties\": {\n            \"sample_id\": {\"type\": \"string\"},\n            \"species\": {\n                \"type\": \"string\",\n                \"enum\": [\"Homo sapiens\", \"Mus musculus\"]\n            },\n            \"tissue\": {\n                \"type\": \"string\",\n                \"enum\": [\"lung\", \"liver\", \"kidney\"]\n            },\n            \"platform\": {\n                \"type\": \"string\",\n                \"enum\": [\"10x Genomics\", \"Smart-seq2\", \"Drop-seq\"]\n            },\n            \"umi_count\": {\n                \"type\": \"integer\",\n                \"minimum\": 1,\n                \"maximum\": 10**6\n            },\n            \"mito_fraction\": {\n                \"type\": \"number\",\n                \"minimum\": 0.0,\n                \"maximum\": 1.0\n            },\n            \"doublet_probability\": {\n                \"type\": \"number\",\n                \"minimum\": 0.0,\n                \"maximum\": 1.0\n            },\n            \"age_years\": {\n                \"type\": \"integer\",\n                \"minimum\": 0,\n                \"maximum\": 120\n            },\n            \"sex\": {\n                \"type\": \"string\",\n                \"enum\": [\"male\", \"female\", \"unknown\"]\n            },\n            # Optional fields example (not required)\n            \"library_prep\": {\n                \"type\": \"string\",\n                \"enum\": [\"polyA\", \"totalRNA\"]\n            },\n            \"batch_id\": {\"type\": \"string\"}\n        },\n        # Allow additional properties without affecting validation\n        \"additionalProperties\": True\n    }\n\n    # Define the test cases (records A-E)\n    test_cases: List[Dict[str, Any]] = [\n        # Record A (happy path)\n        {\n            \"sample_id\": \"SC0001\",\n            \"species\": \"Homo sapiens\",\n            \"tissue\": \"lung\",\n            \"platform\": \"10x Genomics\",\n            \"umi_count\": 50000,\n            \"mito_fraction\": 0.08,\n            \"doublet_probability\": 0.05,\n            \"age_years\": 34,\n            \"sex\": \"female\"\n        },\n        # Record B (boundary conditions)\n        {\n            \"sample_id\": \"SC0002\",\n            \"species\": \"Mus musculus\",\n            \"tissue\": \"liver\",\n            \"platform\": \"Smart-seq2\",\n            \"umi_count\": 1,\n            \"mito_fraction\": 0.0,\n            \"doublet_probability\": 1.0,\n            \"age_years\": 0,\n            \"sex\": \"male\"\n        },\n        # Record C (missing required field: species)\n        {\n            \"sample_id\": \"SC0003\",\n            \"tissue\": \"kidney\",\n            \"platform\": \"Drop-seq\",\n            \"umi_count\": 20000,\n            \"mito_fraction\": 0.12,\n            \"doublet_probability\": 0.1,\n            \"age_years\": 12,\n            \"sex\": \"unknown\"\n        },\n        # Record D (enumeration violation: species not allowed)\n        {\n            \"sample_id\": \"SC0004\",\n            \"species\": \"Drosophila melanogaster\",\n            \"tissue\": \"lung\",\n            \"platform\": \"10x Genomics\",\n            \"umi_count\": 30000,\n            \"mito_fraction\": 0.07,\n            \"doublet_probability\": 0.02,\n            \"age_years\": 5,\n            \"sex\": \"female\"\n        },\n        # Record E (numeric range violation: mito_fraction > 1)\n        {\n            \"sample_id\": \"SC0005\",\n            \"species\": \"Homo sapiens\",\n            \"tissue\": \"liver\",\n            \"platform\": \"Smart-seq2\",\n            \"umi_count\": 500000,\n            \"mito_fraction\": 1.2,\n            \"doublet_probability\": 0.03,\n            \"age_years\": 27,\n            \"sex\": \"male\"\n        },\n    ]\n\n    results = []\n    for rec in test_cases:\n        result = validate_record(rec, schema)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}