{
    "hands_on_practices": [
        {
            "introduction": "系统生物学中的一个基本任务是确定目标分子是否可以从一组初始物种合成，如果可以，最有效的反应途径是什么。这个问题可以建模为对代表生物化学网络的图进行可达性分析。在本练习中 ，您将在物种和反应的二分关联图上使用带约束的广度优先搜索（BFS）算法，学习如何整合真实的化学计量要求，以找到所需的最少反应集合。",
            "id": "3317626",
            "problem": "考虑一个计算系统生物学中生化网络的反应超图。设分子种类集合为 $\\mathcal{S}$，反应集合为 $\\mathcal{R}$。每个反应 $r \\in \\mathcal{R}$ 都有一个底物多重集 $\\mathrm{Subs}(r) = \\{(s_i, \\alpha_i)\\}$ 和一个产物多重集 $\\mathrm{Prods}(r) = \\{(p_j, \\beta_j)\\}$，其中 $s_i, p_j \\in \\mathcal{S}$ 且 $\\alpha_i, \\beta_j \\in \\mathbb{N}$ 是化学计量系数。设 $A_0$ 为可用物种的初始多重集，其计数为 $c_0 : \\mathcal{S} \\to \\mathbb{N}$。定义关联图 $\\mathcal{G}$ 为一个二分图，其节点集为 $\\mathcal{S} \\cup \\mathcal{R}$，当 $(s, \\alpha) \\in \\mathrm{Subs}(r)$ 时存在从物种到反应的边 $(s \\to r)$，当 $(p, \\beta) \\in \\mathrm{Prods}(r)$ 时存在从反应到物种的边 $(r \\to p)$。\n\n我们的目标是在以下单调可用性语义下，计算能够生成指定转录因子 $t \\in \\mathcal{S}$ 的最小反应集：反应发生时物种不被消耗；物种的存在性在广度优先层上是单调的。化学计量约束通过边可行性检查来引入：一个反应节点 $r$ 仅当其每个底物 $(s, \\alpha) \\in \\mathrm{Subs}(r)$ 都已有至少 $\\alpha$ 份拷贝（通过初始集 $A_0$ 或先前遍历的反应产物）变得可用后，才是可遍历的。定义一个物种的深度为从 $A_0$ 开始使其可用所需的最少反应数，一个反应的深度为激活它的所有底物拷贝中的最大深度加一。\n\n基本假设和定义：\n- 化学计量矩阵 $N \\in \\mathbb{Z}^{|\\mathcal{S}| \\times |\\mathcal{R}|}$ 的元素为 $N_{s,r} = \\beta_{s,r} - \\alpha_{s,r}$，其中 $\\alpha_{s,r}$ 是物种 $s$ 在反应 $r$ 中的底物系数（如果不存在则为零），$\\beta_{s,r}$ 是产物系数（如果不存在则为零）。\n- 在无权图上进行关联图广度优先搜索 (BFS) 可以得到遍历边数最少的路径。在二分关联结构中，任何从物种到物种的路径都交替经过物种节点和反应节点；只要可遍历性受底物可用性控制，最小化路径长度就意味着最小化遍历的反应节点数量。\n- 在典型的信号转导和转录调控所使用的单调可用性语义下，物种起催化作用且不被消耗，因此 $t$ 的可达性取决于底物多样性需求的满足情况，而无需考虑耗尽问题。\n\n任务：\n设计一个程序，给定反应定义、初始物种计数和目标转录因子 $t$，在关联图上执行受限的广度优先搜索，以找到生成 $t$ 的最小反应集。一个反应只有在其每个 $(s, \\alpha) \\in \\mathrm{Subs}(r)$ 都有至少 $\\alpha$ 份拷贝的 $s$ 在更早或当前的BFS层中出现时，才有资格发生。当一个反应在深度 $d_r$ 发生时，它在相同的深度 $d_r$ 产生乘积事件 $(p, \\beta)$。最小反应集必须通过追溯用于激活每个反应的实际底物拷贝来重建，从而将化学计量约束整合到依赖链中。如果 $t$ 在初始集 $A_0$ 中就可用，则最小反应集为空列表。如果 $t$ 不可达，则返回布尔值 false 和空列表。\n\n您的程序必须解决以下测试套件。每个测试用例由一个反应列表、一个初始计数映射和一个目标 $t$ 指定。反应标识符是每个测试用例内的从零开始的索引，反应以多重集 $(\\mathrm{Subs}, \\mathrm{Prods})$ 的有序对形式给出，编码为从物种名称到整数化学计量系数的映射。\n\n测试套件：\n1. 具有不同底物和产物的正常流程链。\n   - 物种： $\\{A, B, C, D, E, TF\\}$。\n   - 反应：\n     - $r_0$: $\\mathrm{Subs}(r_0) = \\{(A, 1), (B, 1)\\}$, $\\mathrm{Prods}(r_0) = \\{(C, 1)\\}$.\n     - $r_1$: $\\mathrm{Subs}(r_1) = \\{(C, 1)\\}$, $\\mathrm{Prods}(r_1) = \\{(D, 1)\\}$.\n     - $r_2$: $\\mathrm{Subs}(r_2) = \\{(D, 1), (E, 1)\\}$, $\\mathrm{Prods}(r_2) = \\{(TF, 1)\\}$.\n   - 初始计数：$c_0(A) = 1$, $c_0(B) = 1$, $c_0(E) = 1$；其余为 $0$。\n   - 目标：$t = TF$。\n   - 预期结果类型：一个列表，包含一个布尔值和一个按反应深度非递减顺序排列的反应标识符列表。\n\n2. 目标物种初始可用的边界情况。\n   - 与案例1相同的反应。\n   - 初始计数：$c_0(A) = 1$, $c_0(B) = 1$, $c_0(E) = 1$, $c_0(TF) = 1$；其余为 $0$。\n   - 目标：$t = TF$。\n\n3. 需要多个底物拷贝的化学计量边界情况。\n   - 物种：$\\{X, Y, Z\\}$。\n   - 反应：\n     - $r_0$: $\\mathrm{Subs}(r_0) = \\{(Z, 1)\\}$, $\\mathrm{Prods}(r_0) = \\{(X, 1)\\}$.\n     - $r_1$: $\\mathrm{Subs}(r_1) = \\{(X, 2)\\}$, $\\mathrm{Prods}(r_1) = \\{(Y, 1)\\}$.\n   - 初始计数：$c_0(X) = 1$, $c_0(Z) = 1$；其余为 $0$。\n   - 目标：$t = Y$。\n\n4. 在给定反应下目标不可达。\n   - 物种：$\\{U, TF, A\\}$。\n   - 反应：\n     - $r_0$: $\\mathrm{Subs}(r_0) = \\{(U, 1)\\}$, $\\mathrm{Prods}(r_0) = \\{(TF, 1)\\}$.\n   - 初始计数：$c_0(A) = 1$；其余为 $0$。\n   - 目标：$t = TF$。\n\n5. 目标的分支前提条件。\n   - 物种：$\\{A, P, Q, TF\\}$。\n   - 反应：\n     - $r_0$: $\\mathrm{Subs}(r_0) = \\{(A, 1)\\}$, $\\mathrm{Prods}(r_0) = \\{(P, 1)\\}$.\n     - $r_1$: $\\mathrm{Subs}(r_1) = \\{(A, 1)\\}$, $\\mathrm{Prods}(r_1) = \\{(Q, 1)\\}$.\n     - $r_2$: $\\mathrm{Subs}(r_2) = \\{(P, 1), (Q, 1)\\}$, $\\mathrm{Prods}(r_2) = \\{(TF, 1)\\}$.\n   - 初始计数：$c_0(A) = 1$；其余为 $0$。\n   - 目标：$t = TF$。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含五个测试用例的结果，格式为一个由方括号括起来的逗号分隔列表，其中每个结果本身都是 $[\\text{reachable}, \\text{reaction\\_id\\_list}]$ 形式的双元素列表。例如，输出必须看起来像\n$[[\\text{True},[0,1,2]],[\\text{True},[]],[\\text{True},[0,1]],[\\text{False},[]],[\\text{True},[0,1,2]]]$。\n不涉及物理单位，输出是无单位的。不适用角度，也不使用百分比。",
            "solution": "该问题要求从一组初始可用物种开始，确定生成目标分子物种所需的最小反应集。该系统在一个非消耗性、单调可用性的模型下运行，意味着物种计数只会随时间增加。这个问题最好被建模为反应网络上的受限可达性分析，可以通过使用类似广度优先搜索 (BFS) 的迭代算法来确定反应深度，然后使用一个依赖感知的回溯算法来构建最小反应集。\n\n总体方法包括两个主要阶段：用于确定可達性和最小深度的前向传播，以及用于重建特定反应路径的反向传播。\n\n**阶段1：前向传播（可达性与深度分析）**\n\n前向传播逐层模拟反应网络，类似于BFS。每个“层”对应于从初始状态开始反应步骤数的增加。\n\n1.  **初始化**：\n    - 为了高效处理，所有唯一的物种名称都映射到从 $0$ 到 $|\\mathcal{S}|-1$ 的整数索引。反应由其索引 $0$ 到 $|\\mathcal{R}|-1$ 标识。\n    - 一个大小为 $|\\mathcal{S}|$ 的数组 `species_counts` 被初始化为初始计数 $c_0$。\n    - 一个数组 `species_depth`，用于跟踪生成每种物种所需的最少反应数，对所有物种初始化为无穷大（一个哨兵值，如 $-1$），对于初始集 $A_0$ 中存在的物种则初始化为 $0$。\n    - 一个大小为 $|\\mathcal{R}|$ 的数组 `reaction_depth` 被初始化为无穷大。\n    - 一个集合 `fired_reactions` 用于跟踪所有已触发的反应。\n\n2.  **迭代触发**：该算法以迭代方式进行。在每次迭代中，它扫描所有反应，以找到那些新近符合触发条件的反应。\n    - 一个反应 $r$ 被认为是符合条件的，如果：\n        1.  它在之前的迭代中没有被触发过。\n        2.  对于每个底物 $(s, \\alpha) \\in \\mathrm{Subs}(r)$，物种 $s$ 的当前总数至少为 $\\alpha$。\n        3.  所有底物 $s$ 本身都是可用的（即 `species_depth[s]` 不是无穷大）。\n    - 如果在一轮迭代中有一组新的反应变得符合条件，它们被认为在当前的“层”中同时触发。\n    - 对于每个新触发的反应 $r$：\n        - 它被添加到 `fired_reactions` 集合中。\n        - 它的深度 `reaction_depth[r]` 被计算为 $1 + \\max_{s \\in \\mathrm{Subs}(r)} \\{\\text{species\\_depth}[s]\\}$。\n        - 对于每个产物 $(p, \\beta) \\in \\mathrm{Prods}(r)$，总计数 `species_counts[p]` 增加 $\\beta$。\n        - 如果这条新路径比任何先前发现的生成 $p$ 的路径都短，则产物 `species_depth[p]` 的深度将更新为 `reaction_depth[r]`。\n\n3.  **终止**：迭代过程持续进行，直到对所有反应的完整遍历不再产生新的可触发反应。此时，系统达到一个不动点。如果目标物种 $t$ 的 `species_depth` 仍然是无穷大，则目标是不可达的。\n\n**阶段2：反向传播（依赖重构）**\n\n如果目标 $t$ 是可达的，就从 $t$ 开始进行反向搜索以确定最小反应集。这不是简单的路径跟随，因为必须满足化学计量要求。重构过程必须追溯每个所需底物“拷贝”的来源。\n\n1.  **初始化**：\n    - 创建一个字典 `needed_species` 来跟踪所需的物种计数，初始化为 `{t: 1}`。\n    - 一个集合 `required_reactions` 初始化为空。\n\n2.  **递归依赖解析**：算法迭代地处理 `needed_species` 列表。\n    - 对于需要计数为 $k$ 的物种 $s$：\n        - 从 $k$ 中减去初始集 $c_0(s)$ 中可用的数量，得到一个`deficit`（缺口）。\n        - 如果 `deficit` 为正，我们必须找到生成了 $s$ 的反应来弥补这个缺口。\n        - 算法查询前向传播中的 `fired_reactions` 集合，以找到所有生成 $s$ 的反应。这些反应按其 `reaction_depth` 排序，以确保我们首先使用“最快”的生产路线，这与最小路径目标一致。\n        - 从这个排序列表中逐个将反应添加到 `required_reactions` 集合中，直到缺口被弥补。\n        - 对于添加到集合中的每个反应，其自身的底物需求被添加到 `needed_species` 字典中，从而传播回溯过程。\n\n3.  **最终确定**：当 `needed_species` 字典为空时，过程终止。得到的 `required_reactions` 集合被转换为列表，并按规定的反应深度非递减排序（以反应索引作为决胜条件）。",
            "answer": "```python\nimport numpy as np\n\ndef find_minimal_reactions(reactions_def, initial_counts_def, target_species):\n    \"\"\"\n    Finds a minimal set of reactions to produce a target species.\n    \"\"\"\n    # 1. Initialization and mapping\n    all_species = set(initial_counts_def.keys())\n    all_species.add(target_species)\n    for subs, prods in reactions_def:\n        all_species.update(subs.keys())\n        all_species.update(prods.keys())\n    \n    sorted_species_list = sorted(list(all_species))\n    species_to_id = {name: i for i, name in enumerate(sorted_species_list)}\n    id_to_species = {i: name for i, name in enumerate(sorted_species_list)}\n    num_species = len(sorted_species_list)\n    num_reactions = len(reactions_def)\n\n    if not all_species:\n        return [False, []]\n    \n    reactions = []\n    for subs, prods in reactions_def:\n        reactions.append({\n            'subs': {species_to_id[s]: v for s, v in subs.items()},\n            'prods': {species_to_id[p]: v for p, v in prods.items()}\n        })\n\n    # Phase 1: Forward Propagation\n    species_counts = np.zeros(num_species, dtype=int)\n    for s, c in initial_counts_def.items():\n        if s in species_to_id:\n            species_counts[species_to_id[s]] = c\n\n    species_depth = np.full(num_species, -1, dtype=int)\n    for i in range(num_species):\n        if species_counts[i]  0:\n            species_depth[i] = 0\n\n    reaction_depth = np.full(num_reactions, -1, dtype=int)\n    fired_reactions = set()\n\n    while True:\n        newly_eligible = []\n        for r_id in range(num_reactions):\n            if r_id in fired_reactions:\n                continue\n\n            is_eligible = True\n            max_sub_depth = 0\n            if not reactions[r_id]['subs']:\n                pass\n            else:\n                for s_id, stoich in reactions[r_id]['subs'].items():\n                    if species_counts[s_id]  stoich or species_depth[s_id] == -1:\n                        is_eligible = False\n                        break\n                    max_sub_depth = max(max_sub_depth, species_depth[s_id])\n            \n            if is_eligible:\n                newly_eligible.append((r_id, max_sub_depth))\n        \n        if not newly_eligible:\n            break\n\n        for r_id, max_sub_depth in newly_eligible:\n            fired_reactions.add(r_id)\n            r_depth = 1 + max_sub_depth\n            reaction_depth[r_id] = r_depth\n            \n            for p_id, stoich in reactions[r_id]['prods'].items():\n                species_counts[p_id] += stoich\n                if species_depth[p_id] == -1 or r_depth  species_depth[p_id]:\n                    species_depth[p_id] = r_depth\n\n    # Check reachability of the target\n    target_id = species_to_id.get(target_species)\n    if target_id is None or species_depth[target_id] == -1:\n        return [False, []]\n    \n    if species_depth[target_id] == 0:\n        return [True, []]\n\n    # Phase 2: Backward Propagation\n    required_reactions = set()\n    needed_species = {target_id: 1}\n    \n    # Using a list as a stack for deterministic processing\n    agenda = list(needed_species.items())\n\n    while agenda:\n        s_id, num_needed = agenda.pop(0)\n\n        initial_avail = initial_counts_def.get(id_to_species[s_id], 0)\n        deficit = num_needed - initial_avail\n        \n        if deficit = 0:\n            continue\n            \n        producers = []\n        for r_id in fired_reactions:\n            if s_id in reactions[r_id]['prods']:\n                producers.append(r_id)\n        \n        producers.sort(key=lambda r_id: (reaction_depth[r_id], r_id))\n        \n        covered_deficit = 0\n        for p_rid in producers:\n            if p_rid in required_reactions:\n                # If we've already included this reaction for other needs,\n                # just account for its production without re-adding its substrates\n                amount_made = reactions[p_rid]['prods'][s_id]\n                covered_deficit += amount_made\n                if covered_deficit = deficit: break\n                continue\n\n            required_reactions.add(p_rid)\n            amount_made = reactions[p_rid]['prods'][s_id]\n            covered_deficit += amount_made\n            \n            for sub_id, stoich in reactions[p_rid]['subs'].items():\n                # Naive addition to a dictionary `needed_species` could be non-deterministic.\n                # To handle cumulative needs, let's update a separate dictionary.\n                current_needs_map = dict(agenda)\n                current_needs_map[sub_id] = current_needs_map.get(sub_id, 0) + stoich\n                agenda = list(current_needs_map.items())\n\n            if covered_deficit = deficit:\n                break\n    \n    sorted_reqs = sorted(list(required_reactions), key=lambda r: (reaction_depth[r], r))\n    \n    return [True, sorted_reqs]\n\ndef solve():\n    test_cases = [\n        # 1. Happy path chain\n        ([({'A': 1, 'B': 1}, {'C': 1}), ({'C': 1}, {'D': 1}), ({'D': 1, 'E': 1}, {'TF': 1})],\n         {'A': 1, 'B': 1, 'E': 1}, 'TF'),\n        # 2. Target initially available\n        ([({'A': 1, 'B': 1}, {'C': 1}), ({'C': 1}, {'D': 1}), ({'D': 1, 'E': 1}, {'TF': 1})],\n         {'A': 1, 'B': 1, 'E': 1, 'TF': 1}, 'TF'),\n        # 3. Stoichiometric edge case\n        ([({'Z': 1}, {'X': 1}), ({'X': 2}, {'Y': 1})],\n         {'X': 1, 'Z': 1}, 'Y'),\n        # 4. Unreachable target\n        ([({'U': 1}, {'TF': 1})], \n         {'A': 1}, 'TF'),\n        # 5. Branching prerequisites\n        ([({'A': 1}, {'P': 1}), ({'A': 1}, {'Q': 1}), ({'P': 1, 'Q': 1}, {'TF': 1})],\n         {'A': 1}, 'TF')\n    ]\n\n    results = []\n    for reactions_def, initial_counts_def, target_species in test_cases:\n        result = find_minimal_reactions(reactions_def, initial_counts_def, target_species)\n        results.append(result)\n\n    result_strings = []\n    for r in results:\n        reachable_str = str(r[0])\n        reactions_str = str(r[1]).replace(\" \", \"\")\n        result_strings.append(f'[{reachable_str},{reactions_str}]')\n    \n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "生物过程不仅仅是抽象的网络；它们在物理上位于细胞复杂且区室化的环境中。本练习超越了简单的连通性，将空间约束纳入路径发现中。您将实现 A* 搜索算法，这是优化寻路的基石，用于在一个代谢网络中导航，其中某些反应步骤会因酶的错位而受到惩罚 。这项练习将挑战您设计一个自定义启发式函数，并管理一个扩展的状态空间，以平衡路径长度与生物学可行性。",
            "id": "3317628",
            "problem": "给定一个有向反应图，该图模拟了具有空间区室化的代谢通路的一小部分。每条有向边代表一个反应步骤，具有两个属性：一个基础步长成本和一个二元不匹配指示符，该指示符近似表示催化该反应的酶是否适当地定位于该步骤所隐含的区室中。基础步长成本代表拓扑遍历成本，始终为 $1$。如果不匹配指示符为 $0$，则表示酶的定位是兼容的；否则为 $1$。如果一条路径的累积不匹配计数不超过指定的预算，则该路径被认为是生物学上可行的。\n\n您的任务是实现一个图搜索过程，该过程使用 A* 搜索算法，并采用一种通过软约束对预测的酶错位进行线性惩罚的启发式方法。该算法必须通过剪枝那些不匹配计数超过指定预算的部分路径来强制执行硬可行性约束。该启发式函数必须由在反向图上计算的两个可接受的下界构成：到目标的最短基础步长距离和到达目标所需的最少额外不匹配数。\n\n基本概念和定义：\n- 设该有向图为 $G=(V,E)$，其中 $V$ 是节点的有限集合，$E$ 是有向边的集合。\n- 每条边 $e=(u \\rightarrow v)$ 都有属性：基础步长成本 $c(e) \\in \\{1\\}$ 和不匹配惩罚 $m(e) \\in \\{0,1\\}$。\n- 设 $s \\in V$ 为起始节点，$t \\in V$ 为目标节点。\n- 对于一个在节点 $v$ 结束的部分路径，设 $g(v)$ 表示沿路径的累积基础步长成本 $\\sum c(e)$，设 $M(v)$ 表示沿路径的累积不匹配计数 $\\sum m(e)$。\n- 给定一个硬不匹配预算 $\\tau \\in \\mathbb{N}$。任何 $M(v)  \\tau$ 的部分路径都将被剪枝，不再扩展。\n- 定义基础步长下界启发式 $h_0(v)$ 为在忽略不匹配惩罚时，从 $v$ 到 $t$ 的最短路径长度（以总基础步长计），即，在反向图上使用边权重 $c(e)$ 计算最短路径。\n- 定义不匹配下界 $p(v)$ 为从 $v$ 到达 $t$ 所需的最少额外不匹配数，该值在反向图上使用边权重 $m(e)$ 计算。\n- 软约束启发式为 $h(v) = h_0(v) + \\beta \\cdot p(v)$，其中 $\\beta \\ge 0$ 是一个标量超参数。\n- A* 优先函数为 $f(v) = g(v) + h(v)$。当目标 $t$ 从开放集合中弹出时，搜索成功终止。为了模拟计算资源限制，如果节点状态扩展次数在到达 $t$ 之前超过给定的上限 $L \\in \\mathbb{N}$，算法必须停止并宣告失败。\n\n用于剪枝和优势判定的状态形式化：\n- 由于剪枝取决于累积不匹配数，状态是一个对 $(v,k)$，其中 $v \\in V$ 且 $k = M(v) \\in \\{0,1,\\dots,\\tau\\}$。为每个 $(v,k)$ 维护已知的最佳 $g$ 值，并且只有在为相同的 $k$ 找到严格更低的 $g$ 值时才进行更新。\n\n平局打破规则：\n- 当两个状态的 $f$ 值相等时，首先按较小的 $p(v)$ 值打破平局，然后按先发现的顺序。\n\n图的规格：\n- 节点：$V = \\{ s, b_1, b_2, p_1, p_2, p_3, p_4, u_1, u_2, u_3, v_1, v_2, v_3, t \\}$。\n- 具有属性 $(c,m)$ 的有向边，其中所有 $c=1$ 且 $m \\in \\{0,1\\}$：\n    - $s \\rightarrow b_1$，属性为 $(1,1)$。\n    - $b_1 \\rightarrow b_2$，属性为 $(1,1)$。\n    - $b_2 \\rightarrow t$，属性为 $(1,0)$。\n    - $b_1 \\rightarrow u_1$，属性为 $(1,0)$；$u_1 \\rightarrow v_1$，属性为 $(1,1)$；$v_1 \\rightarrow t$，属性为 $(1,1)$。\n    - $b_1 \\rightarrow u_2$，属性为 $(1,0)$；$u_2 \\rightarrow v_2$，属性为 $(1,1)$；$v_2 \\rightarrow t$，属性为 $(1,1)$。\n    - $b_1 \\rightarrow u_3$，属性为 $(1,0)$；$u_3 \\rightarrow v_3$，属性为 $(1,1)$；$v_3 \\rightarrow t$，属性为 $(1,1)$。\n    - $s \\rightarrow p_1$，属性为 $(1,0)$；$p_1 \\rightarrow p_2$，属性为 $(1,0)$；$p_2 \\rightarrow p_3$，属性为 $(1,0)$；$p_3 \\rightarrow p_4$，属性为 $(1,0)$；$p_4 \\rightarrow t$，属性为 $(1,0)$。\n\n解释：\n- 标记为 $m=1$ 的边表示可能需要未正确定位的酶的步骤；这些步骤会累积不匹配计数。p-链 ($s \\rightarrow p_1 \\rightarrow p_2 \\rightarrow p_3 \\rightarrow p_4 \\rightarrow t$) 是完全一致的（$m=0$），但在基础步长上更长。b-通道 ($s \\rightarrow b_1 \\rightarrow b_2 \\rightarrow t$) 在基础步长上更短，但包含不匹配。u-分支 ($u_i \\rightarrow v_i \\rightarrow t$) 在基础步长启发式下很有吸引力，但会产生额外的不匹配，使它们在严格的 $\\tau$ 下不可行。\n\n您的程序必须：\n- 通过在反向图上使用边权重 $c(e)$ 从 $t$ 开始求解单源最短路径，为所有 $v \\in V$ 预计算 $h_0(v)$。\n- 通过在反向图上使用边权重 $m(e)$ 从 $t$ 开始求解单源最短路径，为所有 $v \\in V$ 预计算 $p(v)$。\n- 在状态空间 $(v,k)$ 上实现A* 搜索算法，优先级为 $f = g + h_0(v) + \\beta \\cdot p(v)$，对任何 $k'  \\tau$ 的后继状态进行硬剪枝，如果弹出操作次数超过 $L$ 则停止并失败。\n- 成功时，报告弹出的目标状态的基础步长 $g(t)$ 和不匹配计数 $k$。\n\n测试套件：\n在以下参数三元组 $(\\beta,\\tau,L)$ 上运行您的求解器：\n- 情况1：$\\beta = 0.0$, $\\tau = 1$, $L = 8$。\n- 情况2：$\\beta = 1.0$, $\\tau = 1$, $L = 8$。\n- 情况3：$\\beta = 0.5$, $\\tau = 1$, $L = 8$。\n- 情况4：$\\beta = 0.0$, $\\tau = 0$, $L = 6$。\n- 情况5：$\\beta = 10.0$, $\\tau = 1$, $L = 6$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个结果列表，每个测试用例一个结果，顺序与上面相同。每个结果必须是包含四个基本值的列表：\n- 一个布尔值，指示是否在扩展限制内找到了到 $t$ 的可行路径。\n- 如果找到，则为基础步长成本 $g(t)$ 的整数；否则为 $-1$。\n- 如果找到，则为总不匹配数 $k$ 的整数；否则为 $-1$。\n- 执行的节点状态扩展（弹出）次数的整数。\n\n例如，输出应看起来像这样单行：\n[[found1,g1,k1,exp1],[found2,g2,k2,exp2],...]",
            "solution": "问题陈述经评估有效。它具有科学依据，提出了一个基于图的代谢网络标准抽象，这是计算系统生物学中的常见做法。该问题定义明确，提供了对图、算法（A*）、状态表示、约束和终止条件的完整且逻辑一致的说明。所有术语都得到了正式和客观的定义。该任务需要实现一个专门的搜索算法，这是一个非平凡且可验证的计算问题。\n\n解决方案分为两个主要阶段：启发式函数预计算和主A*搜索。\n\n**1. 启发式函数预计算**\n\nA*算法的效率和行为由启发式函数 $h(v)$ 决定。指定的启发式函数是一个复合函数：$h(v) = h_0(v) + \\beta \\cdot p(v)$。其两个组成部分，$h_0(v)$ 和 $p(v)$，必须为所有节点 $v \\in V$ 预先计算。\n\n- 基础步长下界 $h_0(v)$ 定义为从节点 $v$ 到目标节点 $t$ 的最短路径长度，仅考虑基础步长成本 $c(e)$。\n- 不匹配下界 $p(v)$ 是从 $v$ 到 $t$ 的任何路径上可能的最小累积不匹配计数。\n\n这两个组成部分都是图 $G$ 上的最短路径问题。一个标准且高效的方法是，在*反向图* $G^R$ 上从目标节点 $t$ 开始求解单源最短路径（SSSP）问题，从而同时计算所有节点 $v$ 的这些值。反向图 $G^R$ 是通过反转 $G$ 中每条边的方向形成的。由于所有边权重（$c(e)=1$ 和 $m(e) \\in \\{0,1\\}$）都是非负的，Dijkstra算法是解决SSSP问题的正确且高效的选择。\n\n预计算过程如下：\n1. 构建反向图 $G^R = (V, E^R)$，其中当且仅当 $(u \\rightarrow v) \\in E$ 时，边 $(v \\rightarrow u) \\in E^R$ 存在。权重被继承。\n2. 为了计算所有 $h_0(v)$ 值，在 $G^R$ 上从节点 $t$ 开始执行Dijkstra算法，使用基础步长成本 $c(e)$ 作为边权重。在 $G^R$ 中从 $t$ 到任何节点 $v$ 的所得最短距离，精确地等于原始图 $G$ 中从 $v$ 到 $t$ 的最短距离，即 $h_0(v)$。\n3. 类似地，为了计算所有 $p(v)$ 值，再次在 $G^R$ 上从节点 $t$ 开始执行Dijkstra算法，这次使用不匹配惩罚 $m(e)$ 作为边权重。所得的最短距离即为 $p(v)$。\n\n**2. 带状态空间增强的A*搜索算法**\n\n问题的核心是一个改进的A*搜索。硬不匹配预算 $\\tau$ 的存在使得增强的状态表示成为必需。一条路径不仅由其到达的节点定义，还由其消耗的资源——在这里是累积的不匹配计数——来定义。\n\n- **状态表示**：我们搜索中的状态是一个对 $(v, k)$，其中 $v \\in V$ 是当前节点，$k \\in \\{0, 1, \\dots, \\tau\\}$ 是从起始节点 $s$ 到 $v$ 的路径上的累积不匹配计数。\n- **成本函数**：到达状态 $(v,k)$ 的成本是累积的基础步长成本，表示为 $g(v,k)$。\n- **优先函数**：开放集合（优先队列）中状态 $(v,k)$ 的优先级由A*函数 $f(v,k) = g(v,k) + h(v)$ 给出，其中 $h(v) = h_0(v) + \\beta \\cdot p(v)$。\n- **开放集合**：使用一个优先队列来存储待探索的状态。为了严格遵守平局打破规则，队列中的每个条目将是一个元组：$(f, p(v), \\text{discovery\\_time}, (v, k))$。队列首先按优先级值 $f$ 排序，然后按不匹配启发式 $p(v)$ 排序，最后通过一个单调递增的发现计数器来确保对具有相同 $f$ 和 $p(v)$ 的状态采用先入先出的顺序。\n- **已访问状态和优势判定**：需要一个数据结构（如哈希表或二维数组）来存储迄今为止为每个状态 $(v,k)$ 找到的最小成本 $g(v,k)$。当找到一条到达状态 $(v',k')$ 且成本为 $g'$ 的路径时，只有当 $g'$ 严格小于先前记录的 $(v',k')$ 的最佳成本时，才继续探索该路径。这可以防止循环和冗余计算。\n- **算法执行**：\n    1. 初始化一个空的优先队列（开放集合）和一个字典 `dist` 来存储已访问状态的最佳 $g(v,k)$。\n    2. 将初始状态添加到队列中：`(f(s,0), p(s), 0, (s,0))`，其中 $f(s,0) = 0 + h(s)$。设置 `dist[(s,0)] = 0`。将扩展计数器初始化为 $0$，发现计数器初始化为 $1$。\n    3. 循环直到优先队列为空或扩展计数器超过限制 $L$：\n        a. 从队列中弹出具有最高优先级的状态（最低 $f$ 值）。设其为 $(v,k)$，成本为 $g(v,k)$。\n        b. 递增扩展计数器。如果计数器此时超过 $L$，则以失败告终。\n        c. 如果 $v$ 是目标节点 $t$，则搜索成功。返回路径属性：找到状态、 $g(t,k)$、 $k$ 和总扩展次数。\n        d. 对于节点 $v$ 的每个由边 $e=(v \\rightarrow v')$ 连接的邻居 $v'$：\n            i. 计算后继状态的成本和不匹配数：$g' = g(v,k) + c(e)$ 和 $k' = k + m(e)$。\n            ii. **硬约束剪枝**：如果 $k'  \\tau$，此路径不可行。丢弃此后继状态并继续。\n            iii. **优势判定检查**：如果之前已找到到达状态 $(v',k')$ 的路径，其成本小于或等于 $g'$（即 `dist.get((v',k'), infinity) = g'`），则此新路径不是一个改进。丢弃它并继续。\n            iv. **更新并入队**：如果新路径更好，则更新 `dist[(v',k')] = g'`。计算优先级 $f' = g' + h(v')$。将新条目 $(f', p(v'), \\text{discovery\\_time}, (v',k'))$ 推入优先队列。递增发现计数器。\n    4. 如果循环结束而未到达目标，则搜索失败。返回失败状态和相应的值。\n\n此过程系统地探索状态空间，由复合启发式函数引导，同时严格执行不匹配预算和扩展限制，确保每个测试用例都有一个正确和确定的结果。",
            "answer": "```python\nimport heapq\nimport numpy as np\n# The problem statement requires scipy to be available, but it is not used in this implementation.\n# from scipy import sparse\n\ndef solve():\n    \"\"\"\n    Main function to define the graph, run test cases, and print the results.\n    \"\"\"\n    nodes = {'s', 'b1', 'b2', 'p1', 'p2', 'p3', 'p4', 'u1', 'u2', 'u3', 'v1', 'v2', 'v3', 't'}\n    edges = [\n        ('s', 'b1', 1, 1),\n        ('b1', 'b2', 1, 1),\n        ('b2', 't', 1, 0),\n        ('b1', 'u1', 1, 0), ('u1', 'v1', 1, 1), ('v1', 't', 1, 1),\n        ('b1', 'u2', 1, 0), ('u2', 'v2', 1, 1), ('v2', 't', 1, 1),\n        ('b1', 'u3', 1, 0), ('u3', 'v3', 1, 1), ('v3', 't', 1, 1),\n        ('s', 'p1', 1, 0), ('p1', 'p2', 1, 0), ('p2', 'p3', 1, 0),\n        ('p3', 'p4', 1, 0), ('p4', 't', 1, 0),\n    ]\n\n    graph = {node: [] for node in nodes}\n    reverse_graph = {node: [] for node in nodes}\n    for u, v, c, m in edges:\n        graph[u].append((v, c, m))\n        reverse_graph[v].append((u, c, m))\n\n    def dijkstra(g, start_node, weight_key_idx):\n        \"\"\"\n        Dijkstra's algorithm for Single-Source Shortest Path.\n        `weight_key_idx` is 1 for base cost 'c', 2 for mismatch 'm'.\n        \"\"\"\n        distances = {node: np.inf for node in g}\n        distances[start_node] = 0\n        pq = [(0, start_node)]\n\n        while pq:\n            dist, current_node = heapq.heappop(pq)\n            if dist  distances[current_node]:\n                continue\n            for neighbor, *weights in g[current_node]:\n                weight = weights[weight_key_idx]\n                new_dist = dist + weight\n                if new_dist  distances[neighbor]:\n                    distances[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, neighbor))\n        return distances\n\n    h0 = dijkstra(reverse_graph, 't', 0)  # Heuristic from base step cost c\n    p = dijkstra(reverse_graph, 't', 1)   # Heuristic from mismatch m\n\n    def astar_search(beta, tau, L):\n        \"\"\"\n        Implements the specified A-star search algorithm.\n        \"\"\"\n        start_node, goal_node = 's', 't'\n        initial_k = 0\n\n        # Priority queue stores: (f_cost, p_heuristic, discovery_time, (node, k))\n        # This handles the tie-breaking rule: f, then p(v), then discovery order.\n        pq = []\n        discovery_time = 0\n        expansions = 0\n        \n        # dist stores the minimum g_cost found for each state (node, k)\n        dist = {}\n\n        initial_g = 0\n        initial_h = h0[start_node] + beta * p[start_node]\n        initial_f = initial_g + initial_h\n        \n        initial_state = (start_node, initial_k)\n        heapq.heappush(pq, (initial_f, p[start_node], discovery_time, initial_state))\n        discovery_time += 1\n        dist[initial_state] = initial_g\n        \n        while pq:\n            if expansions = L:\n                return [False, -1, -1, expansions]\n\n            f_cost, _, _, current_state = heapq.heappop(pq)\n            current_node, current_k = current_state\n            \n            expansions += 1\n            \n            current_g = dist[current_state]\n\n            if current_node == goal_node:\n                return [True, int(current_g), int(current_k), expansions]\n\n            for neighbor, c, m in graph[current_node]:\n                next_g = current_g + c\n                next_k = current_k + m\n\n                if next_k  tau:\n                    continue\n\n                next_state = (neighbor, next_k)\n                if next_g  dist.get(next_state, np.inf):\n                    dist[next_state] = next_g\n                    h_next = h0[neighbor] + beta * p[neighbor]\n                    f_next = next_g + h_next\n                    heapq.heappush(pq, (f_next, p[neighbor], discovery_time, next_state))\n                    discovery_time += 1\n        \n        return [False, -1, -1, expansions]\n\n    test_cases = [\n        (0.0, 1, 8),   # Case 1\n        (1.0, 1, 8),   # Case 2\n        (0.5, 1, 8),   # Case 3\n        (0.0, 0, 6),   # Case 4\n        (10.0, 1, 6),  # Case 5\n    ]\n\n    results = []\n    for beta, tau, L in test_cases:\n        result = astar_search(beta, tau, L)\n        results.append(result)\n\n    # Format the final output exactly as specified.\n    output_str = \"[\" + \",\".join(map(str, results)) + \"]\"\n    print(output_str.replace(\" \", \"\"))\n\nsolve()\n\n```"
        },
        {
            "introduction": "A* 搜索的性能关键取决于其启发式函数 $h(v)$ 的质量。虽然经典的启发式函数通常基于简化的图距离，但现代机器学习提供了一个强大的替代方案：通过图嵌入来学习网络结构。这个高级练习  搭建了机器学习与经典搜索算法之间的桥梁，要求您分析一个源自学习到的潜在空间中欧几里得距离的启发式函数。您将诊断并以算法方式修复其对可采纳性（admissibility）和一致性（consistency）的违反——这两个理论属性对于保证 A* 算法的最优性和效率至关重要。",
            "id": "3317688",
            "problem": "给定加权图，这些图模拟了计算系统生物学中常见的相互作用或反应连通性，其中节点代表生物实体，边代表具有非负成本的可能转换。考虑从连续图嵌入中为 A* 搜索算法设计启发式函数，并分析其可采纳性和一致性的问题。请完全在图和向量的数学框架下进行研究。假设所有边的权重都是非负的，并且所有节点都可以到达指定的目标。\n\n基本定义如下：\n- 一个带有非负边权重的有限有向或无向图是一个对 $(V,E)$，其权重函数为 $w : E \\to \\mathbb{R}_{\\ge 0}$。最短路径距离 $d_G(u,v)$ 是从 $u$ 到 $v$ 的所有路径中的最小总权重。如果没有路径，则定义 $d_G(u,v) = +\\infty$，但在本问题中，对于指定的目标 $t$ 和所有 $u \\in V$，所有测试用例都满足 $d_G(u,t)  +\\infty$。\n- A* 搜索使用一个评估函数 $f(x) = g(x) + h(x)$，其中 $g(x)$ 是从起点到 $x$ 的已知最佳成本，而 $h(x)$ 是到指定目标 $t$ 的剩余成本的启发式估计。\n- 如果对于所有节点 $v$，$h(v) \\le d_G(v,t)$，则启发式函数 $h$ 是可采纳的。如果对于每条边 $(u,v) \\in E$，$h(u) \\le w(u,v) + h(v)$，并且 $h(t) = 0$，则启发式函数 $h$ 是一致的（也称为单调的）。\n\n基于嵌入的启发式方法：\n- 每个节点 $v \\in V$ 都有一个由图嵌入方法（例如 node2vec）生成的向量嵌入 $z(v) \\in \\mathbb{R}^d$。定义原始嵌入启发式 $h_{\\text{raw}}(v)$ 为 $z(v)$ 和目标 $t$ 的 $z(t)$ 在潜在空间中的欧几里得距离。请使用标准的欧几里得范数。\n\n你的任务：\n1. 对于每个测试用例图和指定的目标 $t$，根据嵌入构建原始启发式 $h_{\\text{raw}}(v)$ 并计算：\n   - 可采纳性违例的数量，定义为满足 $h_{\\text{raw}}(v)  d_G(v,t)$ 的节点 $v$ 的数量。\n   - 一致性违例的数量，定义为满足 $h_{\\text{raw}}(u)  w(u,v) + h_{\\text{raw}}(v)$ 的边 $(u,v)$ 的数量，并约定 $h_{\\text{raw}}(t) = 0$。\n2. 设计并实现一种保持可采纳性的原始启发式重缩放方法，方法是选择最大的全局标量 $\\alpha \\in \\mathbb{R}_{\\ge 0}$，使得对于所有嵌入距离严格为正的节点 $v$，缩放后的启发式 $h_{\\text{scaled}}(v) = \\alpha \\cdot h_{\\text{raw}}(v)$ 满足 $h_{\\text{scaled}}(v) \\le d_G(v,t)$。对于与目标的嵌入距离为零的节点，将其缩放后的启发式值设为零。按照任务1中的方式计算 $h_{\\text{scaled}}$ 的可采纳性和一致性违例数量。\n3. 设计并实现一个修复过程，该过程在保持可采纳性的同时强制执行一致性。从一个可采纳的启发式（例如 $h_{\\text{scaled}}$）开始，沿边迭代应用基于边的三角不等式闭包，并固定 $h(t) = 0$，直到没有违例为止。最后得到一个既一致又仍然可采纳的启发式 $h_{\\text{repaired}}$。按照任务1中的方式计算 $h_{\\text{repaired}}$ 的可采纳性和一致性违例数量。\n\n测试套件：\n提供一个程序，为以下测试用例计算上述值。所有图都由带整数标签的节点集、带权重的边以及一个目标节点索引 $t$ 给出。所有嵌入坐标都以实数形式给出。对于无向图，每条权重为 $w$ 的无向边 $\\{u,v\\}$ 等价于两条权重均为 $w$ 的有向边 $(u,v)$ 和 $(v,u)$。\n\n- 测试用例 A（无向，加权）：\n  - 节点：$V = \\{0,1,2,3,4,5\\}$，目标 $t = 5$。\n  - 带权重的边（无向）：$(0,1,2)$, $(1,2,2)$, $(2,5,3)$, $(0,3,5)$, $(3,4,1)$, $(4,5,1)$, $(1,4,4)$。\n  - $\\mathbb{R}^2$ 中的嵌入：$z(0) = (5.0,0.0)$, $z(1) = (8.0,0.0)$, $z(2) = (0.5,0.2)$, $z(3) = (4.6,0.1)$, $z(4) = (0.9,0.1)$, $z(5) = (0.0,0.0)$。\n\n- 测试用例 B（有向，加权）：\n  - 节点：$V = \\{0,1,2,3,4\\}$，目标 $t = 4$。\n  - 带权重的有向边：$(0,1,1)$, $(1,2,1)$, $(2,4,5)$, $(0,3,2)$, $(3,4,2)$, $(1,4,10)$。\n  - $\\mathbb{R}^2$ 中的嵌入：$z(0) = (1.9,0.0)$, $z(1) = (9.0,0.0)$, $z(2) = (10.0,0.0)$, $z(3) = (1.9,0.1)$, $z(4) = (0.0,0.0)$。\n\n- 测试用例 C（无向，路径图）：\n  - 节点：$V = \\{0,1,2,3\\}$，目标 $t = 3$。\n  - 带权重的无向边：$(0,1,1)$, $(1,2,1)$, $(2,3,1)$。\n  - $\\mathbb{R}^2$ 中的嵌入：$z(0) = (10.0,0.0)$, $z(1) = (6.0,0.0)$, $z(2) = (3.2,0.0)$, $z(3) = (0.0,0.0)$。\n\n- 测试用例 D（无向，零距离边情况）：\n  - 节点：$V = \\{0,1,2,3\\}$，目标 $t = 3$。\n  - 带权重的无向边：$(0,3,5)$, $(0,1,2)$, $(1,3,2)$, $(2,3,1)$, $(1,2,3)$。\n  - $\\mathbb{R}^2$ 中的嵌入：$z(0) = (5.0,0.0)$, $z(1) = (0.0,0.0)$, $z(2) = (0.0,0.0)$, $z(3) = (0.0,0.0)$。\n\n要求的最终输出格式：\n- 对于每个测试用例，输出一个包含六个整数的列表 $[v_1,v_2,v_3,v_4,v_5,v_6]$，其中：\n  - $v_1$ 是 $h_{\\text{raw}}$ 的可采纳性违例数量，\n  - $v_2$ 是 $h_{\\text{raw}}$ 的一致性违例数量，\n  - $v_3$ 是 $h_{\\text{scaled}}$ 的可采纳性违例数量，\n  - $v_4$ 是 $h_{\\text{scaled}}$ 的一致性违例数量，\n  - $v_5$ 是 $h_{\\text{repaired}}$ 的可采纳性违例数量，\n  - $v_6$ 是 $h_{\\text{repaired}}$ 的一致性违例数量。\n- 你的程序应生成单行输出，其中包含所有测试用例的结果，形式为一个用方括号括起来的逗号分隔列表，每个元素是对应一个测试用例的六整数列表，顺序为 A, B, C, D。例如：$[[a_1,a_2,a_3,a_4,a_5,a_6],[b_1,b_2,b_3,b_4,b_5,b_6],[c_1,c_2,c_3,c_4,c_5,c_6],[d_1,d_2,d_3,d_4,d_5,d_6]]$。",
            "solution": "用户提供了一个关于为 A* 搜索算法设计和分析启发式函数的问题，这是人工智能和计算科学中的一个基本课题，其问题背景源于系统生物学。该问题定义明確，数学上合理，并提出了一系列清晰的计算任务。我将继续提供完整的解决方案。\n\n### 步骤1：问题验证\n\n**1. 提取已知信息：**\n- **图**：带权重的有向或无向图 $(V,E)$，权重函数为 $w : E \\to \\mathbb{R}_{\\ge 0}$。\n- **最短路径距离**：$d_G(u,v)$ 是从 $u$ 到 $v$ 的路径的最小总权重。给定条件是对于任何节点 $u$，都存在到目标节点 $t$ 的路径，因此 $d_G(u,t)  +\\infty$。\n- **A* 评估函数**：$f(x) = g(x) + h(x)$。\n- **可采纳性**：如果对于所有 $v \\in V$，$h(v) \\le d_G(v,t)$，则启发式函数 $h$ 是可采纳的。\n- **一致性（单调性）**：如果对于每条边 $(u,v) \\in E$，$h(u) \\le w(u,v) + h(v)$，并且 $h(t) = 0$，则启发式函数 $h$ 是一致的。\n- **节点嵌入**：每个节点 $v$ 都有一个向量嵌入 $z(v) \\in \\mathbb{R}^d$。\n- **原始启发式**：$h_{\\text{raw}}(v)$ 是欧几里得距离 $\\|z(v) - z(t)\\|_2$。\n- **任务1**：计算 $h_{\\text{raw}}$ 的可采纳性和一致性违例数量。\n- **任务2**：设计一种保持可采纳性的缩放启发式 $h_{\\text{scaled}}(v) = \\alpha \\cdot h_{\\text{raw}}(v)$，通过找到确保所有节点都满足可采纳性的最大 $\\alpha \\ge 0$ 来实现。计算 $h_{\\text{scaled}}$ 的违例数量。\n- **任务3**：设计一个修复过程，从一个可采纳的启发式开始，强制执行一致性，从而创建 $h_{\\text{repaired}}$，使其既可采纳又一致。计算 $h_{\\text{repaired}}$ 的违例数量。\n- **测试用例**：提供了四个具体的测试用例（A, B, C, D），包括图结构、边权重、节点嵌入和目标节点。\n- **输出格式**：一个列表的列表，其中每个内部列表包含六个整数违例计数：$[v_1, v_2, v_3, v_4, v_5, v_6]$，分别对应（adm-raw, con-raw, adm-scaled, con-scaled, adm-repaired, con-repaired）。\n\n**2. 使用提取的已知信息进行验证：**\n- **科学基础**：该问题基于图论和计算机科学中已建立的基本概念（A* 搜索、启发式函数、最短路径算法）。没有科学上的不合理之处。\n- **良构性**：任务是有具体目标的明确算法。给定输入，可以唯一确定所需的输出。所有节点都能到达目标的条件确保了所有最短路径距离 $d_G(v,t)$ 都是有限的。\n- **客观性**：语言精确且数学化。定义是标准的。\n- **完整性**：为测试用例提供了所有必要的数据（图、权重、嵌入、目标）。定义是自包含的。\n- **其他标准**：该问题不是隐喻性的、琐碎的或无法验证的。它是一个标准的算法问题。\n\n**3. 结论与行动：**\n问题是 **有效的**。我将着手制定一个完整的解决方案。\n\n### 步骤2：解决方案设计\n\n该解决方案将构建为针对每个测试用例的一系列计算。\n\n**第0部分：最短路径距离的预计算**\n评估启发式方法的基准是到目标的真实最短路径距离 $d_G(v,t)$。由于所有边权重都是非负的，Dijkstra 算法是合适的方法。为了计算从所有节点 *到* 单个目标节点 $t$ 的最短距离，我们可以在所有边都反向的图上，从 $t$ 开始运行 Dijkstra 算法。对于无向图，反向图与原图相同。我们将这些距离的向量表示为 $\\mathbf{d}_t$。\n\n**第1部分：原始启发式 ($h_{\\text{raw}}$) 的分析**\n1.  **计算 $h_{\\text{raw}}$**：对于每个节点 $v \\in V$，原始启发式计算为其嵌入与目标节点嵌入之差的欧几里得范数：\n    $$h_{\\text{raw}}(v) = \\|z(v) - z(t)\\|_2$$\n2.  **计算可采纳性违例**：如果 $h_{\\text{raw}}(v)  d_G(v,t)$，则节点 $v$ 存在可采纳性违例。我们计算满足此不等式的节点数量。\n    $$v_1 = |\\{v \\in V \\mid h_{\\text{raw}}(v)  d_G(v,t)\\}|$$\n3.  **计算一致性违例**：如果 $h_{\\text{raw}}(u)  w(u,v) + h_{\\text{raw}}(v)$，则有向边 $(u,v) \\in E$ 存在一致性违例。我们计算满足此不等式的边的数量。注意，对于无向边，我们必须为两个对应的有向边都检查该条件。问题声明了约定 $h(t)=0$，这通过 $h_{\\text{raw}}$ 的定义自然得到满足。\n    $$v_2 = |\\{(u,v) \\in E \\mid h_{\\text{raw}}(u)  w(u,v) + h_{\\text{raw}}(v)\\}|$$\n\n**第2部分：缩放后启发式 ($h_{\\text{scaled}}$) 的分析**\n1.  **计算缩放因子 $\\alpha$**：我们需要找到最大的非负标量 $\\alpha$，使得缩放后的启发式 $h_{\\text{scaled}}(v) = \\alpha \\cdot h_{\\text{raw}}(v)$ 是可采納的。可采纳性条件为对所有 $v \\in V$ 都有 $\\alpha \\cdot h_{\\text{raw}}(v) \\le d_G(v,t)$。对于 $h_{\\text{raw}}(v)  0$ 的节点，这意味着 $\\alpha \\le \\frac{d_G(v,t)}{h_{\\text{raw}}(v)}$。为了对所有这样的节点都满足这个条件，$\\alpha$ 必须是这些比率中的最小值。\n    $$\\alpha = \\min_{v \\in V, h_{\\text{raw}}(v)  0} \\left\\{ \\frac{d_G(v,t)}{h_{\\text{raw}}(v)} \\right\\}$$\n    如果集合 $\\{v \\in V \\mid h_{\\text{raw}}(v)  0\\}$ 为空，则所有非目标节点的嵌入都与目标相同。在这种情况下，$h_{\\textraw}$ 恒为零，并且已经是可采纳和一致的。关于 $\\alpha$ 的条件对于任何 $\\alpha \\ge 0$ 都空泛地成立。在这种空泛情况下，一个实际的约定是设 $\\alpha = 1.0$。\n2.  **计算 $h_{\\text{scaled}}$**：使用计算出的 $\\alpha$，我们为所有节点找到缩放后的启发式：\n    $$h_{\\text{scaled}}(v) = \\alpha \\cdot h_{\\text{raw}}(v)$$\n3.  **计算可采纳性违例**：根据构造，$h_{\\text{scaled}}$ 是可采纳的。因此，可采纳性违例的数量为零。\n    $$v_3 = 0$$\n4.  **计算一致性违例**：我们为所有边检查一致性条件，与 $h_{\\text{raw}}$ 的做法相同。\n    $$v_4 = |\\{(u,v) \\in E \\mid h_{\\text{scaled}}(u)  w(u,v) + h_{\\text{scaled}}(v)\\}|$$\n\n**第3部分：修复后启发式 ($h_{\\text{repaired}}$) 的分析**\n1.  **计算 $h_{\\text{repaired}}$**：我们从可采纳的启发式 $h_{\\text{repaired}}^{(0)}(v) = h_{\\text{scaled}}(v)$ 开始。修复过程迭代地强制执行一致性约束，直到没有违例为止。这是一个类似于 Bellman-Ford 算法的松弛过程。我们反复迭代所有边并更新启发式值。最终的启发式必须满足 $h_{\\text{repaired}}(t)=0$。过程如下：\n    a. 初始化 $h(v) \\leftarrow h_{\\text{scaled}}(v)$ 对所有 $v \\in V$。\n    b. 设置标志 `changed = true`。\n    c. 当 `changed` 为 true 时：\n        i. 设置 `changed = false`。\n        ii. 对于每条边 $(u,v) \\in E$：\n            - 如果 $h(u)  w(u,v) + h(v)$：\n                - 更新 $h(u) \\leftarrow w(u,v) + h(v)$。\n                - 设置 `changed = true`。\n    该过程保证会终止，因为启发式值是非递增的，并且有下界0。最终的启发式 $h_{\\text{repaired}}$ 是此过程的结果。\n2.  **计算可采納性违例**：修复过程只会减小启发式值。由于我们从一个可采納的启发式开始（$h_{\\text{scaled}}(v) \\le d_G(v,t)$），最终的启发式也将是可采納的（$h_{\\text{repaired}}(v) \\le h_{\\text{scaled}}(v) \\le d_G(v,t)$）。违例的数量为零。\n    $$v_5 = 0$$\n3.  **计算一致性违例**：根据构造，算法在没有一致性违例时终止。违例的数量为零。\n    $$v_6 = 0$$\n\n这个完整的程序将使用 Python 实现，其中 `numpy` 用于向量计算，`scipy.sparse.csgraph.dijkstra` 用于计算最短路径。",
            "answer": "```python\nimport numpy as np\nfrom scipy.sparse import csr_matrix\nfrom scipy.sparse.csgraph import dijkstra\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to process all test cases and print the final results.\n    \"\"\"\n    test_cases = [\n        {\n            \"name\": \"A\",\n            \"nodes\": 6,\n            \"goal\": 5,\n            \"directed\": False,\n            \"edges\": [(0, 1, 2), (1, 2, 2), (2, 5, 3), (0, 3, 5), (3, 4, 1), (4, 5, 1), (1, 4, 4)],\n            \"embeddings\": {0: (5.0, 0.0), 1: (8.0, 0.0), 2: (0.5, 0.2), 3: (4.6, 0.1), 4: (0.9, 0.1), 5: (0.0, 0.0)},\n        },\n        {\n            \"name\": \"B\",\n            \"nodes\": 5,\n            \"goal\": 4,\n            \"directed\": True,\n            \"edges\": [(0, 1, 1), (1, 2, 1), (2, 4, 5), (0, 3, 2), (3, 4, 2), (1, 4, 10)],\n            \"embeddings\": {0: (1.9, 0.0), 1: (9.0, 0.0), 2: (10.0, 0.0), 3: (1.9, 0.1), 4: (0.0, 0.0)},\n        },\n        {\n            \"name\": \"C\",\n            \"nodes\": 4,\n            \"goal\": 3,\n            \"directed\": False,\n            \"edges\": [(0, 1, 1), (1, 2, 1), (2, 3, 1)],\n            \"embeddings\": {0: (10.0, 0.0), 1: (6.0, 0.0), 2: (3.2, 0.0), 3: (0.0, 0.0)},\n        },\n        {\n            \"name\": \"D\",\n            \"nodes\": 4,\n            \"goal\": 3,\n            \"directed\": False,\n            \"edges\": [(0, 3, 5), (0, 1, 2), (1, 3, 2), (2, 3, 1), (1, 2, 3)],\n            \"embeddings\": {0: (5.0, 0.0), 1: (0.0, 0.0), 2: (0.0, 0.0), 3: (0.0, 0.0)},\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        results.append(process_case(case))\n\n    # Format the final output string\n    output_str = f\"[\" + \",\".join([str(r) for r in results]) + \"]\"\n    output_str = output_str.replace(\" \", \"\") # Remove spaces for compact representation\n    print(output_str)\n\ndef process_case(case):\n    \"\"\"\n    Processes a single test case and returns the 6 violation counts.\n    \"\"\"\n    num_nodes = case[\"nodes\"]\n    goal_node = case[\"goal\"]\n    is_directed = case[\"directed\"]\n    \n    # Store all directed edges for consistency checking\n    all_edges = []\n    \n    # Build graph for Dijkstra\n    row, col, data = [], [], []\n    for u, v, w in case[\"edges\"]:\n        row.append(u)\n        col.append(v)\n        data.append(w)\n        all_edges.append((u, v, w))\n        if not is_directed:\n            row.append(v)\n            col.append(u)\n            data.append(w)\n            all_edges.append((v, u, w))\n    \n    graph_matrix = csr_matrix((data, (row, col)), shape=(num_nodes, num_nodes))\n\n    # --- Part 0: Calculate shortest path distances to goal ---\n    # To get distances TO goal t, run Dijkstra from t on the transposed graph.\n    graph_transposed = graph_matrix.transpose() if is_directed else graph_matrix\n    d_G = dijkstra(csgraph=graph_transposed, directed=True, indices=goal_node)\n\n    # --- Part 1: Raw Heuristic ---\n    z_goal = np.array(case[\"embeddings\"][goal_node])\n    h_raw = np.array([np.linalg.norm(np.array(case[\"embeddings\"][v]) - z_goal) for v in range(num_nodes)])\n    \n    # Admissibility violations for h_raw\n    adm_violations_raw = np.sum(h_raw  d_G)\n    \n    # Consistency violations for h_raw\n    con_violations_raw = 0\n    for u, v, w in all_edges:\n        if h_raw[u]  w + h_raw[v]:\n            con_violations_raw += 1\n            \n    # --- Part 2: Scaled Heuristic ---\n    h_scaled = np.zeros(num_nodes)\n    \n    # Nodes where raw heuristic is positive\n    positive_h_raw_indices = np.where(h_raw  1e-9)[0]\n    \n    if len(positive_h_raw_indices)  0:\n        ratios = d_G[positive_h_raw_indices] / h_raw[positive_h_raw_indices]\n        alpha = np.min(ratios)\n        h_scaled = alpha * h_raw\n    else:\n        # If all h_raw are 0, heuristic is already admissible/consistent. Alpha can be 1.\n        alpha = 1.0 # Or 0.0, either gives h_scaled = 0.\n        h_scaled = h_raw.copy()\n\n    # Admissibility violations for h_scaled (should be 0 by construction)\n    adm_violations_scaled = np.sum(h_scaled  d_G + 1e-9) # Use tolerance for float comparison\n    \n    # Consistency violations for h_scaled\n    con_violations_scaled = 0\n    for u, v, w in all_edges:\n        if h_scaled[u]  w + h_scaled[v] + 1e-9: # Use tolerance\n            con_violations_scaled += 1\n            \n    # --- Part 3: Repaired Heuristic ---\n    h_repaired = h_scaled.copy()\n    \n    # Iteratively enforce consistency until convergence\n    changed = True\n    while changed:\n        changed = False\n        for u, v, w in all_edges:\n            # The heuristic at the goal is fixed at 0.\n            # Do not update h(t) even if there are outgoing edges from t.\n            # The consistency check h(t) = w(t,v)+h(v) becomes 0 = w+h(v) which always holds.\n            if h_repaired[u]  w + h_repaired[v] + 1e-9:\n                h_repaired[u] = w + h_repaired[v]\n                changed = True\n                \n    # Admissibility violations for h_repaired (should be 0)\n    adm_violations_repaired = np.sum(h_repaired  d_G + 1e-9)\n    \n    # Consistency violations for h_repaired (should be 0)\n    con_violations_repaired = 0\n    for u, v, w in all_edges:\n        if h_repaired[u]  w + h_repaired[v] + 1e-9:\n            con_violations_repaired += 1\n            \n    return [\n        int(adm_violations_raw), int(con_violations_raw),\n        int(adm_violations_scaled), int(con_violations_scaled),\n        int(adm_violations_repaired), int(con_violations_repaired)\n    ]\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}