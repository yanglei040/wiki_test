{
    "hands_on_practices": [
        {
            "introduction": "随机图模型，如 Erdős–Rényi 模型，是理解网络结构的基本出发点，尤其是在我们对一个生物系统的所有相互作用尚不完全了解时。这项练习将通过从基本概率假设出发，推导一个关键属性——度分布，来建立你的直觉。通过这种方式，你将理解局部属性（如一个节点被孤立的概率）是如何从全局生成规则中涌现的 。",
            "id": "3317480",
            "problem": "在固定实验条件下，一个蛋白质-蛋白质相互作用（PPI）网络被建模为一个 Erdős–Rényi（ER）图，记为 $G(n,p)$，其中 $n$ 是蛋白质（节点）的数量，$p$ 是任意一对蛋白质相互作用（形成一条无向边）的概率。假设以下基本前提：\n- 在 $G(n,p)$ 中，$\\binom{n}{2}$ 条可能的无向边中的每一条都以概率 $p$ 独立存在。\n- 不同边的存在与否是独立的伯努利试验，且所有节点对都是可交换的。\n\n仅使用这些前提以及度、概率质量函数和独立性的定义，按以下步骤进行：\n- 从第一性原理出发，推导在 $G(n,p)$ 中随机选择的一个蛋白质的度 $K$ 的精确度分布 $P(K=k)$。\n- 使用您的推导来确定整个网络的度分布（即，一个均匀选择的节点度为 $k$ 的概率质量函数）。\n- 然后，计算一个均匀随机选择的蛋白质是孤立的（度为 $0$）的概率，并表示为 $n$ 和 $p$ 的函数。\n\n在使用独立性时，提供清晰的推理来证明其合理性，并解释您可能使用的任何极限近似（如果有的话）。不要假定任何关于 ER 模型的现成公式；直接从给定的定义进行推导。将您的最终答案表示为随机选择的蛋白质是孤立的概率的单个封闭形式表达式。无需四舍五入，也不涉及单位。",
            "solution": "对问题陈述进行分析后，确认其是有效的。它在科学上基于图论和概率论的既定原理，特别是 Erdős–Rényi 模型 $G(n,p)$。该问题定义明确，提供了所有必要的定义和前提，以推导出唯一且有意义的解。其语言客观、无歧义。因此，我们可以进行推导。\n\n我们的目标是推导 Erdős–Rényi 图 $G(n,p)$ 中一个节点的度分布，然后用它来求出节点是孤立的概率。推导将基于所提供的第一性原理。\n\n设蛋白质（节点）集合为 $V = \\{v_1, v_2, \\ldots, v_n\\}$，其中 $n$ 是蛋白质的总数。我们均匀随机地选择一个蛋白质，记为 $v$。$v$ 的度，记为 $K$，是与它通过边相连的其他蛋白质的数量。网络中有 $n-1$ 个其他蛋白质可能与 $v$ 相互作用。\n\n根据前提，任何给定边的存在都是一个独立事件。对于我们选择的蛋白质 $v$，我们考虑连接它与网络中其他所有蛋白质的 $n-1$ 条可能的边。设这些其他蛋白质为 $u_1, u_2, \\ldots, u_{n-1}$。对于 $i \\in \\{1, \\ldots, n-1\\}$，每条潜在边 $(v, u_i)$ 的形成都是一次伯努利试验。设 $X_i$ 为边 $(v, u_i)$ 存在的事件的指示随机变量。\n- 边存在的概率为 $P(X_i=1) = p$。\n- 边不存在的概率为 $P(X_i=0) = 1-p$。\n\n问题陈述指出，不同边的存在与否是独立事件。因此，随机变量 $X_1, X_2, \\ldots, X_{n-1}$ 是独立同分布（i.i.d.）的。\n\n蛋白质 $v$ 的度 $K$ 是连接到它的边的总数。这可以表示为 $n-1$ 条潜在边的指示变量之和：\n$$\nK = \\sum_{i=1}^{n-1} X_i\n$$\n\n我们想要找到概率质量函数 $P(K=k)$，即 $v$ 的度恰好为 $k$ 的概率。这种情况发生在 $n-1$ 条可能的边中恰好有 $k$ 条存在，而其余的 $(n-1)-k$ 条边不存在。度 $k$ 的取值范围可以从 $0$ 到 $n-1$。\n\n首先，我们必须从 $n-1$ 个潜在邻居中选择哪 $k$ 个与 $v$ 相连。从一个包含 $n-1$ 个元素的集合中选择 $k$ 个邻居的方法数由二项式系数 $\\binom{n-1}{k}$ 给出。\n\n对于任意一个特定的 $k$ 个邻居的选择，所有 $k$ 条相应边都存在的概率是 $p^k$。这是因为这 $k$ 个事件是独立的，所以我们将它们的概率相乘：$\\underbrace{p \\times p \\times \\cdots \\times p}_{k \\text{ times}} = p^k$。\n\n同时，对于同样一个特定的邻居选择，其余的 $(n-1)-k$ 个蛋白质必须*不*与 $v$ 相连。某一条特定边不存在的概率是 $1-p$。所有这 $(n-1)-k$ 条特定边都不存在的概率是 $(1-p)^{(n-1)-k}$，这同样是由于边形成事件的独立性。\n\n因此，任意一个具有 $k$ 个连接和 $(n-1)-k$ 个非连接的特定构型的概率是这些概率的乘积：$p^k (1-p)^{(n-1)-k}$。\n\n由于有 $\\binom{n-1}{k}$ 种不同的、互斥的构型都会导致度为 $k$，总概率 $P(K=k)$ 是它们概率的总和。因为每种构型的概率都相同，我们将单个构型的概率乘以可能构型的数量：\n$$\nP(K=k) = \\binom{n-1}{k} p^k (1-p)^{(n-1)-k}\n$$\n这是具有 $n-1$ 次试验和成功概率为 $p$ 的二项分布的概率质量函数。这就是特定节点 $v$ 的度分布。\n\n问题要求整个网络的度分布。因为 $G(n,p)$ 模型对称地（可交换地）处理所有节点和节点对，所以上述推导对网络中选择的任何节点都有效。因此，推导出的 $P(K=k)$ 是任何节点的度分布，因此也是均匀随机选择的节点的度分布。\n\n接下来，我们计算一个随机选择的蛋白质是孤立的概率。一个孤立的蛋白质是度为 $0$ 的节点。为了求这个概率，我们在我们推导出的度分布公式中令 $k=0$：\n$$\nP(K=0) = \\binom{n-1}{0} p^0 (1-p)^{(n-1)-0}\n$$\n我们计算这个表达式中的各项：\n- 二项式系数 $\\binom{n-1}{0}$ 等于 $1$，因为从一个包含 $n-1$ 个元素的集合中选择零个元素只有一种方法。\n- 项 $p^0$ 等于 $1$（对于任何 $p$，包括 $p=0$ 的平凡情况）。\n- 项 $(1-p)^{(n-1)-0}$ 简化为 $(1-p)^{n-1}$。\n\n将这些值代回方程中：\n$$\nP(K=0) = 1 \\cdot 1 \\cdot (1-p)^{n-1} = (1-p)^{n-1}\n$$\n这就是一个均匀随机选择的蛋白质是孤立的精确概率。该推导仅依赖于所提供的 $G(n,p)$ 模型的前提，没有调用任何极限近似，例如在 $n$ 大且 $p$ 小的情况下才有效的泊松近似。",
            "answer": "$$\\boxed{(1-p)^{n-1}}$$"
        },
        {
            "introduction": "除了节点的度等局部属性，我们常常需要衡量网络的全局连通性。这项练习引入了代数图论中的一个强大工具——矩阵树定理 (Matrix-Tree Theorem)，用以计算网络中生成树的数量。这个数值是衡量网络鲁棒性和冗余性的一个精密指标，而本练习将提供应用线性代数解决图论问题的实践经验 。",
            "id": "3317542",
            "problem": "一个经过筛选的蛋白质-蛋白质相互作用（PPI）酵母网络被建模为一个简单、无向、无权的图，其节点集为 $\\{P_1,P_2,P_3,P_4,P_5\\}$（代表蛋白质），边集代表经过实验验证的相互作用。该网络是连通的，并具有以下无向边：\n$$(P_1,P_2),\\ (P_2,P_3),\\ (P_3,P_4),\\ (P_4,P_1),\\ (P_2,P_5),\\ (P_3,P_5).$$\n将该网络视为一个图，其邻接矩阵为 $\\mathbf{A}$，度矩阵为 $\\mathbf{D}$，组合拉普拉斯矩阵为 $\\mathbf{L}=\\mathbf{D}-\\mathbf{A}$：\n\n- 在无向图的背景下，使用 $\\mathbf{L}$ 的一个代数余子式来陈述矩阵树定理。\n- 根据度数和邻接的基本定义，为该网络构建矩阵 $\\mathbf{A}$、$\\mathbf{D}$，并由此得到 $\\mathbf{L}$。\n- 使用该定理，通过计算 $\\mathbf{L}$ 的任意一个代数余子式来计算网络的生成树数量。代数余子式即为从 $\\mathbf{L}$ 中删除任意一行及相应列后得到的 $(n-1)\\times(n-1)$ 主子式的行列式。请使用有效的线性代数运算，展示你计算行列式的中间步骤。\n\n你的最终答案应为一个精确整数，无需四舍五入。",
            "solution": "该问题是有效的，因为其科学基础在于标准图论，问题陈述清晰，给定条件完整，且其表述是客观的。它要求将矩阵树定理直接应用于一个定义明确的图，这是生物网络分析中的一个标准流程。\n\n该问题需要一个包含三部分的解答：陈述矩阵树定理，构建图的拉普拉斯矩阵，以及使用该定理计算生成树的数量。\n\n**第 1 部分：矩阵树定理**\n\n矩阵树定理指出，对于一个有 $n$ 个顶点的连通无向图 $G$，其不同生成树的总数，记为 $\\tau(G)$，等于该图的组合拉普拉斯矩阵 $\\mathbf{L}$ 的任意一个代数余子式。组合拉普拉斯矩阵定义为 $\\mathbf{L} = \\mathbf{D} - \\mathbf{A}$，其中 $\\mathbf{D}$ 是 $G$ 的度矩阵，$\\mathbf{A}$ 是 $G$ 的邻接矩阵。\n\n$\\mathbf{L}$ 的所有代数余子式都相等。$\\mathbf{L}$ 的一个代数余子式 $C_{ij}$ 由 $C_{ij} = (-1)^{i+j} \\det(\\mathbf{L}_{ij})$ 给出，其中 $\\mathbf{L}_{ij}$ 是从 $\\mathbf{L}$ 中删除第 $i$ 行和第 $j$ 列得到的子矩阵。该定理意味着 $\\tau(G)$ 可以通过计算 $\\mathbf{L}$ 的任意主子式的行列式来得到，该主子式 $\\mathbf{L}_{ii}$ 是通过移除任意单一行 $i$ 及其对应的列 $i$ 形成的子矩阵。\n因此，对于任意 $i \\in \\{1, 2, ..., n\\}$，有 $\\tau(G) = \\det(\\mathbf{L}_{ii})$。\n\n**第 2 部分：矩阵 $\\mathbf{A}$、$\\mathbf{D}$ 和 $\\mathbf{L}$ 的构建**\n\n该网络的节点集为 $V = \\{P_1, P_2, P_3, P_4, P_5\\}$，因此 $n=5$。矩阵的尺寸将为 $5 \\times 5$，行和列根据蛋白质的索引排序。边集为 $E = \\{(P_1, P_2), (P_2, P_3), (P_3, P_4), (P_4, P_1), (P_2, P_5), (P_3, P_5)\\}$。\n\n首先，我们构建邻接矩阵 $\\mathbf{A}$，其中如果节点 $i$ 和节点 $j$ 之间存在边，则 $A_{ij} = 1$，否则 $A_{ij} = 0$。\n$$\n\\mathbf{A} = \\begin{pmatrix}\n0  1  0  1  0 \\\\\n1  0  1  0  1 \\\\\n0  1  0  1  1 \\\\\n1  0  1  0  0 \\\\\n0  1  1  0  0\n\\end{pmatrix}\n$$\n接下来，我们确定每个节点的度数，即与该节点相连的边的数量。\n$\\deg(P_1) = 2$\n$\\deg(P_2) = 3$\n$\\deg(P_3) = 3$\n$\\deg(P_4) = 2$\n$\\deg(P_5) = 2$\n\n度矩阵 $\\mathbf{D}$ 是一个对角矩阵，其对角线上的元素为这些度数。\n$$\n\\mathbf{D} = \\begin{pmatrix}\n2  0  0  0  0 \\\\\n0  3  0  0  0 \\\\\n0  0  3  0  0 \\\\\n0  0  0  2  0 \\\\\n0  0  0  0  2\n\\end{pmatrix}\n$$\n组合拉普拉斯矩阵 $\\mathbf{L}$ 计算为 $\\mathbf{L} = \\mathbf{D} - \\mathbf{A}$。\n$$\n\\mathbf{L} = \\begin{pmatrix}\n 2  -1   0  -1   0 \\\\\n-1   3  -1   0  -1 \\\\\n 0  -1   3  -1  -1 \\\\\n-1   0  -1   2   0 \\\\\n 0  -1  -1   0   2\n\\end{pmatrix}\n$$\n\n**第 3 部分：生成树数量的计算**\n\n根据矩阵树定理，我们可以通过求解 $\\mathbf{L}$ 的任意一个 $(n-1) \\times (n-1)$ 主子式的行列式来计算生成树的数量 $\\tau(G)$。我们选择移除最后一行和最后一列（第 5 行和第 5 列）。得到的子矩阵 $\\mathbf{L}_{55}$ 为：\n$$\n\\mathbf{L}_{55} = \\begin{pmatrix}\n 2  -1   0  -1 \\\\\n-1   3  -1   0 \\\\\n 0  -1   3  -1 \\\\\n-1   0  -1   2\n\\end{pmatrix}\n$$\n现在我们使用沿第一行的代数余子式展开来计算这个 $4 \\times 4$ 矩阵的行列式。\n$$\n\\det(\\mathbf{L}_{55}) = 2 \\det \\begin{pmatrix} 3  -1  0 \\\\ -1  3  -1 \\\\ 0  -1  2 \\end{pmatrix} - (-1) \\det \\begin{pmatrix} -1  -1  0 \\\\ 0  3  -1 \\\\ -1  -1  2 \\end{pmatrix} + 0 \\cdot (...) - (-1) \\det \\begin{pmatrix} -1  3  -1 \\\\ 0  -1  3 \\\\ -1  0  -1 \\end{pmatrix}\n$$\n我们分别计算每个 $3 \\times 3$ 的行列式。\n\n行列式 $M_1$：\n$$\nM_1 = \\det \\begin{pmatrix} 3  -1  0 \\\\ -1  3  -1 \\\\ 0  -1  2 \\end{pmatrix} = 3(3 \\cdot 2 - (-1)(-1)) - (-1)((-1) \\cdot 2 - (-1) \\cdot 0) + 0 = 3(6-1) + 1(-2) = 15 - 2 = 13\n$$\n\n行列式 $M_2$：\n$$\nM_2 = \\det \\begin{pmatrix} -1  -1  0 \\\\ 0  3  -1 \\\\ -1  -1  2 \\end{pmatrix} = -1(3 \\cdot 2 - (-1)(-1)) - (-1)(0 \\cdot 2 - (-1)(-1)) + 0 = -1(6-1) + 1(0-1) = -5 - 1 = -6\n$$\n\n行列式 $M_3$：\n$$\nM_3 = \\det \\begin{pmatrix} -1  3  -1 \\\\ 0  -1  3 \\\\ -1  0  -1 \\end{pmatrix} = -1((-1)(-1) - 3 \\cdot 0) - 3(0 \\cdot (-1) - 3(-1)) + (-1)(0 \\cdot 0 - (-1)(-1)) = -1(1) - 3(3) - 1(-1) = -1 - 9 + 1 = -9\n$$\n\n将这些值代回 $\\det(\\mathbf{L}_{55})$ 的表达式中：\n$$\n\\det(\\mathbf{L}_{55}) = 2(M_1) + 1(M_2) + 1(M_3) = 2(13) + 1(-6) + 1(-9) = 26 - 6 - 9 = 26 - 15 = 11\n$$\n因此，在给定的 PPI 网络中，生成树的数量为 $11$。",
            "answer": "$$\\boxed{11}$$"
        },
        {
            "introduction": "生物网络很少是同质的；它们通常含有高度互联且稳固的核心区域，这些区域对网络的整体功能至关重要。这项练习将深入探讨 k-核分解 ($k$-core decomposition)，这是一种识别这些弹性子图的强大方法。通过实现一个寻找图的简并度 (degeneracy) 的算法，并将其应用于一个靶向瓦解策略，你将获得分析网络结构和识别关键干预节点的实用技能 。",
            "id": "3317506",
            "problem": "考虑一个简单无向图 $G = (V,E)$，其中 $V$ 是一个有限节点集，$E$ 是一个边集 $E \\subseteq \\{\\{u,v\\} \\mid u,v \\in V, u \\neq v\\}$。对于每个节点 $v \\in V$，用 $d(v)$ 表示其度。$G$ 的 $k$-核（$k$-core）定义为 $G$ 中唯一的最大导出子图 $H \\subseteq G$，其中 $H$ 内的每个节点 $u \\in H$ 在 $H$ 中的度至少为 $k$。图 $G$ 的简并度 $D(G)$ 定义为使得 $G$ 的 $k$-核非空的最大整数 $k$；等价地，$D(G)$ 是 $G$ 中所有节点核数的最大值。对于一个节点 $v \\in V$，用 $G - v$ 表示从 $G$ 中移除节点 $v$ 及其所有关联边后得到的导出子图。\n\n在病原体蛋白质-蛋白质相互作用网络或基因调控网络的背景下，高简并度核可能代表具有冗余连接性的结构稳健区域。在计算系统生物学中，靶向破坏策略旨在高效地降低 $D(G)$。您的任务是针对一组测试图实现以下计算：\n\n1. 对于每个图 $G$，计算其简并度 $D(G)$。\n2. 对于每个节点 $v \\in V$，计算简并度下降值 $\\Delta_v = D(G) - D(G - v)$。识别出节点集合 $S^\\ast \\subseteq V$，其中每个节点的单点移除都能最大程度地降低简并度，即 $S^\\ast = \\{v \\in V \\mid \\Delta_v = \\max_{u \\in V} \\Delta_u\\}$。\n3. 对于每个图 $G$ 和一个整数目标 $T$（$0 \\leq T \\leq D(G)$），实现以下贪心靶向破坏策略，将简并度降低到至多为 $T$：\n   - 在处理过程中，令 $D_{\\text{curr}} = D(G)$ 为当前图的简并度。如果 $D_{\\text{curr}} \\leq T$，则停止并返回移除序列。\n   - 计算 $D_{\\text{curr}}$-核子图 $H$。如果 $H$ 为空，则停止（根据定义，如果 $D_{\\text{curr}}  0$，这种情况不会发生）。\n   - 设 $H$ 的连通分量为 $\\{H_1, H_2, \\dots, H_m\\}$，其中每个 $H_i$ 的节点集为 $V_i$。选择节点数 $|V_j|$ 最大的分量 $H_j$；如果存在多个最大分量，则选择其中最小节点标签最小的那个。从选定的分量 $H_j$ 中，移除标签最小的节点 $v^\\ast \\in V_j$。更新图 $G := G - v^\\ast$ 并重复此过程，直到 $D(G) \\leq T$。\n   - 返回此过程生成的完整移除序列 $(v_1^\\ast, v_2^\\ast, \\dots)$。\n\n所有节点标签均为非负整数。输出必须将所有测试用例的结果编码为一个单一的扁平整数列表，每个测试用例的结果按以下顺序组织：首先按升序列出 $S^\\ast$ 的所有元素，然后是哨兵值 $-1$，接着是为达到简并度至多为指定目标 $T$ 的贪心移除序列，最后是哨兵值 $-2$ 以标记该测试用例的结束。保证哨兵值 $-1$ 和 $-2$ 不会作为节点标签出现。\n\n您必须实现您的程序来解决以下测试图和目标的套件：\n\n- 测试用例 1：\n  - 节点：$V = \\{0,1,2,3,4\\}$。\n  - 边：所有满足 $0 \\leq i  j \\leq 4$ 的 $\\{i,j\\}$（一个五节点的完全图）。\n  - 目标：$T = 2$。\n- 测试用例 2：\n  - 节点：$V = \\{0,1,2,3,4,5,6,7,8\\}$。\n  - 边：所有满足 $0 \\leq i  j \\leq 3$ 的 $\\{i,j\\}$（一个在 $0,1,2,3$ 上的完全子图）和所有满足 $4 \\leq i  j \\leq 7$ 的 $\\{i,j\\}$（一个在 $4,5,6,7$ 上的完全子图），加上 $\\{8,3\\}$ 和 $\\{8,4\\}$（一个连接两个稠密区域的度为 $2$ 的桥接节点）。\n  - 目标：$T = 2$。\n- 测试用例 3：\n  - 节点：$V = \\{0,1,2,3,4,5,6\\}$。\n  - 边：所有满足 $i \\in \\{1,2,3,4,5,6\\}$ 的 $\\{0,i\\}$（一个以 $0$ 为中心、有六个叶节点的星形图）。\n  - 目标：$T = 0$。\n- 测试用例 4：\n  - 节点：$V = \\{0,1,2,3,4,5\\}$。\n  - 边：无（所有节点都是孤立的）。\n  - 目标：$T = 0$。\n- 测试用例 5：\n  - 节点：$V = \\{0,1,2,3,4,5,6,7,8\\}$。\n  - 边：所有满足 $0 \\leq i  j \\leq 4$ 的 $\\{i,j\\}$（一个在 $0,1,2,3,4$ 上的完全子图），加上对于每个 $i \\in \\{5,6,7,8\\}$ 的边 $\\{i,0\\}$ 和 $\\{i,1\\}$（连接到两个核心节点的外围节点）。\n  - 目标：$T = 3$。\n\n最终要求的输出格式为单行文本，包含五个测试用例的聚合结果，形式为一个由方括号括起来的逗号分隔列表，并严格遵循上述整数编码描述，例如：$[x_1,x_2,\\dots,x_n]$，其内容是所有测试用例的 $[S^\\ast,-1,\\text{移除序列},-2]$ 数据块的串联。",
            "solution": "该问题要求对一系列测试图实现三种图论计算：计算图的简并度，识别移除后导致简并度下降最大的节点，以及执行一个贪心的节点移除策略以将简并度降低到目标值。\n\n首先，我们必须将问题中提供的定义形式化。一个简单无向图由 $G = (V, E)$ 给出，其中 $V$ 是节点集，$E$ 是边集。节点 $v$ 的度，记为 $d(v)$，是与其关联的边的数量。\n\n**1. 简并度和 k-核的计算**\n\n图 $G$ 的 $k$-核是其中每个节点的度都至少为 $k$ 的最大导出子图。它可以通过一个迭代的“剥离”算法找到：反复从图中移除所有度小于 $k$ 的节点。当没有节点可以移除时，该过程终止。剩余的子图就是 $k$-核。\n\n图的简并度 $D(G)$ 是使得 $k$-核非空的最大整数 $k$。等价地，它是一个节点*核数*在所有节点中的最大值，而一个节点的核数是该节点所属的 $k$-核中最高的 $k$ 值。\n\n一种计算上高效的简并度算法基于创建简并度排序。这是一种顶点排序 $v_1, v_2, \\dots, v_n$，使得每个顶点 $v_i$ 在由 $\\{v_i, v_{i+1}, \\dots, v_n\\}$ 导出的子图中具有最小度。图的简并度即为 $\\max_i d_{G_i}(v_i)$，其中 $G_i$ 是由 $\\{v_i, \\dots, v_n\\}$ 导出的子图。对于本问题的规模，可以实现一个更简单但性能足够好的算法。其工作方式如下：\n1. 创建图的一个可变副本。\n2. 当图不为空时：\n   a. 在当前图中找到一个度最小的节点 $v$，设其度为 $d_{\\min}$。\n   b. 简并度至少为 $d_{\\min}$。记录到目前为止所见到的最大 $d_{\\min}$。\n   c. 从图中移除 $v$ 及其关联边。\n3. 记录到的最大最小度即为简并度 $D(G)$。如果在 $|V|$ 个步骤中的每一步都花费 $O(|V|)$ 时间来寻找最小度节点，则该算法的时间复杂度大约为 $O(|V|^2)$。\n\n**2. 识别关键节点 ($S^\\ast$)**\n\n此任务要求我们评估单独移除每个节点的影响。对于每个节点 $v \\in V$，我们通过移除 $v$ 及其所有关联边来构造子图 $G - v$。然后，我们使用上述算法计算这个新子图的简并度 $D(G-v)$。简并度下降值计算为 $\\Delta_v = D(G) - D(G-v)$。我们遍历 $V$ 中的所有节点，记录找到的最大下降值 $\\max_{u \\in V} \\Delta_u$。集合 $S^\\ast$ 包含所有达到此最大下降值的节点 $v$。\n\n**3. 贪心靶向破坏**\n\n这是一个将图的简并度降低到目标水平 $T$ 的迭代过程。设当前图为 $G_{\\text{curr}}$，初始化为原始图 $G$。过程如下：\n1. 计算当前图的简并度 $D_{\\text{curr}} = D(G_{\\text{curr}})$。\n2. 如果 $D_{\\text{curr}} \\leq T$，过程终止。\n3. 否则，识别 $D_{\\text{curr}}$-核子图，我们将其表示为 $H$。这是通过对固定的 $k=D_{\\text{curr}}$ 使用剥离算法来完成的。\n4. 找到 $H$ 的连通分量。这可以通过标准的图遍历算法（如广度优先搜索 (BFS) 或深度优先搜索 (DFS)）来完成。\n5. 根据两个标准选择目标分量：\n   a. 节点数最多的分量。\n   b. 如果大小相同，则选择其中最小节点标签最小的分量。\n   这个选择是确定性的。我们可以先按大小（降序）对分量进行排序，然后按其最小节点标签（升序）排序，以找到目标分量。\n6. 从选定的分量中，识别标签最小的节点 $v^\\ast$。\n7. 将 $v^\\ast$ 记录在移除序列中，并通过移除它来更新图：$G_{\\text{curr}} := G_{\\text{curr}} - v^\\ast$。\n8. 从步骤1开始重复此过程。\n\n实现将使用一个由集合构成的字典来表示图的邻接表，因为这种结构便于高效地移除节点和边。将为每个不同的算法任务创建辅助函数：简并度计算、k-核提取和寻找连通分量，以确保一个模块化且可验证的解决方案。\n\n对于每个测试用例，这三个任务按顺序执行。其结果（排序后的 $S^\\ast$，移除序列）与指定的哨兵值（$-1$ 和 $-2$）串联起来，形成该测试用例的最终输出字符串，然后将它们聚合成一个单一列表。",
            "answer": "[0,1,2,3,4,-1,0,1,-2,3,4,-1,3,4,-2,0,-1,0,-2,0,1,2,3,4,5,-1,-2,0,1,-1,0,-2]"
        }
    ]
}