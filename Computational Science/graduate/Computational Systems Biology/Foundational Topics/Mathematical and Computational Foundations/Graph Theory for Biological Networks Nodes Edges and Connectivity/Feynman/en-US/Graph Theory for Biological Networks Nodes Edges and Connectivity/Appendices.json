{
    "hands_on_practices": [
        {
            "introduction": "To understand the complex architecture of biological networks, we often start with a \"null model\"—a baseline that represents a complete absence of specific organizing principles. The Erdős–Rényi random graph serves as this fundamental benchmark, modeling a network where each possible interaction occurs with the same independent probability $p$. This exercise  challenges you to derive the degree distribution of this model from first principles, providing insight into the expected connectivity patterns in a purely random world. Mastering this derivation is key to identifying which features of real biological networks, like the presence of highly connected hub proteins, are truly significant deviations from randomness.",
            "id": "3317480",
            "problem": "A protein-protein interaction (PPI) network under a fixed experimental condition is modeled as an Erdős–Rényi (ER) graph, denoted by $G(n,p)$, where $n$ is the number of proteins (nodes) and $p$ is the probability that any given pair of proteins interacts (an undirected edge). Assume the following foundational premises:\n- In $G(n,p)$, each of the $\\binom{n}{2}$ possible undirected edges is present independently with probability $p$.\n- The presence or absence of distinct edges are independent Bernoulli trials, and all node pairs are exchangeable.\n\nUsing only these premises and the definitions of degree, probability mass function, and independence, proceed as follows:\n- Derive from first principles the exact degree distribution $P(K=k)$ for the degree $K$ of a randomly selected protein in $G(n,p)$.\n- Use your derivation to determine the expected degree distribution across the network (that is, the probability mass function that a uniformly chosen node has degree $k$).\n- Then, compute the probability that a uniformly randomly selected protein is isolated (degree $0$), expressed as a function of $n$ and $p$.\n\nProvide clear reasoning that justifies independence where it is used and explain any limiting approximations you invoke, if any. Do not assume any pre-packaged formulas for the ER model; derive them directly from the definitions given. Express your final answer as a single closed-form expression for the probability that a randomly selected protein is isolated. No rounding is required, and no units are involved.",
            "solution": "The problem statement is analyzed and found to be valid. It is scientifically grounded in the established principles of graph theory and probability theory, specifically the Erdős–Rényi model $G(n,p)$. The problem is well-posed, with all necessary definitions and premises provided to derive a unique, meaningful solution. The language is objective and unambiguous. We may therefore proceed with the derivation.\n\nOur goal is to derive the degree distribution for a node in an Erdős–Rényi graph $G(n,p)$ and then use it to find the probability that a node is isolated. The derivation will be built from the first principles provided.\n\nLet the set of proteins (nodes) be $V = \\{v_1, v_2, \\ldots, v_n\\}$, where $n$ is the total number of proteins. We select a protein uniformly at random; let us denote this protein as $v$. The degree of $v$, denoted by $K$, is the number of other proteins to which it is connected by an edge. There are $n-1$ other proteins in the network that $v$ could potentially interact with.\n\nAccording to the premises, the existence of any given edge is an independent event. For our chosen protein $v$, we consider the $n-1$ possible edges connecting it to every other protein in the network. Let these other proteins be $u_1, u_2, \\ldots, u_{n-1}$. The formation of each potential edge $(v, u_i)$ for $i \\in \\{1, \\ldots, n-1\\}$ is a Bernoulli trial. Let $X_i$ be an indicator random variable for the event that the edge $(v, u_i)$ exists.\n- The probability that the edge exists is $P(X_i=1) = p$.\n- The probability that the edge does not exist is $P(X_i=0) = 1-p$.\n\nThe problem states that the presence or absence of distinct edges are independent events. Therefore, the random variables $X_1, X_2, \\ldots, X_{n-1}$ are independent and identically distributed (i.i.d.).\n\nThe degree $K$ of protein $v$ is the total number of edges connected to it. This can be expressed as the sum of the indicator variables for the $n-1$ potential edges:\n$$\nK = \\sum_{i=1}^{n-1} X_i\n$$\n\nWe want to find the probability mass function $P(K=k)$, which is the probability that the degree of $v$ is exactly $k$. This occurs if exactly $k$ of the $n-1$ possible edges exist, and the remaining $(n-1)-k$ edges do not. The degree $k$ can range from $0$ to $n-1$.\n\nFirst, we must choose which $k$ of the $n-1$ potential neighbors are connected to $v$. The number of ways to select $k$ neighbors from a set of $n-1$ is given by the binomial coefficient, $\\binom{n-1}{k}$.\n\nFor any single, specific choice of $k$ neighbors, the probability that all $k$ corresponding edges exist is $p^k$. This is because the $k$ events are independent, so we multiply their probabilities: $\\underbrace{p \\times p \\times \\cdots \\times p}_{k \\text{ times}} = p^k$.\n\nSimultaneously, for that same specific choice of neighbors, the remaining $(n-1)-k$ proteins must *not* be connected to $v$. The probability that a single specific edge does not exist is $1-p$. The probability that all $(n-1)-k$ of these specific edges do not exist is $(1-p)^{(n-1)-k}$, again due to the independence of edge formation events.\n\nTherefore, the probability of any one specific configuration of $k$ connections and $(n-1)-k$ non-connections is the product of these probabilities: $p^k (1-p)^{(n-1)-k}$.\n\nSince there are $\\binom{n-1}{k}$ such distinct and mutually exclusive configurations that all result in a degree of $k$, the total probability $P(K=k)$ is the sum of their probabilities. As each configuration has the same probability, we multiply the probability of a single configuration by the number of possible configurations:\n$$\nP(K=k) = \\binom{n-1}{k} p^k (1-p)^{(n-1)-k}\n$$\nThis is the probability mass function for a binomial distribution with $n-1$ trials and success probability $p$. This is the degree distribution for the specific node $v$.\n\nThe problem asks for the expected degree distribution across the network. Because the $G(n,p)$ model treats all nodes and node pairs symmetrically (exchangeably), the derivation above is valid for any node chosen from the network. Thus, the derived $P(K=k)$ is the degree distribution for any node and consequently for a node selected uniformly at random.\n\nNext, we compute the probability that a randomly selected protein is isolated. An isolated protein is a node with a degree of $0$. To find this probability, we set $k=0$ in our derived degree distribution formula:\n$$\nP(K=0) = \\binom{n-1}{0} p^0 (1-p)^{(n-1)-0}\n$$\nWe evaluate the terms in this expression:\n- The binomial coefficient $\\binom{n-1}{0}$ is equal to $1$, as there is only one way to choose zero items from a set of $n-1$.\n- The term $p^0$ is equal to $1$ (for any $p$, including the trivial case $p=0$).\n- The term $(1-p)^{(n-1)-0}$ simplifies to $(1-p)^{n-1}$.\n\nSubstituting these values back into the equation:\n$$\nP(K=0) = 1 \\cdot 1 \\cdot (1-p)^{n-1} = (1-p)^{n-1}\n$$\nThis is the exact probability that a uniformly randomly selected protein is isolated. This derivation relies solely on the provided premises of the $G(n,p)$ model and does not invoke any limiting approximations, such as the Poisson approximation which becomes valid for large $n$ and small $p$.",
            "answer": "$$\\boxed{(1-p)^{n-1}}$$"
        },
        {
            "introduction": "Beyond random models, we need tools to quantify the structural properties of specific, observed networks. One powerful measure of a network's robustness and redundancy is its total number of spanning trees—the minimal \"skeletons\" that keep all nodes connected. This practice  introduces the Matrix-Tree Theorem, a cornerstone of spectral graph theory that elegantly connects the algebraic properties of the graph's Laplacian matrix to this combinatorial count. By applying this theorem to a protein-protein interaction network, you will gain hands-on experience with a sophisticated method for assessing global network connectivity.",
            "id": "3317542",
            "problem": "A curated protein-protein interaction (PPI) network in yeast is modeled as a simple, undirected, unweighted graph with node set $\\{P_1,P_2,P_3,P_4,P_5\\}$ representing proteins and an edge set representing experimentally supported interactions. The network is connected and has the following undirected edges:\n$$(P_1,P_2),\\ (P_2,P_3),\\ (P_3,P_4),\\ (P_4,P_1),\\ (P_2,P_5),\\ (P_3,P_5).$$\nTreating the network as a graph with adjacency matrix $\\mathbf{A}$, degree matrix $\\mathbf{D}$, and combinatorial Laplacian $\\mathbf{L}=\\mathbf{D}-\\mathbf{A}$:\n\n- State the Matrix-Tree Theorem in the context of an undirected graph in terms of a cofactor of $\\mathbf{L}$.\n- From first principles, construct $\\mathbf{A}$, $\\mathbf{D}$, and hence $\\mathbf{L}$ for this network using the definitions of degree and adjacency.\n- Using the theorem, compute the number of spanning trees of the network by evaluating any cofactor of $\\mathbf{L}$, that is, the determinant of an $(n-1)\\times(n-1)$ principal minor obtained by deleting any one row and the corresponding column from $\\mathbf{L}$. Show the intermediate steps of your determinant evaluation using valid linear algebra operations.\n\nProvide your final answer as a single exact integer. No rounding is necessary.",
            "solution": "The problem is valid as it is scientifically grounded in standard graph theory, well-posed with a clear and complete set of givens, and objective in its formulation. It requests a direct application of the Matrix-Tree Theorem to a well-defined graph, a standard procedure in the analysis of biological networks.\n\nThe problem requires a three-part solution: stating the Matrix-Tree Theorem, constructing the graph Laplacian, and using the theorem to compute the number of spanning trees.\n\n**Part 1: The Matrix-Tree Theorem**\n\nThe Matrix-Tree Theorem states that for a connected, undirected graph $G$ with $n$ vertices, the total number of distinct spanning trees, denoted $\\tau(G)$, is equal to any cofactor of the graph's combinatorial Laplacian matrix, $\\mathbf{L}$. The combinatorial Laplacian is defined as $\\mathbf{L} = \\mathbf{D} - \\mathbf{A}$, where $\\mathbf{D}$ is the degree matrix and $\\mathbf{A}$ is the adjacency matrix of $G$.\n\nAll cofactors of $\\mathbf{L}$ are equal. A cofactor $C_{ij}$ of $\\mathbf{L}$ is given by $C_{ij} = (-1)^{i+j} \\det(\\mathbf{L}_{ij})$, where $\\mathbf{L}_{ij}$ is the submatrix of $\\mathbf{L}$ obtained by deleting row $i$ and column $j$. The theorem implies that $\\tau(G)$ can be computed by calculating the determinant of any principal minor of $\\mathbf{L}$, which is a submatrix $\\mathbf{L}_{ii}$ formed by removing any single row $i$ and its corresponding column $i$.\nThus, $\\tau(G) = \\det(\\mathbf{L}_{ii})$ for any $i \\in \\{1, 2, ..., n\\}$.\n\n**Part 2: Construction of Matrices $\\mathbf{A}$, $\\mathbf{D}$, and $\\mathbf{L}$**\n\nThe network has a node set $V = \\{P_1, P_2, P_3, P_4, P_5\\}$, so $n=5$. The matrices will be of size $5 \\times 5$, with rows and columns ordered according to the indices of the proteins. The edge set is $E = \\{(P_1, P_2), (P_2, P_3), (P_3, P_4), (P_4, P_1), (P_2, P_5), (P_3, P_5)\\}$.\n\nFirst, we construct the adjacency matrix $\\mathbf{A}$, where $A_{ij} = 1$ if an edge exists between node $i$ and node $j$, and $A_{ij} = 0$ otherwise.\n$$\n\\mathbf{A} = \\begin{pmatrix}\n0  1  0  1  0 \\\\\n1  0  1  0  1 \\\\\n0  1  0  1  1 \\\\\n1  0  1  0  0 \\\\\n0  1  1  0  0\n\\end{pmatrix}\n$$\nNext, we determine the degree of each node, which is the number of edges incident to it.\n$\\deg(P_1) = 2$\n$\\deg(P_2) = 3$\n$\\deg(P_3) = 3$\n$\\deg(P_4) = 2$\n$\\deg(P_5) = 2$\n\nThe degree matrix $\\mathbf{D}$ is a diagonal matrix with these degrees on the diagonal.\n$$\n\\mathbf{D} = \\begin{pmatrix}\n2  0  0  0  0 \\\\\n0  3  0  0  0 \\\\\n0  0  3  0  0 \\\\\n0  0  0  2  0 \\\\\n0  0  0  0  2\n\\end{pmatrix}\n$$\nThe combinatorial Laplacian matrix $\\mathbf{L}$ is calculated as $\\mathbf{L} = \\mathbf{D} - \\mathbf{A}$.\n$$\n\\mathbf{L} = \\begin{pmatrix}\n 2  -1   0  -1   0 \\\\\n-1   3  -1   0  -1 \\\\\n 0  -1   3  -1  -1 \\\\\n-1   0  -1   2   0 \\\\\n 0  -1  -1   0   2\n\\end{pmatrix}\n$$\n\n**Part 3: Calculation of the Number of Spanning Trees**\n\nAccording to the Matrix-Tree Theorem, we can compute the number of spanning trees, $\\tau(G)$, by finding the determinant of any $(n-1) \\times (n-1)$ principal minor of $\\mathbf{L}$. Let us choose to remove the last row and column (row $5$ and column $5$). The resulting submatrix, $\\mathbf{L}_{55}$, is:\n$$\n\\mathbf{L}_{55} = \\begin{pmatrix}\n 2  -1   0  -1 \\\\\n-1   3  -1   0 \\\\\n 0  -1   3  -1 \\\\\n-1   0  -1   2\n\\end{pmatrix}\n$$\nWe now compute the determinant of this $4 \\times 4$ matrix using cofactor expansion along the first row.\n$$\n\\det(\\mathbf{L}_{55}) = 2 \\det \\begin{pmatrix} 3  -1  0 \\\\ -1  3  -1 \\\\ 0  -1  2 \\end{pmatrix} - (-1) \\det \\begin{pmatrix} -1  -1  0 \\\\ 0  3  -1 \\\\ -1  -1  2 \\end{pmatrix} + 0 \\cdot (...) - (-1) \\det \\begin{pmatrix} -1  3  -1 \\\\ 0  -1  3 \\\\ -1  0  -1 \\end{pmatrix}\n$$\nWe evaluate each of the $3 \\times 3$ determinants separately.\n\nDeterminant $M_1$:\n$$\nM_1 = \\det \\begin{pmatrix} 3  -1  0 \\\\ -1  3  -1 \\\\ 0  -1  2 \\end{pmatrix} = 3(3 \\cdot 2 - (-1)(-1)) - (-1)((-1) \\cdot 2 - (-1) \\cdot 0) + 0 = 3(6-1) + 1(-2) = 15 - 2 = 13\n$$\n\nDeterminant $M_2$:\n$$\nM_2 = \\det \\begin{pmatrix} -1  -1  0 \\\\ 0  3  -1 \\\\ -1  -1  2 \\end{pmatrix} = -1(3 \\cdot 2 - (-1)(-1)) - (-1)(0 \\cdot 2 - (-1)(-1)) + 0 = -1(6-1) + 1(0-1) = -5 - 1 = -6\n$$\n\nDeterminant $M_3$:\n$$\nM_3 = \\det \\begin{pmatrix} -1  3  -1 \\\\ 0  -1  3 \\\\ -1  0  -1 \\end{pmatrix} = -1((-1)(-1) - 3 \\cdot 0) - 3(0 \\cdot (-1) - 3(-1)) + (-1)(0 \\cdot 0 - (-1)(-1)) = -1(1) - 3(3) - 1(-1) = -1 - 9 + 1 = -9\n$$\n\nSubstituting these values back into the expression for $\\det(\\mathbf{L}_{55})$:\n$$\n\\det(\\mathbf{L}_{55}) = 2(M_1) + 1(M_2) + 1(M_3) = 2(13) + 1(-6) + 1(-9) = 26 - 6 - 9 = 26 - 15 = 11\n$$\nThus, the number of spanning trees in the given PPI network is $11$.",
            "answer": "$$\\boxed{11}$$"
        },
        {
            "introduction": "Connectivity in real biological networks is rarely uniform; instead, they often exhibit a core-periphery organization, with densely interconnected modules forming a robust backbone. The concept of $k$-core decomposition is a powerful algorithmic tool for uncovering this hierarchical structure. This hands-on practice  guides you through implementing this technique to calculate a graph's degeneracy and identify the critical nodes that uphold its most connected core. This analysis is not merely academic; it simulates a key strategy in computational systems biology for targeting network vulnerabilities, such as disrupting essential functions in a pathogen.",
            "id": "3317506",
            "problem": "Consider a simple undirected graph $G = (V,E)$ with a finite set of nodes $V$ and a set of edges $E \\subseteq \\{\\{u,v\\} \\mid u,v \\in V, u \\neq v\\}$. For each node $v \\in V$, denote its degree by $d(v)$. The $k$-core of $G$ is defined as the unique maximal induced subgraph $H \\subseteq G$ in which every node $u \\in H$ has degree at least $k$ within $H$. The degeneracy $D(G)$ of a graph $G$ is defined as the maximum integer $k$ for which the $k$-core of $G$ is nonempty; equivalently, $D(G)$ is the maximum core number over all nodes in $G$. For a node $v \\in V$, denote by $G - v$ the induced subgraph of $G$ obtained by removing $v$ and all edges incident to $v$.\n\nIn the context of pathogen protein-protein interaction networks or gene regulatory networks, high-degeneracy cores may represent structurally robust regions with redundant connectivity. In computational systems biology, targeted disruption strategies aim to reduce $D(G)$ efficiently. Your task is to implement the following computations across a test suite of graphs:\n\n1. For each graph $G$, compute the degeneracy $D(G)$.\n2. For each node $v \\in V$, compute the degeneracy drop $\\Delta_v = D(G) - D(G - v)$. Identify the set $S^\\ast \\subseteq V$ of nodes whose single-node removal maximally reduces the degeneracy, that is, $S^\\ast = \\{v \\in V \\mid \\Delta_v = \\max_{u \\in V} \\Delta_u\\}$.\n3. For each graph $G$ and an integer target $T$ with $0 \\leq T \\leq D(G)$, implement the following greedy targeted disruption strategy to reduce the degeneracy to at most $T$:\n   - Let $D_{\\text{curr}} = D(G)$ for the current graph during the process. If $D_{\\text{curr}} \\leq T$, stop and return the removal sequence.\n   - Compute the $D_{\\text{curr}}$-core subgraph $H$. If $H$ is empty, stop (this cannot happen if $D_{\\text{curr}}  0$ by definition).\n   - Let the connected components of $H$ be $\\{H_1, H_2, \\dots, H_m\\}$, where each $H_i$ has node set $V_i$. Select the component $H_j$ with the largest $|V_j|$; in case of ties, choose the component among those tied whose smallest node label is minimal. From the chosen component $H_j$, remove the node $v^\\ast \\in V_j$ with the smallest label. Update the graph $G := G - v^\\ast$ and repeat until $D(G) \\leq T$.\n   - Return the entire removal sequence $(v_1^\\ast, v_2^\\ast, \\dots)$ produced by this process.\n\nAll node labels are nonnegative integers. The output must encode the results for all test cases in a single flat list of integers, structured as follows for each test case in order: list all elements of $S^\\ast$ in increasing order, then the sentinel $-1$, then the greedy removal sequence to reach degeneracy at most the specified target $T$, then the sentinel $-2$ to mark the end of the test case. The sentinel values $-1$ and $-2$ are guaranteed not to occur as node labels.\n\nYou must implement your program to solve the following test suite of graphs and targets:\n\n- Test case 1:\n  - Nodes: $V = \\{0,1,2,3,4\\}$.\n  - Edges: all $\\{i,j\\}$ for $0 \\leq i  j \\leq 4$ (complete graph on five nodes).\n  - Target: $T = 2$.\n- Test case 2:\n  - Nodes: $V = \\{0,1,2,3,4,5,6,7,8\\}$.\n  - Edges: all $\\{i,j\\}$ for $0 \\leq i  j \\leq 3$ (a complete subgraph on $0,1,2,3$) and all $\\{i,j\\}$ for $4 \\leq i  j \\leq 7$ (a complete subgraph on $4,5,6,7$), plus $\\{8,3\\}$ and $\\{8,4\\}$ (a bridge node of degree $2$ connecting the two dense regions).\n  - Target: $T = 2$.\n- Test case 3:\n  - Nodes: $V = \\{0,1,2,3,4,5,6\\}$.\n  - Edges: all $\\{0,i\\}$ for $i \\in \\{1,2,3,4,5,6\\}$ (a star centered at $0$ with six leaves).\n  - Target: $T = 0$.\n- Test case 4:\n  - Nodes: $V = \\{0,1,2,3,4,5\\}$.\n  - Edges: none (all nodes are isolated).\n  - Target: $T = 0$.\n- Test case 5:\n  - Nodes: $V = \\{0,1,2,3,4,5,6,7,8\\}$.\n  - Edges: all $\\{i,j\\}$ for $0 \\leq i  j \\leq 4$ (a complete subgraph on $0,1,2,3,4$), plus edges $\\{i,0\\}$ and $\\{i,1\\}$ for each $i \\in \\{5,6,7,8\\}$ (peripheral nodes attached to two core nodes).\n  - Target: $T = 3$.\n\nThe required final output format is a single line containing the aggregated results for the five test cases as a comma-separated list enclosed in square brackets, strictly following the integer encoding described above, for example: $[x_1,x_2,\\dots,x_n]$ where the content is the concatenation over test cases of the block $[S^\\ast,-1,\\text{removal sequence},-2]$.",
            "solution": "The problem requires the implementation of three graph-theoretic computations on a series of test graphs: calculating the graph's degeneracy, identifying nodes whose removal causes the largest drop in degeneracy, and executing a greedy node-removal strategy to reduce the degeneracy to a target value.\n\nFirst, we must formalize the definitions provided. A simple undirected graph is given by $G = (V, E)$, where $V$ is the set of nodes and $E$ is the set of edges. The degree of a node $v$, denoted $d(v)$, is the number of edges incident to it.\n\n**1. Degeneracy and k-Core Calculation**\n\nThe $k$-core of a graph $G$ is the largest induced subgraph where every node has a degree of at least $k$. It can be found via an iterative \"peeling\" algorithm: repeatedly remove all nodes with a degree less than $k$ from the graph. The process terminates when no more nodes can be removed. The remaining subgraph is the $k$-core.\n\nThe degeneracy of a graph, $D(G)$, is the largest integer $k$ for which the $k$-core is non-empty. Equivalently, it is the maximum, over all nodes, of the *core number* of a node, where a node's core number is the highest $k$ for which it is a member of the $k$-core.\n\nA computationally efficient algorithm to find the degeneracy is based on creating a degeneracy ordering. This is an ordering of the vertices $v_1, v_2, \\dots, v_n$ such that each vertex $v_i$ has the minimum degree in the subgraph induced by $\\{v_i, v_{i+1}, \\dots, v_n\\}$. The degeneracy of the graph is then $\\max_i d_{G_i}(v_i)$, where $G_i$ is the subgraph induced by $\\{v_i, \\dots, v_n\\}$. A simpler, yet sufficiently performant for this problem's scale, algorithm can be implemented. It works as follows:\n1. Create a mutable copy of the graph.\n2. While the graph is not empty:\n   a. Find a node $v$ with the minimum degree, say $d_{\\min}$, in the current graph.\n   b. The degeneracy is at least $d_{\\min}$. Record the maximum $d_{\\min}$ seen so far.\n   c. Remove $v$ and its incident edges from the graph.\n3. The maximum recorded minimum degree is the degeneracy $D(G)$. This algorithm has a time complexity of roughly $O(|V|^2)$ if finding the minimum degree node takes $O(|V|)$ time at each of the $|V|$ steps.\n\n**2. Identifying Critical Nodes ($S^\\ast$)**\n\nThis task requires us to evaluate the impact of removing each node individually. For every node $v \\in V$, we construct the subgraph $G - v$ by removing $v$ and all its incident edges. We then compute the degeneracy of this new subgraph, $D(G-v)$, using the algorithm described above. The degeneracy drop is calculated as $\\Delta_v = D(G) - D(G-v)$. We iterate through all nodes in $V$, keeping track of the maximum drop found, $\\max_{u \\in V} \\Delta_u$. The set $S^\\ast$ contains all nodes $v$ that achieve this maximum drop.\n\n**3. Greedy Targeted Disruption**\n\nThis is an iterative procedure to reduce the graph's degeneracy to a target level $T$.\nLet the current graph be $G_{\\text{curr}}$, initialized to the original graph $G$. The process is as follows:\n1. Compute the degeneracy of the current graph, $D_{\\text{curr}} = D(G_{\\text{curr}})$.\n2. If $D_{\\text{curr}} \\leq T$, the process terminates.\n3. Otherwise, identify the $D_{\\text{curr}}$-core subgraph, which we denote as $H$. This is done using the peeling algorithm for a fixed $k=D_{\\text{curr}}$.\n4. Find the connected components of $H$. This can be done using a standard graph traversal algorithm like Breadth-First Search (BFS) or Depth-First Search (DFS).\n5. Select the target component based on two criteria:\n   a. The component with the largest number of nodes.\n   b. In case of a tie in size, the component whose smallest node label is minimal.\n   This selection is deterministic. We can sort the components first by size (descending) and then by their minimum node label (ascending) to find the target.\n6. From the selected component, identify the node $v^\\ast$ with the smallest label.\n7. Record $v^\\ast$ in the removal sequence and update the graph by removing it: $G_{\\text{curr}} := G_{\\text{curr}} - v^\\ast$.\n8. Repeat the process from step 1.\n\nThe implementation will use a dictionary of sets to represent the graph's adjacency list, as this structure facilitates efficient node and edge removal. Helper functions will be created for each distinct algorithmic task: degeneracy computation, $k$-core extraction, and finding connected components, ensuring a modular and verifiable solution.\n\nFor each test case, these three tasks are executed in sequence. The results ($S^\\ast$ sorted, the removal sequence) are concatenated with the specified sentinels ($-1$ and $-2$) to form the final output string for that test case, which are then aggregated into a single list.",
            "answer": "[0,1,2,3,4,-1,0,1,-2,0,1,2,3,4,5,6,7,8,-1,0,4,-2,0,-1,0,-2,0,1,2,3,4,5,-1,-2,0,1,2,3,4,-1,0,-2]"
        }
    ]
}