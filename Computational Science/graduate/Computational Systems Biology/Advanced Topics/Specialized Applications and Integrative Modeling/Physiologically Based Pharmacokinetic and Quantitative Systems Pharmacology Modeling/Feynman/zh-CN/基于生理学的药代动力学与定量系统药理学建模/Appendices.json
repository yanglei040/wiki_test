{
    "hands_on_practices": [
        {
            "introduction": "理论知识需要通过实践来巩固。本节的第一个练习将引导你回归PBPK建模的本源：质量平衡原理。我们将暂时忽略复杂的动态过程，专注于理解在稳态条件下决定药物暴露的核心因素。通过推导一个简约PBPK模型中的稳态血浆浓度，你将亲身体会器官血流、固有清除率和血浆蛋白结合等生理参数如何共同决定药物的全身清除率，从而为更复杂的模型打下坚实的基础。",
            "id": "3338308",
            "problem": "考虑一个用于静脉给药的简化生理药代动力学 (PBPK) 模型，该模型包含四个房室：血浆、肝脏、肾脏和肌肉。假设所有组织中的分布均为灌注限制型，动力学为线性的，并且每个房室都是充分混合的。药物以恒定速率 $R_{in}$ 注入血浆，并可逆地与血浆蛋白结合，其未结合分数为 $f_u$。忽略肝门静脉输入（假定只有体循环动脉输入），红细胞对分布没有差异性贡献（血-浆浓度比等于 $1$）。设器官血流量分别为 $Q_h$（肝脏）、$Q_k$（肾脏）和 $Q_m$（肌肉），房室容积分别为 $V_p$（血浆）、$V_h$（肝脏）、$V_k$（肾脏）和 $V_m$（肌肉），心脏输出量满足 $Q_h + Q_k + Q_m$ 等于流入血浆的动脉血流量。肌肉仅作为分布房室（无消除）。在充分混合器官假设下，肝脏消除的特征是作用于肝内未结合药物的内禀清除率 $CL_{int}$。肾脏消除仅通过肾小球滤过发生，肾脏滤过清除率为 $f_u \\cdot GFR$，其中 $GFR$ 是肾小球滤过率，不存在肾小管分泌/重吸收。\n\n从质量守恒和充分混合器官模型出发，并利用上述假设，推导在恒定速率 $R_{in}$ 输注下稳态血浆浓度 $C_{p,\\mathrm{ss}}$ 的封闭式表达式。最终答案仅用 $R_{in}$、$f_u$、$CL_{int}$、$GFR$ 和 $Q_h$ 表示。以质量/体积单位（例如 $\\mathrm{mg}/\\mathrm{L}$）提供 $C_{p,\\mathrm{ss}}$ 的最终表达式。无需进行数值计算，也无需四舍五入。",
            "solution": "本题要求计算通过恒定静脉输注给药的药物的稳态血浆浓度 $C_{p,\\mathrm{ss}}$。推导基于生理药代动力学 (PBPK) 模型中的质量守恒原理。\n\n**步骤 1：稳态基本原理**\n\n在稳态 ($ss$) 下，药物进入体循环的速率必须等于其从体内消除的速率。\n$$\n\\text{输入速率} = \\text{消除速率}\n$$\n题目指出药物以恒定速率 $R_{in}$ 输注。因此，输入速率为 $R_{in}$。假设清除率是相对于血浆浓度定义的，则总消除速率是全身总清除率 $CL_{tot}$ 与稳态血浆浓度 $C_{p,\\mathrm{ss}}$ 的乘积。血-浆浓度比为 $1$ 的假设允许我们将基于血液的清除率与基于血浆的清除率等同起来。\n$$\nR_{in} = CL_{tot} \\cdot C_{p,\\mathrm{ss}}\n$$\n求解稳态血浆浓度可得：\n$$\nC_{p,\\mathrm{ss}} = \\frac{R_{in}}{CL_{tot}}\n$$\n为了求得 $C_{p,\\mathrm{ss}}$，我们必须首先确定全身总清除率 $CL_{tot}$。\n\n**步骤 2：全身总清除率 ($CL_{tot}$)**\n\n全身总清除率是所有消除器官清除率的总和。在此模型中，消除器官是肝脏和肾脏。肌肉被指定为仅分布房室，因此其清除率为零。\n$$\nCL_{tot} = CL_h + CL_r\n$$\n其中 $CL_h$ 是肝清除率，$CL_r$ 是肾清除率。我们将根据给定的假设推导这两项。\n\n**步骤 3：肝清除率 ($CL_h$)**\n\n题目明确指出肝脏消除遵循“充分混合器官”模型。在此模型中，假定肝内药物浓度是均匀的，且等于离开肝脏的静脉血中的浓度。充分混合器官的清除率由一个标准公式给出，该公式关联了器官血流量 ($Q_h$)、药物在血浆中的未结合分数 ($f_u$) 和内禀清除率 ($CL_{int}$)。内禀清除率是作用于未结合药物的肝酶的最大代谢能力。\n在充分混合模型下，肝清除率的公式为：\n$$\nCL_h = \\frac{Q_h \\cdot f_u \\cdot CL_{int}}{Q_h + f_u \\cdot CL_{int}}\n$$\n该表达式取决于 $Q_h$、$f_u$ 和 $CL_{int}$，这些都是题目中提供或最终答案允许使用的变量。\n\n**步骤 4：肾清除率 ($CL_r$)**\n\n题目陈述肾脏消除完全通过肾小球滤过发生。不存在肾小管分泌和重吸收。通过滤过消除药物的速率是肾小球滤过率 ($GFR$) 与可自由滤过的药物浓度的乘积。只有血浆中的未结合药物才能通过肾小球。未结合血浆浓度为 $C_{u,p} = f_u \\cdot C_p$。\n\n因此，肾脏消除的速率为：\n$$\n\\text{Rate}_{elim,r} = GFR \\cdot C_{u,p} = GFR \\cdot f_u \\cdot C_p\n$$\n根据定义，清除率是消除速率除以参考浓度（在此情况下为总血浆浓度 $C_p$）。\n$$\nCL_r = \\frac{\\text{Rate}_{elim,r}}{C_p} = \\frac{GFR \\cdot f_u \\cdot C_p}{C_p}\n$$\n简化后可得：\n$$\nCL_r = f_u \\cdot GFR\n$$\n这证实了题目描述中给出的肾脏滤过清除率的表达式。该表达式取决于 $f_u$ 和 $GFR$，它们是允许使用的变量。\n\n**步骤 5：稳态血浆浓度 ($C_{p,\\mathrm{ss}}$) 的最终表达式**\n\n现在我们将各个清除率的表达式合并，以求得全身总清除率。\n$$\nCL_{tot} = CL_h + CL_r = \\frac{Q_h \\cdot f_u \\cdot CL_{int}}{Q_h + f_u \\cdot CL_{int}} + f_u \\cdot GFR\n$$\n最后，我们将 $CL_{tot}$ 的这个表达式代入稳态血浆浓度的方程中。\n$$\nC_{p,\\mathrm{ss}} = \\frac{R_{in}}{CL_{tot}} = \\frac{R_{in}}{\\frac{Q_h \\cdot f_u \\cdot CL_{int}}{Q_h + f_u \\cdot CL_{int}} + f_u \\cdot GFR}\n$$\n这个 $C_{p,\\mathrm{ss}}$ 的表达式仅用指定的参数表示：$R_{in}$、$f_u$、$CL_{int}$、$GFR$ 和 $Q_h$。题目描述中提供的其他参数，如器官容积（$V_p$、$V_h$、$V_k$、$V_m$）和其他器官血流量（$Q_k$、$Q_m$），会影响药物浓度的时间进程，但不会影响最终的稳态值本身。",
            "answer": "$$\n\\boxed{\\frac{R_{in}}{\\frac{Q_h \\cdot f_u \\cdot CL_{int}}{Q_h + f_u \\cdot CL_{int}} + f_u \\cdot GFR}}\n$$"
        },
        {
            "introduction": "在掌握了稳态模型后，我们将进入更真实、更复杂的动态世界。现实世界中的药理学过程，尤其是药物-药物相互作用（DDI），往往是时间依赖性的。本练习将要求你构建一个定量系统药理学（QSP）模型，以模拟一种抑制剂如何随时间动态地灭活代谢酶，并预测这对“受害”药物药代动力学的影响。这是一项在药物开发中至关重要的实用技能，它展示了如何运用PBPK/QSP模型进行前瞻性预测。",
            "id": "3338346",
            "problem": "开发一个程序，用于计算当一种经历肝清除的受害药物与一种时间依赖性酶抑制剂联合给药时，其曲线下面积比值（AUC比值），并评估其对酶降解速率常数和抑制剂效价参数的敏感性。该建模任务必须基于质量平衡的基本原理以及适用于基于生理的药代动力学（PBPK）和定量系统药理学（QSP）建模的清除率定义。\n\n使用单室药代动力学模型对抑制剂进行建模，该模型具有一级吸收和线性消除。抑制剂以固定间隔重复给药，以接近动态稳态。血浆中未结合的抑制剂浓度与肝酶结合并使其失活，遵循一个周转模型，该模型包括活性酶池的零级合成和一级降解，以及一个可饱和的失活项。活性酶分数会随时间调整受害药物的肝脏内源性清除率。在重复给予抑制剂后，受害药物以单次静脉推注的方式给药，其血浆浓度遵循一个单室模型，该模型的时变消除由充分搅拌肝模型确定。AUC比值定义为存在抑制剂时受害药物的AUC与不存在抑制剂时其AUC的比值。最终的AUC比值表示为一个无量纲的十进制数。\n\n使用以下基本定义，不引入任何快捷公式：\n- 设 $A_{\\mathrm{gut}}(t)$ 为吸收室（肠道）中抑制剂的量，$A_{\\mathrm{c}}(t)$ 为中央室中抑制剂的量，$C_{\\mathrm{inh}}(t) = A_{\\mathrm{c}}(t)/V_{\\mathrm{inh}}$ 为抑制剂的血浆浓度，其中 $V_{\\mathrm{inh}}$ 是抑制剂的分布容积。抑制剂具有一级吸收速率常数 $k_a$ 和线性系统清除率 $\\mathrm{CL}_{\\mathrm{inh}}$。\n- 设 $I_u(t) = f_{u,\\mathrm{inh}}\\,C_{\\mathrm{inh}}(t)$ 为未结合的抑制剂浓度，其中 $f_{u,\\mathrm{inh}}$ 是血浆中的未结合分数。\n- 设 $E(t)$ 为活性酶分数，经缩放以使基线时 $E(0)=1$。酶遵循由合成和降解控制的周转过程，并被抑制剂通过一个由 $k_{\\mathrm{inact}}$ 和 $K_I$ 参数化的可饱和项失活。\n- 设受害药物的量为 $A_{\\mathrm{vic}}(t)$，其血浆浓度为 $C_{\\mathrm{vic}}(t)=A_{\\mathrm{vic}}(t)/V_{\\mathrm{vic}}$，其中 $V_{\\mathrm{vic}}$ 是受害药物的分布容积。受害药物在充分搅拌肝模型下经历由肝清除驱动的消除，其中肝血流量为 $Q_h$，血液未结合分数为 $f_{u,B}$，时变内源性清除率为 $\\mathrm{CL}_{\\mathrm{int}}(t) = \\mathrm{CL}_{\\mathrm{int},0}\\,E(t)$，其中 $\\mathrm{CL}_{\\mathrm{int},0}$ 是基线内源性清除率。\n- 根据充分搅拌模型，在时间 $t$ 的肝清除率为 $\\mathrm{CL}_h(t) = Q_h\\,\\dfrac{f_{u,B}\\,\\mathrm{CL}_{\\mathrm{int}}(t)}{Q_h + f_{u,B}\\,\\mathrm{CL}_{\\mathrm{int}}(t)}$。\n- 根据定义，在时间范围 $[t_0,t_1]$ 内的 AUC 等于 $\\displaystyle \\int_{t_0}^{t_1} C_{\\mathrm{vic}}(t)\\,dt$。在对照条件（无抑制剂）下，酶活性保持在 $E(t)\\equiv 1$，且 $\\mathrm{CL}_h$ 为常数；在抑制条件下，$E(t)$ 会响应抑制剂的暴露而动态演变。\n\n根据以上原理推导控制性常微分方程：\n- 对于在离散口服给药间隔之间的抑制剂：$dA_{\\mathrm{gut}}/dt = -k_a\\,A_{\\mathrm{gut}}$，$dA_{\\mathrm{c}}/dt = k_a\\,A_{\\mathrm{gut}} - \\left(\\mathrm{CL}_{\\mathrm{inh}}/V_{\\mathrm{inh}}\\right)A_{\\mathrm{c}}$。在每个计划的口服给药时间点，瞬时将 $A_{\\mathrm{gut}}$ 增加抑制剂的给药剂量。\n- 对于酶：$dE/dt = k_{\\mathrm{deg}}\\,(1 - E) - k_{\\mathrm{inact}}\\,\\dfrac{I_u(t)}{K_I + I_u(t)}\\,E$，其中 $k_{\\mathrm{deg}}$ 是一级酶降解速率常数，在 $E(0)=1$ 的归一化条件下，$k_{\\mathrm{deg}}$ 等于合成速率常数。\n- 对于在指定时间点静脉推注后的受害药物：$dA_{\\mathrm{vic}}/dt = -\\left(\\mathrm{CL}_h(t)/V_{\\mathrm{vic}}\\right)\\,A_{\\mathrm{vic}}$，其中 $A_{\\mathrm{vic}}$ 的初始跃升量等于受害药物的剂量。定义一个辅助状态 $AUC(t)$，在受害药物给药后满足 $d\\,AUC/dt = C_{\\mathrm{vic}}(t)$，给药前为零。\n\n所有时间单位必须为小时，所有清除率单位为升/小时，所有容积单位为升，所有剂量单位为毫克。AUC比值是无量纲的，并且必须以十进制数报告。不出现角度。将分数输出表示为小数。\n\n对每个测试案例实施以下实验方案：\n- 从 $t=0\\,\\mathrm{h}$ 开始，每 $24\\,\\mathrm{h}$ 重复口服给药抑制剂；持续给药至受害药物给药后至少 $72\\,\\mathrm{h}$。受害药物在 $t=168\\,\\mathrm{h}$ 时以单次静脉推注的方式给药。\n- 对抑制剂和酶系统从 $t=0\\,\\mathrm{h}$ 到 $t=240\\,\\mathrm{h}$ 进行数值积分，在计划的时间点应用离散的抑制剂剂量。仅从 $t=168\\,\\mathrm{h}$ 开始包含受害药物动力学和 $AUC$ 积分器。\n- 将抑制条件下受害药物的AUC计算为从 $t=168\\,\\mathrm{h}$ 到 $t=240\\,\\mathrm{h}$ 数值累积的 $AUC$。使用基线 $E(t)\\equiv 1$ 时的时不变肝清除率，解析计算对照组AUC为 $AUC_{\\mathrm{control}} = \\mathrm{Dose}_{\\mathrm{vic}}/\\mathrm{CL}_{h,0}$，其中 $\\mathrm{CL}_{h,0} = Q_h\\,\\dfrac{f_{u,B}\\,\\mathrm{CL}_{\\mathrm{int},0}}{Q_h + f_{u,B}\\,\\mathrm{CL}_{\\mathrm{int},0}}$。然后计算AUC比值为 $AUC_{\\mathrm{inhib}}/AUC_{\\mathrm{control}}$。\n\n使用以下参数值，它们构成了测试套件。每个测试案例完全由一对 $(K_I, k_{\\mathrm{deg}})$ 指定；所有其他参数在所有案例中保持不变。未按案例明确列出的值对所有案例均为常数。\n\n所有案例的常数：\n- 抑制剂剂量和药代动力学：$\\mathrm{Dose}_{\\mathrm{inh}} = 100\\,\\mathrm{mg}$ 每 $24\\,\\mathrm{h}$，$k_a = 1.0\\,\\mathrm{h}^{-1}$，$\\mathrm{CL}_{\\mathrm{inh}} = 10.0\\,\\mathrm{L/h}$，$V_{\\mathrm{inh}} = 50.0\\,\\mathrm{L}$，$f_{u,\\mathrm{inh}} = 0.1$，$k_{\\mathrm{inact}} = 0.2\\,\\mathrm{h}^{-1}$。\n- 受害药物和肝脏参数：$\\mathrm{Dose}_{\\mathrm{vic}} = 10.0\\,\\mathrm{mg}$，$V_{\\mathrm{vic}} = 35.0\\,\\mathrm{L}$，$Q_h = 90.0\\,\\mathrm{L/h}$，$f_{u,B} = 0.6$，$\\mathrm{CL}_{\\mathrm{int},0} = 20.0\\,\\mathrm{L/h}$。\n- 受害药物给药时间：$t_{\\mathrm{vic}} = 168.0\\,\\mathrm{h}$，最终积分时间：$t_{\\mathrm{end}} = 240.0\\,\\mathrm{h}$。\n\n测试案例（每个案例形式为 $(K_I, k_{\\mathrm{deg}})$）：\n- 案例 1：$(0.5\\,\\mathrm{mg/L},\\,0.03\\,\\mathrm{h}^{-1})$。\n- 案例 2：$(0.5\\,\\mathrm{mg/L},\\,0.005\\,\\mathrm{h}^{-1})$。\n- 案例 3：$(10.0\\,\\mathrm{mg/L},\\,0.03\\,\\mathrm{h}^{-1})$。\n- 案例 4：$(0.1\\,\\mathrm{mg/L},\\,0.03\\,\\mathrm{h}^{-1})$。\n- 案例 5：$(0.5\\,\\mathrm{mg/L},\\,0.10\\,\\mathrm{h}^{-1})$。\n\n您的程序必须：\n- 实现上述的常微分方程和给药方案。\n- 对每个测试案例，将AUC比值计算为浮点数，并四舍五入到三位小数。\n- 生成单行输出，其中包含五个测试案例的结果，格式为方括号内以逗号分隔的列表，例如 $\\left[\\mathrm{result}_1,\\mathrm{result}_2,\\mathrm{result}_3,\\mathrm{result}_4,\\mathrm{result}_5\\right]$。\n\n您的程序必须是自包含的，不需要用户输入，并严格遵守所描述的数值方案和单位。输出必须严格为指定格式的一行，不得包含任何额外的字符或文本。",
            "solution": "该问题要求开发一个计算模型，以模拟涉及时间依赖性酶抑制剂和受害药物的药物-药物相互作用（DDI）。该模型基于药代动力学和酶动力学的基本原理，是基于生理的药代动力学（PBPK）和定量系统药理学（QSP）方法的典型应用。问题的核心是求解一个耦合常微分方程（ODE）组，该方程组描述了两种药物浓度和关键代谢酶活性水平随时间的演变。\n\n该系统可由一个包含五个分量的状态向量 $\\mathbf{y}(t)$ 描述：\n$1$. $A_{\\mathrm{gut}}(t)$：吸收室（例如，肠道）中抑制剂的量。\n$2$. $A_{\\mathrm{c}}(t)$：中央室（代表体循环）中抑制剂的量。\n$3$. $E(t)$：相对于基线水平的活性酶分数。\n$4$. $A_{\\mathrm{vic}}(t)$：受害药物在其中央室中的量。\n$5$. $\\mathrm{AUC}_{\\mathrm{vic}}(t)$：受害药物的浓度-时间曲线下的累积面积。\n\n此状态向量 $\\mathbf{y}(t) = [A_{\\mathrm{gut}}(t), A_{\\mathrm{c}}(t), E(t), A_{\\mathrm{vic}}(t), \\mathrm{AUC}_{\\mathrm{vic}}(t)]^T$ 的时间演化由以下根据质量平衡原理推导出的常微分方程组控制：\n\n$1$. 抑制剂吸收：\n$$\n\\frac{dA_{\\mathrm{gut}}}{dt} = -k_a \\, A_{\\mathrm{gut}}(t)\n$$\n其中 $k_a$ 是一级吸收速率常数。\n\n$2$. 抑制剂处置：\n$$\n\\frac{dA_{\\mathrm{c}}}{dt} = k_a \\, A_{\\mathrm{gut}}(t) - \\frac{\\mathrm{CL}_{\\mathrm{inh}}}{V_{\\mathrm{inh}}} \\, A_{\\mathrm{c}}(t)\n$$\n其中 $\\mathrm{CL}_{\\mathrm{inh}}$ 是抑制剂的系统清除率，$V_{\\mathrm{inh}}$ 是其分布容积。抑制剂的血浆浓度为 $C_{\\mathrm{inh}}(t) = A_{\\mathrm{c}}(t) / V_{\\mathrm{inh}}$。\n\n$3$. 酶动力学：\n$$\n\\frac{dE}{dt} = k_{\\mathrm{deg}}(1 - E(t)) - k_{\\mathrm{inact}} \\frac{I_u(t)}{K_I + I_u(t)} E(t)\n$$\n该方程模拟酶的周转，其合成速率为零级（在基线稳态酶分数为 $E(0)=1$ 时归一化为 $k_{\\mathrm{deg}}$），降解速率为一级（速率常数为 $k_{\\mathrm{deg}}$）。第二项代表未结合抑制剂的基于机制的失活，其中 $I_u(t) = f_{u,\\mathrm{inh}} C_{\\mathrm{inh}}(t)$ 是未结合的抑制剂浓度，$k_{\\mathrm{inact}}$ 是最大失活速率常数，$K_I$ 是产生半最大失活效应的抑制剂浓度。\n\n$4$. 受害药物消除：\n受害药物动力学仅在时间 $t \\ge t_{\\mathrm{vic}}$（受害药物给药时间）时激活。对于 $t  t_{\\mathrm{vic}}$，$\\frac{dA_{\\mathrm{vic}}}{dt} = 0$。对于 $t \\ge t_{\\mathrm{vic}}$：\n$$\n\\frac{dA_{\\mathrm{vic}}}{dt} = -\\frac{\\mathrm{CL}_h(t)}{V_{\\mathrm{vic}}} A_{\\mathrm{vic}}(t)\n$$\n此处，$V_{\\mathrm{vic}}$ 是受害药物的分布容积。由于酶的失活，肝清除率 $\\mathrm{CL}_h(t)$ 是时变的。根据充分搅拌肝模型，其由以下公式给出：\n$$\n\\mathrm{CL}_h(t) = Q_h \\frac{f_{u,B} \\, \\mathrm{CL}_{\\mathrm{int}}(t)}{Q_h + f_{u,B} \\, \\mathrm{CL}_{\\mathrm{int}}(t)}\n$$\n其中 $Q_h$ 是肝血流量，$f_{u,B}$ 是受害药物在血液中的未结合分数，而 $\\mathrm{CL}_{\\mathrm{int}}(t) = \\mathrm{CL}_{\\mathrm{int},0} E(t)$ 是时变内源性清除率，$\\mathrm{CL}_{\\mathrm{int},0}$ 是基线内源性清除率。\n\n$5$. 受害药物AUC累积：\n使用一个辅助状态来计算AUC。对于 $t  t_{\\mathrm{vic}}$，$\\frac{d\\mathrm{AUC}_{\\mathrm{vic}}}{dt} = 0$。对于 $t \\ge t_{\\mathrm{vic}}$：\n$$\n\\frac{d\\mathrm{AUC}_{\\mathrm{vic}}}{dt} = C_{\\mathrm{vic}}(t) = \\frac{A_{\\mathrm{vic}}(t)}{V_{\\mathrm{vic}}}\n$$\n\n模拟方案涉及离散的给药事件。这些事件通过将总积分区间 $[0, 240]\\,\\mathrm{h}$ 在每个事件（抑制剂给药和单次受害药物给药）的时间点进行分段来处理。在每个分段上，使用前一个分段的最终状态作为下一个分段的初始条件，对常微分方程组进行数值求解。在每个相关分段的开始，状态变量被瞬时更新以反映剂量：\n- 在每个抑制剂给药时间（$t=0, 24, 48, \\ldots, 216\\,\\mathrm{h}$），$A_{\\mathrm{gut}}(t)$ 增加 $\\mathrm{Dose}_{\\mathrm{inh}} = 100\\,\\mathrm{mg}$。\n- 在受害药物给药时间（$t_{\\mathrm{vic}}=168\\,\\mathrm{h}$），$A_{\\mathrm{vic}}(t)$ 增加 $\\mathrm{Dose}_{\\mathrm{vic}} = 10\\,\\mathrm{mg}$。\n\n在 $t=0$ 时的初始条件是 $A_{\\mathrm{gut}}(0)=0$, $A_{\\mathrm{c}}(0)=0$, $E(0)=1$, $A_{\\mathrm{vic}}(0)=0$, 和 $\\mathrm{AUC}_{\\mathrm{vic}}(0)=0$。首次抑制剂剂量在 $t=0$ 时立即应用。\n\n在 $t=0$ 到 $t=240\\,\\mathrm{h}$ 的模拟之后，按规定计算AUC比值。\n抑制条件下的AUC，即 $\\mathrm{AUC}_{\\mathrm{inhib}}$，是模拟结束时（$t=240\\,\\mathrm{h}$）状态变量 $\\mathrm{AUC}_{\\mathrm{vic}}(t)$ 的值。这代表了数值积分的部分AUC，即 $\\int_{168\\,\\mathrm{h}}^{240\\,\\mathrm{h}} C_{\\mathrm{vic,inhib}}(t) \\, dt$。\n\n对照条件下（无抑制剂）的AUC，即 $\\mathrm{AUC}_{\\mathrm{control}}$，是针对从给药时间到无穷大的总暴露量进行解析计算的。在这种情况下，$E(t) \\equiv 1$，因此肝清除率是一个常数 $\\mathrm{CL}_{h,0}$：\n$$\n\\mathrm{CL}_{h,0} = Q_h \\frac{f_{u,B} \\, \\mathrm{CL}_{\\mathrm{int},0}}{Q_h + f_{u,B} \\, \\mathrm{CL}_{\\mathrm{int},0}} = 90.0 \\frac{0.6 \\times 20.0}{90.0 + 0.6 \\times 20.0} = \\frac{1080}{102} \\approx 10.588\\,\\mathrm{L/h}\n$$\n单次静脉推注剂量的总AUC由下式给出：\n$$\n\\mathrm{AUC}_{\\mathrm{control}} = \\frac{\\mathrm{Dose}_{\\mathrm{vic}}}{\\mathrm{CL}_{h,0}} = \\frac{10.0\\,\\mathrm{mg}}{10.588\\,\\mathrm{L/h}} \\approx 0.944\\,\\mathrm{mg \\cdot h/L}\n$$\n最终的AUC比值则计算为 $\\mathrm{AUC}_{\\mathrm{ratio}} = \\mathrm{AUC}_{\\mathrm{inhib}} / \\mathrm{AUC}_{\\mathrm{control}}$。\n\n该实现利用了 Python 的 `scipy.integrate.solve_ivp` 函数对每个测试案例进行数值积分，每个案例由一对特定的 $(K_I, k_{\\mathrm{deg}})$ 值定义，同时保持所有其他参数不变。每个案例的结果按要求四舍五入到三位小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Main function to run the PBPK/QSP simulation for all test cases and print results.\n    \"\"\"\n    # Define constant parameters for all cases\n    const_params = {\n        'Dose_inh': 100.0,      # mg\n        'k_a': 1.0,            # h^-1\n        'CL_inh': 10.0,        # L/h\n        'V_inh': 50.0,         # L\n        'f_u_inh': 0.1,        # dimensionless\n        'k_inact': 0.2,        # h^-1\n        'Dose_vic': 10.0,      # mg\n        'V_vic': 35.0,         # L\n        'Q_h': 90.0,           # L/h\n        'f_u_B': 0.6,          # dimensionless\n        'CL_int_0': 20.0,      # L/h\n        't_vic': 168.0,        # h\n        't_end': 240.0,        # h\n        'tau_inh': 24.0,       # h\n    }\n\n    # Test cases defined by (K_I, k_deg)\n    test_cases = [\n        # (K_I in mg/L, k_deg in h^-1)\n        (0.5, 0.03),\n        (0.5, 0.005),\n        (10.0, 0.03),\n        (0.1, 0.03),\n        (0.5, 0.10),\n    ]\n\n    def run_simulation(K_I, k_deg, params):\n        \"\"\"\n        Runs a single simulation for a given set of parameters.\n        \"\"\"\n        # --- System of ODEs ---\n        # y[0]: A_gut (inhibitor amount in gut)\n        # y[1]: A_c (inhibitor amount in central compartment)\n        # y[2]: E (active enzyme fraction)\n        # y[3]: A_vic (victim drug amount)\n        # y[4]: AUC_vic (victim drug AUC)\n        def dydt(t, y, p):\n            A_gut, A_c, E, A_vic, AUC_vic = y\n            \n            # Inhibitor PK\n            dA_gut_dt = -p['k_a'] * A_gut\n            C_inh = A_c / p['V_inh']\n            dA_c_dt = p['k_a'] * A_gut - (p['CL_inh'] / p['V_inh']) * A_c\n            \n            # Enzyme dynamics\n            I_u = p['f_u_inh'] * C_inh\n            # To prevent potential division by zero if K_I is very small, though not in test cases\n            if K_I + I_u > 0:\n                inactivation_term = p['k_inact'] * (I_u / (K_I + I_u)) * E\n            else:\n                inactivation_term = 0.0\n            dE_dt = k_deg * (1 - E) - inactivation_term\n\n            # Victim drug PK (active only after dosing)\n            if t >= p['t_vic']:\n                CL_int_t = p['CL_int_0'] * E\n                # Well-stirred liver model\n                CL_h_t = p['Q_h'] * (p['f_u_B'] * CL_int_t) / (p['Q_h'] + p['f_u_B'] * CL_int_t)\n                dA_vic_dt = -(CL_h_t / p['V_vic']) * A_vic\n                dAUC_vic_dt = A_vic / p['V_vic']\n            else:\n                dA_vic_dt = 0.0\n                dAUC_vic_dt = 0.0\n                \n            return [dA_gut_dt, dA_c_dt, dE_dt, dA_vic_dt, dAUC_vic_dt]\n\n        # --- Simulation setup ---\n        y0 = np.array([0.0, 0.0, 1.0, 0.0, 0.0])\n        \n        # Define simulation time points, including dosing events\n        inhibitor_dose_times = np.arange(0, params['t_end'], params['tau_inh'])\n        event_times = sorted(list(set(inhibitor_dose_times).union({0.0, params['t_vic'], params['t_end']})))\n        \n        current_y = y0.copy()\n        \n        # --- Run simulation segment by segment ---\n        for i in range(len(event_times) - 1):\n            t_start = event_times[i]\n            t_stop = event_times[i+1]\n            \n            # Apply doses at the beginning of the interval\n            if t_start in inhibitor_dose_times:\n                current_y[0] += params['Dose_inh']\n            if t_start == params['t_vic']:\n                current_y[3] += params['Dose_vic']\n\n            # Integrate over the segment\n            sol = solve_ivp(\n                fun=lambda t, y: dydt(t, y, params),\n                t_span=[t_start, t_stop],\n                y0=current_y,\n                method='RK45',\n                dense_output=True,\n                rtol=1e-6,\n                atol=1e-9\n            )\n            current_y = sol.y[:, -1]\n\n        AUC_inhib = current_y[4]\n        \n        # --- Calculate control AUC and ratio ---\n        CL_h_0 = params['Q_h'] * (params['f_u_B'] * params['CL_int_0']) / (params['Q_h'] + params['f_u_B'] * params['CL_int_0'])\n        AUC_control = params['Dose_vic'] / CL_h_0\n        \n        AUC_ratio = AUC_inhib / AUC_control\n        \n        return round(AUC_ratio, 3)\n\n    results = []\n    for ki, kdeg in test_cases:\n        result = run_simulation(ki, kdeg, const_params)\n        results.append(result)\n        \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "一个模型的实用性最终取决于其参数是否能通过实验数据来确定。前两个练习假设参数已知，而本练习将解决“参数从何而来”这一关键问题。我们将探索一种强大的统计方法——贝叶斯推断，来从模拟的实验数据中估计模型的关键参数。通过完成这项练习，你将学习如何将抽象的PBPK/PD模型与具体的实验测量联系起来，完成从理论建模到数据分析的闭环。",
            "id": "3338354",
            "problem": "考虑一个简约的基于生理学的药代动力学 (PBPK) 和定量系统药理学 (QSP) 模型，该模型将一个双室静脉推注药代动力学系统与一个下游抑制性转换药效学生物标志物联系起来。质量平衡常微分方程基于质量守恒和室间的线性转运动力学。设中央室中的药物量为 $A_{c}(t)$ (单位 $\\mathrm{mg}$)，外周室中的药物量为 $A_{p}(t)$ (单位 $\\mathrm{mg}$)，生物标志物水平为 $R(t)$ (无量纲标度，归一化到基线值 $1$)。血浆浓度为 $C(t) = A_{c}(t)/V_{c}$ (单位 $\\mathrm{mg/L}$)，其中 $V_{c}$ 是中央分布容积 (单位 $\\mathrm{L}$)。参数包括清除率 $CL$ (单位 $\\mathrm{L/h}$)、室间清除率 $Q$ (单位 $\\mathrm{L/h}$)、外周容积 $V_{p}$ (单位 $\\mathrm{L}$) 以及半数最大抑制浓度 $EC_{50}$ (单位 $\\mathrm{mg/L}$)。抑制性转换模型具有零级生成速率 $k_{\\mathrm{in}}$ (单位 $\\mathrm{1/h}$) 和一级降解速率 $k_{\\mathrm{out}}$ (单位 $\\mathrm{1/h}$)，其中 $k_{\\mathrm{in}} = k_{\\mathrm{out}}$ 以确保给药前基线 $R(0) = 1$。药物效应通过抑制函数 $I(C) = \\frac{C}{EC_{50} + C}$ 建模，最大效应固定为 $1$。在 $t = 0$ 时给予静脉推注剂量 $D$ (单位 $\\mathrm{mg}$)，因此 $A_{c}(0) = D$, $A_{p}(0) = 0$, 且 $R(0) = 1$。模型为\n$$\n\\frac{dA_{c}}{dt} = -\\left(\\frac{CL}{V_{c}} + \\frac{Q}{V_{c}}\\right) A_{c} + \\frac{Q}{V_{p}} A_{p}, \\quad\n\\frac{dA_{p}}{dt} = \\frac{Q}{V_{c}} A_{c} - \\frac{Q}{V_{p}} A_{p}, \\quad\n\\frac{dR}{dt} = k_{\\mathrm{in}}\\left(1 - \\frac{C}{EC_{50} + C}\\right) - k_{\\mathrm{out}} R.\n$$\n假设观测到的血浆浓度 $y^{C}_{i}$ (在时间 $t^{C}_{i}$) 和生物标志物水平 $y^{R}_{j}$ (在时间 $t^{R}_{j}$) 存在加性独立高斯测量噪声，其标准差 $\\sigma_{C}$ (单位 $\\mathrm{mg/L}$) 和 $\\sigma_{R}$ (无量纲) 已知：\n$$\ny^{C}_{i} = C(t^{C}_{i}) + \\varepsilon^{C}_{i}, \\quad \\varepsilon^{C}_{i} \\sim \\mathcal{N}(0,\\sigma_{C}^{2}), \\qquad\ny^{R}_{j} = R(t^{R}_{j}) + \\varepsilon^{R}_{j}, \\quad \\varepsilon^{R}_{j} \\sim \\mathcal{N}(0,\\sigma_{R}^{2}).\n$$\n我们寻求对未知参数向量 $\\theta = (CL, V_{c}, EC_{50})$ 进行贝叶斯推断，其先验为独立的对数正态分布，具体指定为自然对数上的高斯先验 $\\log \\theta_{k} \\sim \\mathcal{N}(\\mu_{k}, \\tau_{k}^{2})$，其中 $(\\mu_{k},\\tau_{k})$ 已给定。室间清除率 $Q$、外周容积 $V_{p}$、转换速率 $k_{\\mathrm{in}}$ 和 $k_{\\mathrm{out}}$、剂量 $D$ 以及测量噪声标度 $(\\sigma_{C},\\sigma_{R})$ 均为已知常数。使用贝叶斯定理，结合已定义的似然和先验，构建 $\\log\\theta$ 的对数后验，并通过数值优化计算最大后验估计。然后，根据最大后验估计，计算在 $t = 24\\,\\mathrm{h}$ 时的预测生物标志物 $R(t)$。\n\n您的任务是实现一个程序，对下方的每个测试用例，数值求解耦合常微分方程，评估高斯对数似然，在对数参数空间中加入高斯对数先验，并找到最大值。数值解必须遵循给定的单位和初始条件。最终输出必须是：\n- $CL$ 的后验众数（最大后验）估计值，单位 $\\mathrm{L/h}$。\n- 模型预测的生物标志物水平 $R(24)$（无量纲）。\n\n将 $CL$ (单位 $\\mathrm{L/h}$) 和 $R(24)$ 表示为浮点数，并四舍五入到三位小数。最终程序必须输出一行，其中包含所有结果，格式为方括号内的逗号分隔列表，顺序如下方测试套件中所指定。\n\n使用的基本假设和定义：\n- 在充分搅拌的室中进行质量守恒，具有线性的交换和清除。\n- 在 $t = 0$ 时进行静脉推注给药，意味着 $A_{c}(0) = D$ 且 $A_{p}(0) = 0$。\n- 血浆浓度为 $C(t) = A_{c}(t)/V_{c}$。\n- 抑制效应函数为 $I(C) = \\frac{C}{EC_{50} + C}$，最大效应固定为 $1$。\n- 生物标志物转换的基线为 $R(0) = \\frac{k_{\\mathrm{in}}}{k_{\\mathrm{out}}} = 1$，通过 $k_{\\mathrm{in}} = k_{\\mathrm{out}}$ 强制实现。\n- 具有已知标准差的独立高斯测量误差。\n- 在 $\\log \\theta$ 上的独立高斯先验。\n\n测试套件参数、数据及要求的输出顺序：\n所有用例的通用已知常数：$D = 100\\,\\mathrm{mg}$，$Q = 5\\,\\mathrm{L/h}$，$V_{p} = 20\\,\\mathrm{L}$，$k_{\\mathrm{out}} = 0.2\\,\\mathrm{h^{-1}}$，$k_{\\mathrm{in}} = 0.2\\,\\mathrm{h^{-1}}$。观测时间为 $t^{C} = [\\,0.25,\\,0.5,\\,1,\\,2,\\,4,\\,8\\,]\\,\\mathrm{h}$ 和 $t^{R} = [\\,0.5,\\,1,\\,2,\\,4,\\,8,\\,24\\,]\\,\\mathrm{h}$。\n\n- 用例 1（理想情况）：\n  - 浓度 $y^{C}$ (单位 $\\mathrm{mg/L}$)：$[\\,8.20,\\,6.90,\\,5.00,\\,3.20,\\,1.80,\\,0.80\\,]$。\n  - 生物标志物 $y^{R}$：$[\\,0.90,\\,0.80,\\,0.65,\\,0.50,\\,0.40,\\,0.95\\,]$。\n  - 噪声标度：$\\sigma_{C} = 0.2\\,\\mathrm{mg/L}$，$\\sigma_{R} = 0.05$。\n  - $\\log \\theta$ 的先验：$\\mu = [\\,\\log(3),\\,\\log(10),\\,\\log(1)\\,] = [\\,1.098612289,\\,2.302585093,\\,0.0\\,]$，$\\tau = [\\,0.3,\\,0.3,\\,0.5\\,]$。\n\n- 用例 2（噪声更大，先验更弱）：\n  - 浓度 $y^{C}$ (单位 $\\mathrm{mg/L}$)：$[\\,4.60,\\,4.20,\\,3.60,\\,3.00,\\,2.20,\\,1.40\\,]$。\n  - 生物标志物 $y^{R}$：$[\\,0.93,\\,0.88,\\,0.80,\\,0.70,\\,0.60,\\,0.90\\,]$。\n  - 噪声标度：$\\sigma_{C} = 0.5\\,\\mathrm{mg/L}$，$\\sigma_{R} = 0.08$。\n  - $\\log \\theta$ 的先验：$\\mu = [\\,\\log(2),\\,\\log(20),\\,\\log(2)\\,] = [\\,0.693147181,\\,2.995732274,\\,0.693147181\\,]$，$\\tau = [\\,0.7,\\,0.7,\\,0.7\\,]$。\n\n- 用例 3（趋近边界，先验更紧）：\n  - 浓度 $y^{C}$ (单位 $\\mathrm{mg/L}$)：$[\\,15.00,\\,12.00,\\,8.50,\\,5.00,\\,2.50,\\,1.00\\,]$。\n  - 生物标志物 $y^{R}$：$[\\,0.85,\\,0.75,\\,0.55,\\,0.45,\\,0.35,\\,0.98\\,]$。\n  - 噪声标度：$\\sigma_{C} = 0.3\\,\\mathrm{mg/L}$，$\\sigma_{R} = 0.06$。\n  - $\\log \\theta$ 的先验：$\\mu = [\\,\\log(1.2),\\,\\log(5),\\,\\log(0.5)\\,] = [\\,0.182321557,\\,1.609437912,\\,-0.693147181\\,]$，$\\tau = [\\,0.25,\\,0.25,\\,0.4\\,]$。\n\n您的程序应生成一行输出，其中包含所有结果，格式为方括号内的逗号分隔列表，顺序如下：$[\\,CL_{1},\\,R_{1}(24),\\,CL_{2},\\,R_{2}(24),\\,CL_{3},\\,R_{3}(24)\\,]$，其中 $CL_{i}$ 的单位是 $\\mathrm{L/h}$，$R_{i}(24)$ 无量纲。所有数字必须四舍五入到三位小数。此问题不涉及角度。不需要百分比；所有比例均以小数表示。",
            "solution": "用户提供了一个针对耦合药代动力学-药效动力学 (PK-PD) 模型的明确定义的贝叶斯推断问题。该问题经确认为科学上合理、提法恰当且信息完整。\n\n任务是找到模型参数子集 $\\theta = (CL, V_{c}, EC_{50})$ 的最大后验 (MAP) 估计，然后使用此 MAP 估计来预测特定时间点的生物标志物响应。此过程将针对三个不同的测试用例执行，每个用例都有自己的数据集和先验设定。\n\n解决方案如下：\n\n**1. 模型定义**\n该模型由一个包含三个耦合常微分方程 (ODE) 的系统组成：\n$$\n\\frac{dA_{c}}{dt} = -\\left(\\frac{CL}{V_{c}} + \\frac{Q}{V_{c}}\\right) A_{c} + \\frac{Q}{V_{p}} A_{p}\n$$\n$$\n\\frac{dA_{p}}{dt} = \\frac{Q}{V_{c}} A_{c} - \\frac{Q}{V_{p}} A_{p}\n$$\n$$\n\\frac{dR}{dt} = k_{\\mathrm{in}}\\left(1 - \\frac{C}{EC_{50} + C}\\right) - k_{\\mathrm{out}} R\n$$\n其中状态变量为中央室中的药物量 $A_{c}(t)$、外周室中的药物量 $A_{p}(t)$ 以及生物标志物响应 $R(t)$。血浆浓度为 $C(t) = A_{c}(t)/V_{c}$。静脉推注剂量 $D$ 的初始条件为 $A_{c}(0) = D$、$A_{p}(0) = 0$ 和 $R(0) = 1$。待估计的参数是清除率 $CL$、中央分布容积 $V_c$ 和半数最大抑制浓度 $EC_{50}$。所有其他参数 ($Q, V_p, k_{\\mathrm{in}}, k_{\\mathrm{out}}, D$) 均为已知常数。\n\n**2. 贝叶斯框架**\n根据 Bayes 定理，给定观测数据 $y = (y^C, y^R)$ 时参数 $\\theta$ 的后验概率分布为：\n$$\np(\\theta | y) \\propto p(y | \\theta) \\cdot p(\\theta)\n$$\n其中 $p(y | \\theta)$ 是似然函数，$p(\\theta)$ 是先验分布。MAP 估计 $\\theta_{\\mathrm{MAP}}$ 是使该后验概率最大化的 $\\theta$ 值。在计算上，处理后验概率的对数更为方便和数值稳定：\n$$\n\\log p(\\theta | y) = \\log p(y | \\theta) + \\log p(\\theta) + \\text{constant}\n$$\n最大化对数后验等价于最大化后验本身。\n\n**3. 对数似然函数**\n问题指明测量误差是独立的，并服从高斯分布：\n$y^C_i \\sim \\mathcal{N}(C(t^C_i; \\theta), \\sigma_C^2)$ 且 $y^R_j \\sim \\mathcal{N}(R(t^R_j; \\theta), \\sigma_R^2)$。对数似然函数是所有观测值的对数概率密度之和：\n$$\n\\log p(y | \\theta) = \\sum_{i} \\left( -\\frac{1}{2} \\left(\\frac{y^C_i - C(t^C_i; \\theta)}{\\sigma_C}\\right)^2 \\right) + \\sum_{j} \\left( -\\frac{1}{2} \\left(\\frac{y^R_j - R(t^R_j; \\theta)}{\\sigma_R}\\right)^2 \\right) + \\text{constant}\n$$\n模型预测值 $C(t; \\theta)$ 和 $R(t; \\theta)$ 是通过使用给定的参数集 $\\theta$ 数值求解 ODE 系统得到的。\n\n**4. 对数先验函数**\n参数被转换到对数尺度，$\\hat{\\theta}_k = \\log \\theta_k$。先验被指定为这些对数转换参数上的独立高斯分布：$\\hat{\\theta}_k \\sim \\mathcal{N}(\\mu_k, \\tau_k^2)$。联合对数先验为：\n$$\n\\log p(\\theta) = \\log p(\\hat{\\theta}) = \\sum_{k=1}^{3} \\left( -\\frac{1}{2} \\left(\\frac{\\hat{\\theta}_k - \\mu_k}{\\tau_k}\\right)^2 \\right) + \\text{constant}\n$$\n\n**5. 优化目标函数**\nMAP 估计是通过最大化对数后验找到的。标准的数值优化算法旨在最小化一个函数。因此，我们定义一个目标函数 $F(\\hat{\\theta})$ 作为负的对数后验，并舍去所有常数项：\n$$\nF(\\hat{\\theta}) = \\frac{1}{2} \\sum_{i} \\left(\\frac{y^C_i - C(t^C_i; \\theta(\\hat{\\theta}))}{\\sigma_C}\\right)^2 + \\frac{1}{2} \\sum_{j} \\left(\\frac{y^R_j - R(t^R_j; \\theta(\\hat{\\theta}))}{\\sigma_R}\\right)^2 + \\frac{1}{2} \\sum_{k=1}^{3} \\left(\\frac{\\hat{\\theta}_k - \\mu_k}{\\tau_k}\\right)^2\n$$\n对数空间中的 MAP 估计 $\\hat{\\theta}_{\\mathrm{MAP}}$ 是通过最小化 $F(\\hat{\\theta})$ 找到的。原始参数空间中的 MAP 估计则是 $\\theta_{\\mathrm{MAP}} = \\exp(\\hat{\\theta}_{\\mathrm{MAP}})$。\n\n**6. 实现策略**\n该解决方案使用 Python 的 `numpy` 和 `scipy` 库实现。\n- 一个函数 `model_rhs` 定义了 ODE 系统的右侧。\n- 对每个测试用例，构建一个目标函数 `neg_log_posterior`。该函数接受一个对数转换后的参数向量 $\\hat{\\theta}$ 作为输入。\n- 在 `neg_log_posterior` 内部：\n    1. 将参数转换回其原始尺度：$\\theta = \\exp(\\hat{\\theta})$。\n    2. 使用 `scipy.integrate.solve_ivp` 和当前参数值求解 ODE 系统，以在所需的观测时间生成 $C(t)$ 和 $R(t)$ 的模型预测。使用一个鲁棒的隐式求解器 (`Radau`) 来处理潜在的刚性问题。\n    3. 使用模型预测和观测数据计算目标函数 $F(\\hat{\\theta})$ 的值。\n- 使用 `scipy.optimize.minimize` 函数（采用 `BFGS` 算法）来找到最小化 `neg_log_posterior` 的向量 $\\hat{\\theta}_{\\mathrm{MAP}}$。先验均值 $\\mu_k$ 被用作优化的初始猜测值。\n- 找到 $\\theta_{\\mathrm{MAP}} = \\exp(\\hat{\\theta}_{\\mathrm{MAP}})$ 后，使用这些最优参数最后求解一次 ODE 系统，以预测在 $t=24\\,\\mathrm{h}$ 时的生物标志物水平 $R(t)$。\n- 对每个测试用例，收集得到的 $CL$ 的 MAP 估计值和预测值 $R(24)$。\n- 最后，将所有结果格式化为三位小数，并以指定的单行格式打印。",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Main function to solve the PK/PD model fitting problem for all test cases.\n    \"\"\"\n\n    # --- Common parameters and data for all cases ---\n    common_params = {\n        'D': 100.0,      # mg\n        'Q': 5.0,        # L/h\n        'Vp': 20.0,      # L\n        'kout': 0.2,     # 1/h\n        'kin': 0.2,      # 1/h\n        't_C': [0.25, 0.5, 1.0, 2.0, 4.0, 8.0],  # h\n        't_R': [0.5, 1.0, 2.0, 4.0, 8.0, 24.0]  # h\n    }\n\n    # --- Test suite definition ---\n    test_cases = [\n        {  # Case 1\n            \"data_C\": (np.array([8.20, 6.90, 5.00, 3.20, 1.80, 0.80]), 0.2), # (y_C, sigma_C)\n            \"data_R\": (np.array([0.90, 0.80, 0.65, 0.50, 0.40, 0.95]), 0.05),# (y_R, sigma_R)\n            \"priors\": (np.log([3.0, 10.0, 1.0]), np.array([0.3, 0.3, 0.5])) # (mu, tau)\n        },\n        {  # Case 2\n            \"data_C\": (np.array([4.60, 4.20, 3.60, 3.00, 2.20, 1.40]), 0.5),\n            \"data_R\": (np.array([0.93, 0.88, 0.80, 0.70, 0.60, 0.90]), 0.08),\n            \"priors\": (np.log([2.0, 20.0, 2.0]), np.array([0.7, 0.7, 0.7]))\n        },\n        {  # Case 3\n            \"data_C\": (np.array([15.00, 12.00, 8.50, 5.00, 2.50, 1.00]), 0.3),\n            \"data_R\": (np.array([0.85, 0.75, 0.55, 0.45, 0.35, 0.98]), 0.06),\n            \"priors\": (np.log([1.2, 5.0, 0.5]), np.array([0.25, 0.25, 0.4]))\n        }\n    ]\n\n    # --- ODE model definition ---\n    def model_rhs(t, y, CL, Vc, EC50, Q, Vp, kin, kout):\n        Ac, Ap, R = y\n        if Vc == 0: return [np.inf, np.inf, np.inf]\n        \n        C = Ac / Vc\n        inhibition = C / (EC50 + C)\n        \n        dAc_dt = -(CL / Vc + Q / Vc) * Ac + (Q / Vp) * Ap\n        dAp_dt = (Q / Vc) * Ac - (Q / Vp) * Ap\n        dR_dt = kin * (1 - inhibition) - kout * R\n        \n        return [dAc_dt, dAp_dt, dR_dt]\n\n    # --- Core processing function for a single case ---\n    def process_case(case_data):\n        # Unpack data for the case\n        y_C_obs, sigma_C = case_data['data_C']\n        y_R_obs, sigma_R = case_data['data_R']\n        prior_mu, prior_tau = case_data['priors']\n        \n        # Unpack common parameters\n        D, Q, Vp, kin, kout, t_C, t_R = common_params.values()\n        y0 = [D, 0.0, 1.0]\n\n        # Prepare for ODE solving\n        t_eval_unique = sorted(list(set(t_C) | set(t_R)))\n        t_span = (0, max(t_eval_unique))\n        t_map_C = [t_eval_unique.index(t) for t in t_C]\n        t_map_R = [t_eval_unique.index(t) for t in t_R]\n\n        # Objective function: negative log-posterior\n        def neg_log_posterior(log_params):\n            CL, Vc, EC50 = np.exp(log_params)\n\n            if not (CL > 0 and Vc > 0 and EC50 > 0): return np.inf\n\n            sol = solve_ivp(\n                model_rhs, t_span, y0,\n                args=(CL, Vc, EC50, Q, Vp, kin, kout),\n                t_eval=t_eval_unique, method='Radau', dense_output=False\n            )\n            \n            if sol.status != 0: return np.inf\n\n            C_pred_all = sol.y[0] / Vc\n            R_pred_all = sol.y[2]\n            \n            C_pred = C_pred_all[t_map_C]\n            R_pred = R_pred_all[t_map_R]\n            \n            log_lik_term = np.sum(((y_C_obs - C_pred) / sigma_C)**2) + \\\n                           np.sum(((y_R_obs - R_pred) / sigma_R)**2)\n            log_prior_term = np.sum(((log_params - prior_mu) / prior_tau)**2)\n            \n            return 0.5 * (log_lik_term + log_prior_term)\n\n        # Optimization to find MAP\n        opt_result = minimize(neg_log_posterior, prior_mu, method='BFGS')\n        \n        # Extract MAP estimates and predict R(24)\n        CL_map, Vc_map, EC50_map = np.exp(opt_result.x)\n        \n        final_sol = solve_ivp(\n            model_rhs, (0, 24), y0,\n            args=(CL_map, Vc_map, EC50_map, Q, Vp, kin, kout),\n            t_eval=[24], method='Radau', dense_output=False\n        )\n        R_24 = final_sol.y[2, 0]\n        \n        return CL_map, R_24\n\n    # --- Loop through cases and collect results ---\n    all_results = []\n    for case in test_cases:\n        cl_map, r_24 = process_case(case)\n        all_results.append(f\"{cl_map:.3f}\")\n        all_results.append(f\"{r_24:.3f}\")\n\n    # --- Print final output in the required format ---\n    print(f\"[{','.join(all_results)}]\")\n\n# Execute the solver\nsolve()\n```"
        }
    ]
}