{
    "hands_on_practices": [
        {
            "introduction": "在神经退行性疾病中，细胞维持蛋白质稳态的能力至关重要。本练习将引导您使用经典的米氏动力学（Michaelis-Menten kinetics）来构建一个蛋白质聚集物的产生与清除模型 。通过这个练习，您将亲手推导出系统过载的临界条件，从而深入理解蛋白质清除机制饱和对于疾病恶化的关键作用，并量化评估潜在的治疗干预效果。",
            "id": "3333651",
            "problem": "考虑一个与阿尔茨海默病 (AD) 和帕金森病 (PD) 相关的神经元中蛋白质聚集体质量浓度的粗粒度、单组分模型。设聚集体质量浓度为 $A(t)$，其由于上游的蛋白质稳态失衡而以恒定的合成通量 $s$（单位为浓度/时间）产生。聚集体由一种蛋白质稳态维持机制清除，该机制被建模为一种酶 $E$，它与聚集体结合形成复合物 $AE$ 并催化性地将其移除。微观反应式为\n$$A + E \\xrightleftharpoons[k_{\\mathrm{off}}]{k_{\\mathrm{on}}} AE \\xrightarrow{k_{\\mathrm{cat}}} \\varnothing + E,$$\n其中 $k_{\\mathrm{on}}$ 是结合速率， $k_{\\mathrm{off}}$ 是解离速率， $k_{\\mathrm{cat}}$ 是催化转换速率， $E_T$ 是守恒的总清除能力，因此守恒定律 $E_T = [E] + [AE]$ 成立。假设对复合物 $AE$ 的准稳态近似是有效的。聚集体的质量平衡方程为\n$$\\frac{dA}{dt} = s - v(A),$$\n其中 $v(A)$ 是由上述反应式所隐含的清除速率。\n\n从质量作用定律描述和准稳态近似出发，推导 $v(A)$ 的有效函数形式，以及由 $\\frac{dA}{dt} = 0$ 定义的有限稳态 $A^{\\ast}$ 存在的条件。确定临界合成速率 $s^{\\ast}$，在该速率下有限稳态 $A^{\\ast}$ 因 $A^{\\ast}$ 发散而不再存在（过载阈值）。然后，假设一项药理学干预通过将总酶库从 $E_T$ 增加到 $\\rho E_T$ 来提高可用的清除能力，其中 $\\rho > 1$ 且 $k_{\\mathrm{cat}}$、$k_{\\mathrm{on}}$ 或 $k_{\\mathrm{off}}$ 没有变化。计算新的临界合成速率 $s^{\\ast}_{\\mathrm{drug}}$ 和过载阈值的变化量 $\\Delta s^{\\ast} = s^{\\ast}_{\\mathrm{drug}} - s^{\\ast}$。\n\n以 $k_{\\mathrm{cat}}$、$E_T$ 和 $\\rho$ 的闭式解析表达式表示您的最终答案。如果您引入中间常数，它们可以出现在推导过程中，但决不能出现在所要求的最终表达式中。以与 $s$ 相同的单位给出 $s^{\\ast}$、$s^{\\ast}_{\\mathrm{drug}}$ 和 $\\Delta s^{\\ast}$ 的结果。不需要进行数值计算。",
            "solution": "首先根据所需标准对问题进行验证。\n\n### 问题验证\n\n**第一步：提取已知条件**\n- 聚集体质量浓度：$A(t)$\n- 恒定合成通量：$s$\n- 反应式：$A + E \\xrightleftharpoons[k_{\\mathrm{off}}]{k_{\\mathrm{on}}} AE \\xrightarrow{k_{\\mathrm{cat}}} \\varnothing + E$\n- 速率常数：结合速率 $k_{\\mathrm{on}}$，解离速率 $k_{\\mathrm{off}}$，催化转换速率 $k_{\\mathrm{cat}}$\n- 总清除能力（守恒）：$E_T$\n- 守恒定律：$E_T = [E] + [AE]$\n- 假设：对复合物 $AE$ 的准稳态近似 (QSSA) 有效。\n- 聚集体的质量平衡方程：$\\frac{dA}{dt} = s - v(A)$，其中 $v(A)$ 是清除速率。\n- 稳态：$A^{\\ast}$，定义为 $\\frac{dA}{dt} = 0$。\n- 临界合成速率：$s^{\\ast}$，在该速率下有限稳态 $A^{\\ast}$ 发散。\n- 药理学干预：总酶库变为 $\\rho E_T$，其中 $\\rho > 1$。速率常数 $k_{\\mathrm{cat}}$、$k_{\\mathrm{on}}$ 和 $k_{\\mathrm{off}}$ 不变。\n- 要求输出：新的临界合成速率 $s^{\\ast}_{\\mathrm{drug}}$ 和过载阈值的变化量 $\\Delta s^{\\ast} = s^{\\ast}_{\\mathrm{drug}} - s^{\\ast}$，以及原始的 $s^{\\ast}$。\n\n**第二步：使用提取的已知条件进行验证**\n- **科学依据：** 该问题使用标准的 Michaelis-Menten 酶动力学描述了蛋白质聚集和清除的简化模型。这是生物化学和系统生物学中一个基础且广泛使用的框架，其应用于模拟神经退行性疾病的某些方面是一种常见且科学上有效的方法。\n- **适定性：** 问题陈述清晰。它提供了一整套反应动力学、一个控制微分方程和一个有效的简化假设 (QSSA)。其目标——推导清除速率、找到临界合成阈值以及分析干预效果——是精确的，并能导出一个唯一且有意义的解。\n- **客观性：** 问题以客观的数学语言表述，没有任何主观或非科学的主张。\n\n**第三步：结论与行动**\n该问题具有科学依据、适定性且客观。判定为**有效**。我们继续进行求解。\n\n### 解题过程\n\n解题过程分三个阶段：首先，推导清除速率 $v(A)$；其次，确定稳态条件和临界合成速率 $s^{\\ast}$；最后，计算干预后的新临界速率 $s^{\\ast}_{\\mathrm{drug}}$ 和变化量 $\\Delta s^{\\ast}$。\n\n**1. 推导清除速率 $v(A)$**\n反应式为 $A + E \\xrightleftharpoons[k_{\\mathrm{off}}]{k_{\\mathrm{on}}} AE \\xrightarrow{k_{\\mathrm{cat}}} \\varnothing + E$。根据质量作用定律，中间复合物浓度 $[AE]$ 的变化速率为：\n$$ \\frac{d[AE]}{dt} = k_{\\mathrm{on}}[A][E] - k_{\\mathrm{off}}[AE] - k_{\\mathrm{cat}}[AE] $$\n问题陈述中说明对 $[AE]$ 的准稳态近似 (QSSA) 是有效的。这意味着复合物 $[AE]$ 的浓度变化远慢于底物 $A$ 和产物的浓度变化，因此我们可以将其时间导数设为零：\n$$ \\frac{d[AE]}{dt} \\approx 0 $$\n由此可得：\n$$ k_{\\mathrm{on}}[A][E] = (k_{\\mathrm{off}} + k_{\\mathrm{cat}})[AE] $$\n总酶浓度 $E_T$ 是守恒的，由守恒定律 $E_T = [E] + [AE]$ 给出。我们可以将游离酶浓度表示为 $[E] = E_T - [AE]$。将此代入 QSSA 方程：\n$$ k_{\\mathrm{on}}[A](E_T - [AE]) = (k_{\\mathrm{off}} + k_{\\mathrm{cat}})[AE] $$\n我们现在求解 $[AE]$：\n$$ k_{\\mathrm{on}}[A]E_T - k_{\\mathrm{on}}[A][AE] = (k_{\\mathrm{off}} + k_{\\mathrm{cat}})[AE] $$\n$$ k_{\\mathrm{on}}[A]E_T = (k_{\\mathrm{off}} + k_{\\mathrm{cat}} + k_{\\mathrm{on}}[A])[AE] $$\n$$ [AE] = \\frac{k_{\\mathrm{on}}[A]E_T}{k_{\\mathrm{off}} + k_{\\mathrm{cat}} + k_{\\mathrm{on}}[A]} $$\n清除速率 $v(A)$ 是聚集体被移除的速率，也就是催化步骤的速率。在问题描述中，通常用 $A$ 来表示 $[A]$。\n$$ v(A) = k_{\\mathrm{cat}}[AE] = \\frac{k_{\\mathrm{cat}} k_{\\mathrm{on}} A E_T}{k_{\\mathrm{off}} + k_{\\mathrm{cat}} + k_{\\mathrm{on}} A} $$\n此表达式是标准的 Michaelis-Menten 形式。它可以写作：\n$$ v(A) = \\frac{k_{\\mathrm{cat}} E_T A}{\\left(\\frac{k_{\\mathrm{off}} + k_{\\mathrm{cat}}}{k_{\\mathrm{on}}}\\right) + A} = \\frac{V_{\\mathrm{max}} A}{K_M + A} $$\n其中 $V_{\\mathrm{max}} = k_{\\mathrm{cat}}E_T$ 是最大清除速率，而 $K_M = (k_{\\mathrm{off}} + k_{\\mathrm{cat}})/k_{\\mathrm{on}}$ 是米氏常数。\n\n**2. 稳态条件和临界合成速率 $s^{\\ast}$**\n当产生速率等于清除速率时，即 $\\frac{dA}{dt} = 0$，存在一个稳态 $A^{\\ast}$。根据质量平衡方程，这意味着：\n$$ s = v(A^{\\ast}) $$\n要使 $A^{\\ast}$ 存在一个有限的非负稳态解，合成速率 $s$ 必须是清除系统能够达到的一个值。清除速率 $v(A)$ 是一个关于 $A$ 的单调递增函数，它会饱和于其最大值 $V_{\\mathrm{max}}$。\n$$ V_{\\mathrm{max}} = \\lim_{A \\to \\infty} v(A) = \\lim_{A \\to \\infty} \\frac{k_{\\mathrm{cat}} E_T A}{K_M + A} = k_{\\mathrm{cat}} E_T $$\n如果合成速率 $s$ 超过这个最大可能清除速率 $V_{\\mathrm{max}}$，系统将过载，聚集体浓度 $A$ 将无限增长。一个稳定的有限稳态只在 $s  V_{\\mathrm{max}}$ 时存在。\n问题将临界合成速率 $s^{\\ast}$ 定义为有限稳态 $A^{\\ast}$ 因发散而不再存在的阈值。这恰好发生在合成速率等于清除系统最大容量的时候。因此，临界合成速率是：\n$$ s^{\\ast} = V_{\\mathrm{max}} = k_{\\mathrm{cat}} E_T $$\n\n**3. 药理学干预的效果**\n该干预将总酶库从 $E_T$ 增加到 $\\rho E_T$，其中 $\\rho  1$。速率常数 $k_{\\mathrm{cat}}$、$k_{\\mathrm{on}}$ 和 $k_{\\mathrm{off}}$ 不受影响。\n新的最大清除速率 $V_{\\mathrm{max, drug}}$ 由新的总酶浓度决定：\n$$ V_{\\mathrm{max, drug}} = k_{\\mathrm{cat}} (\\rho E_T) = \\rho (k_{\\mathrm{cat}} E_T) $$\n新的临界合成速率 $s^{\\ast}_{\\mathrm{drug}}$ 就是这个新的最大速率：\n$$ s^{\\ast}_{\\mathrm{drug}} = \\rho k_{\\mathrm{cat}} E_T $$\n过载阈值的变化量 $\\Delta s^{\\ast}$ 是新的和原始的临界合成速率之差：\n$$ \\Delta s^{\\ast} = s^{\\ast}_{\\mathrm{drug}} - s^{\\ast} = \\rho k_{\\mathrm{cat}} E_T - k_{\\mathrm{cat}} E_T $$\n$$ \\Delta s^{\\ast} = (\\rho - 1) k_{\\mathrm{cat}} E_T $$\n如题目所要求，$s^{\\ast}$、$s^{\\ast}_{\\mathrm{drug}}$ 和 $\\Delta s^{\\ast}$ 的最终表达式仅依赖于 $k_{\\mathrm{cat}}$、$E_T$ 和 $\\rho$。\n结果如下：\n- $s^{\\ast} = k_{\\mathrm{cat}} E_T$\n- $s^{\\ast}_{\\mathrm{drug}} = \\rho k_{\\mathrm{cat}} E_T$\n- $\\Delta s^{\\ast} = (\\rho - 1) k_{\\mathrm{cat}} E_T$\n\n这些结果在最终答案中以单行矩阵的形式呈现。",
            "answer": "$$ \\boxed{\\begin{pmatrix} k_{\\mathrm{cat}} E_T  \\rho k_{\\mathrm{cat}} E_T  (\\rho - 1) k_{\\mathrm{cat}} E_T \\end{pmatrix}} $$"
        },
        {
            "introduction": "神经退行性疾病的病理并不仅仅局限于单个细胞，而是在整个大脑的连接网络中传播。本练习将带领您在一个简化的四节点大脑连接体上，模拟病理性蛋白质“类似朊病毒”的扩散过程 。您将通过求解一个网络反应扩散模型，直观地观察到局部生长（$r$）和网络扩散（$D$）如何共同作用，决定疾病在不同脑区间的传播速度和模式。",
            "id": "3333626",
            "problem": "考虑一个简化的网络扩散-反应模型，用于描述在由四个脑区（节点）组成的小型加权连接体上，神经退行性疾病（如阿尔茨海默病和帕金森病）中错误折叠蛋白质负荷的传播。设加权邻接矩阵为对称矩阵，给定如下\n$$\nW=\\begin{bmatrix}\n0  0.8  0.2  0.0\\\\\n0.8  0  0.6  0.1\\\\\n0.2  0.6  0  0.7\\\\\n0.0  0.1  0.7  0\n\\end{bmatrix},\n$$\n并设组合图拉普拉斯算子由经过充分检验的公式定义\n$$\nL=\\operatorname{diag}(W\\mathbf{1})-W,\n$$\n其中 $\\mathbf{1}$ 表示全一向量。拉普拉斯算子 $L$ 编码了源于网络上菲克定律的扩散耦合，这是由浓度梯度驱动的扩散的离散模拟。\n\n假设节点处的错误折叠蛋白质负荷根据一个网络反应-扩散系统演化，该系统由以下方程控制，\n$$\n\\frac{d\\mathbf{u}}{dt} = -D L \\mathbf{u} + r \\,\\mathbf{u}\\left(1-\\frac{\\mathbf{u}}{K}\\right)\n$$\n其中 $D0$ 是扩散系数（单位为 $\\text{year}^{-1}$），$r\\ge 0$ 是局部增长率（单位为 $\\text{year}^{-1}$），$K0$ 是承载能力（无量纲的负荷标度），$\\mathbf{u}(t)\\in\\mathbb{R}^4$ 是负荷向量，其分量为 $u_i(t)$，对应于节点 $i=1,2,3,4$。\n\n对于早期动态，当负荷相对于承载能力很小时，通常使用核心近似 $u_i/K\\ll 1$ 来线性化逻辑斯谛反应项，得到\n$$\n\\frac{d\\mathbf{u}}{dt} \\approx \\left(-D L + r I\\right)\\mathbf{u} = A\\,\\mathbf{u}\n$$\n其中 $I$ 是单位矩阵，$A=-D L + r I$ 是一个对称的 Metzler 矩阵（非对角线元素非负）。该线性系统有矩阵指数解\n$$\n\\mathbf{u}(t) \\approx e^{A t}\\,\\mathbf{u}_0\n$$\n对于一个初始条件 $\\mathbf{u}_0$。\n\n给定节点 1 处的初始播种：$\\mathbf{u}_0 = [0.01K,\\,0,\\,0,\\,0]^\\top$。定义节点 $i$ 的波前到达时间为满足 $u_i(t)\\ge \\alpha K$ 的最小时间 $t\\ge 0$，阈值 $\\alpha=0.1$（承载能力的一个小数部分）。如果在规定的时间窗口内未达到阈值，则使用数字 $-1.0$ 报告未到达。\n\n使用的基本原理：\n- 源于网络上菲克定律的图扩散：$d\\mathbf{u}/dt=-D L \\mathbf{u}$，其中 $L=\\operatorname{diag}(W\\mathbf{1})-W$。\n- 逻辑斯谛增长的早期线性化：当 $\\mathbf{u}/K\\ll 1$ 时，$\\mathbf{u}(1-\\mathbf{u}/K)\\approx \\mathbf{u}$。\n- 线性时不变系统的矩阵指数解：$\\mathbf{u}(t)=e^{A t}\\mathbf{u}_0$。\n\n任务：\n1. 对每个测试用例，使用矩阵指数近似 $\\mathbf{u}(t) = e^{A t}\\mathbf{u}_0$（其中 $A=-D L + r I$）计算 $\\mathbf{u}(t)$。使用 $A$ 的特征分解来高效地计算多个时间点的 $e^{A t}$。\n2. 量化每个节点的波前到达时间，定义为在均匀网格上满足 $u_i(t)\\ge \\alpha K$ 的最早时间 $t$。\n3. 将所有到达时间以年为单位表示为浮点数，四舍五入到四位小数。如果在指定的最大时间内未达到阈值，则为该节点返回 $-1.0$。\n\n数值单位和约定：\n- 时间单位为年；$D$ 和 $r$ 的单位为 $\\text{year}^{-1}$；$K$ 和 $\\mathbf{u}$ 是无量纲的负荷单位（相对于 $K$）；不使用角度。\n\n使用以下测试套件，每个套件都有其自己的 $(D,r,K)$ 和最大时间：\n- 情况 1（一般传播）：$(D,r,K)=(0.15,\\,0.30,\\,1.0)$，最大时间 $T_{\\max}=25$ 年，时间步长 $\\Delta t=0.01$ 年。\n- 情况 2（无扩散边界）：$(D,r,K)=(0.00,\\,0.30,\\,1.0)$，$T_{\\max}=25$ 年，时间步长 $\\Delta t=0.01$ 年。\n- 情况 3（无增长边界）：$(D,r,K)=(0.20,\\,0.00,\\,1.0)$，$T_{\\max}=25$ 年，时间步长 $\\Delta t=0.01$ 年。\n- 情况 4（高扩散，慢增长）：$(D,r,K)=(0.50,\\,0.05,\\,1.0)$，$T_{\\max}=60$ 年，时间步长 $\\Delta t=0.01$ 年。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的列表的列表，以逗号分隔。每个内部列表包含相应测试用例中节点 $[1,2,3,4]$ 的四个到达时间（以年为单位，四舍五入到四位小数）。如果一个节点在时间窗口内没有达到阈值，则在其位置输出 $-1.0$。例如，格式必须是：\n$$\n\\texttt{[[t_{1,1},t_{1,2},t_{1,3},t_{1,4}],[t_{2,1},t_{2,2},t_{2,3},t_{2,4}],[t_{3,1},t_{3,2},t_{3,3},t_{3,4}],[t_{4,1},t_{4,2},t_{4,3},t_{4,4}]]}\n$$\n所有时间都以年为单位，并四舍五入到四位小数。",
            "solution": "用户提供了一个问题陈述，在开发解决方案之前需要对其进行验证。\n\n### 步骤 1：提取已知条件\n- **加权邻接矩阵**：$W=\\begin{bmatrix} 0  0.8  0.2  0.0\\\\ 0.8  0  0.6  0.1\\\\ 0.2  0.6  0  0.7\\\\ 0.0  0.1  0.7  0 \\end{bmatrix}$\n- **组合图拉普拉斯算子**：$L=\\operatorname{diag}(W\\mathbf{1})-W$，其中 $\\mathbf{1}$ 是全一向量。\n- **控制微分方程（非线性）**：$\\frac{d\\mathbf{u}}{dt} = -D L \\mathbf{u} + r \\,\\mathbf{u}\\left(1-\\frac{\\mathbf{u}}{K}\\right)$\n- **线性化近似**：对于小负荷 $u_i/K \\ll 1$，方程近似为 $\\frac{d\\mathbf{u}}{dt} \\approx \\left(-D L + r I\\right)\\mathbf{u} = A\\,\\mathbf{u}$。\n- **系统矩阵**：$A = -D L + r I$，其中 $I$ 是单位矩阵。\n- **线性系统解**：$\\mathbf{u}(t) \\approx e^{A t}\\,\\mathbf{u}_0$。\n- **初始条件**：$\\mathbf{u}_0 = [0.01K,\\,0,\\,0,\\,0]^\\top$。\n- **波前到达时间**：定义为满足 $u_i(t) \\ge \\alpha K$ 的最小时间 $t \\ge 0$。\n- **阈值参数**：$\\alpha=0.1$。\n- **未到达值**：$-1.0$。\n- **测试用例**：\n  - 情况 1：$(D,r,K)=(0.15,\\,0.30,\\,1.0)$，$T_{\\max}=25$ 年，$\\Delta t=0.01$ 年。\n  - 情况 2：$(D,r,K)=(0.00,\\,0.30,\\,1.0)$，$T_{\\max}=25$ 年，$\\Delta t=0.01$ 年。\n  - 情况 3：$(D,r,K)=(0.20,\\,0.00,\\,1.0)$，$T_{\\max}=25$ 年，$\\Delta t=0.01$ 年。\n  - 情况 4：$(D,r,K)=(0.50,\\,0.05,\\,1.0)$，$T_{\\max}=60$ 年，$\\Delta t=0.01$ 年。\n\n### 步骤 2：使用提取的已知条件进行验证\n根据指定标准对问题进行评估：\n- **科学依据**：该问题描述了一个网络反应-扩散模型，这是计算系统生物学和数学神经科学中一个标准且被广泛接受的框架，用于模拟病理蛋白的传播。使用图拉普拉斯算子模拟扩散和使用逻辑斯谛增长模拟局部增殖是基本且公认的原理。对于早期动态的线性化是一种有效且标准的数学近似。该模型在科学上是合理的。\n- **适定性**：该问题被表述为一个适定的线性常微分方程组的初值问题。所有必要的参数（$W$、$D$、$r$、$K$）、初始条件（$\\mathbf{u}_0$）以及评估标准（到达时间定义）都得到了明确无误的提供。该问题结构保证了唯一、稳定且可计算的解。\n- **客观性**：该问题以精确、形式化的数学术语陈述。完全没有主观语言、观点或歧义。\n- **其他标准**：该问题是自包含的，其约束条件一致，并且所需的计算在物理上是合理的，在算法上是可行的。它并非微不足道，需要应用线性代数和微分方程的概念。\n\n### 步骤 3：结论与行动\n问题陈述有效。将提供解决方案。\n\n### 解法推导\n\n该问题要求计算在一个包含 $N=4$ 个脑区的连接体上，一个线性化的网络反应-扩散模型的波前到达时间。错误折叠蛋白质负荷向量 $\\mathbf{u}(t) \\in \\mathbb{R}^4$ 的动态由以下线性常微分方程组控制：\n$$\n\\frac{d\\mathbf{u}}{dt} = A\\,\\mathbf{u}\n$$\n其中系统矩阵 $A$ 由 $A = -D L + r I$ 给出。该初值问题的解由矩阵指数给出：\n$$\n\\mathbf{u}(t) = e^{A t}\\,\\mathbf{u}_0\n$$\n\n第一步是根据给定的加权邻接矩阵 $W$ 构建图拉普拉斯算子 $L$。向量 $W\\mathbf{1}$ 包含 $W$ 的行和，代表每个节点的总连接强度（度）。令该向量为 $\\mathbf{s}$。\n$$\n\\mathbf{s} = W\\mathbf{1} = \\begin{bmatrix} 0  0.8  0.2  0.0\\\\ 0.8  0  0.6  0.1\\\\ 0.2  0.6  0  0.7\\\\ 0.0  0.1  0.7  0 \\end{bmatrix} \\begin{bmatrix} 1 \\\\ 1 \\\\ 1 \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} 1.0 \\\\ 1.5 \\\\ 1.5 \\\\ 0.8 \\end{bmatrix}\n$$\n那么，拉普拉斯算子 $L = \\operatorname{diag}(\\mathbf{s}) - W$ 为：\n$$\nL = \\begin{bmatrix} 1.0  0.0  0.0  0.0 \\\\ 0.0  1.5  0.0  0.0 \\\\ 0.0  0.0  1.5  0.0 \\\\ 0.0  0.0  0.0  0.8 \\end{bmatrix} - \\begin{bmatrix} 0  0.8  0.2  0.0\\\\ 0.8  0  0.6  0.1\\\\ 0.2  0.6  0  0.7\\\\ 0.0  0.1  0.7  0 \\end{bmatrix} = \\begin{bmatrix} 1.0  -0.8  -0.2  0.0\\\\ -0.8  1.5  -0.6  -0.1\\\\ -0.2  -0.6  1.5  -0.7\\\\ 0.0  -0.1  -0.7  0.8 \\end{bmatrix}\n$$\n对于每个测试用例，使用给定的参数 $D$ 和 $r$ 构建矩阵 $A = -D L + r I$。由于 $W$ 是对称的，$L$ 也是对称的，因此 $A$ 是一个实对称矩阵。这保证了 $A$ 有一个由特征向量构成的标准正交基。\n\n为了高效地计算多个时间点的 $\\mathbf{u}(t)$，我们对 $A$ 进行对角化。设 $A$ 的特征分解为 $A = V \\Lambda V^\\top$，其中 $V$ 是特征向量构成的正交矩阵，$\\Lambda = \\operatorname{diag}(\\lambda_1, \\lambda_2, \\lambda_3, \\lambda_4)$ 是对应实特征值构成的对角矩阵。解 $\\mathbf{u}(t)$ 于是表示为：\n$$\n\\mathbf{u}(t) = (V e^{\\Lambda t} V^\\top) \\mathbf{u}_0\n$$\n其中 $e^{\\Lambda t} = \\operatorname{diag}(e^{\\lambda_1 t}, e^{\\lambda_2 t}, e^{\\lambda_3 t}, e^{\\lambda_4 t})$。\n\n在计算上，避免在每个时间步都构建矩阵 $e^{At}$ 会更高效。取而代之，我们将初始条件 $\\mathbf{u}_0$ 投影到特征向量基上：\n$$\n\\mathbf{c}_0 = V^\\top \\mathbf{u}_0\n$$\n$\\mathbf{c}_0$ 的分量是 $\\mathbf{u}_0$ 在特征向量基中的坐标。这些坐标的时间演化很简单：\n$$\n\\mathbf{c}(t) = e^{\\Lambda t} \\mathbf{c}_0\n$$\n最后，通过变换回标准基来重构解向量 $\\mathbf{u}(t)$：\n$$\n\\mathbf{u}(t) = V \\mathbf{c}(t)\n$$\n初始条件为 $\\mathbf{u}_0 = [0.01K, 0, 0, 0]^\\top$，到达阈值为 $u_i(t) \\ge \\alpha K$，其中 $\\alpha=0.1$。由于所有测试用例中 $K=1.0$，我们有 $\\mathbf{u}_0 = [0.01, 0, 0, 0]^\\top$ 且阈值为 $0.1$。\n\n对于每个测试用例，我们在一个从 $t=0$ 到 $T_{\\max}$、步长为 $\\Delta t$ 的均匀时间网格上进行迭代。对于每个分量 $u_i(t)$，我们检查是否已超过阈值。节点 $i$ 的波前到达时间是该网格上第一个满足 $u_i(t) \\ge 0.1$ 的时间 $t$。如果在 $T_{\\max}$ 前未达到阈值，则到达时间记录为 $-1.0$。最终报告的时间四舍五入到四位小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the neurodegenerative disease spread model problem by calculating wavefront arrival times\n    for four different test cases.\n    \"\"\"\n    \n    # Define the weighted adjacency matrix W for the 4-node brain connectome.\n    W = np.array([\n        [0.0, 0.8, 0.2, 0.0],\n        [0.8, 0.0, 0.6, 0.1],\n        [0.2, 0.6, 0.0, 0.7],\n        [0.0, 0.1, 0.7, 0.0]\n    ])\n    \n    # Get the number of nodes.\n    N = W.shape[0]\n    \n    # The identity matrix I of size N x N.\n    I = np.identity(N)\n    \n    # Calculate the combinatorial graph Laplacian L = diag(W*1) - W.\n    # s is the vector of row sums (weighted degrees).\n    s = np.sum(W, axis=1)\n    # Degree matrix is a diagonal matrix of the row sums.\n    Degree_matrix = np.diag(s)\n    # The graph Laplacian L.\n    L = Degree_matrix - W\n    \n    # Define constants from the problem statement.\n    alpha = 0.1  # Threshold factor for arrival time.\n    u0_factor = 0.01  # Initial condition factor.\n\n    # Define the test suite with parameters for each case.\n    test_cases = [\n        {'D': 0.15, 'r': 0.30, 'K': 1.0, 'T_max': 25, 'dt': 0.01},\n        {'D': 0.00, 'r': 0.30, 'K': 1.0, 'T_max': 25, 'dt': 0.01},\n        {'D': 0.20, 'r': 0.00, 'K': 1.0, 'T_max': 25, 'dt': 0.01},\n        {'D': 0.50, 'r': 0.05, 'K': 1.0, 'T_max': 60, 'dt': 0.01}\n    ]\n    \n    all_results_str = []\n\n    for case in test_cases:\n        D_param, r_param, K_param = case['D'], case['r'], case['K']\n        T_max, dt = case['T_max'], case['dt']\n\n        # Construct the system matrix A = -D*L + r*I.\n        A = -D_param * L + r_param * I\n\n        # Since A is symmetric, use np.linalg.eigh for stable eigendecomposition.\n        eigenvalues, eigenvectors = np.linalg.eigh(A)\n\n        # Define the initial condition u_0 and the arrival time threshold.\n        # Seeding at node 1.\n        u_0 = np.zeros(N)\n        u_0[0] = u0_factor * K_param\n        threshold = alpha * K_param\n        \n        # Project the initial condition onto the basis of eigenvectors.\n        # c0 = V^T * u_0\n        c0 = eigenvectors.T @ u_0\n\n        # Initialize results for the current case.\n        arrival_times = [-1.0] * N\n        has_arrived = [False] * N\n        \n        # Create a robust time grid using linspace to ensure endpoint is included.\n        num_steps = int(round(T_max / dt)) + 1\n        time_points = np.linspace(0, T_max, num_steps)\n\n        # Iterate through time to find the first arrival at each node.\n        for t in time_points:\n            # Evolve the coefficients in the eigenbasis: c_i(t) = exp(lambda_i * t) * c_i(0).\n            c_t = np.exp(eigenvalues * t) * c0\n            \n            # Reconstruct the solution vector u(t) = V * c(t).\n            u_t = eigenvectors @ c_t\n\n            # Check for threshold crossing at each node.\n            for i in range(N):\n                if not has_arrived[i] and u_t[i] >= threshold:\n                    arrival_times[i] = t\n                    has_arrived[i] = True\n            \n            # Optimization: stop if all nodes have reached the threshold.\n            if all(has_arrived):\n                break\n        \n        # Format the results to four decimal places as required.\n        formatted_times = [f\"{t:.4f}\" for t in arrival_times]\n        all_results_str.append(f\"[{','.join(formatted_times)}]\")\n    \n    # Print the final output in the exact specified format.\n    print(f\"[{','.join(all_results_str)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "一个数学模型的实用价值最终取决于它是否能与真实世界的实验数据相结合。本练习旨在解决“参数可识别性”这一关键挑战，即我们能否从典型的稀疏且含噪声的实验数据（如PET扫描）中，可靠地估计出模型的参数 。您将学习并应用两种核心方法——费雪信息矩阵（Fisher Information Matrix）和剖面似然法（Profile Likelihood）——来评估模型参数的不确定性，这是连接理论模型与临床应用的必经之路。",
            "id": "3333602",
            "problem": "考虑一个简化的神经退行性疾病中错误折叠蛋白负荷的纵向正电子发射断层扫描 (PET) 模型，其中聚集物种通过产生而形成，并通过一级动力学被清除。令 $B(t)$ 表示在时间 $t$ 时聚集蛋白的负荷，以任意 PET 单位计量。假设产生以恒定速率 $k_{agg}$ 发生，清除以速率 $k_{clear}$ 发生，因此负荷服从常微分方程 (ODE)\n$$\\frac{dB}{dt} = k_{agg} - k_{clear}\\,B(t), \\quad B(0)=0,$$\n其中 $k_{agg}  0$ 且 $k_{clear}  0$，单位为 day$^{-1}$。PET 信号建模为\n$$S(t;\\theta) = \\alpha\\,B(t), \\quad \\theta = (k_{agg}, k_{clear}),$$\n其中 $\\alpha0$ 是一个已知的比例常数，$B(t)$ 是该 ODE 的解。在时间 $t_i$ 的观测值 $y_i$ 满足高斯测量模型\n$$y_i = S(t_i;\\theta) + \\varepsilon_i,\\quad \\varepsilon_i \\sim \\mathcal{N}(0,\\sigma^2),$$\n其中噪声标准差 $\\sigma0$ 为已知。对于给定的 ODE 和初始条件，负荷的显式解为\n$$B(t) = \\frac{k_{agg}}{k_{clear}} \\left(1 - e^{-k_{clear} t}\\right),$$\n因此\n$$S(t;\\theta) = \\alpha \\frac{k_{agg}}{k_{clear}} \\left(1 - e^{-k_{clear} t}\\right).$$\n\n您的任务是使用两种互补的方法来评估参数 $k_{agg}$ 和 $k_{clear}$ 的实际可辨识性：\n\n1. 在高斯噪声模型下，根据真实参数值计算的费雪信息矩阵 (FIM)。对于 $\\theta=(k_{agg},k_{clear})$，费雪信息为\n$$I(\\theta) = \\frac{1}{\\sigma^2}\\sum_{i=1}^{n} J(t_i;\\theta)^\\top J(t_i;\\theta),$$\n其中 $J(t;\\theta) = \\left(\\frac{\\partial S(t;\\theta)}{\\partial k_{agg}},\\,\\frac{\\partial S(t;\\theta)}{\\partial k_{clear}}\\right)$ 是信号相对于参数的梯度。使用解析偏导数\n$$\\frac{\\partial S(t;\\theta)}{\\partial k_{agg}} = \\alpha\\,\\frac{1 - e^{-k_{clear} t}}{k_{clear}},$$\n$$\\frac{\\partial S(t;\\theta)}{\\partial k_{clear}} = \\alpha\\,k_{agg}\\left[-\\frac{1 - e^{-k_{clear} t}}{k_{clear}^2} + \\frac{t\\,e^{-k_{clear} t}}{k_{clear}}\\right].$$\n如果 $I(\\theta)$ 是正定的（所有特征值严格为正），并且其谱条件数严格小于选定的阈值 $10^6$，则宣布基于 FIM 的可辨识性准则得到满足。\n\n2. 每个参数的剖面似然。将数据 $\\{(t_i,y_i)\\}_{i=1}^n$ 的残差平方和 (SSE) 定义为\n$$\\mathrm{SSE}(\\theta) = \\sum_{i=1}^n \\left[y_i - S(t_i;\\theta)\\right]^2.$$\n令 $\\hat{\\theta}$ 为 $\\mathrm{SSE}(\\theta)$ 在 $k_{agg}0, k_{clear}0$（在合理范围内）上的联合最小化器。对于每个参数 $\\theta_j \\in \\{k_{agg},k_{clear}\\}$，通过在一系列网格值上固定 $\\theta_j$ 并对剩余参数优化 $\\mathrm{SSE}$ 来计算剖面似然，然后通过\n$$\\Delta(\\theta_j) = \\frac{\\mathrm{SSE}(\\theta_j, \\hat{\\theta}_{-j}(\\theta_j)) - \\mathrm{SSE}(\\hat{\\theta})}{\\sigma^2},$$\n形成 $-2\\log\\mathcal{L}$ 的剖面（相差一个可加常数），其中 $\\hat{\\theta}_{-j}(\\theta_j)$ 表示在给定固定 $\\theta_j$ 时剩余参数的优化器。使用卡方阈值 $\\Delta^* = 3.841459$（对应于 $1$ 个自由度的 $95\\%$ 置信度），如果集合 $\\{\\theta_j: \\Delta(\\theta_j) \\le \\Delta^*\\}$ 在扫描的网格内两侧有界，则宣布基于剖面的 $\\theta_j$ 可辨识性准则得到满足。\n\n结合这两个准则来判断可辨识性：如果 FIM 准则和剖面似然准则都得到满足，则参数是实际可辨识的。\n\n实现一个程序，该程序：\n- 通过在指定时间评估 $S(t;\\theta)$ 并添加标准差为 $\\sigma$ 的高斯噪声来生成合成数据。\n- 计算 $I(\\theta)$，检查其正定性和谱条件数。\n- 计算联合最小二乘估计 $\\hat{\\theta}$，然后计算 $k_{agg}$ 和 $k_{clear}$ 的剖面似然，检查 $95\\%$ 置信集在网格内是否有界。\n- 对于每个测试用例，返回一个包含两个布尔值的列表 $[b_{agg}, b_{clear}]$，分别表示 $k_{agg}$ 和 $k_{clear}$ 的实际可辨识性。\n\n使用以下参数集和采样方案的测试套件，确保所有时间的单位为天，所有速率的单位为 day$^{-1}$：\n- 测试用例 1 (采样良好，中等噪声)：$t_i = 0,2,4,\\ldots,60$；$\\alpha = 1$；$\\sigma = 0.02$；真实 $\\theta^\\star = (k_{agg},k_{clear}) = (0.02, 0.1)$。\n- 测试用例 2 (采样良好，高噪声)：$t_i = 0,2,4,\\ldots,60$；$\\alpha = 1$；$\\sigma = 0.10$；真实 $\\theta^\\star = (0.02, 0.1)$。\n- 测试用例 3 (稀疏早期采样)：$t_i = 0,1,2$；$\\alpha = 1$；$\\sigma = 0.02$；真实 $\\theta^\\star = (0.02, 0.1)$。\n- 测试用例 4 (清除缓慢)：$t_i = 0,1,2,\\ldots,30$；$\\alpha = 1$；$\\sigma = 0.02$；真实 $\\theta^\\star = (0.02, 0.005)$。\n\n对于所有优化任务，使用参数边界 $k_{agg}\\in[10^{-6},1.0]$ 和 $k_{clear}\\in[10^{-6},1.0]$。对于剖面似然网格，为每个参数扫描 $[10^{-4},1.0]$ 区间内的 $200$ 个对数间隔的值。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$ [result1,result2,result3,result4]$）的结果，其中每个 $resultj$ 本身是对应测试用例的一个双元素列表 $[b_{agg},b_{clear}]$（布尔值）。",
            "solution": "该模型始于聚集蛋白负荷 $B(t)$ 的产生-清除动力学，这在计算系统生物学中对分子物种形成与清除之间的不平衡进行建模时是标准方法。在一级清除和恒定聚集速率的条件下，常微分方程为 $\\frac{dB}{dt} = k_{agg} - k_{clear} B(t)$ 且 $B(0) = 0$。这个 ODE 直接源于质量守恒：净变化率等于产生率减去与 $B(t)$ 成正比的清除率。求解该线性 ODE 可得 \n$$B(t) = \\frac{k_{agg}}{k_{clear}} \\left(1 - e^{-k_{clear} t}\\right),$$ \n这是通过标准的积分因子法求解 $\\frac{dB}{dt} + k_{clear} B = k_{agg}$ 得到的，其齐次解为 $B_h(t) = C e^{-k_{clear} t}$，特解为 $B_p(t) = \\frac{k_{agg}}{k_{clear}}$。应用 $B(0) = 0$ 条件即可得到所述表达式。\n\nPET 信号被建模为 $S(t;\\theta) = \\alpha B(t)$，假设负荷与测量信号之间存在已知的线性比例关系 $\\alpha$。高斯噪声模型 $y_i = S(t_i;\\theta) + \\varepsilon_i$ 且 $\\varepsilon_i \\sim \\mathcal{N}(0,\\sigma^2)$ 利用了在纵向扫描的重复帧中 PET 测量误差的经过充分检验的假设。\n\n为了进行可辨识性分析，我们使用两种经典方法。对于独立样本，在高斯噪声下的费雪信息矩阵 (FIM) 为 \n$$I(\\theta) = \\frac{1}{\\sigma^2}\\sum_{i=1}^n J(t_i;\\theta)^\\top J(t_i;\\theta),$$\n其中 $J(t;\\theta)$ 是 $S(t;\\theta)$ 相对于参数的梯度。从 \n$$S(t;\\theta) = \\alpha \\frac{k_{agg}}{k_{clear}}(1 - e^{-k_{clear} t}),$$ \n出发，我们通过对 $k_{agg} k_{clear}^{-1}(1 - e^{-k_{clear} t})$ 应用乘法法则并使用 $\\frac{d}{dk_{clear}} e^{-k_{clear} t} = -t e^{-k_{clear} t}$ 进行微分，得到 \n$$\\frac{\\partial S}{\\partial k_{agg}} = \\alpha \\frac{1 - e^{-k_{clear} t}}{k_{clear}},$$\n和 \n$$\\frac{\\partial S}{\\partial k_{clear}} = \\alpha\\,k_{agg}\\left[-\\frac{1 - e^{-k_{clear} t}}{k_{clear}^2} + \\frac{t\\,e^{-k_{clear} t}}{k_{clear}}\\right],$$\n这些表达式提供了 $J(t;\\theta)$；然后 $I(\\theta)$ 是一个对所有样本聚合的 $2\\times 2$ 矩阵。对于 FIM 准则，我们通过确保 $I(\\theta)$ 的两个特征值都严格为正来检验其正定性；我们还计算谱条件数 $\\kappa(I) = \\lambda_{\\max}/\\lambda_{\\min}$ 并要求 $\\kappa(I)  10^6$，以避免近似奇异，因为这会导致严重的参数相关性和较差的实际可辨识性。\n\n剖面似然方法通过检查当优化其他参数时，似然面是否为每个参数提供了有界的置信区间来评估可辨识性。残差平方和为 \n$$\\mathrm{SSE}(\\theta) = \\sum_{i=1}^n [y_i - S(t_i;\\theta)]^2.$$\n我们通过在 $k_{agg},k_{clear}  0$ 的条件下，使用实际边界 $[10^{-6},1.0]$ 以保证数值稳定性，最小化 $\\mathrm{SSE}(\\theta)$ 来获得联合最小二乘估计 $\\hat{\\theta}$。对于每个参数 $\\theta_j$，我们计算剖面 \n$$\\Delta(\\theta_j) = \\frac{\\mathrm{SSE}(\\theta_j, \\hat{\\theta}_{-j}(\\theta_j)) - \\mathrm{SSE}(\\hat{\\theta})}{\\sigma^2},$$\n它在高斯噪声下近似于 $-2\\log\\mathcal{L}$ 的差值（相差一个可加常数）。使用自由度为 $1$、置信度为 $95\\%$ 的卡方阈值 $\\Delta^* = 3.841459$，我们检查集合 $\\{\\theta_j: \\Delta(\\theta_j) \\le \\Delta^*\\}$ 在网格扫描范围内是否有界。如果区间两侧都有界，则该参数表现出有限的置信区间，表明具有实际可辨识性；如果区间无界（例如，置信集延伸到扫描网格的边界），则该参数不具有实际可辨识性。\n\n算法设计：\n- 通过 $y_i = S(t_i;\\theta^\\star) + \\varepsilon_i$ 生成合成数据 $y_i$，使用固定的随机种子以保证可复现性。\n- 使用解析梯度计算 $I(\\theta^\\star)$；通过特征值和条件数 $\\kappa(I)$ 检查正定性。\n- 通过对残差 $r_i(\\theta) = y_i - S(t_i;\\theta)$ 进行非线性最小二乘拟合来得到 $\\hat{\\theta}$，并使用正性边界 $[10^{-6},1.0]$。\n- 对于每个参数，在 $[10^{-4},1.0]$ 的对数网格上评估剖面似然：固定 $\\theta_j$，对另一个参数优化 $\\mathrm{SSE}$，计算 $\\Delta(\\theta_j)$，并确定 $95\\%$ 置信集是否有界。\n- 结合 FIM 和剖面准则，为每个参数生成布尔值。\n\n测试套件涵盖了多种情况：\n- 测试用例 1 提供了丰富的采样和中等噪声，预期 $k_{agg}$ 和 $k_{clear}$ 都是可辨识的。\n- 测试用例 2 增加了 $\\sigma$，可能因似然面变得平坦而降低可辨识性。\n- 测试用例 3 使用稀疏的早期样本，当 $t$ 较小时，$S(t) \\approx \\alpha k_{agg} t$，这使得 $k_{clear}$ 难以辨识，因为早期动态对 $k_{clear}$ 的依赖性很弱。\n- 测试用例 4 采用了非常慢的清除速率 $k_{clear}$，使得动态在观测窗口内接近线性；这通常会妨碍对 $k_{clear}$ 的精确辨识。\n\n程序输出单行结果：一个包含四个 $[b_{agg}, b_{clear}]$ 结果的列表，按测试用例的顺序排列，适用于自动验证。每个布尔值直接编码了该参数在组合准则下是否是实际可辨识的。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import least_squares, minimize_scalar\n\ndef model_signal(t, k_agg, k_clear, alpha):\n    # S(t) = alpha * (k_agg / k_clear) * (1 - exp(-k_clear * t)), B0 = 0\n    t = np.asarray(t, dtype=float)\n    return alpha * (k_agg / k_clear) * (1.0 - np.exp(-k_clear * t))\n\ndef gradients(t, k_agg, k_clear, alpha):\n    # Analytical gradients of S(t;theta) wrt k_agg and k_clear\n    t = np.asarray(t, dtype=float)\n    exp_term = np.exp(-k_clear * t)\n    dS_dkagg = alpha * (1.0 - exp_term) / k_clear\n    # d/dk_clear of k_agg/k_clear * (1 - exp(-k_clear t))\n    term1 = -(1.0 - exp_term) / (k_clear**2)\n    term2 = (t * exp_term) / k_clear\n    dS_dkclear = alpha * k_agg * (term1 + term2)\n    return dS_dkagg, dS_dkclear\n\ndef fisher_information(t, theta, alpha, sigma):\n    k_agg, k_clear = theta\n    dS_dkagg, dS_dkclear = gradients(t, k_agg, k_clear, alpha)\n    # Build I = (1/sigma^2) sum J^T J\n    I11 = np.sum(dS_dkagg**2) / (sigma**2)\n    I22 = np.sum(dS_dkclear**2) / (sigma**2)\n    I12 = np.sum(dS_dkagg * dS_dkclear) / (sigma**2)\n    I = np.array([[I11, I12],\n                  [I12, I22]], dtype=float)\n    return I\n\ndef is_fim_identifiable(I, cond_threshold=1e6, eps=1e-12):\n    # Check positive definiteness and condition number\n    eigvals = np.linalg.eigvalsh(I)\n    pd = np.all(eigvals > eps)\n    # Avoid division by zero in condition number\n    if eigvals.min() = 0:\n        cond = np.inf\n    else:\n        cond = eigvals.max() / eigvals.min()\n    return pd and (cond  cond_threshold)\n\ndef sse(theta, t, y, alpha):\n    k_agg, k_clear = theta\n    # Clip to positive small values to avoid division by zero in model\n    if k_agg = 0 or k_clear = 0:\n        return np.inf\n    pred = model_signal(t, k_agg, k_clear, alpha)\n    res = y - pred\n    return float(np.sum(res**2))\n\ndef fit_theta(t, y, alpha, bounds=(1e-6, 1.0)):\n    # Nonlinear least squares on residuals with bounds\n    def residuals(theta):\n        return y - model_signal(t, theta[0], theta[1], alpha)\n    lb = np.array([bounds[0], bounds[0]], dtype=float)\n    ub = np.array([bounds[1], bounds[1]], dtype=float)\n    # Initial guess: moderate values\n    x0 = np.array([0.02, 0.1], dtype=float)\n    res = least_squares(residuals, x0=x0, bounds=(lb, ub), method='trf', jac='2-point', max_nfev=5000)\n    theta_hat = res.x\n    sse_hat = float(np.sum(res.fun**2))\n    return theta_hat, sse_hat\n\ndef profile_likelihood_param(param_name, t, y, alpha, sigma, theta_hat, sse_hat,\n                             grid_min=1e-4, grid_max=1.0, n_grid=200, bounds=(1e-6, 1.0)):\n    # Build logarithmic grid for the profiled parameter\n    grid = np.exp(np.linspace(np.log(grid_min), np.log(grid_max), n_grid))\n    deltas = np.empty_like(grid)\n    # Optimize the other parameter for each fixed value\n    for i, val in enumerate(grid):\n        if param_name == 'k_agg':\n            fixed_k_agg = val\n            # Optimize k_clear with bounds\n            def obj(k_clear):\n                # k_clear is scalar\n                k_clear = float(k_clear)\n                if k_clear = 0:\n                    return np.inf\n                return sse((fixed_k_agg, k_clear), t, y, alpha)\n            res = minimize_scalar(obj, bounds=bounds, method='bounded', options={'xatol': 1e-6, 'maxiter': 500})\n            sse_val = float(res.fun)\n        elif param_name == 'k_clear':\n            fixed_k_clear = val\n            def obj(k_agg):\n                k_agg = float(k_agg)\n                if k_agg = 0:\n                    return np.inf\n                return sse((k_agg, fixed_k_clear), t, y, alpha)\n            res = minimize_scalar(obj, bounds=bounds, method='bounded', options={'xatol': 1e-6, 'maxiter': 500})\n            sse_val = float(res.fun)\n        else:\n            raise ValueError(\"Unknown parameter name for profiling\")\n        deltas[i] = (sse_val - sse_hat) / (sigma**2)\n    # Identify bounded 95% CI set within the grid using chi-square threshold\n    threshold = 3.841459  # 95% for 1 dof\n    min_idx = int(np.argmin(deltas))\n    # Search left and right for threshold crossings\n    left_cross = None\n    for i in range(min_idx, -1, -1):\n        if deltas[i] >= threshold:\n            left_cross = i\n            break\n    right_cross = None\n    for i in range(min_idx, len(deltas)):\n        if deltas[i] >= threshold:\n            right_cross = i\n            break\n    # Bounded if both crossings exist and there is at least one point below threshold between them\n    bounded = (left_cross is not None) and (right_cross is not None) and (left_cross  right_cross)\n    return bounded, grid, deltas\n\ndef assess_identifiability(t, theta_true, alpha, sigma, rng):\n    # Generate synthetic data\n    t = np.asarray(t, dtype=float)\n    y_true = model_signal(t, theta_true[0], theta_true[1], alpha)\n    noise = rng.normal(loc=0.0, scale=sigma, size=t.shape)\n    y = y_true + noise\n\n    # Fisher Information at true parameters\n    I = fisher_information(t, theta_true, alpha, sigma)\n    fim_ok = is_fim_identifiable(I, cond_threshold=1e6, eps=1e-12)\n\n    # Joint fit\n    theta_hat, sse_hat = fit_theta(t, y, alpha, bounds=(1e-6, 1.0))\n\n    # Profile likelihoods\n    bounded_kagg, _, _ = profile_likelihood_param('k_agg', t, y, alpha, sigma, theta_hat, sse_hat,\n                                                  grid_min=1e-4, grid_max=1.0, n_grid=200, bounds=(1e-6, 1.0))\n    bounded_kclear, _, _ = profile_likelihood_param('k_clear', t, y, alpha, sigma, theta_hat, sse_hat,\n                                                    grid_min=1e-4, grid_max=1.0, n_grid=200, bounds=(1e-6, 1.0))\n    # Combined criterion: FIM criterion must hold AND profile boundedness must hold for each parameter\n    ident_kagg = bool(fim_ok and bounded_kagg)\n    ident_kclear = bool(fim_ok and bounded_kclear)\n    return [ident_kagg, ident_kclear]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (t_values, theta_true, alpha, sigma)\n        (np.arange(0.0, 60.0 + 1e-9, 2.0), (0.02, 0.10), 1.0, 0.02),   # Test Case 1\n        (np.arange(0.0, 60.0 + 1e-9, 2.0), (0.02, 0.10), 1.0, 0.10),   # Test Case 2\n        (np.array([0.0, 1.0, 2.0]), (0.02, 0.10), 1.0, 0.02),          # Test Case 3\n        (np.arange(0.0, 30.0 + 1e-9, 1.0), (0.02, 0.005), 1.0, 0.02),  # Test Case 4\n    ]\n\n    rng = np.random.default_rng(seed=0)\n    results = []\n    for t_vals, theta_true, alpha, sigma in test_cases:\n        res = assess_identifiability(t_vals, theta_true, alpha, sigma, rng)\n        results.append(res)\n\n    # Final print statement in the exact required format.\n    # Each result is a list [bool, bool]; we need a single-line string with brackets and commas.\n    # Convert booleans to Python's True/False textual representation.\n    def format_result(r):\n        return \"[\" + \",\".join([\"True\" if x else \"False\" for x in r]) + \"]\"\n    print(\"[\" + \",\".join(format_result(r) for r in results) + \"]\")\n\nsolve()\n```"
        }
    ]
}