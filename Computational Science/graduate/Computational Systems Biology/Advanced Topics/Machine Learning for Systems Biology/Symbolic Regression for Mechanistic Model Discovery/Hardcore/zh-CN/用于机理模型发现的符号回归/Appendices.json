{
    "hands_on_practices": [
        {
            "introduction": "任何符号回归方法的基础是其候选函数库。一个构造不良的库，特别是包含高度相关或冗余项的库，会使得识别真实底层模型结构的任务变得不可能。本练习  提供了一个动手实践的场景，让您学习如何使用互相关（mutual coherence）和条件数等标准指标来诊断和解决这类共线性问题，并强调在数值稳定性和机理可解释性之间取得平衡。",
            "id": "3353792",
            "problem": "非线性动力学的稀疏辨识 (SINDy) 旨在通过将测量的时间导数回归到候选基函数库上，来寻求简洁的机理模型。考虑一个单状态系统，其状态 $x(t)$ 在 $N=5$ 个时间点上进行测量，观测值为 $x=\\{0,1,2,3,4\\}$。从三个基函数 $\\phi_1(x)=1$、$\\phi_2(x)=x$ 和 $\\phi_3(x)=1+0.99\\,x$ 构建一个候选库，生成 $N\\times 3$ 的库矩阵 $\\Theta=[\\theta_1\\,\\,\\theta_2\\,\\,\\theta_3]$，其列是求值结果 $\\theta_1=[1,1,1,1,1]^\\top$、$\\theta_2=[0,1,2,3,4]^\\top$ 和 $\\theta_3=[1.00,1.99,2.98,3.97,4.96]^\\top$。\n假设我们在回归之前，用欧几里得 ($\\ell_2$) 范数对各列进行归一化。\n\n稀疏回归中可辨识性的两个标准度量是：\n- 互相关性 $\\mu(\\Theta)$，对于归一化库定义为 $\\mu(\\Theta)=\\max_{i\\neq j}\\left|\\langle \\theta_i,\\theta_j\\rangle\\right|$，其中 $\\langle \\cdot,\\cdot\\rangle$ 表示欧几里得内积。高 $\\mu(\\Theta)$ 会增加稀疏解不唯一的风险。\n- 格拉姆矩阵 $G=\\Theta^\\top\\Theta$ 的条件数 $\\kappa(G)$，定义为 $\\kappa(G)=\\lambda_{\\max}(G)/\\lambda_{\\min}(G)$，其中 $\\lambda_{\\max}$ 和 $\\lambda_{\\min}$ 是最大和最小特征值。大的 $\\kappa(G)$ 表示病态和对噪声的敏感性。\n\n现告知，由于实验设计和噪声的影响，您的可辨识性控制策略是，在应用最小绝对值收缩和选择算子 (LASSO) 进行稀疏估计之前，强制要求 $\\mu(\\Theta)\\le \\tau$（阈值 $\\tau=0.95$）和 $\\kappa(G)\\le \\kappa_{\\max}$（阈值 $\\kappa_{\\max}=50$）。您还采用一个机理可解释性先验：在拆分高度相关的函数对时，倾向于保留基本基函数（例如 $\\phi_1(x)=1$ 和 $\\phi_2(x)=x$），而不是复合混合函数（例如 $\\phi_3(x)=1+0.99\\,x$），除非这样做会违反可辨识性策略。\n\n基于第一性原理和所提供的数据，分析将 $\\phi_3$ 包含在 SINDy 库中对可辨识性的影响，并选择在尊重机理可解释性的同时，能最佳地执行可辨识性策略的剪枝策略。\n\n哪个选项是正确的？\n\nA. 对 $\\Theta$ 进行归一化；计算两两内积以获得 $\\mu(\\Theta)$。由于函数对 $\\{\\phi_2,\\phi_3\\}$ 的互相关性超过了 $\\tau=0.95$，因此剪除 $\\phi_3$（复合混合函数）。剪枝后，剩余的库 $\\{\\phi_1,\\phi_2\\}$ 同时满足 $\\mu(\\Theta)\\le 0.95$ 和 $\\kappa(G)\\le 50$，并且该选择尊重了机理可解释性先验。\n\nB. 保留所有三个基函数，并依靠最小绝对值收缩和选择算子 (LASSO) 正则化来解决冗余问题；在使用 $\\ell_1$ 惩罚项时，高互相关性不会从根本上影响可辨识性。\n\nC. 剪除 $\\phi_2$ 而不是 $\\phi_3$，因为函数对 $\\{\\phi_1,\\phi_3\\}$ 产生的 $\\mu(\\Theta)\\le 0.95$ 和 $\\kappa(G)\\le 50$；在可辨识性策略下，复合混合函数是基本基函数的可接受替代品。\n\nD. 不进行剪枝；而是对库进行 Gram–Schmidt 正交化，将互相关性降至 $0$，并将条件数减小到一个较小的值，从而在不改变回归中所考虑的基函数集合的情况下，强制执行可辨识性策略。",
            "solution": "第一步是评估完整库 $\\Theta=[\\theta_1\\,\\,\\theta_2\\,\\,\\theta_3]$ 的可辨识性。\n\n1.  **归一化库列**：我们首先计算每个库列向量 $\\theta_i$ 的 $\\ell_2$ 范数。\n    -   $||\\theta_1||_2 = \\sqrt{5}$\n    -   $||\\theta_2||_2 = \\sqrt{0^2+1^2+2^2+3^2+4^2} = \\sqrt{30}$\n    -   由于 $\\theta_3 = \\theta_1 + 0.99\\,\\theta_2$，我们计算 $||\\theta_3||_2 = \\sqrt{||\\theta_1||_2^2 + 2(0.99)\\langle\\theta_1,\\theta_2\\rangle + (0.99)^2||\\theta_2||_2^2} = \\sqrt{5 + 1.98(10) + 0.9801(30)} \\approx \\sqrt{54.203}$。\n\n2.  **计算互相关性 $\\mu(\\Theta)$**：我们需要计算归一化向量 $\\hat{\\theta}_i = \\theta_i / ||\\theta_i||_2$ 之间的内积。\n    -   $\\langle \\hat{\\theta}_1, \\hat{\\theta}_2 \\rangle = \\frac{\\langle\\theta_1,\\theta_2\\rangle}{||\\theta_1||_2 ||\\theta_2||_2} = \\frac{10}{\\sqrt{5}\\sqrt{30}} = \\frac{2}{\\sqrt{6}} \\approx 0.8165$。\n    -   $\\langle \\hat{\\theta}_2, \\hat{\\theta}_3 \\rangle = \\frac{\\langle\\theta_2,\\theta_1+0.99\\theta_2\\rangle}{||\\theta_2||_2 ||\\theta_3||_2} = \\frac{\\langle\\theta_1,\\theta_2\\rangle+0.99||\\theta_2||_2^2}{||\\theta_2||_2 ||\\theta_3||_2} = \\frac{10+0.99(30)}{\\sqrt{30}\\sqrt{54.203}} \\approx \\frac{39.7}{40.32} \\approx 0.9846$。\n    -   互相关性是这些值的最大绝对值，$\\mu(\\Theta) \\approx 0.9846$。这超过了策略阈值 $\\tau=0.95$，因此完整的库是不可接受的。\n\n3.  **计算条件数 $\\kappa(G)$**：由于基函数之间存在线性依赖关系（$\\phi_3 = \\phi_1 + 0.99\\,\\phi_2$），库矩阵 $\\Theta$ 的列是线性相关的。这意味着格拉姆矩阵 $G=\\Theta^\\top\\Theta$ 是奇异的，其最小特征值 $\\lambda_{\\min}(G)=0$。因此，条件数 $\\kappa(G) = \\infty$，远超阈值 $\\kappa_{\\max}=50$。\n\n4.  **应用剪枝策略**：由于完整的库不满足可辨识性策略，我们必须对其进行剪枝。问题的根源在于 $\\phi_3$ 是 $\\phi_1$ 和 $\\phi_2$ 的复合。根据机理可解释性先验，我们应优先移除复合函数 $\\phi_3$。\n\n5.  **验证剪枝后的库 $\\{\\phi_1, \\phi_2\\}$**：\n    -   **互相关性**：新库中唯一的互相关性是 $|\\langle \\hat{\\theta}_1, \\hat{\\theta}_2 \\rangle| \\approx 0.8165$，这满足 $\\le 0.95$ 的要求。\n    -   **条件数**：新库的 $2 \\times 2$ 格拉姆矩阵的特征值为 $\\lambda = 1 \\pm |\\langle \\hat{\\theta}_1, \\hat{\\theta}_2 \\rangle|$。条件数为 $\\kappa(G') = \\frac{1+0.8165}{1-0.8165} \\approx \\frac{1.8165}{0.1835} \\approx 9.899$。这满足 $\\le 50$ 的要求。\n\n结论：剪除 $\\phi_3$ 的策略既遵守了可解释性先验，又使库满足了所有的可辨识性要求。因此，选项 A 描述了正确的分析和决策过程。选项 B 忽略了策略并错误地陈述了 LASSO 的稳健性。选项 C 违反了可解释性先验。选项 D 通过正交化破坏了机理可解释性，与 SINDy 的目标不符。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "有了一个适定(well-posed)的函数库后，下一步是推断哪个函数组合能最好地解释观测数据。这个练习  深入探讨了一种强大的方法：贝叶斯模型选择。您将实现一个完整的工作流程，来计算不同候选基因调控模型的后验概率，学习如何边缘化滋扰参数(nuisance parameters)，并利用证据(evidence)来比较整个模型族，这是现代计算系统生物学的基石。",
            "id": "3353773",
            "problem": "实现一个完整的、可运行的程序，该程序使用基于机械论基因激活模型的贝叶斯先验执行符号回归（SR），以在给定模拟时间序列数据的情况下，推断候选表达函数族的后验概率。其机械论基础是无量纲设定下的常微分方程 $dx/dt = f(S) - \\gamma x$，其中 $x$ 是一个无量纲的基因产物水平，$S$ 是一个无量纲的输入信号，$\\gamma$ 是一个为正的降解速率常数。程序必须枚举一个小的候选调控表达式 $f(S)$ 语法库，为离散的希尔指数和连续的生化参数分配具有科学依据的先验，通过边缘化参数来计算表达函数族的贝叶斯后验，然后报告在多个测试案例中，分配给真实生成函数族的后验概率。所有数学实体必须在下方用 LaTeX 书写。\n\n推导必须从以下基础开始：\n- 基因调控动力学模型 $dx/dt = f(S) - \\gamma x$，其中 $\\gamma > 0$。\n- 生物化学中使用的典型激活和抑制希尔函数：\n  - 希尔激活：$f_{\\mathrm{HA}}(S;V,K,n) = \\dfrac{V S^n}{K^n + S^n}$。\n  - 希尔抑制：$f_{\\mathrm{HR}}(S;V,K,n) = \\dfrac{V K^n}{K^n + S^n}$。\n  - 线性质量作用激活：$f_{\\mathrm{LM}}(S;k) = k S$。\n- 使用贝叶斯定理进行贝叶斯模型选择：$p(M \\mid D) \\propto p(D \\mid M) \\, p(M)$，其中 $M$ 是一个模型族，$D$ 是观测数据。边缘似然为 $p(D \\mid M) = \\int p(D \\mid \\theta, M) \\, p(\\theta \\mid M) \\, d\\theta$，其中 $\\theta$ 是模型参数。\n\n您必须实现边缘似然的有限、确定性近似，方法是在机械论模型下，通过对模拟观测值的高斯似然进行积分（在参数的对数上使用均匀网格），同时编码关于希尔指数 $n$ 的有信息先验。程序必须按以下步骤进行：\n- 要枚举的候选表达函数族：\n  1. 希尔激活函数族：$f_{\\mathrm{HA}}(S;V,K,n)$，希尔指数 $n \\in \\{1,2,3,4\\}$。\n  2. 希尔抑制函数族：$f_{\\mathrm{HR}}(S;V,K,n)$，希尔指数 $n \\in \\{1,2,3,4\\}$。\n  3. 线性质量作用激活函数族：$f_{\\mathrm{LM}}(S;k)$。\n- 结构先验：$p(M)$ 在三个函数族上是均匀的，每个函数族的 $p(M) = 1/3$。\n- 希尔指数先验：$p(n=1) = 0.4$，$p(n=2) = 0.3$，$p(n=3) = 0.2$，$p(n=4) = 0.1$。\n- 参数先验（均为无量纲）：\n  - 对于希尔函数族，$V$ 和 $K$ 分别在 $[V_{\\min},V_{\\max}]$ 和 $[K_{\\min},K_{\\max}]$ 上具有对数均匀先验，其中 $V_{\\min} = 0.3$，$V_{\\max} = 3.0$，$K_{\\min} = 0.2$，$K_{\\max} = 2.0$。\n  - 对于线性质量作用，$k$ 在 $[k_{\\min},k_{\\max}]$ 上具有对数均匀先验，其中 $k_{\\min} = 0.2$，$k_{\\max} = 2.0$。\n- 数值边缘化：\n  - 对希尔函数族（对于 $V$ 和 $K$），使用在对数空间中均匀的网格，点数为 $N_V = 6$ 和 $N_K = 6$；对线性质量作用函数族（对于 $k$），使用点数为 $N_k = 6$ 的网格。将网格点视为对数均匀先验下的等权重样本，因此边缘似然通过网格上似然的均值来近似。\n- 似然模型：\n  - 观测值被模拟为带噪声的时间序列 $x_{\\mathrm{obs}}(t_i) = x_{\\mathrm{true}}(t_i) + \\varepsilon_i$，其中 $\\varepsilon_i \\sim \\mathcal{N}(0,\\sigma_x^2)$ 是独立高斯噪声，$\\sigma_x$ 对每个测试案例已知。给定参数 $\\theta$ 和函数族 $M$，预测轨迹 $x_{\\theta,M}(t)$ 求解 $dx/dt = f_M(S(t);\\theta) - \\gamma x$；似然为\n    $$\\log p(D \\mid \\theta, M) = \\sum_{i=1}^{N} \\left[ -\\dfrac{\\left(x_{\\mathrm{obs}}(t_i) - x_{\\theta,M}(t_i)\\right)^2}{2\\sigma_x^2} - \\dfrac{1}{2}\\log\\left(2\\pi\\sigma_x^2\\right) \\right].$$\n  - 对于动力学的数值积分，在 $N$ 个点上使用步长为 $\\Delta t$ 的稳定的前向欧拉离散化：\n    $$x_{i+1} = x_i + \\Delta t \\left( f_M(S(t_i);\\theta) - \\gamma x_i \\right), \\quad x_0 \\text{ 给定.}$$\n- 函数族的后验：\n  - 对于每个函数族 $M$，通过在对数空间网格上对 $p(D \\mid \\theta, M)$ 取平均来计算边缘似然 $p(D \\mid M)$；对于希尔函数族，对每个 $n$ 单独求平均得到 $p(D \\mid n, M)$，然后与 $p(n)$ 结合得到 $p(D \\mid M) = \\sum_{n} p(n) \\, p(D \\mid n, M)$。\n  - 与均匀结构先验结合以获得归一化后验 $p(M \\mid D) = \\dfrac{p(D \\mid M) p(M)}{\\sum_{M'} p(D \\mid M') p(M')}$。\n\n测试套件规范（所有量均为无量纲）：\n- 时间离散化使用在 $[0,T]$ 上均匀分布的 $N$ 个点，步长 $\\Delta t = T/(N-1)$。每个案例指定初始条件 $x_0$。\n- 为每个案例定义输入信号 $S(t)$：\n  1. 案例 A（理想路径希尔激活）：$T = 20$，$N = 201$，$S(t) = 0$（当 $t  5$）和 $S(t) = 1$（当 $t \\ge 5$），$\\gamma = 0.7$，$\\sigma_x = 0.05$，$x_0 = 0.0$。真实生成模型：希尔激活，参数为 $V = 1.5$，$K = 0.5$，$n = 2$。\n  2. 案例 B（边界低指数）：$T = 15$，$N = 151$，$S(t) = \\min\\left(2 \\, t / T, 2\\right)$，$\\gamma = 1.0$，$\\sigma_x = 0.08$，$x_0 = 0.0$。真实生成模型：希尔激活，参数为 $V = 1.0$，$K = 1.0$，$n = 1$。\n  3. 案例 C（高阶跃下的抑制）：$T = 18$，$N = 181$，$S(t) = 0.2$（当 $t  3$）和 $S(t) = 2.0$（当 $t \\ge 3$），$\\gamma = 0.6$，$\\sigma_x = 0.05$。真实生成模型：希尔抑制，参数为 $V = 2.0$，$K = 0.3$，$n = 3$。使用 $x_0 = f_{\\mathrm{HR}}(0.2;V,K,n)/\\gamma$ 以在阶跃前从接近稳态开始。\n  4. 案例 D（正弦输入下的线性质量作用）：$T = 20$，$N = 201$，$S(t) = 0.5\\left[\\sin\\left(6\\pi t/T\\right) + 1\\right]$，$\\gamma = 0.5$，$\\sigma_x = 0.03$，$x_0 = 0.0$。真实生成模型：线性质量作用，参数为 $k = 0.8$。\n\n实现要求：\n- 使用前向欧拉方案从真实生成模型模拟每个案例的 $x_{\\mathrm{true}}(t)$，然后添加独立高斯噪声 $\\mathcal{N}(0,\\sigma_x^2)$ 以获得 $x_{\\mathrm{obs}}(t)$。\n- 对于推断，遵循上述贝叶斯边缘化方法，使用指定的对数空间网格，为每个候选函数族 $M \\in \\{\\mathrm{HA}, \\mathrm{HR}, \\mathrm{LM}\\}$ 计算 $p(M \\mid D)$：\n  - 希尔函数族：$V \\in [0.3,3.0]$ 和 $K \\in [0.2,2.0]$，每个都有 $N_V = N_K = 6$ 个对数间隔值，以及 $n \\in \\{1,2,3,4\\}$，使用给定的先验。\n  - 线性质量作用函数族：$k \\in [0.2,2.0]$，有 $N_k = 6$ 个对数间隔值。\n- 你的程序的最终输出必须是单行，包含一个用方括号括起来的逗号分隔列表，内含四个数字，每个测试案例一个，按顺序代表为案例 A、B、C 和 D 的真实生成函数族分配的后验概率。例如，输出格式应与 $[p_A,p_B,p_C,p_D]$ 完全一样，其中每个 $p_\\bullet$ 是标准十进制表示的浮点数。\n\n所有变量都是无量纲的；不需要物理单位转换。正弦输入中的角度以弧度为单位。程序必须是确定性的和自包含的，不需要外部输入或文件，并且必须仅使用指定的运行时环境库。",
            "solution": "该问题要求实现一个贝叶斯模型选择框架，以在给定模拟时间序列数据的情况下，从一组预定义的候选中发现最可能的基因调控函数。这个任务是一种由机械论原理指导的符号回归形式，是计算系统生物学中的一个常见问题。解决方案涉及从已知模型模拟数据，然后使用贝叶斯推断计算每个候选模型族的后验概率，最终报告分配给真实生成函数族的概率。\n\n分析的核心是控制基因产物浓度 $x$ 的无量纲常微分方程 (ODE)：\n$$\n\\frac{dx}{dt} = f(S) - \\gamma x\n$$\n在这里，$x(t)$ 代表基因产物随时间变化的水平，$S(t)$ 是一个输入信号，$\\gamma$ 是一阶降解速率常数 ($\\gamma  0$)，$f(S)$ 是生产速率函数，它依赖于信号 $S$。目标是从一个离散的候选库中确定 $f(S)$ 最合理的函数形式。\n\n$f(S)$ 的候选函数是标准的生化模型：\n1.  **希尔激活 (HA)**：$f_{\\mathrm{HA}}(S;V,K,n) = \\dfrac{V S^n}{K^n + S^n}$。这个函数描述了一个协同激活过程，其中 $V$ 是最大生产速率，$K$ 是激活常数（半最大激活时的信号水平），$n$ 是希尔指数，用于量化协同性。HA 的模型族由 $n \\in \\{1, 2, 3, 4\\}$ 的子模型组成。\n2.  **希尔抑制 (HR)**：$f_{\\mathrm{HR}}(S;V,K,n) = \\dfrac{V K^n}{K^n + S^n}$。这个函数描述了协同抑制。参数 $V$、$K$ 和 $n$ 具有类似的解释。HR 的模型族也包括 $n \\in \\{1, 2, 3, 4\\}$ 的子模型。\n3.  **线性质量作用 (LM)**：$f_{\\mathrm{LM}}(S;k) = k S$。这是最简单的模型，表示信号与生产速率之间非饱和的、直接成正比的关系，其中 $k$ 是速率常数。\n\n模型选择在贝叶斯框架内进行。根据贝叶斯定理，在给定观测数据 $D$ 的情况下，模型族 $M$ 的后验概率与数据在该模型下的边缘似然和模型的先验概率的乘积成正比：\n$$\np(M \\mid D) \\propto p(D \\mid M) \\, p(M)\n$$\n$p(M)$ 项是结构先验，它反映了对每个模型族可能性的任何预先存在的信念。问题指定了一个均匀结构先验，$p(M) = 1/3$ 对于三个函数族（HA、HR、LM）中的每一个，表明没有初始偏好。\n\n需要计算的关键量是边缘似然，或称为证据，$p(D \\mid M)$。它是通过将似然 $p(D \\mid \\theta, M)$ 在模型所有可能参数 $\\theta$ 值上进行积分得到的，并由其先验分布 $p(\\theta \\mid M)$ 加权：\n$$\np(D \\mid M) = \\int p(D \\mid \\theta, M) \\, p(\\theta \\mid M) \\, d\\theta\n$$\n似然函数 $p(D \\mid \\theta, M)$ 量化了具有特定参数 $\\theta$ 的模型对数据的解释程度。数据 $D$ 由离散时间点的观测值 $x_{\\mathrm{obs}}(t_i)$ 组成，这些观测值被假定为真实轨迹 $x_{\\theta,M}(t_i)$ 加上独立高斯噪声：$x_{\\mathrm{obs}}(t_i) = x_{\\theta,M}(t_i) + \\varepsilon_i$，其中 $\\varepsilon_i \\sim \\mathcal{N}(0, \\sigma_x^2)$。整个时间序列的对数似然是：\n$$\n\\log p(D \\mid \\theta, M) = \\sum_{i=1}^{N} \\left[ -\\dfrac{\\left(x_{\\mathrm{obs}}(t_i) - x_{\\theta,M}(t_i)\\right)^2}{2\\sigma_x^2} - \\dfrac{1}{2}\\log\\left(2\\pi\\sigma_x^2\\right) \\right]\n$$\n参数的先验分布指定如下：\n- 对于希尔函数族，$V$ 和 $K$ 分别在 $[0.3, 3.0]$ 和 $[0.2, 2.0]$ 上具有对数均匀先验。\n- 对于 LM 函数族，$k$ 在 $[0.2, 2.0]$ 上具有对数均匀先验。\n- 对于希尔函数族，指数 $n$ 具有指定的离散先验：$p(n=1)=0.4$，$p(n=2)=0.3$，$p(n=3)=0.2$，$p(n=4)=0.1$。\n\n算法实现过程如下：\n首先，对于每个测试用例，通过使用前向欧拉方案 $x_{i+1} = x_i + \\Delta t (f(S(t_i)) - \\gamma x_i)$ 求解真实模型的 ODE 来生成合成数据 $x_{\\mathrm{obs}}$，并添加具有指定标准差 $\\sigma_x$ 的高斯噪声。\n\n其次，对每个候选函数族的边缘似然进行数值近似。积分被替换为在参数值的离散网格上的求和。问题指定使用在对数空间中对参数 $V$、$K$ 和 $k$ 均匀的网格（点数为 $N_V=6, N_K=6, N_k=6$），将边缘化简化为网格点上似然的算术平均值。这种简化等同于蒙特卡洛近似，其中网格点被视为来自对数均匀先验的样本。为了在将对数似然转换回似然进行平均时避免数值下溢，使用了一种数值稳定的方法：\n$$\np(D \\mid M) \\approx \\frac{1}{N_{\\text{grid}}} \\sum_{j} p(D \\mid \\theta_j, M) = \\frac{1}{N_{\\text{grid}}} \\exp(\\ell_{\\max}) \\sum_{j} \\exp(\\log p(D \\mid \\theta_j, M) - \\ell_{\\max})\n$$\n其中 $\\ell_{\\max}$ 是网格上的最大对数似然值。\n\n对于具有离散参数 $n$ 的希尔函数族（HA 和 HR），边缘化是一个两步过程。首先，对于 $n \\in \\{1, 2, 3, 4\\}$ 的每个值，通过在 $(V, K)$ 网格上求平均来计算边缘似然 $p(D \\mid n, M)$。然后，使用 $n$ 上的先验，将函数族的总边缘似然计算为加权和：\n$$\np(D \\mid M_{\\text{Hill}}) = \\sum_{n \\in \\{1,2,3,4\\}} p(n) \\, p(D \\mid n, M_{\\text{Hill}})\n$$\n\n最后，在计算出三个函数族的边缘似然（证据）$E_{HA}, E_{HR}, E_{LM}$ 之后，通过归一化找到后验概率。由于结构先验 $p(M)$ 是均匀的，它被抵消了，因此函数族 $M$ 的后验就是其证据除以总证据：\n$$\np(M \\mid D) = \\frac{E_M}{E_{HA} + E_{HR} + E_{LM}}\n$$\n对于每个测试案例，算法计算这些后验，并报告与实际生成数据的函数族相对应的值。这个过程为每个候选调控机制提供了定量的、有原则的置信度度量。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements Symbolic Regression with Bayesian priors to infer gene activation models.\n    \"\"\"\n    # Set a deterministic seed for noise generation as required by the problem.\n    RNG = np.random.default_rng(seed=0)\n\n    # --- Define candidate model functions ---\n    def f_ha(S, V, K, n):\n        \"\"\"Hill activation function.\"\"\"\n        # Add a small epsilon to prevent division by zero in edge cases.\n        S_n = S**n\n        K_n = K**n\n        return (V * S_n) / (K_n + S_n + 1e-12)\n\n    def f_hr(S, V, K, n):\n        \"\"\"Hill repression function.\"\"\"\n        S_n = S**n\n        K_n = K**n\n        return (V * K_n) / (K_n + S_n + 1e-12)\n\n    def f_lm(S, k):\n        \"\"\"Linear mass-action function.\"\"\"\n        return k * S\n\n    # --- Define ODE solver ---\n    def euler_solver(f_prod_func, s_signal, gamma, x0, t_points, params):\n        \"\"\"Solves dx/dt = f(S) - gamma*x using forward Euler.\"\"\"\n        dt = t_points[1] - t_points[0]\n        n_points = len(t_points)\n        x = np.zeros(n_points)\n        x[0] = x0\n        for i in range(n_points - 1):\n            production = f_prod_func(s_signal[i], **params)\n            degradation = gamma * x[i]\n            x[i+1] = x[i] + dt * (production - degradation)\n        return x\n\n    # --- Define Likelihood and Evidence functions ---\n    def log_likelihood(x_obs, x_pred, sigma_x):\n        \"\"\"Computes the log-likelihood of observations given a prediction.\"\"\"\n        n_obs = len(x_obs)\n        sse = np.sum((x_obs - x_pred)**2)\n        log_lik = -0.5 * n_obs * np.log(2 * np.pi * sigma_x**2) - sse / (2 * sigma_x**2)\n        return log_lik\n\n    def average_likelihood_from_logs(log_likelihoods):\n        \"\"\"Calculates the mean of likelihoods from a list of log-likelihoods stably.\"\"\"\n        if not log_likelihoods:\n            return 0.0\n        log_lik_array = np.array(log_likelihoods)\n        max_log_lik = np.max(log_lik_array)\n        \n        if max_log_lik  -700:\n            return 0.0\n        \n        sum_of_likelihoods = np.sum(np.exp(log_lik_array - max_log_lik))\n        avg_lik = np.exp(max_log_lik) * sum_of_likelihoods / len(log_likelihoods)\n        return avg_lik\n\n    # --- Define test cases from problem statement ---\n    test_cases = [\n        # Case A: Hill activation\n        {'T': 20.0, 'N': 201, 'S_func': lambda t: np.where(t  5.0, 0.0, 1.0), 'gamma': 0.7, 'sigma_x': 0.05, 'x0': 0.0,\n         'true_model': {'type': 'HA', 'params': {'V': 1.5, 'K': 0.5, 'n': 2.0}, 'func': f_ha}},\n        # Case B: Hill activation, low exponent\n        {'T': 15.0, 'N': 151, 'S_func': lambda t: np.minimum(2.0 * t / 15.0, 2.0), 'gamma': 1.0, 'sigma_x': 0.08, 'x0': 0.0,\n         'true_model': {'type': 'HA', 'params': {'V': 1.0, 'K': 1.0, 'n': 1.0}, 'func': f_ha}},\n        # Case C: Hill repression\n        {'T': 18.0, 'N': 181, 'S_func': lambda t: np.where(t  3.0, 0.2, 2.0), 'gamma': 0.6, 'sigma_x': 0.05, 'x0': 'from_true_params',\n         'true_model': {'type': 'HR', 'params': {'V': 2.0, 'K': 0.3, 'n': 3.0}, 'func': f_hr}},\n        # Case D: Linear mass-action\n        {'T': 20.0, 'N': 201, 'S_func': lambda t: 0.5 * (np.sin(6.0 * np.pi * t / 20.0) + 1.0), 'gamma': 0.5, 'sigma_x': 0.03, 'x0': 0.0,\n         'true_model': {'type': 'LM', 'params': {'k': 0.8}, 'func': f_lm}}\n    ]\n    \n    # --- Define parameter grids and priors for inference ---\n    V_grid = np.logspace(np.log10(0.3), np.log10(3.0), 6)\n    K_grid = np.logspace(np.log10(0.2), np.log10(2.0), 6)\n    k_grid = np.logspace(np.log10(0.2), np.log10(2.0), 6)\n    n_values = [1, 2, 3, 4]\n    n_priors = np.array([0.4, 0.3, 0.2, 0.1])\n\n    final_results = []\n    \n    # --- Main Loop over Test Cases ---\n    for case in test_cases:\n        # Generate time series data\n        t_points = np.linspace(0, case['T'], case['N'])\n        s_signal = case['S_func'](t_points)\n        x0 = case['x0']\n        if x0 == 'from_true_params': # Special handling for case C initial condition\n            s_initial = s_signal[0]\n            true_params = case['true_model']['params']\n            x0 = case['true_model']['func'](s_initial, **true_params) / case['gamma']\n\n        x_true = euler_solver(case['true_model']['func'], s_signal, case['gamma'], x0, t_points, case['true_model']['params'])\n        noise = RNG.normal(0, case['sigma_x'], size=case['N'])\n        x_obs = x_true + noise\n\n        # --- Inference Stage: Compute Evidence for each model family ---\n        evidences = {}\n\n        # 1. Hill Activation (HA)\n        evidence_per_n_ha = []\n        for n in n_values:\n            log_liks = [log_likelihood(x_obs, euler_solver(f_ha, s_signal, case['gamma'], x0, t_points, {'V': v, 'K': k, 'n': float(n)}), case['sigma_x'])\n                        for v in V_grid for k in K_grid]\n            evidence_per_n_ha.append(average_likelihood_from_logs(log_liks))\n        evidences['HA'] = np.sum(n_priors * np.array(evidence_per_n_ha))\n\n        # 2. Hill Repression (HR)\n        evidence_per_n_hr = []\n        for n in n_values:\n            log_liks = [log_likelihood(x_obs, euler_solver(f_hr, s_signal, case['gamma'], x0, t_points, {'V': v, 'K': k, 'n': float(n)}), case['sigma_x'])\n                        for v in V_grid for k in K_grid]\n            evidence_per_n_hr.append(average_likelihood_from_logs(log_liks))\n        evidences['HR'] = np.sum(n_priors * np.array(evidence_per_n_hr))\n        \n        # 3. Linear Mass-Action (LM)\n        log_liks_lm = [log_likelihood(x_obs, euler_solver(f_lm, s_signal, case['gamma'], x0, t_points, {'k': k_val}), case['sigma_x'])\n                       for k_val in k_grid]\n        evidences['LM'] = average_likelihood_from_logs(log_liks_lm)\n        \n        # --- Calculate Posteriors ---\n        total_evidence = sum(evidences.values())\n        if total_evidence > 0:\n            posteriors = {model: ev / total_evidence for model, ev in evidences.items()}\n        else: # Handle unlikely case where all evidences are zero\n            posteriors = {'HA': 1./3., 'HR': 1./3., 'LM': 1./3.}\n        \n        # Append the posterior of the true model for this case\n        true_model_type = case['true_model']['type']\n        final_results.append(posteriors[true_model_type])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.8f}' for r in final_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "如果一个通过符号回归得到的数学上的最优模型违反了基本的物理定律，那么它就是无用的。在系统生物学中，一个关键的约束是浓度的非负性。这个练习  将挑战您对这物理原理进行形式化，首先推导状态正不变性(positivity invariance)的条件，然后将其转化为一个数学惩罚函数，用以引导搜索过程朝向物理上合理的模型。",
            "id": "3353725",
            "problem": "考虑一个已发现的关于 $n$ 种生化物质的常微分方程（ODE）系统，其浓度为 $x \\in \\mathbb{R}_{\\geq 0}^{n}$，写作 $\\dot{x} = f(x)$，其中 $f : \\mathbb{R}_{\\geq 0}^{n} \\to \\mathbb{R}^{n}$ 是局部利普希茨函数，代表净生成速率。在质量作用定律下的机理化学反应网络模型中，$f(x)$ 可表示为 $f(x) = S\\,v(x)$，其中 $S \\in \\mathbb{R}^{n \\times m}$ 是化学计量矩阵，$v : \\mathbb{R}_{\\geq 0}^{n} \\to \\mathbb{R}_{\\geq 0}^{m}$ 是基本反应倾向（通量）向量，它们是 $\\mathbb{R}_{\\geq 0}^{n}$ 上的非负函数，并且当任何所需反应物的浓度为零时，其值也为零。在用于机理模型发现的符号回归中，$f$ 和 $v$ 的候选形式可能会违反物理约束，例如浓度和通量的非负性。\n\n从浓度非负和质量作用定律下反应倾向非负的物理约束出发，并根据常微分方程闭集的前向不变性定义，推导确保状态空间 $\\Omega = \\mathbb{R}_{\\geq 0}^{n}$ 正不变性的条件；即，从 $\\Omega$ 内开始的轨迹在所有未来时间内都保持在 $\\Omega$ 内的条件。然后，为正则化符号回归，构建一个单一的可微罚分泛函，该泛函抑制候选形式对以下条件的违反：\n- 在每个坐标超面 $\\{x \\in \\Omega : x_{i} = 0\\}$ 上，$\\Omega$ 的内指边界条件，以及\n- 在 $\\Omega$ 上，每个候选基本反应倾向 $v_{r}(x)$ 的非负性。\n\n设评估区域为有界超立方体 $\\mathcal{D}_{L} = [0,L]^{n}$，其中 $L  0$，超面为 $\\mathcal{F}_{i}(L) = \\{x \\in \\mathcal{D}_{L} : x_{i} = 0\\}$，其中 $i \\in \\{1,\\dots,n\\}$。在 $\\mathcal{F}_{i}(L)$ 和 $\\mathcal{D}_{L}$ 上使用均匀权重，并令 $\\alpha  0$ 和 $\\beta  0$ 为超参数，分别用以平衡边界违规和通量负值的惩罚。使用仅通过绝对值重新参数化的正部算子来表示边界违规惩罚，并对通量非负性惩罚做同样的处理。您的惩罚项必须通过每个超面的 $(n-1)$ 维体积和 $\\mathcal{D}_{L}$ 的 $n$ 维体积进行归一化。\n\n以 $f$、$v$、$L$、$\\alpha$ 和 $\\beta$ 的形式，提供最终的罚分泛函，作为一个仅包含代数运算、绝对值和积分的单一闭式解析表达式。您的最终答案必须是该单一解析表达式。不需要进行数值四舍五入，最终答案中也不应报告任何单位。",
            "solution": "该问题要求两个主要部分：首先，推导确保物质浓度随时间保持非负性的条件；其次，构建一个罚分泛函，在用于模型发现的符号回归框架内强制执行这些条件。\n\n首先，我们推导正不变性的条件。浓度的状态空间是非负象限 $\\Omega = \\mathbb{R}_{\\geq 0}^{n}$，它是 $\\mathbb{R}^{n}$ 中的一个闭凸集。系统的动力学由常微分方程（ODE）$\\dot{x} = f(x)$ 给出。对于从 $\\Omega$ 内开始的轨迹（即 $x(0) \\in \\Omega$）要在所有未来时间 $t  0$ 内保持在 $\\Omega$ 中，集合 $\\Omega$ 必须是正向不变的。\n\n闭凸集 $\\Omega$ 保持正向不变的一个充分条件由 Nagumo 定理（也称为切向条件）给出。该定理指出，$\\Omega$ 是正向不变的，当且仅当对于边界 $\\partial \\Omega$ 上的每一点 $x$，向量场 $f(x)$ 与 $\\Omega$ 相切或指向 $\\Omega$ 的内部。\n\n非负象限 $\\Omega = \\mathbb{R}_{\\geq 0}^{n}$ 的边界是至少有一个浓度为零的坐标超面的并集：$\\partial \\Omega = \\bigcup_{i=1}^{n} \\{x \\in \\mathbb{R}_{\\geq 0}^{n} : x_i = 0\\}$。\n\n我们考虑这些超面上的一个点 $x$，其中对于某个特定索引 $i \\in \\{1, \\dots, n\\}$，有 $x_i = 0$，并且对于所有 $j \\neq i$，有 $x_j \\ge 0$。在此点，边界面的外指法向量为 $-e_i$，其中 $e_i$ 是第 $i$ 个标准基向量。切向条件要求向量场 $f(x)$ 在外指法线方向上没有分量。在数学上，这表示为 $f(x) \\cdot (-e_i) \\le 0$。该点积可简化为 $-f_i(x) \\le 0$，这等价于 $f_i(x) \\ge 0$。\n\n因此，状态空间 $\\Omega = \\mathbb{R}_{\\geq 0}^{n}$ 保持正不变性的条件是，对于每个物种 $i=1, \\dots, n$，只要该物种的浓度为零，其净变化率 $f_i(x)$ 就必须是非负的。形式上：\n对于每个 $i \\in \\{1, \\dots, n\\}$，我们必须有 $f_i(x) \\ge 0$ 对于所有满足 $x_i = 0$ 的 $x \\in \\Omega$。\n这就是问题中提到的“内指边界条件”。对于基于质量作用的机理模型，其中 $f(x)=S v(x)$，如果反应倾向 $v_r(x)$ 是非负的，并且在必要反应物浓度为零时其值为零，那么这个条件自然得到满足。然而，通过符号回归发现的模型可能不会自动满足这些物理约束。\n\n接下来，我们构建罚分泛函 $J(f, v)$ 来正则化符号回归。该泛函应抑制在有界测试域 $\\mathcal{D}_L = [0,L]^n$ 上对两个条件的违反：\n1. 内指边界条件：在超面 $\\mathcal{F}_i(L) = \\{x \\in \\mathcal{D}_L : x_i=0\\}$ 上，$f_i(x) \\ge 0$。\n2. 反应倾向的非负性：在域 $\\mathcal{D}_L$ 上，$v_r(x) \\ge 0$。\n\n总罚分泛函 $J(f, v)$ 是两项之和，$J_{boundary}$ 和 $J_{flux}$，由超参数 $\\alpha  0$ 和 $\\beta  0$ 加权。\n\n对于边界违规惩罚，如果 $f_i(x)  0$，则在点 $x \\in \\mathcal{F}_i(L)$ 处发生了对物种 $i$ 的违规。我们希望对这种违规进行惩罚。一个能捕捉到这一点的函数是 $-f_i(x)$ 的正部，即 $\\max(0, -f_i(x))$。问题指定使用一个只涉及绝对值的等价表示。正部函数 $(z)_+ = \\max(0, z)$ 的恒等式是 $(z+|z|)/2$。将其应用于 $-f_i(x)$，在点 $x$ 处的惩罚为：\n$$ p_i(x) = \\max(0, -f_i(x)) = \\frac{-f_i(x) + |-f_i(x)|}{2} = \\frac{|f_i(x)| - f_i(x)}{2} $$\n如果 $f_i(x) \\ge 0$，该函数为零；如果 $f_i(x)  0$，该函数等于 $-f_i(x)$。为了获得第 $i$ 个超面的总惩罚，我们将此量在 $\\mathcal{F}_i(L)$ 上积分。问题要求通过 $\\mathcal{F}_i(L)$ 的 $(n-1)$ 维体积（即 $L^{n-1}$）进行归一化。总边界惩罚 $J_{boundary}$ 是所有超面上惩罚的总和，由 $\\alpha$ 加权：\n$$ J_{boundary} = \\alpha \\sum_{i=1}^{n} \\left( \\frac{1}{L^{n-1}} \\int_{\\mathcal{F}_i(L)} \\frac{|f_i(x)| - f_i(x)}{2} \\, d\\sigma_i \\right) $$\n其中 $d\\sigma_i$ 是 $\\mathcal{F}_i(L)$ 上的 $(n-1)$ 维曲面测度。\n\n对于通量非负性惩罚，如果 $v_r(x)  0$，则在点 $x \\in \\mathcal{D}_L$ 处发生了对反应 $r$ 的违规。类似地，我们用函数 $\\max(0, -v_r(x))$ 对此进行惩罚，其表示为：\n$$ q_r(x) = \\max(0, -v_r(x)) = \\frac{-v_r(x) + |-v_r(x)|}{2} = \\frac{|v_r(x)| - v_r(x)}{2} $$\n为了获得第 $r$ 个反应的总惩罚，我们将此量在整个域 $\\mathcal{D}_L$ 上积分。然后通过 $\\mathcal{D}_L$ 的 $n$ 维体积（即 $L^n$）进行归一化。总通量惩罚 $J_{flux}$ 是所有反应上惩罚的总和，由 $\\beta$ 加权：\n$$ J_{flux} = \\beta \\sum_{r=1}^{m} \\left( \\frac{1}{L^n} \\int_{\\mathcal{D}_L} \\frac{|v_r(x)| - v_r(x)}{2} \\, dV \\right) $$\n其中 $dV$ 是 $n$ 维体积元。\n\n最终的罚分泛函是 $J(f, v) = J_{boundary} + J_{flux}$ 的和。合并表达式并提出常数，我们得到单一的闭式解析表达式：\n$$ J(f, v) = \\frac{\\alpha}{2L^{n-1}} \\sum_{i=1}^{n} \\int_{\\mathcal{F}_i(L)} \\left(|f_i(x)| - f_i(x)\\right) d\\sigma_i + \\frac{\\beta}{2L^n} \\sum_{r=1}^{m} \\int_{\\mathcal{D}_L} \\left(|v_r(x)| - v_r(x)\\right) dV $$\n该泛函关于 $f$ 和 $v$ 的参数几乎处处可微，适用于符号回归中的基于梯度的优化。",
            "answer": "$$ \\boxed{ \\frac{\\alpha}{2 L^{n-1}} \\sum_{i=1}^{n} \\int_{\\mathcal{F}_i(L)} (|f_i(x)| - f_i(x)) \\, d\\sigma_i + \\frac{\\beta}{2 L^n} \\sum_{r=1}^{m} \\int_{\\mathcal{D}_L} (|v_r(x)| - v_r(x)) \\, dV } $$"
        }
    ]
}