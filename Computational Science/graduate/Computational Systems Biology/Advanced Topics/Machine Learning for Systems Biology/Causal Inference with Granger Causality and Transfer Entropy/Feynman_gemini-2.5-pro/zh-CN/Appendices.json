{
    "hands_on_practices": [
        {
            "introduction": "格兰杰因果（Granger Causality, GC）与传递熵（Transfer Entropy, TE）是量化时间序列间有向信息流的核心工具，在线性高斯系统中它们拥有深刻的内在联系。本练习将理论付诸实践，要求你从第一性原理出发，通过编程计算一个向量自回归（VAR）模型中的GC与TE。这个过程不仅会让你亲手验证它们的理论等价关系，更会加深你对这两种方法底层数学机制的理解。",
            "id": "3293117",
            "problem": "考虑一个平稳线性高斯一阶向量自回归过程，简称为一阶向量自回归过程（VAR(1)），其作用于二维状态 $Z_t = [X_t, Y_t]^\\top$，动态方程为 $Z_t = A Z_{t-1} + \\varepsilon_t$，其中 $A \\in \\mathbb{R}^{2 \\times 2}$ 是自回归参数矩阵，$\\varepsilon_t \\sim \\mathcal{N}(0, \\Sigma_\\varepsilon)$ 是独立同分布的高斯新息，其协方差为 $\\Sigma_\\varepsilon \\in \\mathbb{R}^{2 \\times 2}$。假设 $A$ 是稳定的，因此存在唯一的平稳协方差。使用以下基本依据：(i) 平稳性意味着协方差 $\\Sigma$ 满足离散时间李雅普诺夫方程，(ii) 高斯条件方差和条件互信息由协方差决定，以及 (iii) 格兰杰因果关系通过预测误差方差来定义。\n\n仅使用这些基本依据和下述标准定义，设计一个程序，对每个指定的参数集 $(A, \\Sigma_\\varepsilon)$，计算从 $X$ 到 $Y$ 以及从 $Y$ 到 $X$ 的一步 Geweke 格兰杰因果关系和相应的传递熵，并对线性高斯系统数值验证它们的理论恒等式。\n\n将使用的定义：\n- 平稳协方差 $\\,\\Sigma = \\operatorname{Var}(Z_t)\\,$ 是在 $\\,A\\,$ 稳定的条件下，离散李雅普诺夫方程 $\\,\\Sigma = A \\Sigma A^\\top + \\Sigma_\\varepsilon\\,$ 的唯一正定解。\n- 标量目标 $\\,U_t \\in \\{X_t, Y_t\\}\\,$ 在以由 $\\,Z_{t-1}\\,$ 的元素构成的预测变量集 $\\,S\\,$ 为条件时的一步预测误差方差，是高斯条件方差 $\\,\\operatorname{Var}(U_t \\mid S)\\,$，它由 $\\,\\{U_t, S\\}\\,$ 的联合协方差决定。\n- 从 $\\,X\\,$到 $\\,Y\\,$ 的格兰杰因果关系（Geweke 度量）定义为 $\\,F_{X \\to Y} = \\log\\left(\\operatorname{Var}(Y_t \\mid Y_{t-1}) / \\operatorname{Var}(Y_t \\mid X_{t-1}, Y_{t-1})\\right)\\,$，单位为自然单位（奈特, nats），$\\,F_{Y \\to X}\\,$ 的定义类似，只需交换角色。\n- 从 $\\,X\\,$到 $\\,Y\\,$ 的传递熵（Schreiber）定义为条件互信息 $\\,T_{X \\to Y} = I(X_{t-1}; Y_t \\mid Y_{t-1})\\,$，单位为自然单位（奈特, nats），$\\,T_{Y \\to X}\\,$ 的定义类似，只需交换角色。\n\n对于高斯变量，条件互信息可简化为条件方差的对数比，这意味着当所有量都以自然单位（奈特, nats）表示时，理论恒等式 $\\,F_{X \\to Y} = 2\\,T_{X \\to Y}\\,$ 和 $\\,F_{Y \\to X} = 2\\,T_{Y \\to X}\\,$ 成立。\n\n您的程序必须：\n- 对于下方的每个参数集，通过确定所需的平稳协方差和所有必要的条件方差（根据 VAR(1) 模型所蕴含的高斯协方差恒等式），计算 $\\,F_{X \\to Y}, F_{Y \\to X}, T_{X \\to Y}, T_{Y \\to X}\\,$。\n- 对每个参数集，报告一个实数，该实数等于与恒等式的最大绝对偏差，即：\n$$d = \\max\\left(\\left|F_{X \\to Y} - 2 T_{X \\to Y}\\right|, \\left|F_{Y \\to X} - 2 T_{Y \\to X}\\right|\\right).$$\n所有值均应视为以自然单位（奈特, nats）表示的无量纲值。不涉及物理单位。不涉及角度。\n\n测试套件（每组为一个 $\\,A\\,$ 和 $\\,\\Sigma_\\varepsilon\\,$ 对）：\n1. 一般耦合、稳定情况（正常路径）：\n$$\nA = \\begin{bmatrix} 0.3  0.1 \\\\ 0.4  0.2 \\end{bmatrix}, \\quad\n\\Sigma_\\varepsilon = \\begin{bmatrix} 0.7  0.2 \\\\ 0.2  0.5 \\end{bmatrix}.\n$$\n2. 从 $\\,X\\,$到 $\\,Y\\,$ 的单向耦合：\n$$\nA = \\begin{bmatrix} 0.4  0.0 \\\\ 0.5  0.3 \\end{bmatrix}, \\quad\n\\Sigma_\\varepsilon = \\begin{bmatrix} 0.7  0.0 \\\\ 0.0  0.3 \\end{bmatrix}.\n$$\n3. 无交叉耦合（预期度量为零的边界情况）：\n$$\nA = \\begin{bmatrix} 0.6  0.0 \\\\ 0.0  0.6 \\end{bmatrix}, \\quad\n\\Sigma_\\varepsilon = \\begin{bmatrix} 1.0  0.0 \\\\ 0.0  1.0 \\end{bmatrix}.\n$$\n4. 接近边界的稳定性，伴有中等耦合：\n$$\nA = \\begin{bmatrix} 0.95  -0.1 \\\\ 0.2  0.85 \\end{bmatrix}, \\quad\n\\Sigma_\\varepsilon = \\begin{bmatrix} 0.2  0.05 \\\\ 0.05  0.2 \\end{bmatrix}.\n$$\n5. 强相关新息：\n$$\nA = \\begin{bmatrix} 0.5  0.5 \\\\ 0.0  0.4 \\end{bmatrix}, \\quad\n\\Sigma_\\varepsilon = \\begin{bmatrix} 0.3  0.27 \\\\ 0.27  0.5 \\end{bmatrix}.\n$$\n\n最终输出规范：\n- 您的程序应生成一行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，即 $[d_1,d_2,d_3,d_4,d_5]$，其中 $d_i$ 是针对测试用例 $i$ 定义的偏差。这些值必须以自然单位（奈特, nats）计算。不应打印任何额外文本。",
            "solution": "该问题是有效的，因为它在科学上基于向量自回归过程、格兰杰因果关系和传递熵的理论，并且问题定义良好，提供了所有必要的定义和数据。所提供的自回归矩阵是稳定的，保证了唯一平稳协方差的存在。任务是通过从第一性原理实现其定义，来数值验证已建立的、关联线性高斯系统中格兰杰因果关系和传递熵的理论恒等式。\n\n解决方案的核心在于从过程的平稳协方差矩阵中推导出必要的条件方差。设二维状态为 $Z_t = [X_t, Y_t]^\\top$。VAR($1$) 模型为 $Z_t = A Z_{t-1} + \\varepsilon_t$，其中 $A$ 是自回归矩阵，$\\varepsilon_t \\sim \\mathcal{N}(0, \\Sigma_\\varepsilon)$ 是新息过程。\n\n首先，我们确定平稳协方差矩阵 $\\Sigma = \\operatorname{Var}(Z_t)$。由于该过程是平稳的，其协方差不随时间变化，$\\operatorname{Var}(Z_t) = \\operatorname{Var}(Z_{t-1}) = \\Sigma$。对模型方程取方差可得 $\\operatorname{Var}(Z_t) = \\operatorname{Var}(A Z_{t-1} + \\varepsilon_t)$。由于 $\\varepsilon_t$ 独立于像 $Z_{t-1}$ 这样的过去状态，这可以展开为 $\\operatorname{Var}(A Z_{t-1}) + \\operatorname{Var}(\\varepsilon_t) = A \\operatorname{Var}(Z_{t-1}) A^\\top + \\Sigma_\\varepsilon$。这就得到了离散时间李雅普诺夫方程 $\\Sigma = A \\Sigma A^\\top + \\Sigma_\\varepsilon$。对于一个稳定的矩阵 $A$，该方程有一个唯一的正定解 $\\Sigma$，可以通过数值方法求得。我们将 $\\Sigma$ 的分量表示为：\n$$\n\\Sigma = \\begin{bmatrix} \\operatorname{Var}(X_t)  \\operatorname{Cov}(X_t, Y_t) \\\\ \\operatorname{Cov}(Y_t, X_t)  \\operatorname{Var}(Y_t) \\end{bmatrix} = \\begin{bmatrix} \\Sigma_{11}  \\Sigma_{12} \\\\ \\Sigma_{21}  \\Sigma_{22} \\end{bmatrix}\n$$\n类似地，新息协方差矩阵的分量表示为 $\\Sigma_{\\varepsilon,ij}$。\n\n接下来，我们推导格兰杰因果关系和传递熵所需的条件方差表达式。对于具有联合协方差矩阵的高斯变量 $(U, V)$，给定 $V$ 时 $U$ 的条件方差由舒尔补公式给出：$\\operatorname{Var}(U \\mid V) = \\operatorname{Var}(U) - \\operatorname{Cov}(U,V) \\operatorname{Var}(V)^{-1} \\operatorname{Cov}(V,U)$。\n\n我们来计算因果方向 $X \\to Y$ 的度量。\n格兰杰因果关系是 $F_{X \\to Y} = \\log\\left(\\frac{\\operatorname{Var}(Y_t \\mid Y_{t-1})}{\\operatorname{Var}(Y_t \\mid X_{t-1}, Y_{t-1})}\\right)$。\n传递熵是 $T_{X \\to Y} = I(X_{t-1}; Y_t \\mid Y_{t-1})$。对于高斯系统，这等价于 $T_{X \\to Y} = \\frac{1}{2} \\log\\left(\\frac{\\operatorname{Var}(Y_t \\mid Y_{t-1})}{\\operatorname{Var}(Y_t \\mid X_{t-1}, Y_{t-1})}\\right)$。\n\n我们需要两个条件方差：\n$1$. $\\operatorname{Var}(Y_t \\mid X_{t-1}, Y_{t-1})$: 这是 $Y_t$ 在给定完整过去状态 $Z_{t-1}$ 条件下的方差。根据模型方程，$Y_t = (A Z_{t-1})_2 + (\\varepsilon_t)_2$。由于在给定 $Z_{t-1}$ 的条件下 $A Z_{t-1}$ 是固定的，且 $\\varepsilon_t$ 独立于 $Z_{t-1}$，条件方差就是 $Y_t$ 的新息项的方差。\n$$\n\\operatorname{Var}(Y_t \\mid X_{t-1}, Y_{t-1}) = \\operatorname{Var}((\\varepsilon_t)_2) = (\\Sigma_\\varepsilon)_{22}\n$$\n$2$. $\\operatorname{Var}(Y_t \\mid Y_{t-1})$: 这需要 $(Y_t, Y_{t-1})$ 的联合协方差。我们有 $\\operatorname{Var}(Y_t) = \\operatorname{Var}(Y_{t-1}) = \\Sigma_{22}$。互协方差为 $\\operatorname{Cov}(Y_t, Y_{t-1}) = E[Y_t Y_{t-1}] = E[( (A Z_{t-1})_2 + (\\varepsilon_t)_2 ) Y_{t-1}] = E[(A Z_{t-1})_2 Y_{t-1}]$。这是滞后1阶互协方差矩阵 $\\operatorname{Cov}(Z_t, Z_{t-1}) = E[Z_t Z_{t-1}^\\top] = A E[Z_{t-1} Z_{t-1}^\\top] = A \\Sigma$ 的 $(2,2)$ 元素。因此，$\\operatorname{Cov}(Y_t, Y_{t-1}) = (A\\Sigma)_{22}$。对标量变量应用舒尔补公式：\n$$\n\\operatorname{Var}(Y_t \\mid Y_{t-1}) = \\operatorname{Var}(Y_t) - \\frac{\\operatorname{Cov}(Y_t, Y_{t-1})^2}{\\operatorname{Var}(Y_{t-1})} = \\Sigma_{22} - \\frac{((A\\Sigma)_{22})^2}{\\Sigma_{22}}\n$$\n根据对称性，对于因果方向 $Y \\to X$，我们交换索引 $1$ 和 $2$：\n$$\n\\operatorname{Var}(X_t \\mid X_{t-1}, Y_{t-1}) = (\\Sigma_\\varepsilon)_{11}\n$$\n$$\n\\operatorname{Var}(X_t \\mid X_{t-1}) = \\Sigma_{11} - \\frac{((A\\Sigma)_{11})^2}{\\Sigma_{11}}\n$$\n程序将为每个测试用例计算这些量。为了数值检验恒等式 $F = 2T$，我们将使用数学上等价但在计算上不同的公式来计算 $F$ 和 $T$，以揭示潜在的浮点差异。具体来说，我们使用 $F = \\log(V_1/V_2)$ 和 $T = \\frac{1}{2}(\\log(V_1)-\\log(V_2))$。最终偏差 $d$ 是两个因果方向上 $|F - 2T|$ 的最大绝对差。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import solve_discrete_lyapunov\n\ndef solve():\n    \"\"\"\n    Computes causal measures for a 2D VAR(1) process and verifies a theoretical identity.\n\n    For each parameter set (A, Sigma_eps) of a VAR(1) process Z_t = A*Z_{t-1} + eps_t,\n    this function calculates Granger causality (F) and Transfer Entropy (T) in both\n    directions (X->Y and Y->X). It then computes the maximum absolute deviation 'd'\n    from the theoretical identity F = 2T for linear Gaussian systems.\n    \"\"\"\n\n    test_cases = [\n        (  # Case 1: General coupled, stable case\n            np.array([[0.3, 0.1], [0.4, 0.2]]),\n            np.array([[0.7, 0.2], [0.2, 0.5]]),\n        ),\n        (  # Case 2: Unidirectional coupling from X to Y\n            np.array([[0.4, 0.0], [0.5, 0.3]]),\n            np.array([[0.7, 0.0], [0.0, 0.3]]),\n        ),\n        (  # Case 3: No cross-coupling\n            np.array([[0.6, 0.0], [0.0, 0.6]]),\n            np.array([[1.0, 0.0], [0.0, 1.0]]),\n        ),\n        (  # Case 4: Near-boundary stability\n            np.array([[0.95, -0.1], [0.2, 0.85]]),\n            np.array([[0.2, 0.05], [0.05, 0.2]]),\n        ),\n        (  # Case 5: Strongly correlated innovations\n            np.array([[0.5, 0.5], [0.0, 0.4]]),\n            np.array([[0.3, 0.27], [0.27, 0.5]]),\n        ),\n    ]\n\n    results = []\n    for A, Sigma_eps in test_cases:\n        # Numerically compute the deviation for the current parameter set.\n        d = compute_deviation(A, Sigma_eps)\n        results.append(d)\n\n    # Print the final result in the specified format.\n    print(f\"[{','.join(f'{r:.17e}' for r in results)}]\")\n\ndef compute_deviation(A, Sigma_eps):\n    \"\"\"\n    Calculates the maximum deviation from the F=2T identity for a given VAR(1) model.\n\n    Args:\n        A (np.ndarray): The 2x2 autoregressive parameter matrix.\n        Sigma_eps (np.ndarray): The 2x2 covariance matrix of the Gaussian innovations.\n\n    Returns:\n        float: The maximum absolute deviation d = max(|F_XY - 2T_XY|, |F_YX - 2T_YX|).\n    \"\"\"\n    # Step 1: Solve the discrete Lyapunov equation for the stationary covariance Sigma.\n    # Sigma = A * Sigma * A.T + Sigma_eps\n    Sigma = solve_discrete_lyapunov(A, Sigma_eps)\n\n    # Step 2: Compute the lag-1 cross-covariance matrix needed for conditional variances.\n    A_Sigma = A @ Sigma\n\n    # --- Calculation for X -> Y direction ---\n\n    # Step 3: Compute the required conditional variances.\n    # Var(Y_t | Y_{t-1})\n    var_Y_given_Y_lag1 = Sigma[1, 1] - (A_Sigma[1, 1] ** 2) / Sigma[1, 1]\n    # Var(Y_t | X_{t-1}, Y_{t-1})\n    var_Y_given_XY_lag1 = Sigma_eps[1, 1]\n\n    # Step 4: Compute Granger causality and Transfer Entropy using numerically\n    # distinct but mathematically equivalent formulas to test the identity.\n    # F = log(V1/V2)\n    F_X_to_Y = np.log(var_Y_given_Y_lag1 / var_Y_given_XY_lag1)\n    # T = 0.5 * (log(V1) - log(V2))\n    T_X_to_Y = 0.5 * (np.log(var_Y_given_Y_lag1) - np.log(var_Y_given_XY_lag1))\n    \n    dev_X_to_Y = np.abs(F_X_to_Y - 2 * T_X_to_Y)\n\n    # --- Calculation for Y -> X direction ---\n    \n    # Step 5: Compute the required conditional variances.\n    # Var(X_t | X_{t-1})\n    var_X_given_X_lag1 = Sigma[0, 0] - (A_Sigma[0, 0] ** 2) / Sigma[0, 0]\n    # Var(X_t | X_{t-1}, Y_{t-1})\n    var_X_given_XY_lag1 = Sigma_eps[0, 0]\n\n    # Step 6: Compute Granger causality and Transfer Entropy.\n    F_Y_to_X = np.log(var_X_given_X_lag1 / var_X_given_XY_lag1)\n    T_Y_to_X = 0.5 * (np.log(var_X_given_X_lag1) - np.log(var_X_given_XY_lag1))\n\n    dev_Y_to_X = np.abs(F_Y_to_X - 2 * T_Y_to_X)\n\n    # Step 7: The result is the maximum of the two deviations.\n    return max(dev_X_to_Y, dev_Y_to_X)\n\nsolve()\n```"
        },
        {
            "introduction": "在真实的生物系统中，变量间的相互作用网络错综复杂，一个未被观测到的“共同驱动”因素（即隐藏混杂变量）是导致虚假因果结论的主要来源。本练习通过一个模拟实验让你直面这一挑战，你将构建一个包含混杂效应的系统，并对比双变量分析与条件分析的结果。通过这个实践，你将清晰地看到条件化如何消除混杂影响，揭示出真实的因果通路，这是应用因果推断时必须掌握的关键技能。",
            "id": "3293189",
            "problem": "考虑一个用于三个联合演变的生物信号的一阶线性高斯向量自回归（VAR(1)）模型，这三个信号分别代表一个隐藏的调控因子 $Z$ 和两个观测到的基因表达时间序列 $X$ 和 $Y$。该系统按如下方式演变：在每个离散时间点 $t$，状态 $(Z_t, X_t, Y_t)$ 线性地依赖于其滞后1阶的状态 $(Z_{t-1}, X_{t-1}, Y_{t-1})$，并加上具有指定标准差的零均值独立高斯新息。假设对于下面的每一组参数集，模型都是稳定的（谱半径严格小于1）。\n\n你的任务是编写一个完整的程序，对每个指定的参数集，根据下面给出的系数从这样一个VAR(1)过程中模拟 $T$ 个点（在丢弃 $T_0$ 个点的预烧期之后），然后计算 $X$ 和 $Y$ 之间的以下方向性度量：\n- 从 $X$ 到 $Y$ 的双变量格兰杰因果（GC），记为 $GC_{X \\to Y}^{(biv)}$，以及从 $Y$ 到 $X$ 的双变量格兰杰因果，记为 $GC_{Y \\to X}^{(biv)}$，每个都仅使用被测变量对的滞后1阶历史数据进行计算，并排除 $Z$。\n- 以 $Z$ 为条件的从 $X$ 到 $Y$ 的偏格兰杰因果（GC），记为 $GC_{X \\to Y \\mid Z}^{(par)}$，以及以 $Z$ 为条件的从 $Y$ 到 $X$ 的偏格兰杰因果，记为 $GC_{Y \\to X \\mid Z}^{(par)}$，每个都使用滞后1阶历史数据计算，同时以 $Z$ 的滞后1阶为条件。\n- 给定 $Z$ 的条件下，从 $X$ 到 $Y$ 的条件传递熵（TE），记为 $TE_{X \\to Y \\mid Z}$，以及给定 $Z$ 的条件下，从 $Y$ 到 $X$ 的条件传递熵，记为 $TE_{Y \\to X \\mid Z}$，每个都针对滞后1阶历史数据计算，并使用自然对数。\n\n所有量都以自然单位（nats）计算。你应该将每个度量都视为一个非负的信息论得分。对于每个测试用例和每个方向，通过如下的阈值化方法将六个得分中的每一个转换为二元检测决策：\n- 对于任何GC度量 $GC$，如果 $GC > \\tau_{\\mathrm{GC}}$ 则判定为检测到，否则判定为未检测到。\n- 对于任何TE度量 $TE$，如果 $TE > \\tau_{\\mathrm{TE}}$ 则判定为检测到，否则判定为未检测到。\n\n使用 $T = 15000$ 和 $T_0 = 1000$。使用 $\\tau_{\\mathrm{GC}} = 0.02$ 和 $\\tau_{\\mathrm{TE}} = 0.01$。使用一个固定的伪随机种子以保证可复现性。\n\n模型规范。对于每种情况，根据具有以下方程的线性高斯VAR(1)系统进行模拟：\n$$\n\\begin{aligned}\nZ_t = a \\, Z_{t-1} + \\varepsilon_{Z,t}, \\\\\nX_t = b_X \\, X_{t-1} + d \\, Y_{t-1} + g_{ZX} \\, Z_{t-1} + \\varepsilon_{X,t}, \\\\\nY_t = b_Y \\, Y_{t-1} + c \\, X_{t-1} + g_{ZY} \\, Z_{t-1} + \\varepsilon_{Y,t},\n\\end{aligned}\n$$\n其中 $\\varepsilon_{Z,t} \\sim \\mathcal{N}(0, \\sigma_Z^2)$，$\\varepsilon_{X,t} \\sim \\mathcal{N}(0, \\sigma_X^2)$ 和 $\\varepsilon_{Y,t} \\sim \\mathcal{N}(0, \\sigma_Y^2)$ 在时间和分量上都是独立的。\n\n测试套件。模拟以下三种情况，每种情况都使用指定的系数和新息标准差：\n- 情况1（纯粹的隐藏混淆，无直接因果关系）：$a = 0.6$，$b_X = 0.2$，$b_Y = 0.2$，$g_{ZX} = 0.8$，$g_{ZY} = 0.8$，$c = 0.0$，$d = 0.0$，$\\sigma_Z = 1.0$，$\\sigma_X = 0.8$，$\\sigma_Y = 0.8$。\n- 情况2（隐藏混淆加上真实的 $X \\to Y$）：$a = 0.5$，$b_X = 0.2$，$b_Y = 0.2$，$g_{ZX} = 0.5$，$g_{ZY} = 0.5$，$c = 0.3$，$d = 0.0$，$\\sigma_Z = 1.0$，$\\sigma_X = 0.8$，$\\sigma_Y = 0.8$。\n- 情况3（隐藏混淆加上真实的 $Y \\to X$）：$a = 0.5$，$b_X = 0.2$，$b_Y = 0.2$，$g_{ZX} = 0.5$，$g_{ZY} = 0.5$，$c = 0.0$，$d = 0.35$，$\\sigma_Z = 1.0$，$\\sigma_X = 0.8$，$\\sigma_Y = 0.8$。\n\n估算协议。对于每种情况：\n1. 模拟 $T_0 + T$ 个点，并丢弃前 $T_0$ 个点。\n2. 通过为 $Y_t$ 拟合两个线性预测器来计算 $GC_{X \\to Y}^{(biv)}$：一个仅使用 $Y_{t-1}$ 的受限模型和一个同时使用 $Y_{t-1}$ 和 $X_{t-1}$ 的完整模型；类似地，通过交换 $X$ 和 $Y$ 的角色来计算 $GC_{Y \\to X}^{(biv)}$。\n3. 通过为 $Y_t$ 拟合两个线性预测器来计算 $GC_{X \\to Y \\mid Z}^{(par)}$：一个使用 $Y_{t-1}$ 和 $Z_{t-1}$ 的受限模型和一个使用 $Y_{t-1}$、$Z_{t-1}$ 和 $X_{t-1}$ 的完整模型；类似地，通过以 $Z_{t-1}$ 为条件并测试 $Y_{t-1}$ 作为 $X_t$ 的新增预测变量来计算 $GC_{Y \\to X \\mid Z}^{(par)}$。\n4. 使用与步骤3中相同的受限和完整预测器集以及自然对数来计算 $TE_{X \\to Y \\mid Z}$ 和 $TE_{Y \\to X \\mid Z}$。\n\n在所有线性拟合中，对滞后1阶的预测变量使用无截距的普通最小二乘法。通过将负的估计值截断为0，将所得分数视为非负值。\n\n最终输出格式。对于每种情况，按以下固定顺序生成六个二进制整数：\n$[ \\mathbf{1}\\{GC_{X \\to Y}^{(biv)} > \\tau_{\\mathrm{GC}}\\}, \\mathbf{1}\\{GC_{X \\to Y \\mid Z}^{(par)} > \\tau_{\\mathrm{GC}}\\}, \\mathbf{1}\\{TE_{X \\to Y \\mid Z} > \\tau_{\\mathrm{TE}}\\}, \\mathbf{1}\\{GC_{Y \\to X}^{(biv)} > \\tau_{\\mathrm{GC}}\\}, \\mathbf{1}\\{GC_{Y \\to X \\mid Z}^{(par)} > \\tau_{\\mathrm{GC}}\\}, \\mathbf{1}\\{TE_{Y \\to X \\mid Z} > \\tau_{\\mathrm{TE}}\\} ]$。\n将三个情况的结果按顺序聚合成一个包含18个整数的单个扁平列表。你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[r_1,r_2,\\dots,r_{18}]$）。",
            "solution": "该问题被认为是有效的，因为它具有科学依据、适定且客观。它提出了系统生物学中的一个标准计算任务，涉及向量自回归（VAR）模型的模拟以及随后定义的因果推断技术（即格兰杰因果和传递熵）的应用。所有参数、模型和程序都得到了精确指定，从而可以得到一个唯一且有意义的解。\n\n将通过以下步骤来构建解决方案：\n1.  对于每个测试用例，从指定的一阶线性高斯向量自回归（VAR(1)）模型中模拟一个三元时间序列 $(Z_t, X_t, Y_t)$。\n2.  根据模拟数据，估计六个指定的有向连接性度量：双变量格兰杰因果（$GC^{(biv)}$）、偏格兰杰因果（$GC^{(par)}$）和条件传递熵（$TE$）。\n3.  通过应用给定的阈值，将每个估计得分转换为一个二元检测结果。\n\n### 基于原理的设计\n\n#### 1. VAR(1)模型与模拟\n系统的动力学由一个VAR(1)过程描述。一组随时间变化的变量 $\\mathbf{v}_t = [Z_t, X_t, Y_t]^T$ 根据以下线性随机差分方程演变：\n$$\n\\mathbf{v}_t = \\mathbf{A} \\mathbf{v}_{t-1} + \\boldsymbol{\\varepsilon}_t\n$$\n其中 $\\mathbf{v}_{t-1}$ 是系统在前一个时间步的状态，$\\mathbf{A}$ 是定义线性依赖关系的系数矩阵，$\\boldsymbol{\\varepsilon}_t$ 是一个白噪声项（新息）向量。根据问题的方程，系数矩阵 $\\mathbf{A}$ 为：\n$$\n\\mathbf{A} = \\begin{pmatrix}\na  0  0 \\\\\ng_{ZX}  b_X  d \\\\\ng_{ZY}  c  b_Y\n\\end{pmatrix}\n$$\n新息向量 $\\boldsymbol{\\varepsilon}_t = [\\varepsilon_{Z,t}, \\varepsilon_{X,t}, \\varepsilon_{Y,t}]^T$ 从一个零均值和对角协方差矩阵 $\\boldsymbol{\\Sigma}_{\\varepsilon} = \\text{diag}(\\sigma_Z^2, \\sigma_X^2, \\sigma_Y^2)$ 的多元正态分布中抽取。问题指出模型是稳定的，这意味着 $\\mathbf{A}$ 的谱半径（其特征值的最大模）小于1。\n\n模拟从初始状态 $\\mathbf{v}_0 = [0, 0, 0]^T$ 开始，进行 $T_0 + T$ 个时间步。在每个步骤 $t$，生成一个噪声向量 $\\boldsymbol{\\varepsilon}_t$，并计算下一个状态 $\\mathbf{v}_t$。前 $T_0$ 个点构成一个“预烧”期，它们被丢弃以确保模拟序列是该过程平稳分布的一个实现，不受任意初始状态的影响。剩余的 $T$ 个点用于分析。\n\n#### 2. 因果推断度量\n问题要求计算格兰杰因果（GC）和传递熵（TE）。对于线性高斯系统，这两种度量是等价的。\n\n**格兰杰因果（GC）：** 格兰杰因果的原理是，如果时间序列 $X$ 的过去值包含有助于比仅使用 $Y$ 的过去值更好地预测 $Y$ 的未来的信息，则称 $X$ “格兰杰-导致”另一个时间序列 $Y$。对于线性VAR模型，这通过比较两个线性模型的预测误差方差来量化：\n1.  一个**受限模型**，仅使用 $Y$ 自身的过去来预测其现在。\n2.  一个**完整模型**，使用 $Y$ 和 $X$ 两者的过去来预测 $Y$ 的现在。\n\nGC得分定义为这两个模型的残差方差之比的自然对数：\n$$\nGC_{X \\to Y} = \\ln \\left( \\frac{\\text{Var}(\\text{error}_{\\text{restricted}})}{\\text{Var}(\\text{error}_{\\text{full}})} \\right) = \\ln \\left( \\frac{\\hat{\\sigma}_r^2}{\\hat{\\sigma}_f^2} \\right)\n$$\n一个正的 $GC$ 值表明 $X$ 改善了对 $Y$ 的预测。\n\n-   **双变量GC ($GC_{X \\to Y}^{(biv)}$):** 这仅使用变量对 $(X, Y)$ 进行计算。受限模型是 $Y_t \\sim Y_{t-1}$，完整模型是 $Y_t \\sim Y_{t-1} + X_{t-1}$。\n-   **偏GC ($GC_{X \\to Y \\mid Z}^{(par)}$):** 这是一个条件度量。它在考虑了第三个变量 $Z$ 的影响后，检验从 $X$ 到 $Y$ 的直接影响。在这里，$Z$ 的过去被包含在两个模型中。受限模型是 $Y_t \\sim Y_{t-1} + Z_{t-1}$，完整模型是 $Y_t \\sim Y_{t-1} + Z_{t-1} + X_{t-1}$。这个度量对于区分直接因果关系和由共同驱动因素（混淆变量）引起的伪相关至关重要。\n\n**条件传递熵（TE）：** 在给定 $Y$ 和 $Z$ 历史的条件下，从 $X$ 到 $Y$ 的条件传递熵量化了因知晓 $X_{t-1}$ 而带来的关于 $Y_t$ 的不确定性的减少。对于线性高斯VAR(1)过程，它在数学上等价于偏格兰杰因果：\n$$\nTE_{X \\to Y \\mid Z} = GC_{X \\to Y \\mid Z}^{(par)}\n$$\n问题要求使用与偏GC相同的模型来计算这个量，但所得分数的阈值处理方式不同。\n\n#### 3. 估计与决策\n根据规定，残差方差 $\\hat{\\sigma}_r^2$ 和 $\\hat{\\sigma}_f^2$ 是通过对模拟数据使用无截距的普通最小二乘（OLS）回归来估计的。对于一个通用线性模型 $\\mathbf{y} = \\mathbf{M}\\boldsymbol{\\beta} + \\boldsymbol{\\epsilon}$，OLS找到最小化残差平方和 $\\|\\boldsymbol{\\epsilon}\\|^2 = \\|\\mathbf{y} - \\mathbf{M}\\boldsymbol{\\beta}\\|^2$ 的系数向量 $\\boldsymbol{\\beta}$。这个和，我们称之为 $SSR$，被用来计算这些度量。由于受限模型和完整模型的样本数量相同，GC/TE得分简化为 $\\ln(SSR_r / SSR_f)$。由于OLS在嵌套模型上的性质，$SSR_f \\le SSR_r$，因此得分是非负的。按照指示，我们将任何由浮点误差引起的微小负值截断为0。\n\n对于六个计算出的分数中的每一个，都会做出一个二元决策：\n-   如果 $GC > \\tau_{\\mathrm{GC}} = 0.02$，则检测到因果联系（输出 $1$）。否则，未检测到联系（输出 $0$）。\n-   如果 $TE > \\tau_{\\mathrm{TE}} = 0.01$，则检测到因果联系（输出 $1$）。否则，未检测到联系（输出 $0$）。\n\n最终输出是这18个二元决策（3个案例，每个案例6个）聚合成的单个列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation and analysis for all test cases.\n    \"\"\"\n    # Define problem parameters\n    T = 15000\n    T0 = 1000\n    TAU_GC = 0.02\n    TAU_TE = 0.01\n    SEED = 42\n\n    # Define test cases as a list of dictionaries\n    test_cases = [\n        {\n            'name': 'Case 1: Hidden Confounding',\n            'a': 0.6, 'bX': 0.2, 'bY': 0.2, 'gZX': 0.8, 'gZY': 0.8, \n            'c': 0.0, 'd': 0.0, 'sigmaZ': 1.0, 'sigmaX': 0.8, 'sigmaY': 0.8\n        },\n        {\n            'name': 'Case 2: Confounding + X->Y',\n            'a': 0.5, 'bX': 0.2, 'bY': 0.2, 'gZX': 0.5, 'gZY': 0.5, \n            'c': 0.3, 'd': 0.0, 'sigmaZ': 1.0, 'sigmaX': 0.8, 'sigmaY': 0.8\n        },\n        {\n            'name': 'Case 3: Confounding + Y->X',\n            'a': 0.5, 'bX': 0.2, 'bY': 0.2, 'gZX': 0.5, 'gZY': 0.5, \n            'c': 0.0, 'd': 0.35, 'sigmaZ': 1.0, 'sigmaX': 0.8, 'sigmaY': 0.8\n        }\n    ]\n\n    rng = np.random.default_rng(SEED)\n    all_results = []\n\n    for params in test_cases:\n        # Step 1: Simulate the VAR(1) process\n        v_total = simulate_var1(params, T + T0, rng)\n        data = v_total[T0:] # Discard burn-in\n\n        # Extract time series for Z, X, Y\n        Z, X, Y = data[:, 0], data[:, 1], data[:, 2]\n\n        # Prepare lagged data for regression\n        # Target variables (t)\n        Y_t = Y[1:]\n        X_t = X[1:]\n        # Predictor variables (t-1)\n        Z_lag1 = Z[:-1].reshape(-1, 1)\n        X_lag1 = X[:-1].reshape(-1, 1)\n        Y_lag1 = Y[:-1].reshape(-1, 1)\n\n        # Step 2  3: Compute measures and apply thresholds\n\n        # Direction X -> Y\n        # GC_biv(X -> Y)\n        gc_xy_biv = compute_gc(target_vec=Y_t, past_target=Y_lag1, driver=X_lag1)\n        \n        # GC_par(X -> Y | Z) and TE(X -> Y | Z)\n        gc_xy_par = compute_gc(target_vec=Y_t, past_target=Y_lag1, driver=X_lag1, condition=Z_lag1)\n        te_xy_cond = gc_xy_par\n\n        # Direction Y -> X\n        # GC_biv(Y -> X)\n        gc_yx_biv = compute_gc(target_vec=X_t, past_target=X_lag1, driver=Y_lag1)\n        \n        # GC_par(Y -> X | Z) and TE(Y -> X | Z)\n        gc_yx_par = compute_gc(target_vec=X_t, past_target=X_lag1, driver=Y_lag1, condition=Z_lag1)\n        te_yx_cond = gc_yx_par\n\n        # Apply thresholds to get binary decisions\n        case_results = [\n            1 if gc_xy_biv > TAU_GC else 0,\n            1 if gc_xy_par > TAU_GC else 0,\n            1 if te_xy_cond > TAU_TE else 0,\n            1 if gc_yx_biv > TAU_GC else 0,\n            1 if gc_yx_par > TAU_GC else 0,\n            1 if te_yx_cond > TAU_TE else 0\n        ]\n        all_results.extend(case_results)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\n\ndef simulate_var1(params, num_points, rng):\n    \"\"\"\n    Simulates a 3-variable VAR(1) process.\n    Returns a numpy array of shape (num_points, 3).\n    \"\"\"\n    # Coefficient matrix A\n    A = np.array([\n        [params['a'], 0.0, 0.0],\n        [params['gZX'], params['bX'], params['d']],\n        [params['gZY'], params['c'], params['bY']]\n    ])\n    \n    # Standard deviations of innovations\n    noise_std = np.array([params['sigmaZ'], params['sigmaX'], params['sigmaY']])\n    \n    # Initialize the time series data array\n    v = np.zeros((num_points, 3))\n    \n    # Iterate through time to generate the series\n    for t in range(1, num_points):\n        epsilon = rng.normal(loc=0.0, scale=noise_std)\n        v[t, :] = A @ v[t-1, :] + epsilon\n        \n    return v\n\ndef compute_gc(target_vec, past_target, driver, condition=None):\n    \"\"\"\n    Computes a Granger Causality score.\n    \n    Args:\n        target_vec (np.array): The vector of the target variable at time t.\n        past_target (np.array): The vector of the target variable at time t-1.\n        driver (np.array): The vector of the driver variable at time t-1.\n        condition (np.array, optional): Conditioning variable(s) at t-1.\n    \n    Returns:\n        float: The computed GC score.\n    \"\"\"\n    # Restricted model regression\n    if condition is None:\n        X_restr = past_target\n    else:\n        X_restr = np.hstack([past_target, condition])\n    \n    _, res_r, _, _ = np.linalg.lstsq(X_restr, target_vec, rcond=None)\n    \n    # Full model regression\n    if condition is None:\n        X_full = np.hstack([past_target, driver])\n    else:\n        X_full = np.hstack([past_target, condition, driver])\n        \n    _, res_f, _, _ = np.linalg.lstsq(X_full, target_vec, rcond=None)\n    \n    # The lstsq function returns the sum of squared residuals in an array\n    ssr_r = res_r[0]\n    ssr_f = res_f[0]\n\n    # Handle cases where full model performs no better due to precision\n    if ssr_f >= ssr_r:\n        return 0.0\n    \n    # Calculate GC score in nats and truncate to be non-negative\n    score = np.log(ssr_r / ssr_f)\n    return np.maximum(0.0, score)\n\n# Execute the solution\nsolve()\n```"
        },
        {
            "introduction": "因果推断的结论不仅取决于所用方法，也深刻地受到数据采样时间尺度的制约。当系统内部的相互作用比测量频率快得多时，一个快速的因果过程可能被错误地识别为“瞬时”相关性。本练习引导你区分并计算“滞后”与“瞬时”格兰杰因果，并探讨其在快速信号通路等场景下的解释。通过这个练习，你将学会如何从模型中解读时间尺度信息，对推断出的因果关系做出更审慎的判断。",
            "id": "3293174",
            "problem": "考虑两种分子物质形成一个快速信号通路，其活性以$1$秒的分辨率被记录，并联合建模为一个平稳、零均值、二元一阶向量自回归（VAR(1)）模型。设状态向量为 $\\mathbf{Z}_{t} = \\begin{pmatrix} X_{t} \\\\ Y_{t} \\end{pmatrix}$，其演化方程为 $\\mathbf{Z}_{t} = \\mathbf{A} \\mathbf{Z}_{t-1} + \\mathbf{E}_{t}$，其中系数矩阵为 $\\mathbf{A} = \\begin{pmatrix} 0.6  0.0 \\\\ 0.4  0.5 \\end{pmatrix}$，且新息（残差）是联合高斯分布、时间上白噪声，并且同期相关，其协方差矩阵为 $\\boldsymbol{\\Sigma}_{e} = \\begin{pmatrix} 1.0  0.4 \\\\ 0.4  0.8 \\end{pmatrix}$。假设该过程是稳定且严平稳的。\n\n仅使用在线性高斯设定中将格兰杰因果（Granger causality, GC）定义为单步预测误差方差的减少（即比较完整线性预测器与受限线性预测器）的基本原理，以及用于平稳协方差的离散时间李雅普诺夫方程，执行以下操作：\n\n1. 通过求解 $\\boldsymbol{\\Gamma} = \\mathbf{A} \\boldsymbol{\\Gamma} \\mathbf{A}^{\\top} + \\boldsymbol{\\Sigma}_{e}$ 来计算平稳协方差矩阵 $\\boldsymbol{\\Gamma} = \\mathbb{E}[\\mathbf{Z}_{t} \\mathbf{Z}_{t}^{\\top}]$。从 $\\boldsymbol{\\Gamma}$ 中，求得条件方差 $\\operatorname{Var}(X_{t-1} \\mid Y_{t-1})$。\n\n2. 使用方差减少的定义，计算从 $X$到$Y$的滞后格兰杰因果关系，其值为 $Y_{t}$ 在排除$X$过去信息的模型下的单步预测误差方差与在完整VAR(1)模型下的单步预测误差方差之比的自然对数。\n\n3. 独立地，计算$X$和$Y$之间的瞬时格兰杰因果关系（在线性高斯假设下的同期对称耦合度量），该关系仅由新息的同期相关性引起。\n\n报告两个标量——首先是从$X$到$Y$的滞后格兰杰因果，其次是瞬时格兰杰因果——以自然对数单位（奈特）表示。将每个值四舍五入到四位有效数字。\n\n最后，基于这些计算出的量，简要解释在采样可能接近分子相互作用特征时间尺度的快速信号通路中，滞后项和瞬时项的分离如何为因果解释提供信息。",
            "solution": "该问题在科学上和数学上都是适定的。所有需要的数据和定义都已提供，参数与一个稳定的向量自回归过程一致，并且任务被明确指定。其基本概念——向量自回归（VAR）、离散时间李雅普诺夫方程，以及通过预测误差方差定义的格兰杰因果——在时间序列分析及其在计算系统生物学等领域的应用中都是标准概念。因此，我们可以进行完整解答。\n\nVAR($1$)过程的状态向量为 $\\mathbf{Z}_{t} = \\begin{pmatrix} X_{t} \\\\ Y_{t} \\end{pmatrix}$，其演化方程为 $\\mathbf{Z}_{t} = \\mathbf{A} \\mathbf{Z}_{t-1} + \\mathbf{E}_{t}$。给定的矩阵是：\n$$\n\\mathbf{A} = \\begin{pmatrix} 0.6  0.0 \\\\ 0.4  0.5 \\end{pmatrix}, \\quad \\boldsymbol{\\Sigma}_{e} = \\mathbb{E}[\\mathbf{E}_{t} \\mathbf{E}_{t}^{\\top}] = \\begin{pmatrix} 1.0  0.4 \\\\ 0.4  0.8 \\end{pmatrix}\n$$\n\n通过检查$\\mathbf{A}$的特征值可以确认过程的稳定性。由于$\\mathbf{A}$是一个下三角矩阵，其特征值是其对角线元素，$\\lambda_1 = 0.6$ 和 $\\lambda_2 = 0.5$。因为$|\\lambda_1|  1$ 和 $|\\lambda_2|  1$都成立，所以该过程是稳定的，并具有唯一的平稳分布。\n\n**1. 平稳协方差矩阵 $\\boldsymbol{\\Gamma}$的计算**\n\n平稳协方差矩阵 $\\boldsymbol{\\Gamma} = \\mathbb{E}[\\mathbf{Z}_{t} \\mathbf{Z}_{t}^{\\top}]$ 是离散时间李雅普诺夫方程的解：\n$$\n\\boldsymbol{\\Gamma} = \\mathbf{A} \\boldsymbol{\\Gamma} \\mathbf{A}^{\\top} + \\boldsymbol{\\Sigma}_{e}\n$$\n设 $\\boldsymbol{\\Gamma} = \\begin{pmatrix} \\gamma_{11}  \\gamma_{12} \\\\ \\gamma_{21}  \\gamma_{22} \\end{pmatrix}$。由于 $\\boldsymbol{\\Gamma}$ 是一个协方差矩阵，它是对称的，所以 $\\gamma_{12} = \\gamma_{21}$。将矩阵代入方程中：\n$$\n\\begin{pmatrix} \\gamma_{11}  \\gamma_{12} \\\\ \\gamma_{12}  \\gamma_{22} \\end{pmatrix} = \\begin{pmatrix} 0.6  0.0 \\\\ 0.4  0.5 \\end{pmatrix} \\begin{pmatrix} \\gamma_{11}  \\gamma_{12} \\\\ \\gamma_{12}  \\gamma_{22} \\end{pmatrix} \\begin{pmatrix} 0.6  0.4 \\\\ 0.0  0.5 \\end{pmatrix} + \\begin{pmatrix} 1.0  0.4 \\\\ 0.4  0.8 \\end{pmatrix}\n$$\n$$\n\\begin{pmatrix} \\gamma_{11}  \\gamma_{12} \\\\ \\gamma_{12}  \\gamma_{22} \\end{pmatrix} = \\begin{pmatrix} 0.36\\gamma_{11}  0.24\\gamma_{11} + 0.3\\gamma_{12} \\\\ 0.24\\gamma_{11} + 0.3\\gamma_{12}  0.16\\gamma_{11} + 0.4\\gamma_{12} + 0.25\\gamma_{22} \\end{pmatrix} + \\begin{pmatrix} 1.0  0.4 \\\\ 0.4  0.8 \\end{pmatrix}\n$$\n这为$\\boldsymbol{\\Gamma}$的元素提供了一个线性方程组：\n1. $\\gamma_{11} = 0.36\\gamma_{11} + 1.0 \\implies 0.64\\gamma_{11} = 1.0 \\implies \\gamma_{11} = \\frac{1.0}{0.64} = 1.5625 = \\frac{25}{16}$。\n2. $\\gamma_{12} = 0.24\\gamma_{11} + 0.3\\gamma_{12} + 0.4 \\implies 0.7\\gamma_{12} = 0.24(1.5625) + 0.4 = 0.375 + 0.4 = 0.775 \\implies \\gamma_{12} = \\frac{0.775}{0.7} = \\frac{31}{28}$。\n3. $\\gamma_{22} = 0.16\\gamma_{11} + 0.4\\gamma_{12} + 0.25\\gamma_{22} + 0.8 \\implies 0.75\\gamma_{22} = 0.16\\gamma_{11} + 0.4\\gamma_{12} + 0.8$。\n代入 $\\gamma_{11}$ 和 $\\gamma_{12}$ 的值：\n$0.75\\gamma_{22} = 0.16(\\frac{25}{16}) + 0.4(\\frac{31}{28}) + 0.8 = 0.25 + \\frac{31}{70} + 0.8 = 1.05 + \\frac{31}{70} = \\frac{21}{20} + \\frac{31}{70} = \\frac{147+62}{140} = \\frac{209}{140}$。\n$\\gamma_{22} = \\frac{209}{140} \\cdot \\frac{1}{0.75} = \\frac{209}{140} \\cdot \\frac{4}{3} = \\frac{209}{105}$。\n\n所以，平稳协方差矩阵是 $\\boldsymbol{\\Gamma} = \\begin{pmatrix} \\frac{25}{16}  \\frac{31}{28} \\\\ \\frac{31}{28}  \\frac{209}{105} \\end{pmatrix}$。\n\n接下来，我们计算条件方差 $\\operatorname{Var}(X_{t-1} \\mid Y_{t-1})$。由于该过程是平稳且高斯的，我们使用二元正态分布中条件方差的标准公式：\n$$\n\\operatorname{Var}(X_{t-1} \\mid Y_{t-1}) = \\operatorname{Var}(X_{t-1}) - \\frac{\\operatorname{Cov}(X_{t-1}, Y_{t-1})^2}{\\operatorname{Var}(Y_{t-1})} = \\gamma_{11} - \\frac{\\gamma_{12}^2}{\\gamma_{22}}\n$$\n$$\n\\operatorname{Var}(X_{t-1} \\mid Y_{t-1}) = \\frac{25}{16} - \\frac{(31/28)^2}{209/105} = \\frac{25}{16} - \\frac{961/784}{209/105} = \\frac{25}{16} - \\frac{961}{784} \\frac{105}{209}\n$$\n化简该分数： $\\frac{961 \\cdot 105}{784 \\cdot 209} = \\frac{14415}{23408}$。\n$$\n\\operatorname{Var}(X_{t-1} \\mid Y_{t-1}) = \\frac{25}{16} - \\frac{14415}{23408} = \\frac{25 \\cdot 1463 - 14415}{23408} = \\frac{36575 - 14415}{23408} = \\frac{22160}{23408} = \\frac{1385}{1463}\n$$\n\n**2. 滞后格兰杰因果（$GC_{X \\to Y}$）的计算**\n\n从$X$到$Y$的滞后格兰杰因果定义为预测误差方差之比的自然对数：\n$$\nGC_{X \\to Y} = \\ln \\left( \\frac{\\sigma^2_{\\text{restr}}}{\\sigma^2_{\\text{full}}} \\right)\n$$\n预测$Y_t$的完整模型使用了$X$和$Y$的过去值：\n$Y_t = A_{21}X_{t-1} + A_{22}Y_{t-1} + E_{2,t} = 0.4 X_{t-1} + 0.5 Y_{t-1} + E_{2,t}$。\n完整模型的单步预测误差方差是新息项$E_{2,t}$的方差，也就是$\\boldsymbol{\\Sigma}_e$的$(2,2)$元素。\n$$\n\\sigma^2_{\\text{full}} = \\operatorname{Var}(E_{2,t}) = (\\boldsymbol{\\Sigma}_{e})_{22} = 0.8\n$$\n受限模型仅使用$Y_t$自身的过去值来预测它。对于VAR($1$)过程，预测误差的方差 $\\sigma^2_{\\text{restr}} = \\operatorname{Var}(Y_t \\mid Y_{t-1}, Y_{t-2}, \\dots)$ 简化为从$Y_{t-1}$预测$Y_t$时的误差方差。该误差方差可以优雅地表示为：\n$$\n\\sigma^2_{\\text{restr}} = A_{21}^2 \\operatorname{Var}(X_{t-1} \\mid Y_{t-1}) + (\\boldsymbol{\\Sigma}_{e})_{22}\n$$\n使用在第1部分计算的条件方差：\n$$\n\\sigma^2_{\\text{restr}} = (0.4)^2 \\left(\\frac{1385}{1463}\\right) + 0.8 = 0.16 \\left(\\frac{1385}{1463}\\right) + 0.8 = \\frac{4}{25}\\frac{1385}{1463} + \\frac{4}{5} = \\frac{221.6}{1463} + \\frac{1170.4}{1463} = \\frac{1392}{1463}\n$$\n现在我们可以计算格兰杰因果：\n$$\nGC_{X \\to Y} = \\ln \\left( \\frac{1392/1463}{0.8} \\right) = \\ln \\left( \\frac{1392}{1463 \\cdot 0.8} \\right) = \\ln \\left( \\frac{1392}{1170.4} \\right) \\approx \\ln(1.189337) \\approx 0.17340\n$$\n保留四位有效数字，$GC_{X \\to Y} = 0.1734$ 奈特。\n\n**3. 瞬时格兰杰因果（$GC_{X \\leftrightarrow Y}$）的计算**\n\n瞬时因果量化了通过知晓另一个变量的同期新息，一个变量的预测误差可以减少的程度。它是由新息协方差矩阵$\\boldsymbol{\\Sigma}_e$的非对角线项产生的一个对称度量。它被计算为新息方差与条件新息方差之比的对数。\n对于$X$和$Y$之间的效应，我们将来自完整滞后模型的$Y_t$的预测误差方差 $\\operatorname{Var}(E_{2,t})$，与当我们也知道同期新息$E_{1,t}$时的误差方差 $\\operatorname{Var}(E_{2,t} \\mid E_{1,t})$ 进行比较。\n$$\nGC_{X \\leftrightarrow Y} = \\ln \\left( \\frac{\\operatorname{Var}(E_{2,t})}{\\operatorname{Var}(E_{2,t} \\mid E_{1,t})} \\right)\n$$\n条件方差由$\\boldsymbol{\\Sigma}_e$的元素计算得出：\n$$\n\\operatorname{Var}(E_{2,t} \\mid E_{1,t}) = (\\boldsymbol{\\Sigma}_{e})_{22} - \\frac{(\\boldsymbol{\\Sigma}_{e})_{21}^2}{(\\boldsymbol{\\Sigma}_{e})_{11}} = 0.8 - \\frac{(0.4)^2}{1.0} = 0.8 - 0.16 = 0.64\n$$\n因此，瞬时因果为：\n$$\nGC_{X \\leftrightarrow Y} = \\ln \\left( \\frac{0.8}{0.64} \\right) = \\ln(1.25) \\approx 0.22314\n$$\n保留四位有效数字，$GC_{X \\leftrightarrow Y} = 0.2231$ 奈特。\n\n**4. 因果解释**\n\n滞后格兰杰因果 $GC_{X \\to Y} \\approx 0.1734$，衡量了在1秒采样时间尺度上可分辨的、从$X$的过去到$Y$的现在的有向影响。这个非零值是预料之中的，因为系数$A_{21}=0.4$不为零。\n\n瞬时格兰杰因果 $GC_{X \\leftrightarrow Y} \\approx 0.2231$，量化了$X_t$和$Y_t$之间无法被其过去值解释的统计依赖性。这种同期相关性源于相关的新息（$\\Sigma_{e,12} = 0.4 \\neq 0$）。\n\n在快速信号通路的背景下，一个非零的、特别是数值较大的瞬时因果项具有关键意义。真实的分子相互作用并非瞬时发生，而是在有限的时间尺度上进行。如果采样间隔（此处为1秒）相对于实际相互作用速度来说是粗糙的，那么一个快速的因果影响（例如，在毫秒级别发生的$X \\to Y$）将被捕获在单个采样区间内。VAR模型受限于离散时间滞后，无法解析这种亚采样动态，并将快速的滞后效应错误地归因于新息中的同期相关性。因此，一个较大的瞬时因果项可能表明：(1) 一个在比采样率更快的时间尺度上发生的真实因果联系，或者 (2) 一个未被测量的共同驱动因素，它在采样间隔内同时影响$X$和$Y$。\n\n在本问题中，瞬时因果（$0.2231$ 奈特）大于滞后因果（$0.1734$ 奈特）。这强烈表明1秒的采样分辨率不足以完全解析系统的因果动态。$X$和$Y$之间的相互作用有很大一部分发生在亚采样时间尺度上，这导致了对滞后因果影响的低估，并将其错误地归因于对称的、非因果的瞬时项。要区分快速因果联系和共同驱动因素，就需要分析以更高频率采样的数据。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0.1734  0.2231\n\\end{pmatrix}\n}\n$$"
        }
    ]
}