{
    "hands_on_practices": [
        {
            "introduction": "空间转录组学数据本质上是在不同空间位置的基因表达计数。这些计数值通常表现出“过度离散”的特性，即方差大于均值。本练习将引导您从简单的泊松 ($Poisson$) 模型过渡到更符合实际的伽马-泊松 ($Gamma-Poisson$)（即负二项）模型，从而探索这种现象的统计学根源。深刻理解这一统计基础，对于为差异表达分析、细胞聚类等下游任务选择恰当的分析模型至关重要。",
            "id": "3350175",
            "problem": "考虑一项基于空间点的空间转录组学分析，该分析测量组织切片上的独立分子标识符 (UMI)。假设组织的细胞密度 $\\lambda$ (单位面积的细胞数) 是均匀的，并且每个点的面积为 $A$。设每个点的细胞数量由一个空间泊松点过程建模，因此点水平的细胞计数 $N$ 满足 $\\mathbb{E}[N]=\\lambda A$。在每个细胞内，转录分子的数量被建模为一个均值为 $\\mu$ 的独立泊松随机变量，每个转录的分子以概率 $\\eta$ (捕获效率)被独立捕获，从而每个细胞的期望捕获计数为 $\\eta \\mu$。令 $Y$ 表示每个点的总捕获UMI计数。\n\n(a) 仅使用期望的线性性和捕获过程的独立性，根据上述假设推导 $\\mathbb{E}[Y]$。\n\n(b) 在 $Y$ 服从泊松分布，且其均值等于(a)部分推导出的期望值的模型假设下，计算 $\\operatorname{Var}(Y)$。\n\n(c)现在通过伽马-泊松混合模型引入点水平的异质性：设潜在的捕获前点水平转录本强度为 $\\Lambda \\sim \\mathrm{Gamma}(\\kappa,\\theta)$，其中形状参数 $\\kappa>0$，尺度参数 $\\theta$ 的选择使得 $\\mathbb{E}[\\Lambda]=\\lambda A \\mu$。在给定 $\\Lambda$ 的条件下，假设 $Y \\mid \\Lambda \\sim \\mathrm{Poisson}(\\eta \\Lambda)$。使用全期望定律和全方差定律，计算在此伽马-泊松混合模型下的 $\\mathbb{E}[Y]$ 和 $\\operatorname{Var}(Y)$。用 $\\eta$、$\\lambda$、$A$、$\\mu$ 和 $\\kappa$ 的符号形式表示您的最终答案。\n\n以单个行向量的形式提供最终答案，其中按顺序包含：均值 $\\mathbb{E}[Y]$、泊松假设下的方差，以及伽马-泊松（负二项）假设下的方差。无需四舍五入，最终表达式中不应包含任何物理单位。",
            "solution": "经评估，用户提供的问题是有效的。该问题具有科学依据，定义明确，客观且内部一致，是计算系统生物学中统计建模的一个标准练习。因此，我们可以进行完整解答。\n\n该问题分为三个部分。我们将依次解答每个部分，以求得最终答案所需的量。所需的量分别是：每个点的总UMI计数的期望值 $\\mathbb{E}[Y]$，简单泊松假设下 $Y$ 的方差，以及更复杂的伽马-泊松混合模型下 $Y$ 的方差。\n\n(a) 使用期望的线性性推导 $\\mathbb{E}[Y]$。\n\n令 $N$ 为一个点中的细胞数量。已知 $N$ 服从一个空间泊松点过程，其期望为 $\\mathbb{E}[N] = \\lambda A$，其中 $\\lambda$ 是细胞密度，$A$ 是点的面积。\n令 $X_i$ 为来自细胞 $i$ 的捕获UMI数量，其中 $i = 1, \\dots, N$。\n每个点的总捕获UMI计数 $Y$ 是该点中所有细胞计数之和：\n$$Y = \\sum_{i=1}^{N} X_i$$\n这是一个随机个随机变量的和。我们可以使用全期望定律（在此情境下也称为瓦尔德等式）来求其期望：\n$$\\mathbb{E}[Y] = \\mathbb{E}[\\mathbb{E}[Y \\mid N]]$$\n首先，我们求给定细胞数 $N$ 时 $Y$ 的条件期望。对于固定的细胞数 $N=n$，$Y = \\sum_{i=1}^{n} X_i$。根据期望的线性性：\n$$\\mathbb{E}[Y \\mid N=n] = \\mathbb{E}\\left[\\sum_{i=1}^{n} X_i\\right] = \\sum_{i=1}^{n} \\mathbb{E}[X_i]$$\n我们需要确定 $\\mathbb{E}[X_i]$。问题陈述，一个细胞中转录分子的数量是一个均值为 $\\mu$ 的泊松随机变量。然后，这些分子中的每一个都以独立的概率 $\\eta$ 被捕获。这个过程被称为泊松分布的稀疏化。如果一个随机变量 $K \\sim \\mathrm{Poisson}(\\mu)$，并且 $K$ 个项目中的每一个都以概率 $\\eta$ 被保留，则得到的保留项目计数 $X_i$ 服从均值为 $\\eta\\mu$ 的泊松分布。\n因此，每个细胞的期望捕获UMI数量为 $\\mathbb{E}[X_i] = \\eta\\mu$。\n由于每个细胞的过程都是相同的，所有的 $X_i$ 都是独立同分布的。所以：\n$$\\mathbb{E}[Y \\mid N=n] = \\sum_{i=1}^{n} (\\eta\\mu) = n\\eta\\mu$$\n这表明条件期望 $\\mathbb{E}[Y \\mid N]$ 是随机变量 $N\\eta\\mu$。\n现在，我们对 $N$ 取期望：\n$$\\mathbb{E}[Y] = \\mathbb{E}[N\\eta\\mu]$$\n再次使用期望的线性性：\n$$\\mathbb{E}[Y] = \\eta\\mu \\mathbb{E}[N]$$\n代入给定的 $\\mathbb{E}[N] = \\lambda A$：\n$$\\mathbb{E}[Y] = \\lambda A \\eta \\mu$$\n\n(b) 在简单泊松模型下计算 $\\operatorname{Var}(Y)$。\n\n在这一部分，我们被要求假设总UMI计数 $Y$ 服从一个泊松分布，其均值等于在(a)部分推导的期望值。\n设此泊松分布的参数为 $\\nu = \\mathbb{E}[Y]$。从(a)部分，我们有：\n$$\\nu = \\lambda A \\eta \\mu$$\n所以，我们假设 $Y \\sim \\mathrm{Poisson}(\\nu) = \\mathrm{Poisson}(\\lambda A \\eta \\mu)$。\n泊松分布的一个基本性质是其方差等于其均值。\n因此，在此假设下 $Y$ 的方差是：\n$$\\operatorname{Var}(Y) = \\nu = \\lambda A \\eta \\mu$$\n\n(c) 在伽马-泊松混合模型下计算 $\\mathbb{E}[Y]$ 和 $\\operatorname{Var}(Y)$。\n\n在这个模型中，总UMI计数 $Y$ 是分层建模的。\n首先，一个表示点中总捕获前转录本强度的潜变量 $\\Lambda$ 从伽马分布中抽取：\n$$\\Lambda \\sim \\mathrm{Gamma}(\\kappa, \\theta)$$\n其中 $\\kappa > 0$ 是形状参数，$\\theta$ 是尺度参数。\n尺度参数 $\\theta$ 由 $\\Lambda$ 的期望约束指定：\n$$\\mathbb{E}[\\Lambda] = \\lambda A \\mu$$\n一个 $\\mathrm{Gamma}(\\kappa, \\theta)$ 分布的期望是 $\\mathbb{E}[\\Lambda] = \\kappa\\theta$。将其与约束条件相等，得到：\n$$\\kappa\\theta = \\lambda A \\mu \\implies \\theta = \\frac{\\lambda A \\mu}{\\kappa}$$\n在给定这个潜在强度 $\\Lambda$ 的条件下，观测到的UMI计数 $Y$ 服从均值为 $\\eta\\Lambda$ 的泊松分布：\n$$Y \\mid \\Lambda \\sim \\mathrm{Poisson}(\\eta\\Lambda)$$\n这种分层结构是一个伽马-泊松混合，它导致 $Y$ 服从负二项分布。我们被要求使用全期望定律和全方差定律来计算 $\\mathbb{E}[Y]$ 和 $\\operatorname{Var}(Y)$。\n\n首先，$Y$ 的期望：\n$$\\mathbb{E}[Y] = \\mathbb{E}[\\mathbb{E}[Y \\mid \\Lambda]]$$\n内部的期望是条件泊松分布的均值：\n$$\\mathbb{E}[Y \\mid \\Lambda] = \\eta\\Lambda$$\n现在，对 $\\Lambda$ 取期望：\n$$\\mathbb{E}[Y] = \\mathbb{E}[\\eta\\Lambda] = \\eta\\mathbb{E}[\\Lambda]$$\n使用给定的约束 $\\mathbb{E}[\\Lambda] = \\lambda A \\mu$：\n$$\\mathbb{E}[Y] = \\eta(\\lambda A \\mu) = \\lambda A \\eta \\mu$$\n这个结果与(a)部分得到的结果一致。\n\n接下来，$Y$ 的方差：\n全方差定律表明：\n$$\\operatorname{Var}(Y) = \\mathbb{E}[\\operatorname{Var}(Y \\mid \\Lambda)] + \\operatorname{Var}(\\mathbb{E}[Y \\mid \\Lambda])$$\n我们分别计算每一项。\n第一项是条件方差的期望。条件泊松分布 $Y \\mid \\Lambda \\sim \\mathrm{Poisson}(\\eta\\Lambda)$ 的方差等于其均值：\n$$\\operatorname{Var}(Y \\mid \\Lambda) = \\eta\\Lambda$$\n对这个量关于 $\\Lambda$ 取期望：\n$$\\mathbb{E}[\\operatorname{Var}(Y \\mid \\Lambda)] = \\mathbb{E}[\\eta\\Lambda] = \\eta\\mathbb{E}[\\Lambda] = \\eta(\\lambda A \\mu) = \\lambda A \\eta \\mu$$\n第二项是条件期望的方差。我们已经找到了条件期望：\n$$\\mathbb{E}[Y \\mid \\Lambda] = \\eta\\Lambda$$\n这个量的方差是：\n$$\\operatorname{Var}(\\mathbb{E}[Y \\mid \\Lambda]) = \\operatorname{Var}(\\eta\\Lambda) = \\eta^2 \\operatorname{Var}(\\Lambda)$$\n我们需要 $\\operatorname{Var}(\\Lambda)$。对于一个 $\\mathrm{Gamma}(\\kappa, \\theta)$ 分布，方差是 $\\operatorname{Var}(\\Lambda) = \\kappa\\theta^2$。代入 $\\theta = \\frac{\\lambda A \\mu}{\\kappa}$：\n$$\\operatorname{Var}(\\Lambda) = \\kappa \\left(\\frac{\\lambda A \\mu}{\\kappa}\\right)^2 = \\kappa \\frac{(\\lambda A \\mu)^2}{\\kappa^2} = \\frac{(\\lambda A \\mu)^2}{\\kappa}$$\n因此，第二项是：\n$$\\operatorname{Var}(\\mathbb{E}[Y \\mid \\Lambda]) = \\eta^2 \\left(\\frac{(\\lambda A \\mu)^2}{\\kappa}\\right) = \\frac{\\eta^2 (\\lambda A \\mu)^2}{\\kappa}$$\n最后，我们将两项相加得到总方差：\n$$\\operatorname{Var}(Y) = \\lambda A \\eta \\mu + \\frac{\\eta^2 (\\lambda A \\mu)^2}{\\kappa}$$\n这个表达式表明，在伽马-泊松模型下，方差大于均值 ($\\lambda A \\eta \\mu$)，这种现象被称为过度离散。项 $\\frac{\\eta^2 (\\lambda A \\mu)^2}{\\kappa}$ 量化了这部分额外的方差。\n\n结果总结：\n1.  $Y$ 的均值：$\\mathbb{E}[Y] = \\lambda A \\eta \\mu$。\n2.  泊松假设下 $Y$ 的方差：$\\operatorname{Var}(Y) = \\lambda A \\eta \\mu$。\n3.  伽马-泊松假设下 $Y$ 的方差：$\\operatorname{Var}(Y) = \\lambda A \\eta \\mu + \\frac{\\eta^2 (\\lambda A \\mu)^2}{\\kappa}$。\n\n这三个表达式将构成最终的行向量。",
            "answer": "$$\\boxed{\\begin{pmatrix} \\lambda A \\eta \\mu & \\lambda A \\eta \\mu & \\lambda A \\eta \\mu + \\frac{\\eta^{2} (\\lambda A \\mu)^{2}}{\\kappa} \\end{pmatrix}}$$"
        },
        {
            "introduction": "要分析空间模式，我们首先必须以计算的方式来表示测量点之间的空间邻近关系。这通常通过构建一个邻域图来实现，其中每个测量点是一个节点，而空间上的邻近关系则定义了节点间的加权边。图拉普拉斯算子 ($Graph \\ Laplacian$) 是对此图结构的一种关键矩阵表示。本练习将提供构建这一基础数据结构的实践经验，并验证其关键的光谱特性，这些特性是许多执行空间平滑、聚类和识别空间变异基因算法的理论基石。",
            "id": "3350213",
            "problem": "考虑一个空间转录组学场景，其中空间点在二维平面中表示，邻近点之间的关系被建模为一个无向加权图。对于一个有 $n$ 个标记为 $\\{0,1,\\dots,n-1\\}$ 的节点的图，设 $W \\in \\mathbb{R}^{n \\times n}$ 为一个对称加权邻接矩阵，其元素 $w_{ij}$ 对所有 $i$ 满足 $w_{ii} = 0$。对于一个指定的无向邻居对集合 $\\mathcal{E} \\subset \\{(i,j) \\mid i \\neq j\\}$ 和每个节点的坐标 $\\{(x_i, y_i)\\}_{i=0}^{n-1}$，定义欧几里得距离 $d_{ij} = \\sqrt{(x_i - x_j)^2 + (y_i - y_j)^2}$。对于 $(i,j) \\in \\mathcal{E}$，通过径向基函数定义权重 $w_{ij} = \\exp\\left(-\\frac{d_{ij}^2}{\\sigma^2}\\right)$，否则设置 $w_{ij} = 0$。设 $D \\in \\mathbb{R}^{n \\times n}$ 为对角度矩阵，其元素为 $D_{ii} = \\sum_{j=0}^{n-1} w_{ij}$。定义未归一化的图拉普拉斯矩阵 $L = D - W$。定义对称归一化拉普拉斯矩阵 $L_{\\text{sym}} = I - D^{-1/2} W D^{-1/2}$，其中 $I$ 是 $n \\times n$ 的单位矩阵，$D^{-1/2}$ 定义为：如果 $d_i = D_{ii} > 0$，则 $(D^{-1/2})_{ii} = d_i^{-1/2}$；如果 $d_i = 0$，则 $(D^{-1/2})_{ii} = 0$。\n\n根据加权图和网络扩散的基本原理，$L$ 和 $L_{\\text{sym}}$ 的谱特性包括所有特征值的非负性，以及对于 $L_{\\text{sym}}$，其特征值上限为 $2$。$L$ 和 $L_{\\text{sym}}$ 的零特征值的重数等于图的连通分量数。$L$ 的特征值之和等于 $\\operatorname{trace}(L)$。\n\n你的任务是实现一个完整的程序，该程序：\n- 使用 $w_{ij} = \\exp\\left(-\\frac{d_{ij}^2}{\\sigma^2}\\right)$ 为 $(i,j) \\in \\mathcal{E}$ 构建 $W$，并满足 $w_{ij} = w_{ji}$ 和 $w_{ii} = 0$。\n- 计算 $D$、$L = D - W$ 和 $L_{\\text{sym}} = I - D^{-1/2} W D^{-1/2}$，并遵循当 $D_{ii} = 0$ 时对 $D^{-1/2}$ 的规定。\n- 计算 $L$ 和 $L_{\\text{sym}}$ 的完整特征谱。\n- 为每个测试用例验证以下内容：\n  1. $L$ 谱的非负性：$L$ 的所有特征值 $\\lambda$ 在数值容差 $\\varepsilon = 10^{-8}$ 内满足 $\\lambda \\geq 0$。\n  2. $L_{\\text{sym}}$ 谱的非负性：$L_{\\text{sym}}$ 的所有特征值 $\\lambda$ 在容差 $\\varepsilon$ 内满足 $\\lambda \\geq 0$。\n  3. $L_{\\text{sym}}$ 谱的上界：$L_{\\text{sym}}$ 的最大特征值 $\\lambda_{\\max}$ 在容差 $\\varepsilon$ 内满足 $\\lambda_{\\max} \\leq 2$。\n  4. $L$ 的零特征值的重数：在容差 $\\varepsilon$ 内等于 $0$ 的 $L$ 的特征值数量（这是一个需要报告的整数输出）。\n  5. $L_{\\text{sym}}$ 的零特征值的重数：在容差 $\\varepsilon$ 内等于 $0$ 的 $L_{\\text{sym}}$ 的特征值数量（这是一个需要报告的整数输出）。\n  6. $L$ 的迹与特征值之和的相等性：验证 $\\left|\\sum_{i=1}^{n} \\lambda_i(L) - \\operatorname{trace}(L)\\right| \\leq \\varepsilon$ 是否成立，并相应地输出一个布尔值。\n\n使用以下测试套件。对于每个用例，都指定了坐标、邻居对 $\\mathcal{E}$ 和 $\\sigma$。必须为 $\\mathcal{E}$ 中的每一对从坐标计算距离 $d_{ij}$。\n\n测试用例 1 (连通链；正常路径):\n- $n = 4$\n- 坐标: $(0,0)$, $(1,0)$, $(2,0)$, $(3,0)$\n- 邻居对 $\\mathcal{E}$: $(0,1)$, $(1,2)$, $(2,3)$\n- $\\sigma = 1.0$\n\n测试用例 2 (两个不连通的分量):\n- $n = 6$\n- 坐标: $(0,0)$, $(1,0)$, $(2,0)$, $(10,0)$, $(11,0)$, $(12,0)$\n- 邻居对 $\\mathcal{E}$: $(0,1)$, $(1,2)$, $(3,4)$, $(4,5)$\n- $\\sigma = 0.5$\n\n测试用例 3 (三角形加一个孤立节点；零度处理):\n- $n = 4$\n- 坐标: $(0,0)$, $(1,0)$, $(0,1)$, $(5,5)$\n- 邻居对 $\\mathcal{E}$: $(0,1)$, $(0,2)$, $(1,2)$\n- $\\sigma = 2.0$\n\n测试用例 4 ($2 \\times 2$ 网格；大平滑尺度):\n- $n = 4$\n- 坐标: $(0,0)$, $(0,1)$, $(1,0)$, $(1,1)$\n- 邻居对 $\\mathcal{E}$: $(0,1)$, $(0,2)$, $(1,3)$, $(2,3)$\n- $\\sigma = 10.0$\n\n数值容差为 $\\varepsilon = 10^{-8}$。此问题中不出现角度，也没有物理单位。\n\n最终输出格式:\n- 你的程序应生成单行输出，包含所有测试用例的串联结果，形式为方括号括起来的逗号分隔列表。\n- 对于每个测试用例，按以下顺序将以下六个值附加到输出列表中：\n  1. $z_L$：在容差 $\\varepsilon$ 内等于 $0$ 的 $L$ 的特征值整数数量。\n  2. $z_{L_{\\text{sym}}}$：在容差 $\\varepsilon$ 内等于 $0$ 的 $L_{\\text{sym}}$ 的特征值整数数量。\n  3. $b_{L,\\text{nonneg}}$：一个布尔值，指示 $L$ 的所有特征值是否在容差内 $\\geq 0$。\n  4. $b_{L_{\\text{sym}},\\text{nonneg}}$：一个布尔值，指示 $L_{\\text{sym}}$ 的所有特征值是否在容差内 $\\geq 0$。\n  5. $b_{L_{\\text{sym}},\\max \\le 2}$：一个布尔值，指示 $\\max \\lambda(L_{\\text{sym}}) \\leq 2$ 是否在容差内成立。\n  6. $b_{\\text{trace-eigs}}$：一个布尔值，指示 $\\left|\\sum_{i=1}^{n} \\lambda_i(L) - \\operatorname{trace}(L)\\right| \\leq \\varepsilon$ 是否成立。\n- 因此，对于 4 个测试用例，输出列表总共必须包含 24 个条目，按测试用例 1 到 4 的顺序排列。\n\n你的程序必须显式实现所有计算，并生成上述的单行输出。",
            "solution": "该问题要求实现一种算法，用于构建和分析源自空间数据的图拉普拉斯矩阵。这是计算系统生物学中分析空间转录组学数据集的一项常见任务。该解决方案涉及构建两种类型的图拉普拉斯矩阵：未归一化的拉普拉斯矩阵 $L$ 和对称归一化的拉普拉斯矩阵 $L_{\\text{sym}}$，计算它们的特征谱，并根据谱图理论的既定定理验证这些谱的几个基本性质。\n\n该过程对几个测试用例执行，每个用例由一组具有二维坐标 $\\{(x_i, y_i)\\}_{i=0}^{n-1}$ 的节点、一组邻居对 $\\mathcal{E}$ 和一个长度尺度参数 $\\sigma$ 定义。\n\n**第 1 步：构建加权邻接矩阵 $W$**\n\n该图由一个 $n \\times n$ 的加权邻接矩阵 $W$ 表示。该矩阵的元素 $w_{ij}$ 量化了节点 $i$ 和 $j$ 之间连接的强度。\n- 该图是无向的，因此 $W$ 是对称的，即 $w_{ij} = w_{ji}$。\n- 按照惯例，没有自环，因此对角线元素为零：对于所有 $i \\in \\{0, \\dots, n-1\\}$，$w_{ii} = 0$。\n- 对于邻居集合 $\\mathcal{E}$ 中指定的节点对 $(i,j)$，权重 $w_{ij}$ 使用径向基函数（高斯核）计算，该函数依赖于节点之间的欧几里得距离 $d_{ij} = \\sqrt{(x_i - x_j)^2 + (y_i - y_j)^2}$：\n$$ w_{ij} = \\exp\\left(-\\frac{d_{ij}^2}{\\sigma^2}\\right) $$\n该函数确保较近的节点有更强的连接（更大的权重），参数 $\\sigma$ 控制影响的空间尺度。\n- 如果一对 $(i,j)$ 不在 $\\mathcal{E}$ 中，则它们之间没有直接的边，其权重设为零：$w_{ij} = 0$。\n\n**第 2 步：构建图拉普拉斯矩阵 $L$ 和 $L_{\\text{sym}}$**\n\n从邻接矩阵 $W$ 中，可以导出两个拉普拉斯矩阵。\n\n- **度矩阵 $D$**：首先，我们定义度矩阵 $D$，它是一个对角矩阵。每个对角线元素 $D_{ii}$ 是节点 $i$ 的度，定义为连接到它的所有边的权重之和：\n$$ D_{ii} = d_i = \\sum_{j=0}^{n-1} w_{ij} $$\n- **未归一化的图拉普拉斯矩阵 $L$**：该拉普拉斯矩阵定义为度矩阵和邻接矩阵之差：\n$$ L = D - W $$\n由于 $D$ 是对角的且 $W$ 是对称的，矩阵 $L$ 保证是实对称的。\n\n- **对称归一化的图拉普拉斯矩阵 $L_{\\text{sym}}$**：该拉普拉斯矩阵是 $L$ 的一个归一化版本，它考虑了节点度的差异。其定义为：\n$$ L_{\\text{sym}} = I - D^{-1/2} W D^{-1/2} $$\n其中 $I$ 是 $n \\times n$ 的单位矩阵。矩阵 $D^{-1/2}$ 是一个对角矩阵，其元素由以下公式给出：\n$$ (D^{-1/2})_{ii} = \\begin{cases} d_i^{-1/2}  \\text{若 } d_i > 0 \\\\ 0  \\text{若 } d_i = 0 \\end{cases} $$\n对度为零（$d_i=0$）的节点进行这种特殊处理至关重要。这些是孤立节点，此定义确保它们在数学框架中得到正确处理，有效地将它们解耦，并导出一个定义明确的 $L_{\\text{sym}}$。与 $L$ 一样，$L_{\\text{sym}}$ 也是实对称的。\n\n**第 3 步：谱分析与性质验证**\n\n任务的核心是计算 $L$ 和 $L_{\\text{sym}}$ 的特征值，并验证它们的理论性质。由于两个矩阵都是实对称的，它们的特征值都是实数。`numpy.linalg.eigh` 函数非常适合此任务，因为它针对厄米特（实对称）矩阵进行了优化，并保证了实值结果。设 $\\lambda_k(M)$ 表示矩阵 $M$ 的第 $k$ 个特征值。对于每个测试用例，使用 $\\varepsilon = 10^{-8}$ 的数值容差验证以下六个性质。\n\n1.  **$L$ 的零特征值的重数 ($z_L$)**：计算满足 $|\\lambda_k(L)| \\leq \\varepsilon$ 的特征值 $\\lambda_k(L)$ 的数量。\n2.  **$L_{\\text{sym}}$ 的零特征值的重数 ($z_{L_{\\text{sym}}}$)**：计算满足 $|\\lambda_k(L_{\\text{sym}})| \\leq \\varepsilon$ 的特征值 $\\lambda_k(L_{\\text{sym}})$ 的数量。\n    - *理论原理*：谱图论的一个基本定理指出，对于 $L$ 和 $L_{\\text{sym}}$，特征值 $0$ 的重数等于图中的连通分量数。因此，这两个输出预计是与此数量相对应的整数。\n3.  **$L$ 谱的非负性 ($b_{L,\\text{nonneg}}$)**：此布尔检查验证 $L$ 的所有特征值是否为非负，即 $\\min_k(\\lambda_k(L)) \\geq -\\varepsilon$。\n4.  **$L_{\\text{sym}}$ 谱的非负性 ($b_{L_{\\text{sym}},\\text{nonneg}}$)**：此布尔检查验证 $L_{\\text{sym}}$ 的所有特征值是否为非负，即 $\\min_k(\\lambda_k(L_{\\text{sym}})) \\geq -\\varepsilon$。\n    - *理论原理*：对于任何具有非负边权重 $w_{ij} \\geq 0$ 的图，$L$ 和 $L_{\\text{sym}}$ 都是半正定矩阵。此性质在数学上意味着它们的所有特征值都必须是实数且非负。\n5.  **$L_{\\text{sym}}$ 谱的上界 ($b_{L_{\\text{sym}},\\max \\le 2}$)**：此布尔检查验证 $L_{\\text{sym}}$ 的最大特征值是否最多为 $2$，即 $\\max_k(\\lambda_k(L_{\\text{sym}})) \\leq 2 + \\varepsilon$。\n    - *理论原理*：另一个已确立的结果是，对于任何具有非负权重的图，$L_{\\text{sym}}$ 的所有特征值的上界为 $2$。\n6.  **$L$ 的迹与特征值之和的相等性 ($b_{\\text{trace-eigs}}$)**：此布尔检查验证 $L$ 的特征值之和是否等于其迹，即 $|\\sum_{k=0}^{n-1} \\lambda_k(L) - \\operatorname{trace}(L)| \\leq \\varepsilon$。\n    - *理论原理*：这是任何方阵的一般性质。矩阵的迹在基变换下是不变的，并且始终等于其特征值之和。这可作为特征值计算的数值健全性检查。\n\n该算法被系统地应用于每个测试用例，并将得到的六个值（$z_L$，$z_{L_{\\text{sym}}}$ 和四个布尔值）串联成一个单一列表作为最终输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    It defines the test cases, processes each one, and prints the final formatted result.\n    \"\"\"\n    \n    # Numerical tolerance for floating-point comparisons\n    epsilon = 1e-8\n\n    # Define the test cases as specified in the problem statement.\n    test_cases = [\n        {\n            \"n\": 4,\n            \"coords\": np.array([(0, 0), (1, 0), (2, 0), (3, 0)]),\n            \"neighbor_pairs\": [(0, 1), (1, 2), (2, 3)],\n            \"sigma\": 1.0,\n        },\n        {\n            \"n\": 6,\n            \"coords\": np.array([(0, 0), (1, 0), (2, 0), (10, 0), (11, 0), (12, 0)]),\n            \"neighbor_pairs\": [(0, 1), (1, 2), (3, 4), (4, 5)],\n            \"sigma\": 0.5,\n        },\n        {\n            \"n\": 4,\n            \"coords\": np.array([(0, 0), (1, 0), (0, 1), (5, 5)]),\n            \"neighbor_pairs\": [(0, 1), (0, 2), (1, 2)],\n            \"sigma\": 2.0,\n        },\n        {\n            \"n\": 4,\n            \"coords\": np.array([(0, 0), (0, 1), (1, 0), (1, 1)]),\n            \"neighbor_pairs\": [(0, 1), (0, 2), (1, 3), (2, 3)],\n            \"sigma\": 10.0,\n        },\n    ]\n\n    all_results = []\n    for case in test_cases:\n        results = process_case(case['n'], case['coords'], case['neighbor_pairs'], case['sigma'], epsilon)\n        all_results.extend(results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\ndef process_case(n, coords, neighbor_pairs, sigma, epsilon):\n    \"\"\"\n    Processes a single test case to compute and verify graph Laplacian properties.\n    \"\"\"\n    \n    # Step 1: Construct the weighted adjacency matrix W\n    W = np.zeros((n, n), dtype=np.float64)\n    sigma_sq = sigma**2\n    for i, j in neighbor_pairs:\n        dist_sq = np.sum((coords[i] - coords[j])**2)\n        weight = np.exp(-dist_sq / sigma_sq)\n        W[i, j] = weight\n        W[j, i] = weight\n\n    # Step 2: Construct D, L, and L_sym\n    # Degree matrix D\n    d_vec = np.sum(W, axis=1)\n    D = np.diag(d_vec)\n\n    # Unnormalized Laplacian L\n    L = D - W\n\n    # Symmetric normalized Laplacian L_sym\n    # First, compute D^{-1/2} carefully handling zero-degree nodes\n    d_inv_sqrt_vec = np.zeros(n, dtype=np.float64)\n    # Find indices where degree is positive\n    positive_degree_indices = d_vec > 0\n    # Compute d^{-1/2} only for positive degrees\n    d_inv_sqrt_vec[positive_degree_indices] = d_vec[positive_degree_indices]**(-0.5)\n    D_inv_sqrt = np.diag(d_inv_sqrt_vec)\n    \n    I = np.identity(n)\n    L_sym = I - D_inv_sqrt @ W @ D_inv_sqrt\n\n    # Step 3: Compute Eigenvalues\n    # Use eigh for symmetric matrices; it's more stable and guarantees real eigenvalues.\n    # It returns eigenvalues sorted in non-decreasing order.\n    eigs_L = np.linalg.eigh(L)[0]\n    eigs_L_sym = np.linalg.eigh(L_sym)[0]\n\n    # Step 4: Perform Verifications\n    \n    # 1. Multiplicity of zero eigenvalue of L\n    z_L = np.sum(np.abs(eigs_L) = epsilon)\n    \n    # 2. Multiplicity of zero eigenvalue of L_sym\n    z_L_sym = np.sum(np.abs(eigs_L_sym) = epsilon)\n    \n    # 3. Nonnegativity of L's spectrum\n    b_L_nonneg = bool(eigs_L[0] >= -epsilon)\n    \n    # 4. Nonnegativity of L_sym's spectrum\n    b_L_sym_nonneg = bool(eigs_L_sym[0] >= -epsilon)\n    \n    # 5. Upper bound of L_sym's spectrum\n    b_L_sym_max_le_2 = bool(eigs_L_sym[-1] = 2 + epsilon)\n    \n    # 6. Trace-eigenvalue equality for L\n    trace_L = np.trace(L)\n    sum_eigs_L = np.sum(eigs_L)\n    b_trace_eigs = bool(np.abs(sum_eigs_L - trace_L) = epsilon)\n\n    return [z_L, z_L_sym, b_L_nonneg, b_L_sym_nonneg, b_L_sym_max_le_2, b_trace_eigs]\n\n# Execute the main function\nsolve()\n```"
        },
        {
            "introduction": "一项成功的空间转录组学研究需要周密的规划，尤其是在固定的预算下，如何在采样点的数量和每个点的测序深度之间做出权衡。本练习运用基于负二项广义线性模型的统计功效分析，来解决这一核心的权衡问题。通过完成这项实践，您将学会如何在实验设计中做出有原则、有数据支持的决策，从而最大化发现真实生物学信号的机会。",
            "id": "3350152",
            "problem": "您正在设计一项空间转录组学研究，其中总成本需要在空间点数量和每个点的测序深度之间进行权衡。令 $n$ 为空间点的数量，$s$ 为每个点的测序深度。总成本建模为 $C = c_n n + c_s n s$，其中 $c_n$ 是每个点的设置成本，$c_s$ 是每个读数（或每个深度单位）的成本。您必须选择整数 $n$ 和整数 $s$，并满足固定预算 $C \\le C_{\\max}$ 以及最低可行性约束 $n \\ge n_{\\min}$ 和 $s \\ge s_{\\min}$。\n\n建模假设与定义：\n- 对于指定集合 $\\mathcal{G}$ 中的每个基因 $g$，每个点的计数遵循负二项 (NB) 分布，其均值为 $\\mu_{g i}$，方差为 $\\mu_{g i} + \\phi_g \\mu_{g i}^2$，其中 $\\phi_g \\ge 0$ 是基因特异性离散度。\n- 使用带有对数连接函数的广义线性模型 (GLM)，通过在 $n$ 个点上的单个标准化空间对比度 $z_i$ 来检测空间信号，该对比度满足 $\\sum_{i=1}^{n} z_i = 0$ 和 $\\sum_{i=1}^{n} z_i^2 = n$。均值参数化为 $\\log \\mu_{g i} = \\log(s m_g) + \\theta_g z_i$，其中 $m_g$ 是基因的基线丰度，$\\theta_g$ 是其真实空间效应大小。\n- 每个基因的检测在 GLM 框架内使用显著性水平为 $\\alpha$ 的双边 Wald 检验。原假设为 $H_0: \\theta_g = 0$，备择假设为 $H_1: \\theta_g \\ne 0$。请使用 GLM 理论和负二项方差设定所隐含的标准大样本正态近似，推导期望功效作为 $n$ 和 $s$ 的函数。推导必须从这些定义出发，而不是从任何简便公式开始。\n\n目标：\n- 对于每个给定的测试用例，计算整数分配 $(n^\\star, s^\\star)$，以在满足约束条件 $c_n n + c_s n s \\le C_{\\max}$、$n \\ge n_{\\min}$ 和 $s \\ge s_{\\min}$ 的前提下，最大化指定基因集 $\\mathcal{G}$ 上的平均期望功效。\n- 如果多个分配在数值容差范围内达到相同的最大平均期望功效，则选择最大的 $n$ 来打破平局；如果仍然平局，则选择最大的 $s$。\n- 如果没有可行的分配，则该测试用例返回 $[0,0,0.0]$。\n\n测试套件：\n- 对于每个测试用例，给定 $(C_{\\max}, c_n, c_s, n_{\\min}, s_{\\min}, \\alpha, \\mathcal{G})$，其中 $\\mathcal{G}$ 以三元组 $(m_g, \\phi_g, \\theta_g)$ 的列表形式提供。\n- 使用以下四个测试用例：\n  1. 测试用例 1：\n     - $C_{\\max} = 12000$, $c_n = 100$, $c_s = 1$, $n_{\\min} = 50$, $s_{\\min} = 10$, $\\alpha = 0.05$。\n     - $\\mathcal{G} = \\{(0.02, 0.05, 0.30), (0.05, 0.10, 0.25), (0.10, 0.20, 0.20), (0.20, 0.20, 0.15), (0.50, 0.30, 0.12), (1.00, 0.40, 0.10)\\}$。\n  2. 测试用例 2：\n     - $C_{\\max} = 12000$, $c_n = 500$, $c_s = 1$, $n_{\\min} = 10$, $s_{\\min} = 10$, $\\alpha = 0.05$。\n     - $\\mathcal{G} = \\{(0.02, 0.05, 0.30), (0.05, 0.10, 0.25), (0.10, 0.20, 0.20), (0.20, 0.20, 0.15), (0.50, 0.30, 0.12), (1.00, 0.40, 0.10)\\}$。\n  3. 测试用例 3：\n     - $C_{\\max} = 12000$, $c_n = 100$, $c_s = 5$, $n_{\\min} = 30$, $s_{\\min} = 5$, $\\alpha = 0.05$。\n     - $\\mathcal{G} = \\{(0.05, 0.20, 0.20), (0.10, 0.30, 0.15), (0.20, 0.30, 0.12), (0.30, 0.40, 0.10)\\}$。\n  4. 测试用例 4 (边界可行性)：\n     - $C_{\\max} = 4400$, $c_n = 200$, $c_s = 2$, $n_{\\min} = 20$, $s_{\\min} = 10$, $\\alpha = 0.01$。\n     - $\\mathcal{G} = \\{(0.10, 0.40, 0.25), (0.20, 0.50, 0.20), (0.40, 0.60, 0.15)\\}$。\n\n程序要求：\n- 您的程序必须为每个测试用例计算最优的 $(n^\\star, s^\\star)$ 以及在双边显著性水平 $\\alpha$ 下，$\\mathcal{G}$ 上的相应平均期望功效。\n- 每个基因的期望功效必须根据上述 GLM 和负二项分布假设，使用对数连接函数和标准化空间对比度，从第一性原理进行计算。计算应依赖于大样本 Wald 检验近似和正态分布累积分布函数 (CDF) 的标准性质。在您的推理中，不要假设任何预先推导的简便公式；请从给定的定义中推导所需内容。\n- 最终输出格式必须是单行，包含一个逗号分隔的结果列表。每个结果都是一个三元组 $[n^\\star,s^\\star,\\overline{p}]$，其中 $\\overline{p}$ 等于在 $\\mathcal{G}$ 上的平均期望功效，四舍五入到恰好 6 位小数。整行不应包含空格。例如，它应该看起来像 `[[n_1,s_1,p_1],[n_2,s_2,p_2],[n_3,s_3,p_3],[n_4,s_4,p_4]]`。",
            "solution": "我们从负二项 (NB) 分布和广义线性模型 (GLM) 框架开始。对于每个基因 $g$，在点 $i$ 的计数 $Y_{g i}$ 的均值为 $\\mu_{g i}$，方差为 $\\operatorname{Var}(Y_{g i}) = \\mu_{g i} + \\phi_g \\mu_{g i}^2$，其中 $\\phi_g \\ge 0$。我们使用带有对数连接函数的模型，以及在 $n$ 个点上满足 $\\sum_{i=1}^{n} z_i = 0$ 和 $\\sum_{i=1}^{n} z_i^2 = n$ 的单个标准化空间对比度 $z_i$。均值结构为\n$$\n\\log \\mu_{g i} = \\log(s m_g) + \\theta_g z_i,\n$$\n因此 $\\mu_{g i} = s m_g \\exp(\\theta_g z_i)$。为了在备择假设下获得推断功效，我们考虑在显著性水平 $\\alpha$ 下，对 $H_0: \\theta_g = 0$ 与 $H_1: \\theta_g \\ne 0$ 进行双边 Wald 检验。\n\n根据具有典则连接函数和使用大样本近似的 GLM 理论，单个参数的 Wald 统计量使用关于 $\\theta_g$ 的费雪信息。在 $\\theta_g$ 的一阶近似下（对于小到中等效应大小），我们在 $H_0$ 下将 $\\mu_{g i}$ 近似为 $\\mu_{g i} \\approx s m_g$，这个值在各个点上是常数。对于对数连接函数，均值关于 $\\theta_g$ 的导数为\n$$\n\\frac{\\partial \\mu_{g i}}{\\partial \\theta_g} = \\mu_{g i} z_i \\approx (s m_g) z_i.\n$$\n在 NB 的拟似然或均值-方差设定下，方差函数为 $V(\\mu) = \\mu + \\phi_g \\mu^2 = \\mu (1 + \\phi_g \\mu)$。那么，根据标准的 GLM 推导，在 $H_0$ 下，每个点对 $\\theta_g$ 的费雪信息的贡献为\n$$\nI_{g i} = \\frac{\\left(\\frac{\\partial \\mu_{g i}}{\\partial \\theta_g}\\right)^2}{\\operatorname{Var}(Y_{g i})}\n\\approx \\frac{(s m_g)^2 z_i^2}{s m_g + \\phi_g (s m_g)^2}\n= \\frac{(s m_g) z_i^2}{1 + \\phi_g (s m_g)}.\n$$\n对 $i = 1,\\dots,n$ 求和并使用 $\\sum_{i=1}^{n} z_i^2 = n$，得到费雪信息\n$$\nI_g(n,s) \\approx \\sum_{i=1}^{n} I_{g i}\n= \\frac{n \\, s \\, m_g}{1 + \\phi_g \\, s \\, m_g}.\n$$\n\nWald 检验统计量可以写作 $Z_g = \\widehat{\\theta}_g \\sqrt{I_g}$，在 $H_0$ 下，它近似服从标准正态分布。在真实效应 $\\theta_g \\ne 0$ 下，$\\widehat{\\theta}_g$ 近似服从均值为 $\\theta_g$、方差为 $1/I_g$ 的正态分布，因此 $Z_g$ 近似服从均值为 $\\theta_g \\sqrt{I_g}$、方差为 1 的正态分布。定义非中心化参数\n$$\n\\lambda_g(n,s) = \\theta_g^2 \\, I_g(n,s) = \\theta_g^2 \\, \\frac{n \\, s \\, m_g}{1 + \\phi_g \\, s \\, m_g}.\n$$\n令 $z_{1-\\alpha/2}$ 为标准正态分布的 $(1-\\alpha/2)$ 分位数，令 $\\Phi(\\cdot)$ 表示标准正态累积分布函数 (CDF)。基因 $g$ 的双边功效为\n$$\n\\operatorname{power}_g(n,s)\n= \\Pr\\big(|Z_g|  z_{1-\\alpha/2}\\big)\n= \\Phi\\big(-z_{1-\\alpha/2} - \\sqrt{\\lambda_g(n,s)}\\big)\n+ 1 - \\Phi\\big(z_{1-\\alpha/2} - \\sqrt{\\lambda_g(n,s)}\\big).\n$$\n基因集 $\\mathcal{G}$ 的平均功效为\n$$\n\\overline{P}(n,s) = \\frac{1}{|\\mathcal{G}|} \\sum_{g \\in \\mathcal{G}} \\operatorname{power}_g(n,s).\n$$\n\n我们必须在预算和可行性约束条件 $c_n n + c_s n s \\le C_{\\max}$、$n \\ge n_{\\min}$ 和 $s \\ge s_{\\min}$ 下，最大化 $\\overline{P}(n,s)$，其中 $n$ 和 $s$ 为整数。对于固定的 $n$，费雪信息 $I_g(n,s)$ 关于 $s$ 是严格递增的，因为\n$$\n\\frac{d}{ds} \\left( \\frac{s m_g}{1 + \\phi_g s m_g} \\right)\n= \\frac{m_g}{\\big(1 + \\phi_g s m_g\\big)^2}  0,\n$$\n所以对于任何固定的 $n$，最优的选择是将 $s$ 设置为预算允许的最大整数：$s \\le \\left\\lfloor \\frac{C_{\\max} - c_n n}{c_s n} \\right\\rfloor$。因此，我们可以在可行范围 $n_{\\min} \\le n \\le \\left\\lfloor \\frac{C_{\\max}}{c_n + c_s s_{\\min}} \\right\\rfloor$ 内对 $n$ 进行搜索，计算 $s_{\\max}(n) = \\left\\lfloor \\frac{C_{\\max} - c_n n}{c_s n} \\right\\rfloor$，如果 $s_{\\max}(n)  s_{\\min}$ 则舍弃该 $n$，否则评估 $\\overline{P}(n,s_{\\max}(n))$。在所有可行的 $(n,s)$ 对中，选择 $\\overline{P}$ 最大的那一对；对于数值容差内的平局，选择最大的 $n$，如果仍然平局，则选择最大的 $s$。\n\n每个测试用例的算法步骤：\n1. 枚举从 $n_{\\min}$ 到 $\\left\\lfloor \\frac{C_{\\max}}{c_n + c_s s_{\\min}} \\right\\rfloor$ 的整数 $n$。\n2. 对每个 $n$，计算 $s_{\\max}(n) = \\left\\lfloor \\frac{C_{\\max} - c_n n}{c_s n} \\right\\rfloor$；如果 $s_{\\max}(n)  s_{\\min}$，则跳过。\n3. 使用上述带有 $\\lambda_g(n,s)$ 的公式和在显著性水平 $\\alpha$ 下的正态 CDF，计算 $\\overline{P}(n,s_{\\max}(n))$。\n4. 通过最大化 $\\overline{P}$ 追踪最佳的 $(n,s)$；通过选择最大的 $n$，然后是最大的 $s$ 来解决平局。\n5. 如果不存在可行的 $(n,s)$，则该测试返回 $[0,0,0.0]$。\n6. 将最佳平均功效四舍五入到恰好 6 位小数以供输出。\n\n将此方法应用于提供的测试套件，会得到一组确定的最优整数分配及其四舍五入后的平均期望功效。最终程序打印包含四个结果的单行，格式为 `[[n_1^\\star,s_1^\\star,\\overline{p}_1],[n_2^\\star,s_2^\\star,\\overline{p}_2],[n_3^\\star,s_3^\\star,\\overline{p}_3],[n_4^\\star,s_4^\\star,\\overline{p}_4]]`，不含空格。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom math import floor, sqrt, isclose\nfrom scipy.stats import norm\n\ndef fisher_information_nbinom(n, s, m, phi):\n    \"\"\"\n    Fisher information for theta (single standardized spatial contrast)\n    under NB GLM with log link and standardized z (sum z^2 = n),\n    using first-order approximation at the null.\n    I_g(n,s) = n * s * m / (1 + phi * s * m)\n    \"\"\"\n    mu = s * m\n    denom = 1.0 + phi * mu\n    return n * mu / denom\n\ndef gene_power(n, s, m, phi, theta, alpha):\n    \"\"\"\n    Two-sided Wald test power for one gene under NB GLM assumptions.\n    Power = Phi(-z - sqrt(lambda)) + 1 - Phi(z - sqrt(lambda)),\n    where lambda = theta^2 * I and z = z_{1 - alpha/2}.\n    \"\"\"\n    I = fisher_information_nbinom(n, s, m, phi)\n    lam = (theta * theta) * I\n    delta = sqrt(lam) if lam > 0.0 else 0.0\n    zthr = norm.ppf(1.0 - alpha / 2.0)\n    # Compute using CDF of standard normal\n    return norm.cdf(-zthr - delta) + (1.0 - norm.cdf(zthr - delta))\n\ndef average_power(n, s, genes, alpha):\n    \"\"\"\n    Average power across a set of genes, each as (m, phi, theta).\n    \"\"\"\n    if n = 0 or s = 0:\n        return 0.0\n    powers = [gene_power(n, s, m, phi, theta, alpha) for (m, phi, theta) in genes]\n    return float(np.mean(powers)) if powers else 0.0\n\ndef optimize_allocation(Cmax, c_n, c_s, n_min, s_min, alpha, genes, tie_tol=1e-12):\n    \"\"\"\n    Search over feasible n, set s to max allowed for each n, and pick the pair\n    that maximizes average expected power; ties broken by largest n, then largest s.\n    If infeasible, return (0, 0, 0.0).\n    \"\"\"\n    # Upper bound for n given minimum s\n    if c_n + c_s * s_min = 0:\n        return (0, 0, 0.0)\n    n_upper = Cmax // (c_n + c_s * s_min)\n    if n_upper  n_min:\n        return (0, 0, 0.0)\n\n    best_n, best_s, best_power = 0, 0, -1.0\n    for n in range(n_min, int(n_upper) + 1):\n        # Max s for this n under budget\n        denom = c_s * n\n        if denom = 0:\n            continue\n        s_max = (Cmax - c_n * n) // denom\n        if s_max  s_min:\n            continue\n        s = int(s_max)\n        avg_p = average_power(n, s, genes, alpha)\n\n        if avg_p > best_power + tie_tol:\n            best_n, best_s, best_power = n, s, avg_p\n        elif isclose(avg_p, best_power, rel_tol=0.0, abs_tol=tie_tol):\n            # Tie-break: prefer larger n, then larger s\n            if n > best_n or (n == best_n and s > best_s):\n                best_n, best_s, best_power = n, s, avg_p\n\n    if best_power  0.0:\n        return (0, 0, 0.0)\n    return (best_n, best_s, best_power)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1\n        {\n            \"Cmax\": 12000, \"c_n\": 100, \"c_s\": 1, \"n_min\": 50, \"s_min\": 10, \"alpha\": 0.05,\n            \"genes\": [\n                (0.02, 0.05, 0.30),\n                (0.05, 0.10, 0.25),\n                (0.10, 0.20, 0.20),\n                (0.20, 0.20, 0.15),\n                (0.50, 0.30, 0.12),\n                (1.00, 0.40, 0.10),\n            ]\n        },\n        # Test case 2\n        {\n            \"Cmax\": 12000, \"c_n\": 500, \"c_s\": 1, \"n_min\": 10, \"s_min\": 10, \"alpha\": 0.05,\n            \"genes\": [\n                (0.02, 0.05, 0.30),\n                (0.05, 0.10, 0.25),\n                (0.10, 0.20, 0.20),\n                (0.20, 0.20, 0.15),\n                (0.50, 0.30, 0.12),\n                (1.00, 0.40, 0.10),\n            ]\n        },\n        # Test case 3\n        {\n            \"Cmax\": 12000, \"c_n\": 100, \"c_s\": 5, \"n_min\": 30, \"s_min\": 5, \"alpha\": 0.05,\n            \"genes\": [\n                (0.05, 0.20, 0.20),\n                (0.10, 0.30, 0.15),\n                (0.20, 0.30, 0.12),\n                (0.30, 0.40, 0.10),\n            ]\n        },\n        # Test case 4 (boundary feasibility)\n        {\n            \"Cmax\": 4400, \"c_n\": 200, \"c_s\": 2, \"n_min\": 20, \"s_min\": 10, \"alpha\": 0.01,\n            \"genes\": [\n                (0.10, 0.40, 0.25),\n                (0.20, 0.50, 0.20),\n                (0.40, 0.60, 0.15),\n            ]\n        },\n    ]\n\n    results_str_parts = []\n    for case in test_cases:\n        n_star, s_star, avg_power_star = optimize_allocation(\n            Cmax=case[\"Cmax\"],\n            c_n=case[\"c_n\"],\n            c_s=case[\"c_s\"],\n            n_min=case[\"n_min\"],\n            s_min=case[\"s_min\"],\n            alpha=case[\"alpha\"],\n            genes=case[\"genes\"],\n        )\n        # Round average power to exactly 6 decimal places for output\n        avg_str = f\"{avg_power_star:.6f}\"\n        results_str_parts.append(f\"[{n_star},{s_star},{avg_str}]\")\n\n    # Final print statement in the exact required format: no spaces.\n    print(\"[\" + \",\".join(results_str_parts) + \"]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}