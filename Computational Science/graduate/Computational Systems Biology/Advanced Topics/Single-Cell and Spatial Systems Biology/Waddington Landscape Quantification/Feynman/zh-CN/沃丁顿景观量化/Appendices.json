{
    "hands_on_practices": [
        {
            "introduction": "在量化沃丁顿景观时，一个首要问题是：对于一个给定的细胞动态系统（由漂移场 $\\boldsymbol{f}(\\boldsymbol{x})$ 描述），是否存在一个标量势能 $U(\\boldsymbol{x})$ 使得 $\\boldsymbol{f}(\\boldsymbol{x}) = -\\nabla U(\\boldsymbol{x})$？这个练习将引导你通过计算漂移场的“旋度”来回答这一根本问题，这是判断系统是否为梯度系统的关键测试。此外，当系统由于非平衡过程而导致势能不存在时，本练习将教你如何使用最小二乘法构建一个最接近原始动态的“有效”梯度势景。",
            "id": "3358340",
            "problem": "在Waddington景观量化的背景下，考虑一个二维基因调控漂移场。设状态为 $\\boldsymbol{x} = (x,y) \\in \\Omega \\subset \\mathbb{R}^2$，其确定性漂移场为 $\\boldsymbol{f}(\\boldsymbol{x}) = (f_1(x,y), f_2(x,y))$。梯度Waddington景观由一个标量势 $U(\\boldsymbol{x})$ 表示，当此势存在时，满足 $\\boldsymbol{f}(\\boldsymbol{x}) = -\\nabla U(\\boldsymbol{x})$。\n\n从以下基本依据出发：(i) 矢量微积分中的Poincaré引理，该引理指出，在单连通域上的一个连续可微矢量场是保守场的充要条件是其旋度为零；(ii) 保守场的线积分与路径无关的存在性；以及 (iii) 在Schwarz定理的假设下，混合二阶偏导数的相等性。基于这些，推导在 $\\boldsymbol{f}$ 和 $\\Omega$ 上存在 $U(\\boldsymbol{x})$ 的充要条件。当此条件不成立时，定义一个最小二乘法程序，以近似一个梯度场 $\\widehat{\\boldsymbol{g}}(\\boldsymbol{x}) = \\nabla \\widehat{U}(\\boldsymbol{x})$，该梯度场在最小化采样点网格上的经验平方误差的意义上最佳匹配 $\\boldsymbol{f}(\\boldsymbol{x})$。\n\n您的程序必须实现以下任务：\n\n- 给定 $\\Omega = [-L,L] \\times [-L,L]$ 上的一个包含 $N \\times N$ 个点的均匀方形网格，使用二阶有限差分来近似标量旋度\n$$\\omega(x,y) = \\frac{\\partial f_2}{\\partial x}(x,y) - \\frac{\\partial f_1}{\\partial y}(x,y)$$\n当且仅当 $\\max_{(x,y)\\in\\Omega} |\\omega(x,y)| \\le \\tau$ 时，声明势存在，其中 $\\tau$ 是一个指定的数值容差。\n\n- 通过将 $\\widehat{U}$ 参数化为最高3次的多项式基函数的线性组合来构建势 $\\widehat{U}(x,y)$ 的最小二乘近似：\n$$\n\\widehat{U}(x,y) = \\sum_{k=1}^{K} \\theta_k \\, \\phi_k(x,y),\n$$\n其中基为\n$$\n\\{\\phi_k\\}_{k=1}^{K} = \\{1, x, y, x^2, xy, y^2, x^3, x^2 y, x y^2, y^3\\},\n$$\n因此\n$$\n\\nabla \\widehat{U}(x,y) = \\left(\\sum_{k=1}^{K} \\theta_k \\, \\frac{\\partial \\phi_k}{\\partial x}(x,y), \\ \\sum_{k=1}^{K} \\theta_k \\, \\frac{\\partial \\phi_k}{\\partial y}(x,y)\\right).\n$$\n通过在所有采样网格点 $\\{(x_i,y_i)\\}_{i=1}^{M}$（其中 $M = N^2$）上最小化正则化最小二乘目标函数来估计 $\\boldsymbol{\\theta} \\in \\mathbb{R}^{K}$：\n$$\n\\min_{\\boldsymbol{\\theta} \\in \\mathbb{R}^{K}} \\ \\sum_{i=1}^{M} \\left\\| \\nabla \\widehat{U}(x_i,y_i) - \\boldsymbol{f}(x_i,y_i) \\right\\|_2^2 \\ + \\ \\lambda \\, \\|\\boldsymbol{\\theta}\\|_2^2,\n$$\n其中 $\\lambda \\ge 0$ 是给定的正则化参数。通过正规方程求解这个凸问题。\n\n- 通过归一化均方根误差来量化梯度近似的质量：\n$$\n\\mathrm{NRMSE} \\ = \\ \\frac{\\sqrt{\\frac{1}{M} \\sum_{i=1}^{M} \\left\\| \\nabla \\widehat{U}(x_i,y_i) - \\boldsymbol{f}(x_i,y_i) \\right\\|_2^2}}{\\sqrt{\\frac{1}{M} \\sum_{i=1}^{M} \\left\\| \\boldsymbol{f}(x_i,y_i) \\right\\|_2^2}}.\n$$\n\n在单连通域 $\\Omega$ 上使用以下包含科学上合理且自洽的矢量场的测试套件：\n\n- 测试用例1（保守线性漂移）：$L = 1$, $N = 25$, $\\tau = 10^{-6}$, $\\lambda = 10^{-8}$, 以及\n$$\nU(x,y) = \\frac{a}{2}(x^2 + y^2), \\quad a = 1, \\quad \\boldsymbol{f}(x,y) = -\\nabla U(x,y) = -a(x,y).\n$$\n\n- 测试用例2（纯旋转非保守漂移）：$L = 1$, $N = 25$, $\\tau = 10^{-6}$, $\\lambda = 10^{-8}$, 以及\n$$\n\\boldsymbol{f}(x,y) = \\big(-y, \\ x\\big).\n$$\n\n- 测试用例3（混合保守与旋转漂移）：$L = 1$, $N = 25$, $\\tau = 10^{-6}$, $\\lambda = 10^{-8}$, 以及\n$$\n\\boldsymbol{f}(x,y) = -a(x,y) + c\\big(-y,\\ x\\big), \\quad a = 1, \\ c = \\tfrac{1}{2}.\n$$\n\n对于每个测试用例，您的程序必须：\n\n- 根据旋度阈值 $\\tau$ 计算指示势是否存在的布尔值。\n- 计算最小二乘梯度近似 $\\nabla \\widehat{U}$ 相对于 $\\boldsymbol{f}$ 的 $\\mathrm{NRMSE}$。\n\n最终输出格式要求：\n\n- 将输出表示为包含一个扁平列表的单行，条目按\n$$\n[\\text{exists}_1, \\ \\mathrm{NRMSE}_1, \\ \\text{exists}_2, \\ \\mathrm{NRMSE}_2, \\ \\text{exists}_3, \\ \\mathrm{NRMSE}_3]\n$$\n顺序排列，其中 $\\text{exists}_j$ 是一个布尔值，$\\mathrm{NRMSE}_j$ 是一个四舍五入到6位小数的浮点数。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，例如 `[True,0.000001,False,0.707107,False,0.408248]`。\n- 本问题不涉及物理单位；所有量均为无量纲。",
            "solution": "我们从量化Waddington景观所需的基本矢量微积分事实开始。如果漂移场 $\\boldsymbol{f}(\\boldsymbol{x})$ 可以表示为 $\\boldsymbol{f}(\\boldsymbol{x}) = -\\nabla U(\\boldsymbol{x})$（其中 $U$ 为标量势），则存在梯度Waddington景观。Poincaré引理指出，在单连通域 $\\Omega \\subset \\mathbb{R}^2$ 上，一个连续可微矢量场 $\\boldsymbol{f}$ 是保守场的充要条件是其旋度处处为零：$\\nabla \\times \\boldsymbol{f} = \\boldsymbol{0}$。在二维情况下，这简化为标量条件\n$$\n\\omega(x,y) \\equiv \\frac{\\partial f_2}{\\partial x}(x,y) - \\frac{\\partial f_1}{\\partial y}(x,y) = 0 \\quad \\text{for all } (x,y) \\in \\Omega.\n$$\n这等价于势 $U$ 的混合偏导数相等，因为如果 $\\boldsymbol{f} = -\\nabla U$，那么 $\\frac{\\partial f_2}{\\partial x} = -\\frac{\\partial^2 U}{\\partial x \\partial y}$ 和 $\\frac{\\partial f_1}{\\partial y} = -\\frac{\\partial^2 U}{\\partial y \\partial x}$，并且在标准光滑性条件下，Schwarz定理保证 $\\frac{\\partial^2 U}{\\partial x \\partial y} = \\frac{\\partial^2 U}{\\partial y \\partial x}$。反之，如果 $\\omega \\equiv 0$ 且 $\\Omega$ 是单连通的，那么对于连接两点的任意曲线 $\\gamma$，线积分 $\\int_{\\gamma} \\boldsymbol{f} \\cdot d\\boldsymbol{\\ell}$ 与路径无关，并且可以通过 $U(\\boldsymbol{x}) = -\\int_{\\gamma_{\\boldsymbol{x}_0 \\to \\boldsymbol{x}}} \\boldsymbol{f} \\cdot d\\boldsymbol{\\ell}$ 定义 $U$（相差一个加性常数）。\n\n在实践中，我们在网格上有采样数据，因此我们通过有限差分来近似旋度。在两个方向上间距均为 $h$ 的均匀网格上，我们在内部使用二阶中心差分来近似 $\\frac{\\partial f_2}{\\partial x}$ 和 $\\frac{\\partial f_1}{\\partial y}$。将数值旋度记为 $\\widehat{\\omega}(x_i,y_j)$。如果 $\\max_{i,j} |\\widehat{\\omega}(x_i,y_j)| \\le \\tau$，我们就声明势存在，其中 $\\tau$ 是一个指定的容差，用于解释离散化和舍入误差。\n\n当旋度条件被违反时，能够精确匹配 $\\boldsymbol{f}$ 的标量势无法全局存在。然而，在Waddington景观量化中，获得在采样域上对 $\\boldsymbol{f}$ 的最佳梯度近似是有用的。这是将 $\\boldsymbol{f}$ 投影到梯度场子空间的一个实例，也是Helmholtz–Hodge分解的一个特例。我们通过在由基函数 $\\{\\phi_k\\}_{k=1}^{K}$ 张成的有限维函数空间中寻找 $\\widehat{U}$，并使用Tikhonov正则化最小化 $\\nabla \\widehat{U}$ 和 $\\boldsymbol{f}$ 之间的经验平方差异来实现这一点：\n$$\n\\min_{\\boldsymbol{\\theta}\\in\\mathbb{R}^{K}} \\sum_{i=1}^{M} \\left\\| \\nabla \\widehat{U}(x_i,y_i) - \\boldsymbol{f}(x_i,y_i) \\right\\|_2^2 + \\lambda \\|\\boldsymbol{\\theta}\\|_2^2,\n$$\n其中 $\\widehat{U}(x,y) = \\sum_{k=1}^{K} \\theta_k \\phi_k(x,y)$。将 $\\nabla \\widehat{U}(x_i,y_i)$ 写成 $\\boldsymbol{\\theta}$ 的线性函数，会得到一个线性最小二乘问题。定义设计矩阵 $A_x \\in \\mathbb{R}^{M \\times K}$ 和 $A_y \\in \\mathbb{R}^{M \\times K}$，其元素为\n$$\n(A_x)_{i,k} = \\frac{\\partial \\phi_k}{\\partial x}(x_i,y_i), \\qquad (A_y)_{i,k} = \\frac{\\partial \\phi_k}{\\partial y}(x_i,y_i).\n$$\n设 $A \\in \\mathbb{R}^{2M \\times K}$ 是 $A_x$ 和 $A_y$ 的垂直堆叠，设 $\\boldsymbol{b} \\in \\mathbb{R}^{2M}$ 是堆叠观测到的漂移分量的矢量：$\\boldsymbol{b} = (f_1(x_1,y_1),\\ldots,f_1(x_M,y_M), f_2(x_1,y_1),\\ldots,f_2(x_M,y_M))^\\top$。问题变为\n$$\n\\min_{\\boldsymbol{\\theta}} \\ \\|A \\boldsymbol{\\theta} - \\boldsymbol{b}\\|_2^2 + \\lambda \\|\\boldsymbol{\\theta}\\|_2^2,\n$$\n其最优性条件得出正规方程\n$$\n(A^\\top A + \\lambda I)\\boldsymbol{\\theta} = A^\\top \\boldsymbol{b}.\n$$\n我们使用一个数值稳定的线性求解器来解这些方程以求得 $\\boldsymbol{\\theta}$。得到 $\\boldsymbol{\\theta}$ 后，我们在每个网格点上计算 $\\nabla \\widehat{U}$ 并计算归一化均方根误差\n$$\n\\mathrm{NRMSE} = \\frac{\\sqrt{\\frac{1}{M} \\sum_{i=1}^{M} \\left\\| \\nabla \\widehat{U}(x_i,y_i) - \\boldsymbol{f}(x_i,y_i) \\right\\|_2^2}}{\\sqrt{\\frac{1}{M} \\sum_{i=1}^{M} \\left\\| \\boldsymbol{f}(x_i,y_i) \\right\\|_2^2}}.\n$$\n\n我们将此过程应用于指定的测试套件：\n\n- 测试用例1使用一个从二次势 $U(x,y) = \\frac{a}{2}(x^2+y^2)$（其中 $a=1$）导出的保守线性漂移，因此 $\\boldsymbol{f}(x,y) = -(x,y)$。域 $\\Omega$ 是单连通的且 $\\omega \\equiv 0$，所以势存在。多项式基包含 $x^2$ 和 $y^2$，因此最小二乘近似可以精确恢复梯度场（在数值精度范围内）。因此，我们预期布尔值为${\\tt True}$，$\\mathrm{NRMSE}$ 接近于0。\n\n- 测试用例2使用一个纯旋转场 $\\boldsymbol{f}(x,y) = (-y, x)$，其 $\\omega(x,y) \\equiv 2$，所以势不存在。最小二乘梯度近似将此场投影到所选基函数张成的梯度空间上。由于该场在对称域上的连续 $L^2$ 意义下与无旋场正交，我们预期会有显著的残差。因此，我们预期布尔值为${\\tt False}$，$\\mathrm{NRMSE}$ 明显不为0。\n\n- 测试用例3将测试用例1的保守场与一个大小为 $c = \\tfrac{1}{2}$ 的旋转分量混合。旋度为非零常数，因此不存在精确的势，但最小二乘法程序将有效捕捉保守分量，导致一个中等的$\\mathrm{NRMSE}$。因此，我们预期布尔值为${\\tt False}$，$\\mathrm{NRMSE}$ 介于测试用例1和2之间。\n\n实现细节包括：\n\n- 在 $\\Omega = [-L,L]^2$ 上构建网格，其中 $L=1$ 和 $N=25$，得到间距 $h = \\frac{2L}{N-1}$。\n- 通过二阶中心差分计算数值旋度，使用 $\\frac{\\partial f_2}{\\partial x} \\approx \\frac{f_2(x+h,y) - f_2(x-h,y)}{2h}$ 和 $\\frac{\\partial f_1}{\\partial y} \\approx \\frac{f_1(x,y+h) - f_1(x,y-h)}{2h}$，并在边界处进行一致性处理。\n- 通过正规方程进行最小二乘估计，其中 $\\lambda = 10^{-8}$。\n- 每个测试用例的最终输出是布尔存在性决策和四舍五入到6位小数的$\\mathrm{NRMSE}$，聚合为一个在单行上打印的扁平列表。\n\n这些步骤整合了Waddington势存在的理论条件，以及在无旋条件被违反时近似漂移场梯度分量的一种有原则的数值方法。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef make_grid(L, N):\n    xs = np.linspace(-L, L, N)\n    ys = np.linspace(-L, L, N)\n    X, Y = np.meshgrid(xs, ys, indexing='xy')\n    return X, Y\n\ndef field_conservative_linear(X, Y, a=1.0):\n    # f = -a * (x, y)\n    f1 = -a * X\n    f2 = -a * Y\n    return f1, f2\n\ndef field_rotational(X, Y):\n    # f = (-y, x)\n    f1 = -Y\n    f2 = X\n    return f1, f2\n\ndef field_mixed(X, Y, a=1.0, c=0.5):\n    f1c, f2c = field_conservative_linear(X, Y, a=a)\n    f1r, f2r = field_rotational(X, Y)\n    return f1c + c * f1r, f2c + c * f2r\n\ndef numerical_curl(f1, f2, L, N):\n    # Compute curl omega = d f2 / dx - d f1 / dy using central differences\n    # Grid spacing\n    h = 2 * L / (N - 1)\n    # Use numpy.gradient with spacing h (second-order in interior)\n    df2_dx = np.gradient(f2, h, axis=1)\n    df1_dy = np.gradient(f1, h, axis=0)\n    omega = df2_dx - df1_dy\n    return omega\n\ndef build_basis_and_grads(X, Y):\n    # Returns gradients of basis functions evaluated at all points\n    # Basis: [1, x, y, x^2, x y, y^2, x^3, x^2 y, x y^2, y^3]\n    x = X.ravel()\n    y = Y.ravel()\n    ones = np.ones_like(x)\n\n    # Partial derivatives of basis functions\n    # d/dx\n    dphidx = np.stack([\n        np.zeros_like(x),       # d(1)/dx\n        ones,                   # d(x)/dx\n        np.zeros_like(x),       # d(y)/dx\n        2.0 * x,                # d(x^2)/dx\n        y,                      # d(x*y)/dx\n        np.zeros_like(x),       # d(y^2)/dx\n        3.0 * x**2,             # d(x^3)/dx\n        2.0 * x * y,            # d(x^2 y)/dx\n        y**2,                   # d(x y^2)/dx\n        np.zeros_like(x),       # d(y^3)/dx\n    ], axis=1)  # shape (M, K)\n\n    # d/dy\n    dphidy = np.stack([\n        np.zeros_like(y),       # d(1)/dy\n        np.zeros_like(y),       # d(x)/dy\n        ones,                   # d(y)/dy\n        np.zeros_like(y),       # d(x^2)/dy\n        x,                      # d(x*y)/dy\n        2.0 * y,                # d(y^2)/dy\n        np.zeros_like(y),       # d(x^3)/dy\n        x**2,                   # d(x^2 y)/dy\n        2.0 * x * y,            # d(x y^2)/dy\n        3.0 * y**2,             # d(y^3)/dy\n    ], axis=1)\n\n    return dphidx, dphidy  # each is (M, K)\n\ndef fit_potential_least_squares(X, Y, f1, f2, lam=1e-8):\n    # Build design matrix A and target b for ridge regression\n    dphidx, dphidy = build_basis_and_grads(X, Y)  # (M, K)\n    M, K = dphidx.shape\n\n    A = np.vstack([dphidx, dphidy])  # (2M, K)\n    b = np.concatenate([f1.ravel(), f2.ravel()])  # (2M,)\n\n    # Solve (A^T A + lam I) theta = A^T b\n    AtA = A.T @ A\n    Atb = A.T @ b\n    if lam > 0:\n        AtA = AtA + lam * np.eye(K)\n    theta = np.linalg.solve(AtA, Atb)\n    return theta\n\ndef eval_gradient_from_theta(X, Y, theta):\n    dphidx, dphidy = build_basis_and_grads(X, Y)  # (M, K)\n    gx = (dphidx @ theta).reshape(X.shape)\n    gy = (dphidy @ theta).reshape(Y.shape)\n    return gx, gy\n\ndef nrmse(g1, g2, f1, f2):\n    # Compute normalized RMSE between gradient g and field f\n    diff_sq = (g1 - f1)**2 + (g2 - f2)**2\n    f_sq = f1**2 + f2**2\n    mse = np.mean(diff_sq)\n    denom = np.mean(f_sq)\n    # Handle degenerate case where field is zero everywhere\n    if denom == 0:\n        return 0.0 if mse == 0 else np.inf\n    return float(np.sqrt(mse / denom))\n\ndef evaluate_case(field_func, params, L=1.0, N=25, tau=1e-6, lam=1e-8):\n    X, Y = make_grid(L, N)\n    f1, f2 = field_func(X, Y, **params)\n    omega = numerical_curl(f1, f2, L=L, N=N)\n    exists = bool(np.max(np.abs(omega)) = tau)\n    theta = fit_potential_least_squares(X, Y, f1, f2, lam=lam)\n    g1, g2 = eval_gradient_from_theta(X, Y, theta)\n    err = nrmse(g1, g2, f1, f2)\n    return exists, err\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Each test case is a tuple: (field_func, params_dict)\n        (field_conservative_linear, {\"a\": 1.0}),\n        (lambda X, Y, **kw: field_rotational(X, Y), {}),\n        (field_mixed, {\"a\": 1.0, \"c\": 0.5}),\n    ]\n    L = 1.0\n    N = 25\n    tau = 1e-6\n    lam = 1e-8\n\n    results = []\n    for field_func, params in test_cases:\n        exists, err = evaluate_case(field_func, params, L=L, N=N, tau=tau, lam=lam)\n        # Append boolean and rounded error\n        results.append(exists)\n        results.append(round(err, 6))\n\n    # Convert booleans and floats to string as required\n    def to_str(x):\n        if isinstance(x, bool):\n            return \"True\" if x else \"False\"\n        if isinstance(x, float):\n            # Ensure fixed formatting with up to 6 decimals, no scientific notation if possible\n            return f\"{x:.6f}\"\n        return str(x)\n\n    print(f\"[{','.join(to_str(r) for r in results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "一旦我们确定了景观中的吸引子（代表稳定的细胞命运），下一步便是深入分析它们的局部特性。吸引子周围景观的局部“形状”或曲率，在数学上由Hessian矩阵 $H$ 描述，它直接决定了该细胞状态的稳定性以及围绕它的随机波动（即表型变异）的幅度。这个练习提供了一个具体的计算任务，旨在将抽象的Hessian矩阵与弛豫时间和表型方差等可测量的生物学特性联系起来，从而深化对景观形态如何支配局部动态的理解。",
            "id": "3358338",
            "problem": "考虑一个粗粒化基因调控系统，该系统被建模为在 Waddington 表观遗传景观上的一个过阻尼随机微分方程 (SDE)，其状态向量 $x \\in \\mathbb{R}^{n}$ 的演化遵循\n$$\ndx \\,=\\, -\\nabla U(x)\\,dt \\,+\\, \\sqrt{2D}\\,dW_t,\n$$\n其中 $U(x)$ 是塑造该景观的标量势，$D$ 是标量扩散系数，$W_t$ 是标准维纳过程。一个吸引子 $x^{\\ast}$ 位于 $U(x)$ 的一个局部最小值处，因此其黑塞矩阵 (Hessian) $H \\equiv \\nabla^{2} U(x^{\\ast})$ 是对称且正定的。在 $x^{\\ast}$ 附近的线性响应区域内，小偏差 $\\xi \\equiv x - x^{\\ast}$ 为动力学和稳态变异性提供了局部有效的近似，而曲率 $H$ 则同时调节弛豫和涨落。\n\n关注一个二维状态 ($n = 2$)，其吸引子处的曲率经实验推断如下：\n$$\nH \\,=\\, \\begin{pmatrix} 5  1 \\\\ 1  3 \\end{pmatrix},\n$$\n标量扩散系数为\n$$\nD \\,=\\, 0.2.\n$$\n假设噪声是加性的、各向同性的，并且没有外部驱动。定义一个线性表型 $y$ 为状态涨落的投影，\n$$\ny \\,=\\, c^{\\top}\\xi,\\quad c \\,=\\, \\begin{pmatrix} 1 \\\\ -2 \\end{pmatrix}.\n$$\n\n从该 SDE 和围绕稳定不动点进行线性化的基本性质（奥恩斯坦-乌伦贝克行为）出发，并使用与福克-普朗克描述一致的线性响应理论和涨落-耗散推理，推导表型 $y$ 的稳态方差以及 $x^{\\ast}$ 附近的最慢弛豫时间常数，并用给定的 $H$、$D$ 和 $c$ 表示。稳态方差的单位应与状态变量的平方单位相同，时间常数的单位应与 SDE 的时间单位相同。将最终答案表示为一个单行矩阵，其中第一个元素是 $y$ 的稳态方差，第二个元素是最慢弛豫时间常数。无需四舍五入；报告精确值。",
            "solution": "该问题要求两个量：表型 $y$ 的稳态方差和吸引子 $x^{\\ast}$ 附近的最慢弛豫时间常数。\n\n首先，我们在稳定不动点 $x^{\\ast}$ 附近对动力学进行线性化。势 $U(x)$ 在 $x^{\\ast}$ 附近的二阶泰勒展开式为：\n$$\nU(x) \\approx U(x^{\\ast}) + (\\nabla U(x^{\\ast}))^{\\top}(x - x^{\\ast}) + \\frac{1}{2}(x - x^{\\ast})^{\\top} H (x - x^{\\ast})\n$$\n由于 $x^{\\ast}$ 是一个局部最小值，梯度 $\\nabla U(x^{\\ast})$ 为零。因此，SDE 中的力项 $-\\nabla U(x)$ 可以近似为：\n$$\n-\\nabla U(x) \\approx -H(x - x^{\\ast}) = -H\\xi\n$$\n偏差 $\\xi = x - x^{\\ast}$ 的 SDE 可通过注意到 $d\\xi = dx$（因为 $x^{\\ast}$ 是一个常数向量）得到。代入线性化的力可得：\n$$\nd\\xi = -H\\xi \\,dt + \\sqrt{2D}\\,dW_t\n$$\n这是一个多维奥恩斯坦-乌伦贝克过程，它描述了系统围绕稳定吸引子的涨落。\n\n**1. 表型 $y$ 的稳态方差**\n\n该系统的稳态概率分布是一个以 $\\xi = 0$ 为中心的多变量高斯分布。该分布可以从相应的福克-普朗克方程推导得出，并且等价于玻尔兹曼分布 $P_{ss}(\\xi) \\propto \\exp(-U(\\xi)/D)$。使用势的二次近似 $U(\\xi) \\approx \\frac{1}{2}\\xi^{\\top}H\\xi$，我们得到：\n$$\nP_{ss}(\\xi) \\propto \\exp\\left(-\\frac{\\xi^{\\top}H\\xi}{2D}\\right)\n$$\n这是一个均值为 $E[\\xi] = 0$、协方差矩阵为 $\\Sigma = E[\\xi\\xi^{\\top}]$ 的多变量正态分布。这种分布的标准形式是 $P(\\xi) \\propto \\exp(-\\frac{1}{2}\\xi^{\\top}\\Sigma^{-1}\\xi)$。通过比较，我们发现 $\\Sigma^{-1} = \\frac{H}{D}$，这意味着稳态协方差矩阵为：\n$$\n\\Sigma = D H^{-1}\n$$\n这个结果是该系统涨落-耗散定理的一种体现。\n\n表型定义为 $y = c^{\\top}\\xi$。其稳态方差 $\\text{Var}(y)$ 为：\n$$\n\\text{Var}(y) = E[(y - E[y])^2]\n$$\n由于 $E[y] = E[c^{\\top}\\xi] = c^{\\top}E[\\xi] = 0$，方差简化为：\n$$\n\\text{Var}(y) = E[y^2] = E[(c^{\\top}\\xi)(c^{\\top}\\xi)^{\\top}] = E[c^{\\top}\\xi\\xi^{\\top}c]\n$$\n根据期望的线性性质，这变为：\n$$\n\\text{Var}(y) = c^{\\top} E[\\xi\\xi^{\\top}] c = c^{\\top}\\Sigma c = c^{\\top}(D H^{-1})c = D c^{\\top}H^{-1}c\n$$\n为了计算这个值，我们首先需要求出黑塞矩阵 $H$ 的逆矩阵：\n$$\nH = \\begin{pmatrix} 5  1 \\\\ 1  3 \\end{pmatrix}\n$$\n行列式为 $\\det(H) = (5)(3) - (1)(1) = 14$。逆矩阵为：\n$$\nH^{-1} = \\frac{1}{\\det(H)} \\begin{pmatrix} 3  -1 \\\\ -1  5 \\end{pmatrix} = \\frac{1}{14} \\begin{pmatrix} 3  -1 \\\\ -1  5 \\end{pmatrix}\n$$\n现在我们用 $c = \\begin{pmatrix} 1 \\\\ -2 \\end{pmatrix}$ 计算二次型 $c^{\\top}H^{-1}c$：\n$$\nc^{\\top}H^{-1}c = \\begin{pmatrix} 1  -2 \\end{pmatrix} \\left( \\frac{1}{14} \\begin{pmatrix} 3  -1 \\\\ -1  5 \\end{pmatrix} \\right) \\begin{pmatrix} 1 \\\\ -2 \\end{pmatrix}\n$$\n$$\nc^{\\top}H^{-1}c = \\frac{1}{14} \\begin{pmatrix} 1  -2 \\end{pmatrix} \\begin{pmatrix} 3(1) + (-1)(-2) \\\\ -1(1) + 5(-2) \\end{pmatrix} = \\frac{1}{14} \\begin{pmatrix} 1  -2 \\end{pmatrix} \\begin{pmatrix} 5 \\\\ -11 \\end{pmatrix}\n$$\n$$\nc^{\\top}H^{-1}c = \\frac{1}{14} ( (1)(5) + (-2)(-11) ) = \\frac{1}{14} (5 + 22) = \\frac{27}{14}\n$$\n最后，我们乘以扩散系数 $D = 0.2 = \\frac{1}{5}$：\n$$\n\\text{Var}(y) = D (c^{\\top}H^{-1}c) = \\frac{1}{5} \\times \\frac{27}{14} = \\frac{27}{70}\n$$\n\n**2. 最慢弛豫时间常数**\n\n弛豫动力学由线性化 SDE 的确定性部分 $\\frac{d\\xi}{dt} = -H\\xi$ 控制。这个线性常微分方程组的解可以表示为本征模式的叠加。每个本征模式的时间演化由一个项 $\\exp(-\\lambda_i t)$ 来表征，其中 $\\lambda_i$ 是矩阵 $H$ 的特征值。弛豫时间常数是这些特征值的倒数，即 $\\tau_i = 1/\\lambda_i$。\n\n最慢的弛豫时间 $\\tau_{\\text{slowest}}$ 对应于 $H$ 的最小特征值 $\\lambda_{\\min}$。我们通过求解特征方程 $\\det(H - \\lambda I) = 0$ 来找到特征值：\n$$\n\\det\\begin{pmatrix} 5-\\lambda  1 \\\\ 1  3-\\lambda \\end{pmatrix} = 0\n$$\n$$\n(5-\\lambda)(3-\\lambda) - (1)(1) = 0\n$$\n$$\n\\lambda^2 - 8\\lambda + 15 - 1 = 0\n$$\n$$\n\\lambda^2 - 8\\lambda + 14 = 0\n$$\n使用二次公式 $\\lambda = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}$：\n$$\n\\lambda = \\frac{8 \\pm \\sqrt{(-8)^2 - 4(1)(14)}}{2(1)} = \\frac{8 \\pm \\sqrt{64 - 56}}{2} = \\frac{8 \\pm \\sqrt{8}}{2} = \\frac{8 \\pm 2\\sqrt{2}}{2} = 4 \\pm \\sqrt{2}\n$$\n特征值为 $\\lambda_1 = 4 + \\sqrt{2}$ 和 $\\lambda_2 = 4 - \\sqrt{2}$。最小的特征值是：\n$$\n\\lambda_{\\min} = 4 - \\sqrt{2}\n$$\n最慢弛豫时间是 $\\lambda_{\\min}$ 的倒数：\n$$\n\\tau_{\\text{slowest}} = \\frac{1}{\\lambda_{\\min}} = \\frac{1}{4 - \\sqrt{2}}\n$$\n为了使分母有理化，我们将分子和分母同时乘以共轭项 $4 + \\sqrt{2}$：\n$$\n\\tau_{\\text{slowest}} = \\frac{1}{4 - \\sqrt{2}} \\times \\frac{4 + \\sqrt{2}}{4 + \\sqrt{2}} = \\frac{4 + \\sqrt{2}}{4^2 - (\\sqrt{2})^2} = \\frac{4 + \\sqrt{2}}{16 - 2} = \\frac{4 + \\sqrt{2}}{14}\n$$\n问题要求将 $y$ 的稳态方差和最慢弛豫时间常数表示为一个单行矩阵。这两个值是 $\\frac{27}{70}$ 和 $\\frac{4 + \\sqrt{2}}{14}$。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{27}{70}  \\frac{4+\\sqrt{2}}{14} \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "理解细胞命运之间的转变过程，与理解稳定状态本身同样重要。一个常见的误解是认为转变的“临界点”总是位于势垒的最高点。本练习将挑战这一直觉，并介绍承诺函数（committor function）$q(x)$ 这一更严谨的动力学概念，它被定义为从位置 $x$ 出发的系统首次到达终态B而非初态A的概率。通过计算承诺函数等于 $\\frac{1}{2}$ 的位置，我们可以精确地定位真正的过渡态——即细胞命运的“不归点”，并将其与静态的势垒顶端进行比较。",
            "id": "3358344",
            "problem": "您的任务是推导、实现并测试一种计算方法，用于在一个一维随机细胞命运模型中，使用提交函数量化瓦丁顿景观并识别过渡态。该模型是过阻尼朗之万随机微分方程（SDE），它在计算系统生物学中被广泛用于表示势能景观上的噪声动力学。该景观由一个多项式形式的类自由能势给出，其两个局部极小值代表了两个细胞命运盆地。\n\n从基本定义和定律开始：\n- 单个坐标 $x(t)$ 的过阻尼朗之万随机微分方程 (SDE) 为 $dx(t) = b(x) \\, dt + \\sqrt{2 D} \\, dW(t)$，其中 $b(x)$ 是确定性漂移，$D$ 是扩散系数（噪声强度），$W(t)$ 是标准维纳过程。\n- 对于类瓦丁顿势 $U(x)$ 上的梯度动力学，漂移为 $b(x) = - \\frac{dU}{dx}$。\n- 作用于光滑检验函数 $f(x)$ 的相关后向柯尔莫哥洛夫算子（无穷小生成元）是 $L f(x) = b(x) \\, \\frac{df}{dx}(x) + D \\, \\frac{d^2 f}{dx^2}(x)$。\n- 提交函数 $q(x)$ 定义为从 $x$ 开始的轨迹在到达A盆地之前先到达B盆地的概率，它在盆地之间的区域内满足后向方程 $L q(x) = 0$，并具有吸收边界条件 $q(x_A) = 0$ 和 $q(x_B) = 1$，其中 $x_A$ 和 $x_B$ 分别是左右两个盆地极小值点的位置。\n- 在此一维设定中，过渡态被定义为满足 $q(x_{\\mathrm{TS}}) = \\tfrac{1}{2}$ 的构型 $x_{\\mathrm{TS}}$，它在操作上代表了反应轨迹上盆地之间的分界面。\n\n您的任务：\n1. 从上述原理出发，针对一维梯度漂移 $b(x) = - \\frac{dU}{dx}$ 和常数 $D$，在边界条件 $q(x_A) = 0$ 和 $q(x_B) = 1$ 下，推导出一个可实现的提交函数 $q(x)$ 的表达式或数值计算过程。\n2. 对每个指定的势和参数集，数值计算：\n   - 在初始条件 $x_0$ 下的提交函数值 $q(x_0)$。\n   - 由 $q(x_{\\mathrm{TS}}) = \\tfrac{1}{2}$ 定义的过渡态位置 $x_{\\mathrm{TS}}$。\n   - 势垒顶点位置 $x_{\\mathrm{bar}}$，定义为 $x_A$ 和 $x_B$ 之间 $U(x)$ 的唯一局部极大值（通过 $U'(x_{\\mathrm{bar}}) = 0$ 和 $U''(x_{\\mathrm{bar}})  0$ 确定）。\n   - 绝对偏差 $\\Delta = \\left| x_{\\mathrm{TS}} - x_{\\mathrm{bar}} \\right|$。\n3. 实现一个程序，为所有测试用例计算这些量，并以要求的最终格式输出结果。\n\n景观和测试套件：\n- 考虑由 $U(x) = \\alpha \\, \\frac{x^4}{4} - \\beta \\, \\frac{x^2}{2} + \\gamma \\, x$ 参数化的类瓦丁顿势，其漂移为 $b(x) = - U'(x) = - \\left( \\alpha \\, x^3 - \\beta \\, x + \\gamma \\right)$，扩散系数 $D$ 为常数。\n- 盆地位置 $x_A$ 和 $x_B$ 分别是 $U(x)$ 最左侧和最右侧的局部极小值点。势垒顶点 $x_{\\mathrm{bar}}$ 是它们之间的局部极大值点。\n- 对于每个用例，程序应通过求解 $U'(x) = 0$ 来确定临界点，通过 $U''(x)$ 对每个临界点进行分类，然后从第一性原理出发计算 $q(x)$，而不调用任何未从上述基础推导出的捷径公式。\n\n测试用例：\n- 用例1（对称双阱，低噪声）：$\\alpha = 1$，$\\beta = 1$，$\\gamma = 0$，$D = 0.05$，$x_0 = 0.2$。\n- 用例2（对称双阱，高噪声）：$\\alpha = 1$，$\\beta = 1$，$\\gamma = 0$，$D = 1.0$，$x_0 = 0.2$。\n- 用例3（非对称双阱，中度倾斜）：$\\alpha = 1$，$\\beta = 1$，$\\gamma = 0.3$，$D = 0.05$，$x_0 = 0.0$。\n- 用例4（非对称双阱，中度倾斜反向）：$\\alpha = 1$，$\\beta = 1$，$\\gamma = -0.3$，$D = 0.05$，$x_0 = 0.0$。\n\n输出规范：\n- 对于每个用例，返回一个包含四个浮点数的列表 $[ q(x_0), x_{\\mathrm{TS}}, x_{\\mathrm{bar}}, \\Delta ]$。\n- 您的程序应生成单行输出，其中包含所有测试用例的结果，格式为这些列表的逗号分隔列表，并用方括号括起来，例如：$[[a_1,b_1,c_1,d_1],[a_2,b_2,c_2,d_2],[a_3,b_3,c_3,d_3],[a_4,b_4,c_4,d_4]]$。\n- 不涉及物理单位；所有量均为无量纲实数。",
            "solution": "### 提交函数的推导\n\n提交函数 $q(x)$ 满足后向柯尔莫哥洛夫方程 $Lq(x) = 0$。代入算子 $L$ 和梯度漂移 $b(x) = -U'(x) = -\\frac{dU}{dx}$ 的表达式，我们得到控制微分方程：\n$$\nD \\frac{d^2q}{dx^2}(x) - \\frac{dU}{dx}(x) \\frac{dq}{dx}(x) = 0\n$$\n这是一个关于 $q(x)$ 的二阶线性齐次常微分方程。为了求解它，我们可以引入一个中间变量 $p(x) = \\frac{dq}{dx}$。方程变为关于 $p(x)$ 的一阶可分离常微分方程：\n$$\nD \\frac{dp}{dx} = \\frac{dU}{dx} p(x)\n$$\n分离变量，假设 $p(x) \\neq 0$：\n$$\n\\frac{dp}{p} = \\frac{1}{D} \\frac{dU}{dx} dx\n$$\n两边积分得到：\n$$\n\\ln|p(x)| = \\frac{1}{D} U(x) + C_0\n$$\n其中 $C_0$ 是一个积分常数。对两边取指数得到：\n$$\np(x) = C_1 e^{U(x)/D}\n$$\n其中 $C_1 = \\pm e^{C_0}$ 是一个新的常数。现在，我们代回 $p(x) = \\frac{dq}{dx}$：\n$$\n\\frac{dq}{dx} = C_1 e^{U(x)/D}\n$$\n为了求出 $q(x)$，我们将此表达式从左侧盆地极小值点 $x_A$ 积分到点 $x$：\n$$\nq(x) - q(x_A) = \\int_{x_A}^{x} C_1 e^{U(s)/D} ds\n$$\n现在我们应用边界条件 $q(x_A) = 0$ 和 $q(x_B) = 1$。\n应用第一个条件，$q(x_A) = 0$：\n$$\nq(x) - 0 = C_1 \\int_{x_A}^{x} e^{U(s)/D} ds \\implies q(x) = C_1 \\int_{x_A}^{x} e^{U(s)/D} ds\n$$\n应用第二个条件，$q(x_B) = 1$：\n$$\n1 = C_1 \\int_{x_A}^{x_B} e^{U(s)/D} ds\n$$\n解出常数 $C_1$：\n$$\nC_1 = \\frac{1}{\\int_{x_A}^{x_B} e^{U(s)/D} ds}\n$$\n将 $C_1$ 的表达式代回 $q(x)$ 的方程，我们得到提交函数的最终解析表达式：\n$$\nq(x) = \\frac{\\int_{x_A}^{x} e^{U(s)/D} ds}{\\int_{x_A}^{x_B} e^{U(s)/D} ds}\n$$\n这个表达式是精确的，并且可以使用数值积分方法进行数值实现以计算积分。\n\n### 计算流程\n\n对于每个测试用例，执行以下步骤：\n\n1.  **识别临界点**：势 $U(x) = \\alpha \\frac{x^4}{4} - \\beta \\frac{x^2}{2} + \\gamma x$ 的临界点是其导数 $U'(x) = \\alpha x^3 - \\beta x + \\gamma = 0$ 的根。解这个三次方程以找到临界点。使用二阶导数 $U''(x) = 3\\alpha x^2 - \\beta$ 来对它们进行分类：如果 $U''(x_c)  0$，点 $x_c$ 是局部极小值点；如果 $U''(x_c)  0$，则是局部极大值点。对于给定的参数，存在三个不同的实根。最左侧和最右侧的根是盆地极小值点，分别指定为 $x_A$ 和 $x_B$，中间的根是势垒顶点 $x_{\\mathrm{bar}}$。\n\n2.  **计算提交函数值 $q(x_0)$**：使用推导出的公式，计算在给定点 $x_0$ 的提交函数值。积分通过数值方法计算。设被积函数为 $I(s) = e^{U(s)/D}$。那么：\n    $$\n    q(x_0) = \\frac{\\int_{x_A}^{x_0} I(s) ds}{\\int_{x_A}^{x_B} I(s) ds}\n    $$\n\n3.  **寻找过渡态 $x_{\\mathrm{TS}}$**：过渡态位置 $x_{\\mathrm{TS}}$ 由 $q(x_{\\mathrm{TS}}) = \\frac{1}{2}$ 定义。这等同于求解关于 $x_{\\mathrm{TS}}$ 的以下方程：\n    $$\n    \\frac{\\int_{x_A}^{x_{\\mathrm{TS}}} e^{U(s)/D} ds}{\\int_{x_A}^{x_B} e^{U(s)/D} ds} = \\frac{1}{2}\n    $$\n    这相当于找到函数 $F(x) = \\left( \\int_{x_A}^{x} e^{U(s)/D} ds \\right) - \\frac{1}{2} \\left( \\int_{x_A}^{x_B} e^{U(s)/D} ds \\right) = 0$ 的根。由于被积函数 $e^{U(s)/D}$ 是严格为正的，该积分是其积分上限的单调递增函数。因此，在区间 $(x_A, x_B)$ 内存在唯一的根 $x_{\\mathrm{TS}}$，并且可以使用像Brent-Dekker方法这样的数值求根算法高效地找到它。\n\n4.  **计算偏差 $\\Delta$**：计算过渡态位置与势垒顶点之间的绝对差值 $\\Delta = |x_{\\mathrm{TS}} - x_{\\mathrm{bar}}|$。这个值量化了由于势的不对称性或显著噪声的存在，动力学分界线 ($x_{\\mathrm{TS}}$) 相对于静态分界线 ($x_{\\mathrm{bar}}$) 的偏移。在对称、低噪声极限下，$\\Delta$ 趋近于 $0$。\n\n这个流程在提供的Python代码中实现，该代码系统地处理每个测试用例并计算所需的量。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate, optimize\n\ndef solve():\n    \"\"\"\n    Derives, implements, and tests a computational method for quantifying\n    the Waddington landscape using committor functions.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (alpha, beta, gamma, D, x0)\n        (1.0, 1.0, 0.0, 0.05, 0.2),\n        (1.0, 1.0, 0.0, 1.0, 0.2),\n        (1.0, 1.0, 0.3, 0.05, 0.0),\n        (1.0, 1.0, -0.3, 0.05, 0.0),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        result = process_case(*case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Format each inner list of floats to a string representation.\n    formatted_results = [\n        f\"[{','.join(f'{val:.8f}' for val in res)}]\" for res in results\n    ]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef process_case(alpha, beta, gamma, D, x0):\n    \"\"\"\n    Processes a single test case to compute the required quantities.\n    \"\"\"\n    \n    # 1. Define potential landscape U(x) and its derivatives\n    U = lambda x: alpha * x**4 / 4 - beta * x**2 / 2 + gamma * x\n    U_prime_coeffs = [alpha, 0, -beta, gamma] # for alpha*x^3 - beta*x + gamma\n    U_double_prime = lambda x: 3 * alpha * x**2 - beta\n\n    # 2. Find critical points (x_A, x_bar, x_B)\n    # Roots of U'(x) = 0\n    crit_points = np.roots(U_prime_coeffs)\n    \n    # Filter for real roots and sort them\n    real_crit_points = sorted([p.real for p in crit_points if np.isclose(p.imag, 0)])\n\n    # Classify critical points using the second derivative test\n    minima = []\n    maxima = []\n    for cp in real_crit_points:\n        if U_double_prime(cp) > 0:\n            minima.append(cp)\n        elif U_double_prime(cp)  0:\n            maxima.append(cp)\n\n    # For a double-well potential, we expect two minima and one maximum\n    if len(minima) != 2 or len(maxima) != 1:\n        raise ValueError(f\"Unexpected number of critical points for case with params {alpha, beta, gamma}.\")\n\n    x_A = min(minima)\n    x_B = max(minima)\n    x_bar = maxima[0]\n\n    # 3. Define the integrand and the committor function q(x)\n    integrand = lambda s: np.exp(U(s) / D)\n\n    # The denominator of the committor function formula\n    total_integral, _ = integrate.quad(integrand, x_A, x_B)\n\n    def q(x):\n        # The numerator of the committor function formula\n        numerator_integral, _ = integrate.quad(integrand, x_A, x)\n        return numerator_integral / total_integral\n\n    # 4. Compute q(x0)\n    q_x0 = q(x0)\n    \n    # 5. Find the transition state x_TS where q(x) = 1/2\n    # This involves finding the root of q(x) - 0.5 = 0\n    # The function is guaranteed to be monotonic, so a robust solver can be used.\n    try:\n        x_TS = optimize.brentq(lambda x: q(x) - 0.5, x_A, x_B)\n    except ValueError:\n        # Handle edge cases where x_TS might be at the boundary\n        if np.isclose(q(x_A) - 0.5, 0):\n            x_TS = x_A\n        elif np.isclose(q(x_B) - 0.5, 0):\n            x_TS = x_B\n        else:\n            raise\n\n    # 6. Compute the discrepancy Delta\n    delta = np.abs(x_TS - x_bar)\n    \n    return [q_x0, x_TS, x_bar, delta]\n\nif __name__ == '__main__':\n    solve()\n\n```"
        }
    ]
}