{
    "hands_on_practices": [
        {
            "introduction": "要真正掌握RNA速度，最好的方法莫过于亲手构建其分析流程。本节练习将指导你完成一个从零开始的RNA速度分析管道，虽然经过简化，但包含了所有核心环节。你将学习如何处理原始的剪接与未剪接计数数据，通过线性模型估计基因速度，并最终将这些离散的速度估计投影和平滑成一个连续的矢量场，从而直观地揭示细胞动态。",
            "id": "3346376",
            "problem": "给定一个小型单细胞剪接和未剪接信使核糖核酸 (mRNA) 计数矩阵集合，要求您实现一个完整的、可复现的预处理和归一化流程，适用于下游的核糖核酸 (RNA) 速度分析和向量场估计。该流程必须从基本原理构建，并且必须包含以下步骤：(i) 带有目标文库大小的细胞级文库大小归一化，(ii) 添加伪计数以稳定比率和对数，(iii) 对数变换，(iv) 基因级标准化，(v) 对每个基因进行未剪接对剪接的线性回归，以获得基于残差的速度估计，(vi) 将基因级速度投影到基于剪接数据的主成分分析 (PCA) 派生的二维嵌入中，以及 (vii) 在指定查询点将投影速度进行基于核的平滑，以形成连续向量场。\n\n基本原理和定义：\n- 分子生物学的中心法则规定，脱氧核糖核酸 (DNA) 转录成 RNA，RNA 经过剪接和加工产生**成**熟（剪接）的转录本；观察到的每个基因的单细胞剪接和未剪接 RNA 计数源于此过程，并受到技术采样变异的影响。\n- 我们假设每个细胞 $i$ 对于每个基因 $g$ 都有观察到的非负整数剪接计数 $S_{i g}$ 和未剪接计数 $U_{i g}$。细胞级文库大小定义为 $L_i = \\sum_{g} \\left(S_{i g} + U_{i g}\\right)$。\n- 文库大小归一化的目的是重新缩放每个细胞，使总分子含量在细胞间具有可比性，这在跨群体拟合转录动力学模型之前至关重要。对数变换可以稳定方差，而基因级标准化确保了线性模型中剪接和未剪接信号的可比性。\n- 基于残差的 RNA 速度对每个基因使用一个线性模型来关联未剪接和剪接信号，并将速度估计为与拟合的稳态关系的偏差。\n\n需要实现的计算：\n1. 带有伪计数添加的细胞级文库大小归一化：\n   - 对每个细胞 $i$，计算 $L_i = \\sum_{g} \\left(S_{i g} + U_{i g}\\right)$。\n   - 给定一个目标文库大小 $L_0$ 和一个小的正数下限 $\\varepsilon_L$ 以避免除以零，定义大小因子 $s_i = \\max(L_i,\\varepsilon_L)/L_0$。\n   - 给定一个伪计数 $p > 0$，定义经过伪计数调整和归一化的计数\n     $$\n     \\tilde{S}_{i g} = \\frac{S_{i g} + p}{s_i}, \\quad \\tilde{U}_{i g} = \\frac{U_{i g} + p}{s_i}.\n     $$\n2. 对数变换：\n   - 定义对数变换后的量\n     $$\n     \\hat{S}_{i g} = \\log\\!\\left(1 + \\tilde{S}_{i g}\\right), \\quad \\hat{U}_{i g} = \\log\\!\\left(1 + \\tilde{U}_{i g}\\right).\n     $$\n3. 跨细胞的基因级标准化：\n   - 对每个基因 $g$，计算跨细胞的均值 $m^S_g = \\frac{1}{n}\\sum_i \\hat{S}_{i g}$ 和 $m^U_g = \\frac{1}{n}\\sum_i \\hat{U}_{i g}$，以及总体标准差\n     $$\n     \\sigma^S_g = \\sqrt{\\frac{1}{n}\\sum_i \\left(\\hat{S}_{i g} - m^S_g\\right)^2}, \\quad \\sigma^U_g = \\sqrt{\\frac{1}{n}\\sum_i \\left(\\hat{U}_{i g} - m^U_g\\right)^2}.\n     $$\n   - 使用一个小的数值稳定器 $\\delta > 0$，定义标准化后的量\n     $$\n     \\bar{S}_{i g} = \\frac{\\hat{S}_{i g} - m^S_g}{\\max(\\sigma^S_g,\\delta)}, \\quad \\bar{U}_{i g} = \\frac{\\hat{U}_{i g} - m^U_g}{\\max(\\sigma^U_g,\\delta)}.\n     $$\n4. 每个基因的线性回归和基于残差的速度：\n   - 对每个基因 $g$，拟合一个带截距的单变量线性模型，关联跨细胞 $i$ 的 $\\bar{U}_{i g}$ 和 $\\bar{S}_{i g}$：\n     $$\n     \\bar{U}_{i g} = \\alpha_g \\bar{S}_{i g} + \\beta_g + \\varepsilon_{i g}.\n     $$\n   - 令 $x_i = \\bar{S}_{i g}$，$y_i = \\bar{U}_{i g}$，$\\mu_x = \\frac{1}{n}\\sum_i x_i$，$\\mu_y = \\frac{1}{n}\\sum_i y_i$，$\\mathrm{var}(x)=\\frac{1}{n}\\sum_i (x_i-\\mu_x)^2$，$\\mathrm{cov}(x,y)=\\frac{1}{n}\\sum_i (x_i-\\mu_x)(y_i-\\mu_y)$。如果 $\\mathrm{var}(x) \\ge \\delta$，则设置 $\\alpha_g = \\mathrm{cov}(x,y)/\\mathrm{var}(x)$ 和 $\\beta_g = \\mu_y - \\alpha_g \\mu_x$；否则设置 $\\alpha_g = 0$ 和 $\\beta_g = \\mu_y$。将每个细胞和基因的基于残差的速度定义为\n     $$\n     v_{i g} = y_i - \\left(\\alpha_g x_i + \\beta_g\\right).\n     $$\n5. 通过主成分分析进行二维嵌入：\n   - 令 $Z$ 为一个矩阵，其元素为 $Z_{i g} = \\bar{S}_{i g}$。计算奇异值分解 $Z = U \\Sigma V^\\top$。取 $V$ 的前2列以获得基因载荷矩阵 $W \\in \\mathbb{R}^{G \\times 2}$。\n   - 将细胞的二维嵌入定义为\n     $$\n     X_i = \\sum_{g} Z_{i g} W_{g, :} \\in \\mathbb{R}^2,\n     $$\n     并将投影的速度向量定义为\n     $$\n     \\mathbf{v}^{\\mathrm{emb}}_i = \\sum_{g} v_{i g} W_{g, :} \\in \\mathbb{R}^2.\n     $$\n6. 在查询点对向量场进行核平滑：\n   - 给定一个查询点 $\\mathbf{q} \\in \\mathbb{R}^2$，一个带宽 $h > 0$，和一个权重为\n     $$\n     w_i = \\exp\\!\\left(-\\frac{\\lVert X_i - \\mathbf{q}\\rVert^2}{2 h^2}\\right)\n     $$\n     的高斯核，将 $\\mathbf{q}$ 处的平滑向量场定义为\n     $$\n     \\hat{\\mathbf{V}}(\\mathbf{q}) = \\frac{\\sum_i w_i \\, \\mathbf{v}^{\\mathrm{emb}}_i}{\\sum_i w_i}.\n     $$\n\n需要处理的边缘情况：\n- 如果某个细胞的 $L_i = 0$，则使用 $\\varepsilon_L$ 强制设置下限。\n- 如果 $\\sigma^S_g$ 或 $\\sigma^U_g$ 为零，在标准化时在分母中使用稳定器 $\\delta$。\n- 如果回归中 $\\mathrm{var}(x)  \\delta$，则设置 $\\alpha_g = 0$ 和 $\\beta_g = \\mu_y$ 以避免除以接近零的数。\n\n测试套件：\n对于每个测试用例，给定剪接计数 $S$、未剪接计数 $U$ 和参数 $(L_0, p, \\varepsilon_L, \\delta, h, \\mathbf{q})$。实现以上所有步骤 1-6，并返回平滑向量场 $\\hat{\\mathbf{V}}(\\mathbf{q})$，结果为包含两个浮点数的列表，四舍五入到六位小数。\n\n- 测试用例 1 (正常路径，中等计数):\n  - $S^{(1)} = \\begin{bmatrix} 10  5  0 \\\\ 3  8  1 \\\\ 0  2  9 \\\\ 6  4  3 \\end{bmatrix}$, $U^{(1)} = \\begin{bmatrix} 4  2  0 \\\\ 1  3  0 \\\\ 0  1  5 \\\\ 2  1  1 \\end{bmatrix}$。\n  - 参数: $L_0 = 1000.0$, $p = 1.0$, $\\varepsilon_L = 1.0$, $\\delta = 10^{-8}$, $h = 1.0$, $\\mathbf{q} = (0.0, 0.0)$。\n- 测试用例 2 (边界条件，包含零计数细胞和稀疏基因):\n  - $S^{(2)} = \\begin{bmatrix} 0  0  0 \\\\ 2  0  0 \\\\ 0  1  0 \\\\ 0  0  3 \\end{bmatrix}$, $U^{(2)} = \\begin{bmatrix} 0  0  0 \\\\ 0  1  0 \\\\ 0  0  2 \\\\ 1  0  0 \\end{bmatrix}$。\n  - 参数: $L_0 = 1000.0$, $p = 0.5$, $\\varepsilon_L = 1.0$, $\\delta = 10^{-8}$, $h = 0.5$, $\\mathbf{q} = (0.0, 0.0)$。\n- 测试用例 3 (边缘情况，包含极不均匀的文库大小和零方差基因):\n  - $S^{(3)} = \\begin{bmatrix} 1000  50  7 \\\\ 50  50  7 \\\\ 3000  50  7 \\\\ 10  50  7 \\end{bmatrix}$, $U^{(3)} = \\begin{bmatrix} 200  10  3 \\\\ 10  10  3 \\\\ 600  10  3 \\\\ 2  10  3 \\end{bmatrix}$。\n  - 参数: $L_0 = 10000.0$, $p = 1.0$, $\\varepsilon_L = 1.0$, $\\delta = 10^{-8}$, $h = 2.0$, $\\mathbf{q} = (0.0, 0.0)$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，每个测试用例对应一个包含 $\\hat{\\mathbf{V}}(\\mathbf{q})$（四舍五入到六位小数）的双元素列表。例如：$[\\,[v^{(1)}_x, v^{(1)}_y], [v^{(2)}_x, v^{(2)}_y], [v^{(3)}_x, v^{(3)}_y]\\,]$。",
            "solution": "该问题提出了一个来自计算系统生物学领域的、定义明确且有科学依据的任务：实现一个简化的RNA速度分析流程。该问题是有效的，因为它提供了一套完整的、自洽的、逻辑一致的指令、定义和测试数据。它没有科学上的不准确、模糊或矛盾之处。所描述的步骤是单细胞数据分析中的标准程序（尽管经过简化），包括归一化、变换、统计建模、降维和向量场估计。所有必需的数学公式、参数和边缘情况处理规则都已明确说明，使得问题是适定(well-posed)的，并且能够计算出唯一、可验证的解。\n\n解决方案通过系统地实现六个指定的计算步骤来展开。该实现旨在将所提供的数学形式直接转化为可执行代码。\n\n1.  **细胞级文库大小归一化**：对于每个细胞，计算其总RNA计数（剪接加未剪接）以确定其文库大小 $L_i$。然后，通过将此文库大小相对于目标文库大小 $L_0$ 进行缩放，同时强制执行一个最小下限 $\\varepsilon_L$ 以防止对零计数细胞进行除零操作，从而计算出大小因子 $s_i$。每个细胞 $i$ 中每个基因 $g$ 的原始剪接 ($S_{ig}$) 和未剪接 ($U_{ig}$) 计数首先加上一个伪计数 $p$，然后除以该细胞的大小因子 $s_i$。这样就得到了归一化后的计数 $\\tilde{S}_{ig}$ 和 $\\tilde{U}_{ig}$，这些计数已经针对测序深度和细胞大小的差异进行了调整。\n\n2.  **对数变换**：归一化后的计数 $\\tilde{S}_{ig}$ 和 $\\tilde{U}_{ig}$ 使用函数 $\\log(1+x)$ 进行对数变换。这项常用技术（为保证数值稳定性，实现为 `np.log1p`）用于稳定表达值范围内的方差，并使数据分布更对称，这对于下游的线性建模是有益的。得到的量记为 $\\hat{S}_{ig}$ 和 $\\hat{U}_{ig}$。\n\n3.  **基因级标准化**：为了使可能具有极大不同动态范围的不同基因的表达值具有可比性，需要对每个基因的对数变换后的计数进行标准化。对于每个基因 $g$，计算其在所有细胞中的均值 ($m^S_g, m^U_g$) 和总体标准差 ($\\sigma^S_g, \\sigma^U_g$)。通过减去均值并除以标准差，得到标准化值 $\\bar{S}_{ig}$ 和 $\\bar{U}_{ig}$。在分母中使用一个小的稳定器 $\\delta$ 来防止对在细胞群体中表达没有变化的基因进行除零操作。\n\n4.  **线性回归和基于残差的速度**：该模型中RNA速度估计的核心在于关联未剪接和剪接的mRNA丰度。对于每个基因 $g$，拟合一个简单的线性回归模型 $\\bar{U}_{ig} = \\alpha_g \\bar{S}_{ig} + \\beta_g$，用标准化的剪接丰度来预测标准化的未剪接丰度。斜率 $\\alpha_g$ 和截距 $\\beta_g$ 使用普通最小二乘法公式计算。对于剪接计数方差接近于零的基因，处理了一个边缘情况，即将其斜率设为零。每个细胞 $i$ 和基因 $g$ 的RNA速度 $v_{ig}$ 被定义为该回归的残差——即观测到的标准化未剪接丰度 $\\bar{U}_{ig}$ 与其模型预测值之间的差异。这个残差代表了与预期的剪接与降解稳态关系的偏差，表明一个基因的表达是在增加还是减少。\n\n5.  **PCA嵌入和速度投影**：为了可视化发育轨迹，细胞通常被嵌入到一个低维空间中。这里，对标准化的剪接数据矩阵 $Z_{ig} = \\bar{S}_{ig}$ 执行主成分分析 (PCA)。从 $Z$ 的奇异值分解 (SVD) 中提取对应于前两个主成分的基因载荷矩阵，记为 $W$。通过将标准化剪接数据投影到这些载荷上 ($X = Z W$) 来计算二维细胞嵌入 $X_i$。类似地，高维的基因级速度向量 $v_{ig}$ 被投影到相同的二维空间中，以产生嵌入的速度向量 $\\mathbf{v}^{\\mathrm{emb}}_i$。\n\n6.  **核平滑**：最后一步是从单个细胞的离散速度向量估计出一个连续的向量场。给定二维嵌入中的一个查询点 $\\mathbf{q}$，使用高斯核来计算嵌入速度 $\\mathbf{v}^{\\mathrm{emb}}_i$ 的加权平均值。在嵌入空间中离查询点越近的细胞获得越高的权重。这个平滑过程提供了一个稳健的局部速度向量估计 $\\hat{\\mathbf{V}}(\\mathbf{q})$，代表了在发育景观中该位置细胞状态变化的可能方向和大小。\n\n这些步骤中的每一步都使用 `numpy` 库来实现高效的基于数组的计算，并仔细遵循所提供的公式和处理所有指定的边缘条件。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef _calculate_rna_velocity_pipeline(S, U, params):\n    \"\"\"\n    Implements the complete RNA velocity pipeline for a single dataset.\n    \n    Args:\n        S (np.ndarray): Spliced counts matrix (cells x genes).\n        U (np.ndarray): Unspliced counts matrix (cells x genes).\n        params (tuple): A tuple of parameters (L0, p, eps_L, delta, h, q).\n\n    Returns:\n        list: The smoothed 2D vector [vx, vy], rounded to 6 decimal places.\n    \"\"\"\n    L0, p, eps_L, delta, h, q_tuple = params\n    S = np.array(S, dtype=float)\n    U = np.array(U, dtype=float)\n    q = np.array(q_tuple, dtype=float)\n    \n    n_cells, n_genes = S.shape\n\n    # Step 1: Cell-wise library-size normalization\n    L = S.sum(axis=1) + U.sum(axis=1)\n    s = np.maximum(L, eps_L) / L0\n    S_tilde = (S + p) / s[:, np.newaxis]\n    U_tilde = (U + p) / s[:, np.newaxis]\n\n    # Step 2: Logarithmic transformation\n    S_hat = np.log1p(S_tilde)\n    U_hat = np.log1p(U_tilde)\n    \n    # Step 3: Gene-wise standardization\n    m_S = S_hat.mean(axis=0)\n    m_U = U_hat.mean(axis=0)\n    # np.std computes population standard deviation (ddof=0) by default\n    sigma_S = S_hat.std(axis=0)\n    sigma_U = U_hat.std(axis=0)\n    \n    denom_S = np.maximum(sigma_S, delta)\n    denom_U = np.maximum(sigma_U, delta)\n    \n    S_bar = (S_hat - m_S) / denom_S\n    U_bar = (U_hat - m_U) / denom_U\n\n    # Step 4: Linear regression per gene and residual-based velocities\n    v = np.zeros_like(S_bar)\n    for g in range(n_genes):\n        x = S_bar[:, g]\n        y = U_bar[:, g]\n        \n        mu_x = x.mean()\n        mu_y = y.mean()\n        \n        # np.var computes population variance (ddof=0) by default\n        var_x = np.var(x)\n        \n        if var_x >= delta:\n            cov_xy = np.mean((x - mu_x) * (y - mu_y))\n            alpha_g = cov_xy / var_x\n            beta_g = mu_y - alpha_g * mu_x\n        else:\n            alpha_g = 0.0\n            beta_g = mu_y\n            \n        v[:, g] = y - (alpha_g * x + beta_g)\n\n    # Step 5: Two-dimensional embedding by PCA\n    Z = S_bar\n    # Using full_matrices=False is efficient and gives Vh of shape (min(n,G), G)\n    try:\n        _, _, Vh = np.linalg.svd(Z, full_matrices=False)\n    except np.linalg.LinAlgError:\n         return [0.0, 0.0] # Failsafe for non-finite data\n\n    # V is the transpose of Vh\n    V = Vh.T\n    \n    # Handle cases with fewer than 2 genes/principal components\n    if V.shape[1]  2:\n        W = np.zeros((n_genes, 2))\n        W[:, :V.shape[1]] = V[:, :V.shape[1]]\n    else:\n        # W are the first 2 columns of V (gene loadings)\n        W = V[:, :2]\n\n    # Project data and velocities onto the 2D embedding space\n    X_emb = Z @ W\n    v_emb = v @ W\n    \n    # Step 6: Kernel smoothing of the vector field at a query point\n    diff = X_emb - q\n    sq_dists = np.sum(diff**2, axis=1)\n    weights = np.exp(-sq_dists / (2 * h**2))\n    \n    sum_weights = np.sum(weights)\n    \n    if sum_weights  delta: # Check for effective zero\n        V_q_hat = np.array([0.0, 0.0])\n    else:\n        weighted_v_emb = weights[:, np.newaxis] * v_emb\n        V_q_hat = np.sum(weighted_v_emb, axis=0) / sum_weights\n        \n    return [round(c, 6) for c in V_q_hat]\n\n\ndef solve():\n    \"\"\"\n    Defines test cases, runs the pipeline for each, and prints the final output.\n    \"\"\"\n    test_cases = [\n        {\n            \"S\": np.array([[10, 5, 0], [3, 8, 1], [0, 2, 9], [6, 4, 3]]),\n            \"U\": np.array([[4, 2, 0], [1, 3, 0], [0, 1, 5], [2, 1, 1]]),\n            \"params\": (1000.0, 1.0, 1.0, 1e-8, 1.0, (0.0, 0.0))\n        },\n        {\n            \"S\": np.array([[0, 0, 0], [2, 0, 0], [0, 1, 0], [0, 0, 3]]),\n            \"U\": np.array([[0, 0, 0], [0, 1, 0], [0, 0, 2], [1, 0, 0]]),\n            \"params\": (1000.0, 0.5, 1.0, 1e-8, 0.5, (0.0, 0.0))\n        },\n        {\n            \"S\": np.array([[1000, 50, 7], [50, 50, 7], [3000, 50, 7], [10, 50, 7]]),\n            \"U\": np.array([[200, 10, 3], [10, 10, 3], [600, 10, 3], [2, 10, 3]]),\n            \"params\": (10000.0, 1.0, 1.0, 1e-8, 2.0, (0.0, 0.0))\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = _calculate_rna_velocity_pipeline(case[\"S\"], case[\"U\"], case[\"params\"])\n        results.append(result)\n\n    # The str() representation of a list of lists matches the required format structure.\n    # Ex: [[-0.0, 0.0], [1.0, 2.0]] -> str -> '[[-0.0, 0.0], [1.0, 2.0]]'\n    # The problem asks for a comma-separated list of lists.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在RNA速度分析中，通过k-最近邻（kNN）图平滑细胞速度是一个常用步骤，但这并非没有风险。当不同的细胞谱系在降维空间中被错误地拉近时，邻域平均会混合截然相反的动态信号，从而产生误导性的结果。本练习通过一个精心设计的“对抗性”嵌入场景，让你定量地分析这种由邻域选择引入的偏差，从而加深对矢量场估计鲁棒性的理解。",
            "id": "3346448",
            "problem": "你的任务是量化在估计RNA速度矢量场时，当两个发育上不同的谱系被嵌入到一个$k$-最近邻（kNN）会将它们混合的空间中，因选择邻域图而引入的偏差。该分析必须基于第一性原理：RNA速度是基因表达沿潜流形的时间导数，而从单细胞数据估计矢量场通常使用邻域图来平滑局部速度估计值。你必须数学上构建一个对抗性嵌入，并计算一个量化偏差度量，该度量是邻居数 $k$ 和流形曲率 $\\kappa$ 的函数。\n\n构建以下纯数学模型：\n\n- 两个谱系（曲线）嵌入在二维欧几里得空间中。设共享的曲线形状为一条抛物线，其在原点附近的曲率是可控的。将第一个谱系定义为参数曲线 $\\alpha(t) = (x(t), y(t))$，其中\n  $$\n  x(t) = t, \\quad y(t) = \\tfrac{1}{2}\\,\\kappa\\,t^2,\n  $$\n  第二个谱系定义为 $\\beta(t) = (x(t), y(t) + \\delta)$，具有相同的 $x(t)$ 和一个附加的垂直偏移 $\\delta$，以使两个谱系保持分离但相互靠近。参数 $t$ 是均匀采样的。\n\n- 真实速度是嵌入沿每条曲线的时间导数。对于第一个谱系，定义\n  $$\n  \\mathbf{v}_A(t) = \\frac{d\\alpha}{dt} = \\left(1,\\, \\kappa\\, t\\right).\n  $$\n  对于第二个谱系，定义相反的演进方向以创建一个对抗性配置：\n  $$\n  \\mathbf{v}_B(t) = -\\mathbf{v}_A(t).\n  $$\n  为计算误差，将真实速度归一化为单位向量：\n  $$\n  \\widehat{\\mathbf{v}}_A(t) = \\frac{\\mathbf{v}_A(t)}{\\|\\mathbf{v}_A(t)\\|_2}, \\quad \\widehat{\\mathbf{v}}_B(t) = \\frac{\\mathbf{v}_B(t)}{\\|\\mathbf{v}_B(t)\\|_2}.\n  $$\n\n- 细胞的估计速度是通过平均其在嵌入空间中的 $k$ 个欧几里得最近邻的真实速度（包括来自两个谱系的邻居）得到的，然后将该方向与该细胞的真实情况（ground truth）进行比较。设 $\\mathcal{N}_k(i)$ 表示细胞 $i$ 的 $k$ 个最近邻（不包括其自身）的索引集，并设 $\\mathbf{v}_j^{\\text{true}}$ 表示邻居 $j$ 的单位真实速度。将细胞 $i$ 的估计速度定义为无权平均值\n  $$\n  \\mathbf{v}_i^{\\text{est}} = \\frac{1}{k}\\sum_{j \\in \\mathcal{N}_k(i)} \\mathbf{v}_j^{\\text{true}}.\n  $$\n  每个细胞的方向误差使用余弦相异性来定义：\n  $$\n  e_i = 1 - \\frac{\\mathbf{v}_i^{\\text{est}} \\cdot \\mathbf{v}_i^{\\text{true}}}{\\|\\mathbf{v}_i^{\\text{est}}\\|_2 \\, \\|\\mathbf{v}_i^{\\text{true}}\\|_2}.\n  $$\n  如果 $\\|\\mathbf{v}_i^{\\text{est}}\\|_2 = 0$，则定义 $e_i = 1$。\n\n- 在两个谱系最接近的局部窗口内（此处混合最具对抗性）量化平均偏差 $E(k,\\kappa)$。具体来说，在区间 $[-T, T]$ 上，对每个谱系以均匀间隔的参数值 $t$ 采样 $N$ 个细胞。定义 $h = \\tfrac{2T}{N-1}$ 并将垂直偏移设置为 $\\delta = \\eta h$，其中常量 $\\eta \\in (0,1)$，以确保在相同参数 $t$ 处的跨谱系点比同谱系邻居更近。计算限制在窗口 $|t| \\le \\tau$ 内的两个谱系的平均误差：\n  $$\n  E(k,\\kappa) = \\frac{1}{M}\\sum_{i: |t_i| \\le \\tau} e_i,\n  $$\n  其中 $M$ 是两个谱系中参数值满足 $|t_i| \\le \\tau$ 的细胞总数。\n\n实现以下算法：\n\n- 将常量 $N$、$T$、$\\eta$ 和 $\\tau$ 固定为值 $N = 401$、$T = 1$、$\\eta = 0.2$ 和 $\\tau = 0.2$。\n- 对于每个测试用例 $(k,\\kappa)$，构建具有指定 $\\kappa$ 的两个谱系，并如上定义计算 $E(k,\\kappa)$。使用 $\\mathbb{R}^2$ 中的欧几里得距离来寻找 $k$-最近邻。\n- 在构建邻居集之前，将两个谱系连接成一个单一的数据集，以便邻居选择可以混合谱系。\n- 在邻居平均之前，将所有真实速度归一化为单位长度。未归一化的平均值 $\\mathbf{v}_i^{\\text{est}}$ 可能不是单位向量；在余弦相异性公式中直接使用它。\n\n测试套件：\n\n- 使用以下测试用例来探究不同情况，包括边界条件和对抗性条件：\n  - $(k,\\kappa) = (1, 0)$\n  - $(k,\\kappa) = (1, 1)$\n  - $(k,\\kappa) = (5, 0.5)$\n  - $(k,\\kappa) = (15, 0)$\n  - $(k,\\kappa) = (51, 2)$\n  - $(k,\\kappa) = (151, 1.5)$\n\n要求的输出格式：\n\n- 你的程序应生成一行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，顺序与测试用例相同，例如 $[r_1,r_2,\\dots,r_6]$，其中每个 $r_i$ 是相应测试用例计算出的 $E(k,\\kappa)$ 值。每个 $r_i$ 都必须是浮点数。",
            "solution": "我们使用一个受控的对抗性结构，将RNA速度矢量场估计中邻居引起的偏差问题形式化。基本原理如下：RNA速度是基因表达沿潜流形的时间导数；在一个嵌入中，这个轨迹是一条曲线，局部速度向量与切线对齐。一种常见的估计器通过在嵌入中的欧几里得距离上构建的 $k$-最近邻（kNN）图来平滑逐个细胞的速度。如果嵌入几何结构导致不同谱系的细胞比同一谱系内的邻居更近，那么邻居平均会因混合不同方向而引入系统性偏差。\n\n我们按步骤进行。\n\n$1.$ 在 $\\mathbb{R}^2$ 中构建两个谱系作为具有可调曲率 $\\kappa$ 的曲线：\n- 第一个谱系是 $\\alpha(t) = (t, \\tfrac{1}{2}\\kappa t^2)$，其中 $t \\in [-T,T]$。\n- 第二个谱系是 $\\beta(t) = (t, \\delta + \\tfrac{1}{2}\\kappa t^2)$，一个向上垂直位移 $\\delta$ 的偏移副本。\n\n这种选择允许直接控制 $t=0$ 附近的曲率。对于抛物线 $y = a t^2$（其中 $a = \\tfrac{\\kappa}{2}$），根据平面曲线 $y(x)$ 的标准曲率公式，其在原点的曲率等于 $\\kappa$，因为当 $x=0$ 时，由于 $y'(0)=0$，该公式简化为 $|y''(0)|$。\n\n$2.$ 将真实速度定义为嵌入的时间导数，这与RNA速度的解释一致：\n- 对于谱系A，$\\mathbf{v}_A(t) = \\frac{d\\alpha}{dt} = (1,\\kappa t)$。\n- 对于谱系B，强制施加一个对抗性的、相反的发育方向 $\\mathbf{v}_B(t) = -\\mathbf{v}_A(t)$。\n归一化为单位向量：\n$$\n\\widehat{\\mathbf{v}}_A(t) = \\frac{(1,\\kappa t)}{\\sqrt{1+(\\kappa t)^2}}, \\quad \\widehat{\\mathbf{v}}_B(t) = -\\widehat{\\mathbf{v}}_A(t).\n$$\n这保证了对于从不同谱系中抽取的、具有相同参数 $t$ 的细胞，其真实速度是反平行的，从而在混合时最大化了潜在的偏差。\n\n$3.$ 采样和对抗性邻近。在 $[-T,T]$ 区间内以均匀间隔的参数 $t_i$ 为每个谱系采样 $N$ 个细胞。参数间距为 $h = \\tfrac{2T}{N-1}$。将垂直偏移设置为 $\\delta = \\eta h$，其中常量 $\\eta \\in (0,1)$。对于较小的 $|t|$，在相同 $t$ 处的跨谱系点之间的欧几里得距离是 $\\delta$，而到 $t \\pm h$ 处的同谱系邻居的距离近似为 $h\\sqrt{1+(\\kappa t)^2}$。通过选择 $\\delta = \\eta h$ 且 $\\eta  1$，我们确保在 $t=0$ 附近，具有相同 $t$ 值的跨谱系邻居比同谱系邻居更近，因此kNN图在该区域会优先混合不同谱系。\n\n$4.$ 基于kNN的估计器。将两个谱系连接成一个包含 $2N$ 个细胞的单一数据集，这些细胞位于点 $\\{\\mathbf{x}_i\\}_{i=1}^{2N}$。对于每个细胞 $i$，计算其 $k$ 个最近邻的集合 $\\mathcal{N}_k(i)$（以欧几里得距离为准，不包括其自身）。通过无权邻居平均来估计局部速度：\n$$\n\\mathbf{v}_i^{\\text{est}} = \\frac{1}{k} \\sum_{j \\in \\mathcal{N}_k(i)} \\mathbf{v}_j^{\\text{true}}.\n$$\n我们令 $\\mathbf{v}_j^{\\text{true}}$ 为邻居 $j$ 对应其谱系的单位真实速度。\n\n$5.$ 误差度量。为量化方向偏差，计算每个细胞的余弦相异性：\n$$\ne_i = 1 - \\frac{\\mathbf{v}_i^{\\text{est}} \\cdot \\mathbf{v}_i^{\\text{true}}}{\\|\\mathbf{v}_i^{\\text{est}}\\|_2 \\, \\|\\mathbf{v}_i^{\\text{true}}\\|_2}.\n$$\n由于通过构造 $\\|\\mathbf{v}_i^{\\text{true}}\\|_2 = 1$，此公式简化为 $1 - \\frac{\\mathbf{v}_i^{\\text{est}} \\cdot \\mathbf{v}_i^{\\text{true}}}{\\|\\mathbf{v}_i^{\\text{est}}\\|_2}$。如果 $\\|\\mathbf{v}_i^{\\text{est}}\\|_2 = 0$，则定义 $e_i = 1$（平均而言，与随机方向的最大相异性）。在窗口 $|t|\\le \\tau$ 内，两个谱系的平均误差为\n$$\nE(k,\\kappa) = \\frac{1}{M} \\sum_{i: |t_i| \\le \\tau} e_i.\n$$\n我们关注一个局部窗口来测量混合最强处的偏差，并限制曲率引起的全局效应。\n\n$6.$ 参数选择与测试套件。固定 $N = 401$, $T = 1$，并选择 $\\eta = 0.2$ 使得 $\\delta = 0.2\\,h$，其中 $h = \\tfrac{2}{400} = 0.005$。因此 $\\delta = 0.001$。选择窗口半宽 $\\tau = 0.2$。为指定的配对 $(k,\\kappa)$ 评估 $E(k,\\kappa)$：\n- $(1,0)$: 边界情况，具有笔直、平行的谱系和最大对抗性的相反方向。当 $k=1$ 时，一个靠近 $t=0$ 的细胞的最近邻位于距离为 $\\delta$ 的相对谱系上，从而在局部得到 $\\mathbf{v}_i^{\\text{est}} \\approx -\\mathbf{v}_i^{\\text{true}}$ 和 $e_i \\approx 2$。\n- $(1,1)$: $k=1$ 的弯曲情况，仍然具有对抗性；曲率轻微改变了邻居的几何结构。\n- $(5,0.5)$: 在低曲率下的小邻域平滑。\n- $(15,0)$: 在笔直谱系上的更强平滑。\n- $(51,2)$: 高平滑度和高曲率，这会增加谱系内邻居的距离，从而增加了 $t=0$ 附近的跨谱系混合。\n- $(151,1.5)$: 非常强的平滑，对许多邻居进行平均，可能稀释方向性并增加抵消的几率。\n\n$7.$ 计算方法。对于每个 $(k,\\kappa)$：\n- 使用给定的 $\\kappa$ 和 $\\delta$ 为两个谱系构建坐标。\n- 计算成对的欧几里得距离，并通过对距离排序来获得 $\\mathcal{N}_k(i)$。\n- 计算所有 $i$ 的 $\\mathbf{v}_i^{\\text{est}}$ 和 $e_i$。\n- 限制在 $|t| \\le \\tau$ 的细胞范围内，并计算平均值以获得 $E(k,\\kappa)$。\n\n最终程序确定性地实现此算法，并以方括号内逗号分隔的浮点数列表的形式，单行输出 $[E(1,0), E(1,1), E(5,0.5), E(15,0), E(51,2), E(151,1.5)]$。\n\n定性预期：\n- 对于 $k=1$，对抗性设计在 $t=0$ 附近产生很大的误差，当最近邻位于方向相反的相对谱系上时，误差接近于 $2$。\n- 随着 $k$ 的增加，估计器对混合的邻居进行平均；根据相对谱系邻居的比例，$\\mathbf{v}_i^{\\text{est}}$ 可能会被衰减甚至几乎抵消，如果估计值的幅度变小或方向错误，余弦相异性会趋向于 $1$。\n- 增加 $\\kappa$ 会在窗口边缘附近的固定参数间距下增加谱系内邻居的距离（因为点在 $y$ 方向上分离得更多），从而增强了跨谱系混合，并倾向于在对抗区域内对固定的 $k$ 增加 $E(k,\\kappa)$。\n\n这些行为源于几何嵌入与kNN图之间的相互作用，其基础是将RNA速度定义为流形切线，以及将估计器定义为在嵌入中进行邻居平均。",
            "answer": "```python\nimport numpy as np\n\ndef build_lineages_and_velocities(kappa, N=401, T=1.0, eta=0.2):\n    # Parameter grid\n    t = np.linspace(-T, T, N)\n    h = (2*T) / (N-1)\n    delta = eta * h\n\n    # Lineage A coordinates: (t, 0.5 * kappa * t^2)\n    xA = t.copy()\n    yA = 0.5 * kappa * t**2\n\n    # Lineage B coordinates: shifted vertically by delta\n    xB = t.copy()\n    yB = delta + 0.5 * kappa * t**2\n\n    # True velocities (unit vectors)\n    # v_A = (1, kappa * t) normalized\n    denom = np.sqrt(1.0 + (kappa * t)**2)\n    vAx = 1.0 / denom\n    vAy = (kappa * t) / denom\n\n    # v_B = -v_A\n    vBx = -vAx\n    vBy = -vAy\n\n    # Stack coordinates and velocities\n    X = np.vstack([np.column_stack([xA, yA]), np.column_stack([xB, yB])])  # shape (2N, 2)\n    V_true = np.vstack([np.column_stack([vAx, vAy]), np.column_stack([vBx, vBy])])  # shape (2N, 2)\n    # Parameter t replicated for both lineages\n    t_all = np.concatenate([t, t])\n\n    return X, V_true, t_all\n\ndef knn_indices(X, k):\n    # Compute pairwise distances\n    # X shape: (M, 2)\n    M = X.shape[0]\n    # Use (x^2 + y^2) - 2 X X^T + (x^2 + y^2)^T trick\n    sq = np.sum(X**2, axis=1, keepdims=True)  # (M,1)\n    d2 = sq + sq.T - 2.0 * (X @ X.T)\n    # Ensure self-distance is inf to exclude self\n    np.fill_diagonal(d2, np.inf)\n    # Get k nearest indices for each point\n    # argsort along axis 1, take first k\n    idx = np.argpartition(d2, kth=k-1, axis=1)[:, :k]\n    # For stable ordering by actual distance within the k subset\n    # Gather distances for these idx and sort within rows\n    row_indices = np.arange(M)[:, None]\n    d2_k = d2[row_indices, idx]\n    order_within = np.argsort(d2_k, axis=1)\n    idx_sorted = idx[row_indices, order_within]\n    return idx_sorted\n\ndef compute_mean_error(X, V_true, t_all, k, tau=0.2):\n    # Build kNN graph\n    k = int(k)\n    k = max(1, min(k, X.shape[0]-1))\n    nn_idx = knn_indices(X, k)\n    # Estimate velocities by averaging neighbors' true velocities\n    V_est = np.zeros_like(V_true)\n    for i in range(X.shape[0]):\n        nbrs = nn_idx[i]\n        v_mean = V_true[nbrs].mean(axis=0)\n        V_est[i] = v_mean\n\n    # Compute per-cell cosine dissimilarity\n    # Handle zero norm estimates\n    est_norm = np.linalg.norm(V_est, axis=1)\n    # True norm is 1 by construction, but compute robustly\n    true_norm = np.linalg.norm(V_true, axis=1)\n    # Avoid division by zero\n    eps = 1e-12\n    cos_sim = np.sum(V_est * V_true, axis=1) / (np.maximum(est_norm, eps) * np.maximum(true_norm, eps))\n    # Clip for numerical safety\n    cos_sim = np.clip(cos_sim, -1.0, 1.0)\n    e = 1.0 - cos_sim\n\n    # Restrict to window |t| = tau\n    mask = np.abs(t_all) = tau\n    if not np.any(mask):\n        return float(np.nan)\n    E = float(e[mask].mean())\n    return E\n\ndef solve():\n    # Constants per the problem statement\n    N = 401\n    T = 1.0\n    eta = 0.2\n    tau = 0.2\n\n    # Test cases: (k, kappa)\n    test_cases = [\n        (1, 0.0),\n        (1, 1.0),\n        (5, 0.5),\n        (15, 0.0),\n        (51, 2.0),\n        (151, 1.5),\n    ]\n\n    results = []\n    for k, kappa in test_cases:\n        X, V_true, t_all = build_lineages_and_velocities(kappa, N=N, T=T, eta=eta)\n        E = compute_mean_error(X, V_true, t_all, k=k, tau=tau)\n        # Round to 6 decimal places for stable output\n        results.append(f\"{E:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "在实际研究中，我们常常需要整合来自不同实验批次的数据，但批次效应会严重干扰对细胞动态的分析。本练习提供了一个优雅的数学框架，将批次效应视为不同数据集状态空间之间的一个几何变换，即“传输映射”。你将运用矢量微积分的原理，推导速度矢量在不同坐标系下的转换关系，并设计指标来评估批次校正是否在对齐数据的同时，也忠实地保留了内在的生物学动力学。",
            "id": "3346371",
            "problem": "给定一个简化的数学模型，用于描述转录组状态空间中跨实验批次的RNA速度分析，该模型被构建为一个二维连续向量场。某一状态下的RNA速度定义为细胞转录组状态的时间导数，这与RNA速度代表基因表达水平随时间变化率的原理相一致。考虑参考批次中的一个基本向量场，由 $v(x) = A x$ 定义，其中 $A \\in \\mathbb{R}^{2 \\times 2}$，$x \\in \\mathbb{R}^{2}$ 是状态。为了进行批次校正，将从参考批次到目标批次的可微坐标变化建模为一个传输映射 $T_b : \\mathbb{R}^{2} \\to \\mathbb{R}^{2}$，该映射被假定为具有可微逆映射的双射。\n\n从RNA速度作为状态时间导数的基本定义，以及可微变量变换的链式法则出发，推导出一个表达式，说明基本坐标系中的速度向量如何与批次坐标系中相应的速度向量相关联。然后使用此关系实现以下计算任务：\n\n- 在参考批次的 $\\mathbb{R}^{2}$ 正则网格上构建一组状态样本，并在这些点上评估基本速度场。\n- 对于每个测试用例，定义一个传输映射 $T_b$，并通过将 $T_b$ 应用于基本状态来生成一组相应的批次空间状态。使用上面导出的关系，计算在 $T_b$ 作用下由基本速度场导出的批次空间速度场。\n- 计算由传输映射预测的批次空间速度场与提供的批次空间“观测”速度场之间的对齐度量。该对齐度量必须是样本点间的平均余弦相似度，计算时仅包括两个速度向量的范数均大于一个小的阈值的点，以避免除以零。将对齐度量表示为一个实数。\n- 通过使用 $T_b$ 的逆微分将观测到的批次空间速度拉回至基本空间，通过普通最小二乘法估计一个将基本空间中的状态映射到速度的线性算子 $\\hat{A}$，并报告相对弗罗贝尼乌斯范数误差 $\\lVert \\hat{A} - A \\rVert_F / \\lVert A \\rVert_F$（作为一个实数），来计算动力学失真度量。\n- 当且仅当对齐度量不小于指定的对齐阈值，且动力学失真度量不大于指定的失真阈值时，判定测试用例通过。每个通过/失败结果必须是布尔值。\n\n假设使用以下基本场和具有具体参数值的测试套件：\n\n- 基本场: $A = \\begin{bmatrix} -1  0.5 \\\\ 0  -0.5 \\end{bmatrix}$。\n- 样本点: 一个 $x = (x_1, x_2)$ 的正则网格，其中 $x_1, x_2 \\in [-1, 1]$，各有 $21$ 个均匀间隔的值，总共给出 $441$ 个点。\n- 余弦相似度范数阈值: 在计算平均余弦相似度时，排除任一速度向量的欧几里得范数小于 $10^{-8}$ 的点。\n- 对齐阈值: $\\tau_{\\text{align}} = 0.97$ (无单位)。\n- 失真阈值: $\\tau_{\\text{distort}} = 0.10$ (无单位)。\n- 观测批次速度的噪声模型: 对每个速度分量施加均值为零、标准差为 $\\sigma$ 的加性独立高斯噪声。\n\n测试用例（角度以弧度为单位）：\n\n$1.$ 仿射，无噪声: $T_b(x) = M x + t$，其中 $M = s R(\\theta)$，$s = 1.2$，$\\theta = 0.5$，$R(\\theta) = \\begin{bmatrix} \\cos(\\theta)  -\\sin(\\theta) \\\\ \\sin(\\theta)  \\cos(\\theta) \\end{bmatrix}$，$t = \\begin{bmatrix} 0.1 \\\\ -0.05 \\end{bmatrix}$。观测的批次速度等于由传输映射导出的速度，无噪声，即噪声标准差 $\\sigma = 0.0$。\n\n$2.$ 仿射，小噪声: 与用例1相同的 $T_b$，观测的批次速度等于由传输映射导出的速度加上标准差为 $\\sigma = 0.02$ 的高斯噪声。\n\n$3.$ 仿射，动力学不匹配: 状态使用与用例1相同的 $T_b$，但观测的批次速度是使用不匹配的算子 $Q = s R(\\phi)$ 生成的，其中 $s = 1.2$，$\\phi = 1.0$，因此观测速度是在批次点的原像 $x$ 处计算为 $Q v(x)$，无噪声 ($\\sigma = 0.0$)。\n\n$4.$ 非线性，无噪声: $T_b(x) = \\begin{bmatrix} x_1 + \\alpha \\sin(x_1) \\\\ x_2 \\end{bmatrix}$，其中 $\\alpha = 0.2$。观测的批次速度等于由传输映射导出的速度，无噪声 ($\\sigma = 0.0$)。$T_b$ 在 $x$ 处的雅可比矩阵为 $J(x) = \\begin{bmatrix} 1 + \\alpha \\cos(x_1)  0 \\\\ 0  1 \\end{bmatrix}$。通过牛顿法数值求解 $x_1 + \\alpha \\sin(x_1) = x_{b,1}$ 来求 $T_b$ 的第一个坐标的逆，并注意第二个坐标的逆是平凡的 $x_2 = x_{b,2}$。\n\n$5.$ 非线性，高噪声: 与用例4相同的 $T_b$，观测的批次速度等于由传输映射导出的速度加上标准差为 $\\sigma = 0.30$ 的高斯噪声。\n\n对于每个测试用例，您必须：\n\n- 从基本场和 $T_b$ 计算批次空间中的预测速度场。\n- 计算预测的批次空间速度场与观测的批次空间速度场之间的平均余弦相似度对齐度量。\n- 使用在相应原像点处的 $T_b$ 的逆微分将观测到的批次速度拉回到基本空间，通过求解最小二乘问题 $\\min_{\\hat{A} \\in \\mathbb{R}^{2 \\times 2}} \\sum \\lVert \\hat{A} x - v_{\\text{base,hat}}(x) \\rVert_2^2$ 来估计 $\\hat{A}$，并计算相对弗罗贝尼乌斯误差 $\\lVert \\hat{A} - A \\rVert_F / \\lVert A \\rVert_F$。\n\n您的程序应生成一行输出，其中包含5个测试用例的通过/失败布尔值，格式为方括号括起来的逗号分隔列表（例如，$[r_1,r_2,r_3,r_4,r_5]$），其中每个 $r_i$ 为 $True$ 或 $False$。角度必须以弧度处理。不需要物理单位，所有输出必须是指定的无单位实数或布尔值。",
            "solution": "该问题是有效的，因为它在科学上基于向量微积分和线性代数，定义清晰，包含所有必要的数据和定义，并且其表述是客观的。我们将着手提供一个解决方案。\n\n### 1. 理论推导\n\n问题的核心在于理解速度向量场在坐标变换下的转换方式。设 $x \\in \\mathbb{R}^2$ 为参考（基本）坐标系中的状态， $x_b \\in \\mathbb{R}^2$ 为目标（批次）坐标系中的状态。两者通过一个可微、可逆的传输映射 $T_b$ 相关联，使得 $x_b = T_b(x)$。\n\nRNA速度定义为状态的时间导数。细胞在基本空间中的轨迹是一条路径 $x(t)$。其速度为 $v(x) = \\frac{dx}{dt}$。批次空间中对应的轨迹是 $x_b(t) = T_b(x(t))$。批次空间中的速度 $v_b(x_b)$ 是此路径的时间导数：\n$$ v_b(x_b) = \\frac{d x_b}{dt} = \\frac{d}{dt} T_b(x(t)) $$\n应用多变量链式法则，我们得到：\n$$ \\frac{d}{dt} T_b(x(t)) = J_{T_b}(x(t)) \\frac{dx}{dt} $$\n其中 $J_{T_b}(x)$ 是映射 $T_b$ 在状态 $x$ 处计算的雅可比矩阵。代入速度的定义，我们得到速度向量的基本变换规则：\n$$ v_b(x_b) = J_{T_b}(x) v(x) $$\n这里，$v(x)$ 是基本空间点 $x$ 处的速度，$v_b(x_b)$ 是在变换后的批次空间点 $x_b = T_b(x)$ 处的相应速度。这就是**预测的批次空间速度场**的表达式。\n\n为了评估动力学的失真，我们必须将观测到的批次速度 $v_{b, \\text{obs}}$ “拉回”到基本空间。这需要逆关系。重新整理上述方程得到：\n$$ v(x) = [J_{T_b}(x)]^{-1} v_b(x_b) $$\n根据反函数定理，$[J_{T_b}(x)]^{-1}$ 项是逆变换 $J_{T_b^{-1}}(x_b)$ 在点 $x_b = T_b(x)$ 处的雅可比矩阵。因此，在基本空间中拉回的速度（我们表示为 $v_{\\text{base,hat}}$）由下式给出：\n$$ v_{\\text{base,hat}}(x) = [J_{T_b}(x)]^{-1} v_{b, \\text{obs}}(x_b) $$\n其中 $x = T_b^{-1}(x_b)$。\n\n### 2. 算法实现\n\n我们实现一个计算过程，将这些原理应用于5个测试用例。\n\n**步骤1：设置**\n首先，我们定义基本线性动力学算子 $A = \\begin{bmatrix} -1  0.5 \\\\ 0  -0.5 \\end{bmatrix}$。然后，我们在域 $x_1, x_2 \\in [-1, 1]$ 中生成一个 $21 \\times 21 = 441$ 个样本点 $\\{x^{(i)}\\}$ 的正则网格。对于每个点 $x^{(i)}$，我们计算基准真实基本速度 $v^{(i)} = A x^{(i)}$。\n\n**步骤2：逐案例分析**\n对于5个测试用例中的每一个，我们执行以下计算：\n\n**a. 速度预测与观测：**\n- 对于给定的传输映射 $T_b$，我们首先计算其雅可比矩阵 $J_{T_b}(x)$。\n- 使用推导出的规则为每个点计算批次空间中的预测速度场：$v_{b, \\text{pred}}^{(i)} = J_{T_b}(x^{(i)}) v^{(i)}$。\n- 根据每个测试用例的具体规则生成“观测”的批次速度场 $v_{b, \\text{obs}}^{(i)}$，这可能涉及添加高斯噪声或使用不匹配的变换。\n\n**b. 对齐度量计算：**\n预测场 $v_{b, \\text{pred}}$ 和观测场 $v_{b, \\text{obs}}$ 之间的对齐度通过平均余弦相似度来量化。我们滤掉任一速度向量的欧几里得范数低于 $10^{-8}$ 的点对。对于剩余的 $N_f$ 个过滤点，度量为：\n$$ \\text{alignment} = \\frac{1}{N_f} \\sum_{i=1}^{N_f} \\frac{v_{b, \\text{pred}}^{(i)} \\cdot v_{b, \\text{obs}}^{(i)}}{\\lVert v_{b, \\text{pred}}^{(i)} \\rVert_2 \\lVert v_{b, \\text{obs}}^{(i)} \\rVert_2} $$\n如果该度量至少为 $\\tau_{\\text{align}} = 0.97$，则该用例通过对齐检查。\n\n**c. 动力学失真度量计算：**\n- 我们使用在相应原像 $x^{(i)}$ 处计算的逆雅可比矩阵将观测到的批次速度 $v_{b, \\text{obs}}^{(i)}$ 拉回到基本空间，以获得估计值 $v_{\\text{base,hat}}^{(i)}$：\n$$ v_{\\text{base,hat}}^{(i)} = [J_{T_b}(x^{(i)})]^{-1} v_{b, \\text{obs}}^{(i)} $$\n- 然后我们寻找一个能最好地解释这些拉回速度的线性算子 $\\hat{A}$。这被表述为一个普通最小二乘问题：找到 $\\hat{A}$ 以最小化平方误差和 $\\sum_i \\lVert \\hat{A} x^{(i)} - v_{\\text{base,hat}}^{(i)} \\rVert_2^2$。如果我们将点 $\\{x^{(i)}\\}$ 组装成一个矩阵 $X$（大小 $441 \\times 2$），将速度 $\\{v_{\\text{base,hat}}^{(i)}\\}$ 组装成一个矩阵 $V_{\\text{hat}}$（大小 $441 \\times 2$），则解由 $\\hat{A}^T = (X^T X)^{-1} X^T V_{\\text{hat}}$ 给出。\n- 动力学失真是估计算子 $\\hat{A}$ 与真实算子 $A$ 之间的相对弗罗贝尼乌斯范数误差：\n$$ \\text{distortion} = \\frac{\\lVert \\hat{A} - A \\rVert_F}{\\lVert A \\rVert_F} $$\n如果该度量最多为 $\\tau_{\\text{distort}} = 0.10$，则该用例通过失真检查。\n\n**d. 最终判定：**\n一个测试用例当且仅当同时满足对齐和失真标准时，才获得通过等级（True）。\n\n### 3. 特定案例的雅可比矩阵\n\n- **仿射用例 ($1, 2, 3$):** $T_b(x) = Mx + t$。雅可比矩阵是常数：$J_{T_b}(x) = M$。逆雅可比矩阵就是 $M^{-1}$。\n- **非线性用例 ($4, 5$):** $T_b(x) = \\begin{bmatrix} x_1 + \\alpha \\sin(x_1) \\\\ x_2 \\end{bmatrix}$。雅可比矩阵是位置相关的：$J_{T_b}(x) = \\begin{bmatrix} 1 + \\alpha \\cos(x_1)  0 \\\\ 0  1 \\end{bmatrix}$。逆雅可比矩阵也是对角的：$[J_{T_b}(x)]^{-1} = \\begin{bmatrix} (1 + \\alpha \\cos(x_1))^{-1}  0 \\\\ 0  1 \\end{bmatrix}$。\n\n这个系统化的步骤被转换成一个Python脚本，用于计算每个案例的通过/失败布尔值。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the RNA velocity batch correction problem for 5 test cases.\n    \"\"\"\n    # Set a seed for reproducibility of noise.\n    np.random.seed(0)\n\n    # --- Problem Setup ---\n    # Base field matrix\n    A = np.array([[-1.0, 0.5], [0.0, -0.5]])\n    norm_A_fro = np.linalg.norm(A, 'fro')\n\n    # Sample points in the base space on a regular grid\n    n_grid_points = 21\n    coords = np.linspace(-1, 1, n_grid_points)\n    x1_grid, x2_grid = np.meshgrid(coords, coords)\n    # Shape of X: (n_grid_points*n_grid_points, 2) i.e., (441, 2)\n    X = np.vstack([x1_grid.ravel(), x2_grid.ravel()]).T\n\n    # Base velocity field at sample points\n    # Shape of V_base: (441, 2)\n    V_base = X @ A.T\n\n    # Thresholds and parameters\n    norm_threshold = 1e-8\n    alignment_threshold = 0.97\n    distortion_threshold = 0.10\n\n    test_cases_params = [\n        # Case 1: Affine, clean\n        {'type': 'affine', 's': 1.2, 'theta': 0.5, 't': np.array([0.1, -0.05]), 'sigma': 0.0, 'mismatch_q': None},\n        # Case 2: Affine, small noise\n        {'type': 'affine', 's': 1.2, 'theta': 0.5, 't': np.array([0.1, -0.05]), 'sigma': 0.02, 'mismatch_q': None},\n        # Case 3: Affine, mismatched dynamics\n        {'type': 'affine', 's': 1.2, 'theta': 0.5, 't': np.array([0.1, -0.05]), 'sigma': 0.0, 'mismatch_q': {'s': 1.2, 'phi': 1.0}},\n        # Case 4: Nonlinear, clean\n        {'type': 'nonlinear', 'alpha': 0.2, 'sigma': 0.0},\n        # Case 5: Nonlinear, high noise\n        {'type': 'nonlinear', 'alpha': 0.2, 'sigma': 0.30}\n    ]\n\n    results = []\n\n    for params in test_cases_params:\n        # --- Field Transformation and Observation Generation ---\n        if params['type'] == 'affine':\n            s, theta, t = params['s'], params['theta'], params['t']\n            R = np.array([[np.cos(theta), -np.sin(theta)], [np.sin(theta), np.cos(theta)]])\n            M = s * R  # Jacobian for the affine map\n\n            # Predicted batch velocities: V_b_pred = J @ V_base\n            V_b_pred = V_base @ M.T\n\n            # Observed batch velocities\n            if params['mismatch_q'] is not None:\n                phi, s_q = params['mismatch_q']['phi'], params['mismatch_q']['s']\n                R_q = np.array([[np.cos(phi), -np.sin(phi)], [np.sin(phi), np.cos(phi)]])\n                Q = s_q * R_q\n                V_b_obs = V_base @ Q.T\n            else:\n                noise = np.random.normal(0, params['sigma'], size=V_b_pred.shape)\n                V_b_obs = V_b_pred + noise\n\n            # Pull back observed velocities for distortion metric: V_base_hat = J_inv @ V_b_obs\n            M_inv = np.linalg.inv(M)\n            V_base_hat = V_b_obs @ M_inv.T\n        \n        elif params['type'] == 'nonlinear':\n            alpha = params['alpha']\n            x1 = X[:, 0]\n\n            # Predicted batch velocities (J @ V_base)\n            # J is diagonal, so we can do this element-wise\n            J_mult_v1 = (1 + alpha * np.cos(x1)) * V_base[:, 0]\n            J_mult_v2 = V_base[:, 1]\n            V_b_pred = np.stack([J_mult_v1, J_mult_v2], axis=1)\n\n            # Observed batch velocities\n            noise = np.random.normal(0, params['sigma'], size=V_b_pred.shape)\n            V_b_obs = V_b_pred + noise\n\n            # Pull back observed velocities (J_inv @ V_b_obs)\n            J_inv_mult_v1 = (1 / (1 + alpha * np.cos(x1))) * V_b_obs[:, 0]\n            J_inv_mult_v2 = V_b_obs[:, 1]\n            V_base_hat = np.stack([J_inv_mult_v1, J_inv_mult_v2], axis=1)\n\n        # --- Metric Calculation ---\n\n        # 1. Alignment Metric (Mean Cosine Similarity)\n        norm_pred = np.linalg.norm(V_b_pred, axis=1)\n        norm_obs = np.linalg.norm(V_b_obs, axis=1)\n        \n        mask = (norm_pred > norm_threshold)  (norm_obs > norm_threshold)\n        \n        dot_product = np.sum(V_b_pred[mask] * V_b_obs[mask], axis=1)\n        cos_sim = dot_product / (norm_pred[mask] * norm_obs[mask])\n        \n        alignment_metric = np.mean(cos_sim) if cos_sim.size > 0 else 1.0\n\n        # 2. Dynamics Distortion Metric\n        # Solve least squares for A_hat: X @ A_hat.T = V_base_hat\n        A_hat_T, _, _, _ = np.linalg.lstsq(X, V_base_hat, rcond=None)\n        A_hat = A_hat_T.T\n        \n        distortion_metric = np.linalg.norm(A_hat - A, 'fro') / norm_A_fro\n\n        # 3. Pass/Fail Decision\n        is_pass = (alignment_metric >= alignment_threshold) and (distortion_metric = distortion_threshold)\n        results.append(is_pass)\n\n    # Format the final output as a comma-separated list of booleans\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}