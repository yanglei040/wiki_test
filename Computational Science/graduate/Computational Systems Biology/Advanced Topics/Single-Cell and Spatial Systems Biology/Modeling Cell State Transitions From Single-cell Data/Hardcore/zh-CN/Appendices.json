{
    "hands_on_practices": [
        {
            "introduction": "RNA速度为细胞转移动力学提供了强有力的瞬时快照，但标准模型常常依赖一个简化的假设：即同一类型的所有细胞共享相同的转录和剪接动力学参数。这个实践  将挑战这一假设，引导您构建一个更贴近生物学现实的层级统计模型。您将学习如何运用随机效应来捕捉基因和细胞类型特异性的异质性，并从第一性原理出发推导边际似然，从而理解模型复杂性在数学上如何处理，以及它如何提升模型的拟合优度。",
            "id": "3327692",
            "problem": "给定一个简化的、用于单细胞中核糖核酸（RNA）速度的稳态剪接模型，该模型关联了跨基因和细胞类型的未剪接和已剪接的信使RNA计数。目标是构建并计算在两个竞争模型下观测到的对数计数的边际似然：一个是允许转录和剪接动力学中存在基因和细胞类型特异性异质性的分层随机效应模型，另一个是假设每个基因在所有细胞中动力学同质的共享参数模型。您必须从核心定义推导似然，构建一个算法进行数值评估，并在提供的测试用例上通过对数似然比比较这两个模型。\n\n基本原理和假设：\n- 针对单个基因的标准两阶段剪接常微分方程（ODE）模型规定，未剪接转录本以转录速率 $\\alpha$ 产生，以速率 $\\beta$ 进行剪接，已剪接转录本以速率 $\\gamma$ 降解。在短时间窗口内的准稳态条件下，期望水平满足未剪接均值与 $\\alpha/\\beta$ 成正比，已剪接均值与 $\\alpha/\\gamma$ 成正比。对于单细胞数据，一个常用的近似是，对数计数在加性测量噪声下集中在这些对数均值周围。\n- 对于基因 $g$ 和细胞 $c$，令 $y^{(u)}_{g,c} = \\log u_{g,c}$ 表示观测到的未剪接对数计数，$y^{(s)}_{g,c} = \\log s_{g,c}$ 表示观测到的已剪接对数计数。假设一个围绕对数均值的高斯观测模型：\n  $$y^{(u)}_{g,c} = \\log \\alpha_{g,c} - \\log \\beta_{g,c} + \\varepsilon^{(u)}_{g,c}, \\quad \\varepsilon^{(u)}_{g,c} \\sim \\mathcal{N}(0,\\sigma_u^2),$$\n  $$y^{(s)}_{g,c} = \\log \\alpha_{g,c} - \\log \\gamma_g + \\varepsilon^{(s)}_{g,c}, \\quad \\varepsilon^{(s)}_{g,c} \\sim \\mathcal{N}(0,\\sigma_s^2),$$\n  其中噪声在观测和模态之间独立，且基因特异的 $\\gamma_g$ 已知。\n- 异质剪接动力学通过对对数转录率和对数剪接率的随机效应进行建模。对于每个基因 $g$ 和细胞 $c$，其细胞类型为 $t(c) \\in \\{0,1,\\dots\\}$，定义\n  $$\\log \\alpha_{g,c} = \\mu_{\\alpha,g} + a_{g,c}, \\quad \\log \\beta_{g,c} = \\mu_{\\beta,g} + b_{g,c},$$\n  其中 $(a_{g,c}, b_{g,c})$ 是独立的零均值高斯随机效应，其方差具有细胞类型特异性\n  $$a_{g,c} \\sim \\mathcal{N}(0, \\tau_{\\alpha,t(c)}^2), \\quad b_{g,c} \\sim \\mathcal{N}(0, \\tau_{\\beta,t(c)}^2).$$\n  参数 $\\mu_{\\alpha,g}$、$\\mu_{\\beta,g}$、$\\gamma_g$、$\\sigma_u^2$ 和 $\\sigma_s^2$ 被视为已知。共享参数模型是所有细胞类型 $t$ 的 $\\tau_{\\alpha,t}^2 = 0$ 和 $\\tau_{\\beta,t}^2 = 0$ 的特例。\n\n任务：\n1. 仅使用上述假设和高斯分布的标准性质，通过对随机效应 $(a_{g,c}, b_{g,c})$ 进行积分，构建分层随机效应模型下联合观测向量 $y_{g,c} = [y^{(u)}_{g,c}, y^{(s)}_{g,c}]^\\top$ 的边际似然。您的推导必须从观测模型和随机效应先验的定义开始，并遵循原则性的边际化方法。不要假定或假设一个预先推导出的边际分布公式；从第一性原理出发进行推导。\n2. 通过将您的分层表达式特化到无异质性的情况，来构建共享参数模型的似然。\n3. 对于下面提供的数据和参数值，计算每个模型下的总对数似然，并报告定义为\n   $$\\Delta = \\log L_{\\mathrm{hier}} - \\log L_{\\mathrm{shared}},$$\n   的对数似然比，用于每个测试用例。这里的 $\\log L$ 是所有基因-细胞观测的对数似然之和。答案必须报告为无量纲的实数（浮点数）。\n\n数据和固定参数：\n- 基因：$G=2$，由 $g \\in \\{0,1\\}$ 索引。\n- 细胞：$C=4$，由 $c \\in \\{0,1,2,3\\}$ 索引，细胞类型映射 $t(c)$ 由 $t(0)=0$, $t(1)=0$, $t(2)=1$, $t(3)=1$ 给出。\n- 基因层面的固定参数：\n  - $(\\mu_{\\alpha,0}, \\mu_{\\beta,0}, \\gamma_0) = (2.0, 0.5, 0.5)$，\n  - $(\\mu_{\\alpha,1}, \\mu_{\\beta,1}, \\gamma_1) = (1.5, 0.2, 1.2)$。\n- 观测噪声标准差：$\\sigma_u = 0.15$，$\\sigma_s = 0.20$。\n- 观测到的对数计数矩阵 $Y^{(u)} = [y^{(u)}_{g,c}] \\in \\mathbb{R}^{2 \\times 4}$ 和 $Y^{(s)} = [y^{(s)}_{g,c}] \\in \\mathbb{R}^{2 \\times 4}$ 如下：\n  - 对于基因 $g=0$：$[y^{(u)}_{0,0}, y^{(u)}_{0,1}, y^{(u)}_{0,2}, y^{(u)}_{0,3}] = [1.8, 1.3, 1.35, 1.75]$，以及 $[y^{(s)}_{0,0}, y^{(s)}_{0,1}, y^{(s)}_{0,2}, y^{(s)}_{0,3}] = [2.89314718056, 2.54314718056, 2.74314718056, 2.69314718056]$。\n  - 对于基因 $g=1$：$[y^{(u)}_{1,0}, y^{(u)}_{1,1}, y^{(u)}_{1,2}, y^{(u)}_{1,3}] = [1.4, 1.1, 1.48, 1.23]$，以及 $[y^{(s)}_{1,0}, y^{(s)}_{1,1}, y^{(s)}_{1,2}, y^{(s)}_{1,3}] = [1.41767844321, 1.26767844321, 1.39767844321, 1.29767844321]$。\n\n待评估的随机效应方差配置测试套件：\n- 测试用例 A（按细胞类型异质）：\n  - 细胞类型 $0$：$(\\tau_{\\alpha,0}, \\tau_{\\beta,0}) = (0.3, 0.25)$，\n  - 细胞类型 $1$：$(\\tau_{\\alpha,1}, \\tau_{\\beta,1}) = (0.1, 0.4)$。\n- 测试用例 B（近共享基线；边界情况）：\n  - 细胞类型 $0$ 和 $1$：对于 $t \\in \\{0,1\\}$，$(\\tau_{\\alpha,t}, \\tau_{\\beta,t}) = (10^{-6}, 10^{-6})$。\n- 测试用例 C（仅转录异质性）：\n  - 细胞类型 $0$ 和 $1$：对于 $t \\in \\{0,1\\}$，$(\\tau_{\\alpha,t}, \\tau_{\\beta,t}) = (0.2, 0.0)$。\n\n算法要求：\n- 在给定超参数的情况下，独立处理每个 $(g,c)$ 对，并将所有对的对数似然相加得到 $\\log L$。\n- 最终的数值答案必须是测试用例 A、B 和 C 的三个 $\\Delta$ 值，并按此顺序排列。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个数字四舍五入到六位小数，例如：\"[0.123456,0.000001,0.987654]\"。",
            "solution": "该问题要求在两个竞争模型下，推导和计算单细胞RNA剪接数据的边际对数似然：一个分层随机效应模型和一个更简单的共享参数模型。最终目标是使用对数似然比来比较这些模型。对问题陈述的验证已确认其具有科学依据、是良定的，并包含足够的信息以获得唯一解。因此，我们可以继续进行推导和计算。\n\n解决方案分为三个部分：首先，推导分层模型的边际似然；其次，将此结果特化到共享参数模型；第三，详述计算算法。\n\n**1. 分层随机效应模型的边际似然**\n\n分析始于单个基因 $g$ 在单个细胞 $c$ 中的观测方程。令观测对数计数向量为 $\\mathbf{y}_{g,c} = [y^{(u)}_{g,c}, y^{(s)}_{g,c}]^\\top$。模型由下式给出：\n$$y^{(u)}_{g,c} = \\log \\alpha_{g,c} - \\log \\beta_{g,c} + \\varepsilon^{(u)}_{g,c}$$\n$$y^{(s)}_{g,c} = \\log \\alpha_{g,c} - \\log \\gamma_g + \\varepsilon^{(s)}_{g,c}$$\n其中 $\\log \\alpha_{g,c} = \\mu_{\\alpha,g} + a_{g,c}$ 且 $\\log \\beta_{g,c} = \\mu_{\\beta,g} + b_{g,c}$。项 $a_{g,c}$ 和 $b_{g,c}$ 是潜随机效应，而 $\\varepsilon^{(u)}_{g,c}$ 和 $\\varepsilon^{(s)}_{g,c}$ 是测量误差。\n\n我们将对数速率的表达式代入观测方程：\n$$y^{(u)}_{g,c} = (\\mu_{\\alpha,g} + a_{g,c}) - (\\mu_{\\beta,g} + b_{g,c}) + \\varepsilon^{(u)}_{g,c} = (\\mu_{\\alpha,g} - \\mu_{\\beta,g}) + a_{g,c} - b_{g,c} + \\varepsilon^{(u)}_{g,c}$$\n$$y^{(s)}_{g,c} = (\\mu_{\\alpha,g} + a_{g,c}) - \\log \\gamma_g + \\varepsilon^{(s)}_{g,c} = (\\mu_{\\alpha,g} - \\log \\gamma_g) + a_{g,c} + \\varepsilon^{(s)}_{g,c}$$\n\n这个系统可以用更紧凑的矩阵-向量形式表示。让我们为给定的基因 $g$ 和细胞 $c$ 定义以下向量和矩阵：\n- 观测向量：$\\mathbf{y}_{g,c} = \\begin{pmatrix} y^{(u)}_{g,c} \\\\ y^{(s)}_{g,c} \\end{pmatrix}$\n- 固定效应均值向量：$\\mathbf{\\mu}_g = \\begin{pmatrix} \\mu_{\\alpha,g} - \\mu_{\\beta,g} \\\\ \\mu_{\\alpha,g} - \\log \\gamma_g \\end{pmatrix}$\n- 随机效应向量：$\\mathbf{z}_{g,c} = \\begin{pmatrix} a_{g,c} \\\\ b_{g,c} \\end{pmatrix}$\n- 测量误差向量：$\\mathbf{\\varepsilon}_{g,c} = \\begin{pmatrix} \\varepsilon^{(u)}_{g,c} \\\\ \\varepsilon^{(s)}_{g,c} \\end{pmatrix}$\n- 线性变换矩阵：$\\mathbf{L} = \\begin{pmatrix} 1 & -1 \\\\ 1 & 0 \\end{pmatrix}$\n\n通过这些定义，单个观测的模型变成了潜变量的线性变换加上噪声：\n$$\\mathbf{y}_{g,c} = \\mathbf{\\mu}_g + \\mathbf{L}\\mathbf{z}_{g,c} + \\mathbf{\\varepsilon}_{g,c}$$\n\n根据问题陈述，随机效应和测量误差服从零均值高斯分布。它们被假设为独立的。\n- 随机效应 $\\mathbf{z}_{g,c}$ 服从一个二元正态分布，其协方差矩阵是对角阵且依赖于细胞类型 $t(c)$：\n  $$\\mathbf{z}_{g,c} \\sim \\mathcal{N}(\\mathbf{0}, \\mathbf{\\Sigma}_{z,t(c)}), \\quad \\text{其中} \\quad \\mathbf{\\Sigma}_{z,t(c)} = \\begin{pmatrix} \\tau_{\\alpha,t(c)}^2 & 0 \\\\ 0 & \\tau_{\\beta,t(c)}^2 \\end{pmatrix}$$\n- 测量误差 $\\mathbf{\\varepsilon}_{g,c}$ 服从一个二元正态分布，其协方差矩阵是对角阵：\n  $$\\mathbf{\\varepsilon}_{g,c} \\sim \\mathcal{N}(\\mathbf{0}, \\mathbf{\\Sigma}_{\\varepsilon}), \\quad \\text{其中} \\quad \\mathbf{\\Sigma}_{\\varepsilon} = \\begin{pmatrix} \\sigma_u^2 & 0 \\\\ 0 & \\sigma_s^2 \\end{pmatrix}$$\n\n为了找到观测值 $\\mathbf{y}_{g,c}$ 的边际似然，我们必须对未观测到的随机效应 $\\mathbf{z}_{g,c}$ 进行积分。该模型是一个线性高斯状态空间模型，而高斯分布的一个关键性质是它们在线性变换和求和下是封闭的。因此，$\\mathbf{y}_{g,c}$ 的边际分布也将是高斯的。\n\n边际分布的均值是 $\\mathbf{y}_{g,c}$ 的期望：\n$$E[\\mathbf{y}_{g,c}] = E[\\mathbf{\\mu}_g + \\mathbf{L}\\mathbf{z}_{g,c} + \\mathbf{\\varepsilon}_{g,c}] = \\mathbf{\\mu}_g + \\mathbf{L}E[\\mathbf{z}_{g,c}] + E[\\mathbf{\\varepsilon}_{g,c}] = \\mathbf{\\mu}_g + \\mathbf{L}\\mathbf{0} + \\mathbf{0} = \\mathbf{\\mu}_g$$\n\n边际分布的协方差是 $\\mathbf{y}_{g,c}$ 的协方差：\n$$Cov(\\mathbf{y}_{g,c}) = Cov(\\mathbf{\\mu}_g + \\mathbf{L}\\mathbf{z}_{g,c} + \\mathbf{\\varepsilon}_{g,c}) = Cov(\\mathbf{L}\\mathbf{z}_{g,c} + \\mathbf{\\varepsilon}_{g,c})$$\n由于随机效应 $\\mathbf{z}_{g,c}$ 和测量误差 $\\mathbf{\\varepsilon}_{g,c}$ 是独立的，它们的和的协方差等于它们协方差的和：\n$$Cov(\\mathbf{y}_{g,c}) = Cov(\\mathbf{L}\\mathbf{z}_{g,c}) + Cov(\\mathbf{\\varepsilon}_{g,c})$$\n使用属性 $Cov(\\mathbf{A}\\mathbf{x}) = \\mathbf{A}Cov(\\mathbf{x})\\mathbf{A}^\\top$，我们有：\n$$Cov(\\mathbf{L}\\mathbf{z}_{g,c}) = \\mathbf{L} Cov(\\mathbf{z}_{g,c}) \\mathbf{L}^\\top = \\mathbf{L} \\mathbf{\\Sigma}_{z,t(c)} \\mathbf{L}^\\top$$\n所以，我们记为 $\\mathbf{\\Sigma}_{y,g,c}$ 的边际协方差矩阵是：\n$$\\mathbf{\\Sigma}_{y,g,c} = \\mathbf{L} \\mathbf{\\Sigma}_{z,t(c)} \\mathbf{L}^\\top + \\mathbf{\\Sigma}_{\\varepsilon}$$\n让我们显式计算 $\\mathbf{L} \\mathbf{\\Sigma}_{z,t(c)} \\mathbf{L}^\\top$：\n$$\\mathbf{L} \\mathbf{\\Sigma}_{z,t(c)} \\mathbf{L}^\\top = \\begin{pmatrix} 1 & -1 \\\\ 1 & 0 \\end{pmatrix} \\begin{pmatrix} \\tau_{\\alpha,t(c)}^2 & 0 \\\\ 0 & \\tau_{\\beta,t(c)}^2 \\end{pmatrix} \\begin{pmatrix} 1 & 1 \\\\ -1 & 0 \\end{pmatrix} = \\begin{pmatrix} \\tau_{\\alpha,t(c)}^2 & -\\tau_{\\beta,t(c)}^2 \\\\ \\tau_{\\alpha,t(c)}^2 & 0 \\end{pmatrix} \\begin{pmatrix} 1 & 1 \\\\ -1 & 0 \\end{pmatrix} = \\begin{pmatrix} \\tau_{\\alpha,t(c)}^2 + \\tau_{\\beta,t(c)}^2 & \\tau_{\\alpha,t(c)}^2 \\\\ \\tau_{\\alpha,t(c)}^2 & \\tau_{\\alpha,t(c)}^2 \\end{pmatrix}$$\n加上测量噪声的协方差，得到最终的边际协方差矩阵：\n$$\\mathbf{\\Sigma}_{y,g,c} = \\begin{pmatrix} \\tau_{\\alpha,t(c)}^2 + \\tau_{\\beta,t(c)}^2 & \\tau_{\\alpha,t(c)}^2 \\\\ \\tau_{\\alpha,t(c)}^2 & \\tau_{\\alpha,t(c)}^2 \\end{pmatrix} + \\begin{pmatrix} \\sigma_u^2 & 0 \\\\ 0 & \\sigma_s^2 \\end{pmatrix} = \\begin{pmatrix} \\sigma_u^2 + \\tau_{\\alpha,t(c)}^2 + \\tau_{\\beta,t(c)}^2 & \\tau_{\\alpha,t(c)}^2 \\\\ \\tau_{\\alpha,t(c)}^2 & \\sigma_s^2 + \\tau_{\\alpha,t(c)}^2 \\end{pmatrix}$$\n因此，在分层模型下，观测向量 $\\mathbf{y}_{g,c}$ 的边际分布是一个二元正态分布：\n$$\\mathbf{y}_{g,c} \\sim \\mathcal{N}(\\mathbf{\\mu}_{g}, \\mathbf{\\Sigma}_{y,g,c})$$\n这个单次观测的对数似然由多元正态概率密度函数（PDF）的对数给出：\n$$\\log p(\\mathbf{y}_{g,c} | \\theta_{\\mathrm{hier}}) = -\\frac{k}{2}\\log(2\\pi) - \\frac{1}{2}\\log(\\det(\\mathbf{\\Sigma}_{y,g,c})) - \\frac{1}{2}(\\mathbf{y}_{g,c} - \\mathbf{\\mu}_{g})^\\top \\mathbf{\\Sigma}_{y,g,c}^{-1} (\\mathbf{y}_{g,c} - \\mathbf{\\mu}_{g})$$\n其中 $k=2$ 是 $\\mathbf{y}_{g,c}$ 的维度。总对数似然 $\\log L_{\\mathrm{hier}}$ 是对所有独立的基因-细胞观测求和：\n$$\\log L_{\\mathrm{hier}} = \\sum_{g=0}^{G-1} \\sum_{c=0}^{C-1} \\log p(\\mathbf{y}_{g,c} | \\theta_{\\mathrm{hier}})$$\n\n**2. 共享参数模型的似然**\n\n共享参数模型被定义为细胞间不存在异质性的特例，即随机效应的方差为零：对于所有细胞类型 $t$，$\\tau_{\\alpha,t}^2 = 0$ 且 $\\tau_{\\beta,t}^2 = 0$。这意味着随机效应 $a_{g,c}$ 和 $b_{g,c}$ 恒等于零。\n\n我们可以通过将 $\\tau_{\\alpha,t(c)}^2 = 0$ 和 $\\tau_{\\beta,t(c)}^2 = 0$ 代入为分层模型推导的边际协方差矩阵 $\\mathbf{\\Sigma}_{y,g,c}$ 来获得此模型的似然：\n$$\\mathbf{\\Sigma}_{y,g,c}^{\\mathrm{shared}} = \\begin{pmatrix} \\sigma_u^2 + 0 + 0 & 0 \\\\ 0 & \\sigma_s^2 + 0 \\end{pmatrix} = \\begin{pmatrix} \\sigma_u^2 & 0 \\\\ 0 & \\sigma_s^2 \\end{pmatrix} = \\mathbf{\\Sigma}_{\\varepsilon}$$\n均值向量 $\\mathbf{\\mu}_g$ 保持不变。因此，共享模型的边际分布为：\n$$\\mathbf{y}_{g,c} \\sim \\mathcal{N}(\\mathbf{\\mu}_{g}, \\mathbf{\\Sigma}_{\\varepsilon})$$\n因为协方差矩阵 $\\mathbf{\\Sigma}_{\\varepsilon}$ 是对角阵，这等同于未剪接和已剪接对数计数的两个独立的单变量高斯分布：\n$$y^{(u)}_{g,c} \\sim \\mathcal{N}(\\mu_{\\alpha,g} - \\mu_{\\beta,g}, \\sigma_u^2)$$\n$$y^{(s)}_{g,c} \\sim \\mathcal{N}(\\mu_{\\alpha,g} - \\log \\gamma_g, \\sigma_s^2)$$\n总对数似然 $\\log L_{\\mathrm{shared}}$ 是通过使用这个简化模型对所有基因-细胞对的对数-PDF值求和来计算的。\n\n**3. 对数似然比的计算算法**\n\n任务是为三个测试用例计算 $\\Delta = \\log L_{\\mathrm{hier}} - \\log L_{\\mathrm{shared}}$。算法如下：\n\n1.  初始化问题陈述中提供的所有固定参数和数据：$G, C$，细胞类型映射 $t(c)$，基因特异性参数 $(\\mu_{\\alpha,g}, \\mu_{\\beta,g}, \\gamma_g)$，观测噪声 $(\\sigma_u, \\sigma_s)$，以及观测数据矩阵 $Y^{(u)}$ 和 $Y^{(s)}$。\n2.  定义一个函数 `calculate_logL(taus)`，它以一组随机效应标准差 $(\\tau_{\\alpha,t}, \\tau_{\\beta,t})$ 作为输入，并返回总对数似然。\n3.  在该函数内部，遍历每个基因 $g \\in \\{0, ..., G-1\\}$ 和每个细胞 $c \\in \\{0, ..., C-1\\}$。\n    a. 确定细胞类型 $t = t(c)$。\n    b. 构建均值向量 $\\mathbf{\\mu}_g$ 和观测向量 $\\mathbf{y}_{g,c}$。\n    c. 获取相应的 $\\tau_{\\alpha,t}$ 和 $\\tau_{\\beta,t}$ 值并计算它们的平方。\n    d. 使用推导出的公式组装 $2 \\times 2$ 边际协方差矩阵 $\\mathbf{\\Sigma}_{y,g,c}$。\n    e. 计算给定分布 $\\mathcal{N}(\\mathbf{\\mu}_g, \\mathbf{\\Sigma}_{y,g,c})$ 下 $\\mathbf{y}_{g,c}$ 的对数似然。使用多元正态对数-PDF的库函数来完成此操作最为稳健。\n    f. 将此值加到对数似然的总和中。\n4.  对于每个测试用例 (A, B, C)：\n    a. 通过使用为该测试用例指定的 $\\tau$ 值调用 `calculate_logL` 来计算 $\\log L_{\\mathrm{hier}}$。\n    b. 通过使用所有 $\\tau$ 值设为 $0$ 来调用 `calculate_logL` 计算 $\\log L_{\\mathrm{shared}}$。\n    c. 计算差值 $\\Delta = \\log L_{\\mathrm{hier}} - \\log L_{\\mathrm{shared}}$。\n5.  收集三个 $\\Delta$ 值并将其格式化为逗号分隔的列表作为最终输出。\n\n此过程将按规定使用Python的`numpy`和`scipy`库来实现。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import multivariate_normal\n\ndef solve():\n    \"\"\"\n    Computes the log-likelihood ratio between a hierarchical and shared-parameter\n    model for RNA velocity, based on the problem specification.\n    \"\"\"\n    \n    # Define fixed parameters and data from the problem statement.\n    G, C = 2, 4\n    cell_types = np.array([0, 0, 1, 1])\n    \n    # Gene-wise fixed parameters\n    mu_alpha = np.array([2.0, 1.5])\n    mu_beta = np.array([0.5, 0.2])\n    gamma = np.array([0.5, 1.2])\n    log_gamma = np.log(gamma)\n    \n    # Observation noise\n    sigma_u, sigma_s = 0.15, 0.20\n    sigma_u_sq, sigma_s_sq = sigma_u**2, sigma_s**2\n\n    # Observed log-count matrices\n    Y_u = np.array([\n        [1.8, 1.3, 1.35, 1.75],\n        [1.4, 1.1, 1.48, 1.23]\n    ])\n    Y_s = np.array([\n        [2.89314718056, 2.54314718056, 2.74314718056, 2.69314718056],\n        [1.41767844321, 1.26767844321, 1.39767844321, 1.29767844321]\n    ])\n\n    # Test suite of random-effect variance configurations.\n    # Format: ((tau_alpha_t0, tau_beta_t0), (tau_alpha_t1, tau_beta_t1))\n    test_cases_params = [\n        # Test case A\n        ((0.3, 0.25), (0.1, 0.4)),\n        # Test case B\n        ((1e-6, 1e-6), (1e-6, 1e-6)),\n        # Test case C\n        ((0.2, 0.0), (0.2, 0.0))\n    ]\n\n    def calculate_total_logL(tau_maps):\n        \"\"\"\n        Calculates the total log-likelihood over all genes and cells for a given\n        set of random-effect standard deviations.\n\n        Args:\n            tau_maps (tuple): A tuple containing two dictionaries, one for tau_alpha\n                              and one for tau_beta, mapping cell types to std dev values.\n\n        Returns:\n            float: The total log-likelihood.\n        \"\"\"\n        tau_alpha_map, tau_beta_map = tau_maps\n        total_logL = 0.0\n        \n        for g in range(G):\n            # Pre-compute the mean vector for the current gene\n            mean_vec = np.array([mu_alpha[g] - mu_beta[g], mu_alpha[g] - log_gamma[g]])\n            \n            for c in range(C):\n                t = cell_types[c]\n                tau_alpha = tau_alpha_map.get(t, 0.0)\n                tau_beta = tau_beta_map.get(t, 0.0)\n                \n                tau_alpha_sq = tau_alpha**2\n                tau_beta_sq = tau_beta**2\n                \n                # Observation vector for this gene-cell pair\n                obs_vec = np.array([Y_u[g, c], Y_s[g, c]])\n                \n                # Construct the marginal covariance matrix\n                cov_mat = np.array([\n                    [sigma_u_sq + tau_alpha_sq + tau_beta_sq, tau_alpha_sq],\n                    [tau_alpha_sq, sigma_s_sq + tau_alpha_sq]\n                ])\n                \n                # Calculate log-likelihood for the observation and add to total\n                logL_gc = multivariate_normal.logpdf(obs_vec, mean=mean_vec, cov=cov_mat)\n                total_logL += logL_gc\n                \n        return total_logL\n\n    results = []\n    \n    # Calculate log-likelihood for the shared-parameter model (constant across test cases)\n    shared_params = ({0: 0.0, 1: 0.0}, {0: 0.0, 1: 0.0})\n    logL_shared = calculate_total_logL(shared_params)\n\n    for case_params in test_cases_params:\n        # Unpack parameters for the current hierarchical model test case\n        hier_tau_alpha_map = {0: case_params[0][0], 1: case_params[1][0]}\n        hier_tau_beta_map = {0: case_params[0][1], 1: case_params[1][1]}\n        hier_params = (hier_tau_alpha_map, hier_tau_beta_map)\n        \n        # Calculate log-likelihood for the hierarchical model\n        logL_hier = calculate_total_logL(hier_params)\n        \n        # Compute the log-likelihood ratio and store the result\n        delta = logL_hier - logL_shared\n        results.append(delta)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "从单个细胞的瞬时速度推演到整个细胞群体的演化，需要一个能够整合漂移、扩散以及细胞增殖与凋亡等命运决定过程的动态框架。本练习  将指导您使用作为统计物理学基石的 Fokker-Planck 方程来模拟群体动力学。您不僅将学习如何对该偏微分方程进行离散化，还将解决一个关键的推断问题：如何通过整合群体密度快照与克隆谱系追踪数据，来估计真实的净增长率。",
            "id": "3327656",
            "problem": "您正在对细胞状态转换进行建模，该转换沿着代表一个连续细胞状态变量 $x \\in [0,1]$ 的一维潜在轨迹发生，此模型基于单细胞数据。细胞密度 $ \\rho(x,t)$ 在漂移 $ b(x)$、扩散 $ D(x)$ 和净源 $ g(x) = r(x) - d(x)$（捕获增殖($r$)和凋亡($d$)）的作用下演化。其控制偏微分方程是带源项的 Fokker–Planck 方程，它建立在带源项的连续性方程和本构建漂移-扩散关系之上：\n$$\n\\partial_t \\rho(x,t) = -\\nabla \\cdot \\big(b(x)\\rho(x,t)\\big) + \\nabla \\cdot \\big(D(x)\\nabla \\rho(x,t)\\big) + g(x)\\rho(x,t),\n$$\n在一维空间 $x \\in [0,1]$ 上，并采用零通量边界条件（即没有净通量穿过边界）。此外，您还获得了一个与增殖相关的标量细胞周期特征 $ s(x)$，以及用于追踪克隆大小在短时间间隔 $ \\tau$ 小时内倍数变化的克隆条形码。\n\n从带源项的守恒定律和漂移-扩散通量出发，且不假设任何快捷公式，请执行以下操作：\n\n1. 在具有 $ N$ 个单元、单元中心 $ x_i$、间距 $ \\Delta x$ 和零通量边界的均匀一维网格上，推导一个有限体积离散格式。您的推导必须从连续性原理和本构建关系开始，并为位于单元中心的平流项 $ -\\nabla \\cdot (b\\rho)$ 和扩散项 $ \\nabla \\cdot (D \\nabla \\rho)$ 的离散散度，生成一个一致的、显式的公式。该公式应使用由体心量和面心系数计算出的面心通量来表示。该离散格式必须对非均匀的 $ b(x)$ 和 $ D(x)$ 有效，并且必须通过其构造满足零通量边界条件。\n\n2. 使用守恒定律的短时展开，在每个网格点上，根据离散时间差 $ (\\rho(x,t+\\tau) - \\rho(x,t))$ 和您在时间 $ t$ 计算的离散漂移-扩散散度，构建净源 $ g(x)$ 的一个估计器。另外，通过证明净源 $ g(x)$ 在时间间隔 $ \\tau$ 内如何产生 $ g(x) \\approx \\frac{1}{\\tau}\\log m(x)$（假设每个分箱内呈指数增长或衰减），为克隆倍数变化 $ m(x) = \\frac{c(x,t+\\tau)}{c(x,t)}$ 推导一个测量模型。\n\n3. 提出一个参数模型 $ g(x) = a_0 + a_1 s(x)$，并推导一个组合加权最小二乘估计器，用于估计 $ a_0$ 和 $ a_1$。该估计器应整合基于偏微分方程的 $ g$ 估计值和基于克隆对数倍数变化的 $ g$ 测量值。提供该估计器的显式正规方程。\n\n4. 实现一个程序，该程序生成自洽的合成数据，并对一个小规模测试套件计算重建的 $ g(x)$ 与真实值 $ g_{\\text{true}}(x)$ 之间的平均绝对误差 (MAE)。使用以下测试套件，并对每种情况，按规定构建 $ \\rho(x,0)$、$ b(x)$、$ D(x)$、$ s(x)$ 和 $ g_{\\text{true}}(x)$，然后使用您的离散格式通过单个显式时间步获得 $ \\rho(x,\\tau)$，并计算克隆倍数变化 $ m(x) = \\exp\\big(g_{\\text{true}}(x)\\tau\\big)$。\n\n所有时间量均以小时为单位，所有增长率（如 $ g(x)$）均以每小时为单位。最终数值答案以每小时为单位表示。\n\n测试套件（每种情况均在 $ x=0$ 和 $ x=1$ 处使用零通量边界条件、一个均匀网格和一个短时间步 $ \\tau$）：\n\n- 情况 A（理想情况）：\n  - $ N = 50$， $ \\tau = 0.001$ 小时。\n  - $ s(x) = x$。\n  - $ b(x) = -0.5\\,(x - 0.5)$。\n  - $ D(x) = 0.01$。\n  - $ g_{\\text{true}}(x) = 0.1 + 0.4\\,s(x)$。\n  - $ \\rho(x,0) = \\exp\\Big(-\\frac{(x - 0.6)^2}{2\\cdot 0.1^2}\\Big)$。\n- 情况 B（边界条件和可识别性边界情况）：\n  - $ N = 50$， $ \\tau = 0.001$ 小时。\n  - $ s(x) = \\sin(2\\pi x) + 1$。\n  - $ b(x) = 0$。\n  - $ D(x) = 0.005$。\n  - $ g_{\\text{true}}(x) = 0.2$ (常数)。\n  - $ \\rho(x,0) = 1$。\n- 情况 C（非均匀扩散和漂移）：\n  - $ N = 80$， $ \\tau = 0.001$ 小时。\n  - $ s(x) = x^2$。\n  - $ b(x) = 0.8\\,\\sin(\\pi x)$。\n  - $ D(x) = 0.02 + 0.02\\,x$。\n  - $ g_{\\text{true}}(x) = 0.05 + 0.3\\,s(x)$。\n  - $ \\rho(x,0) = \\exp\\Big(-\\frac{(x - 0.3)^2}{2\\cdot 0.05^2}\\Big) + 0.8\\,\\exp\\Big(-\\frac{(x - 0.8)^2}{2\\cdot 0.07^2}\\Big)$。\n\n算法要求：\n\n- 使用具有单元中心 $ x_i$ 和间距 $ \\Delta x$ 的均匀网格。\n- 通过对相邻单元中心值进行平均来计算面心系数。\n- 在您推导的格式中，通过将边界面通量设置为零来一致地实现零通量边界。\n- 使用单个显式时间步计算 $ \\rho(x,\\tau)$。\n- 使用您的参数模型和最小二乘估计器，从偏微分方程残差和克隆倍数变化中估计 $ g(x)$。\n- 对每种情况，计算平均绝对误差 $ \\text{MAE} = \\frac{1}{N}\\sum_{i=1}^{N} \\left| g_{\\text{est}}(x_i) - g_{\\text{true}}(x_i) \\right|$。\n\n最终输出格式：\n\n您的程序应生成一行输出，其中包含情况 A、情况 B 和情况 C 的平均绝对误差，格式为用方括号括起来的逗号分隔列表，保留六位小数，例如，“[maeA,maeB,maeC]”。这些值代表每小时单位。",
            "solution": "该问题要求推导并实现一种方法，用以估计一维细胞状态轨迹 $x$ 上的净细胞生长速率 $g(x)$。该方法必须整合两种信息来源：由 Fokker-Planck 型偏微分方程 (PDE) 控制的细胞密度快照 $\\rho(x,t)$，以及克隆倍数变化数据 $m(x)$。\n\n### 第 1 部分：有限体积离散化\n在域 $x \\in [0,1]$ 上，细胞密度 $\\rho(x,t)$ 的控制偏微分方程为：\n$$ \\partial_t \\rho(x,t) = -\\nabla \\cdot \\big(b(x)\\rho(x,t)\\big) + \\nabla \\cdot \\big(D(x)\\nabla \\rho(x,t)\\big) + g(x)\\rho(x,t) $$\n这可以使用通量 $J(x,t) = b(x)\\rho(x,t) - D(x)\\nabla \\rho(x,t)$ 重写为带源项的连续性方程：\n$$ \\partial_t \\rho = -\\nabla \\cdot J + g\\rho $$\n给定零通量边界条件，$J(0,t) = J(1,t) = 0$。\n\n为了离散化该方程，我们使用有限体积法。我们将域 $[0,1]$ 分成 $N$ 个均匀的单元（或称控制体积）$C_i = [x_{i-1/2}, x_{i+1/2}]$，其中 $i=1, \\dots, N$。单元 $C_i$ 的中心是 $x_i$，其宽度为 $\\Delta x = 1/N$。单元的界面位于 $x_{i-1/2}$ 和 $x_{i+1/2}$。\n\n我们在控制体积 $C_i$ 上对 PDE 进行积分：\n$$ \\int_{x_{i-1/2}}^{x_{i+1/2}} \\partial_t \\rho \\,dx = - \\int_{x_{i-1/2}}^{x_{i+1/2}} \\nabla \\cdot J \\,dx + \\int_{x_{i-1/2}}^{x_{i+1/2}} g\\rho \\,dx $$\n对通量项应用散度定理并近似积分，我们得到单元 $i$ 中平均密度 $\\rho_i(t)$ 的半离散方程：\n$$ \\Delta x \\frac{d\\rho_i}{dt} \\approx - \\left( J(x_{i+1/2}, t) - J(x_{i-1/2}, t) \\right) + g(x_i)\\rho_i(t) \\Delta x $$\n除以 $\\Delta x$：\n$$ \\frac{d\\rho_i}{dt} = - \\frac{J_{i+1/2} - J_{i-1/2}}{\\Delta x} + g_i \\rho_i $$\n其中 $J_{i \\pm 1/2}$ 是单元界面处的通量，我们使用记号 $g_i = g(x_i)$ 和 $\\rho_i = \\rho(x_i, t)$。\n\n通量 $J_{i+1/2}$ 由一个平流部分 $J_{\\text{adv}}$ 和一个扩散部分 $J_{\\text{diff}}$ 组成。\n根据 $J$ 的定义，$J_{i+1/2} = J_{\\text{adv}, i+1/2} - J_{\\text{diff}, i+1/2}$。\n等一下，PDE是 $\\partial_t \\rho = -\\nabla \\cdot (b \\rho) + \\nabla \\cdot (D \\nabla \\rho) + g \\rho$。这可以重写为 $\\partial_t \\rho = -\\nabla \\cdot (b \\rho - D \\nabla \\rho) + g \\rho$。因此，通量为 $J=b\\rho - D\\nabla\\rho$。这与我最初的评估一致。\n\n在界面 $i+1/2$ 处的扩散通量部分是 $D(x_{i+1/2})\\nabla \\rho$。我们使用中心差分来近似梯度，并用平均值来近似系数：\n$$ J_{\\text{diff}, i+1/2} \\approx D_{i+1/2} \\frac{\\rho_{i+1} - \\rho_i}{\\Delta x} = \\frac{D_i + D_{i+1}}{2} \\frac{\\rho_{i+1} - \\rho_i}{\\Delta x} $$\n平流通量是 $b(x_{i+1/2})\\rho(x_{i+1/2})$。为了稳定性，我们使用一阶迎风格式。界面处的密度取自“迎风”单元，这由界面处漂移 $b$ 的符号决定。\n$$ J_{\\text{adv}, i+1/2} \\approx b_{i+1/2} \\rho_{i+1/2} = \\frac{b_i + b_{i+1}}{2} \\times \\begin{cases} \\rho_i  & \\text{if } b_{i+1/2} \\ge 0 \\\\ \\rho_{i+1} & \\text{if } b_{i+1/2}  0 \\end{cases} $$\n在界面 $i+1/2$ 处的总通量是：\n$$ J_{i+1/2} = \\left(\\frac{b_i+b_{i+1}}{2}\\right)^{+} \\rho_i + \\left(\\frac{b_i+b_{i+1}}{2}\\right)^{-} \\rho_{i+1} - \\left(\\frac{D_i+D_{i+1}}{2}\\right) \\frac{\\rho_{i+1}-\\rho_i}{\\Delta x} $$\n其中 $v^+ = \\max(v, 0)$ 且 $v^- = \\min(v, 0)$。\n通过将域边界处的通量设置为零，自然地施加了零通量边界条件：$J_{1/2} = 0$ 和 $J_{N+1/2} = 0$。\n\n平流项的散度是 $-\\frac{J_{\\text{adv}, i+1/2} - J_{\\text{adv}, i-1/2}}{\\Delta x}$，扩散项的散度是 $+\\frac{J_{\\text{diff}, i+1/2} - J_{\\text{diff}, i-1/2}}{\\Delta x}$。这就提供了完整的离散化格式。\n\n### 第 2 部分：$g(x)$ 的估计器\n\n**基于 PDE 的估计器：**\n半离散 PDE 为 $\\frac{d\\rho_i}{dt} = \\mathcal{L}(\\rho)_i + g_i \\rho_i$，其中 $\\mathcal{L}(\\rho)_i = - \\frac{J_{i+1/2} - J_{i-1/2}}{\\Delta x}$。\n对时间导数使用一阶向前差分，在短时间间隔 $\\tau$ 内，我们有 $\\frac{d\\rho_i}{dt} \\approx \\frac{\\rho_i(t+\\tau) - \\rho_i(t)}{\\tau}$。\n代入并求解 $g_i$（假设 $\\rho_i  0$）：\n$$ g_{\\text{PDE}, i} \\approx \\frac{1}{\\rho_i(t)} \\left( \\frac{\\rho_i(t+\\tau) - \\rho_i(t)}{\\tau} - \\mathcal{L}(\\rho(t))_i \\right) $$\n\n**基于克隆数据的估计器：**\n忽略细胞运动（漂移和扩散），特定克隆在位置 $x$ 的细胞数量 $c(x,t)$ 的变化由局部净增长控制：$\\frac{dc}{dt} = g(x) c(x,t)$。\n在短时间 $\\tau$ 内积分得到 $c(x, t+\\tau) = c(x,t) e^{g(x)\\tau}$。\n克隆倍数变化是 $m(x) = \\frac{c(x, t+\\tau)}{c(x,t)} = e^{g(x)\\tau}$。\n求解 $g(x)$ 得到第二个估计器：\n$$ g_{\\text{clonal}, i} \\approx \\frac{1}{\\tau} \\log m(x_i) $$\n\n### 第 3 部分：组合加权最小二乘估计器\n给定参数模型 $g(x_i) = a_0 + a_1 s(x_i)$，其中 $s(x)$ 是一个细胞周期特征。我们在每个网格点 $i$ 都有两个对 $g(x_i)$ 的估计：$g_{\\text{PDE}, i}$ 和 $g_{\\text{clonal}, i}$。\n\n基于 PDE 的估计器涉及除以 $\\rho_i$，如果细胞密度低，这可能导致数值不稳定。为了创建一个稳健的估计器，我们构建一个避免这种除法的加权最小二乘问题。我们不直接最小化 $g_i$ 中的误差，而是最小化表现良好的量中的误差。令 $Y_{1,i} = \\rho_i(t) g_{\\text{PDE}, i}$ 且 $Y_{2,i} = g_{\\text{clonal}, i}$。从 $g_{\\text{PDE}, i}$ 的推导中我们可以看出，$Y_{1,i} = \\frac{\\rho_i(t+\\tau) - \\rho_i(t)}{\\tau} - \\mathcal{L}(\\rho(t))_i$，这不涉及除以 $\\rho_i(t)$。\n\n我们定义要最小化的损失函数 $L(a_0, a_1)$：\n$$ L(a_0, a_1) = \\sum_{i=1}^N \\left( Y_{1,i} - \\rho_i (a_0 + a_1 s_i) \\right)^2 + \\sum_{i=1}^N \\left( Y_{2,i} - (a_0 + a_1 s_i) \\right)^2 $$\n这对应于一个加权最小二乘问题。为了找到最优的 $a_0$ 和 $a_1$，我们将 $L$ 对 $a_0$ 和 $a_1$ 的偏导数设为零。\n令 $g_{\\text{model}, i} = a_0 + a_1 s_i$。损失为 $L = \\sum(\\rho_i g_{\\text{model},i} - Y_{1,i})^2 + \\sum(g_{\\text{model},i} - Y_{2,i})^2$。导数为：\n$$ \\frac{\\partial L}{\\partial a_0} = \\sum 2(\\rho_i g_{\\text{model},i} - Y_{1,i}) \\rho_i + \\sum 2(g_{\\text{model},i} - Y_{2,i}) = 0 $$\n$$ \\frac{\\partial L}{\\partial a_1} = \\sum 2(\\rho_i g_{\\text{model},i} - Y_{1,i}) \\rho_i s_i + \\sum 2(g_{\\text{model},i} - Y_{2,i}) s_i = 0 $$\n重新整理得到正规方程：\n$$ \\sum (\\rho_i^2+1) g_{\\text{model},i} = \\sum (\\rho_i Y_{1,i} + Y_{2,i}) $$\n$$ \\sum (\\rho_i^2+1) s_i g_{\\text{model},i} = \\sum s_i(\\rho_i Y_{1,i} + Y_{2,i}) $$\n代入 $g_{\\text{model},i} = a_0 + a_1 s_i$ 会产生一个关于参数向量 $\\mathbf{a} = [a_0, a_1]^T$ 的 $2 \\times 2$ 线性系统：$\\mathbf{M} \\mathbf{a} = \\mathbf{v}$，其中：\n$$ \\mathbf{M} = \\begin{pmatrix} \\sum_{i=1}^N (\\rho_i^2+1)  \\sum_{i=1}^N (\\rho_i^2+1)s_i \\\\ \\sum_{i=1}^N (\\rho_i^2+1)s_i  \\sum_{i=1}^N (\\rho_i^2+1)s_i^2 \\end{pmatrix} $$\n$$ \\mathbf{v} = \\begin{pmatrix} \\sum_{i=1}^N (\\rho_i Y_{1,i} + Y_{2,i}) \\\\ \\sum_{i=1}^N s_i (\\rho_i Y_{1,i} + Y_{2,i}) \\end{pmatrix} $$\n求解该系统可得到估计的参数 $a_0$ 和 $a_1$。\n\n### 第 4 部分：实现与合成数据\n实现将遵循所概述的步骤。通过对初始密度 $\\rho(x, 0)$ 应用单个显式前向欧拉时间步来生成 $\\rho(x, \\tau)$ 的合成数据，其中使用推导的有限体积格式和已知的真实值 $g_{\\text{true}}(x)$。克隆倍数变化 $m(x)$ 直接由 $g_{\\text{true}}(x)$ 生成。然后，将这些合成数据与推导出的估计器一起使用，以找到 $a_0$ 和 $a_1$ 并计算估计的 $\\hat{g}(x) = \\hat{a}_0 + \\hat{a}_1 s(x)$。性能通过 $\\hat{g}(x)$ 和 $g_{\\text{true}}(x)$ 之间的平均绝对误差 (MAE) 来衡量。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n\n    def solve_case(N, tau, s_func, b_func, D_func, g_true_func, rho0_func):\n        \"\"\"\n        Solves a single case of the problem.\n\n        Args:\n            N (int): Number of grid cells.\n            tau (float): Short time interval.\n            s_func (callable): Function for the cell-cycle feature s(x).\n            b_func (callable): Function for the drift b(x).\n            D_func (callable): Function for the diffusion D(x).\n            g_true_func (callable): Function for the ground truth net source g(x).\n            rho0_func (callable): Function for the initial cell density rho(x, 0).\n\n        Returns:\n            float: The mean absolute error (MAE) between the estimated and true g(x).\n        \"\"\"\n        # 1. Grid setup\n        dx = 1.0 / N\n        x = np.linspace(dx / 2, 1.0 - dx / 2, N)\n\n        # 2. Evaluate parameters and initial conditions\n        s = s_func(x)\n        b = b_func(x)\n        D = D_func(x)\n        rho0 = rho0_func(x)\n        g_true = g_true_func(x, s)\n\n        # 3. Compute rho(x, tau) with one explicit Euler step\n        # This requires calculating the flux J at t=0\n        J = np.zeros(N + 1)  # N+1 faces, J[0] and J[N] are zero by B.C.\n\n        # Compute fluxes at interior faces (j=1 to N-1)\n        b_face = (b[:-1] + b[1:]) / 2.0\n        D_face = (D[:-1] + D[1:]) / 2.0\n        rho_left = rho0[:-1]\n        rho_right = rho0[1:]\n\n        # Advective flux using first-order upwind scheme\n        J_adv_interior = np.where(b_face = 0, b_face * rho_left, b_face * rho_right)\n        \n        # Diffusive flux, component is D*grad(rho)\n        J_diff_component = D_face * (rho_right - rho_left) / dx\n        \n        # Total flux J = b*rho - D*grad(rho)\n        J[1:-1] = J_adv_interior - J_diff_component\n        \n        # Compute the discrete operator for flux divergence div(J)\n        div_J = (J[1:] - J[:-1]) / dx\n        \n        # Evolve rho for one time step: drho/dt = -div(J) + g*rho\n        drho_dt = -div_J + g_true * rho0\n        rho_tau = rho0 + tau * drho_dt\n        \n        # 4. Calculate the two estimators for g(x)\n        \n        # Estimator from clonal data \n        # (synthetically generated from g_true)\n        m = np.exp(g_true * tau)\n        g_clonal = (1.0 / tau) * np.log(m)\n        \n        # Estimator from PDE\n        # We work with Y1 = rho0 * g_pde to avoid division by small rho0\n        # Y1 = (rho_tau - rho0)/tau + div(J)\n        Y1 = (rho_tau - rho0) / tau + div_J\n        Y2 = g_clonal\n\n        # 5. Perform weighted least squares\n        # The linear system is M * [a0, a1]^T = v\n        \n        # Build the matrix M\n        w = rho0**2 + 1\n        M = np.zeros((2, 2))\n        M[0, 0] = np.sum(w)\n        M[0, 1] = np.sum(w * s)\n        M[1, 0] = M[0, 1]\n        M[1, 1] = np.sum(w * s**2)\n\n        # Build the vector v\n        rhs_summand = rho0 * Y1 + Y2\n        v = np.zeros(2)\n        v[0] = np.sum(rhs_summand)\n        v[1] = np.sum(s * rhs_summand)\n        \n        # Solve for parameters a = [a0, a1]\n        try:\n            a = np.linalg.solve(M, v)\n        except np.linalg.LinAlgError:\n            # Fallback to pseudo-inverse if singular\n            a = np.linalg.pinv(M) @ v\n            \n        a0_est, a1_est = a[0], a[1]\n\n        # 6. Calculate estimated g and MAE\n        g_est = a0_est + a1_est * s\n        mae = np.mean(np.abs(g_est - g_true))\n        \n        return mae\n\n    # Test Suite\n    test_cases = {\n        'A': {\n            'N': 50, 'tau': 0.001,\n            's_func': lambda x: x,\n            'b_func': lambda x: -0.5 * (x - 0.5),\n            'D_func': lambda x: 0.01 + np.zeros_like(x),\n            'g_true_func': lambda x, s: 0.1 + 0.4 * s,\n            'rho0_func': lambda x: np.exp(-(x - 0.6)**2 / (2 * 0.1**2))\n        },\n        'B': {\n            'N': 50, 'tau': 0.001,\n            's_func': lambda x: np.sin(2 * np.pi * x) + 1.0,\n            'b_func': lambda x: np.zeros_like(x),\n            'D_func': lambda x: 0.005 + np.zeros_like(x),\n            'g_true_func': lambda x, s: 0.2 + np.zeros_like(s), # Constant g\n            'rho0_func': lambda x: np.ones_like(x)\n        },\n        'C': {\n            'N': 80, 'tau': 0.001,\n            's_func': lambda x: x**2,\n            'b_func': lambda x: 0.8 * np.sin(np.pi * x),\n            'D_func': lambda x: 0.02 + 0.02 * x,\n            'g_true_func': lambda x, s: 0.05 + 0.3 * s,\n            'rho0_func': lambda x: (np.exp(-(x - 0.3)**2 / (2 * 0.05**2)) + \n                                     0.8 * np.exp(-(x - 0.8)**2 / (2 * 0.07**2)))\n        }\n    }\n\n    results = []\n    for case_id in ['A', 'B', 'C']:\n        params = test_cases[case_id]\n        mae = solve_case(\n            params['N'], params['tau'], params['s_func'],\n            params['b_func'], params['D_func'], params['g_true_func'],\n            params['rho0_func']\n        )\n        results.append(round(mae, 6))\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "一个预测模型的优劣取决于我们验证其性能的能力。对于细胞动力学模型而言，这意味着评估其预测未来细胞状态分布的准确性。这个实践  聚焦于这一关键步驟，要求您设计一个适用于时间序列数据的稳健交叉验证方案。您将从基本统计原理出发，推导出合适的评分指标——标准化的对数似然——从而深刻理解如何量化和比较不同转移动力学模型的预测准确性。",
            "id": "3327667",
            "problem": "一项单细胞时间序列实验在离散时间点 $\\{t_{0}, t_{1}, t_{2}, t_{3}\\}$ 测量细胞状态，其中 $t_{0} = 0$, $t_{1} = 1$, $t_{2} = 2$, $t_{3} = 4$ 小时。每个细胞根据基因表达谱的聚类被分配到 $K=3$ 个转录状态中的一个，从而在时间 $t_{m}$ 产生状态计数向量 $\\mathbf{c}^{(m)} = (c_{1}^{(m)}, c_{2}^{(m)}, c_{3}^{(m)})$，对于 $m \\in \\{0,1,2,3\\}$，在时间 $t_m$ 观测到的细胞总数为 $N_{m} = \\sum_{i=1}^{3} c_{i}^{(m)}$。假设在同一时间点内的细胞是从这 $3$ 个状态的分类分布中进行的独立抽取。为了对细胞状态转换进行建模，假设一个时间同质的离散时间马尔可夫链，其在连续的单位小时之间具有单步转移矩阵 $\\mathbf{P}$，并令 $\\mathbf{p}(t)$ 表示在时间 $t$ 的群体水平状态概率向量。该模型通过跨单位步长的前向传播，从 $\\mathbf{p}(t_{0})$ 和 $\\mathbf{P}$ 预测 $\\mathbf{p}(t_{m})$。\n\n你将设计一个“留一时间点交叉验证”（LOTO-CV）方案，以评估转移模型的预测性能，并为一个留出的时间点推导一个基于对数似然的评分指标。具体来说，在其中一折中，留出整个时间点 $t_{2}$，在 $\\{t_{0}, t_{1}, t_{3}\\}$ 上拟合转移模型，并为留出的时间点获得一个预测的状态概率向量 $\\widehat{\\mathbf{p}}(t_{2})$。在 $t_{2}$ 观测到的计数为 $\\mathbf{c}^{(2)} = (52, 29, 19)$，因此 $N_{2} = 100$，训练好的模型在 $t_{2}$ 的预测概率为 $\\widehat{\\mathbf{p}}(t_{2}) = (0.5, 0.3, 0.2)$。\n\n从独立样本的分类分布的定义和用于模型评估的最大似然原理出发，为留出的时间点推导一个合适的、基于对数似然的评分指标，该指标应适用于在 $N_{m}$ 可能不同的折叠之间比较模型。然后，对于这一折，使用提供的 $\\mathbf{c}^{(2)}$ 和 $\\widehat{\\mathbf{p}}(t_{2})$ 计算该指标的数值。使用自然对数，并以“奈特/细胞”为单位表示最终得分。将你的答案四舍五入到四位有效数字。",
            "solution": "问题要求在一个交叉验证设置中，为一个留出的时间点推导一个基于对数似然的评分指标，并进行后续计算。该指标必须适用于在样本量（$N_m$）可能不同的折叠之间比较模型。\n\n首先，我们推导评分指标。问题陈述，在给定时间点 $t_m$ 观测到的细胞被视为从 $K=3$ 个状态的分类分布中进行的 $N_m$ 次独立抽取。该分布的参数是状态概率 $\\mathbf{p}^{(m)} = (p_1^{(m)}, p_2^{(m)}, p_3^{(m)})$。一个训练好的模型为这些概率提供了一个预测，记作 $\\widehat{\\mathbf{p}}^{(m)} = (\\widehat{p}_1^{(m)}, \\widehat{p}_2^{(m)}, \\widehat{p}_3^{(m)})$。\n\n设在留出的时间点 $t_m$ 的观测数据为每个状态下的细胞计数 $\\mathbf{c}^{(m)} = (c_1^{(m)}, c_2^{(m)}, c_3^{(m)})$，其中 $\\sum_{i=1}^{3} c_i^{(m)} = N_m$。根据从分类分布中独立抽取的假设，在给定模型预测概率 $\\widehat{\\mathbf{p}}^{(m)}$ 的条件下，观测到这组特定的 $N_m$ 个细胞状态的似然是每个单个细胞观测概率的乘积。这个乘积可以按状态分组，得到以下似然函数 $L$：\n$$L(\\widehat{\\mathbf{p}}^{(m)}; \\mathbf{c}^{(m)}) = \\prod_{i=1}^{3} (\\widehat{p}_i^{(m)})^{c_i^{(m)}}$$\n这个表达式给出了在模型预测下观测到数据的概率。对数似然 $\\mathcal{L}$ 是该函数的自然对数：\n$$\\mathcal{L}(\\widehat{\\mathbf{p}}^{(m)}; \\mathbf{c}^{(m)}) = \\ln(L) = \\ln\\left(\\prod_{i=1}^{3} (\\widehat{p}_i^{(m)})^{c_i^{(m)}}\\right) = \\sum_{i=1}^{3} c_i^{(m)} \\ln(\\widehat{p}_i^{(m)})$$\n这个对数似然是衡量模型预测概率 $\\widehat{\\mathbf{p}}^{(m)}$ 解释观测计数 $\\mathbf{c}^{(m)}$ 效果好坏的适当度量。更高的对数似然表示更好的拟合。\n\n注意，如果我们将计数 $\\mathbf{c}^{(m)}$ 建模为从多项分布中的单次抽取，则对数似然将包含一个额外的组合项 $\\ln(N_m!) - \\sum_{i=1}^{3} \\ln(c_i^{(m)}!)$。然而，该项仅依赖于观测数据，而不依赖于模型的参数 $\\widehat{\\mathbf{p}}^{(m)}$。因此，为了在同一数据集上比较不同模型，该项是一个无关的加法常数，并且通常被省略。基于独立分类抽取的公式直接得出了与模型评估相关的对数似然核。\n\n问题要求一个适用于在不同交叉验证折叠之间比较模型的指标，其中留出时间点 $t_m$ 的细胞数量 $N_m$ 可能不同。总对数似然 $\\mathcal{L}$ 是一个与 $N_m$ 成比例的外延量。为了获得一个可在折叠间比较的内含量，我们必须按观测数量进行归一化。标准方法是计算每个细胞的平均对数似然。这得到了评分指标 $S_m$：\n$$S_m = \\frac{1}{N_m} \\mathcal{L}(\\widehat{\\mathbf{p}}^{(m)}; \\mathbf{c}^{(m)}) = \\frac{1}{N_m} \\sum_{i=1}^{3} c_i^{(m)} \\ln(\\widehat{p}_i^{(m)})$$\n该指标以“奈特/细胞”为单位表示，因为使用了自然对数。它代表每个细胞对总对数似然的平均贡献。\n\n接下来，我们计算在留出时间点 $t_2$ 的指定折叠中该指标的数值。\n该折叠的给定数据为：\n\\begin{itemize}\n    \\item 观测计数：$\\mathbf{c}^{(2)} = (52, 29, 19)$\n    \\item 来自训练模型的预测概率：$\\widehat{\\mathbf{p}}(t_2) = (0.5, 0.3, 0.2)$\n\\end{itemize}\n首先，我们计算在 $t_2$ 的细胞总数：\n$$N_2 = c_1^{(2)} + c_2^{(2)} + c_3^{(2)} = 52 + 29 + 19 = 100$$\n现在，我们应用推导出的评分指标 $S_2$ 的公式：\n$$S_2 = \\frac{1}{N_2} \\sum_{i=1}^{3} c_i^{(2)} \\ln(\\widehat{p}_i(t_2))$$\n代入数值：\n$$S_2 = \\frac{1}{100} \\left[ 52 \\ln(0.5) + 29 \\ln(0.3) + 19 \\ln(0.2) \\right]$$\n我们计算括号内的各项：\n\\begin{itemize}\n    \\item $52 \\ln(0.5) \\approx 52 \\times (-0.693147) \\approx -36.043644$\n    \\item $29 \\ln(0.3) \\approx 29 \\times (-1.203973) \\approx -34.915217$\n    \\item $19 \\ln(0.2) \\approx 19 \\times (-1.609438) \\approx -30.579322$\n\\end{itemize}\n将这些值相加得到总对数似然：\n$$\\sum_{i=1}^{3} c_i^{(2)} \\ln(\\widehat{p}_i(t_2)) \\approx -36.043644 - 34.915217 - 30.579322 = -101.538183$$\n最后，我们除以 $N_2 = 100$ 得到以“奈特/细胞”为单位的得分：\n$$S_2 = \\frac{-101.538183}{100} = -1.01538183$$\n问题要求答案四舍五入到四位有效数字。前四位有效数字是 $1$、$0$、$1$ 和 $5$。第五位有效数字是 $3$，所以我们向下舍入。\n$$S_2 \\approx -1.015$$",
            "answer": "$$\\boxed{-1.015}$$"
        }
    ]
}