{
    "hands_on_practices": [
        {
            "introduction": "将细胞状态转换建模为离散时间的马尔可夫链是一种基本而强大的方法。然而，任何模型的价值都取决于其预测能力，因此严格的验证至关重要。本实践旨在通过设计一种“留一时间点交叉验证”（LOTO-CV）方案，来训练你评估模型性能的核心技能，你将从第一性原理出发，推导并计算一个基于对数似然的评分指标，以量化模型对未见数据的预测准确性 ()。",
            "id": "3327667",
            "problem": "一项单细胞时间序列实验在离散时间点 $\\{t_{0}, t_{1}, t_{2}, t_{3}\\}$ 测量细胞状态，其中 $t_{0} = 0$，$t_{1} = 1$，$t_{2} = 2$，$t_{3} = 4$ 小时。根据基因表达谱的聚类分析，每个细胞被分配到 $K=3$ 个转录状态中的一个，从而在时间点 $t_{m}$（$m \\in \\{0,1,2,3\\}$）产生状态计数向量 $\\mathbf{c}^{(m)} = (c_{1}^{(m)}, c_{2}^{(m)}, c_{3}^{(m)})$，在时间点 $t_{m}$ 总共观察到 $N_{m} = \\sum_{i=1}^{3} c_{i}^{(m)}$ 个细胞。假设在同一时间点内的细胞是从这 3 个状态上的一个分类分布中独立抽取的样本。为对细胞状态转换进行建模，我们假设一个时间同质的离散时间马尔可夫链，其在连续的单位小时间隔内的单步转移矩阵为 $\\mathbf{P}$，并令 $\\mathbf{p}(t)$ 表示在时间 $t$ 的群体水平状态概率向量。该模型通过单位步长的正向传播，从 $\\mathbf{p}(t_{0})$ 和 $\\mathbf{P}$ 预测 $\\mathbf{p}(t_{m})$。\n\n您将设计一个“留一时间点交叉验证”(LOTO-CV) 方案来评估转移模型的预测性能，并为留出的时间点推导一个基于对数似然的评分指标。具体来说，在其中一折交叉验证中，留出整个时间点 $t_{2}$，在 $\\{t_{0}, t_{1}, t_{3}\\}$ 上拟合转移模型，并为留出的时间点获得一个预测的状态概率向量 $\\widehat{\\mathbf{p}}(t_{2})$。在 $t_{2}$ 观察到的计数为 $\\mathbf{c}^{(2)} = (52, 29, 19)$，因此 $N_{2} = 100$，训练后的模型在 $t_{2}$ 的预测概率为 $\\widehat{\\mathbf{p}}(t_{2}) = (0.5, 0.3, 0.2)$。\n\n从独立样本的分类分布定义和用于模型评估的最大似然原则出发，为留出的时间点推导一个合适的、基于对数似然的评分指标，该指标应适用于在不同折之间比较模型，其中不同折的 $N_{m}$ 可能不同。然后，对于这一折，使用给定的 $\\mathbf{c}^{(2)}$ 和 $\\widehat{\\mathbf{p}}(t_{2})$ 计算该指标的数值。使用自然对数，并以“奈特/细胞”为单位表示最终得分。将您的答案四舍五入到四位有效数字。",
            "solution": "问题要求在交叉验证设置中，为一个留出的时间点推导一个基于对数似然的评分指标，并进行后续计算。该指标必须适用于在样本量（$N_m$）可能不同的各折之间比较模型。\n\n首先，我们推导该评分指标。问题陈述，在给定时间点 $t_m$ 观察到的细胞被视为从一个包含 $K=3$ 个状态的分类分布中进行的 $N_m$ 次独立抽取。此分布的参数是状态概率 $\\mathbf{p}^{(m)} = (p_1^{(m)}, p_2^{(m)}, p_3^{(m)})$。一个训练好的模型为这些概率提供一个预测，记作 $\\widehat{\\mathbf{p}}^{(m)} = (\\widehat{p}_1^{(m)}, \\widehat{p}_2^{(m)}, \\widehat{p}_3^{(m)})$。\n\n设留出时间点 $t_m$ 的观测数据为各状态下的细胞计数 $\\mathbf{c}^{(m)} = (c_1^{(m)}, c_2^{(m)}, c_3^{(m)})$，其中 $\\sum_{i=1}^{3} c_i^{(m)} = N_m$。根据从分类分布中独立抽取的假设，在给定模型的预测概率 $\\widehat{\\mathbf{p}}^{(m)}$ 的条件下，观察到这组特定的 $N_m$ 个细胞状态的似然是每个单个细胞观测概率的乘积。这个乘积可以按状态分组，得到以下似然函数 $L$：\n$$L(\\widehat{\\mathbf{p}}^{(m)}; \\mathbf{c}^{(m)}) = \\prod_{i=1}^{3} (\\widehat{p}_i^{(m)})^{c_i^{(m)}}$$\n此表达式给出了在模型预测下观测数据的概率。对数似然 $\\mathcal{L}$ 是该函数的自然对数：\n$$\\mathcal{L}(\\widehat{\\mathbf{p}}^{(m)}; \\mathbf{c}^{(m)}) = \\ln(L) = \\ln\\left(\\prod_{i=1}^{3} (\\widehat{p}_i^{(m)})^{c_i^{(m)}}\\right) = \\sum_{i=1}^{3} c_i^{(m)} \\ln(\\widehat{p}_i^{(m)})$$\n该对数似然是衡量模型预测概率 $\\widehat{\\mathbf{p}}^{(m)}$ 对观测计数 $\\mathbf{c}^{(m)}$ 解释得有多好的恰当度量。更高的对数似然表示更好的拟合。\n\n请注意，如果我们将计数 $\\mathbf{c}^{(m)}$ 建模为从多项分布中的单次抽取，则对数似然将包含一个额外的组合项 $\\ln(N_m!) - \\sum_{i=1}^{3} \\ln(c_i^{(m)}!)$。然而，该项仅取决于观测数据，而不取决于模型的参数 $\\widehat{\\mathbf{p}}^{(m)}$。因此，为了在相同数据集上比较不同模型，该项是一个无关的加法常数，通常被省略。基于独立分类抽取的表述直接得出了与模型评估相关的对数似然核。\n\n问题要求一个适用于在不同交叉验证折之间比较模型的指标，其中留出时间点 $t_m$ 的细胞数 $N_m$ 可能不同。总对数似然 $\\mathcal{L}$ 是一个与 $N_m$ 成比例的外延量 (extensive quantity)。为了获得一个可在各折之间比较的内含(intensive quantity)，我们必须按观测数量进行归一化。标准方法是计算每个细胞的平均对数似然。这得到了评分指标 $S_m$：\n$$S_m = \\frac{1}{N_m} \\mathcal{L}(\\widehat{\\mathbf{p}}^{(m)}; \\mathbf{c}^{(m)}) = \\frac{1}{N_m} \\sum_{i=1}^{3} c_i^{(m)} \\ln(\\widehat{p}_i^{(m)})$$\n该指标以“奈特/细胞”为单位表示，因为使用了自然对数。它代表每个细胞对总对数似然的平均贡献。\n\n接下来，我们为留出时间点 $t_2$ 的特定折计算该指标的数值。\n该折的给定数据如下：\n\\begin{itemize}\n    \\item 观测计数：$\\mathbf{c}^{(2)} = (52, 29, 19)$\n    \\item 训练模型的预测概率：$\\widehat{\\mathbf{p}}(t_2) = (0.5, 0.3, 0.2)$\n\\end{itemize}\n首先，我们计算 $t_2$ 的总细胞数：\n$$N_2 = c_1^{(2)} + c_2^{(2)} + c_3^{(2)} = 52 + 29 + 19 = 100$$\n现在，我们将推导出的公式应用于评分指标 $S_2$：\n$$S_2 = \\frac{1}{N_2} \\sum_{i=1}^{3} c_i^{(2)} \\ln(\\widehat{p}_i(t_2))$$\n代入数值：\n$$S_2 = \\frac{1}{100} \\left[ 52 \\ln(0.5) + 29 \\ln(0.3) + 19 \\ln(0.2) \\right]$$\n我们计算方括号内的各项：\n\\begin{itemize}\n    \\item $52 \\ln(0.5) \\approx 52 \\times (-0.693147) \\approx -36.043644$\n    \\item $29 \\ln(0.3) \\approx 29 \\times (-1.203973) \\approx -34.915217$\n    \\item $19 \\ln(0.2) \\approx 19 \\times (-1.609438) \\approx -30.579322$\n\\end{itemize}\n将这些值相加得到总对数似然：\n$$\\sum_{i=1}^{3} c_i^{(2)} \\ln(\\widehat{p}_i(t_2)) \\approx -36.043644 - 34.915217 - 30.579322 = -101.538183$$\n最后，我们除以 $N_2 = 100$ 以获得以“奈特/细胞”为单位的得分：\n$$S_2 = \\frac{-101.538183}{100} = -1.01538183$$\n问题要求答案四舍五入到四位有效数字。前四位有效数字是 $1$、$0$、$1$ 和 $5$。第五位有效数字是 $3$，所以我们向下舍入。\n$$S_2 \\approx -1.015$$",
            "answer": "$$\\boxed{-1.015}$$"
        },
        {
            "introduction": "为了更精细地捕捉细胞状态的连续变化，我们可以使用福克-普朗克方程，它将细胞群体动力学描述为漂移（定向运动）、扩散（随机波动）和增殖/凋亡的综合结果。本实践的核心挑战在于如何从实验数据中推断这些潜在的生物学过程，你将学习如何通过结合细胞密度分布的偏微分方程（PDE）模型和克隆追踪数据，来构建一个统一的估计器，从而推断出沿细胞状态轨迹变化的净增殖率 ()。",
            "id": "3327656",
            "problem": "您正在根据单细胞数据，沿着代表连续细胞状态变量 $x \\in [0,1]$ 的一维潜在轨迹，对细胞状态转换进行建模。细胞密度 $ \\rho(x,t)$ 在漂移 $ b(x)$、扩散 $ D(x)$ 以及捕获增殖 ($r$) 和凋亡 ($d$) 的净源 $ g(x) = r(x) - d(x)$ 的作用下演化。其控制偏微分方程是带源项的 Fokker–Planck 方程，该方程建立在带源项的连续性方程和本构漂移-扩散关系之上：\n$$\n\\partial_t \\rho(x,t) = -\\nabla \\cdot \\big(b(x)\\rho(x,t)\\big) + \\nabla \\cdot \\big(D(x)\\nabla \\rho(x,t)\\big) + g(x)\\rho(x,t),\n$$\n在一维空间 $x \\in [0,1]$ 上，并采用零通量边界条件（即边界上没有净通量）。此外，您还获得了一个与增殖相关的标量细胞周期特征 $ s(x)$，以及用于在 $ \\tau$ 小时的短时间间隔内追踪克隆大小倍数变化的克隆条形码。\n\n从带源项的守恒定律和漂移-扩散通量出发，且不假设任何捷径公式，请执行以下操作：\n\n1. 在具有 $ N$ 个单元、单元中心为 $ x_i$、间距为 $ \\Delta x$ 的均匀一维网格上，推导一个有限体积离散化，并采用零通量边界。您的推导必须从连续性原理和本构关系开始，并为单元中心的平流项 $ -\\nabla \\cdot (b\\rho)$ 和扩散项 $ \\nabla \\cdot (D \\nabla \\rho)$ 的离散散度生成一个一致的显式公式，该公式应以根据单元中心量和面心系数计算出的面心通量来表示。此离散化必须对非均匀的 $ b(x)$ 和 $ D(x)$ 有效，并且必须通过构造来满足零通量边界条件。\n\n2. 利用守恒定律的短时展开，在每个网格点上，基于离散时间差 $ (\\rho(x,t+\\tau) - \\rho(x,t))$ 和您在时间 $ t$ 评估的离散漂移-扩散散度，为净源 $ g(x)$ 构建一个估计量。独立地，通过证明在每个区间内呈指数增长或衰减的假设下，时间间隔 $ \\tau$ 内的净源 $ g(x)$ 如何产生 $ g(x) \\approx \\frac{1}{\\tau}\\log m(x)$，为克隆倍数变化 $ m(x) = \\frac{c(x,t+\\tau)}{c(x,t)}$ 推导一个测量模型。\n\n3. 提出一个参数模型 $ g(x) = a_0 + a_1 s(x)$，并为 $ a_0$ 和 $ a_1$ 推导一个组合加权最小二乘估计量，该估计量整合了基于偏微分方程的 $ g$ 估计值和基于克隆对数倍数变化的 $ g$ 测量值。给出该估计量的显式正规方程组。\n\n4. 实现一个程序，该程序生成自洽的合成数据，并针对一个小型测试套件，计算重建的 $ g(x)$ 与真实值 $ g_{\\text{true}}(x)$ 之间的平均绝对误差 (MAE)。使用以下测试套件，并对每种情况，按规定构建 $ \\rho(x,0)$、$ b(x)$、$ D(x)$、$ s(x)$ 和 $ g_{\\text{true}}(x)$，然后使用您的离散化方法通过单个显式时间步获得 $ \\rho(x,\\tau)$，并计算克隆倍数变化 $ m(x) = \\exp\\big(g_{\\text{true}}(x)\\tau\\big)$。\n\n所有时间量均以小时为单位，所有增长率（如 $ g(x)$）均以每小时（小时$^{-1}$）为单位。最终数值答案以每小时为单位表示。\n\n测试套件（每种情况都在 $ x=0$ 和 $ x=1$ 处使用零通量边界条件、均匀网格和短时间步 $ \\tau$）：\n\n- 情况 A（理想情况）：\n  - $ N = 50$， $ \\tau = 0.001$ 小时。\n  - $ s(x) = x$。\n  - $ b(x) = -0.5\\,(x - 0.5)$。\n  - $ D(x) = 0.01$。\n  - $ g_{\\text{true}}(x) = 0.1 + 0.4\\,s(x)$。\n  - $ \\rho(x,0) = \\exp\\Big(-\\frac{(x - 0.6)^2}{2\\cdot 0.1^2}\\Big)$。\n- 情况 B（边界条件和可识别性边缘情况）：\n  - $ N = 50$， $ \\tau = 0.001$ 小时。\n  - $ s(x) = \\sin(2\\pi x) + 1$。\n  - $ b(x) = 0$。\n  - $ D(x) = 0.005$。\n  - $ g_{\\text{true}}(x) = 0.2$ (常数)。\n  - $ \\rho(x,0) = 1$。\n- 情况 C（非均匀扩散和漂移）：\n  - $ N = 80$， $ \\tau = 0.001$ 小时。\n  - $ s(x) = x^2$。\n  - $ b(x) = 0.8\\,\\sin(\\pi x)$。\n  - $ D(x) = 0.02 + 0.02\\,x$。\n  - $ g_{\\text{true}}(x) = 0.05 + 0.3\\,s(x)$。\n  - $ \\rho(x,0) = \\exp\\Big(-\\frac{(x - 0.3)^2}{2\\cdot 0.05^2}\\Big) + 0.8\\,\\exp\\Big(-\\frac{(x - 0.8)^2}{2\\cdot 0.07^2}\\Big)$。\n\n算法要求：\n\n- 使用具有单元中心 $ x_i$ 和间距 $ \\Delta x$ 的均匀网格。\n- 通过平均相邻单元中心的值来计算面心系数。\n- 在您推导的方案中，通过将边界上的面通量一致地设置为零来实现零通量边界。\n- 使用单个显式时间步来计算 $ \\rho(x,\\tau)$。\n- 使用您的参数模型和最小二乘估计量，同时从偏微分方程残差和克隆倍数变化中估计 $ g(x)$。\n- 计算每种情况的平均绝对误差 $ \\text{MAE} = \\frac{1}{N}\\sum_{i=1}^{N} \\left| g_{\\text{est}}(x_i) - g_{\\text{true}}(x_i) \\right|$。\n\n最终输出格式：\n\n您的程序应生成一行输出，其中包含情况 A、情况 B 和情况 C 的平均绝对误差，形式为用方括号括起来的逗号分隔列表，四舍五入到六位小数，例如“[maeA,maeB,maeC]”。这些值代表以每小时为单位的量。",
            "solution": "该问题要求推导并实现一种方法，用于估计沿一维细胞状态轨迹 $x$ 的细胞净增长率 $g(x)$。该方法必须整合两种信息来源：由 Fokker-Planck 型偏微分方程 (PDE) 控制的细胞密度快照 $\\rho(x,t)$，以及克隆倍数变化数据 $m(x)$。\n\n### 第一部分：有限体积离散化\n在域 $x \\in [0,1]$ 上，细胞密度 $\\rho(x,t)$ 的控制偏微分方程由下式给出：\n$$ \\partial_t \\rho(x,t) = -\\nabla \\cdot \\big(b(x)\\rho(x,t)\\big) + \\nabla \\cdot \\big(D(x)\\nabla \\rho(x,t)\\big) + g(x)\\rho(x,t) $$\n这可以重写为一个带源项的连续性方程：$\\partial_t \\rho = -\\nabla \\cdot J + g\\rho$，其中通量为 $J(x,t) = b(x)\\rho(x,t) - D(x)\\nabla \\rho(x,t)$。给定零通量边界条件，$J(0,t) = J(1,t) = 0$。\n\n为离散化该方程，我们使用有限体积法。我们将域 $[0,1]$ 分成 $N$ 个均匀的单元（或称控制体积），记为 $C_i = [x_{i-1/2}, x_{i+1/2}]$，其中 $i=1, \\dots, N$。单元 $C_i$ 的中心是 $x_i$，其宽度为 $\\Delta x = 1/N$。\n\n将 PDE 在控制体积 $C_i$ 上积分，并应用散度定理，得到单元 $i$ 中平均密度 $\\rho_i(t)$ 的半离散方程：\n$$ \\frac{d\\rho_i}{dt} = - \\frac{J_{i+1/2} - J_{i-1/2}}{\\Delta x} + g_i \\rho_i $$\n其中 $J_{i \\pm 1/2}$ 是单元界面处的通量，我们使用记号 $g_i = g(x_i)$ 和 $\\rho_i = \\rho(x_i, t)$。\n\n界面 $i+1/2$ 处的通量 $J_{i+1/2}$ 由平流部分 $J_{\\text{adv}}$ 和扩散部分 $J_{\\text{diff}}$ 组成。我们使用中心差分来近似梯度，并对系数进行平均，同时为保证稳定性，对平流项使用一阶迎风格式：\n$$ J_{i+1/2} = \\underbrace{\\left(\\frac{b_i+b_{i+1}}{2}\\right)^{+} \\rho_i + \\left(\\frac{b_i+b_{i+1}}{2}\\right)^{-} \\rho_{i+1}}_{\\text{平流项}} - \\underbrace{\\left(\\frac{D_i+D_{i+1}}{2}\\right) \\frac{\\rho_{i+1}-\\rho_i}{\\Delta x}}_{\\text{扩散项}} $$\n其中 $v^+ = \\max(v, 0)$ 且 $v^- = \\min(v, 0)$。通过将域边界处的通量设置为零（$J_{1/2} = 0$ 和 $J_{N+1/2} = 0$），可以自然地施加零通量边界条件。\n\n### 第二部分：$g(x)$ 的估计量\n\n**基于 PDE 的估计量：**\n半离散 PDE 为 $\\frac{d\\rho_i}{dt} = \\mathcal{L}(\\rho)_i + g_i \\rho_i$，其中 $\\mathcal{L}(\\rho)_i = - \\frac{J_{i+1/2} - J_{i-1/2}}{\\Delta x}$ 是漂移-扩散算子。\n对时间导数使用一阶向前差分，我们有 $\\frac{d\\rho_i}{dt} \\approx \\frac{\\rho_i(t+\\tau) - \\rho_i(t)}{\\tau}$。\n代入此式并求解 $g_i$（假设 $\\rho_i > 0$）：\n$$ g_{\\text{PDE}, i} \\approx \\frac{1}{\\rho_i(t)} \\left( \\frac{\\rho_i(t+\\tau) - \\rho_i(t)}{\\tau} - \\mathcal{L}(\\rho(t))_i \\right) $$\n\n**基于克隆数据的估计量：**\n忽略细胞运动（漂移和扩散），位于位置 $x$ 的特定克隆的细胞数量 $c(x,t)$ 的变化由局部净增长控制：$\\frac{dc}{dt} = g(x) c(x,t)$。\n在短时间 $\\tau$ 内积分得到 $c(x, t+\\tau) = c(x,t) e^{g(x)\\tau}$。\n克隆倍数变化为 $m(x) = \\frac{c(x, t+\\tau)}{c(x,t)} = e^{g(x)\\tau}$。\n求解 $g(x)$ 得到第二个估计量：\n$$ g_{\\text{clonal}, i} \\approx \\frac{1}{\\tau} \\log m(x_i) $$\n\n### 第三部分：组合加权最小二乘估计量\n给定参数模型 $g(x_i) = a_0 + a_1 s(x_i)$，在每个网格点 $i$ 我们有两个对 $g(x_i)$ 的估计：$g_{\\text{PDE}, i}$ 和 $g_{\\text{clonal}, i}$。我们构建一个加权最小二乘问题，以避免在细胞密度低时产生数值不稳定。令 $Y_{1,i} = \\rho_i(t) g_{\\text{PDE}, i} = \\frac{\\rho_i(t+\\tau) - \\rho_i(t)}{\\tau} - \\mathcal{L}(\\rho(t))_i$ 和 $Y_{2,i} = g_{\\text{clonal}, i}$。\n\n我们定义要最小化的损失函数 $L(a_0, a_1)$：\n$$ L(a_0, a_1) = \\sum_{i=1}^N \\left( \\rho_i (a_0 + a_1 s_i) - Y_{1,i} \\right)^2 + \\sum_{i=1}^N \\left( (a_0 + a_1 s_i) - Y_{2,i} \\right)^2 $$\n将 $L$ 对 $a_0$ 和 $a_1$ 的偏导数设为零，我们得到关于参数向量 $\\mathbf{a} = [a_0, a_1]^T$ 的 $2 \\times 2$ 线性正规方程组 $\\mathbf{M} \\mathbf{a} = \\mathbf{v}$，其中：\n$$ \\mathbf{M} = \\begin{pmatrix} \\sum_{i=1}^N (\\rho_i^2+1) & \\sum_{i=1}^N (\\rho_i^2+1)s_i \\\\ \\sum_{i=1}^N (\\rho_i^2+1)s_i & \\sum_{i=1}^N (\\rho_i^2+1)s_i^2 \\end{pmatrix} $$\n$$ \\mathbf{v} = \\begin{pmatrix} \\sum_{i=1}^N (\\rho_i Y_{1,i} + Y_{2,i}) \\\\ \\sum_{i=1}^N s_i (\\rho_i Y_{1,i} + Y_{2,i}) \\end{pmatrix} $$\n求解该系统可得到估计参数 $a_0$ 和 $a_1$。\n\n### 第四部分：实现与合成数据\n实现将遵循上述步骤。通过使用推导的有限体积格式和已知的真实值 $g_{\\text{true}}(x)$，对初始密度 $\\rho(x, 0)$ 应用单个显式前向欧拉时间步，来生成 $\\rho(x, \\tau)$ 的合成数据。克隆倍数变化 $m(x)$ 直接由 $g_{\\text{true}}(x)$ 生成。然后，这些合成数据与推导的估计量一起使用，以找到 $a_0$ 和 $a_1$，并计算估计的 $\\hat{g}(x) = \\hat{a}_0 + \\hat{a}_1 s(x)$。性能通过 $\\hat{g}(x)$ 和 $g_{\\text{true}}(x)$ 之间的平均绝对误差 (MAE) 来衡量。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n\n    def solve_case(N, tau, s_func, b_func, D_func, g_true_func, rho0_func):\n        \"\"\"\n        Solves a single case of the problem.\n\n        Args:\n            N (int): Number of grid cells.\n            tau (float): Short time interval.\n            s_func (callable): Function for the cell-cycle feature s(x).\n            b_func (callable): Function for the drift b(x).\n            D_func (callable): Function for the diffusion D(x).\n            g_true_func (callable): Function for the ground truth net source g(x).\n            rho0_func (callable): Function for the initial cell density rho(x, 0).\n\n        Returns:\n            float: The mean absolute error (MAE) between the estimated and true g(x).\n        \"\"\"\n        # 1. Grid setup\n        dx = 1.0 / N\n        x = np.linspace(dx / 2, 1.0 - dx / 2, N)\n\n        # 2. Evaluate parameters and initial conditions\n        s = s_func(x)\n        b = b_func(x)\n        D = D_func(x)\n        rho0 = rho0_func(x)\n        g_true = g_true_func(x, s)\n\n        # 3. Compute rho(x, tau) with one explicit Euler step\n        # This requires calculating the flux J at t=0\n        J = np.zeros(N + 1)  # N+1 faces, J[0] and J[N] are zero by B.C.\n\n        # Compute fluxes at interior faces (j=1 to N-1)\n        b_face = (b[:-1] + b[1:]) / 2.0\n        D_face = (D[:-1] + D[1:]) / 2.0\n        rho_left = rho0[:-1]\n        rho_right = rho0[1:]\n\n        # Advective flux using first-order upwind scheme\n        J_adv_interior = np.where(b_face >= 0, b_face * rho_left, b_face * rho_right)\n        \n        # Diffusive flux\n        J_diff_interior = -D_face * (rho_right - rho_left) / dx\n        \n        # Total flux\n        J[1:-1] = J_adv_interior + J_diff_interior\n        \n        # Compute the discrete operator L(rho) = -div(J)\n        L_rho = -(J[1:] - J[:-1]) / dx\n        \n        # Evolve rho for one time step\n        drho_dt = L_rho + g_true * rho0\n        rho_tau = rho0 + tau * drho_dt\n        \n        # 4. Calculate the two estimators for g(x)\n        \n        # Estimator from clonal data \n        # (synthetically generated from g_true)\n        m = np.exp(g_true * tau)\n        g_clonal = (1.0 / tau) * np.log(m)\n        \n        # Estimator from PDE\n        # We work with Y1 = rho0 * g_pde to avoid division by small rho0\n        # Y1 = (rho_tau - rho0)/tau - L_rho\n        Y1 = (rho_tau - rho0) / tau - L_rho\n        Y2 = g_clonal\n\n        # 5. Perform weighted least squares\n        # The linear system is M * [a0, a1]^T = v\n        \n        # Build the matrix M\n        w = rho0**2 + 1\n        M = np.zeros((2, 2))\n        M[0, 0] = np.sum(w)\n        M[0, 1] = np.sum(w * s)\n        M[1, 0] = M[0, 1]\n        M[1, 1] = np.sum(w * s**2)\n\n        # Build the vector v\n        rhs_summand = rho0 * Y1 + Y2\n        v = np.zeros(2)\n        v[0] = np.sum(rhs_summand)\n        v[1] = np.sum(s * rhs_summand)\n        \n        # Solve for parameters a = [a0, a1]\n        try:\n            a = np.linalg.solve(M, v)\n        except np.linalg.LinAlgError:\n            # Fallback to pseudo-inverse if singular\n            a = np.linalg.pinv(M) @ v\n            \n        a0_est, a1_est = a[0], a[1]\n\n        # 6. Calculate estimated g and MAE\n        g_est = a0_est + a1_est * s\n        mae = np.mean(np.abs(g_est - g_true))\n        \n        return mae\n\n    # Test Suite\n    test_cases = {\n        'A': {\n            'N': 50, 'tau': 0.001,\n            's_func': lambda x: x,\n            'b_func': lambda x: -0.5 * (x - 0.5),\n            'D_func': lambda x: 0.01 + np.zeros_like(x),\n            'g_true_func': lambda x, s: 0.1 + 0.4 * s,\n            'rho0_func': lambda x: np.exp(-(x - 0.6)**2 / (2 * 0.1**2))\n        },\n        'B': {\n            'N': 50, 'tau': 0.001,\n            's_func': lambda x: np.sin(2 * np.pi * x) + 1.0,\n            'b_func': lambda x: np.zeros_like(x),\n            'D_func': lambda x: 0.005 + np.zeros_like(x),\n            'g_true_func': lambda x, s: 0.2 + np.zeros_like(s), # Constant g\n            'rho0_func': lambda x: np.ones_like(x)\n        },\n        'C': {\n            'N': 80, 'tau': 0.001,\n            's_func': lambda x: x**2,\n            'b_func': lambda x: 0.8 * np.sin(np.pi * x),\n            'D_func': lambda x: 0.02 + 0.02 * x,\n            'g_true_func': lambda x, s: 0.05 + 0.3 * s,\n            'rho0_func': lambda x: (np.exp(-(x - 0.3)**2 / (2 * 0.05**2)) + \n                                     0.8 * np.exp(-(x - 0.8)**2 / (2 * 0.07**2)))\n        }\n    }\n\n    results = []\n    for case_id in ['A', 'B', 'C']:\n        params = test_cases[case_id]\n        mae = solve_case(\n            params['N'], params['tau'], params['s_func'],\n            params['b_func'], params['D_func'], params['g_true_func'],\n            params['rho0_func']\n        )\n        results.append(round(mae, 6))\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在推断出细胞状态转换的动力学后，一个更深层次的问题是：这些动力学向量场的内在结构是什么？本实践引入了图论和代数拓扑中的一个强大工具——霍奇分解，它能将复杂的细胞状态转换向量场唯一地分解为无旋的梯度流和无散的环流部分。你将亲手实现这一分解过程，并将这些数学上正交的分量与关键的生物学过程（如分化和细胞周期）联系起来，从而揭示细胞命运决定背后的基本动力学模式 ()。",
            "id": "3327702",
            "problem": "考虑一个有限、简单、无向图，其顶点代表单细胞，其边连接转录相似的细胞。有向边流用于从单细胞测量中近似一个连续的细胞状态向量场；具体来说，每条无向边上的流向由节点标签的升序确定。设有向边流由向量 $y \\in \\mathbb{R}^{m}$ 表示，其中 $m$ 是边的数量。有向关联矩阵 $B \\in \\mathbb{R}^{m \\times n}$（其中 $n$ 是节点的数量）的定义如下：对于每条从节点 $i$ 指向节点 $j$（其中 $i<j$）的边，该行在第 $i$ 列为 -1，在第 $j$ 列为 1。边-三角形关联矩阵 $D_1 \\in \\mathbb{R}^{m \\times t}$（其中 $t$ 是图中三角形的数量）编码了图中所有三角形的边界。\n\n根据离散Hodge理论，任何边流向量 $y$ 都可以唯一地正交分解为梯度分量 $y_{\\mathrm{grad}}$、旋度分量 $y_{\\mathrm{curl}}$ 和调和分量 $y_{\\mathrm{harm}}$。这些分量可以通过将 $y$ 投影到 $B$ 的图像、 $D_1$ 的图像以及正交补空间上来计算。梯度分量由势 $\\phi \\in \\mathbb{R}^n$ 产生（$y_{\\mathrm{grad}} = B\\phi$），与分化相关；旋度分量与细胞周期等循环过程相关。\n\n您的任务是：\n1.  对给定的流向量 $y$ 进行Hodge分解，得到 $y_{\\mathrm{grad}}$, $y_{\\mathrm{curl}}$, 和 $y_{\\mathrm{harm}}$。\n2.  计算每个分量的能量分数（范数平方与总范数平方的比值）：$f_{\\mathrm{grad}}$, $f_{\\mathrm{curl}}$, $f_{\\mathrm{harm}}$。\n3.  计算梯度势 $\\phi$ 与给定的伪时间向量 $p$ 之间的皮尔逊相关性 $r_{\\mathrm{grad}}$。\n4.  计算局部旋度大小向量 $c$ 与给定的细胞周期得分向量 $s$ 之间的皮尔逊相关性 $r_{\\mathrm{curl}}$。其中，$c_i$ 是节点 $i$ 处所有入射边上旋度流分量的均方根。\n5.  对提供的四个测试用例，计算这五个指标 $[f_{\\mathrm{grad}}, f_{\\mathrm{curl}}, f_{\\mathrm{harm}}, r_{\\mathrm{grad}}, r_{\\mathrm{curl}}]$，并将结果四舍五入到四位小数。最终输出一个包含四个此类列表的列表。",
            "solution": "该问题要求将图上的给定边流向量 $y \\in \\mathbb{R}^{m}$ 分解为三个正交分量：一个梯度分量 $y_{\\mathrm{grad}}$、一个旋度分量 $y_{\\mathrm{curl}}$ 和一个调和分量 $y_{\\mathrm{harm}}$。这种分解被称为离散Hodge分解。该过程和后续分析将按照要求从线性代数的基本原理推导。\n\n该图有 $n$ 个顶点（节点）和 $m$ 条边。按照惯例，每条无向边都被赋予从索引较小的节点指向索引较大的节点的方向。\n\n**1. 矩阵表示**\n\n节点、边和三角形（3-团）之间的关系由两个关联矩阵 $B$ 和 $D_1$ 捕获。\n\n**有向关联矩阵** $B \\in \\mathbb{R}^{m \\times n}$ 将基于节点的势映射到边上的梯度流。对于一条从节点 $i$ 指向节点 $j$（其中 $i<j$）的第 $k$ 条边，$B$ 的第 $k$ 行在第 $i$ 列为 -1，在第 $j$ 列为 1，其他位置为 0。\n\n**边-三角形关联矩阵** $D_1 \\in \\mathbb{R}^{m \\times t}$ (也称为边界算子) 将基于三角形的势映射到边上的环流。对于由节点 $i < j < k$ 构成的第 $l$ 个三角形， $D_1$ 的第 $l$ 列在对应于边 $(i, j)$ 和 $(j, k)$ 的行上为 1，在对应于边 $(i, k)$ 的行上为 -1。\n\n**2. Hodge分解**\n\nHodge分解将边流 $y$ 投影到三个正交子空间上：\n- **梯度分量 ($y_{\\mathrm{grad}}$):** 这是 $y$ 在 $B$ 的图像（列空间） $\\mathrm{Im}(B)$ 上的正交投影。它可以通过求解最小二乘问题 $\\min_{\\phi} \\|B\\phi - y\\|_2^2$ 来找到。解出的势 $\\phi$ 满足正规方程 $B^T B \\phi = B^T y$。梯度分量为 $y_{\\mathrm{grad}} = B\\phi$。\n- **旋度分量 ($y_{\\mathrm{curl}}$):** 这是 $y$ 在 $D_1$ 的图像 $\\mathrm{Im}(D_1)$ 上的正交投影。它可以通过求解最小二乘问题 $\\min_{\\alpha} \\|D_1\\alpha - y\\|_2^2$ 来找到。解出的 $\\alpha$ 满足正规方程 $D_1^T D_1 \\alpha = D_1^T y$。旋度分量为 $y_{\\mathrm{curl}} = D_1\\alpha$。\n- **调和分量 ($y_{\\mathrm{harm}}$):** 这是 $y$ 中既不是梯度也不是旋度的部分。由于这三个分量是正交的，调和分量可以直接通过从原始向量中减去梯度和旋度分量得到：$y_{\\mathrm{harm}} = y - y_{\\mathrm{grad}} - y_{\\mathrm{curl}}$。\n\n**3. 指标计算**\n\n1.  **能量分数**：\n    -   $f_{\\mathrm{grad}} = \\|y_{\\mathrm{grad}}\\|_2^2 / \\|y\\|_2^2$\n    -   $f_{\\mathrm{curl}} = \\|y_{\\mathrm{curl}}\\|_2^2 / \\|y\\|_2^2$\n    -   $f_{\\mathrm{harm}} = \\|y_{\\mathrm{harm}}\\|_2^2 / \\|y\\|_2^2$\n    其中 $\\|v\\|_2^2 = \\sum_i v_i^2$ 是向量的范数平方。\n\n2.  **梯度相关性 ($r_{\\mathrm{grad}}$)**：\n    这是从梯度分量分解中得到的势向量 $\\phi$ 与给定的伪时间向量 $p$ 之间的皮尔逊相关系数。\n\n3.  **旋度相关性 ($r_{\\mathrm{curl}}$)**：\n    首先，为每个节点 $i$ 计算局部旋度大小 $c_i$。这是节点 $i$ 所有入射边上旋度流分量 $(y_{\\mathrm{curl}})_k$ 的均方根：\n    $$c_i = \\sqrt{\\frac{1}{|\\mathcal{E}_i|} \\sum_{k \\in \\mathcal{E}_i} ((y_{\\mathrm{curl}})_k)^2}$$\n    其中 $\\mathcal{E}_i$ 是与节点 $i$ 相连的边的索引集合。然后，计算向量 $c$ 与给定的细胞周期得分向量 $s$ 之间的皮尔逊相关系数。\n\n这些步骤为分析给定的测试用例提供了一个完整的计算框架。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to process all test cases and print results.\n    \"\"\"\n\n    def _pearson_corr(x, y):\n        \"\"\"Computes Pearson correlation, handling zero standard deviation.\"\"\"\n        mean_x, mean_y = np.mean(x), np.mean(y)\n        std_x, std_y = np.std(x), np.std(y)\n\n        if std_x == 0 or std_y == 0:\n            return 0.0\n\n        cov = np.mean((x - mean_x) * (y - mean_y))\n        return cov / (std_x * std_y)\n\n    def _construct_matrices_and_y(case):\n        \"\"\"Constructs graph matrices and the flow vector y for a given test case.\"\"\"\n        n = case['n']\n        edges_raw = case['edges']\n        \n        nodes = list(range(n))\n        edges = sorted([tuple(sorted(e)) for e in edges_raw])\n        m = len(edges)\n        edge_map = {edge: i for i, edge in enumerate(edges)}\n\n        # Construct B matrix\n        B = np.zeros((m, n))\n        for i, edge in enumerate(edges):\n            u, v = edge\n            B[i, u] = -1\n            B[i, v] = 1\n        \n        # Find triangles\n        adj = {i: set() for i in nodes}\n        for u, v in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n        \n        triangles = []\n        for i in nodes:\n            for j in adj[i]:\n                if j > i:\n                    for k in adj[j]:\n                        if k > j and k in adj[i]:\n                            triangles.append((i, j, k))\n        triangles = sorted(triangles)\n        t = len(triangles)\n\n        # Construct D1 matrix\n        D1 = np.zeros((m, 0))\n        if t > 0:\n            D1 = np.zeros((m, t))\n            for k_idx, tri in enumerate(triangles):\n                i, j, k = tri  # i  j  k\n                D1[edge_map[(i, j)], k_idx] = 1\n                D1[edge_map[(j, k)], k_idx] = 1\n                D1[edge_map[(i, k)], k_idx] = -1\n\n        # Construct y vector\n        if 'y_direct' in case:\n            y = np.zeros(m)\n            for edge, val in case['y_direct'].items():\n                u, v = tuple(sorted(edge))\n                y[edge_map[(u, v)]] = val\n        else:\n            y_grad_gen = B @ np.array(case['phi_gen'])\n            \n            y_curl_gen = np.zeros(m)\n            if t > 0 and 'alpha_gen' in case:\n                alpha_vec = np.zeros(t)\n                for tri, amp in case['alpha_gen'].items():\n                    try:\n                        k_idx = triangles.index(tuple(sorted(tri)))\n                        alpha_vec[k_idx] = amp\n                    except ValueError:\n                        pass # Triangle not in graph\n                \n                gamma = case.get('gamma', 1.0)\n                y_curl_gen = gamma * (D1 @ alpha_vec)\n            \n            y = y_grad_gen + y_curl_gen\n            \n        return n, m, edges, edge_map, B, D1, t, y, np.array(case['p']), np.array(case['s'])\n\n\n    def process_case(case):\n        \"\"\"Performs Hodge decomposition and calculates metrics for a single case.\"\"\"\n        n, m, edges, edge_map, B, D1, t, y, p, s = _construct_matrices_and_y(case)\n\n        # Orthogonal projections\n        phi, _, _, _ = np.linalg.lstsq(B, y, rcond=None)\n        y_grad = B @ phi\n\n        if t > 0 and D1.shape[1] > 0:\n            alpha, _, _, _ = np.linalg.lstsq(D1, y, rcond=None)\n            y_curl = D1 @ alpha\n        else:\n            y_curl = np.zeros(m)\n        \n        y_harm = y - y_grad - y_curl\n\n        # Energy fractions\n        norm_y_sq = np.linalg.norm(y)**2\n        if norm_y_sq == 0:\n            f_grad, f_curl, f_harm = 0.0, 0.0, 0.0\n        else:\n            f_grad = np.linalg.norm(y_grad)**2 / norm_y_sq\n            f_curl = np.linalg.norm(y_curl)**2 / norm_y_sq\n            f_harm = np.linalg.norm(y_harm)**2 / norm_y_sq\n\n        # Correlation r_grad\n        r_grad = _pearson_corr(phi, p)\n\n        # Correlation r_curl\n        c = np.zeros(n)\n        adj_edge_indices = {i: [] for i in range(n)}\n        for edge_idx, edge in enumerate(edges):\n            u, v = edge\n            adj_edge_indices[u].append(edge_idx)\n            adj_edge_indices[v].append(edge_idx)\n\n        for i in range(n):\n            indices = adj_edge_indices[i]\n            if len(indices) > 0:\n                y_curl_incident_sq = y_curl[indices]**2\n                c[i] = np.sqrt(np.mean(y_curl_incident_sq))\n        \n        r_curl = _pearson_corr(c, s)\n\n        return [round(val, 4) for val in [f_grad, f_curl, f_harm, r_grad, r_curl]]\n\n    test_cases = [\n        {\n            \"n\": 6, \"edges\": [(0,1), (1,2), (0,2), (2,3), (3,4), (4,5)],\n            \"phi_gen\": [0.00, 0.20, 0.40, 0.60, 0.80, 1.00],\n            \"alpha_gen\": {(0,1,2): 1.00}, \"gamma\": 0.50,\n            \"p\": [0.00, 0.22, 0.39, 0.62, 0.81, 0.98],\n            \"s\": [1.00, 0.90, 0.80, 0.20, 0.10, 0.05],\n        },\n        {\n            \"n\": 6, \"edges\": [(0,1), (1,2), (0,2), (2,3), (3,4), (4,5)],\n            \"phi_gen\": [0.00, 0.20, 0.40, 0.60, 0.80, 1.00],\n            \"alpha_gen\": {(0,1,2): 0.00},\n            \"p\": [0.00, 0.20, 0.40, 0.60, 0.80, 1.00],\n            \"s\": [0.30, 0.50, 0.40, 0.60, 0.70, 0.20],\n        },\n        {\n            \"n\": 4, \"edges\": [(0,1), (1,2), (2,3), (0,3), (0,2)],\n            \"phi_gen\": [0.00, 0.00, 0.00, 0.00],\n            \"alpha_gen\": {(0,1,2): 1.00, (0,2,3): 0.20},\n            \"p\": [0.10, 0.40, 0.20, 0.30],\n            \"s\": [1.00, 0.95, 0.90, 0.60],\n        },\n        {\n            \"n\": 4, \"edges\": [(0,1), (1,2), (2,3), (0,3)],\n            \"p\": [0.00, 0.30, 0.60, 0.90],\n            \"s\": [0.20, 0.20, 0.20, 0.20],\n            \"y_direct\": {(0,1): 1.00, (1,2): 1.00, (2,3): 1.00, (0,3): -1.00},\n        }\n    ]\n\n    all_results = [process_case(case) for case in test_cases]\n    \n    # Format output as a string representation of a list of lists.\n    result_str = \"[\" + \", \".join([str(res) for res in all_results]) + \"]\"\n    print(result_str)\n\nsolve()\n```"
        }
    ]
}