{
    "hands_on_practices": [
        {
            "introduction": "在基于梯度的校准中，目标函数通常包含数据失配项和先验正则化项。本练习将重点关注一个基本任务：分析推导高斯先验项的梯度。通过这个“纸笔”实践，你将理解如何将关于参数的先验信念转化为指导优化过程的数学力量，并揭示先验的协方差结构如何影响参数更新的尺度和方向 。",
            "id": "3287571",
            "problem": "考虑为一个生物化学反应网络校准一个参数向量 $\\theta \\in \\mathbb{R}^{d}$，其状态 $x(t;\\theta) \\in \\mathbb{R}^{n}$ 遵循一个常微分方程 (ODE) 演化\n$$\n\\frac{d x}{d t} = f\\big(x(t;\\theta),\\theta\\big), \\quad x(0;\\theta) = x_{0},\n$$\n在时间点 $t_{i}$ 有观测值 $y_{i} \\in \\mathbb{R}^{m}$，这些观测值通过一个测量算子 $h:\\mathbb{R}^{n} \\to \\mathbb{R}^{m}$ 与状态相关联。一个用于基于梯度的校准的标准负对数后验目标函数是\n$$\nJ(\\theta) = \\frac{1}{2}\\sum_{i=1}^{N} \\| W^{1/2}\\big(h(x(t_{i};\\theta)) - y_{i}\\big) \\|_{2}^{2} \\;+\\; \\phi_{\\text{prior}}(\\theta),\n$$\n其中 $W \\in \\mathbb{R}^{m \\times m}$ 是对称正定矩阵，编码了观测权重，而 $\\phi_{\\text{prior}}(\\theta)$ 是负对数先验惩罚项。假设 $\\theta$ 服从均值为 $\\mu \\in \\mathbb{R}^{d}$、协方差为 $\\Sigma \\in \\mathbb{R}^{d \\times d}$ 的多元正态先验分布，其中 $\\Sigma$ 是对称正定的，因此先验密度为\n$$\np(\\theta) = (2\\pi)^{-d/2}|\\Sigma|^{-1/2}\\exp\\!\\left(-\\frac{1}{2}(\\theta - \\mu)^{\\top}\\Sigma^{-1}(\\theta - \\mu)\\right).\n$$\n从多元正态密度的这个基本定义出发，构造 $\\phi_{\\text{prior}}(\\theta)$，并明确推导出其梯度 $\\nabla_{\\theta}\\phi_{\\text{prior}}(\\theta)$（用 $\\theta$、$\\mu$ 和 $\\Sigma$ 表示）。然后，解释当与数据失配的伴随法计算梯度相结合时，由 $\\Sigma$ 编码的各向异性如何改变基于梯度的校准中的步长，并参考 $\\Sigma$ 的特征值和特征向量，以及这对形如 $\\theta_{k+1} = \\theta_{k} - \\alpha \\nabla_{\\theta}J(\\theta_{k})$ 的迭代中选择全局步长 $\\alpha$ 的影响。你的最终答案必须是 $\\nabla_{\\theta}\\phi_{\\text{prior}}(\\theta)$ 的精确闭式解析表达式，不得有任何数值近似。",
            "solution": "该问题要求三个部分：构造负对数先验惩罚项 $\\phi_{\\text{prior}}(\\theta)$，推导其梯度 $\\nabla_{\\theta}\\phi_{\\text{prior}}(\\theta)$，并解释该先验对基于梯度的校准的影响。\n\n首先，我们根据给定的先验概率密度函数 (PDF) 构造负对数先验惩罚项 $\\phi_{\\text{prior}}(\\theta)$。参数向量 $\\theta \\in \\mathbb{R}^{d}$ 的先验分布是均值为 $\\mu \\in \\mathbb{R}^{d}$、协方差为 $\\Sigma \\in \\mathbb{R}^{d \\times d}$ 的多元正态分布。其概率密度函数 (PDF) 如下：\n$$\np(\\theta) = (2\\pi)^{-\\frac{d}{2}}|\\Sigma|^{-\\frac{1}{2}}\\exp\\!\\left(-\\frac{1}{2}(\\theta - \\mu)^{\\top}\\Sigma^{-1}(\\theta - \\mu)\\right)\n$$\n负对数先验 $\\phi_{\\text{prior}}(\\theta)$ 定义为先验概率密度函数的负自然对数，通常省略相对于 $\\theta$ 为常数的项，因为它们不影响梯度。对 $p(\\theta)$ 取自然对数得到：\n$$\n\\ln(p(\\theta)) = \\ln\\left((2\\pi)^{-\\frac{d}{2}}|\\Sigma|^{-\\frac{1}{2}}\\right) + \\ln\\left(\\exp\\!\\left(-\\frac{1}{2}(\\theta - \\mu)^{\\top}\\Sigma^{-1}(\\theta - \\mu)\\right)\\right)\n$$\n$$\n\\ln(p(\\theta)) = -\\frac{d}{2}\\ln(2\\pi) - \\frac{1}{2}\\ln(|\\Sigma|) - \\frac{1}{2}(\\theta - \\mu)^{\\top}\\Sigma^{-1}(\\theta - \\mu)\n$$\n因此，负对数先验是：\n$$\n\\phi_{\\text{prior}}(\\theta) = -\\ln(p(\\theta)) = \\frac{1}{2}(\\theta - \\mu)^{\\top}\\Sigma^{-1}(\\theta - \\mu) + \\frac{d}{2}\\ln(2\\pi) + \\frac{1}{2}\\ln(|\\Sigma|)\n$$\n出于优化目的，常数项是无关紧要的，因此惩罚项实际上就是二次项。\n\n接下来，我们推导 $\\phi_{\\text{prior}}(\\theta)$ 关于 $\\theta$ 的梯度。我们需要计算上述表达式的梯度。常数项的梯度为零。\n$$\n\\nabla_{\\theta}\\phi_{\\text{prior}}(\\theta) = \\nabla_{\\theta}\\left( \\frac{1}{2}(\\theta - \\mu)^{\\top}\\Sigma^{-1}(\\theta - \\mu) \\right)\n$$\n我们使用二次型梯度的标准矩阵微积分恒等式。对于向量变量 $z$ 和对称矩阵 $A$，梯度由 $\\nabla_{z}\\left( (z-c)^{\\top}A(z-c) \\right) = 2A(z-c)$ 给出。在我们的例子中，变量是 $\\theta$，常数向量是 $\\mu$，矩阵是 $\\Sigma^{-1}$。协方差矩阵 $\\Sigma$ 已知是对称正定的，这意味着其逆矩阵 $\\Sigma^{-1}$ 也是对称的。应用这个恒等式，我们得到：\n$$\n\\nabla_{\\theta}\\left( (\\theta - \\mu)^{\\top}\\Sigma^{-1}(\\theta - \\mu) \\right) = 2\\Sigma^{-1}(\\theta - \\mu)\n$$\n将此结果代回 $\\phi_{\\text{prior}}(\\theta)$ 的梯度表达式中：\n$$\n\\nabla_{\\theta}\\phi_{\\text{prior}}(\\theta) = \\frac{1}{2} \\left( 2\\Sigma^{-1}(\\theta - \\mu) \\right) = \\Sigma^{-1}(\\theta - \\mu)\n$$\n这就是先验惩罚项梯度的解析表达式。\n\n最后，我们解释这个先验梯度对基于梯度的校准的影响。目标函数 $J(\\theta)$ 的总梯度是数据失配项的梯度和先验惩罚项梯度的和：\n$$\n\\nabla_{\\theta}J(\\theta) = \\nabla_{\\theta}\\left( \\frac{1}{2}\\sum_{i=1}^{N} \\left\\| W^{\\frac{1}{2}}(h(x(t_{i};\\theta)) - y_{i}) \\right\\|_{2}^{2} \\right) + \\Sigma^{-1}(\\theta - \\mu)\n$$\n数据失配梯度（通常通过伴随法计算）驱动参数趋向于拟合观测值 $y_i$ 的值。先验梯度 $\\Sigma^{-1}(\\theta - \\mu)$ 作为一个正则化项，将参数向量 $\\theta$ 拉向先验均值 $\\mu$。\n\n理解其效果的关键在于矩阵 $\\Sigma^{-1}$，即所谓的精度矩阵。协方差矩阵 $\\Sigma$ 是对称正定的，可以对角化为 $\\Sigma = V \\Lambda V^{\\top}$，其中 $V$ 是一个正交矩阵，其列是 $\\Sigma$ 的特征向量 $v_j$，$\\Lambda$ 是由相应正特征值 $\\lambda_j$ 构成的对角矩阵。特征向量 $v_j$ 定义了先验概率分布的主轴，而特征值 $\\lambda_j$ 表示先验在这些轴向上的方差（不确定性的度量）。\n\n那么精度矩阵就是 $\\Sigma^{-1} = (V \\Lambda V^{\\top})^{-1} = V \\Lambda^{-1} V^{\\top}$。其特征值为 $1/\\lambda_j$。先验梯度的贡献是 $\\Sigma^{-1}(\\theta-\\mu) = V \\Lambda^{-1} V^{\\top}(\\theta-\\mu)$。该项揭示了正则化的各向异性性质：\n\\begin{enumerate}\n    \\item $\\Sigma$ 的一个小特征值 $\\lambda_j$ 对应于一个方向 $v_j$，在该方向上先验知识非常确定（低方差）。$\\Sigma^{-1}$ 的相应特征值很大 ($1/\\lambda_j$)。因此，$\\theta$ 沿此方向 $v_j$ 与均值 $\\mu$ 的任何偏差都会产生一个非常大的梯度分量，从而强烈惩罚该偏差，并将参数值沿该轴推回先验均值。\n    \\item $\\Sigma$ 的一个大特征值 $\\lambda_k$ 对应于一个先验不确定性高的方向 $v_k$（大方差）。$\\Sigma^{-1}$ 的相应特征值很小 ($1/\\lambda_k$)。沿此方向的偏差受到的惩罚很弱，从而允许数据失配梯度在该方向的参数更新中发挥更大的影响。\n\\end{enumerate}\n这种各向异性对形如 $\\theta_{k+1} = \\theta_{k} - \\alpha \\nabla_{\\theta}J(\\theta_{k})$ 的标准梯度下降更新步骤有重要影响，其中 $\\alpha$ 是一个单一的全局步长。总梯度向量 $\\nabla_{\\theta}J(\\theta_{k})$ 的分量大小将会有巨大差异，特别是当 $\\Sigma$ 的特征值跨越几个数量级时。最大允许步长 $\\alpha$ 受限于需要在最大梯度分量方向上保持稳定性的需求，该方向通常与最小先验方差（最小的 $\\lambda_j$，最大的 $1/\\lambda_j$）相关联。对所有参数方向都使用如此小的 $\\alpha$ 会导致在梯度较小的方向（例如，那些对应于大先验方差的方向）收敛极其缓慢。这个问题被称为病态问题 (ill-conditioning)，它表明，对于具有各向异性先验的目标函数，使用标量步长的无预处理梯度下降法是低效的。先验的结构内在地表明，应沿不同的参数方向采取不同的步长，这推动了预处理或二阶优化方法的使用。",
            "answer": "$$\\boxed{\\Sigma^{-1}(\\theta - \\mu)}$$"
        },
        {
            "introduction": "推导出正确的伴随方程是一回事，但在代码中无误地实现它们则完全是另一项挑战。本动手练习将指导你实现一个强大的验证技术——离散伴随恒等式检验，它可以作为你的伴随求解器的严格“单元测试”。通过数值验证这一数学恒等式，你可以确信你的切线和伴随算子实现是正确的，这对于开发可靠的科学计算软件是一项不可或缺的技能 。",
            "id": "3287583",
            "problem": "考虑一个由常微分方程 (ODE) 在连续时间内建模的三物种生化反应网络。令状态为 $x(t) \\in \\mathbb{R}^3$，其分量 $x_1(t)$、$x_2(t)$、$x_3(t)$ 表示浓度；令参数向量为 $\\theta \\in \\mathbb{R}^7$，其分量 $\\theta_1,\\theta_2,\\theta_3,\\theta_4,\\theta_5,\\theta_6,\\theta_7$ 均为非负的反应速率常数。连续时间的右侧由质量作用动力学定义：\n$$\nf(x,\\theta) = \\begin{bmatrix}\n\\theta_1 - \\theta_2 x_1 - \\theta_3 x_1 x_2 \\\\\n\\theta_4 x_1 - \\theta_5 x_2 \\\\\n\\theta_6 x_2 - \\theta_7 x_3\n\\end{bmatrix},\n$$\n其关于 $x$ 的雅可比矩阵为\n$$\nJ(x,\\theta) = \\frac{\\partial f(x,\\theta)}{\\partial x} = \\begin{bmatrix}\n-\\theta_2 - \\theta_3 x_2  -\\theta_3 x_1  0 \\\\\n\\theta_4  -\\theta_5  0 \\\\\n0  \\theta_6  -\\theta_7\n\\end{bmatrix}.\n$$\n使用时间步长 $\\Delta t > 0$（单位：秒）的后向欧拉法对动力学进行单步离散化：\n$$\nx_{k+1} - x_k - \\Delta t \\, f(x_{k+1},\\theta) = 0,\n$$\n并考虑在状态 $x_{k+1}$ 处的任意扰动 $\\delta x_{k+1} \\in \\mathbb{R}^3$，以及任意的伴随向量 $\\lambda_k,\\lambda_{k+1} \\in \\mathbb{R}^3$。后向欧拉法的线性化切线映射由下式给出\n$$\n\\delta x_k = \\left(I - \\Delta t \\, J(x_{k+1},\\theta)\\right) \\, \\delta x_{k+1}.\n$$\n定义在步骤 $k+1$ 处的离散伴随残差为\n$$\nr_{k+1} := \\frac{\\left(I - \\Delta t \\, J(x_{k+1},\\theta)^\\top\\right)\\lambda_k - \\lambda_{k+1}}{\\Delta t}.\n$$\n待测试的离散伴随恒等式表明，对于任意扰动 $\\delta x_{k+1}$ 和伴随向量 $\\lambda_k,\\lambda_{k+1}$，以下等式成立：\n$$\n\\langle \\lambda_k, \\delta x_k \\rangle - \\langle \\lambda_{k+1}, \\delta x_{k+1} \\rangle = \\Delta t \\, \\langle r_{k+1}, \\delta x_{k+1} \\rangle,\n$$\n其中 $\\langle \\cdot,\\cdot \\rangle$ 表示标准欧几里得内积。\n\n您的任务是使用上述的 $f(x,\\theta)$ 和 $J(x,\\theta)$，为该后向欧拉离散化实现一个离散伴随恒等式测试，并针对具有任意扰动和伴随向量的多种情况对该恒等式进行数值验证。对于每个测试用例，您必须：\n- 计算 $J(x_{k+1},\\theta)$。\n- 计算 $\\delta x_k = \\left(I - \\Delta t \\, J(x_{k+1},\\theta)\\right)\\delta x_{k+1}$。\n- 计算 $r_{k+1} = \\frac{\\left(I - \\Delta t \\, J(x_{k+1},\\theta)^\\top\\right)\\lambda_k - \\lambda_{k+1}}{\\Delta t}$。\n- 计算绝对误差\n$$\n\\varepsilon = \\left| \\langle \\lambda_k, \\delta x_k \\rangle - \\langle \\lambda_{k+1}, \\delta x_{k+1} \\rangle - \\Delta t \\, \\langle r_{k+1}, \\delta x_{k+1} \\rangle \\right|.\n$$\n\n科学真实性要求：\n- 所有反应速率常数 $\\theta_i$ 必须为非负。\n- 所有浓度 $x_i$ 必须为非负。\n- 时间步长 $\\Delta t$ 必须为正，并以秒为单位。\n\n测试套件：\n为以下五个案例实现测试。在每个案例中，使用固定种子从零均值单位方差的正态分布中生成伴随向量 $\\lambda_k, \\lambda_{k+1}$ 和扰动 $\\delta x_{k+1}$（以确保确定性的任意扰动）。对每个向量独立使用三维标准正态分布。\n\n- 案例 1（理想路径）：$\\Delta t = 0.1$ 秒, $\\theta = [0.8, 0.5, 0.4, 0.3, 0.2, 1.0, 0.7]$, $x_{k+1} = [1.0, 0.8, 0.5]$, 种子 $101$。\n- 案例 2（边界：极小时间步长）：$\\Delta t = 10^{-6}$ 秒, $\\theta = [0.2, 0.1, 0.05, 0.3, 0.25, 0.4, 0.35]$, $x_{k+1} = [0.1, 0.05, 0.02]$, 种子 $202$。\n- 案例 3（类刚性动力学：大时间步长和速率）：$\\Delta t = 1.0$ 秒, $\\theta = [2.0, 1.5, 1.2, 0.8, 0.9, 1.1, 1.0]$, $x_{k+1} = [3.0, 2.0, 1.0]$, 种子 $303$。\n- 案例 4（近退化 $I - \\Delta t J$：大相互作用）：$\\Delta t = 0.9$ 秒, $\\theta = [1.0, 1.0, 5.0, 2.5, 0.1, 0.6, 0.5]$, $x_{k+1} = [10.0, 10.0, 10.0]$, 种子 $404$。\n- 案例 5（近零雅可比矩阵：极小浓度）：$\\Delta t = 0.05$ 秒, $\\theta = [0.1, 0.1, 0.05, 0.2, 0.1, 0.15, 0.12]$, $x_{k+1} = [10^{-9}, 2 \\cdot 10^{-9}, 3 \\cdot 10^{-9}]$, 种子 $505$。\n\n最终输出规范：\n您的程序应生成单行输出，其中包含五个案例的绝对误差，格式为方括号内以逗号分隔的列表（例如 $[e_1,e_2,e_3,e_4,e_5]$）。每个 $e_i$ 都必须是一个实数（浮点数），表示相应案例计算出的 $\\varepsilon$。误差是无量纲的实数。不应打印任何其他文本。",
            "solution": "在尝试解决问题之前，需对问题进行验证。\n\n### 步骤 1：提取已知信息\n\n- **状态向量：**$x(t) \\in \\mathbb{R}^3$，其分量 $x_1(t)$, $x_2(t)$, $x_3(t)$ 表示浓度。\n- **参数向量：**$\\theta \\in \\mathbb{R}^7$，其分量 $\\theta_1, \\dots, \\theta_7$ 表示非负的反应速率常数。\n- **连续时间动力学函数：**$f(x,\\theta) = \\begin{bmatrix} \\theta_1 - \\theta_2 x_1 - \\theta_3 x_1 x_2 \\\\ \\theta_4 x_1 - \\theta_5 x_2 \\\\ \\theta_6 x_2 - \\theta_7 x_3 \\end{bmatrix}$。\n- **动力学的雅可比矩阵：**$J(x,\\theta) = \\frac{\\partial f(x,\\theta)}{\\partial x} = \\begin{bmatrix} -\\theta_2 - \\theta_3 x_2  -\\theta_3 x_1  0 \\\\ \\theta_4  -\\theta_5  0 \\\\ 0  \\theta_6  -\\theta_7 \\end{bmatrix}$。\n- **离散化方法：**后向欧拉法，时间步长 $\\Delta t > 0$，由隐式方程 $x_{k+1} - x_k - \\Delta t \\, f(x_{k+1},\\theta) = 0$ 定义。\n- **扰动和伴随向量：**任意扰动 $\\delta x_{k+1} \\in \\mathbb{R}^3$ 和任意伴随向量 $\\lambda_k, \\lambda_{k+1} \\in \\mathbb{R}^3$。\n- **线性化切线映射：**$\\delta x_k = \\left(I - \\Delta t \\, J(x_{k+1},\\theta)\\right) \\, \\delta x_{k+1}$，其中 $I$ 是 $3 \\times 3$ 单位矩阵。\n- **离散伴随残差：**$r_{k+1} := \\frac{\\left(I - \\Delta t \\, J(x_{k+1},\\theta)^\\top\\right)\\lambda_k - \\lambda_{k+1}}{\\Delta t}$。\n- **离散伴随恒等式：**$\\langle \\lambda_k, \\delta x_k \\rangle - \\langle \\lambda_{k+1}, \\delta x_{k+1} \\rangle = \\Delta t \\, \\langle r_{k+1}, \\delta x_{k+1} \\rangle$。\n- **内积：**$\\langle \\cdot,\\cdot \\rangle$ 是标准欧几里得内积。\n- **绝对误差度量：**$\\varepsilon = \\left| \\langle \\lambda_k, \\delta x_k \\rangle - \\langle \\lambda_{k+1}, \\delta x_{k+1} \\rangle - \\Delta t \\, \\langle r_{k+1}, \\delta x_{k+1} \\rangle \\right|$。\n- **科学真实性约束：**$\\theta_i \\ge 0$, $x_i \\ge 0$, $\\Delta t > 0$。\n- **测试用例：**定义了五个具体的数值案例，给定了 $\\Delta t$、$\\theta$、$x_{k+1}$ 的值以及用于随机数生成的种子。随机向量 $\\lambda_k, \\lambda_{k+1}, \\delta x_{k+1}$ 将从一个三维标准正态分布中抽取。\n\n### 步骤 2：使用提取的已知信息进行验证\n\n- **科学依据：**该问题基于化学动力学（质量作用）、常微分方程数值分析（后向欧拉法）和灵敏度分析（伴随方法）的标准原理。这些是计算系统生物学中的基本概念。模型和方程与既定理论一致。\n- **适定性：**该问题提供了一个清晰、明确的任务：为一组完全指定的测试用例，数值验证一个给定的数学恒等式。所有必要的方程、参数和初始值均已提供。每个案例的唯一数值结果（$\\varepsilon$）的存在性得到保证。\n- **客观性：**问题完全以客观的数学语言陈述。由于为随机数生成指定了种子，测试用例是确定性的。\n- **缺陷清单：**\n    1.  **科学/事实不健全：**问题的核心是离散伴随恒等式。这个恒等式是一个数学上的重言式，由切线映射和伴随残差的定义推导而来。令 $A = I - \\Delta t \\, J(x_{k+1},\\theta)$。切线映射是 $\\delta x_k = A \\, \\delta x_{k+1}$。伴随残差是 $r_{k+1} = \\frac{1}{\\Delta t}(A^\\top \\lambda_k - \\lambda_{k+1})$。待测试的恒等式是 $\\langle \\lambda_k, \\delta x_k \\rangle - \\langle \\lambda_{k+1}, \\delta x_{k+1} \\rangle = \\Delta t \\, \\langle r_{k+1}, \\delta x_{k+1} \\rangle$。通过代入定义并使用伴随算子（对于欧几里得内积，即转置）的性质 $\\langle u, Av \\rangle = \\langle A^\\top u, v \\rangle$，左侧变为 $\\langle \\lambda_k, A \\delta x_{k+1} \\rangle - \\langle \\lambda_{k+1}, \\delta x_{k+1} \\rangle = \\langle A^\\top \\lambda_k, \\delta x_{k+1} \\rangle - \\langle \\lambda_{k+1}, \\delta x_{k+1} \\rangle = \\langle A^\\top \\lambda_k - \\lambda_{k+1}, \\delta x_{k+1} \\rangle$。右侧是 $\\Delta t \\, \\langle \\frac{1}{\\Delta t}(A^\\top \\lambda_k - \\lambda_{k+1}), \\delta x_{k+1} \\rangle = \\langle A^\\top \\lambda_k - \\lambda_{k+1}, \\delta x_{k+1} \\rangle$。该恒等式在数学上是正确的。问题是健全的。\n    2.  **非形式化/不相关：**该问题是明确形式化的，并且与验证计算科学中伴随求解器的实现直接相关。\n    3.  **不完整/矛盾：**问题是自洽的且内部一致的。\n    4.  **不现实/不可行：**给定的参数遵循科学真实性约束（$\\theta_i \\ge 0$, $x_i \\ge 0$, $\\Delta t > 0$）。\n    5.  **不适定/结构不良：**问题结构良好，每个测试用例都能得到唯一的稳定结果。\n    6.  **伪深刻/琐碎：**虽然该恒等式是数学上的重言式，但其数值验证任务在科学计算的软件工程中是一项非凡且基础的实践，旨在确保离散算子已正确实现。\n    7.  **超出科学可验证性：**该主张是可以通过数值验证的。\n\n### 步骤 3：结论与行动\n\n此问题是 **有效的**。将提供一个解决方案。\n\n### 解答\n\n该问题要求对使用后向欧拉法离散化的常微分方程 (ODE) 系统的离散伴随恒等式进行数值验证。该恒等式是一个基本属性，它将扰动的前向传播（切线模型）与灵敏度的后向传播（伴随模型）联系起来。验证此恒等式是“梯度检查”中的关键步骤，以确保伴随求解器的正确实现。预期的结果是，绝对误差 $\\varepsilon$ 将为零，直到浮点运算精度的极限。\n\n恒等式的推导构成了理论基础。后向欧拉离散化为单个时间步定义了一个残差方程，$G(x_k, x_{k+1}, \\theta) = x_{k+1} - x_k - \\Delta t \\, f(x_{k+1}, \\theta) = 0$。线性化切线模型描述了在时间 $k+1$ 的小扰动 $\\delta x_{k+1}$ 如何与在时间 $k$ 保持残差为零所需的相应扰动 $\\delta x_k$ 相关。这可以通过求 $G$ 的全微分找到：\n$$ dG = \\frac{\\partial G}{\\partial x_k} \\delta x_k + \\frac{\\partial G}{\\partial x_{k+1}} \\delta x_{k+1} = 0 $$\n有 $\\frac{\\partial G}{\\partial x_k} = -I$ 和 $\\frac{\\partial G}{\\partial x_{k+1}} = I - \\Delta t \\frac{\\partial f}{\\partial x_{k+1}} = I - \\Delta t J(x_{k+1}, \\theta)$，我们得到：\n$$ -I \\delta x_k + (I - \\Delta t J(x_{k+1}, \\theta)) \\delta x_{k+1} = 0 $$\n这可以重新排列为所提供的线性化切线映射：\n$$ \\delta x_k = (I - \\Delta t J(x_{k+1}, \\theta)) \\delta x_{k+1} $$\n让我们将线性算子表示为 $A = I - \\Delta t J(x_{k+1}, \\theta)$。因此，$\\delta x_k = A \\delta x_{k+1}$。\n\n离散伴随恒等式 $\\langle \\lambda_k, \\delta x_k \\rangle - \\langle \\lambda_{k+1}, \\delta x_{k+1} \\rangle = \\Delta t \\, \\langle r_{k+1}, \\delta x_{k+1} \\rangle$ 将前向映射 $A$ 与其伴随 $A^\\top$ 连接起来。我们可以通过代入 $\\delta x_k$ 和 $r_{k+1}$ 的定义来证明这个恒等式。\n\n令 LHS 为恒等式的左侧，RHS 为恒等式的右侧。\n$$ \\text{LHS} = \\langle \\lambda_k, \\delta x_k \\rangle - \\langle \\lambda_{k+1}, \\delta x_{k+1} \\rangle $$\n代入 $\\delta x_k = A \\delta x_{k+1}$：\n$$ \\text{LHS} = \\langle \\lambda_k, A \\delta x_{k+1} \\rangle - \\langle \\lambda_{k+1}, \\delta x_{k+1} \\rangle $$\n使用欧几里得内积的伴随算子性质 $\\langle u, Av \\rangle = \\langle A^\\top u, v \\rangle$：\n$$ \\text{LHS} = \\langle A^\\top \\lambda_k, \\delta x_{k+1} \\rangle - \\langle \\lambda_{k+1}, \\delta x_{k+1} \\rangle $$\n根据内积的线性性质：\n$$ \\text{LHS} = \\langle A^\\top \\lambda_k - \\lambda_{k+1}, \\delta x_{k+1} \\rangle $$\n现在考虑 RHS（右侧）：\n$$ \\text{RHS} = \\Delta t \\, \\langle r_{k+1}, \\delta x_{k+1} \\rangle $$\n代入伴随残差的定义 $r_{k+1} = \\frac{A^\\top \\lambda_k - \\lambda_{k+1}}{\\Delta t}$：\n$$ \\text{RHS} = \\Delta t \\, \\left\\langle \\frac{A^\\top \\lambda_k - \\lambda_{k+1}}{\\Delta t}, \\delta x_{k+1} \\right\\rangle $$\n再次，根据内积的线性性质：\n$$ \\text{RHS} = \\langle \\Delta t \\left( \\frac{A^\\top \\lambda_k - \\lambda_{k+1}}{\\Delta t} \\right), \\delta x_{k+1} \\rangle = \\langle A^\\top \\lambda_k - \\lambda_{k+1}, \\delta x_{k+1} \\rangle $$\n由于 LHS = RHS，该恒等式在数学上是精确的。\n\n算法实现将对每个测试用例遵循以下理论步骤：\n1.  为可复现性设置随机种子。\n2.  从标准正态分布生成任意向量 $\\lambda_k, \\lambda_{k+1}, \\delta x_{k+1} \\in \\mathbb{R}^3$。\n3.  使用给定的状态 $x_{k+1}$ 和参数 $\\theta$ 构建雅可比矩阵 $J(x_{k+1}, \\theta)$。\n4.  计算矩阵 $A = I - \\Delta t J(x_{k+1}, \\theta)$。\n5.  计算传播的扰动 $\\delta x_k = A \\delta x_{k+1}$。\n6.  计算伴随残差 $r_{k+1} = \\frac{1}{\\Delta t} (A^\\top \\lambda_k - \\lambda_{k+1})$。\n7.  使用向量点积计算 LHS（左侧），$L = \\langle \\lambda_k, \\delta x_k \\rangle - \\langle \\lambda_{k+1}, \\delta x_{k+1} \\rangle$。\n8.  使用向量点积计算 RHS（右侧），$R = \\Delta t \\langle r_{k+1}, \\delta x_{k+1} \\rangle$。\n9.  最后，计算绝对误差 $\\varepsilon = |L - R|$。该值预期在机器epsilon的量级，从而证实数值实现的正确性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a discrete adjoint identity test for a backward Euler discretization\n    of a 3-species biochemical reaction network.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"dt\": 0.1,\n            \"theta\": np.array([0.8, 0.5, 0.4, 0.3, 0.2, 1.0, 0.7]),\n            \"x_kp1\": np.array([1.0, 0.8, 0.5]),\n            \"seed\": 101,\n        },\n        {\n            \"dt\": 1e-6,\n            \"theta\": np.array([0.2, 0.1, 0.05, 0.3, 0.25, 0.4, 0.35]),\n            \"x_kp1\": np.array([0.1, 0.05, 0.02]),\n            \"seed\": 202,\n        },\n        {\n            \"dt\": 1.0,\n            \"theta\": np.array([2.0, 1.5, 1.2, 0.8, 0.9, 1.1, 1.0]),\n            \"x_kp1\": np.array([3.0, 2.0, 1.0]),\n            \"seed\": 303,\n        },\n        {\n            \"dt\": 0.9,\n            \"theta\": np.array([1.0, 1.0, 5.0, 2.5, 0.1, 0.6, 0.5]),\n            \"x_kp1\": np.array([10.0, 10.0, 10.0]),\n            \"seed\": 404,\n        },\n        {\n            \"dt\": 0.05,\n            \"theta\": np.array([0.1, 0.1, 0.05, 0.2, 0.1, 0.15, 0.12]),\n            \"x_kp1\": np.array([1e-9, 2e-9, 3e-9]),\n            \"seed\": 505,\n        },\n    ]\n\n    def compute_jacobian(x, theta):\n        \"\"\"\n        Computes the Jacobian matrix J(x, theta).\n        x: state vector [x1, x2, x3]\n        theta: parameter vector [theta1, ..., theta7]\n        \"\"\"\n        x1, x2, x3 = x\n        th1, th2, th3, th4, th5, th6, th7 = theta\n        \n        J = np.zeros((3, 3))\n        \n        J[0, 0] = -th2 - th3 * x2\n        J[0, 1] = -th3 * x1\n        J[0, 2] = 0.0\n        \n        J[1, 0] = th4\n        J[1, 1] = -th5\n        J[1, 2] = 0.0\n        \n        J[2, 0] = 0.0\n        J[2, 1] = th6\n        J[2, 2] = -th7\n        \n        return J\n\n    results = []\n    for case in test_cases:\n        dt = case[\"dt\"]\n        theta = case[\"theta\"]\n        x_kp1 = case[\"x_kp1\"]\n        seed = case[\"seed\"]\n\n        # Set the seed for deterministic random vector generation\n        np.random.seed(seed)\n\n        # Generate arbitrary vectors from N(0, I_3)\n        lambda_k = np.random.randn(3)\n        lambda_kp1 = np.random.randn(3)\n        delta_x_kp1 = np.random.randn(3)\n\n        # Compute the Jacobian J(x_{k+1}, theta)\n        J_kp1 = compute_jacobian(x_kp1, theta)\n\n        # The linear operator from the linearized backward Euler step\n        # A = I - dt * J\n        I = np.identity(3)\n        A = I - dt * J_kp1\n\n        # Compute delta_x_k using the linearized tangent mapping\n        # delta_x_k = (I - dt*J) * delta_x_{k+1}\n        delta_x_k = A @ delta_x_kp1\n\n        # Compute the discrete adjoint residual r_{k+1}\n        # r_{k+1} = ((I - dt*J^T)*lambda_k - lambda_{k+1}) / dt\n        A_T = A.T # (I - dt*J)^T = I - dt*J^T\n        r_kp1 = (A_T @ lambda_k - lambda_kp1) / dt\n        \n        # Compute the Left-Hand Side (LHS) of the adjoint identity\n        lhs = np.dot(lambda_k, delta_x_k) - np.dot(lambda_kp1, delta_x_kp1)\n        \n        # Compute the Right-Hand Side (RHS) of the adjoint identity\n        rhs = dt * np.dot(r_kp1, delta_x_kp1)\n        \n        # Compute the absolute error\n        error = np.abs(lhs - rhs)\n        results.append(error)\n            \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "许多前沿的系统生物学模型都耦合了多种物理过程，例如力学与生物化学。本练习将带你从简单的常微分方程（ODE）系统进入一个更真实的耦合偏微分方程（PDE）模型，这需要采用分区伴随方法。你将学习如何为一个在每个时间步内顺序求解不同物理场的系统推导和实现伴随求解器，这是解决复杂多物理场校准问题的关键能力 。",
            "id": "3287555",
            "problem": "考虑一个一维空间域上的力学化学模型，该模型将一个准静态弹性平衡方程与一个反应扩散方程耦合。控制方程的连续偏微分方程(PDEs)由弹性力学方程 $\\nabla\\cdot(\\sigma(u,p))=0$ 和反应扩散方程 $\\partial_t c = \\nabla\\cdot(D\\nabla c) + R(c,u,p)$ 给出，其中 $u$ 是位移，$c$ 是浓度，$p$ 是一个参数向量。当观测值同时依赖于 $u$ 和 $c$ 时，您将推导并实现一个针对特定线性、时间离散和空间离散模型的分区离散伴随方法，以计算校准代价泛函的梯度。\n\n从以下基本原理出发：\n- 准静态弹性力学中的线性动量守恒，在小应变下导出一个关于 $u$ 的线性椭圆方程。\n- Fick 扩散定律和 $c$ 的质量平衡，导出一个关于 $c$ 的抛物线方程。\n- 在均匀网格上对空间导数进行标准有限差分離散化，并采用齐次 Dirichlet 边界条件。\n- 对线性扩散采用后向欧拉时间离散化。\n\n离散化设置：\n- 空间域为 $[0,1]$，有 $N$ 个内部网格点，其中 $N = 10$。令 $\\Delta x = 1/(N+1)$，$x_i = i \\Delta x$，$i = 1,\\dots,N$。\n- 时间区间为 $[0,T]$，有 $N_t = 5$ 个等长时间步，$\\Delta t = 0.1$，因此 $t_n = n \\Delta t$，$n=0,\\dots,N_t$，且 $T = N_t \\Delta t = 0.5$。\n- 离散拉普拉斯算子 $L \\in \\mathbb{R}^{N \\times N}$ 由齐次 Dirichlet 边界条件和标准二阶中心差分格式定义：\n$$\n(L v)_i = \\frac{v_{i-1} - 2 v_i + v_{i+1}}{\\Delta x^2}, \\quad v_0 = v_{N+1} = 0,\\quad i=1,\\dots,N.\n$$\n- 弹性算子定义为 $K = - E L + k_u I$，其中 $E = 1.0$，$k_u = 1.0$，$I$ 是 $N\\times N$ 单位矩阵。\n- 反应扩散隐式算子定义为 $M(p_2) = I - \\Delta t\\, D\\, L + \\Delta t\\, p_2 I$，其中扩散系数 $D = 0.1$。\n- 耦合常数在弹性力学中为 $\\gamma = 1.0$，在反应项中为参数 $p_3$。\n- 参数向量为 $p = (p_1, p_2, p_3)$，其中 $p_1$ 缩放化学-力学体力，$p_2$ 是 $c$ 的线性衰减率，$p_3$ 是反应项中一个与 $u$ 成正比的线性源项。\n- 浓度的初始条件为 $c^0_i = \\sin(\\pi x_i)$，编码为向量 $c^0$，其分量为 $c^0_i = \\sin(\\pi x_i)$，$i=1,\\dots,N$。\n- 对 $u$ 和 $c$ 均施加齐次 Dirichlet 边界条件，即 $u(0)=u(1)=0$ 和 $c(0,t)=c(1,t)=0$，这通过 $L$ 的选择被转换到离散系统中。\n\n分区前向时间步进格式：\n对于每个时间步 $n=0,1,\\dots,N_t-1$，给定 $c^n$，计算\n1. 弹性力学（准静态，线性）：\n$$\nu^{n+1} = K^{-1} (\\gamma\\, p_1\\, c^n).\n$$\n2. 反应扩散（扩散和衰减项采用后向欧拉格式，对 $c^{n+1}$ 是线性的）：\n$$\nM(p_2)\\, c^{n+1} = c^n + \\Delta t\\, p_3\\, u^{n+1}.\n$$\n收集序列 $\\{u^{n+1}\\}_{n=0}^{N_t-1}$ 和 $\\{c^n\\}_{n=0}^{N_t}$。\n\n观测值与代价泛函：\n- 通过使用参数 $p^\\star = (0.5, 0.7, 0.3)$ 模拟上述正向模型，并且无观测噪声，定义在最终时刻 $T$ 的观测向量 $u_{\\mathrm{obs}}$ 和 $c_{\\mathrm{obs}}$：\n$$\nu_{\\mathrm{obs}} = u^T(p^\\star), \\quad c_{\\mathrm{obs}} = c^T(p^\\star).\n$$\n- 定义任意 $p$ 的校准代价泛函为\n$$\nJ(p) = \\frac{1}{2} \\| u^T(p) - u_{\\mathrm{obs}} \\|_2^2 + \\frac{1}{2} \\| c^T(p) - c_{\\mathrm{obs}} \\|_2^2 + \\frac{\\lambda}{2} \\| p \\|_2^2,\n$$\n其中 Tikhonov 正则化参数 $\\lambda = 10^{-3}$，$\\|\\cdot\\|_2$ 是 $\\mathbb{R}^N$ 和 $\\mathbb{R}^3$ 上的欧几里得范数。所有量均为无量纲；您应将数值报告为无量纲浮点数。\n\n任务：\n1. 从离散正向映射出发，使用链式法则和线性系统的性质，为上述时间步进格式推导一个分区离散伴随方法，以计算梯度 $\\nabla_p J(p)$ 关于 $p = (p_1,p_2,p_3)$ 的值。推导必须从上面给出的定义开始，不得假定任何预先推導出的伴随公式。您的推导必须清楚地指出与 $c^{n}$ 和 $u^{n+1}$ 相关的伴随变量的后向递推关系，以及 $\\nabla_p J(p)$ 各分量的最终表达式。\n2. 实现一个完整、可运行的程序，该程序：\n   - 为指定的网格和参数构建 $L$、$K$ 和 $M(p_2)$。\n   - 使用 $p^\\star$ 生成 $u_{\\mathrm{obs}}$ 和 $c_{\\mathrm{obs}}$。\n   - 对于每个测试参数向量 $p$，运行正向模型，然后使用您推导的分区离散伴随方法计算 $\\nabla_p J(p)$。\n3. 测试套件：\n   使用以下三个参数向量作为测试用例：\n   - 情况 A（一般情况）：$p = (0.4, 0.6, 0.2)$。\n   - 情况 B（弱力学化学耦合）：$p = (10^{-6}, 0.6, 0.2)$。\n   - 情况 C（强衰减）：$p = (0.4, 2.0, 0.2)$。\n4. 最终输出格式：\n   您的程序应产生单行输出，其中包含一个逗号分隔的浮点数列表，并用方括号括起来，对应于三个情况的梯度向量的串联，顺序为 A、B、C。例如，程序应打印\n$$\n[\\partial_{p_1} J(p^{A}), \\partial_{p_2} J(p^{A}), \\partial_{p_3} J(p^{A}), \\partial_{p_1} J(p^{B}), \\partial_{p_2} J(p^{B}), \\partial_{p_3} J(p^{B}), \\partial_{p_1} J(p^{C}), \\partial_{p_2} J(p^{C}), \\partial_{p_3} J(p^{C})].\n$$\n以普通十进制浮点数（而非科学记数法）提供数值，条目之间用逗号分隔，整个列表用一对单独的方括号括起来，并且该行上没有其他任何内容。",
            "solution": "该问题是有效的，因为它具有科学依据、良定且客观。它为推导和实现一个定义好的力学化学模型的分区离散伴随方法提供了一套完整且一致的定义和数据。\n\n### 1. 系统方程与代价泛函\n\n离散正向模型随时间步 $n=1, \\dots, N_t$ 演化状态变量——位移 $u^n \\in \\mathbb{R}^N$ 和浓度 $c^n \\in \\mathbb{R}^N$。给定上一步的浓度 $c^{n-1}$，第 $n$ 步的状态通过分区格式计算：\n\n1.  **弹性力学方程：**\n    $$K u^n = \\gamma p_1 c^{n-1} \\quad (*)$$\n2.  **反应扩散方程：**\n    $$M(p_2) c^n = c^{n-1} + \\Delta t p_3 u^n \\quad (**)$$\n\n其中 $K = -E L + k_u I$ 和 $M(p_2) = I - \\Delta t\\, D\\, L + \\Delta t\\, p_2 I$ 对于给定的参数是对称正定矩阵。初始条件是 $c^0_i = \\sin(\\pi x_i)$。待校准的参数是 $p=(p_1, p_2, p_3)$。\n\n待最小化的代价泛函是：\n$$J(p) = \\frac{1}{2} \\| u^{N_t}(p) - u_{\\mathrm{obs}} \\|_2^2 + \\frac{1}{2} \\| c^{N_t}(p) - c_{\\mathrm{obs}} \\|_2^2 + \\frac{\\lambda}{2} \\| p \\|_2^2$$\n其中 $u^{N_t}$ 和 $c^{N_t}$ 是最终時刻 $T=N_t \\Delta t$ 的状态，$u_{\\mathrm{obs}}$ 和 $c_{\\mathrm{obs}}$ 是使用参考参数 $p^\\star$ 生成的观测值。\n\n我们的目标是使用离散伴随方法高效地计算梯度 $\\nabla_p J(p)$。\n\n### 2. 拉格朗日方法\n\n我们通过将代价泛函 $J$ 与作为约束的控制方程相结合，引入一个拉格朗日函数 $\\mathcal{L}$。我们为每个步骤 $n=1, \\dots, N_t$ 的弹性力学方程引入向量值的拉格朗日乘子（伴随变量）$\\psi^n \\in \\mathbb{R}^N$，为反应扩散方程引入 $\\phi^n \\in \\mathbb{R}^N$。\n\n拉格朗日函数为：\n$$\n\\mathcal{L}(p, \\{u^n\\}, \\{c^n\\}) = J + \\sum_{n=1}^{N_t} (\\psi^n)^T (K u^n - \\gamma p_1 c^{n-1}) + \\sum_{n=1}^{N_t} (\\phi^n)^T (M(p_2) c^n - c^{n-1} - \\Delta t p_3 u^n)\n$$\n状态变量 $u^n$ 和 $c^n$ 是 $p$ 的隐函数。只要 $\\mathcal{L}$ 关于所有状态变量的偏导数为零，代价泛函关于任意参数 $p_k$ 的全导数就由 $dJ/dp_k = \\partial\\mathcal{L}/\\partial p_k$ 给出。这个条件定义了伴随方程。\n\n### 3. 伴随方程的推导\n\n我们通过将 $\\mathcal{L}$ 关于每个状态变量 $u^n$（对于 $n=1, \\dots, N_t$）和 $c^n$（对于 $n=1, \\dots, N_t$）的偏导数设为零来求得伴随方程。\n\n**关于 $u^n$ 的导数：**\n状态 $u^n$ 出现在第 $n$ 个弹性约束项、第 $n$ 个反应扩散约束项中，并且如果 $n=N_t$，则出现在代价泛函 $J$ 中。\n$$\n\\frac{\\partial \\mathcal{L}}{\\partial u^n} = (\\psi^n)^T K - (\\phi^n)^T (\\Delta t p_3 I) + \\delta_{n,N_t} \\frac{\\partial J}{\\partial u^{N_t}} = 0\n$$\n取转置并注意到 $K$ 是对称的 ($K^T=K$)：\n$$K \\psi^n - \\Delta t p_3 \\phi^n + \\delta_{n,N_t} \\nabla_{u^{N_t}} J = 0$$\n其中 $\\nabla_{u^{N_t}} J = u^{N_t} - u_{\\mathrm{obs}}$。\n这给出了两种情况：\n- 对于 $n = N_t$，我们有 $\\psi^{N_t}$ 的终端条件：\n  $$K \\psi^{N_t} = \\Delta t p_3 \\phi^{N_t} - (u^{N_t} - u_{\\mathrm{obs}})$$\n- 对于 $n = 1, \\dots, N_t-1$：\n  $$K \\psi^n = \\Delta t p_3 \\phi^n$$\n\n**关于 $c^n$ 的导数：**\n状态 $c^n$ 出现在第 $(n+1)$ 个弹性约束项、第 $(n+1)$ 个反应扩散约束项、第 $n$ 个反应扩散约束项中，并且如果 $n=N_t$，则出现在代价泛函 $J$ 中。\n$$\n\\frac{\\partial \\mathcal{L}}{\\partial c^n} = (\\phi^n)^T M(p_2) - (\\psi^{n+1})^T (\\gamma p_1 I) - (\\phi^{n+1})^T I + \\delta_{n,N_t} \\frac{\\partial J}{\\partial c^{N_t}} = 0\n$$\n其中我们定义 $\\psi^{N_t+1} = 0$ 和 $\\phi^{N_t+1} = 0$。取转置并注意到 $M(p_2)$ 是对称的 ($M(p_2)^T = M(p_2)$)：\n$$M(p_2) \\phi^n - \\gamma p_1 \\psi^{n+1} - \\phi^{n+1} + \\delta_{n,N_t} \\nabla_{c^{N_t}} J = 0$$\n其中 $\\nabla_{c^{N_t}} J = c^{N_t} - c_{\\mathrm{obs}}$。\n这也给出了两种情况：\n- 对于 $n = N_t$，我们有 $\\phi^{N_t}$ 的终端条件：\n  $$M(p_2) \\phi^{N_t} = - \\nabla_{c^{N_t}} J = -(c^{N_t} - c_{\\mathrm{obs}})$$\n- 对于 $n = 1, \\dots, N_t-1$：\n  $$M(p_2) \\phi^n = \\phi^{n+1} + \\gamma p_1 \\psi^{n+1}$$\n\n**伴随变量的分区后向递推：**\n这些方程定义了一个必须从时间 $n=N_t$ 向后求解至 $n=1$ 的系统。\n\n1.  **终端步 ($n=N_t$)：**\n    首先，求解 $\\phi^{N_t}$：\n    $$M(p_2) \\phi^{N_t} = -(c^{N_t} - c_{\\mathrm{obs}})$$\n    然后，使用这个 $\\phi^{N_t}$，求解 $\\psi^{N_t}$：\n    $$K \\psi^{N_t} = \\Delta t p_3 \\phi^{N_t} - (u^{N_t} - u_{\\mathrm{obs}})$$\n\n2.  **后向循环 ($n = N_t-1, \\dots, 1$)：**\n    对于每个步骤 $n$，假设 $\\phi^{n+1}$ 和 $\\psi^{n+1}$ 从上一步（在后向时间中）已知：\n    首先，求解 $\\phi^n$：\n    $$M(p_2) \\phi^n = \\phi^{n+1} + \\gamma p_1 \\psi^{n+1}$$\n    然后，使用这个 $\\phi^n$，求解 $\\psi^n$：\n    $$K \\psi^n = \\Delta t p_3 \\phi^n$$\n\n### 4. 参数梯度的推导\n\n计算出伴随变量后，我们可以通过对拉格朗日函数 $\\mathcal{L}$ 求关于每个参数 $p_k$ 的导数来找到代价泛函的梯度。\n\n**关于 $p_1$ 的梯度：**\n参数 $p_1$ 只出现在弹性约束项中。\n$$\n\\nabla_{p_1} J = \\frac{\\partial \\mathcal{L}}{\\partial p_1} = \\frac{\\partial}{\\partial p_1} \\left( \\frac{\\lambda}{2} p_1^2 \\right) + \\sum_{n=1}^{N_t} (\\psi^n)^T (-\\gamma c^{n-1}) = \\lambda p_1 - \\gamma \\sum_{n=1}^{N_t} (\\psi^n)^T c^{n-1}\n$$\n\n**关于 $p_2$ 的梯度：**\n参数 $p_2$ 只通过 $M(p_2)$ 出现在反应扩散约束项中。注意 $\\partial M(p_2) / \\partial p_2 = \\Delta t I$。\n$$\n\\nabla_{p_2} J = \\frac{\\partial \\mathcal{L}}{\\partial p_2} = \\frac{\\partial}{\\partial p_2} \\left( \\frac{\\lambda}{2} p_2^2 \\right) + \\sum_{n=1}^{N_t} (\\phi^n)^T \\left( \\frac{\\partial M(p_2)}{\\partial p_2} c^n \\right) = \\lambda p_2 + \\sum_{n=1}^{N_t} (\\phi^n)^T (\\Delta t c^n) = \\lambda p_2 + \\Delta t \\sum_{n=1}^{N_t} (\\phi^n)^T c^n\n$$\n\n**关于 $p_3$ 的梯度：**\n参数 $p_3$ 只出现在反应扩散约束项中。\n$$\n\\nabla_{p_3} J = \\frac{\\partial \\mathcal{L}}{\\partial p_3} = \\frac{\\partial}{\\partial p_3} \\left( \\frac{\\lambda}{2} p_3^2 \\right) + \\sum_{n=1}^{N_t} (\\phi^n)^T (-\\Delta t u^n) = \\lambda p_3 - \\Delta t \\sum_{n=1}^{N_t} (\\phi^n)^T u^n\n$$\n\n这三个表达式提供了梯度 $\\nabla_p J(p)$ 的分量。整个算法包括一个计算并存储状态 $\\{u^n, c^n\\}$ 的前向过程，接着是一个计算伴随变量 $\\{\\psi^n, \\phi^n\\}$ 的后向过程，最后是使用存储的状态和伴随变量进行梯度组装的步骤。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import lu_factor, lu_solve\n\ndef construct_laplacian(N, dx):\n    \"\"\"Constructs the 1D discrete Laplacian matrix L with homogeneous Dirichlet BCs.\"\"\"\n    L = np.zeros((N, N))\n    diag_val = -2.0 / dx**2\n    off_diag_val = 1.0 / dx**2\n    np.fill_diagonal(L, diag_val)\n    if N > 1:\n        np.fill_diagonal(L[1:], off_diag_val)\n        np.fill_diagonal(L[:, 1:], off_diag_val)\n    return L\n\ndef forward_model(p, N, Nt, dt, dx, L, K_lu, c0, gamma):\n    \"\"\"Runs the forward simulation for a given parameter vector p.\"\"\"\n    p1, p2, p3 = p\n    \n    # Constants for reaction-diffusion operator\n    D = 0.1\n    # Elasticity operator K is constant, provided as LU-factored K_lu\n    \n    # Reaction-diffusion operator M depends on p2\n    I = np.identity(N)\n    M = I - dt * D * L + dt * p2 * I\n    M_lu = lu_factor(M)\n\n    # Store state histories\n    c_hist = {0: c0}\n    u_hist = {}\n\n    c_n = c0\n    for n in range(Nt):\n        # 1. Elasticity\n        rhs_u = gamma * p1 * c_n\n        u_np1 = lu_solve(K_lu, rhs_u)\n        \n        # 2. Reaction-diffusion\n        rhs_c = c_n + dt * p3 * u_np1\n        c_np1 = lu_solve(M_lu, rhs_c)\n        \n        # Store states and update for next step\n        u_hist[n + 1] = u_np1\n        c_hist[n + 1] = c_np1\n        c_n = c_np1\n        \n    return u_hist, c_hist, M_lu\n\ndef adjoint_model(p, N, Nt, dt, K_lu, M_lu, u_hist, c_hist, u_obs, c_obs, gamma):\n    \"\"\"Computes the adjoint variables using the backward recursion.\"\"\"\n    p1, p2, p3 = p\n    \n    phi_hist = {}\n    psi_hist = {}\n    \n    # Terminal conditions for adjoints at n = Nt\n    c_T = c_hist[Nt]\n    u_T = u_hist[Nt]\n    \n    # Adjoint phi_T\n    rhs_phi_T = -(c_T - c_obs)\n    # M is symmetric, so M_T = M. Use M_lu for solve.\n    phi_T = lu_solve(M_lu, rhs_phi_T, trans=1) \n    phi_hist[Nt] = phi_T\n    \n    # Adjoint psi_T\n    rhs_psi_T = dt * p3 * phi_T - (u_T - u_obs)\n    # K is symmetric, so K_T = K. Use K_lu for solve.\n    psi_T = lu_solve(K_lu, rhs_psi_T, trans=1)\n    psi_hist[Nt] = psi_T\n\n    # Backward loop from n = Nt-1 down to 1\n    for n in range(Nt - 1, 0, -1):\n        # Adjoint phi_n\n        rhs_phi = phi_hist[n + 1] + gamma * p1 * psi_hist[n + 1]\n        phi_n = lu_solve(M_lu, rhs_phi, trans=1)\n        phi_hist[n] = phi_n\n        \n        # Adjoint psi_n\n        rhs_psi = dt * p3 * phi_n\n        psi_n = lu_solve(K_lu, rhs_psi, trans=1)\n        psi_hist[n] = psi_n\n        \n    return psi_hist, phi_hist\n\ndef compute_gradient(p, Nt, dt, lambda_reg, psi_hist, phi_hist, u_hist, c_hist, gamma):\n    \"\"\"Assembles the gradient from state and adjoint variables.\"\"\"\n    p1, p2, p3 = p\n    \n    # Initialize with regularization term gradient\n    grad_p = lambda_reg * np.array(p)\n    \n    grad_p1_sum = 0.0\n    grad_p2_sum = 0.0\n    grad_p3_sum = 0.0\n    \n    for n in range(1, Nt + 1):\n        grad_p1_sum += np.dot(psi_hist[n], c_hist[n - 1])\n        grad_p2_sum += np.dot(phi_hist[n], c_hist[n])\n        grad_p3_sum += np.dot(phi_hist[n], u_hist[n])\n        \n    grad_p[0] += -gamma * grad_p1_sum\n    grad_p[1] += dt * grad_p2_sum\n    grad_p[2] += -dt * grad_p3_sum\n    \n    return grad_p\n\ndef solve():\n    # --- Problem Setup ---\n    N = 10\n    Nt = 5\n    dt = 0.1\n    dx = 1.0 / (N + 1)\n    \n    # Material and model parameters\n    E = 1.0\n    k_u = 1.0\n    gamma = 1.0\n    lambda_reg = 1e-3\n    \n    # Construct constant matrices and initial conditions\n    L = construct_laplacian(N, dx)\n    K = -E * L + k_u * np.identity(N)\n    K_lu = lu_factor(K)\n    \n    x = np.linspace(dx, 1.0 - dx, N)\n    c0 = np.sin(np.pi * x)\n\n    # --- Generate Observations ---\n    p_star = (0.5, 0.7, 0.3)\n    u_hist_star, c_hist_star, _ = forward_model(p_star, N, Nt, dt, dx, L, K_lu, c0, gamma)\n    u_obs = u_hist_star[Nt]\n    c_obs = c_hist_star[Nt]\n\n    # --- Test Cases ---\n    test_cases = [\n        (0.4, 0.6, 0.2),      # Case A\n        (1e-6, 0.6, 0.2),     # Case B\n        (0.4, 2.0, 0.2),      # Case C\n    ]\n    \n    results = []\n    for p_test in test_cases:\n        # 1. Forward pass to get state histories\n        u_hist, c_hist, M_lu_test = forward_model(p_test, N, Nt, dt, dx, L, K_lu, c0, gamma)\n        \n        # 2. Backward pass to get adjoint variables\n        psi_hist, phi_hist = adjoint_model(p_test, N, Nt, dt, K_lu, M_lu_test, u_hist, c_hist, u_obs, c_obs, gamma)\n        \n        # 3. Assemble gradient\n        grad = compute_gradient(p_test, Nt, dt, lambda_reg, psi_hist, phi_hist, u_hist, c_hist, gamma)\n        \n        results.extend(grad)\n    \n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}