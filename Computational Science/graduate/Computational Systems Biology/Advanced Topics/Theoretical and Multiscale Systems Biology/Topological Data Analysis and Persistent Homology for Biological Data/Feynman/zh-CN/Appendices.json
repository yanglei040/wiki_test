{
    "hands_on_practices": [
        {
            "introduction": "在运用复杂的软件分析大型数据集之前，理解单纯同调的基本计算机制至关重要。本练习  将引导您逐步构建边界矩阵，并为一个小的、具体的单纯复形计算贝蒂数 (Betti number)。掌握这一过程将为您解读自动化拓扑数据分析 (TDA) 流程的输出提供坚实的基础。",
            "id": "3355925",
            "problem": "在计算系统生物学中，当在固定尺度上对细胞间的相似性进行建模时，会出现一个小型拓扑数据分析 (TDA) 任务。考虑一个 Vietoris–Rips (VR) 复形 $K$，它是从嵌入在潜空间中的 $5$ 个单细胞图谱构建的，作用于含两个元素的有限域 ($\\mathbb{F}_{2}$)，并使用了一个生物学上合理的相似性阈值，从而产生了以下单纯形。0-单纯形 (顶点) 为 $v_{1}, v_{2}, v_{3}, v_{4}, v_{5}$。1-单纯形 (边) 为 $e_{12}, e_{23}, e_{34}, e_{45}, e_{15}, e_{25}, e_{35}$。2-单纯形 (三角形) 为 $\\tau_{125}, \\tau_{345}$。假设不存在更高维度的单纯形。所有计算都在 $\\mathbb{F}_{2}$ 上进行。\n\n仅从单纯同调的核心定义出发，构造边界算子 $\\partial_{1} : C_{1}(K;\\mathbb{F}_{2}) \\to C_{0}(K;\\mathbb{F}_{2})$ 和 $\\partial_{2} : C_{2}(K;\\mathbb{F}_{2}) \\to C_{1}(K;\\mathbb{F}_{2})$ 相对于 $C_{0}(K;\\mathbb{F}_{2})$ 的有序基 $\\{v_{1}, v_{2}, v_{3}, v_{4}, v_{5}\\}$，$C_{1}(K;\\mathbb{F}_{2})$ 的有序基 $\\{e_{12}, e_{23}, e_{34}, e_{45}, e_{15}, e_{25}, e_{35}\\}$，以及 $C_{2}(K;\\mathbb{F}_{2})$ 的有序基 $\\{\\tau_{125}, \\tau_{345}\\}$ 的边界矩阵。仅使用这些矩阵和在 $\\mathbb{F}_{2}$ 上的同调的标准定义，验证确定一阶同调群 $H_{1}(K;\\mathbb{F}_{2})$ 所需的秩。\n\n将 Betti 数 $\\beta_{1} = \\operatorname{rank} H_{1}(K;\\mathbb{F}_{2})$ 以单个整数形式报告。无需四舍五入。",
            "solution": "该问题要求计算给定单纯复形 $K$ 在有限域 $\\mathbb{F}_{2}$ 上的第一 Betti 数 $\\beta_{1}$。一阶同调群 $H_{1}(K; \\mathbb{F}_{2})$ 定义为 1-圈链的向量空间 $Z_{1}(K; \\mathbb{F}_{2})$ 与 1-边缘链的向量空间 $B_{1}(K; \\mathbb{F}_{2})$ 的商空间。\n$$H_{1}(K; \\mathbb{F}_{2}) = Z_{1}(K; \\mathbb{F}_{2}) / B_{1}(K; \\mathbb{F}_{2})$$\nBetti 数 $\\beta_{1}$ 是这个商空间的维度：\n$$\\beta_{1} = \\dim(H_{1}(K; \\mathbb{F}_{2})) = \\dim(Z_{1}(K; \\mathbb{F}_{2})) - \\dim(B_{1}(K; \\mathbb{F}_{2}))$$\n\n1-圈链空间 $Z_{1}$ 是边界算子 $\\partial_{1}: C_{1}(K; \\mathbb{F}_{2}) \\to C_{0}(K; \\mathbb{F}_{2})$ 的核，而 1-边缘链空间 $B_{1}$ 是边界算子 $\\partial_{2}: C_{2}(K; \\mathbb{F}_{2}) \\to C_{1}(K; \\mathbb{F}_{2})$ 的像。\n因此，我们有：\n$\\dim(Z_{1}(K; \\mathbb{F}_{2})) = \\dim(\\ker \\partial_{1})$\n$\\dim(B_{1}(K; \\mathbb{F}_{2})) = \\dim(\\operatorname{im} \\partial_{2})$\n\n对线性映射 $\\partial_{1}$ 使用秩-零化度定理，我们有 $\\dim(C_{1}) = \\dim(\\ker \\partial_{1}) + \\dim(\\operatorname{im} \\partial_{1})$。因此，$\\dim(\\ker \\partial_{1}) = \\dim(C_{1}) - \\operatorname{rank}(\\partial_{1})$。算子的秩是其像的维度。\n将这些代入 $\\beta_{1}$ 的表达式中：\n$$\\beta_{1} = (\\dim(C_{1}) - \\operatorname{rank}(\\partial_{1})) - \\operatorname{rank}(\\partial_{2})$$\n问题指定了链群的基，所以它们的维度是已知的。$\\dim(C_{2}) = 2$，$\\dim(C_{1}) = 7$，且 $\\dim(C_{0}) = 5$。我们的任务简化为构造 $\\partial_{2}$ 和 $\\partial_{1}$ 的矩阵表示并求出它们的秩。\n\n首先，我们构造 $\\partial_{2} : C_{2}(K;\\mathbb{F}_{2}) \\to C_{1}(K;\\mathbb{F}_{2})$ 的矩阵。$C_{2}$ 的基是 $\\{\\tau_{125}, \\tau_{345}\\}$，$C_{1}$ 的基是 $\\{e_{12}, e_{23}, e_{34}, e_{45}, e_{15}, e_{25}, e_{35}\\}$。一个 $p$-单纯形 $[v_{i_{0}}, \\dots, v_{i_{p}}]$ 的边界是 $\\sum_{j=0}^{p} (-1)^{j} [v_{i_{0}}, \\dots, \\widehat{v_{i_{j}}}, \\dots, v_{i_{p}}]$。在 $\\mathbb{F}_{2}$ 中计算，由于 $-1 \\equiv 1 \\pmod 2$，这简化为所有 $(p-1)$-维面的和。\n\n$C_{2}$ 的第一个基元素的边界是：\n$\\partial_{2}(\\tau_{125}) = \\partial_{2}([v_{1}, v_{2}, v_{5}]) = [v_{2}, v_{5}] + [v_{1}, v_{5}] + [v_{1}, v_{2}] = e_{25} + e_{15} + e_{12}$。\n$C_{2}$ 的第二个基元素的边界是：\n$\\partial_{2}(\\tau_{345}) = \\partial_{2}([v_{3}, v_{4}, v_{5}]) = [v_{4}, v_{5}] + [v_{3}, v_{5}] + [v_{3}, v_{4}] = e_{45} + e_{35} + e_{34}$。\n\n$\\partial_2$ 的矩阵表示（记为 $D_2$）的列对应于 $C_2$ 基向量的像。其维度为 $\\dim(C_1) \\times \\dim(C_2) = 7 \\times 2$。\n$$D_{2} =\n\\begin{pmatrix}\n1 & 0 \\\\\n0 & 0 \\\\\n0 & 1 \\\\\n0 & 1 \\\\\n1 & 0 \\\\\n1 & 0 \\\\\n0 & 1\n\\end{pmatrix}\n\\begin{matrix} \\\n\\leftarrow e_{12} \\\\ \\leftarrow e_{23} \\\\ \\leftarrow e_{34} \\\\ \\leftarrow e_{45} \\\\ \\leftarrow e_{15} \\\\ \\leftarrow e_{25} \\\\ \\leftarrow e_{35} \\end{matrix}\n$$\n这两个列向量在 $\\mathbb{F}_{2}$ 上是线性无关的，因为它们在不相交的行集合（第 1, 5, 6 行对第 3, 4, 7 行）中具有非零项。因此，该矩阵的秩为 2。\n$\\operatorname{rank}(\\partial_{2}) = \\operatorname{rank}(D_{2}) = 2$。\n\n接下来，我们构造 $\\partial_{1} : C_{1}(K;\\mathbb{F}_{2}) \\to C_{0}(K;\\mathbb{F}_{2})$ 的矩阵。$C_{1}$ 的基是 $\\{e_{12}, e_{23}, e_{34}, e_{45}, e_{15}, e_{25}, e_{35}\\}$，$C_{0}$ 的基是 $\\{v_{1}, v_{2}, v_{3}, v_{4}, v_{5}\\}$。\n一条边 $[v_{i}, v_{j}]$ 的边界是 $v_{j} + v_{i}$ (在 $\\mathbb{F}_{2}$ 中)。\n$\\partial_{1}(e_{12}) = v_{1} + v_{2}$\n$\\partial_{1}(e_{23}) = v_{2} + v_{3}$\n$\\partial_{1}(e_{34}) = v_{3} + v_{4}$\n$\\partial_{1}(e_{45}) = v_{4} + v_{5}$\n$\\partial_{1}(e_{15}) = v_{1} + v_{5}$\n$\\partial_{1}(e_{25}) = v_{2} + v_{5}$\n$\\partial_{1}(e_{35}) = v_{3} + v_{5}$\n\n$\\partial_1$ 的矩阵表示（记为 $D_1$）的维度为 $\\dim(C_0) \\times \\dim(C_1) = 5 \\times 7$。\n$$D_{1} =\n\\begin{pmatrix}\n1 & 0 & 0 & 0 & 1 & 0 & 0 \\\\\n1 & 1 & 0 & 0 & 0 & 1 & 0 \\\\\n0 & 1 & 1 & 0 & 0 & 0 & 1 \\\\\n0 & 0 & 1 & 1 & 0 & 0 & 0 \\\\\n0 & 0 & 0 & 1 & 1 & 1 & 1\n\\end{pmatrix}$$\n为求 $D_{1}$ 的秩，我们在 $\\mathbb{F}_{2}$ 上进行高斯消元，将其化为行阶梯形。令 $R_{i}$ 表示第 $i$ 行。\n$$\n\\begin{pmatrix}\n1 & 0 & 0 & 0 & 1 & 0 & 0 \\\\\n1 & 1 & 0 & 0 & 0 & 1 & 0 \\\\\n0 & 1 & 1 & 0 & 0 & 0 & 1 \\\\\n0 & 0 & 1 & 1 & 0 & 0 & 0 \\\\\n0 & 0 & 0 & 1 & 1 & 1 & 1\n\\end{pmatrix}\n\\xrightarrow{R_{2} \\leftarrow R_{2} + R_{1}}\n\\begin{pmatrix}\n1 & 0 & 0 & 0 & 1 & 0 & 0 \\\\\n0 & 1 & 0 & 0 & 1 & 1 & 0 \\\\\n0 & 1 & 1 & 0 & 0 & 0 & 1 \\\\\n0 & 0 & 1 & 1 & 0 & 0 & 0 \\\\\n0 & 0 & 0 & 1 & 1 & 1 & 1\n\\end{pmatrix}\n$$\n$$\n\\xrightarrow{R_{3} \\leftarrow R_{3} + R_{2}}\n\\begin{pmatrix}\n1 & 0 & 0 & 0 & 1 & 0 & 0 \\\\\n0 & 1 & 0 & 0 & 1 & 1 & 0 \\\\\n0 & 0 & 1 & 0 & 1 & 1 & 1 \\\\\n0 & 0 & 1 & 1 & 0 & 0 & 0 \\\\\n0 & 0 & 0 & 1 & 1 & 1 & 1\n\\end{pmatrix}\n\\xrightarrow{R_{4} \\leftarrow R_{4} + R_{3}}\n\\begin{pmatrix}\n1 & 0 & 0 & 0 & 1 & 0 & 0 \\\\\n0 & 1 & 0 & 0 & 1 & 1 & 0 \\\\\n0 & 0 & 1 & 0 & 1 & 1 & 1 \\\\\n0 & 0 & 0 & 1 & 1 & 1 & 1 \\\\\n0 & 0 & 0 & 1 & 1 & 1 & 1\n\\end{pmatrix}\n$$\n$$\n\\xrightarrow{R_{5} \\leftarrow R_{5} + R_{4}}\n\\begin{pmatrix}\n1 & 0 & 0 & 0 & 1 & 0 & 0 \\\\\n0 & 1 & 0 & 0 & 1 & 1 & 0 \\\\\n0 & 0 & 1 & 0 & 1 & 1 & 1 \\\\\n0 & 0 & 0 & 1 & 1 & 1 & 1 \\\\\n0 & 0 & 0 & 0 & 0 & 0 & 0\n\\end{pmatrix}\n$$\n化为行阶梯形后的矩阵有 $4$ 个非零行，所以其秩为 $4$。\n$\\operatorname{rank}(\\partial_{1}) = \\operatorname{rank}(D_{1}) = 4$。\n\n现在我们有了计算 $\\beta_{1}$所需的所有要素。\n$\\dim(C_{1}) = 7$\n$\\operatorname{rank}(\\partial_{1}) = 4$\n$\\operatorname{rank}(\\partial_{2}) = 2$\n\n将这些值代入 Betti 数的公式中：\n$$\\beta_{1} = \\dim(C_{1}) - \\operatorname{rank}(\\partial_{1}) - \\operatorname{rank}(\\partial_{2}) = 7 - 4 - 2 = 1$$\n\n第一 Betti 数是 $1$。这表示在单纯复形 $K$ 中存在一个独立的 1 维“洞”。",
            "answer": "$$\n\\boxed{1}\n$$"
        },
        {
            "introduction": "持久同调将复杂数据总结为持久性图，但在生物学中，TDA 的真正威力通常在于比较不同实验条件下的这些拓扑摘要。为此，我们需要一种方法来衡量图之间的“距离”。本练习  提供了计算两个关键度量——瓶颈距离 ($d_B$) 和瓦瑟斯坦距离 ($W_1$)——的实践经验，并促使您思考哪种度量对生物学上有意义的变化与噪声更敏感。",
            "id": "3355848",
            "problem": "空间转录组学中的两个实验条件，通过对细胞间距离进行 Vietoris-Rips 过滤，并使用拓扑数据分析 (TDA) 进行分析，产生了两个一维同调特征集。由此产生的持久性图记录了环状结构的生-灭对，这些结构反映了稳定的组织域（长寿命特征）和瞬时的测量波动（短寿命特征）。考虑两个持久性图\n$$D_A = \\{(0.05,\\,0.70),\\,(0.30,\\,0.35)\\} \\quad \\text{和} \\quad D_B = \\{(0.06,\\,0.71),\\,(0.48,\\,0.50)\\}.$$\n使用 $L^{\\infty}$ 基础度量进行匹配：匹配两个非对角点 $(b,\\,d)$ 和 $(b',\\,d')$ 的成本是 $\\max\\!\\big(|b-b'|,\\,|d-d'|\\big)$，将一个非对角点 $(b,\\,d)$ 匹配到对角线的成本是 $(d-b)/2$。瓶颈距离 $d_B$ 定义为在两个图（增广了无限多个对角线点）之间的所有双射中，最大匹配成本的下确界；$1$-Wasserstein 距离 $W_1$ 定义为在这些双射中，匹配成本总和的下确界。\n\n通过求解匹配问题，精确计算 $d_B(D_A,D_B)$ 和 $W_1(D_A,D_B)$。然后，根据生物学解释（长寿命特征对应于稳定的组织域，而短寿命特征类似噪声），论证在此示例中哪个度量更能反映有意义的生物学变异。\n\n将最终数值结果表示为一个行矩阵 $\\big[d_B,\\,W_1\\big]$，不进行四舍五入。",
            "solution": "该问题要求我们计算两个持久性图 $D_A$ 和 $D_B$ 之间的瓶颈距离 ($d_B$) 和 1-Wasserstein 距离 ($W_1$)，并基于生物学背景来论证哪种度量更优。\n\n**1. 计算配对成本**\n\n首先，我们识别持久性图中的点及其持久性（生命周期长度 $d-b$）：\n- $D_A$: $p_1 = (0.05, 0.70)$ (持久性 0.65, 信号), $p_2 = (0.30, 0.35)$ (持久性 0.05, 噪声)。\n- $D_B$: $q_1 = (0.06, 0.71)$ (持久性 0.65, 信号), $q_2 = (0.48, 0.50)$ (持久性 0.02, 噪声)。\n\n接下来，计算所有可能的匹配成本。\n**点与对角线 ($\\Delta$) 的匹配成本**（即特征被视为噪声的成本）：$C((b,d), \\Delta) = (d-b)/2$\n- $C(p_1, \\Delta) = 0.65 / 2 = 0.325$\n- $C(p_2, \\Delta) = 0.05 / 2 = 0.025$\n- $C(q_1, \\Delta) = 0.65 / 2 = 0.325$\n- $C(q_2, \\Delta) = 0.02 / 2 = 0.01$\n\n**点与点之间的匹配成本**（$L^\\infty$ 距离）：$C((b,d), (b',d')) = \\max(|b-b'|, |d-d'|)$\n- $C(p_1, q_1) = \\max(|0.05 - 0.06|, |0.70 - 0.71|) = \\max(0.01, 0.01) = 0.01$\n- $C(p_1, q_2) = \\max(|0.05 - 0.48|, |0.70 - 0.50|) = \\max(0.43, 0.20) = 0.43$\n- $C(p_2, q_1) = \\max(|0.30 - 0.06|, |0.35 - 0.71|) = \\max(0.24, 0.36) = 0.36$\n- $C(p_2, q_2) = \\max(|0.30 - 0.48|, |0.35 - 0.50|) = \\max(0.18, 0.15) = 0.18$\n\n**2. 寻找最优匹配**\n\n我们需要在 $D_A$ 和 $D_B$ 的点之间找到一个最优双射（允许匹配到对角线），以最小化 $d_B$（最大成本）和 $W_1$（成本总和）。\n我们评估可能的匹配方案：\n\n- **方案 A：** 匹配信号-信号，噪声-噪声。即 $(p_1, q_1)$ 和 $(p_2, q_2)$。\n  - 成本：$\\{C(p_1, q_1), C(p_2, q_2)\\} = \\{0.01, 0.18\\}$\n  - $d_B = \\max(0.01, 0.18) = 0.18$\n  - $W_1 = 0.01 + 0.18 = 0.19$\n\n- **方案 B：** 交叉匹配。即 $(p_1, q_2)$ 和 $(p_2, q_1)$。\n  - 成本：$\\{C(p_1, q_2), C(p_2, q_1)\\} = \\{0.43, 0.36\\}$\n  - $d_B = \\max(0.43, 0.36) = 0.43$\n  - $W_1 = 0.43 + 0.36 = 0.79$\n\n- **方案 C：** 匹配信号-信号，并将两个噪声点匹配到对角线。即匹配 $(p_1, q_1)$，并将 $p_2$ 和 $q_2$ 视为噪声。\n  - 成本：$\\{C(p_1, q_1), C(p_2, \\Delta), C(q_2, \\Delta)\\} = \\{0.01, 0.025, 0.01\\}$\n  - $d_B = \\max(0.01, 0.025, 0.01) = 0.025$\n  - $W_1 = 0.01 + 0.025 + 0.01 = 0.045$\n\n通过比较所有可能匹配方案的成本，我们发现方案 C 产生了最小的 $d_B$ 和 $W_1$。因此，最优匹配是匹配两个长寿命的“信号”特征，并将两个短寿命的“噪声”特征匹配到对角线。\n\n- **最终距离：**\n  - $d_B(D_A, D_B) = 0.025$\n  - $W_1(D_A, D_B) = 0.045$\n\n**3. 论证**\n\n根据生物学解释，有意义的变异体现在稳定组织域（长寿命特征）的变化上，而瞬时波动（短寿命特征）应被视为噪声。最优匹配方案 C 正是这样做的：它识别了稳定特征 $p_1$ 和 $q_1$ 之间的对应关系，并将噪声特征 $p_2$ 和 $q_2$ 滤除。\n\n- **瓶颈距离 ($d_B$)**: 在本例中，其值为 $0.025$，完全由将噪声点 $p_2$ 匹配到对角线的成本决定 ($C(p_2, \\Delta) = 0.025$)。这意味着，即使代表生物学信号的特征 ($p_1$ 和 $q_1$) 之间的差异变得更大（例如，只要 $C(p_1, q_1)  0.025$），瓶颈距离也不会改变。它被最不稳定的特征所支配，因此对稳定信号的细微变化不敏感。\n\n- **1-Wasserstein 距离 ($W_1$)**: 其值为 $0.045$，是所有匹配成本的总和 ($0.01 + 0.025 + 0.01$)。这个值同时包含了稳定特征之间的变异成本（$0.01$）和滤除噪声的成本。因为它累积了所有特征的贡献，所以它能更全面地反映两个拓扑摘要之间的总体差异。如果稳定特征之间的差异增加， $W_1$ 的值也会相应增加，从而能更好地捕捉到有意义的生物学变异。\n\n**结论**：在此示例中，$1$-Wasserstein 距离 $W_1$ 是一个更具信息量的度量，因为它整合了所有特征（包括信号和噪声）的贡献，提供了一个更全面的差异评估。相比之下，瓶颈距离 $d_B$ 作为一种“最坏情况”度量，可能被单个噪声特征所主导，从而掩盖了对生物学上更重要的稳定特征变化的敏感性。",
            "answer": "$$ \\boxed{ \\begin{bmatrix} 0.025  0.045 \\end{bmatrix} } $$"
        },
        {
            "introduction": "为了从包含多个重复样本的生物学实验中得出统计上稳健的结论，我们需要超越对持久性图的简单视觉比较。持久性景观 (persistence landscape) 提供了一种将拓扑摘要转化为函数数据分析框架的强大方法。这项高级计算练习  要求您实现一个完整的分析流程，从将条形码 (barcode) 转换为景观，到执行函数 $t$-检验以进行组间比较，这项技能处于将 TDA 应用于真实世界生物学问题的前沿。",
            "id": "3355833",
            "problem": "给定两组条形码，它们代表在拓扑数据分析（TDA）工作流中对生物数据集计算出的持久同调区间。每个条形码是一个生灭区间的多重集，这些区间是对源自生物测量的点云或网络应用过滤后的输出。请为每个重复样本定义持久性景观函数，估计各组的平均景观函数，并执行带有方差正则化的函数型双样本 $t$-检验。为每个测试案例返回三个可量化的浮点数指标。\n\n基本原理和定义：\n- 拓扑数据分析（TDA）使用过滤来生成一系列单纯复形，以捕捉跨尺度参数的结构；持久同调计算整个过滤过程中的同调群，产生作为区间 $(b_i, d_i)$ 多重集的条形码，其中 $b_i$ 和 $d_i$ 表示一个拓扑特征的生成和死亡尺度值。\n- 对于一个条形码 $\\mathcal{B} = \\{(b_i, d_i)\\}_{i=1}^m$ 且 $b_i  d_i$，为每个区间 $i$ 定义分段线性“帐篷”函数为\n$$\nf_i(t) = \\max\\left(0, \\min\\left(t - b_i, d_i - t\\right)\\right).\n$$\n- 第 $k$ 个持久性景观函数 $\\lambda_k(t)$ 按点定义为集合 $\\{f_i(t)\\}_{i=1}^m$ 中的第 $k$ 大值。如果在 $t$ 点处非零的帐篷函数少于 $k$ 个，则 $\\lambda_k(t) = 0$。\n- 给定一个组中的 $n$ 个重复样本，其景观函数为 $\\lambda_{k}^{(j)}(t)$（其中 $j \\in \\{1,\\dots,n\\}$），则景观层级 $k$ 的组平均值为\n$$\n\\bar{\\lambda}_k(t) = \\frac{1}{n} \\sum_{j=1}^n \\lambda_{k}^{(j)}(t).\n$$\n- 对于在每个网格点 $t$ 比较大小为 $n_1$ 和 $n_2$ 的两个组的函数型 $t$-检验，定义第一个景观层级的点态差异为\n$$\n\\delta_1(t) = \\bar{\\lambda}^{(2)}_1(t) - \\bar{\\lambda}^{(1)}_1(t),\n$$\n以及正则化合并标准误\n$$\ns_{\\text{pool}}(t) = \\sqrt{ \\frac{s_1^2(t)}{n_1} + \\frac{s_2^2(t)}{n_2} + \\epsilon^2 },\n$$\n其中 $s_g^2(t)$ 是组 $g$ 在时间 $t$ 的重复样本间的无偏样本方差，$\\epsilon$ 是一个方差正则化下限，选择为\n$$\n\\epsilon = \\gamma \\cdot \\mathrm{median}\\left( \\sqrt{ \\frac{s_1^2(t)}{n_1} + \\frac{s_2^2(t)}{n_2} } \\right),\n$$\n其中 $\\gamma = 0.1$，如果中位数为 $0$，则使用备用值 $\\epsilon = 10^{-8}$。点态 $t$-统计量为\n$$\nt(t) = \\frac{\\delta_1(t)}{s_{\\text{pool}}(t)}.\n$$\n- 通过在网格上的 $L^2$ 范数将点态统计量聚合为全局指标：\n$$\nT_{\\text{global}} = \\left( \\int t(t)^2 \\, dt \\right)^{1/2}.\n$$\n- 同时，计算 $k = 1$ 和 $k = 2$ 时组平均差异的 $L^2$ 范数：\n$$\n\\|\\delta_k\\|_2 = \\left( \\int \\left( \\bar{\\lambda}^{(2)}_k(t) - \\bar{\\lambda}^{(1)}_k(t) \\right)^2 dt \\right)^{1/2}.\n$$\n\n数值实现要求：\n- 在一个均匀网格 $t$ 上逼近所有函数，该网格横跨两组中所有区间的支撑集的并集。在 $T_{\\min}$ 和 $T_{\\max}$ 之间选择 $M = 401$ 个等距点，其中 $T_{\\min}$ 是所有区间的最小生成值，$T_{\\max}$ 是所有区间的最大死亡值；如果测试案例中不存在区间，则设置 $T_{\\min} = 0$ 和 $T_{\\max} = 1$。将该区间范围的 $5\\%$ 作为边距扩展到两端（如果范围为 $0$，则使用 $0.05$ 的边距）。使用 $K = 2$ 个景观层级。如上定义，使用 $\\gamma = 0.1$ 进行正则化。\n- 使用梯形数值积分来逼近所有积分。\n- 处理边界情况：空条形码、每组单个重复样本（此时设 $s_g^2(t) = 0$），以及少于 $K$ 个区间（用零填充景观函数）。\n- 所有输出均以无单位的浮点数表示。不涉及物理单位。\n\n测试套件：\n对于每个测试案例，给定两组：对照组和处理组。每组包含若干重复样本，每个重复样本是一个区间 $(b, d)$ 的列表。\n\n- 测试案例 1（一般情况，处理组的特征存续时间更长）：\n  - 对照组重复样本：\n    - 重复样本 1：$(0.1, 0.9)$, $(0.2, 1.0)$, $(0.5, 1.4)$\n    - 重复样本 2：$(0.05, 0.8)$, $(0.3, 1.1)$\n    - 重复样本 3：$(0.2, 0.95)$, $(0.6, 1.3)$, $(0.7, 1.5)$\n  - 处理组重复样本：\n    - 重复样本 1：$(0.1, 1.2)$, $(0.25, 1.3)$, $(0.5, 1.7)$\n    - 重复样本 2：$(0.05, 1.0)$, $(0.3, 1.4)$\n    - 重复样本 3：$(0.2, 1.05)$, $(0.6, 1.6)$, $(0.7, 1.9)$\n\n- 测试案例 2（边界情况，包含空条形码和相同的条形码）：\n  - 对照组重复样本：\n    - 重复样本 1：无区间\n    - 重复样本 2：$(0.4, 0.45)$\n  - 处理组重复样本：\n    - 重复样本 1：无区间\n    - 重复样本 2：$(0.4, 0.45)$\n\n- 测试案例 3（边缘情况，对照组有许多短区间，处理组有一个长区间）：\n  - 对照组重复样本：\n    - 重复样本 1：$(0.1, 0.15)$, $(0.2, 0.25)$, $(0.3, 0.35)$\n    - 重复样本 2：$(0.12, 0.2)$, $(0.22, 0.28)$\n  - 处理组重复样本：\n    - 重复样本 1：$(0.1, 1.2)$, $(0.2, 0.25)$\n    - 重复样本 2：$(0.05, 1.0)$\n\n每个测试案例的所需输出：\n- 计算三个浮点数：$[\\|\\delta_1\\|_2, \\|\\delta_2\\|_2, T_{\\text{global}}]$。\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表，每个测试案例对应一个内部列表。例如，打印 $[[\\|\\delta_1\\|_2^{(1)},\\|\\delta_2\\|_2^{(1)},T_{\\text{global}}^{(1)}],[\\|\\delta_1\\|_2^{(2)},\\|\\delta_2\\|_2^{(2)},T_{\\text{global}}^{(2)}],[\\|\\delta_1\\|_2^{(3)},\\|\\delta_2\\|_2^{(3)},T_{\\text{global}}^{(3)}]]$，打印的列表中不含空格。",
            "solution": "此问题要求执行一个多步骤的计算流程，以对两组持久性条形码进行统计比较。该流程将拓扑摘要（条形码）转换为函数（持久性景观），然后应用函数数据分析中的方法（函数型 t-检验）来量化组间的差异。解决方案遵循问题中定义的精确步骤，这些步骤在计算拓扑领域是标准的。\n\n**1. 网格离散化**\n首先，我们需要为所有函数计算定义一个共同的域。\n- 汇集两个组所有重复样本中的所有区间的生成时间 ($b_i$) 和死亡时间 ($d_i$)。\n- 确定全局的最小生成时间 $T_{\\min}$ 和最大死亡时间 $T_{\\max}$。\n- 根据这些值定义一个扩展的均匀网格。计算范围 $R = T_{\\max} - T_{\\min}$，并在两端各增加 $0.05R$ 的边距。最终的网格 $t$ 在 $[T_{\\min} - 0.05R, T_{\\max} + 0.05R]$ 区间内包含 $M=401$ 个等距点。这个网格的步长 $dt$ 将用于数值积分。\n\n**2. 持久性景观生成**\n对于每个组中的每个重复样本（即每个条形码），我们计算其前 $K=2$ 个持久性景观函数。\n- 对条形码中的每个区间 $(b_i, d_i)$，在网格 $t$ 上计算其对应的“帐篷”函数 $f_i(t) = \\max(0, \\min(t - b_i, d_i - t))$。\n- 第 $k$ 个景观函数 $\\lambda_k(t)$ 的值在每个网格点 $t$ 处被计算为所有帐篷函数值 $\\{f_i(t)\\}$ 集合中的第 $k$ 大值。这通过在每个网格点对帐篷函数值进行降序排序并选取第 $k$ 个元素来实现。如果一个条形码的区间数少于 $k$，则第 $k$ 个及更高层级的景观函数为零。\n\n**3. 计算组级别统计量**\n一旦为每个重复样本计算出景观函数，我们就可以计算组级别的统计量。\n- **平均景观**：对于每个组和每个景观层级 $k$，通过对该组内所有重复样本的 $\\lambda_k^{(j)}(t)$ 函数进行逐点平均，计算出组平均景观 $\\bar{\\lambda}_k(t)$。\n- **样本方差**：对于每个组和每个景观层级，计算重复样本间的逐点无偏样本方差 $s_g^2(t)$。如果一个组只有一个重复样本，其方差为零。\n\n**4. 计算最终指标**\n最后，我们根据问题中的公式计算三个输出指标。\n- **$L^2$ 范数差异 $\\|\\delta_k\\|_2$**：对于 $k=1$ 和 $k=2$，计算两个组的平均景观之间的差异函数 $\\delta_k(t) = \\bar{\\lambda}_k^{(2)}(t) - \\bar{\\lambda}_k^{(1)}(t)$。然后，使用梯形法则对 $\\delta_k(t)^2$ 进行数值积分，并取其平方根，得到 $\\|\\delta_k\\|_2$。\n- **全局 t-统计量 $T_{\\text{global}}$**：\n  - 计算 $\\delta_1(t)$。\n  - 计算合并标准误的分母项 $\\frac{s_1^2(t)}{n_1} + \\frac{s_2^2(t)}{n_2}$。\n  - 计算正则化参数 $\\epsilon$，即 $\\gamma=0.1$ 乘以该分母项平方根的中位数。\n  - 构造正则化的合并标准误 $s_{\\text{pool}}(t) = \\sqrt{\\frac{s_1^2(t)}{n_1} + \\frac{s_2^2(t)}{n_2} + \\epsilon^2}$。\n  - 计算逐点 t-统计量 $t(t) = \\delta_1(t) / s_{\\text{pool}}(t)$。\n  - 最后，通过计算 $t(t)$ 的 $L^2$ 范数（使用梯形积分）得到全局统计量 $T_{\\text{global}}$。\n\n这个过程将原始的、非结构化的条形码集合转化为了三个定量的、可解释的统计指标，用于评估对照组和处理组之间的拓扑差异。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to process all test cases and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1\n        (\n            [ # Control\n                [(0.1, 0.9), (0.2, 1.0), (0.5, 1.4)],\n                [(0.05, 0.8), (0.3, 1.1)],\n                [(0.2, 0.95), (0.6, 1.3), (0.7, 1.5)]\n            ],\n            [ # Treated\n                [(0.1, 1.2), (0.25, 1.3), (0.5, 1.7)],\n                [(0.05, 1.0), (0.3, 1.4)],\n                [(0.2, 1.05), (0.6, 1.6), (0.7, 1.9)]\n            ]\n        ),\n        # Test case 2\n        (\n            [ # Control\n                [],\n                [(0.4, 0.45)]\n            ],\n            [ # Treated\n                [],\n                [(0.4, 0.45)]\n            ]\n        ),\n        # Test case 3\n        (\n            [ # Control\n                [(0.1, 0.15), (0.2, 0.25), (0.3, 0.35)],\n                [(0.12, 0.2), (0.22, 0.28)]\n            ],\n            [ # Treated\n                [(0.1, 1.2), (0.2, 0.25)],\n                [(0.05, 1.0)]\n            ]\n        )\n    ]\n\n    all_results = []\n    for control_reps, treated_reps in test_cases:\n        result = process_case(control_reps, treated_reps)\n        all_results.append(result)\n\n    # Format the final output string\n    output_str = \"[\"\n    for i, res in enumerate(all_results):\n        output_str += f\"[{','.join(f'{x:.10f}' for x in res)}]\"\n        if i  len(all_results) - 1:\n            output_str += \",\"\n    output_str += \"]\"\n    \n    print(output_str)\n\ndef process_case(group1_reps, group2_reps):\n    \"\"\"\n    Processes a single test case to compute the three required metrics.\n    \"\"\"\n    M = 401\n    K = 2\n    gamma = 0.1\n\n    # 1. Grid Discretization\n    all_points = []\n    for rep in group1_reps + group2_reps:\n        for b, d in rep:\n            all_points.extend([b, d])\n\n    if not all_points:\n        t_min, t_max = 0.0, 1.0\n    else:\n        t_min, t_max = min(all_points), max(all_points)\n\n    range_val = t_max - t_min\n    margin = 0.05 * range_val if range_val > 0 else 0.05\n    grid_min, grid_max = t_min - margin, t_max + margin\n    t = np.linspace(grid_min, grid_max, M)\n    dt = t[1] - t[0]\n\n    # 2. Compute landscapes for each group\n    landscapes1 = compute_group_landscapes(group1_reps, t, K)\n    landscapes2 = compute_group_landscapes(group2_reps, t, K)\n    \n    n1, n2 = landscapes1.shape[0], landscapes2.shape[0]\n\n    # 3. Compute group-level statistics\n    mean_landscapes1 = np.mean(landscapes1, axis=0)\n    mean_landscapes2 = np.mean(landscapes2, axis=0)\n\n    if n1 > 1:\n        var1 = np.var(landscapes1, axis=0, ddof=1)\n    else:\n        var1 = np.zeros_like(mean_landscapes1)\n\n    if n2 > 1:\n        var2 = np.var(landscapes2, axis=0, ddof=1)\n    else:\n        var2 = np.zeros_like(mean_landscapes2)\n\n    # 4. Compute output metrics\n    \n    # 4a. ||delta_k||_2\n    delta1 = mean_landscapes2[0, :] - mean_landscapes1[0, :]\n    delta2 = mean_landscapes2[1, :] - mean_landscapes1[1, :]\n    \n    l2_norm_delta1 = np.sqrt(np.trapz(delta1**2, dx=dt))\n    l2_norm_delta2 = np.sqrt(np.trapz(delta2**2, dx=dt))\n\n    # 4b. T_global\n    pooled_var_term = var1[0, :] / n1 + var2[0, :] / n2\n    \n    unreg_std_err = np.sqrt(pooled_var_term)\n    \n    median_val = np.median(unreg_std_err)\n    epsilon = gamma * median_val if median_val > 0 else 1e-8\n    \n    s_pool = np.sqrt(pooled_var_term + epsilon**2)\n    \n    # Use np.divide to handle cases where s_pool might still be zero, though epsilon should prevent this.\n    t_stat = np.divide(delta1, s_pool, out=np.zeros_like(delta1), where=s_pool!=0)\n    \n    t_global = np.sqrt(np.trapz(t_stat**2, dx=dt))\n    \n    return [l2_norm_delta1, l2_norm_delta2, t_global]\n\ndef compute_group_landscapes(replicates, t, K):\n    \"\"\"\n    Computes landscapes for all replicates in a group.\n    \"\"\"\n    num_reps = len(replicates)\n    M = len(t)\n    group_landscapes = np.zeros((num_reps, K, M))\n\n    for i, rep_intervals in enumerate(replicates):\n        group_landscapes[i, :, :] = compute_replicate_landscapes(rep_intervals, t, K)\n        \n    return group_landscapes\n\ndef compute_replicate_landscapes(intervals, t, K):\n    \"\"\"\n    Computes K landscape levels for a single replicate.\n    \"\"\"\n    num_intervals = len(intervals)\n    M = len(t)\n    \n    if num_intervals == 0:\n        return np.zeros((K, M))\n\n    tent_functions = np.zeros((num_intervals, M))\n    for i, (b, d) in enumerate(intervals):\n        if b  d:\n            tent_functions[i, :] = np.maximum(0, np.minimum(t - b, d - t))\n\n    # Sort tent function values at each grid point in descending order\n    # This gives us the landscape values\n    sorted_tents = -np.sort(-tent_functions, axis=0)\n    \n    landscapes = np.zeros((K, M))\n    \n    # The number of non-zero landscapes is at most num_intervals\n    num_valid_landscapes = min(K, num_intervals)\n    landscapes[:num_valid_landscapes, :] = sorted_tents[:num_valid_landscapes, :]\n    \n    return landscapes\n\nsolve()\n```"
        }
    ]
}