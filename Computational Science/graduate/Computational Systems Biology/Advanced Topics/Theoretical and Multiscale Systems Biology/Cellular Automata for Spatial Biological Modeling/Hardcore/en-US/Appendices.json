{
    "hands_on_practices": [
        {
            "introduction": "A core strength of cellular automata is their ability to generate complex macroscopic dynamics from simple, local rules. This exercise provides a foundational experience in making the connection between these scales explicit. You will analyze a hypothetical cellular automaton model for tissue homeostasis and derive the expected change in the total cell population based on its stochastic rules for cell division and apoptosis, which are designed to reflect contact-dependent behavior. This practice hones essential skills in probability and expectation, demonstrating how a model can be constructed to ensure a global property—in this case, conservation of cell number in expectation—is an emergent feature of its local dynamics.",
            "id": "3293881",
            "problem": "Consider a two-dimensional square lattice cellular automaton (CA) with periodic boundary conditions representing an epithelial tissue monolayer. Each lattice site $j$ has a binary state $x_{j} \\in \\{0,1\\}$, where $x_{j} = 1$ denotes a living cell and $x_{j} = 0$ denotes an empty site. Let $N = \\sum_{j} x_{j}$ be the total number of cells. Each site has a fixed neighborhood of size $k$ (for example, the Moore neighborhood of radius one has $k = 8$), and for any occupied site $i$ define $e_{i} \\in \\{0,1,\\dots,k\\}$ as the number of empty neighbors of site $i$.\n\nAt each update, the CA evolves asynchronously by selecting one occupied site $i$ uniformly at random from the set of all occupied sites. Given the selected site $i$, define a local event probability\n$$\nr_{i} = r_{0} \\frac{e_{i}}{k},\n$$\nwhere $r_{0} \\in (0, \\tfrac{1}{2}]$ is a fixed parameter. The update at site $i$ then proceeds by drawing a single outcome from the following mutually exclusive possibilities:\n- With probability $r_{i}$, the cell at $i$ divides into one of its $e_{i}$ empty neighboring sites chosen uniformly at random, thereby increasing $N$ by $1$.\n- With probability $r_{i}$, the cell at $i$ undergoes apoptosis (programmed cell death), thereby decreasing $N$ by $1$.\n- With probability $1 - 2 r_{i}$, no change occurs at $i$ and $N$ is unchanged.\n\nThese rules reflect two well-tested biological facts: (i) cell division is limited by the availability of free space, and (ii) loss of contact-mediated survival signals (anoikis) increases the likelihood of apoptosis in sparsely occupied neighborhoods.\n\nStarting from the definitions of expected value and conditioning on the random choice of the focal site and the stochastic outcome of the update at that site, derive the expected change in the total number of cells per update, denoted $\\mathbb{E}[\\Delta N]$, as a closed-form analytic expression in terms of the current configuration $\\{x_{j}\\}$, the neighborhood emptiness counts $\\{e_{i}\\}$, and the parameter $r_{0}$. Express your final answer as a single analytic expression with no units. No rounding is required.",
            "solution": "The problem statement is evaluated to be valid. It is scientifically grounded as a standard cellular automaton model in computational biology, is well-posed with all necessary parameters and rules defined, and is objective and free of contradictions. The constraint $r_0 \\in (0, \\tfrac{1}{2}]$ ensures that all probabilities are well-defined and non-negative, as $r_i = r_0 \\frac{e_i}{k} \\le r_0 \\le \\frac{1}{2}$, which implies $1 - 2r_i \\ge 0$. We proceed with the derivation.\n\nThe objective is to derive the expected change in the total number of cells per update, denoted $\\mathbb{E}[\\Delta N]$. The total number of cells is $N = \\sum_j x_j$, where $x_j=1$ for an occupied site and $x_j=0$ for an empty site. We assume the process starts with a non-zero number of cells, i.e., $N > 0$.\n\nThe update process consists of two stages of random selection:\n1.  An occupied site $i$ is selected uniformly at random from the set of all $N$ occupied sites.\n2.  A stochastic event (division, apoptosis, or no change) occurs at site $i$ according to the given probabilities.\n\nLet $\\mathcal{O} = \\{ j \\mid x_j = 1 \\}$ be the set of indices of all occupied sites. The size of this set is $|\\mathcal{O}| = N$. Let $I$ be the random variable representing the index of the site selected for update. According to the problem statement, for any site $i \\in \\mathcal{O}$, the probability of it being selected is:\n$$\nP(I=i) = \\frac{1}{N}\n$$\nTo find the expected change in the cell number, $\\mathbb{E}[\\Delta N]$, we can use the law of total expectation, conditioning on the selection of site $I$. The formula is:\n$$\n\\mathbb{E}[\\Delta N] = \\sum_{i \\in \\mathcal{O}} \\mathbb{E}[\\Delta N \\mid I=i] P(I=i)\n$$\nwhere $\\mathbb{E}[\\Delta N \\mid I=i]$ is the expected change in $N$ given that site $i$ has been selected for the update.\n\nWe now compute this conditional expectation for an arbitrary occupied site $i \\in \\mathcal{O}$. The change in the total cell number, $\\Delta N$, can take on three distinct values based on the event at site $i$:\n*   **Division**: The number of cells increases by one, so $\\Delta N = +1$. This event occurs with probability $r_i$.\n*   **Apoptosis**: The number of cells decreases by one, so $\\Delta N = -1$. This event occurs with probability $r_i$.\n*   **No change**: The number of cells remains the same, so $\\Delta N = 0$. This event occurs with probability $1 - 2r_i$.\n\nThe expected value of $\\Delta N$, conditioned on the selection of site $i$, is the sum of each possible value of $\\Delta N$ multiplied by its corresponding probability:\n$$\n\\mathbb{E}[\\Delta N \\mid I=i] = (+1) \\cdot P(\\text{division at } i) + (-1) \\cdot P(\\text{apoptosis at } i) + (0) \\cdot P(\\text{no change at } i)\n$$\nSubstituting the probabilities given in the problem:\n$$\n\\mathbb{E}[\\Delta N \\mid I=i] = (+1) \\cdot r_i + (-1) \\cdot r_i + (0) \\cdot (1 - 2r_i)\n$$\nThis simplifies to:\n$$\n\\mathbb{E}[\\Delta N \\mid I=i] = r_i - r_i + 0 = 0\n$$\nThis result demonstrates that for any occupied site $i$ that is chosen, the expected change in the total cell population is exactly zero. This is a direct consequence of the model's design, where the probability of a cell-number-increasing event (division) is specified to be identical to the probability of a cell-number-decreasing event (apoptosis). The local neighborhood-dependent factor $r_i = r_0 \\frac{e_i}{k}$ modulates both rates equally, so their respective contributions to the expected change cancel each other out perfectly at the level of a single event.\n\nNow, we substitute this conditional expectation back into the law of total expectation:\n$$\n\\mathbb{E}[\\Delta N] = \\sum_{i \\in \\mathcal{O}} (0) \\cdot P(I=i)\n$$\nSince $P(I=i) = \\frac{1}{N}$, this becomes:\n$$\n\\mathbb{E}[\\Delta N] = \\sum_{i \\in \\mathcal{O}} (0) \\cdot \\frac{1}{N}\n$$\nThe sum consists of $N$ terms, each of which is zero. Therefore, the total sum is zero:\n$$\n\\mathbb{E}[\\Delta N] = 0\n$$\nThe expected change in the total number of cells per update is $0$. This is a closed-form analytic expression, a constant that is independent of the current configuration $\\{x_j\\}$, the neighborhood emptiness counts $\\{e_i\\}$, and the parameter $r_0$.",
            "answer": "$$\n\\boxed{0}\n$$"
        },
        {
            "introduction": "Biological systems are inherently multi-scale, and our models must often reflect this by coupling different mathematical formalisms. This practice explores a common scenario where a discrete cellular automaton for a cell population is coupled with a continuous partial differential equation (PDE) for a diffusing nutrient field. Your task is to determine the maximum allowable time step, $\\Delta t$, that ensures the numerical stability of the entire hybrid simulation. This involves reconciling the classic Courant–Friedrichs–Lewy (CFL) stability conditions for the PDE with a probabilistic constraint to prevent temporal aliasing in the stochastic CA, a crucial and highly practical challenge in computational systems biology.",
            "id": "3293879",
            "problem": "Consider a coupled simulation in computational systems biology that integrates a reaction–advection–diffusion partial differential equation (PDE) for a nutrient field with a cellular automaton (CA) for a proliferating cell population on a two-dimensional lattice. The PDE for nutrient concentration $c(x,y,t)$ is discretized on a uniform Cartesian grid with spacings $\\Delta x$ and $\\Delta y$ using forward Euler time integration. The diffusive flux is discretized with a standard five-point Laplacian stencil, and the advective flux $\\nabla \\cdot (\\mathbf{v} c)$ is discretized using first-order upwind differences in both directions. The CA rules at each lattice site are driven by stochastic events: cell division with rate $\\lambda_{\\mathrm{div}}(c)$ and cell death with rate $\\mu$, modeled as independent Poisson processes. The simulation advances the PDE and CA with a shared uniform time step $\\Delta t$ via operator splitting.\n\nYou are given the following scientifically plausible parameters for a microfluidic biofilm system:\n- Spatial spacings: $\\Delta x = \\Delta y = 5 \\times 10^{-6}\\ \\mathrm{m}$.\n- Diffusion coefficient: $D = 1.0 \\times 10^{-9}\\ \\mathrm{m}^{2}\\mathrm{s}^{-1}$.\n- Constant advection velocities: $v_{x} = 2.0 \\times 10^{-5}\\ \\mathrm{m}\\,\\mathrm{s}^{-1}$ and $v_{y} = 1.0 \\times 10^{-5}\\ \\mathrm{m}\\,\\mathrm{s}^{-1}$.\n- Division rate: $\\lambda_{\\mathrm{div}}(c) = \\dfrac{k\\,c}{K + c}$ with $k = 0.04\\ \\mathrm{s}^{-1}$ and $K$ any positive constant (the precise value of $K$ is not needed to bound the maximum rate).\n- Death rate: $\\mu = 0.01\\ \\mathrm{s}^{-1}$.\n- Temporal aliasing tolerance: in each time step, the probability that two or more CA events occur at a single site must be below $p_{\\mathrm{tol}} = 0.01$.\n\nStarting from first principles and core definitions, derive the Courant–Friedrichs–Lewy (CFL) constraints that guarantee stability of the explicit PDE update for advection and diffusion on this grid, and then derive a probabilistic constraint on $\\Delta t$ such that the CA update avoids temporal aliasing under the stated tolerance. Compute the largest permissible $\\Delta t$ that simultaneously satisfies all constraints.\n\nExpress the final $\\Delta t$ in seconds and round your answer to four significant figures. Do not provide intermediate results, only the final $\\Delta t$ value.",
            "solution": "The coupled scheme advances the PDE with forward Euler and the CA with a uniform time step $\\Delta t$. We must constrain $\\Delta t$ to satisfy explicit stability for the PDE and to avoid aliasing for the CA event processes.\n\nFor the advection term discretized with first-order upwind in two dimensions, let the donor-cell update for a concentration at grid point $(i,j)$ be written in conservative form. Under forward Euler, the update coefficients are nonnegative and sum to one provided the sum of Courant numbers does not exceed unity. The Courant numbers in $x$ and $y$ are defined as\n$$\n\\mathrm{Co}_{x} = \\frac{|v_{x}|\\,\\Delta t}{\\Delta x},\\qquad \\mathrm{Co}_{y} = \\frac{|v_{y}|\\,\\Delta t}{\\Delta y}.\n$$\nFor monotonicity and $L^{\\infty}$ stability of the first-order upwind scheme, a sufficient condition is\n$$\n\\mathrm{Co}_{x} + \\mathrm{Co}_{y} \\leq 1,\n$$\nwhich implies the explicit advection time-step constraint\n$$\n\\Delta t \\leq \\frac{1}{\\dfrac{|v_{x}|}{\\Delta x} + \\dfrac{|v_{y}|}{\\Delta y}}.\n$$\nSubstituting the given velocities and grid spacings yields\n$$\n\\frac{|v_{x}|}{\\Delta x} = \\frac{2.0 \\times 10^{-5}}{5.0 \\times 10^{-6}} = 4,\\qquad \\frac{|v_{y}|}{\\Delta y} = \\frac{1.0 \\times 10^{-5}}{5.0 \\times 10^{-6}} = 2,\n$$\nso\n$$\n\\Delta t_{\\mathrm{adv}}^{\\max} = \\frac{1}{4 + 2} = \\frac{1}{6}\\ \\mathrm{s} \\approx 0.1667\\ \\mathrm{s}.\n$$\n\nFor the diffusion term discretized with the standard five-point Laplacian on a uniform grid and forward Euler in time, linear stability can be characterized via the eigenvalues of the discrete Laplacian. Consider the semi-discrete form for diffusion,\n$$\n\\frac{\\mathrm{d}\\mathbf{c}}{\\mathrm{d}t} = D\\,\\mathbf{L}\\,\\mathbf{c},\n$$\nwhere $\\mathbf{L}$ is the discrete Laplacian operator. On a two-dimensional uniform grid, the largest-magnitude eigenvalue of $\\mathbf{L}$ is\n$$\n\\lambda_{\\max}(\\mathbf{L}) = -4\\left(\\frac{1}{\\Delta x^{2}} + \\frac{1}{\\Delta y^{2}}\\right).\n$$\nApplying forward Euler to $\\frac{\\mathrm{d}\\mathbf{c}}{\\mathrm{d}t} = D\\,\\mathbf{L}\\,\\mathbf{c}$, stability for each modal component $\\hat{c}$ with eigenvalue $\\lambda$ requires $|1 + \\Delta t\\,D\\,\\lambda| \\leq 1$ for real negative $\\lambda$, yielding\n$$\n\\Delta t \\leq \\frac{2}{|D\\,\\lambda_{\\max}(\\mathbf{L})|} = \\frac{1}{2D\\left(\\frac{1}{\\Delta x^{2}} + \\frac{1}{\\Delta y^{2}}\\right)}.\n$$\nSubstituting the given values, with $\\Delta x = \\Delta y = 5.0 \\times 10^{-6}\\ \\mathrm{m}$ and $D = 1.0 \\times 10^{-9}\\ \\mathrm{m}^{2}\\mathrm{s}^{-1}$, we compute\n$$\n\\frac{1}{\\Delta x^{2}} = \\frac{1}{(5.0 \\times 10^{-6})^{2}} = \\frac{1}{25 \\times 10^{-12}} = 4.0 \\times 10^{10}\\ \\mathrm{m}^{-2},\n$$\nand similarly $\\frac{1}{\\Delta y^{2}} = 4.0 \\times 10^{10}\\ \\mathrm{m}^{-2}$. Therefore,\n$$\n\\Delta t_{\\mathrm{diff}}^{\\max} = \\frac{1}{2 \\times 1.0 \\times 10^{-9} \\times \\left(4.0 \\times 10^{10} + 4.0 \\times 10^{10}\\right)} = \\frac{1}{2 \\times 1.0 \\times 10^{-9} \\times 8.0 \\times 10^{10}} = \\frac{1}{160} \\ \\mathrm{s} = 0.00625\\ \\mathrm{s}.\n$$\n\nFor the CA event processes at each site, division and death are modeled as independent Poisson processes with rates $\\lambda_{\\mathrm{div}}(c)$ and $\\mu$, respectively. The total event rate per site is\n$$\n\\lambda_{\\mathrm{tot}}(c) = \\lambda_{\\mathrm{div}}(c) + \\mu.\n$$\nTo bound the probability of two or more events in a single time step under Poisson statistics, let $N$ be the number of events in a step of duration $\\Delta t$, with $N \\sim \\mathrm{Poisson}(\\lambda_{\\mathrm{tot}}(c)\\,\\Delta t)$. Then\n$$\n\\mathbb{P}(N \\geq 2) = 1 - \\exp\\!\\left(-\\lambda_{\\mathrm{tot}}(c)\\,\\Delta t\\right)\\left(1 + \\lambda_{\\mathrm{tot}}(c)\\,\\Delta t\\right).\n$$\nTo ensure $\\mathbb{P}(N \\geq 2) \\leq p_{\\mathrm{tol}}$, a sufficient and analytically tractable small-step condition uses the second-order term from the Taylor expansion:\n$$\n\\mathbb{P}(N \\geq 2) \\approx \\frac{\\left(\\lambda_{\\mathrm{tot}}(c)\\,\\Delta t\\right)^{2}}{2} \\leq p_{\\mathrm{tol}}.\n$$\nThis gives\n$$\n\\Delta t \\leq \\frac{\\sqrt{2\\,p_{\\mathrm{tol}}}}{\\lambda_{\\mathrm{tot}}(c)}.\n$$\nTo guarantee the bound uniformly over the domain, we use the maximum possible rate. Since $\\lambda_{\\mathrm{div}}(c) = \\dfrac{k c}{K + c}$ is increasing in $c$ and saturates at $k$ as $c \\to \\infty$, the maximum division rate is $\\lambda_{\\mathrm{div}}^{\\max} = k$. Therefore,\n$$\n\\lambda_{\\mathrm{tot}}^{\\max} = \\lambda_{\\mathrm{div}}^{\\max} + \\mu = k + \\mu = 0.04 + 0.01 = 0.05\\ \\mathrm{s}^{-1},\n$$\nand, with $p_{\\mathrm{tol}} = 0.01$,\n$$\n\\Delta t_{\\mathrm{CA}}^{\\max} = \\frac{\\sqrt{2 \\times 0.01}}{0.05} = \\frac{\\sqrt{0.02}}{0.05}.\n$$\nCompute $\\sqrt{0.02} = \\sqrt{2} \\times 0.1 \\approx 1.414213562 \\times 0.1 = 0.1414213562$, hence\n$$\n\\Delta t_{\\mathrm{CA}}^{\\max} \\approx \\frac{0.1414213562}{0.05} = 2.828427124\\ \\mathrm{s}.\n$$\n\nReconciling the constraints, the admissible time step is the minimum of the advection, diffusion, and CA bounds:\n$$\n\\Delta t^{\\max} = \\min\\!\\left(\\Delta t_{\\mathrm{adv}}^{\\max},\\ \\Delta t_{\\mathrm{diff}}^{\\max},\\ \\Delta t_{\\mathrm{CA}}^{\\max}\\right) = \\min\\!\\left(\\frac{1}{6},\\ \\frac{1}{160},\\ 2.828427124\\right)\\ \\mathrm{s} = \\frac{1}{160}\\ \\mathrm{s}.\n$$\nNumerically, this is $\\Delta t^{\\max} = 0.00625\\ \\mathrm{s}$. Rounding to four significant figures and expressing in seconds gives $0.006250\\ \\mathrm{s}$.",
            "answer": "$$\\boxed{0.006250}$$"
        },
        {
            "introduction": "Moving from a conceptual model to a large-scale simulation that can answer real biological questions requires a deep understanding of computational performance. This final practice focuses on the practical challenges of implementing a cellular automaton on modern parallel hardware like a Graphics Processing Unit (GPU). You will develop a first-principles performance model to estimate the primary bottleneck in many large scientific simulations: memory bandwidth. By calculating memory traffic and the overhead from parallel update conflicts, you will gain insight into how algorithmic design and hardware characteristics interact to determine the feasibility of simulating systems at biologically relevant scales.",
            "id": "3293868",
            "problem": "Consider a three-dimensional Cellular Automaton (CA) for spatial biological modeling executed on a Graphics Processing Unit (GPU). The CA evolves on a cubic lattice of size $N_x \\times N_y \\times N_z$ with double-buffered, synchronous, parallel updates and a Moore neighborhood of radius $r$. Each lattice site holds a discrete state of $S$ bytes and $F$ additional scalar concentration fields stored as single-precision floating-point numbers ($4$ bytes each). Assume a two-phase time step: (i) a local, neighborhood-dependent “gather” update that computes the next-state buffer from the current-state buffer, and (ii) a stochastic motility or replication “scatter” phase where a fraction of currently occupied sites independently attempt to write into neighboring empty sites (one target per attempting agent, uniformly at random among all empty sites in the full domain). Assume the grid is partitioned into equally sized tiles of dimensions $t_x \\times t_y \\times t_z$ for shared-memory staging with a halo of width $r$ in each dimension.\n\nYou are to design a parallel update scheme that uses tiling to maximize data reuse and avoids write conflicts in the gather phase by writing to a separate next-state buffer. For the scatter phase, assume optimistic reservations without locks: each attempt reads the target occupancy; on success, the agent writes its full state to the target and clears its source; on failure (conflict), only the read occurs for that attempt. Assume all random choices are independent and uniformly distributed. Ignore arithmetic compute cost; focus exclusively on memory traffic and expected conflict behavior.\n\nStarting from first principles of parallel memory reuse and independence assumptions for random selections, derive expressions, implement them, and evaluate the following quantities per time step for each test case:\n\n1. Total global memory traffic in bytes, $T_{\\text{total}}$, including both phases. For the gather phase, assume each tile loads its tile-plus-halo exactly once from global memory into shared memory and writes each interior site exactly once to the next-state buffer. For the scatter phase, approximate the expected number of successful target acquisitions using classical balls-into-bins reasoning under independence.\n\n2. The memory-bandwidth-limited time per step in seconds, $\\tau_{\\text{step}} = T_{\\text{total}} / B_{\\max}$, where $B_{\\max}$ is the sustained global memory bandwidth in $\\mathrm{GB}/\\mathrm{s}$ using the base-$10$ definition, that is, $1\\,\\mathrm{GB} = 10^9$ bytes. Express $\\tau_{\\text{step}}$ in seconds as a floating-point number.\n\n3. The expected conflict overhead factor for the scatter phase, $\\phi = A/S$, where $A$ is the expected number of attempts and $S$ is the expected number of successful target acquisitions. Also report the success rate $S/A$ as a decimal. Handle boundary cases $A=0$ or no empty sites gracefully by returning $\\phi = 1$ and $S/A = 1$ when $A=0$, and $\\phi = +\\infty$ and $S/A = 0$ when there are no empty sites but $A0$.\n\nUse the following modeling assumptions to make the calculation precise and universally implementable:\n\n- The number of lattice sites is $N = N_x N_y N_z$.\n- The per-site byte size is $b_{\\text{cell}} = S + 4F$ bytes.\n- The gather phase per-tile global read is $b_{\\text{cell}} \\cdot (t_x + 2r)(t_y + 2r)(t_z + 2r)$ and the number of interior updates covered by that tile is $t_x t_y t_z$. Assume the grid size is divisible by the tile size in each dimension, and ignore boundary remainder effects. Hence the gather-phase read bytes per interior update is $b_{\\text{cell}} \\cdot \\frac{(t_x + 2r)(t_y + 2r)(t_z + 2r)}{t_x t_y t_z}$, and the write bytes per interior update is $b_{\\text{cell}}$.\n- Let $\\rho \\in [0,1]$ denote the fraction of occupied sites before the scatter phase. The expected number of attempts is $A = q \\rho N$, where $q \\in [0,1]$ is the fraction of currently occupied sites that attempt a move. The number of empty sites is $E = (1-\\rho) N$. Under uniform random targeting into the set of empty sites, the expected number of successfully claimed targets is $S \\approx E \\left(1 - e^{-A/E}\\right)$ when $E0$, with the convention $S=0$ when $E=0$ and $A0$.\n- The scatter-phase memory traffic is modeled as the sum of: per-attempt target occupancy read cost of $1$ byte for all $A$ attempts, plus per-success writes of the full state to the target and clearing the source, and occupancy byte updates for both sites. Hence, per successful move, the write traffic is $2\\,b_{\\text{cell}} + 2$ bytes. Thus, $T_{\\text{scatter}} = A \\cdot 1 + S \\cdot (2 b_{\\text{cell}} + 2)$ bytes.\n- The gather-phase total traffic is $T_{\\text{gather}} = N \\cdot b_{\\text{cell}} \\left( \\frac{(t_x + 2r)(t_y + 2r)(t_z + 2r)}{t_x t_y t_z} + 1 \\right)$ bytes.\n- The total is $T_{\\text{total}} = T_{\\text{gather}} + T_{\\text{scatter}}$ bytes.\n\nYour program must compute, for each test case, the quadruple $\\left[T_{\\text{total}}, \\tau_{\\text{step}}, \\phi, S/A\\right]$ with the following requirements:\n\n- All four outputs are floating-point numbers.\n- The time $\\tau_{\\text{step}}$ must be in seconds.\n- The outputs for each test case should be rounded to six decimal places.\n- The final output must be a single line containing a list of these quadruples, one per test case, as a comma-separated list enclosed in square brackets, where each quadruple itself is a list in the same bracketed, comma-separated format.\n\nUse the following test suite, which covers a typical case, small-tile overhead, very large grids, near-saturation occupancy, and a no-move edge case:\n\n- Test case $1$: $N_x = 512$, $N_y = 512$, $N_z = 128$, $r = 1$, $t_x = 8$, $t_y = 8$, $t_z = 8$, $S = 1$, $F = 2$, $B_{\\max} = 900$ $\\mathrm{GB}/\\mathrm{s}$, $\\rho = 0.3$, $q = 0.2$.\n- Test case $2$: $N_x = 32$, $N_y = 32$, $N_z = 32$, $r = 2$, $t_x = 4$, $t_y = 4$, $t_z = 4$, $S = 1$, $F = 0$, $B_{\\max} = 300$ $\\mathrm{GB}/\\mathrm{s}$, $\\rho = 0.9$, $q = 0.5$.\n- Test case $3$: $N_x = 1024$, $N_y = 1024$, $N_z = 256$, $r = 1$, $t_x = 8$, $t_y = 8$, $t_z = 4$, $S = 2$, $F = 1$, $B_{\\max} = 1600$ $\\mathrm{GB}/\\mathrm{s}$, $\\rho = 0.05$, $q = 0.1$.\n- Test case $4$: $N_x = 256$, $N_y = 256$, $N_z = 64$, $r = 1$, $t_x = 16$, $t_y = 4$, $t_z = 4$, $S = 1$, $F = 3$, $B_{\\max} = 600$ $\\mathrm{GB}/\\mathrm{s}$, $\\rho = 0.99$, $q = 0.9$.\n- Test case $5$: $N_x = 128$, $N_y = 128$, $N_z = 128$, $r = 1$, $t_x = 8$, $t_y = 8$, $t_z = 8$, $S = 1$, $F = 4$, $B_{\\max} = 900$ $\\mathrm{GB}/\\mathrm{s}$, $\\rho = 0.4$, $q = 0.0$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is the list $\\left[T_{\\text{total}}, \\tau_{\\text{step}}, \\phi, S/A\\right]$ for the corresponding test case, in the given order, each value rounded to six decimal places. For example, the format should be like $[[x_1,y_1,z_1,w_1],[x_2,y_2,z_2,w_2],\\ldots]$ with no additional text.",
            "solution": "The user has provided a problem that requires the derivation and calculation of performance metrics for a three-dimensional Cellular Automaton (CA) executed on a Graphics Processing Unit (GPU). The model is specified in considerable detail, including parameters for the computational grid, the algorithm's structure (a gather phase and a scatter phase), and the underlying hardware characteristics (memory bandwidth). My analysis will proceed by systematically deriving expressions for the requested quantities from the first principles and modeling assumptions provided.\n\nThe problem is centered on performance modeling, a critical aspect of computational science. We are asked to ignore arithmetic compute costs and focus solely on memory traffic, which is appropriate for many large-scale scientific simulations on GPUs where performance is frequently limited by memory bandwidth rather than floating-point operation throughput.\n\nThe requested quantities are:\n$1$. The total global memory traffic per time step, $T_{\\text{total}}$, in bytes.\n$2$. The memory-bandwidth-limited time per step, $\\tau_{\\text{step}}$, in seconds.\n$3$. The conflict overhead factor, $\\phi$, and success rate, $S/A$, for the scatter phase.\n\nLet us define the primary parameters provided:\n- Lattice dimensions: $N_x, N_y, N_z$.\n- Total number of lattice sites: $N = N_x N_y N_z$.\n- Moore neighborhood radius: $r$.\n- Tile dimensions for shared-memory staging: $t_x, t_y, t_z$.\n- Per-site state size in bytes: $S$.\n- Number of per-site scalar fields (single-precision, $4$ bytes each): $F$.\n- Sustained global memory bandwidth: $B_{\\max}$ in $\\mathrm{GB}/\\mathrm{s}$, where $1\\,\\mathrm{GB} = 10^9$ bytes.\n- Fraction of occupied sites: $\\rho \\in [0, 1]$.\n- Fraction of occupied sites attempting to scatter: $q \\in [0, 1]$.\n\nFrom these, we derive the size of the data for a single cell, $b_{\\text{cell}}$, which is the sum of the discrete state size $S$ and the storage for the $F$ floating-point fields.\n$$b_{\\text{cell}} = S + 4F \\text{ bytes}$$\n\nThe analysis is structured into two parts, corresponding to the two phases of the update step.\n\n**1. Gather Phase Memory Traffic ($T_{\\text{gather}}$)**\n\nThis phase involves a local, neighborhood-dependent update. To optimize data reuse, the simulation grid is partitioned into tiles. Each GPU thread block processes one tile. The core principle is to load the data for a tile and its surrounding halo from slow global memory into fast on-chip shared memory just once.\n\n- The volume of a tile is $V_{\\text{tile}} = t_x t_y t_z$.\n- To compute the update for all cells within this tile, data from a Moore neighborhood of radius $r$ is required. This necessitates loading a larger block that includes a \"halo\" of width $r$ around the tile in each dimension.\n- The dimensions of this larger block are $(t_x + 2r) \\times (t_y + 2r) \\times (t_z + 2r)$.\n- The total bytes read from global memory into shared memory for one tile is therefore:\n$$b_{\\text{read,tile}} = b_{\\text{cell}} \\cdot (t_x + 2r)(t_y + 2r)(t_z + 2r)$$\n- After computation, the new states for the interior cells of the tile are written back to a separate next-state buffer in global memory. The bytes written for one tile are:\n$$b_{\\text{write,tile}} = b_{\\text{cell}} \\cdot t_x t_y t_z$$\n- The problem states we can ignore boundary effects, assuming the total grid size $N$ is an integer multiple of the tile volume $V_{\\text{tile}}$. The total number of tiles is $N_{\\text{tiles}} = N / V_{\\text{tile}} = N / (t_x t_y t_z)$.\n- The total gather traffic is the sum of reads and writes for all tiles:\n$$T_{\\text{gather}} = N_{\\text{tiles}} \\cdot (b_{\\text{read,tile}} + b_{\\text{write,tile}})$$\n$$T_{\\text{gather}} = \\frac{N}{t_x t_y t_z} \\left[ b_{\\text{cell}}(t_x+2r)(t_y+2r)(t_z+2r) + b_{\\text{cell}}t_x t_y t_z \\right]$$\n- Factoring out terms yields the total gather traffic expressed as an average per-site cost, matching the formula provided in the problem statement:\n$$T_{\\text{gather}} = N \\cdot b_{\\text{cell}} \\left( \\frac{(t_x+2r)(t_y+2r)(t_z+2r)}{t_x t_y t_z} + 1 \\right)$$\nThe first term inside the parenthesis represents the read amplification factor due to halo requirements, while the '$+1$' represents the one-to-one write of the updated state.\n\n**2. Scatter Phase Memory Traffic ($T_{\\text{scatter}}$)**\n\nThis phase models stochastic events like motility or replication. A fraction $q$ of the occupied sites attempt to move to a randomly chosen empty site. The problem description contains a slight ambiguity, mentioning \"neighboring empty sites\" but clarifying in a parenthetical and in the provided formula that targeting is uniform over \"all empty sites in the full domain\". We must adhere to the formal model specified by the formulas.\n\n- The number of occupied sites is $N_{\\text{occ}} = \\rho N$.\n- The expected number of attempts, $A$, is:\n$$A = q \\cdot N_{\\text{occ}} = q \\rho N$$\n- The number of available empty sites, $E$, is:\n$$E = (1 - \\rho) N$$\n- The process of $A$ agents attempting to claim one of $E$ empty sites is analogous to the classical \"balls-into-bins\" problem. The expected number of unique sites claimed (bins with at least one ball), $S$, is given by the well-known approximation:\n$$S \\approx E \\left(1 - e^{-A/E}\\right) \\text{, for } E  0$$\nThe problem specifies that if $E=0$ (no empty sites), then $S=0$.\n\nThe memory traffic for this phase consists of reads for all attempts and writes for successful ones.\n- For each of the $A$ attempts, the occupancy of the target site is read. This is specified as a $1$-byte read. Total attempt traffic: $A \\cdot 1$ bytes.\n- For each of the $S$ successful moves, the full state of the agent is written to the target site, and the source site is cleared. The problem models this as a write of $b_{\\text{cell}}$ bytes to the target, a write of $b_{\\text{cell}}$ bytes to clear the source, plus a $1$-byte occupancy update for both target and source. Total success traffic per success: $(2b_{\\text{cell}} + 2)$ bytes.\n- The total scatter traffic, $T_{\\text{scatter}}$, is the sum of these components:\n$$T_{\\text{scatter}} = A \\cdot 1 + S \\cdot (2 b_{\\text{cell}} + 2)$$\n\n**3. Total Traffic, Time Step, and Conflict Metrics**\n\n- The total memory traffic per time step, $T_{\\text{total}}$, is the sum of the traffic from both phases:\n$$T_{\\text{total}} = T_{\\text{gather}} + T_{\\text{scatter}}$$\n- The memory-bandwidth-limited time per step, $\\tau_{\\text{step}}$, is this total traffic divided by the sustained bandwidth, $B_{\\max}$. The bandwidth is given in $\\mathrm{GB}/\\mathrm{s}$, which must be converted to bytes/s using the provided definition $1\\,\\mathrm{GB} = 10^9$ bytes.\n$$\\tau_{\\text{step}} = \\frac{T_{\\text{total}}}{B_{\\max} \\cdot 10^9}$$\n- The conflict overhead factor, $\\phi$, is the ratio of attempts to successes. It quantifies the amount of \"wasted\" work due to conflicts.\n$$\\phi = \\frac{A}{S}$$\n- The success rate is the reciprocal of the overhead factor:\n$$\\text{Success Rate} = \\frac{S}{A}$$\n- The problem specifies handling of edge cases, which we will adhere to:\n    - If $A=0$ (e.g., if $q=0$), then $S=0$. In this case, $\\phi$ is taken to be $1$ and the success rate $S/A$ is taken to be $1$. This convention implies no attempts leads to no conflicts and is thus perfectly \"successful\" in a vacuous sense.\n    - If $E=0$ (i.e., $\\rho=1$) and $A0$, then $S=0$. All attempts must fail as there are no empty sites. $\\phi = A/0 \\rightarrow +\\infty$ and the success rate $S/A = 0/A = 0$.\n\nThese derived expressions provide a complete framework to solve for the requested quantities for each test case.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the cellular automaton performance modeling problem for a given set of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (Nx, Ny, Nz, r, tx, ty, tz, S, F, B_max, rho, q)\n        (512, 512, 128, 1, 8, 8, 8, 1, 2, 900, 0.3, 0.2),\n        (32, 32, 32, 2, 4, 4, 4, 1, 0, 300, 0.9, 0.5),\n        (1024, 1024, 256, 1, 8, 8, 4, 2, 1, 1600, 0.05, 0.1),\n        (256, 256, 64, 1, 16, 4, 4, 1, 3, 600, 0.99, 0.9),\n        (128, 128, 128, 1, 8, 8, 8, 1, 4, 900, 0.4, 0.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        Nx, Ny, Nz, r, tx, ty, tz, S_bytes, F, B_max_GBps, rho, q = case\n\n        # --- System Parameters ---\n        N = float(Nx * Ny * Nz)\n        b_cell = float(S_bytes + 4 * F)\n\n        # --- Gather Phase Traffic Calculation ---\n        read_amplification = ((tx + 2*r) * (ty + 2*r) * (tz + 2*r)) / (tx * ty * tz)\n        T_gather = N * b_cell * (read_amplification + 1.0)\n\n        # --- Scatter Phase Traffic Calculation ---\n        A = q * rho * N  # Expected number of attempts\n        E = (1.0 - rho) * N  # Number of empty sites\n\n        S_success = 0.0\n        if A > 0 and E > 0:\n            S_success = E * (1.0 - np.exp(-A / E))\n        elif A > 0 and E == 0:\n            S_success = 0.0\n        # if A == 0, S_success remains 0.0\n\n        T_scatter = A * 1.0 + S_success * (2 * b_cell + 2.0)\n\n        # --- Total Traffic and Time Step ---\n        T_total = T_gather + T_scatter\n        B_max_Bps = B_max_GBps * 1e9\n        tau_step = T_total / B_max_Bps if B_max_Bps > 0 else float('inf')\n\n        # --- Conflict Overhead Metrics ---\n        if A == 0:\n            phi = 1.0\n            S_over_A = 1.0\n        elif S_success == 0: # This covers the case E=0 and A>0\n            phi = float('inf')\n            S_over_A = 0.0\n        else:\n            phi = A / S_success\n            S_over_A = S_success / A\n\n        results.append([T_total, tau_step, phi, S_over_A])\n\n    # --- Format and Print Output ---\n    formatted_quads = []\n    for quad in results:\n        formatted_vals = []\n        for val in quad:\n            if val == float('inf'):\n                # Problem asks for floating point, but inf is standard. Let's represent it textually for clarity.\n                # However, the problem doesn't specify how to format infinity. Assuming a standard string representation is fine.\n                # Re-reading: \"All four outputs are floating-point numbers\". This is tricky for infinity.\n                # Let's stick to Python's `inf` representation and see if it formats.\n                # The f-string format `{val:.6f}` will fail on `inf`. Let's handle it explicitly.\n                formatted_vals.append(str(val))\n            else:\n                formatted_vals.append(f'{val:.6f}')\n        formatted_quads.append(f\"[{','.join(formatted_vals)}]\")\n    \n    final_output_string = f\"[{','.join(formatted_quads)}]\"\n    print(final_output_string)\n\nsolve()\n```"
        }
    ]
}