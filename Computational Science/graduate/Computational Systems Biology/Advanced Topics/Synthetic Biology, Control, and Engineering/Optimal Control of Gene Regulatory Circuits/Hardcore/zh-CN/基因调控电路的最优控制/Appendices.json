{
    "hands_on_practices": [
        {
            "introduction": "在合成生物学中，一个核心任务是驱动细胞在不同功能状态间进行快速、可靠的切换。本练习将直接应对这一挑战，为一个经典的双稳态“拨动开关”模型设计时间最优控制器。你将应用庞特里亚金最大值原理（Pontryagin's Maximum Principle），在满足“代谢负担”这一关键生物学约束的前提下，找到实现状态翻转的最优“开关式”（bang-bang）控制策略。",
            "id": "3335261",
            "problem": "考虑一个双稳态基因拨动开关的单坐标降阶模型，该模型通过对快速变量进行准稳态消除，从标准的相互抑制动力学中推导得出。基因表达差异坐标 $x(t)$ 服从立方范式\n$$\n\\dot{x}(t) = a\\,x(t) - b\\,x^3(t) + c + k\\,u(t),\n$$\n其中 $a>0$ 和 $b>0$ 分别代表有效线性增益和立方饱和，$c$ 是一个模拟基础转录偏好的不对称参数，$k>0$ 是诱导物驱动增益，$u(t)\\in\\{0,u_{\\max}\\}$ 是一个砰砰诱导策略。与诱导相关的代谢负荷通过不等式约束来建模\n$$\n\\int_{0}^{T} \\gamma\\,u^2(t)\\,dt \\leq B,\n$$\n其中 $\\gamma>0$ 是负荷系数，$B>0$ 是允许的总负荷预算。控制目标是在满足负荷约束的同时，在最短时间 $T$ 内将开关从位于 $x_A$ 势阱吸引盆中的初始状态 $x(0)=x_A$ 翻转到对应于相反势阱的目标区域，该区域定义为 $x(T)\\geq x_B$。\n\n从计算系统生物学和控制论的基本原理出发，即基因调控的常微分方程动力学和庞特里亚金极大值原理，为这一维降阶系统设计一个最优砰砰策略 $u(t)\\in\\{0,u_{\\max}\\}$，以在满足负荷约束的条件下最小化翻转时间。您的推导和算法必须基于原理，并且不应假设任何预先指定的切换时间或策略。将负荷约束明确地纳入最优性条件中。\n\n最终程序必须对给定的参数集，数值计算最小翻转时间 $T$（单位为分钟），并四舍五入到三位小数。如果在给定的负荷预算下无法达到目标（即，没有任何 $u(t)\\in\\{0,u_{\\max}\\}$ 的策略能同时满足状态和负荷约束），则输出布尔值 `False`。\n\n使用以下参数值测试套件，这些值以科学上合理的单位表示：基因表达 $x$ 为任意单位，时间单位为分钟，$u$ 为诱导速率单位，使得 $k\\,u$ 的单位为每分钟基因表达量。对于所有情况，设置 $a=1$, $b=1$, $k=1$, $u_{\\max}=0.5$, $\\gamma=2$, $x_A=-1.5$, and $x_B=0.8$。\n\n- 情况1（一般理想路径）：$c=0, B=100$。\n- 情况2（边界负荷等式）：$c=0$，$B$ 的取值恰好等于从 $t=0$ 开始以 $u(t)=u_{\\max}$ 运行直至达到目标所需的最小负荷；即 $B=\\gamma\\,u_{\\max}^2\\,T^\\star$，其中 $T^\\star$ 是在全诱导下的最短时间。您的程序必须在这种情况下内部计算 $T^\\star$，然后相应地设置 $B$，再计算报告的最小翻转时间。\n- 情况3（预算受限且有正漂移辅助）：$c=0.5, B=0.5$。\n- 情况4（因负漂移主导而不可行）：$c=-0.5, B=0.5$。\n\n科学真实性要求：\n- 必须遵守所有的动力学和约束条件。假设如所写的那样，是连续时间演化和确定性动力学。\n- 您必须使用基于事件的积分来检测 $x(t)$ 首次满足 $x(t)\\geq x_B$ 的时刻。\n- 当负荷预算 $B$ 不足以维持 $u(t)=u_{\\max}$ 直至达到目标时，考虑由第一性原理推导出的最优两阶段砰砰策略：施加 $u(t)=u_{\\max}$ 直到负荷在时间 $t=T_{\\mathrm{budget}}=B/(\\gamma u_{\\max}^2)$ 耗尽，然后设置 $u(t)=0$，并仅依靠自主漂移来达到目标（如果可能的话）。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含按情况1-4顺序排列的结果，形式为用方括号括起来的逗号分隔列表。每个条目必须是浮点数（最小翻转时间，单位为分钟，四舍五入到三位小数）或布尔值 `False`（如果不可行）。例如，一个包含四种情况的有效输出看起来像 `[12.345, 8.765, False, 3.210]`。",
            "solution": "我们从基因调控动力学开始，其模型为单坐标立方范式\n$$\n\\dot{x}(t) = a\\,x(t) - b\\,x^3(t) + c + k\\,u(t),\n$$\n其中 $u(t)\\in\\{0,u_{\\max}\\}$，初始条件为 $x(0)=x_A$。目标是集合 $\\{x \\mid x\\geq x_B\\}$，代谢负荷受以下约束\n$$\n\\int_{0}^{T} \\gamma\\,u^2(t)\\,dt \\leq B.\n$$\n系统动力学捕捉了双稳态拨动开关的简化描述：当 $c\\approx 0$ 时，立方向量场 $a\\,x(t) - b\\,x^3(t)$ 在 $\\pm\\sqrt{a/b}$ 附近产生两个稳定势阱，而当诱导开启时，项 $k\\,u(t)$ 会使景观向正势阱倾斜。不对称参数 $c$ 通过将漂移偏向正侧（$c>0$）或负侧（$c<0$）来打破对称性。\n\n我们使用庞特里亚金极大值原理来表述受等周（积分）不等式约束的最短时间问题。定义哈密顿量\n$$\nH(x,\\lambda,u) = 1 + \\lambda\\left(a\\,x - b\\,x^3 + c + k\\,u\\right) + \\mu\\,\\gamma\\,u^2,\n$$\n其中 $\\lambda(t)$ 是协态变量，$\\mu\\geq 0$ 是与负荷约束相关的拉格朗日乘子。协态动力学遵循\n$$\n\\dot{\\lambda}(t) = -\\frac{\\partial H}{\\partial x}(x,\\lambda,u) = -\\lambda\\left(a - 3b\\,x^2\\right),\n$$\n并附带适用于最短时间到达目标问题的横截性条件。对于最短时间问题，$H$ 中的常数项 $1$ 反映了成本率。控制 $u(t)\\in\\{0,u_{\\max}\\}$ 必须几乎处处逐点最小化 $H$。因为除了与 $\\mu$ 相关的二次惩罚项外，$H$ 在 $u$ 上是仿射的，所以离散集 $\\{0,u_{\\max}\\}$ 上的最小化器通过比较两个哈密顿量值来确定：\n$$\nH(x,\\lambda,u_{\\max}) - H(x,\\lambda,0) = \\lambda\\,k\\,u_{\\max} + \\mu\\,\\gamma\\,u_{\\max}^2.\n$$\n因此，最优控制是砰砰控制，其切换规则由开关函数的符号决定\n$$\n\\sigma(t) = \\lambda(t)\\,k + \\mu\\,\\gamma\\,u_{\\max}.\n$$\n如果 $\\sigma(t) < 0$ 则 $u(t)=u_{\\max}$，如果 $\\sigma(t) > 0$ 则 $u(t)=0$。在我们的设置中，$k>0$ 且系统是一维的，并且在 $u$ 上是单调的。对于在正驱动增益 $k>0$ 下从 $x_A < x_B$ 驱动到目标 $x_B$，直观上我们希望尽快将状态向正方向推动，因此最优策略通常涉及在开始时施加最大控制 $u(t)=u_{\\max}$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Runtime environment: Python 3.12, numpy 1.23.5, scipy 1.11.4\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef dynamics(t, x, a, b, c, k, u):\n    # dx/dt = a*x - b*x^3 + c + k*u\n    return a * x[0] - b * (x[0] ** 3) + c + k * u\n\ndef hit_event_factory(x_target):\n    # Event function g(x) = x - x_target; detect crossing in positive direction.\n    def event(t, x):\n        return x[0] - x_target\n    event.terminal = True\n    event.direction = 1.0\n    return event\n\ndef simulate_phase(a, b, c, k, u, x_init, t_span, x_target, rtol=1e-8, atol=1e-10, max_step=np.inf):\n    # Simulate dynamics over t_span with constant u, detect first time x >= x_target.\n    event = hit_event_factory(x_target)\n    sol = solve_ivp(\n        fun=lambda t, x: dynamics(t, x, a, b, c, k, u),\n        t_span=t_span,\n        y0=[x_init],\n        events=event,\n        rtol=rtol,\n        atol=atol,\n        max_step=max_step\n    )\n    return sol\n\ndef minimal_flipping_time(a, b, c, k, u_max, gamma, B, x_init, x_target, boundary_match=False):\n    # Compute minimal flipping time under optimal bang-bang schedule with burden constraint.\n    # If boundary_match is True, first compute full-induction minimal time T*, then set B accordingly.\n    # Returns float time in minutes or False if infeasible.\n    # Phase 1: full induction to compute T* if needed.\n    sol_full = simulate_phase(a, b, c, k, u_max, x_init, (0.0, 1e4), x_target)\n    if sol_full.t_events[0].size > 0:\n        T_star = sol_full.t_events[0][0]\n        burden_star = gamma * (u_max ** 2) * T_star\n    else:\n        # Even with full induction for long time horizon, target not reached; infeasible.\n        return False\n\n    if boundary_match:\n        # Set B to exact burden needed under full induction until hitting.\n        B = burden_star\n\n    # Budget-based decision\n    T_budget = B / (gamma * (u_max ** 2))\n\n    if T_budget >= T_star:\n        # Budget sufficient to keep u = u_max until target is reached; minimal time is T_star.\n        return T_star\n    else:\n        # Two-phase schedule: u = u_max until T_budget, then u = 0 and rely on autonomous drift.\n        # Simulate phase 1 up to T_budget to get state at switch.\n        sol_phase1 = simulate_phase(a, b, c, k, u_max, x_init, (0.0, T_budget), x_target)\n        if sol_phase1.t_events[0].size > 0:\n            # Rare case: reached earlier than T_budget due to numerical tolerance; use event time.\n            return sol_phase1.t_events[0][0]\n        x_switch = sol_phase1.y[0, -1]\n        # Phase 2: u = 0 from T_budget onward\n        sol_phase2 = simulate_phase(a, b, c, k, 0.0, x_switch, (T_budget, T_budget + 1e4), x_target)\n        if sol_phase2.t_events[0].size > 0:\n            T2 = sol_phase2.t_events[0][0] - T_budget\n            return T_budget + T2\n        else:\n            # Target not reached under autonomous drift; infeasible under given budget.\n            return False\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Common parameters: a=1, b=1, k=1, u_max=0.5, gamma=2, x_init=-1.5, x_target=0.8\n    test_cases = [\n        # Case 1: c=0, B=100\n        {\"a\": 1.0, \"b\": 1.0, \"c\": 0.0, \"k\": 1.0, \"u_max\": 0.5, \"gamma\": 2.0, \"B\": 100.0,\n         \"x_init\": -1.5, \"x_target\": 0.8, \"boundary_match\": False},\n        # Case 2: c=0, B chosen to exactly match burden under full induction to target (boundary case)\n        {\"a\": 1.0, \"b\": 1.0, \"c\": 0.0, \"k\": 1.0, \"u_max\": 0.5, \"gamma\": 2.0, \"B\": None,\n         \"x_init\": -1.5, \"x_target\": 0.8, \"boundary_match\": True},\n        # Case 3: c=0.5 (positive drift assist), B=0.5 (budget-limited)\n        {\"a\": 1.0, \"b\": 1.0, \"c\": 0.5, \"k\": 1.0, \"u_max\": 0.5, \"gamma\": 2.0, \"B\": 0.5,\n         \"x_init\": -1.5, \"x_target\": 0.8, \"boundary_match\": False},\n        # Case 4: c=-0.5 (negative drift dominance), B=0.5 (likely infeasible)\n        {\"a\": 1.0, \"b\": 1.0, \"c\": -0.5, \"k\": 1.0, \"u_max\": 0.5, \"gamma\": 2.0, \"B\": 0.5,\n         \"x_init\": -1.5, \"x_target\": 0.8, \"boundary_match\": False},\n    ]\n\n    results = []\n    for case in test_cases:\n        a = case[\"a\"]; b = case[\"b\"]; c = case[\"c\"]; k = case[\"k\"]\n        u_max = case[\"u_max\"]; gamma = case[\"gamma\"]; B = case[\"B\"]\n        x_init = case[\"x_init\"]; x_target = case[\"x_target\"]\n        boundary_match = case[\"boundary_match\"]\n\n        T = minimal_flipping_time(a, b, c, k, u_max, gamma, B, x_init, x_target, boundary_match=boundary_match)\n        if isinstance(T, bool):\n            results.append(\"False\")\n        else:\n            results.append(f\"{T:.3f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "超越简单的状态切换，许多尖端生物应用要求我们能精确引导基因表达水平，使其随时间动态变化。本练习将介绍模型预测控制（Model Predictive Control, MPC），一个功能强大的“后退时域”控制框架，专为解决此类轨迹跟踪问题而设计。你将从零开始构建一个完整的MPC控制器，涵盖从系统模型离散化，到构建二次规划（QP）优化问题，再到实施后退时域法则，以实现对目标轨迹的鲁棒跟踪。",
            "id": "3335315",
            "problem": "考虑一个单基因调控回路，其中转录因子的浓度用 $x(t)$ 表示，单位为纳摩尔 (nM)，外部控制输入（例如，诱导物强度）用 $u(t)$ 表示，为在 $u(t) \\in [0,1]$ 范围内的无量纲量。基于质量平衡和一阶动力学，假设合成速率与输入成正比，速率比例常数为 $\\alpha$ (单位为 nM/s 每单位输入)，并加上一个基础合成项 $\\gamma$ (单位为 nM/s)，降解为一阶过程，速率为 $\\beta$ (单位为 s$^{-1}$)。其连续时间动力学由以下常微分方程描述：\n$$\n\\frac{dx(t)}{dt} = \\alpha\\,u(t) - \\beta\\,x(t) + \\gamma.\n$$\n您将设计一个模型预测控制 (MPC) 策略。模型预测控制 (MPC) 是一种滚动时域优化控制方法，它利用模型反复求解一个有限时域优化问题，应用第一个控制动作，然后用新的测量值进行更新。\n\n任务1 (模型推导与线性化)：从给定的动力学方程出发，通过满足 $\\frac{dx}{dt} = 0$ 来定义稳态 $(x^\\ast,u^\\ast)$。在 $(x^\\ast,u^\\ast)$ 附近，用偏差变量 $\\delta x(t) = x(t) - x^\\ast$ 和 $\\delta u(t) = u(t) - u^\\ast$ 对动力学进行线性化。在采样周期 $T_s$ (单位 s) 内对输入 $u(t)$ 使用零阶保持器的条件下，推导精确的离散时间模型。分别用绝对变量和偏差变量表示该模型。对于绝对变量，证明\n$$\nx_{k+1} = A\\,x_k + B\\,u_k + c,\n$$\n其中 $A$、$B$ 和 $c$ 是 $\\beta$、$\\alpha$、$\\gamma$ 和 $T_s$ 的函数。对于偏差变量，证明\n$$\n\\delta x_{k+1} = A\\,\\delta x_k + B\\,\\delta u_k.\n$$\n\n任务2 (有限时域跟踪公式)：对于长度为 $N$ 步的预测时域，为给定的参考轨迹 $r_1,\\dots,r_N$ (单位 nM) 定义一个跟踪目标。设成本函数为\n$$\nJ = \\sum_{i=1}^{N} q\\,\\big( x_i - r_i \\big)^2 + \\sum_{i=0}^{N-1} r_u\\,\\big( u_i - u_{\\mathrm{ref},i} \\big)^2,\n$$\n其中 $q \\ge 0$ 是状态跟踪权重，$r_u > 0$ 是输入偏差惩罚，$u_{\\mathrm{ref},i}$ 是一个选定的参考输入序列。在时域内的所有步骤中，强制执行严格的输入边界 $u_{\\min} \\le u_i \\le u_{\\max}$。\n\n任务3 (二次规划推导)：使用绝对仿射离散时间模型和预测时域，推导压缩预测模型\n$$\n\\mathbf{x} = \\mathbf{M}\\,x_0 + \\mathbf{T}\\,\\mathbf{u} + \\mathbf{t},\n$$\n其中 $\\mathbf{x} \\in \\mathbb{R}^{N}$ 堆叠了预测状态 $x_1,\\dots,x_N$，$\\mathbf{u} \\in \\mathbb{R}^{N}$ 堆叠了输入 $u_0,\\dots,u_{N-1}$，$\\mathbf{M} \\in \\mathbb{R}^{N \\times 1}$，$\\mathbf{T} \\in \\mathbb{R}^{N \\times N}$，以及 $\\mathbf{t} \\in \\mathbb{R}^{N}$ 编码了来自 $c$ 的仿射贡献。然后，通过使用压缩模型消去 $\\mathbf{x}$，将 $J$ 表示为关于 $\\mathbf{u}$ 的凸二次函数，\n$$\nJ(\\mathbf{u}) = \\frac{1}{2}\\,\\mathbf{u}^{\\top}\\mathbf{H}\\,\\mathbf{u} + \\mathbf{g}^{\\top}\\mathbf{u} + \\text{constant},\n$$\n其中 $\\mathbf{H} \\succ 0$ 且 $\\mathbf{g}$ 取决于 $\\mathbf{M}$、$\\mathbf{T}$、$\\mathbf{t}$、$x_0$ 和参考轨迹。以 $u_{\\min} \\le u_i \\le u_{\\max}$ (对所有 $i$) 的形式陈述边界约束，并指出这将导出一个关于 $\\mathbf{u}$ 的箱式约束二次规划问题。\n\n任务4 (滚动时域更新法则)：将滚动时域法则定义为\n$$\nu_k = (\\mathbf{u}^{\\ast})_0,\n$$\n其中 $\\mathbf{u}^{\\ast}$ 是在时刻 $k$ 求解有限时域二次规划得到的最优输入序列，并且只应用该序列的第一个控制动作。状态使用离散时间模型进行更新，并在下一个时间步使用测量值来重复此过程。\n\n任务5 (实现与测试套件)：实现一个程序，对于下面的每个测试用例，该程序需要构建离散时间模型，为给定的时域和参考轨迹构建压缩二次规划，求解在箱式约束 $u_{\\min} \\le u_i \\le u_{\\max}$ 下的最优输入序列，通过取第一个输入 $u_0$ 来应用滚动时域更新，并计算下一个状态 $x_1$。每个测试用例的输出必须是一个包含两个浮点数 $[u_0, x_1]$ 的列表，其中 $u_0$ 是无量纲的，$x_1$ 的单位是 nM。程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，格式如下\n$$\n\\text{[[}u_0^{(1)},x_1^{(1)}\\text{],[}u_0^{(2)},x_1^{(2)}\\text{],...]},\n$$\n所有数值都表示为十进制数。所有浓度单位都应理解为 nM，时间单位为 s。\n\n使用以下测试套件参数集，这些参数集旨在探查理想路径、饱和边界情况、单步边界情况和高控制努力惩罚情况。在每种情况下，$u_{\\min}$ 和 $u_{\\max}$ 都是无量纲的边界。\n\n- 测试用例1 (理想路径)：\n  - $\\alpha = 0.5$ nM/s 每单位输入, $\\beta = 0.3$ s$^{-1}$, $\\gamma = 0.2$ nM/s, $T_s = 10$ s,\n  - $x_0 = 5.0$ nM, $N = 5$, $q = 1.0$, $r_u = 0.02$, $u_{\\min} = 0.0$, $u_{\\max} = 1.0$, $u_{\\mathrm{ref},i} = 0.5$ 对所有 $i$,\n  - $r = [5.5, 6.0, 6.5, 7.0, 7.5]$ nM.\n\n- 测试用例2 (严格的上界导致饱和)：\n  - $\\alpha = 0.8$ nM/s 每单位输入, $\\beta = 0.2$ s$^{-1}$, $\\gamma = 0.1$ nM/s, $T_s = 10$ s,\n  - $x_0 = 4.0$ nM, $N = 5$, $q = 1.0$, $r_u = 0.05$, $u_{\\min} = 0.0$, $u_{\\max} = 0.2$, $u_{\\mathrm{ref},i} = 0.0$ 对所有 $i$,\n  - $r = [8.0, 8.0, 8.0, 8.0, 8.0]$ nM.\n\n- 测试用例3 (单步时域的边界情况)：\n  - $\\alpha = 0.6$ nM/s 每单位输入, $\\beta = 0.05$ s$^{-1}$, $\\gamma = 0.0$ nM/s, $T_s = 20$ s,\n  - $x_0 = 3.0$ nM, $N = 1$, $q = 1.0$, $r_u = 0.01$, $u_{\\min} = 0.0$, $u_{\\max} = 1.0$, $u_{\\mathrm{ref},0} = 0.0$,\n  - $r = [5.0]$ nM.\n\n- 测试用例4 (对控制努力的高惩罚)：\n  - $\\alpha = 0.5$ nM/s 每单位输入, $\\beta = 0.3$ s$^{-1}$, $\\gamma = 0.2$ nM/s, $T_s = 10$ s,\n  - $x_0 = 6.0$ nM, $N = 5$, $q = 1.0$, $r_u = 1.0$, $u_{\\min} = 0.0$, $u_{\\max} = 1.0$, $u_{\\mathrm{ref},i} = 0.0$ 对所有 $i$,\n  - $r = [7.0, 7.0, 7.0, 7.0, 7.0]$ nM.\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个测试用例按上述顺序报告为 $[u_0,x_1]$。例如，输出必须如下所示：\n$$\n[[u_0^{(1)},x_1^{(1)}],[u_0^{(2)},x_1^{(2)}],[u_0^{(3)},x_1^{(3)}],[u_0^{(4)},x_1^{(4)}]].\n$$",
            "solution": "该问题是有效的，因为它具有科学依据、是适定的且客观的。它提出了一个模型预测控制 (MPC) 理论中的标准问题，并将其应用于基因调控回路的线性模型，这是计算系统生物学中的一个常见应用领域。所有必要的定义、参数和约束都已提供，并且各项任务构成了推导和实现 MPC 控制器的逻辑顺序。\n\n### 任务1：模型推导与线性化\n\n转录因子浓度 $x(t)$ 的连续时间动力学由以下线性常微分方程 (ODE) 给出：\n$$\n\\frac{dx(t)}{dt} = \\alpha\\,u(t) - \\beta\\,x(t) + \\gamma\n$$\n其中 $x(t)$ 是状态，$u(t)$ 是控制输入，$\\alpha, \\beta, \\gamma$ 是常数参数。\n\n**稳态与线性化：**\n稳态 $(x^\\ast, u^\\ast)$ 由条件 $\\frac{dx}{dt} = 0$ 定义。将此代入 ODE 得到：\n$$\n0 = \\alpha\\,u^\\ast - \\beta\\,x^\\ast + \\gamma\n$$\n这定义了稳态输入 $u^\\ast$ 和稳态输出 $x^\\ast$ 之间的线性关系：\n$$\nx^\\ast = \\frac{\\alpha u^\\ast + \\gamma}{\\beta}\n$$\n为了在该稳态点附近对动力学进行线性化，我们定义偏差变量 $\\delta x(t) = x(t) - x^\\ast$ 和 $\\delta u(t) = u(t) - u^\\ast$。偏差状态的导数为 $\\frac{d(\\delta x)}{dt} = \\frac{dx}{dt}$。将 $x(t) = \\delta x(t) + x^\\ast$ 和 $u(t) = \\delta u(t) + u^\\ast$ 代入原始 ODE：\n$$\n\\frac{d(\\delta x)}{dt} = \\alpha(\\delta u(t) + u^\\ast) - \\beta(\\delta x(t) + x^\\ast) + \\gamma\n$$\n$$\n\\frac{d(\\delta x)}{dt} = \\alpha\\,\\delta u(t) - \\beta\\,\\delta x(t) + (\\alpha u^\\ast - \\beta x^\\ast + \\gamma)\n$$\n根据稳态的定义，括号中的项为零。因此，偏差变量下的线性化动力学为：\n$$\n\\frac{d(\\delta x)}{dt} = -\\beta\\,\\delta x(t) + \\alpha\\,\\delta u(t)\n$$\n这是一个形如 $\\dot{\\delta x} = A_{cont} \\delta x + B_{cont} \\delta u$ 的线性系统，其中 $A_{cont} = -\\beta$，$B_{cont} = \\alpha$。\n\n**精确离散化：**\n我们假设在采样周期 $T_s$ 内对输入 $u(t)$ 采用零阶保持器，即对于 $t \\in [kT_s, (k+1)T_s)$，$u(t) = u_k$。\n\n对于**绝对变量**，我们求解仿射 ODE $\\frac{dx}{dt} = -\\beta x(t) + (\\alpha u_k + \\gamma)$，其在区间 $[kT_s, (k+1)T_s]$ 上的初始条件为 $x(kT_s) = x_k$。其解为：\n$$\nx(t) = e^{-\\beta(t-kT_s)} x_k + \\int_{kT_s}^{t} e^{-\\beta(t-\\tau)} (\\alpha u_k + \\gamma) d\\tau\n$$\n令 $t = (k+1)T_s$：\n$$\nx_{k+1} = e^{-\\beta T_s} x_k + (\\alpha u_k + \\gamma) \\int_{kT_s}^{(k+1)T_s} e^{-\\beta((k+1)T_s-\\tau)} d\\tau\n$$\n当 $\\beta \\neq 0$ 时，该积分的计算结果为 $\\frac{1}{\\beta}(1 - e^{-\\beta T_s})$。因此：\n$$\nx_{k+1} = e^{-\\beta T_s} x_k + \\frac{1}{\\beta}(1 - e^{-\\beta T_s})(\\alpha u_k + \\gamma)\n$$\n这可以写成 $x_{k+1} = A\\,x_k + B\\,u_k + c$ 的形式，其中：\n$$\nA = e^{-\\beta T_s}\n$$\n$$\nB = \\frac{\\alpha}{\\beta}(1 - e^{-\\beta T_s})\n$$\n$$\nc = \\frac{\\gamma}{\\beta}(1 - e^{-\\beta T_s})\n$$\n\n对于**偏差变量**，其动力学为 $\\frac{d(\\delta x)}{dt} = -\\beta\\,\\delta x + \\alpha\\,\\delta u$。这是一个标准的线性系统。精确离散化得到 $\\delta x_{k+1} = A_d \\delta x_k + B_d \\delta u_k$。离散时间矩阵由以下公式给出：\n$$\nA_d = e^{A_{cont} T_s} = e^{-\\beta T_s}\n$$\n$$\nB_d = \\int_0^{T_s} e^{A_{cont}\\tau} B_{cont} d\\tau = \\int_0^{T_s} e^{-\\beta\\tau} \\alpha d\\tau = \\alpha \\left[-\\frac{1}{\\beta}e^{-\\beta\\tau}\\right]_0^{T_s} = \\frac{\\alpha}{\\beta}(1 - e^{-\\beta T_s})\n$$\n因此，偏差变量的离散时间模型是 $\\delta x_{k+1} = A\\,\\delta x_k + B\\,\\delta u_k$，其矩阵 $A$ 和 $B$ 与绝对变量模型的矩阵相同，这与预期相符。\n\n### 任务2：有限时域跟踪公式\n\n目标是使状态轨迹 $x_1, \\dots, x_N$ 在一个长度为 $N$ 步的预测时域内跟踪参考轨迹 $r_1, \\dots, r_N$。性能由以下二次成本函数衡量：\n$$\nJ = \\sum_{i=1}^{N} q\\,\\big( x_i - r_i \\big)^2 + \\sum_{i=0}^{N-1} r_u\\,\\big( u_i - u_{\\mathrm{ref},i} \\big)^2\n$$\n此处，$q \\ge 0$ 惩罚状态跟踪误差，$r_u > 0$ 惩罚控制输入 $u_i$ 相对于参考输入 $u_{\\mathrm{ref},i}$ 的偏差。\n控制输入受到严格的物理或操作约束，表示为箱式约束：\n$$\nu_{\\min} \\le u_i \\le u_{\\max} \\quad \\text{for } i = 0, 1, \\dots, N-1\n$$\nMPC 问题在于在每个时间步最小化受这些约束的 $J$。\n\n### 任务3：二次规划 (QP) 推导\n\n为了将优化问题表述为标准的 QP 问题，我们将预测的状态序列 $\\mathbf{x} = [x_1, x_2, \\dots, x_N]^{\\top}$ 表示为初始状态 $x_0$ 和控制输入序列 $\\mathbf{u} = [u_0, u_1, \\dots, u_{N-1}]^{\\top}$ 的仿射函数。\n\n**压缩预测模型：**\n通过递归地应用离散时间模型 $x_{k+1} = Ax_k + Bu_k + c$，我们得到：\n$x_1 = Ax_0 + Bu_0 + c$\n$x_2 = A x_1 + B u_1 + c = A^2 x_0 + AB u_0 + B u_1 + (A+1)c$\n...\n$x_i = A^i x_0 + \\sum_{j=0}^{i-1} A^{i-1-j} B u_j + \\left(\\sum_{j=0}^{i-1} A^j\\right) c$\n\n这可以写成矩阵形式 $\\mathbf{x} = \\mathbf{M}\\,x_0 + \\mathbf{T}\\,\\mathbf{u} + \\mathbf{t}$，其中：\n$$\n\\mathbf{M} = \\begin{bmatrix} A \\\\ A^2 \\\\ \\vdots \\\\ A^N \\end{bmatrix}, \\quad\n\\mathbf{T} = \\begin{bmatrix}\nB  & 0 & \\dots & 0 \\\\\nAB & B & \\dots & 0 \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\nA^{N-1}B & A^{N-2}B & \\dots & B\n\\end{bmatrix}, \\quad\n\\mathbf{t} = \\begin{bmatrix}\nc \\\\\n(A+1)c \\\\\n\\vdots \\\\\n(\\sum_{j=0}^{N-1} A^j)c\n\\end{bmatrix}\n$$\n此处，$\\mathbf{M} \\in \\mathbb{R}^{N \\times 1}$，$\\mathbf{T} \\in \\mathbb{R}^{N \\times N}$ 是一个下三角矩阵，$\\mathbf{t} \\in \\mathbb{R}^{N \\times 1}$。\n\n**QP 公式：**\n成本函数可以写成向量形式：\n$$\nJ(\\mathbf{u}) = (\\mathbf{x} - \\mathbf{r})^{\\top} \\mathbf{Q} (\\mathbf{x} - \\mathbf{r}) + (\\mathbf{u} - \\mathbf{u}_{\\mathrm{ref}})^{\\top} \\mathbf{R} (\\mathbf{u} - \\mathbf{u}_{\\mathrm{ref}})\n$$\n其中 $\\mathbf{r} = [r_1, \\dots, r_N]^{\\top}$，$\\mathbf{u}_{\\mathrm{ref}} = [u_{\\mathrm{ref},0}, \\dots, u_{\\mathrm{ref},N-1}]^{\\top}$，$\\mathbf{Q} = q \\cdot I_{N\\times N}$，以及 $\\mathbf{R} = r_u \\cdot I_{N\\times N}$。\n\n将压缩模型 $\\mathbf{x} = \\mathbf{M}x_0 + \\mathbf{T}\\mathbf{u} + \\mathbf{t}$ 代入 $J$ 中：\n$$\nJ(\\mathbf{u}) = (\\mathbf{M}x_0 + \\mathbf{T}\\mathbf{u} + \\mathbf{t} - \\mathbf{r})^{\\top} \\mathbf{Q} (\\mathbf{M}x_0 + \\mathbf{T}\\mathbf{u} + \\mathbf{t} - \\mathbf{r}) + (\\mathbf{u} - \\mathbf{u}_{\\mathrm{ref}})^{\\top} \\mathbf{R} (\\mathbf{u} - \\mathbf{u}_{\\mathrm{ref}})\n$$\n为了得到标准 QP 形式 $J(\\mathbf{u}) = \\frac{1}{2}\\mathbf{u}^{\\top}\\mathbf{H}\\,\\mathbf{u} + \\mathbf{g}^{\\top}\\mathbf{u} + \\text{constant}$，我们提取关于 $\\mathbf{u}$ 的二次项和线性项：\n二次项：$\\mathbf{u}^{\\top} \\mathbf{T}^{\\top} \\mathbf{Q} \\mathbf{T} \\mathbf{u} + \\mathbf{u}^{\\top} \\mathbf{R} \\mathbf{u} = \\mathbf{u}^{\\top} (\\mathbf{T}^{\\top} \\mathbf{Q} \\mathbf{T} + \\mathbf{R}) \\mathbf{u}$\n线性项：$2(\\mathbf{M}x_0 + \\mathbf{t} - \\mathbf{r})^{\\top} \\mathbf{Q} \\mathbf{T} \\mathbf{u} - 2\\mathbf{u}_{\\mathrm{ref}}^{\\top}\\mathbf{R}\\mathbf{u} = 2[\\mathbf{T}^{\\top}\\mathbf{Q}(\\mathbf{M}x_0 + \\mathbf{t} - \\mathbf{r}) - \\mathbf{R}\\mathbf{u}_{\\mathrm{ref}}]^{\\top} \\mathbf{u}$\n\n与标准形式比较，我们确定海森矩阵 $\\mathbf{H}$ 和梯度向量 $\\mathbf{g}$：\n$$\n\\mathbf{H} = 2(\\mathbf{T}^{\\top} \\mathbf{Q} \\mathbf{T} + \\mathbf{R}) = 2(q \\mathbf{T}^{\\top} \\mathbf{T} + r_u I)\n$$\n$$\n\\mathbf{g} = 2(\\mathbf{T}^{\\top} \\mathbf{Q} (\\mathbf{M}x_0 + \\mathbf{t} - \\mathbf{r}) - \\mathbf{R}\\mathbf{u}_{\\mathrm{ref}}) = 2(q \\mathbf{T}^{\\top} (\\mathbf{M}x_0 + \\mathbf{t} - \\mathbf{r}) - r_u \\mathbf{u}_{\\mathrm{ref}})\n$$\n由于 $r_u > 0$，$\\mathbf{R}$ 是正定的。由于 $q \\ge 0$，$\\mathbf{Q}$ 是半正定的。因此，$\\mathbf{H}$ 是正定的，这保证了 QP 问题有唯一的最小值。\n\n该优化问题是一个箱式约束二次规划：\n$$\n\\min_{\\mathbf{u} \\in \\mathbb{R}^N} \\quad \\frac{1}{2}\\mathbf{u}^{\\top}\\mathbf{H}\\,\\mathbf{u} + \\mathbf{g}^{\\top}\\mathbf{u}\n$$\n$$\n\\text{subject to} \\quad u_{\\min} \\le u_i \\le u_{\\max} \\quad \\text{for } i = 0, \\dots, N-1\n$$\n\n### 任务4：滚动时域更新法则\n\n滚动时域原理决定了每个时间步 $k$ 的控制动作。其步骤如下：\n1.  测量或估计系统的当前状态 $x_k$。\n2.  使用 $x_k$ 作为初始状态 $x_0$，求解任务3中推导的有限时域、箱式约束的 QP 问题。这将得到一个最优控制序列 $\\mathbf{u}^{\\ast} = [u_0^{\\ast}, u_1^{\\ast}, \\dots, u_{N-1}^{\\ast}]^{\\top}$。\n3.  仅将此序列的第一个元素应用于被控系统：$u_k = u_0^{\\ast}$。\n4.  让系统演化一个采样周期 $T_s$。新的状态为 $x_{k+1}$。\n5.  在下一个时间步，$k \\leftarrow k+1$，从步骤1开始重复此过程。这种时域的“滚动”为应对扰动和模型失配提供了反馈和鲁棒性。\n\n### 任务5：实现与测试套件\n\n针对给定测试用例的此 MPC 策略的实现，已在最终答案部分提供。该代码按照上述推导构建模型和 QP 矩阵，使用数值求解器解决优化问题，并计算第一个控制动作和由此产生的状态。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Solves the MPC problem for a single-gene regulatory circuit for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        # Test Case 1 (happy path)\n        {\n            \"params\": {\"alpha\": 0.5, \"beta\": 0.3, \"gamma\": 0.2, \"Ts\": 10.0},\n            \"mpc\": {\"N\": 5, \"q\": 1.0, \"ru\": 0.02, \"umin\": 0.0, \"umax\": 1.0},\n            \"initial\": {\"x0\": 5.0},\n            \"refs\": {\n                \"r\": np.array([5.5, 6.0, 6.5, 7.0, 7.5]),\n                \"u_ref\": np.full(5, 0.5),\n            },\n        },\n        # Test Case 2 (tight upper bound causes saturation)\n        {\n            \"params\": {\"alpha\": 0.8, \"beta\": 0.2, \"gamma\": 0.1, \"Ts\": 10.0},\n            \"mpc\": {\"N\": 5, \"q\": 1.0, \"ru\": 0.05, \"umin\": 0.0, \"umax\": 0.2},\n            \"initial\": {\"x0\": 4.0},\n            \"refs\": {\n                \"r\": np.full(5, 8.0),\n                \"u_ref\": np.full(5, 0.0),\n            },\n        },\n        # Test Case 3 (boundary case with single-step horizon)\n        {\n            \"params\": {\"alpha\": 0.6, \"beta\": 0.05, \"gamma\": 0.0, \"Ts\": 20.0},\n            \"mpc\": {\"N\": 1, \"q\": 1.0, \"ru\": 0.01, \"umin\": 0.0, \"umax\": 1.0},\n            \"initial\": {\"x0\": 3.0},\n            \"refs\": {\n                \"r\": np.array([5.0]),\n                \"u_ref\": np.array([0.0]),\n            },\n        },\n        # Test Case 4 (high penalty on control effort)\n        {\n            \"params\": {\"alpha\": 0.5, \"beta\": 0.3, \"gamma\": 0.2, \"Ts\": 10.0},\n            \"mpc\": {\"N\": 5, \"q\": 1.0, \"ru\": 1.0, \"umin\": 0.0, \"umax\": 1.0},\n            \"initial\": {\"x0\": 6.0},\n            \"refs\": {\n                \"r\": np.full(5, 7.0),\n                \"u_ref\": np.full(5, 0.0),\n            },\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        p = case[\"params\"]\n        m = case[\"mpc\"]\n        i = case[\"initial\"]\n        r = case[\"refs\"]\n\n        alpha, beta, gamma, Ts = p[\"alpha\"], p[\"beta\"], p[\"gamma\"], p[\"Ts\"]\n        N, q, ru, umin, umax = m[\"N\"], m[\"q\"], m[\"ru\"], m[\"umin\"], m[\"umax\"]\n        x0 = i[\"x0\"]\n        r_vec = r[\"r\"]\n        u_ref_vec = r[\"u_ref\"]\n\n        # Task 1: Construct discrete-time model x_k+1 = A*x_k + B*u_k + c\n        if beta == 0.0:\n            A = 1.0\n            B = alpha * Ts\n            c_param = gamma * Ts\n        else:\n            exp_beta_Ts = np.exp(-beta * Ts)\n            A = exp_beta_Ts\n            B = (alpha / beta) * (1 - exp_beta_Ts)\n            c_param = (gamma / beta) * (1 - exp_beta_Ts)\n\n        # Task 3: Construct condensed prediction model and QP formulation\n        # x_vec = M*x0 + T*u_vec + t_vec\n        M = np.array([A ** (i + 1) for i in range(N)])\n\n        T = np.zeros((N, N))\n        for i in range(N):\n            for j in range(i + 1):\n                T[i, j] = (A ** (i - j)) * B\n        \n        if A == 1.0:\n            powers = np.arange(1, N + 1)\n            t_vec = c_param * powers\n        else:\n            powers = np.arange(1, N + 1)\n            t_vec = c_param * (1 - A ** powers) / (1 - A)\n\n        # QP matrices for J(u) = 0.5*u.T*H*u + g.T*u\n        Q_mat = q * np.identity(N)\n        R_mat = ru * np.identity(N)\n        \n        H = 2 * (T.T @ Q_mat @ T + R_mat)\n        \n        error_term = M * x0 + t_vec - r_vec\n        g = 2 * (T.T @ Q_mat @ error_term - R_mat @ u_ref_vec)\n\n        # Define objective function and its gradient (Jacobian) for the solver\n        def objective(u_vec):\n            return 0.5 * u_vec.T @ H @ u_vec + g.T @ u_vec\n\n        def jacobian(u_vec):\n            return H @ u_vec + g\n\n        # Define bounds for the control input sequence\n        bounds = [(umin, umax)] * N\n\n        # Initial guess for the optimizer\n        u_initial_guess = np.clip(u_ref_vec, umin, umax)\n\n        # Solve the box-constrained QP\n        opt_result = minimize(\n            objective,\n            u_initial_guess,\n            method='L-BFGS-B',\n            jac=jacobian,\n            bounds=bounds\n        )\n        \n        u_star_sequence = opt_result.x\n        \n        # Task 4: Apply receding horizon law\n        u0_star = u_star_sequence[0]\n        \n        # Compute the next state\n        x1 = A * x0 + B * u0_star + c_param\n        \n        results.append([u0_star, x1])\n\n    # Format the final output as specified\n    formatted_results = [f\"[{res[0]},{res[1]}]\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n\n```"
        }
    ]
}