{
    "hands_on_practices": [
        {
            "introduction": "理解最小切割集最直接的方法是从基本原理入手，直接分析底层的化学计量方程。本练习将通过一个简单的示例网络，演示如何通过检视流量之间的代数关系，并强制目标流量为零，来识别实现干预目标所必需的反应组合。这种方法为更高级的算法奠定了坚实的直觉基础。",
            "id": "3326074",
            "problem": "考虑一个玩具代谢网络，该网络包含四种不可逆反应 $R_1, R_2, R_3, R_4$，涉及代谢物 $A, B, C$：\n- $R_1:\\ A \\rightarrow B$，\n- $R_2:\\ B \\rightarrow C$，\n- $R_4:\\ A \\rightarrow C$，\n- $R_3:\\ C \\rightarrow \\emptyset$。\n\n假设采用标准的稳态通量平衡设置：化学计量矩阵 $S$ 是针对内源代谢物构建的，通量 $v$ 满足 $S v = 0$ 和 $v \\ge 0$，其中 $v = (v_1, v_2, v_3, v_4)^\\top$，而代谢物 $A$ 是一个不包含在稳态平衡中的外源底物。反应 $R_3$ 是 $C$ 的一个消耗（需求）反应。目标函数是维持通过 $R_3$ 的通量 $v_3 \\ge 1$ 的能力。\n\n最小割集被定义为一个最小的反应集合，其同时失活会迫使所有满足 $v \\ge 0$ 的可行稳态通量向量的 $v_3 = 0$。仅使用稳态质量平衡 $S v = 0$、不可逆非负性 $v \\ge 0$ 的基本定义以及给定的网络拓扑，从第一性原理出发，推导出所有能阻断目标 $v_3 \\ge 1$ 的最小割集。\n\n请报告禁用目标反应 $R_3$ 的最小割集的总数作为您的最终答案。请以精确整数形式提供该数字。不需要四舍五入，也不涉及物理单位。",
            "solution": "我们从通量平衡分析中的稳态质量平衡和不可逆性约束开始。令 $v = (v_1, v_2, v_3, v_4)^\\top$ 分别表示反应 $R_1, R_2, R_3, R_4$ 的反应通量。代谢物 $A$ 是外源的，因此不包含在稳态质量平衡中。内源代谢物是 $B$ 和 $C$。构建化学计量矩阵 $S$，其行对应于 $B$ 和 $C$，列对应于 $R_1, R_2, R_3, R_4$。\n\n根据反应定义：\n- 对于代谢物 $B$，$R_1$ 产生 $B$，$R_2$ 消耗 $B$。因此，$B$ 所在行的条目对于 $R_1$ 是 $+1$，对于 $R_2$ 是 $-1$，对于 $R_3$ 和 $R_4$ 是 $0$。\n- 对于代谢物 $C$，$R_2$ 产生 $C$，$R_4$ 产生 $C$，$R_3$ 消耗 $C$。因此，$C$ 所在行的条目对于 $R_1$ 是 $0$，对于 $R_2$ 是 $+1$，对于 $R_3$ 是 $-1$，对于 $R_4$ 是 $+1$。\n\n因此，\n\n$$\nS \\;=\\;\n\\begin{pmatrix}\n1  -1  0  0 \\\\\n0  1  -1  1\n\\end{pmatrix},\n\\qquad\nv \\;=\\; \\begin{pmatrix} v_1 \\\\ v_2 \\\\ v_3 \\\\ v_4 \\end{pmatrix},\n\\qquad\nv \\ge 0.\n$$\n\n\n稳态条件 $S v = 0$ 产生以下线性约束\n\n$$\n\\text{(B 平衡)}\\quad v_1 - v_2 = 0 \\;\\Rightarrow\\; v_1 = v_2,\n$$\n\n\n$$\n\\text{(C 平衡)}\\quad v_2 - v_3 + v_4 = 0 \\;\\Rightarrow\\; v_3 = v_2 + v_4.\n$$\n\n在 $v \\ge 0$ 的条件下，目标条件 $v_3 \\ge 1$ 要求 $v_2$ 或 $v_4$ 中至少有一个是严格为正的，并进行缩放以使 $v_3$ 达到至少 $1$。最小割集是一个最小的反应集合，移除该集合中的反应会迫使所有可行通量 $v$ 的 $v_3 = 0$，从而阻断任何 $v_3 \\ge 1$ 的情况。\n\n我们在 $S v = 0, v \\ge 0$ 的条件下，找出所有使 $v_3 = v_2 + v_4 = 0$ 不可避免的方法：\n\n1. 直接敲除 $R_3$ 会迫使 $v_3 = 0$。因此，单元素集合 $\\{R_3\\}$ 是一个割集。它是最小的，因为移除 $\\{R_3\\}$ 的任何真子集都无法达到相同的效果。\n\n2. 要在不移除 $R_3$ 本身的情况下迫使 $v_3 = v_2 + v_4 = 0$，必须迫使 $v_2 = 0$ 和 $v_4 = 0$。\n   - 通过移除 $R_4$ 来迫使 $v_4 = 0$。\n   - 可以通过直接移除 $R_2$ 或移除其唯一的前体 $R_1$ 来迫使 $v_2 = 0$，因为 $v_1 = v_2$ 意味着移除 $R_1$ 会迫使 $v_1 = 0$，从而 $v_2 = 0$。\n\n   这产生了两个不同的最小反应对：\n   - $\\{R_2, R_4\\}$：移除 $R_2$ 迫使 $v_2 = 0$，移除 $R_4$ 迫使 $v_4 = 0$，因此 $v_3 = 0$。单独移除 $\\{R_2\\}$ 或 $\\{R_4\\}$ 都不能阻断 $v_3$，所以这个反应对是最小的。\n   - $\\{R_1, R_4\\}$：移除 $R_1$ 迫使 $v_1 = v_2 = 0$，移除 $R_4$ 迫使 $v_4 = 0$，因此 $v_3 = 0$。单独移除 $\\{R_1\\}$ 或 $\\{R_4\\}$ 都不能阻断 $v_3$，所以这个反应对是最小的。\n\n我们验证不存在其他最小割集：\n- 任何真包含 $R_3$ 的集合，例如 $\\{R_1, R_3\\}$，都不是最小的，因为仅 $\\{R_3\\}$ 就足够了。\n- 反应对 $\\{R_1, R_2\\}$ 不能阻断 $v_3$，因为 $v_4$ 可以直接供应 $C$，使得 $v_3 = v_4  0$。\n- 根据定义，不包含任何一个已识别的最小割集的更大集合不是最小的。\n\n这一结果也可以通过分析初等流模式（EFM）来证实。能够产生目标通量（$v_3>0$）的基本路径有两个，其支持集分别为 $\\{R_1, R_2, R_3\\}$ 和 $\\{R_3, R_4\\}$。最小割集是这两个支持集的最小命中集，即 $\\{R_3\\}$、$\\{R_1, R_4\\}$ 和 $\\{R_2, R_4\\}$。\n\n因此，禁用目标反应 $R_3$ 的最小割集总数为 $3$。",
            "answer": "$$\\boxed{3}$$"
        },
        {
            "introduction": "在从基本原理推导之后，我们可以进入一个更抽象但功能更强大的层次。任何可行的稳态流量分布都可以被视为基本通路（即基本通量模式，EFMs）的非负线性组合。因此，要阻断一个目标反应，我们只需“击中”（即禁用）每一个能够产生该目标的EFM即可。 这个练习将介绍这种强大的对偶性，并引入最小“击中集”这一核心概念，它是计算最小切割集的基石。",
            "id": "3326054",
            "problem": "考虑一个小型稳态代谢网络，其中包含内部代谢物 $B$ 和 $C$ 以及四个不可逆反应 $R_1$, $R_2$, $R_3$ 和 $R_4$。设化学计量矩阵 $S \\in \\mathbb{R}^{2 \\times 4}$ 按代谢物 $[B,\\,C]^{\\top}$ 和反应 $[R_1,\\,R_2,\\,R_3,\\,R_4]$ 的顺序列出，其元素为\n$$\nS \\;=\\; \\begin{pmatrix}\n+1  -1  0  0 \\\\\n0  +1  -1  +1\n\\end{pmatrix}.\n$$\n所有反应都是不可逆的，通量界限为 $v_i \\ge 0$，其中 $i \\in \\{1,2,3,4\\}$。在稳态下，通量向量 $v \\in \\mathbb{R}^4$ 必须满足 $S\\,v = 0$。关注的目标是反应 $R_3$ 有一个严格为正的通量，即目标条件为 $v_3 \\ge 1$（由于可行稳态通量的正向缩放，这不失一般性）。\n\n基本通量模式 (EFMs) 定义为具有最小支撑集且满足 $S\\,v=0$ 和 $v \\ge 0$ 的非零稳态通量向量。假设已确定能够实现目标反应 $R_3$ 的 EFM 集合，该集合恰好由两个支撑集 $E_1 = \\{R_1, R_2, R_3\\}$ 和 $E_2 = \\{R_4, R_3\\}$ 组成，这意味着存在其非零反应集恰好为 $E_1$ 和 $E_2$ 的 EFM。\n\n一种干预策略被建模为敲除一部分反应。针对该目标的最小割集 (MCS) 是一个允许干预集 $K$ 的子集 $C$，使得在移除 $C$ 中所有反应后，不存在满足 $v_3 \\ge 1$ 的可行稳态通量，并且 $C$ 的任何真子集都不具有此性质。对于此问题，允许的干预集排除了目标反应，由 $K = \\{R_1, R_2, R_4\\}$ 给出。\n\n你的任务是：\n- 仅使用命中集的定义和给定的 EFM $E_1$ 和 $E_2$，枚举所有与每个实现目标的 EFM 相交的、包含关系上的最小命中集 $C \\subseteq K$。\n- 对于每个候选集 $C$，通过求解移除 $C$ 中反应后得到的残余网络的可行性问题来验证其是否为 MCS：确定是否存在 $v \\ge 0$ 满足 $S\\,v = 0$ 和 $v_3 \\ge 1$。同时，通过证明 $C$ 的每个真子集都无法阻断目标来验证其最小性，即当移除较少反应时，存在一个可行的 $v \\ge 0$ 满足 $S\\,v=0$ 和 $v_3 \\ge 1$。\n- 令 $N$ 表示你已验证的最小割集的数量。报告 $N$ 的值。\n\n请以单个实数的形式提供你的最终答案。不需要单位。如果你得到一个非整数实数，请将答案四舍五入到 $4$ 位有效数字。否则，请报告确切的整数。",
            "solution": "问题要求我们找到给定代谢目标的最小割集数量 ($N$)。目标是维持通过反应 $R_3$ 的通量至少为 $1$，即 $v_3 \\ge 1$。最小割集 (MCS) 是从允许集 $K=\\{R_1, R_2, R_4\\}$ 中选出的一个最小反应敲除集，它使得目标无法实现。\n\n代谢途径分析的一个基本原理指出，任何可行的稳态通量分布都可以表示为网络 EFM 的非负线性组合。问题指出，唯一能够产生目标（即通过 $R_3$ 的通量非零）的 EFM 是那些支撑集为 $E_1 = \\{R_1, R_2, R_3\\}$ 和 $E_2 = \\{R_4, R_3\\}$ 的 EFM。要阻断目标，必须且只需使所有这些产生目标的 EFM 失活。如果一个 EFM 的至少一个组成反应被敲除，那么该 EFM 就失活了。\n\n因此，一个 MCS 对应于 $K$ 的一个包含关系上的最小子集，该子集与每个产生目标的 EFM 都有非空交集。换句话说，一个 MCS 是产生目标的 EFM 的最小命中集，且限于 $K$ 中可敲除的反应。\n\n**第 1 步：枚举最小命中集**\n\n产生目标的 EFM 集合由其支撑集给出，$\\mathcal{E} = \\{E_1, E_2\\}$，其中 $E_1 = \\{R_1, R_2, R_3\\}$ 和 $E_2 = \\{R_4, R_3\\}$。允许的干预反应集合是 $K = \\{R_1, R_2, R_4\\}$。\n\n一个割集 $C \\subseteq K$ 必须“命中”$E_1$ 和 $E_2$。这意味着 $C \\cap E_1 \\neq \\emptyset$ 且 $C \\cap E_2 \\neq \\emptyset$。由于 $C$ 必须是 $K$ 的子集，我们只关心 EFM 中可被敲除的部分：\n$E'_1 = E_1 \\cap K = \\{R_1, R_2, R_3\\} \\cap \\{R_1, R_2, R_4\\} = \\{R_1, R_2\\}$\n$E'_2 = E_2 \\cap K = \\{R_4, R_3\\} \\cap \\{R_1, R_2, R_4\\} = \\{R_4\\}$\n\n我们需要找到集合族 $\\mathcal{F} = \\{E'_1, E'_2\\} = \\{\\{R_1, R_2\\}, \\{R_4\\}\\}$ 的最小命中集。一个命中集必须包含 $\\mathcal{F}$ 中每个集合的至少一个元素。\n\\begin{itemize}\n    \\item 要命中 $\\{R_4\\}$，一个集合必须包含 $R_4$。\n    \\item 要命中 $\\{R_1, R_2\\}$，一个集合必须包含 $R_1$ 或 $R_2$。\n\\end{itemize}\n结合这些条件，一个命中集必须包含 $\\{R_4\\}$ 以及 $\\{R_1\\}$ 或 $\\{R_2\\}$ 中的一个。这产生了两个候选集：\n\\begin{enumerate}\n    \\item $C_1 = \\{R_1, R_4\\}$\n    \\item $C_2 = \\{R_2, R_4\\}$\n\\end{enumerate}\n这些集合是最小的，因为从任一集合中移除任何单个反应都会导致该集合不再同时命中 $E'_1$ 和 $E'_2$。例如，对于 $C_1$，子集 $\\{R_1\\}$ 没有命中 $E'_2$，而子集 $\\{R_4\\}$ 没有命中 $E'_1$。类似的论证也适用于 $C_2$。因此，这些就是最小命中集。\n\n**第 2 步：验证候选集为最小割集**\n\n问题要求明确验证每个候选集都是一个 MCS。这涉及到为残余网络求解一个可行性问题。控制方程是稳态条件 $S v = 0$ 和非负约束 $v_i \\ge 0$。\n化学计量方程为：\n$v_1 - v_2 = 0 \\implies v_1 = v_2$\n$v_2 - v_3 + v_4 = 0 \\implies v_3 = v_2 + v_4$\n\n目标条件是 $v_3 \\ge 1$。\n\n**验证 $C_1 = \\{R_1, R_4\\}$**\n\n\\begin{itemize}\n    \\item **阻断能力**：我们测试当反应 $R_1$ 和 $R_4$ 被敲除（即 $v_1=0$ 和 $v_4=0$）时，目标是否能实现。\n    将这些代入稳态方程：\n    $0 - v_2 = 0 \\implies v_2 = 0$\n    $v_2 - v_3 + 0 = 0 \\implies v_3 = v_2$\n    结合这些，我们得到 $v_3 = 0$。这个结果与目标条件 $v_3 \\ge 1$ 相矛盾。因此，不存在可行的通量，$C_1$ 成功地阻断了目标。\n\n    \\item **最小性**：我们必须证明 $C_1$ 的任何真子集都不能阻断目标。\n    \\begin{itemize}\n        \\item 子集 $\\{R_1\\}$：敲除 $R_1$ ($v_1=0$)。系统变为：\n        $0 - v_2 = 0 \\implies v_2=0$\n        $0 - v_3 + v_4 = 0 \\implies v_3=v_4$\n        我们需要找到是否存在一个向量 $v$ 满足这些条件、$v \\ge 0$ 且 $v_3 \\ge 1$。让我们设 $v_3=1$。这意味着 $v_4=1$。通量向量 $v = [0, 0, 1, 1]^\\top$ 是一个在 $v_1=0$ 条件下的有效稳态通量分布。由于 $v_3 = 1 \\ge 1$，目标是可以实现的。因此，$\\{R_1\\}$ 不是一个割集。\n\n        \\item 子集 $\\{R_4\\}$：敲除 $R_4$ ($v_4=0$)。系统变为：\n        $v_1 - v_2 = 0 \\implies v_1=v_2$\n        $v_2 - v_3 + 0 = 0 \\implies v_3=v_2$\n        我们需要找到是否存在一个向量 $v$ 满足这些条件、$v \\ge 0$ 且 $v_3 \\ge 1$。让我们设 $v_3=1$。这意味着 $v_2=1$ 和 $v_1=1$。通量向量 $v = [1, 1, 1, 0]^\\top$ 是一个在 $v_4=0$ 条件下的有效稳态通量分布。由于 $v_3 = 1 \\ge 1$，目标是可以实现的。因此，$\\{R_4\\}$ 不是一个割集。\n    \\end{itemize}\n    由于 $C_1$ 阻断了目标且其任何真子集都不能，所以 $C_1 = \\{R_1, R_4\\}$ 是一个经过验证的 MCS。\n\\end{itemize}\n\n**验证 $C_2 = \\{R_2, R_4\\}$**\n\n\\begin{itemize}\n    \\item **阻断能力**：我们测试当反应 $R_2$ 和 $R_4$ 被敲除（即 $v_2=0$ 和 $v_4=0$）时，目标是否能实现。\n    代入稳态方程：\n    $v_1 - 0 = 0 \\implies v_1 = 0$\n    $0 - v_3 + 0 = 0 \\implies v_3 = 0$\n    结果 $v_3=0$ 与目标条件 $v_3 \\ge 1$ 相矛盾。因此，$C_2$ 成功地阻断了目标。\n\n    \\item **最小性**：我们检查 $C_2$ 的真子集。\n    \\begin{itemize}\n        \\item 子集 $\\{R_2\\}$：敲除 $R_2$ ($v_2=0$)。系统变为：\n        $v_1 - 0 = 0 \\implies v_1=0$\n        $0 - v_3 + v_4 = 0 \\implies v_3=v_4$\n        与之前的子集 $\\{R_1\\}$ 一样，我们可以找到一个实现目标的可行通量向量，例如 $v=[0, 0, 1, 1]^\\top$。因此，$\\{R_2\\}$ 不是一个割集。\n\n        \\item 子集 $\\{R_4\\}$：敲除 $R_4$ ($v_4=0$)。这种情况与为 $C_1$ 分析的情况相同。一个可行的通量向量 $v=[1, 1, 1, 0]^\\top$ 可以实现目标。因此，$\\{R_4\\}$ 不是一个割集。\n    \\end{itemize}\n    由于 $C_2$ 阻断了目标且其任何真子集都不能，所以 $C_2 = \\{R_2, R_4\\}$ 也是一个经过验证的 MCS。\n\\end{itemize}\n\n**结论**\n\n通过找到目标 EFM 的最小命中集，我们确定了两个候选集：$C_1 = \\{R_1, R_4\\}$ 和 $C_2 = \\{R_2, R_4\\}$。我们已经严格验证了这两个候选集都满足最小割集的定义：它们都能阻断目标反应，而它们的任何子集都不能。\n\n因此，最小割集的总数为 $N=2$。",
            "answer": "$$\\boxed{2}$$"
        },
        {
            "introduction": "从理论分析转向大规模计算是计算系统生物学的核心。对于真实的基因组尺度网络，手动枚举EFMs或切割集是不现实的。因此，寻找最小切割集的问题通常被构建为一个优化问题，典型地是混合整数线性规划（MILP）。 本练习将引导你理解如何将寻找最小干预策略的问题形式化为一个可以通过计算求解的优化模型，从而连接理论与实际应用。",
            "id": "3326084",
            "problem": "您的任务是使用混合整数线性规划（MILP）为代谢网络严格制定一个基于优化的干预策略，然后对指定测试用例的最小割集进行计算验证。目标是找到一个基数最小的反应敲除集，该反应敲除集能在指定阈值或更高水平上阻断目标通量。您的程序必须生成单行输出，其中包含针对一系列测试网络的计算出的最小割集。\n\n考虑一个由化学计量矩阵 $S \\in \\mathbb{R}^{m \\times n}$、通量向量 $v \\in \\mathbb{R}^{n}$、下界 $L \\in \\mathbb{R}^{n}$、上界 $U \\in \\mathbb{R}^{n}$ 和目标反应指数 $t \\in \\{0,1,\\dots,n-1\\}$ 定义的代谢网络。反应 $i$ 的敲除由一个二元变量 $y_i \\in \\{0,1\\}$ 表示，其中 $y_i = 1$ 强制 $v_i = 0$，而 $y_i = 0$ 允许 $v_i$ 在其界限内。稳态质量平衡由 $S v = 0$ 表示。对于具有非负下界的不可逆反应，敲除下的可用性约束可通过对所有 $i \\in \\{0,1,\\dots,n-1\\}$ 设置 $v_i \\le U_i(1 - y_i)$ 和 $v_i \\ge L_i(1 - y_i)$ 来施加。目标可行性要求是对于指定的阈值 $\\tau \\in \\mathbb{R}_{\\ge 0}$，满足 $v_t \\ge \\tau$。\n\n您的推导必须从基本的稳态约束 $S v = 0$ 和边界约束 $L \\le v \\le U$ 开始，为内部目标达成问题构建一个双层线性规划（LP），然后使用强对偶性或法卡斯引理构建一个单层 MILP。具体来说，您需要构建一个双层问题，该问题最小化敲除的基数，并受制于一个试图实现 $v_t \\ge \\tau$ 的内部 LP，然后通过用其对偶约束替换内部 LP 并进行适当的线性化来处理与二元变量的乘积，从而推导出一个单层 MILP。\n\n您的最终程序必须在给定特定测试套件实例的情况下，计算一个最小基数割集 $C \\subseteq \\mathcal{R}_{\\text{allowed}}$，该割集在 $S v = 0$ 和 $L \\le v \\le U$ 的条件下阻断 $v_t \\ge \\tau$ 的可行性，其中 $\\mathcal{R}_{\\text{allowed}}$ 是符合敲除条件的反应集合。对于每个测试用例，您必须返回字典序最小的最小基数割集，形式为一个从零开始的反应指数列表。如果在没有任何敲除的情况下，目标可行性 $v_t \\ge \\tau$ 已经不可能实现，则返回空列表 $[\\ ]$。\n\n测试套件：\n- 案例 1（具有两条平行路径和非平凡最小割集的理想情况）：\n  - 化学计量矩阵 $S_1 = \\begin{bmatrix} 1  -1  0  -1  0 \\\\ 0  1  -1  0  0 \\\\ 0  0  1  1  -1 \\end{bmatrix}$。\n  - 下界 $L_1 = [0, 0, 0, 0, 0]$。\n  - 上界 $U_1 = [10, 10, 10, 10, 100]$。\n  - 目标指数 $t_1 = 4$。\n  - 阈值 $\\tau_1 = 5$。\n  - 允许的干预 $\\mathcal{R}_{\\text{allowed},1} = \\{1, 2, 3\\}$。\n- 案例 2（即使没有干预，目标阈值也无法达到的边界条件）：\n  - 化学计量矩阵 $S_2 = S_1$。\n  - 下界 $L_2 = L_1$。\n  - 上界 $U_2 = [3, 10, 10, 10, 100]$。\n  - 目标指数 $t_2 = 4$。\n  - 阈值 $\\tau_2 = 5$。\n  - 允许的干预 $\\mathcal{R}_{\\text{allowed},2} = \\{1, 2, 3\\}$。\n- 案例 3（单次敲除即可满足条件的单路径网络）：\n  - 化学计量矩阵 $S_3 = \\begin{bmatrix} 1  -1  0 \\\\ 0  1  -1 \\end{bmatrix}$。\n  - 下界 $L_3 = [0, 0, 0]$。\n  - 上界 $U_3 = [10, 10, 100]$。\n  - 目标指数 $t_3 = 2$。\n  - 阈值 $\\tau_3 = 6$。\n  - 允许的干预 $\\mathcal{R}_{\\text{allowed},3} = \\{1\\}$。\n\n所需输出：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个结果是对应测试用例的字典序最小的最小基数割集列表。例如，如果最小割集是 $[1,3]$、$[\\ ]$ 和 $[1]$，则输出必须是单行 $[[1,3],[],[1]]$。\n\n假设与约束：\n- 测试套件中的所有反应都是不可逆的，且具有非负下界，因此对所有 $i$ 都有 $L_i \\ge 0$。\n- 反应指数是从零开始的。\n- 通量不需要物理单位；将所有通量界限和阈值视为无量纲实数。\n- 实现必须通过求解一个零目标 LP 来计算每个敲除子集的 $v_t \\ge \\tau$ 的可行性，该 LP 的约束条件为 $S v = 0$、$L \\le v \\le U$、对被敲除的 $i$ 有 $v_i = 0$ 以及 $v_t \\ge \\tau$；然后通过增加子集大小来搜索最小基数阻塞集。为提高性能，请将搜索限制在每个案例指定的 $\\mathcal{R}_{\\text{allowed}}$ 内。",
            "solution": "该问题要求制定一个优化策略，以确定一个最小的反应敲除集，使得代谢网络无法达到目标通量，然后通过计算实现来解决特定的测试用例。在进行计算方法之前，我们首先严格推导其控制数学框架。\n\n### I. 问题构建：双层优化\n\n该问题的核心是找到一个基数最小的干预集（反应敲除），以保证代谢目标的失败。这天然地可以构建为一个双层优化问题。\n\n设代谢网络由一个化学计量矩阵 $S \\in \\mathbb{R}^{m \\times n}$ 定义，其中 $m$ 是代谢物数量，$n$ 是反应数量。向量 $v \\in \\mathbb{R}^{n}$ 表示通过这些反应的通量。在稳态下，质量平衡方程为：\n$$S v = 0$$\n通量受下界 $L \\in \\mathbb{R}^{n}$ 和上界 $U \\in \\mathbb{R}^{n}$ 的约束：\n$$L \\le v \\le U$$\n对反应 $i$ 的干预由一个二元变量 $y_i \\in \\{0, 1\\}$ 建模。若 $y_i=1$，反应 $i$ 被敲除，其通量 $v_i$ 被强制为 $0$。若 $y_i=0$，反应在其原始界限内运行。对于 $L_i \\ge 0$ 的不可逆反应，这可以通过修改界限来体现：\n$$L_i(1-y_i) \\le v_i \\le U_i(1-y_i)$$\n问题的目标是使得通过反应 $t$ 的通量 $v_t$ 所代表的目标产物，在达到或超过阈值 $\\tau \\ge 0$ 时变得不可行。也就是说，我们寻求一个干预向量 $y$，使得约束系统：\n$$S v = 0$$\n$$L_i(1-y_i) \\le v_i \\le U_i(1-y_i) \\quad \\forall i \\in \\{0, \\dots, n-1\\}$$\n$$v_t \\ge \\tau$$\n对于 $v$ 没有解。\n\n**外层问题**旨在最小化敲除数量，且敲除仅限于允许的反应集 $\\mathcal{R}_{\\text{allowed}}$。目标函数为 $\\sum_{i \\in \\mathcal{R}_{\\text{allowed}}} y_i$。\n\n**内层问题**检查对于给定的 $y$，目标是否可以实现。一种常见的形式化方法是最大化目标通量 $v_t$，并检查其最大可能值 $v_t^*(y)$ 是否小于 $\\tau$。\n$$v_t^*(y) = \\max_{v} \\quad v_t$$\n受制于：\n$$S v = 0$$\n$$L_i(1-y_i) \\le v_i \\le U_i(1-y_i) \\quad \\forall i$$\n\n因此，完整的双层优化模型为：\n$$\\min_{y} \\quad \\sum_{i \\in \\mathcal{R}_{\\text{allowed}}} y_i$$\n受制于：\n$$v_t^*(y)  \\tau$$\n$$y_i \\in \\{0, 1\\} \\quad \\forall i \\in \\mathcal{R}_{\\text{allowed}}$$\n$$y_i = 0 \\quad \\forall i \\notin \\mathcal{R}_{\\text{allowed}}$$\n\n### II. 使用对偶性的单层 MILP 重构\n\n双层结构在计算上是难以处理的。我们可以利用对偶性原理，特别是法卡斯引理，将其重构成一个单层混合整数线性规划（MILP）。\n\n一组线性约束 $Ax \\le b$ 是不可行的，当且仅当存在一个向量 $z \\ge 0$ 使得 $z^T A = 0$ 和 $z^T b  0$。向量 $z$ 被称为不可行性的法卡斯证书。\n\n我们将此应用于我们希望对任何 $v$ 的选择都使其不可行的约束系统：\n1. $S v = 0$ (等价于 $S v \\le 0$ 和 $-S v \\le 0$)\n2. $v \\le U(1-y)$\n3. $-v \\le -L(1-y)$\n4. $v_t \\ge \\tau$ (等价于 $-e_t^T v \\le -\\tau$，其中 $e_t$ 是在索引 $t$ 处为 1 的标准基向量)\n\n我们引入对偶变量（法卡斯证书 $z$ 的分量）：\n- $\\lambda_1 \\ge 0$ 对应 $S v \\le 0$\n- $\\lambda_2 \\ge 0$ 对应 $-S v \\le 0$\n- $\\mu_i \\ge 0$ 对应 $v_i \\le U_i(1-y_i)$\n- $\\nu_i \\ge 0$ 对应 $-v_i \\le -L_i(1-y_i)$\n- $\\gamma \\ge 0$ 对应 $-v_t \\le -\\tau$\n\n条件 $z^T A = 0$ 转化为对偶约束。对于每个原始变量 $v_j$，约束中系数的加权和（权重为对偶变量）必须为零：\n$$(S^T)_j \\lambda_1 - (S^T)_j \\lambda_2 + \\mu_j - \\nu_j - \\gamma (e_t)_j = 0 \\quad \\forall j \\in \\{0, \\dots, n-1\\}$$\n令 $\\lambda = \\lambda_1 - \\lambda_2$（现在是自由变量），上式简化为：\n$$S^T \\lambda + \\mu - \\nu - \\gamma e_t = 0$$\n\n条件 $z^T b  0$ 转化为：\n$$\\sum_i \\mu_i U_i (1-y_i) - \\sum_i \\nu_i L_i (1-y_i) - \\gamma \\tau  0$$\n这是一个严格不等式，在求解器中通常通过引入一个小的正常数 $\\epsilon$ 来实现：\n$$\\sum_i \\mu_i U_i (1-y_i) - \\sum_i \\nu_i L_i (1-y_i) - \\gamma \\tau \\le -\\epsilon$$\n\n这个不等式包含形如 $\\mu_i y_i$ 和 $\\nu_i y_i$ 的双线性项。这些项必须被线性化。对于像 $w_i = \\mu_i y_i$ 这样的项，其中 $\\mu_i \\ge 0$ 且 $y_i \\in \\{0,1\\}$，我们可以用一个新变量 $w_i$ 替换它，并使用一个足够大的常数 $M$ 添加以下线性约束：\n$$w_i \\le M y_i$$\n$$w_i \\le \\mu_i$$\n$$w_i \\ge \\mu_i - M(1 - y_i)$$\n$$w_i \\ge 0$$\n对于涉及 $\\nu_i$ 的乘积也添加类似的约束。\n\n完整的单层 MILP 是找到一组干预 $y$ 和一个对应的法卡斯证书 $(\\lambda, \\mu, \\nu, \\gamma)$，在最小化 $y$ 的基数的同时满足这些约束。\n\n### III. 通过组合搜索的算法实现\n\n虽然 MILP 公式是通用且强大的，但问题陈述指导实现遵循一种特定的、更直接的组合搜索策略来处理给定的这些小规模测试用例。该方法按大小递增的顺序遍历所有可能的敲除集。\n\n算法流程如下：\n1.  初始化敲除集大小 $k=0$。\n2.  从允许的集合 $\\mathcal{R}_{\\text{allowed}}$ 中生成所有大小为 $k$ 的唯一反应组合 $C$。\n3.  组合自然地按字典序生成，这满足了平局决胜的要求。\n4.  对于每个组合 $C$：\n    a.  构建一个线性规划（LP）来测试目标通量是否仍然可以实现。这是一个可行性问题：找到 $v$ 使得\n        -   $S v = 0$\n        -   $L_i \\le v_i \\le U_i$ 对于 $i \\notin C$\n        -   $v_i = 0$ 对于 $i \\in C$\n        -   $v_t \\ge \\tau$\n    b.  求解此 LP。我们可以使用一个零目标函数，因为我们只关心可行性。\n    c.  如果发现 LP **不可行**，这意味着集合 $C$ 是一个有效的割集。由于我们从 $k=0$ 开始迭代，并按字典序处理子集，这个 $C$ 就是字典序最小的最小基数割集。搜索终止并返回 $C$。\n5.  如果测试了所有大小为 $k$ 的组合，并且发现它们都不是阻塞集（即 LP 可行），则将 $k$ 增加到 $k+1$ 并从第 2 步重复。\n6.  该过程从 $k=0$ 开始，测试空集 $C=[]$。如果即使没有任何敲除，目标也无法实现，则初始 LP 将是不可行的，空集将作为结果被正确返回。\n\n此过程保证能找到所需的最小割集。在实现中，我们使用 `scipy.optimize.linprog` 来解决可行性 LP。此求解器返回的不可行状态表示已识别出有效的割集。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\nimport itertools\n\ndef find_minimal_cut_set(S, L, U, t, tau, R_allowed):\n    \"\"\"\n    Finds the lexicographically smallest minimum-cardinality cut set.\n\n    This function iterates through knockout set sizes k = 0, 1, 2, ...\n    For each size, it checks all combinations of reactions from R_allowed.\n    For each combination (cut_set), it solves a feasibility LP to check\n    if the target flux is blocked. The first cut set found is guaranteed\n    to be minimal in cardinality and lexicographically first.\n    \"\"\"\n    S = np.array(S, dtype=float)\n    L = np.array(L, dtype=float)\n    U = np.array(U, dtype=float)\n    num_reactions = S.shape[1]\n\n    # Objective function is zero, we only care about feasibility.\n    c = np.zeros(num_reactions)\n\n    # Equality constraints S*v = 0\n    A_eq = S\n    b_eq = np.zeros(S.shape[0])\n\n    R_allowed = sorted(list(R_allowed))\n\n    for k in range(len(R_allowed) + 1):\n        for cut_set in itertools.combinations(R_allowed, k):\n            # Create bounds for the current LP\n            # Default bounds are (L_i, U_i)\n            current_bounds = list(zip(L, U))\n\n            # Apply target constraint: v_t >= tau\n            # This means the lower bound of v_t is max(L_t, tau)\n            current_bounds[t] = (max(L[t], tau), U[t])\n            \n            # Apply knockouts: v_i = 0 for i in cut_set\n            for i in cut_set:\n                current_bounds[i] = (0.0, 0.0)\n            \n            # Solve the feasibility LP\n            # method 'highs' is robust and is the default in recent SciPy\n            res = linprog(c, A_eq=A_eq, b_eq=b_eq, bounds=current_bounds, method='highs')\n            \n            # linprog status 2 means the problem is infeasible.\n            # This means the cut_set is effective in blocking the target flux.\n            if res.status == 2:\n                return list(cut_set)\n    \n    # This part should not be reached if a solution always exists\n    return None\n\ndef solve():\n    \"\"\"\n    Defines and runs the test suite for finding minimal cut sets.\n    \"\"\"\n    test_cases = [\n        {\n            \"S\": [[1, -1, 0, -1, 0], \n                  [0, 1, -1, 0, 0], \n                  [0, 0, 1, 1, -1]],\n            \"L\": [0, 0, 0, 0, 0],\n            \"U\": [10, 10, 10, 10, 100],\n            \"t\": 4,\n            \"tau\": 5,\n            \"R_allowed\": {1, 2, 3}\n        },\n        {\n            \"S\": [[1, -1, 0, -1, 0], \n                  [0, 1, -1, 0, 0], \n                  [0, 0, 1, 1, -1]],\n            \"L\": [0, 0, 0, 0, 0],\n            \"U\": [3, 10, 10, 10, 100],\n            \"t\": 4,\n            \"tau\": 5,\n            \"R_allowed\": {1, 2, 3}\n        },\n        {\n            \"S\": [[1, -1, 0], \n                  [0, 1, -1]],\n            \"L\": [0, 0, 0],\n            \"U\": [10, 10, 100],\n            \"t\": 2,\n            \"tau\": 6,\n            \"R_allowed\": {1}\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = find_minimal_cut_set(\n            case[\"S\"], case[\"L\"], case[\"U\"], case[\"t\"], case[\"tau\"], case[\"R_allowed\"]\n        )\n        results.append(result)\n\n    # Format the output string to be exactly as specified, e.g., [[1,3],[],[1]]\n    output_parts = [str(res).replace(\" \", \"\") for res in results]\n    final_output = f\"[{','.join(output_parts)}]\"\n    \n    print(final_output)\n\nsolve()\n```"
        }
    ]
}