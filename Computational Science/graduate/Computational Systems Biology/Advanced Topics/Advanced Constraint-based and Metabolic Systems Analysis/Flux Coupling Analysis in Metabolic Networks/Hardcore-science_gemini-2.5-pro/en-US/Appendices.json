{
    "hands_on_practices": [
        {
            "introduction": "This first exercise is foundational, guiding you through the implementation of the complete Flux Coupling Analysis (FCA) algorithm to classify all pairwise reaction relationships. By applying the method to simple, illustrative network topologies, you will not only master the computational mechanics using linear programming but also develop a strong geometric intuition for what these coupling relationships mean in the space of feasible fluxes. This practice connects the abstract algebraic constraints to concrete polyhedral shapes, making the concepts of coupling tangible. ",
            "id": "3309305",
            "problem": "You are given a series of steady-state metabolic networks, each specified by a stoichiometric matrix $S \\in \\mathbb{R}^{m \\times n}$, where $m$ is the number of metabolites and $n$ is the number of reactions. A steady-state flux vector $\\mathbf{v} \\in \\mathbb{R}^n$ satisfies $\\mathbf{S}\\mathbf{v} = \\mathbf{0}$ together with component-wise lower and upper bounds $\\boldsymbol{\\ell} \\le \\mathbf{v} \\le \\mathbf{u}$. All fluxes are in arbitrary consistent units with no additional physical unit reporting required for this problem.\n\nThe task is to implement Flux Coupling Analysis (FCA) for each network to classify the pairwise coupling relationships among reactions. Use the following fundamental definitions:\n\n- Steady state: $\\mathbf{S}\\mathbf{v} = \\mathbf{0}$.\n- Bounds: $\\ell_i \\le v_i \\le u_i$ for each reaction $i$.\n- Feasible flux space: $\\{\\mathbf{v} \\in \\mathbb{R}^n \\mid \\mathbf{S}\\mathbf{v} = \\mathbf{0}, \\ \\boldsymbol{\\ell} \\le \\mathbf{v} \\le \\mathbf{u}\\}$.\n- A reaction $i$ is said to be blocked if $\\max \\{ v_i \\mid \\mathbf{S}\\mathbf{v} = \\mathbf{0}, \\ \\boldsymbol{\\ell} \\le \\mathbf{v} \\le \\mathbf{u} \\} = 0$.\n- Flux Coupling Analysis (FCA) coupling types for reactions $i$ and $j$ are defined through implications about positivity. Let $\\mathbf{v} \\in \\mathbb{R}^n$ be feasible.\n  - Full coupling (mutual proportionality): For every feasible $\\mathbf{v}$, $v_i$ and $v_j$ are strictly proportional with a constant ratio; equivalently, fixing $v_i$ to any positive feasible value yields a unique $v_j$ (and vice versa).\n  - Partial coupling (mutual implication without fixed ratio): For every feasible $\\mathbf{v}$, $v_i > 0$ if and only if $v_j > 0$, but the ratio $v_j / v_i$ is not constant across the feasible set.\n  - Directional coupling ($i \\to j$): For every feasible $\\mathbf{v}$, $v_i > 0$ implies $v_j > 0$.\n  - Anti-coupled: For every feasible $\\mathbf{v}$, $v_i > 0$ implies $v_j = 0$, and $v_j > 0$ implies $v_i = 0$.\n  - Uncoupled: None of the above implications hold.\n\nYour program must determine, for each ordered pair $(i,j)$, a code that quantifies the coupling relation from reaction $i$ to reaction $j$, using the following encoding:\n- $5$: full coupling (this is symmetric, so both $(i,j)$ and $(j,i)$ must be $5$),\n- $4$: partial coupling (symmetric, both directions $4$),\n- $3$: directional coupling (only $(i,j)$ is $3$ when $i \\to j$ holds; $(j,i)$ will generally not be $3$),\n- $2$: anti-coupled (symmetric, both directions $2$),\n- $1$: uncoupled,\n- $0$: origin reaction $i$ is blocked (i.e., cannot carry any positive flux under the constraints), so the implication from $i$ is undefined and should be reported as $0$ for all $(i,\\cdot)$.\n\nTo test your implementation, apply it to the following three networks with bounds $0 \\le v \\le 10$ for every reaction (component-wise). Each network is specified by its stoichiometric matrix $S$:\n\n- Test Case 1 (chain balance):\n  $$S_1 = \\begin{bmatrix} -1  1  0 \\\\ 0  -1  1 \\end{bmatrix}.$$\n- Test Case 2 (one independent exchange):\n  $$S_2 = \\begin{bmatrix} -1  1  0 \\\\ 0  0  0 \\end{bmatrix}.$$\n- Test Case 3 (single conservation with two producers):\n  $$S_3 = \\begin{bmatrix} -1  1  1 \\end{bmatrix}.$$\n\nAlgorithmic guidance (must be implemented in a way that is universally applicable and mathematically valid):\n- For each reaction $i$, determine if it is blocked by solving a linear program that maximizes $v_i$ subject to $\\mathbf{S}\\mathbf{v} = \\mathbf{0}$ and the bounds.\n- For deciding directional implications, avoid non-linear ratio objectives by fixing the origin flux to a positive feasible level and linearly optimizing the target flux:\n  - Let $\\alpha_i$ be a strictly positive feasible level of $v_i$, for instance $\\alpha_i = \\tfrac{1}{2} \\cdot \\max \\{ v_i \\mid \\mathbf{S}\\mathbf{v} = \\mathbf{0}, \\ \\boldsymbol{\\ell} \\le \\mathbf{v} \\le \\mathbf{u} \\}$ when the maximum is positive.\n  - Then solve two linear programs to minimize and maximize $v_j$ subject to $\\mathbf{S}\\mathbf{v} = \\mathbf{0}$, $v_i = \\alpha_i$, and the bounds. If the minimized value of $v_j$ is strictly positive, then $i \\to j$ is a directional coupling. If both the minimized and maximized values of $v_j$ are zero, then $i$ is anti-coupled to $j$ in that direction.\n  - Use symmetric checks to decide full versus partial coupling: if $i \\to j$ and $j \\to i$ both hold, but the admissible range of $v_j$ when $v_i$ is fixed has nonzero width, then the pair is partially coupled; if that width is zero in both directions, the pair is fully coupled.\n- Numerical tolerances must be used to determine strict positivity and zero width; you may set a tolerance $\\varepsilon = 10^{-8}$.\n\nGeometric reasoning requirement:\n- Your solution must, in addition to determining the codes, explain the geometric structure of the feasible set in the $(v_1, v_2, v_3)$ space for each test case, starting from the constraints $\\mathbf{S}\\mathbf{v} = \\mathbf{0}$ and box bounds. The explanation must be based on the convex polyhedral geometry of the feasible set (the intersection of an affine subspace with a box), and must connect this geometry to the FCA outcomes.\n\nFinal output specification:\n- For each test case, output a $3 \\times 3$ matrix of integers where the entry in row $i$, column $j$ is the code for the ordered pair $(i,j)$ as defined above. The diagonal entries should be $5$ when the reaction is not blocked (each reaction is trivially fully coupled with itself), and $0$ when blocked.\n- Your program should produce a single line of output containing the three results as a comma-separated list enclosed in square brackets, for example:\n  - $\\big[$matrix for Test Case 1$\\,$,$\\,$matrix for Test Case 2$\\,$,$\\,$matrix for Test Case 3$\\big]$,\n  where each matrix itself is printed as a list of three lists of three integers, for instance $[[5,5,5],[5,5,5],[5,5,5]]$.\n\nNo user input is required; all data are specified here. The final answer must be integers as defined above, with the single line formatted exactly as described.",
            "solution": "The problem requires performing Flux Coupling Analysis (FCA) on three small metabolic networks to classify the pairwise coupling relationships between reactions. The analysis must be grounded in the geometry of the feasible flux space and implemented via a series of linear programs (LPs).\n\nThe feasible flux space, denoted by $\\mathcal{P}$, is the set of all flux vectors $\\mathbf{v} \\in \\mathbb{R}^n$ that satisfy the steady-state condition $\\mathbf{S}\\mathbf{v} = \\mathbf{0}$ and the reaction bounds $\\boldsymbol{\\ell} \\le \\mathbf{v} \\le \\mathbf{u}$. Mathematically, $\\mathcal{P} = \\{\\mathbf{v} \\in \\mathbb{R}^n \\mid \\mathbf{S}\\mathbf{v} = \\mathbf{0}, \\boldsymbol{\\ell} \\le \\mathbf{v} \\le \\mathbf{u}\\}$. This set is a convex polyhedron, formed by the intersection of the null space of the stoichiometric matrix $\\mathbf{S}$ (an affine subspace) and a hyperrectangle defined by the bounds (a box). The coupling relationships between two reactions, $v_i$ and $v_j$, are manifestations of the geometric properties of this polyhedron $\\mathcal{P}$.\n\nThe algorithmic approach to determine these relationships involves systematically testing implications using linear programming. For an unblocked reaction $i$ (one that can carry a positive flux, i.e., $\\max v_i > 0$), we fix its flux to a positive value, $v_i = \\alpha_i$, where $0  \\alpha_i \\le \\max v_i$. We then find the minimum and maximum possible fluxes for another reaction $j$ under this constraint.\nLet $v_{j,i}^{\\min}(\\alpha_i)$ and $v_{j,i}^{\\max}(\\alpha_i)$ be the minimum and maximum of $v_j$ subject to $\\mathbf{S}\\mathbf{v} = \\mathbf{0}$, $\\boldsymbol{\\ell} \\le \\mathbf{v} \\le \\mathbf{u}$, and $v_i = \\alpha_i$.\n- **Directional coupling ($i \\to j$):** This implication holds if $v_{j,i}^{\\min}(\\alpha_i) > 0$ for any choice of feasible $\\alpha_i > 0$.\n- **Anti-coupling ($v_i > 0 \\implies v_j = 0$):** This holds if $v_{j,i}^{\\max}(\\alpha_i) = 0$.\n- **Full coupling** is a symmetric, bidirectional implication where fixing $v_i$ uniquely determines $v_j$, meaning $v_{j,i}^{\\min}(\\alpha_i) = v_{j,i}^{\\max}(\\alpha_i)$.\n- **Partial coupling** is a symmetric, bidirectional implication where the ratio $v_j/v_i$ is not constant.\n- **Uncoupling** occurs when none of these constrained relationships hold.\n\nA numerical tolerance $\\varepsilon = 10^{-8}$ is used to check for strict positivity or equality to zero.\n\n**Test Case 1: Chain Balance**\n\n- Stoichiometric matrix: $S_1 = \\begin{bmatrix} -1  1  0 \\\\ 0  -1  1 \\end{bmatrix}$. The number of reactions is $n=3$.\n- Steady-state constraints:\n  $$-v_1 + v_2 = 0 \\implies v_1 = v_2$$\n  $$-v_2 + v_3 = 0 \\implies v_2 = v_3$$\n- Bounds: $0 \\le v_i \\le 10$ for $i \\in \\{1, 2, 3\\}$.\n\n**Geometric Analysis:**\nThe null space of $S_1$ is the set of vectors where $v_1 = v_2 = v_3$. This is a line in $\\mathbb{R}^3$ passing through the origin, spanned by the vector $(1, 1, 1)^T$. The feasible set $\\mathcal{P}_1$ is the intersection of this line with the cube $[0, 10]^3$. The resulting polyhedron is a line segment with endpoints $(0, 0, 0)$ and $(10, 10, 10)$. Any feasible flux vector has the form $\\mathbf{v} = (\\lambda, \\lambda, \\lambda)$ for some $\\lambda \\in [0, 10]$.\n\n**FCA Results:**\n- **Blocked Reactions:** None, as each reaction can carry flux up to $10$. The diagonal entries of the coupling matrix are $5$.\n- **Pairwise Coupling:** For any pair of reactions $(i, j)$, any feasible flux satisfies $v_i = \\lambda$ and $v_j = \\lambda$. Thus, $v_i = v_j$ for all feasible fluxes. The ratio $v_j/v_i = 1$ is constant for all non-zero fluxes. This is the definition of full coupling. All pairs of reactions are fully coupled.\n\n**Coupling Matrix for Test Case 1:**\n$$ C_1 = \\begin{bmatrix} 5  5  5 \\\\ 5  5  5 \\\\ 5  5  5 \\end{bmatrix} $$\n\n**Test Case 2: One Independent Exchange**\n\n- Stoichiometric matrix: $S_2 = \\begin{bmatrix} -1  1  0 \\\\ 0  0  0 \\end{bmatrix}$. Number of reactions $n=3$.\n- Steady-state constraints:\n  $$-v_1 + v_2 = 0 \\implies v_1 = v_2$$\n  $$0=0$$ (a redundant constraint)\n- Bounds: $0 \\le v_i \\le 10$.\n\n**Geometric Analysis:**\nThe null space of $S_2$ is the plane in $\\mathbb{R}^3$ defined by the equation $v_1 = v_2$. Reaction $v_3$ is not constrained by stoichiometry. The feasible set $\\mathcal{P}_2$ is the intersection of this plane with the cube $[0, 10]^3$. This region is a square whose vertices are $(0, 0, 0)$, $(10, 10, 0)$, $(0, 0, 10)$, and $(10, 10, 10)$.\n\n**FCA Results:**\n- **Blocked Reactions:** None, as all reactions can carry flux up to $10$. Diagonals are $5$.\n- **Pairwise Coupling:**\n  - **$(v_1, v_2)$:** The constraint $v_1 = v_2$ is always active. Thus, they are fully coupled. Code is $5$.\n  - **$(v_1, v_3)$:** We must check for implications. Is it true that $v_1 > 0 \\implies v_3 > 0$? No, the feasible point $(5, 5, 0)$ is a counterexample. Is it true that $v_3 > 0 \\implies v_1 > 0$? No, the point $(0, 0, 5)$ is a counterexample. Since they are not directionally coupled in either direction, nor anti-coupled (e.g., $(5, 5, 5)$ is feasible), they are uncoupled. Code is $1$.\n  - **$(v_2, v_3)$:** By symmetry with $(v_1, v_3)$ (since $v_1=v_2$), this pair is also uncoupled. Code is $1$.\n\n**Coupling Matrix for Test Case 2:**\n$$ C_2 = \\begin{bmatrix} 5  5  1 \\\\ 5  5  1 \\\\ 1  1  5 \\end{bmatrix} $$\n\n**Test Case 3: Single Conservation with Two Producers**\n\n- Stoichiometric matrix: $S_3 = \\begin{bmatrix} -1  1  1 \\end{bmatrix}$. Number of reactions $n=3$.\n- Steady-state constraint: $-v_1 + v_2 + v_3 = 0 \\implies v_1 = v_2 + v_3$.\n- Bounds: $0 \\le v_i \\le 10$.\n\n**Geometric Analysis:**\nThe null space is the plane $v_1 = v_2 + v_3$. The feasible set $\\mathcal{P}_3$ is the intersection of this plane with the cube $[0, 10]^3$. The bounds imply:\n$v_2 \\ge 0$, $v_3 \\ge 0$.\n$v_2 \\le 10$, $v_3 \\le 10$.\n$v_1 = v_2 + v_3 \\ge 0$ (redundant with the first two).\n$v_1 = v_2 + v_3 \\le 10$.\nThe constraints $v_2 \\le 10$ and $v_3 \\le 10$ are made redundant by $v_2, v_3 \\ge 0$ and $v_2+v_3 \\le 10$. Thus, the projection of $\\mathcal{P}_3$ onto the $(v_2, v_3)$ plane is a triangle with vertices at $(0,0)$, $(10,0)$, and $(0,10)$. The feasible set $\\mathcal{P}_3$ itself is a triangle in $\\mathbb{R}^3$ with vertices $(0, 0, 0)$, $(10, 10, 0)$, and $(10, 0, 10)$.\n\n**FCA Results:**\n- **Blocked Reactions:** None. All can carry flux up to $10$. Diagonals are $5$.\n- **Pairwise Coupling:**\n  - **$(v_2, v_1)$ and $(v_3, v_1)$:** If $v_2 > 0$, then $v_1 = v_2 + v_3 > 0$ because $v_3 \\ge 0$. So, $2 \\to 1$ (directional). Similarly, if $v_3 > 0$, then $v_1 > 0$, so $3 \\to 1$ (directional). Code for $(2,1)$ and $(3,1)$ is $3$.\n  - **$(v_1, v_2)$ and $(v_1, v_3)$:** Does $v_1 > 0 \\implies v_2 > 0$? No, the feasible point $(10, 0, 10)$ is a counterexample. Thus, $1 \\not\\to 2$. Similarly, $1 \\not\\to 3$ due to the feasible point $(10, 10, 0)$. These pairs are uncoupled in this direction. Code for $(1,2)$ and $(1,3)$ is $1$.\n  - **$(v_2, v_3)$:** Does $v_2 > 0 \\implies v_3 > 0$? No (counterexample: $(10, 10, 0)$). Does $v_3 > 0 \\implies v_2 > 0$? No (counterexample: $(10, 0, 10)$). They are not anti-coupled as $(5, 2.5, 2.5)$ is feasible. Thus, they are uncoupled. Code is $1$.\n\n**Coupling Matrix for Test Case 3:**\n$$ C_3 = \\begin{bmatrix} 5  1  1 \\\\ 3  5  1 \\\\ 3  1  5 \\end{bmatrix} $$",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Main function to run Flux Coupling Analysis on the given test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1 (chain balance)\n        np.array([[-1, 1, 0], [0, -1, 1]]),\n        \n        # Test Case 2 (one independent exchange)\n        np.array([[-1, 1, 0], [0, 0, 0]]),\n        \n        # Test Case 3 (single conservation with two producers)\n        np.array([[-1, 1, 1]]),\n    ]\n    \n    results = []\n    \n    for S in test_cases:\n        m, n = S.shape\n        bounds = [(0, 10)] * n\n        result_matrix = fca_analysis(S, bounds)\n        # Format the matrix as a list of lists for the final output string\n        results.append(result_matrix.tolist())\n\n    # Final print statement in the exact required format.\n    # The str() representation of a list of lists contains spaces.\n    # The required format is compact, so we remove spaces.\n    results_str = [str(res).replace(' ', '') for res in results]\n    print(f\"[{','.join(results_str)}]\")\n\ndef fca_analysis(S, bounds, tol=1e-8):\n    \"\"\"\n    Performs Flux Coupling Analysis for a given stoichiometric matrix and bounds.\n\n    Args:\n        S (np.ndarray): The stoichiometric matrix (m x n).\n        bounds (list of tuples): List of (lower, upper) bounds for each reaction.\n        tol (float): Numerical tolerance for zero checks.\n\n    Returns:\n        np.ndarray: The n x n matrix of coupling codes.\n    \"\"\"\n    m, n = S.shape\n    b_eq = np.zeros(m)\n    \n    coupling_matrix = np.zeros((n, n), dtype=int)\n    is_blocked = np.zeros(n, dtype=bool)\n    v_maxs = np.zeros(n)\n\n    # Step 1: Identify blocked reactions and find max fluxes for unblocked ones\n    for i in range(n):\n        c = np.zeros(n)\n        c[i] = -1  # Objective to maximize v_i (by minimizing -v_i)\n        \n        res = linprog(c, A_eq=S, b_eq=b_eq, bounds=bounds, method='highs')\n        \n        if res.success and -res.fun  tol:\n            v_maxs[i] = -res.fun\n            is_blocked[i] = False\n            coupling_matrix[i, i] = 5\n        else:\n            is_blocked[i] = True\n            # The i-th row and column will remain 0\n\n    # Step 2: Compute pairwise implications\n    # D[i, j] is True if i implies j (i - j)\n    # A[i, j] is True if v_i  0 implies v_j = 0\n    # W[j, i] stores the width of v_j's flux range when v_i is fixed\n    implication_D = np.zeros((n, n), dtype=bool)\n    implication_A = np.zeros((n, n), dtype=bool)\n    range_widths_W = np.zeros((n, n))\n\n    for i in range(n):\n        if is_blocked[i]:\n            continue\n        \n        alpha_i = 0.5 * v_maxs[i]\n        \n        # If max flux is very close to zero, it behaves like a blocked reaction.\n        if alpha_i  tol:\n            is_blocked[i] = True\n            coupling_matrix[i,:] = 0\n            coupling_matrix[:,i] = 0\n            continue\n            \n        iter_bounds = list(bounds)\n        iter_bounds[i] = (alpha_i, alpha_i)\n\n        for j in range(n):\n            if is_blocked[j] or i == j:\n                continue\n\n            # Minimize v_j\n            c_min = np.zeros(n)\n            c_min[j] = 1\n            res_min = linprog(c_min, A_eq=S, b_eq=b_eq, bounds=iter_bounds, method='highs')\n            v_j_min = res_min.fun if res_min.success else np.inf\n\n            # Maximize v_j\n            c_max = np.zeros(n)\n            c_max[j] = -1\n            res_max = linprog(c_max, A_eq=S, b_eq=b_eq, bounds=iter_bounds, method='highs')\n            v_j_max = -res_max.fun if res_max.success else -np.inf\n            \n            if not (res_min.success and res_max.success):\n                # This case indicates an infeasibility, which shouldn't happen\n                # with a properly chosen alpha_i unless the feasible space is disjoint\n                # in a strange way. We'll treat it as uncoupled.\n                continue\n\n            range_widths_W[j, i] = v_j_max - v_j_min\n\n            if v_j_min  tol:\n                implication_D[i, j] = True\n            \n            if v_j_max  tol:\n                implication_A[i, j] = True\n\n    # Step 3: Classify pairs based on computed implications\n    for i in range(n):\n        if is_blocked[i]:\n            continue\n        for j in range(i + 1, n):\n            if is_blocked[j]:\n                continue\n            \n            # Check for symmetric relationships first\n            if implication_D[i, j] and implication_D[j, i]:\n                # Full or Partial coupling\n                if range_widths_W[j, i]  tol and range_widths_W[i, j]  tol:\n                    coupling_matrix[i, j] = coupling_matrix[j, i] = 5  # Full\n                else:\n                    coupling_matrix[i, j] = coupling_matrix[j, i] = 4  # Partial\n            elif implication_A[i, j] and implication_A[j, i]:\n                coupling_matrix[i, j] = coupling_matrix[j, i] = 2  # Anti-coupled\n            # Check for directional relationships\n            elif implication_D[i, j]:\n                coupling_matrix[i, j] = 3  # Directional i - j\n                coupling_matrix[j, i] = 1  # Uncoupled the other way\n            elif implication_D[j, i]:\n                coupling_matrix[j, i] = 3  # Directional j - i\n                coupling_matrix[i, j] = 1  # Uncoupled the other way\n            # If nothing else, it's uncoupled\n            else:\n                coupling_matrix[i, j] = coupling_matrix[j, i] = 1  # Uncoupled\n\n    return coupling_matrix\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "While full coupling implies a rigid, fixed ratio, partial coupling signifies a more flexible relationship where fluxes are co-dependent but not strictly proportional. This practice focuses on quantifying this flexibility by calculating the allowable range of flux ratios for a partially coupled pair in a classic metabolic branch point motif. Mastering this technique is crucial for analyzing how metabolic networks distribute resources and for predicting their adaptability to changing demands. ",
            "id": "3309285",
            "problem": "Consider a small metabolic network motif under steady-state assumptions used in Flux Balance Analysis (FBA), where the net production and consumption of each internal metabolite must balance. Let the stoichiometric matrix be denoted by $S \\in \\mathbb{R}^{m \\times n}$, the reaction flux vector by $\\mathbf{v} \\in \\mathbb{R}^{n}$, and the steady-state condition by $\\mathbf{S}\\mathbf{v} = \\mathbf{0}$. Reaction irreversibility and capacity limits impose linear bounds on $\\mathbf{v}$ of the form $\\mathbf{l} \\le \\mathbf{v} \\le \\mathbf{u}$. Flux Coupling Analysis (FCA) studies relationships between pairs of reaction fluxes, and Linear Programming (LP) is used to compute constraints on feasible flux ratios.\n\nYou are given the following explicit network motif with $m = 4$ internal metabolites and $n = 6$ reactions. The internal metabolites are $A$, $B$, $C$, and $D$. The reactions are:\n- $R_1$: source $\\rightarrow A$ with flux $v_1$,\n- $R_2$: $A \\rightarrow B$ with flux $v_2$,\n- $R_3$: $B \\rightarrow C$ with flux $v_3$,\n- $R_4$: $B \\rightarrow D$ with flux $v_4$,\n- $R_5$: $C \\rightarrow$ sink with flux $v_5$,\n- $R_6$: $D \\rightarrow$ sink with flux $v_6$.\n\nThe stoichiometric matrix $S$ with row order $(A,B,C,D)$ and column order $(R_1,\\dots,R_6)$ is:\n$$\nS =\n\\begin{bmatrix}\n1  -1  0  0  0  0 \\\\\n0  1  -1  -1  0  0 \\\\\n0  0  1  0  -1  0 \\\\\n0  0  0  1  0  -1\n\\end{bmatrix}.\n$$\nThus the steady-state equalities $\\mathbf{S}\\mathbf{v} = \\mathbf{0}$ are:\n$$\nv_1 - v_2 = 0,\\quad v_2 - v_3 - v_4 = 0,\\quad v_3 - v_5 = 0,\\quad v_4 - v_6 = 0.\n$$\n\nReaction bounds are as follows:\n- Irreversibility: all fluxes are nonnegative, so $v_k \\ge 0$ for $k \\in \\{1,2,3,4,5,6\\}$.\n- Capacity limits: upper bounds are large but finite, e.g., $v_k \\le 100$ for all $k$.\n- A demand constraint enforces a minimum drain from metabolite $C$: $v_5 \\ge d_{\\min}$, where $d_{\\min}$ is a nonnegative parameter.\n- A mandatory branch constraint enforces a minimum flux into $D$: $v_4 \\ge b_{\\min}$, where $b_{\\min}$ is a nonnegative parameter satisfying $b_{\\min} \\le 1$ in the scenarios below.\n\nWe will study the flux coupling between reactions $R_3$ and $R_2$, denoted $i = 3$ and $j = 2$. The goal is to demonstrate a case where $i$ and $j$ are partially coupled but not fully coupled and to compute bounds on the ratio $v_i / v_j$ using Linear Programming (LP). To compute ratio bounds, we fix $v_j = 1$ as a normalization and solve two LPs: minimize $v_i$ subject to the constraints and maximize $v_i$ subject to the constraints. The minimum and maximum of $v_i$ under $v_j = 1$ yield the lower and upper bounds on $v_i / v_j$, respectively.\n\nYour program must:\n- Implement the network constraints $\\mathbf{S}\\mathbf{v} = \\mathbf{0}$, the bounds $\\mathbf{l} \\le \\mathbf{v} \\le \\mathbf{u}$, and the normalization $v_2 = 1$.\n- For each parameter set $(d_{\\min}, b_{\\min})$ in the test suite, solve two LPs to obtain $\\min v_3$ and $\\max v_3$ subject to $v_2 = 1$ and all constraints, and report the ratio bounds $[\\min(v_3)/1, \\max(v_3)/1]$.\n- Use Linear Programming (LP) to obtain these bounds, not closed-form algebra, even though the motif is simple.\n\nTest suite (each pair is $(d_{\\min}, b_{\\min})$):\n1. Case A (partial coupling \"happy path\"): $(0.2, 0.0)$\n2. Case B (boundary with no lower drain): $(0.0, 0.0)$\n3. Case C (full coupling boundary): $(1.0, 0.0)$\n4. Case D (partial coupling with mandatory branch): $(0.2, 0.3)$\n\nFor each case, the output must be a pair of floats $[\\text{lower}, \\text{upper}]$ representing the bounds on $v_3 / v_2$ under $v_2 = 1$, rounded to six decimal places.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case and is itself a two-element list of the ratio bounds. For example, the final output must look like $[[x_1,y_1],[x_2,y_2],[x_3,y_3],[x_4,y_4]]$ with each $x_k$ and $y_k$ rounded to six decimal places.",
            "solution": "The user wants to analyze a metabolic network motif using Flux Coupling Analysis (FCA), a technique based on Flux Balance Analysis (FBA). The analysis requires solving a series of Linear Programming (LP) problems.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n\n*   **Stoichiometric Matrix ($S$)**: A matrix of size $m \\times n$ where $m=4$ and $n=6$.\n    $$\n    S =\n    \\begin{bmatrix}\n    1  -1  0  0  0  0 \\\\\n    0  1  -1  -1  0  0 \\\\\n    0  0  1  0  -1  0 \\\\\n    0  0  0  1  0  -1\n    \\end{bmatrix}\n    $$\n*   **Flux Vector ($\\mathbf{v}$)**: A vector $\\mathbf{v} \\in \\mathbb{R}^{6}$ representing the fluxes of the $6$ reactions, $\\mathbf{v} = [v_1, v_2, v_3, v_4, v_5, v_6]^T$.\n*   **Steady-State Condition**: $\\mathbf{S}\\mathbf{v} = \\mathbf{0}$, which translates to the following system of linear equations:\n    *   $v_1 - v_2 = 0$\n    *   $v_2 - v_3 - v_4 = 0$\n    *   $v_3 - v_5 = 0$\n    *   $v_4 - v_6 = 0$\n*   **Flux Bounds and Constraints**:\n    *   Irreversibility: $v_k \\ge 0$ for $k \\in \\{1, 2, 3, 4, 5, 6\\}$.\n    *   Capacity: $v_k \\le 100$ for all $k$.\n    *   Demand: $v_5 \\ge d_{\\min}$, a non-negative parameter.\n    *   Branch: $v_4 \\ge b_{\\min}$, a non-negative parameter with $b_{\\min} \\le 1$.\n*   **Analysis Goal**: Compute the bounds on the flux ratio $v_3 / v_2$.\n*   **Methodology**:\n    1.  Normalize the flux of reaction $R_2$ by setting $v_2 = 1$.\n    2.  Use Linear Programming (LP) to find the minimum possible value of $v_3$.\n    3.  Use Linear Programming (LP) to find the maximum possible value of $v_3$.\n    4.  The results from steps 2 and 3 give the lower and upper bounds on the ratio $v_3 / v_2$.\n*   **Test Suite**: A list of parameter pairs $(d_{\\min}, b_{\\min})$ to be tested:\n    1.  $(0.2, 0.0)$\n    2.  $(0.0, 0.0)$\n    3.  $(1.0, 0.0)$\n    4.  $(0.2, 0.3)$\n\n**Step 2: Validate Using Extracted Givens**\n\nThe problem statement is evaluated for validity.\n\n*   **Scientific Grounding**: The problem is well-founded in computational systems biology. It employs the standard framework of Flux Balance Analysis (FBA), where a metabolic network is modeled by its stoichiometry ($S$) and subjected to a steady-state mass balance condition ($\\mathbf{S}\\mathbf{v} = \\mathbf{0}$). The use of Linear Programming (LP) to explore the space of feasible flux distributions defined by additional linear inequality constraints is a cornerstone of the field. Flux Coupling Analysis (FCA) is a direct application of this framework. Thus, the problem is scientifically sound.\n*   **Well-Posed and Complete**: The problem is mathematically well-posed. It defines a feasible region (a convex polytope) through a set of linear equalities and inequalities. The objective is to find the minimum and maximum of a linear function ($v_3$) over this region. This is a canonical LP problem. All necessary information is provided: the stoichiometric matrix $S$, all boundary conditions and constraints on the flux vector $\\mathbf{v}$, and the specific normalization to be used. The constraints are consistent; for each test case, the condition $d_{\\min} + b_{\\min} \\le 1$ holds, which guarantees a non-empty feasible region when $v_2=1$.\n*   **Objectivity**: The problem is stated using precise, unambiguous mathematical terms and definitions. It is entirely objective and free of subjective elements.\n\nThe problem does not exhibit any of the flaws that would render it invalid. It is a well-defined, solvable problem in its specified domain.\n\n**Step 3: Verdict and Action**\n\nThe problem is **valid**. A complete solution will be developed.\n\n### Solution Design\n\nThe problem requires finding the minimum and maximum of the flux $v_3$ subject to a set of linear constraints, which is a classic application of Linear Programming (LP). An LP problem is formulated as finding a vector $\\mathbf{x}$ that minimizes or maximizes a linear objective function $\\mathbf{c}^T \\mathbf{x}$ while satisfying a set of linear equality and inequality constraints.\n\n**Step 1: Formulate the Linear Programming Problem**\nThe unknown variables are the fluxes, represented by the vector $\\mathbf{v} = [v_1, v_2, v_3, v_4, v_5, v_6]^T$.\n\nThe constraints are as follows:\n1.  **Equality Constraints**: The steady-state condition $\\mathbf{S}\\mathbf{v} = \\mathbf{0}$ provides a set of linear equality constraints. In the standard LP form $\\mathbf{A}_{eq} \\mathbf{x} = \\mathbf{b}_{eq}$, we have $\\mathbf{A}_{eq} = S$ and $\\mathbf{b}_{eq} = \\mathbf{0}$.\n    $$\n    \\mathbf{A}_{eq} =\n    \\begin{bmatrix}\n    1  -1  0  0  0  0 \\\\\n    0  1  -1  -1  0  0 \\\\\n    0  0  1  0  -1  0 \\\\\n    0  0  0  1  0  -1\n    \\end{bmatrix},\n    \\quad\n    \\mathbf{b}_{eq} =\n    \\begin{bmatrix}\n    0 \\\\ 0 \\\\ 0 \\\\ 0\n    \\end{bmatrix}\n    $$\n2.  **Bound Constraints**: All other constraints can be expressed as lower and upper bounds on the individual flux variables $v_k$. A standard LP solver accepts these in the form $\\mathbf{l} \\le \\mathbf{v} \\le \\mathbf{u}$.\n    *   Irreversibility ($v_k \\ge 0$) and capacity ($v_k \\le 100$) give a baseline range of $[0, 100]$ for each flux.\n    *   The normalization constraint $v_2 = 1$ is implemented by setting the lower and upper bounds for $v_2$ to $1$.\n    *   The demand constraint $v_5 \\ge d_{\\min}$ sets the lower bound for $v_5$.\n    *   The branch constraint $v_4 \\ge b_{\\min}$ sets the lower bound for $v_4$.\n\n    Combining these, the bounds for the vector $\\mathbf{v}$ are:\n    *   $v_1$: $[0, 100]$\n    *   $v_2$: $[1, 1]$\n    *   $v_3$: $[0, 100]$\n    *   $v_4$: $[b_{\\min}, 100]$\n    *   $v_5$: $[d_{\\min}, 100]$\n    *   $v_6$: $[0, 100]$\n\n**Step 2: Define Objective Functions**\nThe goal is to find the minimum and maximum of $v_3$. This requires solving two separate LP problems.\n1.  **Minimizing $v_3$**: The objective function is $f(\\mathbf{v}) = v_3$. The corresponding objective coefficient vector $\\mathbf{c}$ (where the objective is to minimize $\\mathbf{c}^T \\mathbf{v}$) is:\n    $$\n    \\mathbf{c}_{\\min} = [0, 0, 1, 0, 0, 0]^T\n    $$\n2.  **Maximizing $v_3$**: Standard LP solvers are typically designed for minimization. To maximize $v_3$, we can minimize $-v_3$. The objective function is $g(\\mathbf{v}) = -v_3$, and the objective coefficient vector is:\n    $$\n    \\mathbf{c}_{\\max} = [0, 0, -1, 0, 0, 0]^T\n    $$\n    The result of this minimization, when negated, yields the maximum value of $v_3$.\n\n**Step 3: Solve for Each Test Case**\nFor each pair of $(d_{\\min}, b_{\\min})$ from the test suite, the following procedure is executed:\n1.  Construct the specific `bounds` array based on the given $d_{\\min}$ and $b_{\\min}$.\n2.  Solve the minimization LP: $\\min(\\mathbf{c}_{\\min}^T \\mathbf{v})$ subject to $\\mathbf{S}\\mathbf{v} = \\mathbf{0}$ and the bounds. The result is the lower bound of the ratio $v_3/v_2$.\n3.  Solve the maximization LP: $\\min(\\mathbf{c}_{\\max}^T \\mathbf{v})$ subject to $\\mathbf{S}\\mathbf{v} = \\mathbf{0}$ and the bounds. The negative of the result is the upper bound of the ratio $v_3/v_2$.\n4.  Store the resulting `[lower_bound, upper_bound]` pair.\n\nThis systematic approach, using a numerical LP solver as specified, will produce the required flux coupling ratios for each scenario. The implementation will use `scipy.optimize.linprog` to perform these calculations.",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Solves for the flux coupling ratio bounds between reactions R3 and R2\n    for a given metabolic network motif.\n    \"\"\"\n    # The stoichiometric matrix S for the network.\n    # Rows correspond to metabolites (A, B, C, D).\n    # Columns correspond to reactions (R1 to R6).\n    S = np.array([\n        [1, -1,  0,  0,  0,  0],\n        [0,  1, -1, -1,  0,  0],\n        [0,  0,  1,  0, -1,  0],\n        [0,  0,  0,  1,  0, -1]\n    ])\n\n    # The steady-state condition Sv = 0 implies the right-hand side is a zero vector.\n    b_eq = np.zeros(S.shape[0])\n\n    # Objective vectors to minimize and maximize v3 (flux of R3, at index 2).\n    # To maximize v3, we minimize -v3.\n    c_objective = np.array([0, 0, 1, 0, 0, 0])\n\n    # The general capacity limit for all fluxes.\n    v_upper_bound = 100.0\n\n    # Test suite with parameter pairs (d_min, b_min).\n    test_cases = [\n        (0.2, 0.0),\n        (0.0, 0.0),\n        (1.0, 0.0),\n        (0.2, 0.3)\n    ]\n\n    results = []\n    for d_min, b_min in test_cases:\n        # Define the bounds for the flux vector v = [v1, v2, v3, v4, v5, v6]^T.\n        # This is where the specific constraints for each case are set.\n        # v_k = 0 for all k (irreversibility)\n        # v_k = 100 for all k (capacity)\n        # v2 = 1 (normalization)\n        # v4 = b_min (mandatory branch)\n        # v5 = d_min (demand)\n        bounds = [\n            (0.0, v_upper_bound),  # v1 bound\n            (1.0, 1.0),            # v2 fixed at 1.0 for normalization\n            (0.0, v_upper_bound),  # v3 bound\n            (b_min, v_upper_bound),# v4 lower bound from b_min\n            (d_min, v_upper_bound),# v5 lower bound from d_min\n            (0.0, v_upper_bound)   # v6 bound\n        ]\n\n        # --- Solve for the minimum of v3 ---\n        # The result 'fun' of linprog is the optimal value of the objective function.\n        res_min = linprog(c=c_objective, A_eq=S, b_eq=b_eq, bounds=bounds, method='highs')\n        \n        lower_bound = 0.0\n        if res_min.success:\n            lower_bound = res_min.fun\n        else:\n            # This case should not be reached for the given valid problem.\n            # Handle solver failure if necessary (e.g., infeasible problem).\n            lower_bound = float('nan')\n            \n        # --- Solve for the maximum of v3 ---\n        # We achieve maximization by minimizing the negative of the objective.\n        res_max = linprog(c=-c_objective, A_eq=S, b_eq=b_eq, bounds=bounds, method='highs')\n\n        upper_bound = 0.0\n        if res_max.success:\n            # The result is min(-v3), so we negate it to get max(v3).\n            upper_bound = -res_max.fun\n        else:\n            # Handle solver failure.\n            upper_bound = float('nan')\n        \n        # Collect the bounds, formatted to six decimal places.\n        results.append([f\"{lower_bound:.6f}\", f\"{upper_bound:.6f}\"])\n\n    # Format the final list of results into the required string format.\n    # Example: \"[[0.200000,1.000000],[0.000000,1.000000]]\"\n    formatted_results_str = ','.join([f\"[{','.join(pair)}]\" for pair in results])\n    print(f\"[{formatted_results_str}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Moving from analysis to design, this final exercise demonstrates how FCA can be a powerful tool for rational metabolic engineering. The challenge is to determine the minimal set of reaction \"knockouts\" required to enforce a desired coupling between two target reactions, effectively re-wiring the network to achieve a specific metabolic objective. This practice frames a biological design question as a combinatorial optimization problem, a common and powerful paradigm in modern synthetic biology. ",
            "id": "3309313",
            "problem": "Consider a metabolic network represented by a stoichiometric matrix $S \\in \\mathbb{R}^{m \\times n}$ over $m$ metabolites and $n$ reactions, with a flux vector $\\mathbf{v} \\in \\mathbb{R}^n$. Under the pseudo-steady-state assumption, the feasible flux set is defined by the linear constraints $\\mathbf{S}\\mathbf{v} = \\mathbf{0}$ and component-wise bounds $\\mathbf{l} \\le \\mathbf{v} \\le \\mathbf{u}$, where $\\mathbf{l}, \\mathbf{u} \\in \\mathbb{R}^n$ are given lower and upper bounds. Assume all reactions are irreversible, so $l_k \\ge 0$ for all $k \\in \\{1,\\dots,n\\}$.\n\nFor a pair of reactions indexed by $(i,j)$ with $i \\in \\{1,\\dots,n\\}$ and $j \\in \\{1,\\dots,n\\}$, define the pair to be fully coupled if there exists a constant $c \\in \\mathbb{R}_{\\ge 0}$ such that for every feasible flux vector $\\mathbf{v}$ with $v_j > 0$, it holds that $v_i = c \\, v_j$. Equivalently, under the normalization constraint $v_j = 1$, the pair is fully coupled if the maximum and minimum achievable values of $v_i$ over the feasible set coincide.\n\nA reaction deletion set is a subset $D \\subseteq \\{1,\\dots,n\\} \\setminus \\{i,j\\}$; deleting reactions in $D$ enforces $v_k = 0$ for all $k \\in D$ while preserving the steady-state constraints $\\mathbf{S}\\mathbf{v} = \\mathbf{0}$ and bounds $\\mathbf{l} \\le \\mathbf{v} \\le \\mathbf{u}$. The combinatorial optimization problem is:\n$$\n\\min_{D \\subseteq \\{1,\\dots,n\\} \\setminus \\{i,j\\}} \\; |D| \\quad \\text{subject to} \\quad \\text{the pair } (i,j) \\text{ is fully coupled in the network with } v_j = 1,\n$$\nand the modified feasible set is nonempty. If no such deletion set exists that preserves feasibility of $v_j = 1$, declare the problem infeasible.\n\nYour task is to write a program that, for each test case provided below, computes:\n- the minimal cardinality $|D^\\star|$ over all deletion sets that make $(i,j)$ fully coupled under $v_j = 1$, and\n- the lexicographically smallest deletion set $D^\\star$ among those of minimal cardinality, using $1$-based reaction indices.\n\nTo decide full coupling for a candidate deletion set $D$, formulate two linear programs under the constraints $\\mathbf{S}\\mathbf{v} = \\mathbf{0}$, $\\mathbf{l} \\le \\mathbf{v} \\le \\mathbf{u}$, $v_k = 0$ for all $k \\in D$, and $v_j = 1$:\n- maximize $v_i$;\n- minimize $v_i$.\nIf both programs are feasible and the optimal values are equal within a numerical tolerance of $\\varepsilon = 10^{-7}$, declare $(i,j)$ fully coupled with constant ratio $c = v_i$ under $v_j = 1$.\n\nThe output for each test case must be a list $[|D^\\star|, D^\\star]$. If no deletion set yields full coupling while maintaining feasibility of $v_j = 1$, output $[-1, []]$ for that case.\n\nTest suite specifications (all bounds satisfy $l_k = 0$ and $u_k = 10$ for every reaction $k$; use $1$-based indexing for reactions):\n\n- Test Case $1$ (happy path): $m = 4$, $n = 6$,\n  $$\n  S =\n  \\begin{bmatrix}\n  +1  -1  -1  0  0  0 \\\\\n  0  +1  0  -1  0  0 \\\\\n  0  0  +1  0  -1  0 \\\\\n  0  0  0  +1  +1  -1\n  \\end{bmatrix},\n  $$\n  pair $(i,j) = (4,5)$.\n\n- Test Case $2$ (another happy path): $m = 2$, $n = 4$,\n  $$\n  S =\n  \\begin{bmatrix}\n  +1  -1  -1  0 \\\\\n  0  +1  0  -1\n  \\end{bmatrix},\n  $$\n  pair $(i,j) = (1,2)$.\n\n- Test Case $3$ (significant edge case: impossible coupling without deleting one of the pair members, which is disallowed): $m = 2$, $n = 4$,\n  $$\n  S =\n  \\begin{bmatrix}\n  +1  -1  -1  0 \\\\\n  0  +1  +1  -1\n  \\end{bmatrix},\n  $$\n  pair $(i,j) = (3,2)$.\n\n- Test Case $4$ (boundary condition: already fully coupled with zero deletions): reuse the first stoichiometric matrix,\n  $$\n  S =\n  \\begin{bmatrix}\n  +1  -1  -1  0  0  0 \\\\\n  0  +1  0  -1  0  0 \\\\\n  0  0  +1  0  -1  0 \\\\\n  0  0  0  +1  +1  -1\n  \\end{bmatrix},\n  $$\n  pair $(i,j) = (4,2)$.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case in the same order as above. Each element must be of the form $[|D^\\star|, D^\\star]$, with $D^\\star$ itself printed as a list of $1$-based reaction indices, for example $[[1,[3]],[2,[1,4]],[-1,[]],[0,[]]]$. No physical units are required for this problem. Angles are not involved. Express any fractions or decimals directly as numeric values.",
            "solution": "The user has presented a well-defined combinatorial optimization problem grounded in the principles of flux balance analysis and flux coupling analysis, which are standard techniques in computational systems biology.\n\n### Step 1: Problem Validation\n\nThe problem is to find a minimal set of reaction deletions, $D$, that forces a pair of reactions, $(i, j)$, to be fully coupled.\n\n*   **Givens:**\n    *   A stoichiometric matrix $S \\in \\mathbb{R}^{m \\times n}$.\n    *   A flux vector $\\mathbf{v} \\in \\mathbb{R}^n$.\n    *   Steady-state constraints: $\\mathbf{S}\\mathbf{v} = \\mathbf{0}$ and $\\mathbf{l} \\le \\mathbf{v} \\le \\mathbf{u}$.\n    *   Irreversibility: $l_k \\ge 0$ for all reactions $k$.\n    *   A target reaction pair $(i, j)$.\n    *   A deletion set $D \\subseteq \\{1,\\dots,n\\} \\setminus \\{i,j\\}$.\n    *   The rule for full coupling under $v_j=1$: after setting $v_k=0$ for all $k \\in D$ and $v_j=1$, the system must be feasible, and the solution to $\\max v_i$ must equal the solution to $\\min v_i$ within a tolerance $\\varepsilon = 10^{-7}$.\n*   **Objective:**\n    *   $\\min_{D} |D|$.\n    *   Among minimal sets, find the lexicographically smallest $D^\\star$.\n*   **Test Cases:** Four specific test cases with given $S$ matrices, pairs $(i,j)$, and universal bounds $l_k=0, u_k=10$.\n\n### Step 2: Validation Verdict\n\nThe problem is **valid**.\n1.  **Scientifically Grounded:** The problem uses standard representations and assumptions from metabolic network analysis (stoichiometric matrix, pseudo-steady-state). The concept of full coupling and the use of linear programming (LP) to check for it are canonical.\n2.  **Well-Posed:** The problem is mathematically well-defined. The search space is finite (the power set of reactions available for deletion), the objective function $|D|$ is clear, and the lexicographical tie-breaking rule ensures a unique solution.\n3.  **Objective:** The problem is stated using precise mathematical language, free from ambiguity or subjective claims.\n4.  **Completeness:** All necessary data ($S$, bounds, pairs $(i,j)$, coupling test) are provided.\n\nThe problem is a solvable, non-trivial computational task that requires implementing a search algorithm coupled with a linear programming solver.\n\n### Step 3: Solution Methodology\n\nThe problem seeks a reaction deletion set $D \\subseteq \\{1,\\dots,n\\} \\setminus \\{i,j\\}$ that is of minimal cardinality and is the lexicographically smallest among all sets of that minimal size. This structure suggests a search strategy that explores candidate sets in increasing order of size.\n\nThe overall algorithm is as follows:\n1.  Define the set of reactions that are candidates for deletion, $R_{\\text{del}} = \\{k \\in \\{1, \\dots, n\\} \\mid k \\neq i \\land k \\neq j\\}$. To handle the lexicographical requirement, we consider these reactions in their natural sorted order.\n2.  Iterate through possible deletion set cardinalities, $k$, from $0$ to $|R_{\\text{del}}|$.\n3.  For each cardinality $k$, generate all unique combinations of $k$ reactions from $R_{\\text{del}}$. By generating these combinations from a sorted list of reactions, we ensure they are produced in lexicographical order.\n4.  For each candidate deletion set $D$, test if it induces full coupling in the pair $(i,j)$ while maintaining feasibility. This test is performed using linear programming.\n5.  The first set $D$ that satisfies the coupling condition is, by this construction, guaranteed to be of minimal cardinality and lexicographically the smallest. The search can terminate, and this set is the optimal solution $D^\\star$.\n6.  If the search completes without finding any such set $D$, no solution exists, and the problem is declared infeasible for the given $(i,j)$ pair.\n\n#### Linear Programming Formulation for Coupling Test\n\nFor a given candidate deletion set $D$, we must verify if $\\max v_i = \\min v_i$ subject to the system's constraints. This requires solving two separate linear programs. The feasible set $\\mathcal{F}_D$ is defined by:\n$$\n\\begin{cases}\n\\mathbf{S}\\mathbf{v} = \\mathbf{0} \\\\\n\\mathbf{l} \\le \\mathbf{v} \\le \\mathbf{u} \\\\\nv_j = 1 \\\\\nv_k = 0  \\forall k \\in D\n\\end{cases}\n$$\nThe two LPs are:\n1.  **Minimization LP:** $\\min_{\\mathbf{v}} v_i \\quad \\text{subject to} \\quad \\mathbf{v} \\in \\mathcal{F}_D$\n2.  **Maximization LP:** $\\max_{\\mathbf{v}} v_i \\quad \\text{subject to} \\quad \\mathbf{v} \\in \\mathcal{F}_D$\n\nThese LPs can be modeled in the standard form required by solvers like `scipy.optimize.linprog`:\n$$\n\\min_{\\mathbf{x}} \\mathbf{c}^T \\mathbf{x} \\quad \\text{subject to} \\quad \\mathbf{A}_{eq} \\mathbf{x} = \\mathbf{b}_{eq}, \\quad lb \\le \\mathbf{x} \\le ub\n$$\nFor our problem, the components are:\n*   The variable vector is the flux vector: $\\mathbf{x} = \\mathbf{v} \\in \\mathbb{R}^n$.\n*   The equality constraints $\\mathbf{S}\\mathbf{v} = \\mathbf{0}$ are directly represented by $\\mathbf{A}_{eq} = S$ and $\\mathbf{b}_{eq} = \\mathbf{0} \\in \\mathbb{R}^m$.\n*   The objective vector $\\mathbf{c} \\in \\mathbb{R}^n$ is a zero vector, except for the element corresponding to $v_i$. For the minimization LP, $c_i=1$. For the maximization LP, we minimize $-v_i$, so we set $c_i=-1$.\n*   The bounds $lb$ and $ub$ incorporate the given lower and upper bounds ($l_k$ and $u_k$), the normalization condition ($v_j=1$), and the deletions ($v_k=0$ for $k \\in D$). Specifically, for each reaction $k \\in \\{1,\\dots,n\\}$:\n    *   If $k = j$, set bounds to $[1, 1]$.\n    *   If $k \\in D$, set bounds to $[0, 0]$.\n    *   Otherwise, use the given bounds $[l_k, u_k]$.\n\nThe test for full coupling proceeds as follows:\n1.  Solve the minimization LP. If it is infeasible, the set $D$ is invalid, and we proceed to the next candidate. Let the optimal value be $v_i^{\\min}$.\n2.  Solve the maximization LP. If it is also feasible, let its optimal value be $v_i^{\\max}$.\n3.  The pair $(i,j)$ is fully coupled if $|v_i^{\\max} - v_i^{\\min}| \\le \\varepsilon$, where the tolerance is given as $\\varepsilon = 10^{-7}$.\n\nThis procedure is applied iteratively for each candidate set $D$ generated by the combinatorial search until a solution is found or the search space is exhausted.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\nfrom itertools import combinations\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and orchestrate the solution process.\n    \"\"\"\n    \n    # --- Helper Functions ---\n    \n    def _check_coupling(S, i_0, j_0, l, u, n, D_0, epsilon):\n        \"\"\"\n        Checks for full coupling for a given deletion set using linear programming.\n        Uses 0-based indexing for reactions and deletion sets.\n        \n        Returns:\n            (bool, bool): A tuple (is_feasible, is_coupled).\n        \"\"\"\n        m = S.shape[0]\n\n        A_eq = S\n        b_eq = np.zeros(m)\n        \n        # Create bounds for this specific check\n        current_l = l.copy()\n        current_u = u.copy()\n        \n        # Constraint: v_j = 1\n        current_l[j_0] = 1.0\n        current_u[j_0] = 1.0\n\n        # Constraints: v_k = 0 for k in D\n        for k_del in D_0:\n            current_l[k_del] = 0.0\n            current_u[k_del] = 0.0\n\n        bounds = list(zip(current_l, current_u))\n        \n        # --- Minimization LP ---\n        c_min = np.zeros(n)\n        c_min[i_0] = 1.0\n        # Use 'highs' solver which is robust. presolve=True is generally good.\n        res_min = linprog(c=c_min, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs', options={'presolve': True})\n\n        if not res_min.success:\n            return False, False # (is_feasible, is_coupled)\n\n        v_i_min = res_min.fun\n\n        # --- Maximization LP (by minimizing -v_i) ---\n        c_max = np.zeros(n)\n        c_max[i_0] = -1.0\n        res_max = linprog(c=c_max, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs', options={'presolve': True})\n        \n        if not res_max.success:\n            # This should not happen if min-LP was feasible in a bounded region, but is a safeguard.\n            return True, False\n\n        v_i_max = -res_max.fun\n\n        is_coupled = abs(v_i_max - v_i_min) = epsilon\n        \n        return True, is_coupled\n\n    def _find_minimal_deletion_set(S, i, j, l, u, epsilon):\n        \"\"\"\n        Finds the minimal cardinality, lexicographically smallest deletion set D.\n        i and j are 1-based indices.\n        \"\"\"\n        n = S.shape[1]\n        i_0, j_0 = i - 1, j - 1\n\n        # Get list of deletable reactions (0-based), sorted for lexicographical combinations\n        deletable_reactions = sorted([r for r in range(n) if r != i_0 and r != j_0])\n\n        for k_size in range(len(deletable_reactions) + 1):\n            for D_0_tuple in combinations(deletable_reactions, k_size):\n                D_0 = list(D_0_tuple)\n                is_feasible, is_coupled = _check_coupling(S, i_0, j_0, l, u, n, D_0, epsilon)\n                \n                if is_feasible and is_coupled:\n                    # Found the solution. Convert back to 1-based indices for output.\n                    D_1_based = [d + 1 for d in D_0]\n                    return [k_size, D_1_based]\n                    \n        return [-1, []]\n\n    def _format_result(res):\n        \"\"\"\n        Formats a single result list into the required string format without spaces.\n        \"\"\"\n        cardinality, d_set = res\n        d_set_str = f\"[{','.join(map(str, d_set))}]\"\n        return f\"[{cardinality},{d_set_str}]\"\n        \n    # --- Test Case Definitions ---\n    \n    S1 = np.array([\n        [+1, -1, -1, 0, 0, 0],\n        [0, +1, 0, -1, 0, 0],\n        [0, 0, +1, 0, -1, 0],\n        [0, 0, 0, +1, +1, -1]\n    ], dtype=float)\n    \n    S2 = np.array([\n        [+1, -1, -1, 0],\n        [0, +1, 0, -1]\n    ], dtype=float)\n\n    S3 = np.array([\n        [+1, -1, -1, 0],\n        [0, +1, +1, -1]\n    ], dtype=float)\n\n    test_cases = [\n        {'S': S1, 'n': 6, 'pair': (4, 5)},\n        {'S': S2, 'n': 4, 'pair': (1, 2)},\n        {'S': S3, 'n': 4, 'pair': (3, 2)},\n        {'S': S1, 'n': 6, 'pair': (4, 2)}\n    ]\n    \n    # --- Main Execution Loop ---\n    \n    l_base = 0.0\n    u_base = 10.0\n    epsilon = 1e-7\n\n    final_results = []\n    for case in test_cases:\n        S = case['S']\n        n = case['n']\n        i, j = case['pair']\n        \n        l = np.full(n, l_base)\n        u = np.full(n, u_base)\n        \n        result = _find_minimal_deletion_set(S, i, j, l, u, epsilon)\n        final_results.append(_format_result(result))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(final_results)}]\")\n\nsolve()\n```"
        }
    ]
}