{
    "hands_on_practices": [
        {
            "introduction": "本练习旨在从零开始建立对通量耦合分析（Flux Coupling Analysis, FCA）的基础理解。通过实现基于核心线性规划的定义，您将对简单网络中的耦合关系进行分类，并且至关重要地，将这些抽象的分类与可行通量空间（feasible flux space）的内在几何结构联系起来 。这项练习将巩固数学形式主义与直观几何推理之间的联系。",
            "id": "3309305",
            "problem": "给定一系列稳态代谢网络，每个网络由一个化学计量矩阵 $S \\in \\mathbb{R}^{m \\times n}$ 指定，其中 $m$ 是代谢物数量，$n$ 是反应数量。稳态通量向量 $v \\in \\mathbb{R}^n$ 满足 $S v = 0$ 以及分量级的上下界 $\\ell \\le v \\le u$。所有通量均使用任意一致的单位，本问题无需报告额外的物理单位。\n\n任务是为每个网络实现通量耦合分析 (FCA)，以对反应之间的成对耦合关系进行分类。使用以下基本定义：\n\n- 稳态：$S v = 0$。\n- 边界：对于每个反应 $i$，$\\ell_i \\le v_i \\le u_i$。\n- 可行通量空间：$\\{v \\in \\mathbb{R}^n \\mid S v = 0, \\ \\ell \\le v \\le u\\}$。\n- 如果 $\\max \\{ v_i \\mid S v = 0, \\ \\ell \\le v \\le u \\} = 0$，则称反应 $i$ 是阻塞的。\n- 反应 $i$ 和 $j$ 的通量耦合分析 (FCA) 耦合类型是通过关于正值的蕴涵关系来定义的。设 $v \\in \\mathbb{R}^n$ 是可行的。\n  - 完全耦合 (相互成比例)：对于每个可行向量 $v$，$v_i$ 和 $v_j$ 严格成比例，且比值恒定；等价地，将 $v_i$ 固定到任何可行的正值都会得到唯一的 $v_j$ (反之亦然)。\n  - 部分耦合 (相互蕴涵但比值不固定)：对于每个可行向量 $v$，$v_i > 0$ 当且仅当 $v_j > 0$，但比值 $v_j / v_i$ 在整个可行集上不是恒定的。\n  - 方向性耦合 ($i \\to j$)：对于每个可行向量 $v$，$v_i > 0$ 蕴涵 $v_j > 0$。\n  - 反向耦合：对于每个可行向量 $v$，$v_i > 0$ 蕴涵 $v_j = 0$，且 $v_j > 0$ 蕴涵 $v_i = 0$。\n  - 非耦合：以上蕴涵关系均不成立。\n\n您的程序必须为每个有序对 $(i,j)$ 确定一个代码，该代码量化了从反应 $i$ 到反应 $j$ 的耦合关系，使用以下编码：\n- $5$：完全耦合 (这是对称的，因此 $(i,j)$ 和 $(j,i)$ 都必须是 $5$)，\n- $4$：部分耦合 (对称的，两个方向都是 $4$)，\n- $3$：方向性耦合 (当 $i \\to j$ 成立时，只有 $(i,j)$ 是 $3$；$(j,i)$ 通常不会是 $3$)，\n- $2$：反向耦合 (对称的，两个方向都是 $2$)，\n- $1$：非耦合，\n- $0$：起始反应 $i$ 是阻塞的 (即在约束条件下不能携带任何正通量)，因此从 $i$ 出发的蕴涵关系是未定义的，对于所有 $(i,\\cdot)$ 都应报告为 $0$。\n\n为测试您的实现，请将其应用于以下三个网络，其中每个反应的边界 (分量级) 为 $0 \\le v \\le 10$。每个网络由其化学计量矩阵 $S$ 指定：\n\n- 测试用例 1 (链式平衡)：\n  $$S_1 = \\begin{bmatrix} -1  1  0 \\\\ 0  -1  1 \\end{bmatrix}.$$\n- 测试用例 2 (一个独立的交换反应)：\n  $$S_2 = \\begin{bmatrix} -1  1  0 \\\\ 0  0  0 \\end{bmatrix}.$$\n- 测试用例 3 (单个守恒定律与两个生产者)：\n  $$S_3 = \\begin{bmatrix} -1  1  1 \\end{bmatrix}.$$\n\n算法指导 (必须以一种普遍适用且数学上有效的方式实现)：\n- 对于每个反应 $i$，通过求解一个线性规划问题来确定其是否被阻塞，该问题在满足 $S v = 0$ 和边界约束的条件下最大化 $v_i$。\n- 为了判断方向性蕴涵，通过将起始通量固定在一个可行的正水平上，并对目标通量进行线性优化，来避免非线性的比率目标：\n  - 设 $\\alpha_i$ 为 $v_i$ 的一个严格为正的可行水平，例如，当最大值为正时，可设 $\\alpha_i = \\tfrac{1}{2} \\cdot \\max \\{ v_i \\mid S v = 0, \\ \\ell \\le v \\le u \\}$。\n  - 然后求解两个线性规划问题，在满足 $S v = 0$、$v_i = \\alpha_i$ 和边界约束的条件下，分别最小化和最大化 $v_j$。如果 $v_j$ 的最小值严格为正，则 $i \\to j$ 是一个方向性耦合。如果 $v_j$ 的最小值和最大值都为零，则 $i$ 在该方向上与 $j$ 是反向耦合的。\n  - 使用对称性检查来判断完全耦合与部分耦合：如果 $i \\to j$ 和 $j \\to i$ 都成立，但在 $v_i$ 固定的情况下 $v_j$ 的容许范围宽度非零，则这对反应是部分耦合的；如果两个方向的宽度都为零，则这对反应是完全耦合的。\n- 必须使用数值公差来确定严格正性和零宽度；您可以设置公差 $\\varepsilon = 10^{-8}$。\n\n几何推理要求：\n- 除了确定代码之外，您的解决方案还必须为每个测试用例解释在 $(v_1, v_2, v_3)$ 空间中可行集的几何结构，从约束 $S v = 0$ 和盒子边界出发。解释必须基于可行集的凸多面体几何形状 (仿射子空间与一个盒子的交集)，并且必须将此几何形状与 FCA 的结果联系起来。\n\n最终输出规范：\n- 对于每个测试用例，输出一个 $3 \\times 3$ 的整数矩阵，其中第 $i$ 行、第 $j$ 列的条目是上述定义的有序对 $(i,j)$ 的代码。当反应未被阻塞时，对角线上的条目应为 $5$ (每个反应与其自身都是平凡的完全耦合)，当反应被阻塞时，对角线上的条目应为 $0$。\n- 您的程序应该生成单行输出，其中包含三个结果，以逗号分隔的列表形式并用方括号括起来，例如：\n  - $\\big[$测试用例1的矩阵$\\,$,$\\,$测试用例2的矩阵$\\,$,$\\,$测试用例3的矩阵$\\big]$,\n  其中每个矩阵本身打印为包含三个列表的列表，每个列表包含三个整数，例如 $[[5,5,5],[5,5,5],[5,5,5]]$。\n\n无需用户输入；所有数据均在此处指定。最终答案必须是如上定义的整数，并且单行格式必须与描述完全一致。",
            "solution": "该问题要求对三个小型代谢网络执行通量耦合分析 (FCA)，以对反应之间的成对耦合关系进行分类。该分析必须基于可行通量空间的几何结构，并通过一系列线性规划 (LP) 实现。\n\n可行通量空间，记为 $\\mathcal{P}$，是所有满足稳态条件 $S v = 0$ 和反应边界 $\\ell \\le v \\le u$ 的通量向量 $v \\in \\mathbb{R}^n$ 的集合。在数学上，$\\mathcal{P} = \\{v \\in \\mathbb{R}^n \\mid S v = 0, \\ell \\le v \\le u\\}$。这个集合是一个凸多面体，由化学计量矩阵 $S$ 的零空间 (一个仿射子空间) 和由边界定义的超矩形 (一个盒子) 的交集形成。两个反应 $v_i$ 和 $v_j$ 之间的耦合关系是该多面体 $\\mathcal{P}$ 几何特性的体现。\n\n确定这些关系的算法方法涉及使用线性规划系统地测试蕴涵关系。对于一个未阻塞的反应 $i$ (即可以携带正通量的反应，即 $\\max v_i > 0$)，我们将其通量固定为一个正值 $v_i = \\alpha_i$，其中 $0 < \\alpha_i \\le \\max v_i$。然后我们在此约束下找到另一个反应 $j$ 的最小和最大可能通量。\n设 $v_{j,i}^{\\min}(\\alpha_i)$ 和 $v_{j,i}^{\\max}(\\alpha_i)$ 是在满足 $S v = 0$、$\\ell \\le v \\le u$ 和 $v_i = \\alpha_i$ 的条件下 $v_j$ 的最小值和最大值。\n- **方向性耦合 ($i \\to j$)：** 如果对于任何可行的 $\\alpha_i > 0$ 的选择，都有 $v_{j,i}^{\\min}(\\alpha_i) > 0$，则该蕴涵关系成立。\n- **反向耦合 ($v_i > 0 \\implies v_j = 0$)：** 如果 $v_{j,i}^{\\max}(\\alpha_i) = 0$，则该关系成立。\n- **完全耦合**是一种对称的双向蕴涵关系，其中固定 $v_i$ 会唯一确定 $v_j$，即 $v_{j,i}^{\\min}(\\alpha_i) = v_{j,i}^{\\max}(\\alpha_i)$。\n- **部分耦合**是一种对称的双向蕴涵关系，其中比率 $v_j/v_i$ 不是恒定的。\n- **非耦合**在以上这些受约束的关系都不成立时发生。\n\n使用数值公差 $\\varepsilon = 10^{-8}$ 来检查严格正性或是否等于零。\n\n**测试用例 1：链式平衡**\n\n- 化学计量矩阵：$S_1 = \\begin{bmatrix} -1  1  0 \\\\ 0  -1  1 \\end{bmatrix}$。反应数量为 $n=3$。\n- 稳态约束：\n  $$-v_1 + v_2 = 0 \\implies v_1 = v_2$$\n  $$-v_2 + v_3 = 0 \\implies v_2 = v_3$$\n- 边界：$0 \\le v_i \\le 10$ 对于 $i \\in \\{1, 2, 3\\}$。\n\n**几何分析：**\n$S_1$ 的零空间是满足 $v_1 = v_2 = v_3$ 的向量集合。这是 $\\mathbb{R}^3$ 中一条穿过原点的直线，由向量 $(1, 1, 1)^T$ 张成。可行集 $\\mathcal{P}_1$ 是这条直线与立方体 $[0, 10]^3$ 的交集。所得到的多面体是一条线段，端点为 $(0, 0, 0)$ 和 $(10, 10, 10)$。任何可行的通量向量都具有形式 $v = (\\lambda, \\lambda, \\lambda)$，其中 $\\lambda \\in [0, 10]$。\n\n**FCA 结果：**\n- **阻塞反应：** 无，因为每个反应都可以携带高达 $10$ 的通量。耦合矩阵的对角线元素为 $5$。\n- **成对耦合：** 对于任意一对反应 $(i, j)$，任何可行通量都满足 $v_i = \\lambda$ 和 $v_j = \\lambda$。因此，对于所有可行通量，$v_i = v_j$。对于所有非零通量，比率 $v_j/v_i = 1$ 是恒定的。这是完全耦合的定义。所有反应对都是完全耦合的。\n\n**测试用例1的耦合矩阵：**\n$$ C_1 = \\begin{bmatrix} 5  5  5 \\\\ 5  5  5 \\\\ 5  5  5 \\end{bmatrix} $$\n\n**测试用例 2：一个独立的交换反应**\n\n- 化学计量矩阵：$S_2 = \\begin{bmatrix} -1  1  0 \\\\ 0  0  0 \\end{bmatrix}$。反应数量 $n=3$。\n- 稳态约束：\n  $$-v_1 + v_2 = 0 \\implies v_1 = v_2$$\n  $$0=0$$ (一个冗余约束)\n- 边界：$0 \\le v_i \\le 10$。\n\n**几何分析：**\n$S_2$ 的零空间是 $\\mathbb{R}^3$ 中由方程 $v_1 = v_2$ 定义的平面。反应 $v_3$ 不受化学计量约束。可行集 $\\mathcal{P}_2$ 是该平面与立方体 $[0, 10]^3$ 的交集。这个区域是一个正方形，其顶点为 $(0, 0, 0)$、$(10, 10, 0)$、$(0, 0, 10)$ 和 $(10, 10, 10)$。\n\n**FCA 结果：**\n- **阻塞反应：** 无，因为所有反应都可以携带高达 $10$ 的通量。对角线元素为 $5$。\n- **成对耦合：**\n  - **$(v_1, v_2)$：** 约束 $v_1 = v_2$ 始终有效。因此，它们是完全耦合的。代码为 $5$。\n  - **$(v_1, v_3)$：** 我们必须检查蕴涵关系。$v_1 > 0 \\implies v_3 > 0$ 是否成立？不成立，可行点 $(5, 5, 0)$ 是一个反例。$v_3 > 0 \\implies v_1 > 0$ 是否成立？不成立，点 $(0, 0, 5)$ 是一个反例。由于它们在任何一个方向上都不是方向性耦合，也不是反向耦合 (例如，$(5, 5, 5)$ 是可行的)，所以它们是非耦合的。代码为 $1$。\n  - **$(v_2, v_3)$：** 根据与 $(v_1, v_3)$ 的对称性 (因为 $v_1=v_2$)，这对反应也是非耦合的。代码为 $1$。\n\n**测试用例2的耦合矩阵：**\n$$ C_2 = \\begin{bmatrix} 5  5  1 \\\\ 5  5  1 \\\\ 1  1  5 \\end{bmatrix} $$\n\n**测试用例 3：单个守恒定律与两个生产者**\n\n- 化学计量矩阵：$S_3 = \\begin{bmatrix} -1  1  1 \\end{bmatrix}$。反应数量 $n=3$。\n- 稳态约束：$-v_1 + v_2 + v_3 = 0 \\implies v_1 = v_2 + v_3$。\n- 边界：$0 \\le v_i \\le 10$。\n\n**几何分析：**\n零空间是平面 $v_1 = v_2 + v_3$。可行集 $\\mathcal{P}_3$ 是该平面与立方体 $[0, 10]^3$ 的交集。边界条件意味着：\n$v_2 \\ge 0$, $v_3 \\ge 0$。\n$v_2 \\le 10$, $v_3 \\le 10$。\n$v_1 = v_2 + v_3 \\ge 0$ (与前两个条件相比是冗余的)。\n$v_1 = v_2 + v_3 \\le 10$。\n约束 $v_2 \\le 10$ 和 $v_3 \\le 10$ 因 $v_2, v_3 \\ge 0$ 和 $v_2+v_3 \\le 10$ 而变得冗余。因此，$\\mathcal{P}_3$ 在 $(v_2, v_3)$ 平面上的投影是一个顶点为 $(0,0)$、$(10,0)$ 和 $(0,10)$ 的三角形。可行集 $\\mathcal{P}_3$ 本身是 $\\mathbb{R}^3$ 中的一个三角形，其顶点为 $(0, 0, 0)$、$(10, 10, 0)$ 和 $(10, 0, 10)$。\n\n**FCA 结果：**\n- **阻塞反应：** 无。所有反应都可以携带高达 $10$ 的通量。对角线元素为 $5$。\n- **成对耦合：**\n  - **$(v_2, v_1)$ 和 $(v_3, v_1)$：** 如果 $v_2 > 0$，那么因为 $v_3 \\ge 0$，所以 $v_1 = v_2 + v_3 > 0$。因此，$2 \\to 1$ (方向性)。类似地，如果 $v_3 > 0$，那么 $v_1 > 0$，因此 $3 \\to 1$ (方向性)。$(2,1)$ 和 $(3,1)$ 的代码为 $3$。\n  - **$(v_1, v_2)$ 和 $(v_1, v_3)$：** $v_1 > 0 \\implies v_2 > 0$ 是否成立？不成立，可行点 $(10, 0, 10)$ 是一个反例。因此，$1 \\not\\to 2$。类似地，由于可行点 $(10, 10, 0)$ 的存在，$1 \\not\\to 3$。这些反应对在这个方向上是非耦合的。$(1,2)$ 和 $(1,3)$ 的代码为 $1$。\n  - **$(v_2, v_3)$：** $v_2 > 0 \\implies v_3 > 0$ 是否成立？不成立 (反例：$(10, 10, 0)$)。$v_3 > 0 \\implies v_2 > 0$ 是否成立？不成立 (反例：$(10, 0, 10)$)。它们不是反向耦合的，因为 $(5, 2.5, 2.5)$ 是可行的。因此，它们是非耦合的。代码为 $1$。\n\n**测试用例3的耦合矩阵：**\n$$ C_3 = \\begin{bmatrix} 5  1  1 \\\\ 3  5  1 \\\\ 3  1  5 \\end{bmatrix} $$",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Main function to run Flux Coupling Analysis on the given test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1 (chain balance)\n        np.array([[-1, 1, 0], [0, -1, 1]]),\n        \n        # Test Case 2 (one independent exchange)\n        np.array([[-1, 1, 0], [0, 0, 0]]),\n        \n        # Test Case 3 (single conservation with two producers)\n        np.array([[-1, 1, 1]]),\n    ]\n    \n    results = []\n    \n    for S in test_cases:\n        m, n = S.shape\n        bounds = [(0, 10)] * n\n        result_matrix = fca_analysis(S, bounds)\n        # Format the matrix as a list of lists for the final output string\n        results.append(result_matrix.tolist())\n\n    # Final print statement in the exact required format.\n    # The str() representation of a list of lists contains spaces.\n    # The required format is compact, so we remove spaces.\n    results_str = [str(res).replace(' ', '') for res in results]\n    print(f\"[{','.join(results_str)}]\")\n\ndef fca_analysis(S, bounds, tol=1e-8):\n    \"\"\"\n    Performs Flux Coupling Analysis for a given stoichiometric matrix and bounds.\n\n    Args:\n        S (np.ndarray): The stoichiometric matrix (m x n).\n        bounds (list of tuples): List of (lower, upper) bounds for each reaction.\n        tol (float): Numerical tolerance for zero checks.\n\n    Returns:\n        np.ndarray: The n x n matrix of coupling codes.\n    \"\"\"\n    m, n = S.shape\n    b_eq = np.zeros(m)\n    \n    coupling_matrix = np.zeros((n, n), dtype=int)\n    is_blocked = np.zeros(n, dtype=bool)\n    v_maxs = np.zeros(n)\n\n    # Step 1: Identify blocked reactions and find max fluxes for unblocked ones\n    for i in range(n):\n        c = np.zeros(n)\n        c[i] = -1  # Objective to maximize v_i (by minimizing -v_i)\n        \n        res = linprog(c, A_eq=S, b_eq=b_eq, bounds=bounds, method='highs')\n        \n        if res.success and -res.fun > tol:\n            v_maxs[i] = -res.fun\n            is_blocked[i] = False\n            coupling_matrix[i, i] = 5\n        else:\n            is_blocked[i] = True\n            # The i-th row and column will remain 0\n\n    # Step 2: Compute pairwise implications\n    # D[i, j] is True if i implies j (i -> j)\n    # A[i, j] is True if v_i > 0 implies v_j = 0\n    # W[j, i] stores the width of v_j's flux range when v_i is fixed\n    implication_D = np.zeros((n, n), dtype=bool)\n    implication_A = np.zeros((n, n), dtype=bool)\n    range_widths_W = np.zeros((n, n))\n\n    for i in range(n):\n        if is_blocked[i]:\n            continue\n        \n        alpha_i = 0.5 * v_maxs[i]\n        \n        # If max flux is very close to zero, it behaves like a blocked reaction.\n        if alpha_i  tol:\n            is_blocked[i] = True\n            coupling_matrix[i,:] = 0\n            coupling_matrix[:,i] = 0\n            continue\n            \n        iter_bounds = list(bounds)\n        iter_bounds[i] = (alpha_i, alpha_i)\n\n        for j in range(n):\n            if is_blocked[j] or i == j:\n                continue\n\n            # Minimize v_j\n            c_min = np.zeros(n)\n            c_min[j] = 1\n            res_min = linprog(c_min, A_eq=S, b_eq=b_eq, bounds=iter_bounds, method='highs')\n            v_j_min = res_min.fun if res_min.success else np.inf\n\n            # Maximize v_j\n            c_max = np.zeros(n)\n            c_max[j] = -1\n            res_max = linprog(c_max, A_eq=S, b_eq=b_eq, bounds=iter_bounds, method='highs')\n            v_j_max = -res_max.fun if res_max.success else -np.inf\n            \n            if not (res_min.success and res_max.success):\n                # This case indicates an infeasibility, which shouldn't happen\n                # with a properly chosen alpha_i unless the feasible space is disjoint\n                # in a strange way. We'll treat it as uncoupled.\n                continue\n\n            range_widths_W[j, i] = v_j_max - v_j_min\n\n            if v_j_min > tol:\n                implication_D[i, j] = True\n            \n            if v_j_max  tol:\n                implication_A[i, j] = True\n\n    # Step 3: Classify pairs based on computed implications\n    for i in range(n):\n        if is_blocked[i]:\n            continue\n        for j in range(i + 1, n):\n            if is_blocked[j]:\n                continue\n            \n            # Check for symmetric relationships first\n            if implication_D[i, j] and implication_D[j, i]:\n                # Full or Partial coupling\n                if range_widths_W[j, i]  tol and range_widths_W[i, j]  tol:\n                    coupling_matrix[i, j] = coupling_matrix[j, i] = 5  # Full\n                else:\n                    coupling_matrix[i, j] = coupling_matrix[j, i] = 4  # Partial\n            elif implication_A[i, j] and implication_A[j, i]:\n                coupling_matrix[i, j] = coupling_matrix[j, i] = 2  # Anti-coupled\n            # Check for directional relationships\n            elif implication_D[i, j]:\n                coupling_matrix[i, j] = 3  # Directional i -> j\n                coupling_matrix[j, i] = 1  # Uncoupled the other way\n            elif implication_D[j, i]:\n                coupling_matrix[j, i] = 3  # Directional j -> i\n                coupling_matrix[i, j] = 1  # Uncoupled the other way\n            # If nothing else, it's uncoupled\n            else:\n                coupling_matrix[i, j] = coupling_matrix[j, i] = 1  # Uncoupled\n\n    return coupling_matrix\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "在掌握了基本概念之后，本练习将聚焦于部分耦合（partial coupling）的细微之处，这是一种两个通量相互依赖但非严格成比例的状态。您将使用线性规划来计算一对部分耦合反应通量比率的精确边界，展示网络约束和需求如何塑造这些非平凡的关系 。这项技能对于定量理解代谢灵活性和途径相互作用至关重要。",
            "id": "3309285",
            "problem": "考虑一个在稳态假设下的小型代谢网络基序，该基序用于通量平衡分析（Flux Balance Analysis, FBA）。在FBA中，每种内部代谢物的净产生和消耗必须平衡。设化学计量矩阵表示为 $S \\in \\mathbb{R}^{m \\times n}$，反应通量向量表示为 $v \\in \\mathbb{R}^{n}$，稳态条件表示为 $S v = 0$。反应的不可逆性和容量限制对 $v$ 施加了 $l \\le v \\le u$ 形式的线性边界。通量耦合分析（Flux Coupling Analysis, FCA）研究反应通量对之间的关系，并使用线性规划（Linear Programming, LP）计算可行通量比率的约束。\n\n给定以下具有 $m = 4$ 种内部代谢物和 $n = 6$ 个反应的显式网络基序。内部代谢物为 $A$、 $B$、 $C$ 和 $D$。反应如下：\n- $R_1$：源 $\\rightarrow A$，通量为 $v_1$，\n- $R_2$：$A \\rightarrow B$，通量为 $v_2$，\n- $R_3$：$B \\rightarrow C$，通量为 $v_3$，\n- $R_4$：$B \\rightarrow D$，通量为 $v_4$，\n- $R_5$：$C \\rightarrow$ 汇，通量为 $v_5$，\n- $R_6$：$D \\rightarrow$ 汇，通量为 $v_6$。\n\n化学计量矩阵 $S$ 的行序为 $(A,B,C,D)$，列序为 $(R_1,\\dots,R_6)$，如下所示：\n$$\nS =\n\\begin{bmatrix}\n1  -1  0  0  0  0 \\\\\n0  1  -1  -1  0  0 \\\\\n0  0  1  0  -1  0 \\\\\n0  0  0  1  0  -1\n\\end{bmatrix}.\n$$\n因此，稳态等式 $S v = 0$ 为：\n$$\nv_1 - v_2 = 0,\\quad v_2 - v_3 - v_4 = 0,\\quad v_3 - v_5 = 0,\\quad v_4 - v_6 = 0.\n$$\n\n反应边界如下：\n- 不可逆性：所有通量均为非负，因此对于 $k \\in \\{1,2,3,4,5,6\\}$，有 $v_k \\ge 0$。\n- 容量限制：上界很大但有限，例如，对于所有 $k$，有 $v_k \\le 100$。\n- 一个需求约束强制从代谢物 $C$ 中有最小流出：$v_5 \\ge d_{\\min}$，其中 $d_{\\min}$ 是一个非负参数。\n- 一个强制分支约束强制进入 $D$ 的最小通量为：$v_4 \\ge b_{\\min}$，其中 $b_{\\min}$ 是一个非负参数，在以下情景中满足 $b_{\\min} \\le 1$。\n\n我们将研究反应 $R_3$ 和 $R_2$ 之间的通量耦合，记为 $i = 3$ 和 $j = 2$。目标是展示一个 $i$ 和 $j$ 部分耦合但非完全耦合的案例，并使用线性规划（LP）计算比率 $v_i / v_j$ 的边界。为计算比率边界，我们固定 $v_j = 1$作为归一化，并求解两个LP问题：在满足约束条件的情况下最小化 $v_i$，以及在满足约束条件的情况下最大化 $v_i$。在 $v_j = 1$ 的条件下，$v_i$ 的最小值和最大值分别给出了 $v_i / v_j$ 的下界和上界。\n\n您的程序必须：\n- 实现网络约束 $S v = 0$、边界 $l \\le v \\le u$ 以及归一化 $v_2 = 1$。\n- 对于测试套件中的每个参数集 $(d_{\\min}, b_{\\min})$，求解两个LP问题以获得在 $v_2 = 1$ 和所有约束条件下的 $\\min v_3$ 和 $\\max v_3$，并报告比率边界 $[\\min(v_3)/1, \\max(v_3)/1]$。\n- 使用线性规划（LP）来获得这些边界，而不是使用封闭形式的代数，即使该基序很简单。\n\n测试套件（每对为 $(d_{\\min}, b_{\\min})$）：\n1. 案例A（部分耦合“理想路径”）：$(0.2, 0.0)$\n2. 案例B（无较低流出的边界情况）：$(0.0, 0.0)$\n3. 案例C（完全耦合边界）：$(1.0, 0.0)$\n4. 案例D（带强制分支的部分耦合）：$(0.2, 0.3)$\n\n对于每种情况，输出必须是一对浮点数 $[\\text{lower}, \\text{upper}]$，表示在 $v_2 = 1$ 条件下 $v_3 / v_2$ 的边界，并四舍五入到六位小数。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。列表中的每个元素对应一个测试用例，其本身是一个包含两个元素的比率边界列表。例如，最终输出必须类似于 $[[x_1,y_1],[x_2,y_2],[x_3,y_3],[x_4,y_4]]$，其中每个 $x_k$ 和 $y_k$ 都四舍五入到六位小数。",
            "solution": "用户希望使用通量耦合分析（FCA）来分析一个代谢网络基序，这是一种基于通量平衡分析（FBA）的技术。该分析需要求解一系列线性规划（LP）问题。\n\n### 问题验证\n\n**步骤1：提取给定信息**\n\n*   **化学计量矩阵 ($S$)**：一个大小为 $m \\times n$ 的矩阵，其中 $m=4$ 且 $n=6$。\n    $$\n    S =\n    \\begin{bmatrix}\n    1  -1  0  0  0  0 \\\\\n    0  1  -1  -1  0  0 \\\\\n    0  0  1  0  -1  0 \\\\\n    0  0  0  1  0  -1\n    \\end{bmatrix}\n    $$\n*   **通量向量 ($v$)**：一个向量 $v \\in \\mathbb{R}^{6}$，代表6个反应的通量，$v = [v_1, v_2, v_3, v_4, v_5, v_6]^T$。\n*   **稳态条件**：$S v = 0$，可转化为以下线性方程组：\n    *   $v_1 - v_2 = 0$\n    *   $v_2 - v_3 - v_4 = 0$\n    *   $v_3 - v_5 = 0$\n    *   $v_4 - v_6 = 0$\n*   **通量边界与约束**：\n    *   不可逆性：对于 $k \\in \\{1, 2, 3, 4, 5, 6\\}$，有 $v_k \\ge 0$。\n    *   容量：对于所有 $k$，有 $v_k \\le 100$。\n    *   需求：$v_5 \\ge d_{\\min}$，一个非负参数。\n    *   分支：$v_4 \\ge b_{\\min}$，一个非负参数且 $b_{\\min} \\le 1$。\n*   **分析目标**：计算通量比率 $v_3 / v_2$ 的边界。\n*   **方法论**：\n    1.  通过设置 $v_2 = 1$ 来归一化反应 $R_2$ 的通量。\n    2.  使用线性规划（LP）找到 $v_3$ 的最小可能值。\n    3.  使用线性规划（LP）找到 $v_3$ 的最大可能值。\n    4.  步骤2和3的结果给出了比率 $v_3 / v_2$ 的下界和上界。\n*   **测试套件**：待测试的参数对 $(d_{\\min}, b_{\\min})$ 列表：\n    1.  $(0.2, 0.0)$\n    2.  $(0.0, 0.0)$\n    3.  $(1.0, 0.0)$\n    4.  $(0.2, 0.3)$\n\n**步骤2：使用提取的给定信息进行验证**\n\n评估问题陈述的有效性。\n\n*   **科学依据**：该问题在计算系统生物学中有充分的依据。它采用了通量平衡分析（FBA）的标准框架，其中代谢网络通过其化学计量（$S$）进行建模，并服从稳态质量平衡条件（$S v = 0$）。使用线性规划（LP）来探索由附加线性不等式约束定义的可行通量分布空间是该领域的基石。通量耦合分析（FCA）是此框架的直接应用。因此，该问题在科学上是合理的。\n*   **良态且完整**：该问题在数学上是良态的。它通过一组线性的等式和不等式定义了一个可行域（一个凸多胞体）。目标是在此区域上找到一个线性函数（$v_3$）的最小值和最大值。这是一个典型的LP问题。所有必要的信息都已提供：化学计量矩阵 $S$、通量向量 $v$ 的所有边界条件和约束，以及要使用的特定归一化方法。约束条件是一致的；对于每个测试用例，条件 $d_{\\min} + b_{\\min} \\le 1$ 均成立，这保证了在 $v_2=1$ 时可行域非空。\n*   **客观性**：问题陈述使用了精确、无歧义的数学术语和定义。它完全是客观的，没有主观因素。\n\n该问题没有任何会使其无效的缺陷。在其指定的领域内，这是一个定义明确、可解决的问题。\n\n**步骤3：结论与行动**\n\n该问题是**有效的**。将开发一个完整的解决方案。\n\n### 解决方案设计\n\n该问题要求在一组线性约束条件下找到通量 $v_3$ 的最小值和最大值，这是线性规划（LP）的经典应用。一个LP问题被表述为找到一个向量 $x$，该向量在满足一组线性等式和不等式约束的同时，最小化或最大化一个线性目标函数 $c^T x$。\n\n**步骤1：构建线性规划问题**\n未知变量是通量，由向量 $v = [v_1, v_2, v_3, v_4, v_5, v_6]^T$ 表示。\n\n约束条件如下：\n1.  **等式约束**：稳态条件 $S v = 0$ 提供了一组线性等式约束。在标准LP形式 $A_{eq} x = b_{eq}$ 中，我们有 $A_{eq} = S$ 和 $b_{eq} = 0$。\n    $$\n    A_{eq} =\n    \\begin{bmatrix}\n    1  -1  0  0  0  0 \\\\\n    0  1  -1  -1  0  0 \\\\\n    0  0  1  0  -1  0 \\\\\n    0  0  0  1  0  -1\n    \\end{bmatrix},\n    \\quad\n    b_{eq} =\n    \\begin{bmatrix}\n    0 \\\\ 0 \\\\ 0 \\\\ 0\n    \\end{bmatrix}\n    $$\n2.  **边界约束**：所有其他约束都可以表示为单个通量变量 $v_k$ 的下界和上界。一个标准的LP求解器接受 $l \\le v \\le u$ 的形式。\n    *   不可逆性（$v_k \\ge 0$）和容量（$v_k \\le 100$）为每个通量提供了 $[0, 100]$ 的基线范围。\n    *   归一化约束 $v_2 = 1$ 通过将 $v_2$ 的下界和上界都设置为1来实现。\n    *   需求约束 $v_5 \\ge d_{\\min}$ 设置了 $v_5$ 的下界。\n    *   分支约束 $v_4 \\ge b_{\\min}$ 设置了 $v_4$ 的下界。\n\n    综合这些，向量 $v$ 的边界为：\n    *   $v_1$: $[0, 100]$\n    *   $v_2$: $[1, 1]$\n    *   $v_3$: $[0, 100]$\n    *   $v_4$: $[b_{\\min}, 100]$\n    *   $v_5$: $[d_{\\min}, 100]$\n    *   $v_6$: $[0, 100]$\n\n**步骤2：定义目标函数**\n目标是找到 $v_3$ 的最小值和最大值。这需要求解两个独立的LP问题。\n1.  **最小化 $v_3$**：目标函数是 $f(v) = v_3$。对应的目标系数向量 $c$（其中目标是最小化 $c^T v$）是：\n    $$\n    c_{\\min} = [0, 0, 1, 0, 0, 0]^T\n    $$\n2.  **最大化 $v_3$**：标准的LP求解器通常为最小化而设计。为了最大化 $v_3$，我们可以最小化 $-v_3$。目标函数是 $g(v) = -v_3$，目标系数向量是：\n    $$\n    c_{\\max} = [0, 0, -1, 0, 0, 0]^T\n    $$\n    该最小化问题的结果取反后，即得到 $v_3$ 的最大值。\n\n**步骤3：为每个测试用例求解**\n对于测试套件中的每对 $(d_{\\min}, b_{\\min})$，执行以下过程：\n1.  根据给定的 $d_{\\min}$ 和 $b_{\\min}$ 构建特定的 `bounds` 数组。\n2.  求解最小化LP问题：`min(c_min^T v)`，约束条件为 $S v = 0$ 和边界。结果是比率 $v_3/v_2$ 的下界。\n3.  求解最大化LP问题：`min(c_max^T v)`，约束条件为 $S v = 0$ 和边界。结果的负值是比率 $v_3/v_2$ 的上界。\n4.  存储得到的 `[lower_bound, upper_bound]` 对。\n\n这种系统化的方法，按照规定使用数值LP求解器，将为每种情景生成所需的通量耦合比率。实现将使用 `scipy.optimize.linprog` 来执行这些计算。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Solves for the flux coupling ratio bounds between reactions R3 and R2\n    for a given metabolic network motif.\n    \"\"\"\n    # The stoichiometric matrix S for the network.\n    # Rows correspond to metabolites (A, B, C, D).\n    # Columns correspond to reactions (R1 to R6).\n    S = np.array([\n        [1, -1,  0,  0,  0,  0],\n        [0,  1, -1, -1,  0,  0],\n        [0,  0,  1,  0, -1,  0],\n        [0,  0,  0,  1,  0, -1]\n    ])\n\n    # The steady-state condition Sv = 0 implies the right-hand side is a zero vector.\n    b_eq = np.zeros(S.shape[0])\n\n    # Objective vectors to minimize and maximize v3 (flux of R3, at index 2).\n    # To maximize v3, we minimize -v3.\n    c_objective = np.array([0, 0, 1, 0, 0, 0])\n\n    # The general capacity limit for all fluxes.\n    v_upper_bound = 100.0\n\n    # Test suite with parameter pairs (d_min, b_min).\n    test_cases = [\n        (0.2, 0.0),\n        (0.0, 0.0),\n        (1.0, 0.0),\n        (0.2, 0.3)\n    ]\n\n    results = []\n    for d_min, b_min in test_cases:\n        # Define the bounds for the flux vector v = [v1, v2, v3, v4, v5, v6]^T.\n        # This is where the specific constraints for each case are set.\n        # v_k >= 0 for all k (irreversibility)\n        # v_k = 100 for all k (capacity)\n        # v2 = 1 (normalization)\n        # v4 >= b_min (mandatory branch)\n        # v5 >= d_min (demand)\n        bounds = [\n            (0.0, v_upper_bound),  # v1 bound\n            (1.0, 1.0),            # v2 fixed at 1.0 for normalization\n            (0.0, v_upper_bound),  # v3 bound\n            (b_min, v_upper_bound),# v4 lower bound from b_min\n            (d_min, v_upper_bound),# v5 lower bound from d_min\n            (0.0, v_upper_bound)   # v6 bound\n        ]\n\n        # --- Solve for the minimum of v3 ---\n        # The result 'fun' of linprog is the optimal value of the objective function.\n        res_min = linprog(c=c_objective, A_eq=S, b_eq=b_eq, bounds=bounds, method='highs')\n        \n        lower_bound = 0.0\n        if res_min.success:\n            lower_bound = res_min.fun\n        else:\n            # This case should not be reached for the given valid problem.\n            # Handle solver failure if necessary (e.g., infeasible problem).\n            lower_bound = float('nan')\n            \n        # --- Solve for the maximum of v3 ---\n        # We achieve maximization by minimizing the negative of the objective.\n        res_max = linprog(c=-c_objective, A_eq=S, b_eq=b_eq, bounds=bounds, method='highs')\n\n        upper_bound = 0.0\n        if res_max.success:\n            # The result is min(-v3), so we negate it to get max(v3).\n            upper_bound = -res_max.fun\n        else:\n            # Handle solver failure.\n            upper_bound = float('nan')\n        \n        # Collect the bounds, formatted to six decimal places.\n        results.append([f\"{lower_bound:.6f}\", f\"{upper_bound:.6f}\"])\n\n    # Format the final list of results into the required string format.\n    # Example: \"[[0.200000,1.000000],[0.000000,1.000000]]\"\n    formatted_results_str = ','.join([f\"[{','.join(pair)}]\" for pair in results])\n    print(f\"[{formatted_results_str}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "计算模型的最终检验在于其与实验数据的一致性。这最后一个练习旨在弥合理论FCA与实验证据（例如来自同位素示踪实验的数据）之间的鸿沟 。您将开发一个一致性测试，以确定实验测量的通量比率是否与网络模型预测的完全耦合相容，从而为模型验证和改进提供一个强大的工具。",
            "id": "3309259",
            "problem": "给定一个由化学计量矩阵 $S \\in \\mathbb{R}^{m \\times n}$ 定义的稳态代谢网络，其中 $m$ 是代谢物数量，$n$ 是反应数量。在稳态假设下，细胞内代谢物浓度不随时间变化，因此质量平衡对反应通量向量 $\\mathbf{v} \\in \\mathbb{R}^n$ 施加了线性约束 $S \\, \\mathbf{v} = \\mathbf{0}$。每个反应通量 $v_k$ 都受下界和上界 $l_k \\le v_k \\le u_k$ 的限制，这些界限体现了热力学不可逆性、酶容量和生理限制。这些约束定义了一个可行通量的凸多面体，这是基于约束的分析中的基础模型。\n\n目标是使用同位素示踪数据交叉验证通量耦合分析 (FCA)。在 FCA 中，如果两个反应 $i$ 和 $j$ 的通量在所有可行的稳态通量向量 $\\mathbf{v}$ 中都满足 $v_i = \\alpha \\, v_j$（其中 $\\alpha$ 为常数），且与其他通量的大小无关，则称它们是完全耦合的。假设同位素示踪实验为 $v_i / v_j$ 提供了一个经验比率 $r$，其容差为 $\\epsilon$，使得 $v_i / v_j \\approx r$ 在容差 $\\epsilon$ 范围内成立。\n\n您的任务是实现一个一致性检验，评估在网络约束下，经验比率 $r$ 是否意味着反应 $i$ 和 $j$ 在绝对容差 $\\epsilon$ 内完全耦合。形式上，定义残差线性泛函 $f(\\mathbf{v}) = v_i - r \\, v_j$。经验比率在容差 $\\epsilon$ 内意味着完全耦合，当且仅当\n$$\n\\sup_{\\mathbf{v} \\in \\mathcal{F}} \\left| f(\\mathbf{v}) \\right| \\le \\epsilon,\n$$\n其中 $\\mathcal{F} = \\left\\{ \\mathbf{v} \\in \\mathbb{R}^n \\mid S \\, \\mathbf{v} = \\mathbf{0}, \\, l_k \\le v_k \\le u_k \\, \\forall k \\in \\{1, \\dots, n\\} \\right\\}$ 是可行通量集。多面体上线性泛函的上确界在其极点处取得，可以通过线性规划 (LP) 计算。因此，您必须计算\n$$\nM_+ \\;=\\; \\max_{\\mathbf{v} \\in \\mathcal{F}} \\, \\left( v_i - r \\, v_j \\right), \\qquad\nM_- \\;=\\; \\max_{\\mathbf{v} \\in \\mathcal{F}} \\, \\left( -v_i + r \\, v_j \\right),\n$$\n然后评估 $M = \\max\\{M_+, M_-\\}$。如果 $M \\le \\epsilon$，则返回 `True`；否则返回 `False`。如果可行集 $\\mathcal{F}$ 为空（没有稳态通量满足约束），则返回 `False`。\n\n请实现一个程序，为每个测试用例构建线性规划问题，计算 $M$，并根据上述规则返回一个布尔结果。最终输出必须是单行文本，包含所有测试用例的布尔结果，格式为逗号分隔的列表并用方括号括起。\n\n使用以下测试套件。每个测试用例指定 $(S, \\, \\mathbf{l}, \\, \\mathbf{u}, \\, i, \\, j, \\, r, \\, \\epsilon)$:\n\n测试用例 1 (顺利路径：严格完全耦合，r = 1):\n- $S = \\begin{bmatrix} 1  -1 \\end{bmatrix}$，\n- $\\mathbf{l} = \\begin{bmatrix} 0  0 \\end{bmatrix}$，\n- $\\mathbf{u} = \\begin{bmatrix} 10  10 \\end{bmatrix}$，\n- $i = 0$, $j = 1$, $r = 1$, $\\epsilon = 10^{-6}$。\n\n测试用例 2 (因旁路反应而未耦合):\n- $S = \\begin{bmatrix} 1  -1  -1 \\end{bmatrix}$，\n- $\\mathbf{l} = \\begin{bmatrix} 0  0  0 \\end{bmatrix}$，\n- $\\mathbf{u} = \\begin{bmatrix} 10  10  5 \\end{bmatrix}$，\n- $i = 0$, $j = 1$, $r = 1$, $\\epsilon = 10^{-2}$。\n\n测试用例 3 (与测试用例 2 网络相同，但容差较大):\n- $S = \\begin{bmatrix} 1  -1  -1 \\end{bmatrix}$，\n- $\\mathbf{l} = \\begin{bmatrix} 0  0  0 \\end{bmatrix}$，\n- $\\mathbf{u} = \\begin{bmatrix} 10  10  5 \\end{bmatrix}$，\n- $i = 0$, $j = 1$, $r = 1$, $\\epsilon = 5$。\n\n测试用例 4 (j 受阻导致比率不一致，除非 i 也接近于零):\n- $S = \\begin{bmatrix} 1  -1  -1 \\end{bmatrix}$，\n- $\\mathbf{l} = \\begin{bmatrix} 0  0  0 \\end{bmatrix}$，\n- $\\mathbf{u} = \\begin{bmatrix} 10  0  10 \\end{bmatrix}$，\n- $i = 0$, $j = 1$, $r = 1$, $\\epsilon = 10^{-3}$。\n\n您的程序应生成单行输出，其中包含以逗号分隔的列表形式的结果，并用方括号括起来 (例如, `[True,False,True]`)。输出的布尔值必须是小写或大写的 Python布尔字面量，并且必须严格按照要求的格式打印。",
            "solution": "我们从基于约束的建模中的稳态质量平衡原理开始。对于一个化学计量矩阵 $S \\in \\mathbb{R}^{m \\times n}$ 和一个通量向量 $\\mathbf{v} \\in \\mathbb{R}^n$，稳态假设施加了 $S \\, \\mathbf{v} = \\mathbf{0}$ 的约束。反应通量界限 $l_k \\le v_k \\le u_k$ 定义了可行集 $\\mathcal{F} = \\{\\mathbf{v} \\mid S \\, \\mathbf{v} = \\mathbf{0}, \\, l_k \\le v_k \\le u_k \\}$，这是一个凸多面体。\n\n通量耦合分析 (FCA) 通过反应通量在可行集内是否保持固定比例来对反应对进行分类。反应 $i$ 和 $j$ 的完全耦合意味着存在一个常数 $\\alpha$，使得对于所有 $\\mathbf{v} \\in \\mathcal{F}$，都有 $v_i = \\alpha v_j$。来自同位素示踪的经验数据为 $v_i / v_j$ 提供了一个估计比率 $r$，其容差 $\\epsilon$ 代表测量不确定性。为了使用这些数据交叉验证 FCA，我们试图检验在网络约束下，经验比率 $r$ 是否意味着在容差 $\\epsilon$ 内的完全耦合。\n\n定义残差泛函 $f(\\mathbf{v}) = v_i - r \\, v_j$。陈述“$v_i / v_j \\approx r$ 在容差 $\\epsilon$ 内”可以转化为对所有可行 $\\mathbf{v}$ 均有 $|f(\\mathbf{v})| \\le \\epsilon$ 的要求。因为 $f$ 是 $\\mathbf{v}$ 的线性函数且 $\\mathcal{F}$ 是一个多面体，所以上确界 $\\sup_{\\mathbf{v} \\in \\mathcal{F}} |f(\\mathbf{v})|$ 在 $\\mathcal{F}$ 的一个顶点处取得。因此，我们可以计算\n$$\nM_+ = \\max_{\\mathbf{v} \\in \\mathcal{F}} \\left( v_i - r \\, v_j \\right), \\qquad\nM_- = \\max_{\\mathbf{v} \\in \\mathcal{F}} \\left( -v_i + r \\, v_j \\right),\n$$\n并设 $M = \\max\\{M_+, M_-\\}$。当且仅当 $M \\le \\epsilon$ 时，经验比率意味着在容差 $\\epsilon$ 内完全耦合。这建立了一个基于原则的一致性检验，它将 FCA 与同位素衍生的比率相结合：它证明了线性一致性残差在整个可行稳态通量空间内是一致有界的。\n\n为了计算 $M_+$ 和 $M_-$，我们求解两个线性规划 (LP) 问题。令 $\\mathbf{c} \\in \\mathbb{R}^n$ 是一个向量，其中对于所有 $k$，$c_k = 0$，除了 $c_i = 1$ 和 $c_j = -r$。那么 $f(\\mathbf{v}) = \\mathbf{c}^\\top \\mathbf{v}$。多面体上线性泛函的最大化可以使用最小化目标的标准 LP 求解器来计算；具体来说，\n- $\\max \\mathbf{c}^\\top \\mathbf{v}$ 等价于 $\\min (-\\mathbf{c})^\\top \\mathbf{v}$，\n- $\\max (-\\mathbf{c})^\\top \\mathbf{v}$ 等价于 $\\min \\mathbf{c}^\\top \\mathbf{v}$。\n在等式约束 $S \\, \\mathbf{v} = \\mathbf{0}$ 和箱形约束 $l_k \\le v_k \\le u_k$ 的条件下，这些 LP 分别返回最优值 $M_+$ 和 $M_-$。如果可行集为空（LP 不可行）或目标无界（在有限界限下不会发生），我们报告 `False`，因为该检验无法在给定的网络约束下证明耦合。\n\n算法步骤：\n1. 构建 $\\mathbf{c}$，其中 $c_i = 1$ 且 $c_j = -r$。\n2. 求解 $\\min (-\\mathbf{c})^\\top \\mathbf{v}$，约束条件为 $S \\, \\mathbf{v} = \\mathbf{0}$ 和 $l_k \\le v_k \\le u_k$，得到最优值 $F_1$。设 $M_+ = -F_1$。\n3. 在相同约束下求解 $\\min \\mathbf{c}^\\top \\mathbf{v}$，得到最优值 $F_2$。设 $M_- = -F_2$（因为 $F_2 = \\min \\mathbf{c}^\\top \\mathbf{v}$，所以 $\\max (-\\mathbf{c}^\\top \\mathbf{v}) = -\\min \\mathbf{c}^\\top \\mathbf{v}$）。\n4. 计算 $M = \\max\\{M_+, M_-\\}$，如果 $M \\le \\epsilon$，则返回 `True`，否则返回 `False`。\n\n对测试用例的解释：\n- 测试用例 1：$S = [1, -1]$ 强制 $v_0 = v_1$。当 $r = 1$ 时，残差 $f(\\mathbf{v}) = v_0 - v_1$ 在 $\\mathcal{F}$ 上恒为 $0$，所以 $M = 0 \\le 10^{-6}$，结果为 `True`。\n- 测试用例 2：$S = [1, -1, -1]$ 强制 $v_0 = v_1 + v_2$。当 $r = 1$ 时，$f(\\mathbf{v}) = v_0 - v_1 = v_2$。由于 $v_2$ 可以达到其上界 $5$，所以 $M = 5 \\nleq 10^{-2}$，结果为 `False`。\n- 测试用例 3：与测试用例 2 相同，但 $\\epsilon = 5$。这里 $M = 5 \\le 5$，结果为 `True`。这表明，即使存在旁路通量，足够大的容差也可以证明耦合。\n- 测试用例 4：$S = [1, -1, -1]$ 且 $u_1 = 0$ 强制 $v_1 = 0$，而 $v_0$ 和 $v_2$ 可以为正且 $v_0 = v_2$。当 $r = 1$ 时，$f(\\mathbf{v}) = v_0$，其可以达到 $10$，所以 $M = 10 \\nleq 10^{-3}$，结果为 `False`。\n\n这种方法是有原则且通用的：它直接检验由 $S$、$\\mathbf{l}$ 和 $\\mathbf{u}$ 定义的整个可行稳态通量空间内，同位素信息所启发的线性关系是否一致满足。如果满足，则经验比率意味着在规定的容差 $\\epsilon$ 内完全耦合。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef consistency_test(S, lb, ub, i, j, r, eps, solver_tol=1e-9):\n    \"\"\"\n    Evaluate whether the empirical ratio v_i / v_j ≈ r implies full coupling\n    within absolute tolerance eps, by computing the supremum of |v_i - r v_j|\n    over the feasible steady-state flux space defined by S v = 0 and bounds lb, ub.\n    \n    Returns:\n        bool: True if sup |v_i - r v_j| = eps (within numerical tolerance), else False.\n    \"\"\"\n    S = np.asarray(S, dtype=float)\n    lb = np.asarray(lb, dtype=float)\n    ub = np.asarray(ub, dtype=float)\n    if S.ndim == 1:\n        S = S.reshape(1, -1)\n    m, n = S.shape\n    assert lb.shape == (n,) and ub.shape == (n,), \"Bounds must be length n.\"\n    assert 0 = i  n and 0 = j  n, \"Indices i,j must be valid reaction indices.\"\n    \n    # Construct objective coefficients c for f(v) = v_i - r v_j = c^T v.\n    c = np.zeros(n, dtype=float)\n    c[i] = 1.0\n    c[j] = -float(r)\n    \n    # Bounds for linprog: list of (lower, upper) per variable.\n    bounds = [(float(lb[k]), float(ub[k])) for k in range(n)]\n    \n    # Equality constraints: S v = 0\n    A_eq = S\n    b_eq = np.zeros(m, dtype=float)\n    \n    # Use SciPy linprog to minimize; to compute maxima, invert objective sign appropriately.\n    # Compute M_plus = max c^T v = -min (-c)^T v\n    res1 = linprog(-c, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n    if res1.status != 0:\n        # Infeasible or other failure: cannot certify coupling\n        return False\n    M_plus = -res1.fun\n    \n    # Compute M_minus = max (-c)^T v = -min c^T v\n    res2 = linprog(c, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n    if res2.status != 0:\n        return False\n    M_minus = -res2.fun\n    \n    # Supremum of absolute residual\n    M = max(M_plus, M_minus)\n    \n    # Numerical safety: small negative due to solver tolerance should be clipped to zero\n    if M  0 and abs(M)  solver_tol:\n        M = 0.0\n    \n    return M = eps + solver_tol\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case: (S, lb, ub, i, j, r, eps)\n    test_cases = [\n        # Test case 1: strict full coupling, r=1, small epsilon\n        (np.array([[1.0, -1.0]]), np.array([0.0, 0.0]), np.array([10.0, 10.0]), 0, 1, 1.0, 1e-6),\n        # Test case 2: bypass reaction breaks coupling, small epsilon\n        (np.array([[1.0, -1.0, -1.0]]), np.array([0.0, 0.0, 0.0]), np.array([10.0, 10.0, 5.0]), 0, 1, 1.0, 1e-2),\n        # Test case 3: same as case 2 but large epsilon permits \"within tolerance\"\n        (np.array([[1.0, -1.0, -1.0]]), np.array([0.0, 0.0, 0.0]), np.array([10.0, 10.0, 5.0]), 0, 1, 1.0, 5.0),\n        # Test case 4: j blocked at zero; residual equals i and grows large\n        (np.array([[1.0, -1.0, -1.0]]), np.array([0.0, 0.0, 0.0]), np.array([10.0, 0.0, 10.0]), 0, 1, 1.0, 1e-3),\n    ]\n\n    results = []\n    for S, lb, ub, i, j, r, eps in test_cases:\n        result = consistency_test(S, lb, ub, i, j, r, eps)\n        results.append(str(result))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}