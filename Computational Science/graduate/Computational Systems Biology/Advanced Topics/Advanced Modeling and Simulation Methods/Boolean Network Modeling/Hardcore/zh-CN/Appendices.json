{
    "hands_on_practices": [
        {
            "introduction": "理解布尔网络动态的核心在于描绘其完整的动态景观。对于任何给定的初始状态，系统将演化至何处？此练习  将指导您通过构建状态转移图（State Transition Graph, STG）来手动推演一个小型网络的行为，从而识别其所有可能的长期行为模式，即吸引子。这是将局部更新规则转化为全局动态行为的基础实践。",
            "id": "3292409",
            "problem": "考虑一个具有 $3$ 个节点的确定性布尔网络 (BN)，它代表一个简化的基因调控模块。在布尔网络 (BN) 中，每个节点 $x_{i} \\in \\{0,1\\}$ 通过将其布尔更新函数 $f_{i}$ 应用于当前网络状态 $\\mathbf{x} = (x_{1}, x_{2}, x_{3}) \\in \\{0,1\\}^{3}$ 来同步更新。同步更新导出一个全局更新映射 $\\mathbf{f} : \\{0,1\\}^{3} \\to \\{0,1\\}^{3}$，定义为 $\\mathbf{f}(\\mathbf{x}) = (f_{1}(\\mathbf{x}), f_{2}(\\mathbf{x}), f_{3}(\\mathbf{x}))$。状态转移图 (STG) 是一个有向图，其顶点是所有 $2^{3}$ 个状态，其边是有序对 $(\\mathbf{x}, \\mathbf{f}(\\mathbf{x}))$。吸引子是一个最小的非空集合 $\\mathcal{A} \\subseteq \\{0,1\\}^{3}$，它在 $\\mathbf{f}$ 作用下是闭合的；不动点是周期为 $1$ 的吸引子，而循环吸引子的周期大于 $1$。\n\n给定节点更新规则\n$$\nf_{1} = x_{2} \\land \\neg x_{3}, \\quad f_{2} = x_{1} \\lor x_{3}, \\quad f_{3} = \\neg x_{1}.\n$$\n任务：\n- 通过计算所有 $2^{3}$ 个状态 $\\mathbf{x} \\in \\{0,1\\}^{3}$ 的 $\\mathbf{f}(\\mathbf{x})$，构建同步更新下的完整转移关系。\n- 使用第一性原理，通过全局更新映射和状态转移图的定义来论证该同步布尔网络轨迹的确定性。\n- 识别状态转移图中的所有吸引子（包括不动点和循环）。然后，报告不同吸引子的总数。\n\n将您的最终答案以单个整数形式提供。无需四舍五入；无需单位。",
            "solution": "问题陈述已经过验证，被认为是科学上合理的、问题定义良好的、客观的和自洽的。它提出了一个分析布尔网络的标准练习，这是计算系统生物学中一个成熟的课题。所有必需的定义和函数都已提供，没有矛盾或歧义。\n\n该布尔网络 (BN) 由 $3$ 个节点组成，状态为 $x_1, x_2, x_3 \\in \\{0,1\\}$。网络状态是一个向量 $\\mathbf{x} = (x_1, x_2, x_3) \\in \\{0,1\\}^3$。同步更新函数如下：\n$$\nf_1(\\mathbf{x}) = x_2 \\land \\neg x_3\n$$\n$$\nf_2(\\mathbf{x}) = x_1 \\lor x_3\n$$\n$$\nf_3(\\mathbf{x}) = \\neg x_1\n$$\n其中我们将逻辑 TRUE 解释为 $1$，FALSE 解释为 $0$。全局更新映射为 $\\mathbf{f}(\\mathbf{x}) = (f_1(\\mathbf{x}), f_2(\\mathbf{x}), f_3(\\mathbf{x}))$。\n\n**任务 1：构建完整转移关系**\n\n我们为 $2^3 = 8$ 个可能的当前状态 $\\mathbf{x}$ 中的每一个计算下一个状态 $\\mathbf{f}(\\mathbf{x})$。结果汇总在下面的状态转移表中。\n\n1.  对于 $\\mathbf{x} = (0,0,0)$:\n    $f_1 = 0 \\land \\neg 0 = 0 \\land 1 = 0$\n    $f_2 = 0 \\lor 0 = 0$\n    $f_3 = \\neg 0 = 1$\n    $\\mathbf{f}(0,0,0) = (0,0,1)$\n\n2.  对于 $\\mathbf{x} = (0,0,1)$:\n    $f_1 = 0 \\land \\neg 1 = 0 \\land 0 = 0$\n    $f_2 = 0 \\lor 1 = 1$\n    $f_3 = \\neg 0 = 1$\n    $\\mathbf{f}(0,0,1) = (0,1,1)$\n\n3.  对于 $\\mathbf{x} = (0,1,0)$:\n    $f_1 = 1 \\land \\neg 0 = 1 \\land 1 = 1$\n    $f_2 = 0 \\lor 0 = 0$\n    $f_3 = \\neg 0 = 1$\n    $\\mathbf{f}(0,1,0) = (1,0,1)$\n\n4.  对于 $\\mathbf{x} = (0,1,1)$:\n    $f_1 = 1 \\land \\neg 1 = 1 \\land 0 = 0$\n    $f_2 = 0 \\lor 1 = 1$\n    $f_3 = \\neg 0 = 1$\n    $\\mathbf{f}(0,1,1) = (0,1,1)$\n\n5.  对于 $\\mathbf{x} = (1,0,0)$:\n    $f_1 = 0 \\land \\neg 0 = 0 \\land 1 = 0$\n    $f_2 = 1 \\lor 0 = 1$\n    $f_3 = \\neg 1 = 0$\n    $\\mathbf{f}(1,0,0) = (0,1,0)$\n\n6.  对于 $\\mathbf{x} = (1,0,1)$:\n    $f_1 = 0 \\land \\neg 1 = 0 \\land 0 = 0$\n    $f_2 = 1 \\lor 1 = 1$\n    $f_3 = \\neg 1 = 0$\n    $\\mathbf{f}(1,0,1) = (0,1,0)$\n\n7.  对于 $\\mathbf{x} = (1,1,0)$:\n    $f_1 = 1 \\land \\neg 0 = 1 \\land 1 = 1$\n    $f_2 = 1 \\lor 0 = 1$\n    $f_3 = \\neg 1 = 0$\n    $\\mathbf{f}(1,1,0) = (1,1,0)$\n\n8.  对于 $\\mathbf{x} = (1,1,1)$:\n    $f_1 = 1 \\land \\neg 1 = 1 \\land 0 = 0$\n    $f_2 = 1 \\lor 1 = 1$\n    $f_3 = \\neg 1 = 0$\n    $\\mathbf{f}(1,1,1) = (0,1,0)$\n\n完整的状态转移关系是：\n$$(0,0,0) \\to (0,0,1)$$\n$$(0,0,1) \\to (0,1,1)$$\n$$(0,1,0) \\to (1,0,1)$$\n$$(0,1,1) \\to (0,1,1)$$\n$$(1,0,0) \\to (0,1,0)$$\n$$(1,0,1) \\to (0,1,0)$$\n$$(1,1,0) \\to (1,1,0)$$\n$$(1,1,1) \\to (0,1,0)$$\n\n**任务 2：验证轨迹的确定性**\n\n根据定义，该系统是确定性的。全局更新映射 $\\mathbf{f}: \\{0,1\\}^3 \\to \\{0,1\\}^3$ 是一个数学函数。函数的一个核心属性是，对于其定义域中的任何给定输入 $\\mathbf{x}$，它都会产生一个单一、唯一的输出 $\\mathbf{f}(\\mathbf{x})$。状态转移图 (STG) 的构建方式是，顶点代表状态，有向边由 $(\\mathbf{x}, \\mathbf{f}(\\mathbf{x}))$ 给出。因为 $\\mathbf{f}$ 是一个函数，所以 STG 中的每个顶点（状态）都恰好有一条出边。从初始状态 $\\mathbf{x}(0)$ 开始的轨迹是通过迭代应用 $\\mathbf{f}$ 生成的状态序列 $\\mathbf{x}(t)$，即 $\\mathbf{x}(t+1) = \\mathbf{f}(\\mathbf{x}(t))$。由于从 $\\mathbf{x}(t)$ 到 $\\mathbf{x}(t+1)$ 的每一步都是唯一确定的，因此整个轨迹由其初始状态唯一确定。这就是确定性动力系统的定义。\n\n**任务 3：识别所有吸引子**\n\n吸引子是系统无法逃逸的最小状态集。在一个有限确定性系统中，所有轨迹都必须导向一个吸引子，该吸引子可以是不动点或极限环。我们分析状态转移以找到这些最小闭合集。\n\n从转移表中：\n- 我们可以立即识别出两个不动点吸引子，其中 $\\mathbf{f}(\\mathbf{x}) = \\mathbf{x}$：\n  - $\\mathbf{f}(0,1,1) = (0,1,1)$。这是一个不动点。我们称此吸引子为 $\\mathcal{A}_1 = \\{(0,1,1)\\}$。\n  - $\\mathbf{f}(1,1,0) = (1,1,0)$。这也是一个不动点。我们称此吸引子为 $\\mathcal{A}_2 = \\{(1,1,0)\\}$。\n\n- 接下来，我们追踪其余状态的轨迹，看看它们会导向何处。让我们从一个尚未在吸引子中的状态开始，例如 $(0,1,0)$：\n  - $(0,1,0) \\to (1,0,1)$\n  - 现在我们追踪 $(1,0,1)$: $(1,0,1) \\to (0,1,0)$。\n  这形成了一个 2-周期循环： $(0,1,0) \\leftrightarrows (1,0,1)$。这是一个周期为 $2$ 的循环吸引子。我们称此吸引子为 $\\mathcal{A}_3 = \\{(0,1,0), (1,0,1)\\}$。\n\n- 我们必须检查所有其他状态是否都导向这三个吸引子之一。\n  - $(0,0,0) \\to (0,0,1) \\to (0,1,1)$。此轨迹进入不动点 $\\mathcal{A}_1$。\n  - $(1,0,0) \\to (0,1,0)$。此轨迹进入 2-周期循环 $\\mathcal{A}_3$。\n  - $(1,1,1) \\to (0,1,0)$。此轨迹也进入 2-周期循环 $\\mathcal{A}_3$。\n\n所有 $8$ 个状态都已说明。状态空间被划分为这三个吸引子的吸引盆。不同的吸引子是：\n1. 一个不动点：$\\mathcal{A}_1 = \\{(0,1,1)\\}$\n2. 一个不动点：$\\mathcal{A}_2 = \\{(1,1,0)\\}$\n3. 一个 2-周期循环：$\\mathcal{A}_3 = \\{(0,1,0), (1,0,1)\\}$\n\n不同吸引子的总数是 $3$。",
            "answer": "$$\\boxed{3}$$"
        },
        {
            "introduction": "生物过程的演化并非总是在完美的同步节拍下进行，因此，探索不同的更新机制至关重要。同步更新模型中的吸引子在更真实的异步假设下可能并不稳定。这个计算练习  将让您通过编程模拟，直观地比较同步与异步更新方案对网络长期动态的影响，从而深刻理解模型假设的批判性。",
            "id": "3292480",
            "problem": "考虑一个具有$3$个节点的布尔网络，它代表一个具有相互抑制和自我维持的调控基序。设状态为 $x = (x_1, x_2, x_3) \\in \\{0,1\\}^3$，其中$0$代表“关”，$1$代表“开”。局部更新函数由以下逻辑规则定义，这些规则将当前状态$x$映射到下一个状态：\n$$\nf_1(x) = \\neg x_2, \\quad f_2(x) = \\neg x_1, \\quad f_3(x) = x_3,\n$$\n其中$\\neg$是逻辑非，逻辑值与整数$0$（假）和$1$（真）等同。全局同步更新算子 $F: \\{0,1\\}^3 \\to \\{0,1\\}^3$ 根据以下方式同时更新所有节点：\n$$\nF(x) = (f_1(x), f_2(x), f_3(x)).\n$$\n定义局部单节点更新算子 $U_i: \\{0,1\\}^3 \\to \\{0,1\\}^3$ 如下：\n$$\nU_i(x)_j = \n\\begin{cases}\nf_i(x),  \\text{if } j = i, \\\\\nx_j,  \\text{if } j \\neq i,\n\\end{cases}\n$$\n该算子仅使用所有节点的当前值更新节点$i$，而保持其他节点不变。对于$\\{1,2,3\\}$的一个排列$\\pi$，异步固定顺序更新 $F_{\\pi}: \\{0,1\\}^3 \\to \\{0,1\\}^3$ 是如下的顺序复合：\n$$\nF_{\\pi}(x) = U_{\\pi(3)}\\big(U_{\\pi(2)}\\big(U_{\\pi(1)}(x)\\big)\\big),\n$$\n即，依次应用$U_{\\pi(1)}$、$U_{\\pi(2)}$和$U_{\\pi(3)}$，每次都使用最近更新的状态。在随机顺序异步机制下，在宏观步$t$，使用具有指定种子的伪随机数生成器，从$\\{1,2,3\\}$的所有排列中独立地均匀随机抽样一个排列$\\pi_t$，并应用$F_{\\pi_t}$以获得下一个宏观状态。\n\n吸引子是在给定的更新机制下，一个循环的状态集合。对于确定性机制（同步和固定顺序异步），在重复应用相应的全局更新算子后，这简化为长度为$L \\ge 1$的循环，其中$L=1$代表一个不动点。对于具有固定伪随机种子的随机顺序异步机制，由带种子的排列序列诱导出一个宏观动力学；通过跟踪访问来检测循环状态，并报告为该诱导出的动力学观察到的循环长度。目标是计算在每种机制下，从所有$8$个可能的初始状态$x \\in \\{0,1\\}^3$出发遇到的所有吸引子长度，并突出展示同步更新下存在的循环在异步更新下如何消失。\n\n从上述基本定义出发，实现一个程序，该程序：\n1. 枚举所有$8$个初始状态$x \\in \\{0,1\\}^3$。\n2. 对于同步机制，从每个初始状态重复应用$F$，并通过首次重复检测来探测吸引子长度。\n3. 对于$\\pi = (1,2,3)$的异步固定顺序机制，重复应用$F_{\\pi}$并以类似方式检测吸引子长度。\n4. 对于$\\pi = (3,2,1)$的异步固定顺序机制，重复应用$F_{\\pi}$并以类似方式检测吸引子长度。\n5. 对于随机顺序异步机制，对每个初始状态，使用以$s = 2025 + i$为种子的伪随机生成器（其中$i$是初始状态在$\\{0,1\\}^3$字典序中的整数索引）生成最多$T=30$个排列$\\pi_t$，依次应用它们对应的$F_{\\pi_t}$，并检测首次出现的重复以确定吸引子长度；如果在$T$个宏观步内未找到重复，则假定未检测到循环，并将该初始状态从报告的长度中排除。\n\n您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个条目是对应机制下、汇总所有$8$个初始状态结果的、排序后的不同吸引子长度的列表。四种机制按以下顺序进行评估：同步、$\\pi=(1,2,3)$的异步、$\\pi=(3,2,1)$的异步、以及使用上述种子规则和$T=30$的随机顺序异步。例如，输出格式必须为\n$$\n[\\,[L_{sync}],\\,[L_{123}],\\,[L_{321}],\\,[L_{rand}]\\,],\n$$\n其中每个方括号内的项目是一个整数的Python列表字面量，例如$[1,2]$。\n\n测试套件和答案规范：\n- 机制1（同步）：计算并返回汇总所有$8$个初始状态的不同循环长度的排序列表$[L_{sync}]$。\n- 机制2（异步固定顺序，$\\pi=(1,2,3)$）：计算并返回$[L_{123}]$。\n- 机制3（异步固定顺序，$\\pi=(3,2,1)$）：计算并返回$[L_{321}]$。\n- 机制4（随机顺序异步，种子规则为$s = 2025 + i$，时限为$T=30$）：计算并返回$[L_{rand}]$。\n\n最终的程序输出必须是精确格式的单行文本：一个由逗号分隔的四个列表组成的列表，并用一对总的方括号括起来。不涉及物理单位。不涉及角度。不涉及百分比。每个测试用例的所有答案都是整数列表。",
            "solution": "用户提供的问题是一个关于不同更新方案下布尔网络动力学分析的定义明确的练习。问题陈述在科学上是合理的、内容自洽且在算法上是可解的。这个问题将通过为四种机制中的每一种实现指定的更新规则和吸引子检测算法来解决。\n\n### 1. 系统的形式化\n\n该布尔网络由$N=3$个节点组成。网络的一个状态是一个向量$x = (x_1, x_2, x_3)$，其中每个$x_i \\in \\{0, 1\\}$。因此，状态空间为$\\{0, 1\\}^3$，包含$2^3 = 8$个可能的状态。\n\n局部更新函数如下：\n$f_1(x) = \\neg x_2 = 1 - x_2$\n$f_2(x) = \\neg x_1 = 1 - x_1$\n$f_3(x) = x_3$\n\n这些函数定义了每个节点的下一个状态如何根据网络的当前状态来确定。我们现在将分析四种不同更新机制下的动力学。对于吸引子检测，由于状态空间是有限的，任何轨迹最终都必须重复一个状态。如果一个状态$x$在$L$步之后重新出现，那么就找到了一个长度为$L$的循环。\n\n### 2. 机制1：同步更新\n\n在同步机制中，所有节点同时更新。全局更新算子$F: \\{0,1\\}^3 \\to \\{0,1\\}^3$为：\n$$\nF(x_1, x_2, x_3) = (f_1(x), f_2(x), f_3(x)) = (1-x_2, 1-x_1, x_3)\n$$\n为了找到吸引子，我们将从$8$个初始状态中的每一个出发，并重复应用$F$。我们将记录状态序列并检测首次重复。\n\n例如，从$x_0 = (0,0,0)$开始：\n$x_1 = F(0,0,0) = (1-0, 1-0, 0) = (1,1,0)$\n$x_2 = F(1,1,0) = (1-1, 1-1, 0) = (0,0,0)$\n由于$x_2 = x_0$，我们找到了一个长度为$L = 2-0 = 2$的循环。\n\n通过分析所有$8$个初始状态，我们识别出所有的吸引子。找到的不同循环长度的集合构成了该机制的结果。不动点是长度为$L=1$的循环。\n\n### 3. 机制2：异步固定顺序更新 $\\pi=(1,2,3)$\n\n在此机制下，节点按固定顺序$1, 2, 3$序贯更新。更新算子$F_{(1,2,3)}$是$U_3 \\circ U_2 \\circ U_1$的复合。给定一个状态$x^{(0)} = (x_1, x_2, x_3)$：\n1. 更新节点1：$x^{(1)} = U_1(x^{(0)}) = (f_1(x^{(0)}), x_2, x_3) = (1-x_2, x_2, x_3)$。\n2. 更新节点2：$x^{(2)} = U_2(x^{(1)}) = (x^{(1)}_1, f_2(x^{(1)}), x^{(1)}_3) = (1-x_2, 1-x^{(1)}_1, x_3) = (1-x_2, 1-(1-x_2), x_3) = (1-x_2, x_2, x_3)$。\n3. 更新节点3：$x^{(3)} = U_3(x^{(2)}) = (x^{(2)}_1, x^{(2)}_2, f_3(x^{(2)})) = (1-x_2, x_2, x^{(2)}_3) = (1-x_2, x_2, x_3)$。\n\n因此，总的更新函数是$F_{(1,2,3)}(x_1, x_2, x_3) = (1-x_2, x_2, x_3)$。\n如果$F_{(1,2,3)}(x) = x$，则吸引子是一个不动点，这意味着$(x_1, x_2, x_3) = (1-x_2, x_2, x_3)$。这要求$x_1 = 1-x_2$。任何满足此条件的状态都是一个不动点。这些不动点是$(1,0,0)$、$(1,0,1)$、$(0,1,0)$和$(0,1,1)$。\n对于任何不满足此条件的状态，例如$x=(0,0,0)$，应用一次$F_{(1,2,3)}$会得到$F_{(1,2,3)}(0,0,0) = (1,0,0)$，这是一个不动点。因此，所有轨迹都在一步之内收敛到一个不动点。所以，唯一的吸引子长度是$1$。\n\n### 4. 机制3：异步固定顺序更新 $\\pi=(3,2,1)$\n\n这里，节点按$3, 2, 1$的顺序更新。算子是$F_{(3,2,1)} = U_1 \\circ U_2 \\circ U_3$。给定$x^{(0)} = (x_1, x_2, x_3)$：\n1. 更新节点3：$x^{(1)} = U_3(x^{(0)}) = (x_1, x_2, f_3(x^{(0)})) = (x_1, x_2, x_3) = x^{(0)}$。\n2. 更新节点2：$x^{(2)} = U_2(x^{(1)}) = (x_1, f_2(x^{(1)}), x_3) = (x_1, 1-x_1, x_3)$。\n3. 更新节点1：$x^{(3)} = U_1(x^{(2)}) = (f_1(x^{(2)}), x^{(2)}_2, x^{(2)}_3) = (1-x^{(2)}_2, 1-x_1, x_3) = (1-(1-x_1), 1-x_1, x_3) = (x_1, 1-x_1, x_3)$。\n\n更新函数是$F_{(3,2,1)}(x_1, x_2, x_3) = (x_1, 1-x_1, x_3)$。\n与前一个机制类似，不动点必须满足$x_2 = 1-x_1$，这与之前的条件相同。不动点的集合是相同的：$\\{(1,0,0), (1,0,1), (0,1,0), (0,1,1)\\}$。所有其他状态都在一步之内转换到这些不动点之一。例如，$F_{(3,2,1)}(0,0,0) = (0,1,0)$。同样，所有吸引子都是不动点，唯一的吸引子长度是$1$。\n\n### 5. 机制4：随机顺序异步更新\n\n在这个随机机制中，对于每个初始状态$x_i$（其中$i \\in \\{0, \\dots, 7\\}$是字典序索引），通过应用更新$F_{\\pi_t}$生成一个确定性的状态序列。排列序列$\\pi_t$由一个以$s = 2025 + i$为种子的伪随机数生成器（PRNG）确定。\n针对每个初始状态的算法是：\n1. 用种子$s = 2025 + i$初始化伪随机数生成器。\n2. 从初始状态$x(0) = x_i$开始。维护一个已访问状态的历史记录以及它们首次出现的步数，例如 `history = {x(0): 0}`。\n3. 对于每个宏观步$t = 0, 1, \\dots, T-1$（其中$T=30$）：\n    a. 使用带种子的伪随机数生成器从$\\{1,2,3\\}$中均匀随机生成一个排列$\\pi_t$。\n    b. 计算下一个状态$x(t+1) = F_{\\pi_t}(x(t))$。\n    c. 如果$x(t+1)$在步数$k = \\text{history}[x(t+1)]$时已经出现过，则找到了一个长度为$L = (t+1) - k$的循环。记录此长度，并终止对此初始状态的处理。\n    d. 否则，记录新状态：`history[x(t+1)] = t+1`。\n4. 如果在$T=30$步内没有找到循环，则不为此初始状态记录长度。\n5. 此机制的最终结果是在所有$8$个初始状态中找到的唯一吸引子长度的排序列表。\n\n实现将精确遵循这些步骤来计算所需的吸引子长度列表。跨机制的结果比较表明，更新方案在塑造网络长期行为方面起着关键作用，异步更新倾向于消除同步情况下存在的循环。",
            "answer": "[[1, 2], [1], [1], [1]]"
        },
        {
            "introduction": "从分析网络行为到主动调控其走向，是系统生物学从描述性科学迈向干预性科学的关键一步。我们能否通过干预少数关键节点，将网络从任何初始状态引导至一个期望的“健康”状态？这项高级练习  探讨了网络控制中的一个核心问题，您将通过实现并比较最优和启发式算法，来寻找驱动网络动态的最小“控制内核”。",
            "id": "3292470",
            "problem": "给定三个用于计算系统生物学的有限、同步、确定性布尔网络。每个网络由一个有限节点集 $V=\\{0,1,\\dots,n-1\\}$、一个节点更新函数向量 $F=(f_0,\\dots,f_{n-1})$（其中 $f_i:\\{0,1\\}^n\\to\\{0,1\\}$）以及一个指定的目标吸引子 $\\alpha^*\\in\\{0,1\\}^n$ 组成，该吸引子是无固定动力学的不动点。同步更新规则为 $x(t+1)=F\\big(x(t)\\big)$，其中 $x(0)\\in\\{0,1\\}^n$。固定控制（pinning control）选择一个子集 $S\\subseteq V$，并对所有 $i\\in S$ 和所有 $t\\ge 0$ 强制 $x_i(t)=\\alpha^*_i$；所有其他节点则根据其自身的函数 $f_i$ 和包含固定值的当前状态 $x(t)$ 进行更新。如果对于每个初始状态 $x(0)\\in\\{0,1\\}^n$，固定动力学都能在有限时间内收敛到目标不動点 $\\alpha^*$，我们就称控制集 $S$ 是有效的。\n\n本练习的基础知识：\n- 布尔网络是在 $V$ 上的一个有向图，当 $f_i$ 依赖于 $x_j$ 时，存在边 $j\\to i$；其动力学由 $x_i(t+1)=f_i\\big(x(t)\\big)$ 给出。\n- 一个不动点 $\\alpha^*\\in\\{0,1\\}^n$ 对所有 $i\\in V$ 满足 $\\alpha^*_i=f_i(\\alpha^*)$。\n- 反馈顶点集（Feedback Vertex Set, FVS）是 $V$ 的一个子集 $S$，它与依赖图的每个有向环都相交。将任意FVS中的节点固定到目标值会消除所有有向环，从而产生一个有向无环图；在有向无环图中，同步更新会向前传播信息，经过至多最长有向路径的长度后，状态将由固定值唯一确定，因此收敛到与这些固定值一致的不动点。\n\n您的任务是为下面的每个测试网络计算：\n1. 一个最优最小基数控制集 $S_{\\mathrm{opt}}$，使得将 $x_S$ 固定为 $x_S^*=\\alpha^*_S$ 能将网络从所有初始状态驱动到 $\\alpha^*$。在所有最小基数的集合中，选择节点按索引排序时字典序最小的那个。\n2. 一个启发式控制集 $S_{\\mathrm{heu}}$，由一个贪心反馈顶点集算法产生。该算法通过深度优先搜索（DFS）重复检测有向环，并移除发现后向边的当前节点，直到剩余图变为无环图。DFS按节点索引递增顺序探索节点和出边。然后将集合 $S_{\\mathrm{heu}}$ 中的节点固定到 $\\alpha^*$。\n\n您必须通过对所有初始条件 $x(0)\\in\\{0,1\\}^n$ 进行穷举模拟来验证候选控制集 $S$ 的有效性，模拟在固定控制下进行同步更新，时间范围为 $T_{\\max}=2^n$，这足以在一个有限确定性布尔网络中检测收敛。当且仅当每个轨迹都在 $T_{\\max}$ 步内到达 $\\alpha^*$ 时，候选集 $S$ 才有效。\n\n基于以下原则，将最优控制问题表述为整数线性规划（ILP），但不要在程序中使用求解器：\n- 引入二元决策变量 $y_i\\in\\{0,1\\}$，表示节点 $i$ 是被固定（$y_i=1$）还是自由（$y_i=0$）。并且，对于每个初始条件 $s\\in\\{0,1\\}^n$ 和时间 $t=0,\\dots,T$，引入状态变量 $z_i^{(t,s)}\\in\\{0,1\\}$，代表从 $x(0)=s$ 开始的轨迹上 $x_i(t)$ 的值。选择一个足够大的 $T$，使得当环被（由所选的 $S$）消除后，$T$ 能限制最长有向路径的长度；对于一个有 $n$ 个节点的有向无环图，一个安全的选择是 $T=n$。\n- 对每个初始条件 $s$，强制 $z_i^{(0,s)}=s_i$。\n- 对每个节点 $i$、时间 $t$ 和初始条件 $s$，通过二元变量的大M约束来强制执行固定和动力学：\n  - 如果 $y_i=1$，则 $z_i^{(t+1,s)}=\\alpha^*_i$，编码为\n    $$z_i^{(t+1,s)}-\\alpha^*_i\\le 1-y_i,\\quad \\alpha^*_i-z_i^{(t+1,s)}\\le 1-y_i.$$\n  - 如果 $y_i=0$，则 $z_i^{(t+1,s)}=f_i\\big(z^{(t,s)}\\big)$，编码为\n    $$z_i^{(t+1,s)}-f_i\\big(z^{(t,s)}\\big)\\le y_i,\\quad f_i\\big(z^{(t,s)}\\big)-z_i^{(t+1,s)}\\le y_i.$$\n- 使用标准的二元线性约束来线性化布尔函数：\n  - 对于 $y=\\bigwedge_{j\\in P} x_j$：施加约束 $y\\le x_j$（对所有 $j\\in P$）和 $y\\ge \\sum_{j\\in P} x_j-|P|+1$。\n  - 对于 $y=\\bigvee_{j\\in P} x_j$：施加约束 $y\\ge x_j$（对所有 $j\\in P$）和 $y\\le \\sum_{j\\in P} x_j$。\n  - 对于 $y=\\neg x$：施加约束 $y=1-x$。\n  - 对于 $y=x$：施加约束 $y=x$。\n- 强制施加终端约束 $z_i^{(T,s)}=\\alpha^*_i$，对所有 $i$ 和所有初始条件 $s$。\n- 最小化 $\\sum_{i=0}^{n-1} y_i$。\n\n尽管您不应调用外部求解器，但上述ILP的最优解正是最小基数的有效控制集。您将通过穷舉枚举子集 $S$ 并检查有效性约束来计算它，这对于给定的小型测试集是等价的。\n\n测试集规范。对于每个案例，网络通过显式的节点更新公式和目标不动点给出。当且仅当 $f_i$ 依赖于 $x_j$ 时，依赖图中存在边 $j\\to i$。\n\n- 案例A：三节点环形复制。节点 $V=\\{0,1,2\\}$，同步更新\n  $$f_0(x)=x_2,\\quad f_1(x)=x_0,\\quad f_2(x)=x_1,$$\n  和目标不动点\n  $$\\alpha^*=(1,1,1).$$\n\n- 案例B：共享一个节点的两个三元环。节点 $V=\\{0,1,2,3,4\\}$，同步更新\n  $$f_0(x)=x_2\\wedge x_4,\\quad f_1(x)=x_0,\\quad f_2(x)=x_1,\\quad f_3(x)=x_0,\\quad f_4(x)=x_3,$$\n  和目标不动点\n  $$\\alpha^*=(1,1,1,1,1).$$\n  依赖图有环 $0\\to 1\\to 2\\to 0$ 和 $0\\to 3\\to 4\\to 0$。\n\n- 案例C：有向无环图（无环）。节点 $V=\\{0,1,2,3\\}$，同步更新\n  $$f_0(x)=1,\\quad f_1(x)=\\neg x_0,\\quad f_2(x)=x_0\\wedge x_1,\\quad f_3(x)=x_2,$$\n  和目标不動点\n  $$\\alpha^*=(1,0,0,0).$$\n\n为每个测试案例实现的算法任务：\n- 通过对 $S\\subseteq V$ 进行穷举搜索（按 $|S|$ 递增），并通过在固定控制下模拟所有 $2^n$ 个初始条件 $T_{\\max}=2^n$ 步来验证有效性，从而计算 $S_{\\mathrm{opt}}$。\n- 通过上述贪心FVS启发式算法计算 $S_{\\mathrm{heu}}$（DFS环检测，移除发现后向边的当前节点，按索引递增顺序探索节点和邻接表）。将 $S_{\\mathrm{heu}}$ 中的节点固定到 $\\alpha^*$。\n- 通过与上述相同的模拟方法验证 $S_{\\mathrm{heu}}$ 的有效性。\n\n最终输出格式：\n- 您的程序必须生成一行包含结果列表的内容，每个测试案例一个结果，其中每个结果都是一个列表\n  $$\\big[|S_{\\mathrm{opt}}|,\\ |S_{\\mathrm{heu}}|,\\ \\text{is\\_equal},\\ S_{\\mathrm{opt}},\\ S_{\\mathrm{heu}}\\big],$$\n  其中 $|S_{\\mathrm{opt}}|$ 和 $|S_{\\mathrm{heu}}|$ 是整数，$\\text{is\\_equal}$ 是一个布尔值，指示大小是否相等，而 $S_{\\mathrm{opt}}$ 和 $S_{\\mathrm{heu}}$ 以基于0的节点索引的排序列表形式给出。整行必须严格按照Python列表字面量格式打印，例如\n  $$\\big[\\,[1,2,\\mathrm{False},[0],[1,3]]\\,\\big].$$\n本任务中没有物理单位、角度单位或百分比。所有返回的数字都是无单位的整数或布尔值，以及这些值的列表。",
            "solution": "用户提供的问题被评估为有效。它在科学上基于布尔网络建模和控制理论的原理，这是计算系统生物学的一个子领域。该问题定义明确，所有必要的数据、函数和目标都有清晰客观的定义。计算任务虽然密集，但对于测试集中指定的小型网络规模是可行的。问题要求实现用于寻找布尔网络最优和启发式控制集的算法，这是一项标准且不平凡的任务。\n\n解决方案首先表示每个布尔网络，包括其更新函数和依赖图。然后，实现两种不同的算法来找到所需的控制集：一种用于最优控制集（$S_{\\mathrm{opt}}$），另一种用于启发式控制集（$S_{\\mathrm{heu}}$）。\n\n### 1. 网络表示\n对于每个测试案例，网络由其节点数 $n$、更新函数向量 $F=(f_0, \\dots, f_{n-1})$、目标不动点 $\\alpha^*$ 和其依赖图定义。函数 $f_i$ 实现为Python函数，接受一个状态向量（0和1的元组）并返回一个二进制值。依赖图（其中如果 $f_i$ 依赖于 $x_j$，则存在边 $j \\to i$）被预先计算并存储为邻接表。\n\n### 2. 核心函数：有效性检查\n一个关键组件是验证候选控制集 $S$ 是否有效的函数。如果对于所有 $2^n$ 个可能的初始状态，在将 $S$ 中的节点固定到 $\\alpha^*$ 中相应值的情况下，网络动力学均收敛到目标状态 $\\alpha^*$，则该集合 $S$ 是有效的。\n\n验证过程如下：\n- 对于 $2^n$ 个初始状态中的每一个 $x(0) \\in \\{0, 1\\}^n$：\n  - 同步模拟固定的网络动力学，最多 $T_{\\max} = 2^n$ 步。第 $t+1$ 步的状态由第 $t$ 步的状态计算得出：\n    $$\n    x_i(t+1) = \\begin{cases} \\alpha^*_i  \\text{if } i \\in S \\\\ f_i(x(t))  \\text{if } i \\notin S \\end{cases}\n    $$\n  - 如果状态 $x(t)$ 在任何时间 $t \\le T_{\\max}$ 等于 $\\alpha^*$，则从此初始条件出发的轨迹是成功的。\n  - 如果有任何轨迹在 $T_{\\max}$ 步内未能达到 $\\alpha^*$，则集合 $S$ 被视为无效，并提前终止对该集合的处理。\n- 如果所有 $2^n$ 条轨迹都收敛到 $\\alpha^*$，则集合 $S$ 是有效的。\n\n时间范围 $T_{\\max}=2^n$ 是一个大小为 $2^n$ 的有限确定性系统状态空间中收敛的保证上限。\n\n### 3. 最优控制集 ($S_{\\mathrm{opt}}$)\n最优控制集 $S_{\\mathrm{opt}}$ 是具有最小可能节点数的有效控制集。在所有具有此最小大小的集合中，我们必须选择字典序最小的那个。\n\n这是通过穷举搜索找到的：\n1. 从 $k=0$ 到 $n$ 遍历可能的集合大小 $k$。\n2. 对于每个大小 $k$，生成所有基数为 $k$ 的可能子集 $S \\subseteq V$。这些子集按其元素的字典序生成。\n3. 对于每个生成的子集 $S$，使用上述函数检查其有效性。\n4. 找到的第一个有效集合保证是最小大小的（由于对 $k$ 的循环）并且是该最小大小的所有集合中字典序最小的（由于子集的有序生成）。这个集合就是 $S_{\\mathrm{opt}}$。\n\n### 4. 启发式控制集 ($S_{\\mathrm{heu}}$)\n启发式控制集 $S_{\\mathrm{heu}}$ 是通过应用贪心算法来寻找网络依赖图的反馈顶点集（FVS）来确定的。FVS是一组节点，移除这些节点会使图变为无环图。具体算法如下：\n\n1. 将 $S_{\\mathrm{heu}}$ 初始化为空集。\n2. 在当前图（原始图减去已在 $S_{\\mathrm{heu}}$ 中的节点）中重复搜索有向环。\n3. 环检测使用深度优先搜索（DFS）执行。DFS遍历优先考虑索引较小的节点，对于每个节点，按邻居索引的递增顺序探索其出边。\n4. 当找到一条后向边（从节点 `u` 到DFS树中的祖先 `v`）时，即检测到一个环。问题指定，将“发现后向边的当前节点”（即 `u`）添加到 $S_{\\mathrm{heu}}$ 中。\n5. 将一个节点添加到 $S_{\\mathrm{heu}}$ 后，从头开始重新搜索环。\n6. 这个过程持续进行，直到对剩余图的完整DFS遍历不再揭示任何环为止。\n7. 得到的集合 $S_{\\mathrm{heu}}$ 就是启发式FVS。然后固定该集合中的节点。问题还要求使用与 $S_{\\mathrm{opt}}$ 相同的基于模拟的方法来验证 $S_{\\mathrm{heu}}$ 的有效性。根据问题描述中提供的理论，任何FVS对于这类动力学都是一个有效的控制集，所以这项检查主要用于确认算法的正确性。\n\n最后，对于每个测试案例，收集 $S_{\\mathrm{opt}}$ 和 $S_{\\mathrm{heu}}$ 的大小和内容，并将其格式化为所需的输出结构。",
            "answer": "[[1,1,False,[0],[2]],[1,2,False,[0],[2,4]],[0,0,True,[],[]]]"
        }
    ]
}