{
    "hands_on_practices": [
        {
            "introduction": "在构建复杂的混合模拟器之前，理解随机描述（化学主方程）与确定性近似（常微分方程）之间的基本关系至关重要。本练习将指导您推导一个简单生灭过程的精确均值和方差。通过将随机均值与相应常微分方程的解进行比较，您将精确地看到确定性模型在何种情况下以及为何能准确捕捉随机系统的平均行为 。",
            "id": "3319363",
            "problem": "考虑一个固定体积内充分混合的单物种系统，其中物种 $X$ 的分子由一个零级源产生，并通过一级衰变被移除。在作为连续时间马尔可夫跳跃过程的随机性描述中，两个反应为 $X \\xrightarrow{k_b} X+1$（倾向函数为 $a_b(x) = k_b$）和 $X \\xrightarrow{k_d} \\emptyset$（倾向函数为 $a_d(x) = k_d x$），其中 $k_b > 0$ 和 $k_d > 0$ 是常数，$x$ 表示当前的分子数。假设初始条件 $X(0) = x_0$ 是一个已知的非负整数。\n\n从化学主方程框架和马尔可夫跳跃过程矩的生成元恒等式出发，推导前两个矩 $\\mathbb{E}[X(t)]$ 和 $\\mathbb{E}[X(t)^2]$ 的时间演化方程。求解这些方程，以获得在随机模拟算法（SSA）下 $\\mathbb{E}[X(t)]$ 和 $\\mathrm{Var}[X(t)]$ 的显式闭式表达式。然后，将 $\\mathbb{E}[X(t)]$ 与确定性常微分方程 $\\dot{c}(t) = k_b - k_d c(t)$（满足 $c(0) = x_0$）的解 $c(t)$ 进行比较。\n\n将您的最终答案表示为单行矩阵中的有序对 $\\left(\\mathbb{E}[X(t)], \\mathrm{Var}[X(t)]\\right)$。最终表达式无需四舍五入，也不应包含单位。",
            "solution": "首先验证问题，确保其科学上合理、适定且完整。\n\n**步骤1：提取已知条件**\n- 系统：固定体积内充分混合的单物种系统。\n- 物种：$X$。\n- 状态变量：$x$，物种 $X$ 的分子数。\n- 反应1（生成）：$X \\xrightarrow{k_b} X+1$，倾向函数为 $a_b(x) = k_b$。\n- 反应2（衰变）：$X \\xrightarrow{k_d} \\emptyset$，倾向函数为 $a_d(x) = k_d x$。\n- 常数：$k_b > 0$, $k_d > 0$。\n- 初始条件：$X(0) = x_0$，一个已知的非负整数。\n- 框架：化学主方程 (CME)。\n- 任务：\n  1. 推导 $\\mathbb{E}[X(t)]$ 和 $\\mathbb{E}[X(t)^2]$ 的时间演化方程。\n  2. 求解 $\\mathbb{E}[X(t)]$ 和 $\\mathrm{Var}[X(t)]$ 的闭式表达式。\n  3. 将 $\\mathbb{E}[X(t)]$ 与确定性常微分方程 $\\dot{c}(t) = k_b - k_d c(t)$（满足 $c(0)=x_0$）的解 $c(t)$ 进行比较。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题描述了一个线性生灭过程，这是随机化学动力学中一个基础且被充分理解的模型。这些反应和倾向函数是零级生成和一级衰变的 标准表示。符号表示 $X \\xrightarrow{k_b} X+1$ 及其倾向函数 $a_b(x) = k_b$ 明确定义了一个零级生成过程。所有参数和初始条件都已给出，使得问题自洽且适定。任务涉及在此框架内的标准数学推导。该问题具有科学依据，是客观的，并且没有违反任何无效标准。\n\n**步骤3：结论与操作**\n问题被判定为有效。将提供完整解答。\n\n**矩方程的推导**\n\n对于一个连续时间马尔可夫跳跃过程，其状态的任意函数 $f(X(t))$ 的期望值的时间演化由以下生成元恒等式给出：\n$$\n\\frac{d}{dt}\\mathbb{E}[f(X(t))] = \\mathbb{E}[\\mathcal{L}f(X(t))]\n$$\n其中 $\\mathcal{L}$ 是该过程的生成元。对于一个化学反应网络，生成元作用于函数 $f(x)$ 的方式如下：\n$$\n\\mathcal{L}f(x) = \\sum_{j} a_j(x) [f(x+v_j) - f(x)]\n$$\n这里，$j$ 是反应的索引，$a_j(x)$ 是反应 $j$ 的倾向函数，$v_j$ 是由于反应 $j$ 引起的状态变量 $x$ 的变化量。\n\n对于给定系统，我们有两个反应：\n1.  生成：$a_1(x) = k_b$, $v_1 = +1$。\n2.  消亡：$a_2(x) = k_d x$, $v_2 = -1$。\n\n因此，生成元为：\n$$\n\\mathcal{L}f(x) = k_b [f(x+1) - f(x)] + k_d x [f(x-1) - f(x)]\n$$\n\n**均值 $\\mathbb{E}[X(t)]$ 的时间演化**\n\n为了求一阶矩的方程，我们设 $f(x) = x$。\n$$\n\\mathcal{L}x = k_b [(x+1) - x] + k_d x [(x-1) - x] = k_b(1) + k_d x(-1) = k_b - k_d x\n$$\n应用生成元恒等式和期望算子的线性性质：\n$$\n\\frac{d}{dt}\\mathbb{E}[X(t)] = \\mathbb{E}[\\mathcal{L}X(t)] = \\mathbb{E}[k_b - k_d X(t)] = k_b - k_d \\mathbb{E}[X(t)]\n$$\n令 $\\mu(t) = \\mathbb{E}[X(t)]$。我们得到一阶线性常微分方程 (ODE)：\n$$\n\\frac{d\\mu(t)}{dt} = k_b - k_d \\mu(t)\n$$\n初始条件为 $\\mu(0) = \\mathbb{E}[X(0)] = x_0$。\n\n**与确定性模型的比较**\n\n确定性速率方程为 $\\dot{c}(t) = k_b - k_d c(t)$，且 $c(0) = x_0$。这个 ODE 在数学上与随机过程均值 $\\mu(t)$ 的 ODE 完全相同。因此，它们的解也将是相同的：$\\mu(t) = c(t)$。这个性质成立是因为所有反应倾向函数都是状态变量 $x$ 的线性函数。\n\n**求解均值 $\\mathbb{E}[X(t)]$**\n\n我们求解 ODE $\\frac{d\\mu}{dt} + k_d \\mu = k_b$。积分因子是 $I(t) = \\exp(\\int k_d dt) = \\exp(k_d t)$。\n$$\n\\frac{d}{dt} (\\mu(t) \\exp(k_d t)) = k_b \\exp(k_d t)\n$$\n对两边关于 $t$ 积分：\n$$\n\\mu(t) \\exp(k_d t) = \\int k_b \\exp(k_d t) dt = \\frac{k_b}{k_d} \\exp(k_d t) + C\n$$\n其中 $C$ 是积分常数。\n$$\n\\mu(t) = \\frac{k_b}{k_d} + C \\exp(-k_d t)\n$$\n使用初始条件 $\\mu(0) = x_0$：\n$$\nx_0 = \\frac{k_b}{k_d} + C \\implies C = x_0 - \\frac{k_b}{k_d}\n$$\n将 $C$ 代回解中，得到均值的显式表达式：\n$$\n\\mathbb{E}[X(t)] = \\frac{k_b}{k_d} + \\left(x_0 - \\frac{k_b}{k_d}\\right) \\exp(-k_d t)\n$$\n\n**方差 $\\mathrm{Var}[X(t)]$ 的时间演化**\n\n方差定义为 $\\mathrm{Var}[X(t)] = \\mathbb{E}[X(t)^2] - (\\mathbb{E}[X(t)])^2$。一个比先求 $\\mathbb{E}[X(t)^2]$ 更直接的方法是直接推导方差本身的 ODE。令 $V(t) = \\mathrm{Var}[X(t)]$。\n$$\n\\frac{dV(t)}{dt} = \\frac{d}{dt}\\mathbb{E}[X(t)^2] - 2\\mathbb{E}[X(t)]\\frac{d}{dt}\\mathbb{E}[X(t)]\n$$\n首先，通过设 $f(x)=x^2$ 来求二阶矩 $m_2(t) = \\mathbb{E}[X(t)^2]$ 的 ODE。\n$$\n\\mathcal{L}x^2 = k_b [(x+1)^2 - x^2] + k_d x [(x-1)^2 - x^2]\n$$\n$$\n\\mathcal{L}x^2 = k_b (2x+1) + k_d x (-2x+1) = 2k_b x + k_b - 2k_d x^2 + k_d x = -2k_d x^2 + (2k_b + k_d)x + k_b\n$$\n取期望值：\n$$\n\\frac{dm_2(t)}{dt} = \\mathbb{E}[\\mathcal{L}X(t)^2] = -2k_d \\mathbb{E}[X(t)^2] + (2k_b + k_d)\\mathbb{E}[X(t)] + k_b\n$$\n$$\n\\frac{dm_2(t)}{dt} = -2k_d m_2(t) + (2k_b + k_d)\\mu(t) + k_b\n$$\n现在将这个结果和 $\\mu(t)$ 的 ODE 代入方差的导数中：\n$$\n\\frac{dV(t)}{dt} = [-2k_d m_2(t) + (2k_b + k_d)\\mu(t) + k_b] - 2\\mu(t)[k_b - k_d \\mu(t)]\n$$\n$$\n\\frac{dV(t)}{dt} = -2k_d m_2(t) + 2k_b\\mu(t) + k_d\\mu(t) + k_b - 2k_b\\mu(t) + 2k_d\\mu(t)^2\n$$\n$$\n\\frac{dV(t)}{dt} = -2k_d m_2(t) + 2k_d\\mu(t)^2 + k_d\\mu(t) + k_b\n$$\n$$\n\\frac{dV(t)}{dt} = -2k_d [m_2(t) - \\mu(t)^2] + k_d\\mu(t) + k_b\n$$\n这可以简化为方差的 ODE：\n$$\n\\frac{dV(t)}{dt} = -2k_d V(t) + k_d\\mu(t) + k_b\n$$\n初始条件为 $V(0) = \\mathrm{Var}[X(0)] = \\mathrm{Var}[x_0] = 0$，因为 $x_0$ 是一个确定值。\n\n**求解方差 $\\mathrm{Var}[X(t)]$**\n\n我们通过代入 $\\mu(t)$ 的表达式来求解 ODE $\\frac{dV}{dt} + 2k_d V = k_d\\mu(t) + k_b$：\n$$\n\\frac{dV}{dt} + 2k_d V = k_d\\left[\\frac{k_b}{k_d} + \\left(x_0 - \\frac{k_b}{k_d}\\right) \\exp(-k_d t)\\right] + k_b\n$$\n$$\n\\frac{dV}{dt} + 2k_d V = k_b + (k_d x_0 - k_b)\\exp(-k_d t) + k_b = 2k_b + (k_d x_0 - k_b)\\exp(-k_d t)\n$$\n积分因子是 $I(t) = \\exp(\\int 2k_d dt) = \\exp(2k_d t)$。\n$$\n\\frac{d}{dt}(V(t)\\exp(2k_d t)) = 2k_b \\exp(2k_d t) + (k_d x_0 - k_b)\\exp(k_d t)\n$$\n关于 $t$ 积分：\n$$\nV(t)\\exp(2k_d t) = \\int [2k_b \\exp(2k_d t) + (k_d x_0 - k_b)\\exp(k_d t)] dt\n$$\n$$\nV(t)\\exp(2k_d t) = 2k_b \\frac{\\exp(2k_d t)}{2k_d} + (k_d x_0 - k_b) \\frac{\\exp(k_d t)}{k_d} + C'\n$$\n$$\nV(t)\\exp(2k_d t) = \\frac{k_b}{k_d}\\exp(2k_d t) + \\left(x_0 - \\frac{k_b}{k_d}\\right)\\exp(k_d t) + C'\n$$\n两边除以 $\\exp(2k_d t)$:\n$$\nV(t) = \\frac{k_b}{k_d} + \\left(x_0 - \\frac{k_b}{k_d}\\right)\\exp(-k_d t) + C'\\exp(-2k_d t)\n$$\n使用初始条件 $V(0)=0$:\n$$\n0 = \\frac{k_b}{k_d} + \\left(x_0 - \\frac{k_b}{k_d}\\right) + C' = x_0 + C' \\implies C' = -x_0\n$$\n代入 $C'$ 得到方差的最终表达式：\n$$\n\\mathrm{Var}[X(t)] = \\frac{k_b}{k_d} + \\left(x_0 - \\frac{k_b}{k_d}\\right)\\exp(-k_d t) - x_0\\exp(-2k_d t)\n$$\n这个表达式可以重新整理，以突出来自过程内在随机性和从初始状态松弛的贡献：\n$$\n\\mathrm{Var}[X(t)] = \\frac{k_b}{k_d}(1-\\exp(-k_d t)) + x_0 \\exp(-k_d t)(1 - \\exp(-k_d t))\n$$\n提出公因子 $(1 - \\exp(-k_d t))$ 得到一个紧凑形式：\n$$\n\\mathrm{Var}[X(t)] = \\left(\\frac{k_b}{k_d} + x_0 \\exp(-k_d t)\\right)\\left(1 - \\exp(-k_d t)\\right)\n$$\n\n**最终表达式**\n该过程的均值为：\n$$\n\\mathbb{E}[X(t)] = \\frac{k_b}{k_d} + \\left(x_0 - \\frac{k_b}{k_d}\\right) \\exp(-k_d t)\n$$\n该过程的方差为：\n$$\n\\mathrm{Var}[X(t)] = \\left(\\frac{k_b}{k_d} + x_0 \\exp(-k_d t)\\right)\\left(1 - \\exp(-k_d t)\\right)\n$$",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{k_b}{k_d} + \\left(x_0 - \\frac{k_b}{k_d}\\right) \\exp(-k_d t)  \\left(\\frac{k_b}{k_d} + x_0 \\exp(-k_d t)\\right)\\left(1 - \\exp(-k_d t)\\right)\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "真实的生物系统通常混合了低拷贝数的分子（其噪声至关重要）和高拷贝数的分子（可以进行确定性近似）。本练习要求您为一个经典的双稳态系统——基因转换开关——实现一个分区混合模拟器。您将随机处理缓慢的启动子结合事件以捕捉噪声驱动的状态转换，同时使用常微分方程对更快的转录和翻译过程进行建模，以提高计算效率 。",
            "id": "3319361",
            "problem": "您的任务是为计算系统生物学中的一个基准遗传拨动开关网络设计并实现一种混合仿真算法。该算法结合使用随机和确定性方法，以在提高计算性能的同时保持其双稳态特性。该网络由两个基因（表示为 $A$ 和 $B$）组成，它们通过与启动子位点结合来相互抑制对方的转录。\n\n各组分如下：\n- 基因 $A$ 的启动子状态：$P_A^{\\mathrm{free}}$ 和 $P_A^{\\mathrm{bound}}$。\n- 基因 $B$ 的启动子状态：$P_B^{\\mathrm{free}}$ 和 $P_B^{\\mathrm{bound}}$。\n- 信使RNA：$m_A$ 和 $m_B$（分子）。\n- 蛋白质：$A$ 和 $B$（分子）。\n\n反应（遵循质量作用定律）如下：\n- 启动子结合与解离（随机）：\n  - $B + P_A^{\\mathrm{free}} \\xrightarrow{k_{\\mathrm{on},A}} P_A^{\\mathrm{bound}}$，\n  - $P_A^{\\mathrm{bound}} \\xrightarrow{k_{\\mathrm{off},A}} B + P_A^{\\mathrm{free}}$，\n  - $A + P_B^{\\mathrm{free}} \\xrightarrow{k_{\\mathrm{on},B}} P_B^{\\mathrm{bound}}$，\n  - $P_B^{\\mathrm{bound}} \\xrightarrow{k_{\\mathrm{off},B}} A + P_B^{\\mathrm{free}}$。\n- 转录（确定性），依赖于启动子占用情况：\n  - 如果是 $P_A^{\\mathrm{free}}$，转录速率 $r_A = \\alpha_A$；如果是 $P_A^{\\mathrm{bound}}$，转录速率 $r_A = \\ell_A$（泄露）。\n  - 如果是 $P_B^{\\mathrm{free}}$，转录速率 $r_B = \\alpha_B$；如果是 $P_B^{\\mathrm{bound}}$，转录速率 $r_B = \\ell_B$（泄露）。\n- 翻译与降解（确定性）：\n  - $m_A \\xrightarrow{\\beta_A} A$，\n  - $m_B \\xrightarrow{\\beta_B} B$，\n  - 降解 $m_A \\xrightarrow{\\delta_{m,A}} \\varnothing$，$m_B \\xrightarrow{\\delta_{m,B}} \\varnothing$，$A \\xrightarrow{\\delta_{p,A}} \\varnothing$，$B \\xrightarrow{\\delta_{p,B}} \\varnothing$。\n\n您必须对反应进行划分，使得启动子的结合与解离通过随机方法进行仿真，而转录、翻译和降解则通过确定性方法进行仿真。确定性部分应使用固定步长的显式方法进行积分，而随机部分则应基于瞬时倾向，使用非齐次泊松过程的离散时间近似进行仿真。具体而言，在每个大小为 $\\Delta t$ 的时间步长内：\n- 对于 $P_A$：\n  - 如果是 $P_A^{\\mathrm{free}}$，结合倾向为 $a_{\\mathrm{bind},A}(t) = k_{\\mathrm{on},A} \\, B(t)$，在 $\\Delta t$ 内的结合概率为 $p_{\\mathrm{bind},A} = 1 - e^{-a_{\\mathrm{bind},A}(t)\\,\\Delta t}$。\n  - 如果是 $P_A^{\\mathrm{bound}}$，解离倾向为 $a_{\\mathrm{unbind},A} = k_{\\mathrm{off},A}$，在 $\\Delta t$ 内的解离概率为 $p_{\\mathrm{unbind},A} = 1 - e^{-a_{\\mathrm{unbind},A}\\,\\Delta t}$。\n- 对于 $P_B$：\n  - 如果是 $P_B^{\\mathrm{free}}$，结合倾向为 $a_{\\mathrm{bind},B}(t) = k_{\\mathrm{on},B} \\, A(t)$，概率为 $p_{\\mathrm{bind},B} = 1 - e^{-a_{\\mathrm{bind},B}(t)\\,\\Delta t}$。\n  - 如果是 $P_B^{\\mathrm{bound}}$，解离倾向为 $a_{\\mathrm{unbind},B} = k_{\\mathrm{off},B}$，概率为 $p_{\\mathrm{unbind},B} = 1 - e^{-a_{\\mathrm{unbind},B}\\,\\Delta t}$。\n\n$m_A$、$m_B$、$A$ 和 $B$ 的确定性更新必须使用显式欧拉积分：\n$$\nm_A(t+\\Delta t) = m_A(t) + \\Delta t \\left(r_A(t) - \\delta_{m,A} \\, m_A(t)\\right), \\quad\nA(t+\\Delta t) = A(t) + \\Delta t \\left(\\beta_A \\, m_A(t) - \\delta_{p,A} \\, A(t)\\right),\n$$\n$$\nm_B(t+\\Delta t) = m_B(t) + \\Delta t \\left(r_B(t) - \\delta_{m,B} \\, m_B(t)\\right), \\quad\nB(t+\\Delta t) = B(t) + \\Delta t \\left(\\beta_B \\, m_B(t) - \\delta_{p,B} \\, B(t)\\right).\n$$\n每次更新后，将 $m_A$、$m_B$、$A$ 和 $B$ 的值限定为非负数。\n\n设计的科学依据与约束条件：\n- 该混合方案是一个分段确定性马尔可夫过程（PDMP），通过将化学主方程（CME）划分为一个针对离散启动子状态的随机子系统和一个在反应速率近似下针对大拷贝数物种的确定性子系统而导出。\n- 为保持双稳态，必须在启动子结合动力学中保留随机性，该动力学介导了吸引子状态之间的噪声驱动切换。\n- 对 $m_A$、$m_B$、$A$ 和 $B$ 进行确定性积分可以提高性能，并且在它们的拷贝数中等到大时是合理的。\n\n所有仿真的初始条件：\n- 在时间 $t=0$ 时，设置 $m_A(0) = 0$, $m_B(0) = 0$, $A(0) = 0$, $B(0) = 0$（单位均为分子），以及 $P_A^{\\mathrm{free}}$, $P_B^{\\mathrm{free}}$。\n- 时间步长为 $\\Delta t = 1\\,\\mathrm{s}$。\n- 总仿真时长为 $T = 2000\\,\\mathrm{s}$。\n- 对于每个参数集，运行 $N = 100$ 次独立重复仿真，以形成最终蛋白质差异 $D = A(T) - B(T)$ 的经验分布，以分子为单位记录。\n\n您的程序必须通过以下方式估计 $D$ 的经验分布中的模式数量：\n- 使用 Freedman–Diaconis 法则计算箱宽来生成直方图，用一个短的对称核平滑计数，并统计高于全局最大值某个比例的局部最大值。\n\n设计以下参数集的测试套件（所有速率单位为 $\\mathrm{s^{-1}}$，$k_{\\mathrm{on}}$ 值的单位是每分子每秒，因此 $k_{\\mathrm{on}} \\times$ 浓度 的单位是 $\\mathrm{s^{-1}}$）：\n1. 对称、双稳态基准（理想情况）：\n   - $\\alpha_A = \\alpha_B = 5$, $\\ell_A = \\ell_B = 0.02$, $\\beta_A = \\beta_B = 0.5$,\n   - $\\delta_{m,A} = \\delta_{m,B} = 0.1$, $\\delta_{p,A} = \\delta_{p,B} = 0.005$,\n   - $k_{\\mathrm{on},A} = k_{\\mathrm{on},B} = 2\\times 10^{-4}$, $k_{\\mathrm{off},A} = k_{\\mathrm{off},B} = 5\\times 10^{-4}$。\n   预期行为：由于相互排斥的启动子占用，在 $D$ 中出现两个分离良好的模式。\n2. 减弱的抑制（趋向单峰的边界条件）：\n   - $\\alpha_A = \\alpha_B = 5$, $\\ell_A = \\ell_B = 0.02$, $\\beta_A = \\beta_B = 0.5$,\n   - $\\delta_{m,A} = \\delta_{m,B} = 0.1$, $\\delta_{p,A} = \\delta_{p,B} = 0.005$,\n   - $k_{\\mathrm{on},A} = k_{\\mathrm{on},B} = 1\\times 10^{-4}$, $k_{\\mathrm{off},A} = k_{\\mathrm{off},B} = 2\\times 10^{-2}$。\n   预期行为：频繁的解离导致频繁切换，并在 $D \\approx 0$ 附近形成单个宽峰。\n3. 强抑制和持久性（具有高度稳定模式的边缘情况）：\n   - $\\alpha_A = \\alpha_B = 5$, $\\ell_A = \\ell_B = 0.02$, $\\beta_A = \\beta_B = 0.5$,\n   - $\\delta_{m,A} = \\delta_{m,B} = 0.1$, $\\delta_{p,A} = \\delta_{p,B} = 0.005$,\n   - $k_{\\mathrm{on},A} = k_{\\mathrm{on},B} = 4\\times 10^{-4}$, $k_{\\mathrm{off},A} = k_{\\mathrm{off},B} = 2\\times 10^{-4}$。\n   预期行为：两个模式具有更大的分离度和更长的停留时间。\n\n单位：\n- 时间单位必须是 $\\mathrm{s}$。\n- 分子计数单位为“分子”（无量纲计数）。\n\n最终输出规范：\n- 对于每个参数集，计算在 $D$ 的经验分布中检测到的模式的整数数量。\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。例如，如果三个案例分别有 $2$、$1$ 和 $2$ 个模式，则输出格式必须严格为 $[2,1,2]$。",
            "solution": "该问题要求为遗传拨动开关网络设计并实现一种混合随机-确定性仿真算法。该问题在科学上是合理的，提法明确，并提供了足够的细节来构建一个唯一且有意义的解决方案。该模型是遗传拨动开关的一种标准表示，而所提出的混合仿真策略，作为一种分段确定性马尔可夫过程（PDMP），是计算系统生物学中的一种成熟方法。参数和初始条件已完全指定。模式计数过程中的轻微模糊性将通过做出如下详述的标准、明确假设来解决。\n\n问题的核心是仿真一个系统，其中一些事件（启动子结合/解离）是稀有且本质上是随机的，驱动着系统级的状态切换（双稳态），而其他过程（转录、翻译、降解）涉及大量分子，为了计算效率可以进行确定性近似。\n\n在任意时间 $t$ 的系统状态由元组 $(m_A(t), m_B(t), A(t), B(t), P_A(t), P_B(t))$ 描述，其中 $m_A, m_B, A, B$ 是 mRNA 和蛋白质的分子计数，而 $P_A, P_B$ 代表启动子的离散状态（自由或结合）。我们将自由状态表示为 $0$，结合状态表示为 $1$。\n\n仿真以大小为 $\\Delta t = 1\\,\\mathrm{s}$ 的离散时间步长进行，总时长为 $T = 2000\\,\\mathrm{s}$。在从时间 $t$ 到 $t+\\Delta t$ 的每一步中，我们根据划分的动力学更新系统状态。\n\n首先，我们处理启动子状态 $P_A$ 和 $P_B$ 的随机更新。自由状态和结合状态之间的转换被建模为非齐次泊松过程，并在离散时间间隔 $\\Delta t$ 上进行近似。状态改变的概率取决于系统的当前状态。\n\n- 对于启动子 $A$：\n  - 如果在时间 $t$ 它是自由的（$P_A(t)=0$），它可以被一个蛋白质 $B$ 分子结合。该反应的倾向是 $a_{\\mathrm{bind},A}(t) = k_{\\mathrm{on},A} B(t)$。该事件在区间 $[t, t+\\Delta t]$ 内发生的概率是 $p_{\\mathrm{bind},A} = 1 - \\exp(-a_{\\mathrm{bind},A}(t)\\Delta t)$。\n  - 如果在时间 $t$ 它是结合的（$P_A(t)=1$），它可以解离。该反应的倾向是恒定的：$a_{\\mathrm{unbind},A} = k_{\\mathrm{off},A}$。解离的概率是 $p_{\\mathrm{unbind},A} = 1 - \\exp(-a_{\\mathrm{unbind},A}\\Delta t)$。\n- 一组对称的规则适用于启动子 $B$，其状态转换取决于蛋白质 $A$ 的浓度。\n\n其次，我们使用显式欧拉方法对连续值组分（mRNA 和蛋白质分子计数）进行确定性更新。问题指定欧拉步骤的速率 $r_A(t)$ 和 $r_B(t)$ 由时间间隔开始时（即时间 $t$）的启动子状态决定。\n\n- 转录速率为：\n  - 如果 $P_A(t)=0$（自由），则 $r_A(t) = \\alpha_A$；如果 $P_A(t)=1$（结合），则 $r_A(t) = \\ell_A$。\n  - 如果 $P_B(t)=0$（自由），则 $r_B(t) = \\alpha_B$；如果 $P_B(t)=1$（结合），则 $r_B(t) = \\ell_B$。\n- 欧拉离散化的常微分方程为：\n$$\nm_A(t+\\Delta t) = m_A(t) + \\Delta t \\left(r_A(t) - \\delta_{m,A} \\, m_A(t)\\right)\n$$\n$$\nA(t+\\Delta t) = A(t) + \\Delta t \\left(\\beta_A \\, m_A(t) - \\delta_{p,A} \\, A(t)\\right)\n$$\n对于 $m_B$ 和 $B$ 也是如此。每次更新后，分子计数被限定为非负，以确保物理真实性。\n\n单次仿真轨迹的整体算法如下：\n1. 在 $t=0$ 初始化状态：$m_A(0)=0$, $m_B(0)=0$, $A(0)=0$, $B(0)=0$，以及启动子 $P_A(0)=0, P_B(0)=0$（自由）。\n2. 对于从 $0$ 到 $(T/\\Delta t) - 1$ 的每个时间步 $i$，令 $t_i = i \\Delta t$：\n    a. 根据 $P_A(t_i)$ 和 $P_B(t_i)$ 确定转录速率 $r_A(t_i)$ 和 $r_B(t_i)$。\n    b. 使用显式欧拉公式和在 $t_i$ 的值计算新的分子计数 $m_A(t_{i+1}), A(t_{i+1}), m_B(t_{i+1}), B(t_{i+1})$。强制非负性。\n    c. 根据在 $t_i$ 的状态计算启动子的转换概率。\n    d. 为每个启动子生成一个随机数，以决定其状态是否翻转，从而确定 $P_A(t_{i+1})$ 和 $P_B(t_{i+1})$。\n3. 循环完成后，记录最终的蛋白质差异 $D = A(T) - B(T)$。\n\n对于三个参数集中的每一个，此过程重复 $N=100$ 次，为每种情况生成 $D$ 的经验分布。\n\n最后，我们分析此分布以统计其模式数量。问题概述了一个过程，我们将其完整地规定如下：\n1.  **分箱**：计算 $N=100$ 个 $D$ 值的直方图。箱宽 $h$ 由 Freedman-Diaconis 法则确定：$h = 2 \\frac{\\mathrm{IQR}(D)}{N^{1/3}}$，其中 $\\mathrm{IQR}$ 是数据的四分位距。\n2.  **平滑**：对直方图计数进行平滑以减少噪声。我们将使用一个 3 点对称三角核 $[0.25, 0.5, 0.25]$ 通过卷积来应用。\n3.  **峰值检测**：识别平滑后直方图中的局部最大值。如果一个点的值严格大于其两个直接相邻点的值，则该点为局部最大值。\n4.  **阈值处理**：为了滤除微小波动，只统计高度大于平滑后直方图中全局最大值高度 $10\\%$ 的局部最大值。这个阈值是区分重要模式与噪声的合理选择。\n\n最终输出是为三个参数集中的每一个检测到的模式数量。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the hybrid simulation for the three test cases\n    and print the detected number of modes for each.\n    \"\"\"\n\n    # Define the three test cases as dictionaries of parameters.\n    # Base parameters common to all cases\n    base_params = {\n        'alpha_A': 5.0, 'alpha_B': 5.0, 'ell_A': 0.02, 'ell_B': 0.02,\n        'beta_A': 0.5, 'beta_B': 0.5, 'delta_m_A': 0.1, 'delta_m_B': 0.1,\n        'delta_p_A': 0.005, 'delta_p_B': 0.005,\n    }\n\n    test_cases = [\n        # Case 1: Symmetric, bistable benchmark\n        {**base_params, 'k_on_A': 2e-4, 'k_on_B': 2e-4, 'k_off_A': 5e-4, 'k_off_B': 5e-4},\n        # Case 2: Weakened repression (unimodal)\n        {**base_params, 'k_on_A': 1e-4, 'k_on_B': 1e-4, 'k_off_A': 2e-2, 'k_off_B': 2e-2},\n        # Case 3: Strong repression (highly stable modes)\n        {**base_params, 'k_on_A': 4e-4, 'k_on_B': 4e-4, 'k_off_A': 2e-4, 'k_off_B': 2e-4},\n    ]\n\n    # Simulation constants\n    T = 2000.0\n    DT = 1.0\n    N_REPLICATES = 100\n    \n    # Mode counting parameters\n    MODE_THRESHOLD_FRACTION = 0.1\n    SMOOTHING_KERNEL = np.array([0.25, 0.5, 0.25])\n\n    rng = np.random.default_rng(seed=42) # for reproducible results\n\n    results = []\n    for params in test_cases:\n        final_diffs = []\n        for _ in range(N_REPLICATES):\n            d = run_simulation(params, T, DT, rng)\n            final_diffs.append(d)\n        \n        n_modes = count_modes(\n            np.array(final_diffs), \n            SMOOTHING_KERNEL, \n            MODE_THRESHOLD_FRACTION\n        )\n        results.append(n_modes)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_simulation(params, T, dt, rng):\n    \"\"\"\n    Runs a single trajectory of the hybrid simulation.\n    \n    Args:\n        params (dict): Dictionary of model parameters.\n        T (float): Total simulation time.\n        dt (float): Time step.\n        rng (np.random.Generator): Random number generator instance.\n\n    Returns:\n        float: The final difference D = A(T) - B(T).\n    \"\"\"\n    # Initial conditions\n    m_a, m_b = 0.0, 0.0\n    prot_a, prot_b = 0.0, 0.0\n    p_a_free, p_b_free = 1, 1 # 1 for free, 0 for bound\n\n    num_steps = int(T / dt)\n\n    for _ in range(num_steps):\n        # Store current state for calculations within this time step\n        m_a_t, m_b_t = m_a, m_b\n        prot_a_t, prot_b_t = prot_a, prot_b\n        p_a_free_t, p_b_free_t = p_a_free, p_b_free\n\n        # --- Stochastic update of promoter states ---\n        # Based on state at time t\n        \n        # Promoter A\n        if p_a_free_t == 1: # free - bound?\n            propensity = params['k_on_A'] * prot_b_t\n            prob_bind = 1.0 - np.exp(-propensity * dt)\n            if rng.random()  prob_bind:\n                p_a_free = 0\n        else: # bound - free?\n            propensity = params['k_off_A']\n            prob_unbind = 1.0 - np.exp(-propensity * dt)\n            if rng.random()  prob_unbind:\n                p_a_free = 1\n        \n        # Promoter B\n        if p_b_free_t == 1: # free - bound?\n            propensity = params['k_on_B'] * prot_a_t\n            prob_bind = 1.0 - np.exp(-propensity * dt)\n            if rng.random()  prob_bind:\n                p_b_free = 0\n        else: # bound - free? \n            propensity = params['k_off_B']\n            prob_unbind = 1.0 - np.exp(-propensity * dt)\n            if rng.random()  prob_unbind:\n                p_b_free = 1\n\n        # --- Deterministic update of mRNA and proteins ---\n        # Based on state at time t\n        r_a = params['alpha_A'] if p_a_free_t == 1 else params['ell_A']\n        r_b = params['alpha_B'] if p_b_free_t == 1 else params['ell_B']\n\n        # Update mRNA\n        m_a = m_a_t + dt * (r_a - params['delta_m_A'] * m_a_t)\n        m_b = m_b_t + dt * (r_b - params['delta_m_B'] * m_b_t)\n        \n        # Update proteins\n        prot_a = prot_a_t + dt * (params['beta_A'] * m_a_t - params['delta_p_A'] * prot_a_t)\n        prot_b = prot_b_t + dt * (params['beta_B'] * m_b_t - params['delta_p_B'] * prot_b_t)\n\n        # Clamp to non-negative\n        m_a = max(0.0, m_a)\n        m_b = max(0.0, m_b)\n        prot_a = max(0.0, prot_a)\n        prot_b = max(0.0, prot_b)\n        \n    return prot_a - prot_b\n\n\ndef count_modes(data, kernel, threshold_frac):\n    \"\"\"\n    Counts the number of modes in a 1D data array using a histogram-based method.\n    \n    Args:\n        data (np.ndarray): Array of data points.\n        kernel (np.ndarray): Smoothing kernel.\n        threshold_frac (float): Fraction of the global max for peak thresholding.\n\n    Returns:\n        int: The number of detected modes.\n    \"\"\"\n    if len(data)  3:\n        return 1\n        \n    # 1. Binning using Freedman-Diaconis rule\n    try:\n        counts, bin_edges = np.histogram(data, bins='fd')\n    except ValueError:\n        # Fallback if 'fd' fails (e.g., zero variance)\n        counts, bin_edges = np.histogram(data, bins=10)\n\n    if len(counts)  3:\n      # Not enough bins to find local maxima with a 3-point kernel\n      return 1 if len(counts)  0 else 0\n\n    # 2. Smoothing\n    smoothed_counts = np.convolve(counts, kernel, mode='same')\n    \n    # 3. Peak Finding  4. Thresholding\n    global_max = np.max(smoothed_counts)\n    if global_max == 0:\n        return 0\n        \n    threshold = threshold_frac * global_max\n    \n    modes = 0\n    # Iterate from the second to the second-to-last bin to check for local maxima\n    for i in range(1, len(smoothed_counts) - 1):\n        is_local_max = smoothed_counts[i]  smoothed_counts[i-1] and \\\n                       smoothed_counts[i]  smoothed_counts[i+1]\n        \n        if is_local_max and smoothed_counts[i]  threshold:\n            modes += 1\n            \n    # Handle edge case where a single peak might exist at the edge\n    # or the data is monotonic, producing no peaks in the center.\n    if modes == 0 and np.any(smoothed_counts  0):\n        return 1\n        \n    return modes\n\nsolve()\n```"
        },
        {
            "introduction": "混合方法是近似方法，计算科学家的一个关键技能是量化这些近似所引入的误差。本练习将指导您构建一个基于阈值的混合模拟器，更重要的是，建立一个验证该模拟器的框架。您需要将模拟器的输出与已知的解析解进行比较，并使用统计工具来判断模拟器的准确性是否满足预定义的容差，这是稳健模型开发的核心过程 。",
            "id": "3319370",
            "problem": "设计并实现一个程序，该程序量化混合随机-确定性模拟器与线性生灭网络的解析化学主方程（CME）稳态解之间的差异，然后根据一个有原则的准则来判断该混合模拟器是否可接受。研究的网络是单物种迁入-死亡过程，其反应为：$\\varnothing \\to X$（速率为 $k_{0}$）和 $X \\to \\varnothing$（速率为 $k_{1} \\, X$）。混合模拟策略定义如下：当拷贝数 $x$ 满足 $x \\le H$ 时，使用随机模拟算法（SSA）进行模拟；当 $x  H$ 时，通过常微分方程 $\\mathrm{d}x/\\mathrm{d}t = k_{0} - k_{1} x$ 进行确定性模拟，并在穿越阈值时切换模式。在确定性模式下，使用精确的解析流来将 $x(t)$ 随时间向前传播，并允许当流向下穿越 $H$ 时切换回随机模式。假设体积内混合均匀，分子数为无量纲；时间单位为秒。\n\n从该线性网络的CME和稳态的基本定义出发，推导出适合比较的解析平稳分布。定义并实现一个估计量，用于计算解析稳态分布 $p$ 与通过多次独立重复实验获得的经验分布 $\\hat{q}$ 之间的全变分距离。每次重复实验都从 $x(0) = 0$ 开始，运行至时间 $T_{\\mathrm{final}}$。为使估计量在数值上易于处理，将状态空间截断为 $\\{0,1,\\dots,K\\}$，并将所有超出 $K$ 的概率质量聚合到一个尾部箱中。对于选定的非负整数 $K$，全变分估计量为\n$$\n\\widehat{\\mathrm{TV}} \\;=\\; \\tfrac{1}{2} \\left( \\sum_{k=0}^{K} \\left| p(k) - \\hat{q}(k) \\right| \\;+\\; \\left| 1 - \\sum_{k=0}^{K} p(k) \\;-\\; \\sum_{k=0}^{K} \\hat{q}(k) \\right| \\right).\n$$\n自适应地选择 $K$ 为 $K = \\lceil \\lambda + L \\sqrt{\\lambda} \\rceil$，其中 $\\lambda$ 是解析稳态均值，$L$ 是一个正常数，并包含一个聚合的尾部箱，因此总箱数为 $B = K + 2$。利用多项式频率的测度集中和对 $B$ 个箱的并集界，推导一个有限样本边际 $\\Delta$，使得未知的真实全变分距离 $\\mathrm{TV}(p,\\hat{q})$ 最多为 $\\widehat{\\mathrm{TV}} + \\Delta$ 的置信度至少为 $1 - \\alpha$，其中\n$$\n\\Delta \\;=\\; \\tfrac{1}{2} \\, B \\, \\varepsilon, \n\\qquad\n\\varepsilon \\;=\\; \\sqrt{ \\dfrac{\\ln \\left( \\dfrac{2B}{\\alpha} \\right)}{2 n} },\n$$\n$n$ 是独立重复实验的次数。构建一个接受决策规则：如果 $\\widehat{\\mathrm{TV}} + \\Delta \\le \\tau$，则接受该混合模拟器，其中 $\\tau$ 是用户指定的容差。\n\n您的任务是实现一个完整的程序，该程序：\n- 对下面的测试套件中的每个参数集，使用指定的 $n$ 次独立重复实验、时间范围 $T_{\\mathrm{final}}$、阈值 $H$ 和支持乘数 $L$ 来模拟混合过程。\n- 从第一性原理出发，为该线性网络计算解析CME稳态分布及其均值 $\\lambda$。\n- 在 $\\{0,\\dots,K\\}$ 加上一个尾部箱上，构建如上定义的截断全变分估计量 $\\widehat{\\mathrm{TV}}$。\n- 使用上述有限样本界、置信水平 $\\alpha$ 和总箱数 $B = K + 2$ 计算边际 $\\Delta$。\n- 根据规则 $\\widehat{\\mathrm{TV}} + \\Delta \\le \\tau$，为每个测试案例返回接受决策（布尔值）。\n\n混合模拟器必须精确实现以下模式切换：\n- 如果 $x \\le H$，使用随机模拟算法，总风险率 $a_{0}(x) = k_{0} + k_{1} x$，指数等待时间的均值为 $1/a_{0}(x)$，并以概率 $k_{0}/a_{0}(x)$ 进行跳跃 $x \\mapsto x + 1$，或以概率 $k_{1} x / a_{0}(x)$ 进行跳跃 $x \\mapsto \\max\\{0,x-1\\}$。\n- 如果 $x  H$，使用精确流 $x(t+\\Delta t) = \\lambda + \\left( x(t) - \\lambda \\right) e^{-k_{1} \\Delta t}$ 进行确定性传播。当 $\\lambda  H$ 时，计算从上方到达 $H$ 的精确时间，即第一个满足 $x(t+\\Delta t) = H$ 的 $\\Delta t$，然后在该时间切换到SSA；如果 $\\lambda \\ge H$，则在确定性模式下保持到 $T_{\\mathrm{final}}$。\n- 在 $T_{\\mathrm{final}}$ 时，将连续的 $x$ 四舍五入到最近的非负整数，以生成用于经验分布的样本。\n\n测试套件和要求输出：\n- 使用以下四个测试案例，每个案例由 $(k_{0}, k_{1}, H, T_{\\mathrm{final}}, n, L, \\tau, \\alpha)$ 指定：\n    - 案例 1： $(5.0, 1.0, 100, 50.0, 600, 8.0, 0.05, 0.01)$。\n    - 案例 2： $(40.0, 1.0, 5, 50.0, 600, 8.0, 0.05, 0.01)$。\n    - 案例 3： $(1.0, 1.0, 5, 50.0, 600, 8.0, 0.05, 0.01)$。\n    - 案例 4： $(5.0, 0.2, 10, 50.0, 600, 8.0, 0.05, 0.01)$。\n- 对于每个案例，计算并存储一个布尔值，表示在置信水平 $1 - \\alpha$ 下是否满足接受准则。\n- 您的程序应生成单行输出，其中包含按上述案例顺序排列的结果，格式为逗号分隔的列表并用方括号括起来（例如，\"[True,False,True,False]\"）。不应打印任何其他文本。\n\n假设与约束：\n- 所有随机抽样在重复实验之间必须是独立的。\n- 为保证可复现性，使用固定的随机种子。\n- 不涉及角度；无需角度单位。\n- 除了已声明的秒作为时间单位外，不需要进行其他物理单位转换。",
            "solution": "该问题要求设计并实现一个计算流程，用于验证一个混合随机-确定性模拟器与一个基本生化反应网络的精确解析解的一致性。验证过程通过量化模拟器输出与解析已知的稳态分布之间的统计差异，并应用一个有原则的决策规则来决定是否接受。该流程包括三个主要部分：推导解析解、实现指定的混合模拟算法以及进行严格的统计比较。\n\n### 1. 解析稳态解\n\n该系统是一个单物种迁入-死亡过程，由以下反应描述：\n$$\n\\varnothing \\xrightarrow{k_0} X \\\\\nX \\xrightarrow{k_1} \\varnothing\n$$\n系统的状态是物种 $X$ 的分子数，用非负整数 $x$ 表示。第一个反应是以恒定速率 $k_0$ 发生的迁入（或出生）过程。第二个反应是以速率 $k_1 x$ 发生的降解（或死亡）过程，该速率与存在的分子数成正比。\n\n状态概率分布 $p(k, t) = \\mathrm{Prob}(X(t)=k)$ 的演化由化学主方程（CME）控制。在稳态下，流入任何状态 $k$ 的净概率流为零，即 $\\mathrm{d}p(k, t)/\\mathrm{d}t = 0$。这导出了平衡方程，该方程将流入状态 $k$ 的概率速率与流出状态 $k$ 的概率速率相等同：\n$$\n\\text{流入速率} = \\text{流出速率}\n$$\n对于一个通用状态 $k  0$，系统可以从状态 $k-1$（通过出生）或状态 $k+1$（通过死亡）进入。它可以通过出生（到状态 $k+1$）或死亡（到状态 $k-1$）离开。状态 $k$ 的稳态平衡方程是：\n$$\nk_0 \\, p(k-1) + k_1 (k+1) \\, p(k+1) = (k_0 + k_1 k) \\, p(k)\n$$\n对于边界状态 $k=0$，方程为：\n$$\nk_1 (1) \\, p(1) = k_0 \\, p(0)\n$$\n这给出 $p(1) = (k_0/k_1) p(0)$。我们定义参数 $\\lambda = k_0/k_1$。则 $p(1) = \\lambda p(0)$。我们可以递归地求解一般平衡方程。对于 $k=1$：\n$$\nk_0 p(0) + k_1 (2) p(2) = (k_0 + k_1) p(1)\n$$\n代入 $p(1) = (k_0/k_1) p(0)$：\n$$\nk_0 p(0) + 2k_1 p(2) = (k_0 + k_1) (k_0/k_1) p(0) = (k_0^2/k_1 + k_0) p(0)\n$$\n$$\n2k_1 p(2) = (k_0^2/k_1) p(0) \\implies p(2) = \\frac{k_0^2}{2 k_1^2} p(0) = \\frac{\\lambda^2}{2} p(0)\n$$\n通过归纳法，可以证明通解为：\n$$\np(k) = \\frac{\\lambda^k}{k!} p(0)\n$$\n为了找到 $p(0)$，我们使用归一化条件 $\\sum_{k=0}^{\\infty} p(k) = 1$：\n$$\n\\sum_{k=0}^{\\infty} \\frac{\\lambda^k}{k!} p(0) = p(0) \\sum_{k=0}^{\\infty} \\frac{\\lambda^k}{k!} = p(0) e^{\\lambda} = 1\n$$\n这意味着 $p(0) = e^{-\\lambda}$。因此，解析稳态分布是一个均值为 $\\lambda$ 的泊松分布：\n$$\np(k) = \\frac{e^{-\\lambda} \\lambda^k}{k!} \\quad \\text{其中} \\quad \\lambda = \\frac{k_0}{k_1}\n$$\n\n### 2. 混合模拟算法\n\n该模拟器将精确的随机模拟算法（SSA）与基于系统速率方程的确定性近似相结合。两种模式之间的切换由一个阈值分子数 $H$ 控制。\n\n- **随机模式 ($x \\le H$)：** 当分子数 $x$ 等于或低于阈值 $H$ 时，模拟使用 Gillespie 直接法（一种SSA形式）进行。\n    1. 所有可能反应的总倾向性（风险率）为 $a_0(x) = k_0 + k_1 x$。\n    2. 从均值为 $1/a_0(x)$ 的指数分布中抽取下一次反应的等待时间 $\\Delta t$。\n    3. 时间前进 $\\Delta t$。如果新时间超过最终时间 $T_{\\mathrm{final}}$，则该次重复实验的模拟终止。\n    4. 根据反应的相对倾向性选择一个反应。抽取一个均匀随机数 $u \\in [0,1)$。如果 $u  k_0/a_0(x)$，则发生一次出生 ($x \\to x+1$)；否则，发生一次死亡 ($x \\to x-1$)。\n    5. 更新整数分子数 $x$，并重复此逻辑。\n\n- **确定性模式 ($x  H$)：** 当某个反应导致分子数 $x$ 超过 $H$ 时，模拟切换到确定性模型。平均分子数的演化由常微分方程（ODE）$\\mathrm{d}x/\\mathrm{d}t = k_0 - k_1 x$ 描述。\n    1. 这个线性ODE的解析解，从切换时间 $t_s$ 时的 $x(t_s)$ 开始，是 $x(t) = \\lambda + (x(t_s) - \\lambda)e^{-k_1(t-t_s)}$，其中 $\\lambda = k_0/k_1$ 是确定性不动点。\n    2. 轨迹的行为取决于不动点 $\\lambda$ 和阈值 $H$ 之间的关系：\n        - 如果 $\\lambda \\ge H$，任何从 $x  H$ 开始的轨迹将从下方或上方接近 $\\lambda$，但永远不会再次穿越到 $H$ 以下。模拟可以直接快进到 $T_{\\mathrm{final}}$。最终状态是 $x(T_{\\mathrm{final}}) = \\lambda + (x(t_s) - \\lambda)e^{-k_1(T_{\\mathrm{final}}-t_s)}$。\n        - 如果 $\\lambda  H$，从 $x  H$ 开始的轨迹将向 $\\lambda$ 衰减，并将穿越 $H$。我们计算到达 $H$ 的精确时间 $\\Delta t_H$：\n            $$\n            H = \\lambda + (x(t_s) - \\lambda)e^{-k_1 \\Delta t_H} \\implies \\Delta t_H = \\frac{1}{k_1} \\ln \\left( \\frac{x(t_s) - \\lambda}{H - \\lambda} \\right)\n            $$\n            如果 $t_s + \\Delta t_H \\ge T_{\\mathrm{final}}$，模拟在到达 $H$ 之前或之时结束。最终状态使用ODE解在 $T_{\\mathrm{final}}$ 时计算。否则，时间前进到 $t_s + \\Delta t_H$，状态设置为整数 $x=H$，模拟切换回随机模式。\n\n- **最终样本生成：** $n$ 次独立重复实验中的每一次都从 $x(0)=0$ 开始，运行直到 $t=T_{\\mathrm{final}}$。如果一次重复实验在确定性模式下结束，其最终的连续状态 $x(T_{\\mathrm{final}})$ 被四舍五入到最近的非负整数。这 $n$ 个整数值构成了经验分布的样本。\n\n### 3. 统计差异框架\n\n为了比较模拟器得到的经验分布 $\\hat{q}$ 与解析的泊松分布 $p$，我们使用截断状态空间上的全变分（TV）距离。\n\n- **状态空间截断：** 无限状态空间 $\\{0, 1, 2, \\dots \\}$ 被截断为一个包含 $B$ 个箱的有限集合，以便于实际计算。这些箱是 $\\{0\\}, \\{1\\}, \\dots, \\{K\\}$，外加一个用于所有大于 $K$ 的状态的聚合尾部箱。截断点 $K$ 是自适应选择的，以覆盖解析分布的大部分质量：$K = \\lceil \\lambda + L \\sqrt{\\lambda} \\rceil$，其中 $L$ 是给定的乘数。总箱数为 $B = K + 2$。\n\n- **全变分估计量 ($\\widehat{\\mathrm{TV}}$)：** 经验分布 $\\hat{q}$ 是通过计算 $n$ 个样本中落入 $B$ 个箱中每一个的比例而形成的。TV距离的估计量是分箱概率向量之间 $L_1$ 距离的一半：\n    $$\n    \\widehat{\\mathrm{TV}} = \\frac{1}{2} \\sum_{i=1}^{B} |\\hat{q}_i - p_i|\n    $$\n    其中 $p_i$ 和 $\\hat{q}_i$ 分别是解析分布和经验分布下第 $i$ 个箱的概率。这与问题陈述中给出的公式完全对应。\n\n- **有限样本置信界：** 估计量 $\\widehat{\\mathrm{TV}}$ 是从有限数量的样本 $n$ 计算出来的，它本身是一个随机变量。为了做出稳健的决策，我们必须考虑这种抽样误差。我们为解析分布 $p$ 与混合模拟器的真实潜在分布 $q_{true}$ 之间的真实（未知）TV距离构建一个单边置信区间。以至少 $1-\\alpha$ 的置信度，这个距离由 $\\mathrm{TV}(p, q_{true}) \\le \\widehat{\\mathrm{TV}} + \\Delta$ 界定。误差边际 $\\Delta$ 解释了 $\\hat{q}$ 中的统计不确定性。它是利用针对多项式频率的 Hoeffding 不等式与对 $B$ 个箱的并集界相结合推导出来的。这得出：\n    $$\n    \\Delta = \\frac{1}{2} B \\varepsilon, \\quad \\text{其中} \\quad \\varepsilon = \\sqrt{ \\frac{\\ln (2B/\\alpha)}{2n} }\n    $$\n\n### 4. 接受准则\n\n如果混合模拟器与解析解的最坏情况差异在可容忍的小范围内，则认为它是真实随机过程的一个可接受的近似。决策规则是：\n$$\n\\text{如果 } \\widehat{\\mathrm{TV}} + \\Delta \\le \\tau \\text{ 则接受}\n$$\n这意味着我们只有在真实TV距离的 $(1-\\alpha)$-置信区间的上界不超过用户指定的容差 $\\tau$ 时，才接受该模拟器。这为验证数值方法提供了统计上有原则的基础。最终的实现将为每个测试案例执行这整个过程，并返回一个布尔决策。",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import poisson\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    # A fixed random seed is used for reproducibility as per the problem statement.\n    np.random.seed(42)\n\n    # Test suite: (k0, k1, H, T_final, n, L, tau, alpha)\n    test_cases = [\n        (5.0, 1.0, 100, 50.0, 600, 8.0, 0.05, 0.01),\n        (40.0, 1.0, 5, 50.0, 600, 8.0, 0.05, 0.01),\n        (1.0, 1.0, 5, 50.0, 600, 8.0, 0.05, 0.01),\n        (5.0, 0.2, 10, 50.0, 600, 8.0, 0.05, 0.01),\n    ]\n\n    results = [_run_validation_case(*case) for case in test_cases]\n\n    # Format the output as specified: a single line \"[bool,bool,...]\"\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef _run_validation_case(k0, k1, H, T_final, n, L, tau, alpha):\n    \"\"\"\n    Runs the full validation procedure for a single parameter set.\n    \"\"\"\n    # 1. Generate n samples from the hybrid simulator.\n    samples = [_simulate_replicate(k0, k1, H, T_final) for _ in range(n)]\n    \n    # 2. Perform statistical analysis and make an acceptance decision.\n    return _analyze_discrepancy(samples, k0, k1, n, L, tau, alpha)\n\ndef _simulate_replicate(k0, k1, H, T_final):\n    \"\"\"\n    Simulates a single trajectory of the hybrid process from t=0 to t=T_final.\n    \"\"\"\n    t = 0.0\n    x = 0  # State is an integer copy number.\n\n    while t  T_final:\n        if x = H:\n            # Stochastic Simulation Algorithm (SSA) regime\n            propensity = k0 + k1 * x\n            if propensity = 1e-9:  # System is stuck (e.g., x=0, k0=0)\n                t = T_final\n                continue\n            \n            # Time to next event\n            dt = np.random.exponential(1.0 / propensity)\n            \n            if t + dt >= T_final:\n                # Event occurs after T_final, so state does not change\n                t = T_final\n                break\n                \n            t += dt\n            \n            # Choose event\n            if np.random.uniform(0, 1)  k0 / propensity:\n                x += 1  # Birth\n            else:\n                x -= 1  # Death\n            # State x remains an integer for the next loop iteration check\n        else:\n            # Deterministic regime (x > H)\n            lambda_val = k0 / k1\n            t_det_start = t\n            x_det_start = float(x)\n\n            if lambda_val >= H:\n                # Trajectory will not cross back below H. Fast-forward to T_final.\n                x_final_det = lambda_val + (x_det_start - lambda_val) * np.exp(-k1 * (T_final - t_det_start))\n                return int(np.round(x_final_det))\n            else:\n                # Trajectory will decay towards lambda  H and will cross H.\n                # Compute time to hit H. Since x_det_start > H > lambda_val, the log argument is > 1.\n                dt_H = (1.0 / k1) * np.log((x_det_start - lambda_val) / (H - lambda_val))\n                \n                if t_det_start + dt_H >= T_final:\n                    # Does not reach H before simulation ends.\n                    x_final_det = lambda_val + (x_det_start - lambda_val) * np.exp(-k1 * (T_final - t_det_start))\n                    return int(np.round(x_final_det))\n                else:\n                    # Reaches H. Update state and switch back to stochastic.\n                    t = t_det_start + dt_H\n                    x = int(H) # State is now exactly H.\n                    # The loop will continue in the stochastic regime.\n\n    # If the loop completes, the final state is the integer x.\n    return x\n\ndef _analyze_discrepancy(samples, k0, k1, n, L, tau, alpha):\n    \"\"\"\n    Computes discrepancy metrics and returns the acceptance decision.\n    \"\"\"\n    # 1. Define analytic and empirical distributions on a truncated space.\n    lambda_val = k0 / k1\n    \n    # Define truncation K and number of bins B\n    if lambda_val > 0:\n        K = int(np.ceil(lambda_val + L * np.sqrt(lambda_val)))\n    else:\n        K = 0\n    B = K + 2\n\n    # Analytic distribution (p)\n    k_vals = np.arange(0, K + 1)\n    p_analytic_pmf = poisson.pmf(k_vals, lambda_val)\n    p_analytic_tail = poisson.sf(K, lambda_val)\n    p_vec = np.append(p_analytic_pmf, p_analytic_tail)\n\n    # Empirical distribution (q_hat)\n    counts = np.zeros(K + 2, dtype=np.int64)\n    for s in samples:\n        if s = K:\n            counts[s] += 1\n        else:\n            counts[K + 1] += 1  # Tail bin\n    q_hat_vec = counts / n\n\n    # 2. Compute the total variation distance estimator.\n    tv_hat = 0.5 * np.sum(np.abs(p_vec - q_hat_vec))\n    \n    # 3. Compute the finite-sample margin.\n    epsilon = np.sqrt(np.log(2 * B / alpha) / (2 * n))\n    delta = 0.5 * B * epsilon\n    \n    # 4. Apply the acceptance decision rule.\n    return (tv_hat + delta) = tau\n\n# This pattern ensures the code runs when the script is executed.\nif __name__ == '__main__':\n    solve()\n\n```"
        }
    ]
}