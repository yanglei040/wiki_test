{
    "hands_on_practices": [
        {
            "introduction": "This exercise is a classic application of microeconomic theory to a modern-day scenario: the gig economy. By modeling a freelance worker's decision, you will practice setting up and solving an expected profit maximization problem under uncertainty. This hands-on practice will solidify your ability to use calculus to find optimal strategies when facing trade-offs between price, probability of success, and cost.",
            "id": "2422477",
            "problem": "Consider a risk-neutral freelance worker who decides on an hourly rate $w \\ge 0$ and reserves $h \\ge 0$ hours of availability for a single period. The worker is matched with a client with probability $p(w) = \\exp(-\\alpha w)$, where $\\alpha > 0$. If matched, the worker earns $w$ per hour for all $h$ hours, for total revenue $w h$; if unmatched, revenue is $0$. Reserving $h$ hours imposes an opportunity cost $c(h) = \\frac{\\gamma}{2} h^{2}$, with $\\gamma > 0$, that is incurred regardless of whether a match occurs.\n\nAssuming an interior solution exists and the worker chooses $(w,h)$ to maximize expected profit (expected revenue minus the opportunity cost), determine the profit-maximizing choices $(w^{\\star}, h^{\\star})$ as closed-form expressions in $\\alpha$ and $\\gamma$.\n\nYour final answer must be a single analytic expression. Do not provide an inequality or an equation. No rounding is required.",
            "solution": "The problem statement is subjected to validation before a solution is attempted.\n\nStep 1: Extract Givens\n- Decision variables: hourly rate $w \\ge 0$, hours of availability $h \\ge 0$.\n- Probability of being matched with a client: $p(w) = \\exp(-\\alpha w)$.\n- Parameter constraint for probability function: $\\alpha > 0$.\n- Revenue if matched: $w h$.\n- Revenue if unmatched: $0$.\n- Opportunity cost function: $c(h) = \\frac{\\gamma}{2} h^{2}$.\n- Parameter constraint for cost function: $\\gamma > 0$.\n- Worker's objective: To maximize expected profit.\n- Expected profit definition: Expected revenue minus the opportunity cost.\n- Assumption: An interior solution exists, meaning the optimal choices $(w^{\\star}, h^{\\star})$ satisfy $w^{\\star} > 0$ and $h^{\\star} > 0$.\n- Goal: Determine the profit-maximizing choices $(w^{\\star}, h^{\\star})$ as closed-form expressions in terms of $\\alpha$ and $\\gamma$.\n\nStep 2: Validate Using Extracted Givens\nThe problem is a standard optimization exercise in microeconomic theory, specifically in the context of labor supply under uncertainty.\n- **Scientifically Grounded**: The problem is well-founded in economic principles. The use of an exponential function for a success probability and a quadratic function for cost is common in economic modeling to ensure desirable properties such as diminishing returns and increasing marginal cost. The assumption of risk-neutrality simplifies the utility function to be linear in money. The problem is scientifically and mathematically sound.\n- **Well-Posed**: The problem is well-posed. It specifies an objective function (expected profit) to be maximized with respect to two choice variables ($w$ and $h$), subject to given functional forms and parameter constraints ($\\alpha > 0$, $\\gamma > 0$). The assumption of an interior solution directs the methodology towards standard differential calculus, ensuring a unique solution can be found.\n- **Objective**: The problem is stated using precise, objective mathematical language, free of ambiguity or subjective claims.\n\nStep 3: Verdict and Action\nThe problem is valid. It is a well-defined, scientifically grounded optimization problem. A solution will be derived.\n\nThe worker's expected profit, denoted by $\\Pi(w, h)$, is the expected revenue minus the opportunity cost. The expected revenue is the revenue from being matched, $w h$, multiplied by the probability of being matched, $p(w)$, plus the revenue from being unmatched, $0$, multiplied by the probability of being unmatched, $1-p(w)$. The opportunity cost $c(h)$ is incurred regardless of the outcome.\n\nThe expected profit function is therefore:\n$$\n\\Pi(w, h) = p(w) \\cdot (wh) + (1 - p(w)) \\cdot 0 - c(h)\n$$\nSubstituting the given functional forms for $p(w)$ and $c(h)$:\n$$\n\\Pi(w, h) = \\exp(-\\alpha w) w h - \\frac{\\gamma}{2} h^{2}\n$$\nTo maximize this function with respect to $w$ and $h$, we find the first-order partial derivatives and set them to zero. This is the first-order condition for a critical point. The problem's assumption of an interior solution guarantees that such a point corresponds to the maximum profit.\n\nFirst, we differentiate with respect to the wage, $w$:\n$$\n\\frac{\\partial \\Pi}{\\partial w} = \\frac{\\partial}{\\partial w} \\left( w h \\exp(-\\alpha w) - \\frac{\\gamma}{2} h^{2} \\right)\n$$\nUsing the product rule for differentiation on the first term:\n$$\n\\frac{\\partial \\Pi}{\\partial w} = h \\cdot \\frac{d}{dw}(w \\exp(-\\alpha w)) = h \\left( 1 \\cdot \\exp(-\\alpha w) + w \\cdot (-\\alpha \\exp(-\\alpha w)) \\right)\n$$\n$$\n\\frac{\\partial \\Pi}{\\partial w} = h \\exp(-\\alpha w) (1 - \\alpha w)\n$$\nSetting this partial derivative to zero gives the first condition:\n$$\nh \\exp(-\\alpha w) (1 - \\alpha w) = 0\n$$\n\nNext, we differentiate with respect to the hours, $h$:\n$$\n\\frac{\\partial \\Pi}{\\partial h} = \\frac{\\partial}{\\partial h} \\left( w h \\exp(-\\alpha w) - \\frac{\\gamma}{2} h^{2} \\right)\n$$\n$$\n\\frac{\\partial \\Pi}{\\partial h} = w \\exp(-\\alpha w) - \\gamma h\n$$\nSetting this partial derivative to zero gives the second condition:\n$$\nw \\exp(-\\alpha w) - \\gamma h = 0\n$$\n\nWe now have a system of two equations with two unknowns, $w$ and $h$:\n1. $h \\exp(-\\alpha w) (1 - \\alpha w) = 0$\n2. $w \\exp(-\\alpha w) - \\gamma h = 0$\n\nFrom equation $(1)$, because we are seeking an interior solution where $h^{\\star} > 0$, and since the term $\\exp(-\\alpha w)$ is strictly positive for any finite $w$, the equation can only be satisfied if the term $(1 - \\alpha w)$ is equal to zero.\n$$\n1 - \\alpha w = 0\n$$\nSolving for $w$ gives the optimal wage rate, $w^{\\star}$:\n$$\nw^{\\star} = \\frac{1}{\\alpha}\n$$\nSince $\\alpha > 0$ is given, $w^{\\star}$ is positive, which is consistent with an interior solution.\n\nNow, we substitute this optimal wage $w^{\\star}$ into equation $(2)$ to find the optimal hours, $h^{\\star}$:\n$$\n\\left(\\frac{1}{\\alpha}\\right) \\exp\\left(-\\alpha \\left(\\frac{1}{\\alpha}\\right)\\right) - \\gamma h = 0\n$$\n$$\n\\frac{1}{\\alpha} \\exp(-1) - \\gamma h = 0\n$$\nRearranging to solve for $h$:\n$$\n\\gamma h = \\frac{1}{\\alpha} \\exp(-1) = \\frac{1}{\\alpha e}\n$$\nThis gives the optimal hours, $h^{\\star}$:\n$$\nh^{\\star} = \\frac{1}{\\alpha \\gamma e}\n$$\nSince $\\alpha > 0$ and $\\gamma > 0$ are given, $h^{\\star}$ is also positive, consistent with an interior solution.\n\nThus, the profit-maximizing choices are $(w^{\\star}, h^{\\star}) = \\left(\\frac{1}{\\alpha}, \\frac{1}{\\alpha \\gamma e}\\right)$.\n\nTo be rigorous, we can verify this is a maximum using the second-order conditions. The Hessian matrix of second partial derivatives is:\n$$ H(w,h) = \\begin{pmatrix} \\frac{\\partial^2 \\Pi}{\\partial w^2} & \\frac{\\partial^2 \\Pi}{\\partial w \\partial h} \\\\ \\frac{\\partial^2 \\Pi}{\\partial h \\partial w} & \\frac{\\partial^2 \\Pi}{\\partial h^2} \\end{pmatrix} $$\nThe components are:\n$$ \\frac{\\partial^2 \\Pi}{\\partial w^2} = -h\\alpha\\exp(-\\alpha w)(2 - \\alpha w) $$\n$$ \\frac{\\partial^2 \\Pi}{\\partial h^2} = -\\gamma $$\n$$ \\frac{\\partial^2 \\Pi}{\\partial w \\partial h} = \\exp(-\\alpha w)(1 - \\alpha w) $$\nAt the critical point where $w^{\\star} = 1/\\alpha$ and $h^{\\star} = 1/(\\alpha \\gamma e)$:\n$$ \\frac{\\partial^2 \\Pi}{\\partial w^2}\\bigg|_{(w^{\\star},h^{\\star})} = -h^{\\star}\\alpha\\exp(-1)(2 - 1) = -\\frac{1}{\\alpha\\gamma e}\\alpha e^{-1} = -\\frac{1}{\\gamma e^2} < 0 $$\n$$ \\frac{\\partial^2 \\Pi}{\\partial h^2}\\bigg|_{(w^{\\star},h^{\\star})} = -\\gamma < 0 $$\n$$ \\frac{\\partial^2 \\Pi}{\\partial w \\partial h}\\bigg|_{(w^{\\star},h^{\\star})} = \\exp(-1)(1 - 1) = 0 $$\nThe determinant of the Hessian at this point is:\n$$ D = \\left(-\\frac{1}{\\gamma e^2}\\right)(-\\gamma) - (0)^2 = \\frac{1}{e^2} > 0 $$\nSince the determinant $D$ is positive and $\\frac{\\partial^2 \\Pi}{\\partial w^2}$ is negative, the critical point is a local maximum, as required.\n\nThe profit-maximizing choices are given by the derived expressions for $w^{\\star}$ and $h^{\\star}$.",
            "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{1}{\\alpha} & \\frac{1}{\\alpha \\gamma e} \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "Real-world business decisions often have consequences that unfold over time. This practice explores a crucial dynamic trade-off for a luxury goods firm: maximizing current sales versus preserving long-term brand equity. Using backward induction, you will computationally solve a two-period model where today's sales can dilute future demand, demonstrating how to approach dynamic optimization problems where actions have lasting impacts.",
            "id": "2422445",
            "problem": "Consider a monopolist producing a single luxury good over two discrete periods, indexed by $t \\in \\{1,2\\}$. In each period $t$, the inverse demand curve for the good is linear and given by $p_t(q_t) = A_t - B_t q_t$, where $A_t > 0$ and $B_t > 0$ are parameters and $q_t \\ge 0$ is the quantity sold in period $t$. The firm has a constant marginal cost $c \\ge 0$ that is the same in both periods. Revenues and costs are denominated in arbitrary currency units. Time has no physical units and is dimensionless. Intertemporal trade-offs are discounted by a factor $\\beta \\in (0,1)$ expressed as a decimal (not as a percentage).\n\nBrand dilution: Selling a luxury product in large quantities can harm the brand and reduce future willingness to pay. Model this as a downward shift in period-$2$ demand intercept that depends on the extent to which period-$1$ quantity exceeds a prestige threshold quantity $q_{\\text{bar}} \\ge 0$. Specifically, the period-$2$ intercept is\n$$\nA_2^{\\text{eff}}(q_1) = A_2 - d \\cdot \\max\\{0,\\, q_1 - q_{\\text{bar}}\\},\n$$\nwhere $d \\ge 0$ is the dilution sensitivity. If $q_1 \\le q_{\\text{bar}}$, there is no dilution and $A_2^{\\text{eff}}(q_1) = A_2$; if $q_1 > q_{\\text{bar}}$, the intercept shrinks linearly with slope $-d$.\n\nThe monopolist chooses $q_1$ in period $1$ and $q_2$ in period $2$ to maximize the discounted sum of profits. The period-$t$ profit is\n$$\n\\pi_t(q_t) = \\big(p_t(q_t) - c\\big)\\, q_t = \\big(A_t - B_t q_t - c\\big)\\, q_t,\n$$\nwith the caveat that in period $2$ the relevant intercept is $A_2^{\\text{eff}}(q_1)$, i.e., $p_2(q_2) = A_2^{\\text{eff}}(q_1) - B_2 q_2$. The total objective is\n$$\n\\Pi(q_1,q_2) = \\pi_1(q_1) + \\beta \\, \\pi_2(q_2),\n$$\nsubject to $q_1 \\ge 0$ and $q_2 \\ge 0$, and the implicit no-negative-price condition on demand ensures $q_t \\le A_t/B_t$ in period $t$, with period $2$ using $A_2^{\\text{eff}}(q_1)$ in place of $A_2$.\n\nFundamental base for derivation and computation:\n- The monopolist’s period-$t$ static profit maximization under linear demand yields, for a given intercept $A$ and slope $B$, and cost $c$, the first-order condition that leads to the well-tested result $q^\\star = \\max\\{0,\\, (A - c)/(2B)\\}$ and $p^\\star = (A + c)/2$, provided $A > c$.\n- Discounting of future payoffs is modeled by multiplying period-$2$ profit by $\\beta$.\n\nComputational task:\n- Work in purely mathematical terms. You must compute the subgame-perfect outcome by backward induction: for any fixed $q_1$, the period-$2$ monopolist chooses $q_2$ optimally given $A_2^{\\text{eff}}(q_1)$; anticipating this, the firm chooses $q_1$ to maximize total discounted profit.\n- Assume the firm cannot sell at negative prices, so $q_1 \\in [0,\\, A_1/B_1]$, and in period $2$, $q_2 \\in [0,\\, A_2^{\\text{eff}}(q_1)/B_2]$ when $A_2^{\\text{eff}}(q_1) > 0$; otherwise $q_2 = 0$.\n- For each test case below, compute the unique profit-maximizing pair $(q_1^\\star, q_2^\\star)$, along with the corresponding equilibrium prices $p_1^\\star$ and $p_2^\\star$, and the total discounted profit $\\Pi^\\star = \\pi_1(q_1^\\star) + \\beta \\pi_2(q_2^\\star)$. All scalar outputs must be real numbers.\n\nTest suite (each tuple is $(A_1, B_1, A_2, B_2, c, q_{\\text{bar}}, d, \\beta)$):\n- Case $1$: $(A_1, B_1, A_2, B_2, c, q_{\\text{bar}}, d, \\beta) = (100,\\, 1,\\, 120,\\, 1.5,\\, 10,\\, 20,\\, 0.8,\\, 0.95)$.\n- Case $2$: $(A_1, B_1, A_2, B_2, c, q_{\\text{bar}}, d, \\beta) = (100,\\, 1,\\, 120,\\, 1.5,\\, 10,\\, 80,\\, 0.8,\\, 0.95)$.\n- Case $3$: $(A_1, B_1, A_2, B_2, c, q_{\\text{bar}}, d, \\beta) = (50,\\, 1,\\, 8,\\, 1.2,\\, 10,\\, 20,\\, 1.0,\\, 0.9)$.\n- Case $4$: $(A_1, B_1, A_2, B_2, c, q_{\\text{bar}}, d, \\beta) = (80,\\, 1,\\, 100,\\, 0.5,\\, 20,\\, 15,\\, 3.5,\\, 0.9)$.\n\nOutput specification:\n- For each test case, output the list $[q_1^\\star, q_2^\\star, p_1^\\star, p_2^\\star, \\Pi^\\star]$, with each number rounded to $6$ decimals.\n- Your program should produce a single line of output containing the results for all cases as a single list of such lists, in the order of the test suite above, formatted as a comma-separated list enclosed in square brackets.\n- No input should be read from standard input. All computation must be performed within the program for the given cases, and only the single required output line should be printed.",
            "solution": "The problem requires finding the profit-maximizing production quantities, prices, and total profit for a monopolist over two periods, considering a brand dilution effect. The problem is well-posed and scientifically grounded in microeconomic theory. We will solve it using backward induction to find the subgame-perfect equilibrium.\n\nThe total profit $\\Pi$ for the monopolist is the discounted sum of profits from period $1$ and period $2$:\n$$ \\Pi(q_1, q_2) = \\pi_1(q_1) + \\beta \\pi_2(q_2) $$\nwhere $\\pi_t(q_t) = (p_t(q_t) - c)q_t$, $p_t(q_t) = A_t - B_t q_t$ is the inverse demand, $c$ is the constant marginal cost, and $\\beta$ is the discount factor. The brand dilution is modeled by an effective period-$2$ demand intercept, $A_2^{\\text{eff}}(q_1)$, which depends on the period-$1$ quantity $q_1$:\n$$ A_2^{\\text{eff}}(q_1) = A_2 - d \\cdot \\max\\{0, q_1 - q_{\\text{bar}}\\} $$\nHere, $d$ is the dilution sensitivity and $q_{\\text{bar}}$ is a prestige sales threshold.\n\n**Step 1: Period-2 Optimization (Backward Induction)**\n\nIn period $2$, the quantity $q_1$ is already determined. The monopolist faces a static optimization problem with a given demand intercept $A_2^{\\text{eff}}(q_1)$. The period-$2$ profit is $\\pi_2(q_2) = (A_2^{\\text{eff}}(q_1) - B_2 q_2 - c)q_2$.\nThe first-order condition for maximizing $\\pi_2$ with respect to $q_2$ yields the standard monopoly quantity:\n$$ q_2^\\star(q_1) = \\max\\left\\{0, \\frac{A_2^{\\text{eff}}(q_1) - c}{2B_2}\\right\\} $$\nThe resulting maximized profit for period $2$, as a function of $q_1$, is:\n$$ \\pi_2^\\star(q_1) = \\frac{\\left(\\max\\{0, A_2^{\\text{eff}}(q_1) - c\\}\\right)^2}{4B_2} $$\n\n**Step 2: Period-1 Optimization**\n\nAnticipating the optimal response in period $2$, the firm chooses $q_1 \\ge 0$ in period $1$ to maximize the total discounted profit function, which now depends only on $q_1$:\n$$ \\Pi(q_1) = (A_1 - B_1 q_1 - c)q_1 + \\beta \\pi_2^\\star(q_1) $$\nSubstituting the expressions for $\\pi_2^\\star(q_1)$ and $A_2^{\\text{eff}}(q_1)$:\n$$ \\Pi(q_1) = (A_1 - B_1 q_1 - c)q_1 + \\frac{\\beta}{4B_2} \\left(\\max\\{0, A_2 - c - d \\cdot \\max\\{0, q_1 - q_{\\text{bar}}\\}\\}\\right)^2 $$\nThis objective function is continuous but piecewise differentiable. The points of non-differentiability (kinks) occur at $q_1 = q_{\\text{bar}}$ and, potentially, where $A_2 - c - d(q_1 - q_{\\text{bar}}) = 0$, which is at $q_1 = q_{\\text{crit}} \\equiv q_{\\text{bar}} + (A_2-c)/d$ (for $d > 0$ and $A_2 > c$). The function $\\Pi(q_1)$ is composed of up to three quadratic segments.\n\n**Step 3: Finding the Global Maximum**\n\nTo find the global maximum of this continuous, piecewise function, we must evaluate it at all candidate points. These include points where the derivative is zero (stationary points) within each smooth segment and the kink points themselves. The candidate set for the optimal quantity $q_1^\\star$ is constructed as follows:\n1.  **Boundary and Kink Points**: The point $q_1=0$ (non-negativity constraint), the prestige threshold $q_1 = q_{\\text{bar}}$, and the dilution-to-zero-profit point $q_1 = q_{\\text{crit}}$ are all potential candidates for the optimum.\n2.  **Stationary Points**: We find the stationary points by setting the derivative $\\frac{d\\Pi}{dq_1}$ to zero in each smooth region.\n    -   For $0 \\le q_1 < q_{\\text{bar}}$, the objective function simplifies, and the stationary point is the standard static monopoly quantity $q_{S1} = (A_1-c)/(2B_1)$.\n    -   For $q_{\\text{bar}} < q_1 < q_{\\text{crit}}$, the derivative leads to a different stationary point, let's call it $q_{S2}$:\n        $$ q_{S2} = \\frac{2B_2(A_1 - c) - \\beta d(A_2 - c + dq_{\\text{bar}})}{4B_1B_2 - \\beta d^2} $$\n        This point is a candidate only if it falls within its region of validity and if the denominator $4B_1B_2 - \\beta d^2$ is not zero. If the denominator is negative, the objective function is locally convex, and the maximum on this segment must lie at its boundaries ($q_{\\text{bar}}$ or $q_{\\text{crit}}$).\n    -   For $q_1 > q_{\\text{crit}}$, period-$2$ profit is zero. The objective is again the period-$1$ profit function, with stationary point $q_{S1}$.\n\nThe algorithmic approach is to assemble a set of all such candidate points, ensuring we include all kink points and all relevant stationary points that are feasible ($q_1 \\ge 0$). We then evaluate the total profit function $\\Pi(q_1)$ at each candidate point. The value of $q_1$ that yields the highest profit is the optimal quantity $q_1^\\star$.\n\n**Step 4: Computing Final Results**\n\nOnce the optimal $q_1^\\star$ is determined, the remaining equilibrium values are calculated as follows:\n-   Period-1 price: $p_1^\\star = A_1 - B_1 q_1^\\star$.\n-   Effective period-2 intercept: $A_{2, \\text{eff}}^\\star = A_2 - d \\cdot \\max\\{0, q_1^\\star - q_{\\text{bar}}\\}$.\n-   Period-2 quantity: $q_2^\\star = \\max\\{0, (A_{2, \\text{eff}}^\\star - c) / (2B_2)\\}$.\n-   Period-2 price: If $q_2^\\star > 0$, $p_2^\\star = (A_{2, \\text{eff}}^\\star + c) / 2$. If $q_2^\\star = 0$, the market clearing price is the choke price $p_2^\\star = A_{2, \\text{eff}}^\\star$.\n-   Total discounted profit: $\\Pi^\\star = (p_1^\\star - c)q_1^\\star + \\beta (p_2^\\star - c)q_2^\\star$.\n\nThis systematic procedure guarantees finding the unique profit-maximizing outcome for the given problem structure.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the two-period monopoly problem with brand dilution for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        # (A1, B1, A2, B2, c, q_bar, d, beta)\n        (100.0, 1.0, 120.0, 1.5, 10.0, 20.0, 0.8, 0.95),\n        (100.0, 1.0, 120.0, 1.5, 10.0, 80.0, 0.8, 0.95),\n        (50.0, 1.0, 8.0, 1.2, 10.0, 20.0, 1.0, 0.9),\n        (80.0, 1.0, 100.0, 0.5, 20.0, 15.0, 3.5, 0.9),\n    ]\n\n    all_results = []\n\n    for params in test_cases:\n        result = _solve_single_case(params)\n        all_results.append([f\"{x:.6f}\" for x in result])\n\n    # Format the final output string as a list of lists.\n    output_str = \"[\" + \",\".join([f\"[{','.join(res)}]\" for res in all_results]) + \"]\"\n    print(output_str)\n\ndef _calculate_total_profit(q1, params):\n    \"\"\"\n    Helper function to calculate total discounted profit for a given q1.\n    \"\"\"\n    A1, B1, A2, B2, c, q_bar, d, beta = params\n\n    if q1  0:\n        return -np.inf\n\n    # Period 1 profit\n    pi1 = (A1 - B1 * q1 - c) * q1\n    \n    # Period 2 effective demand intercept\n    A2_eff = A2 - d * max(0, q1 - q_bar)\n\n    # Optimal period 2 profit\n    pi2_opt = 0.0\n    if A2_eff > c:\n        # Standard monopoly profit formula: (A-c)^2 / (4B)\n        pi2_opt = (A2_eff - c)**2 / (4 * B2)\n\n    return pi1 + beta * pi2_opt\n\n\ndef _solve_single_case(params):\n    \"\"\"\n    Solves a single instance of the monopolist problem.\n    \"\"\"\n    A1, B1, A2, B2, c, q_bar, d, beta = params\n\n    # The optimal q1 must be one of the critical points of the piecewise objective function.\n    # We collect all such candidates and evaluate the profit at each.\n    candidates = {0.0, q_bar}\n    \n    # Candidate from static profit maximization in period 1\n    if A1 > c:\n        q_s1 = (A1 - c) / (2 * B1)\n        candidates.add(q_s1)\n\n    # Candidates related to the dilution mechanism\n    if d > 0 and A2 > c:\n        # Kink point where period 2 profit becomes zero due to dilution\n        q_crit = q_bar + (A2 - c) / d\n        candidates.add(q_crit)\n        \n        # Stationary point in the dilution region (q_bar  q1  q_crit)\n        denom = 4 * B1 * B2 - beta * d**2\n        if abs(denom) > 1e-12: # Avoid division by zero\n            num = 2 * B2 * (A1 - c) - beta * d * (A2 - c + d * q_bar)\n            q_s2 = num / denom\n            candidates.add(q_s2)\n\n    max_profit = -np.inf\n    q1_star = 0.0\n\n    # Feasibility limit for q1 (where price becomes zero)\n    q1_max_feasible = A1 / B1 if B1 > 0 else np.inf\n\n    for q1_cand in candidates:\n        # Only consider physically and economically meaningful candidates\n        if q1_cand  0 or q1_cand > q1_max_feasible + 1e-9:\n            continue\n        \n        current_profit = _calculate_total_profit(q1_cand, params)\n        \n        if current_profit > max_profit:\n            max_profit = current_profit\n            q1_star = q1_cand\n\n    # Calculate final equilibrium values based on the optimal q1_star\n    p1_star = A1 - B1 * q1_star\n    A2_eff_star = A2 - d * max(0, q1_star - q_bar)\n    \n    if A2_eff_star > c:\n        q2_star = (A2_eff_star - c) / (2 * B2)\n        p2_star = (A2_eff_star + c) / 2\n    else:\n        q2_star = 0.0\n        # If no production, the market clearing price is the choke price\n        p2_star = A2_eff_star\n\n    # Recalculate final total profit for precision\n    pi1_star = (p1_star - c) * q1_star\n    pi2_star = (p2_star - c) * q2_star\n    Pi_star = pi1_star + beta * pi2_star\n\n    return [q1_star, q2_star, p1_star, p2_star, Pi_star]\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "How do firms compete when they don't have perfect information about their rivals or the market? This simulation exercise moves beyond traditional optimization to explore the fascinating world of agent-based learning in a Cournot duopoly setting. You will implement a reinforcement learning algorithm, allowing firms to adapt their production strategies based on past profits, and observe how market outcomes emerge from this adaptive process.",
            "id": "2422430",
            "problem": "Consider a homogeneous-good Cournot duopoly with inverse demand and constant marginal costs. Time is discrete. In each period, two firms simultaneously select nonnegative quantities and receive profits from the realized market price. Neither firm knows the rival’s behavior. Instead, each firm adapts its own quantity over time by updating an internal value associated with each feasible quantity level based only on realized profits.\n\nModel primitives and timing are as follows.\n\n1. Market environment.\n- Inverse demand is given by $p_t = \\max\\{0, a - b(q_{1,t} + q_{2,t})\\}$ for each period $t$, where $a \\gt 0$, $b \\gt 0$, and $q_{i,t} \\ge 0$ is firm $i$’s output in period $t$.\n- Firm $i$ has constant marginal cost $c_i \\ge 0$, so its period-$t$ profit is $\\pi_{i,t} = (p_t - c_i)\\,q_{i,t}$.\n\n2. Action space discretization.\n- Fix a capacity $Q_{\\max} \\gt 0$ and an integer grid size $M \\ge 2$. Each firm’s feasible action set is the grid $\\mathcal{A} = \\{0, \\Delta, 2\\Delta, \\dots, Q_{\\max}\\}$ of size $M$, where $\\Delta = Q_{\\max}/(M-1)$.\n\n3. Learning dynamics.\n- Each firm $i \\in \\{1,2\\}$ maintains a vector of action values $Q_i \\in \\mathbb{R}^M$ initialized at $Q_i[m] = 0$ for all indices $m \\in \\{0,1,\\dots,M-1\\}$.\n- For each period $t \\in \\{1,2,\\dots,T\\}$:\n    - Each firm independently draws its action using a softmax choice rule with temperature parameter $\\tau \\gt 0$:\n    $$\\mathbb{P}\\{a_{i,t} = m\\} = \\frac{\\exp\\!\\left(Q_i[m]/\\tau\\right)}{\\sum_{j=0}^{M-1} \\exp\\!\\left(Q_i[j]/\\tau\\right)}, \\quad m \\in \\{0,1,\\dots,M-1\\}.$$\n    - The corresponding output is $q_{i,t} = m\\Delta$ if $a_{i,t} = m$.\n    - The market price $p_t$ and profits $\\pi_{i,t}$ are realized from the demand and cost primitives.\n    - Each firm updates only the value of the action it played using a recency-weighted rule with learning rate $\\alpha \\in (0,1]$:\n    $$Q_i[a_{i,t}] \\leftarrow (1 - \\alpha)\\,Q_i[a_{i,t}] + \\alpha\\,\\pi_{i,t}.$$\n    - All other components of $Q_i$ remain unchanged in that period.\n- All random draws are to be generated from a pseudo-random number generator with a specified integer seed for reproducibility.\n\n4. Performance measure.\n- After $T$ periods, compute the average outputs over the last $W$ periods for each firm:\n$$\\overline{q_i} = \\frac{1}{W} \\sum_{t=T-W+1}^{T} q_{i,t}, \\quad i \\in \\{1,2\\},$$\nwhere $W \\in \\{1,2,\\dots,T\\}$ is given. The required outputs are the two averages $(\\overline{q_1}, \\overline{q_2})$ for each parameter set.\n\nImplementation requirements.\n\n- Use the exact dynamics above. Use the exact softmax choice probabilities and the exact value update rule stated. Use $p_t = \\max\\{0, a - b(q_{1,t}+q_{2,t})\\}$ for all $t$.\n- Use the specified pseudo-random number generator seed for each test case to make all action draws, and reinitialize the generator to that seed at the start of each test case.\n- For each test case, report the pair $(\\overline{q_1}, \\overline{q_2})$ rounded to $4$ decimal places.\n\nTest suite.\n\nFor each line below, the tuple is $(a, b, c_1, c_2, Q_{\\max}, M, \\alpha, \\tau, T, W, \\text{seed})$.\n\n- Case A (symmetric, interior benchmark): $(100.0, 1.0, 10.0, 10.0, 100.0, 51, 0.10, 1.00, 20000, 5000, 2023)$.\n- Case B (asymmetric costs): $(100.0, 1.0, 10.0, 40.0, 100.0, 51, 0.10, 1.00, 20000, 5000, 2024)$.\n- Case C (near-boundary high costs): $(50.0, 1.5, 45.0, 45.0, 60.0, 61, 0.15, 0.80, 20000, 5000, 2025)$.\n- Case D (tight capacity): $(60.0, 2.0, 5.0, 5.0, 10.0, 21, 0.10, 0.70, 20000, 5000, 2026)$.\n\nFinal output format.\n\n- Your program should produce a single line of output containing the results for Cases A–D as a comma-separated list of length $4$, where each element is itself a two-element list $[\\overline{q_1}, \\overline{q_2}]$. The line must be a single Python-style list literal with each average rounded to $4$ decimal places, for example:\n$[[x_{A,1}, x_{A,2}],[x_{B,1}, x_{B,2}],[x_{C,1}, x_{C,2}],[x_{D,1}, x_{D,2}]]$.",
            "solution": "The problem statement is subjected to validation.\n\n### Step 1: Extract Givens\n\n- **Market Model**: Homogeneous-good Cournot duopoly.\n- **Inverse Demand Function**: $p_t = \\max\\{0, a - b(q_{1,t} + q_{2,t})\\}$, with parameters $a  0$, $b  0$.\n- **Firm Output**: $q_{i,t} \\ge 0$ for firm $i \\in \\{1,2\\}$ in period $t$.\n- **Cost Structure**: Firm $i$ has constant marginal cost $c_i \\ge 0$.\n- **Profit Function**: $\\pi_{i,t} = (p_t - c_i)\\,q_{i,t}$.\n- **Action Space**: A discrete grid $\\mathcal{A} = \\{0, \\Delta, 2\\Delta, \\dots, Q_{\\max}\\}$ of size $M \\ge 2$, where $Q_{\\max}  0$ is a capacity limit and $\\Delta = Q_{\\max}/(M-1)$.\n- **Learning Model**: Each firm $i$ maintains an action-value vector $Q_i \\in \\mathbb{R}^M$.\n- **Initialization**: At $t=0$, $Q_i[m] = 0$ for all $m \\in \\{0, \\dots, M-1\\}$.\n- **Simulation Horizon**: $t \\in \\{1, 2, \\dots, T\\}$.\n- **Action Selection**: Softmax choice rule with temperature $\\tau  0$: \n$$ \\mathbb{P}\\{a_{i,t} = m\\} = \\frac{\\exp(Q_i[m]/\\tau)}{\\sum_{j=0}^{M-1} \\exp(Q_i[j]/\\tau)} $$\n- **Output from Action**: If action $a_{i,t} = m$, then quantity $q_{i,t} = m\\Delta$.\n- **Value Update Rule**: A recency-weighted average with learning rate $\\alpha \\in (0,1]$:\n$$ Q_i[a_{i,t}] \\leftarrow (1 - \\alpha)\\,Q_i[a_{i,t}] + \\alpha\\,\\pi_{i,t} $$\nOnly the value of the selected action is updated.\n- **Reproducibility**: All random draws must be from a pseudo-random number generator initialized with a specified integer seed for each test case.\n- **Performance Metric**: The average outputs over the last $W$ periods, where $W \\in \\{1, \\dots, T\\}$:\n$$ \\overline{q_i} = \\frac{1}{W} \\sum_{t=T-W+1}^{T} q_{i,t} $$\n- **Test Cases**: Four sets of parameters $(a, b, c_1, c_2, Q_{\\max}, M, \\alpha, \\tau, T, W, \\text{seed})$ are provided.\n- **Output Formatting**: The final result is a list of pairs $(\\overline{q_1}, \\overline{q_2})$ for each case, rounded to $4$ decimal places, formatted as a Python-style list of lists.\n\n### Step 2: Validate Using Extracted Givens\n\n- **Scientific Groundedness**: The problem describes a Cournot duopoly model where firms use a standard reinforcement learning algorithm (related to Q-learning and exponential weights) to adapt their strategies. This is a well-established and scientifically valid topic within computational economics and game theory. The model does not violate any fundamental principles.\n- **Well-Posedness**: The problem specifies a complete computational procedure. All parameters, initial conditions, and dynamic rules are explicitly defined. The use of a pseudo-random number generator with a fixed seed for each case ensures that the simulation is deterministic and produces a unique result. The problem is therefore well-posed.\n- **Objectivity**: The problem is stated using precise mathematical and algorithmic language, free of any subjective or ambiguous terminology.\n\nThe problem statement passes all validation criteria. It is scientifically sound, well-posed, objective, complete, and computationally feasible. There are no contradictions or fallacies.\n\n### Step 3: Verdict and Action\n\nThe problem is **valid**. A solution will be provided.\n\n### Algorithmic Solution\n\nThe problem requires the implementation of a simulation of a two-firm (duopoly) Cournot market competition. Both firms act as autonomous agents that learn over time. The solution involves constructing a discrete-time simulation that proceeds for $T$ periods. For each test case, the simulation must be re-initialized with the specified parameters.\n\nThe core of the solution is a loop that iterates from $t=1$ to $T$. For each simulation, the following objects must be initialized:\n\n1.  A pseudo-random number generator (RNG) with the specified `seed`. This is critical for reproducibility.\n2.  The discrete action space $\\mathcal{A}$, which is a grid of $M$ equally spaced quantity levels from $0$ to $Q_{\\max}$. Let this be represented by a vector `actions` of length $M$, where `actions`$[m] = m \\cdot \\Delta$.\n3.  Two action-value vectors, $Q_1$ and $Q_2$, each of size $M$, initialized to all zeros.\n4.  Two history vectors, `q1_history` and `q2_history`, of length $T$, to store the chosen quantities in each period.\n\nInside the main loop for each period $t$:\n\n1.  **Action Selection**: For each firm $i \\in \\{1,2\\}$, an action must be chosen. This is a two-step process:\n    a.  Compute the softmax probabilities for each action $m \\in \\{0, \\dots, M-1\\}$ using the current action-value vector $Q_i$ and the temperature parameter $\\tau$. To ensure numerical stability, it is standard practice to subtract the maximum value of the vector $Q_i/\\tau$ from all its elements before applying the exponential function. The probabilities $P_i$ are then given by:\n    $$ v_m = Q_i[m]/\\tau $$\n    $$ P_i[m] = \\frac{\\exp(v_m - \\max(v))}{\\sum_{j=0}^{M-1} \\exp(v_j - \\max(v))} $$\n    b.  Use the RNG to draw an action index $a_{i,t} \\in \\{0, \\dots, M-1\\}$ according to the probability distribution $P_i$.\n\n2.  **Market Interaction**: Once both firms have selected their actions, $a_{1,t}$ and $a_{2,t}$, their respective output quantities are determined:\n    $$ q_{i,t} = \\text{actions}[a_{i,t}] $$\n    These quantities are stored in the history vectors. The total market quantity is $Q_{\\text{total}, t} = q_{1,t} + q_{2,t}$. The market price is then realized according to the inverse demand function:\n    $$ p_t = \\max\\{0, a - b \\cdot Q_{\\text{total}, t}\\} $$\n\n3.  **Profit Calculation**: Each firm's profit for the period is calculated:\n    $$ \\pi_{i,t} = (p_t - c_i) \\cdot q_{i,t} $$\n\n4.  **Value Update**: Each firm updates the value associated with the action it just played. For each firm $i$, the update rule is applied to the single element $Q_i[a_{i,t}]$:\n    $$ Q_i[a_{i,t}] \\leftarrow (1 - \\alpha) \\cdot Q_i[a_{i,t}] + \\alpha \\cdot \\pi_{i,t} $$\n\nAfter the simulation loop over $T$ periods completes, the performance metric is computed. For each firm $i$, the average quantity $\\overline{q_i}$ is calculated over the last $W$ periods of the simulation, using the stored `q_history` vectors.\n\n$$ \\overline{q_i} = \\frac{1}{W} \\sum_{k=T-W}^{T-1} \\text{q\\_history}_i[k] $$\nThese two averages, $(\\overline{q_1}, \\overline{q_2})$, are rounded to $4$ decimal places. This entire procedure is repeated for each of the four test cases provided. The final output is an aggregation of the results from all cases into the specified list-of-lists format.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Cournot duopoly learning simulation for the given test cases.\n    \"\"\"\n    test_cases = [\n        # Case A (symmetric, interior benchmark)\n        (100.0, 1.0, 10.0, 10.0, 100.0, 51, 0.10, 1.00, 20000, 5000, 2023),\n        # Case B (asymmetric costs)\n        (100.0, 1.0, 10.0, 40.0, 100.0, 51, 0.10, 1.00, 20000, 5000, 2024),\n        # Case C (near-boundary high costs)\n        (50.0, 1.5, 45.0, 45.0, 60.0, 61, 0.15, 0.80, 20000, 5000, 2025),\n        # Case D (tight capacity)\n        (60.0, 2.0, 5.0, 5.0, 10.0, 21, 0.10, 0.70, 20000, 5000, 2026),\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        a, b, c1, c2, Q_max, M, alpha, tau, T, W, seed = case\n\n        # Initialize pseudo-random number generator for reproducibility\n        rng = np.random.default_rng(seed)\n\n        # 1. Setup\n        # Action space\n        delta = Q_max / (M - 1)\n        actions = np.arange(M) * delta\n        action_indices = np.arange(M)\n\n        # Action-value vectors\n        Q1 = np.zeros(M)\n        Q2 = np.zeros(M)\n\n        # History of quantities\n        q1_history = np.zeros(T)\n        q2_history = np.zeros(T)\n\n        # 2. Simulation Loop\n        for t in range(T):\n            # Firm 1 action selection\n            v1 = Q1 / tau\n            # Numerically stable softmax\n            exp_v1 = np.exp(v1 - np.max(v1))\n            probs1 = exp_v1 / np.sum(exp_v1)\n            action_idx1 = rng.choice(action_indices, p=probs1)\n            q1_t = actions[action_idx1]\n\n            # Firm 2 action selection\n            v2 = Q2 / tau\n            exp_v2 = np.exp(v2 - np.max(v2))\n            probs2 = exp_v2 / np.sum(exp_v2)\n            action_idx2 = rng.choice(action_indices, p=probs2)\n            q2_t = actions[action_idx2]\n            \n            # Store quantities\n            q1_history[t] = q1_t\n            q2_history[t] = q2_t\n\n            # Market price\n            p_t = max(0.0, a - b * (q1_t + q2_t))\n\n            # Profits\n            pi1_t = (p_t - c1) * q1_t\n            pi2_t = (p_t - c2) * q2_t\n\n            # Value update\n            Q1[action_idx1] = (1.0 - alpha) * Q1[action_idx1] + alpha * pi1_t\n            Q2[action_idx2] = (1.0 - alpha) * Q2[action_idx2] + alpha * pi2_t\n\n        # 3. Performance Measure\n        avg_q1 = np.mean(q1_history[-W:])\n        avg_q2 = np.mean(q2_history[-W:])\n\n        # Append rounded results\n        result_pair = [round(avg_q1, 4), round(avg_q2, 4)]\n        all_results.append(result_pair)\n\n    # 4. Final Output Formatting\n    # The format is a string representation of a Python list of lists.\n    # str(list) automatically adds spaces after commas, which is fine for a Python literal.\n    print(str(all_results).replace(\" \", \"\"))\n\nsolve()\n```"
        }
    ]
}