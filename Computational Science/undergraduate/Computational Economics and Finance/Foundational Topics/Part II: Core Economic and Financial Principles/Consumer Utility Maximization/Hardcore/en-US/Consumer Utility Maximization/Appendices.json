{
    "hands_on_practices": [
        {
            "introduction": "Standard consumer theory often starts with the simplifying assumption of linear prices. This first practice challenges that assumption by introducing a \"buy-one-get-one-free\" offer, a common real-world promotion that creates a non-linear budget constraint. By solving this problem, you will learn to handle optimization with kinked budget sets and compare the outcome to a scenario with an \"equivalent\" linear price cut, offering deep insights into the subtleties of consumer choice .",
            "id": "2384155",
            "problem": "Consider a single consumer who allocates a nonnegative quantity of a marketed good $x$ and a nonnegative quantity of a composite outside good $y$ to maximize a Cobb–Douglas utility function $u(x,y) = x^{\\alpha} y^{1-\\alpha}$, where $0 < \\alpha < 1$. The consumer faces a linear budget with total income $I > 0$. The price of $y$ is $p_y > 0$. The marketed good $x$ is sold under two alternative pricing regimes:\n\n- Regime A (Buy-One-Get-One-Free, abbreviated as BOGO): for every unit of $x$ purchased at price $p_x > 0$, the consumer receives one unit of $x$ at zero marginal price. The consumer must choose $x$ in integer units. Under this regime, to consume $x \\in \\{0,1,2,\\dots\\}$ units, the total expenditure on $x$ is $p_x \\cdot \\lceil x/2 \\rceil$, where $\\lceil \\cdot \\rceil$ denotes the ceiling function. The outside good $y$ is continuously divisible.\n- Regime B (Uniform Equivalent Price Reduction): the good $x$ is priced at a uniform per-unit price equal to one half of the original price, that is $p_x' = p_x/2$, with no quantity-based promotions. Both $x$ and $y$ are continuously divisible.\n\nYour task is to simulate and compare the consumer’s optimal choices under these two regimes for a set of parameter values. Use only the foundational definitions of utility maximization and budget feasibility. Do not assume any special structure beyond what is explicitly stated above.\n\nRequirements to implement:\n\n- Under Regime A, the consumer solves the discrete–continuous problem: choose an integer $x \\in \\{0,1,2,\\dots\\}$ and a nonnegative real $y \\ge 0$ to maximize $u(x,y)$ subject to the budget constraint $p_x \\cdot \\lceil x/2 \\rceil + p_y \\cdot y \\le I$. For any fixed feasible integer $x$, the optimal $y$ exhausts the remaining budget. Search over all feasible integers $x$ for which the budget constraint can be satisfied.\n- Under Regime B, the consumer solves the continuous problem: choose $x \\ge 0$ and $y \\ge 0$ to maximize $u(x,y)$ subject to $p_x' x + p_y y \\le I$, where $p_x' = p_x/2$.\n\nFor each test case below, compute:\n- The optimal choice under Regime A, reported as the pair $(x_A^\\star, y_A^\\star)$ with $x_A^\\star$ an integer and $y_A^\\star$ a real number.\n- The optimal choice under Regime B, reported as the pair $(x_B^\\star, y_B^\\star)$, both real numbers.\n- The corresponding utilities $u_A^\\star = u(x_A^\\star, y_A^\\star)$ and $u_B^\\star = u(x_B^\\star, y_B^\\star)$.\n\nTest suite (parameters provided as $(I, p_x, p_y, \\alpha)$):\n\n- Case $1$: $(100, 10, 10, 0.5)$.\n- Case $2$: $(9, 10, 1, 0.5)$.\n- Case $3$: $(20, 7, 2, 0.3)$.\n- Case $4$: $(11, 5, 1, 0.7)$.\n- Case $5$: $(50, 8, 12, 0.1)$.\n\nFinal output format:\n\n- Your program should produce a single line of output containing a list of results for the five cases, in the same order as listed. Each case’s result must be a list of the form $[x_A^\\star, y_A^\\star, x_B^\\star, y_B^\\star, u_A^\\star, u_B^\\star]$.\n- The overall output must thus look like a single list of five inner lists. All real numbers must be rounded to $6$ decimal places. For example: $[[\\dots],[\\dots],[\\dots],[\\dots],[\\dots]]$.",
            "solution": "The problem presented is a well-defined exercise in consumer theory, a branch of microeconomics. It requires the determination of optimal consumption bundles under two different pricing schemes for a single good, subject to a budget constraint, for a consumer with a Cobb-Douglas utility function. The problem is scientifically grounded, internally consistent, and requires no information beyond what is provided. Thus, it is a valid problem, and a rigorous solution can be constructed.\n\nThe consumer's objective is to maximize the utility function $u(x,y) = x^{\\alpha} y^{1-\\alpha}$ for $x \\ge 0$, $y \\ge 0$, and $0 < \\alpha < 1$. The utility function is strictly increasing in both arguments, which implies that the consumer will always exhaust their entire income, $I$. The budget constraint will therefore always be binding, holding with equality. We analyze the two specified pricing regimes.\n\n### Regime B: Uniform Equivalent Price Reduction\n\nThis regime represents a standard continuous optimization problem. The consumer chooses continuous quantities of goods $x$ and $y$ to maximize utility. The price of good $x$ is set to $p_x' = p_x/2$. The budget constraint is linear:\n$$p_x' x + p_y y = I$$\nSubstituting $p_x' = p_x/2$, we have:\n$$\\frac{p_x}{2} x + p_y y = I$$\nThis is a classic utility maximization problem with a Cobb-Douglas utility function. The solution is found by setting the marginal rate of substitution (MRS) equal to the price ratio.\n$$MRS_{x,y} = \\frac{\\partial u / \\partial x}{\\partial u / \\partial y} = \\frac{\\alpha x^{\\alpha-1} y^{1-\\alpha}}{(1-\\alpha) x^{\\alpha} y^{-\\alpha}} = \\frac{\\alpha y}{(1-\\alpha) x}$$\nThe price ratio is:\n$$\\frac{p_x'}{p_y} = \\frac{p_x/2}{p_y} = \\frac{p_x}{2p_y}$$\nEquating the MRS and the price ratio gives the tangency condition:\n$$\\frac{\\alpha y}{(1-\\alpha) x} = \\frac{p_x}{2p_y}$$\n$$p_y y = \\frac{1-\\alpha}{\\alpha} \\frac{p_x}{2} x$$\nSubstituting this into the budget constraint:\n$$\\frac{p_x}{2} x + \\left(\\frac{1-\\alpha}{\\alpha} \\frac{p_x}{2} x\\right) = I$$\n$$\\frac{p_x}{2} x \\left(1 + \\frac{1-\\alpha}{\\alpha}\\right) = I$$\n$$\\frac{p_x}{2} x \\left(\\frac{\\alpha + 1 - \\alpha}{\\alpha}\\right) = I$$\n$$\\frac{p_x}{2} x \\left(\\frac{1}{\\alpha}\\right) = I$$\nSolving for the optimal quantity $x_B^\\star$:\n$$x_B^\\star = \\frac{2 \\alpha I}{p_x}$$\nSubstituting $x_B^\\star$ back into the expression for $p_y y$:\n$$p_y y_B^\\star = I - \\frac{p_x}{2} x_B^\\star = I - \\frac{p_x}{2} \\left(\\frac{2 \\alpha I}{p_x}\\right) = I - \\alpha I = (1-\\alpha)I$$\nSolving for the optimal quantity $y_B^\\star$:\n$$y_B^\\star = \\frac{(1-\\alpha)I}{p_y}$$\nThese are the Marshallian demand functions for Regime B. The corresponding maximum utility is $u_B^\\star = u(x_B^\\star, y_B^\\star)$.\n\n### Regime A: Buy-One-Get-One-Free (BOGO)\n\nThis regime presents a discrete-continuous optimization problem. The quantity of good $x$ must be an integer, $x_A \\in \\{0, 1, 2, \\ldots\\}$, while the quantity of good $y$ is continuous, $y_A \\ge 0$. The budget constraint is non-linear due to the pricing structure for $x$:\n$$p_x \\lceil x_A/2 \\rceil + p_y y_A = I$$\nwhere $\\lceil \\cdot \\rceil$ is the ceiling function.\n\nFor any given integer choice of $x_A$, the optimal quantity of $y_A$ is determined by the binding budget constraint:\n$$y_A(x_A) = \\frac{I - p_x \\lceil x_A/2 \\rceil}{p_y}$$\nThis choice is feasible only if $y_A(x_A) \\ge 0$, which implies $p_x \\lceil x_A/2 \\rceil \\le I$. This condition establishes an upper bound on the possible integer values of $x_A$. Specifically, $\\lceil x_A/2 \\rceil \\le I/p_x$, which implies $x_A/2 \\le I/p_x$, so $x_A \\le 2I/p_x$. The search for the optimal integer $x_A^\\star$ can be restricted to the finite set:\n$$x_A \\in \\{0, 1, 2, \\ldots, \\lfloor 2I/p_x \\rfloor\\}$$\nalthough a more precise check $p_x \\lceil x_A/2 \\rceil \\le I$ for each $x_A$ is required.\n\nThe problem reduces to a one-dimensional search for the integer $x_A$ that maximizes the utility function, where $y_A$ is substituted out:\n$$\\max_{x_A \\in \\mathbb{Z}_{\\ge 0}, \\, p_x \\lceil x_A/2 \\rceil \\le I} u(x_A, y_A(x_A)) = (x_A)^{\\alpha} \\left( \\frac{I - p_x \\lceil x_A/2 \\rceil}{p_y} \\right)^{1-\\alpha}$$\nThe optimal bundle $(x_A^\\star, y_A^\\star)$ is found by iterating through all feasible integer values of $x_A$ from $0$ up to the maximum value allowed by the budget, calculating the corresponding $y_A(x_A)$ and the utility $u(x_A, y_A(x_A))$, and identifying the value $x_A$ that yields the highest utility.\n\nThe case $x_A = 0$ must be considered. In this case, $y_A(0) = I/p_y$ and $u(0, I/p_y) = 0$. This serves as a baseline utility. The algorithm will search for a positive integer $x_A$ that yields a utility greater than $0$.\n\n### Computational Algorithm\n\nFor each set of parameters $(I, p_x, p_y, \\alpha)$:\n\n1.  **Solve for Regime B:**\n    - Calculate $x_B^\\star = \\frac{2 \\alpha I}{p_x}$.\n    - Calculate $y_B^\\star = \\frac{(1-\\alpha)I}{p_y}$.\n    - Calculate $u_B^\\star = (x_B^\\star)^{\\alpha} (y_B^\\star)^{1-\\alpha}$.\n\n2.  **Solve for Regime A:**\n    - Initialize optimal values: $x_A^\\star = 0$, $y_A^\\star = I/p_y$, $u_A^\\star = 0$.\n    - Determine the maximum search value for $x_A$: $x_{max} = \\lfloor 2I/p_x \\rfloor$.\n    - Iterate $x_{test}$ from $1$ to $x_{max}$.\n    - For each $x_{test}$:\n        - Calculate the expenditure on $x$: $E_x = p_x \\cdot \\lceil x_{test}/2 \\rceil$.\n        - If $E_x > I$, this and all subsequent values of $x_{test}$ are infeasible, so terminate the search.\n        - Calculate the corresponding quantity of $y$: $y_{test} = (I - E_x)/p_y$.\n        - Calculate the utility: $u_{test} = (x_{test})^{\\alpha} (y_{test})^{1-\\alpha}$.\n        - If $u_{test} > u_A^\\star$, update the optimal values: $x_A^\\star = x_{test}$, $y_A^\\star = y_{test}$, $u_A^\\star = u_{test}$.\n\n3.  **Report Results:**\n    - Collect the computed values $(x_A^\\star, y_A^\\star, x_B^\\star, y_B^\\star, u_A^\\star, u_B^\\star)$ for the given parameter set.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the consumer utility maximization problem for two different pricing regimes\n    across a suite of test cases.\n    \"\"\"\n    # Test cases are provided as tuples of (I, p_x, p_y, alpha)\n    test_cases = [\n        (100.0, 10.0, 10.0, 0.5),\n        (9.0, 10.0, 1.0, 0.5),\n        (20.0, 7.0, 2.0, 0.3),\n        (11.0, 5.0, 1.0, 0.7),\n        (50.0, 8.0, 12.0, 0.1),\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        I, px, py, alpha = case\n\n        # --- Regime B: Uniform Equivalent Price Reduction (Continuous) ---\n        # Price of x is halved: p_x' = p_x / 2\n        px_prime = px / 2.0\n        \n        # Standard Cobb-Douglas demand functions\n        x_star_B = (alpha * I) / px_prime\n        y_star_B = ((1.0 - alpha) * I) / py\n        \n        # Calculate resulting utility\n        u_star_B = (x_star_B**alpha) * (y_star_B**(1.0 - alpha))\n        \n        # --- Regime A: Buy-One-Get-One-Free (Discrete-Continuous) ---\n        # Initialize with the bundle (0, I/py), which has utility 0\n        x_star_A = 0\n        y_star_A = I / py\n        u_star_A = 0.0\n\n        # Maximum possible integer value for x to search\n        x_max_search = int(np.floor(2.0 * I / px))\n\n        for x_test in range(1, x_max_search + 1):\n            # Cost of x under BOGO pricing: p_x * ceil(x/2)\n            cost_x = px * np.ceil(x_test / 2.0)\n\n            # If expenditure on x exceeds income, it's not a feasible bundle\n            if cost_x > I:\n                # Since cost_x is non-decreasing in x_test, we can stop searching\n                break\n            \n            # Remaining budget for y\n            y_test = (I - cost_x) / py\n            \n            # Calculate utility for this (x, y) bundle\n            # y_test will be non-negative due to the check above\n            u_test = (x_test**alpha) * (y_test**(1.0 - alpha))\n\n            # If this utility is the best so far, update the optimal choice\n            if u_test > u_star_A:\n                u_star_A = u_test\n                x_star_A = x_test\n                y_star_A = y_test\n\n        # Store results for this case. x_star_A is already an integer.\n        # Round all float values to 6 decimal places for final output.\n        case_results = [\n            x_star_A,\n            round(y_star_A, 6),\n            round(x_star_B, 6),\n            round(y_star_B, 6),\n            round(u_star_A, 6),\n            round(u_star_B, 6),\n        ]\n        all_results.append(case_results)\n\n    # Format the final output as a single-line string representation of a list of lists.\n    # Convert each inner list to its string representation and join them.\n    results_str = ','.join(map(str, all_results))\n    print(f\"[{results_str}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Having explored complex budget constraints, we now turn to different types of preferences. This exercise moves beyond the smooth trade-offs of Cobb-Douglas utility to Leontief preferences, which model perfect complements consumed in fixed ratios. Complicating matters further, one good is only available in discrete integer units, making this a mixed-integer programming problem that requires a different approach than simple calculus-based methods .",
            "id": "2384153",
            "problem": "Consider a consumer choosing nonnegative quantities of two goods, good $x$ and good $y$, to maximize utility subject to a linear budget constraint. The utility function is Leontief (perfect complements), given by $U(x,y)=\\min(a x, b y)$ where $a>0$ and $b>0$ are fixed parameters. Prices are $p_x>0$ for good $x$ and $p_y>0$ for good $y$. Income is $m\\ge 0$. The choice set is constrained by the budget $p_x x + p_y y \\le m$, $x \\ge 0$, and the availability restriction that $y$ must be chosen in discrete integer units $y \\in \\{0,1,2,\\dots\\}$. The consumer seeks to choose $(x,y)$ to maximize $U(x,y)$.\n\nAmong all utility-maximizing bundles, select the one with the smallest integer $y$ that attains the maximal utility. For that selected $y$, select $x$ to be the smallest nonnegative real value that attains the chosen utility while satisfying the budget constraint.\n\nAll variables are unitless. No angles or physical units are involved.\n\nYour program must compute, for each parameter set below, the utility-maximizing bundle $(x^\\star,y^\\star)$ and the corresponding maximal utility $U^\\star=U(x^\\star,y^\\star)$, under the constraints and selection rules stated above. The required output for each parameter set is the triple $[x^\\star,y^\\star,U^\\star]$.\n\nProvide results for the following test suite of parameter sets, each specified as $(a,b,p_x,p_y,m)$:\n- $(a,b,p_x,p_y,m) = (1, 1, 2, 3, 20)$\n- $(a,b,p_x,p_y,m) = (2, 1, 3, 5, 11)$\n- $(a,b,p_x,p_y,m) = (1.5, 2, 1, 10, 7)$\n- $(a,b,p_x,p_y,m) = (2, 1, 3, 4, 9.5)$\n- $(a,b,p_x,p_y,m) = (3, 5, 2, 7, 100)$\n\nFinal output format:\n- For each parameter set, output a triple $[x^\\star,y^\\star,U^\\star]$ where $x^\\star$ and $U^\\star$ are real numbers rounded to six decimal places and $y^\\star$ is an integer.\n- Aggregate the results for all parameter sets into a single line as a comma-separated list enclosed in square brackets, with no whitespace. For example: $[[x^\\star_1,y^\\star_1,U^\\star_1],[x^\\star_2,y^\\star_2,U^\\star_2],\\dots]$.",
            "solution": "The problem presented is a constrained utility maximization problem from the field of microeconomics. It is well-defined, mathematically consistent, and grounded in established economic theory. The utility function is of the Leontief form, $U(x,y)=\\min(ax, by)$, which represents perfect complements. The consumer's choice is subject to a budget constraint, $p_x x + p_y y \\le m$, and mixed-variable constraints, with good $x$ being a continuous non-negative variable ($x \\ge 0$) and good $y$ being a discrete non-negative integer ($y \\in \\{0,1,2,\\dots\\}$). The objective is to find the bundle $(x^\\star, y^\\star)$ and the corresponding maximal utility $U^\\star$ that satisfies these constraints, along with a specific set of tie-breaking rules.\n\nThe analysis begins with the nature of the Leontief utility function. To maximize utility, a rational consumer will never choose a bundle where $ax \\neq by$. If, for instance, $ax > by$, utility is determined solely by the term $by$. The consumer could reduce consumption of $x$ without any loss of utility, thereby saving income. This saved income could be reallocated to increase consumption of both goods, leading to a strictly higher utility level. Therefore, any optimal bundle with positive utility must satisfy the condition $ax = by$. This relation defines the expansion path, on which optimal bundles must lie. From this, we derive the optimal proportion of goods as $x = \\frac{b}{a}y$.\n\nThe constraint that $y$ must be an integer transforms the problem into a mixed-integer optimization problem. We can no longer simply solve the system of equations $ax = by$ and $p_x x + p_y y = m$. Instead, we must evaluate the maximum possible utility for each feasible integer value of $y$.\n\nAn integer choice for $y$, let us call it $y_k$, is feasible only if its cost does not exceed the total income, i.e., $p_y y_k \\le m$. This implies that the set of feasible integers for $y$ is finite, given by $y_k \\in \\{0, 1, 2, \\dots, \\lfloor \\frac{m}{p_y} \\rfloor \\}$. For any such feasible $y_k$, the consumer will maximize utility by allocating all remaining income to good $x$. The maximum quantity of $x$ that can be purchased is $x_{max} = \\frac{m - p_y y_k}{p_x}$. The utility for this bundle $(x_{max}, y_k)$ is $U_k = U(x_{max}, y_k) = \\min(a \\cdot x_{max}, b \\cdot y_k)$.\n\nOur objective is to find the integer $y_k$ from the feasible set that maximizes this function $U_k$. To guide this search, we consider the analogous problem where $y$ is a continuous variable. The utility $U(y) = \\min(a \\frac{m - p_y y}{p_x}, by)$ is maximized when the two arguments of the $\\min$ function are equal: $a \\frac{m - p_y y}{p_x} = by$. Solving for $y$ gives the continuous optimal value, $y_{cont}^* = \\frac{am}{b p_x + a p_y}$.\n\nThe function $g(y) = by$ is increasing in $y$, while the function $f(y) = a \\frac{m - p_y y}{p_x}$ is decreasing in $y$. The function $\\min(f(y), g(y))$ is therefore quasi-concave, increasing for $y < y_{cont}^*$ and decreasing for $y > y_{cont}^*$. Consequently, the maximum utility for an integer $y$ must occur at one of the two integers bracketing the continuous optimum: $y_1 = \\lfloor y_{cont}^* \\rfloor$ or $y_2 = \\lceil y_{cont}^* \\rceil = y_1 + 1$.\n\nThe solution algorithm is as follows:\n$1$. Calculate the continuous optimal value $y_{cont}^* = \\frac{am}{b p_x + a p_y}$.\n$2$. The first integer candidate is $y_1 = \\lfloor y_{cont}^* \\rfloor$. We compute the corresponding maximum utility $U_1 = \\min\\left(a \\frac{m - p_y y_1}{p_x}, b y_1\\right)$.\n$3$. The second integer candidate is $y_2 = y_1 + 1$. We must first verify its feasibility by checking if $p_y y_2 \\le m$. If it is feasible, we compute its utility $U_2 = \\min\\left(a \\frac{m - p_y y_2}{p_x}, b y_2\\right)$.\n$4$. We then determine the optimal integer $y^\\star$ and the maximal utility $U^\\star$. The maximal utility is $U^\\star = \\max(U_1, U_2)$ (or simply $U_1$ if $y_2$ is not feasible). The problem specifies a tie-breaking rule: if multiple bundles yield the same maximal utility, we must choose the one with the smallest integer $y^\\star$. Therefore:\n    - If $U_2 > U_1$, we select $y^\\star = y_2$ and $U^\\star = U_2$.\n    - Otherwise (if $U_1 \\ge U_2$ or if $y_2$ is infeasible), we select $y^\\star = y_1$ and $U^\\star = U_1$.\n$5$. Finally, we must determine the value of $x^\\star$. The second tie-breaking rule states that for the selected $y^\\star$, we must choose the smallest non-negative $x$ that achieves utility $U^\\star$ and satisfies the budget constraint. To achieve utility $U^\\star$, we require $\\min(ax, by^\\star) \\ge U^\\star$. This implies $ax \\ge U^\\star$ and $by^\\star \\ge U^\\star$. The condition $ax \\ge U^\\star$ gives $x \\ge U^\\star/a$. The smallest non-negative $x$ satisfying this is precisely $x^\\star = U^\\star/a$. This choice of $x^\\star$ is guaranteed to be budget-feasible by the definition of $U^\\star$.\n\nThis procedure provides the unique utility-maximizing bundle $(x^\\star, y^\\star)$ and the associated utility $U^\\star$ according to the problem's specifications.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the utility maximization problem for a series of test cases.\n    The utility function is Leontief U(x,y) = min(ax, by), with y being discrete.\n    \"\"\"\n    # Define the test cases from the problem statement as (a, b, p_x, p_y, m).\n    test_cases = [\n        (1.0, 1.0, 2.0, 3.0, 20.0),\n        (2.0, 1.0, 3.0, 5.0, 11.0),\n        (1.5, 2.0, 1.0, 10.0, 7.0),\n        (2.0, 1.0, 3.0, 4.0, 9.5),\n        (3.0, 5.0, 2.0, 7.0, 100.0),\n    ]\n\n    results_as_strings = []\n    for a, b, px, py, m in test_cases:\n        # Handle the trivial case of zero income.\n        if m = 0:\n            x_star, y_star, U_star = 0.0, 0, 0.0\n        else:\n            # Calculate the optimal 'y' as if it were a continuous variable.\n            # This is the point where the two components of the utility function,\n            # scaled by the budget, would be equal.\n            # y_cont_star = (a * m) / (b * p_x + a * p_y)\n            y_cont_star = (a * m) / (b * px + a * py)\n            \n            # The optimal integer y must be one of the two integers surrounding y_cont_star.\n            # Candidate 1: floor(y_cont_star)\n            y1 = int(np.floor(y_cont_star))\n            \n            # Calculate the maximum utility achievable with y1.\n            # This assumes all remaining budget is spent on x.\n            xmax1 = (m - py * y1) / px\n            U1 = min(a * xmax1, b * y1)\n            \n            # Initialize the optimal choice with the results from y1.\n            y_star = y1\n            U_star = U1\n            \n            # Candidate 2: ceil(y_cont_star) = y1 + 1\n            y2 = y1 + 1\n            \n            # Check if y2 is affordable within the budget.\n            if py * y2 = m:\n                # If affordable, calculate its corresponding maximum utility.\n                xmax2 = (m - py * y2) / px\n                U2 = min(a * xmax2, b * y2)\n                \n                # Update the optimal choice if y2 yields a strictly higher utility.\n                # If utilities are equal, the tie-breaking rule requires choosing the\n                # smaller y, which is y1, so we do nothing in case of a tie.\n                if U2 > U1:\n                    y_star = y2\n                    U_star = U2\n            \n            # The final optimal value of x is determined by the utility level U_star.\n            # To get utility U_star, we must have ax >= U_star, so the smallest x is U_star / a.\n            if a > 0:\n                x_star = U_star / a\n            else: # Should not happen based on problem constraints (a>0)\n                x_star = 0.0\n\n        # Format the result triple [x*, y*, U*] as a string.\n        res_str = f\"[{x_star:.6f},{y_star},{U_star:.6f}]\"\n        results_as_strings.append(res_str)\n        \n    # Aggregate all result strings into the final required output format.\n    final_output = f\"[{','.join(results_as_strings)}]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "Our final practice makes a powerful connection between economics and computer science by modeling a consumer choosing among a set of indivisible goods. This scenario transforms the utility maximization problem into the classic 0/1 knapsack problem, a cornerstone of combinatorial optimization. By framing the consumer's dilemma as an integer program and solving it with dynamic programming, you will gain a versatile tool for analyzing a wide range of discrete choice situations .",
            "id": "2384164",
            "problem": "You are given a discrete-time consumer choice problem with indivisible goods. The consumer faces a finite set of goods indexed by $i \\in \\{1,\\dots,n\\}$. Each good can be either not purchased or purchased in one unit. The consumer has a nonnegative, additively separable utility index represented by a vector $u \\in \\mathbb{R}_{\\ge 0}^{n}$, where $u_i$ is the utility of obtaining one unit of good $i$, and nonnegative prices represented by a vector $p \\in \\mathbb{R}_{\\ge 0}^{n}$, where $p_i$ is the price of one unit of good $i$. The consumer has a budget $M \\in \\mathbb{R}_{\\ge 0}$. The decision variables are $x_i \\in \\{0,1\\}$ for each $i$, indicating whether good $i$ is purchased. The consumer seeks to maximize total utility subject to the budget constraint.\n\nFrom fundamental microeconomic principles, the consumer problem is to maximize a utility function subject to a resource constraint. Under additivity across goods and indivisibility, this becomes a combinatorial optimization problem. Your task is to:\n\n- Derive the precise mathematical formulation of this discrete consumer choice problem from the definitions of utility maximization and the budget set, introducing binary decision variables and a linear budget constraint. Express the problem using a valid integer program.\n- Explain how this formulation is an instance of the zero-one knapsack problem, in which utilities play the role of values, prices play the role of weights, and the budget is the capacity.\n- Design and implement an exact algorithm that solves the problem as an integer program. You must produce an exact maximizer of total utility. You may use a principled algorithm such as a branch-and-bound scheme with a fractional knapsack upper bound, or a pseudo-polynomial dynamic program, ensuring correctness for all provided test cases. Clearly explain the algorithmic logic from first principles.\n\nYour program must implement the solver and apply it to the following test suite of instances, each specified by a utilities vector $u$, a prices vector $p$, and a budget $M$:\n\n- Test $1$ (general case): $u = [9,6,7,3]$, $p = [4,3,5,2]$, $M = 7$.\n- Test $2$ (zero budget boundary): $u = [5,4]$, $p = [1,2]$, $M = 0$.\n- Test $3$ (zero-price item): $u = [4,10,2]$, $p = [0,5,3]$, $M = 5$.\n- Test $4$ (tie in per-dollar utilities, unique optimal utility): $u = [6,6,5]$, $p = [4,4,5]$, $M = 8$.\n- Test $5$ (dominated item present): $u = [8,7,6,9]$, $p = [5,6,4,7]$, $M = 9$.\n- Test $6$ (budget exceeds total cost, take all): $u = [3,5,2]$, $p = [1,2,1]$, $M = 10$.\n\nDesign for coverage:\n- Test $1$ is a standard nontrivial instance.\n- Test $2$ checks the boundary case $M = 0$.\n- Test $3$ checks handling of zero-price items.\n- Test $4$ checks behavior under ties in utility-price ratios, with a unique optimal total utility.\n- Test $5$ includes a dominated option to verify correct pruning.\n- Test $6$ checks the capacity-dominated regime where the optimal choice is to buy all goods.\n\nAssumptions:\n- All utility entries satisfy $u_i \\ge 0$.\n- All prices satisfy $p_i \\ge 0$, with at least one $p_i  0$ unless otherwise stated.\n- If any $p_i = 0$ and $u_i  0$, it is always rational to set $x_i = 1$ for such items.\n\nYour program should compute, for each test case, the maximum achievable total utility as a single integer. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example $[a_1,a_2,\\dots,a_6]$, where $a_j$ is the maximum total utility for test $j$, in the order given above. No physical units or angle units are involved. Express each number as an integer. No percentages are used anywhere in this problem.",
            "solution": "The problem of discrete consumer choice under an additively separable utility function and a budget constraint is a classic model in microeconomic theory and a fundamental problem in combinatorial optimization. We shall first validate the problem statement, then derive its mathematical formulation, connect it to a known problem structure, and finally design and implement a correct and exact algorithm.\n\n**Problem Formulation**\n\nThe consumer's objective is to maximize total utility derived from a collection of goods, subject to a budget constraint. Let the set of goods be indexed by $i \\in \\{1, \\dots, n\\}$. For each good $i$, the consumer makes a binary decision, represented by the variable $x_i$, where $x_i = 1$ if the good is purchased and $x_i = 0$ if it is not.\nThe utility is additively separable, meaning the total utility is the sum of utilities from individual goods purchased. Given a utility vector $u = (u_1, u_2, \\dots, u_n)$, the total utility is expressed as the linear function:\n$$\nU(x) = \\sum_{i=1}^{n} u_i x_i\n$$\nThe consumer faces a budget constraint. Given a price vector $p = (p_1, p_2, \\dots, p_n)$ and a total budget $M$, the total expenditure must not exceed the budget. This is expressed as the linear inequality:\n$$\n\\sum_{i=1}^{n} p_i x_i \\le M\n$$\nCombining the objective function, the budget constraint, and the binary nature of the decision variables, we arrive at the following integer linear program (ILP) formulation:\n$$\n\\begin{aligned}\n\\text{maximize} \\quad  \\sum_{i=1}^{n} u_i x_i \\\\\n\\text{subject to} \\quad  \\sum_{i=1}^{n} p_i x_i \\le M \\\\\n x_i \\in \\{0, 1\\}, \\quad \\forall i \\in \\{1, \\dots, n\\}\n\\end{aligned}\n$$\nThis formulation precisely captures the consumer's optimization problem as described. All parameters ($u_i$, $p_i$, $M$) are non-negative real numbers, as given.\n\n**Relation to the 0-1 Knapsack Problem**\n\nThe derived ILP is structurally identical to the canonical 0-1 knapsack problem. The 0-1 knapsack problem is a combinatorial optimization problem defined as follows: given a set of items, each with a value and a weight, determine the subset of items to include in a collection (a \"knapsack\") so that the total value is maximized, subject to the constraint that the total weight does not exceed a given capacity.\n\nThe formal mapping is direct and unambiguous:\n-   The consumer's goods correspond to the *items* in the knapsack problem.\n-   The utility $u_i$ of good $i$ corresponds to the *value* of item $i$.\n-   The price $p_i$ of good $i$ corresponds to the *weight* of item $i$.\n-   The consumer's budget $M$ corresponds to the *capacity* of the knapsack.\n-   The decision variable $x_i$ (to purchase or not) is equivalent to the decision to include an item in the knapsack or not.\n\nTherefore, solving the consumer's utility maximization problem is equivalent to solving an instance of the 0-1 knapsack problem. This problem is known to be NP-hard, which implies that no known algorithm can solve it in time that is polynomial in the number of items and the number of bits required to represent the inputs. However, it admits a pseudo-polynomial time solution via dynamic programming.\n\n**Algorithmic Design: Dynamic Programming**\n\nWe will construct a dynamic programming algorithm to find the exact optimal utility. The algorithm relies on the principle of optimality: an optimal solution to the problem can be constructed from optimal solutions to its subproblems.\n\nFirst, we address the special case of zero-price items. As per the problem's assumption, if a good $i$ has $p_i=0$ and $u_i  0$, it is always optimal to acquire it, as it provides positive utility at no cost to the budget. We can therefore preprocess the item list. We sum the utilities of all such zero-price items to establish a `base_utility` and then solve the remaining problem for goods with positive prices using the original budget $M$.\n\nLet the remaining items (with $p_i0$) be indexed from $1$ to $n'$. The subproblem is defined as finding the maximum utility obtainable using a subset of the first $i$ items ($1 \\le i \\le n'$) with a budget of $w$ ($0 \\le w \\le M$). Let $dp[i][w]$ denote the value of this solution.\n\nThe recurrence relation is derived by considering the $i$-th item (utility $u_i$, price $p_i$):\n1.  **Do not include item $i$**: The maximum utility is the same as that achievable with the first $i-1$ items and budget $w$. This value is $dp[i-1][w]$.\n2.  **Include item $i$**: This is possible only if its price $p_i$ does not exceed the current budget $w$. If included, it contributes $u_i$ to the utility, and the remaining budget $w - p_i$ can be used optimally for the first $i-1$ items. The total utility in this case is $u_i + dp[i-1][w-p_i]$.\n\nThe optimal choice is the maximum of these two options. Thus, the recurrence is:\n$$\ndp[i][w] = \\begin{cases}\ndp[i-1][w]  \\text{if } p_i  w \\\\\n\\max(dp[i-1][w], u_i + dp[i-1][w-p_i])  \\text{if } p_i \\le w\n\\end{cases}\n$$\nThe base cases are $dp[0][w] = 0$ for all $w$, as there is no utility to be gained from zero items.\n\nThis two-dimensional DP formulation has a time complexity of $O(n'M)$ and a space complexity of $O(n'M)$. The space complexity can be optimized to $O(M)$ by observing that the calculation for row $i$ only depends on row $i-1$. By using a single one-dimensional array `dp[w]` and iterating the budget `w` downwards from $M$ to $p_i$, we prevent using the information of item $i$ multiple times within the same item-processing step. The optimized recurrence for a single array `dp` of size $M+1$ is:\n\nFor each item $i$ from $1$ to $n'$:\nFor each budget $w$ from $M$ down to $p_i$:\n$$\ndp[w] = \\max(dp[w], u_i + dp[w-p_i])\n$$\nThe final solution for the subproblem is $dp[M]$. The total maximum utility is this value plus the `base_utility` from zero-price items. Since the problem's test cases involve integer prices and budgets, this DP approach is applicable and efficient. The implementation will follow this optimized space approach.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Solves the discrete consumer choice problem for a suite of test cases.\n    This problem is equivalent to the 0-1 knapsack problem.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test 1 (general case)\n        {'u': [9, 6, 7, 3], 'p': [4, 3, 5, 2], 'M': 7},\n        # Test 2 (zero budget boundary)\n        {'u': [5, 4], 'p': [1, 2], 'M': 0},\n        # Test 3 (zero-price item)\n        {'u': [4, 10, 2], 'p': [0, 5, 3], 'M': 5},\n        # Test 4 (tie in per-dollar utilities, unique optimal utility)\n        {'u': [6, 6, 5], 'p': [4, 4, 5], 'M': 8},\n        # Test 5 (dominated item present)\n        {'u': [8, 7, 6, 9], 'p': [5, 6, 4, 7], 'M': 9},\n        # Test 6 (budget exceeds total cost, take all)\n        {'u': [3, 5, 2], 'p': [1, 2, 1], 'M': 10},\n    ]\n\n    results = []\n    for case in test_cases:\n        utilities = case['u']\n        prices = case['p']\n        budget = case['M']\n        \n        n = len(utilities)\n        base_utility = 0\n        \n        # Preprocessing step for zero-price items\n        positive_price_items = []\n        for i in range(n):\n            if prices[i] == 0:\n                if utilities[i] > 0:\n                    base_utility += utilities[i]\n            else:\n                # We only consider items that could potentially fit in the budget\n                if prices[i] = budget:\n                    positive_price_items.append({'u': utilities[i], 'p': prices[i]})\n\n        # If budget is 0, no items with positive price can be bought.\n        if budget == 0:\n            results.append(base_utility)\n            continue\n\n        # Dynamic Programming solution for the 0-1 Knapsack problem\n        # dp[w] stores the maximum utility for a budget of w.\n        # The budget is treated as an integer quantity.\n        dp = np.zeros(budget + 1, dtype=int)\n        \n        for item in positive_price_items:\n            utility = item['u']\n            price = item['p']\n            # Iterate backwards to use each item at most once\n            for w in range(budget, price - 1, -1):\n                dp[w] = max(dp[w], utility + dp[w - price])\n                \n        max_utility = dp[budget] + base_utility\n        results.append(int(max_utility))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}