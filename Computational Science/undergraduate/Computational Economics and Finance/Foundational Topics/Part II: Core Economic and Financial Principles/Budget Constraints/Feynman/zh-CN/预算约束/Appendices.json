{
    "hands_on_practices": [
        {
            "introduction": "标准的经济学模型通常假设价格是线性的，但现实世界中的定价策略往往更为复杂。本练习通过一个常见的“买一赠一”促销活动，向您展示如何从基本原则出发构建非线性预算约束。这项实践有助于您深入理解定价规则如何直接塑造消费者的机会集，并为分析更复杂的经济情景打下坚实基础。",
            "id": "2378669",
            "problem": "一位消费者选择两种完全可分商品（商品 $x_1$ 和商品 $x_2$）的数量，面临非负的价格 $p_1$ 和 $p_2$ 以及货币收入 $m$。预算集是在该商店标明的定价规则下，总支出不超过 $m$ 的所有非负商品组合的集合。商店对商品 $x_1$ 提供有上限的买一赠一（BOGO）促销活动：对于购买的每单位商品 $x_1$，在最多 $K$ 个付费单位的上限内，消费者有权免费获得等量的额外商品 $x_1$。超过此上限后，额外的商品 $x_1$ 不再附赠免费单位，所有后续单位都必须按标价 $p_1$ 支付。假设两种商品都是完全可分的，因此促销活动按比例适用。\n\n仅从预算集的定义和所描述的促销活动出发，推导预算集横轴截距（即当 $x_2=0$ 时 $x_1$ 的最大可得数量）作为 $m$、$p_1$ 和 $K$ 的函数的精确表达式。然后，使用 $p_1 = 4$、$p_2 = 5$、$m = 90$ 和 $K = 8$ 对该截距进行数值计算。提供截距的最终数值，无需四舍五入。",
            "solution": "在尝试任何解答之前，将对问题陈述进行验证。\n\n**步骤1：提取已知条件**\n- 商品：两种完全可分的商品，$x_1$ 和 $x_2$。\n- 价格：非负价格 $p_1$ 和 $p_2$。\n- 收入：货币收入 $m$。\n- 预算集：总支出不超过 $m$ 的非负商品组合 $(x_1, x_2)$ 的集合。\n- 促销：对商品 $x_1$ 进行买一赠一（BOGO）促销。每购买一单位商品 $x_1$，即可免费获赠等量单位。\n- 促销上限：BOGO促销最多适用于 $K$ 个付费单位的商品 $x_1$。超过此上限，所有后续单位的 $x_1$ 都必须按价格 $p_1$ 购买。\n- 可分性：对于完全可分的商品，促销按比例适用。\n- 目标1：推导预算集横轴截距（当 $x_2=0$ 时 $x_1$ 的最大值）作为 $m$、$p_1$ 和 $K$ 的函数的表达式。\n- 目标2：使用 $p_1 = 4$、$p_2 = 5$、$m = 90$ 和 $K = 8$对此截距进行数值计算。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题具有科学依据，提法得当且客观。它描述了一个非线性预算约束，这是微观经济学消费者理论中的一个标准主题。问题设定清晰，内部一致，并包含推导唯一解所需的所有信息。语言精确，没有主观论断。因此，该问题被认定为**有效**。\n\n**步骤3：结论与行动**\n问题有效。将提供完整解答。\n\n目标是求出当商品 $x_2$ 的数量为零（即 $x_2 = 0$）时，商品 $x_1$ 的最大可得数量。这即是预算集的横轴截距。商品总支出不得超过收入 $m$。当 $x_2=0$ 时，全部收入 $m$ 都可以用于消费商品 $x_1$。因此，我们必须确定用支出 $m$ 能获得的最大 $x_1$ 数量。\n\n让我们首先形式化获得第一种商品总数量 $x_1$ 所需的支出 $E_1(x_1)$。该定价规则是分段的。\n\n第1部分：BOGO促销机制\n促销活动规定，每支付一单位的 $x_1$，即可免费获得一单位。这意味着要获得总数量 $x_1$，消费者只需支付 $x_1/2$ 单位的费用。因此，成本为 $E_1(x_1) = p_1 \\cdot \\frac{x_1}{2}$。\n此促销在付费单位数量不超过 $K$ 时有效。付费单位数量为 $x_1/2$。所以，该定价规则适用于 $x_1/2 \\le K$，即 $0 \\le x_1 \\le 2K$。\n\n第2部分：标准定价机制\n如果消费者希望获得超过 $2K$ 单位的商品 $x_1$，他们必须首先用尽BOGO促销。获得前 $2K$ 单位商品 $x_1$ 的成本是支付 $K$ 单位的费用，即 $p_1 K$。\n对于任何超过 $2K$ 的数量，即 $x_1 > 2K$，额外的单位 $(x_1 - 2K)$ 必须按标准价格 $p_1$ 付费。这些额外单位的支出为 $p_1 (x_1 - 2K)$。\n获得数量 $x_1 > 2K$ 的总支出是前 $2K$ 单位的成本与额外单位成本之和：\n$$E_1(x_1) = p_1 K + p_1 (x_1 - 2K) = p_1 K + p_1 x_1 - 2p_1 K = p_1 (x_1 - K)$$\n\n结合这两部分，获得 $x_1$ 的支出函数为：\n$$ E_1(x_1) = \\begin{cases} \\frac{p_1 x_1}{2} & \\text{当 } 0 \\le x_1 \\le 2K \\\\ p_1(x_1 - K) & \\text{当 } x_1 > 2K \\end{cases} $$\n\n为了找到横轴截距，我们将总支出设为等于收入 $m$（因为 $x_2=0$），然后解出 $x_1$。解取决于 $m$ 相对于用尽BOGO促销所需支出 $p_1 K$ 的值。\n\n情况A：$m \\le p_1 K$\n如果收入不足以支付 $K$ 个单位，消费者将完全在BOGO促销机制内进行消费。通过将此机制下的支出设为等于 $m$ 来找到 $x_1$ 的最大数量：\n$$\\frac{p_1 x_1}{2} = m$$\n$$x_1 = \\frac{2m}{p_1}$$\n我们必须验证此结果与条件 $x_1 \\le 2K$ 一致。\n由于 $m \\le p_1 K$，我们有 $\\frac{m}{p_1} \\le K$，因此 $\\frac{2m}{p_1} \\le 2K$。条件满足。\n\n情况B：$m > p_1 K$\n如果收入大于用尽促销所需的成本，消费者将获得超过 $2K$ 单位的商品 $x_1$。支出由函数的第二部分给出：\n$$p_1(x_1 - K) = m$$\n$$x_1 - K = \\frac{m}{p_1}$$\n$$x_1 = K + \\frac{m}{p_1}$$\n我们必须验证此结果与条件 $x_1 > 2K$ 一致。\n由于 $m > p_1 K$，我们有 $\\frac{m}{p_1} > K$，这意味着 $K + \\frac{m}{p_1} > K+K = 2K$。条件满足。\n\n横轴截距 $x_{1, \\text{intercept}}$ 的通用表达式为：\n$$ x_{1, \\text{intercept}} = \\begin{cases} \\frac{2m}{p_1} & \\text{当 } m \\le p_1 K \\\\ K + \\frac{m}{p_1} & \\text{当 } m > p_1 K \\end{cases} $$\n问题的第一个部分到此结束。\n\n对于第二部分，我们必须使用给定的数值 $p_1 = 4$，$p_2 = 5$，$m = 90$ 和 $K = 8$ 计算此截距。$p_2$ 的值与此计算无关。\n首先，我们通过比较 $m$ 和 $p_1 K$ 来确定适用哪种情况：\n$$m = 90$$\n$$p_1 K = 4 \\times 8 = 32$$\n由于 $90 > 32$，我们有 $m > p_1 K$，这对应于情况B。\n截距的公式是 $x_{1, \\text{intercept}} = K + \\frac{m}{p_1}$。\n代入数值：\n$$x_{1, \\text{intercept}} = 8 + \\frac{90}{4}$$\n$$x_{1, \\text{intercept}} = 8 + 22.5$$\n$$x_{1, \\text{intercept}} = 30.5$$\n商品 $x_1$ 的最大可得数量是 $30.5$。",
            "answer": "$$\\boxed{30.5}$$"
        },
        {
            "introduction": "在掌握了简单的非线性定价后，我们将更进一步，探讨在公共政策中常见的“分段线性”或“扭折”预算约束。本练习将分析在累进所得税制度下的经典劳动-休闲选择模型。通过对税收等级如何导致预算线产生扭折点进行建模，您将学习如何用计算方法确定消费者的最优选择——该选择可能出现在扭折点上，而非传统的切点处，这是家庭经济学中的一个核心洞见。",
            "id": "2378657",
            "problem": "考虑一个代表性个人在累进所得税下的劳动-闲暇选择，该税制会产生一个分段线性的预算约束。时间是稀缺资源。该个人拥有固定的 $T$ 小时时间禀赋，选择劳动时间 $h \\in [0,T]$，进行消费 $c$，并享受闲暇 $s = T - h$。税前工资率为每小时 $w$，个人拥有非劳动收入 $b$。其偏好由柯布-道格拉斯效用函数 $U(c,s) = c^{\\alpha} s^{1-\\alpha}$ 表示，其中 $\\alpha \\in (0,1)$。\n\n政府根据一个税级表对劳动收入征收累进税。设税前劳动收入为 $y = w h$。税收方案由一系列税级阈值 $\\{K_0, K_1, \\dots, K_{N}\\}$（其中 $K_0 = 0$ 且 $K_{N} = +\\infty$）和相应的边际税率 $\\{t_1, t_2, \\dots, t_{N}\\}$ 定义，这些税率适用于阈值之间的收入增量。所有边际税率必须以小数形式提供（例如，使用 $0.2$ 而不是 $20\\%$）。应缴税款的计算方式为：较低税级的累计税额加上当前税级内收入的边际税额。消费由 $c = b + y - \\mathcal{T}(y)$ 给出，其中 $\\mathcal{T}(y)$ 是根据税级表定义的收入 $y$ 的总应缴税款。\n\n您的任务是：\n\n- 仅使用以下基本依据：(i) 预算约束的定义 $c = b + y - \\mathcal{T}(y)$，其中 $y = w h$，$\\mathcal{T}(y)$ 由分段边际税率和阈值定义；(ii) 闲暇的定义 $s = T - h$；以及 (iii) 内部最优解的一阶条件，即在适用情况下，将闲暇与消费之间的边际替代率等同于某个税级内的税后工资。非内部最优解可能出现在拐点或端点 $h=0$ 或 $h=T$ 处。\n- 对于每个税级 $i \\in \\{1,\\dots,N\\}$，边际税率 $t_i$ 适用于收入 $y \\in [K_{i-1},K_i)$ 的部分，总应缴税款可以写为较低税级的税收总和加上 $t_i$ 乘以当前税级内的收入金额。这意味着一个分段线性的预算约束，在税级 $i$ 内的斜率等于税后工资 $w(1 - t_i)$。\n- 您的程序必须为每个测试用例确定效用最大化的劳动时间选择 $h^\\star \\in [0,T]$。为此，需要检查理论所暗示的所有候选解：(a) 每个税级内的内部解，其中一阶条件成立，前提是其隐含的收入 $y = w h$ 位于该税级的收入范围内；以及 (b) 对应于阈值 $\\{K_1,\\dots,K_{N-1}\\}$ 的所有拐点，这些拐点必须在时间禀赋内可以达到，此外还包括端点 $h=0$ 和 $h=T$。对于每个候选的 $h$，计算 $c = b + w h - \\mathcal{T}(w h)$、$s = T - h$ 和 $U(c,s) = c^{\\alpha} s^{1-\\alpha}$，然后选择使 $U(c,s)$ 最大化的候选解。\n- 所有输入均为纯数值；除了 $T$ 和 $h$ 的单位是小时外，没有其他物理单位。所有输出必须是数值。不涉及角度。百分比必须以小数形式提供。\n\n待实现的测试套件：\n\n提供以下五个测试用例；在每个案例中，$K$ 列出阈值，$t$ 列出相应的边际税率：\n\n- 案例 1：$T = 16$, $w = 25$, $b = 10$, $\\alpha = 0.4$, $K = [0, 200, 400, +\\infty)$, $t = [0.0, 0.2, 0.35]$.\n- 案例 2：$T = 24$, $w = 20$, $b = 300$, $\\alpha = 0.2$, $K = [0, 100, 200, +\\infty)$, $t = [0.5, 0.7, 0.9]$.\n- 案例 3：$T = 8$, $w = 30$, $b = 0$, $\\alpha = 0.5$, $K = [0, +\\infty)$, $t = [0.25]$.\n- 案例 4：$T = 6$, $w = 40$, $b = 0$, $\\alpha = 0.5$, $K = [0, 80, 120, +\\infty)$, $t = [0.0, 0.5, 0.6]$.\n- 案例 5：$T = 12$, $w = 15$, $b = 0$, $\\alpha = 0.9$, $K = [0, 60, 120, +\\infty)$, $t = [0.1, 0.2, 0.4]$.\n\n最终输出格式：\n\n- 对于每个测试用例，输出一个列表 $[h^\\star, c^\\star, s^\\star, U^\\star]$，其中 $h^\\star, c^\\star, s^\\star, U^\\star$ 是精确到六位小数的浮点数。\n- 您的程序应生成单行输出，其中包含五个测试用例的结果，格式为一个逗号分隔的列表，并用方括号括起来，每个用例本身也表示为一个列表。例如：“[[h1,c1,s1,U1],[h2,c2,s2,U2],...]”，每个数字精确到六位小数，且无附加文本。",
            "solution": "我们从基本定义开始。个人选择劳动时间 $h \\in [0,T]$，闲暇为 $s = T - h$，税前劳动收入为 $y = w h$，消费为 $c = b + y - \\mathcal{T}(y)$。偏好由柯布-道格拉斯效用函数 $U(c,s) = c^{\\alpha} s^{1-\\alpha}$ 给出，参数 $\\alpha \\in (0,1)$。\n\n累进税制由阈值 $\\{K_0,\\dots,K_N\\}$（其中 $K_0 = 0$ 且 $K_N = +\\infty$）和税级边际税率 $\\{t_1,\\dots,t_N\\}$ 定义。在税级 $i$ 内，对于 $y \\in [K_{i-1}, K_i)$，总税额可以表示为\n$$\n\\mathcal{T}(y) \\;=\\; \\underbrace{\\sum_{j=1}^{i-1} t_j (K_j - K_{j-1})}_{\\text{截至 } K_{i-1} \\text{ 的累计税额}} \\;+\\; t_i \\, (y - K_{i-1}),\n$$\n其中 $C_{i-1} = \\sum_{j=1}^{i-1} t_j (K_j - K_{j-1})$ 是在较低阈值 $K_{i-1}$ 处的累计税额。因此，在税级 $i$ 内，\n$$\nc \\;=\\; b + y - \\mathcal{T}(y) \\;=\\; \\underbrace{b - C_{i-1} + t_i K_{i-1}}_{B_i} \\;+\\; (1 - t_i) y,\n$$\n这是 $y$（因此也是 $h$）的线性函数，其斜率等于税级 $i$ 内的税后工资，即 $w_i = w (1 - t_i)$。因此，对于税级 $i$ 内的 $y = w h$，我们有\n$$\nc(h) \\;=\\; B_i + w_i h\n\\quad\\text{和}\\quad\ns(h) \\;=\\; T - h.\n$$\n\n对于给定税级 $i$ 内的内部解，一阶条件将边际替代率等同于相应的税后工资：\n$$\n\\text{MRS}_{s,c} \\;=\\; \\frac{\\partial U/\\partial s}{\\partial U/\\partial c} \\;=\\; \\frac{(1-\\alpha)}{\\alpha} \\,\\frac{c}{s} \\;=\\; w_i.\n$$\n代入 $c = B_i + w_i h$ 和 $s = T - h$ 可得\n$$\n\\frac{(1-\\alpha)}{\\alpha}\\,\\frac{B_i + w_i h}{T - h} \\;=\\; w_i.\n$$\n解出 $h$ 即可得到税级 $i$ 的候选内部解：\n$$\nh_i^\\circ \\;=\\; \\alpha T \\;-\\; \\frac{1-\\alpha}{w_i}\\, B_i.\n$$\n这个 $h_i^\\circ$ 仅在可行时有效，即可行性意味着它满足 $0 \\le h_i^\\circ \\le T$，并且其隐含的收入 $y_i^\\circ = w h_i^\\circ$ 位于该税级的收入范围之内，即 $K_{i-1} \\le y_i^\\circ < K_i$。如果候选解不满足这些条件，则最优解不可能位于该税级的内部。\n\n除了内部候选解，最优解也可能出现在拐点处，因为预算约束的斜率在阈值 $\\{K_1,\\dots,K_{N-1}\\}$ 处发生变化。每个拐点对应劳动时间 $h_k = K_k / w$，前提是 $h_k \\le T$。端点 $h=0$ 和 $h=T$ 也是候选解。对于每个候选的 $h$，计算：\n- $y = w h$，\n- 来自税级表的总税额 $\\mathcal{T}(y)$，\n- $c = b + y - \\mathcal{T}(y)$，\n- $s = T - h$，\n- $U(c,s) = c^{\\alpha} s^{1-\\alpha}$。\n\n在所有候选解中，选择使 $U(c,s)$ 最大化的 $h^\\star$。如果多个候选解产生的效用值在数值容差范围内相等，为了保证结果的确定性，可以选择具有最小 $h$ 的候选解。\n\n算法设计：\n- 为每个税级 $i$ 预先计算累计税额 $C_{i-1}$、常数 $B_i = b - C_{i-1} + t_i K_{i-1}$ 和税后工资 $w_i = w(1 - t_i)$。\n- 生成候选集，包括：\n  - 内部候选解 $h_i^\\circ = \\alpha T - \\frac{1-\\alpha}{w_i} B_i$，需满足约束条件 $0 \\le h_i^\\circ \\le T$ 和 $K_{i-1} \\le w h_i^\\circ < K_i$。\n  - 适用于所有满足 $h_k \\le T$ 的阈值的拐点候选解 $h_k = K_k / w$。\n  - 端点 $h=0$ 和 $h=T$。\n- 对所有候选解计算 $U(c(h), s(h))$ 并选择最大化者。\n\n此程序独立应用于以下五个测试用例：\n- 案例 1：$T = 16$, $w = 25$, $b = 10$, $\\alpha = 0.4$, $K = [0, 200, 400, +\\infty)$, $t = [0.0, 0.2, 0.35]$.\n- 案例 2：$T = 24$, $w = 20$, $b = 300$, $\\alpha = 0.2$, $K = [0, 100, 200, +\\infty)$, $t = [0.5, 0.7, 0.9]$.\n- 案例 3：$T = 8$, $w = 30$, $b = 0$, $\\alpha = 0.5$, $K = [0, +\\infty)$, $t = [0.25]$.\n- 案例 4：$T = 6$, $w = 40$, $b = 0$, $\\alpha = 0.5$, $K = [0, 80, 120, +\\infty)$, $t = [0.0, 0.5, 0.6]$.\n- 案例 5：$T = 12$, $w = 15$, $b = 0$, $\\alpha = 0.9$, $K = [0, 60, 120, +\\infty)$, $t = [0.1, 0.2, 0.4]$.\n\n程序实现了这种候选解评估方法，为每个案例计算最优解 $[h^\\star, c^\\star, s^\\star, U^\\star]$，将每个值四舍五入到恰好六位小数，并按照规定格式将结果打印为单行的列表之列表。",
            "answer": "```python\nimport numpy as np\n\ndef compute_cumulative_tax_thresholds(K, t):\n    \"\"\"\n    Given thresholds K (length N+1 with K[0]=0, K[N]=inf) and marginal rates t (length N),\n    compute cumulative tax up to each lower threshold K[i] for bracket i (i from 0..N-1).\n    Returns list C where C[i] = cumulative tax up to K[i] (i.e., sum_{j< i} t[j]*(K[j+1]-K[j])).\n    \"\"\"\n    N = len(t)\n    C = [0.0] * (N + 1)\n    cum = 0.0\n    for i in range(1, N + 1):\n        # Tax in bracket i-1 fully applied up to K[i]\n        width = K[i] - K[i - 1]\n        if np.isfinite(width):\n            cum += t[i - 1] * width\n        else:\n            # Last width is infinite; do not add to cumulative because it's unbounded\n            cum += 0.0\n        C[i] = cum\n    return C\n\ndef total_tax(y, K, t):\n    \"\"\"\n    Compute total tax owed given income y, thresholds K, and marginal rates t.\n    \"\"\"\n    N = len(t)\n    tax = 0.0\n    remaining = y\n    for i in range(N):\n        lower = K[i]\n        upper = K[i + 1]\n        if remaining <= lower:\n            break\n        taxable = min(remaining, upper) - lower\n        if taxable > 0:\n            tax += t[i] * taxable\n    return tax\n\ndef evaluate_candidates(case):\n    T = float(case[\"T\"])\n    w = float(case[\"w\"])\n    b = float(case[\"b\"])\n    alpha = float(case[\"alpha\"])\n    # Ensure K and t are numpy arrays, last K can be inf\n    K = np.array(case[\"K\"], dtype=float)\n    t_rates = np.array(case[\"t\"], dtype=float)\n    N = len(t_rates)\n    # Precompute cumulative taxes at thresholds\n    C = compute_cumulative_tax_thresholds(K, t_rates)  # length N+1\n    # Generate candidates: endpoints\n    candidates = [0.0, T]\n    # Kinks: K[1..N-1]\n    for j in range(1, len(K) - 1):\n        h_kink = K[j] / w\n        if h_kink <= T + 1e-12:\n            candidates.append(max(0.0, min(T, h_kink)))\n    # Interior candidates within each bracket\n    for i in range(N):\n        lower = K[i]\n        upper = K[i + 1]\n        wi = w * (1.0 - t_rates[i])\n        # If after-tax wage is effectively zero, skip interior candidate\n        if wi <= 1e-12:\n            continue\n        Bi = b - C[i] + t_rates[i] * K[i]\n        h_int = alpha * T - (1.0 - alpha) * Bi / wi\n        # Feasibility: within [0,T] and income within bracket\n        if h_int < -1e-12 or h_int > T + 1e-12:\n            continue\n        y_int = w * h_int\n        lower_ok = y_int >= lower - 1e-9\n        upper_ok = (y_int < upper - 1e-9) or not np.isfinite(upper)\n        if lower_ok and upper_ok:\n            # Clamp to [0,T]\n            h_int = max(0.0, min(T, h_int))\n            candidates.append(h_int)\n    # Deduplicate candidates with tolerance\n    candidates_sorted = sorted(candidates)\n    uniq = []\n    for h in candidates_sorted:\n        if not uniq or abs(h - uniq[-1]) > 1e-9:\n            uniq.append(h)\n    # Evaluate utility and select best\n    best = None\n    best_tuple = None\n    for h in uniq:\n        y = w * h\n        tax = total_tax(y, K, t_rates)\n        c = b + y - tax\n        s = T - h\n        # Utility: c^alpha * s^(1-alpha); by convention, if c<=0 or s<=0, utility is 0\n        if c <= 0.0 or s <= 0.0:\n            U = 0.0\n        else:\n            U = (c ** alpha) * (s ** (1.0 - alpha))\n        # Select by utility, tie-break by smallest h\n        sel_key = (U, -h)  # since we want smallest h on tie, use -h with max\n        if (best is None) or (sel_key > best):\n            best = sel_key\n            best_tuple = (h, c, s, U)\n    # Round to six decimals\n    h_star, c_star, s_star, U_star = best_tuple\n    return [round(h_star, 6), round(c_star, 6), round(s_star, 6), round(U_star, 6)]\n\ndef solve():\n    test_cases = [\n        # Case 1\n        {\"T\": 16.0, \"w\": 25.0, \"b\": 10.0, \"alpha\": 0.4,\n         \"K\": [0.0, 200.0, 400.0, np.inf], \"t\": [0.0, 0.2, 0.35]},\n        # Case 2\n        {\"T\": 24.0, \"w\": 20.0, \"b\": 300.0, \"alpha\": 0.2,\n         \"K\": [0.0, 100.0, 200.0, np.inf], \"t\": [0.5, 0.7, 0.9]},\n        # Case 3\n        {\"T\": 8.0, \"w\": 30.0, \"b\": 0.0, \"alpha\": 0.5,\n         \"K\": [0.0, np.inf], \"t\": [0.25]},\n        # Case 4\n        {\"T\": 6.0, \"w\": 40.0, \"b\": 0.0, \"alpha\": 0.5,\n         \"K\": [0.0, 80.0, 120.0, np.inf], \"t\": [0.0, 0.5, 0.6]},\n        # Case 5\n        {\"T\": 12.0, \"w\": 15.0, \"b\": 0.0, \"alpha\": 0.9,\n         \"K\": [0.0, 60.0, 120.0, np.inf], \"t\": [0.1, 0.2, 0.4]},\n    ]\n    results = []\n    for case in test_cases:\n        results.append(evaluate_candidates(case))\n\n    # Format as a single-line list of lists with exactly six decimals\n    def fmt_num(x):\n        return f\"{x:.6f}\"\n\n    inner = []\n    for res in results:\n        inner.append(\"[\" + \",\" + \",\".join(fmt_num(v) for v in res)[1:] + \"]\" if False else \"[\" + \",\".join(fmt_num(v) for v in res) + \"]\")\n    output = \"[\" + \",\".join(inner) + \"]\"\n    print(output)\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "最后一个实践将我们带入金融与不确定性的领域。在许多现实应用中，预算约束必须考虑未来收入的波动。这个练习模拟了一个涉及波动性加密货币资产的现代金融场景，它将指导您如何基于“最坏情况”来定义一个稳健的预算约束，这是风险管理和金融合约中的一个关键原则。通过完成此练习，您将掌握在未来收入不确定时如何严谨地处理约束条件。",
            "id": "2378611",
            "problem": "一位消费者选择两种商品，其数量为非负，记为 $x_1$ 和 $x_2$，对应的法币价格分别为 $p_1$ 和 $p_2$。该消费者在时刻 $0$ 拥有法币财富 $w_0$，并将在时刻 $1$ 收到 $q$ 单位的加密货币。在时刻 $1$ 时，该加密货币的法币汇率是不确定的，但属于一个已知的闭区间 $[E_{\\min}, E_{\\max}]$，其中 $E_{\\min} \\ge 0$。该消费者在时刻 $1$ 之前不能出售该加密货币。\n\n在时刻 $0$，该消费者可以借入一笔金额为 $b$ 的法币，但受外生上限 $B_{\\max} \\ge 0$ 的限制，并必须在时刻 $1$ 偿还 $(1+r)b$，其中 $r \\ge 0$ 是利率。为偿还债务，该消费者可以在时刻 $1$ 观察到已实现的汇率 $E \\in [E_{\\min}, E_{\\max}]$ 后，出售任意数量 $z(E) \\in [0,q]$ 的加密货币。如果 $z(E) = 0$，则不支付任何交易费，法币收益为 $0$。如果 $z(E) &gt; 0$，交易所会征收一笔费率为 $f \\in [0,1)$ 的从价费和一笔固定费用 $k \\ge 0$，因此以汇率 $E$ 出售 $z(E)$ 单位加密货币的法币收益为 $(1-f) E \\, z(E) - k$。\n\n贷款方施加一个稳健的偿付能力要求：对于每一个 $E \\in [E_{\\min}, E_{\\max}]$，都必须存在一个选择 $z(E) \\in [0,q]$，使得在时刻 $1$ 的出售净收益至少为还款额 $(1+r)b$。形式上，对于所有 $E \\in [E_{\\min}, E_{\\max}]$，存在一个 $z(E) \\in [0,q]$ 满足\n$$(1-f) E \\, z(E) - k \\cdot \\mathbf{1}_{\\{z(E) > 0\\}} \\;\\ge\\; (1+r) b,$$\n其中 $\\mathbf{1}_{\\{\\cdot\\}}$ 是指示函数，当其参数为真时等于 $1$，否则等于 $0$。\n\n在时刻 $0$，消费者的预算集是所有满足\n$$p_1 x_1 + p_2 x_2 \\;\\le\\; w_0 + b,$$\n的 $(x_1,x_2)$ 的集合，其中 $x_1 \\ge 0$, $x_2 \\ge 0$，并且 $b \\in [0,B_{\\max}]$ 满足上述稳健偿付能力要求。\n\n任务。对于下面测试套件中的每个参数集，计算以下三个量：\n- 最大稳健可行借贷能力 $b_{\\max}$。\n- 最终预算线在 $x_2 = 0$ 时与 $x_1$ 轴的截距 $x_1^{\\max}$，即 $x_1^{\\max} = (w_0 + b_{\\max})/p_1$。\n- 最终预算线在 $x_1 = 0$ 时与 $x_2$ 轴的截距 $x_2^{\\max}$，即 $x_2^{\\max} = (w_0 + b_{\\max})/p_2$。\n\n将这三个量中的每一个都以小数形式报告，并四舍五入到小数点后六位。\n\n测试套件。每个案例都是一个元组 $(p_1,p_2,w_0,q,E_{\\min},E_{\\max},f,k,r,B_{\\max})$：\n- 案例 1：$(2.0,\\,3.0,\\,10.0,\\,5.0,\\,180.0,\\,220.0,\\,0.01,\\,5.0,\\,0.05,\\,1000.0)$。\n- 案例 2：$(1.5,\\,4.0,\\,20.0,\\,2.0,\\,5.555555555555556,\\,6.0,\\,0.1,\\,10.0,\\,0.1,\\,100.0)$。\n- 案例 3：$(5.0,\\,2.0,\\,0.0,\\,3.0,\\,100.0,\\,200.0,\\,0.0,\\,0.0,\\,0.2,\\,1000.0)$。\n- 案例 4：$(1.0,\\,1.0,\\,5.0,\\,10.0,\\,50.0,\\,60.0,\\,0.05,\\,0.0,\\,0.0,\\,100.0)$。\n- 案例 5：$(2.0,\\,2.0,\\,0.0,\\,1.0,\\,100.0,\\,150.0,\\,0.1,\\,5.0,\\,1.0,\\,1000.0)$。\n- 案例 6：$(3.0,\\,6.0,\\,7.0,\\,0.0,\\,100.0,\\,120.0,\\,0.2,\\,1.0,\\,0.3,\\,50.0)$。\n\n最终输出格式。你的程序应该生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表。对于每个案例 $i$，输出列表 $[b_{\\max,i},x_{1,i}^{\\max},x_{2,i}^{\\max}]$，其中每个数字都四舍五入到小数点后六位。将这六个案例级别的列表按上述顺序聚合到单个列表中，任何地方都不得有空格。例如，包含两个假设案例的输出将如下所示：$[[1.000000,2.000000,3.000000],[4.000000,5.000000,6.000000]]$。",
            "solution": "问题在于，在未来加密货币收入不确定但有界，且贷款方要求对于区间 $[E_{\\min}, E_{\\max}]$ 内的每一个汇率实现都必须满足稳健偿付能力的条件下，确定时刻 $0$ 的法币预算线。核心步骤依赖于稳健偿付能力约束下的可行性定义以及预算线的定义。\n\n首先，考虑稳健借贷约束。对于任何选定的贷款 $b \\in [0,B_{\\max}]$，偿付能力要求规定，对于每个 $E \\in [E_{\\min}, E_{\\max}]$，都存在一个出售数量 $z(E) \\in [0,q]$ 使得\n$$(1-f) E \\, z(E) - k \\cdot \\mathbf{1}_{\\{z(E) > 0\\}} \\;\\ge\\; (1+r) b.$$\n让我们分析，在已知 $E$ 实现后可以选择 $z(E)$ 的情况下，对于所有可能的 $E$，能够保证用于偿还的最大法币金额是多少。\n\n固定 $E \\in [E_{\\min}, E_{\\max}]$。出售 $z \\in [0,q]$ 单位时的收益函数为\n$$\\pi(E,z) \\;=\\; \\begin{cases}\n0, & z = 0,\\\\\n(1-f) E \\, z - k, & z \\in (0,q].\n\\end{cases}$$\n对于一个给定的 $E$，收益 $\\pi(E,z)$ 在 $(0,q]$ 上是关于 $z$ 的非递减函数，因为 $(1-f)E \\ge 0$。因此，在决定出售的前提下，在该汇率 $E$ 下的最大收益来自于出售全部持有量：\n$$\\max_{z \\in (0,q]} \\pi(E,z) \\;=\\; (1-f) E \\, q - k.$$\n然而，消费者也可以选择不出售，从而避免固定费用 $k$，获得收益 $0$。因此，在汇率 $E$ 下，通过该汇率下的最优出售决策可以保证的最大收益是\n$$\\Pi(E) \\;=\\; \\max\\!\\big(0,\\,(1-f) E \\, q - k\\big).$$\n\n贷款方要求还款额 $(1+r) b$ 不超过在任何 $E \\in [E_{\\min}, E_{\\max}]$ 下，根据该 $E$ 下的最优出售决策所能获得的收益。这导出了稳健界限\n$$(1+r) b \\;\\le\\; \\inf_{E \\in [E_{\\min}, E_{\\max}]} \\Pi(E).$$\n因为 $\\Pi(E)$ 是关于 $E$ 的非递减函数（因为 $(1-f) E \\, q - k$ 是非递减的，且与 $0$ 取最大值保持了单调性），所以在 $[E_{\\min}, E_{\\max}]$ 上的下确界在 $E_{\\min}$ 处取得：\n$$\\inf_{E \\in [E_{\\min}, E_{\\max}]} \\Pi(E) \\;=\\; \\max\\!\\big(0,\\,(1-f) E_{\\min} \\, q - k\\big).$$\n因此，与稳健偿付能力和外生上限相符的最大 $b$ 是\n$$b_{\\max} \\;=\\; \\min\\!\\left(B_{\\max},\\; \\frac{\\max\\!\\big(0,\\,(1-f) E_{\\min} \\, q - k\\big)}{1+r}\\right).$$\n\n接下来，时刻 $0$ 的预算集由标准线性支出约束\n$$p_1 x_1 + p_2 x_2 \\;\\le\\; w_0 + b,$$\n定义，其中 $b \\in [0,b_{\\max}]$ 且 $x_1 \\ge 0, x_2 \\ge 0$。预算集的外包络线是在 $b = b_{\\max}$ 时得到的预算线。通过将另一种商品的消费量设为零，我们得到该线与 $x_1$ 轴和 $x_2$ 轴的截距分别为\n$$x_1^{\\max} \\;=\\; \\frac{w_0 + b_{\\max}}{p_1}, \\qquad x_2^{\\max} \\;=\\; \\frac{w_0 + b_{\\max}}{p_2}.$$\n\n因此，每个案例的计算都从第一性原理出发，按以下步骤进行：\n1. 计算最坏情况下的保证收益 $\\max\\!\\big(0,\\,(1-f) E_{\\min} \\, q - k\\big)$。\n2. 将其除以 $(1+r)$ 得到还款所隐含的借贷上限，再与 $B_{\\max}$ 取最小值，从而得到 $b_{\\max}$。\n3. 计算 $x_1^{\\max} = (w_0 + b_{\\max})/p_1$ 和 $x_2^{\\max} = (w_0 + b_{\\max})/p_2$。\n\n将这些步骤应用于每个测试案例，并将所有报告的数字四舍五入到小数点后六位，即可得出规范所要求的输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport math\n\ndef robust_borrowing_capacity(p1, p2, w0, q, E_min, E_max, f, k, r, B_max):\n    \"\"\"\n    Compute b_max = min(B_max, max(0, (1-f)*E_min*q - k) / (1+r))\n    Then compute axis intercepts:\n      x1_max = (w0 + b_max)/p1\n      x2_max = (w0 + b_max)/p2\n    \"\"\"\n    # Worst-case guaranteed proceeds at E_min given optimal choice of z(E)\n    proceeds_low = (1.0 - f) * E_min * q - k\n    guaranteed = proceeds_low if proceeds_low > 0.0 else 0.0\n    denom = 1.0 + r\n    # Guard against any numerical issues (denom should be > 0 given r >= 0 in problem)\n    if denom <= 0.0:\n        # Fallback: if denom is zero or negative (not in provided tests), set borrowing bound to 0\n        b_bound = 0.0\n    else:\n        b_bound = guaranteed / denom\n    b_max = b_bound if b_bound <= B_max else B_max\n    # Axis intercepts\n    x1_max = (w0 + b_max) / p1\n    x2_max = (w0 + b_max) / p2\n    return b_max, x1_max, x2_max\n\ndef fmt6(x):\n    # Format with exactly 6 digits after the decimal, avoiding \"-0.000000\"\n    if abs(x) < 0.0000005:\n        x = 0.0\n    return f\"{x:.6f}\"\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each tuple: (p1, p2, w0, q, E_min, E_max, f, k, r, B_max)\n    test_cases = [\n        (2.0, 3.0, 10.0, 5.0, 180.0, 220.0, 0.01, 5.0, 0.05, 1000.0),            # Case 1\n        (1.5, 4.0, 20.0, 2.0, 5.555555555555556, 6.0, 0.1, 10.0, 0.1, 100.0),    # Case 2\n        (5.0, 2.0, 0.0, 3.0, 100.0, 200.0, 0.0, 0.0, 0.2, 1000.0),               # Case 3\n        (1.0, 1.0, 5.0, 10.0, 50.0, 60.0, 0.05, 0.0, 0.0, 100.0),                # Case 4\n        (2.0, 2.0, 0.0, 1.0, 100.0, 150.0, 0.1, 5.0, 1.0, 1000.0),               # Case 5\n        (3.0, 6.0, 7.0, 0.0, 100.0, 120.0, 0.2, 1.0, 0.3, 50.0),                 # Case 6\n    ]\n\n    results = []\n    for case in test_cases:\n        p1, p2, w0, q, E_min, E_max, f, k, r, B_max = case\n        b_max, x1_max, x2_max = robust_borrowing_capacity(p1, p2, w0, q, E_min, E_max, f, k, r, B_max)\n        results.append((b_max, x1_max, x2_max))\n\n    # Build output string with no spaces and six decimals per number\n    inner_lists = []\n    for b, x1, x2 in results:\n        inner = f\"[{fmt6(b)},{fmt6(x1)},{fmt6(x2)}]\"\n        inner_lists.append(inner)\n    output = f\"[{','.join(inner_lists)}]\"\n    # Final print statement in the exact required format.\n    print(output)\n\nsolve()\n```"
        }
    ]
}