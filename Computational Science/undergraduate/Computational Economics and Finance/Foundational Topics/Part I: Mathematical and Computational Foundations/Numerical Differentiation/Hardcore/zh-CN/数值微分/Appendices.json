{
    "hands_on_practices": [
        {
            "introduction": "在将数值微分应用于复杂的金融模型之前，我们必须首先掌握其基本工具。本练习通过计算一个已知函数的导数，直接比较了前向、后向和中心差分这三种基本方法的近似误差。通过这个实践，你将亲身体会到为什么中心差分公式因其更高的精度而成为许多实际应用中的首选方法。",
            "id": "2191753",
            "problem": "考虑函数 $f(x) = x \\exp(-x)$。我们希望近似其在点 $x_0 = 1$ 处的导数 $f'(x)$。近似的质量由其绝对误差来衡量，绝对误差定义为近似值与导数真值之间的绝对差。\n\n您需要比较三种常用的有限差分公式来近似导数：\n1.  **前向差分近似**：$D_f(x_0, h) = \\frac{f(x_0+h) - f(x_0)}{h}$\n2.  **后向差分近似**：$D_b(x_0, h) = \\frac{f(x_0) - f(x_0-h)}{h}$\n3.  **中心差分近似**：$D_c(x_0, h) = \\frac{f(x_0+h) - f(x_0-h)}{2h}$\n\n设当步长 $h = 0.1$ 时，$E_f$、$E_b$ 和 $E_c$ 分别是对应于前向、后向和中心差分近似的绝对误差。\n\n计算比值 $R = \\frac{E_f + E_b}{E_c}$ 的值。将您的最终答案四舍五入到三位有效数字。",
            "solution": "我们从函数 $f(x) = x \\exp(-x)$ 开始。其导数可以通过乘积法则求得：\n$$\nf'(x) = \\exp(-x) + x \\frac{d}{dx}\\big(\\exp(-x)\\big) = \\exp(-x) - x \\exp(-x) = \\exp(-x)\\,(1 - x).\n$$\n在 $x_{0} = 1$ 处，这给出\n$$\nf'(1) = \\exp(-1)\\,(1 - 1) = 0.\n$$\n因此，对于任何有限差分近似 $D$，在 $x_{0}=1$ 处的绝对误差就是该近似值的绝对值：\n$$\nE_{f} = |D_{f}(1,h)|,\\quad E_{b} = |D_{b}(1,h)|,\\quad E_{c} = |D_{c}(1,h)|.\n$$\n\n当 $h = 0.1$ 时，使用 $f(x) = x \\exp(-x)$ 计算三种有限差分：\n- 前向差分：\n$$\nD_{f}(1,h) = \\frac{f(1+h) - f(1)}{h} = \\frac{(1.1)\\exp(-1.1) - \\exp(-1)}{0.1}.\n$$\n- 后向差分：\n$$\nD_{b}(1,h) = \\frac{f(1) - f(1-h)}{h} = \\frac{\\exp(-1) - (0.9)\\exp(-0.9)}{0.1}.\n$$\n- 中心差分：\n$$\nD_{c}(1,h) = \\frac{f(1+h) - f(1-h)}{2h} = \\frac{(1.1)\\exp(-1.1) - (0.9)\\exp(-0.9)}{0.2}.\n$$\n\n通过将 $\\exp(-1.1)$ 写成 $\\exp(-1)\\exp(-0.1)$，并将 $\\exp(-0.9)$ 写成 $\\exp(-1)\\exp(0.1)$，可以提取公因数 $\\exp(-1)$。定义 $t = \\exp(0.1)$，因此 $\\exp(-0.1) = 1/t$。然后\n$$\nD_{f}(1,h) = \\frac{\\exp(-1)}{0.1}\\left(1.1\\,\\frac{1}{t} - 1 \\right),\\quad\nD_{b}(1,h) = \\frac{\\exp(-1)}{0.1}\\left(1 - 0.9\\,t \\right),\n$$\n$$\nD_{c}(1,h) = \\frac{\\exp(-1)}{0.2}\\left(1.1\\,\\frac{1}{t} - 0.9\\,t \\right).\n$$\n令\n$$\nA = 1.1\\,\\frac{1}{t} - 1,\\quad B = 1 - 0.9\\,t,\\quad C = 1.1\\,\\frac{1}{t} - 0.9\\,t.\n$$\n则\n$$\nE_{f} = \\frac{\\exp(-1)}{0.1}\\,|A|,\\quad E_{b} = \\frac{\\exp(-1)}{0.1}\\,|B|,\\quad E_{c} = \\frac{\\exp(-1)}{0.2}\\,|C|.\n$$\n因此，比值简化为\n$$\nR = \\frac{E_{f} + E_{b}}{E_{c}} = \\frac{\\frac{\\exp(-1)}{0.1}(|A|+|B|)}{\\frac{\\exp(-1)}{0.2}|C|} = 2\\,\\frac{|A|+|B|}{|C|}.\n$$\n\n数值上，当 $t = \\exp(0.1) \\approx 1.1051701859880927$ 且 $1/t = \\exp(-0.1) \\approx 0.9048374180359596$ 时，\n$$\nA = 1.1\\cdot 0.9048374180359596 - 1 \\approx -0.00467884016044447,\\quad |A| \\approx 0.00467884016044447,\n$$\n$$\nB = 1 - 0.9\\cdot 1.1051701859880927 \\approx 0.00534683261071661,\\quad |B| \\approx 0.00534683261071661,\n$$\n$$\nC = 1.1\\cdot 0.9048374180359596 - 0.9\\cdot 1.1051701859880927 \\approx 0.000667992450272143,\\quad |C| \\approx 0.000667992450272143.\n$$\n因此，\n$$\nR = 2\\,\\frac{0.00467884016044447 + 0.00534683261071661}{0.000667992450272143} \\approx \\frac{0.02005134554232216}{0.000667992450272143} \\approx 30.0173.\n$$\n四舍五入到三位有效数字，\n$$\nR \\approx 30.0.\n$$",
            "answer": "$$\\boxed{30.0}$$"
        },
        {
            "introduction": "选择了合适的差分公式（如中心差分）后，下一个关键问题是：如何选择步长 $h$？本练习将引导你探索数值微分中的一个核心权衡：截断误差与舍入误差之间的矛盾。通过经验性地寻找计算期权Vega（衡量期权价格对波动率敏感度的指标）的最佳步长 $h$，你将对这个在实践中至关重要的问题获得深刻理解。",
            "id": "2415200",
            "problem": "考虑一个在 Black–Scholes 框架下定价的无股息支付资产的欧式看涨期权。设即期价格为 $S_0$，执行价格为 $K$，连续复利无风险利率为 $r$，到期时间为 $T$，波动率为 $\\sigma$。Black–Scholes 看涨期权价格为\n$$\nC(S_0,K,r,T,\\sigma)=S_0\\,\\Phi(d_1)-K e^{-rT}\\,\\Phi(d_2),\n$$\n其中\n$$\nd_1=\\frac{\\ln\\!\\left(\\frac{S_0}{K}\\right)+\\left(r+\\frac{1}{2}\\sigma^2\\right)T}{\\sigma\\sqrt{T}},\\quad d_2=d_1-\\sigma\\sqrt{T},\n$$\n且 $\\Phi(\\cdot)$ 是标准正态分布的累积分布函数。该看涨期权的解析 Vega 是价格对 $\\sigma$ 的偏导数，由下式给出\n$$\n\\text{Vega}(S_0,K,r,T,\\sigma)=\\frac{\\partial C}{\\partial \\sigma}=S_0 \\sqrt{T}\\,\\varphi(d_1),\n$$\n其中 $\\varphi(\\cdot)$ 是标准正态概率密度函数。\n\n对于给定的参数向量 $(S_0,K,r,T,\\sigma)$，我们通过对称差商应用于波动率来定义 Vega 的数值估计量：\n$$\n\\widehat{\\text{Vega}}(h)=\\frac{C(S_0,K,r,T,\\sigma+h)-C(S_0,K,r,T,\\sigma-h)}{2h},\n$$\n对于步长 $h0$ 且满足 $\\sigma-h0$。对于一个给定的候选步长集合\n$$\n\\mathcal{H}=\\{10^{-12},10^{-11},10^{-10},10^{-9},10^{-8},10^{-7},10^{-6},10^{-5},10^{-4},10^{-3},10^{-2}\\},\n$$\n考虑其容许子集\n$$\n\\mathcal{H}_{\\text{adm}}=\\{h\\in\\mathcal{H}\\,:\\,0 h  \\sigma/2\\}.\n$$\n对于以下每个测试用例，找到 $\\mathcal{H}_{\\text{adm}}$ 中使 $\\widehat{\\text{Vega}}(h)$ 与解析 Vega 之间的绝对误差最小化的最优步长 $h^\\star \\in \\mathcal{H}_{\\text{adm}}$：\n- $(S_0,K,r,T,\\sigma)=(100,100,0.01,1,0.2)$\n- $(S_0,K,r,T,\\sigma)=(100,100,0.01,0.01,0.2)$\n- $(S_0,K,r,T,\\sigma)=(100,102,0.02,0.5,0.05)$\n- $(S_0,K,r,T,\\sigma)=(100,100,0.03,2,0.6)$\n\n如果多个步长得到相同的最小误差，则选择其中最大的一个。你的程序应生成一个单行输出，其中包含一个用方括号括起来的、逗号分隔的最优步长列表，顺序与测试用例的顺序相对应，格式为 `[h_1,h_2,h_3,h_4]`。",
            "solution": "问题陈述经过了严格验证，被认为是有效的。它在科学上基于 Black-Scholes 期权定价理论和数值分析原理。问题是适定的，具有所有必要的参数、公式以及清晰明确的目标。问题没有矛盾和主观论断。因此，将提供一个解决方案。\n\n任务是为期权 Vega 的数值估计找到最优步长 $h^\\star$。Vega 是期权价格相对于波动率 $\\sigma$ 的一阶偏导数。数值估计使用对称差商进行。最优步长 $h^\\star$ 定义为给定离散集合 $\\mathcal{H}_{\\text{adm}}$ 中使数值估计与 Vega 解析值之间绝对误差最小化的值。\n\n对于由参数集 $(S_0, K, r, T, \\sigma)$ 定义的每个测试用例，方法如下：\n\n1.  **解析 Vega 计算**：首先，使用提供的解析公式计算 Vega 的精确值：\n    $$ \\text{Vega}(S_0,K,r,T,\\sigma) = S_0 \\sqrt{T}\\,\\varphi(d_1) $$\n    其中 $\\varphi(\\cdot)$ 是标准正态分布的概率密度函数 (PDF)，$d_1$ 由下式给出：\n    $$ d_1=\\frac{\\ln(S_0/K)+\\left(r+\\frac{1}{2}\\sigma^2\\right)T}{\\sigma\\sqrt{T}} $$\n    该解析值作为比较数值估计的基准。\n\n2.  **数值估计和误差计算**：对于容许集合 $\\mathcal{H}_{\\text{adm}}$ 中的每个步长 $h$，我们使用对称差商计算 Vega 的数值近似值，记为 $\\widehat{\\text{Vega}}(h)$：\n    $$ \\widehat{\\text{Vega}}(h)=\\frac{C(S_0,K,r,T,\\sigma+h)-C(S_0,K,r,T,\\sigma-h)}{2h} $$\n    这里，$C(\\cdot)$ 是 Black-Scholes 看涨期权价格函数：\n    $$ C(S_0,K,r,T,\\sigma)=S_0\\,\\Phi(d_1)-K e^{-rT}\\,\\Phi(d_2) $$\n    其中 $\\Phi(\\cdot)$ 是标准正态分布的累积分布函数 (CDF)，且 $d_2 = d_1 - \\sigma\\sqrt{T}$。然后，计算每个 $h$ 的绝对误差：\n    $$ E(h)=\\left|\\widehat{\\text{Vega}}(h)-\\text{Vega}(S_0,K,r,T,\\sigma)\\right| $$\n\n3.  **最优步长选择**：候选步长集合由 $\\mathcal{H} = \\{10^{-12}, 10^{-11}, \\dots, 10^{-2}\\}$ 给出。容许集合 $\\mathcal{H}_{\\text{adm}}$ 定义为 $\\{h\\in\\mathcal{H}\\,:\\,0 h  \\sigma/2\\}$。对于每个测试用例，我们计算所有 $h \\in \\mathcal{H}_{\\text{adm}}$ 的 $E(h)$，并找到最小误差 $E_{\\min}$。最优步长 $h^\\star$ 随后被确定为 $\\{h \\in \\mathcal{H}_{\\text{adm}} \\,:\\, E(h) = E_{\\min}\\}$ 中的最大值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\n# from scipy import ...\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (100.0, 100.0, 0.01, 1.0, 0.2),\n        (100.0, 100.0, 0.01, 0.01, 0.2),\n        (100.0, 102.0, 0.02, 0.5, 0.05),\n        (100.0, 100.0, 0.03, 2.0, 0.6),\n    ]\n\n    # Candidate set of step sizes H\n    H = [10**-12, 10**-11, 10**-10, 10**-9, 10**-8, 10**-7,\n         10**-6, 10**-5, 10**-4, 10**-3, 10**-2]\n\n    # Function to calculate Black-Scholes call price\n    def black_scholes_call(S0, K, r, T, sigma):\n        # Handle edge cases for sigma and T to avoid mathematical errors\n        if sigma == 0 or T == 0:\n            # If T > 0 and sigma == 0, the option price is deterministic.\n            # If T = 0, the option price is its intrinsic value.\n            return max(0.0, S0 - K * np.exp(-r * T))\n            \n        d1 = (np.log(S0 / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n        d2 = d1 - sigma * np.sqrt(T)\n        price = S0 * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)\n        return price\n\n    # Function to calculate analytical Vega\n    def analytical_vega(S0, K, r, T, sigma):\n        # Vega is zero if T=0 or sigma=0\n        if sigma == 0 or T == 0:\n            return 0.0\n        d1 = (np.log(S0 / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n        vega = S0 * np.sqrt(T) * norm.pdf(d1)\n        return vega\n\n    optimal_h_results = []\n\n    for case in test_cases:\n        S0, K, r, T, sigma = case\n\n        # Determine the admissible set of step sizes.\n        # For all test cases provided, sigma/2 is greater than the largest h_cand in H,\n        # so the admissible set is the full set H.\n        H_adm = [h for h in H if 0  h  sigma / 2.0]\n\n        # Calculate the true analytical Vega to use as a benchmark\n        true_vega = analytical_vega(S0, K, r, T, sigma)\n\n        errors_with_h = []\n        for h in H_adm:\n            # Calculate numerical Vega using symmetric difference quotient\n            C_plus = black_scholes_call(S0, K, r, T, sigma + h)\n            C_minus = black_scholes_call(S0, K, r, T, sigma - h)\n            numerical_vega = (C_plus - C_minus) / (2.0 * h)\n            \n            # Calculate the absolute error\n            error = abs(numerical_vega - true_vega)\n            errors_with_h.append((error, h))\n\n        # Find the minimum error among all step sizes\n        min_error = min(e for e, h in errors_with_h)\n\n        # Find all step sizes that achieve this minimum error\n        minimizing_hs = [h for e, h in errors_with_h if e == min_error]\n\n        # Select the largest h among the minimizers as per the tie-breaking rule\n        optimal_h = max(minimizing_hs)\n        optimal_h_results.append(optimal_h)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, optimal_h_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "金融模型中经常出现并非处处光滑的函数，一个典型的例子是期权在到期日的收益函数。本练习探讨了数值微分方法在这些“拐点”或不可微点附近的行为。通过分析一个欧式看涨期权的收益函数，你将学习到在面对这类实际金融问题时，如何正确解读不同差分格式给出的结果及其局限性。",
            "id": "2415141",
            "problem": "考虑金融经济学中的分段线性收益函数，由欧式看涨期权在到期时的收益定义，其公式为 $f(x) = \\max(x - K, 0)$，其中 $x$ 表示标的价格，$K$ 是行权价。该函数处处连续，但在 $x = K$ 处不可微。取 $K = 100$。对于一个点 $x$ 和一个正步长 $h$，根据导数作为差商极限的第一性原理，定义以下三种有限差分商：左（后向）差分 $L(x;h) = \\dfrac{f(x) - f(x - h)}{h}$，对称（中心）差分 $D(x;h) = \\dfrac{f(x + h) - f(x - h)}{2h}$，以及右（前向）差分 $R(x;h) = \\dfrac{f(x + h) - f(x)}{h}$。你的任务是实现一个程序，使用指定的 $f(x)$ 和 $K$ 对下面的每个测试用例计算 $L(x;h)$、$D(x;h)$ 和 $R(x;h)$。\n\n使用以下包含数对 $(x,h)$ 的测试套件：\n- $(x,h) = (90.0, 0.1)$\n- $(x,h) = (110.0, 0.1)$\n- $(x,h) = (100.0, 0.1)$\n- $(x,h) = (99.99, 0.1)$\n- $(x,h) = (100.01, 0.1)$\n- $(x,h) = (100.0, 10^{-6})$\n- $(x,h) = (99.999999, 10^{-8})$\n- $(x,h) = (100.000001, 10^{-8})$\n\n对于每个测试用例，计算并记录三个浮点数 $L(x;h)$、$D(x;h)$ 和 $R(x;h)$。将报告的每个浮点数四舍五入到 $8$ 位小数。你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，该列表按给定顺序连接测试用例的三元组得到，即输出\n$[L(x_1;h_1), D(x_1;h_1), R(x_1;h_1), L(x_2;h_2), D(x_2;h_2), R(x_2;h_2), \\ldots, L(x_8;h_8), D(x_8;h_8), R(x_8;h_8)]$。\n\n最终输出必须是这种格式的单行文本。不涉及物理单位或角度；所有报告的量均为纯数。每个报告的单个值都必须是四舍五入到 $8$ 位小数的浮点数。",
            "solution": "问题陈述是有效的。它提出了一个根植于数值分析和金融数学基本原理的适定计算任务。该问题是自包含的、客观的且科学上合理的。我们将进行严谨的求解。\n\n问题要求对欧式看涨期权收益函数 $f(x)$ 进行三种有限差分商的求值，其定义为：\n$$f(x) = \\max(x - K, 0)$$\n其中 $x$ 是标的资产的价格，$K$ 是行权价。对于此问题，给定 $K = 100$。该函数对于所有 $x \\in \\mathbb{R}$ 都是连续的。然而，它在单点 $x = K$ 处不可微。其解析导数 $f'(x)$（在存在的地方）是一个阶跃函数：\n$$\nf'(x) = \n\\begin{cases} \n0  \\text{if } x  K \\\\\n1  \\text{if } x  K \n\\end{cases}\n$$\n在 $x=K$ 处，左导数为 $0$，右导数为 $1$。\n\n需要计算的三种有限差分格式是：\n1.  **左（后向）差分**：$L(x;h) = \\dfrac{f(x) - f(x - h)}{h}$\n2.  **对称（中心）差分**：$D(x;h) = \\dfrac{f(x + h) - f(x - h)}{2h}$\n3.  **右（前向）差分**：$R(x;h) = \\dfrac{f(x + h) - f(x)}{h}$\n\n现在我们将为 $8$ 个测试用例中的每一个计算三元组 $(L(x;h), D(x;h), R(x;h))$。分析按求值区间 $[x-h, x+h]$ 相对于拐点 $K=100$ 的位置进行组织。\n\n**情况组 1：求值区间完全位于拐点左侧 ($x+h \\le K$)**\n在这个区域，$f(x-h) = f(x) = f(x+h) = 0$。\n- **测试用例 1：$(x,h) = (90.0, 0.1)$**：此处，$x-h=89.9$，$x=90.0$，以及 $x+h=90.1$。所有点都小于 $100$。\n  $L = \\frac{0-0}{0.1} = 0$, $D = \\frac{0-0}{0.2} = 0$, $R = \\frac{0-0}{0.1} = 0$。\n  结果：$(0.0, 0.0, 0.0)$。\n- **测试用例 7：$(x,h) = (99.999999, 10^{-8})$**：此处，$x=100-10^{-6}$ 且 $h=10^{-8}$。\n  $x+h = 100 - 10^{-6} + 10^{-8} = 100 - 0.99 \\times 10^{-6}  100$。\n  所有求值点都小于或等于 $100$，其函数值为 $0$。\n  $L = \\frac{0-0}{10^{-8}} = 0$, $D = \\frac{0-0}{2 \\times 10^{-8}} = 0$, $R = \\frac{0-0}{10^{-8}} = 0$。\n  结果：$(0.0, 0.0, 0.0)$。\n\n**情况组 2：求值区间完全位于拐点右侧 ($x-h  K$)**\n在这个区域，$f(z) = z - K$，是一个斜率为 $1$ 的线性函数。有限差分公式应该能精确地恢复这个斜率。\n- **测试用例 2：$(x,h) = (110.0, 0.1)$**：此处，$x-h=109.9  100$。\n  $f(x)=10$, $f(x-h)=9.9$, $f(x+h)=10.1$。\n  $L = \\frac{10-9.9}{0.1} = 1$, $D = \\frac{10.1-9.9}{0.2} = 1$, $R = \\frac{10.1-10}{0.1} = 1$。\n  结果：$(1.0, 1.0, 1.0)$。\n- **测试用例 8：$(x,h) = (100.000001, 10^{-8})$**：此处，$x=100+10^{-6}$ 且 $h=10^{-8}$。\n  $x-h = 100 + 10^{-6} - 10^{-8} = 100 + 0.99 \\times 10^{-6}  100$。\n  函数为 $f(z) = z-100$。\n  $L = \\frac{f(x)-f(x-h)}{h} = \\frac{(x-100)-((x-h)-100)}{h} = \\frac{h}{h} = 1$。\n  $R = \\frac{f(x+h)-f(x)}{h} = \\frac{((x+h)-100)-(x-100)}{h} = \\frac{h}{h} = 1$。\n  $D = \\frac{f(x+h)-f(x-h)}{2h} = \\frac{((x+h)-100)-((x-h)-100)}{2h} = \\frac{2h}{2h} = 1$。\n  结果：$(1.0, 1.0, 1.0)$。\n\n**情况组 3：求值区间跨越拐点 ($x-h  K  x+h$)**\n这是最具启发性的情况，因为不可微性会影响近似值。\n- **测试用例 3：$(x,h) = (100.0, 0.1)$** 和 **测试用例 6：$(x,h) = (100.0, 10^{-6})$**：\n  此处，$x=K=100$。\n  $f(x) = f(100) = 0$。\n  $f(x-h) = f(100-h) = 0$ 因为 $100-h  100$。\n  $f(x+h) = f(100+h) = (100+h)-100 = h$ 因为 $100+h  100$。\n  $L = \\frac{0-0}{h} = 0$。这近似于左导数。\n  $R = \\frac{h-0}{h} = 1$。这近似于右导数。\n  $D = \\frac{h-0}{2h} = 0.5$。这是左右导数的平均值。\n  对于这两种情况，结果均为：$(0.0, 0.5, 1.0)$。\n\n- **测试用例 4：$(x,h) = (99.99, 0.1)$**：区间是 $[99.89, 100.09]$。\n  $x  K$，所以 $f(x)=0$。$x-h  K$，所以 $f(x-h)=0$。\n  $x+h = 100.09  K$，所以 $f(x+h) = 100.09 - 100 = 0.09$。\n  $L = \\frac{0-0}{0.1} = 0$。\n  $R = \\frac{0.09-0}{0.1} = 0.9$。\n  $D = \\frac{0.09-0}{2 \\times 0.1} = 0.45$。\n  结果：$(0.0, 0.45, 0.9)$。\n\n- **测试用例 5：$(x,h) = (100.01, 0.1)$**：区间是 $[99.91, 100.11]$。\n  $x-h = 99.91  K$，所以 $f(x-h)=0$。\n  $x = 100.01  K$，所以 $f(x)=100.01-100=0.01$。\n  $x+h = 100.11  K$，所以 $f(x+h)=100.11-100=0.11$。\n  $L = \\frac{0.01-0}{0.1} = 0.1$。\n  $R = \\frac{0.11-0.01}{0.1} = 1$。\n  $D = \\frac{0.11-0}{2 \\times 0.1} = 0.55$。\n  结果：$(0.1, 0.55, 1.0)$。\n\n**结果总结**\n在最终格式化之前，每个测试用例计算出的 $(L, D, R)$ 值为：\n1.  $(90.0, 0.1) \\rightarrow (0.0, 0.0, 0.0)$\n2.  $(110.0, 0.1) \\rightarrow (1.0, 1.0, 1.0)$\n3.  $(100.0, 0.1) \\rightarrow (0.0, 0.5, 1.0)$\n4.  $(99.99, 0.1) \\rightarrow (0.0, 0.45, 0.9)$\n5.  $(100.01, 0.1) \\rightarrow (0.1, 0.55, 1.0)$\n6.  $(100.0, 10^{-6}) \\rightarrow (0.0, 0.5, 1.0)$\n7.  $(99.999999, 10^{-8}) \\rightarrow (0.0, 0.0, 0.0)$\n8.  $(100.000001, 10^{-8}) \\rightarrow (1.0, 1.0, 1.0)$\n\n以下程序实现了这一逻辑，并按要求格式化输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Evaluates left, central, and right finite difference quotients for the\n    European call option payoff function f(x) = max(x - K, 0).\n    \"\"\"\n    # Define the strike price constant.\n    K = 100.0\n\n    def f(x_val):\n        \"\"\"\n        Calculates the European call option payoff.\n        Args:\n            x_val (float or np.ndarray): The underlying price(s).\n        Returns:\n            float or np.ndarray: The payoff(s).\n        \"\"\"\n        return np.maximum(x_val - K, 0)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (90.0, 0.1),\n        (110.0, 0.1),\n        (100.0, 0.1),\n        (99.99, 0.1),\n        (100.01, 0.1),\n        (100.0, 1e-6),\n        (99.999999, 1e-8),\n        (100.000001, 1e-8),\n    ]\n\n    results = []\n    for x, h in test_cases:\n        # Evaluate the function at the required points.\n        fx = f(x)\n        fx_minus_h = f(x - h)\n        fx_plus_h = f(x + h)\n\n        # Calculate the three finite difference quotients.\n        # L(x;h) = (f(x) - f(x - h)) / h\n        L = (fx - fx_minus_h) / h\n        \n        # D(x;h) = (f(x + h) - f(x - h)) / (2 * h)\n        D = (fx_plus_h - fx_minus_h) / (2 * h)\n        \n        # R(x;h) = (f(x + h) - f(x)) / h\n        R = (fx_plus_h - fx) / h\n\n        # Append the formatted results to the list.\n        # The problem requires rounding each float to 8 decimal places.\n        # Using f-string formatting for precise output.\n        results.append(f\"{L:.8f}\")\n        results.append(f\"{D:.8f}\")\n        results.append(f\"{R:.8f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}