{
    "hands_on_practices": [
        {
            "introduction": "理论学习之后，最好的巩固方式莫过于亲手实践。下面的练习将引导你将辛普森法则应用于经典的经济学和金融学问题。第一个练习将数值积分与微观经济学的核心概念——消费者剩余——直接联系起来。通过计算需求曲线下的面积，你将体会到如何使用辛普森法则来量化经济福利的变化，这是一个将抽象理论转化为具体数值的关键步骤 。",
            "id": "2430268",
            "problem": "一位区域规划师试图量化一条新高速公路所创造的每日消费者剩余。这条高速公路降低了出行者面临的广义出行价格（以美元/次出行计）。设 $Q(p)$ 表示作为广义价格 $p$（美元/次出行）的函数的出行需求。根据微观经济学定义，价格下降带来的消费者剩余是需求曲线下方，新旧价格之间的面积。从黎曼积分的定义出发，并基于当价格从 $p_0$ 降至 $p_1$（其中 $p_1 < p_0$）时消费者剩余的变化等于 $Q(p)$ 对 $p$ 的定积分这一事实，该收益可以写为 $Q(p)$ 在区间 $[p_1, p_0]$ 上的定积分。在不使用任何数值积分快捷公式的情况下，请实现具有偶数个子区间的复合辛普森法则，为几种经济上合理的需求设定近似计算此积分。\n\n您的任务是编写一个程序，该程序：\n- 对以下每个测试用例，使用具有偶数个子区间的复合辛普森法则来近似计算 $Q(p)$ 在 $[p_1,p_0]$ 上的积分。\n- 报告每种情况下产生的消费者剩余（以美元/天为单位），表示为一个四舍五入到 $6$ 位小数的浮点数。\n- 生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如，“[$x_1,x_2,x_3$]”）。\n\n假设需求设定和参数值如下（所有 $p$ 的单位为美元/次出行， $Q$ 的单位为次出行/天，结果必须以美元/天报告）：\n\n- 测试用例 $1$ （二次需求；一般“理想情况”）：\n  - $Q(p) = \\alpha - \\beta p - \\gamma p^2$\n  - $\\alpha = 120000$, $\\beta = 4000$, $\\gamma = 100$\n  - 初始广义价格 $p_0 = 12$，新广义价格 $p_1 = 9$\n  - 子区间数量 $n = 100$ （确保 $n$ 为偶数）\n\n- 测试用例 $2$ （指数需求；非线性曲率）：\n  - $Q(p) = A e^{-k p}$\n  - $A = 100000$, $k = 0.15$\n  - $p_0 = 12$, $p_1 = 8$\n  - $n = 200$\n\n- 测试用例 $3$ （逻辑斯蒂需求；饱和/市场规模上限）：\n  - $Q(p) = \\dfrac{N}{1 + e^{k(p - \\bar{p})}}$\n  - $N = 150000$, $k = 0.5$, $\\bar{p} = 10$\n  - $p_0 = 14$, $p_1 = 10$\n  - $n = 400$\n\n- 测试用例 $4$ （二次需求，价格变化极小；边界附近的数值稳定性）：\n  - $Q(p) = \\alpha - \\beta p - \\gamma p^2$\n  - $\\alpha = 80000$, $\\beta = 5000$, $\\gamma = 50$\n  - $p_0 = 10.00$, $p_1 = 9.99$\n  - $n = 10$\n\n要求：\n- 对每个测试，使用指定的 $n$ 在 $[p_1,p_0]$ 上通过复合辛普森法则实现积分近似。\n- 将每个最终数值答案以美元/天表示，四舍五入到 $6$ 位小数。\n- 您的程序应生成单行输出，其中包含一个按测试用例 $1$ 到 $4$ 顺序排列的、用方括号括起来的逗号分隔列表形式的结果（例如，“[$r_1,r_2,r_3,r_4$]”）。",
            "solution": "问题陈述已经过严格审查，并被确定为**有效**。它在科学上基于已确立的微观经济学原理和微积分，问题设定适定，提供了所有必要信息和一致的约束条件，并以客观、明确的语言进行了阐述。任务是使用指定的数值方法来近似一个代表消费者剩余的定积分，这是计算科学中的一个标准问题。\n\n核心原理是计算价格从初始价格 $p_0$ 下降到新的、更低的价格 $p_1$ 所导致的消费者剩余变化（$\\Delta CS$）。在微观经济学中，这被定义为需求曲线 $Q(p)$ 下方、这两个价格之间的面积。在数学上，这表示为需求函数在价格区间上的定积分：\n\n$$ \\Delta CS = \\int_{p_1}^{p_0} Q(p) \\, dp $$\n\n该问题要求使用复合辛普森法则来近似这个积分，而不借助预先存在的数值积分库函数。辛普森法则是一种数值方法，用于近似函数 $f(x)$ 在区间 $[a, b]$ 上的定积分。该法则的复合形式将区间 $[a, b]$ 分成偶数个（数量为 $n$）等宽（宽度为 $h$）的子区间。\n\n算法流程如下：\n1.  **定义积分参数**：对于每个测试用例，积分区间为 $[a, b] = [p_1, p_0]$。子区间的数量 $n$ 是给定的，并且是一个偶数。\n\n2.  **计算子区间宽度**：每个子区间的宽度 $h$ 计算如下：\n    $$ h = \\frac{b - a}{n} = \\frac{p_0 - p_1}{n} $$\n\n3.  **确定分割点**：区间 $[p_1, p_0]$ 被 $n+1$ 个点分割成 $n$ 个子区间。为避免与初始价格 $p_0$ 和 $p_1$ 混淆，将这些点表示为 $x_k$。\n    $$ x_k = p_1 + k \\cdot h, \\quad \\text{for } k = 0, 1, 2, \\ldots, n $$\n    注意 $x_0 = p_1$ 且 $x_n = p_0$。\n\n4.  **应用复合辛普森法则**：积分的复合辛普森法则近似值 $S_n$ 的公式为：\n    $$ S_n = \\frac{h}{3} \\left[ Q(x_0) + 4\\sum_{k=1}^{n/2} Q(x_{2k-1}) + 2\\sum_{k=1}^{n/2-1} Q(x_{2k}) + Q(x_n) \\right] $$\n    此公式通过对函数 $Q(p)$ 在分割点 $x_k$ 处的值根据其位置进行加权求和来构建近似值。端点（$x_0$ 和 $x_n$）的权重为 $1$。奇数索引的内部点（$x_1, x_3, \\ldots, x_{n-1}$）的权重为 $4$。偶数索引的内部点（$x_2, x_4, \\ldots, x_{n-2}$）的权重为 $2$。\n\n5.  **为每个测试用例实现**：将此数值积分程序应用于四个指定的测试用例中的每一个。\n\n    -   **测试用例 $1$**：\n        -   $Q(p) = \\alpha - \\beta p - \\gamma p^2$，其中 $\\alpha = 120000$, $\\beta = 4000$, $\\gamma = 100$。\n        -   在 $n = 100$ 个子区间上从 $p_1 = 9$ 积分到 $p_0 = 12$。\n        -   由于 $Q(p)$ 是一个次数为 $2$ 的多项式（小于 $4$），辛普森法则将提供积分的精确值。\n\n    -   **测试用例 $2$**：\n        -   $Q(p) = A e^{-k p}$，其中 $A = 100000$, $k = 0.15$。\n        -   在 $n = 200$ 个子区间上从 $p_1 = 8$ 积分到 $p_0 = 12$。\n\n    -   **测试用例 $3$**：\n        -   $Q(p) = \\dfrac{N}{1 + e^{k(p - \\bar{p})}}$，其中 $N = 150000$, $k = 0.5$, $\\bar{p} = 10$。\n        -   在 $n = 400$ 个子区间上从 $p_1 = 10$ 积分到 $p_0 = 14$。\n\n    -   **测试用例 $4$**：\n        -   $Q(p) = \\alpha - \\beta p - \\gamma p^2$，其中 $\\alpha = 80000$, $\\beta = 5000$, $\\gamma = 50$。\n        -   在 $n = 10$ 个子区间上从 $p_1 = 9.99$ 积分到 $p_0 = 10.00$。\n        -   与情况 $1$ 一样，结果将是解析精确的。\n\n每个案例的最终计算值四舍五入到 $6$ 位小数，以表示每日的消费者剩余（以美元计）。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the consumer surplus problem for four different demand specifications\n    using a from-scratch implementation of the composite Simpson's rule.\n    \"\"\"\n\n    def simpson_integrator(func, a, b, n):\n        \"\"\"\n        Approximates the definite integral of func from a to b by the\n        composite Simpson's rule, using n subintervals.\n\n        Args:\n            func (callable): The function to integrate.\n            a (float): The lower limit of integration.\n            b (float): The upper limit of integration.\n            n (int): The number of subintervals (must be even).\n\n        Returns:\n            float: The approximate value of the integral.\n        \"\"\"\n        if n % 2 != 0:\n            raise ValueError(\"Number of subintervals (n) must be even.\")\n\n        h = (b - a) / n\n        x_points = np.linspace(a, b, n + 1)\n        y_points = func(x_points)\n\n        # Simpson's rule: (h/3) * [y0 + 4y1 + 2y2 + 4y3 + ... + 4y_{n-1} + yn]\n        # This is implemented by summing endpoints, odd interior points, and even interior points.\n        integral = (h / 3) * (\n            y_points[0] + \n            y_points[-1] + \n            4 * np.sum(y_points[1:-1:2]) + \n            2 * np.sum(y_points[2:-1:2])\n        )\n        \n        return integral\n\n    # Define the demand functions for each test case\n    def q_case1(p):\n        alpha, beta, gamma = 120000, 4000, 100\n        return alpha - beta * p - gamma * p**2\n\n    def q_case2(p):\n        A, k = 100000, 0.15\n        return A * np.exp(-k * p)\n\n    def q_case3(p):\n        N, k, p_bar = 150000, 0.5, 10\n        return N / (1 + np.exp(k * (p - p_bar)))\n\n    def q_case4(p):\n        alpha, beta, gamma = 80000, 5000, 50\n        return alpha - beta * p - gamma * p**2\n\n    # Define the test cases from the problem statement\n    test_cases = [\n        {'func': q_case1, 'p1': 9, 'p0': 12, 'n': 100},\n        {'func': q_case2, 'p1': 8, 'p0': 12, 'n': 200},\n        {'func': q_case3, 'p1': 10, 'p0': 14, 'n': 400},\n        {'func': q_case4, 'p1': 9.99, 'p0': 10.00, 'n': 10},\n    ]\n\n    results = []\n    for case in test_cases:\n        # The integral for consumer surplus is from the new price (p1) to the old price (p0)\n        consumer_surplus = simpson_integrator(\n            case['func'], \n            case['p1'], \n            case['p0'], \n            case['n']\n        )\n        # Round the result to 6 decimal places and format as a string\n        results.append(f\"{consumer_surplus:.6f}\")\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "现实世界中的经济模型往往不是单一平滑的函数所能描述的。第二个练习引入了分段函数的挑战，这在模拟跨越不同阶段（例如，求学期间与毕业后）的金融决策中非常常见。你将通过计算攻读工商管理硕士（MBA）学位的净现值（$NPV$），学习如何处理被积函数在特定点的不连续性，这需要你将积分区间分割并在每个子区间上分别应用辛普森法则 。这项练习旨在培养你根据实际模型特征调整和应用数值方法的能力。",
            "id": "2430272",
            "problem": "您的任务是计算攻读工商管理硕士（MBA）项目所带来的增量收益的净现值，该问题被建模为一个连续时间现金流问题。净现值定义为：后MBA薪资路径与反事实的前MBA薪资路径之差，减去项目期间的学费支出，其差额的现值积分。所有时间以年为单位，所有货币价值以美元为单位。您必须使用复合辛普森法则（composite Simpson’s rule）进行数值积分。\n\n设前MBA薪资路径被建模为一个指数增长函数 $s_{\\text{pre}}(t) = A \\exp(g_{\\text{pre}} t)$，其中 $A$ 是时间 $t=0$ 时的初始薪资，$g_{\\text{pre}}$ 是前MBA薪资增长率。后MBA薪资路径是分段的：在长度为 $L$ 的项目期间，年收入可能是一个恒定值 $s_{\\text{prog}}$；在时间 $t=L$ 毕业后，薪资从水平 $B$ 开始，并以增长率 $g_{\\text{post}}$ 增长，即当 $t \\ge L$ 时，$s_{\\text{post}}(t) = B \\exp(g_{\\text{post}}(t - L))$。学费在项目期间 $[0,L)$ 内以恒定速率 $\\tau$ 作为连续流出支付，其他时间为零。连续复利贴现率为 $r \\ge 0$。\n\n将增量现金流定义为\n$$\n\\Delta(t) = s_{\\text{post}}(t) - s_{\\text{pre}}(t) - \\text{tuition}(t),\n$$\n其中\n$$\ns_{\\text{post}}(t) = \n\\begin{cases}\ns_{\\text{prog}}, & 0 \\le t < L \\\\\nB \\exp\\!\\big(g_{\\text{post}}(t - L)\\big), & t \\ge L\n\\end{cases},\n\\qquad\n\\text{tuition}(t) =\n\\begin{cases}\n\\tau, & 0 \\le t < L \\\\\n0, & t \\ge L\n\\end{cases},\n\\qquad\ns_{\\text{pre}}(t) = A \\exp(g_{\\text{pre}} t).\n$$\n时间范围 $[0,T]$ 内的净现值为\n$$\n\\text{NPV} = \\int_{0}^{T} e^{- r t}\\, \\Delta(t)\\, dt.\n$$\n\n实现一个程序，该程序：\n- 在每个平滑子区间上，使用偶数个子区间 $n$ 的复合辛普森法则来近似积分。为处理项目边界 $t=L$ 处的分段（piecewise）定义，需在 $t=L$ 处分割积分，并分别在 $[0,L]$ 和 $[L,T]$ 上应用辛普森法则（忽略任何零长度的段）。使用总共 $n_{\\text{total}}=4096$ 个子区间的基线，并为每个分段分配偶数个子区间，使得 $n_1 + n_2 = n_{\\text{total}}$，其中 $n_1$（用于 $[0,L]$）和 $n_2$（用于 $[L,T]$）均为偶数（必要时进行调整，以确保当分段长度为正时，两者都至少为 $2$）。\n- 对以下每个测试用例计算净现值，使用美元作为货币单位，年作为时间单位。最终结果以美元表示，四舍五入到两位小数。\n\n测试套件（参数以 $(A, g_{\\text{pre}}, L, B, g_{\\text{post}}, s_{\\text{prog}}, \\tau, r, T)$ 的形式给出）：\n- 用例 $1$（一般长时期）：$(\\$80{,}000,\\; 0.02,\\; 2,\\; \\$120{,}000,\\; 0.03,\\; \\$10{,}000,\\; \\$60{,}000,\\; 0.05,\\; 40)$。\n- 用例 $2$（边界情况，项目长度 $L=0$）：$(\\$85{,}000,\\; 0.02,\\; 0,\\; \\$110{,}000,\\; 0.025,\\; \\$0,\\; \\$0,\\; 0.05,\\; 35)$。\n- 用例 $3$（零贴现率 $r=0$）：$(\\$70{,}000,\\; 0.03,\\; 1.5,\\; \\$95{,}000,\\; 0.035,\\; \\$0,\\; \\$50{,}000,\\; 0,\\; 30)$。\n- 用例 $4$（时期等于项目长度 $T=L$）：$(\\$90{,}000,\\; 0.02,\\; 2,\\; \\$150{,}000,\\; 0.03,\\; \\$5{,}000,\\; \\$80{,}000,\\; 0.04,\\; 2)$。\n\n输出要求：\n- 您的程序应生成单行输出，其中包含按上述用例顺序排列的四个净现值，格式为方括号内的逗号分隔列表，例如 $[\\text{npv}_1,\\text{npv}_2,\\text{npv}_3,\\text{npv}_4]$。\n- 每个值必须以美元为单位，并四舍五入到两位小数。\n\n角度单位不适用。所有指数函数均使用自然指数。所有利率 $g_{\\text{pre}}$、$g_{\\text{post}}$ 和 $r$ 均为年利率（连续复利）。通过遵循在 $t=L$ 处的分割策略并在每个分段上使用偶数个子区间，确保科学真实性和数值稳定性。",
            "solution": "所提出的问题是计算金融领域一个有效的练习。它科学地基于净现值分析的原理，设定良好，包含所有必要的参数和明确的目标，其组成部分在数学和经济上都是合理的。我们将着手推导解决方案。\n\n目标是计算在时间范围 $[0, T]$ 内投资MBA项目所产生的增量现金流的净现值（${\\text{NPV}}$）。这需要使用复合辛普森法则对一个定积分进行数值评估。\n\n在时间 $t$ 的增量现金流，记为 $\\Delta(t)$，是后MBA薪资、前MBA薪资与学费成本之间的差额。这些函数定义如下：\n- 前MBA薪资：$s_{\\text{pre}}(t) = A \\exp(g_{\\text{pre}} t)$\n- 后MBA薪资：$s_{\\text{post}}(t) = \\begin{cases} s_{\\text{prog}}, & 0 \\le t < L \\\\ B \\exp(g_{\\text{post}}(t-L)), & t \\ge L \\end{cases}$\n- 学费：$\\text{tuition}(t) = \\begin{cases} \\tau, & 0 \\le t < L \\\\ 0, & t \\ge L \\end{cases}$\n\n净现值是在时间范围 $[0, T]$ 内贴现后增量现金流的积分：\n$$\n\\text{NPV} = \\int_{0}^{T} e^{-rt} \\Delta(t) \\,dt = \\int_{0}^{T} e^{-rt} [s_{\\text{post}}(t) - s_{\\text{pre}}(t) - \\text{tuition}(t)] \\,dt\n$$\n其中 $r$ 是连续复利贴现率。\n\n由于 $s_{\\text{post}}(t)$ 和 $\\text{tuition}(t)$ 的分段定义，被积函数在点 $t=L$ 处不连续，该点标志着MBA项目的结束。对积分的严格评估要求在这个不连续点处将其分割：\n$$\n\\text{NPV} = \\int_{0}^{L} e^{-rt} \\Delta(t) \\,dt + \\int_{L}^{T} e^{-rt} \\Delta(t) \\,dt\n$$\n将每个区间的相应定义代入，得到两个独立的积分：\n$$\n\\text{NPV} = \\int_{0}^{L} e^{-rt} (s_{\\text{prog}} - \\tau - A e^{g_{\\text{pre}}t}) \\,dt + \\int_{L}^{T} e^{-rt} (B e^{g_{\\text{post}}(t-L)} - A e^{g_{\\text{pre}}t}) \\,dt\n$$\n我们将第一个积分记为 $\\text{NPV}_1$，第二个记为 $\\text{NPV}_2$。$\\text{NPV} = \\text{NPV}_1 + \\text{NPV}_2$。这些积分将进行数值近似计算。\n\n指定的数值方法是复合辛普森法则。对于一个在划分为偶数个子区间 $n$ 的区间上的积分 $\\int_a^b f(x) \\,dx$，其近似值由下式给出：\n$$\n\\int_a^b f(x) \\,dx \\approx \\frac{h}{3} \\left[ f(x_0) + 4\\sum_{i=1}^{n/2} f(x_{2i-1}) + 2\\sum_{i=1}^{n/2-1} f(x_{2i}) + f(x_n) \\right]\n$$\n其中 $h = (b-a)/n$ 是步长，$x_i = a+ih$ 是求值点。此法则要求 $n$ 是一个偶数整数，且 $n \\ge 2$。\n\n问题要求使用总共 $n_{\\text{total}} = 4096$ 个子区间，分配到两个积分段 $[0, L]$ 和 $[L, T]$。设 $n_1$ 是第一个积分的子区间数，$n_2$ 是第二个积分的子区间数，使得 $n_1 + n_2 = n_{\\text{total}}$。$n_1$ 和 $n_2$ 都必须是偶数。一个合乎逻辑且系统的方法是按每个积分段的长度比例分配这些子区间。\n\n$n_1$ 和 $n_2$ 的分配算法如下：\n1. 处理边界情况：\n    - 如果 $L \\le 0$，则在 $[0, L]$ 上的第一个积分为零。我们设置 $n_1 = 0$ 和 $n_2 = n_{\\text{total}}$。积分仅在 $[0, T]$ 上执行。\n    - 如果 $T \\le L$，则在 $[L, T]$ 上的第二个积分为零。我们设置 $n_1 = n_{\\text{total}}$ 和 $n_2 = 0$。积分仅在 $[0, L]$ 上执行。\n2. 对于一般情况 $0  L  T$：\n    - 计算第一个区间的比例分配：$n_{1, \\text{prop}} = n_{\\text{total}} \\times \\frac{L}{T}$。\n    - 将此值四舍五入到最近的偶数整数。一个稳健的方法是 $n_1 = 2 \\times \\text{round}(n_{1, \\text{prop}}/2)$。\n    - 应用保障措施以确保 $n_1$ 和 $n_2$ 至少为 $2$（如果它们对应的区间长度为正）。如果计算得出 $n_1  2$，我们设置 $n_1=2$。如果得出 $n_1 > n_{\\text{total}}-2$，我们设置 $n_1 = n_{\\text{total}}-2$。\n    - 那么第二个区间的分配为 $n_2 = n_{\\text{total}} - n_1$。根据构造，如果 $n_{\\text{total}}$ 和 $n_1$ 是偶数，那么 $n_2$ 也将是偶数。\n\n实现将包括一个执行辛普森法则的函数和一个遍历所提供测试用例的主程序。对于每个用例，它将：\n- 根据具体参数定义两个被积函数。\n- 根据分配算法确定子区间计数 $n_1$ 和 $n_2$。\n- 为两个积分中的每一个调用辛普森法则函数（如果区间长度为正）。\n- 将结果相加得到总 $\\text{NPV}$。\n- 按要求将最终值四舍五入到两位小数。\n\n这种结构化方法确保了经济模型的分段特性被数值积分正确处理，从而提供了一个科学上合理且计算上稳健的解决方案。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the net present value of enrolling in an MBA program \n    for a series of test cases using the composite Simpson's rule.\n    \"\"\"\n\n    def simpson_rule(func, a, b, n):\n        \"\"\"\n        Approximates the definite integral of a function from a to b\n        using the composite Simpson's rule with n subintervals.\n\n        Args:\n            func (callable): The function to integrate.\n            a (float): The lower limit of integration.\n            b (float): The upper limit of integration.\n            n (int): The number of subintervals (must be even and positive).\n\n        Returns:\n            float: The approximate value of the integral.\n        \"\"\"\n        if n == 0 or a == b:\n            return 0.0\n        \n        if n  2 or n % 2 != 0:\n            raise ValueError(\"Number of subintervals (n) must be a positive even integer.\")\n\n        h = (b - a) / n\n        x = np.linspace(a, b, n + 1)\n        y = func(x)\n\n        # Simpson's rule formula\n        # S = y[0] + y[-1] + 4 * sum(odd indices) + 2 * sum(even indices)\n        integral = h / 3.0 * (y[0] + y[-1] + 4.0 * np.sum(y[1:-1:2]) + 2.0 * np.sum(y[2:-2:2]))\n        \n        return integral\n\n    # Define the test cases from the problem statement.\n    # Parameters: (A, g_pre, L, B, g_post, s_prog, tau, r, T)\n    test_cases = [\n        (80000, 0.02, 2, 120000, 0.03, 10000, 60000, 0.05, 40),\n        (85000, 0.02, 0, 110000, 0.025, 0, 0, 0.05, 35),\n        (70000, 0.03, 1.5, 95000, 0.035, 0, 50000, 0, 30),\n        (90000, 0.02, 2, 150000, 0.03, 5000, 80000, 0.04, 2),\n    ]\n\n    results = []\n    n_total = 4096\n\n    for case in test_cases:\n        A, g_pre, L, B, g_post, s_prog, tau, r, T = case\n\n        # Define the two integrands corresponding to the two time periods\n        \n        # Integrand for the period during the MBA program: [0, L]\n        # Delta(t) = s_prog - s_pre(t) - tuition(t)\n        integrand1 = lambda t: np.exp(-r * t) * (s_prog - tau - A * np.exp(g_pre * t))\n\n        # Integrand for the period after graduation: [L, T]\n        # Delta(t) = s_post(t) - s_pre(t)\n        integrand2 = lambda t: np.exp(-r * t) * (B * np.exp(g_post * (t - L)) - A * np.exp(g_pre * t))\n\n        # Allocate subintervals n1 and n2\n        n1, n2 = 0, 0\n        if L = 0:\n            # First interval has zero or negative length\n            n1 = 0\n            n2 = n_total\n            # Adjust integration range for the second part\n            L_eff = 0\n            T_eff = T\n        elif T = L:\n            # Second interval has zero or negative length\n            n1 = n_total\n            n2 = 0\n            L_eff = L\n            T_eff = L\n        else: # 0  L  T\n            # Proportional allocation\n            n1_prop = n_total * L / T\n            # Round to nearest even integer\n            n1 = int(round(n1_prop / 2.0) * 2)\n            \n            # Safeguard to ensure n1 and n2 are at least 2\n            if n1  2:\n                n1 = 2\n            if n_total - n1  2:\n                n1 = n_total - 2\n            \n            n2 = n_total - n1\n            L_eff = L\n            T_eff = T\n\n        # Calculate NPV for the first period [0, L]\n        npv1 = 0.0\n        if n1 > 0:\n            npv1 = simpson_rule(integrand1, 0, L_eff, n1)\n\n        # Calculate NPV for the second period [L, T]\n        # For L=0 case, this integral is over [0,T]\n        npv2 = 0.0\n        if n2 > 0:\n            npv2 = simpson_rule(integrand2, L_eff, T_eff, n2)\n\n        # Total NPV is the sum of the two parts\n        total_npv = npv1 + npv2\n        results.append(total_npv)\n\n    # Final print statement in the exact required format.\n    # Round to two decimal places for currency representation.\n    print(f\"[{','.join([f'{res:.2f}' for res in results])}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "掌握了基本应用和对复杂函数的处理后，是时候探索如何提升数值方法的精度了。最后一个练习将带你进入一个更高级的主题：在企业估值背景下使用理查森外推法（Richardson extrapolation）来优化辛普森法则的计算结果。辛普森法则的截断误差具有已知的结构，我们可以利用这一特性，通过组合不同步长下的计算结果来消除主误差项，从而获得更精确的估计值 。这个练习不仅让你应用辛普森法则解决复杂的金融估值问题，更让你一窥误差分析和加速收敛等高级数值分析技术。",
            "id": "2430246",
            "problem": "给定一个公司企业价值的连续时间贴现现金流模型。对于一个瞬时现金流为 $C(t)$、连续复利贴现率为 $r(t)$ 的现金流流，其在时间 $0$ 的现值定义为如下反常积分：$$\\mathrm{EV} \\;=\\; \\int_{0}^{\\infty} C(t)\\,\\exp\\!\\left(-\\int_{0}^{t} r(s)\\,ds\\right)\\,dt.$$ 在本任务中，假设以下结构成立：\n- 对于 $t \\in [0,\\tau]$，贴现率是常数 $r(t)=r_{1}$，被积函数为 $f(t)=C(t)\\,\\exp(-r_{1}t)$。\n- 对于 $t \\ge \\tau$，现金流以恒定增长率 $g_{\\infty}$ 增长，贴现率是常数 $r_{\\infty}$，且 $r_{\\infty}  g_{\\infty}$。那么，时间 $\\tau$ 之后的尾部现值是明确定义且有限的。\n\n你的目标是通过以下步骤计算企业价值的精确数值估计：\n1. 使用复合 Simpson 法，在具有 $N$ 个子区间（$N$ 为偶数）的均匀间隔网格上，以及在具有 $2N$ 个子区间的加密网格上，近似计算积分 $\\int_{0}^{\\tau} f(t)\\,dt$。\n2. 对两个 Simpson 近似值应用 Richardson 外推法，以消除主阶截断误差，从而获得 $\\int_{0}^{\\tau} f(t)\\,dt$ 的一个精化估计值。\n3. 加上一个在时间 $\\tau$ 解析计算的终值，该终值捕捉了在恒定增长和恒定贴现率假设下 $t \\ge \\tau$ 的贡献。如果 $C(\\tau)$ 表示前 $\\tau$ 时期模型在时间 $\\tau$ 的现金流水平，并且对于 $t \\in [0,\\tau]$ 有 $r(t)=r_{1}$，则尾部在时间 $t=0$ 的现值由下式给出：$$\\mathrm{TV} \\;=\\; \\exp(-r_{1}\\tau)\\,\\frac{C(\\tau)}{r_{\\infty}-g_{\\infty}}.$$\n4. 报告总估计值 $\\widehat{\\mathrm{EV}} = \\widehat{\\int_{0}^{\\tau} f(t)\\,dt} + \\mathrm{TV}$。\n\n实现一个完整、可运行的程序，对下述每个测试用例执行以上步骤。任何三角函数的角度必须以弧度为单位。所有输出必须以与 $C(t)$ 相同的货币单位表示，不带任何货币符号，并以十进制浮点数形式四舍五入到 $10$ 位小数。\n\n测试套件包含四个案例。在每个案例中，$t \\in [0,\\tau]$ 的现金流由下式指定：\n$$C(t) \\;=\\; A\\,\\exp(g_{1} t)\\,\\bigl(1 + \\alpha \\sin(\\omega t) + \\beta t\\bigr),$$\n其中参数可能为零以简化子案例。对于 $t \\ge \\tau$，使用指定的常数 $r_{\\infty}$ 和 $g_{\\infty}$ 计算终值。\n\n对每个测试用例使用以下参数集：\n- 案例1（通过 $\\tau=0$ 进行闭式解验证）：$A=50$, $g_{1}=0.02$, $\\alpha=0$, $\\omega=0$, $\\beta=0$, $r_{1}=0.07$, $\\tau=0$, $r_{\\infty}=0.07$, $g_{\\infty}=0.02$, $N=64$。模型所蕴含的精确值为 $A/(r_{\\infty}-g_{\\infty})$。\n- 案例2（早期周期性阶段，长期稳定）：$A=120$, $g_{1}=0.015$, $\\alpha=0.1$, $\\omega=0.8$, $\\beta=0$, $r_{1}=0.09$, $\\tau=8$, $r_{\\infty}=0.08$, $g_{\\infty}=0.02$, $N=128$。\n- 案例3（长期增长率与贴现率差距极小）：$A=80$, $g_{1}=0.03$, $\\alpha=0$, $\\omega=0$, $\\beta=0.05$, $r_{1}=0.05$, $\\tau=6$, $r_{\\infty}=0.04$, $g_{\\infty}=0.039$, $N=256$。\n- 案例4（早期高贴现率，长期适度增长）：$A=200$, $g_{1}=0$, $\\alpha=0$, $\\omega=0$, $\\beta=0.02$, $r_{1}=0.15$, $\\tau=4$, $r_{\\infty}=0.10$, $g_{\\infty}=0.01$, $N=128$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含四个案例的结果，格式为方括号内以逗号分隔的列表。列表必须与上述案例的顺序一致。每个数字必须精确到 $10$ 位小数。例如：$[\\text{result}_{1},\\text{result}_{2},\\text{result}_{3},\\text{result}_{4}]$。",
            "solution": "该问题要求基于一个连续时间贴现现金流模型计算公司的企业价值 $\\mathrm{EV}$。估值采用两阶段法：一个从时间 $t=0$ 到 $t=\\tau$ 的有限预测期，以及一个代表此后所有现金流的终值。\n\n企业价值由以下积分正式定义：\n$$ \\mathrm{EV} \\;=\\; \\int_{0}^{\\infty} C(t)\\,\\exp\\!\\left(-\\int_{0}^{t} r(s)\\,ds\\right)\\,dt $$\n其中 $C(t)$ 是时间 $t$ 的瞬时现金流，$r(t)$ 是连续复利贴现率。\n\n对于初始阶段 $t \\in [0, \\tau]$，贴现率是常数 $r(t)=r_{1}$。现金流函数由下式给出：\n$$ C(t) \\;=\\; A\\,\\exp(g_{1} t)\\,\\bigl(1 + \\alpha \\sin(\\omega t) + \\beta t\\bigr) $$\n这一时期的价值贡献是贴现现金流的积分，我们将其记为 $I_{\\tau}$：\n$$ I_{\\tau} = \\int_{0}^{\\tau} C(t) e^{-r_{1}t} dt = \\int_{0}^{\\tau} A\\,\\exp((g_{1}-r_{1})t)\\,\\bigl(1 + \\alpha \\sin(\\omega t) + \\beta t\\bigr) dt $$\n该积分通常没有简单的闭式解，必须进行数值近似。\n\n对于 $t \\ge \\tau$ 时期，假设现金流从其在时间 $\\tau$ 的水平开始以恒定速率 $g_{\\infty}$ 增长，并且贴现率是常数 $r_{\\infty}$，满足稳定性条件 $r_{\\infty}  g_{\\infty}$。这些永续现金流在时间 $\\tau$ 的价值由 Gordon 增长模型给出，即 $\\frac{C(\\tau)}{r_{\\infty}-g_{\\infty}}$。为了找到其在 $t=0$ 的现值，我们将此金额以因子 $\\exp(-r_{1}\\tau)$ 贴现回来。因此，终值 $\\mathrm{TV}$ 为：\n$$ \\mathrm{TV} \\;=\\; \\exp(-r_{1}\\tau)\\,\\frac{C(\\tau)}{r_{\\infty}-g_{\\infty}} $$\n总企业价值是这两个组成部分之和：$\\mathrm{EV} = I_{\\tau} + \\mathrm{TV}$。\n\n数值计算任务是获得 $I_{\\tau}$ 的高精度估计。指定的方法涉及复合 Simpson 法则和 Richardson 外推法。\n\n复合 Simpson 法则使用偶数个宽度为 $h = (b-a)/n$ 的子区间 $n$ 来近似积分 $\\int_{a}^{b} f(x)\\,dx$。其公式为：\n$$ S_{n} = \\frac{h}{3} \\left[ f(x_0) + 4\\sum_{i=1}^{n/2} f(x_{2i-1}) + 2\\sum_{i=1}^{n/2-1} f(x_{2i}) + f(x_n) \\right] $$\n其中 $x_i = a+ih$。此方法的局部截断误差为 $O(h^4)$ 阶。总误差可以表示为 $h$ 的幂次的渐近级数：\n$$ I_{\\tau} - S_{n} = K_{1}h^4 + K_{2}h^6 + \\dots $$\n其中 $h = \\tau/n$。\n\nRichardson 外推法是一种通过消除主误差项来提高数值估计准确性的技术。我们用两种不同数量的子区间（$N$ 和 $2N$）计算积分近似值，它们分别对应步长 $h = \\tau/N$ 和 $h/2$。设这些近似值为 $S_{N}$ 和 $S_{2N}$。我们有：\n$$ I_{\\tau} = S_{N} + K_{1}h^4 + O(h^6) $$\n$$ I_{\\tau} = S_{2N} + K_{1}(h/2)^4 + O(h^6) = S_{2N} + \\frac{1}{16}K_{1}h^4 + O(h^6) $$\n通过消去 $K_{1}h^4$ 项，可以解这个二元方程组求得 $I_{\\tau}$。将第二个方程乘以 $16$ 再减去第一个方程，得到：\n$$ 15 I_{\\tau} = 16 S_{2N} - S_{N} + O(h^6) $$\n因此，外推估计值 $\\widehat{I_{\\tau}}$ 为：\n$$ \\widehat{I_{\\tau}} = \\frac{16S_{2N} - S_{N}}{15} = S_{2N} + \\frac{S_{2N} - S_{N}}{15} $$\n这个精化估计的截断误差为 $O(h^6)$ 阶，相比原始 Simpson 法则近似值，其准确性有显著提高。\n\n每个测试用例的总体算法如下：\n1.  定义被积函数 $f(t) = C(t) e^{-r_{1}t}$。\n2.  对于给定的子区间数 $N$，在区间 $[0, \\tau]$ 上计算两个 Simpson 法则近似值：$S_{N}$（使用 $N$ 个子区间）和 $S_{2N}$（使用 $2N$ 个子区间）。如果 $\\tau=0$，则积分 $I_{\\tau}$ 精确为 $0$。\n3.  应用 Richardson 外推法得到精化的积分估计值 $\\widehat{I_{\\tau}} = (16S_{2N} - S_{N})/15$。\n4.  使用所提供的公式解析计算终值 $\\mathrm{TV}$。\n5.  将两个分量相加，得到总的企业价值估计值：$\\widehat{\\mathrm{EV}} = \\widehat{I_{\\tau}} + \\mathrm{TV}$。\n\n此过程应用于四个参数集中的每一个。对于案例1，其中 $\\tau=0$，积分部分 $I_{\\tau}$ 显然为零，企业价值完全由终值给出，即 $\\mathrm{EV} = \\mathrm{TV} = A/(r_{\\infty}-g_{\\infty})$，这可作为对终值计算的验证。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the enterprise value for four test cases using a two-stage DCF model.\n    The integral part is calculated using Simpson's rule with Richardson extrapolation.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: Closed-form validation via tau=0\n        dict(A=50, g1=0.02, alpha=0, omega=0, beta=0, r1=0.07, tau=0, r_inf=0.07, g_inf=0.02, N=64),\n        # Case 2: Cyclical early phase, stable long run\n        dict(A=120, g1=0.015, alpha=0.1, omega=0.8, beta=0, r1=0.09, tau=8, r_inf=0.08, g_inf=0.02, N=128),\n        # Case 3: Near-boundary long-run gap\n        dict(A=80, g1=0.03, alpha=0, omega=0, beta=0.05, r1=0.05, tau=6, r_inf=0.04, g_inf=0.039, N=256),\n        # Case 4: High discount early, modest long run\n        dict(A=200, g1=0, alpha=0, omega=0, beta=0.02, r1=0.15, tau=4, r_inf=0.10, g_inf=0.01, N=128),\n    ]\n\n    results = []\n\n    def integrand(t, A, g1, alpha, omega, beta, r1):\n        \"\"\"\n        Calculates the discounted cash flow f(t) = C(t) * exp(-r1*t) for t in [0, tau].\n        \"\"\"\n        # C(t) = A * exp(g1*t) * (1 + alpha*sin(omega*t) + beta*t)\n        # f(t) = C(t) * exp(-r1*t) = A * exp((g1-r1)*t) * (1 + alpha*sin(omega*t) + beta*t)\n        return A * np.exp((g1 - r1) * t) * (1 + alpha * np.sin(omega * t) + beta * t)\n\n    def simpson_rule(func, a, b, n, params):\n        \"\"\"\n        Composite Simpson's rule for numerical integration.\n        n must be an even integer.\n        \"\"\"\n        if n % 2 != 0:\n            raise ValueError(\"Number of subintervals (n) must be even.\")\n        if a == b:\n            return 0.0\n            \n        h = (b - a) / n\n        x = np.linspace(a, b, n + 1)\n        y = func(x, **params)\n        \n        integral = y[0] + y[-1]\n        integral += 4 * np.sum(y[1:-1:2]) # Odd indices\n        integral += 2 * np.sum(y[2:-2:2]) # Even indices\n        \n        return (h / 3) * integral\n\n    for case in test_cases:\n        p = case.copy() # Use a copy to avoid modifying the original dict\n        # Pop non-integrand parameters\n        tau = p.pop('tau')\n        r_inf = p.pop('r_inf')\n        g_inf = p.pop('g_inf')\n        N = p.pop('N')\n\n        # --- Step 1  2: Integral with Richardson Extrapolation ---\n        if tau == 0:\n            integral_estimate = 0.0\n        else:\n            # Simpson approximation with N subintervals\n            S_N = simpson_rule(integrand, 0, tau, N, p)\n            \n            # Simpson approximation with 2N subintervals\n            S_2N = simpson_rule(integrand, 0, tau, 2 * N, p)\n            \n            # Richardson extrapolation for O(h^4) method\n            integral_estimate = S_2N + (S_2N - S_N) / 15.0\n\n        # --- Step 3: Terminal Value ---\n        # Get full parameters back for C(tau) calculation\n        params_full = case\n        C_tau = params_full['A'] * np.exp(params_full['g1'] * tau) * \\\n                (1 + params_full['alpha'] * np.sin(params_full['omega'] * tau) + params_full['beta'] * tau)\n\n        TV = np.exp(-params_full['r1'] * tau) * C_tau / (r_inf - g_inf)\n\n        # --- Step 4: Total Enterprise Value ---\n        total_ev = integral_estimate + TV\n        results.append(f\"{total_ev:.10f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}