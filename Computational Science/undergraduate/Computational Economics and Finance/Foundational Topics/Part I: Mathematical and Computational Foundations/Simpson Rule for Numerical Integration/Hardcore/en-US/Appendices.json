{
    "hands_on_practices": [
        {
            "introduction": "Theoretical concepts come alive through practical application. A foundational concept in microeconomics, consumer surplus, is geometrically defined as the area under a demand curve. This exercise  provides a direct application of Simpson's rule to translate this abstract area into a concrete financial value. By working with various functional forms for demand, you will develop a fundamental skill in cost-benefit analysis and applied economics.",
            "id": "2430268",
            "problem": "A regional planner seeks to quantify the daily consumer surplus created by a new highway that reduces the generalized travel price (measured in dollars per trip) faced by travelers. Let $Q(p)$ denote the trip demand as a function of the generalized price $p$ (dollars per trip). The microeconomic definition of consumer surplus from a price decrease is the area under the demand curve between the new and old prices. Starting from the definition of the Riemann integral and the fact that consumer surplus change from $p_0$ to $p_1$ with $p_1 < p_0$ equals the definite integral of $Q(p)$ with respect to $p$, the benefit can be written as the definite integral of $Q(p)$ over the interval from $p_1$ to $p_0$. Without using any shortcut formulas for numerical integration, implement the composite Simpson's rule with an even number of subintervals to approximate this integral for several economically plausible demand specifications.\n\nYour task is to write a program that:\n- Uses the composite Simpson's rule with an even number of subintervals to approximate the integral of $Q(p)$ over $[p_1,p_0]$ for each test case below.\n- Reports the resulting consumer surplus in dollars per day for each case, expressed as a floating-point number rounded to $6$ decimal places.\n- Produces a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[$x_1,x_2,x_3$]\").\n\nAssume the following demand specifications and parameter values (all $p$ are in dollars per trip, $Q$ is in trips per day, and results must be reported in dollars per day):\n\n- Test case $1$ (quadratic demand; general \"happy path\"):\n  - $Q(p) = \\alpha - \\beta p - \\gamma p^2$\n  - $\\alpha = 120000$, $\\beta = 4000$, $\\gamma = 100$\n  - Initial generalized price $p_0 = 12$, new generalized price $p_1 = 9$\n  - Number of subintervals $n = 100$ (ensure $n$ is even)\n\n- Test case $2$ (exponential demand; nonlinear curvature):\n  - $Q(p) = A e^{-k p}$\n  - $A = 100000$, $k = 0.15$\n  - $p_0 = 12$, $p_1 = 8$\n  - $n = 200$\n\n- Test case $3$ (logistic demand; saturation/market-size bound):\n  - $Q(p) = \\dfrac{N}{1 + e^{k(p - \\bar{p})}}$\n  - $N = 150000$, $k = 0.5$, $\\bar{p} = 10$\n  - $p_0 = 14$, $p_1 = 10$\n  - $n = 400$\n\n- Test case $4$ (quadratic demand with a very small price change; numerical stability near a boundary):\n  - $Q(p) = \\alpha - \\beta p - \\gamma p^2$\n  - $\\alpha = 80000$, $\\beta = 5000$, $\\gamma = 50$\n  - $p_0 = 10.00$, $p_1 = 9.99$\n  - $n = 10$\n\nRequirements:\n- Implement the integral approximation using the composite Simpson's rule over $[p_1,p_0]$ with the specified $n$ for each test.\n- Express each final numeric answer in dollars per day, rounded to $6$ decimal places.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test cases $1$ through $4$ (e.g., \"[$r_1,r_2,r_3,r_4$]\").",
            "solution": "The problem statement has been critically examined and is determined to be **valid**. It is scientifically grounded in established microeconomic principles and calculus, well-posed with all necessary information and consistent constraints, and articulated with objective, unambiguous language. The task is to approximate a definite integral representing consumer surplus using a specified numerical method, which is a standard problem in computational science.\n\nThe core principle is the calculation of the change in consumer surplus ($\\Delta CS$) resulting from a price decrease from an initial price $p_0$ to a new, lower price $p_1$. In microeconomics, this is defined as the area under the demand curve, $Q(p)$, between these two prices. Mathematically, this is expressed as the definite integral of the demand function over the price interval:\n\n$$ \\Delta CS = \\int_{p_1}^{p_0} Q(p) \\, dp $$\n\nThe problem requires the approximation of this integral using the composite Simpson's rule, without recourse to pre-existing library functions for numerical integration. Simpson's rule is a numerical method for approximating the definite integral of a function $f(x)$ over an interval $[a, b]$. The composite version of the rule divides the interval $[a, b]$ into an even number of subintervals, $n$, of equal width, $h$.\n\nThe algorithm proceeds as follows:\n1.  **Define Integration Parameters**: For each test case, the interval of integration is $[a, b] = [p_1, p_0]$. The number of subintervals, $n$, is given and is an even integer.\n\n2.  **Calculate Subinterval Width**: The width, $h$, of each subinterval is calculated as:\n    $$ h = \\frac{b - a}{n} = \\frac{p_0 - p_1}{n} $$\n\n3.  **Establish Partition Points**: The interval $[p_1, p_0]$ is partitioned into $n$ subintervals by $n+1$ points. Let these points be denoted by $x_k$ to avoid confusion with the initial prices $p_0$ and $p_1$.\n    $$ x_k = p_1 + k \\cdot h, \\quad \\text{for } k = 0, 1, 2, \\ldots, n $$\n    Note that $x_0 = p_1$ and $x_n = p_0$.\n\n4.  **Apply Composite Simpson's Rule**: The formula for the composite Simpson's rule approximation, $S_n$, of the integral is:\n    $$ S_n = \\frac{h}{3} \\left[ Q(x_0) + 4\\sum_{k=1}^{n/2} Q(x_{2k-1}) + 2\\sum_{k=1}^{n/2-1} Q(x_{2k}) + Q(x_n) \\right] $$\n    This formula constructs the approximation by summing the values of the function $Q(p)$ at the partition points $x_k$, weighted according to their position. The endpoints ($x_0$ and $x_n$) have a weight of $1$. The interior points with odd indices ($x_1, x_3, \\ldots, x_{n-1}$) have a weight of $4$. The interior points with even indices ($x_2, x_4, \\ldots, x_{n-2}$) have a weight of $2$.\n\n5.  **Implementation for each Test Case**: This numerical integration procedure is applied to each of the four specified test cases.\n\n    -   **Test Case $1$**:\n        -   $Q(p) = \\alpha - \\beta p - \\gamma p^2$ with $\\alpha = 120000$, $\\beta = 4000$, $\\gamma = 100$.\n        -   Integration from $p_1 = 9$ to $p_0 = 12$ with $n = 100$ subintervals.\n        -   Since $Q(p)$ is a polynomial of degree $2$, which is less than $4$, Simpson's rule will provide the exact value of the integral.\n\n    -   **Test Case $2$**:\n        -   $Q(p) = A e^{-k p}$ with $A = 100000$, $k = 0.15$.\n        -   Integration from $p_1 = 8$ to $p_0 = 12$ with $n = 200$ subintervals.\n\n    -   **Test Case $3$**:\n        -   $Q(p) = \\dfrac{N}{1 + e^{k(p - \\bar{p})}}$ with $N = 150000$, $k = 0.5$, $\\bar{p} = 10$.\n        -   Integration from $p_1 = 10$ to $p_0 = 14$ with $n = 400$ subintervals.\n\n    -   **Test Case $4$**:\n        -   $Q(p) = \\alpha - \\beta p - \\gamma p^2$ with $\\alpha = 80000$, $\\beta = 5000$, $\\gamma = 50$.\n        -   Integration from $p_1 = 9.99$ to $p_0 = 10.00$ with $n = 10$ subintervals.\n        -   As in case $1$, the result will be analytically exact.\n\nThe final computed value for each case is rounded to $6$ decimal places to represent the consumer surplus in dollars per day.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the consumer surplus problem for four different demand specifications\n    using a from-scratch implementation of the composite Simpson's rule.\n    \"\"\"\n\n    def simpson_integrator(func, a, b, n):\n        \"\"\"\n        Approximates the definite integral of func from a to b by the\n        composite Simpson's rule, using n subintervals.\n\n        Args:\n            func (callable): The function to integrate.\n            a (float): The lower limit of integration.\n            b (float): The upper limit of integration.\n            n (int): The number of subintervals (must be even).\n\n        Returns:\n            float: The approximate value of the integral.\n        \"\"\"\n        if n % 2 != 0:\n            raise ValueError(\"Number of subintervals (n) must be even.\")\n\n        h = (b - a) / n\n        x_points = np.linspace(a, b, n + 1)\n        y_points = func(x_points)\n\n        # Simpson's rule: (h/3) * [y0 + 4y1 + 2y2 + 4y3 + ... + 4y_{n-1} + yn]\n        # This is implemented by summing endpoints, odd interior points, and even interior points.\n        integral = (h / 3) * (\n            y_points[0] + \n            y_points[-1] + \n            4 * np.sum(y_points[1:-1:2]) + \n            2 * np.sum(y_points[2:-1:2])\n        )\n        \n        return integral\n\n    # Define the demand functions for each test case\n    def q_case1(p):\n        alpha, beta, gamma = 120000, 4000, 100\n        return alpha - beta * p - gamma * p**2\n\n    def q_case2(p):\n        A, k = 100000, 0.15\n        return A * np.exp(-k * p)\n\n    def q_case3(p):\n        N, k, p_bar = 150000, 0.5, 10\n        return N / (1 + np.exp(k * (p - p_bar)))\n\n    def q_case4(p):\n        alpha, beta, gamma = 80000, 5000, 50\n        return alpha - beta * p - gamma * p**2\n\n    # Define the test cases from the problem statement\n    test_cases = [\n        {'func': q_case1, 'p1': 9, 'p0': 12, 'n': 100},\n        {'func': q_case2, 'p1': 8, 'p0': 12, 'n': 200},\n        {'func': q_case3, 'p1': 10, 'p0': 14, 'n': 400},\n        {'func': q_case4, 'p1': 9.99, 'p0': 10.00, 'n': 10},\n    ]\n\n    results = []\n    for case in test_cases:\n        # The integral for consumer surplus is from the new price (p1) to the old price (p0)\n        consumer_surplus = simpson_integrator(\n            case['func'], \n            case['p1'], \n            case['p0'], \n            case['n']\n        )\n        # Round the result to 6 decimal places and format as a string\n        results.append(f\"{consumer_surplus:.6f}\")\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Real-world financial models are rarely described by a single, simple function. Cash flow streams often change their mathematical form at different points in time, such as the change in earnings before, during, and after obtaining a degree. This exercise  introduces this common complexity by requiring you to calculate the Net Present Value ($NPV$) of an MBA. To do this, you must adapt Simpson's rule to handle a piecewise-defined cash flow function by splitting the integral, a crucial technique for accurate valuation in practice.",
            "id": "2430272",
            "problem": "You are tasked with computing the net present value of the incremental earnings from enrolling in a Master of Business Administration (MBA) program, modeled as a continuous-time cash-flow problem. The net present value is defined as the present value integral of the difference between a post-MBA salary path and a counterfactual pre-MBA salary path, minus tuition payments during the program. All time is measured in years, and all currency values are in dollars. You must use the composite Simpson’s rule for numerical integration.\n\nLet the pre-MBA salary path be modeled as an exponentially growing function $s_{\\text{pre}}(t) = A \\exp(g_{\\text{pre}} t)$, where $A$ is the initial salary at time $t=0$ and $g_{\\text{pre}}$ is the pre-MBA salary growth rate. The post-MBA salary path is piecewise: during the program of length $L$, earnings may be a constant amount $s_{\\text{prog}}$ per year; after graduation at time $t=L$, the salary starts at level $B$ and grows at rate $g_{\\text{post}}$ as $s_{\\text{post}}(t) = B \\exp(g_{\\text{post}}(t - L))$ for $t \\ge L$. Tuition is paid as a continuous outflow at constant rate $\\tau$ during the program period $[0,L)$ and is zero otherwise. The continuously compounded discount rate is $r \\ge 0$.\n\nDefine the incremental cash flow as\n$$\n\\Delta(t) = s_{\\text{post}}(t) - s_{\\text{pre}}(t) - \\text{tuition}(t),\n$$\nwhere\n$$\ns_{\\text{post}}(t) = \n\\begin{cases}\ns_{\\text{prog}}, & 0 \\le t < L,\\\\\nB \\exp\\!\\big(g_{\\text{post}}(t - L)\\big), & t \\ge L,\n\\end{cases}\n\\qquad\n\\text{tuition}(t) =\n\\begin{cases}\n\\tau, & 0 \\le t < L,\\\\\n0, & t \\ge L,\n\\end{cases}\n\\qquad\ns_{\\text{pre}}(t) = A \\exp(g_{\\text{pre}} t).\n$$\nThe net present value over horizon $[0,T]$ is\n$$\n\\text{NPV} = \\int_{0}^{T} e^{- r t}\\, \\Delta(t)\\, dt.\n$$\n\nImplement a program that:\n- Approximates the integral using the composite Simpson’s rule with an even number of subintervals $n$ on each smooth subinterval. To handle the piecewise definition at the program boundary $t=L$, split the integral at $t=L$ and apply Simpson’s rule separately on $[0,L]$ and $[L,T]$ (ignoring any zero-length segment). Use a total baseline of $n_{\\text{total}}=4096$ subintervals, and allocate an even number of subintervals to each segment so that $n_1 + n_2 = n_{\\text{total}}$ with $n_1$ even for $[0,L]$ and $n_2$ even for $[L,T]$ (adjust as needed to ensure both are at least $2$ when their segment length is positive).\n- Computes the net present value for each of the following test cases, using dollars as the currency unit and years as the time unit. Express the final results in dollars, rounded to two decimals.\n\nTest suite (parameters given as $(A, g_{\\text{pre}}, L, B, g_{\\text{post}}, s_{\\text{prog}}, \\tau, r, T)$):\n- Case $1$ (general long horizon): $(\\$80{,}000,\\; 0.02,\\; 2,\\; \\$120{,}000,\\; 0.03,\\; \\$10{,}000,\\; \\$60{,}000,\\; 0.05,\\; 40)$.\n- Case $2$ (boundary with zero program length $L=0$): $(\\$85{,}000,\\; 0.02,\\; 0,\\; \\$110{,}000,\\; 0.025,\\; \\$0,\\; \\$0,\\; 0.05,\\; 35)$.\n- Case $3$ (zero discount rate $r=0$): $(\\$70{,}000,\\; 0.03,\\; 1.5,\\; \\$95{,}000,\\; 0.035,\\; \\$0,\\; \\$50{,}000,\\; 0,\\; 30)$.\n- Case $4$ (horizon equals program length $T=L$): $(\\$90{,}000,\\; 0.02,\\; 2,\\; \\$150{,}000,\\; 0.03,\\; \\$5{,}000,\\; \\$80{,}000,\\; 0.04,\\; 2)$.\n\nOutput requirements:\n- Your program should produce a single line of output containing the four net present values in order of the cases above, as a comma-separated list enclosed in square brackets, for example, $[\\text{npv}_1,\\text{npv}_2,\\text{npv}_3,\\text{npv}_4]$.\n- Each value must be in dollars, rounded to two decimals.\n\nAngle units do not apply. All exponential functions use the natural exponential. All rates $g_{\\text{pre}}$, $g_{\\text{post}}$, and $r$ are per year (continuous compounding). Ensure scientific realism and numerical stability by adhering to the splitting strategy at $t=L$ and using an even number of subintervals on each segment.",
            "solution": "The problem presented is a valid exercise in computational finance. It is scientifically grounded in the principles of net present value analysis, well-posed with all necessary parameters and a clear objective, and its components are mathematically and economically sound. We shall proceed with the derivation of the solution.\n\nThe objective is to compute the Net Present Value (${\\text{NPV}}$) of the incremental cash flow resulting from an investment in an MBA program over a time horizon $[0, T]$. This requires the numerical evaluation of a definite integral using the composite Simpson's rule.\n\nThe incremental cash flow at time $t$, denoted $\\Delta(t)$, is the difference between the post-MBA salary, the pre-MBA salary, and tuition costs. The functions are defined as:\n- Pre-MBA Salary: $s_{\\text{pre}}(t) = A \\exp(g_{\\text{pre}} t)$\n- Post-MBA Salary: $s_{\\text{post}}(t) = \\begin{cases} s_{\\text{prog}}, & 0 \\le t < L \\\\ B \\exp(g_{\\text{post}}(t-L)), & t \\ge L \\end{cases}$\n- Tuition: $\\text{tuition}(t) = \\begin{cases} \\tau, & 0 \\le t < L \\\\ 0, & t \\ge L \\end{cases}$\n\nThe Net Present Value is the integral of the discounted incremental cash flow over the horizon $[0, T]$:\n$$\n\\text{NPV} = \\int_{0}^{T} e^{-rt} \\Delta(t) \\,dt = \\int_{0}^{T} e^{-rt} [s_{\\text{post}}(t) - s_{\\text{pre}}(t) - \\text{tuition}(t)] \\,dt\n$$\nwhere $r$ is the continuously compounded discount rate.\n\nDue to the piecewise definition of $s_{\\text{post}}(t)$ and $\\text{tuition}(t)$, the integrand is discontinuous at the point $t=L$, which marks the end of the MBA program. A rigorous evaluation of the integral requires splitting it at this point of discontinuity:\n$$\n\\text{NPV} = \\int_{0}^{L} e^{-rt} \\Delta(t) \\,dt + \\int_{L}^{T} e^{-rt} \\Delta(t) \\,dt\n$$\nSubstituting the appropriate definitions for each interval yields two separate integrals:\n$$\n\\text{NPV} = \\int_{0}^{L} e^{-rt} (s_{\\text{prog}} - \\tau - A e^{g_{\\text{pre}}t}) \\,dt + \\int_{L}^{T} e^{-rt} (B e^{g_{\\text{post}}(t-L)} - A e^{g_{\\text{pre}}t}) \\,dt\n$$\nWe denote the first integral as $\\text{NPV}_1$ and the second as $\\text{NPV}_2$. $\\text{NPV} = \\text{NPV}_1 + \\text{NPV}_2$. These integrals are to be approximated numerically.\n\nThe specified numerical method is the composite Simpson's rule. For an integral $\\int_a^b f(x) \\,dx$ over an interval divided into an even number of subintervals $n$, the approximation is given by:\n$$\n\\int_a^b f(x) \\,dx \\approx \\frac{h}{3} \\left[ f(x_0) + 4\\sum_{i=1}^{n/2} f(x_{2i-1}) + 2\\sum_{i=1}^{n/2-1} f(x_{2i}) + f(x_n) \\right]\n$$\nwhere $h = (b-a)/n$ is the step size and $x_i = a+ih$ are the evaluation points. This rule requires $n$ to be an even integer, $n \\ge 2$.\n\nThe problem mandates that a total of $n_{\\text{total}} = 4096$ subintervals be used, distributed between the two integration segments $[0, L]$ and $[L, T]$. Let $n_1$ be the number of subintervals for the first integral and $n_2$ for the second, such that $n_1 + n_2 = n_{\\text{total}}$. Both $n_1$ and $n_2$ must be even. A logical and systematic approach is to allocate these subintervals proportionally to the length of each integration segment.\n\nThe allocation algorithm for $n_1$ and $n_2$ is as follows:\n$1$. Handle boundary cases:\n    - If $L \\le 0$, the first integral over $[0, L]$ is zero. We set $n_1 = 0$ and $n_2 = n_{\\text{total}}$. The integration is performed only over $[0, T]$.\n    - If $T \\le L$, the second integral over $[L, T]$ is zero. We set $n_1 = n_{\\text{total}}$ and $n_2 = 0$. The integration is performed only over $[0, L]$.\n$2$. For the general case $0 < L < T$:\n    - Calculate the proportional allocation for the first interval: $n_{1, \\text{prop}} = n_{\\text{total}} \\times \\frac{L}{T}$.\n    - Round this value to the nearest even integer. A robust method is $n_1 = 2 \\times \\text{round}(n_{1, \\text{prop}}/2)$.\n    - Apply safeguards to ensure $n_1$ and $n_2$ are at least $2$ (if their corresponding interval lengths are positive). If the calculation yields $n_1 < 2$, we set $n_1=2$. If it yields $n_1 > n_{\\text{total}}-2$, we set $n_1 = n_{\\text{total}}-2$.\n    - The allocation for the second interval is then $n_2 = n_{\\text{total}} - n_1$. By construction, if $n_{\\text{total}}$ and $n_1$ are even, $n_2$ will also be even.\n\nThe implementation will consist of a function that executes Simpson's rule and a main procedure that iterates through the provided test cases. For each case, it will:\n- Define the two integrand functions based on the specific parameters.\n- Determine the subinterval counts $n_1$ and $n_2$ according to the allocation algorithm.\n- Call the Simpson's rule function for each of the two integrals (if the interval length is positive).\n- Sum the results to obtain the total $\\text{NPV}$.\n- Round the final value to two decimal places as required.\n\nThis structured approach ensures that the piecewise nature of the economic model is correctly handled by the numerical integration, providing a scientifically sound and computationally robust solution.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the net present value of enrolling in an MBA program \n    for a series of test cases using the composite Simpson's rule.\n    \"\"\"\n\n    def simpson_rule(func, a, b, n):\n        \"\"\"\n        Approximates the definite integral of a function from a to b\n        using the composite Simpson's rule with n subintervals.\n\n        Args:\n            func (callable): The function to integrate.\n            a (float): The lower limit of integration.\n            b (float): The upper limit of integration.\n            n (int): The number of subintervals (must be even and positive).\n\n        Returns:\n            float: The approximate value of the integral.\n        \"\"\"\n        if n == 0 or a == b:\n            return 0.0\n        \n        if n  2 or n % 2 != 0:\n            raise ValueError(\"Number of subintervals (n) must be a positive even integer.\")\n\n        h = (b - a) / n\n        x = np.linspace(a, b, n + 1)\n        y = func(x)\n\n        # Simpson's rule formula\n        # S = y[0] + y[-1] + 4 * sum(odd indices) + 2 * sum(even indices)\n        integral = h / 3.0 * (y[0] + y[-1] + 4.0 * np.sum(y[1:-1:2]) + 2.0 * np.sum(y[2:-1:2]))\n        \n        return integral\n\n    # Define the test cases from the problem statement.\n    # Parameters: (A, g_pre, L, B, g_post, s_prog, tau, r, T)\n    test_cases = [\n        (80000, 0.02, 2, 120000, 0.03, 10000, 60000, 0.05, 40),\n        (85000, 0.02, 0, 110000, 0.025, 0, 0, 0.05, 35),\n        (70000, 0.03, 1.5, 95000, 0.035, 0, 50000, 0, 30),\n        (90000, 0.02, 2, 150000, 0.03, 5000, 80000, 0.04, 2),\n    ]\n\n    results = []\n    n_total = 4096\n\n    for case in test_cases:\n        A, g_pre, L, B, g_post, s_prog, tau, r, T = case\n\n        # Define the two integrands corresponding to the two time periods\n        \n        # Integrand for the period during the MBA program: [0, L]\n        # Delta(t) = s_prog - s_pre(t) - tuition(t)\n        integrand1 = lambda t: np.exp(-r * t) * (s_prog - tau - A * np.exp(g_pre * t))\n\n        # Integrand for the period after graduation: [L, T]\n        # Delta(t) = s_post(t) - s_pre(t)\n        integrand2 = lambda t: np.exp(-r * t) * (B * np.exp(g_post * (t - L)) - A * np.exp(g_pre * t))\n\n        # Allocate subintervals n1 and n2\n        n1, n2 = 0, 0\n        if L = 0:\n            # First interval has zero or negative length\n            n1 = 0\n            n2 = n_total\n            # Adjust integration range for the second part\n            L_eff = 0\n            T_eff = T\n        elif T = L:\n            # Second interval has zero or negative length\n            n1 = n_total\n            n2 = 0\n            L_eff = L\n            T_eff = L\n        else: # 0  L  T\n            # Proportional allocation\n            n1_prop = n_total * L / T\n            # Round to nearest even integer\n            n1 = int(round(n1_prop / 2.0) * 2)\n            \n            # Safeguard to ensure n1 and n2 are at least 2\n            if n1  2:\n                n1 = 2\n            if n_total - n1  2:\n                n1 = n_total - 2\n            \n            n2 = n_total - n1\n            L_eff = L\n            T_eff = T\n\n        # Calculate NPV for the first period [0, L]\n        npv1 = 0.0\n        if n1 > 0:\n            npv1 = simpson_rule(integrand1, 0, L_eff, n1)\n\n        # Calculate NPV for the second period [L, T]\n        # For L=0 case, this integral is over [0,T]\n        npv2 = 0.0\n        if n2 > 0:\n            npv2 = simpson_rule(integrand2, L_eff, T_eff, n2)\n\n        # Total NPV is the sum of the two parts\n        total_npv = npv1 + npv2\n        results.append(total_npv)\n\n    # Final print statement in the exact required format.\n    # Round to two decimal places for currency representation.\n    print(f\"[{','.join([f'{res:.2f}' for res in results])}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The analysis of financial portfolios moves us beyond single-variable problems into a world of multiple, correlated assets. Accurately capturing an investor's preferences requires calculating expected utility, often over complex, non-normal joint probability distributions. This advanced practice  demonstrates how to extend Simpson's rule into two dimensions to tackle such a problem. You will calculate the expected utility for a portfolio of assets with correlated, heavy-tailed returns, engaging with a cornerstone of modern quantitative finance.",
            "id": "2430205",
            "problem": "A portfolio consists of $2$ risky assets with simple returns denoted by $r_1$ and $r_2$. The joint Probability Density Function (PDF) of $(r_1,r_2)$ is specified as a bivariate Student-$t$ distribution with degrees of freedom $\\,\\nu2\\,$, location vector $\\mu=\\begin{bmatrix}\\mu_1\\\\ \\mu_2\\end{bmatrix}$, scale parameters $s_10$ and $s_20$, and linear correlation coefficient $\\rho \\in(-1,1)$. Let the covariance-style scale matrix be\n$$\n\\Sigma \\;=\\; \\begin{bmatrix}\ns_1^2  \\rho\\, s_1 s_2\\\\\n\\rho\\, s_1 s_2  s_2^2\n\\end{bmatrix},\n\\quad\n|\\Sigma| \\;=\\; s_1^2 s_2^2 (1-\\rho^2),\n\\quad\n\\Sigma^{-1} \\;=\\; \\frac{1}{(1-\\rho^2)}\\begin{bmatrix}\n1/s_1^2  -\\rho/(s_1 s_2)\\\\\n-\\rho/(s_1 s_2)  1/s_2^2\n\\end{bmatrix}.\n$$\nFor $d=2$ dimensions, the joint PDF is\n$$\nf(r_1,r_2) \\;=\\; \\frac{\\Gamma\\!\\left(\\tfrac{\\nu+d}{2}\\right)}{\\Gamma\\!\\left(\\tfrac{\\nu}{2}\\right)\\,(\\nu\\pi)^{d/2}\\,|\\Sigma|^{1/2}}\n\\left(1 + \\frac{1}{\\nu}\\,(x^\\top \\Sigma^{-1} x)\\right)^{-\\tfrac{\\nu+d}{2}},\n\\quad\nx \\;=\\; \\begin{bmatrix} r_1-\\mu_1 \\\\ r_2-\\mu_2 \\end{bmatrix},\n\\quad d=2,\n$$\nthat is,\n$$\nf(r_1,r_2) \\;=\\; \\frac{\\Gamma\\!\\left(\\tfrac{\\nu+2}{2}\\right)}{\\Gamma\\!\\left(\\tfrac{\\nu}{2}\\right)\\,\\nu\\pi\\, s_1 s_2 \\sqrt{1-\\rho^2}}\\,\n\\left(1 + \\frac{1}{\\nu}\\,\\frac{(r_1-\\mu_1)^2/s_1^2 - 2\\rho\\,(r_1-\\mu_1)(r_2-\\mu_2)/(s_1 s_2) + (r_2-\\mu_2)^2/s_2^2}{1-\\rho^2}\\right)^{-\\tfrac{\\nu+2}{2}}.\n$$\n\nLet initial wealth be $W_00$ and portfolio weights be $w_1$ and $w_2$. The terminal wealth is\n$$\nW(r_1,r_2) \\;=\\; W_0\\,\\big(1 + w_1 r_1 + w_2 r_2\\big).\n$$\nPreferences are given by the Constant Absolute Risk Aversion (CARA) utility\n$$\nU(W) \\;=\\; -\\exp(-a\\,W),\n$$\nwith absolute risk aversion parameter $a\\ge 0$. The expected utility is defined by the integral\n$$\n\\mathbb{E}[U(W)] \\;=\\; \\int_{-\\infty}^{\\infty}\\!\\int_{-\\infty}^{\\infty} U\\!\\big(W(r_1,r_2)\\big)\\, f(r_1,r_2)\\, \\mathrm{d}r_1\\,\\mathrm{d}r_2.\n$$\n\nFor numerical evaluation, restrict the domain to the rectangle\n$$\n\\mathcal{R} \\;=\\; \\big[\\mu_1 - K\\,s_1,\\; \\mu_1 + K\\,s_1\\big]\\;\\times\\;\\big[\\mu_2 - K\\,s_2,\\; \\mu_2 + K\\,s_2\\big],\n$$\nand approximate\n$$\n\\int_{\\mathcal{R}} U\\!\\big(W(r_1,r_2)\\big)\\, f(r_1,r_2)\\, \\mathrm{d}r_1\\,\\mathrm{d}r_2,\n$$\nwhich serves as an approximation to $\\mathbb{E}[U(W)]$.\n\nTest Suite. For each case below, use the given parameters, where $n_x$ and $n_y$ are the numbers of equal subintervals along the $r_1$ and $r_2$ axes, respectively. All $n_x$ and $n_y$ are even integers.\n\n- Case $1$ (general): $\\nu=6$, $\\mu_1=0.05$, $\\mu_2=0.02$, $s_1=0.20$, $s_2=0.15$, $\\rho=0.3$, $W_0=1.0$, $w_1=0.6$, $w_2=0.4$, $a=3.0$, $K=12$, $n_x=200$, $n_y=200$.\n- Case $2$ (independence): $\\nu=7$, $\\mu_1=0.04$, $\\mu_2=0.03$, $s_1=0.25$, $s_2=0.25$, $\\rho=0.0$, $W_0=1.0$, $w_1=0.5$, $w_2=0.5$, $a=1.5$, $K=12$, $n_x=180$, $n_y=180$.\n- Case $3$ (negative correlation, heavier tails): $\\nu=5$, $\\mu_1=0.01$, $\\mu_2=0.00$, $s_1=0.30$, $s_2=0.20$, $\\rho=-0.7$, $W_0=1.0$, $w_1=0.8$, $w_2=0.2$, $a=2.5$, $K=14$, $n_x=220$, $n_y=220$.\n- Case $4$ (risk-neutral benchmark): $\\nu=6$, $\\mu_1=0.00$, $\\mu_2=0.00$, $s_1=0.20$, $s_2=0.20$, $\\rho=0.5$, $W_0=1.0$, $w_1=0.3$, $w_2=0.7$, $a=0.0$, $K=16$, $n_x=200$, $n_y=200$.\n\nRequired program output. Your program should produce a single line of output containing the four numerical approximations for the cases above as a comma-separated list enclosed in square brackets, with each number rounded to $8$ decimal places, in the order of Cases $1$ to $4$ (for example, $[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4]$). No other text should be printed.",
            "solution": "The problem statement has been rigorously analyzed and is determined to be valid. It is scientifically sound, well-posed, and provides all necessary data and definitions for a unique and meaningful solution. The problem requires the numerical approximation of the expected utility of a portfolio whose asset returns follow a bivariate Student-$t$ distribution. We shall proceed with a detailed solution.\n\nThe objective is to compute the expected utility, which is defined by the integral:\n$$\n\\mathbb{E}[U(W)] \\;=\\; \\int_{-\\infty}^{\\infty}\\!\\int_{-\\infty}^{\\infty} U\\!\\big(W(r_1,r_2)\\big)\\, f(r_1,r_2)\\, \\mathrm{d}r_1\\,\\mathrm{d}r_2\n$$\nThe problem specifies that this integral is to be approximated by restricting the domain of integration to a finite rectangle $\\mathcal{R}$ given by:\n$$\n\\mathcal{R} \\;=\\; \\big[r_{1,\\min}, r_{1,\\max}\\big]\\;\\times\\;\\big[r_{2,\\min}, r_{2,\\max}\\big] \\;=\\; \\big[\\mu_1 - K\\,s_1,\\; \\mu_1 + K\\,s_1\\big]\\;\\times\\;\\big[\\mu_2 - K\\,s_2,\\; \\mu_2 + K\\,s_2\\big]\n$$\nThe function to be integrated, let us call it $g(r_1, r_2)$, is the product of the utility function $U(W)$ and the probability density function (PDF) $f(r_1, r_2)$.\n\nThe terminal wealth $W(r_1, r_2)$ is a linear function of the asset returns $r_1$ and $r_2$:\n$$\nW(r_1,r_2) \\;=\\; W_0\\,\\big(1 + w_1 r_1 + w_2 r_2\\big)\n$$\nThe utility function is of the Constant Absolute Risk Aversion (CARA) form:\n$$\nU(W) \\;=\\; -\\exp(-a\\,W)\n$$\nSubstituting the expression for wealth, the utility is:\n$$\nU(W(r_1, r_2)) \\;=\\; -\\exp\\Big(-a W_0 (1 + w_1 r_1 + w_2 r_2)\\Big)\n$$\nThe joint PDF of returns is the bivariate Student-$t$ distribution:\n$$\nf(r_1,r_2) \\;=\\; C \\cdot \\left(1 + \\frac{1}{\\nu(1-\\rho^2)}\\left[\\left(\\frac{r_1-\\mu_1}{s_1}\\right)^2 - 2\\rho\\left(\\frac{r_1-\\mu_1}{s_1}\\right)\\left(\\frac{r_2-\\mu_2}{s_2}\\right) + \\left(\\frac{r_2-\\mu_2}{s_2}\\right)^2\\right]\\right)^{-\\frac{\\nu+2}{2}}\n$$\nwhere the normalization constant $C$ is:\n$$\nC \\;=\\; \\frac{\\Gamma\\!\\left(\\frac{\\nu+2}{2}\\right)}{\\Gamma\\!\\left(\\frac{\\nu}{2}\\right)\\,\\nu\\pi\\, s_1 s_2 \\sqrt{1-\\rho^2}}\n$$\nThe integrand is therefore $g(r_1, r_2) = U(W(r_1, r_2)) \\cdot f(r_1, r_2)$.\n\nTo approximate the integral $\\int_{\\mathcal{R}} g(r_1, r_2) \\, \\mathrm{d}r_1 \\mathrm{d}r_2$, we employ the two-dimensional Simpson's rule, which is appropriate given that the number of subintervals, $n_x$ and $n_y$, are specified as even integers.\n\nFirst, we discretize the integration domain. The intervals $[r_{1,\\min}, r_{1,\\max}]$ and $[r_{2,\\min}, r_{2,\\max}]$ are divided into $n_x$ and $n_y$ subintervals of equal width, respectively. The step sizes are:\n$$\nh_1 = \\frac{r_{1,\\max} - r_{1,\\min}}{n_x} = \\frac{2 K s_1}{n_x}\n\\quad \\text{and} \\quad\nh_2 = \\frac{r_{2,\\max} - r_{2,\\min}}{n_y} = \\frac{2 K s_2}{n_y}\n$$\nThis creates a grid of points $(r_{1,i}, r_{2,j})$, where $r_{1,i} = r_{1,\\min} + i h_1$ for $i \\in \\{0, 1, \\dots, n_x\\}$ and $r_{2,j} = r_{2,\\min} + j h_2$ for $j \\in \\{0, 1, \\dots, n_y\\}$.\n\nSimpson's rule for a two-dimensional integral is an extension of the one-dimensional rule. The formula for the approximation is:\n$$\nI \\approx \\frac{h_1 h_2}{9} \\sum_{i=0}^{n_x} \\sum_{j=0}^{n_y} w_{i,j} g(r_{1,i}, r_{2,j})\n$$\nThe weights $w_{i,j}$ are the products of the one-dimensional Simpson's weights. The one-dimensional weight vector for $n$ subintervals ($n$ is even) is $(1, 4, 2, 4, \\dots, 2, 4, 1)$. Let $w^{(1)}$ be the weight vector for the $r_1$ dimension (length $n_x+1$) and $w^{(2)}$ be the weight vector for the $r_2$ dimension (length $n_y+1$). Then the weight matrix $W$ with entries $w_{i,j}$ is constructed such that $w_{i,j} = w_i^{(1)} w_j^{(2)}$.\n\nThe algorithm for each test case is as follows:\n1.  Define the integration limits $r_{1,\\min}, r_{1,\\max}, r_{2,\\min}, r_{2,\\max}$ using the given parameters $\\mu_1, \\mu_2, s_1, s_2, K$.\n2.  Generate two vectors of grid points, one for $r_1$ of size $n_x+1$ and one for $r_2$ of size $n_y+1$.\n3.  Create a two-dimensional mesh grid from these vectors to represent all $(r_{1,i}, r_{2,j})$ points.\n4.  Evaluate the integrand $g(r_1, r_2)$ at each point on the grid. This involves two main sub-steps:\n    a. Compute the PDF values $f(r_{1,i}, r_{2,j})$. The gamma function $\\Gamma(z)$ from the `scipy.special` library is required for the constant factor.\n    b. Compute the utility values $U(W(r_{1,i}, r_{2,j}))$.\n    c. Multiply the PDF and utility values element-wise to form a matrix of integrand values.\n5.  Construct the Simpson's weight vectors for the $r_1$ and $r_2$ dimensions.\n6.  Form the two-dimensional weight matrix by taking the outer product of the two weight vectors.\n7.  Compute the sum of the element-wise product of the integrand matrix and the weight matrix.\n8.  Multiply this sum by the factor $\\frac{h_1 h_2}{9}$ to obtain the final numerical value for the integral.\n\nA special consideration is Case $4$, where the risk aversion parameter $a=0$. In this case, the utility function becomes constant:\n$$\nU(W) = -\\exp(-0 \\cdot W) = -1\n$$\nThe expected utility integral simplifies to:\n$$\n\\mathbb{E}[U(W)] \\approx \\int_{\\mathcal{R}} (-1) \\cdot f(r_1, r_2) \\, \\mathrm{d}r_1 \\mathrm{d}r_2 = - \\int_{\\mathcal{R}} f(r_1, r_2) \\, \\mathrm{d}r_1 \\mathrm{d}r_2\n$$\nThis is the negative of the total probability mass contained within the integration rectangle $\\mathcal{R}$. Since $K=16$ is large, this rectangle covers the vast majority of the probability distribution, and the result should be very close to $-1$. This serves as a useful sanity check for the implementation.",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import gamma\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    \"\"\"\n\n    # Test cases as defined in the problem statement.\n    # Each tuple contains: (nu, mu1, mu2, s1, s2, rho, W0, w1, w2, a, K, nx, ny)\n    test_cases = [\n        (6.0, 0.05, 0.02, 0.20, 0.15, 0.3, 1.0, 0.6, 0.4, 3.0, 12, 200, 200),\n        (7.0, 0.04, 0.03, 0.25, 0.25, 0.0, 1.0, 0.5, 0.5, 1.5, 12, 180, 180),\n        (5.0, 0.01, 0.00, 0.30, 0.20, -0.7, 1.0, 0.8, 0.2, 2.5, 14, 220, 220),\n        (6.0, 0.00, 0.00, 0.20, 0.20, 0.5, 1.0, 0.3, 0.7, 0.0, 16, 200, 200),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_expected_utility(*case)\n        results.append(f\"{result:.8f}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef calculate_expected_utility(nu, mu1, mu2, s1, s2, rho, W0, w1, w2, a, K, nx, ny):\n    \"\"\"\n    Calculates the expected utility for a single set of parameters using 2D Simpson's rule.\n    \"\"\"\n    # 1. Define integration domain\n    r1_min, r1_max = mu1 - K * s1, mu1 + K * s1\n    r2_min, r2_max = mu2 - K * s2, mu2 + K * s2\n\n    h1 = (r1_max - r1_min) / nx\n    h2 = (r2_max - r2_min) / ny\n\n    # 2. Create grid of points\n    r1_vals = np.linspace(r1_min, r1_max, nx + 1)\n    r2_vals = np.linspace(r2_min, r2_max, ny + 1)\n    R1, R2 = np.meshgrid(r1_vals, r2_vals, indexing='xy')\n\n    # 3. Calculate integrand values on the grid\n    \n    # 3a. Bivariate Student-t PDF f(r1, r2)\n    # Normalization constant\n    const_C = gamma((nu + 2) / 2) / (gamma(nu / 2) * nu * np.pi * s1 * s2 * np.sqrt(1 - rho**2))\n    \n    # Standardized variables\n    z1 = (R1 - mu1) / s1\n    z2 = (R2 - mu2) / s2\n    \n    # Quadratic form in the exponent\n    quad_form = (z1**2 - 2 * rho * z1 * z2 + z2**2) / (1 - rho**2)\n    \n    pdf_vals = const_C * (1 + quad_form / nu)**(- (nu + 2) / 2)\n\n    # 3b. CARA Utility U(W(r1, r2))\n    terminal_wealth = W0 * (1 + w1 * R1 + w2 * R2)\n    utility_vals = -np.exp(-a * terminal_wealth)\n\n    # 3c. Integrand g = U * f\n    integrand_vals = utility_vals * pdf_vals\n\n    # 4. Construct Simpson's weights\n    weights_x = np.ones(nx + 1)\n    weights_x[1:-1:2] = 4\n    weights_x[2:-1:2] = 2\n\n    weights_y = np.ones(ny + 1)\n    weights_y[1:-1:2] = 4\n    weights_y[2:-1:2] = 2\n    \n    # 5. Create 2D weight matrix\n    # meshgrid with 'xy' indexing returns arrays with shape (ny+1, nx+1)\n    # The weight matrix must match this shape.\n    # The correct weight for g(x_i, y_j) is w_i * w_j.\n    # With this indexing, the point at integrand_vals[j, i] corresponds to x_i, y_j\n    # So we need weight_matrix[j, i] = weights_y[j] * weights_x[i]\n    # This is exactly what np.outer(weights_y, weights_x) does.\n    weight_matrix = np.outer(weights_y, weights_x)\n\n    # 6. Apply 2D Simpson's rule formula\n    integral_val = (h1 * h2 / 9.0) * np.sum(integrand_vals * weight_matrix)\n\n    return integral_val\n\nsolve()\n```"
        }
    ]
}