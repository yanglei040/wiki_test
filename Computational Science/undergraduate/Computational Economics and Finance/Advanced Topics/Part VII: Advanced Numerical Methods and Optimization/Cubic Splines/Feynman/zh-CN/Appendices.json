{
    "hands_on_practices": [
        {
            "introduction": "本练习为您提供了一个直接的动手实践机会，以掌握三次样条构建的核心机制。通过为一个简单的数据集计算内部节点上的二阶导数，您将应用控制样条曲率的基本线性方程，从而深入理解样条如何在节点间确保平滑性。",
            "id": "2164958",
            "problem": "函数 $S(x)$ 是一个对一组数据点进行插值的自然三次样条。根据定义，三次样条是一个由三次多项式组成的分段函数，它本身及其一阶和二阶导数都是连续的。“自然”三次样条具有一个额外的性质，即其二阶导数在插值区间的两个端点处为零。\n\n考虑一个自然三次样条 $S(x)$，它经过以下三个数据点：$(x_0, y_0) = (0, 0)$，$(x_1, y_1) = (1, 1)$ 和 $(x_2, y_2) = (2, 0)$。\n\n计算该样条在 $x=1$ 处的二阶导数的值，记为 $S''(1)$。",
            "solution": "令 $x_{0}=0$，$x_{1}=1$，$x_{2}=2$，且 $y_{0}=0$，$y_{1}=1$，$y_{2}=0$。对于自然三次样条，其在节点处的二阶导数 $M_{i}=S''(x_{i})$ 满足 $M_{0}=0$ 和 $M_{2}=0$，并且内部方程为\n$$\nh_{i-1}M_{i-1}+2(h_{i-1}+h_{i})M_{i}+h_{i}M_{i+1}\n=6\\left(\\frac{y_{i+1}-y_{i}}{h_{i}}-\\frac{y_{i}-y_{i-1}}{h_{i-1}}\\right),\n$$\n对于 $i=1,\\ldots,n-1$，其中 $h_{i}=x_{i+1}-x_{i}$。在本题中，$n=2$，所以 $i=1$。$h_{0}=x_{1}-x_{0}=1$ 且 $h_{1}=x_{2}-x_{1}=1$，并且在 $i=1$ 处有一个唯一的内部方程：\n$$\nh_{0} M_{0}+2(h_{0}+h_{1})M_{1}+h_{1} M_{2}\n=6\\left(\\frac{y_{2}-y_{1}}{h_{1}}-\\frac{y_{1}-y_{0}}{h_{0}}\\right).\n$$\n将 $M_{0}=0$，$M_{2}=0$，$y_{2}-y_{1}=0-1=-1$ 和 $y_{1}-y_{0}=1-0=1$ 代入，得到\n$$\n1 \\cdot 0 + 2(1+1)M_{1}+1\\cdot 0\n=6\\left(\\frac{-1}{1}-\\frac{1}{1}\\right).\n$$\n$$\n4M_{1}=6(-2)=-12,\n$$\n因此\n$$\nM_{1}=-3.\n$$\n所以 $S''(1)=M_{1}=-3$。",
            "answer": "$$\\boxed{-3}$$"
        },
        {
            "introduction": "本练习超越了纯粹的计算，深入探讨了样条的数学性质在金融领域的实际意义。您将分析一个不满足合格样条平滑性要求的分段函数，并发现这个看似微小的数学缺陷如何导致了在隐含的远期利率曲线上产生不符合经济学常理的跳跃。这个实践突显了为什么确保至少$C^1$连续性对于构建合理的金融模型至关重要。",
            "id": "2386597",
            "problem": "您正在使用一个分段三次函数拟合一个连续复利零息收益率的期限结构，该函数旨在作为到期期限域 $[0,2]$（单位：年）上的一个三次样条，在 $t=1$ 处有一个单一节点。考虑以下候选函数 $S:[0,2]\\to \\mathbb{R}$，定义为\n$$\nS(t)=\n\\begin{cases}\nt^3, & t\\in[0,1],\\\\\nt^3 + (t-1), & t\\in(1,2].\n\\end{cases}\n$$\n将 $y(t)\\equiv S(t)$ 解释为到期期限为 $t>0$ 的连续复利零利率（年化）。与 $y(t)$ 相关的折现函数 $D(t)$ 定义为\n$$\nD(t) \\equiv \\exp\\!\\Big(-\\int_0^t f(u)\\,du\\Big),\n$$\n其中 $f(t)$ 是瞬时远期利率，而连续复利零利率定义为\n$$\ny(t) \\equiv -\\frac{1}{t}\\ln D(t), \\quad t>0.\n$$\n哪个选项正确地描述了 $S(t)$ 在节点处的光滑性，以及通过上述定义由 $y(t)$ 构建的隐含瞬时远期利率曲线 $f(t)$ 的经济含义？\n\nA. $S(t)$ 在 $t=1$ 处是 $C^0$ 连续但非 $C^1$ 连续。隐含的 $f(t)$ 在 $t=1$ 处有一个跳跃间断点，其幅度等于 $y(t)$ 在 $t=1$ 处单侧导数的跳跃值，此处为一个大小为 $1$ 的向上跳跃，这意味着在没有已知离散事件的情况下，边际折现率在 $t=1$ 处出现一个突兀的、不符合经济学常理的尖峰。\n\nB. $S(t)$ 在 $t=1$ 处是 $C^1$ 连续但非 $C^2$ 连续。隐含的 $f(t)$ 在 $t=1$ 处是连续的但表现出一个扭结，因此边际折现率没有突变。\n\nC. $S(t)$ 在 $t=1$ 处不满足 $C^0$ 连续性，因此 $D(t)$ 在 $t=1$ 处不连续，违反了无套利条件，且 $f(t)$ 在 $t=1$ 处没有良好定义。\n\nD. $S(t)$ 在 $t=1$ 处是 $C^0$ 连续但非 $C^1$ 连续。然而，由于 $y(t)$ 通过一个积分映射到 $D(t)$，隐含的 $f(t)$ 在 $t=1$ 处仍然是连续的；$y(t)$ 中的任何扭结都会被平滑掉，对 $f(t)$ 的间断性没有影响。\n\nE. $S(t)$ 在 $t=1$ 处是 $C^0$ 连续但非 $C^1$ 连续。隐含的 $f(t)$ 在 $t=1$ 处包含一个狄拉克δ（Dirac delta）函数 $\\delta$ 贡献但没有跳跃；积分关系将非光滑性推入一个脉冲而不是 $f(t)$ 中的一个阶跃。",
            "solution": "在尝试任何解答之前，必须首先验证问题陈述的科学性和逻辑一致性。\n\n问题提供了以下定义和函数：\n一个用于零息收益率期限结构的候选函数 $S(t)$ 定义在域 $t \\in [0,2]$ 上，在 $t=1$ 处有一个节点：\n$$\nS(t)=\n\\begin{cases}\nS_1(t) = t^3, & t\\in[0,1],\\\\\nS_2(t) = t^3 + (t-1), & t\\in(1,2].\n\\end{cases}\n$$\n连续复利零利率被等同于此函数：$y(t) \\equiv S(t)$。\n折现函数 $D(t)$ 由瞬时远期利率 $f(t)$ 定义：\n$$\nD(t) \\equiv \\exp\\!\\Big(-\\int_0^t f(u)\\,du\\Big)\n$$\n零利率 $y(t)$ 与折现函数 $D(t)$ 的关系为：\n$$\ny(t) \\equiv -\\frac{1}{t}\\ln D(t), \\quad t>0.\n$$\n问题要求描述 $S(t)$ 在节点 $t=1$ 处的光滑性，以及对隐含的瞬时远期利率曲线 $f(t)$ 的经济影响。\n\n所提供的定义是利率理论中的标准定义。根据 $y(t)$ 的定义，我们可以写出 $\\ln D(t) = -t \\cdot y(t)$。将此代入 $D(t)$ 的定义并取对数，得到 $-t \\cdot y(t) = -\\int_0^t f(u) du$，即 $t \\cdot y(t) = \\int_0^t f(u) du$。\n为了从零利率 $y(t)$ 中求出瞬时远期利率 $f(t)$，我们使用微积分基本定理对该关系式关于 $t$ 求导：\n$$\n\\frac{d}{dt} [t \\cdot y(t)] = f(t)\n$$\n使用乘法法则，得到基本关系式：\n$$\nf(t) = y(t) + t \\cdot y'(t)\n$$\n该问题定义明确、陈述客观，并且在标准金融数学中有科学依据。函数 $S(t)$ 是一个简单的分段多项式，适合进行形式分析。由 $S(t)$ 产生的收益率大小（例如，$S(1) = 1$ 或 $100\\%$）对于现实世界经济而言并不典型，但这并不影响问题的数学结构的有效性，该问题是一个分析函数性质的形式练习。该问题是有效的。\n\n我们继续进行解答。\n\n首先，我们分析 $S(t)$ 在节点 $t=1$ 处的光滑性。\n函数定义为 $S(t) = y(t)$。\n对于 $t \\in [0,1]$，$S_1(t) = t^3$。\n对于 $t \\in (1,2]$，$S_2(t) = t^3 + t - 1$。\n\n我们评估函数的连续性，即 $C^0$ 连续性。我们计算在 $t=1$ 处的左极限和右极限：\n$$\n\\lim_{t \\to 1^-} S(t) = \\lim_{t \\to 1^-} t^3 = 1^3 = 1\n$$\n$$\n\\lim_{t \\to 1^+} S(t) = \\lim_{t \\to 1^+} (t^3 + t - 1) = 1^3 + 1 - 1 = 1\n$$\n在节点处的值为 $S(1) = 1^3 = 1$。由于左极限、右极限和函数值都等于 $1$，函数 $S(t)$ 在 $t=1$ 处是连续的。它是 $C^0$ 连续的。\n\n接下来，我们评估一阶导数的连续性，即 $C^1$ 连续性。我们首先求出 $S(t)$ 各段的导数：\n对于 $t \\in [0,1)$，$S'(t) = S_1'(t) = \\frac{d}{dt}(t^3) = 3t^2$。\n对于 $t \\in (1,2]$，$S'(t) = S_2'(t) = \\frac{d}{dt}(t^3 + t - 1) = 3t^2 + 1$。\n\n现在，我们计算导数在 $t=1$ 处的左极限和右极限：\n$$\nS'(1^-) = \\lim_{t \\to 1^-} S'(t) = \\lim_{t \\to 1^-} 3t^2 = 3(1)^2 = 3\n$$\n$$\nS'(1^+) = \\lim_{t \\to 1^+} S'(t) = \\lim_{t \\to 1^+} (3t^2 + 1) = 3(1)^2 + 1 = 4\n$$\n由于 $S'(1^-) \\neq S'(1^+)$，一阶导数 $S'(t)$ 在 $t=1$ 处不连续。因此，函数 $S(t)$ 在 $t=1$ 处不是 $C^1$ 连续的。\n总结来说，$S(t)$ 在 $t=1$ 处是 $C^0$ 连续但非 $C^1$ 连续的。\n\n其次，我们分析隐含的瞬时远期利率曲线 $f(t)$。\n我们使用关系式 $f(t) = \\frac{d}{dt}[t \\cdot y(t)]$ 来计算分段的瞬时远期利率。\n对于 $t \\in [0,1)$：$y(t) = t^3$。乘积为 $t \\cdot y(t) = t \\cdot t^3 = t^4$。\n则 $f(t) = \\frac{d}{dt}(t^4) = 4t^3$。\n\n对于 $t \\in (1,2]$：$y(t) = t^3 + t - 1$。乘积为 $t \\cdot y(t) = t(t^3 + t - 1) = t^4 + t^2 - t$。\n则 $f(t) = \\frac{d}{dt}(t^4 + t^2 - t) = 4t^3 + 2t - 1$。\n\n所以瞬时远期利率由以下分段函数给出：\n$$\nf(t)=\n\\begin{cases}\n4t^3, & t\\in[0,1),\\\\\n4t^3 + 2t - 1, & t\\in(1,2].\n\\end{cases}\n$$\n我们检查 $f(t)$ 在 $t=1$ 处的连续性：\n$$\n\\lim_{t \\to 1^-} f(t) = \\lim_{t \\to 1^-} 4t^3 = 4(1)^3 = 4\n$$\n$$\n\\lim_{t \\to 1^+} f(t) = \\lim_{t \\to 1^+} (4t^3 + 2t - 1) = 4(1)^3 + 2(1) - 1 = 4 + 2 - 1 = 5\n$$\n由于极限不相等，$f(t)$ 在 $t=1$ 处有跳跃间断点。跳跃的幅度为 $\\Delta f |_1 = \\lim_{t \\to 1^+} f(t) - \\lim_{t \\to 1^-} f(t) = 5 - 4 = 1$。这是一个向上的跳跃。\n\n让我们将这个跳跃与 $y(t)$ 的性质联系起来。\n在节点 $t_k$ 处 $f(t)$ 的跳跃由 $f(t_k^+) - f(t_k^-)$ 给出。\n使用 $f(t) = y(t) + t y'(t)$:\n$\\lim_{t \\to t_k^+} f(t) = \\lim_{t \\to t_k^+} (y(t) + t y'(t)) = y(t_k) + t_k y'(t_k^+)$ 因为 $y(t)$ 是连续的。\n$\\lim_{t \\to t_k^-} f(t) = \\lim_{t \\to t_k^-} (y(t) + t y'(t)) = y(t_k) + t_k y'(t_k^-)$。\n跳跃为 $ (y(t_k) + t_k y'(t_k^+)) - (y(t_k) + t_k y'(t_k^-)) = t_k (y'(t_k^+) - y'(t_k^-))$。\n$y'(t_k^+) - y'(t_k^-)$ 项是收益率曲线 $y(t)$ 的导数在节点处的跳跃。\n在我们的问题中，$t_k=1$。$y'(t)$ 的跳跃是 $y'(1^+) - y'(1^-) = 4-3=1$。\n因此，$f(t)$ 的跳跃是 $1 \\cdot (4-3) = 1$。这与我们的直接计算相符。\n\n经济含义是，瞬时远期利率，代表在未来时间 $t$ 借贷的边际利率，经历了一个突兀的、离散的跳跃。在一个没有在该特定到期日安排重大经济事件或公告的正常运转市场中，这样的特征被认为是高度人为且不符合经济学常理的。这表明收益率曲线模型的选择存在缺陷。\n\n现在我们评估每个选项。\n\nA. $S(t)$ 在 $t=1$ 处是 $C^0$ 连续但非 $C^1$ 连续。隐含的 $f(t)$ 在 $t=1$ 处有一个跳跃间断点，其幅度等于 $y(t)$ 在 $t=1$ 处单侧导数的跳跃值，此处为一个大小为 $1$ 的向上跳跃，这意味着在没有已知离散事件的情况下，边际折现率在 $t=1$ 处出现一个突兀的、不符合经济学常理的尖峰。\n- “$S(t)$ 在 $t=1$ 处是 $C^0$ 连续但非 $C^1$ 连续。” 正确，如上推导。\n- “隐含的 $f(t)$ 在 $t=1$ 处有一个跳跃间断点。” 正确。\n- “其幅度等于 $y(t)$ 在 $t=1$ 处单侧导数的跳跃值。” 正确。$f(t)$ 的跳跃为 $1$。$y'(t)$ 的跳跃为 $y'(1^+) - y'(1^-) = 4-3=1$。幅度相等是因为节点在 $t=1$。\n- “此处为一个大小为 $1$ 的向上跳跃。” 正确，我们计算出跳跃为 $5-4=1$。\n- “这意味着一个突兀的、不符合经济学常理的尖峰...”。 正确，这是标准的经济解释。\n这个陈述完全正确。\n\nB. $S(t)$ 在 $t=1$ 处是 $C^1$ 连续但非 $C^2$ 连续。隐含的 $f(t)$ 在 $t=1$ 处是连续的但表现出一个扭结，因此边际折现率没有突变。\n- “$S(t)$ 在 $t=1$ 处是 $C^1$ 连续但非 $C^2$ 连续。” 不正确。我们证明了 $S(t)$ 不是 $C^1$ 连续的。\n\nC. $S(t)$ 在 $t=1$ 处不满足 $C^0$ 连续性，因此 $D(t)$ 在 $t=1$ 处不连续，违反了无套利条件，且 $f(t)$ 在 $t=1$ 处没有良好定义。\n- “$S(t)$ 在 $t=1$ 处不满足 $C^0$ 连续性。” 不正确。我们证明了 $S(t)$ 是 $C^0$ 连续的。\n\nD. $S(t)$ 在 $t=1$ 处是 $C^0$ 连续但非 $C^1$ 连续。然而，由于 $y(t)$ 通过一个积分映射到 $D(t)$，隐含的 $f(t)$ 在 $t=1$ 处仍然是连续的；$y(t)$ 中的任何扭结都会被平滑掉，对 $f(t)$ 的间断性没有影响。\n- “$S(t)$ 在 $t=1$ 处是 $C^0$ 连续但非 $C^1$ 连续。” 正确。\n- “由于 $y(t)$ 通过一个积分映射到 $D(t)$，隐含的 $f(t)$ 仍然是连续的”。 前提混乱，结论错误。从 $y(t)$ 到 $f(t)$ 的映射是通过微分 $f(t) = \\frac{d}{dt}[t \\cdot y(t)]$，而不是积分。微分不会使函数平滑；通常会使它们更不平滑。我们明确地证明了 $f(t)$ 是不连续的。不正确。\n\nE. $S(t)$ 在 $t=1$ 处是 $C^0$ 连续但非 $C^1$ 连续。隐含的 $f(t)$ 在 $t=1$ 处包含一个狄拉克δ（Dirac delta）函数 $\\delta$ 贡献但没有跳跃；积分关系将非光滑性推入一个脉冲而不是 $f(t)$ 中的一个阶跃。\n- “$S(t)$ 在 $t=1$ 处是 $C^0$ 连续但非 $C^1$ 连续。” 正确。\n- “隐含的 $f(t)$ 在 $t=1$ 处包含一个狄拉克δ函数 $\\delta$ 贡献。” 不正确。如果被微分的函数 $t \\cdot y(t)$ 存在跳跃间断点，那么 $f(t)$ 中才会出现狄拉克δ函数贡献。在这里，$t \\cdot y(t)$ 是连续的，但有一个扭结（不可微点）。它的导数有一个跳跃间断点，而不是狄拉克δ函数。\n- “但没有跳跃”。 不正确。我们证明了它有跳跃。\n\n基于这一严谨的分析，只有选项 A 是正确的。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "这个计算练习将展示高阶多项式插值中一个被称为“龙格现象”的经典陷阱，并说明为何三次样条通常是更优越的替代方案。通过编写代码来插值一个类似于隐含波动率微笑的函数，您将定量地比较多项式插值产生的大误差与自然三次样条提供的稳定、精确的拟合效果。这种动手比较生动地展示了样条在计算金融中的稳健性和实用价值。",
            "id": "2386520",
            "problem": "考虑一个函数 $v(k)$，它将标准化对数货币性 $k$ 映射到一个隐含波动率水平，定义如下\n$$\nv(k) \\equiv \\alpha + \\frac{\\beta}{1 + \\gamma k^2},\n$$\n其参数为 $\\alpha = 0.2$，$\\beta = 0.1$ 和 $\\gamma = 25$。对于一个给定的整数 $n \\ge 2$，在闭区间 $[-1,1]$ 上定义一个包含 $n$ 个等距节点的数据集，其节点为 $k_i = -1 + \\frac{2(i-1)}{n-1}$，其中 $i \\in \\{1,2,\\dots,n\\}$，观测值为 $y_i = v(k_i)$。\n\n对于每个指定的 $n$，考虑由同一数据集 $\\{(k_i,y_i)\\}_{i=1}^n$ 构建的两种插值函数：\n1. $p_n(k)$ 是次数最多为 $n-1$ 的唯一多项式插值函数，满足对于所有 $i \\in \\{1,2,\\dots,n\\}$ 都有 $p_n(k_i) = y_i$。\n2. $s_n(k)$ 是自然三次样条插值函数，其节点位于 $\\{k_i\\}_{i=1}^n$ 处，满足对于所有 $i \\in \\{1,2,\\dots,n\\}$ 都有 $s_n(k_i) = y_i$。该函数在 $[-1,1]$ 上二阶连续可微，在连续的节点之间是分段三次的，并遵循自然边界条件 $s_n''(-1) = 0$ 和 $s_n''(1) = 0$。\n\n对于一个包含在 $[-1,1]$ 中的评估网格 $\\{x_j\\}_{j=1}^m$，定义近似函数 $a(k)$ 对 $v(k)$ 的均方根误差 (RMSE) 为\n$$\n\\mathrm{RMSE}(a) \\equiv \\left( \\frac{1}{m} \\sum_{j=1}^m \\left[a(x_j) - v(x_j)\\right]^2 \\right)^{1/2},\n$$\n以及最大绝对误差为\n$$\n\\mathrm{MAX}(a) \\equiv \\max_{1 \\le j \\le m} \\left|a(x_j) - v(x_j)\\right|.\n$$\n\n使用上述定义，评估以下四个测试用例：\n\n- 用例 A (一般情况)：$n = 9$，评估网格大小 $m = 1001$，点在 $[-1,1]$ 上等距分布。\n- 用例 B (一般情况)：$n = 17$，评估网格大小 $m = 1001$，点在 $[-1,1]$ 上等距分布。\n- 用例 C (高次边界压力)：$n = 25$，评估网格大小 $m = 1001$，点在 $[-1,1]$ 上等距分布。\n- 用例 D (插值恒等性检查)：$n = 17$，评估网格恰好由 $n$ 个节点组成，即 $m = n$ 且 $\\{x_j\\}_{j=1}^m = \\{k_i\\}_{i=1}^n$。\n\n对于每个用例，按以下顺序计算四个量：\n1. $\\mathrm{RMSE}(p_n)$,\n2. $\\mathrm{RMSE}(s_n)$,\n3. $\\mathrm{MAX}(p_n)$,\n4. $\\mathrm{MAX}(s_n)$.\n\n最终输出格式要求：您的程序应生成单行输出，其中包含一个逗号分隔的列表，该列表由四个元素的列表组成，每个子列表对应一个测试用例，并用方括号括起来。具体来说，输出必须为\n$$\n\\left[\\left[r_1,r_2,r_3,r_4\\right],\\left[r_1',r_2',r_3',r_4'\\right],\\left[r_1'',r_2'',r_3'',r_4''\\right],\\left[r_1''',r_2''',r_3''',r_4'''\\right]\\right],\n$$\n其中每个 $r_\\cdot$ 是一个实数，四个内部列表按上述顺序分别对应于用例 A、B、C 和 D。所有数值结果必须表示为不带单位的实数。输出必须严格按照规定格式单行显示，例如 $[ [\\cdots], [\\cdots], [\\cdots], [\\cdots] ]$，不包含任何额外的解释性文本、百分号或角度单位。",
            "solution": "问题陈述已经过严格验证，并被确定为是合理的。它在数值分析领域有科学依据，是适定的、客观的，并包含了唯一解所需的所有必要信息。不存在不一致、矛盾或模糊之处。因此，我们可以开始求解。\n\n该问题要求对两种插值方案——全局多项式插值和分段三次样条插值——在逼近一个给定函数时的表现进行比较分析。待逼近的函数模拟了一条隐含波动率曲线，定义如下：\n$$\nv(k) \\equiv \\alpha + \\frac{\\beta}{1 + \\gamma k^2}\n$$\n给定参数为 $\\alpha = 0.2$，$\\beta = 0.1$ 和 $\\gamma = 25$。这是一个有理函数，在整个实数轴上是无限可微的（$C^\\infty$）。然而，其到复平面的解析延拓在 $k = \\pm i/\\sqrt{\\gamma} = \\pm i/5 = \\pm 0.2i$ 处有极点。这些极点与插值区间 $[-1, 1]$ 的接近程度是影响多项式插值函数收敛特性的一个关键因素。\n\n对于给定的节点数 $n$，我们得到一个数据集 $\\{(k_i, y_i)\\}_{i=1}^n$，其中节点 $k_i = -1 + \\frac{2(i-1)}{n-1}$ 在 $[-1, 1]$ 上均匀分布，对应的值为 $y_i = v(k_i)$。\n\n第一个近似函数 $p_n(k)$ 是次数最多为 $n-1$ 的唯一插值多项式。为了使这样的多项式存在且唯一，$k_i$ 必须是互不相同的，这一点由其定义保证。尽管唯一解存在，但在逼近论中一个公认的结论是：对于像 $v(k)$ 这样在实数区间附近有奇点的函数，使用等距节点进行高次多项式插值会导致剧烈振荡，尤其是在区间端点附近。这种现象被称为 Runge 现象。为了计算该多项式，我们将采用一种数值稳定的方法，即重心插值公式，这比为求解单项式系数而构造和求解病态的 Vandermonde 系统更可取。\n\n第二个近似函数 $s_n(k)$ 是自然三次样条。该方法在每个子区间 $[k_i, k_{i+1}]$ 上构造一个分段三次多项式。为确保光滑性，要求样条函数在整个区间 $[-1, 1]$ 上是二阶连续可微的（$C^2$）。这是通过强制相邻分段三次多项式的函数值、一阶导数和二阶导数在内部节点处匹配来实现的。该系统通过“自然”边界条件 $s_n''(-1) = 0$ 和 $s_n''(1) = 0$ 来闭合。这种设置导出了一个良态的三对角线性方程组，用于求解节点上的二阶导数，该方程组可以被高效且稳定地求解。三次样条在数据拟合和插值方面通常优于高次多项式，因为它们能避免高次多项式的振荡行为。\n\n每个插值函数 $a(k) \\in \\{p_n(k), s_n(k)\\}$ 的性能通过在离散网格 $\\{x_j\\}_{j=1}^m$ 上评估的两个误差度量来量化：\n1.  均方根误差：$\\mathrm{RMSE}(a) = \\left( \\frac{1}{m} \\sum_{j=1}^m [a(x_j) - v(x_j)]^2 \\right)^{1/2}$\n2.  最大绝对误差：$\\mathrm{MAX}(a) = \\max_{1 \\le j \\le m} |a(x_j) - v(x_j)|$\n\n每个测试用例的计算过程如下：\n1.  对于给定的 $n$，建立 $n$ 个插值节点的集合 $\\{k_i\\}$，并计算相应的值 $\\{y_i = v(k_i)\\}$。\n2.  使用数据集 $\\{(k_i, y_i)\\}$，通过重心坐标形式构造多项式插值函数 $p_n(k)$。\n3.  使用相同的数据集构造自然三次样条插值函数 $s_n(k)$，并施加条件 $s_n''(-1) = s_n''(1) = 0$。\n4.  按照测试用例的规定定义评估网格 $\\{x_j\\}_{j=1}^m$。\n5.  在评估网格上计算 $v(x_j)$、$p_n(x_j)$ 和 $s_n(x_j)$ 的值。\n6.  计算多项式和样条的误差向量。\n7.  计算所需的四个度量：$\\mathrm{RMSE}(p_n)$、$\\mathrm{RMSE}(s_n)$、$\\mathrm{MAX}(p_n)$ 和 $\\mathrm{MAX}(s_n)$。\n\n对于用例 C，其节点数高达 $n=25$，我们预计会观察到显著的 Runge 现象，导致 $p_{25}(k)$ 出现巨大误差。相反，随着 $n$ 的增加，样条插值的误差应该会减小。用例 D 是一个基本的正确性检查：由于评估网格与插值节点重合，根据插值的定义 $a(k_i) = y_i = v(k_i)$，因此两种插值函数的误差都必须为零（或在机器精度范围内）。以下程序实现了这个过程。",
            "answer": "```python\nimport numpy as np\nfrom scipy.interpolate import BarycentricInterpolator, CubicSpline\n\ndef solve():\n    \"\"\"\n    Computes and compares errors for polynomial and cubic spline interpolants.\n    \"\"\"\n    # Define parameters for the function v(k)\n    alpha = 0.2\n    beta = 0.1\n    gamma = 25.0\n\n    def v(k: np.ndarray) -> np.ndarray:\n        \"\"\"\n        The target function to be interpolated.\n        v(k) = alpha + beta / (1 + gamma * k^2)\n        \"\"\"\n        return alpha + beta / (1.0 + gamma * np.power(k, 2))\n\n    # Define the four test cases from the problem statement\n    # Each tuple is (n, m, grid_type)\n    # grid_type 'equidistant': m points on [-1, 1]\n    # grid_type 'nodes': m=n points, evaluation grid is the interpolation nodes\n    test_cases = [\n        (9, 1001, 'equidistant'),    # Case A\n        (17, 1001, 'equidistant'),   # Case B\n        (25, 1001, 'equidistant'),   # Case C\n        (17, 17, 'nodes'),           # Case D\n    ]\n\n    all_results = []\n    \n    for n, m, grid_type in test_cases:\n        # Step 1: Generate interpolation data\n        # n equally spaced nodes on the closed interval [-1, 1]\n        k_nodes = np.linspace(-1.0, 1.0, n)\n        # Observed values y_i = v(k_i)\n        y_nodes = v(k_nodes)\n\n        # Step 2: Construct the interpolants\n        # p_n(k): unique polynomial interpolant of degree at most n-1\n        # Using Barycentric form for numerical stability\n        p_n = BarycentricInterpolator(k_nodes, y_nodes)\n\n        # s_n(k): natural cubic spline interpolant\n        # bc_type='natural' sets the second derivatives at endpoints to zero\n        s_n = CubicSpline(k_nodes, y_nodes, bc_type='natural')\n\n        # Step 3: Define the evaluation grid\n        if grid_type == 'equidistant':\n            x_grid = np.linspace(-1.0, 1.0, m)\n        elif grid_type == 'nodes':\n            x_grid = k_nodes\n        else:\n            raise ValueError(\"Invalid grid_type specified.\")\n\n        # Step 4: Evaluate the true function and interpolants on the grid\n        v_true = v(x_grid)\n        p_n_vals = p_n(x_grid)\n        s_n_vals = s_n(x_grid)\n        \n        # Step 5: Compute errors\n        errors_p = p_n_vals - v_true\n        errors_s = s_n_vals - v_true\n\n        # Step 6: Calculate the required error metrics\n        # RMSE\n        rmse_p = np.sqrt(np.mean(np.square(errors_p)))\n        rmse_s = np.sqrt(np.mean(np.square(errors_s)))\n        \n        # MAX\n        max_p = np.max(np.abs(errors_p))\n        max_s = np.max(np.abs(errors_s))\n\n        # Store the four computed quantities for the current case\n        case_results = [rmse_p, rmse_s, max_p, max_s]\n        all_results.append(case_results)\n\n    # Final Output Formatting:\n    # Build a list of strings, where each string represents an inner list, e.g., \"[r1,r2,r3,r4]\"\n    results_as_strings = [\n        f\"[{','.join(map(str, res))}]\" for res in all_results\n    ]\n    \n    # Join the list of strings with commas and enclose in the outermost brackets\n    final_output = f\"[{','.join(results_as_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```"
        }
    ]
}