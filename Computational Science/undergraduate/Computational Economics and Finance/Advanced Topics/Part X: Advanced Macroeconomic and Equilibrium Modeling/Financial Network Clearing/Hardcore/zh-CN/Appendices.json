{
    "hands_on_practices": [
        {
            "introduction": "掌握金融网络清算的第一步是理解在系统承压时如何计算最终支付。本练习 () 将指导您直接应用 Eisenberg-Noe 模型来确定清算支付向量。通过分析对银行间负债进行统一削减（haircut）的影响，您将获得模型核心机制的实践经验，并了解政策参数如 $\\alpha$ 如何直接影响系统性偿付能力。",
            "id": "2392822",
            "problem": "考虑一个包含 $2$ 家银行（索引为 $i \\in \\{1,2\\}$）和一个社会节点的 Eisenberg–Noe 金融网络。设外部资产为 $x = (x_{1}, x_{2}) = (2, 1)$。名义银行间负债由矩阵 $L$ 给出，其元素为 $L_{12} = 1$ 和 $L_{21} = 2$（且 $L_{11} = L_{22} = 0$）。每家银行还对社会负有债务：$l_{10} = 1$ 和 $l_{20} = 1$。对银行间负债应用参数为 $\\alpha$（其中 $0  \\alpha  1$）的统一减记，因此银行间负债变为 $(1-\\alpha) L$，而 $l_{10}$、$l_{20}$ 和 $x$ 保持不变。\n\n对于每家银行 $i \\in \\{1,2\\}$，减记后的总名义债务为\n$$\\bar{p}_{1}(\\alpha) = (1 - \\alpha)L_{12} + l_{10}, \\quad \\bar{p}_{2}(\\alpha) = (1 - \\alpha)L_{21} + l_{20}.$$\n定义相对负债矩阵 $\\Pi(\\alpha)$，对于银行间联系（$j \\in \\{1,2\\}$），其元素为 $\\Pi_{ij}(\\alpha) = \\frac{L'_{ij}(\\alpha)}{\\bar{p}_{i}(\\alpha)}$；对于对社会联系，其元素为 $\\Pi_{i0}(\\alpha) = \\frac{l_{i0}}{\\bar{p}_{i}(\\alpha)}$，其中 $L'(\\alpha) = (1 - \\alpha)L$ 且当 $i=1$ 时 $l_{i0} = l_{10}$，当 $i=2$ 时 $l_{i0} = l_{20}$。Eisenberg–Noe 清算支付向量 $p^{*}(\\alpha) \\in \\mathbb{R}^{2}_{+}$ 是满足有限责任和按比例分配原则的任意不动点，即：\n$$p^{*}(\\alpha) = \\min\\big(\\bar{p}(\\alpha), \\, x + \\Pi(\\alpha)^{\\top} p^{*}(\\alpha)\\big),$$\n其中最小值为逐元素取值。\n\n显式计算 $p^{*}(\\alpha)$ 作为 $\\alpha$ 的函数。以 $\\alpha$ 表示你的最终答案，形式为一个 $1 \\times 2$ 的行向量。无需四舍五入。",
            "solution": "在尝试任何解答之前，需要对问题陈述进行验证。\n\n**第1步：提取已知条件**\n- 银行数量：$2$，索引为 $i \\in \\{1, 2\\}$。\n- 外部资产向量：$x = (x_1, x_2) = (2, 1)$。\n- 名义银行间负债矩阵：$L$，其中 $L_{12} = 1$，$L_{21} = 2$，且 $L_{11} = L_{22} = 0$。\n- 对社会的负债：$l_{10} = 1$，$l_{20} = 1$。\n- 减记参数：$\\alpha$，其中 $0  \\alpha  1$。\n- 减记后银行间负债：$L'(\\alpha) = (1-\\alpha)L$。\n- 总名义债务向量 $\\bar{p}(\\alpha) = (\\bar{p}_1(\\alpha), \\bar{p}_2(\\alpha))$：\n  $\\bar{p}_1(\\alpha) = (1 - \\alpha)L_{12} + l_{10}$\n  $\\bar{p}_2(\\alpha) = (1 - \\alpha)L_{21} + l_{20}$\n- 相对负债矩阵 $\\Pi(\\alpha)$：对于银行间联系（$j \\in \\{1,2\\}$），$\\Pi_{ij}(\\alpha) = \\frac{L'_{ij}(\\alpha)}{\\bar{p}_i(\\alpha)}$；对于对社会联系，$\\Pi_{i0}(\\alpha) = \\frac{l_{i0}}{\\bar{p}_i(\\alpha)}$。\n- 清算支付向量 $p^*(\\alpha)$，是以下方程的一个不动点：\n  $p^*(\\alpha) = \\min\\big(\\bar{p}(\\alpha), \\, x + \\Pi(\\alpha)^{\\top} p^*(\\alpha)\\big)$，其中最小值为逐元素取值。\n\n**第2步：使用提取的已知条件进行验证**\n该问题具有科学依据，提法恰当且客观。这是金融网络清算领域的一个标准练习，基于已建立的 Eisenberg-Noe 模型。求解所需的所有数据和定义均已提供，并且它们内部一致。没有违反科学原理、数学逻辑或事实准确性的地方。该问题是可形式化和可解的。\n\n**结论**\n该问题被认定为有效。将构建一个解。\n\n**求解推导**\n任务是找到清算支付向量 $p^*(\\alpha) = \\begin{pmatrix} p_1^*(\\alpha) \\\\ p_2^*(\\alpha) \\end{pmatrix}$，它是给定方程的一个不动点。\n\n首先，我们用给定的参数 $\\alpha$ 来表示模型的各个组成部分。\n外部资产向量为 $x = \\begin{pmatrix} 2 \\\\ 1 \\end{pmatrix}$。\n每家银行的总名义债务为：\n$\\bar{p}_1(\\alpha) = (1-\\alpha)L_{12} + l_{10} = (1-\\alpha)(1) + 1 = 2-\\alpha$。\n$\\bar{p}_2(\\alpha) = (1-\\alpha)L_{21} + l_{20} = (1-\\alpha)(2) + 1 = 3-2\\alpha$。\n所以，总名义债务向量为 $\\bar{p}(\\alpha) = \\begin{pmatrix} 2-\\alpha \\\\ 3-2\\alpha \\end{pmatrix}$。\n\n银行 $i$ 从系统中收到的收入是向量 $\\Pi(\\alpha)^{\\top} p^*(\\alpha)$ 的第 $i$ 个分量。该分量是从其他银行收到的支付的总和，按相对负债加权。银行 $i$ 从银行 $j$ 获得的收入是 $p_j^*(\\alpha) \\frac{L'_{ji}(\\alpha)}{\\bar{p}_j(\\alpha)}$。\n令 $\\hat{\\Pi}(\\alpha)$ 表示相对负债矩阵的银行间部分，其元素为 $\\hat{\\Pi}_{ij}(\\alpha) = \\frac{(1-\\alpha)L_{ij}}{\\bar{p}_i(\\alpha)}$。\n银行间收入向量则为 $\\hat{\\Pi}(\\alpha)^{\\top}p^*(\\alpha)$。矩阵 $\\hat{\\Pi}(\\alpha)$ 为：\n$$ \\hat{\\Pi}(\\alpha) = \\begin{pmatrix} 0  \\frac{1-\\alpha}{2-\\alpha} \\\\ \\frac{2(1-\\alpha)}{3-2\\alpha}  0 \\end{pmatrix} $$\n其转置矩阵为：\n$$ \\hat{\\Pi}(\\alpha)^{\\top} = \\begin{pmatrix} 0  \\frac{2(1-\\alpha)}{3-2\\alpha} \\\\ \\frac{1-\\alpha}{2-\\alpha}  0 \\end{pmatrix} $$\n不动点方程可以为每个分量 $p_i^* = p_i^*(\\alpha)$ 写出：\n$$p_1^* = \\min\\left(2-\\alpha, 2 + \\frac{2(1-\\alpha)}{3-2\\alpha}p_2^*\\right)$$\n$$p_2^* = \\min\\left(3-2\\alpha, 1 + \\frac{1-\\alpha}{2-\\alpha}p_1^*\\right)$$\n\nEisenberg-Noe 清算向量的规范解是映射 $F(p) = \\min(\\bar{p}, x + \\hat{\\Pi}^{\\top} p)$ 的最大不动点。这可以使用虚拟违约算法找到，该算法从初始猜测 $p^{(0)} = \\bar{p}(\\alpha)$ 开始，并迭代 $p^{(k+1)} = F(p^{(k)})$。\n\n我们初始化迭代：\n$p^{(0)} = \\bar{p}(\\alpha) = \\begin{pmatrix} 2-\\alpha \\\\ 3-2\\alpha \\end{pmatrix}$。\n\n计算第一次迭代 $p^{(1)}$：\n$$ p_1^{(1)} = \\min\\left(2-\\alpha, 2 + \\frac{2(1-\\alpha)}{3-2\\alpha}p_2^{(0)}\\right) = \\min\\left(2-\\alpha, 2 + \\frac{2(1-\\alpha)}{3-2\\alpha}(3-2\\alpha)\\right) $$\n$$ p_1^{(1)} = \\min(2-\\alpha, 2 + 2(1-\\alpha)) = \\min(2-\\alpha, 4-2\\alpha) $$\n对于给定范围 $0  \\alpha  1$，我们有 $4-2\\alpha > 2-\\alpha$。因此，$p_1^{(1)} = 2-\\alpha$。\n\n$$ p_2^{(1)} = \\min\\left(3-2\\alpha, 1 + \\frac{1-\\alpha}{2-\\alpha}p_1^{(0)}\\right) = \\min\\left(3-2\\alpha, 1 + \\frac{1-\\alpha}{2-\\alpha}(2-\\alpha)\\right) $$\n$$ p_2^{(1)} = \\min(3-2\\alpha, 1 + (1-\\alpha)) = \\min(3-2\\alpha, 2-\\alpha) $$\n对于 $0  \\alpha  1$，我们有 $3-2\\alpha > 2-\\alpha$。因此，$p_2^{(1)} = 2-\\alpha$。\n\n所以，第一次迭代得出 $p^{(1)} = \\begin{pmatrix} 2-\\alpha \\\\ 2-\\alpha \\end{pmatrix}$。\n\n现在，我们使用 $p^{(1)}$ 计算第二次迭代 $p^{(2)}$：\n$$ p_1^{(2)} = \\min\\left(2-\\alpha, 2 + \\frac{2(1-\\alpha)}{3-2\\alpha}p_2^{(1)}\\right) = \\min\\left(2-\\alpha, 2 + \\frac{2(1-\\alpha)(2-\\alpha)}{3-2\\alpha}\\right) $$\n在 $0  \\alpha  1$ 的范围内，项 $\\frac{2(1-\\alpha)(2-\\alpha)}{3-2\\alpha}$ 是严格为正的。因此，$2 + \\frac{2(1-\\alpha)(2-\\alpha)}{3-2\\alpha} > 2-\\alpha$。这意味着 $p_1^{(2)} = 2-\\alpha$。\n\n$$ p_2^{(2)} = \\min\\left(3-2\\alpha, 1 + \\frac{1-\\alpha}{2-\\alpha}p_1^{(1)}\\right) = \\min\\left(3-2\\alpha, 1 + \\frac{1-\\alpha}{2-\\alpha}(2-\\alpha)\\right) $$\n$$ p_2^{(2)} = \\min(3-2\\alpha, 2-\\alpha) $$\n和之前一样，对于 $0  \\alpha  1$，我们有 $3-2\\alpha > 2-\\alpha$。这意味着 $p_2^{(2)} = 2-\\alpha$。\n\n第二次迭代得出 $p^{(2)} = \\begin{pmatrix} 2-\\alpha \\\\ 2-\\alpha \\end{pmatrix}$。\n由于 $p^{(2)} = p^{(1)}$，算法已收敛到一个不动点。\n这个向量 $p^*(\\alpha) = \\begin{pmatrix} 2-\\alpha \\\\ 2-\\alpha \\end{pmatrix}$ 就是清算向量。\n\n这个解对应于银行1有偿付能力（$p_1^*(\\alpha) = \\bar{p}_1(\\alpha) = 2-\\alpha$）而银行2违约（对于 $\\alpha  1$，$p_2^*(\\alpha) = 2-\\alpha  3-2\\alpha = \\bar{p}_2(\\alpha)$）的情形。",
            "answer": "$$ \\boxed{ \\begin{pmatrix} 2 - \\alpha  2 - \\alpha \\end{pmatrix} } $$"
        },
        {
            "introduction": "现实世界中的政策决策通常涉及如何在有限的资源下做出最优选择以实现最大效果。本实践问题 () 将您置于监管者的角色，需要决定救助策略，迫使您在支持最大的银行与一个规模较小但关联更紧密的银行之间进行比较。通过实施一个计算解决方案，您将实证地发现，在网络中，规模并非衡量重要性的唯一标准，而互联性可能是决定系统稳定性的更关键因素。",
            "id": "2392815",
            "problem": "给定一个金融系统，其中有 $n$ 家银行，该系统在 Eisenberg–Noe (EN) 框架中表示。每家银行 $i \\in \\{1,\\dots,n\\}$ 对所有债权人（包括银行间和外部债权人）的总名义负债为 $\\bar{p}_i \\ge 0$。设 $L \\in \\mathbb{R}_{\\ge 0}^{n \\times n}$ 为银行间名义负债矩阵，其中 $L_{ij}$ 表示银行 $i$ 欠银行 $j$ 的名义金额。定义相对负债矩阵 $\\Pi \\in \\mathbb{R}_{\\ge 0}^{n \\times n}$ 如下\n$$\n\\pi_{ij} = \\begin{cases}\n\\dfrac{L_{ij}}{\\bar{p}_i},  \\text{if } \\bar{p}_i  0,\\\\\n0,  \\text{if } \\bar{p}_i = 0.\n\\end{cases}\n$$\n设 $x \\in \\mathbb{R}_{\\ge 0}^n$ 表示外部资产（禀赋）向量。Eisenberg–Noe 清算支付向量 $p \\in \\mathbb{R}_{\\ge 0}^n$ 被定义为求解以下方程的最大不动点，该求解是按分量进行的：\n$$\np_i = \\min\\left\\{\\bar{p}_i,\\ x_i + \\sum_{j=1}^n \\pi_{ji} p_j\\right\\} \\quad \\text{for all } i \\in \\{1,\\dots,n\\},\n$$\n或以向量形式表示为：\n$$\np = \\min\\left\\{\\bar{p},\\ x + \\Pi^\\top p\\right\\},\n$$\n其中最小化是按分量进行的。考虑一个定向救助政策，该政策将一笔非负预算 $b$ 注入到单一银行 $k$ 中，这被建模为将 $b$ 加到 $x_k$ 上，同时保持所有其他 $x_i$ 不变。\n\n对于下面的每个测试用例，您必须计算差值\n$$\n\\Delta = \\left(\\sum_{i=1}^n p_i^{(\\text{small})}\\right) - \\left(\\sum_{i=1}^n p_i^{(\\text{large})}\\right),\n$$\n其中，$p^{(\\text{small})}$ 是当全部预算 $b$ 注入到指定的规模较小、连接更紧密的银行时的清算支付向量；而 $p^{(\\text{large})}$ 是当全部预算 $b$ 注入到按总名义负债 $\\bar{p}_i$ 计为最大的银行时的清算支付向量。在每个测试中，我们都为您提供了最大银行以及规模较小、连接更紧密的银行的明确索引。您的程序必须为测试套件生成 $\\Delta$ 值的列表，四舍五入到六位小数。\n\n所有输入均为无量纲的货币量；不涉及物理单位。\n\n测试套件：\n- 测试用例 1：\n    - $n = 4$。\n    - $\\bar{p} = (10, 6, 6, 6)$。\n    - $x = (1, 1, 1, 1)$。\n    - $L = \\begin{pmatrix}\n    0  0  0  0\\\\\n    0  0  3  3\\\\\n    1  0  0  0\\\\\n    1  0  0  0\n    \\end{pmatrix}$。\n    - 预算 $b = 2$。\n    - 最大银行的索引 $i_{\\text{large}} = 0$。\n    - 规模较小、连接更紧密的银行的索引 $i_{\\text{small}} = 1$。\n- 测试用例 2：\n    - $n = 3$。\n    - $\\bar{p} = (5, 4, 4)$。\n    - $x = (0.5, 0.5, 0.5)$。\n    - $L = \\begin{pmatrix}\n    0  0  0\\\\\n    0  0  2\\\\\n    0  1  0\n    \\end{pmatrix}$。\n    - 预算 $b = 0$。\n    - 最大银行的索引 $i_{\\text{large}} = 0$。\n    - 规模较小、连接更紧密的银行的索引 $i_{\\text{small}} = 1$。\n- 测试用例 3：\n    - $n = 3$。\n    - $\\bar{p} = (8, 3, 3)$。\n    - $x = (1, 0.5, 0.5)$。\n    - $L = \\begin{pmatrix}\n    0  3  3\\\\\n    0  0  0\\\\\n    0  0  0\n    \\end{pmatrix}$。\n    - 预算 $b = 2$。\n    - 最大银行的索引 $i_{\\text{large}} = 0$。\n    - 规模较小、连接更紧密的银行的索引 $i_{\\text{small}} = 1$。\n\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个条目等于相应测试用例的 $\\Delta$ 值，并四舍五入到六位小数（例如，$[\\,\\delta_1,\\delta_2,\\delta_3\\,]$）。",
            "solution": "问题陈述已经过评估，被认为是有效的。它是自洽的，科学上基于已建立的金融网络清算 Eisenberg-Noe 模型，并且在数学上是适定的。唯一解所需的所有数据均已提供，且没有内部矛盾。\n\n核心任务是计算 Eisenberg-Noe 清算支付向量 $p$，它被定义为以下方程的最大不动点：\n$$\np = \\min\\left\\{\\bar{p},\\ x + \\Pi^\\top p\\right\\}\n$$\n其中最小化是按分量进行的。向量 $\\bar{p}$ 代表总名义负债，$x$ 是外部资产向量，而 $\\Pi$ 是相对银行间负债矩阵。\n\n为求解此问题，我们定义一个算子 $F: \\mathbb{R}^n \\to \\mathbb{R}^n$ 如下：\n$$\nF(p) = \\min\\left\\{\\bar{p},\\ x + \\Pi^\\top p\\right\\}\n$$\n清算向量 $p$ 的搜索范围被限制在紧集 $[0, \\bar{p}]$ 内，即超矩形 $\\{p \\in \\mathbb{R}^n \\mid 0 \\le p_i \\le \\bar{p}_i \\text{ for all } i\\}$。这个集合在赋予了分量偏序关系后，构成一个完备格。\n\n算子 $F(p)$ 在这个格上是单调的。也就是说，如果按分量比较 $p^{(a)} \\le p^{(b)}$，那么 $x + \\Pi^\\top p^{(a)} \\le x + \\Pi^\\top p^{(b)}$，因为 $\\Pi^\\top$ 的所有元素都是非负的。因此，$F(p^{(a)}) = \\min\\{\\bar{p}, x + \\Pi^\\top p^{(a)}\\} \\le \\min\\{\\bar{p}, x + \\Pi^\\top p^{(b)}\\} = F(p^{(b)})$。\n\n根据 Tarski 不动点定理，完备格上的任何单调函数都存在一个不动点集，该集合本身也是一个非空的完备格。这保证了最大不动点的存在。这个最大不动点可以通过一个简单的迭代算法找到。我们用格的最大元素 $p^{(0)} = \\bar{p}$ 来初始化迭代。然后通过以下方式生成序列：\n$$\np^{(k+1)} = F(p^{(k)}) = \\min\\left\\{\\bar{p},\\ x + \\Pi^\\top p^{(k)}\\right\\}\n$$\n由于 $p^{(1)} = F(p^{(0)}) \\le p^{(0)}$ 且 $F$ 是单调的，序列 $\\{p^{(k)}\\}_{k \\ge 0}$ 是非增的，并以零向量为下界。因此，它保证收敛到一个不动点，并且由于它从格的顶部开始，它会收敛到最大不动点。\n\n解决每个测试用例的总体步骤如下：\n\n1.  给定参数 $n, \\bar{p}, x, L, b, i_{\\text{large}}, i_{\\text{small}}$，首先根据其定义计算相对负债矩阵 $\\Pi$：\n    $$\n    \\pi_{ij} = \\begin{cases}\n    \\dfrac{L_{ij}}{\\bar{p}_i},  \\text{if } \\bar{p}_i  0,\\\\\n    0,  \\text{if } \\bar{p}_i = 0.\n    \\end{cases}\n    $$\n2.  根据救助目标，为外部资产向量定义两种情景。设 $e_k$ 是在索引 $k$ 处为 1，其他位置为 0 的标准基向量。\n    - 对规模较小的银行进行救助：$x^{(\\text{small})} = x + b \\cdot e_{i_{\\text{small}}}$。\n    - 对最大的银行进行救助：$x^{(\\text{large})} = x + b \\cdot e_{i_{\\text{large}}}$。\n3.  对于每种情景，计算相应的清算向量：\n    - 从 $p = \\bar{p}$ 开始，通过迭代 $p \\gets \\min\\{\\bar{p}, x^{(\\text{small})} + \\Pi^\\top p\\}$ 来计算 $p^{(\\text{small})}$，直到向量 $p$ 收敛。\n    - 从 $p = \\bar{p}$ 开始，通过迭代 $p \\gets \\min\\{\\bar{p}, x^{(\\text{large})} + \\Pi^\\top p\\}$ 来计算 $p^{(\\text{large})}$，直到向量 $p$ 收敛。\n4.  为每个得到的清算向量计算支付总额：\n    $$\n    S_{\\text{small}} = \\sum_{i=1}^n p_i^{(\\text{small})} \\quad \\text{and} \\quad S_{\\text{large}} = \\sum_{i=1}^n p_i^{(\\text{large})}\n    $$\n5.  最后，计算所需的差值 $\\Delta = S_{\\text{small}} - S_{\\text{large}}$。\n\n这个结构化、有理论依据的算法将被实施，以找到每个指定测试用例的数值解。迭代的收敛准则是当连续向量之间的变化可以忽略不计时，例如，当差值的上确界范数 $\\|p^{(k+1)} - p^{(k)}\\|_\\infty$ 小于一个很小的容差 $\\epsilon  0$ 时。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_clearing_vector(p_bar: np.ndarray, x: np.ndarray, Pi: np.ndarray) - np.ndarray:\n    \"\"\"\n    Computes the Eisenberg-Noe clearing payments vector.\n\n    This function finds the greatest fixed point of the equation:\n    p = min(p_bar, x + Pi.T @ p)\n    using a convergent iterative method starting from p = p_bar.\n\n    Args:\n        p_bar: Vector of total nominal liabilities.\n        x: Vector of external assets.\n        Pi: Relative liabilities matrix.\n\n    Returns:\n        The clearing payments vector p.\n    \"\"\"\n    n = len(p_bar)\n    # Initialize with the maximal element of the lattice [0, p_bar].\n    p = p_bar.copy()\n    \n    # Iterate until convergence.\n    # The sequence is non-increasing and bounded below, so it must converge.\n    for _ in range(1000):  # A sufficiently large number of iterations for convergence\n        p_prev = p.copy()\n        p = np.minimum(p_bar, x + Pi.T @ p_prev)\n        # Check for convergence using a small tolerance.\n        if np.allclose(p, p_prev, rtol=1e-12, atol=1e-12):\n            break\n            \n    return p\n\ndef solve():\n    \"\"\"\n    Solves the problem for the given test suite.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1\n        {\n            \"n\": 4,\n            \"p_bar\": np.array([10.0, 6.0, 6.0, 6.0]),\n            \"x\": np.array([1.0, 1.0, 1.0, 1.0]),\n            \"L\": np.array([\n                [0.0, 0.0, 0.0, 0.0],\n                [0.0, 0.0, 3.0, 3.0],\n                [1.0, 0.0, 0.0, 0.0],\n                [1.0, 0.0, 0.0, 0.0]\n            ]),\n            \"b\": 2.0,\n            \"i_large\": 0,\n            \"i_small\": 1,\n        },\n        # Test case 2\n        {\n            \"n\": 3,\n            \"p_bar\": np.array([5.0, 4.0, 4.0]),\n            \"x\": np.array([0.5, 0.5, 0.5]),\n            \"L\": np.array([\n                [0.0, 0.0, 0.0],\n                [0.0, 0.0, 2.0],\n                [0.0, 1.0, 0.0]\n            ]),\n            \"b\": 0.0,\n            \"i_large\": 0,\n            \"i_small\": 1,\n        },\n        # Test case 3\n        {\n            \"n\": 3,\n            \"p_bar\": np.array([8.0, 3.0, 3.0]),\n            \"x\": np.array([1.0, 0.5, 0.5]),\n            \"L\": np.array([\n                [0.0, 3.0, 3.0],\n                [0.0, 0.0, 0.0],\n                [0.0, 0.0, 0.0]\n            ]),\n            \"b\": 2.0,\n            \"i_large\": 0,\n            \"i_small\": 1,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        n = case[\"n\"]\n        p_bar = case[\"p_bar\"]\n        x = case[\"x\"]\n        L = case[\"L\"]\n        b = case[\"b\"]\n        i_large = case[\"i_large\"]\n        i_small = case[\"i_small\"]\n\n        # Calculate the relative liabilities matrix Pi\n        Pi = np.zeros((n, n))\n        for i in range(n):\n            if p_bar[i]  0:\n                Pi[i, :] = L[i, :] / p_bar[i]\n\n        # Scenario 1: Bailout injected into the smaller bank\n        x_small = x.copy()\n        x_small[i_small] += b\n        p_small = compute_clearing_vector(p_bar, x_small, Pi)\n        total_payments_small = np.sum(p_small)\n\n        # Scenario 2: Bailout injected into the largest bank\n        x_large = x.copy()\n        x_large[i_large] += b\n        p_large = compute_clearing_vector(p_bar, x_large, Pi)\n        total_payments_large = np.sum(p_large)\n        \n        # Calculate the difference delta\n        delta = total_payments_small - total_payments_large\n        results.append(f\"{delta:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "金融监管机构的一个核心问题不仅是如何应对危机，更是如何有效地应对。这项高级练习 () 将救助问题重构为一个优化问题：找到为确保网络中每个机构都能履行其义务所需的最小总资本注入。通过解决这个问题，您将学会如何运用清算框架，不仅用于预测，更用于设计具有成本效益的政策干预，并精确量化系统的总体资本缺口。",
            "id": "2392858",
            "problem": "考虑一个由$n$个机构组成的金融系统，该系统在Eisenberg和Noe的框架下建模。设 $L \\in \\mathbb{R}_{\\ge 0}^{n \\times n}$ 为名义银行间负债矩阵，其中 $L_{ij}$ 表示机构 $i$ 对机构 $j$ 的名义负债。定义总名义债务向量 $\\bar{p} \\in \\mathbb{R}_{\\ge 0}^{n}$ 为 $\\bar{p}_i = \\sum_{j=1}^n L_{ij}$，并定义相对负债矩阵 $\\Pi \\in \\mathbb{R}_{\\ge 0}^{n \\times n}$ 为\n$$\n\\pi_{ij} = \n\\begin{cases}\n\\dfrac{L_{ij}}{\\bar{p}_i},  \\text{若 } \\bar{p}_i  0,\\\\[6pt]\n0,  \\text{若 } \\bar{p}_i = 0.\n\\end{cases}\n$$\n设 $e \\in \\mathbb{R}_{\\ge 0}^n$ 表示外部资产向量。一个清算支付向量 $p \\in \\mathbb{R}_{\\ge 0}^n$ 满足Eisenberg–Noe清算条件\n$$\np = \\min\\left(\\bar{p}, \\, \\Pi^\\top p + e\\right),\n$$\n其中最小值为逐分量取值。如果存在一个清算向量 $p$ 使得 $p = \\bar{p}$，则称该系统被拯救。\n\n监管机构可以向外部资产注入一个非负的救助向量 $\\Delta e \\in \\mathbb{R}_{\\ge 0}^n$，从而得到总外部资产 $e + \\Delta e$。考虑这样一个优化问题：找到一个能够拯救系统同时最小化总救助资本的救助方案，即在系统被拯救的约束下，最小化 $\\sum_{i=1}^n \\Delta e_i$。\n\n您的任务是，对于下方的每个测试案例，计算出最小总救助资本 $\\sum_{i=1}^n \\Delta e_i$（以十进制数表示），其要求是救助后的系统需满足上述“被拯救”的定义。\n\n测试套件：\n- 案例A ($n=3$):\n  - 负债矩阵 $L$:\n    $$\n    L = \\begin{bmatrix}\n    0  50  0\\\\\n    0  0  40\\\\\n    30  0  0\n    \\end{bmatrix}.\n    $$\n  - 外部资产 $e$:\n    $$\n    e = \\begin{bmatrix}\n    10\\\\\n    5\\\\\n    5\n    \\end{bmatrix}.\n    $$\n- 案例B ($n=2$):\n  - 负债矩阵 $L$:\n    $$\n    L = \\begin{bmatrix}\n    0  10\\\\\n    0  0\n    \\end{bmatrix}.\n    $$\n  - 外部资产 $e$:\n    $$\n    e = \\begin{bmatrix}\n    10\\\\\n    0\n    \\end{bmatrix}.\n    $$\n- 案例C ($n=3$):\n  - 负债矩阵 $L$:\n    $$\n    L = \\begin{bmatrix}\n    0  10  0\\\\\n    0  0  0\\\\\n    0  20  0\n    \\end{bmatrix}.\n    $$\n  - 外部资产 $e$:\n    $$\n    e = \\begin{bmatrix}\n    0\\\\\n    0\\\\\n    0\n    \\end{bmatrix}.\n    $$\n- 案例D ($n=2$):\n  - 负债矩阵 $L$:\n    $$\n    L = \\begin{bmatrix}\n    0  50\\\\\n    50  0\n    \\end{bmatrix}.\n    $$\n  - 外部资产 $e$:\n    $$\n    e = \\begin{bmatrix}\n    0\\\\\n    0\n    \\end{bmatrix}.\n    $$\n\n答案规格：\n- 对于每个案例，将最小总救助资本 $\\sum_{i=1}^n \\Delta e_i$ 计算为单个实数（浮点数）。\n- 您的程序应生成单行输出，其中包含结果，格式为逗号分隔的十进制数列表，保留四位小数，并用方括号括起来，顺序为 $[\\text{案例A}, \\text{案例B}, \\text{案例C}, \\text{案例D}]$。\n\n不涉及物理单位。不涉及角度。不得使用百分比；所有量必须表示为十进制数。程序必须是自包含的，并且不得读取任何输入。",
            "solution": "问题陈述已经过严格验证，被认为是有效的。它科学地基于已建立的Eisenberg-Noe金融清算模型，在数学上是适定的、客观的，并为其解决提供了完整且一致的数据和定义。\n\n问题的核心是找到拯救金融系统所需的最小总救助资本 $\\sum_{i=1}^n \\Delta e_i$。注入资本 $\\Delta e$ 后，系统的总外部资产为 $e' = e + \\Delta e$。如果清算支付向量 $p$ 等于总名义债务向量 $\\bar{p}$，则系统被定义为“被拯救”。\n\n清算向量 $p$ 必须满足Eisenberg-Noe清算条件，加入救助后该条件为：\n$$\np = \\min\\left(\\bar{p}, \\, \\Pi^\\top p + e + \\Delta e\\right)\n$$\n为了使系统被拯救，向量 $p = \\bar{p}$ 必须是此方程的一个解。将 $p = \\bar{p}$ 代入该条件，可得：\n$$\n\\bar{p} = \\min\\left(\\bar{p}, \\, \\Pi^\\top \\bar{p} + e + \\Delta e\\right)\n$$\n这个向量方程成立的充分必要条件是它对每个分量 $i \\in \\{1, \\dots, n\\}$ 都成立：\n$$\n\\bar{p}_i = \\min\\left(\\bar{p}_i, \\, (\\Pi^\\top \\bar{p})_i + e_i + \\Delta e_i\\right)\n$$\n这等价于以下不等式组：\n$$\n\\bar{p}_i \\le (\\Pi^\\top \\bar{p})_i + e_i + \\Delta e_i\n$$\n监管机构的任务是找到一个满足此条件的非负救助向量 $\\Delta e \\in \\mathbb{R}_{\\ge 0}^n$，同时最小化总支出 $\\sum_{i=1}^n \\Delta e_i$。\n\n对关于 $\\Delta e_i$ 的不等式进行移项，我们得到每个机构所需救助的下界：\n$$\n\\Delta e_i \\ge \\bar{p}_i - (\\Pi^\\top \\bar{p})_i - e_i\n$$\n由于救助出资 $\\Delta e_i$ 也必须是非负的，约束变为：\n$$\n\\Delta e_i \\ge \\max\\left(0, \\, \\bar{p}_i - (\\Pi^\\top \\bar{p})_i - e_i\\right)\n$$\n为了最小化总和 $\\sum_{i=1}^n \\Delta e_i$，我们必须为每个 $\\Delta e_i$ 选择允许的最小值，因为这些约束是独立的。因此，对机构 $i$ 的最优救助为：\n$$\n\\Delta e_i^* = \\max\\left(0, \\, \\bar{p}_i - (\\Pi^\\top \\bar{p})_i - e_i\\right)\n$$\n项 $(\\Pi^\\top \\bar{p})_i$ 表示在假设所有交易对手均履行全部债务的情况下，机构 $i$ 应收的总资产。我们来分析这一项：\n$$\n(\\Pi^\\top \\bar{p})_i = \\sum_{j=1}^n (\\Pi^\\top)_{ij} \\bar{p}_j = \\sum_{j=1}^n \\pi_{ji} \\bar{p}_j\n$$\n根据定义，如果 $\\bar{p}_j  0$，则 $\\pi_{ji} = L_{ji} / \\bar{p}_j$；如果 $\\bar{p}_j = 0$，则 $\\pi_{ji} = 0$。\n- 如果 $\\bar{p}_j  0$，则求和中的项为 $(L_{ji} / \\bar{p}_j) \\bar{p}_j = L_{ji}$。\n- 如果 $\\bar{p}_j = 0$，则 $\\sum_{k=1}^n L_{jk} = 0$。由于负债是非负的（$L_{jk} \\ge 0$），这意味着对所有 $k$ 都有 $L_{jk} = 0$，所以 $L_{ji}=0$。求和中的项为 $\\pi_{ji} \\bar{p}_j = 0 \\cdot 0 = 0$。因此，该项也等于 $L_{ji}$。\n这严格证明了对所有 $j$ 都有 $\\pi_{ji} \\bar{p}_j = L_{ji}$。因此，该求和简化为：\n$$\n(\\Pi^\\top \\bar{p})_i = \\sum_{j=1}^n L_{ji}\n$$\n这正是负债矩阵 $L$ 的第 $i$ 列之和，代表应付给机构 $i$ 的总名义付款。\n在救助之前，机构 $i$ 的资本缺口是其债务超过其总资产（假设从其他机构获得全额支付）的部分：\n$$\ns_i = \\underbrace{\\sum_{j=1}^n L_{ij}}_{\\text{债务}} - \\left( \\underbrace{\\sum_{j=1}^n L_{ji}}_{\\text{银行间资产}} + \\underbrace{e_i}_{\\text{外部资产}} \\right)\n$$\n最小总救助资本是所有机构的正缺口之和：\n$$\n\\sum_{i=1}^n \\Delta e_i^* = \\sum_{i=1}^n \\max(0, s_i)\n$$\n现在我们将此公式应用于每个测试案例。\n\n**案例A**\n- 负债 $L = \\begin{bmatrix} 0  50  0 \\\\ 0  0  40 \\\\ 30  0  0 \\end{bmatrix}$，外部资产 $e = \\begin{bmatrix} 10 \\\\ 5 \\\\ 5 \\end{bmatrix}$。\n- 债务（$L$ 的行和）： $\\bar{p} = \\begin{bmatrix} 50 \\\\ 40 \\\\ 30 \\end{bmatrix}$。\n- 银行间资产（$L$ 的列和）： $\\begin{bmatrix} 30 \\\\ 50 \\\\ 40 \\end{bmatrix}$。\n- 缺口 $s_i = \\bar{p}_i - (\\sum_j L_{ji}) - e_i$:\n  - $s_1 = 50 - 30 - 10 = 10$\n  - $s_2 = 40 - 50 - 5 = -15$\n  - $s_3 = 30 - 40 - 5 = -15$\n- 救助 $\\Delta e_i^* = \\max(0, s_i)$:\n  - $\\Delta e_1^* = \\max(0, 10) = 10$\n  - $\\Delta e_2^* = \\max(0, -15) = 0$\n  - $\\Delta e_3^* = \\max(0, -15) = 0$\n- 最小总救助：$10 + 0 + 0 = 10$。\n\n**案例B**\n- 负债 $L = \\begin{bmatrix} 0  10 \\\\ 0  0 \\end{bmatrix}$，外部资产 $e = \\begin{bmatrix} 10 \\\\ 0 \\end{bmatrix}$。\n- 债务（$L$ 的行和）： $\\bar{p} = \\begin{bmatrix} 10 \\\\ 0 \\end{bmatrix}$。\n- 银行间资产（$L$ 的列和）： $\\begin{bmatrix} 0 \\\\ 10 \\end{bmatrix}$。\n- 缺口 $s_i = \\bar{p}_i - (\\sum_j L_{ji}) - e_i$:\n  - $s_1 = 10 - 0 - 10 = 0$\n  - $s_2 = 0 - 10 - 0 = -10$\n- 救助 $\\Delta e_i^* = \\max(0, s_i)$:\n  - $\\Delta e_1^* = \\max(0, 0) = 0$\n  - $\\Delta e_2^* = \\max(0, -10) = 0$\n- 最小总救助：$0 + 0 = 0$。该系统已经具有偿付能力。\n\n**案例C**\n- 负债 $L = \\begin{bmatrix} 0  10  0 \\\\ 0  0  0 \\\\ 0  20  0 \\end{bmatrix}$，外部资产 $e = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\end{bmatrix}$。\n- 债务（$L$ 的行和）： $\\bar{p} = \\begin{bmatrix} 10 \\\\ 0 \\\\ 20 \\end{bmatrix}$。\n- 银行间资产（$L$ 的列和）： $\\begin{bmatrix} 0 \\\\ 30 \\\\ 0 \\end{bmatrix}$。\n- 缺口 $s_i = \\bar{p}_i - (\\sum_j L_{ji}) - e_i$:\n  - $s_1 = 10 - 0 - 0 = 10$\n  - $s_2 = 0 - 30 - 0 = -30$\n  - $s_3 = 20 - 0 - 0 = 20$\n- 救助 $\\Delta e_i^* = \\max(0, s_i)$:\n  - $\\Delta e_1^* = \\max(0, 10) = 10$\n  - $\\Delta e_2^* = \\max(0, -30) = 0$\n  - $\\Delta e_3^* = \\max(0, 20) = 20$\n- 最小总救助：$10 + 0 + 20 = 30$。\n\n**案例D**\n- 负债 $L = \\begin{bmatrix} 0  50 \\\\ 50  0 \\end{bmatrix}$，外部资产 $e = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}$。\n- 债务（$L$ 的行和）： $\\bar{p} = \\begin{bmatrix} 50 \\\\ 50 \\end{bmatrix}$。\n- 银行间资产（$L$ 的列和）： $\\begin{bmatrix} 50 \\\\ 50 \\end{bmatrix}$。\n- 缺口 $s_i = \\bar{p}_i - (\\sum_j L_{ji}) - e_i$:\n  - $s_1 = 50 - 50 - 0 = 0$\n  - $s_2 = 50 - 50 - 0 = 0$\n- 救助 $\\Delta e_i^* = \\max(0, s_i)$:\n  - $\\Delta e_1^* = \\max(0, 0) = 0$\n  - $\\Delta e_2^* = \\max(0, 0) = 0$\n- 最小总救助：$0 + 0 = 0$。该系统的债务被完全轧差。\n\n最终数值结果为：案例A为 $10.0$，案例B为 $0.0$，案例C为 $30.0$，案例D为 $0.0$。程序将按要求格式化这些结果。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the minimum total bailout capital for a series of financial network test cases\n    based on the Eisenberg-Noe model.\n    \"\"\"\n\n    test_cases = [\n        # Case A\n        {\n            \"L\": np.array([[0, 50, 0], [0, 0, 40], [30, 0, 0]], dtype=float),\n            \"e\": np.array([10, 5, 5], dtype=float)\n        },\n        # Case B\n        {\n            \"L\": np.array([[0, 10], [0, 0]], dtype=float),\n            \"e\": np.array([10, 0], dtype=float)\n        },\n        # Case C\n        {\n            \"L\": np.array([[0, 10, 0], [0, 0, 0], [0, 20, 0]], dtype=float),\n            \"e\": np.array([0, 0, 0], dtype=float)\n        },\n        # Case D\n        {\n            \"L\": np.array([[0, 50], [50, 0]], dtype=float),\n            \"e\": np.array([0, 0], dtype=float)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        L = case[\"L\"]\n        e = case[\"e\"]\n\n        # The condition for a \"saved\" system is that full nominal payments are a clearing vector.\n        # This requires that for each institution i, its total assets (assuming full payment from\n        # others) are greater than or equal to its total nominal obligations.\n        # Total Assets = Interbank Assets + External Assets\n        # Total Obligations = Interbank Liabilities\n        #\n        # Interbank assets for each institution are the column sums of L.\n        # Total nominal obligations for each institution are the row sums of L.\n        \n        # 1. Calculate total nominal obligations (p_bar), which are the row sums of L.\n        p_bar = np.sum(L, axis=1)\n\n        # 2. Calculate total interbank assets receivable, which are the column sums of L.\n        # This is equivalent to Pi^T * p_bar in the Eisenberg-Noe formulation.\n        interbank_assets = np.sum(L, axis=0)\n\n        # 3. Calculate the capital shortfall for each institution.\n        # Shortfall = Obligations - (Interbank Assets + External Assets)\n        shortfall = p_bar - interbank_assets - e\n\n        # 4. The minimum bailout for each institution is the positive part of its shortfall.\n        bailout_vector = np.maximum(0, shortfall)\n\n        # 5. The total minimum bailout is the sum of the individual required bailouts.\n        total_min_bailout = np.sum(bailout_vector)\n        \n        results.append(total_min_bailout)\n\n    # Print the final results in the specified format, rounded to four decimal places.\n    print(f\"[{','.join(f'{r:.4f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}