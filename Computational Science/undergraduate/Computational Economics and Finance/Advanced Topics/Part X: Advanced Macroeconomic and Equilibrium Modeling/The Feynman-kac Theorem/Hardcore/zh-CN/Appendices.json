{
    "hands_on_practices": [
        {
            "introduction": "费曼-卡茨定理的一个最直接的应用是计算依赖于随机过程的未来现金流的期望值。本练习将通过为一个遵循几何布朗运动的股票计算预期总股息，来构建这项基本技能。这个实践突出了如何利用费曼-卡茨定理的概率形式，将偏微分方程中的源项与未来现金流的期望直接联系起来。",
            "id": "2440775",
            "problem": "考虑一个在现实世界概率测度下，通过一维 Itô 扩散建模的股价过程。该过程遵循随机微分方程 $dX_t = \\mu X_t \\, dt + \\sigma X_t \\, dW_t$，其中 $X_t$ 是时间 $t$ 的股价，$\\mu$ 和 $\\sigma$ 是常数，而 $W_t$ 是标准布朗运动。该股票以瞬时速率 $f(X_t,t)$ 支付连续股息流，其公式为 $f(X_t,t) = a \\, e^{-\\kappa t} + q \\, X_t \\, e^{-\\lambda t}$，其中 $a$、$\\kappa$、$q$ 和 $\\lambda$ 是非负常数。将从当前时间 $t=0$ 到固定的时间视界 $T$ 所支付的预期总股息定义为以下泛函\n$$\nu(x_0,0) = \\mathbb{E}\\left[\\int_{0}^{T} f(X_t,t) \\, dt \\,\\bigg|\\, X_0 = x_0\\right].\n$$\n使用 Feynman–Kac 定理，为 $u(x,t)$ 必须满足的相应后向偏微分方程 (PDE) 问题建立公式，包括在 $t=T$ 时的终端条件。仅从 Itô 扩散、期望的线性性和 Feynman–Kac 定理的定义出发（不要假设任何关于 $u$ 的最终公式），确定 $u(x_0,0)$ 关于 $x_0$、$\\mu$、$\\sigma$、$T$、$a$、$\\kappa$、$q$ 和 $\\lambda$ 的封闭式表达式。您的表达式必须在所有情况下都有效，包括边界情况 $\\kappa = 0$ 和 $\\mu = \\lambda$，并且应在分母为零时作为适当的连续极限获得。\n\n然后，您必须实现一个程序，对于一组给定的参数元组，使用您推导出的封闭式表达式来数值计算 $u(x_0,0)$。程序在测试相等性时，必须通过使用数值稳定的容差来稳健地处理极限情况 $\\kappa \\to 0$ 和 $\\mu \\to \\lambda$。所有利率都应解释为小数（例如，百分之五的利率为 $0.05$）。\n\n您的程序必须评估以下参数集测试套件，每个参数集指定为 $(x_0,\\mu,\\sigma,T,a,\\kappa,q,\\lambda)$：\n\n- 测试 1：$(100,\\, 0.03,\\, 0.20,\\, 2.0,\\, 1.5,\\, 0.5,\\, 0.02,\\, 0.1)$，一个具有不同指数的一般情况。\n- 测试 2：$(80,\\, 0.04,\\, 0.25,\\, 1.5,\\, 2.0,\\, 0.0,\\, 0.03,\\, 0.2)$，边界情况 $\\kappa = 0$。\n- 测试 3：$(120,\\, 0.05,\\, 0.15,\\, 3.0,\\, 0.5,\\, 0.3,\\, 0.01,\\, 0.05)$，边界情况 $\\mu = \\lambda$。\n- 测试 4：$(50,\\, 0.07,\\, 0.30,\\, 0.0,\\, 1.0,\\, 0.4,\\, 0.02,\\, 0.6)$，边界情况 $T = 0$。\n- 测试 5：$(90,\\, -0.02,\\, 0.18,\\, 2.5,\\, 1.2,\\, 0.25,\\, 0.05,\\, 0.01)$，一个具有负漂移率的情况。\n\n您的程序必须为每个测试用例生成 $u(x_0,0)$ 的数值，这些数值是四舍五入到六位小数的实数。最终输出格式必须是单行，其中包含一个用方括号括起来的五个结果的逗号分隔列表，例如 $[r_1,r_2,r_3,r_4,r_5]$，其中每个 $r_i$ 是小数点后恰好有六位的浮点数。",
            "solution": "在尝试任何解决方案之前，将首先对问题陈述进行严格的验证程序。\n\n### 第 1 步：提取已知信息\n\n问题陈述中提供了以下信息：\n\n-   **股价过程**：由随机微分方程 (SDE) $dX_t = \\mu X_t \\, dt + \\sigma X_t \\, dW_t$ 控制的一维 Itô 扩散。\n    -   $X_t$：时间 $t$ 的股价。\n    -   $\\mu, \\sigma$：恒定漂移率和波动率。\n    -   $W_t$：标准布朗运动。\n-   **连续股息流**：瞬时股息率由 $f(X_t,t) = a \\, e^{-\\kappa t} + q \\, X_t \\, e^{-\\lambda t}$ 给出。\n    -   $a, \\kappa, q, \\lambda$：非负常数。\n-   **待计算的泛函**：从时间 $t=0$ 到 $T$ 的预期总股息定义为：\n    $$ u(x_0,0) = \\mathbb{E}\\left[\\int_{0}^{T} f(X_t,t) \\, dt \\,\\bigg|\\, X_0 = x_0\\right] $$\n-   **任务要求**：\n    1.  使用 Feynman–Kac 定理为 $u(x,t)$ 构建后向偏微分方程 (PDE)，包括终端条件。\n    2.  推导 $u(x_0,0)$ 的封闭式表达式。\n    3.  推导必须从第一性原理（Itô 扩散、期望的线性性、Feynman-Kac 定理）出发。\n    4.  表达式必须在所有情况下都有效，包括 $\\kappa = 0$ 和 $\\mu = \\lambda$。\n    5.  实现一个程序，为一组给定的测试用例计算 $u(x_0,0)$。\n\n### 第 2 步：使用提取的已知信息进行验证\n\n根据验证标准对问题进行评估。\n\n-   **科学性**：该问题设置在现代量化金融的标准框架内。股价过程是几何布朗运动模型，这是 Black-Scholes-Merton 理论的基石。股息结构是时间和股价的明确定义的函数。待计算的泛函，即路径依赖量的期望值，是一个常见的研究对象。Feynman-Kac 定理是将此类期望与 PDE 联系起来的正确且标准的数学工具。该问题不含任何伪科学或事实错误。\n-   **适定性**：该问题是适定的。SDE 是线性的，系数性质良好，保证了 $X_t$ 存在唯一的强解。泛函 $u(x_0,0)$ 是一个明确定义的期望，其存在性由过程和股息函数的性质保证。参数定义清晰，并提供了足够的信息来推导唯一解。\n-   **客观性**：语言精确、数学化，没有任何主观或含糊的术语。\n-   **无其他缺陷**：问题是自洽的，其设置是一致的，并且条件在数学模型内是可行的。它不是隐喻性的、琐碎的，也不在科学验证的范围之外。\n\n### 第 3 步：结论与行动\n\n问题是**有效的**。将制定解决方案。\n\n### 封闭式解的推导\n\n任务是找到以下泛函的封闭式表达式：\n$$ u(x_0, 0) = \\mathbb{E}\\left[\\int_{0}^{T} f(X_s,s) \\, ds \\,\\bigg|\\, X_0 = x_0\\right] $$\n其中 $dX_t = \\mu X_t \\, dt + \\sigma X_t \\, dW_t$ 且 $f(X_t,t) = a \\, e^{-\\kappa t} + q \\, X_t \\, e^{-\\lambda t}$。\n\n首先，我们将泛函推广到任意起始时间 $t \\in [0, T]$ 和状态 $X_t = x$：\n$$ u(x,t) = \\mathbb{E}\\left[\\int_{t}^{T} f(X_s,s) \\, ds \\,\\bigg|\\, X_t = x\\right] $$\n\n根据要求，我们使用 Feynman–Kac 定理来构建 PDE 问题。一般定理将形式为 $\\frac{\\partial u}{\\partial t} + \\mathcal{A}u - r u + g = 0$ 且终端条件为 $u(x,T) = \\psi(x)$ 的 PDE 与期望 $u(x,t) = \\mathbb{E}\\left[\\int_t^T e^{-\\int_t^s r(X_v) dv} g(X_s,s) ds + e^{-\\int_t^T r(X_v) dv} \\psi(X_T) | X_t=x\\right]$ 联系起来，其中 $\\mathcal{A}$ 是扩散过程的无穷小生成元。\n\n对于给定的过程 $dX_s = \\mu X_s ds + \\sigma X_s dW_s$，漂移系数为 $b(x,s) = \\mu x$，扩散系数为 $\\eta(x,s) = \\sigma x$。因此，无穷小生成元 $\\mathcal{A}$ 为：\n$$ \\mathcal{A}u = b(x,s) \\frac{\\partial u}{\\partial x} + \\frac{1}{2} \\eta(x,s)^2 \\frac{\\partial^2 u}{\\partial x^2} = \\mu x \\frac{\\partial u}{\\partial x} + \\frac{1}{2}\\sigma^2 x^2 \\frac{\\partial^2 u}{\\partial x^2} $$\n\n通过将我们的目标泛函与通用的 Feynman-Kac 公式进行比较，我们确定了以下组成部分：\n-   贴现率函数为 $r(x,s) = 0$。\n-   运行成本（或股息）函数为 $g(x,s) = f(x,s) = a e^{-\\kappa s} + q x e^{-\\lambda s}$。\n-   终端值函数为 $\\psi(x) = 0$。\n\n将这些代入通用 PDE 形式，得到 $u(x,t)$ 对于 $t \\in [0,T)$ 必须满足的后向 PDE：\n$$ \\frac{\\partial u}{\\partial t} + \\mu x \\frac{\\partial u}{\\partial x} + \\frac{1}{2}\\sigma^2 x^2 \\frac{\\partial^2 u}{\\partial x^2} + a e^{-\\kappa t} + q x e^{-\\lambda t} = 0 $$\n在 $t=T$ 时的相应终端条件由 $u(x,T)$ 的定义导出：\n$$ u(x,T) = \\mathbb{E}\\left[\\int_{T}^{T} f(X_s,s) \\, ds \\,\\bigg|\\, X_T = x\\right] = \\mathbb{E}[0] = 0 $$\n\n虽然这个 PDE 可以求解，但一个更直接的方法是直接评估期望，这种方法完全符合问题的约束条件。我们从 $u(x_0,0)$ 的定义开始，并应用期望的线性性和 Fubini 定理（由于被积函数是非负的，这是合理的）：\n$$ u(x_0, 0) = \\mathbb{E}\\left[\\int_{0}^{T} (a e^{-\\kappa t} + q X_t e^{-\\lambda t}) dt \\,\\bigg|\\, X_0 = x_0\\right] = \\int_{0}^{T} \\mathbb{E}[a e^{-\\kappa t} + q X_t e^{-\\lambda t} | X_0=x_0 ] dt $$\n$$ u(x_0, 0) = \\int_{0}^{T} \\left( a e^{-\\kappa t} + q e^{-\\lambda t} \\mathbb{E}[X_t | X_0=x_0] \\right) dt $$\n\n下一步是计算条件期望 $\\mathbb{E}[X_t | X_0=x_0]$。SDE $dX_t = \\mu X_t dt + \\sigma X_t dW_t$ 描述了一个几何布朗运动。其解已知为 $X_t = X_0 \\exp\\left((\\mu - \\frac{1}{2}\\sigma^2)t + \\sigma W_t\\right)$。取期望：\n$$ \\mathbb{E}[X_t | X_0=x_0] = \\mathbb{E}\\left[x_0 \\exp\\left((\\mu - \\frac{1}{2}\\sigma^2)t + \\sigma W_t\\right)\\right] = x_0 \\exp\\left((\\mu - \\frac{1}{2}\\sigma^2)t\\right) \\mathbb{E}[\\exp(\\sigma W_t)] $$\n由于 $W_t \\sim \\mathcal{N}(0, t)$，随机变量 $\\sigma W_t$ 服从均值为 $0$、方差为 $\\sigma^2 t$ 的正态分布。对于一个正态随机变量 $Z \\sim \\mathcal{N}(\\nu, \\tau^2)$，其矩母函数为 $\\mathbb{E}[e^{sZ}] = e^{s\\nu + \\frac{1}{2}s^2\\tau^2}$。对于 $\\sigma W_t$ 和 $s=1$，我们有：\n$$ \\mathbb{E}[\\exp(\\sigma W_t)] = \\exp\\left(1 \\cdot 0 + \\frac{1}{2} \\cdot 1^2 \\cdot \\sigma^2 t\\right) = \\exp\\left(\\frac{1}{2}\\sigma^2 t\\right) $$\n将此代回，我们得到一个基本结果：\n$$ \\mathbb{E}[X_t | X_0=x_0] = x_0 \\exp\\left((\\mu - \\frac{1}{2}\\sigma^2)t\\right) \\exp\\left(\\frac{1}{2}\\sigma^2 t\\right) = x_0 e^{\\mu t} $$\n\n现在，我们将此期望值代入 $u(x_0,0)$ 的积分中：\n$$ u(x_0, 0) = \\int_{0}^{T} \\left( a e^{-\\kappa t} + q e^{-\\lambda t} (x_0 e^{\\mu t}) \\right) dt = \\int_{0}^{T} a e^{-\\kappa t} dt + \\int_{0}^{T} q x_0 e^{(\\mu-\\lambda) t} dt $$\n\n我们分别计算每个积分。\n\n对于第一个积分，$I_1 = \\int_{0}^{T} a e^{-\\kappa t} dt$：\n-   如果 $\\kappa \\neq 0$：\n    $$ I_1 = a \\left[ \\frac{e^{-\\kappa t}}{-\\kappa} \\right]_0^T = a \\left( \\frac{e^{-\\kappa T}}{-\\kappa} - \\frac{e^0}{-\\kappa} \\right) = a \\frac{1 - e^{-\\kappa T}}{\\kappa} $$\n-   如果 $\\kappa = 0$：\n    $$ I_1 = \\int_{0}^{T} a dt = aT $$\n    当 $\\kappa \\to 0$ 时，使用 L'Hôpital 法则计算第一种情况的极限是 $\\lim_{\\kappa \\to 0} a \\frac{1 - e^{-\\kappa T}}{\\kappa} = \\lim_{\\kappa \\to 0} a \\frac{T e^{-\\kappa T}}{1} = aT$，这证实了一致性。\n\n对于第二个积分，$I_2 = \\int_{0}^{T} q x_0 e^{(\\mu-\\lambda) t} dt$：\n-   如果 $\\mu - \\lambda \\neq 0$：\n    $$ I_2 = q x_0 \\left[ \\frac{e^{(\\mu-\\lambda) t}}{\\mu-\\lambda} \\right]_0^T = q x_0 \\left( \\frac{e^{(\\mu-\\lambda) T}}{\\mu-\\lambda} - \\frac{e^0}{\\mu-\\lambda} \\right) = q x_0 \\frac{e^{(\\mu-\\lambda) T} - 1}{\\mu-\\lambda} $$\n-   如果 $\\mu - \\lambda = 0$（即 $\\mu = \\lambda$）：\n    $$ I_2 = \\int_{0}^{T} q x_0 dt = q x_0 T $$\n    同样，当 $\\mu-\\lambda \\to 0$ 时，第一种情况的极限得出 $\\lim_{\\mu-\\lambda \\to 0} q x_0 \\frac{e^{(\\mu-\\lambda) T} - 1}{\\mu-\\lambda} = \\lim_{\\mu-\\lambda \\to 0} q x_0 \\frac{T e^{(\\mu-\\lambda) T}}{1} = q x_0 T$，这证实了一致性。\n\n结合这些结果，$u(x_0,0)$ 的最终封闭式表达式为：\n$$ u(x_0, 0) = I_1 + I_2 $$\n该表达式必须使用条件逻辑来实现，以处理分母为零的情况。\n$$ u(x_0, 0) = \\begin{cases} aT  \\text{若 } \\kappa = 0 \\\\ a \\frac{1 - e^{-\\kappa T}}{\\kappa}  \\text{若 } \\kappa \\neq 0 \\end{cases} + \\begin{cases} q x_0 T  \\text{若 } \\mu=\\lambda \\\\ q x_0 \\frac{e^{(\\mu-\\lambda) T} - 1}{\\mu-\\lambda}  \\text{若 } \\mu \\neq \\lambda \\end{cases} $$\n该表达式对于所有指定的非负参数都是有效和稳健的。需要注意的是，波动率 $\\sigma$ 并未出现在最终表达式中。这是因为几何布朗运动过程 $X_t$ 的期望仅取决于漂移率 $\\mu$，而与其方差无关。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the expected total dividends for a set of test cases\n    based on a derived closed-form solution.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (x0, mu, sigma, T, a, kappa, q, lambda)\n    test_cases = [\n        (100.0, 0.03, 0.20, 2.0, 1.5, 0.5, 0.02, 0.1),    # Test 1: General case\n        (80.0, 0.04, 0.25, 1.5, 2.0, 0.0, 0.03, 0.2),      # Test 2: kappa = 0\n        (120.0, 0.05, 0.15, 3.0, 0.5, 0.3, 0.01, 0.05),   # Test 3: mu = lambda\n        (50.0, 0.07, 0.30, 0.0, 1.0, 0.4, 0.02, 0.6),      # Test 4: T = 0\n        (90.0, -0.02, 0.18, 2.5, 1.2, 0.25, 0.05, 0.01),  # Test 5: Negative drift\n    ]\n\n    results = []\n    # Tolerance for checking if a value is close to zero, to handle special cases robustly.\n    tol = 1e-12\n\n    for case in test_cases:\n        x0, mu, sigma, T, a, kappa, q, lam = case\n\n        # Handle the edge case where T = 0. The integral from 0 to 0 is 0.\n        if T == 0.0:\n            results.append(0.0)\n            continue\n\n        # Calculate the first term of the solution, related to the dividend component 'a'.\n        # This corresponds to the integral of a * exp(-kappa*t).\n        if abs(kappa)  tol:\n            # If kappa is zero, the integral is a*T.\n            term1 = a * T\n        else:\n            # The general case for kappa != 0.\n            term1 = a * (1.0 - np.exp(-kappa * T)) / kappa\n\n        # Calculate the second term of the solution, related to the dividend component 'q*X_t'.\n        # This corresponds to the integral of q * x0 * exp((mu-lambda)*t).\n        mu_minus_lambda = mu - lam\n        if abs(mu_minus_lambda)  tol:\n            # If mu equals lambda, the exponent is zero, and the integral is q*x0*T.\n            term2 = q * x0 * T\n        else:\n            # The general case for mu != lambda.\n            term2 = q * x0 * (np.exp(mu_minus_lambda * T) - 1.0) / mu_minus_lambda\n\n        # The total expected dividend is the sum of the two terms.\n        total_dividend = term1 + term2\n        results.append(total_dividend)\n\n    # Final print statement in the exact required format.\n    # Results are formatted to six decimal places.\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "为了扩展您的分析工具，我们将从几何布朗运动转向模拟均值回归现象的奥恩斯坦-乌伦贝克（OU）过程。本练习通过一个程式化的碳信用估值问题，展示了费曼-卡茨定理在处理非指数增长型随机变量时的强大功能。您将练习计算包含终端支付和持续运行成本的期望现值，这对于为利率或大宗商品等资产定价至关重要。",
            "id": "2440756",
            "problem": "考虑一个简化的碳信用估值问题，其中基础大气二氧化碳水平相较于基线的偏差（记为 $X_t$）遵循奥恩斯坦-乌伦贝克（Ornstein–Uhlenbeck）随机微分方程（SDE）\n$$\ndX_t = \\left(\\alpha - \\beta X_t\\right)\\,dt + \\sigma\\,dW_t,\\quad X_0 = x_0,\n$$\n其中 $\\alpha$、$\\beta$ 和 $\\sigma$ 是常数，$W_t$ 是一个标准布朗运动，$x_0$ 是给定的。设 $r$ 为一个恒定的贴现率。设瞬时社会碳成本由势能项 $V(x,t) = c_0 + c_1 x$ 建模，在时间 $T$ 的终端收益为 $g(x) = q x$，其中 $c_0$、$c_1$、$q$ 和 $T0$ 是给定的常数。定义时间–$t$ 的价值函数 $u(t,x)$ 为终端收益的现值加上社会成本的贴现流，在风险中性测度下进行评估。\n\n根据费曼-卡茨（Feynman–Kac）定理，价值函数 $u(t,x)$ 是以下线性抛物偏微分方程的唯一（足够正则的）解\n$$\n\\frac{\\partial u}{\\partial t}(t,x) + \\left(\\alpha - \\beta x\\right)\\frac{\\partial u}{\\partial x}(t,x) + \\frac{1}{2}\\sigma^2 \\frac{\\partial^2 u}{\\partial x^2}(t,x) - r\\,u(t,x) + \\left(c_0 + c_1 x\\right) = 0,\n$$\n其终端条件为\n$$\nu(T,x) = q\\,x.\n$$\n等价地，对于 $0 \\le t \\le T$，费曼-卡茨表示意味着\n$$\nu(t,x) = \\mathbb{E}\\left[ e^{-r (T-t)}\\,q\\,X_T + \\int_t^T e^{-r (s-t)} \\left(c_0 + c_1 X_s\\right)\\,ds \\,\\bigg|\\, X_t = x \\right].\n$$\n\n任务：编写一个完整、可运行的程序，为下列参数集测试套件计算 $u(0,x_0)$。对于每种情况，程序必须使用上述数学规范，并为 $u(0,x_0)$ 生成一个单一的浮点数结果。\n\n测试套件：\n- A类（正常路径，仅含确定性终端收益）：$(\\alpha,\\beta,\\sigma,r,T,x_0,c_0,c_1,q) = (0,0,0,0.05,1,10,0,0,1)$。\n- B类（零贴现和确定性运行成本的边界条件）：$(\\alpha,\\beta,\\sigma,r,T,x_0,c_0,c_1,q) = (2,1,0,0,\\ln 2,5,0,2,0)$。\n- C类（包含运行和终端两部分的一般随机设置）：$(\\alpha,\\beta,\\sigma,r,T,x_0,c_0,c_1,q) = (0.5,0.3,0.6,0.04,1.5,8,0,1,0.5)$。\n\n您的程序必须计算这三种情况下 $u(0,x_0)$ 的值，并将这三个结果汇总到最终输出中。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含用方括号括起来的逗号分隔列表的结果（例如，$[a,b,c]$），其中每个条目是四舍五入到 $6$ 位小数的浮点数。\n\n不允许使用外部输入或文件，并且输出中不允许有随机性。\n\n所有结果都是无量纲的实数。不使用角度。如果在中间步骤中需要比例，则必须在内部作为小数处理；输出中不得出现百分号。最终输出必须是如上所述的浮点数。",
            "solution": "首先将对问题陈述进行严格验证。\n\n步骤 1：提取已知条件\n已知条件如下：\n- $X_t$ 的随机微分方程（SDE）：\n$$\ndX_t = \\left(\\alpha - \\beta X_t\\right)\\,dt + \\sigma\\,dW_t,\\quad X_0 = x_0\n$$\n- 参数：常数 $\\alpha$、$\\beta$、$\\sigma$、$r$、$T  0$、$x_0$、$c_0$、$c_1$、$q$。\n- 瞬时社会成本（势能项）：$V(x,t) = c_0 + c_1 x$。\n- 终端收益：$g(x) = qx$。\n- 通过费曼-卡茨表示定义的价值函数：\n$$\nu(t,x) = \\mathbb{E}\\left[ e^{-r (T-t)}\\,q\\,X_T + \\int_t^T e^{-r (s-t)} \\left(c_0 + c_1 X_s\\right)\\,ds \\,\\bigg|\\, X_t = x \\right]\n$$\n- 等价的偏微分方程（PDE）：\n$$\n\\frac{\\partial u}{\\partial t}(t,x) + \\left(\\alpha - \\beta x\\right)\\frac{\\partial u}{\\partial x}(t,x) + \\frac{1}{2}\\sigma^2 \\frac{\\partial^2 u}{\\partial x^2}(t,x) - r\\,u(t,x) + \\left(c_0 + c_1 x\\right) = 0\n$$\n终端条件为 $u(T,x) = qx$。\n- 任务：为三个指定的参数集计算 $u(0, x_0)$。\n\n步骤 2：使用提取的已知条件进行验证\n根据验证标准对问题进行分析。\n- **科学性**：该问题基于奥恩斯坦-乌伦贝克过程和费曼-卡茨定理，这些是在随机微积分及其在金融和经济学应用中标准且完善的理论结构。该模型是仿射期限结构模型的典型例子。其表述在科学和数学上是合理的。\n- **适定性**：该问题要求计算一个特定的条件期望，对于给定的线性模型，它有唯一的解析解。任务简化为计算初等积分。每种情况都提供了所有必要的参数，使得问题自成体系且可解。\n- **客观性**：该问题使用精确、无歧义的数学语言和符号进行陈述。没有主观或基于意见的陈述。\n\n步骤 3：结论与行动\n问题有效。这是一个在计算金融领域中适定且具有科学基础的问题。将提供完整的解决方案。\n\n目标是计算由特定条件期望给出的价值函数 $u(0, x_0)$。根据期望算子的线性性质，$u(0, x_0)$ 的表达式可以分解为：\n$$\nu(0, x_0) = q\\,e^{-rT} \\mathbb{E}[X_T | X_0=x_0] + \\int_0^T e^{-rs} \\mathbb{E}[(c_0 + c_1 X_s) | X_0=x_0]\\,ds\n$$\n$$\nu(0, x_0) = q\\,e^{-rT} \\mathbb{E}[X_T | X_0=x_0] + c_0 \\int_0^T e^{-rs}\\,ds + c_1 \\int_0^T e^{-rs} \\mathbb{E}[X_s | X_0=x_0]\\,ds\n$$\n波动率参数 $\\sigma$ 不出现在 $X_s$ 的期望中，这是线性SDE的一个已知属性。\n\n计算的核心是奥恩斯坦-乌伦贝克过程的条件期望 $\\mathbb{E}[X_s | X_0 = x_0]$。SDE的解给出了这个期望。\n\n对于 $\\beta \\neq 0$：\n$$\n\\mathbb{E}[X_s | X_0=x_0] = x_0 e^{-\\beta s} + \\frac{\\alpha}{\\beta}(1 - e^{-\\beta s})\n$$\n对于特殊情况 $\\beta = 0$，SDE简化为 $dX_t = \\alpha dt + \\sigma dW_t$，这是一个算术布朗运动。其期望为：\n$$\n\\mathbb{E}[X_s | X_0=x_0] = x_0 + \\alpha s\n$$\n\n我们将通过分别处理 $\\beta$ 的这两种情况来推导解。\n\n情况 1：$\\beta \\neq 0$\n我们将 $\\mathbb{E}[X_s | X_0=x_0]$ 的表达式代入 $u(0, x_0)$ 的公式中。总价值是三个部分的和：\n1.  终端收益部分：$I_{term} = q\\,e^{-rT} \\mathbb{E}[X_T | X_0=x_0] = q\\,e^{-rT} \\left( x_0 e^{-\\beta T} + \\frac{\\alpha}{\\beta}(1 - e^{-\\beta T}) \\right)$。\n2.  恒定运行成本部分：$I_{run,c_0} = c_0 \\int_0^T e^{-rs}\\,ds$。\n3.  状态依赖运行成本部分：$I_{run,c_1} = c_1 \\int_0^T e^{-rs} \\left( x_0 e^{-\\beta s} + \\frac{\\alpha}{\\beta}(1 - e^{-\\beta s}) \\right) \\,ds$。\n\n这些积分将进行解析求解。我们定义一个通用积分函数：\n$$\n\\text{Integral}_1(k, T) = \\int_0^T e^{-ks}\\,ds = \\begin{cases} T  \\text{若 } k=0 \\\\ \\frac{1 - e^{-kT}}{k}  \\text{若 } k \\neq 0 \\end{cases}\n$$\n使用这个函数，$I_{run,c_0} = c_0 \\cdot \\text{Integral}_1(r, T)$。\n$I_{run,c_1}$ 中的积分被拆分为：\n$$\nI_{run,c_1} = c_1 x_0 \\int_0^T e^{-(r+\\beta)s}\\,ds + \\frac{c_1 \\alpha}{\\beta} \\int_0^T (e^{-rs} - e^{-(r+\\beta)s})\\,ds\n$$\n$$\nI_{run,c_1} = c_1 x_0 \\cdot \\text{Integral}_1(r+\\beta, T) + \\frac{c_1 \\alpha}{\\beta} \\left( \\text{Integral}_1(r, T) - \\text{Integral}_1(r+\\beta, T) \\right)\n$$\n将这三个部分相加得到 $u(0, x_0) = I_{term} + I_{run,c_0} + I_{run,c_1}$。\n\n情况 2：$\\beta = 0$\n此时，$\\mathbb{E}[X_s | X_0=x_0] = x_0 + \\alpha s$。各部分为：\n1.  终端收益部分：$I_{term} = q\\,e^{-rT} (x_0 + \\alpha T)$。\n2.  运行成本部分：$I_{run} = \\int_0^T e^{-rs} (c_0 + c_1(x_0+\\alpha s))\\,ds$。这可以拆分为：\n$$\nI_{run} = (c_0 + c_1 x_0) \\int_0^T e^{-rs}\\,ds + c_1 \\alpha \\int_0^T s e^{-rs}\\,ds\n$$\n第一个积分是 $\\text{Integral}_1(r, T)$。第二个积分是一种新的形式：\n$$\n\\text{Integral}_2(k, T) = \\int_0^T s e^{-ks}\\,ds = \\begin{cases} \\frac{T^2}{2}  \\text{若 } k=0 \\\\ \\frac{1 - e^{-kT} - kTe^{-kT}}{k^2}  \\text{若 } k \\neq 0 \\end{cases}\n$$\n因此，对于 $\\beta=0$，价值为：\n$$\nu(0, x_0) = q\\,e^{-rT} (x_0 + \\alpha T) + (c_0 + c_1 x_0)\\text{Integral}_1(r, T) + c_1 \\alpha \\text{Integral}_2(r, T)\n$$\n这些闭式表达式允许对任何给定的参数集直接计算 $u(0, x_0)$，并正确处理积分中的奇异点 $k=0$（对应于 $r=0$、$\\beta=0$ 或 $r+\\beta=0$）。实现将基于这些推导出的公式。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for u(0, x_0) for the given test cases based on the\n    analytical solution derived from the Feynman-Kac representation.\n    \"\"\"\n\n    test_cases = [\n        # Case A: (alpha, beta, sigma, r, T, x0, c0, c1, q)\n        (0.0, 0.0, 0.0, 0.05, 1.0, 10.0, 0.0, 0.0, 1.0),\n        # Case B:\n        (2.0, 1.0, 0.0, 0.0, np.log(2), 5.0, 0.0, 2.0, 0.0),\n        # Case C:\n        (0.5, 0.3, 0.6, 0.04, 1.5, 8.0, 0.0, 1.0, 0.5),\n    ]\n\n    results = []\n    for params in test_cases:\n        result = calculate_u(*params)\n        results.append(result)\n\n    # Format the output string as required.\n    print(f\"[{','.join(f'{x:.6f}' for x in results)}]\")\n\ndef integral_1(k, T):\n    \"\"\"\n    Computes the definite integral of exp(-k*s) from 0 to T.\n    Integral: ∫[0,T] e^(-ks) ds\n    \"\"\"\n    if abs(k)  1e-9:\n        return T\n    return (1 - np.exp(-k * T)) / k\n\ndef integral_2(k, T):\n    \"\"\"\n    Computes the definite integral of s*exp(-k*s) from 0 to T.\n    Integral: ∫[0,T] s*e^(-ks) ds\n    \"\"\"\n    if abs(k)  1e-9:\n        return T**2 / 2.0\n    return (1 - np.exp(-k * T) - k * T * np.exp(-k * T)) / k**2\n\ndef calculate_u(alpha, beta, sigma, r, T, x0, c0, c1, q):\n    \"\"\"\n    Calculates the value u(0, x0) using the derived analytical solution.\n    Handles the special case when beta is zero.\n    The parameter sigma is not used in the expectation calculation.\n    \"\"\"\n    \n    # Case when beta is effectively zero (Arithmetic Brownian Motion)\n    if abs(beta)  1e-9:\n        # Terminal value component\n        term1 = q * np.exp(-r * T) * (x0 + alpha * T)\n        \n        # Running cost components\n        int1_r = integral_1(r, T)\n        int2_r = integral_2(r, T)\n        \n        term2 = c0 * int1_r\n        term3 = c1 * x0 * int1_r\n        term4 = c1 * alpha * int2_r\n        \n        return term1 + term2 + term3 + term4\n\n    # General case for beta != 0 (Ornstein-Uhlenbeck)\n    else:\n        # 1. Terminal payoff component\n        E_XT = x0 * np.exp(-beta * T) + (alpha / beta) * (1 - np.exp(-beta * T))\n        term1 = q * np.exp(-r * T) * E_XT\n        \n        # 2. Constant running cost component\n        int1_r = integral_1(r, T)\n        term2 = c0 * int1_r\n        \n        # 3. State-dependent running cost component\n        int1_r_beta = integral_1(r + beta, T)\n        term3_x0_part = c1 * x0 * int1_r_beta\n        term3_alpha_part = c1 * (alpha / beta) * (int1_r - int1_r_beta)\n        term3 = term3_x0_part + term3_alpha_part\n        \n        return term1 + term2 + term3\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "本练习旨在深化您对理论的理解，探讨费曼-卡茨定理揭示的二元性。我们将比较两种不同的建模方式：一种是将某个比率（如成本或收益率）作为资产漂移项的一部分，另一种是将其作为“扼杀率”体现在贴现因子中。通过这个实践，您将能够更深刻地理解定理中各项的金融直觉，并掌握如何在不同但相关的估值框架之间进行转换。",
            "id": "2440799",
            "problem": "考虑一个风险中性测度 (RNM) 下的金融市场，其中标的资产价格过程 $\\{S_t\\}_{t \\in [0,T]}$ 服从一个由维纳过程（布朗运动）$\\{W_t\\}_{t \\in [0,T]}$ 驱动的几何布朗运动。令 $S_0 \\in \\mathbb{R}_{+}$ 为初始价格，$r \\in \\mathbb{R}$ 为恒定无风险利率，$\\sigma \\in \\mathbb{R}_{+}$ 为恒定波动率。固定到期日 $T \\in \\mathbb{R}_{+}$ 和行权价 $K \\in \\mathbb{R}_{+}$。考虑一个支付函数为 $\\varphi(S_T) = \\max(S_T - K, 0)$ 的欧式看涨期权。\n\n对于一个非负、确定性、随时间变化的利率 $q(t)$，我们将比较两种建模约定：\n\n- 模型 A (灭失率模型)：价格函数 $u_A(s,t)$ 求解一个带有势能项（灭失率）$V(x,t) = q(t)$ 的偏微分方程 (PDE)，且根据 Feynman–Kac 定理，\n$$\nu_A(S_0,0) \\;=\\; \\mathbb{E}\\left[\\exp\\!\\left(-\\int_{0}^{T} \\big(r + q(t)\\big)\\,dt\\right)\\,\\varphi(S_T)\\,\\Big|\\,S_0\\right],\n$$\n其中的标的资产服从\n$$\ndS_t \\;=\\; r\\,S_t\\,dt \\;+\\; \\sigma\\,S_t\\,dW_t,\\quad S_0 \\;\\; 0.\n$$\n\n- 模型 B (股息率模型)：相同的量 $q(t)$ 被解释为进入标的资产漂移项的连续股息率，\n$$\ndS_t \\;=\\; \\big(r - q(t)\\big)\\,S_t\\,dt \\;+\\; \\sigma\\,S_t\\,dW_t,\\quad S_0 \\;\\; 0,\n$$\n并且期权价格由下式给出\n$$\nu_B(S_0,0) \\;=\\; \\mathbb{E}\\left[\\exp\\!\\left(-\\int_{0}^{T} r\\,dt\\right)\\,\\varphi(S_T)\\,\\Big|\\,S_0\\right].\n$$\n\n你的任务是，对于下面指定的每个 $q(t)$，仅使用上述定义以及几何布朗运动和 Feynman–Kac 定理的基本性质，计算 $u_A(S_0,0)$ 和 $u_B(S_0,0)$。答案必须以与 $S_0$ 和 $K$ 相同的货币单位表示，并四舍五入到六位小数。\n\n使用通用参数集\n$$\nS_0 \\;=\\; 100,\\quad K \\;=\\; 100,\\quad r \\;=\\; 0.03,\\quad \\sigma \\;=\\; 0.2,\\quad T \\;=\\; 1.\n$$\n\n测试套件（$q(t)$ 的五个案例）：\n- 案例 #1：对于所有 $t \\in [0,T]$，$q(t) \\;=\\; 0$。\n- 案例 #2：对于所有 $t \\in [0,T]$，$q(t) \\;=\\; 0.02$。\n- 案例 #3：对于所有 $t \\in [0,T]$，$q(t) \\;=\\; 0.05$。\n- 案例 #4：对于所有 $t \\in [0,T]$，$q(t) \\;=\\; 0.10$。\n- 案例 #5：$q(t)$ 是分段常数，其中对于 $t \\in [0, 0.25]$，$q(t) \\;=\\; 0.10$；对于 $t \\in (0.25, 1]$，$q(t) \\;=\\; 0$。\n\n你的程序必须按以下顺序输出五个案例的结果：对于每个案例，首先输出 $u_A(S_0,0)$，然后输出 $u_B(S_0,0)$。最终输出必须是单行，包含一个用方括号括起来的逗号分隔列表，其中有十个浮点数，四舍五入到六位小数，顺序如下\n$$\n\\big[u_A^{(1)},\\,u_B^{(1)},\\,u_A^{(2)},\\,u_B^{(2)},\\,u_A^{(3)},\\,u_B^{(3)},\\,u_A^{(4)},\\,u_B^{(4)},\\,u_A^{(5)},\\,u_B^{(5)}\\big].\n$$",
            "solution": "在尝试求解之前，对问题陈述进行验证。\n\n首先，逐字提取所有给定条件。\n- 标的资产价格过程：$\\{S_t\\}_{t \\in [0,T]}$ 服从一个由维纳过程 $\\{W_t\\}_{t \\in [0,T]}$ 驱动的几何布朗运动。\n- 初始价格：$S_0 \\in \\mathbb{R}_{+}$。\n- 无风险利率：$r \\in \\mathbb{R}$，恒定。\n- 波动率：$\\sigma \\in \\mathbb{R}_{+}$，恒定。\n- 到期日：$T \\in \\mathbb{R}_{+}$。\n- 行权价：$K \\in \\mathbb{R}_{+}$。\n- 支付函数（欧式看涨期权）：$\\varphi(S_T) = \\max(S_T - K, 0)$。\n- 一个非负、确定性、随时间变化的利率 $q(t)$。\n- 模型 A (灭失率模型)：$u_A(S_0,0) = \\mathbb{E}\\left[\\exp\\left(-\\int_{0}^{T} (r + q(t))\\,dt\\right)\\,\\varphi(S_T)\\,\\Big|\\,S_0\\right]$，其中标的资产为 $dS_t = r\\,S_t\\,dt + \\sigma\\,S_t\\,dW_t$。\n- 模型 B (股息率模型)：$u_B(S_0,0) = \\mathbb{E}\\left[\\exp\\left(-\\int_{0}^{T} r\\,dt\\right)\\,\\varphi(S_T)\\,\\Big|\\,S_0\\right]$，其中标的资产为 $dS_t = (r - q(t))\\,S_t\\,dt + \\sigma\\,S_t\\,dW_t$。\n- 通用参数：$S_0 = 100$, $K = 100$, $r = 0.03$, $\\sigma = 0.2$, $T = 1$。\n- $q(t)$ 的测试案例：\n    1. 对于所有 $t \\in [0,T]$，$q(t) = 0$。\n    2. 对于所有 $t \\in [0,T]$，$q(t) = 0.02$。\n    3. 对于所有 $t \\in [0,T]$，$q(t) = 0.05$。\n    4. 对于所有 $t \\in [0,T]$，$q(t) = 0.10$。\n    5. $q(t)$ 是分段常数，其中对于 $t \\in [0, 0.25]$，$q(t) = 0.10$；对于 $t \\in (0.25, 1]$，$q(t) = 0$。\n\n其次，根据所需标准对问题进行验证。\n- **科学基础**：该问题是在数理金融的标准 Black-Scholes-Merton 框架内提出的。所提出的两种模型都是纳入收益率或灭失率的有效解释，它们通过 Feynman-Kac 定理的表示是标准理论。该问题在科学上是合理的。\n- **适定性**：问题是完全指定的。所有必要的参数（$S_0, K, r, \\sigma, T$）和 $q(t)$ 的函数形式都已提供。对于几何布朗运动，期望是良定义的，确保每个案例都存在唯一且稳定的解。\n- **客观性**：问题使用精确的数学和金融术语陈述，没有歧义或主观论断。\n\n结论是该问题是**有效的**。它是自洽的、有科学依据且适定的。我们继续进行求解。\n\n任务是为利率函数 $q(t)$ 的五种不同具体形式计算 $u_A(S_0,0)$ 和 $u_B(S_0,0)$ 的值。两种模型都导出了可以使用欧式看涨期权的 Black-Scholes-Merton (BSM) 公式进行评估的表达式。对于一个初始股价为 $S_0$、行权价为 $K$、到期日为 $T$、恒定无风险利率为 $r$、恒定连续股息率为 $q$、恒定波动率为 $\\sigma$ 的期权，其 BSM 价格由下式给出：\n$$\nC(S_0, K, T, r, q, \\sigma) = S_0 e^{-qT} N(d_1) - K e^{-rT} N(d_2)\n$$\n其中 $N(\\cdot)$ 是标准正态分布的累积分布函数 (CDF)，并且\n$$\nd_1 = \\frac{\\ln(S_0/K) + (r - q + \\sigma^2/2)T}{\\sigma\\sqrt{T}}\n$$\n$$\nd_2 = d_1 - \\sigma\\sqrt{T}\n$$\n\n我们现在在此公式的背景下分析每个模型。\n\n**模型 A：灭失率模型**\n价格由期望给出：\n$$\nu_A(S_0,0) = \\mathbb{E}\\left[\\exp\\left(-\\int_{0}^{T} (r + q(t))\\,dt\\right)\\,\\varphi(S_T)\\,\\Big|\\,S_0\\right]\n$$\n标的过程是 $dS_t = r S_t dt + \\sigma S_t dW_t$。由于 $r$ 是常数且 $q(t)$ 是时间的确定性函数，折现因子可以从期望中分离出来：\n$$\nu_A(S_0,0) = \\exp\\left(-\\int_{0}^{T} q(t)\\,dt\\right) \\mathbb{E}\\left[\\exp(-rT)\\,\\varphi(S_T)\\,\\Big|\\,S_0\\right]\n$$\n剩余的期望项 $\\mathbb{E}\\left[\\exp(-rT)\\,\\varphi(S_T)\\,\\Big|\\,S_0\\right]$，正是漂移率为 $r$ 的标的资产的欧式看涨期权的 BSM 价格，这对应于股息率 $q=0$ 的 BSM 公式。令其为 $C_0 = C(S_0, K, T, r, 0, \\sigma)$。因此，模型 A 的公式为：\n$$\nu_A(S_0,0) = \\exp\\left(-\\int_{0}^{T} q(t)\\,dt\\right) \\times C_0\n$$\n\n**模型 B：股息率模型**\n价格由下式给出：\n$$\nu_B(S_0,0) = \\mathbb{E}\\left[\\exp(-rT)\\,\\varphi(S_T)\\,\\Big|\\,S_0\\right]\n$$\n标的过程是 $dS_t = (r - q(t))S_t dt + \\sigma S_t dW_t$。该随机微分方程在时间 $T$ 的解是：\n$$\nS_T = S_0 \\exp\\left(\\int_0^T (r - q(t) - \\sigma^2/2)\\,dt + \\sigma W_T\\right)\n$$\n由于 $q(t)$ 是确定性的，该积分也是确定性的。让我们定义时间平均股息率 $\\bar{q}$ 为：\n$$\n\\bar{q} = \\frac{1}{T}\\int_{0}^{T} q(t)\\,dt\n$$\n那么，$\\int_0^T (r-q(t))\\,dt = (r-\\bar{q})T$。$S_T$ 的分布是对数正态的，并且与服从恒定漂移率为 $r-\\bar{q}$ 的几何布朗运动的资产分布相同。因此，定价公式就是标准的 BSM 公式，只是将常数股息率 $q$ 替换为平均收益率 $\\bar{q}$：\n$$\nu_B(S_0,0) = C(S_0, K, T, r, \\bar{q}, \\sigma)\n$$\n\n我们现在使用通用参数 $S_0 = 100$, $K = 100$, $r = 0.03$, $\\sigma = 0.2$, 和 $T = 1$ 将这些公式应用于给定的测试案例。由于 $S_0 = K$，项 $\\ln(S_0/K) = 0$。\n\n首先，我们计算基准价格 $C_0 = C(100, 100, 1, 0.03, 0, 0.2)$：\n$d_1 = \\frac{(0.03 - 0 + 0.2^2/2) \\times 1}{0.2\\sqrt{1}} = \\frac{0.05}{0.2} = 0.25$。\n$d_2 = 0.25 - 0.2\\sqrt{1} = 0.05$。\n$C_0 = 100 \\times e^0 \\times N(0.25) - 100 \\times e^{-0.03 \\times 1} \\times N(0.05)$。\n使用 $N(0.25) \\approx 0.598706$ 和 $N(0.05) \\approx 0.519939$，我们得到 $C_0 \\approx 9.412819$。\n\n**案例 #1: $q(t) = 0$**\n- $\\int_0^T q(t)dt = 0$。\n- $\\bar{q} = 0$。\n- $u_A^{(1)} = e^{-0} \\times C_0 = C_0 \\approx 9.412819$。\n- $u_B^{(1)} = C(100, 100, 1, 0.03, 0, 0.2) = C_0 \\approx 9.412819$。\n\n**案例 #2: $q(t) = 0.02$**\n- $\\int_0^T q(t)dt = 0.02 \\times 1 = 0.02$。\n- $\\bar{q} = 0.02$。\n- $u_A^{(2)} = e^{-0.02} \\times C_0 \\approx 0.980199 \\times 9.412819 \\approx 9.226391$。\n- $u_B^{(2)} = C(100, 100, 1, 0.03, 0.02, 0.2)$。\n  $d_1 = \\frac{(0.03 - 0.02 + 0.02)}{0.2} = 0.15$。\n  $d_2 = 0.15 - 0.2 = -0.05$。\n  $u_B^{(2)} = 100 e^{-0.02} N(0.15) - 100 e^{-0.03} N(-0.05) \\approx 8.267096$。\n\n**案例 #3: $q(t) = 0.05$**\n- $\\int_0^T q(t)dt = 0.05 \\times 1 = 0.05$。\n- $\\bar{q} = 0.05$。\n- $u_A^{(3)} = e^{-0.05} \\times C_0 \\approx 0.951229 \\times 9.412819 \\approx 8.953530$。\n- $u_B^{(3)} = C(100, 100, 1, 0.03, 0.05, 0.2)$。\n  $d_1 = \\frac{(0.03 - 0.05 + 0.02)}{0.2} = 0$。\n  $d_2 = 0 - 0.2 = -0.2$。\n  $u_B^{(3)} = 100 e^{-0.05} N(0) - 100 e^{-0.03} N(-0.2) \\approx 6.730836$。\n\n**案例 #4: $q(t) = 0.10$**\n- $\\int_0^T q(t)dt = 0.10 \\times 1 = 0.10$。\n- $\\bar{q} = 0.10$。\n- $u_A^{(4)} = e^{-0.10} \\times C_0 \\approx 0.904837 \\times 9.412819 \\approx 8.517192$。\n- $u_B^{(4)} = C(100, 100, 1, 0.03, 0.10, 0.2)$。\n  $d_1 = \\frac{(0.03 - 0.10 + 0.02)}{0.2} = -0.25$。\n  $d_2 = -0.25 - 0.2 = -0.45$。\n  $u_B^{(4)} = 100 e^{-0.10} N(-0.25) - 100 e^{-0.03} N(-0.45) \\approx 4.648986$。\n\n**案例 #5: 分段常数 $q(t)$**\n- 对于 $t \\in [0, 0.25]$，$q(t) = 0.10$；对于 $t \\in (0.25, 1]$，$q(t) = 0$。\n- $\\int_0^T q(t)dt = \\int_0^{0.25} 0.10 dt + \\int_{0.25}^1 0 dt = 0.10 \\times 0.25 = 0.025$。\n- $\\bar{q} = \\frac{0.025}{1} = 0.025$。\n- $u_A^{(5)} = e^{-0.025} \\times C_0 \\approx 0.975310 \\times 9.412819 \\approx 9.180479$。\n- $u_B^{(5)} = C(100, 100, 1, 0.03, 0.025, 0.2)$。\n  $d_1 = \\frac{(0.03 - 0.025 + 0.02)}{0.2} = 0.125$。\n  $d_2 = 0.125 - 0.2 = -0.075$。\n  $u_B^{(5)} = 100 e^{-0.025} N(0.125) - 100 e^{-0.03} N(-0.075) \\approx 7.990990$。\n\n这些值在四舍五入到六位小数后，将呈现在最终输出中。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Computes European call option prices for two different models\n    (killing-rate and dividend-yield) based on the Feynman-Kac theorem.\n    \"\"\"\n\n    def black_scholes_call(S0, K, T, r, q, sigma):\n        \"\"\"\n        Calculates the price of a European call option using the Black-Scholes-Merton formula.\n        \"\"\"\n        if sigma == 0 or T == 0:\n            return max(0, S0 - K) if T == 0 else max(0, S0 * np.exp(-q * T) - K * np.exp(-r * T))\n\n        d1 = (np.log(S0 / K) + (r - q + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n        d2 = d1 - sigma * np.sqrt(T)\n        \n        price = S0 * np.exp(-q * T) * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)\n        return price\n\n    # Common parameters\n    S0 = 100.0\n    K = 100.0\n    r = 0.03\n    sigma = 0.2\n    T = 1.0\n\n    # Test cases for the rate function q(t)\n    test_cases = [\n        {'type': 'constant', 'q_val': 0.0},\n        {'type': 'constant', 'q_val': 0.02},\n        {'type': 'constant', 'q_val': 0.05},\n        {'type': 'constant', 'q_val': 0.10},\n        {'type': 'piecewise', 'pieces': [(0.10, 0.0, 0.25), (0.0, 0.25, 1.0)]}\n    ]\n\n    results = []\n\n    # Calculate the baseline price for q=0, which is used in Model A\n    price_q0 = black_scholes_call(S0, K, T, r, 0.0, sigma)\n\n    for case in test_cases:\n        if case['type'] == 'constant':\n            integral_q_dt = case['q_val'] * T\n        elif case['type'] == 'piecewise':\n            integral_q_dt = sum(q_val * (end_t - start_t) for q_val, start_t, end_t in case['pieces'])\n        \n        q_bar = integral_q_dt / T\n\n        # Model A: u_A = exp(-integral(q(t) dt)) * C(q=0)\n        u_A = np.exp(-integral_q_dt) * price_q0\n\n        # Model B: u_B = C(q=q_bar)\n        u_B = black_scholes_call(S0, K, T, r, q_bar, sigma)\n\n        results.append(round(u_A, 6))\n        results.append(round(u_B, 6))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{x:.6f}' for x in results)}]\")\n\nsolve()\n```"
        }
    ]
}