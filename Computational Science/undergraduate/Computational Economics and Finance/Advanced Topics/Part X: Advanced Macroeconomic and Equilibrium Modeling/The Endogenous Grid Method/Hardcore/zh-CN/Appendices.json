{
    "hands_on_practices": [
        {
            "introduction": "任何计算方法的核心都在于其关键的更新步骤。这个练习将直接带您深入EGM的心脏地带，通过识别并修正一个有缺陷的算法实现，您将深刻理解欧拉方程如何直接转化为EGM的更新公式。这个从第一性原理出发的调试过程是掌握EGM并避免常见编程陷阱的绝佳起点 。",
            "id": "2440065",
            "problem": "考虑具有恒定相对风险厌恶 (CRRA) 效用的无限期消费储蓄问题。一个代表性代理人选择消费 $c_t$ 和下一期资产 $a_{t+1}$ 以最大化\n$$\n\\sum_{t=0}^{\\infty} \\beta^t \\frac{c_t^{1-\\sigma}}{1-\\sigma},\n$$\n在预算约束下\n$$\na_{t+1} = m_t - c_t,\\quad m_t = R a_t + y,\\quad a_{t+1} \\ge 0,\n$$\n其中 $\\beta \\in (0,1)$ 是折扣因子，$\\sigma  0$ 是相对风险厌恶系数，$R  0$ 是总利率因子，$y  0$ 是外生恒定收入。边际效用为 $u'(c) = c^{-\\sigma}$。在没有触及借贷约束时的最优性条件是欧拉方程\n$$\nu'(c_t) = \\beta R u'(c_{t+1}).\n$$\n\n求解稳态消费策略 $c(m)$ 的一种常用数值方法是内生网格法 (EGM)。在 EGM 中，首先固定一个下一期资产 $a'$ 的网格，计算下一期的手头现金 $m'$，使用当前猜测的策略来评估下一期的边际效用，然后利用欧拉方程反解出当期消费，并计算出内生的当期手头现金 $m$，最后通过插值得到 $c(m)$。\n\n给定以下这个有问题的 EGM 更新实现草案。每一步都用数学伪代码写成，其中变量 $(\\beta, R, \\sigma, y)$ 是参数，$a'$ 是下一期资产的外生网格，$m'$ 是下一期的手头现金，$c^{\\text{old}}(m)$ 是作为 $m$ 函数的当前策略猜测：\n\n- 步骤 1 (下一期资产网格)：在 $[0,\\bar a]$ 上选择一个网格 $\\{a'_i\\}_{i=1}^N$，其中 $\\bar a  0$ 是一个较大的数。\n- 步骤 2 (下一期资源)：对每个 $a'_i$，计算 $m'_i = R a'_i + y$。\n- 步骤 3 (下一期边际效用)：对每个 $m'_i$，计算 $u'(c^{\\text{old}}(m'_i)) = \\left(c^{\\text{old}}(m'_i)\\right)^{-\\sigma}$。\n- 步骤 4 (从欧拉方程得到当期消费，错误)：对每个 $i$，设置\n$$\nc^{\\text{endo}}_i = \\left(R \\cdot u'(c^{\\text{old}}(m'_i))\\right)^{-1/\\sigma}.\n$$\n- 步骤 5 (内生当期资源)：对每个 $i$，设置 $m^{\\text{endo}}_i = c^{\\text{endo}}_i + a'_i$。\n- 步骤 6 (插值到固定的 $m$-网格)：在 $[y, \\bar m]$ 上定义一个固定网格 $\\{m_j\\}_{j=1}^M$，其中 $\\bar m  0$ 是一个较大的数。对于 $m_j  \\min_i m^{\\text{endo}}_i$，通过设置 $c^{\\text{new}}(m_j) = m_j$ 来强制执行借贷约束。对于 $m_j \\ge \\min_i m^{\\text{endo}}_i$，通过对点对 $(m^{\\text{endo}}_i, c^{\\text{endo}}_i)$ 进行线性插值来获得 $c^{\\text{new}}(m_j)$。\n\n错误的步骤是步骤 4。你的任务是：\n\n1) 从欧拉方程和 CRRA 边际效用定义的第一性原理出发，识别步骤 4 中的逻辑错误。解释为什么步骤 4 不正确，以及正确的表达式必须是什么。\n\n2) 实现两个求解器：\n- 一个“错误的”EGM 求解器，使用上面不正确的步骤 4。\n- 一个“修正的”EGM 求解器，使用你在第 1 部分中推导出的逻辑上修正的步骤 4。\n\n两个求解器都应使用 EGM 更新迭代消费策略，直到收敛到策略算子的不动点，或达到最大迭代次数。你必须通过在借贷约束 $a' \\ge 0$ 生效时设置 $c(m) = m$ 来处理该约束。在网格点之间使用线性插值，并在最后一个内生网格点之外使用线性外推。确保对所有 $m$ 都有 $c(m) \\le m$。\n\n3) 为了进行评估，将给定 $m$ 处的欧拉残差定义为\n$$\n\\mathcal{R}(m) = \n\\begin{cases}\n\\left|u'(c(m)) - \\beta R \\, u'\\left(c\\left(R\\left[m - c(m)\\right] + y\\right)\\right)\\right|,   \\text{若 } m - c(m)  10^{-10},\\\\\n0,  \\text{若 } m - c(m) \\le 10^{-10},\n\\end{cases}\n$$\n该值衡量了在未触及借贷约束时对欧拉方程的绝对违背程度。计算在手头现金值的评估网格上欧拉残差的上确界范数。\n\n4) 使用你的两个求解器和残差定义，运行以下测试套件。对于每个参数集，在相同的评估网格上为错误的和修正的求解器计算上确界欧拉残差。然后，为每个测试案例输出一个布尔值，当且仅当以下所有条件同时成立时该值为真：修正后残差严格小于 $10^{-5}$，错误残差至少为 $10^{-3}$，并且错误残差至少是修正后残差的 $10$ 倍。\n\n测试套件参数集：\n- 案例 A (理想路径)：$\\beta = 0.96$, $R = 1.04$, $\\sigma = 2.0$, $y = 1.0$, $\\bar a = 50.0$, $N = 300$, $M = 400$。\n- 案例 B (更强的不耐和曲率)：$\\beta = 0.90$, $R = 1.04$, $\\sigma = 3.0$, $y = 1.0$, $\\bar a = 50.0$, $N = 300$, $M = 400$。\n- 案例 C (接近刀刃情况 $\\beta R \\approx 1$)：$\\beta = 0.995$, $R = 1.004$, $\\sigma = 2.0$, $y = 1.0$, $\\bar a = 60.0$, $N = 300$, $M = 500$。\n\n对两个求解器使用相同的停止规则，最大迭代次数为 $800$ 次，连续策略函数之间上确界范数差的容差为 $10^{-8}$，必要时采用凸阻尼以确保稳定性。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，`[result1,result2,result3]`）。每个条目必须是布尔值，按顺序对应于上面定义的案例 A、B 和 C。输出中不允许有多余的空格或文本。\n\n所有答案都是无量纲的；不涉及物理单位。",
            "solution": "该问题陈述是计算经济学中的一个有效练习。它涉及具有恒定相对风险厌恶 (CRRA) 效用的标准无限期消费储蓄模型。任务是识别并纠正所提供的内生网格法 (EGM) 算法草案中的一个逻辑错误，实现有缺陷和修正后的两个版本，并使用欧拉方程残差来比较它们的准确性。所有参数和模型组件都定义明确，并与既定的经济理论一致。\n\n**1. 算法缺陷的识别与修正**\n\n动态优化问题的核心是欧拉方程，它决定了今天消费与明天消费之间的最优权衡。对于给定的模型，它是：\n$$\nu'(c_t) = \\beta R u'(c_{t+1})\n$$\n其中 $c_t$ 是当期消费，$c_{t+1}$ 是下一期消费。代理人的效用是 CRRA 形式，这意味着边际效用函数为 $u'(c) = c^{-\\sigma}$。将其代入欧拉方程，得到：\n$$\nc_t^{-\\sigma} = \\beta R c_{t+1}^{-\\sigma}\n$$\n内生网格法 (EGM) 通过从未来状态网格向后推导来求解策略函数 $c(m)$。在此背景下，$c_t$ 对应于我们希望找到的内生当期消费，我们将其表示为 $c^{\\text{endo}}$。未来消费 $c_{t+1}$ 由当前猜测的策略函数 $c^{\\text{old}}$ 在下一期手头现金 $m'$ 处的值决定。因此，$c_{t+1} = c^{\\text{old}}(m')$。欧拉方程变为：\n$$\n(c^{\\text{endo}})^{-\\sigma} = \\beta R \\left( c^{\\text{old}}(m') \\right)^{-\\sigma}\n$$\n为了找到今天消费 $c^{\\text{endo}}$ 的正确表达式，我们通过将两边都取 $-1/\\sigma$ 次幂来求解它：\n$$\n\\left( (c^{\\text{endo}})^{-\\sigma} \\right)^{-1/\\sigma} = \\left( \\beta R \\left( c^{\\text{old}}(m') \\right)^{-\\sigma} \\right)^{-1/\\sigma}\n$$\n$$\nc^{\\text{endo}} = \\left( \\beta R \\right)^{-1/\\sigma} \\left( \\left(c^{\\text{old}}(m') \\right)^{-\\sigma} \\right)^{-1/\\sigma}\n$$\n$$\nc^{\\text{endo}} = \\left( \\beta R \\right)^{-1/\\sigma} c^{\\text{old}}(m')\n$$\n或者，更直接地用于实现，我们可以将其写为：\n$$\nc^{\\text{endo}} = \\left[ \\beta R \\cdot u'(c^{\\text{old}}(m')) \\right]^{-1/\\sigma}\n$$\n现在，我们将这个正确的推导与问题陈述中步骤 4 提供的表达式进行比较：\n$$\nc^{\\text{endo}}_i = \\left(R \\cdot u'(c^{\\text{old}}(m'_i))\\right)^{-1/\\sigma} \\quad (\\text{错误的步骤 4})\n$$\n逻辑错误立即可见：错误的步骤**忽略了折扣因子 $\\beta$**。\n\n这个错误的经济学含义是显著的。代理人计划消费时，表现得比其偏好所指示的更有耐心。通过忽略 $\\beta \\in (0,1)$，代理人的行为实际上如同 $\\beta=1$ 一样，没有对未来的边际效用进行折现。这导致了不正确的跨期配置，即对于任何给定的未来消费水平，使用错误规则的代理人今天会储蓄更多（消费更少）。这种与最优行为的偏离将表现为非零的欧拉方程残差。\n\n**2. 算法实现策略**\n\n将基于 EGM 实现两个求解器，“错误的”和“修正的”。两者将遵循相同的迭代过程，仅在步骤 4 中使用的方程有所不同。\n\n单次 EGM 迭代的算法如下：\n1.  **定义网格**：在 $[0, \\bar a]$ 上定义一个下一期资产的外生网格 $\\{a'_i\\}_{i=1}^N$。在 $[y, \\bar m]$ 上定义一个当期手头现金的固定网格 $\\{m_j\\}_{j=1}^M$，其中 $\\bar m = R \\bar a + y$。\n2.  **初始策略**：从消费策略的初始猜测 $c^{\\text{old}}(m)$ 开始。一个稳健的选择是 $c^{\\text{old}}(m) = m$。\n3.  **迭代循环**：重复直至策略函数收敛。\n    a.  **下一期状态**：对于资产网格上的每个点 $a'_i$，计算相应的下一期手头现金：$m'_i = R a'_i + y$。\n    b.  **下一期消费**：使用当前的策略猜测 $c^{\\text{old}}$，找到每个 $m'_i$ 处的消费。这需要对定义在固定网格 $\\{m_j\\}$ 上的 $c^{\\text{old}}$ 在点 $\\{m'_i\\}$ 处进行插值。\n    c.  **反转欧拉方程**：使用欧拉方程找到与每个 $a'_i$ 对应的当期消费 $c^{\\text{endo}}_i$。\n        -   **修正的求解器**：$c^{\\text{endo}}_i = \\left[ \\beta R \\cdot (c^{\\text{old}}(m'_i))^{-\\sigma} \\right]^{-1/\\sigma}$。\n        -   **错误的求解器**：$c^{\\text{endo}}_i = \\left[ R \\cdot (c^{\\text{old}}(m'_i))^{-\\sigma} \\right]^{-1/\\sigma}$。\n    d.  **内生网格**：构建当期手头现金的内生网格：$m^{\\text{endo}}_i = c^{\\text{endo}}_i + a'_i$。这将创建一组满足欧拉方程的点对 $(m^{\\text{endo}}_i, c^{\\text{endo}}_i)$。\n    e.  **更新策略函数**：在固定网格 $\\{m_j\\}$ 上构建新的策略 $c^{\\text{new}}$。\n        i.  对点对 $(m^{\\text{endo}}_i, c^{\\text{endo}}_i)$ 进行线性插值，以找到在固定网格 $\\{m_j\\}$ 上的消费值。对于超出 $\\{m^{\\text{endo}}_i\\}$ 范围的点，使用线性外推。\n        ii. 处理借贷约束：对于任何低于最低内生网格点 ($m_j  m^{\\text{endo}}_1$) 的 $m_j$，代理人受到约束并消费所有资源。因此，设置 $c^{\\text{new}}(m_j) = m_j$。\n        iii. 强制可行性：确保对所有 $j$ 都有 $c^{\\text{new}}(m_j) \\le m_j$。\n    f.  **收敛检查**：计算新旧策略之间差异的上确界范数，$\\max_j |c^{\\text{new}}(m_j) - c^{\\text{old}}(m_j)|$。如果此差异低于容差（例如，$10^{-8}$），则达到收敛。否则，设置 $c^{\\text{old}} = c^{\\text{new}}$ 并开始下一次迭代。\n\n对于给定的参数化，此 EGM 实现是稳定的，不需要使用阻尼。\n\n**3. 欧拉残差计算**\n\n在获得收敛的策略函数 $c(m)$ 后，通过计算欧拉残差 $\\mathcal{R}(m)$ 在评估网格 $\\{m_j\\}$ 上的上确界范数来评估其准确性。对于网格上的每个 $m_j$：\n1.  计算当期消费 $c_j = c(m_j)$ 和下一期资产 $a'_{j} = m_j - c_j$。\n2.  如果借贷约束不生效 ($a'_{j} > 10^{-10}$)，则计算下一期手头现金 $m'_{j} = R a'_{j} + y$ 和下一期消费 $c'_{j} = c(m'_{j})$。然后残差为 $|\\left(c_j\\right)^{-\\sigma} - \\beta R \\left(c'_{j}\\right)^{-\\sigma}|$。\n3.  如果约束生效 ($a'_{j} \\le 10^{-10}$)，则残差定义为 $0$。\n所有 $j$ 中这些值的最大值是最终的误差度量。\n\n对于每个测试案例，上述概述的程序将对错误的和修正的求解器都进行实现，以确定最终的布尔结果。",
            "answer": "```python\nimport numpy as np\nfrom scipy.interpolate import interp1d\n\ndef solve():\n    \"\"\"\n    Solves the consumption-savings problem using both broken and corrected EGM,\n    and evaluates the results based on Euler residuals.\n    \"\"\"\n\n    def egm_solver(beta, R, sigma, y, a_bar, N, M, is_broken):\n        \"\"\"\n        Iteratively solves for the consumption policy function using the EGM.\n\n        Args:\n            beta (float): Discount factor.\n            R (float): Gross interest rate.\n            sigma (float): CRRA parameter.\n            y (float): Constant income.\n            a_bar (float): Upper bound for the asset grid.\n            N (int): Number of points in the asset grid.\n            M (int): Number of points in the cash-on-hand grid.\n            is_broken (bool): If True, uses the flawed Euler equation update.\n\n        Returns:\n            tuple: A tuple containing the cash-on-hand grid (np.ndarray) and the\n                   converged consumption policy (np.ndarray).\n        \"\"\"\n        max_iter = 800\n        tol = 1.0e-8\n\n        # Step 1: Set up grids\n        a_prime_grid = np.linspace(0.0, a_bar, N)\n        m_bar = R * a_bar + y\n        m_grid = np.linspace(y, m_bar, M)\n\n        # Initial guess for the policy function: consume everything\n        c_policy = m_grid.copy()\n\n        for _ in range(max_iter):\n            c_old_policy = c_policy.copy()\n            c_old_interp = interp1d(\n                m_grid, c_old_policy, kind='linear',\n                fill_value=\"extrapolate\", bounds_error=False\n            )\n\n            # Step 2: Next period resources\n            m_prime = R * a_prime_grid + y\n            \n            # Step 3: Next period consumption and marginal utility\n            c_at_m_prime = c_old_interp(m_prime)\n            # Ensure consumption is positive for marginal utility calculation\n            c_at_m_prime[c_at_m_prime = 1.0e-14] = 1.0e-14\n            marg_util_at_m_prime = c_at_m_prime**(-sigma)\n\n            # Step 4: Current consumption from Euler equation (broken or correct)\n            if is_broken:\n                c_endo = (R * marg_util_at_m_prime)**(-1.0 / sigma)\n            else:\n                c_endo = (beta * R * marg_util_at_m_prime)**(-1.0 / sigma)\n\n            # Step 5: Endogenous current resources\n            m_endo = c_endo + a_prime_grid\n            \n            # Step 6: Interpolate to get new policy on the fixed m-grid\n            c_new_interp = interp1d(\n                m_endo, c_endo, kind='linear',\n                fill_value=\"extrapolate\", bounds_error=False\n            )\n            c_policy = c_new_interp(m_grid)\n\n            # Enforce borrowing constraint for m below the first endogenous point\n            borrowing_constrained = m_grid  m_endo[0]\n            c_policy[borrowing_constrained] = m_grid[borrowing_constrained]\n\n            # Enforce physical constraint c(m) = m\n            c_policy = np.minimum(c_policy, m_grid)\n\n            # Check for convergence\n            diff = np.max(np.abs(c_policy - c_old_policy))\n            if diff  tol:\n                break\n        \n        return m_grid, c_policy\n\n    def calculate_euler_residual(policy_func, m_grid, beta, R, sigma, y):\n        \"\"\"\n        Calculates the supremum norm of the Euler equation residual.\n\n        Args:\n            policy_func (np.ndarray): The converged consumption policy.\n            m_grid (np.ndarray): The cash-on-hand grid.\n            beta, R, sigma, y (float): Model parameters.\n\n        Returns:\n            float: The max absolute Euler residual.\n        \"\"\"\n        c_interp = interp1d(\n            m_grid, policy_func, kind='linear',\n            fill_value=\"extrapolate\", bounds_error=False\n        )\n\n        c_at_m = policy_func\n        a_prime = m_grid - c_at_m\n\n        residuals = np.zeros_like(m_grid)\n        \n        # Evaluate residual only where the borrowing constraint doesn't bind\n        not_binding_mask = a_prime > 1.0e-10\n        m_eval = m_grid[not_binding_mask]\n        c_eval = c_at_m[not_binding_mask]\n        a_prime_eval = a_prime[not_binding_mask]\n\n        if m_eval.size > 0:\n            m_prime_eval = R * a_prime_eval + y\n            c_at_m_prime_eval = c_interp(m_prime_eval)\n            \n            # Ensure consumption values are positive\n            c_eval[c_eval = 1.0e-14] = 1.0e-14\n            c_at_m_prime_eval[c_at_m_prime_eval = 1.0e-14] = 1.0e-14\n\n            marg_util_now = c_eval**(-sigma)\n            marg_util_future = c_at_m_prime_eval**(-sigma)\n            \n            residual_values = np.abs(marg_util_now - beta * R * marg_util_future)\n            residuals[not_binding_mask] = residual_values\n\n        return np.max(residuals)\n\n    test_cases = [\n        # Case A\n        {'beta': 0.96, 'R': 1.04, 'sigma': 2.0, 'y': 1.0, 'a_bar': 50.0, 'N': 300, 'M': 400},\n        # Case B\n        {'beta': 0.90, 'R': 1.04, 'sigma': 3.0, 'y': 1.0, 'a_bar': 50.0, 'N': 300, 'M': 400},\n        # Case C\n        {'beta': 0.995, 'R': 1.004, 'sigma': 2.0, 'y': 1.0, 'a_bar': 60.0, 'N': 300, 'M': 500},\n    ]\n\n    results = []\n    for params in test_cases:\n        # Run broken solver and calculate its residual\n        m_grid_b, policy_b = egm_solver(**params, is_broken=True)\n        res_brok = calculate_euler_residual(policy_b, m_grid_b, **{k:v for k,v in params.items() if k in ['beta','R','sigma','y']})\n\n        # Run corrected solver and calculate its residual\n        m_grid_c, policy_c = egm_solver(**params, is_broken=False)\n        res_corr = calculate_euler_residual(policy_c, m_grid_c, **{k:v for k,v in params.items() if k in ['beta','R','sigma','y']})\n\n        # Evaluate the condition\n        condition_met = (res_corr  1.0e-5) and \\\n                        (res_brok >= 1.0e-3) and \\\n                        (res_brok >= 10.0 * res_corr)\n        results.append(condition_met)\n\n    # Format and print the final output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "掌握了核心更新步骤后，我们将其应用到一个完整的、多周期的生命周期模型中。本练习要求您使用EGM，通过反向归纳法来求解一个包含遗赠动机的消费储蓄问题。您将学习如何处理非平凡的最终期条件，并完整地求解出代理人在整个生命周期中的最优决策路径，从而体验EGM在解决有限期界动态问题时的威力 。",
            "id": "2440058",
            "problem": "要求您为一个生命终点具有遗赠动机的有限期、确定性消费-储蓄生命周期模型实施 Endogenous Grid Method (EGM)。代理人生命周期为 $T$ 个消费期，由 $t \\in \\{0,1,\\ldots,T-1\\}$ 索引。其面临预算约束 $c_t + a_{t+1} = R a_t + y_t$，其中 $a_{t+1} \\ge \\underline{a}$，且初始资产 $a_0$ 为给定值。其偏好由下式给出：\n$$\n\\sum_{t=0}^{T-1} \\beta^{t} u(c_t) + \\beta^{T} \\phi(a_T),\n$$\n其中，当 $\\gamma \\ne 1$ 时，$u(c) = \\frac{c^{1-\\gamma}}{1-\\gamma}$，而 $\\phi(a)$ 则捕捉了遗赠动机。您将分析遗赠动机在整个生命周期中如何影响储蓄。\n\n基本和核心定义：\n- 期间预算约束为 $c_t + a_{t+1} = R a_t + y_t$，其中 $R$ 是总利率因子，$y_t$ 是外生收入。\n- 借贷约束为 $a_{t+1} \\ge \\underline{a}$，其中 $\\underline{a} \\in \\mathbb{R}$。\n- 代理人的目标是选择 $\\{c_t,a_{t+1}\\}_{t=0}^{T-1}$ 以在约束条件下最大化 $\\sum_{t=0}^{T-1} \\beta^{t} u(c_t) + \\beta^{T} \\phi(a_T)$。\n- 在内点解选择和无不确定性情况下的一阶条件（欧拉方程）如下：\n  - 对于 $t \\in \\{0,1,\\ldots,T-2\\}$：$u'(c_t) = \\beta R u'(c_{t+1})$。\n  - 在 $t = T-1$ 时，对于期末遗赠 $\\phi(a_T)$：$u'(c_{T-1}) = \\beta \\phi'(a_T)$。\n- 为每个时期 $t$ 定义 Endogenous Grid Method 映射，方法是：选择一个关于 $a_{t+1}$ 的网格，使用边际效用 $u'(\\cdot)$ 的逆函数从欧拉方程计算出 $c_t$，然后构建手头现金 $m_t = a_{t+1} + c_t$ 的内生网格。当欧拉方程所蕴含的选择会违反借贷约束时，通过强制执行 $a_{t+1} = \\underline{a}$ 来处理该约束。\n\n待实现的模型设定：\n- 偏好：\n  - $u(c) = \\frac{c^{1-\\gamma}}{1-\\gamma}$，其中 $\\gamma  0$ 且 $\\gamma \\ne 1$。\n  - $\\phi(a) = \\kappa \\cdot \\frac{(a + b)^{1-\\nu} - b^{1-\\nu}}{1-\\nu}$，其中 $\\nu  0$，$\\kappa \\ge 0$，且 $b  0$；因此 $\\phi'(a) = \\kappa \\cdot (a+b)^{-\\nu}$。\n- 技术和收入：\n  - 总利率因子 $R  0$ 在所有时期 $t$ 保持不变。\n  - 确定性收入序列 $\\{y_t\\}_{t=0}^{T-1}$ 是给定的。\n- 约束：\n  - 借贷限制 $\\underline{a}$ 是固定的，并满足 $\\underline{a} \\le 0$；在下文的测试套件中，它将被设置为 $\\underline{a} = 0$。\n- 时期与时点：\n  - 共有 $T$ 个消费期。遗赠项 $\\beta^{T} \\phi(a_T)$ 取决于在 $t = T-1$ 期选择的 $a_T$；在 $t = T-1$ 之后的最终日期没有消费。\n\n算法任务：\n- 使用 Endogenous Grid Method，通过逆向归纳法，在每个时期 $t$ 基于 $a_{t+1}$ 的网格计算策略函数 $\\{c_t(m_t)\\}_{t=0}^{T-1}$。\n- 在 $t = T-1$ 时，使用欧拉条件 $u'(c_{T-1}) = \\beta \\phi'(a_T)$，从 $a_T$ 的网格计算内生的 $m_{T-1} = a_T + c_{T-1}$。如果 $\\kappa = 0$ 从而 $\\phi'(a_T) = 0$，则内点欧拉方程不成立，借贷约束将具有约束力：$a_T = \\underline{a}$ 且 $c_{T-1} = m_{T-1} - \\underline{a}$。\n- 对于 $t \\le T-2$，给定 $c_{t+1}(\\cdot)$，为每个网格点 $a_{t+1}$ 计算下一期资源 $m_{t+1} = R a_{t+1} + y_{t+1}$，并使用 $u'(c_t) = \\beta R u'(c_{t+1}(m_{t+1}))$ 来获得 $c_t$，进而得到 $m_t = a_{t+1} + c_t$。按要求对较低的 $m_t$ 值强制执行 $a_{t+1} = \\underline{a}$ 以处理借贷约束。\n\n模拟与分析：\n- 计算出策略函数后，从 $a_0$ 和给定的收入序列开始，模拟资产和消费的生命周期路径，以获得 $\\{a_{t+1}\\}_{t=0}^{T-1}$ 和 $\\{c_t\\}_{t=0}^{T-1}$。将时期 $t$ 的储蓄定义为 $a_{t+1}$。\n- 对于下文测试套件中的每个参数集，报告整个生命周期的平均储蓄，\n$$\n\\bar{s} = \\frac{1}{T} \\sum_{t=0}^{T-1} a_{t+1},\n$$\n结果应为一个实数。\n\n测试套件：\n在所有测试中使用以下共同元素：\n- 时期 $T = 5$。\n- 利率因子 $R = 1.03$。\n- 贴现因子 $\\beta$ 将根据下文指定的测试用例而变化。\n- 消费的相对风险规避系数 $\\gamma = 2$。\n- 遗赠曲率 $\\nu = 2$。\n- 遗赠平移项 $b = 0.01$。\n- 借贷限制 $\\underline{a} = 0$。\n- 初始资产 $a_0 = 0$。\n- 确定性收入序列 $\\{y_t\\}_{t=0}^{4} = \\{1.0, 1.0, 0.8, 0.6, 0.5\\}$。\n\n定义四个测试用例，它们在遗赠强度 $\\kappa$ 和跨期贴现因子 $\\beta$ 上有所不同：\n1. 案例 A（基准，无遗赠）：$\\kappa = 0.0$，$\\beta = 0.96$。\n2. 案例 B（中等遗赠）：$\\kappa = 0.5$，$\\beta = 0.96$。\n3. 案例 C（强遗赠）：$\\kappa = 2.0$，$\\beta = 0.96$。\n4. 案例 D（中等遗赠，更不耐心）：$\\kappa = 0.5$，$\\beta = 0.90$。\n\n数值要求：\n- 使用 Endogenous Grid Method 实现，其中 $a_{t+1}$ 的网格在 $[\\underline{a}, a_{\\max}]$ 区间上至少包含 $200$ 个等距点，$a_{\\max}$ 需足够大以避免最优选择被截断。在您的程序中，选择一个对所有测试用例在数值上都足够的固定 $a_{\\max}$。\n- 使用线性插值来评估网格外的 $c_{t+1}(m_{t+1})$。\n- 当 $m_{t+1}$ 或 $m_t$ 低于欧拉方程所蕴含的最小内生手头现金值时，施加借贷约束 $a_{t+1} = \\underline{a}$，从而使得 $c_t = m_t - \\underline{a}$。\n\n最终输出规范：\n- 对于每个测试用例，计算上文定义的 $\\bar{s}$，并按 $[\\bar{s}_A, \\bar{s}_B, \\bar{s}_C, \\bar{s}_D]$ 的顺序返回包含这四个实数的列表。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，$[x_1,x_2,x_3,x_4]$）。不应打印任何额外文本。\n- 此问题不涉及物理单位。所有数值输出必须是十进制表示的实数。",
            "solution": "用户提供了一个来自计算经济学领域的、科学上有效且定义明确的问题。任务是使用 Endogenous Grid Method (EGM) 求解一个有限期、确定性的消费-储蓄生命周期模型，并分析遗赠动机对储蓄的影响。我将着手提供一个完整的解决方案。\n\n代理人的目标是最大化生命周期效用，其由下式给出：\n$$\n\\sum_{t=0}^{T-1} \\beta^{t} u(c_t) + \\beta^{T} \\phi(a_T)\n$$\n消费效用函数为恒定相对风险规避 (CRRA) 形式，$u(c) = \\frac{c^{1-\\gamma}}{1-\\gamma}$，这意味着边际效用为 $u'(c) = c^{-\\gamma}$。因此，逆边际效用函数为 $(u')^{-1}(x) = x^{-1/\\gamma}$。遗赠动机由终端价值函数 $\\phi(a_T)$ 捕捉，其边际效用为 $\\phi'(a_T) = \\kappa (a_T+b)^{-\\nu}$。\n\n代理人在每个时期 $t$ 面临预算约束：$c_t + a_{t+1} = R a_t + y_t$，其中 $m_t = R a_t + y_t$ 是手头现金。存在借贷限制 $a_{t+1} \\ge \\underline{a}$。\n\n该问题使用 Endogenous Grid Method 通过逆向归纳法求解。该方法的核心是利用一阶条件（欧拉方程）从生命终点向起点反向构建消费的策略函数 $c_t(m_t)$。\n\n欧拉方程为：\n1.  对于时期 $t \\in \\{0, 1, \\ldots, T-2\\}$：$u'(c_t) = \\beta R u'(c_{t+1})$。\n2.  对于最终消费期 $t = T-1$：$u'(c_{T-1}) = \\beta \\phi'(a_T)$。\n\n求解过程主要分三个阶段：构建最终时期的策略函数，反向迭代构建所有之前时期的策略函数，以及通过前向模拟找到生命周期路径和平均储蓄。\n\n**1. 最终时期的策略函数 ($t=T-1$)**\n\nEGM 从决策后状态的外生网格开始。对于时期 $t=T-1$，这是一个关于生命周期终点资产 $\\{a_{T,i}\\}_{i=1}^N$ 的网格，该网格建立在区间 $[\\underline{a}, a_{\\max}]$ 上。\n\n- **有遗赠动机的情况 ($\\kappa > 0$)：**\n  使用期末欧拉方程 $u'(c_{T-1}) = \\beta \\phi'(a_T)$。代入函数形式，我们得到 $c_{T-1}^{-\\gamma} = \\beta \\kappa (a_T+b)^{-\\nu}$。对我们网格上的每个点 $a_{T,i}$ 求解消费 $c_{T-1}$：\n  $$\n  c_{T-1,i} = \\left( \\beta \\kappa (a_{T,i}+b)^{-\\nu} \\right)^{-1/\\gamma}\n  $$\n  已知 $c_{T-1,i}$ 和 $a_{T,i}$ 后，我们在一个内生网格上找到相应的决策前状态（手头现金）：$m_{T-1,i} = a_{T,i} + c_{T-1,i}$。这为我们提供了一组点对 $(m_{T-1,i}, c_{T-1,i})$，它们定义了无约束代理人的消费策略。\n\n- **无遗赠动机的情况 ($\\kappa = 0$)：**\n  如果 $\\kappa=0$，则 $\\phi'(a_T)=0$。欧拉方程 $c_{T-1}^{-\\gamma} = 0$ 将意味着无限的消费，这是不可行的。代理人的最优选择是消费所有可用资源，从而达到借贷限额。因此，$a_T = \\underline{a}$，策略函数即为 $c_{T-1}(m_{T-1}) = m_{T-1} - \\underline{a}$。\n\n**2. 最终时期之前的策略函数 ($t  T-1$)**\n\n我们从 $t=T-2$ 反向迭代至 $t=0$。对于每个时期 $t$，我们假设下一时期的策略函数 $c_{t+1}(m_{t+1})$ 是已知的（由上一步计算出的网格表示）。\n\n1.  从一个关于储蓄的外生网格 $\\{a_{t+1,i}\\}_{i=1}^N$ 开始，该网格建立在 $[\\underline{a}, a_{\\max}]$ 上。\n2.  对于每个网格点 $a_{t+1,i}$，计算下一时期的手头现金：$m_{t+1,i} = R a_{t+1,i} + y_{t+1}$。\n3.  评估已知的策略函数 $c_{t+1}(m_{t+1,i})$ 以找到下一时期的消费 $c_{t+1,i}$。这是通过对存储的 $t+1$ 期策略网格进行线性插值来完成的。\n4.  使用跨期欧拉方程 $u'(c_t) = \\beta R u'(c_{t+1})$ 反向求解当期消费 $c_{t,i}$。对于 CRRA 效用，这可以很好地简化为：\n    $$\n    c_{t,i}^{-\\gamma} = \\beta R c_{t+1,i}^{-\\gamma} \\implies c_{t,i} = (\\beta R)^{-1/\\gamma} c_{t+1,i}\n    $$\n5.  构建手头现金的内生网格：$m_{t,i} = a_{t+1,i} + c_{t,i}$。这将产生点对 $(m_{t,i}, c_{t,i})$，它们定义了 $t$ 期无约束代理人的策略。\n\n**3. 处理借贷约束**\n\nEGM 过程自然地生成了无约束选择的策略。对于手头现金较少的代理人，借贷约束 $a_{t+1} \\ge \\underline{a}$ 将具有约束力。他们的消费是 $c_t = m_t - \\underline{a}$。\nEGM 网格以 $a_{t+1,1} = \\underline{a}$ 开始。这对应于一个点 $(m_{t,1}, c_{t,1})$，该点构成了有约束区域和无约束区域之间的“拐点”。策略在该点是连续的。为了创建一个完整的数值策略函数，我们将点 $(\\underline{a}, 0)$ 添加到 EGM 生成的网格 $(m_{t,i}, c_{t,i})$ 的前面。在 $(\\underline{a}, 0)$ 和 $(m_{t,1}, c_{t,1})$ 之间进行线性插值，可以正确地再现有约束区域中的线性策略 $c_t = m_t - \\underline{a}$，因为 $m_{t,1} = \\underline{a} + c_{t,1}$。\n\n**4. 模拟与平均储蓄计算**\n\n在计算出所有策略函数 $\\{c_t(m_t)\\}_{t=0}^{T-1}$ 后，我们从时间上向前模拟代理人的生命周期路径。\n1.  从初始资产 $a_0$ 开始。\n2.  对于 $t = 0, \\ldots, T-1$：\n    -   计算手头现金：$m_t = R a_t + y_t$。\n    -   通过在存储的策略网格上插值来确定消费：$c_t = c_t(m_t)$。\n    -   根据预算约束确定下一期的储蓄：$a_{t+1} = m_t - c_t$。\n3.  模拟得出了储蓄路径 $\\{a_1, a_2, \\ldots, a_T\\}$。最终的度量指标是这些值的平均值：\n    $$\n    \\bar{s} = \\frac{1}{T} \\sum_{t=0}^{T-1} a_{t+1}\n    $$\n实现将为指定的四个测试用例中的每一个执行这些步骤。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the life-cycle model for all test cases and print the results.\n    \"\"\"\n    \n    # Define common parameters across all test cases\n    T = 5\n    R = 1.03\n    gamma = 2.0\n    nu = 2.0\n    b = 0.01\n    underline_a = 0.0\n    a0 = 0.0\n    income = np.array([1.0, 1.0, 0.8, 0.6, 0.5])\n    \n    # Numerical parameters for the Endogenous Grid Method\n    grid_size = 200\n    a_max = 20.0\n    \n    # Define the four test cases by varying bequest strength (kappa) and discount factor (beta)\n    test_cases = [\n        # (kappa, beta)\n        (0.0, 0.96),  # Case A: No bequest motive\n        (0.5, 0.96),  # Case B: Moderate bequest motive\n        (2.0, 0.96),  # Case C: Strong bequest motive\n        (0.5, 0.90),  # Case D: Moderate bequest, more impatient\n    ]\n\n    results = []\n    # Solve the model for each case and store the average savings\n    for kappa, beta in test_cases:\n        avg_savings = solve_one_case(T, R, gamma, nu, b, underline_a, a0, income, \n                                     grid_size, a_max, kappa, beta)\n        results.append(avg_savings)\n\n    # Print the results in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef solve_one_case(T, R, gamma, nu, b, underline_a, a0, income, grid_size, a_max, kappa, beta):\n    \"\"\"\n    Solves the life-cycle model for a single set of parameters using EGM.\n\n    Returns:\n        float: The average savings over the agent's life-cycle.\n    \"\"\"\n    # Exogenous grid for post-decision assets (a_{t+1})\n    a_grid = np.linspace(underline_a, a_max, grid_size)\n    \n    # Dictionary to store the computed policy functions (m_grid, c_grid) for each period\n    policy_functions = {}\n    \n    # --- Backward Induction: Solve for policy functions from T-1 to 0 ---\n    \n    # Period t = T-1 (the final consumption period)\n    t = T - 1\n    if kappa == 0.0:\n        # No bequest motive: agent consumes everything, so a_T = underline_a.\n        # The policy is c_{T-1} = m_{T-1} - underline_a.\n        # We represent this linear policy on a grid for consistency with other periods.\n        # A simple two-point grid is sufficient for linear interpolation.\n        m_grid_t = np.array([underline_a, a_max * R + np.max(income)])\n        c_grid_t = m_grid_t - underline_a\n    else:\n        # With bequest motive, use the terminal Euler equation: u'(c_{T-1}) = beta * phi'(a_T)\n        # Here, a_grid represents the grid for a_T.\n        a_T = a_grid\n        phi_p = kappa * (a_T + b)**(-nu)\n        # Avoid division by zero or negative base if phi_p = 0\n        c_endo_t = np.full_like(a_T, 1e-10) # a small positive value for consumption\n        positive_phi_p_mask = phi_p > 0\n        c_endo_t[positive_phi_p_mask] = (beta * phi_p[positive_phi_p_mask])**(-1.0 / gamma)\n\n        # Compute the endogenous grid for cash-on-hand: m_{T-1} = a_T + c_{T-1}\n        m_endo_t = a_T + c_endo_t\n\n        # Combine with the borrowing-constrained region to form the full policy function.\n        # The constrained policy c = m - underline_a is represented by the point (underline_a, 0).\n        m_grid_t = np.concatenate(([underline_a], m_endo_t))\n        c_grid_t = np.concatenate(([0.0], c_endo_t))\n        \n    policy_functions[t] = (m_grid_t, c_grid_t)\n    \n    # Periods t = T-2 down to 0\n    for t in range(T - 2, -1, -1):\n        m_grid_t_plus_1, c_grid_t_plus_1 = policy_functions[t + 1]\n        \n        # Here, a_grid represents the grid for a_{t+1}\n        a_t_plus_1 = a_grid\n        \n        # 1. Calculate next-period cash-on-hand for each point on the a_{t+1} grid\n        m_t_plus_1 = R * a_t_plus_1 + income[t + 1]\n        \n        # 2. Interpolate on the next-period policy function to find c_{t+1}\n        c_t_plus_1 = np.interp(m_t_plus_1, m_grid_t_plus_1, c_grid_t_plus_1)\n        \n        # 3. Use the intertemporal Euler equation to find current consumption c_t\n        # For CRRA utility, this simplifies to c_t = (beta * R)^(-1/gamma) * c_{t+1}\n        c_endo_t = (beta * R)**(-1.0 / gamma) * c_t_plus_1\n        \n        # 4. Compute the endogenous grid for cash-on-hand m_t\n        m_endo_t = a_t_plus_1 + c_endo_t\n        \n        # Add the borrowing-constrained region\n        m_grid_t = np.concatenate(([underline_a], m_endo_t))\n        c_grid_t = np.concatenate(([0.0], c_endo_t))\n        \n        policy_functions[t] = (m_grid_t, c_grid_t)\n        \n    # --- Forward Simulation: Calculate the life-cycle path of assets ---\n    \n    a_path = np.zeros(T + 1)\n    a_path[0] = a0\n    \n    for t in range(T):\n        # Calculate current period's cash-on-hand\n        m_t = R * a_path[t] + income[t]\n        \n        # Get the policy function for the current period\n        m_grid_t, c_grid_t = policy_functions[t]\n        \n        # Evaluate the policy function to get consumption\n        c_t = np.interp(m_t, m_grid_t, c_grid_t)\n        \n        # Calculate next period's assets from the budget constraint\n        a_path[t + 1] = m_t - c_t\n        \n    # The problem defines savings as {a_1, ..., a_T}.\n    # Calculate the average of these savings.\n    avg_savings = np.mean(a_path[1:])\n    \n    return avg_savings\n\n# Execute the main function when the script is run\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "实现一个算法是一回事，而验证其解的可靠性则是另一项关键技能。最后一个练习将聚焦于数值解的验证，这是一个计算经济学从业者的核心素养。我们将探讨外生网格的设置如何影响最终解的准确性，并学习使用欧拉方程残差等标准度量来量化我们EGM实现的质量 。",
            "id": "2440083",
            "problem": "考虑一个有借贷约束的两期消费储蓄问题，偏好为恒定相对风险厌恶（CRRA）类型。代表性代理人的时期效用函数为 $u(c) = \\frac{c^{1-\\gamma}}{1-\\gamma}$，其中风险厌恶参数 $\\gamma  0$，折扣因子 $\\beta \\in (0,1)$，总回报因子 $R  0$。资产根据预算约束演变\n$c_1 + a_2 = R a_1 + y_1$ 和 $c_2 + a_3 = R a_2 + y_2$，并有借贷约束 $a_{t+1} \\ge a_{\\min}$ 对所有 $t$ 成立。不存在遗赠动机，因此期末资产满足 $a_3 = a_{\\min}$。初始资产 $a_1$ 是一个通用状态变量，且 $a_{\\min} = 0$。第1期的收入是确定性的，等于 $y_1  0$。第2期的收入是随机的，以概率 $\\pi \\in (0,1)$ 取值为 $y_L  0$，以概率 $1 - \\pi$ 取值为 $y_H  0$。\n\n第1期的一阶最优性条件（欧拉方程）为\n$$\nu'(c_1) = \\beta R \\,\\mathbb{E}\\left[ u'(c_2) \\right],\n$$\n其中 $u'(c) = c^{-\\gamma}$，并且因为 $a_3 = a_{\\min} = 0$，所以 $c_2 = R a_2 + y_2$。\n\n对于第1期期末资产的任意一个外生网格 $\\{a_{2,i}\\}_{i=1}^N$（其中每个 $a_{2,i} \\ge a_{\\min}$），通过预算约束和欧拉方程生成的映射，定义第1期期初资产的隐含内生网格：\n1. 对于每个 $a_{2,i}$，将 $c_1(a_{2,i})$ 定义为以下方程的唯一正解：\n$$\nu'\\left(c_1(a_{2,i})\\right) = \\beta R \\left[ \\pi \\, u'\\left(R a_{2,i} + y_L\\right) + (1-\\pi) \\, u'\\left(R a_{2,i} + y_H\\right) \\right].\n$$\n2. 通过第1期的预算约束定义 $a_1(a_{2,i})$，\n$$\na_1(a_{2,i}) = \\frac{a_{2,i} + c_1(a_{2,i}) - y_1}{R}.\n$$\n因为在所述假设下 $a_1(\\cdot)$ 是严格递增的，图 $\\{(a_1(a_{2,i}), c_1(a_{2,i}))\\}_{i=1}^N$ 可以被解释为在 $a_1$ 的内生网格上的一个隐含策略函数。对于任何位于 $\\{a_1(a_{2,i})\\}_{i=1}^N$ 凸包内的参数 $a_1$，通过对这些有序对进行线性插值来定义策略值 $c_1(a_1)$。\n\n精度指标。给定一个固定的 $a_1$ 评估网格 $\\mathcal{A} \\subset \\mathbb{R}_+$，定义：\n- 在任何被覆盖的 $a_1 \\in \\mathcal{A}$（即插值域内的任何 $a_1$）处的欧拉残差为\n$$\n\\varepsilon(a_1) \\;=\\; u'\\big(c_1(a_1)\\big) \\;-\\; \\beta R \\left[ \\pi \\, u'\\!\\left(R \\tilde{a}_2(a_1) + y_L\\right) + (1-\\pi)\\, u'\\!\\left(R \\tilde{a}_2(a_1) + y_H\\right) \\right],\n$$\n其中 $\\tilde{a}_2(a_1) = R a_1 + y_1 - c_1(a_1)$ 从第1期的预算约束得出。\n- 在被覆盖点上的最大绝对欧拉残差：\n$$\nE_{\\max} = \\max_{a_1 \\in \\mathcal{A} \\cap \\mathrm{dom}(c_1)} \\left| \\varepsilon(a_1) \\right|.\n$$\n- 一个高分辨率基准策略 $c_1^\\star(a_1)$，它是通过使用一个密集的、有 $N^\\star$ 个点的外生网格 $\\{a_{2,j}^\\star\\}_{j=1}^{N^\\star}$（其中 $N^\\star$ 很大）并采用相同构造方法得到的。定义在被覆盖点（即同时位于两种构造方法的插值域中的点 $a_1 \\in \\mathcal{A}$）上的最大绝对策略偏差：\n$$\nC_{\\max} = \\max_{a_1 \\in \\mathcal{A} \\cap \\mathrm{dom}(c_1) \\cap \\mathrm{dom}(c_1^\\star)} \\left| c_1(a_1) - c_1^\\star(a_1) \\right|.\n$$\n- 覆盖率 $\\kappa \\in [0,1]$，定义为评估网格 $\\mathcal{A}$ 中被隐含策略 $c_1(a_1)$ 的插值域所覆盖的点的比例。\n\n所有测试通用的固定参数：$\\beta = 0.96$, $R = 1.03$, $y_1 = 1.0$, $y_L = 0.5$, $y_H = 1.5$, $\\pi = 0.5$, $a_{\\min} = 0$。$a_1$ 的评估网格是均匀网格 $\\mathcal{A} = \\{0, \\Delta, 2\\Delta, \\dots, A_{\\max}\\}$，其中 $A_{\\max} = 10.0$，有 $500$ 个等距点（即 $\\Delta = A_{\\max}/(500-1)$）。高分辨率基准使用 $N^\\star = 5000$ 个点，并且对每个测试用例，其 $a_2$ 的范围与下文指定的一致。\n\n测试套件。对于每个测试用例，外生网格 $\\{a_{2,i}\\}_{i=1}^N$ 在区间 $[a_{2,\\min}, a_{2,\\max}]$ 上定义如下：\n- 线性网格：$a_{2,i} = a_{2,\\min} + \\frac{i-1}{N-1}\\,(a_{2,\\max} - a_{2,\\min})$，对于 $i \\in \\{1,\\dots,N\\}$。\n- 二次网格（在 $a_{2,\\min}$ 附近集中）：$a_{2,i} = a_{2,\\min} + \\left(\\frac{i-1}{N-1}\\right)^2 (a_{2,\\max} - a_{2,\\min})$，对于 $i \\in \\{1,\\dots,N\\}$。\n\n评估以下四种情况，每种情况产生一个指标三元组 $[E_{\\max}, C_{\\max}, \\kappa]$：\n1.  情况1：$\\gamma = 2.0$，线性网格， $N = 200$， $a_{2,\\min} = 0.0$， $a_{2,\\max} = 10.0$。\n2.  情况2：$\\gamma = 2.0$，线性网格， $N = 10$， $a_{2,\\min} = 0.0$， $a_{2,\\max} = 10.0$。\n3.  情况3：$\\gamma = 2.0$，线性网格， $N = 200$， $a_{2,\\min} = 0.0$， $a_{2,\\max} = 2.0$。\n4.  情况4：$\\gamma = 5.0$，二次网格， $N = 200$， $a_{2,\\min} = 0.0$， $a_{2,\\max} = 10.0$。\n\n最终输出格式。您的程序应生成单行输出，其中包含结果，格式为一个逗号分隔的四个三元组列表，并用方括号括起来，每个数字都以小数形式打印。因此，格式是一个列表的列表：\n$[[E_{\\max}^{(1)}, C_{\\max}^{(1)}, \\kappa^{(1)}],[E_{\\max}^{(2)}, C_{\\max}^{(2)}, \\kappa^{(2)}],[E_{\\max}^{(3)}, C_{\\max}^{(3)}, \\kappa^{(3)}],[E_{\\max}^{(4)}, C_{\\max}^{(4)}, \\kappa^{(4)}]]$。",
            "solution": "所提供的问题陈述已经过验证，并被认定为有效。这是一个在计算经济学中定义明确、有科学依据且自成一体的练习。任务是为一个两期消费储蓄问题实现内生网格法（EGM），并评估其在不同参数化下的精度。\n\n该模型的特点是代表性代理人具有恒定相对风险厌恶（CRRA）效用函数 $u(c) = \\frac{c^{1-\\gamma}}{1-\\gamma}$，其中 $\\gamma  0$ 是相对风险厌恶系数。代理人旨在最大化期望终身效用，同时受一系列预算约束的限制。问题的核心在于求解第1期的欧拉方程：\n$$\nu'(c_1) = \\beta R \\,\\mathbb{E}\\left[ u'(c_2) \\right]\n$$\n其中 $u'(c) = c^{-\\gamma}$ 是消费的边际效用，$\\beta$ 是折扣因子，$R$ 是总无风险利率。给定终端条件 $a_3 = a_{\\min} = 0$，第2期的消费为 $c_2 = R a_2 + y_2$，其中 $y_2$ 是一个随机的收入抽取。\n\n求解过程如前所述，通过实现内生网格法来进行。\n\n1.  **核心算法步骤：内生网格映射**\n    EGM 从决策后状态的网格开始向后求解。我们从一个第1期期末资产的外生网格 $\\{a_{2,i}\\}_{i=1}^N$ 开始，其中每个 $a_{2,i} \\ge a_{\\min} = 0$。对于每个网格点 $a_{2,i}$，我们可以找到满足欧拉方程的唯一第1期消费水平 $c_1(a_{2,i})$。将 CRRA 边际效用函数和对两种收入状态（$y_L, y_H$）的期望代入欧拉方程，得到：\n    $$\n    \\left(c_1(a_{2,i})\\right)^{-\\gamma} = \\beta R \\left[ \\pi \\left(R a_{2,i} + y_L\\right)^{-\\gamma} + (1-\\pi) \\left(R a_{2,i} + y_H\\right)^{-\\gamma} \\right]\n    $$\n    此方程可以直接解出 $c_1(a_{2,i})$：\n    $$\n    c_1(a_{2,i}) = \\left( \\beta R \\left[ \\pi (R a_{2,i} + y_L)^{-\\gamma} + (1-\\pi) (R a_{2,i} + y_H)^{-\\gamma} \\right] \\right)^{-1/\\gamma}\n    $$\n    确定了 $c_1(a_{2,i})$ 后，通过重新整理第1期的预算约束 $c_1 + a_2 = R a_1 + y_1$，可以找到相应的期初资产水平 $a_1(a_{2,i})$：\n    $$\n    a_1(a_{2,i}) = \\frac{a_{2,i} + c_1(a_{2,i}) - y_1}{R}\n    $$\n    这个过程产生了一组数对 $\\{(a_1(a_{2,i}), c_1(a_{2,i}))\\}_{i=1}^N$。由于从 $a_2$ 到 $a_1$ 的映射是严格递增的，这些数对在内生网格 $\\{a_1(a_{2,i})\\}_{i=1}^N$ 上定义了一个近似的策略函数 $c_1(a_1)$。对于该内生网格范围内的任何 $a_1$ 值，策略通过线性插值进行评估。\n\n2.  **精度指标计算**\n    为了评估使用大小为 $N$ 的网格生成的近似策略函数 $c_1(a_1)$ 的精度，我们在状态变量 $a_1$ 的一个固定的、精细的评估网格 $\\mathcal{A}$ 上计算三个指标。\n\n    -   **基准策略 $c_1^\\star(a_1)$**：首先使用相同的 EGM 流程，但使用一个非常大的网格点数 $N^\\star = 5000$ 来构建一个高分辨率的基准策略。基准策略的外生网格使用与其进行比较的测试用例相同的范围 $[a_{2,\\min}, a_{2,\\max}]$ 和类型（线性或二次）。\n\n    -   **覆盖率 ($\\kappa$)**：插值策略函数 $c_1(a_1)$ 的定义域是 $[\\min(\\{a_{1,i}\\}), \\max(\\{a_{1,i}\\})]$。覆盖率 $\\kappa$ 是评估网格 $\\mathcal{A}$ 中落在此定义域内的点的比例。\n\n    -   **最大绝对策略偏差 ($C_{\\max}$)**：此指标衡量测试策略与基准策略之间的差异。对于每个同时位于 $c_1(a_1)$ 和 $c_1^\\star(a_1)$ 定义域交集内的点 $a_1 \\in \\mathcal{A}$，我们计算绝对偏差 $|c_1(a_1) - c_1^\\star(a_1)|$。$C_{\\max}$ 是这些偏差的最大值。\n\n    -   **最大绝对欧拉残差 ($E_{\\max}$)**：此指标衡量近似策略满足原始欧拉方程的程度。对于测试策略定义域所覆盖的每个点 $a_1 \\in \\mathcal{A}$，我们计算：\n        1.  插值得到的消费 $c_1(a_1)$。\n        2.  隐含的期末资产 $\\tilde{a}_2(a_1) = R a_1 + y_1 - c_1(a_1)$。\n        3.  欧拉方程残差：\n            $$\n            \\varepsilon(a_1) = \\left(c_1(a_1)\\right)^{-\\gamma} - \\beta R \\left[ \\pi (R \\tilde{a}_2(a_1) + y_L)^{-\\gamma} + (1-\\pi) (R \\tilde{a}_2(a_1) + y_H)^{-\\gamma} \\right]\n            $$\n        $E_{\\max}$ 是在所有这些被覆盖点上绝对值 $|\\varepsilon(a_1)|$ 的最大值。\n\n将此完整过程系统地应用于问题中指定的四个测试用例，并收集得到的指标三元组 $[E_{\\max}, C_{\\max}, \\kappa]$。实现过程使用标准的数值库来执行网格生成、向量化计算和线性插值。",
            "answer": "```python\nimport numpy as np\n\n# Fixed parameters common to all tests\nBETA = 0.96\nR = 1.03\nY1 = 1.0\nY_L, Y_H = 0.5, 1.5\nPI = 0.5\nA_MIN = 0.0\n\n# Evaluation grid for a1\nA_MAX_EVAL = 10.0\nN_EVAL = 500\nA1_EVAL_GRID = np.linspace(0.0, A_MAX_EVAL, N_EVAL)\n\n# Benchmark resolution\nN_STAR = 5000\n\ndef u_prime(c, gamma):\n    \"\"\"CRRA marginal utility function.\"\"\"\n    return c**(-gamma)\n\ndef expected_u_prime_c2(a2, gamma):\n    \"\"\"Expected marginal utility of consumption in period 2, given savings a2.\"\"\"\n    c2_l = R * a2 + Y_L\n    c2_h = R * a2 + Y_H\n    return PI * u_prime(c2_l, gamma) + (1 - PI) * u_prime(c2_h, gamma)\n\ndef compute_policy(gamma, a2_grid):\n    \"\"\"\n    Implements the core EGM step to compute policy on an endogenous grid.\n    Args:\n        gamma (float): CRRA risk aversion parameter.\n        a2_grid (np.array): Exogenous grid for end-of-period assets.\n    Returns:\n        tuple (np.array, np.array): The endogenous grid for a1 and the\n                                     corresponding consumption policy c1.\n    \"\"\"\n    # Step 1: Invert the Euler equation to find c1 for each a2.\n    rhs_euler = BETA * R * expected_u_prime_c2(a2_grid, gamma)\n    c1_grid = rhs_euler**(-1.0 / gamma)\n\n    # Step 2: Use the budget constraint to find the corresponding a1.\n    a1_grid = (a2_grid + c1_grid - Y1) / R\n\n    # a1_grid is monotonic, so no sorting is needed for np.interp.\n    return a1_grid, c1_grid\n\ndef generate_grid(grid_type, N, a2_min, a2_max):\n    \"\"\"Generates the exogenous grid for a2.\"\"\"\n    if N == 1:\n        return np.array([a2_min])\n    if grid_type == 'linear':\n        return np.linspace(a2_min, a2_max, N)\n    elif grid_type == 'quadratic':\n        # (i-1)/(N-1) is a linear space from 0 to 1.\n        norm_grid = np.linspace(0, 1, N)\n        return a2_min + (norm_grid**2) * (a2_max - a2_min)\n    else:\n        raise ValueError(\"Invalid grid_type specified.\")\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final results.\n    \"\"\"\n    test_cases = [\n        {'id': 1, 'gamma': 2.0, 'grid_type': 'linear', 'N': 200, 'a2_min': 0.0, 'a2_max': 10.0},\n        {'id': 2, 'gamma': 2.0, 'grid_type': 'linear', 'N': 10, 'a2_min': 0.0, 'a2_max': 10.0},\n        {'id': 3, 'gamma': 2.0, 'grid_type': 'linear', 'N': 200, 'a2_min': 0.0, 'a2_max': 2.0},\n        {'id': 4, 'gamma': 5.0, 'grid_type': 'quadratic', 'N': 200, 'a2_min': 0.0, 'a2_max': 10.0},\n    ]\n\n    all_results = []\n    for case in test_cases:\n        gamma = case['gamma']\n        grid_type = case['grid_type']\n        N = case['N']\n        a2_min = case['a2_min']\n        a2_max = case['a2_max']\n\n        # --- Benchmark Policy Calculation ---\n        a2_star_grid = generate_grid(grid_type, N_STAR, a2_min, a2_max)\n        a1_star_grid, c1_star_grid = compute_policy(gamma, a2_star_grid)\n\n        # --- Test Policy Calculation ---\n        a2_test_grid = generate_grid(grid_type, N, a2_min, a2_max)\n        a1_test_grid, c1_test_grid = compute_policy(gamma, a2_test_grid)\n\n        # --- Metric Calculation ---\n\n        # 1. Coverage (kappa)\n        domain_test_min = a1_test_grid[0]\n        domain_test_max = a1_test_grid[-1]\n        covered_mask_test = (A1_EVAL_GRID >= domain_test_min)  (A1_EVAL_GRID = domain_test_max)\n        num_covered = np.sum(covered_mask_test)\n        kappa = num_covered / N_EVAL\n\n        if num_covered == 0:\n            E_max = 0.0\n            C_max = 0.0\n        else:\n            # 2. Maximum Absolute Euler Residual (E_max)\n            a1_eval_covered_test = A1_EVAL_GRID[covered_mask_test]\n            c1_interp_for_euler = np.interp(a1_eval_covered_test, a1_test_grid, c1_test_grid)\n            a2_tilde = R * a1_eval_covered_test + Y1 - c1_interp_for_euler\n            \n            lhs_euler = u_prime(c1_interp_for_euler, gamma)\n            rhs_euler = BETA * R * expected_u_prime_c2(a2_tilde, gamma)\n            euler_residuals = np.abs(lhs_euler - rhs_euler)\n            E_max = np.max(euler_residuals)\n            \n            # 3. Maximum Absolute Policy Deviation (C_max)\n            domain_star_min = a1_star_grid[0]\n            domain_star_max = a1_star_grid[-1]\n            covered_mask_star = (A1_EVAL_GRID >= domain_star_min)  (A1_EVAL_GRID = domain_star_max)\n            common_mask = covered_mask_test  covered_mask_star\n            \n            if not np.any(common_mask):\n                C_max = 0.0\n            else:\n                a1_eval_common = A1_EVAL_GRID[common_mask]\n                c1_interp_test = np.interp(a1_eval_common, a1_test_grid, c1_test_grid)\n                c1_interp_star = np.interp(a1_eval_common, a1_star_grid, c1_star_grid)\n                policy_devs = np.abs(c1_interp_test - c1_interp_star)\n                C_max = np.max(policy_devs)\n        \n        all_results.append([E_max, C_max, kappa])\n\n    # Format output string as a list of lists: [[E1,C1,k1],[E2,C2,k2],...]\n    string_results = [f\"[{e},{c},{k}]\" for e, c, k in all_results]\n    final_output = f\"[{','.join(string_results)}]\"\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}