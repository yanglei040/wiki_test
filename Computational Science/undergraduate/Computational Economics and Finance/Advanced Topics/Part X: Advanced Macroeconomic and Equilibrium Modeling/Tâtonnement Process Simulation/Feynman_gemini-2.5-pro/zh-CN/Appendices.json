{
    "hands_on_practices": [
        {
            "introduction": "标准的摸索过程模型假设价格会对任何程度的超额需求做出即时反应。然而，在现实世界中，由于“菜单成本”等因素，价格可能表现出一定的“粘性”，即它们不会因微小的市场失衡而频繁变动。本练习引入了一个价格调整的“门槛”($\\delta$)，通过这种简单而强大的方式来模拟价格粘性。通过实现这个模型，你将亲身体验这种市场摩擦如何影响价格收敛到均衡的过程和速度。",
            "id": "2436152",
            "problem": "考虑一个纯交换经济体，其中有 $I = 2$ 个代理人和 $G = 3$ 种商品。每个代理人 $i \\in \\{1,2\\}$ 对这些商品拥有一个柯布-道格拉斯（Cobb–Douglas）效用函数，其指数为 $\\alpha_{ig}$，满足 $\\sum_{g=1}^{3} \\alpha_{ig} = 1$ 且对于所有 $g$ 都有 $\\alpha_{ig} \\in (0,1)$。代理人 $i$ 的禀赋为一个严格为正的商品向量 $\\mathbf{e}_i \\in \\mathbb{R}_{++}^{3}$。设总禀赋为 $\\mathbf{E} = \\sum_{i=1}^{2} \\mathbf{e}_i$。价格由一个严格为正的向量 $\\mathbf{p} \\in \\mathbb{R}_{++}^{3}$ 表示，其中第一种商品用作计价物（numeraire），因此始终有 $p_1 \\equiv 1$。\n\n给定一个价格向量 $\\mathbf{p}$，代理人 $i$ 的收入为 $m_i(\\mathbf{p}) = \\mathbf{p} \\cdot \\mathbf{e}_i$。对于柯布-道格拉斯偏好，代理人 $i$ 对商品 $g$ 的个人需求为 $x_{ig}(\\mathbf{p}) = \\alpha_{ig} \\, m_i(\\mathbf{p}) / p_g$。商品 $g$ 的总需求为 $X_g(\\mathbf{p}) = \\sum_{i=1}^{2} x_{ig}(\\mathbf{p})$，超额需求为 $Z_g(\\mathbf{p}) = X_g(\\mathbf{p}) - E_g$。市场出清要求在均衡价格 $\\mathbf{p}^*$ 下，对所有 $g$ 都有 $Z_g(\\mathbf{p}^*) = 0$，其中 $p_1^* = 1$ 是归一化条件。\n\n您将模拟一个带有粘性价格的离散时间拍卖（tâtonnement，即价格调整）过程。设 $t \\in \\{0,1,2,\\dots\\}$ 为迭代的索引。对于给定的步长 $\\gamma > 0$ 和粘性阈值 $\\delta \\ge 0$，价格更新如下：\n- 计价物价格是固定的：对于所有 $t$，$p_1^{t+1} = 1$。\n- 对于每种非计价物商品 $g \\in \\{2,3\\}$，\n  - 如果 $\\lvert Z_g(\\mathbf{p}^t) \\rvert > \\delta$，则\n    $$\n    p_g^{t+1} = \\max\\{\\varepsilon, \\, p_g^t \\, (1 + \\gamma \\, Z_g(\\mathbf{p}^t))\\},\n    $$\n    其中 $\\varepsilon > 0$ 是一个用于强制保持正值的小常数。\n  - 否则，$p_g^{t+1} = p_g^t$（由于粘性，价格不变）。\n当 $\\max_{g \\in \\{1,2,3\\}} \\lvert Z_g(\\mathbf{p}^t) \\rvert \\le \\tau$ 时，宣告收敛，其中 $\\tau > 0$ 是一个容差。如果在 $T_{\\max}$ 次迭代内未达到收敛，则过程停止并宣告未收敛。\n\n使用以下校准的经济体：\n- 柯布-道格拉斯指数：\n  - 代理人 1：$(\\alpha_{11}, \\alpha_{12}, \\alpha_{13}) = (0.5, 0.3, 0.2)$。\n  - 代理人 2：$(\\alpha_{21}, \\alpha_{22}, \\alpha_{23}) = (0.2, 0.4, 0.4)$。\n- 禀赋：\n  - 代理人 1：$\\mathbf{e}_1 = (1.0, 0.5, 0.5)$。\n  - 代理人 2：$\\mathbf{e}_2 = (0.5, 1.0, 0.5)$。\n- 总禀赋：$\\mathbf{E} = (1.5, 1.5, 1.0)$。\n- 所有模拟的固定参数：正值下限 $\\varepsilon = 10^{-8}$，收敛容差 $\\tau = 10^{-6}$。\n- 初始价格向量 $\\mathbf{p}^0$ 总是指定为 $p_1^0 = 1$。\n\n为以下测试用例集实现模拟。每个测试用例是一个具有明确值的元组 $(\\gamma, \\delta, T_{\\max}, \\mathbf{p}^0)$：\n- 案例 A（基准，无粘性）：$(\\gamma, \\delta, T_{\\max}, \\mathbf{p}^0) = (0.2, 0.0, 5000, [1.0, 1.0, 1.0])$。\n- 案例 B（中等粘性，非均衡起点）：$(\\gamma, \\delta, T_{\\max}, \\mathbf{p}^0) = (0.15, 0.1, 5000, [1.0, 0.7, 1.3])$。\n- 案例 C（高粘性，实际冻结）：$(\\gamma, \\delta, T_{\\max}, \\mathbf{p}^0) = (0.2, 1.0, 10, [1.0, 1.0, 1.0])$。\n- 案例 D（在等式边界上的粘性）：$(\\gamma, \\delta, T_{\\max}, \\mathbf{p}^0) = (0.2, 0.2, 10, [1.0, 1.0, 1.0])$。\n\n程序要求：\n- 在每次迭代中，根据基本原理精确计算上面定义的 $Z_g(\\mathbf{p})$。\n- 严格按照指定的方式应用粘性拍卖规则，当严格不等式 $\\lvert Z_g \\rvert > \\delta$ 成立时触发更新。\n- 始终保持 $p_1 \\equiv 1$。\n- 如果满足收敛条件 $\\max_g \\lvert Z_g(\\mathbf{p}^t) \\rvert \\le \\tau$，则提前停止。\n- 对于每个测试用例，生成一个形式为 `[N, B, [p_1, p_2, p_3]]` 的结果，其中：\n  - $N$ 是实际执行的迭代次数（介于 $0$ 和 $T_{\\max}$ 之间）的整数。\n  - $B$ 是一个布尔值，如果宣告收敛则为 $\\mathrm{True}$，否则为 $\\mathrm{False}$。\n  - $[p_1, p_2, p_3]$ 是四舍五入到六位小数的最终价格向量。\n- 最终输出格式：您的程序应生成一行输出，其中包含按案例 $\\mathrm{A}$、$\\mathrm{B}$、$\\mathrm{C}$、$\\mathrm{D}$ 顺序排列的结果，以逗号分隔并用方括号括起来的列表。例如，它看起来应该像 $[[\\cdot, \\cdot, [\\cdot,\\cdot,\\cdot]],[\\cdot, \\cdot, [\\cdot,\\cdot,\\cdot]],[\\cdot, \\cdot, [\\cdot,\\cdot,\\cdot]],[\\cdot, \\cdot, [\\cdot,\\cdot,\\cdot]]]$，并用实际的数字和布尔值结果替换。",
            "solution": "该问题是有效的。这是一个定义明确的计算经济学练习，其基础是一般均衡理论和动态系统数值模拟的既定原则。所有参数、方程和条件都已足够精确地指定，可以构建一个唯一且可验证的解决方案。\n\n该问题要求在一个纯交换经济体中模拟一个离散时间拍卖（tâtonnement）价格调整过程。该经济体由 $I=2$ 个代理人和 $G=3$ 种商品组成。解决方案的核心是实现一个迭代算法，该算法根据市场超额需求更新价格，直到达到均衡或超过最大迭代次数。\n\n首先，我们建立经济模型的基本方程。每个代理人 $i \\in \\{1, 2\\}$ 都有柯布-道格拉斯偏好，由效用函数 $U_i(\\mathbf{x}_i) = \\prod_{g=1}^3 x_{ig}^{\\alpha_{ig}}$ 描述，其中 $\\mathbf{x}_i = (x_{i1}, x_{i2}, x_{i3})$ 是消费束，$\\boldsymbol{\\alpha}_i = (\\alpha_{i1}, \\alpha_{i2}, \\alpha_{i3})$ 是效用份额参数。代理人拥有商品向量 $\\mathbf{e}_i = (e_{i1}, e_{i2}, e_{i3})$ 的禀赋。\n\n给定一个价格向量 $\\mathbf{p} = (p_1, p_2, p_3)$，代理人 $i$ 的收入（或财富）由其禀赋导出：\n$$\nm_i(\\mathbf{p}) = \\mathbf{p} \\cdot \\mathbf{e}_i = \\sum_{g=1}^{3} p_g e_{ig}\n$$\n柯布-道格拉斯效用函数的一个关键特性是，代理人 $i$ 将其收入的一个固定比例 $\\alpha_{ig}$ 分配给每种商品 $g$。这得出了个人需求函数：\n$$\nx_{ig}(\\mathbf{p}) = \\frac{\\alpha_{ig} m_i(\\mathbf{p})}{p_g}\n$$\n每种商品 $g$ 的总需求是所有代理人个人需求的总和：\n$$\nX_g(\\mathbf{p}) = \\sum_{i=1}^{2} x_{ig}(\\mathbf{p})\n$$\n经济体中每种商品的总量由总禀赋 $\\mathbf{E} = \\mathbf{e}_1 + \\mathbf{e}_2$ 固定。商品 $g$ 的超额需求，记为 $Z_g(\\mathbf{p})$，是需求量与可供量之间的差额：\n$$\nZ_g(\\mathbf{p}) = X_g(\\mathbf{p}) - E_g\n$$\n问题指定了以下经济参数：\n- 效用指数：代理人 1 为 $\\boldsymbol{\\alpha}_1 = (0.5, 0.3, 0.2)$，代理人 2 为 $\\boldsymbol{\\alpha}_2 = (0.2, 0.4, 0.4)$。\n- 禀赋：代理人 1 为 $\\mathbf{e}_1 = (1.0, 0.5, 0.5)$，代理人 2 为 $\\mathbf{e}_2 = (0.5, 1.0, 0.5)$。\n- 总禀赋：$\\mathbf{E} = \\mathbf{e}_1 + \\mathbf{e}_2 = (1.5, 1.5, 1.0)$。\n\n该模拟遵循一个由 $t \\in \\{0, 1, 2, \\dots\\}$ 索引的离散时间拍卖过程。商品 1 的价格被归一化作为计价物，即对于所有 $t$ 都有 $p_1^t \\equiv 1$。非计价物商品 $p_2$ 和 $p_3$ 的价格根据它们各自的超额需求进行调整，但带有一个“粘性”条件。\n\n算法流程如下：\n1.  **初始化**：在迭代 $t=0$ 时，从给定的初始价格向量 $\\mathbf{p}^0$ 开始。\n2.  **迭代循环**：对于 $t = 0, 1, \\dots, T_{\\max}$：\n    a. **计算状态**：计算所有商品 $g \\in \\{1, 2, 3\\}$ 的代理人收入 $m_i(\\mathbf{p}^t)$、总需求 $X_g(\\mathbf{p}^t)$ 和超额需求 $Z_g(\\mathbf{p}^t)$。\n    b. **检查收敛性**：如果 $\\max_{g} |Z_g(\\mathbf{p}^t)| \\le \\tau$，其中 $\\tau = 10^{-6}$ 是容差，则过程已收敛。模拟终止，报告当前迭代次数 $t$、收敛状态 `True` 和最终价格向量 $\\mathbf{p}^t$。\n    c. **检查迭代限制**：如果 $t$ 达到 $T_{\\max}$，模拟停止。报告最终状态，迭代次数为 $T_{\\max}$，收敛状态由步骤(b)中的最终检查确定。\n    d. **价格更新**：如果过程尚未终止，则计算下一个价格向量 $\\mathbf{p}^{t+1}$。计价物价格是固定的：$p_1^{t+1} = 1$。对于每种非计价物商品 $g \\in \\{2, 3\\}$，价格根据粘性规则进行更新：\n       $$\n       p_g^{t+1} =\n       \\begin{cases}\n       \\max\\{\\varepsilon, p_g^t (1 + \\gamma Z_g(\\mathbf{p}^t))\\} & \\text{if } |Z_g(\\mathbf{p}^t)| > \\delta \\\\\n       p_g^t & \\text{if } |Z_g(\\mathbf{p}^t)| \\le \\delta\n       \\end{cases}\n       $$\n       此处，$\\gamma$ 是调整速度，$\\delta$ 是粘性阈值，$\\varepsilon = 10^{-8}$ 是确保价格保持严格为正的下限。\n    e. **推进**：设置 $\\mathbf{p}^t \\leftarrow \\mathbf{p}^{t+1}$，增加迭代计数器，并从步骤(a)开始重复。\n\n该算法将使用 Python 和 `numpy` 库来实现，以进行高效的向量和矩阵运算。程序将对四个指定的测试用例执行模拟，每个用例都有一组不同的参数 $(\\gamma, \\delta, T_{\\max}, \\mathbf{p}^0)$，并按要求格式化结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the tâtonnement process simulations for all test cases.\n    \"\"\"\n    \n    # Calibrated economy parameters\n    alphas = np.array([\n        [0.5, 0.3, 0.2],  # Agent 1\n        [0.2, 0.4, 0.4]   # Agent 2\n    ])\n    \n    endowments = np.array([\n        [1.0, 0.5, 0.5],  # Agent 1\n        [0.5, 1.0, 0.5]   # Agent 2\n    ])\n    \n    agg_endowment = np.sum(endowments, axis=0)\n    \n    # Fixed simulation parameters\n    epsilon = 1e-8\n    tau = 1e-6\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: baseline, no stickiness\n        (0.2, 0.0, 5000, np.array([1.0, 1.0, 1.0])),\n        # Case B: moderate stickiness, off-equilibrium start\n        (0.15, 0.1, 5000, np.array([1.0, 0.7, 1.3])),\n        # Case C: high stickiness, effectively frozen\n        (0.2, 1.0, 10, np.array([1.0, 1.0, 1.0])),\n        # Case D: boundary stickiness at equality\n        (0.2, 0.2, 10, np.array([1.0, 1.0, 1.0])),\n    ]\n\n    results = []\n    for case in test_cases:\n        gamma, delta, T_max, p0 = case\n        \n        # Run the simulation for the current case\n        N, B, p_final = simulate_tatonnement(\n            gamma, delta, T_max, p0, \n            alphas, endowments, agg_endowment, \n            epsilon, tau\n        )\n        \n        # Round final prices to 6 decimal places\n        p_final_rounded = np.round(p_final, 6).tolist()\n        \n        results.append([N, B, p_final_rounded])\n\n    # Final print statement in the exact required format.\n    # The replace(\" \", \"\") call ensures the output matches the dense format.\n    print(str(results).replace(\" \", \"\"))\n\ndef simulate_tatonnement(gamma, delta, T_max, p0, alphas, endowments, agg_endowment, epsilon, tau):\n    \"\"\"\n    Simulates the sticky tâtonnement process for a single case.\n    \n    Returns:\n        N (int): Number of iterations performed.\n        converged (bool): True if convergence was achieved, False otherwise.\n        p (np.ndarray): The final price vector.\n    \"\"\"\n    p = p0.copy()\n    N = 0\n    converged = False\n\n    while N <= T_max:\n        # Step 1: Calculate incomes m_i(p) = p . e_i\n        incomes = np.dot(endowments, p)\n        \n        # Step 2: Calculate individual demands x_ig(p) = alpha_ig * m_i(p) / p_g\n        # We need to handle division by p_g carefully.\n        # income_per_price matrix: (I x G)\n        income_matrix = np.tile(incomes, (alphas.shape[1], 1)).T\n        demands = alphas * income_matrix / p\n        \n        # Step 3: Calculate aggregate and excess demands\n        agg_demand = np.sum(demands, axis=0)\n        excess_demand = agg_demand - agg_endowment\n        \n        # Step 4: Check for convergence\n        if np.max(np.abs(excess_demand)) <= tau:\n            converged = True\n            break\n        \n        # Step 5: Check for maximum iterations\n        if N == T_max:\n            break\n        \n        # Step 6: Update prices for the next iteration\n        p_next = p.copy()\n        \n        # Update for non-numeraire goods (g=2, 3), indices 1, 2\n        for g_idx in [1, 2]:\n            if abs(excess_demand[g_idx]) > delta:\n                p_next[g_idx] = max(epsilon, p[g_idx] * (1 + gamma * excess_demand[g_idx]))\n        \n        p = p_next\n        N += 1\n        \n    return N, converged, p\n\nsolve()\n\n```"
        },
        {
            "introduction": "经典的瓦尔拉斯摸索是一个理想化的“思想实验”，其中在找到均衡价格之前不发生任何交易。本章的最后一个练习将探索一个更接近现实的非瓦尔拉斯模型，在该模型中，即使市场尚未出清，有限的、按比例配给的交易也会在非均衡价格下发生。这个模拟要求你同时追踪代理人禀赋和市场价格的共同演化，从而让你更深入地理解当市场无法即时出清时，其内部的动态调整机制是如何运作的。",
            "id": "2436167",
            "problem": "给定一个两种商品、两个代理人的纯交换经济。时间是离散的，由 $t \\in \\{0,1,2,\\dots\\}$ 索引。有两种商品，标记为 $g \\in \\{1,2\\}$；有两个代理人，标记为 $i \\in \\{A,B\\}$。在每个时间点 $t$，会公布一个严格为正的价格向量 $p_t = (p_{t,1}, p_{t,2}) \\in \\mathbb{R}_{++}^2$，之后，代理人根据他们当前的禀赋和公布的价格形成需求。如果市场未能出清，该过程允许发生有限的、配给的交易，随后是新一轮的价格公布。\n\n基本模型组成部分：\n\n1) 偏好与需求。每个代理人 $i$ 对两种商品具有 Cobb–Douglas 效用，其参数为 $\\alpha_i \\in (0,1)$：\n$$\nu_i(x_{i,1}, x_{i,2}) = x_{i,1}^{\\alpha_i} x_{i,2}^{1-\\alpha_i}.\n$$\n给定价格 $p_t$ 和禀赋 $e_{i}(t) = (e_{i,1}(t), e_{i,2}(t)) \\in \\mathbb{R}_{+}^2$，其预算为 $m_i(t) = p_{t,1} e_{i,1}(t) + p_{t,2} e_{i,2}(t)$。代理人 $i$ 在时间 $t$ 的 Cobb–Douglas 需求为：\n$$\nd_{i,1}(t) = \\frac{\\alpha_i \\, m_i(t)}{p_{t,1}}, \\qquad d_{i,2}(t) = \\frac{(1-\\alpha_i) \\, m_i(t)}{p_{t,2}}.\n$$\n将商品 $g$ 的总需求定义为 $D_g(t) = \\sum_{i \\in \\{A,B\\}} d_{i,g}(t)$。将总禀赋（总供给）定义为 $S_g(t) = \\sum_{i \\in \\{A,B\\}} e_{i,g}(t)$。总超额需求为\n$$\nz_g(t) = D_g(t) - S_g(t).\n$$\n\n2) 在下一次价格公布前的有限、配给交易。对于每种商品 $g \\in \\{1,2\\}$，将每个代理人的净期望交易量定义为 $n_{i,g}(t) = d_{i,g}(t) - e_{i,g}(t)$。设商品 $g$ 的买方集合和卖方集合为\n$$\n\\mathcal{B}_g(t) = \\{ i : n_{i,g}(t) > 0 \\}, \\quad \\mathcal{S}_g(t) = \\{ i : n_{i,g}(t) < 0 \\}.\n$$\n将商品 $g$ 的总期望购买量和总期望销售量定义为\n$$\nB_g(t) = \\sum_{i \\in \\mathcal{B}_g(t)} n_{i,g}(t), \\qquad S_g^{\\text{tot}}(t) = \\sum_{i \\in \\mathcal{S}_g(t)} \\big( -n_{i,g}(t) \\big).\n$$\n设 $\\rho \\in [0,1]$ 为一个固定的“每轮交易限额”。在时间 $t$ 交易的商品 $g$ 的实际数量是短边乘以该限额：\n$$\nT_g(t) = \\rho \\cdot \\min\\big( B_g(t), \\, S_g^{\\text{tot}}(t) \\big).\n$$\n交易根据市场双方提交的数量按比例进行配给：\n- 对于每个买方 $i \\in \\mathcal{B}_g(t)$，获得的商品 $g$ 的数量为\n$$\nq_{i,g}(t) = \\begin{cases}\nT_g(t) \\cdot \\dfrac{n_{i,g}(t)}{B_g(t)} & \\text{if } B_g(t) > 0, \\\\\n0 & \\text{if } B_g(t) = 0,\n\\end{cases}\n$$\n且对于每个卖方 $i \\in \\mathcal{S}_g(t)$，交付的商品 $g$ 的数量为\n$$\ns_{i,g}(t) = \\begin{cases}\nT_g(t) \\cdot \\dfrac{-n_{i,g}(t)}{S_g^{\\text{tot}}(t)} & \\text{if } S_g^{\\text{tot}}(t) > 0, \\\\\n0 & \\text{if } S_g^{\\text{tot}}(t) = 0.\n\\end{cases}\n$$\n禀赋根据商品守恒进行更新：\n$$\ne_{i,g}(t+1) = e_{i,g}(t) + q_{i,g}(t) - s_{i,g}(t).\n$$\n注意，对于每种商品 $g$，都有 $S_g(t+1) = \\sum_i e_{i,g}(t+1) = S_g(t)$。\n\n3) 价格调整 (tâtonnement)。设 $\\eta > 0$ 为给定的步长参数。价格根据以下规则演变\n$$\np_{t+1,g} = p_{t,g} \\cdot \\exp\\!\\left( \\eta \\cdot \\frac{z_g(t)}{S_g(t)} \\right), \\quad g \\in \\{1,2\\}.\n$$\n然后通过将商品2固定为计价物 (numeraire) 来对价格进行归一化：\n$$\n\\tilde{p}_{t+1,g} = \\frac{p_{t+1,g}}{p_{t+1,2}}, \\quad \\text{so that } \\tilde{p}_{t+1,2} = 1.\n$$\n为简化符号，将 $\\tilde{p}_{t+1}$ 重新标记为 $p_{t+1}$。\n\n4) 收敛与终止。当满足以下条件时，过程终止\n$$\n\\max\\{ |z_1(t)|, |z_2(t)| \\} \\le \\varepsilon\n$$\n对于给定的容差 $\\varepsilon > 0$，或者当达到最大迭代次数 $T_{\\max}$ 时。终止时，报告商品1的归一化价格，即在 $p_{t,2} = 1$ 时的 $p_{t,1}$。\n\n任务。实现一个程序，模拟上述非瓦尔拉斯 (non-Walrasian)、配给交易的 tâtonnement 过程，并为下面测试套件中的每组参数返回商品1的最终归一化价格。所有数值均为无量纲。\n\n测试套件。对于每个案例，输入包括\n- Cobb–Douglas 参数 $(\\alpha_A,\\alpha_B)$，\n- 初始禀赋 $e_A(0) = (e_{A,1}(0), e_{A,2}(0))$，$e_B(0) = (e_{B,1}(0), e_{B,2}(0))$，\n- 初始价格 $p_0 = (p_{0,1}, p_{0,2})$，\n- 步长参数 $\\eta$、交易限额 $\\rho$、容差 $\\varepsilon$ 和最大迭代次数 $T_{\\max}$。\n\n指定并求解以下四个案例：\n\n- 案例1（理想路径）：$(\\alpha_A,\\alpha_B) = (0.5, 0.5)$, $e_A(0) = (1, 0)$, $e_B(0) = (0, 1)$, $p_0 = (2, 1)$, $\\eta = 0.2$, $\\rho = 0.5$, $\\varepsilon = 10^{-8}$, $T_{\\max} = 10000$。\n- 案例2（边界情况：初始出清价格）：$(\\alpha_A,\\alpha_B) = (0.5, 0.5)$, $e_A(0) = (1, 0)$, $e_B(0) = (0, 1)$, $p_0 = (1, 1)$, $\\eta = 0.2$, $\\rho = 0.7$, $\\varepsilon = 10^{-10}$, $T_{\\max} = 10000$。\n- 案例3（边缘情况：价格公布之间不允许交易）：$(\\alpha_A,\\alpha_B) = (0.5, 0.5)$, $e_A(0) = (1, 0)$, $e_B(0) = (0, 1)$, $p_0 = (3, 1)$, $\\eta = 0.3$, $\\rho = 0$, $\\varepsilon = 10^{-8}$, $T_{\\max} = 10000$。\n- 案例4（非对称偏好和禀赋）：$(\\alpha_A,\\alpha_B) = (0.8, 0.2)$, $e_A(0) = (2, 0.5)$, $e_B(0) = (0.5, 1)$, $p_0 = (0.4, 1)$, $\\eta = 0.2$, $\\rho = 1$, $\\varepsilon = 10^{-8}$, $T_{\\max} = 20000$。\n\n最终输出格式。你的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。对于每个案例，输出四舍五入到六位小数的商品1的最终归一化价格。例如，一个包含四个案例的输出应如下所示\n[p1_case1,p1_case2,p1_case3,p1_case4],\n其中每个条目是小数点后有六位数字的十进制数。",
            "solution": "该问题经过严格验证，被认定是有效的。它提出了一个来自计算经济学领域的、定义清晰、有科学依据且计算上可行的非瓦尔拉斯 tâtonnement 过程模型。所有参数、方程和条件都得到了明确的规定，构成了一个自洽且一致的系统。该问题要求在多种参数化设置下对该系统进行数值模拟，这是科学计算中的一项标准任务。\n\n解决方案需要实现一个离散时间模拟，该模拟迭代更新禀赋和价格，直到市场接近均衡。算法流程如下。\n\n设时间由 $t \\in \\{0, 1, 2, \\ldots\\}$ 索引。在时间 $t$ 系统的状态由价格向量 $p_t = (p_{t,1}, p_{t,2})$ 和两个代理人 $i \\in \\{A, B\\}$ 对两种商品 $g \\in \\{1, 2\\}$ 的禀赋矩阵描述，记作 $e(t) = \\{e_{i,g}(t)\\}$。模拟从初始条件 $p_0$ 和 $e(0)$ 开始。每种商品的总禀赋 $S_g = \\sum_{i} e_{i,g}(t)$ 不随时间变化，这一特性被称为商品守恒，是纯交换模型所固有的。\n\n对于从 $0$ 到 $T_{\\max}-1$ 的每个时间步 $t$，模拟循环包括以下计算序列：\n\n1.  **需求和超额需求计算**：给定当前价格 $p_t$ 和当前禀赋 $e(t)$，我们首先计算每个代理人 $i$ 的预算：\n    $$\n    m_i(t) = \\sum_{g=1}^{2} p_{t,g} e_{i,g}(t) = p_t \\cdot e_i(t).\n    $$\n    代理人 $i$ 对每种商品 $g$ 的需求是通过最大化其 Cobb-Douglas 效用函数 $u_i(x_{i,1}, x_{i,2}) = x_{i,1}^{\\alpha_i} x_{i,2}^{1-\\alpha_i}$ 在其预算约束下得出的。这产生了以下需求函数：\n    $$\n    d_{i,1}(t) = \\frac{\\alpha_i m_i(t)}{p_{t,1}} \\quad \\text{和} \\quad d_{i,2}(t) = \\frac{(1-\\alpha_i) m_i(t)}{p_{t,2}}.\n    $$\n    每种商品 $g$ 的总需求是个人需求的总和，$D_g(t) = \\sum_i d_{i,g}(t)$。商品 $g$ 的总超额需求，记作 $z_g(t)$，是总需求与总供给（总禀赋）之间的差额：\n    $$\n    z_g(t) = D_g(t) - S_g.\n    $$\n    作为一致性检查，瓦尔拉斯定律 (Walras's Law) 必须成立：$\\sum_g p_{t,g} z_g(t) = 0$。\n\n2.  **收敛性检查**：如果市场足够接近均衡，模拟就终止。这通过检查两种商品的总超额需求的大小是否低于指定的容差 $\\varepsilon > 0$ 来确定：\n    $$\n    \\max\\left( |z_1(t)|, |z_2(t)| \\right) \\le \\varepsilon.\n    $$\n    如果满足此条件，过程停止，当前商品1的归一化价格 $p_{t,1}$ 即为结果。\n\n3.  **配给交易与禀赋更新**：如果市场尚未出清，则发生非均衡交易。这种交易受到一个因子 $\\rho \\in [0,1]$ 的限制，并按市场的短边进行配给。\n    - 首先，我们确定每个代理人对每种商品的净期望交易量：$n_{i,g}(t) = d_{i,g}(t) - e_{i,g}(t)$。\n    - 对于每种商品 $g$，我们找出总期望购买量 $B_g(t) = \\sum_{i: n_{i,g}(t)>0} n_{i,g}(t)$ 和总期望销售量 $S_g^{\\text{tot}}(t) = \\sum_{i: n_{i,g}(t)<0} (-n_{i,g}(t))$。\n    - 交易的商品 $g$ 的实际数量是 $T_g(t) = \\rho \\cdot \\min(B_g(t), S_g^{\\text{tot}}(t))$。\n    - 买方 $i$ 获得的数量 $q_{i,g}(t)$ 和卖方 $j$ 放弃的数量 $s_{j,g}(t)$ 与其期望的交易量成正比。对于买方 $i$，$q_{i,g}(t) = T_g(t) \\cdot n_{i,g}(t) / B_g(t)$（如果 $B_g(t)>0$），对于卖方 $j$，$s_{j,g}(t) = T_g(t) \\cdot (-n_{j,g}(t)) / S_g^{\\text{tot}}(t)$（如果 $S_g^{\\text{tot}}(t)>0$）。\n    - 然后根据这些交易更新下一时期 $t+1$ 的禀赋：\n    $$\n    e_{i,g}(t+1) = e_{i,g}(t) + q_{i,g}(t) - s_{i,g}(t).\n    $$\n    如果 $\\rho=0$，则不发生交易，并且对于所有的 $i,g,t$，$e_{i,g}(t+1) = e_{i,g}(t)$。\n\n4.  **价格更新**：下一时期的价格根据当前时期的超额需求进行调整。商品 $g$ 的未归一化价格使用指数规则进行更新：\n    $$\n    p'_{t+1,g} = p_{t,g} \\cdot \\exp\\left( \\eta \\cdot \\frac{z_g(t)}{S_g} \\right).\n    $$\n    此规则增加了正超额需求商品的价格，降低了负超额需求商品的价格，确保价格保持为正。步长 $\\eta>0$ 控制调整速度。\n\n5.  **价格归一化**：为防止价格发散并固定记账单位，对价格向量进行归一化。商品2被选为计价物 (numeraire)，意味着其价格被设为1。时期 $t+1$ 的价格为：\n    $$\n    p_{t+1,1} = \\frac{p'_{t+1,1}}{p'_{t+1,2}} \\quad \\text{且} \\quad p_{t+1,2} = 1.\n    $$\n    这样就完成了一次迭代。模拟使用更新后的禀赋 $e(t+1)$ 和价格 $p_{t+1}$ 继续进行。如果在 $T_{\\max}$ 次迭代内未达到收敛标准，循环将终止并报告最后计算出的价格 $p_{T_{\\max},1}$。\n\n这整个过程被封装在一个数值算法中，并应用于四个指定的测试案例，以确定商品1的最终均衡或近均衡价格。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_case(alpha_A, alpha_B, e_A_0, e_B_0, p_0, eta, rho, eps, T_max):\n    \"\"\"\n    Simulates the non-Walrasian tâtonnement process for a single case.\n\n    Args:\n        alpha_A (float): Cobb-Douglas parameter for agent A.\n        alpha_B (float): Cobb-Douglas parameter for agent B.\n        e_A_0 (tuple): Initial endowment for agent A (good 1, good 2).\n        e_B_0 (tuple): Initial endowment for agent B (good 1, good 2).\n        p_0 (tuple): Initial prices (p1, p2).\n        eta (float): Price adjustment step parameter.\n        rho (float): Per-round trade limit.\n        eps (float): Convergence tolerance.\n        T_max (int): Maximum number of iterations.\n\n    Returns:\n        float: The final normalized price of good 1.\n    \"\"\"\n    # Convert inputs to numpy arrays for vectorized operations\n    alphas = np.array([alpha_A, alpha_B])\n    endowments = np.array([e_A_0, e_B_0], dtype=np.float64)\n    prices = np.array(p_0, dtype=np.float64)\n\n    # Aggregate supply (total endowment) is constant throughout the simulation\n    S_total = np.sum(endowments, axis=0)\n\n    for _ in range(T_max):\n        # Step 1: Calculate Demands and Excess Demands\n        # Budgets: m_i = p . e_i\n        budgets = np.dot(endowments, prices)\n        \n        # Demands: d_i,g\n        demands = np.zeros_like(endowments)\n        # Agent A's demands\n        demands[0, 0] = alphas[0] * budgets[0] / prices[0]\n        demands[0, 1] = (1 - alphas[0]) * budgets[0] / prices[1]\n        # Agent B's demands\n        demands[1, 0] = alphas[1] * budgets[1] / prices[0]\n        demands[1, 1] = (1 - alphas[1]) * budgets[1] / prices[1]\n        \n        # Aggregate Demand and Excess Demand\n        D_total = np.sum(demands, axis=0)\n        z = D_total - S_total\n\n        # Step 2: Check for Convergence\n        if np.max(np.abs(z)) <= eps:\n            return prices[0]\n\n        # Step 3: Rationed Trade and Endowment Update\n        # This step is skipped if rho is 0, as no trade occurs.\n        if rho > 0:\n            net_desired_trades = demands - endowments\n            e_next = endowments.copy()\n\n            for g in range(2):  # For each good\n                n_g = net_desired_trades[:, g]\n                \n                # Identify buyers and sellers\n                buyers_mask = n_g > 1e-12 # Use a small tolerance for floating point\n                sellers_mask = n_g < -1e-12\n\n                # Total desired purchases and sales\n                B_g = np.sum(n_g[buyers_mask])\n                S_g_tot = -np.sum(n_g[sellers_mask])\n\n                if B_g > 0 and S_g_tot > 0:\n                    # Actual quantity of good g traded\n                    T_g = rho * min(B_g, S_g_tot)\n                    \n                    # Rationed quantities and endowment updates\n                    # For buyers of good g\n                    q_ig = T_g * (n_g[buyers_mask] / B_g)\n                    e_next[buyers_mask, g] += q_ig\n                    \n                    # For sellers of good g\n                    s_ig = T_g * (-n_g[sellers_mask] / S_g_tot)\n                    e_next[sellers_mask, g] -= s_ig\n            \n            endowments = e_next\n        \n        # Step 4 & 5: Price Update and Normalization\n        # Update unnormalized prices\n        # Protect against division by zero if S_total[g] is somehow 0\n        update_ratios = np.divide(z, S_total, out=np.zeros_like(z), where=S_total!=0)\n        p_next_unnormalized = prices * np.exp(eta * update_ratios)\n        \n        # Normalize prices using good 2 as numeraire\n        if p_next_unnormalized[1] > 0:\n            prices = p_next_unnormalized / p_next_unnormalized[1]\n        # If p_next_unnormalized[1] hits zero, stop to avoid errors\n        else:\n            break\n            \n    return prices[0]\n\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Happy path\n        # (alpha_A, alpha_B), e_A(0), e_B(0), p_0, eta, rho, eps, T_max\n        (0.5, 0.5, (1.0, 0.0), (0.0, 1.0), (2.0, 1.0), 0.2, 0.5, 1e-8, 10000),\n        # Case 2: Boundary (initially clearing prices)\n        (0.5, 0.5, (1.0, 0.0), (0.0, 1.0), (1.0, 1.0), 0.2, 0.7, 1e-10, 10000),\n        # Case 3: Edge (no trade allowed)\n        (0.5, 0.5, (1.0, 0.0), (0.0, 1.0), (3.0, 1.0), 0.3, 0.0, 1e-8, 10000),\n        # Case 4: Asymmetric preferences and endowments\n        (0.8, 0.2, (2.0, 0.5), (0.5, 1.0), (0.4, 1.0), 0.2, 1.0, 1e-8, 20000),\n    ]\n\n    results = []\n    for case in test_cases:\n        alpha_A, alpha_B, e_A_0, e_B_0, p_0, eta, rho, eps, T_max = case\n        result = solve_case(alpha_A, alpha_B, e_A_0, e_B_0, p_0, eta, rho, eps, T_max)\n        results.append(f\"{result:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}