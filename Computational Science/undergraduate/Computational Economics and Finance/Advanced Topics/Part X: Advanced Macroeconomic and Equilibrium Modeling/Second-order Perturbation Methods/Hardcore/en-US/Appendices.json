{
    "hands_on_practices": [
        {
            "introduction": "This first practice moves beyond a single equation to a system of interacting agents, a common scenario in economics and finance. Using a stylized model of an interbank network, you will apply the perturbation method to understand how an initial shock to one bank propagates non-linearly through the system . The core task is to derive the first and second-order coefficients of the system's response by substituting the Taylor series into the governing equations and solving for the unknown vectors, a foundational skill for analyzing multi-dimensional models.",
            "id": "2428772",
            "problem": "Consider an economy with $n$ interconnected banks. Let $W \\in \\mathbb{R}^{n \\times n}$ be a nonnegative exposure matrix with zero diagonal, where $W_{ij}$ measures bank $i$'s loss sensitivity to counterparty $j$. Let $u \\in \\mathbb{R}^{n}$ be a fixed shock direction vector and let $s \\in \\mathbb{R}$ be a scalar shock amplitude. Each bank’s equilibrium loss vector $\\ell(s) \\in \\mathbb{R}^{n}$ is defined implicitly by the fixed-point system\n$$\n\\ell(s) \\;=\\; W \\big( s\\,u \\;+\\; \\alpha\\,\\ell(s) \\;+\\; \\gamma\\,(\\ell(s)\\circ \\ell(s)) \\big),\n$$\nwhere $\\alpha \\in \\mathbb{R}$ and $\\gamma \\in \\mathbb{R}_{\\ge 0}$ are given parameters and $\\ell(s)\\circ \\ell(s)$ denotes the elementwise (Hadamard) square of $\\ell(s)$. Assume that $I - \\alpha W$ is nonsingular, which guarantees a unique solution $\\ell(s)$ for $s$ in a neighborhood of $0$.\n\nYour task is to obtain the second-order perturbation approximation of $\\ell(s)$ around $s=0$. That is, determine vectors $a \\in \\mathbb{R}^{n}$ and $b \\in \\mathbb{R}^{n}$ such that\n$$\n\\ell(s) \\;=\\; a\\,s \\;+\\; b\\,s^{2} \\;+\\; o(s^{2}) \\quad \\text{as } s \\to 0,\n$$\nand then evaluate the approximation $\\widehat{\\ell}(s) \\equiv a\\,s + b\\,s^{2}$ at the specified parameter values below.\n\nTest Suite. For each test case, compute and report $\\widehat{\\ell}(s)$:\n- Test case $1$:\n$$\nn=3,\\quad\nW=\\begin{bmatrix}\n0  0.3  0.2\\\\\n0.25  0  0.15\\\\\n0.1  0.2  0\n\\end{bmatrix},\\quad\n\\alpha=0.8,\\quad\n\\gamma=0.7,\\quad\nu=\\begin{bmatrix}1\\\\0\\\\0\\end{bmatrix},\\quad\ns=0.05.\n$$\n- Test case $2$:\n$$\nn=3,\\quad\nW=\\begin{bmatrix}\n0  0.45  0.45\\\\\n0.45  0  0.45\\\\\n0.45  0.45  0\n\\end{bmatrix},\\quad\n\\alpha=1.05,\\quad\n\\gamma=0.5,\\quad\nu=\\begin{bmatrix}0\\\\1\\\\0\\end{bmatrix},\\quad\ns=0.02.\n$$\n- Test case $3$:\n$$\nn=4,\\quad\nW=\\begin{bmatrix}\n0  0.2  0.1  0\\\\\n0.1  0  0.1  0.1\\\\\n0.05  0.1  0  0.1\\\\\n0  0.1  0.1  0\n\\end{bmatrix},\\quad\n\\alpha=0.9,\\quad\n\\gamma=0.0,\\quad\nu=\\begin{bmatrix}0.6\\\\0.4\\\\0\\\\0\\end{bmatrix},\\quad\ns=0.03.\n$$\n- Test case $4$:\n$$\nn=3,\\quad\nW=\\begin{bmatrix}\n0  0.3  0.2\\\\\n0.25  0  0.15\\\\\n0.1  0.2  0\n\\end{bmatrix},\\quad\n\\alpha=0.8,\\quad\n\\gamma=0.7,\\quad\nu=\\begin{bmatrix}0\\\\0\\\\1\\end{bmatrix},\\quad\ns=-0.05.\n$$\n\nFinal Output Format. Your program must output a single line containing a list of the four results, where each result is the list of components of $\\widehat{\\ell}(s)$ for the corresponding test case, each component rounded to $6$ decimal places. The format must have no spaces, for example:\n$$\n\\big[\\,[x_{1,1},x_{1,2},\\dots],[x_{2,1},x_{2,2},\\dots],[x_{3,1},\\dots],[x_{4,1},\\dots]\\,\\big].\n$$\nNo physical units are involved. All numerical answers must be decimals (not percentages).",
            "solution": "We start from the implicit fixed-point definition of the equilibrium loss vector $\\ell(s)\\in\\mathbb{R}^{n}$:\n$$\n\\ell(s) \\;=\\; W \\big( s\\,u \\;+\\; \\alpha\\,\\ell(s) \\;+\\; \\gamma\\,(\\ell(s)\\circ \\ell(s)) \\big).\n$$\nDefine the residual map $F:\\mathbb{R}^{n}\\times\\mathbb{R}\\to\\mathbb{R}^{n}$ by\n$$\nF(\\ell,s) \\;=\\; \\ell \\;-\\; W \\big( s\\,u \\;+\\; \\alpha\\,\\ell \\;+\\; \\gamma\\,(\\ell\\circ \\ell) \\big).\n$$\nBy assumption, the matrix $I-\\alpha W$ is nonsingular, which implies that for $s$ in a neighborhood of $0$ there exists a unique continuously differentiable function $\\ell(s)$ with $F(\\ell(s),s)=0$.\n\nWe seek a second-order perturbation expansion around $s=0$:\n$$\n\\ell(s) \\;=\\; a\\,s \\;+\\; b\\,s^{2} \\;+\\; o(s^{2}),\n$$\nfor vectors $a,b\\in\\mathbb{R}^{n}$. Substituting this expansion into the fixed-point system and collecting terms by powers of $s$ yields the equations determining $a$ and $b$.\n\nFirst-order terms. Substitute $\\ell(s)\\approx a\\,s$ and note that $(\\ell\\circ \\ell)\\approx (a\\circ a)\\,s^{2}$ contributes no first-order term. The $\\mathcal{O}(s)$ terms in $F(\\ell,s)=0$ satisfy\n$$\na \\;-\\; W\\big(u+\\alpha\\,a\\big) \\;=\\; 0,\n$$\nwhich can be rearranged as\n$$\n\\big(I-\\alpha W\\big)\\,a \\;=\\; W\\,u.\n$$\nBecause $I-\\alpha W$ is nonsingular, the unique first-order coefficient is\n$$\na \\;=\\; \\big(I-\\alpha W\\big)^{-1} W\\,u.\n$$\n\nSecond-order terms. Substitute $\\ell(s)\\approx a\\,s+b\\,s^{2}$ and observe that\n$$\n\\ell\\circ \\ell \\;=\\; (a\\circ a)\\,s^{2} \\;+\\; \\mathcal{O}(s^{3}),\n$$\nbecause $(a\\,s)\\circ (b\\,s^{2})$ is of order $s^{3}$. The $\\mathcal{O}(s^{2})$ terms in $F(\\ell,s)=0$ satisfy\n$$\nb \\;-\\; W\\big(\\alpha\\,b \\;+\\; \\gamma\\,(a\\circ a)\\big) \\;=\\; 0,\n$$\nwhich rearranges to\n$$\n\\big(I-\\alpha W\\big)\\,b \\;=\\; W\\big(\\gamma\\,(a\\circ a)\\big).\n$$\nThus, the second-order coefficient is\n$$\nb \\;=\\; \\big(I-\\alpha W\\big)^{-1} W\\big(\\gamma\\,(a\\circ a)\\big).\n$$\n\nPutting the coefficients together, the second-order perturbation approximation of the equilibrium loss vector is\n$$\n\\widehat{\\ell}(s) \\;=\\; a\\,s \\;+\\; b\\,s^{2}, \\quad\na \\;=\\; \\big(I-\\alpha W\\big)^{-1} W\\,u,\\quad\nb \\;=\\; \\big(I-\\alpha W\\big)^{-1} W\\big(\\gamma\\,(a\\circ a)\\big).\n$$\n\nProperties and checks relevant to the test suite:\n- When $\\gamma=0$, the convex term vanishes and $b=0$, so the approximation is purely linear: $\\widehat{\\ell}(s)=a\\,s$.\n- If $s0$ but $\\gamma0$, the quadratic term $b\\,s^{2}$ is nonnegative componentwise whenever $W\\ge 0$ and $a\\circ a\\ge 0$, creating asymmetry between positive and negative shocks due to convex balance sheet costs.\n- The condition that $I-\\alpha W$ be nonsingular is assured when $\\alpha\\,\\rho(W)  1$, where $\\rho(W)$ is the spectral radius. The provided numerical cases satisfy this, including a near-boundary configuration where $\\alpha\\,\\rho(W)$ is close to $1$.\n\nAlgorithmic implementation for each test case:\n- Form $A = I - \\alpha W$.\n- Solve $A\\,a = W\\,u$ for $a$.\n- Compute $v = \\gamma\\,(a\\circ a)$ and solve $A\\,b = W\\,v$ for $b$.\n- Evaluate $\\widehat{\\ell}(s) = a\\,s + b\\,s^{2}$.\n- Round each component to $6$ decimal places and report the vector.\n\nApplying this procedure to each of the four specified test cases produces the requested list of vectors in the final output format, with no spaces and each component rounded to $6$ decimal places.",
            "answer": "```python\nimport numpy as np\n\ndef second_order_approx(W, alpha, gamma, u, s):\n    \"\"\"\n    Compute the second-order perturbation approximation:\n    l_hat(s) = a*s + b*s^2\n    where:\n      (I - alpha W) a = W u\n      (I - alpha W) b = W [ gamma (a◦a) ]\n    \"\"\"\n    W = np.array(W, dtype=float)\n    u = np.array(u, dtype=float).reshape(-1)\n    n = W.shape[0]\n    I = np.eye(n)\n    A = I - alpha * W\n    # Solve for a\n    rhs_a = W @ u\n    a = np.linalg.solve(A, rhs_a)\n    # Solve for b\n    v = gamma * (a * a)\n    rhs_b = W @ v\n    b = np.linalg.solve(A, rhs_b)\n    # Evaluate approximation\n    l_hat = a * s + b * (s ** 2)\n    return l_hat\n\ndef format_vector(vec):\n    # Format a 1D numpy array as a bracketed list with 6 decimal places, no spaces\n    return \"[\" + \",\".join(f\"{x:.6f}\" for x in vec) + \"]\"\n\ndef solve():\n    # Define the test cases as specified in the problem statement.\n    test_cases = [\n        # Test case 1\n        {\n            \"W\": [\n                [0.0, 0.3, 0.2],\n                [0.25, 0.0, 0.15],\n                [0.1, 0.2, 0.0]\n            ],\n            \"alpha\": 0.8,\n            \"gamma\": 0.7,\n            \"u\": [1.0, 0.0, 0.0],\n            \"s\": 0.05\n        },\n        # Test case 2\n        {\n            \"W\": [\n                [0.0, 0.45, 0.45],\n                [0.45, 0.0, 0.45],\n                [0.45, 0.45, 0.0]\n            ],\n            \"alpha\": 1.05,\n            \"gamma\": 0.5,\n            \"u\": [0.0, 1.0, 0.0],\n            \"s\": 0.02\n        },\n        # Test case 3 (gamma = 0)\n        {\n            \"W\": [\n                [0.0, 0.2, 0.1, 0.0],\n                [0.1, 0.0, 0.1, 0.1],\n                [0.05, 0.1, 0.0, 0.1],\n                [0.0, 0.1, 0.1, 0.0]\n            ],\n            \"alpha\": 0.9,\n            \"gamma\": 0.0,\n            \"u\": [0.6, 0.4, 0.0, 0.0],\n            \"s\": 0.03\n        },\n        # Test case 4 (negative shock)\n        {\n            \"W\": [\n                [0.0, 0.3, 0.2],\n                [0.25, 0.0, 0.15],\n                [0.1, 0.2, 0.0]\n            ],\n            \"alpha\": 0.8,\n            \"gamma\": 0.7,\n            \"u\": [0.0, 0.0, 1.0],\n            \"s\": -0.05\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        W = case[\"W\"]\n        alpha = case[\"alpha\"]\n        gamma = case[\"gamma\"]\n        u = case[\"u\"]\n        s = case[\"s\"]\n        l_hat = second_order_approx(W, alpha, gamma, u, s)\n        results.append(format_vector(l_hat))\n\n    # Final print statement in the exact required format: list of lists, no spaces.\n    print(\"[\" + \",\".join(results) + \"]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "We now turn to the canonical application of second-order perturbation in modern macroeconomics: analyzing the dynamics of a stochastic growth model. This exercise requires you to compute a second-order approximation to the capital accumulation policy function and use it to simulate the economy's response to technology shocks . By comparing the model's reaction to positive versus negative shocks, you will directly observe the kind of asymmetry that second-order, but not first-order, approximations are designed to capture.",
            "id": "2428798",
            "problem": "You are asked to design and implement a program that computes Generalized Impulse Response Functions (GIRFs) for a nonlinear capital accumulation model subject to a stochastic technology process, using a second-order perturbation method around the deterministic steady state. The goal is to quantify and report the asymmetry between the responses to a positive versus a negative one-standard-deviation technology shock, and to do so across a small suite of parameter configurations.\n\nThe economic environment is a simple nonlinear production-investment model without intertemporal optimization. The model features adjustment costs that make the law of motion implicit and nonlinear, a standard Cobb-Douglas production function, and a mean-reverting technology process. The model is specified as follows.\n\n- State dynamics. Let $k_t$ denote capital at the end of period $t$, and let $z_t$ denote the (log) technology at time $t$. Let $A_t = \\exp(z_t)$ denote the level of technology. Given a fixed savings rate $s \\in (0,1)$ and a quadratic adjustment cost, capital evolves implicitly via\n$$\nF(i,k,z) \\equiv i - (1-\\delta) k - s \\,\\exp(z)\\, k^{\\alpha} + \\frac{\\phi}{2}\\,\\frac{(i-k)^2}{k} = 0,\n$$\nwhere $i \\equiv k_{t}$, $k \\equiv k_{t-1}$, $z \\equiv z_t$, $\\delta \\in (0,1)$ is the depreciation rate, $\\alpha \\in (0,1)$ is the output elasticity of capital, and $\\phi \\ge 0$ is the adjustment cost parameter. Output is defined by\n$$\ny_t = \\exp(z_t)\\, k_{t-1}^{\\alpha}.\n$$\n\n- Technology process. The technology follows a stationary autoregressive process of order one with independent and identically distributed Gaussian innovations:\n$$\nz_{t+1} = \\rho\\, z_t + \\sigma\\, \\epsilon_{t+1}, \\quad \\epsilon_{t+1} \\sim \\mathcal{N}(0,1),\n$$\nwith persistence $\\rho \\in (-1,1)$ and standard deviation $\\sigma > 0$. There are no physical units required for the variables; report all numerical results as unit-free real numbers.\n\n- Steady state. The deterministic steady state sets $z=0$, $i=k=\\bar{k}$, and $z=0$. With the adjustment cost at the steady state equal to zero, the steady state $\\bar{k}$ solves\n$$\n\\delta \\,\\bar{k} = s\\, \\bar{k}^{\\alpha} \\quad \\Longrightarrow \\quad \\bar{k} = \\left(\\frac{s}{\\delta}\\right)^{\\frac{1}{1-\\alpha}}.\n$$\n\n- Second-order perturbation around the steady state. Define the implicit solution $i = h(k,z)$ to $F(i,k,z)=0$. A second-order perturbation approximation to the policy function $h(k,z)$ around $(\\bar{k},0)$ is the second-order Taylor expansion\n$$\nh(k,z) \\approx \\bar{k} + h_k \\,(k-\\bar{k}) + h_z \\, z + \\frac{1}{2}\\left[ h_{kk}\\,(k-\\bar{k})^2 + 2h_{kz}\\,(k-\\bar{k})\\, z + h_{zz}\\, z^2 \\right],\n$$\nwhere the derivatives $h_k$, $h_z$, $h_{kk}$, $h_{kz}$, and $h_{zz}$ are evaluated at $(\\bar{k},0)$ and are obtained using the implicit function theorem from derivatives of $F(i,k,z)$ at $(i,k,z)=(\\bar{k},\\bar{k},0)$.\n\n- Generalized Impulse Response Functions. For a given horizon $H \\in \\mathbb{N}$ and number of Monte Carlo paths $R \\in \\mathbb{N}$, the GIRF of a variable $v_t$ to an initial shock $\\epsilon_0$ at time $t=0$ is defined for horizon $h \\in \\{0,1,\\dots,H\\}$ as\n$$\n\\text{GIRF}_v(h;\\epsilon_0) \\equiv \\mathbb{E}\\left[ v_{t+h} \\,\\middle|\\, \\epsilon_0, \\text{ initial at steady state}, \\{\\epsilon_j\\}_{j\\ge 1} \\right] - \\mathbb{E}\\left[ v_{t+h} \\,\\middle|\\, \\epsilon_0 = 0, \\text{ initial at steady state}, \\{\\epsilon_j\\}_{j\\ge 1} \\right],\n$$\nwhere the expectations are taken over future shocks $\\{\\epsilon_j\\}_{j\\ge 1}$, which are drawn identically in both the shocked and baseline paths to isolate the effect of the initial innovation. In this problem, set $v_t = y_t$ and take $\\epsilon_0 \\in \\{+1,-1\\}$. The GIRFs are generated by simulating the second-order approximated model for $R$ Monte Carlo paths under a given parameterization, starting from $(k_{-1}, z_{-1}) = (\\bar{k},0)$, using the same random seeds for the future innovations in the shocked and baseline paths. Use the second-order approximation $h(k,z)$ to propagate capital, and the exact formula for $z_{t+1}$.\n\n- Asymmetry measure. To highlight asymmetry between responses to positive and negative shocks, compute\n$$\n\\mathcal{A} \\equiv \\max_{0 \\le h \\le H} \\left| \\text{GIRF}_y(h; +1) + \\text{GIRF}_y(h; -1) \\right|.\n$$\nIn a linear-symmetric model, one expects $\\text{GIRF}_y(h; -1) \\approx -\\text{GIRF}_y(h; +1)$, so $\\mathcal{A}$ would be close to zero. Nonlinearity captured by the second-order approximation typically produces $\\mathcal{A} > 0$.\n\n- Your task. Derive the needed derivatives from first principles and implement a program that\n- computes the steady state $\\bar{k}$,\n- computes the derivatives needed for the second-order approximation to $h(k,z)$ at $(\\bar{k},0)$,\n- simulates the model using the second-order approximation to produce the GIRFs of $y_t$ for $\\epsilon_0=+1$ and $\\epsilon_0=-1$,\n- computes and reports the asymmetry measure $\\mathcal{A}$ for each of the parameter sets in the test suite below.\n\n- Test suite. Use the following parameter sets, each defining a separate test case. For each case, set $H=20$ and $R=5000$ Monte Carlo paths. The parameters are:\n- Case A (nonlinear adjustment costs, moderate volatility): $(\\alpha,\\delta,s,\\phi,\\rho,\\sigma) = (0.33,\\,0.08,\\,0.25,\\,4.0,\\,0.90,\\,0.02)$.\n- Case B (no adjustment costs, same volatility): $(\\alpha,\\delta,s,\\phi,\\rho,\\sigma) = (0.33,\\,0.08,\\,0.25,\\,0.0,\\,0.90,\\,0.02)$.\n- Case C (nonlinear adjustment costs, low volatility): $(\\alpha,\\delta,s,\\phi,\\rho,\\sigma) = (0.33,\\,0.08,\\,0.25,\\,4.0,\\,0.90,\\,0.002)$.\n\n- Final output format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered as $[\\mathcal{A}_{\\text{A}}, \\mathcal{A}_{\\text{B}}, \\mathcal{A}_{\\text{C}}]$, where each entry is a real number. For example, a valid output line looks like\n\"[0.012345,0.006789,0.001234]\".",
            "solution": "The problem requires the computation of an asymmetry measure for Generalized Impulse Response Functions (GIRFs) in a nonlinear capital accumulation model. This is to be achieved by employing a second-order perturbation method. The analysis proceeds in two main stages: first, the derivation of the second-order accurate policy function for capital accumulation, and second, the simulation of the model to generate GIRFs and the asymmetry measure.\n\n**Step 1: Model Specification and Steady State**\n\nThe economic model is described by the following equations:\nThe law of motion for capital $k_t$ is given implicitly by:\n$$F(k_t, k_{t-1}, z_t) \\equiv k_t - (1-\\delta) k_{t-1} - s \\exp(z_t) k_{t-1}^{\\alpha} + \\frac{\\phi}{2} \\frac{(k_t - k_{t-1})^2}{k_{t-1}} = 0$$\nwhere $z_t$ is the log-technology process, which follows a first-order autoregressive process:\n$$z_{t+1} = \\rho z_t + \\sigma \\epsilon_{t+1}, \\quad \\epsilon_{t+1} \\sim \\mathcal{N}(0,1)$$\nOutput $y_t$ is given by a Cobb-Douglas production function:\n$$y_t = \\exp(z_t) k_{t-1}^{\\alpha}$$\nThe deterministic steady state is characterized by $z_t = 0$ and $k_t = k_{t-1} = \\bar{k}$ for all $t$. Substituting these into the capital accumulation equation yields the steady-state capital stock $\\bar{k}$:\n$$\\bar{k} - (1-\\delta)\\bar{k} - s \\bar{k}^{\\alpha} = 0 \\implies \\delta \\bar{k} = s \\bar{k}^{\\alpha}$$\nSolving for $\\bar{k}$ gives:\n$$\\bar{k} = \\left(\\frac{s}{\\delta}\\right)^{\\frac{1}{1-\\alpha}}$$\n\n**Step 2: Second-Order Perturbation via Implicit Function Theorem**\n\nWe seek a second-order Taylor approximation of the policy function $i = h(k,z)$ around the steady state $(k,z)=(\\bar{k},0)$, where we use the notation $i=k_t$ and $k=k_{t-1}$. The implicit function is $F(i,k,z) = 0$. The derivatives of $h$ are found by repeatedly differentiating the identity $F(h(k,z), k, z) = 0$. All derivatives are evaluated at the steady state $(i,k,z)=(\\bar{k},\\bar{k},0)$.\n\nFirst, we calculate the necessary partial derivatives of $F(i,k,z)$:\n$F_i = 1 + \\phi\\frac{i-k}{k} \\implies F_i\\vert_{ss} = 1$\n$F_k = -(1-\\delta) - s\\alpha e^z k^{\\alpha-1} - \\phi\\frac{i-k}{k} - \\frac{\\phi}{2}\\frac{(i-k)^2}{k^2} \\implies F_k\\vert_{ss} = -(1-\\delta) - s\\alpha\\bar{k}^{\\alpha-1} = -(1-\\delta(1-\\alpha))$\n$F_z = -se^z k^\\alpha \\implies F_z\\vert_{ss} = -s\\bar{k}^\\alpha = -\\delta\\bar{k}$\n\n$F_{ii} = \\frac{\\phi}{k} \\implies F_{ii}\\vert_{ss} = \\frac{\\phi}{\\bar{k}}$\n$F_{ik} = -\\frac{\\phi i}{k^2} \\implies F_{ik}\\vert_{ss} = -\\frac{\\phi}{\\bar{k}}$\n$F_{iz} = 0$\n$F_{kk} = -s\\alpha(\\alpha-1)e^z k^{\\alpha-2} + \\frac{\\phi}{k} \\implies F_{kk}\\vert_{ss} = -s\\alpha(\\alpha-1)\\bar{k}^{\\alpha-2} + \\frac{\\phi}{\\bar{k}} = -\\frac{\\delta\\alpha(\\alpha-1)}{\\bar{k}} + \\frac{\\phi}{\\bar{k}}$\n$F_{kz} = -s\\alpha e^z k^{\\alpha-1} \\implies F_{kz}\\vert_{ss} = -s\\alpha\\bar{k}^{\\alpha-1} = -\\alpha\\delta$\n$F_{zz} = -se^z k^\\alpha \\implies F_{zz}\\vert_{ss} = -s\\bar{k}^\\alpha = -\\delta\\bar{k}$\n\nUsing the implicit function theorem, the first derivatives of $h(k,z)$ are:\n$h_k = -\\frac{F_k}{F_i} = 1-\\delta(1-\\alpha)$\n$h_z = -\\frac{F_z}{F_i} = \\delta\\bar{k}$\n\nThe second derivatives are found by differentiating the first-order conditions again:\n$F_i h_{kk} + F_{ii}h_k^2 + 2F_{ik}h_k + F_{kk} = 0 \\implies h_{kk} = -(F_{ii}h_k^2 + 2F_{ik}h_k + F_{kk})$\n$F_i h_{kz} + F_{ii}h_k h_z + F_{ik}h_z + F_{iz}h_k + F_{kz} = 0 \\implies h_{kz} = -(F_{ii}h_k h_z + F_{ik}h_z + F_{kz})$\n$F_i h_{zz} + F_{ii}h_z^2 + 2F_{iz}h_z + F_{zz} = 0 \\implies h_{zz} = -(F_{ii}h_z^2 + F_{zz})$\nSubstituting the derivatives of $F$ evaluated at the steady state gives:\n$h_{kk} = -\\left(\\frac{\\phi}{\\bar{k}}h_k^2 - \\frac{2\\phi}{\\bar{k}}h_k - \\frac{\\delta\\alpha(\\alpha-1)}{\\bar{k}} + \\frac{\\phi}{\\bar{k}}\\right) = -\\frac{1}{\\bar{k}}\\left(\\phi(h_k-1)^2 - \\delta\\alpha(\\alpha-1)\\right)$\n$h_{kz} = -\\left(\\frac{\\phi}{\\bar{k}}h_k h_z - \\frac{\\phi}{\\bar{k}}h_z - \\alpha\\delta\\right) = -\\frac{\\phi}{\\bar{k}}(h_k-1)h_z + \\alpha\\delta$\n$h_{zz} = -\\left(\\frac{\\phi}{\\bar{k}}h_z^2 - \\delta\\bar{k}\\right) = \\delta\\bar{k} - \\frac{\\phi}{\\bar{k}}h_z^2$\n\nThe second-order approximation of the policy function $k_t = h(k_{t-1}, z_t)$ around the steady state, expressed in terms of deviations $\\hat{k}_t = k_t - \\bar{k}$ and $z_t$, is:\n$$\\hat{k}_t \\approx h_k \\hat{k}_{t-1} + h_z z_t + \\frac{1}{2}h_{kk}\\hat{k}_{t-1}^2 + h_{kz}\\hat{k}_{t-1}z_t + \\frac{1}{2}h_{zz}z_t^2$$\n\n**Step 3: Simulation of Generalized Impulse Response Functions**\n\nThe GIRF for output $y_t$ at horizon $h$ to an initial shock $\\epsilon_0$ is computed as the difference between the expected path of the variable following the shock and its expected path in the absence of the shock (the baseline).\n$$ \\text{GIRF}_y(h;\\epsilon_0) = \\mathbb{E}[ y_h \\,|\\, \\epsilon_0, \\text{state}_{ -1}=(\\bar{k},0) ] - \\mathbb{E}[ y_h \\,|\\, \\epsilon_0=0, \\text{state}_{ -1}=(\\bar{k},0) ] $$\nThe expectation is over future shocks $\\{\\epsilon_j\\}_{j \\ge 1}$ and is approximated via Monte Carlo simulation over $R$ paths. The simulation procedure is as follows:\n1. For each parameter case, calculate $\\bar{k}$ and the derivatives of $h$.\n2. Generate $R$ paths of exogenous shocks $\\{\\epsilon_{r,h}\\}_{h=1}^H$ for $r=1,\\dots,R$. Use a fixed random seed for reproducibility.\n3. Simulate three scenarios for $R$ paths each: a baseline ($\\epsilon_0=0$), a positive shock ($\\epsilon_0=+1$), and a negative shock ($\\epsilon_0=-1$).\n4. For each scenario and each path $r$, starting with $(k_{-1,r}, z_{-1,r}) = (\\bar{k},0)$, iterate from $h=0$ to $H$:\n   a. Update the technology process: $z_{h,r} = \\rho z_{h-1,r} + \\sigma \\epsilon_{h,r}$. For $h=0$, $\\epsilon_{0,r}$ is deterministic for each scenario. For $h>0$, $\\epsilon_{h,r}$ is the pre-generated random shock, identical across scenarios.\n   b. Calculate output for period $h$: $y_{h,r} = \\exp(z_{h,r}) k_{h-1,r}^{\\alpha}$.\n   c. Update the capital stock using the second-order policy rule: $k_{h,r} = \\bar{k} + \\hat{k}_{h,r}$.\n5. Average the simulated output paths $y_{h,r}$ across all $R$ paths for each scenario to obtain $\\mathbb{E}[y_h]$.\n6. Compute $\\text{GIRF}_y(h;+1)$ and $\\text{GIRF}_y(h;-1)$ for $h=0,\\dots,H$.\n7. The asymmetry measure $\\mathcal{A}$ is then found by taking the maximum absolute value of the sum of the positive and negative shock responses over the horizon:\n$$ \\mathcal{A} = \\max_{0 \\le h \\le H} |\\text{GIRF}_y(h;+1) + \\text{GIRF}_y(h;-1)| $$\n\nThis procedure is implemented for each of the three test cases specified. The nonlinearity introduced by the second-order terms is expected to make $\\mathcal{A}$ greater than zero.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases and print the results.\n    \"\"\"\n    \n    # Define test cases from the problem statement.\n    # (alpha, delta, s, phi, rho, sigma)\n    test_cases = [\n        (0.33, 0.08, 0.25, 4.0, 0.90, 0.02),  # Case A\n        (0.33, 0.08, 0.25, 0.0, 0.90, 0.02),  # Case B\n        (0.33, 0.08, 0.25, 4.0, 0.90, 0.002), # Case C\n    ]\n    \n    # Simulation parameters\n    H = 20\n    R = 5000\n    \n    results = []\n    for params in test_cases:\n        result = compute_asymmetry(params, H, R, seed=42)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\ndef compute_asymmetry(params, H, R, seed=0):\n    \"\"\"\n    Computes the GIRF asymmetry measure for a given set of model parameters.\n\n    Args:\n        params (tuple): A tuple of model parameters (alpha, delta, s, phi, rho, sigma).\n        H (int): The simulation horizon.\n        R (int): The number of Monte Carlo paths.\n        seed (int): The seed for the random number generator.\n\n    Returns:\n        float: The computed asymmetry measure A.\n    \"\"\"\n    alpha, delta, s, phi, rho, sigma = params\n\n    # Step 1: Compute steady state\n    k_bar = (s / delta)**(1 / (1 - alpha))\n\n    # Step 2: Compute derivatives for second-order approximation\n    h_k = 1.0 - delta * (1.0 - alpha)\n    h_z = delta * k_bar\n    \n    # Note: h_kk = -1/k_bar * (phi*(h_k-1)**2 - delta*alpha*(1-alpha))\n    h_kk = (1.0 / k_bar) * (delta * alpha * (1.0 - alpha) - phi * (h_k - 1.0)**2)\n    \n    # Note: h_kz = alpha*delta - phi/k_bar * (h_k-1)*h_z\n    h_kz = alpha * delta - (phi / k_bar) * (h_k - 1.0) * h_z\n    \n    # Note: h_zz = delta*k_bar - phi/k_bar * h_z**2\n    h_zz = delta * k_bar - (phi / k_bar) * h_z**2\n\n    # Coefficients for the policy rule (including 1/2 factor)\n    H_kk_half = 0.5 * h_kk\n    H_zz_half = 0.5 * h_zz\n\n    # Step 3: Setup simulation\n    rng = np.random.default_rng(seed)\n    # Future shocks for t=1,...,H\n    future_shocks = rng.normal(size=(R, H))\n\n    # Dictionary to hold output paths for each scenario\n    y_paths = {'base': np.zeros((R, H + 1)), 'pos': np.zeros((R, H + 1)), 'neg': np.zeros((R, H + 1))}\n    \n    initial_shocks = {'base': 0.0, 'pos': 1.0, 'neg': -1.0}\n\n    # Step 4: Run simulation\n    for scenario, eps0 in initial_shocks.items():\n        # Initialize states at t=-1\n        k_prev = np.full(R, k_bar)\n        z_prev = np.zeros(R)\n\n        # Main simulation loop over time h=0,...,H\n        for h in range(H + 1):\n            # Update technology process\n            if h == 0:\n                z_curr = rho * z_prev + sigma * eps0\n            else:\n                shocks_h = future_shocks[:, h-1]\n                z_curr = rho * z_prev + sigma * shocks_h\n            \n            # Compute output y_h = exp(z_h) * k_{h-1}^alpha\n            y_paths[scenario][:, h] = np.exp(z_curr) * (k_prev**alpha)\n\n            # Compute new capital stock k_h = h(k_{h-1}, z_h) using 2nd order approximation\n            k_hat_prev = k_prev - k_bar\n            \n            k_hat_curr = (h_k * k_hat_prev + h_z * z_curr\n                          + H_kk_half * k_hat_prev**2 \n                          + h_kz * k_hat_prev * z_curr \n                          + H_zz_half * z_curr**2)\n            \n            k_curr = k_bar + k_hat_curr\n            \n            # Update states for next period\n            k_prev = k_curr\n            z_prev = z_curr\n\n    # Step 5: Compute GIRFs by averaging\n    y_exp_base = np.mean(y_paths['base'], axis=0)\n    y_exp_pos = np.mean(y_paths['pos'], axis=0)\n    y_exp_neg = np.mean(y_paths['neg'], axis=0)\n    \n    girf_pos = y_exp_pos - y_exp_base\n    girf_neg = y_exp_neg - y_exp_base\n\n    # Step 6: Compute asymmetry measure\n    asymmetry_h = np.abs(girf_pos + girf_neg)\n    \n    # Step 7: Return maximum asymmetry over horizon\n    return np.max(asymmetry_h)\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "Our final practice demonstrates a more sophisticated application, showing how a local approximation can be used to analyze a global nonlinearity. Here, we introduce a non-negativity constraint on investment—a feature that may only occasionally bind, depending on the size and sign of economic shocks . This problem challenges you to combine the second-order approximation of the investment policy with analytical calculations based on the normal distribution to quantify the impact of this constraint, illustrating how local methods can provide powerful insights into more complex economic behavior.",
            "id": "2428812",
            "problem": "Consider a representative firm in discrete time facing stochastic productivity and quadratic investment adjustment costs. Let the exogenous productivity be $A_t = \\exp(\\varepsilon_t)$ with the shock process given by $\\varepsilon_{t+1} = \\rho\\,\\varepsilon_t + \\sigma\\,\\eta_{t+1}$ where $\\eta_{t+1}\\sim \\mathcal{N}(0,1)$ is independent and identically distributed and $\\rho\\in(-1,1)$, $\\sigma > 0$. For local analysis, treat the capital stock as fixed at its deterministic steady-state level $\\bar{k} > 0$ and assume quadratic adjustment costs around steady depreciation. Impose an occasionally binding non-negativity constraint on gross investment $i_t \\geq 0$.\n\nUse the following core relationships grounded in $q$-theory with quadratic adjustment costs and a standard approximation for the shadow value of capital. With adjustment cost parameter $\\phi > 0$ and depreciation rate $\\delta \\in (0,1)$, the first-order condition linking the shadow value of capital $q_t$ to gross investment is\n$$\nq_t \\;=\\; 1 \\;+\\; \\phi\\!\\left(\\frac{i_t}{\\bar{k}} - \\delta\\right).\n$$\nUnder small deviations and risk-adjusted pricing that is locally linear in expected returns, approximate the shadow value of capital as the discounted expected one-period-ahead marginal payoff of installed capital,\n$$\nq_t \\;\\approx\\; \\beta\\,(1-\\delta) \\;+\\; \\beta\\,\\alpha\\,\\bar{k}^{\\alpha - 1}\\, \\mathbb{E}_t[A_{t+1}],\n$$\nwhere $\\beta\\in(0,1)$ is the discount factor and $\\alpha\\in(0,1)$ is the capital elasticity in the Cobb-Douglas production technology $y_t = A_t \\bar{k}^\\alpha$. Because $A_{t+1} = \\exp(\\varepsilon_{t+1})$ with $\\varepsilon_{t+1} \\mid \\varepsilon_t \\sim \\mathcal{N}(\\rho\\,\\varepsilon_t,\\sigma^2)$, it follows that $\\mathbb{E}_t[A_{t+1}] = \\exp\\!\\left(\\rho\\,\\varepsilon_t + \\tfrac{1}{2}\\sigma^2\\right)$.\n\n1. Starting from the definitions above, express the gross investment policy $i(\\varepsilon_t)$ as a function of the current shock $\\varepsilon_t$ via the composition $q(\\varepsilon_t)$ and the adjustment cost condition. Derive the second-order Taylor expansion around $\\varepsilon_t = 0$:\n$$\ni(\\varepsilon_t) \\;\\approx\\; a \\;+\\; b\\,\\varepsilon_t \\;+\\; \\tfrac{1}{2}\\,c\\,\\varepsilon_t^2,\n$$\nand compute the coefficients $a$, $b$, and $c$ in terms of the structural parameters $(\\alpha,\\beta,\\delta,\\phi,\\bar{k},\\rho,\\sigma)$. Treat $\\sigma$ as small but nonzero so that terms of order $\\sigma^2$ are retained in the expansion.\n\n2. Let $g(\\varepsilon) := a + b\\,\\varepsilon + \\tfrac{1}{2}c\\,\\varepsilon^2$ and $\\varepsilon \\sim \\mathcal{N}(0,\\sigma^2)$. Using only exact properties of the Gaussian distribution (no simulation), compute:\n   - The unconditional mean of the unconstrained second-order approximation, $\\mathbb{E}[g(\\varepsilon)]$, retaining terms up to order $\\sigma^2$.\n   - The exact Gaussian expectation of the occasionally constrained policy, $\\mathbb{E}[\\max\\{0,g(\\varepsilon)\\}]$, by analytically integrating the quadratic $g(\\varepsilon)$ over the region where it is positive. Express your result using the standard normal cumulative distribution function $\\Phi(\\cdot)$ and probability density function $\\varphi(\\cdot)$, and handle all sign cases of $c$ and the discriminant $\\Delta = b^2 - 2ac$.\n   - The binding probability $\\mathbb{P}(g(\\varepsilon)\\le 0)$ as a decimal in $[0,1]$.\n\n3. Implement a program that, for each parameter set in the test suite below, computes $a$, $b$, $c$, then returns three numbers: the approximate unconstrained mean $\\mathbb{E}[g(\\varepsilon)]$, the constrained mean $\\mathbb{E}[\\max\\{0,g(\\varepsilon)\\}]$, and the binding probability $\\mathbb{P}(g(\\varepsilon)\\le 0)$. All results must be real numbers with no units; probabilities must be decimals in $[0,1]$.\n\nUse the following test suite of parameter sets $(\\alpha,\\beta,\\delta,\\phi,\\bar{k},\\rho,\\sigma)$:\n- Test 1 (baseline, low volatility): $(0.33, 0.96, 0.08, 4.0, 1.0, 0.9, 0.10)$.\n- Test 2 (more responsive adjustment): $(0.33, 0.96, 0.08, 1.0, 1.0, 0.95, 0.25)$.\n- Test 3 (greater chance of binding): $(0.20, 0.90, 0.05, 0.50, 1.0, 0.90, 0.30)$.\n- Test 4 (near-threshold calibration): $(0.20, 0.90, 0.164, 0.95, 1.0, 0.90, 0.20)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, stacking the three outputs for each test in order. Concretely, print\n$$\n[\\mathbb{E}[g]_1,\\;\\mathbb{E}[\\max\\{0,g\\}]_1,\\;\\mathbb{P}(g\\le 0)_1,\\;\\ldots,\\;\\mathbb{E}[g]_4,\\;\\mathbb{E}[\\max\\{0,g\\}]_4,\\;\\mathbb{P}(g\\le 0)_4],\n$$\nwhere the subscript indexes the test case. No other text should be printed. No physical units are involved; probabilities must be decimals, not percentages.",
            "solution": "**Part 1: Derivation of the Second-Order Approximation**\n\nFirst, we derive the investment policy function $i(\\varepsilon_t)$. From the first-order condition, we isolate gross investment $i_t$:\n$$\nq_t = 1 + \\phi\\left(\\frac{i_t}{\\bar{k}} - \\delta\\right) \\implies i_t = \\frac{\\bar{k}}{\\phi}(q_t - 1 + \\phi\\delta)\n$$\nSubstitute the approximation for Tobin's $q_t$:\n$$\ni_t = \\frac{\\bar{k}}{\\phi}\\left( \\left( \\beta(1-\\delta) + \\beta\\alpha\\bar{k}^{\\alpha-1} \\mathbb{E}_t[A_{t+1}] \\right) - 1 + \\phi\\delta \\right)\n$$\nUsing the given expression for the conditional expectation, $\\mathbb{E}_t[A_{t+1}] = \\exp(\\rho\\varepsilon_t + \\frac{1}{2}\\sigma^2)$, we obtain the investment policy as a function of the current shock $\\varepsilon_t$:\n$$\ni(\\varepsilon_t) = \\frac{\\bar{k}}{\\phi}(\\beta(1-\\delta) - 1 + \\phi\\delta) + \\frac{\\beta\\alpha\\bar{k}^{\\alpha}}{\\phi} \\exp\\left(\\rho\\varepsilon_t + \\frac{1}{2}\\sigma^2\\right)\n$$\nThis function is of the form $i(\\varepsilon_t) = C_1 + C_2 \\exp(\\rho\\varepsilon_t + \\frac{1}{2}\\sigma^2)$, which we will expand in a Taylor series around $\\varepsilon_t = 0$. The second-order expansion is $i(\\varepsilon_t) \\approx i(0) + i'(0)\\varepsilon_t + \\frac{1}{2}i''(0)\\varepsilon_t^2$.\nBy comparison with $g(\\varepsilon_t) = a + b\\varepsilon_t + \\frac{1}{2}c\\varepsilon_t^2$, we identify the coefficients as $a=i(0)$, $b=i'(0)$, and $c=i''(0)$.\nWe first compute the derivatives of $i(\\varepsilon_t)$ with respect to $\\varepsilon_t$:\n$$\ni'(\\varepsilon_t) = \\frac{\\beta\\alpha\\bar{k}^{\\alpha}}{\\phi} \\rho \\exp\\left(\\rho\\varepsilon_t + \\frac{1}{2}\\sigma^2\\right)\n$$\n$$\ni''(\\varepsilon_t) = \\frac{\\beta\\alpha\\bar{k}^{\\alpha}}{\\phi} \\rho^2 \\exp\\left(\\rho\\varepsilon_t + \\frac{1}{2}\\sigma^2\\right)\n$$\nEvaluating these at $\\varepsilon_t = 0$:\n$$\na = i(0) = \\frac{\\bar{k}}{\\phi}(\\beta(1-\\delta) - 1 + \\phi\\delta) + \\frac{\\beta\\alpha\\bar{k}^{\\alpha}}{\\phi} \\exp\\left(\\frac{1}{2}\\sigma^2\\right)\n$$\n$$\nb = i'(0) = \\frac{\\beta\\alpha\\bar{k}^{\\alpha}}{\\phi} \\rho \\exp\\left(\\frac{1}{2}\\sigma^2\\right)\n$$\n$$\nc = i''(0) = \\frac{\\beta\\alpha\\bar{k}^{\\alpha}}{\\phi} \\rho^2 \\exp\\left(\\frac{1}{2}\\sigma^2\\right)\n$$\nThese expressions define the coefficients of the quadratic approximation $g(\\varepsilon_t)$.\n\n**Part 2: Statistical Properties of the Approximated Policy**\n\nWe are given $g(\\varepsilon) = a + b\\varepsilon + \\frac{1}{2}c\\varepsilon^2$ with $\\varepsilon \\sim \\mathcal{N}(0, \\sigma^2)$.\n\n**Unconstrained Mean:**\nThe expectation of $g(\\varepsilon)$ is found using the linearity of expectation and properties of the normal distribution:\n$$\n\\mathbb{E}[g(\\varepsilon)] = \\mathbb{E}\\left[a + b\\varepsilon + \\frac{1}{2}c\\varepsilon^2\\right] = a + b\\,\\mathbb{E}[\\varepsilon] + \\frac{1}{2}c\\,\\mathbb{E}[\\varepsilon^2]\n$$\nFor $\\varepsilon \\sim \\mathcal{N}(0, \\sigma^2)$, we have $\\mathbb{E}[\\varepsilon] = 0$ and $\\mathbb{E}[\\varepsilon^2] = \\text{Var}(\\varepsilon) + (\\mathbb{E}[\\varepsilon])^2 = \\sigma^2$. Therefore, the unconstrained mean is:\n$$\n\\mathbb{E}[g(\\varepsilon)] = a + \\frac{1}{2}c\\sigma^2\n$$\n\n**Binding Probability and Constrained Mean:**\nThe binding probability is $\\mathbb{P}(g(\\varepsilon) \\le 0)$. The constrained expectation is $\\mathbb{E}[\\max\\{0, g(\\varepsilon)\\}]$. Both require finding the roots of the quadratic equation $g(\\varepsilon) = 0$. The roots are given by $\\varepsilon_{1,2} = \\frac{-b \\pm \\sqrt{\\Delta}}{c}$, where the discriminant is $\\Delta = b^2 - 2ac$. Let $p(\\varepsilon)$ be the PDF of $\\mathcal{N}(0, \\sigma^2)$. Let $\\varphi(z)$ and $\\Phi(z)$ be the standard normal PDF and CDF, respectively.\n\nWe analyze based on the sign of $c$ and $\\Delta$:\n- Since $c = \\frac{\\beta\\alpha\\bar{k}^{\\alpha}}{\\phi} \\rho^2 \\exp(\\frac{1}{2}\\sigma^2)$, and all structural parameters are positive and $\\rho \\ne 0$ in the test cases, $c$ is strictly positive. This implies the quadratic $g(\\varepsilon)$ is a parabola opening upwards.\n\n- If $\\Delta  0$, the parabola's minimum, $-\\Delta/(2c)$, is positive. Thus, $g(\\varepsilon)  0$ for all $\\varepsilon$.\n  - Binding probability: $\\mathbb{P}(g(\\varepsilon) \\le 0) = 0$.\n  - Constrained mean: $\\mathbb{E}[\\max\\{0, g(\\varepsilon)\\}] = \\mathbb{E}[g(\\varepsilon)] = a + \\frac{1}{2}c\\sigma^2$.\n\n- If $\\Delta \\ge 0$, there are two real roots, $\\varepsilon_1 \\le \\varepsilon_2$. The parabola is non-positive, $g(\\varepsilon) \\le 0$, for $\\varepsilon \\in [\\varepsilon_1, \\varepsilon_2]$, where $\\varepsilon_1 = \\frac{-b - \\sqrt{\\Delta}}{c}$ and $\\varepsilon_2 = \\frac{-b + \\sqrt{\\Delta}}{c}$.\n  - **Binding Probability**: We standardize the roots to $z_1 = \\varepsilon_1/\\sigma$ and $z_2 = \\varepsilon_2/\\sigma$.\n    $$\n    \\mathbb{P}(g(\\varepsilon) \\le 0) = \\mathbb{P}(\\varepsilon_1 \\le \\varepsilon \\le \\varepsilon_2) = \\Phi(z_2) - \\Phi(z_1)\n    $$\n  - **Constrained Mean**: The expectation is the integral of $g(\\varepsilon)$ over the region where it is positive: $(-\\infty, \\varepsilon_1) \\cup (\\varepsilon_2, \\infty)$.\n    $$\n    \\mathbb{E}[\\max\\{0, g(\\varepsilon)\\}] = \\int_{-\\infty}^{\\varepsilon_1} g(\\varepsilon)p(\\varepsilon)d\\varepsilon + \\int_{\\varepsilon_2}^{\\infty} g(\\varepsilon)p(\\varepsilon)d\\varepsilon\n    $$\n    This is equivalent to the total expectation minus the integral over the negative region:\n    $$\n    \\mathbb{E}[\\max\\{0, g(\\varepsilon)\\}] = \\mathbb{E}[g(\\varepsilon)] - \\int_{\\varepsilon_1}^{\\varepsilon_2} g(\\varepsilon)p(\\varepsilon)d\\varepsilon\n    $$\n    The required definite integral can be expressed as:\n    $$\n    \\int_{\\varepsilon_1}^{\\varepsilon_2} g(\\varepsilon)p(\\varepsilon)d\\varepsilon = \\left[ \\left(a+\\frac{c\\sigma^2}{2}\\right)\\Phi(z) - \\left(b\\sigma + \\frac{c\\sigma^2 z}{2}\\right) \\varphi(z) \\right]_{z_1}^{z_2}\n    $$\n    Let this integral be $I_{neg}$. Then the constrained mean is $\\mathbb{E}[\\max\\{0, g(\\varepsilon)\\}] = (a + \\frac{1}{2}c\\sigma^2) - I_{neg}$.\n\nFor completeness, if $c  0$ (parabola opens downwards):\n- If $\\Delta  0$, $g(\\varepsilon)  0$ for all $\\varepsilon$. $\\mathbb{P}(g \\le 0)=1$, $\\mathbb{E}[\\max\\{0,g\\}]=0$.\n- If $\\Delta \\ge 0$, $g(\\varepsilon)  0$ for $\\varepsilon \\in (\\varepsilon_1, \\varepsilon_2)$.\n  - $\\mathbb{P}(g \\le 0) = 1 - (\\Phi(z_2) - \\Phi(z_1))$.\n  - $\\mathbb{E}[\\max\\{0, g(\\varepsilon)\\}]$ is the integral over $[\\varepsilon_1, \\varepsilon_2]$, given by $I_{neg}$ above.\n\nIf c=0, $g(\\varepsilon) = b\\varepsilon + a$.\n- If $b0$, $g \\le 0$ for $\\varepsilon \\le -a/b$. $\\mathbb{P}(g \\le 0) = \\Phi(-a/(b\\sigma))$.\n- If $b0$, $g \\le 0$ for $\\varepsilon \\ge -a/b$. $\\mathbb{P}(g \\le 0) = 1 - \\Phi(-a/(b\\sigma))$.\n- The constrained mean can be computed by integrating the line over the region where it is positive.\n\nThe implementation will follow this logic, specialized for $c0$ as dictated by the problem parameters.",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Solves the quantitative economics problem for a suite of test cases.\n    \"\"\"\n\n    test_cases = [\n        # (alpha, beta, delta, phi, k_bar, rho, sigma)\n        (0.33, 0.96, 0.08, 4.0, 1.0, 0.9, 0.10),\n        (0.33, 0.96, 0.08, 1.0, 1.0, 0.95, 0.25),\n        (0.20, 0.90, 0.05, 0.50, 1.0, 0.90, 0.30),\n        (0.20, 0.90, 0.164, 0.95, 1.0, 0.90, 0.20),\n    ]\n\n    results = []\n    for params in test_cases:\n        result_tuple = calculate_metrics(params)\n        results.extend(result_tuple)\n\n    # Print the final results in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef calculate_metrics(params):\n    \"\"\"\n    Computes the three required metrics for a single parameter set.\n    1. Unconstrained mean E[g(eps)]\n    2. Constrained mean E[max{0, g(eps)}]\n    3. Binding probability P(g(eps) = 0)\n    \"\"\"\n    alpha, beta, delta, phi, k_bar, rho, sigma = params\n\n    # Part 1: Compute coefficients a, b, c\n    sigma2 = sigma**2\n    exp_term = np.exp(0.5 * sigma2)\n    \n    # Common factor for b and c\n    K = (beta * alpha * k_bar**alpha / phi) * exp_term\n    \n    a = (k_bar / phi) * (beta * (1 - delta) - 1 + phi * delta) + K\n    b = K * rho\n    c = K * rho**2\n\n    # Part 2: Compute statistical properties\n    # Unconstrained mean E[g(eps)]\n    unconstrained_mean = a + 0.5 * c * sigma2\n\n    # Since all parameters are positive and rho is non-zero, c is always > 0.\n    # The quadratic g(eps) is a parabola opening upwards.\n\n    # Discriminant Delta = b^2 - 2ac\n    delta_discriminant = b**2 - 2 * a * c\n\n    if delta_discriminant  0:\n        # g(eps) is always positive\n        binding_prob = 0.0\n        constrained_mean = unconstrained_mean\n    else:\n        # g(eps) has two real roots, so the constraint can bind.\n        sqrt_delta = np.sqrt(delta_discriminant)\n        \n        # Roots of g(eps) = 0\n        eps1 = (-b - sqrt_delta) / c\n        eps2 = (-b + sqrt_delta) / c\n        \n        # Standardized roots\n        z1 = eps1 / sigma\n        z2 = eps2 / sigma\n        \n        # Binding probability P(g(eps) = 0) = P(eps1 = eps = eps2)\n        binding_prob = norm.cdf(z2) - norm.cdf(z1)\n        \n        # Constrained mean E[max{0, g(eps)}] = E[g(eps)] - integral of g(eps) over [eps1, eps2]\n        \n        # Integral of g(eps)p(eps) from eps1 to eps2\n        # Let F(z) = (a + c*sig^2/2)Phi(z) - (b*sig + c*sig^2*z/2)phi(z)\n        # Integral is F(z2) - F(z1)\n        term_phi = a + 0.5 * c * sigma2\n        \n        F_z2 = term_phi * norm.cdf(z2) - (b*sigma + 0.5*c*sigma2*z2) * norm.pdf(z2)\n        F_z1 = term_phi * norm.cdf(z1) - (b*sigma + 0.5*c*sigma2*z1) * norm.pdf(z1)\n        \n        integral_neg_region = F_z2 - F_z1\n        \n        constrained_mean = unconstrained_mean - integral_neg_region\n        \n    return unconstrained_mean, constrained_mean, binding_prob\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}