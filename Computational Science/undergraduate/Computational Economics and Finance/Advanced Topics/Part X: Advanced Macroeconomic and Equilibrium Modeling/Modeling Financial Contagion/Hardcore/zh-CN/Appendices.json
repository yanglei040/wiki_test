{
    "hands_on_practices": [
        {
            "introduction": "最直观的金融传染模型之一是线性动态系统，它描述了初始冲击如何在网络中随时间逐步传播。该模型的核心思想是，银行受到的冲击会按其网络连接，以一定比例传递给其交易对手方，这个过程可以通过迭代方程 $s_{t+1} = A^{\\top} s_t$ 来模拟。通过这个练习 ，你将亲手实现这一基本的级联机制，并计算系统性风险的关键指标，同时体会到在处理大型网络时使用稀疏矩阵的计算优势。",
            "id": "2432984",
            "problem": "考虑一个由 $n$ 家银行组成的银行间借贷网络，该网络由一个有向加权邻接矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 表示，其中 $A_{ij}$ 是银行 $i$ 的一次冲击在一个迭代中传递给银行 $j$ 的比例。根据构造，对于每一行 $i$，$\\sum_{j=1}^{n} A_{ij} \\leq 1$。令 $s_t \\in \\mathbb{R}^n$ 表示离散时间 $t \\in \\mathbb{N}_0$ 时的非负冲击强度向量。冲击传播由以下线性递推关系定义：\n$$\ns_{t+1} = A^{\\top} s_t,\n$$\n并给定初始条件 $s_0 \\in \\mathbb{R}^n_{\\ge 0}$。对于给定的非负阈值 $\\theta \\in \\mathbb{R}_{\\ge 0}$，将时间 $T$ 时的困境银行数量定义为满足 $s_{T,i} \\ge \\theta$ 的索引 $i \\in \\{1,\\dots,n\\}$ 的数量。将时间 $T$ 时的总冲击质量定义为 1-范数 $\\lVert s_T \\rVert_1 = \\sum_{i=1}^n |s_{T,i}|$。\n\n您的任务是为下面指定的每个测试用例计算一个包含以下两个元素的数对：\n- 总冲击质量 $\\lVert s_T \\rVert_1$，使用标准四舍五入保留 $6$ 位小数，以及\n- 在 $s_{T,i} \\ge \\theta$ 准则下，时间 $T$ 时的困境银行整数数量。\n\n所有量均无单位。不涉及角度或百分比。\n\n测试套件：\n- 测试用例 1：\n  - $n = 6$。\n  - $A$ 的非零项由三元组 $(i,j,w)$ 列表给出，表示 $A_{ij} = w$：\n    $$(0,1,0.5),\\ (0,2,0.3),\\ (1,2,0.4),\\ (1,3,0.4),\\ (2,3,0.6),\\ (3,4,0.5),\\ (4,5,0.3)。$$\n  - 初始冲击 $s_0 = [1,0,0,0,0,0]$。\n  - 时间范围 $T = 4$。\n  - 阈值 $\\theta = 0.15$。\n- 测试用例 2：\n  - $n = 4$。\n  - $A$ 的非零项：\n    $$(0,1,1.0),\\ (1,2,1.0),\\ (2,3,1.0)。$$\n  - 初始冲击 $s_0 = [0,0,1,0]$。\n  - 时间范围 $T = 0$。\n  - 阈值 $\\theta = 0.5$。\n- 测试用例 3：\n  - $n = 3$。\n  - $A$ 没有非零项。\n  - 初始冲击 $s_0 = [0,0.8,0]$。\n  - 时间范围 $T = 3$。\n  - 阈值 $\\theta = 0.1$。\n- 测试用例 4：\n  - $n = 5$。\n  - $A$ 的非零项：\n    $$(0,1,1.0),\\ (1,2,1.0),\\ (2,3,1.0),\\ (3,4,1.0),\\ (4,0,1.0)。$$\n  - 初始冲击 $s_0 = [1,0,0,0,0]$。\n  - 时间范围 $T = 5$。\n  - 阈值 $\\theta = 0.4$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个逗号分隔的列表，列表用方括号括起，每个测试用例的结果本身是一个双元素列表 $[\\lVert s_T \\rVert_1,\\ \\text{count}]$。例如，对于四个测试用例，一个有效的输出格式是\n$$\n[[x_1,c_1],[x_2,c_2],[x_3,c_3],[x_4,c_4]]\n$$\n其中每个 $x_k$ 是一个保留 $6$ 位小数的浮点数，每个 $c_k$ 是一个整数。",
            "solution": "问题陈述已经过验证，被认为是有效的。它具有科学依据、提法恰当、客观且完整。它描述了一个用于模拟网络传播现象（如金融传染）的标准离散时间线性动力系统。所有测试用例的参数都已提供且一致。\n\n该问题要求分析一个包含 $n$ 家银行的网络中的冲击传播模型。其动态由以下线性递推关系决定：\n$$ s_{t+1} = A^{\\top} s_t $$\n其中 $s_t \\in \\mathbb{R}^n$ 是时间 $t \\in \\mathbb{N}_0$ 时的冲击强度向量，而 $A \\in \\mathbb{R}^{n \\times n}$ 是网络的加权邻接矩阵。$A_{ij}$ 项表示从银行 $i$ 传递到银行 $j$ 的冲击比例。条件 $\\sum_{j=1}^{n} A_{ij} \\leq 1$ （对于每一行 $i$）确保任何银行传播的总冲击不超过其接收到的冲击，从而保证系统中的总冲击质量 $\\lVert s_t \\rVert_1$ 是非递增的。\n\n给定一个初始冲击向量 $s_0$，系统在任何未来时间 $T \\in \\mathbb{N}_0$ 的状态都可以通过递归应用传播规则来确定。时间 $T$ 的解由下式给出：\n$$ s_T = (A^{\\top})^T s_0 $$\n这可以通过算法计算，方法是：将向量 $s$ 初始化为 $s_0$，然后通过 $T$ 次矩阵-向量乘法进行迭代更新：$s \\leftarrow A^{\\top} s$。\n\n银行间网络由 $A$ 的非零项列表指定，这意味着对于任何实际规模的网络（$n$ 很大），矩阵 $A$ 都是稀疏的。为了高效处理，必须使用稀疏矩阵数据结构和算法。所提供的三元组 $(i,j,w)$ 自然地以坐标（COO）格式定义了矩阵。为了高效地进行重复的矩阵-向量乘法，最好将此矩阵转换为压缩稀疏行（CSR）或压缩稀疏列（CSC）等格式。对于稀疏矩阵，转置操作 $A^{\\top}$ 的计算成本很低。\n\n解决每个测试用例的算法如下：\n\n1. **矩阵构建**：从给定的三元组列表 $(i,j,w)$ 构建矩阵 $A$，其中 $A_{ij} = w$。我们使用稀疏矩阵表示，例如 `scipy.sparse` 库中的表示法。根据测试用例中给定的基于 $0$ 的索引，我们构建一个 $n \\times n$ 的稀疏矩阵。\n\n2. **迭代冲击传播**：我们将冲击向量 $s$ 初始化为给定的 $s_0$。然后，我们模拟 $T$ 个时间步长的传播。对于从 $0$ 到 $T-1$ 的每一步 $t$，我们通过计算 $s_{t+1} = A^{\\top} s_t$ 来更新冲击向量。如果 $T=0$，最终的冲击向量就是 $s_0$。\n\n3. **指标计算**：经过 $T$ 次迭代后，我们得到最终的冲击向量 $s_T$。从此向量中，我们计算两个量：\n    - 总冲击质量，即 $s_T$ 的 $L_1$-范数，$\\lVert s_T \\rVert_1 = \\sum_{i=1}^{n} |s_{T,i}|$。由于初始冲击 $s_0$ 是非负的，且 $A$ 的所有项都是非负的，因此所有后续的冲击向量 $s_t$ 也将是非负的。因此，范数就是向量各分量之和，$\\sum_{i=1}^{n} s_{T,i}$。然后将此值四舍五入到 $6$ 位小数。\n    - 困境银行的数量，即冲击强度 $s_{T,i}$ 达到或超过给定阈值 $\\theta$ 的索引 $i$ 的数量，即 $|\\{i \\in \\{1,\\dots,n\\} \\mid s_{T,i} \\ge \\theta\\}|$。\n\n4. **输出格式化**：对于每个测试用例，将计算出的数值对——四舍五入后的总冲击质量和困境银行的整数数量——格式化为一个列表，并将所有测试用例的结果聚合成一个列表的列表，以符合要求。",
            "answer": "```python\nimport numpy as np\nfrom scipy.sparse import coo_matrix\n\ndef solve():\n    \"\"\"\n    Solves the shock propagation problem for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"n\": 6,\n            \"A_triples\": [(0, 1, 0.5), (0, 2, 0.3), (1, 2, 0.4), (1, 3, 0.4), (2, 3, 0.6), (3, 4, 0.5), (4, 5, 0.3)],\n            \"s0\": [1, 0, 0, 0, 0, 0],\n            \"T\": 4,\n            \"theta\": 0.15,\n        },\n        {\n            \"n\": 4,\n            \"A_triples\": [(0, 1, 1.0), (1, 2, 1.0), (2, 3, 1.0)],\n            \"s0\": [0, 0, 1, 0],\n            \"T\": 0,\n            \"theta\": 0.5,\n        },\n        {\n            \"n\": 3,\n            \"A_triples\": [],\n            \"s0\": [0, 0.8, 0],\n            \"T\": 3,\n            \"theta\": 0.1,\n        },\n        {\n            \"n\": 5,\n            \"A_triples\": [(0, 1, 1.0), (1, 2, 1.0), (2, 3, 1.0), (3, 4, 1.0), (4, 0, 1.0)],\n            \"s0\": [1, 0, 0, 0, 0],\n            \"T\": 5,\n            \"theta\": 0.4,\n        }\n    ]\n\n    results_str_list = []\n    for case in test_cases:\n        n = case[\"n\"]\n        A_triples = case[\"A_triples\"]\n        s0 = case[\"s0\"]\n        T = case[\"T\"]\n        theta = case[\"theta\"]\n\n        # 1. Construct the sparse matrix A and its transpose A_T.\n        if not A_triples:\n            # If there are no non-zero entries, A is the zero matrix.\n            A = coo_matrix((n, n), dtype=float)\n        else:\n            rows, cols, data = zip(*A_triples)\n            A = coo_matrix((data, (rows, cols)), shape=(n, n), dtype=float)\n        \n        # Using CSC format for A.T is efficient for matrix-vector products.\n        A_T = A.T.tocsc()\n\n        # 2. Iteratively compute the shock propagation.\n        s = np.array(s0, dtype=float)\n        for _ in range(T):\n            s = A_T @ s\n        \n        s_T = s\n\n        # 3. Calculate total shock mass and the number of distressed banks.\n        # Since s0 >= 0 and A >= 0, s_T will be non-negative.\n        total_mass = np.sum(s_T)\n        distressed_count = np.sum(s_T >= theta)\n        \n        # 4. Format the result for the current test case.\n        # \"standard rounding\" is taken to be Python's built-in round.\n        rounded_mass = round(total_mass, 6)\n        \n        # Format the float to a string with 6 decimal places.\n        mass_str = f'{rounded_mass:.6f}'\n        \n        result_str = f'[{mass_str},{distressed_count}]'\n        results_str_list.append(result_str)\n\n    # 5. Print the final results in the required format.\n    print(f\"[{','.join(results_str_list)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "与模拟冲击随时间演化的动态模型不同，金融网络分析的另一个基石是静态均衡模型，其中最具代表性的是 Eisenberg-Noe 模型。该方法不再追踪一轮轮的违约，而是旨在找到一个单一的、在系统内所有银行间同时成立的“清算支付向量”$p$，它满足定点方程 $p = \\min(\\bar{p}, x' + \\Pi^{\\top} p)$，精准地刻画了有限责任下的债务清偿过程。这项练习  将让你实现这一经典模型，并用它来量化和比较个体银行冲击与宏观系统性压力对整个金融网络稳定性的不同影响。",
            "id": "2410802",
            "problem": "给定一个由 $n$ 家银行组成的封闭金融网络，其中包含名义银行间负债和外部资产。设名义负债矩阵为 $L \\in \\mathbb{R}_{\\ge 0}^{n \\times n}$，其中 $L_{ij}$ 是银行 $i$ 欠银行 $j$ 的金额。定义银行 $i$ 的名义银行间总负债为 $\\bar{p}_i = \\sum_{j=1}^n L_{ij}$，并定义向量 $\\bar{p} \\in \\mathbb{R}_{\\ge 0}^{n}$，其条目为 $\\bar{p}_i$。设相对负债矩阵 $\\Pi \\in \\mathbb{R}_{\\ge 0}^{n \\times n}$ 由 $\\Pi_{ij} = \\frac{L_{ij}}{\\bar{p}_i}$（如果 $\\bar{p}_i > 0$）和 $\\Pi_{ij} = 0$（如果 $\\bar{p}_i = 0$）给出。设 $x \\in \\mathbb{R}_{\\ge 0}^{n}$ 为外部（非银行间）资产向量。\n\n考虑应用于外部资产的两种冲击情景：\n- 对单一银行 $k \\in \\{1,\\dots,n\\}$ 的特定冲击，幅度为 $s_{\\mathrm{id}} \\in [0,1]$（以小数形式表示，非百分比）：冲击后的外部资产为 $x^{\\mathrm{id}}$，其中 $x^{\\mathrm{id}}_k = (1 - s_{\\mathrm{id}})\\, x_k$，对于所有 $i \\ne k$，则 $x^{\\mathrm{id}}_i = x_i$。\n- 幅度为 $s_{\\mathrm{com}} \\in [0,1]$ 的共同（相关）压力（以小数形式表示，非百分比）：冲击后的外部资产为 $x^{\\mathrm{com}}$，其中对所有 $i$，有 $x^{\\mathrm{com}}_i = (1 - s_{\\mathrm{com}})\\, x_i$。\n\n假设在 Eisenberg–Noe (EN) 清算机制的意义下，遵循有限责任下的按比例偿付原则。对于给定的冲击后外部资产向量 $x' \\in \\{x^{\\mathrm{id}}, x^{\\mathrm{com}}\\}$，一个清算支付向量 $p \\in \\mathbb{R}_{\\ge 0}^{n}$ 必须满足\n$$\np = \\min\\!\\big(\\,\\bar{p},\\; x' + \\Pi^{\\top} p\\,\\big),\n$$\n其中最小值为逐元素取值。如果银行 $i$ 的支付 $p_i  \\bar{p}_i$，则称该银行违约。设违约银行数量为 $D(x') = \\sum_{i=1}^n \\mathbf{1}\\{p_i  \\bar{p}_i\\}$，未偿付负债总额为 $U(x') = \\sum_{i=1}^n (\\bar{p}_i - p_i)$。\n\n您的任务是为下面的每个测试用例计算两种情景下的指标对：违约数量和未偿付负债总额。对于每个测试用例，返回列表 $[D(x^{\\mathrm{id}}), D(x^{\\mathrm{com}}), U(x^{\\mathrm{id}}), U(x^{\\mathrm{com}})]$，其中未偿付负债 $U(\\cdot)$ 必须四舍五入到六位小数。\n\n所有货币金额均采用一致的任意单位（无需单位转换）。冲击幅度必须视为 $[0,1]$ 区间内的小数。\n\n测试套件（每个测试用例指定 $n$, $L$, $x$, $k$, $s_{\\mathrm{id}}$, $s_{\\mathrm{com}}$）：\n\n- 测试用例 1：\n$$\nn = 4,\\quad\nL = \\begin{bmatrix}\n0  2  1  2 \\\\\n1  0  1  2 \\\\\n1  1  0  1 \\\\\n0  1  2  0\n\\end{bmatrix},\\quad\nx = \\begin{bmatrix}\n6.0\\\\ 4.5\\\\ 3.5\\\\ 3.0\n\\end{bmatrix},\\quad\nk = 1,\\quad\ns_{\\mathrm{id}} = 0.6,\\quad\ns_{\\mathrm{com}} = 0.3.\n$$\n\n- 测试用例 2（基准线，无冲击）：\n$$\nn = 4,\\quad\nL = \\begin{bmatrix}\n0  2  1  2 \\\\\n1  0  1  2 \\\\\n1  1  0  1 \\\\\n0  1  2  0\n\\end{bmatrix},\\quad\nx = \\begin{bmatrix}\n6.0\\\\ 4.5\\\\ 3.5\\\\ 3.0\n\\end{bmatrix},\\quad\nk = 3,\\quad\ns_{\\mathrm{id}} = 0.0,\\quad\ns_{\\mathrm{com}} = 0.0.\n$$\n\n- 测试用例 3（严重压力比较）：\n$$\nn = 4,\\quad\nL = \\begin{bmatrix}\n0  2  1  2 \\\\\n1  0  1  2 \\\\\n1  1  0  1 \\\\\n0  1  2  0\n\\end{bmatrix},\\quad\nx = \\begin{bmatrix}\n6.0\\\\ 4.5\\\\ 3.5\\\\ 3.0\n\\end{bmatrix},\\quad\nk = 2,\\quad\ns_{\\mathrm{id}} = 0.9,\\quad\ns_{\\mathrm{com}} = 0.75.\n$$\n\n最终输出格式：您的程序应生成单行输出，其中包含所有测试用例的结果，形式为一个以方括号括起来的逗号分隔列表，其中每个元素是单个测试用例的列表。例如，一个有效的结构是\n$[[D_1^{\\mathrm{id}}, D_1^{\\mathrm{com}}, U_1^{\\mathrm{id}}, U_1^{\\mathrm{com}}],[D_2^{\\mathrm{id}}, D_2^{\\mathrm{com}}, U_2^{\\mathrm{id}}, U_2^{\\mathrm{com}}],\\dots]$。",
            "solution": "该问题已经过验证。\n\n**第 1 步：提取已知信息**\n\n-   银行数量：$n$。\n-   名义负债矩阵：$L \\in \\mathbb{R}_{\\ge 0}^{n \\times n}$，其中 $L_{ij}$ 是银行 $i$ 欠银行 $j$ 的金额。\n-   银行 $i$ 的名义银行间总负债：$\\bar{p}_i = \\sum_{j=1}^n L_{ij}$。向量形式为：$\\bar{p} \\in \\mathbb{R}_{\\ge 0}^{n}$。\n-   相对负债矩阵：$\\Pi \\in \\mathbb{R}_{\\ge 0}^{n \\times n}$，其中 $\\Pi_{ij} = \\frac{L_{ij}}{\\bar{p}_i}$（如果 $\\bar{p}_i > 0$），以及 $\\Pi_{ij} = 0$（如果 $\\bar{p}_i = 0$）。\n-   外部资产向量：$x \\in \\mathbb{R}_{\\ge 0}^{n}$。\n-   特定冲击：影响单一银行 $k \\in \\{1,\\dots,n\\}$，幅度为 $s_{\\mathrm{id}} \\in [0,1]$。冲击后的资产为 $x^{\\mathrm{id}}$，其中 $x^{\\mathrm{id}}_k = (1 - s_{\\mathrm{id}})\\, x_k$，对于 $i \\ne k$，则 $x^{\\mathrm{id}}_i = x_i$。\n-   共同冲击：影响所有银行，幅度为 $s_{\\mathrm{com}} \\in [0,1]$。冲击后的资产为 $x^{\\mathrm{com}}$，其中对所有 $i$，有 $x^{\\mathrm{com}}_i = (1 - s_{\\mathrm{com}})\\, x_i$。\n-   清算支付向量：$p \\in \\mathbb{R}_{\\ge 0}^{n}$ 是不动点方程 $p = \\min\\!\\big(\\,\\bar{p},\\; x' + \\Pi^{\\top} p\\,\\big)$ 的解，其中 $x'$ 是冲击后的资产向量。\n-   违约条件：如果银行 $i$ 的实际支付 $p_i$ 小于其名义负债 $\\bar{p}_i$，则该银行违约。\n-   待计算指标：\n    1.  违约银行数量：$D(x') = \\sum_{i=1}^n \\mathbf{1}\\{p_i  \\bar{p}_i\\}$。\n    2.  未偿付负债总额：$U(x') = \\sum_{i=1}^n (\\bar{p}_i - p_i)$。$U(\\cdot)$ 必须四舍五入到六位小数。\n-   任务：对于每个由（$n$、$L$、$x$、$k$、$s_{\\mathrm{id}}$、$s_{\\mathrm{com}}$）定义的测试用例，计算四元素列表 $[D(x^{\\mathrm{id}}), D(x^{\\mathrm{com}}), U(x^{\\mathrm{id}}), U(x^{\\mathrm{com}})]$。\n\n**第 2 步：使用提取的已知信息进行验证**\n\n-   **科学依据**：问题陈述描述了一个金融传染的典型模型，特别是 Eisenberg–Noe (2001) 清算系统。这是一个计算金融学和经济学中用于分析银行间网络系统性风险的基础且科学严谨的模型。前提条件真实可靠，并基于已确立的经济学理论。\n-   **良定性**：问题的核心是找到清算向量 $p$ 作为方程 $p = f(p) = \\min\\!\\big(\\,\\bar{p},\\; x' + \\Pi^{\\top} p\\,\\big)$ 的一个不动点。函数 $f$ 是在完备格 $[0, \\bar{p}] = \\{ p \\in \\mathbb{R}^n \\mid 0 \\le p_i \\le \\bar{p}_i \\text{ for all } i \\}$ 上的单调函数。根据 Tarski 不动点定理，不动点存在。Eisenberg 和 Noe 证明了最大不动点是具有经济意义的清算向量。这可以通过从 $p^{(0)} = \\bar{p}$ 开始的迭代过程 $p^{(m+1)} = f(p^{(m)})$ 来找到。该序列是非增且有下界的，因此保证收敛。问题是良定的。\n-   **客观性**：问题是用精确的数学定义和客观的语言表述的。没有主观或模糊的术语。\n-   **完整性**：为每个测试用例提供了所有必要的数据和参数（$L$, $x$, $k$, $s_{\\mathrm{id}}$, $s_{\\mathrm{com}}$）。模型和指标都已完全指定。\n\n**第 3 步：结论与行动**\n\n该问题具有科学依据、良定性、客观性和完整性。因此被判定为**有效**。将提供一个解决方案。\n\n**求解方法**\n\n该问题要求在两种冲击情景下，计算金融网络的违约统计数据。解决方案遵循 Eisenberg–Noe 模型。对于每个测试用例和每种冲击情景，执行以下步骤：\n\n1.  **系统设定**：根据给定的名义负债矩阵 $L$，我们首先计算总名义负债向量 $\\bar{p}$。每个元素 $\\bar{p}_i$ 是 $L$ 的第 $i$ 行之和：\n    $$\n    \\bar{p}_i = \\sum_{j=1}^{n} L_{ij}\n    $$\n    接下来，我们计算相对负债矩阵 $\\Pi$，其中每个元素 $\\Pi_{ij}$ 代表银行 $i$ 的总债务中欠银行 $j$ 的比例：\n    $$\n    \\Pi_{ij} = \\begin{cases} L_{ij} / \\bar{p}_i  \\text{if } \\bar{p}_i > 0 \\\\ 0  \\text{if } \\bar{p}_i = 0 \\end{cases}\n    $$\n\n2.  **应用冲击**：我们为每种情景确定冲击后的外部资产向量 $x'$。\n    -   对于幅度为 $s_{\\mathrm{id}}$、作用于银行 $k$ 的特定冲击，资产向量 $x^{\\mathrm{id}}$ 为：\n        $$\n        x^{\\mathrm{id}}_i = \\begin{cases} (1 - s_{\\mathrm{id}}) x_k  \\text{if } i = k \\\\ x_i  \\text{if } i \\ne k \\end{cases}\n        $$\n    -   对于幅度为 $s_{\\mathrm{com}}$ 的共同冲击，资产向量 $x^{\\mathrm{com}}$ 为：\n        $$\n        x^{\\mathrm{com}} = (1 - s_{\\mathrm{com}}) x\n        $$\n\n3.  **清算向量计算**：中心任务是找到清算支付向量 $p$，它是以下迭代映射的最大不动点：\n    $$\n    p = \\min\\!\\big(\\,\\bar{p},\\; x' + \\Pi^{\\top} p\\,\\big)\n    $$\n    这个不动点通过迭代找到。我们以最乐观的假设初始化支付向量，$p^{(0)} = \\bar{p}$（所有银行都打算全额偿还债务）。然后我们迭代以下更新规则直到收敛，即直到 $p^{(m+1)} = p^{(m)}$：\n    $$\n    p^{(m+1)} = \\min\\!\\big(\\,\\bar{p},\\; x' + \\Pi^{\\top} p^{(m)}\\,\\big)\n    $$\n    项 $\\Pi^{\\top}p^{(m)}$ 表示每家银行收到的银行间资产向量，假设其他银行根据 $p^{(m)}$ 进行支付。银行 $i$ 的总可用资金是其冲击后外部资产 $x'_i$ 加上其银行间应收账款。支付 $p_i$ 的上限是其总名义债务 $\\bar{p}_i$。向量序列 $\\{p^{(m)}\\}_{m=0}^\\infty$ 是非增的，并且有下界零向量，保证收敛到最大不动点。\n\n4.  **指标计算**：一旦获得收敛的清算向量 $p$，我们计算所需的指标：\n    -   **违约数量 ($D$)**：如果银行 $i$ 的支付 $p_i$ 严格小于其债务 $\\bar{p}_i$，则该银行违约。我们计算这类银行的数量。\n        $$\n        D(x') = \\sum_{i=1}^{n} \\mathbf{1}\\{p_i  \\bar{p}_i\\}\n        $$\n        在实现中，使用一个小的数值容差来稳健地处理浮点数比较。\n    -   **未偿付负债总额 ($U$)**：这是整个系统的总短缺，计算为所有银行的名义负债与实际支付之间的差额之和。\n        $$\n        U(x') = \\sum_{i=1}^{n} (\\bar{p}_i - p_i)\n        $$\n    然后按要求将 $U(x')$ 的值四舍五入到六位小数。\n\n对每个测试用例的特定冲击和共同冲击情景均应用此过程，以生成最终的四元素结果向量。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that processes all test cases and prints the final result.\n    \"\"\"\n    \n    test_cases = [\n        # Test case 1\n        (4,\n         np.array([[0, 2, 1, 2], [1, 0, 1, 2], [1, 1, 0, 1], [0, 1, 2, 0]], dtype=float),\n         np.array([6.0, 4.5, 3.5, 3.0], dtype=float),\n         1, 0.6, 0.3),\n        # Test case 2 (baseline, no shock)\n        (4,\n         np.array([[0, 2, 1, 2], [1, 0, 1, 2], [1, 1, 0, 1], [0, 1, 2, 0]], dtype=float),\n         np.array([6.0, 4.5, 3.5, 3.0], dtype=float),\n         3, 0.0, 0.0),\n        # Test case 3 (severe stress comparison)\n        (4,\n         np.array([[0, 2, 1, 2], [1, 0, 1, 2], [1, 1, 0, 1], [0, 1, 2, 0]], dtype=float),\n         np.array([6.0, 4.5, 3.5, 3.0], dtype=float),\n         2, 0.9, 0.75),\n    ]\n\n    results = []\n    for case in test_cases:\n        n, L, x, k, s_id, s_com = case\n        result = compute_for_case(n, L, x, k, s_id, s_com)\n        results.append(result)\n\n    # Format the final output as a string representation of a list of lists.\n    # e.g., [[val1, val2], [val3, val4]]\n    # Using map(str, ...) handles the inner lists correctly.\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef compute_for_case(n, L, x, k, s_id, s_com):\n    \"\"\"\n    Computes the required metrics for a single test case.\n    \"\"\"\n    # Step 1: System Specification\n    p_bar = L.sum(axis=1)\n    \n    # Calculate relative liabilities matrix Pi, handling division by zero for banks with no liabilities.\n    Pi = np.divide(L, p_bar[:, np.newaxis], out=np.zeros_like(L, dtype=float), where=(p_bar[:, np.newaxis] != 0))\n    Pi_T = Pi.T\n\n    # --- Idiosyncratic Shock Scenario ---\n    # Step 2: Apply idiosyncratic shock\n    x_id = x.copy()\n    if k is not None:\n        # Note: problem uses 1-based indexing for k, Python uses 0-based.\n        x_id[k - 1] *= (1 - s_id)\n    \n    # Steps 3  4: Compute clearing vector and metrics\n    D_id, U_id = find_clearing_vector_and_metrics(p_bar, Pi_T, x_id)\n\n    # --- Common Shock Scenario ---\n    # Step 2: Apply common shock\n    x_com = x * (1 - s_com)\n    \n    # Steps 3  4: Compute clearing vector and metrics\n    D_com, U_com = find_clearing_vector_and_metrics(p_bar, Pi_T, x_com)\n\n    return [D_id, D_com, round(U_id, 6), round(U_com, 6)]\n\n\ndef find_clearing_vector_and_metrics(p_bar, Pi_T, x_shocked, max_iter=100, tol=1e-12):\n    \"\"\"\n    Computes the Eisenberg-Noe clearing vector and derived metrics.\n    \n    Args:\n        p_bar (np.ndarray): Vector of total nominal liabilities.\n        Pi_T (np.ndarray): Transposed relative liabilities matrix.\n        x_shocked (np.ndarray): Post-shock external asset vector.\n        max_iter (int): Maximum number of iterations for the fixed-point solver.\n        tol (float): Tolerance for default detection and convergence.\n        \n    Returns:\n        tuple[int, float]: A tuple containing the number of defaults (D) and \n                           aggregate unpaid liabilities (U).\n    \"\"\"\n    # Step 3: Clearing Vector Computation (Iterative Fixed-Point Method)\n    p = p_bar.copy()  # Initialize with optimistic p(0) = p_bar\n\n    for _ in range(max_iter):\n        p_old = p\n        \n        # Calculate incoming interbank payments\n        interbank_assets = Pi_T @ p_old\n        \n        # Calculate total available assets and update payments\n        p = np.minimum(p_bar, x_shocked + interbank_assets)\n        \n        # Check for convergence\n        if np.allclose(p, p_old, atol=tol, rtol=0):\n            break\n\n    # Step 4: Metrics Calculation\n    # Number of defaults D: count banks where payment is less than liability\n    # Use a tolerance to avoid floating-point inaccuracies.\n    defaults = (p_bar - p) > tol\n    num_defaults = int(np.sum(defaults))\n    \n    # Aggregate unpaid liabilities U: sum of shortfalls across all banks\n    unpaid_liabilities = float(np.sum(p_bar - p))\n    \n    return num_defaults, unpaid_liabilities\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "为了更真实地模拟金融系统，我们可以从被动网络节点转向主动决策的“代理人”。代理人基模型 (Agent-Based Model, ABM) 正是为此而生，它允许我们为系统中的每个银行赋予战略行为能力。在这个练习  中，你将构建一个两阶段模型：首先，银行会根据风险收益计算来决定是否切断其风险敞口，从而主动改变网络结构；随后，在一个外生冲击下，违约将在这个被重塑的网络中进行传播。通过这个实践，你将掌握一种更前沿的建模范式，探索银行的战略决策是如何内生地影响整个系统的脆弱性。",
            "id": "2410787",
            "problem": "实现一个完整的、可运行的程序，该程序模拟一个基于代理的银行间风险敞口模型，其中包含基于风险回报计算的策略性联系切断以及随后的违约传染。金融系统由一组有限的银行组成，索引为 $i \\in \\{0,1,\\dots,N-1\\}$。设 $E \\in \\mathbb{R}_{\\ge 0}^{N \\times N}$ 表示有向风险敞口矩阵，其中 $E_{i,j}$ 是银行 $i$ 对交易对手 $j$ 的账面风险敞口（一项资产）；对所有 $i$，$E_{i,i} = 0$。每家银行 $i$ 拥有初始资本 $C_i \\in \\mathbb{R}$，集合在向量 $C \\in \\mathbb{R}^N$ 中。设 $L \\in [0,1]$ 为适用于所有风险敞口的通用违约损失率。设 $s \\in \\mathbb{R}_{\\ge 0}$ 表示维持任何风险敞口的单位预期回报，设 $k \\in \\mathbb{R}_{\\ge 0}$ 表示切断风险敞口的单位成本。设 $p \\in [0,1]^N$ 为外生违约概率向量，仅用于在策略性切断决策中形成预期。设 $\\tau \\in \\mathbb{R}_{\\ge 0}^N$ 为银行特定的切断容忍度向量，以与风险敞口相同的货币单位度量；较大的 $\\tau_i$ 使银行 $i$ 更不倾向于切断联系。设 $D_0 \\subseteq \\{0,1,\\dots,N-1\\}$ 为外生指定的初始违约银行集合。\n\n策略性切断阶段（传染前）：每家银行 $i$ 通过保留联系相对于切断联系的预期净成本来评估其每个对外联系 $E_{i,j} > 0$。保留联系的预期净成本是 $p_j \\cdot L \\cdot E_{i,j} - s \\cdot E_{i,j}$，切断成本是 $k \\cdot E_{i,j}$。银行 $i$ 当且仅当\n$$(p_j \\cdot L - s - k) \\cdot E_{i,j} > \\tau_i$$\n时，切断联系 $i \\to j$。\n如果银行 $i$ 切断联系 $i \\to j$，它会立即从其资本中支付切断成本 $k \\cdot E_{i,j}$，因此 $C_i \\leftarrow C_i - k \\cdot E_{i,j}$，且风险敞口被设置为零，$E_{i,j} \\leftarrow 0$。如果在传染开始前，任何银行的资本因切断成本而变得小于或等于零，则该银行被视为立即违约。\n\n传染阶段：设 $D$ 为当前违约的银行集合，初始化为 $D_0$ 以及在切断阶段后资本小于或等于零的任何银行。损失以离散的轮次传播。在每一轮中，每个有偿付能力的银行 $i \\notin D$ 都会遭受损失\n$$\\Delta_i = L \\cdot \\sum_{j \\in D_{\\mathrm{new}}} E_{i,j},$$\n其中 $D_{\\mathrm{new}}$ 是在上一轮中违约的银行集合（在第一轮中，$D_{\\mathrm{new}} = D$ 如初始化时）。对于所有 $i \\notin D$，通过 $C_i \\leftarrow C_i - \\Delta_i$ 将 $\\Delta_i$ 应用于 $C_i$ 后，任何更新后资本小于或等于零的银行都会违约，并被添加到下一轮的 $D_{\\mathrm{new}}$ 中。该过程重复进行，直到没有新的违约发生，即 $D_{\\mathrm{new}} = \\varnothing$。一家银行当且仅当其在一轮结束时资本小于或等于零时违约。\n\n您的程序必须精确实现上述规则，并为每个测试用例生成一个整数，该整数等于传染过程结束时违约银行的总数。\n\n银行索引使用从零开始的索引。\n\n在程序内部实现的测试套件（每个用例都是独立的；参数可能在不同用例之间有所不同）：\n\n- 测试用例 1（理想路径，预防性切断阻止了传染）：\n  - $N = 4$，\n  - $$E = \\begin{bmatrix}\n  0  0  0  50 \\\\\n  0  0  20  0 \\\\\n  10  0  0  30 \\\\\n  0  0  0  0\n  \\end{bmatrix},$$\n  - $C = [20,\\,12,\\,15,\\,5]$,\n  - $L = 0.6$,\n  - $s = 0.02$,\n  - $k = 0.005$,\n  - $p = [0.01,\\,0.01,\\,0.01,\\,0.5]$,\n  - $\\tau = [0,\\,0,\\,0,\\,0]$,\n  - $D_0 = \\{3\\}$。\n  - 此用例的所需输出：一个整数。\n\n- 测试用例 2（边界情况，不容忍切断，导致连锁反应）：\n  - $N = 4$,\n  - $$E = \\begin{bmatrix}\n  0  0  0  50 \\\\\n  0  0  20  0 \\\\\n  10  0  0  30 \\\\\n  0  0  0  0\n  \\end{bmatrix},$$\n  - $C = [20,\\,12,\\,15,\\,5]$,\n  - $L = 0.6$,\n  - $s = 0.02$,\n  - $k = 0.005$,\n  - $p = [0.01,\\,0.01,\\,0.01,\\,0.5]$,\n  - $\\tau = [100,\\,100,\\,100,\\,100]$,\n  - $D_0 = \\{3\\}$。\n  - 此用例的所需输出：一个整数。\n\n- 测试用例 3（边界情况，所有联系事前被切断且无初始违约）：\n  - $N = 4$,\n  - $$E = \\begin{bmatrix}\n  0  5  5  5 \\\\\n  5  0  5  5 \\\\\n  5  5  0  5 \\\\\n  5  5  5  0\n  \\end{bmatrix},$$\n  - $C = [10,\\,10,\\,10,\\,10]$,\n  - $L = 0.5$,\n  - $s = 0.0$,\n  - $k = 0.0$,\n  - $p = [0.4,\\,0.4,\\,0.4,\\,0.4]$,\n  - $\\tau = [0,\\,0,\\,0,\\,0]$,\n  - $D_0 = \\varnothing$。\n  - 此用例的所需输出：一个整数。\n\n- 测试用例 4（边界条件，一家银行在遭受损失后资本恰好为零）：\n  - $N = 2$,\n  - $$E = \\begin{bmatrix}\n  0  0 \\\\\n  20  0\n  \\end{bmatrix},$$\n  - $C = [5,\\,10]$,\n  - $L = 0.5$,\n  - $s = 0.01$,\n  - $k = 0.0$,\n  - $p = [0.1,\\,0.1]$,\n  - $\\tau = [100,\\,100]$,\n  - $D_0 = \\{0\\}$。\n  - 此用例的所需输出：一个整数。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，按测试用例的顺序排列，例如 $[x_1,x_2,x_3,x_4]$，其中每个 $x_m$ 是测试用例 $m$ 的整数结果。",
            "solution": "所提出的问题是对银行间网络中金融传染的一个定义明确且具有科学依据的模拟。它以数学精度进行了规定，提供了一个清晰、确定性的算法，可以直接实现。该模型分为两个截然不同的阶段：基于风险回报分析的策略性联系切断阶段，以及随后的违约传染阶段。该问题是有效的，对于任何给定的参数集都存在唯一解。\n\n解决方案通过按规定顺序实现这两个阶段来推进。\n\n**阶段 1：策略性联系切断**\n\n这个初始阶段模拟了银行寻求减轻风险的理性行为。对于每家银行 $i$，我们评估其对交易对手银行 $j$ 的每一个对外风险敞口 $E_{i,j} > 0$。切断联系的决定由以下不等式控制：\n$$ (p_j \\cdot L - s - k) \\cdot E_{i,j} > \\tau_i $$\n这里，$p_j$ 是交易对手 $j$ 的感知违约概率，$L$ 是违约损失率，$s$ 是持有风险敞口的单位回报，$k$ 是切断风险敞口的单位成本，而 $\\tau_i$ 是银行 $i$ 对采取这种破坏性行动的特定容忍阈值。项 $(p_j \\cdot L)$ 代表风险敞口的单位预期损失，而 $s$ 是预期的单位收益。项 $-k$ 可以解释为避免切断行动的好处。因此，$(p_j \\cdot L - s - k)$ 是每单位风险敞口的净成本效益因子。如果这个因子乘以风险敞口的大小 $E_{i,j}$ 超过了银行的容忍度 $\\tau_i$，银行就选择切断该联系。\n\n整个网络中所有联系 $(i, j)$ 的决策被认为是在系统初始状态的基础上同时做出的。我们首先确定将要被切断的完整联系集合。随后，网络的状态被更新。对于每个被切断的联系 $(i, j)$：\n1. 风险敞口被消除：$E_{i,j}$ 变为 $0$。\n2. 银行 $i$ 的资本因切断成本而减少：$C_i \\leftarrow C_i - k \\cdot E_{i,j}$。\n\n在所有切断成本被应用后，任何资本 $C_i$ 现在小于或等于 $0$ 的银行 $i$ 都被认为已经违约。这些银行，连同外生指定的初始违约集合 $D_0$，构成了下一阶段的初始违约银行集合。我们将切断后的资本和风险敞口矩阵分别表示为 $C'$ 和 $E'$。\n\n**阶段 2：违约传染**\n\n此阶段模拟由初始违约集合引发的连锁失败。该过程以离散的轮次展开。设 $D$ 为所有违约银行的累积集合，用 $D_0$ 和在切断阶段失败的任何银行进行初始化。\n\n在第一轮中，新违约银行的集合 $D_{\\mathrm{new}}$ 是这个初始集合 $D$。对于随后的每一轮，$D_{\\mathrm{new}}$ 将是紧接在前一轮中违约的银行集合。只要 $D_{\\mathrm{new}}$ 不为空，传染过程就会继续。\n\n在每一轮中，每个有偿付能力的银行 $i \\notin D$ 计算其因对新违约银行的风险敞口而产生的损失。银行 $i$ 的损失是：\n$$ \\Delta_i = L \\cdot \\sum_{j \\in D_{\\mathrm{new}}} E'_{i,j} $$\n此损失从其当前资本中减去：$C'_i \\leftarrow C'_i - \\Delta_i$。在将这些损失应用于所有有偿付能力的银行后，我们检查新的违约。任何不在 $D$ 中的有偿付能力的银行 $i$，如果其更新后的资本 $C'_i$ 现在小于或等于 $0$，则被宣布违约。\n\n这些新失败的银行被添加到累积的违约集合 $D$ 中，并构成下一轮传染的集合 $D_{\\mathrm{new}}$。如果一轮结束时没有新的违约，那么 $D_{\\mathrm{new}}$ 变为空集 $\\varnothing$，模拟终止。\n\n最终结果是过程结束时累积违约集合 $D$ 中银行的总数。\n\n**算法摘要：**\n1. 初始化风险敞口矩阵 $E'$ 和资本向量 $C'$ 的工作副本。\n2. 遍历所有银行 $i \\in \\{0, \\dots, N-1\\}$ 和交易对手 $j \\in \\{0, \\dots, N-1\\}$。如果 $(p_j \\cdot L - s - k) \\cdot E_{i,j} > \\tau_i$，则更新 $C'_i \\leftarrow C'_i - k \\cdot E_{i,j}$ 并设置 $E'_{i,j} \\leftarrow 0$。这些风险敞口更新必须使用原始的 $E_{i,j}$ 值。\n3. 用 $D_0$ 的成员初始化违约银行集合 $D$。然后，将任何 $C'_i \\le 0$ 的银行 $i$ 添加到 $D$ 中。\n4. 为第一轮传染初始化新违约银行的集合，$D_{\\mathrm{new}} \\leftarrow D$。\n5. 开始一个循环，只要 $D_{\\mathrm{new}}$ 不为空就继续。\n    a. 为下一轮的新违约初始化一个空集，$D_{\\mathrm{next\\_round}}$。\n    b. 对于每个有偿付能力的银行 $i \\notin D$：\n        i. 计算损失 $\\Delta_i = L \\cdot \\sum_{j \\in D_{\\mathrm{new}}} E'_{i,j}$。\n        ii. 更新资本 $C'_i \\leftarrow C'_i - \\Delta_i$。\n    c. 更新所有有偿付能力银行的资本后，遍历所有银行 $i' \\in \\{0, \\dots, N-1\\}$。如果银行 $i'$ 尚未在 $D$ 中且其新资本 $C'_{i'} \\le 0$，则将 $i'$ 添加到 $D$ 和 $D_{\\mathrm{next\\_round}}$ 中。\n    d. 设置 $D_{\\mathrm{new}} \\leftarrow D_{\\mathrm{next\\_round}}$。\n6. 一旦循环终止，结果是最终集合 $D$ 的大小。\n这个过程是确定性的，并且保证会终止，因为集合 $D$ 是单调递增的，并且受银行总数 $N$ 的限制。",
            "answer": "```python\nimport numpy as np\n\ndef run_simulation(N, E, C, L, s, k, p, tau, D0):\n    \"\"\"\n    Runs one instance of the interbank contagion simulation.\n\n    Args:\n        N (int): Number of banks.\n        E (np.ndarray): Exposure matrix.\n        C (np.ndarray): Capital vector.\n        L (float): Loss-given-default fraction.\n        s (float): Per-unit exposure reward.\n        k (float): Per-unit severing cost.\n        p (np.ndarray): Exogenous default probabilities.\n        tau (np.ndarray): Severing tolerance vector.\n        D0 (set): Set of initially defaulted banks.\n\n    Returns:\n        int: Total number of defaulted banks at the end of the simulation.\n    \"\"\"\n    # Make copies to modify\n    E_prime = E.copy()\n    C_prime = C.copy()\n\n    # Stage 1: Strategic Link Severing\n    # Decisions are made based on the initial state of E.\n    severing_mask = np.zeros_like(E, dtype=bool)\n    for i in range(N):\n        for j in range(N):\n            if E[i, j] > 0:\n                severing_condition = (p[j] * L - s - k) * E[i, j] > tau[i]\n                if severing_condition:\n                    severing_mask[i, j] = True\n\n    # Apply severing costs and update exposure matrix\n    for i in range(N):\n        for j in range(N):\n            if severing_mask[i, j]:\n                C_prime[i] -= k * E[i, j]\n                E_prime[i, j] = 0\n\n    # Stage 2: Default Contagion\n    # Initialize the set of defaulted banks\n    defaulted_banks = set(D0)\n    for i in range(N):\n        if C_prime[i] = 0:\n            defaulted_banks.add(i)\n\n    # The first 'wave' of contagion is caused by all banks defaulted so far\n    newly_defaulted = defaulted_banks.copy()\n\n    while newly_defaulted:\n        # Calculate losses for solvent banks from newly defaulted banks\n        # Losses are only calculated if there are newly defaulted banks to consider\n        if not newly_defaulted:\n            break\n\n        losses = np.zeros(N, dtype=float)\n        # Sum exposures from solvent banks to newly defaulted banks\n        newly_defaulted_idx = list(newly_defaulted)\n        exposures_to_new_defaults = E_prime[:, newly_defaulted_idx]\n        \n        # Calculate total loss for each bank\n        # Ensure we're summing over an axis even if there's only one new default\n        if exposures_to_new_defaults.ndim == 1:\n            total_exposure_vector = exposures_to_new_defaults\n        else:\n            total_exposure_vector = np.sum(exposures_to_new_defaults, axis=1)\n\n        losses = L * total_exposure_vector\n\n        # Apply losses to all banks' capital\n        C_prime -= losses\n\n        # Identify newly defaulted banks for the next round\n        next_round_defaults = set()\n        for i in range(N):\n            # Check if bank i is newly defaulted\n            if i not in defaulted_banks and C_prime[i] = 0:\n                next_round_defaults.add(i)\n\n        # Update the set of all defaulted banks and set up for the next round\n        defaulted_banks.update(next_round_defaults)\n        newly_defaulted = next_round_defaults\n\n    return len(defaulted_banks)\n\n\ndef solve():\n    \"\"\"\n    Defines and runs all test cases for the simulation.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        {\n            \"N\": 4,\n            \"E\": np.array([\n                [0, 0, 0, 50],\n                [0, 0, 20, 0],\n                [10, 0, 0, 30],\n                [0, 0, 0, 0]\n            ], dtype=float),\n            \"C\": np.array([20, 12, 15, 5], dtype=float),\n            \"L\": 0.6, \"s\": 0.02, \"k\": 0.005,\n            \"p\": np.array([0.01, 0.01, 0.01, 0.5]),\n            \"tau\": np.array([0, 0, 0, 0], dtype=float),\n            \"D0\": {3}\n        },\n        # Test case 2\n        {\n            \"N\": 4,\n            \"E\": np.array([\n                [0, 0, 0, 50],\n                [0, 0, 20, 0],\n                [10, 0, 0, 30],\n                [0, 0, 0, 0]\n            ], dtype=float),\n            \"C\": np.array([20, 12, 15, 5], dtype=float),\n            \"L\": 0.6, \"s\": 0.02, \"k\": 0.005,\n            \"p\": np.array([0.01, 0.01, 0.01, 0.5]),\n            \"tau\": np.array([100, 100, 100, 100], dtype=float),\n            \"D0\": {3}\n        },\n        # Test case 3\n        {\n            \"N\": 4,\n            \"E\": np.array([\n                [0, 5, 5, 5],\n                [5, 0, 5, 5],\n                [5, 5, 0, 5],\n                [5, 5, 5, 0]\n            ], dtype=float),\n            \"C\": np.array([10, 10, 10, 10], dtype=float),\n            \"L\": 0.5, \"s\": 0.0, \"k\": 0.0,\n            \"p\": np.array([0.4, 0.4, 0.4, 0.4]),\n            \"tau\": np.array([0, 0, 0, 0], dtype=float),\n            \"D0\": set()\n        },\n        # Test case 4\n        {\n            \"N\": 2,\n            \"E\": np.array([\n                [0, 0],\n                [20, 0]\n            ], dtype=float),\n            \"C\": np.array([5, 10], dtype=float),\n            \"L\": 0.5, \"s\": 0.01, \"k\": 0.0,\n            \"p\": np.array([0.1, 0.1]),\n            \"tau\": np.array([100, 100], dtype=float),\n            \"D0\": {0}\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_simulation(\n            case[\"N\"], case[\"E\"], case[\"C\"], case[\"L\"], case[\"s\"],\n            case[\"k\"], case[\"p\"], case[\"tau\"], case[\"D0\"]\n        )\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\n\nsolve()\n```"
        }
    ]
}