{
    "hands_on_practices": [
        {
            "introduction": "我们动手实践的第一步始于一个基础性问题：市场参与者的多样化特征如何共同决定资产价格？第一个练习  将市场简化为一个单周期模型，以便提供一个清晰的解析答案。通过为具有不同风险厌恶程度和信念的经纪人建模，你将从第一性原理出发推导出均衡价格，并观察异质性如何催生出市场范围的风险溢价。",
            "id": "2445904",
            "problem": "考虑一个单期市场，其中包含一种无风险资产和一种风险资产。市场中有 $N$ 个代理人，其索引为 $i \\in \\{1,\\dots,N\\}$。每个代理人对期末财富具有恒定绝对风险厌恶（CARA）效用，其函数为 $U_i(w) = -\\exp(-\\gamma_i w)$，风险厌恶参数为 $\\gamma_i \\gt 0$。风险资产在期末支付一笔随机的回报 $D$。代理人 $i$ 持有主观信念，认为 $D$ 服从均值为 $\\mu_i$、方差为 $\\sigma_i^2$ 的正态分布，记为 $D \\sim \\mathcal{N}(\\mu_i,\\sigma_i^2)$。无风险资产的总回报率为 $R_f \\gt 0$。风险资产存在外生的总净供给 $s \\in \\mathbb{R}$（以风险资产的单位计量）。令 $P$ 表示风险资产在时刻0的价格。\n\n每个代理人在时刻0选择持有风险资产的头寸 $x_i$，以最大化期末财富的期望效用，并将价格 $P$ 视为给定。市场出清要求 $\\sum_{i=1}^N x_i = s$。假设所有给定参数都意味着竞争均衡价格 $P$ 存在且唯一。\n\n对于一个给定的实例，风险溢价定义为代理人期望回报的简单平均值与价格 $P$ 下所需总回报之间的差额，即\n$$\\text{RP} \\equiv \\bar{\\mu} - P R_f, \\quad \\text{其中} \\quad \\bar{\\mu} \\equiv \\frac{1}{N}\\sum_{i=1}^N \\mu_i.$$\n请以实数形式报告风险溢价，单位与 $D$ 相同（例如，美元）。答案以小数形式表示（不含百分号）。\n\n您的任务是编写一个程序，为下面的每个测试用例计算出清市场的唯一竞争均衡价格 $P$，然后输出上述定义的相应风险溢价 $\\text{RP}$。将每个风险溢价四舍五入到6位小数。\n\n测试套件（每个测试用例指定 $(N, R_f, s, \\{\\gamma_i\\}_{i=1}^N, \\{\\mu_i\\}_{i=1}^N, \\{\\sigma_i^2\\}_{i=1}^N)$）：\n- 测试用例 A:\n  - $N = 3$, $R_f = 1.02$, $s = 1.0$,\n  - $\\{\\gamma_i\\} = [2.0, 3.0, 1.0]$,\n  - $\\{\\mu_i\\} = [1.0, 1.2, 0.8]$,\n  - $\\{\\sigma_i^2\\} = [0.25, 0.25, 0.25]$.\n- 测试用例 B:\n  - $N = 3$, $R_f = 1.01$, $s = 1000.0$,\n  - $\\{\\gamma_i\\} = [1.0, 2.0, 3.0]$,\n  - $\\{\\mu_i\\} = [1.0, 1.0, 1.0]$,\n  - $\\{\\sigma_i^2\\} = [10^{-6}, 10^{-6}, 10^{-6}]$.\n- 测试用例 C:\n  - $N = 3$, $R_f = 1.00$, $s = 50.0$,\n  - $\\{\\gamma_i\\} = [10^{-6}, 2.0, 3.0]$,\n  - $\\{\\mu_i\\} = [1.1, 1.1, 1.1]$,\n  - $\\{\\sigma_i^2\\} = [9.0, 9.0, 9.0]$.\n- 测试用例 D:\n  - $N = 3$, $R_f = 1.05$, $s = 0.0$,\n  - $\\{\\gamma_i\\} = [2.0, 1.0, 4.0]$,\n  - $\\{\\mu_i\\} = [0.9, 1.4, 1.1]$,\n  - $\\{\\sigma_i^2\\} = [0.16, 0.36, 0.25]$.\n\n最终输出格式：您的程序应生成一行输出，其中包含四个测试用例的风险溢价，每个都四舍五入到6位小数，形式为方括号内以逗号分隔的列表，例如 $[r_A,r_B,r_C,r_D]$，其中 $r_A$ 对应测试用例A，依此类推。不应打印任何额外文本。",
            "solution": "所给出的问题是一个标准的、包含异质代理人的资产定价模型，该模型具有科学依据，设定良好且客观。因此，可以对其进行全面分析。我们从第一性原理出发推导解答。\n\n该模型包含 $N$ 个代理人，一个总回报率为 $R_f  0$ 的无风险资产，以及一个在时刻0价格为 $P$、在时刻1随机支付为 $D$ 的风险资产。代理人 $i \\in \\{1, \\dots, N\\}$ 具有恒定绝对风险厌恶（CARA）效用函数 $U_i(w) = -\\exp(-\\gamma_i w)$，其中 $\\gamma_i  0$ 是绝对风险厌恶系数。每个代理人 $i$ 都持有主观信念，认为支付 $D$ 服从正态分布 $D \\sim \\mathcal{N}(\\mu_i, \\sigma_i^2)$。\n\n代理人 $i$ 选择持有数量为 $x_i$ 的风险资产。其初始财富 $w_{i,0}$ 的其余部分投资于无风险资产。因此，代理人 $i$ 在时刻1的财富由下式给出：\n$$w_i = (w_{i,0} - x_i P)R_f + x_i D = w_{i,0}R_f + x_i(D - PR_f)$$\n代理人的目标是根据其主观信念，最大化期末财富的期望效用：\n$$\\max_{x_i} \\mathbb{E}_i[U_i(w_i)] = \\max_{x_i} \\mathbb{E}_i[-\\exp(-\\gamma_i w_i)]$$\n代入 $w_i$ 的表达式：\n$$\\max_{x_i} \\mathbb{E}_i[-\\exp(-\\gamma_i (w_{i,0}R_f + x_i(D - PR_f)))]$$\n由于 $w_{i,0}$ 和 $R_f$ 是常数，且最大化 $-f(x)$ 等价于最小化 $f(x)$，该问题等价于：\n$$\\min_{x_i} \\exp(-\\gamma_i w_{i,0}R_f) \\mathbb{E}_i[\\exp(-\\gamma_i x_i(D - PR_f))]$$\n项 $\\exp(-\\gamma_i w_{i,0}R_f)$ 是一个相对于选择变量 $x_i$ 的正常数，可以忽略。因此，优化等价于最小化期望项。令随机变量为 $Z_i = -\\gamma_i x_i(D - PR_f)$。从代理人 $i$ 的角度看，由于 $D \\sim \\mathcal{N}(\\mu_i, \\sigma_i^2)$，项 $(D - PR_f)$ 也服从正态分布，其均值为 $\\mu_i - PR_f$，方差为 $\\sigma_i^2$。因此，$Z_i$ 是一个正态分布的随机变量，其均值为 $\\mathbb{E}_i[Z_i] = -\\gamma_i x_i(\\mu_i - PR_f)$，方差为 $\\text{Var}_i(Z_i) = (-\\gamma_i x_i)^2 \\sigma_i^2 = \\gamma_i^2 x_i^2 \\sigma_i^2$。\n\n期望 $\\mathbb{E}_i[\\exp(Z_i)]$ 是正态变量 $Z_i$ 在 $t=1$ 处的矩生成函数。对于一个一般的正态变量 $X \\sim \\mathcal{N}(\\mu_X, \\sigma_X^2)$，其矩生成函数为 $M_X(t) = \\exp(\\mu_X t + \\frac{1}{2}\\sigma_X^2 t^2)$。将此应用于 $Z_i$：\n$$\\mathbb{E}_i[\\exp(Z_i)] = \\exp(\\mathbb{E}_i[Z_i] \\cdot 1 + \\frac{1}{2}\\text{Var}_i(Z_i) \\cdot 1^2) = \\exp(-\\gamma_i x_i(\\mu_i - PR_f) + \\frac{1}{2}\\gamma_i^2 x_i^2 \\sigma_i^2)$$\n代理人的问题简化为选择 $x_i$ 来最小化此表达式，这等价于最小化其指数部分（确定性等价收益率）：\n$$\\min_{x_i} \\left\\{ -\\gamma_i x_i(\\mu_i - PR_f) + \\frac{1}{2}\\gamma_i^2 x_i^2 \\sigma_i^2 \\right\\}$$\n这是一个关于 $x_i$ 的凸二次函数。通过对 $x_i$ 求导并令结果为零，可以找到最小化的一阶条件：\n$$\\frac{\\partial}{\\partial x_i} \\left[ -\\gamma_i x_i(\\mu_i - PR_f) + \\frac{1}{2}\\gamma_i^2 x_i^2 \\sigma_i^2 \\right] = -\\gamma_i(\\mu_i - PR_f) + \\gamma_i^2 x_i \\sigma_i^2 = 0$$\n由于 $\\gamma_i  0$，我们可以除以 $\\gamma_i$ 并求解 $x_i$，得到个人对风险资产的需求：\n$$x_i(P) = \\frac{\\mu_i - PR_f}{\\gamma_i \\sigma_i^2}$$\n该表达式表明，需求由风险资产单位的感知期望超额回报驱动，并由代理人的风险容忍度进行缩放，风险容忍度是风险厌恶度和感知方差乘积的倒数。\n\n均衡价格 $P$ 由市场出清条件决定，该条件要求总需求等于外生总供给 $s$：\n$$\\sum_{i=1}^N x_i = s$$\n代入个人需求函数：\n$$\\sum_{i=1}^N \\frac{\\mu_i - PR_f}{\\gamma_i \\sigma_i^2} = s$$\n我们可以解这个关于 $P$ 的线性方程。让我们分离各项：\n$$\\sum_{i=1}^N \\frac{\\mu_i}{\\gamma_i \\sigma_i^2} - \\sum_{i=1}^N \\frac{PR_f}{\\gamma_i \\sigma_i^2} = s$$\n$$PR_f \\left( \\sum_{i=1}^N \\frac{1}{\\gamma_i \\sigma_i^2} \\right) = \\left( \\sum_{i=1}^N \\frac{\\mu_i}{\\gamma_i \\sigma_i^2} \\right) - s$$\n求解所需总回报 $PR_f$：\n$$PR_f = \\frac{\\left( \\sum_{i=1}^N \\frac{\\mu_i}{\\gamma_i \\sigma_i^2} \\right) - s}{\\sum_{i=1}^N \\frac{1}{\\gamma_i \\sigma_i^2}}$$\n问题将风险溢价定义为 $\\text{RP} \\equiv \\bar{\\mu} - PR_f$，其中 $\\bar{\\mu} = \\frac{1}{N}\\sum_{i=1}^N \\mu_i$。代入推导出的 $PR_f$ 表达式，得到风险溢价的最终公式：\n$$\\text{RP} = \\left(\\frac{1}{N}\\sum_{i=1}^N \\mu_i\\right) - \\frac{\\left( \\sum_{i=1}^N \\frac{\\mu_i}{\\gamma_i \\sigma_i^2} \\right) - s}{\\sum_{i=1}^N \\frac{1}{\\gamma_i \\sigma_i^2}}$$\n我们将实施这个解析表达式来计算每个测试用例的风险溢价。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the competitive equilibrium price and risk premium for a set of test cases\n    in a CARA-Normal asset pricing model with heterogeneous beliefs.\n    \"\"\"\n\n    def calculate_risk_premium(N, Rf, s, gammas, mus, sigmas_sq):\n        \"\"\"\n        Calculates the risk premium for a single market instance.\n\n        Args:\n            N (int): Number of agents.\n            Rf (float): Gross risk-free return.\n            s (float): Aggregate net supply of the risky asset.\n            gammas (np.ndarray): Array of risk aversion parameters.\n            mus (np.ndarray): Array of subjective expected payoffs.\n            sigmas_sq (np.ndarray): Array of subjective payoff variances.\n\n        Returns:\n            float: The calculated risk premium.\n        \"\"\"\n        # Average of agents' expected payoffs\n        mu_bar = np.mean(mus)\n\n        # Risk tolerances tau_i = 1 / (gamma_i * sigma_i^2)\n        taus = 1.0 / (gammas * sigmas_sq)\n\n        # Numerator of the PR_f expression: sum(mu_i * tau_i) - s\n        numerator_pr_f = np.sum(mus * taus) - s\n\n        # Denominator of the PR_f expression: sum(tau_i)\n        denominator_pr_f = np.sum(taus)\n\n        # Required gross payoff at equilibrium price P\n        pr_f = numerator_pr_f / denominator_pr_f\n\n        # Risk premium RP = mu_bar - P * R_f\n        risk_premium = mu_bar - pr_f\n        \n        return risk_premium\n\n    # Test Suite\n    test_cases = [\n        # Test case A: (N, Rf, s, {gamma_i}, {mu_i}, {sigma_i^2})\n        (3, 1.02, 1.0, np.array([2.0, 3.0, 1.0]), np.array([1.0, 1.2, 0.8]), np.array([0.25, 0.25, 0.25])),\n        # Test case B:\n        (3, 1.01, 1000.0, np.array([1.0, 2.0, 3.0]), np.array([1.0, 1.0, 1.0]), np.array([1e-6, 1e-6, 1e-6])),\n        # Test case C:\n        (3, 1.00, 50.0, np.array([1e-6, 2.0, 3.0]), np.array([1.1, 1.1, 1.1]), np.array([9.0, 9.0, 9.0])),\n        # Test case D:\n        (3, 1.05, 0.0, np.array([2.0, 1.0, 4.0]), np.array([0.9, 1.4, 1.1]), np.array([0.16, 0.36, 0.25])),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, Rf, s, gammas, mus, sigmas_sq = case\n        rp = calculate_risk_premium(N, Rf, s, gammas, mus, sigmas_sq)\n        results.append(rp)\n    \n    # Format the output as a comma-separated list of values rounded to 6 decimal places.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "真实世界的市场并非静止不变，它们在不断演化，其中的经纪人也是如此。在这个练习  中，我们将从静态均衡模型进阶到动态模拟，在这里经纪人会随着时间的推移而学习。你将实现一个适应性学习规则，允许经纪人根据过去的结果更新他们对资产盈利能力的预期，并探索这一学习过程和随之而来的财富动态如何塑造市场的整体投资行为。",
            "id": "2399122",
            "problem": "考虑一个由大量代理人组成的群体，他们在一项安全资产和一项风险资产之间进行投资组合选择。时间是离散的，由 $t \\in \\{0,1,2,\\dots,T-1\\}$ 索引。每个代理人 $i \\in \\{1,\\dots,N\\}$ 在时期 $t$ 开始时选择一个投资组合份额 $x_{i,t} \\in [0,1]$ 投资于风险资产，剩余的份额 $1-x_{i,t}$ 投资于安全资产。安全资产具有恒定的总回报率 $R_f  0$。风险资产的净回报率为 $r_t$，它在时间上是独立同分布（i.i.d.）的，其均值 $\\mu^\\star$ 未知，方差 $\\sigma^2$ 已知。回报率以小数形式表示；例如，百分之五的回报率为 $0.05$，每个时期百分之一的无风险总回报率为 $R_f = 1.01$。\n\n代理人在两个维度上是异质的：\n- 每个代理人 $i$ 都有一个风险厌恶系数 $\\gamma_i  0$。\n- 每个代理人 $i$ 都有一个学习率 $\\alpha_i \\in (0,1]$，用于自适应地更新她对风险资产预期净回报率的估计。\n\n在时间 $t$，观察到 $r_t$ 之前，每个代理人对风险资产的预期净回报率持有一个信念 $\\mu_{i,t}$。信念根据自适应学习进行演化：\n$$\n\\mu_{i,t+1} \\;=\\; \\mu_{i,t} + \\alpha_i \\left(r_t - \\mu_{i,t}\\right).\n$$\n假设所有代理人都知道方差 $\\sigma^2$ 和安全总回报率 $R_f$，但不知道 $\\mu^\\star$。存在无卖空、无杠杆的约束：对于所有 $i,t$，$x_{i,t} \\in [0,1]$。\n\n财富根据标准总回报率聚合进行演化：\n$$\nW_{i,t+1} \\;=\\; W_{i,t} \\left[ R_f \\left(1-x_{i,t}\\right) + \\left(1+r_t\\right) x_{i,t} \\right],\n$$\n所有代理人的初始财富为 $W_{i,0} = 1$。\n\n代理人选择 $x_{i,t}$ 以最大化一个基于 Markowitz 框架的均值-方差目标，该目标可以通过正态回报下的指数效用函数来合理解释。从线性投资组合的期望和方差定义以及 $r_t$ 的正态性假设出发，根据第一性原理推导出单周期最优风险份额 $x_{i,t}$，它是在约束 $x_{i,t} \\in [0,1]$ 下，关于代理人信念 $\\mu_{i,t}$、安全回报率 $R_f$、风险厌恶参数 $\\gamma_i$ 和回报率方差 $\\sigma^2$ 的函数。最终的选择规则必须通过一阶条件获得，然后投影到可行集 $[0,1]$ 上。\n\n将时间 $t$ 的财富加权总风险份额定义为\n$$\n\\bar{x}_t \\;=\\; \\frac{\\sum_{i=1}^{N} W_{i,t} \\, x_{i,t}}{\\sum_{i=1}^{N} W_{i,t}}.\n$$\n\n您的任务是实现这个异质代理人经济体的模拟，并为下面测试套件中的每组参数，计算最后 $L$ 个时期的财富加权风险份额的时间平均值：\n$$\n\\bar{x}_{\\text{avg}} \\;=\\; \\frac{1}{L} \\sum_{t=T-L}^{T-1} \\bar{x}_t.\n$$\n\n所有代理人的初始信念被设定为安全净回报率：\n$$\n\\mu_{i,0} \\;=\\; R_f - 1.\n$$\n\n异质性是使用基于索引的循环来确定性地分配的。设给定的 $\\gamma_{\\text{base}}  0$ 和 $\\alpha_{\\text{base}} \\in (0,1]$。对于代理人索引 $i = 1,\\dots,N$，定义\n$$\n\\gamma_i \\;=\\; \\gamma_{\\text{base}} \\times m_{(i \\bmod 4)},\n\\quad \\text{其中 } m_{0}=0.5,\\; m_{1}=1.0,\\; m_{2}=1.5,\\; m_{3}=2.0,\n$$\n和\n$$\n\\alpha_i \\;=\\; \\min\\left(0.9,\\; \\alpha_{\\text{base}} \\times a_{(i \\bmod 4)}\\right),\n\\quad \\text{其中 } a_{0}=0.5,\\; a_{1}=1.0,\\; a_{2}=2.0,\\; a_{3}=4.0.\n$$\n\n模拟协议：\n- 使用 $N$ 个代理人和 $T$ 个时期。\n- 风险净回报率 $r_t$ 从 $r_t \\sim \\mathcal{N}(\\mu^\\star,\\sigma^2)$ 中抽取，并且在时间 $t$ 上是独立的。\n- 为保证可复现性，使用一个固定的伪随机数生成器种子：基础种子为 $12345$，并由从零开始的测试用例索引 $k \\in \\{0,1,2,3\\}$ 进行偏移，因此用例 $k$ 的种子是 $12345 + k$。\n- 计算如上定义的 $\\bar{x}_{\\text{avg}}$。\n\n测试套件（每个项目是一个参数元组 $(\\mu^\\star,\\sigma,R_f,\\gamma_{\\text{base}},\\alpha_{\\text{base}},N,T,L)$；所有回报率均为小数）：\n1. 用例 1: $(0.06,\\,0.15,\\,1.01,\\,3.0,\\,0.20,\\,200,\\,2000,\\,500)$。\n2. 用例 2: $(0.01,\\,0.15,\\,1.01,\\,3.0,\\,0.20,\\,200,\\,2000,\\,500)$。\n3. 用例 3: $(0.06,\\,0.20,\\,1.01,\\,3.0,\\,0.20,\\,200,\\,2000,\\,500)$。\n4. 用例 4: $(0.06,\\,0.15,\\,1.01,\\,6.0,\\,0.05,\\,200,\\,2000,\\,500)$。\n\n您的程序必须生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，顺序与上述用例相同，例如 $[r_1,r_2,r_3,r_4]$，其中每个 $r_k$ 是用例 $k$ 的 $\\bar{x}_{\\text{avg}}$ 的浮点值，以小数（而非百分比）表示。您可以根据需要进行四舍五入或格式化，但要确保使用标准的浮点格式，以便每个 $r_k$ 都可以被解析为浮点数。",
            "solution": "问题陈述经过了严格验证，并被认定为有效。这是一个计算经济学领域中定义明确的问题，它基于成熟的经济学理论，并且为模拟提供了所有必要的参数和函数形式。该模型将标准的 Markowitz 式投资组合选择问题与自适应学习动态相结合，这是金融学中异质代理人模型的常见结构。不存在会妨碍得出唯一且有意义的解决方案的科学不一致、矛盾或关键模糊之处。关于代理人索引 `i mod 4` 的微小模糊之处，通过采用标准的计算惯例得以解决，即使用从基于1的代理人索引派生出的基于0的索引，即 `(i-1) mod 4`，这与所提供的乘数索引 $\\{0,1,2,3\\}$ 相符。\n\n解决方案分为两部分：首先，从第一性原理推导代理人的最优决策规则；其次，描述基于此规则构建的模拟算法。\n\n**第1部分：最优风险资产份额的推导**\n\n每个代理人 $i$ 选择其财富的一定份额 $x_{i,t} \\in [0,1]$ 投资于风险资产，以最大化单周期的均值-方差目标。代理人投资组合的总回报率 $R_{p,i,t}$ 是安全资产总回报率 $R_f$ 和风险资产总回报率 $1+r_t$ 的加权平均值：\n$$\nR_{p,i,t} \\;=\\; (1-x_{i,t})R_f + x_{i,t}(1+r_t)\n$$\n这可以重写为风险资产相对于安全资产的超额回报率形式：\n$$\nR_{p,i,t} \\;=\\; R_f + x_{i,t}(1+r_t - R_f) \\;=\\; R_f + x_{i,t}(r_t - (R_f-1))\n$$\n令 $r_f = R_f-1$ 为无风险净利率。\n$$\nR_{p,i,t} \\;=\\; R_f + x_{i,t}(r_t - r_f)\n$$\n代理人的决策在时间 $t$ 做出，此时 $r_t$ 尚属未知。因此，代理人使用基于其信念 $\\mu_{i,t}$ 和已知方差 $\\sigma^2$ 的主观期望 $E_t[\\cdot]$。预期投资组合回报率为：\n$$\nE_t[R_{p,i,t}] \\;=\\; E_t[R_f + x_{i,t}(r_t - r_f)] \\;=\\; R_f + x_{i,t}(E_t[r_t] - r_f) \\;=\\; R_f + x_{i,t}(\\mu_{i,t} - r_f)\n$$\n投资组合回报率的方差为：\n$$\nVar_t(R_{p,i,t}) \\;=\\; Var_t(R_f + x_{i,t}(r_t - r_f)) \\;=\\; Var_t(x_{i,t}r_t) \\;=\\; x_{i,t}^2 Var_t(r_t) \\;=\\; x_{i,t}^2 \\sigma^2\n$$\n代理人 $i$ 的均值-方差目标函数是最大化：\n$$\nU(x_{i,t}) \\;=\\; E_t[R_{p,i,t}] - \\frac{\\gamma_i}{2} Var_t(R_{p,i,t})\n$$\n代入期望值和方差的表达式：\n$$\nU(x_{i,t}) \\;=\\; \\left( R_f + x_{i,t}(\\mu_{i,t} - r_f) \\right) - \\frac{\\gamma_i}{2} x_{i,t}^2 \\sigma^2\n$$\n这是一个关于 $x_{i,t}$ 的凹二次函数。为了找到最优的无约束份额 $x_{i,t}^*$，我们对 $x_{i,t}$ 求一阶导数并令其为零（最大化的一阶条件）：\n$$\n\\frac{\\mathrm{d}U}{\\mathrm{d}x_{i,t}} \\;=\\; (\\mu_{i,t} - r_f) - \\gamma_i \\sigma^2 x_{i,t} \\;=\\; 0\n$$\n求解 $x_{i,t}$：\n$$\nx_{i,t}^* \\;=\\; \\frac{\\mu_{i,t} - r_f}{\\gamma_i \\sigma^2} \\;=\\; \\frac{\\mu_{i,t} - (R_f - 1)}{\\gamma_i \\sigma^2}\n$$\n这是经典的 Merton 份额。分子代表感知到的风险资产超额净回报率，分母是风险厌恶程度和回报率方差的乘积。\n\n问题指定了无卖空和无杠杆的约束，意味着 $x_{i,t}$ 必须位于区间 $[0,1]$ 内。最终的最优选择是无约束解 $x_{i,t}^*$ 在此可行集上的投影：\n$$\nx_{i,t} \\;=\\; \\max\\left(0, \\min\\left(1, x_{i,t}^*\\right)\\right)\n$$\n\n**第2部分：模拟算法**\n\n该模拟对一个由 $N$ 个异质代理人组成的经济体在 $T$ 个离散时间周期内进行建模。算法流程如下：\n\n1.  **初始化 (在 $t=0$ 时):**\n    *   从测试用例中设置全局参数 $(\\mu^\\star, \\sigma, R_f, N, T, L)$ 和异质性基础参数 $(\\gamma_{\\text{base}}, \\alpha_{\\text{base}})$。\n    *   使用指定的种子初始化伪随机数生成器。\n    *   创建 $N$ 个代理人的群体。对于每个代理人 $i \\in \\{1, \\dots, N\\}$，根据确定性循环分配异质参数 $\\gamma_i$ 和 $\\alpha_i$。令 $j = (i-1) \\pmod 4$。则：\n        $$\n        \\gamma_i \\;=\\; \\gamma_{\\text{base}} \\times m_j, \\quad \\text{其中 } m \\in \\{0.5, 1.0, 1.5, 2.0\\}\n        $$\n        $$\n        \\alpha_i \\;=\\; \\min(0.9, \\alpha_{\\text{base}} \\times a_j), \\quad \\text{其中 } a \\in \\{0.5, 1.0, 2.0, 4.0\\}\n        $$\n    *   为每个代理人 $i$ 设置初始状态变量：\n        *   初始财富：$W_{i,0} = 1$。\n        *   初始信念：$\\mu_{i,0} = R_f - 1$。\n\n2.  **时间循环 (对于 $t=0, 1, \\dots, T-1$):**\n    在每个时期 $t$ 执行以下步骤：\n    *   a. 投资组合选择：每个代理人 $i$ 使用他们当前的信念 $\\mu_{i,t}$ 和从第1部分推导出的公式来计算其最优风险资产配置 $x_{i,t}$。\n    *   b. 聚合：计算经济体的财富加权总风险份额 $\\bar{x}_t$：\n        $$\n        \\bar{x}_t \\;=\\; \\frac{\\sum_{i=1}^{N} W_{i,t} \\, x_{i,t}}{\\sum_{i=1}^{N} W_{i,t}}\n        $$\n        如果当前时期 $t$ 在最后的平均窗口内，即 $t \\ge T-L$，则存储 $\\bar{x}_t$ 的值。\n    *   c. 市场实现：从均值为 $\\mu^\\star$、方差为 $\\sigma^2$ 的正态分布中抽取风险资产的随机净回报率 $r_t$：$r_t \\sim \\mathcal{N}(\\mu^\\star, \\sigma^2)$。\n    *   d. 状态更新：更新所有代理人的状态以反映时期 $t$ 的结果，为时期 $t+1$ 做准备：\n        *   财富演化：$W_{i,t+1} = W_{i,t} [ R_f (1-x_{i,t}) + (1+r_t) x_{i,t} ]$。\n        *   信念演化：$\\mu_{i,t+1} = \\mu_{i,t} + \\alpha_i (r_t - \\mu_{i,t})$。\n\n3.  **最终计算：**\n    模拟循环完成后，通过计算最后 $L$ 个时期存储的 $\\bar{x}_t$ 值的算术平均值，来计算最终输出 $\\bar{x}_{\\text{avg}}$：\n    $$\n    \\bar{x}_{\\text{avg}} \\;=\\; \\frac{1}{L} \\sum_{t=T-L}^{T-1} \\bar{x}_t\n    $$\n\n该算法使用 `numpy` 库的向量化操作实现，以确保计算效率。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(mu_star, sigma, R_f, gamma_base, alpha_base, N, T, L, seed):\n    \"\"\"\n    Runs a single simulation of the heterogeneous agent model.\n\n    Args:\n        mu_star (float): True mean of the risky asset net return.\n        sigma (float): True standard deviation of the risky asset net return.\n        R_f (float): Gross risk-free return.\n        gamma_base (float): Base risk-aversion coefficient.\n        alpha_base (float): Base learning rate.\n        N (int): Number of agents.\n        T (int): Number of time periods.\n        L (int): Number of last periods to average over.\n        seed (int): Seed for the pseudo-random number generator.\n\n    Returns:\n        float: The time average of the wealth-weighted risky share over the last L periods.\n    \"\"\"\n    # Initialize the pseudo-random number generator for reproducibility.\n    rng = np.random.default_rng(seed)\n\n    # Define heterogeneity multipliers\n    m_multipliers = np.array([0.5, 1.0, 1.5, 2.0])\n    a_multipliers = np.array([0.5, 1.0, 2.0, 4.0])\n\n    # Assign heterogeneous parameters to agents based on index-based cycles.\n    agent_indices_mod_4 = np.arange(N) % 4\n    gamma_i = gamma_base * m_multipliers[agent_indices_mod_4]\n    alpha_i = np.minimum(0.9, alpha_base * a_multipliers[agent_indices_mod_4])\n\n    # Initial state variables\n    r_f_net = R_f - 1.0\n    mu_i_t = np.full(N, r_f_net)\n    W_i_t = np.ones(N)\n    \n    # Pre-calculate constant variance\n    sigma2 = sigma**2\n\n    # Storage for results in the final averaging window\n    x_bar_history = []\n\n    # Simulation loop over T periods\n    for t in range(T):\n        # 1. Agents make portfolio choices\n        # Calculate unconstrained optimal share\n        x_i_t_star = (mu_i_t - r_f_net) / (gamma_i * sigma2)\n        # Apply no-short, no-leverage constraint [0, 1]\n        x_i_t = np.clip(x_i_t_star, 0.0, 1.0)\n        \n        # 2. Compute and store aggregate risky share if in the final L periods\n        if t >= T - L:\n            total_W_t = np.sum(W_i_t)\n            # Avoid division by zero, though unlikely with these parameters\n            if total_W_t > 0:\n                x_bar_t = np.sum(W_i_t * x_i_t) / total_W_t\n                x_bar_history.append(x_bar_t)\n            else:\n                 x_bar_history.append(0.0)\n\n        # 3. Realize the risky asset's net return for the period\n        r_t = rng.normal(loc=mu_star, scale=sigma)\n        \n        # 4. Update agent states for the next period\n        # Update wealth\n        portfolio_gross_return = R_f * (1.0 - x_i_t) + (1.0 + r_t) * x_i_t\n        W_i_t = W_i_t * portfolio_gross_return\n        # Update beliefs\n        mu_i_t = mu_i_t + alpha_i * (r_t - mu_i_t)\n\n    # 5. Final calculation: average of the stored aggregate shares\n    x_bar_avg = np.mean(x_bar_history) if x_bar_history else 0.0\n    \n    return x_bar_avg\n\ndef solve():\n    \"\"\"\n    Main function to run simulations for all test cases and print the results.\n    \"\"\"\n    _ = np.set_printoptions # Scipy and numpy are permitted; not used here.\n\n    # Test suite: (mu_star, sigma, R_f, gamma_base, alpha_base, N, T, L)\n    test_cases = [\n        (0.06, 0.15, 1.01, 3.0, 0.20, 200, 2000, 500),\n        (0.01, 0.15, 1.01, 3.0, 0.20, 200, 2000, 500),\n        (0.06, 0.20, 1.01, 3.0, 0.20, 200, 2000, 500),\n        (0.06, 0.15, 1.01, 6.0, 0.05, 200, 2000, 500),\n    ]\n\n    results = []\n    base_seed = 12345\n    for i, case in enumerate(test_cases):\n        mu_star, sigma, R_f, gamma_base, alpha_base, N, T, L = case\n        # Set seed based on test case index\n        seed = base_seed + i\n        result = run_simulation(mu_star, sigma, R_f, gamma_base, alpha_base, N, T, L, seed)\n        results.append(result)\n\n    # Format the output as a comma-separated list in brackets, with standard float precision.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "除了个体学习，市场适应也可以在群体层面发生，即成功的策略得以繁殖扩散，不成功的策略则被淘汰。这个练习  将向你介绍这种“生态学”视角，并使用一个强大的工具：遗传算法。你将构建一个模拟，其中一组交易规则的种群根据其盈利能力进行代际演化，展示如何利用计算演化来发现金融市场中的有效策略。",
            "id": "2399108",
            "problem": "考虑一个由异质交易代理组成的种群，代理的索引为 $i \\in \\{1,\\dots,N\\}$，它们在一个确定性的超额对数收益序列 $\\{r_t\\}_{t=1}^T$ 上进行操作。每个代理 $i$ 遵循一个阈值移动平均规则，该规则由一个回顾窗口长度 $k_i \\in \\{2,3,\\dots,K_{\\max}\\}$ 和一个非负阈值 $\\tau_i \\in \\{0,\\tau_{\\text{step}},2\\tau_{\\text{step}},\\dots,H_{\\max}\\tau_{\\text{step}}\\}$ 参数化。定义时间 $t$ 时窗口为 $k$ 的移动平均信号为\n$$\nm_t^{(k)} = \\frac{1}{k}\\sum_{j=0}^{k-1} r_{t-j}, \\quad \\text{for } t \\in \\{k,k+1,\\dots,T-1\\}.\n$$\n代理 $i$ 在时间 $t$ 根据以下规则持有头寸 $s_{i,t} \\in \\{-1,0,+1\\}$\n$$\ns_{i,t} =\n\\begin{cases}\n+1  \\text{if } m_t^{(k_i)} \\ge \\tau_i, \\\\\n-1  \\text{if } m_t^{(k_i)} \\le -\\tau_i, \\\\\n0  \\text{otherwise},\n\\end{cases}\n\\quad \\text{for } t \\in \\{k_i,k_i+1,\\dots,T-1\\}.\n$$\n代理 $i$ 在样本上的已实现利润定义为\n$$\n\\pi_i = \\sum_{t=k_i}^{T-1} s_{i,t} \\, r_{t+1} \\;-\\; c \\sum_{t=k_i}^{T-1} \\mathbf{1}\\{s_{i,t} \\ne s_{i,t-1}\\},\n$$\n约定 $s_{i,k_i-1}=0$，其中 $c \\ge 0$ 是每次交易的交易成本。代理 $i$ 的适应度由利润的一个非负变换给出\n$$\nf(\\pi_i) = \\pi_i - \\min_j \\pi_j + \\delta,\n$$\n其中 $\\delta0$ 是一个任意小的正常数。\n\n超额对数收益过程是确定性的，由下式给出\n$$\nr_t = A \\sin\\!\\left(\\frac{2\\pi t}{P}\\right) + B\\left(\\frac{t}{T}-\\frac{1}{2}\\right),\n\\quad t \\in \\{1,2,\\dots,T\\},\n$$\n其中 $A0$，$B \\in \\mathbb{R}$ 和周期 $P \\in \\mathbb{N}$ 是固定常数。\n\n一个包含 $N$ 个异质代理的有限种群在 $G$ 个离散的代中演化。在每一代，会形成一个大小为 $N$ 的新种群，过程如下：保留一个精英代理（适应度最高的代理）不变，其余 $N-1$ 个代理通过从当前种群中按与适应度成比例的概率抽样父代，并以概率 $p_c \\in [0,1]$ 应用基因级交叉，以及以概率 $\\mu \\in [0,1]$ 应用独立的基因级突变来产生，进入 $k$ 的允许离散集合 $\\{2,\\dots,K_{\\max}\\}$ 和 $\\tau$ 的允许离散集合 $\\{0,1,\\dots,H_{\\max}\\}\\cdot \\tau_{\\text{step}}$。在抽样父代时，如果所有适应度值都相等，则均匀抽样父代。在对基因进行突变时，用一个从相应允许集合中（不包括当前值）均匀抽取的值来替换它。在初始化第一个种群之前，必须使用指定的整数种子初始化伪随机数生成器；然后，在整个演化过程中的所有随机操作都使用同一个生成器。\n\n实现一个程序，对于下面测试套件中的每一组参数，该程序使用指定的种子，通过在允许的离散集合上独立均匀地抽样每个代理的 $(k_i,\\tau_i)$ 来初始化一个大小为 $N$ 的种群，开始一次独立的演化运行，按照描述将种群演化 $G$ 代，并输出在最后一代种群上测得的最大已实现利润 $\\max_i \\pi_i$。所有计算都必须以实数进行，除了明确指定的伪随机操作外，不应有任何其他随机性。将常数 $A$、$B$ 和 $P$ 设置为 $A=0.01$，$B=0.0005$ 和 $P=20$。\n\n测试套件参数集：\n- 案例1（基准）：$(T,N,G,c,\\mu,p_c,K_{\\max},\\tau_{\\text{step}},H_{\\max},\\delta,\\text{seed}) = (120,20,30,0.0005,0.1,0.7,8,0.0005,4,10^{-12},202405)$。\n- 案例2（高交易成本）：$(T,N,G,c,\\mu,p_c,K_{\\max},\\tau_{\\text{step}},H_{\\max},\\delta,\\text{seed}) = (120,20,30,0.002,0.1,0.7,8,0.0005,4,10^{-12},202406)$。\n- 案例3（无交叉或突变）：$(T,N,G,c,\\mu,p_c,K_{\\max},\\tau_{\\text{step}},H_{\\max},\\delta,\\text{seed}) = (80,10,50,0.0005,0.0,0.0,6,0.0005,3,10^{-12},42)$。\n\n对于每个案例，你的程序必须计算出最后一代种群中最佳利润的单一实数值。要求的最终输出格式是包含三个结果的单行，结果为逗号分隔的列表，并用方括号括起来，每个值都精确到 $6$ 位小数（例如，$[x_1,x_2,x_3]$，其中每个 $x_i$ 是一个有 $6$ 位小数的十进制数）。不涉及物理单位。",
            "solution": "问题陈述已被解析和验证。\n\n### 第1步：提取的已知信息\n\n- **收益序列**：$\\{r_t\\}_{t=1}^T$，其中 $r_t = A \\sin(\\frac{2\\pi t}{P}) + B(\\frac{t}{T}-\\frac{1}{2})$，参数为 $A=0.01$, $B=0.0005$, $P=20$。\n- **代理基因**：一对 $(k_i, \\tau_i)$，其中 $k_i \\in \\{2, 3, \\dots, K_{\\max}\\}$ 且 $\\tau_i \\in \\{0, \\tau_{\\text{step}}, \\dots, H_{\\max}\\tau_{\\text{step}}\\}$。\n- **代理信号**：$m_t^{(k)} = \\frac{1}{k}\\sum_{j=0}^{k-1} r_{t-j}$，对于 $t \\ge k$。\n- **代理头寸**：$s_{i,t} = +1$ 如果 $m_t^{(k_i)} \\ge \\tau_i$，$-1$ 如果 $m_t^{(k_i)} \\le -\\tau_i$，否则为 $0$，对于 $t \\in \\{k_i, \\dots, T-1\\}$。\n- **代理利润**：$\\pi_i = \\sum_{t=k_i}^{T-1} s_{i,t} r_{t+1} - c \\sum_{t=k_i}^{T-1} \\mathbf{1}\\{s_{i,t} \\ne s_{i,t-1}\\}$，约定 $s_{i,k_i-1}=0$。\n- **适应度函数**：$f(\\pi_i) = \\pi_i - \\min_j \\pi_j + \\delta$。\n- **遗传算法**：\n  - 种群大小 $N$，代数 $G$。\n  - **初始化**：使用指定的种子，从允许集合中均匀随机抽样 $(k_i, \\tau_i)$。\n  - **繁殖**：对于每个新的一代，保留一个精英代理（适应度最高）。其余 $N-1$ 个代理通过以下方式生成：\n    1. 按与适应度成比例的概率选择父代（如果所有适应度相等则均匀选择）。\n    2. 以概率 $p_c$ 进行基因级交叉。\n    3. 以概率 $\\mu$ 进行独立的基因级突变。\n- **突变机制**：用从允许集合中（不包括当前值）均匀抽取的值替换基因。\n- **任务**：对一组参数运行模拟，并报告最终一代种群中的最大利润 $\\max_i \\pi_i$。\n- **测试案例**：\n  1. $(T,N,G,c,\\mu,p_c,K_{\\max},\\tau_{\\text{step}},H_{\\max},\\delta,\\text{seed}) = (120,20,30,0.0005,0.1,0.7,8,0.0005,4,10^{-12},202405)$\n  2. $(T,N,G,c,\\mu,p_c,K_{\\max},\\tau_{\\text{step}},H_{\\max},\\delta,\\text{seed}) = (120,20,30,0.002,0.1,0.7,8,0.0005,4,10^{-12},202406)$\n  3. $(T,N,G,c,\\mu,p_c,K_{\\max},\\tau_{\\text{step}},H_{\\max},\\delta,\\text{seed}) = (80,10,50,0.0005,0.0,0.0,6,0.0005,3,10^{-12},42)$\n\n### 第2步：验证\n\n该问题是计算金融领域中一个明确定义的模拟任务，具体涉及异质代理模型和演化学习。\n- **科学依据**：该模型使用了标准组件：移动平均交易规则、遗传算法（精英主义、适应度比例选择、交叉、突变）以及包含交易成本的典型利润函数。这些是已确立的概念。收益序列是人工合成且确定性的，这适合于受控的计算实验。不存在科学或逻辑上的矛盾。\n- **适定性**：所有参数、函数和过程都已明确定义。使用带有特定种子的伪随机数生成器确保了模拟是确定性和可复现的，从而导向唯一的解。\n- **客观性**：问题以精确的数学和算法语言陈述，没有歧义或主观论断。\n\n### 第3步：结论\n\n该问题是**有效的**。将构建一个解决方案。\n\n### 解决方案设计\n\n该问题要求实现一个遗传算法来演化一个交易代理种群。解决方案被构建为一个逐代进行的模拟。核心组成部分是代理级别的利润计算和种群级别的演化动态。\n\n**1. 模拟环境和代理表示**\n\n首先，我们建立环境。确定性的超额对数收益序列 $\\{r_t\\}_{t=1}^T$ 根据其公式预先计算：\n$$\nr_t = A \\sin\\left(\\frac{2\\pi t}{P}\\right) + B\\left(\\frac{t}{T}-\\frac{1}{2}\\right)\n$$\n该序列存储为数值数组。常数 $A$、$B$ 和 $P$ 分别固定为 $0.01$、$0.0005$ 和 $20$。\n代理基因、回顾窗口 $k$ 和阈值 $\\tau$ 的允许集合也已预先计算。\n- 可能的回顾窗口集合是 $K_{set} = \\{2, 3, \\dots, K_{\\max}\\}$。\n- 可能的阈值集合是 $\\Tau_{set} = \\{0, \\tau_{\\text{step}}, 2\\tau_{\\text{step}}, \\dots, H_{\\max}\\tau_{\\text{step}}\\}$。\n一个代理由其“基因组”表示，即一对索引 $(i_k, i_\\tau)$，指向这些预计算集合中的值，从而方便遗传操作。\n\n**2. 代理利润计算**\n\n对于一个给定参数 $(k, \\tau)$ 的代理，其利润 $\\pi$ 是在整个时间范围内计算的。这是一个确定性函数。\n- 对于从 $k$ 到 $T-1$ 的每个时间步 $t$，计算移动平均信号 $m_t^{(k)}$。这是前 $k$ 个收益 $\\{r_{t-k+1}, \\dots, r_t\\}$ 的算术平均值。\n- 根据信号，确定代理的头寸 $s_t$：\n$$\ns_t =\n\\begin{cases}\n+1  \\text{if } m_t^{(k)} \\ge \\tau \\\\\n-1  \\text{if } m_t^{(k)} \\le -\\tau \\\\\n0  \\text{otherwise}\n\\end{cases}\n$$\n- 总利润 $\\pi$ 是两个组成部分的总和：总交易利润和交易成本。\n  - 总毛利润为 $\\sum_{t=k}^{T-1} s_t r_{t+1}$。在时间 $t$ 持有的头寸乘以从 $t$ 到 $t+1$ 的收益。\n  - 交易成本为 $c \\cdot N_{trades}$，其中 $N_{trades}$ 是代理头寸变化的次数。这计算为 $\\sum_{t=k}^{T-1} \\mathbf{1}\\{s_t \\ne s_{t-1}\\}$。按约定，初始状态为 $s_{k-1}=0$。\n最终利润为 $\\pi = \\text{总毛利润} - \\text{交易成本}$。\n\n**3. 演化动态**\n\n模拟从一个包含 $N$ 个代理的初始种群开始，其基因索引 $(i_k, i_\\tau)$ 使用指定的随机种子从可用范围内均匀独立地抽取。然后，种群演化 $G$ 代。每个世代循环包括评估、选择和繁殖。\n\n- **评估**：计算当前种群中每个代理 $i$ 的利润 $\\pi_i$。然后，使用公式 $f(\\pi_i) = \\pi_i - \\min_j \\pi_j + \\delta$ 计算每个代理的适应度，这确保了所有适应度值都是正的。\n\n- **选择与繁殖**：为下一代构建一个新的种群。\n  - **精英主义**：当前代中表现最好的单个代理（“精英”），由最高适应度确定，保证在新种群中占有一席之地，其基因未经修改地保留下来。\n  - **繁殖**：新种群中剩余的 $N-1$ 个位置由后代填充。对于每个位置：\n    1. 从当前种群中选择两个父代P1和P2。选择是放回抽样，其中选择一个代理的概率与其适应度成正比，即 $p_i = f(\\pi_i) / \\sum_j f(\\pi_j)$。如果所有代理的适应度相等，则使用均匀选择概率 $1/N$。\n    2. 随机抽签决定是否发生交叉。以概率 $p_c$，后代是交叉的产物。实现一个简单的单点交叉：后代从父代P1继承 $k$ 基因，从父代P2继承 $\\tau$ 基因。如果不发生交叉（概率为 $1-p_c$），则后代是父代P1的克隆。\n    3. 然后，新后代的基因会受到突变的影响。每个基因（$k$ 和 $\\tau$）以概率 $\\mu$ 独立突变。如果一个基因被选中进行突变，其当前值将被从其允许集合中（不包括当前值）均匀抽取的新值替换。\n\n- **迭代**：新创建的种群取代旧种群，循环重复 $G$ 代。\n\n**4. 最终输出**\n\n在完成最后一代 $G$ 后，计算这个最终种群中所有代理的利润。这些利润值的最大值就是给定测试案例的结果。对测试套件中的每个参数集重复此整个过程。最终输出是这些最大利润值的列表，格式化为六位小数。",
            "answer": "```python\nimport numpy as np\n\ndef calculate_profit(k, tau, r_series, T, c):\n    \"\"\"\n    Calculates the realized profit for a single agent.\n\n    Args:\n        k (int): Lookback window length.\n        tau (float): Trading threshold.\n        r_series (np.ndarray): The 1-indexed excess log-return series (r_series[t-1] = r_t).\n        T (int): The total number of time steps in the return series.\n        c (float): Per-trade transaction cost.\n\n    Returns:\n        float: The total profit pi for the agent.\n    \"\"\"\n    # Time points for signal calculation are t = k, ..., T-1\n    signal_times = range(k, T)\n    \n    # an array to hold positions s_k, s_{k+1}, ..., s_{T-1}\n    positions = np.zeros(len(signal_times))\n\n    for i, t in enumerate(signal_times):\n        # Moving average m_t is the mean of returns from r_{t-k+1} to r_t.\n        # This corresponds to r_series indices from t-k to t-1.\n        m_signal = np.mean(r_series[t - k : t])\n\n        if m_signal >= tau:\n            positions[i] = 1.0\n        elif m_signal = -tau:\n            positions[i] = -1.0\n        # Otherwise, position remains 0.0\n\n    # Gross profit: sum_{t=k}^{T-1} s_t * r_{t+1}\n    # r_{t+1} corresponds to r_series[t].\n    # The relevant returns are for t = k, ..., T-1, which are r_series[k], ..., r_series[T-1].\n    # But the sum uses r_{t+1}, so for t=T-1, we need r_T. r_series needs to go up to T-1.\n    # The sum is for t in {k, ..., T-1}. So s_t * r_{t+1} uses r_{k+1}, ... r_T.\n    # This corresponds to r_series indices k, ..., T-1.\n    profit_returns = r_series[k : T]\n    gross_profit = np.sum(positions * profit_returns)\n\n    # Transaction costs: c * sum_{t=k}^{T-1} 1{s_t != s_{t-1}}, with s_{k-1}=0.\n    # The lagged positions are s_{k-1}, s_k, ..., s_{T-2}.\n    lagged_positions = np.concatenate(([0.0], positions[:-1]))\n    num_trades = np.sum(positions != lagged_positions)\n    transaction_cost = c * num_trades\n\n    return gross_profit - transaction_cost\n\n\ndef run_evolution(T, N, G, c, mu, p_c, K_max, tau_step, H_max, delta, seed):\n    \"\"\"\n    Runs the full genetic algorithm simulation for one test case.\n    \"\"\"\n    A = 0.01\n    B = 0.0005\n    P = 20\n    \n    rng = np.random.default_rng(seed)\n\n    # Pre-compute the deterministic return series r_t for t=1,...,T\n    t_vals = np.arange(1, T + 1)\n    r_series = A * np.sin(2 * np.pi * t_vals / P) + B * (t_vals / T - 0.5)\n\n    # Define admissible gene sets\n    k_set = np.arange(2, K_max + 1)\n    tau_set = np.arange(0, H_max + 1) * tau_step\n\n    # Initialize population with random gene indices\n    k_indices = rng.integers(0, len(k_set), size=N)\n    tau_indices = rng.integers(0, len(tau_set), size=N)\n    population = np.array([k_indices, tau_indices]).T  # Shape (N, 2)\n\n    for _ in range(G):\n        # 1. Evaluation\n        profits = np.array([\n            calculate_profit(k_set[agent[0]], tau_set[agent[1]], r_series, T, c)\n            for agent in population\n        ])\n\n        # 2. Fitness calculation\n        min_profit = np.min(profits)\n        fitnesses = profits - min_profit + delta\n\n        # 3. Selection and Reproduction\n        new_population = np.zeros_like(population)\n\n        # Elitism: carry over the best agent\n        elite_idx = np.argmax(fitnesses)\n        new_population[0] = population[elite_idx]\n        \n        # Calculate selection probabilities\n        sum_fitness = np.sum(fitnesses)\n        if sum_fitness > 0 and not np.all(fitnesses == fitnesses[0]):\n            probs = fitnesses / sum_fitness\n        else: # All fitnesses equal (or zero)\n            probs = np.full(N, 1.0 / N)\n\n        # Generate N-1 new agents\n        parent_indices = rng.choice(N, size=(N - 1, 2), p=probs, replace=True)\n\n        for i in range(N - 1):\n            p1_idx, p2_idx = parent_indices[i]\n            p1 = population[p1_idx]\n            p2 = population[p2_idx]\n\n            # Crossover\n            if rng.random()  p_c:\n                # One-point crossover: k from p1, tau from p2\n                child = np.array([p1[0], p2[1]])\n            else:\n                # Asexual reproduction (cloning)\n                child = p1.copy()\n\n            # Mutation\n            if rng.random()  mu:\n                # Mutate k gene\n                current_k_idx = child[0]\n                possible_k_indices = list(range(len(k_set)))\n                if len(possible_k_indices) > 1:\n                    possible_k_indices.remove(current_k_idx)\n                    child[0] = rng.choice(possible_k_indices)\n\n            if rng.random()  mu:\n                # Mutate tau gene\n                current_tau_idx = child[1]\n                possible_tau_indices = list(range(len(tau_set)))\n                if len(possible_tau_indices) > 1:\n                    possible_tau_indices.remove(current_tau_idx)\n                    child[1] = rng.choice(possible_tau_indices)\n            \n            new_population[i + 1] = child\n        \n        population = new_population\n\n    # Calculate final profits for the last generation\n    final_profits = np.array([\n        calculate_profit(k_set[agent[0]], tau_set[agent[1]], r_series, T, c)\n        for agent in population\n    ])\n\n    return np.max(final_profits)\n\n\ndef solve():\n    \"\"\"\n    Solves the problem for all test cases and prints the results.\n    \"\"\"\n    test_cases = [\n        # (T, N, G, c, mu, p_c, K_max, tau_step, H_max, delta, seed)\n        (120, 20, 30, 0.0005, 0.1, 0.7, 8, 0.0005, 4, 1e-12, 202405),\n        (120, 20, 30, 0.002, 0.1, 0.7, 8, 0.0005, 4, 1e-12, 202406),\n        (80, 10, 50, 0.0005, 0.0, 0.0, 6, 0.0005, 3, 1e-12, 42),\n    ]\n\n    results = []\n    for params in test_cases:\n        max_profit = run_evolution(*params)\n        results.append(f\"{max_profit:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}