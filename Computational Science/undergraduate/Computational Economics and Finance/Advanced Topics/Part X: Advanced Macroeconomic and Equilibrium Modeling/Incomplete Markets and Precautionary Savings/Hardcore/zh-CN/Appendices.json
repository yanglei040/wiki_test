{
    "hands_on_practices": [
        {
            "introduction": "在构建复杂的动态模型之前，理解其核心的微观经济学构件至关重要。本练习通过一个简化的两期模型，深入剖析了不同的风险偏好设定——具体来说，是风险厌恶程度如何随财富变化——如何导致截然不同的储蓄行为。通过对比恒定相对风险厌恶（CRRA）和恒定绝对风险厌恶（CARA）效用函数下的最优决策，这项练习为理解预防性储蓄模型的理论基石提供了清晰的直觉。",
            "id": "2401175",
            "problem": "考虑一个消费者，他/她面临一个具有不可保险的加性收入风险的不完全市场环境。时间分为两个时期，即初始时期和未来时期。消费者在初始时期获得初始财富 $w \\gt 0$，在未来时期获得随机收入 $y_{1}$。唯一的资产是总回报率为 $R \\gt 0$ 的无风险债券，并且无法获得状态依存证券。消费者在初始时期选择储蓄 $s$ 以最大化期望终生效用，并受跨期预算约束 $c_{0} = w - s$ 和 $c_{1} = R s + y_{1}$ 的限制。\n\n假设偏好满足时间可分的期望效用，贴现因子为 $\\beta \\in (0,1)$，并考虑两种基准效用设定：\n- 恒定相对风险厌恶 (CRRA): $u(c) = \\frac{c^{1-\\gamma}}{1-\\gamma}$，其中 $\\gamma \\gt 0$ 且 $c \\gt 0$。\n- 恒定绝对风险厌恶 (CARA): $u(c) = -\\frac{1}{\\alpha} \\exp(-\\alpha c)$，其中 $\\alpha \\gt 0$ 且 $c \\in \\mathbb{R}$。\n\n假设 $y_{1}$ 与 $s$ 无关，具有有限方差，并且是非退化的。对于在 CARA 下依赖于 $y_{1}$ 分布性质的陈述，额外假设 $y_{1} \\sim \\mathcal{N}(\\mu_{y},\\sigma_{y}^{2})$ 且 $\\sigma_{y}^{2} \\gt 0$。对于在 CRRA 下依赖于定义域限制的陈述，假设 $y_{1}$ 的支撑集为 $[0,\\infty)$，从而最优选择能确保 $c_{1} \\gt 0$。\n\n令最优策略函数为储蓄函数 $s(w)$，相应的消费策略为 $c_{0}(w) = w - s(w)$。仅使用原始定义（偏好、预算约束和内点解的一阶最优性条件），推断最优策略在 CRRA 和 CARA 之间有何不同，以及财富 $w$ 如何通过风险厌恶和审慎影响储蓄决策。\n\n哪些陈述是正确的？\n\nA. 在 CRRA 和加性收入风险下，最优初始消费策略 $c_{0}(w)$ 是 $w$ 的严格凹函数，因此边际消费倾向随 $w$ 递减。在 CARA 和正态分布收入风险下，$c_{0}(w)$ 是 $w$ 的仿射函数，其边际消费倾向与财富无关。\n\nB. 在 CRRA 和加性收入风险下，最优储蓄率 $s(w)/w$ 不随 $w$ 变化。在 CARA 下，由于恒定的绝对审慎，最优储蓄随 $w$ 的增长超过等比例增长。\n\nC. 在 CARA 和正态分布收入风险下，最优储蓄 $s(w)$ 是 $w$ 的仿射函数。与具有相同 $(\\beta,R)$ 和 $\\mathbb{E}[y_{1}]$ 的无风险基准相比，其差值所定义的预防性储蓄部分与 $w$ 无关。\n\nD. 在 CRRA 下，绝对审慎随 $w$ 增加，这意味着在较高的 $w$ 水平时有更强的预防性储蓄动机。\n\nE. 在这个具有加性风险的不完全市场环境中，对于 CRRA 和 CARA，财富的边际消费倾向均不随 $w$ 变化。",
            "solution": "用户希望我验证并解决一个关于 CRRA 和 CARA 效用下预防性储蓄的计算经济学问题。\n\n### 第一步：提取已知条件\n- **模型**：两期消费-储蓄模型（初始时期 $0$，未来时期 $1$）。\n- **禀赋**：初始财富 $w  0$，未来随机收入 $y_1$。\n- **资产**：总回报率为 $R  0$ 的无风险债券。\n- **选择**：储蓄 $s$。\n- **预算约束**：$c_0 = w - s$ (初始消费)，$c_1 = R s + y_1$ (未来消费)。\n- **目标函数**：最大化 $\\mathbb{E}[U] = u(c_0) + \\beta \\mathbb{E}[u(c_1)]$，其中 $\\beta \\in (0,1)$ 是贴现因子。\n- **效用设定**：\n    - 恒定相对风险厌恶 (CRRA): $u(c) = \\frac{c^{1-\\gamma}}{1-\\gamma}$，其中 $\\gamma  0$ 且 $c  0$。\n    - 恒定绝对风险厌恶 (CARA): $u(c) = -\\frac{1}{\\alpha} \\exp(-\\alpha c)$，其中 $\\alpha  0$ 且 $c \\in \\mathbb{R}$。\n- **关于收入风险 $y_1$ 的假设**：\n    - 与储蓄 $s$ 无关。\n    - 具有有限方差且非退化 ($\\sigma_y^2  0$)。\n    - 对于 CARA 相关陈述：$y_1 \\sim \\mathcal{N}(\\mu_y, \\sigma_y^2)$。\n    - 对于 CRRA 相关陈述：$y_1$ 的支撑集为 $[0,\\infty)$，且最优选择确保 $c_1  0$。\n- **策略函数**：最优储蓄 $s(w)$ 和最优初始消费 $c_0(w) = w - s(w)$。\n- **任务**：分析最优策略在 CRRA 和 CARA 效用下有何不同，重点关注财富 $w$、风险厌恶和审慎的作用。\n\n### 第二步：使用提取的已知条件进行验证\n- **科学依据**：该问题描述了一个经典的两期预防性储蓄模型，这是现代宏观经济学和金融学的基本主题。效用函数和约束都是标准的。该模型在经济学理论中具有科学合理性且已被广泛确立。\n- **适定性**：效用函数是严格凹的，选择集是凸的。因此，目标函数是严格凹的，确保储蓄 $s$ 的唯一最优解存在，并由一阶条件刻画（假设为内点解）。该问题是适定的。\n- **客观性**：该问题使用精确的数学语言陈述，定义清晰，没有歧义或主观内容。\n- **其他标准**：该问题是自洽的，没有矛盾，其假设（例如 CARA 下的正态收入）是为了获得解析易处理性而采用的标准假设。\n\n### 第三步：结论与行动\n问题陈述是有效的。我将继续进行解答。\n\n### 推导\n消费者的最优化问题是：\n$$ \\max_{s} \\left\\{ u(w-s) + \\beta \\mathbb{E}[u(Rs + y_1)] \\right\\} $$\n内点解的一阶必要条件 (FOC) 是：\n$$ -u'(w-s) + \\beta \\mathbb{E}[R u'(Rs + y_1)] = 0 $$\n$$ u'(c_0) = \\beta R \\mathbb{E}[u'(c_1)] $$\n代入 $s = w - c_0$，FOC 隐式地定义了最优初始消费 $c_0$ 作为财富 $w$ 的函数：\n$$ u'(c_0) = \\beta R \\mathbb{E}[u'(R(w-c_0) + y_1)] \\quad (*)$$\n\n**CARA 效用分析**\n在 CARA 下，$u(c) = -\\frac{1}{\\alpha} \\exp(-\\alpha c)$，因此边际效用为 $u'(c) = \\exp(-\\alpha c)$。FOC 变为：\n$$ \\exp(-\\alpha c_0) = \\beta R \\mathbb{E}[\\exp(-\\alpha(R(w-c_0) + y_1))] $$\n$$ \\exp(-\\alpha c_0) = \\beta R \\exp(-\\alpha R(w-c_0)) \\mathbb{E}[\\exp(-\\alpha y_1)] $$\n我们假设 $y_1 \\sim \\mathcal{N}(\\mu_y, \\sigma_y^2)$。正态分布的矩生成函数意味着 $\\mathbb{E}[\\exp(-\\alpha y_1)] = \\exp(-\\alpha \\mu_y + \\frac{1}{2}(-\\alpha)^2 \\sigma_y^2) = \\exp(-\\alpha \\mu_y + \\frac{1}{2}\\alpha^2 \\sigma_y^2)$。\n将此代入 FOC：\n$$ \\exp(-\\alpha c_0) = \\beta R \\exp(-\\alpha R w + \\alpha R c_0) \\exp(-\\alpha \\mu_y + \\frac{1}{2}\\alpha^2 \\sigma_y^2) $$\n对两边取自然对数：\n$$ -\\alpha c_0 = \\ln(\\beta R) - \\alpha R w + \\alpha R c_0 - \\alpha \\mu_y + \\frac{1}{2}\\alpha^2 \\sigma_y^2 $$\n求解 $c_0$，我们将包含 $c_0$ 的项归类：\n$$ \\alpha R w - \\ln(\\beta R) + \\alpha \\mu_y - \\frac{1}{2}\\alpha^2 \\sigma_y^2 = c_0 (\\alpha + \\alpha R) = c_0 \\alpha(1+R) $$\n$$ c_0(w) = \\frac{R}{1+R}w + \\frac{\\alpha \\mu_y - \\ln(\\beta R) - \\frac{1}{2}\\alpha^2 \\sigma_y^2}{\\alpha(1+R)} $$\n这是一个关于财富 $w$ 的仿射函数，形式为 $c_0(w) = A w + B$。边际消费倾向 (MPC) 是 $\\frac{dc_0}{dw} = \\frac{R}{1+R}$，这是一个与 $w$ 无关的常数。\n\n最优储蓄函数是 $s(w) = w - c_0(w)$：\n$$ s(w) = w - \\left(\\frac{R}{1+R}w + \\frac{\\alpha \\mu_y - \\ln(\\beta R) - \\frac{1}{2}\\alpha^2 \\sigma_y^2}{\\alpha(1+R)}\\right) $$\n$$ s(w) = \\frac{1}{1+R}w - \\frac{\\alpha \\mu_y - \\ln(\\beta R) - \\frac{1}{2}\\alpha^2 \\sigma_y^2}{\\alpha(1+R)} $$\n因此，$s(w)$ 也是 $w$ 的一个仿射函数。\n\n为了找到预防性储蓄部分，我们将不确定性下的储蓄 $s(w)$ 与无风险基准（即 $y_1$ 被其均值 $\\mu_y$ 替代，也即 $\\sigma_y^2 = 0$）下的储蓄进行比较。令后者为 $s_{cert}(w)$。在 $s(w)$ 的表达式中令 $\\sigma_y^2 = 0$：\n$$ s_{cert}(w) = \\frac{1}{1+R}w - \\frac{\\alpha \\mu_y - \\ln(\\beta R)}{\\alpha(1+R)} $$\n预防性储蓄部分是两者的差：\n$$ s_{prec} = s(w) - s_{cert}(w) = \\left(s_{cert}(w) + \\frac{\\frac{1}{2}\\alpha^2 \\sigma_y^2}{\\alpha(1+R)}\\right) - s_{cert}(w) = \\frac{\\frac{1}{2}\\alpha^2 \\sigma_y^2}{\\alpha(1+R)} = \\frac{\\alpha \\sigma_y^2}{2(1+R)} $$\n这个部分是一个正常数，与财富 $w$ 无关。\n\n**CRRA 效用分析**\n在 CRRA 下，$u(c) = \\frac{c^{1-\\gamma}}{1-\\gamma}$，因此 $u'(c) = c^{-\\gamma}$。FOC 为：\n$$ c_0^{-\\gamma} = \\beta R \\mathbb{E}[(Rs + y_1)^{-\\gamma}] $$\n没有通用的闭式解。我们使用风险厌恶和审慎的概念来分析解的性质。关键系数是绝对风险厌恶 (ARA) $A(c) = -u''(c)/u'(c)$ 和绝对审慎 $P(c) = -u'''(c)/u''(c)$。\n对于 CRRA 效用：\n$u'(c) = c^{-\\gamma}$\n$u''(c) = -\\gamma c^{-\\gamma-1}$\n$u'''(c) = \\gamma(\\gamma+1) c^{-\\gamma-2}$\n所以，ARA 是 $A(c) = \\frac{\\gamma}{c}$，绝对审慎是 $P(c) = \\frac{\\gamma+1}{c}$。\nARA 和绝对审慎都是消费 $c$ 的递减函数。\n\n在预防性储蓄理论中，消费函数 $c_0(w)$ 的形状取决于绝对审慎如何随消费变化。由于 $c_0(w)$ 是财富 $w$ 的增函数，而 $P(c)$ 是消费 $c$ 的减函数，因此绝对审慎 $P(c_0(w))$ 是财富 $w$ 的减函数。\n一个标准结果（例如，Carroll 和 Kimball, 1996）是，如果绝对审慎是递减的，那么消费函数 $c_0(w)$ 是财富 $w$ 的严格凹函数。一个严格凹函数的一阶导数是严格递减的。因此，边际消费倾向 $\\frac{dc_0}{dw}$ 是 $w$ 的严格递减函数。\n\n### 逐项分析\n\n**A. 在 CRRA 和加性收入风险下，最优初始消费策略 $c_{0}(w)$ 是 $w$ 的严格凹函数，因此边际消费倾向随 $w$ 递减。在 CARA 和正态分布收入风险下，$c_{0}(w)$ 是 $w$ 的仿射函数，其边际消费倾向与财富无关。**\n- CRRA 部分是正确的。如上所示，CRRA 效用具有递减的绝对审慎（$P(c) = (\\gamma+1)/c$），这意味着消费函数 $c_0(w)$ 是严格凹的，因此 MPC 随 $w$ 递减。\n- CARA 部分是正确的。我们对 CARA-正态情况的明确推导表明，$c_0(w)$ 是 $w$ 的一个仿射函数，具有等于 $\\frac{R}{1+R}$ 的恒定 MPC。\n- **结论：正确。**\n\n**B. 在 CRRA 和加性收入风险下，最优储蓄率 $s(w)/w$ 不随 $w$ 变化。在 CARA 下，由于恒定的绝对审慎，最优储蓄随 $w$ 的增长超过等比例增长。**\n- CRRA 部分是不正确的。恒定的储蓄率是 CRRA 效用在*乘性*风险下的特性，而不是加性风险。在加性风险下，问题不是齐次的，且如 A 中所示，$c_0(w)$ 是凹的。这意味着 $\\frac{d}{dw}(\\frac{c_0(w)}{w})  0$。由于储蓄率是 $\\frac{s(w)}{w} = 1 - \\frac{c_0(w)}{w}$，其导数为 $\\frac{d}{dw}(\\frac{s(w)}{w}) = - \\frac{d}{dw}(\\frac{c_0(w)}{w})  0$。储蓄率是递增的，而不是恒定的。\n- CARA 部分陈述储蓄“超过等比例增长”，这意味着储蓄率 $s(w)/w$ 是递增的。我们发现 $s(w) = \\frac{1}{1+R}w - K$，其中 $K$ 是某个常数。储蓄率是 $\\frac{s(w)}{w} = \\frac{1}{1+R} - \\frac{K}{w}$。它对 $w$ 的导数是 $\\frac{K}{w^2}$。其符号取决于 $K$ 的符号，而 $K$ 的符号取决于参数，不保证为正。因此，储蓄不一定超过等比例增长。\n- **结论：不正确。**\n\n**C. 在 CARA 和正态分布收入风险下，最优储蓄 $s(w)$ 是 $w$ 的仿射函数。与具有相同 $(\\beta,R)$ 和 $\\mathbb{E}[y_{1}]$ 的无风险基准相比，其差值所定义的预防性储蓄部分与 $w$ 无关。**\n- 第一部分是正确的。我们的推导表明 $s(w) = \\frac{1}{1+R}w + \\text{常数}$，这是 $w$ 的一个仿射函数。\n- 第二部分是正确的。我们的推导表明预防性储蓄部分是 $s_{prec} = \\frac{\\alpha \\sigma_y^2}{2(1+R)}$，这是一个不依赖于财富 $w$ 的常数。\n- **结论：正确。**\n\n**D. 在 CRRA 下，绝对审慎随 $w$ 增加，这意味着在较高的 $w$ 水平时有更强的预防性储蓄动机。**\n- 这是不正确的。对于 CRRA，绝对审慎为 $P(c) = (\\gamma+1)/c$。由于消费 $c_0(w)$ 随财富 $w$ 增加，绝对审慎随 $w$ *递减*。这意味着在较高财富水平下，预防性储蓄动机（相对于消费）*较弱*。该陈述与事实相反。\n- **结论：不正确。**\n\n**E. 在这个具有加性风险的不完全市场环境中，对于 CRRA 和 CARA，财富的边际消费倾向均不随 $w$ 变化。**\n- 这是不正确的。虽然对于 CARA 效用 MPC 是恒定的（无论是否为正态分布），但我们证明了对于 CRRA 效用，MPC 是 $w$ 的严格递减函数。由于该陈述必须对两者都成立，所以是错误的。\n- **结论：不正确。**\n\n根据问题前提的推导，陈述 A 和 C 都是正确的。",
            "answer": "$$\\boxed{AC}$$"
        },
        {
            "introduction": "掌握了理论基础后，我们现在将从一个简化的设定转向一个完整的计算经济模型。本练习将指导你构建并求解一个经典的异质性代理人模型（Aiyagari模型），这是不完全市场研究中的主力模型。通过价值函数迭代法求解家庭的最优储蓄策略，并进一步计算经济的稳态财富分布，你将亲身体验微观的预防性储蓄行为如何汇总成为宏观层面的财富和消费不平等。",
            "id": "2401138",
            "problem": "考虑一个不完全市场经济，其中有无限生命、事前同质的家庭，面临不可保险的异质性劳动收入风险和借贷约束。价格是外生且恒定的。家庭选择储蓄以在预算约束和无借贷约束下最大化预期折现效用。偏好由恒定相对风险厌恶（CRRA）效用函数表示。该环境由以下原始对象和基本定义给出：\n\n- 家庭通过贝尔曼方程求解动态规划问题\n$$\nV(a,y) = \\max_{a' \\in \\mathcal{A}} \\left\\{ u\\big(c\\big) + \\beta \\, \\mathbb{E}\\big[V(a',y') \\mid y\\big] \\right\\}\n$$\n约束条件为\n$$\nc = (1+r)\\,a + w\\,y - a', \\quad c \\ge 0,\\quad a' \\ge a_{\\min},\n$$\n其中 $a$ 是当前资产，$a'$ 是下一期资产，$y$ 是异质性劳动生产率状态，$r$ 是净利率，$w$ 是工资，$\\beta \\in (0,1)$ 是折现因子，$u(c)$ 是时期效用。\n\n- 时期效用函数为 CRRA 形式：\n$$\nu(c) =\n\\begin{cases}\n\\dfrac{c^{1-\\gamma}}{1-\\gamma},  \\gamma \\ne 1, \\\\\n\\log(c),  \\gamma = 1,\n\\end{cases}\n\\quad \\text{其中 } \\gamma  0.\n$$\n\n- 异质性劳动生产率遵循一个有限状态马尔可夫链 $y \\in \\{y_1,\\dots,y_S\\}$，其转移矩阵为 $\\Pi$，其中 $\\Pi_{ij} = \\Pr(y' = y_j \\mid y = y_i)$。\n\n- 联合状态 $(a,y)$ 上的平稳分布是一个在离散化状态空间上的概率向量 $\\mu$，满足\n$$\n\\mu' = \\mu' \\, \\mathcal{T},\n$$\n其中 $\\mathcal{T}$ 是由最优策略函数和收入转移矩阵 $\\Pi$ 导出的转移矩阵。\n\n- 对于具有权重（概率）$w$ 的非负随机变量 $x$，基尼系数由洛伦兹曲线定义。给定一个离散、升序排列的样本 $\\{x_i,w_i\\}_{i=1}^N$，其中 $x_i \\ge 0$，总权重为 $W = \\sum_i w_i$，总质量为 $X = \\sum_i w_i x_i$。令累积权重份额为 $p_i = \\left(\\sum_{j=1}^i w_j\\right)/W$，累积 $x$ 份额为 $L_i = \\left(\\sum_{j=1}^i w_j x_j\\right)/X$。当 $p_0 = 0$ 且 $L_0 = 0$ 时，基尼系数为\n$$\nG = 1 - \\sum_{i=1}^N (p_i - p_{i-1}) \\, (L_i + L_{i-1}).\n$$\n假设 $X  0$。\n\n任务。编写一个程序，对下方的每组参数执行以下步骤：\n\n1. 将资产空间 $\\mathcal{A}$ 在 $a_{\\min}$ 到 $a_{\\max}$ 之间离散化为一个包含 $N_a$ 个点的均匀网格。设定 $a_{\\min} \\ge 0$，以确保资产持有量为非负，且财富的基尼系数有明确定义。\n\n2. 在联合网格 $(a,y)$ 上通过价值函数迭代法求解家庭问题，以获得最优储蓄策略 $a'(a,y)$ 及隐含的消费 $c(a,y)$。从价值函数的初始猜测开始，迭代直至价值函数增量的上确界范数低于一个容差。\n\n3. 构建由最优策略和 $y$ 的外生过程引出的关于 $(a,y)$ 的马尔可夫转移矩阵。通过对分布的运动定律进行迭代直至收敛，来计算平稳分布 $\\mu$。\n\n4. 使用由 $\\mu$ 加权的 $(a,y)$ 上的资产分布计算财富的基尼系数，并使用由 $\\mu$ 加权的 $c(a,y)$ 分布计算消费的基尼系数。\n\n5. 通过报告绝对偏差，将你的模型所隐含的基尼系数与给定的美国经验目标值 $G^{\\text{emp}}_{\\text{wealth}} = 0.78$ 和 $G^{\\text{emp}}_{\\text{cons}} = 0.30$ 进行比较。\n\n使用以下参数集测试套件：\n\n- 案例1（基准风险与耐心）：\n  - $\\beta = 0.96$，$\\gamma = 2.0$，$r = 0.02$，$w = 1.0$，\n  - 收入状态 $y \\in \\{0.6, 1.4\\}$，\n  - 对称持久性 $p = 0.9$，因此\n    $$\n    \\Pi = \\begin{bmatrix}\n    p  1-p \\\\[4pt]\n    1-p  p\n    \\end{bmatrix},\n    $$\n  - 资产：$a_{\\min} = 0$，$a_{\\max} = 40$，$N_a = 200$。\n\n- 案例2（更高的储蓄回报率）：\n  - $\\beta = 0.96$，$\\gamma = 2.0$，$r = 0.04$，$w = 1.0$，\n  - 收入状态 $y \\in \\{0.6, 1.4\\}$，\n  - 对称持久性 $p = 0.9$，$\\Pi$ 如上所示，\n  - 资产：$a_{\\min} = 0$，$a_{\\max} = 40$，$N_a = 200$。\n\n- 案例3（更低的收入持久性）：\n  - $\\beta = 0.96$，$\\gamma = 2.0$，$r = 0.02$，$w = 1.0$，\n  - 收入状态 $y \\in \\{0.6, 1.4\\}$，\n  - 对称持久性 $p = 0.5$，其中\n    $$\n    \\Pi = \\begin{bmatrix}\n    0.5  0.5 \\\\[4pt]\n    0.5  0.5\n    \\end{bmatrix},\n    $$\n  - 资产：$a_{\\min} = 0$，$a_{\\max} = 40$，$N_a = 200$。\n\n你的程序必须按顺序为这三个案例输出以下12个浮点数：\n$$\n\\big[G^{\\text{cons}}_1,\\, G^{\\text{wealth}}_1,\\, |G^{\\text{cons}}_1 - 0.30|,\\, |G^{\\text{wealth}}_1 - 0.78|,\\, G^{\\text{cons}}_2,\\, G^{\\text{wealth}}_2,\\, |G^{\\text{cons}}_2 - 0.30|,\\, |G^{\\text{wealth}}_2 - 0.78|,\\, G^{\\text{cons}}_3,\\, G^{\\text{wealth}}_3,\\, |G^{\\text{cons}}_3 - 0.30|,\\, |G^{\\text{wealth}}_3 - 0.78|\\big],\n$$\n四舍五入到四位小数。\n\n最终输出格式：你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，“[0.3123,0.7456,0.0123,0.0344, ...]”）。不应打印任何额外文本。不允许用户输入。所有量均为无单位量，因此不需要物理单位。不涉及角度。百分比必须表示为小数，而不是使用百分号。",
            "solution": "这个问题是有效的。它提出了一个计算宏观经济学中标准的、适定的练习，具体来说是分析一个带有预防性储蓄的不完全市场模型（一个 Aiyagari-Huggett 模型）。所有参数和定义都是清晰的，并且是该领域内的既定标准。任务是求解家庭的动态规划问题，计算由此产生的财富和消费的平稳分布，并使用基尼系数来衡量这些分布中的不平等程度。\n\n解决方案系统地遵循问题陈述中概述的步骤。\n\n1.  **模型离散化与设定**\n    资产的连续状态变量 $a$ 被离散化为一个有限的均匀网格 $\\mathcal{A} = \\{a_1, \\dots, a_{N_a}\\}$，范围从 $a_{\\min}$ 到 $a_{\\max}$。异质性劳动生产率过程已经是一个具有 $N_y$ 个状态 $y \\in \\{y_1, \\dots, y_{N_y}\\}$ 和一个转移矩阵 $\\Pi$ 的离散有限状态马尔可夫链。因此，一个家庭的完整状态是联合离散空间 $(a, y)$ 中的一个点，该空间有 $N_a \\times N_y$ 个可能的状态。\n\n2.  **价值函数迭代 (VFI)**\n    家庭问题通过价值函数迭代法求解。处于状态 $(a_i, y_k)$ 的家庭的贝尔曼方程为：\n    $$\n    V(a_i, y_k) = \\max_{a_j \\in \\mathcal{A}} \\left\\{ u\\big(c(a_i, y_k, a_j)\\big) + \\beta \\sum_{l=1}^{N_y} \\Pi_{kl} V(a_j, y_l) \\right\\}\n    $$\n    其中消费 $c$ 由预算约束 $c(a_i, y_k, a_j) = (1+r)a_i + w y_k - a_j$ 决定。最大化是在可能的下一期资产持有量的离散集合 $\\{a_1, \\dots, a_{N_a}\\}$ 上进行的。任何导致非正消费（$c \\le 0$）的 $a_j$ 选择都会被赋予一个极低的效用值（例如 $-\\infty$），以确保它永远不会被选中。\n\n    算法从价值函数的一个初始猜测 $V_0$（例如一个零矩阵）开始，并迭代贝尔曼算子：\n    $$\n    V_{t+1}(a_i, y_k) = \\max_{a_j \\in \\mathcal{A}} \\left\\{ u\\big((1+r)a_i + w y_k - a_j\\big) + \\beta \\sum_{l=1}^{N_y} \\Pi_{kl} V_t(a_j, y_l) \\right\\}\n    $$\n    重复此迭代直至价值函数收敛，这是有保证的，因为当 $\\beta \\in (0,1)$ 时，贝尔曼算子是一个压缩映射。当连续价值函数之间的最大绝对差 $\\sup |V_{t+1} - V_t|$ 小于指定的容差时，即宣告收敛。\n\n    为了提高效率，计算被向量化。代表预期未来价值的项 $\\mathbb{E}[V_t(a', y') | y] = \\sum_{l=1}^{N_y} \\Pi_{kl} V_t(a', y_l)$ 对所有 $a'$ 和 $y$ 的组合进行预计算。然后在一个代表所有可能状态下所有可能选择的多维数组上执行最大化。\n\n    收敛后，最优储蓄策略 $a'(a_i, y_k)$ 由对每个状态 $(a_i, y_k)$ 使贝尔曼方程右侧最大化的资产选择 $a_j$ 确定。然后，相应的消费策略 $c(a_i, y_k)$ 从预算约束中计算得出。\n\n3.  **平稳分布**\n    确定性的最优储蓄策略 $a'(a,y)$ 和随机的收入过程 $\\Pi$ 的组合定义了联合状态空间 $(a,y)$ 上的一个马尔可夫链。我们为此过程构建一个大小为 $(N_a N_y) \\times (N_a N_y)$ 的转移矩阵 $\\mathcal{T}$。元素 $\\mathcal{T}_{s,s'}$ 给出了从组合状态 $s=(a_i, y_k)$ 转移到状态 $s'=(a_j, y_l)$ 的概率。仅当策略规定从状态 $(a_i, y_k)$ 选择 $a_j$ 时，此概率才非零，在这种情况下，概率由收入转移概率 $\\Pi_{kl}$ 给出。\n    \n    平稳分布 $\\mu$ 是状态空间上的一个概率向量，它随时间保持不变，满足条件 $\\mu' = \\mu' \\mathcal{T}$，其中向量被视作行向量。该分布使用幂迭代法找到。我们从一个初始猜测 $\\mu_0$（例如，均匀分布）开始，并重复应用转移矩阵 $\\mu_{t+1} = \\mu_t \\mathcal{T}$，直到分布收敛，即 $\\max |\\mu_{t+1} - \\mu_t|$ 小于一个很小的容差。得到的向量 $\\mu$ 给出了一个家庭处于任何给定状态 $(a_i, y_k)$ 的长期概率。\n\n4.  **基尼系数计算**\n    财富和消费的基尼系数是使用平稳分布 $\\mu$ 作为权重计算的。对于一个具有值 $\\{x_i\\}$ 和相应概率 $\\{w_i\\}$ 的变量 $x$，基尼系数根据问题陈述中指定的洛伦兹曲线计算。过程如下：\n    - 根据 $x_i$ 将配对 $(x_i, w_i)$ 按升序排序。\n    - 计算人口（权重）的累积份额 $p_i$ 和变量的累积份额 $L_i$。\n    - 应用公式 $G = 1 - \\sum_{i=1}^N (p_i - p_{i-1}) (L_i + L_{i-1})$。\n\n    对于财富基尼系数，变量 $x$ 是资产网格 $\\mathcal{A}$，权重是资产的边际平稳分布 $\\mu_a(a_i) = \\sum_{k=1}^{N_y} \\mu(a_i, y_k)$。对于消费基尼系数，变量 $x$ 是来自策略函数的消费水平集合 $c(a_i, y_k)$，权重是联合平稳分布概率 $\\mu(a_i, y_k)$。\n\n    最后一步是计算每个参数案例下计算出的基尼系数与所提供的经验目标值之间的绝对偏差，并报告所有结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef gini(x, w):\n    \"\"\"\n    Calculates the Gini coefficient for a discrete distribution.\n    \n    Args:\n        x (np.ndarray): Array of values.\n        w (np.ndarray): Array of corresponding weights (probabilities).\n        \n    Returns:\n        float: The Gini coefficient.\n    \"\"\"\n    # Ensure x and w are flat numpy arrays of the same size\n    x = np.asarray(x).flatten()\n    w = np.asarray(w).flatten()\n\n    # Sort by x values\n    sorted_indices = np.argsort(x)\n    x_sorted = x[sorted_indices]\n    w_sorted = w[sorted_indices]\n\n    # Cumulative weights and value-weighted weights\n    cum_w = np.cumsum(w_sorted)\n    cum_xw = np.cumsum(x_sorted * w_sorted)\n    \n    # Total weight and total value\n    total_w = cum_w[-1]\n    total_xw = cum_xw[-1]\n\n    # Handle case of zero total value (no inequality if total is zero)\n    if total_xw == 0:\n        return 0.0\n\n    # Lorenz curve coordinates (p, L)\n    p = cum_w / total_w\n    L = cum_xw / total_xw\n\n    # Prepend (0,0) to the Lorenz curve points for the summation formula\n    p = np.insert(p, 0, 0)\n    L = np.insert(L, 0, 0)\n\n    # Gini coefficient from the area under the Lorenz curve\n    # The formula given is G = 1 - sum((p_i - p_{i-1}) * (L_i + L_{i-1}))\n    area_sum = np.sum(np.diff(p) * (L[1:] + L[:-1]))\n    \n    return 1.0 - area_sum\n\ndef run_case(params):\n    \"\"\"\n    Solves the household problem for a given set of parameters.\n    \n    Args:\n        params (tuple): A tuple containing all model and grid parameters.\n        \n    Returns:\n        list: A list of floats containing [G_cons, G_wealth, dev_cons, dev_wealth].\n    \"\"\"\n    # Unpack parameters\n    beta, gamma, r, w, y_states, Pi, a_min, a_max, N_a = params\n    \n    # Numerical tolerances and iteration limits\n    vfi_tol = 1e-7\n    vfi_max_iter = 2000\n    dist_tol = 1e-9\n    dist_max_iter = 5000\n\n    # 1. Discretize state space\n    a_grid = np.linspace(a_min, a_max, N_a)\n    y_grid = np.array(y_states)\n    N_y = len(y_grid)\n\n    # 2. Value Function Iteration\n    V = np.zeros((N_a, N_y))\n    \n    # Define CRRA utility function\n    def u(c):\n        # Note: gamma != 1 is handled by problem statement parameters\n        return (c**(1.0 - gamma)) / (1.0 - gamma)\n\n    for i in range(vfi_max_iter):\n        V_old = V.copy()\n\n        # Expected value component E[V(a',y')|y]\n        EV = V @ Pi.T  # shape (N_a, N_y)\n\n        # Vectorized maximization\n        cash_on_hand = (1 + r) * a_grid[:, None] + w * y_grid[None, :]\n        consumption = cash_on_hand[:, :, None] - a_grid[None, None, :]\n\n        # Calculate utility, handling non-positive consumption with a large penalty\n        utility = np.full(consumption.shape, -1e12)\n        mask = consumption > 1e-9 # Avoid numerical issues at c=0\n        utility[mask] = u(consumption[mask])\n\n        # Bellman operator RHS\n        RHS_val = utility + beta * EV.T[None, :, :]\n        \n        V = np.max(RHS_val, axis=2)\n        \n        if np.max(np.abs(V - V_old))  vfi_tol:\n            break\n    \n    # Derive optimal policies from the final value function iteration\n    policy_idx = np.argmax(RHS_val, axis=2)\n    a_prime_policy = a_grid[policy_idx]\n    c_policy = (1 + r) * a_grid[:, None] + w * y_grid[None, :] - a_prime_policy\n\n    # 3. Stationary Distribution\n    N_states = N_a * N_y\n    T = np.zeros((N_states, N_states))\n\n    for i_a in range(N_a):\n        for i_y in range(N_y):\n            s_from = i_a * N_y + i_y\n            j_a_to = policy_idx[i_a, i_y]\n            for j_y_to in range(N_y):\n                s_to = j_a_to * N_y + j_y_to\n                T[s_from, s_to] = Pi[i_y, j_y_to]\n    \n    # Power iteration to find stationary distribution mu\n    mu = np.ones(N_states) / N_states\n    for i in range(dist_max_iter):\n        mu_old = mu\n        mu = mu @ T\n        if np.max(np.abs(mu - mu_old))  dist_tol:\n            break\n            \n    # 4. Gini coefficients\n    # Wealth Gini\n    mu_reshaped = mu.reshape((N_a, N_y))\n    marginal_mu_a = mu_reshaped.sum(axis=1)\n    gini_wealth = gini(a_grid, marginal_mu_a)\n    \n    # Consumption Gini\n    gini_consumption = gini(c_policy.flatten(), mu)\n    \n    # 5. Report deviations from empirical targets\n    G_emp_cons = 0.30\n    G_emp_wealth = 0.78\n    \n    dev_cons = abs(gini_consumption - G_emp_cons)\n    dev_wealth = abs(gini_wealth - G_emp_wealth)\n\n    return [gini_consumption, gini_wealth, dev_cons, dev_wealth]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Case 1: baseline\n    p1 = 0.9\n    pi1 = np.array([[p1, 1 - p1], [1 - p1, p1]])\n    case1 = (0.96, 2.0, 0.02, 1.0, [0.6, 1.4], pi1, 0.0, 40.0, 200)\n\n    # Case 2: higher interest rate\n    p2 = 0.9\n    pi2 = np.array([[p2, 1 - p2], [1 - p2, p2]])\n    case2 = (0.96, 2.0, 0.04, 1.0, [0.6, 1.4], pi2, 0.0, 40.0, 200)\n\n    # Case 3: lower income persistence\n    p3 = 0.5\n    pi3 = np.array([[p3, 1-p3], [1-p3, p3]])\n    case3 = (0.96, 2.0, 0.02, 1.0, [0.6, 1.4], pi3, 0.0, 40.0, 200)\n    \n    test_cases = [case1, case2, case3]\n\n    all_results = []\n    for case in test_cases:\n        results = run_case(case)\n        all_results.extend(results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{x:.4f}' for x in all_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "虽然稳态分析为我们提供了重要的长期基准，但真实的经济体总是在不断演变。这最后一个练习将挑战你模拟当经济遭遇一次未预料到的、永久性的收入风险冲击后，其总资产和财富分布的动态调整路径。这项实践不仅能让你掌握分析非均衡动态的高级技能，还能让你理解模型如何被用于研究经济对新情况的适应速度，这对于政策评估和理解经济波动至关重要。",
            "id": "2401170",
            "problem": "考虑一个具有不完全市场和单一无风险资产的无限期异质性代理人禀赋经济。时间是离散的。一个代表性家庭（代表每个事前同质的家庭）求解一个动态规划问题，其偏好为恒定相对风险厌恶类型，并面临特质性、不可保险的马尔可夫劳动收入。由于市场不完全，每个家庭只能通过预防性储蓄进行自我保险，并受到借贷额度的限制。不存在总体冲击，利率被外生固定。\n\n家庭求解以下问题：选择一个储蓄策略以最大化预期终生效用\n$$\n\\max_{\\{a_{t+1}\\}_{t \\ge 0}} \\ \\mathbb{E}_0 \\sum_{t=0}^{\\infty} \\beta^t \\, u(c_t),\n$$\n受制于每期的预算约束\n$$\nc_t + a_{t+1} = R a_t + y_t,\n$$\n以及借贷约束\n$$\na_{t+1} \\ge \\underline{a},\n$$\n其中 $a_t$ 是第 $t$ 期初的资产，$c_t$ 是消费，$y_t$ 是特质性劳动收入，$\\beta \\in (0,1)$ 是主观贴现因子，$R = 1 + r$ 是无风险总回报率，其中 $r \\ge 0$，$\\underline{a}$ 是借贷限额。偏好由恒定相对风险厌恶（CRRA）效用函数给出\n$$\nu(c) =\n\\begin{cases}\n\\dfrac{c^{1-\\sigma}}{1-\\sigma},  \\text{if } \\sigma \\ne 1,\\\\\n\\log(c),  \\text{if } \\sigma = 1,\n\\end{cases}\n$$\n其中相对风险厌恶系数 $\\sigma  0$。收入 $y_t$ 遵循一个双状态马尔可夫链，状态空间为 $\\{y_L,y_H\\}$，转移矩阵为\n$$\n\\Pi =\n\\begin{bmatrix}\n\\pi_{LL}  \\pi_{LH} \\\\\n\\pi_{HL}  \\pi_{HH}\n\\end{bmatrix},\n$$\n其中 $\\pi_{ij} = \\mathbb{P}(y_{t+1}=y_j \\mid y_t=y_i)$，并且通过构造，收入的平稳均值等于 $1$。\n\n该动态规划问题可以写成价值函数 $V(a,y)$ 的贝尔曼形式：\n$$\nV(a,y) = \\max_{a' \\in [\\underline{a},\\bar{a}]} \\left\\{ u(Ra + y - a') + \\beta \\sum_{y' \\in \\{y_L,y_H\\}} \\Pi(y,y') \\, V(a',y') \\right\\},\n$$\n其中 $a' \\equiv a_{t+1}$，数值资产网格为 $a \\in \\mathcal{A} = \\{\\underline{a},\\ldots,\\bar{a}\\}$，$\\bar{a}$ 是一个足够大的上界。\n\n在时间 $t=0$ 时，发生了一次意料之外的、永久性的收入风险增加：在 $t=0$ 之前，收入取值于 $\\{y_L^{\\text{pre}}, y_H^{\\text{pre}}\\}$，转移矩阵为 $\\Pi^{\\text{pre}}$；在 $t=0$ 时，该过程切换到 $\\{y_L^{\\text{post}}, y_H^{\\text{post}}\\}$，转移矩阵为 $\\Pi^{\\text{post}}$，并永久保持不变。两种机制下收入的均值都保持为 $1$，但冲击后方差更高。价格 $R$ 在整个过程中保持不变。\n\n你的任务是：\n\n- 计算冲击前环境下的最优策略 $a'(a,y)$ 和平稳横截面分布 $\\mu^{\\text{pre}}$。\n- 计算冲击后环境下的最优策略 $a'(a,y)$ 和平稳横截面分布 $\\mu^{\\text{post}}$。\n- 模拟意外冲击后横截面分布的转移动态：在 $t=0$ 时将分布初始化为 $\\mu^{\\text{pre}}$，然后使用冲击后的运动定律向前演化，得到在冲击后策略和转移矩阵下的 $\\{\\mu_t\\}_{t \\ge 0}$。\n- 追踪总体（横截面）平均资产 $A_t = \\sum_{(a,y)} a \\, \\mu_t(a,y)$ 随时间的变化，并计算首次满足 $|A_t - A^{\\text{post}}| \\le \\varepsilon$ 的时间 $T$，其中 $A^{\\text{post}}$ 是冲击后环境下的平稳平均资产，$\\varepsilon$ 是一个容差。\n\n你必须使用的基础理论：\n\n- 动态规划的贝尔曼最优性原理。\n- 马尔可夫链的定义和迭代期望定律。\n- 风险厌恶偏好的效用函数凹性，以及预防性储蓄动机的审慎性定义（你可以引用 $u'''(c)  0$ 作为在存在不可保险风险和借贷约束下预防性储蓄的充分条件）。\n- 马尔可夫链平稳分布的定义，即其是前向算子的不动点。\n\n数值方法约束：\n\n- 在 $\\underline{a}$ 和 $\\bar{a}$ 之间使用均匀网格对资产空间 $\\mathcal{A}$ 进行离散化。\n- 使用价值函数迭代法计算 $V(a,y)$ 和导出策略 $a'(a,y)$，方法是在 $\\mathcal{A}$ 上离散化选择并强制 $c \\ge 0$。\n- 根据最优策略和外生收入转移，构建联合状态空间 $\\mathcal{S} = \\mathcal{A} \\times \\{y_L,y_H\\}$ 上的内生马尔可夫转移矩阵。\n- 通过对横截面分布进行前向迭代直至收敛来计算平稳分布。\n- 从 $\\mu^{\\text{pre}}$ 开始，在冲击后的转移矩阵下进行前向迭代，以模拟转移动态。\n- 所有状态概率必须为非负，并且在机器精度下其总和应为 $1$。\n\n你的程序不应接受任何输入，并且必须为以下参数化测试集计算结果。在所有情况下，设置总回报率为 $R = 1 + r$，在 $[\\underline{a}, \\bar{a}]$ 上使用 $N_a$ 个点的均匀网格离散化资产，并在一个测试用例的冲击前和冲击后计算中使用相同的 $\\bar{a}$。\n\n测试集（三种情况）：\n\n- 情况1（标准情形，冲击后风险增强）：\n  - $\\beta = 0.96$, $r = 0.02$ (因此 $R = 1.02$), $\\sigma = 2.0$, $\\underline{a} = 0.0$, $\\bar{a} = 50.0$, $N_a = 151$。\n  - 冲击前收入： $(y_L^{\\text{pre}}, y_H^{\\text{pre}}) = (0.8, 1.2)$，转移矩阵为\n    $$\n    \\Pi^{\\text{pre}} =\n    \\begin{bmatrix}\n    0.9  0.1\\\\\n    0.1  0.9\n    \\end{bmatrix}.\n    $$\n  - 冲击后收入： $(y_L^{\\text{post}}, y_H^{\\text{post}}) = (0.6, 1.4)$，使用相同的转移矩阵\n    $$\n    \\Pi^{\\text{post}} = \\Pi^{\\text{pre}}.\n    $$\n  - 转移动态模拟容差 $\\varepsilon = 10^{-6}$，最大模拟期数 $T_{\\max} = 5000$。\n\n- 情况2（冲击后风险无变化；一致性检验）：\n  - 参数与情况1相同，但冲击后收入等于冲击前收入，即 $(y_L^{\\text{post}}, y_H^{\\text{post}}) = (0.8, 1.2)$ 且 $\\Pi^{\\text{post}} = \\Pi^{\\text{pre}}$。\n  - 使用与情况1相同的 $\\varepsilon$ 和 $T_{\\max}$。\n\n- 情况3（对数效用，冲击后风险增强）：\n  - $\\beta = 0.96$, $r = 0.02$ (因此 $R = 1.02$), $\\sigma = 1.0$, $\\underline{a} = 0.0$, $\\bar{a} = 50.0$, $N_a = 151$。\n  - 冲击前收入： $(y_L^{\\text{pre}}, y_H^{\\text{pre}}) = (0.85, 1.15)$，转移矩阵为\n    $$\n    \\Pi^{\\text{pre}} =\n    \\begin{bmatrix}\n    0.9  0.1\\\\\n    0.1  0.9\n    \\end{bmatrix}.\n    $$\n  - 冲击后收入： $(y_L^{\\text{post}}, y_H^{\\text{post}}) = (0.65, 1.35)$，且 $\\Pi^{\\text{post}} = \\Pi^{\\text{pre}}$。\n  - 转移动态模拟容差 $\\varepsilon = 10^{-6}$，最大模拟期数 $T_{\\max} = 5000$。\n\n对于每个测试用例，你的程序必须计算并返回以下四个量：\n\n- $A^{\\text{pre}}$：冲击前环境下的平稳平均资产。\n- $A^{\\text{post}}$：冲击后环境下的平稳平均资产。\n- $T$：从 $\\mu^{\\text{pre}}$ 开始并在冲击后转移下演化时，使得 $|A_t - A^{\\text{post}}| \\le \\varepsilon$ 的最小非负整数 $t$；如果不存在这样的 $t \\le T_{\\max}$，则返回 $T_{\\max}$。\n- $\\Delta A_1$：一步冲击响应，定义为 $A_1 - A_0$，其中 $A_0 = A^{\\text{pre}}$，$A_1$ 是在冲击后转移下进行一次前向迭代后的平均资产。\n\n最终输出格式：\n\n- 你的程序应生成单行输出，包含一个逗号分隔的列表，列表中的每个元素是对应测试用例的结果，每个用例的结果本身是一个列表，顺序为 $[A^{\\text{pre}}, A^{\\text{post}}, T, \\Delta A_1]$。\n- 因此，总输出必须看起来像\n  $$\n  \\big[ [A^{\\text{pre}}_1, A^{\\text{post}}_1, T_1, \\Delta A_{1,1}], [A^{\\text{pre}}_2, A^{\\text{post}}_2, T_2, \\Delta A_{1,2}], [A^{\\text{pre}}_3, A^{\\text{post}}_3, T_3, \\Delta A_{1,3}] \\big]\n  $$\n  作为单行。将 $A^{\\text{pre}}$、$A^{\\text{post}}$ 和 $\\Delta A_1$ 打印为十进制浮点数，$T$ 打印为整数。在打印输出中将浮点数四舍五入到 $6$ 位小数。",
            "solution": "问题陈述经过验证，被认为是有效的。这是一个定义明确、具有科学基础的计算宏观经济学问题，具体来说是一个标准的异质性代理人不完全市场模型（Bewley-Aiyagari模型）。所有参数、函数形式和数值约束都足够精确，可以得到一个唯一的、可计算的解。所提供的参数化，如 $\\beta=0.96$ 和 $R=1.02$，满足标准条件 $\\beta R  1$，这确保了家庭足够不耐烦，以防止资产无限积累。收入过程被正确设定为具有平稳均值 $1$。这些任务在计算上是可行的，并测试了一个标准的经济实验：总储蓄对特质性收入风险增加的响应。\n\n该解决方案通过实施问题陈述中概述的数值方法来推进。这涉及三个主要阶段：首先，使用价值函数迭代求解最优家庭策略；其次，使用该策略构建状态空间上的马尔可夫转移算子，并找到相应的平稳横截面分布；第三，在收入风险发生意外冲击后，模拟经济从一个初始平稳状态到新状态的过渡。\n\n**1. 价值函数迭代与最优策略**\n\n家庭的问题被设定为一个动态规划问题，由每个收入状态 $y \\in \\{y_L, y_H\\}$ 的贝尔曼方程概括：\n$$\nV(a,y) = \\max_{a'} \\left\\{ u(Ra + y - a') + \\beta \\mathbb{E}[V(a',y') \\mid y] \\right\\}\n$$\n受限于借贷约束 $a' \\ge \\underline{a}$ 和消费非负性 $c = Ra + y - a' \\ge 0$。期望是针对下一期收入 $y'$ 计算的，由转移矩阵 $\\Pi$ 给出。\n\n为了数值求解这个问题，我们首先将资产空间离散化为一个从 $\\underline{a}$到 $\\bar{a}$ 的大小为 $N_a$ 的均匀网格 $\\mathcal{A} = \\{a_1, a_2, \\ldots, a_{N_a}\\}$。因此，一个家庭的状态是一对 $(a_i, y_j) \\in \\mathcal{A} \\times \\{y_L, y_H\\}$。我们旨在找到所有状态的价值函数 $V(a_i, y_j)$。\n\n我们采用价值函数迭代（VFI），由于贝尔曼算子是一个压缩映射，它保证能收敛到唯一的真实价值函数。迭代过程如下：\n- 初始化价值函数，例如，对所有状态 $V^0(a, y) = 0$。\n- 对每次迭代 $k = 0, 1, 2, \\ldots$:\n    1. 计算每个可能的下一期状态 $(a', y)$ 的条件期望延续价值：\n       $$\n       \\mathbb{E}[V^k(a',y') \\mid y] = \\sum_{y' \\in \\{y_L,y_H\\}} \\Pi(y,y') V^k(a',y')\n       $$\n    2. 对于每个当前状态 $(a, y)$，求解贝尔曼方程右侧的最大化问题。下一期资产 $a'$ 的选择被限制在离散网格 $\\mathcal{A}$ 上。\n       $$\n       V^{k+1}(a,y) = \\max_{a' \\in \\mathcal{A}, a' \\le Ra+y} \\left\\{ u(Ra + y - a') + \\beta \\mathbb{E}[V^k(a',y') \\mid y] \\right\\}\n       $$\n       约束 $a' \\le Ra+y$ 确保消费为非负。\n    3. 当价值函数收敛时，即连续两次迭代之间的最大绝对差小于一个很小的容差 $\\delta_V$ 时，迭代停止：$\\sup_{a,y} |V^{k+1}(a,y) - V^k(a,y)|  \\delta_V$。\n\nVFI算法的输出是收敛的价值函数 $V(a,y)$ 和相关的最优策略函数（或运动定律）$a'(a,y)$，它将每个状态 $(a,y)$ 映射到下一期资产的最优选择。由于选择是离散化的，$a'(a,y)$ 将是网格 $\\mathcal{A}$ 上的一个点。\n\n**2. 平稳分布**\n\n外生收入转移 $\\Pi$ 和内生资产选择策略函数 $a'(a,y)$ 的组合，在联合离散状态空间 $\\mathcal{S} = \\mathcal{A} \\times \\{y_L, y_H\\}$ 上定义了一个马尔可夫过程。设该空间的大小为 $N_s = N_a \\times 2$。我们构建一个 $N_s \\times N_s$ 的转移概率矩阵 $\\mathbf{P}$。\n\n该矩阵的一个元素 $\\mathbf{P}_{ij}$ 给出了从状态 $i$ 转移到状态 $j$ 的一期概率。设状态 $i$ 对应于 $(a_k, y_m)$，状态 $j$ 对应于 $(a_l, y_n)$。给定策略 $a'(a_k, y_m) = a_p$（其中 $a_p$ 是资产网格上的某个点），代理人以确定性转移到资产水平 $a_p$。下一期的收入状态将是 $y_n$，概率为 $\\Pi_{mn}$。因此，只有当目标资产水平 $a_l$ 与策略决定的水平 $a_p$ 匹配时，转移概率才非零。\n$$\n\\mathbf{P}((a_k, y_m) \\to (a_l, y_n)) =\n\\begin{cases}\n\\Pi_{mn}  \\text{if } a_l = a'(a_k, y_m) \\\\\n0  \\text{otherwise}\n\\end{cases}\n$$\n状态空间 $\\mathcal{S}$ 上的平稳分布 $\\mu$ 是该马尔可夫过程的不变分布。它代表了家庭在资产和收入上的长期横截面分布。它是定点问题 $\\mu \\mathbf{P} = \\mu$ 的解，其中 $\\mu$ 是一个概率行向量，其元素之和为 $1$。我们通过前向迭代计算 $\\mu$：从任意初始分布 $\\mu_0$（例如，均匀分布）开始，我们重复应用转移矩阵 $\\mu_{t+1} = \\mu_t \\mathbf{P}$ 直到分布收敛，即对于一个很小的容差 $\\delta_{\\mu}$，有 $\\|\\mu_{t+1} - \\mu_t\\|_{\\infty}  \\delta_{\\mu}$。\n\n**3. 冲击的模拟**\n\n该实验涉及一次意料之外的、永久性的收入风险增加。对每个测试用例，这分三步进行分析：\n\n- **冲击前稳态：** 首先，我们使用冲击前的收入过程 $(\\{y_L^{\\text{pre}}, y_H^{\\text{pre}}\\}, \\Pi^{\\text{pre}})$ 求解最优策略 $a'_{\\text{pre}}(a,y)$ 和平稳分布 $\\mu^{\\text{pre}}$。从 $\\mu^{\\text{pre}}$，我们计算冲击前平稳均衡中的总体（平均）资产：\n  $$\n  A^{\\text{pre}} = \\sum_{(a,y) \\in \\mathcal{S}} a \\cdot \\mu^{\\text{pre}}(a,y)\n  $$\n\n- **冲击后稳态：** 其次，我们对冲击后环境 $(\\{y_L^{\\text{post}}, y_H^{\\text{post}}\\}, \\Pi^{\\text{post}})$ 重复整个过程。这产生了冲击后的策略 $a'_{\\text{post}}(a,y)$、转移矩阵 $\\mathbf{P}_{\\text{post}}$、平稳分布 $\\mu^{\\text{post}}$ 和平稳总体资产：\n  $$\n  A^{\\text{post}} = \\sum_{(a,y) \\in \\mathcal{S}} a \\cdot \\mu^{\\text{post}}(a,y)\n  $$\n  收入风险（方差）的增加，同时均值保持不变，加上审慎的偏好（$u'''  0$），导致了更强的预防性储蓄动机。因此，当冲击后风险更高时，我们预期 $A^{\\text{post}}  A^{\\text{pre}}$。\n\n- **转移动态：** 第三，我们模拟经济的总资产从冲击前稳态到冲击后稳态的过渡路径。在时间 $t=0$ 时，经济处于冲击前稳态，因此初始分布为 $\\mu_0 = \\mu^{\\text{pre}}$，初始平均资产为 $A_0 = A^{\\text{pre}}$。从 $t=0$ 开始，家庭应用新的、最优的冲击后策略 $a'_{\\text{post}}$，经济根据冲击后的转移矩阵 $\\mathbf{P}_{\\text{post}}$ 演化。任何时间 $t+1$ 的分布由 $\\mu_{t+1} = \\mu_t \\mathbf{P}_{\\text{post}}$ 给出。我们追踪总资产序列 $\\{A_t\\}_{t \\ge 0}$，其中 $A_t = \\sum a \\cdot \\mu_t(a,y)$。\n\n我们从这个模拟中计算两个量：\n1.  收敛时间 $T$，定义为总资产水平与新稳态值的差距在容差 $\\varepsilon$ 内的第一个非负整数时间 $t$：\n    $$\n    T = \\min \\{ t \\ge 0 \\mid |A_t - A^{\\text{post}}| \\le \\varepsilon \\}\n    $$\n    如果在 $T_{\\max}$ 内未满足此条件，我们报告 $T=T_{\\max}$。检查从 $t=0$ 开始。\n2.  一步冲击响应 $\\Delta A_1$，定义为冲击后第一期总资产的变化：\n    $$\n    \\Delta A_1 = A_1 - A_0\n    $$\n    其中 $A_1$ 由 $\\mu_1 = \\mu_0 \\mathbf{P}_{\\text{post}}$ 计算得出。这个量衡量了对激励变化的即时总体响应。\n\n整个过程应用于问题陈述中指定的三个测试用例中的每一个。然后按要求格式化结果。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    \"\"\"\n\n    def get_utility(c, sigma):\n        \"\"\"Computes CRRA utility, handling non-positive consumption.\"\"\"\n        utility = np.full_like(c, -np.inf, dtype=np.float64)\n        positive_c = c > 1e-9 # A small tolerance for positivity\n        if sigma == 1.0:\n            utility[positive_c] = np.log(c[positive_c])\n        else:\n            utility[positive_c] = (c[positive_c]**(1 - sigma)) / (1 - sigma)\n        return utility\n\n    def value_function_iteration(asset_grid, y, Pi, beta, R, sigma, tol=1e-8, max_iter=2000):\n        \"\"\"\n        Solves the household's dynamic programming problem using value function iteration.\n        \"\"\"\n        Na = len(asset_grid)\n        Ny = len(y)\n        V = np.zeros((Na, Ny))\n        policy_idx = np.zeros((Na, Ny), dtype=int)\n\n        for it in range(max_iter):\n            V_new = np.zeros_like(V)\n            # Expected continuation value: E[V] = beta * V * Pi^T\n            continuation_V = beta * V @ Pi.T\n\n            # For each state (a, y), find optimal a'\n            for i_a in range(Na):\n                for i_y in range(Ny):\n                    cash_on_hand = R * asset_grid[i_a] + y[i_y]\n                    \n                    # Available consumption for each choice of a'\n                    consumption = cash_on_hand - asset_grid\n                    \n                    # Current-period utility for each choice of a'\n                    utility = get_utility(consumption, sigma)\n\n                    # Total value for each choice of a'\n                    value_choices = utility + continuation_V[:, i_y]\n                    \n                    # Find optimal choice and value\n                    best_idx = np.argmax(value_choices)\n                    V_new[i_a, i_y] = value_choices[best_idx]\n                    policy_idx[i_a, i_y] = best_idx\n\n            diff = np.max(np.abs(V - V_new))\n            V = V_new\n            if diff  tol:\n                break\n        \n        return V, policy_idx\n\n    def build_transition_matrix(policy_idx, Pi, Na, Ny):\n        \"\"\"\n        Constructs the full Markov transition matrix over the joint state space.\n        \"\"\"\n        Ns = Na * Ny\n        P = np.zeros((Ns, Ns))\n        \n        for i_a in range(Na):      # Current asset index\n            for i_y in range(Ny):  # Current income index\n                current_state_idx = i_a + i_y * Na\n                next_a_idx = policy_idx[i_a, i_y]\n\n                for j_y in range(Ny): # Next income index\n                    next_state_idx = next_a_idx + j_y * Na\n                    prob = Pi[i_y, j_y]\n                    P[current_state_idx, next_state_idx] = prob\n        return P\n\n    def compute_stationary_distribution(P, tol=1e-10, max_iter=10000):\n        \"\"\"\n        Computes the stationary distribution by forward iteration (power method).\n        \"\"\"\n        Ns = P.shape[0]\n        mu = np.ones(Ns) / Ns  # Start with uniform distribution\n\n        for _ in range(max_iter):\n            mu_new = mu @ P\n            if np.max(np.abs(mu_new - mu))  tol:\n                break\n            mu = mu_new\n        \n        # Ensure it's a valid probability distribution\n        mu /= np.sum(mu)\n        return mu\n\n    def solve_one_case(params):\n        \"\"\"\n        Solves for one complete test case.\n        \"\"\"\n        beta, r, sigma, a_underline, a_bar, Na, y_pre, Pi_pre, y_post, Pi_post, epsilon, T_max = params\n        R = 1 + r\n\n        # Common asset grid and state vector\n        asset_grid = np.linspace(a_underline, a_bar, Na)\n        asset_state_vector = np.tile(asset_grid, 2) # For [a_grid_yL, a_grid_yH]\n\n        # --- Pre-shock analysis ---\n        _, policy_pre = value_function_iteration(asset_grid, y_pre, Pi_pre, beta, R, sigma)\n        P_pre = build_transition_matrix(policy_pre, Pi_pre, Na, 2)\n        mu_pre = compute_stationary_distribution(P_pre)\n        A_pre = np.dot(mu_pre, asset_state_vector)\n\n        # --- Post-shock analysis ---\n        _, policy_post = value_function_iteration(asset_grid, y_post, Pi_post, beta, R, sigma)\n        P_post = build_transition_matrix(policy_post, Pi_post, Na, 2)\n        mu_post = compute_stationary_distribution(P_post)\n        A_post = np.dot(mu_post, asset_state_vector)\n\n        # --- Transition dynamics ---\n        mu_0 = mu_pre\n        A_0 = A_pre\n        \n        # Calculate T\n        T = T_max\n        if np.abs(A_0 - A_post) = epsilon:\n            T = 0\n        else:\n            mu_t = mu_0\n            for t in range(T_max):\n                mu_t = mu_t @ P_post\n                A_t = np.dot(mu_t, asset_state_vector)\n                if np.abs(A_t - A_post) = epsilon:\n                    T = t + 1\n                    break\n        \n        # Calculate Delta A_1\n        mu_1 = mu_0 @ P_post\n        A_1 = np.dot(mu_1, asset_state_vector)\n        delta_A_1 = A_1 - A_0\n\n        return [\n            round(A_pre, 6),\n            round(A_post, 6),\n            T,\n            round(delta_A_1, 6)\n        ]\n\n    # Test suite parameters\n    common_params_case12 = {\n        'beta': 0.96, 'r': 0.02, 'a_underline': 0.0, 'a_bar': 50.0,\n        'Na': 151, 'epsilon': 1e-6, 'T_max': 5000\n    }\n    Pi_matrix = np.array([[0.9, 0.1], [0.1, 0.9]])\n\n    test_cases = [\n        # Case 1: Happy path, stronger risk\n        (\n            common_params_case12['beta'], common_params_case12['r'], 2.0,\n            common_params_case12['a_underline'], common_params_case12['a_bar'], common_params_case12['Na'],\n            np.array([0.8, 1.2]), Pi_matrix,\n            np.array([0.6, 1.4]), Pi_matrix,\n            common_params_case12['epsilon'], common_params_case12['T_max']\n        ),\n        # Case 2: Consistency check, no change\n        (\n            common_params_case12['beta'], common_params_case12['r'], 2.0,\n            common_params_case12['a_underline'], common_params_case12['a_bar'], common_params_case12['Na'],\n            np.array([0.8, 1.2]), Pi_matrix,\n            np.array([0.8, 1.2]), Pi_matrix, # Post = Pre\n            common_params_case12['epsilon'], common_params_case12['T_max']\n        ),\n        # Case 3: Log utility, stronger risk\n        (\n            common_params_case12['beta'], common_params_case12['r'], 1.0,\n            common_params_case12['a_underline'], common_params_case12['a_bar'], common_params_case12['Na'],\n            np.array([0.85, 1.15]), Pi_matrix,\n            np.array([0.65, 1.35]), Pi_matrix,\n            common_params_case12['epsilon'], common_params_case12['T_max']\n        ),\n    ]\n\n    results = [solve_one_case(case) for case in test_cases]\n    \n    # Format a list of lists into the required string representation\n    result_str = '[' + ','.join([f\"[{r[0]},{r[1]},{r[2]},{r[3]}]\" for r in results]) + ']'\n    print(result_str)\n\nsolve()\n```"
        }
    ]
}