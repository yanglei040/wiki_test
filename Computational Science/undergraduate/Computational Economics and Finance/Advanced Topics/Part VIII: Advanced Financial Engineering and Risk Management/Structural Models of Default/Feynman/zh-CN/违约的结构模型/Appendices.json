{
    "hands_on_practices": [
        {
            "introduction": "默顿模型（Merton model）在公司资产价值与其违约风险之间建立了优美的理论联系。然而，将其付诸实践需要在理论与现实之间架起桥梁，而这始于一个关键参数：违约壁垒 $F$。本练习  将挑战你探索如何使用从真实世界资产负债表数据中得出的不同且合理的 $F$ 定义，并分析这些定义对计算出的违约概率的显著影响，从而突显出模型实施中批判性假设的重要性。",
            "id": "2435090",
            "problem": "考虑一家公司，其总资产价值过程 $\\{V_t\\}_{t \\in [0,T]}$ 在风险中性测度下服从几何布朗运动，满足随机微分方程 $\\mathrm{d}V_t = (r - q) V_t \\, \\mathrm{d}t + \\sigma V_t \\, \\mathrm{d}W_t$，其中 $V_0 > 0$ 为已知，$r \\ge 0$ 是连续复利无风险利率，$q \\ge 0$ 是资产的连续派发收益率，$\\sigma > 0$ 是资产波动率，$T > 0$ 是时间范围（以年为单位）。在 Merton 的结构化违约模型中，当且仅当 $V_T < F$ 时发生违约，其中 $F > 0$ 是一个与公司债务相关的、类似面值的违约阈值。\n\n您的任务是，针对几组参数集，在定义 $F$ 的不同常见启发式方法下，计算在时间范围 $T$ 内的风险中性违约概率，并量化计算出的违约概率对启发式方法选择的敏感性。对于每个参数集，您将获得以下输入：$V_0$、$\\sigma$、 $r$、 $q$、 $T$、短期（流动）带息债务 $D_S$、长期带息债务 $D_L$、总负债 $L$ 以及现金及等价物 $C$。您必须评估以下四种关于 $F$ 的启发式方法：\n\n- 启发式方法 $\\mathrm{H1}$（一半长期债务）：$F_1 = D_S + 0.5 \\, D_L$。\n- 启发式方法 $\\mathrm{H2}$（所有带息债务）：$F_2 = D_S + D_L$。\n- 启发式方法 $\\mathrm{H3}$（总负债）：$F_3 = L$。\n- 启发式方法 $\\mathrm{H4}$（有底线的净债务）：$F_4 = \\max\\{ D_S + D_L - C, \\, 1 \\}$，其中底线值 $1$ 确保严格为正。\n\n对于每种启发式方法 $\\mathrm{Hi}$，计算模型所隐含的风险中性违约概率 $p_i = \\mathbb{Q}(V_T < F_i)$。然后根据这四个 $p_i$ 值计算以下敏感性指标：\n- 绝对范围 $R_{\\mathrm{abs}} = \\max_i p_i - \\min_i p_i$。\n- 相对范围 $R_{\\mathrm{rel}} = R_{\\mathrm{abs}} / \\overline{p}$，其中 $\\overline{p}$ 是 $\\{p_1, p_2, p_3, p_4\\}$ 的算术平均值。\n\n所有概率和敏感性指标必须以小数形式表示（而非百分比）。\n\n使用以下参数集测试套件。每个测试用例是一个元组 $(V_0,\\sigma,r,q,T,D_S,D_L,L,C)$:\n\n- 案例 $\\#1$：$(200.0, \\, 0.25, \\, 0.02, \\, 0.00, \\, 1.0, \\, 30.0, \\, 70.0, \\, 120.0, \\, 20.0)$。\n- 案例 $\\#2$：$(120.0, \\, 0.30, \\, 0.03, \\, 0.01, \\, 1.0, \\, 40.0, \\, 100.0, \\, 180.0, \\, 10.0)$。\n- 案例 $\\#3$：$(90.0, \\, 0.20, \\, 0.01, \\, 0.00, \\, 0.5, \\, 50.0, \\, 80.0, \\, 150.0, \\, 5.0)$。\n- 案例 $\\#4$：$(150.0, \\, 0.15, \\, 0.02, \\, 0.00, \\, 2.0, \\, 10.0, \\, 20.0, \\, 60.0, \\, 50.0)$。\n\n对于每个案例，您的程序必须输出一个包含六个浮点数的列表，顺序为 $[p_1, \\, p_2, \\, p_3, \\, p_4, \\, R_{\\mathrm{abs}}, \\, R_{\\mathrm{rel}}]$，其中每个浮点数四舍五入到 $6$ 位小数。\n\n最终输出格式：您的程序应生成单行输出，其中包含所有案例的结果，形式为列表的列表。外层列表必须恰好包含 $4$ 个内层列表，每个内层列表按上述顺序对应一个案例，并且每个内层列表必须恰好包含 $6$ 个四舍五入到 $6$ 位小数的浮点数。例如，打印的行必须类似于 $[[x_{11},x_{12},\\dots,x_{16}],[x_{21},\\dots,x_{26}],[x_{31},\\dots,x_{36}],[x_{41},\\dots,x_{46}]]$，不含多余的空格或文本。",
            "solution": "该问题要求在 Merton 模型框架下，针对定义违约壁垒的几种启发式方法，计算风险中性违约概率，并分析这些概率对启发式方法选择的敏感性。该问题定义明确，科学上基于成熟的金融理论，并为获得唯一解提供了所有必要的数据。\n\n公司资产的价值 $V_t$ 在风险中性测度 $\\mathbb{Q}$ 下被建模为几何布朗运动：\n$$\n\\mathrm{d}V_t = (r - q) V_t \\, \\mathrm{d}t + \\sigma V_t \\, \\mathrm{d}W_t\n$$\n其中 $r$ 是无风险利率，$q$ 是连续股息收益率，$\\sigma$ 是资产波动率，$W_t$ 是一个标准维纳过程。该随机微分方程在给定初始值 $V_0$ 的情况下，在时间 $T$ 的资产价值解为\n$$\nV_T = V_0 \\exp\\left( \\left(r - q - \\frac{1}{2}\\sigma^2\\right)T + \\sigma W_T \\right)\n$$\n其中 $W_T = \\sqrt{T}Z$ 且 $Z$ 是一个标准正态随机变量，$Z \\sim N(0, 1)$。这意味着 $\\ln(V_T)$ 服从正态分布，其均值为 $\\mu = \\ln(V_0) + (r - q - \\frac{1}{2}\\sigma^2)T$，方差为 $\\sigma^2 T$。\n\n如果到期日 $T$ 的资产价值低于某个违约阈值 $F$，则发生违约。因此，风险中性违约概率 $p$ 由 $\\mathbb{Q}(V_T < F)$ 给出。为了计算这个概率，我们对对数正态变量进行标准化：\n$$\n\\begin{aligned}\np = \\mathbb{Q}(V_T < F) &= \\mathbb{Q}(\\ln(V_T) < \\ln(F)) \\\\\n&= \\mathbb{Q}\\left(\\frac{\\ln(V_T) - \\mu}{\\sigma\\sqrt{T}} < \\frac{\\ln(F) - \\mu}{\\sigma\\sqrt{T}}\\right) \\\\\n&= \\mathbb{Q}\\left(Z < \\frac{\\ln(F) - \\left(\\ln(V_0) + \\left(r - q - \\frac{1}{2}\\sigma^2\\right)T\\right)}{\\sigma\\sqrt{T}}\\right) \\\\\n&= \\mathbb{Q}\\left(Z < \\frac{\\ln(F/V_0) - \\left(r - q - \\frac{1}{2}\\sigma^2\\right)T}{\\sigma\\sqrt{T}}\\right)\n\\end{aligned}\n$$\n该概率使用标准正态分布的累积分布函数（CDF）进行评估，记为 $\\Phi(\\cdot)$。在期权定价理论中，$\\Phi$ 的参数通常被认为是 Black-Scholes 模型 $d_2$ 参数的负值。我们定义 $d_2$ 为：\n$$\nd_2 = \\frac{\\ln(V_0/F) + \\left(r - q - \\frac{1}{2}\\sigma^2\\right)T}{\\sigma\\sqrt{T}}\n$$\n违约概率则由 $p = \\Phi(-d_2)$ 给出。\n\n问题指定了四种基于资产负债表数据来定义违约阈值 $F$ 的启发式方法：短期债务 $D_S$、长期债务 $D_L$、总负债 $L$ 和现金 $C$。对于每种启发式方法 $\\mathrm{Hi}$，我们计算一个阈值 $F_i$ 和相应的违约概率 $p_i$。\n\n- 启发式方法 $\\mathrm{H1}$：$F_1 = D_S + 0.5 D_L$。违约概率为 $p_1 = \\Phi(-d_{2,1})$。\n- 启发式方法 $\\mathrm{H2}$：$F_2 = D_S + D_L$。违约概率为 $p_2 = \\Phi(-d_{2,2})$。\n- 启发式方法 $\\mathrm{H3}$：$F_3 = L$。违约概率为 $p_3 = \\Phi(-d_{2,3})$。\n- 启发式方法 $\\mathrm{H4}$：$F_4 = \\max\\{D_S + D_L - C, 1\\}$。违约概率为 $p_4 = \\Phi(-d_{2,4})$。\n\n对于每个测试用例，计算步骤如下：\n1. 根据输入参数 $(V_0, \\sigma, r, q, T, D_S, D_L, L, C)$，计算四个违约阈值 $F_1, F_2, F_3, F_4$。\n2. 对于每个阈值 $F_i$，其中 $i \\in \\{1, 2, 3, 4\\}$，计算相应的 $d_{2,i}$ 项：\n    $$\n    d_{2,i} = \\frac{\\ln(V_0/F_i) + (r - q - 0.5\\sigma^2)T}{\\sigma\\sqrt{T}}\n    $$\n3. 使用标准正态 CDF 的数值实现计算四个违约概率 $p_i = \\Phi(-d_{2,i})$。\n4. 获得概率集合 $\\{p_1, p_2, p_3, p_4\\}$ 后，计算两个敏感性指标：\n    - 绝对范围：$R_{\\mathrm{abs}} = \\max_i p_i - \\min_i p_i$。\n    - 相对范围：$R_{\\mathrm{rel}} = R_{\\mathrm{abs}} / \\overline{p}$，其中 $\\overline{p} = \\frac{1}{4}\\sum_{i=1}^{4} p_i$ 是算术平均值。由于 $V_0 > 0$, $F_i > 0$, $\\sigma > 0$, and $T > 0$，概率 $p_i = \\Phi(-d_{2,i})$ 始终为严格正数，确保 $\\overline{p} > 0$ 且相对范围有明确定义。\n5. 将每个案例的结果收集到一个包含六个值的列表中：$[p_1, p_2, p_3, p_4, R_{\\mathrm{abs}}, R_{\\mathrm{rel}}]$，每个值四舍五入到 $6$ 位小数。对所有提供的测试用例重复此过程。\n\n科学计算库 `scipy.stats.norm` 提供了计算 $\\Phi(\\cdot)$ 所需的 `cdf` 函数。`numpy` 库用于高效的数值和基于数组的计算。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Computes risk-neutral default probabilities and sensitivity metrics\n    for the Merton model under different default threshold heuristics.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (V0, sigma, r, q, T, DS, DL, L, C)\n    test_cases = [\n        (200.0, 0.25, 0.02, 0.00, 1.0, 30.0, 70.0, 120.0, 20.0),\n        (120.0, 0.30, 0.03, 0.01, 1.0, 40.0, 100.0, 180.0, 10.0),\n        (90.0, 0.20, 0.01, 0.00, 0.5, 50.0, 80.0, 150.0, 5.0),\n        (150.0, 0.15, 0.02, 0.00, 2.0, 10.0, 20.0, 60.0, 50.0),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        V0, sigma, r, q, T, DS, DL, L, C = case\n\n        # Heuristic 1: Half long-term debt\n        F1 = DS + 0.5 * DL\n        # Heuristic 2: All interest-bearing debt\n        F2 = DS + DL\n        # Heuristic 3: Total liabilities\n        F3 = L\n        # Heuristic 4: Net debt with floor\n        F4 = max(DS + DL - C, 1.0)\n        \n        # Array of default thresholds\n        F_arr = np.array([F1, F2, F3, F4])\n\n        # Common terms in the d2 formula\n        drift_term = (r - q - 0.5 * sigma**2) * T\n        stdev_term = sigma * np.sqrt(T)\n\n        # Calculate d2 for each heuristic in a vectorized way\n        # d2 = (ln(V0/F) + (r - q - 0.5*sigma^2)*T) / (sigma*sqrt(T))\n        d2_arr = (np.log(V0 / F_arr) + drift_term) / stdev_term\n        \n        # Calculate default probabilities: P(V_T < F) = N(-d2)\n        probs = norm.cdf(-d2_arr)\n\n        # Calculate sensitivity metrics\n        R_abs = np.max(probs) - np.min(probs)\n        mean_p = np.mean(probs)\n        \n        # Relative range, handle case of mean_p being zero to avoid division errors,\n        # though it's theoretically not possible with these model constraints.\n        R_rel = R_abs / mean_p if mean_p > 0 else 0.0\n        \n        # Combine all results for the current case\n        case_result = list(probs) + [R_abs, R_rel]\n\n        # Round to 6 decimal places as required\n        rounded_result = [round(x, 6) for x in case_result]\n        all_results.append(rounded_result)\n\n    # Format the final output string as a list of lists.\n    #\n    # This manual string construction ensures the output strictly matches\n    # the required format with no extra spaces.\n    # Ex: [[1.0,2.0],[3.0,4.0]]\n    list_of_lists_str = [\n        f\"[{','.join(map(str, res))}]\" \n        for res in all_results\n    ]\n    final_output_str = f\"[{','.join(list_of_lists_str)}]\"\n    print(final_output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "经典的默顿模型假设违约只在债务到期时发生。本练习  引入了更为现实的动态，将策略性提前违约的可能性纳入考量。你需要对股东的决策过程进行建模，他们会权衡持续经营的价值与持续成本的负担。这个练习能让你深入理解经济激励如何能够在远未到期时就触发违约。",
            "id": "2435122",
            "problem": "考虑一家公司，其资金来源为单一类别的零息债券和由享有有限责任的股东持有的股权。该债券的面值为 $F$，到期时间为 $T$。公司的资产价值 $V_t$ 在风险中性测度下遵循几何布朗运动，其中无风险利率 $r$ 和波动率 $\\sigma$ 为常数，时间 $t \\in [0,T]$。在决策时间 $t<T$ 时，股东可以选择立即违约（策略性提前违约）或继续运营直至 $T$。如果股东在时间 $t$ 立即违约，他们将获得 $0$。如果他们选择继续运营，则必须承担一个确定性的运营负担，该负担被建模为在 $[t,T]$ 区间内单位时间成本为 $k$ 的恒定成本流，并在风险中性定价下以利率 $r$ 进行贴现。假设在 $t$ 时刻违约时股权无回收价值，债务无中期票息支付，市场无摩擦，并且在基准结构化模型中（无策略性行为时）违约仅在 $T$ 时刻发生。\n\n根据 Merton 模型的结构化方法，在 $t$ 时刻的股权是公司资产的一份期权价值。在理性预期和风险中性定价下，股东将存续价值与立即违约价值进行比较。$t$ 时刻的存续价值是 $t$ 时刻股权的风险中性现值（由 Merton 框架推导）减去 $[t,T]$ 区间内恒定成本流 $k$ 在 $t$ 时刻的现值。$t$ 时刻的立即违约价值为 $0$。当且仅当存续价值严格小于 $0$ 时，股东选择在 $t$ 时刻提前违约；如果两者相等，则他们处于无差异状态，为完成本任务，您必须选择存续。所有时间均以年为单位，所有利率（如 $r$）必须视为小数（例如，百分之五为 $0.05$），所有货币量（$V$, $F$, $k$）必须使用一致的货币单位。角度单位不适用。\n\n您的任务是编写一个完整的、可运行的程序，该程序对于一组给定的参数元组 $(V,F,r,\\sigma,t,T,k)$，根据以下规则为每个元组判断理性股东在时间 $t$ 是选择立即违约（输出布尔值 $True$）还是存续（输出布尔值 $False$）：当且仅当存续价值 $<0$ 时提前违约，否则选择存续。在 $t$ 时刻，$[t,T]$ 区间上以利率 $r$ 贴现的恒定成本流 $k$ 的现值，必须根据 $r$、$k$、$t$ 和 $T$，使用第一性原理作为函数进行计算；请注意，当 $r=0$ 时，此计算简化为一个极限情况。\n\n测试套件：\n- 案例 $1$：$(V,F,r,\\sigma,t,T,k) = (80,100,0.03,0.2,0,1,0)$。\n- 案例 $2$：$(V,F,r,\\sigma,t,T,k) = (60,100,0.05,0.25,0,1,20)$。\n- 案例 $3$：$(V,F,r,\\sigma,t,T,k) = (100,100,0.02,0.2,0.5,1.0,12.3)$。\n- 案例 $4$：$(V,F,r,\\sigma,t,T,k) = (90,100,0.0,0.3,0.0,1.5,5.0)$。\n- 案例 $5$：$(V,F,r,\\sigma,t,T,k) = (70,100,0.03,0.8,0.0,2.0,5.0)$。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果，结果顺序与测试套中的顺序相同，每个条目都是一个布尔值，表示对应案例在时间 $t$ 的最优行动。例如，输出格式必须为 $[result_1,result_2,result_3,result_4,result_5]$，其中每个 $result_i \\in \\{\\text{True},\\text{False}\\}$。",
            "solution": "所述问题是有效的。它在科学上基于金融经济学已确立的原则，特别是 Merton 开创的信用风险结构化模型。该问题是适定的，提供了所有必要的参数和明确的决策准则。它没有矛盾、主观陈述和非形式化元素。因此，我们可以直接进行求解。\n\n问题的核心是通过比较继续运营的价值与立即违约的价值来确定股东在时间 $t$ 的最优行动。立即违约的价值给定为 $0$。决策规则是当且仅当存续价值严格小于 $0$ 时违约。\n\n$t$ 时刻的存续价值，记为 $CV_t$，是股东在 $t$ 时刻的股权价值 $E_t$ 减去未来运营负担的现值，我们将其记为 $P_k(t,T)$。\n$$ CV_t = E_t - P_k(t,T) $$\n股东在 $t$ 时刻的最优行动是：如果 $CV_t < 0$，则违约；如果 $CV_t \\geq 0$，则继续运营。\n\n第一个组成部分，股权价值 $E_t$，源自 Merton 模型。在此框架中，股权等同于一份以公司总资产价值 $V_t$ 为标的物的欧式看涨期权。该期权的执行价格是债务的面值 $F$，到期时间是债务到期前剩余的时间 $\\tau = T-t$。此看涨期权的价值由 Black-Scholes-Merton 公式给出：\n$$ E_t = V_t N(d_1) - F e^{-r(T-t)} N(d_2) $$\n其中 $N(\\cdot)$ 是标准正态分布的累积分布函数 (CDF)，参数 $d_1$ 和 $d_2$ 定义如下：\n$$ d_1 = \\frac{\\ln(V_t/F) + (r + \\frac{1}{2}\\sigma^2)(T-t)}{\\sigma \\sqrt{T-t}} $$\n$$ d_2 = d_1 - \\sigma \\sqrt{T-t} = \\frac{\\ln(V_t/F) + (r - \\frac{1}{2}\\sigma^2)(T-t)}{\\sigma \\sqrt{T-t}} $$\n\n第二个组成部分是运营成本的现值 $P_k(t,T)$。公司在 $[t,T]$ 区间内承担单位时间为 $k$ 的恒定成本流。在风险中性定价下，此成本流在时间 $t$ 的现值通过对贴现后的成本流进行积分计算得出：\n$$ P_k(t,T) = \\int_{t}^{T} k e^{-r(s-t)} ds $$\n该积分的计算取决于无风险利率 $r$。\n当无风险利率不为零，即 $r > 0$ 时，该积分的计算结果为：\n$$ P_k(t,T) = \\frac{k}{r} \\left( 1 - e^{-r(T-t)} \\right) $$\n在无风险利率为零的特殊情况下，即 $r=0$ 时，被积函数中的指数项变为 $1$，积分简化为：\n$$ P_k(t,T) = \\int_{t}^{T} k \\, ds = k(T-t) $$\n这个 $r=0$ 的结果也可以通过 L'Hôpital 法则对 $r > 0$ 的表达式取 $r \\to 0$ 的极限来验证。\n\n对于一组给定的参数 $(V, F, r, \\sigma, t, T, k)$，解决该问题的算法流程如下：\n$1$. 计算到期时间 $\\tau = T-t$。\n$2$. 使用给定值计算参数 $d_1$ 和 $d_2$。\n$3$. 使用数值库函数评估标准正态CDF，$N(d_1)$ 和 $N(d_2)$。\n$4$. 使用 Black-Scholes-Merton 公式计算股权价值 $E_t$。\n$5$. 计算成本流的现值 $P_k(t,T)$，确保对 $r=0$ 和 $r > 0$ 使用正确的公式。\n$6$. 计算存续价值 $CV_t = E_t - P_k(t,T)$。\n$7$. 如果 $CV_t < 0$，返回 `True`（表示违约），否则返回 `False`（表示存续）。\n\n这个结构化流程被转换成一个 Python 程序，用于对指定的测试用例进行数值评估。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Solves for the optimal shareholder decision (default or continue) for\n    a series of test cases based on a modified Merton model.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each tuple is in the format: (V, F, r, sigma, t, T, k)\n    test_cases = [\n        (80, 100, 0.03, 0.2, 0, 1, 0),\n        (60, 100, 0.05, 0.25, 0, 1, 20),\n        (100, 100, 0.02, 0.2, 0.5, 1.0, 12.3),\n        (90, 100, 0.0, 0.3, 0.0, 1.5, 5.0),\n        (70, 100, 0.03, 0.8, 0.0, 2.0, 5.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        V, F, r, sigma, t, T, k = case\n        decision = should_default_early(V, F, r, sigma, t, T, k)\n        results.append(decision)\n\n    # Final print statement in the exact required format.\n    # The str() of a Python boolean is 'True' or 'False'.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef should_default_early(V, F, r, sigma, t, T, k):\n    \"\"\"\n    Determines if shareholders should default early based on continuation value.\n\n    Args:\n        V (float): Firm's asset value at time t.\n        F (float): Face value of zero-coupon debt.\n        r (float): Constant risk-free rate.\n        sigma (float): Constant volatility of asset value.\n        t (float): Decision time.\n        T (float): Debt maturity time.\n        k (float): Constant cost flow rate.\n\n    Returns:\n        bool: True if default is optimal, False if continuation is optimal.\n    \"\"\"\n    time_to_maturity = T - t\n\n    # In the problem, t < T, so time_to_maturity > 0.\n    # No need to handle time_to_maturity <= 0 edge cases.\n\n    # 1. Calculate Equity Value (E_t) using Black-Scholes-Merton formula\n    # The problem constraints ensure sigma > 0 and time_to_maturity > 0,\n    # so the denominator is non-zero.\n    \n    sigma_sqrt_tau = sigma * np.sqrt(time_to_maturity)\n    \n    # Check for V > 0 to avoid math domain error with log, which is a reasonable assumption.\n    if V <= 0:\n      # If asset value is zero, equity value is zero.\n      equity_value = 0.0\n    else:\n      d1 = (np.log(V / F) + (r + 0.5 * sigma**2) * time_to_maturity) / sigma_sqrt_tau\n      d2 = d1 - sigma_sqrt_tau\n      \n      N_d1 = norm.cdf(d1)\n      N_d2 = norm.cdf(d2)\n      \n      equity_value = V * N_d1 - F * np.exp(-r * time_to_maturity) * N_d2\n\n    # 2. Calculate Present Value of Costs (PV_costs)\n    if r == 0.0:\n        pv_costs = k * time_to_maturity\n    else:\n        pv_costs = (k / r) * (1 - np.exp(-r * time_to_maturity))\n\n    # 3. Calculate Continuation Value (CV_t)\n    continuation_value = equity_value - pv_costs\n\n    # 4. Decision Rule: Default if Continuation Value is strictly negative.\n    return continuation_value < 0\n\nsolve()\n```"
        },
        {
            "introduction": "任何量化模型的一个关键用途，不仅仅是得出一个单一的数字，更是理解其对各种风险因素的敏感性。本练习  将指导你对违约概率的变化进行一阶泰勒分解。通过计算资产价值、波动率、债务水平和时间变化各自的贡献，你将开发出一个用于风险归因和敏感性分析的实用工具，而这也是金融风险管理的基石。",
            "id": "2435102",
            "problem": "考虑由 Robert C. Merton 引入的违约结构模型。假设一家公司的资产价值过程 $\\{V_t\\}_{t \\ge 0}$ 在风险中性测度下遵循几何布朗运动，具有恒定的无风险利率 $r$ 和恒定的资产波动率 $\\sigma_V$，因此到期日 $T$ 的终端资产价值呈对数正态分布。该公司有一笔面值为 $F$ 的单一零息债务，于时间 $T$ 到期。当且仅当 $V_T < F$ 时，违约在 $T$ 时刻发生。在日历时间 $t$，剩余到期时间为 $\\tau = T - t$ 时，风险中性测度下的违约概率 (PD) 是在给定 $V_t = V$、$r$、$\\sigma_V$ 和 $\\tau$ 的条件下 $V_T < F$ 的概率，表示为 $[0,1]$ 范围内的小数（而非百分比）。\n\n设时间 $t$ 的初始参数向量为 $\\theta = (V, \\sigma_V, F, \\tau, r)$，并考虑一个短暂的时间增量 $\\Delta t > 0$ 及相应的参数小幅变化 $\\Delta V$、$\\Delta \\sigma_V$、$\\Delta F$。时间 $t + \\Delta t$ 的新参数向量为 $\\theta' = (V + \\Delta V, \\sigma_V + \\Delta \\sigma_V, F + \\Delta F, \\tau - \\Delta t, r)$，其中 $\\tau - \\Delta t > 0$。将此短时间间隔内违约概率的精确变化定义为\n$$\n\\Delta \\text{PD}_{\\text{exact}} \\equiv \\text{PD}(V + \\Delta V, \\sigma_V + \\Delta \\sigma_V, F + \\Delta F, \\tau - \\Delta t, r) - \\text{PD}(V, \\sigma_V, F, \\tau, r).\n$$\n通过在初始参数 $\\theta$ 处计算 $\\text{PD}$ 的一阶微分，将 $\\Delta \\text{PD}_{\\text{exact}}$ 分解为可归因于 $V$、$\\sigma_V$、$F$ 变化以及时间流逝（时间衰减）的加性贡献，产生四个贡献项 $C_V$、$C_{\\sigma}$、$C_F$ 和 $C_{\\text{time}}$，它们的和近似于 $\\Delta \\text{PD}_{\\text{exact}}$。将贡献项之和与精确变化之间的差值作为近似误差报告。\n\n假设违约概率 $\\text{PD}(V, \\sigma_V, F, \\tau, r)$ 是根据 $V_t$ 的风险中性动态所隐含的 $V_T$ 的对数正态分布以及违约事件 $\\{V_T < F\\}$ 直接计算得出的。所有结果必须表示为小数（而非百分比）。不涉及角度计算。\n\n您的程序必须为每个测试用例计算一个包含六个浮点数的列表：\n1. $\\Delta \\text{PD}_{\\text{exact}}$,\n2. $C_V$,\n3. $C_{\\sigma}$,\n4. $C_F$,\n5. $C_{\\text{time}}$,\n6. $\\left(C_V + C_{\\sigma} + C_F + C_{\\text{time}}\\right) - \\Delta \\text{PD}_{\\text{exact}}$,\n\n每个数值四舍五入到八位小数。将所有测试用例的结果汇总到单行输出中，该输出包含一个列表的列表，例如，\"[[...],[...],...]\"。\n\n使用以下参数值测试套件，每个作为元组 $(V, \\sigma_V, F, \\tau, r, \\Delta V, \\Delta \\sigma_V, \\Delta F, \\Delta t)$：\n- 案例 1 (典型): $(100.0, 0.25, 80.0, 1.0, 0.03, 0.5, 0.01, 0.2, 0.01)$。\n- 案例 2 (接近平价): $(100.0, 0.30, 100.0, 0.5, 0.02, -1.0, -0.02, 0.0, 0.02)$。\n- 案例 3 (高杠杆): $(70.0, 0.20, 100.0, 2.0, 0.05, 0.0, 0.03, -1.0, 0.1)$。\n- 案例 4 (短到期，纯时间衰减): $(95.0, 0.35, 100.0, 0.05, 0.01, 0.0, 0.0, 0.0, 0.01)$。\n- 案例 5 (低波动率): $(100.0, 0.05, 90.0, 1.5, 0.02, -0.5, 0.0, 0.0, 0.05)$。\n\n您的程序应生成单行输出，其中包含五个案例结果的逗号分隔列表，并用方括号括起来 (例如 \"[[c1],[c2],[c3],[c4],[c5]]\")。",
            "solution": "该问题要求在 Merton 模型框架内，对公司风险中性违约概率 (PD) 的变化进行分解。该分解基于关于模型参数的一阶泰勒级数展开，这些参数包括：公司资产价值 $V$、资产波动率 $\\sigma_V$、债务面值 $F$ 和剩余到期时间 $\\tau$。\n\n首先，我们建立违约概率 $\\text{PD}$ 的公式。根据 Merton 模型，公司的资产价值 $V_t$ 在风险中性测度 $\\mathbb{Q}$ 下遵循几何布朗运动：\n$$\ndV_t = r V_t dt + \\sigma_V V_t dZ_t\n$$\n其中 $r$ 是恒定的无风险利率，$\\sigma_V$ 是恒定的资产波动率，$Z_t$ 是一个标准维纳过程。此随机微分方程的解给出了在时间 $t$ 的价值 $V_t$ 条件下，到期日 $T$ 的资产价值 $V_T$：\n$$\nV_T = V_t \\exp\\left( \\left(r - \\frac{1}{2}\\sigma_V^2\\right)\\tau + \\sigma_V \\sqrt{\\tau} Z \\right)\n$$\n其中 $\\tau = T - t$ 是剩余到期时间，$Z$ 是一个标准正态随机变量，$Z \\sim N(0, 1)$。\n\n当且仅当到期时的资产价值小于债务面值时，即 $V_T < F$，违约发生。此事件的概率为：\n$$\n\\text{PD} = \\mathbb{Q}(V_T < F | V_t = V) = \\mathbb{Q}\\left( V \\exp\\left( \\left(r - \\frac{1}{2}\\sigma_V^2\\right)\\tau + \\sigma_V \\sqrt{\\tau} Z \\right) < F \\right)\n$$\n在概率测度内部对不等式两边取自然对数：\n$$\n\\ln(V) + \\left(r - \\frac{1}{2}\\sigma_V^2\\right)\\tau + \\sigma_V \\sqrt{\\tau} Z < \\ln(F)\n$$\n$$\n\\sigma_V \\sqrt{\\tau} Z < \\ln(F) - \\ln(V) - \\left(r - \\frac{1}{2}\\sigma_V^2\\right)\\tau\n$$\n$$\nZ < \\frac{\\ln(F/V) - \\left(r - \\frac{1}{2}\\sigma_V^2\\right)\\tau}{\\sigma_V \\sqrt{\\tau}} = - \\frac{\\ln(V/F) + \\left(r - \\frac{1}{2}\\sigma_V^2\\right)\\tau}{\\sigma_V \\sqrt{\\tau}}\n$$\n该表达式定义了标准违约距离度量 $-d_2$ 的负值，其中：\n$$\nd_2 = \\frac{\\ln(V/F) + \\left(r - \\frac{1}{2}\\sigma_V^2\\right)\\tau}{\\sigma_V \\sqrt{\\tau}}\n$$\n因此，违约概率由标准正态分布的累积分布函数 (CDF) $\\Phi(\\cdot)$ 给出：\n$$\n\\text{PD}(V, \\sigma_V, F, \\tau, r) = \\mathbb{Q}(Z < -d_2) = \\Phi(-d_2)\n$$\n问题要求计算精确变化 $\\Delta \\text{PD}_{\\text{exact}} = \\text{PD}(\\theta') - \\text{PD}(\\theta)$，并使用围绕初始参数向量 $\\theta = (V, \\sigma_V, F, \\tau, r)$ 的一阶泰勒展开来近似此变化。参数的变化由 $(\\Delta V, \\Delta \\sigma_V, \\Delta F, -\\Delta t)$ 给出。一阶近似为：\n$$\n\\Delta \\text{PD}_{\\text{approx}} = \\frac{\\partial \\text{PD}}{\\partial V}\\Delta V + \\frac{\\partial \\text{PD}}{\\partial \\sigma_V}\\Delta \\sigma_V + \\frac{\\partial \\text{PD}}{\\partial F}\\Delta F + \\frac{\\partial \\text{PD}}{\\partial \\tau}(-\\Delta t)\n$$\n各个单项即为贡献项 $C_V$、$C_{\\sigma}$、$C_F$ 和 $C_{\\text{time}}$。为了计算这些，我们必须求出 $\\text{PD}$ 对其各个参数的偏导数。使用链式法则，对于任意变量 $x$，我们有 $\\frac{\\partial \\text{PD}}{\\partial x} = \\frac{\\partial \\Phi(-d_2)}{\\partial x} = \\phi(-d_2) \\cdot \\left(-\\frac{\\partial d_2}{\\partial x}\\right)$，其中 $\\phi(\\cdot)$ 是标准正态概率密度函数 (PDF)。由于 $\\phi(-z) = \\phi(z)$，这可简化为 $\\frac{\\partial \\text{PD}}{\\partial x} = -\\phi(d_2) \\frac{\\partial d_2}{\\partial x}$。\n\n$d_2$ 的偏导数如下：\n1.  关于 $V$：\n    $$\n    \\frac{\\partial d_2}{\\partial V} = \\frac{\\partial}{\\partial V} \\left( \\frac{\\ln V - \\ln F + (r - \\frac{1}{2}\\sigma_V^2)\\tau}{\\sigma_V \\sqrt{\\tau}} \\right) = \\frac{1}{V \\sigma_V \\sqrt{\\tau}}\n    $$\n    因此，对资产价值的敏感度为：\n    $$\n    C_V = \\frac{\\partial \\text{PD}}{\\partial V} \\Delta V = -\\frac{\\phi(d_2)}{V \\sigma_V \\sqrt{\\tau}} \\Delta V\n    $$\n2.  关于 $F$：\n    $$\n    \\frac{\\partial d_2}{\\partial F} = \\frac{\\partial}{\\partial F} \\left( \\frac{\\ln V - \\ln F + (r - \\frac{1}{2}\\sigma_V^2)\\tau}{\\sigma_V \\sqrt{\\tau}} \\right) = -\\frac{1}{F \\sigma_V \\sqrt{\\tau}}\n    $$\n    对债务面值的敏感度为：\n    $$\n    C_F = \\frac{\\partial \\text{PD}}{\\partial F} \\Delta F = \\frac{\\phi(d_2)}{F \\sigma_V \\sqrt{\\tau}} \\Delta F\n    $$\n3.  关于 $\\sigma_V$：\n    首先定义 $d_1 = d_2 + \\sigma_V \\sqrt{\\tau} = \\frac{\\ln(V/F) + (r + \\frac{1}{2}\\sigma_V^2)\\tau}{\\sigma_V \\sqrt{\\tau}}$ 会很有用。金融微积分中的一个标准结果是 $\\frac{\\partial d_2}{\\partial \\sigma_V} = -\\frac{d_1}{\\sigma_V}$。\n    因此，对资产波动率的敏感度为：\n    $$\n    C_{\\sigma} = \\frac{\\partial \\text{PD}}{\\partial \\sigma_V} \\Delta \\sigma_V = -\\phi(d_2) \\left( -\\frac{d_1}{\\sigma_V} \\right) \\Delta \\sigma_V = \\frac{\\phi(d_2) d_1}{\\sigma_V} \\Delta \\sigma_V\n    $$\n4.  关于 $\\tau$：\n    $$\n    d_2 = \\frac{\\ln (V/F)}{\\sigma_V} \\tau^{-1/2} + \\frac{r - \\frac{1}{2}\\sigma_V^2}{\\sigma_V} \\tau^{1/2}\n    $$\n    $$\n    \\frac{\\partial d_2}{\\partial \\tau} = -\\frac{1}{2}\\frac{\\ln (V/F)}{\\sigma_V} \\tau^{-3/2} + \\frac{1}{2}\\frac{r - \\frac{1}{2}\\sigma_V^2}{\\sigma_V} \\tau^{-1/2} = \\frac{1}{2\\tau} \\left( -\\frac{\\ln(V/F)}{\\sigma_V\\sqrt{\\tau}} + \\frac{(r - \\frac{1}{2}\\sigma_V^2)\\tau}{\\sigma_V\\sqrt{\\tau}} \\right) = -\\frac{d_2}{2\\tau} + \\frac{r - \\frac{1}{2}\\sigma_V^2}{\\sigma_V\\sqrt{\\tau}}\n    $$\n    时间衰减的贡献为：\n    $$\n    C_{\\text{time}} = \\frac{\\partial \\text{PD}}{\\partial \\tau} (-\\Delta t) = -\\phi(d_2) \\left( -\\frac{d_2}{2\\tau} + \\frac{r - \\frac{1}{2}\\sigma_V^2}{\\sigma_V\\sqrt{\\tau}} \\right) (-\\Delta t) = \\phi(d_2) \\left( -\\frac{d_2}{2\\tau} + \\frac{r - \\frac{1}{2}\\sigma_V^2}{\\sigma_V\\sqrt{\\tau}} \\right) \\Delta t\n    $$\n所实现的算法将执行以下操作：\n1.  对每个测试用例，定义初始参数向量 $\\theta = (V, \\sigma_V, F, \\tau, r)$ 和变化量 $(\\Delta V, \\Delta \\sigma_V, \\Delta F, \\Delta t)$。\n2.  计算初始违约概率 $\\text{PD}(\\theta) = \\Phi(-d_2(\\theta))$。\n3.  定义新的参数向量 $\\theta' = (V+\\Delta V, \\sigma_V+\\Delta \\sigma_V, F+\\Delta F, \\tau-\\Delta t, r)$。\n4.  计算最终违约概率 $\\text{PD}(\\theta')$。\n5.  计算精确变化：$\\Delta \\text{PD}_{\\text{exact}} = \\text{PD}(\\theta') - \\text{PD}(\\theta)$。\n6.  在初始点 $\\theta$ 计算偏导数 $\\frac{\\partial \\text{PD}}{\\partial V}$、$\\frac{\\partial \\text{PD}}{\\partial \\sigma_V}$、$\\frac{\\partial \\text{PD}}{\\partial F}$ 和 $\\frac{\\partial \\text{PD}}{\\partial \\tau}$。\n7.  使用推导出的公式计算四个贡献项 $C_V$、$C_{\\sigma}$、$C_F$ 和 $C_{\\text{time}}$。\n8.  计算近似误差为 $\\left(C_V + C_{\\sigma} + C_F + C_{\\text{time}}\\right) - \\Delta \\text{PD}_{\\text{exact}}$。\n所有计算都将使用 `numpy` 和 `scipy.stats` 库中的函数以确保数值精度。",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import norm\n\ndef calculate_pd_and_sensitivities(V, sigma_V, F, tau, r):\n    \"\"\"\n    Calculates the probability of default (PD) and its first-order partial derivatives\n    (sensitivities) with respect to V, sigma_V, F, and tau, based on the Merton model.\n\n    Args:\n        V (float): Firm's asset value.\n        sigma_V (float): Asset volatility.\n        F (float): Face value of debt.\n        tau (float): Time to maturity.\n        r (float): Risk-free rate.\n\n    Returns:\n        tuple: A tuple containing:\n            - pd (float): Probability of default.\n            - pd_V (float): Partial derivative of PD w.r.t. V.\n            - pd_sigma (float): Partial derivative of PD w.r.t. sigma_V.\n            - pd_F (float): Partial derivative of PD w.r.t. F.\n            - pd_tau (float): Partial derivative of PD w.r.t. tau.\n    \"\"\"\n    if tau <= 1e-9:\n        pd = 1.0 if V < F else 0.0\n        return pd, 0.0, 0.0, 0.0, 0.0\n\n    sqrt_tau = np.sqrt(tau)\n    sigma_sqrt_tau = sigma_V * sqrt_tau\n    \n    d1 = (np.log(V / F) + (r + 0.5 * sigma_V**2) * tau) / sigma_sqrt_tau\n    d2 = d1 - sigma_sqrt_tau\n    \n    pd = norm.cdf(-d2)\n    \n    pdf_d2 = norm.pdf(d2)\n    \n    pd_V = -pdf_d2 / (V * sigma_sqrt_tau)\n    \n    pd_sigma = pdf_d2 * d1 / sigma_V\n    \n    pd_F = pdf_d2 / (F * sigma_sqrt_tau)\n    \n    d2_tau_deriv = (r - 0.5 * sigma_V**2) / (sigma_V * sqrt_tau) - d2 / (2 * tau)\n    pd_tau = -pdf_d2 * d2_tau_deriv\n    \n    return pd, pd_V, pd_sigma, pd_F, pd_tau\n\ndef solve_case(params):\n    \"\"\"\n    Solves a single test case for PD decomposition.\n\n    Args:\n        params (tuple): A tuple of parameters (V, sigma_V, F, tau, r, dV, d_sigma, dF, dt).\n\n    Returns:\n        list: A list of six floats rounded to eight decimal places.\n    \"\"\"\n    V, sigma_V, F, tau, r, dV, d_sigma, dF, dt = params\n\n    pd_initial, pd_V, pd_sigma, pd_F, pd_tau = calculate_pd_and_sensitivities(V, sigma_V, F, tau, r)\n    \n    C_V = pd_V * dV\n    C_sigma = pd_sigma * d_sigma\n    C_F = pd_F * dF\n    C_time = pd_tau * (-dt)\n    \n    V_new = V + dV\n    sigma_V_new = sigma_V + d_sigma\n    F_new = F + dF\n    tau_new = tau - dt\n    \n    pd_final = calculate_pd_and_sensitivities(V_new, sigma_V_new, F_new, tau_new, r)[0]\n    \n    delta_pd_exact = pd_final - pd_initial\n    \n    total_approximation = C_V + C_sigma + C_F + C_time\n    \n    approximation_error = total_approximation - delta_pd_exact\n    \n    return [\n        round(delta_pd_exact, 8),\n        round(C_V, 8),\n        round(C_sigma, 8),\n        round(C_F, 8),\n        round(C_time, 8),\n        round(approximation_error, 8)\n    ]\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final output.\n    \"\"\"\n    test_cases = [\n        # (V, sigma_V, F, tau, r, dV, d_sigma, dF, dt)\n        (100.0, 0.25, 80.0, 1.0, 0.03, 0.5, 0.01, 0.2, 0.01),\n        (100.0, 0.30, 100.0, 0.5, 0.02, -1.0, -0.02, 0.0, 0.02),\n        (70.0, 0.20, 100.0, 2.0, 0.05, 0.0, 0.03, -1.0, 0.1),\n        (95.0, 0.35, 100.0, 0.05, 0.01, 0.0, 0.0, 0.0, 0.01),\n        (100.0, 0.05, 90.0, 1.5, 0.02, -0.5, 0.0, 0.0, 0.05),\n    ]\n\n    results = []\n    for case in test_cases:\n        result_case = solve_case(case)\n        results.append(result_case)\n\n    case_strings = []\n    for res_list in results:\n        case_str = f\"[{','.join(map(str, res_list))}]\"\n        case_strings.append(case_str)\n    \n    final_output = f\"[{','.join(case_strings)}]\"\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}