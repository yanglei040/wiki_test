{
    "hands_on_practices": [
        {
            "introduction": "Our first practice extends the standard binomial model to a more realistic scenario: pricing an American option on a commodity. Real-world commodities often exhibit seasonal price patterns and incur storage costs, which we can model as a time-dependent continuous dividend yield. This exercise  challenges you to adapt the risk-neutral valuation framework to incorporate these non-constant parameters, providing a robust tool for pricing options on assets with more complex dynamics.",
            "id": "2420641",
            "problem": "You are asked to programmatically compute the value of an American option written on a commodity whose spot price process is affected by seasonality and storage costs. Work under the risk-neutral measure. The commodity spot price process $\\{S_t\\}_{t \\in [0,T]}$ has instantaneous dynamics\n$$\n\\frac{dS_t}{S_t} = \\left(r - q(t)\\right) \\, dt + \\sigma \\, dW_t,\n$$\nwhere $r$ is the continuously compounded risk-free interest rate, $\\sigma$ is the volatility, and $q(t)$ is a time-dependent effective yield. The effective yield combines a deterministic seasonal component and a storage cost treated as a negative continuous dividend yield:\n$$\nq(t) = q_0 + A \\cos\\left(2\\pi t + \\phi\\right) - s.\n$$\nHere $q_0$ is a baseline convenience yield level, $A$ is the seasonal amplitude, $\\phi$ is the phase (in radians), and $s$ is the storage cost rate. All rates are expressed per year as decimals, time $t$ is measured in years, and $T$ is in years.\n\nFor numerical valuation, use a discrete-time approximation with a Cox-Ross-Rubinstein recombining binomial model over $N$ equal steps of length $\\Delta t = T/N$. The up and down multipliers are\n$$\nu = e^{\\sigma \\sqrt{\\Delta t}}, \\quad d = \\frac{1}{u},\n$$\nand at step $i \\in \\{0,1,\\dots,N-1\\}$ corresponding to time $t_i = i \\Delta t$, the one-step risk-neutral probability is\n$$\np_i = \\frac{e^{(r - q(t_i)) \\Delta t} - d}{u - d}.\n$$\nThe one-step discount factor is $D = e^{-r \\Delta t}$. The American option value at time $0$ is the supremum over all stopping times $\\tau$ taking values on the grid $\\{0, \\Delta t, 2 \\Delta t, \\dots, T\\}$ of the discounted expected payoff under the above model. For a call, the payoff function is $\\Pi(S) = \\max(S - K, 0)$, and for a put, it is $\\Pi(S) = \\max(K - S, 0)$.\n\nImplement a program that computes the American option value at time $0$ for each of the following test cases. All inputs use the units specified above, with $\\phi$ given in radians. The output for each case must be a single real number (a float). Each result must be rounded to six decimal places.\n\nTest Suite:\n- Case 1 (seasonal effective yield oscillating around negative due to storage, baseline one-year maturity):\n  - $S_0 = 100.0$, $K = 100.0$, $r = 0.05$, $\\sigma = 0.2$, $T = 1.0$, $N = 400$, option type: put.\n  - $q_0 = 0.0$, $A = 0.03$, $\\phi = 0.0$, $s = 0.02$.\n- Case 2 (very short maturity boundary, one-step tree):\n  - $S_0 = 80.0$, $K = 100.0$, $r = 0.01$, $\\sigma = 0.25$, $T = 1/365$, $N = 1$, option type: put.\n  - $q_0 = 0.0$, $A = 0.02$, $\\phi = \\pi/2$, $s = 0.01$.\n- Case 3 (American call with negative effective yield due to storage and zero risk-free rate):\n  - $S_0 = 50.0$, $K = 40.0$, $r = 0.0$, $\\sigma = 0.3$, $T = 0.5$, $N = 300$, option type: call.\n  - $q_0 = 0.0$, $A = 0.0$, $\\phi = 0.0$, $s = 0.05$.\n- Case 4 (positive effective yield due to strong convenience yield, one-year maturity):\n  - $S_0 = 100.0$, $K = 90.0$, $r = 0.02$, $\\sigma = 0.25$, $T = 1.0$, $N = 400$, option type: put.\n  - $q_0 = 0.07$, $A = 0.02$, $\\phi = \\pi$, $s = 0.02$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each price rounded to six decimal places and printed as a decimal number (for example, $[12.345678,9.876543,0.123456,4.000000]$). No other text should be printed.",
            "solution": "The problem is subjected to validation before a solution is attempted.\n\n### Step 1: Extract Givens\n\nThe spot price process $\\{S_t\\}_{t \\in [0,T]}$ follows the stochastic differential equation:\n$$\n\\frac{dS_t}{S_t} = \\left(r - q(t)\\right) \\, dt + \\sigma \\, dW_t\n$$\nwhere $r$ is the risk-free rate, $\\sigma$ is volatility, and $q(t)$ is the time-dependent effective yield.\n\nThe effective yield is defined as:\n$$\nq(t) = q_0 + A \\cos\\left(2\\pi t + \\phi\\right) - s\n$$\nwhere $q_0$ is the baseline convenience yield, $A$ is seasonal amplitude, $\\phi$ is phase, and $s$ is storage cost rate.\n\nThe numerical method is a Cox-Ross-Rubinstein (CRR) binomial model with $N$ steps over a period $T$.\n- Time step: $\\Delta t = T/N$.\n- Up/down multipliers: $u = e^{\\sigma \\sqrt{\\Delta t}}$, $d = 1/u$.\n- One-step risk-neutral probability at time $t_i = i \\Delta t$:\n$$\np_i = \\frac{e^{(r - q(t_i)) \\Delta t} - d}{u - d}\n$$\n- One-step discount factor: $D = e^{-r \\Delta t}$.\n- Payoff functions: $\\Pi(S) = \\max(S - K, 0)$ for a call, and $\\Pi(S) = \\max(K - S, 0)$ for a put.\n\nTest Cases:\n1.  **Case 1**: $S_0 = 100.0$, $K = 100.0$, $r = 0.05$, $\\sigma = 0.2$, $T = 1.0$, $N = 400$, `option type: put`. Parameters for $q(t)$: $q_0 = 0.0$, $A = 0.03$, $\\phi = 0.0$, $s = 0.02$.\n2.  **Case 2**: $S_0 = 80.0$, $K = 100.0$, $r = 0.01$, $\\sigma = 0.25$, $T = 1/365$, $N = 1$, `option type: put`. Parameters for $q(t)$: $q_0 = 0.0$, $A = 0.02$, $\\phi = \\pi/2$, $s = 0.01$.\n3.  **Case 3**: $S_0 = 50.0$, $K = 40.0$, $r = 0.0$, $\\sigma = 0.3$, $T = 0.5$, $N = 300$, `option type: call`. Parameters for $q(t)$: $q_0 = 0.0$, $A = 0.0$, $\\phi = 0.0$, $s = 0.05$.\n4.  **Case 4**: $S_0 = 100.0$, $K = 90.0$, $r = 0.02$, $\\sigma = 0.25$, $T = 1.0$, $N = 400$, `option type: put`. Parameters for $q(t)$: $q_0 = 0.07$, $A = 0.02$, $\\phi = \\pi$, $s = 0.02$.\n\n### Step 2: Validate Using Extracted Givens\n\nThe problem is evaluated against the validation criteria.\n- **Scientifically Grounded**: The model provided is a variant of Geometric Brownian Motion with a time-dependent drift, which is a standard framework for modeling commodity prices in quantitative finance. The form of the effective yield $q(t)$ incorporating seasonality and storage costs is also a conventional approach. The numerical valuation method, a binomial tree, is a cornerstone of computational finance for option pricing. All equations and concepts are based on established financial engineering principles.\n- **Well-Posed**: The problem is well-posed. The inputs for each test case are complete and sufficient to compute a unique numerical result using the specified algorithm. The CRR model with a time-dependent dividend yield is known to provide a converging approximation to the continuous-time solution. The parameters are within reasonable bounds, ensuring that the risk-neutral probabilities $p_i$ satisfy the no-arbitrage condition $0  p_i  1$.\n- **Objective**: The problem is stated in precise, objective mathematical and financial language. It provides concrete test cases and requires a numerical output, leaving no room for subjective interpretation.\n\nThe problem does not exhibit any flaws such as scientific unsoundness, incompleteness, contradiction, or ambiguity. It is a standard and well-defined problem in computational economics and finance.\n\n### Step 3: Verdict and Action\n\nThe problem statement is **valid**. A solution will be provided.\n\nThe valuation of an American option on a commodity with the specified dynamics is performed using a binomial lattice. The fundamental principle is risk-neutral valuation combined with dynamic programming to account for the early exercise feature. The American option price at any point in time is the maximum of its intrinsic value (from immediate exercise) and its continuation value (from holding the option).\n\nThe algorithm proceeds via backward induction on a recombining binomial tree.\n\n1.  **Discretization of the Model**: The time to maturity $T$ is divided into $N$ equal intervals of length $\\Delta t = T/N$. The state space of the commodity price $S$ is discretized into a binomial lattice. The price at node $(i, j)$ at time $t_i = i\\Delta t$, having experienced $j$ up-moves and $i-j$ down-moves, is given by $S_{i,j} = S_0 u^j d^{i-j}$. The up and down multipliers, $u$ and $d$, are determined by the volatility $\\sigma$ and time step $\\Delta t$ as per the CRR model:\n    $$\n    u = e^{\\sigma \\sqrt{\\Delta t}}, \\quad d = e^{-\\sigma \\sqrt{\\Delta t}} = \\frac{1}{u}\n    $$\n    The one-step discount factor is constant: $D = e^{-r \\Delta t}$.\n\n2.  **Time-Dependent Risk-Neutral Probability**: The risk-neutral probability of an up-move is not constant but depends on the time step $i$ due to the time-dependent effective yield $q(t_i)$. For each time step $t_i = i \\Delta t$, where $i \\in \\{0, 1, \\dots, N-1\\}$, the effective yield is:\n    $$\n    q(t_i) = q_0 + A \\cos(2\\pi t_i + \\phi) - s\n    $$\n    This yields a step-dependent risk-neutral probability $p_i$ for the transition from $t_i$ to $t_{i+1}$:\n    $$\n    p_i = \\frac{e^{(r - q(t_i)) \\Delta t} - d}{u - d}\n    $$\n\n3.  **Backward Induction Algorithm**:\n    - **Initialization at Maturity (Time $T$)**: At the final time step $N$, the option value at each of the $N+1$ nodes is simply its intrinsic value, given by the payoff function. Let $\\omega = 1$ for a call and $\\omega = -1$ for a put. The value $V_{N,j}$ at node $(N,j)$ is:\n      $$\n      V_{N,j} = \\max(\\omega \\cdot (S_{N,j} - K), 0) \\quad \\text{for } j = 0, 1, \\dots, N\n      $$\n      These values are stored in a one-dimensional array of size $N+1$.\n\n    - **Iteration**: The algorithm iterates backward from time step $i = N-1$ down to $0$. At each step $i$, it computes the option values $V_{i,j}$ for all nodes $j \\in \\{0, 1, \\dots, i\\}$.\n      - For each node $(i,j)$, the continuation value, $C_{i,j}$, is the discounted expected value of the option in the next time step, calculated using the risk-neutral probability $p_i$:\n        $$\n        C_{i,j} = D \\cdot [p_i V_{i+1, j+1} + (1-p_i) V_{i+1, j}]\n        $$\n      - The intrinsic value, $I_{i,j}$, is the value if exercised at node $(i,j)$:\n        $$\n        I_{i,j} = \\max(\\omega \\cdot (S_{i,j} - K), 0)\n        $$\n      - The American option value at this node is the maximum of these two values, reflecting the optimal decision:\n        $$\n        V_{i,j} = \\max(I_{i,j}, C_{i,j})\n        $$\n      In implementation, a single array representing the option values at step $i+1$ can be updated in-place to store the values for step $i$.\n\n    - **Final Value**: The process terminates at step $i=0$. The single value $V_{0,0}$ is the price of the American option at time $t=0$.\n\nThis procedure is implemented for each test case to compute the required option prices.",
            "answer": "```python\nimport numpy as np\n\ndef calculate_american_option(S0, K, r, sigma, T, N, option_type, q_params):\n    \"\"\"\n    Computes the value of an American option on a commodity with seasonality.\n\n    Args:\n        S0 (float): Initial spot price.\n        K (float): Strike price.\n        r (float): Risk-free interest rate.\n        sigma (float): Volatility.\n        T (float): Time to maturity in years.\n        N (int): Number of steps in the binomial tree.\n        option_type (str): 'call' or 'put'.\n        q_params (dict): Parameters for the effective yield q(t).\n                         Keys: 'q0', 'A', 'phi', 's'.\n\n    Returns:\n        float: The price of the American option at time 0.\n    \"\"\"\n    # Unpack parameters for q(t)\n    q0 = q_params['q0']\n    A = q_params['A']\n    phi = q_params['phi']\n    s = q_params['s']\n\n    # Step 1: Discretization and constant parameters\n    dt = T / N\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1.0 / u\n    discount_factor = np.exp(-r * dt)\n\n    # Step 2: Initialize option values at maturity (time T)\n    # Omega = 1 for call, -1 for put\n    omega = 1.0 if option_type == 'call' else -1.0\n    \n    # Create a vector for option values. This will be updated at each step.\n    # It stores values at step i+1, and is used to compute values at step i.\n    V = np.zeros(N + 1)\n    \n    # Asset prices at maturity\n    S_T = np.array([(S0 * u**j * d**(N - j)) for j in range(N + 1)])\n    \n    # Option payoff at maturity\n    V[:] = np.maximum(omega * (S_T - K), 0)\n\n    # Step 3: Backward induction\n    for i in range(N - 1, -1, -1):\n        # Calculate time-dependent risk-neutral probability for this step\n        ti = i * dt\n        q_ti = q0 + A * np.cos(2 * np.pi * ti + phi) - s\n        \n        # Risk-neutral probability for transition from t_i to t_{i+1}\n        p_i = (np.exp((r - q_ti) * dt) - d) / (u - d)\n        \n        # Stability check, should hold for reasonable parameters\n        if not (0  p_i  1):\n             # This indicates an arbitrage opportunity or unstable parameters.\n             # The problem parameters are well-behaved, so this is a safeguard.\n             # For some extreme parameters, one might need to adjust u,d,p.\n             # but here it is not necessary.\n             pass\n\n        # Calculate option values at time step i\n        for j in range(i + 1):\n            # Continuation value (if not exercised)\n            continuation_value = discount_factor * (p_i * V[j+1] + (1 - p_i) * V[j])\n            \n            # Stock price at this node (i, j)\n            S_ij = S0 * u**j * d**(i - j)\n            \n            # Intrinsic value (if exercised now)\n            intrinsic_value = np.maximum(omega * (S_ij - K), 0)\n            \n            # American option value is the max of exercising or holding\n            V[j] = np.maximum(intrinsic_value, continuation_value)\n            \n    # The final result is the option value at the root of the tree (t=0)\n    return round(V[0], 6)\n\ndef solve():\n    \"\"\"\n    Solves the problem for the given test suite.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        {'S0': 100.0, 'K': 100.0, 'r': 0.05, 'sigma': 0.2, 'T': 1.0, 'N': 400, 'option_type': 'put',\n         'q_params': {'q0': 0.0, 'A': 0.03, 'phi': 0.0, 's': 0.02}},\n        # Case 2\n        {'S0': 80.0, 'K': 100.0, 'r': 0.01, 'sigma': 0.25, 'T': 1/365, 'N': 1, 'option_type': 'put',\n         'q_params': {'q0': 0.0, 'A': 0.02, 'phi': np.pi/2, 's': 0.01}},\n        # Case 3\n        {'S0': 50.0, 'K': 40.0, 'r': 0.0, 'sigma': 0.3, 'T': 0.5, 'N': 300, 'option_type': 'call',\n         'q_params': {'q0': 0.0, 'A': 0.0, 'phi': 0.0, 's': 0.05}},\n        # Case 4\n        {'S0': 100.0, 'K': 90.0, 'r': 0.02, 'sigma': 0.25, 'T': 1.0, 'N': 400, 'option_type': 'put',\n         'q_params': {'q0': 0.07, 'A': 0.02, 'phi': np.pi, 's': 0.02}},\n    ]\n\n    results = []\n    for case in test_cases:\n        price = calculate_american_option(\n            S0=case['S0'],\n            K=case['K'],\n            r=case['r'],\n            sigma=case['sigma'],\n            T=case['T'],\n            N=case['N'],\n            option_type=case['option_type'],\n            q_params=case['q_params']\n        )\n        results.append(price)\n    \n    # Format the final output according to specification\n    print(f\"[{','.join(map(lambda x: f'{x:.6f}', results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The assumption of constant volatility in the Black-Scholes and standard binomial models is a significant simplification. This practice  addresses this limitation by introducing a local volatility function, where volatility depends on the underlying asset's price. You will construct a non-recombining binomial tree to price an American put, offering a valuable lesson in the trade-offs between model realism and computational tractability.",
            "id": "2420693",
            "problem": "You are asked to design and implement a discrete-time binomial model to price an American put option when the instantaneous (local) volatility is a function of the stock price. The model must be self-contained and based on first principles of no-arbitrage pricing under the risk-neutral measure. Specifically, consider a risky asset with current price $S_0$, strike price $K$, continuously compounded risk-free rate $r$ (in decimal form), time to maturity $T$ (in years), and an integer number of time steps $N$. The time step size is $\\Delta t = T / N$. There are no dividends. The option is an American put, meaning it can be exercised at any time step prior to and including maturity.\n\nFundamental base and definitions: The binomial model assumes that over a single time step of length $\\Delta t$, from any node with stock price $S$, the next stock price takes one of two values: an \"up\" price $S \\cdot u(S)$ or a \"down\" price $S \\cdot d(S)$, where $u(S)  1$ and $d(S) = 1/u(S) \\in (0,1)$. The no-arbitrage risk-neutral valuation principle requires that the expected return of the stock over a single time step under the risk-neutral measure equals $e^{r \\Delta t}$. Therefore, the risk-neutral probability of the up move at the node with price $S$ is\n$$\np(S) = \\frac{e^{r \\Delta t} - d(S)}{u(S) - d(S)},\n$$\nand the down probability is $1 - p(S)$. American early exercise at a node with price $S$ yields an immediate payoff $\\max\\{K - S, 0\\}$; otherwise the continuation value is the discounted expected value of the next-step option values.\n\nLocal volatility specification: The up and down factors at a node with stock price $S$ are determined by a local volatility function $\\sigma(S)$ through\n$$\nu(S) = e^{\\sigma(S)\\sqrt{\\Delta t}}, \\quad d(S) = \\frac{1}{u(S)}.\n$$\nTo ensure positivity and a simple, well-defined dependence on $S$, use\n$$\n\\sigma(S) = \\max\\left(\\sigma_{\\min}, \\ \\sigma_0 \\cdot \\left(1 + \\beta \\cdot \\left(\\frac{S}{K} - 1\\right)\\right)\\right),\n$$\nwhere $\\sigma_{\\min}  0$ is a volatility floor, $\\sigma_0  0$ is a baseline volatility level, and $\\beta$ is a dimensionless slope parameter. Because $u(S)$ and $d(S)$ depend on $S$, the resulting binomial tree does not recombine in general. You must therefore construct the full non-recombining binary tree explicitly.\n\nAlgorithmic requirements:\n1. Build the non-recombining stock price tree with $N$ levels using the local volatility rule, starting at $S_0$ and expanding each node into two children with their node-specific factors $u(S)$ and $d(S)$. Record the corresponding risk-neutral probability $p(S)$ at each node.\n2. At maturity (level $N$), initialize the option value at each leaf node as the intrinsic value $\\max\\{K - S, 0\\}$.\n3. Perform backward induction from level $N-1$ to $0$: at a node with stock price $S$, compute the continuation value by discounting the next-step expected option value under $p(S)$ and $1 - p(S)$, and take the maximum with the immediate exercise payoff $\\max\\{K - S, 0\\}$. That is, at a generic node with price $S$,\n$$\nV(S) = \\max\\left(\\max\\{K - S, 0\\}, \\ e^{-r\\Delta t} \\cdot \\left(p(S) \\cdot V\\left(S \\cdot u(S)\\right) + (1 - p(S)) \\cdot V\\left(S \\cdot d(S)\\right)\\right)\\right).\n$$\n4. Report the root value $V(S_0)$ as the American put price for the parameter set.\n\nNumerical realism and constraints: You must assume $N$ is small enough that the explicit non-recombining tree is computationally feasible. All rates and volatilities are in decimal form. Time is expressed in years. Angles are not involved. There are no physical units beyond the financial conventions already specified. The test suite below chooses scientifically plausible parameters that imply $0  p(S)  1$ and ensure numerical stability. If numerical round-off causes a probability just outside $[0,1]$, clip it to the interval $[0,1]$ locally to avoid spurious negative probabilities.\n\nTest suite: Your program must price the American put for each of the following parameter sets. In each tuple, the parameters are ordered as $(S_0, K, r, T, N, \\sigma_0, \\beta, \\sigma_{\\min})$.\n- Case $1$: $(\\$100.0, \\$100.0, 0.05, 1.0, 10, 0.20, 0.40, 0.05)$.\n- Case $2$: $(\\$50.0, \\$100.0, 0.02, 1.0, 12, 0.25, -0.60, 0.05)$.\n- Case $3$: $(\\$120.0, \\$100.0, 0.00, 0.25, 8, 0.15, 0.00, 0.05)$.\n- Case $4$: $(\\$100.0, \\$100.0, 0.10, 0.5, 1, 0.30, 1.00, 0.05)$.\n\nRequired final output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example $[x_1,x_2,x_3,x_4]$, where each $x_i$ is the computed American put price for Case $i$. Round each $x_i$ to exactly $6$ decimal places. There must be no extra whitespace or additional text in the output line.",
            "solution": "The problem statement has been rigorously validated and is determined to be **valid**. It constitutes a well-posed problem in the domain of computational finance, grounded in established first principles of no-arbitrage derivative pricing. All definitions, parameters, and algorithmic requirements are specified with sufficient clarity and precision to permit the construction of a unique and meaningful solution.\n\nThe problem requires the pricing of an American put option under a local volatility framework. This is accomplished using a discrete-time, non-recombining binomial tree model. The core of the solution is to construct this tree and then apply the principle of backward induction to find the option's value.\n\nThe model is defined over $N$ discrete time steps, with each step of duration $\\Delta t = T/N$. At any given node in the tree with stock price $S$, the asset price can move up to $S \\cdot u(S)$ or down to $S \\cdot d(S)$ in the subsequent time step. The movement factors, $u(S)$ and $d(S)$, are functions of the stock price $S$ via the local volatility function $\\sigma(S)$:\n$$\nu(S) = e^{\\sigma(S)\\sqrt{\\Delta t}}, \\quad d(S) = \\frac{1}{u(S)} = e^{-\\sigma(S)\\sqrt{\\Delta t}}\n$$\nThe local volatility, $\\sigma(S)$, is specified as a function of the stock's moneyness relative to the strike price $K$:\n$$\n\\sigma(S) = \\max\\left(\\sigma_{\\min}, \\ \\sigma_0 \\cdot \\left(1 + \\beta \\cdot \\left(\\frac{S}{K} - 1\\right)\\right)\\right)\n$$\nThis state-dependent volatility means the binomial tree does not recombine, necessitating the explicit construction and storage of all $2^i$ nodes at each time level $i$.\n\nThe pricing is conducted under the risk-neutral measure. The risk-neutral probability $p(S)$ for an upward price movement is derived from the no-arbitrage condition, which states that the expected return on the asset must equal the risk-free return, $e^{r\\Delta t}$. This yields:\n$$\np(S) = \\frac{e^{r \\Delta t} - d(S)}{u(S) - d(S)}\n$$\nThe probability of a downward movement is correspondingly $1 - p(S)$. The problem specification provides a guarantee that parameters are selected such that $0  p(S)  1$, but also advises clipping the computed probability to the interval $[0, 1]$ to ensure numerical stability.\n\nThe valuation algorithm proceeds via backward induction:\n1.  **Forward Tree Construction**: First, a complete binary tree of stock prices is constructed. Starting from the initial price $S_0$ at level $i=0$, we iteratively compute the $2^{i+1}$ successor prices at level $i+1$ from the $2^i$ prices at level $i$. This process continues until level $N$, resulting in $2^N$ terminal stock prices.\n\n2.  **Valuation at Maturity**: At the final time step, level $N$, the option value at each of the $2^N$ nodes is determined by its intrinsic value upon exercise:\n    $$\n    V_N(S) = \\max\\{K - S, 0\\}\n    $$\n\n3.  **Backward Induction Step**: The algorithm then iterates backward from level $i=N-1$ to $i=0$. At each node with price $S$, the option value $V_i(S)$ is the greater of the value from immediate exercise and the continuation value.\n    - The immediate exercise value is $\\max\\{K - S, 0\\}$.\n    - The continuation value is the discounted expected value of the option at the next time step, under the risk-neutral measure:\n      $$\n      \\text{Continuation Value} = e^{-r\\Delta t} \\left[ p(S) \\cdot V_{i+1}(S \\cdot u(S)) + (1 - p(S)) \\cdot V_{i+1}(S \\cdot d(S)) \\right]\n      $$\n      Here, $V_{i+1}(\\cdot)$ are the known option values from the subsequent level, which have already been computed.\n    - Thus, the option value is:\n      $$\n      V_i(S) = \\max\\left(\\max\\{K - S, 0\\}, \\ e^{-r\\Delta t} \\left[ p(S) \\cdot V_{i+1,u} + (1 - p(S)) \\cdot V_{i+1,d} \\right] \\right)\n      $$\n\n4.  **Option Price**: This backward iteration concludes at level $i=0$, which contains only the root node with price $S_0$. The value computed for this node, $V_0(S_0)$, is the price of the American put option. The implementation will perform this process level by level to compute the prices for the given test cases.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Parameters are ordered as: (S0, K, r, T, N, sigma0, beta, sigma_min)\n    test_cases = [\n        (100.0, 100.0, 0.05, 1.0, 10, 0.20, 0.40, 0.05),\n        (50.0, 100.0, 0.02, 1.0, 12, 0.25, -0.60, 0.05),\n        (120.0, 100.0, 0.00, 0.25, 8, 0.15, 0.00, 0.05),\n        (100.0, 100.0, 0.10, 0.5, 1, 0.30, 1.00, 0.05),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = price_american_put_non_recombining(*case)\n        results.append(f\"{result:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef price_american_put_non_recombining(S0, K, r, T, N, sigma0, beta, sigma_min):\n    \"\"\"\n    Prices an American put option using a non-recombining binomial tree\n    with local volatility.\n\n    Args:\n        S0 (float): Initial stock price.\n        K (float): Strike price.\n        r (float): Risk-free interest rate (decimal).\n        T (float): Time to maturity (years).\n        N (int): Number of time steps.\n        sigma0 (float): Baseline volatility.\n        beta (float): Volatility slope parameter.\n        sigma_min (float): Volatility floor.\n\n    Returns:\n        float: The calculated price of the American put option.\n    \"\"\"\n    dt = T / N\n    discount_factor = np.exp(-r * dt)\n    exp_rdt = np.exp(r * dt)\n    sqrt_dt = np.sqrt(dt)\n\n    def get_sigma(S):\n        \"\"\"Calculates local volatility for a given stock price S.\"\"\"\n        return np.maximum(sigma_min, sigma0 * (1.0 + beta * (S / K - 1.0)))\n\n    # Step 1: Forward Pass - Build the stock price tree\n    # stock_tree[i] stores the list of stock prices at level i.\n    stock_tree = [[S0]]\n    for i in range(N):\n        prices_at_next_level = []\n        for S in stock_tree[i]:\n            sigma_S = get_sigma(S)\n            u = np.exp(sigma_S * sqrt_dt)\n            prices_at_next_level.append(S * u)\n            prices_at_next_level.append(S / u) # d = 1/u\n        stock_tree.append(prices_at_next_level)\n\n    # Step 2: Backward Pass - Calculate option values\n    # Initialize option values at maturity (level N).\n    option_values = [np.maximum(K - s, 0.0) for s in stock_tree[N]]\n    \n    # Iterate backwards from level N-1 down to 0.\n    for i in range(N - 1, -1, -1):\n        option_values_at_this_level = []\n        for j in range(len(stock_tree[i])):\n            S = stock_tree[i][j]\n            \n            # Option values from the successor nodes.\n            V_u = option_values[2 * j]\n            V_d = option_values[2 * j + 1]\n            \n            # Calculate node-specific parameters.\n            sigma_S = get_sigma(S)\n            u = np.exp(sigma_S * sqrt_dt)\n            d = 1.0 / u\n            \n            # Risk-neutral probability. Since sigma_S is guaranteed to be positive,\n            # u  d, so no division by zero will occur.\n            p = (exp_rdt - d) / (u - d)\n\n            # Clip probability to [0, 1] for numerical stability as per instructions.\n            p = np.maximum(0.0, np.minimum(1.0, p))\n\n            # Continuation value (value of holding the option).\n            continuation_value = discount_factor * (p * V_u + (1.0 - p) * V_d)\n            \n            # Exercise value (value of exercising the option now).\n            exercise_value = np.maximum(K - S, 0.0)\n            \n            # Option value is the maximum of holding vs. exercising.\n            node_value = np.maximum(continuation_value, exercise_value)\n            option_values_at_this_level.append(node_value)\n        \n        option_values = option_values_at_this_level\n            \n    # The final price is the single value at the root of the tree (level 0).\n    return option_values[0]\n\nsolve()\n```"
        },
        {
            "introduction": "The principle of optimal stopping extends far beyond the valuation of a single option. In this final exercise , we apply the logic of backward induction to a game-theoretic setting where two players hold competing American options. By calculating the subgame-perfect equilibrium, you will see how the same computational framework can be used to analyze strategic interactions and predict rational behavior in competitive financial scenarios.",
            "id": "2420694",
            "problem": "You are asked to design and implement a program that computes subgame-perfect equilibrium values for a two-player stopping game based on American-style options on the same underlying asset, using a recombining binomial model. One player holds an American call option and the other holds an American put option, both with the same strike on the same asset. The strategic interaction is defined by a sequential-move exercise priority at each time step: the call holder moves first, and only if the call holder chooses not to exercise does the put holder get to decide. The game terminates when any player exercises; otherwise, it continues to the next time step. All valuations must be under the risk-neutral measure, using the Cox–Ross–Rubinstein binomial model.\n\nFundamental base:\n- The underlying asset price process is modeled under the risk-neutral measure in discrete time with a recombining binomial tree. Let the underlying price at time $t$ be $S_t$, with time steps of length $\\Delta t = T/N$. The \"up\" and \"down\" multiplicative factors are $u = \\exp(\\sigma \\sqrt{\\Delta t})$ and $d = 1/u$, respectively, where $\\sigma$ is the volatility. The risk-neutral probability is $p = \\dfrac{\\exp((r - q)\\Delta t) - d}{u - d}$, where $r$ is the continuously compounded risk-free rate and $q$ is the continuous dividend yield. The one-step discount factor is $\\beta = \\exp(-r \\Delta t)$.\n- The American call option has immediate exercise payoff $C_t = \\max(S_t - K, 0)$ at any time $t$, while the American put option has immediate exercise payoff $P_t = \\max(K - S_t, 0)$ at any time $t$, where $K$ is the strike price.\n- Risk-neutral valuation principle: at any node, the continuation value equals the discounted expectation of the next step equilibrium values, computed as $\\beta \\left( p \\cdot V^{\\cdot}_{t+1}(Su) + (1-p) \\cdot V^{\\cdot}_{t+1}(Sd) \\right)$, where $V^{\\cdot}$ denotes the equilibrium value for the respective player.\n\nGame protocol and equilibrium concept:\n- At each node $(t, S)$ for $t \\in \\{0, 1, \\ldots, N\\}$:\n  1. The call holder moves first and decides to exercise or to continue.\n  2. If the call holder continues, the put holder then decides to exercise or to continue.\n  3. If any player exercises at that node, the game terminates immediately with payoffs equal to the exercising player’s immediate exercise value and zero for the other player. If neither exercises, the game proceeds to the next time step with both options alive.\n- Tie-breaking and optimality: each player exercises if and only if their immediate exercise payoff is strictly greater than their continuation value; otherwise, they continue. In case of equality, the player continues. This convention must be applied at every node, including maturity. This ensures the equilibrium is well-defined and avoids pathological exercise with zero gain.\n- At maturity $t = N$, the same sequential protocol applies: the call holder moves first; if the call does not exercise, the put holder may exercise. If neither exercises at $t = N$, both receive zero.\n\nDynamic programming for equilibrium values:\n- Let $V^C_t(S)$ and $V^P_t(S)$ denote the equilibrium values at node $(t, S)$ for the call and put holders, respectively, conditional on reaching that node with both options still alive.\n- For $t = N$, set\n  - If $C_N = \\max(S - K, 0)  0$, then $V^C_N(S) = C_N$ and $V^P_N(S) = 0$.\n  - Else, if $P_N = \\max(K - S, 0)  0$, then $V^C_N(S) = 0$ and $V^P_N(S) = P_N$.\n  - Else, $V^C_N(S) = 0$ and $V^P_N(S) = 0$.\n- For $t = 0, 1, \\ldots, N-1$, define the one-step continuation values\n  $$\\tilde V^C_t(S) = \\beta \\left( p \\cdot V^C_{t+1}(Su) + (1-p) \\cdot V^C_{t+1}(Sd) \\right), \\quad \\tilde V^P_t(S) = \\beta \\left( p \\cdot V^P_{t+1}(Su) + (1-p) \\cdot V^P_{t+1}(Sd) \\right).$$\n  Then the equilibrium at $(t, S)$ is computed by:\n  - Put’s response if the call continues: if $P_t  \\tilde V^P_t(S)$, the put exercises and the node payoffs are $(0, P_t)$; otherwise the put continues and the node payoffs are $(\\tilde V^C_t(S), \\tilde V^P_t(S))$.\n  - Call’s decision using the anticipated put response: define the call’s continuation-with-response value as $\\text{Cont}^C_t(S) = 0$ if the put would exercise, and $\\text{Cont}^C_t(S) = \\tilde V^C_t(S)$ otherwise. If $C_t  \\text{Cont}^C_t(S)$, the call exercises and the node payoffs are $(C_t, 0)$; otherwise, the node payoffs are those implied by the put’s response (either $(0, P_t)$ if the put exercises, or $(\\tilde V^C_t(S), \\tilde V^P_t(S))$ if the put continues).\n\nYour tasks:\n- Implement the above dynamic program on a recombining binomial tree with the parameters listed in the test suite.\n- Compute and return the equilibrium present values at the root node for both players, i.e., $V^C_0(S_0)$ and $V^P_0(S_0)$, for each test case.\n- All monetary values are in consistent abstract units; no physical units are involved. Rates $r$, $q$, and $\\sigma$ must be interpreted as decimals (for example, $0.05$ for five percent). Time to maturity $T$ is in years. Angles do not appear in this problem.\n\nTest suite:\n- Case A (baseline, no dividend yield):\n  - $S_0 = 100$, $K = 100$, $r = 0.05$, $q = 0.00$, $\\sigma = 0.20$, $T = 1.00$, $N = 200$.\n- Case B (dividend yield encourages early call exercise):\n  - $S_0 = 100$, $K = 100$, $r = 0.01$, $q = 0.08$, $\\sigma = 0.25$, $T = 1.00$, $N = 200$.\n- Case C (deep in-the-money put at inception):\n  - $S_0 = 60$, $K = 100$, $r = 0.03$, $q = 0.00$, $\\sigma = 0.25$, $T = 1.00$, $N = 150$.\n- Case D (deep in-the-money call with high dividends):\n  - $S_0 = 150$, $K = 100$, $r = 0.02$, $q = 0.10$, $\\sigma = 0.20$, $T = 1.00$, $N = 150$.\n\nRequired final output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each entry is itself a two-element list $[V^C_0, V^P_0]$ of the call and put equilibrium values for the corresponding test case.\n- Each numeric value must be rounded to six decimal places.\n- For the above four cases, the output must look like:\n  - $[[v^C_A, v^P_A],[v^C_B, v^P_B],[v^C_C, v^P_C],[v^C_D, v^P_D]]$,\n  where each $v$ stands for a float rounded to six decimal places.\n\nYour submitted answer must be a complete, runnable program that performs these computations and prints exactly one line in the specified format. No user input should be required, and no external files should be used.",
            "solution": "The problem is valid. It presents a well-defined question in computational finance, grounded in established theories of option pricing and game theory. All parameters and rules are specified unambiguously, allowing for a unique, computable solution. We proceed to construct the solution.\n\nThe problem requires the calculation of subgame-perfect equilibrium values for a two-player sequential stopping game. The framework is the Cox-Ross-Rubinstein (CRR) binomial model under the risk-neutral measure. The solution is obtained via dynamic programming, specifically by backward induction on the binomial tree.\n\nFirst, we define the parameters of the recombining binomial model. The time to maturity $T$ is divided into $N$ steps of duration $\\Delta t = T/N$. The underlying asset price $S$ moves up by a factor $u$ or down by a factor $d$ at each step. These factors are given by:\n$$u = \\exp(\\sigma \\sqrt{\\Delta t})$$\n$$d = \\frac{1}{u} = \\exp(-\\sigma \\sqrt{\\Delta t})$$\nwhere $\\sigma$ is the asset's volatility.\n\nUnder the risk-neutral measure, the probability of an \"up\" move, $p$, is determined by the risk-free rate $r$ and the continuous dividend yield $q$:\n$$p = \\frac{\\exp((r - q)\\Delta t) - d}{u - d}$$\nThe probability of a \"down\" move is $1-p$. All future cash flows are discounted using the one-step discount factor $\\beta = \\exp(-r \\Delta t)$. The stock price at any node $(t, j)$—representing time step $t$ and $j$ up-moves—is $S_{t,j} = S_0 u^j d^{t-j}$.\n\nThe core of the solution lies in a backward induction algorithm to find the subgame-perfect equilibrium values for the call holder, $V^C_t(S)$, and the put holder, $V^P_t(S)$, at each node $(t, S)$ of the tree.\n\nThe algorithm starts at the maturity time, $t=N$. At each terminal node, we determine the payoffs based on the specified sequential game protocol and strict exercise condition. The call holder decides first.\n- If the call's intrinsic value $C_N = \\max(S_N - K, 0)$ is strictly positive, the call holder exercises. The payoffs are $(V^C_N, V^P_N) = (C_N, 0)$.\n- If $C_N = 0$, the call holder continues. The put holder then decides. If the put's intrinsic value $P_N = \\max(K - S_N, 0)$ is strictly positive, the put holder exercises. The payoffs are $(V^C_N, V^P_N) = (0, P_N)$.\n- If both $C_N=0$ and $P_N=0$, both players continue, and since it is maturity, both options expire worthless. The payoffs are $(V^C_N, V^P_N) = (0, 0)$.\n\nNext, we iterate backward from $t = N-1$ down to $t=0$. At each node $(t, S)$, we compute the equilibrium values $(V^C_t(S), V^P_t(S))$ using the values from the next time step, $t+1$. The logic for each node is as follows:\n\n1.  Calculate the one-step-ahead continuation values for both players. These are the discounted expected values of continuing the game for one more step, assuming no exercise at the current node:\n    $$\\tilde V^C_t(S) = \\beta \\left( p \\cdot V^C_{t+1}(Su) + (1-p) \\cdot V^C_{t+1}(Sd) \\right)$$\n    $$\\tilde V^P_t(S) = \\beta \\left( p \\cdot V^P_{t+1}(Su) + (1-p) \\cdot V^P_{t+1}(Sd) \\right)$$\n\n2.  Solve the subgame at node $(t,S)$ by backward induction *within the node*.\n    a.  First, determine the put holder's (second mover) optimal strategy, conditional on the call holder (first mover) choosing to continue. The put holder compares their immediate exercise payoff $P_t = \\max(K-S, 0)$ with their continuation value $\\tilde V^P_t(S)$. The put holder will exercise if and only if $P_t  \\tilde V^P_t(S)$.\n\n    b.  Second, determine the call holder's (first mover) optimal strategy. The call holder anticipates the put holder's response. The call's effective continuation value, denoted $\\text{Cont}^C_t(S)$, depends on this anticipation:\n        - If the put holder would exercise (i.e., if $P_t  \\tilde V^P_t(S)$), the call's value upon continuing is $0$. Thus, $\\text{Cont}^C_t(S) = 0$.\n        - If the put holder would continue (i.e., if $P_t \\le \\tilde V^P_t(S)$), the call's value upon continuing is its standard continuation value, $\\tilde V^C_t(S)$. Thus, $\\text{Cont}^C_t(S) = \\tilde V^C_t(S)$.\n    The call holder then compares their immediate exercise payoff $C_t = \\max(S-K, 0)$ to this effective continuation value. The call holder will exercise if and only if $C_t  \\text{Cont}^C_t(S)$.\n\n3.  The equilibrium values at node $(t,S)$ are then determined by the outcome of this sequential decision process:\n    - If the call holder exercises: $(V^C_t, V^P_t) = (C_t, 0)$.\n    - If the call holder continues and the put holder exercises: $(V^C_t, V^P_t) = (0, P_t)$.\n    - If both players continue: $(V^C_t, V^P_t) = (\\tilde V^C_t, \\tilde V^P_t)$.\n\nThis procedure is applied to all nodes at time $t$. We then decrement $t$ and repeat the process until we reach the root node at $t=0$. The resulting values, $V^C_0(S_0)$ and $V^P_0(S_0)$, are the equilibrium present values of the options for the two players. This algorithm will be implemented in Python using `numpy` for efficient vectorized computation over the nodes at each time step.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the test cases and print the output in the required format.\n    \"\"\"\n    test_cases = [\n        # Case A: baseline, no dividend yield\n        {'S0': 100.0, 'K': 100.0, 'r': 0.05, 'q': 0.00, 'sigma': 0.20, 'T': 1.00, 'N': 200},\n        # Case B: dividend yield encourages early call exercise\n        {'S0': 100.0, 'K': 100.0, 'r': 0.01, 'q': 0.08, 'sigma': 0.25, 'T': 1.00, 'N': 200},\n        # Case C: deep in-the-money put at inception\n        {'S0': 60.0, 'K': 100.0, 'r': 0.03, 'q': 0.00, 'sigma': 0.25, 'T': 1.00, 'N': 150},\n        # Case D: deep in-the-money call with high dividends\n        {'S0': 150.0, 'K': 100.0, 'r': 0.02, 'q': 0.10, 'sigma': 0.20, 'T': 1.00, 'N': 150},\n    ]\n\n    results = []\n    for params in test_cases:\n        v_c, v_p = compute_equilibrium_values(**params)\n        # Format the result for the current case as a string '[v_c,v_p]'\n        results.append(f\"[{v_c:.6f},{v_p:.6f}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef compute_equilibrium_values(S0, K, r, q, sigma, T, N):\n    \"\"\"\n    Computes subgame-perfect equilibrium values for the two-player option exercise game\n    using a recombining binomial model.\n\n    Args:\n        S0 (float): Initial stock price.\n        K (float): Strike price.\n        r (float): Risk-free interest rate.\n        q (float): Continuous dividend yield.\n        sigma (float): Volatility.\n        T (float): Time to maturity in years.\n        N (int): Number of time steps in the binomial tree.\n\n    Returns:\n        tuple[float, float]: The equilibrium values (V_C, V_P) at time t=0.\n    \"\"\"\n    # 1. Calculate CRR model parameters\n    dt = T / N\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1.0 / u\n    p = (np.exp((r - q) * dt) - d) / (u - d)\n    beta = np.exp(-r * dt)\n\n    # 2. Initialize asset prices at maturity (t=N), ordered from highest to lowest stock price.\n    # S_at_N[j] corresponds to N-j up moves and j down moves.\n    num_up_moves = np.arange(N, -1, -1)\n    num_down_moves = np.arange(0, N + 1, 1)\n    S_at_N = S0 * (u ** num_up_moves) * (d ** num_down_moves)\n\n    # 3. Determine terminal payoffs at t=N based on the sequential game protocol\n    C_N = np.maximum(S_at_N - K, 0)\n    P_N = np.maximum(K - S_at_N, 0)\n\n    # The call holder moves first. If C_N  0, they exercise.\n    # Otherwise, the put holder moves. If P_N  0, they exercise.\n    # Otherwise, both options expire worthless. This uses the strict inequality rule.\n    V_C = np.where(C_N > 0, C_N, 0)\n    V_P = np.where(C_N > 0, 0, np.where(P_N > 0, P_N, 0))\n\n    # 4. Backward induction loop from t=N-1 to t=0\n    for i in range(N - 1, -1, -1):\n        # Asset prices at time t=i. There are i+1 nodes.\n        num_up_moves = np.arange(i, -1, -1)\n        num_down_moves = np.arange(0, i + 1, 1)\n        S_at_t = S0 * (u ** num_up_moves) * (d ** num_down_moves)\n        \n        # Immediate exercise payoffs at time t=i\n        C_t = np.maximum(S_at_t - K, 0)\n        P_t = np.maximum(K - S_at_t, 0)\n\n        # Continuation values: discounted expectation of values from t=i+1\n        # V_C and V_P currently hold values for time i+1 (length i+2)\n        # For a high-to-low price ordering, an \"up\" state corresponds to V[:-1]\n        # and a \"down\" state corresponds to V[1:].\n        tilde_V_C = beta * (p * V_C[:-1] + (1 - p) * V_C[1:])\n        tilde_V_P = beta * (p * V_P[:-1] + (1 - p) * V_P[1:])\n\n        # Solve the subgame at each node of time t=i\n        # Put holder's decision (if reached): exercise if P_t  continuation value\n        put_would_exercise = P_t > tilde_V_P\n        \n        # Call holder's effective continuation value, anticipating the put's response\n        call_continuation_value = np.where(put_would_exercise, 0, tilde_V_C)\n        \n        # Call holder's decision: exercise if C_t  effective continuation value\n        call_exercises = C_t > call_continuation_value\n        \n        # Determine equilibrium values for time t=i based on the sequential decisions\n        # If call exercises: payoffs are (C_t, 0)\n        # Else (call continues), if put exercises: payoffs are (0, P_t)\n        # Else (both continue): payoffs are (tilde_V_C, tilde_V_P)\n        v_c_next = np.where(call_exercises, C_t, np.where(put_would_exercise, 0, tilde_V_C))\n        v_p_next = np.where(call_exercises, 0, np.where(put_would_exercise, P_t, tilde_V_P))\n        \n        V_C, V_P = v_c_next, v_p_next\n    \n    # 5. After the loop, V_C and V_P contain the single value at t=0\n    return V_C[0], V_P[0]\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}