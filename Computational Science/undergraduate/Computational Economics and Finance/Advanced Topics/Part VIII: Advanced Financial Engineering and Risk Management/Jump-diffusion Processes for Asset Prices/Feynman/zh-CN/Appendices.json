{
    "hands_on_practices": [
        {
            "introduction": "正如 Black-Scholes 模型由一个偏微分方程 (PDE) 所描述，跳跃-扩散模型也有其自身的动态定价方程。本练习将引导你推导这个核心方程，它被称为偏积分-微分方程 (PIDE)，你将通过运用带跳跃过程的伊藤引理，深入理解资产价格的随机行为如何转化为期权价格必须满足的数学约束 。",
            "id": "1282213",
            "problem": "一个量化分析团队正在为一份欧式看涨期权开发一个定价模型。他们认识到，假定资产价格连续变动的标准 Black-Scholes 模型未能捕捉金融市场中观察到的突发性大幅价格冲击的风险。为解决此问题，他们决定使用 Merton 跳跃扩散过程对标的资产价格 $S_t$ 进行建模。\n\n在风险中性概率测度下，资产价格动态由以下随机微分方程给出：\n$$\n\\frac{dS_t}{S_{t-}} = (r - \\lambda k) dt + \\sigma dW_t + (Y-1)dN_t\n$$\n其中：\n- $S_{t-}$ 是资产在时间 $t$ 发生潜在跳跃前的价格。\n- $r$ 是恒定的无风险利率。\n- $\\sigma$ 是扩散部分的恒定波动率。\n- $W_t$ 是一个标准维纳过程。\n- $N_t$ 是一个强度为常数 $\\lambda > 0$ 的泊松过程，代表跳跃的到达。\n- $Y$ 是一个表示乘性跳跃幅度的随机变量，如果时间 $t$ 发生跳跃，价格将从 $S_{t-}$ 移动到 $S_t = Y S_{t-}$。跳跃幅度彼此独立，且与维纳过程无关。\n- 跳跃幅度的自然对数 $\\ln(Y)$ 假定服从均值为 $\\mu_J$、方差为 $\\sigma_J^2$ 的正态分布。换言之，$\\ln(Y) \\sim N(\\mu_J, \\sigma_J^2)$。\n- $k$ 是预期的相对跳跃幅度，定义为 $k = E[Y-1]$，其中期望是在 $Y$ 的风险中性分布下计算的。\n\n设 $C(S, t)$ 为该资产上执行价格为 $K$、到期时间为 $T$ 的欧式看涨期权的价格。您的任务是推导期权价格 $C(S, t)$ 在 $t < T$ 时必须满足的偏积分微分方程 (PIDE)。您的最终答案应该是完整的 PIDE，用 $C$ 及其偏导数、$S、t、r、\\sigma、\\lambda、\\mu_J$ 和 $\\sigma_J$ 表示。",
            "solution": "在所述的风险中性动态下，\n$$\n\\frac{dS_{t}}{S_{t-}}=\\left(r-\\lambda k\\right)dt+\\sigma dW_{t}+(Y-1)dN_{t},\n$$\n其中 $k=E[Y-1]$，期权价格 $C(S,t)$ 是在 $t<T$ 时关于 $(S,t)$ 的函数。对 $f(S,t)=C(S,t)$ 应用跳跃扩散的伊藤引理。对于一个带有扩散和复合泊松跳跃的过程，\n$$\ndC=C_{t}\\,dt+C_{S}\\,dS+\\frac{1}{2}C_{SS}\\,d[S^{c}]_{t}+\\left(C(S_{t}+\\Delta S_{t},t)-C(S_{t-},t)\\right),\n$$\n其中 $d[S^{c}]_{t}=\\sigma^{2}S_{t}^{2}dt$ 是连续部分的二次变分，当发生跳跃时 $\\Delta S_{t}=S_{t}-S_{t-}=S_{t-}(Y-1)$。使用 $dS_{t}=S_{t-}\\left((r-\\lambda k)dt+\\sigma dW_{t}\\right)$ (这是连续部分)，跳跃部分单独处理。\n完整的 $dS_t$ 表达式为 $S_{t-}((r-\\lambda k)dt + \\sigma dW_t) + S_{t-}(Y-1)dN_t$。\n将 $dC$ 分解为连续部分和跳跃部分：\n$$\ndC=\\left(C_{t}+(r-\\lambda k)S C_{S}+\\frac{1}{2}\\sigma^{2}S^{2}C_{SS}\\right)dt+\\sigma S C_{S}\\,dW_{t}+\\left(C(SY,t)-C(S,t)\\right)dN_{t}.\n$$\n\n在风险中性测度下，折现后期权价格是一个鞅。对于 $G(t)=\\exp(-rt)C(S_{t},t)$，其漂移（$dt$ 项的系数）必须为零。应用伊藤引理于 $G(t)$，或等价地，设置 $e^{-rt} \\times (\\text{drift of } C - rC) = 0$。\n$C$ 的漂移来自其 $dt$ 项和 $dN_t$ 项的期望：\n$E[dC]/dt = \\left(C_{t}+(r-\\lambda k)S C_{S}+\\frac{1}{2}\\sigma^{2}S^{2}C_{SS}\\right) + \\lambda E[C(SY,t)-C(S,t)]$。\n因此，对于鞅定价，总漂移必须等于 $rC$：\n$C_{t}+(r-\\lambda k)S C_{S}+\\frac{1}{2}\\sigma^{2}S^{2}C_{SS} + \\lambda E[C(SY,t)-C(S,t)] = rC$\n重新整理得到：\n$$\nC_{t}+(r-\\lambda k)S C_{S}+\\frac{1}{2}\\sigma^{2}S^{2}C_{SS}-rC+\\lambda\\,E\\!\\left[C(SY,t)-C(S,t)\\right]=0.\n$$\n因为 $\\ln(Y)\\sim N(\\mu_{J},\\sigma_{J}^{2})$，$Y$ 服从对数正态分布，其密度函数为\n$$\nf_{Y}(y)=\\frac{1}{y\\,\\sigma_{J}\\sqrt{2\\pi}}\\exp\\!\\left(-\\frac{(\\ln y-\\mu_{J})^{2}}{2\\sigma_{J}^{2}}\\right),\\quad y>0,\n$$\n且\n$$\nk=E[Y-1]=\\exp\\!\\left(\\mu_{J}+\\frac{1}{2}\\sigma_{J}^{2}\\right)-1.\n$$\n因此，该期望可以写成一个积分，并且 $k$ 可以用 $\\mu_{J}、\\sigma_{J}$ 表示，从而给出 PIDE (对于 $t<T$)：\n$$\nC_{t}+\\left(r-\\lambda\\left(\\exp\\!\\left(\\mu_{J}+\\frac{1}{2}\\sigma_{J}^{2}\\right)-1\\right)\\right)S C_{S}+\\frac{1}{2}\\sigma^{2}S^{2}C_{SS}-rC+\\lambda\\int_{0}^{\\infty}\\left[C(Sy,t)-C(S,t)\\right]\\frac{1}{y\\,\\sigma_{J}\\sqrt{2\\pi}}\\exp\\!\\left(-\\frac{(\\ln y-\\mu_{J})^{2}}{2\\sigma_{J}^{2}}\\right)dy=0.\n$$\n为了完整起见，终端条件是 $C(S,T)=\\max(S-K,0)$，尽管它本身不是 PIDE 的一部分。",
            "answer": "$$\\boxed{C_{t}+\\left(r-\\lambda\\left(\\exp\\!\\left(\\mu_{J}+\\frac{1}{2}\\sigma_{J}^{2}\\right)-1\\right)\\right)S\\,C_{S}+\\frac{1}{2}\\sigma^{2}S^{2}C_{SS}-r\\,C+\\lambda\\int_{0}^{\\infty}\\left[C(Sy,t)-C(S,t)\\right]\\frac{1}{y\\,\\sigma_{J}\\sqrt{2\\pi}}\\exp\\!\\left(-\\frac{(\\ln y-\\mu_{J})^{2}}{2\\sigma_{J}^{2}}\\right)\\,dy=0}$$"
        },
        {
            "introduction": "跳跃-扩散模型的核心优势在于其能够生成比正态分布更符合市场现实的“厚尾”收益率分布。本练习将让你亲手实现 Merton 模型的对数收益率概率密度函数（PDF），这个函数是一个由泊松分布加权的高斯密度函数的无穷混合。通过编程计算这个混合分布，你将直观地理解跳跃如何塑造资产收益的统计特征，并将抽象的数学模型转化为具体可感的数值结果 。",
            "id": "2422076",
            "problem": "考虑一个由 Merton 跳跃扩散模型建模的资产价格过程，其定义如下。设 $S_t$ 表示时间 $t \\ge 0$ 时的资产价格。在物理测度下，价格动态由以下随机微分方程 (SDE) 给出：\n$$\n\\frac{dS_t}{S_{t^-}} = \\mu \\, dt + \\sigma \\, dW_t + (J - 1) \\, dN_t,\n$$\n其中 $W_t$ 是一个标准布朗运动，$N_t$ 是一个强度为 $\\lambda > 0$ 的泊松过程，且独立于 $W_t$。跳跃幅度 $J$ 满足 $\\log J \\sim \\mathcal{N}(m, \\delta^2)$，其中 $\\delta \\ge 0$ 且 $m \\in \\mathbb{R}$。定义时间范围 $T > 0$ 内的对数回报率为 $X_T = \\log(S_T/S_0)$。设 $\\kappa = \\mathbb{E}[J - 1] = \\exp\\!\\left(m + \\tfrac{1}{2}\\delta^2\\right) - 1$。\n\n从第一性原理出发，通过对 $[0,T]$ 内的跳跃次数进行条件化，可以得到 $X_T$ 的精确分布表示。设 $N_T \\sim \\text{Poisson}(\\lambda T)$。那么\n$$\nX_T \\,\\big|\\, (N_T = n) \\sim \\mathcal{N}\\!\\left(\\left(\\mu - \\tfrac{1}{2}\\sigma^2 - \\lambda \\kappa\\right)T + n m,\\; \\sigma^2 T + n \\delta^2\\right),\n$$\n并且无条件概率密度函数 $f_{X_T}(x)$ 是高斯密度的泊松加权无限混合：\n$$\nf_{X_T}(x) = \\sum_{n=0}^{\\infty} \\underbrace{e^{-\\lambda T}\\frac{(\\lambda T)^n}{n!}}_{\\text{泊松权重}} \\cdot \\underbrace{\\frac{1}{\\sqrt{2\\pi(\\sigma^2 T + n\\delta^2)}} \\exp\\!\\left(-\\frac{\\left(x - \\left(\\mu - \\tfrac{1}{2}\\sigma^2 - \\lambda \\kappa\\right)T - n m\\right)^2}{2(\\sigma^2 T + n\\delta^2)}\\right)}_{\\text{在 }x\\text{ 处的高斯密度}}。\n$$\n\n任务。对于下方的每组参数，计算在指定的对数回报率点 $x$ 处的对数回报率密度 $f_{X_T}(x)$ 的值。你的程序每次评估输出的密度值必须精确到绝对误差不超过 $10^{-10}$。所有量均为无量纲量；将所有数值输出表示为浮点数。\n\n测试套件。使用以下参数集，每个参数集均指定为 $(\\mu, \\sigma, \\lambda, m, \\delta, T; \\ \\text{网格 } \\{x\\})$：\n- 情况 A（一般跳跃扩散）：$(0.08, \\ 0.2, \\ 0.5, \\ -0.1, \\ 0.2, \\ 1.0; \\ \\{-0.2, \\ 0.0, \\ 0.2\\})$。\n- 情况 B（无跳跃边界，$\\lambda = 0$）：$(0.05, \\ 0.25, \\ 0.0, \\ 0.0, \\ 0.1, \\ 1.0; \\ \\{-0.2, \\ 0.0, \\ 0.2\\})$。\n- 情况 C（确定性跳跃幅度，$\\delta = 0$）：$(0.06, \\ 0.15, \\ 1.2, \\ -0.05, \\ 0.0, \\ 0.5; \\ \\{-0.1, \\ 0.0, \\ 0.1\\})$。\n- 情况 D（短时间范围）：$(0.10, \\ 0.3, \\ 2.5, \\ -0.02, \\ 0.1, \\ 0.01; \\ \\{-0.02, \\ 0.0, \\ 0.02\\})$。\n\n必需的最终输出格式。你的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果必须是根据其网格排序的密度值的内部列表。因此，最终输出必须是代表一个包含四个列表的列表的单行，按情况 A 到 D 的顺序排列，例如：\n\"[ [f_A(x1),f_A(x2),f_A(x3)], [f_B(x1),f_B(x2),f_B(x3)], [f_C(x1),f_C(x2),f_C(x3)], [f_D(x1),f_D(x2),f_D(x3)] ]\"，但其中没有任何空格，即 \"[[...],[...],[...],[...]]\"。",
            "solution": "该问题是有效的。这是一个在计算金融领域中定义明确、具有科学依据的问题，没有矛盾或含糊之处。任务是计算由 Merton 跳跃扩散模型控制的资产价格的对数回报率的概率密度函数 (PDF) 值。\n\n资产价格 $S_t$ 遵循随机微分方程：\n$$\n\\frac{dS_t}{S_{t^-}} = \\mu \\, dt + \\sigma \\, dW_t + (J - 1) \\, dN_t\n$$\n如问题所述，时间范围 $T$ 内的对数回报率定义为 $X_T = \\log(S_T/S_0)$，其概率密度函数 $f_{X_T}(x)$ 由高斯密度的无限混合给出：\n$$\nf_{X_T}(x) = \\sum_{n=0}^{\\infty} \\mathbb{P}(N_T=n) \\cdot \\phi(x; \\mu_n, \\sigma_n^2)\n$$\n在此表达式中，$\\mathbb{P}(N_T=n) = e^{-\\lambda T}\\frac{(\\lambda T)^n}{n!}$ 是均值为 $\\lambda T$ 的泊松随机变量 $N_T$ 的概率质量函数，代表在区间 $[0, T]$ 内的跳跃次数。函数 $\\phi(x; \\mu_n, \\sigma_n^2)$ 是均值为 $\\mu_n$、方差为 $\\sigma_n^2$ 的正态分布的概率密度函数。第 $n$ 个高斯分量的参数由以下公式给出：\n$$\n\\mu_n = \\left(\\mu - \\tfrac{1}{2}\\sigma^2 - \\lambda \\kappa\\right)T + n m\n$$\n$$\n\\sigma_n^2 = \\sigma^2 T + n \\delta^2\n$$\n其中跳跃补偿项 $\\kappa$ 定义为 $\\kappa = \\mathbb{E}[J - 1] = \\exp(m + \\tfrac{1}{2}\\delta^2) - 1$。\n\n核心任务是以 $10^{-10}$ 的绝对精度对这个无限级数进行数值计算。由于该级数和没有闭式解，我们必须采用数值近似，这涉及到截断级数。\n\n所实施的方法是对级数项 $T_n(x) = \\mathbb{P}(N_T=n) \\cdot \\phi(x; \\mu_n, \\sigma_n^2)$ 进行迭代求和。求和从 $n = 0, 1, 2, \\dots$ 开始，当后续项的贡献在数值上变得无足轻重时终止。所有项 $T_n(x)$ 都是严格非负的。该级数的收敛速度很快，主要是由于泊松概率 $\\mathbb{P}(N_T=n)$ 随着 $n$ 的增加而衰减，特别是当 $n$ 的值大于均值 $\\lambda T$ 时。测试套件中提供的参数值导致 $\\lambda T$ 的值很小（最多为 $0.6$），这保证了非常快的收敛速度。\n\n对于每个参数集和评估点 $x$，算法流程如下：\n1.  首先，预先计算几个常数以优化计算循环：泊松均值 $\\Lambda = \\lambda T$、跳跃补偿项 $\\kappa$、条件均值的常数部分 $D = (\\mu - \\frac{1}{2}\\sigma^2 - \\lambda\\kappa)T$，以及条件方差的常数部分 $V = \\sigma^2 T$。\n2.  为了效率，单独处理 $\\lambda = 0$（无跳跃）的特殊情况。当 $\\lambda = 0$ 时，Merton 模型简化为几何布朗运动 (GBM) 模型。无限级数坍缩为其第一项 ($n=0$)，对数回报率密度变为单个高斯概率密度函数 $\\phi(x; (\\mu - \\frac{1}{2}\\sigma^2)T, \\sigma^2 T)$。\n3.  对于 $\\lambda > 0$ 的一般情况，总密度 $f_{X_T}(x)$ 初始化为零，并迭代地对级数项求和。\n4.  循环遍历跳跃次数 $n=0, 1, 2, \\dots$：\n    a. 计算泊松概率 $\\mathbb{P}(N_T=n)$。为保持数值稳定性并避免计算大数的阶乘，这里使用递推关系 $\\mathbb{P}(N_T=n) = \\mathbb{P}(N_T=n-1) \\cdot \\frac{\\Lambda}{n}$，从基本情况 $\\mathbb{P}(N_T=0) = e^{-\\Lambda}$ 开始。\n    b. 计算第 $n$ 个高斯分量的均值 $\\mu_n = D + nm$ 和方差 $\\sigma_n^2 = V + n\\delta^2$。\n    c. 在点 $x$ 处评估相应高斯概率密度函数 $\\phi(x; \\mu_n, \\sigma_n^2)$ 的值。这可以通过使用 SciPy 库中的 `scipy.stats.norm.pdf` 函数可靠地完成。\n    d. 计算级数的完整项 $T_n(x) = \\mathbb{P}(N_T=n) \\cdot \\phi(x; \\mu_n, \\sigma_n^2)$。\n    e. 如果计算出的项 $T_n(x)$ 低于 $10^{-16}$ 的绝对容差，则终止循环。该阈值远小于所要求的最终精度 $10^{-10}$，确保级数的截断尾部不会影响结果。为了增加稳健性，此检查仅在 $n$ 超过泊松分布的众数 ($n > \\Lambda$) 后执行。\n    f. 如果未满足终止条件，则将项 $T_n(x)$ 加到 $f_{X_T}(x)$ 的累加和中。\n5.  循环终止后，累积的和即为在 $x$ 处的最终密度值。\n\n此过程系统地应用于问题陈述中指定的所有参数集及其对应的评估网格。然后将所得密度格式化为最终输出所需的嵌套列表结构。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem, including test cases and output formatting.\n    \"\"\"\n\n    def compute_merton_pdf(params):\n        \"\"\"\n        Computes the Merton jump-diffusion model's log-return PDF for a given parameter set.\n        \"\"\"\n        mu, sigma, lam, m, delta, T, x_grid = params\n\n        # Handle the boundary case of no jumps (lambda=0), which is the Black-Scholes-Merton model.\n        if lam == 0.0:\n            drift = (mu - 0.5 * sigma**2) * T\n            variance = sigma**2 * T\n            \n            # The problem's constraints (sigma>0, T>0) ensure variance is positive.\n            std_dev = np.sqrt(variance)\n            return [norm.pdf(x, loc=drift, scale=std_dev) for x in x_grid]\n\n        # Pre-compute constants for the general jump-diffusion case (lambda > 0)\n        kappa = np.exp(m + 0.5 * delta**2) - 1\n        drift_base = (mu - 0.5 * sigma**2 - lam * kappa) * T\n        var_base = sigma**2 * T\n        lambda_T = lam * T\n\n        results = []\n        for x in x_grid:\n            total_pdf = 0.0\n            n = 0\n            \n            # Start with n=0 term: P(N_T=0) = exp(-lambda*T)\n            poisson_prob = np.exp(-lambda_T)\n\n            while True:\n                # Calculate mean and variance of the n-th Gaussian component\n                cond_mean = drift_base + n * m\n                cond_var = var_base + n * delta**2\n                \n                # The variance is always > 0 for test cases, so sqrt is safe\n                cond_std = np.sqrt(cond_var)\n\n                # Evaluate the density of the n-th Gaussian at point x\n                gaussian_pdf = norm.pdf(x, loc=cond_mean, scale=cond_std)\n                \n                # The term for this n in the infinite sum\n                term = poisson_prob * gaussian_pdf\n                \n                # Check for convergence. Stop when the term's contribution is negligible.\n                # An absolute tolerance on the term is sufficient here. 1e-16 is a safe\n                # margin for a required absolute error of 1e-10.\n                if term  1e-16 and n > lambda_T:\n                    break\n                \n                total_pdf += term\n                \n                # Prepare for the next iteration\n                n += 1\n                # Update Poisson probability using the recurrence relation: P(k) = P(k-1) * lambda*T / k\n                poisson_prob = poisson_prob * lambda_T / n\n\n                # Safety break to prevent infinite loops with unusual parameters\n                if n > 300:\n                    break\n            \n            results.append(total_pdf)\n        \n        return results\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (Parameter set: mu, sigma, lambda, m, delta, T, x_grid)\n        # Case A (general jump-diffusion)\n        (0.08, 0.2, 0.5, -0.1, 0.2, 1.0, [-0.2, 0.0, 0.2]),\n        # Case B (no jumps boundary, lambda = 0)\n        (0.05, 0.25, 0.0, 0.0, 0.1, 1.0, [-0.2, 0.0, 0.2]),\n        # Case C (deterministic jump size, delta = 0)\n        (0.06, 0.15, 1.2, -0.05, 0.0, 0.5, [-0.1, 0.0, 0.1]),\n        # Case D (short horizon)\n        (0.10, 0.3, 2.5, -0.02, 0.1, 0.01, [-0.02, 0.0, 0.02]),\n    ]\n\n    all_results = []\n    for case_params in test_cases:\n        case_results = compute_merton_pdf(case_params)\n        all_results.append(case_results)\n\n    # Final print statement in the exact required format.\n    result_strings = []\n    for res_list in all_results:\n        # Convert each float in the inner list to its standard string representation.\n        inner_list_str = \"[\" + \",\".join(map(str, res_list)) + \"]\"\n        result_strings.append(inner_list_str)\n    \n    final_output = \"[\" + \",\".join(result_strings) + \"]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "理论模型必须与市场数据相结合才能发挥其在定价和风险管理中的作用，这个过程被称为模型校准。本练习将指导你完成一个典型的量化金融任务：通过最小化模型价格与市场价格之间的误差，来校准 Merton 模型中的跳跃强度参数 $\\lambda$。你将从零开始实现一种高效的优化算法——黄金分割搜索法，从而将理论知识应用于解决实际的参数估计问题 。",
            "id": "2398577",
            "problem": "编写一个完整、可运行的程序，该程序使用黄金分割法 (GSS) 来校准 Merton 跳跃扩散模型中的跳跃强度参数 $\\lambda$。校准过程通过最小化模型价格与虚值欧式看涨期权的合成市场价格之间的定价误差平方和来完成。您的程序必须从第一性原理出发，实现定价模型和单变量优化器，并且不得依赖任何外部优化器。\n\n基本原理：\n- 在风险中性测度下，执行价格为 $K$、到期日为 $T$ 的欧式看涨期权的价格由风险中性期望 $C = e^{-r T} \\mathbb{E}\\left[(S_T - K)^{+}\\right]$ 给出。\n- 在 Merton 跳跃扩散模型中，风险中性测度下的资产动态为\n$$\n\\frac{dS_t}{S_{t^-}} = \\left(r - q - \\lambda k\\right)\\,dt + \\sigma\\, dW_t + (J - 1)\\, dN_t,\n$$\n其中，$r$ 是连续复利无风险利率，$q$ 是连续股息率，$\\sigma$ 是扩散波动率，$N_t$ 是强度为 $\\lambda$ 的泊松过程，$J$ 是跳跃幅度，且 $\\ln J \\sim \\mathcal{N}(\\mu_J,\\sigma_J^2)$。跳跃补偿项为 $k = \\mathbb{E}[J - 1] = e^{\\mu_J + \\tfrac{1}{2}\\sigma_J^2} - 1$。\n- 以 $N_T = n$ 为条件，可以得到对数正态分布的泊松混合，从而得出期权价格的闭式混合形式，表示为 Black–Scholes 项的加权和。\n\n待实现的定价模型：\n- 定义 $k = e^{\\mu_J + \\tfrac{1}{2}\\sigma_J^2} - 1$，有效净漂移 $b(\\lambda) = r - q - \\lambda k$，以及每次跳跃的缩放因子 $s_J = 1 + k = e^{\\mu_J + \\tfrac{1}{2}\\sigma_J^2}$。\n- 对于每个非负整数 $n$，定义条件方差参数\n$$\n\\sigma_n = \\sqrt{\\sigma^2 + \\frac{n\\,\\sigma_J^2}{T}},\n$$\n和调整后的即期价格\n$$\nS_n = S_0\\, s_J^{\\,n}.\n$$\n- 泊松权重为\n$$\n\\pi_n(\\lambda) = e^{-\\lambda T}\\frac{(\\lambda T)^n}{n!}.\n$$\n- 具有有效净漂移 $b$ 的 Black–Scholes (BS) 看涨期权价格为\n$$\nC_{\\text{BS}}(S,K,r,q,\\sigma_n,T;b) = S\\,e^{(b-r)T}\\,\\Phi(d_1) - K\\,e^{-rT}\\,\\Phi(d_2),\n$$\n其中\n$$\nd_1 = \\frac{\\ln\\left(\\frac{S}{K}\\right) + \\left(b + \\tfrac{1}{2}\\sigma_n^2\\right)T}{\\sigma_n \\sqrt{T}}, \\quad d_2 = d_1 - \\sigma_n \\sqrt{T},\n$$\n且 $\\Phi(\\cdot)$ 是标准正态累积分布函数。\n- Merton 看涨期权价格为\n$$\nC_{\\text{Merton}}(\\lambda; S_0, K, r, q, \\sigma, \\mu_J, \\sigma_J, T) = \\sum_{n=0}^{\\infty} \\pi_n(\\lambda)\\, C_{\\text{BS}}(S_n, K, r, q, \\sigma_n, T; b(\\lambda)).\n$$\n- 对于数值实现，通过以下方式截断无穷级数：\n  - 对 $n = 0,1,2,\\dots$ 进行求和，直到增量泊松权重 $\\pi_n(\\lambda)$ 低于 $10^{-12}$，或\n  - 达到硬性上限 $n_{\\max} = 50$，\n  以先发生者为准。\n\n校准目标：\n- 给定一组虚值执行价格 $\\{K_i\\}_{i=1}^m$ 和相应的市场看涨期权价格 $\\{C^{\\text{mkt}}_i\\}_{i=1}^m$，定义目标函数\n$$\nJ(\\lambda) = \\sum_{i=1}^m \\left( C_{\\text{Merton}}(\\lambda; S_0, K_i, r, q, \\sigma, \\mu_J, \\sigma_J, T) - C^{\\text{mkt}}_i \\right)^2.\n$$\n- 通过使用黄金分割法在闭区间 $\\lambda \\in [0, 3]$ 上最小化 $J(\\lambda)$ 来校准 $\\lambda$。当区间长度小于 $10^{-6}$ 或迭代次数达到 200 次后终止，以先到者为准。\n\n数值细节：\n- 使用 $\\Phi(x) = \\tfrac{1}{2}\\left(1 + \\operatorname{erf}\\left(\\tfrac{x}{\\sqrt{2}}\\right)\\right)$。\n- 所有期权均为欧式看涨期权，测试套件中的所有执行价格均为严格虚值：$K > S_0$。\n- 不得使用任何随机性；所有数值必须以确定性方式计算。\n\n测试套件：\n对于以下每种情况，首先使用给定的“真实”$\\lambda$ 和指定的数值设置，通过评估 Merton 价格来生成合成的市场价格。然后，舍弃该真实值，并应用您的校准程序从合成的市场价格中恢复 $\\widehat{\\lambda}$。\n\n- 情况 A (理想路径)：\n  - $S_0 = 100.0$, $r = 0.02$, $q = 0.0$, $T = 0.75$,\n  - $\\sigma = 0.20$, $\\mu_J = -0.10$, $\\sigma_J = 0.25$,\n  - 执行价格 $K \\in \\{105.0, 110.0, 120.0\\}$,\n  - 真实 $\\lambda_{\\text{true}} = 0.60$。\n\n- 情况 B (边界情况，无跳跃)：\n  - $S_0 = 100.0$, $r = 0.01$, $q = 0.0$, $T = 1.00$,\n  - $\\sigma = 0.15$, $\\mu_J = -0.20$, $\\sigma_J = 0.30$,\n  - 执行价格 $K \\in \\{102.0, 110.0, 125.0\\}$,\n  - 真实 $\\lambda_{\\text{true}} = 0.00$。\n\n- 情况 C (较高跳跃活动性)：\n  - $S_0 = 100.0$, $r = 0.03$, $q = 0.0$, $T = 2.00$,\n  - $\\sigma = 0.18$, $\\mu_J = 0.05$, $\\sigma_J = 0.20$,\n  - 执行价格 $K \\in \\{105.0, 115.0, 130.0, 150.0\\}$,\n  - 真实 $\\lambda_{\\text{true}} = 1.20$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含三种情况校准后的强度，以逗号分隔的列表形式包含在方括号内，每个值按 A、B、C 的顺序排列，并四舍五入到六位小数。例如，输出必须如下所示：\n$$\n[\\widehat{\\lambda}_A,\\widehat{\\lambda}_B,\\widehat{\\lambda}_C],\n$$\n每个 $\\widehat{\\lambda}$ 四舍五入到 6 位小数（无单位）。",
            "solution": "该问题已经过严格验证，并被认为是有效的。其公式具有科学依据，基于金融工程领域的标准模型——Merton 跳跃扩散模型。该问题是适定的，为一项确定性优化任务提供了一套完整且内部一致的定义、参数和数值程序。目标以数学精度陈述，没有任何歧义或主观内容。唯一解所需的所有必要组成部分均已提供。\n\n任务是校准 Merton 跳跃扩散模型的跳跃强度参数 $\\lambda$。这是通过最小化一个目标函数 $J(\\lambda)$ 来完成的，该函数表示由模型生成的期权价格与一组合成市场价格之间的差值平方和。优化被约束在区间 $\\lambda \\in [0, 3]$ 内，并且必须使用从第一性原理实现的黄金分割法 (GSS) 算法来执行。\n\n问题的核心涉及两个主要组成部分的实现：Merton 定价模型和 GSS 优化器。\n\n首先，我们按照规定实现欧式看涨期权的定价模型。Merton 价格 $C_{\\text{Merton}}$ 是在期权存续期 $T$ 内发生 $n$ 次跳跃的条件下，对 Black-Scholes 类型期权价格的加权求和。该价格由以下公式给出：\n$$\nC_{\\text{Merton}}(\\lambda) = \\sum_{n=0}^{\\infty} \\pi_n(\\lambda)\\, C_{\\text{BS}}(S_n, K, r, q, \\sigma_n, T; b(\\lambda))\n$$\n泊松权重 $\\pi_n(\\lambda)$ 表示发生 $n$ 次跳跃的概率，其公式为：\n$$\n\\pi_n(\\lambda) = e^{-\\lambda T}\\frac{(\\lambda T)^n}{n!}\n$$\n条件 Black-Scholes 部分 $C_{\\text{BS}}$ 是为调整后的即期价格 $S_n = S_0\\, s_J^{\\,n}$ 和条件波动率 $\\sigma_n = \\sqrt{\\sigma^2 + n\\,\\sigma_J^2/T}$ 定义的。每次跳跃的缩放因子为 $s_J = e^{\\mu_J + \\frac{1}{2}\\sigma_J^2}$。该部分价格由以下公式给出：\n$$\nC_{\\text{BS}} = S_n\\,e^{(b(\\lambda)-r)T}\\,\\Phi(d_1) - K\\,e^{-rT}\\,\\Phi(d_2)\n$$\n其参数 $d_1$ 和 $d_2$ 取决于有效净漂移 $b(\\lambda) = r - q - \\lambda k$，其中 $k = s_J - 1$。$d_1$ 的具体公式为：\n$$\nd_1 = \\frac{\\ln\\left(\\frac{S_n}{K}\\right) + \\left(b(\\lambda) + \\tfrac{1}{2}\\sigma_n^2\\right)T}{\\sigma_n \\sqrt{T}}\n$$\n且 $d_2 = d_1 - \\sigma_n \\sqrt{T}$。标准正态累积分布函数 $\\Phi(\\cdot)$ 使用误差函数 $\\operatorname{erf}(\\cdot)$ 计算，即 $\\Phi(x) = \\frac{1}{2}\\left(1 + \\operatorname{erf}\\left(\\frac{x}{\\sqrt{2}}\\right)\\right)$。在数值实现中，无穷级数被截断。求和从 $n=0, 1, 2, \\dots$ 开始，当项的泊松权重 $\\pi_n(\\lambda)$ 低于 $10^{-12}$ 的容差，或已包含的最大项数达到 $n_{\\max}=50$ 时终止，以先发生者为准。为避免大阶乘导致的数值溢出，使用一种稳健的迭代方法来计算泊松权重，即 $\\pi_n(\\lambda) = \\pi_{n-1}(\\lambda) \\cdot \\frac{\\lambda T}{n}$。\n\n其次，我们将校准目标函数 $J(\\lambda)$ 定义为一组具有不同执行价格 $\\{K_i\\}_{i=1}^m$ 的 $m$ 个期权的误差平方和 (SSE)：\n$$\nJ(\\lambda) = \\sum_{i=1}^m \\left( C_{\\text{Merton}}(\\lambda; K_i) - C^{\\text{mkt}}_i \\right)^2\n$$\n其中 $C^{\\text{mkt}}_i$ 是给定的合成市场价格。\n\n第三，我们实现黄金分割法 (GSS) 算法来最小化 $J(\\lambda)$。GSS 是一种无导数优化方法，通过迭代缩小搜索区间来寻找单峰函数的极值。搜索从区间 $[a, b] = [0, 3]$ 开始。选择两个内部点 $c$ 和 $d$，根据黄金比例 $\\phi = (1+\\sqrt{5})/2 \\approx 1.618$ 来分割区间。\n$$\nc = b - \\frac{b-a}{\\phi} \\quad \\text{and} \\quad d = a + \\frac{b-a}{\\phi}\n$$\n在这些点上评估目标函数。如果 $J(c)  J(d)$，则最小值必定位于区间 $[a, d]$ 内，因此新的搜索区间变为 $[a, d]$。否则，如果 $J(c) \\ge J(d)$，新的区间变为 $[c, b]$。此过程在每一步都将区间长度缩小一个因子 $1/\\phi$，从而保证收敛。当区间长度 $|b-a|$ 小于 $10^{-6}$ 的容差或达到最大迭代次数 200 次时，算法终止。最终区间的中点 $(a+b)/2$作为校准估计值 $\\widehat{\\lambda}$ 返回。\n\n整体流程包括：首先，通过在给定的“真实”强度 $\\lambda_{\\text{true}}$ 下评估指定的 $C_{\\text{Merton}}$ 函数，为每个测试用例生成合成市场价格 $C^{\\text{mkt}}_i$。然后，概念上舍弃这个真实值，并采用 GSS 算法通过最小化 $J(\\lambda)$ 来找到能够最佳再现这些合成价格的 $\\widehat{\\lambda}$。对所有指定的测试用例重复此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import erf\n\n# Define a global constant for the Golden Ratio.\nGR = (1 + np.sqrt(5)) / 2\n\ndef norm_cdf(x):\n    \"\"\"\n    Computes the standard normal cumulative distribution function using the error function.\n    All mathematical entities must be in LaTeX: Phi(x) = 1/2 * (1 + erf(x/sqrt(2))).\n    \"\"\"\n    return 0.5 * (1 + erf(x / np.sqrt(2)))\n\ndef merton_bs_component(S, K, r, q, T, sigma_n, b):\n    \"\"\"\n    Computes a single Black-Scholes-like component of the Merton price series,\n    using the specific functional form provided in the problem statement.\n    \"\"\"\n    if sigma_n = 0 or T = 0:\n        # Simplified payoff for non-positive time or volatility\n        if b  r:\n             # If drift is high, it's effectively S - K*exp(-b*T) etc, but this is an edge case\n             return np.maximum(0, S * np.exp((b-r)*T) - K * np.exp(-r*T))\n        return np.maximum(0, S - K)\n\n    d1 = (np.log(S / K) + (b + 0.5 * sigma_n**2) * T) / (sigma_n * np.sqrt(T))\n    d2 = d1 - sigma_n * np.sqrt(T)\n    # Corrected pricing formula for a general risk-neutral drift 'b'\n    price = S * np.exp((b - r) * T) * norm_cdf(d1) - K * np.exp(-r * T) * norm_cdf(d2)\n    return price\n\ndef merton_price(lambda_val, S0, K, r, q, T, sigma, mu_J, sigma_J):\n    \"\"\"\n    Calculates the Merton jump-diffusion model call option price. The infinite sum\n    is truncated based on the Poisson weight or a maximum number of terms.\n    \"\"\"\n    # Jump-related parameters, constant with respect to lambda\n    k = np.exp(mu_J + 0.5 * sigma_J**2) - 1\n    s_J = 1 + k\n    \n    # Lambda-dependent effective drift\n    b = r - q - lambda_val * k\n    \n    total_price = 0.0\n    lambda_T = lambda_val * T\n    \n    n_max = 50\n    weight_tol = 1e-12\n\n    # Term for n=0 jumps (pure diffusion component)\n    poisson_weight = np.exp(-lambda_T)\n    sigma_0 = sigma\n    component_price_0 = merton_bs_component(S0, K, r, q, T, sigma_0, b)\n    total_price += poisson_weight * component_price_0\n    \n    # Terms for n=1 to n_max jumps\n    for n in range(1, n_max + 1):\n        poisson_weight *= lambda_T / n\n        if poisson_weight  weight_tol:\n            break\n        \n        sigma_n = np.sqrt(sigma**2 + n * sigma_J**2 / T)\n        S_n = S0 * (s_J**n)\n        \n        component_price = merton_bs_component(S_n, K, r, q, T, sigma_n, b)\n        total_price += poisson_weight * component_price\n        \n    return total_price\n\ndef objective_function(lambda_val, S0, r, q, T, sigma, mu_J, sigma_J, strikes, market_prices):\n    \"\"\"\n    Calculates the sum of squared errors (SSE) between model prices and market prices.\n    This is the function to be minimized.\n    \"\"\"\n    sse = 0.0\n    for i in range(len(strikes)):\n        model_price = merton_price(lambda_val, S0, strikes[i], r, q, T, sigma, mu_J, sigma_J)\n        sse += (model_price - market_prices[i])**2\n    return sse\n\ndef golden_section_search(f, a, b, tol=1e-6, max_iter=200):\n    \"\"\"\n    Performs Golden-Section Search to find the minimum of a univariate function 'f'\n    on the interval [a, b].\n    \"\"\"\n    inv_phi = 1 / GR\n    \n    # Initialize interior points\n    c = b - inv_phi * (b - a)\n    d = a + inv_phi * (b - a)\n    \n    fc = f(c)\n    fd = f(d)\n    \n    for _ in range(max_iter):\n        if abs(b - a)  tol:\n            break\n            \n        if fc  fd:\n            b = d\n            d = c\n            fd = fc\n            c = b - inv_phi * (b - a)\n            fc = f(c)\n        else:\n            a = c\n            c = d\n            fc = fd\n            d = a + inv_phi * (b - a)\n            fd = f(d)\n            \n    return (a + b) / 2\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite, calibrate lambda for each case, and print results.\n    \"\"\"\n    test_cases = [\n        # Case A: Happy path\n        {'S0': 100.0, 'r': 0.02, 'q': 0.0, 'T': 0.75, 'sigma': 0.20,\n         'mu_J': -0.10, 'sigma_J': 0.25, 'strikes': [105.0, 110.0, 120.0],\n         'lambda_true': 0.60},\n        # Case B: Boundary case, no jumps\n        {'S0': 100.0, 'r': 0.01, 'q': 0.0, 'T': 1.00, 'sigma': 0.15,\n         'mu_J': -0.20, 'sigma_J': 0.30, 'strikes': [102.0, 110.0, 125.0],\n         'lambda_true': 0.00},\n        # Case C: Higher jump activity\n        {'S0': 100.0, 'r': 0.03, 'q': 0.0, 'T': 2.00, 'sigma': 0.18,\n         'mu_J': 0.05, 'sigma_J': 0.20, 'strikes': [105.0, 115.0, 130.0, 150.0],\n         'lambda_true': 1.20}\n    ]\n    \n    calibrated_lambdas = []\n    \n    for case in test_cases:\n        # 1. Generate synthetic market prices using the true lambda\n        market_prices = [\n            merton_price(case['lambda_true'], case['S0'], K, case['r'], case['q'], case['T'],\n                         case['sigma'], case['mu_J'], case['sigma_J'])\n            for K in case['strikes']\n        ]\n\n        # 2. Define objective function for this case, capturing all parameters except lambda\n        obj_func = lambda l: objective_function(\n            l, case['S0'], case['r'], case['q'], case['T'], case['sigma'],\n            case['mu_J'], case['sigma_J'], case['strikes'], market_prices\n        )\n\n        # 3. Run Golden-Section Search to find the calibrated lambda\n        lambda_hat = golden_section_search(obj_func, a=0.0, b=3.0, tol=1e-6, max_iter=200)\n        calibrated_lambdas.append(lambda_hat)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join([f'{l:.6f}' for l in calibrated_lambdas])}]\")\n\nsolve()\n```"
        }
    ]
}