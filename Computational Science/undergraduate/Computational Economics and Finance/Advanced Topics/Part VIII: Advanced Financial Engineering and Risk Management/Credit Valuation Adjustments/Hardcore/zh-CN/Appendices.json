{
    "hands_on_practices": [
        {
            "introduction": "蒙特卡洛模拟是为复杂衍生品及信用估值调整 (Credit Valuation Adjustment, CVA) 等估值调整定价的基石。本练习  将指导你从零开始构建一个CVA计算引擎，通过模拟资产价格路径，体会向量化计算（一种模拟图形处理器 (GPU) 并行计算思想的关键技术）带来的巨大性能提升。这项实践不仅能让你掌握CVA的核心计算方法，还能培养你在计算金融领域至关重要的性能优化意识。",
            "id": "2386203",
            "problem": "要求您在蒙特卡洛框架下，为一个信用估值调整（CVA）构建一个小型、独立的计算引擎，并比较两种计算后端：一种是使用显式循环的标量中央处理器（CPU）实现，另一种是模拟图形处理器（GPU）批量并行执行、使用数组编程的单指令多数据（SIMD）风格的矢量化后端。在实际图形处理器（GPU）执行不可用的情况下，矢量化是单指令多数据（SIMD）并行性的标准且可靠的代理，它能够实现与将卸载到 GPU 内核相同的算法结构。\n\n从以下基本基础开始：\n- 在风险中性测度下，单个风险资产的即期价格过程由几何布朗运动（GBM）建模：$$dS_t = (r - q) S_t \\, dt + \\sigma S_t \\, dW_t,$$ 其中 $S_t$ 是即期价格，$r$ 是连续复利无风险利率，$q$ 是连续股息收益率，$\\sigma$ 是波动率，$W_t$ 是标准布朗运动。\n- 在时间 $t$，一份于到期日 $T$ 交割、执行价为 $K$、连续股息收益率为 $q$ 的多头远期合约的价值为 $$V_t = S_t e^{-q (T - t)} - K e^{-r (T - t)}.$$\n- 在时间 $t$ 的未抵押风险暴露为 $$E_t = \\max(V_t, 0).$$\n- 在恒定风险率（违约强度）$\\lambda$ 和回收率 $R$ 的情况下，违约损失率为 $$\\text{LGD} = 1 - R,$$ 生存概率为 $$\\mathbb{S}(t) = e^{-\\lambda t}.$$ 风险中性违约密度为 $$f(t) = \\lambda e^{-\\lambda t}.$$\n- 在独立性假设下，连续时间 CVA 为 $$\\text{CVA} = \\text{LGD} \\int_0^T D(0,t) \\, \\mathbb{E}[E_t] \\, f(t) \\, dt,$$ 其中 $$D(0,t) = e^{-r t}$$ 是贴现因子，$$\\mathbb{E}[E_t]$$ 是预期风险暴露。\n\n任务：\n1) 使用均匀时间网格 $t_i = i \\Delta t$（其中 $i = 1, 2, \\dots, M$，$ \\Delta t = T/M$）和用于预期风险暴露的蒙特卡洛估计量，为 CVA 推导一个一致的离散时间估计量。您的推导必须从上述基本基础开始，且不得依赖任何快捷公式。\n2) 为该估计量实现两种后端：\n   - 一种使用显式嵌套循环遍历路径和时间的标量 CPU 后端。\n   - 一种矢量化后端，通过将相同操作一次性应用于整个模拟状态数组（即单指令多数据）来模拟 GPU 风格的并行性。\n3) 对两种后端使用相同的随机数，以确保任何差异都源于计算策略，而非不同的随机抽样。\n4) 通过测量挂钟时间来对两种后端进行基准测试。您必须在内部计算时间，但程序的最终输出必须仅包含下面要求的 CVA 值。\n5) 对于每个测试用例，以与 $S_0$ 和 $K$ 相同的货币单位计算 CVA，并以浮点数形式返回。\n\n离散化和估计量设计约束：\n- 对数形式的 GBM 使用 Euler–Maruyama 精确步长：$$S_{t+\\Delta t} = S_t \\exp\\!\\Big(\\big((r - q) - \\tfrac{1}{2}\\sigma^2\\big) \\Delta t + \\sigma \\sqrt{\\Delta t} \\, Z\\Big),$$ 其中 $Z \\sim \\mathcal{N}(0,1)$ 在时间步和路径间独立。\n- 使用在右端点求值的黎曼和来近似积分：$$\\text{CVA} \\approx (1-R) \\sum_{i=1}^{M} e^{-r t_i} \\, \\widehat{\\mathbb{E}}[E_{t_i}] \\, \\lambda e^{-\\lambda t_i} \\, \\Delta t,$$ 其中 $\\widehat{\\mathbb{E}}[E_{t_i}]$ 是 $E_{t_i}$ 在所有模拟路径上的蒙特卡洛平均值。\n- 所有概率和利率必须以小数形式表示（而非百分比）。\n\n测试套件：\n实现您的程序，为以下参数集计算 CVA。每个测试用例是一个元组 $(S_0, K, T, r, q, \\sigma, \\lambda, R, N, M, \\text{seed})$：\n- 用例 A (happy path): $(\\$100.0, \\$100.0, 1.0, 0.02, 0.0, 0.2, 0.02, 0.4, 20000, 50, 20240501)$\n- 用例 B (zero hazard boundary): $(\\$100.0, \\$100.0, 1.0, 0.02, 0.0, 0.2, 0.0, 0.4, 20000, 50, 20240501)$\n- 用例 C (full recovery boundary): $(\\$100.0, \\$100.0, 1.0, 0.02, 0.0, 0.2, 0.02, 1.0, 20000, 50, 20240501)$\n- 用例 D (deterministic exposure check): $(\\$100.0, \\$90.0, 1.0, 0.01, 0.0, 0.0, 0.05, 0.4, 5000, 50, 7)$\n\n实现要求：\n- 对于每个测试用例，在两个后端中使用相同的标准正态抽样矩阵，以便任何数值差异（如果存在）仅归因于计算策略。\n- 在内部测量并记录用例 A 的每个后端的运行时间。不应打印任何计时结果，但必须进行计算。\n- 对于每个测试用例，仅输出由矢量化后端计算的 CVA，四舍五入到六位小数。如果某个用例在数学上意味着 CVA 为零（例如，零风险率或零违约损失率），则该用例的输出在四舍五入后必须恰好为 $0.0$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含四个测试用例的 CVA 结果，形式为方括号内用逗号分隔的列表，例如 $$[\\text{cva}_A,\\text{cva}_B,\\text{cva}_C,\\text{cva}_D],$$ 其中每个条目都是一个四舍五入到六位小数的浮点数。\n\n注意：\n- 没有物理单位；所有货币输出都与 $S_0$ 和 $K$ 使用相同的货币单位。\n- 不涉及角度。\n- 所有利率（$r$, $q$, $\\sigma$, $\\lambda$）和回收率 $R$ 都必须以小数形式传递，而不是百分比。",
            "solution": "所提出的问题是计算金融学中一个明确定义的任务，要求推导并实现信用估值调整（CVA）的蒙特卡洛估计量。在进行求解之前，需要进行正式的验证。\n\n**问题验证**\n\n**第1步：提取给定信息**\n\n问题提供了以下明确信息：\n\n- **资产价格过程**：风险中性测度下的几何布朗运动（GBM）：$$dS_t = (r - q) S_t \\, dt + \\sigma S_t \\, dW_t$$ 其中 $S_t$ 是即期价格，$r$ 是无风险利率，$q$ 是股息收益率，$\\sigma$ 是波动率，$W_t$ 是标准布朗运动。\n- **合约估值**：多头远期合约的价值为 $$V_t = S_t e^{-q (T - t)} - K e^{-r (T - t)}$$ 其中 $T$ 是到期日，$K$ 是执行价。\n- **风险暴露定义**：未抵押风险暴露为 $$E_t = \\max(V_t, 0).$$\n- **违约模型**：恒定风险率 $\\lambda$，回收率 $R$，违约损失率 $\\text{LGD} = 1 - R$，生存概率 $\\mathbb{S}(t) = e^{-\\lambda t}$，以及风险中性违约密度 $f(t) = \\lambda e^{-\\lambda t}$。\n- **CVA 公式**：独立性假设下的连续时间 CVA 为 $$\\text{CVA} = \\text{LGD} \\int_0^T D(0,t) \\, \\mathbb{E}[E_t] \\, f(t) \\, dt,$$ 其中 $D(0,t) = e^{-r t}$ 是贴现因子。\n- **离散化方案**：\n    - 时间网格：$t_i = i \\Delta t$，其中 $i = 1, 2, \\dots, M$，$ \\Delta t = T/M$。\n    - GBM 模拟步长：$$S_{t+\\Delta t} = S_t \\exp\\!\\Big(\\big((r - q) - \\tfrac{1}{2}\\sigma^2\\big) \\Delta t + \\sigma \\sqrt{\\Delta t} \\, Z\\Big),$$ 其中 $Z \\sim \\mathcal{N}(0,1)$。\n    - CVA 估计量：$$\\text{CVA} \\approx (1-R) \\sum_{i=1}^{M} e^{-r t_i} \\, \\widehat{\\mathbb{E}}[E_{t_i}] \\, \\lambda e^{-\\lambda t_i} \\, \\Delta t,$$ 其中 $\\widehat{\\mathbb{E}}[E_{t_i}]$ 是 $E_{t_i}$ 的蒙特卡洛平均值。\n- **测试套件**：四个参数集，每个都是一个元组 $(S_0, K, T, r, q, \\sigma, \\lambda, R, N, M, \\text{seed})$。\n    - A: $(\\$100.0, \\$100.0, 1.0, 0.02, 0.0, 0.2, 0.02, 0.4, 20000, 50, 20240501)$\n    - B: $(\\$100.0, \\$100.0, 1.0, 0.02, 0.0, 0.2, 0.0, 0.4, 20000, 50, 20240501)$\n    - C: $(\\$100.0, \\$100.0, 1.0, 0.02, 0.0, 0.2, 0.02, 1.0, 20000, 50, 20240501)$\n    - D: $(\\$100.0, \\$90.0, 1.0, 0.01, 0.0, 0.0, 0.05, 0.4, 5000, 50, 7)$\n\n**第2步：使用提取的给定信息进行验证**\n\n根据验证标准对问题进行评估。\n- **科学依据**：该问题基于量化金融的标准基石模型（GBM，Merton 式违约模型）。所提供的公式是正确且广泛使用的。该问题在科学上是合理的。\n- **适定性**：该问题结构完整，包含所有必要的输入、一个指定的数值方法（带有定义的路径离散器和积分近似的蒙特卡洛方法）以及一个明确的目标。对于给定的随机种子，该过程会产生唯一的数值解。该问题是适定的。\n- **客观性**：所有定义都是数学的，所有输入都是数值的。语言精确，没有主观性。该问题是客观的。\n- **其他缺陷**：问题陈述是自洽、一致且可行的。没有矛盾、歧义或依赖伪科学。该任务是计算经济学和金融学中的一个标准练习。\n\n**第3步：结论与行动**\n\n该问题是**有效的**。将构建一个解决方案。\n\n**解决方案：设计与实现**\n\n任务是为 CVA 推导一个离散估计量，并使用两种不同的计算范式（标量和矢量化）来实现它。\n\n**1. 离散化与估计量推导**\n\n推导从给定的连续时间 CVA 公式开始：\n$$ \\text{CVA} = \\text{LGD} \\int_0^T D(0,t) \\, \\mathbb{E}[E_t] \\, f(t) \\, dt $$\n代入给定的 LGD、贴现因子 $D(0,t)$ 和违约密度 $f(t)$ 的定义：\n$$ \\text{CVA} = (1-R) \\int_0^T e^{-rt} \\, \\mathbb{E}[E_t] \\, \\lambda e^{-\\lambda t} \\, dt $$\n问题要求使用右黎曼和在均匀时间网格上近似此积分。区间 $[0, T]$ 被划分为 $M$ 个宽度为 $\\Delta t = T/M$ 的子区间 $[t_{i-1}, t_i]$，其中 $t_i = i \\Delta t$，$i = 1, \\dots, M$。积分通过对被积函数在右端点 $t_i$ 的值求和来近似：\n$$ \\int_0^T g(t) \\, dt \\approx \\sum_{i=1}^M g(t_i) \\Delta t $$\n将此应用于 CVA 积分，得到离散估计量：\n$$ \\text{CVA} \\approx (1-R) \\sum_{i=1}^{M} \\left( e^{-r t_i} \\, \\mathbb{E}[E_{t_i}] \\, \\lambda e^{-\\lambda t_i} \\right) \\Delta t $$\n这与问题陈述中指定的公式相符。下一步是使用包含 $N$ 条路径的蒙特卡洛模拟来估计未来预期风险暴露 $\\mathbb{E}[E_{t_i}]$。期望值被其样本均值估计量 $\\widehat{\\mathbb{E}}[E_{t_i}]$ 替代：\n$$ \\widehat{\\mathbb{E}}[E_{t_i}] = \\frac{1}{N} \\sum_{j=1}^{N} E_{t_i}^{(j)} $$\n其中 $E_{t_i}^{(j)}$ 是第 $j$ 条模拟路径在时间 $t_i$ 的风险暴露。风险暴露是模拟资产价格 $S_{t_i}^{(j)}$ 的函数：\n$$ E_{t_i}^{(j)} = \\max\\left( V_{t_i}^{(j)}, 0 \\right) = \\max\\left( S_{t_i}^{(j)} e^{-q (T - t_i)} - K e^{-r (T - t_i)}, 0 \\right) $$\n每条路径 $S^{(j)}$ 都是从 $S_{t_0}^{(j)}=S_0$ 开始，使用对数价格 SDE 的精确解逐步生成的：\n$$ S_{t_i}^{(j)} = S_{t_{i-1}}^{(j)} \\exp\\left( \\left( (r - q) - \\frac{1}{2}\\sigma^2 \\right) \\Delta t + \\sigma \\sqrt{\\Delta t} \\, Z_{i,j} \\right) $$\n其中 $Z_{i,j}$ 是独立的标准正态随机变量。\n\n将这些部分组合起来，就得到了 CVA 估计量的完整计算公式。\n\n**2. 算法设计**\n\n基于推导出的估计量设计了两种计算后端。为了公平比较，两者都必须使用相同的基础标准正态抽样矩阵 $Z \\in \\mathbb{R}^{N \\times M}$。\n\n**标量（CPU）后端：**\n此方法使用显式的嵌套循环，这是传统 CPU 编程的典型特征。\n\n1.  初始化一个大小为 $M$ 的数组 `expected_exposures`，所有元素均为零。\n2.  外层循环遍历每条路径 $j$（从 $1$ 到 $N$）。\n3.  在外层循环内部，初始化路径的起始价格 `current_S = S_0`。\n4.  内层循环遍历每个时间步 $i$（从 $1$ 到 $M$）。\n5.  在内层循环内部：\n    a. 检索随机正态抽样 $Z_{i,j}$。\n    b. 使用 GBM 步长公式从 `current_S` 计算下一个资产价格 $S_{t_i}$。\n    c. 计算该时间步的风险暴露 $E_{t_i}$。\n    d. 将此风险暴露加到该时间步的运行总和中：`expected_exposures[i-1] += E_{t_i}`。\n    e. 更新 `current_S = S_{t_i}`。\n6.  外层循环完成后，将 `expected_exposures` 的每个元素除以 $N$ 以完成平均值的计算。\n7.  使用现已计算出的 `expected_exposures` 数组，对离散积分近似的各项求和，以计算最终的 CVA 值。\n\n**矢量化（SIMD/GPU风格）后端：**\n此方法利用数组编程一次性对整个向量或矩阵执行操作，模拟了像 GPU 这样的并行处理器的单指令多数据（SIMD）范式。\n\n1.  生成整个 $N \\times M$ 的标准正态抽样矩阵 $Z$。\n2.  初始化一个大小为 $N$ 的向量 `S_current`，所有元素均设为 $S_0$。\n3.  初始化一个大小为 $M$ 的结果向量 `cva_sum_terms`，所有元素均为零。\n4.  循环遍历每个时间步 $i$（从 $1$ 到 $M$）。\n5.  在循环内部：\n    a. 获取当前步长的随机抽样列向量 $Z_{:, i-1}$。\n    b. 在单个操作中更新包含 $N$ 个资产价格的整个 `S_current` 向量。\n    c. 同时计算包含 $N$ 个远期合约价值的向量 $V_{t_i}$。\n    d. 计算所有路径的 $N$ 个风险暴露向量 $E_{t_i} = \\max(V_{t_i}, 0)$。\n    e. 计算此风险暴露向量的平均值以得到 $\\widehat{\\mathbb{E}}[E_{t_i}]$。\n    f. 计算 CVA 被积函数的第 $i$ 项并将其存储在 `cva_sum_terms[i-1]` 中。\n6.  循环结束后，通过对 `cva_sum_terms` 向量求和并乘以常数 $\\lambda$、$(1-R)$ 和 $\\Delta t$ 来计算最终的 CVA。\n\n这种矢量化方法避免了对模拟路径的显式循环，代之以由 NumPy 等库提供的高度优化的低级数组操作。这通常会带来显著的性能提升。\n\n**3. 实现策略**\n\n解决方案将使用 Python 中的 NumPy 库来实现数值计算，特别是用于矢量化后端。对于每个测试用例，将为一个随机数生成器设定种子以确保可复现性。为某个用例生成的相同随机数矩阵将传递给标量和矢量化函数，以确保输出的任何差异（如果存在）仅由浮点算术顺序引起，而性能差异则由算法引起。用例 A 的两个后端的运行时间将通过 `time.perf_counter()` 来测量，以满足基准测试要求，尽管这些计时结果不会成为最终打印输出的一部分。来自矢量化后端的最终 CVA 值将按要求四舍五入到六位小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport time\n\ndef cva_scalar_cpu(S0, K, T, r, q, sigma, lambda_c, R, N, M, Z):\n    \"\"\"\n    Computes CVA using a scalar (loopy) implementation.\n    \"\"\"\n    dt = T / M\n    \n    if lambda_c == 0.0 or R == 1.0:\n        return 0.0\n\n    # Calculate Expected Exposures\n    expected_exposures = [0.0] * M\n    for j in range(N):  # Loop over paths\n        S_curr = S0\n        for i in range(M):  # Loop over time steps\n            drift = (r - q - 0.5 * sigma**2) * dt\n            diffusion = sigma * np.sqrt(dt) * Z[j, i]\n            S_curr *= np.exp(drift + diffusion)\n            \n            t = (i + 1) * dt\n            forward_val = S_curr * np.exp(-q * (T - t)) - K * np.exp(-r * (T - t))\n            exposure = max(forward_val, 0.0)\n            \n            expected_exposures[i] += exposure\n\n    for i in range(M):\n        expected_exposures[i] /= N\n\n    # Calculate CVA\n    cva_sum = 0.0\n    for i in range(M):\n        t = (i + 1) * dt\n        discount = np.exp(-r * t)\n        default_prob_density = lambda_c * np.exp(-lambda_c * t)\n        cva_sum += discount * expected_exposures[i] * default_prob_density\n\n    cva = (1 - R) * cva_sum * dt\n    return cva\n\ndef cva_vectorized_simd(S0, K, T, r, q, sigma, lambda_c, R, N, M, Z):\n    \"\"\"\n    Computes CVA using a vectorized (SIMD-style) implementation.\n    \"\"\"\n    dt = T / M\n    \n    if lambda_c == 0.0 or R == 1.0:\n        return 0.0\n\n    # Time grid\n    t = np.linspace(dt, T, M)\n    \n    # Generate asset price paths\n    S = np.zeros((N, M + 1))\n    S[:, 0] = S0\n    \n    drift = (r - q - 0.5 * sigma**2) * dt\n    diffusion = sigma * np.sqrt(dt)\n    \n    for i in range(M):\n        S[:, i + 1] = S[:, i] * np.exp(drift + diffusion * Z[:, i])\n    \n    S_paths = S[:, 1:] # Paths at t_1, ..., t_M\n    \n    # Calculate Exposures\n    forward_vals = S_paths * np.exp(-q * (T - t)) - K * np.exp(-r * (T - t))\n    exposures = np.maximum(forward_vals, 0)\n    \n    # Calculate Expected Exposures\n    expected_exposures = np.mean(exposures, axis=0)\n    \n    # Calculate CVA\n    discount = np.exp(-r * t)\n    default_prob_density = lambda_c * np.exp(-lambda_c * t)\n    integrand = (1 - R) * discount * expected_exposures * default_prob_density\n    \n    cva = np.sum(integrand) * dt\n    return cva\n\ndef solve():\n    \"\"\"\n    Main solver function to run test cases and produce the final output.\n    \"\"\"\n    # (S0, K, T, r, q, sigma, lambda_c, R, N, M, seed)\n    test_cases = [\n        (100.0, 100.0, 1.0, 0.02, 0.0, 0.2, 0.02, 0.4, 20000, 50, 20240501), # Case A\n        (100.0, 100.0, 1.0, 0.02, 0.0, 0.2, 0.0, 0.4, 20000, 50, 20240501),  # Case B\n        (100.0, 100.0, 1.0, 0.02, 0.0, 0.2, 0.02, 1.0, 20000, 50, 20240501),  # Case C\n        (100.0, 90.0, 1.0, 0.01, 0.0, 0.0, 0.05, 0.4, 5000, 50, 7),         # Case D\n    ]\n\n    results = []\n\n    # Process Case A separately to perform the required benchmark timing.\n    S0, K, T, r, q, sigma, lambda_c, R, N, M, seed = test_cases[0]\n    rng = np.random.default_rng(seed)\n    Z = rng.standard_normal(size=(N, M))\n    \n    # Time scalar implementation for Case A (computation must occur, but result is not printed)\n    start_time_scalar = time.perf_counter()\n    _ = cva_scalar_cpu(S0, K, T, r, q, sigma, lambda_c, R, N, M, Z)\n    end_time_scalar = time.perf_counter()\n    # scalar_time = end_time_scalar - start_time_scalar # For internal verification\n\n    # Time vectorized implementation for Case A and collect result\n    start_time_vec = time.perf_counter()\n    cva_A = cva_vectorized_simd(S0, K, T, r, q, sigma, lambda_c, R, N, M, Z)\n    end_time_vec = time.perf_counter()\n    # vec_time = end_time_vec - start_time_vec # For internal verification\n    \n    results.append(round(cva_A, 6))\n\n    # Process remaining cases (B, C, D) using only the vectorized backend for output\n    for case in test_cases[1:]:\n        S0, K, T, r, q, sigma, lambda_c, R, N, M, seed = case\n        rng = np.random.default_rng(seed)\n        Z = rng.standard_normal(size=(N, M))\n        cva = cva_vectorized_simd(S0, K, T, r, q, sigma, lambda_c, R, N, M, Z)\n        results.append(round(cva, 6))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了单个工具的估值后，我们将视角转向真实的投资组合管理。本练习  聚焦于计算“增量CVA”(Incremental CVA)，即衡量一笔新交易对整个投资组合交易对手风险的边际影响。通过这个练习，你将深入理解轧差 (netting) 的关键作用，即正负敞口如何相互抵消，从而显著改变整体风险状况。",
            "id": "2386214",
            "problem": "考虑信用估值调整 (CVA) 的单一交易对手方情景。设时间由离散网格 $\\{t_1,\\dots,t_N\\}$ 表示，其中 $t_0=0$。设无风险连续复利率为恒定的 $r$，交易对手方的违约强度（风险率）为恒定的 $\\lambda$，回收率为 $R$。定义生存函数为 $S(t)=\\exp(-\\lambda t)$，贴现因子为 $D(t)=\\exp(-r t)$。设区间 $(t_{k-1},t_k]$ 上的增量违约概率为 $\\Delta \\mathrm{PD}_k=S(t_{k-1})-S(t_k)$，其中 $S(t_0)=1$。对于一个确定性的净额结算组合风险暴露路径，设现有投资组合在 $t_k$ 时刻的（取正值前）风险暴露为 $E^{\\mathrm{old}}_k$，新增交易在 $t_k$ 时刻的（取正值前）风险暴露为 $E^{\\mathrm{new}}_k$。$t_k$ 时刻的净正风险暴露是对取正值前的净风险暴露应用 $\\max(x,0)$ 函数。使用离散时间近似，单边 CVA 为\n$$\n\\mathrm{CVA} = (1-R)\\sum_{k=1}^{N} D(t_k)\\,\\Big(\\max\\big(E_k,0\\big)\\Big)\\,\\Delta \\mathrm{PD}_k,\n$$\n其中 $E_k$ 表示 $t_k$ 时刻的相关净风险暴露。因增加新交易而产生的增量 CVA 为\n$$\n\\Delta \\mathrm{CVA} = \\mathrm{CVA}\\big(\\max(E^{\\mathrm{old}}+E^{\\mathrm{new}},0)\\big) - \\mathrm{CVA}\\big(\\max(E^{\\mathrm{old}},0)\\big).\n$$\n所有利率 $r$ 和 $\\lambda$ 均为以小数表示的年化率，时间 $t_k$ 以年为单位，风险暴露 $E^{\\mathrm{old}}_k$ 和 $E^{\\mathrm{new}}_k$ 以任意货币单位计量，最终答案必须以相同货币单位的小数形式报告。\n\n任务：对于下方的每个测试用例，计算如上定义的 $\\Delta \\mathrm{CVA}$。请精确使用给定的参数，并将所有数组视为按 $t_1,\\dots,t_N$ 的顺序排列。\n\n测试集：\n- 测试用例 $1$（考虑净额结算效应的一般情况）：$r=0.02$, $\\lambda=0.03$, $R=0.4$, $[t_1,t_2,t_3,t_4]=[0.5,1.0,1.5,2.0]$, $[E^{\\mathrm{old}}_k]_{k=1}^4=[10,8,6,4]$, $[E^{\\mathrm{new}}_k]_{k=1}^4=[-3,-2,1,2]$。\n- 测试用例 $2$（边界情况：零风险率）：$r=0.02$, $\\lambda=0.0$, $R=0.4$, $[t_1,t_2,t_3,t_4]=[0.5,1.0,1.5,2.0]$, $[E^{\\mathrm{old}}_k]_{k=1}^4=[2,-1,4,-2]$, $[E^{\\mathrm{new}}_k]_{k=1}^4=[1,-3,2,0]$。\n- 测试用例 $3$（所有风险暴露均为严格正值，零无风险利率，零回收率）：$r=0.0$, $\\lambda=0.1$, $R=0.0$, $[t_1,t_2,t_3,t_4]=[0.25,0.5,0.75,1.0]$, $[E^{\\mathrm{old}}_k]_{k=1}^4=[5,5,5,5]$, $[E^{\\mathrm{new}}_k]_{k=1}^4=[2,2,2,2]$。\n- 测试用例 $4$（边界情况：完全回收）：$r=0.05$, $\\lambda=0.2$, $R=1.0$, $[t_1,t_2,t_3]=[1.0,2.0,3.0]$, $[E^{\\mathrm{old}}_k]_{k=1}^3=[-1,2,3]$, $[E^{\\mathrm{new}}_k]_{k=1}^3=[4,-1,1]$。\n\n要求的最终输出格式：您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，按测试用例 $1$ 到 $4$ 的顺序排列，每个数字都精确四舍五入到小数点后六位（例如，$[0.123456,-0.000001,1.000000]$）。",
            "solution": "问题陈述已经过严格验证。我们发现其具有科学依据、提法恰当，并且没有矛盾或含糊之处。所提供的信用估值调整 (CVA) 的定义和公式是量化金融中使用的标准（尽管是简化了的）表示方法。指定测试用例的所有必要参数都已提供。因此，该问题被认定为**有效**。我们接下来将推导解决方案。\n\n目标是计算将一笔新交易添加至现有投资组合所产生的增量 CVA ($\\Delta \\mathrm{CVA}$)。$\\Delta \\mathrm{CVA}$ 定义为合并后投资组合的 CVA 与原始投资组合的 CVA 之差：\n$$\n\\Delta \\mathrm{CVA} = \\mathrm{CVA}(\\text{combined}) - \\mathrm{CVA}(\\text{original})\n$$\n\n对于给定的风险暴露概况，CVA 使用离散时间近似公式计算：\n$$\n\\mathrm{CVA} = (1-R)\\sum_{k=1}^{N} D(t_k)\\,\\Big(\\max\\big(E_k,0\\big)\\Big)\\,\\Delta \\mathrm{PD}_k\n$$\n其中：\n- $R$ 是回收率。\n- $N$ 是时间步数。\n- $t_k$ 是第 $k$ 步的时间（以年为单位）。\n- $E_k$ 是在 $t_k$ 时刻的净风险暴露。\n- $D(t_k)$ 是在 $t_k$ 时刻的无风险贴现因子。\n- $\\Delta \\mathrm{PD}_k$ 是时间区间 $(t_{k-1}, t_k]$ 上的增量违约概率。\n\n对于每个时间步 $k \\in \\{1, 2, \\dots, N\\}$，公式的各组成部分计算如下：\n\n1.  **贴现因子, $D(t_k)$**：这是在 $t_k$ 时刻将收到的一个货币单位的现值。在恒定无风险利率 $r$ 下，其公式为：\n    $$\n    D(t_k) = \\exp(-r \\cdot t_k)\n    $$\n\n2.  **增量违约概率, $\\Delta \\mathrm{PD}_k$**：这是交易对手方在存活至 $t_{k-1}$ 时刻的条件下，在区间 $(t_{k-1}, t_k]$ 内违约的概率。它由生存函数 $S(t) = \\exp(-\\lambda t)$ 导出，其中 $\\lambda$ 是恒定风险率。我们定义 $t_0 = 0$。\n    $$\n    \\Delta \\mathrm{PD}_k = S(t_{k-1}) - S(t_k) = \\exp(-\\lambda \\cdot t_{k-1}) - \\exp(-\\lambda \\cdot t_k)\n    $$\n\n3.  **正风险暴露, $\\max\\big(E_k,0\\big)$**：CVA 计算仅在风险暴露 $E_k$ 为正时适用，这意味着如果交易对手方违约，我们将遭受损失。对于原始投资组合，风险暴露为 $E_k^{\\mathrm{old}}$。对于合并后的投资组合，风险暴露是原始风险暴露和新增风险暴露之和，即 $E_k^{\\mathrm{comb}} = E_k^{\\mathrm{old}} + E_k^{\\mathrm{new}}$，这反映了净额结算的效果。\n\n整体算法如下：\n\n首先，计算原始投资组合的 CVA，即 $\\mathrm{CVA}^{\\mathrm{old}}$。\n$$\n\\mathrm{CVA}^{\\mathrm{old}} = (1-R)\\sum_{k=1}^{N} \\exp(-r t_k) \\cdot \\max\\big(E_k^{\\mathrm{old}}, 0\\big) \\cdot \\big(\\exp(-\\lambda t_{k-1}) - \\exp(-\\lambda t_k)\\big)\n$$\n\n其次，计算合并后投资组合的 CVA，即 $\\mathrm{CVA}^{\\mathrm{comb}}$。每个时间步的合并风险暴露为 $E_k^{\\mathrm{comb}} = E_k^{\\mathrm{old}} + E_k^{\\mathrm{new}}$。\n$$\n\\mathrm{CVA}^{\\mathrm{comb}} = (1-R)\\sum_{k=1}^{N} \\exp(-r t_k) \\cdot \\max\\big(E_k^{\\mathrm{old}} + E_k^{\\mathrm{new}}, 0\\big) \\cdot \\big(\\exp(-\\lambda t_{k-1}) - \\exp(-\\lambda t_k)\\big)\n$$\n\n最后，增量 CVA 是两者之差：\n$$\n\\Delta \\mathrm{CVA} = \\mathrm{CVA}^{\\mathrm{comb}} - \\mathrm{CVA}^{\\mathrm{old}}\n$$\n\n此过程将应用于每个测试用例。测试集中提供的边界条件可作为检验实现正确性的重要手段：\n- 如果 $\\lambda = 0$，那么对于所有的 $k$ 都有 $\\Delta \\mathrm{PD}_k = 0$，这必然导致 $\\mathrm{CVA} = 0$ 和 $\\Delta \\mathrm{CVA} = 0$。\n- 如果 $R = 1$，那么因子 $(1-R) = 0$，这也必然导致 $\\mathrm{CVA} = 0$ 和 $\\Delta \\mathrm{CVA} = 0$。\n\n为提高效率，实现将利用向量化计算，其中贴现因子、违约概率和风险暴露的整个数组都在单次操作中处理。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the incremental Credit Valuation Adjustment (Delta CVA)\n    for a series of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"r\": 0.02, \"lambda\": 0.03, \"R\": 0.4,\n            \"t\": [0.5, 1.0, 1.5, 2.0],\n            \"E_old\": [10, 8, 6, 4],\n            \"E_new\": [-3, -2, 1, 2]\n        },\n        {\n            \"r\": 0.02, \"lambda\": 0.0, \"R\": 0.4,\n            \"t\": [0.5, 1.0, 1.5, 2.0],\n            \"E_old\": [2, -1, 4, -2],\n            \"E_new\": [1, -3, 2, 0]\n        },\n        {\n            \"r\": 0.0, \"lambda\": 0.1, \"R\": 0.0,\n            \"t\": [0.25, 0.5, 0.75, 1.0],\n            \"E_old\": [5, 5, 5, 5],\n            \"E_new\": [2, 2, 2, 2]\n        },\n        {\n            \"r\": 0.05, \"lambda\": 0.2, \"R\": 1.0,\n            \"t\": [1.0, 2.0, 3.0],\n            \"E_old\": [-1, 2, 3],\n            \"E_new\": [4, -1, 1]\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        r = case[\"r\"]\n        lam = case[\"lambda\"]\n        R = case[\"R\"]\n        t_k = np.array(case[\"t\"])\n        E_old_k = np.array(case[\"E_old\"])\n        E_new_k = np.array(case[\"E_new\"])\n\n        # Prepend t_0 = 0 to the time grid for calculating intervals.\n        t_prev_k = np.concatenate(([0], t_k[:-1]))\n\n        # Calculate discount factors D(t_k)\n        D_k = np.exp(-r * t_k)\n\n        # Calculate survival probabilities at t_k-1 and t_k\n        S_prev_k = np.exp(-lam * t_prev_k)\n        S_k = np.exp(-lam * t_k)\n        \n        # Calculate incremental default probabilities Delta_PD_k\n        delta_PD_k = S_prev_k - S_k\n\n        # Calculate the CVA contribution factor, common to both portfolios\n        cva_factor = (1 - R) * D_k * delta_PD_k\n\n        # --- CVA for the old portfolio ---\n        # Calculate positive exposure for the old portfolio\n        positive_E_old_k = np.maximum(E_old_k, 0)\n        # Sum the terms to get CVA_old\n        cva_old = np.sum(cva_factor * positive_E_old_k)\n\n        # --- CVA for the combined portfolio ---\n        # Calculate combined exposure\n        E_comb_k = E_old_k + E_new_k\n        # Calculate positive exposure for the combined portfolio\n        positive_E_comb_k = np.maximum(E_comb_k, 0)\n        # Sum the terms to get CVA_comb\n        cva_comb = np.sum(cva_factor * positive_E_comb_k)\n\n        # --- Incremental CVA ---\n        delta_cva = cva_comb - cva_old\n        results.append(delta_cva)\n\n    # Format the results to exactly six decimal places and print.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "这项练习旨在连接理论金融与现代数据科学，展示了如何用机器学习模型生成的、更符合现实的数据驱动预测来替代抽象的违约概率假设。你将学习如何将逻辑回归模型的输出整合到CVA计算框架中 ，这在当今的量化金融领域是一项高度相关的实用技能。通过这项实践，你将能构建一个更加真实和动态的信用风险评估模型。",
            "id": "2386252",
            "problem": "您需要完成一项任务：计算一个投资组合的信用估值调整 (CVA)。其中，交易对手的违约概率由一个基于公司特定特征训练的逻辑回归 (LR) 模型得出。您的目标是首先从第一性原理出发进行推导，然后实现一个程序，在风险中性测度下计算该投资组合的 CVA，假设风险敞口与违约事件相互独立，且只考虑单边交易对手信用风险。\n\n假设与理论基础：\n- 在风险中性估值下，一个投资组合的信用估值调整 (CVA) 可表示为在给定时间范围内，因交易对手违约而产生的折现期望损失。令 $t \\in [0, T]$ 表示时间，$D(t)$ 为无风险折现因子，$\\text{LGD}$ 为违约损失率，$E^{\\mathbb{Q}}[\\cdot]$ 为风险中性期望，$\\tau$ 为交易对手的随机违约时间。通用定义如下\n$$\n\\text{CVA} \\;=\\; E^{\\mathbb{Q}}\\!\\left[\\int_{0}^{T} D(t)\\,\\text{LGD}\\,\\max(V(t),0)\\,\\mathrm{d}\\mathbf{1}_{\\{\\tau \\le t\\}}\\right].\n$$\n- 公司的时点违约概率使用逻辑回归建模。对于每个特征向量为 $x \\in \\mathbb{R}^{d}$ 的公司，其逻辑回归得分为 $z = \\beta_0 + \\sum_{i=1}^{d} \\beta_i x_i$。年度无条件违约概率为 $p_{\\text{ann}} = \\sigma(z)$，其中 $\\sigma(u) = \\frac{1}{1 + e^{-u}}$ 为 logistic (sigmoid) 函数。\n- 对于强度为 $\\lambda$ 的恒定风险率模型，其生存函数为 $S(t) = e^{-\\lambda t}$，年度无条件违约概率与此相关，关系式为 $p_{\\text{ann}} = 1 - e^{-\\lambda \\cdot 1}$。由此可得 $\\lambda = -\\ln(1 - p_{\\text{ann}})$。\n- 对于一个离散的年度时间网格 $t_k = k$（$k = 1, \\dots, K$），在网格点上具有分段常数的期望正敞口 (EPE)，并假设存在一个恒定的连续复利无风险利率 $r$，则折现因子为 $D(t_k) = e^{-r t_k}$。\n- 在恒定风险率 $\\lambda$ 下，区间 $(t_{k-1}, t_k]$ 内的边际违约概率为 $S(t_{k-1}) - S(t_k)$，其中 $S(0) = 1$。\n\n任务：\n1. 从通用的风险中性 CVA 定义和上述假设出发，推导年度网格上投资组合 CVA 的离散化表达式。您的推导过程必须清楚地展示如何结合违约可能性、折现因子、期望正敞口 (EPE) 和违约损失率 (LGD)。不得使用任何未经证明或未加解释的简便公式；每一步都需从生存概率、风险率和风险中性期望的定义推导而来。\n2. 实现一个程序，该程序：\n   - 使用 LR 模型，通过 $p_{\\text{ann}} = \\sigma(\\beta_0 + \\sum_{i=1}^{d} \\beta_i x_i)$ 从特征和系数计算年度违约概率 $p_{\\text{ann}}$。\n   - 将 $p_{\\text{ann}}$ 转换为恒定风险率 $\\lambda = -\\ln(1 - p_{\\text{ann}})$。\n   - 使用年度网格 $t_k = k$（其中 $k$ 等于公司 EPE 点的数量）来计算生存概率 $S(t_k) = e^{-\\lambda t_k}$ 和边际违约概率 $S(t_{k-1}) - S(t_k)$。\n   - 通过对每个时间段 $k$ 的折现期望损失贡献求和来计算单个公司的 CVA，然后将所有公司的 CVA 相加得到投资组合的 CVA。\n   - 实现数值稳定的 logistic 函数评估，并在应用对数变换前将概率裁剪到开区间 $(\\epsilon, 1-\\epsilon)$ 内，其中 $\\epsilon = 10^{-12}$。\n3. 使用以下测试套件。每个测试用例提供一个固定利率 $r$、一个截距项 $\\beta_0$、一个系数向量 $\\beta$，以及一个公司列表，每个公司都有一个特征向量 $x$、一个违约损失率 $\\text{LGD}$ 和一个年度网格 EPE 向量。时间步长为一年，因此第 $k$ 个 EPE 条目对应于 $t_k=k$。\n   - 测试用例 1（正常路径，多家公司，中等概率，期限 5 年）：\n     - $r = 0.02$，\n     - $\\beta_0 = -4.0$，\n     - $\\beta = [0.8, -0.5]$，\n     - 公司：\n       - 公司 A：$x = [1.2, 0.3]$，$\\text{LGD} = 0.6$，$\\text{EPE} = [1.0, 0.9, 0.8, 0.7, 0.6]$。\n       - 公司 B：$x = [0.5, -0.1]$，$\\text{LGD} = 0.6$，$\\text{EPE} = [0.5, 0.5, 0.5, 0.5, 0.5]$。\n       - 公司 C：$x = [-0.2, 1.5]$，$\\text{LGD} = 0.6$，$\\text{EPE} = [0.2, 0.25, 0.3, 0.35, 0.4]$。\n   - 测试用例 2（边界条件：零敞口意味着零 CVA，期限 3 年）：\n     - $r = 0.01$，\n     - $\\beta_0 = -4.0$，\n     - $\\beta = [0.8, -0.5]$，\n     - 公司：\n       - 公司 D：$x = [0.0, 0.0]$，$\\text{LGD} = 0.6$，$\\text{EPE} = [0.0, 0.0, 0.0]$。\n       - 公司 E：$x = [1.0, -1.0]$，$\\text{LGD} = 0.6$，$\\text{EPE} = [0.0, 0.0, 0.0]$。\n   - 测试用例 3（边缘情况覆盖：高概率和低概率，异构 $\\text{LGD}$，零无风险利率，期限 7 年）：\n     - $r = 0.0$，\n     - $\\beta_0 = -1.0$，\n     - $\\beta = [1.5, 1.0]$，\n     - 公司：\n       - 公司 F：$x = [1.0, 1.0]$，$\\text{LGD} = 0.4$，$\\text{EPE} = [0.2, 0.4, 0.6, 0.8, 0.6, 0.4, 0.2]$。\n       - 公司 G：$x = [-2.0, -1.0]$，$\\text{LGD} = 0.6$，$\\text{EPE} = [1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4]$。\n4. 输出规范：\n   - 对于每个测试用例，计算一个单一的投资组合 CVA 值，该值为浮点数。\n   - 您的程序应生成一行输出，其中包含一个方括号括起来的逗号分隔结果列表。每个数字必须四舍五入到 6 位小数。例如：$[0.123456,0.000000,1.234568]$。\n5. 其他说明：\n   - 角度单位不适用。\n   - 百分比必须表示为小数（例如，$\\text{LGD} = 0.6$ 表示 $60\\%$）。\n   - 不需要物理单位；货币值被视为抽象的数值量。\n\n您的实现必须是自包含的，无需输入，并严格遵循输出格式。任何对指定格式的偏离都将被视为不正确。该算法应具有足够的通用性，以处理所列的测试套件。",
            "solution": "计算投资组合信用估值调整 (CVA) 的问题是有效的，因为它在科学上基于金融工程的既定原则，其数据和假设集完整且一致，问题本身是适定的，并且表述客观。以下是从第一性原理出发的推导，随后是解决方案的实现。\n\n推导始于 CVA 的通用风险中性定义。CVA 代表交易对手信用风险的市场价值。对于单个交易对手，它是在交易对手违约时刻 $\\tau$ 发生的折现损失的风险中性期望值。\n提供的定义是：\n$$ \\text{CVA} = E^{\\mathbb{Q}}\\!\\left[\\int_{0}^{T} D(t)\\,\\text{LGD}\\,\\max(V(t),0)\\,\\mathrm{d}\\mathbf{1}_{\\{\\tau \\le t\\}}\\right] $$\n其中 $E^{\\mathbb{Q}}[\\cdot]$ 是在风险中性测度 $\\mathbb{Q}$ 下的期望，$D(t)$ 是时间 $t$ 的无风险折现因子，$\\text{LGD}$ 是违约损失率（一个常数比例），$V(t)$ 是与该交易对手的交易组合的市场价值，$\\tau$ 是随机违约时间。$\\max(V(t),0)$ 项代表违约时的风险敞口，因为只有当投资组合对我们有正价值时才会发生损失。该积分为斯蒂尔切斯积分，可以解释为在违约瞬间 $\\tau$（前提是 $\\tau \\le T$）评估折现损失。一个更标准的公式是：\n$$ \\text{CVA} = E^{\\mathbb{Q}}\\!\\left[ \\mathbf{1}_{\\{\\tau \\le T\\}} \\cdot D(\\tau) \\cdot \\text{LGD} \\cdot \\max(V(\\tau), 0) \\right] $$\n这表示 CVA 是从违约时间 $\\tau$ 折现的损失期望。为了评估此期望，我们可以对所有可能的违约时间进行积分，并以其风险中性概率密度加权。设 $f_\\tau(t)$ 为违约时间 $\\tau$ 的概率密度函数 (PDF)。那么 CVA 为：\n$$ \\text{CVA} = \\int_{0}^{T} E^{\\mathbb{Q}}\\!\\left[ D(t) \\cdot \\text{LGD} \\cdot \\max(V(t), 0) \\mid \\tau=t \\right] f_\\tau(t) \\, \\mathrm{d}t $$\n一个关键假设是违约事件与驱动投资组合价值 $V(t)$ 的市场风险之间相互独立。这使我们能够分离期望：\n$$ E^{\\mathbb{Q}}\\!\\left[ D(t) \\cdot \\text{LGD} \\cdot \\max(V(t), 0) \\mid \\tau=t \\right] = D(t) \\cdot \\text{LGD} \\cdot E^{\\mathbb{Q}}\\!\\left[\\max(V(t), 0)\\right] $$\n$E^{\\mathbb{Q}}\\!\\left[\\max(V(t), 0)\\right]$ 项是期望正敞口，记为 $\\text{EPE}(t)$。公式简化为：\n$$ \\text{CVA} = \\int_{0}^{T} D(t) \\cdot \\text{LGD} \\cdot \\text{EPE}(t) \\cdot f_\\tau(t) \\, \\mathrm{d}t $$\nPDF $f_\\tau(t)$ 与生存概率函数 $S(t) = P(\\tau > t)$ 的关系为 $f_\\tau(t) = -\\frac{\\mathrm{d}S(t)}{\\mathrm{d}t}$。将其代入，我们得到：\n$$ \\text{CVA} = -\\int_{0}^{T} D(t) \\cdot \\text{LGD} \\cdot \\text{EPE}(t) \\cdot S'(t) \\, \\mathrm{d}t $$\n为了进行数值实现，我们将时间范围 $[0, T]$ 离散化为 $K$ 个区间 $(t_{k-1}, t_k]$，其中 $t_k = k$（$k=1, \\dots, K$）且 $t_0=0$。该积分可通过对这些区间的求和来近似：\n$$ \\text{CVA} \\approx \\sum_{k=1}^{K} \\int_{t_{k-1}}^{t_k} D(t) \\cdot \\text{LGD} \\cdot \\text{EPE}(t) \\cdot f_\\tau(t) \\, \\mathrm{d}t $$\n我们假设在每个小区间 $(t_{k-1}, t_k]$ 内，$D(t)$ 和 $\\text{EPE}(t)$ 项近似为常数，并可以在区间末尾进行评估，即 $D(t) \\approx D(t_k)$ 和 $\\text{EPE}(t) \\approx \\text{EPE}(t_k)$。这是一个标准的一阶近似。\n$$ \\text{CVA} \\approx \\sum_{k=1}^{K} D(t_k) \\cdot \\text{LGD} \\cdot \\text{EPE}(t_k) \\int_{t_{k-1}}^{t_k} f_\\tau(t) \\, \\mathrm{d}t $$\nPDF 在区间 $(t_{k-1}, t_k]$ 上的积分就是该区间内的违约概率：\n$$ \\int_{t_{k-1}}^{t_k} f_\\tau(t) \\, \\mathrm{d}t = P(t_{k-1}  \\tau \\le t_k) = S(t_{k-1}) - S(t_k) $$\n该项是第 $k$ 期的边际违约概率。将其代入求和式，得到单个交易对手 CVA 的最终离散化公式：\n$$ \\text{CVA}_{\\text{firm}} \\approx \\text{LGD} \\sum_{k=1}^{K} D(t_k) \\cdot \\text{EPE}(t_k) \\cdot [S(t_{k-1}) - S(t_k)] $$\n投资组合的 CVA 是每个独立交易对手 CVA 的总和，假设它们的违约是独立事件：\n$$ \\text{CVA}_{\\text{portfolio}} = \\sum_{j} \\text{CVA}_{\\text{firm } j} $$\n现在我们整合所提供的具体模型。违约过程由一个恒定风险率 $\\lambda$ 建模。生存函数为 $S(t) = e^{-\\lambda t}$。风险率 $\\lambda$ 从逻辑回归模型的输出（即年度无条件违约概率 $p_{\\text{ann}}$）推导得出。其关系为 $p_{\\text{ann}} = P(\\tau \\le 1) = 1 - S(1) = 1 - e^{-\\lambda \\cdot 1}$。求解 $\\lambda$ 可得 $\\lambda = -\\ln(1 - p_{\\text{ann}})$。年度概率 $p_{\\text{ann}}$ 由线性得分 $z = \\beta_0 + \\mathbf{x}^T \\boldsymbol{\\beta}$ 的 sigmoid 函数 $\\sigma(z)$ 给出：\n$$ p_{\\text{ann}} = \\sigma(z) = \\frac{1}{1+e^{-z}} $$\n时间 $t_k=k$ 时，连续复利率为 $r$ 的无风险折现因子是 $D(t_k) = e^{-r t_k}$。综合所有组成部分，我们按如下方式计算单个公司的 CVA：\n1.  计算得分 $z = \\beta_0 + \\sum_{i=1}^{d} \\beta_i x_i$。\n2.  使用数值稳定的实现计算年度违约概率 $p_{\\text{ann}} = \\sigma(z)$。将 $p_{\\text{ann}}$ 裁剪到 $(\\epsilon, 1-\\epsilon)$ 区间内，其中 $\\epsilon=10^{-12}$。\n3.  计算恒定风险率 $\\lambda = -\\ln(1 - p_{\\text{ann}})$。\n4.  计算每个时间区间 $k=1, \\dots, K$ 的 CVA 贡献：\n    $$ \\text{CVA}_{\\text{firm}} = \\text{LGD} \\sum_{k=1}^{K} e^{-r k} \\cdot \\text{EPE}_k \\cdot (e^{-\\lambda (k-1)} - e^{-\\lambda k}) $$\n    其中 $\\text{EPE}_k$ 是给定的第 $k$ 年的期望正敞口。投资组合的总 CVA 是这些值在所有公司上的总和。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes portfolio CVA based on a logistic regression model for default probabilities.\n    \"\"\"\n    # Test cases defined in the problem statement.\n    test_cases = [\n        # Test case 1\n        {\n            \"r\": 0.02,\n            \"beta0\": -4.0,\n            \"beta\": np.array([0.8, -0.5]),\n            \"firms\": [\n                {\"x\": np.array([1.2, 0.3]), \"lgd\": 0.6, \"epe\": np.array([1.0, 0.9, 0.8, 0.7, 0.6])},\n                {\"x\": np.array([0.5, -0.1]), \"lgd\": 0.6, \"epe\": np.array([0.5, 0.5, 0.5, 0.5, 0.5])},\n                {\"x\": np.array([-0.2, 1.5]), \"lgd\": 0.6, \"epe\": np.array([0.2, 0.25, 0.3, 0.35, 0.4])},\n            ]\n        },\n        # Test case 2\n        {\n            \"r\": 0.01,\n            \"beta0\": -4.0,\n            \"beta\": np.array([0.8, -0.5]),\n            \"firms\": [\n                {\"x\": np.array([0.0, 0.0]), \"lgd\": 0.6, \"epe\": np.array([0.0, 0.0, 0.0])},\n                {\"x\": np.array([1.0, -1.0]), \"lgd\": 0.6, \"epe\": np.array([0.0, 0.0, 0.0])},\n            ]\n        },\n        # Test case 3\n        {\n            \"r\": 0.0,\n            \"beta0\": -1.0,\n            \"beta\": np.array([1.5, 1.0]),\n            \"firms\": [\n                {\"x\": np.array([1.0, 1.0]), \"lgd\": 0.4, \"epe\": np.array([0.2, 0.4, 0.6, 0.8, 0.6, 0.4, 0.2])},\n                {\"x\": np.array([-2.0, -1.0]), \"lgd\": 0.6, \"epe\": np.array([1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4])},\n            ]\n        }\n    ]\n\n    results = []\n    \n    # Numerical precision for clipping\n    epsilon = 1e-12\n\n    def stable_sigmoid(z):\n        \"\"\"Numerically stable sigmoid function.\"\"\"\n        if z >= 0:\n            return 1.0 / (1.0 + np.exp(-z))\n        else:\n            # Use formulation exp(z) / (1 + exp(z)) to avoid overflow\n            exp_z = np.exp(z)\n            return exp_z / (1.0 + exp_z)\n\n    for case in test_cases:\n        r = case[\"r\"]\n        beta0 = case[\"beta0\"]\n        beta = case[\"beta\"]\n        firms = case[\"firms\"]\n        \n        portfolio_cva = 0.0\n        \n        for firm in firms:\n            x = firm[\"x\"]\n            lgd = firm[\"lgd\"]\n            epe = firm[\"epe\"]\n            \n            # 1. Compute LR score\n            z = beta0 + np.dot(beta, x)\n            \n            # 2. Compute annual default probability\n            p_ann = stable_sigmoid(z)\n            \n            # 3. Clip for numerical stability before log\n            p_ann_clipped = np.clip(p_ann, epsilon, 1.0 - epsilon)\n            \n            # 4. Convert to constant hazard rate\n            # If p_ann is 1, lambda would be inf. Clipping handles this.\n            hazard_rate_lambda = -np.log(1.0 - p_ann_clipped)\n            \n            firm_cva = 0.0\n            num_steps = len(epe)\n            \n            if num_steps == 0:\n                portfolio_cva += 0.0\n                continue\n                \n            # Time steps k = 1, 2, ..., K\n            k_steps = np.arange(1, num_steps + 1)\n            \n            # Discount factors D(t_k) = exp(-r*k)\n            discount_factors = np.exp(-r * k_steps)\n            \n            # Survival probabilities S(t_k) = exp(-lambda*k) and S(t_{k-1})\n            s_k_minus_1 = np.exp(-hazard_rate_lambda * (k_steps - 1))\n            s_k = np.exp(-hazard_rate_lambda * k_steps)\n            \n            # Marginal default probabilities in (t_{k-1}, t_k]\n            marginal_pd = s_k_minus_1 - s_k\n            \n            # Expected loss for each period\n            expected_loss_periods = epe * marginal_pd\n            \n            # Discounted expected loss for each period\n            discounted_el = discount_factors * expected_loss_periods\n            \n            # Sum over all periods and multiply by LGD for the firm's CVA\n            firm_cva = lgd * np.sum(discounted_el)\n            \n            portfolio_cva += firm_cva\n            \n        results.append(round(portfolio_cva, 6))\n\n    # Format the final output string\n    print(f\"[{','.join(f'{res:.6f}' for res in results)}]\")\n\nsolve()\n```"
        }
    ]
}