{
    "hands_on_practices": [
        {
            "introduction": "在风险管理实践中，一项关键任务不仅仅是从头计算投资组合的信用估值调整（CVA），更重要的是在新交易加入时能够高效地更新它。本练习将侧重于这种“增量CVA”的计算，并突显净额结算（netting）的非线性影响，即一笔新交易的加入可能对整体风险产生复杂效应。通过在一个简化的离散模型中进行实践，你将为掌握更复杂的CVA概念打下坚实的基础。",
            "id": "2386214",
            "problem": "考虑信用估值调整 (CVA) 的单一交易对手情景。设时间由离散网格 $\\{t_1,\\dots,t_N\\}$ 表示，且 $t_0=0$。设无风险连续复利率为恒定的 $r$，交易对手的违约强度（风险率）为恒定的 $\\lambda$，回收率为 $R$。定义生存函数为 $S(t)=\\exp(-\\lambda t)$，贴现因子为 $D(t)=\\exp(-r t)$。设区间 $(t_{k-1},t_k]$ 上的增量违约概率为 $\\Delta \\mathrm{PD}_k=S(t_{k-1})-S(t_k)$，其中 $S(t_0)=1$。对于一个确定的净额结算组合风险敞口路径，设现有投资组合在 $t_k$ 的（取正值前）风险敞口为 $E^{\\mathrm{old}}_k$，新增交易在 $t_k$ 的（取正值前）风险敞口为 $E^{\\mathrm{new}}_k$。在 $t_k$ 的净额正风险敞口是对取正值前的净风险敞口应用 $\\max(x,0)$ 得到的结果。使用离散时间近似，单边 CVA 为\n$$\n\\mathrm{CVA} = (1-R)\\sum_{k=1}^{N} D(t_k)\\,\\Big(\\max\\big(E_k,0\\big)\\Big)\\,\\Delta \\mathrm{PD}_k,\n$$\n其中 $E_k$ 表示在 $t_k$ 时的相关净风险敞口。因增加新交易而产生的增量 CVA 为\n$$\n\\Delta \\mathrm{CVA} = \\mathrm{CVA}\\big(\\max(E^{\\mathrm{old}}+E^{\\mathrm{new}},0)\\big) - \\mathrm{CVA}\\big(\\max(E^{\\mathrm{old}},0)\\big).\n$$\n所有利率 $r$ 和 $\\lambda$ 均为以小数表示的年利率，时间 $t_k$ 以年为单位，风险敞口 $E^{\\mathrm{old}}_k$ 和 $E^{\\mathrm{new}}_k$ 以任意货币单位计量，最终答案必须以相同货币单位的十进制数报告。\n\n任务：对于下方的每个测试用例，计算如上定义的 $\\Delta \\mathrm{CVA}$。请严格使用给定的参数，并将所有数组视为按 $t_1,\\dots,t_N$ 排序。\n\n测试套件：\n- 测试用例 $1$（考虑净额结算效应的一般情况）：$r=0.02$, $\\lambda=0.03$, $R=0.4$, $[t_1,t_2,t_3,t_4]=[0.5,1.0,1.5,2.0]$, $[E^{\\mathrm{old}}_k]_{k=1}^4=[10,8,6,4]$, $[E^{\\mathrm{new}}_k]_{k=1}^4=[-3,-2,1,2]$.\n- 测试用例 $2$（边界情况：风险率为零）：$r=0.02$, $\\lambda=0.0$, $R=0.4$, $[t_1,t_2,t_3,t_4]=[0.5,1.0,1.5,2.0]$, $[E^{\\mathrm{old}}_k]_{k=1}^4=[2,-1,4,-2]$, $[E^{\\mathrm{new}}_k]_{k=1}^4=[1,-3,2,0]$.\n- 测试用例 $3$（所有风险敞口严格为正，无风险利率为零，回收率为零）：$r=0.0$, $\\lambda=0.1$, $R=0.0$, $[t_1,t_2,t_3,t_4]=[0.25,0.5,0.75,1.0]$, $[E^{\\mathrm{old}}_k]_{k=1}^4=[5,5,5,5]$, $[E^{\\mathrm{new}}_k]_{k=1}^4=[2,2,2,2]$.\n- 测试用例 $4$（边界情况：完全回收）：$r=0.05$, $\\lambda=0.2$, $R=1.0$, $[t_1,t_2,t_3]=[1.0,2.0,3.0]$, $[E^{\\mathrm{old}}_k]_{k=1}^3=[-1,2,3]$, $[E^{\\mathrm{new}}_k]_{k=1}^3=[4,-1,1]$.\n\n所需的最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按测试用例 1 到 4 的顺序排列结果，每个数字四舍五入到小数点后恰好六位（例如，$[0.123456,-0.000001,1.000000]$）。",
            "solution": "问题陈述已经过严格验证。我们发现其科学基础扎实，问题定义明确，没有矛盾或含糊之处。所提供的信用估值调整 (CVA) 的定义和公式是量化金融中使用的标准（尽管是简化的）表示方法。已为指定的测试用例提供了所有必要的参数。因此，该问题被视为 **有效**。我们接下来着手推导解决方案。\n\n目标是计算将一笔新交易添加至现有投资组合所产生的增量 CVA ($\\Delta \\mathrm{CVA}$)。$\\Delta \\mathrm{CVA}$ 定义为合并后投资组合的 CVA 与原始投资组合的 CVA 之差：\n$$\n\\Delta \\mathrm{CVA} = \\mathrm{CVA}(\\text{combined}) - \\mathrm{CVA}(\\text{original})\n$$\n\n对于给定的风险敞口概况，CVA 使用离散时间近似公式计算：\n$$\n\\mathrm{CVA} = (1-R)\\sum_{k=1}^{N} D(t_k)\\,\\Big(\\max\\big(E_k,0\\big)\\Big)\\,\\Delta \\mathrm{PD}_k\n$$\n其中：\n- $R$ 是回收率。\n- $N$ 是时间步数。\n- $t_k$ 是第 $k$ 步的时间（以年为单位）。\n- $E_k$ 是在时间 $t_k$ 的净风险敞口。\n- $D(t_k)$ 是在时间 $t_k$ 的无风险贴现因子。\n- $\\Delta \\mathrm{PD}_k$ 是在时间区间 $(t_{k-1}, t_k]$ 上的增量违约概率。\n\n对于每个时间步 $k \\in \\{1, 2, \\dots, N\\}$，公式的各组成部分计算如下：\n\n1.  **贴现因子, $D(t_k)$**：这是一单位货币在时间 $t_k$ 收到的现值。在恒定的无风险利率 $r$ 下，其计算公式为：\n    $$\n    D(t_k) = \\exp(-r \\cdot t_k)\n    $$\n\n2.  **增量违约概率, $\\Delta \\mathrm{PD}_k$**：这是交易对手在区间 $(t_{k-1}, t_k]$ 内违约的概率，前提是其存活至 $t_{k-1}$。它源自生存函数 $S(t) = \\exp(-\\lambda t)$，其中 $\\lambda$ 是恒定的风险率。我们定义 $t_0 = 0$。\n    $$\n    \\Delta \\mathrm{PD}_k = S(t_{k-1}) - S(t_k) = \\exp(-\\lambda \\cdot t_{k-1}) - \\exp(-\\lambda \\cdot t_k)\n    $$\n\n3.  **正风险敞口, $\\max\\big(E_k,0\\big)$**：CVA 计算仅适用于风险敞口 $E_k$ 为正的情况，这意味着如果交易对手违约，我们将遭受损失。对于原始投资组合，风险敞口为 $E_k^{\\mathrm{old}}$。对于合并后的投资组合，风险敞口是原始风险敞口与新增风险敞口之和，$E_k^{\\mathrm{comb}} = E_k^{\\mathrm{old}} + E_k^{\\mathrm{new}}$，这反映了净额结算的效果。\n\n总体算法如下：\n\n首先，计算原始投资组合的 CVA，即 $\\mathrm{CVA}^{\\mathrm{old}}$。\n$$\n\\mathrm{CVA}^{\\mathrm{old}} = (1-R)\\sum_{k=1}^{N} \\exp(-r t_k) \\cdot \\max\\big(E_k^{\\mathrm{old}}, 0\\big) \\cdot \\big(\\exp(-\\lambda t_{k-1}) - \\exp(-\\lambda t_k)\\big)\n$$\n\n其次，计算合并后投资组合的 CVA，即 $\\mathrm{CVA}^{\\mathrm{comb}}$。每个时间步的合并风险敞口为 $E_k^{\\mathrm{comb}} = E_k^{\\mathrm{old}} + E_k^{\\mathrm{new}}$。\n$$\n\\mathrm{CVA}^{\\mathrm{comb}} = (1-R)\\sum_{k=1}^{N} \\exp(-r t_k) \\cdot \\max\\big(E_k^{\\mathrm{old}} + E_k^{\\mathrm{new}}, 0\\big) \\cdot \\big(\\exp(-\\lambda t_{k-1}) - \\exp(-\\lambda t_k)\\big)\n$$\n\n最后，增量 CVA 是二者之差：\n$$\n\\Delta \\mathrm{CVA} = \\mathrm{CVA}^{\\mathrm{comb}} - \\mathrm{CVA}^{\\mathrm{old}}\n$$\n\n此过程将应用于每个测试用例。测试套件中提供的边界条件可作为检验实现正确性的重要手段：\n- 如果 $\\lambda = 0$，则对于所有 $k$，$\\Delta \\mathrm{PD}_k = 0$，这必然导致 $\\mathrm{CVA} = 0$ 和 $\\Delta \\mathrm{CVA} = 0$。\n- 如果 $R = 1$，则因子 $(1-R) = 0$，这也必然导致 $\\mathrm{CVA} = 0$ 和 $\\Delta \\mathrm{CVA} = 0$。\n\n为了提高效率，该实现将利用向量化计算，即在单次操作中处理整个贴现因子、违约概率和风险敞口数组。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the incremental Credit Valuation Adjustment (Delta CVA)\n    for a series of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"r\": 0.02, \"lambda\": 0.03, \"R\": 0.4,\n            \"t\": [0.5, 1.0, 1.5, 2.0],\n            \"E_old\": [10, 8, 6, 4],\n            \"E_new\": [-3, -2, 1, 2]\n        },\n        {\n            \"r\": 0.02, \"lambda\": 0.0, \"R\": 0.4,\n            \"t\": [0.5, 1.0, 1.5, 2.0],\n            \"E_old\": [2, -1, 4, -2],\n            \"E_new\": [1, -3, 2, 0]\n        },\n        {\n            \"r\": 0.0, \"lambda\": 0.1, \"R\": 0.0,\n            \"t\": [0.25, 0.5, 0.75, 1.0],\n            \"E_old\": [5, 5, 5, 5],\n            \"E_new\": [2, 2, 2, 2]\n        },\n        {\n            \"r\": 0.05, \"lambda\": 0.2, \"R\": 1.0,\n            \"t\": [1.0, 2.0, 3.0],\n            \"E_old\": [-1, 2, 3],\n            \"E_new\": [4, -1, 1]\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        r = case[\"r\"]\n        lam = case[\"lambda\"]\n        R = case[\"R\"]\n        t_k = np.array(case[\"t\"])\n        E_old_k = np.array(case[\"E_old\"])\n        E_new_k = np.array(case[\"E_new\"])\n\n        # Prepend t_0 = 0 to the time grid for calculating intervals.\n        t_prev_k = np.concatenate(([0], t_k[:-1]))\n\n        # Calculate discount factors D(t_k)\n        D_k = np.exp(-r * t_k)\n\n        # Calculate survival probabilities at t_k-1 and t_k\n        S_prev_k = np.exp(-lam * t_prev_k)\n        S_k = np.exp(-lam * t_k)\n        \n        # Calculate incremental default probabilities Delta_PD_k\n        delta_PD_k = S_prev_k - S_k\n\n        # Calculate the CVA contribution factor, common to both portfolios\n        cva_factor = (1 - R) * D_k * delta_PD_k\n\n        # --- CVA for the old portfolio ---\n        # Calculate positive exposure for the old portfolio\n        positive_E_old_k = np.maximum(E_old_k, 0)\n        # Sum the terms to get CVA_old\n        cva_old = np.sum(cva_factor * positive_E_old_k)\n\n        # --- CVA for the combined portfolio ---\n        # Calculate combined exposure\n        E_comb_k = E_old_k + E_new_k\n        # Calculate positive exposure for the combined portfolio\n        positive_E_comb_k = np.maximum(E_comb_k, 0)\n        # Sum the terms to get CVA_comb\n        cva_comb = np.sum(cva_factor * positive_E_comb_k)\n\n        # --- Incremental CVA ---\n        delta_cva = cva_comb - cva_old\n        results.append(delta_cva)\n\n    # Format the results to exactly six decimal places and print.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "虽然确定性风险敞口对于学习很有帮助，但现实世界中的金融风险敞口是随机变化的。蒙特卡洛模拟是处理这种复杂性的行业标准工具，能够为各种衍生品合约估算未来的风险敞口分布。在本练习中，你将构建一个完整的蒙特卡洛CVA引擎，从模拟资产价格路径到计算最终CVA，并在此过程中探索计算效率这一关键主题。",
            "id": "2386203",
            "problem": "要求您构建一个小型、自包含的计算引擎，用于在蒙特卡洛框架下进行信用估值调整 (Credit Valuation Adjustment, CVA)，并比较两种计算后端：一个使用显式循环的标量中央处理器 (CPU) 实现，以及一个使用数组编程来模拟图形处理器 (GPU) 批量并行执行的单指令多数据 (Single Instruction Multiple Data, SIMD) 风格的向量化后端。在无法进行实际图形处理器 (GPU) 执行的情况下，向量化是单指令多数据 (SIMD) 并行性的标准且可靠的代理，它能够实现本可卸载到 GPU 内核的相同算法结构。\n\n从以下基本基础开始：\n- 在风险中性测度下，单个风险资产的即期价格过程由几何布朗运动 (Geometric Brownian Motion, GBM) 建模：$$dS_t = (r - q) S_t \\, dt + \\sigma S_t \\, dW_t,$$ 其中 $S_t$ 是即期价格， $r$ 是连续复利无风险利率， $q$ 是连续股息收益率， $\\sigma$ 是波动率，且 $W_t$ 是标准布朗运动。\n- 在连续股息收益率 $q$ 的情况下，一份于到期日 $T$ 交割、执行价为 $K$ 的多头远期合约在时间 $t$ 的价值为 $$V_t = S_t e^{-q (T - t)} - K e^{-r (T - t)}.$$\n- 在时间 $t$ 的未抵押风险暴露为 $$E_t = \\max(V_t, 0).$$\n- 在恒定风险率（违约强度）$\\lambda$ 和回收率 $R$ 的情况下，违约损失率为 $$\\text{LGD} = 1 - R,$$ 且生存概率为 $$\\mathbb{S}(t) = e^{-\\lambda t}.$$ 风险中性违约密度为 $$f(t) = \\lambda e^{-\\lambda t}.$$\n- 在独立性假设下的连续时间 CVA 为 $$\\text{CVA} = \\text{LGD} \\int_0^T D(0,t) \\, \\mathbb{E}[E_t] \\, f(t) \\, dt,$$ 其中 $$D(0,t) = e^{-r t}$$ 是贴现因子，且 $$\\mathbb{E}[E_t]$$ 是期望风险暴露。\n\n任务：\n1) 使用均匀时间网格 $t_i = i \\Delta t$（其中 $i = 1, 2, \\dots, M$ 且 $\\Delta t = T/M$）和期望风险暴露的蒙特卡洛估计量，为 CVA 推导一个一致的离散时间估计量。您的推导必须从上述基本基础开始，并且不得依赖任何快捷公式。\n2) 为该估计量实现两个后端：\n   - 一个使用显式嵌套循环（遍历路径和时间）的标量 CPU 后端。\n   - 一个向量化后端，通过对模拟状态的整个数组一次性应用相同操作来模拟 GPU 风格的并行性（即单指令多数据）。\n3) 对两个后端使用相同的随机数，以确保任何差异都源于计算策略，而非不同的随机抽样。\n4) 通过测量实际运行时间（wall-clock time）来对两个后端进行基准测试。您必须在内部计算计时，但您的程序最终输出必须仅包含下面要求的 CVA 值。\n5) 对于每个测试用例，计算 CVA，其货币单位与 $S_0$ 和 $K$ 相同，并以浮点数形式返回。\n\n离散化和估计量设计约束：\n- 对对数形式的 GBM 使用 Euler–Maruyama 精确步长：$$S_{t+\\Delta t} = S_t \\exp\\!\\Big(\\big((r - q) - \\tfrac{1}{2}\\sigma^2\\big) \\Delta t + \\sigma \\sqrt{\\Delta t} \\, Z\\Big),$$ 其中 $Z \\sim \\mathcal{N}(0,1)$ 在各时间步和路径间独立。\n- 使用在右端点求值的黎曼和来近似积分：$$\\text{CVA} \\approx (1-R) \\sum_{i=1}^{M} e^{-r t_i} \\, \\widehat{\\mathbb{E}}[E_{t_i}] \\, \\lambda e^{-\\lambda t_i} \\, \\Delta t,$$ 其中 $\\widehat{\\mathbb{E}}[E_{t_i}]$ 是 $E_{t_i}$ 在所有模拟路径上的蒙特卡洛平均值。\n- 所有概率和利率必须表示为小数（而非百分比）。\n\n测试套件：\n实现您的程序，为以下参数集计算 CVA。每个测试用例是一个元组 $(S_0, K, T, r, q, \\sigma, \\lambda, R, N, M, \\text{seed})$：\n- 案例 A （正常路径）：$(\\$100.0, \\$100.0, 1.0, 0.02, 0.0, 0.2, 0.02, 0.4, 20000, 50, 20240501)$\n- 案例 B （零风险率边界）：$(\\$100.0, \\$100.0, 1.0, 0.02, 0.0, 0.2, 0.0, 0.4, 20000, 50, 20240501)$\n- 案例 C （完全回收边界）：$(\\$100.0, \\$100.0, 1.0, 0.02, 0.0, 0.2, 0.02, 1.0, 20000, 50, 20240501)$\n- 案例 D （确定性风险暴露检查）：$(\\$100.0, \\$90.0, 1.0, 0.01, 0.0, 0.0, 0.05, 0.4, 5000, 50, 7)$\n\n实现要求：\n- 对每个测试用例的两个后端使用相同的标准正态抽样矩阵，以便任何数值差异（若有）仅可归因于计算策略。\n- 在内部测量并记录案例 A 的每个后端的运行时间。不应打印任何计时结果，但必须执行计算。\n- 对于每个测试用例，仅输出由向量化后端计算的 CVA，四舍五入到六位小数。如果一个案例在数学上意味着 CVA 为零（例如，零风险率或零违约损失率），则该案例的输出在四舍五入后必须恰好为 $0.0$。\n\n最终输出格式：\n- 您的程序应生成单行输出，包含四个测试用例的 CVA 结果，格式为由方括号括起来的逗号分隔列表，例如 $$[\\text{cva}_A,\\text{cva}_B,\\text{cva}_C,\\text{cva}_D],$$ 其中每个条目都是一个四舍五入到六位小数的浮点数。\n\n注意：\n- 无物理单位；所有货币输出的单位与 $S_0$ 和 $K$ 的货币单位相同。\n- 不涉及角度。\n- 所有利率 ($r$, $q$, $\\sigma$, $\\lambda$) 和回收率 $R$ 必须以小数形式传递，而不是百分比。",
            "solution": "所提出的问题是计算金融领域中一个明确定义的任务，它要求推导和实现一个用于信用估值调整 (CVA) 的蒙特卡洛估计量。在进行求解之前，需要进行正式的验证。\n\n**问题验证**\n\n**步骤1：提取既定信息**\n\n问题提供了以下明确信息：\n\n- **资产价格过程**: 几何布朗运动 (GBM)，在风险中性测度下：$$dS_t = (r - q) S_t \\, dt + \\sigma S_t \\, dW_t$$ 其中 $S_t$ 是即期价格， $r$ 是无风险利率， $q$ 是股息收益率， $\\sigma$ 是波动率， $W_t$ 是标准布朗运动。\n- **合约估值**: 多头远期合约的价值为 $$V_t = S_t e^{-q (T - t)} - K e^{-r (T - t)}$$ 其中 $T$ 是到期日， $K$ 是执行价。\n- **风险暴露定义**: 未抵押风险暴露为 $$E_t = \\max(V_t, 0).$$\n- **违约模型**: 恒定风险率 $\\lambda$，回收率 $R$，违约损失率 $\\text{LGD} = 1 - R$，生存概率 $\\mathbb{S}(t) = e^{-\\lambda t}$，以及风险中性违约密度 $f(t) = \\lambda e^{-\\lambda t}$。\n- **CVA 公式**: 在独立性假设下的连续时间 CVA 为 $$\\text{CVA} = \\text{LGD} \\int_0^T D(0,t) \\, \\mathbb{E}[E_t] \\, f(t) \\, dt,$$ 其中 $D(0,t) = e^{-r t}$ 是贴现因子。\n- **离散化方案**:\n    - 时间网格: $t_i = i \\Delta t$ ，其中 $i = 1, 2, \\dots, M$ 且 $\\Delta t = T/M$。\n    - GBM 模拟步长: $$S_{t+\\Delta t} = S_t \\exp\\!\\Big(\\big((r - q) - \\tfrac{1}{2}\\sigma^2\\big) \\Delta t + \\sigma \\sqrt{\\Delta t} \\, Z\\Big),$$ 其中 $Z \\sim \\mathcal{N}(0,1)$。\n    - CVA 估计量: $$\\text{CVA} \\approx (1-R) \\sum_{i=1}^{M} e^{-r t_i} \\, \\widehat{\\mathbb{E}}[E_{t_i}] \\, \\lambda e^{-\\lambda t_i} \\, \\Delta t,$$ 其中 $\\widehat{\\mathbb{E}}[E_{t_i}]$ 是 $E_{t_i}$ 的蒙特卡洛平均值。\n- **测试套件**: 四个参数集，每个都是一个元组 $(S_0, K, T, r, q, \\sigma, \\lambda, R, N, M, \\text{seed})$。\n    - A: $(\\$100.0, \\$100.0, 1.0, 0.02, 0.0, 0.2, 0.02, 0.4, 20000, 50, 20240501)$\n    - B: $(\\$100.0, \\$100.0, 1.0, 0.02, 0.0, 0.2, 0.0, 0.4, 20000, 50, 20240501)$\n    - C: $(\\$100.0, \\$100.0, 1.0, 0.02, 0.0, 0.2, 0.02, 1.0, 20000, 50, 20240501)$\n    - D: $(\\$100.0, \\$90.0, 1.0, 0.01, 0.0, 0.0, 0.05, 0.4, 5000, 50, 7)$\n\n**步骤2：使用提取的既定信息进行验证**\n\n根据验证标准对问题进行评估。\n- **科学性**: 问题基于量化金融的标准基石模型（GBM, Merton 风格的违约模型）。所提供的公式正确且被广泛使用。该问题具有科学性。\n- **良构性**: 该问题结构清晰，包含所有必要的输入、指定的数值方法（带有已定义路径离散器和积分近似的蒙特卡洛方法）以及明确的目标。对于给定的随机种子，该过程会产生唯一的数值解。该问题是良构的。\n- **客观性**: 所有定义都是数学性的，所有输入都是数值。语言精确，没有主观性。该问题是客观的。\n- **其他缺陷**: 问题陈述是自包含、一致且可行的。没有矛盾、歧义或对伪科学的依赖。该任务是计算经济学和金融学中的一个标准练习。\n\n**步骤3：结论与行动**\n\n问题是 **有效的**。将构建一个解决方案。\n\n**解决方案：设计与实现**\n\n任务是推导 CVA 的离散估计量，并使用两种不同的计算范式（标量和向量化）来实现它。\n\n**1. 离散化与估计量推导**\n\n推导从提供的连续时间 CVA 公式开始：\n$$ \\text{CVA} = \\text{LGD} \\int_0^T D(0,t) \\, \\mathbb{E}[E_t] \\, f(t) \\, dt $$\n代入 LGD、贴现因子 $D(0,t)$ 和违约密度 $f(t)$ 的给定定义：\n$$ \\text{CVA} = (1-R) \\int_0^T e^{-rt} \\, \\mathbb{E}[E_t] \\, \\lambda e^{-\\lambda t} \\, dt $$\n问题要求使用在均匀时间网格上的右黎曼和来近似这个积分。区间 $[0, T]$ 被划分为 $M$ 个宽度为 $\\Delta t = T/M$ 的子区间 $[t_{i-1}, t_i]$，其中 $t_i = i \\Delta t$，i = $1, \\dots, M$。积分通过对被积函数在右端点 $t_i$ 处的值求和来近似：\n$$ \\int_0^T g(t) \\, dt \\approx \\sum_{i=1}^M g(t_i) \\Delta t $$\n将此应用于 CVA 积分，得到离散估计量：\n$$ \\text{CVA} \\approx (1-R) \\sum_{i=1}^{M} \\left( e^{-r t_i} \\, \\mathbb{E}[E_{t_i}] \\, \\lambda e^{-\\lambda t_i} \\right) \\Delta t $$\n这与问题陈述中指定的公式相匹配。下一步是使用具有 $N$ 条路径的蒙特卡洛模拟来估计未来期望风险暴露 $\\mathbb{E}[E_{t_i}]$。期望值被其样本均值估计量 $\\widehat{\\mathbb{E}}[E_{t_i}]$ 替代：\n$$ \\widehat{\\mathbb{E}}[E_{t_i}] = \\frac{1}{N} \\sum_{j=1}^{N} E_{t_i}^{(j)} $$\n其中 $E_{t_i}^{(j)}$ 是第 $j$ 条模拟路径在时间 $t_i$ 的风险暴露。风险暴露是模拟资产价格 $S_{t_i}^{(j)}$ 的函数：\n$$ E_{t_i}^{(j)} = \\max\\left( V_{t_i}^{(j)}, 0 \\right) = \\max\\left( S_{t_i}^{(j)} e^{-q (T - t_i)} - K e^{-r (T - t_i)}, 0 \\right) $$\n每条路径 $S^{(j)}$ 都是从 $S_{t_0}^{(j)}=S_0$ 开始，使用对数价格 SDE 的精确解逐步生成的：\n$$ S_{t_i}^{(j)} = S_{t_{i-1}}^{(j)} \\exp\\left( \\left( (r - q) - \\frac{1}{2}\\sigma^2 \\right) \\Delta t + \\sigma \\sqrt{\\Delta t} \\, Z_{i,j} \\right) $$\n其中 $Z_{i,j}$ 是独立的标准正态随机变量。\n\n组合这些部分，得到 CVA 估计量的完整计算公式。\n\n**2. 算法设计**\n\n基于推导出的估计量设计了两种计算后端。为了公平比较，两者必须使用相同的基础标准正态抽样矩阵 $Z \\in \\mathbb{R}^{N \\times M}$。\n\n**标量 (CPU) 后端：**\n这种方法使用显式的嵌套循环，这是传统 CPU 编程的典型特征。\n\n1.  初始化一个大小为 $M$ 的数组 `expected_exposures`，所有元素为零。\n2.  外层循环遍历从 $1$ 到 $N$ 的每条路径 $j$。\n3.  在外层循环内部，初始化路径的起始价格 `current_S = S_0`。\n4.  内层循环遍历从 $1$ 到 $M$ 的每个时间步 $i$。\n5.  在内层循环内部：\n    a. 获取随机正态抽样 $Z_{i,j}$。\n    b. 使用 GBM 步长公式从 `current_S` 计算下一个资产价格 $S_{t_i}$。\n    c. 计算此时间步的风险暴露 $E_{t_i}$。\n    d. 将此风险暴露加到该时间步的运行总和中：`expected_exposures[i-1] += E_{t_i}`。\n    e. 更新 `current_S = S_{t_i}`。\n6.  外层循环完成后，将 `expected_exposures` 的每个元素除以 $N$，完成平均值的计算。\n7.  使用刚刚计算出的 `expected_exposures` 数组，通过对离散积分近似的各项求和来计算最终的 CVA 值。\n\n**向量化 (SIMD/GPU风格) 后端：**\n这种方法利用数组编程一次性对整个向量或矩阵执行操作，模拟像 GPU 这样的并行处理器的单指令多数据 (SIMD) 范式。\n\n1.  生成整个 $N \\times M$ 的标准正态抽样矩阵 $Z$。\n2.  初始化一个大小为 $N$ 的向量 `S_current`，所有元素设置为 $S_0$。\n3.  初始化一个大小为 $M$ 的结果向量 `cva_sum_terms`，所有元素为零。\n4.  循环遍历从 $1$ 到 $M$ 的每个时间步 $i$。\n5.  在循环内部：\n    a. 获取当前步骤的随机抽样列向量 $Z_{:, i-1}$。\n    b. 在单个操作中更新包含 $N$ 个资产价格的整个 `S_current` 向量。\n    c. 同时计算包含 $N$ 个远期合约价值的向量 $V_{t_i}$。\n    d. 为所有路径计算包含 $N$ 个风险暴露的向量 $E_{t_i} = \\max(V_{t_i}, 0)$。\n    e. 计算此风险暴露向量的平均值以得到 $\\widehat{\\mathbb{E}}[E_{t_i}]$。\n    f. 计算 CVA 被积函数的第 $i$ 项并将其存储在 `cva_sum_terms[i-1]` 中。\n6.  循环结束后，通过对 `cva_sum_terms` 向量求和并乘以常数 $\\lambda$、$(1-R)$ 和 $\\Delta t$ 来计算最终的 CVA。\n\n这种向量化方法避免了对模拟路径的显式循环，代之以由 NumPy 等库提供的高度优化的低级数组操作。这通常会带来显著的性能提升。\n\n**3. 实现策略**\n\n解决方案将使用 Python 实现，并利用 NumPy 库进行数值计算，特别是用于向量化后端。对每个测试用例，将为随机数生成器设定种子以确保可复现性。为一个案例生成的相同随机数矩阵将传递给标量和向量化函数，以确保输出的唯一差异（如果有的话）是由浮点运算顺序引起的，而性能差异则是由算法造成的。将通过 `time.perf_counter()` 测量案例 A 的两个后端的运行时间，以满足基准测试要求，尽管这些计时数据不会成为最终打印输出的一部分。来自向量化后端的最终 CVA 值将按要求四舍五入到六位小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport time\n\ndef cva_scalar_cpu(S0, K, T, r, q, sigma, lambda_c, R, N, M, Z):\n    \"\"\"\n    Computes CVA using a scalar (loopy) implementation.\n    \"\"\"\n    dt = T / M\n    \n    if lambda_c == 0.0 or R == 1.0:\n        return 0.0\n\n    # Calculate Expected Exposures\n    expected_exposures = [0.0] * M\n    for j in range(N):  # Loop over paths\n        S_curr = S0\n        for i in range(M):  # Loop over time steps\n            drift = (r - q - 0.5 * sigma**2) * dt\n            diffusion = sigma * np.sqrt(dt) * Z[j, i]\n            S_curr *= np.exp(drift + diffusion)\n            \n            t = (i + 1) * dt\n            forward_val = S_curr * np.exp(-q * (T - t)) - K * np.exp(-r * (T - t))\n            exposure = max(forward_val, 0.0)\n            \n            expected_exposures[i] += exposure\n\n    for i in range(M):\n        expected_exposures[i] /= N\n\n    # Calculate CVA\n    cva_sum = 0.0\n    for i in range(M):\n        t = (i + 1) * dt\n        discount = np.exp(-r * t)\n        default_prob_density = lambda_c * np.exp(-lambda_c * t)\n        cva_sum += discount * expected_exposures[i] * default_prob_density\n\n    cva = (1 - R) * cva_sum * dt\n    return cva\n\ndef cva_vectorized_simd(S0, K, T, r, q, sigma, lambda_c, R, N, M, Z):\n    \"\"\"\n    Computes CVA using a vectorized (SIMD-style) implementation.\n    \"\"\"\n    dt = T / M\n    \n    if lambda_c == 0.0 or R == 1.0:\n        return 0.0\n\n    # Time grid\n    t = np.linspace(dt, T, M)\n    \n    # Generate asset price paths\n    S = np.zeros((N, M + 1))\n    S[:, 0] = S0\n    \n    drift = (r - q - 0.5 * sigma**2) * dt\n    diffusion = sigma * np.sqrt(dt)\n    \n    for i in range(M):\n        S[:, i + 1] = S[:, i] * np.exp(drift + diffusion * Z[:, i])\n    \n    S_paths = S[:, 1:] # Paths at t_1, ..., t_M\n    \n    # Calculate Exposures\n    forward_vals = S_paths * np.exp(-q * (T - t)) - K * np.exp(-r * (T - t))\n    exposures = np.maximum(forward_vals, 0)\n    \n    # Calculate Expected Exposures\n    expected_exposures = np.mean(exposures, axis=0)\n    \n    # Calculate CVA\n    discount = np.exp(-r * t)\n    default_prob_density = lambda_c * np.exp(-lambda_c * t)\n    integrand = (1 - R) * discount * expected_exposures * default_prob_density\n    \n    cva = np.sum(integrand) * dt\n    return cva\n\ndef solve():\n    \"\"\"\n    Main solver function to run test cases and produce the final output.\n    \"\"\"\n    # (S0, K, T, r, q, sigma, lambda_c, R, N, M, seed)\n    test_cases = [\n        (100.0, 100.0, 1.0, 0.02, 0.0, 0.2, 0.02, 0.4, 20000, 50, 20240501), # Case A\n        (100.0, 100.0, 1.0, 0.02, 0.0, 0.2, 0.0, 0.4, 20000, 50, 20240501),  # Case B\n        (100.0, 100.0, 1.0, 0.02, 0.0, 0.2, 0.02, 1.0, 20000, 50, 20240501),  # Case C\n        (100.0, 90.0, 1.0, 0.01, 0.0, 0.0, 0.05, 0.4, 5000, 50, 7),         # Case D\n    ]\n\n    results = []\n\n    # Process Case A separately to perform the required benchmark timing.\n    S0, K, T, r, q, sigma, lambda_c, R, N, M, seed = test_cases[0]\n    rng = np.random.default_rng(seed)\n    Z = rng.standard_normal(size=(N, M))\n    \n    # Time scalar implementation for Case A (computation must occur, but result is not printed)\n    start_time_scalar = time.perf_counter()\n    _ = cva_scalar_cpu(S0, K, T, r, q, sigma, lambda_c, R, N, M, Z)\n    end_time_scalar = time.perf_counter()\n    # scalar_time = end_time_scalar - start_time_scalar # For internal verification\n\n    # Time vectorized implementation for Case A and collect result\n    start_time_vec = time.perf_counter()\n    cva_A = cva_vectorized_simd(S0, K, T, r, q, sigma, lambda_c, R, N, M, Z)\n    end_time_vec = time.perf_counter()\n    # vec_time = end_time_vec - start_time_vec # For internal verification\n    \n    results.append(round(cva_A, 6))\n\n    # Process remaining cases (B, C, D) using only the vectorized backend for output\n    for case in test_cases[1:]:\n        S0, K, T, r, q, sigma, lambda_c, R, N, M, seed = case\n        rng = np.random.default_rng(seed)\n        Z = rng.standard_normal(size=(N, M))\n        cva = cva_vectorized_simd(S0, K, T, r, q, sigma, lambda_c, R, N, M, Z)\n        results.append(round(cva, 6))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, [f'{r:.6f}' for r in results]))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在前面的练习中，我们使用了简化的、恒定的违约强度 $\\lambda$。然而在实践中，交易对手的违约概率是复杂的，通常需要通过数据驱动的模型来估计。本练习将展示如何将现代数据科学技术融入CVA框架，通过使用逻辑回归模型为不同交易对手生成特定的违约概率，并将其作为输入整合到我们的CVA计算流程中。",
            "id": "2386252",
            "problem": "您的任务是计算一个投资组合的信用估值调整 (CVA)。其中，交易对手的违约概率由一个基于公司特定特征训练的逻辑回归 (LR) 模型导出。您的目标是首先从第一性原理出发进行推导，然后实现一个程序，在风险暴露与违约相互独立以及单边交易对手信用风险的假设下，根据风险中性测度计算投资组合的CVA。\n\n假设与基础框架：\n- 在风险中性估值下，投资组合的信用估值调整 (CVA) 可表示为在给定时间范围内，因交易对手违约而产生的折现后预期损失。设时间 $t \\in [0, T]$，$D(t)$ 为无风险贴现因子，$\\text{LGD}$ 为违约损失率，$E^{\\mathbb{Q}}[\\cdot]$ 为风险中性期望，$\\tau$ 为交易对手的随机违约时间。一般定义为\n$$\n\\text{CVA} \\;=\\; E^{\\mathbb{Q}}\\!\\left[\\int_{0}^{T} D(t)\\,\\text{LGD}\\,\\max(V(t),0)\\,\\mathrm{d}\\mathbf{1}_{\\{\\tau \\le t\\}}\\right].\n$$\n- 公司的时点违约概率使用逻辑回归模型进行建模。对于每个特征向量为 $x \\in \\mathbb{R}^{d}$ 的公司，设其 LR 得分为 $z = \\beta_0 + \\sum_{i=1}^{d} \\beta_i x_i$。年度无条件违约概率为 $p_{\\text{ann}} = \\sigma(z)$，其中 $\\sigma(u) = \\frac{1}{1 + e^{-u}}$ 是 logistic (sigmoid) 函数。\n- 对于强度为 $\\lambda$ 的恒定风险率模型，其生存函数为 $S(t) = e^{-\\lambda t}$，一年内的无条件违约概率与之相关，关系式为 $p_{\\text{ann}} = 1 - e^{-\\lambda \\cdot 1}$。这意味着 $\\lambda = -\\ln(1 - p_{\\text{ann}})$。\n- 对于一个离散的年度时间网格 $t_k = k$（其中 $k = 1, \\dots, K$），假设在网格点上的预期正风险暴露 (EPE) 是分段常数，并且存在一个固定的连续复利无风险利率 $r$，则贴现因子为 $D(t_k) = e^{-r t_k}$。\n- 在恒定风险率 $\\lambda$ 下，区间 $(t_{k-1}, t_k]$ 内的边际违约概率是 $S(t_{k-1}) - S(t_k)$，其中 $S(0) = 1$。\n\n任务：\n1. 从风险中性CVA的一般定义和上述假设出发，推导年度网格上投资组合CVA的离散化表达式。您的推导必须清楚地展示如何结合违约可能性、贴现因子、预期正风险暴露 (EPE) 和违约损失率 (LGD)。不要使用任何未经证明或解释的简化公式；从生存概率、风险率和风险中性期望的定义出发推导每一步。\n2. 实现一个程序，该程序：\n   - 使用 LR 模型，通过 $p_{\\text{ann}} = \\sigma(\\beta_0 + \\sum_{i=1}^{d} \\beta_i x_i)$ 从特征和系数计算年度违约概率 $p_{\\text{ann}}$。\n   - 将 $p_{\\text{ann}}$ 转换为恒定风险率 $\\lambda = -\\ln(1 - p_{\\text{ann}})$。\n   - 使用年度网格 $t_k = k$（其中 $k$ 等于公司的EPE点数）来计算生存概率 $S(t_k) = e^{-\\lambda t_k}$ 和边际违约概率 $S(t_{k-1}) - S(t_k)$。\n   - 将各时期 $k$ 的折现预期损失贡献求和，计算每个公司的CVA，然后对所有公司求和以获得投资组合的CVA。\n   - 实现数值稳定的 logistic 函数评估，并在应用对数变换前将概率裁剪到开区间 $(\\epsilon, 1-\\epsilon)$ 内，其中 $\\epsilon = 10^{-12}$。\n3. 使用以下测试套件。每个测试用例提供一个固定利率 $r$、一个截距项 $\\beta_0$、一个系数向量 $\\beta$，以及一个公司列表，每个公司都包含一个特征向量 $x$、一个违约损失率 $\\text{LGD}$ 和一个年度网格EPE向量。时间步长为一年，因此第 $k$ 个EPE条目对应于 $t_k = k$。\n   - 测试用例 1 (正常路径，多家公司，中等概率，期限5年)：\n     - $r = 0.02$,\n     - $\\beta_0 = -4.0$,\n     - $\\beta = [0.8, -0.5]$,\n     - 公司：\n       - 公司 A: $x = [1.2, 0.3]$, $\\text{LGD} = 0.6$, $\\text{EPE} = [1.0, 0.9, 0.8, 0.7, 0.6]$.\n       - 公司 B: $x = [0.5, -0.1]$, $\\text{LGD} = 0.6$, $\\text{EPE} = [0.5, 0.5, 0.5, 0.5, 0.5]$.\n       - 公司 C: $x = [-0.2, 1.5]$, $\\text{LGD} = 0.6$, $\\text{EPE} = [0.2, 0.25, 0.3, 0.35, 0.4]$.\n   - 测试用例 2 (边界条件：零风险暴露意味着零CVA，期限3年)：\n     - $r = 0.01$,\n     - $\\beta_0 = -4.0$,\n     - $\\beta = [0.8, -0.5]$,\n     - 公司：\n       - 公司 D: $x = [0.0, 0.0]$, $\\text{LGD} = 0.6$, $\\text{EPE} = [0.0, 0.0, 0.0]$.\n       - 公司 E: $x = [1.0, -1.0]$, $\\text{LGD} = 0.6$, $\\text{EPE} = [0.0, 0.0, 0.0]$.\n   - 测试用例 3 (边缘覆盖：高和低概率，异构LGD，零无风险利率，期限7年)：\n     - $r = 0.0$,\n     - $\\beta_0 = -1.0$,\n     - $\\beta = [1.5, 1.0]$,\n     - 公司：\n       - 公司 F: $x = [1.0, 1.0]$, $\\text{LGD} = 0.4$, $\\text{EPE} = [0.2, 0.4, 0.6, 0.8, 0.6, 0.4, 0.2]$.\n       - 公司 G: $x = [-2.0, -1.0]$, $\\text{LGD} = 0.6$, $\\text{EPE} = [1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4]$.\n4. 输出规格：\n   - 对每个测试用例，计算一个单一的投资组合CVA值，作为浮点数。\n   - 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。每个数字必须四舍五入到 $6$ 位小数。例如：$[0.123456,0.000000,1.234568]$。\n5. 角度单位不适用。百分比必须表示为小数（例如，$\\text{LGD} = 0.6$ 表示 $60\\%$）。不需要物理单位；货币价值被视为抽象数值。\n\n您的实现必须是自包含的，不需要任何输入，并严格遵循输出格式。任何与指定格式的偏离都将被视为不正确。该算法应具有足够的通用性以处理所列的测试套件。",
            "solution": "计算投资组合信用估值调整 (CVA) 的问题是有效的，因为它在科学上基于金融工程的既定原则，具有完整且一致的数据和假设，是一个适定的问题，并且其表述是客观的。下文是从第一性原理出发的推导，随后是解决方案的实现。\n\n推导从CVA的风险中性一般定义开始。CVA代表交易对手信用风险的市场价值。对于单个交易对手，它是在交易对手违约时刻 $\\tau$ 发生的损失的风险中性期望折现值。\n所提供的定义是：\n$$ \\text{CVA} = E^{\\mathbb{Q}}\\!\\left[\\int_{0}^{T} D(t)\\,\\text{LGD}\\,\\max(V(t),0)\\,\\mathrm{d}\\mathbf{1}_{\\{\\tau \\le t\\}}\\right] $$\n其中 $E^{\\mathbb{Q}}[\\cdot]$ 是在风险中性测度 $\\mathbb{Q}$ 下的期望，$D(t)$ 是时间 $t$ 的无风险贴现因子，$\\text{LGD}$ 是违约损失率（一个固定比例），$V(t)$ 是与交易对手的交易组合的市场价值，$\\tau$ 是随机违约时间。$\\max(V(t),0)$ 项代表违约时的风险暴露，因为只有当投资组合对我们具有正价值时才会发生损失。该积分为斯蒂尔切斯积分，可以解释为在违约瞬间 $\\tau$（前提是 $\\tau \\le T$）评估折现损失。一个更标准的公式是：\n$$ \\text{CVA} = E^{\\mathbb{Q}}\\!\\left[ \\mathbf{1}_{\\{\\tau \\le T\\}} \\cdot D(\\tau) \\cdot \\text{LGD} \\cdot \\max(V(\\tau), 0) \\right] $$\n这将CVA表示为从违约时间 $\\tau$ 折现的损失期望值。为了评估这个期望，我们可以对所有可能的违约时间进行积分，并按其风险中性概率密度加权。设 $f_\\tau(t)$ 为违约时间 $\\tau$ 的概率密度函数 (PDF)。那么CVA为：\n$$ \\text{CVA} = \\int_{0}^{T} E^{\\mathbb{Q}}\\!\\left[ D(t) \\cdot \\text{LGD} \\cdot \\max(V(t), 0) \\mid \\tau=t \\right] f_\\tau(t) \\, \\mathrm{d}t $$\n一个关键的假设是违约事件与驱动投资组合价值 $V(t)$ 的市场风险之间是相互独立的。这使我们能够分离期望：\n$$ E^{\\mathbb{Q}}\\!\\left[ D(t) \\cdot \\text{LGD} \\cdot \\max(V(t), 0) \\mid \\tau=t \\right] = D(t) \\cdot \\text{LGD} \\cdot E^{\\mathbb{Q}}\\!\\left[\\max(V(t), 0)\\right] $$\n$E^{\\mathbb{Q}}\\!\\left[\\max(V(t), 0)\\right]$ 项是预期正风险暴露，记为 $\\text{EPE}(t)$。公式简化为：\n$$ \\text{CVA} = \\int_{0}^{T} D(t) \\cdot \\text{LGD} \\cdot \\text{EPE}(t) \\cdot f_\\tau(t) \\, \\mathrm{d}t $$\nPDF $f_\\tau(t)$ 与生存概率函数 $S(t) = P(\\tau > t)$ 的关系为 $f_\\tau(t) = -\\frac{\\mathrm{d}S(t)}{\\mathrm{d}t}$。将其代入，我们得到：\n$$ \\text{CVA} = -\\int_{0}^{T} D(t) \\cdot \\text{LGD} \\cdot \\text{EPE}(t) \\cdot S'(t) \\, \\mathrm{d}t $$\n为了进行数值实现，我们将时间范围 $[0, T]$ 离散化为 $K$ 个区间 $(t_{k-1}, t_k]$，其中 $t_k = k$（对于 $k=1, \\dots, K$）且 $t_0=0$。该积分通过对这些区间的求和来近似：\n$$ \\text{CVA} \\approx \\sum_{k=1}^{K} \\int_{t_{k-1}}^{t_k} D(t) \\cdot \\text{LGD} \\cdot \\text{EPE}(t) \\cdot f_\\tau(t) \\, \\mathrm{d}t $$\n我们假设在每个小区间 $(t_{k-1}, t_k]$ 内，$D(t)$ 和 $\\text{EPE}(t)$ 项近似为常数，并可以在区间末端进行评估，即 $D(t) \\approx D(t_k)$ 和 $\\text{EPE}(t) \\approx \\text{EPE}(t_k)$。这是一个标准的一阶近似。\n$$ \\text{CVA} \\approx \\sum_{k=1}^{K} D(t_k) \\cdot \\text{LGD} \\cdot \\text{EPE}(t_k) \\int_{t_{k-1}}^{t_k} f_\\tau(t) \\, \\mathrm{d}t $$\nPDF在区间 $(t_{k-1}, t_k]$ 上的积分就是在该区间内违约的概率：\n$$ \\int_{t_{k-1}}^{t_k} f_\\tau(t) \\, \\mathrm{d}t = P(t_{k-1} < \\tau \\le t_k) = S(t_{k-1}) - S(t_k) $$\n该项是第 $k$ 期的边际违约概率。将其代入求和公式，得到单个交易对手CVA的最终离散化公式：\n$$ \\text{CVA}_{\\text{firm}} \\approx \\text{LGD} \\sum_{k=1}^{K} D(t_k) \\cdot \\text{EPE}(t_k) \\cdot [S(t_{k-1}) - S(t_k)] $$\n投资组合CVA是每个独立交易对手CVA的总和，假设它们的违约是独立事件：\n$$ \\text{CVA}_{\\text{portfolio}} = \\sum_{j} \\text{CVA}_{\\text{firm } j} $$\n现在我们整合所提供的具体模型。违约过程由一个恒定的风险率 $\\lambda$ 建模。生存函数为 $S(t) = e^{-\\lambda t}$。风险率 $\\lambda$ 从逻辑回归模型的输出（即年度无条件违约概率 $p_{\\text{ann}}$）推导得出。其关系为 $p_{\\text{ann}} = P(\\tau \\le 1) = 1 - S(1) = 1 - e^{-\\lambda \\cdot 1}$。解出 $\\lambda$ 得到 $\\lambda = -\\ln(1 - p_{\\text{ann}})$。年度概率 $p_{\\text{ann}}$ 由线性得分 $z = \\beta_0 + \\mathbf{x}^T \\boldsymbol{\\beta}$ 的sigmoid函数 $\\sigma(z)$ 给出：\n$$ p_{\\text{ann}} = \\sigma(z) = \\frac{1}{1+e^{-z}} $$\n在时间 $t_k=k$ 时，对于连续复利率 $r$，无风险贴现因子为 $D(t_k) = e^{-r t_k}$。综合所有组成部分，我们按如下方式计算单个公司的CVA：\n1.  计算得分 $z = \\beta_0 + \\sum_{i=1}^{d} \\beta_i x_i$。\n2.  使用数值稳定的实现来计算年度违约概率 $p_{\\text{ann}} = \\sigma(z)$。将 $p_{\\text{ann}}$ 裁剪到 $(\\epsilon, 1-\\epsilon)$ 区间内，其中 $\\epsilon=10^{-12}$。\n3.  计算恒定风险率 $\\lambda = -\\ln(1 - p_{\\text{ann}})$。\n4.  计算每个时间区间 $k=1, \\dots, K$ 的CVA贡献：\n    $$ \\text{CVA}_{\\text{firm}} = \\text{LGD} \\sum_{k=1}^{K} e^{-r k} \\cdot \\text{EPE}_k \\cdot (e^{-\\lambda (k-1)} - e^{-\\lambda k}) $$\n    其中 $\\text{EPE}_k$ 是给定的第 $k$ 年的预期正风险暴露。总的投资组合CVA是所有公司这些值的总和。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes portfolio CVA based on a logistic regression model for default probabilities.\n    \"\"\"\n    # Test cases defined in the problem statement.\n    test_cases = [\n        # Test case 1\n        {\n            \"r\": 0.02,\n            \"beta0\": -4.0,\n            \"beta\": np.array([0.8, -0.5]),\n            \"firms\": [\n                {\"x\": np.array([1.2, 0.3]), \"lgd\": 0.6, \"epe\": np.array([1.0, 0.9, 0.8, 0.7, 0.6])},\n                {\"x\": np.array([0.5, -0.1]), \"lgd\": 0.6, \"epe\": np.array([0.5, 0.5, 0.5, 0.5, 0.5])},\n                {\"x\": np.array([-0.2, 1.5]), \"lgd\": 0.6, \"epe\": np.array([0.2, 0.25, 0.3, 0.35, 0.4])},\n            ]\n        },\n        # Test case 2\n        {\n            \"r\": 0.01,\n            \"beta0\": -4.0,\n            \"beta\": np.array([0.8, -0.5]),\n            \"firms\": [\n                {\"x\": np.array([0.0, 0.0]), \"lgd\": 0.6, \"epe\": np.array([0.0, 0.0, 0.0])},\n                {\"x\": np.array([1.0, -1.0]), \"lgd\": 0.6, \"epe\": np.array([0.0, 0.0, 0.0])},\n            ]\n        },\n        # Test case 3\n        {\n            \"r\": 0.0,\n            \"beta0\": -1.0,\n            \"beta\": np.array([1.5, 1.0]),\n            \"firms\": [\n                {\"x\": np.array([1.0, 1.0]), \"lgd\": 0.4, \"epe\": np.array([0.2, 0.4, 0.6, 0.8, 0.6, 0.4, 0.2])},\n                {\"x\": np.array([-2.0, -1.0]), \"lgd\": 0.6, \"epe\": np.array([1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4])},\n            ]\n        }\n    ]\n\n    results = []\n    \n    # Numerical precision for clipping\n    epsilon = 1e-12\n\n    def stable_sigmoid(z):\n        \"\"\"Numerically stable sigmoid function.\"\"\"\n        if z >= 0:\n            return 1.0 / (1.0 + np.exp(-z))\n        else:\n            # Use formulation exp(z) / (1 + exp(z)) to avoid overflow\n            exp_z = np.exp(z)\n            return exp_z / (1.0 + exp_z)\n\n    for case in test_cases:\n        r = case[\"r\"]\n        beta0 = case[\"beta0\"]\n        beta = case[\"beta\"]\n        firms = case[\"firms\"]\n        \n        portfolio_cva = 0.0\n        \n        for firm in firms:\n            x = firm[\"x\"]\n            lgd = firm[\"lgd\"]\n            epe = firm[\"epe\"]\n            \n            # 1. Compute LR score\n            z = beta0 + np.dot(beta, x)\n            \n            # 2. Compute annual default probability\n            p_ann = stable_sigmoid(z)\n            \n            # 3. Clip for numerical stability before log\n            p_ann_clipped = np.clip(p_ann, epsilon, 1.0 - epsilon)\n            \n            # 4. Convert to constant hazard rate\n            # If p_ann is 1, lambda would be inf. Clipping handles this.\n            hazard_rate_lambda = -np.log(1.0 - p_ann_clipped)\n            \n            firm_cva = 0.0\n            num_steps = len(epe)\n            \n            if num_steps == 0 or np.sum(epe) == 0:\n                portfolio_cva += 0.0\n                continue\n                \n            # Time steps k = 1, 2, ..., K\n            k_steps = np.arange(1, num_steps + 1)\n            \n            # Discount factors D(t_k) = exp(-r*k)\n            discount_factors = np.exp(-r * k_steps)\n            \n            # Survival probabilities S(t_k) = exp(-lambda*k) and S(t_{k-1})\n            s_k_minus_1 = np.exp(-hazard_rate_lambda * (k_steps - 1))\n            s_k = np.exp(-hazard_rate_lambda * k_steps)\n            \n            # Marginal default probabilities in (t_{k-1}, t_k]\n            marginal_pd = s_k_minus_1 - s_k\n            \n            # Expected loss for each period\n            expected_loss_periods = epe * marginal_pd\n            \n            # Discounted expected loss for each period\n            discounted_el = discount_factors * expected_loss_periods\n            \n            # Sum over all periods and multiply by LGD for the firm's CVA\n            firm_cva = lgd * np.sum(discounted_el)\n            \n            portfolio_cva += firm_cva\n            \n        results.append(round(portfolio_cva, 6))\n\n    # Format the final output string\n    print(f\"[{','.join(f'{res:.6f}' for res in results)}]\")\n\nsolve()\n```"
        }
    ]
}