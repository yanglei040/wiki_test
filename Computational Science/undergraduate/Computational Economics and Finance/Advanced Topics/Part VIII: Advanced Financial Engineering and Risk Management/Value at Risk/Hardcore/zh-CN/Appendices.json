{
    "hands_on_practices": [
        {
            "introduction": "理论为我们揭示了风险价值（VaR）的“是什么”和“为什么”，但要真正掌握它，我们必须亲身实践。本章节将通过三个动手练习来指导你，从一个揭示常见陷阱的简单估算技术开始，然后使用历史模拟法构建一个完整的VaR模型，最后学习如何严格评估模型的表现。这些实践将为你装备进行真实世界风险分析所需的核心技能。\n\n我们首先从一个看似简单的问题开始。风险模型通常会输出标准置信水平（如 $0.95$ 或 $0.99$）下的VaR值。但如果你需要一个非标准水平（比如 $0.975$）的VaR估算，该怎么办呢？一个直观的方法是线性插值。这个练习将引导你完成这个计算，但更重要的是，它将挑战你批判性地思考这种简单方法背后隐藏的风险，特别是在处理极端损失的非线性行为时。",
            "id": "2419212",
            "problem": "一家银行的交易部门报告了单日在险价值 (VaR) 的估计值。在险价值 (VaR) 定义为，在给定的置信缺口下，损失超过某个阈值的概率至多为此缺口时，该阈值的最小值。报告涵盖了三个置信水平 $\\alpha \\in \\{0.95, 0.99, 0.999\\}$。具体来说，模型的输出为 $V(0.95)=2.5$、$V(0.99)=5.0$ 和 $V(0.999)=12.0$，其中 $V(\\alpha)$ 表示在置信水平 $\\alpha$ 下的单日 VaR，单位为百万美元 (USD)。使用在置信水平轴上的分段线性插值法，估计在 $\\alpha=0.975$ 时的单日 VaR。在你的推理中，讨论这种插值方法用于尾部风险度量的任何风险或局限性。将你的答案四舍五入到四位有效数字。以百万美元 (USD) 为单位表示最终值。最终答案只提供数值。",
            "solution": "在尝试任何解决方案之前，需对问题陈述进行验证。\n\n**步骤 1：提取已知信息**\n提供的已知信息如下：\n- 一组在不同置信水平 $\\alpha$ 下的单日在险价值 (VaR) 估计值。\n- 数据点 1：$V(0.95) = 2.5$ 百万美元。\n- 数据点 2：$V(0.99) = 5.0$ 百万美元。\n- 数据点 3：$V(0.999) = 12.0$ 百万美元。\n- 任务是使用在置信水平轴上的分段线性插值法，估计在 $\\alpha = 0.975$ 时的单日 VaR。\n- 任务还要求讨论这种方法的风险和局限性。\n- 最终答案必须四舍五入到四位有效数字。\n\n**步骤 2：使用提取的已知信息进行验证**\n- **科学依据：** 该问题使用了量化金融（在险价值）和数值方法（分段线性插值）中的标准概念。它在科学上是合理的。\n- **适定性：** 这是一个适定问题。目标点 $\\alpha = 0.975$ 位于给定数据点 $[0.95, 0.99]$ 定义的区间内，并且提供了该区间的 VaR 值。这使得插值成为一个定义明确的过程。\n- **客观性：** 该问题使用客观、量化的数据和术语进行陈述。\n- **完整性和一致性：** 该问题为指定的插值任务提供了所有必要的数据。数据与金融理论一致，因为 VaR 是置信水平 $\\alpha$ 的增函数，给定点满足此条件：$V(0.95)  V(0.99)  V(0.999)$。\n\n**步骤 3：结论和行动**\n该问题被视为有效。将提供解决方案。\n\n任务是使用分段线性插值法找到 VaR 函数 $V(\\alpha)$ 在 $\\alpha = 0.975$ 处的值。给定的数据点是 $( \\alpha_i, V_i )$，其中 $V_i = V(\\alpha_i)$。我们有这些点：$(0.95, 2.5)$、$(0.99, 5.0)$ 和 $(0.999, 12.0)$。\n\n目标置信水平 $\\alpha = 0.975$ 位于区间 $[0.95, 0.99]$ 内。因此，我们必须使用界定此区间的两个数据点：$(\\alpha_1, V_1) = (0.95, 2.5)$ 和 $(\\alpha_2, V_2) = (0.99, 5.0)$。\n\n函数 $f(x)$ 在两个已知点 $(x_1, y_1)$ 和 $(x_2, y_2)$ 之间的一点 $x$ 处的线性插值公式由下式给出：\n$$y = y_1 + (x - x_1) \\frac{y_2 - y_1}{x_2 - x_1}$$\n在我们的情境中，$x$ 对应于置信水平 $\\alpha$，$y$ 对应于 VaR 值 $V(\\alpha)$。因此，我们有：\n$$V(\\alpha) = V(\\alpha_1) + (\\alpha - \\alpha_1) \\frac{V(\\alpha_2) - V(\\alpha_1)}{\\alpha_2 - \\alpha_1}$$\n\n代入给定值：\n- 目标点：$\\alpha = 0.975$\n- 第一个点：$(\\alpha_1, V_1) = (0.95, 2.5)$\n- 第二个点：$(\\alpha_2, V_2) = (0.99, 5.0)$\n\n计算过程如下：\n$$V(0.975) = 2.5 + (0.975 - 0.95) \\frac{5.0 - 2.5}{0.99 - 0.95}$$\n$$V(0.975) = 2.5 + (0.025) \\frac{2.5}{0.04}$$\n线段的斜率为：\n$$\\frac{2.5}{0.04} = 62.5$$\n继续计算：\n$$V(0.975) = 2.5 + 0.025 \\times 62.5$$\n$$V(0.975) = 2.5 + 1.5625$$\n$$V(0.975) = 4.0625$$\n\n问题要求将答案四舍五入到四位有效数字。计算值为 $4.0625$。第四位有效数字是 $2$。后面的数字是 $5$，因此我们向上取整。舍入后的值为 $4.063$。在 $\\alpha = 0.975$ 时，估计的 VaR 为 $4.063$ 百万美元。\n\n**风险与局限性讨论**\n\n使用分段线性插值法估算 VaR，尤其是在分布的尾部，充满了重大风险和局限性。该方法的前提是假设 VaR 函数（即损失分布的分位数函数或逆累积分布函数）相对于置信水平 $\\alpha$ 是线性的。对于金融资产回报而言，这一假设存在根本性缺陷。\n\n1.  **分位数函数的非线性：** 金融损失分布的尾部通常是“肥尾”的，这意味着极端事件发生的概率比正态分布预测的要高。这一特性在数学上表现为，对于较高的 $\\alpha$ 值，分位数函数 $V(\\alpha) = F_L^{-1}(\\alpha)$ 是凸函数。凸函数的增长速度是递增的。线性插值假设两点之间的增长率（斜率）恒定，其插值结果将位于真实凸函数曲线的下方。因此，线性插值会系统性地**低估**真实的 VaR。\n\n2.  **来自给定数据的经验证据：** 所提供的数据本身就为反驳线性假设提供了有力证据。我们可以计算 VaR 函数在两个给定区间上的斜率。\n    -   在 $[0.95, 0.99]$ 上的斜率：\n        $$m_1 = \\frac{V(0.99) - V(0.95)}{0.99 - 0.95} = \\frac{5.0 - 2.5}{0.04} = 62.5$$\n    -   在 $[0.99, 0.999]$ 上的斜率：\n        $$m_2 = \\frac{V(0.999) - V(0.99)}{0.999 - 0.99} = \\frac{12.0 - 5.0}{0.009} = \\frac{7}{0.009} \\approx 777.8$$\n    斜率从 $m_1 = 62.5$ 急剧增加到 $m_2 \\approx 777.8$，这为函数的强凸性提供了明确的经验证据。VaR 在更远的尾部增长得更快。我们对 $\\alpha = 0.975$ 的线性插值使用了斜率 $m_1 = 62.5$，这显然不能代表哪怕是稍微深入尾部一点的行为。在 $\\alpha = 0.975$ 处的真实 VaR 几乎肯定高于我们估计的 $4.063$ 百万美元。\n\n3.  **模型风险和虚假精度：** 这种方法引入了显著的模型风险。通过提供一个精确的数值答案，它制造了一种虚假的安全感。真实的风险被低估，这可能对风险管理、资本配置和监管合规性造成灾难性后果。正确的尾部风险建模需要基于极值理论 (EVT) 的方法，例如将广义帕累托分布 (GPD) 拟合到尾部损失。这类方法通常涉及在变换后的尺度上进行插值，例如，对 $\\ln(V(\\alpha))$ 与 $\\ln(1-\\alpha)$ 进行线性插值，这对应于假设一个幂律尾部行为，这对金融数据来说是一个远为更现实的前提。\n\n总之，尽管在 $(\\alpha, V(\\alpha))$ 上进行分段线性插值在计算上很简单，但它是一种用于估计尾部风险度量的幼稚且危险的技术。它忽略了金融回报分布的基本属性，并导致对风险的实质性低估。",
            "answer": "$$\\boxed{4.063}$$"
        },
        {
            "introduction": "在认识到过度简化估算的风险后，我们现在转向非参数风险建模的一个基石：历史模拟法。该方法不预设回报率遵循特定的理论分布，而是让“历史”数据自己说话。在这个编程练习中，你将从零开始构建一个VaR估算引擎，从生成相关的资产回报数据，到为不同的投资组合策略计算最终的VaR。 这将巩固估算VaR的核心计算技能。",
            "id": "2390037",
            "problem": "给定一个包含 $N=10$ 种资产的投资组合。设投资组合权重向量为 $\\mathbf{w} \\in \\mathbb{R}^{10}$，过去 $T$ 天的历史回报率为矩阵 $\\mathbf{R} \\in \\mathbb{R}^{T \\times 10}$，其第 $t$ 行为 $\\mathbf{r}_t^\\top$。每日投资组合回报率为 $R^p_t = \\sum_{i=1}^{10} w_i r_{t,i}$，每日投资组合损失为 $L_t = - R^p_t$。对于一个损失随机变量 $L$，其 $99\\%$ 风险价值 (Value at Risk, VaR) 定义为满足 $\\mathbb{P}(L \\le v) \\ge 0.99$ 的最小数值 $v$。在历史模拟法下，使用样本 $\\{L_t\\}_{t=1}^T$ 的经验分布来代替 $L$ 的分布。使用经验分布函数，将经验 $p$-分位数定义为索引 $k = \\lceil p \\cdot T \\rceil$（采用 1-基索引）处的顺序统计量，即，将 $\\{L_t\\}$ 按非递减顺序排序得到 $L_{(1)} \\le \\cdots \\le L_{(T)}$，并设 $\\widehat{q}_p = L_{(k)}$，其中 $k = \\lceil p \\cdot T \\rceil$。那么，$99\\%$ VaR 的历史模拟估计值为 $\\widehat{\\mathrm{VaR}}_{0.99} = \\widehat{q}_{0.99}$。所有输出都必须以小数形式报告（例如，报告 $0.025$ 而不是 $2.5\\%$）。\n\n为了确保数据集科学合理、可复现，并能捕捉跨资产相关性，请按如下方式构建历史回报率。设各资产每日波动率向量为 $\\boldsymbol{\\sigma} = (\\sigma_1,\\ldots,\\sigma_{10})$，其中对于 $i \\in \\{1,\\ldots,10\\}$，$\\sigma_i = 0.01 + 0.002 \\cdot (i-1)$。定义相关矩阵 $\\mathbf{C} \\in \\mathbb{R}^{10 \\times 10}$ 为 $C_{ij} = \\rho^{|i-j|}$，其中 $\\rho = 0.6$；并定义协方差矩阵 $\\boldsymbol{\\Sigma} = \\mathbf{D} \\mathbf{C} \\mathbf{D}$，其中 $\\mathbf{D} = \\mathrm{diag}(\\boldsymbol{\\sigma})$。对于给定的 $T$，通过抽取一个具有独立同分布标准正态元素的矩阵 $\\mathbf{Z} \\in \\mathbb{R}^{T \\times 10}$，然后设置 $\\mathbf{R} = \\mathbf{Z} \\mathbf{L}^\\top$ 来生成历史样本，其中 $\\mathbf{L}$ 是 $\\boldsymbol{\\Sigma}$ 的下三角 Cholesky 因子，满足 $\\boldsymbol{\\Sigma} = \\mathbf{L} \\mathbf{L}^\\top$。每次生成数据集时，使用固定的伪随机种子 $12345$。此过程会生成具有指定协方差的相关资产回报率，作为历史模拟的历史样本。本任务不涉及角度。不适用任何物理单位；所有损失均以无单位的小数报告。\n\n请实现一个程序，根据上述经验顺序统计量的定义，为以下每个测试案例计算 $\\widehat{\\mathrm{VaR}}_{0.99}$。在所有案例中，都使用生成方法和固定的种子 $12345$ 为指定的 $T$ 生成 $\\mathbf{R}$ 矩阵。\n\n测试套件：\n- 案例 A（一般情况）：$T = 1000$，对于所有 $i \\in \\{1,\\ldots,10\\}$，权重 $w_i = 1/10$。\n- 案例 B（集中度边缘情况）：$T = 500$，权重 $w_1 = 1$，对于所有 $i \\in \\{2,\\ldots,10\\}$，权重 $w_i = 0$。\n- 案例 C（风险平价风格情况）：$T = 252$，权重由 $w_i \\propto 1/\\sigma_i$ 给出，其中 $i \\in \\{1,\\ldots,10\\}$，并进行归一化以使 $\\sum_{i=1}^{10} w_i = 1$。\n\n算法要求：\n- 使用如上定义的经验分位数，其中 $k = \\lceil 0.99 \\cdot T \\rceil$（无插值）。\n- 对于每个案例，根据生成的回报率和指定的权重计算损失序列 $\\{L_t\\}_{t=1}^T$，然后计算 $\\widehat{\\mathrm{VaR}}_{0.99}$。\n- 将每个最终的 $\\widehat{\\mathrm{VaR}}_{0.99}$ 四舍五入到 $6$ 位小数。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含案例 A、B 和 C 的三个四舍五入后的结果，按顺序排列，形式为用方括号括起来的逗号分隔列表。例如，输出必须类似于 $[x_A,x_B,x_C]$，其中每个 $x$ 都精确显示到 $6$ 位小数。",
            "solution": "该问题定义明确、科学合理且内部一致。我们将着手提供一个形式化的解决方案。\n\n目标是计算一个包含 $N=10$ 种资产的投资组合在三种不同情景下的 $99\\%$ 风险价值 ($\\mathrm{VaR}_{0.99}$)。计算将使用历史模拟法，其中的历史数据是根据指定的统计模型综合生成的。\n\n**1. 资产回报率的综合生成**\n\n模拟的核心是生成一个 $T \\times N$ 的历史回报率矩阵 $\\mathbf{R}$，其中 $T$ 是天数，$N=10$ 是资产数量。回报率被建模为从均值为零、协方差矩阵为 $\\boldsymbol{\\Sigma}$ 的多元正态分布中抽取的样本。这种协方差结构对于捕捉资产价格变动之间的相互依赖关系至关重要。\n\n首先，我们定义协方差矩阵 $\\boldsymbol{\\Sigma} \\in \\mathbb{R}^{10 \\times 10}$ 的分量。\n各资产每日波动率向量为 $\\boldsymbol{\\sigma} = (\\sigma_1, \\sigma_2, \\dots, \\sigma_{10})^\\top$，其中第 $i$ 种资产的波动率由以下公式给出：\n$$\n\\sigma_i = 0.01 + 0.002 \\cdot (i-1) \\quad \\text{for } i \\in \\{1, 2, \\dots, 10\\}\n$$\n这产生了一系列波动率，从 $\\sigma_1 = 0.01$ 开始，递增至 $\\sigma_{10} = 0.028$。这些波动率构成了矩阵 $\\mathbf{D} = \\mathrm{diag}(\\boldsymbol{\\sigma})$ 的对角线。\n\n接下来，相关结构由一个矩阵 $\\mathbf{C} \\in \\mathbb{R}^{10 \\times 10}$ 定义，其中资产 $i$ 和资产 $j$ 之间的相关性为：\n$$\nC_{ij} = \\rho^{|i-j|}\n$$\n参数 $\\rho$ 给定为 $0.6$。这种结构意味着索引上更接近的资产相关性更强。\n\n协方差矩阵 $\\boldsymbol{\\Sigma}$ 随之组装为：\n$$\n\\boldsymbol{\\Sigma} = \\mathbf{D} \\mathbf{C} \\mathbf{D}\n$$\n为了生成相关的随机变量，我们使用 $\\boldsymbol{\\Sigma}$ 的 Cholesky 分解。我们找到一个下三角矩阵 $\\mathbf{L}$，使得 $\\boldsymbol{\\Sigma} = \\mathbf{L} \\mathbf{L}^\\top$。\n\n历史回报率矩阵 $\\mathbf{R}$ 的生成过程是：首先创建一个由独立同分布的标准正态随机变量 ($\\mathcal{N}(0,1)$) 组成的矩阵 $\\mathbf{Z} \\in \\mathbb{R}^{T \\times 10}$。然后通过以下变换获得相关的回报率：\n$$\n\\mathbf{R} = \\mathbf{Z} \\mathbf{L}^\\top\n$$\n$\\mathbf{R}$ 的每一行 $\\mathbf{r}_t^\\top$ 都是一个随机向量，代表这 10 种资产的每日回报率，这些向量是从 $\\mathcal{N}(\\mathbf{0}, \\boldsymbol{\\Sigma})$ 中抽取的。为保证可复现性，对于每个数据生成过程，伪随机数生成器都使用固定的种子 $12345$ 进行初始化。\n\n**2. 用于计算风险价值（$\\mathrm{VaR}$）的历史模拟法**\n\n给定一个投资组合权重向量 $\\mathbf{w} = (w_1, w_2, \\dots, w_{10})^\\top$，每日投资组合回报率 $R^p_t$ 是各资产回报率的加权和：\n$$\nR^p_t = \\mathbf{r}_t^\\top \\mathbf{w} = \\sum_{i=1}^{10} w_i r_{t,i}\n$$\n相应的每日投资组合损失定义为回报率的负数：$L_t = -R^p_t$。对从 $1$ 到 $T$ 的每一天 $t$ 都执行此计算，从而得到一个历史损失样本 $\\{L_t\\}_{t=1}^T$。\n\n历史模拟法根据此损失样本的经验分布来估计 $\\mathrm{VaR}$。损失分布的 $p$-分位数是通过从排序后的损失数据中找到一个特定值来估计的。我们将损失按非递减顺序排序：\n$$\nL_{(1)} \\le L_{(2)} \\le \\cdots \\le L_{(T)}\n$$\n问题规定，经验 $p$-分位数 $\\widehat{q}_p$ 是第 $k$ 个顺序统计量 $L_{(k)}$，其中索引 $k$ 由以下公式给出：\n$$\nk = \\lceil p \\cdot T \\rceil\n$$\n这是一个 1-基索引。对于 $99\\%$ $\\mathrm{VaR}$，我们设置 $p=0.99$，因此历史估计值为：\n$$\n\\widehat{\\mathrm{VaR}}_{0.99} = L_{(k)} \\quad \\text{with} \\quad k = \\lceil 0.99 \\cdot T \\rceil\n$$\n\n**3. 应用于测试案例**\n\n现在我们将此方法应用于三个指定的测试案例。协方差矩阵 $\\boldsymbol{\\Sigma}$ 及其 Cholesky 因子 $\\mathbf{L}$ 对所有案例都是通用的，因为它们仅取决于 $N=10$ 和固定参数 $\\boldsymbol{\\sigma}$ 和 $\\rho$。\n\n**案例 A：一般情况**\n-   时间周期：$T = 1000$。\n-   投资组合权重：一个等权重投资组合，对所有 $i$ 都有 $w_i = 1/10 = 0.1$。\n-   $\\mathrm{VaR}$ 索引：$k = \\lceil 0.99 \\cdot 1000 \\rceil = \\lceil 990 \\rceil = 990$。\n-   步骤：\n    1.  使用种子 $12345$ 生成 $\\mathbf{R} \\in \\mathbb{R}^{1000 \\times 10}$。\n    2.  使用 $\\mathbf{w} = (0.1, \\dots, 0.1)^\\top$ 计算损失序列 $\\{L_t\\}_{t=1}^{1000}$。\n    3.  对损失进行排序并选择第 $990$ 个值，$L_{(990)}$。\n\n**案例 B：集中度边缘情况**\n-   时间周期：$T = 500$。\n-   投资组合权重：一个完全集中于第一种资产的投资组合，$\\mathbf{w} = (1, 0, \\dots, 0)^\\top$。\n-   $\\mathrm{VaR}$ 索引：$k = \\lceil 0.99 \\cdot 500 \\rceil = \\lceil 495 \\rceil = 495$。\n-   步骤：\n    1.  使用种子 $12345$ 生成 $\\mathbf{R} \\in \\mathbb{R}^{500 \\times 10}$。\n    2.  计算损失序列 $\\{L_t\\}_{t=1}^{500}$。此处，$L_t = -r_{t,1}$。\n    3.  对损失进行排序并选择第 $495$ 个值，$L_{(495)}$。\n\n**案例 C：风险平价风格情况**\n-   时间周期：$T = 252$（约等于一个交易年）。\n-   投资组合权重：权重与资产波动率成反比，$w_i \\propto 1/\\sigma_i$。这是一种受“风险平价”启发的配置，其中波动性较低的资产获得更高的权重。权重必须归一化以使其总和为 $1$：\n    $$\n    w_i = \\frac{1/\\sigma_i}{\\sum_{j=1}^{10} (1/\\sigma_j)}\n    $$\n-   $\\mathrm{VaR}$ 索引：$k = \\lceil 0.99 \\cdot 252 \\rceil = \\lceil 249.48 \\rceil = 250$。\n-   步骤：\n    1.  计算归一化权重 $\\mathbf{w}$。\n    2.  使用种子 $12345$ 生成 $\\mathbf{R} \\in \\mathbb{R}^{252 \\times 10}$。\n    3.  使用计算出的 $\\mathbf{w}$ 计算损失序列 $\\{L_t\\}_{t=1}^{252}$。\n    4.  对损失进行排序并选择第 $250$ 个值，$L_{(250)}$。\n\n对于每个案例，计算出的 $\\widehat{\\mathrm{VaR}}_{0.99}$ 将按要求四舍五入到 $6$ 位小数。实现将使用 0-基数组索引，因此在 1-基系统中的索引 $k$ 对应于代码中的索引 $k-1$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef generate_returns(T, N, sigma_vec, corr_matrix, seed):\n    \"\"\"\n    Generates a matrix of correlated asset returns.\n\n    Args:\n        T (int): Number of time periods (days).\n        N (int): Number of assets.\n        sigma_vec (np.ndarray): Vector of asset volatilities.\n        corr_matrix (np.ndarray): Asset correlation matrix.\n        seed (int): Seed for the random number generator.\n\n    Returns:\n        np.ndarray: A T x N matrix of simulated daily returns.\n    \"\"\"\n    # Construct the covariance matrix: Sigma = D * C * D\n    D = np.diag(sigma_vec)\n    cov_matrix = D @ corr_matrix @ D\n\n    # Perform Cholesky decomposition: Sigma = L * L^T\n    # numpy.linalg.cholesky returns the lower-triangular matrix L.\n    L = np.linalg.cholesky(cov_matrix)\n\n    # Generate independent standard normal random variables\n    rng = np.random.default_rng(seed)\n    Z = rng.standard_normal((T, N))\n\n    # Generate correlated returns: R = Z * L^T\n    R = Z @ L.T\n    return R\n\ndef calculate_var(T, weights, returns):\n    \"\"\"\n    Calculates the 99% Value at Risk using historical simulation.\n\n    Args:\n        T (int): Number of time periods.\n        weights (np.ndarray): Portfolio weights vector.\n        returns (np.ndarray): Matrix of historical returns.\n\n    Returns:\n        float: The 99% VaR, rounded to 6 decimal places.\n    \"\"\"\n    # Calculate daily portfolio returns: Rp_t = R_t^T * w\n    portfolio_returns = returns @ weights\n    \n    # Calculate daily portfolio losses: L_t = -Rp_t\n    losses = -portfolio_returns\n    \n    # Sort losses in non-decreasing order\n    sorted_losses = np.sort(losses)\n    \n    # Calculate the index k for the 99% empirical quantile\n    # k = ceil(p * T), with 1-based indexing\n    p = 0.99\n    k = math.ceil(p * T)\n    \n    # Get the VaR value. Index is k-1 due to 0-based indexing in Python.\n    var_99 = sorted_losses[k - 1]\n    \n    return round(var_99, 6)\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the three test cases.\n    \"\"\"\n    N = 10\n    rho = 0.6\n    \n    # Define asset volatilities\n    sigma_vec = np.array([0.01 + 0.002 * (i - 1) for i in range(1, N + 1)])\n    \n    # Define correlation matrix\n    indices = np.arange(N)\n    corr_matrix = rho ** np.abs(indices - indices[:, np.newaxis])\n    \n    # Fixed seed for all data generation\n    seed = 12345\n    \n    # Define test cases\n    test_cases = [\n        {'name': 'A', 'T': 1000, 'weights_def': 'equal'},\n        {'name': 'B', 'T': 500, 'weights_def': 'concentrated'},\n        {'name': 'C', 'T': 252, 'weights_def': 'risk-parity'}\n    ]\n    \n    results = []\n    \n    for case in test_cases:\n        T = case['T']\n        \n        # Generate returns for the specific T\n        returns = generate_returns(T, N, sigma_vec, corr_matrix, seed)\n        \n        # Define weights for the case\n        weights = np.zeros(N)\n        if case['weights_def'] == 'equal':\n            weights = np.full(N, 1.0 / N)\n        elif case['weights_def'] == 'concentrated':\n            weights[0] = 1.0\n        elif case['weights_def'] == 'risk-parity':\n            inv_sigma = 1.0 / sigma_vec\n            weights = inv_sigma / np.sum(inv_sigma)\n        \n        # Calculate VaR for the case\n        var_result = calculate_var(T, weights, returns)\n        results.append(var_result)\n\n    # Format the final output string as [x_A,x_B,x_C]\n    output_str = f\"[{','.join([f'{r:.6f}' for r in results])}]\"\n    print(output_str)\n\nsolve()\n\n```"
        },
        {
            "introduction": "一个VaR模型只有在准确时才有用。但我们如何衡量其准确性呢？建模生命周期的最后一步是回测（backtesting），即将模型过去所作的预测与真实发生的结果进行对比。这个练习将超越简单地计算VaR被突破的次数，而是引入一个更精密的工具——分位数损失函数（quantile loss function）。通过这种方式，我们可以建立一个更稳健的评估框架，该框架不仅惩罚预测错误的频率，也惩罚其幅度。",
            "id": "2446219",
            "problem": "您的任务是实现一个独立的风险价值（VaR）回测框架。该框架通过一个损失函数，对VaR突破的频率和突破的幅度进行惩罚，从而评估预测的质量。请从以下基本定义和事实开始。\n\n对于一个损失随机变量 $L$，在水平 $\\alpha \\in (0,1)$ 下的单步VaR预测是任意满足在预测分布下超过 $v$ 的概率接近 $\\alpha$ 的数值 $v$，即 $P(L \\le v) \\approx 1 - \\alpha$。等价地，用收益率 $R$ 表示（约定 $L = -R$），VaR预测 $v$ 是对 $L$ 的 $\\alpha$-分位数的预测。回测是根据已实现的损失序列 $\\{L_t\\}_{t=1}^T$ 来评估一系列此类预测 $\\{v_t\\}_{t=1}^T$。\n\n为了同时捕捉突破的频率和幅度，我们使用与水平 $\\alpha$ 相关的分位数（检验）损失，对于预测误差 $u \\in \\mathbb{R}$，其定义为\n$$\n\\ell_{\\alpha}(u) = \\left(\\alpha - \\mathbf{1}\\{u  0\\}\\right) u,\n$$\n其中 $\\mathbf{1}\\{\\cdot\\}$ 是指示函数。对于VaR回测，相关的误差是 $u_t = L_t - v_t$；当 $u_t  0$ 时，发生一次突破。\n\n请为给定的收益率序列 $\\{R_t\\}_{t=1}^T$、VaR预测序列 $\\{v_t\\}_{t=1}^T$ 和水平 $\\alpha$ 实现以下回测指标：\n1. 经验覆盖偏差，定义为\n$$\n\\widehat{c} - \\alpha, \\quad \\text{其中} \\quad \\widehat{c} = \\frac{1}{T} \\sum_{t=1}^T \\mathbf{1}\\{L_t  v_t\\} = \\frac{1}{T} \\sum_{t=1}^T \\mathbf{1}\\{-R_t  v_t\\}.\n$$\n2. 平均分位数损失，\n$$\n\\overline{L}_{\\alpha} = \\frac{1}{T} \\sum_{t=1}^T \\ell_{\\alpha}(L_t - v_t) = \\frac{1}{T} \\sum_{t=1}^T \\ell_{\\alpha}(-R_t - v_t).\n$$\n\n您的程序必须为下面的每个测试案例计算一个包含两个元素的列表 $[\\widehat{c} - \\alpha, \\overline{L}_{\\alpha}]$，其中两个条目都四舍五入到六位小数。所有数值输入和输出都必须是十进制形式（不要使用百分号）。不涉及物理单位。\n\n要实现的测试套件：\n- 案例A（混合结果）：\n  - $\\alpha = 0.05$\n  - 收益率 $\\{R_t\\}_{t=1}^{10} = [\\,-0.01,\\, 0.002,\\, -0.03,\\, -0.015,\\, 0.005,\\, -0.04,\\, 0.01,\\, -0.025,\\, 0.003,\\, -0.012\\,]$\n  - VaR预测 $\\{v_t\\}_{t=1}^{10} = [\\,0.015,\\, 0.01,\\, 0.02,\\, 0.015,\\, 0.008,\\, 0.025,\\, 0.009,\\, 0.02,\\, 0.007,\\, 0.012\\,]$\n- 案例B（无突破；保守的VaR）：\n  - $\\alpha = 0.05$\n  - 收益率 $\\{R_t\\}_{t=1}^{5} = [\\,-0.005,\\, 0.004,\\, 0.002,\\, -0.003,\\, 0.001\\,]$\n  - VaR预测 $\\{v_t\\}_{t=1}^{5} = [\\,0.02,\\, 0.02,\\, 0.02,\\, 0.02,\\, 0.02\\,]$\n- 案例C（全部突破；激进的VaR）：\n  - $\\alpha = 0.05$\n  - 收益率 $\\{R_t\\}_{t=1}^{3} = [\\,-0.05,\\, -0.06,\\, -0.04\\,]$\n  - VaR预测 $\\{v_t\\}_{t=1}^{3} = [\\,0.01,\\, 0.005,\\, 0.02\\,]$\n- 案例D（单次大幅度突破）：\n  - $\\alpha = 0.05$\n  - 收益率 $\\{R_t\\}_{t=1}^{5} = [\\,-0.001,\\, -0.002,\\, -0.15,\\, -0.003,\\, 0.0\\,]$\n  - VaR预测 $\\{v_t\\}_{t=1}^{5} = [\\,0.005,\\, 0.005,\\, 0.01,\\, 0.005,\\, 0.005\\,]$\n\n最终输出格式要求：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素本身都是一个对应于一个测试案例的双元素列表 $[\\widehat{c} - \\alpha, \\overline{L}_{\\alpha}]$，例如 $[[x_1,y_1],[x_2,y_2],\\ldots]$。每个浮点数必须四舍五入到六位小数。",
            "solution": "该问题要求为风险价值（VaR）预测实现一个回测框架。在提出严谨的解决方案之前，我将首先确定问题陈述的有效性。\n\n该问题需要进行验证。\n\n**步骤1：提取已知信息**\n- 损失 $L$ 和收益率 $R$ 之间的关系是 $L_t = -R_t$。\n- VaR水平表示为 $\\alpha \\in (0,1)$。\n- 分位数损失函数定义为 $\\ell_{\\alpha}(u) = (\\alpha - \\mathbf{1}\\{u  0\\}) u$，其中 $u$ 是预测误差。\n- 预测误差为 $u_t = L_t - v_t$。当 $L_t > v_t$ 时定义为一次突破，这等价于 $u_t > 0$。\n- 第一个要求的指标是经验覆盖偏差：$\\widehat{c} - \\alpha$，其中 $\\widehat{c} = \\frac{1}{T} \\sum_{t=1}^T \\mathbf{1}\\{L_t > v_t\\}$。\n- 第二个要求的指标是平均分位数损失：$\\overline{L}_{\\alpha} = \\frac{1}{T} \\sum_{t=1}^T \\ell_{\\alpha}(L_t - v_t)$。\n- 提供的测试套件包含四个案例（A, B, C, D），每个案例都指定了收益率 $\\{R_t\\}$、VaR预测 $\\{v_t\\}$ 的时间序列和给定的水平 $\\alpha$。\n- 每个测试案例的最终输出必须是一个列表 $[\\widehat{c} - \\alpha, \\overline{L}_{\\alpha}]$，其中每个值都四舍五入到六位小数。\n\n**步骤2：使用提取的信息进行验证**\n根据验证标准对问题进行评估。\n- **科学依据：** 该问题基于量化金融和计量经济学中已确立的标准概念。风险价值、分位数损失函数和回测是金融风险管理的基本工具。所提供的定义和公式是正确的，并与学术文献一致。该问题在科学上是合理的。\n- **适定性和完整性：** 该问题是适定的。计算解决方案所需的所有必要数据（时间序列、参数）、定义和数学公式都已明确提供。没有缺失或矛盾的元素。任务是基于这些输入执行直接计算，这将为每个案例得出唯一的解决方案。\n- **客观性：** 问题陈述以精确、客观和技术性的语言呈现，没有任何主观论断或含糊不清之处。\n\n**步骤3：结论与行动**\n该问题被认定为有效。它是在计算金融领域内一个明确定义的计算任务，具有科学依据和客观陈述。现在将逐步制定解决方案。\n\n**基于原理的解决方案**\n\n目标是针对一系列已实现的收益率 $\\{R_t\\}_{t=1}^T$ 和显著性水平 $\\alpha$，为一系列风险价值预测 $\\{v_t\\}_{t=1}^T$ 计算两个回测指标。\n\n首先，我们对给定长度为 $T$ 的时间序列的输入进行形式化：\n- 收益率序列：$\\{R_t\\}_{t=1}^T$。\n- VaR预测序列：$\\{v_t\\}_{t=1}^T$。\n- VaR水平：$\\alpha$。\n\n由此，我们推导出必要的中间量。时间 $t$ 的损失定义为收益率的负数，即 $L_t = -R_t$。预测误差是实际损失与预测损失之差，即 $u_t = L_t - v_t$。\n\n然后按如下方式计算这两个指标：\n\n**1. 经验覆盖偏差 $(\\widehat{c} - \\alpha)$**\n该指标评估VaR突破的频率是否与目标频率 $\\alpha$ 一致。一个理想的VaR模型应以概率 $\\alpha$ 产生突破。\n- 经验覆盖率 $\\widehat{c}$ 是样本中观察到的突破频率。当实际损失 $L_t$ 大于VaR预测 $v_t$ 时，发生一次突破。\n- 我们将时间 $t$ 的突破指示变量定义为 $I_t = \\mathbf{1}\\{L_t > v_t\\}$。如果发生突破，该变量为 $1$，否则为 $0$。\n- 经验覆盖率是这些指示变量在样本期内的均值：\n$$\n\\widehat{c} = \\frac{1}{T} \\sum_{t=1}^T I_t = \\frac{1}{T} \\sum_{t=1}^T \\mathbf{1}\\{L_t > v_t\\}\n$$\n- 最终指标是该经验率与理论率 $\\alpha$ 之间的偏差：\n$$\n\\text{Coverage Deviation} = \\widehat{c} - \\alpha\n$$\n接近 $0$ 的值表示模型的突破频率与VaR水平一致。正值意味着突破次数过多（模型过于激进），而负值意味着突破次数过少（模型过于保守）。\n\n**2. 平均分位数损失 $(\\overline{L}_{\\alpha})$**\n该指标提供了一种更细致的评估，它不仅惩罚突破的发生，还惩罚其幅度，同时也惩罚过于保守的预测。它是分位数损失函数 $\\ell_{\\alpha}(u)$ 在样本上的平均值。\n- 分位数损失函数由 $\\ell_{\\alpha}(u) = (\\alpha - \\mathbf{1}\\{u  0\\}) u$ 给出。误差项为 $u_t = L_t - v_t$。\n- 我们可以分两种情况分析该损失函数：\n    - **突破 ($L_t > v_t \\implies u_t > 0$)：** 在这种情况下，$\\mathbf{1}\\{u_t  0\\} = 0$。损失为 $\\ell_{\\alpha}(u_t) = \\alpha \\cdot u_t$。惩罚与亏损幅度 $u_t$ 成正比，并按小概率 $\\alpha$ 进行缩放。\n    - **无突破 ($L_t \\le v_t \\implies u_t \\le 0$)：** 在这种情况下，$\\mathbf{1}\\{u_t  0\\} = 1$（当 $u_t  0$时）或 $0$（当 $u_t=0$时）。如果 $u_t  0$，损失为 $\\ell_{\\alpha}(u_t) = (\\alpha - 1) u_t = (1-\\alpha)(-u_t)$。这会对过于保守的预测（即VaR估计值远大于损失）进行惩罚。惩罚与“过度预测”的幅度 $|u_t|$ 成正比，并按大概率 $(1-\\alpha)$ 进行缩放。如果 $u_t = 0$，损失为 $0$。\n- 平均分位数损失是这些个体损失在样本期内的均值：\n$$\n\\overline{L}_{\\alpha} = \\frac{1}{T} \\sum_{t=1}^T \\ell_{\\alpha}(L_t - v_t)\n$$\n理论上，一个能正确指定损失分布条件分位数的模型将最小化该期望损失。因此，较低的 $\\overline{L}_{\\alpha}$ 值更优。\n\n每个测试案例的计算过程包括：将给定的收益率和VaR预测列表转换为数值数组，应用上述公式计算两个指标，并将结果四舍五入到指定精度。此过程将在提供的Python代码中实现。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the VaR backtesting problem for a suite of test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case A (mixed outcomes)\n        {\n            \"alpha\": 0.05,\n            \"returns\": [-0.01, 0.002, -0.03, -0.015, 0.005, -0.04, 0.01, -0.025, 0.003, -0.012],\n            \"var_forecasts\": [0.015, 0.01, 0.02, 0.015, 0.008, 0.025, 0.009, 0.02, 0.007, 0.012]\n        },\n        # Case B (no exceedances)\n        {\n            \"alpha\": 0.05,\n            \"returns\": [-0.005, 0.004, 0.002, -0.003, 0.001],\n            \"var_forecasts\": [0.02, 0.02, 0.02, 0.02, 0.02]\n        },\n        # Case C (all exceedances)\n        {\n            \"alpha\": 0.05,\n            \"returns\": [-0.05, -0.06, -0.04],\n            \"var_forecasts\": [0.01, 0.005, 0.02]\n        },\n        # Case D (a single large exceedance)\n        {\n            \"alpha\": 0.05,\n            \"returns\": [-0.001, -0.002, -0.15, -0.003, 0.0],\n            \"var_forecasts\": [0.005, 0.005, 0.01, 0.005, 0.005]\n        }\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        alpha = case[\"alpha\"]\n        # Convert inputs to NumPy arrays for vectorized operations\n        R_t = np.array(case[\"returns\"])\n        v_t = np.array(case[\"var_forecasts\"])\n        \n        # Ensure T is correctly inferred from the data length\n        T = len(R_t)\n\n        # Calculate the loss series L_t = -R_t\n        L_t = -R_t\n\n        # 1. Calculate Empirical Coverage Deviation\n        # An exceedance occurs if L_t  v_t\n        exceedances = L_t > v_t\n        c_hat = np.mean(exceedances)\n        coverage_deviation = c_hat - alpha\n\n        # 2. Calculate Average Quantile Loss\n        # Forecast error u_t = L_t - v_t\n        u_t = L_t - v_t\n        \n        # Indicator function: 1 if u_t  0, else 0\n        indicator_u_neg = (u_t  0).astype(float)\n        \n        # Quantile loss for each time step: l_alpha(u_t) = (alpha - I{u_t  0}) * u_t\n        quantile_losses = (alpha - indicator_u_neg) * u_t\n        \n        # Average quantile loss\n        L_bar_alpha = np.mean(quantile_losses)\n\n        # Round results to 6 decimal places\n        result_pair = [\n            round(coverage_deviation, 6),\n            round(L_bar_alpha, 6)\n        ]\n        all_results.append(result_pair)\n\n    # Format the final output string as per problem specification\n    # str() on a list gives the desired '[...]' format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        }
    ]
}