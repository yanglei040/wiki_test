{
    "hands_on_practices": [
        {
            "introduction": "对于一个反复出现状态的系统，一个核心问题是：“长期来看，系统将处于何种状态？”。本练习将引导你解决这个问题，通过一个关于劳动力市场状态的简化经济模型，练习计算马尔科夫链的稳态分布。这个分布描述了系统在长期均衡中处于各个状态的概率，是分析任何不可约马尔科夫链模型的基石，掌握其计算方法至关重要。",
            "id": "2409051",
            "problem": "考虑一个离散时间、时齐马尔可夫链，它模拟了经济体中一个代表性工人每周的劳动力市场状况。状态空间包括失业（$U$）、兼职（$P$）和全职（$F$）。状态之间的转移在每周结束时根据以下行随机转移矩阵 $P$ 进行，其中状态排序为 $(U, P, F)$：\n$$\nP \\;=\\;\n\\begin{pmatrix}\n\\frac{3}{5}  & \\frac{3}{10}  & \\frac{1}{10} \\\\\n\\frac{1}{5}  & \\frac{1}{2}  & \\frac{3}{10} \\\\\n\\frac{1}{20}  & \\frac{3}{20}  & \\frac{4}{5}\n\\end{pmatrix}.\n$$\n在这些假设下，确定由 $P$ 隐含的长期失业率，该失业率定义为在该链唯一的平稳分布中，处于状态 $U$ 的平稳（不变）概率。请以精确分数（不进行四舍五入）的形式给出您的答案，表示为小数或不带百分号的分数。",
            "solution": "该系统是一个具有有限状态空间 $\\{U, P, F\\}$ 的离散时间、时齐马尔可夫链。平稳（不变）分布 $\\pi$ 是一个行向量 $\\pi = (\\pi_U, \\pi_P, \\pi_F)$，满足以下定义条件\n$$\n\\pi = \\pi P, \\quad \\pi_U + \\pi_P + \\pi_F = 1, \\quad \\pi_i \\ge 0 \\text{ 对每个状态 } i \\in \\{U, P, F\\}.\n$$\n因为 $P$ 的每个元素都严格为正，所以该链是不可约且非周期的，根据 Perron–Frobenius theorem，这保证了平稳分布的存在性和唯一性。\n\n设 $\\pi = (x, y, z)$，其中 $x = \\pi_U$，$y = \\pi_P$，$z = \\pi_F$。平稳性条件 $\\pi = \\pi P$ 产生了以下方程组\n$$\n\\begin{aligned}\nx &= \\frac{3}{5}x + \\frac{1}{5}y + \\frac{1}{20}z, \\\\\ny &= \\frac{3}{10}x + \\frac{1}{2}y + \\frac{3}{20}z, \\\\\nz &= \\frac{1}{10}x + \\frac{3}{10}y + \\frac{4}{5}z,\n\\end{aligned}\n$$\n以及归一化条件\n$$\nx + y + z = 1.\n$$\n将前两个方程的所有项移到左侧，重写方程组：\n$$\n\\begin{aligned}\nx - \\frac{3}{5}x - \\frac{1}{5}y - \\frac{1}{20}z = 0\n\\;\\;\\Rightarrow\\;\\;\n\\frac{2}{5}x - \\frac{1}{5}y - \\frac{1}{20}z = 0, \\\\\ny - \\frac{3}{10}x - \\frac{1}{2}y - \\frac{3}{20}z = 0\n\\;\\;\\Rightarrow\\;\\;\n\\frac{1}{2}y - \\frac{3}{10}x - \\frac{3}{20}z = 0.\n\\end{aligned}\n$$\n将其中第一个方程乘以 $20$，第二个方程也乘以 $20$，以消去分母：\n$$\n\\begin{aligned}\n8x - 4y - z = 0, \\\\\n-6x + 10y - 3z = 0.\n\\end{aligned}\n$$\n由第一个方程可得，\n$$\nz = 8x - 4y.\n$$\n将此式代入第二个方程：\n$$\n-6x + 10y - 3(8x - 4y) = 0\n\\;\\;\\Rightarrow\\;\\;\n-6x + 10y - 24x + 12y = 0\n\\;\\;\\Rightarrow\\;\\;\n-30x + 22y = 0\n\\;\\;\\Rightarrow\\;\\;\ny = \\frac{15}{11}x.\n$$\n那么\n$$\nz = 8x - 4y = 8x - 4\\left(\\frac{15}{11}x\\right) = \\left(\\frac{88}{11} - \\frac{60}{11}\\right)x = \\frac{28}{11}x.\n$$\n应用归一化条件：\n$$\nx + y + z = 1\n\\;\\;\\Rightarrow\\;\\;\nx + \\frac{15}{11}x + \\frac{28}{11}x = 1\n\\;\\;\\Rightarrow\\;\\;\n\\left(1 + \\frac{15}{11} + \\frac{28}{11}\\right)x = 1\n\\;\\;\\Rightarrow\\;\\;\n\\frac{54}{11}x = 1\n\\;\\;\\Rightarrow\\;\\;\nx = \\frac{11}{54}.\n$$\n因此，平稳分布为\n$\n\\pi = \\left(\\frac{11}{54}, \\frac{15}{54}, \\frac{28}{54}\\right) = \\left(\\frac{11}{54}, \\frac{5}{18}, \\frac{14}{27}\\right),\n$\n长期失业率，即处于状态 $U$ 的平稳概率，为\n$$\n\\pi_U = \\frac{11}{54}.\n$$\n这已经是一个精确分数，符合题目要求。",
            "answer": "$$\\boxed{\\frac{11}{54}}$$"
        },
        {
            "introduction": "并非所有系统都会无限期地在不同状态间循环，许多系统会演化至一个或多个不可逆转的“终点”状态，即吸收态。本练习将探讨这类含有吸收态的马尔科夫链，并以一个公司信用评级模型为例，让你计算从一个初始状态（如“A”级评级）到达吸收态（“违约”）所需的期望时间。这项技能在风险管理和金融建模中至关重要，例如评估产品寿命或预测违约时间。",
            "id": "2409067",
            "problem": "一家公司的信用评级由一个离散时间、时齐马尔可夫链表示，该链在有序状态 $\\{\\text{AAA}, \\text{AA}, \\text{A}, \\text{BBB}, \\text{BB}, \\text{B}, \\text{CCC}, \\text{D}\\}$ 之间进行年度转移，其中 $\\text{D}$ 表示违约并且是吸收态。在此状态顺序下，一步转移矩阵 $P$（各行之和为 $1$）为\n$$\nP \\;=\\;\n\\begin{pmatrix}\n0.5  & 0.5  & 0  & 0  & 0  & 0  & 0  & 0 \\\\\n0  & 0.5  & 0.5  & 0  & 0  & 0  & 0  & 0 \\\\\n0  & 0  & 0.5  & 0.5  & 0  & 0  & 0  & 0 \\\\\n0  & 0  & 0  & 0.5  & 0.5  & 0  & 0  & 0 \\\\\n0  & 0  & 0  & 0  & 0.5  & 0.5  & 0  & 0 \\\\\n0  & 0  & 0  & 0  & 0  & 0.5  & 0.5  & 0 \\\\\n0  & 0  & 0  & 0  & 0  & 0  & 0.5  & 0.5 \\\\\n0  & 0  & 0  & 0  & 0  & 0  & 0  & 1\n\\end{pmatrix}.\n$$\n每年，处于非违约状态的公司要么以概率 $0.5$ 维持其当前评级，要么以概率 $0.5$ 被降一级。处于状态 $\\text{CCC}$ 的公司，要么以概率 $0.5$ 维持在 $\\text{CCC}$ 状态，要么以概率 $0.5$ 发生违约（$\\text{D}$）。状态 $\\text{D}$ 是吸收态。\n\n假设公司年初的评级为 $\\text{A}$，确定其到达违约状态所需的期望年数。请以年为单位提供您的答案作为精确值（无四舍五入）。",
            "solution": "本题旨在确定一家当前信用评级为 $\\text{A}$ 的公司到违约所需的期望年数。这是一个计算离散时间、时齐马尔可夫链中到达吸收态的期望时间的经典问题。\n\n设马尔可夫链的状态空间为 $S = \\{s_1, s_2, s_3, s_4, s_5, s_6, s_7, s_8\\}$，其中 $s_1 = \\text{AAA}$，$s_2 = \\text{AA}$，$s_3 = \\text{A}$，$s_4 = \\text{BBB}$，$s_5 = \\text{BB}$，$s_6 = \\text{B}$，$s_7 = \\text{CCC}$，以及 $s_8 = \\text{D}$（违约）。状态 $s_8$ 是一个吸收态，而状态 $\\{s_1, \\dots, s_7\\}$ 是暂态。公司的初始状态是 $s_3 = \\text{A}$。转移矩阵由 $P$ 给出。\n\n设 $\\mu_i$ 为从状态 $s_i$ 出发，到达吸收态 $s_8$（违约）所需的期望年数（步数）。我们的目标是求 $\\mu_3$。\n\n根据定义，从一个吸收态到达吸收态的期望时间为零。因此，我们有：\n$$ \\mu_8 = 0 $$\n\n对于任何暂态 $s_i$（其中 $i \\in \\{1, 2, \\dots, 7\\}$），我们可以通过对第一步的结果进行条件分析来建立关于 $\\mu_i$ 的线性方程组。从状态 $s_i$ 出发的期望时间等于一年，加上从该年之后达到的状态 $s_j$ 出发的未来期望时间（对所有可能的下一状态 $s_j$ 取平均）。这可以表示为：\n$$ \\mu_i = 1 + \\sum_{j=1}^{8} P_{ij} \\mu_j $$\n其中 $P_{ij}$ 是从状态 $s_i$ 一步转移到状态 $s_j$ 的概率。\n\n根据给定的转移矩阵 $P$：\n对于任何非违约、非CCC的评级（即，对于 $i \\in \\{1, 2, \\dots, 6\\}$），公司要么以概率 $0.5$ 保持在状态 $s_i$，要么以概率 $0.5$ 降级到状态 $s_{i+1}$。转移概率为 $P_{ii} = 0.5$，$P_{i,i+1} = 0.5$，而对于所有其他 $j$，$P_{ij} = 0$。关于 $\\mu_i$ 的方程是：\n$$ \\mu_i = 1 + P_{ii}\\mu_i + P_{i,i+1}\\mu_{i+1} = 1 + 0.5\\mu_i + 0.5\\mu_{i+1} $$\n整理此方程，我们得到一个对于 $i \\in \\{1, 2, \\dots, 6\\}$ 的递推关系：\n$$ 0.5\\mu_i = 1 + 0.5\\mu_{i+1} $$\n$$ \\mu_i = 2 + \\mu_{i+1} $$\n\n对于状态 $s_7 = \\text{CCC}$，公司要么以概率 $P_{77}=0.5$ 保持在状态 $s_7$，要么以概率 $P_{78}=0.5$ 违约到状态 $s_8$。关于 $\\mu_7$ 的方程是：\n$$ \\mu_7 = 1 + P_{77}\\mu_7 + P_{78}\\mu_8 = 1 + 0.5\\mu_7 + 0.5\\mu_8 $$\n代入 $\\mu_8 = 0$，我们有：\n$$ \\mu_7 = 1 + 0.5\\mu_7 $$\n$$ 0.5\\mu_7 = 1 $$\n$$ \\mu_7 = 2 $$\n所以，从状态 $\\text{CCC}$ 到违约的期望时间是 $2$ 年。\n\n现在我们可以使用递推关系 $\\mu_i = 2 + \\mu_{i+1}$，从 $\\mu_7$ 开始通过向后代入法求解剩余的 $\\mu_i$：\n\n对于状态 $s_6 = \\text{B}$：\n$$ \\mu_6 = 2 + \\mu_7 = 2 + 2 = 4 $$\n\n对于状态 $s_5 = \\text{BB}$：\n$$ \\mu_5 = 2 + \\mu_6 = 2 + 4 = 6 $$\n\n对于状态 $s_4 = \\text{BBB}$：\n$$ \\mu_4 = 2 + \\mu_5 = 2 + 6 = 8 $$\n\n最后，对于初始状态 $s_3 = \\text{A}$：\n$$ \\mu_3 = 2 + \\mu_4 = 2 + 8 = 10 $$\n\n从评级 $\\text{A}$ 开始，公司到违约的期望年数是 $10$ 年。\n问题现已解决。推理过程完整且科学上无懈可击。",
            "answer": "$$\n\\boxed{10}\n$$"
        },
        {
            "introduction": "在掌握了理论计算之后，让我们转向一个更高级的实践：如何利用马尔科夫链来分析真实的经济数据并做出统计推断。经济和金融系统并非一成不变，其内在“规则”可能随时间发生变化，这被称为“结构性突变”。本练习将指导你完成一个完整的实证分析流程：处理时间序列数据、为不同时期估计转移矩阵，并运用统计检验来判断市场动态的变化是否显著。这个练习让你体验定量分析师的工作，是运用马尔科夫链进行实证研究的核心技能。",
            "id": "2409049",
            "problem": "要求您实现一个独立的程序，使用离散时间、有限状态马尔可夫链来评估一个股票市场在两个历史时期内的动态特性是否存在统计显著性变化。这两个时期意在反映 $1980$–$2000$ 年和 $2001$–$2021$ 年，但在此次任务中，您必须仅使用所提供的测试用例。这些测试用例是人工合成但符合金融实际的收益序列，以小数形式表示收益率。我们使用一个三状态马尔可夫链，其状态为 $\\{\\text{损失}, \\text{持平}, \\text{收益}\\}$（Loss, Flat, Gain），这些状态是通过一个对称区间阈值 $\\tau > 0$ 对每个收益率 $r_t$ 进行分类来定义的，规则如下：如果 $r_t < -\\tau$，则为“损失” (Loss)；如果 $|r_t| \\le \\tau$，则为“持平” (Flat)；如果 $r_t > \\tau$，则为“收益” (Gain)。对于每个时期，您必须根据观测到的状态序列估计转移概率矩阵，并检验两个时期共享相同转移矩阵的原假设，其备择假设为两个矩阵不同。对于每个测试用例，您的程序必须返回一个布尔值，回答在给定的显著性水平 $\\alpha$ 下，这种变化是否具有统计显著性。\n\n您的程序必须从下述的测试套件中隐式地解释输入参数。对于每个测试用例 $k$，输入为：\n- 分类阈值 $\\tau_k$（无量纲；收益率为小数）。\n- 显著性水平 $\\alpha_k$（无量纲）。\n- 两个小数形式的收益率序列，时期 1 为 $\\{r^{(1)}_{t}\\}_{t=1}^{T^{(1)}}$，时期 2 为 $\\{r^{(2)}_{t}\\}_{t=1}^{T^{(2)}}$，其中 $T^{(1)} \\ge 2$ 且 $T^{(2)} \\ge 2$。\n\n基于基本原理：\n- 将分类后的状态时间序列视为状态空间 $\\{\\text{损失}, \\text{持平}, \\text{收益}\\}$ 上的时间齐次一阶马尔可夫链的一个实现。\n- 对于每个时期 $m \\in \\{1,2\\}$，构建一个 $3 \\times 3$ 的转移计数矩阵 $N^{(m)} = [n^{(m)}_{ij}]$，其中 $n^{(m)}_{ij}$ 记录了该时期内从起始状态 $i$ 到目标状态 $j$ 的连续转移次数。在整个过程中，请采用固定的状态顺序 $(\\text{损失}, \\text{持平}, \\text{收益})$。\n- 通过最大似然估计量 $\\hat{p}^{(m)}_{ij} = \\frac{n^{(m)}_{ij}}{\\sum_{j} n^{(m)}_{ij}}$ 来估计每个时期的转移概率矩阵 $\\hat{P}^{(m)} = [\\hat{p}^{(m)}_{ij}]$。此估计适用于任何至少有一次观测到出向转移的起始状态 $i$（总出向转移为零的行不贡献任何参数或似然）。\n- 使用基于每个起始行对应的多项式模型的、适当的似然统计检验方法，来检验两个时期共享同一转移矩阵的原假设。决策规则必须是：当且仅当 $p$ 值严格小于 $\\alpha$ 时，拒绝原假设。\n- 如果对于某个特定的起始状态，两个时期中至少有一个时期的总出向转移为零，则该起始状态对检验不贡献任何参数或自由度，并且其似然贡献定义为零。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表。例如，如果有三个测试用例，输出必须类似于“[True,False,True]”。\n\n测试套件：\n请使用以下三个测试用例。在所有情况下，收益率均为小数（例如，$0.01$ 表示百分之一）。为紧凑地构建收益序列，使用映射 $\\text{Gain} \\mapsto r_G = 0.01$, $\\text{Flat} \\mapsto r_F = 0.0$, $\\text{Loss} \\mapsto r_L = -0.01$，并通过将给定的有限状态模式重复指定次数来构建每个序列。分类使用每个用例指定的 $\\tau$。\n\n- 测试用例 1 (具有明显机制变化的一般情况)：\n  - $\\tau_1 = 0.002$, $\\alpha_1 = 0.05$。\n  - 时期 1 序列：将模式 $(\\text{Gain}, \\text{Gain}, \\text{Gain}, \\text{Gain}, \\text{Loss}, \\text{Loss}, \\text{Loss}, \\text{Loss}, \\text{Flat}, \\text{Flat}, \\text{Flat}, \\text{Flat})$ 精确重复 $20$ 次。\n  - 时期 2 序列：将模式 $(\\text{Gain}, \\text{Loss}, \\text{Gain}, \\text{Loss}, \\text{Gain}, \\text{Loss}, \\text{Flat}, \\text{Gain}, \\text{Flat}, \\text{Gain}, \\text{Flat}, \\text{Gain})$ 精确重复 $20$ 次。\n\n- 测试用例 2 (无变化；边界情况，缺少“持平”起始行)：\n  - $\\tau_2 = 0.002$, $\\alpha_2 = 0.05$。\n  - 时期 1 序列：将模式 $(\\text{Gain}, \\text{Gain}, \\text{Loss}, \\text{Loss})$ 精确重复 $50$ 次。\n  - 时期 2 序列：将同一模式 $(\\text{Gain}, \\text{Gain}, \\text{Loss}, \\text{Loss})$ 精确重复 $50$ 次。\n\n- 测试用例 3 (边缘案例，时期 2 缺少一个起始行，且显著性水平严格)：\n  - $\\tau_3 = 0.002$, $\\alpha_3 = 1\\times 10^{-6}$。\n  - 时期 1 序列：将模式 $(\\text{Gain}, \\text{Gain}, \\text{Gain}, \\text{Flat}, \\text{Loss}, \\text{Loss}, \\text{Loss})$ 精确重复 $10$ 次。\n  - 时期 2 序列：将模式 $(\\text{Gain}, \\text{Gain}, \\text{Gain}, \\text{Loss}, \\text{Loss}, \\text{Loss})$ 精确重复 $10$ 次。\n\n要求的最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表，结果顺序与测试用例顺序一致，例如：“[result1,result2,result3]”。其中每个结果都是一个布尔值，表示在该测试用例指定的 $\\alpha$ 水平下，转移矩阵的变化是否具有统计显著性。",
            "solution": "该问题要求进行一项统计检验，以确定一个股票市场的转移动态特性（建模为离散时间马尔可夫链）在两个时期之间是否发生了变化。解决方案包括对金融收益数据进行离散化、估计转移矩阵，并应用似然比检验来判断马尔可夫链的同质性。\n\n状态空间定义为 $S = \\{S_0, S_1, S_2\\}$，分别对应 $\\{\\text{损失(Loss)}, \\text{持平(Flat)}, \\text{收益(Gain)}\\}$。在时刻 $t$ 的一个收益率观测值 $r_t$ 根据给定的阈值 $\\tau > 0$ 被分类到一个状态：\n$$\n\\text{State}(r_t) =\n\\begin{cases}\n    S_0 (\\text{Loss}) & \\text{if } r_t < -\\tau \\\\\n    S_1 (\\text{Flat}) & \\text{if } |r_t| \\le \\tau \\\\\n    S_2 (\\text{Gain}) & \\text{if } r_t > \\tau\n\\end{cases}\n$$\n此分类过程将每个时期 $m \\in \\{1, 2\\}$ 的收益率时间序列 $\\{r^{(m)}_t\\}_{t=1}^{T^{(m)}}$ 转换为一个状态序列。\n\n我们将每个状态序列建模为一阶时间齐次马尔可夫链的一个实现。该模型的核心是转移概率矩阵 $P^{(m)} = [p_{ij}^{(m)}]$，其中 $p_{ij}^{(m)}$ 是在时期 $m$ 中从状态 $S_i$ 转移到状态 $S_j$ 的概率。第一步是估计这些矩阵。对于每个时期 $m$，我们构建一个 $3 \\times 3$ 的转移计数矩阵 $N^{(m)} = [n_{ij}^{(m)}]$，其中 $n_{ij}^{(m)}$ 是观测到的从状态 $S_i$ 到状态 $S_j$ 的转移次数。转移概率 $p_{ij}^{(m)}$ 的最大似然估计 (MLE) 由观测到的转移计数之比给出：\n$$\n\\hat{p}_{ij}^{(m)} = \\frac{n_{ij}^{(m)}}{N_i^{(m)}}\n\\quad \\text{其中} \\quad\nN_i^{(m)} = \\sum_{j=0}^{2} n_{ij}^{(m)}\n$$\n此估计是针对总出向转移次数 $N_i^{(m)}$ 大于零的每个起始状态 $S_i$ 进行的。\n\n主要目标是检验原假设 $H_0$（两个时期的转移矩阵相同）与备择假设 $H_A$（它们不相同）：\n$$\nH_0: P^{(1)} = P^{(2)} \\qquad \\text{vs.} \\qquad H_A: P^{(1)} \\neq P^{(2)}\n$$\n这是一个检验两个马尔可夫链同质性的测试。由于从给定状态 $S_i$ 出发的转移遵循多项式分布，问题简化为对转移矩阵的每一行 $i$ 检验多项式分布的同质性。此问题的标准方法是基于似然比原理的 Anderson-Goodman 检验。\n\n检验统计量是针对每个起始状态 $S_i$ 逐行计算的。只有当某一行 $i$ 在两个时期中都曾作为起始状态被观测到时（即 $N_i^{(1)} > 0$ 且 $N_i^{(2)} > 0$），才将其纳入检验。对于每个这样的有效行 $i$，我们计算一个似然比检验统计量 $G_i^2$。总检验统计量 $G^2$ 是这些单个统计量的总和：\n$$\nG^2 = \\sum_{i \\text{ s.t. } N_i^{(1)}>0, N_i^{(2)}>0} G_i^2\n$$\n行 $i$ 的统计量 $G_i^2$ 比较了数据在备择假设（使用独立的概率 $\\hat{p}_{ij}^{(1)}$ 和 $\\hat{p}_{ij}^{(2)}$）下的似然与在原假设（使用一个共同的、合并的概率 $\\hat{p}_{ij}^{\\text{pool}}$）下的似然。合并概率的估计值为：\n$$\n\\hat{p}_{ij}^{\\text{pool}} = \\frac{n_{ij}^{(1)} + n_{ij}^{(2)}}{N_i^{(1)} + N_i^{(2)}} = \\frac{n_{ij}^{\\text{pool}}}{N_i^{\\text{pool}}}\n$$\n行 $i$ 的似然比统计量由下式给出：\n$$\nG_i^2 = 2 \\sum_{m=1}^{2} \\sum_{j=0}^{2} n_{ij}^{(m)} \\log\\left(\\frac{\\hat{p}_{ij}^{(m)}}{\\hat{p}_{ij}^{\\text{pool}}}\\right)\n$$\n其中 $n_{ij}^{(m)} = 0$ 的项被视为零。为了计算稳定性，这可以表示为使用 $n \\log n$ 项的总和形式：\n$$\nG_i^2 = 2 \\left( \\sum_{m,j} n_{ij}^{(m)}\\log n_{ij}^{(m)} - \\sum_{m} N_i^{(m)}\\log N_i^{(m)} - \\sum_{j} n_{ij}^{\\text{pool}}\\log n_{ij}^{\\text{pool}} + N_i^{\\text{pool}}\\log N_i^{\\text{pool}} \\right)\n$$\n其中每个求和都只针对非零计数的项。\n\n在原假设下，总统计量 $G^2$ 服从卡方 ($\\chi^2$) 分布。检验的自由度 ($df$) 是每个有效行的自由度之和。对于每个被包含的行 $i$，我们比较的是两个具有 $K=3$ 个类别的多项式分布，这贡献了 $K-1=2$ 个自由度。因此，总自由度为 $df = 2 \\times (\\text{有效行数})$。如果没有可供比较的有效行，则 $df=0$，检验未定义，我们断定没有显著变化的证据。\n\n最后，通过将计算出的 p 值与给定的显著性水平 $\\alpha_k$ 进行比较来做出决策。p 值是在假设 $H_0$ 为真的情况下，观测到至少与计算出的检验统计量一样极端的统计量的概率：\n$$\np\\text{-value} = P(\\chi^2_{df} \\ge G^2)\n$$\n当且仅当 p 值严格小于 $\\alpha_k$ 时，拒绝原假设。拒绝原假设意味着市场动态存在统计显著性变化。如果变化显著，程序返回 `True`，否则返回 `False`。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import chi2\n\ndef solve():\n    \"\"\"\n    Solves the problem of detecting statistically significant changes\n    in Markov chain dynamics between two periods for a set of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"tau\": 0.002,\n            \"alpha\": 0.05,\n            \"period1_pattern\": ('G','G','G','G','L','L','L','L','F','F','F','F'),\n            \"period1_reps\": 20,\n            \"period2_pattern\": ('G','L','G','L','G','L','F','G','F','G','F','G'),\n            \"period2_reps\": 20,\n        },\n        {\n            \"tau\": 0.002,\n            \"alpha\": 0.05,\n            \"period1_pattern\": ('G','G','L','L'),\n            \"period1_reps\": 50,\n            \"period2_pattern\": ('G','G','L','L'),\n            \"period2_reps\": 50,\n        },\n        {\n            \"tau\": 0.002,\n            \"alpha\": 1e-6,\n            \"period1_pattern\": ('G','G','G','F','L','L','L'),\n            \"period1_reps\": 10,\n            \"period2_pattern\": ('G','G','G','L','L','L'),\n            \"period2_reps\": 10,\n        }\n    ]\n\n    # Mapping from state character to return value and state index\n    # State order: {0: Loss, 1: Flat, 2: Gain}\n    state_info = {\n        'L': {'return': -0.01, 'index': 0},\n        'F': {'return': 0.0, 'index': 1},\n        'G': {'return': 0.01, 'index': 2},\n    }\n    \n    num_states = 3\n    results = []\n\n    for case in test_cases:\n        tau = case[\"tau\"]\n        alpha = case[\"alpha\"]\n\n        # 1. Generate return sequences\n        p1_ret_seq = [state_info[s]['return'] for s in case[\"period1_pattern\"]] * case[\"period1_reps\"]\n        p2_ret_seq = [state_info[s]['return'] for s in case[\"period2_pattern\"]] * case[\"period2_reps\"]\n\n        # 2. Classify returns into states\n        def classify_returns(returns, tau):\n            states = []\n            for r in returns:\n                if r < -tau:\n                    states.append(state_info['L']['index'])\n                elif r > tau:\n                    states.append(state_info['G']['index'])\n                else: # |r| = tau\n                    states.append(state_info['F']['index'])\n            return states\n\n        p1_state_seq = classify_returns(p1_ret_seq, tau)\n        p2_state_seq = classify_returns(p2_ret_seq, tau)\n\n        # 3. Compute transition count matrices\n        def get_transition_counts(state_seq, n_states):\n            counts = np.zeros((n_states, n_states), dtype=np.int64)\n            for i in range(len(state_seq) - 1):\n                origin_state = state_seq[i]\n                dest_state = state_seq[i+1]\n                counts[origin_state, dest_state] += 1\n            return counts\n\n        N1 = get_transition_counts(p1_state_seq, num_states)\n        N2 = get_transition_counts(p2_state_seq, num_states)\n\n        # 4. Perform the Anderson-Goodman test\n        total_g_squared = 0.0\n        total_df = 0\n\n        N1_row_sums = N1.sum(axis=1)\n        N2_row_sums = N2.sum(axis=1)\n\n        for i in range(num_states):\n            # A row is included if it has transitions in BOTH periods\n            if N1_row_sums[i]  0 and N2_row_sums[i]  0:\n                # Calculate G^2 statistic for this row\n                g_squared_i = 0.0\n                \n                N_pool_row = N1[i, :] + N2[i, :]\n                N_pool_row_sum = N_pool_row.sum()\n\n                # Use log-likelihood formula resistant to n=0\n                # G^2 = 2 * ( sum(n log n) - sum(row_sum log row_sum) - sum(col_sum log col_sum) + total log total )\n                # For a single row of the transition matrix, this applies to the 2xK contingency table\n                \n                # sum(n log n) term\n                term1 = 0.0\n                for n in np.concatenate((N1[i, :], N2[i, :])):\n                    if n  0:\n                        term1 += n * np.log(n)\n                \n                # sum(row_sum log row_sum) term\n                term2 = 0.0\n                term2 += N1_row_sums[i] * np.log(N1_row_sums[i])\n                term2 += N2_row_sums[i] * np.log(N2_row_sums[i])\n\n                # sum(col_sum log col_sum) term\n                term3 = 0.0\n                for n_pool in N_pool_row:\n                    if n_pool  0:\n                        term3 += n_pool * np.log(n_pool)\n\n                # total log total term\n                term4 = 0.0\n                if N_pool_row_sum  0:\n                    term4 = N_pool_row_sum * np.log(N_pool_row_sum)\n\n                g_squared_i = 2 * (term1 - term2 - term3 + term4)\n                \n                total_g_squared += g_squared_i\n                total_df += (num_states - 1)\n\n        # 5. Calculate p-value and make a decision\n        if total_df == 0:\n            # No basis for comparison, so no evidence to reject H0\n            p_value = 1.0\n        else:\n            # sf is the survival function (1 - cdf)\n            p_value = chi2.sf(total_g_squared, total_df)\n        \n        is_significant = p_value  alpha\n        results.append(is_significant)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(lambda b: str(b), results))}]\")\n\nsolve()\n```"
        }
    ]
}