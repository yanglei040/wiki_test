{
    "hands_on_practices": [
        {
            "introduction": "The theoretical connection between consumption and asset prices is elegantly captured by the stochastic discount factor (SDF). This exercise challenges you to explore how extreme, rare events, as modeled in the 'rare disasters' framework, dramatically affect the SDF and its ability to explain the high returns observed on equity markets. By calculating key asset pricing moments under different disaster scenarios , you will gain a hands-on understanding of how the possibility of economic catastrophes can resolve the famous equity premium puzzle.",
            "id": "2421399",
            "problem": "Consider a representative-agent endowment economy with Constant Relative Risk Aversion (CRRA) utility. Let aggregate consumption be $\\{C_t\\}_{t \\ge 0}$, and define gross consumption growth as $g_{t+1} = \\frac{C_{t+1}}{C_t}$. The agent’s stochastic discount factor (SDF) is given by $m_{t+1} = \\beta \\, g_{t+1}^{-\\gamma}$, where $\\beta \\in (0,1)$ is the subjective discount factor and $\\gamma \\gt 0$ is the coefficient of relative risk aversion. Consumption growth follows a rare-disaster mixture process: \n$$\n\\log g_{t+1} = \\mu + \\sigma \\,\\varepsilon_{t+1} + \\ln(1-b)\\, J_{t+1},\n$$\nwith $\\varepsilon_{t+1} \\sim \\mathcal{N}(0,1)$, $J_{t+1} \\sim \\text{Bernoulli}(p)$, and $(\\varepsilon_{t+1}, J_{t+1})$ independent across time and mutually independent. The parameter $b \\in (0,1)$ is the proportional drop in consumption during a disaster, and $p \\in [0,1]$ is the probability of a disaster in a given period. The parameters $\\mu \\in \\mathbb{R}$ and $\\sigma \\ge 0$ govern the lognormal component of consumption growth.\n\nConsider two one-period assets priced by the fundamental pricing equation $P_t = \\mathbb{E}_t[m_{t+1} X_{t+1}]$, where $X_{t+1}$ is the next-period payoff:\n- A risk-free one-period pure-discount bond with gross return $R_f$ that satisfies $\\mathbb{E}[m_{t+1}] \\, R_f = 1$.\n- A risky “equity” claim with one-period payoff $X_{t+1} = g_{t+1}$. Its date-$t$ price is $P_e = \\mathbb{E}[m_{t+1} g_{t+1}]$, and its one-period gross return is $R_e = \\frac{g_{t+1}}{P_e}$. Define the expected equity return as $\\mathbb{E}[R_e]$ and the equity premium as $\\mathbb{E}[R_e] - R_f$.\n\nUsing only the definitions above and the specified probabilistic structure for $g_{t+1}$, compute, for each parameter set in the test suite, the triplet of floats $(R_f, \\mathbb{E}[R_e], \\mathbb{E}[R_e] - R_f)$.\n\nTest Suite (each tuple is $(\\beta, \\gamma, \\mu, \\sigma, p, b)$):\n- Case A (no disasters baseline): $(0.99, 4.0, 0.005, 0.02, 0.0, 0.3)$.\n- Case B (rare moderate disasters): $(0.99, 4.0, 0.005, 0.02, 0.01, 0.3)$.\n- Case C (rare severe disasters): $(0.99, 4.0, 0.005, 0.02, 0.01, 0.5)$.\n- Case D (disasters without diffusive risk): $(0.99, 4.0, 0.005, 0.0, 0.02, 0.4)$.\n- Case E (higher risk aversion with rare moderate disasters): $(0.99, 8.0, 0.005, 0.02, 0.01, 0.3)$.\n\nYour program must produce a single line of output containing the results for the five cases, formatted as a comma-separated list of five inner lists, each inner list containing the three floats $(R_f, \\mathbb{E}[R_e], \\mathbb{E}[R_e] - R_f)$ in that order. The line must have no spaces and must be enclosed in square brackets. For example, the required shape is $[[x_{1,1},x_{1,2},x_{1,3}],[x_{2,1},x_{2,2},x_{2,3}],[x_{3,1},x_{3,2},x_{3,3}],[x_{4,1},x_{4,2},x_{4,3}],[x_{5,1},x_{5,2},x_{5,3}]]$, where each $x_{i,j}$ is a float.",
            "solution": "The problem statement is subjected to rigorous validation and is found to be valid. It is scientifically grounded in established macroeconomic and financial theory, specifically the asset pricing framework with a representative agent, CRRA utility, and a rare-disaster process for consumption growth. The problem is well-posed, with all necessary parameters and distributions defined, ensuring that a unique and meaningful solution can be calculated. The language is objective and mathematically precise.\n\nThe solution proceeds by deriving the necessary analytical expressions. The core of the problem is the calculation of various expected values involving the gross consumption growth, $g_{t+1}$. The process for log-consumption growth is given by:\n$$ \\log g_{t+1} = \\mu + \\sigma \\varepsilon_{t+1} + \\ln(1-b) J_{t+1} $$\nwhere $\\varepsilon_{t+1} \\sim \\mathcal{N}(0,1)$ and $J_{t+1} \\sim \\text{Bernoulli}(p)$ are independent. We can write $g_{t+1}$ as the product of two independent random variables:\n$$ g_{t+1} = \\exp(\\mu + \\sigma \\varepsilon_{t+1}) \\cdot (1-b)^{J_{t+1}} $$\nLet $Z = \\exp(\\mu + \\sigma \\varepsilon_{t+1})$ and $V = (1-b)^{J_{t+1}}$. The variable $Z$ is log-normally distributed, with $\\log Z \\sim \\mathcal{N}(\\mu, \\sigma^2)$. The variable $V$ takes the value $1-b$ with probability $p$ and $1$ with probability $1-p$.\n\nThe key to solving the problem is to derive a general formula for the $k$-th moment of $g_{t+1}$, which is $\\mathbb{E}[g_{t+1}^k]$. Due to the independence of $Z$ and $V$, we have:\n$$ \\mathbb{E}[g_{t+1}^k] = \\mathbb{E}[Z^k V^k] = \\mathbb{E}[Z^k] \\mathbb{E}[V^k] $$\nThe expectation of $Z^k$ is a standard result for log-normal distributions:\n$$ \\mathbb{E}[Z^k] = \\mathbb{E}[\\exp(k(\\mu + \\sigma \\varepsilon_{t+1}))] = \\exp(k\\mu + \\frac{1}{2} k^2 \\sigma^2) $$\nThe expectation of $V^k$ is calculated from its discrete distribution:\n$$ \\mathbb{E}[V^k] = \\mathbb{E}[((1-b)^{J_{t+1}})^k] = (1-p) \\cdot (1-b)^{k \\cdot 0} + p \\cdot (1-b)^{k \\cdot 1} = (1-p) + p(1-b)^k $$\nCombining these results yields the general moment-generating formula for $g_{t+1}$:\n$$ \\mathbb{E}[g_{t+1}^k] = \\exp(k\\mu + \\frac{1}{2} k^2 \\sigma^2) \\left[ (1-p) + p(1-b)^k \\right] $$\nWe now apply this formula to derive the quantities of interest.\n\n1.  **Risk-Free Gross Return ($R_f$)**\n    The risk-free rate is defined by the equation $1 = \\mathbb{E}[m_{t+1}] R_f$. Thus, $R_f = 1 / \\mathbb{E}[m_{t+1}]$.\n    The stochastic discount factor (SDF) is $m_{t+1} = \\beta g_{t+1}^{-\\gamma}$. Its expectation is:\n    $$ \\mathbb{E}[m_{t+1}] = \\beta \\mathbb{E}[g_{t+1}^{-\\gamma}] $$\n    Using our general formula with $k = -\\gamma$:\n    $$ \\mathbb{E}[g_{t+1}^{-\\gamma}] = \\exp(-\\gamma\\mu + \\frac{1}{2} \\gamma^2 \\sigma^2) \\left[ (1-p) + p(1-b)^{-\\gamma} \\right] $$\n    Therefore, the risk-free rate is given by:\n    $$ R_f = \\frac{1}{\\beta \\exp(-\\gamma\\mu + \\frac{1}{2} \\gamma^2 \\sigma^2) \\left[ (1-p) + p(1-b)^{-\\gamma} \\right]} $$\n\n2.  **Expected Equity Gross Return ($\\mathbb{E}[R_e]$)**\n    The equity claim has a payoff $X_{t+1} = g_{t+1}$. Its price at time $t$ is $P_e = \\mathbb{E}[m_{t+1} X_{t+1}]$.\n    $$ P_e = \\mathbb{E}[\\beta g_{t+1}^{-\\gamma} g_{t+1}] = \\beta \\mathbb{E}[g_{t+1}^{1-\\gamma}] $$\n    Using the general formula with $k = 1-\\gamma$:\n    $$ \\mathbb{E}[g_{t+1}^{1-\\gamma}] = \\exp((1-\\gamma)\\mu + \\frac{1}{2} (1-\\gamma)^2 \\sigma^2) \\left[ (1-p) + p(1-b)^{1-\\gamma} \\right] $$\n    The gross return on equity is $R_e = g_{t+1} / P_e$. Its expectation is:\n    $$ \\mathbb{E}[R_e] = \\frac{\\mathbb{E}[g_{t+1}]}{P_e} = \\frac{\\mathbb{E}[g_{t+1}]}{\\beta \\mathbb{E}[g_{t+1}^{1-\\gamma}]} $$\n    The term $\\mathbb{E}[g_{t+1}]$ is found by setting $k=1$ in the general formula:\n    $$ \\mathbb{E}[g_{t+1}] = \\exp(\\mu + \\frac{1}{2} \\sigma^2) \\left[ (1-p) + p(1-b) \\right] = \\exp(\\mu + \\frac{1}{2} \\sigma^2) (1-pb) $$\n    Substituting the expressions for the expectations, we obtain the formula for the expected equity return.\n\n3.  **Equity Premium ($\\mathbb{E}[R_e] - R_f$)**\n    The equity premium is the difference between the expected gross return on equity and the risk-free gross return:\n    $$ \\text{Equity Premium} = \\mathbb{E}[R_e] - R_f $$\n    This is computed directly from the two previously derived quantities.\n\nThese formulae are implemented to calculate the required triplet $(R_f, \\mathbb{E}[R_e], \\mathbb{E}[R_e] - R_f)$ for each parameter set provided in the test suite.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the rare-disaster asset pricing model for the given test cases.\n    \"\"\"\n    \n    # Test Suite: tuples of (beta, gamma, mu, sigma, p, b)\n    test_cases = [\n        # Case A (no disasters baseline)\n        (0.99, 4.0, 0.005, 0.02, 0.0, 0.3),\n        # Case B (rare moderate disasters)\n        (0.99, 4.0, 0.005, 0.02, 0.01, 0.3),\n        # Case C (rare severe disasters)\n        (0.99, 4.0, 0.005, 0.02, 0.01, 0.5),\n        # Case D (disasters without diffusive risk)\n        (0.99, 4.0, 0.005, 0.0, 0.02, 0.4),\n        # Case E (higher risk aversion with rare moderate disasters)\n        (0.99, 8.0, 0.005, 0.02, 0.01, 0.3),\n    ]\n\n    all_results = []\n\n    def _calculate_moment(k, mu, sigma, p, b):\n        \"\"\"\n        Calculates the k-th moment of the gross consumption growth, E[g^k].\n        \"\"\"\n        lognormal_term = np.exp(k * mu + 0.5 * (k * sigma)**2)\n        disaster_term = (1 - p) + p * ((1 - b)**k)\n        return lognormal_term * disaster_term\n\n    for case in test_cases:\n        beta, gamma, mu, sigma, p, b = case\n\n        # 1. Calculate the Risk-Free Gross Return (Rf)\n        # E[m] = beta * E[g^(-gamma)]\n        e_g_neg_gamma = _calculate_moment(-gamma, mu, sigma, p, b)\n        e_m = beta * e_g_neg_gamma\n        r_f = 1.0 / e_m\n\n        # 2. Calculate the Expected Equity Gross Return (E[Re])\n        # E[Re] = E[g] / P_e, where P_e = beta * E[g^(1-gamma)]\n        \n        # E[g] = E[g^1]\n        e_g = _calculate_moment(1.0, mu, sigma, p, b)\n        \n        # E[g^(1-gamma)]\n        e_g_one_minus_gamma = _calculate_moment(1.0 - gamma, mu, sigma, p, b)\n        \n        # Price of equity, P_e\n        p_e = beta * e_g_one_minus_gamma\n        \n        # E[Re]\n        e_r_e = e_g / p_e\n\n        # 3. Calculate the Equity Premium (EP)\n        equity_premium = e_r_e - r_f\n        \n        result_triplet = [r_f, e_r_e, equity_premium]\n        all_results.append(result_triplet)\n\n    # Format the final output string as required, with no spaces.\n    final_output = str(all_results).replace(\" \", \"\")\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "While a powerful theoretical tool, the standard consumption-based SDF often struggles to price assets accurately with real-world data, which has led to the development of alternative models, such as linear factor models. This practice problem puts you in the role of an empirical economist, tasking you with comparing the performance of these two canonical SDF specifications by calculating their pricing errors on a cross-section of assets . This exercise is fundamental to understanding the practical challenges and trade-offs involved in empirical asset pricing.",
            "id": "2421338",
            "problem": "You are given a small artificial panel of asset gross returns, traded factor excess returns, a constant risk-free gross return, and aggregate consumption growth, all at a monthly frequency. Your task is to compute, from first principles, pricing errors implied by two distinct Stochastic Discount Factor (SDF) specifications on a cross-section of three industry portfolios, and to compare their root mean squared pricing errors. All returns are dimensionless gross returns. There are no physical units involved.\n\nData for $T=8$ consecutive months:\n- Risk-free gross return (constant across $t$): $R_{f} = 1.0025$.\n- Traded factor excess returns (two factors), for $t=1,\\dots,8$:\n  - Factor $1$: $\\{0.012,\\,0.005,\\,-0.010,\\,0.018,\\,-0.004,\\,0.009,\\,0.002,\\,0.015\\}$.\n  - Factor $2$: $\\{0.008,\\,-0.006,\\,0.004,\\,0.011,\\,-0.003,\\,0.007,\\,-0.002,\\,0.010\\}$.\n  Denote $f_{t} \\in \\mathbb{R}^{2}$ as the vector of the two factor excess returns in month $t$.\n- Gross returns of three industry portfolios, for $t=1,\\dots,8$:\n  - Industry $1$: $\\{1.015,\\,1.010,\\,0.995,\\,1.022,\\,1.000,\\,1.013,\\,1.005,\\,1.020\\}$.\n  - Industry $2$: $\\{1.012,\\,1.008,\\,0.992,\\,1.018,\\,0.998,\\,1.009,\\,1.004,\\,1.017\\}$.\n  - Industry $3$: $\\{1.018,\\,1.012,\\,0.997,\\,1.025,\\,1.003,\\,1.016,\\,1.006,\\,1.022\\}$.\n  Denote $R_{i,t}$ as the gross return of industry $i \\in \\{1,2,3\\}$ in month $t$.\n- Aggregate consumption growth (gross), for $t=1,\\dots,8$: $\\{1.003,\\,1.004,\\,0.999,\\,1.005,\\,1.001,\\,1.004,\\,1.002,\\,1.006\\}$.\n  Denote $g_{t} = C_{t}/C_{t-1}$.\n\nConsider two SDF specifications:\n1. Consumption-based SDF with power utility: for given discount factor $\\beta$ and relative risk aversion $\\gamma$, the SDF is $m^{C}_{t} = \\beta \\cdot g_{t}^{-\\gamma}$. Use $\\beta = 0.99$ and three values of $\\gamma$ as specified in the test suite below.\n2. Linear factor-based SDF: $m^{F}_{t} = a - b^{\\top} f_{t}$, where $a \\in \\mathbb{R}$ and $b \\in \\mathbb{R}^{2}$. Assume the two factors are returns on traded factor-mimicking portfolios in excess of the risk-free asset. Impose the asset pricing Euler equations for the (constant) risk-free asset and the traded factors using sample averages as empirical expectations: $\\mathbb{E}[m^{F}_{t}] \\cdot R_{f} = 1$ and $\\mathbb{E}[m^{F}_{t} f_{t}] = 0$.\n\nFor each SDF specification and for each industry $i \\in \\{1,2,3\\}$, define the pricing error as the sample-mean Euler equation deviation\n$$\n\\epsilon_{i} = \\frac{1}{T} \\sum_{t=1}^{T} m_{t} R_{i,t} - 1.\n$$\nFor each SDF specification, compute the root mean squared pricing error across the three industries,\n$$\n\\text{RMSPE} = \\sqrt{\\frac{1}{3} \\sum_{i=1}^{3} \\epsilon_{i}^{2}}.\n$$\n\nTest suite (three parameter sets for the consumption-based SDF, holding the factor-based SDF fixed by the data and $R_{f}$):\n- Case $1$: $\\gamma = 0.0$.\n- Case $2$: $\\gamma = 2.0$.\n- Case $3$: $\\gamma = 6.0$.\nIn all cases, use $\\beta = 0.99$.\n\nRequired final output format:\n- Your program should produce a single line of output containing a list of three items, one per test case in the order above. Each item must be a list with two floating-point numbers $[\\text{RMSPE}^{C}, \\text{RMSPE}^{F}]$, where $\\text{RMSPE}^{C}$ is the root mean squared pricing error from the consumption-based SDF for that case and $\\text{RMSPE}^{F}$ is the corresponding value from the factor-based SDF (the latter does not depend on $\\gamma$).\n- Round each floating-point number to exactly six digits after the decimal point.\n- The overall output must therefore have the form\n$$\n[[x_{1},y_{1}],[x_{2},y_{2}],[x_{3},y_{3}]],\n$$\nwhere each $x_{k}$ and $y_{k}$ are decimals with exactly six digits after the decimal point and there are no additional characters or whitespace beyond what is needed for a valid list.",
            "solution": "The problem presented is a well-posed exercise in empirical asset pricing, requiring the computation and comparison of pricing errors from two canonical Stochastic Discount Factor (SDF) models. The data and definitions are complete, scientifically sound, and internally consistent. It is a valid problem. We shall proceed with the solution.\n\nThe core of asset pricing is the Euler equation, which states that for any traded asset with gross return $R_t$, the following holds:\n$$\n1 = \\mathbb{E}[m_t R_t]\n$$\nwhere $m_t$ is the stochastic discount factor. In practice, models for $m_t$ do not perfectly price all assets. The deviation from this equation, the pricing error, is a measure of a model's performance. For a set of $N$ test assets with returns $R_{i,t}$, the pricing error for asset $i$ is defined using the sample analogue of the Euler equation:\n$$\n\\epsilon_i = \\frac{1}{T} \\sum_{t=1}^{T} m_t R_{i,t} - 1\n$$\nA common aggregate measure of performance is the root mean squared pricing error (RMSPE) across the test assets:\n$$\n\\text{RMSPE} = \\sqrt{\\frac{1}{N} \\sum_{i=1}^{N} \\epsilon_i^2}\n$$\nIn this problem, we evaluate two specific models for $m_t$ using a cross-section of $N=3$ industry portfolios.\n\n**1. Consumption-Based SDF ($m^C_t$)**\n\nThis model, rooted in the consumption decisions of a representative agent with power utility, specifies the SDF as:\n$$\nm^C_t = \\beta \\left(\\frac{C_t}{C_{t-1}}\\right)^{-\\gamma} = \\beta g_t^{-\\gamma}\n$$\nHere, $\\beta$ is the agent's subjective time discount factor, $g_t$ is the growth rate of aggregate consumption, and $\\gamma$ is the coefficient of relative risk aversion. The parameters $\\beta=0.99$ and $T=8$ are given, along with the time series for consumption growth $g_t$ and industry returns $R_{i,t}$. The task requires evaluating the model for three distinct values of risk aversion: $\\gamma \\in \\{0.0, 2.0, 6.0\\}$.\n\nFor each given $\\gamma$, the procedure is as follows:\na. Compute the time series for the SDF, $m^C_t$, for $t=1, \\dots, 8$.\nb. For each of the three industry portfolios ($i=1,2,3$), calculate the pricing error $\\epsilon_i^C = \\frac{1}{T} \\sum_{t=1}^{T} m^C_t R_{i,t} - 1$.\nc. Compute the $\\text{RMSPE}^C = \\sqrt{\\frac{1}{3} \\sum_{i=1}^{3} (\\epsilon_i^C)^2}$.\n\n**2. Linear Factor-Based SDF ($m^F_t$)**\n\nThis model posits that the SDF is a linear function of a set of traded factor excess returns, $f_t \\in \\mathbb{R}^K$. Here, $K=2$.\n$$\nm^F_t = a - b^\\top f_t\n$$\nThe scalar parameter $a$ and vector $b \\in \\mathbb{R}^2$ are not given a priori. Instead, they are determined by imposing that the model must correctly price the assets used to construct it. These assets are the risk-free asset, with constant gross return $R_f$, and the factor-mimicking portfolios themselves, which have excess returns $f_t$.\n\nThe pricing conditions, expressed using sample moments as estimators for expectations, are:\n1. For the risk-free asset: $\\mathbb{E}[m^F_t] R_f = 1 \\implies \\left(\\frac{1}{T} \\sum_{t=1}^{T} m^F_t\\right) R_f = 1$.\n2. For the factor excess returns: $\\mathbb{E}[m^F_t f_t] = \\vec{0} \\implies \\frac{1}{T} \\sum_{t=1}^{T} m^F_t f_t = \\vec{0}$.\n\nSubstituting the definition of $m^F_t$ into these conditions yields a system of equations for $a$ and $b$. Let $\\bar{f} = \\frac{1}{T}\\sum_t f_t$ be the sample mean of the factors and $\\overline{ff^\\top} = \\frac{1}{T}\\sum_t f_t f_t^\\top$ be the second-moment matrix.\n\nFrom condition 1:\n$$\n\\frac{1}{T} \\sum_{t=1}^{T} (a - b^\\top f_t) = \\frac{1}{R_f} \\implies a - b^\\top \\bar{f} = \\frac{1}{R_f} \\quad (*).\n$$\nFrom condition 2:\n$$\n\\frac{1}{T} \\sum_{t=1}^{T} (a - b^\\top f_t) f_t = \\vec{0} \\implies a \\bar{f} - \\overline{ff^\\top} b = \\vec{0} \\quad (**).\n$$\nFrom $(*)$, we express $a = \\frac{1}{R_f} + b^\\top \\bar{f}$. Substituting this into $(**)$:\n$$\n\\left(\\frac{1}{R_f} + b^\\top \\bar{f}\\right) \\bar{f} - \\overline{ff^\\top} b = \\vec{0}\n$$\n$$\n\\frac{1}{R_f}\\bar{f} + (\\bar{f} \\bar{f}^\\top) b - \\overline{ff^\\top} b = \\vec{0}\n$$\nRearranging to solve for $b$:\n$$\n(\\overline{ff^\\top} - \\bar{f} \\bar{f}^\\top) b = \\frac{1}{R_f} \\bar{f}\n$$\nThe term $(\\overline{ff^\\top} - \\bar{f} \\bar{f}^\\top)$ is precisely the sample covariance matrix of the factors, $\\Sigma_{ff}$. Thus, we have a linear system for the vector $b$:\n$$\n\\Sigma_{ff} b = \\frac{1}{R_f} \\bar{f}\n$$\nThis system can be solved for $b$, assuming $\\Sigma_{ff}$ is invertible. With $b$ determined, $a$ is found from equation $(*)$.\n\nThe procedure for the factor model is:\na. Compute the sample mean vector $\\bar{f}$ and sample covariance matrix $\\Sigma_{ff}$ from the provided factor data $f_t$.\nb. Solve the linear system $\\Sigma_{ff} b = \\frac{1}{R_f} \\bar{f}$ for the vector of factor loadings $b$.\nc. Calculate the intercept $a = \\frac{1}{R_f} + b^\\top \\bar{f}$.\nd. Construct the SDF time series $m^F_t = a - b^\\top f_t$ for $t=1, \\dots, 8$.\ne. For each of the three industry portfolios ($i=1,2,3$), calculate the pricing error $\\epsilon_i^F = \\frac{1}{T} \\sum_{t=1}^{T} m^F_t R_{i,t} - 1$.\nf. Compute the $\\text{RMSPE}^F = \\sqrt{\\frac{1}{3} \\sum_{i=1}^{3} (\\epsilon_i^F)^2}$. Since the factor model's parameters do not depend on $\\gamma$, this value will be the same for all three test cases.\n\nThe final output will list the pairs $[\\text{RMSPE}^C, \\text{RMSPE}^F]$ for each specified value of $\\gamma$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and compares the Root Mean Squared Pricing Errors (RMSPE)\n    for a consumption-based SDF and a linear factor-based SDF.\n    \"\"\"\n    \n    # 1. Define Givens from the problem statement\n    \n    # Constants and parameters\n    T = 8\n    R_f = 1.0025\n    beta = 0.99\n    gammas = [0.0, 2.0, 6.0]\n\n    # Time series data as numpy arrays\n    # Factor excess returns, shape (T, 2)\n    factors = np.array([\n        [0.012, 0.008],\n        [0.005, -0.006],\n        [-0.010, 0.004],\n        [0.018, 0.011],\n        [-0.004, -0.003],\n        [0.009, 0.007],\n        [0.002, -0.002],\n        [0.015, 0.010]\n    ])\n\n    # Industry portfolio gross returns, shape (T, 3)\n    industry_returns = np.array([\n        [1.015, 1.012, 1.018],\n        [1.010, 1.008, 1.012],\n        [0.995, 0.992, 0.997],\n        [1.022, 1.018, 1.025],\n        [1.000, 0.998, 1.003],\n        [1.013, 1.009, 1.016],\n        [1.005, 1.004, 1.006],\n        [1.020, 1.017, 1.022]\n    ])\n\n    # Aggregate consumption growth, shape (T,)\n    cons_growth = np.array([1.003, 1.004, 0.999, 1.005, 1.001, 1.004, 1.002, 1.006])\n\n    def calculate_rmspe(m, R):\n        \"\"\"\n        Calculates the RMSPE given an SDF vector and a matrix of asset returns.\n        \n        Args:\n            m (np.ndarray): The SDF time series, shape (T,).\n            R (np.ndarray): The asset returns time series, shape (T, N_assets).\n            \n        Returns:\n            float: The root mean squared pricing error.\n        \"\"\"\n        # Reshape m to (T, 1) for broadcasting\n        m_reshaped = m[:, np.newaxis]\n        \n        # Calculate pricing products m*R for each asset and time point\n        pricing_products = m_reshaped * R\n        \n        # Compute sample mean of m*R for each asset\n        mean_pricing_products = np.mean(pricing_products, axis=0)\n        \n        # Calculate pricing errors (alpha)\n        pricing_errors = mean_pricing_products - 1.0\n        \n        # Calculate root mean squared pricing error\n        rmspe = np.sqrt(np.mean(pricing_errors**2))\n        \n        return rmspe\n\n    # 2. Compute parameters and RMSPE for the Linear Factor-Based SDF\n    \n    # Sample mean of factor excess returns\n    f_mean = np.mean(factors, axis=0)\n    \n    # Sample covariance matrix of factors (ddof=0 for population formula 1/T)\n    f_cov = np.cov(factors, rowvar=False, ddof=0)\n    \n    # Solve the system Sigma_ff * b = (1/R_f) * f_mean for b\n    b = np.linalg.solve(f_cov, f_mean / R_f)\n    \n    # Calculate the intercept a\n    a = 1.0 / R_f + np.dot(b, f_mean)\n    \n    # Construct the SDF time series for the factor model\n    m_factor = a - factors @ b\n    \n    # Calculate the RMSPE for the factor model\n    rmspe_factor = calculate_rmspe(m_factor, industry_returns)\n\n    # 3. Compute RMSPE for the Consumption-Based SDF for each gamma\n    \n    results = []\n    for gamma in gammas:\n        # Construct the SDF time series for the consumption model\n        m_consumption = beta * (cons_growth ** (-gamma))\n        \n        # Calculate the RMSPE for the consumption model\n        rmspe_consumption = calculate_rmspe(m_consumption, industry_returns)\n        \n        # Store the pair of results for this case\n        results.append([rmspe_consumption, rmspe_factor])\n\n    # 4. Format and print the final output\n    \n    formatted_results = []\n    for res_pair in results:\n        # Format each number to exactly six decimal places\n        formatted_pair = f'[{res_pair[0]:.6f},{res_pair[1]:.6f}]'\n        formatted_results.append(formatted_pair)\n        \n    # Join the formatted pairs into the final string\n    final_output = f\"[{','.join(formatted_results)}]\"\n    \n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "Instead of committing to a specific economic theory for the SDF's functional form, we can estimate it directly from asset return data. This exercise introduces a powerful non-parametric approach where the SDF is approximated by a flexible linear combination of basis functions, with coefficients chosen to minimize cross-sectional pricing errors . By implementing this advanced technique on simulated data, you will also gain valuable insight into diagnosing practical problems like model misspecification and multicollinearity.",
            "id": "2394975",
            "problem": "You are given a cross-section of asset returns and a set of period-by-period basis functions intended to approximate an unknown stochastic discount factor (SDF), also called the pricing kernel, in a no-arbitrage asset pricing framework. The foundational definition you must use is that, under no arbitrage, for each asset index $i$ with gross return $R_{i,t}$ in period $t$, there exists a strictly positive SDF $m_t$ such that the unconditional pricing condition holds: $\\mathbb{E}[m_t R_{i,t}] = 1$. The task is to approximate the SDF by a linear function of basis functions and to estimate its coefficients by least squares, minimizing cross-sectional pricing errors.\n\nYou will work with a time series of $T$ periods and $I$ assets. Let $\\phi_t \\in \\mathbb{R}^K$ denote a $K$-dimensional vector of basis functions observed at period $t$. Approximate the SDF as $m_t \\approx \\beta^\\top \\phi_t$ for some coefficient vector $\\beta \\in \\mathbb{R}^K$. Define, for each asset $i$, the sample moment vector\n$$\nc_i = \\frac{1}{T}\\sum_{t=1}^T \\phi_t R_{i,t} \\in \\mathbb{R}^K.\n$$\nIf the linear approximation is exact, then $\\beta^\\top c_i = 1$ for all assets $i$. In general, with an overidentified system and finite samples, this need not hold exactly for a single $\\beta$. Use least squares to estimate $\\beta$ by minimizing the cross-sectional average squared pricing error,\n$$\n\\min_{\\beta \\in \\mathbb{R}^K} \\; \\frac{1}{I}\\sum_{i=1}^I \\left(\\beta^\\top c_i - 1\\right)^2.\n$$\n\nYour program must:\n- Construct the specified basis functions $\\phi_t$ for each period $t$ and test case.\n- Simulate returns according to the detailed data-generating processes (DGP) provided below.\n- Compute the matrix $C \\in \\mathbb{R}^{I \\times K}$ whose $i$-th row is $c_i^\\top$.\n- Estimate $\\hat{\\beta}$ by minimizing the objective above using least squares.\n- Report, for each test case, the root-mean-square cross-sectional pricing error,\n$$\n\\text{RMSE} = \\sqrt{\\frac{1}{I}\\sum_{i=1}^I \\left(\\hat{\\beta}^\\top c_i - 1\\right)^2}.\n$$\n\nImportant implementation details:\n- All randomness must be controlled by the provided seeds to ensure reproducibility.\n- To enforce the economically meaningful condition that $m_t = \\beta^\\top \\phi_t$ is strictly positive in the simulated data, ensure the minimum of $\\{\\beta^\\top \\phi_t\\}_{t=1}^T$ is bounded below by a positive constant by adjusting only the coefficient on the constant basis function if necessary.\n- In Test Cases $1$ and $3$, construct idiosyncratic noise $\\varepsilon_{i,t}$ for each asset $i$ such that the sample orthogonality condition $\\sum_{t=1}^T \\phi_t \\varepsilon_{i,t} = 0_K$ holds exactly. One way to achieve this is to project a random vector in $\\mathbb{R}^T$ onto the orthogonal complement of the column space of the design matrix $\\Phi \\in \\mathbb{R}^{T \\times K}$ whose $t$-th row is $\\phi_t^\\top$.\n\nTest Suite:\nYou must implement the following three test cases exactly as stated.\n\n- Test Case $1$ (exact pricing within the chosen span):\n  - Seed: $123$.\n  - Periods: $T = 180$.\n  - Assets: $I = 8$.\n  - Basis dimension: $K = 3$ with $\\phi_t = [1, z_{t,1}, z_{t,2}]^\\top$, where $z_{t,1}$ and $z_{t,2}$ are independent standard normal draws.\n  - Draw $\\beta \\in \\mathbb{R}^3$ with independent standard normal components and then enforce positivity of $m_t = \\beta^\\top \\phi_t$ by increasing the constant term so that $\\min_t m_t \\ge 0.6$.\n  - Define the baseline gross return series $b_t = 1 / (\\beta^\\top \\phi_t)$.\n  - For each asset $i$, generate idiosyncratic noise $\\varepsilon_{i} \\in \\mathbb{R}^T$ with the sample orthogonality condition $\\sum_{t=1}^T \\phi_t \\varepsilon_{i,t} = 0_K$, constructed by projecting a random vector onto the orthogonal complement of the column space of $\\Phi$. Scale each $\\varepsilon_i$ so that its sample standard deviation equals $0.05$.\n  - Set $R_{i,t} = b_t + \\varepsilon_{i,t}$.\n\n- Test Case $2$ (misspecification via a component correlated with the basis):\n  - Seed: $456$.\n  - Periods: $T = 200$.\n  - Assets: $I = 12$.\n  - Basis dimension: $K = 3$ with $\\phi_t = [1, z_{t,1}, z_{t,2}]^\\top$, where $z_{t,1}$ and $z_{t,2}$ are independent standard normal draws.\n  - Draw $\\beta \\in \\mathbb{R}^3$ with independent standard normal components and then enforce positivity of $m_t = \\beta^\\top \\phi_t$ by increasing the constant term so that $\\min_t m_t \\ge 0.6$.\n  - Define the baseline gross return series $b_t = 1 / (\\beta^\\top \\phi_t)$.\n  - Draw a vector $v \\in \\mathbb{R}^3$ with independent standard normal components, and rescale it so that the sample standard deviation of $d_t = v^\\top \\phi_t$ is $0.2$. Let $\\alpha_i$ be linearly spaced in the interval $[-0.3, 0.3]$ across $i = 1, \\dots, I$.\n  - For each asset $i$, generate idiosyncratic noise $\\varepsilon_{i} \\in \\mathbb{R}^T$ with the sample orthogonality condition $\\sum_{t=1}^T \\phi_t \\varepsilon_{i,t} = 0_K$, constructed by projection as in Test Case $1$, and scale each $\\varepsilon_i$ to have sample standard deviation $0.05$.\n  - Set $R_{i,t} = b_t + \\alpha_i d_t + \\varepsilon_{i,t}$.\n\n- Test Case $3$ (multicollinearity in the basis with exact pricing within span):\n  - Seed: $789$.\n  - Periods: $T = 160$.\n  - Assets: $I = 10$.\n  - Basis dimension: $K = 4$ with $\\phi_t = [1, z_{t,1}, z_{t,2}, z_{t,1}+z_{t,2}]^\\top$, where $z_{t,1}$ and $z_{t,2}$ are independent standard normal draws. Note that the basis is linearly dependent.\n  - Draw $\\beta \\in \\mathbb{R}^4$ with independent standard normal components and then enforce positivity of $m_t = \\beta^\\top \\phi_t$ by increasing the constant term so that $\\min_t m_t \\ge 0.6$.\n  - Define the baseline gross return series $b_t = 1 / (\\beta^\\top \\phi_t)$.\n  - For each asset $i$, generate idiosyncratic noise $\\varepsilon_{i} \\in \\mathbb{R}^T$ with the sample orthogonality condition $\\sum_{t=1}^T \\phi_t \\varepsilon_{i,t} = 0_K$, constructed by projection as in Test Case $1$, and scale each $\\varepsilon_i$ to have sample standard deviation $0.05$.\n  - Set $R_{i,t} = b_t + \\varepsilon_{i,t}$.\n\nComputation and output requirements:\n- For each test case, compute $c_i = \\frac{1}{T}\\sum_{t=1}^T \\phi_t R_{i,t}$, form the matrix $C \\in \\mathbb{R}^{I \\times K}$ with rows $c_i^\\top$, and estimate $\\hat{\\beta}$ by least squares minimizing $\\frac{1}{I}\\sum_{i=1}^I (\\beta^\\top c_i - 1)^2$.\n- Compute the RMSE $\\sqrt{\\frac{1}{I}\\sum_{i=1}^I (\\hat{\\beta}^\\top c_i - 1)^2}$ for each test case.\n- Your program should produce a single line of output containing the three RMSE values as a comma-separated list enclosed in square brackets, rounded to six decimal places, in the order of Test Case $1$, Test Case $2$, Test Case $3$ (e.g., \"[0.000000,0.012345,0.000000]\").",
            "solution": "The problem requires the estimation of a coefficient vector $\\beta \\in \\mathbb{R}^K$ for a linear approximation of a stochastic discount factor (SDF), $m_t \\approx \\beta^\\top \\phi_t$. The estimation is performed by minimizing the cross-sectional average squared pricing error. The objective function to be minimized is given by:\n$$\nJ(\\beta) = \\frac{1}{I}\\sum_{i=1}^I \\left(\\beta^\\top c_i - 1\\right)^2\n$$\nwhere $I$ is the number of assets, and $c_i = \\frac{1}{T}\\sum_{t=1}^T \\phi_t R_{i,t}$ is the sample moment vector for asset $i$, with $T$ being the number of time periods, $\\phi_t \\in \\mathbb{R}^K$ the vector of basis functions, and $R_{i,t}$ the gross return of asset $i$ at time $t$.\n\nThis optimization problem can be formulated as a standard linear least squares problem. Let $C$ be an $I \\times K$ matrix where the $i$-th row is $c_i^\\top$. Let $\\mathbf{1}_I$ be an $I$-dimensional column vector of ones. The objective function can then be written in matrix form as:\n$$\nJ(\\beta) = \\frac{1}{I} \\| C\\beta - \\mathbf{1}_I \\|_2^2\n$$\nMinimizing $J(\\beta)$ is equivalent to minimizing $\\| C\\beta - \\mathbf{1}_I \\|_2^2$. This is a linear regression of the vector $\\mathbf{1}_I$ onto the columns of the matrix $C$. The ordinary least squares (OLS) estimate $\\hat{\\beta}$ is the vector that minimizes this sum of squared residuals. It is given by $\\hat{\\beta} = (C^\\top C)^{-1} C^\\top \\mathbf{1}_I$, provided that the matrix $C^\\top C$ is invertible. If $C^\\top C$ is singular, a solution still exists but is not unique; in this case, a standard approach is to find the minimum-norm solution using the pseudoinverse, $\\hat{\\beta} = (C^\\top C)^+ C^\\top \\mathbf{1}_I$.\n\nThe final quantity to be reported is the root-mean-square cross-sectional pricing error (RMSE), which is defined as:\n$$\n\\text{RMSE} = \\sqrt{\\frac{1}{I}\\sum_{i=1}^I \\left(\\hat{\\beta}^\\top c_i - 1\\right)^2} = \\sqrt{\\frac{1}{I} \\| C\\hat{\\beta} - \\mathbf{1}_I \\|_2^2} = \\sqrt{J(\\hat{\\beta})}\n$$\n\nThe procedure for each test case is as follows:\n1.  **Generate Data**: For each test case, we generate the time series of basis functions $\\phi_t$ and asset returns $R_{i,t}$ according to the specified data-generating process (DGP). This involves setting the random seed for reproducibility, generating random variates, and constructing the variables as described.\n2.  **Construct Matrix $C$**: The matrix $C \\in \\mathbb{R}^{I \\times K}$ is computed. Its $(i, k)$-th element is $C_{ik} = \\frac{1}{T}\\sum_{t=1}^T R_{i,t} \\phi_{t,k}$. This can be computed efficiently using matrix multiplication as $C = \\frac{1}{T} \\mathbf{R} \\mathbf{\\Phi}$, where $\\mathbf{R}$ is the $I \\times T$ matrix of asset returns and $\\mathbf{\\Phi}$ is the $T \\times K$ design matrix whose $t$-th row is $\\phi_t^\\top$.\n3.  **Estimate $\\hat{\\beta}$**: We solve the least squares problem $\\min_{\\beta} \\| C\\beta - \\mathbf{1}_I \\|_2^2$ to find the estimate $\\hat{\\beta}$. This is done numerically using a standard linear algebra solver, which is robust to potential rank deficiencies in matrix $C$.\n4.  **Calculate RMSE**: Using the estimated $\\hat{\\beta}$, we compute the pricing errors for each asset, $e_i = \\hat{\\beta}^\\top c_i - 1$. The RMSE is then calculated as the square root of the mean of the squared pricing errors.\n\nLet us analyze the structure of each test case.\n\n**Test Case 1: Exact Pricing**\nIn this case, asset returns are $R_{i,t} = b_t + \\varepsilon_{i,t}$, where $b_t = 1 / (\\beta_{\\text{true}}^\\top \\phi_t)$ and the idiosyncratic noise $\\varepsilon_{i,t}$ is constructed to be orthogonal to the basis functions in the sample, i.e., $\\sum_{t=1}^T \\phi_t \\varepsilon_{i,t} = 0_K$. The sample moment vector for asset $i$ is:\n$$\nc_i = \\frac{1}{T}\\sum_{t=1}^T \\phi_t R_{i,t} = \\frac{1}{T}\\sum_{t=1}^T \\phi_t b_t + \\frac{1}{T}\\sum_{t=1}^T \\phi_t \\varepsilon_{i,t} = \\frac{1}{T}\\sum_{t=1}^T \\phi_t \\frac{1}{\\beta_{\\text{true}}^\\top \\phi_t} + 0_K\n$$\nThis vector $c_i$ is independent of the asset index $i$. Let's call it $c^*$. The pricing condition with the true $\\beta_{\\text{true}}$ is:\n$$\n\\beta_{\\text{true}}^\\top c_i = \\beta_{\\text{true}}^\\top c^* = \\frac{1}{T}\\sum_{t=1}^T \\frac{\\beta_{\\text{true}}^\\top \\phi_t}{\\beta_{\\text{true}}^\\top \\phi_t} = \\frac{1}{T}\\sum_{t=1}^T 1 = 1\n$$\nThe pricing error is exactly $0$ for all assets with the true $\\beta_{\\text{true}}$. The least squares minimization will find a coefficient vector $\\hat{\\beta}$ (which may or may not be equal to $\\beta_{\\text{true}}$) that also yields zero pricing error. Therefore, the RMSE is expected to be $0$, up to floating-point precision.\n\n**Test Case 2: Misspecification**\nHere, returns are $R_{i,t} = b_t + \\alpha_i d_t + \\varepsilon_{i,t}$, where $d_t$ is correlated with the basis functions but is not spanned by them in a way that the model can capture perfectly. The moment vector is:\n$$\nc_i = c^* + \\alpha_i \\left(\\frac{1}{T}\\sum_{t=1}^T \\phi_t d_t\\right)\n$$\nThe pricing condition with any candidate $\\beta$ becomes $\\beta^\\top c_i = \\beta^\\top c^* + \\alpha_i \\beta^\\top \\left(\\frac{1}{T}\\sum_t \\phi_t d_t\\right)$. Since $\\alpha_i$ varies across assets, it is impossible for a single $\\beta$ to make the pricing error $\\beta^\\top c_i - 1$ equal to zero for all assets. The SDF is misspecified as it omits the factor represented by $d_t$. The least squares procedure will find a best-fit $\\hat{\\beta}$, but the resulting minimum average squared error, and thus the RMSE, will be non-zero.\n\n**Test Case 3: Multicollinearity**\nThis case uses a linearly dependent set of basis functions: $\\phi_{t,4} = \\phi_{t,2} + \\phi_{t,3}$. The DGP is otherwise identical to Test Case $1$. The linear dependence in $\\phi_t$ implies that the design matrix $\\mathbf{\\Phi}$ is rank-deficient. Consequently, the matrix $C = \\frac{1}{T} \\mathbf{R} \\mathbf{\\Phi}$ will also be rank-deficient. The normal equations matrix $C^\\top C$ will be singular, meaning the OLS estimate $\\hat{\\beta}$ is not unique. However, the vector of predicted prices, $C\\hat{\\beta}$, is unique as it represents the projection of $\\mathbf{1}_I$ onto the column space of $C$. The pricing errors and the RMSE are therefore unique and well-defined. As in Test Case $1$, the pricing model is correctly specified within the span of the basis functions, so we expect the minimum pricing error and the resulting RMSE to be $0$. This case tests the numerical robustness of the least squares implementation.\n\nThe implementation will follow these principles, using `numpy` for numerical computations, including a robust least squares solver that handles rank deficiency.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # (T, I, K, seed, case_type, description)\n        (180, 8, 3, 123, 1, \"Test Case 1: Exact pricing\"),\n        (200, 12, 3, 456, 2, \"Test Case 2: Misspecification\"),\n        (160, 10, 4, 789, 3, \"Test Case 3: Multicollinearity\"),\n    ]\n\n    results = []\n    for T, I, K, seed, case_type, _ in test_cases:\n        rmse = run_simulation(T, I, K, seed, case_type)\n        results.append(f\"{rmse:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef run_simulation(T, I, K, seed, case_type):\n    \"\"\"\n    Runs a single simulation for a given test case configuration.\n    \n    Args:\n        T (int): Number of time periods.\n        I (int): Number of assets.\n        K (int): Dimension of basis functions.\n        seed (int): Random seed for reproducibility.\n        case_type (int): Identifier for the test case (1, 2, or 3).\n        \n    Returns:\n        float: The calculated root-mean-square pricing error (RMSE).\n    \"\"\"\n    # Initialize random number generator with the specified seed\n    rng = np.random.default_rng(seed)\n\n    # 1. Construct basis functions (design matrix Phi)\n    # z_t,1 and z_t,2 are independent standard normal draws\n    z = rng.standard_normal(size=(T, 2))\n    \n    if case_type == 1 or case_type == 2:\n        # Case 1  2: phi_t = [1, z_t,1, z_t,2]^T\n        Phi = np.c_[np.ones(T), z]\n    elif case_type == 3:\n        # Case 3: phi_t = [1, z_t,1, z_t,2, z_t,1+z_t,2]^T (multicollinearity)\n        Phi = np.c_[np.ones(T), z, z[:, 0] + z[:, 1]]\n    \n    # 2. Generate true beta and enforce positivity of SDF m_t\n    beta_true = rng.standard_normal(size=K)\n    m = Phi @ beta_true\n    min_m = np.min(m)\n    if min_m  0.6:\n        # Adjust the constant term (beta_0) to meet the positivity constraint\n        beta_true[0] += (0.6 - min_m)\n    \n    # Define the true SDF m_t and baseline gross return b_t\n    m_true = Phi @ beta_true\n    b = 1.0 / m_true\n\n    # 3. Generate asset returns R (I x T matrix)\n    R = np.zeros((I, T))\n    \n    # Pre-calculate components for Case 2 if applicable\n    d = None\n    alphas = None\n    if case_type == 2:\n        v = rng.standard_normal(size=K)\n        d_unscaled = Phi @ v\n        # Rescale d_t to have a sample standard deviation of 0.2\n        d = d_unscaled * (0.2 / np.std(d_unscaled, ddof=1))\n        # Exposures alpha_i are linearly spaced in [-0.3, 0.3]\n        alphas = np.linspace(-0.3, 0.3, num=I)\n\n    for i in range(I):\n        # Generate idiosyncratic noise epsilon_i\n        # Project a random vector onto the orthogonal complement of Phi's column space\n        e_i = rng.standard_normal(size=T)\n        \n        # Use lstsq to find the projection of e_i onto the column space of Phi\n        # This is a numerically stable way to perform the projection\n        coeffs_for_proj = np.linalg.lstsq(Phi, e_i, rcond=None)[0]\n        proj_e_i = Phi @ coeffs_for_proj\n        epsilon_i = e_i - proj_e_i\n        \n        # Verify orthogonality condition: sum_t(phi_t * epsilon_i,t) = 0\n        # np.allclose(Phi.T @ epsilon_i, 0) should be True\n\n        # Scale epsilon_i to have a sample standard deviation of 0.05\n        # The mean is guaranteed to be 0 since Phi contains a constant column\n        epsilon_i *= 0.05 / np.std(epsilon_i, ddof=1)\n        \n        # Construct asset returns based on the test case\n        if case_type == 1 or case_type == 3:\n            R[i, :] = b + epsilon_i\n        elif case_type == 2:\n            R[i, :] = b + alphas[i] * d + epsilon_i\n\n    # 4. Compute the matrix C (I x K)\n    # C_ik = (1/T) * sum_t(R_it * Phi_tk)\n    C = (1 / T) * (R @ Phi)\n\n    # 5. Estimate beta_hat by minimizing ||C*beta - 1||^2 using least squares\n    ones_I = np.ones(I)\n    beta_hat = np.linalg.lstsq(C, ones_I, rcond=None)[0]\n\n    # 6. Compute the root-mean-square pricing error (RMSE)\n    pricing_errors = C @ beta_hat - ones_I\n    rmse = np.sqrt(np.mean(pricing_errors**2))\n    \n    return rmse\n\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}