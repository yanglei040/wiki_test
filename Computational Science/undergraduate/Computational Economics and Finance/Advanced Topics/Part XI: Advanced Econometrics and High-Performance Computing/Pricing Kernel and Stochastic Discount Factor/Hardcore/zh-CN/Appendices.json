{
    "hands_on_practices": [
        {
            "introduction": "随机折现因子 (SDF) 的理论根基在于宏观经济基本面。本练习将通过一个著名的罕见灾难模型，让您亲手探索SDF如何解释金融领域最大的谜题之一——股权溢价之谜 。您将通过解析计算，直观地看到消费增长中的小概率灾难性事件如何深刻地影响SDF的形态，并最终产生巨大的风险溢价。",
            "id": "2421399",
            "problem": "考虑一个具有恒定相对风险规避（CRRA）效用的代表性代理人禀赋经济体。设总消费为 $\\{C_t\\}_{t \\ge 0}$，并定义消费总量增长为 $g_{t+1} = \\frac{C_{t+1}}{C_t}$。该代理人的随机折现因子（SDF）由 $m_{t+1} = \\beta \\, g_{t+1}^{-\\gamma}$ 给出，其中 $\\beta \\in (0,1)$ 是主观折现因子，$\\gamma \\gt 0$ 是相对风险规避系数。消费增长遵循一个罕见灾难混合过程：\n$$\n\\log g_{t+1} = \\mu + \\sigma \\,\\varepsilon_{t+1} + \\ln(1-b)\\, J_{t+1},\n$$\n其中 $\\varepsilon_{t+1} \\sim \\mathcal{N}(0,1)$，$J_{t+1} \\sim \\text{Bernoulli}(p)$，并且 $(\\varepsilon_{t+1}, J_{t+1})$ 在时间上独立且相互独立。参数 $b \\in (0,1)$ 是灾难期间消费的下降比例，而 $p \\in [0,1]$ 是在给定时期内发生灾难的概率。参数 $\\mu \\in \\mathbb{R}$ 和 $\\sigma \\ge 0$ 控制消费增长的对数正态部分。\n\n考虑两种由基本定价方程 $P_t = \\mathbb{E}_t[m_{t+1} X_{t+1}]$ 定价的单期资产，其中 $X_{t+1}$ 是下一期的回报：\n- 一种无风险单期纯贴现债券，其总回报率为 $R_f$，满足 $\\mathbb{E}[m_{t+1}] \\, R_f = 1$。\n- 一种风险“股权”索取权，其单期回报为 $X_{t+1} = g_{t+1}$。其在 $t$ 日的价格为 $P_e = \\mathbb{E}[m_{t+1} g_{t+1}]$，其单期总回报率为 $R_e = \\frac{g_{t+1}}{P_e}$。将预期股权回报定义为 $\\mathbb{E}[R_e]$，股权溢价定义为 $\\mathbb{E}[R_e] - R_f$。\n\n仅使用上述定义和为 $g_{t+1}$ 指定的概率结构，为测试套件中的每个参数集计算浮点数三元组 $(R_f, \\mathbb{E}[R_e], \\mathbb{E}[R_e] - R_f)$。\n\n测试套件（每个元组为 $(\\beta, \\gamma, \\mu, \\sigma, p, b)$）：\n- 案例A（无灾难基线）：$(0.99, 4.0, 0.005, 0.02, 0.0, 0.3)$。\n- 案例B（罕见中度灾难）：$(0.99, 4.0, 0.005, 0.02, 0.01, 0.3)$。\n- 案例C（罕见严重灾难）：$(0.99, 4.0, 0.005, 0.02, 0.01, 0.5)$。\n- 案例D（无扩散风险的灾难）：$(0.99, 4.0, 0.005, 0.0, 0.02, 0.4)$。\n- 案例E（罕见中度灾难下更高的风险规避）：$(0.99, 8.0, 0.005, 0.02, 0.01, 0.3)$。\n\n您的程序必须生成单行输出，其中包含五个案例的结果，格式为一个由五个内部列表组成的逗号分隔列表，每个内部列表按顺序包含三个浮点数 $(R_f, \\mathbb{E}[R_e], \\mathbb{E}[R_e] - R_f)$。该行必须没有空格，并且必须用方括号括起来。例如，所需的形状是 $[[x_{1,1},x_{1,2},x_{1,3}],[x_{2,1},x_{2,2},x_{2,3}],[x_{3,1},x_{3,2},x_{3,3}],[x_{4,1},x_{4,2},x_{4,3}],[x_{5,1},x_{5,2},x_{5,3}]]$, 其中每个 $x_{i,j}$ 都是一个浮点数。",
            "solution": "问题陈述经过严格验证，被认定为有效。它在科学上基于已建立的宏观经济和金融理论，特别是包含代表性代理人、CRRA效用和消费增长罕见灾难过程的资产定价框架。该问题是适定的，所有必要的参数和分布都已定义，确保可以计算出唯一且有意义的解。语言客观且数学上精确。\n\n求解过程是通过推导必要的解析表达式来进行的。问题的核心是计算涉及消费总量增长 $g_{t+1}$ 的各种期望值。对数消费增长的过程由下式给出：\n$$ \\log g_{t+1} = \\mu + \\sigma \\varepsilon_{t+1} + \\ln(1-b) J_{t+1} $$\n其中 $\\varepsilon_{t+1} \\sim \\mathcal{N}(0,1)$ 和 $J_{t+1} \\sim \\text{Bernoulli}(p)$ 是独立的。我们可以将 $g_{t+1}$ 写成两个独立随机变量的乘积：\n$$ g_{t+1} = \\exp(\\mu + \\sigma \\varepsilon_{t+1}) \\cdot (1-b)^{J_{t+1}} $$\n设 $Z = \\exp(\\mu + \\sigma \\varepsilon_{t+1})$ 且 $V = (1-b)^{J_{t+1}}$。变量 $Z$ 是对数正态分布的，其中 $\\log Z \\sim \\mathcal{N}(\\mu, \\sigma^2)$。变量 $V$ 以概率 $p$ 取值 $1-b$，以概率 $1-p$ 取值 $1$。\n\n解决问题的关键是推导出 $g_{t+1}$ 的 $k$ 阶矩的通用公式，即 $\\mathbb{E}[g_{t+1}^k]$。由于 $Z$ 和 $V$ 的独立性，我们有：\n$$ \\mathbb{E}[g_{t+1}^k] = \\mathbb{E}[Z^k V^k] = \\mathbb{E}[Z^k] \\mathbb{E}[V^k] $$\n$Z^k$ 的期望是对数正态分布的一个标准结果：\n$$ \\mathbb{E}[Z^k] = \\mathbb{E}[\\exp(k(\\mu + \\sigma \\varepsilon_{t+1}))] = \\exp(k\\mu + \\frac{1}{2} k^2 \\sigma^2) $$\n$V^k$ 的期望从其离散分布计算得出：\n$$ \\mathbb{E}[V^k] = \\mathbb{E}[((1-b)^{J_{t+1}})^k] = (1-p) \\cdot (1-b)^{k \\cdot 0} + p \\cdot (1-b)^{k \\cdot 1} = (1-p) + p(1-b)^k $$\n结合这些结果，得到 $g_{t+1}$ 的通用矩生成公式：\n$$ \\mathbb{E}[g_{t+1}^k] = \\exp(k\\mu + \\frac{1}{2} k^2 \\sigma^2) \\left[ (1-p) + p(1-b)^k \\right] $$\n我们现在应用此公式来推导我们感兴趣的量。\n\n1.  **无风险总回报率 ($R_f$)**\n    无风险利率由方程 $1 = \\mathbb{E}[m_{t+1}] R_f$ 定义。因此，$R_f = 1 / \\mathbb{E}[m_{t+1}]$。\n    随机折现因子（SDF）为 $m_{t+1} = \\beta g_{t+1}^{-\\gamma}$。其期望为：\n    $$ \\mathbb{E}[m_{t+1}] = \\beta \\mathbb{E}[g_{t+1}^{-\\gamma}] $$\n    使用我们的通用公式，令 $k = -\\gamma$：\n    $$ \\mathbb{E}[g_{t+1}^{-\\gamma}] = \\exp(-\\gamma\\mu + \\frac{1}{2} \\gamma^2 \\sigma^2) \\left[ (1-p) + p(1-b)^{-\\gamma} \\right] $$\n    因此，无风险利率由下式给出：\n    $$ R_f = \\frac{1}{\\beta \\exp(-\\gamma\\mu + \\frac{1}{2} \\gamma^2 \\sigma^2) \\left[ (1-p) + p(1-b)^{-\\gamma} \\right]} $$\n\n2.  **预期股权总回报率 ($\\mathbb{E}[R_e]$)**\n    股权索取权的回报为 $X_{t+1} = g_{t+1}$。其在时间 $t$ 的价格为 $P_e = \\mathbb{E}[m_{t+1} X_{t+1}]$。\n    $$ P_e = \\mathbb{E}[\\beta g_{t+1}^{-\\gamma} g_{t+1}] = \\beta \\mathbb{E}[g_{t+1}^{1-\\gamma}] $$\n    使用通用公式，令 $k = 1-\\gamma$：\n    $$ \\mathbb{E}[g_{t+1}^{1-\\gamma}] = \\exp((1-\\gamma)\\mu + \\frac{1}{2} (1-\\gamma)^2 \\sigma^2) \\left[ (1-p) + p(1-b)^{1-\\gamma} \\right] $$\n    股权的总回报率为 $R_e = g_{t+1} / P_e$。其期望为：\n    $$ \\mathbb{E}[R_e] = \\frac{\\mathbb{E}[g_{t+1}]}{P_e} = \\frac{\\mathbb{E}[g_{t+1}]}{\\beta \\mathbb{E}[g_{t+1}^{1-\\gamma}]} $$\n    通过在通用公式中设置 $k=1$ 可以找到项 $\\mathbb{E}[g_{t+1}]$：\n    $$ \\mathbb{E}[g_{t+1}] = \\exp(\\mu + \\frac{1}{2} \\sigma^2) \\left[ (1-p) + p(1-b) \\right] = \\exp(\\mu + \\frac{1}{2} \\sigma^2) (1-pb) $$\n    代入期望的表达式，我们得到预期股权回报的公式。\n\n3.  **股权溢价 ($\\mathbb{E}[R_e] - R_f$)**\n    股权溢价是预期股权总回报率与无风险总回报率之间的差额：\n    $$ \\text{Equity Premium} = \\mathbb{E}[R_e] - R_f $$\n    这是直接从前面推导出的两个量计算得出的。\n\n这些公式被用来为测试套件中提供的每个参数集计算所需的三元组 $(R_f, \\mathbb{E}[R_e], \\mathbb{E}[R_e] - R_f)$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the rare-disaster asset pricing model for the given test cases.\n    \"\"\"\n    \n    # Test Suite: tuples of (beta, gamma, mu, sigma, p, b)\n    test_cases = [\n        # Case A (no disasters baseline)\n        (0.99, 4.0, 0.005, 0.02, 0.0, 0.3),\n        # Case B (rare moderate disasters)\n        (0.99, 4.0, 0.005, 0.02, 0.01, 0.3),\n        # Case C (rare severe disasters)\n        (0.99, 4.0, 0.005, 0.02, 0.01, 0.5),\n        # Case D (disasters without diffusive risk)\n        (0.99, 4.0, 0.005, 0.0, 0.02, 0.4),\n        # Case E (higher risk aversion with rare moderate disasters)\n        (0.99, 8.0, 0.005, 0.02, 0.01, 0.3),\n    ]\n\n    all_results = []\n\n    def _calculate_moment(k, mu, sigma, p, b):\n        \"\"\"\n        Calculates the k-th moment of the gross consumption growth, E[g^k].\n        \"\"\"\n        lognormal_term = np.exp(k * mu + 0.5 * (k * sigma)**2)\n        disaster_term = (1 - p) + p * ((1 - b)**k)\n        return lognormal_term * disaster_term\n\n    for case in test_cases:\n        beta, gamma, mu, sigma, p, b = case\n\n        # 1. Calculate the Risk-Free Gross Return (Rf)\n        # E[m] = beta * E[g^(-gamma)]\n        e_g_neg_gamma = _calculate_moment(-gamma, mu, sigma, p, b)\n        e_m = beta * e_g_neg_gamma\n        r_f = 1.0 / e_m\n\n        # 2. Calculate the Expected Equity Gross Return (E[Re])\n        # E[Re] = E[g] / P_e, where P_e = beta * E[g^(1-gamma)]\n        \n        # E[g] = E[g^1]\n        e_g = _calculate_moment(1.0, mu, sigma, p, b)\n        \n        # E[g^(1-gamma)]\n        e_g_one_minus_gamma = _calculate_moment(1.0 - gamma, mu, sigma, p, b)\n        \n        # Price of equity, P_e\n        p_e = beta * e_g_one_minus_gamma\n        \n        # E[Re]\n        e_r_e = e_g / p_e\n\n        # 3. Calculate the Equity Premium (EP)\n        equity_premium = e_r_e - r_f\n        \n        result_triplet = [r_f, e_r_e, equity_premium]\n        all_results.append(result_triplet)\n\n    # Format the final output string as required, with no spaces.\n    final_output = str(all_results).replace(\" \", \"\")\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "在资产定价领域，理论模型（如基于消费的SDF）和经验模型（如基于因子的SDF）并行发展，各有千秋。本练习提供了一个直接比较这两种核心模型定价能力的机会 。您将学习如何构建一个因子模型的SDF，并用定价误差这一关键指标来衡量它与消费模型的表现，从而获得评估和比较不同SDF模型的实践经验。",
            "id": "2421338",
            "problem": "给定一个小型的人工资产总回报率、交易因子超额回报率、恒定无风险总回报率和总体消费增长率的面板数据，均为月度频率。您的任务是，从第一性原理出发，计算两种不同随机贴现因子（SDF）设定在一个包含三个行业投资组合的横截面数据上所产生的定价误差，并比较它们的均方根定价误差。所有回报率均为无量纲的总回报率，不涉及物理单位。\n\n$T=8$ 个连续月份的数据：\n- 无风险总回报率（在所有 $t$ 上恒定）：$R_{f} = 1.0025$。\n- 交易因子超额回报率（两个因子），对于 $t=1,\\dots,8$：\n  - 因子 1：$\\{0.012,\\,0.005,\\,-0.010,\\,0.018,\\,-0.004,\\,0.009,\\,0.002,\\,0.015\\}$。\n  - 因子 2：$\\{0.008,\\,-0.006,\\,0.004,\\,0.011,\\,-0.003,\\,0.007,\\,-0.002,\\,0.010\\}$。\n  将 $f_{t} \\in \\mathbb{R}^{2}$ 表示为第 $t$ 个月中两个因子超额回报率的向量。\n- 三个行业投资组合的总回报率，对于 $t=1,\\dots,8$：\n  - 行业 1：$\\{1.015,\\,1.010,\\,0.995,\\,1.022,\\,1.000,\\,1.013,\\,1.005,\\,1.020\\}$。\n  - 行业 2：$\\{1.012,\\,1.008,\\,0.992,\\,1.018,\\,0.998,\\,1.009,\\,1.004,\\,1.017\\}$。\n  - 行业 3：$\\{1.018,\\,1.012,\\,0.997,\\,1.025,\\,1.003,\\,1.016,\\,1.006,\\,1.022\\}$。\n  将 $R_{i,t}$ 表示为行业 $i \\in \\{1,2,3\\}$ 在第 $t$ 个月中的总回报率。\n- 总体消费增长率（总增长率），对于 $t=1,\\dots,8$：$\\{1.003,\\,1.004,\\,0.999,\\,1.005,\\,1.001,\\,1.004,\\,1.002,\\,1.006\\}$。\n  表示为 $g_{t} = C_{t}/C_{t-1}$。\n\n考虑两种 SDF 设定：\n1. 基于消费的幂效用 SDF：对于给定的贴现因子 $\\beta$ 和相对风险厌恶系数 $\\gamma$，SDF 为 $m^{C}_{t} = \\beta \\cdot g_{t}^{-\\gamma}$。使用 $\\beta = 0.99$ 和下面测试套件中指定的三个 $\\gamma$ 值。\n2. 线性因子 SDF：$m^{F}_{t} = a - b^{\\top} f_{t}$，其中 $a \\in \\mathbb{R}$ 且 $b \\in \\mathbb{R}^{2}$。假设这两个因子是在无风险资产基础上构建的交易因子模拟投资组合的回报率。使用样本均值作为经验期望，对（恒定）无风险资产和交易因子施加资产定价欧拉方程：$\\mathbb{E}[m^{F}_{t}] \\cdot R_{f} = 1$ 和 $\\mathbb{E}[m^{F}_{t} f_{t}] = 0$。\n\n对于每种 SDF 设定和每个行业 $i \\in \\{1,2,3\\}$，将定价误差定义为样本均值欧拉方程偏差\n$$\n\\epsilon_{i} = \\frac{1}{T} \\sum_{t=1}^{T} m_{t} R_{i,t} - 1.\n$$\n对于每种 SDF 设定，计算三个行业的均方根定价误差\n$$\n\\text{RMSPE} = \\sqrt{\\frac{1}{3} \\sum_{i=1}^{3} \\epsilon_{i}^{2}}.\n$$\n\n测试套件（三组基于消费的 SDF 参数，因子 SDF 由数据和 $R_{f}$ 固定）：\n- 情况 1：$\\gamma = 0.0$。\n- 情况 2：$\\gamma = 2.0$。\n- 情况 3：$\\gamma = 6.0$。\n在所有情况下，均使用 $\\beta = 0.99$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个含三个项目的列表，每个项目对应上述顺序的一个测试用例。每个项目必须是包含两个浮点数的列表 $[\\text{RMSPE}^{C}, \\text{RMSPE}^{F}]$，其中 $\\text{RMSPE}^{C}$ 是该情况下基于消费的 SDF 的均方根定价误差，$\\text{RMSPE}^{F}$ 是基于因子的 SDF 对应的值（后者不依赖于 $\\gamma$）。\n- 将每个浮点数四舍五入到小数点后六位。\n- 因此，总输出必须具有以下形式\n$$\n[[x_{1},y_{1}],[x_{2},y_{2}],[x_{3},y_{3}]],\n$$\n其中每个 $x_{k}$ 和 $y_{k}$ 都是小数点后恰好有六位的小数，并且除了构成有效列表所需的字符或空格外，没有其他额外字符。",
            "solution": "所呈现的问题是一项结构清晰的实证资产定价练习，要求计算并比较两种经典的随机贴现因子（SDF）模型的定价误差。数据和定义完整、科学合理且内部一致。这是一个有效的问题。我们将着手解决。\n\n资产定价的核心是欧拉方程，该方程指出对于任何总回报率为 $R_t$ 的交易资产，以下等式成立：\n$$\n1 = \\mathbb{E}[m_t R_t]\n$$\n其中 $m_t$ 是随机贴现因子。在实践中，$m_t$ 的模型并不能完美地为所有资产定价。与此方程的偏差，即定价误差，是衡量模型性能的一个指标。对于一组具有回报率 $R_{i,t}$ 的 $N$ 个测试资产，资产 $i$ 的定价误差使用欧拉方程的样本模拟来定义：\n$$\n\\epsilon_i = \\frac{1}{T} \\sum_{t=1}^{T} m_t R_{i,t} - 1\n$$\n一个常见的总体性能度量是跨测试资产的均方根定价误差（RMSPE）：\n$$\n\\text{RMSPE} = \\sqrt{\\frac{1}{N} \\sum_{i=1}^{N} \\epsilon_i^2}\n$$\n在这个问题中，我们使用一个包含 $N=3$ 个行业投资组合的横截面数据来评估两种特定的 $m_t$ 模型。\n\n**1. 基于消费的 SDF ($m^C_t$)**\n\n该模型根植于具有幂效用的代表性代理人的消费决策，将 SDF 定义为：\n$$\nm^C_t = \\beta \\left(\\frac{C_t}{C_{t-1}}\\right)^{-\\gamma} = \\beta g_t^{-\\gamma}\n$$\n这里，$\\beta$ 是代理人的主观时间贴现因子，$g_t$ 是总体消费的增长率，$\\gamma$ 是相对风险厌恶系数。给定了参数 $\\beta=0.99$ 和 $T=8$，以及消费增长率 $g_t$ 和行业回报率 $R_{i,t}$ 的时间序列。任务要求针对三个不同的风险厌恶值 $\\gamma \\in \\{0.0, 2.0, 6.0\\}$ 来评估模型。\n\n对于每个给定的 $\\gamma$，流程如下：\na. 计算 $t=1, \\dots, 8$ 的 SDF 时间序列 $m^C_t$。\nb. 对于三个行业投资组合中的每一个（$i=1,2,3$），计算定价误差 $\\epsilon_i^C = \\frac{1}{T} \\sum_{t=1}^{T} m^C_t R_{i,t} - 1$。\nc. 计算 $\\text{RMSPE}^C = \\sqrt{\\frac{1}{3} \\sum_{i=1}^{3} (\\epsilon_i^C)^2}$。\n\n**2. 线性因子 SDF ($m^F_t$)**\n\n该模型假设 SDF 是一组交易因子超额回报率 $f_t \\in \\mathbb{R}^K$ 的线性函数。这里，$K=2$。\n$$\nm^F_t = a - b^\\top f_t\n$$\n标量参数 $a$ 和向量 $b \\in \\mathbb{R}^2$ 并非先验给定，而是通过施加模型必须正确定价其构建所用资产的条件来确定。这些资产是具有恒定总回报率 $R_f$ 的无风险资产，以及因子模拟投资组合本身，其超额回报率为 $f_t$。\n\n定价条件，使用样本矩作为期望的估计量来表示，为：\n1. 对于无风险资产：$\\mathbb{E}[m^F_t] R_f = 1 \\implies \\left(\\frac{1}{T} \\sum_{t=1}^{T} m^F_t\\right) R_f = 1$。\n2. 对于因子超额回报率：$\\mathbb{E}[m^F_t f_t] = \\vec{0} \\implies \\frac{1}{T} \\sum_{t=1}^{T} m^F_t f_t = \\vec{0}$。\n\n将 $m^F_t$ 的定义代入这些条件，得到一个关于 $a$ 和 $b$ 的方程组。令 $\\bar{f} = \\frac{1}{T}\\sum_t f_t$ 为因子的样本均值，$\\overline{ff^\\top} = \\frac{1}{T}\\sum_t f_t f_t^\\top$ 为二阶矩矩阵。\n\n从条件 1：\n$$\n\\frac{1}{T} \\sum_{t=1}^{T} (a - b^\\top f_t) = \\frac{1}{R_f} \\implies a - b^\\top \\bar{f} = \\frac{1}{R_f} \\quad (*).\n$$\n从条件 2：\n$$\n\\frac{1}{T} \\sum_{t=1}^{T} (a - b^\\top f_t) f_t = \\vec{0} \\implies a \\bar{f} - \\overline{ff^\\top} b = \\vec{0} \\quad (**).\n$$\n由 $(*)$，我们可得 $a = \\frac{1}{R_f} + b^\\top \\bar{f}$。将其代入 $(**)$：\n$$\n\\left(\\frac{1}{R_f} + b^\\top \\bar{f}\\right) \\bar{f} - \\overline{ff^\\top} b = \\vec{0}\n$$\n$$\n\\frac{1}{R_f}\\bar{f} + (\\bar{f} \\bar{f}^\\top) b - \\overline{ff^\\top} b = \\vec{0}\n$$\n重新整理以求解 $b$：\n$$\n(\\overline{ff^\\top} - \\bar{f} \\bar{f}^\\top) b = \\frac{1}{R_f} \\bar{f}\n$$\n项 $(\\overline{ff^\\top} - \\bar{f} \\bar{f}^\\top)$ 正是因子的样本协方差矩阵 $\\Sigma_{ff}$。因此，我们得到一个关于向量 $b$ 的线性方程组：\n$$\n\\Sigma_{ff} b = \\frac{1}{R_f} \\bar{f}\n$$\n假设 $\\Sigma_{ff}$ 可逆，则可以求解该系统以得到 $b$。在确定 $b$ 之后，可从方程 $(*)$ 中求出 $a$。\n\n因子模型的流程为：\na. 根据提供的因子数据 $f_t$ 计算样本均值向量 $\\bar{f}$ 和样本协方差矩阵 $\\Sigma_{ff}$。\nb. 求解线性系统 $\\Sigma_{ff} b = \\frac{1}{R_f} \\bar{f}$，得到因子载荷向量 $b$。\nc. 计算截距 $a = \\frac{1}{R_f} + b^\\top \\bar{f}$。\nd. 构建 $t=1, \\dots, 8$ 的 SDF 时间序列 $m^F_t = a - b^\\top f_t$。\ne. 对于三个行业投资组合中的每一个（$i=1,2,3$），计算定价误差 $\\epsilon_i^F = \\frac{1}{T} \\sum_{t=1}^{T} m^F_t R_{i,t} - 1$。\nf. 计算 $\\text{RMSPE}^F = \\sqrt{\\frac{1}{3} \\sum_{i=1}^{3} (\\epsilon_i^F)^2}$。由于因子模型的参数不依赖于 $\\gamma$，此值对于所有三个测试用例将是相同的。\n\n最终输出将列出每个指定 $\\gamma$ 值对应的 $[\\text{RMSPE}^C, \\text{RMSPE}^F]$ 对。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and compares the Root Mean Squared Pricing Errors (RMSPE)\n    for a consumption-based SDF and a linear factor-based SDF.\n    \"\"\"\n    \n    # 1. Define Givens from the problem statement\n    \n    # Constants and parameters\n    T = 8\n    R_f = 1.0025\n    beta = 0.99\n    gammas = [0.0, 2.0, 6.0]\n\n    # Time series data as numpy arrays\n    # Factor excess returns, shape (T, 2)\n    factors = np.array([\n        [0.012, 0.008],\n        [0.005, -0.006],\n        [-0.010, 0.004],\n        [0.018, 0.011],\n        [-0.004, -0.003],\n        [0.009, 0.007],\n        [0.002, -0.002],\n        [0.015, 0.010]\n    ])\n\n    # Industry portfolio gross returns, shape (T, 3)\n    industry_returns = np.array([\n        [1.015, 1.012, 1.018],\n        [1.010, 1.008, 1.012],\n        [0.995, 0.992, 0.997],\n        [1.022, 1.018, 1.025],\n        [1.000, 0.998, 1.003],\n        [1.013, 1.009, 1.016],\n        [1.005, 1.004, 1.006],\n        [1.020, 1.017, 1.022]\n    ])\n\n    # Aggregate consumption growth, shape (T,)\n    cons_growth = np.array([1.003, 1.004, 0.999, 1.005, 1.001, 1.004, 1.002, 1.006])\n\n    def calculate_rmspe(m, R):\n        \"\"\"\n        Calculates the RMSPE given an SDF vector and a matrix of asset returns.\n        \n        Args:\n            m (np.ndarray): The SDF time series, shape (T,).\n            R (np.ndarray): The asset returns time series, shape (T, N_assets).\n            \n        Returns:\n            float: The root mean squared pricing error.\n        \"\"\"\n        # Reshape m to (T, 1) for broadcasting\n        m_reshaped = m[:, np.newaxis]\n        \n        # Calculate pricing products m*R for each asset and time point\n        pricing_products = m_reshaped * R\n        \n        # Compute sample mean of m*R for each asset\n        mean_pricing_products = np.mean(pricing_products, axis=0)\n        \n        # Calculate pricing errors (alpha)\n        pricing_errors = mean_pricing_products - 1.0\n        \n        # Calculate root mean squared pricing error\n        rmspe = np.sqrt(np.mean(pricing_errors**2))\n        \n        return rmspe\n\n    # 2. Compute parameters and RMSPE for the Linear Factor-Based SDF\n    \n    # Sample mean of factor excess returns\n    f_mean = np.mean(factors, axis=0)\n    \n    # Sample covariance matrix of factors (ddof=0 for population formula 1/T)\n    f_cov = np.cov(factors, rowvar=False, ddof=0)\n    \n    # Solve the system Sigma_ff * b = (1/R_f) * f_mean for b\n    b = np.linalg.solve(f_cov, f_mean / R_f)\n    \n    # Calculate the intercept a\n    a = 1.0 / R_f + np.dot(b, f_mean)\n    \n    # Construct the SDF time series for the factor model\n    m_factor = a - factors @ b\n    \n    # Calculate the RMSPE for the factor model\n    rmspe_factor = calculate_rmspe(m_factor, industry_returns)\n\n    # 3. Compute RMSPE for the Consumption-Based SDF for each gamma\n    \n    results = []\n    for gamma in gammas:\n        # Construct the SDF time series for the consumption model\n        m_consumption = beta * (cons_growth ** (-gamma))\n        \n        # Calculate the RMSPE for the consumption model\n        rmspe_consumption = calculate_rmspe(m_consumption, industry_returns)\n        \n        # Store the pair of results for this case\n        results.append([rmspe_consumption, rmspe_factor])\n\n    # 4. Format and print the final output\n    \n    formatted_results = []\n    for res_pair in results:\n        # Format each number to exactly six decimal places\n        formatted_pair = f'[{res_pair[0]:.6f},{res_pair[1]:.6f}]'\n        formatted_results.append(formatted_pair)\n        \n    # Join the formatted pairs into the final string\n    final_output = f\"[{','.join(formatted_results)}]\"\n    \n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "理论上，SDF应是总体财富的单调递减函数，反映了财富增加时边际效用的递减。然而，实证研究常常发现与此相悖的“定价核之谜”，本练习将引导您探索这一前沿问题 。您将运用最小范数法从资产收益中估计SDF，并检验其是否满足理论上的单调性，从而深入理解理论预测与实证结果之间的差距。",
            "id": "2421410",
            "problem": "要求您研究所谓的定价核之谜，通过检验经验估计的随机折现因子（也称为定价核）是否如具有凹效用的代表性代理人模型所预测的那样，随总财富单调递减。您必须实现一个完整的程序，该程序能从合成资产收益中估计随机折现因子，然后针对提供的测试套件评估其相对于总财富的单调性。\n\n从基本的跨期资产定价条件出发：对于每项总回报率为 $R_i$ 的资产 $i$，存在一个随机折现因子 $m$，使得样本欧拉方程成立：\n$$\n\\mathbb{E}[\\,m R_i\\,] = 1,\n$$\n其中 $\\mathbb{E}[\\cdot]$ 表示在有限数量的等可能状态下的经验期望。\n\n在一个有 $S$ 个状态的有限状态经济中，设 $m$ 由长度为 $S$ 的向量 $m = (m_1,\\dots,m_S)^\\top$ 表示，并且 $N$ 种资产的回报由 $S \\times N$ 矩阵 $R$ 给出，其 $(s,i)$ 项为 $R_{s,i}$。在所有状态概率相等 $p_s = 1/S$ 的情况下，对所有 $i \\in \\{1,\\dots,N\\}$ 的欧拉方程可以写成如下线性系统：\n$$\n\\frac{1}{S} R^\\top m = \\mathbf{1}_N,\n$$\n其中 $\\mathbf{1}_N$ 是长度为 $N$ 的全一向量。在所有满足该系统的 $m$ 中，将经验估计量定义为具有最小欧几里得范数的向量：\n$$\n\\text{find } m \\text{ that minimizes } \\|m\\|_2 \\text{ subject to } \\frac{1}{S} R^\\top m = \\mathbf{1}_N.\n$$\n\n您的程序必须：\n1. 对于下述每个测试用例，使用以下构造方法，从一个目标随机折现因子 $m^{\\star}$ 确定性地构造回报矩阵 $R$。固定 $S = 4$ 和 $N = 4$，并设 $\\epsilon = 0.45$。设 $\\mathbf{1}_4$ 为 4 维全一向量。定义四个方向向量 $v_j \\in \\mathbb{R}^4$，这些向量在标准点积下与 $m^{\\star}$ 正交，即对所有 $j \\in \\{1,2,3,4\\}$ 都有 $m^{\\star \\top} v_j = 0$。使用：\n   - $v_1 = (1,\\; -m^{\\star}_1/m^{\\star}_2,\\; 0,\\; 0)^\\top$，\n   - $v_2 = (1,\\; 0,\\; -m^{\\star}_1/m^{\\star}_3,\\; 0)^\\top$，\n   - $v_3 = (1,\\; 0,\\; 0,\\; -m^{\\star}_1/m^{\\star}_4)^\\top$，\n   - $v_4 = (0,\\; 1,\\; -m^{\\star}_2/m^{\\star}_3,\\; 0)^\\top$。\n   将每个回报列向量构造为\n   $$\n   R_{:,j} = \\mathbf{1}_4 + \\epsilon\\, v_j.\n   $$\n   这保证了对所有 $j$ 都有 $m^{\\star \\top} R_{:,j} = \\sum_{s=1}^4 m^{\\star}_s$。施加归一化条件 $\\sum_{s=1}^4 m^{\\star}_s = 4$，使得对每个 $j$ 都有 $m^{\\star \\top} R_{:,j} = 4$，从而使 $m^{\\star}$ 成为在等状态概率下欧拉方程的一个可行解。\n\n2. 给定 $R$，计算线性系统 $\\frac{1}{4} R^\\top m = \\mathbf{1}_4$ 的最小范数解 $\\hat m$。\n\n3. 对于每个测试用例中提供的总财富向量 $W \\in \\mathbb{R}^4$，按如下方式评估单调性。理论预测是随机折现因子随总财富递减。定义可比较的状态对集合\n   $$\n   \\mathcal{P} = \\{(i,j) \\in \\{1,2,3,4\\}^2 \\;|\\; i \\neq j, \\; W_i  W_j\\}.\n   $$\n   如果 $\\hat m_i \\ge \\hat m_j$，则一对 $(i,j) \\in \\mathcal{P}$ 构成一个违背。设 $V$ 为违背的数量，$T = |\\mathcal{P}|$ 为可比较对的数量。违背率定义为分数 $V/T$。使用数值容差 $\\tau = 10^{-10}$，因此不等式 $\\hat m_i \\ge \\hat m_j$ 被解释为 $\\hat m_i - \\hat m_j \\ge -\\tau$。\n\n4. 对每个测试用例，计算并报告违背率（作为一个实数）。最终输出必须是单行文本，包含所有测试用例的违背率列表，按顺序排列，用方括号括起并用逗号分隔，例如 $[0.0,0.5,0.0]$。打印时将每个违背率四舍五入到恰好六位小数。\n\n测试套件：\n- A例（严格递减的目标随机折现因子，与递增的财富一致）：\n  - 财富：$W = (0.9,\\; 1.0,\\; 1.1,\\; 1.2)^\\top$。\n  - 目标：$m^{\\star} = (1.4,\\; 1.1,\\; 0.8,\\; 0.7)^\\top$，其中 $\\sum_s m^{\\star}_s = 4$。\n- B例（驼峰形目标，意味着非单调性）：\n  - 财富：$W = (0.9,\\; 1.0,\\; 1.1,\\; 1.2)^\\top$。\n  - 目标：$m^{\\star} = (1.0,\\; 1.5,\\; 0.9,\\; 0.6)^\\top$，其中 $\\sum_s m^{\\star}_s = 4$。\n- C例（财富存在相同值；可比较对排除财富相等的状态）：\n  - 财富：$W = (1.0,\\; 1.0,\\; 1.2,\\; 1.3)^\\top$。\n  - 目标：$m^{\\star} = (1.1,\\; 1.3,\\; 0.9,\\; 0.7)^\\top$，其中 $\\sum_s m^{\\star}_s = 4$。\n- D例（近似单调，但有局部倒置）：\n  - 财富：$W = (0.9,\\; 1.0,\\; 1.1,\\; 1.2)^\\top$。\n  - 目标：$m^{\\star} = (1.2,\\; 0.98,\\; 1.0,\\; 0.82)^\\top$，其中 $\\sum_s m^{\\star}_s = 4$。\n\n您的程序应生成单行输出，其中包含四个违背率，按A、B、C、D的顺序，以逗号分隔的列表形式，并用方括号括起来。不允许有其他输出。所有计算都是无量纲的；不涉及任何物理单位或角度。",
            "solution": "在尝试任何解决方案之前，问题陈述都经过了严格的验证。一个问题必须是自洽的、科学上合理的、逻辑上一致的。\n\n首先，我们提取陈述中给出的信息和约束。\n给定信息：\n1.  **资产定价框架**：基本样本欧拉方程为 $\\mathbb{E}[\\,m R_i\\,] = 1$，适用于每项资产 $i$。其中 $m$ 是随机折现因子（SDF），$R_i$ 是总回报率。\n2.  **有限状态模型**：存在 $S$ 个状态和 $N$ 种资产。状态概率是均匀的，$p_s = 1/S$。回报由一个 $S \\times N$ 的矩阵 $R$ 给出。SDF 是一个向量 $m \\in \\mathbb{R}^S$。欧拉方程构成一个线性系统：$\\frac{1}{S} R^\\top m = \\mathbf{1}_N$。\n3.  **SDF 估计量**：经验 SDF 估计量 $\\hat m$ 定义为线性系统 $\\frac{1}{S} R^\\top m = \\mathbf{1}_N$ 的最小欧几里得范数解：最小化 $\\|m\\|_2$，约束条件为 $\\frac{1}{S} R^\\top m = \\mathbf{1}_N$。\n4.  **问题参数**：模型指定 $S=4$ 个状态和 $N=4$ 种资产。\n5.  **回报矩阵的构造**：回报矩阵 $R$ 是从满足归一化条件 $\\sum_{s=1}^4 m^{\\star}_s = 4$ 的目标 SDF $m^\\star \\in \\mathbb{R}^4$ 构造的。$R$ 的列由 $R_{:,j} = \\mathbf{1}_4 + \\epsilon v_j$ 给出（$j \\in \\{1,2,3,4\\}$），其中 $\\epsilon = 0.45$，向量 $v_j$ 被构造成与 $m^\\star$ 正交（$m^{\\star \\top} v_j = 0$）：\n    -   $v_1 = (1,\\; -m^{\\star}_1/m^{\\star}_2,\\; 0,\\; 0)^\\top$\n    -   $v_2 = (1,\\; 0,\\; -m^{\\star}_1/m^{\\star}_3,\\; 0)^\\top$\n    -   $v_3 = (1,\\; 0,\\; 0,\\; -m^{\\star}_1/m^{\\star}_4)^\\top$\n    -   $v_4 = (0,\\; 1,\\; -m^{\\star}_2/m^{\\star}_3,\\; 0)^\\top$\n6.  **单调性检验**：将估计的 SDF $\\hat m$ 与总财富向量 $W \\in \\mathbb{R}^4$ 进行单调性检验。\n    -   可比较的状态对集合为 $\\mathcal{P} = \\{(i,j) \\in \\{1,2,3,4\\}^2 \\;|\\; i \\neq j, \\; W_i  W_j\\}$。\n    -   对于一对 $(i,j) \\in \\mathcal{P}$，如果 $\\hat m_i \\ge \\hat m_j$，则发生违背。\n    -   检验的数值容差为 $\\tau = 10^{-10}$，因此如果 $\\hat m_i - \\hat m_j \\ge -\\tau$，则记录为一次违背。\n    -   违背率为 $V/T$，其中 $V$ 是违背次数，$T=|\\mathcal{P}|$。\n7.  **测试套件**：\n    -   A例：$W = (0.9,\\; 1.0,\\; 1.1,\\; 1.2)^\\top$, $m^{\\star} = (1.4,\\; 1.1,\\; 0.8,\\; 0.7)^\\top$。\n    -   B例：$W = (0.9,\\; 1.0,\\; 1.1,\\; 1.2)^\\top$, $m^{\\star} = (1.0,\\; 1.5,\\; 0.9,\\; 0.6)^\\top$。\n    -   C例：$W = (1.0,\\; 1.0,\\; 1.2,\\; 1.3)^\\top$, $m^{\\star} = (1.1,\\; 1.3,\\; 0.9,\\; 0.7)^\\top$。\n    -   D例：$W = (0.9,\\; 1.0,\\; 1.1,\\; 1.2)^\\top$, $m^{\\star} = (1.2,\\; 0.98,\\; 1.0,\\; 0.82)^\\top$。\n\n基于这些给定信息的验证证实了该问题在资产定价理论方面有科学依据，是客观且适定的。回报矩阵 $R$ 的构造保证了关于 $m$ 的线性系统是相容的，因为目标 $m^\\star$ 是一个可行解。这确保了唯一的最小范数解的存在。所有必需的数据和定义都已提供。该问题被认为是有效的。我们着手进行求解。\n\n问题的核心是解决以下约束优化问题：\n$$\n\\text{minimize } \\frac{1}{2} m^\\top m \\quad \\text{subject to} \\quad A m = b\n$$\n其中 $A = \\frac{1}{S} R^\\top$ 是一个 $N \\times S$ 矩阵，$m \\in \\mathbb{R}^S$，$b = \\mathbf{1}_N \\in \\mathbb{R}^N$。对于此问题，我们有 $S=N=4$。\n\n一个相容线性系统 $Am=b$ 的唯一最小范数解由 $\\hat m = A^\\dagger b$ 给出，其中 $A^\\dagger$ 是 $A$ 的 Moore-Penrose 伪逆。这个线性代数的结果为计算估计的SDF $\\hat m$ 提供了一个直接的方法。\n\n每个测试用例的步骤如下：\n\n1.  **构造回报矩阵 $R$**：\n    对于给定的测试用例，其目标 SDF 为 $m^\\star = (m^\\star_1, m^\\star_2, m^\\star_3, m^\\star_4)^\\top$，我们首先根据指定公式构造四个辅助向量 $v_1, v_2, v_3, v_4 \\in \\mathbb{R}^4$。所有测试用例中 $m^\\star$ 的分量均非零，因此 $v_j$ 的定义是良定义的。然后我们构成一个 $4 \\times 4$ 的矩阵 $V = [v_1, v_2, v_3, v_4]$，其列是这些向量。然后组装 $4 \\times 4$ 的回报矩阵 $R$。$R$ 的第 $j$ 列是 $R_{:,j} = \\mathbf{1}_4 + \\epsilon v_j$，其中 $\\mathbf{1}_4$ 是全一向量，$\\epsilon = 0.45$。这可以紧凑地写成 $R = J + \\epsilon V$，其中 $J$ 是 $4 \\times 4$ 的全一矩阵。\n\n2.  **估计随机折现因子 $\\hat m$**：\n    构造好 $R$ 后，我们形成矩阵 $A = \\frac{1}{4}R^\\top$。待解的系统是 $Am = \\mathbf{1}_4$。我们计算 Moore-Penrose 伪逆 $A^\\dagger$，然后得到估计的 SDF 为 $\\hat m = A^\\dagger \\mathbf{1}_4$。必须强调的是，最小范数解 $\\hat m$ 通常不等于目标向量 $m^\\star$。向量 $m^\\star$ 只是解的仿射子空间中的一个点，而 $\\hat m$ 是该子空间中离原点最近的唯一元素。\n\n3.  **评估单调性并计算违背率**：\n    给定财富向量 $W = (W_1, W_2, W_3, W_4)^\\top$ 和估计的 SDF $\\hat m = (\\hat m_1, \\hat m_2, \\hat m_3, \\hat m_4)^\\top$，我们必须评估 $\\hat m$ 是否是 $W$ 的递减函数。我们遍历所有不同的状态索引对 $(i, j)$，其中 $i,j \\in \\{1, 2, 3, 4\\}$。\n    -   我们首先计算可比较对的总数 $T$。如果 $W_i  W_j$，则一对 $(i, j)$ 是可比较的。我们找到所有这样的有序对。\n    -   _请注意，在实现中我们使用从0开始的索引，因此我们比较的是 $i,j \\in \\{0, 1, 2, 3\\}$ 的 $W_i$ 和 $W_j$。_\n    -   对于每个 $W_i  W_j$ 的可比较对，我们检查是否存在单调性违背。如果 SDF 不是严格递减的，即 $\\hat m_i \\ge \\hat m_j$，则定义为发生了一次违背。我们使用提供的数值容差 $\\tau = 10^{-10}$ 来实现此检查，即 $\\hat m_i - \\hat m_j \\ge -\\tau$。\n    -   我们计算此类违背的总数 $V$。\n    -   违背率是比率 $V/T$。如果 $T=0$，则比率为 $0$。\n\n整个过程被封装在一个程序中，该程序为每个测试用例计算并报告违背率，四舍五入到六位小数。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the pricing kernel puzzle problem for a suite of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: Strictly decreasing target SDF\n        {\n            \"W\": np.array([0.9, 1.0, 1.1, 1.2]),\n            \"m_star\": np.array([1.4, 1.1, 0.8, 0.7]),\n        },\n        # Case B: Hump-shaped target SDF\n        {\n            \"W\": np.array([0.9, 1.0, 1.1, 1.2]),\n            \"m_star\": np.array([1.0, 1.5, 0.9, 0.6]),\n        },\n        # Case C: Ties in wealth\n        {\n            \"W\": np.array([1.0, 1.0, 1.2, 1.3]),\n            \"m_star\": np.array([1.1, 1.3, 0.9, 0.7]),\n        },\n        # Case D: Near-monotone target SDF\n        {\n            \"W\": np.array([0.9, 1.0, 1.1, 1.2]),\n            \"m_star\": np.array([1.2, 0.98, 1.0, 0.82]),\n        },\n    ]\n\n    results = []\n    \n    # Constants from the problem statement\n    S = 4\n    N = 4\n    epsilon = 0.45\n    tau = 1e-10\n\n    for case in test_cases:\n        W = case[\"W\"]\n        m_star = case[\"m_star\"]\n\n        # 1. Construct the returns matrix R\n        # Define the orthogonal vectors v_j\n        # Indices are 0-based for array access.\n        v1 = np.array([1.0, -m_star[0] / m_star[1], 0.0, 0.0])\n        v2 = np.array([1.0, 0.0, -m_star[0] / m_star[2], 0.0])\n        v3 = np.array([1.0, 0.0, 0.0, -m_star[0] / m_star[3]])\n        v4 = np.array([0.0, 1.0, -m_star[1] / m_star[2], 0.0])\n        \n        # Stack vectors into a matrix V\n        V = np.column_stack([v1, v2, v3, v4])\n        \n        # Construct R = J + epsilon * V, where J is a matrix of ones\n        R = np.ones((S, N)) + epsilon * V\n\n        # 2. Compute the minimum-norm SDF estimator m_hat\n        # System is (1/S) * R^T * m = 1_N\n        A = (1 / S) * R.T\n        b = np.ones(N)\n        \n        # The minimum-norm solution is m_hat = A_pinv * b\n        A_pinv = np.linalg.pinv(A)\n        m_hat = A_pinv @ b\n\n        # 3. Evaluate monotonicity and compute violation rate\n        num_comparable_pairs = 0\n        num_violations = 0\n        \n        for i in range(S):\n            for j in range(S):\n                if i == j:\n                    continue\n                \n                # A pair is comparable if wealth levels are different\n                if W[i] > W[j]:\n                    num_comparable_pairs += 1\n                    # A violation occurs if SDF is not strictly decreasing\n                    if m_hat[i] - m_hat[j] >= -tau:\n                        num_violations += 1\n        \n        if num_comparable_pairs == 0:\n            violation_rate = 0.0\n        else:\n            violation_rate = num_violations / num_comparable_pairs\n            \n        results.append(f\"{violation_rate:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}