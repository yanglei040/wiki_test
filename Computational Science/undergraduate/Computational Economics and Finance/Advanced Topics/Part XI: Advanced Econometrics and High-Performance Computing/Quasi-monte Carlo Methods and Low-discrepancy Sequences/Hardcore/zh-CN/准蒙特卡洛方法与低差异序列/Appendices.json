{
    "hands_on_practices": [
        {
            "introduction": "要体会拟蒙特卡洛（Quasi-Monte Carlo, QMC）方法的实际优势，最有效的方式是将其与其他数值积分技术进行直接比较。第一个练习  将引导你完成一个经典的基准测试，比较 QMC、标准蒙特卡洛（MC）方法以及简单的网格黎曼求和。通过对一个周期函数进行积分，你不仅能观察到 QMC 的优越收敛速度，还将发现网格方法的一个致命弱点——共振现象。",
            "id": "2424669",
            "problem": "考虑一个二元函数 $f:[0,1]^2 \\to \\mathbb{R}$，其定义为 $f(x,y)=\\cos(20\\pi x)+\\cos(20\\pi y)$，其中余弦函数以弧度为单位进行计算。目标是数值近似积分\n$$I=\\int_0^1\\int_0^1 f(x,y)\\,dx\\,dy,$$\n比较三种估计量产生的绝对积分误差，并报告一组指定样本大小下的结果。\n\n对于给定的样本大小 $N\\in\\mathbb{N}$，定义以下三种 $I$ 的估计量：\n- 蒙特卡洛 (MC, Monte Carlo)：抽取 $N$ 个独立样本 $(X_i,Y_i)$，其中 $(X_i,Y_i)\\sim \\text{Uniform}([0,1]^2)$，并使用以下估计量\n$$\\widehat{I}_{\\text{MC},N}=\\frac{1}{N}\\sum_{i=1}^N f(X_i,Y_i).$$\n- 拟蒙特卡洛 (QMC, Quasi-Monte Carlo)：使用二维 Sobol 低差异序列（不加扰）在 $[0,1]^2$ 上的前 $N$ 个点 $(u_i,v_i)$，并使用以下估计量\n$$\\widehat{I}_{\\text{QMC},N}=\\frac{1}{N}\\sum_{i=1}^N f(u_i,v_i).$$\n- 均匀网格上的二维黎曼和：假设 $N=n^2$ 且 $n\\in\\mathbb{N}$，并构成一个由左端点节点组成的均匀 $n\\times n$ 网格\n$$\\Big\\{\\Big(\\frac{i}{n},\\frac{j}{n}\\Big): i=0,1,\\dots,n-1,\\; j=0,1,\\dots,n-1\\Big\\}.$$\n使用以下估计量\n$$\\widehat{I}_{\\text{Grid},N}=\\frac{1}{n^2}\\sum_{i=0}^{n-1}\\sum_{j=0}^{n-1} f\\Big(\\frac{i}{n},\\frac{j}{n}\\Big).$$\n\n您的程序必须：\n- 使用由 $f$ 在 $[0,1]^2$ 上的定义所蕴含的 $I$ 的精确值来计算误差。\n- 对于 MC，使用固定的伪随机种子 $2025$ 以确保可复现性。\n- 对于 QMC，使用二维 Sobol 序列（不加扰），按顺序取前 $N$ 个点，从索引 0 开始。\n- 对于基于网格的黎曼和，仅当 $N$ 是一个完全平方数时才应用它。\n\n对于测试集中的每个 $N$，计算绝对误差\n$$E_{\\text{MC}}(N)=\\big|\\widehat{I}_{\\text{MC},N}-I\\big|,\\quad E_{\\text{QMC}}(N)=\\big|\\widehat{I}_{\\text{QMC},N}-I\\big|,\\quad E_{\\text{Grid}}(N)=\\big|\\widehat{I}_{\\text{Grid},N}-I\\big|.$$\n\n测试集：\n- $N\\in\\{1,4,25,100,400\\}$，对于网格估计量，这对应于网格大小 $n\\in\\{1,2,5,10,20\\}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个列表的列表形式的结果。每个内部列表按 $N\\in[1,4,25,100,400]$ 的顺序对应一个 $N$ 值，并按固定顺序 $[E_{\\text{MC}}(N),E_{\\text{QMC}}(N),E_{\\text{Grid}}(N)]$ 包含三个误差。\n- 每个浮点数打印时小数点后必须保留恰好 $8$ 位数字。\n- 打印的行中任何位置都不能有空格。\n- 因此，输出的形式为单行的 Python 风格的列表的列表，其中所有条目都格式化为 8 位小数。",
            "solution": "所述问题具有科学依据、良构、客观且完整。这是计算数学中的一个标准练习，旨在比较蒙特卡洛、拟蒙特卡洛和确定性的基于网格的数值积分方法的性能。所有提供的信息对于获得唯一解是充分且一致的。因此，该问题是有效的。\n\n目标是计算函数 $f(x,y)=\\cos(20\\pi x)+\\cos(20\\pi y)$ 的积分 $I = \\int_0^1\\int_0^1 f(x,y)\\,dx\\,dy$ 的三种不同数值估计量的绝对积分误差。\n\n首先，我们必须确定积分 $I$ 的精确值。根据积分的线性性质，我们可以将积分分离：\n$$I = \\int_0^1\\int_0^1 \\left(\\cos(20\\pi x)+\\cos(20\\pi y)\\right)\\,dx\\,dy = \\int_0^1\\int_0^1 \\cos(20\\pi x)\\,dx\\,dy + \\int_0^1\\int_0^1 \\cos(20\\pi y)\\,dx\\,dy$$\n让我们计算第一项：\n$$ \\int_0^1\\int_0^1 \\cos(20\\pi x)\\,dx\\,dy = \\int_0^1 \\left[ \\frac{\\sin(20\\pi x)}{20\\pi} \\right]_{x=0}^{x=1} \\,dy = \\int_0^1 \\left( \\frac{\\sin(20\\pi \\cdot 1) - \\sin(20\\pi \\cdot 0)}{20\\pi} \\right) \\,dy $$\n由于 $\\sin(20\\pi) = 0$ 且 $\\sin(0) = 0$，内部积分的计算结果为 $0$。因此，整个第一项为 $\\int_0^1 0 \\,dy = 0$。\n根据对称性，第二项也为零：\n$$ \\int_0^1\\int_0^1 \\cos(20\\pi y)\\,dx\\,dy = \\int_0^1 \\cos(20\\pi y) \\left[ x \\right]_{x=0}^{x=1} \\,dy = \\int_0^1 \\cos(20\\pi y) \\,dy = \\left[ \\frac{\\sin(20\\pi y)}{20\\pi} \\right]_{y=0}^{y=1} = 0 $$\n因此，积分的精确值为 $I = 0 + 0 = 0$。任何估计量 $\\widehat{I}$ 的绝对误差因此就是其绝对值，$E = |\\widehat{I} - I| = |\\widehat{I}|$。\n\n求解过程涉及为集合 $\\{1, 4, 25, 100, 400\\}$ 中的每个样本大小 $N$ 实现三种估计量。\n\n1.  **蒙特卡洛 (MC) 估计量：**对于每个 $N$，我们在单位正方形 $[0,1]^2$ 内生成 $N$ 个独立且均匀分布的随机点 $(X_i, Y_i)$。使用固定种子 $2025$ 的伪随机数生成器以确保可复现性。估计值为这些点上函数值的样本均值：\n    $$\\widehat{I}_{\\text{MC},N}=\\frac{1}{N}\\sum_{i=1}^N f(X_i,Y_i)$$\n\n2.  **拟蒙特卡洛 (QMC) 估计量：**对于每个 $N$，我们使用二维 Sobol 低差异序列的前 $N$ 个点 $(u_i,v_i)$。这些点是确定性生成的，并且被设计用来比伪随机点更均匀地覆盖单位正方形。为确保每个测试用例都使用“前 $N$ 个点”，我们生成一个所需最大长度（$N=400$）的序列，并为每个 $N$ 使用该序列的适当前缀。估计值为样本均值：\n    $$\\widehat{I}_{\\text{QMC},N}=\\frac{1}{N}\\sum_{i=1}^N f(u_i,v_i)$$\n\n3.  **基于网格的黎曼和估计量：**此方法应用于 $N=n^2$，其中 $n \\in \\{1, 2, 5, 10, 20\\}$。构建一个由点 $(\\frac{i}{n}, \\frac{j}{n})$ 组成的均匀 $n \\times n$ 网格，其中 $i,j \\in \\{0, 1, \\dots, n-1\\}$。估计值为该网格上函数值的均值：\n    $$\\widehat{I}_{\\text{Grid},N}=\\frac{1}{n^2}\\sum_{i=0}^{n-1}\\sum_{j=0}^{n-1} f\\Big(\\frac{i}{n},\\frac{j}{n}\\Big)$$\n    对于给定函数，分析此估计量的行为非常重要。该和可以简化为：\n    $$\\widehat{I}_{\\text{Grid},N} = \\frac{1}{n^2} \\sum_{i=0}^{n-1}\\sum_{j=0}^{n-1} \\left( \\cos\\left(\\frac{20\\pi i}{n}\\right) + \\cos\\left(\\frac{20\\pi j}{n}\\right) \\right) = \\frac{2}{n}\\sum_{k=0}^{n-1} \\cos\\left(\\frac{20\\pi k}{n}\\right)$$\n    如果 $10/n$ 是一个整数，则项 $20\\pi/n$ 是 $2\\pi$ 的倍数。这对 $n \\in \\{1, 2, 5, 10\\}$ 成立。对于这些值，每一项 $\\cos(20\\pi k/n) = \\cos(2\\pi \\cdot (\\text{整数}) \\cdot k) = 1$。和为 $n$，估计量变为 $\\widehat{I}_{\\text{Grid},N} = \\frac{2}{n} \\cdot n = 2$。误差为 $|\\widehat{I}_{\\text{Grid},N}| = 2$。\n    对于 $n=20$，自变量为 $\\cos(\\pi k)$，求和 $\\sum_{k=0}^{19} \\cos(\\pi k) = 1-1+1-1+\\dots+1-1=0$。估计量及其误差均为 $0$。这个特定的函数选择突显了一种共振现象，即均匀网格的性能可能非常差，也可能完美，这取决于其与函数周期性的对齐情况。\n\n程序为每个 $N$ 计算这三种估计值，计算绝对误差，并按规定格式化结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import qmc\n\ndef solve():\n    \"\"\"\n    Computes and compares absolute integration errors for MC, QMC, and Grid estimators.\n    \"\"\"\n    # The exact value of the integral is I=0.\n    I_exact = 0.0\n\n    # Define the bivariate function to be integrated.\n    def f(x, y):\n        \"\"\"\n        Calculates f(x,y) = cos(20*pi*x) + cos(20*pi*y).\n        x and y can be scalars or numpy arrays.\n        \"\"\"\n        return np.cos(20 * np.pi * x) + np.cos(20 * np.pi * y)\n\n    # Define the test suite for sample sizes N.\n    test_cases = [\n        (1, 1),\n        (4, 2),\n        (25, 5),\n        (100, 10),\n        (400, 20),\n    ]\n\n    seed = 2025\n    rng = np.random.default_rng(seed)\n\n    # Pre-generate all required Sobol points to ensure \"first N\" rule is followed.\n    max_N = test_cases[-1][0]\n    sobol_engine = qmc.Sobol(d=2, scramble=False)\n    all_qmc_points = sobol_engine.random(max_N)\n\n    results = []\n    for N, n in test_cases:\n        # --- 1. Monte Carlo (MC) Estimator ---\n        # Generate N fresh random points for each N.\n        mc_points = rng.random((N, 2))\n        f_values_mc = f(mc_points[:, 0], mc_points[:, 1])\n        I_hat_mc = np.mean(f_values_mc)\n        error_mc = np.abs(I_hat_mc - I_exact)\n\n        # --- 2. Quasi-Monte Carlo (QMC) Estimator ---\n        # Use the first N points from the pre-generated sequence.\n        qmc_points = all_qmc_points[:N]\n        f_values_qmc = f(qmc_points[:, 0], qmc_points[:, 1])\n        I_hat_qmc = np.mean(f_values_qmc)\n        error_qmc = np.abs(I_hat_qmc - I_exact)\n\n        # --- 3. Grid-based Riemann Sum Estimator ---\n        # Generate an n x n grid of left-endpoints.\n        grid_coords = np.arange(n) / n\n        x_grid, y_grid = np.meshgrid(grid_coords, grid_coords)\n        f_values_grid = f(x_grid, y_grid)\n        I_hat_grid = np.mean(f_values_grid)\n        error_grid = np.abs(I_hat_grid - I_exact)\n\n        results.append([error_mc, error_qmc, error_grid])\n\n    # Format the output string according to the specified rules:\n    # A list of lists, with each number formatted to 8 decimal places,\n    # and no spaces in the entire output string.\n    formatted_rows = [\n        f\"[{','.join([f'{err:.8f}' for err in row])}]\"\n        for row in results\n    ]\n    final_output = f\"[{','.join(formatted_rows)}]\"\n\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "尽管 QMC 方法通常优于标准蒙特卡洛方法，但其优势并非无条件的。本练习  旨在探讨 QMC 的一个关键局限性：其性能对被积函数与坐标轴的对齐方式非常敏感。你将通过一个正交变换来“旋转”问题，从而观察到即使积分的真值保持不变，这种变换如何增加了函数的“有效维度”并导致 QMC 的性能下降。",
            "id": "2424673",
            "problem": "给定一个基于模拟的积分任务，该任务在一个与计算经济学和金融学相关的场景中，比较标准蒙特卡洛方法和拟蒙特卡洛方法。考虑一个被积函数在多元标准正态分布下的期望，并研究变量的正交旋转如何改变被积函数的轴对齐性，以及当函数是轴对齐时，这种旋转如何消除拟蒙特卡洛方法的典型优势。\n\n令 $d \\in \\mathbb{N}$ 为维度，令 $\\boldsymbol{Z} \\sim \\mathcal{N}(\\boldsymbol{0}, \\mathbf{I}_d)$ 为一个 $d$ 维标准正态随机向量，并令 $\\mathbf{Q} \\in \\mathbb{R}^{d \\times d}$ 为一个满足 $\\mathbf{Q}^\\top \\mathbf{Q} = \\mathbf{I}_d$ 的正交矩阵。定义被积函数\n$$\nf_{\\lambda,\\mathbf{Q}}(\\boldsymbol{z}) = \\exp\\!\\left(\\lambda \\, (\\mathbf{Q}\\boldsymbol{z})_1\\right),\n$$\n其中 $(\\mathbf{Q}\\boldsymbol{z})_1$ 表示旋转后向量 $\\mathbf{Q}\\boldsymbol{z}$ 的第一个分量，$\\lambda \\in \\mathbb{R}$ 是一个固定标量。由于多元正态分布在正交变换下是不变的，我们感兴趣的积分是\n$$\nI(\\lambda) = \\mathbb{E}\\!\\left[f_{\\lambda,\\mathbf{Q}}(\\boldsymbol{Z})\\right] = \\mathbb{E}\\!\\left[\\exp\\!\\left(\\lambda \\, (\\mathbf{Q}\\boldsymbol{Z})_1\\right)\\right] = \\exp\\!\\left(\\tfrac{1}{2}\\lambda^2\\right),\n$$\n该值不依赖于 $\\mathbf{Q}$。\n\n你的任务是编写一个完整、可运行的程序，以经验性地比较以下两种方法的绝对积分误差：\n- 拟蒙特卡洛法：使用 Sobol 低差异序列，通过标准正态累积分布函数的逆函数映射到独立的标准正态坐标。\n- 标准蒙特卡洛法：使用独立的伪随机标准正态抽样。\n\n比较是在不同的正交矩阵 $\\mathbf{Q}$（它们旋转和混合坐标）下进行的。为标准蒙特卡洛法使用固定种子以确保可复现性。为 Sobol 序列使用加扰和固定种子，以避免标准正态逆映射在 $0$ 和 $1$ 处的边界问题。\n\n你可以依赖的基本定义包括：期望作为积分的定义、$\\mathcal{N}(\\boldsymbol{0}, \\mathbf{I}_d)$ 在正交变换下的不变性，以及通过累积分布函数的逆函数将均匀随机变量映射到正态随机变量。除这些之外，不要假设任何未经证明的捷径。\n\n实现要求：\n- 使用 Sobol 序列生成 $n$ 个在 $[0,1]^d$ 中的样本点，用固定种子对它们进行加扰，并通过标准正态累积分布函数的逆函数将它们逐坐标地变换到 $\\mathbb{R}^d$ 中，以获得拟蒙特卡洛样本。独立地，使用带有固定种子的伪随机数生成器生成 $n$ 个独立的 $d$ 维标准正态样本。\n- 将正交变换 $\\mathbf{Q}$ 应用于每个 $d$ 维样本，并计算 $f_{\\lambda,\\mathbf{Q}}$。\n- 使用每种方法下的样本均值来估计 $I(\\lambda)$，并计算相对于精确值 $\\exp\\!\\left(\\tfrac{1}{2}\\lambda^2\\right)$ 的绝对误差。\n- 对每个测试用例，报告一个定义如下的比率\n$$\nr = \\frac{\\left|\\widehat{I}_{\\mathrm{QMC}} - I(\\lambda)\\right|}{\\max\\!\\left(\\left|\\widehat{I}_{\\mathrm{MC}} - I(\\lambda)\\right|, \\varepsilon\\right)},\n$$\n其中 $\\varepsilon = 10^{-16}$ 以避免除以零。比率 $r < 1$ 表明在该测试中拟蒙特卡洛方法优于标准蒙特卡洛方法；比率 $r > 1$ 则相反。角度（如果存在）必须以弧度解释。\n\n要使用的正交矩阵：\n- 对于前两个坐标中按角度 $\\theta$ 进行的平面旋转，通过将 $2 \\times 2$ 旋转矩阵\n$$\n\\mathbf{R}(\\theta) = \\begin{pmatrix} \\cos\\theta & -\\sin\\theta\\\\ \\sin\\theta & \\cos\\theta \\end{pmatrix}\n$$\n嵌入到 $\\mathbf{Q}$ 的左上角块中，并将其余对角线元素设为 $1$、非对角线元素设为 $0$ 来定义 $\\mathbf{Q}$。\n- 对于在第一个输出坐标中均匀混合所有坐标的 Householder 反射，取 $\\boldsymbol{v} = \\tfrac{1}{\\sqrt{d}}(1,1,\\dots,1)^\\top \\in \\mathbb{R}^d$ 并定义\n$$\n\\mathbf{Q} = \\mathbf{I}_d - 2 \\,\\boldsymbol{u}\\boldsymbol{u}^\\top, \\quad \\boldsymbol{u} = \\frac{\\boldsymbol{e}_1 - \\boldsymbol{v}}{\\lVert \\boldsymbol{e}_1 - \\boldsymbol{v}\\rVert_2},\n$$\n其中 $\\boldsymbol{e}_1$ 是第一个标准基向量。这种选择确保了 $(\\mathbf{Q}\\boldsymbol{z})_1 = \\boldsymbol{v}^\\top \\boldsymbol{z}$，因此被积函数依赖于所有坐标的等权重线性组合。\n\n固定参数：\n- 使用 $\\lambda = 0.5$。\n- 使用标准蒙特卡洛种子 $42$。\n- 使用 Sobol 加扰种子 $7$。\n\n测试套件：\n- 案例 1：$d = 8$, $n = 4096$，平面旋转，$\\theta = 0$ (轴对齐)。\n- 案例 2：$d = 8$, $n = 4096$，平面旋转，$\\theta = \\pi/4$ (混合两个坐标)。\n- 案例 3：$d = 32$, $n = 4096$，Householder 反射，$\\boldsymbol{v} = \\tfrac{1}{\\sqrt{d}}(1,\\dots,1)^\\top$ (在第一个输出中最大程度地混合所有坐标)。\n- 案例 4：$d = 8$, $n = 64$，平面旋转，$\\theta = 0$ (小样本量边界)。\n- 案例 5：$d = 8$, $n = 64$，平面旋转，$\\theta = \\pi/4$ (混合的小样本量)。\n\n要求的最终输出格式：\n- 你的程序应生成一行输出，其中包含上述案例的比率 $r$，格式为用方括号括起来的逗号分隔列表，顺序与测试用例相同，每个比率四舍五入到 $6$ 位小数（例如，$\\left[0.123456,0.654321\\right]$）。不应打印任何额外文本。",
            "solution": "问题陈述已经过验证，被认为是有效的。它具有科学依据，问题定义明确，并包含获得唯一、可复现解所需的所有必要信息。其所依据的数学前提，特别是积分的解析值和指定正交变换的性质，是正确的。该任务是一个标准的数值实验，旨在比较拟蒙特卡洛积分和标准蒙特卡洛积分的性能，这是计算数学及其在金融中应用的经典问题。因此，我们将着手求解。\n\n目标是计算使用拟蒙特卡洛（QMC）方法和标准蒙特卡洛（MC）方法估计一个函数在多元标准正态分布下的期望时产生的绝对误差之比。我们感兴趣的积分是\n$$\nI(\\lambda) = \\mathbb{E}_{\\boldsymbol{Z} \\sim \\mathcal{N}(\\boldsymbol{0}, \\mathbf{I}_d)}\\!\\left[f_{\\lambda,\\mathbf{Q}}(\\boldsymbol{Z})\\right] = \\mathbb{E}\\!\\left[\\exp\\!\\left(\\lambda \\, (\\mathbf{Q}\\boldsymbol{Z})_1\\right)\\right]\n$$\n其中 $\\boldsymbol{Z}$ 是一个 $d$ 维标准正态随机向量，$\\mathbf{Q}$ 是一个 $d \\times d$ 的正交矩阵，$(\\mathbf{Q}\\boldsymbol{Z})_1$ 是变换后向量的第一个分量。由于多元标准正态分布在正交变换下是不变的，向量 $\\boldsymbol{Y} = \\mathbf{Q}\\boldsymbol{Z}$ 也服从 $\\mathcal{N}(\\boldsymbol{0}, \\mathbf{I}_d)$ 分布。因此，它的第一个分量 $Y_1 = (\\mathbf{Q}\\boldsymbol{Z})_1$ 是一个标准正态随机变量，$Y_1 \\sim \\mathcal{N}(0, 1)$。因此，该期望是标准正态变量在 $\\lambda$ 点的矩生成函数，其具有已知的闭式解：\n$$\nI(\\lambda) = \\mathbb{E}\\!\\left[\\exp(\\lambda Y_1)\\right] = \\exp\\!\\left(\\tfrac{1}{2}\\lambda^2\\right)\n$$\n该值可作为计算积分误差的基准真相。对于给定的参数 $\\lambda = 0.5$，精确值为 $I(0.5) = \\exp\\!\\left(\\tfrac{1}{2}(0.5)^2\\right) = \\exp(0.125)$。\n\n该期望通过将积分近似为 $n$ 个点的样本均值来进行数值估计：\n$$\n\\widehat{I} = \\frac{1}{n} \\sum_{i=1}^{n} \\exp\\!\\left(\\lambda \\, (\\mathbf{Q}\\boldsymbol{z}_i)_1\\right)\n$$\n这种近似的有效性取决于样本点 $\\boldsymbol{z}_i$ 的选择。我们比较两种生成这些点的方法。\n\n首先，标准蒙特卡洛（MC）方法使用伪随机数生成器从目标分布 $\\mathcal{N}(\\boldsymbol{0}, \\mathbf{I}_d)$ 中生成 $n$ 个独立同分布的样本 $\\boldsymbol{z}_i$。固定的种子确保了可复现性。\n\n其次，拟蒙特卡洛（QMC）方法旨在通过使用确定性的、比伪随机点更均匀地覆盖积分域的低差异序列来改善收敛性。这里，我们使用 Sobol 序列在 $d$ 维单位超立方体 $[0,1]^d$ 中生成 $n$ 个点。这些点使用固定种子进行加扰以改善其统计特性。然后，这些均匀点的每个坐标 $u_{i,j}$ 通过标准正态分布的逆累积分布函数（CDF）（也称为概率单位函数）变换为标准正态坐标 $z_{i,j}$：$z_{i,j} = \\Phi^{-1}(u_{i,j})$。\n\n这个问题的核心是分析被积函数的结构对 QMC 性能的影响。被积函数 $f_{\\lambda,\\mathbf{Q}}(\\boldsymbol{z})$ 仅通过线性组合 $(\\mathbf{Q}\\boldsymbol{z})_1 = \\sum_{j=1}^d Q_{1j} z_j$ 依赖于 $\\boldsymbol{z}$。当函数最重要的维度与低差异序列的前几个轴对齐时，QMC 的效率通常最高。通过应用正交变换 $\\mathbf{Q}$，我们改变了这种对齐方式。\n\n我们考虑两种类型的正交矩阵：\n1.  平面旋转，它混合前两个坐标。当旋转角度 $\\theta=0$ 时，$\\mathbf{Q}=\\mathbf{I}_d$，被积函数变为 $\\exp(\\lambda z_1)$，仅依赖于第一个坐标。这对 QMC 来说是一个理想的、“轴对齐”的案例。当 $\\theta$ 增加到 $\\pi/4$ 时，被积函数变为依赖于 $z_1$ 和 $z_2$ 的均等混合，这通常会降低 QMC 的性能。该矩阵为 $\\mathbf{Q} = \\begin{pmatrix} \\mathbf{R}(\\theta) & \\mathbf{0} \\\\ \\mathbf{0} & \\mathbf{I}_{d-2} \\end{pmatrix}$，其中 $\\mathbf{R}(\\theta) = \\begin{pmatrix} \\cos\\theta & -\\sin\\theta \\\\ \\sin\\theta & \\cos\\theta \\end{pmatrix}$。\n\n2.  旨在最大程度混合所有坐标的 Householder 反射。该矩阵由 $\\mathbf{Q} = \\mathbf{I}_d - 2 \\boldsymbol{u}\\boldsymbol{u}^\\top$ 给出，其中 $\\boldsymbol{u} = \\frac{\\boldsymbol{e}_1 - \\boldsymbol{v}}{\\lVert \\boldsymbol{e}_1 - \\boldsymbol{v}\\rVert_2}$，$\\boldsymbol{v} = \\frac{1}{\\sqrt{d}}(1, \\dots, 1)^\\top$。此变换的构造使得 $\\mathbf{Q}$ 将 $\\boldsymbol{e}_1$ 映射到 $\\boldsymbol{v}$。由于 $\\mathbf{Q}$ 是对称且正交的（$\\mathbf{Q}^\\top = \\mathbf{Q} = \\mathbf{Q}^{-1}$），因此有 $(\\mathbf{Q}\\boldsymbol{z})_1 = \\boldsymbol{e}_1^\\top \\mathbf{Q} \\boldsymbol{z} = (\\mathbf{Q}^\\top \\boldsymbol{e}_1)^\\top \\boldsymbol{z} = (\\mathbf{Q} \\boldsymbol{e}_1)^\\top \\boldsymbol{z} = \\boldsymbol{v}^\\top \\boldsymbol{z}$。被积函数变为 $\\exp\\!\\left(\\frac{\\lambda}{\\sqrt{d}}\\sum_{j=1}^d z_j\\right)$，均等地依赖于所有 $d$ 个坐标。这代表了标准 QMC 的最坏情况，因为有效维度很高。\n\n对于由 $(d, n, \\mathbf{Q})$ 定义的每个测试用例，计算过程如下：\n1.  设置参数：$\\lambda=0.5$，MC 种子 $42$，Sobol 加扰种子 $7$。\n2.  构造指定的 $d \\times d$ 正交矩阵 $\\mathbf{Q}$。\n3.  使用 MC 方法生成 $n$ 个标准正态样本 $\\boldsymbol{Z}_{MC}$。\n4.  使用基于 Sobol 的 QMC 方法生成 $n$ 个标准正态样本 $\\boldsymbol{Z}_{QMC}$。\n5.  对于每个样本集，计算旋转后的向量 $\\boldsymbol{Y} = (\\mathbf{Q}\\boldsymbol{Z}^\\top)^\\top$，这可以实现为 $\\boldsymbol{Z} @ \\mathbf{Q}^\\top$。\n6.  提取旋转后向量的第一个分量 $(\\boldsymbol{Y})_1$。\n7.  为所有样本计算被积函数值，并计算样本均值 $\\widehat{I}_{MC}$ 和 $\\widehat{I}_{QMC}$。\n8.  计算绝对误差：$E_{MC} = |\\widehat{I}_{MC} - I(\\lambda)|$ 和 $E_{QMC} = |\\widehat{I}_{QMC} - I(\\lambda)|$。\n9.  计算性能比率 $r = E_{QMC} / \\max(E_{MC}, \\varepsilon)$，其中 $\\varepsilon = 10^{-16}$。\n\n所有测试用例的结果将被汇编并以所需格式呈现。比率 $r$ 量化了 QMC 的相对性能：$r < 1$ 表示 QMC 在该配置下更优，而 $r > 1$ 表示 MC 更优。",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import qmc, norm\n\ndef solve():\n    \"\"\"\n    Compares the performance of quasi-Monte Carlo (QMC) and standard Monte Carlo (MC)\n    for integrating a function under a multivariate standard normal distribution,\n    subject to various orthogonal transformations.\n    \"\"\"\n\n    # --- Fixed Parameters ---\n    lambda_val = 0.5\n    mc_seed = 42\n    sobol_scramble_seed = 7\n    epsilon = 1e-16\n\n    # --- Analytical Solution ---\n    # The true value of the integral E[exp(lambda * (QZ)_1)]\n    I_true = np.exp(0.5 * lambda_val**2)\n\n    # --- Test Suite ---\n    test_cases = [\n        # Case 1: d=8, n=4096, planar rotation, theta=0 (axis-aligned)\n        {'d': 8, 'n': 4096, 'q_type': 'planar', 'theta': 0.0},\n        # Case 2: d=8, n=4096, planar rotation, theta=pi/4 (mixes 2 coords)\n        {'d': 8, 'n': 4096, 'q_type': 'planar', 'theta': np.pi / 4},\n        # Case 3: d=32, n=4096, Householder reflection (mixes all coords)\n        {'d': 32, 'n': 4096, 'q_type': 'householder', 'theta': None},\n        # Case 4: d=8, n=64, planar rotation, theta=0 (small sample)\n        {'d': 8, 'n': 64, 'q_type': 'planar', 'theta': 0.0},\n        # Case 5: d=8, n=64, planar rotation, theta=pi/4 (small sample with mixing)\n        {'d': 8, 'n': 64, 'q_type': 'planar', 'theta': np.pi / 4},\n    ]\n\n    results = []\n\n    for case in test_cases:\n        d = case['d']\n        n = case['n']\n        q_type = case['q_type']\n        theta = case['theta']\n\n        # --- Construct Orthogonal Matrix Q ---\n        if q_type == 'planar':\n            Q = np.identity(d)\n            if d >= 2:\n                c, s = np.cos(theta), np.sin(theta)\n                R = np.array([[c, -s], [s, c]])\n                Q[:2, :2] = R\n        elif q_type == 'householder':\n            v = np.ones(d) / np.sqrt(d)\n            e1 = np.zeros(d)\n            e1[0] = 1.0\n            u_vec = e1 - v\n            norm_u = np.linalg.norm(u_vec)\n            if norm_u > 0:\n                u_vec /= norm_u\n            u_outer_u = np.outer(u_vec, u_vec)\n            Q = np.identity(d) - 2 * u_outer_u\n        else:\n            raise ValueError(f\"Unknown matrix type: {q_type}\")\n\n        # --- Generate Samples ---\n        # Standard Monte Carlo (MC) samples\n        rng_mc = np.random.default_rng(seed=mc_seed)\n        Z_mc = rng_mc.standard_normal(size=(n, d))\n\n        # Quasi-Monte Carlo (QMC) samples\n        sampler_qmc = qmc.Sobol(d=d, scramble=True, seed=sobol_scramble_seed)\n        U_qmc = sampler_qmc.random(n=n)\n        Z_qmc = norm.ppf(U_qmc)\n\n        # --- Define integrand function ---\n        def evaluate_integrand(Z, Q_matrix, lam):\n            # Q is (d, d), Z is (n, d). We want Q*z for each row z in Z.\n            # This is equivalent to (Q @ Z.T).T or Z @ Q.T\n            # Then we take the first component of each resulting vector.\n            Y1 = (Z @ Q_matrix.T)[:, 0]\n            return np.exp(lam * Y1)\n\n        # --- Estimate Integrals ---\n        f_vals_mc = evaluate_integrand(Z_mc, Q, lambda_val)\n        I_hat_mc = np.mean(f_vals_mc)\n\n        f_vals_qmc = evaluate_integrand(Z_qmc, Q, lambda_val)\n        I_hat_qmc = np.mean(f_vals_qmc)\n\n        # --- Compute Errors and Ratio ---\n        err_mc = np.abs(I_hat_mc - I_true)\n        err_qmc = np.abs(I_hat_qmc - I_true)\n\n        ratio = err_qmc / np.maximum(err_mc, epsilon)\n        results.append(ratio)\n\n    # --- Format and Print Final Output ---\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "为了克服确定性 QMC 方法的一些局限性，研究者们常常采用随机化拟蒙特卡洛（Randomized Quasi-Monte Carlo, RQMC）方法。最后一个练习  将介绍一种强大的随机化技术——Owen 加扰（Owen's scrambling）。通过将其应用于一个不连续函数的积分，你将看到加扰技术如何显著提高准确性，并通过独立的随机重复实验，为积分误差的估计提供了一种稳健的途径。",
            "id": "2424700",
            "problem": "你必须编写一个完整、可运行的程序，比较 Owen 加扰 Sobol’ 序列和未加扰 Sobol’ 序列在估计一个在计算经济学和金融学中至关重要的不连续被积函数积分时的性能。考虑积分\n$$\nI(d,\\tau) \\;=\\; \\int_{[0,1]^d} \\mathbf{1}\\!\\left\\{\\sum_{i=1}^{d} u_i \\ge \\tau \\right\\} \\, \\mathrm{d}\\boldsymbol{u},\n$$\n其中 $\\mathbf{1}\\{\\cdot\\}$ 是指示函数，$d \\in \\mathbb{N}$ 是维度，$\\tau \\in \\mathbb{R}$ 是一个阈值。该积分表示 $d$ 个独立的 Uniform$(0,1)$ 随机变量之和超过 $\\tau$ 的概率，这是与资产定价中的数字支付以及计算经济学和金融学中的风险度量相关的一种典型不连续支付。其精确值为\n$$\nI(d,\\tau) \\;=\\; 1 - F_{\\mathrm{IH}}(\\tau; d),\n$$\n其中 $F_{\\mathrm{IH}}(\\cdot; d)$ 是参数为 $d$ 的 Irwin–Hall 分布的累积分布函数，由下式给出\n$$\nF_{\\mathrm{IH}}(x; d) =\n\\begin{cases}\n0, & x \\le 0, \\\\[4pt]\n\\frac{1}{d!}\\sum_{k=0}^{\\lfloor x \\rfloor} (-1)^k \\binom{d}{k} (x - k)^d, & 0 < x < d, \\\\[10pt]\n1, & x \\ge d.\n\\end{cases}\n$$\n\n对于给定的 $d$、$\\tau$ 和样本量 $N \\in \\mathbb{N}$，定义拟蒙特卡罗估计量\n$$\n\\widehat{I}_N \\;=\\; \\frac{1}{N} \\sum_{n=1}^{N} \\mathbf{1}\\!\\left\\{\\sum_{i=1}^{d} u_{n,i} \\ge \\tau \\right\\},\n$$\n其中 $\\{\\boldsymbol{u}_n\\}_{n=1}^{N} \\subset [0,1]^d$ 是 Sobol’ 低差异序列的前 $N$ 个点。令 $m$ 为满足 $2^m \\ge N$ 的最小整数。在以下所有情况中，都使用来自维度为 $d$、大小为 $2^m$ 的 Sobol’ 数字网格的前 $N$ 个点。\n\n你的程序必须为每个测试用例计算：\n1. 使用未加扰的 Sobol’ 序列进行未加扰估计，以获得 $\\widehat{I}_N^{\\mathrm{uns}}$ 及其绝对误差\n$$\ne_{\\mathrm{uns}} \\;=\\; \\left| \\widehat{I}_N^{\\mathrm{uns}} - I(d,\\tau) \\right|.\n$$\n2. 使用 Owen 加扰的 Sobol’ 序列进行 $R$ 次独立随机化估计，以获得 $r \\in \\{1,\\dots,R\\}$ 的 $\\widehat{I}_{N,r}^{\\mathrm{scr}}$，每次都有其独立的随机化，并记录绝对误差\n$$\ne_{\\mathrm{scr},r} \\;=\\; \\left| \\widehat{I}_{N,r}^{\\mathrm{scr}} - I(d,\\tau) \\right|.\n$$\n对于每个测试用例，定义性能比\n$$\n\\rho \\;=\\; \\frac{e_{\\mathrm{uns}}}{\\operatorname{median}\\{ e_{\\mathrm{scr},1},\\dots,e_{\\mathrm{scr},R} \\}},\n$$\n这样，$\\rho > 1$ 在数值上表明，对于这个不连续的被积函数，Owen 加扰估计量比未加扰估计量获得了更小的典型绝对误差。\n\n使用以下参数值测试套件，其中 $S$ 是基础种子，$R$ 是独立 Owen 加扰的重复次数。对于第 $r$ 次加扰重复，使用种子 $S + r - 1$。对于下面的每个元组 $\\left(d,\\tau,N,R,S\\right)$，计算相应的 $\\rho$：\n- 测试用例 1：$\\left(d,\\tau,N,R,S\\right) = \\left(5,\\,2.5,\\,4093,\\,64,\\,13579\\right)$。\n- 测试用例 2：$\\left(d,\\tau,N,R,S\\right) = \\left(10,\\,5.0,\\,16384,\\,32,\\,24680\\right)$。\n- 测试用例 3：$\\left(d,\\tau,N,R,S\\right) = \\left(12,\\,9.0,\\,32767,\\,16,\\,112233\\right)$。\n\n你的程序必须：\n- 使用上面给出的 Irwin–Hall 累积分布函数 $F_{\\mathrm{IH}}(\\tau; d)$ 精确计算 $I(d,\\tau)$。\n- 对于每个测试用例，对未加扰序列和独立 Owen 加扰序列，都使用来自维度为 $d$、大小为 $2^m$ 的 Sobol’ 数字网格的前 $N$ 个点。\n- 对于每个测试用例，生成上面定义的性能比 $\\rho$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含三个测试用例的比率，格式为方括号括起来的逗号分隔列表，顺序与上面给出的测试用例相同，每个比率四舍五入到小数点后恰好 $6$ 位。例如，形式为 $\\left[\\rho_1,\\rho_2,\\rho_3\\right]$ 的输出必须打印为单行，如 $[1.234000,0.987650,1.500000]$。",
            "solution": "所提出的问题是拟蒙特卡罗 (QMC) 方法领域内一个有效的数值实验，具体应用于一个具有计算金融学特征的问题。它要求比较标准 Sobol’ 序列与 Owen 加扰 Sobol’ 序列在对一个不连续函数进行积分时的性能。该问题提法恰当，有科学依据，并且所有参数和定义都足够清晰，可以得出一个唯一的、可验证的解。我们将着手推导和实现解决方案。\n\n核心目标是计算性能比 $\\rho$，该比率量化了对于一个特定的不连续积分，Owen 加扰相比未加扰序列所带来的改进。该比率定义为\n$$\n\\rho \\;=\\; \\frac{e_{\\mathrm{uns}}}{\\operatorname{median}\\{ e_{\\mathrm{scr},1},\\dots,e_{\\mathrm{scr},R} \\}},\n$$\n其中 $e_{\\mathrm{uns}}$ 是使用未加扰 Sobol' 序列的估计量的绝对误差，而 $\\{ e_{\\mathrm{scr},r} \\}_{r=1}^R$ 是使用 Owen 加扰 Sobol' 序列的 $R$ 次独立重复实验所得的一组绝对误差。$\\rho > 1$ 的值表明加扰序列具有更优越的性能，因为它实现了更小的中位数误差。\n\n分步过程如下：\n\n**步骤 1：计算精确积分值**\n\n待估计的积分是\n$$\nI(d,\\tau) \\;=\\; \\int_{[0,1]^d} \\mathbf{1}\\!\\left\\{\\sum_{i=1}^{d} u_i \\ge \\tau \\right\\} \\, \\mathrm{d}\\boldsymbol{u}.\n$$\n这表示概率 $P(\\sum_{i=1}^d U_i \\ge \\tau)$，其中 $U_i \\sim \\text{Uniform}(0,1)$ 是独立的随机变量。和 $\\sum_{i=1}^d U_i$ 服从参数为 $d$ 的 Irwin–Hall 分布。该积分的精确值由该分布的生存函数给出：\n$$\nI(d,\\tau) \\;=\\; 1 - F_{\\mathrm{IH}}(\\tau; d),\n$$\n其中 $F_{\\mathrm{IH}}(x; d)$ 是问题描述中提供的累积分布函数 (CDF)。为了计算它，我们必须实现一个函数来计算 $F_{\\mathrm{IH}}(x;d)$。对于给定的值 $x = \\tau$ 和参数 $d$，该函数是分段定义的。非平凡的情况是 $0 < x < d$：\n$$\nF_{\\mathrm{IH}}(x; d) \\;=\\; \\frac{1}{d!}\\sum_{k=0}^{\\lfloor x \\rfloor} (-1)^k \\binom{d}{k} (x - k)^d.\n$$\n这个求和涉及到阶乘、二项式系数和幂，这些都是标准的数学函数。例如，对于测试用例 $(d, \\tau) = (5, 2.5)$，我们发现 $I(5, 2.5) = 1 - F_{\\mathrm{IH}}(2.5; 5) = 1 - 0.5 = 0.5$，这是由 Irwin-Hall 分布围绕其均值 $d/2 = 2.5$ 的对称性得出的。对于其他情况，需要直接评估该公式。\n\n**步骤 2：实现拟蒙特卡罗估计量**\n\n使用点集 $\\{\\boldsymbol{u}_n\\}_{n=1}^{N}$ 对 $I(d,\\tau)$ 进行 QMC 估计的公式是\n$$\n\\widehat{I}_N \\;=\\; \\frac{1}{N} \\sum_{n=1}^{N} f(\\boldsymbol{u}_n),\n$$\n其中被积函数是指示函数 $f(\\boldsymbol{u}) = \\mathbf{1}\\{\\sum_{i=1}^{d} u_i \\ge \\tau\\}$。计算过程包括对每个点 $\\boldsymbol{u}_n$ 的分量求和，检查总和是否大于或等于 $\\tau$，然后对所有 $N$ 个点的二元检查结果取平均值。\n\n我们必须计算两种类型的估计：\n\n1.  **未加扰估计 ($\\widehat{I}_N^{\\mathrm{uns}}$):** 我们生成一个 $d$ 维 Sobol' 序列的前 $N$ 个点，不进行任何加扰。这些点用于计算估计值 $\\widehat{I}_N^{\\mathrm{uns}}$。然后绝对误差为 $e_{\\mathrm{uns}} = |\\widehat{I}_N^{\\mathrm{uns}} - I(d, \\tau)|$。Sobol' 序列生成器配置为 `scramble=False`。\n\n2.  **加扰估计 ($\\widehat{I}_{N,r}^{\\mathrm{scr}}$):** 我们执行 $R$ 次独立的重复实验。对于每次重复 $r \\in \\{1, \\dots, R\\}$，我们从一个启用了 Owen 加扰的 $d$ 维 Sobol' 序列中生成一组新的 $N$ 个点。关键是，每次重复必须在统计上是独立的。这通过为每次重复的加扰矩阵使用不同的随机数生成器种子来实现。问题指定第 $r$ 次重复使用种子 $S + r - 1$。对于这 $R$ 个点集中的每一个，我们计算一个估计值 $\\widehat{I}_{N,r}^{\\mathrm{scr}}$ 及其对应的绝对误差 $e_{\\mathrm{scr},r} = |\\widehat{I}_{N,r}^{\\mathrm{scr}} - I(d, \\tau)|$。这个过程产生一个包含 $R$ 个误差的样本 $\\{e_{\\mathrm{scr},1}, \\dots, e_{\\mathrm{scr},R}\\}$。\n\n**步骤 3：计算性能比**\n\n有了未加扰误差 $e_{\\mathrm{uns}}$ 和 $R$ 个加扰误差的样本 $\\{e_{\\mathrm{scr},r}\\}$，我们就可以评估加扰估计量的典型性能。加扰误差的中位数 $\\operatorname{median}\\{e_{\\mathrm{scr},r}\\}$ 为随机化 QMC 方法的误差分布提供了一个稳健的中心趋势度量。最终的性能比 $\\rho$ 是通过将未加扰方法的单个确定性误差除以该中位数误差来计算的。\n\n**步骤 4：单个测试用例的算法流程**\n对于每个元组 $(d, \\tau, N, R, S)$：\n1.  计算精确积分值 $I_{\\mathrm{exact}} = 1 - F_{\\mathrm{IH}}(\\tau; d)$。\n2.  生成一个 $d$ 维的包含 $N$ 个点的未加扰 Sobol' 序列。\n3.  计算估计值 $\\widehat{I}_N^{\\mathrm{uns}}$ 和误差 $e_{\\mathrm{uns}} = |\\widehat{I}_N^{\\mathrm{uns}} - I_{\\mathrm{exact}}|$。\n4.  初始化一个空列表 `errors_scr` 用于存放加扰误差。\n5.  循环 $r$ 从 $1$ 到 $R$：\n    a.  将随机化种子设置为 $S + r - 1$。\n    b.  生成一个 $d$ 维的包含 $N$ 个点的 Owen 加扰 Sobol' 序列。\n    c.  计算估计值 $\\widehat{I}_{N,r}^{\\mathrm{scr}}$ 和误差 $e_{\\mathrm{scr},r} = |\\widehat{I}_{N,r}^{\\mathrm{scr}} - I_{\\mathrm{exact}}|$。\n    d.  将 $e_{\\mathrm{scr},r}$ 添加到 `errors_scr`。\n6.  计算加扰误差的中位数：$m_e = \\operatorname{median}(\\text{errors\\_scr})$。\n7.  计算性能比 $\\rho = e_{\\mathrm{uns}} / m_e$。\n8.  存储结果 $\\rho$，格式化为小数点后 6 位。\n\n对所有提供的测试用例重复这整个过程。最终输出是计算出的比率的有序列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import qmc\nfrom scipy.special import comb\nimport math\n\ndef solve():\n    \"\"\"\n    Main solver function that executes the comparison for all test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (d, tau, N, R, S)\n        (5, 2.5, 4093, 64, 13579),\n        (10, 5.0, 16384, 32, 24680),\n        (12, 9.0, 32767, 16, 112233),\n    ]\n\n    results = []\n    \n    for d, tau, N, R, S in test_cases:\n        # Step 1: Compute the exact integral value using the Irwin-Hall CDF\n        exact_integral_value = 1.0 - irwin_hall_cdf(tau, d)\n\n        # Step 2.1: Compute the unscrambled QMC estimate and its error\n        # Initialize an unscrambled Sobol' sequence generator\n        sampler_unscrambled = qmc.Sobol(d=d, scramble=False)\n        points_unscrambled = sampler_unscrambled.random(n=N)\n        \n        # Compute the estimate\n        integrand_values = (np.sum(points_unscrambled, axis=1) >= tau)\n        i_hat_unscrambled = np.mean(integrand_values)\n\n        # Compute the absolute error\n        e_unscrambled = np.abs(i_hat_unscrambled - exact_integral_value)\n\n        # Step 2.2: Compute R independent scrambled QMC estimates and their errors\n        scrambled_errors = []\n        for r in range(1, R + 1):\n            seed = S + r - 1\n            \n            # Initialize an Owen-scrambled Sobol' sequence generator with a unique seed\n            sampler_scrambled = qmc.Sobol(d=d, scramble=True, seed=seed)\n            points_scrambled = sampler_scrambled.random(n=N)\n            \n            # Compute the estimate\n            integrand_values_scr = (np.sum(points_scrambled, axis=1) >= tau)\n            i_hat_scrambled = np.mean(integrand_values_scr)\n            \n            # Compute and store the absolute error\n            e_scrambled = np.abs(i_hat_scrambled - exact_integral_value)\n            scrambled_errors.append(e_scrambled)\n\n        # Step 3: Calculate the performance ratio\n        median_scrambled_error = np.median(scrambled_errors)\n        \n        # Avoid division by zero, though highly unlikely in this context.\n        if median_scrambled_error == 0:\n            # If median error is 0, scrambling is perfect. \n            # If unscrambled is also 0, ratio is 1. Otherwise, ratio is effectively infinite.\n            # We assign a large number or handle as per problem specific but here we assume it won't happen.\n            rho = np.inf if e_unscrambled > 0 else 1.0\n        else:\n            rho = e_unscrambled / median_scrambled_error\n        \n        results.append(f\"{rho:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\n\ndef irwin_hall_cdf(x, d):\n    \"\"\"\n    Computes the Irwin-Hall cumulative distribution function F_IH(x; d).\n    \n    Args:\n        x (float): The value at which to evaluate the CDF.\n        d (int): The parameter of the distribution (number of uniform variables).\n    \n    Returns:\n        float: The value of the CDF.\n    \"\"\"\n    if x = 0:\n        return 0.0\n    if x >= d:\n        return 1.0\n    \n    # Formula for 0  x  d\n    total_sum = 0.0\n    k_max = math.floor(x)\n    \n    for k in range(k_max + 1):\n        # Calculate (-1)^k * C(d, k) * (x - k)^d\n        term = ((-1)**k) * comb(d, k, exact=True) * ((x - k)**d)\n        total_sum += term\n        \n    return total_sum / math.factorial(d)\n\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}