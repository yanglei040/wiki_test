{
    "hands_on_practices": [
        {
            "introduction": "掌握限价订单簿模拟的第一步是构建其核心——匹配引擎。此练习将指导您使用高效的数据结构，从零开始实现一个能够处理连续（非离散）价格的匹配引擎。通过这个实践 ，您将深入理解价格-时间优先原则以及在处理真实世界金融数据时浮点数精度所带来的挑战。",
            "id": "2406545",
            "problem": "本题要求您设计并实现一个连续价格限价订单簿（LOB）模拟器。与常见的离散价格档位设置不同，此处的价位是实数值，不吸附于网格。该模拟器必须实现价格-时间优先原则，允许订单取消，并能处理市价单和限价单的部分成交，所有操作都需在处理浮点数比较时考虑一个小的数值容差。\n\n问题的核心在于，将连续价格双向拍卖的微观结构逻辑转化为高效的数据结构和算法撮合引擎，然后计算指定的聚合指标。以下是您必须遵守的基础定义和规则。\n\n定义与规则：\n- 限价单是一个元组 $(\\text{side}, \\text{quantity}, \\text{price}, \\text{id})$，其中 $\\text{side} \\in \\{\\text{buy}, \\text{sell}\\}$，$\\text{quantity} \\in \\mathbb{R}_{>0}$，$\\text{price} \\in \\mathbb{R}_{>0}$，以及一个唯一的整数标识符 $\\text{id} \\in \\mathbb{Z}_{>0}$。市价单是一个没有价格的元组 $(\\text{side}, \\text{quantity}, \\text{id})$。取消订单针对一个已存在的标识符，形式为 $(\\text{id})$。\n- 价格-时间优先：对于同一边、同一价格的挂单，执行优先级按到达时间（先进先出）排序。在不同价格之间，最优价格优先执行：买单为最高价，卖单为最低价。\n- 带容差的撮合条件：设 $\\varepsilon \\ge 0$ 为一个数值容差。当一个新的买方限价单价格为 $p_b$ 时，如果当前最优卖价 $a^\\star$ 满足 $a^\\star \\le p_b + \\varepsilon$，则该订单是可成交的。当一个新的卖方限价单价格为 $p_s$ 时，如果当前最优买价 $b^\\star$ 满足 $b^\\star + \\varepsilon \\ge p_s$，则该订单是可成交的。市价单总是可成交的。\n- 成交价：交易以挂单的价格发生。\n- 部分成交：如果传入订单的剩余数量为 $q_\\text{in} > 0$，而价格为 $p^\\star$ 的最优对手方挂单的剩余数量为 $q^\\star > 0$，则成交数量为 $\\min(q_\\text{in}, q^\\star)$。相应地减少双方数量；传入订单的任何剩余部分将继续撮合；不可成交的传入限价单的任何剩余部分将成为一个新的挂单。\n- 订单取消：通过标识符取消订单，将从订单簿中移除该挂单的任何剩余数量（如果它存在且尚未被完全执行或取消）。\n- 空边最优价：如果最终买方或卖方订单簿为空，则将该边的最优价定义为 $0$。\n\n每个测试用例所需的输出指标：\n- 处理完测试用例中所有事件后的最优买价 $b^\\star_\\text{final}$ 和最优卖价 $a^\\star_\\text{final}$（如果一边为空，则使用 $0$）。\n- 总交易次数 $N_T$，其中每次与一个挂单的撮合都算作一次交易，即使是由单个传入订单触发的。\n- 总成交量 $Q_T = \\sum_i q_i$，其中 $q_i$ 是第 $i$ 次交易的数量。\n- 所有交易的成交量加权平均价（VWAP）：\n$$\n\\text{VWAP} = \n\\begin{cases}\n\\frac{\\sum_i q_i p_i}{\\sum_i q_i},  & \\text{if } \\sum_i q_i > 0,\\\\\n0,  & \\text{otherwise},\n\\end{cases}\n$$\n其中 $p_i$ 是第 $i$ 次交易的成交价。\n所有浮点数输出必须四舍五入到恰好 $6$ 位小数；整数必须不带小数位打印。\n\n算法要求：\n- 由于价格是连续的，您不得将价格离散化或分桶。应使用支持顺序统计的数据结构，例如用于提取最优价格的堆，并为每个不同价格使用一个队列来维持时间优先。您必须处理空价格水平的懒删除。浮点数比较必须使用给定的 $\\varepsilon$ 容差。\n- 交易执行采用价格-时间优先原则，成交价始终为挂单的价格。\n\n测试套件：\n对于每个测试用例 $k \\in \\{1,2,3,4\\}$，给定一个容差 $\\varepsilon_k$ 和一个事件序列 $\\{E_{k,j}\\}_{j=1}^{m_k}$。\n\n事件编码：\n- 限价单：$E=(\\text{\"limit\"}, \\text{side}, q, p, \\text{id})$，其中 $\\text{side} \\in \\{\\text{\"buy\"}, \\text{\"sell\"}\\}$，$q \\in \\mathbb{R}_{>0}$，$p \\in \\mathbb{R}_{>0}$，$\\text{id} \\in \\mathbb{Z}_{>0}$。\n- 市价单：$E=(\\text{\"market\"}, \\text{side}, q, \\text{id})$，其中 $\\text{side} \\in \\{\\text{\"buy\"}, \\text{\"sell\"}\\}$，$q \\in \\mathbb{R}_{>0}$，$\\text{id} \\in \\mathbb{Z}_{>0}$。\n- 订单取消：$E=(\\text{\"cancel\"}, \\text{id})$。\n\n测试用例 1：\n- $\\varepsilon_1 = 10^{-9}$。\n- 事件：\n  - $E_{1,1}=(\\text{\"limit\"}, \\text{\"sell\"}, 5, 101.0, 1)$。\n  - $E_{1,2}=(\\text{\"limit\"}, \\text{\"sell\"}, 3, 100.5, 2)$。\n  - $E_{1,3}=(\\text{\"limit\"}, \\text{\"buy\"}, 4, 100.0, 3)$。\n  - $E_{1,4}=(\\text{\"limit\"}, \\text{\"buy\"}, 6, 101.0, 4)$。\n\n测试用例 2（边界情况：同一价格水平下的等价与严格的先进先出）：\n- $\\varepsilon_2 = 0$。\n- 事件：\n  - $E_{2,1}=(\\text{\"limit\"}, \\text{\"sell\"}, 2, 100.0, 10)$。\n  - $E_{2,2}=(\\text{\"limit\"}, \\text{\"sell\"}, 1, 100.0, 11)$。\n  - $E_{2,3}=(\\text{\"limit\"}, \\text{\"buy\"}, 3, 100.0, 12)$。\n\n测试用例 3（市价单扫过多个价格水平）：\n- $\\varepsilon_3 = 10^{-9}$。\n- 事件：\n  - $E_{3,1}=(\\text{\"limit\"}, \\text{\"sell\"}, 1, 100.0, 20)$。\n  - $E_{3,2}=(\\text{\"limit\"}, \\text{\"sell\"}, 2, 100.2, 21)$。\n  - $E_{3,3}=(\\text{\"limit\"}, \\text{\"sell\"}, 4, 101.0, 22)$。\n  - $E_{3,4}=(\\text{\"market\"}, \\text{\"buy\"}, 5, 23)$。\n\n测试用例 4（启用容差的交叉和取消）：\n- $\\varepsilon_4 = 10^{-3}$。\n- 事件：\n  - $E_{4,1}=(\\text{\"limit\"}, \\text{\"sell\"}, 5, 100.0001, 30)$。\n  - $E_{4,2}=(\\text{\"limit\"}, \\text{\"buy\"}, 2, 100.0, 31)$。\n  - $E_{4,3}=(\\text{\"cancel\"}, 30)$。\n  - $E_{4,4}=(\\text{\"market\"}, \\text{\"sell\"}, 1, 32)$。\n\n程序输入与输出：\n- 无外部输入。将上述测试套件硬编码在您的程序中。\n- 对于每个测试用例，按顺序处理所有事件并计算 $[b^\\star_\\text{final}, a^\\star_\\text{final}, N_T, Q_T, \\text{VWAP}]$。\n- 您的程序应生成单行输出，包含一个顶层列表，其中每个元素是按指定格式表示的测试用例结果列表，浮点数四舍五入到恰好 $6$ 位小数，且不含任何空格。例如：$[[\\dots],[\\dots],[\\dots],[\\dots]]$。\n\n约束与保证：\n- 所有数量和价格均为合理的金融范围内的严格正实数。\n- 标识符在整个测试套件中是唯一的，且取消操作仅引用先前提交的标识符。\n- 撮合引擎不得离散化价格；它必须按照定义，使用 $\\varepsilon$ 容差来尊重连续价格的比较。",
            "solution": "该问题要求设计并实现一个连续价格限价订单簿（LOB）模拟器。该解决方案必须遵守价格-时间优先原则，处理各种订单类型，并计算特定的金融指标。解决方案的核心是一个事件驱动的模拟过程，它构建于精心选择的数据结构之上，这些数据结构能高效地管理订单簿的状态。\n\n**1. 基础设计：事件驱动模拟**\n\n模拟通过按时间顺序处理一系列事件来进行。LOB 的状态——包括所有挂单中的买单（bid）和卖单（ask）——会根据每个事件进行更新。此设计封装在 `LimitOrderBook` 类中，该类维护订单簿的状态，并包含处理事件和撮合订单的逻辑。\n\n**2. 核心数据结构**\n\n为了在连续价格设置中满足价格-时间优先规则，采用了堆和队列的组合。这种混合结构对于所需操作是最佳的：快速检索最优价格的订单，并对同一价格的订单严格执行按到达时间排序的规则。\n\n- **价格优先（堆）**：交易必须以最优可用价格进行。对于买单（bids），最优价格是最高价。对于卖单（asks），最优价格是最低价。\n    - **卖方订单簿** 由一个最小堆管理，它提供对最低价格（最优卖价）的 $O(1)$ 访问。Python 的 `heapq` 库用于此目的。\n    - **买方订单簿** 由一个最大堆管理。由于 `heapq` 只提供最小堆，这通过存储买单价格的负值（例如，价格为 $p$ 则存储 $-p$）来实现，这有效地反转了排序顺序，并允许最小堆在 $O(1)$ 时间内检索到最大价格。\n\n- **时间优先（队列）**：对于相同价格的订单，执行遵循先进先出（FIFO）原则。\n    - 一个字典 `price_levels` 将每个不同的价格 $p$ 映射到一个该价格下的订单队列（具体来说是 `collections.deque`）。选择 `deque` 是因为它能高效地在两端进行 $O(1)$ 的追加和弹出操作，这对于管理订单的到达和执行非常理想。\n\n- **订单跟踪（字典）**：取消订单需要通过其唯一标识符 `id` 快速查找订单。\n    - 一个字典 `orders_map` 将每个 `id` 映射到其对应的 `Order` 对象。这允许对任何活动订单进行 $O(1)$ 访问以进行修改（例如，减少数量）或取消。定义了一个 `Order` 类来存储其 `id`、`side`、`price` 和剩余 `quantity`。\n\n**3. 算法逻辑与执行流程**\n\n模拟器的逻辑围绕一个主事件处理循环组织。\n\n- **事件分派**：一个中心方法 `process_event` 识别事件的类型——限价单、市价单或取消订单——并将其分派给相应的处理函数。\n\n- **订单撮合引擎**：这是 LOB 的心脏。当一个可成交的订单到达时（市价单，或一个跨越买卖价差的限价单），`_match_order` 方法被调用。\n    - 一个价格为 $p_b$ 的传入买单，若最优卖价 $a^\\star$ 满足 $a^\\star \\le p_b + \\varepsilon$，则该订单可成交。一个价格为 $p_s$ 的传入卖单，若最优买价 $b^\\star$ 满足 $b^\\star + \\varepsilon \\ge p_s$，则该订单可成交。市价单总是可成交的。\n    - 撮合循环持续进行，只要传入订单的数量 $q_\\text{in} > 0$ 且对手方订单簿中有可交叉的订单。\n    - 在每一步中，它都与最优价格的挂单进行撮合。交易以挂单的价格发生。成交数量为 $\\min(q_\\text{in}, q^\\star)$，其中 $q^\\star$ 是挂单的数量。\n    - 两个订单的数量都相应减少。如果挂单被完全成交，它将从其价格水平队列和 `orders_map` 中移除。如果传入订单被成交，撮合过程停止。不可成交的传入限价单的任何剩余部分随后被放入订单簿中。\n\n- **订单放置**：如果一个限价单不可成交，或者在撮合后仍有剩余数量，它将被 `_add_order_to_book` 方法添加到订单簿中。这涉及将 `Order` 对象添加到相应的价格水平队列和 `orders_map`。如果该价格水平是新的，价格也会被推入相应的买方或卖方堆中。\n\n- **取消与懒删除**：对给定 `id` 的取消事件，通过在 `orders_map` 中查找订单并将其 `quantity` 设置为 $0$ 来处理。这是一种“懒”取消（lazy cancellation）。该“僵尸”订单对象仍保留在其队列中。\n    - 为了防止这些零数量订单影响撮合，实现了一个 `_peek_best_price` 辅助函数。在从堆返回最优价格之前，此函数会检查相应的价格水平队列。它通过从队列前端移除任何零数量订单来清理队列。如果此清理操作使整个价格水平变空，则该价格将从堆中弹出，并重复此过程，直到在堆顶找到一个有效的、非空的价格水平或堆变空为止。这种懒删除（lazy deletion）机制通过避免为查找和移除空价格水平而对订单簿进行高成本的遍历，从而确保了高性能。\n\n**4. 输出指标的计算**\n\n在处理完一个测试用例中的所有事件后，计算最终指标：\n- **最优买/卖价（$b^\\star_\\text{final}, a^\\star_\\text{final}$）**：分别使用 `_peek_best_price` 方法获取买方和卖方侧的最优价格。如果某一边为空，则价格定义为 $0$。\n- **总交易次数（$N_T$）**：每当传入订单与挂单发生一次撮合时，计数器加一。\n- **总成交量（$Q_T$）**：这是所有交易数量的累积总和。\n- **成交量加权平均价（VWAP）**：计算公式为 $\\frac{\\sum_i q_i p_i}{\\sum_i q_i}$，其中 $q_i$ 和 $p_i$ 分别是每笔交易的数量和价格。在模拟期间，会维护分子 $\\sum_i q_i p_i$ 的一个运行总和。最终的 VWAP 是此总和除以最终的 $Q_T$。如果 $Q_T = 0$，则 VWAP 为 $0$。\n\n所有浮点数结果都按要求格式化并四舍五入到 $6$ 位小数。整个设计确保了正确性、对指定规则的遵守以及适用于高性能撮合引擎模拟的计算效率。",
            "answer": "```python\nimport collections\nimport heapq\n\nclass Order:\n    \"\"\"Represents an order in the book.\"\"\"\n    __slots__ = ['id', 'side', 'quantity', 'price']\n    \n    def __init__(self, id, side, quantity, price=None):\n        self.id = id\n        self.side = side\n        self.quantity = float(quantity)\n        self.price = float(price) if price is not None else None\n\nclass LimitOrderBook:\n    \"\"\"A continuous-price limit order book simulator.\"\"\"\n    \n    def __init__(self, epsilon=1e-9):\n        # Bids are a max-heap (implemented with negative prices in a min-heap)\n        self.bids = []  \n        # Asks are a min-heap\n        self.asks = []  \n        # price -> deque of orders\n        self.price_levels = collections.defaultdict(collections.deque)\n        # id -> Order object\n        self.orders_map = {}\n        self.epsilon = epsilon\n        \n        # Statistics\n        self.n_trades = 0\n        self.total_quantity = 0.0\n        self.vwap_numerator = 0.0\n\n    def _peek_best_price(self, side):\n        \"\"\"Returns the best price for a side, handling lazy deletion.\"\"\"\n        heap = self.bids if side == \"buy\" else self.asks\n        \n        while heap:\n            price_in_heap = heap[0]\n            real_price = -price_in_heap if side == \"buy\" else price_in_heap\n            \n            level_queue = self.price_levels[real_price]\n            \n            # Clean up filled/cancelled orders from the front of the queue\n            while level_queue and level_queue[0].quantity = 0:\n                dead_order = level_queue.popleft()\n                if dead_order.id in self.orders_map:\n                    del self.orders_map[dead_order.id]\n            \n            if not level_queue:\n                # Price level is now empty, remove from heap and map\n                heapq.heappop(heap)\n                del self.price_levels[real_price]\n            else:\n                # Found a valid price level\n                return real_price\n        \n        return 0.0 # Per problem spec for empty side\n\n    def _add_order_to_book(self, order):\n        \"\"\"Adds a limit order to the book.\"\"\"\n        if order.quantity = 0: return\n\n        # If price level is new, add price to the correct heap\n        if not self.price_levels[order.price]:\n            if order.side == \"buy\":\n                heapq.heappush(self.bids, -order.price)\n            else:\n                heapq.heappush(self.asks, order.price)\n        \n        self.price_levels[order.price].append(order)\n        self.orders_map[order.id] = order\n\n    def _match_order(self, incoming_order):\n        \"\"\"Matches an incoming order against the book.\"\"\"\n        while incoming_order.quantity > 0:\n            best_opp_price = self._peek_best_price(\"sell\" if incoming_order.side == \"buy\" else \"buy\")\n            \n            if best_opp_price == 0.0:\n                break # No liquidity on the opposing side\n\n            # Check marketability for incoming limit orders\n            is_marketable = False\n            if incoming_order.price is None: # Market order\n                is_marketable = True\n            elif incoming_order.side == \"buy\": # Buy limit\n                if best_opp_price = incoming_order.price + self.epsilon:\n                    is_marketable = True\n            else: # Sell limit\n                if best_opp_price + self.epsilon >= incoming_order.price:\n                    is_marketable = True\n\n            if not is_marketable:\n                break # Incoming limit order is no longer aggressive enough\n\n            resting_order_queue = self.price_levels[best_opp_price]\n            \n            # Match against orders at this price level\n            while resting_order_queue and incoming_order.quantity > 0:\n                resting_order = resting_order_queue[0]\n                \n                trade_qty = min(incoming_order.quantity, resting_order.quantity)\n                \n                # Update statistics\n                self.n_trades += 1\n                self.total_quantity += trade_qty\n                # Trade happens at the resting order's price\n                self.vwap_numerator += trade_qty * resting_order.price\n                \n                # Update quantities\n                incoming_order.quantity -= trade_qty\n                resting_order.quantity -= trade_qty\n                \n                if resting_order.quantity = 0:\n                    resting_order_queue.popleft()\n                    if resting_order.id in self.orders_map:\n                         del self.orders_map[resting_order.id]\n            \n            # If the price level was exhausted, _peek_best_price will clean it up on the next loop\n        \n        # If incoming was a limit order with residual quantity, add it to the book\n        if incoming_order.price is not None and incoming_order.quantity > 0:\n            self._add_order_to_book(incoming_order)\n\n    def process_event(self, event):\n        \"\"\"Processes a single event tuple.\"\"\"\n        event_type = event[0]\n        \n        if event_type == \"limit\":\n            _, side, qty, price, oid = event\n            order = Order(oid, side, qty, price)\n            self._match_order(order)\n            \n        elif event_type == \"market\":\n            _, side, qty, oid = event\n            order = Order(oid, side, qty, None)\n            self._match_order(order)\n\n        elif event_type == \"cancel\":\n            _, oid = event\n            if oid in self.orders_map:\n                self.orders_map[oid].quantity = 0\n\n    def get_final_metrics(self):\n        \"\"\"Returns the final metrics for the test case.\"\"\"\n        b_star = self._peek_best_price(\"buy\")\n        a_star = self._peek_best_price(\"sell\")\n        \n        vwap = 0.0\n        if self.total_quantity > 0:\n            vwap = self.vwap_numerator / self.total_quantity\n\n        return [\n            f\"{b_star:.6f}\",\n            f\"{a_star:.6f}\",\n            self.n_trades,\n            f\"{self.total_quantity:.6f}\",\n            f\"{vwap:.6f}\"\n        ]\n\ndef solve():\n    test_cases = [\n        # Test Case 1\n        (1e-9, [\n            (\"limit\", \"sell\", 5, 101.0, 1),\n            (\"limit\", \"sell\", 3, 100.5, 2),\n            (\"limit\", \"buy\", 4, 100.0, 3),\n            (\"limit\", \"buy\", 6, 101.0, 4),\n        ]),\n        # Test Case 2\n        (0.0, [\n            (\"limit\", \"sell\", 2, 100.0, 10),\n            (\"limit\", \"sell\", 1, 100.0, 11),\n            (\"limit\", \"buy\", 3, 100.0, 12),\n        ]),\n        # Test Case 3\n        (1e-9, [\n            (\"limit\", \"sell\", 1, 100.0, 20),\n            (\"limit\", \"sell\", 2, 100.2, 21),\n            (\"limit\", \"sell\", 4, 101.0, 22),\n            (\"market\", \"buy\", 5, 23),\n        ]),\n        # Test Case 4\n        (1e-3, [\n            (\"limit\", \"sell\", 5, 100.0001, 30),\n            (\"limit\", \"buy\", 2, 100.0, 31),\n            (\"cancel\", 30),\n            (\"market\", \"sell\", 1, 32),\n        ])\n    ]\n\n    all_results = []\n    for epsilon, events in test_cases:\n        lob = LimitOrderBook(epsilon)\n        for event in events:\n            lob.process_event(event)\n        \n        metrics = lob.get_final_metrics()\n        all_results.append(f\"[{','.join(map(str, metrics))}]\")\n\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "一个有意义的模拟不仅需要一个有效的市场结构，还需要能够做出理性决策的智能体。此练习将视角转向单个做市商，要求您运用优化理论，推导出在面临库存风险和盈利机会权衡下的最优报价策略。这个基于计算的练习  为您在更复杂的基于智能体的模型中设计代理人行为提供了坚实的理论基础。",
            "id": "2406577",
            "problem": "在一个长度为 $\\Delta t  0$ 的短时间范围内，模拟一个单一资产的限价订单簿 (LOB)。中间价用 $S$ 表示，其在 $\\Delta t$ 内的期望变化为零。一个做市商在低于 $S$ 的距离 $\\delta_b \\ge 0$ 处发布一个单位大小的买入限价单，并在高于 $S$ 的距离 $\\delta_a \\ge 0$ 处发布一个单位大小的卖出限价单。每次成交都会使库存发生变化，买方为 $+q$，卖方为 $-q$，其中给定的 $q0$。初始库存为 $I_0 \\in \\mathbb{R}$。\n\n做市商报价上的订单到达是独立的泊松过程，其均值为\n$$\n\\Lambda_b(\\delta_b) = (\\alpha - \\beta \\delta_b)\\,\\Delta t,\\qquad \\Lambda_a(\\delta_a) = (\\alpha - \\beta \\delta_a)\\,\\Delta t,\n$$\n其中 $\\alpha0$ 和 $\\beta0$ 是给定常数，并且报价受到限制，使得 $\\Lambda_b(\\delta_b)\\ge 0$ 和 $\\Lambda_a(\\delta_a)\\ge 0$。每个成交的买单（或卖单）的利润是相对于 $S$ 衡量的，等于 $\\delta_b q$（或 $\\delta_a q$）。\n\n在时间范围结束时，做市商会产生一个非线性的库存惩罚 $C(I_T)=k I_T^2$，其中 $k0$，期末库存为 $I_T = I_0 + q N_b - q N_a$，$N_b \\sim \\mathrm{Poisson}(\\Lambda_b(\\delta_b))$ 和 $N_a \\sim \\mathrm{Poisson}(\\Lambda_a(\\delta_a))$ 是独立的。\n\n构建并解决选择 $(\\delta_b,\\delta_a)$ 的优化问题，以在时间范围 $\\Delta t$ 内最大化扣除预期期末库存惩罚后的期望利润。请提供最优距离 $\\delta_b^\\star$ 和 $\\delta_a^\\star$ 作为关于 $\\alpha$、$\\beta$、$\\Delta t$、$q$、$k$ 和 $I_0$ 的闭式解析表达式。",
            "solution": "用户要求构建并解决一个做市商在限价订单簿中的优化问题。我将首先验证问题陈述。\n\n第一步：提取已知条件\n- 时间范围：$\\Delta t  0$。\n- 中间价：$S$，其 $E[\\Delta S] = 0$。\n- 买入限价单价格：$S - \\delta_b$，其中 $\\delta_b \\ge 0$。\n- 卖出限价单价格：$S + \\delta_a$，其中 $\\delta_a \\ge 0$。\n- 订单成交规模：$q  0$。\n- 初始库存：$I_0 \\in \\mathbb{R}$。\n- 订单到达率为独立泊松过程的均值：\n  - 买方：$\\Lambda_b(\\delta_b) = (\\alpha - \\beta \\delta_b)\\,\\Delta t$。\n  - 卖方：$\\Lambda_a(\\delta_a) = (\\alpha - \\beta \\delta_a)\\,\\Delta t$。\n- 常数：$\\alpha  0$, $\\beta  0$。\n- 约束条件：$\\Lambda_b(\\delta_b)\\ge 0$ 和 $\\Lambda_a(\\delta_a)\\ge 0$。这意味着 $0 \\le \\delta_b \\le \\alpha/\\beta$ 和 $0 \\le \\delta_a \\le \\alpha/\\beta$。\n- 每次买入成交的利润：$\\delta_b q$。\n- 每次卖出成交的利润：$\\delta_a q$。\n- 期末库存惩罚：$C(I_T) = k I_T^2$，其中 $k  0$。\n- 期末库存：$I_T = I_0 + q N_b - q N_a$，其中 $N_b \\sim \\mathrm{Poisson}(\\Lambda_b(\\delta_b))$ 和 $N_a \\sim \\mathrm{Poisson}(\\Lambda_a(\\delta_a))$ 分别是买入和卖出成交的数量。\n- 目标：选择 $(\\delta_b, \\delta_a)$ 以最大化期望总利润。\n\n第二步：使用提取的已知条件进行验证\n- **科学基础**：该问题是做市的一个简化模型，与量化金融领域的既有文献（例如 Avellaneda-Stoikov 框架）一致。使用泊松过程来模拟订单到达和二次库存惩罚是标准的建模选择。\n- **适定性**：该问题要求在一个紧集上最大化一个函数。我将证明，目标函数是严格凹的，这保证了唯一最大值的存在。该问题是适定的。\n- **客观性**：问题以清晰的数学术语陈述，没有主观内容。\n\n问题陈述是有效的。它是自洽的、有科学依据且客观的。我现在将继续进行求解。\n\n在时间范围 $\\Delta t$ 内的总利润 $\\Pi$ 是已执行订单的利润之和减去期末库存惩罚：\n$$\n\\Pi = q \\delta_b N_b + q \\delta_a N_a - k I_T^2 = q \\delta_b N_b + q \\delta_a N_a - k (I_0 + q N_b - q N_a)^2\n$$\n目标是通过选择 $\\delta_b$ 和 $\\delta_a$ 来最大化期望利润 $E[\\Pi]$。\n$$\nE[\\Pi] = E[q \\delta_b N_b + q \\delta_a N_a - k (I_0 + q N_b - q N_a)^2]\n$$\n根据期望的线性性，\n$$\nE[\\Pi] = q \\delta_b E[N_b] + q \\delta_a E[N_a] - k E[(I_0 + q N_b - q N_a)^2]\n$$\n对于一个泊松随机变量 $X \\sim \\mathrm{Poisson}(\\lambda)$，其期望为 $E[X] = \\lambda$，方差为 $\\mathrm{Var}(X) = \\lambda$。其二阶矩为 $E[X^2] = \\mathrm{Var}(X) + (E[X])^2 = \\lambda + \\lambda^2$。\n随机变量 $N_b$ 和 $N_a$ 是独立的。\n$E[N_b] = \\Lambda_b$ 且 $E[N_a] = \\Lambda_a$。\n期望期末库存为 $E[I_T] = E[I_0 + q N_b - q N_a] = I_0 + q E[N_b] - q E[N_a] = I_0 + q(\\Lambda_b - \\Lambda_a)$。\n期末库存的方差为 $\\mathrm{Var}(I_T) = \\mathrm{Var}(I_0 + q N_b - q N_a) = q^2\\mathrm{Var}(N_b) + q^2\\mathrm{Var}(N_a) = q^2(\\Lambda_b + \\Lambda_a)$。\n期望二次惩罚为 $E[k I_T^2] = k E[I_T^2] = k (\\mathrm{Var}(I_T) + (E[I_T])^2)$。\n$$\nE[k I_T^2] = k \\left[ q^2(\\Lambda_b + \\Lambda_a) + (I_0 + q(\\Lambda_b - \\Lambda_a))^2 \\right]\n$$\n因此，需要最大化的目标函数，我们称之为 $F(\\delta_b, \\delta_a)$，是：\n$$\nF(\\delta_b, \\delta_a) = q \\delta_b \\Lambda_b + q \\delta_a \\Lambda_a - k \\left[ q^2(\\Lambda_b + \\Lambda_a) + (I_0 + q(\\Lambda_b - \\Lambda_a))^2 \\right]\n$$\n为了找到最优的 $(\\delta_b, \\delta_a)$，我们计算 $F$ 的偏导数并令其为零。我们注意到 $\\frac{\\partial \\Lambda_b}{\\partial \\delta_b} = -\\beta \\Delta t$，$\\frac{\\partial \\Lambda_a}{\\partial \\delta_a} = -\\beta \\Delta t$，且交叉导数为零。\n\n关于 $\\delta_b$ 的偏导数是：\n$$\n\\frac{\\partial F}{\\partial \\delta_b} = \\frac{\\partial}{\\partial \\delta_b} (q \\delta_b \\Lambda_b) - k q^2 \\frac{\\partial \\Lambda_b}{\\partial \\delta_b} - 2k(I_0 + q(\\Lambda_b - \\Lambda_a))q \\frac{\\partial \\Lambda_b}{\\partial \\delta_b} = 0\n$$\n使用乘法法则，$\\frac{\\partial}{\\partial \\delta_b} (q \\delta_b \\Lambda_b) = q \\Lambda_b + q \\delta_b \\frac{\\partial \\Lambda_b}{\\partial \\delta_b}$。\n$$\nq \\Lambda_b + q \\delta_b \\frac{\\partial \\Lambda_b}{\\partial \\delta_b} - k q^2 \\frac{\\partial \\Lambda_b}{\\partial \\delta_b} - 2kq(I_0 + q(\\Lambda_b - \\Lambda_a)) \\frac{\\partial \\Lambda_b}{\\partial \\delta_b} = 0\n$$\n代入 $\\frac{\\partial \\Lambda_b}{\\partial \\delta_b} = -\\beta \\Delta t$：\n$$\nq \\Lambda_b - q \\delta_b (\\beta \\Delta t) + k q^2 (\\beta \\Delta t) + 2kq(I_0 + q(\\Lambda_b - \\Lambda_a)) (\\beta \\Delta t) = 0\n$$\n除以 $q \\beta \\Delta t$（非零）：\n$$\n\\frac{\\Lambda_b}{\\beta \\Delta t} - \\delta_b + kq + 2k(I_0 + q(\\Lambda_b - \\Lambda_a)) = 0\n$$\n代入 $\\Lambda_b = (\\alpha - \\beta \\delta_b)\\Delta t$：\n$$\n\\frac{(\\alpha - \\beta \\delta_b)\\Delta t}{\\beta \\Delta t} - \\delta_b + kq + 2k I_0 + 2kq(\\Lambda_b - \\Lambda_a) = 0\n$$\n$$\n\\frac{\\alpha}{\\beta} - 2\\delta_b + kq + 2k I_0 + 2kq(\\Lambda_b - \\Lambda_a) = 0\n$$\n$$\n2\\delta_b = \\frac{\\alpha}{\\beta} + kq + 2k I_0 + 2kq(\\Lambda_b - \\Lambda_a) \\quad (1)\n$$\n根据对称性，关于 $\\delta_a$ 的偏导数得出：\n$$\n\\frac{\\partial F}{\\partial \\delta_a} = q \\Lambda_a + q \\delta_a \\frac{\\partial \\Lambda_a}{\\partial \\delta_a} - k q^2 \\frac{\\partial \\Lambda_a}{\\partial \\delta_a} - 2k(I_0 + q(\\Lambda_b - \\Lambda_a))(-q) \\frac{\\partial \\Lambda_a}{\\partial \\delta_a} = 0\n$$\n除以 $q \\beta \\Delta t$ 并代入 $\\frac{\\partial \\Lambda_a}{\\partial \\delta_a} = -\\beta \\Delta t$：\n$$\n\\frac{\\Lambda_a}{\\beta \\Delta t} - \\delta_a + kq - 2k(I_0 + q(\\Lambda_b - \\Lambda_a)) = 0\n$$\n$$\n\\frac{\\alpha}{\\beta} - 2\\delta_a + kq - 2k I_0 - 2kq(\\Lambda_b - \\Lambda_a) = 0\n$$\n$$\n2\\delta_a = \\frac{\\alpha}{\\beta} + kq - 2k I_0 - 2kq(\\Lambda_b - \\Lambda_a) \\quad (2)\n$$\n我们现在得到了一个关于 $\\delta_b$ 和 $\\delta_a$ 的二元线性方程组。\n将 (1) 和 (2) 相加：\n$$\n2(\\delta_b + \\delta_a) = 2\\left(\\frac{\\alpha}{\\beta} + kq\\right) \\implies \\delta_b + \\delta_a = \\frac{\\alpha}{\\beta} + kq\n$$\n将 (1) 减去 (2)：\n$$\n2(\\delta_b - \\delta_a) = 4k I_0 + 4kq(\\Lambda_b - \\Lambda_a)\n$$\n代入 $\\Lambda_b - \\Lambda_a = (\\alpha - \\beta \\delta_b)\\Delta t - (\\alpha - \\beta \\delta_a)\\Delta t = \\beta \\Delta t (\\delta_a - \\delta_b)$：\n$$\n2(\\delta_b - \\delta_a) = 4k I_0 + 4kq\\beta \\Delta t (\\delta_a - \\delta_b) = 4k I_0 - 4kq\\beta \\Delta t (\\delta_b - \\delta_a)\n$$\n$$\n2(1 + 2kq\\beta \\Delta t)(\\delta_b - \\delta_a) = 4k I_0\n$$\n$$\n\\delta_b - \\delta_a = \\frac{2k I_0}{1 + 2kq\\beta \\Delta t}\n$$\n我们求解该方程组：\n$$\n\\delta_b + \\delta_a = \\frac{\\alpha}{\\beta} + kq\n$$\n$$\n\\delta_b - \\delta_a = \\frac{2k I_0}{1 + 2kq\\beta \\Delta t}\n$$\n将这两个方程相加得到 $2\\delta_b$：\n$$\n\\delta_b^\\star = \\frac{1}{2} \\left( \\frac{\\alpha}{\\beta} + kq \\right) + \\frac{k I_0}{1 + 2kq \\beta \\Delta t}\n$$\n用第一个方程减去第二个方程得到 $2\\delta_a$：\n$$\n\\delta_a^\\star = \\frac{1}{2} \\left( \\frac{\\alpha}{\\beta} + kq \\right) - \\frac{k I_0}{1 + 2kq \\beta \\Delta t}\n$$\n这些是在假设存在内部解的情况下的最优报价距离。目标函数 $F$ 的海森矩阵是常数且负定的，这确保了 $F$ 是严格凹函数，并且该驻点是唯一的全局最大值。问题指定了约束条件 $0 \\le \\delta_b, \\delta_a \\le \\alpha/\\beta$。所提供的解在其满足这些约束的参数区域内是有效的。一个完整的处理方法将涉及分析边界解，但这些表达式代表了从模型核心逻辑推导出的解析解。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} \\delta_b^\\star \\\\ \\delta_a^\\star \\end{pmatrix} = \\begin{pmatrix} \\frac{1}{2} \\left( \\frac{\\alpha}{\\beta} + kq \\right) + \\frac{k I_0}{1 + 2kq \\beta \\Delta t} \\\\ \\frac{1}{2} \\left( \\frac{\\alpha}{\\beta} + kq \\right) - \\frac{k I_0}{1 + 2kq \\beta \\Delta t} \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "最后的练习将前两个概念融会贯通，要求您构建一个完整的离散时间订单簿模拟，并引入一个基于规则的高频交易（HFT）智能体。您将通过编程模拟 ，亲手探索诸如亚美分定价（sub-penny pricing）等市场微观结构变化如何影响HFT策略的有效性及整个市场的流动性。这项实践将理论与代码相结合，揭示了单个智能体行为如何产生系统性的市场效应。",
            "id": "2406579",
            "problem": "构建一个完整的、可运行的程序，该程序在价格-时间优先原则下模拟一个离散时间的限价订单簿，以研究允许亚美分定价对订单队列动态和一种程式化高频交易 (HFT) 策略的影响。该模型必须按如下方式定义。\n\n该资产有一个以任意货币单位计量的固定参考价 $P^{\\ast}$。价格被限制在一个最小变动单位为 $\\Delta p$ 的网格上，因此任何报价都必须是 $\\Delta p$ 的倍数。将基准最佳买价和最佳卖价初始化为 $B_0 = P^{\\ast} - \\Delta p$ 和 $A_0 = P^{\\ast} + \\Delta p$。将基准最佳买价队列大小 $Q^0_B$ 和最佳卖价队列大小 $Q^0_A$（以单位计）初始化，二者均以整数计量。时间是离散的，步长为 $t \\in \\{1,2,\\ldots,T\\}$。在每个时间步，根据概率为 $p_{\\text{MB}}$、$p_{\\text{MS}}$、$p_{\\text{LB}}$、$p_{\\text{LS}}$ 和 $p_{\\text{C}}$（总和为 $1$）的分类分布，会发生一个且仅一个独立于过去的事件。五种事件类型如下：\n- 市价买单 (MB)，单位大小为 $1$：如果当前最佳卖价队列中有单位，则从中移除 $1$ 个单位。\n- 市价卖单 (MS)，单位大小为 $1$：如果当前最佳买价队列中有单位，则从中移除 $1$ 个单位。\n- 基准限价买单 (LB)，单位大小为 $1$：在价格 $B_t$ 处向基准最佳买价队列中添加 $1$ 个单位。\n- 基准限价卖单 (LS)，单位大小为 $1$：在价格 $A_t$ 处向基准最佳卖价队列中添加 $1$ 个单位。\n- 基准取消订单 (C)，单位大小为 $1$：从当前规模严格为正的基准最佳队列中恰好一个队列里移除 $1$ 个单位，该队列从符合条件的队列中均匀随机选择；如果两个基准最佳队列都为空，则此事件无效。\n\n价格-时间优先原则意味着交易在最高买价和最低卖价处执行；在同一价格水平内，执行优先级为先进先出，但由于模拟按边汇总了同质的单位大小订单，因此只需相应地更新总队列大小即可。对于所有 $t$，基准订单的价格 $B_t$ 和 $A_t$ 始终固定为 $B_t = P^{\\ast} - \\Delta p$ 和 $A_t = P^{\\ast} + \\Delta p$。\n\n引入一个程式化的高频交易（HFT）代理，其特征由以下参数定义：HFT 挂单数量 $q_{\\text{HFT}} \\in \\mathbb{Z}_{\\ge 0}$（单位）及其限价单的生存时间 $\\tau \\in \\mathbb{Z}_{\\ge 1}$（步）。该 HFT 代理在任何时候最多可以在一边将价格相对于基准最佳价格提高一个最小变动单位，这之所以可行，仅因为价格网格允许这样的价格改进。HFT 代理遵循以下规则：\n- 激活：在 LB 事件发生后，如果 $q_{\\text{HFT}} \\ge 1$，HFT 会立即在更优价格 $P^{\\ast}$（比基准最佳买价好一个最小变动单位）处挂出一个大小为 $q_{\\text{HFT}}$ 的买入限价单。在 LS 事件发生后，如果 $q_{\\text{HFT}} \\ge 1$，HFT 会立即在更优价格 $P^{\\ast}$（比基准最佳卖价好一个最小变动单位）处挂出一个大小为 $q_{\\text{HFT}}$ 的卖出限价单。如果 HFT 在另一边已有活动订单，则该订单在本次激活时被取消。在激活时（或在同一边重新激活时），HFT 订单的剩余数量将设置为 $q_{\\text{HFT}}$，其剩余生存时间将设置为 $\\tau$。\n- 优先级和价差：如果 HFT 在价格 $P^{\\ast}$ 有一个活动的买单，那么当前最佳买价变为 $P^{\\ast}$，而最佳卖价保持在 $A_t = P^{\\ast} + \\Delta p$，从而产生 $\\Delta p$ 的当前价差。如果 HFT 在价格 $P^{\\ast}$ 有一个活动的卖单，那么当前最佳卖价变为 $P^{\\ast}$，而最佳买价保持在 $B_t = P^{\\ast} - \\Delta p$，从而产生 $\\Delta p$ 的当前价差。如果 HFT 没有活动订单，则价差等于 $2\\Delta p$。\n- 与市价单的执行：市价买单（或市价卖单）由于价格更优，首先与任何活动的 HFT 卖单（或 HFT 买单）执行。如果 HFT 在该边存在剩余数量严格为正的订单，则成交一个单位，HFT 的剩余数量减 $1$，并且 HFT 立即通过向另一边的基准最佳队列提交一个单位大小的对冲市价单来中和其库存，如果另一边基准队列有单位，则该队列数量减 $1$。如果相关边没有 HFT 订单，则市价单会消耗相应基准最佳队列中的 $1$ 个单位（如果可用）。\n- HFT 订单生命周期：在每个时间步结束时，如果 HFT 有活动订单，其剩余生存时间减 $1$。如果剩余生存时间达到 $0$ 或剩余数量达到 $0$，HFT 将取消其订单（不再处于活动状态）。\n- HFT 利润核算：每个成交的 HFT 单位立即产生已实现利润，其金额等于另一边执行价格与 HFT 更优价格之间的同期价差，在此模型中，每个成交的 HFT 单位等于 $\\Delta p$。如果在时间步 $t$ 没有 HFT 成交，则 HFT 在该时间步的利润为 $0$。\n\n在时间范围 $\\{1,\\ldots,T\\}$ 内计算以下性能统计数据：\n- 平均价差：$\\frac{1}{T}\\sum_{t=1}^{T} \\left(A^{\\text{best}}_t - B^{\\text{best}}_t\\right)$，其中 $A^{\\text{best}}_t$ 和 $B^{\\text{best}}_t$ 是由上述 HFT 激活规则在时间 $t$ 所决定的最佳卖价和最佳买价。\n- 每步 HFT 成交率：HFT 单位总成交数除以 $T$。\n- 每步 HFT 平均利润：HFT 总利润除以 $T$。\n- 平均基准最佳队列大小：$\\frac{1}{T}\\sum_{t=1}^{T} \\left(Q_{B,t} + Q_{A,t}\\right)$，其中 $Q_{B,t}$ 和 $Q_{A,t}$ 是在时间步 $t$ 结束时的基准最佳买价和最佳卖价队列大小。\n\n除价格以任意货币单位计量外，所有数量都是无单位的。不涉及角度或物理单位。所有答案必须以浮点数表示。\n\n您的程序必须为以下测试套件运行模拟。每个元组列出了 $(\\Delta p, T, q_{\\text{HFT}}, \\tau, \\text{seed}, (p_{\\text{MB}}, p_{\\text{MS}}, p_{\\text{LB}}, p_{\\text{LS}}, p_{\\text{C}}))$。在所有测试用例中，使用 $P^{\\ast} = 100$，$Q^0_B = 10$，$Q^0_A = 10$，并且所有市价单、基准限价单和取消订单的单位大小均为 $1$。\n- 用例 $1$：$(0.01, 50000, 1, 50, 123, (0.2, 0.2, 0.25, 0.25, 0.1))$\n- 用例 $2$：$(0.001, 50000, 1, 50, 456, (0.2, 0.2, 0.25, 0.25, 0.1))$\n- 用例 $3$：$(0.001, 50000, 0, 50, 789, (0.2, 0.2, 0.25, 0.25, 0.1))$\n- 用例 $4$：$(0.005, 50000, 1, 50, 321, (0.2, 0.2, 0.25, 0.25, 0.1))$\n- 用例 $5$：$(0.001, 50000, 1, 50, 654, (0.15, 0.15, 0.15, 0.15, 0.4))$\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果本身是一个列表 `[avg_spread, hft_fill_rate, hft_profit_per_step, avg_baseline_queue]`，其中包含浮点数。例如，输出格式必须为\n$[[x_{1,1},x_{1,2},x_{1,3},x_{1,4}],[x_{2,1},x_{2,2},x_{2,3},x_{2,4}],[x_{3,1},x_{3,2},x_{3,3},x_{3,4}],[x_{4,1},x_{4,2},x_{4,3},x_{4,4}],[x_{5,1},x_{5,2},x_{5,3},x_{5,4}]]$\n该行中任何地方都不能有空格。",
            "solution": "该问题要求构建一个离散时间限价订单簿（LOB）的模拟模型，以分析高频交易（HFT）策略的影响。该问题定义明确，在计算金融领域有科学依据，其参数和规则的详细程度足以保证一个唯一的、可复现的解。\n\n解决方案是对指定的随机过程的直接实现。解决方案的核心是一个函数，该函数模拟 LOB 在 $T$ 个时间步长的时间范围内的演变。\n\n**1. 状态表示**\n系统在任何离散时间步 $t$ 的状态由一组变量完全描述：\n- $Q_{B,t}$：在价格 $P^{\\ast} - \\Delta p$ 的基准最佳买价队列中的静止单位数量。\n- $Q_{A,t}$：在价格 $P^{\\ast} + \\Delta p$ 的基准最佳卖价队列中的静止单位数量。\n- HFT 订单状态：一个表示 HFT 单个活动订单的结构，由其方向（买或卖）、剩余数量 $q_{\\text{rem}}$ 和剩余生存时间（TTL）$\\tau_{\\text{rem}}$ 定义。如果没有活动订单，其状态标记为‘无’。\n\n模拟在 $t=0$ 时开始，初始队列大小为 $Q^0_B$ 和 $Q^0_A$，且没有活动的 HFT 订单。\n\n**2. 模拟动态**\n模拟从 $t=1$ 进行到 $T$。在每个时间步内，遵循严格的操作序列来更新 LOB 的状态。\n\n**步骤 2.1：事件生成**\n在每个步骤 $t$ 的开始，从由概率 $(p_{\\text{MB}}, p_{\\text{MS}}, p_{\\text{LB}}, p_{\\text{LS}}, p_{\\text{C}})$ 定义的分类分布中抽取一个单一事件。五个可能的事件是：市价买单（MB）、市价卖单（MS）、基准限价买单（LB）、基准限价卖单（LS）和基准取消订单（C）。\n\n**步骤 2.2：状态转移逻辑**\n系统状态根据抽取的事件和 HFT 代理的规则进行更新。\n\n- **市价单（MB, MS）：** 如果在更优价格（价格 $P^{\\ast}$）存在 HFT 订单，市价单首先消耗 HFT 提供的流动性。市价买单（MB）消耗 HFT 的卖单，市价卖单（MS）消耗 HFT 的买单。\n    - 成交一个单位后，HFT 的订单数量 $q_{\\text{rem}}$ 会减少。\n    - HFT 的总成交量增加 $1$，其总利润增加定义的每次成交利润 $\\Delta p$。\n    - HFT 通过向另一边的基准队列发送一个大小为 $1$ 的对冲市价单，立即中和其获得的头寸。例如，在 HFT 买单成交后，HFT 提交一个市价卖单，消耗基准买价队列 $Q_{B,t}$ 中的一个单位。\n    - 如果相应边没有可用的 HFT 订单，市价单会消耗相应基准队列中的一个单位（MB 对应 $Q_{A,t}$，MS 对应 $Q_{B,t}$），前提是队列不为空。\n\n- **基准限价单（LB, LS）：** 基准限价买单（LB）使 $Q_{B,t}$ 增加 $1$，基准限价卖单（LS）使 $Q_{A,t}$ 增加 $1$。\n    - 紧随 LB 或 LS 事件之后，HFT 代理（如果 $q_{\\text{HFT}} \\ge 1$）会在更优价格 $P^{\\ast}$ 处下一个大小为 $q_{\\text{HFT}}$、TTL 为 $\\tau$ 的新限价单。LB 触发 HFT 买单，LS 触发 HFT 卖单。\n    - 下一个新的 HFT 订单会取消任何已存在的 HFT 订单，确保 HFT 在订单簿上最多只在一边活动。激活一个订单会将其数量重置为 $q_{\\text{HFT}}$，TTL 重置为 $\\tau$。\n\n- **基准取消订单（C）：** 从非空的基准队列（$Q_{B,t}$ 或 $Q_{A,t}$）之一中移除一个单位。如果两者都非空，则均匀随机选择一个。如果只有一个非空，则选择该队列。如果两者都为空，则没有影响。\n\n**步骤 2.3：步末更新**\n在事件逻辑完全处理完毕后，执行步末更新。\n- **HFT 订单生命周期：** 如果一个 HFT 订单是活动的，其 TTL，$\\tau_{\\text{rem}}$，会减少 $1$。然后检查该订单是否应被取消。如果其 TTL 已达到 $0$ 或其剩余数量 $q_{\\text{rem}}$ 已达到 $0$，该订单将从订单簿中移除（其状态设置为‘无’）。\n\n**3. 指标计算**\n性能统计数据在 $T$ 个时间步内进行汇总。在每个步骤 $t$ 的末尾，在所有状态转移和取消操作处理完毕后，记录以下指标：\n\n- **价差：** 计算最佳买卖价差 $A^{\\text{best}}_t - B^{\\text{best}}_t$。如果 HFT 有活动订单（在取消检查后），价差为 $\\Delta p$。否则，价差由基准队列决定，为 $2\\Delta p$。\n- **基准队列大小：** 记录基准队列的总大小 $Q_{B,t} + Q_{A,t}$。\n\n模拟完成后，通过将累积总数除以 $T$ 来计算最终的平均指标：\n- 平均价差：$\\frac{1}{T}\\sum_{t=1}^{T} (A^{\\text{best}}_t - B^{\\text{best}}_t)$\n- HFT 成交率：$\\frac{1}{T} \\times (\\text{总 HFT 成交数})$\n- HFT 平均利润：$\\frac{1}{T} \\times (\\text{总 HFT 利润})$\n- 平均基准队列大小：$\\frac{1}{T}\\sum_{t=1}^{T} (Q_{B,t} + Q_{A,t})$\n\n**4. 实现**\n该模拟使用 Python 实现，利用 `numpy` 库进行可复现的随机数生成，每个测试用例由指定的种子控制。上述逻辑被封装在一个将模型参数作为输入的函数中。一个主函数遍历所提供的测试用例，调用模拟，并将结果格式化为所要求的精确字符串格式。",
            "answer": "```python\nimport numpy as np\n\ndef run_simulation(delta_p, T, q_hft, tau, seed, probs):\n    \"\"\"\n    Runs a single simulation of the limit order book model.\n    \"\"\"\n    # Fixed parameters\n    P_star = 100.0\n    Q0_B = 10\n    Q0_A = 10\n    \n    # State variables\n    q_b = Q0_B\n    q_a = Q0_A\n    hft_order = {'side': 'none', 'qty': 0, 'ttl': 0}\n\n    # Statistics accumulators\n    total_spread = 0.0\n    total_hft_fills = 0\n    total_hft_profit = 0.0\n    total_baseline_queue_size = 0.0\n\n    # Setup random number generator\n    rng = np.random.default_rng(seed)\n    events = ['MB', 'MS', 'LB', 'LS', 'C']\n\n    for _ in range(T):\n        # Step 1: Draw event\n        event = rng.choice(events, p=probs)\n        \n        # Step 2: State Transition Logic\n        if event == 'MB':  # Market Buy\n            if hft_order['side'] == 'sell' and hft_order['qty'] > 0:\n                hft_order['qty'] -= 1\n                total_hft_fills += 1\n                total_hft_profit += delta_p\n                # HFT offset order (market buy against baseline ask to flatten inventory)\n                if q_a > 0:\n                    q_a -= 1\n            else:\n                if q_a > 0:\n                    q_a -= 1\n        \n        elif event == 'MS':  # Market Sell\n            if hft_order['side'] == 'buy' and hft_order['qty'] > 0:\n                hft_order['qty'] -= 1\n                total_hft_fills += 1\n                total_hft_profit += delta_p\n                # HFT offset order (market sell against baseline bid to flatten inventory)\n                if q_b > 0:\n                    q_b -= 1\n            else:\n                if q_b > 0:\n                    q_b -= 1\n        \n        elif event == 'LB':  # Baseline Limit Buy\n            q_b += 1\n            if q_hft >= 1:\n                hft_order = {'side': 'buy', 'qty': q_hft, 'ttl': tau}\n        \n        elif event == 'LS':  # Baseline Limit Sell\n            q_a += 1\n            if q_hft >= 1:\n                hft_order = {'side': 'sell', 'qty': q_hft, 'ttl': tau}\n        \n        elif event == 'C':  # Baseline Cancellation\n            can_cancel_b = q_b > 0\n            can_cancel_a = q_a > 0\n            if can_cancel_b and can_cancel_a:\n                if rng.random()  0.5:\n                    q_b -= 1\n                else:\n                    q_a -= 1\n            elif can_cancel_b:\n                q_b -= 1\n            elif can_cancel_a:\n                q_a -= 1\n\n        # Step 3: End-of-step HFT order lifecycle update\n        if hft_order['side'] != 'none':\n            hft_order['ttl'] -= 1\n            if hft_order['ttl'] = 0 or hft_order['qty'] = 0:\n                hft_order = {'side': 'none', 'qty': 0, 'ttl': 0}\n\n        # Step 4: Calculate and accumulate metrics for the current step t\n        current_spread = 2.0 * delta_p\n        if hft_order['side'] != 'none':\n            current_spread = delta_p\n        \n        total_spread += current_spread\n        total_baseline_queue_size += (q_b + q_a)\n\n    # Final calculation of average metrics\n    avg_spread = total_spread / T\n    hft_fill_rate = total_hft_fills / T\n    hft_avg_profit = total_hft_profit / T\n    avg_baseline_queue = total_baseline_queue_size / T\n\n    return [avg_spread, hft_fill_rate, hft_avg_profit, avg_baseline_queue]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.01, 50000, 1, 50, 123, (0.2, 0.2, 0.25, 0.25, 0.1)),\n        (0.001, 50000, 1, 50, 456, (0.2, 0.2, 0.25, 0.25, 0.1)),\n        (0.001, 50000, 0, 50, 789, (0.2, 0.2, 0.25, 0.25, 0.1)),\n        (0.005, 50000, 1, 50, 321, (0.2, 0.2, 0.25, 0.25, 0.1)),\n        (0.001, 50000, 1, 50, 654, (0.15, 0.15, 0.15, 0.15, 0.4)),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        delta_p, T, q_hft, tau, seed, probs = case\n        result = run_simulation(delta_p, T, q_hft, tau, seed, probs)\n        all_results.append(result)\n\n    # Format the output string exactly as specified\n    result_strings = []\n    for res_list in all_results:\n        # Format each float to a reasonable precision to avoid excessive length\n        inner_str = f\"[{','.join(f'{x:.8f}' for x in res_list)}]\"\n        result_strings.append(inner_str)\n    \n    final_output = f\"[{','.join(result_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```"
        }
    ]
}