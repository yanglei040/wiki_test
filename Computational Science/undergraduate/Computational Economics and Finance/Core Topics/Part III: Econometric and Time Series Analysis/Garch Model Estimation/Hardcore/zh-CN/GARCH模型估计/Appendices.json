{
    "hands_on_practices": [
        {
            "introduction": "GARCH模型的核心在于捕捉波动率聚集现象，即大的价格变动之后往往伴随着大的变动，而小的变动之后则伴随着小的变动。模型中的参数 $\\alpha_1$ 和 $\\beta_1$ 共同决定了波动冲击的持续性。为了更直观地理解这一点，我们可以计算“波动率半衰期”，这个练习将通过计算不同金融资产假设下的半衰期，帮助你将抽象的参数与一个具体、可解释的时间度量联系起来。",
            "id": "2395686",
            "problem": "考虑一个均值为零的收益过程 $\\left\\{r_t\\right\\}$ 的单变量广义自回归条件异方差（GARCH）模型，阶数为 $\\left(1,1\\right)$：\n$$r_t=\\epsilon_t,\\quad \\epsilon_t=\\sqrt{h_t}\\,z_t,$$\n其中 $\\left\\{z_t\\right\\}$ 是独立同分布的，满足 $\\mathbb{E}\\left[z_t\\right]=0$ 和 $\\mathbb{V}\\mathrm{ar}\\left[z_t\\right]=1$，且条件方差 $\\left\\{h_t\\right\\}$ 遵循\n$$h_t=\\omega+\\alpha_1\\,\\epsilon_{t-1}^2+\\beta_1\\,h_{t-1},$$\n参数为 $\\omega0$, $\\alpha_1\\ge 0$, $\\beta_1\\ge 0$。在协方差平稳性条件 $\\alpha_1+\\beta_11$ 下，单位波动率冲击的影响以 $\\alpha_1+\\beta_1$ 的速率呈几何衰减。将波动率冲击的半衰期定义为预期影响衰减至其初始量级一半所需的时期数 $k$，由下式给出：\n$$k=\\frac{\\ln\\left(0.5\\right)}{\\ln\\left(\\alpha_1+\\beta_1\\right)},$$\n其中 $\\ln\\left(\\cdot\\right)$ 表示自然对数。对于边界情况 $\\alpha_1+\\beta_1=1$，半衰期取为 $+\\infty$。\n\n您的任务是为以下每一组参数计算半衰期 $k$，每组参数代表一个不同的金融资产。将每一对 $\\left(\\alpha_1,\\beta_1\\right)$ 视为一个独立的测试用例。假设 $\\omega0$ 使得 $h_t$ 有良好定义，并且 $\\alpha_1,\\beta_1$ 满足所述的非负约束。使用约定，如果 $\\alpha_1+\\beta_1=1$，则该测试用例的输出必须为 $+\\infty$。\n\n测试套件（资产和参数）：\n- 资产 A: $\\alpha_1=0.05$, $\\beta_1=0.90$.\n- 资产 B: $\\alpha_1=0.05$, $\\beta_1=0.949$.\n- 资产 C: $\\alpha_1=0.10$, $\\beta_1=0.40$.\n- 资产 D: $\\alpha_1=0.10$, $\\beta_1=0.90$.\n- 资产 E: $\\alpha_1=0.02$, $\\beta_1=0.92$.\n\n对程序输出的要求：\n- 对于每个资产，使用上述公式计算半衰期 $k$。\n- 对于边界情况 $\\alpha_1+\\beta_1=1$，输出 $+\\infty$。\n- 对于所有有限的 $k$，四舍五入到恰好 $6$ 位小数。\n- 程序应生成单行输出，包含所有按 A, B, C, D, E 顺序排列的结果，格式为用方括号括起来的逗号分隔列表，无空格，例如 $\\left[\\text{result}_A,\\text{result}_B,\\text{result}_C,\\text{result}_D,\\text{result}_E\\right]$。\n- 在输出行中将 $+\\infty$ 直接表示为 $\\text{inf}$。\n\n不涉及物理单位。不涉及角度。每个测试用例的最终答案必须是浮点数，边界情况按规定用 $\\text{inf}$ 表示。解决方案应适用于上面提供的确切参数值，并遵守测试套件的顺序。",
            "solution": "所提出的问题在科学上是适定的，并为唯一解提供了充分的信息。任务是为广义自回归条件异方差（GARCH($1,1$)）过程在几种参数化下计算波动率冲击的半衰期。\n\n均值为零的收益序列 $r_t$ 的 GARCH($1,1$) 模型由以下方程定义：\n$$r_t = \\epsilon_t$$\n$$\\epsilon_t = \\sqrt{h_t} z_t$$\n其中 $\\{z_t\\}$ 是一个均值为零、方差为一的独立同分布（i.i.d.）过程。条件方差 $h_t$ 按以下方式演变：\n$$h_t = \\omega + \\alpha_1 \\epsilon_{t-1}^2 + \\beta_1 h_{t-1}$$\n波动率冲击的持续性由参数 $\\alpha_1$ 和 $\\beta_1$ 的和决定。这个和，我们记为 $S = \\alpha_1 + \\beta_1$，决定了过去冲击对未来条件方差影响的衰减速率。对于协方差平稳过程，要求 $S  1$。\n\n半衰期 $k$ 定义为冲击的预期影响衰减到其初始值的 $50\\%$ 所需的时间周期数。这由关系式 $(\\alpha_1 + \\beta_1)^k = 0.5$ 控制。求解 $k$ 可得公式：\n$$k = \\frac{\\ln(0.5)}{\\ln(\\alpha_1 + \\beta_1)}$$\n此公式在 $\\alpha_1 + \\beta_1  1$ 时有效。一个介于 $0$ 和 $1$ 之间的数的对数是负数，因此分子和分母都为负，从而得到一个正的半衰期 $k$。\n\n在 $\\alpha_1 + \\beta_1 = 1$ 的特殊情况下，该过程被称为积分GARCH（IGARCH）模型。在此机制下，冲击对条件方差具有无限持续的影响，因此半衰期 $k$ 取为 $+\\infty$。\n\n我们现在将为每个指定的参数集计算半衰期。\n\n1.  **资产 A**：参数为 $\\alpha_1 = 0.05$ 和 $\\beta_1 = 0.90$。\n    持续性为 $S = 0.05 + 0.90 = 0.95$。\n    半衰期计算如下：\n    $$k_A = \\frac{\\ln(0.5)}{\\ln(0.95)} \\approx \\frac{-0.693147}{-0.051293} \\approx 13.513427$$\n    结果四舍五入到 $6$ 位小数是 $13.513427$。\n\n2.  **资产 B**：参数为 $\\alpha_1 = 0.05$ 和 $\\beta_1 = 0.949$。\n    持续性为 $S = 0.05 + 0.949 = 0.999$。这表明持续性非常高。\n    半衰期计算如下：\n    $$k_B = \\frac{\\ln(0.5)}{\\ln(0.999)} \\approx \\frac{-0.693147}{-0.0010005} \\approx 692.800063$$\n    结果四舍五入到 $6$ 位小数是 $692.800063$。\n\n3.  **资产 C**：参数为 $\\alpha_1 = 0.10$ 和 $\\beta_1 = 0.40$。\n    持续性为 $S = 0.10 + 0.40 = 0.50$。\n    半衰期计算如下：\n    $$k_C = \\frac{\\ln(0.5)}{\\ln(0.5)} = 1$$\n    结果表示为 $6$ 位小数是 $1.000000$。\n\n4.  **资产 D**：参数为 $\\alpha_1 = 0.10$ 和 $\\beta_1 = 0.90$。\n    持续性为 $S = 0.10 + 0.90 = 1.0$。\n    这对应于 IGARCH 边界情况。半衰期是无限的。\n    $$k_D = +\\infty$$\n\n5.  **资产 E**：参数为 $\\alpha_1 = 0.02$ 和 $\\beta_1 = 0.92$。\n    持续性为 $S = 0.02 + 0.92 = 0.94$。\n    半衰期计算如下：\n    $$k_E = \\frac{\\ln(0.5)}{\\ln(0.94)} \\approx \\frac{-0.693147}{-0.061875} \\approx 11.202302$$\n    结果四舍五入到 $6$ 位小数是 $11.202302$。\n\n最终结果按要求编译成一个列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the volatility shock half-life for a GARCH(1,1) model\n    for a given test suite of parameters.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple contains (alpha_1, beta_1) for an asset.\n    test_cases = [\n        (0.05, 0.90),   # Asset A\n        (0.05, 0.949),  # Asset B\n        (0.10, 0.40),   # Asset C\n        (0.10, 0.90),   # Asset D\n        (0.02, 0.92)    # Asset E\n    ]\n\n    results = []\n    for alpha_1, beta_1 in test_cases:\n        # Calculate the shock persistence parameter\n        persistence = alpha_1 + beta_1\n\n        # Check for the boundary case (IGARCH) where persistence is 1.\n        # np.isclose is used for safe floating-point comparison.\n        if np.isclose(persistence, 1.0):\n            result_str = 'inf'\n        else:\n            # Calculate the half-life k using the provided formula.\n            # k = ln(0.5) / ln(alpha_1 + beta_1)\n            half_life = np.log(0.5) / np.log(persistence)\n            # Format the result to exactly 6 decimal places.\n            result_str = f\"{half_life:.6f}\"\n        \n        results.append(result_str)\n\n    # Final print statement in the exact required format.\n    # The format is a comma-separated list of results enclosed in square brackets.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "最大似然估计是拟合GARCH模型的标准方法，其核心是求解对数似然函数关于模型参数的梯度。通过从第一性原理推导并实现这个梯度，我们可以深入理解优化算法（如拟牛顿法）的内部工作机制。这个练习不仅是一次重要的数学推导实践，也揭示了模型参数如何通过每一个数据点影响似然函数，从而加深对估计过程本身的理解。",
            "id": "2395726",
            "problem": "考虑一个单变量收益率序列 $\\{r_t\\}_{t=1}^T$，该序列由一个条件均值为零且误差服从正态分布的$\\left(1,1\\right)$阶广义自回归条件异方差（GARCH）模型建模。该模型由下式给出\n$$\nr_t = \\varepsilon_t, \\quad \\varepsilon_t \\mid \\mathcal{F}_{t-1} \\sim \\mathcal{N}\\!\\left(0, h_t\\right),\n$$\n其条件方差动态为\n$$\nh_t = \\omega + \\alpha \\,\\varepsilon_{t-1}^2 + \\beta \\,h_{t-1},\n$$\n对于所有 $t \\in \\{1,\\dots,T\\}$，其中参数向量为 $\\theta = \\left(\\omega,\\alpha,\\beta\\right)$，且满足 $\\omega  0$，$\\alpha \\ge 0$，$\\beta \\ge 0$ 和 $\\alpha + \\beta  1$。在正态分布假设下，样本的对数似然为\n$$\n\\ell\\!\\left(\\theta\\right) = -\\frac{1}{2}\\sum_{t=1}^{T}\\left[\\log\\!\\left(2\\pi\\right) + \\log\\!\\left(h_t\\right) + \\frac{\\varepsilon_t^2}{h_t}\\right].\n$$\n假设初始化为\n$$\nh_0 = \\frac{\\omega}{1-\\alpha-\\beta}, \\qquad \\varepsilon_0^2 = h_0.\n$$\n\n任务：\n1. 从第一性原理出发，推导在上述初始化条件下，总对数似然 $\\ell\\!\\left(\\theta\\right)$ 关于 $\\theta = \\left(\\omega,\\alpha,\\beta\\right)$ 的解析梯度向量。\n2. 实现一个程序，在给定数据和参数向量 $\\theta$ 的情况下，计算在 $\\theta$ 处的解析梯度（而非数值近似值）。\n\n测试套件：\n- 使用以下给定的长度为 $T = 12$ 的收益率序列\n$$\n\\{r_t\\}_{t=1}^{12} = \\{\\,0.004,\\,-0.002,\\,0.006,\\,0.000,\\,-0.007,\\,0.005,\\,-0.0035,\\,0.001,\\,0.000,\\,0.0045,\\,-0.0025,\\,0.003\\,\\}.\n$$\n- 在以下四个参数向量处评估梯度，每个向量都满足 $\\omega  0$，$\\alpha \\ge 0$，$\\beta \\ge 0$ 和 $\\alpha + \\beta  1$：\n  1. $\\theta_1 = \\left(0.00001,\\,0.05,\\,0.90\\right)$,\n  2. $\\theta_2 = \\left(0.00001,\\,0.09,\\,0.90\\right)$,\n  3. $\\theta_3 = \\left(0.00002,\\,0.00,\\,0.80\\right)$,\n  4. $\\theta_4 = \\left(0.00002,\\,0.10,\\,0.00\\right)$。\n\n要求的最终输出格式：\n- 您的程序必须生成单行输出，其中包含四个测试用例的梯度向量列表，顺序与上文所列相同，形式为用方括号括起来的逗号分隔列表。每个梯度向量表示为一个包含三个实数的列表，顺序为 $\\left[\\frac{\\partial \\ell}{\\partial \\omega},\\,\\frac{\\partial \\ell}{\\partial \\alpha},\\,\\frac{\\partial \\ell}{\\partial \\beta}\\right]$。例如，输出的形式应为\n$$\n\\big[\\,[g_{1,\\omega}, g_{1,\\alpha}, g_{1,\\beta}],\\,[g_{2,\\omega}, g_{2,\\alpha}, g_{2,\\beta}],\\,[g_{3,\\omega}, g_{3,\\alpha}, g_{3,\\beta}],\\,[g_{4,\\omega}, g_{4,\\alpha}, g_{4,\\beta}]\\,\\big].\n$$\n\n所有答案均为实数，不涉及物理单位。不涉及角度。如果在计算过程中出现百分比，最终输出时必须表示为小数。输出必须严格按照上述格式，且仅占一行。",
            "solution": "题目要求推导并实现 GARCH($1$,$1$) 模型对数似然的解析梯度。问题陈述在科学上是合理的，在数学上是适定的，并且是完整的。我们开始进行求解。\n\n指定的针对收益率序列 $\\{r_t\\}_{t=1}^T$ 且条件均值为零的 GARCH($1$,$1$) 模型为：\n$$\nr_t = \\varepsilon_t, \\quad \\varepsilon_t \\mid \\mathcal{F}_{t-1} \\sim \\mathcal{N}(0, h_t)\n$$\n$$\nh_t = \\omega + \\alpha \\varepsilon_{t-1}^2 + \\beta h_{t-1}\n$$\n参数向量为 $\\theta = (\\omega, \\alpha, \\beta)^T$。对于大小为 $T$ 的样本，其对数似然函数由下式给出：\n$$\n\\ell(\\theta) = -\\frac{1}{2}\\sum_{t=1}^{T}\\left[\\log(2\\pi) + \\log(h_t) + \\frac{r_t^2}{h_t}\\right]\n$$\n其中我们根据模型定义代入了 $\\varepsilon_t = r_t$。\n\n梯度向量 $\\nabla_\\theta \\ell(\\theta)$ 的分量为 $\\frac{\\partial \\ell}{\\partial \\omega}$、$\\frac{\\partial \\ell}{\\partial \\alpha}$ 和 $\\frac{\\partial \\ell}{\\partial \\beta}$。设 $\\theta_j$ 是 $\\theta$ 的一个通用分量。对求和应用链式法则，可得到总对数似然关于 $\\theta_j$ 的偏导数：\n$$\n\\frac{\\partial \\ell}{\\partial \\theta_j} = \\sum_{t=1}^{T} \\frac{\\partial}{\\partial \\theta_j} \\left(-\\frac{1}{2} \\left[ \\log(h_t) + \\frac{r_t^2}{h_t} \\right]\\right) = \\sum_{t=1}^{T} \\left( -\\frac{1}{2} \\left[ \\frac{1}{h_t} - \\frac{r_t^2}{h_t^2} \\right] \\right) \\frac{\\partial h_t}{\\partial \\theta_j}\n$$\n此表达式可简化为：\n$$\n\\frac{\\partial \\ell}{\\partial \\theta_j} = \\sum_{t=1}^{T} \\frac{1}{2h_t^2} \\left( r_t^2 - h_t \\right) \\frac{\\partial h_t}{\\partial \\theta_j}\n$$\n为评估此梯度，我们必须计算条件方差的时间序列 $\\{h_t\\}_{t=1}^T$ 及其关于每个参数的偏导数序列 $\\{\\frac{\\partial h_t}{\\partial \\theta_j}\\}_{t=1}^T$。这些都可以通过从 GARCH($1$,$1$) 方差方程推导出的递推关系得到。\n\n首先，我们建立 $\\{h_t\\}$ 的递推关系。问题指定了初始化 $h_0 = \\frac{\\omega}{1-\\alpha-\\beta}$ 和 $\\varepsilon_0^2 = h_0$。对于 $t1$，$\\varepsilon_{t-1}^2 = r_{t-1}^2$ 由数据给出。在 $t=1$ 时的条件方差为：\n$$\nh_1 = \\omega + \\alpha \\varepsilon_0^2 + \\beta h_0 = \\omega + (\\alpha + \\beta) h_0 = \\omega + (\\alpha + \\beta) \\frac{\\omega}{1-\\alpha-\\beta} = \\frac{\\omega(1-\\alpha-\\beta) + \\omega(\\alpha+\\beta)}{1-\\alpha-\\beta} = \\frac{\\omega}{1-\\alpha-\\beta}\n$$\n这就是该过程的无条件方差。对于 $t=2, \\dots, T$，方差通过递推计算：\n$$\nh_t = \\omega + \\alpha r_{t-1}^2 + \\beta h_{t-1}\n$$\n\n接下来，我们推导 $h_t$ 偏导数的递推公式。\n\n**1. 关于 $\\omega$ 的导数**\n我们将 $h_t$ 的表达式对 $\\omega$ 求导。\n对于 $t=1$：\n$$ \\frac{\\partial h_1}{\\partial \\omega} = \\frac{\\partial}{\\partial \\omega} \\left(\\frac{\\omega}{1-\\alpha-\\beta}\\right) = \\frac{1}{1-\\alpha-\\beta} $$\n对于 $t  1$：\n$$ \\frac{\\partial h_t}{\\partial \\omega} = \\frac{\\partial}{\\partial \\omega} (\\omega + \\alpha r_{t-1}^2 + \\beta h_{t-1}) = 1 + \\beta \\frac{\\partial h_{t-1}}{\\partial \\omega} $$\n这为 $\\{\\frac{\\partial h_t}{\\partial \\omega}\\}_{t=1}^T$ 定义了一个简单的线性递推关系。\n\n**2. 关于 $\\alpha$ 的导数**\n我们对 $\\alpha$ 求导。对于 $t=1$：\n$$ \\frac{\\partial h_1}{\\partial \\alpha} = \\frac{\\partial}{\\partial \\alpha} \\left(\\frac{\\omega}{1-\\alpha-\\beta}\\right) = \\omega(-1)(1-\\alpha-\\beta)^{-2}(-1) = \\frac{\\omega}{(1-\\alpha-\\beta)^2} $$\n对于 $t  1$，$r_{t-1}^2$ 是一个固定的数据点，其关于 $\\alpha$ 的导数为零：\n$$ \\frac{\\partial h_t}{\\partial \\alpha} = \\frac{\\partial}{\\partial \\alpha} (\\omega + \\alpha r_{t-1}^2 + \\beta h_{t-1}) = r_{t-1}^2 + \\beta \\frac{\\partial h_{t-1}}{\\partial \\alpha} $$\n\n**3. 关于 $\\beta$ 的导数**\n我们对 $\\beta$ 求导。对于 $t=1$：\n$$ \\frac{\\partial h_1}{\\partial \\beta} = \\frac{\\partial}{\\partial \\beta} \\left(\\frac{\\omega}{1-\\alpha-\\beta}\\right) = \\omega(-1)(1-\\alpha-\\beta)^{-2}(-1) = \\frac{\\omega}{(1-\\alpha-\\beta)^2} $$\n对于 $t  1$：\n$$ \\frac{\\partial h_t}{\\partial \\beta} = \\frac{\\partial}{\\partial \\beta} (\\omega + \\alpha r_{t-1}^2 + \\beta h_{t-1}) = h_{t-1} + \\beta \\frac{\\partial h_{t-1}}{\\partial \\beta} $$\n\n**算法摘要**\n\n为计算给定参数集 $\\theta = (\\omega, \\alpha, \\beta)$ 和收益率序列 $\\{r_t\\}_{t=1}^T$ 的梯度向量 $\\nabla_\\theta \\ell(\\theta)$，我们执行以下步骤：\n\n1.  初始化长度为 $T$ 的数组，用于存储序列 $h_t$、$\\frac{\\partial h_t}{\\partial \\omega}$、$\\frac{\\partial h_t}{\\partial \\alpha}$ 和 $\\frac{\\partial h_t}{\\partial \\beta}$（$t=1, \\dots, T$）。\n2.  计算 $t=1$ 时的初始值：\n    -   $h_1 = \\frac{\\omega}{1-\\alpha-\\beta}$\n    -   $\\frac{\\partial h_1}{\\partial \\omega} = \\frac{1}{1-\\alpha-\\beta}$\n    -   $\\frac{\\partial h_1}{\\partial \\alpha} = \\frac{\\omega}{(1-\\alpha-\\beta)^2}$\n    -   $\\frac{\\partial h_1}{\\partial \\beta} = \\frac{\\omega}{(1-\\alpha-\\beta)^2}$\n3.  从 $t=2$ 迭代到 $T$，使用先前计算的 $t-1$ 时的值来计算每个序列的值：\n    -   $h_t = \\omega + \\alpha r_{t-1}^2 + \\beta h_{t-1}$\n    -   $\\frac{\\partial h_t}{\\partial \\omega} = 1 + \\beta \\frac{\\partial h_{t-1}}{\\partial \\omega}$\n    -   $\\frac{\\partial h_t}{\\partial \\alpha} = r_{t-1}^2 + \\beta \\frac{\\partial h_{t-1}}{\\partial \\alpha}$\n    -   $\\frac{\\partial h_t}{\\partial \\beta} = h_{t-1} + \\beta \\frac{\\partial h_{t-1}}{\\partial \\beta}$\n4.  将梯度分量 $(\\frac{\\partial \\ell}{\\partial \\omega}, \\frac{\\partial \\ell}{\\partial \\alpha}, \\frac{\\partial \\ell}{\\partial \\beta})$ 初始化为零。\n5.  从 $t=1$ 迭代到 $T$，计算每个时间步对总梯度的贡献并累加求和：\n    -   公共因子： $c_t = \\frac{1}{2h_t^2} ( r_t^2 - h_t )$\n    -   $\\frac{\\partial \\ell}{\\partial \\omega} \\mathrel{+}= c_t \\cdot \\frac{\\partial h_t}{\\partial \\omega}$\n    -   $\\frac{\\partial \\ell}{\\partial \\alpha} \\mathrel{+}= c_t \\cdot \\frac{\\partial h_t}{\\partial \\alpha}$\n    -   $\\frac{\\partial \\ell}{\\partial \\beta} \\mathrel{+}= c_t \\cdot \\frac{\\partial h_t}{\\partial \\beta}$\n6.  最终累加的和构成了梯度向量。此过程在提供的程序中实现。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_garch_gradient(r, omega, alpha, beta):\n    \"\"\"\n    Computes the analytical gradient of the GARCH(1,1) log-likelihood.\n\n    Args:\n        r (np.ndarray): The series of returns.\n        omega (float): GARCH parameter omega.\n        alpha (float): GARCH parameter alpha.\n        beta (float): GARCH parameter beta.\n\n    Returns:\n        list[float]: The gradient vector [d_ell/d_omega, d_ell/d_alpha, d_ell/d_beta].\n    \"\"\"\n    T = len(r)\n    r_sq = r**2\n\n    # Arrays to store h_t and its derivatives\n    h = np.zeros(T)\n    dh_domega = np.zeros(T)\n    dh_dalpha = np.zeros(T)\n    dh_dbeta = np.zeros(T)\n    \n    # Check for stationarity condition to avoid division by zero\n    stat_denom = 1.0 - alpha - beta\n    if stat_denom = 0:\n        # Parameters violate the stationarity constraint, which would make h0 infinite or negative.\n        # This case is not expected for the given valid test cases but is good practice.\n        return [np.nan, np.nan, np.nan]\n\n    # Initialization for t=1 (index 0)\n    # h_1 = omega / (1 - alpha - beta)\n    h[0] = omega / stat_denom\n    \n    # Derivatives of h_1\n    # dh1/d_omega = 1 / (1 - alpha - beta)\n    dh_domega[0] = 1.0 / stat_denom\n    # dh1/d_alpha = omega / (1 - alpha - beta)^2\n    dh_dalpha[0] = omega / (stat_denom**2)\n    # dh1/d_beta = omega / (1 - alpha - beta)^2\n    dh_dbeta[0] = omega / (stat_denom**2)\n    \n    # Recursive calculation for t = 2 to T (indices 1 to T-1)\n    for t in range(1, T):\n        # h_t = omega + alpha * r_{t-1}^2 + beta * h_{t-1}\n        h[t] = omega + alpha * r_sq[t-1] + beta * h[t-1]\n        \n        # dh_t/d_omega = 1 + beta * dh_{t-1}/d_omega\n        dh_domega[t] = 1.0 + beta * dh_domega[t-1]\n        \n        # dh_t/d_alpha = r_{t-1}^2 + beta * dh_{t-1}/d_alpha\n        dh_dalpha[t] = r_sq[t-1] + beta * dh_dalpha[t-1]\n        \n        # dh_t/d_beta = h_{t-1} + beta * dh_{t-1}/d_beta\n        dh_dbeta[t] = h[t-1] + beta * dh_dbeta[t-1]\n        \n    # Compute the gradient of the log-likelihood\n    grad_omega = 0.0\n    grad_alpha = 0.0\n    grad_beta = 0.0\n    \n    for t in range(T):\n        common_factor = 0.5 * (r_sq[t] / h[t] - 1.0) / h[t]\n        grad_omega += common_factor * dh_domega[t]\n        grad_alpha += common_factor * dh_dalpha[t]\n        grad_beta += common_factor * dh_dbeta[t]\n\n    return [grad_omega, grad_alpha, grad_beta]\n\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    \"\"\"\n    # Define the data and test cases from the problem statement.\n    returns_data = np.array([\n        0.004, -0.002, 0.006, 0.000, -0.007, 0.005, \n        -0.0035, 0.001, 0.000, 0.0045, -0.0025, 0.003\n    ])\n    \n    test_cases = [\n        (0.00001, 0.05, 0.90),  # theta_1\n        (0.00001, 0.09, 0.90),  # theta_2\n        (0.00002, 0.00, 0.80),  # theta_3\n        (0.00002, 0.10, 0.00)   # theta_4\n    ]\n\n    results = []\n    for params in test_cases:\n        omega, alpha, beta = params\n        gradient = compute_garch_gradient(returns_data, omega, alpha, beta)\n        results.append(gradient)\n\n    # Format the results into the required string format.\n    # The string representation of a list in Python already includes brackets and spaces.\n    # Joining the string representations of each gradient list with a comma\n    # and enclosing in outer brackets produces the desired format.\n    # e.g., \"[[g1_w, g1_a, g1_b],[g2_w, g2_a, g2_b]]\"\n    result_str = f\"[{','.join(map(str, results))}]\"\n    \n    # To remove spaces for a more compact representation, though not strictly required by example\n    result_str_no_space = result_str.replace(\" \", \"\")\n\n    print(result_str_no_space)\n\nsolve()\n```"
        },
        {
            "introduction": "一个优秀建模者的关键技能是区分真实的数据模式与模型设定错误所产生的假象。本练习将展示一个经典的计量经济学情景：如果一个时间序列的均值发生了未被识别的结构性突变，标准的统计检验可能会错误地将其识别为GARCH效应。通过这个实践，你将学到在应用复杂模型前检验基本假设（如均值稳定性）的重要性，并理解错误的模型设定会如何误导我们的结论。",
            "id": "2399496",
            "problem": "你的任务是设计并实现一个模拟和测试程序，用于研究时间序列均值的结构性突变如何被自回归条件异方差的标准检验错误地识别为一阶广义自回归条件异方差（表示为 $GARCH(1,1)$）。你的程序必须完全自包含，并且无需任何用户交互即可产生结果。\n\n需要使用的基本原理包括以下经过充分检验的定义和事实。\n\n- 如果一个时间序列 $\\{y_t\\}_{t=1}^T$ 的确定性均值在 $t = T_b + 1$ 时从 $\\mu_1$ 变为 $\\mu_2$，而创新项方差保持不变，则称该序列在已知时间 $T_b$ 处存在均值结构性突变。具体来说，当 $t \\le T_b$ 时，$y_t = \\mu_1 + \\varepsilon_t$；当 $t  T_b$ 时，$y_t = \\mu_2 + \\varepsilon_t$，其中 $\\varepsilon_t \\overset{iid}{\\sim} \\mathcal{N}(0,\\sigma^2)$。\n- 普通最小二乘（OLS）均值模型为 $y_t = x_t^{\\prime}\\beta + \\varepsilon_t$，其中 $x_t$ 包含一个截距项，并在适用时包含额外的回归变量，例如一个突变虚拟变量 $d_t$，其中当 $t \\le T_b$ 时 $d_t = 0$，当 $t  T_b$ 时 $d_t = 1$。OLS 残差为 $e_t = y_t - x_t^{\\prime}\\hat{\\beta}$。\n- 针对零均值创新项 $\\{u_t\\}$ 的 $GARCH(1,1)$ 模型为 $u_t = \\sqrt{h_t} z_t$，其中 $z_t \\overset{iid}{\\sim} \\mathcal{N}(0,1)$，条件方差 $h_t = \\omega + \\alpha u_{t-1}^2 + \\beta h_{t-1}$。参数满足 $\\omega  0$、$\\alpha \\ge 0$、$\\beta \\ge 0$ 和 $\\alpha + \\beta  1$，以确保有限的无条件方差。观测序列为 $y_t = \\mu + u_t$。\n- 对 OLS 残差序列 $\\{e_t\\}$ 进行的 Engle 拉格朗日乘数（LM）检验（用于检验 $q$ 阶自回归条件异方差）的过程是：将 $e_t^2$ 对一个常数项和 $q$ 阶滞后的 $e_t^2$ 进行回归，计算决定系数 $R^2$，并构建统计量 $LM = n R^2$，其中 $n$ 是该回归中可用的观测数。在不存在直至 $q$ 阶的自回归条件异方差的原假设下，$LM$ 渐近服从 $\\chi^2_q$ 分布。$p$ 值为 $1 - F_{\\chi^2_q}(LM)$，其中 $F_{\\chi^2_q}$ 是自由度为 $q$ 的卡方分布的累积分布函数。\n\n你的任务是精确地实现以下步骤。\n\n1. 数据生成过程（DGP）的模拟：\n   - 恒定方差下的均值结构性突变：对于给定的参数 $T$、$\\mu_1$、$\\mu_2$、$\\sigma$ 和突变比例 $b \\in (0,1)$，模拟 $\\{y_t\\}$，其中 $T_b = \\lfloor b T \\rfloor$ 且 $\\varepsilon_t \\overset{iid}{\\sim} \\mathcal{N}(0,\\sigma^2)$，如上所述。\n   - 无突变的独立同分布（iid）同方差序列：$y_t = \\mu + \\varepsilon_t$，$\\varepsilon_t \\overset{iid}{\\sim} \\mathcal{N}(0,\\sigma^2)$。\n   - 无均值突变的 $GARCH(1,1)$ 序列：$y_t = \\mu + u_t$，其中 $u_t$ 遵循上述定义的 $GARCH(1,1)$ 过程。将 $h_0$ 初始化为无条件方差 $h_0 = \\omega/(1-\\alpha-\\beta)$，并使用 500 步的初始预烧期以减轻初始化效应。\n\n2. 建模和残差提取：\n   - 对每个模拟序列，拟合两个 OLS 均值模型以获得残差 $\\{e_t\\}$：\n     - 错误设定的均值：对所有 $t$ 使用仅含截距项的模型 $x_t = [1]$。\n     - 正确设定的均值：当 DGP 存在结构性突变时，使用截距项加突变虚拟变量，即 $x_t = [1, d_t]$；否则使用仅含截距项的模型。\n\n3. 自回归条件异方差检验：\n   - 对每组残差和指定的滞后阶数 $q$，运行上述 Engle LM 检验，并基于 $\\chi^2_q$ 分布计算 $p$ 值。\n\n4. 解释原则（用于你的推理，不作为输出的一部分）：低 p 值表示拒绝无自回归条件异方差的原假设。要观察的核心现象是，当均值设定错误时，均值的结构性突变会在 $e_t^2$ 中引起序列相关性，从而导致对 GARCH 类型行为的伪检测。\n\n使用以下参数集测试套件。所有随机抽样必须使用相同的固定种子 $12345$ 生成，以确保结果可复现。\n\n- 测试用例 1（理想路径，样本中期强突变）：\n  - DGP：恒定方差下的结构性均值突变。\n  - 参数：$T = 4000$，$\\mu_1 = 0.0$，$\\mu_2 = 2.0$，$\\sigma = 1.0$，$b = 0.5$，$q = 5$。\n\n- 测试用例 2（边界条件，后期突变，检验中最小滞后）：\n  - DGP：恒定方差下的结构性均值突变。\n  - 参数：$T = 4000$，$\\mu_1 = 0.0$，$\\mu_2 = 3.0$，$\\sigma = 1.0$，$b = 0.9$，$q = 1$。\n\n- 测试用例 3（边缘案例，真实的 $GARCH(1,1)$）：\n  - DGP：无均值突变的 $GARCH(1,1)$。\n  - 参数：$T = 5000$，$\\mu = 0.0$，$\\omega = 0.1$，$\\alpha = 0.05$，$\\beta = 0.9$，$q = 5$。\n\n- 测试用例 4（对照组，独立同分布同方差）：\n  - DGP：无均值突变的同方差 iid。\n  - 参数：$T = 4000$，$\\mu = 0.0$，$\\sigma = 1.0$，$q = 5$。\n\n每个测试用例的所需输出：\n\n- 对于每个测试用例 $i \\in \\{1,2,3,4\\}$，计算两个 $p$ 值：\n  - $p^{(i)}_{\\text{misspec}}$：使用仅含截距项均值模型的 LM 检验 p 值。\n  - $p^{(i)}_{\\text{well}}$：使用正确设定均值模型（仅在适用时包含突变虚拟变量）的 LM 检验 p 值。\n\n最终输出格式：\n\n- 你的程序应生成单行输出，其中包含 8 个结果，形式为方括号内以逗号分隔的列表，并严格按照以下顺序排列：\n  $[p^{(1)}_{\\text{misspec}}, p^{(1)}_{\\text{well}}, p^{(2)}_{\\text{misspec}}, p^{(2)}_{\\text{well}}, p^{(3)}_{\\text{misspec}}, p^{(3)}_{\\text{well}}, p^{(4)}_{\\text{misspec}}, p^{(4)}_{\\text{well}}]$，\n  每个值四舍五入到六位小数。例如，输出可能看起来像 $[0.000001,0.845210,0.000004,0.612345,0.000000,0.000000,0.523410,0.523410]$。\n\n此问题中的所有量都是无单位的实数，不涉及任何物理单位。不使用角度。当概念上引用百分比时，必须将其视为小数；但是，您必须仅输出如上所述的指定 p 值。",
            "solution": "该问题陈述已经过严格验证，并被认定为有效。它在科学上基于已建立的计量经济学理论，特别是时间序列模型设定错误的研究。该问题是良定的，为获得唯一、可验证的解提供了完整且一致的定义、参数和程序。不存在逻辑矛盾、歧义或事实不准确之处。该任务是计量经济学中的一个标准计算练习，而非征求主观意见或推测性推理。我们现在着手进行系统性求解。\n\n目标是通过计算来证明，如果时间序列均值中的结构性突变未被正确建模，可能会产生自回归条件异方差（ARCH）的伪证据，这种现象在实践中可能导致错误模型选择。解决方案分为三个主要阶段：数据模拟、模型估计与残差提取、以及假设检验。\n\n首先，我们按规定处理三种不同数据生成过程（DGP）的模拟。所有随机操作均使用固定的随机种子 $12345$，以确保可复现性。\n\n1.  **结构性突变序列**：根据以下模型生成一个长度为 $T$ 且均值存在单次突变的时间序列 $\\{y_t\\}_{t=1}^T$：\n    $$\n    y_t =\n    \\begin{cases}\n    \\mu_1 + \\varepsilon_t  \\text{当 } t \\le T_b \\\\\n    \\mu_2 + \\varepsilon_t  \\text{当 } t  T_b\n    \\end{cases}\n    $$\n    其中突变点为 $T_b = \\lfloor bT \\rfloor$（给定突变比例 $b \\in (0,1)$），创新项 $\\varepsilon_t$ 是从正态分布 $\\varepsilon_t \\overset{iid}{\\sim} \\mathcal{N}(0, \\sigma^2)$ 中独立同分布（iid）抽取的样本。\n\n2.  **GARCH(1,1) 序列**：生成一个由广义自回归条件异方差过程 $(1,1)$ 控制的时间序列 $\\{y_t\\}_{t=1}^T$，其形式为 $y_t = \\mu + u_t$。创新项 $u_t$ 定义为 $u_t = \\sqrt{h_t} z_t$，其中 $z_t \\overset{iid}{\\sim} \\mathcal{N}(0,1)$。条件方差 $h_t$ 按以下方式演化：\n    $$\n    h_t = \\omega + \\alpha u_{t-1}^2 + \\beta h_{t-1}\n    $$\n    参数必须满足平稳性条件 $\\omega  0$、$\\alpha \\ge 0$、$\\beta \\ge 0$ 和 $\\alpha + \\beta  1$。模拟从 $h_0$ 设置为无条件方差 $h_{uncond} = \\frac{\\omega}{1-\\alpha-\\beta}$ 开始，并生成最初的 500 个数据点后丢弃，以减轻初始化偏差。\n\n3.  **IID 同方差序列**：这是一个作为基线的对照序列，生成方式为 $y_t = \\mu + \\varepsilon_t$，其中 $\\varepsilon_t \\overset{iid}{\\sim} \\mathcal{N}(0, \\sigma^2)$。\n\n其次，对于每个模拟序列 $\\{y_t\\}$，从两种不同的普通最小二乘（OLS）均值模型设定中获得残差。通用的 OLS 模型为 $y_t = x_t^{\\prime}\\beta + e_t$，其中 $x_t$ 是回归变量向量，$\\beta$ 是系数向量，$e_t$ 是残差。$\\beta$ 的 OLS 估计量为 $\\hat{\\beta} = (X'X)^{-1}X'y$，其中 $X$ 和 $y$ 分别是回归变量和因变量的矩阵和向量形式。然后计算残差为 $e = y - X\\hat{\\beta}$。\n\n1.  **错误设定的模型**：此模型始终假设一个简单的常数均值，通过单一回归变量（一个截距项）实现。因此，对所有 $t$，$x_t = [1]$。对于具有结构性突变的 DGP，此模型是错误设定的。\n\n2.  **正确设定的模型**：此模型正确反映了 DGP 的潜在均值结构。对于结构性突变的 DGP，回归变量是一个截距项和一个突变虚拟变量 $d_t$，其中当 $t \\le T_b$ 时 $d_t=0$，当 $t  T_b$ 时 $d_t=1$。因此，$x_t = [1, d_t]$。对于具有常数均值的 GARCH 和 IID DGP，正确设定的模型与错误设定的模型相同，仅包含一个截距项。\n\n第三，对从每个模型中提取的残差序列 $\\{e_t\\}$ 进行 Engle 拉格朗日乘数（LM）检验，以检验 $q$ 阶 ARCH 效应。此检验的原假设是直到 $q$ 阶都不存在 ARCH，即在辅助回归中 $H_0: \\gamma_1 = \\gamma_2 = \\dots = \\gamma_q = 0$：\n$$\ne_t^2 = \\gamma_0 + \\gamma_1 e_{t-1}^2 + \\dots + \\gamma_q e_{t-q}^2 + \\nu_t\n$$\nLM 检验统计量计算为 $LM = nR^2$，其中 $n$ 是辅助回归中的观测数量（$n = T-q$），$R^2$ 是此回归的决定系数。在原假设下，LM 统计量渐近服从自由度为 $q$ 的卡方分布，$LM \\sim \\chi^2_q$。$p$ 值是观测到至少与计算出的检验统计量一样极端的概率，由 $1 - F_{\\chi^2_q}(LM)$ 给出，其中 $F_{\\chi^2_q}$ 是 $\\chi^2_q$ 分布的累积分布函数。\n\n低 $p$ 值（例如 $p  0.05$）导致拒绝原假设，表明存在 ARCH 效应。分析的核心在于比较结构性突变 DGP 的错误设定模型和正确设定模型的 $p$ 值。如果错误设定的模型产生低 p 值，而正确设定的模型产生高 p 值，则证实了 ARCH 的伪检测。对于 GARCH DGP，预计两个模型都会产生低 p 值。对于 IID DGP，预计两个模型都会产生高 p 值。对四个指定的测试用例均执行整个过程，以生成所需的输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import chi2\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final results.\n    \"\"\"\n    \n    # Establish a reproducible random number generator\n    rng = np.random.default_rng(12345)\n\n    def generate_structural_break(T, mu1, mu2, sigma, b, rng_gen):\n        \"\"\"Generates a time series with a structural break in the mean.\"\"\"\n        Tb = int(np.floor(b * T))\n        innovations = rng_gen.normal(loc=0.0, scale=sigma, size=T)\n        y = np.zeros(T)\n        y[:Tb] = mu1 + innovations[:Tb]\n        y[Tb:] = mu2 + innovations[Tb:]\n        return y, Tb\n\n    def generate_garch(T, mu, omega, alpha, beta, rng_gen):\n        \"\"\"Generates a GARCH(1,1) time series.\"\"\"\n        burn_in = 500\n        total_len = T + burn_in\n        \n        z = rng_gen.normal(loc=0.0, scale=1.0, size=total_len)\n        u = np.zeros(total_len)\n        h = np.zeros(total_len)\n        \n        h[0] = omega / (1 - alpha - beta)\n        u[0] = np.sqrt(h[0]) * z[0]\n        \n        for t in range(1, total_len):\n            h[t] = omega + alpha * u[t-1]**2 + beta * h[t-1]\n            u[t] = np.sqrt(h[t]) * z[t]\n        \n        y = mu + u[burn_in:]\n        return y\n\n    def generate_iid(T, mu, sigma, rng_gen):\n        \"\"\"Generates an IID homoskedastic time series.\"\"\"\n        innovations = rng_gen.normal(loc=0.0, scale=sigma, size=T)\n        y = mu + innovations\n        return y\n\n    def get_residuals(y, with_break_dummy, Tb=None):\n        \"\"\"\n        Fits an OLS model to the data and returns the residuals.\n        \"\"\"\n        T = len(y)\n        if with_break_dummy:\n            if Tb is None:\n                raise ValueError(\"Tb must be provided for break dummy model.\")\n            X = np.ones((T, 2))\n            dummy = np.zeros(T)\n            dummy[Tb:] = 1.0\n            X[:, 1] = dummy\n        else:\n            X = np.ones((T, 1))\n\n        beta_hat = np.linalg.lstsq(X, y, rcond=None)[0]\n        y_hat = X @ beta_hat\n        residuals = y - y_hat\n        return residuals\n\n    def engle_lm_test(residuals, q):\n        \"\"\"\n        Performs the Engle LM test for ARCH effects.\n        \"\"\"\n        T = len(residuals)\n        e_sq = residuals**2\n        \n        # Dependent variable for the auxiliary regression\n        Y_aux = e_sq[q:]\n        n = len(Y_aux) # n = T - q\n        \n        # Independent variables (constant + q lags of e_sq)\n        X_aux = np.ones((n, q + 1))\n        for i in range(q):\n            # lag i+1\n            X_aux[:, i + 1] = e_sq[q - 1 - i : T - 1 - i]\n            \n        # OLS on the auxiliary regression\n        try:\n            # lstsq returns sum of squared residuals in the second element\n            rss_val = np.linalg.lstsq(X_aux, Y_aux, rcond=None)[1][0]\n        except IndexError:\n            # This can happen if the problem is perfectly determined, rss is empty.\n            rss_val = 0.0\n\n        # Total sum of squares of the dependent variable\n        tss = np.sum((Y_aux - np.mean(Y_aux))**2)\n        \n        if tss  1e-12: # Handle cases with zero variance\n             R2 = 0.0\n        else:\n            R2 = 1 - rss_val / tss\n\n        lm_stat = n * R2\n        p_value = 1 - chi2.cdf(lm_stat, q)\n        \n        return p_value\n\n    test_cases = [\n        {'type': 'break', 'params': {'T': 4000, 'mu1': 0.0, 'mu2': 2.0, 'sigma': 1.0, 'b': 0.5, 'q': 5}},\n        {'type': 'break', 'params': {'T': 4000, 'mu1': 0.0, 'mu2': 3.0, 'sigma': 1.0, 'b': 0.9, 'q': 1}},\n        {'type': 'garch', 'params': {'T': 5000, 'mu': 0.0, 'omega': 0.1, 'alpha': 0.05, 'beta': 0.9, 'q': 5}},\n        {'type': 'iid', 'params': {'T': 4000, 'mu': 0.0, 'sigma': 1.0, 'q': 5}}\n    ]\n    \n    results = []\n    \n    # Test case 1\n    case = test_cases[0]\n    params = case['params']\n    y, Tb = generate_structural_break(params['T'], params['mu1'], params['mu2'], params['sigma'], params['b'], rng)\n    res_misspec = get_residuals(y, with_break_dummy=False)\n    p_misspec = engle_lm_test(res_misspec, params['q'])\n    res_well = get_residuals(y, with_break_dummy=True, Tb=Tb)\n    p_well = engle_lm_test(res_well, params['q'])\n    results.extend([p_misspec, p_well])\n    \n    # Test case 2\n    case = test_cases[1]\n    params = case['params']\n    y, Tb = generate_structural_break(params['T'], params['mu1'], params['mu2'], params['sigma'], params['b'], rng)\n    res_misspec = get_residuals(y, with_break_dummy=False)\n    p_misspec = engle_lm_test(res_misspec, params['q'])\n    res_well = get_residuals(y, with_break_dummy=True, Tb=Tb)\n    p_well = engle_lm_test(res_well, params['q'])\n    results.extend([p_misspec, p_well])\n\n    # Test case 3\n    case = test_cases[2]\n    params = case['params']\n    y = generate_garch(params['T'], params['mu'], params['omega'], params['alpha'], params['beta'], rng)\n    # For GARCH DGP, both misspecified and well-specified models are intercept-only\n    res = get_residuals(y, with_break_dummy=False)\n    p_val = engle_lm_test(res, params['q'])\n    results.extend([p_val, p_val])\n\n    # Test case 4\n    case = test_cases[3]\n    params = case['params']\n    y = generate_iid(params['T'], params['mu'], params['sigma'], rng)\n    # For IID DGP, both misspecified and well-specified models are intercept-only\n    res = get_residuals(y, with_break_dummy=False)\n    p_val = engle_lm_test(res, params['q'])\n    results.extend([p_val, p_val])\n\n    # Format and print the final output\n    print(f\"[{','.join(f'{v:.6f}' for v in results)}]\")\n\nsolve()\n```"
        }
    ]
}