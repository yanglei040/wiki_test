{
    "hands_on_practices": [
        {
            "introduction": "VAR模型的核心任务之一是描述系统如何随时间对冲击做出响应，这通常通过脉冲响应函数（IRF）来刻画。本练习将展示正确设定模型的重要性，通过一个实例说明过于简化的模型会产生错误的脉冲响应，无法捕捉系统真实的动态行为。通过这个实践，你将掌握模拟时间序列、估计自回归模型以及计算和比较脉冲响应函数的基本技能。",
            "id": "2447477",
            "problem": "给定一个由二阶自回归定义的平稳单变量数据生成过程\n$$ y_t = 0.9\\,y_{t-1} - 0.8\\,y_{t-2} + \\epsilon_t, $$\n其中新息满足 $$\\epsilon_t \\sim \\text{i.i.d. } \\mathcal{N}(0,1)$$ 并且在时间上是独立的。设初始条件为 $$y_{-1}=0 \\text{ 和 } y_0=0。$$ 考虑使用一阶向量自回归 (VAR) 模型（只有一个变量，简化为一阶自回归）来近似该过程的动态，即形式为\n$$ y_t = a\\,y_{t-1} + u_t, $$\n的模型，无截距项，且 $$u_t$$ 为残差项。\n\n您的任务如下，需在单个程序内完全执行：\n\n1. 模拟。对于每个测试用例，使用上述指定参数，从给定的二阶自回归过程中模拟 $$T+B$$ 个观测值，其中 $$B$$ 是预烧期（burn-in）长度。丢弃前 $$B$$ 个观测值，保留后 $$T$$ 个观测值用于分析。\n\n2. 估计。对于每个保留样本，通过最小化保留样本上的一步向前预测误差的平方和来估计一阶向量自回归 (VAR(1)) 的系数 $$a$$，即找到\n$$ \\hat{a} \\in \\arg\\min_{a \\in \\mathbb{R}} \\sum_{t=1}^{T-1} \\left(y_{t+1} - a\\,y_t\\right)^2. $$\n\n3. 脉冲响应。对于每个测试用例和指定的时期长度 $$H \\in \\mathbb{N}$$，计算：\n   - 真实二阶自回归在时期 $$h=1,2,\\dots,H$$ 上的单位标准差脉冲响应序列，该序列由满足以下条件的移动平均系数 $$\\{\\psi_h\\}_{h \\ge 0}$$ 递归定义\n     $$ \\psi_0 = 1,\\quad \\psi_1 = 0.9,\\quad \\psi_h = 0.9\\,\\psi_{h-1} - 0.8\\,\\psi_{h-2}\\ \\text{for all}\\ h \\ge 2. $$\n     在时期 $$h$$ 的脉冲响应是 $$\\psi_h$$。\n   - 估计的一阶向量自回归在时期 $$h=1,2,\\dots,H$$ 上的脉冲响应序列，由 $$\\theta_h = \\hat{a}^{\\,h}$$ 定义，并约定 $$\\theta_0=1。$$\n\n4. 误导性动态指标。对于每个测试用例，计算在 $$\\{1,2,\\dots,H\\}$$ 这些时期中，估计的 VAR(1) 脉冲响应的符号与真实脉冲响应的符号不同的时期的比例。使用符号函数 $$\\operatorname{sgn}:\\mathbb{R}\\to\\{-1,0,1\\}$$，其定义为\n$$ \\operatorname{sgn}(x)=\\begin{cases}1  \\text{if }x>0,\\\\0  \\text{if }x=0,\\\\-1  \\text{if }x0.\\end{cases} $$\n令 $$m(H)$$ 表示满足 $$\\operatorname{sgn}(\\theta_h) \\neq \\operatorname{sgn}(\\psi_h)$$ 的索引 $$h \\in \\{1,\\dots,H\\}$$ 的数量。所要求的指标是该比例\n$$ \\frac{m(H)}{H}. $$\n\n5. 输出规范。您的程序必须输出一行，包含一个由方括号括起来的逗号分隔列表，其中每个测试用例对应一个浮点数，即分数 $$m(H)/H$$，四舍五入到六位小数。\n\n在所有测试用例中统一使用的模拟细节：\n- 预烧期长度 $$B=500$$。\n- 新息方差等于 $$1$$。\n- 保留的样本大小 $$T$$ 和时期长度 $$H$$ 在下面的每个测试用例中指定。\n- 如果在推理中出现任何角度，输出中不需要它们，也不需要单位。不涉及任何物理单位。\n\n测试套件。为以下参数值运行您的程序：\n- 测试用例 1: $$T=5000$$ 和 $$H=12$$。\n- 测试用例 2: $$T=100$$ 和 $$H=12$$。\n- 测试用例 3: $$T=2000$$ 和 $$H=1$$。\n- 测试用例 4: $$T=2000$$ 和 $$H=30$$。\n\n最终输出格式：\n- 您的程序应生成单行输出，包含一个由方括号括起来的逗号分隔列表形式的结果，其顺序与上面列出的测试用例相同，例如 $$[r_1,r_2,r_3,r_4]$$，其中每个 $$r_i$$ 是对应测试用例的分数 $$m(H)/H$$，四舍五入到六位小数。",
            "solution": "问题陈述已经过验证，被确认为一个有效、有科学依据且定义明确的计算计量经济学练习。它通过用一阶自回归模型 AR(1) 来近似二阶自回归过程 AR(2)，探讨了模型设定错误所带来的后果。所有参数和程序都得到了明确的规定。通过分析其特征多项式 $\\lambda(z) = 1 - 0.9 z + 0.8 z^2$，可以确认真实的 AR(2) 过程 $y_t = 0.9\\,y_{t-1} - 0.8\\,y_{t-2} + \\epsilon_t$ 的平稳性。$\\lambda(z)=0$ 的根是 $z = \\frac{0.9 \\pm i\\sqrt{2.39}}{1.6}$，其模为 $\\sqrt{1.25}$。由于该模大于1，根位于单位圆之外，这证实了该过程确实是平稳的，与问题陈述一致。\n\n该解决方案需要进行蒙特卡洛模拟研究。对于每个测试用例，该过程包括四个主要步骤：模拟真实过程、估计近似模型的参数、计算两个模型的脉冲响应函数，以及计算一个指标来量化它们动态属性的差异。\n\n**第一步：模拟AR(2)过程**\n数据生成过程由以下随机差分方程定义：\n$$ y_t = 0.9\\,y_{t-1} - 0.8\\,y_{t-2} + \\epsilon_t $$\n其中新息 $\\epsilon_t$ 是独立同分布的标准正态随机变量，即 $\\epsilon_t \\sim \\mathcal{N}(0,1)$。该过程以条件 $y_{-1}=0$ 和 $y_0=0$ 初始化。对于由样本大小 $T$ 和时期长度 $H$ 定义的每个测试用例，生成一个总长度为 $T+B$ 的时间序列，其中 $B=500$ 是指定的预烧期。丢弃前 $B$ 个观测值，以确保分析是在代表该过程平稳分布的样本上进行的，从而减轻任意初始条件的影响。模拟从 $t=1$ 开始，使用给定的递推关系迭代进行：\n- $y_1 = 0.9\\,y_0 - 0.8\\,y_{-1} + \\epsilon_1 = \\epsilon_1$\n- $y_2 = 0.9\\,y_1 - 0.8\\,y_0 + \\epsilon_2 = 0.9\\,y_1 + \\epsilon_2$\n- ... 对于后续时间步直到 $t = T+B$ 依此类推。\n\n**第二步：估计AR(1)系数**\n更复杂的 AR(2) 过程将由一个更简单的 AR(1) 模型来近似，该模型是单变量 VAR(1) 的特例，由下式给出：\n$$ y_t = a\\,y_{t-1} + u_t $$\n系数 $a$ 使用普通最小二乘法 (OLS) 进行估计，通过最小化保留样本上的一步向前预测误差的平方和。设保留样本表示为 $\\{z_t\\}_{t=1}^T$，其中 $z_t$ 对应于模拟值 $y_{B+t}$。优化问题是找到解决以下问题的 $\\hat{a}$：\n$$ \\hat{a} = \\arg\\min_{a \\in \\mathbb{R}} \\sum_{t=1}^{T-1} (z_{t+1} - a\\,z_t)^2 $$\n这是一个标准的回归问题，其 OLS 估计量 $\\hat{a}$ 具有众所周知的闭式解：\n$$ \\hat{a} = \\frac{\\sum_{t=1}^{T-1} z_t z_{t+1}}{\\sum_{t=1}^{T-1} z_t^2} $$\n这个估计系数 $\\hat{a}$ 代表仅基于最近一次观测的最佳线性预测系数。\n\n**第三步：脉冲响应函数(IRF)计算**\nIRF 描述了系统在响应其某个新息的单个、暂时性冲击时的演变过程。\n- **真实IRF：** 对于真实的 AR(2) 过程， $y_{t+h}$ 对单位冲击 $\\epsilon_t=1$ 的响应由 Wold 移动平均表示 $y_t = \\sum_{j=0}^{\\infty} \\psi_j \\epsilon_{t-j}$ 中的系数 $\\psi_h$ 给出。这些系数根据问题的定义递归计算：\n  - $\\psi_0 = 1$\n  - $\\psi_1 = 0.9$\n  - $\\psi_h = 0.9\\,\\psi_{h-1} - 0.8\\,\\psi_{h-2}$ 对于所有整数 $h \\ge 2$。\n特征多项式的复数根意味着真实的 IRF，即 $\\{\\psi_h\\}_{h>0}$，将是一个阻尼正弦波，其符号会振荡。对于每个指定的时期长度 $H$，计算响应序列 $\\{\\psi_h\\}_{h=1}^H$。\n\n- **估计IRF：** 对于估计的 AR(1) 模型，时期 $h$ 的脉冲响应由 $\\theta_h$ 给出：\n  - $\\theta_h = \\hat{a}^h$\n这个 IRF 是一个简单的几何序列。如果 $|\\hat{a}|  1$ 且 $\\hat{a}>0$，其行为是单调衰减至零；如果 $|\\hat{a}|1$ 且 $\\hat{a}0$，则是振荡衰减。使用第二步中估计的系数 $\\hat{a}$ 计算序列 $\\{\\theta_h\\}_{h=1}^H$。\n\n**第四步：误导性动态指标**\n核心任务是量化简化的 AR(1) 模型在多大程度上提供了系统动态响应的定性错误预测。脉冲响应的符号是一个基本的定性特征，指示在正向冲击后，变量预期是高于还是低于其长期均值。真实和估计 IRF 之间的符号差异揭示了简化模型未能捕捉真实动态。该指标定义为时期 $h \\in \\{1, 2, \\dots, H\\}$ 中符号不同的比例：\n$$ \\text{指标} = \\frac{m(H)}{H} = \\frac{1}{H} \\sum_{h=1}^{H} \\mathbf{1}_{\\{\\operatorname{sgn}(\\theta_h) \\neq \\operatorname{sgn}(\\psi_h)\\}} $$\n其中 $\\mathbf{1}_{\\{\\cdot\\}}$ 表示指示函数，如果其参数为真则为 $1$，否则为 $0$，而 $\\operatorname{sgn}(\\cdot)$ 是标准符号函数。为每个测试用例计算此指标。\n\n算法实现将精确遵循这四个步骤。开发一个 Python 脚本来为所有测试用例自动化整个过程，从数据模拟到最终指标计算，并确保严格遵守输出格式。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of comparing AR(2) dynamics with an AR(1) approximation.\n    \"\"\"\n\n    # --- Problem Parameters ---\n    test_cases = [\n        (5000, 12),  # T, H for case 1\n        (100, 12),   # T, H for case 2\n        (2000, 1),   # T, H for case 3\n        (2000, 30),  # T, H for case 4\n    ]\n    B = 500  # Burn-in length\n    ar2_coeffs = (0.9, -0.8) # Coefficients for y_{t-1} and y_{t-2}\n    \n    # Store results for each test case\n    results = []\n\n    for T, H in test_cases:\n        # --- 1. Simulation ---\n        # Simulate T+B observations from the AR(2) process.\n        total_len = T + B\n        eps = np.random.normal(loc=0.0, scale=1.0, size=total_len)\n        y = np.zeros(total_len)\n\n        # Initial conditions y_{-1}=0, y_0=0\n        # t=1 (index 0): y[0] = 0.9*y_0 - 0.8*y_{-1} + eps[0] = eps[0]\n        if total_len > 0:\n            y[0] = eps[0]\n        \n        # t=2 (index 1): y[1] = 0.9*y[0] - 0.8*y_0 + eps[1] = 0.9*y[0] + eps[1]\n        if total_len > 1:\n            y[1] = ar2_coeffs[0] * y[0] + eps[1]\n        \n        # for t=3, .. N (index 2 to N-1)\n        for t in range(2, total_len):\n            y[t] = ar2_coeffs[0] * y[t-1] + ar2_coeffs[1] * y[t-2] + eps[t]\n\n        # Discard burn-in period to get the retained sample\n        y_retained = y[B:]\n\n        # --- 2. Estimation ---\n        # Estimate the AR(1) coefficient 'a' using OLS.\n        # The model is y_{t+1} = a*y_t + u_t\n        # dependent variable: y_retained[1:]\n        # independent variable: y_retained[:-1]\n        y_reg_dep = y_retained[1:]\n        y_reg_indep = y_retained[:-1]\n        \n        # OLS formula: a_hat = (X'Y) / (X'X)\n        numerator = np.dot(y_reg_indep, y_reg_dep)\n        denominator = np.dot(y_reg_indep, y_reg_indep)\n\n        a_hat = 0.0 if denominator == 0 else numerator / denominator\n\n        # --- 3. Impulse Responses ---\n        # True AR(2) IRF\n        psi = np.zeros(H + 1)\n        if H >= 0:\n            psi[0] = 1.0\n        if H >= 1:\n            psi[1] = ar2_coeffs[0]\n        for h in range(2, H + 1):\n            psi[h] = ar2_coeffs[0] * psi[h-1] + ar2_coeffs[1] * psi[h-2]\n        \n        # We need IRF for horizons h=1, ..., H\n        psi_true = psi[1:]\n\n        # Estimated AR(1) IRF\n        # theta_h = a_hat^h for h=1, ..., H\n        horizons = np.arange(1, H + 1)\n        theta_est = np.power(a_hat, horizons)\n\n        # --- 4. Misleading-Dynamics Metric ---\n        # Count horizons where signs of IRFs differ\n        m_H = 0\n        for h in range(H):\n            if np.sign(theta_est[h]) != np.sign(psi_true[h]):\n                m_H += 1\n        \n        metric = m_H / H if H > 0 else 0.0\n        results.append(metric)\n\n    # --- 5. Output Specification ---\n    # Print results in the required format\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在理解了系统的动态特性后，我们常常希望探究变量间的因果联系，而格兰杰因果检验是实现此目的的标准工具。然而，本练习将揭示一个关键陷阱：一个被忽略的共同驱动因素（即遗漏变量）可能会在两个观测变量之间制造出虚假的格兰杰因果关系。通过亲手模拟这一情景并进行正式的假设检验，你将深刻体会到应用VAR分析中最常见的挑战之一。",
            "id": "2447550",
            "problem": "给定一个由潜变量驱动的三变量线性数据生成过程，旨在说明向量自回归（VAR）估计中的遗漏变量偏差。向量自回归（VAR）是一个线性随机差分方程组，用于描述多个时间序列的联合动态。考虑由以下方程生成的三个过程 $\\{Z_t\\}$、$\\{X_t\\}$ 和 $\\{Y_t\\}$：\n$$Z_t = \\rho_Z Z_{t-1} + u_t,$$\n$$X_t = \\phi_X X_{t-1} + b_X Z_{t-1} + e_t,$$\n$$Y_t = \\phi_Y Y_{t-1} + b_Y Z_{t-1} + v_t,$$\n其中 $u_t$、$e_t$ 和 $v_t$ 是相互独立、序列独立、均值为零的高斯冲击，其方差分别为 $\\sigma_u^2$、$\\sigma_e^2$ 和 $\\sigma_v^2$。在全信息三变量系统中，$X_t$ 不会格兰杰因果（Granger-cause）$Y_t$，因为在 $Y_t$ 的运动规律中没有直接引入 $X_t$ 的滞后项。格兰杰因果关系定义如下：如果 $X_t$ 的过去值在 $Y_t$ 过去值及所有其他相关过程所含信息之外，能够改进对 $Y_t$ 在未来1期的均方预测，则称过程 $X_t$ 格兰杰因果过程 $Y_t$。\n\n然而，在实践中，潜变量过程 $Z_t$ 被遗漏，而仅对 $(X_t, Y_t)$ 估计一个二元VAR模型。您的任务是证明这种遗漏如何在估计的二元系统中引发伪格兰杰因果关系。\n\n基本原理：\n- 使用基于线性可预测性的格兰杰因果关系定义，以及在 Gauss–Markov 条件下作为最佳线性无偏估计量的普通最小二乘法（OLS）。普通最小二乘法（OLS）依赖于求解正规方程来最小化残差平方和。\n- 对于高斯扰动下的嵌套线性模型，源自均方残差和之比的经典F检验，为基于 Fisher–Snedecor 分布（F分布）的有限样本线性排斥性约束提供了有效检验。\n\n说明：\n- 对于下方的每个测试用例，使用指定的参数从三变量系统模拟数据。使用 $B = 300$ 个观测值的“预烧期”（burn-in），并在分析前丢弃这些数据以减轻初始化效应。将 $Z_0$、$X_0$ 和 $Y_0$ 初始化为 $0$。\n- 对于预烧期后的观测二元数据 $(X_t, Y_t)$，通过OLS逐方程估计一个包含截距项的 $p=1$ 阶二元VAR模型。\n- 在 $Y$ 方程中，检验在观测的二元系统中“$X$ 不格兰杰因果 $Y$”的原假设。该原假设设定 $Y$ 方程中所有 $X$ 的 $p$ 个滞后项的系数都等于 $0$。通过比较无约束的 $Y$ 方程（包含 $X$ 的滞后项）与有约束的 $Y$ 方程（不包含 $X$ 的滞后项），构建标准的嵌套模型 F 统计量。使用 Fisher–Snedecor 分布的累积分布函数计算 $p$ 值，其分子和分母自由度由排斥性约束的数量和无约束残差自由度决定。当且仅当 $p$ 值严格小于显著性水平 $\\alpha = 0.05$ 时，拒绝原假设。\n- 对每个测试用例，输出一个布尔值，表示在观测的二元VAR模型中，原假设“$X$ 不格兰杰因果 $Y$”是否被拒绝。\n\n测试套件：\n- 案例 1（高潜变量持续性；伪关系检测的“理想路径”）：\n  - $T = 1000$, $p = 1$, $\\alpha = 0.05$, $\\rho_Z = 0.95$, $\\phi_X = 0.2$, $\\phi_Y = 0.2$, $b_X = 1.5$, $b_Y = 1.5$, $\\sigma_u = 0.5$, $\\sigma_e = 0.5$, $\\sigma_v = 0.5$, seed $= 123456$。\n- 案例 2（潜变量为白噪声；$X_{t-1}$ 对 $Y_t$ 的伪可预测性最小的边界情况）：\n  - $T = 600$, $p = 1$, $\\alpha = 0.05$, $\\rho_Z = 0.0$, $\\phi_X = 0.4$, $\\phi_Y = 0.6$, $b_X = 1.0$, $b_Y = 1.0$, $\\sigma_u = 1.0$, $\\sigma_e = 1.0$, $\\sigma_v = 1.0$, seed $= 20231102$。\n- 案例 3（小样本；低检验效力和抽样变异性的边缘案例）：\n  - $T = 120$, $p = 1$, $\\alpha = 0.05$, $\\rho_Z = 0.9$, $\\phi_X = 0.6$, $\\phi_Y = 0.6$, $b_X = 1.2$, $b_Y = 0.8$, $\\sigma_u = 0.8$, $\\sigma_e = 0.8$, $\\sigma_v = 0.8$, seed $= 7$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按上述案例顺序列出结果。每个条目都是一个布尔值，对应于原假设“$X$ 不格兰杰因果 $Y$”是否被拒绝。例如，包含三个案例的输出应类似于 $[{\\rm True},{\\rm False},{\\rm True}]$。",
            "solution": "该问题要求研究由向量自回归（VAR）模型中遗漏变量偏差引起的伪格兰杰因果现象。我们获得一个三变量线性随机过程，它由两个观测变量 $X_t$ 和 $Y_t$ 以及一个未观测到的（潜）共同驱动因素 $Z_t$ 组成。任务是在指定的参数集下模拟该系统，并在一个遗漏了 $Z_t$ 的错误设定的二元VAR模型中检验从 $X_t$ 到 $Y_t$ 的格兰杰因果关系。\n\n数据生成过程（DGP）由以下方程组定义：\n$$Z_t = \\rho_Z Z_{t-1} + u_t$$\n$$X_t = \\phi_X X_{t-1} + b_X Z_{t-1} + e_t$$\n$$Y_t = \\phi_Y Y_{t-1} + b_Y Z_{t-1} + v_t$$\n其中 $u_t$、$e_t$ 和 $v_t$ 是相互独立、序列不相关、均值为 $0$ 且方差分别为 $\\sigma_u^2$、$\\sigma_e^2$ 和 $\\sigma_v^2$ 的高斯白噪声过程。\n\n在这个真实的结构模型中，$Y_t$ 的演化仅取决于其自身的滞后项 $Y_{t-1}$ 和潜变量过程的滞后项 $Z_{t-1}$。在 $Y_t$ 的方程中没有涉及 $X_t$ 滞后项的项。因此，在完整的三变量系统背景下，$X_t$ 不会格兰杰因果 $Y_t$。\n\n然而，计量经济学家观测不到 $Z_t$，于是继续对观测数据 $(X_t, Y_t)$ 估计一个 $p=1$ 阶的二元VAR模型。在这个错误设定的模型中，$Y_t$ 的方程是：\n$$Y_t = c_Y + \\beta_{Y,1} Y_{t-1} + \\beta_{X,1} X_{t-1} + \\epsilon_t$$\n其中 $\\epsilon_t$ 是新的误差项。从 $X_t$到 $Y_t$ 的格兰杰因果关系检验是检验原假设 $H_0: \\beta_{X,1} = 0$。\n\n如果我们拒绝这个原假设，并不是因为 $X_{t-1}$ （在以 $Y_{t-1}$ 为条件后）对 $Y_t$ 具有真正的预测能力，而是因为模型的错误设定，这时就出现了伪格兰杰因果关系。这是一个典型的遗漏变量偏差案例。如果包含的回归量 $X_{t-1}$ 与遗漏变量 $Z_{t-1}$ 相关，那么 $\\beta_{X,1}$ 的普通最小二乘（OLS）估计量（记为 $\\hat{\\beta}_{X,1}$）将是有偏的，而 $Z_{t-1}$ 是错误设定回归的真实误差项的一部分。\n\n$Y_t$ 的真实模型可以表示为 $Y_t = \\phi_Y Y_{t-1} + (b_Y Z_{t-1} + v_t)$。当我们估计二元模型时，项 $b_Y Z_{t-1}$ 被遗漏并成为误差项 $\\epsilon_t$ 的一部分。要使OLS估计量 $\\hat{\\beta}_{X,1}$ 有偏，必须满足两个条件：\n1. 遗漏变量 $Z_{t-1}$ 必须是 $Y_t$ 的一个决定因素。在我们的DGP中，如果 $b_Y \\neq 0$，这个条件成立。\n2. 遗漏变量 $Z_{t-1}$ 必须与包含的回归量 $X_{t-1}$ 相关，即 $\\mathrm{Cov}(X_{t-1}, Z_{t-1}) \\neq 0$。\n\n让我们分析这个协方差，假设过程是平稳的。根据DGP，我们有 $X_{t-1} = \\phi_X X_{t-2} + b_X Z_{t-2} + e_{t-1}$ 和 $Z_{t-1} = \\rho_Z Z_{t-2} + u_{t-1}$。计算 $X_{t-1}$ 和 $Z_{t-1}$ 的协方差（并假设均值为零），我们得到：\n$$\\mathrm{E}[X_{t-1} Z_{t-1}] = \\mathrm{E}[(\\phi_X X_{t-2} + b_X Z_{t-2} + e_{t-1})(\\rho_Z Z_{t-2} + u_{t-1})]$$\n由于冲击的独立性，这可以简化为：\n$$\\mathrm{E}[X_{t-1} Z_{t-1}] = \\phi_X \\rho_Z \\mathrm{E}[X_{t-2}Z_{t-2}] + b_X \\rho_Z \\mathrm{E}[Z_{t-2}^2]$$\n设 $\\Gamma_{XZ} = \\mathrm{E}[X_t Z_t]$ 且 $\\gamma_Z(0) = \\mathrm{E}[Z_t^2]$。在稳态下，我们有 $\\Gamma_{XZ} = \\phi_X \\rho_Z \\Gamma_{XZ} + b_X \\rho_Z \\gamma_Z(0)$，这意味着 $\\Gamma_{XZ} = \\frac{b_X \\rho_Z}{1 - \\phi_X \\rho_Z} \\gamma_Z(0)$。\n由于 $\\gamma_Z(0) = \\sigma_u^2 / (1 - \\rho_Z^2) > 0$，协方差 $\\mathrm{Cov}(X_{t-1}, Z_{t-1})$ 非零当且仅当 $b_X \\neq 0$ 且 $\\rho_Z \\neq 0$。\n\n因此，当 $b_X \\neq 0$、$b_Y \\neq 0$ 且 $\\rho_Z \\neq 0$ 时，预计会产生从 $X_t$ 到 $Y_t$ 的伪格兰杰因果关系。回归量 $X_{t-1}$ 充当了遗漏变量 $Z_{t-1}$ 的代理变量，其系数 $\\beta_{X,1}$ 虚假地捕捉了 $Z_{t-1}$ 对 $Y_t$ 的影响。如果 $\\rho_Z=0$，$Z_t$ 是白噪声，那么 $Z_{t-1}$ 与 $X_{t-1}$ 不相关，从而打破了偏差产生的机制。\n\n具体步骤是为每个案例进行假设检验。我们生成 $T+B$ 个数据点，并丢弃前 $B=300$ 个作为预烧期。在剩下的 $T$ 个观测值上，我们使用OLS估计二元VAR(1)的 $Y$ 方程。这需要 $T-1$ 个有效观测值。无约束模型是 $Y_t = c + \\beta_1 Y_{t-1} + \\beta_2 X_{t-1} + \\epsilon_t$，而在 $H_0: \\beta_2=0$ 下的约束模型是 $Y_t = c' + \\beta'_1 Y_{t-1} + \\epsilon'_t$。\n\n我们使用两个回归的残差平方和（$RSS$）计算 F 统计量：\n$$F = \\frac{(RSS_R - RSS_U) / q}{RSS_U / (N_{reg} - k)}$$\n这里，$RSS_R$ 和 $RSS_U$ 分别是约束模型和无约束模型的残差平方和。回归观测的数量是 $N_{reg} = T-1$。约束的数量是 $q=1$。无约束模型中的参数数量是 $k=3$（截距项、$Y$ 的一个滞后项、$X$ 的一个滞后项）。F 分布的自由度是分子自由度 $q=1$ 和分母自由度 $N_{reg} - k = (T-1) - 3 = T-4$。\n\np值由 $F_{1, T-4}$ 分布的累积分布函数（CDF）计算得出。如果 p 值小于显著性水平 $\\alpha=0.05$，则拒绝原假设。\n\n- 案例 1：潜变量具有高持续性（$\\rho_Z = 0.95$）且样本量大（$T=1000$）。伪因果关系的所有条件都得到了有力满足。预计原假设将被拒绝。\n- 案例 2：潜变量是白噪声（$\\rho_Z = 0.0$）。遗漏变量偏差的机制不存在。除非发生 I 类错误，否则检验不应拒绝原假设。\n- 案例 3：潜变量具有高持续性（$\\rho_Z = 0.9$），但样本量小（$T=120$）。偏差存在，但检验的统计功效可能不足以检测到它。结果展示了偏差大小和样本量之间的相互作用。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import f as f_dist\n\ndef solve():\n    \"\"\"\n    Main function to run test cases for spurious Granger causality.\n    \"\"\"\n    test_cases = [\n        # Case 1 (high latent persistence)\n        {\n            \"T\": 1000, \"p\": 1, \"alpha\": 0.05, \"rho_Z\": 0.95, \"phi_X\": 0.2, \"phi_Y\": 0.2,\n            \"b_X\": 1.5, \"b_Y\": 1.5, \"sigma_u\": 0.5, \"sigma_e\": 0.5, \"sigma_v\": 0.5,\n            \"seed\": 123456\n        },\n        # Case 2 (latent white noise)\n        {\n            \"T\": 600, \"p\": 1, \"alpha\": 0.05, \"rho_Z\": 0.0, \"phi_X\": 0.4, \"phi_Y\": 0.6,\n            \"b_X\": 1.0, \"b_Y\": 1.0, \"sigma_u\": 1.0, \"sigma_e\": 1.0, \"sigma_v\": 1.0,\n            \"seed\": 20231102\n        },\n        # Case 3 (small sample)\n        {\n            \"T\": 120, \"p\": 1, \"alpha\": 0.05, \"rho_Z\": 0.9, \"phi_X\": 0.6, \"phi_Y\": 0.6,\n            \"b_X\": 1.2, \"b_Y\": 0.8, \"sigma_u\": 0.8, \"sigma_e\": 0.8, \"sigma_v\": 0.8,\n            \"seed\": 7\n        }\n    ]\n\n    results = []\n    for case_params in test_cases:\n        result = run_granger_test(case_params)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_granger_test(params):\n    \"\"\"\n    Simulates data and performs the Granger causality F-test for a single case.\n\n    Args:\n        params (dict): A dictionary of parameters for the simulation and test.\n\n    Returns:\n        bool: True if the null hypothesis is rejected, False otherwise.\n    \"\"\"\n    # Unpack parameters\n    T = params[\"T\"]\n    p = params[\"p\"]\n    alpha = params[\"alpha\"]\n    rho_Z = params[\"rho_Z\"]\n    phi_X = params[\"phi_X\"]\n    phi_Y = params[\"phi_Y\"]\n    b_X = params[\"b_X\"]\n    b_Y = params[\"b_Y\"]\n    sigma_u = params[\"sigma_u\"]\n    sigma_e = params[\"sigma_e\"]\n    sigma_v = params[\"sigma_v\"]\n    seed = params[\"seed\"]\n    \n    B = 300  # Burn-in period\n    T_total = T + B\n\n    # Set seed for reproducibility\n    np.random.seed(seed)\n\n    # Generate shocks\n    u = np.random.normal(0, sigma_u, T_total)\n    e = np.random.normal(0, sigma_e, T_total)\n    v = np.random.normal(0, sigma_v, T_total)\n\n    # Initialize time series arrays\n    Z = np.zeros(T_total)\n    X = np.zeros(T_total)\n    Y = np.zeros(T_total)\n\n    # Simulate the trivariate system\n    for t in range(1, T_total):\n        Z[t] = rho_Z * Z[t-1] + u[t]\n        X[t] = phi_X * X[t-1] + b_X * Z[t-1] + e[t]\n        Y[t] = phi_Y * Y[t-1] + b_Y * Z[t-1] + v[t]\n\n    # Discard burn-in period\n    X_sample = X[B:]\n    Y_sample = Y[B:]\n\n    # Prepare data for regression (VAR order p=1)\n    # Effective sample size for regression is T-p\n    y_vec = Y_sample[p:]\n    N_reg = len(y_vec)\n\n    # Regressors for the unrestricted model: intercept, Y_lag1, X_lag1\n    X_unrestricted = np.vstack([\n        np.ones(N_reg),\n        Y_sample[p-1:-1],\n        X_sample[p-1:-1]\n    ]).T\n\n    # Regressors for the restricted model: intercept, Y_lag1\n    X_restricted = np.vstack([\n        np.ones(N_reg),\n        Y_sample[p-1:-1]\n    ]).T\n\n    # OLS estimation via np.linalg.lstsq\n    # lstsq returns: coefficients, residuals (sum of squares), rank, singular values\n    # We only need the residual sum of squares (RSS)\n    _, rss_unrestricted, _, _ = np.linalg.lstsq(X_unrestricted, y_vec, rcond=None)\n    _, rss_restricted, _, _ = np.linalg.lstsq(X_restricted, y_vec, rcond=None)\n    \n    # lstsq returns RSS as a one-element array, so we extract the float\n    rss_u = rss_unrestricted[0]\n    rss_r = rss_restricted[0]\n\n    # Compute the F-statistic\n    q = X_unrestricted.shape[1] - X_restricted.shape[1]\n    k_unrestricted = X_unrestricted.shape[1]\n    df_num = q\n    df_den = N_reg - k_unrestricted\n    \n    # Check for df_den > 0 to avoid division by zero\n    if df_den = 0:\n        return False # Cannot perform test\n\n    F_statistic = ((rss_r - rss_u) / df_num) / (rss_u / df_den)\n\n    # Compute the p-value using the survival function (1 - CDF)\n    p_value = f_dist.sf(F_statistic, dfn=df_num, dfd=df_den)\n\n    # Reject null if p-value is less than the significance level\n    return p_value  alpha\n\n# Run the simulation and print the results\nsolve()\n```"
        },
        {
            "introduction": "虽然简约型VAR模型在预测和描述相关性方面表现出色，但要分析特定经济冲击（如货币政策冲击）的影响，我们需要构建结构性VAR（SVAR）模型。这项高级练习将指导你如何利用经济理论——在本例中为“货币长期中性”假设——来识别和分解这些结构性冲击。这项实践将统计建模与经济解释联系起来，是计算经济学研究者必备的关键技能。",
            "id": "2447527",
            "problem": "考虑一个二元平稳一阶向量自回归 (VAR) 模型，该模型为变量向量 $x_t \\in \\mathbb{R}^2$ 定义如下\n$$\nx_t = A x_{t-1} + u_t,\n$$\n其中 $A \\in \\mathbb{R}^{2 \\times 2}$ 是一个参数矩阵，其谱半径严格小于 $1$，$u_t$ 是一个零均值新息，其正定协方差矩阵为 $\\Sigma_u \\in \\mathbb{R}^{2 \\times 2}$。假设存在一个结构表示，其结构冲击 $e_t \\in \\mathbb{R}^2$ 满足 $u_t = B e_t$ 和 $\\mathbb{E}[e_t e_t^\\top] = I_2$，其中 $B \\in \\mathbb{R}^{2 \\times 2}$ 是结构冲击矩阵，$I_2$ 是大小为 2 的单位矩阵。设 $x_t$ 的两个分量分别解释为一个实际变量（第一分量）和一个名义变量（第二分量），例如，实际产出和货币供应量。\n\n定义长期累积效应矩阵为\n$$\n\\Psi(1) = \\sum_{h=0}^{\\infty} A^h B,\n$$\n由于 $A$ 的谱半径严格小于 $1$，该矩阵是良定义的。施加长期约束，即名义结构冲击（$e_t$ 的第二分量）对实际变量（$x_t$ 的第一分量）没有长期效应，即\n$$\n\\left[\\Psi(1)\\right]_{1,2} = 0.\n$$\n此外，强制要求 $B$ 再现简化式协方差，即\n$$\n\\Sigma_u = B B^\\top,\n$$\n并采用符号归一化\n$$\nB_{1,1}  0 \\quad \\text{and} \\quad B_{2,2}  0,\n$$\n以消除结构冲击中的符号不确定性。\n\n您的任务是，对于下面提供的每组参数，计算矩阵 $B$ 以及由上述约束所隐含的相关诊断指标。长期矩阵 $\\Psi(1)$ 必须根据给定的 $A$ 和您计算出的 $B$ 来确定。\n\n测试套件（每个案例指定 $A$ 和 $\\Sigma_u$）：\n- 案例 1（正常路径）：\n$$\nA^{(1)} = \\begin{bmatrix} 0.3  0.1 \\\\ 0.05  0.2 \\end{bmatrix}, \\quad\n\\Sigma_u^{(1)} = \\begin{bmatrix} 0.5  0.1 \\\\ 0.1  0.3 \\end{bmatrix}.\n$$\n- 案例 2（零动态边界）：\n$\nA^{(2)} = \\begin{bmatrix} 0.0  0.0 \\\\ 0.0  0.0 \\end{bmatrix}, \\quad\n\\Sigma_u^{(2)} = \\begin{bmatrix} 1.0  0.2 \\\\ 0.2  2.0 \\end{bmatrix}.\n$\n- 案例 3（高持续性但稳定）：\n$\nA^{(3)} = \\begin{bmatrix} 0.95  -0.1 \\\\ 0.05  0.9 \\end{bmatrix}, \\quad\n\\Sigma_u^{(3)} = \\begin{bmatrix} 0.2  -0.05 \\\\ -0.05  0.4 \\end{bmatrix}.\n$\n\n对于每个案例 $k \\in \\{1,2,3\\}$，计算：\n- 标量 $[\\Psi^{(k)}(1)]_{1,2}$。\n- 弗罗贝尼乌斯范数 $\\|B^{(k)} (B^{(k)})^\\top - \\Sigma_u^{(k)}\\|_F$。\n- $B^{(k)}$ 按行主序排列的元素：$B^{(k)}_{1,1}$、$B^{(k)}_{1,2}$、$B^{(k)}_{2,1}$、$B^{(k)}_{2,2}$。\n\n最终输出格式：\n- 您的程序应产生单行输出，其中包含一个含三个元素的列表，每个元素对应一个测试案例。每个元素本身必须是包含六个浮点数的列表，顺序为\n$\n\\big([\\Psi(1)]_{1,2}, \\ \\|B B^\\top - \\Sigma_u\\|_F, \\ B_{1,1}, \\ B_{1,2}, \\ B_{2,1}, \\ B_{2,2}\\big),\n$\n每个数字四舍五入到六位小数。\n- 具体来说，输出必须是以下形式的单行：\n$\n\\big[ [r^{(1)}_1, r^{(1)}_2, r^{(1)}_3, r^{(1)}_4, r^{(1)}_5, r^{(1)}_6], [r^{(2)}_1, \\ldots, r^{(2)}_6], [r^{(3)}_1, \\ldots, r^{(3)}_6] \\big],\n$\n其中每个 $r^{(k)}_j$ 是一个四舍五入到六位小数的浮点数。\n\n不需要外部输入，也不涉及物理单位。在内部使用的角度必须以弧度为单位。程序必须是自包含的，并能按所提供的方式运行。",
            "solution": "首先对问题进行严格的验证过程。\n\n### 步骤 1：提取的已知条件\n\n问题提供了以下信息：\n- 一个二元平稳一阶向量自回归模型：$x_t = A x_{t-1} + u_t$，其中 $x_t \\in \\mathbb{R}^2$，$A \\in \\mathbb{R}^{2 \\times 2}$ 且谱半径 $\\rho(A)  1$。\n- 新息 $u_t$ 是零均值，具有正定协方差矩阵 $\\Sigma_u \\in \\mathbb{R}^{2 \\times 2}$。\n- 一个结构表示 $u_t = B e_t$，其结构冲击 $e_t \\in \\mathbb{R}^2$ 满足 $\\mathbb{E}[e_t e_t^\\top] = I_2$，其中 $I_2$ 是 $2 \\times 2$ 的单位矩阵，$B \\in \\mathbb{R}^{2 \\times 2}$ 是结构冲击矩阵。\n- 长期累积效应矩阵定义为 $\\Psi(1) = \\sum_{h=0}^{\\infty} A^h B$。\n- 一个长期约束：名义结构冲击（$e_t$ 的第二分量）对实际变量（$x_t$ 的第一分量）没有长期效应。这表示为 $[\\Psi(1)]_{1,2} = 0$。\n- 一个协方差约束：$B B^\\top = \\Sigma_u$。\n- 一个符号归一化：$B_{1,1} > 0$ 和 $B_{2,2} > 0$。\n- 矩阵 $A$ 和 $\\Sigma_u$ 的三个测试案例：\n  - 案例 1：$A^{(1)} = \\begin{bmatrix} 0.3  0.1 \\\\ 0.05  0.2 \\end{bmatrix}, \\Sigma_u^{(1)} = \\begin{bmatrix} 0.5  0.1 \\\\ 0.1  0.3 \\end{bmatrix}$。\n  - 案例 2：$A^{(2)} = \\begin{bmatrix} 0.0  0.0 \\\\ 0.0  0.0 \\end{bmatrix}, \\Sigma_u^{(2)} = \\begin{bmatrix} 1.0  0.2 \\\\ 0.2  2.0 \\end{bmatrix}$。\n  - 案例 3：$A^{(3)} = \\begin{bmatrix} 0.95  -0.1 \\\\ 0.05  0.9 \\end{bmatrix}, \\Sigma_u^{(3)} = \\begin{bmatrix} 0.2  -0.05 \\\\ -0.05  0.4 \\end{bmatrix}$。\n- 每个案例所需的输出是一个包含六个数字的列表：$[\\Psi(1)]_{1,2}$、$\\|B B^\\top - \\Sigma_u\\|_F$、$B_{1,1}$、$B_{1,2}$、$B_{2,1}$、$B_{2,2}$。\n\n### 步骤 2：使用提取的已知条件进行验证\n\n根据指定标准对问题进行评估：\n- **科学依据**：该问题描述了结构向量自回归（SVAR）的 Blanchard-Quah 识别策略，这是宏观经济学和计算金融学中一个标准且成熟的方法。它在科学上是合理的。\n- **适定性**：该问题提供了一组旨在唯一识别结构矩阵 $B$ 的约束（长期、协方差、符号）。约束的数量与 $B$ 中自由参数的数量相匹配。断言了稳定性条件 $\\rho(A)  1$ 和 $\\Sigma_u$ 的正定性，并且可以对给定的测试案例进行验证。对于 $A^{(1)}$，特征值约为 $0.336$ 和 $0.164$。对于 $A^{(2)}$，特征值为 $0, 0$。对于 $A^{(3)}$，特征值为模为 $\\sqrt{0.86} \\approx 0.927$ 的复共轭。所有谱半径均小于 $1$。所有 $\\Sigma_u^{(k)}$ 矩阵的行列式和迹均为正，证实了其正定性。该问题是适定的。\n- **客观性**：问题以精确的数学术语陈述，没有主观性或模糊性。\n- **完整性和一致性**：为每个测试案例提供了所有必要的矩阵（$A$、$\\Sigma_u$）和条件。设置中没有矛盾。\n- **现实性和可行性**：参数值在经济模型的现实范围内。计算任务是可行的。\n\n### 步骤 3：结论与行动\n\n该问题是有效的。它是计量经济学建模中一个标准的、适定的练习。将提供一个解决方案。\n\n### 解决方案\n\n任务是使用长期约束来识别二元 VAR(1) 模型的结构冲击矩阵 $B$。这是结构计量经济学中一个经典的识别问题。我们从第一性原理出发。\n\n模型由 $x_t = A x_{t-1} + u_t$ 给出，其中 $u_t = B e_t$ 且 $\\mathbb{E}[e_t e_t^\\top] = I_2$。简化式残差的协方差为 $\\Sigma_u = \\mathbb{E}[u_t u_t^\\top] = \\mathbb{E}[B e_t e_t^\\top B^\\top] = B \\mathbb{E}[e_t e_t^\\top] B^\\top = B I_2 B^\\top = B B^\\top$。这是协方差约束。\n\n通过递归替换获得 $x_t$ 的向量移动平均（VMA）表示：\n$$\nx_t = \\sum_{h=0}^{\\infty} A^h u_{t-h} = \\sum_{h=0}^{\\infty} A^h B e_{t-h}\n$$\n在时期 $h$ 的脉冲响应矩阵是 $A^h B$。长期累积效应矩阵 $\\Psi(1)$ 是所有脉冲响应矩阵的总和：\n$$\n\\Psi(1) = \\sum_{h=0}^{\\infty} A^h B\n$$\n由于谱半径 $\\rho(A)  1$，矩阵几何级数收敛于 $\\Psi(1) = (I_2 - A)^{-1} B$。令 $C \\equiv (I_2 - A)^{-1}$。则长期矩阵为 $\\Psi(1) = C B$。\n\n识别策略依赖于两组约束来唯一确定 $B$。\n\n1.  **协方差约束**：$B B^\\top = \\Sigma_u$。该方程意味着 $B$ 是正定矩阵 $\\Sigma_u$ 的一个矩阵平方根。任何满足此关系的矩阵 $B$ 都可以参数化为 $B = P_0 Q$，其中 $P_0$ 是 $\\Sigma_u$ 的一个特定矩阵平方根（为确定性起见，我们选择下三角 Cholesky 因子，$P_0 P_0^\\top = \\Sigma_u$ 且 $P_{0,ii} > 0$），而 $Q$ 是一个任意的 $2 \\times 2$ 正交矩阵（$Q Q^\\top = I_2$）。任务简化为找到正确的 $Q$。\n\n2.  **长期约束**：$[\\Psi(1)]_{1,2} = 0$。代入 $\\Psi(1)$ 和 $B$ 的表达式，我们得到：\n    $$\n    [C(P_0 Q)]_{1,2} = 0\n    $$\n    令 $S = C P_0$。约束变为 $[S Q]_{1,2} = 0$。一个通用的 $2 \\times 2$ 旋转矩阵由下式给出：\n    $$\n    Q(\\theta) = \\begin{bmatrix} \\cos\\theta  -\\sin\\theta \\\\ \\sin\\theta  \\cos\\theta \\end{bmatrix}\n    $$\n    令 $s_{1}^\\top$ 为 $S$ 的第一行，$s_1^\\top = [S_{11}, S_{12}]$，令 $q_2$ 为 $Q$ 的第二列，$q_2 = [-\\sin\\theta, \\cos\\theta]^\\top$。约束是点积 $s_1^\\top q_2 = 0$：\n    $$\n    -S_{11} \\sin\\theta + S_{12} \\cos\\theta = 0\n    $$\n    这意味着 $\\tan\\theta = S_{12} / S_{11}$，前提是 $S_{11} \\neq 0$。该方程确定了角度 $\\theta$（相差 $\\pi$ 的整数倍），从而产生两个候选旋转矩阵，$Q(\\theta)$ 和 $Q(\\theta+\\pi) = -Q(\\theta)$。为了计算方便，我们可以使用双参数反正切函数唯一确定 $\\theta \\in (-\\pi, \\pi]$：$\\theta = \\operatorname{arctan2}(S_{12}, S_{11})$。这给出了一个唯一的 $Q$。\n\n3.  **符号归一化**：$B_{1,1} > 0$ 和 $B_{2,2} > 0$。\n    我们从一个初始解 $B_{init} = P_0 Q(\\theta)$ 开始。协方差和长期约束对于形如 $[\\pm b_1, \\pm b_2]$ 的任何矩阵都满足，其中 $B_{init}=[b_1, b_2]$。我们必须选择列的符号以满足归一化。令 $B^{(0)} = P_0 Q(\\theta)$。我们按如下方式构建最终矩阵 $B$：\n    - 设置第一列 $B_{:,1}$。如果 $B^{(0)}_{1,1}  0$，我们设置 $B_{:,1} = -B^{(0)}_{:,1}$。否则，$B_{:,1} = B^{(0)}_{:,1}$。这确保了 $B_{1,1} \\geq 0$。\n    - 设置第二列 $B_{:,2}$。使用（可能符号翻转的）第一列，我们形成一个新的中间矩阵。如果其 $(2,2)$ 元素为负，我们翻转第二列 $B^{(0)}_{:,2}$ 的符号以形成 $B_{:,2}$。这确保了 $B_{2,2} \\geq 0$。\n    严格不等式 $B_{1,1} > 0, B_{2,2} > 0$ 意味着对角线元素都不会为零，这对于所提供的测试案例是成立的。\n\n计算算法如下：\n对于每个测试案例 $(A, \\Sigma_u)$：\n1.  计算 $C = (I_2 - A)^{-1}$。\n2.  计算 $\\Sigma_u$ 的下三角 Cholesky 因子 $P_0$，使得 $P_0 P_0^\\top = \\Sigma_u$。\n3.  计算矩阵 $S = C P_0$。\n4.  确定旋转角度 $\\theta = \\operatorname{arctan2}(S_{0,1}, S_{0,0})$。\n5.  构建旋转矩阵 $Q(\\theta)$。\n6.  计算初始候选矩阵 $B_{init} = P_0 Q(\\theta)$。\n7.  调整 $B_{init}$ 的列符号以获得满足 $B_{1,1} > 0$ 和 $B_{2,2} > 0$ 的最终矩阵 $B$。\n8.  计算诊断指标：\n    - 长期效应矩阵 $\\Psi(1) = C B$ 并提取其 $(1,2)$ 元素，$[\\Psi(1)]_{1,2}$。\n    - 重建误差的弗罗贝尼乌斯范数，$\\|B B^\\top - \\Sigma_u\\|_F$。\n    - $B$ 的元素，按行主序排列。\n两个诊断指标 $[\\Psi(1)]_{1,2}$ 和 $\\|B B^\\top - \\Sigma_u\\|_F$ 在数值上都应接近于零，作为对实现正确性的检验。",
            "answer": "```python\nimport numpy as np\nimport scipy.linalg\n\ndef solve():\n    \"\"\"\n    Solves for the structural impact matrix B in a bivariate VAR(1) model\n    using Blanchard-Quah long-run restrictions for several test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case 1 (happy path)\n        {\n            \"A\": np.array([[0.3, 0.1], [0.05, 0.2]]),\n            \"Sigma_u\": np.array([[0.5, 0.1], [0.1, 0.3]]),\n        },\n        # Case 2 (boundary with zero dynamics)\n        {\n            \"A\": np.array([[0.0, 0.0], [0.0, 0.0]]),\n            \"Sigma_u\": np.array([[1.0, 0.2], [0.2, 2.0]]),\n        },\n        # Case 3 (high persistence, but stable)\n        {\n            \"A\": np.array([[0.95, -0.1], [0.05, 0.9]]),\n            \"Sigma_u\": np.array([[0.2, -0.05], [-0.05, 0.4]]),\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        A = case[\"A\"]\n        Sigma_u = case[\"Sigma_u\"]\n        K = A.shape[0]\n\n        # Step 1: Compute C = (I - A)^-1\n        I = np.identity(K)\n        C = scipy.linalg.inv(I - A)\n\n        # Step 2: Compute lower Cholesky factor P0 of Sigma_u\n        # P0 P0.T = Sigma_u\n        P0 = scipy.linalg.cholesky(Sigma_u, lower=True)\n\n        # Step 3: Compute S = C * P0\n        S = C @ P0\n\n        # Step 4: Determine the rotation angle from the long-run restriction\n        # [S*Q]_12 = -S_11*sin(theta) + S_12*cos(theta) = 0\n        # tan(theta) = S_12 / S_11\n        theta = np.arctan2(S[0, 1], S[0, 0])\n\n        # Step 5: Construct the rotation matrix Q\n        c, s = np.cos(theta), np.sin(theta)\n        Q = np.array([[c, -s], [s, c]])\n\n        # Step 6: Compute initial B matrix\n        B_init = P0 @ Q\n\n        # Step 7: Apply sign normalization B_11 > 0 and B_22 > 0\n        B = B_init.copy()\n        # Ensure B[0, 0] > 0\n        if B[0, 0]  0:\n            B[:, 0] *= -1\n        # Ensure B[1, 1] > 0\n        if B[1, 1]  0:\n            B[:, 1] *= -1\n\n        # Step 8: Compute diagnostics\n        # Long-run effect matrix Psi(1) = C * B\n        Psi1 = C @ B\n        # Extract the restricted element [Psi(1)]_12\n        psi1_12 = Psi1[0, 1]\n\n        # Frobenius norm of the covariance reconstruction error\n        recon_error = scipy.linalg.norm(B @ B.T - Sigma_u, 'fro')\n\n        # Elements of B in row-major order\n        b_elements = B.flatten().tolist()\n\n        # Compile results for the current case\n        case_result = [psi1_12, recon_error] + b_elements\n        results.append(case_result)\n\n    # Format the final output string as specified\n    output_parts = []\n    for r in results:\n        formatted_r = [f\"{x:.6f}\" for x in r]\n        output_parts.append(f\"[{','.join(formatted_r)}]\")\n    \n    final_output = f\"[{','.join(output_parts)}]\"\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}