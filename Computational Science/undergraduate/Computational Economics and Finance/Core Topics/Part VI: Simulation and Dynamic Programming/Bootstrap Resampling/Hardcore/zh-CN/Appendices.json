{
    "hands_on_practices": [
        {
            "introduction": "本练习将引导你直接动手实践非参数自助法。我们将以风险投资回报率这类典型的非正态数据为例，为总体中位数构建一个置信区间，而中位数是一个难以用解析方法处理的稳健统计量。通过完成这个练习 ，你将掌握实施自助法重抽样流程的核心编程技能，并体会其在无法依赖传统理论公式时的强大作用。",
            "id": "2377547",
            "problem": "考虑一个风险投资交易层面的简单回报率数据集，其中每笔交易 $i$ 的回报率定义为 $r_i = \\dfrac{\\text{cash\\_out}_i - \\text{cash\\_in}_i}{\\text{cash\\_in}_i}$，因此 $r_i \\in [-1, +\\infty)$。假设观测到的回报率是来自一个未知分布的实现，并且数据是独立同分布的（IID）。设一个多重集 $x_1, x_2, \\ldots, x_n$ 的样本中位数定义为：当 $n$ 为奇数时，取中间的顺序统计量；当 $n$ 为偶数时，取中间两个顺序统计量的平均值。\n\n你的任务是，对于下述每个测试案例，根据以下 bootstrap 百分位区间的定义，计算总体中位数的双侧置信区间。设 $T$ 表示样本中位数泛函。对于给定的数据集 $D = [x_1, x_2, \\ldots, x_n]$，定义经验分布 $\\hat{F}_n$，它将 $1/n$ 的概率质量赋给每个观测值（计算重复值）。对于一个给定的整数 $B \\ge 1$，从 $\\hat{F}_n$ 中抽取 $B$ 个独立同分布的 bootstrap 重抽样样本，每个样本大小为 $n$（即从多重集 $D$ 中有放回地抽样）。对于每个重抽样样本 $b \\in \\{1, 2, \\ldots, B\\}$，计算 $T_b = T(D^{\\ast}_b)$，即第 $b$ 个重抽样样本的样本中位数。设 $T_{(1)} \\le T_{(2)} \\le \\cdots \\le T_{(B)}$ 为排序后的值。对于一个名义双侧置信水平 $1 - \\alpha \\in (0,1)$，将下端点定义为经验 $p$-分位数（其中 $p = \\alpha/2$），上端点定义为经验 $q$-分位数（其中 $q = 1 - \\alpha/2$）。对于任意概率水平 $u \\in [0,1]$，经验分位数 $Q(u)$ 通过对排序后的索引进行线性插值来定义：\n- 设 $k = 1 + (B - 1)u$。\n- 若 $k \\le 1$，则设 $Q(u) = T_{(1)}$；若 $k \\ge B$，则设 $Q(u) = T_{(B)}$。\n- 否则，记 $k = m + \\delta$，其中 $m = \\lfloor k \\rfloor$ 且 $\\delta \\in (0,1)$，并设 $Q(u) = (1 - \\delta) T_{(m)} + \\delta T_{(m+1)}$。\n\n为了可复现性，对于每个测试案例，在抽取 $B$ 个 bootstrap 重抽样样本之前，请使用指定的整数种子初始化伪随机数生成器。\n\n测试套件：\n- 案例 1：$D_1 = [-1.0, -0.8, -0.6, -0.5, -0.3, -0.1, 0.0, 0.2, 0.25, 0.35, 0.4, 0.5, 0.6, 0.9, 1.2, 1.5, 2.0, 3.0, 5.0]$，$B_1 = 20000$，$\\alpha_1 = 0.10$，种子 $S_1 = 202311$。\n- 案例 2：$D_2 = [-1.0, -0.9, -0.9, -0.5, -0.2, -0.1, 0.0, 0.05]$，$B_2 = 15000$，$\\alpha_2 = 0.20$，种子 $S_2 = 7$。\n- 案例 3：$D_3 = [-1.0, -1.0, -0.5, -0.5, 0.0, 0.0, 0.4, 0.4, 0.4, 1.0, 1.0, 2.5]$，$B_3 = 30000$，$\\alpha_3 = 0.05$，种子 $S_3 = 12345$。\n- 案例 4：$D_4 = [0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3]$，$B_4 = 10000$，$\\alpha_4 = 0.10$，种子 $S_4 = 99$。\n\n你的程序必须为每个案例计算上述定义的配对 $[\\ell, u] = [Q(\\alpha/2), Q(1 - \\alpha/2)]$。每个界限必须报告为小数点后保留六位的小数。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含四个案例的结果，格式为方括号括起来的逗号分隔列表，每个案例是一个包含两个元素的列表 $[\\ell, u]$。例如：$[[\\ell_1,u_1],[\\ell_2,u_2],[\\ell_3,u_3],[\\ell_4,u_4]]$，其中每个数值都四舍五入到小数点后六位。",
            "solution": "问题陈述已经过分析，被认为是有效的。它具有科学依据、提法明确、客观，并为标准的计算统计问题提供了一套完整且一致的给定条件。任务是给定若干数据集和参数，计算总体中位数的 bootstrap 百分位置信区间。\n\n需要实现的方法是 bootstrap 百分位区间法。这是一种非参数统计技术，用于估计统计量的抽样分布，并由此构建置信区间，而无需对潜在的总体分布做出强假设。bootstrap 的基本原理是使用观测样本 $D = \\{x_1, x_2, \\ldots, x_n\\}$ 的经验分布函数 $\\hat{F}_n$ 作为对真实、未知的总体分布 $F$ 的近似。在 $\\hat{F}_n$ 中，每个观测数据点 $x_i$ 被赋予 $1/n$ 的概率质量。\n\n算法流程如下：\n$1$.\n对于一个大小为 $n$ 的给定数据集 $D$，我们抽取大量的（$B$ 个）bootstrap 重抽样样本。每个重抽样样本，记为 $D^{\\ast}_b$（$b \\in \\{1, 2, \\ldots, B\\}$），大小为 $n$，通过从原始数据集 $D$ 中有放回地抽样获得。这个过程是从经验分布 $\\hat{F}_n$ 中抽取独立同分布样本的计算实现。\n\n$2$.\n对于每个 bootstrap 重抽样样本 $D^{\\ast}_b$，我们计算感兴趣的统计量。在本问题中，该统计量是样本中位数，记为 $T$。设 $T_b = T(D^{\\ast}_b)$ 为第 $b$ 个重抽样样本的样本中位数。样本中位数的定义是：对于奇数大小的样本，取中间的顺序统计量；对于偶数大小的样本，取中间两个顺序统计量的算术平均值。\n\n$3$.\n$B$ 个 bootstrap 统计量的集合 $\\{T_1, T_2, \\ldots, T_B\\}$，作为样本中位数 $T$ 的抽样分布的经验近似。\n\n$4$.\n为了构建一个名义置信水平为 $1-\\alpha$ 的双侧置信区间，我们使用百分位法。这涉及到找到排序后的 bootstrap 统计量 $T_{(1)} \\le T_{(2)} \\le \\cdots \\le T_{(B)}$ 的适当分位数。置信区间的下界 $\\ell$ 是该分布的经验 $(\\alpha/2)$-分位数，上界 $u$ 是经验 $(1 - \\alpha/2)$-分位数。\n\n$5$.\n问题为经验分位数 $Q(u)$ 的计算提供了精确定义，适用于任意概率水平 $u \\in [0,1]$。它使用顺序统计量之间的线性插值。该过程涉及计算一个索引 $k = 1 + (B - 1)u$，并且如果 $1  k  B$，则在值 $T_{(\\lfloor k \\rfloor)}$ 和 $T_{(\\lfloor k \\rfloor + 1)}$ 之间进行插值。这个特定规则对应于标准的分位数线性插值方法，例如在 `numpy.quantile` 函数中使用 `interpolation='linear'` 选项实现。使用此特定函数可确保遵循问题定义。\n\n$6$.\n为了科学可复现性，用于重抽样的伪随机数生成器必须在每个测试案例中用特定的种子进行初始化。这确保了 bootstrap 重抽样样本的序列是确定性的，并且结果可以被独立验证。\n\n下面的实现将为提供的四个测试案例中的每一个执行此算法，计算指定的置信区间界限，并按要求将它们四舍五入到小数点后六位。对于原始样本中所有数据点都相同的特殊情况（如案例4），任何 bootstrap 重抽样样本也将由相同的值组成。因此，每个 bootstrap 重抽样样本的中位数都将是这个相同的值，最终的置信区间将坍缩为单个点。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are required or permitted.\n\ndef solve():\n    \"\"\"\n    Computes bootstrap percentile confidence intervals for the median for several test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        {\n            'D': [-1.0, -0.8, -0.6, -0.5, -0.3, -0.1, 0.0, 0.2, 0.25, 0.35, 0.4, 0.5, 0.6, 0.9, 1.2, 1.5, 2.0, 3.0, 5.0],\n            'B': 20000,\n            'alpha': 0.10,\n            'seed': 202311\n        },\n        # Case 2\n        {\n            'D': [-1.0, -0.9, -0.9, -0.5, -0.2, -0.1, 0.0, 0.05],\n            'B': 15000,\n            'alpha': 0.20,\n            'seed': 7\n        },\n        # Case 3\n        {\n            'D': [-1.0, -1.0, -0.5, -0.5, 0.0, 0.0, 0.4, 0.4, 0.4, 1.0, 1.0, 2.5],\n            'B': 30000,\n            'alpha': 0.05,\n            'seed': 12345\n        },\n        # Case 4\n        {\n            'D': [0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3],\n            'B': 10000,\n            'alpha': 0.10,\n            'seed': 99\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Extract parameters for the current case.\n        D = np.array(case['D'])\n        B = case['B']\n        alpha = case['alpha']\n        seed = case['seed']\n        n = len(D)\n\n        # 1. Initialize the pseudo-random number generator for reproducibility.\n        rng = np.random.default_rng(seed)\n\n        # 2. Generate B bootstrap resamples and compute the median for each.\n        # Pre-allocate array for efficiency.\n        bootstrap_medians = np.zeros(B)\n        for i in range(B):\n            # Draw a bootstrap resample of size n with replacement.\n            resample = rng.choice(D, size=n, replace=True)\n            # Compute the median of the resample.\n            bootstrap_medians[i] = np.median(resample)\n\n        # 3. Sort the bootstrap medians to prepare for quantile calculation.\n        bootstrap_medians.sort()\n\n        # 4. Compute the lower and upper quantiles for the confidence interval.\n        # The problem's quantile definition matches numpy's 'linear' interpolation.\n        p_lower = alpha / 2.0\n        p_upper = 1.0 - alpha / 2.0\n\n        lower_bound = np.quantile(bootstrap_medians, p_lower, interpolation='linear')\n        upper_bound = np.quantile(bootstrap_medians, p_upper, interpolation='linear')\n\n        # 5. Round the results to six decimal places as required by the problem.\n        l_rounded = round(lower_bound, 6)\n        u_rounded = round(upper_bound, 6)\n        \n        results.append([l_rounded, u_rounded])\n\n    # Final print statement in the exact required format.\n    # The format is a list of lists, with numeric values rounded to 6 decimal places.\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the main function.\nsolve()\n```"
        },
        {
            "introduction": "在掌握了基本的非参数自助法后，本练习  将带你探索其另一重要分支：参数自助法。你将对同一组生成数据同时应用两种方法，并比较它们的区间长度和覆盖准确率。这个对比练习清晰地揭示了统计推断中的一个核心权衡：当模型假设正确时，参数方法可以提供更高的效率（更窄的区间）；而当模型未知或可能设定错误时，非参数方法则表现出更强的稳健性。",
            "id": "2377478",
            "problem": "给定代表非负经济量（如交易持续时间或损失程度）的独立同分布观测值。假设每个测试用例的真实数据生成过程是具有未知参数的伽马分布族。您的任务是使用两种不同的重抽样范式为总体均值构建双侧置信区间，并根据已知的真实值评估它们的表现。\n\n设样本表示为 $\\{x_1,\\dots,x_n\\}$，其中 $n \\in \\mathbb{N}$。设伽马分布族由形状参数 $k \\in (0,\\infty)$ 和尺度参数 $\\theta \\in (0,\\infty)$ 参数化，因此总体均值为 $\\mu = k \\theta$。对于下面的每个测试用例，必须通过使用指定的数据生成种子从指定的伽马分布中抽取大小为 $n$ 的样本来生成数据，然后必须按如下方式为 $\\mu$ 构建两个覆盖水平为 $1-\\alpha$ 的双侧置信区间：\n\n- 基于模型的重抽样：对数据的未知分布施加伽马分布族，并在位置参数为零的约束下，通过最大似然法从已实现的样本中估计 $(k,\\theta)$。使用拟合的模型通过重抽样来近似样本均值的抽样分布。\n- 经验重抽样：将对每个观测值 $x_i$ 赋予 $1/n$ 质量的经验分布视为数据生成分布，并通过重抽样来近似样本均值的抽样分布。\n\n在这两种范式中，都通过从各自的分布中生成 $B$ 个大小为 $n$ 的独立重抽样样本来近似样本均值的分布，计算每个重抽样样本的样本均值，然后将这些重抽样均值的经验 $\\alpha/2$ 和 $1-\\alpha/2$ 分位数作为下端点和上端点。\n\n为保证可复现性，适用以下要求：\n\n- 对于每个测试用例，必须使用为该用例指定的、以数据生成种子初始化的独立伪随机流来生成数据集。\n- 对于所有测试用例中的所有重抽样操作，使用以种子 $2025$ 初始化一次的单一伪随机流。\n- 对所有测试用例使用相同的 $B$ 和 $\\alpha$。\n\n测试套件：\n\n- 案例 $1$：形状 $k=2.5$，尺度 $\\theta=1.2$，样本大小 $n=80$，数据生成种子 $1729$。\n- 案例 $2$：形状 $k=1.1$，尺度 $\\theta=2.0$，样本大小 $n=20$，数据生成种子 $2027$。\n- 案例 $3$：形状 $k=5.0$，尺度 $\\theta=0.5$，样本大小 $n=50$，数据生成种子 $12345$。\n- 案例 $4$：形状 $k=0.7$，尺度 $\\theta=1.5$，样本大小 $n=12$，数据生成种子 $314159$。\n\n通用设置：名义覆盖率 $1-\\alpha=0.95$（因此 $\\alpha=0.05$），重抽样次数 $B=10000$。\n\n对于每个案例，按 1 到 4 的顺序，计算并记录以下 7 个量：\n\n- $L_{\\mathrm{M}}$，基于模型的区间的下端点。\n- $U_{\\mathrm{M}}$，基于模型的区间的上端点。\n- $L_{\\mathrm{E}}$，经验重抽样区间的下端点。\n- $U_{\\mathrm{E}}$，经验重抽样区间的上端点。\n- 一个指示符 $I$，如果基于模型的区间长度严格小于经验重抽样区间的长度，则其值为 $\\mathrm{True}$，否则为 $\\mathrm{False}$。\n- 一个覆盖指示符 $C_{\\mathrm{M}}$，如果真实均值 $\\mu = k \\theta$ 位于基于模型的区间 $[L_{\\mathrm{M}},U_{\\mathrm{M}}]$ 内，则其值为 $\\mathrm{True}$，否则为 $\\mathrm{False}$。\n- 一个覆盖指示符 $C_{\\mathrm{E}}$，如果真实均值 $\\mu = k \\theta$ 位于经验重抽样区间 $[L_{\\mathrm{E}},U_{\\mathrm{E}}]$ 内，则其值为 $\\mathrm{True}$，否则为 $\\mathrm{False}$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。该列表必须按顺序连接案例 1 的 7 个输出，然后是案例 2 的 7 个输出，接着是案例 3，然后是案例 4。例如，输出必须具有以下形式：$[L_{\\mathrm{M}}^{(1)},U_{\\mathrm{M}}^{(1)},L_{\\mathrm{E}}^{(1)},U_{\\mathrm{E}}^{(1)},I^{(1)},C_{\\mathrm{M}}^{(1)},C_{\\mathrm{E}}^{(1)},\\dots,L_{\\mathrm{M}}^{(4)},U_{\\mathrm{M}}^{(4)},L_{\\mathrm{E}}^{(4)},U_{\\mathrm{E}}^{(4)},I^{(4)},C_{\\mathrm{M}}^{(4)},C_{\\mathrm{E}}^{(4)}]$，其中上标表示案例索引。所有数字都是实数，指示符是布尔值。不需要物理单位。",
            "solution": "该问题涉及在假设数据独立同分布的情况下，为正值经济变量的总体均值构建和比较两种近似置信区间。核心关注量是总体均值 $\\mu = \\mathbb{E}[X]$，其中 $X$ 表示单个观测值。\n\n基础设置：\n\n- 设 $X_1,\\dots,X_n$ 为独立同分布，其共同分布的支撑集为 $[0,\\infty)$。\n- 样本均值为 $\\bar{X}_n = \\frac{1}{n}\\sum_{i=1}^n X_i$。\n- 我们寻求一个名义覆盖率为 $1-\\alpha$ 的双侧区间 $[L,U]$，使得 $\\mathbb{P}(\\mu \\in [L,U]) \\approx 1-\\alpha$。\n\n重抽样的基本原理：\n\n- 自助法（bootstrap）的基本思想是通过在某个分布（可以是拟合的参数模型或经验分布）下进行重复抽样，来近似一个统计量的抽样分布。对于一个统计量 $T = t(X_1,\\dots,X_n)$，其在真实模型下的抽样分布通常是未知的。然而，可以通过从一个代理分布中重抽样，并重复计算 $T$ 来为其构建经验分布，从而近似该抽样分布。\n\n此处需要两种重抽样范式：\n\n- 基于伽马分布族的模型重抽样：\n\n  - 假设 $X_i$ 的分布属于参数族 $\\{ \\mathrm{Gamma}(k,\\theta) : k>0,\\ \\theta>0\\}$。其概率密度函数为\n    $$ f(x;k,\\theta) = \\frac{1}{\\Gamma(k)\\,\\theta^k} x^{k-1} e^{-x/\\theta}, \\quad x\\ge 0, $$\n    其中 $\\Gamma(\\cdot)$ 是伽马函数，$k$ 是形状参数，$\\theta$ 是尺度参数，这意味着均值为 $\\mu = k\\theta$。\n  - 在位置参数为零的约束下，通过最大似然法从观测样本中估计 $(k,\\theta)$。最大似然估计量 $(\\hat{k},\\hat{\\theta})$ 定义为\n    $$ (\\hat{k},\\hat{\\theta}) \\in \\arg\\max_{k>0,\\ \\theta>0} \\sum_{i=1}^n \\log f(x_i;k,\\theta). $$\n    此估计仅使用观测样本和伽马分布族。\n  - 为了近似 $\\bar{X}_n$ 的抽样分布，生成 $B$ 个独立的重抽样样本，每个样本包含 $n$ 个从 $\\mathrm{Gamma}(\\hat{k},\\hat{\\theta})$ 中抽取的独立值。对于每个重抽样样本 $b\\in\\{1,\\dots,B\\}$，计算其均值 $\\bar{X}_n^{(b)}$。$\\{\\bar{X}_n^{(1)},\\dots,\\bar{X}_n^{(B)}\\}$ 的经验分布近似了参数模型下 $\\bar{X}_n$ 的抽样分布。\n\n- 经验重抽样：\n\n  - 考虑经验分布 $\\hat{F}_n$，它为每个观测值 $x_i$ 分配了 $1/n$ 的质量。\n  - 生成 $B$ 个独立的重抽样样本，每个样本都是通过从 $\\hat{F}_n$ 中独立抽取 $n$ 个观测值而形成的（即从观测样本中有放回地抽样）。对于每个重抽样样本 $b\\in\\{1,\\dots,B\\}$，计算其均值 $\\bar{X}_n^{*(b)}$。$\\{\\bar{X}_n^{*(1)},\\dots,\\bar{X}_n^{*(B)}\\}$ 的经验分布近似了经验分布下 $\\bar{X}_n$ 的抽样分布。\n\n区间构建原则：\n\n- 对于任意一组重抽样均值 $\\{M_b\\}_{b=1}^B$，通过经验分位数定义双侧 $(1-\\alpha)$ 区间，\n  $$ L = \\mathrm{Quantile}_{\\alpha/2}\\left(\\{M_b\\}_{b=1}^B\\right), \\quad U = \\mathrm{Quantile}_{1-\\alpha/2}\\left(\\{M_b\\}_{b=1}^B\\right). $$\n  这就是百分位数法，它直接使用统计量的近似抽样分布来设定端点。\n\n确定性与可复现性：\n\n- 通过固定伪随机数生成器的种子来确保确定性。对于每个测试用例，使用指定的数据生成种子从已知形状 $k$ 和尺度 $\\theta$ 的伽马分布中生成数据，从而得到一个具体的已实现样本。对于重抽样，所有案例的所有 $B$ 次重抽样都使用一个具有固定种子的单一伪随机流。\n\n验证与比较：\n\n- 对于每个案例，真实均值为 $\\mu_{\\mathrm{true}} = k\\theta$。在获得基于模型的区间 $[L_{\\mathrm{M}},U_{\\mathrm{M}}]$ 和经验重抽样区间 $[L_{\\mathrm{E}},U_{\\mathrm{E}}]$ 后，计算：\n  - 长度比较指示符 $I = \\mathbf{1}\\{(U_{\\mathrm{M}}-L_{\\mathrm{M}})  (U_{\\mathrm{E}}-L_{\\mathrm{E}})\\}$。\n  - 覆盖指示符 $C_{\\mathrm{M}} = \\mathbf{1}\\{\\mu_{\\mathrm{true}} \\in [L_{\\mathrm{M}},U_{\\mathrm{M}}]\\}$ 和 $C_{\\mathrm{E}} = \\mathbf{1}\\{\\mu_{\\mathrm{true}} \\in [L_{\\mathrm{E}},U_{\\mathrm{E}}]\\}$。\n\n算法映射：\n\n- 对于每个测试用例 $(k,\\theta,n,\\text{seed})$：\n  - 使用指定的数据生成种子，通过从 $\\mathrm{Gamma}(k,\\theta)$ 中抽取 $n$ 个独立值来生成数据集 $x_1,\\dots,x_n$。\n  - 计算位置为零的伽马分布族的最大似然估计 $(\\hat{k},\\hat{\\theta})$。\n  - 使用固定的重抽样种子，从 $\\mathrm{Gamma}(\\hat{k},\\hat{\\theta})$ 中生成 $B$ 个大小为 $n$ 的基于模型的重抽样样本，并计算重抽样均值向量；将这些均值的 $\\alpha/2$ 和 $1-\\alpha/2$ 经验分位数计算为 $L_{\\mathrm{M}}$ 和 $U_{\\mathrm{M}}$。\n  - 使用相同的固定重抽样种子流（延续同一个伪随机数生成器），通过从 $\\{x_i\\}_{i=1}^n$ 中有放回地抽样生成 $B$ 个经验重抽样样本，并计算重抽样均值向量；计算 $\\alpha/2$ 和 $1-\\alpha/2$ 经验分位数作为 $L_{\\mathrm{E}}$ 和 $U_{\\mathrm{E}}$。\n  - 计算如上定义的 $I$、$C_{\\mathrm{M}}$ 和 $C_{\\mathrm{E}}$。\n\n复杂性与数值考量：\n\n- 每个重抽样步骤都是向量化的：生成一个大小为 $B \\times n$ 的矩阵，并沿行求平均值，可以高效地得到 $B$ 个均值。然后对这 $B$ 个值计算分位数。当 $B=10000$ 且 $n$ 适中时，总计算量是可处理的。\n- 固定重抽样种子确保了可复现的结果，这对于确定性的单行输出是必需的。\n\n要求的输出是按顺序将案例 1 到 4 的 $[L_{\\mathrm{M}},U_{\\mathrm{M}},L_{\\mathrm{E}},U_{\\mathrm{E}},I,C_{\\mathrm{M}},C_{\\mathrm{E}}]$ 连接起来，并作为单个列表打印在一行上。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import gamma as sp_gamma\n\ndef percentile_interval(samples, alpha):\n    # Compute the (alpha/2, 1 - alpha/2) empirical quantiles\n    q_low = np.quantile(samples, alpha / 2.0, method=\"linear\")\n    q_high = np.quantile(samples, 1.0 - alpha / 2.0, method=\"linear\")\n    return float(q_low), float(q_high)\n\ndef generate_data(shape_k, scale_theta, n, seed):\n    rng = np.random.default_rng(seed)\n    data = rng.gamma(shape_k, scale_theta, size=n)\n    return data\n\ndef fit_gamma_mle_zero_loc(data):\n    # Fit Gamma distribution with zero location via maximum likelihood\n    # scipy.stats.gamma.fit returns (shape, loc, scale)\n    # We fix location to 0 using floc=0\n    k_hat, loc_hat, theta_hat = sp_gamma.fit(data, floc=0.0)\n    # loc_hat should be 0.0 by construction\n    return float(k_hat), float(theta_hat)\n\ndef bootstrap_intervals_for_mean(data, B, alpha, rng_boot):\n    n = data.shape[0]\n    # Parametric (model-based) bootstrap using fitted Gamma\n    k_hat, theta_hat = fit_gamma_mle_zero_loc(data)\n    # Generate B x n Gamma draws and compute means\n    param_draws = rng_boot.gamma(shape=k_hat, scale=theta_hat, size=(B, n))\n    param_means = param_draws.mean(axis=1)\n    L_M, U_M = percentile_interval(param_means, alpha)\n\n    # Empirical (nonparametric) bootstrap: resample with replacement from data\n    idx = rng_boot.integers(0, n, size=(B, n))\n    emp_resamples = data[idx]\n    emp_means = emp_resamples.mean(axis=1)\n    L_E, U_E = percentile_interval(emp_means, alpha)\n\n    return L_M, U_M, L_E, U_E\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each tuple: (shape k, scale theta, n, data-generation seed)\n    test_cases = [\n        (2.5, 1.2, 80, 1729),     # Case 1\n        (1.1, 2.0, 20, 2027),     # Case 2\n        (5.0, 0.5, 50, 12345),    # Case 3\n        (0.7, 1.5, 12, 314159),   # Case 4\n    ]\n\n    alpha = 0.05\n    B = 10000\n\n    # Single pseudorandom stream for all resampling operations\n    rng_boot = np.random.default_rng(2025)\n\n    results = []\n    for (k_true, theta_true, n, data_seed) in test_cases:\n        # Generate data for this case\n        data = generate_data(k_true, theta_true, n, data_seed)\n\n        # Compute intervals\n        L_M, U_M, L_E, U_E = bootstrap_intervals_for_mean(data, B, alpha, rng_boot)\n\n        # Interval length comparison indicator\n        len_M = U_M - L_M\n        len_E = U_E - L_E\n        shorter_parametric = len_M  len_E\n\n        # Coverage indicators wrt true mean\n        mu_true = k_true * theta_true\n        cover_M = (L_M = mu_true) and (mu_true = U_M)\n        cover_E = (L_E = mu_true) and (mu_true = U_E)\n\n        # Append in the specified order\n        results.extend([L_M, U_M, L_E, U_E, shorter_parametric, cover_M, cover_E])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "这是一个高级练习，旨在探讨自助法在实际应用中的一个关键问题：如何选择重抽样次数 $B$。通过一个引导性的模拟研究 ，你将发现自助法本身也是一个随机过程，其得出的置信区间会因随机抽样而存在变异。本练习将让你亲手量化这种不稳定性，并理解增加 $B$ 的值是如何帮助我们获得更稳定、更可复现的结果，这是任何严谨应用都必须考量的因素。",
            "id": "2377512",
            "problem": "考虑单一资产，其每日对数回报率为独立同分布 (i.i.d.)。令一个实现样本表示为 $\\{X_i\\}_{i=1}^n$。定义样本均值为 $\\hat{\\mu} = \\frac{1}{n}\\sum_{i=1}^n X_i$。对于给定的 bootstrap 复制次数 $B$，通过从实现样本中有放回地重复抽取 $n$ 个观测值，并为每个重抽样样本计算均值，来定义 $\\hat{\\mu}$ 的 bootstrap 抽样分布。置信水平为 $0.95$ 的双侧置信区间由 $\\hat{\\mu}$ 的 bootstrap 分布在 $0.025$ 和 $0.975$ 水平上的经验分位数定义，使用顺序统计量之间的线性插值法。将这些端点表示为 $L(B)$（下限）和 $U(B)$（上限）。\n\n为了量化端点相对于 $B$ 的稳定性，考虑使用相同的实现样本但不同的随机种子，对整个 bootstrap 过程进行 $\\mathcal{R}$ 次独立重复；将在第 $j \\in \\{1,\\dots,\\mathcal{R}\\}$ 次重复中的端点标记为 $\\ell_j(B)$ 和 $u_j(B)$。将稳定性度量定义为总体标准差\n$$\ns_\\ell(B) = \\left(\\frac{1}{\\mathcal{R}}\\sum_{j=1}^{\\mathcal{R}}\\left(\\ell_j(B) - \\bar{\\ell}(B)\\right)^2\\right)^{1/2},\\quad\n\\bar{\\ell}(B) = \\frac{1}{\\mathcal{R}}\\sum_{j=1}^{\\mathcal{R}} \\ell_j(B),\n$$\n和\n$$\ns_u(B) = \\left(\\frac{1}{\\mathcal{R}}\\sum_{j=1}^{\\mathcal{R}}\\left(u_j(B) - \\bar{u}(B)\\right)^2\\right)^{1/2},\\quad\n\\bar{u}(B) = \\frac{1}{\\mathcal{R}}\\sum_{j=1}^{\\mathcal{R}} u_j(B).\n$$\n\n为保证可复现性，每个测试用例的实现样本必须按照下述规定人工合成生成，并且在该测试用例的所有 $\\mathcal{R}$ 次重复中保持不变。在每次重复 $j \\in \\{0,1,\\dots,\\mathcal{R}-1\\}$ 中，bootstrap 过程必须使用一个伪随机种子，其值等于给定的基础种子加上 $j$。在生成实现样本时，请严格使用所提供的样本种子。所有伪随机数生成必须基于带有给定整数种子的现代伪随机数生成器。\n\n回报模型：\n- 高斯回报：$X_i \\sim \\mathcal{N}(\\mu,\\sigma^2)$。\n- 重尾回报：$X_i = \\mu + \\sigma \\sqrt{\\frac{\\nu - 2}{\\nu}}\\, T_{\\nu}$，其中 $T_{\\nu}$ 是自由度为 $\\nu  2$ 且单位尺度的学生t分布，因此 $\\mathrm{Var}(X_i)$ 等于 $\\sigma^2$。\n\n感兴趣的统计量：\n- 参数是平均回报率 $\\mu$，统计量是样本均值 $\\hat{\\mu}$。\n\n置信区间：\n- 端点是 $\\hat{\\mu}$ 的 bootstrap 分布在 $0.025$ 和 $0.975$ 水平上的经验分位数，采用顺序统计量之间的线性插值法。\n\n稳定性度量：\n- 对每个测试用例，报告如上定义的 $s_\\ell(B)$ 和 $s_u(B)$，四舍五入到 $6$ 位小数。\n\n测试套件：\n对于每个测试用例，参数列表为 $(\\text{dist}, n, \\mu, \\sigma, \\nu, B, \\mathcal{R}, \\text{sample\\_seed}, \\text{bootstrap\\_base\\_seed})$；当 $\\text{dist}=\\text{N}$ 时，不使用条目 $\\nu$。\n1. $(\\text{N},\\, 252,\\, 0.0005,\\, 0.01,\\, -,\\, 25,\\, 32,\\, 20231101,\\, 770000)$.\n2. $(\\text{N},\\, 252,\\, 0.0005,\\, 0.01,\\, -,\\, 200,\\, 32,\\, 20231101,\\, 770100)$.\n3. $(\\text{N},\\, 252,\\, 0.0005,\\, 0.01,\\, -,\\, 1000,\\, 32,\\, 20231101,\\, 770200)$.\n4. $(\\text{N},\\, 252,\\, 0.0005,\\, 0.01,\\, -,\\, 2000,\\, 32,\\, 20231101,\\, 770300)$.\n5. $(\\text{N},\\, 30,\\, 0.0005,\\, 0.01,\\, -,\\, 200,\\, 32,\\, 20231111,\\, 880100)$.\n6. $(\\text{T},\\, 252,\\, 0.0005,\\, 0.02,\\, 3,\\, 1000,\\, 32,\\, 20231221,\\, 990100)$.\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素都是一个双元素列表 $[s_\\ell(B), s_u(B)]$，顺序与测试用例相同，每个值四舍五入到 $6$ 位小数。例如，三个用例的有效输出应如下所示：$[[0.001234,0.001987],[0.000456,0.000765],[0.000123,0.000321]]$。\n\n不涉及物理单位。所有数值结果必须是浮点数。",
            "solution": "该问题提出了计算统计学中一个有效且定义明确的任务，具体涉及 bootstrap 置信区间的稳定性分析。我将提供一个系统的解决方案。\n\n问题的核心是量化 bootstrap 置信区间端点的变异性。这种变异性的产生是因为 bootstrap 过程本身是一个依赖于随机种子的随机过程。通过使用不同的种子多次重复整个 bootstrap 过程，我们可以观察区间端点的分布并衡量其稳定性，而标准差是衡量稳定性的一个自然度量。\n\n每个测试用例的总体流程如下：\n1.  人工合成生成一个大小为 $n$ 的资产对数回报率的实现样本 $\\{X_i\\}_{i=1}^n$。对于给定的测试用例，此样本使用指定的 `sample_seed` 生成一次，并在后续步骤中保持固定。\n2.  对 bootstrap 置信区间估计执行 $\\mathcal{R}$ 次独立重复。对于每次重复 $j \\in \\{0, 1, \\dots, \\mathcal{R}-1\\}$：\n    a.  将伪随机数生成器 (PRNG) 的种子设置为 `bootstrap_base_seed` $+ j$。这确保了 $\\mathcal{R}$ 次重复中的每一次在统计上是独立的，但在计算上是可复现的。\n    b.  生成 $B$ 个 bootstrap 样本。每个 bootstrap 样本都是通过从原始实现样本 $\\{X_i\\}_{i=1}^n$ 中有放回地抽取 $n$ 个观测值来创建的。\n    c.  对 $B$ 个 bootstrap 样本中的每一个计算样本均值。这 $B$ 个均值的集合构成了统计量 $\\hat{\\mu}$ 的经验 bootstrap 分布。\n    d.  从该经验分布中，确定双侧 $95\\%$ 置信区间。问题规定，下限和上限端点（分别表示为 $\\ell_j(B)$ 和 $u_j(B)$）是水平为 $q_{low} = 0.025$ 和 $q_{high} = 0.975$ 的经验分位数。如果分位数落在有序数据点之间，则使用线性插值法进行估计。\n3.  完成所有 $\\mathcal{R}$ 次重复后，我们将得到两组数据：$\\{\\ell_j(B)\\}_{j=0}^{\\mathcal{R}-1}$ 和 $\\{u_j(B)\\}_{j=0}^{\\mathcal{R}-1}$。\n4.  最后，计算这些端点的稳定性。问题将稳定性度量定义为这两组端点的总体标准差。令下限端点集合为 $\\boldsymbol{\\ell} = (\\ell_0(B), \\dots, \\ell_{\\mathcal{R}-1}(B))$，上限端点集合为 $\\boldsymbol{u} = (u_0(B), \\dots, u_{\\mathcal{R}-1}(B))$。均值为 $\\bar{\\ell}(B) = \\frac{1}{\\mathcal{R}}\\sum_{j=0}^{\\mathcal{R}-1} \\ell_j(B)$ 和 $\\bar{u}(B) = \\frac{1}{\\mathcal{R}}\\sum_{j=0}^{\\mathcal{R}-1} u_j(B)$。稳定性度量则为：\n$$\ns_\\ell(B) = \\sqrt{\\frac{1}{\\mathcal{R}}\\sum_{j=0}^{\\mathcal{R}-1}\\left(\\ell_j(B) - \\bar{\\ell}(B)\\right)^2}\n$$\n$$\ns_u(B) = \\sqrt{\\frac{1}{\\mathcal{R}}\\sum_{j=0}^{\\mathcal{R}-1}\\left(u_j(B) - \\bar{u}(B)\\right)^2}\n$$\n这对应于除数为 $\\mathcal{R}$（而不是 $\\mathcal{R}-1$）的标准差计算。\n\n实现样本的生成取决于指定的分布。\n- 对于高斯回报，$X_i \\sim \\mathcal{N}(\\mu, \\sigma^2)$，我们从均值为 $\\mu$、标准差为 $\\sigma$ 的正态分布中抽样。\n- 对于重尾回报，$X_i = \\mu + \\sigma \\sqrt{\\frac{\\nu - 2}{\\nu}}\\, T_{\\nu}$，其中 $T_{\\nu}$ 服从自由度为 $\\nu$ 的标准学生t分布。选择此公式是为了在 $\\nu  2$ 的条件下，使得 $\\mathrm{E}[X_i] = \\mu$ 且 $\\mathrm{Var}(X_i) = \\sigma^2$。\n\n在计算上，实现将遵循这些步骤。所有随机数生成将使用一个现代伪随机数生成器，具体为 `numpy.random.PCG64`，以确保所规定的可复现性。带线性插值的分位数计算由 `numpy.quantile` 及其默认的 `method='linear'` 参数处理。总体标准差使用 `numpy.std` 并设置 `ddof=0` 来计算。整个过程被封装在一个函数中，该函数遍历所提供的测试套件，为每个案例计算配对 $(s_\\ell(B), s_u(B))$，并根据严格要求格式化输出。",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import t\n\ndef compute_stability_for_case(dist, n, mu, sigma, nu, B, R, sample_seed, bootstrap_base_seed):\n    \"\"\"\n    Computes the stability of bootstrap confidence interval endpoints for a single test case.\n\n    Args:\n        dist (str): Distribution type ('N' for Gaussian, 'T' for Student's-t).\n        n (int): Size of the realized sample.\n        mu (float): Mean of the return distribution.\n        sigma (float): Standard deviation of the return distribution.\n        nu (int): Degrees of freedom for the Student's-t distribution.\n        B (int): Number of bootstrap replications.\n        R (int): Number of independent repetitions of the bootstrap procedure.\n        sample_seed (int): Seed for generating the realized sample.\n        bootstrap_base_seed (int): Base seed for the bootstrap procedure repetitions.\n\n    Returns:\n        list: A list containing [s_l, s_u], the stability measures for the lower and upper\n              confidence interval endpoints, rounded to 6 decimals.\n    \"\"\"\n    # Step 1: Generate the realized sample\n    rng_sample = np.random.Generator(np.random.PCG64(sample_seed))\n    \n    if dist == 'N':\n        realized_sample = rng_sample.normal(loc=mu, scale=sigma, size=n)\n    elif dist == 'T':\n        # Generate standard Student's t-distributed random variables\n        t_samples = t.rvs(df=nu, size=n, random_state=rng_sample)\n        # Scale to match mean mu and variance sigma^2\n        scaling_factor = sigma * np.sqrt((nu - 2) / nu)\n        realized_sample = mu + scaling_factor * t_samples\n    else:\n        raise ValueError(\"Invalid distribution type specified.\")\n\n    lower_endpoints = []\n    upper_endpoints = []\n\n    # Step 2: Outer loop for R independent repetitions\n    for j in range(R):\n        current_seed = bootstrap_base_seed + j\n        rng_bootstrap = np.random.Generator(np.random.PCG64(current_seed))\n\n        # Perform B bootstrap resamples efficiently\n        # Generate all indices for B resamples at once\n        bootstrap_indices = rng_bootstrap.choice(n, size=(B, n), replace=True)\n        \n        # Create bootstrap samples and compute their means\n        bootstrap_samples = realized_sample[bootstrap_indices]\n        bootstrap_means = bootstrap_samples.mean(axis=1)\n\n        # Step 2d: Calculate confidence interval endpoints\n        q_low, q_high = np.quantile(bootstrap_means, [0.025, 0.975])\n        \n        lower_endpoints.append(q_low)\n        upper_endpoints.append(q_high)\n\n    # Step 4: Calculate stability measures (population standard deviation)\n    s_l = np.std(lower_endpoints, ddof=0)\n    s_u = np.std(upper_endpoints, ddof=0)\n\n    return [round(s_l, 6), round(s_u, 6)]\n\ndef solve():\n    \"\"\"\n    Main solver function that runs all test cases and prints the final result.\n    \"\"\"\n    test_cases = [\n        # (dist, n, mu, sigma, nu, B, R, sample_seed, bootstrap_base_seed)\n        ('N', 252, 0.0005, 0.01, None, 25, 32, 20231101, 770000),\n        ('N', 252, 0.0005, 0.01, None, 200, 32, 20231101, 770100),\n        ('N', 252, 0.0005, 0.01, None, 1000, 32, 20231101, 770200),\n        ('N', 252, 0.0005, 0.01, None, 2000, 32, 20231101, 770300),\n        ('N', 30, 0.0005, 0.01, None, 200, 32, 20231111, 880100),\n        ('T', 252, 0.0005, 0.02, 3, 1000, 32, 20231221, 990100),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_stability_for_case(*case)\n        results.append(result)\n\n    # Format the final output string exactly as required, without spaces after commas.\n    formatted_results = [f\"[{res[0]},{res[1]}]\" for res in results]\n    final_output_string = f\"[{','.join(formatted_results)}]\"\n    \n    print(final_output_string)\n\nsolve()\n```"
        }
    ]
}