{
    "hands_on_practices": [
        {
            "introduction": "将一个序贯决策问题转化为贝尔曼方程的数学结构，是应用动态规划的第一步，也是最关键的一步。这个练习将帮助你掌握这项基本技能，特别是在一个有限期界模型中，如何正确地定义终点时刻的价值函数和倒数第二期的最优决策条件。通过在一个标准的生命周期储蓄模型中加入遗赠动机，你将学会如何严谨地构建贝尔曼递归关系。",
            "id": "2437277",
            "problem": "考虑一个有限期、确定性的生命周期消费-储蓄问题，时期由 $t \\in \\{0,1,\\dots,T-1\\}$ 索引。在每个时期 $t$ 开始时，代理人持有财富 $W_t \\ge 0$，选择消费 $c_t \\ge 0$，并根据以下运动定律将财富带入下一时期\n$$\nW_{t+1} \\;=\\; (1+r)\\,(W_t - c_t) \\;+\\; y_{t+1},\n$$\n其中 $r  -1$ 是一个恒定的净利率，$\\{y_t\\}_{t=1}^T$ 是一个外生的非负收入序列。偏好由下式给出\n$$\n\\sum_{t=0}^{T-1} \\beta^t\\,u(c_t) \\;+\\; \\beta^T\\,u_B(W_T),\n$$\n其中贴现因子为 $\\beta \\in (0,1)$，时期效用为 $u:\\mathbb{R}_+ \\to \\mathbb{R}$，遗赠效用为 $u_B:\\mathbb{R}_+ \\to \\mathbb{R}$。假设 $u$ 和 $u_B$ 是严格递增、严格凹且二次连续可微的，并假设在最优情况下所有相关约束都是松弛的，因此内部一阶条件适用。\n\n哪个选项正确地指定了 Bellman 递归（包括终端条件）以及在时期 $T-1$ 中得到的一阶条件？\n\nA. \n- 终端条件：$V_T(W_T) \\;=\\; u_B(W_T)$。\n- $t \\in \\{0,1,\\dots,T-1\\}$ 的递归：\n$$\nV_t(W_t) \\;=\\; \\max_{c_t \\ge 0} \\left\\{ u(c_t) \\;+\\; \\beta\\,V_{t+1}\\!\\left((1+r)\\,(W_t - c_t) + y_{t+1}\\right) \\right\\}.\n$$\n- $t=T-1$ 时的一阶条件（内部解）：$u'(c_{T-1}) \\;=\\; \\beta\\,(1+r)\\,u_B'(W_T)$。\n\nB.\n- 终端条件：$V_T(W_T) \\;=\\; \\beta\\,u_B(W_T)$。\n- $t \\in \\{0,1,\\dots,T-1\\}$ 的递归：\n$$\nV_t(W_t) \\;=\\; \\max_{c_t \\ge 0} \\left\\{ u(c_t) \\;+\\; \\beta\\,V_{t+1}\\!\\left((1+r)\\,(W_t - c_t) + y_{t+1}\\right) \\right\\}.\n$$\n- $t=T-1$ 时的一阶条件（内部解）：$u'(c_{T-1}) \\;=\\; \\beta\\,u_B'(W_T)$。\n\nC.\n- 终端条件：$V_T(W_T) \\;=\\; u(W_T)$。\n- $t \\in \\{0,1,\\dots,T-1\\}$ 的递归：\n$$\nV_t(W_t) \\;=\\; \\max_{c_t \\ge 0} \\left\\{ u(c_t) \\;+\\; \\beta\\,V_{t+1}\\!\\left((1+r)\\,(W_t - c_t) + y_{t+1}\\right) \\right\\}.\n$$\n- $t=T-1$ 时的一阶条件（内部解）：$u'(c_{T-1}) \\;=\\; \\beta\\,(1+r)\\,u'(c_T)$。\n\nD.\n- 终端条件：$V_T(W_T) \\;=\\; u_B(W_T)$。\n- $t \\in \\{0,1,\\dots,T-1\\}$ 的递归：\n$$\nV_t(W_t) \\;=\\; \\max_{c_t \\ge 0} \\left\\{ u(c_t) \\;+\\; \\beta\\,\\Big( V_{t+1}\\!\\left((1+r)\\,(W_t - c_t) + y_{t+1}\\right) \\;+\\; u_B\\!\\left((1+r)\\,(W_t - c_t) + y_{t+1}\\right) \\Big) \\right\\}.\n$$\n- $t=T-1$ 时的一阶条件（内部解）：$u'(c_{T-1}) \\;=\\; \\beta\\,(1+r)\\,\\Big(u'(c_T) \\;+\\; u_B'(W_T)\\Big)$。",
            "solution": "首先将对问题陈述进行严格验证。\n\n### 步骤1：提取已知条件\n该问题描述了一个有限期、确定性的生命周期消费-储蓄模型。\n- **时间范围**：离散时间段 $t \\in \\{0, 1, \\dots, T-1\\}$。\n- **状态变量**：时期 $t$ 开始时的财富，$W_t \\ge 0$。\n- **控制变量**：时期 $t$ 的消费，$c_t \\ge 0$。\n- **财富的运动定律**：$W_{t+1} = (1+r)(W_t - c_t) + y_{t+1}$。\n- **净利率**：$r  -1$，恒定。\n- **外生收入流**：$\\{y_t\\}_{t=1}^T$，其中 $y_t \\ge 0$。\n- **目标函数（偏好）**：$\\sum_{t=0}^{T-1} \\beta^t\\,u(c_t) + \\beta^T\\,u_B(W_T)$。\n- **贴现因子**：$\\beta \\in (0,1)$。\n- **时期效用函数**：$u:\\mathbb{R}_+ \\to \\mathbb{R}$。\n- **遗赠效用函数**：$u_B:\\mathbb{R}_+ \\to \\mathbb{R}$。\n- **关于效用函数的假设**：$u$ 和 $u_B$ 是严格递增、严格凹且二次连续可微 ($C^2$) 的。\n- **解的特征**：最优解是内部解，因此一阶条件适用。\n\n### 步骤2：使用提取的已知条件进行验证\n该问题提出了一个动态宏观经济学和计算经济学中的经典模型。\n\n- **科学依据**：该模型是确定性条件下跨期选择的标准表示。其公式，包括目标函数、运动定律和对效用的假设，是经济学理论的基石。它在科学上是完全合理的。\n- **适定性**：该问题是适定的。对效用函数的严格凹性假设，以及问题的结构，确保了对于给定的初始财富 $W_0$，存在一个唯一的、行为良好的最优消费计划。\n- **客观性**：该问题使用精确的数学语言陈述，没有任何主观或模糊的术语。\n- **检查缺陷**：\n    1.  **科学/事实不合理**：无。该模型是一个标准的理论构造。\n    2.  **非形式化/不相关**：该问题是一个直接与 Bellman 方程相关的形式化数学练习，符合要求。\n    3.  **不完整/矛盾的设置**：该问题是完整且自洽的。建立 Bellman 方程所需的所有组件都已提供。\n    4.  **不现实/不可行**：该模型是现实的简化，但并非科学上不可信或物理上不可能。条件 $r  -1$ 是标准的，确保预算约束不是病态的。\n    5.  **不适定/结构不良**：无。问题结构清晰，并导向一个唯一的解。\n    6.  **超出科学可验证性**：该问题是一个数学问题，完全可以通过动态规划的标准方法进行验证。\n\n### 步骤3：结论和行动\n问题陈述是有效的。我现在将进行推导和分析。\n\n---\n\n该问题使用动态规划原理，从最终时期 $T$ 开始向后倒推求解。设 $V_t(W_t)$ 为价值函数，表示从时期 $t$ 开始，在给定财富 $W_t$ 的情况下可获得的最大效用。价值函数的标准定义（在每个阶段对贴现因子进行归一化）是：\n$$\nV_t(W_t) \\;=\\; \\max_{\\{c_s\\}_{s=t}^{T-1}} \\left\\{ \\sum_{s=t}^{T-1} \\beta^{s-t} u(c_s) \\;+\\; \\beta^{T-t} u_B(W_T) \\right\\}\n$$\n\n**1. 终端条件的推导**\n\n在最终日期 $t=T$，不再做出消费决策。代理人剩下财富 $W_T$。剩余的效用完全来自遗赠。根据价值函数的定义，对于 $t=T$，我们有：\n$$\nV_T(W_T) \\;=\\; \\beta^{T-T} u_B(W_T) \\;=\\; u_B(W_T)\n$$\n这是 Bellman 递归的终端条件。它表明，在生命结束时拥有财富 $W_T$ 的价值就是遗赠该金额所获得的效用。\n\n**2. Bellman 递归的推导**\n\n对于任何时期 $t  T$，价值函数可以通过将决策分解为当前选择（$c_t$）和对未来的影响来递归地表示。\n$$\nV_t(W_t) \\;=\\; \\max_{c_t} \\left\\{ u(c_t) \\;+\\; \\beta \\left( \\max_{\\{c_s\\}_{s=t+1}^{T-1}} \\left\\{ \\sum_{s=t+1}^{T-1} \\beta^{s-(t+1)} u(c_s) \\;+\\; \\beta^{T-(t+1)} u_B(W_T) \\right\\} \\right) \\right\\}\n$$\n根据定义，外层括号内的表达式是下一时期的价值函数 $V_{t+1}(W_{t+1})$。因此，我们得到 Bellman 方程：\n$$\nV_t(W_t) \\;=\\; \\max_{c_t \\ge 0} \\left\\{ u(c_t) \\;+\\; \\beta\\,V_{t+1}(W_{t+1}) \\right\\}\n$$\n代入财富的运动定律 $W_{t+1} = (1+r)(W_t - c_t) + y_{t+1}$，我们得到 $t \\in \\{0, 1, \\dots, T-1\\}$ 的完整递归：\n$$\nV_t(W_t) \\;=\\; \\max_{c_t \\ge 0} \\left\\{ u(c_t) \\;+\\; \\beta\\,V_{t+1}\\!\\left((1+r)\\,(W_t - c_t) + y_{t+1}\\right) \\right\\}\n$$\n\n**3. 时期 $t=T-1$ 一阶条件的推导**\n\n我们现在将 Bellman 方程具体化到最后一个决策时期 $t=T-1$。\n$$\nV_{T-1}(W_{T-1}) \\;=\\; \\max_{c_{T-1} \\ge 0} \\left\\{ u(c_{T-1}) \\;+\\; \\beta\\,V_T(W_T) \\right\\}\n$$\n使用终端条件 $V_T(W_T) = u_B(W_T)$，这变为：\n$$\nV_{T-1}(W_{T-1}) \\;=\\; \\max_{c_{T-1} \\ge 0} \\left\\{ u(c_{T-1}) \\;+\\; \\beta\\,u_B(W_T) \\right\\}\n$$\n接下来，我们代入连接 $W_T$ 和选择 $c_{T-1}$ 的运动定律：$W_T = (1+r)(W_{T-1} - c_{T-1}) + y_T$。\n$$\nV_{T-1}(W_{T-1}) \\;=\\; \\max_{c_{T-1} \\ge 0} \\left\\{ u(c_{T-1}) \\;+\\; \\beta\\,u_B\\!\\left((1+r)\\,(W_{T-1} - c_{T-1}) + y_T\\right) \\right\\}\n$$\n为了找到最优消费 $c_{T-1}$，我们将最大化运算符内的表达式对 $c_{T-1}$ 求导并设为零，因为假设存在内部解。\n$$\n\\frac{\\partial}{\\partial c_{T-1}} \\left[ u(c_{T-1}) \\;+\\; \\beta\\,u_B\\!\\left((1+r)\\,(W_{T-1} - c_{T-1}) + y_T\\right) \\right] \\;=\\; 0\n$$\n应用链式法则：\n$$\nu'(c_{T-1}) \\;+\\; \\beta\\,u_B'(W_T) \\cdot \\frac{\\partial W_T}{\\partial c_{T-1}} \\;=\\; 0\n$$\n$W_T$ 对 $c_{T-1}$ 的导数是：\n$$\n\\frac{\\partial W_T}{\\partial c_{T-1}} \\;=\\; \\frac{\\partial}{\\partial c_{T-1}} \\left[ (1+r)(W_{T-1} - c_{T-1}) + y_T \\right] \\;=\\; -(1+r)\n$$\n将此代入一阶条件：\n$$\nu'(c_{T-1}) \\;+\\; \\beta\\,u_B'(W_T) \\cdot (-(1+r)) \\;=\\; 0\n$$\n重新整理各项，得到时期 $T-1$ 的最终一阶条件：\n$$\nu'(c_{T-1}) \\;=\\; \\beta\\,(1+r)\\,u_B'(W_T)\n$$\n这是最后一个时期的欧拉方程。它将今天消费一单位财富的边际效用与储蓄该单位、让其以利率 $r$ 增长、并在时间 $T$ 遗赠的贴现边际效用相等同。\n\n**选项评估**\n\n- **选项 A**：\n    - 终端条件：$V_T(W_T) = u_B(W_T)$。这是正确的。\n    - 递归：$V_t(W_t) = \\max_{c_t \\ge 0} \\left\\{ u(c_t) + \\beta\\,V_{t+1}\\!\\left((1+r)\\,(W_t - c_t) + y_{t+1}\\right) \\right\\}$。这是正确的。\n    - $t=T-1$ 时的一阶条件：$u'(c_{T-1}) = \\beta\\,(1+r)\\,u_B'(W_T)$。这是正确的。\n    - 结论：**正确**。所有三个部分都推导正确。\n\n- **选项 B**：\n    - 终端条件：$V_T(W_T) = \\beta\\,u_B(W_T)$。这是不正确的。时间 $t$ 的价值函数通常定义为从时间 $t$ 开始的效用现值，贴现到时间 $t$。$\\beta$ 因子不是终端价值的一部分。\n    - 递归：递归公式陈述正确。\n    - 一阶条件：$u'(c_{T-1}) = \\beta\\,u_B'(W_T)$。这是不正确的。它缺少了代表储蓄总回报的因子 $(1+r)$。这个条件只有在 $r=0$ 时才成立。\n    - 结论：**不正确**。\n\n- **选项 C**：\n    - 终端条件：$V_T(W_T) = u(W_T)$。这是不正确的。终端日期的效用由遗赠效用函数 $u_B$ 给出，而不是时期消费效用函数 $u$。\n    - 递归：递归公式陈述正确。\n    - 一阶条件：$u'(c_{T-1}) = \\beta\\,(1+r)\\,u'(c_T)$。这是根本上不正确的。在时期 $T$ 没有消费选择 $c_T$。时间 $T$ 的效用取决于财富存量 $W_T$，而不是消费流量。这个方程似乎将有限期模型与无限期欧拉方程混淆了。\n    - 结论：**不正确**。\n\n- **选项 D**：\n    - 终端条件：$V_T(W_T) = u_B(W_T)$。这是正确的。\n    - 递归：递归被陈述为 $V_t(W_t) = \\max_{c_t \\ge 0} \\{ u(c_t) + \\beta\\,\\Big( V_{t+1}(\\dots) + u_B(\\dots) \\Big) \\}$。这是不正确的。它错误地在每个时期的递归中都加入了遗赠效用。遗赠动机只适用于一次，即终端财富 $W_T$。这个公式是对动态规划原理的严重误述。\n    - 一阶条件：$u'(c_{T-1}) = \\beta\\,(1+r)\\,\\Big(u'(c_T) + u_B'(W_T)\\Big)$。这是不正确的，既有包含不存在的 $c_T$ 的错误，又是从一个无效的递归结构中推导出来的。\n    - 结论：**不正确**。\n\n基于从第一性原理的严格推导，选项 A 是唯一正确陈述了终端条件、Bellman 递归和时期 $T-1$ 一阶条件的选项。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "虽然许多动态规划问题需要计算机求解，但一些重要的模型存在解析解，能够为我们提供深刻的经济学洞见。本练习探讨了一个经典的无限期界模型，我们将通过“猜解和验证”的方法，即假设价值函数具有特定的函数形式，来推导出其闭式解。这种方法是经济学研究中一个强有力的分析工具。",
            "id": "2437253",
            "problem": "考虑一个具有恒定相对风险厌恶 (CRRA) 偏好的单一代理人面临的无限期消费储蓄问题。代理人的时期效用为 $u(c) = \\frac{c^{1-\\sigma}}{1-\\sigma}$，参数为 $\\sigma \\in (0,1)$，贴现因子为 $\\beta \\in (0,1)$。财富 $\\{W_t\\}_{t \\geq 0}$ 根据预算转移方程演变\n$$\nW_{t+1} \\;=\\; R_{t+1}\\,\\bigl(W_t - c_t\\bigr),\n$$\n其中，总投资回报 $\\{R_t\\}_{t \\geq 1}$ 是随时间独立同分布 (IID) 的，以概率 $p \\in (0,1)$ 取值为 $r_L0$，以概率 $1-p$ 取值为 $r_H0$。代理人面临借贷约束 $c_t \\in [0, W_t]$。如果 $W_t \\leq 0$，则发生破产，该状态为吸收态，对于所有 $s \\geq 1$ 都有 $W_{t+s}=0$，且在 $c_t=0$ 时的时期效用等于 $u(0)=0$。\n\n令 $V(W)$ 表示解贝尔曼方程\n$$\nV(W) \\;=\\; \\max_{c \\in [0,W]} \\Bigl\\{ u(c) \\;+\\; \\beta \\,\\mathbb{E}\\bigl[\\,V\\bigl(R\\,(W-c)\\bigr)\\,\\bigr] \\Bigr\\},\n$$\n的值函数，边界条件为 $V(0)=0$，其中期望是针对 $R \\in \\{r_L, r_H\\}$ 计算的。\n\n假设参数满足有限性条件\n$$\n\\Bigl(\\beta \\,\\bigl[p\\,r_L^{\\,1-\\sigma} + (1-p)\\,r_H^{\\,1-\\sigma}\\bigr]\\Bigr)^{\\frac{1}{\\sigma}}  1.\n$$\n\n定义在吸收态附近的前导阶系数\n$$\n\\Lambda(\\beta,\\sigma,p,r_L,r_H) \\;\\equiv\\; \\lim_{W \\to 0^+} \\frac{V(W)}{W^{\\,1-\\sigma}}.\n$$\n\n仅使用贝尔曼方程和模型的原素，确定 $\\Lambda(\\beta,\\sigma,p,r_L,r_H)$ 的精确闭式表达式。您的最终答案必须是仅含 $\\beta$、$\\sigma$、$p$、$r_L$ 和 $r_H$ 的单一解析表达式。",
            "solution": "问题陈述需经过验证。\n\n**步骤1：提取给定条件**\n- 效用函数：$u(c) = \\frac{c^{1-\\sigma}}{1-\\sigma}$，其中 $\\sigma \\in (0,1)$。\n- 贴现因子：$\\beta \\in (0,1)$。\n- 预算转移方程：$W_{t+1} = R_{t+1}(W_t - c_t)$。\n- 投资回报 $R$：独立同分布，以概率 $p \\in (0,1)$ 取值为 $r_L  0$，以概率 $1-p$ 取值为 $r_H  0$。\n- 约束：$c_t \\in [0, W_t]$。\n- 边界/吸收态：$V(0)=0$。\n- 贝尔曼方程：$V(W) = \\max_{c \\in [0,W]} \\left\\{ u(c) + \\beta \\mathbb{E}[V(R(W-c))] \\right\\}$。\n- 有限性条件：$(\\beta [p r_L^{1-\\sigma} + (1-p) r_H^{1-\\sigma}])^{\\frac{1}{\\sigma}}  1$。\n- 目标：求 $\\Lambda \\equiv \\lim_{W \\to 0^+} \\frac{V(W)}{W^{\\,1-\\sigma}}$ 的闭式表达式。\n\n**步骤2：使用提取的给定条件进行验证**\n该问题是量化经济学中一个经典的无限期动态规划问题。所有组成部分都是标准的且经过严格定义。\n- **科学依据**：该模型是现代宏观经济学（消费储蓄问题）的基石。CRRA 效用函数是一个标准假设。贝尔曼方程是解决此类问题的基本工具。该设定在数学上和经济学上都是合理的。\n- **适定性**：该问题是适定的。所提供的有限性条件正是确保存在非平凡、有限值函数的必要条件。约束条件明确。目标是找到一个定义明确的数学极限。\n- **目标**：问题使用精确的数学语言陈述，没有任何主观性。\n\n**步骤3：结论与行动**\n该问题是有效的。它是一个定义明确、自洽的数学问题，其基础是成熟的经济理论。将提供完整的解答。\n\n问题在于确定系数 $\\Lambda$，该系数描述了当财富 $W$ 趋近于零处的吸收态时，值函数 $V(W)$ 的前导阶行为。鉴于 CRRA 效用函数和财富冲击的乘法性质，这类模型允许一个值函数为 $1-\\sigma$ 次齐次的解。因此，我们猜想一个形式为：\n$$\nV(W) = A W^{1-\\sigma}\n$$\n的解，其中 $A  0$ 为某个常数系数。在此猜想下，待求的量正是这个系数：\n$$\n\\Lambda = \\lim_{W \\to 0^+} \\frac{V(W)}{W^{\\,1-\\sigma}} = \\lim_{W \\to 0^+} \\frac{A W^{1-\\sigma}}{W^{\\,1-\\sigma}} = A\n$$\n相关的最优策略函数是财富的线性函数：$c(W) = \\lambda W$，其中 $\\lambda \\in (0,1)$ 是某个恒定的消费-财富比。任务简化为找到常数 $A$。这将通过两个逻辑步骤完成：首先，我们确定最优策略参数 $\\lambda$，然后，我们用它来找到值函数系数 $A$。\n\n为简洁起见，我们定义恒定预期回报因子：\n$$\n\\mathcal{R} \\equiv \\mathbb{E}[R^{1-\\sigma}] = p r_L^{1-\\sigma} + (1-p) r_H^{1-\\sigma}\n$$\n贝尔曼方程可以写成：\n$$\nV(W) = \\max_{c \\in [0,W]} \\left\\{ \\frac{c^{1-\\sigma}}{1-\\sigma} + \\beta \\mathbb{E}[V(R(W-c))] \\right\\}\n$$\n代入猜想的形式 $V(W) = A W^{1-\\sigma}$：\n$$\nA W^{1-\\sigma} = \\max_{c \\in [0,W]} \\left\\{ \\frac{c^{1-\\sigma}}{1-\\sigma} + \\beta \\mathbb{E}[A (R(W-c))^{1-\\sigma}] \\right\\} = \\max_{c \\in [0,W]} \\left\\{ \\frac{c^{1-\\sigma}}{1-\\sigma} + \\beta A (W-c)^{1-\\sigma} \\mathcal{R} \\right\\}\n$$\n\n**步骤1：确定最优策略参数 $\\lambda$。**\n我们对贝尔曼方程应用包络定理。将值函数对状态变量 $W$ 求导得出：\n$$\nV'(W) = \\frac{\\partial}{\\partial W} \\left( \\frac{c^{1-\\sigma}}{1-\\sigma} + \\beta \\mathbb{E}[V(R(W-c))] \\right) \\Biggr|_{c=c(W)}\n$$\n该定理指出，在对 $W$ 求导时，我们可以忽略 $W$ 对最优选择 $c(W)$ 的影响，因此我们将 $c$ 视为固定的：\n$$\nV'(W) = \\beta \\mathbb{E}[V'(R(W-c(W))) \\cdot R]\n$$\n现在，我们代入猜想的形式 $V(W) = A W^{1-\\sigma}$，这意味着 $V'(W) = A(1-\\sigma)W^{-\\sigma}$。最优策略是 $c(W)=\\lambda W$。\n$$\nA(1-\\sigma)W^{-\\sigma} = \\beta \\mathbb{E}\\left[ A(1-\\sigma)(R(W - \\lambda W))^{-\\sigma} \\cdot R \\right]\n$$\n从两边消去项 $A(1-\\sigma)$（因为 $A0$ 且 $\\sigma \\neq 1$）：\n$$\nW^{-\\sigma} = \\beta \\mathbb{E}\\left[ (R(1-\\lambda)W)^{-\\sigma} R \\right] = \\beta (1-\\lambda)^{-\\sigma} W^{-\\sigma} \\mathbb{E}[R^{-\\sigma} R]\n$$\n$$\nW^{-\\sigma} = \\beta (1-\\lambda)^{-\\sigma} W^{-\\sigma} \\mathbb{E}[R^{1-\\sigma}]\n$$\n消去 $W^{-\\sigma}$（对于 $W0$）并使用 $\\mathcal{R}$ 的定义：\n$$\n1 = \\beta (1-\\lambda)^{-\\sigma} \\mathcal{R}\n$$\n我们现在可以求解最优消费-财富比 $\\lambda$：\n$$\n(1-\\lambda)^{\\sigma} = \\beta \\mathcal{R}\n$$\n$$\n1-\\lambda = (\\beta \\mathcal{R})^{\\frac{1}{\\sigma}}\n$$\n$$\n\\lambda = 1 - (\\beta \\mathcal{R})^{\\frac{1}{\\sigma}} = 1 - \\left( \\beta \\left[ p r_L^{1-\\sigma} + (1-p) r_H^{1-\\sigma} \\right] \\right)^{\\frac{1}{\\sigma}}\n$$\n问题的有限性条件确保了 $(\\beta \\mathcal{R})^{\\frac{1}{\\sigma}}  1$，这保证了 $\\lambda \\in (0,1)$，与非平凡的内部解一致。\n\n**步骤2：确定值函数系数 $A$。**\n在找到最优策略参数 $\\lambda$ 后，我们将策略 $c = \\lambda W$ 代回贝尔曼方程。由于该策略是最优的，不再需要 'max' 算子。\n$$\nA W^{1-\\sigma} = \\frac{(\\lambda W)^{1-\\sigma}}{1-\\sigma} + \\beta \\mathbb{E}[A (R(W-\\lambda W))^{1-\\sigma}]\n$$\n提出公因式：\n$$\nA W^{1-\\sigma} = \\frac{\\lambda^{1-\\sigma} W^{1-\\sigma}}{1-\\sigma} + \\beta A (1-\\lambda)^{1-\\sigma} W^{1-\\sigma} \\mathbb{E}[R^{1-\\sigma}]\n$$\n整个方程除以 $W^{1-\\sigma}$（对于 $W0$）并使用 $\\mathcal{R}$ 的定义：\n$$\nA = \\frac{\\lambda^{1-\\sigma}}{1-\\sigma} + \\beta A (1-\\lambda)^{1-\\sigma} \\mathcal{R}\n$$\n我们求解 $A$：\n$$\nA \\left( 1 - \\beta (1-\\lambda)^{1-\\sigma} \\mathcal{R} \\right) = \\frac{\\lambda^{1-\\sigma}}{1-\\sigma}\n$$\n从步骤1，我们有恒等式 $(1-\\lambda)^{\\sigma} = \\beta \\mathcal{R}$。我们用它来简化括号中的项：\n$$\n1 - \\beta (1-\\lambda)^{1-\\sigma} \\mathcal{R} = 1 - (1-\\lambda)^{1-\\sigma} (\\beta \\mathcal{R}) = 1 - (1-\\lambda)^{1-\\sigma} (1-\\lambda)^{\\sigma} = 1 - (1-\\lambda)^{1-\\sigma+\\sigma} = 1 - (1-\\lambda) = \\lambda\n$$\n将此简化结果代回关于 $A$ 的方程中：\n$$\nA \\cdot \\lambda = \\frac{\\lambda^{1-\\sigma}}{1-\\sigma}\n$$\n因为 $\\lambda  0$，我们可以除以 $\\lambda$：\n$$\nA = \\frac{\\lambda^{-\\sigma}}{1-\\sigma}\n$$\n最后，我们将步骤1中 $\\lambda$ 的表达式代入此方程以求得 $A=\\Lambda$：\n$$\n\\Lambda = \\frac{1}{1-\\sigma} \\left[ 1 - (\\beta \\mathcal{R})^{\\frac{1}{\\sigma}} \\right]^{-\\sigma}\n$$\n代入 $\\mathcal{R}$ 的定义，得到以模型原素表示的最终表达式：\n$$\n\\Lambda(\\beta,\\sigma,p,r_L,r_H) = \\frac{1}{1-\\sigma} \\left[ 1 - \\left( \\beta \\left( p r_L^{1-\\sigma} + (1-p) r_H^{1-\\sigma} \\right) \\right)^{\\frac{1}{\\sigma}} \\right]^{-\\sigma}\n$$\n这个表达式是所求系数的精确闭式解。",
            "answer": "$$\n\\boxed{\\frac{1}{1-\\sigma} \\left[ 1 - \\left(\\beta \\left(p r_L^{1-\\sigma} + (1-p) r_H^{1-\\sigma}\\right)\\right)^{\\frac{1}{\\sigma}} \\right]^{-\\sigma}}\n$$"
        },
        {
            "introduction": "现实世界中大多数有趣的动态规划问题都缺乏解析解，这使得数值方法变得至关重要。本练习将指导你实现价值函数迭代（Value Function Iteration, VFI），这是求解贝尔曼方程的基石算法。你不仅需要将贝尔曼算子转化为可执行的代码，还将通过经验证据来验证该算法的理论收敛速度，从而将理论与计算实践紧密联系起来。",
            "id": "2437296",
            "problem": "考虑一个具有单一资产状态的确定性消费-储蓄问题。偏好由恒定相对风险厌恶 (CRRA) 效用函数给出，其风险厌恶参数为 $\\sigma  0$，每期效用为 $u(c) = \\frac{c^{1-\\sigma}}{1-\\sigma}$ (当 $\\sigma \\neq 1$ 时)。代理人每期获得外生收入 $y$，其资产持有量 $a$ 进行确定性演化，面临资产的总回报率为 $1+r$，且不能借贷。状态变量是资产 $a$，控制变量是下一期的资产 $a'$。单期预算约束为 $c = (1+r)a + y - a'$，同时有非负约束 $c \\ge 0$ 和借贷约束 $a' \\ge 0$。\n\n在 $[0, A_{\\max}]$ 上定义一个包含 $N$ 个均匀间隔资产点的有限网格 $\\mathcal{A}_N = \\{a_0, a_1, \\dots, a_{N-1}\\}$。动态规划问题是计算求解贝尔曼方程的价值函数 $V(a)$\n$$\nV(a) = \\max_{a' \\in \\mathcal{A}_N} \\left\\{ u\\big((1+r)a + y - a'\\big) + \\beta V(a') \\right\\},\n$$\n需满足约束 $c = (1+r)a + y - a' \\ge 0$ 和 $a' \\ge 0$，其中 $\\beta \\in (0,1)$ 是贴现因子。令 $\\mathcal{T}$ 表示贝尔曼算子，其定义为在网格上将一个函数 $V$ 映射到一个新函数 $\\mathcal{T}V$ 的右侧映射。\n\n任务：\n- 从贝尔曼算子 $\\mathcal{T}$ 的基本定义以及有界连续效用和紧凑状态-行动集下的动态规划原理出发，通过对初始猜测 $V_0(a) = 0$ (在 $\\mathcal{A}_N$ 上) 重复应用 $\\mathcal{T}$ 来执行价值函数迭代，直至在上确界范数下收敛。对于每次迭代 $k$，计算误差 $\\epsilon_k = \\lVert V_{k+1} - V_k \\rVert_\\infty = \\max_i \\left| V_{k+1}(a_i) - V_k(a_i) \\right|$。\n- 使用上确界范数为 $\\text{tol} = 10^{-4}$ 的收敛容差和 $1000$ 次的最大迭代次数。记录每种网格规模下收敛所需的总迭代次数。\n- 通过连续误差之比 $\\rho_k = \\epsilon_{k+1} / \\epsilon_k$ 计算经验收敛率估计。将观测到的收敛率报告为终止前最后 $M$ 个可用比率的中位数，其中 $M = 10$（如果可用比率少于 $M$ 个则使用所有可用比率）。将此观测率四舍五入到三位小数。\n- 使用参数值 $\\beta = 0.90$、$r = 0.03$、$y = 1.0$、$\\sigma = 2.0$ 和 $A_{\\max} = 5.0$。对于不可行的消费 $c \\le 0$，将 $u(c)$ 视为一个非常大的负值，以在最大化过程中强制可行性。\n\n测试套件：\n- 为以下资产网格规模 $N \\in \\{5, 20, 80, 160\\}$ 评估程序。\n\n要求的最终输出：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。列表中的每个元素对应一个网格规模 $N$，并且本身必须是 $[N, \\text{iterations}, \\text{observed_rate}]$ 形式的列表，其中 $\\text{iterations}$ 是收敛所需的整数迭代次数，$\\text{observed_rate}$ 是四舍五入到三位小数的浮点数。例如，包含两个测试用例的输出将类似于 $[[N_1, I_1, R_1],[N_2, I_2, R_2]]$。\n\n科学真实性和推导依据：\n- 从核心定义出发：贝尔曼算子 $\\mathcal{T}$、上确界范数 $\\lVert \\cdot \\rVert_\\infty$ 以及贴现下的压缩映射原理。不要假设 $V(a)$ 有任何闭式解，也不要使用任何加速方法；严格使用价值函数迭代，并对 $a' \\in \\mathcal{A}_N$ 进行全网格搜索。",
            "solution": "该问题要求使用价值函数迭代法对一个确定性消费-储蓄模型进行数值求解。解决方案必须源于动态规划的基本原理。\n\n**1. 理论基础：贝尔曼方程与压缩映射**\n\n代理人的问题可以递归地表述。价值函数 $V(a)$ 代表代理人从资产水平 $a$ 开始可以实现的最大生命周期效用。它必须满足贝尔曼方程，该方程定义了一个函数不动点问题：\n$$\nV(a) = \\max_{a' \\in [0, (1+r)a+y]} \\left\\{ u\\big((1+r)a + y - a'\\big) + \\beta V(a') \\right\\}\n$$\n这里，$u(c)$ 是每期效用函数，$c$ 是消费，$a$ 是当前资产水平（状态），$a'$ 是下一期资产水平（控制），$r$ 是利率，$y$ 是收入，$\\beta \\in (0,1)$ 是贴现因子。最大化受制于预算约束 $c = (1+r)a + y - a'$ 以及非负约束 $c \\ge 0$ 和 $a' \\ge 0$。\n\n这个方程可以用贝尔曼算子 $\\mathcal{T}$ 来表示，它将一个候选价值函数 $W$ 映射到一个新的函数 $\\mathcal{T}W$：\n$$\n(\\mathcal{T}W)(a) = \\max_{a'} \\left\\{ u(c) + \\beta W(a') \\right\\}\n$$\n真实的价值函数 $V$ 是该算子的唯一不动点，即 $V = \\mathcal{T}V$。该不动点的存在性和唯一性，以及迭代方法对其的收敛性，都由压缩映射定理保证。对于一个配备了上确界范数 $\\lVert f \\rVert_\\infty = \\sup_x |f(x)|$ 的有界函数组成的完备度量空间，如果存在一个常数 $\\gamma \\in [0,1)$，使得对于空间中的任意两个函数 $f_1, f_2$，都有 $\\lVert \\mathcal{T}f_1 - \\mathcal{T}f_2 \\rVert_\\infty \\le \\gamma \\lVert f_1 - f_2 \\rVert_\\infty$，那么算子 $\\mathcal{T}$ 就是一个压缩映射。由于贴现的存在，贝尔曼算子 $\\mathcal{T}$ 是一个模为 $\\beta$ 的压缩映射。\n\n此性质保证了对于任何有界的初始猜测 $V_0$，由价值函数迭代 $V_{k+1} = \\mathcal{T}V_k$ 生成的序列将收敛到唯一解 $V$。收敛速度是几何级的，与不动点的距离在每一步至少减少一个因子 $\\beta$。这意味着连续迭代之间的距离也会缩小：$\\lVert V_{k+1} - V_k \\rVert_\\infty \\le \\beta \\lVert V_k - V_{k-1} \\rVert_\\infty$。\n\n**2. 离散化与算法实现**\n\n为了对问题进行计算求解，我们必须将连续的状态空间离散化。资产持有量 $a$ 被限制在一个包含 $N$ 个点的有限网格上，$\\mathcal{A}_N = \\{a_0, a_1, \\ldots, a_{N-1}\\}$，这些点在 $[0, A_{\\max}]$ 上均匀分布。因此，价值函数由一个长度为 $N$ 的向量 $\\mathbf{V}$ 表示，其中 $\\mathbf{V}[i] = V(a_i)$。\n\n价值函数迭代算法如下：\n- **步骤1：初始化。** 从价值函数向量的初始猜测开始，通常为 $\\mathbf{V}_0 = \\mathbf{0}$。设置迭代计数器 $k=0$ 和收敛容差 $\\text{tol}$。指定的参数为 $\\beta=0.90$、$r=0.03$、$y=1.0$、$\\sigma=2.0$、$A_{\\max}=5.0$ 和 $\\text{tol}=10^{-4}$。当 $\\sigma=2.0$ 时，效用函数为 $u(c) = \\frac{c^{1-\\sigma}}{1-\\sigma} = -c^{-1}$。\n- **步骤2：迭代。** 应用贝尔曼算子来更新价值函数。对于网格中的每个点 $a_i \\in \\mathcal{A}_N$，求解最大化问题：\n$$\n\\mathbf{V}_{k+1}[i] = \\max_{j \\in \\{0, \\ldots, N-1\\}} \\left\\{ u\\big((1+r)a_i + y - a_j\\big) + \\beta \\mathbf{V}_k[j] \\right\\}\n$$\n$a'$ 的选择集也被限制在网格 $\\mathcal{A}_N$ 中。导致非正消费 ($c_{ij} = (1+r)a_i+y-a_j \\le 0$) 的选择 $a_j$ 是不可行的。按照规定，通过为此类选择分配一个非常大的负效用值来处理这种情况，从而在最大化过程中有效地排除它们。\n- **步骤3：收敛性检查。** 在每次完整更新价值函数向量后，计算上确界范数误差：\n$$\n\\epsilon_k = \\lVert \\mathbf{V}_{k+1} - \\mathbf{V}_k \\rVert_\\infty = \\max_{i \\in \\{0, \\ldots, N-1\\}} |\\mathbf{V}_{k+1}[i] - \\mathbf{V}_k[i]|\n$$\n循环继续，直到 $\\epsilon_k  \\text{tol}$ 或达到最大迭代次数。\n\n**3. 高效的向量化计算**\n\n使用嵌套循环的朴素实现计算成本高昂，每次迭代的复杂度为 $\\mathcal{O}(N^2)$。一种更优的方法是使用向量化。令 $\\mathbf{a}$ 为资产网格点的 $N \\times 1$ 列向量。每种状态下的手头现金是向量 $\\mathbf{z} = (1+r)\\mathbf{a} + y$。我们可以构建一个 $N \\times N$ 的潜在消费值矩阵 $\\mathbf{C}$，其中 $\\mathbf{C}_{ij} = z_i - a_j$。这可以通过广播计算得出，即 $\\mathbf{C} = \\mathbf{z} - \\mathbf{a}^T$。\n\n然后形成一个对应的 $N \\times N$ 效用矩阵 $\\mathbf{U}$：\n$$\n\\mathbf{U}_{ij} =\n\\begin{cases}\n- (\\mathbf{C}_{ij})^{-1}  \\text{if } \\mathbf{C}_{ij}  0 \\\\\n-\\infty  \\text{if } \\mathbf{C}_{ij} \\le 0\n\\end{cases}\n$$\n然后，所有状态的价值函数更新可以在一个高效的操作中完成：\n$$\n\\mathbf{V}_{k+1} = \\max_{\\text{axis}=1}(\\mathbf{U} + \\beta \\mathbf{V}_k^T)\n$$\n其中 `axis=1` 表示对列（即选择变量 $a'$ 的索引 $j$）进行最大化，而 $\\mathbf{V}_k^T$ 则广播到 $\\mathbf{U}$ 的各行。\n\n**4. 经验收敛率**\n\n迭代的理论收敛率是 $\\beta$。我们可以根据误差序列 $\\{\\epsilon_k\\}$ 对其进行经验估计。连续误差之比 $\\rho_k = \\epsilon_{k+1} / \\epsilon_k$ 应收敛于 $\\beta$。为获得稳定的估计，我们计算算法终止前可用的最后 $M=10$ 个此类比率的中位数。这提供了 `observed_rate`。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef vfi_solver(N, beta, sigma, y, r, A_max, tol, max_iter, M):\n    \"\"\"\n    Solves the deterministic consumption-savings problem using Value Function Iteration.\n\n    Args:\n        N (int): Number of points in the asset grid.\n        beta (float): Discount factor.\n        sigma (float): Coefficient of relative risk aversion.\n        y (float): Exogenous income.\n        r (float): Net interest rate.\n        A_max (float): Maximum asset level.\n        tol (float): Convergence tolerance for the supremum norm.\n        max_iter (int): Maximum number of iterations.\n        M (int): Number of recent error ratios to use for rate calculation.\n\n    Returns:\n        list: A list containing [N, number_of_iterations, observed_rate].\n    \"\"\"\n    # 1. Discretize the state space\n    a_grid = np.linspace(0, A_max, N)\n\n    # 2. Initialize value function and error list\n    V = np.zeros(N)\n    errors = []\n\n    # 3. Vectorized setup for efficient computation\n    # Reshape grids for broadcasting\n    a_grid_col = a_grid.reshape(N, 1)  # Current assets 'a'\n    a_grid_row = a_grid.reshape(1, N)  # Next period assets 'a''\n\n    # Calculate cash-on-hand for each current asset level\n    cash_on_hand = (1 + r) * a_grid_col + y\n\n    # Calculate consumption for all (a, a') pairs\n    consumption = cash_on_hand - a_grid_row\n    \n    # Define the utility function\n    # Note: As per problem, sigma is not 1.\n    def u(c):\n        return (c**(1 - sigma)) / (1 - sigma)\n\n    # Pre-calculate utility matrix.\n    # Set utility of non-positive consumption to a very large negative number\n    # to enforce feasibility during maximization.\n    utility = np.full((N, N), -np.inf)\n    positive_c_mask = consumption > 0\n    utility[positive_c_mask] = u(consumption[positive_c_mask])\n    \n    # 4. Value Function Iteration loop\n    num_iterations = 0\n    for k in range(max_iter):\n        # Apply the Bellman operator in a vectorized fashion\n        # V is (N,), broadcasting makes it equivalent to V.reshape(1, N)\n        # So (utility + beta * V) is an (N, N) matrix.\n        next_V = np.max(utility + beta * V, axis=1)\n        \n        # Calculate supremum norm error\n        error = np.max(np.abs(next_V - V))\n        errors.append(error)\n        \n        # Update value function\n        V = next_V\n        num_iterations = k + 1\n        \n        # Check for convergence\n        if error  tol:\n            break\n\n    # 5. Calculate the empirical convergence rate\n    observed_rate = np.nan\n    if len(errors) > 1:\n        # Ratios are epsilon_{k+1} / epsilon_k\n        ratios = np.array(errors[1:]) / np.array(errors[:-1])\n        \n        # Take the median of the last M ratios (or fewer if not enough exist)\n        num_ratios_to_consider = min(M, len(ratios))\n        if num_ratios_to_consider > 0:\n            last_ratios = ratios[-num_ratios_to_consider:]\n            observed_rate = float(np.median(last_ratios))\n\n    # Round the rate to three decimal places\n    if not np.isnan(observed_rate):\n        observed_rate = round(observed_rate, 3)\n\n    return [N, num_iterations, observed_rate]\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the parameters from the problem statement.\n    params = {\n        'beta': 0.90,\n        'sigma': 2.0,\n        'y': 1.0,\n        'r': 0.03,\n        'A_max': 5.0,\n        'tol': 1e-4,\n        'max_iter': 1000,\n        'M': 10\n    }\n    \n    # Define the test cases from the problem statement.\n    test_cases = [5, 20, 80, 160]\n\n    results = []\n    for N in test_cases:\n        # Run the solver for one grid size\n        result = vfi_solver(N=N, **params)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # e.g., [[N1,I1,R1],[N2,I2,R2]]\n    # Using str().replace() is a reliable way to get this format without spaces.\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```"
        }
    ]
}