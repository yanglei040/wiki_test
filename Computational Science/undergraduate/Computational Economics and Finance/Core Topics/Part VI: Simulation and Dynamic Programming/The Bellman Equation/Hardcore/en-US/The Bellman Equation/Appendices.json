{
    "hands_on_practices": [
        {
            "introduction": "Before solving complex dynamic programming problems, it is essential to master the art of correctly formulating them. This exercise  focuses on this foundational skill by asking you to construct the Bellman equation for a standard life-cycle consumption model that includes a bequest motive. Properly defining the value function, the recursive relationship, and the terminal condition is the crucial first step toward finding an optimal policy.",
            "id": "2437277",
            "problem": "Consider a finite-horizon, deterministic life-cycle consumption-savings problem with periods indexed by $t \\in \\{0,1,\\dots,T-1\\}$. At the beginning of each period $t$, the agent holds wealth $W_t \\ge 0$, chooses consumption $c_t \\ge 0$, and carries wealth into the next period according to the law of motion\n$$\nW_{t+1} \\;=\\; (1+r)\\,(W_t - c_t) \\;+\\; y_{t+1},\n$$\nwhere $r > -1$ is a constant net interest rate and $\\{y_t\\}_{t=1}^T$ is an exogenous sequence of nonnegative incomes. Preferences are given by\n$$\n\\sum_{t=0}^{T-1} \\beta^t\\,u(c_t) \\;+\\; \\beta^T\\,u_B(W_T),\n$$\nwith discount factor $\\beta \\in (0,1)$, period utility $u:\\mathbb{R}_+ \\to \\mathbb{R}$, and bequest utility $u_B:\\mathbb{R}_+ \\to \\mathbb{R}$. Assume $u$ and $u_B$ are strictly increasing, strictly concave, and twice continuously differentiable, and assume that at the optimum all relevant constraints are slack so that interior first-order conditions apply.\n\nWhich option correctly specifies the Bellman recursion (including the terminal condition) and the resulting first-order condition in period $T-1$?\n\nA. \n- Terminal condition: $V_T(W_T) \\;=\\; u_B(W_T)$.\n- Recursion for $t \\in \\{0,1,\\dots,T-1\\}$:\n$$\nV_t(W_t) \\;=\\; \\max_{c_t \\ge 0} \\left\\{ u(c_t) \\;+\\; \\beta\\,V_{t+1}\\!\\left((1+r)\\,(W_t - c_t) + y_{t+1}\\right) \\right\\}.\n$$\n- First-order condition in $t=T-1$ (interior): $u'(c_{T-1}) \\;=\\; \\beta\\,(1+r)\\,u_B'(W_T)$.\n\nB.\n- Terminal condition: $V_T(W_T) \\;=\\; \\beta\\,u_B(W_T)$.\n- Recursion for $t \\in \\{0,1,\\dots,T-1\\}$:\n$$\nV_t(W_t) \\;=\\; \\max_{c_t \\ge 0} \\left\\{ u(c_t) \\;+\\; \\beta\\,V_{t+1}\\!\\left((1+r)\\,(W_t - c_t) + y_{t+1}\\right) \\right\\}.\n$$\n- First-order condition in $t=T-1$ (interior): $u'(c_{T-1}) \\;=\\; \\beta\\,u_B'(W_T)$.\n\nC.\n- Terminal condition: $V_T(W_T) \\;=\\; u(W_T)$.\n- Recursion for $t \\in \\{0,1,\\dots,T-1\\}$:\n$$\nV_t(W_t) \\;=\\; \\max_{c_t \\ge 0} \\left\\{ u(c_t) \\;+\\; \\beta\\,V_{t+1}\\!\\left((1+r)\\,(W_t - c_t) + y_{t+1}\\right) \\right\\}.\n$$\n- First-order condition in $t=T-1$ (interior): $u'(c_{T-1}) \\;=\\; \\beta\\,(1+r)\\,u'(c_T)$.\n\nD.\n- Terminal condition: $V_T(W_T) \\;=\\; u_B(W_T)$.\n- Recursion for $t \\in \\{0,1,\\dots,T-1\\}$:\n$$\nV_t(W_t) \\;=\\; \\max_{c_t \\ge 0} \\left\\{ u(c_t) \\;+\\; \\beta\\,\\Big( V_{t+1}\\!\\left((1+r)\\,(W_t - c_t) + y_{t+1}\\right) \\;+\\; u_B\\!\\left((1+r)\\,(W_t - c_t) + y_{t+1}\\right) \\Big) \\right\\}.\n$$\n- First-order condition in $t=T-1$ (interior): $u'(c_{T-1}) \\;=\\; \\beta\\,(1+r)\\,\\Big(u'(c_T) \\;+\\; u_B'(W_T)\\Big)$.",
            "solution": "The problem statement will first be subjected to rigorous validation.\n\n### Step 1: Extract Givens\nThe problem describes a finite-horizon, deterministic life-cycle consumption-savings model.\n-   **Time horizon**: Discrete time periods $t \\in \\{0, 1, \\dots, T-1\\}$.\n-   **State variable**: Wealth at the beginning of period $t$, $W_t \\ge 0$.\n-   **Control variable**: Consumption in period $t$, $c_t \\ge 0$.\n-   **Law of motion for wealth**: $W_{t+1} = (1+r)(W_t - c_t) + y_{t+1}$.\n-   **Net interest rate**: $r  -1$, constant.\n-   **Exogenous income stream**: $\\{y_t\\}_{t=1}^T$, where $y_t \\ge 0$.\n-   **Objective function (preferences)**: $\\sum_{t=0}^{T-1} \\beta^t\\,u(c_t) + \\beta^T\\,u_B(W_T)$.\n-   **Discount factor**: $\\beta \\in (0,1)$.\n-   **Period utility function**: $u:\\mathbb{R}_+ \\to \\mathbb{R}$.\n-   **Bequest utility function**: $u_B:\\mathbb{R}_+ \\to \\mathbb{R}$.\n-   **Assumptions on utility functions**: $u$ and $u_B$ are strictly increasing, strictly concave, and twice continuously differentiable ($C^2$).\n-   **Solution characteristic**: The optimum is interior, so first-order conditions apply.\n\n### Step 2: Validate Using Extracted Givens\nThe problem presents a canonical model in dynamic macroeconomics and computational economics.\n\n-   **Scientific Grounding**: The model is a standard representation of intertemporal choice under certainty. The formulation, including the objective function, law of motion, and assumptions on utility, is a cornerstone of economic theory. It is entirely scientifically sound.\n-   **Well-Posedness**: The problem is well-posed. The assumptions of strict concavity on the utility functions, along with the structure of the problem, ensure that a unique, well-behaved optimal consumption plan exists for a given initial wealth $W_0$.\n-   **Objectivity**: The problem is stated using precise mathematical language, free from any subjective or ambiguous terminology.\n-   **Check for Flaws**:\n    1.  **Scientific/Factual Unsoundness**: None. The model is a standard theoretical construct.\n    2.  **Non-Formalizable/Irrelevant**: The problem is a formal mathematical exercise directly related to the Bellman equation, as required.\n    3.  **Incomplete/Contradictory Setup**: The problem is complete and self-consistent. All necessary components for setting up the Bellman equation are provided.\n    4.  **Unrealistic/Infeasible**: The model is a simplification of reality, but it is not scientifically implausible or physically impossible. The condition $r  -1$ is standard and ensures the budget constraint is not pathological.\n    5.  **Ill-Posed/Poorly Structured**: None. The problem structure is clear and leads to a unique solution.\n    6.  **Outside Scientific Verifiability**: The problem is a mathematical one and is entirely verifiable through standard methods of dynamic programming.\n\n### Step 3: Verdict and Action\nThe problem statement is valid. I will now proceed with the derivation and analysis.\n\n---\n\nThe problem is solved using the principle of dynamic programming, working backward from the final period $T$. Let $V_t(W_t)$ be the value function, representing the maximum attainable utility from period $t$ onward, given wealth $W_t$. The standard definition of the value function, which normalizes the discount factor at each stage, is:\n$$\nV_t(W_t) \\;=\\; \\max_{\\{c_s\\}_{s=t}^{T-1}} \\left\\{ \\sum_{s=t}^{T-1} \\beta^{s-t} u(c_s) \\;+\\; \\beta^{T-t} u_B(W_T) \\right\\}\n$$\n\n**1. Derivation of the Terminal Condition**\n\nAt the final date $t=T$, no more consumption decisions are made. The agent is left with wealth $W_T$. The remaining utility is derived solely from the bequest. According to the definition of the value function, for $t=T$, we have:\n$$\nV_T(W_T) \\;=\\; \\beta^{T-T} u_B(W_T) \\;=\\; u_B(W_T)\n$$\nThis is the terminal condition for the Bellman recursion. It states that the value of being at the end of life with wealth $W_T$ is simply the utility derived from bequeathing that amount.\n\n**2. Derivation of the Bellman Recursion**\n\nFor any period $t  T$, the value function can be expressed recursively by breaking the decision into the current choice ($c_t$) and the consequences for the future.\n$$\nV_t(W_t) \\;=\\; \\max_{c_t} \\left\\{ u(c_t) \\;+\\; \\beta \\left( \\max_{\\{c_s\\}_{s=t+1}^{T-1}} \\left\\{ \\sum_{s=t+1}^{T-1} \\beta^{s-(t+1)} u(c_s) \\;+\\; \\beta^{T-(t+1)} u_B(W_T) \\right\\} \\right) \\right\\}\n$$\nThe expression inside the outer parentheses is, by definition, the value function for the next period, $V_{t+1}(W_{t+1})$. Therefore, we obtain the Bellman equation:\n$$\nV_t(W_t) \\;=\\; \\max_{c_t \\ge 0} \\left\\{ u(c_t) \\;+\\; \\beta\\,V_{t+1}(W_{t+1}) \\right\\}\n$$\nSubstituting the law of motion for wealth, $W_{t+1} = (1+r)(W_t - c_t) + y_{t+1}$, we get the full recursion for $t \\in \\{0, 1, \\dots, T-1\\}$:\n$$\nV_t(W_t) \\;=\\; \\max_{c_t \\ge 0} \\left\\{ u(c_t) \\;+\\; \\beta\\,V_{t+1}\\!\\left((1+r)\\,(W_t - c_t) + y_{t+1}\\right) \\right\\}\n$$\n\n**3. Derivation of the First-Order Condition in Period $t=T-1$**\n\nWe now specialize the Bellman equation to the last period of decision-making, $t=T-1$.\n$$\nV_{T-1}(W_{T-1}) \\;=\\; \\max_{c_{T-1} \\ge 0} \\left\\{ u(c_{T-1}) \\;+\\; \\beta\\,V_T(W_T) \\right\\}\n$$\nUsing the terminal condition $V_T(W_T) = u_B(W_T)$, this becomes:\n$$\nV_{T-1}(W_{T-1}) \\;=\\; \\max_{c_{T-1} \\ge 0} \\left\\{ u(c_{T-1}) \\;+\\; \\beta\\,u_B(W_T) \\right\\}\n$$\nNext, we substitute the law of motion connecting $W_T$ to the choice $c_{T-1}$: $W_T = (1+r)(W_{T-1} - c_{T-1}) + y_T$.\n$$\nV_{T-1}(W_{T-1}) \\;=\\; \\max_{c_{T-1} \\ge 0} \\left\\{ u(c_{T-1}) \\;+\\; \\beta\\,u_B\\!\\left((1+r)\\,(W_{T-1} - c_{T-1}) + y_T\\right) \\right\\}\n$$\nTo find the optimal consumption $c_{T-1}$, we differentiate the expression inside the maximization operator with respect to $c_{T-1}$ and set it to zero, as an interior solution is assumed.\n$$\n\\frac{\\partial}{\\partial c_{T-1}} \\left[ u(c_{T-1}) \\;+\\; \\beta\\,u_B\\!\\left((1+r)\\,(W_{T-1} - c_{T-1}) + y_T\\right) \\right] \\;=\\; 0\n$$\nApplying the chain rule:\n$$\nu'(c_{T-1}) \\;+\\; \\beta\\,u_B'(W_T) \\cdot \\frac{\\partial W_T}{\\partial c_{T-1}} \\;=\\; 0\n$$\nThe derivative of $W_T$ with respect to $c_{T-1}$ is:\n$$\n\\frac{\\partial W_T}{\\partial c_{T-1}} \\;=\\; \\frac{\\partial}{\\partial c_{T-1}} \\left[ (1+r)(W_{T-1} - c_{T-1}) + y_T \\right] \\;=\\; -(1+r)\n$$\nSubstituting this into the first-order condition:\n$$\nu'(c_{T-1}) \\;+\\; \\beta\\,u_B'(W_T) \\cdot (-(1+r)) \\;=\\; 0\n$$\nRearranging the terms yields the final first-order condition for period $T-1$:\n$$\nu'(c_{T-1}) \\;=\\; \\beta\\,(1+r)\\,u_B'(W_T)\n$$\nThis is the Euler equation for the final period. It equates the marginal utility of consuming one unit of wealth today with the discounted marginal utility of saving that unit, letting it grow at rate $r$, and bequeathing it at time $T$.\n\n**Evaluation of Options**\n\n-   **Option A**:\n    -   Terminal condition: $V_T(W_T) = u_B(W_T)$. This is correct.\n    -   Recursion: $V_t(W_t) = \\max_{c_t \\ge 0} \\left\\{ u(c_t) + \\beta\\,V_{t+1}\\!\\left((1+r)\\,(W_t - c_t) + y_{t+1}\\right) \\right\\}$. This is correct.\n    -   First-order condition in $t=T-1$: $u'(c_{T-1}) = \\beta\\,(1+r)\\,u_B'(W_T)$. This is correct.\n    -   Verdict: **Correct**. All three components are derived correctly.\n\n-   **Option B**:\n    -   Terminal condition: $V_T(W_T) = \\beta\\,u_B(W_T)$. This is incorrect. The value function at time $t$ is conventionally defined as the present value of utility from time $t$ onward, discounted to time $t$. The $\\beta$ factor is not part of the terminal value.\n    -   Recursion: The recursion formula is stated correctly.\n    -   First-order condition: $u'(c_{T-1}) = \\beta\\,u_B'(W_T)$. This is incorrect. It is missing the factor $(1+r)$, which represents the gross return on savings. This condition would only hold if $r=0$.\n    -   Verdict: **Incorrect**.\n\n-   **Option C**:\n    -   Terminal condition: $V_T(W_T) = u(W_T)$. This is incorrect. The utility at the terminal date is given by the bequest utility function $u_B$, not the period consumption utility function $u$.\n    -   Recursion: The recursion formula is stated correctly.\n    -   First-order condition: $u'(c_{T-1}) = \\beta\\,(1+r)\\,u'(c_T)$. This is fundamentally incorrect. There is no consumption choice $c_T$ in period $T$. Utility at time $T$ depends on the stock of wealth $W_T$, not a flow of consumption. This equation seems to confuse the finite-horizon model with an infinite-horizon Euler equation.\n    -   Verdict: **Incorrect**.\n\n-   **Option D**:\n    -   Terminal condition: $V_T(W_T) = u_B(W_T)$. This is correct.\n    -   Recursion: The recursion is stated as $V_t(W_t) = \\max_{c_t \\ge 0} \\{ u(c_t) + \\beta\\,\\Big( V_{t+1}(\\dots) + u_B(\\dots) \\Big) \\}$. This is incorrect. It incorrectly adds the bequest utility in every period's recursion. The bequest motive applies only once, to the terminal wealth $W_T$. This formulation is a serious misstatement of the dynamic programming principle.\n    -   First-order condition: $u'(c_{T-1}) = \\beta\\,(1+r)\\,\\Big(u'(c_T) + u_B'(W_T)\\Big)$. This is incorrect, suffering from both the error of including a non-existent $c_T$ and being derived from an invalid recursive structure.\n    -   Verdict: **Incorrect**.\n\nBased on a rigorous derivation from first principles, Option A is the only one that correctly states the terminal condition, the Bellman recursion, and the period $T-1$ first-order condition.",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "While many dynamic programming problems require numerical methods, some canonical models admit elegant analytical solutions that offer deep economic insights. This problem  challenges you to solve a stochastic, infinite-horizon savings model by conjecturing a specific functional form for the value function—a powerful technique known as the 'guess and verify' method. By characterizing the value function near the bankruptcy state, you will see how the model's core parameters, such as risk aversion and the discount factor, directly shape the solution.",
            "id": "2437253",
            "problem": "Consider an infinite-horizon consumption-savings problem faced by a single agent with Constant Relative Risk Aversion (CRRA) preferences. The agent’s period utility is $u(c) = \\frac{c^{1-\\sigma}}{1-\\sigma}$ with parameter $\\sigma \\in (0,1)$, and the discount factor is $\\beta \\in (0,1)$. Wealth $\\{W_t\\}_{t \\geq 0}$ evolves according to the budget transition\n$$\nW_{t+1} \\;=\\; R_{t+1}\\,\\bigl(W_t - c_t\\bigr),\n$$\nwhere the gross investment return $\\{R_t\\}_{t \\geq 1}$ is independent and identically distributed (IID) across time, taking values $r_L0$ with probability $p \\in (0,1)$ and $r_H0$ with probability $1-p$. The agent faces the borrowing constraint $c_t \\in [0, W_t]$. If $W_t \\leq 0$ then bankruptcy occurs, the state is absorbing with $W_{t+s}=0$ for all $s \\geq 1$, and period utility at $c_t=0$ equals $u(0)=0$.\n\nLet $V(W)$ denote the value function that solves the Bellman equation\n$$\nV(W) \\;=\\; \\max_{c \\in [0,W]} \\Bigl\\{ u(c) \\;+\\; \\beta \\,\\mathbb{E}\\bigl[\\,V\\bigl(R\\,(W-c)\\bigr)\\,\\bigr] \\Bigr\\},\n$$\nwith boundary condition $V(0)=0$, where the expectation is taken over $R \\in \\{r_L, r_H\\}$.\n\nAssume the parameters satisfy the finiteness condition\n$$\n\\Bigl(\\beta \\,\\bigl[p\\,r_L^{\\,1-\\sigma} + (1-p)\\,r_H^{\\,1-\\sigma}\\bigr]\\Bigr)^{\\frac{1}{\\sigma}} \\;\\; 1.\n$$\n\nDefine the leading-order coefficient near the absorbing state\n$$\n\\Lambda(\\beta,\\sigma,p,r_L,r_H) \\;\\equiv\\; \\lim_{W \\to 0^+} \\frac{V(W)}{W^{\\,1-\\sigma}}.\n$$\n\nUsing only the Bellman equation and the model’s primitives, determine the exact closed-form expression for $\\Lambda(\\beta,\\sigma,p,r_L,r_H)$. Your final answer must be a single analytic expression in terms of $\\beta$, $\\sigma$, $p$, $r_L$, and $r_H$.",
            "solution": "The problem statement is subjected to validation.\n\n**Step 1: Extract Givens**\n- Utility function: $u(c) = \\frac{c^{1-\\sigma}}{1-\\sigma}$ with $\\sigma \\in (0,1)$.\n- Discount factor: $\\beta \\in (0,1)$.\n- Budget transition: $W_{t+1} = R_{t+1}(W_t - c_t)$.\n- Investment return $R$: IID, takes value $r_L  0$ with probability $p \\in (0,1)$ and $r_H  0$ with probability $1-p$.\n- Constraint: $c_t \\in [0, W_t]$.\n- Boundary/Absorbing state: $V(0)=0$.\n- Bellman equation: $V(W) = \\max_{c \\in [0,W]} \\left\\{ u(c) + \\beta \\mathbb{E}[V(R(W-c))] \\right\\}$.\n- Finiteness condition: $(\\beta [p r_L^{1-\\sigma} + (1-p) r_H^{1-\\sigma}])^{\\frac{1}{\\sigma}}  1$.\n- Objective: Find the closed-form expression for $\\Lambda \\equiv \\lim_{W \\to 0^+} \\frac{V(W)}{W^{\\,1-\\sigma}}$.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is a canonical infinite-horizon dynamic programming problem in quantitative economics. All components are standard and rigorously defined.\n- **Scientifically Grounded**: The model is a cornerstone of modern macroeconomics (the consumption-savings problem). The CRRA utility function is a standard assumption. The Bellman equation is the fundamental tool for such problems. The setup is mathematically and economically sound.\n- **Well-Posed**: The problem is well-posed. The provided finiteness condition is precisely the one required to ensure a non-trivial, finite value function exists. The constraints are clearly specified. The objective is to find a well-defined mathematical limit.\n- **Objective**: The problem is stated using precise mathematical language, free from any subjectivity.\n\n**Step 3: Verdict and Action**\nThe problem is valid. It is a well-defined and self-contained mathematical problem grounded in established economic theory. A complete solution will be provided.\n\nThe problem is to determine the coefficient $\\Lambda$ which describes the leading-order behavior of the value function $V(W)$ as wealth $W$ approaches the absorbing state at zero. Given the CRRA utility function and the multiplicative nature of the wealth shocks, this class of model admits a solution where the value function is homogeneous of degree $1-\\sigma$. We therefore conjecture a solution of the form:\n$$\nV(W) = A W^{1-\\sigma}\n$$\nfor some constant coefficient $A  0$. Under this conjecture, the quantity to be determined is precisely this coefficient:\n$$\n\\Lambda = \\lim_{W \\to 0^+} \\frac{V(W)}{W^{\\,1-\\sigma}} = \\lim_{W \\to 0^+} \\frac{A W^{1-\\sigma}}{W^{\\,1-\\sigma}} = A\n$$\nThe associated optimal policy function is linear in wealth: $c(W) = \\lambda W$ for some constant consumption-to-wealth ratio $\\lambda \\in (0,1)$. The task reduces to finding the constant $A$. This will be accomplished in two logical steps: first, we determine the optimal policy parameter $\\lambda$, and second, we use this to find the value function coefficient $A$.\n\nLet us define the constant expected return factor for brevity:\n$$\n\\mathcal{R} \\equiv \\mathbb{E}[R^{1-\\sigma}] = p r_L^{1-\\sigma} + (1-p) r_H^{1-\\sigma}\n$$\nThe Bellman equation can be written as:\n$$\nV(W) = \\max_{c \\in [0,W]} \\left\\{ \\frac{c^{1-\\sigma}}{1-\\sigma} + \\beta \\mathbb{E}[V(R(W-c))] \\right\\}\n$$\nSubstituting the conjectured form $V(W) = A W^{1-\\sigma}$:\n$$\nA W^{1-\\sigma} = \\max_{c \\in [0,W]} \\left\\{ \\frac{c^{1-\\sigma}}{1-\\sigma} + \\beta \\mathbb{E}[A (R(W-c))^{1-\\sigma}] \\right\\} = \\max_{c \\in [0,W]} \\left\\{ \\frac{c^{1-\\sigma}}{1-\\sigma} + \\beta A (W-c)^{1-\\sigma} \\mathcal{R} \\right\\}\n$$\n\n**Step 1: Determination of the optimal policy parameter $\\lambda$.**\nWe apply the envelope theorem to the Bellman equation. Differentiating the value function with respect to the state variable $W$ yields:\n$$\nV'(W) = \\frac{\\partial}{\\partial W} \\left( \\frac{c^{1-\\sigma}}{1-\\sigma} + \\beta \\mathbb{E}[V(R(W-c))] \\right) \\Biggr|_{c=c(W)}\n$$\nThe theorem states we can ignore the effect of $W$ on the optimal choice $c(W)$, so we treat $c$ as fixed when differentiating with respect to $W$:\n$$\nV'(W) = \\beta \\mathbb{E}[V'(R(W-c(W))) \\cdot R]\n$$\nNow, we substitute the conjectured form $V(W) = A W^{1-\\sigma}$, which implies $V'(W) = A(1-\\sigma)W^{-\\sigma}$. The optimal policy is $c(W)=\\lambda W$.\n$$\nA(1-\\sigma)W^{-\\sigma} = \\beta \\mathbb{E}\\left[ A(1-\\sigma)(R(W - \\lambda W))^{-\\sigma} \\cdot R \\right]\n$$\nCanceling the term $A(1-\\sigma)$ from both sides (since $A0$ and $\\sigma \\neq 1$):\n$$\nW^{-\\sigma} = \\beta \\mathbb{E}\\left[ (R(1-\\lambda)W)^{-\\sigma} R \\right] = \\beta (1-\\lambda)^{-\\sigma} W^{-\\sigma} \\mathbb{E}[R^{-\\sigma} R]\n$$\n$$\nW^{-\\sigma} = \\beta (1-\\lambda)^{-\\sigma} W^{-\\sigma} \\mathbb{E}[R^{1-\\sigma}]\n$$\nCanceling $W^{-\\sigma}$ (for $W0$) and using the definition of $\\mathcal{R}$:\n$$\n1 = \\beta (1-\\lambda)^{-\\sigma} \\mathcal{R}\n$$\nWe can now solve for the optimal consumption-to-wealth ratio $\\lambda$:\n$$\n(1-\\lambda)^{\\sigma} = \\beta \\mathcal{R}\n$$\n$$\n1-\\lambda = (\\beta \\mathcal{R})^{\\frac{1}{\\sigma}}\n$$\n$$\n\\lambda = 1 - (\\beta \\mathcal{R})^{\\frac{1}{\\sigma}} = 1 - \\left( \\beta \\left[ p r_L^{1-\\sigma} + (1-p) r_H^{1-\\sigma} \\right] \\right)^{\\frac{1}{\\sigma}}\n$$\nThe problem's finiteness condition ensures that $(\\beta \\mathcal{R})^{\\frac{1}{\\sigma}}  1$, which guarantees that $\\lambda \\in (0,1)$, consistent with a non-trivial interior solution.\n\n**Step 2: Determination of the value function coefficient $A$.**\nHaving found the optimal policy parameter $\\lambda$, we substitute the policy $c = \\lambda W$ back into the Bellman equation. Since the policy is optimal, the 'max' operator is no longer needed.\n$$\nA W^{1-\\sigma} = \\frac{(\\lambda W)^{1-\\sigma}}{1-\\sigma} + \\beta \\mathbb{E}[A (R(W-\\lambda W))^{1-\\sigma}]\n$$\nFactoring out common terms:\n$$\nA W^{1-\\sigma} = \\frac{\\lambda^{1-\\sigma} W^{1-\\sigma}}{1-\\sigma} + \\beta A (1-\\lambda)^{1-\\sigma} W^{1-\\sigma} \\mathbb{E}[R^{1-\\sigma}]\n$$\nDividing the entire equation by $W^{1-\\sigma}$ (for $W0$) and using the definition of $\\mathcal{R}$:\n$$\nA = \\frac{\\lambda^{1-\\sigma}}{1-\\sigma} + \\beta A (1-\\lambda)^{1-\\sigma} \\mathcal{R}\n$$\nWe solve for $A$:\n$$\nA \\left( 1 - \\beta (1-\\lambda)^{1-\\sigma} \\mathcal{R} \\right) = \\frac{\\lambda^{1-\\sigma}}{1-\\sigma}\n$$\nFrom Step 1, we have the identity $(1-\\lambda)^{\\sigma} = \\beta \\mathcal{R}$. We use this to simplify the term in the parentheses:\n$$\n1 - \\beta (1-\\lambda)^{1-\\sigma} \\mathcal{R} = 1 - (1-\\lambda)^{1-\\sigma} (\\beta \\mathcal{R}) = 1 - (1-\\lambda)^{1-\\sigma} (1-\\lambda)^{\\sigma} = 1 - (1-\\lambda)^{1-\\sigma+\\sigma} = 1 - (1-\\lambda) = \\lambda\n$$\nSubstituting this simplification back into the equation for $A$:\n$$\nA \\cdot \\lambda = \\frac{\\lambda^{1-\\sigma}}{1-\\sigma}\n$$\nSince $\\lambda  0$, we can divide by $\\lambda$:\n$$\nA = \\frac{\\lambda^{-\\sigma}}{1-\\sigma}\n$$\nFinally, we substitute the expression for $\\lambda$ from Step 1 into this equation to find $A=\\Lambda$:\n$$\n\\Lambda = \\frac{1}{1-\\sigma} \\left[ 1 - (\\beta \\mathcal{R})^{\\frac{1}{\\sigma}} \\right]^{-\\sigma}\n$$\nSubstituting the definition of $\\mathcal{R}$ gives the final expression in terms of the model's primitive parameters:\n$$\n\\Lambda(\\beta,\\sigma,p,r_L,r_H) = \\frac{1}{1-\\sigma} \\left[ 1 - \\left( \\beta \\left( p r_L^{1-\\sigma} + (1-p) r_H^{1-\\sigma} \\right) \\right)^{\\frac{1}{\\sigma}} \\right]^{-\\sigma}\n$$\nThis expression is the exact closed-form solution for the requested coefficient.",
            "answer": "$$\n\\boxed{\\frac{1}{1-\\sigma} \\left[ 1 - \\left(\\beta \\left(p r_L^{1-\\sigma} + (1-p) r_H^{1-\\sigma}\\right)\\right)^{\\frac{1}{\\sigma}} \\right]^{-\\sigma}}\n$$"
        },
        {
            "introduction": "The true power of the Bellman equation framework is realized through computational methods that can solve problems lacking analytical solutions. This exercise  guides you through the implementation of value function iteration, the fundamental algorithm for numerically solving dynamic programming problems. By coding the iterative application of the Bellman operator, you will gain hands-on experience with the principles of contraction mappings and witness how the theoretical convergence rate relates to the algorithm's performance in practice.",
            "id": "2437296",
            "problem": "Consider a deterministic consumption-savings problem with a single asset state. Preferences are given by a Constant Relative Risk Aversion (CRRA) utility function with risk aversion parameter $\\sigma  0$ and per-period utility $u(c) = \\frac{c^{1-\\sigma}}{1-\\sigma}$ for $\\sigma \\neq 1$. The agent receives an exogenous income $y$ each period, has asset holdings $a$ that evolve deterministically, faces a gross return $1+r$ on assets, and cannot borrow. The state variable is assets $a$ and the control is next period assets $a'$. The one-period budget constraint is $c = (1+r)a + y - a'$, with non-negativity constraint $c \\ge 0$ and borrowing constraint $a' \\ge 0$.\n\nDefine a finite grid $\\mathcal{A}_N = \\{a_0, a_1, \\dots, a_{N-1}\\}$ of $N$ evenly spaced asset points on $[0, A_{\\max}]$. The dynamic programming problem is to compute the value function $V(a)$ that solves the Bellman equation\n$$\nV(a) = \\max_{a' \\in \\mathcal{A}_N} \\left\\{ u\\big((1+r)a + y - a'\\big) + \\beta V(a') \\right\\},\n$$\nsubject to $c = (1+r)a + y - a' \\ge 0$ and $a' \\ge 0$, where $\\beta \\in (0,1)$ is the discount factor. Let $\\mathcal{T}$ denote the Bellman operator defined by the right-hand side mapping from a function $V$ to a new function $\\mathcal{T}V$ on the grid.\n\nTasks:\n- Starting from the fundamental definition of the Bellman operator $\\mathcal{T}$ and the principles of dynamic programming under bounded and continuous utility and compact state-action sets, implement value function iteration by repeatedly applying $\\mathcal{T}$ to an initial guess $V_0(a) = 0$ on $\\mathcal{A}_N$ until convergence in the supremum norm. For each iteration $k$, compute the error $\\epsilon_k = \\| V_{k+1} - V_k \\|_\\infty = \\max_i | V_{k+1}(a_i) - V_k(a_i) |$.\n- Use a convergence tolerance of $\\text{tol} = 10^{-4}$ in the supremum norm and a maximum number of iterations of $1000$. Record the total number of iterations required for convergence for each grid size.\n- Compute an empirical convergence rate estimate by the ratio of successive errors $\\rho_k = \\epsilon_{k+1} / \\epsilon_k$. Report the observed rate as the median of the last $M$ available ratios prior to termination, where $M = 10$ or fewer if fewer ratios are available. Round this observed rate to three decimal places.\n- Use parameter values $\\beta = 0.90$, $r = 0.03$, $y = 1.0$, $\\sigma = 2.0$, and $A_{\\max} = 5.0$. For infeasible consumption $c \\le 0$, treat $u(c)$ as a very large negative value to enforce feasibility in maximization.\n\nTest suite:\n- Evaluate the program for the following asset grid sizes $N \\in \\{5, 20, 80, 160\\}$.\n\nRequired final output:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each element of the list corresponds to one grid size $N$ and must itself be a list of the form `[N, iterations, observed_rate]`, where `iterations` is the integer number of iterations to convergence and `observed_rate` is the float rounded to three decimals. For example, an output with two test cases would look like `[[N_1, I_1, R_1],[N_2, I_2, R_2]]`.\n\nScientific realism and derivation basis:\n- Begin from core definitions: the Bellman operator $\\mathcal{T}$, the supremum norm $\\| \\cdot \\|_\\infty$, and the contraction mapping principle under discounting. Do not assume any closed-form solution for $V(a)$ and do not use any acceleration methods; strictly use value function iteration with full grid search over $a' \\in \\mathcal{A}_N$.",
            "solution": "The problem requires the numerical solution of a deterministic consumption-savings model using value function iteration. The solution must be derived from fundamental principles of dynamic programming.\n\n**1. Theoretical Foundation: The Bellman Equation and Contraction Mappings**\n\nThe agent's problem can be formulated recursively. The value function, $V(a)$, represents the maximum lifetime utility an agent can achieve starting with asset level $a$. It must satisfy the Bellman equation, which defines a functional fixed-point problem:\n$$\nV(a) = \\max_{a' \\in [0, (1+r)a+y]} \\left\\{ u\\big((1+r)a + y - a'\\big) + \\beta V(a') \\right\\}\n$$\nHere, $u(c)$ is the per-period utility function, $c$ is consumption, $a$ is the current asset level (state), $a'$ is the next-period asset level (control), $r$ is the interest rate, $y$ is income, and $\\beta \\in (0,1)$ is the discount factor. The maximization is subject to the budget constraint $c = (1+r)a + y - a'$ and non-negativity constraints $c \\ge 0$ and $a' \\ge 0$.\n\nThis equation can be expressed using the Bellman operator, $\\mathcal{T}$, which maps a candidate value function $W$ to a new function $\\mathcal{T}W$:\n$$\n(\\mathcal{T}W)(a) = \\max_{a'} \\left\\{ u(c) + \\beta W(a') \\right\\}\n$$\nThe true value function $V$ is the unique fixed point of this operator, i.e., $V = \\mathcal{T}V$. The existence and uniqueness of this fixed point, and the convergence of iterative methods to it, are guaranteed by the Contraction Mapping Theorem. For a complete metric space of bounded functions equipped with the supremum norm $\\lVert f \\rVert_\\infty = \\sup_x |f(x)|$, an operator $\\mathcal{T}$ is a contraction if there exists a constant $\\gamma \\in [0,1)$ such that for any two functions $f_1, f_2$ in the space, $\\lVert \\mathcal{T}f_1 - \\mathcal{T}f_2 \\rVert_\\infty \\le \\gamma \\lVert f_1 - f_2 \\rVert_\\infty$. The Bellman operator $\\mathcal{T}$ is a contraction with modulus $\\beta$ because of discounting.\n\nThis property guarantees that for any initial bounded guess $V_0$, the sequence generated by value function iteration, $V_{k+1} = \\mathcal{T}V_k$, converges to the unique solution $V$. The rate of convergence is geometric, with the distance to the fixed point decreasing by at least a factor of $\\beta$ at each step. This implies that the distance between successive iterates also shrinks: $\\lVert V_{k+1} - V_k \\rVert_\\infty \\le \\beta \\lVert V_k - V_{k-1} \\rVert_\\infty$.\n\n**2. Discretization and Algorithmic Implementation**\n\nTo solve the problem computationally, we must discretize the continuous state space. The asset holdings $a$ are restricted to a finite grid of $N$ points, $\\mathcal{A}_N = \\{a_0, a_1, \\ldots, a_{N-1}\\}$, evenly spaced on $[0, A_{\\max}]$. The value function is thus represented by a vector $\\mathbf{V}$ of length $N$, where $\\mathbf{V}[i] = V(a_i)$.\n\nThe value function iteration algorithm is as follows:\n- **Step 1: Initialization.** Start with an initial guess for the value function vector, typically $\\mathbf{V}_0 = \\mathbf{0}$. Set an iteration counter $k=0$ and a convergence tolerance $\\text{tol}$. The specified parameters are $\\beta=0.90$, $r=0.03$, $y=1.0$, $\\sigma=2.0$, $A_{\\max}=5.0$, and $\\text{tol}=10^{-4}$. The utility function is $u(c) = \\frac{c^{1-\\sigma}}{1-\\sigma} = -c^{-1}$ for $\\sigma=2.0$.\n- **Step 2: Iteration.** Apply the Bellman operator to update the value function. For each grid point $a_i \\in \\mathcal{A}_N$, solve the maximization problem:\n$$\n\\mathbf{V}_{k+1}[i] = \\max_{j \\in \\{0, \\ldots, N-1\\}} \\left\\{ u\\big((1+r)a_i + y - a_j\\big) + \\beta \\mathbf{V}_k[j] \\right\\}\n$$\nThe choice set for $a'$ is also restricted to the grid $\\mathcal{A}_N$. Choices $a_j$ that lead to non-positive consumption ($c_{ij} = (1+r)a_i+y-a_j \\le 0$) are infeasible. As specified, this is handled by assigning a very large negative utility to such choices, effectively excluding them from the maximization.\n- **Step 3: Convergence Check.** After each full update of the value function vector, compute the sup-norm error:\n$$\n\\epsilon_k = \\lVert \\mathbf{V}_{k+1} - \\mathbf{V}_k \\rVert_\\infty = \\max_{i \\in \\{0, \\ldots, N-1\\}} |\\mathbf{V}_{k+1}[i] - \\mathbf{V}_k[i]|\n$$\nThe loop continues until $\\epsilon_k  \\text{tol}$ or a maximum number of iterations is reached.\n\n**3. Efficient Vectorized Computation**\n\nA naive implementation with nested loops is computationally expensive, scaling as $\\mathcal{O}(N^2)$ per iteration. A superior approach uses vectorization. Let $\\mathbf{a}$ be the $N \\times 1$ column vector of asset grid points. The cash-on-hand for each state is the vector $\\mathbf{z} = (1+r)\\mathbf{a} + y$. We can construct an $N \\times N$ matrix of potential consumption values, $\\mathbf{C}$, where $\\mathbf{C}_{ij} = z_i - a_j$. This is computed via broadcasting as $\\mathbf{C} = \\mathbf{z} - \\mathbf{a}^T$.\n\nA corresponding $N \\times N$ utility matrix $\\mathbf{U}$ is then formed:\n$$\n\\mathbf{U}_{ij} =\n\\begin{cases}\n- (\\mathbf{C}_{ij})^{-1}  \\text{if } \\mathbf{C}_{ij}  0 \\\\\n-\\infty  \\text{if } \\mathbf{C}_{ij} \\le 0\n\\end{cases}\n$$\nThe value function update for all states can then be performed in a single, efficient operation:\n$$\n\\mathbf{V}_{k+1} = \\max_{\\text{axis}=1}(\\mathbf{U} + \\beta \\mathbf{V}_k^T)\n$$\nwhere `axis=1` indicates maximization over the columns (the choice variable $a'$ index $j$) and $\\mathbf{V}_k^T$ is broadcast across the rows of $\\mathbf{U}$.\n\n**4. Empirical Convergence Rate**\n\nThe theoretical convergence rate of the iteration is $\\beta$. We can estimate this empirically from the sequence of errors $\\{\\epsilon_k\\}$. The ratio of successive errors $\\rho_k = \\epsilon_{k+1} / \\epsilon_k$ should converge to $\\beta$. To obtain a stable estimate, we compute the median of the last $M=10$ such ratios available before the algorithm terminates. This provides the `observed_rate`.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef vfi_solver(N, beta, sigma, y, r, A_max, tol, max_iter, M):\n    \"\"\"\n    Solves the deterministic consumption-savings problem using Value Function Iteration.\n\n    Args:\n        N (int): Number of points in the asset grid.\n        beta (float): Discount factor.\n        sigma (float): Coefficient of relative risk aversion.\n        y (float): Exogenous income.\n        r (float): Net interest rate.\n        A_max (float): Maximum asset level.\n        tol (float): Convergence tolerance for the supremum norm.\n        max_iter (int): Maximum number of iterations.\n        M (int): Number of recent error ratios to use for rate calculation.\n\n    Returns:\n        list: A list containing [N, number_of_iterations, observed_rate].\n    \"\"\"\n    # 1. Discretize the state space\n    a_grid = np.linspace(0, A_max, N)\n\n    # 2. Initialize value function and error list\n    V = np.zeros(N)\n    errors = []\n\n    # 3. Vectorized setup for efficient computation\n    # Reshape grids for broadcasting\n    a_grid_col = a_grid.reshape(N, 1)  # Current assets 'a'\n    a_grid_row = a_grid.reshape(1, N)  # Next period assets 'a''\n\n    # Calculate cash-on-hand for each current asset level\n    cash_on_hand = (1 + r) * a_grid_col + y\n\n    # Calculate consumption for all (a, a') pairs\n    consumption = cash_on_hand - a_grid_row\n    \n    # Define the utility function\n    # Note: As per problem, sigma is not 1.\n    def u(c):\n        return (c**(1 - sigma)) / (1 - sigma)\n\n    # Pre-calculate utility matrix.\n    # Set utility of non-positive consumption to a very large negative number\n    # to enforce feasibility during maximization.\n    utility = np.full((N, N), -np.inf)\n    positive_c_mask = consumption  0\n    utility[positive_c_mask] = u(consumption[positive_c_mask])\n    \n    # 4. Value Function Iteration loop\n    num_iterations = 0\n    for k in range(max_iter):\n        # Apply the Bellman operator in a vectorized fashion\n        # V is (N,), broadcasting makes it equivalent to V.reshape(1, N)\n        # So (utility + beta * V) is an (N, N) matrix.\n        next_V = np.max(utility + beta * V, axis=1)\n        \n        # Calculate supremum norm error\n        error = np.max(np.abs(next_V - V))\n        errors.append(error)\n        \n        # Update value function\n        V = next_V\n        num_iterations = k + 1\n        \n        # Check for convergence\n        if error  tol:\n            break\n\n    # 5. Calculate the empirical convergence rate\n    observed_rate = np.nan\n    if len(errors)  1:\n        # Ratios are epsilon_{k+1} / epsilon_k\n        ratios = np.array(errors[1:]) / np.array(errors[:-1])\n        \n        # Take the median of the last M ratios (or fewer if not enough exist)\n        num_ratios_to_consider = min(M, len(ratios))\n        if num_ratios_to_consider  0:\n            last_ratios = ratios[-num_ratios_to_consider:]\n            observed_rate = float(np.median(last_ratios))\n\n    # Round the rate to three decimal places\n    if not np.isnan(observed_rate):\n        observed_rate = round(observed_rate, 3)\n\n    return [N, num_iterations, observed_rate]\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the parameters from the problem statement.\n    params = {\n        'beta': 0.90,\n        'sigma': 2.0,\n        'y': 1.0,\n        'r': 0.03,\n        'A_max': 5.0,\n        'tol': 1e-4,\n        'max_iter': 1000,\n        'M': 10\n    }\n    \n    # Define the test cases from the problem statement.\n    test_cases = [5, 20, 80, 160]\n\n    results = []\n    for N in test_cases:\n        # Run the solver for one grid size\n        result = vfi_solver(N=N, **params)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # e.g., [[N1,I1,R1],[N2,I2,R2]]\n    # Using str().replace() is a reliable way to get this format without spaces.\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```"
        }
    ]
}