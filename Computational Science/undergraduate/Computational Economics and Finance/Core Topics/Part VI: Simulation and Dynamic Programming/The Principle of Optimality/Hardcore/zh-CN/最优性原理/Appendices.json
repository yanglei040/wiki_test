{
    "hands_on_practices": [
        {
            "introduction": "本练习探讨一个经典的“最优停止”问题，它是动态决策理论的基石。在面对一系列按顺序出现的机会时（例如投资项目或工作邀约），我们的目标是确定一个简单的决策规则（一个阈值），以决定何时停止搜索并接受当前的机会。通过本练习 ，你将看到最优性原理如何自然地引出贝尔曼方程，并最终求解出最优策略。",
            "id": "2443380",
            "problem": "一位基金经理面临一个模拟连续投资机会的无限期动态选择问题。时间是离散的，周期由 $t \\in \\{0,1,2,\\dots\\}$ 索引。在每个周期 $t$，恰好有一个质量为 $X_{t}$ 的投资机会到来，其中 $\\{X_{t}\\}$ 是一个独立同分布序列，其共同密度函数在 $[0,1]$ 上为 $f(x)=1$，在其他情况下为 $f(x)=0$。在观察到 $X_{t}$ 后，经理必须要么接受该机会并不可撤销地停止，获得等于 $X_{t}$（以现值衡量）的即时回报；要么拒绝它并继续到下一个周期。未来的回报每个周期按因子 $\\delta \\in (0,1)$ 进行贴现。不可召回：被拒绝的机会以后不能再接受。经理的目标是最大化所接受回报的期望现值。\n\n确定最优接受阈值 $\\tau^{\\ast}$ 的精确闭式表达式（作为 $\\delta$ 的函数），使得在某个周期中，当且仅当 $X_{t} \\ge \\tau^{\\ast}$ 时接受是最优的。\n\n以 $\\delta$ 的单个解析表达式形式陈述您的最终答案。不需要数值近似或四舍五入。",
            "solution": "该问题描述了一个无限期、离散时间的最优停止问题。问题的平稳性（机会 $X_t$ 的分布和贴现因子 $\\delta$ 随时间保持不变）意味着最优策略也将是平稳的。这意味着存在一个单一的、不随时间变化的阈值 $\\tau^{\\ast}$，它决定了每个周期的最优决策。\n\n设 $V$ 为在任何周期开始时，在该周期的投资机会质量 $X_t$ 未知之前，可以获得的最大期望现值。由于平稳性，$V$ 是一个常数。\n\n在任何周期 $t$，经理观察到一个质量为 $X_t = x$。经理有两个选择：\n$1$. **接受**：过程终止，经理获得回报 $x$。\n$2$. **拒绝**：经理放弃回报 $x$ 并继续到下一个周期。从周期 $t$ 来看，继续的期望值是以最优方式开始下一周期的贴现值，即 $\\delta V$。\n\n最优性原理指出，经理将选择使期望回报最大化的行动。因此，在观察到 $x$ 时，获得的值为 $\\max(x, \\delta V)$。\n\n价值函数 $V$ 是此结果在 $X_t$ 所有可能实现上的期望值。随机变量 $X_t$ 在 $[0,1]$ 上均匀分布，其概率密度函数（PDF）为 $f(x)=1$。因此，$V$ 的贝尔曼方程为：\n$$V = \\mathbb{E}[\\max(X_t, \\delta V)] = \\int_{-\\infty}^{\\infty} \\max(x, \\delta V) f(x) dx = \\int_{0}^{1} \\max(x, \\delta V) dx$$\n\n项 $\\max(x, \\delta V)$ 的结构定义了最优策略。如果 $x \\ge \\delta V$ 则接受报价是最优的，如果 $x < \\delta V$ 则拒绝。这证实了最优阈值的存在，该阈值为 $\\tau^{\\ast} = \\delta V$。\n\n我们现在可以通过在阈值 $\\delta V$ 处分割积分来求解 $V$ 的积分方程。注意，由于 $X_t \\in [0,1]$ 且 $\\delta \\in (0,1)$，必然有 $V \\le 1$，这意味着 $\\delta V < 1$。阈值 $\\delta V$ 位于积分区间 $[0,1]$ 内。\n$$V = \\int_{0}^{\\delta V} (\\delta V) dx + \\int_{\\delta V}^{1} x dx$$\n\n我们计算每个积分：\n第一个积分是：\n$$\\int_{0}^{\\delta V} (\\delta V) dx = \\delta V [x]_{0}^{\\delta V} = \\delta V (\\delta V - 0) = \\delta^2 V^2$$\n\n第二个积分是：\n$$\\int_{\\delta V}^{1} x dx = \\left[ \\frac{x^2}{2} \\right]_{\\delta V}^{1} = \\frac{1^2}{2} - \\frac{(\\delta V)^2}{2} = \\frac{1}{2} - \\frac{\\delta^2 V^2}{2}$$\n\n将这些代回到 $V$ 的方程中：\n$$V = \\delta^2 V^2 + \\left( \\frac{1}{2} - \\frac{\\delta^2 V^2}{2} \\right)$$\n$$V = \\frac{1}{2}\\delta^2 V^2 + \\frac{1}{2}$$\n\n这是一个关于 $V$ 的二次方程。整理成标准形式 $aV^2 + bV + c = 0$：\n$$\\frac{1}{2}\\delta^2 V^2 - V + \\frac{1}{2} = 0$$\n乘以 $2$ 以消除分数，得到：\n$$\\delta^2 V^2 - 2V + 1 = 0$$\n\n我们使用二次公式 $V = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}$ 求解 $V$：\n$$V = \\frac{-(-2) \\pm \\sqrt{(-2)^2 - 4(\\delta^2)(1)}}{2\\delta^2}$$\n$$V = \\frac{2 \\pm \\sqrt{4 - 4\\delta^2}}{2\\delta^2} = \\frac{2 \\pm 2\\sqrt{1 - \\delta^2}}{2\\delta^2}$$\n$$V = \\frac{1 \\pm \\sqrt{1 - \\delta^2}}{\\delta^2}$$\n\n这给出了 $V$ 的两个潜在解。我们必须选择经济上有效的那一个。值 $V$ 代表了来自有界为 $1$ 的机会的期望回报，因此必须有 $V \\le 1$。\n\n我们来检验当 $\\delta \\to 0$ 时这两个根的情况：\n$1$. $V_1 = \\frac{1 + \\sqrt{1 - \\delta^2}}{\\delta^2}$。当 $\\delta \\to 0^+$ 时，分子趋近于 $1 + \\sqrt{1} = 2$，而分母趋近于 $0$。因此，$V_1 \\to \\infty$。这不是一个有经济意义的解。\n$2$. $V_2 = \\frac{1 - \\sqrt{1 - \\delta^2}}{\\delta^2}$。当 $\\delta \\to 0^+$ 时，我们得到一个不定式 $0/0$。我们可以使用洛必达法则，或者通过乘以其共轭表达式来使分子有理化：\n$$V_2 = \\frac{1 - \\sqrt{1 - \\delta^2}}{\\delta^2} \\times \\frac{1 + \\sqrt{1 - \\delta^2}}{1 + \\sqrt{1 - \\delta^2}} = \\frac{1 - (1 - \\delta^2)}{\\delta^2(1 + \\sqrt{1 - \\delta^2})} = \\frac{\\delta^2}{\\delta^2(1 + \\sqrt{1 - \\delta^2})} = \\frac{1}{1 + \\sqrt{1 - \\delta^2}}$$\n现在，取 $\\delta \\to 0^+$ 的极限：\n$$\\lim_{\\delta \\to 0^+} V_2 = \\frac{1}{1 + \\sqrt{1 - 0}} = \\frac{1}{2}$$\n这个结果是合理的：如果未来的回报毫无价值（$\\delta=0$），最优策略是接受第一个机会 $X_0$。那么期望回报是 $\\mathbb{E}[X_0] = \\int_0^1 x dx = 1/2$。\n此外，对于 $\\delta \\in (0,1)$，我们有 $0 \\le \\sqrt{1-\\delta^2} < 1$，所以 $V_2 = \\frac{1}{1 + \\sqrt{1-\\delta^2}}$ 位于区间 $[1/2, 1)$ 内，满足条件 $V \\le 1$。\n\n因此，正确的价值函数是：\n$$V = \\frac{1 - \\sqrt{1 - \\delta^2}}{\\delta^2}$$\n\n问题要求的是最优接受阈值 $\\tau^{\\ast}$。如前所述，$\\tau^{\\ast} = \\delta V$。\n代入 $V$ 的表达式：\n$$\\tau^{\\ast} = \\delta \\cdot V = \\delta \\left( \\frac{1 - \\sqrt{1 - \\delta^2}}{\\delta^2} \\right)$$\n$$\\tau^{\\ast} = \\frac{1 - \\sqrt{1 - \\delta^2}}{\\delta}$$\n\n这就是最优接受阈值的精确闭式表达式。",
            "answer": "$$\\boxed{\\frac{1 - \\sqrt{1 - \\delta^2}}{\\delta}}$$"
        },
        {
            "introduction": "这个问题将最优性原理应用于一个现代且贴近现实的商业场景：动态定价。与前一个问题不同，这里的决策周期是有限的，并且消费者的“记忆”（即参考价格）使得状态变得更加复杂，因为今天的定价会影响未来的消费者行为。这个练习  要求你使用向后归纳法来计算最优的定价策略，从而揭示当前决策如何通过状态变量影响未来的盈利能力。",
            "id": "2443432",
            "problem": "一家单一产品公司设定跨期价格以最大化贴现利润，其中消费者根据公司最近收取的 $k$ 个价格形成参考价格。时间是离散的，时期由 $t \\in \\{1,2,\\ldots,T\\}$ 索引。在时期 $t$，公司从一个有限的可行集 $\\mathcal{P} = \\{0,1,2,\\ldots,10\\}$ 中选择一个价格 $p_t$。设参考价格为时期 $t$ 之前最后 $k$ 个已实现价格的简单平均值，记为 $r_t = \\frac{1}{k}\\sum_{j=1}^{k} p_{t-j}$，其中样本前历史 $\\left(p_{0},p_{-1},\\ldots,p_{-(k-1)}\\right)$ 是给定的。时期 $t$ 的需求为\n$$\nq_t = \\max\\left\\{0,\\, a - b\\,p_t + \\gamma\\,(r_t - p_t)\\right\\},\n$$\n时期利润为\n$$\n\\pi_t = (p_t - c)\\,q_t.\n$$\n公司的目标是选择序列 $\\{p_t\\}_{t=1}^T$ 以最大化利润的贴现总和\n$$\n\\sum_{t=1}^{T} \\beta^{t-1}\\,\\pi_t,\n$$\n其中 $a>0$、$b>0$、$\\gamma \\ge 0$、$c \\ge 0$、$T \\in \\mathbb{N}$、$k \\in \\mathbb{N}$ 和 $\\beta \\in (0,1]$ 是给定参数。在时期 $t$ 开始时，系统的状态是最后 $k$ 个已实现价格的有序 k 元组 $\\left(p_{t-1},p_{t-2},\\ldots,p_{t-k}\\right)$。状态转移是确定性的：选择 $p_t$ 后，下一个状态变为 $\\left(p_t,p_{t-1},\\ldots,p_{t-k+1}\\right)$。\n\n在多个利润最大化序列中，选择在最早出现平局的时期选择最小可行价格的序列。等价地，在每个时期 $t$ 和每个状态下，如果多个 $p_t \\in \\mathcal{P}$ 产生相同的最大化目标值，则选择其中最小的 $p_t$。\n\n对于下面测试套件中的每个参数化，计算最优价格序列 $\\{p_t^\\star\\}_{t=1}^T$。无物理单位适用。您的程序必须只输出一行，其中包含所有结果，汇总为列表的列表，每个内部列表按时间顺序包含该测试用例的 $T$ 个最优价格，且无空格。例如，输出格式必须严格为以下形式：\n$$\n[[p_1^\\star,\\ldots,p_T^\\star],[\\ldots],\\ldots].\n$$\n\n测试套件：\n- 案例 1 (一般情况)：$T=3$, $k=2$, $a=12$, $b=1.5$, $\\gamma=0.8$, $c=2$, $\\beta=0.95$, 初始历史 $\\left(p_{0},p_{-1}\\right) = (4,6)$, $\\mathcal{P}=\\{0,1,2,\\ldots,10\\}$。\n- 案例 2 (单时期边界)：$T=1$, $k=3$, $a=8$, $b=1$, $\\gamma=0.5$, $c=1$, $\\beta=0.9$, 初始历史 $\\left(p_{0},p_{-1},p_{-2}\\right) = (2,2,2)$, $\\mathcal{P}=\\{0,1,2,\\ldots,10\\}$。\n- 案例 3 (强参考效应，最小记忆)：$T=4$, $k=1$, $a=10$, $b=2$, $\\gamma=2$, $c=3$, $\\beta=0.9$, 初始历史 $\\left(p_{0}\\right) = (5)$, $\\mathcal{P}=\\{0,1,2,\\ldots,10\\}$。\n\n您的程序应生成单行输出，包含结果，格式为三个最优价格序列的逗号分隔列表，每个序列都用方括号括起来且无空格，并按上述案例的顺序排列。例如，要求的输出模式为\n$$\n[[\\cdot,\\cdot,\\cdot],[\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot]].\n$$",
            "solution": "该问题描述了一个有限期、确定性的动态规划问题。公司的目标是找到一个价格序列 $\\{p_t\\}_{t=1}^T$ 来最大化总贴现利润。这个问题可以使用动态规划来解决，为此我们定义其标准组成部分。\n\n1.  **状态**：时期 $t$ 开始时系统的状态必须封装所有与未来决策相关的过去信息。在此模型中，未来利润取决于下一个参考价格，而参考价格又取决于近期的价格历史。因此，时间 $t$ 的状态是最后 $k$ 个价格的有序 k 元组，$S_t = (p_{t-1}, p_{t-2}, \\ldots, p_{t-k})$。状态空间是离散且有限的，由 $|\\mathcal{P}|^k$ 个可能的状态组成，其中 $|\\mathcal{P}| = 11$。\n\n2.  **行动**：在每个时期 $t$，公司选择一个行动，即价格 $p_t$。可行行动集是有限集 $\\mathcal{P} = \\{0, 1, 2, \\ldots, 10\\}$。\n\n3.  **奖励函数**：时期 $t$ 的奖励是利润 $\\pi_t$。该利润取决于当前状态 $S_t$（它决定了参考价格 $r_t$）和所选行动 $p_t$。参考价格为 $r_t = \\frac{1}{k}\\sum_{j=1}^{k} p_{t-j}$。利润函数为 $\\pi_t(S_t, p_t) = (p_t - c)q_t$，其中需求为 $q_t = \\max\\{0, a - bp_t + \\gamma(r_t - p_t)\\}$。这可以重写为 $q_t = \\max\\{0, a + \\gamma r_t - (b+\\gamma)p_t\\}$。\n\n4.  **状态转移**：系统是确定性的。如果时间 $t$ 的状态是 $S_t = (p_{t-1}, \\ldots, p_{t-k})$ 且公司选择价格 $p_t$，则时间 $t+1$ 的状态变为 $S_{t+1} = (p_t, p_{t-1}, \\ldots, p_{t-k+1})$。\n\n设 $V_t(S_t)$ 为从时期 $t$ 到期界 $T$ 末尾的最大贴现利润，给定状态为 $S_t$。最优性原理通过 Bellman 方程表示：\n$$\nV_t(S_t) = \\max_{p_t \\in \\mathcal{P}} \\left\\{ \\pi_t(S_t, p_t) + \\beta V_{t+1}(S_{t+1}) \\right\\}\n$$\n对于 $t=1, \\ldots, T$。终端条件是在时期 $T$ 之后没有未来利润，因此对于任何状态 $S$，都有 $V_{T+1}(S) = 0$。\n\n该问题通过使用逆向归纳法在算法上求解：\n\n1.  **初始化 (时期 $t=T$)：** 我们从最后一个时期 $T$ 开始。对于每个可能的状态 $S_T = (p_{T-1}, \\ldots, p_{T-k})$，我们求解最优价格 $p_T^*(S_T)$：\n    $$\n    V_T(S_T) = \\max_{p_T \\in \\mathcal{P}} \\{ \\pi_T(S_T, p_T) \\}\n    $$\n    我们计算每个 $p_T \\in \\mathcal{P}$ 的利润，并找到产生最大利润的价格。平局打破规则规定，如果多个价格产生相同的最大值，我们必须选择最小的价格。我们将此最优价格存储在策略函数 $\\Pi_T(S_T) = p_T^*(S_T)$ 中，并将相应的最大值存储在价值函数 $V_T(S_T)$ 中。对状态空间中的所有可能状态都执行此操作。\n\n2.  **递归步骤 (时期 $t = T-1, \\ldots, 1$)：** 我们一次向后退一个时期。对于每个时期 $t$ 和每个状态 $S_t$，我们通过求解 Bellman 方程来找到最优价格 $p_t^*(S_t)$：\n    $$\n    V_t(S_t) = \\max_{p_t \\in \\mathcal{P}} \\left\\{ \\pi_t(S_t, p_t) + \\beta V_{t+1}((p_t, p_{t-1}, \\ldots, p_{t-k+1})) \\right\\}\n    $$\n    对于每个候选价格 $p_t \\in \\mathcal{P}$，我们计算即时利润 $\\pi_t(S_t, p_t)$ 并加上贴现未来价值 $\\beta V_{t+1}(S_{t+1})$，其中未来价值 $V_{t+1}$ 已在归纳法的前一步中计算得出。最大化此总和的价格 $p_t$ 被选为最优策略 $\\Pi_t(S_t)$，同样要遵守平局打破规则。最大化的总和存储为 $V_t(S_t)$。\n\n3.  **最优路径重构：** 在逆向归纳完成后，我们得到了所有 $t \\in \\{1, \\ldots, T\\}$ 和所有状态 $S_t$ 的最优策略 $\\Pi_t(S_t)$。为了找到最优价格序列，我们执行一次前向传递：\n    -   从给定的初始状态 $S_1 = (p_0, p_{-1}, \\ldots, p_{-(k-1)})$ 开始。\n    -   第一个最优价格是 $p_1^* = \\Pi_1(S_1)$。\n    -   下一时期的状态是 $S_2 = (p_1^*, p_0, \\ldots, p_{-(k-2)})$。\n    -   第二个最优价格是 $p_2^* = \\Pi_2(S_2)$。\n    -   重复此过程直到 $t=T$，得到最优价格序列 $\\{p_1^*, p_2^*, \\ldots, p_T^*\\}$。\n\n该算法通过使用字典将状态元组映射到其价值和最优策略来实现。每个时期的有限状态空间是通过将可行价格集 $\\mathcal{P}$ 与自身进行 $k$ 次笛卡尔积生成的。",
            "answer": "```python\nimport numpy as np\nfrom itertools import product\n\ndef solve():\n    \"\"\"\n    Main function to solve the dynamic pricing problem for all test cases\n    and print the results in the specified format.\n    \"\"\"\n\n    def solve_case(T, k, a, b, gamma, c, beta, initial_history):\n        \"\"\"\n        Solves a single instance of the dynamic pricing problem using backward induction.\n        \"\"\"\n        P_set = list(range(11))\n        \n        # The state is a tuple of the last k prices.\n        # Handle k=0 case for generality, though problem states k >= 1.\n        all_states = list(product(P_set, repeat=k)) if k > 0 else [()]\n        \n        # V: Value function memoization table, V[t][state] = max_profit\n        # policy: Policy function table, policy[t][state] = optimal_price\n        V = {}\n        policy = {}\n\n        # Initialize value function at the terminal time T+1 to zero.\n        V[T + 1] = {s: 0.0 for s in all_states}\n\n        # Backward induction from T down to 1\n        for t in range(T, 0, -1):\n            V[t] = {}\n            policy[t] = {}\n            for state in all_states:\n                # state = (p_{t-1}, ..., p_{t-k})\n                r_t = np.mean(state) if k > 0 else 0.0\n                \n                # Evaluate the value for each possible price p_t\n                p_values = {}\n                for p_t in P_set:\n                    q_t = max(0, a + gamma * r_t - (b + gamma) * p_t)\n                    profit_t = (p_t - c) * q_t\n                    \n                    next_state = (p_t,) + state[:-1] if k > 0 else ()\n                    \n                    # Bellman equation\n                    value = profit_t + beta * V[t + 1][next_state]\n                    p_values[p_t] = value\n                \n                # Find the maximum value among all possible prices\n                max_value = -float('inf')\n                for p_t in P_set:\n                    if p_values[p_t] > max_value:\n                        max_value = p_values[p_t]\n\n                # Find the smallest price that achieves the maximum value (tie-breaking)\n                best_p = -1\n                for p_t in P_set:\n                    if np.isclose(p_values[p_t], max_value):\n                        best_p = p_t\n                        break\n                \n                V[t][state] = max_value\n                policy[t][state] = best_p\n\n        # Forward pass to reconstruct the optimal price path\n        optimal_path = []\n        current_state = initial_history\n        for t in range(1, T + 1):\n            optimal_p = policy[t][current_state]\n            optimal_path.append(optimal_p)\n            current_state = (optimal_p,) + current_state[:-1] if k > 0 else ()\n\n        return optimal_path\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'T': 3, 'k': 2, 'a': 12, 'b': 1.5, 'gamma': 0.8, 'c': 2, 'beta': 0.95, 'initial_history': (4, 6)},\n        {'T': 1, 'k': 3, 'a': 8, 'b': 1, 'gamma': 0.5, 'c': 1, 'beta': 0.9, 'initial_history': (2, 2, 2)},\n        {'T': 4, 'k': 1, 'a': 10, 'b': 2, 'gamma': 2, 'c': 3, 'beta': 0.9, 'initial_history': (5,)},\n    ]\n\n    results = []\n    for params in test_cases:\n        result = solve_case(**params)\n        results.append(result)\n\n    # Format the output string exactly as required, with no spaces.\n    formatted_results = [f\"[{','.join(map(str, r))}]\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "本练习模拟了在资源约束下的最优路径规划问题，这是经济学和运筹学中的一个共同主题。挑战在于，如何在管理有限资源（如燃料或氧气）的同时，找到一条成本最低的路径。这个练习  将凸显动态规划的一个关键思想：为了应用最优性原理，必须正确定义“状态”，使其不仅包含物理位置，还需囊括资源水平，从而将一个复杂的约束问题转化为一个可在扩展图上求解的最短路径问题。",
            "id": "2443368",
            "problem": "一辆交通工具必须在离散网格上确定一条最优路径，以最小化一个累加的能量准则，同时满足一个累积的氧气资源约束。所有量均为无量纲标量。环境是一个矩形网格，索引为 $(i,j)$，其中 $i \\in \\{0,\\dots,N-1\\}$ 且 $j \\in \\{0,\\dots,M-1\\}$，每个网格单元都有一个非负的深度值 $D_{i,j}$。从任何单元格 $(i,j)$ 出发，交通工具可以单步离散地移动到其四个轴对齐的邻居 $(i \\pm 1,j)$ 或 $(i,j \\pm 1)$ 中的任何一个，前提是该邻居仍在网格内。从 $(i,j)$ 到邻居 $(i',j')$ 的一步会产生能量成本 $c_{E}(i',j') = \\alpha + \\beta \\, D_{i',j'}$ 和氧气消耗 $c_{O}(i',j') = \\mu + \\nu \\, D_{i',j'}$，其中 $\\alpha,\\beta,\\mu,\\nu$ 是给定的非负参数。路径是网格单元的有限序列 $(x_{0},x_{1},\\dots,x_{L})$，其中 $x_{0} = s$ (起点) 且 $x_{L} = g$ (终点)，每个 $x_{\\ell+1}$ 都是 $x_{\\ell}$ 的有效邻居。目标是最小化总能量 $\\sum_{\\ell=0}^{L-1} c_{E}(x_{\\ell+1})$，同时满足氧气约束 $\\sum_{\\ell=0}^{L-1} c_{O}(x_{\\ell+1}) \\leq O_{\\max}$，其中 $O_{\\max}$ 是一个给定的非负整数。如果不存在可行路径，则该实例无解。\n\n形式上，给定 $D \\in \\mathbb{R}_{\\ge 0}^{N \\times M}$、参数 $\\alpha,\\beta,\\mu,\\nu \\in \\mathbb{R}_{\\ge 0}$、整数氧气预算 $O_{\\max} \\in \\mathbb{Z}_{\\ge 0}$ 以及网格坐标 $s=(i_{s},j_{s})$、$g=(i_{g},j_{g})$，计算最小能量值\n$$\nE^{\\star} \\;=\\; \\min_{(x_{0},\\dots,x_{L})} \\;\\sum_{\\ell=0}^{L-1} \\big(\\alpha + \\beta \\, D_{x_{\\ell+1}}\\big)\n\\quad\\text{subject to}\\quad x_{0}=s,\\; x_{L}=g,\\; x_{\\ell+1}\\in \\mathcal{N}(x_{\\ell}),\n\\;\\sum_{\\ell=0}^{L-1} \\big(\\mu + \\nu \\, D_{x_{\\ell+1}}\\big) \\le O_{\\max},\n$$\n其中 $\\mathcal{N}(i,j)=\\{(i\\pm 1,j),(i,j\\pm 1)\\}$ 与网格的交集，并且 $D_{x}$ 表示在单元格 $x$ 处计算的 $D$ 值。如果不存在可行路径，则定义 $E^{\\star}=+\\infty$。\n\n您的程序必须解决以下测试套件中的实例，并输出一行，其中包含每个实例的最小能量列表，格式为浮点数，使用 $+\\infty$ 表示不可行性：\n\n- 测试用例 $\\mathbf{A}$：\n  - 网格大小 $N = 4$，$M = 4$，深度矩阵为\n    $$\n    D^{(A)} \\;=\\;\n    \\begin{bmatrix}\n    4  3  4  5\\\\\n    5  2  2  3\\\\\n    6  4  1  2\\\\\n    7  5  3  1\n    \\end{bmatrix}.\n    $$\n  - 参数：$\\alpha = 1$，$\\beta = 1$，$\\mu = 1$，$\\nu = 0$。\n  - 起点 $s=(0,0)$，终点 $g=(3,3)$，氧气预算 $O_{\\max}=7$。\n\n- 测试用例 $\\mathbf{B}$：与测试用例 $\\mathbf{A}$ 相同，但氧气预算 $O_{\\max}=6$。\n\n- 测试用例 $\\mathbf{C}$：与测试用例 $\\mathbf{A}$ 相同，但氧气预算 $O_{\\max}=5$。\n\n- 测试用例 $\\mathbf{D}$：\n  - 网格大小 $N = 4$，$M = 4$，深度矩阵为\n    $$\n    D^{(D)} \\;=\\;\n    \\begin{bmatrix}\n    5  5  5  5\\\\\n    5  1  1  5\\\\\n    5  1  5  5\\\\\n    5  1  1  1\n    \\end{bmatrix}.\n    $$\n  - 参数：$\\alpha = 1$，$\\beta = 2$，$\\mu = 1$，$\\nu = 1$。\n  - 起点 $s=(0,0)$，终点 $g=(3,3)$，氧气预算 $O_{\\max}=24$。\n\n输出格式要求：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，顺序为 $\\mathbf{A},\\mathbf{B},\\mathbf{C},\\mathbf{D}$，例如 \"$[e_{A},e_{B},e_{C},e_{D}]$\"，其中每个 $e_{\\cdot}$ 是一个浮点数，不可行性由浮点常数 $+\\infty$ 表示。",
            "solution": "该问题是在一个网格中寻找一条路径，该路径在满足第二个累积成本（氧气）的上限约束条件下，最小化第一个累积成本（能量）。这是约束最短路径问题的一个经典实例。虽然 CSPP 在一般情况下是 NP-难问题，但所提供测试用例中氧气成本的整数性质允许使用动态规划得到一个伪多项式时间的解法，这是最优性原理的一种体现。\n\n最优性原理指出，一个最优策略具有这样的性质：无论初始状态和初始决策是什么，其余的决策都必须构成一个相对于由第一个决策导致的状态的最优策略。在我们的情境中，到达单元格 $(i,j)$ 且消耗了一定氧气的最优路径，是由到达某个相邻单元格且消耗了相应更少氧气的最优路径，再加上一个最优的单步移动组成的。\n\n这表明我们系统中的状态不能仅由网格位置 $(i,j)$ 来定义。到达 $(i,j)$ 所经过的路径很重要，因为它决定了消耗的氧气量。因此，我们扩展状态以包括已消耗的资源。我们将一个状态表示为元组 $(i, j, o)$，表示交通工具位于单元格 $(i,j)$，并且已消耗了 $o$ 单位的氧气。\n\n令 $E[i, j, o]$ 为到达状态 $(i,j,o)$ 所需的最小能量。我们的目标是计算 $\\min_{0 \\le o \\le O_{\\max}} E[i_g, j_g, o]$，其中 $(i_g, j_g)$ 是终点单元格 $g$ 的坐标。\n\n我们可以通过调整 Dijkstra 算法来解决此问题，在扩展的状态空间图上寻找最短路径。该图的节点是状态 $(i, j, o)$，路径的“长度”是其总能量成本。\n\n算法流程如下：\n1.  **初始化**：我们使用一个三维数组 `min_energy[N][M][O_max + 1]` 来存储每个状态的最小能量 $E[i, j, o]$。所有条目都初始化为 $+\\infty$。对于起始单元格 $s=(i_s, j_s)$，我们设置 `min_energy[i_s][j_s][0] = 0$，因为到达起点需要零能量，消耗零氧气。初始化一个优先队列 `pq`，包含起始状态：`(energy=0, i=i_s, j=j_s, oxygen=0)`。\n\n2.  **迭代**：算法反复从优先队列中提取具有最小能量 $e$ 的状态 $(e, i, j, o)$。如果这个能量 $e$ 大于已知的到达状态 $(i,j,o)$ 的最小能量，我们将其丢弃，因为它代表一个次优路径。否则，我们探索单元格 $(i,j)$ 的所有有效邻居 $(i', j')$。\n\n3.  **状态转移（松弛）**：对于每个邻居 $(i', j')$，我们计算增量成本：\n    - 能量成本：$\\Delta E = \\alpha + \\beta D_{i',j'}$\n    - 氧气成本：$\\Delta O = \\mu + \\nu D_{i',j'}$\n    新状态将是 $(i', j', o + \\Delta O)$，总能量为 $e + \\Delta E$。\n\n4.  **约束与更新**：我们检查新的总氧气 $o' = o + \\Delta O$ 是否超过预算 $O_{\\max}$。如果超过，此路径不可行，将被忽略。否则，如果新的总能量 $e' = e + \\Delta E$ 小于 `min_energy[i'][j'][o']` 的当前值，我们就找到了到达状态 $(i', j', o')$ 的一条更优路径。我们更新 `min_energy[i'][j'][o'] = e'$ 并将新状态 $(e', i', j', o')$ 添加到优先队列中。\n\n5.  **终止与结果**：当优先队列为空时，算法终止。到达终点单元格 $g=(i_g, j_g)$ 的最小能量是 `min_energy[i_g][j_g][o]` 在所有可能的氧气水平 $o \\in \\{0, \\dots, O_{\\max}\\}$ 上的最小值。如果该最小值仍为 $+\\infty$，则表示在给定的氧气预算内无法到达终点。\n\n该算法的计算复杂度由扩展状态空间上的 Dijkstra 算法决定。状态数为 $N \\times M \\times (O_{\\max} + 1)$，每个状态最多有 4 个转移。复杂度为 $O(N \\cdot M \\cdot O_{\\max} \\cdot \\log(N \\cdot M \\cdot O_{\\max}))$，对于所提供测试用例的规模而言是高效的。",
            "answer": "```python\nimport numpy as np\nimport heapq\n\ndef solve():\n    \"\"\"\n    Main function to define, solve, and print results for all test cases.\n    \"\"\"\n\n    def solve_case(N, M, D, alpha, beta, mu, nu, s, g, O_max):\n        \"\"\"\n        Solves a single instance of the constrained shortest path problem.\n\n        This function uses a Dijkstra-like algorithm on an expanded state space,\n        where a state is defined by (row, column, oxygen_consumed). The priority\n        queue stores tuples of (energy, row, col, oxygen), ordered by energy.\n        \"\"\"\n        # min_energy[i, j, o] stores the minimum energy to reach cell (i, j)\n        # having consumed exactly 'o' units of oxygen.\n        min_energy = np.full((N, M, O_max + 1), np.inf, dtype=np.float64)\n\n        start_i, start_j = s\n        goal_i, goal_j = g\n\n        # Initial state: at the start cell with 0 energy and 0 oxygen consumed.\n        min_energy[start_i, start_j, 0] = 0.0\n        \n        # Priority queue stores tuples of (energy, i, j, oxygen_consumed).\n        # It's ordered by energy to always expand the path with the lowest energy first.\n        pq = [(0.0, start_i, start_j, 0)]\n\n        while pq:\n            energy, i, j, o = heapq.heappop(pq)\n\n            # If we've already found a better path to this state, skip.\n            if energy > min_energy[i, j, o]:\n                continue\n\n            # Explore the four axis-aligned neighbors.\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                ni, nj = i + di, j + dj\n\n                # Check if the neighbor is within the grid boundaries.\n                if 0 = ni  N and 0 = nj  M:\n                    # Costs are incurred upon entering the new cell (ni, nj).\n                    energy_step = alpha + beta * D[ni, nj]\n                    oxygen_step = mu + nu * D[ni, nj]\n\n                    # For this problem, oxygen costs are guaranteed to be integers.\n                    oxygen_step_int = int(oxygen_step)\n\n                    new_energy = energy + energy_step\n                    new_oxygen = o + oxygen_step_int\n\n                    # If the path is feasible (within oxygen budget) and improves\n                    # upon a known path to the new state, update and push to queue.\n                    if new_oxygen = O_max:\n                        if new_energy  min_energy[ni, nj, new_oxygen]:\n                            min_energy[ni, nj, new_oxygen] = new_energy\n                            heapq.heappush(pq, (new_energy, ni, nj, new_oxygen))\n\n        # The final minimum energy is the minimum over all possible oxygen\n        # levels at the goal cell.\n        result = np.min(min_energy[goal_i, goal_j, :])\n        return float(result)\n\n    # Test Case A\n    D_A = np.array([[4, 3, 4, 5], [5, 2, 2, 3], [6, 4, 1, 2], [7, 5, 3, 1]])\n    params_A = (1, 1, 1, 0)\n    s_A, g_A = (0, 0), (3, 3)\n    O_max_A = 7\n    res_A = solve_case(4, 4, D_A, *params_A, s_A, g_A, O_max_A)\n\n    # Test Case B (identical to A, but O_max = 6)\n    O_max_B = 6\n    res_B = solve_case(4, 4, D_A, *params_A, s_A, g_A, O_max_B)\n\n    # Test Case C (identical to A, but O_max = 5)\n    O_max_C = 5\n    res_C = solve_case(4, 4, D_A, *params_A, s_A, g_A, O_max_C)\n\n    # Test Case D\n    D_D = np.array([[5, 5, 5, 5], [5, 1, 1, 5], [5, 1, 5, 5], [5, 1, 1, 1]])\n    params_D = (1, 2, 1, 1)\n    s_D, g_D = (0, 0), (3, 3)\n    O_max_D = 24\n    res_D = solve_case(4, 4, D_D, *params_D, s_D, g_D, O_max_D)\n\n    results = [res_A, res_B, res_C, res_D]\n    \n    # Format the final output as a comma-separated list in brackets.\n    # The `str` function correctly handles `np.inf` by converting it to 'inf'.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}