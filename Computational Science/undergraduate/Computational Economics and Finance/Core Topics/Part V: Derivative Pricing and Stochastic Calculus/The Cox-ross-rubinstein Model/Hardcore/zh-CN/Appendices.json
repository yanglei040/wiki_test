{
    "hands_on_practices": [
        {
            "introduction": "Cox-Ross-Rubinstein 模型的核心在于无套利原理和完美复制思想，即在无摩擦市场中，任何衍生品的收益都可以通过动态交易标的资产和无风险资产的投资组合来精确复制。这个练习将让你亲手验证这一关键理论。你将为一个卖出的看涨期权实施一个动态的 Delta 对冲策略，并在一个具体的资产价格路径上追踪投资组合的价值，通过计算每一步的对冲误差，你将直观地理解自融资策略如何确保在理论上实现零误差的完美复制 。",
            "id": "2412792",
            "problem": "给定一个离散时间、多周期的二项资产定价模型。设标的资产价格过程 $\\{S_{t}\\}_{t=0}^{N}$ 服从乘法动态，即在每个周期内，价格要么上涨一个因子 $u$，要么下跌一个因子 $d$，其中 $u>d>0$。每个周期的无风险总回报率为 $R$，且满足无套利条件 $d<R<u$。考虑一个基于该资产的欧式看涨期权，其执行价格为 $K$，到期时间步为 $N$。令 $C_{t}$ 表示在给定节点时期权在时间 $t$ 的唯一无套利价值，该价值在风险中性测度下计算得出，其中概率 $q=(R-d)/(u-d)$，终端条件为 $C_{N}=\\max(S_{N}-K,0)$。在每个非终端节点，定义局部 Delta 为复制投资组合中的股票数量，\n$$\n\\Delta_{t}=\\frac{C_{t+1}^{(u)}-C_{t+1}^{(d)}}{S_{t+1}^{(u)}-S_{t+1}^{(d)}},\n$$\n其中上标表示在上涨或下跌子节点中的价值。\n\n一个交易员在时间 $0$ 卖空一个单位的看涨期权，收到期权费 $C_{0}$，并通过持有 $\\Delta_{t}$ 份股票和风险中性账户头寸 $B_{t}$ 来动态对冲该空头头寸。交易无交易成本并满足自融资约束。初始对冲满足 $B_{0}=C_{0}-\\Delta_{0}S_{0}$。沿着一条长度为 $N$ 的已实现价格路径，令周期 $t$ 结束时的再平衡前对冲误差为\n$$\ne_{t}=\\Delta_{t-1}S_{t}+B_{t-1}R-C_{t},\\quad t=1,2,\\dots,N,\n$$\n其中 $C_{t}$ 是在时间 $t$ 到达的节点上的期权价值，且 $C_{N}=\\max(S_{N}-K,0)$。在测量 $e_{t}$ 之后，于时间 $t$（$t=1,2,\\dots,N-1$）将对冲头寸再平衡至 $\\Delta_{t}$。\n\n您的任务是实现一个程序，对于每个给定的参数集和已实现路径，该程序需要构建二项价格树，计算期权价值树，执行上述定义的看涨期权空头的动态 Delta 对冲策略，并返回沿该路径的序列 $\\{e_{t}\\}_{t=1}^{N}$。所有数值必须以小数形式表示（无百分号），且每个 $e_{t}$ 必须四舍五入到 $10$ 位小数。\n\n测试套件。对于以下每个案例，请使用所提供的参数和已实现的上涨/下跌移动路径，其中 $U$ 表示上涨一个因子 $u$，$D$ 表示下跌一个因子 $d$：\n- 案例 $1$ (一般多周期路径): $S_{0}=100.0$, $u=1.1$, $d=0.9$, $R=1.02$, $K=100.0$, $N=4$, 路径 $[U,D,U,U]$。\n- 案例 $2$ (边界，单周期): $S_{0}=50.0$, $u=1.2$, $d=0.8$, $R=1.0$, $K=50.0$, $N=1$, 路径 $[U]$。\n- 案例 $3$ (边缘，零利率且全为下跌): $S_{0}=80.0$, $u=1.25$, $d=0.8$, $R=1.0$, $K=90.0$, $N=3$, 路径 $[D,D,D]$。\n- 案例 $4$ (边缘，深度价内且全为上涨): $S_{0}=100.0$, $u=1.2$, $d=0.8$, $R=1.01$, $K=80.0$, $N=3$, 路径 $[U,U,U]$。\n\n要求的最终输出格式。您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。此列表的每个元素都必须是对应测试案例的四舍五入后的对冲误差列表 $[e_{1},e_{2},\\dots,e_{N}]$。例如，包含两个案例的输出应如下所示：$[[e_{1}^{(1)},\\dots,e_{$N_1$}^{(1)}],[e_{1}^{(2)},\\dots,e_{$N_2$}^{(2)}]]$，该行中任何地方都不能有空格。",
            "solution": "问题陈述需要进行验证。\n\n给定的条件逐字提取如下：\n- 资产价格过程：$\\{S_{t}\\}_{t=0}^{N}$ 服从乘法二项模型。\n- 上涨因子：$u$。下跌因子：$d$。其中 $u > d > 0$。\n- 每个周期的无风险总回报率：$R$。\n- 无套利条件：$d < R < u$。\n- 衍生品：欧式看涨期权，执行价格 $K$，到期时间 $N$。\n- 期权价值：在时间 $t$ 的价值为 $C_{t}$。\n- 终端条件：$C_{N} = \\max(S_{N}-K, 0)$。\n- 风险中性上涨概率：$q = \\frac{R-d}{u-d}$。\n- 期权定价：在风险中性测度下，意味着 $C_{t} = R^{-1}[q C_{t+1}^{(u)} + (1-q) C_{t+1}^{(d)}]$。\n- 复制投资组合的 Delta：$\\Delta_{t}=\\frac{C_{t+1}^{(u)}-C_{t+1}^{(d)}}{S_{t+1}^{(u)}-S_{t+1}^{(d)}}$。\n- 对冲策略：卖空一个看涨期权，用 $\\Delta_{t}$ 份股票和一个无风险账户头寸 $B_{t}$ 进行对冲。\n- 初始对冲：$B_{0}=C_{0}-\\Delta_{0}S_{0}$。\n- 再平衡前对冲误差：$e_{t}=\\Delta_{t-1}S_{t}+B_{t-1}R-C_{t}$，对于 $t=1, 2, \\dots, N$。\n- 再平衡：在自融资约束下，于时间 $t$（$t=1, 2, \\dots, N-1$）将对冲头寸再平衡至 $\\Delta_{t}$。\n- 测试案例：提供了四组特定的参数（$S_{0}, u, d, R, K, N$）和已实现路径。\n- 输出要求：对于每个案例，输出一个包含对冲误差 $\\{e_{t}\\}_{t=1}^{N}$ 的列表的列表，结果四舍五入到 10 位小数。\n\n验证结论：问题有效。\n该问题具有科学依据，是 Cox-Ross-Rubinstein 二项期权定价模型中的一个标准练习，这是计算金融学中的一个基本概念。该问题是适定的；所有参数、定义和约束都已提供，确保可以通过计算确定唯一的解。期权价值、风险中性概率和 delta 的定义是标准且正确的。问题是客观的，不包含任何歧义。无套利条件被正确陈述，并且测试案例均满足该条件。问题的核心是验证二项模型的核心论点：即衍生品的支付可以通过对标的资产和无风险债券的动态、自融资交易策略来完美复制。因此，根据定义，对冲误差在所有时间步上理论上应为零，任何非零结果仅可归因于浮点数计算精度问题。\n\n现在给出一个完整的解决方案。该方法论建立在离散时间资产定价的基本原则之上。\n\n首先，我们为标的资产价格构建二项格 $\\{S_{t}\\}_{t=0}^{N}$。在时间步 $i$（$0 \\le i \\le N$）经过 $j$ 次上涨（$0 \\le j \\le i$）后的树中节点，其价格由以下公式给出：\n$$S_{i,j} = S_{0} u^{j} d^{i-j}$$\n\n其次，我们确定树中每个节点的期权价值。这是通过从到期日 $t=N$ 的已知期权价值开始进行后向归纳来完成的。欧式看涨期权在到期日的价值是其内在价值：\n$$C_{N,j} = \\max(S_{N,j} - K, 0) \\quad \\text{for } j = 0, 1, \\dots, N$$\n对于任何 $i < N$ 的非终端节点 $(i,j)$，无套利期权价值 $C_{i,j}$ 是在风险中性测度下计算的下一周期期权的贴现期望值。风险中性上涨概率为 $q = \\frac{R-d}{u-d}$。估值公式为：\n$$C_{i,j} = \\frac{1}{R} \\left[ q C_{i+1,j+1} + (1-q) C_{i+1,j} \\right]$$\n这种后向递归计算填充了整个期权价值树 $\\{C_{i,j}\\}$。\n\n第三，我们沿着指定的资产价格移动路径执行动态对冲策略。该策略包括创建一个由 $\\Delta_{t}$ 份资产股票和无风险账户中的现金头寸 $B_{t}$ 组成的投资组合。该投资组合在时间 $t$ 的价值为 $V_t = \\Delta_t S_t + B_t$。\n\n该策略在 $t=0$ 时启动。初始投资组合的构建是为了复制期权的价值，$V_0 = C_0$。股票数量 $\\Delta_0$ 由 delta 对冲公式给出：\n$$\\Delta_{0} = \\frac{C_{1,1} - C_{1,0}}{S_{1,1} - S_{1,0}}$$\n然后设置初始现金头寸 $B_0$，以确保投资组合价值与期权价值匹配：$B_{0} = C_{0,0} - \\Delta_{0}S_{0,0}$。\n\n该投资组合是自融资的。这意味着对于任何后续周期 $t > 0$，投资组合构成的任何变化都由内部融资，没有外部现金注入或提取。在一个周期 $t$ 的开始（在价格从 $t-1$ 移动之后），前一周期投资组合 $(\\Delta_{t-1}, B_{t-1})$ 的价值演变为：\n$$V_{t}^{-} = \\Delta_{t-1}S_{t} + B_{t-1}R$$\n问题将时间 $t$ 的对冲误差定义为该投资组合价值与新节点上的理论期权价格 $C_{t}$ 之间的差额：\n$$e_{t} = V_{t}^{-} - C_{t}$$\n二项模型的一个核心结果是，复制投资组合的价值 $V_{t}^{-}$ 在每个节点都将精确匹配期权的价值 $C_{t}$。因此，我们预期对于所有 $t$，$e_t = 0$，除非受限于数值精度。\n\n计算误差后，为下一周期（如果 $t < N$）对投资组合进行再平衡。新的股票数量 $\\Delta_t$ 是根据当前节点的后继价值计算的：\n$$\\Delta_{t} = \\frac{C_{t+1}^{\\text{(up)}} - C_{t+1}^{\\text{(down)}}}{S_{t+1}^{\\text{(up)}} - S_{t+1}^{\\text{(down)}}}$$\n新的现金头寸 $B_t$ 由自融资条件确定。在再平衡过程中，投资组合的价值保持不变，因此再平衡后的价值 $V_t^{+} = \\Delta_t S_t + B_t$ 必须等于再平衡前的价值 $V_t^{-}$。因此，新的现金头寸是：\n$$B_{t} = V_{t}^{-} - \\Delta_{t}S_{t}$$\n这个沿着路径移动、计算对冲误差和再平衡的过程会一直重复，直到到期日 $t=N$。计算出的误差序列 $\\{e_t\\}_{t=1}^N$ 是给定路径的最终结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n\n    test_cases = [\n        {'S0': 100.0, 'u': 1.1, 'd': 0.9, 'R': 1.02, 'K': 100.0, 'N': 4, 'path': ['U', 'D', 'U', 'U']},\n        {'S0': 50.0, 'u': 1.2, 'd': 0.8, 'R': 1.0, 'K': 50.0, 'N': 1, 'path': ['U']},\n        {'S0': 80.0, 'u': 1.25, 'd': 0.8, 'R': 1.0, 'K': 90.0, 'N': 3, 'path': ['D', 'D', 'D']},\n        {'S0': 100.0, 'u': 1.2, 'd': 0.8, 'R': 1.01, 'K': 80.0, 'N': 3, 'path': ['U', 'U', 'U']}\n    ]\n\n    results = []\n    for case in test_cases:\n        errors = _calculate_hedging_errors(\n            S0=case['S0'],\n            u=case['u'],\n            d=case['d'],\n            R=case['R'],\n            K=case['K'],\n            N=case['N'],\n            path=case['path']\n        )\n        results.append(errors)\n    \n    # Format the final output string precisely as required.\n    inner_parts = []\n    for err_list in results:\n        # Format each error to a string with the required precision.\n        # Although the errors are theoretically zero, they may be small non-zero floats.\n        # We ensure standard float representation e.g. '0.0' instead of '0'\n        # The rounding is already done, this is for formatting.\n        formatted_list = [f\"{err:.10f}\".rstrip('0').rstrip('.') if err != 0 else '0.0' for err in err_list]\n        inner_parts.append(f\"[{','.join(formatted_list)}]\")\n        \n    final_output = f\"[{','.join(inner_parts)}]\"\n    print(final_output)\n\ndef _calculate_hedging_errors(S0: float, u: float, d: float, R: float, K: float, N: int, path: list[str]) -> list[float]:\n    \"\"\"\n    Calculates the sequence of dynamic hedging errors for a given path.\n\n    Args:\n        S0: Initial asset price.\n        u: Up-move factor.\n        d: Down-move factor.\n        R: Gross risk-free return per period.\n        K: Option strike price.\n        N: Number of periods to maturity.\n        path: A list of 'U' or 'D' strings representing the realized path.\n\n    Returns:\n        A list of hedging errors {e_t} for t=1,...,N, rounded to 10 decimal places.\n    \"\"\"\n    # 1. Construct asset price and option value trees\n    # Risk-neutral probability\n    q = (R - d) / (u - d)\n\n    # Initialize trees\n    S_tree = np.zeros((N + 1, N + 1))\n    C_tree = np.zeros((N + 1, N + 1))\n\n    # Populate asset price tree S[i,j] = price at time i after j up-moves\n    for i in range(N + 1):\n        for j in range(i + 1):\n            S_tree[i, j] = S0 * (u**j) * (d**(i - j))\n\n    # Populate option value tree at maturity (t=N)\n    C_tree[N, :] = np.maximum(S_tree[N, :] - K, 0)\n\n    # Populate option value tree by backward induction\n    for i in range(N - 1, -1, -1):\n        for j in range(i + 1):\n            C_up = C_tree[i + 1, j + 1]\n            C_down = C_tree[i + 1, j]\n            C_tree[i, j] = (q * C_up + (1 - q) * C_down) / R\n\n    # 2. Trace the path and compute hedging errors\n    hedging_errors = []\n    \n    # Initial portfolio setup at t=0\n    num_ups = 0  # number of up moves from t=0\n    \n    # Initial delta (Delta_0)\n    delta_prev = (C_tree[1, 1] - C_tree[1, 0]) / (S_tree[1, 1] - S_tree[1, 0])\n    \n    # Initial bond position (B_0)\n    B_prev = C_tree[0, 0] - delta_prev * S_tree[0, 0]\n\n    # Iterate along the path from t=1 to N\n    for t in range(1, N + 1):\n        # Determine current node based on path\n        move = path[t - 1]\n        if move == 'U':\n            num_ups += 1\n        \n        # Current asset and option values at node (t, num_ups)\n        current_S = S_tree[t, num_ups]\n        current_C = C_tree[t, num_ups]\n        \n        # Value of hedge portfolio before rebalancing\n        portfolio_val_pre_rebalance = delta_prev * current_S + B_prev * R\n        \n        # Calculate hedging error e_t\n        error = portfolio_val_pre_rebalance - current_C\n        hedging_errors.append(round(error, 10))\n\n        # Rebalance the portfolio for the next period (if not at maturity)\n        if t < N:\n            # Calculate new delta (Delta_t) at the current node\n            delta_curr = (C_tree[t + 1, num_ups + 1] - C_tree[t + 1, num_ups]) / \\\n                         (S_tree[t + 1, num_ups + 1] - S_tree[t + 1, num_ups])\n            \n            # Calculate new bond position (B_t) to maintain self-financing\n            # New portfolio value V_t+ must equal V_t-\n            B_curr = portfolio_val_pre_rebalance - delta_curr * current_S\n            \n            # Update portfolio for the next iteration\n            delta_prev = delta_curr\n            B_prev = B_curr\n\n    return hedging_errors\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "掌握了基本复制原理后，我们可以将其应用于更复杂的金融工具，这正是理论模型的威力所在。这个练习挑战你为一种“远期生效”欧式看涨期权 (forward-start European call option) 定价，其特殊之处在于执行价格 $K$ 是在未来某个时刻 $m$ 才被设定为当时的资产价格 $S_m$。你需要从鞅定价和风险中性期望等第一性原理出发，推导出该期权的定价算法，这能锻炼你将核心理论灵活应用于非标准金融产品的分析和解决能力 。",
            "id": "2439216",
            "problem": "考虑无套利情况下的 Cox–Ross–Rubinstein (CRR) 二叉树资产定价模型。一个资产价格过程 $\\{S_n\\}_{n=0}^{N}$ 在 $N$ 个离散时期内演变，其中每一步资产价格要么上涨一个因子 $u$，要么下跌一个因子 $d$，因此 $S_{n+1} \\in \\{u S_n, d S_n\\}$。每期的无风险总回报率为 $R$，假设其不随时间变化，并且满足无套利条件 $d < R < u$。根据资产定价基本定理，通过 $p = (R - d)/(u - d)$ 定义的风险中性概率 $p$ 下，折现后的资产价格 $\\{S_n / R^n\\}$ 是一个鞅，且任何到期日为 $N$ 的或有债权的0时刻价格等于其风险中性折现期望。\n\n一个远期生效欧式看涨期权由一个生效时间 $t_1$ 指定，该时间对应于步数指数 $m \\in \\{0,1,\\dots,N\\}$。在 $m$ 时刻，执行价格被设定为当时的市场资产价格，即 $K = S_m$。该期权在 $N$ 时刻到期，其支付为 $(S_N - S_m)^+$，其中 $(x)^+ = \\max\\{x, 0\\}$。\n\n任务：仅从上述核心定义（二叉树动态、无套利、风险中性定价和折现鞅性质）出发，推导一个算法来计算该远期生效看涨期权的0时刻价格，该算法适用于满足 $d < R < u$ 和 $0 \\le m \\le N$ 的任意输入 $(S_0, u, d, R, N, m)$。你的程序必须实现这个算法，不得使用任何连续时间近似或超出这些原则的外部公式。实现应使用数值稳定的方法计算风险中性期望，并且必须处理如 $m = 0$ 和 $m = N$ 等边界情况。\n\n输入和输出测试规范：你的程序应硬编码以下参数集测试套件，每个参数集以元组 $(S_0, u, d, R, N, m)$ 的形式给出：\n\n- 测试 1（一般情况）：$(100.0, 1.1, 0.9, 1.02, 6, 2)$。\n- 测试 2（边界 $m = 0$）：$(100.0, 1.1, 0.9, 1.02, 6, 0)$。\n- 测试 3（边界 $m = N$）：$(75.0, 1.08, 0.93, 1.01, 5, 5)$。\n- 测试 4（每步零利率 $R = 1$ 且因子对称）：$(50.0, 1.2, 1.0/1.2, 1.0, 4, 1)$。\n- 测试 5（$m$ 之后剩余期限较短）：$(80.0, 1.05, 0.95, 1.01, 10, 7)$。\n\n要求的最终输出格式为单行文本，其中包含所有测试的价格，按顺序排列，形式为一个用方括号括起来的逗号分隔列表。每个价格必须是四舍五入到恰好6位小数的实数。例如，一个包含三个假设结果的输出应如下所示：\"[12.345678,0.000000,3.210000]\"。",
            "solution": "我们在无套利条件 $d < R < u$ 下的 Cox–Ross–Rubinstein (CRR) 二叉树模型中进行分析。根据资产定价基本定理，存在一个风险中性概率 $p = \\frac{R - d}{u - d}$，在该概率下，折现后的资产价格过程 $\\left\\{\\frac{S_n}{R^n}\\right\\}_{n=0}^{N}$ 是一个鞅。任何在 $N$ 时刻可测的或有债权 $X_N$ 的0时刻价格 $V_0$ 由 $V_0 = \\mathbb{E}^{\\mathbb{Q}}\\!\\left[R^{-N} X_N\\right]$ 给出，其中 $\\mathbb{Q}$ 表示风险中性测度。\n\n我们考虑一个远期生效欧式看涨期权，它在第 $m$ 步生效，执行价格为 $K = S_m$，并在第 $N$ 步到期，支付为 $X_N = (S_N - S_m)^+$。为了计算其0时刻价格，我们使用两个基本原则：\n\n1. 对从 $m$ 到 $N$ 的子时段进行风险中性定价。\n2. 折现资产的鞅性质。\n\n固定由二叉树过程生成的筛选 $\\{\\mathcal{F}_n\\}$。在 $m$ 时刻，以 $\\mathcal{F}_m$ 为条件，支付可以重写为\n$$\nX_N = \\left(S_N - S_m\\right)^{+} = S_m \\left(\\frac{S_N}{S_m} - 1\\right)^{+}.\n$$\n定义子时段内的乘法回报率为\n$$\nY := \\frac{S_N}{S_m},\n$$\n该值仅依赖于 $m$ 时刻后的 $N - m$ 次价格变动；特别地，$Y \\in \\{u^k d^{(N-m)-k} : k = 0,1,\\dots,N-m\\}$。于是，$m$ 时刻的期权价值为\n$$\nV_m = \\mathbb{E}^{\\mathbb{Q}}\\!\\left[R^{-(N-m)} X_N \\,\\middle|\\, \\mathcal{F}_m \\right]\n= \\mathbb{E}^{\\mathbb{Q}}\\!\\left[R^{-(N-m)} S_m (Y - 1)^{+} \\,\\middle|\\, \\mathcal{F}_m \\right].\n$$\n因为 $S_m$ 是 $\\mathcal{F}_m$-可测的，且在给定 $\\mathcal{F}_m$ 的条件下 $Y$ 仅依赖于未来的价格变动，我们可以将 $S_m$ 因子提出来：\n$$\nV_m = S_m \\cdot \\underbrace{\\mathbb{E}^{\\mathbb{Q}}\\!\\left[R^{-(N-m)} (Y - 1)^{+} \\right]}_{=: c_{\\text{rel}}}.\n$$\n量 $c_{\\text{rel}}$ 是确定性的（它不依赖于已实现的 $S_m$），因为它只依赖于 $u$、$d$、$R$ 以及步数 $N - m$。因此，\n$$\nV_m = S_m \\, c_{\\text{rel}}.\n$$\n\n接下来，从0时刻到 $m$ 时刻应用风险中性估值：\n$$\nV_0 = \\mathbb{E}^{\\mathbb{Q}}\\!\\left[R^{-m} V_m \\right] = \\mathbb{E}^{\\mathbb{Q}}\\!\\left[R^{-m} S_m \\right] \\, c_{\\text{rel}}.\n$$\n根据折现价格的鞅性质，$\\mathbb{E}^{\\mathbb{Q}}\\!\\left[R^{-m} S_m\\right] = S_0$。因此，\n$$\nV_0 = S_0 \\, c_{\\text{rel}}.\n$$\n\n剩下的任务是从第一性原理计算 $c_{\\text{rel}}$。在测度 $\\mathbb{Q}$ 下，$N - m$ 步中的上涨次数 $K$ 服从参数为 $n := N - m$ 和 $p = \\frac{R - d}{u - d}$ 的二项分布。乘法回报率为 $Y = u^{K} d^{n-K}$。因此，\n$$\nc_{\\text{rel}} = R^{-n} \\sum_{k=0}^{n} \\binom{n}{k} p^{k} (1-p)^{n-k} \\, \\max\\!\\left(u^{k} d^{n-k} - 1, 0\\right).\n$$\n这个公式是直接从风险中性折现期望和未来上涨步数的二项分布推导出来的。两个边界检查立即得出：\n- 如果 $m = N$，则 $n = 0$ 且 $Y = 1$，因此 $\\max(Y - 1, 0) = 0$ 且 $c_{\\text{rel}} = 0$，得到 $V_0 = 0$。\n- 如果 $m = 0$，则 $V_0 = S_0 \\, c_{\\text{rel}}$ 等于一个执行价格为 $K = S_0$、期限为 $N$ 步的平价看涨期权的0时刻价格，这与立即生效的远期生效期权的定义一致。\n\n算法设计：\n- 输入 $(S_0, u, d, R, N, m)$，其中 $d < R < u$ 且 $0 \\le m \\le N$。\n- 计算 $n \\leftarrow N - m$。如果 $n = 0$，返回 $0.0$。\n- 计算 $p \\leftarrow (R - d)/(u - d)$ 和 $q \\leftarrow 1 - p$。\n- 计算\n$$\nc_{\\text{rel}} \\leftarrow R^{-n} \\sum_{k=0}^{n} \\binom{n}{k} p^{k} q^{n-k} \\, \\max\\!\\left(u^{k} d^{n-k} - 1, 0\\right).\n$$\n- 返回 $V_0 \\leftarrow S_0 \\cdot c_{\\text{rel}}$。\n- 为了数值稳定性，可以通过递归更新二项概率质量函数或在 $n$ 适中时使用精确的整数二项式系数和浮点数幂来计算 $\\binom{n}{k} p^{k} q^{n-k}$。这里的测试用例使用的 $n$ 都比较小，所以两种方法都是稳定的。结果四舍五入到6位小数。\n\n此构建过程仅使用了核心原理：无套利下的风险中性测度的存在性、折现价格的鞅性质，以及风险中性定价即为折现期望的定义。它避免了任何连续时间近似，并且完全依赖于二叉树结构和初等概率论。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef forward_start_call_price_crr(S0, u, d, R, N, m):\n    \"\"\"\n    Price a forward-start European call in the CRR model.\n    At time m, the strike is set to S_m; maturity at N; payoff is (S_N - S_m)+.\n    Parameters:\n        S0 : float, initial asset price S_0\n        u  : float, up factor per step\n        d  : float, down factor per step\n        R  : float, risk-free gross rate per step\n        N  : int, total number of steps to maturity\n        m  : int, activation step (0 <= m <= N)\n    Returns:\n        float, time-0 price\n    \"\"\"\n    # Handle trivial case: if m == N, payoff is zero.\n    n = N - m\n    if n == 0:\n        return 0.0\n\n    # Risk-neutral probability\n    p = (R - d) / (u - d)\n    q = 1.0 - p\n\n    # Compute c_rel = E[ R^{-n} * max(Y - 1, 0) ] with Y = u^K d^{n-K}, K ~ Bin(n,p)\n    # Use exact binomial coefficients for modest n.\n    c_rel = 0.0\n    R_disc = R ** (-n)\n    # To avoid redundant power computations, precompute powers if beneficial\n    # but here n is small in tests; we compute directly for clarity.\n    for k in range(n + 1):\n        # Binomial probability\n        comb = math.comb(n, k)\n        prob = comb * (p ** k) * (q ** (n - k))\n        # Relative terminal factor\n        y = (u ** k) * (d ** (n - k))\n        payoff = y - 1.0\n        if payoff > 0.0:\n            c_rel += prob * payoff\n\n    c_rel *= R_disc\n    return S0 * c_rel\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case is (S0, u, d, R, N, m)\n    test_cases = [\n        (100.0, 1.1, 0.9, 1.02, 6, 2),                         # Test 1\n        (100.0, 1.1, 0.9, 1.02, 6, 0),                         # Test 2 (m=0)\n        (75.0, 1.08, 0.93, 1.01, 5, 5),                        # Test 3 (m=N -> price 0)\n        (50.0, 1.2, 1.0/1.2, 1.0, 4, 1),                       # Test 4 (R=1, symmetric u,d)\n        (80.0, 1.05, 0.95, 1.01, 10, 7),                       # Test 5 (short remaining horizon)\n    ]\n\n    results = []\n    for case in test_cases:\n        S0, u, d, R, N, m = case\n        price = forward_start_call_price_crr(S0, u, d, R, N, m)\n        results.append(f\"{price:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "理想模型是理解现实的起点，但真实世界充满了各种“摩擦”，这使得市场变得不完备。本练习将打破完美市场的假设，引入一个常见的市场摩擦：借贷利率不一致 ($r_b > r_l$)。在这种不完备市场中，你将发现期权不再拥有唯一的无套利价格，而是存在一个价格区间，这个练习要求你通过构建“超复制”(super-replication) 和“次复制”(sub-replication) 策略，来确定这个无套利价格区间的上下边界 。",
            "id": "2439179",
            "problem": "考虑一个离散时间下的双期 Cox-Ross-Rubinstein (CRR) 二项市场，其中包含一个风险资产和一个银行账户。风险资产的初始价格为 $S_{0} = 100$，在每个时期，其价格独立地以因子 $u = 1.2$ 上涨或以因子 $d = 0.9$ 下跌。银行账户具有不对称的单利率：如果一个自融资策略的现金头寸在一个时期内为非负，则该时期的利息按贷款利率 $r_{l} = 0.02$ 计算；如果现金头寸为负，则该时期的利息按借款利率 $r_{b} = 0.08$ 计算。市场无股息、无交易成本，除了借贷利率不对称外，交易是无摩擦的。假设允许卖空股票，并且利率的不对称性根据每个时期开始时策略的现金头寸的符号逐期应用。\n\n设 $C$ 是一个以该风险资产为标的的欧式看涨期权，执行价格为 $K = 100$，到期日为两个时期结束时。在无套利的情况下，由于利率的不对称性，该期权不必有唯一的价格。\n\n确定 $C$ 在时间 $0$ 的无套利价格范围（即无套利价格区间）。将您的两个数值端点四舍五入到四位有效数字。以单行矩阵的形式提供您的最终答案，包含两个数字。",
            "solution": "该问题要求在一个具有不对称利率的双期二项式市场中，确定一个欧式看涨期权的无套利价格范围。这是一个不完全市场中的期权定价问题。由于不存在单一的风险中性概率测度，导致价格存在一个范围，其边界为买方价格（买入价）和卖方价格（卖出价）。\n\n设 $S_t$ 为风险资产在时间 $t$ 的价格。初始价格为 $S_0 = 100$。在每个时期，价格乘以一个上涨因子 $u=1.2$ 或一个下跌因子 $d=0.9$。贷款和借款的无风险利率分别为 $r_l=0.02$ 和 $r_b=0.08$。该期权是一个欧式看涨期权，执行价格为 $K=100$，到期时间为 $T=2$。\n\n首先，我们绘制出股票价格的可能路径：\n在 $t=0$ 时：$S_0 = 100$。\n在 $t=1$ 时：$S_1(u) = 100 \\times 1.2 = 120$， $S_1(d) = 100 \\times 0.9 = 90$。\n在 $t=2$ 时：$S_2(uu) = 120 \\times 1.2 = 144$， $S_2(ud) = 120 \\times 0.9 = 108$， $S_2(dd) = 90 \\times 0.9 = 81$。\n\n在 $t=2$ 时，期权收益 $C_2 = \\max(S_2 - K, 0)$ 为：\n$C_2(uu) = \\max(144 - 100, 0) = 44$。\n$C_2(ud) = \\max(108 - 100, 0) = 8$。\n$C_2(dd) = \\max(81 - 100, 0) = 0$。\n\n时间 $t=0$ 时的无套利价格范围是 $[C_0^{min}, C_0^{max}]$。\n上界 $C_0^{max}$ 是卖方价格（卖出价）。它是建立一个能够上超复制（super-replicate）期权收益的投资组合所需的最小初始资本，即其在到期时的价值总是至少等于期权的收益。\n下界 $C_0^{min}$ 是买方价格（买入价）。它是可以从一个下超复制（sub-replicate）期权收益的投资组合中提取的最大初始资本，即其在到期时的价值总是至多等于期权的收益。这通过对偶关系联系起来：$C_0^{min}(C) = -C_0^{max}(-C)$。\n\n我们使用向后归纳法来解决这个问题。\n\n**1. 卖方价格 $C_0^{max}$ 的计算**\n\n这是上超复制策略的最小成本。一个策略在每个时间 $t$ 包含持有 $\\phi_t$ 份股票和一个现金数额 $\\psi_t$。应用于 $\\psi_t$ 的利率取决于其符号。\n\n**步骤 1.1：在 $t=1$ 时定价**\n在 $t=1$ 的每个节点，我们寻找上超复制 $t=2$ 时期权收益的最小成本。一个投资组合 $(\\phi_1, \\psi_1)$ 必须满足 $V_2 = \\phi_1 S_2 + \\psi_1(1+r_1) \\ge C_2$。\n在节点 $S_1(u)=120$：\n我们需要在以下约束条件下求 $\\min(\\phi_1 \\cdot 120 + \\psi_1)$：\n$\\phi_1 \\cdot 144 + \\psi_1(1+r_1) \\ge 44$\n$\\phi_1 \\cdot 108 + \\psi_1(1+r_1) \\ge 8$\n用等式求解得到 $\\phi_1 = \\frac{44-8}{144-108} = 1$。这意味着 $\\psi_1(1+r_1) = 8 - 1 \\cdot 108 = -100$。\n由于 $\\psi_1(1+r_1)$ 为负，$\\psi_1$ 必须为负。因此，适用借款利率 $r_1=r_b=0.08$。\n$\\psi_1 = -100 / (1+0.08) = -100/1.08$。关于 $\\psi_1$ 符号的先验假设是一致的。\n此节点的成本是 $C_1^{max}(u) = 1 \\cdot 120 - 100/1.08 = 120 - \\frac{100}{1.08} = \\frac{129.6 - 100}{1.08} = \\frac{29.6}{1.08} = \\frac{2960}{108} = \\frac{740}{27}$。\n\n在节点 $S_1(d)=90$：\n我们需要在以下约束条件下求 $\\min(\\phi_1 \\cdot 90 + \\psi_1)$：\n$\\phi_1 \\cdot 108 + \\psi_1(1+r_1) \\ge 8$\n$\\phi_1 \\cdot 81 + \\psi_1(1+r_1) \\ge 0$\n用等式求解得到 $\\phi_1 = \\frac{8-0}{108-81} = \\frac{8}{27}$。这意味着 $\\psi_1(1+r_1) = 0 - \\frac{8}{27} \\cdot 81 = -24$。\n$\\psi_1$ 必须为负，因此适用 $r_1=r_b=0.08$。\n$\\psi_1 = -24/1.08$。成本是 $C_1^{max}(d) = \\frac{8}{27} \\cdot 90 - \\frac{24}{1.08} = \\frac{80}{3} - \\frac{24}{1.08} = \\frac{80}{3} - \\frac{2400}{108} = \\frac{80}{3} - \\frac{200}{9} = \\frac{240-200}{9} = \\frac{40}{9}$。\n\n由于在两个后继节点进行完美复制时都必须有 $\\psi_10$，成本 $C_1^{max}(u)$ 和 $C_1^{max}(d)$ 是唯一确定的。\n\n**步骤 1.2：在 $t=0$ 时定价**\n我们在以下约束条件下寻找最小成本 $\\min(\\phi_0 S_0 + \\psi_0)$：\n$\\phi_0 S_1(u) + \\psi_0(1+r_0) \\ge C_1^{max}(u) = 740/27$\n$\\phi_0 S_1(d) + \\psi_0(1+r_0) \\ge C_1^{max}(d) = 40/9$\n其中，如果 $\\psi_0 \\ge 0$ 则 $r_0=r_l$，如果 $\\psi_0  0$ 则 $r_0=r_b$。我们必须在两种可能性中找到最小成本。\n\n情况 A：假设 $\\psi_0  0$，则 $r_0 = r_b = 0.08$。\n用等式求解：$\\phi_0 = \\frac{740/27 - 40/9}{120-90} = \\frac{(740-120)/27}{30} = \\frac{620}{810} = \\frac{62}{81}$。\n$\\psi_0(1.08) = 40/9 - (62/81) \\cdot 90 = (360-620)/9 = -580/9$。\n$\\psi_0 = -580/(9 \\cdot 1.08)  0$。这与我们的假设一致。\n成本为 $V_0^{borrow} = \\phi_0 S_0 + \\psi_0 = \\frac{62}{81} \\cdot 100 - \\frac{580}{9 \\cdot 1.08} = \\frac{6200}{81} - \\frac{580}{9.72} = \\frac{18600-14500}{243} = \\frac{4100}{243}$。\n\n情况 B：假设 $\\psi_0 \\ge 0$，则 $r_0=r_l=0.02$。\n该策略必须满足约束条件。最小成本在可行域的顶点处达到。其中一个顶点是 $\\psi_0 = 0$ 且一个约束为等式。我们尝试 $\\psi_0=0, \\phi_0 S_1(u) \\ge C_1^{max}(u)$。这意味着 $120\\phi_0 \\ge 740/27 \\implies \\phi_0=37/162$。成本为 $V_0 = 100 \\cdot (37/162) = 1850/81$。这个投资组合也必须满足第二个约束条件：$90 \\cdot (37/162) = 185/9 = 20.55\\ldots$，这确实 $\\ge 40/9 = 4.44\\ldots$。所以这是一个有效的上超复制投资组合。\n成本为 $V_0^{lend} = 1850/81$。\n\n为了找到卖方价格 $C_0^{max}$，我们取所有可能策略成本的最小值：\n$C_0^{max} = \\min(V_0^{borrow}, V_0^{lend}) = \\min(\\frac{4100}{243}, \\frac{1850}{81}) = \\min(\\frac{4100}{243}, \\frac{5550}{243}) = \\frac{4100}{243}$。\n$C_0^{max} \\approx 16.8724$。\n\n**2. 买方价格 $C_0^{min}$ 的计算**\n\n我们使用对偶关系 $C_0^{min}(C) = -C_0^{max}(-C)$。我们计算一个收益为 $-C_2$ 的期权的卖方价格。\n收益为 $-C_2(uu)=-44$，$-C_2(ud)=-8$，$-C_2(dd)=0$。\n\n**步骤 2.1：在 $t=1$ 时为 $-C$ 定价**\n在节点 $S_1(u)=120$：收益为 $-44, -8$。\n求解复制组合：$\\phi_1 = \\frac{-44 - (-8)}{144-108} = -1$。\n$\\psi_1(1+r_1) = -8 - (-1) \\cdot 108 = 100$。\n由于 $\\psi_1(1+r_1)  0$，$\\psi_1$ 必须为正。因此，适用贷款利率 $r_1=r_l=0.02$。\n成本为 $C_1^{ask}(-C)(u) = -1 \\cdot 120 + 100/1.02 = (-122.4+100)/1.02 = -22.4/1.02$。\n\n在节点 $S_1(d)=90$：收益为 $-8, 0$。\n$\\phi_1 = \\frac{-8-0}{108-81} = -8/27$。\n$\\psi_1(1+r_1) = 0 - (-8/27) \\cdot 81 = 24$。\n$\\psi_1  0$，因此适用 $r_1=r_l=0.02$。\n成本为 $C_1^{ask}(-C)(d) = (-8/27) \\cdot 90 + 24/1.02 = -80/3 + 24/1.02 = (-80 \\cdot 1.02 + 72)/3.06 = -9.6/3.06 = -160/51$。\n\n**步骤 2.2：在 $t=0$ 时为 $-C$ 定价**\n我们在以下约束条件下寻找 $\\min(\\phi_0 S_0 + \\psi_0)$：\n$\\phi_0 S_1(u) + \\psi_0(1+r_0) \\ge C_1^{ask}(-C)(u) = -22.4/1.02$\n$\\phi_0 S_1(d) + \\psi_0(1+r_0) \\ge C_1^{ask}(-C)(d) = -160/51$\n情况 A：假设 $\\psi_0 \\ge 0$，使用 $r_0=r_l=0.02$。\n用等式求解：$\\phi_0 = \\frac{-22.4/1.02 - (-160/51)}{30} = \\frac{1}{30}(\\frac{-22.4 \\cdot 50/51 + 160/51}{1}) = \\frac{-1120+160}{30 \\cdot 51} = \\frac{-960}{1530} = -32/51$。\n$\\psi_0(1.02) = -160/51 - (-32/51) \\cdot 90 = (-160+2880)/51 = 2720/51$。\n$\\psi_0 = 2720/(51 \\cdot 1.02)  0$。这与假设一致。\n成本为 $V_0^{lend} = \\phi_0 S_0 + \\psi_0 = -32/51 \\cdot 100 + \\frac{2720}{51 \\cdot 1.02} = \\frac{-3200 \\cdot 1.02 + 2720}{51 \\cdot 1.02} = \\frac{-3264+2720}{52.02} = \\frac{-544}{52.02} = \\frac{-27200}{2601}$。\n\n情况 B：假设 $\\psi_0  0$，使用 $r_0=r_b=0.08$。\n复制组合的 $\\phi_0$ 相同，为 $-32/51$。\n$\\psi_0(1.08) = 2720/51 \\implies \\psi_0  0$。这与假设 $\\psi_0  0$ 相矛盾。因此，在 $t=0$ 时借款来为 $-C$ 构造一个上超复制策略是不可能的。\n\n因此，$-C$ 的卖方价格为 $C_0^{max}(-C) = -27200/2601$。\n$C$ 的买方价格为 $C_0^{min}(C) = -C_0^{max}(-C) = 27200/2601$。\n$C_0^{min} \\approx 10.4575$。\n\n**3. 结论**\n该欧式看涨期权在 $t=0$ 时的无套利价格范围是 $[C_0^{min}, C_0^{max}]$。\n$C_0^{min} = 27200/2601 \\approx 10.457516$\n$C_0^{max} = 4100/243 \\approx 16.872428$\n\n四舍五入到四位有效数字，该范围是 $[10.46, 16.87]$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n10.46  16.87\n\\end{pmatrix}\n}\n$$"
        }
    ]
}