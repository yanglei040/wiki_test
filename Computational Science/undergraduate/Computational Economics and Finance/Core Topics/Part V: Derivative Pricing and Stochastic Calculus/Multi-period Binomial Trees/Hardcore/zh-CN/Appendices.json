{
    "hands_on_practices": [
        {
            "introduction": "二叉树模型的真正威力在于其超越标准期权的适应性。第一个练习将挑战你为一种常见的奇异衍生品——有顶看涨期权——进行定价。通过将风险中性定价的基本原理应用于一个修正后的收益结构 ，你将练习一项关键技能：调整模型以适应各种金融工具的独特特性。",
            "id": "2412781",
            "problem": "考虑一个无摩擦、无套利的市场。单一风险资产的当前价格为 $S_0 = 100$，其价格在 $N = 3$ 个等长时期内根据一个重组二叉树模型进行演变，每期的固定上涨因子为 $u = 1.2$，下跌因子为 $d = 0.9$。无风险资产以每期固定的有效利率 $r = 0.05$ 增长，因此每期的总回报率为 $R = 1 + r = 1.05$。该风险资产不支付股息。\n\n一份基于该风险资产的欧式有顶看涨期权的执行价格为 $K = 100$，上限金额为 $C = 15$。其在到期日 $T$ 的支付由 $\\min\\!\\big(\\max(S_T - K, 0), C\\big)$ 给出。假设上述二叉树模型和参数在期权的整个生命周期内都成立。\n\n在该二叉树模型的无套利原则下，计算此有顶看涨期权在时间 $t=0$ 的无套利价格。以与 $S_0$ 相同的货币单位表示您的最终答案，并四舍五入到 $4$ 位有效数字。在您的最终数值输入中不要包含任何货币符号。",
            "solution": "所述问题是有效的。这是一个在量化金融领域内自成体系、有科学依据的问题。二叉树期权定价模型所需的所有必要参数都已给出：初始资产价格 $S_0$、上涨因子 $u$、下跌因子 $d$、无风险利率 $r$、时期数 $N$，以及衍生品的特定支付结构（执行价格为 $K$、上限为 $C$ 的欧式有顶看涨期权）。该模型基于无套利基本原则，这是金融理论的基石。存在唯一风险中性概率的无套利条件 $d  R  u$（其中 $R = 1+r$）是满足的。给定 $d=0.9$，$u=1.2$ 和 $R=1.05$，我们有 $0.9  1.05  1.2$。因此，该问题是适定的，并且可以计算出唯一的无套利价格。\n\n欧式有顶看涨期权在时间 $t=0$ 的价格（记为 $V_0$）由风险中性估值原则确定。该原则指出，衍生品的当前价格是其未来支付的折现期望值，其中期望是在风险中性概率测度下计算的，折现则使用无风险利率。\n\n首先，我们必须计算资产价格上涨的风险中性概率 $q$。$q$ 的公式来自于这样一个条件：在风险中性测度下，风险资产的预期回报必须等于无风险回报。\n$$\nq S_0 u + (1-q) S_0 d = S_0 R\n$$\n求解 $q$，我们得到：\n$$\nq = \\frac{R - d}{u - d}\n$$\n代入给定值：$R = 1.05$，$u = 1.2$ 和 $d = 0.9$。\n$$\nq = \\frac{1.05 - 0.9}{1.2 - 0.9} = \\frac{0.15}{0.30} = 0.5\n$$\n下跌的概率是 $1 - q = 1 - 0.5 = 0.5$。\n\n该问题涉及 $N=3$ 个时期。标的资产在到期日的价格 $S_T = S_3$ 可能有 $N+1 = 4$ 个不同的值。设 $j$ 为 $N$ 个时期内价格上涨的次数。到期时的资产价格由 $S_3(j) = S_0 u^j d^{N-j}$ 给出。可能的终端价格是：\n-   当 $j=3$ (3次上涨)时：$S_3(3) = 100 \\times (1.2)^3 = 100 \\times 1.728 = 172.8$\n-   当 $j=2$ (2次上涨, 1次下跌)时：$S_3(2) = 100 \\times (1.2)^2 \\times (0.9)^1 = 100 \\times 1.44 \\times 0.9 = 129.6$\n-   当 $j=1$ (1次上涨, 2次下跌)时：$S_3(1) = 100 \\times (1.2)^1 \\times (0.9)^2 = 100 \\times 1.2 \\times 0.81 = 97.2$\n-   当 $j=0$ (3次下跌)时：$S_3(0) = 100 \\times (0.9)^3 = 100 \\times 0.729 = 72.9$\n\n接下来，我们计算在这些终端资产价格下，期权在到期日 $V_3$ 的支付。支付定义为 $V_3 = \\min(\\max(S_3 - K, 0), C)$，其中执行价格 $K=100$，上限 $C=15$。\n-   在 $S_3(3) = 172.8$ 时的支付：$V_3(3) = \\min(\\max(172.8 - 100, 0), 15) = \\min(72.8, 15) = 15$。\n-   在 $S_3(2) = 129.6$ 时的支付：$V_3(2) = \\min(\\max(129.6 - 100, 0), 15) = \\min(29.6, 15) = 15$。\n-   在 $S_3(1) = 97.2$ 时的支付：$V_3(1) = \\min(\\max(97.2 - 100, 0), 15) = \\min(0, 15) = 0$。\n-   在 $S_3(0) = 72.9$ 时的支付：$V_3(0) = \\min(\\max(72.9 - 100, 0), 15) = \\min(0, 15) = 0$。\n\n时间 $t=0$ 的无套利价格是在风险中性测度下预期支付的现值。在 $N$ 个时期内实现 $j$ 次上涨状态的概率服从概率为 $q$ 的二项分布。该概率由 $\\binom{N}{j} q^j (1-q)^{N-j}$ 给出。\n$$\nV_0 = \\frac{1}{R^N} \\sum_{j=0}^{N} \\binom{N}{j} q^j (1-q)^{N-j} V_3(j)\n$$\n代入 $N=3$，$R=1.05$ 和 $q=0.5$：\n$$\nV_0 = \\frac{1}{(1.05)^3} \\left[ \\binom{3}{0}(0.5)^3 V_3(0) + \\binom{3}{1}(0.5)^3 V_3(1) + \\binom{3}{2}(0.5)^3 V_3(2) + \\binom{3}{3}(0.5)^3 V_3(3) \\right]\n$$\n二项式系数为 $\\binom{3}{0}=1$, $\\binom{3}{1}=3$, $\\binom{3}{2}=3$, $\\binom{3}{3}=1$。\n$$\nV_0 = \\frac{(0.5)^3}{(1.05)^3} \\left[ 1 \\cdot V_3(0) + 3 \\cdot V_3(1) + 3 \\cdot V_3(2) + 1 \\cdot V_3(3) \\right]\n$$\n代入计算出的支付值：\n$$\nV_0 = \\frac{0.125}{(1.05)^3} \\left[ 1 \\cdot 0 + 3 \\cdot 0 + 3 \\cdot 15 + 1 \\cdot 15 \\right]\n$$\n$$\nV_0 = \\frac{0.125}{(1.05)^3} \\left[ 45 + 15 \\right] = \\frac{0.125 \\times 60}{(1.05)^3} = \\frac{7.5}{(1.05)^3}\n$$\n现在，我们计算数值。\n$$\n(1.05)^3 = 1.157625\n$$\n$$\nV_0 = \\frac{7.5}{1.157625} \\approx 6.4788506...\n$$\n问题要求答案四舍五入到 $4$ 位有效数字。\n$$\nV_0 \\approx 6.479\n$$\n这就是欧式有顶看涨期权在时间 $t=0$ 的无套利价格。",
            "answer": "$$\n\\boxed{6.479}\n$$"
        },
        {
            "introduction": "无套利价格的概念与使用标的资产和无风险债券完美复制期权收益的能力紧密相连。这个动手编程练习  将抽象的理论具体化，要求你实现一个动态的Delta对冲策略。通过追踪整个过程中的对冲误差，你将亲眼见证复制的“魔力”，并深刻理解为何计算出的期权价格确实是无套利的。",
            "id": "2412792",
            "problem": "给定一个离散时间、多期的二叉树资产定价模型。设标的资产价格过程 $\\{S_{t}\\}_{t=0}^{N}$ 服从乘性动态，即在每个时期内，价格要么上涨一个因子 $u$，要么下跌一个因子 $d$，其中 $ud0$。每个时期的无风险总回报率为 $R$，且满足无套利条件 $d  R  u$。考虑一个以此资产为标的、执行价格为 $K$、到期时间步为 $N$ 的欧式看涨期权。设 $C_{t}$ 表示在给定节点处，期权在时间 $t$ 的唯一无套利价值。该价值是在风险中性测度下计算的，其中上涨概率为 $q=(R-d)/(u-d)$，终端条件为 $C_{N}=\\max(S_{N}-K,0)$。在每个非终端节点，将局部 Delta 定义为复制投资组合中的股票数量，\n$$\n\\Delta_{t}=\\frac{C_{t+1}^{(u)}-C_{t+1}^{(d)}}{S_{t+1}^{(u)}-S_{t+1}^{(d)}},\n$$\n其中上标表示在上涨或下跌子节点中的价值。\n\n一个交易员在时间 $0$ 卖空一份看涨期权，收到期权费 $C_{0}$，并通过持有 $\\Delta_{t}$ 份股票和一份无风险账户头寸 $B_{t}$ 来动态对冲该空头头寸。交易无交易成本且满足自融资约束。初始对冲满足 $B_{0}=C_{0}-\\Delta_{0}S_{0}$。沿着一条长度为 $N$ 的已实现价格路径，设时期 $t$ 结束时的再平衡前对冲误差为\n$$\ne_{t}=\\Delta_{t-1}S_{t}+B_{t-1}R-C_{t},\\quad t=1,2,\\dots,N,\n$$\n其中 $C_{t}$ 是在时间 $t$ 到达的节点上的期权价值，且 $C_{N}=\\max(S_{N}-K,0)$。在度量 $e_{t}$ 后，于时间 $t$ 将对冲头寸再平衡至 $\\Delta_{t}$，其中 $t=1,2,\\dots,N-1$。\n\n您的任务是实现一个程序，对于每个给定的参数集和已实现路径，构建二叉树价格树、计算期权价值树、为上述定义的看涨期权空头实施动态 Delta 对冲策略，并返回沿该路径的序列 $\\{e_{t}\\}_{t=1}^{N}$。所有值必须以小数形式表示（无百分号），且每个 $e_{t}$ 必须四舍五入到小数点后 $10$ 位。\n\n测试套件。对于以下每种情况，使用所提供的参数和上涨/下跌移动的已实现路径，其中 $U$ 表示上涨因子为 $u$ 的移动，$D$ 表示下跌因子为 $d$ 的移动：\n- 情况 $1$（一般多期路径）：$S_{0}=100.0$, $u=1.1$, $d=0.9$, $R=1.02$, $K=100.0$, $N=4$, 路径 $[U,D,U,U]$。\n- 情况 $2$（边界，单期）：$S_{0}=50.0$, $u=1.2$, $d=0.8$, $R=1.0$, $K=50.0$, $N=1$, 路径 $[U]$。\n- 情况 $3$（边缘，零利率且全为下跌）：$S_{0}=80.0$, $u=1.25$, $d=0.8$, $R=1.0$, $K=90.0$, $N=3$, 路径 $[D,D,D]$。\n- 情况 $4$（边缘，深度实值且全为上涨）：$S_{0}=100.0$, $u=1.2$, $d=0.8$, $R=1.01$, $K=80.0$, $N=3$, 路径 $[U,U,U]$。\n\n要求的最终输出格式。您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。此列表的每个元素都必须是对应测试用例的四舍五入后的对冲误差列表 $[e_{1},e_{2},\\dots,e_{N}]$。例如，包含两个测试用例的输出应类似于 $[[e_{1}^{(1)},\\dots,e_{N\\_{1}}^{(1)}],[e_{1}^{(2)},\\dots,e_{N\\_{2}}^{(2)}]]$，行内任何位置均无空格。",
            "solution": "问题陈述需进行验证。\n\n已知条件逐字提取如下：\n- 资产价格过程：$\\{S_{t}\\}_{t=0}^{N}$ 服从乘性二叉树模型。\n- 上涨因子：$u$。下跌因子：$d$。其中 $u  d  0$。\n- 每个时期的无风险总回报率：$R$。\n- 无套利条件：$d  R  u$。\n- 衍生品：欧式看涨期权，执行价格 $K$，到期时间 $N$。\n- 期权价值：在时间 $t$ 为 $C_{t}$。\n- 终端条件：$C_{N} = \\max(S_{N}-K, 0)$。\n- 风险中性上涨概率：$q = \\frac{R-d}{u-d}$。\n- 期权估值：在风险中性测度下，意味着 $C_{t} = R^{-1}[q C_{t+1}^{(u)} + (1-q) C_{t+1}^{(d)}]$。\n- 复制投资组合的 Delta：$\\Delta_{t}=\\frac{C_{t+1}^{(u)}-C_{t+1}^{(d)}}{S_{t+1}^{(u)}-S_{t+1}^{(d)}}$。\n- 对冲策略：卖空一份看涨期权，用 $\\Delta_{t}$ 份股票和一份无风险账户头寸 $B_{t}$ 进行对冲。\n- 初始对冲：$B_{0}=C_{0}-\\Delta_{0}S_{0}$。\n- 再平衡前对冲误差：$e_{t}=\\Delta_{t-1}S_{t}+B_{t-1}R-C_{t}$，其中 $t=1, 2, \\dots, N$。\n- 再平衡：在自融资约束下，于时间 $t$ 将对冲头寸再平衡至 $\\Delta_{t}$，其中 $t=1, 2, \\dots, N-1$。\n- 测试用例：提供了四组特定的参数（$S_{0}, u, d, R, K, N$）和已实现路径。\n- 输出要求：一个列表的列表，包含每个案例的对冲误差 $\\{e_{t}\\}_{t=1}^{N}$，四舍五入到小数点后 $10$ 位。\n\n验证结论：问题有效。\n该问题具有科学依据，是 Cox-Ross-Rubinstein 二叉树期权定价模型中的一个标准练习，该模型是计算金融学的一个基本概念。问题定义明确；所有参数、定义和约束都已提供，确保可以通过计算确定唯一解。期权价值、风险中性概率和 delta 的定义是标准且正确的。问题是客观的，不含任何模糊之处。无套利条件陈述正确，且测试用例均满足该条件。问题的核心是验证二叉树模型的核心论点：衍生品的支付可以通过在标的资产和无风险债券中的动态、自融资交易策略来完美复制。因此，根据定义，对冲误差在所有时间步上理论上应为零，任何非零结果仅可归因于浮点数计算精度。\n\n现给出一个完整的解决方案。该方法论构建于离散时间资产定价的基本原则之上。\n\n首先，我们为标的资产价格构建二叉格 $\\{S_{t}\\}_{t=0}^{N}$。在时间步 $i$（$0 \\le i \\le N$）经过 $j$ 次上涨（$0 \\le j \\le i$）后的树中节点，其价格由下式给出：\n$$S_{i,j} = S_{0} u^{j} d^{i-j}$$\n\n其次，我们确定树中每个节点的期权价值。这是通过从到期日 $t=N$ 的已知期权价值开始进行后向归纳来完成的。欧式看涨期权在到期日的价值是其内在价值：\n$$C_{N,j} = \\max(S_{N,j} - K, 0) \\quad \\text{for } j = 0, 1, \\dots, N$$\n对于任何 $i  N$ 的非终端节点 $(i,j)$，无套利期权价值 $C_{i,j}$ 是在风险中性测度下计算的下一时期期权的贴现期望值。风险中性上涨概率为 $q = \\frac{R-d}{u-d}$。估值公式为：\n$$C_{i,j} = \\frac{1}{R} \\left[ q C_{i+1,j+1} + (1-q) C_{i+1,j} \\right]$$\n这个后向递归计算填充了整个期权价值树 $\\{C_{i,j}\\}$。\n\n第三，我们沿着指定的资产价格移动路径实施动态对冲策略。该策略涉及创建一个由 $\\Delta_{t}$ 份资产股票和在无风险账户中的现金头寸 $B_{t}$ 组成的投资组合。该投资组合在时间 $t$ 的价值为 $V_t = \\Delta_t S_t + B_t$。\n\n该策略在 $t=0$ 时启动。构建初始投资组合以复制期权价值，$V_0 = C_0$。股票数量 $\\Delta_0$ 由 delta 对冲公式给出：\n$$\\Delta_{0} = \\frac{C_{1,1} - C_{1,0}}{S_{1,1} - S_{1,0}}$$\n然后设置初始现金头寸 $B_0$，以确保投资组合价值与期权价值相匹配：$B_{0} = C_{0,0} - \\Delta_{0}S_{0,0}$。\n\n该投资组合是自融资的。这意味着对于任何后续时期 $t  0$，投资组合构成的任何变化都在内部融资，没有外部现金注入或提取。在时期 $t$ 的开始（在价格从 $t-1$ 移动之后），来自上一时期的投资组合 $(\\Delta_{t-1}, B_{t-1})$ 的价值已演变为：\n$$V_{t}^{-} = \\Delta_{t-1}S_{t} + B_{t-1}R$$\n问题将时间 $t$ 的对冲误差定义为该投资组合价值与新节点处的理论期权价格 $C_{t}$ 之间的差额：\n$$e_{t} = V_{t}^{-} - C_{t}$$\n二叉树模型的一个核心结果是，复制投资组合的价值 $V_{t}^{-}$ 在每个节点上将精确匹配期权的价值 $C_{t}$。因此，我们预期对于所有 $t$，$e_t = 0$，除非有数值精度误差。\n\n计算误差后，为下一时期（如果 $t  N$）对投资组合进行再平衡。新的股票数量 $\\Delta_t$ 是根据当前节点的后继价值计算的：\n$$\\Delta_{t} = \\frac{C_{t+1}^{\\text{(up)}} - C_{t+1}^{\\text{(down)}}}{S_{t+1}^{\\text{(up)}} - S_{t+1}^{\\text{(down)}}}$$\n新的现金头寸 $B_t$ 由自融资条件确定。投资组合的价值在再平衡期间保持不变，因此再平衡后的价值 $V_t^{+} = \\Delta_t S_t + B_t$ 必须等于再平衡前的价值 $V_t^{-}$。因此，新的现金头寸为：\n$$B_{t} = V_{t}^{-} - \\Delta_{t}S_{t}$$\n这个沿着路径移动、计算对冲误差和再平衡的过程会一直重复，直到在 $t=N$ 到期。计算出的误差序列 $\\{e_t\\}_{t=1}^N$ 是给定路径的最终结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n\n    test_cases = [\n        {'S0': 100.0, 'u': 1.1, 'd': 0.9, 'R': 1.02, 'K': 100.0, 'N': 4, 'path': ['U', 'D', 'U', 'U']},\n        {'S0': 50.0, 'u': 1.2, 'd': 0.8, 'R': 1.0, 'K': 50.0, 'N': 1, 'path': ['U']},\n        {'S0': 80.0, 'u': 1.25, 'd': 0.8, 'R': 1.0, 'K': 90.0, 'N': 3, 'path': ['D', 'D', 'D']},\n        {'S0': 100.0, 'u': 1.2, 'd': 0.8, 'R': 1.01, 'K': 80.0, 'N': 3, 'path': ['U', 'U', 'U']}\n    ]\n\n    results = []\n    for case in test_cases:\n        errors = _calculate_hedging_errors(\n            S0=case['S0'],\n            u=case['u'],\n            d=case['d'],\n            R=case['R'],\n            K=case['K'],\n            N=case['N'],\n            path=case['path']\n        )\n        results.append(errors)\n    \n    # Format the final output string precisely as required.\n    inner_parts = []\n    for err_list in results:\n        # Format each error to a string with the required precision.\n        # Although the errors are theoretically zero, they may be small non-zero floats.\n        # We ensure standard float representation e.g. '0.0' instead of '0'\n        # The rounding is already done, this is for formatting.\n        formatted_list = [f\"{err:.10f}\".rstrip('0').rstrip('.') if err != 0 else '0.0' for err in err_list]\n        inner_parts.append(f\"[{','.join(formatted_list)}]\")\n        \n    final_output = f\"[{','.join(inner_parts)}]\"\n    print(final_output)\n\ndef _calculate_hedging_errors(S0: float, u: float, d: float, R: float, K: float, N: int, path: list[str]) - list[float]:\n    \"\"\"\n    Calculates the sequence of dynamic hedging errors for a given path.\n\n    Args:\n        S0: Initial asset price.\n        u: Up-move factor.\n        d: Down-move factor.\n        R: Gross risk-free return per period.\n        K: Option strike price.\n        N: Number of periods to maturity.\n        path: A list of 'U' or 'D' strings representing the realized path.\n\n    Returns:\n        A list of hedging errors {e_t} for t=1,...,N, rounded to 10 decimal places.\n    \"\"\"\n    # 1. Construct asset price and option value trees\n    # Risk-neutral probability\n    q = (R - d) / (u - d)\n\n    # Initialize trees\n    S_tree = np.zeros((N + 1, N + 1))\n    C_tree = np.zeros((N + 1, N + 1))\n\n    # Populate asset price tree S[i,j] = price at time i after j up-moves\n    for i in range(N + 1):\n        for j in range(i + 1):\n            S_tree[i, j] = S0 * (u**j) * (d**(i - j))\n\n    # Populate option value tree at maturity (t=N)\n    C_tree[N, :] = np.maximum(S_tree[N, :] - K, 0)\n\n    # Populate option value tree by backward induction\n    for i in range(N - 1, -1, -1):\n        for j in range(i + 1):\n            C_up = C_tree[i + 1, j + 1]\n            C_down = C_tree[i + 1, j]\n            C_tree[i, j] = (q * C_up + (1 - q) * C_down) / R\n\n    # 2. Trace the path and compute hedging errors\n    hedging_errors = []\n    \n    # Initial portfolio setup at t=0\n    num_ups = 0  # number of up moves from t=0\n    \n    # Initial delta (Delta_0)\n    delta_prev = (C_tree[1, 1] - C_tree[1, 0]) / (S_tree[1, 1] - S_tree[1, 0])\n    \n    # Initial bond position (B_0)\n    B_prev = C_tree[0, 0] - delta_prev * S_tree[0, 0]\n\n    # Iterate along the path from t=1 to N\n    for t in range(1, N + 1):\n        # Determine current node based on path\n        move = path[t - 1]\n        if move == 'U':\n            num_ups += 1\n        \n        # Current asset and option values at node (t, num_ups)\n        current_S = S_tree[t, num_ups]\n        current_C = C_tree[t, num_ups]\n        \n        # Value of hedge portfolio before rebalancing\n        portfolio_val_pre_rebalance = delta_prev * current_S + B_prev * R\n        \n        # Calculate hedging error e_t\n        error = portfolio_val_pre_rebalance - current_C\n        hedging_errors.append(round(error, 10))\n\n        # Rebalance the portfolio for the next period (if not at maturity)\n        if t  N:\n            # Calculate new delta (Delta_t) at the current node\n            delta_curr = (C_tree[t + 1, num_ups + 1] - C_tree[t + 1, num_ups]) / \\\n                         (S_tree[t + 1, num_ups + 1] - S_tree[t + 1, num_ups])\n            \n            # Calculate new bond position (B_t) to maintain self-financing\n            # New portfolio value V_t+ must equal V_t-\n            B_curr = portfolio_val_pre_rebalance - delta_curr * current_S\n            \n            # Update portfolio for the next iteration\n            delta_prev = delta_curr\n            B_prev = B_curr\n\n    return hedging_errors\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "许多金融衍生品的收益不仅取决于最终的资产价格，还取决于其所经历的整个价格路径。本练习  将向你介绍最常见的类型之一：障碍期权。你将学习如何调整标准的二叉树定价算法，以包含“敲出”特性，这是为各种路径依赖证券估值的关键技术。",
            "id": "2412809",
            "problem": "要求您编写一个完整、可运行的程序，在一个多期二叉树模型中计算一个离散监测向上敲出欧式看涨期权的无套利价格。计算必须基于 Cox–Ross–Rubinstein 模型下风险中性定价的基本原理。程序必须为下面提供的一组固定的参数集测试套件生成结果，并按规定将它们汇总到单行输出中。\n\n标的资产价格过程在一个包含 $N$ 个等长周期 $\\Delta t$ 的可重组二叉树上建模，其中 $\\Delta t = T/N$，每期上涨因子 $u = e^{\\sigma \\sqrt{\\Delta t}}$，每期下跌因子 $d = 1/u$，连续复利无风险利率为 $r$，风险中性概率为 $p = \\dfrac{e^{r \\Delta t} - d}{u - d}$。每期折现因子为 $e^{-r \\Delta t}$。在一个由时期 $i \\in \\{0,1,\\dots,N\\}$ 和累计上涨次数 $j \\in \\{0,1,\\dots,i\\}$ 索引的节点上，标的价格等于 $S(i,j) = S_0 \\, u^{j} d^{i-j}$。该期权是一个向上敲出欧式看涨期权，行权价为 $K$，障碍水平为 $B$，在 $N+1$ 个时间点 $t_i = i \\Delta t$ 进行离散监测。障碍是吸收性的：如果在任何监测时间 $i$，节点价格满足 $S(i,j) \\ge B$，期权即被敲出，其价值从此为 $0$。如果在时间 $N$ 之前从未触及障碍，则期末收益为 $\\max\\{S(N,j) - K, 0\\}$。假设对于所有列出的参数集，都满足 $d  e^{r \\Delta t}  u$，这确保了 $p \\in (0,1)$。\n\n您的程序必须仅使用在所述模型下能够贡献非零折现收益的状态，通过风险中性定价计算无套利价格 $V(0,0)$。在监测时间，障碍条件 $S(i,j) \\ge B$ 成立的状态，根据定义其贡献为零，并且不得影响计算出的价格。监测仅在节点时间 $t_i$ 离散进行。如果 $S_0 \\ge B$，期权在初始时刻即被敲出，价格为 $0$。\n\n测试套件。对于以下每个参数集，计算向上敲出欧式看涨期权的价格，结果为实数：\n- 情况 A（一般一致性情况，障碍实际上永远不会被触及）：$S_0 = 100$, $K = 100$, $B = 10^9$, $r = 0.05$, $\\sigma = 0.2$, $T = 1$, $N = 100$。\n- 情况 B（初始时刻立即敲出）：$S_0 = 100$, $K = 100$, $B = 100$, $r = 0.05$, $\\sigma = 0.2$, $T = 1$, $N = 100$。\n- 情况 C（深度价内，障碍水平较近）：$S_0 = 120$, $K = 90$, $B = 125$, $r = 0.03$, $\\sigma = 0.25$, $T = 1$, $N = 200$。\n- 情况 D（单步短期）：$S_0 = 100$, $K = 110$, $B = 130$, $r = 0.01$, $\\sigma = 0.15$, $T = 0.25$, $N = 1$。\n- 情况 E（深度价外，在树中行权价不可达）：$S_0 = 90$, $K = 200$, $B = 1e9$, $r = 0.02$, $\\sigma = 0.1$, $T = 1$, $N = 50$。\n\n答案规格和最终输出格式。您的程序必须：\n- 为每种情况计算一个价格，结果为浮点数。\n- 将每个计算出的价格四舍五入到 $10$ 位小数。\n- 生成仅一行输出，其中包含按 A、B、C、D、E 顺序排列的价格，形式为逗号分隔的列表，并用方括号括起来，例如 $[v_A,v_B,v_C,v_D,v_E]$。\n\n不涉及物理单位。所有角度（如果出现）必须以弧度为单位，但此处不需要角度。所有比例必须表示为小数，而不是使用百分号。",
            "solution": "所呈现的问题是计算金融中的一个标准练习：使用多期 Cox-Ross-Rubinstein (CRR) 二叉树模型为离散监测的向上敲出欧式看涨期权定价。问题陈述具有科学依据、问题定义明确、客观，并为得出唯一解提供了所有必要的数据。因此，该问题被认为是有效的。解决方案将从无套利定价的风险中性估值基本原理推导得出。\n\n核心方法是在代表标的资产可能价格路径的可重组二叉价格树上进行向后归纳法。设初始资产价格为 $S_0$，行权价为 $K$，障碍水平为 $B$，连续复利无风险利率为 $r$，波动率为 $\\sigma$，到期时间为 $T$。总时间被离散化为 $N$ 个长度为 $\\Delta t = T/N$ 的周期。\n\nCRR 模型将每期上涨因子 $u$ 和下跌因子 $d$ 定义为：\n$$ u = e^{\\sigma \\sqrt{\\Delta t}} $$\n$$ d = e^{-\\sigma \\sqrt{\\Delta t}} = 1/u $$\n树上任意节点 $(i, j)$ 的资产价格，代表时间步 $i \\in \\{0, 1, \\dots, N\\}$ 和 $j \\in \\{0, 1, \\dots, i\\}$ 次累计上涨，由下式给出：\n$$ S(i,j) = S_0 u^j d^{i-j} $$\n为确保无套利，风险中性概率 $p$ 由折现后的期望资产价格以无风险利率增长的条件唯一确定。这得出：\n$$ p = \\frac{e^{r \\Delta t} - d}{u - d} $$\n那么，下跌的概率为 $(1-p)$。问题陈述保证了 $d  e^{r \\Delta t}  u$，这确保了 $p \\in (0, 1)$。每期折现因子为 $e^{-r \\Delta t}$。\n\n定价过程从期权到期日 $T$ 开始向后进行。\n\n首先，必须检查在时间 $t_0=0$ 发生的立即敲出情况。如果初始价格 $S_0$ 等于或高于障碍水平 $B$，即 $S_0 \\ge B$，则期权毫无价值，其价格 $V(0,0)$ 为 $0$。\n\n如果期权在初始时未被敲出，我们前进到终端时间步 $N$。在每个终端节点 $(N, j)$，我们必须确定期权的价值 $V(N, j)$。此时会监测障碍。如果资产价格 $S(N, j) \\ge B$，期权被敲出，其价值为 $0$。否则，其价值为标准的欧式看涨期权收益：\n$$ V(N,j) = \\begin{cases} 0  \\text{if } S(N,j) \\ge B \\\\ \\max\\{S(N,j) - K, 0\\}  \\text{if } S(N,j)  B \\end{cases} $$\n这定义了在最终时间步所有 $j \\in \\{0, 1, \\dots, N\\}$ 的期权价值。\n\n接下来，我们从时间 $i = N-1$ 向后迭代至 $0$。在任意给定节点 $(i, j)$（其中 $i  N$），确定期权价值 $V(i, j)$。我们再次首先检查当前节点的障碍条件。如果 $S(i, j) \\ge B$，期权被敲出，因此其价值设为 $0$。如果 $S(i, j)  B$，该节点是“存活”的，其价值是后续两个节点 $(i+1, j+1)$ 和 $(i+1, j)$ 价值的折现风险中性期望。\n$$ V(i,j) = \\begin{cases} 0  \\text{if } S(i,j) \\ge B \\\\ e^{-r \\Delta t} \\left[ p \\cdot V(i+1, j+1) + (1-p) \\cdot V(i+1, j) \\right]  \\text{if } S(i,j)  B \\end{cases} $$\n对时间步 $i$ 的所有节点执行此递归计算。对 $i = N-2, N-3, \\dots, 0$ 重复此过程。最终结果是在单个初始节点 $V(0, 0)$ 的价值，它代表了期权在时间 $t=0$ 的无套利价格。\n\n该算法通过初始化一个大小为 $N+1$ 的数组，其中包含终端期权价值 $V(N, j)$ 来实现。然后，在一个从 $i=N-1$ 向下到 $0$ 的循环中，此数组被原地更新以保存时间步 $i$ 的价值。在每个时间步 $i$，对 $j$ 的循环从 $0$ 到 $i$ 运行，用新计算的值覆盖先前的值。最终价格是循环结束后数组中剩下的单个元素。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the price of an up-and-out European call option for a suite of test cases\n    and formats the output as specified.\n    \"\"\"\n    test_cases = [\n        # Case A: General consistency where the barrier is effectively never reached\n        (100, 100, 1e9, 0.05, 0.2, 1, 100),\n        # Case B: Immediate knockout at inception\n        (100, 100, 100, 0.05, 0.2, 1, 100),\n        # Case C: Deep in-the-money with a nearby barrier\n        (120, 90, 125, 0.03, 0.25, 1, 200),\n        # Case D: Single-step short maturity\n        (100, 110, 130, 0.01, 0.15, 0.25, 1),\n        # Case E: Far out-of-the-money with unreachable strike under the tree\n        (90, 200, 1e9, 0.02, 0.1, 1, 50),\n    ]\n\n    results = []\n    for case in test_cases:\n        S0, K, B, r, sigma, T, N = case\n        price = price_up_and_out_call(S0, K, B, r, sigma, T, N)\n        results.append(round(price, 10))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef price_up_and_out_call(S0, K, B, r, sigma, T, N):\n    \"\"\"\n    Prices a discretely monitored up-and-out European call option using a \n    multi-period Cox-Ross-Rubinstein binomial model.\n\n    Args:\n        S0 (float): Initial stock price.\n        K (float): Strike price.\n        B (float): Barrier level.\n        r (float): Risk-free interest rate (continuously compounded).\n        sigma (float): Volatility.\n        T (float): Time to maturity in years.\n        N (int): Number of periods in the binomial tree.\n\n    Returns:\n        float: The arbitrage-free price of the option.\n    \"\"\"\n    # 1. Initial knockout check\n    if S0 >= B:\n        return 0.0\n\n    # 2. Calculate model parameters\n    dt = T / N\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1 / u\n    # The condition d  e^(r*dt)  u is guaranteed by the problem statement.\n    p = (np.exp(r * dt) - d) / (u - d)\n    discount = np.exp(-r * dt)\n\n    # 3. Initialize option values at maturity (time N)\n    # This array will store option values. Its size is N+1.\n    option_values = np.zeros(N + 1)\n    \n    for j in range(N + 1):\n        # State at node (N, j) corresponds to j up-moves and N-j down-moves\n        S_terminal = S0 * (u**j) * (d**(N - j))\n        \n        # Check barrier at maturity\n        if S_terminal >= B:\n            option_values[j] = 0.0\n        else:\n            option_values[j] = max(S_terminal - K, 0.0)\n\n    # 4. Perform backward induction from time N-1 to 0\n    # The `option_values` array is updated in-place.\n    # At step i, `option_values` holds values from step i+1.\n    for i in range(N - 1, -1, -1):\n        for j in range(i + 1):\n            # State at node (i, j)\n            S_current = S0 * (u**j) * (d**(i - j))\n\n            # Check barrier at current node\n            if S_current >= B:\n                option_values[j] = 0.0\n            else:\n                # Risk-neutral expectation of values from time i+1\n                # V(i+1, j+1) is in option_values[j+1]\n                # V(i+1, j) is in option_values[j]\n                expected_value = p * option_values[j + 1] + (1 - p) * option_values[j]\n                option_values[j] = discount * expected_value\n    \n    # The final price is the value at node (0,0)\n    return option_values[0]\n\nsolve()\n```"
        }
    ]
}