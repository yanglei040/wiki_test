{
    "hands_on_practices": [
        {
            "introduction": "本练习是多维伊藤引理的一个经典应用。我们将看到，一个简单的二维随机游走，当从其与原点的距离的角度观察时，会产生一个新的、带有一个非平凡漂移项的一维过程——这正是“伊藤修正项”的直接结果。这个实践将加深你对几何曲率如何在随机微积分中表现为漂移的理解 。",
            "id": "2404268",
            "problem": "在计算金融学中，多因子模型常使用独立的布朗驱动来模拟风险因子。设 $\\{X_t\\}_{t \\ge 0}$ 和 $\\{Y_t\\}_{t \\ge 0}$ 为定义在一个满足通常条件的带滤概率空间上的独立标准维纳过程（标准布朗运动），具有确定性初始值 $X_0 = x_0$ 和 $Y_0 = y_0$。定义径向过程 $R_t = \\sqrt{X_t^2 + Y_t^2}$ 并假设 $r_0 = \\sqrt{x_0^2 + y_0^2} > 0$，使得在所考虑的时间范围内，$R_t > 0$ 几乎必然成立。\n\n将 $R_t$ 视为状态 $(X_t,Y_t)$ 的光滑函数，并仅从标准维纳过程的定义和连续半鞅的微分法则（特别是独立维纳过程的二次变差性质）出发，推导 $R_t$ 满足的随机微分方程。根据你的推导，确定以下表达式中的漂移系数 $b(r)$ 和扩散系数 $\\sigma(r)$：\n$$\n\\mathrm{d}R_t \\;=\\; b(R_t)\\,\\mathrm{d}t \\;+\\; \\sigma(R_t)\\,\\mathrm{d}W_t,\n$$\n其中 $\\{W_t\\}_{t \\ge 0}$ 是一个适应于同一滤的一维标准维纳过程。\n\n答案规格：\n- 将你的最终答案表示为有序函数对 $(b(r), \\sigma(r))$，按此顺序，并使用变量 $r$ 作为参数，以行矩阵的形式表达。\n- 最终答案必须是单一的解析表达式，不带单位。无需数值取舍。",
            "solution": "给定独立的标准维纳过程 $\\{X_t\\}_{t \\ge 0}$ 和 $\\{Y_t\\}_{t \\ge 0}$，其二次变差和二次协变差为\n$$\n\\mathrm{d}\\langle X \\rangle_t = \\mathrm{d}t, \n\\quad \n\\mathrm{d}\\langle Y \\rangle_t = \\mathrm{d}t, \n\\quad \n\\mathrm{d}\\langle X, Y \\rangle_t = 0,\n$$\n我们定义 $R_t = f(X_t, Y_t)$，其中 $f(x,y) = \\sqrt{x^2 + y^2}$。我们假设在所关心的时间范围内 $R_t > 0$，因此 $f$ 在相关的状态区域上是光滑的，且下文的导数是良定义的。\n\n我们计算 $f$ 的一阶和二阶偏导数。令 $r = \\sqrt{x^2 + y^2}$。则\n$$\nf_x(x,y) = \\frac{\\partial f}{\\partial x}(x,y) = \\frac{x}{r}, \n\\qquad\nf_y(x,y) = \\frac{\\partial f}{\\partial y}(x,y) = \\frac{y}{r}.\n$$\n对于二阶导数，\n$$\nf_{xx}(x,y) = \\frac{\\partial}{\\partial x}\\!\\left(\\frac{x}{r}\\right) \n= \\frac{1}{r} - \\frac{x^2}{r^3} \n= \\frac{r^2 - x^2}{r^3} \n= \\frac{y^2}{r^3},\n$$\n$$\nf_{yy}(x,y) = \\frac{\\partial}{\\partial y}\\!\\left(\\frac{y}{r}\\right) \n= \\frac{1}{r} - \\frac{y^2}{r^3} \n= \\frac{r^2 - y^2}{r^3} \n= \\frac{x^2}{r^3},\n$$\n混合偏导数为\n$$\nf_{xy}(x,y) = \\frac{\\partial}{\\partial y}\\!\\left(\\frac{x}{r}\\right) \n= - \\frac{x y}{r^3}.\n$$\n\n对 $R_t = f(X_t, Y_t)$ 应用多维形式的伊藤引理，得到\n$$\n\\mathrm{d}R_t \n= f_x(X_t, Y_t)\\,\\mathrm{d}X_t + f_y(X_t, Y_t)\\,\\mathrm{d}Y_t \n+ \\frac{1}{2}\\Big( f_{xx}(X_t, Y_t)\\,\\mathrm{d}\\langle X \\rangle_t \n+ 2 f_{xy}(X_t, Y_t)\\,\\mathrm{d}\\langle X, Y \\rangle_t \n+ f_{yy}(X_t, Y_t)\\,\\mathrm{d}\\langle Y \\rangle_t \\Big).\n$$\n利用二次变差关系和独立性，我们代入 $\\mathrm{d}\\langle X \\rangle_t = \\mathrm{d}t$、$\\mathrm{d}\\langle Y \\rangle_t = \\mathrm{d}t$ 和 $\\mathrm{d}\\langle X, Y \\rangle_t = 0$，得到\n$$\n\\mathrm{d}R_t \n= \\frac{X_t}{R_t}\\,\\mathrm{d}X_t + \\frac{Y_t}{R_t}\\,\\mathrm{d}Y_t \n+ \\frac{1}{2}\\left( \\frac{Y_t^2}{R_t^3} + \\frac{X_t^2}{R_t^3} \\right)\\mathrm{d}t \n= \\frac{X_t}{R_t}\\,\\mathrm{d}X_t + \\frac{Y_t}{R_t}\\,\\mathrm{d}Y_t \n+ \\frac{1}{2}\\left( \\frac{X_t^2 + Y_t^2}{R_t^3} \\right)\\mathrm{d}t.\n$$\n由于 $R_t^2 = X_t^2 + Y_t^2$，漂移项简化为\n$$\n\\frac{1}{2}\\left( \\frac{R_t^2}{R_t^3} \\right)\\mathrm{d}t = \\frac{1}{2 R_t}\\,\\mathrm{d}t.\n$$\n因此，\n$$\n\\mathrm{d}R_t \n= \\frac{1}{2 R_t}\\,\\mathrm{d}t + \\frac{X_t}{R_t}\\,\\mathrm{d}X_t + \\frac{Y_t}{R_t}\\,\\mathrm{d}Y_t.\n$$\n\n我们现在分析扩散项\n$$\nM_t := \\int_0^t \\frac{X_s}{R_s}\\,\\mathrm{d}X_s + \\int_0^t \\frac{Y_s}{R_s}\\,\\mathrm{d}Y_s.\n$$\n其二次变差为\n$$\n\\mathrm{d}\\langle M \\rangle_t \n= \\left(\\frac{X_t}{R_t}\\right)^2 \\mathrm{d}\\langle X \\rangle_t \n+ \\left(\\frac{Y_t}{R_t}\\right)^2 \\mathrm{d}\\langle Y \\rangle_t \n+ 2 \\frac{X_t}{R_t}\\frac{Y_t}{R_t} \\mathrm{d}\\langle X, Y \\rangle_t\n= \\left( \\frac{X_t^2 + Y_t^2}{R_t^2} \\right)\\mathrm{d}t \n= \\mathrm{d}t.\n$$\n因此，$M_t$ 是一个二次变差为单位1的连续局部鞅，故存在一个适应于同一滤的一维标准维纳过程 $\\{W_t\\}_{t \\ge 0}$，使得\n$$\n\\frac{X_t}{R_t}\\,\\mathrm{d}X_t + \\frac{Y_t}{R_t}\\,\\mathrm{d}Y_t = \\mathrm{d}W_t.\n$$\n因此，\n$$\n\\mathrm{d}R_t = \\frac{1}{2 R_t}\\,\\mathrm{d}t + \\mathrm{d}W_t.\n$$\n\n与表达式 $\\mathrm{d}R_t = b(R_t)\\,\\mathrm{d}t + \\sigma(R_t)\\,\\mathrm{d}W_t$ 进行比较，我们确定\n$$\nb(r) = \\frac{1}{2 r}, \n\\qquad \n\\sigma(r) = 1,\n$$\n对于 $r > 0$。这些是二维贝塞尔过程的漂移系数和扩散系数，该过程是二维布朗运动的径向部分。",
            "answer": "$$\\boxed{\\begin{pmatrix}\\frac{1}{2r}  1\\end{pmatrix}}$$"
        },
        {
            "introduction": "伊藤引理不仅用于寻找一个函数的动态过程，它也是一个用以*求解*复杂随机微分方程（SDE）的强大工具。在这个问题中，我们将通过巧妙地选择一个变量变换，将一个非线性SDE简化为可解形式。这个实践展示了应用数学工具时所需的创造性，并突显了引理作为解决问题基石的角色 。",
            "id": "2404213",
            "problem": "考虑连续时间金融中的随机微分方程 (SDE)\n$$\ndX_t = X_t^{3}\\,dt + X_t^{2}\\,dZ_t,\\quad X_0 = x_0 \\neq 0,\n$$\n其中 $\\{Z_t\\}_{t \\ge 0}$ 是一个标准布朗运动（维纳过程），且 $Z_0 = 0$。我们在一个满足通常条件的带滤概率空间上进行研究，并以 Itō 意义解释该 SDE。求出显式强解 $X_t$，其形式为关于 $x_0$ 和 $Z_t$ 的封闭解析表达式。你的最终答案必须是单一的解析表达式。如果你的答案涉及任何停时考虑，请在你的推理中陈述，但不要将其包含在最终表达式中。",
            "solution": "问题陈述经过验证，是有效的。这是一个随机分析中适定的问题。给定的随机微分方程 (SDE) 是：\n$$\ndX_t = X_t^{3}\\,dt + X_t^{2}\\,dZ_t\n$$\n初始条件为 $X_0 = x_0$，其中 $x_0 \\neq 0$。过程 $\\{Z_t\\}_{t \\ge 0}$ 是一个标准布朗运动。\n\n漂移系数 $\\mu(x) = x^3$ 和扩散系数 $\\sigma(x) = x^2$ 不满足全局线性增长条件。也就是说，不存在常数 $K$ 使得对所有 $x \\in \\mathbb{R}$ 都有 $|\\mu(x)| \\le K(1 + |x|)$ 和 $|\\sigma(x)| \\le K(1 + |x|)$。这表明解可能在有限时间内发生爆炸。问题是求出强解的显式公式，该解可能只在某个随机停时之前存在。\n\n为了解这个 SDE，我们寻求对过程 $X_t$ 进行变换。令 $Y_t = f(X_t)$，其中 $f$ 是某个二阶可微函数。根据 Itō 引理，$Y_t$ 的微分由下式给出：\n$$\ndY_t = f'(X_t) dX_t + \\frac{1}{2} f''(X_t) (dX_t)^2\n$$\n将给定的 SDE 代入 $dX_t$ 并使用 Itō 乘法规则 $(dZ_t)^2 = dt$，$(dt)^2 = 0$ 和 $dt\\,dZ_t = 0$，我们得到：\n$$\n(dX_t)^2 = (X_t^{3}\\,dt + X_t^{2}\\,dZ_t)^2 = (X_t^2)^2 (dZ_t)^2 + (\\text{terms with } dt) = X_t^4 dt\n$$\n因此，$Y_t$ 的 SDE 变为：\n$$\ndY_t = f'(X_t) (X_t^{3}\\,dt + X_t^{2}\\,dZ_t) + \\frac{1}{2} f''(X_t) X_t^4 dt\n$$\n将 $dt$ 和 $dZ_t$ 项分组：\n$$\ndY_t = \\left[ X_t^3 f'(X_t) + \\frac{1}{2} X_t^4 f''(X_t) \\right] dt + X_t^2 f'(X_t) dZ_t\n$$\n我们的目标是选择一个函数 $f$ 来简化这个方程。一个标准技巧是消除扩散系数中对 $X_t$ 的依赖。我们将 $dZ_t$ 的系数设为一个常数。我们选择这个常数为 $-1$：\n$$\nX_t^2 f'(X_t) = -1\n$$\n这意味着 $f'(x) = -x^{-2}$。这个关于 $f(x)$ 的常微分方程可以通过积分求解：\n$$\nf(x) = \\int -x^{-2} \\,dx = \\frac{1}{x} + C\n$$\n为简单起见，我们可以选择积分常数 $C=0$，得到变换 $f(x) = 1/x$。这个变换是适定的，因为初始条件 $X_0 = x_0 \\neq 0$，并且可以证明，如果过程 $X_t$ 从一个非零值开始，它几乎必然不会达到 $0$。$f(x)$ 的一阶和二阶导数是：\n$$\nf'(x) = -x^{-2} \\quad \\text{and} \\quad f''(x) = 2x^{-3}\n$$\n现在我们将这些导数代入 $Y_t$ 的 SDE 的漂移项：\n$$\n\\text{Drift term} = X_t^3 f'(X_t) + \\frac{1}{2} X_t^4 f''(X_t) = X_t^3 (-X_t^{-2}) + \\frac{1}{2} X_t^4 (2X_t^{-3}) = -X_t + X_t = 0\n$$\n漂移项消失了。$Y_t$ 的 SDE 极大地简化为：\n$$\ndY_t = 0 \\cdot dt - 1 \\cdot dZ_t = -dZ_t\n$$\n这是一个简单的 SDE，可以通过从 $t=0$ 到 $t$ 的直接积分来求解：\n$$\n\\int_0^t dY_s = - \\int_0^t dZ_s\n$$\n这给出：\n$$\nY_t - Y_0 = -(Z_t - Z_0)\n$$\n已知 $Z_0=0$ 且 $Y_0 = f(X_0) = 1/X_0 = 1/x_0$，我们有：\n$$\nY_t - \\frac{1}{x_0} = -Z_t\n$$\n解出 $Y_t$：\n$$\nY_t = \\frac{1}{x_0} - Z_t\n$$\n最后，我们使用关系式 $X_t = 1/Y_t$ 变换回原过程 $X_t$：\n$$\nX_t = \\frac{1}{Y_t} = \\frac{1}{\\frac{1}{x_0} - Z_t}\n$$\n通过分子分母同乘以 $x_0$ 可以简化这个表达式：\n$$\nX_t = \\frac{x_0}{1 - x_0 Z_t}\n$$\n这就是过程 $X_t$ 的显式强解。只要分母不为零，解就存在。令 $\\tau$ 为停时，定义为 $\\tau = \\inf\\{t0 \\mid 1 - x_0 Z_t = 0\\}$。这是过程 $Z_t$ 首次达到水平 $1/x_0$ 的时间。对于标准的一维布朗运动，这个时间几乎必然是有限的。因此，解 $X_t$ 以概率 $1$ 在有限时间内爆炸到无穷大。我们找到的表达式是 $t \\in [0, \\tau)$ 时的解。\n\n为了验证解，我们可以对函数 $g(z) = \\frac{x_0}{1-x_0 z}$ 应用 Itō 引理，其中 $X_t = g(Z_t)$。其导数为 $g'(z) = \\frac{x_0^2}{(1-x_0 z)^2}$ 和 $g''(z) = \\frac{2x_0^3}{(1-x_0 z)^3}$。用 $X_t$ 表示，它们变为 $g'(Z_t) = X_t^2$ 和 $g''(Z_t) = 2X_t^3$。\n对 $X_t = g(Z_t)$ 应用 Itō 引理：\n$$\ndX_t = g'(Z_t)dZ_t + \\frac{1}{2}g''(Z_t)(dZ_t)^2 = X_t^2 dZ_t + \\frac{1}{2}(2X_t^3)dt = X_t^3 dt + X_t^2 dZ_t\n$$\n这与原始 SDE 相符，从而证实了解的正确性。",
            "answer": "$$\n\\boxed{\\frac{x_0}{1 - x_0 Z_t}}\n$$"
        },
        {
            "introduction": "我们如何确定我们的连续时间公式在计算机模拟的离散世界中仍然成立？这最后一个练习将弥合抽象理论与计算实践之间的鸿沟。你将模拟一条几何布朗运动路径，并数值验证从伊藤引理推导出的关于价格对数动态的著名结果，看其是否能在高精度下成立。这项练习强调了该引理在现代计算金融中的实际重要性 。",
            "id": "2404258",
            "problem": "考虑一个单资产价格过程，其被建模为几何布朗运动 (GBM)，由以下随机微分方程 (SDE) 定义\n$$\n\\mathrm{d}S_t=\\mu S_t\\,\\mathrm{d}t+\\sigma S_t\\,\\mathrm{d}W_t,\n$$\n其中 $S_t$ 是在时间 $t$ 的资产价格，$\\mu$ 是常数漂移率，$\\sigma$ 是常数波动率，$W_t$ 是一个标准维纳过程 (布朗运动)。令 $f(s)=\\ln(s)$，并用 $\\Delta \\ln(S)$ 表示在一个小的时间步长 $\\Delta t$ 内实现的离散变化 $\\ln(S_{t_{k+1}})-\\ln(S_{t_k})$。\n\n对上述 GBM 应用 Itô 引理于 $f(s)=\\ln(s)$，确定 $\\ln(S_t)$ 瞬时变化的公式，并用它来指定单步内 $\\ln(S)$ 的预测离散增量，用 $\\mu$、$\\sigma$、$\\Delta t$ 以及布朗增量 $\\Delta W_k:=W_{t_{k+1}}-W_{t_k}$ 来表示。然后，对于下方的每个测试用例，在时间区间 $[0,T]$ 上，使用一个均匀网格 $0=t_0  t_1  \\dots  t_N = T$（其中 $\\Delta t = T/N$）进行模拟，并验证实现的对数增量与你的预测公式在数值上是否一致。如果所有步骤中两者之间的最大绝对差异小于 $10^{-10}$，则该测试用例通过。以布尔值列表的形式返回所有测试用例的结果。",
            "solution": "在尝试解决方案之前，需要对问题陈述进行验证。\n\n步骤 1：提取已知条件\n- 资产价格过程：几何布朗运动 (GBM)，由随机微分方程 (SDE) $\\mathrm{d}S_t=\\mu S_t\\,\\mathrm{d}t+\\sigma S_t\\,\\mathrm{d}W_t$ 定义。\n- 参数：$\\mu$ 是常数漂移率，$\\sigma$ 是常数波动率。\n- 随机过程：$W_t$ 是一个标准维纳过程。\n- 目标函数：$f(s)=\\ln(s)$。\n- 离散变化定义：$\\Delta \\ln(S)$ 是实现的离散变化 $\\ln(S_{t_{k+1}})-\\ln(S_{t_k})$。\n- 布朗增量定义：$\\Delta W_k := W_{t_{k+1}}-W_{t_k}$。\n- 时间网格：均匀网格 $0=t_0  t_1  \\dots  t_N = T$，时间步长 $\\Delta t=T/N$。\n- 任务：1) 推导 $\\ln(S)$ 的离散增量公式。2) 对每个测试用例运行模拟。3) 比较实现的 $\\Delta \\ln(S)$ 和预测的 $\\Delta \\ln(S)$。4) 检查最大绝对差异是否小于 $10^{-10}$。5) 返回一个布尔值列表。\n\n步骤 2：应用 Itô 引理\n对于 $f(S_t)=\\ln(S_t)$，其偏导数为 $f'(s)=1/s$ 和 $f''(s)=-1/s^2$。GBM 过程的漂移为 $\\mu S_t$，扩散为 $\\sigma S_t$。\n根据 Itô 引理：\n$$\n\\mathrm{d}f(S_t) = \\left( \\frac{\\partial f}{\\partial t} + \\mu S_t \\frac{\\partial f}{\\partial s} + \\frac{1}{2}(\\sigma S_t)^2 \\frac{\\partial^2 f}{\\partial s^2} \\right)\\mathrm{d}t + \\sigma S_t \\frac{\\partial f}{\\partial s}\\mathrm{d}W_t\n$$\n代入 $f(S_t)=\\ln(S_t)$ 的导数：\n$$\n\\mathrm{d}(\\ln S_t) = \\left( 0 + \\mu S_t \\left(\\frac{1}{S_t}\\right) + \\frac{1}{2}\\sigma^2 S_t^2 \\left(-\\frac{1}{S_t^2}\\right) \\right)\\mathrm{d}t + \\sigma S_t \\left(\\frac{1}{S_t}\\right)\\mathrm{d}W_t\n$$\n简化后得到 $\\ln(S_t)$ 的 SDE：\n$$\n\\mathrm{d}(\\ln S_t) = \\left(\\mu - \\frac{1}{2}\\sigma^2\\right)\\mathrm{d}t + \\sigma\\,\\mathrm{d}W_t\n$$\n这个过程是一个带有常数漂移和扩散的算术布朗运动。\n\n步骤 3：离散化\n对上述 SDE 进行积分得到从 $t_k$ 到 $t_{k+1}$ 的离散增量：\n$$\n\\ln(S_{t_{k+1}}) - \\ln(S_{t_k}) = \\int_{t_k}^{t_{k+1}} \\left(\\mu - \\frac{1}{2}\\sigma^2\\right)\\mathrm{d}t + \\int_{t_k}^{t_{k+1}} \\sigma\\,\\mathrm{d}W_t\n$$\n这得到了精确的离散化方案：\n$$\n\\Delta \\ln(S) = \\left(\\mu - \\frac{1}{2}\\sigma^2\\right)\\Delta t + \\sigma \\Delta W_k\n$$\n这就是**预测的对数增量**。\n\n步骤 4：模拟与验证\n模拟 GBM 路径通常使用其精确解，该解正是从上述 $\\ln(S_t)$ 的 SDE 推导出来的：\n$$\nS_{t_{k+1}} = S_{t_k} \\exp\\left( \\left(\\mu - \\frac{1}{2}\\sigma^2\\right)\\Delta t + \\sigma \\Delta W_k \\right)\n$$\n因此，**实现的对数增量**为：\n$$\n\\ln(S_{t_{k+1}}) - \\ln(S_{t_k}) = \\ln\\left( \\frac{S_{t_{k+1}}}{S_{t_k}} \\right) = \\ln\\left( \\exp\\left( \\left(\\mu - \\frac{1}{2}\\sigma^2\\right)\\Delta t + \\sigma \\Delta W_k \\right) \\right)\n$$\n$$\n\\Delta \\ln(S)_{\\text{realized}} = \\left(\\mu - \\frac{1}{2}\\sigma^2\\right)\\Delta t + \\sigma \\Delta W_k\n$$\n理论上，**实现的对数增量**和**预测的对数增量**是完全相同的。任何差异都将归因于计算机中的浮点算术误差（例如，$\\ln(\\exp(x))$ 可能不完全等于 $x$）。因此，我们期望它们之间的最大绝对差异非常小，并且应该小于给定的容差 $10^{-10}$。\n\n步骤 5：代码实现\n该逻辑将在 Python 代码中实现，对每个测试用例执行以下操作：\n1.  为给定的 `seed` 初始化随机数生成器。\n2.  生成 $N$ 个布朗增量 $\\Delta W_k \\sim \\mathcal{N}(0, \\Delta t)$。\n3.  使用公式计算预测的对数增量序列。\n4.  使用指数形式的精确解构建 $S_t$ 的模拟路径。\n5.  从模拟路径计算实现的对数增量序列。\n6.  计算两个序列之间的最大绝对差异。\n7.  将该差异与 $10^{-10}$ 进行比较，并将结果（`True` 或 `False`）存储起来。\n8.  以指定格式打印最终的布尔值列表。\n\n特殊情况：\n- 如果 $\\sigma=0$，GBM 变为确定性 ODE $\\mathrm{d}S_t = \\mu S_t \\mathrm{d}t$，解为 $S_t = S_0 e^{\\mu t}$。$\\ln(S_t)$ 的 SDE 变为 $\\mathrm{d}(\\ln S_t) = \\mu \\mathrm{d}t$。我们的公式仍然成立。\n- 如果 $T=0$ 或 $N=0$，则没有步数，最大差异应定义为 0，因此测试通过。代码将正确处理这种情况。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by deriving the discrete log-increment formula from Ito's lemma,\n    simulating GBM paths, and comparing realized vs. predicted increments.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (S0, mu, sigma, T, N, seed)\n        (100.0, 0.08, 0.2, 1.0, 5000, 11),\n        (100.0, 0.05, 0.0, 1.0, 100, 13),\n        (250.0, 0.0, 0.3, 2.0, 2000, 17),\n        (50.0, -0.1, 0.15, 1.5, 1500, 19),\n        (1.0, 0.2, 0.4, 0.0, 1, 23),\n    ]\n\n    results = []\n    tolerance = 1e-10\n\n    for case in test_cases:\n        s0, mu, sigma, T, N, seed = case\n        \n        # N must be an integer\n        N = int(N)\n\n        # Handle the case where T=0 or N=0. The max over an empty set of steps should pass.\n        if N == 0 or T == 0:\n            results.append(True)\n            continue\n            \n        # Set seed for reproducibility\n        np.random.seed(seed)\n\n        # Calculate time step\n        dt = T / N\n\n        # 1. Generate Brownian increments dW ~ N(0, dt)\n        # We generate N standard normal variables Z and scale them.\n        Z = np.random.standard_normal(N)\n        dW = Z * np.sqrt(dt)\n\n        # 2. Calculate the sequence of predicted log-increments from Ito's lemma\n        # d(lnS) = (mu - 0.5*sigma^2)dt + sigma*dW\n        predicted_log_increments = (mu - 0.5 * sigma**2) * dt + sigma * dW\n\n        # 3. Construct the simulated path for S_t.\n        # S_{t+dt} = S_t * exp((mu - 0.5*sigma^2)dt + sigma*dW)\n        # This can be done vectorially for efficiency.\n        # First, compute the cumulative product of the exponential terms.\n        # S[k] = S0 * product(exp(predicted_increments[i])) for i=0 to k-1\n        s_path = np.zeros(N + 1)\n        s_path[0] = s0\n        # The cumulative product builds the path S_1, S_2, ...\n        s_path[1:] = s0 * np.cumprod(np.exp(predicted_log_increments))\n\n        # 4. Compute the sequence of realized log-increments\n        # delta_ln_S = ln(S_{k+1}) - ln(S_k)\n        # Suppress \"divide by zero\" or \"invalid value\" warnings for log if S becomes 0,\n        # although this is extremely unlikely with standard parameters.\n        with np.errstate(divide='ignore', invalid='ignore'):\n            log_s_path = np.log(s_path)\n        \n        # Check for -inf or nan in log_s_path, which would indicate S hit 0 or below.\n        if np.any(np.isneginf(log_s_path)) or np.any(np.isnan(log_s_path)):\n             # This path is numerically unstable, discrepancy is likely large.\n             # This case should not happen with the given parameters but is a robust check.\n             max_discrepancy = np.inf\n        else:\n            realized_log_increments = np.diff(log_s_path)\n    \n            # 5. Compute the maximum absolute discrepancy\n            # The discrepancy at each step is due to floating point error in log(exp(x)) != x\n            discrepancies = np.abs(realized_log_increments - predicted_log_increments)\n            max_discrepancy = np.max(discrepancies)\n\n        # 6. Check if the pass criterion is met\n        pass_criterion_met = max_discrepancy  tolerance\n        results.append(str(pass_criterion_met))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}