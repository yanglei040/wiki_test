{
    "hands_on_practices": [
        {
            "introduction": "在深入探讨资本资产定价模型（CAPM）的复杂性之前，我们首先需要掌握其核心参数——$\\alpha$ 和 $\\beta$——的估计方法。这个练习将引导你从零开始，仅使用基本的矩阵运算，通过普通最小二乘法（OLS）来手动实现CAPM的估计过程。这不仅能加深你对模型底层数学原理的理解，也为你将来进行更复杂的计量经济学分析奠定坚实的基础。",
            "id": "2378983",
            "problem": "给定某个资产、市场以及无风险利率的多个时间序列数据样本。对于每个样本，假设资本资产定价模型 (CAPM) 的形式如下：\n$$\nr_{i,t} - r_{f,t} = \\alpha + \\beta \\left(r_{m,t} - r_{f,t}\\right) + \\varepsilon_t,\n$$\n其中周期由 $t = 1, \\ldots, T$ 索引，$r_{i,t}$ 是资产收益率，$r_{m,t}$ 是市场收益率，$r_{f,t}$ 是无风险收益率，$\\alpha$ 是截距，$\\beta$ 是市场超额收益率的斜率，$\\varepsilon_t$ 是残差。所有收益率均以小数形式提供，而非百分比。\n\n您的任务是为每个样本计算参数对 $(\\hat{\\alpha}, \\hat{\\beta})$，以最小化残差平方和：\n$$\n\\sum_{t=1}^{T} \\left[\\left(r_{i,t} - r_{f,t}\\right) - \\left(\\alpha + \\beta \\left(r_{m,t} - r_{f,t}\\right)\\right)\\right]^2.\n$$\n\n请使用以下测试套件。对于每个测试用例，$r_i$ 表示资产收益率序列，$r_m$ 表示市场收益率序列，$r_f$ 表示无风险收益率序列。每个序列都是一个长度为 $T$ 的有序列表。\n\n- 测试用例 1（一般情况，$T=5$）：\n  - $r_m = [\\,0.012,\\, 0.018,\\, -0.005,\\, 0.010,\\, 0.022\\,]$\n  - $r_f = [\\,0.002,\\, 0.002,\\, 0.002,\\, 0.0025,\\, 0.0025\\,]$\n  - $r_i = [\\,0.015,\\, 0.0222,\\, -0.0054,\\, 0.0125,\\, 0.0269\\,]$\n\n- 测试用例 2（观测值最少的边界情况，$T=2$）：\n  - $r_m = [\\,0.02,\\, 0.05\\,]$\n  - $r_f = [\\,0.0,\\, 0.0\\,]$\n  - $r_i = [\\,0.07,\\, 0.16\\,]$\n\n- 测试用例 3（零截距，变化的无风险利率，$T=4$）：\n  - $r_m = [\\,0.01,\\, 0.00,\\, 0.03,\\, -0.02\\,]$\n  - $r_f = [\\,0.002,\\, 0.002,\\, 0.0025,\\, 0.0015\\,]$\n  - $r_i = [\\,0.014,\\, -0.001,\\, 0.04375,\\, -0.03075\\,]$\n\n- 测试用例 4（负截距和负斜率，$T=3$）：\n  - $r_m = [\\,0.015,\\, -0.010,\\, 0.005\\,]$\n  - $r_f = [\\,0.001,\\, 0.0015,\\, 0.001\\,]$\n  - $r_i = [\\,-0.008,\\, 0.00525,\\, -0.003\\,]$\n\n对于每个测试用例，使用上述准则计算估计值 $(\\hat{\\alpha}, \\hat{\\beta})$。将所有收益率和结果表示为小数（不含百分号）。您的程序应生成单行输出，其中包含四个测试用例的结果，形式为列表的列表，每个内部列表包含 $[\\hat{\\alpha}, \\hat{\\beta}]$，并按测试用例的顺序排列，四舍五入到六位小数。确切的所需输出格式为：\n$$\n[[\\hat{\\alpha}_1,\\hat{\\beta}_1],[\\hat{\\alpha}_2,\\hat{\\beta}_2],[\\hat{\\alpha}_3,\\hat{\\beta}_3],[\\hat{\\alpha}_4,\\hat{\\beta}_4]]\n$$\n打印在单行上，值和列表之间用逗号分隔，每个浮点数精确显示小数点后六位数字。",
            "solution": "本题是计量经济学中的一个标准练习，要求使用普通最小二乘法 (OLS) 估计资本资产定价模型 (CAPM) 的参数。我将首先根据要求的协议验证问题陈述。\n\n### 步骤 1：提取已知条件\n\n问题提供了以下内容：\n\n- CAPM 方程：\n$$\nr_{i,t} - r_{f,t} = \\alpha + \\beta \\left(r_{m,t} - r_{f,t}\\right) + \\varepsilon_t\n$$\n其中 $t = 1, \\ldots, T$。变量定义为资产收益率 ($r_{i,t}$)、市场收益率 ($r_{m,t}$)、无风险收益率 ($r_{f,t}$)、截距 ($\\alpha$)、斜率 ($\\beta$) 和残差 ($\\varepsilon_t$) 。\n\n- 需要最小化的目标函数是残差平方和 (SSR)：\n$$\n\\sum_{t=1}^{T} \\left[\\left(r_{i,t} - r_{f,t}\\right) - \\left(\\alpha + \\beta \\left(r_{m,t} - r_{f,t}\\right)\\right)\\right]^2\n$$\n\n- $r_m$、$r_f$ 和 $r_i$ 的四个时间序列数据测试用例：\n  - 测试用例 1 ($T=5$):\n    - $r_m = [\\,0.012,\\, 0.018,\\, -0.005,\\, 0.010,\\, 0.022\\,]$\n    - $r_f = [\\,0.002,\\, 0.002,\\, 0.002,\\, 0.0025,\\, 0.0025\\,]$\n    - $r_i = [\\,0.015,\\, 0.0222,\\, -0.0054,\\, 0.0125,\\, 0.0269\\,]$\n  - 测试用例 2 ($T=2$):\n    - $r_m = [\\,0.02,\\, 0.05\\,]$\n    - $r_f = [\\,0.0,\\, 0.0\\,]$\n    - $r_i = [\\,0.07,\\, 0.16\\,]$\n  - 测试用例 3 ($T=4$):\n    - $r_m = [\\,0.01,\\, 0.00,\\, 0.03,\\, -0.02\\,]$\n    - $r_f = [\\,0.002,\\, 0.002,\\, 0.0025,\\, 0.0015\\,]$\n    - $r_i = [\\,0.014,\\, -0.001,\\, 0.04375,\\, -0.03075\\,]$\n  - 测试用例 4 ($T=3$):\n    - $r_m = [\\,0.015,\\, -0.010,\\, 0.005\\,]$\n    - $r_f = [\\,0.001,\\, 0.0015,\\, 0.001\\,]$\n    - $r_i = [\\,-0.008,\\, 0.00525,\\, -0.003\\,]$\n\n- 要求的输出是一个单行字符串，表示一个列表的列表，每个内部列表包含估计参数 $[\\hat{\\alpha}, \\hat{\\beta}]$，四舍五入到六位小数。\n\n### 步骤 2：使用提取的已知条件进行验证\n\n根据既定标准对问题进行验证。\n\n- **科学依据**：该问题是线性回归（一种基础统计方法）在金融经济学基石模型 CAPM 中的应用。它在科学上是合理的，并且是该领域的经典范例。\n- **适定性**：问题在于找到最小化平方和的参数，这定义了一个标准的普通最小二乘法 (OLS) 估计。当且仅当自变量（市场超额收益率）不为常数时，$(\\hat{\\alpha}, \\hat{\\beta})$ 的唯一解才存在。对于所有给定的测试用例，市场超额收益率序列都存在变动，从而确保了唯一解的存在。$T=2$ 的情况（测试用例 2）是一个边界条件，其中两个参数由两个数据点精确确定，这是一个明确定义的数学问题。\n- **客观性**：该问题由精确的数学方程和客观的数值数据构成。没有主观或含糊不清的陈述。\n- **不完整或矛盾的设置**：问题是自洽的。所有必要的数据和定义都已提供。没有矛盾之处。\n\n### 步骤 3：结论与行动\n\n问题陈述是 **有效的**。这是一个清晰、一致且适定的问题，其基础是成熟的金融和统计理论。我现在将继续进行求解。\n\n### 求解推导\n\n问题是通过最小化残差平方和来找到参数 $\\hat{\\alpha}$ 和 $\\hat{\\beta}$。这是普通最小二乘法 (OLS) 的经典应用。让我们定义资产超额收益率为 $y_t = r_{i,t} - r_{f,t}$，市场超额收益率为 $x_t = r_{m,t} - r_{f,t}$。模型简化为简单的线性回归：\n$$\ny_t = \\alpha + \\beta x_t + \\varepsilon_t\n$$\n目标是最小化残差平方和 $S(\\alpha, \\beta)$：\n$$\nS(\\alpha, \\beta) = \\sum_{t=1}^{T} \\varepsilon_t^2 = \\sum_{t=1}^{T} (y_t - \\alpha - \\beta x_t)^2\n$$\n为了找到最小值，我们求 $S$ 关于 $\\alpha$ 和 $\\beta$ 的一阶偏导数，并令它们为零。\n\n关于 $\\alpha$ 的偏导数：\n$$\n\\frac{\\partial S}{\\partial \\alpha} = \\sum_{t=1}^{T} 2(y_t - \\alpha - \\beta x_t)(-1) = -2 \\left( \\sum_{t=1}^{T} y_t - T\\alpha - \\beta \\sum_{t=1}^{T} x_t \\right) = 0\n$$\n这简化为第一个正规方程：\n$$\n\\sum_{t=1}^{T} y_t = T\\hat{\\alpha} + \\hat{\\beta} \\sum_{t=1}^{T} x_t\n$$\n两边除以 $T$，我们得到 $\\bar{y} = \\hat{\\alpha} + \\hat{\\beta}\\bar{x}$，其中 $\\bar{y}$ 和 $\\bar{x}$ 分别是 $y_t$ 和 $x_t$ 的样本均值。这使我们可以将 $\\hat{\\alpha}$ 表示为：\n$$\n\\hat{\\alpha} = \\bar{y} - \\hat{\\beta}\\bar{x}\n$$\n\n关于 $\\beta$ 的偏导数：\n$$\n\\frac{\\partial S}{\\partial \\beta} = \\sum_{t=1}^{T} 2(y_t - \\alpha - \\beta x_t)(-x_t) = -2 \\left( \\sum_{t=1}^{T} x_t y_t - \\alpha \\sum_{t=1}^{T} x_t - \\beta \\sum_{t=1}^{T} x_t^2 \\right) = 0\n$$\n这简化为第二个正规方程：\n$$\n\\sum_{t=1}^{T} x_t y_t = \\hat{\\alpha} \\sum_{t=1}^{T} x_t + \\hat{\\beta} \\sum_{t=1}^{T} x_t^2\n$$\n将 $\\hat{\\alpha}$ 的表达式代入第二个正规方程：\n$$\n\\sum x_t y_t = (\\bar{y} - \\hat{\\beta}\\bar{x}) \\sum x_t + \\hat{\\beta} \\sum x_t^2\n$$\n$$\n\\sum x_t y_t = \\bar{y} \\sum x_t - \\hat{\\beta}\\bar{x} \\sum x_t + \\hat{\\beta} \\sum x_t^2\n$$\n重新整理以求解 $\\hat{\\beta}$：\n$$\n\\hat{\\beta} \\left( \\sum x_t^2 - \\bar{x} \\sum x_t \\right) = \\sum x_t y_t - \\bar{y} \\sum x_t\n$$\n使用 $\\sum x_t = T\\bar{x}$，我们有：\n$$\n\\hat{\\beta} \\left( \\sum x_t^2 - T\\bar{x}^2 \\right) = \\sum x_t y_t - T\\bar{x}\\bar{y}\n$$\n括号中的项分别是样本方差和协方差的分子（没有 $1/T$ 或 $1/(T-1)$ 的缩放因子）。具体来说，$\\sum(x_t-\\bar{x})^2 = \\sum x_t^2 - T\\bar{x}^2$ 和 $\\sum(x_t-\\bar{x})(y_t-\\bar{y}) = \\sum x_t y_t - T\\bar{x}\\bar{y}$。因此，$\\beta$ 的估计量由众所周知的公式给出：\n$$\n\\hat{\\beta} = \\frac{\\sum_{t=1}^{T} (x_t - \\bar{x})(y_t - \\bar{y})}{\\sum_{t=1}^{T} (x_t - \\bar{x})^2} = \\frac{\\text{Cov}(x, y)}{\\text{Var}(x)}\n$$\n该算法的实现将首先为每个测试用例计算序列 $x_t$ 和 $y_t$。然后，计算样本均值 $\\bar{x}$ 和 $\\bar{y}$。最后，使用协方差-方差公式计算 $\\hat{\\beta}$，并利用其与均值和 $\\hat{\\beta}$ 的关系求出 $\\hat{\\alpha}$。此过程将应用于所有四个测试用例。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the CAPM parameters alpha and beta for multiple test cases\n    using Ordinary Least Squares (OLS).\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1 (general case, T=5)\n        {\n            'r_m': np.array([0.012, 0.018, -0.005, 0.010, 0.022]),\n            'r_f': np.array([0.002, 0.002, 0.002, 0.0025, 0.0025]),\n            'r_i': np.array([0.015, 0.0222, -0.0054, 0.0125, 0.0269])\n        },\n        # Test Case 2 (boundary with minimal observations, T=2)\n        {\n            'r_m': np.array([0.02, 0.05]),\n            'r_f': np.array([0.0, 0.0]),\n            'r_i': np.array([0.07, 0.16])\n        },\n        # Test Case 3 (zero intercept, varying risk-free rate, T=4)\n        {\n            'r_m': np.array([0.01, 0.00, 0.03, -0.02]),\n            'r_f': np.array([0.002, 0.002, 0.0025, 0.0015]),\n            'r_i': np.array([0.014, -0.001, 0.04375, -0.03075])\n        },\n        # Test Case 4 (negative intercept and slope, T=3)\n        {\n            'r_m': np.array([0.015, -0.010, 0.005]),\n            'r_f': np.array([0.001, 0.0015, 0.001]),\n            'r_i': np.array([-0.008, 0.00525, -0.003])\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        r_m, r_f, r_i = case['r_m'], case['r_f'], case['r_i']\n\n        # Calculate excess returns\n        # y_t = r_i,t - r_f,t (dependent variable)\n        y = r_i - r_f\n        # x_t = r_m,t - r_f,t (independent variable)\n        x = r_m - r_f\n\n        # Calculate sample means\n        x_bar = np.mean(x)\n        y_bar = np.mean(y)\n\n        # Calculate the OLS estimator for beta (slope)\n        # beta_hat = Cov(x, y) / Var(x)\n        # Numerator: sum of cross-products of deviations from mean\n        numerator = np.sum((x - x_bar) * (y - y_bar))\n        # Denominator: sum of squared deviations from mean for x\n        denominator = np.sum((x - x_bar)**2)\n        \n        # Handle the edge case of T=2 where the fit is perfect but division by zero could occur if x values were identical.\n        # The problem validation confirmed this is not an issue for the given test cases.\n        beta_hat = numerator / denominator\n\n        # Calculate the OLS estimator for alpha (intercept)\n        # alpha_hat = y_bar - beta_hat * x_bar\n        alpha_hat = y_bar - beta_hat * x_bar\n\n        results.append([alpha_hat, beta_hat])\n\n    # Format the final output string exactly as required.\n    # The format [v1,v2] does not have a space after the comma.\n    # Using f-strings with a format specifier ensures exactly six decimal places.\n    formatted_results = []\n    for alpha, beta in results:\n        formatted_results.append(f\"[{alpha:.6f},{beta:.6f}]\")\n    \n    final_output_string = f\"[{','.join(formatted_results)}]\"\n    \n    print(final_output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "理论模型往往建立在理想化的假设之上，但真实世界的金融数据很少完全满足这些条件。本练习将带你直面CAPM估计中一个常见挑战：当残差项存在自相关和异方差时，传统的OLS估计会产生误导性的结论。你将学习如何诊断这些问题，并应用Newey-West方法来获得即使在这些假设被违反时依然稳健的标准误。",
            "id": "2378979",
            "problem": "您的任务是通过估计单个资产的截距和斜率参数并评估残差自相关性，来评估资本资产定价模型 (CAPM) 的有效性。考虑由 CAPM 方程定义的超额收益模型\n$$\ny_t = \\alpha + \\beta m_t + \\varepsilon_t,\n$$\n其中 $y_t$ 是时间 $t$ 的资产超额收益，$m_t$ 是时间 $t$ 的市场超额收益，$\\alpha$ 是截距，$\\beta$ 是市场负荷，$\\varepsilon_t$ 是误差项。所有收益率必须以小数形式解释。\n\n对于下面指定的每个测试用例，您必须模拟 $\\{m_t\\}_{t=1}^T$ 和 $\\{\\varepsilon_t\\}_{t=1}^T$ 的过程，构建 $\\{y_t\\}_{t=1}^T$，然后：\n1. 使用一个由一列 1 和观测到的 $m_t$ 组成的 $T \\times 2$ 回归矩阵 $X$，通过普通最小二乘法估计 $\\alpha$ 和 $\\beta$。\n2. 使用基于样本残差自相关 $\\{\\hat{r}_k\\}_{k=1}^h$ 的大样本卡方检验（自由度为 $h$），检验残差 $\\{\\hat{\\varepsilon}_t\\}$ 在滞后 $h$ 阶内不存在自相关的原假设。\n3. 计算 $\\alpha$ 和 $\\beta$ 的传统普通最小二乘法标准误。\n4. 使用带有截断滞后 $L$ 的 Bartlett 核计算 $\\alpha$ 和 $\\beta$ 的 Newey–West 异方差和自相关一致性标准误。\n\n所有模拟必须对每个测试用例使用带有指定种子的确定性伪随机数生成器。对于每个测试用例，根据以下通用数据生成过程进行模拟。市场超额收益 $\\{m_t\\}$ 服从\n$$\nm_t = \\mu_m + \\phi_m m_{t-1} + \\sigma_m z_t, \\quad m_0 = 0,\n$$\n并且异质性成分 $\\{u_t\\}$ 服从\n$$\nu_t = \\rho\\, u_{t-1} + \\sigma_\\varepsilon w_t, \\quad u_0 = 0,\n$$\n其中 $z_t$ 和 $w_t$ 是独立同分布的标准正态冲击，在时间 $t$ 上和序列之间均独立。CAPM 误差指定为\n$$\n\\varepsilon_t =\n\\begin{cases}\nu_t,  \\text{如果 } \\kappa = 0,\\\\\n\\left(1 + \\kappa \\lvert m_t \\rvert \\right) u_t,  \\text{如果 } \\kappa  0.\n\\end{cases}\n$$\n则观测到的资产超额收益为 $y_t = \\alpha + \\beta m_t + \\varepsilon_t$。在所有测试用例中，无风险利率恒为零。\n\n为保证可复现性，冲击的生成顺序必须固定：对于从 $1$ 到 $T$ 的每个 $t$，首先抽取 $z_t$ 来更新 $m_t$，然后抽取 $w_t$ 来更新 $u_t$，最后形成 $\\varepsilon_t$ 和 $y_t$。在生成任何冲击之前，必须使用每个测试用例中指定的精确种子来初始化伪随机数生成器，并且所有随机抽取必须按所述顺序使用该单一生成器。\n\n使用以下参数值测试套件，它们共同涵盖了典型、边界和边缘情况下的行为。在每种情况下，所有参数都是以小数单位表示的标量，且 $\\mu_m = 0$。\n\n- 情况 A (理想情况，无残差自相关)：$T = 500$, $\\alpha = 0.001$, $\\beta = 1.2$, $\\phi_m = 0.1$, $\\sigma_m = 0.04$, $\\rho = 0$, $\\sigma_\\varepsilon = 0.02$, $\\kappa = 0$, $h = 4$, $L = 4$, 种子 $= 20240514$。\n- 情况 B (强残差自相关)：$T = 500$, $\\alpha = 0.001$, $\\beta = 1.2$, $\\phi_m = 0.1$, $\\sigma_m = 0.04$, $\\rho = 0.6$, $\\sigma_\\varepsilon = 0.02$, $\\kappa = 0$, $h = 4$, $L = 4$, 种子 $= 20240515$。\n- 情况 C (小样本，中度自相关)：$T = 60$, $\\alpha = 0.001$, $\\beta = 1.2$, $\\phi_m = 0.2$, $\\sigma_m = 0.05$, $\\rho = 0.5$, $\\sigma_\\varepsilon = 0.02$, $\\kappa = 0$, $h = 4$, $L = 4$, 种子 $= 20240516$。\n- 情况 D (异方差和自相关误差)：$T = 500$, $\\alpha = 0.001$, $\\beta = 1.2$, $\\phi_m = 0.1$, $\\sigma_m = 0.04$, $\\rho = 0.3$, $\\sigma_\\varepsilon = 0.02$, $\\kappa = 0.8$, $h = 4$, $L = 4$, 种子 $= 20240517$。\n\n对于每种情况，您的程序必须按此确切顺序计算以下七个输出：估计的 $\\alpha$，估计的 $\\beta$，$\\alpha$ 的普通最小二乘法标准误，$\\beta$ 的普通最小二乘法标准误，$\\alpha$ 的 Newey–West 标准误，$\\beta$ 的 Newey–West 标准误，以及一个布尔值，指示在 $0.05$ 的显著性水平下，滞后 $h$ 阶内无自相关的原假设是否被拒绝。\n\n最终输出格式要求：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个元素本身是对应测试用例的列表，顺序如上所述，所有浮点值四舍五入到六位小数。例如，整体格式必须是\n$$\n\\left[ [\\alpha_1,\\beta_1,se^{\\mathrm{OLS}}_{\\alpha,1},se^{\\mathrm{OLS}}_{\\beta,1},se^{\\mathrm{NW}}_{\\alpha,1},se^{\\mathrm{NW}}_{\\beta,1},\\mathrm{Reject}_1], \\ldots \\right].\n$$",
            "solution": "所提出的问题是计算计量经济学中一个适定性（well-posed）的练习，具体涉及资本资产定价模型（CAPM）的估计。它要求在关于误差结构的不同假设下模拟金融时间序列数据，然后估计模型参数并对估计量的性质进行批判性评估。该问题在科学上是合理的，完全指定的，并且是客观的。我们将以一个详细的、基于原则的解决方案来着手。\n\nCAPM 指定了资产的超额收益 $y_t$ 与市场的超额收益 $m_t$ 之间的线性关系：\n$$\ny_t = \\alpha + \\beta m_t + \\varepsilon_t\n$$\n其中 $t = 1, \\dots, T$ 是时间索引。参数 $\\alpha$ 是资产的“阿尔法”，代表无法由市场解释的超额收益。参数 $\\beta$ 是“贝塔”，衡量资产对市场变动的敏感性。项 $\\varepsilon_t$ 是异质性误差。\n\n第一个任务是根据所提供的数据生成过程（DGP）模拟时间序列 $\\{y_t\\}_{t=1}^T$ 和 $\\{m_t\\}_{t=1}^T$。对于每个测试用例，我们必须严格遵守指定的参数和随机数生成器种子。\n\n市场超额收益 $\\{m_t\\}$ 由一个一阶自回归过程 AR($1$) 生成：\n$$\nm_t = \\phi_m m_{t-1} + \\sigma_m z_t, \\quad \\text{with } m_0 = 0\n$$\n其中 $\\{z_t\\}$ 是独立同分布（i.i.d.）的标准正态随机变量序列。\n\nCAPM 误差项 $\\{\\varepsilon_t\\}$ 由一个底层的 AR($1$) 过程 $\\{u_t\\}$ 构建：\n$$\nu_t = \\rho u_{t-1} + \\sigma_\\varepsilon w_t, \\quad \\text{with } u_0 = 0\n$$\n其中 $\\{w_t\\}$ 是另一个独立同分布的标准正态序列，与 $\\{z_t\\}$ 独立。$\\varepsilon_t$ 的结构允许条件异方差性：\n$$\n\\varepsilon_t =\n\\begin{cases}\nu_t,  \\text{如果 } \\kappa = 0 \\text{ (同方差性)},\\\\\n\\left(1 + \\kappa \\lvert m_t \\rvert \\right) u_t,  \\text{如果 } \\kappa  0 \\text{ (异方差性)}.\n\\end{cases}\n$$\n当 $\\kappa  0$ 时，误差项的方差取决于市场收益的幅度，这是金融数据中的一个常见特征。\n\n利用模拟数据，我们执行以下估计和检验。\n\n**1. 普通最小二乘法 (OLS) 估计**\n参数 $\\alpha$ 和 $\\beta$ 使用 OLS 进行估计。我们定义参数向量 $\\theta = [\\alpha, \\beta]^T$，因变量向量 $y = [y_1, \\dots, y_T]^T$，以及回归矩阵 $X$，它是一个 $T \\times 2$ 矩阵，包含一列 1 和一列市场收益 $\\{m_t\\}$。\n$$\nX = \\begin{bmatrix} 1  m_1 \\\\ 1  m_2 \\\\ \\vdots  \\vdots \\\\ 1  m_T \\end{bmatrix}\n$$\nOLS 估计量 $\\hat{\\theta} = [\\hat{\\alpha}, \\hat{\\beta}]^T$ 由著名的公式给出：\n$$\n\\hat{\\theta} = (X^T X)^{-1} X^T y\n$$\n\n**2. OLS 标准误**\n在经典 OLS 假设下（包括同方差和无自相关的误差，即 $\\mathbb{E}[\\varepsilon \\varepsilon^T | X] = \\sigma^2 I_T$），估计量 $\\hat{\\theta}$ 的协方差矩阵为：\n$$\n\\text{Var}_{\\text{OLS}}(\\hat{\\theta}) = \\sigma^2 (X^T X)^{-1}\n$$\n误差方差 $\\sigma^2$ 是未知的，可以从残差 $\\hat{\\varepsilon}_t = y_t - \\hat{\\alpha} - \\hat{\\beta} m_t$ 中估计。$\\sigma^2$ 的无偏估计量是：\n$$\n\\hat{\\sigma}^2 = \\frac{1}{T-k} \\sum_{t=1}^T \\hat{\\varepsilon}_t^2\n$$\n其中 $k=2$ 是回归变量的数量。估计的协方差矩阵为 $\\widehat{\\text{Var}}_{\\text{OLS}}(\\hat{\\theta}) = \\hat{\\sigma}^2 (X^T X)^{-1}$。$\\hat{\\alpha}$ 和 $\\hat{\\beta}$ 的标准误是该矩阵对角线元素的平方根。\n\n**3. 残差自相关检验**\n为了检验无自相关假设的有效性，我们使用一个基于残差样本自相关的大样本检验。我们将采用 Ljung-Box Q 检验。原假设是 $H_0: r_1 = r_2 = \\dots = r_h = 0$，其中 $r_k$ 是滞后 $k$ 阶的总体自相关。检验统计量为：\n$$\nQ = T(T+2) \\sum_{k=1}^h \\frac{\\hat{r}_k^2}{T-k}\n$$\n其中 $\\hat{r}_k$ 是滞后 $k$ 阶的残差样本自相关。在原假设下，$Q$ 服从自由度为 $h$ 的卡方分布，即 $Q \\sim \\chi^2(h)$。如果在 $0.05$ 的显著性水平下，计算出的 $Q$ 统计量超过 $\\chi^2(h)$ 分布的第 $95$ 百分位数，我们就拒绝 $H_0$。\n\n**4. Newey–West (HAC) 标准误**\n当误差 $\\{\\varepsilon_t\\}$ 存在异方差和/或自相关时，OLS 标准误是不一致的。我们必须使用异方差和自相关一致性（HAC）协方差矩阵估计量。Newey-West 估计量是一个常见的选择。$\\hat{\\theta}$ 的 HAC 协方差矩阵具有“三明治”形式：\n$$\n\\text{Var}_{\\text{NW}}(\\hat{\\theta}) = (X^T X)^{-1} \\hat{S} (X^T X)^{-1}\n$$\n这里，$\\hat{S}$ 是得分向量 $g_t = X_t \\varepsilon_t$ 的长期方差的估计量，其中 $X_t = [1, m_t]^T$。$\\hat{S}$ 的 Newey-West 估计量为：\n$$\n\\hat{S} = \\sum_{t=1}^T g_t g_t^T + \\sum_{j=1}^L w_j \\sum_{t=j+1}^T (g_t g_{t-j}^T + g_{t-j} g_t^T)\n$$\n其中 $g_t = X_t \\hat{\\varepsilon}_t$。问题指定了 Bartlett 核，其权重 $w_j$ 由 $w_j = 1 - \\frac{j}{L+1}$ 给出，$L$ 是截断滞后。$\\hat{\\alpha}$ 和 $\\hat{\\beta}$ 的 Newey-West 标准误是最终得到的 $\\widehat{\\text{Var}}_{\\text{NW}}(\\hat{\\theta})$ 矩阵对角线元素的平方根。\n\n以下 Python 程序为每个指定的测试用例实现了这一完整过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport scipy.stats\n\ndef process_case(T, alpha, beta, phi_m, sigma_m, rho, sigma_eps, kappa, h, L, seed):\n    \"\"\"\n    Simulates time series data, estimates CAPM parameters, and computes standard errors.\n\n    Args:\n        T (int): Number of time periods.\n        alpha (float): True alpha.\n        beta (float): True beta.\n        phi_m (float): AR(1) coefficient for market return.\n        sigma_m (float): Volatility of market return shock.\n        rho (float): AR(1) coefficient for idiosyncratic error component.\n        sigma_eps (float): Volatility of idiosyncratic error shock.\n        kappa (float): Heteroskedasticity parameter.\n        h (int): Lag length for autocorrelation test.\n        L (int): Truncation lag for Newey-West estimator.\n        seed (int): Seed for the random number generator.\n\n    Returns:\n        list: A list containing estimated alpha, beta, OLS standard errors,\n              Newey-West standard errors, and autocorrelation test result.\n    \"\"\"\n    # 1. Data Generation\n    rng = np.random.default_rng(seed)\n    \n    m = np.zeros(T)\n    u = np.zeros(T)\n    eps = np.zeros(T)\n    y = np.zeros(T)\n\n    m_prev = 0.0\n    u_prev = 0.0\n    mu_m = 0.0 # As specified in the problem\n\n    for t in range(T):\n        z_t = rng.standard_normal()\n        w_t = rng.standard_normal()\n\n        # Market return process\n        m[t] = mu_m + phi_m * m_prev + sigma_m * z_t\n        m_prev = m[t]\n\n        # Idiosyncratic component process\n        u[t] = rho * u_prev + sigma_eps * w_t\n        u_prev = u[t]\n\n        # CAPM error term\n        if kappa == 0:\n            eps[t] = u[t]\n        else:\n            eps[t] = (1 + kappa * np.abs(m[t])) * u[t]\n        \n        # Asset excess return\n        y[t] = alpha + beta * m[t] + eps[t]\n\n    # 2. OLS Estimation\n    X = np.vstack([np.ones(T), m]).T\n    k = X.shape[1]\n    \n    try:\n        XTX_inv = np.linalg.inv(X.T @ X)\n    except np.linalg.LinAlgError:\n        # Handle cases of perfect multicollinearity, though unlikely here\n        return [np.nan] * 7\n\n    theta_hat = XTX_inv @ X.T @ y\n    alpha_hat, beta_hat = theta_hat[0], theta_hat[1]\n\n    # 3. OLS Standard Errors\n    residuals = y - X @ theta_hat\n    sigma2_hat = np.sum(residuals**2) / (T - k)\n    var_cov_ols = sigma2_hat * XTX_inv\n    se_alpha_ols = np.sqrt(var_cov_ols[0, 0])\n    se_beta_ols = np.sqrt(var_cov_ols[1, 1])\n\n    # 4. Residual Autocorrelation Test (Ljung-Box)\n    res_var = np.sum(residuals**2) / T\n    q_stat = 0.0\n    for j in range(1, h + 1):\n        # Sample autocovariance at lag j\n        res_acov_j = np.sum(residuals[j:] * residuals[:-j]) / T\n        # Sample autocorrelation at lag j\n        res_acor_j = res_acov_j / res_var\n        q_stat += (res_acor_j**2) / (T - j)\n        \n    q_stat *= T * (T + 2)\n    \n    chi2_crit_val = scipy.stats.chi2.ppf(0.95, df=h)\n    reject_h0 = q_stat > chi2_crit_val\n\n    # 5. Newey-West HAC Standard Errors\n    g = X * residuals[:, np.newaxis]  # T x k matrix of scores\n    \n    S_hat = g.T @ g\n    \n    for j in range(1, L + 1):\n        weight = 1.0 - j / (L + 1.0)\n        gamma_j = g[j:].T @ g[:-j]\n        S_hat += weight * (gamma_j + gamma_j.T)\n        \n    var_cov_nw = XTX_inv @ S_hat @ XTX_inv\n    se_alpha_nw = np.sqrt(var_cov_nw[0, 0])\n    se_beta_nw = np.sqrt(var_cov_nw[1, 1])\n\n    # 6. Collate and return results\n    return [alpha_hat, beta_hat, se_alpha_ols, se_beta_ols, se_alpha_nw, se_beta_nw, reject_h0]\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # T, alpha, beta, phi_m, sigma_m, rho, sigma_eps, kappa, h, L, seed\n        (500, 0.001, 1.2, 0.1, 0.04, 0.0, 0.02, 0.0, 4, 4, 20240514), # Case A\n        (500, 0.001, 1.2, 0.1, 0.04, 0.6, 0.02, 0.0, 4, 4, 20240515), # Case B\n        (60, 0.001, 1.2, 0.2, 0.05, 0.5, 0.02, 0.0, 4, 4, 20240516),  # Case C\n        (500, 0.001, 1.2, 0.1, 0.04, 0.3, 0.02, 0.8, 4, 4, 20240517), # Case D\n    ]\n\n    results = []\n    for case in test_cases:\n        result = process_case(*case)\n        results.append(result)\n\n    # Format output string without extra spaces, rounding floats to 6 places\n    list_of_strings = []\n    for res_list in results:\n        inner_str_list = []\n        for item in res_list:\n            if isinstance(item, (float, np.floating)):\n                inner_str_list.append(f\"{item:.6f}\")\n            else:\n                inner_str_list.append(str(item))\n        inner_str = ','.join(inner_str_list)\n        list_of_strings.append(f\"[{inner_str}]\")\n    \n    final_output_str = f\"[{','.join(list_of_strings)}]\"\n    print(final_output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "除了经典的频率派方法，我们还可以从贝叶斯的视角来估计CAPM参数，这为我们理解和量化不确定性提供了另一种强大的框架。在这个练习中，你将并排比较这两种方法：首先使用频率派的OLS方法构建置信区间，然后应用贝叶斯回归，通过共轭先验分布推导参数的后验分布。通过计算$\\beta$落在OLS置信区间内的后验概率，你将直观地感受到这两种统计推断范式在结果和解读上的异同。",
            "id": "2379015",
            "problem": "你需要从基本原理开始，实现一个完整的计算流程，以估计资本资产定价模型 (CAPM) 的斜率参数，同时使用频率派和贝叶斯方法，然后将斜率的后验分布与频率派的置信区间进行比较。单一资产超额回报的资本资产定价模型 (CAPM) 可以写成一个线性回归：对于每个时间索引 $t \\in \\{1,\\dots,n\\}$，资产超额回报 $y_t$ 满足 $y_t = \\alpha + \\beta x_t + \\varepsilon_t$，其中 $x_t$ 是市场超额回报，$\\alpha$ 是截距，$\\beta$ 是斜率（系统性风险），$\\varepsilon_t$ 是独立同分布的误差，满足 $E[\\varepsilon_t]=0$ 和 $Var(\\varepsilon_t)=\\sigma^2$。你将需要：\n- 通过普通最小二乘法 (OLS) 估计 $\\beta$，并使用具有 $n-2$ 自由度的有限样本 $t$ 分布构建双侧 $95$ 置信区间。\n- 在具有共轭正态-逆伽马 (NIG) 先验的贝叶斯回归下估计 $\\beta$。令 $\\theta = (\\alpha,\\beta)'$。先验指定为 $\\sigma^2 \\sim \\text{Inverse-Gamma}(a_0, d_0)$ 和 $\\theta \\mid \\sigma^2 \\sim \\mathcal{N}(b_0,\\ \\sigma^2 V_0)$，其中 $b_0 \\in \\mathbb{R}^2$ 且 $V_0 \\in \\mathbb{R}^{2 \\times 2}$ 是正定矩阵。使用贝叶斯定理、高斯似然和此共轭先验来获得后验分布，然后进行边缘化以获得 $\\beta$ 的后验分布。\n- 计算 $\\beta$ 位于频率派 $95\\%$ 置信区间内的后验概率。将此概率表示为 $[0,1]$ 内的一个小数。\n\n你的程序必须：\n1) 针对下面列出的每个测试用例，在 CAPM 数据生成过程下模拟数据 $(x_t,y_t)$，每个用例使用固定的伪随机种子以保证可复现性。具体来说，独立地为 $t=1,\\dots,n$ 生成 $x_t \\sim \\mathcal{N}(\\mu_x,\\sigma_x)$，独立地生成 $\\varepsilon_t \\sim \\mathcal{N}(0,1)$，然后设置 $y_t = \\alpha + \\beta x_t + \\sigma \\varepsilon_t$。此问题中没有物理单位。\n2) 对每个用例，计算：\n   - 使用具有 $n-2$ 自由度的 $t$ 分布和在同方差性下的精确有限样本 OLS 标准误，计算 $\\beta$ 的 OLS 估计及其双侧 $95$ 置信区间。\n   - 在正态-逆伽马先验下计算 $\\beta$ 的贝叶斯后验。使用贝叶斯定理对高斯线性模型所隐含的共轭更新。然后，从后验中获得 $\\beta$ 的边缘分布，并计算 $\\beta$ 位于 OLS 置信区间内的后验概率。\n3) 对于三个测试用例，输出一行，其中包含一个列表，列表内有三个浮点数，分别等于上述三个后验概率，并按测试用例的顺序排列。将每个浮点数四舍五入到 $6$ 位小数。最后一行必须严格符合 $[p_1,p_2,p_3]$ 的格式，其中每个 $p_i$ 是小数点后有 $6$ 位数字的小数，且没有多余的空格。\n\n你可以假定的基本原理：\n- 在同方差性假设下，带有高斯误差的线性回归产生的 OLS 估计量即为最大似然估计量，其系数的线性组合在有限样本中具有基于 $t$ 分布的精确抽样分布。\n- 对于带有正态-逆伽马先验的高斯线性模型，贝叶斯定理会产生一个正态-逆伽马后验分布，在积分掉 $\\sigma^2$ 后，系数的边缘分布为多元学生t分布。\n\n测试套件：\n- 用例 $1$ (理想情况，弱先验，中等样本): 种子 $=12345$, $n=60$, 真实 $\\alpha=0.002$, 真实 $\\beta=1.1$, $\\sigma=0.04$, $\\mu_x=0.006$, $\\sigma_x=0.045$, $b_0=\\begin{bmatrix}0\\\\ 1.0\\end{bmatrix}$, $V_0=\\text{diag}(10^6,10^6)$, $a_0=10^{-6}$, $d_0=10^{-6}$。\n- 用例 $2$ (小样本，强先验): 种子 $=2024$, $n=8$, 真实 $\\alpha=0.001$, 真实 $\\beta=0.8$, $\\sigma=0.05$, $\\mu_x=0.004$, $\\sigma_x=0.05$, $b_0=\\begin{bmatrix}0\\\\ 1.0\\end{bmatrix}$, $V_0=\\text{diag}(0.01,0.01)$, $a_0=5$, $d_0=0.002$。\n- 用例 $3$ (较高噪声，中等先验): 种子 $=777$, $n=40$, 真实 $\\alpha=0.0$, 真实 $\\beta=1.3$, $\\sigma=0.08$, $\\mu_x=0.005$, $\\sigma_x=0.06$, $b_0=\\begin{bmatrix}0\\\\ 1.2\\end{bmatrix}$, $V_0=\\text{diag}(0.1,0.1)$, $a_0=3$, $d_0=0.0064$。\n\n要求的最终输出格式：\n- 你的程序应生成单行输出，其中包含三个后验概率，格式为方括号括起来的逗号分隔列表，每个概率四舍五入到 $6$ 位小数，没有多余的空格，例如：$[0.952381,0.843211,0.901337]$。",
            "solution": "该问题要求对资本资产定价模型 (CAPM) 的斜率参数 $\\beta$ 进行频率派估计和贝叶斯估计的对比分析。问题定义明确，科学上合理，并提供了所有必要的信息。我们将采用严谨的、分步的解决方案。\n\nCAPM 被表述为一个基于市场超额回报 $x_t$ 的资产超额回报 $y_t$ 的简单线性回归模型：\n$$y_t = \\alpha + \\beta x_t + \\varepsilon_t, \\quad t=1, \\dots, n$$\n其中 $\\varepsilon_t$ 是独立同分布的误差项，满足 $E[\\varepsilon_t]=0$ 和 $Var(\\varepsilon_t)=\\sigma^2$。用矩阵表示法，即为 $y = X\\theta + \\varepsilon$，其中 $y$ 是一个 $n \\times 1$ 的回报向量，$X$ 是一个 $n \\times 2$ 的设计矩阵，其第一列为1，第二列为 $x_t$ 的值，$\\theta = (\\alpha, \\beta)'$ 是 $2 \\times 1$ 的参数向量。\n\n每个测试用例的解决方案包括三个阶段：\n1.  根据指定的数据生成过程模拟数据 $(x_t, y_t)$。\n2.  使用普通最小二乘法 (OLS) 估计 $\\beta$ 并推导其 $95\\%$ 置信区间。\n3.  使用带有共轭正态-逆伽马先验的贝叶斯方法估计 $\\beta$，以找到 $\\beta$ 的边缘后验分布，然后计算 $\\beta$ 落在 OLS 置信区间内的后验概率。\n\n**第1步：数据生成**\n\n对于每个测试用例，我们使用提供的随机数生成器种子以确保可复现性。我们从正态分布 $x_t \\sim \\mathcal{N}(\\mu_x, \\sigma_x^2)$ 中生成 $n$ 个独立的市场超额回报 $x_t$ 的抽样。然后我们生成 $n$ 个独立的标准正态新息 $z_t \\sim \\mathcal{N}(0, 1)$ 的抽样。接着使用真实的模型参数 ($\\alpha_{\\text{true}}, \\beta_{\\text{true}}, \\sigma_{\\text{true}}$) 构建资产超额回报 $y_t$：\n$$y_t = \\alpha_{\\text{true}} + \\beta_{\\text{true}} x_t + \\sigma_{\\text{true}} z_t$$\n这确保了误差项 $\\varepsilon_t = \\sigma_{\\text{true}} z_t$ 满足模型假设，特别是 $E[\\varepsilon_t]=0$ 和 $Var(\\varepsilon_t) = \\sigma_{\\text{true}}^2 Var(z_t) = \\sigma_{\\text{true}}^2$。\n\n**第2步：频率派估计（普通最小二乘法）**\n\n给定数据 $(y, X)$ 并假设高斯误差，OLS 估计量为 $\\theta$ 提供了最大似然估计：\n$$\\hat{\\theta}_{OLS} = (X'X)^{-1}X'y$$\n这给出了估计值 $\\hat{\\alpha}$ 和 $\\hat{\\beta}$。误差方差 $\\sigma^2$ 的一个无偏估计量是：\n$$\\hat{\\sigma}^2 = \\frac{e'e}{n-2}$$\n其中 $e = y - X\\hat{\\theta}_{OLS}$ 是残差向量。OLS 估计量的协方差矩阵估计为：\n$$\\widehat{Var}(\\hat{\\theta}_{OLS}) = \\hat{\\sigma}^2(X'X)^{-1}$$\n$\\hat{\\beta}$ 的标准误是该矩阵第二个对角元素的平方根：\n$$se(\\hat{\\beta}) = \\sqrt{[\\widehat{Var}(\\hat{\\theta}_{OLS})]_{2,2}}$$\n在模型假设下，量 $\\frac{\\hat{\\beta} - \\beta}{se(\\hat{\\beta})}$ 服从具有 $n-2$ 自由度的学生t分布。这允许构建一个精确的有限样本置信区间。$\\beta$ 的双侧 $95\\%$ 置信区间由下式给出：\n$$CI_{95\\%} = \\left[ \\hat{\\beta} - t_{n-2, 0.975} \\cdot se(\\hat{\\beta}), \\quad \\hat{\\beta} + t_{n-2, 0.975} \\cdot se(\\hat{\\beta}) \\right]$$\n其中 $t_{n-2, 0.975}$ 是具有 $n-2$ 自由度的 $t$ 分布的上临界值，其在右尾留下了 $2.5\\%$ 的概率。\n\n**第3步：贝叶斯估计与最终概率**\n\n贝叶斯框架融合了关于参数的先验信念，这些信念通过贝叶斯定理利用数据进行更新。指定的先验是针对 $(\\theta, \\sigma^2)$ 的正态-逆伽马 (NIG) 分布，它是高斯线性模型的共轭先验。这意味着后验分布也将属于 NIG 族。\n\n先验指定为：\n$$p(\\theta, \\sigma^2) = p(\\theta | \\sigma^2) p(\\sigma^2)$$\n$$\\sigma^2 \\sim \\text{Inverse-Gamma}(a_0, d_0)$$\n$$\\theta | \\sigma^2 \\sim \\mathcal{N}(b_0, \\sigma^2 V_0)$$\n其中 $a_0, d_0, b_0, V_0$ 是超参数。\n\n数据的似然由下式给出：\n$$p(y|X, \\theta, \\sigma^2) \\propto (\\sigma^2)^{-n/2} \\exp\\left(-\\frac{1}{2\\sigma^2}(y-X\\theta)'(y-X\\theta)\\right)$$\n应用贝叶斯定理，后验分布 $p(\\theta, \\sigma^2 | y, X) \\propto p(y|X, \\theta, \\sigma^2) p(\\theta, \\sigma^2)$ 是一个具有更新后参数 $(a_n, d_n, b_n, V_n)$ 的正态-逆伽马分布：\n$$a_n = a_0 + \\frac{n}{2}$$\n$$V_n = (V_0^{-1} + X'X)^{-1}$$\n$$b_n = V_n(V_0^{-1}b_0 + X'y)$$\n$$d_n = d_0 + \\frac{1}{2}\\left(y'y + b_0'V_0^{-1}b_0 - b_n'(V_0^{-1} + X'X)b_n\\right)$$\n\n为了与 $\\beta$ 的频率派结果进行比较，我们必须找到它的边缘后验分布。将联合后验中的 $\\sigma^2$ 积分掉，可以得到 $\\theta$ 的一个多元学生t分布：\n$$\\theta | y, X \\sim t_{2a_n}\\left(b_n, \\frac{d_n}{a_n}V_n\\right)$$\n因此，斜率参数 $\\beta$（$\\theta$ 的第二个分量）的边缘后验是一个广义学生t分布。其标准化形式是一个标准学生t变量：\n$$\\frac{\\beta - [b_n]_2}{\\sqrt{\\frac{d_n}{a_n}[V_n]_{2,2}}} \\sim t_{2a_n}$$\n令 $\\mu_\\beta = [b_n]_2$ 为后验位置（均值），$s_\\beta = \\sqrt{\\frac{d_n}{a_n}[V_n]_{2,2}}$ 为后验尺度，$\\nu_\\beta = 2a_n$ 为自由度。\n\n最后的任务是计算 $\\beta$ 落在频率派 $95\\%$ 置信区间 $[CI_{low}, CI_{high}]$ 内的后验概率。这可以使用标准学生t分布的累积分布函数 (CDF) $F_{t_{\\nu_\\beta}}$ 来计算：\n$$P(\\beta \\in [CI_{low}, CI_{high}] | y, X) = F_{t_{\\nu_\\beta}}\\left(\\frac{CI_{high} - \\mu_\\beta}{s_\\beta}\\right) - F_{t_{\\nu_\\beta}}\\left(\\frac{CI_{low} - \\mu_\\beta}{s_\\beta}\\right)$$\n\n对指定的三个测试用例中的每一个都执行此过程，得出三个概率，这三个概率构成了最终结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import t\n\ndef solve():\n    \"\"\"\n    Main function to run the CAPM estimation pipeline for all test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"name\": \"Case 1\",\n            \"seed\": 12345, \"n\": 60, \"true_alpha\": 0.002, \"true_beta\": 1.1, \"sigma\": 0.04,\n            \"mu_x\": 0.006, \"sigma_x\": 0.045,\n            \"b0\": np.array([[0.0], [1.0]]), \"V0\": np.diag([1e6, 1e6]), \"a0\": 1e-6, \"d0\": 1e-6\n        },\n        {\n            \"name\": \"Case 2\",\n            \"seed\": 2024, \"n\": 8, \"true_alpha\": 0.001, \"true_beta\": 0.8, \"sigma\": 0.05,\n            \"mu_x\": 0.004, \"sigma_x\": 0.05,\n            \"b0\": np.array([[0.0], [1.0]]), \"V0\": np.diag([0.01, 0.01]), \"a0\": 5.0, \"d0\": 0.002\n        },\n        {\n            \"name\": \"Case 3\",\n            \"seed\": 777, \"n\": 40, \"true_alpha\": 0.0, \"true_beta\": 1.3, \"sigma\": 0.08,\n            \"mu_x\": 0.005, \"sigma_x\": 0.06,\n            \"b0\": np.array([[0.0], [1.2]]), \"V0\": np.diag([0.1, 0.1]), \"a0\": 3.0, \"d0\": 0.0064\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        p = frequentist_vs_bayesian_capm(**case)\n        results.append(f\"{p:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef frequentist_vs_bayesian_capm(name, seed, n, true_alpha, true_beta, sigma, mu_x, sigma_x, b0, V0, a0, d0):\n    \"\"\"\n    Executes the full pipeline for a single test case.\n    1. Simulates data.\n    2. Performs OLS estimation and computes the confidence interval for beta.\n    3. Performs Bayesian estimation and computes the posterior probability of beta\n       lying in the OLS confidence interval.\n    \"\"\"\n    # 1. Simulate data\n    rng = np.random.default_rng(seed)\n    x = rng.normal(mu_x, sigma_x, n)\n    eps = rng.normal(0, 1, n)\n    y = true_alpha + true_beta * x + sigma * eps\n\n    # Reshape for matrix operations\n    y = y.reshape(-1, 1)\n    X = np.vstack([np.ones(n), x]).T\n\n    # 2. Frequentist (OLS) Estimation\n    # OLS coefficient estimates: theta_hat = (X'X)^-1 * X'y\n    XTX = X.T @ X\n    XTX_inv = np.linalg.inv(XTX)\n    XTY = X.T @ y\n    theta_hat = XTX_inv @ XTY\n    beta_hat = theta_hat[1, 0]\n\n    # OLS variance estimate and standard errors\n    residuals = y - X @ theta_hat\n    sigma2_hat = (residuals.T @ residuals) / (n - 2)\n    cov_theta_hat = sigma2_hat[0, 0] * XTX_inv\n    se_beta = np.sqrt(cov_theta_hat[1, 1])\n\n    # 95% Confidence Interval for beta\n    df_ols = n - 2\n    t_crit = t.ppf(0.975, df=df_ols)\n    ci_low = beta_hat - t_crit * se_beta\n    ci_high = beta_hat + t_crit * se_beta\n\n    # 3. Bayesian Estimation\n    # Posterior parameters for Normal-Inverse-Gamma\n    V0_inv = np.linalg.inv(V0)\n    Vn_inv = V0_inv + XTX\n    Vn = np.linalg.inv(Vn_inv)\n    bn = Vn @ (V0_inv @ b0 + XTY)\n    \n    an = a0 + n / 2.0\n    \n    # Use the more direct formula for dn\n    # dn = d0 + 0.5 * (y'y + b0'V0_inv*b0 - bn'Vn_inv*bn)\n    term1 = y.T @ y\n    term2 = b0.T @ V0_inv @ b0\n    term3 = bn.T @ Vn_inv @ bn\n    dn = d0 + 0.5 * (term1 + term2 - term3)\n    dn = dn[0, 0] # Ensure scalar\n\n    # Marginal posterior for beta (Student-t)\n    df_bayes = 2 * an\n    # Location (mean) of beta's posterior\n    _mu_beta_post = bn[1, 0]\n    # Scale of beta's posterior\n    _s2_beta_post_scaled = (dn / an) * Vn[1, 1]\n    _s_beta_post = np.sqrt(_s2_beta_post_scaled)\n\n    # Calculate posterior probability of beta being in the OLS CI\n    z_low = (ci_low - _mu_beta_post) / _s_beta_post\n    z_high = (ci_high - _mu_beta_post) / _s_beta_post\n    \n    prob = t.cdf(z_high, df=df_bayes) - t.cdf(z_low, df=df_bayes)\n\n    return prob\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}