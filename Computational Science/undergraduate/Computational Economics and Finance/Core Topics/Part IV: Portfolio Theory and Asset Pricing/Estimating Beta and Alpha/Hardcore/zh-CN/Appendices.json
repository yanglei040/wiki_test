{
    "hands_on_practices": [
        {
            "introduction": "在金融实践中，我们经常需要区分一家公司的商业风险和其财务杠杆带来的风险。股票的贝塔系数，即权益贝塔（$\\beta_E$），混合了这两种风险。为了对不同资本结构的公司进行公平比较，或评估一个新项目的内在风险，我们需要计算资产贝塔（$\\beta_A$），它仅衡量公司的基础商业风险。这个练习将指导你如何通过“去杠杆化”过程，从已知的权益贝塔中分离出资产贝塔，这是公司财务和估值中的一项基本技能。",
            "id": "2390287",
            "problem": "一家单一业务公司通过股权和固定利率的付息债务进行融资。一位分析师通过对足够长的样本期内公司每月的股权超额回报率与市场每月的超额回报率进行线性回归，估算出该公司的股权贝塔系数为 $1.35$。当前股权市值为 $700$ 百万美元，当前付息债务市值为 $300$ 百万美元。法定公司税率为 $0.25$。假设公司的债务贝塔系数约为 $0$，并且公司利息税盾的现值与债务具有相同的风险。在这些条件下，计算公司的资产贝塔系数（也称为无杠杆贝塔系数）。将您的答案四舍五入至四位有效数字。",
            "solution": "该问题要求计算公司的资产贝塔系数，也称为无杠杆贝塔系数，我们将其记为 $\\beta_A$。这是衡量公司资产系统性风险的指标，与公司的资本结构无关。我们已知公司的股权贝塔系数 $\\beta_E$，它反映了股权持有者面临的风险，并受到财务杠杆的影响。\n\n其核心原则是，公司资产的系统性风险必须等于对这些资产的各项求偿权的加权平均系统性风险。这些求偿权包括债务和股权。然而，在存在公司税的情况下，使用债务会产生利息税盾，这是一项有价值的资产。因此，对公司价值的更完整表述必须考虑到这个税盾。\n\n杠杆公司的总市值 $V_L$ 是其股权市值 $E$ 和债务市值 $D$ 的总和。\n$$V_L = E + D$$\n杠杆公司资产的贝塔系数 $\\beta_L$ 是其股权和债务贝塔系数的加权平均值：\n$$\\beta_L = \\frac{E}{E+D}\\beta_E + \\frac{D}{E+D}\\beta_D$$\n杠杆公司的资产也可以分解为无杠杆资产（公司在全股权融资情况下的价值，$V_U$）和利息税盾的现值 $V_{TS}$。\n$$V_L = V_U + V_{TS}$$\n从这个角度来看，杠杆公司资产的贝塔系数也是无杠杆资产贝塔系数 $\\beta_U$（或 $\\beta_A$）和税盾贝塔系数 $\\beta_{TS}$ 的加权平均值：\n$$\\beta_L = \\frac{V_U}{V_L}\\beta_U + \\frac{V_{TS}}{V_L}\\beta_{TS}$$\n通过令 $\\beta_L$ 的两个表达式相等，并乘以 $V_L = E+D$，我们得到各组成部分的贝塔系数和价值之间的基本关系：\n$$E\\beta_E + D\\beta_D = V_U\\beta_U + V_{TS}\\beta_{TS}$$\n该问题提供了一些关键的简化假设。首先，公司的债务贝塔系数约等于零：\n$$\\beta_D \\approx 0$$\n其次，税盾的现值与债务具有相同的风险。这意味着它们的贝塔系数相等：\n$$\\beta_{TS} = \\beta_D$$\n结合这两个假设，我们得出结论，税盾的贝塔系数也为零：\n$$\\beta_{TS} \\approx 0$$\n将 $\\beta_D = 0$ 和 $\\beta_{TS} = 0$ 代入我们的基本贝塔方程：\n$$E\\beta_E + D(0) = V_U\\beta_U + V_{TS}(0)$$\n$$E\\beta_E = V_U\\beta_U$$\n我们寻求的资产贝塔系数是 $\\beta_A = \\beta_U$。为了求解它，我们必须用已知量来表示 $V_U$。根据价值分解，$V_U = V_L - V_{TS} = (E+D) - V_{TS}$。在永续债务的普遍假设下，税盾的价值 $V_{TS}$ 是税率乘以债务的价值：\n$$V_{TS} = \\tau_c D$$\n将此代入 $V_U$ 的表达式中：\n$$V_U = E + D - \\tau_c D = E + D(1-\\tau_c)$$\n现在我们将这个 $V_U$ 的表达式代回我们简化后的贝塔方程：\n$$E\\beta_E = (E + D(1-\\tau_c))\\beta_U$$\n求解 $\\beta_U$，即资产贝塔系数 $\\beta_A$：\n$$\\beta_A = \\beta_U = \\frac{E}{E + D(1-\\tau_c)}\\beta_E$$\n我们已知以下数值：\n股权贝塔系数，$\\beta_E = 1.35$\n股权市值，$E = 700$ 百万美元\n债务市值，$D = 300$ 百万美元\n公司税率，$\\tau_c = 0.25$\n\n我们将这些数值代入推导出的资产贝塔系数公式中：\n$$\\beta_A = \\frac{700}{700 + 300(1 - 0.25)}\\times 1.35$$\n$$\\beta_A = \\frac{700}{700 + 300(0.75)}\\times 1.35$$\n$$\\beta_A = \\frac{700}{700 + 225}\\times 1.35$$\n$$\\beta_A = \\frac{700}{925}\\times 1.35$$\n计算数值结果：\n$$\\beta_A \\approx 0.75675675... \\times 1.35$$\n$$\\beta_A \\approx 1.02162162...$$\n问题要求答案四舍五入至四位有效数字。第五位有效数字是 $6$，所以我们将第四位数字向上取整。\n$$\\beta_A \\approx 1.022$$\n这个结果是合乎逻辑的，因为对于一个杠杆公司来说，资产贝塔系数（$1.022$）必须低于股权贝塔系数（$1.35$），这反映了财务风险被剔除后的结果。",
            "answer": "$$\\boxed{1.022}$$"
        },
        {
            "introduction": "虽然标准资本资产定价模型 (CAPM) 中的贝塔系数可以通过简单的线性回归来估算，但现实世界的数据往往存在复杂性，需要更精密的模型。对于交易不频繁的“冷门股”来说，其收盘价可能并非在交易日结束时形成，导致其收益率与市场指数的收益率在时间上不同步。这个练习将向你介绍迪姆森（Dimson）贝塔，这是一种通过在回归模型中引入市场收益的滞后项和领先项来修正非同步交易偏差的实用方法。",
            "id": "2390296",
            "problem": "给定一个用于交易不活跃资产的线性回报模型，该模型通过包含市场回报的一期滞后和一期领先项，来考虑资产与市场之间的非同步交易。对于时间指数 $t \\in \\{1,2,\\ldots,T\\}$，该模型为\n$$\nR_{i,t} \\;=\\; \\alpha_i \\;+\\; \\beta_{-1} R_{m,t-1} \\;+\\; \\beta_{0} R_{m,t} \\;+\\; \\beta_{+1} R_{m,t+1} \\;+\\; \\varepsilon_t,\n$$\n其中 $R_{i,t}$ 是资产回报，$R_{m,t}$ 是市场回报，两者均以小数形式表示。未知参数是截距项 $\\alpha_i$ 和三个斜率系数 $\\beta_{-1}$、$\\beta_{0}$ 和 $\\beta_{+1}$。Dimson beta 定义为总和 $\\beta_{-1} + \\beta_{0} + \\beta_{+1}$。假设参数是通过在所有回归变量都有定义的时间指数集合上（即 $t \\in \\{2,3,\\ldots,T-1\\}$）最小化残差平方和来估计的。所有回报均以小数形式给出（例如，百分之一的回报是 $0.01$，而不是 $1$ 或 $1\\%$）。\n\n您的任务是，对下面的每个测试用例，使用上述的普通最小二乘法定义来估计 $\\alpha_i$ 和 Dimson beta $\\beta_{-1} + \\beta_{0} + \\beta_{+1}$，其目标是最小化\n$$\n\\sum_{t=2}^{T-1} \\Big(R_{i,t} - \\alpha_i - \\beta_{-1} R_{m,t-1} - \\beta_{0} R_{m,t} - \\beta_{+1} R_{m,t+1}\\Big)^2.\n$$\n\n对于每个测试用例，在估计中仅使用指数 $t \\in \\{2,3,\\ldots,T-1\\}$。此指数范围之外的任何数据都不应对目标函数有贡献。\n\n测试套件：\n- 测试用例 $1$（一般情况，中等长度）：设 $T=8$。市场回报序列 $R_{m,1:T}$ 为 $\\{0.018,\\,-0.012,\\,0.031,\\,0.004,\\,-0.023,\\,0.009,\\,0.042,\\,-0.035\\}$。资产回报序列 $R_{i,1:T}$ 为 $\\{0.00000,\\,-0.01185,\\,0.03200,\\,0.01710,\\,-0.02415,\\,-0.00065,\\,0.05520,\\,0.00000\\}$。\n- 测试用例 $2$（边界长度，足以估计所有参数）：设 $T=6$。市场回报序列 $R_{m,1:T}$ 为 $\\{0.014,\\,-0.025,\\,0.019,\\,-0.006,\\,0.037,\\,-0.011\\}$。资产回报序列 $R_{i,1:T}$ 为 $\\{0.00000,\\,-0.00450,\\,-0.01150,\\,-0.01100,\\,0.00050,\\,0.00000\\}$。\n- 测试用例 $3$（数据生成关系中仅存在截距项）：设 $T=7$。市场回报序列 $R_{m,1:T}$ 为 $\\{0.005,\\,-0.008,\\,0.013,\\,-0.021,\\,0.017,\\,0.002,\\,-0.009\\}$。资产回报序列 $R_{i,1:T}$ 为 $\\{0.00240,\\,0.00240,\\,0.00240,\\,0.00240,\\,0.00240,\\,0.00240,\\,0.00240\\}$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的、以逗号分隔的结果列表。每个测试用例应贡献一个数对，该数对由估计的截距项 $\\alpha_i$ 和估计的 Dimson beta $\\beta_{-1} + \\beta_{0} + \\beta_{+1}$ 组成，并按此顺序排列。\n- 每个浮点数必须四舍五入到恰好 $6$ 位小数，并以定点表示法打印。\n- 具体来说，输出必须采用 $[[\\widehat{\\alpha}_1,\\widehat{\\beta}^{\\text{Dimson}}_1],[\\widehat{\\alpha}_2,\\widehat{\\beta}^{\\text{Dimson}}_2],[\\widehat{\\alpha}_3,\\widehat{\\beta}^{\\text{Dimson}}_3]]$ 的形式，并且行内任何地方都没有空格。\n\n每个测试用例的答案必须是指定格式的一对浮点数，并且汇总输出必须是如上所述的单行。",
            "solution": "问题陈述已经过验证，被认为是有效的。这是一个计算金融学中的适定问题，它基于成熟的计量经济学原理，并提供了所有必要的数据和定义。\n\n该问题要求使用普通最小二乘法（OLS）来估计一个线性回归模型的参数。该模型考虑了非同步交易，其具体形式如下：\n$$\nR_{i,t} = \\alpha_i + \\beta_{-1} R_{m,t-1} + \\beta_{0} R_{m,t} + \\beta_{+1} R_{m,t+1} + \\varepsilon_t\n$$\n其中 $R_{i,t}$ 是资产 $i$ 在时间 $t$ 的回报，$R_{m,t}$ 是市场在时间 $t$ 的回报，而 $\\varepsilon_t$ 是一个随机误差项。待估计的参数是截距项 $\\alpha_i$ 和斜率系数 $\\beta_{-1}$、$\\beta_{0}$ 和 $\\beta_{+1}$。\n\n估计是基于在时间指数 $t \\in \\{2, 3, \\ldots, T-1\\}$ 上最小化残差平方和（SSR）进行的。这对应于标准的 OLS 流程。该问题可以表示为矩阵形式：\n$$\n\\mathbf{y} = \\mathbf{X}\\mathbf{b} + \\mathbf{e}\n$$\n参数向量 $\\mathbf{b}$ 的 OLS 估计量 $\\hat{\\mathbf{b}}$ 是使残差向量的平方范数 $\\|\\mathbf{y} - \\mathbf{X}\\mathbf{b}\\|^2$ 最小化的向量。\n\n对于每个总时间序列长度为 $T$ 的测试用例，我们使用所有回归变量都可用的数据来构建向量和矩阵，即对于 $t \\in \\{2, 3, \\ldots, T-1\\}$。这为回归提供了 $N = T-2$ 个观测值。\n\n因变量向量 $\\mathbf{y}$ 是从时间 $t=2$ 到 $t=T-1$ 的资产回报的列向量：\n$$\n\\mathbf{y} = \\begin{pmatrix} R_{i,2} \\\\ R_{i,3} \\\\ \\vdots \\\\ R_{i,T-1} \\end{pmatrix}\n$$\n该向量的维度为 $(T-2) \\times 1$。\n\n参数向量 $\\mathbf{b}$ 包含未知系数：\n$$\n\\mathbf{b} = \\begin{pmatrix} \\alpha_i \\\\ \\beta_{-1} \\\\ \\beta_{0} \\\\ \\beta_{+1} \\end{pmatrix}\n$$\n该向量的维度为 $4 \\times 1$。\n\n设计矩阵 $\\mathbf{X}$ 由回归变量构成。它包含一列全为 1 的项（对应截距项 $\\alpha_i$），以及对应滞后、同期和领先的市场回报（$R_{m,t-1}, R_{m,t}, R_{m,t+1}$）的列。每一行对应一个特定的时间 $t$：\n$$\n\\mathbf{X} = \\begin{pmatrix}\n1 & R_{m,1} & R_{m,2} & R_{m,3} \\\\\n1 & R_{m,2} & R_{m,3} & R_{m,4} \\\\\n\\vdots & \\vdots & \\vdots & \\vdots \\\\\n1 & R_{m,T-2} & R_{m,T-1} & R_{m,T}\n\\end{pmatrix}\n$$\n该矩阵的维度为 $(T-2) \\times 4$。\n\nOLS 估计值 $\\hat{\\mathbf{b}}$ 由正规方程的解给出：\n$$\n\\hat{\\mathbf{b}} = (\\mathbf{X}^T \\mathbf{X})^{-1} \\mathbf{X}^T \\mathbf{y}\n$$\n如果矩阵 $\\mathbf{X}^T \\mathbf{X}$ 是可逆的，则存在唯一解，这要求观测值数量 $N = T-2$ 至少等于参数数量 $k=4$，并且 $\\mathbf{X}$ 的列是线性无关的。所有测试用例都满足条件 $T-2 \\ge 4$：对于 $T=8$，$N=6$；对于 $T=6$，$N=4$；对于 $T=7$，$N=5$。\n\n一旦参数向量 $\\hat{\\mathbf{b}} = [\\hat{\\alpha}_i, \\hat{\\beta}_{-1}, \\hat{\\beta}_{0}, \\hat{\\beta}_{+1}]^T$ 被估计出来，就可以计算所需的输出：\n$1$. 估计的截距是向量的第一个元素：$\\hat{\\alpha}_i = \\hat{\\mathbf{b}}_1$。\n$2$. 估计的 Dimson beta 是估计的斜率系数之和：$\\hat{\\beta}^{\\text{Dimson}} = \\hat{\\beta}_{-1} + \\hat{\\beta}_{0} + \\hat{\\beta}_{+1} = \\hat{\\mathbf{b}}_2 + \\hat{\\mathbf{b}}_3 + \\hat{\\mathbf{b}}_4$。\n\n算法流程如下：\n对于每个测试用例：\n$1$. 给定时间序列 $R_{m,1:T}$ 和 $R_{i,1:T}$，从 $t \\in \\{2, \\ldots, T-1\\}$ 的 $R_{i,t}$ 构建向量 $\\mathbf{y}$。\n$2$. 构建矩阵 $\\mathbf{X}$，其中每一行 $j$（对应于时间 $t=j+2$）是 $[1, R_{m,t-1}, R_{m,t}, R_{m,t+1}]$。\n$3$. 求解线性最小二乘问题以找到 $\\hat{\\mathbf{b}}$。最好使用数值稳定的算法来完成，例如基于 QR 分解的算法，这种算法在标准数值库中都有实现。\n$4$. 从结果向量 $\\hat{\\mathbf{b}}$ 中提取 $\\hat{\\alpha}_i$ 并计算 $\\hat{\\beta}^{\\text{Dimson}}$。\n$5$. 按要求格式化结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Dimson-beta estimation problem for a set of test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"T\": 8,\n            \"Rm\": [0.018, -0.012, 0.031, 0.004, -0.023, 0.009, 0.042, -0.035],\n            \"Ri\": [0.00000, -0.01185, 0.03200, 0.01710, -0.02415, -0.00065, 0.05520, 0.00000]\n        },\n        {\n            \"T\": 6,\n            \"Rm\": [0.014, -0.025, 0.019, -0.006, 0.037, -0.011],\n            \"Ri\": [0.00000, -0.00450, -0.01150, -0.01100, 0.00050, 0.00000]\n        },\n        {\n            \"T\": 7,\n            \"Rm\": [0.005, -0.008, 0.013, -0.021, 0.017, 0.002, -0.009],\n            \"Ri\": [0.00240, 0.00240, 0.00240, 0.00240, 0.00240, 0.00240, 0.00240]\n        }\n    ]\n\n    results_as_strings = []\n    \n    for case in test_cases:\n        T = case[\"T\"]\n        Rm = np.array(case[\"Rm\"])\n        Ri = np.array(case[\"Ri\"])\n        \n        # The regression is run over indices t from 2 to T-1.\n        # This corresponds to 0-based array indices from 1 to T-2.\n        \n        # Dependent variable vector y from Ri_t for t in {2, ..., T-1}\n        # Array indices: Ri[1], ..., Ri[T-2]\n        y = Ri[1:T-1]\n        \n        # Design matrix X\n        # For each t in {2, ..., T-1}, the regressors are 1, R_m,t-1, R_m,t, R_m,t+1\n        # which corresponds to array indices Rm[t-2], Rm[t-1], Rm[t].\n        X_rows = []\n        for t_idx in range(1, T - 1): # Corresponds to t = 2, ..., T-1\n            # t = t_idx + 1\n            # R_m,t-1 -> Rm[t-2] -> Rm[t_idx-1]\n            # R_m,t   -> Rm[t-1] -> Rm[t_idx]\n            # R_m,t+1 -> Rm[t]   -> Rm[t_idx+1]\n            row = [1.0, Rm[t_idx - 1], Rm[t_idx], Rm[t_idx + 1]]\n            X_rows.append(row)\n        \n        X = np.array(X_rows)\n        \n        # Solve the ordinary least squares problem y = Xb + e for b\n        # np.linalg.lstsq is numerically stable for this task.\n        coeffs, _, _, _ = np.linalg.lstsq(X, y, rcond=None)\n        \n        # The coefficients are [alpha_i, beta_-1, beta_0, beta_+1]\n        alpha_i = coeffs[0]\n        dimson_beta = coeffs[1] + coeffs[2] + coeffs[3]\n        \n        # Format the result pair as a string and add to the list\n        pair_str = f\"[{alpha_i:.6f},{dimson_beta:.6f}]\"\n        results_as_strings.append(pair_str)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_as_strings)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在估算了单个资产的贝塔系数之后，一个自然而然的问题是：这些贝塔系数能否真正解释资产预期收益的差异？这是资本资产定价模型（CAPM）的核心预测。本练习将引导你完成法玛-麦克贝斯（Fama-MacBeth）两步回归，这是金融经济学中用于检验CAPM证券市场线（SML）的经典实证方法。通过这个练习，你将学习如何从模拟数据生成到执行完整的实证检验，体验从理论假设到计量经济学验证的全过程。",
            "id": "2390281",
            "problem": "本题要求您从第一性原理出发，使用 Fama and MacBeth 两步回归程序，对资本资产定价模型（CAPM）的证券市场线进行完整且可复现的实证检验。请完全使用由一个明确指定的单因子数据生成过程所生成的模拟回报率进行操作，并为每个测试用例使用固定的伪随机种子以确保确定性。所有回报率必须以小数形式表示，而不是百分比。\n\n定义以下对象。对于每个资产指数 $i \\in \\{1,\\dots,N\\}$ 和时间指数 $t \\in \\{1,\\dots,T\\}$，令 $R_{i,t}^{e}$ 表示资产相对于无风险利率的超额回报率，令 $F_{t}$ 表示市场超额回报率。数据生成过程为\n$$\nR_{i,t}^{e} \\;=\\; \\alpha_{i} \\;+\\; \\beta_{i} \\, F_{t} \\;+\\; \\varepsilon_{i,t},\n$$\n其中 $\\varepsilon_{i,t} \\sim \\mathcal{N}(0,\\sigma_{e,i}^{2})$ 在 $i$ 和 $t$ 上独立同分布，且 $F_{t} \\sim \\mathcal{N}(\\mu_{M},\\sigma_{M}^{2})$ 在 $t$ 上独立同分布。无风险利率设为零，因此超额回报率与原始回报率相等。CAPM 证券市场线要求对所有 $i$ 都有 $\\alpha_{i}=0$，并指出横截面预期超额回报率与 $\\beta_{i}$ 呈线性关系，截距为零，斜率等于 $\\mathbb{E}[F_{t}]$。\n\n为每个测试用例精确实现以下定义：\n1. 使用前 $W$ 个时期的数据，通过对时间序列回归进行普通最小二乘估计，为每个资产 $i$ 估算 $\\widehat{\\beta}_{i}$\n$$\nR_{i,t}^{e} \\;=\\; a_{i} \\;+\\; b_{i} \\, F_{t} \\;+\\; u_{i,t}, \\quad t=1,\\dots,W,\n$$\n并令 $\\widehat{\\beta}_{i} \\equiv b_{i}$。\n2. 对于每个时期 $t = W\\!+\\!1,\\dots,T$，对各资产进行横截面回归\n$$\nR_{i,t}^{e} \\;=\\; \\gamma_{0,t} \\;+\\; \\gamma_{1,t} \\, \\widehat{\\beta}_{i} \\;+\\; \\eta_{i,t},\n$$\n以获得时期 $t$ 的估计值 $\\widehat{\\gamma}_{0,t}$ 和 $\\widehat{\\gamma}_{1,t}$。\n3. 令 $T_{\\text{cs}} \\equiv T - W$。计算横截面参数的时间序列平均值，\n$$\n\\bar{\\gamma}_{0} \\;=\\; \\frac{1}{T_{\\text{cs}}} \\sum_{t=W+1}^{T} \\widehat{\\gamma}_{0,t}, \n\\qquad\n\\bar{\\gamma}_{1} \\;=\\; \\frac{1}{T_{\\text{cs}}} \\sum_{t=W+1}^{T} \\widehat{\\gamma}_{1,t}.\n$$\n4. 使用横截面估计值的时间序列变异性计算 Fama and MacBeth 标准误，\n$$\n\\widehat{\\mathrm{se}}(\\bar{\\gamma}_{j}) \\;=\\; \\frac{s(\\widehat{\\gamma}_{j,\\cdot})}{\\sqrt{T_{\\text{cs}}}}, \n\\quad j \\in \\{0,1\\},\n$$\n其中 $s(\\widehat{\\gamma}_{j,\\cdot})$ 是 $\\{\\widehat{\\gamma}_{j,t}\\}_{t=W+1}^{T}$ 的样本标准差，计算时分母为 $T_{\\text{cs}}-1$。然后构建 $t$-统计量，\n$$\nt(\\bar{\\gamma}_{j}) \\;=\\; \\frac{\\bar{\\gamma}_{j}}{\\widehat{\\mathrm{se}}(\\bar{\\gamma}_{j})}, \n\\quad j \\in \\{0,1\\}.\n$$\n\n您的程序必须为以下三个测试用例中的每一个模拟数据并执行上述计算。在所有情况下，请勿转换或重新缩放输入；请完全按照所提供的数据使用。下面给出的所有数字均以小数单位表示。\n\n测试套件（每个项目符号为一个测试用例）：\n- 案例 A（CAPM 成立，存在中等程度的异质性噪声）：\n  • $N=6$, $T=120$, $W=60$。\n  • 真实 beta 值：$(\\beta_{1},\\dots,\\beta_{6}) = (0.6, 0.8, 1.0, 1.2, 1.4, 1.6)$。\n  • 异质性标准差：$(\\sigma_{e,1},\\dots,\\sigma_{e,6}) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02)$。\n  • 市场参数：$\\mu_{M}=0.006$, $\\sigma_{M}=0.04$。\n  • 共同截距：对所有 $i$ 都有 $\\alpha_{i}=0$。\n  • 随机种子：$12345$。\n- 案例 B（通过一个共同的非零截距项来违背证券市场线）：\n  • $N=6$, $T=120$, $W=60$。\n  • 真实 beta 值：$(\\beta_{1},\\dots,\\beta_{6}) = (0.6, 0.8, 1.0, 1.2, 1.4, 1.6)$。\n  • 异质性标准差：$(\\sigma_{e,1},\\dots,\\sigma_{e,6}) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02)$。\n  • 市场参数：$\\mu_{M}=0.006$, $\\sigma_{M}=0.04$。\n  • 共同截距：对所有 $i$ 都有 $\\alpha_{i}=0.002$。\n  • 随机种子：$67890$。\n- 案例 C（较短的估计窗口和较高的异质性噪声）：\n  • $N=4$, $T=90$, $W=24$。\n  • 真实 beta 值：$(\\beta_{1},\\dots,\\beta_{4}) = (0.5, 1.0, 1.5, 2.0)$。\n  • 异质性标准差：$(\\sigma_{e,1},\\dots,\\sigma_{e,4}) = (0.06, 0.05, 0.04, 0.03)$。\n  • 市场参数：$\\mu_{M}=0.005$, $\\sigma_{M}=0.05$。\n  • 共同截距：对所有 $i$ 都有 $\\alpha_{i}=0$。\n  • 随机种子：$24680$。\n\n对于每个案例，计算四元组\n$$\n\\left[ \\bar{\\gamma}_{0},\\; \\bar{\\gamma}_{1},\\; t(\\bar{\\gamma}_{0}),\\; t(\\bar{\\gamma}_{1}) \\right],\n$$\n并将每个条目四舍五入到 $6$ 位小数。\n\n您的程序应生成单行输出，其中包含这些三个四元组的结果，以逗号分隔，并用方括号括起来，例如\n$[\\,[x_{A},y_{A},z_{A},w_{A}],\\,[x_{B},y_{B},z_{B},w_{B}],\\,[x_{C},y_{C},z_{C},w_{C}]\\,]$,\n其中每个符号代表一个按上述规定四舍五入后的小数。不允许有其他输出。",
            "solution": "资本资产定价模型 (CAPM) 假设预期超额回报率与市场风险暴露之间存在线性关系，此关系由证券市场线所概括。形式上，对于超额回报率为 $R_{i,t}^{e}$ 的资产 $i$ 和市场超额回报率为 $F_{t}$，该模型陈述为\n$$\n\\mathbb{E}[R_{i,t}^{e}] \\;=\\; \\beta_{i} \\,\\mathbb{E}[F_{t}],\n$$\n这等价于因子表达式\n$$\nR_{i,t}^{e} \\;=\\; \\alpha_{i} \\;+\\; \\beta_{i} \\, F_{t} \\;+\\; \\varepsilon_{i,t}\n$$\n中的截距项 $\\alpha_{i}$ 对所有 $i$ 均为零的条件。\n\nFama and MacBeth（两步）方法首先估计风险暴露，然后在横截面中对其进行定价。其原理是将时间序列的风险估计与横截面的定价分开，并利用横截面斜率和截距的时间序列变异性来构建标准误。\n\n分步推导：\n\n1. beta 的时间序列估计。对于每个资产 $i$，考虑在初始窗口 $t=1,\\dots,W$ 上的回归，\n$$\nR_{i,t}^{e} \\;=\\; a_{i} \\;+\\; b_{i} \\, F_{t} \\;+\\; u_{i,t}.\n$$\n普通最小二乘法 (OLS) 估计值 $b_{i}$ 求解\n$$\n\\min_{(a_{i},b_{i})} \\sum_{t=1}^{W} \\left(R_{i,t}^{e} - a_{i} - b_{i} F_{t}\\right)^{2},\n$$\n得到正规方程组，\n$$\n\\begin{bmatrix}\nW & \\sum_{t=1}^{W} F_{t} \\\\\n\\sum_{t=1}^{W} F_{t} & \\sum_{t=1}^{W} F_{t}^{2}\n\\end{bmatrix}\n\\begin{bmatrix}\na_{i} \\\\\nb_{i}\n\\end{bmatrix}\n\\;=\\;\n\\begin{bmatrix}\n\\sum_{t=1}^{W} R_{i,t}^{e} \\\\\n\\sum_{t=1}^{W} F_{t} R_{i,t}^{e}\n\\end{bmatrix}.\n$$\n求解得出 $b_{i} \\equiv \\widehat{\\beta}_{i}$，即资产 $i$ 的估计市场风险暴露。这是第一性原理的 OLS 解：$b_{i}$ 是 $R_{i,t}^{e}$ 对 $F_{t}$ 和一个常数进行线性投影时的斜率系数。\n\n2. 每个时期的横截面定价。对于每个 $t=W+1,\\dots,T$，我们将集合 $\\{\\widehat{\\beta}_{i}\\}_{i=1}^{N}$ 视为固定的回归量，并对所有资产进行横截面 OLS 回归，\n$$\nR_{i,t}^{e} \\;=\\; \\gamma_{0,t} \\;+\\; \\gamma_{1,t} \\, \\widehat{\\beta}_{i} \\;+\\; \\eta_{i,t}.\n$$\n对 $i$ 进行堆叠可得 $y_{t} = X \\gamma_{t} + \\eta_{t}$，其中 $y_{t}$ 是回报率 $R_{i,t}^{e}$ 的 $N \\times 1$ 向量，$X$ 是一个 $N \\times 2$ 矩阵，第一列为 1，第二列为 $\\widehat{\\beta}$，且 $\\gamma_{t} = (\\gamma_{0,t},\\gamma_{1,t})^{\\top}$。OLS 估计量为\n$$\n\\widehat{\\gamma}_{t} \\;=\\; (X^{\\top}X)^{-1} X^{\\top} y_{t},\n$$\n从而得出时期 $t$ 的 $\\widehat{\\gamma}_{0,t}$ (截距) 和 $\\widehat{\\gamma}_{1,t}$ (斜率)。\n\n3. 时间序列聚合与标准误。对于 $T_{\\text{cs}} = T - W$ 个横截面，定义样本均值\n$$\n\\bar{\\gamma}_{j} \\;=\\; \\frac{1}{T_{\\text{cs}}} \\sum_{t=W+1}^{T} \\widehat{\\gamma}_{j,t}, \\quad j \\in \\{0,1\\}.\n$$\nFama and MacBeth 标准误使用逐期估计值的时间序列离散度：\n$$\n\\widehat{\\mathrm{se}}(\\bar{\\gamma}_{j}) \\;=\\; \\frac{s(\\widehat{\\gamma}_{j,\\cdot})}{\\sqrt{T_{\\text{cs}}}},\n$$\n其中 $s(\\widehat{\\gamma}_{j,\\cdot})$ 是样本标准差\n$$\ns(\\widehat{\\gamma}_{j,\\cdot}) \\;=\\; \\sqrt{\\frac{1}{T_{\\text{cs}}-1} \\sum_{t=W+1}^{T} \\left(\\widehat{\\gamma}_{j,t} - \\bar{\\gamma}_{j}\\right)^{2}}.\n$$\n于是 $t$-统计量为\n$$\nt(\\bar{\\gamma}_{j}) \\;=\\; \\frac{\\bar{\\gamma}_{j}}{\\widehat{\\mathrm{se}}(\\bar{\\gamma}_{j})}.\n$$\n\n在 CAPM 下的解释：\n- 如果在数据生成过程中 CAPM 成立，则对所有 $i$ 都有 $\\alpha_{i} = 0$，这意味着 $\\bar{\\gamma}_{0}$ 应接近于零，并且对于足够大的 $T_{\\text{cs}}$，$t(\\bar{\\gamma}_{0})$ 在统计上不应显著异于零。\n- 斜率 $\\bar{\\gamma}_{1}$ 应接近 $\\mathbb{E}[F_{t}] = \\mu_{M}$，而 $t(\\bar{\\gamma}_{1})$ 则应指明 beta 风险的平均价格在统计上是否显著异于零。\n\n模拟设计与可复现性：\n- 对于每个案例，使用指定的种子独立生成抽样 $F_{t} \\sim \\mathcal{N}(\\mu_{M},\\sigma_{M}^{2})$ 和 $\\varepsilon_{i,t} \\sim \\mathcal{N}(0,\\sigma_{e,i}^{2})$。\n- 超额回报率按 $R_{i,t}^{e} = \\alpha_{i} + \\beta_{i} F_{t} + \\varepsilon_{i,t}$ 构建，其中 $t=1,\\dots,T$。\n- 从前 $W$ 个时期估计出的相同 $\\widehat{\\beta}_{i}$ 将用作所有后续横截面回归的回归量。\n\n基于原理的算法实现：\n- 为每个资产构建时间序列 OLS 的设计矩阵，其列为 $(\\mathbf{1}, F_{1:W})$，并使用线性代数求解正规方程组以获得 $\\widehat{\\beta}_{i}$。\n- 构建横截面设计矩阵，其列为 $(\\mathbf{1}, \\widehat{\\beta})$，并对每个 $t=W+1,\\dots,T$，将 $R_{\\cdot,t}^{e}$ 对其进行回归，以获得 $\\widehat{\\gamma}_{0,t}$ 和 $\\widehat{\\gamma}_{1,t}$。\n- 聚合计算 $\\bar{\\gamma}_{0}$、$\\bar{\\gamma}_{1}$ 及其定义的 $t$-统计量。\n- 将每个报告的数字四舍五入到 6 位小数，以匹配所需的输出精度。\n\n最终输出是三个四元组的列表，每个案例一个，\n$$\n\\left[ \\left[\\bar{\\gamma}_{0}^{A},\\bar{\\gamma}_{1}^{A}, t(\\bar{\\gamma}_{0}^{A}), t(\\bar{\\gamma}_{1}^{A})\\right], \\left[\\bar{\\gamma}_{0}^{B},\\bar{\\gamma}_{1}^{B}, t(\\bar{\\gamma}_{0}^{B}), t(\\bar{\\gamma}_{1}^{B})\\right], \\left[\\bar{\\gamma}_{0}^{C},\\bar{\\gamma}_{1}^{C}, t(\\bar{\\gamma}_{0}^{C}), t(\\bar{\\gamma}_{1}^{C})\\right] \\right],\n$$\n打印在单行上，其中上标 $A$、$B$ 和 $C$ 为测试案例的索引。鉴于种子和参数是给定的，输出是确定性的。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef estimate_beta_time_series(R_excess, F, W):\n    \"\"\"\n    Estimate beta_i for each asset i using OLS on the first W periods:\n    R_i,t^e = a_i + b_i * F_t + u_i,t\n    Returns array of shape (N,) with beta estimates b_i.\n    \"\"\"\n    N = R_excess.shape[0]\n    X = np.column_stack([np.ones(W), F[:W]])\n    XtX = X.T @ X\n    XtX_inv = np.linalg.inv(XtX)\n    betas_hat = np.empty(N)\n    for i in range(N):\n        y = R_excess[i, :W]\n        coef = XtX_inv @ (X.T @ y)\n        betas_hat[i] = coef[1]\n    return betas_hat\n\ndef cross_sectional_gammas(R_excess, betas_hat, start_t):\n    \"\"\"\n    For each t from start_t to T-1, run cross-sectional OLS:\n    R_i,t^e = gamma0_t + gamma1_t * betas_hat_i + eta_i,t\n    Returns arrays gamma0 (Tcs,), gamma1 (Tcs,)\n    \"\"\"\n    N, T = R_excess.shape\n    Tcs = T - start_t\n    ones = np.ones(N)\n    X = np.column_stack([ones, betas_hat])  # shape (N, 2)\n    XtX = X.T @ X\n    XtX_inv = np.linalg.inv(XtX)\n    gamma0 = np.empty(Tcs)\n    gamma1 = np.empty(Tcs)\n    idx = 0\n    for t in range(start_t, T):\n        y = R_excess[:, t]\n        gamma = XtX_inv @ (X.T @ y)\n        gamma0[idx] = gamma[0]\n        gamma1[idx] = gamma[1]\n        idx += 1\n    return gamma0, gamma1\n\ndef fm_summary_stats(gamma_series):\n    \"\"\"\n    Given a 1-D array of period-by-period gammas (length Tcs),\n    return (mean, t_stat) using FM time-series standard error.\n    \"\"\"\n    Tcs = gamma_series.shape[0]\n    mean_val = float(np.mean(gamma_series))\n    # sample standard deviation with ddof=1\n    if Tcs > 1:\n        sd = float(np.std(gamma_series, ddof=1))\n        se = sd / np.sqrt(Tcs)\n        t_stat = mean_val / se if se > 0 else 0.0\n    else:\n        # Degenerate case; define t-stat as 0\n        t_stat = 0.0\n    return mean_val, t_stat\n\ndef simulate_case(N, T, W, betas_true, sigmas_e, mu_M, sigma_M, alpha_common, seed):\n    \"\"\"\n    Simulate factor and returns according to:\n    R_i,t^e = alpha_common + beta_i * F_t + eps_i,t\n    with F_t ~ N(mu_M, sigma_M^2), eps_i,t ~ N(0, sigma_e_i^2).\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    F = rng.normal(loc=mu_M, scale=sigma_M, size=T)\n    R_excess = np.empty((N, T))\n    betas_true = np.asarray(betas_true, dtype=float)\n    sigmas_e = np.asarray(sigmas_e, dtype=float)\n    for i in range(N):\n        eps = rng.normal(loc=0.0, scale=sigmas_e[i], size=T)\n        R_excess[i, :] = alpha_common + betas_true[i] * F + eps\n    return R_excess, F\n\ndef run_case(N, T, W, betas_true, sigmas_e, mu_M, sigma_M, alpha_common, seed):\n    R_excess, F = simulate_case(N, T, W, betas_true, sigmas_e, mu_M, sigma_M, alpha_common, seed)\n    betas_hat = estimate_beta_time_series(R_excess, F, W)\n    gamma0_series, gamma1_series = cross_sectional_gammas(R_excess, betas_hat, W)\n    g0_mean, g0_t = fm_summary_stats(gamma0_series)\n    g1_mean, g1_t = fm_summary_stats(gamma1_series)\n    # Round to 6 decimals as required\n    return [round(g0_mean, 6), round(g1_mean, 6), round(g0_t, 6), round(g1_t, 6)]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A\n        {\n            \"N\": 6,\n            \"T\": 120,\n            \"W\": 60,\n            \"betas_true\": [0.6, 0.8, 1.0, 1.2, 1.4, 1.6],\n            \"sigmas_e\": [0.02, 0.02, 0.02, 0.02, 0.02, 0.02],\n            \"mu_M\": 0.006,\n            \"sigma_M\": 0.04,\n            \"alpha_common\": 0.0,\n            \"seed\": 12345,\n        },\n        # Case B\n        {\n            \"N\": 6,\n            \"T\": 120,\n            \"W\": 60,\n            \"betas_true\": [0.6, 0.8, 1.0, 1.2, 1.4, 1.6],\n            \"sigmas_e\": [0.02, 0.02, 0.02, 0.02, 0.02, 0.02],\n            \"mu_M\": 0.006,\n            \"sigma_M\": 0.04,\n            \"alpha_common\": 0.002,\n            \"seed\": 67890,\n        },\n        # Case C\n        {\n            \"N\": 4,\n            \"T\": 90,\n            \"W\": 24,\n            \"betas_true\": [0.5, 1.0, 1.5, 2.0],\n            \"sigmas_e\": [0.06, 0.05, 0.04, 0.03],\n            \"mu_M\": 0.005,\n            \"sigma_M\": 0.05,\n            \"alpha_common\": 0.0,\n            \"seed\": 24680,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        res = run_case(\n            N=case[\"N\"],\n            T=case[\"T\"],\n            W=case[\"W\"],\n            betas_true=case[\"betas_true\"],\n            sigmas_e=case[\"sigmas_e\"],\n            mu_M=case[\"mu_M\"],\n            sigma_M=case[\"sigma_M\"],\n            alpha_common=case[\"alpha_common\"],\n            seed=case[\"seed\"],\n        )\n        results.append(res)\n\n    # Final print statement in the exact required format.\n    # Format as a single line: [[a,b,c,d],[a,b,c,d],[a,b,c,d]]\n    print(\"[\" + \",\".join(\"[\" + \",\".join(f\"{x:.6f}\" for x in arr) + \"]\" for arr in results) + \"]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}