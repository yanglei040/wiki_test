{
    "hands_on_practices": [
        {
            "introduction": "一个好的模型应该能捕捉数据中所有的系统性模式，只在残差中留下随机噪声。本练习将引导你通过一个模拟来亲眼见证这一原则。通过比较资本资产定价模型 (CAPM) 和 Fama-French 三因子模型的残差，你将亲手验证为何增加规模（SMB）和价值（HML）因子能够更完整地解释资产回报 。",
            "id": "2448010",
            "problem": "考虑单个资产的一系列超额回报，其由一个带有白噪声扰动的线性因子模型建模。令市场因子、规模因子和价值因子分别由 $M_t$、$\\mathrm{SMB}_t$ 和 $\\mathrm{HML}_t$ 表示。对于每个时间指数 $t \\in \\{1,2,\\dots,T\\}$，资产的超额回报 $R_t^{e}$ 由以下公式生成：\n$$\nR_t^{e} \\;=\\; \\alpha \\;+\\; \\beta_M M_t \\;+\\; \\beta_S \\mathrm{SMB}_t \\;+\\; \\beta_H \\mathrm{HML}_t \\;+\\; \\varepsilon_t,\n$$\n其中扰动项 $\\{\\varepsilon_t\\}$ 是一个白噪声过程：$\\mathbb{E}[\\varepsilon_t]=0$，$\\operatorname{Var}(\\varepsilon_t)=\\sigma_{\\varepsilon}^2$，且对于 $t\\neq s$ 有 $\\operatorname{Cov}(\\varepsilon_t,\\varepsilon_s)=0$。\n\n因子 $(M_t,\\mathrm{SMB}_t,\\mathrm{HML}_t)$ 服从独立的、带高斯新息和零初始条件的一阶自回归过程：\n$$\nM_t \\;=\\; \\phi_M M_{t-1} \\;+\\; \\eta_{M,t}, \\quad \\mathrm{SMB}_t \\;=\\; \\phi_S \\mathrm{SMB}_{t-1} \\;+\\; \\eta_{S,t}, \\quad \\mathrm{HML}_t \\;=\\; \\phi_H \\mathrm{HML}_{t-1} \\;+\\; \\eta_{H,t},\n$$\n其中 $M_0=\\mathrm{SMB}_0=\\mathrm{HML}_0=0$，且 $\\{\\eta_{M,t}\\}$、$\\{\\eta_{S,t}\\}$ 和 $\\{\\eta_{H,t}\\}$ 是相互独立的、独立同分布的高斯随机变量序列，各自均值为 $0$，方差的选择使得每个因子过程的平稳方差为 $1$。即，对于 $f \\in \\{M,S,H\\}$，新息方差满足 $\\operatorname{Var}(\\eta_{f,t})=1-\\phi_f^2$。\n\n对于 $\\{(R_t^{e},M_t,\\mathrm{SMB}_t,\\mathrm{HML}_t)\\}_{t=1}^T$ 的一个给定实现，考虑两个带截距项的线性回归：\n(1) 资本资产定价模型 (Capital Asset Pricing Model, CAPM)：$R_t^{e}$ 对 $\\{1,M_t\\}$ 的回归，以及\n(2) Fama-French 三因子模型：$R_t^{e}$ 对 $\\{1,M_t,\\mathrm{SMB}_t,\\mathrm{HML}_t\\}$ 的回归。\n两者均通过最小二乘法进行估计，即最小化残差平方和，从而产生残差序列 $\\{e^{\\mathrm{CAPM}}_t\\}_{t=1}^T$ 和 $\\{e^{\\mathrm{FF3}}_t\\}_{t=1}^T$。\n\n对于残差序列 $\\{e_t\\}_{t=1}^T$，定义其在滞后 $k$ 阶的样本自相关为\n$$\n\\hat{r}_k \\;=\\; \\frac{\\sum_{t=k+1}^{T} (e_t - \\bar{e})(e_{t-k} - \\bar{e})}{\\sum_{t=1}^{T} (e_t - \\bar{e})^2}, \\quad \\text{其中 } \\bar{e}=\\frac{1}{T}\\sum_{t=1}^{T} e_t.\n$$\n定义最大滞后阶数为 $m$ 的 Ljung-Box Q 统计量为\n$$\nQ(m) \\;=\\; T(T+2)\\sum_{k=1}^{m} \\frac{\\hat{r}_k^2}{T-k}.\n$$\n在残差为白噪声的原假设下，$Q(m)$ 的参考分布为自由度为 $m$ 的卡方分布。对于一个给定的残差序列，令其白度 $p$ 值为 $p = 1 - F_{\\chi^2_m}(Q(m))$，其中 $F_{\\chi^2_m}$ 表示自由度为 $m$ 的卡方分布的累积分布函数。定义一组残差比另一组残差“更白”，如果其 Ljung-Box $p$ 值严格更大。\n\n为了可复现性，使用一个固定的随机种子，根据上述规格生成因子过程和资产回报，并对下面的每个测试用例，估计两种回归模型并计算指定最大滞后阶数下的 Ljung-Box $p$ 值。对于每个测试用例，如果 Fama-French 三因子模型的残差比 CAPM 的残差更白，则输出布尔值 true，否则输出 false。\n\n所有用例中使用的全局模拟参数：\n- 因子自回归系数：$\\phi_M=0.6$, $\\phi_S=0.5$, $\\phi_H=0.4$。\n- 初始条件：$M_0=\\mathrm{SMB}_0=\\mathrm{HML}_0=0$。\n\n测试套件（四个用例），每个用例由 $(T, \\beta_M, \\beta_S, \\beta_H, \\sigma_{\\varepsilon}, m)$ 指定：\n- 用例 $1$：$(T=\\;600,\\;\\beta_M=\\;0.9,\\;\\beta_S=\\;0.5,\\;\\beta_H=\\;-0.3,\\;\\sigma_{\\varepsilon}=\\;0.5,\\;m=\\;10)$。\n- 用例 $2$：$(T=\\;600,\\;\\beta_M=\\;1.1,\\;\\beta_S=\\;0.0,\\;\\beta_H=\\;0.0,\\;\\sigma_{\\varepsilon}=\\;0.5,\\;m=\\;10)$。\n- 用例 $3$：$(T=\\;120,\\;\\beta_M=\\;0.0,\\;\\beta_S=\\;0.8,\\;\\beta_H=\\;0.8,\\;\\sigma_{\\varepsilon}=\\;0.5,\\;m=\\;10)$。\n- 用例 $4$：$(T=\\;60,\\;\\beta_M=\\;0.0,\\;\\beta_S=\\;0.0,\\;\\beta_H=\\;0.0,\\;\\sigma_{\\varepsilon}=\\;1.0,\\;m=\\;10)$。\n\n随机性与重用规则：\n- 使用一个长度为 $T_{\\max}$ 的因子过程的共同实现，其中 $T_{\\max}$ 是测试用例中最大的 $T$。对于每个用例，使用每个因子的前 $T$ 个观测值。使用一个固定的、明确指定的随机种子，以唯一确定该实现。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个方括号内的、逗号分隔的四个布尔值列表，按测试用例的顺序排列，例如 $[\\mathrm{True},\\mathrm{False},\\mathrm{True},\\mathrm{False}]$。\n- 不涉及物理单位。不涉及角度。如果需要任何分数，应表示为小数，但这里要求的输出仅为布尔值。",
            "solution": "所提出的问题是金融计量经济学中一个明确定义的模拟练习。它在科学上基于线性因子模型和模型诊断的理论，特别是关于遗漏变量偏差及其通过回归残差的序列相关性检验进行检测。该问题是完整的、一致的且客观陈述的，因此是一个有效的问题。我们将着手解决它。\n\n所考察的基本原理是模型的正确设定。资产超额回报 $R_t^{e}$ 的数据生成过程 (DGP) 由 Fama-French 三因子模型加上一个附加的白噪声扰动项 $\\{\\varepsilon_t\\}$ 给出：\n$$\nR_t^{e} \\;=\\; \\alpha \\;+\\; \\beta_M M_t \\;+\\; \\beta_S \\mathrm{SMB}_t \\;+\\; \\beta_H \\mathrm{HML}_t \\;+\\; \\varepsilon_t\n$$\n因子本身 $\\{M_t\\}$、$\\{\\mathrm{SMB}_t\\}$ 和 $\\{\\mathrm{HML}_t\\}$ 并非白噪声，而是表现出时间依赖性，因为它们被建模为一阶自回归 (AR($1$)) 过程。\n\n当我们通过将 $R_t^e$ 仅对一个常数和市场因子 $M_t$ 进行回归来估计资本资产定价模型 (CAPM) 时，如果真实系数 $\\beta_S$ 或 $\\beta_H$ 非零，我们就会引入设定误差。被遗漏的因子 $\\mathrm{SMB}_t$ 和 $\\mathrm{HML}_t$ 的影响被 CAPM 的残差项所吸收。令估计的 CAPM 为 $\\hat{R}_t^e = \\hat{a}_{\\mathrm{CAPM}} + \\hat{b}_M M_t$。由此产生的残差 $e_t^{\\mathrm{CAPM}} = R_t^e - \\hat{R}_t^e$ 将近似于：\n$$\ne_t^{\\mathrm{CAPM}} \\approx (\\alpha - \\hat{a}_{\\mathrm{CAPM}}) + (\\beta_M - \\hat{b}_M) M_t + \\beta_S \\mathrm{SMB}_t + \\beta_H \\mathrm{HML}_t + \\varepsilon_t\n$$\n由于 $\\mathrm{SMB}_t$ 和 $\\mathrm{HML}_t$ 是序列相关的，这种自相关结构被传递给了 CAPM 的残差，导致它们偏离白噪声。\n\n相反，估计 Fama-French 三因子模型与 DGP 是一致的。来自这个正确设定模型的残差 $e_t^{\\mathrm{FF3}}$ 将是真实新息 $\\varepsilon_t$ 的一致估计量，而新息被规定为白噪声。\n\nLjung-Box 检验是用于检验自相关的正式统计检验。检验统计量 $Q(m)$ 汇总了前 $m$ 个样本自相关的平方。在序列是白噪声的原假设下，$Q(m)$ 近似服从自由度为 $m$ 的卡方随机变量分布。一个低的 p 值表示拒绝原假设，表明存在显著的序列相关性。\n\n因此，当 $\\beta_S$ 或 $\\beta_H$ 非零时，我们预期应用于错误设定的 CAPM 残差的 Ljung-Box 检验会产生一个低的 p 值（检测到自相关）。对 FF3 残差的检验应产生一个高的 p 值（未能检测到自相关）。问题将“更白”的残差定义为具有严格更大的 p 值的残差，因此我们预计在 CAPM 模型错误设定的情况下，FF3 的残差将比 CAPM 的残差更白。在 CAPM 是真实模型的情况下（即 $\\beta_S = \\beta_H = 0$），两个残差序列都应近似为白噪声，p 值的任何差异都源于有限样本的估计方差。\n\n解决该问题的算法如下：\n$1$. **设置**：为了可复现性，使用一个固定的随机种子（$42$）。定义全局参数（$\\phi_M=0.6$, $\\phi_S=0.5$, $\\phi_H=0.4$）。在不失一般性的前提下，DGP 中的截距项 $\\alpha$ 被设为 $0$，因为带有截距项的普通最小二乘法（OLS）对此类平移是不变的。\n\n$2$. **因子生成**：将因子过程（$M_t, \\mathrm{SMB}_t, \\mathrm{HML}_t$）生成为长度为 $T_{\\max}=600$（测试套件所需的最大长度）的 AR($1$) 序列。对于每个因子 $f \\in \\{M,S,H\\}$，新息方差设为 $\\sigma^2_{\\eta,f} = 1 - \\phi_f^2$，以确保因子的平稳方差为 $1$。初始条件为 $M_0=\\mathrm{SMB}_0=\\mathrm{HML}_0=0$。\n\n$3$. **迭代分析**：我们遍历四个测试用例中的每一个。对于给定参数 $(T, \\beta_M, \\beta_S, \\beta_H, \\sigma_{\\varepsilon}, m)$ 的用例：\n    a. 我们选择已生成的因子序列的前 $T$ 个观测值。\n    b. 使用特定用例的 $\\beta$ 参数和一新序列的高斯白噪声误差 $\\varepsilon_t \\sim \\mathcal{N}(0, \\sigma_{\\varepsilon}^2)$ 来合成资产回报序列 $R_t^e$。\n    c. 使用普通最小二乘法 (OLS) 估计两个模型：\n        i. CAPM：$R_t^e$ 对一个常数和 $M_t$ 的回归。\n        ii. FF3：$R_t^e$ 对一个常数、$M_t$、$\\mathrm{SMB}_t$ 和 $\\mathrm{HML}_t$ 的回归。\n    d. 为每个模型计算残差向量 $e^{\\mathrm{CAPM}}$ 和 $e^{\\mathrm{FF3}}$。\n    e. 使用样本自相关 $\\hat{r}_k$ 和 $Q(m)$ 统计量的给定公式，并以 $\\chi^2_m$ 作为参考分布，为两个残差序列计算 Ljung-Box p 值。\n    f. 通过条件 $p_{\\mathrm{FF3}}  p_{\\mathrm{CAPM}}$ 来确定一个布尔结果。\n\n$4$. **最终输出**：将四个布尔结果的列表按指定格式进行格式化并打印。\n\n该实现将使用 `numpy` 进行数组计算和通过 `numpy.linalg.lstsq` 进行 OLS 估计，并使用 `scipy.stats.chi2.cdf` 来计算卡方累积分布函数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import chi2\n\ndef solve():\n    \"\"\"\n    Solves the problem by simulating asset returns, estimating CAPM and FF3 models,\n    and comparing the whiteness of their residuals using the Ljung-Box test.\n    \"\"\"\n    # Define global simulation parameters and random seed for reproducibility.\n    SEED = 42\n    rng = np.random.default_rng(SEED)\n    \n    phi_M = 0.6\n    phi_S = 0.5\n    phi_H = 0.4\n    alpha = 0.0  # Assumed value, does not affect residuals with intercept.\n\n    # Define the test suite.\n    test_cases = [\n        # (T, beta_M, beta_S, beta_H, sigma_eps, m)\n        (600, 0.9, 0.5, -0.3, 0.5, 10),\n        (600, 1.1, 0.0, 0.0, 0.5, 10),\n        (120, 0.0, 0.8, 0.8, 0.5, 10),\n        (60, 0.0, 0.0, 0.0, 1.0, 10),\n    ]\n\n    T_max = max(case[0] for case in test_cases)\n\n    def generate_ar1(T, phi, rng_gen):\n        \"\"\"Generates an AR(1) process of length T with stationary variance 1.\"\"\"\n        sigma_eta = np.sqrt(1 - phi**2)\n        eta = rng_gen.normal(loc=0.0, scale=sigma_eta, size=T)\n        process = np.zeros(T)\n        # Process starts at t=1 with F_0 = 0.\n        # F_1 = phi * F_0 + eta_1 = eta_1.\n        if T > 0:\n            process[0] = eta[0]\n            for t in range(1, T):\n                process[t] = phi * process[t-1] + eta[t]\n        return process\n\n    # Generate a single common realization of factor processes.\n    M_full = generate_ar1(T_max, phi_M, rng)\n    SMB_full = generate_ar1(T_max, phi_S, rng)\n    HML_full = generate_ar1(T_max, phi_H, rng)\n    \n    def ljung_box_p_value(residuals, m):\n        \"\"\"Computes the Ljung-Box Q-statistic and its p-value.\"\"\"\n        T = len(residuals)\n        e_bar = np.mean(residuals) # Should be ~0 for OLS with intercept\n        e_demeaned = residuals - e_bar\n        \n        denominator = np.sum(e_demeaned**2)\n        if denominator  1e-12:  # Avoid division by zero\n            return 1.0  # No variation means no autocorrelation.\n\n        q_terms = []\n        for k in range(1, m + 1):\n            numerator_k = np.sum(e_demeaned[k:] * e_demeaned[:-k])\n            r_k = numerator_k / denominator\n            q_terms.append(r_k**2 / (T - k))\n            \n        Q_m = T * (T + 2) * np.sum(q_terms)\n        \n        # p-value from chi-square distribution with m degrees of freedom.\n        p_val = 1.0 - chi2.cdf(Q_m, df=m)\n        return p_val\n\n    results = []\n    for case in test_cases:\n        T, beta_M, beta_S, beta_H, sigma_eps, m = case\n\n        # Use the first T observations of the common factor series.\n        M_t = M_full[:T]\n        SMB_t = SMB_full[:T]\n        HML_t = HML_full[:T]\n\n        # Generate asset returns for the current case.\n        epsilon = rng.normal(loc=0.0, scale=sigma_eps, size=T)\n        R_e = alpha + beta_M * M_t + beta_S * SMB_t + beta_H * HML_t + epsilon\n\n        # (1) Estimate CAPM and get residuals.\n        X_capm = np.vstack([np.ones(T), M_t]).T\n        beta_hat_capm = np.linalg.lstsq(X_capm, R_e, rcond=None)[0]\n        e_capm = R_e - X_capm @ beta_hat_capm\n        \n        # (2) Estimate Fama-French 3-factor model and get residuals.\n        X_ff3 = np.vstack([np.ones(T), M_t, SMB_t, HML_t]).T\n        beta_hat_ff3 = np.linalg.lstsq(X_ff3, R_e, rcond=None)[0]\n        e_ff3 = R_e - X_ff3 @ beta_hat_ff3\n\n        # Compute Ljung-Box p-values for both residual series.\n        p_val_capm = ljung_box_p_value(e_capm, m)\n        p_val_ff3 = ljung_box_p_value(e_ff3, m)\n\n        # Compare p-values to determine which residual set is \"whiter\".\n        is_ff3_whiter = p_val_ff3 > p_val_capm\n        results.append(is_ff3_whiter)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Fama-French 因子并非抽象概念，它们是根据基础资产构建的可交易投资组合。本练习让你扮演一位量化研究员，任务是为一个新特征（如 ESG 评分）构建一个“因子模拟投资组合”。你将运用约束最优化方法，构建一个对目标因子具有单位暴露、同时对其他已知因子暴露为零的投资组合，从而掌握实证资产定价中的一项核心技术 。",
            "id": "2392242",
            "problem": "给定一组截面资产及其与Fama-French三因子模型（FF3）和一个新颖特征相关的风险暴露。Fama-French三因子模型（FF3）包括市场因子、小市值减大市值（SMB）和高账面市值比减低账面市值比（HML）。这个新颖的特征是环境、社会和治理（ESG）得分。您的任务是使用给定的资产超额收益面板数据，在特定的线性风险暴露约束下，为ESG特征构建最小方差因子模拟投资组合。\n\n假设有 $N=6$ 种资产和 $T=10$ 个时间周期。令 $R \\in \\mathbb{R}^{T \\times N}$ 表示以小数形式表示的资产超额收益矩阵，其中第 $t$ 行包含第 $t$ 期的 $N$ 种资产的超额收益。$R$ 的数据如下：\n- 第1行：$(0.012, 0.008, 0.015, 0.005, 0.010, 0.011)$\n- 第2行：$(-0.020, -0.015, -0.018, -0.022, -0.017, -0.019)$\n- 第3行：$(0.025, 0.020, 0.028, 0.018, 0.022, 0.024)$\n- 第4行：$(0.005, 0.007, 0.004, 0.009, 0.006, 0.005)$\n- 第5行：$(0.030, 0.026, 0.033, 0.021, 0.027, 0.029)$\n- 第6行：$(-0.010, -0.012, -0.009, -0.013, -0.011, -0.010)$\n- 第7行：$(0.018, 0.014, 0.020, 0.012, 0.016, 0.017)$\n- 第8行：$(-0.005, -0.006, -0.004, -0.007, -0.005, -0.005)$\n- 第9行：$(0.022, 0.019, 0.024, 0.016, 0.020, 0.021)$\n- 第10行：$(0.003, 0.004, 0.002, 0.005, 0.003, 0.003)$\n\n令 $\\Sigma \\in \\mathbb{R}^{N \\times N}$ 表示资产超额收益的协方差矩阵，其计算方式为总体协方差估计量：\n$$\n\\Sigma \\;=\\; \\frac{1}{T} \\sum_{t=1}^{T} \\left( r_t - \\bar{r} \\right)\\left( r_t - \\bar{r} \\right)^{\\top},\n$$\n其中 $r_t \\in \\mathbb{R}^{N}$ 是 $R$ 的第 $t$ 行，$\\bar{r} \\in \\mathbb{R}^{N}$ 是资产收益的时间序列均值向量。\n\n此外，还给出了每种资产对FF3因子和ESG特征的风险暴露向量。令 $f^{\\text{MKT}}, f^{\\text{SMB}}, f^{\\text{HML}}, f^{\\text{ESG}} \\in \\mathbb{R}^{N}$ 表示每种资产的风险暴露：\n- $f^{\\text{MKT}} = (1.10, 0.90, 1.20, 0.80, 1.00, 1.05)$\n- $f^{\\text{SMB}} = (-0.30, 0.50, -0.20, 0.70, 0.10, -0.40)$\n- $f^{\\text{HML}} = (0.60, -0.20, 0.40, -0.50, 0.00, 0.30)$\n- $f^{\\text{ESG}} = (0.80, 0.20, -0.40, 1.10, -0.60, 0.30)$\n\n因子模拟投资组合是一个投资组合权重向量 $w \\in \\mathbb{R}^{N}$，其选择旨在在满足线性风险暴露约束的条件下最小化投资组合方差。形式上，对于给定的约束矩阵 $A \\in \\mathbb{R}^{K \\times N}$ 和目标风险暴露向量 $b \\in \\mathbb{R}^{K}$，权重 $w$ 求解以下问题：\n$$\n\\min_{w \\in \\mathbb{R}^{N}} \\; w^{\\top}\\Sigma w \\quad \\text{subject to} \\quad A w = b.\n$$\n\n考虑以下四个测试用例，每个用例都指定了一组约束条件。令 $\\mathbf{1} \\in \\mathbb{R}^{N}$ 表示全为1的向量。\n\n- 测试用例1（自融资，对FF3中性，单位ESG暴露）：\n  - 约束条件：$\\mathbf{1}^{\\top} w = 0$, $(f^{\\text{MKT}})^{\\top} w = 0$, $(f^{\\text{SMB}})^{\\top} w = 0$, $(f^{\\text{HML}})^{\\top} w = 0$, $(f^{\\text{ESG}})^{\\top} w = 1$。\n- 测试用例2（自融资，对FF3中性，负单位ESG暴露）：\n  - 约束条件：$\\mathbf{1}^{\\top} w = 0$, $(f^{\\text{MKT}})^{\\top} w = 0$, $(f^{\\text{SMB}})^{\\top} w = 0$, $(f^{\\text{HML}})^{\\top} w = 0$, $(f^{\\text{ESG}})^{\\top} w = -1$。\n- 测试用例3（完全投资，对FF3中性，一半ESG暴露）：\n  - 约束条件：$\\mathbf{1}^{\\top} w = 1$, $(f^{\\text{MKT}})^{\\top} w = 0$, $(f^{\\text{SMB}})^{\\top} w = 0$, $(f^{\\text{HML}})^{\\top} w = 0$, $(f^{\\text{ESG}})^{\\top} w = 0.5$。\n- 测试用例4（自融资，对FF3中性，零ESG暴露；边界情况）：\n  - 约束条件：$\\mathbf{1}^{\\top} w = 0$, $(f^{\\text{MKT}})^{\\top} w = 0$, $(f^{\\text{SMB}})^{\\top} w = 0$, $(f^{\\text{HML}})^{\\top} w = 0$, $(f^{\\text{ESG}})^{\\top} w = 0$。\n\n对于每个测试用例，计算最小方差因子模拟投资组合 $w$ 并将投资组合方差 $v = w^{\\top} \\Sigma w$ 报告为一个实数。收益输入为小数（无单位），报告的 $v$ 也必须是无单位的。\n\n您的程序应生成单行输出，其中包含按测试用例1到4的顺序排列的结果，格式为方括号内以逗号分隔的列表，例如：\"[v1,v2,v3,v4]\"。",
            "solution": "所提出的问题是量化金融中的一个标准练习：在一组线性约束下构建最小方差因子模拟投资组合。这是一个典型的约束二次优化问题。\n\n该问题定义如下：\n$$ \\min_{w \\in \\mathbb{R}^{N}} \\; v = w^{\\top}\\Sigma w $$\n受以下线性等式约束：\n$$ A w = b $$\n其中 $w \\in \\mathbb{R}^{N}$ 是投资组合权重向量，$\\Sigma \\in \\mathbb{R}^{N \\times N}$ 是资产超额收益的协方差矩阵， $A \\in \\mathbb{R}^{K \\times N}$ 是约束系数（因子暴露）矩阵， $b \\in \\mathbb{R}^{K}$ 是目标风险暴露向量。这里，资产数量为 $N=6$，约束数量为 $K=5$。\n\n此问题的解是使用拉格朗日乘数法系统地推导出来的。拉格朗日函数 $\\mathcal{L}$ 的形式为：\n$$ \\mathcal{L}(w, \\lambda) = w^{\\top}\\Sigma w - \\lambda^{\\top}(Aw - b) $$\n其中 $\\lambda \\in \\mathbb{R}^{K}$ 是拉格朗日乘子向量。\n\n最小化的一阶必要条件是通过将拉格朗日函数相对于 $w$ 的梯度设为零来找到的：\n$$ \\frac{\\partial \\mathcal{L}}{\\partial w} = 2\\Sigma w - A^{\\top}\\lambda = \\mathbf{0} $$\n假设协方差矩阵 $\\Sigma$ 是可逆的，我们可以解出 $w$：\n$$ w = \\frac{1}{2} \\Sigma^{-1} A^{\\top} \\lambda $$\n为了求得 $\\lambda$，我们将这个 $w$ 的表达式代入约束方程 $Aw=b$ 中：\n$$ A \\left( \\frac{1}{2} \\Sigma^{-1} A^{\\top} \\lambda \\right) = b $$\n$$ \\left( A \\Sigma^{-1} A^{\\top} \\right) \\lambda = 2b $$\n只要 $\\Sigma$ 是正定的且 $A$ 是行满秩的，矩阵 $A \\Sigma^{-1} A^{\\top}$ 就是可逆的。在这个问题中，这两个条件都满足。因此，我们可以解出 $\\lambda$：\n$$ \\lambda = 2 \\left( A \\Sigma^{-1} A^{\\top} \\right)^{-1} b $$\n将 $\\lambda$ 代回 $w$ 的方程中，得到最优权重向量 $w^{\\star}$：\n$$ w^{\\star} = \\Sigma^{-1} A^{\\top} \\left( A \\Sigma^{-1} A^{\\top} \\right)^{-1} b $$\n最小投资组合方差 $v$ 则由 $v = (w^{\\star})^{\\top}\\Sigma w^{\\star}$ 给出。通过代入 $w^{\\star}$ 的表达式，我们得到了一个更直接的方差计算公式：\n$$ v = \\left( \\Sigma^{-1}A^{\\top}(A\\Sigma^{-1}A^{\\top})^{-1}b \\right)^{\\top} \\Sigma \\left( \\Sigma^{-1}A^{\\top}(A\\Sigma^{-1}A^{\\top})^{-1}b \\right) $$\n$$ v = b^{\\top} \\left( (A\\Sigma^{-1}A^{\\top})^{-1} \\right)^{\\top} (A\\Sigma^{-1})^{\\top} \\Sigma \\Sigma^{-1} A^{\\top} (A\\Sigma^{-1}A^{\\top})^{-1} b $$\n$$ v = b^{\\top} (A\\Sigma^{-1}A^{\\top})^{-1} A \\Sigma^{-1} A^{\\top} (A\\Sigma^{-1}A^{\\top})^{-1} b $$\n$$ v = b^{\\top} (A\\Sigma^{-1}A^{\\top})^{-1} b $$\n这个最终表达式在计算上是高效的，并将用于解决每个测试用例中的方差。\n\n计算过程如下：\n$1$. 资产超额收益协方差矩阵 $\\Sigma \\in \\mathbb{R}^{6 \\times 6}$ 是根据提供的数据矩阵 $R \\in \\mathbb{R}^{10 \\times 6}$ 使用指定的总体协方差公式计算得出的：$\\Sigma = \\frac{1}{T} \\sum_{t=1}^{T} ( r_t - \\bar{r} )( r_t - \\bar{r} )^{\\top}$，其中 $T=10$ 是时间周期数，$r_t$ 是时间 $t$ 的收益向量，$\\bar{r}$ 是每种资产收益的时间序列均值。\n\n$2$. 约束矩阵 $A \\in \\mathbb{R}^{5 \\times 6}$ 是通过将全为1的向量 $\\mathbf{1}$ 和因子暴露向量 $f^{\\text{MKT}}$、 $f^{\\text{SMB}}$、 $f^{\\text{HML}}$ 和 $f^{\\text{ESG}}$ 作为其行堆叠而成的：\n$$ A = \\begin{pmatrix} \\mathbf{1}^{\\top} \\\\ (f^{\\text{MKT}})^{\\top} \\\\ (f^{\\text{SMB}})^{\\top} \\\\ (f^{\\text{HML}})^{\\top} \\\\ (f^{\\text{ESG}})^{\\top} \\end{pmatrix} $$\n\n$3$. 对于四个测试用例中的每一个，定义相应的目标风险暴露向量 $b \\in \\mathbb{R}^{5}$。\n\n$4$. 计算核心矩阵 $M = (A\\Sigma^{-1}A^{\\top})^{-1}$。\n\n$5$. 每个案例的最小方差计算为 $v = b^{\\top}Mb$。\n\n测试用例的评估过程如下：\n- 对于测试用例1, $b_1 = [0, 0, 0, 0, 1]^{\\top}$。方差为 $v_1 = b_1^{\\top}Mb_1$。\n- 对于测试用例2, $b_2 = [0, 0, 0, 0, -1]^{\\top}$。由于 $b_2 = -b_1$，方差为 $v_2 = (-b_1)^{\\top}M(-b_1) = b_1^{\\top}Mb_1 = v_1$。用例1和2的方差必须相同。\n- 对于测试用例3, $b_3 = [1, 0, 0, 0, 0.5]^{\\top}$。方差为 $v_3 = b_3^{\\top}Mb_3$。\n- 对于测试用例4, $b_4 = [0, 0, 0, 0, 0]^{\\top}$。目标向量是零向量。这直接意味着方差为 $v_4 = \\mathbf{0}^{\\top}M\\mathbf{0} = 0$。最优投资组合就是 $w^{\\star} = \\mathbf{0}$，其方差为零，并满足齐次约束 $A w = \\mathbf{0}$。\n\n下面的实现以数值方式执行这些计算。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes minimum-variance factor-mimicking portfolio variances for four test cases.\n    \"\"\"\n    # Number of assets N and time periods T\n    N = 6\n    T = 10\n\n    # Data from the problem statement\n    # Asset excess returns matrix R in decimal form\n    R = np.array([\n        [0.012, 0.008, 0.015, 0.005, 0.010, 0.011],\n        [-0.020, -0.015, -0.018, -0.022, -0.017, -0.019],\n        [0.025, 0.020, 0.028, 0.018, 0.022, 0.024],\n        [0.005, 0.007, 0.004, 0.009, 0.006, 0.005],\n        [0.030, 0.026, 0.033, 0.021, 0.027, 0.029],\n        [-0.010, -0.012, -0.009, -0.013, -0.011, -0.010],\n        [0.018, 0.014, 0.020, 0.012, 0.016, 0.017],\n        [-0.005, -0.006, -0.004, -0.007, -0.005, -0.005],\n        [0.022, 0.019, 0.024, 0.016, 0.020, 0.021],\n        [0.003, 0.004, 0.002, 0.005, 0.003, 0.003]\n    ])\n\n    # Factor exposure vectors\n    f_mkt = np.array([1.10, 0.90, 1.20, 0.80, 1.00, 1.05])\n    f_smb = np.array([-0.30, 0.50, -0.20, 0.70, 0.10, -0.40])\n    f_hml = np.array([0.60, -0.20, 0.40, -0.50, 0.00, 0.30])\n    f_esg = np.array([0.80, 0.20, -0.40, 1.10, -0.60, 0.30])\n\n    # Step 1: Compute the population covariance matrix Sigma.\n    # The problem asks for the population covariance estimator, which corresponds\n    # to using a divisor of T (ddof=0 in numpy.cov).\n    Sigma = np.cov(R, rowvar=False, ddof=0)\n\n    # Step 2: Construct the constraint matrix A.\n    # The rows of A are the constraint vectors.\n    ones_vec = np.ones(N)\n    A = np.vstack([ones_vec, f_mkt, f_smb, f_hml, f_esg])\n\n    # Step 3: Compute the core matrix M = (A * Sigma_inv * A^T)^-1.\n    try:\n        Sigma_inv = np.linalg.inv(Sigma)\n        M = np.linalg.inv(A @ Sigma_inv @ A.T)\n    except np.linalg.LinAlgError as e:\n        # This case should not be reached given the problem data.\n        print(f\"Error during matrix inversion: {e}\")\n        return\n\n    # Step 4: Define the target exposure vectors 'b' for each test case.\n    test_cases = [\n        # Case 1: self-financing, FF3-neutral, unit ESG exposure\n        {\"b\": np.array([0., 0., 0., 0., 1.])},\n        # Case 2: self-financing, FF3-neutral, negative unit ESG exposure\n        {\"b\": np.array([0., 0., 0., 0., -1.])},\n        # Case 3: fully invested, FF3-neutral, half ESG exposure\n        {\"b\": np.array([1., 0., 0., 0., 0.5])},\n        # Case 4: self-financing, FF3-neutral, zero ESG exposure (boundary case)\n        {\"b\": np.array([0., 0., 0., 0., 0.])}\n    ]\n\n    results = []\n    # Step 5: Calculate the minimum variance for each test case.\n    for case in test_cases:\n        b = case[\"b\"]\n        variance = b.T @ M @ b\n        results.append(variance)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "金融市场并非静止不变，其行为模式在不同的经济“状态”（如扩张期和衰退期）之间可能发生巨大变化。这个高级练习将挑战你超越标准的 Fama-French 模型，通过实现一个状态转换框架，使得因子溢价可以根据潜在的经济状态而改变。通过应用汉密尔顿滤波器 (Hamilton filter)，你将学会如何估计此类动态模型并推断当前处于特定经济状态的概率，这是进行复杂金融分析的强大工具 。",
            "id": "2392227",
            "problem": "给定一个用于预期收益的双状态区制转换 Fama-French 三因子模型。对于单个资产，其对市场、小市值减大市值（SMB）和高账面市值比减低账面市值比（HML）因子的因子暴露分别为 $\\beta_{M}$、$\\beta_{S}$ 和 $\\beta_{H}$，其条件预期超额收益被假定依赖于经济的潜在状态 $S_t \\in \\{1,2\\}$，具体表现为 SMB 和 HML 因子的状态依赖因子溢价。具体来说，在每个时间点 $t$，观测到的超额收益 $r_t$ 被建模为\n$$\nr_t \\mid S_t=s \\sim \\mathcal{N}\\left(\\mu_s, \\sigma^2\\right), \\quad s \\in \\{1,2\\},\n$$\n其条件均值为\n$$\n\\mu_s \\;=\\; \\beta_{M}\\,\\lambda_{M} \\;+\\; \\beta_{S}\\,\\lambda_{SMB}^{(s)} \\;+\\; \\beta_{H}\\,\\lambda_{HML}^{(s)},\n$$\n其中 $\\lambda_{M}$ 是市场溢价，而 $\\lambda_{SMB}^{(s)}$ 和 $\\lambda_{HML}^{(s)}$ 是 SMB 和 HML 因子的状态依赖因子溢价。潜在状态 $\\{S_t\\}$ 服从一个时间同质的一阶马尔可夫链，其转移矩阵为\n$$\nP \\;=\\; \n\\begin{bmatrix}\np_{11}  p_{12} \\\\\np_{21}  p_{22}\n\\end{bmatrix},\n\\quad \\text{其中 } p_{ij} = \\mathbb{P}(S_t=j \\mid S_{t-1}=i), \\; p_{12}=1-p_{11}, \\; p_{21}=1-p_{22}.\n$$\n设初始状态分布为 $\\pi_0 = \\big(\\mathbb{P}(S_0=1), \\mathbb{P}(S_0=2)\\big)$。\n\n您的任务是为每个给定的测试用例计算：\n- 在指定模型下，观测序列 $\\{r_t\\}_{t=1}^{T}$ 的总对数似然，以及\n- 滤波概率 $\\mathbb{P}(S_T=1 \\mid r_1,\\dots,r_T)$。\n\n所有收益均为以十进制形式表示的超额收益。高斯似然必须使用指定的方差 $\\sigma^2$ 通过精确的概率密度函数计算。结果必须报告为四舍五入到六位小数的实数。\n\n测试套件：\n- 测试用例 A：\n  - 参数：\n    - $\\beta_{M} = 1.1$, $\\beta_{S} = 0.4$, $\\beta_{H} = -0.2$.\n    - $\\lambda_{M} = 0.006$.\n    - $\\lambda_{SMB}^{(1)} = 0.004$, $\\lambda_{HML}^{(1)} = 0.002$; $\\lambda_{SMB}^{(2)} = -0.001$, $\\lambda_{HML}^{(2)} = 0.005$.\n    - $\\sigma = 0.01$.\n    - $P = \\begin{bmatrix} 0.9  0.1 \\\\ 0.2  0.8 \\end{bmatrix}$.\n    - $\\pi_0 = \\big(2/3,\\, 1/3\\big)$.\n  - 观测值（十进制）： $[\\,0.006,\\,0.009,\\,0.004,\\,0.007,\\,0.005,\\,0.008\\,]$.\n- 测试用例 B：\n  - 参数：\n    - $\\beta_{M} = 0.9$, $\\beta_{S} = 0.7$, $\\beta_{H} = 0.3$.\n    - $\\lambda_{M} = 0.005$.\n    - $\\lambda_{SMB}^{(1)} = 0.003$, $\\lambda_{HML}^{(1)} = 0.001$; $\\lambda_{SMB}^{(2)} = -0.002$, $\\lambda_{HML}^{(2)} = -0.001$.\n    - $\\sigma = 0.008$.\n    - $P = \\begin{bmatrix} 0.99  0.01 \\\\ 0.02  0.98 \\end{bmatrix}$.\n    - $\\pi_0 = \\big(2/3,\\,1/3\\big)$.\n  - 观测值（十进制）： $[\\,0.0065,\\,0.0072,\\,0.0023,\\,0.0030,\\,0.0068\\,]$.\n- 测试用例 C（状态均值相等的边界情况）：\n  - 参数：\n    - $\\beta_{M} = 1.0$, $\\beta_{S} = 0.5$, $\\beta_{H} = 0.5$.\n    - $\\lambda_{M} = 0.004$.\n    - $\\lambda_{SMB}^{(1)} = 0.002$, $\\lambda_{HML}^{(1)} = 0.001$; $\\lambda_{SMB}^{(2)} = 0.002$, $\\lambda_{HML}^{(2)} = 0.001$.\n    - $\\sigma = 0.012$.\n    - $P = \\begin{bmatrix} 0.6  0.4 \\\\ 0.3  0.7 \\end{bmatrix}$.\n    - $\\pi_0 = \\big(3/7,\\,4/7\\big)$.\n  - 观测值（十进制）： $[\\,0.0040,\\,0.0060,\\,0.0050,\\,0.0070\\,]$.\n\n要求的最终输出格式：\n- 您的程序必须生成单行输出，其中包含一个列表，每个测试用例对应一个条目。\n- 每个条目必须是一个包含两个元素的列表，其中包括：\n  - 总对数似然（四舍五入到六位小数），以及\n  - 滤波概率 $\\mathbb{P}(S_T=1 \\mid r_1,\\dots,r_T)$（四舍五入到六位小数）。\n- 确切的字符串格式必须是：\n  - `[\\,[\\ell_A, p_A],\\,[\\ell_B, p_B],\\,[\\ell_C, p_C]\\,]`，其中 $\\ell_\\cdot$ 和 $p_\\cdot$ 分别是测试用例 A、B 和 C 的相应四舍五入值。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，例如，`[[\\ell_A,p_A],[\\ell_B,p_B],[\\ell_C,p_C]]`。",
            "solution": "该问题要求计算由双状态区制转换 Fama-French 模型生成的资产收益序列的总对数似然和最终的滤波状态概率。这是一个隐马尔可夫模型（HMM）的经典应用，其标准解决方法是前向-后向算法中的前向传递，通常称为 Hamilton 滤波器。\n\n模型规定如下：\n在时间 $t$ 观测到的超额收益，记为 $r_t$，是从一个高斯分布中抽取的，该分布的参数取决于一个潜在状态 $S_t \\in \\{1, 2\\}$。\n$$\nr_t \\mid S_t=s \\sim \\mathcal{N}(\\mu_s, \\sigma^2)\n$$\n状态依赖均值 $\\mu_s$ 是三个因子的线性函数，其中 SMB 和 HML 因子具有状态依赖的溢价：\n$$\n\\mu_s = \\beta_{M}\\lambda_{M} + \\beta_{S}\\lambda_{SMB}^{(s)} + \\beta_{H}\\lambda_{HML}^{(s)}\n$$\n潜在状态序列 $\\{S_t\\}$ 是一个一阶马尔可夫链，具有给定的转移矩阵 $P$ 和状态 $S_0$ 的初始状态分布 $\\pi_0$。观测数据从 $t=1$ 到 $t=T$。\n\n目标是计算总对数似然 $\\mathcal{L} = \\log \\mathbb{P}(r_1, \\dots, r_T)$ 和滤波概率 $\\mathbb{P}(S_T=1 \\mid r_1, \\dots, r_T)$。这通过递归计算滤波概率 $\\pi_{t|t} = (\\mathbb{P}(S_t=1 \\mid \\mathcal{F}_t), \\mathbb{P}(S_t=2 \\mid \\mathcal{F}_t))$ 来完成，其中 $\\mathcal{F}_t = \\{r_1, \\dots, r_t\\}$ 是时间 $t$ 的信息集。\n\nHamilton 滤波器算法对 $t = 1, \\dots, T$ 进行迭代：\n\n1.  **初始化**：过程从 $t=1$ 开始。在观测到 $r_1$ 之前，我们需要状态 $S_1$ 的概率分布。这是在 $t=1$ 时的预测概率，以 $t=0$ 时的信息为条件（从观测角度看，此时没有信息）。问题指定了 $S_0$ 的分布为 $\\pi_0$。因此，$S_1$ 的预测概率向量为 $\\pi_{1|0} = \\pi_0 P$，其中 $P$ 是转移矩阵。对于递归的第一步，我们使用 $\\pi_{0|0} = \\pi_0$。\n\n2.  **递归步骤 ($t=1, \\dots, T$)**：给定上一步的滤波概率 $\\pi_{t-1|t-1} = (\\mathbb{P}(S_{t-1}=1 \\mid \\mathcal{F}_{t-1}), \\mathbb{P}(S_{t-1}=2 \\mid \\mathcal{F}_{t-1}))$，我们执行两个操作：预测和更新。\n\n    a.  **预测步骤**：我们使用马尔可夫性质预测时间 $t$ 的状态概率：\n        $$\n        \\pi_{t|t-1} = \\pi_{t-1|t-1} P\n        $$\n        其中 $\\pi_{t|t-1}(j) = \\mathbb{P}(S_t=j \\mid \\mathcal{F}_{t-1})$。\n\n    b.  **更新步骤**：观测到 $r_t$ 后，我们使用贝叶斯定理更新对状态 $S_t$ 的信念。\n        首先，我们为每个状态 $s \\in \\{1, 2\\}$ 计算观测值 $r_t$ 的条件概率密度，我们将其记为 $\\eta_s(r_t)$：\n        $$\n        \\eta_s(r_t) = f(r_t \\mid S_t=s) = \\frac{1}{\\sqrt{2\\pi}\\sigma} \\exp\\left(-\\frac{(r_t - \\mu_s)^2}{2\\sigma^2}\\right)\n        $$\n        给定过去的观测值 $\\mathcal{F}_{t-1}$，观测到 $r_t$ 的边际似然是这些密度的加权平均，权重由预测概率给出：\n        $$\n        f(r_t \\mid \\mathcal{F}_{t-1}) = \\sum_{s=1}^{2} f(r_t \\mid S_t=s) \\mathbb{P}(S_t=s \\mid \\mathcal{F}_{t-1}) = \\sum_{s=1}^{2} \\eta_s(r_t) \\pi_{t|t-1}(s)\n        $$\n        整个序列的对数似然是每个时间步的这些边际似然的对数之和：\n        $$\n        \\mathcal{L} = \\sum_{t=1}^{T} \\log f(r_t \\mid \\mathcal{F}_{t-1})\n        $$\n        最后，通过使用来自 $r_t$ 的信息更新预测概率来计算滤波概率向量 $\\pi_{t|t}$：\n        $$\n        \\pi_{t|t}(s) = \\mathbb{P}(S_t=s \\mid \\mathcal{F}_t) = \\frac{f(r_t \\mid S_t=s) \\mathbb{P}(S_t=s \\mid \\mathcal{F}_{t-1})}{f(r_t \\mid \\mathcal{F}_{t-1})} = \\frac{\\eta_s(r_t) \\pi_{t|t-1}(s)}{\\sum_{k=1}^{2} \\eta_k(r_t) \\pi_{t|t-1}(k)}\n        $$\n\n此递归过程应用于 $t=1, \\dots, T$。在最后一步 $t=T$ 之后，累加和即为总对数似然 $\\mathcal{L}$，最终的滤波概率向量为 $\\pi_{T|T}$。问题要求此向量的第一个分量，即 $\\mathbb{P}(S_T=1 \\mid \\mathcal{F}_T)$。\n\n对于测试用例 C，我们注意到状态依赖的均值是相同的，即 $\\mu_1 = \\mu_2$。这意味着对于任何 $r_t$，条件密度也是相同的，即 $\\eta_1(r_t) = \\eta_2(r_t)$。因此，观测值 $r_t$ 无法提供任何信息来区分状态。更新步骤简化为 $\\pi_{t|t}(s) = \\pi_{t|t-1}(s)$。因此，滤波概率完全根据马尔可夫链的动态演化：$\\pi_{t|t} = \\pi_{t-1|t-1} P$。由于给定的初始分布 $\\pi_0 = (3/7, 4/7)$ 是给定转移矩阵 $P$ 的平稳分布，因此对于所有 $t$ 都有 $\\pi_{t|t} = \\pi_0$。所以，最终的滤波概率 $\\mathbb{P}(S_T=1 \\mid \\mathcal{F}_T)$ 必须是 $3/7$。对数似然则是在单一均值 $\\mu = \\mu_1 = \\mu_2$ 处求值的对数密度之和。\n\n实现将针对每个测试用例遵循此逻辑，首先计算状态依赖的均值，然后遍历观测值以执行滤波器递归。",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Solves the regime-switching Fama-French model problem for all test cases.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"betas\": (1.1, 0.4, -0.2), # (beta_M, beta_S, beta_H)\n            \"lambda_M\": 0.006,\n            \"lambda_s1\": (0.004, 0.002), # (lambda_SMB_1, lambda_HML_1)\n            \"lambda_s2\": (-0.001, 0.005), # (lambda_SMB_2, lambda_HML_2)\n            \"sigma\": 0.01,\n            \"P\": np.array([[0.9, 0.1], [0.2, 0.8]]),\n            \"pi0\": np.array([2/3, 1/3]),\n            \"observations\": [0.006, 0.009, 0.004, 0.007, 0.005, 0.008]\n        },\n        {\n            \"betas\": (0.9, 0.7, 0.3),\n            \"lambda_M\": 0.005,\n            \"lambda_s1\": (0.003, 0.001),\n            \"lambda_s2\": (-0.002, -0.001),\n            \"sigma\": 0.008,\n            \"P\": np.array([[0.99, 0.01], [0.02, 0.98]]),\n            \"pi0\": np.array([2/3, 1/3]),\n            \"observations\": [0.0065, 0.0072, 0.0023, 0.0030, 0.0068]\n        },\n        {\n            \"betas\": (1.0, 0.5, 0.5),\n            \"lambda_M\": 0.004,\n            \"lambda_s1\": (0.002, 0.001),\n            \"lambda_s2\": (0.002, 0.001),\n            \"sigma\": 0.012,\n            \"P\": np.array([[0.6, 0.4], [0.3, 0.7]]),\n            \"pi0\": np.array([3/7, 4/7]),\n            \"observations\": [0.0040, 0.0060, 0.0050, 0.0070]\n        }\n    ]\n\n    def run_filter(case):\n        \"\"\"\n        Implements the Hamilton filter for a single test case.\n        \"\"\"\n        beta_m, beta_s, beta_h = case[\"betas\"]\n        lambda_m = case[\"lambda_M\"]\n        lambda_smb1, lambda_hml1 = case[\"lambda_s1\"]\n        lambda_smb2, lambda_hml2 = case[\"lambda_s2\"]\n        sigma = case[\"sigma\"]\n        P = case[\"P\"]\n        pi0 = case[\"pi0\"]\n        observations = case[\"observations\"]\n\n        # Calculate state-dependent means\n        mu1 = beta_m * lambda_m + beta_s * lambda_smb1 + beta_h * lambda_hml1\n        mu2 = beta_m * lambda_m + beta_s * lambda_smb2 + beta_h * lambda_hml2\n        \n        mus = np.array([mu1, mu2])\n\n        total_log_likelihood = 0.0\n        # Initialize filtered probability with pi0 (for state S_0)\n        filtered_prob = pi0\n\n        for r_t in observations:\n            # Prediction step: P(S_t | F_{t-1}) = P(S_{t-1} | F_{t-1}) * P\n            predicted_prob = filtered_prob @ P\n            \n            # Likelihood of observation r_t in each state\n            # eta_s = P(r_t | S_t=s)\n            emission_likelihoods = norm.pdf(r_t, loc=mus, scale=sigma)\n            \n            # Marginal likelihood of observation r_t\n            # f(r_t | F_{t-1})\n            marginal_likelihood = np.dot(predicted_prob, emission_likelihoods)\n            \n            # Update total log-likelihood\n            total_log_likelihood += np.log(marginal_likelihood)\n            \n            # Update step: P(S_t | F_t)\n            # using Bayes' rule: P(S_t | r_t, F_{t-1}) approx P(S_t | F_t)\n            numerator = predicted_prob * emission_likelihoods\n            filtered_prob = numerator / marginal_likelihood\n        \n        final_filtered_prob_s1 = filtered_prob[0]\n        \n        return [round(total_log_likelihood, 6), round(final_filtered_prob_s1, 6)]\n\n    results = []\n    for case in test_cases:\n        results.append(run_filter(case))\n\n    # Format the output string to match the required format exactly.\n    # The format [l,p] should not have spaces after the comma.\n    formatted_results = [f\"[{res[0]},{res[1]}]\" for res in results]\n    final_output_str = f\"[{','.join(formatted_results)}]\"\n    \n    print(final_output_str)\n\nsolve()\n```"
        }
    ]
}