{
    "hands_on_practices": [
        {
            "introduction": "标准的竞争性分析假设存在一个强大且全知的对手。本练习  通过引入一个预见能力有限的“懒惰对手”来挑战这一假设。这有助于理解对手的能力如何直接影响最优策略及其性能保证，对于领会最坏情况分析的精妙之处，这是一个至关重要的思想实验。",
            "id": "3272187",
            "problem": "一个在线滑雪者每天早上决定是租用滑雪板还是购买滑雪板。租用每天花费 $1$，而购买则需要一次性支付费用 $b$，其中 $b \\in \\mathbb{Z}_{\\ge 1}$。总滑雪天数 $n \\in \\mathbb{Z}_{\\ge 1}$ 事先对滑雪者是未知的，由一个对手（adversary）来选择。考虑以下由整数 $T \\in \\mathbb{Z}_{\\ge 0}$ 参数化的确定性阈值算法族：在前 $T$ 天租用滑雪板；如果雪季持续到第 $T+1$ 天，则在第 $T+1$ 天开始时购买，之后不再产生每日费用。\n\n我们研究一种受约束的自适应输入生成器，称为“懒惰对手”（lazy adversary），它只能预见未来 $L$ 天，其中 $L \\in \\mathbb{Z}_{\\ge 0}$ 是已知的。为了以科学上有意义且可操作的方式对此限制进行建模，我们对对手施加以下约束：一旦算法购买了滑雪板（在第 $T+1$ 天开始时），对手不能在第 $T+L$ 天之前结束雪季；也就是说，如果算法购买，总雪季长度 $n$ 必须满足 $n \\ge T+L$。如果算法从未购买，对手可以在任何一天结束雪季。\n\n仅使用在线算法和竞争性分析的核心定义，以及在给定 $n$ 的情况下最小化总成本的明显离线最优行为，推导出在 $b$ 和 $L$ 方面可能的最小最坏情况竞争比的闭式表达式（即，在与懒惰对手约束一致的所有 $n$ 上，算法成本与离线最优成本之比的上确界，关于 $T$ 的选择的下确界）。将你的最终答案表示为关于 $b$ 和 $L$ 的单个解析表达式。不需要数值近似或四舍五入。",
            "solution": "为了找到最优的最坏情况竞争比，我们首先形式化在线算法的成本、离线最优成本，然后分析在懒惰对手的约束下，竞争比如何随阈值 $T$ 变化，最后找到最小化这个最坏情况比率的最优 $T$。\n\n**1. 成本函数定义**\n- **离线最优成本** $\\operatorname{OPT}(n)$: 如果知道总天数 $n$，最优策略是在租用总成本 $n \\cdot 1$ 和购买成本 $b$ 之间选择较小者。\n  $$ \\operatorname{OPT}(n) = \\min\\{n, b\\} $$\n- **在线算法成本** $\\operatorname{ALG}_T(n)$: 算法在前 $T$ 天租用，并在第 $T+1$ 天（如果雪季持续）购买。\n  $$ \\operatorname{ALG}_T(n) = \\begin{cases} n,  \\text{if } n \\le T \\\\ T+b,  \\text{if } n > T \\end{cases} $$\n\n**2. 对手约束**\n懒惰对手选择 $n$。如果算法只租用（即 $n \\le T$），对手可以选择任何 $n \\in \\{1, \\dots, T\\}$。如果算法购买（即 $n > T$），对手必须选择 $n \\ge T+L$。因此，对于给定的 $T$，允许的 $n$ 集合为 $\\{1, \\dots, T\\} \\cup \\{T+L, T+L+1, \\dots\\}$。\n\n**3. 最坏情况竞争比 $R(T)$**\n对于固定的 $T$，最坏情况竞争比是在所有允许的 $n$ 上的比率上确界：\n$$ R(T) = \\sup_{n \\text{ admissible}} \\frac{\\operatorname{ALG}_T(n)}{\\operatorname{OPT}(n)} = \\max\\left( \\sup_{1 \\le n \\le T} \\frac{n}{\\min\\{n, b\\}}, \\sup_{n \\ge T+L} \\frac{T+b}{\\min\\{n, b\\}} \\right) $$\n\n- **分析第一部分 (租太久):** $\\sup_{1 \\le n \\le T} \\frac{n}{\\min\\{n, b\\}}$\n  - 如果 $T  b$，对于所有 $n \\le T$，我们有 $n  b$，所以 $\\min\\{n, b\\} = n$。比率为 $n/n = 1$。\n  - 如果 $T \\ge b$，对于 $n \\in [b, T]$，比率为 $n/b$。这个比率在 $n=T$ 时达到最大值 $T/b$。\n  - 因此，第一部分是 $\\max\\{1, T/b\\}$。\n\n- **分析第二部分 (买太早):** $\\sup_{n \\ge T+L} \\frac{T+b}{\\min\\{n, b\\}}$\n  - 为了最大化这个比率，我们需要最小化分母 $\\min\\{n, b\\}$，受限于 $n \\ge T+L$。\n  - 最小化发生在 $n$ 的下界，即 $n=T+L$。因此，分母的最小值为 $\\min\\{T+L, b\\}$。\n  - 比率的最大值为 $\\frac{T+b}{\\min\\{T+L, b\\}}$。\n\n**4. 寻找最优竞争比**\n我们的目标是找到 $\\min_T R(T)$。\n$$ R(T) = \\max\\left( \\max\\{1, T/b\\}, \\frac{T+b}{\\min\\{T+L, b\\}} \\right) $$\n\n我们需要考虑两种情况：\n- **情况 1: $L \\ge b$**\n  在这种情况下，对手的预见能力足够强，以至于如果算法购买，雪季的持续时间至少为 $b$。\n  让我们选择阈值 $T=0$。这意味着算法在第一天就购买。\n  - $\\operatorname{ALG}_0(n) = b$ 对于所有 $n \\ge 1$。\n  - 对手约束：由于购买发生在第 1 天（$T=0$），对手必须选择 $n \\ge 0+L = L \\ge b$。\n  - 对于所有允许的 $n \\ge L$，$\\operatorname{OPT}(n) = \\min\\{n, b\\} = b$。\n  - 因此，竞争比为 $\\frac{\\operatorname{ALG}_0(n)}{\\operatorname{OPT}(n)} = \\frac{b}{b} = 1$。\n  由于竞争比不能小于1，这是最优的。所以当 $L \\ge b$ 时，最小竞争比为 $1$。\n\n- **情况 2: $L  b$**\n  为了最小化 $\\max(A, B)$ 形式的函数，我们通常尝试选择参数使得 $A \\approx B$。\n  让我们尝试平衡“租太久”和“买太早”这两种风险。最优的 $T$ 应该在 $b$ 附近。\n  考虑选择 $T$ 使得 $T+L=b$，即 $T = b-L$。由于 $L  b$，我们有 $T > 0$。\n  - 因为 $T = b-L  b$，所以 $\\max\\{1, T/b\\} = 1$。\n  - “买太早”的比率变为 $\\frac{T+b}{\\min\\{T+L, b\\}} = \\frac{(b-L)+b}{\\min\\{b, b\\}} = \\frac{2b-L}{b} = 2 - \\frac{L}{b}$。\n  - 那么，对于 $T=b-L$，$R(b-L) = \\max\\left(1, 2 - \\frac{L}{b}\\right)$。\n  - 因为 $L  b$，我们有 $L/b  1$，所以 $2 - L/b > 1$。因此 $R(b-L) = 2 - \\frac{L}{b}$。\n  可以证明这是最优选择。如果 $T$ 增加（$T > b-L$），$\\frac{T+b}{b}$ 项会增加。如果 $T$ 减小（$T  b-L$），$\\frac{T+b}{T+L}$ 项会增加。因此，$T=b-L$ 是平衡点。\n\n**5. 最终结果**\n结合两种情况：\n- 如果 $L \\ge b$，最优竞争比是 $1$。\n- 如果 $L  b$，最优竞争比是 $2 - L/b$。\n\n这两种情况可以统一表示为单个表达式：$\\max\\{1, 2 - L/b\\}$。因为当 $L \\ge b$ 时，$2 - L/b \\le 1$，所以 $\\max\\{1, 2 - L/b\\} = 1$。当 $L  b$ 时，$2 - L/b > 1$，所以 $\\max\\{1, 2 - L/b\\} = 2 - L/b$。\n\n因此，最小最坏情况竞争比是 $\\max\\{1, 2 - L/b\\}$。",
            "answer": "$$\\boxed{\\max\\left\\{1,\\ 2 - \\frac{L}{b}\\right\\}}$$"
        },
        {
            "introduction": "现在让我们从对抗模型转向随机模型。在许多现实场景中，我们面对的并非最坏情况的对手，而是对未来拥有一定的概率性信息。本练习  将指导你使用动态规划，在已知滑雪季节长度的概率分布下，寻找最小化*期望*成本的策略。这引入了一种在不确定性下进行决策的强大技术。",
            "id": "3272330",
            "problem": "一个滑雪者面临经典的雪具租赁决策：在每一天，她既可以租用雪具，也可以直接购买。设 $r > 0$ 为每日的租赁成本，设 $b > 0$ 为一次性购买成本，该成本涵盖所有剩余天数，无需再支付租赁费用。本滑雪季的总滑雪天数（用随机变量 $K$ 表示）的支撑集为 $\\{1, 2, \\dots, N\\}$，其概率质量函数 $P(k)$ 已知，且满足 $\\sum_{k=1}^{N} P(k) = 1$。决策在每天 $t \\in \\{1, 2, \\dots, N\\}$ 的开始时做出，条件是滑雪季尚未结束（即，条件为 $K \\ge t$）。目标是最小化预期总成本。\n\n仅使用期望值的基本定义、动态规划（DP）的最优性原理以及关于离散分布条件概率的标准事实，将决策过程表述为一个有限期界动态规划。推导出在第 $t$ 天开始时的最小预期剩余成本 $V(t)$ 的递归式，并附上适当的边界条件，然后推断出最优策略的结构。然后，用 $P(k)$、$r$、$b$ 和 $N$ 将从滑雪季开始的最小预期总成本表示为单个闭式解析表达式。\n\n你的最终答案必须是这个单一表达式。不需要数值近似。",
            "solution": "该问题要求使用动态规划来表述和解决随机雪具租赁问题，以找到最小预期总成本。\n\n这个问题是有效的，因为它是一个在优化和概率论中定义明确、自成体系的问题，是在线算法和随机算法领域的经典问题。所有参数和目标都已明确说明。\n\n设 $t \\in \\{1, 2, \\dots, N\\}$ 是滑雪季的当前天数。我们已知滑雪季尚未结束，即总滑雪天数 $K$ 至少为 $t$（$K \\ge t$）。我们必须决定是为当天花费 $r$ 租用雪具，还是一次性花费 $b$ 购买雪具。我们假设尚未购买雪具。\n\n设 $V(t)$ 为在第 $t$ 天开始且尚未购买雪具的情况下的最小预期未来成本。这是我们动态规划表述的值函数。状态由天数 $t$ 定义。期界是有限的，在 $N$ 结束。我们使用后向归纳法，从第 $N$ 天到第 $1$ 天来解决这个问题。\n\n在第 $t$ 天开始时，我们有两个行动：\n1.  **购买**：成本为 $b$。该成本立即产生，并且在本季余下的时间里，无论持续多少天，都不会再有其他成本。总未来成本为 $b$。\n2.  **租赁**：今天的成本是 $r$。本季可能在今天结束，也可能持续到第 $t+1$ 天。我们需要考虑未来决策的预期成本。如果我们今天租赁，总的预期未来成本是今天的租赁成本 $r$ 与从第 $t+1$ 天开始的预期成本之和，条件是本季会继续。\n\n设 $S(t) = P(K \\ge t) = \\sum_{k=t}^{N} P(k)$ 为生存函数，即滑雪季持续至少 $t$ 天的概率。注意 $S(1) = \\sum_{k=1}^{N} P(k) = 1$。\n第 $t$ 天的决策以 $K \\ge t$ 为条件。在滑雪季已持续到第 $t$ 天的情况下，它继续到第 $t+1$ 天的概率是：\n$$ P(K \\ge t+1 | K \\ge t) = \\frac{P(K \\ge t+1 \\text{ and } K \\ge t)}{P(K \\ge t)} = \\frac{P(K \\ge t+1)}{P(K \\ge t)} = \\frac{S(t+1)}{S(t)} $$\n如果滑雪季持续到第 $t+1$ 天，我们将再次面临同样的问题，根据最优性原理，我们将以最优方式进行，产生一个最小预期未来成本 $V(t+1)$。\n\n因此，在第 $t$ 天租赁的预期成本是 $r + V(t+1) \\cdot P(K \\ge t+1 | K \\ge t) = r + V(t+1) \\frac{S(t+1)}{S(t)}$。\n值函数 $V(t)$ 是这两个行动成本的最小值：\n$$ V(t) = \\min \\left( b, r + \\frac{S(t+1)}{S(t)} V(t+1) \\right) $$\n这个递归关系对 $t=1, 2, \\dots, N$ 成立。我们需要一个边界条件。我们定义 $V(N+1)=0$，因为没有更多可能的滑雪天，因此未来成本为零。\n对于 $t=N$，给定 $K \\ge N$，我们必有 $K=N$。所以滑雪季恰好还会持续一天。继续到第 $N+1$ 天的概率是 $P(K \\ge N+1 | K \\ge N) = S(N+1)/S(N) = 0$。\n在 $t=N$ 时的递归式变为：\n$$ V(N) = \\min \\left( b, r + \\frac{S(N+1)}{S(N)} V(N+1) \\right) = \\min(b, r + 0) = \\min(b, r) $$\n这是合乎逻辑的：在最后一个可能的日子里，人们应该简单地比较单日租赁成本和购买价格。\n\n最优策略的结构可以从这个递归中推断出来。最优策略是一个停止规则，它指定何时停止租赁并购买雪具。一旦购买了雪具，过程就终止了。我们假设最优策略具有阈值结构：在第 $t=1, \\dots, \\tau-1$ 天租赁，如果滑雪季在第 $\\tau$ 天仍在继续，则购买雪具。这里 $\\tau \\in \\{1, 2, \\dots, N+1\\}$ 是购买的阈值日。$\\tau=1$ 意味着在第 1 天购买。$\\tau=N+1$ 意味着永不购买（总是租赁）。\n\n让我们验证这个结构与动态规划递归的一致性。如果策略是在第 $\\tau$ 天购买，那么对于任何 $t \\ge \\tau$，如果我们到达第 $t$ 天，我们就会购买。这意味着对于所有 $t \\ge \\tau$，$V(t) = b$。\n对于 $t  \\tau$，策略是租赁。所以 $V(t) = r + \\frac{S(t+1)}{S(t)}V(t+1)$。\n在第 $\\tau$ 天，决策必须是购买。这意味着：\n$$ b \\le r + \\frac{S(\\tau+1)}{S(\\tau)} V(\\tau+1) $$\n由于 $\\tau+1$ 也处于“购买”区域，所以 $V(\\tau+1) = b$。条件变为：\n$$ b \\le r + \\frac{S(\\tau+1)}{S(\\tau)} b \\implies b \\left(1 - \\frac{S(\\tau+1)}{S(\\tau)}\\right) \\le r \\implies b \\frac{S(\\tau)-S(\\tau+1)}{S(\\tau)} \\le r $$\n由于 $S(\\tau) - S(\\tau+1) = \\sum_{k=\\tau}^N P(k) - \\sum_{k=\\tau+1}^N P(k) = P(\\tau)$，这可以简化为：\n$$ b \\frac{P(\\tau)}{S(\\tau)} \\le r \\quad \\text{或} \\quad b P(\\tau) \\le r S(\\tau) $$\n在第 $\\tau-1$ 天，决策必须是租赁。这意味着：\n$$ b > r + \\frac{S(\\tau)}{S(\\tau-1)} V(\\tau) $$\n由于第 $\\tau$ 天是“购买”日，所以 $V(\\tau) = b$。条件变为：\n$$ b > r + \\frac{S(\\tau)}{S(\\tau-1)} b \\implies b \\left(1 - \\frac{S(\\tau)}{S(\\tau-1)}\\right) > r \\implies b \\frac{S(\\tau-1)-S(\\tau)}{S(\\tau-1)} > r $$\n这可以简化为：\n$$ b \\frac{P(\\tau-1)}{S(\\tau-1)} > r \\quad \\text{或} \\quad b P(\\tau-1) > r S(\\tau-1) $$\n结合这些结果，最优阈值 $\\tau_{opt}$ 是满足“购买”条件 $b P(t) \\le r S(t)$ 的第一天 $t$。如果对于 $t \\in \\{1, \\dots, N\\}$ 这个条件从未被满足，那么我们总是租赁，这对应于 $\\tau_{opt} = N+1$。\n因此，最优购买日是 $\\tau_{opt} = \\min(\\{t \\in \\{1, \\dots, N\\} \\mid b P(t) \\le r S(t)\\} \\cup \\{N+1\\})$。最优策略的结构确实是一个简单的阈值策略。\n\n现在我们可以推导最小预期总成本的闭式表达式，即 $V(1)$。\n在具有阈值 $\\tau_{opt}$ 的最优策略下，成本由实际的滑雪天数 $k$ 决定。\n- 如果 $K=k  \\tau_{opt}$：我们租赁 $k$ 天。成本为 $k \\cdot r$。\n- 如果 $K=k \\ge \\tau_{opt}$：我们租赁 $\\tau_{opt}-1$ 天，然后在第 $\\tau_{opt}$ 天购买。成本为 $(\\tau_{opt}-1)r + b$。\n\n预期总成本是这些成本乘以概率 $P(k)$ 的加权和：\n$$ V(1) = \\sum_{k=1}^{\\tau_{opt}-1} (k \\cdot r) P(k) + \\sum_{k=\\tau_{opt}}^{N} ((\\tau_{opt}-1)r + b) P(k) $$\n$$ V(1) = r \\sum_{k=1}^{\\tau_{opt}-1} k P(k) + ((\\tau_{opt}-1)r + b) \\sum_{k=\\tau_{opt}}^{N} P(k) $$\n$$ V(1) = r \\sum_{k=1}^{\\tau_{opt}-1} k P(k) + ((\\tau_{opt}-1)r + b) S(\\tau_{opt}) $$\n这个表达式可以被简化。让我们使用我们为阈值策略的总成本找到的递归关系。对于 $t  \\tau_{opt}$，我们有 $V(t) = r + \\frac{S(t+1)}{S(t)}V(t+1)$。这可以重写为 $S(t)V(t) = rS(t) + S(t+1)V(t+1)$。\n这给出了一个类似伸缩级数的关系。对于 $t = \\tau_{opt}-1$：\n$S(\\tau_{opt}-1)V(\\tau_{opt}-1) = rS(\\tau_{opt}-1) + S(\\tau_{opt})V(\\tau_{opt}) = rS(\\tau_{opt}-1) + b S(\\tau_{opt})$ 因为 $V(\\tau_{opt})=b$。\n对于 $t = \\tau_{opt}-2$：\n$S(\\tau_{opt}-2)V(\\tau_{opt}-2) = rS(\\tau_{opt}-2) + S(\\tau_{opt}-1)V(\\tau_{opt}-1) = rS(\\tau_{opt}-2) + rS(\\tau_{opt}-1) + bS(\\tau_{opt})$。\n通过归纳，对于任何 $t  \\tau_{opt}$：\n$$ S(t)V(t) = r \\sum_{j=t}^{\\tau_{opt}-1} S(j) + b S(\\tau_{opt}) $$\n从滑雪季开始的最小总成本是 $V(1)$。由于 $S(1)=1$：\n$$ V(1) = r \\sum_{j=1}^{\\tau_{opt}-1} S(j) + b S(\\tau_{opt}) $$\n虽然这个表达式依赖于 $\\tau_{opt}$，而 $\\tau_{opt}$ 本身必须被计算，但表达最小成本的另一种方法是将其表述为所有可能阈值策略下的最小值。设 $\\tau$ 是一个潜在的购买日。预期成本 $C(\\tau)$ 是：\n$$ C(\\tau) = r \\sum_{t=1}^{\\tau-1} S(t) + b S(\\tau) $$\n最小预期成本是这些值在所有可能阈值 $\\tau \\in \\{1, 2, \\dots, N+1\\}$ 上的最小值。\n如果 $\\tau=1$，$\\sum_{t=1}^{\\tau-1}$ 定义为 $0$。如果 $\\tau=N+1$，$S(\\tau)$ 定义为 $0$。\n代入 $S(t)$ 的定义即可得到最终表达式。\n\n最小预期成本 $= \\min_{\\tau \\in \\{1, 2, \\dots, N+1\\}} C(\\tau) $，其中 $C(\\tau)$ 是在第 $\\tau$ 天购买的预期成本。\n$$ C(\\tau) = r \\sum_{t=1}^{\\tau-1} \\left( \\sum_{k=t}^{N} P(k) \\right) + b \\sum_{k=\\tau}^{N} P(k) $$\n这是关于给定参数的最小预期总成本的单个闭式表达式。\n对于 $\\tau=1$，第一项为 $0$，成本为 $b \\sum_{k=1}^N P(k) = b$。\n对于 $\\tau=N+1$，第二项为 $0$（对空集求和），成本为 $r \\sum_{t=1}^{N} S(t) = r \\sum_{t=1}^N \\sum_{k=t}^N P(k) = r \\sum_{k=1}^N k P(k) = r E[K]$。\n该表达式正确地表示了在第 1 天购买与始终租赁的对比。最优策略的成本是所有可能购买天数中成本的最小值。",
            "answer": "$$ \\boxed{\\min_{\\tau \\in \\{1, 2, \\dots, N+1\\}} \\left( r \\sum_{t=1}^{\\tau-1} \\sum_{k=t}^{N} P(k) + b \\sum_{k=\\tau}^{N} P(k) \\right)} $$"
        },
        {
            "introduction": "本节旨在弥合抽象算法与实际应用之间的鸿沟。最后一个练习  将解决在具有固定大小整数运算能力的系统上实现滑雪租赁策略的挑战，这是现实世界硬件中的常见约束。你将探索计算精度和溢出安全之间的权衡，学习如何设计一个在硬件限制下仍能正确工作的、稳健的缩放算法。",
            "id": "3272293",
            "problem": "现在以纯数学术语向您描述在线滑雪租赁决策问题。每天，租用的成本为正整数 $r$，购买的成本为正整数 $B$。两者均以任意货币单位计量。决策者可以先租用若干天，然后购买一次。经典的延迟购买策略是持续租用，直到累计租金至少等于购买成本时再进行购买；在精确计算下，这得出的购买日为 $d^\\star = \\lceil B / r \\rceil$。然而，假设决策者受限于只能使用 $N$ 位的固定大小无符号计数器来实现此决策。由于可能发生溢出，存储未缩放的 $B$ 值或无限制的每日累加可能不安全。您必须实现一个溢出安全的、使用2的幂次缩放因子进行整数除法的缩放延迟购买算法，并分析缩放对精度和响应时间的影响。\n\n算法要求：\n- 令 $C_{\\max} = 2^N - 1$ 表示单个 $N$ 位无符号计数器能表示的最大值。\n- 选择一个缩放因子 $s = 2^k$（其中 $k \\ge 0$ 为整数），使得缩放后的阈值 $T = \\left\\lfloor B / s \\right\\rfloor$ 和缩放后的累加器永远不会超过 $C_{\\max}$，并且该阈值不是退化的。为避免因 $T=0$ 导致的无意义立即购买，要求 $T \\ge 1$。为了平衡精度和溢出安全性，选择的 $s$ 应尽可能使 $T$ 落在计数器范围的较高部分：具体来说，尝试确保 $T \\ge \\left\\lceil C_{\\max} / 8 \\right\\rceil$。如果对于给定的 $B$ 和 $N$ 这是不可能的，则选择能产生 $T \\ge 1$ 的最大可能的 $s$（仍为2的幂次）。\n- 通过跟踪余数，使用缩放累加，使其在 $d$ 天后精确等于 $\\left\\lfloor d \\cdot r / s \\right\\rfloor$：每天将 $r$ 加到一个余数寄存器中，并将计数器增加 $\\left\\lfloor \\text{余数} / s \\right\\rfloor$，然后从余数中减去 $s$ 与该商的乘积。这通过整数运算实现了随时间推移的精确的定点除法（除以 $s$），避免了每日的舍入损失，并且根据构造防止了主计数器的溢出。\n- 在缩放累加器 $\\left\\lfloor d \\cdot r / s \\right\\rfloor$ 达到或超过阈值 $T = \\left\\lfloor B / s \\right\\rfloor$ 的第一天 $d$ 进行购买。等价地，通过闭式公式 $d_s = \\left\\lceil T \\cdot s / r \\right\\rceil$ 计算购买日，这是满足 $\\left\\lfloor d \\cdot r / s \\right\\rfloor \\ge T$ 的最小 $d$。\n\n您的任务：\n1. 实现上述带有溢出安全缩放和基于余数累加的缩放延迟购买算法。程序必须为每个测试用例自动选择如上所述的缩放因子 $s$。\n2. 对每个测试用例，计算两个整数：\n   - 缩放购买日 $d_s = \\left\\lceil T \\cdot s / r \\right\\rceil$。\n   - 精确的未缩放购买日 $d^\\star = \\left\\lceil B / r \\right\\rceil$。\n   同时计算非负整数偏差 $\\Delta = d^\\star - d_s$，它衡量了缩放实现相比于精确延迟策略提前了多少天购买。\n3. 在注释和您的解决方案中，讨论作为缩放因子 $s$ 和计数器位宽 $N$ 的函数的精度与响应时间之间的权衡，并解释为什么所选的缩放能确保计数器溢出安全。\n\n重要约束和科学真实性：\n- 所有量 $N$、$r$ 和 $B$ 都是正整数。\n- 缩放阈值 $T$ 必须满足 $1 \\le T \\le C_{\\max}$。\n- 余数寄存器必须能用相同的 $N$ 位宽表示，这通过选择 $s \\le C_{\\max}$ 来保证。\n\n测试套件：\n使用以下五个测试用例，涵盖典型行为、边界和边缘条件：\n- 用例 1：$N = 8$，$r = 9$，$B = 200$。\n- 用例 2：$N = 16$，$r = 1$，$B = 50000$。\n- 用例 3：$N = 8$，$r = 200$，$B = 201$。\n- 用例 4：$N = 8$，$r = 9$，$B = 19$。\n- 用例 5：$N = 12$，$r = 300$，$B = 4000$。\n\n要求的最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例贡献一个包含三个整数 $[d_s, d^\\star, \\Delta]$ 的子列表。例如，输出应类似于 $[[d_{s1},d^\\star_1,\\Delta_1],[d_{s2},d^\\star_2,\\Delta_2],\\dots]$，逗号或括号之间不加空格。",
            "solution": "该问题要求实现并分析滑雪租赁问题中延迟购买策略的缩放、定点算术版本，该版本针对具有固定大小 $N$ 位无符号计数器的系统进行了优化。\n\n首先，我们形式化地描述无约束的、精确的延迟购买策略。一个决策者面临每日租金 $r$ 和一次性购买成本 $B$。决策者需要该服务的天数是事先未知的。延迟购买策略规定，只要累计租金 $d \\cdot r$ 小于购买成本 $B$，决策者就应该在第 $d$ 天继续租用。当此条件被违反时，决策者在第一天购买。因此，购买日（表示为 $d^\\star$）是满足 $d \\cdot r \\ge B$ 的最小正整数 $d$。这可以用向上取整函数在数学上表示为：\n$$d^\\star = \\left\\lceil \\frac{B}{r} \\right\\rceil$$\n\n接下来，我们引入 $N$ 位无符号计数器的硬件约束。这样一个计数器可以表示从 $0$ 到 $C_{\\max} = 2^N - 1$ 的整数。直接累加成本 $d \\cdot r$ 是不安全的，因为它可能超过 $C_{\\max}$ 并导致溢出，从而引出错误的决策。为了缓解这个问题，我们采用一种缩放技术。所有货币值都按一个因子 $s$ 进行缩小，该因子被选为2的幂，即 $s = 2^k$（其中 $k \\ge 0$ 为整数），以便使用位移而不是通用除法来实现高效运算。\n\n缩放后的问题表述如下：\n- 购买成本 $B$ 被转换为缩放阈值 $T = \\left\\lfloor B / s \\right\\rfloor$。\n- 累计租金 $d \\cdot r$ 被转换为缩放累加器 $A_d = \\left\\lfloor d \\cdot r / s \\right\\rfloor$。\n新的购买条件是在缩放累加器 $A_d$ 达到或超过缩放阈值 $T$ 的第一天 $d$ 进行购买。缩放购买日 $d_s$ 是满足 $A_d \\ge T$ 的最小整数 $d$。\n\n我们可以推导出 $d_s$ 的闭式表达式。条件是 $\\lfloor d \\cdot r / s \\rfloor \\ge T$。由于 $T$ 是一个整数，这个不等式等价于 $d \\cdot r / s \\ge T$。对 $d$ 进行整理，我们得到 $d \\ge (T \\cdot s) / r$。因为 $d$ 必须是整数，满足此条件的最小 $d$ 值为：\n$$d_s = \\left\\lceil \\frac{T \\cdot s}{r} \\right\\rceil$$\n\n缩放因子 $s$ 的选择至关重要，必须平衡两个相互竞争的目标：精度和溢出安全性。\n- 较小的 $s$（例如 $s=1$）会产生更高的精度，因为有效购买阈值 $\\lfloor B/s \\rfloor \\cdot s$ 更接近真实值 $B$。然而，这会导致一个更大的缩放阈值 $T$，从而增加了溢出的风险。\n- 较大的 $s$ 通过减小 $T$ 的量级，为防止溢出提供了更大的安全边际。然而，它通过增加量化误差 $B - (\\lfloor B/s \\rfloor \\cdot s)$ 来降低精度。这可能导致与精确策略产生显著偏差。\n\n问题为选择 $s=2^k$ 指定了一个确定性过程：\n1.  缩放阈值 $T$ 必须是非退化的，即 $T \\ge 1$。这意味着 $\\lfloor B / s \\rfloor \\ge 1$，这要求 $s \\le B$。\n2.  缩放阈值 $T$ 和累加器不能使 $N$ 位计数器溢出，即 $T \\le C_{\\max}$。\n3.  为保持合理的精度，选择逻辑优先将 $T$ 保持在计数器范围的较高部分。具体来说，我们尝试找到最大的缩放因子 $s=2^k$，使得产生的阈值 $T$ 满足 $T \\ge \\left\\lceil (2^N - 1) / 8 \\right\\rceil$。\n4.  如果无法满足第3步中的条件（当 $B$ 本身太小时会发生这种情况），我们退而求其次，选择仍然能确保非退化阈值 $T \\ge 1$ 的最大可能缩放因子 $s=2^k$。这相当于选择小于或等于 $B$ 的最大2的幂。\n\n缩放策略与精确策略之间的偏差为 $\\Delta = d^\\star - d_s$。我们可以证明 $\\Delta \\ge 0$。在缩放版本中，有效购买阈值为 $B_{eff} = \\lfloor B/s \\rfloor \\cdot s$。由于 $\\lfloor B/s \\rfloor \\le B/s$，我们有 $B_{eff} \\le B$。缩放算法基于这个更低或相等的有效阈值触发购买，因此它永远不会比精确算法更晚购买。因此，$d_s \\le d^\\star$，偏差 $\\Delta$ 总是非负的。$\\Delta$ 的大小与量化误差 $B - B_{eff} = B \\pmod s$ 有关。一个更大的 $s$ 可能导致更大的误差，从而可能引起更大的 $\\Delta$ 和一次更早、次优的购买。\n\n缩放累加器 $A_d = \\lfloor d \\cdot r / s \\rfloor$ 的实现可以通过使用余数跟踪方法来完成，而无需浮点运算。一个余数寄存器 `rem` 初始化为 $0$。每天，将日租金 $r$ 加到此寄存器中。主累加器增加的量是新余数与缩放因子的整数商，即 `inc = rem // s`。主累加器增加 `inc`，然后通过减去已“存入”的部分来更新余数：`rem = rem - inc * s`。这确保了在 $d$ 天内，累加器增加的总值恰好是 $\\lfloor d \\cdot r / s \\rfloor$。\n\n为了使这种基于余数的累加在 $N$ 位寄存器内是溢出安全的，中间和 `rem + r` 决不能超过 $C_{\\max}$。由于余数 `rem` 总是保持在 $[0, s-1]$ 的范围内，中间和的最大值为 $(s-1) + r$。因此，余数寄存器安全的一个充分条件是 $s + r - 1 \\le C_{\\max}$。问题的给定条件和约束遵守了这一点，确保了整个算法的溢出安全。主累加器也是安全的，因为它只会达到一个接近 $T$ 的值，而 $s$ 的选择逻辑确保了 $T$ 远在计数器的容量之内。\n\n现在，我们将把这套完整的方法论应用于提供的测试用例。对于每个用例 $(N, r, B)$，我们计算 $C_{\\max}$，根据指定的逻辑确定适当的缩放因子 $s$，然后计算缩放购买日 $d_s$、精确购买日 $d^\\star$ 以及由此产生的偏差 $\\Delta = d^\\star - d_s$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the scaled ski rental problem for a given set of test cases.\n    \"\"\"\n    \n    # Test suite covering typical behavior, boundaries, and edge conditions.\n    # Each case is a tuple: (N: counter width in bits, r: daily rent cost, B: buy cost).\n    test_cases = [\n        (8, 9, 200),\n        (16, 1, 50000),\n        (8, 200, 201),\n        (8, 9, 19),\n        (12, 300, 4000),\n    ]\n\n    results = []\n    for N, r, B in test_cases:\n        # ----------------------------------------------------------------------\n        # PROBLEM ANALYSIS AND PARAMETER CALCULATION\n        # ----------------------------------------------------------------------\n\n        # C_max: Maximum value for an N-bit unsigned counter.\n        C_max = (1  N) - 1\n\n        # d_star: The exact, unscaled buy day.\n        # This is ceil(B/r), calculated using integer arithmetic to avoid float precision issues.\n        # The formula (a + b - 1) // b computes ceil(a/b) for positive integers a, b.\n        d_star = (B + r - 1) // r\n\n        # ----------------------------------------------------------------------\n        # SCALING FACTOR (s) SELECTION LOGIC\n        # ----------------------------------------------------------------------\n        # The goal is to choose a scaling factor s = 2^k that balances precision\n        # (small s) with overflow safety (large s).\n        #\n        # Trade-off discussion:\n        # - Precision: The scaled threshold T = floor(B/s) introduces quantization.\n        #   The effective buy cost is floor(B/s) * s, which is = B. This causes the\n        #   algorithm to buy potentially earlier than the exact strategy (d_s = d_star).\n        #   A smaller 's' minimizes this quantization error, yielding a more accurate\n        #   result (Delta -> 0), but a larger T that is more likely to overflow.\n        # - Response Time / Overflow Safety: A larger 's' results in a smaller T,\n        #   providing more headroom in the counter (safer from overflow). However,\n        #   the larger quantization error can lead to a larger deviation Delta,\n        #   making the agent buy significantly earlier. The \"response time\" to\n        #   the threshold is shorter, but the economic outcome may be worse.\n        \n        # Priority 1: Try to keep T in the upper 1/8 of the counter range for good precision.\n        # T_pref_min is the preferred minimum threshold: ceil(C_max / 8).\n        T_pref_min = (C_max + 8) // 8 # Integer ceil for C_max >= 0.\n\n        # To satisfy T >= T_pref_min, we need floor(B/s) >= T_pref_min.\n        # This implies B/s >= T_pref_min, so s = B / T_pref_min.\n        # s_max_for_pref is the maximum s that could satisfy this.\n        # T_pref_min is always > 0 for N>=3, which covers all test cases.\n        s_max_for_pref = B // T_pref_min if T_pref_min > 0 else B\n        \n        s = 0\n        if s_max_for_pref >= 1:\n            # We can satisfy the preferred precision. Choose the largest power of 2\n            # less than or equal to s_max_for_pref. This maximizes s while meeting\n            # the precision target.\n            k = s_max_for_pref.bit_length() - 1\n            s = 1  k\n        else:\n            # Priority 2 (Fallback): Cannot meet preferred precision.\n            # Instead, choose the largest s = 2^k ensuring T >= 1.\n            # This is equivalent to choosing the largest s = 2^k such that s = B.\n            if B > 0:\n                k = B.bit_length() - 1\n                s = 1  k\n            else: # B=0 is ruled out by problem statement, but as a safeguard.\n                s = 1 # T would be 0, but this path is not taken.\n\n\n        # ----------------------------------------------------------------------\n        # SCALED BUY DAY (d_s) and DEVIATION (Delta) CALCULATION\n        # ----------------------------------------------------------------------\n\n        # T: The scaled threshold, based on the chosen scaling factor s.\n        # It is guaranteed to be >= 1 by the selection logic for s.\n        T = B // s\n        \n        # The chosen s guarantees that T is well below C_max, and the accumulator,\n        # which grows to reach T, is also safe from overflow.\n        # The problem also guarantees the remainder register is safe for the given constraints.\n\n        # d_s: The scaled buy day.\n        # This is ceil(T*s/r), calculated using integer arithmetic.\n        d_s = (T * s + r - 1) // r\n\n        # Delta: The non-negative deviation, measuring how much earlier the scaled\n        # implementation buys.\n        Delta = d_star - d_s\n        \n        results.append([d_s, d_star, Delta])\n\n    # Format the final output string exactly as required, with no extra spaces.\n    sub_results_str = [f\"[{','.join(map(str, res))}]\" for res in results]\n    final_output_str = f\"[{','.join(sub_results_str)}]\"\n    \n    print(final_output_str)\n\nsolve()\n```"
        }
    ]
}