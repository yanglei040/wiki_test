{
    "hands_on_practices": [
        {
            "introduction": "“阻碍对”的概念是稳定婚姻问题中稳定性的基石。第一个练习将带你从理论走向实践，挑战你实现一个关键的诊断工具：一个计算给定匹配中阻碍对数量的算法。通过高效地实现这一检查，你将对导致匹配不稳定的原因有一个更深刻、更具操作性的理解 。",
            "id": "3274083",
            "problem": "给定经典的稳定婚姻问题 (SMP)，该问题包含两个大小相等的不相交集合，一个男性集合和一个女性集合。设男性数量为 $n$，女性数量为 $n$，男性索引为 $\\{0,1,\\dots,n-1\\}$，女性索引为 $\\{0,1,\\dots,n-1\\}$。每位男性对所有女性提供一个严格全序（无并列）偏好，每位女性也对所有男性提供一个严格全序（无并列）偏好。完美匹配是一个双射 $\\mu$，它将每位男性 $m$ 与唯一一位女性 $\\mu(m)$ 配对，并将每位女性 $w$ 与唯一一位男性 $\\mu^{-1}(w)$ 配对。\n\n对于一个匹配 $\\mu$，如果男性 $m$ 和女性 $w$ 在 $\\mu$ 中没有相互匹配，并且 $m$ 和 $w$ 都严格偏好对方胜过自己在 $\\mu$ 下的配偶，那么配对 $(m,w)$ 就是一个阻塞对。当且仅当不存在阻塞对时，一个匹配是稳定的。\n\n从上述基本定义出发，设计一个算法，在给定以下输入时：\n- 所有男性和女性的完整严格偏好配置，以及\n- 一个完美匹配 $\\mu$，\n\n利用排名矩阵计算阻塞对的确切数量。在提供偏好和匹配后，你的算法必须在 $O(n^2)$ 时间内运行。男性的排名矩阵，记为 $R^{M}$，定义为：如果女性 $w$ 在男性 $m$ 的偏好列表中的排名为 $r$，则 $R^{M}[m][w] = r$（值越小表示偏好越强）。类似地，女性的排名矩阵，记为 $R^{W}$，定义为：如果男性 $m$ 在女性 $w$ 的偏好列表中的排名为 $r$，则 $R^{W}[w][m] = r$（值越小表示偏好越强）。\n\n你的任务是实现这个算法，然后用它通过以下归一化不稳定性指数来衡量一个匹配与稳定性的接近程度：\n$$\nI(\\mu) = \n\\begin{cases}\n\\frac{B(\\mu)}{n^2 - n},  \\text{if } n^2 - n \\neq 0 \\\\\n0,  \\text{if } n^2 - n = 0\n\\end{cases}\n$$\n其中 $B(\\mu)$ 是 $\\mu$ 的阻塞对数量。分母 $n^2 - n$ 是在完美匹配中所有未配对的交叉对 $(m,w)$ 的总数。归一化不稳定性指数 $I(\\mu)$ 的取值范围在 $[0,1]$ 内。\n\n实现一个程序，对于下面的每个测试用例，返回一个双元素列表 $[B(\\mu), I(\\mu)]$，其中 $B(\\mu)$ 是一个整数，$I(\\mu)$ 是一个四舍五入到三位小数的实数。\n\n用于覆盖一系列情况的测试套件：\n- 情况 A (边界大小): $n=1$。\n  - 男性偏好: $[[0]]$。\n  - 女性偏好: $[[0]]$。\n  - 匹配: $[0]$。\n- 情况 B (稳定匹配，无阻塞对): $n=3$。\n  - 男性偏好: $[[0,1,2],[1,2,0],[2,0,1]]$。\n  - 女性偏好: $[[0,1,2],[1,2,0],[2,0,1]]$。\n  - 匹配: $[0,1,2]$。\n- 情况 C (一些阻塞对): $n=3$。\n  - 男性偏好: $[[1,0,2],[0,1,2],[0,1,2]]$。\n  - 女性偏好: $[[1,0,2],[0,1,2],[0,1,2]]$。\n  - 匹配: $[0,1,2]$。\n- 情况 D (相对于大小有许多阻塞对): $n=4$。\n  - 男性偏好: $[[0,1,2,3],[0,1,2,3],[0,1,2,3],[0,1,2,3]]$。\n  - 女性偏好: $[[0,1,2,3],[0,1,2,3],[0,1,2,3],[0,1,2,3]]$。\n  - 匹配: $[3,2,1,0]$。\n\n你的程序应该生成单行输出，其中包含一个逗号分隔的列表，该列表用方括号括起来，其中每个元素是对应测试用例的双元素列表，顺序与上面列出的一致。例如，输出必须采用以下形式\n\"[[B_A,I_A],[B_B,I_B],[B_C,I_C],[B_D,I_D]]\"\n其中 $I_A,I_B,I_C,I_D$ 均四舍五入到三位小数。",
            "solution": "该问题是有效的。这是一个来自离散数学和计算机科学领域的明确定义的算法任务，具体涉及在稳定婚姻问题的背景下分析匹配。所有输入、定义和约束都是清晰、一致且科学上合理的。\n\n问题要求我们设计一个算法，在一个大小为 $n$ 的稳定婚姻实例中，为一个给定的完美匹配 $\\mu$ 计算阻塞对的数量。该算法必须在 $O(n^2)$ 的时间复杂度内运行。随后，这个计数将用于计算归一化不稳定性指数 $I(\\mu)$。\n\n一个完美匹配 $\\mu$ 的阻塞对是一个由男性 $m$ 和女性 $w$ 组成的配对 $(m, w)$，他们没有相互匹配，但两人都严格偏好对方胜过自己在 $\\mu$ 下的配偶。形式上，当且仅当满足三个条件时，$(m, w)$ 是一个阻塞对：\n1.  男性 $m$ 和女性 $w$ 未匹配：$\\mu(m) \\neq w$。\n2.  男性 $m$ 偏好女性 $w$ 胜过其配偶 $\\mu(m)$。\n3.  女性 $w$ 偏好男性 $m$ 胜过其配偶 $\\mu^{-1}(w)$。\n\n一种朴素的方法是遍历所有不在匹配 $\\mu$ 中的 $n^2 - n$ 个配对 $(m, w)$，并对每个配对检查两个偏好条件。通过搜索长度为 $n$ 的个人偏好列表来验证偏好需要 $O(n)$ 的时间。这导致总体时间复杂度为 $O(n^3)$，效率低下且不满足指定的 $O(n^2)$ 约束。\n\n为了达到所需的 $O(n^2)$ 复杂度，我们必须在常数时间 $O(1)$ 内执行偏好检查。如题目所建议，这可以通过将偏好列表预处理成排名矩阵来实现。我们定义两个排名矩阵，一个用于男性 ($R^M$)，一个用于女性 ($R^W$）。\n\n男性的排名矩阵 $R^M$ 是一个 $n \\times n$ 矩阵，其中条目 $R^M[m][w]$ 存储了女性 $w$ 在男性 $m$ 偏好列表中的排名。较低的排名值表示更高的偏好。例如，如果男性 $m$ 最偏爱的女性是 $w_i$，则 $R^M[m][w_i] = 0$。这个矩阵可以通过遍历每个男性的偏好列表在 $O(n^2)$ 时间内构建。对于从 $0$ 到 $n-1$ 的每个男性 $m$，我们遍历他的偏好列表：如果女性 $w$ 在列表中的位置（排名）是 $r$，我们就设置 $R^M[m][w] = r$。\n\n类似地，女性的排名矩阵 $R^W$ 是一个 $n \\times n$ 矩阵，其中 $R^W[w][m]$ 存储了男性 $m$ 在女性 $w$ 偏好列表中的排名。这个矩阵也可以在 $O(n^2)$ 时间内构建。\n\n有了这些排名矩阵，检查一个阻塞对 $(m, w)$ 的偏好条件可以在 $O(1)$ 时间内完成：\n- 男性 $m$ 偏好 $w$ 胜过 $\\mu(m)$ 当且仅当 $R^M[m][w]  R^M[m][\\mu(m)]$。\n- 女性 $w$ 偏好 $m$ 胜过 $\\mu^{-1}(w)$ 当且仅当 $R^W[w][m]  R^W[w][\\mu^{-1}(w)]$。\n\n完整的 $O(n^2)$ 算法如下：\n\n1.  **预处理 (时间: $O(n^2)$):**\n    a. 给定男性的偏好列表，构建男性的排名矩阵 $R^M$。这需要 $O(n^2)$ 时间。\n    b. 给定女性的偏好列表，构建女性的排名矩阵 $R^W$。这也需要 $O(n^2)$ 时间。\n    c. 给定匹配 $\\mu$（一个数组，其中 `matching[m]` $= \\mu(m)$），构建逆匹配 $\\mu^{-1}$（一个数组，其中 `inverse_matching[w]` $= \\mu^{-1}(w)$）。这需要 $O(n)$ 时间。\n\n2.  **阻塞对计数 (时间: $O(n^2)$):**\n    a. 初始化一个阻塞对数量计数器 $B(\\mu)$ 为 $0$。\n    b. 遍历所有可能的男性 $m$（从 $0$ 到 $n-1$）和女性 $w$（从 $0$ 到 $n-1$）的配对。\n    c. 对于每个配对 $(m, w)$，首先检查他们是否已经匹配，即 $w = \\mu(m)$。如果是，这个配对不可能是阻塞对，我们继续下一个配对。\n    d. 如果他们未匹配，使用排名矩阵检查两个偏好条件：\n        i.  $R^M[m][w]  R^M[m][\\mu(m)]$\n        ii. $R^W[w][m]  R^W[w][\\mu^{-1}(w)]$\n    e. 如果两个条件都为真，则配对 $(m, w)$ 是一个阻塞对。将计数器 $B(\\mu)$ 加一。\n\n3.  **不稳定性指数计算 (时间: $O(1)$):**\n    a. 遍历完所有 $n^2$ 个配对后，计数器 $B(\\mu)$ 将保存阻塞对的总数。\n    b. 然后根据以下公式计算归一化不稳定性指数 $I(\\mu)$：\n    $$\n    I(\\mu) = \n    \\begin{cases}\n    \\frac{B(\\mu)}{n^2 - n},  \\text{if } n^2 - n \\neq 0 \\\\\n    0,  \\text{if } n^2 - n = 0\n    \\end{cases}\n    $$\n    $n^2-n=0$ 的情况仅在 $n=0$ 或 $n=1$ 时发生。对于 $n=1$，没有未匹配的配对，所以 $B(\\mu)$ 必然为 $0$，且 $I(\\mu)$ 被定义为 $0$。对于 $n>1$，分母不为零。这个指数 $I(\\mu)$ 代表了不稳定配对在所有非匹配配对中所占的比例。\n\n该算法的总时间复杂度是其各步骤复杂度之和：预处理为 $O(n^2)$，计数为 $O(n^2)$，总复杂度为 $O(n^2)$，满足问题的约束。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_instability(n, men_prefs, women_prefs, matching):\n    \"\"\"\n    Computes the number of blocking pairs and the instability index for a given matching.\n\n    Args:\n        n (int): The number of men and women.\n        men_prefs (list of list of int): Men's preference lists.\n        women_prefs (list of list of int): Women's preference lists.\n        matching (list of int): The matching to analyze, where matching[m] = w.\n\n    Returns:\n        tuple: A tuple (B, I) where B is the number of blocking pairs and I is the\n               normalized instability index.\n    \"\"\"\n    if n == 1:\n        # For n=1, there are no non-matched pairs, so B=0.\n        # The problem defines I=0 for this case.\n        return 0, 0.0\n\n    # Step 1: Preprocessing\n    # a. Construct men's rank matrix R_M\n    # R_M[m][w] = rank of woman w in man m's preference list\n    R_M = np.zeros((n, n), dtype=int)\n    for m in range(n):\n        for rank, w in enumerate(men_prefs[m]):\n            R_M[m, w] = rank\n\n    # b. Construct women's rank matrix R_W\n    # R_W[w][m] = rank of man m in woman w's preference list\n    R_W = np.zeros((n, n), dtype=int)\n    for w in range(n):\n        for rank, m in enumerate(women_prefs[w]):\n            R_W[w, m] = rank\n\n    # c. Construct the inverse matching\n    inverse_matching = np.zeros(n, dtype=int)\n    for m, w in enumerate(matching):\n        inverse_matching[w] = m\n    \n    # Pre-fetch the ranks of the current partners for faster lookups\n    man_partner_ranks = np.zeros(n, dtype=int)\n    for m in range(n):\n        man_partner_ranks[m] = R_M[m, matching[m]]\n        \n    woman_partner_ranks = np.zeros(n, dtype=int)\n    for w in range(n):\n        woman_partner_ranks[w] = R_W[w, inverse_matching[w]]\n\n    # Step 2: Blocking Pair Count\n    blocking_pairs_count = 0\n    for m in range(n):\n        for w in range(n):\n            # A pair cannot block itself\n            if matching[m] == w:\n                continue\n\n            # Check if (m, w) is a blocking pair\n            # Condition 1: m prefers w to his current partner\n            m_prefers_w = R_M[m, w]  man_partner_ranks[m]\n            \n            # Condition 2: w prefers m to her current partner\n            w_prefers_m = R_W[w, m]  woman_partner_ranks[w]\n\n            if m_prefers_w and w_prefers_m:\n                blocking_pairs_count += 1\n    \n    B = blocking_pairs_count\n    \n    # Step 3: Instability Index Calculation\n    # Denominator is the total number of non-matched pairs\n    denominator = n**2 - n\n    I = B / denominator if denominator != 0 else 0.0\n\n    return B, I\n\ndef solve():\n    \"\"\"\n    Defines the test cases and runs the instability calculation for each,\n    then prints the formatted results.\n    \"\"\"\n    test_cases = [\n        # Case A (boundary size): n=1\n        {\n            \"n\": 1,\n            \"men_prefs\": [[0]],\n            \"women_prefs\": [[0]],\n            \"matching\": [0]\n        },\n        # Case B (stable matching, no blocking pairs): n=3\n        {\n            \"n\": 3,\n            \"men_prefs\": [[0, 1, 2], [1, 2, 0], [2, 0, 1]],\n            \"women_prefs\": [[0, 1, 2], [1, 2, 0], [2, 0, 1]],\n            \"matching\": [0, 1, 2]\n        },\n        # Case C (some blocking pairs): n=3\n        {\n            \"n\": 3,\n            \"men_prefs\": [[1, 0, 2], [0, 1, 2], [0, 1, 2]],\n            \"women_prefs\": [[1, 0, 2], [0, 1, 2], [0, 1, 2]],\n            \"matching\": [0, 1, 2]\n        },\n        # Case D (many blocking pairs relative to size): n=4\n        {\n            \"n\": 4,\n            \"men_prefs\": [[0, 1, 2, 3], [0, 1, 2, 3], [0, 1, 2, 3], [0, 1, 2, 3]],\n            \"women_prefs\": [[0, 1, 2, 3], [0, 1, 2, 3], [0, 1, 2, 3], [0, 1, 2, 3]],\n            \"matching\": [3, 2, 1, 0]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        B, I = calculate_instability(case[\"n\"], case[\"men_prefs\"], case[\"women_prefs\"], case[\"matching\"])\n        # Round the instability index to three decimal places\n        I_rounded = round(I, 3)\n        results.append([B, I_rounded])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "经典的Gale-Shapley算法假设偏好列表是完整且无限制的，但现实世界的情景很少如此简单。这项实践要求你调整该算法，以处理存在“禁止配对”和不完整列表的情况，在这些情况下，某些匹配是不可能的，或者个体不愿意与所有人匹配。这项任务将提升你将理论算法应用于解决实际受限问题的能力 。",
            "id": "3274062",
            "problem": "考虑具有不完整列表和禁用配对的稳定婚姻问题 (SMP)。假设有两个不相交的代理集合，一个提议方 $U$ 和一个接收方 $V$，其中对于某个整数 $n \\geq 1$，有 $|U| = |V| = n$。每个代理 $u \\in U$ 对 $V$ 中代理的一个子集有严格的偏好顺序，每个代理 $v \\in V$ 对 $U$ 中代理的一个子集有严格的偏好顺序。一个配对 $(u,v)$ 是可接受的，当且仅当 $u$ 的列表中包含 $v$ 且 $v$ 的列表中包含 $u$。此外，一个配对子集 $F \\subseteq U \\times V$ 被声明为禁用，这意味着任何配对 $(u,v) \\in F$ 都不能被匹配，即使根据代理的列表 $(u,v)$ 是可接受的。\n\n一个匹配 $M \\subseteq U \\times V$ 是一组不相交的配对（没有代理出现在一个以上的配对中）。允许存在未匹配的代理。就可接受性而言，一个配对 $(u,v)$ 属于 $M$ 仅当 $(u,v)$ 是可接受的且 $(u,v) \\notin F$。一个不在 $M$ 中的配对 $(u,v)$ 是一个阻塞对，如果 $(u,v)$ 是可接受的，$(u,v) \\notin F$，代理 $u$ 严格偏好 $v$ 超过其在 $M$ 中的当前伴侣（或未匹配状态），并且代理 $v$ 严格偏好 $u$ 超过其在 $M$ 中的当前伴侣（或未匹配状态）。如果一个匹配没有阻塞对，则它是稳定的。\n\n从稳定性、可接受性和严格偏好的核心定义出发，并使用 Gale–Shapley 算法 (GSA) 作为基本程序，调整该算法，使其永远不会向禁用或不可接受的伴侣发出提议。您的算法必须处理双方可能不完整的偏好列表和禁用集 $F$。程序必须：\n- 构建一个忽略禁用和不可接受配对的、$U$ 方提议的 Gale–Shapley 程序。\n- 生成一个稳定匹配 $M$（可能是不完整的）。\n- 使用上述正式定义，通过计算阻塞对的数量来验证稳定性。\n- 分析是否存在稳定完美匹配（即匹配双方所有代理的匹配）：返回一个布尔值，指示调整后的 Gale–Shapley 程序是否产生了一个完美匹配。在具有不完整列表且无平局的 SMP 中，此条件是稳定完美匹配存在的充分必要条件。\n\n对于每个测试用例，您的程序必须返回一个列表 $[s, p, b, u, M]$，其中：\n- $s$ 是一个布尔值，指示算法是否产生了稳定匹配（当且仅当 $b = 0$ 时应为 true），\n- $p$ 是一个布尔值，指示匹配是否是完美的（$U$ 中的所有 $n$ 个代理都已匹配），\n- $b$ 是阻塞对的整数数量，\n- $u$ 是 $U$ 中未匹配代理的整数数量，\n- $M$ 是一个匹配配对的列表，编码为列表的列表 $[[u_1, v_1], [u_2, v_2], \\dots]$，其中每个 $u_i$ 和 $v_i$ 都写为整数。\n\n实现您的解决方案并为以下测试套件计算输出。在每个案例中，都指定了 $n$、偏好列表和禁用配对。列表中的所有整数都表示代理索引。\n\n- 测试用例 $1$（理想路径，存在完美匹配）：\n  - $n = 3$\n  - $P_U = \\{0 : [0,1,2],\\ 1 : [1,2,0],\\ 2 : [2,1,0]\\}$\n  - $P_V = \\{0 : [1,0,2],\\ 1 : [0,1,2],\\ 2 : [2,1,0]\\}$\n  - $F = \\{(0,2)\\}$\n\n- 测试用例 $2$（无禁用配对，标准 SMP）：\n  - $n = 3$\n  - $P_U = \\{0 : [1,0,2],\\ 1 : [1,2,0],\\ 2 : [0,2,1]\\}$\n  - $P_V = \\{0 : [2,0,1],\\ 1 : [0,1,2],\\ 2 : [1,2,0]\\}$\n  - $F = \\{\\}$\n\n- 测试用例 $3$（由于禁用配对，一个代理的可接受列表为空，无完美匹配）：\n  - $n = 4$\n  - $P_U = \\{0 : [0,1,2,3],\\ 1 : [1,0,2,3],\\ 2 : [2,3,1,0],\\ 3 : [3,2,1,0]\\}$\n  - $P_V = \\{0 : [1,0,2,3],\\ 1 : [0,1,2,3],\\ 2 : [2,3,1,0],\\ 3 : [3,2,1,0]\\}$\n  - $F = \\{(3,0),(3,1),(3,2),(3,3)\\}$\n\n- 测试用例 $4$（多个提议者竞争一个选择非常有限的接收者，无完美匹配）：\n  - $n = 4$\n  - $P_U = \\{0 : [0],\\ 1 : [0],\\ 2 : [1,2,3],\\ 3 : [3,2,1]\\}$\n  - $P_V = \\{0 : [1,0,2,3],\\ 1 : [2,3,1,0],\\ 2 : [2,3,1,0],\\ 3 : [3,2,1,0]\\}$\n  - $F = \\{(1,1),(1,2),(1,3)\\}$\n\n- 测试用例 $5$（边界情况，最小规模，一个提议者没有可接受的伴侣）：\n  - $n = 2$\n  - $P_U = \\{0 : [0],\\ 1 : [1,0]\\}$\n  - $P_V = \\{0 : [1,0],\\ 1 : [1,0]\\}$\n  - $F = \\{(0,0)\\}$\n\n您的程序应生成单行输出，其中包含一个以逗号分隔的列表形式的结果，并用方括号括起来（例如 $[result_1,result_2,\\dots,result_k]$），其中每个 $result_i$ 对应一个测试用例，并严格按照上述 $[s,p,b,u,M]$ 的格式。程序必须是自包含的，不需要任何输入，并使用指定的运行时环境。所有返回值必须来自基本类型集合：布尔值、整数、浮点数或这些类型的列表。编码的匹配 $M$ 中不允许出现字符串。",
            "solution": "该问题要求对 Gale-Shapley 算法 (GSA)进行调整，以解决具有不完整列表和禁用配对的稳定婚姻问题。解决方案必须处理这些约束，生成一个稳定匹配，并验证其属性。指导此解决方案的核心原则是可接受性、禁用配对和稳定性的正式定义。\n\n总体方法分为三个主要阶段：\n$1$. **预处理**：我们首先为提议方代理 ($U$) 构建有效的偏好列表。一个配对 $(u,v)$ 只有在既*可接受*（即 $u$ 在 $v$ 的偏好列表上，且 $v$ 在 $u$ 的列表上）又*非禁用*（即 $(u,v) \\notin F$）的情况下，才是一个有效的匹配候选者。通过在开始时筛选每个提议者的偏好列表，只包含此类有效伴侣，我们确保后续算法只考虑有资格成为稳定匹配一部分的配对。这将问题转化为具有不完整列表的稳定婚姻问题 (SMPI) 的一个等价实例，而 GSA 是解决该问题的标准方法。\n\n$2$. **执行（调整后的 Gale-Shapley 算法）**：然后使用这些经过预处理的有效偏好列表来执行 $U$ 方提议的 GSA。\n    - 初始化一个来自集合 $U$ 的“自由”代理队列。\n    - 当队列不为空时，一个自由代理 $u$ 出队，并向其有效列表中尚未提议过的、排名最高的代理 $v$ 提议。\n    - 接收方代理 $v$ 评估该提议。如果 $v$ 当前未匹配，他们会暂时接受。如果 $v$ 已经与代理 $u'$ 匹配，他们会根据自己原始的、完整的偏好列表比较 $u$ 和 $u'$。如果 $v$ 更偏好 $u$ 而不是 $u'$，他们会与 $u'$ 解除婚约（$u'$ 重新变为自由身）并暂时接受来自 $u$ 的提议。否则，$v$ 拒绝 $u$，而 $u$ 保持自由，可以向其列表上的下一个代理提议。\n    - 一个用尽其有效偏好列表（该列表可能从一开始就是空的）的代理 $u$ 将永久保持未匹配状态。\n    - 当自由代理队列为空时，算法终止。此时的暂定婚約集合构成了最终的稳定匹配。用于 SMPI 的 GSA 保证此过程会终止，并产生一个 $U$ 方最优的稳定匹配，这意味着 $U$ 中的任何代理在任何其他稳定匹配中都无法获得更好的结果。\n\n$3$. **验证与分析**：在获得匹配 $M$ 后，会进行严格的验证过程，以确认其是否符合问题陈述所要求的属性。\n    - **稳定性检查**：计算阻塞对的数量。一个配对 $(u,v) \\notin M$ 是一个阻塞对，如果：（$a$）它是可接受的，（$b$）它不是禁用的，（$c$）$u$ 偏好 $v$ 超过其在 $M$ 中的伴侣（或未匹配状态），以及（$d$）$v$ 偏好 $u$ 超过其在 $M$ 中的伴侣（或未匹配状态）。此检查会对 $(U \\times V) \\setminus M$ 中的所有配对进行详尽的遍历。对于正确实现的 GSA，此计数必须为 $0$。当且仅当此计数为 $0$ 时，稳定性布尔值 $s$ 为 true。\n    - **完美性与未匹配代理**：如果 $U$中的每个代理都已匹配，则该匹配是完美的。布尔值 $p$ 会相应设置，并且 $U$ 中未匹配代理的数量（表示为 $u$）计算为 $n - |M|$。\n    - **最终输出组装**：将结果编译为指定的列表格式：$[s, p, b, u, M]$。\n\n这种有原則的设计通过首先简化问题约束，然后应用一个经过验证的算法，最后对照初始的复杂规则对结果进行形式化验证，从而确保了正确性。\n\n为实现这一点，我们预先计算偏好排名以便高效查找。对于一个代理 $w$ 和一个潜在伴侣 $z$，$rank(w, z)$ 是 $z$ 在 $w$ 的偏好列表中的位置。如果 $z$ 不在 $w$ 的列表上，则分配一个无穷大的排名（例如，一个比任何可能排名都大的数字）。这使得代理在评估新提议与当前伴侣时可以进行简单的数值比较。\n\n对于阻塞对检查，对于一个给定的配对 $(u, v) \\notin M$：\n- 如果 $rank(u, v)  rank(u, \\text{u 的当前伴侣})$，则 $u$ 更偏好 $v$。如果 $u$ 未匹配，其当前伴侣的排名被认为是无穷大，因此任何有效的提议都会被偏好。\n- 对称的逻辑适用于 $v$ 的偏好。\n- 阻塞对的所有四个条件必须同时满足，计数才会增加。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves a series of Stable Marriage Problems with Incomplete Lists and Forbidden Pairs.\n    \"\"\"\n    \n    test_cases = [\n        {\n            \"n\": 3,\n            \"P_U\": {0: [0, 1, 2], 1: [1, 2, 0], 2: [2, 1, 0]},\n            \"P_V\": {0: [1, 0, 2], 1: [0, 1, 2], 2: [2, 1, 0]},\n            \"F\": [[0, 2]]\n        },\n        {\n            \"n\": 3,\n            \"P_U\": {0: [1, 0, 2], 1: [1, 2, 0], 2: [0, 2, 1]},\n            \"P_V\": {0: [2, 0, 1], 1: [0, 1, 2], 2: [1, 2, 0]},\n            \"F\": []\n        },\n        {\n            \"n\": 4,\n            \"P_U\": {0: [0, 1, 2, 3], 1: [1, 0, 2, 3], 2: [2, 3, 1, 0], 3: [3, 2, 1, 0]},\n            \"P_V\": {0: [1, 0, 2, 3], 1: [0, 1, 2, 3], 2: [2, 3, 1, 0], 3: [3, 2, 1, 0]},\n            \"F\": [[3, 0], [3, 1], [3, 2], [3, 3]]\n        },\n        {\n            \"n\": 4,\n            \"P_U\": {0: [0], 1: [0], 2: [1, 2, 3], 3: [3, 2, 1]},\n            \"P_V\": {0: [1, 0, 2, 3], 1: [2, 3, 1, 0], 2: [2, 3, 1, 0], 3: [3, 2, 1, 0]},\n            \"F\": [[1, 1], [1, 2], [1, 3]]\n        },\n        {\n            \"n\": 2,\n            \"P_U\": {0: [0], 1: [1, 0]},\n            \"P_V\": {0: [1, 0], 1: [1, 0]},\n            \"F\": [[0, 0]]\n        },\n    ]\n\n    def format_result(res):\n        \"\"\"Formats a single result list into the required string representation.\"\"\"\n        s, p, b, u, M = res\n        s_str = 'true' if s else 'false'\n        p_str = 'true' if p else 'false'\n        m_str_parts = [f\"[{pair[0]},{pair[1]}]\" for pair in M]\n        m_str = f\"[{','.join(m_str_parts)}]\"\n        return f\"[{s_str},{p_str},{b},{u},{m_str}]\"\n\n    def run_smp_case(n, P_U, P_V, F):\n        \"\"\"Processes a single test case of the stable marriage problem.\"\"\"\n        F_set = {tuple(p) for p in F}\n\n        # 1. Preprocessing: Create effective preference lists for U\n        cleaned_U_prefs = {u: [] for u in range(n)}\n        for u in range(n):\n            if u in P_U:\n                for v in P_U[u]:\n                    is_acceptable = v in P_V and u in P_V.get(v, [])\n                    is_not_forbidden = (u, v) not in F_set\n                    if is_acceptable and is_not_forbidden:\n                        cleaned_U_prefs[u].append(v)\n        \n        # Pre-calculate V's rankings for efficient lookups\n        v_rankings = np.full((n, n), n, dtype=int)\n        for v in range(n):\n            if v in P_V:\n                for rank, u in enumerate(P_V[v]):\n                    v_rankings[v, u] = rank\n\n        # 2. Execution: U-proposing Gale-Shapley Algorithm\n        free_men = list(range(n))\n        u_proposal_idx = np.zeros(n, dtype=int)\n        v_partners = np.full(n, -1, dtype=int)\n\n        while free_men:\n            u = free_men.pop(0)\n            u_prefs = cleaned_U_prefs[u]\n            \n            if u_proposal_idx[u]  len(u_prefs):\n                v = u_prefs[u_proposal_idx[u]]\n                u_proposal_idx[u] += 1\n                \n                current_partner = v_partners[v]\n                if current_partner == -1:\n                    v_partners[v] = u\n                else:\n                    if v_rankings[v, u]  v_rankings[v, current_partner]:\n                        v_partners[v] = u\n                        free_men.append(current_partner)\n                    else:\n                        free_men.append(u)\n            # If u has exhausted their list, they remain unmatched.\n        \n        # 3. Verification and Analysis\n        \n        # Construct final matching M and related stats\n        M_dict = {v_partners[v]: v for v in range(n) if v_partners[v] != -1}\n        M_list = sorted(list(M_dict.items()))\n        \n        u_unmatched_count = n - len(M_list)\n        p_is_perfect = (len(M_list) == n)\n\n        # Count blocking pairs\n        u_rankings = np.full((n, n), n, dtype=int)\n        for u in range(n):\n            if u in P_U:\n                for rank, v in enumerate(P_U[u]):\n                    u_rankings[u, v] = rank\n\n        b_blocking_pairs_count = 0\n        for u in range(n):\n            u_current_partner = M_dict.get(u, -1)\n            u_current_rank = n if u_current_partner == -1 else u_rankings[u, u_current_partner]\n\n            if u not in P_U: continue\n\n            for v in P_U[u]:\n                if u_current_partner == v: continue # Not an outside pair\n\n                # Check if (u,v) is a blocking pair\n                is_acceptable = v in P_V and u in P_V.get(v, [])\n                is_not_forbidden = (u,v) not in F_set\n                \n                if is_acceptable and is_not_forbidden:\n                    u_prefers = u_rankings[u, v]  u_current_rank\n                    \n                    if u_prefers:\n                        v_current_partner = v_partners[v]\n                        v_current_rank = n if v_current_partner == -1 else v_rankings[v, v_current_partner]\n                        v_prefers = v_rankings[v, u]  v_current_rank\n                        \n                        if v_prefers:\n                            b_blocking_pairs_count += 1\n        \n        s_is_stable = b_blocking_pairs_count == 0\n        \n        return [s_is_stable, p_is_perfect, b_blocking_pairs_count, u_unmatched_count, M_list]\n\n    results = [run_smp_case(**case) for case in test_cases]\n    results_as_strings = [format_result(r) for r in results]\n    \n    print(f\"[{','.join(results_as_strings)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "当偏好不是严格的，且个体对几个选项持无所谓态度时，会发生什么？这个高级练习通过引入平局来挑战基础Gale-Shapley算法的确定性。你将探索随机打破平局所带来的后果，并为一个特定个体计算期望结果，从而深入了解当存在无差异选择时，稳定性的概率分布情况 。",
            "id": "3273994",
            "problem": "您的任务是修改经典的稳定婚姻问题 (Stable Marriage Problem, SMP)，通过应用随机打破平局的规则来处理偏好列表中的平局（无差异），然后分析单个指定代理人的期望结果。工作环境设定为有 $n$ 位男性和 $n$ 位女性，其中偏好可能包含平局。每个代理人的偏好是一个等级序列：等级 $1$ 是最偏好的，等级 $2$ 是次偏好的，以此类推；在一个等级内部，代理人对所有候选人持无差异态度。\n\n基本概念：\n- 匹配是男性集合与女性集合之间的一个双射。\n- 如果不存在阻塞对 $\\left(m,w\\right)$ 使得 $m$ 偏爱 $w$ 胜过他当前的伴侣，并且 $w$ 偏爱 $m$ 胜过她当前的伴侣，则该匹配是稳定的。\n- 当在严格偏好列表上运行时，男性提议的 Gale–Shapley 算法 (GS) 总能终止并得到男性最优稳定匹配。\n\n随机打破平局规则：\n- 对于每个代理人独立地，且对于每个平局等级独立地，通过抽取该等级内代理人的一个均匀随机排列来打破平局。跨等级的相对顺序保持不变。这样为每个代理人生成一个严格的全序。\n- 在打破平局后，在得到的严格偏好上运行男性提议的 Gale–Shapley 算法。\n\n待分析量：\n- 固定一个索引为 $i$ 的指定男性（其中代理人索引为 $0,1,\\dots,n-1$）。对于每个完整的打破平局结果，GS 算法的输出是一个完美匹配。使用该指定男性原始的带平局偏好，将其匹配到的伴侣映射到一个等级索引：如果匹配到的女性位于等级 $t$，则记录数字等级 $t$（等级 $1$ 为最佳）。\n- 将指定男性的期望等级定义为在所有打破平局结果的均匀分布下，所记录等级的平均值。\n\n计算任务：\n- 对于每个测试用例，通过枚举所有可能的打破平局结果（作为所有代理人及其所有平局等级的独立排列的笛卡尔积）来计算指定男性的确切期望等级。对于每个结果：\n  1. 使用该结果的排列将带平局的偏好转换为严格偏好。\n  2. 运行男性提议的 Gale–Shapley 算法以获得匹配。\n  3. 根据指定男性原始的带平局偏好，记录其等级索引。\n- 将所有结果中记录的等级索引取平均值，得到期望等级。将结果报告为四舍五入到 $6$ 位小数的浮点数。\n\n带平局偏好的表示方法：\n- 每个男性的偏好以等级列表的形式给出，其中每个等级是一个女性索引的列表。每个女性的偏好也是如此。例如，男性的带平局偏好列表 $[[0,1],[2]]$ 意味着集合 $\\{0,1\\}$ 是等级 $1$（对女性 $0$ 和 $1$ 无差异），而 $\\{2\\}$ 是等级 $2$。\n\n假设：\n- 所有偏好列表都是完整的：对于每个男性，所有等级恰好覆盖所有女性一次；对于每个女性，所有等级恰好覆盖所有男性一次。\n- 每一方的代理人索引从 $0$ 到 $n-1$。\n- Gale–Shapley 算法使用男性提议。\n\n测试用例：\n- 您必须计算以下 $4$ 个测试用例中指定男性的期望等级。在所有案例中，$n=3$，除了最后一个案例，$n=2$。每个测试用例由男性的分级偏好、女性的分级偏好以及指定的男性索引指定。\n\n- 测试用例 $1$ (双方都有少量平局)：\n  - 男性：\n    - $M_0$: $[[0,1],[2]]$\n    - $M_1$: $[[1],[0],[2]]$\n    - $M_2$: $[[1],[2],[0]]$\n  - 女性：\n    - $W_0$: $[[0,1],[2]]$\n    - $W_1$: $[[2],[1],[0]]$\n    - $W_2$: $[[0],[1],[2]]$\n  - 指定男性：$0$\n\n- 测试用例 $2$ (无平局；边界确定性)：\n  - 男性：\n    - $M_0$: $[[0],[1],[2]]$\n    - $M_1$: $[[1],[0],[2]]$\n    - $M_2$: $[[1],[2],[0]]$\n  - 女性：\n    - $W_0$: $[[1],[0],[2]]$\n    - $W_1$: $[[0],[1],[2]]$\n    - $W_2$: $[[0],[1],[2]]$\n  - 指定男性：$1$\n\n- 测试用例 $3$ (仅接收方有平局；女性有平局，男性为严格偏好)：\n  - 男性：\n    - $M_0$: $[[0],[1],[2]]$\n    - $M_1$: $[[1],[0],[2]]$\n    - $M_2$: $[[1],[2],[0]]$\n  - 女性：\n    - $W_0$: $[[0,1],[2]]$\n    - $W_1$: $[[1,2],[0]]$\n    - $W_2$: $[[0],[1],[2]]$\n  - 指定男性：$0$\n\n- 测试用例 $4$ (双方都有完全平局；$n=2$；边缘均匀性)：\n  - 男性：\n    - $M_0$: $[[0,1]]$\n    - $M_1$: $[[0,1]]$\n  - 女性：\n    - $W_0$: $[[0,1]]$\n    - $W_1$: $[[0,1]]$\n  - 指定男性：$0$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。第 $k$ 个数字必须是测试用例 $k$ 的期望等级，每个都四舍五入到 $6$ 位小数，例如 `[1.234000,2.000000,1.750000,1.000000]`。",
            "solution": "该问题被评估为有效。这是一个定义明确的计算任务，其根植于已建立的稳定匹配算法和离散概率理论。问题陈述是自洽的、数学上一致的，并为计算唯一解提供了所有必要的数据和定义。所规定的计算方法，即枚举所有打破平局的可能性，对于测试用例中指定的小问题规模是可行的。\n\n解决该问题的方法包括计算指定男性的期望等级，该期望等级定义为在他最终伴侣的等级在所有可能的随机解决偏好列表中平局情况下的平均值。单个测试用例的过程如下。\n\n设男性集合为 $M = \\{M_0, M_1, \\dots, M_{n-1}\\}$，女性集合为 $W = \\{W_0, W_1, \\dots, W_{n-1}\\}$，其中 $n$ 是男性和女性的数量。每个代理人 $a \\in M \\cup W$ 的偏好以等级列表的形式给出，$P_a = (T_{a,1}, T_{a,2}, \\dots)$，其中 $T_{a,j}$ 是另一组中的代理人集合。代理人 $a$ 对给定等级 $T_{a,j}$ 中的所有代理人无差异，并且当且仅当 $j  k$ 时，偏爱等级 $T_{a,j}$ 中的任何代理人胜过等级 $T_{a,k}$ 中的任何代理人。\n\n随机打破平局规则指出，对于每个大小 $|T_{a,j}| > 1$ 的等级 $T_{a,j}$，通过从该等级中代理人的 $|T_{a,j}|!$ 种可能排列中均匀随机选择一个线性排序来替换 $T_{a,j}$，从而打破平局。这些选择是为所有代理人及其各自的所有等级独立进行的。\n\n一个结果 $\\omega$ 是对所有代理人中所有平局进行一次此类打破的完整规范。所有可能结果的集合表示为 $\\Omega$。唯一结果的总数是所有平局等级大小的阶乘之积：\n$$ |\\Omega| = \\prod_{a \\in M \\cup W} \\prod_{j \\text{ s.t. } |T_{a,j}|>1} |T_{a,j}|! $$\n\n对于每个结果 $\\omega \\in \\Omega$，我们可以为所有代理人构建一组严格偏好列表 $P'(\\omega)$。使用这些严格偏好，男性提议的 Gale-Shapley 算法（表示为 $\\text{GS}$）保证产生一个唯一的稳定匹配，我们将其表示为 $\\mu_{\\omega}$。\n\n设指定男性为 $M_i$。在匹配 $\\mu_{\\omega}$ 中，他与某个女性 $w^* = \\mu_{\\omega}(M_i)$ 配对。然后我们参考 $M_i$ 原始的带平局偏好列表 $P_{M_i}$，以找到包含 $w^*$ 的等级。如果 $w^* \\in T_{M_i,t}$，我们记录这个等级索引 $t$。我们将此函数表示为 $\\text{Tier}(M_i, \\mu_{\\omega}) = t$。\n\n男性 $M_i$ 的期望等级是这些等级指数在所有可能结果上的算术平均值：\n$$ \\mathbb{E}[\\text{tier}(M_i)] = \\frac{1}{|\\Omega|} \\sum_{\\omega \\in \\Omega} \\text{Tier}(M_i, \\mu_{\\omega}) $$\n\n计算过程是该公式的直接实现：\n\n1.  **识别平局并生成排列**：对于每个测试用例，我们首先解析所有男性和女性的偏好列表，以找到所有大小大于 $1$ 的等级。对于每个这样的等级，我们生成所有可能排列的集合。\n\n2.  **枚举结果**：我们构建上一步中生成的所有排列集合的笛卡尔积。此积的每个元素对应一个完整的打破平局结果 $\\omega$。\n\n3.  **迭代与计算**：我们遍历笛卡尔积中的每个结果 $\\omega$。对于每个 $\\omega$：\n    a. 我们通过用 $\\omega$ 指定的具体排列替换每个平局等级，为所有 $n$ 个男性和 $n$ 个女性构建完整的严格偏好列表 $P'(\\omega)$。\n    b. 我们使用这些严格偏好 $P'(\\omega)$ 执行男性提议的 Gale-Shapley 算法。该算法过程如下：\n        i. 初始化所有男性为自由状态。\n        ii. 当存在自由男性 $m$ 时，他向其偏好列表 $P'_m(\\omega)$ 中下一个他尚未提议过的女性 $w$ 提议。\n        iii. 如果 $w$ 是自由的，她接受并与 $m$ 订婚。\n        iv. 如果 $w$ 已与男性 $m'$ 订婚，她使用她的偏好列表 $P'_w(\\omega)$ 比较 $m$ 和 $m'$。如果她偏爱 $m$ 胜过 $m'$，她解除与 $m'$ 的婚约（使 $m'$ 变为自由），并接受 $m$。否则，她拒绝 $m$。\n        v. 当没有男性是自由的时，算法终止。得到的订婚集合即为稳定匹配 $\\mu_{\\omega}$。为实现高效，每个女性的偏好列表被转换为等级映射，以实现常数时间比较。\n    c. 我们确定指定男性 $M_i$ 的伴侣。设此为 $w^* = \\mu_{\\omega}(M_i)$。\n    d. 我们确定 $w^*$ 在 $M_i$ 原始、未打破平局的偏好中的等级索引。此索引被加到一个运行总和中。\n\n4.  **计算平均值**：遍历所有结果后，将记录的等级索引的总和除以结果总数 $|\\Omega|$，得到最终的期望等级。然后将该值四舍五入到所需的小数位数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom itertools import permutations, product\n\ndef run_gale_shapley(n, men_prefs, women_prefs):\n    \"\"\"\n    Executes the men-proposing Gale-Shapley algorithm.\n\n    Args:\n        n (int): The number of men/women.\n        men_prefs (list of list of int): Strict preference lists for men.\n        women_prefs (list of list of int): Strict preference lists for women.\n\n    Returns:\n        list of int: A list where the i-th element is the partner of man i.\n    \"\"\"\n    # Create rank maps for women for O(1) preference lookups.\n    # women_ranks[w][m] gives the rank of man m in woman w's preference list.\n    women_ranks = [[0] * n for _ in range(n)]\n    for w in range(n):\n        for rank, m in enumerate(women_prefs[w]):\n            women_ranks[w][m] = rank\n\n    # woman_partner[w] is the man currently engaged to woman w, -1 if free.\n    woman_partner = [-1] * n\n    # man_partner[m] is the woman currently engaged to man m, -1 if free.\n    man_partner = [-1] * n\n    # next_proposal[m] is the index of the next woman man m will propose to.\n    next_proposal = [0] * n\n\n    # Initially, all men are free.\n    free_men_q = list(range(n))\n\n    while free_men_q:\n        m = free_men_q.pop(0)\n        \n        # Man m proposes to the next woman on his list.\n        w = men_prefs[m][next_proposal[m]]\n        next_proposal[m] += 1\n\n        if woman_partner[w] == -1:\n            # Woman w is free, she accepts.\n            woman_partner[w] = m\n            man_partner[m] = w\n        else:\n            # Woman w is engaged, she compares her current partner with the new suitor.\n            current_partner = woman_partner[w]\n            if women_ranks[w][m]  women_ranks[w][current_partner]:\n                # She prefers the new man m.\n                woman_partner[w] = m\n                man_partner[m] = w\n                \n                # Her old partner becomes free.\n                man_partner[current_partner] = -1\n                free_men_q.append(current_partner)\n            else:\n                # She rejects m, m remains free and will propose to the next on his list.\n                free_men_q.append(m)\n    \n    return man_partner\n\ndef solve_case(n, men_tiered_prefs, women_tiered_prefs, designated_man_idx):\n    \"\"\"\n    Calculates the expected tier for a designated man for a single test case.\n    \"\"\"\n    # 1. Identify all ties and generate the set of permutations for each.\n    # tie_permutations_list will be a list of lists of tuples, e.g., [[(0,1), (1,0)], [(0,1), (1,0)]]\n    tie_permutations_list = []\n    \n    def find_ties(agent_prefs_list):\n        for agent_prefs in agent_prefs_list:\n            for tier in agent_prefs:\n                if len(tier) > 1:\n                    tie_permutations_list.append(list(permutations(tier)))\n\n    find_ties(men_tiered_prefs)\n    find_ties(women_tiered_prefs)\n\n    # 2. Prepare for iteration by creating a tier lookup map for the designated man.\n    # This maps each woman to her tier index (1-based) in the original preferences.\n    designated_man_tier_map = {}\n    for tier_idx, tier in enumerate(men_tiered_prefs[designated_man_idx]):\n        for woman in tier:\n            designated_man_tier_map[woman] = tier_idx + 1\n\n    total_tier_sum = 0\n    num_outcomes = 0\n\n    # Handle the case where there are no ties.\n    if not tie_permutations_list:\n        outcomes_iterator = [()]\n    else:\n        outcomes_iterator = product(*tie_permutations_list)\n\n    # 3. Iterate through all possible tie-breaking outcomes.\n    for outcome_permutations in outcomes_iterator:\n        num_outcomes += 1\n        perm_iterator = iter(outcome_permutations)\n\n        # 3a. For each outcome, build strict preference lists.\n        def build_strict_list(tiered_prefs):\n            strict_list = []\n            for tier in tiered_prefs:\n                if len(tier) > 1:\n                    strict_list.extend(next(perm_iterator))\n                else:\n                    strict_list.extend(tier)\n            return strict_list\n        \n        strict_men_prefs = [build_strict_list(p) for p in men_tiered_prefs]\n        strict_women_prefs = [build_strict_list(p) for p in women_tiered_prefs]\n        \n        # 3b. Run Gale-Shapley algorithm.\n        matching = run_gale_shapley(n, strict_men_prefs, strict_women_prefs)\n        \n        # 3c/d. Find designated man's partner, look up tier, and add to sum.\n        partner = matching[designated_man_idx]\n        tier = designated_man_tier_map[partner]\n        total_tier_sum += tier\n\n    # 4. Calculate the expected tier.\n    return total_tier_sum / num_outcomes\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1\n        {\n            \"n\": 3,\n            \"men_prefs\": [[[0, 1], [2]], [[1], [0], [2]], [[1], [2], [0]]],\n            \"women_prefs\": [[[0, 1], [2]], [[2], [1], [0]], [[0], [1], [2]]],\n            \"designated_man\": 0,\n        },\n        # Test case 2\n        {\n            \"n\": 3,\n            \"men_prefs\": [[[0], [1], [2]], [[1], [0], [2]], [[1], [2], [0]]],\n            \"women_prefs\": [[[1], [0], [2]], [[0], [1], [2]], [[0], [1], [2]]],\n            \"designated_man\": 1,\n        },\n        # Test case 3\n        {\n            \"n\": 3,\n            \"men_prefs\": [[[0], [1], [2]], [[1], [0], [2]], [[1], [2], [0]]],\n            \"women_prefs\": [[[0, 1], [2]], [[1, 2], [0]], [[0], [1], [2]]],\n            \"designated_man\": 0,\n        },\n        # Test case 4\n        {\n            \"n\": 2,\n            \"men_prefs\": [[[0, 1]], [[0, 1]]],\n            \"women_prefs\": [[[0, 1]], [[0, 1]]],\n            \"designated_man\": 0,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        expected_tier = solve_case(\n            case[\"n\"], case[\"men_prefs\"], case[\"women_prefs\"], case[\"designated_man\"]\n        )\n        results.append(f\"{expected_tier:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}