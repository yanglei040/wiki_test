{
    "hands_on_practices": [
        {
            "introduction": "在深入研究复杂算法之前，通过一个直观的思维实验来巩固基本概念是至关重要的。这个练习  要求你分析一个由两个环共享一个顶点构成的简单图，从而识别其割点和块。这有助于你建立对网络关键节点和鲁棒子结构的核心直觉。",
            "id": "1484265",
            "problem": "考虑一个简单的无向图 $G=(V, E)$，其构造如下。该图由两个环的并集构成，我们称之为 $C_A$ 和 $C_B$。$C_A$ 和 $C_B$ 都是长度为 5 的环。这两个环恰好共享一个公共顶点，且没有公共边。一个*割点*（或关节点）是指移除后会增加图的连通分量数量的顶点。一个*块*是指 $G$ 的一个自身没有割点的最大连通子图。\n\n根据这个构造，下列哪个陈述正确描述了图 $G$ 中块和割点的数量？\n\nA. 该图有 1 个块和 0 个割点。\nB. 该图有 2 个块和 1 个割点。\nC. 该图有 1 个块和 1 个割点。\nD. 该图有 2 个块和 0 个割点。\nE. 该图有 10 个块和 9 个割点。",
            "solution": "给定一个简单的无向图 $G=(V,E)$，它由两个 5-环（表示为 $C_{A}$ 和 $C_{B}$）的并集构成，这两个环恰好共享一个公共顶点，且没有公共边。\n\n根据定义，割点（关节点）是移除后会增加图的连通分量数量的顶点。块是没有割点的最大连通子图。\n\n首先，确定割点。设唯一的公共顶点为 $s$。考虑从 $G$ 中移除 $s$。由于 $C_{A}$ 和 $C_{B}$ 仅在 $s$ 处相交，移除 $s$ 会将图断开成两个不相交的子图，每个子图都是相应的 5-环移除 $s$ 后的结果。每个这样的子图都是连通的（一条路径），但它们彼此不相交。因此，连通分量的数量增加，所以 $s$ 是一个割点。\n\n接下来，考虑任意一个顶点 $u \\in V$ 且 $u \\neq s$。不失一般性地，假设 $u \\in C_{A}\\setminus\\{s\\}$。从 $G$ 中移除 $u$ 会使 $C_{A}$ 变成一条由其剩余顶点构成的路径，该路径是连通的，而 $C_{B}$ 保持完整且连通。此外，这两个部分通过共享顶点 $s$（仍然存在）保持连接，所以整个图仍然是连通的。因此，移除 $u$ 不会增加连通分量的数量。所以，除了 $s$ 之外没有其他顶点是割点。由此可知，$G$ 恰好有一个割点。\n\n现在确定块。一个至少有三个顶点的环没有割点并且是 2-连通的，因此每个 5-环都是一个没有割点的连通子图。将 $C_{A}$ 视为一个子图：它自身内部没有割点，并且从 $C_{B}$ 添加任何额外的顶点或边都会创建一个更大的连通子图，其中共享顶点 $s$ 会成为一个割点（移除 $s$ 会将添加的部分与其余部分断开），这违反了块的定义。因此 $C_{A}$ 是在没有割点方面是最大的，并且是一个块。同样的论证也适用于 $C_{B}$。整个图 $G$ 不是一个块，因为它有割点 $s$。因此，块就是这两个 5-环，所以 $G$ 恰好有两个块。\n\n综合这些结论，$G$ 有 $2$ 个块和 $1$ 个割点。这对应于选项 B。",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "掌握了基本定义后，下一步是将理论转化为实践。这个练习  是一个核心编程任务，它要求你利用深度优先搜索（DFS）实现一个能够准确找出图中所有割点的算法。完成这个练习将标志着你具备了通过代码分析图连通性弱点的基本能力。",
            "id": "3227552",
            "problem": "给定一个无向简单图的族。无向简单图是一个偶对 $G=(V,E)$，其中 $V$ 是一个有限的顶点集合，$E\\subseteq \\{\\{u,v\\}\\mid u\\in V, v\\in V, u\\neq v\\}$ 是一个无序对的集合，图中没有自环也没有平行边。$G$ 的一个连通分量是一个极大的顶点子集 $C\\subseteq V$，使得对于 $C$ 中的每一对顶点 $x,y\\in C$，在 $G$ 中都存在一条以 $x$ 和 $y$ 为端点的路径。一个顶点 $a\\in V$ 被称为关节点（也称为割点），如果移除顶点 $a$ 及其所有关联边会增加图的连通分量数量。\n\n您的任务是实现一个程序，使用深度优先搜索（DFS）来确定每个给定测试图 $G$ 的所有关节点，并以顶点索引升序排序的列表形式报告。顶点由从 $0$ 开始的整数标记。\n\n推理和实现的基本依据：\n- 图论中关于路径、连通性和连通分量的定义。\n- 图上深度优先搜索（DFS）的过程定义，它通过递归访问未访问的邻居来沿着边进行探索，从而构建一个编码了可达性结构的生成森林。\n- 移除一个顶点及其关联边对路径和连通分量的逻辑影响。\n\n输入不从标准输入读取。相反，您必须在程序内部嵌入并处理以下测试套件。每个测试用例由顶点数 $n$ 和一个由无序对 $(u,v)$ 描述的边集 $E$ 指定，其中 $u$ 和 $v$ 是顶点索引。\n\n测试套件：\n- 测试用例 $1$：$n=7$，$E=\\{(0,1),(1,2),(2,3),(1,3),(1,4),(4,5),(5,6)\\}$。该图由顶点 $\\{1,2,3\\}$ 上的一个三角形组成，其中顶点 $1$ 连接到顶点 $0$ 和链 $1-4-5-6$。\n- 测试用例 $2$：$n=5$，$E=\\{(0,1),(1,2),(2,3),(3,4),(4,0)\\}$。该图是顶点 $\\{0,1,2,3,4\\}$ 上的一个单圈。\n- 测试用例 $3$：$n=6$，$E=\\{(0,1),(0,2),(0,3),(0,4),(0,5)\\}$。该图是一个以顶点 $0$ 为中心，叶节点为 $\\{1,2,3,4,5\\}$ 的星形图。\n- 测试用例 $4$：$n=1$，$E=\\varnothing$。该图只有一个顶点，没有边。\n- 测试用例 $5$：$n=2$，$E=\\{(0,1)\\}$。该图是连接两个顶点的一条边。\n- 测试用例 $6$：$n=6$，$E=\\{(0,1),(1,2),(2,0),(3,4),(4,5)\\}$。该图有两个连通分量：一个在顶点 $\\{0,1,2\\}$ 上的三角形和一个路径 $3-4-5$。\n\n输出规范：\n- 对于每个测试用例，计算所有关节点的列表，形式为升序排列的整数列表。\n- 您的程序应生成单行输出，其中包含所有测试用例的结果。结果是一个用方括号括起来的逗号分隔列表，每个测试用例的结果本身也是一个用方括号括起来的逗号分隔整数列表。例如，整体输出必须具有 $[r_1,r_2,\\dots,r_k]$ 的形式，其中每个 $r_i$ 是一个类似 $[v_1,v_2,\\dots]$ 的列表。如果一个测试用例没有关节点，则为该用例输出空列表 $[]$。",
            "solution": "在无向图中识别关节点（或称割点）的问题是深度优先搜索（DFS）的一个经典应用。关节点是指移除该点后图中连通分量数量会增加的顶点。这里介绍的解决方案基于一种成熟的线性时间算法，该算法通常归功于 John Hopcroft 和 Robert Tarjan。\n\n其核心思想是对图进行一次从任意顶点开始的深度优先搜索（DFS）遍历。在遍历过程中，我们为每个顶点 $u$ 维护两个关键信息：\n1. 发现时间 $disc[u]$，这是一个时间戳，记录顶点 $u$ 在 DFS 期间首次被访问的时间。时间戳由一个全局计数器提供，每当访问一个新顶点时，该计数器就会递增。\n2. 低链接值 $low[u]$，这是从 $u$（包括 $u$ 自身）出发，通过遍历零条或多条 DFS 树的边和最多一条回边，可以到达的节点的最低发现时间（即遍历中“最早”的顶点）。回边是连接一个顶点到其在 DFS 树中某个祖先的边。\n\n这两个值使我们能够检测到决定关节点存在的结构。设图为 $G=(V, E)$，其中 $|V|=n$ 个顶点，标记为 $0, 1, \\dots, n-1$。\n\n算法流程如下：\n\n首先，我们初始化数据结构：\n- 图 $G$ 的邻接表表示。\n- 一个大小为 $n$ 的数组 `disc`，初始化为一个哨兵值（例如 $-1$），表示所有顶点都尚未被发现。\n- 一个大小为 $n$ 的数组 `low`，同样初始化为 $-1$。\n- 一个大小为 $n$ 的数组 `parent`，初始化为 $-1$，用于存储 DFS 树中每个顶点的父节点。\n- 一个全局时间计数器，初始化为 $0$。\n- 一个集合，用于存储已识别的关节点，以避免重复。\n\n算法的主要部分是一个递归的 DFS 函数，我们称之为 `FindAPs(u, p)`，它从顶点 $u$ 开始探索图，其在 DFS 树中的父节点为 $p$。\n\n当 `FindAPs(u, p)` 被调用时：\n1. 我们将顶点 $u$ 标记为已发现，方法是将其发现时间和低链接值都设置为当前全局时间计数器的值，然后递增计数器。\n$$disc[u] \\leftarrow \\text{time}$$\n$$low[u] \\leftarrow \\text{time}$$\n$$\\text{time} \\leftarrow \\text{time} + 1$$\n2. 我们将 $u$ 的父节点设置为 $p$：`parent[u] = p`。\n3. 我们还为顶点 $u$ 初始化一个计数器 `children` 为 $0$。该计数器用于跟踪 $u$ 在 DFS 树中的直接子节点数量。\n4. 我们遍历邻接表中 $u$ 的每个邻居 $v$。\n    - 如果 $v$ 是 $u$ 的父节点（即 $v = p$），我们忽略它，继续处理下一个邻居。\n    - 如果 $v$ 已经被发现（即 $disc[v] \\neq -1$），则边 $(u, v)$ 是一条回边。这条边提供了一条从 $u$ 到某个祖先（或已访问节点）$v$ 的路径。我们更新 $u$ 的低链接值，以反映这条可能通往图更早部分的捷径：\n    $$low[u] \\leftarrow \\min(low[u], disc[v])$$\n    - 如果 $v$ 尚未被发现，则边 $(u, v)$ 是一条树边。这意味着 $v$ 是 $u$ 在 DFS 树中的一个新子节点。\n        a. 我们为 $u$ 的 `children` 计数器加一。\n        b. 我们进行递归调用：`FindAPs(v, u)`。\n        c. 递归调用返回后，以 $v$ 为根的整个子树都已被探索。`low[v]` 的值现在是可从 $v$ 到达的最低发现时间。我们用它来更新 $u$ 的低链接值，因为 $u$ 可以到达 $v$ 能到达的所有地方：\n        $$low[u] \\leftarrow \\min(low[u], low[v])$$\n        d. 现在，我们执行关键检查，以确定 $u$ 是否为关节点。此检查分为两种不同的情况。\n\n关节点的条件如下：\n\n**条件 1：DFS 树的根节点**\n如果一个顶点 $u$ 的父节点 `p` 是哨兵值（例如 $-1$），则 $u$ 是 DFS 树的根。DFS 树的根是关节点的充要条件是它在 DFS 树中有超过一个子节点。如果根有两个或更多子节点，移除根将导致以这些子节点为根的子树分离成不同的连通分量。这个检查在对根的所有邻居的循环结束后，使用 `children` 计数器进行。如果 `p = -1` 且 `children > 1`，则 $u$ 是一个关节点。\n\n**条件 2：非根顶点**\n一个不是 DFS 树根的顶点 $u$（即 $p \\neq -1$）是关节点的条件是，它在 DFS 树中至少有一个子节点 $v$，使得以 $v$ 为根的整个子树（包括 $v$ 自身）没有任何回边能连接到 $u$ 的任何祖先。这个条件成立的充要条件是，从 $v$ 可达的最低发现时间（即 `low[v]`）大于或等于 $u$ 的发现时间。\n$$low[v] \\ge disc[u]$$\n如果这个不等式成立，意味着没有从 $v$ 的子树回到图“上层”部分且绕过 $u$ 的路径。因此，移除 $u$ 将会使 $v$ 的子树与图的其余部分断开连接。这个检查在对 $u$ 的每个子节点 $v$ 的循环内部，紧接在递归调用 `FindAPs(v, u)` 返回后进行。\n\n为了处理可能非连通的图，主过程会遍历从 $0$ 到 $n-1$ 的所有顶点。如果一个顶点 $i$ 尚未被发现（`disc[i] = -1`），就从 $i$ 开始发起一次新的 DFS 遍历，通过调用 `FindAPs(i, -1)`。这确保了图的所有连通分量都被处理。\n\n该算法的总体时间复杂度为 $O(n+m)$，其中 $n$ 是顶点数，$m$ 是边数，因为它是基于对整个图的单次 DFS 遍历。空间复杂度也是 $O(n+m)$，用于存储图和相关的数组。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass ArticulationPointFinder:\n    \"\"\"\n    A class to find all articulation points in an undirected graph using DFS.\n    \"\"\"\n    def __init__(self, n, edges):\n        self.n = n\n        self.graph = [[] for _ in range(n)]\n        for u, v in edges:\n            self.graph[u].append(v)\n            self.graph[v].append(u)\n        \n        self.disc = [-1] * n\n        self.low = [-1] * n\n        self.parent = [-1] * n\n        self.articulation_points = set()\n        self.time = 0\n\n    def _find_aps_util(self, u):\n        \"\"\"\n        A recursive DFS utility function to find articulation points.\n        \"\"\"\n        self.disc[u] = self.low[u] = self.time\n        self.time += 1\n        children = 0\n\n        for v in self.graph[u]:\n            if v == self.parent[u]:\n                continue\n            \n            if self.disc[v] != -1:  # v is a visited vertex (back edge)\n                self.low[u] = min(self.low[u], self.disc[v])\n            else:  # v is an unvisited vertex (tree edge)\n                children += 1\n                self.parent[v] = u\n                self._find_aps_util(v)\n                \n                # After the DFS subtree rooted at v returns, update low of u\n                self.low[u] = min(self.low[u], self.low[v])\n                \n                # Condition 1: u is the root of DFS tree and has more than one child.\n                if self.parent[u] == -1 and children > 1:\n                    self.articulation_points.add(u)\n                \n                # Condition 2: u is not root and low value of one of its children is >= its discovery time.\n                if self.parent[u] != -1 and self.low[v] >= self.disc[u]:\n                    self.articulation_points.add(u)\n\n    def find_all(self):\n        \"\"\"\n        Finds all articulation points in the graph. Handles disconnected graphs.\n        \"\"\"\n        if self.n == 1:\n            return []\n\n        for i in range(self.n):\n            if self.disc[i] == -1:\n                self._find_aps_util(i)\n                \n        return sorted(list(self.articulation_points))\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        (7, [(0, 1), (1, 2), (2, 3), (1, 3), (1, 4), (4, 5), (5, 6)]),\n        # Test case 2\n        (5, [(0, 1), (1, 2), (2, 3), (3, 4), (4, 0)]),\n        # Test case 3\n        (6, [(0, 1), (0, 2), (0, 3), (0, 4), (0, 5)]),\n        # Test case 4\n        (1, []),\n        # Test case 5\n        (2, [(0, 1)]),\n        # Test case 6\n        (6, [(0, 1), (1, 2), (2, 0), (3, 4), (4, 5)]),\n    ]\n\n    results = []\n    for n, edges in test_cases:\n        finder = ArticulationPointFinder(n, edges)\n        aps = finder.find_all()\n        results.append(aps)\n\n    # Format output according to specification\n    output_str = \"[\" + \",\".join(map(str, results)) + \"]\"\n    # Fix spacing for empty lists and single-element lists\n    output_str = output_str.replace(\" \", \"\")\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "识别网络中的脆弱点仅仅是第一步，更重要的任务是如何加固它们。这个高级练习  将挑战你解决一个实际的优化问题：如何通过添加最少的边来消除图中所有的割点，从而使整个网络变得双连通。这个问题不仅巩固了你对割点和双连通分量的理解，还展示了这些概念在网络设计和增强鲁棒性方面的实际应用价值。",
            "id": "3209569",
            "problem": "设 $G=(V,E)$ 是一个有限、简单、无向的连通图，其中 $|V|=n$ 且 $|E|=m$，$n \\ge 3$。如果移除一个顶点 $v \\in V$（以及所有与之关联的边）会增加图的连通分量数量，则该顶点 $v$ 是一个关节点。如果一个图是连通的且没有关节点，则该图是双连通的（或称二-顶点-连通的）。你需要编写一个完整、可运行的程序，对提供的测试套件中的每个图，计算为了使图成为双连通图，在当前不相邻的不同顶点之间必须添加的最少边数，且不能产生平行边或自环。\n\n你的程序必须基于第一性原理构建答案，使用关节点和双连通分量的核心定义，以及诸如深度优先搜索（DFS）树结构和low-link值的存在性等经过充分检验的算法事实。程序不得依赖于预设的快捷公式；相反，它必须识别关节点和双连通分量，分析由这些分量和关节点导出的块-割点树，并推导出需要添加的最少边数。\n\n测试套件包含 $6$ 个连通图，每个图都由其顶点数 $n$ 和边集 $E$ 指定（所有顶点均用从 $0$ 到 $n-1$ 的整数标记）：\n\n- 测试用例1：$n=5$，$E=\\{(0,1),(1,2),(2,3),(3,4),(4,0)\\}$（一个包含5个顶点的环）。\n- 测试用例2：$n=4$，$E=\\{(0,1),(1,2),(2,3)\\}$（一个包含4个顶点的路径）。\n- 测试用例3：$n=7$，$E=\\{(0,1),(0,2),(0,3),(0,4),(0,5),(0,6)\\}$（一个以0为中心、有6个叶节点的星形图）。\n- 测试用例4：$n=5$，$E=\\{(0,1),(1,2),(2,0),(2,3),(3,4),(4,2)\\}$（两个共享一个顶点的三角形）。\n- 测试用例5：$n=6$，$E=\\{(0,1),(1,2),(2,3),(3,0),(1,4),(4,5)\\}$（一个环，其中一个环顶点上连接了一条长度为2的尾巴）。\n- 测试用例6：$n=6$，$E=\\{(0,1),(1,2),(1,3),(3,4),(3,5)\\}$（一棵树，其内部顶点为1和3）。\n\n你的程序应生成单行输出，其中按顺序包含六个测试用例的结果，格式为一个由方括号括起来的逗号分隔列表，例如 $[r_1,r_2,r_3,r_4,r_5,r_6]$，其中每个 $r_i$ 是一个整数，表示测试用例 $i$ 所需添加的最少边数。",
            "solution": "该问题已经过验证，被认为是图论领域中一个定义明确、具有科学依据的问题。所给条件是完备、一致且可形式化的。\n\n### 基于原理的解决方案设计\n\n核心任务是确定为使一个连通图 $G$ 成为双连通图所需添加的最少边数。一个图是双连通的，当且仅当它是连通的并且不包含任何关节点。关节点（或称割点）是指移除后会增加图的连通分量数量的顶点。\n\n#### 1. 块-割点树结构\n\n这个问题可以通过分析图的结构来解决，即从其双连通分量（BCCs或块）和关节点的角度进行分析。这些实体之间的关系可以通过一个 **块-割点树** $T_{BC}$ 来建模。\n- $T_{BC}$ 的顶点对应于原始图 $G$ 的关节点和双连通分量。\n- 在 $T_{BC}$ 中，一个关节点顶点 $v_{ap}$ 和一个块顶点 $B$ 之间存在一条边，当且仅当与 $v_{ap}$ 对应的顶点是图 $G$ 中块 $B$ 的一个成员。\n- 对于任何连通图 $G$，其对应的块-割点结构 $T_{BC}$ 是一棵树。\n\n将原始图 $G$ 变为双连通图，等价于将其块-割点树 $T_{BC}$ 转换为一个单一节点。当所有原始的双连通分量和关节点合并成一个单一的、大的双连通分量时，这种概念上的转换就发生了。\n\n#### 2. 策略：连接叶子块\n\n图连通性的“薄弱点”在于其“悬挂”的分量。在块-割点树中，这些薄弱点由叶节点表示。由于树中的任何路径都必须连接两个叶节点（或者本身就是一个节点），因此 $T_{BC}$ 中的叶节点总是块顶点（假设该树不是平凡的）。如果一个块 $B$ 在 $T_{BC}$ 中是叶子，那么它在图 $G$ 中只包含一个关节点。我们称之为 **叶子块**。\n\n为了消除关节点，我们必须在被它们分隔开的图的各个部分之间引入新的路径。最有效的方法是在不同的叶子块的顶点之间添加边。在一个叶子块 $B_1$ 中的一个顶点和另一个叶子块 $B_2$ 中的一个顶点之间添加一条边，会在图 $G$ 中创建一个新的环。这会产生一个效果，即在 $T_{BC}$ 中，将 $B_1$、$B_2$ 以及它们之间的整个块和关节点路径合并成一个更大的单一双连通分量。\n\n这个操作有效地减少了概念上的块-割点树中叶子的数量。如果我们有 $l$ 个叶子块，我们可以将它们配对。每对之间添加一条边会使叶子数量减少两个。将所有 $l$ 个叶子连接成一个超分量所需的最少边数为 $\\lceil l/2 \\rceil$。\n\n- 如果图已经是双连通的，它就由单个块组成，没有关节点。在这种情况下，叶子块的数量为 $l=0$，公式正确地得出 $\\lceil 0/2 \\rceil = 0$。\n- 如果图不是双连通的，它必须至少有一个关节点，因此至少有两个叶子块 ($l \\ge 2$) 。\n\n#### 3. 算法实现\n\n总体算法如下：\n\n**步骤1：寻找关节点和双连通分量**\n这是算法的核心部分，通过一次深度优先搜索（DFS）遍历来执行。对于每个顶点 $u \\in V$，我们维护两个值：\n- $disc[u]$：在DFS期间 $u$ 的发现时间，即首次访问 $u$ 时的“时间”（一个计数器）。\n- $low[u]$：从 $u$ 出发（包括通过其自身的DFS子树），通过遍历零条或多条树边和最多一条回边，可以到达的最低发现时间。\n\n使用一个边栈来跟踪双连通分量的边。在从顶点 $u$ 到其邻居 $v$ 的DFS过程中：\n- 如果顶点 $u$ 是DFS树的根且拥有多个子节点，或者它不是根但有一个子节点 $v$ 满足 $low[v] \\ge disc[u]$，则 $u$ 被识别为关节点。\n- 同样的条件 $low[v] \\ge disc[u]$ 也标志着一个双连通分量刚刚被完全遍历。这个双连通分量的边位于边栈的顶部，可以被弹出，直到边 $(u,v)$ 被移除。这些被弹出的边所包含的所有顶点集合构成了该双连通分量。\n\n**步骤2：计算叶子块数量**\n在DFS完成并且所有关节点和双连通分量都已识别出来之后，我们计算叶子块的数量 $l$。如果一个双连通分量中恰好只有一个顶点是主图的关节点，那么它就是一个叶子块。\n\n**步骤3：计算最少边数**\n需要添加的最少边数由公式 $\\lceil l / 2 \\rceil$ 给出。这可以使用整数算术计算为 $(l + 1) // 2$。如果图已经是双连通的，算法将只找到一个双连通分量而没有关节点，从而得出 $l=0$ 和答案 $0$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the biconnectivity augmentation problem for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        # Test case 1: n=5, a cycle graph\n        (5, [(0, 1), (1, 2), (2, 3), (3, 4), (4, 0)]),\n        # Test case 2: n=4, a path graph\n        (4, [(0, 1), (1, 2), (2, 3)]),\n        # Test case 3: n=7, a star graph\n        (7, [(0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (0, 6)]),\n        # Test case 4: n=5, two triangles sharing a vertex\n        (5, [(0, 1), (1, 2), (2, 0), (2, 3), (3, 4), (4, 2)]),\n        # Test case 5: n=6, a cycle with a tail\n        (6, [(0, 1), (1, 2), (2, 3), (3, 0), (1, 4), (4, 5)]),\n        # Test case 6: n=6, a tree\n        (6, [(0, 1), (1, 2), (1, 3), (3, 4), (3, 5)]),\n    ]\n\n    results = []\n    for n, edges in test_cases:\n        solver = BiconnectivityAugmenter(n, edges)\n        result = solver.compute_min_edges()\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nclass BiconnectivityAugmenter:\n    \"\"\"\n    A class to find the minimum number of edges to make a graph biconnected.\n    \"\"\"\n    def __init__(self, n, edges):\n        self.n = n\n        self.adj = [[] for _ in range(n)]\n        for u, v in edges:\n            self.adj[u].append(v)\n            self.adj[v].append(u)\n        \n        # State for the BCC algorithm\n        self.time = 0\n        self.disc = [-1] * n\n        self.low = [-1] * n\n        self.edge_stack = []\n        \n        self.articulation_points = set()\n        self.bccs = []\n\n    def _find_aps_and_bccs(self, u, p):\n        \"\"\"\n        Recursive DFS utility to find articulation points and biconnected components.\n        'u' is the current vertex, 'p' is its parent in the DFS tree.\n        \"\"\"\n        self.disc[u] = self.low[u] = self.time\n        self.time += 1\n        children = 0\n\n        for v in self.adj[u]:\n            if v == p:\n                continue\n\n            if self.disc[v] != -1:  # Visited vertex, so a back edge\n                self.low[u] = min(self.low[u], self.disc[v])\n                if self.disc[v]  self.disc[u]:\n                    self.edge_stack.append((u, v))\n            else:  # Not visited, so a tree edge\n                children += 1\n                self.edge_stack.append((u, v))\n                self._find_aps_and_bccs(v, u)\n                \n                self.low[u] = min(self.low[u], self.low[v])\n\n                # Check for articulation point u\n                if (p == -1 and children > 1) or (p != -1 and self.low[v] >= self.disc[u]):\n                    self.articulation_points.add(u)\n                \n                # If low[v] >= disc[u], u is an AP and a new BCC is found\n                if self.low[v] >= self.disc[u]:\n                    new_bcc_edges = []\n                    while True:\n                        edge = self.edge_stack.pop()\n                        new_bcc_edges.append(edge)\n                        if edge == (u, v) or edge == (v, u):\n                            break\n                    \n                    bcc_nodes = set()\n                    for n1, n2 in new_bcc_edges:\n                        bcc_nodes.add(n1)\n                        bcc_nodes.add(n2)\n                    self.bccs.append(bcc_nodes)\n\n    def compute_min_edges(self):\n        \"\"\"\n        Computes the minimum number of edges to add to make the graph biconnected.\n        \"\"\"\n        # A connected graph with n  3 is always biconnected.\n        if self.n  3:\n            return 0\n            \n        # Run DFS from vertex 0. The graph is connected, so one run is sufficient.\n        self._find_aps_and_bccs(0, -1)\n\n        # If the whole graph is one BCC, the stack will not be empty.\n        if self.edge_stack:\n            bcc_nodes = set()\n            for u, v in self.edge_stack:\n                bcc_nodes.add(u)\n                bcc_nodes.add(v)\n            self.bccs.append(bcc_nodes)\n            self.edge_stack.clear()\n        \n        # If there are no articulation points, the graph is already biconnected.\n        # This is equivalent to having 0 or 1 BCCs.\n        if len(self.bccs) = 1:\n            return 0\n\n        # Count leaf blocks: BCCs with exactly one articulation point.\n        leaf_blocks = 0\n        for bcc in self.bccs:\n            ap_count_in_bcc = 0\n            for node in bcc:\n                if node in self.articulation_points:\n                    ap_count_in_bcc += 1\n            if ap_count_in_bcc == 1:\n                leaf_blocks += 1\n        \n        # The number of edges to add is ceil(number of leaf blocks / 2).\n        return int(np.ceil(leaf_blocks / 2))\n\nif __name__ == \"__main__\":\n    solve()\n\n```"
        }
    ]
}