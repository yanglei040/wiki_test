## 引言
在图论的世界里，计算网络中所有节点对之间的最短路径（All-Pairs Shortest Paths, APSP）是一个基础且重要的问题。当图是稀疏的且边权重可能为负时，这一挑战变得尤为棘手。经典的 Dijkstra 算法无法处理[负权边](@entry_id:635620)，而为每个节点运行能够处理[负权边](@entry_id:635620)的 [Bellman-Ford](@entry_id:634399) 算法则效率过低，无法满足实际需求。那么，是否存在一种既能正确处理[负权边](@entry_id:635620)，又能在[稀疏图](@entry_id:261439)上保持高效的解决方案呢？

Johnson 算法正是为了填补这一空白而设计的精妙方法。它并非直接在负[权图](@entry_id:204634)上进行计算，而是通过一个巧妙的预处理步骤，将整个图的权重体系进行“重塑”，从而为高效算法的应用铺平道路。本文将带领读者深入探索 Johnson 算法的奥秘。在“原理与机制”章节中，我们将剖析其核心的重赋权思想，理解势函数如何构建以及[负权环](@entry_id:633892)是如何被检测的。接着，在“应用与跨学科联系”章节，我们将看到该算法如何从抽象理论走向现实世界，解决从[金融风险](@entry_id:138097)分析到生物路径发现等多样化问题。最后，通过“动手实践”部分，您将有机会将理论付诸实践，亲手构建并扩展这一强大的算法。

## 原理与机制

### 核心思想：重赋权

在含有[负权边](@entry_id:635620)的图上计算所有结点对之间的[最短路径](@entry_id:157568)（All-Pairs Shortest Paths, APSP）是一个经典问题。一个直接的想法是从每个顶点出发，运行一次[单源最短路径](@entry_id:636497)（Single-Source Shortest Path, SSSP）算法。然而，经典的 Dijkstra 算法在遇到[负权边](@entry_id:635620)时可能会失效，而对于[稀疏图](@entry_id:261439)，从每个顶点运行 [Bellman-Ford](@entry_id:634399) 算法的复杂度（$O(n^2 m)$）又过高。

Johnson 算法通过一种名为 **重赋权 (reweighting)** 的精妙技术，优雅地解决了这个问题。其核心思想并非直接处理[负权边](@entry_id:635620)，而是通过一个预处理步骤，将原图“改造”成一个与之等价且不含[负权边](@entry_id:635620)的新图。这样一来，我们就可以在改造后的图上放心地、高效地从每个顶点运行 Dijkstra 算法。

为了实现这一目标，我们为每个顶点 $v$ 引入一个实数值，称之为 **势 (potential)**，并用函数 $h: V \to \mathbb{R}$ 来表示。基于此[势函数](@entry_id:176105)，我们将图中每条边 $(u, v)$ 的原始权重 $w(u, v)$ 转换为一个新的权重 $w'(u, v)$，其转换规则如下：

$$w'(u, v) = w(u, v) + h(u) - h(v)$$

这个简单的公式蕴含着深刻的性质。让我们考察任意一条从起点 $s$ 到终点 $t$ 的路径 $p = \langle v_0, v_1, \dots, v_k \rangle$，其中 $v_0 = s$ 且 $v_k = t$。该路径在原图中的长度为 $w(p) = \sum_{i=1}^{k} w(v_{i-1}, v_i)$。在重赋权后，其新长度 $w'(p)$ 变为：

$$w'(p) = \sum_{i=1}^{k} w'(v_{i-1}, v_i) = \sum_{i=1}^{k} (w(v_{i-1}, v_i) + h(v_{i-1}) - h(v_i))$$

将求和式展开并重新组合，我们得到：

$$w'(p) = \left( \sum_{i=1}^{k} w(v_{i-1}, v_i) \right) + (h(v_0) - h(v_1)) + (h(v_1) - h(v_2)) + \dots + (h(v_{k-1}) - h(v_k))$$

可以发现，中间的 $h(v)$ 项形成了一个 **伸缩和 (telescoping sum)**，除了首项 $h(v_0)$ 和末项 $h(v_k)$ 外，所有中间项都相互抵消了。因此，上式可以简化为：

$$w'(p) = w(p) + h(v_0) - h(v_k) = w(p) + h(s) - h(t)$$

这个结果至关重要。它表明，对于连接同一对起点 $s$ 和终点 $t$ 的 **所有** 路径，其权重值的变化量都是一个固定的常数 $h(s) - h(t)$。这意味着路径之间的相对长度关系在重赋权后保持不变。如果路径 $p_1$ 在原图中比路径 $p_2$ 短，那么在重赋权后 $p_1$ 依然比 $p_2$ 短。因此，原[图中的最短路径](@entry_id:267725)在新图中仍然是[最短路径](@entry_id:157568)。

这一性质保证了我们可以在重赋权后的图上寻找最短路径，然后通过简单的代数运算恢复出原始的最短路径长度。具体来说，若 $\delta'(u, v)$ 是在新图中使用 $w'$ 计算出的最短路径长度，那么原始[图中的最短路径](@entry_id:267725)长度 $\delta(u, v)$ 可以通过以下公式恢复 ：

$$\delta(u, v) = \delta'(u, v) - h(u) + h(v)$$

这个重赋权机制是 Johnson 算法的基石。然而，我们还有一个关键问题尚未解决：我们应该如何选择势函数 $h$，才能保证所有新的边权重 $w'(u, v)$ 都是非负的呢？

### 势函数的构建与非负性保证

重赋权的目的是为了能够使用 Dijkstra 算法，其前提是所有边权重非负。因此，我们选择的[势函数](@entry_id:176105) $h$ 必须满足以下条件：
对于图中任意边 $(u, v) \in E$，都有 $w'(u, v) \ge 0$。
代入重赋权公式，即：

$$w(u, v) + h(u) - h(v) \ge 0$$

移项后，我们得到一个更直观的不等式：

$$h(v) \le h(u) + w(u, v)$$

这个不等式被称为 **三角不等式 (triangle inequality)**，它构成了对一个“合法”势函数 $h$ 的唯一要求 。任何满足此条件的函数 $h$ 都可以成功地将图重赋权为没有[负权边](@entry_id:635620)的图，而无需关心 $h$ 本身的值是正是负，或是如何得到的。

那么，如何系统地找到一个满足条件的[势函数](@entry_id:176105) $h$ 呢？上述不等式的形式与[最短路径](@entry_id:157568)的性质惊人地相似。对于图中任意三点 $s, u, v$，从 $s$ 到 $v$ 的最短路径长度一定不大于先从 $s$ 走到 $u$ 再沿边 $(u,v)$ 到达 $v$ 的路径长度，即 $\delta(s, v) \le \delta(s, u) + w(u, v)$。

这启发我们利用[最短路径](@entry_id:157568)来构建[势函数](@entry_id:176105) $h$。具体方法如下：
1.  构建一个辅助图 $G'$：在原图 $G$ 的基础上，增加一个全新的源顶点 $s_0$。
2.  从 $s_0$ 向原图中的 **每一个** 顶点 $v \in V$ 添加一条权重为 $0$ 的有向边 $(s_0, v)$。
3.  我们将势函数 $h(v)$ 定义为在这个辅助图 $G'$ 中，从新源点 $s_0$ 到顶点 $v$ 的最短路径长度，即 $h(v) = \delta_{G'}(s_0, v)$。

由于 $h(v)$ 是[最短路径](@entry_id:157568)长度，它天然满足[三角不等式](@entry_id:143750)。对于原图中的任意一条边 $(u, v) \in E$，这条边同样存在于 $G'$ 中。因此，$\delta_{G'}(s_0, v) \le \delta_{G'}(s_0, u) + w(u, v)$ 必然成立，即 $h(v) \le h(u) + w(u, v)$。这就保证了所有重赋权后的边权重 $w'(u, v)$ 均大于等于零。

这里，引入新顶点 $s_0$ 的设计至关重要。如果我们随意选择原图中的一个现有顶点 $r$ 作为源点来计算[势函数](@entry_id:176105)，只有当 $r$ 能够到达图中所有其他顶点时，这个方法才有效。如果图中存在 $r$ 无法到达的顶点，它们的势将被计算为无穷大，导致重赋权公式失效 。而新顶点 $s_0$ 通过权重为 $0$ 的边与所有原始顶点相连，巧妙地保证了所有顶点的势都是有定义的、有限的值（除非图中存在[负权环](@entry_id:633892)，我们稍后会讨论）。

### [负权环](@entry_id:633892)的处理

上述构造势函数的方法有一个前提：辅助图 $G'$ 中从 $s_0$ 出发的[最短路径](@entry_id:157568)必须是明确定义的。由于原图 $G$ 可能包含[负权边](@entry_id:635620)，辅助图 $G'$ 也同样包含。因此，在计算 $h(v) = \delta_{G'}(s_0, v)$ 时，我们不能使用 Dijkstra 算法，而必须使用能够处理[负权边](@entry_id:635620)的算法，例如 **[Bellman-Ford](@entry_id:634399) 算法**。

运行 [Bellman-Ford](@entry_id:634399) 算法会产生两种可能的结果：

1.  **算法成功收敛**：如果在 $|V'|-1$（即 $|V|$）轮迭代后，所有顶点的距离估计值都稳定下来，说明 $G'$ 中不存在从 $s_0$ 可达的[负权环](@entry_id:633892)。由于 $s_0$ 可以到达所有原始顶点，这也意味着原图 $G$ 中不存在任何[负权环](@entry_id:633892) 。在这种情况下，我们成功地计算出了一组有效的势 $h(v)$，可以进行后续的重赋权。

2.  **算法检测到[负权环](@entry_id:633892)**：如果在第 $|V'|$ 轮迭代中，某个顶点的距离估计值仍然可以被减小，那么 [Bellman-Ford](@entry_id:634399) 算法就能断定图中存在[负权环](@entry_id:633892)。当[负权环](@entry_id:633892)存在时，环上以及从环可达的顶点的[最短路径](@entry_id:157568)长度为 $-\infty$，[最短路径问题](@entry_id:273176)本身变得无解。

具体而言，当图中存在一个[负权环](@entry_id:633892) $C$ 时，对于任意一对顶点 $(u, v)$，其[最短路径](@entry_id:157568)长度 $\delta(u, v)$ 为 $-\infty$ 的充要条件是：从 $u$ 出发存在一条路径可以到达环 $C$ 上的某个顶点，并且从环 $C$ 上的某个顶点出发存在一条路径可以到达 $v$ 。任何不满足此条件的路径，其最短路径长度仍然是有限的（或 $+\infty$）。例如，在一个[无向图](@entry_id:270905)上，如果某条边 $\{u,v\}$ 的原始权重 $w > 0$，我们将其转换为两条有向边 $(u,v)$ 和 $(v,u)$ 并赋予权重 $-w$，那么必然会形成一个权重为 $-2w$ 的[负权环](@entry_id:633892)。此时，任何试图在其上计算最短路径的算法（包括 Johnson 算法）都应报告失败 。

因此，[Bellman-Ford](@entry_id:634399) 算法在 Johnson 算法的第一阶段扮演了双重角色：它不仅是计算[势函数](@entry_id:176105)的工具，同时也是一个“守卫”，负责检验图是否含有[负权环](@entry_id:633892)这一根本性的无解情况。

### Johnson 算法完整流程与分析

综合以上原理，Johnson 算法的完整步骤如下：

1.  **构建辅助图**：创建一个新图 $G'$，它包含原图 $G$ 的所有边，并额外增加一个新源点 $s_0$ 和一组从 $s_0$ 到所有原顶点 $v \in V$ 的权重为 $0$ 的边。

2.  **计算势函数**：在 $G'$ 上，从源点 $s_0$ 运行 [Bellman-Ford](@entry_id:634399) 算法。
    *   如果检测到[负权环](@entry_id:633892)，则[算法终止](@entry_id:143996)，报告图中存在[负权环](@entry_id:633892)，最短路径无解。
    *   否则，将计算出的从 $s_0$ 到各顶点 $v$ 的[最短路径](@entry_id:157568)长度 $\delta_{G'}(s_0, v)$ 赋给 $h(v)$。

3.  **重赋权**：对于原图 $G$ 中的每一条边 $(u, v) \in E$，计算新的非负权重 $w'(u, v) = w(u, v) + h(u) - h(v)$。

4.  **计算所有对[最短路径](@entry_id:157568)**：对原图中的 **每一个** 顶点 $u \in V$，以 $u$ 为源点，在重赋权后的图（使用 $w'$ 权重）上运行 Dijkstra 算法，计算出从 $u$到所有其他顶点 $v$ 的[最短路径](@entry_id:157568)长度 $\delta'(u, v)$。

5.  **恢复原始[最短路径](@entry_id:157568)长度**：对于每一对顶点 $(u, v)$，通过逆向转换公式计算出在原图中的最终[最短路径](@entry_id:157568)长度：$\delta(u, v) = \delta'(u, v) - h(u) + h(v)$。

**[算法复杂度](@entry_id:137716)分析：**
- 第 1 步：$O(n)$ 时间。
- 第 2 步 ([Bellman-Ford](@entry_id:634399))：在含有 $n+1$ 个顶点和 $m+n$ 条边的图上运行，[时间复杂度](@entry_id:145062)为 $O((n+1)(m+n)) = O(nm)$。
- 第 3 步：$O(m)$ 时间。
- 第 4 步 (Dijkstra)：运行 $n$ 次。若使用基于[二叉堆](@entry_id:636601)的[优先队列](@entry_id:263183)，每次 Dijkstra 的[时间复杂度](@entry_id:145062)为 $O(m + n \log n)$。总时间为 $O(n(m + n \log n)) = O(nm + n^2 \log n)$。
- 第 5 步：计算 $n^2$ 对距离，[时间复杂度](@entry_id:145062)为 $O(n^2)$。

对于 **[稀疏图](@entry_id:261439)**（即 $m$ 与 $n$ 的[数量级](@entry_id:264888)相近），总[时间复杂度](@entry_id:145062)由第 4 步主导，为 $O(n^2 \log n)$。这显著优于从每个顶点运行 [Bellman-Ford](@entry_id:634399) 算法的 $O(n^2 m)$（[稀疏图](@entry_id:261439)下为 $O(n^3)$）。

### 深入探讨与特殊情况

**Dijkstra 失效而 Johnson 成功的场景**

Dijkstra 算法的贪心策略是其高效的根源，但也使其在面对[负权边](@entry_id:635620)时显得脆弱。考虑一个最简单的失败场景：图中存在三个顶点 $s, a, t$，以及边 $(s, t)$ 和路径 $s \to a \to t$。假设 $w(s, a) > w(s, t)$，但 $w(a, t)$ 是一个足够大的负数，使得总路径长度 $w(s, a) + w(a, t) < w(s, t)$。Dijkstra 算法从 $s$ 出发，会因 $w(s, t)$ 更小而优先选择并最终确定 $s \to t$ 的路径，从而错过了经由 $a$ 的更短路径。而 Johnson 算法通过重赋权，将 $w'(a, t)$ 提升为非负值，消除了这种“陷阱”，使得后续的 Dijkstra 算法能够正确工作 。

**在非负[权图](@entry_id:204634)上运行 Johnson 算法**

如果一个图本身所有边的权重都已经是-非负的，我们仍然可以运行 Johnson 算法。在这种情况下，第一步构建的辅助图 $G'$ 同样不含[负权边](@entry_id:635620)。从 $s_0$ 出发到任何顶点 $v$ 的[最短路径](@entry_id:157568)就是直接通过权重为 $0$ 的边 $(s_0, v)$。因此，[Bellman-Ford](@entry_id:634399) 算法计算出的所有势 $h(v)$ 都将等于 $0$。其结果是，重赋权后的权重 $w'(u,v)$ 与原始权重 $w(u,v)$ 完全相同。这意味着，后续 $n$ 次 Dijkstra 算法的执行过程，与直接在原图上运行 $n$ 次 Dijkstra 算法完全一致，包括[优先队列](@entry_id:263183)中 `decrease-key` 操作的总次数也完全相等 。这表明 Johnson 算法虽然在这种情况下能得到正确结果，但其第一阶段的 [Bellman-Ford](@entry_id:634399) 计算成了一项不必要的开销。

**[势函数](@entry_id:176105)的唯一性（进阶讨论）**

我们已经知道，任何满足 $h(v) \le h(u) + w(u,v)$ 的函数都是一个合法的[势函数](@entry_id:176105)。那么，这样的函数有多少种呢？如果 $h(v)$ 是一个合法的势函数，那么对于任意常数 $c$， $h'(v) = h(v) + c$ 也是一个合法的[势函数](@entry_id:176105)，因为常数 $c$ 在重赋权公式中会被抵消。一个更深刻的问题是：所有合法的[势函数](@entry_id:176105)是否都只相差一个全局的常数？答案取决于图的结构。当且仅当原图 $G$ 是 **强连通** 的时候，任何两个合法的[势函数](@entry_id:176105) $h_1$ 和 $h_2$ 之间必然存在一个常数 $c$，使得对所有顶点 $v$ 都有 $h_2(v) = h_1(v) + c$。如果图不是强连通的，那么不同的连通分支上的[势函数](@entry_id:176105)可以被不同的常数独立地“平移”。