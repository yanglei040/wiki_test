{
    "hands_on_practices": [
        {
            "introduction": "理论学习之后，最好的检验方式就是亲自动手。这项练习将引导你在一张包含负权边的有向图上，一步步追踪Floyd-Warshall算法的执行过程。通过手动计算距离矩阵和后继矩阵在每次迭代中的变化，你将直观地理解算法的动态规划核心，并亲眼见证它如何发现更短的路径，以及在何时、以何种方式识别出负权环的存在。",
            "id": "3235663",
            "problem": "考虑一个包含 $n=6$ 个顶点（标记为 $1,2,3,4,5,6$）的有向加权图。其加权邻接矩阵 $W$ 如下所示：\n$$\nW \\;=\\;\n\\begin{pmatrix}\n0  3  \\infty  \\infty  \\infty  \\infty\\\\\n\\infty  0  4  2  \\infty  \\infty\\\\\n-10  \\infty  0  5  \\infty  \\infty\\\\\n\\infty  \\infty  \\infty  0  1  \\infty\\\\\n\\infty  \\infty  \\infty  \\infty  0  1\\\\\n\\infty  \\infty  \\infty  1  \\infty  0\n\\end{pmatrix}.\n$$\n假设我们使用一个标准的所有点对最短路径动态规划程序，该程序基于以下基本定义：路径是由有向边连接的顶点序列；路径的权重是其边权重之和；最短路径是在具有相同端点的所有路径中总权重最小的路径。该程序分阶段 $k=0,1,2,\\dots,6$ 进行，维护一个距离矩阵 $D^{(k)}$ 和一个后继矩阵 $\\mathrm{next}^{(k)}$。在阶段 $k$，这两个矩阵共同编码了所有有序点对 $(i,j)$ 的最短路径信息，并遵循一个不变性：在阶段 $k$ 考虑的任何路径的所有内部顶点都必须取自集合 $\\{1,2,\\dots,k\\}$。初始时，$D^{(0)}=W$，并且 $\\mathrm{next}^{(0)}$ 的定义如下：如果 $W[i,j]  \\infty$ 且 $i\\neq j$，则 $\\mathrm{next}^{(0)}[i,j]=j$；对于所有 $i$，$\\mathrm{next}^{(0)}[i,i]=i$；否则 $\\mathrm{next}^{(0)}[i,j]=\\varnothing$。\n\n你的任务是：\n- 仅使用上述基本定义，用你自己的话陈述这个不变性。\n- 写下初始化的 $D^{(0)}$ 和 $\\mathrm{next}^{(0)}$。\n- 对于阶段 $k=1,2,3$，应用符合所述不变性的程序更新策略，生成 $D^{(1)}$, $D^{(2)}$ 和 $D^{(3)}$，并注释在每个阶段发生变化的 $\\mathrm{next}$ 矩阵的条目。通过明确指出其内部顶点位于 $\\{1,2,\\dots,k\\}$ 中的一个严格更短的路径来证明每次更改的合理性。\n- 精确解释某个对角线元素 $d_{ii}^{(k)}$ 何时以及为何会变为负数，并指明在该阶段使其根据不变性成为可接受的特定环路以及内部顶点集合。\n\n回答要求：令 $k^\\star$ 表示 $D^{(k)}$ 的任何对角线元素首次变为负数时的最小阶段索引 $k\\in\\{1,2,\\dots,6\\}$。请以单个整数形式提供 $k^\\star$。无需四舍五入，也无物理单位。你的最终答案必须仅为该整数。",
            "solution": "该问题要求逐步执行 Floyd-Warshall 算法，以找到首次检测到负权环路的特定阶段。\n\n首先，我们来陈述算法的不变性。根据所提供的定义，该程序所维护的不变性是：在阶段 $k$ 结束时，对于任意顶点对 $(i,j)$，条目 $D^{(k)}[i,j]$ 存储的是从顶点 $i$ 到顶点 $j$ 的、其所有内部顶点都包含在集合 $\\{1, 2, \\dots, k\\}$ 中的所有路径的最小权重。\n\n接下来，我们确定算法在阶段 $k=0$ 时的初始状态。距离矩阵 $D^{(0)}$ 是给定的加权邻接矩阵 $W$。后继矩阵 $\\mathrm{next}^{(0)}$ 根据指定规则填充。\n$$ D^{(0)} = W =\n\\begin{pmatrix}\n0  3  \\infty  \\infty  \\infty  \\infty\\\\\n\\infty  0  4  2  \\infty  \\infty\\\\\n-10  \\infty  0  5  \\infty  \\infty\\\\\n\\infty  \\infty  \\infty  0  1  \\infty\\\\\n\\infty  \\infty  \\infty  \\infty  0  1\\\\\n\\infty  \\infty  \\infty  1  \\infty  0\n\\end{pmatrix}\n$$\n$$ \\mathrm{next}^{(0)} =\n\\begin{pmatrix}\n1  2  \\varnothing  \\varnothing  \\varnothing  \\varnothing \\\\\n\\varnothing  2  3  4  \\varnothing  \\varnothing \\\\\n1  \\varnothing  3  4  \\varnothing  \\varnothing \\\\\n\\varnothing  \\varnothing  \\varnothing  4  5  \\varnothing \\\\\n\\varnothing  \\varnothing  \\varnothing  \\varnothing  5  6 \\\\\n\\varnothing  \\varnothing  \\varnothing  4  \\varnothing  6\n\\end{pmatrix}\n$$\n动态规划程序的更新规则是 $D^{(k)}[i,j] = \\min(D^{(k-1)}[i,j], D^{(k-1)}[i,k] + D^{(k-1)}[k,j])$。如果发生更新，则后继者设置为 $\\mathrm{next}^{(k)}[i,j] = \\mathrm{next}^{(k-1)}[i,k]$。\n\n阶段 $k=1$：我们考虑以顶点 $1$ 为内部顶点的路径。\n进入顶点 $1$ 的唯一边来自顶点 $3$，权重为 $D^{(0)}[3,1] = -10$。离开顶点 $1$ 的唯一边是到顶点 $2$，权重为 $D^{(0)}[1,2] = 3$。这使得可能存在一条从 $3$ 经由 $1$ 到 $2$ 的新路径。\n- 对于点对 $(3,2)$：我们计算 $D^{(0)}[3,1] + D^{(0)}[1,2] = -10 + 3 = -7$。这小于当前距离 $D^{(0)}[3,2] = \\infty$。\n- 理由：找到了一条新的、严格更短的路径 $3\\to1\\to2$。其总权重为 $-7$。其内部顶点是 $\\{1\\}$，这与阶段 $k=1$ 的不变性一致。\n- 更新：$D^{(1)}[3,2] = -7$。\n- 后继矩阵更新：$\\mathrm{next}^{(1)}[3,2] = \\mathrm{next}^{(0)}[3,1] = 1$。\n没有其他路径被改善。阶段 $k=1$ 的距离矩阵是：\n$$ D^{(1)} =\n\\begin{pmatrix}\n0  3  \\infty  \\infty  \\infty  \\infty\\\\\n\\infty  0  4  2  \\infty  \\infty\\\\\n-10  -7  0  5  \\infty  \\infty\\\\\n\\infty  \\infty  \\infty  0  1  \\infty\\\\\n\\infty  \\infty  \\infty  \\infty  0  1\\\\\n\\infty  \\infty  \\infty  1  \\infty  0\n\\end{pmatrix}\n$$\n\n阶段 $k=2$：我们考虑内部顶点来自 $\\{1, 2\\}$ 的路径。枢轴顶点是 $2$。我们检查形如 $i \\to \\dots \\to 2 \\to \\dots \\to j$ 的路径。\n- 对于 $(1,3)$：$D^{(1)}[1,2] + D^{(1)}[2,3] = 3 + 4 = 7$。当前 $D^{(1)}[1,3]=\\infty$。\n  - 理由：路径 $1\\to2\\to3$ 的权重为 $7$。内部顶点为 $\\{2\\} \\subseteq \\{1,2\\}$。\n  - 更新：$D^{(2)}[1,3] = 7$。$\\mathrm{next}^{(2)}[1,3] = \\mathrm{next}^{(1)}[1,2] = 2$。\n- 对于 $(1,4)$：$D^{(1)}[1,2] + D^{(1)}[2,4] = 3 + 2 = 5$。当前 $D^{(1)}[1,4]=\\infty$。\n  - 理由：路径 $1\\to2\\to4$ 的权重为 $5$。内部顶点为 $\\{2\\} \\subseteq \\{1,2\\}$。\n  - 更新：$D^{(2)}[1,4] = 5$。$\\mathrm{next}^{(2)}[1,4] = \\mathrm{next}^{(1)}[1,2] = 2$。\n- 对于 $(3,3)$：$D^{(1)}[3,2] + D^{(1)}[2,3] = -7 + 4 = -3$。当前 $D^{(1)}[3,3]=0$。\n  - 理由：从 $3$ 到 $2$ 的路径是 $3\\to1\\to2$（权重 $-7$）。从 $2$ 到 $3$ 的路径是直接的（权重 $4$）。连接起来得到环路 $3\\to1\\to2\\to3$，权重为 $-3$。内部顶点集合是 $\\{1,2\\}$，这正是阶段 $k=2$ 所允许的集合。\n  - 更新：$D^{(2)}[3,3] = -3$。$\\mathrm{next}^{(2)}[3,3] = \\mathrm{next}^{(1)}[3,2] = 1$。这是第一个负的对角线元素。\n- 对于 $(3,4)$：$D^{(1)}[3,2] + D^{(1)}[2,4] = -7 + 2 = -5$。当前 $D^{(1)}[3,4]=5$。\n  - 理由：路径 $3\\to1\\to2\\to4$ 的权重为 $-5$。内部顶点为 $\\{1,2\\}$。\n  - 更新：$D^{(2)}[3,4] = -5$。$\\mathrm{next}^{(2)}[3,4] = \\mathrm{next}^{(1)}[3,2] = 1$。\n阶段 $k=2$ 的距离矩阵是：\n$$ D^{(2)} =\n\\begin{pmatrix}\n0  3  7  5  \\infty  \\infty\\\\\n\\infty  0  4  2  \\infty  \\infty\\\\\n-10  -7  -3  -5  \\infty  \\infty\\\\\n\\infty  \\infty  \\infty  0  1  \\infty\\\\\n\\infty  \\infty  \\infty  \\infty  0  1\\\\\n\\infty  \\infty  \\infty  1  \\infty  0\n\\end{pmatrix}\n$$\n\n阶段 $k=3$：我们考虑内部顶点来自 $\\{1, 2, 3\\}$ 的路径。枢轴顶点是 $3$。\n- 对于 $(1,1)$：$D^{(2)}[1,3] + D^{(2)}[3,1] = 7 + (-10) = -3$。当前 $D^{(2)}[1,1]=0$。\n  - 理由：环路 $1\\to2\\to3\\to1$ 的权重为 $-3$。内部顶点 $\\{2,3\\} \\subseteq \\{1,2,3\\}$。\n  - 更新：$D^{(3)}[1,1] = -3$。$\\mathrm{next}^{(3)}[1,1] = \\mathrm{next}^{(2)}[1,3] = 2$。\n- 对于 $(1,2)$：$D^{(2)}[1,3] + D^{(2)}[3,2] = 7 + (-7) = 0$。当前 $D^{(2)}[1,2]=3$。\n  - 理由：路径 $1\\to2\\to3\\to1\\to2$ 的权重为 $0$。内部顶点 $\\{1,2,3\\} \\subseteq \\{1,2,3\\}$。\n  - 更新：$D^{(3)}[1,2] = 0$。$\\mathrm{next}^{(3)}[1,2] = \\mathrm{next}^{(2)}[1,3] = 2$。\n- 对于 $(1,4)$：$D^{(2)}[1,3] + D^{(2)}[3,4] = 7 + (-5) = 2$。当前 $D^{(2)}[1,4]=5$。\n  - 理由：通过枢轴顶点3，连接路径 $1 \\to 2 \\to 3$ (对应 $D^{(2)}[1,3]$) 和路径 $3 \\to 1 \\to 2 \\to 4$ (对应 $D^{(2)}[3,4]$)。新路径的权重为 $7+(-5)=2$，小于当前的5。其内部顶点为 $\\{1,2,3\\}$，符合阶段 $k=3$ 的要求。\n  - 更新：$D^{(3)}[1,4] = 2$。$\\mathrm{next}^{(3)}[1,4] = \\mathrm{next}^{(2)}[1,3] = 2$。\n- 对于 $(2,1)$：$D^{(2)}[2,3] + D^{(2)}[3,1] = 4 + (-10) = -6$。当前 $D^{(2)}[2,1]=\\infty$。\n  - 理由：路径 $2\\to3\\to1$ 的权重为 $-6$。内部顶点 $\\{3\\} \\subseteq \\{1,2,3\\}$。\n  - 更新：$D^{(3)}[2,1] = -6$。$\\mathrm{next}^{(3)}[2,1] = \\mathrm{next}^{(2)}[2,3] = 3$。\n- 对于 $(2,2)$：$D^{(2)}[2,3] + D^{(2)}[3,2] = 4 + (-7) = -3$。当前 $D^{(2)}[2,2]=0$。\n  - 理由：环路 $2\\to3\\to1\\to2$ 的权重为 $-3$。内部顶点 $\\{1,3\\} \\subseteq \\{1,2,3\\}$。\n  - 更新：$D^{(3)}[2,2] = -3$。$\\mathrm{next}^{(3)}[2,2] = \\mathrm{next}^{(2)}[2,3] = 3$。\n- 对于 $(2,4)$：$D^{(2)}[2,3] + D^{(2)}[3,4] = 4 + (-5) = -1$。当前 $D^{(2)}[2,4]=2$。\n  - 理由：通过枢轴顶点3，连接路径 $2 \\to 3$ (对应 $D^{(2)}[2,3]$) 和路径 $3 \\to 1 \\to 2 \\to 4$ (对应 $D^{(2)}[3,4]$)。新路径的权重为 $4+(-5)=-1$，小于当前的2。其内部顶点为 $\\{1,2,3\\}$，符合阶段 $k=3$ 的要求。\n  - 更新：$D^{(3)}[2,4] = -1$。$\\mathrm{next}^{(3)}[2,4] = \\mathrm{next}^{(2)}[2,3] = 3$。\n阶段 $k=3$ 的距离矩阵是：\n$$ D^{(3)} =\n\\begin{pmatrix}\n-3  0  7  2  \\infty  \\infty\\\\\n-6  -3  4  -1  \\infty  \\infty\\\\\n-10  -7  -3  -5  \\infty  \\infty\\\\\n\\infty  \\infty  \\infty  0  1  \\infty\\\\\n\\infty  \\infty  \\infty  \\infty  0  1\\\\\n\\infty  \\infty  \\infty  1  \\infty  0\n\\end{pmatrix}\n$$\n\n对角线元素 $d_{ii}^{(k)}$ 变为负数，表示首次发现了一个涉及顶点 $i$ 的负权环路。根据算法，这发生在阶段 $k$，如果存在某个顶点（比如 $j$）经过枢轴顶点 $k$ 到达自身的路径权重为负：$D^{(k-1)}[j,k] + D^{(k-1)}[k,j]  0$。所得到的路径 $j \\rightsquigarrow k \\rightsquigarrow j$ 的内部顶点取自集合 $\\{1, \\dots, k-1\\} \\cup \\{k\\}$。\n\n在阶段 $k=1$，对于任何 $j$，条件 $D^{(0)}[j,1] + D^{(0)}[1,j]  0$ 都不满足。\n\n在阶段 $k=2$，我们测试条件 $D^{(1)}[j,2] + D^{(1)}[2,j]  0$。对于 $j=3$：\n$$ D^{(1)}[3,2] + D^{(1)}[2,3] = -7 + 4 = -3 $$\n由于 $-3  0$，条目 $D^{(2)}[3,3]$ 从 $0$ 更新为 $-3$。这是任何对角线元素首次变为负数的时刻。发现的具体环路是 $3 \\to 1 \\to 2 \\to 3$。它是由阶段 $k=1$ 后已知的从 $3$ 到 $2$ 的最短路径（即 $3\\to1\\to2$，内部顶点为 $\\{1\\}$）和阶段 $k=1$ 后已知的从 $2$ 到 $3$ 的最短路径（即直接边 $2\\to3$，无内部顶点）连接而成。此环路的内部顶点集合为 $\\{1, 2\\}$。该集合恰好是阶段 $k=2$ 所考虑路径的允许内部顶点集合。因此，该环路在此阶段对算法变得“可见”。\n\n因此，使 $D^{(k)}$ 的对角线元素首次变为负数的最小阶段索引 $k^\\star \\in \\{1, 2, \\dots, 6\\}$ 是 $k^\\star=2$。",
            "answer": "$$\\boxed{2}$$"
        },
        {
            "introduction": "仅仅检测到负权环的存在通常是不够的，在很多应用中，我们还需要知道这个环具体由哪些顶点组成。这项练习是一个编码挑战，它要求你实现一个关键的后续步骤：利用算法过程中生成的后继矩阵来追踪并报告一个负权环中的确切顶点序列。这能加深你对算法如何记录路径信息的理解，并锻炼你将算法理论转化为实用代码的能力。",
            "id": "3235685",
            "problem": "给定一个有向加权图族，每个图都以邻接矩阵形式表示，并为每个图指定一个锚点。您的任务是实现一个完整的程序，使用 Floyd–Warshall 算法来检测是否存在与锚点相关联的负权环，如果存在，则重构该特定负权环的顶点序列。重构必须仅基于算法执行期间累积的前驱（父）矩阵。最终输出必须将所有提供的测试用例的结果聚合到单行中。\n\n一个有向加权图是一个对 $(V,E)$，其中 $|V| = n$，边的权重由一个矩阵 $W \\in \\mathbb{R}^{n \\times n}$ 给出，其中 $W[i][j]$ 是从顶点 $i$ 到顶点 $j$ 的边的权重。如果从 $i$ 到 $j$ 没有边，则 $W[i][j]$ 为 $+\\infty$。对于所有的 $i$，对角线元素 $W[i][i]$ 均为 $0$，除非存在显式的自环。路径是顶点的序列，其总权重是其边权重之和。所有点对最短路径（APSP）问题旨在寻找所有顶点对之间的最短路径。\n\n基础理论：\n- 最短路径的最优子结构性质：最短路径的任何子路径本身都是其端点之间的最短路径。\n- 应用于 APSP 的动态规划原理：逐步考虑允许的中间顶点集合，以在遵守最优子结构的同时优化路径距离。\n\n闭包中负权环的检测定义：\n- 在对所有顶点执行 Floyd–Warshall 闭包后，一个顶点 $v$ 属于或受一个负权环影响，当且仅当闭包距离 $D[v][v]$ 严格小于 $0$。\n\n重构指令：\n- 对于一个锚点 $s \\in V$，如果 $D[s][s]  0$，则使用最终的前驱矩阵 $P$ 重构一个特定的负权环。设 $n = |V|$。将 $u$ 定义为从 $(s,s)$ 开始应用前驱指针恰好 $n$ 次的结果：从 $u \\leftarrow s$ 开始，并重复设置 $u \\leftarrow P[s][u]$ 共 $n$ 步。然后，从 $u$ 开始，继续跟随前驱 $P[s][\\cdot]$ 直到再次访问 $u$，从而形成一个环。将该环输出为一个顶点索引列表，该列表以 $u$ 开始，并以重复的 $u$ 作为最后一个元素结束。如果对于该锚点不存在这样的环（即 $D[s][s] \\ge 0$ 或重构失败），则输出空列表 $[]$。\n\n程序要求：\n- 实现 Floyd–Warshall 算法，计算一个闭包距离矩阵 $D$ 和一个前驱矩阵 $P$。对于每个有序对 $(i,j)$，$P$ 存储从 $i$ 到 $j$ 的当前最短路径上 $j$ 的直接前驱。\n- 对不存在的边使用 $+\\infty$。\n- 对于每个测试用例，生成重构的环（如上所述）或 $[]$。\n\n测试套件（每个测试用例是一个由矩阵 $W$ 和锚点 $s$ 组成的对）：\n1. $W_1$，$n=4$：\n   - 第 $0$ 行：$[\\,0,\\;2,\\;+\\infty,\\;+\\infty\\,]$\n   - 第 $1$ 行：$[\\,+\\infty,\\;0,\\;-1,\\;2\\,]$\n   - 第 $2$ 行：$[\\, -2,\\;+\\infty,\\;0,\\;+\\infty\\,]$\n   - 第 $3$ 行：$[\\,+\\infty,\\;-2,\\;+\\infty,\\;0\\,]$\n   锚点 $s_1 = 0$。\n2. $W_2$，$n=4$：\n   - 第 $0$ 行：$[\\,0,\\;+\\infty,\\;+\\infty,\\;2\\,]$\n   - 第 $1$ 行：$[\\,+\\infty,\\;0,\\;-3,\\;+\\infty\\,]$\n   - 第 $2$ 行：$[\\,+\\infty,\\;+\\infty,\\;0,\\;1\\,]$\n   - 第 $3$ 行：$[\\,+\\infty,\\;1,\\;+\\infty,\\;0\\,]$\n   锚点 $s_2 = 2$。\n3. $W_3$，$n=3$：\n   - 第 $0$ 行：$[\\,0,\\;1,\\;+\\infty\\,]$\n   - 第 $1$ 行：$[\\,+\\infty,\\;0,\\;1\\,]$\n   - 第 $2$ 行：$[\\,1,\\;+\\infty,\\;0\\,]$\n   锚点 $s_3 = 0$。\n4. $W_4$，$n=3$：\n   - 第 $0$ 行：$[\\,0,\\;+\\infty,\\;+\\infty\\,]$\n   - 第 $1$ 行：$[\\,+\\infty,\\;0,\\;+\\infty\\,]$\n   - 第 $2$ 行：$[\\,+\\infty,\\;+\\infty,\\;-1\\,]$\n   锚点 $s_4 = 2$。\n5. $W_5$，$n=3$：\n   - 第 $0$ 行：$[\\,0,\\;1,\\;+\\infty\\,]$\n   - 第 $1$ 行：$[\\,1,\\;0,\\;+\\infty\\,]$\n   - 第 $2$ 行：$[\\,+\\infty,\\;+\\infty,\\;-1\\,]$\n   锚点 $s_5 = 0$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来、以逗号分隔且无空格的结果列表。每个元素本身是一个用方括号括起来的、以逗号分隔的整数列表，表示一个环；如果无环可返回，则为空列表。例如，一个输出可能看起来像 $[[a_0,a_1,\\dots,a_0],[\\;],\\dots]$，其中第一个环的起始和结束顶点相同。",
            "solution": "用户提供了一个问题，要求实现 Floyd-Warshall 算法来寻找有向加权图中的所有点对最短路径。主要任务是检测与特定锚点相关联的负权环，如果存在，则使用算法生成的前驱矩阵重构该环的顶点序列。\n\n### 基于原则的设计\n\n该解决方案基于应用于所有点对最短路径（APSP）问题的动态规划原则。\n\n**1. Floyd-Warshall 算法：**\nFloyd-Warshall 算法通过迭代地将每个顶点视为任意两个其他顶点之间路径的中间点来解决 APSP 问题。它依赖于最优子结构性质：一个通过中间顶点 $k$ 的顶点 $i$ 和 $j$ 之间的最短路径，是由一条从 $i$到 $k$ 的最短路径和一条从 $k$ 到 $j$ 的最短路径组成的。\n\n设 $D^{(k)}[i][j]$ 为从顶点 $i$到顶点 $j$ 仅使用集合 $\\{0, 1, \\dots, k\\}$ 中的顶点作为中间顶点的最短路径权重。该算法计算一个矩阵序列 $D^{(0)}, D^{(1)}, \\dots, D^{(n)}$，其中 $n$ 是顶点数。\n\n递推关系为：\n$$\nD^{(k)}[i][j] = \\min(D^{(k-1)}[i][j], D^{(k-1)}[i][k] + D^{(k-1)}[k][j])\n$$\n基本情况 $D^{(-1)}$ 是输入权重矩阵 $W$，其中如果从 $i$ 到 $j$ 没有边，则 $W[i][j] = \\infty$。在实现中，我们可以原地更新矩阵，从而去掉上标。该算法通过三个嵌套循环进行：\n对于 $k$ 从 $0$ 到 $n-1$：\n  对于 $i$ 从 $0$ 到 $n-1$：\n    对于 $j$ 从 $0$ 到 $n-1$：\n      $D[i][j] \\leftarrow \\min(D[i][j], D[i][k] + D[k][j])$\n\n**2. 用于路径重构的前驱矩阵：**\n为了重构最短路径，我们维护一个前驱矩阵 $P$。$P[i][j]$ 存储从 $i$ 到 $j$ 的最短路径上紧接在 $j$ 之前的顶点。\n\n- **初始化：** 前驱矩阵 $P$ 根据输入图进行初始化。对于输入矩阵 $W$ 中从 $i$ 到 $j$ 的每条权重有限的边，我们设置 $P[i][j] = i$。如果没有直接边，则前驱未定义（用一个特殊值如 $-1$ 表示）。这包括自环，如果 $W[i][i]$ 是有限的，则 $P[i][i]=i$。\n\n- **更新规则：** 在 Floyd-Warshall 算法的主循环中，如果我们通过 $k$ 找到了从 $i$ 到 $j$ 的更短路径（即 $D[i][k] + D[k][j]  D[i][j]$），我们不仅更新距离 $D[i][j]$，还更新前驱 $P[i][j]$。从 $i$ 到 $j$ 的新路径是从 $i$ 到 $k$ 的路径和从 $k$ 到 $j$ 的路径的串联。因此，从 $i$ 出发的新路径上 $j$ 的前驱与从 $k$ 出发的路径上 $j$ 的前驱相同。更新规则是：\n$$\n\\text{若 } D[i][k] + D[k][j]  D[i][j], \\text{ 则 } P[i][j] \\leftarrow P[k][j]\n$$\n\n**3. 负权环检测：**\nFloyd-Warshall 算法的一个关键特性是它能够检测负权环。一个图包含一个从顶点 $i$ 可达且可以到达顶点 $i$ 的负权环，当且仅当算法完成后，从 $i$ 到其自身的最短路径距离 $D[i][i]$ 为负。问题指定了对给定的锚点 $s$ 检查此条件：如果 $D[s][s]  0$，则一个负权环与 $s$ 相关联。\n\n**4. 环的重构：**\n问题提供了一个具体的、非常规的指令，用于在 Floyd-Warshall 算法完成后基于最终的前驱矩阵 $P$ 来重构环。设锚点为 $s$，顶点数为 $n$。\n\n- **步骤 4.1：识别环上的一个顶点：** 如果 $D[s][s]  0$，这意味着从 $s$ 到其自身的最短路径涉及一个环。通过重复应用前驱函数可以找到该环上的一个顶点 $u$。从一个指向 $s$ 的指针开始，我们沿着从 $s$ 到 $s$ 的“最短路径”向后追溯。过程是初始化 $u \\leftarrow s$，然后迭代更新 $u \\leftarrow P[s][u]$ 共 $n$ 次。由于任何简单路径最多有 $n-1$ 条边，遍历 $n$ 个前驱链接保证了最终顶点 $u$ 位于源为 $s$ 的前驱图中的一个环上。\n\n- **步骤 4.2：追溯环路：** 一旦识别出顶点 $u$，就可以通过从 $u$ 开始并重复跟随源为 $s$ 的前驱直到再次访问 $u$ 来追溯环本身。也就是说，我们生成序列 $v_0=u, v_1=P[s][v_0], v_2=P[s][v_1], \\dots, v_m=u$。这个顶点序列以路径的逆序表示了该环。\n\n- **步骤 4.3：格式化输出：** 指令要求输出以 $u$ 开始并以重复的 $u$ 结束的顶点索引列表。这对应于序列 $[v_0, v_1, \\dots, v_{m-1}, v_m]$，这正是追溯过程生成的列表。\n\n### 算法实现\n\n整个程序将首先按规定定义测试用例。对于每个由权重矩阵 $W$ 和锚点 $s$ 组成的测试用例，执行以下过程：\n\n1.  用 $W$ 的值初始化一个 $n \\times n$ 的距离矩阵 $D$，以及一个 $n \\times n$ 的前驱矩阵 $P$。对于每个 $(i, j)$ 其中 $W[i][j]  \\infty$，设置 $P[i][j] \\leftarrow i$。$P$ 中的其他条目初始化为 $-1$。\n2.  执行 Floyd-Warshall 算法，并使用前驱更新规则 $P[i][j] \\leftarrow P[k][j]$，每当距离 $D[i][j]$ 通过顶点 $k$ 得到改善时。\n3.  循环完成后，检查 $D[s][s]  0$ 是否成立。如果不成立，此测试用例的结果是一个空列表 `[]`。\n4.  如果 $D[s][s]  0$，则继续进行重构：\n    a. 通过从 $u \\leftarrow s$ 开始并迭代 $u \\leftarrow P[s][u]$ 共 $n$ 次来确定环顶点 $u$。\n    b. 通过从 $u$ 开始并跟随前驱 $P[s][\\cdot]$ 直到再次到达 $u$ 来生成顶点序列，从而追溯环。\n    c. 将此序列格式化为一个以 $u$ 开始和结束的整数列表。\n5.  收集所有测试用例的结果，并按规定将它们格式化为单行字符串。\n\n这种结构化方法通过严格遵守 Floyd-Warshall 算法的既定原则和问题陈述的明确指令来确保正确性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef find_negative_cycle(W: np.ndarray, s: int) - list[int]:\n    \"\"\"\n    Uses the Floyd-Warshall algorithm to detect and reconstruct a negative cycle\n    associated with an anchor vertex.\n\n    Args:\n        W: The adjacency matrix of the graph.\n        s: The anchor vertex.\n\n    Returns:\n        A list of vertices representing the reconstructed negative cycle, starting\n        and ending with a specific vertex `u` on the cycle. Returns an empty\n        list if no such cycle is detected for the anchor.\n    \"\"\"\n    n = W.shape[0]\n\n    # Step 1: Initialize distance and predecessor matrices\n    dist = np.copy(W)\n    pred = np.full((n, n), -1, dtype=int)\n\n    for i in range(n):\n        for j in range(n):\n            if W[i, j] != np.inf:\n                pred[i, j] = i\n\n    # Step 2: Floyd-Warshall Algorithm\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                if dist[i, k] != np.inf and dist[k, j] != np.inf:\n                    if dist[i, k] + dist[k, j]  dist[i, j]:\n                        dist[i, j] = dist[i, k] + dist[k, j]\n                        pred[i, j] = pred[k, j]\n\n    # Step 3: Check for negative cycle at the anchor vertex\n    if dist[s, s] = 0:\n        return []\n\n    # Step 4: Reconstruct the negative cycle\n    # 4.1: Find a vertex 'u' that is part of the cycle.\n    # By repeatedly applying the predecessor function n times from s,\n    # we are guaranteed to land on a vertex within the cycle.\n    u = s\n    for _ in range(n):\n        if u == -1: # Predecessor path ended, should not happen if dist[s,s]  0\n            return []\n        u = pred[s, u]\n    \n    if u == -1: # This vertex must be on the cycle\n        return []\n\n    # 4.2: Trace the cycle starting from u by following predecessors.\n    # The problem asks for the sequence generated by following predecessors,\n    # which represents the cycle in reverse.\n    v = u\n    cycle = []\n    # Using a seen set to handle cases where the path before the cycle is long\n    seen = set()\n    while v not in seen:\n        seen.add(v)\n        v = pred[s, v]\n    \n    # Now trace the cycle starting from the first repeated vertex\n    u = v\n    cycle.append(u)\n    v = pred[s,u]\n    while v != u:\n        cycle.append(v)\n        v = pred[s,v]\n    \n    # 4.3: Add the starting vertex `u` to the end to close the cycle display\n    cycle.append(u)\n    \n    # The problem asks for the list in a specific way, let's trace again from the initially found 'u'\n    # The problem's instruction is simpler: just trace from the 'u' found after n steps.\n    v = u\n    cycle = []\n    while True:\n        cycle.append(v)\n        v = pred[s, v]\n        if v == u:\n            break\n    cycle.append(u)\n    \n    # The reconstructed path is backward, let's reverse it to match common conventions,\n    # though the problem is ambiguous. The logic of starting with u and ending with u\n    # can be satisfied either way. Let's stick to the direct backward trace.\n    # The problem asks for a list starting and ending with u.\n    # From u, get pred[s,u], then pred[s,pred[s,u]], until we get u again.\n    start_node = u\n    path = [start_node]\n    curr = pred[s, start_node]\n    while curr != start_node:\n        path.append(curr)\n        curr = pred[s, curr]\n    path.append(start_node)\n    \n    return path[::-1] # Reverse to get the forward path of the cycle.\n\ndef solve():\n    \"\"\"\n    Solves the problem for all given test cases and prints the final output.\n    \"\"\"\n    inf = np.inf\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        (np.array([\n            [0, 2, inf, inf],\n            [inf, 0, -1, 2],\n            [-2, inf, 0, inf],\n            [inf, -2, inf, 0]\n        ]), 0), # s1=0\n        (np.array([\n            [0, inf, inf, 2],\n            [inf, 0, -3, inf],\n            [inf, inf, 0, 1],\n            [inf, 1, inf, 0]\n        ]), 2), # s2=2\n        (np.array([\n            [0, 1, inf],\n            [inf, 0, 1],\n            [1, inf, 0]\n        ]), 0), # s3=0\n        (np.array([\n            [0, inf, inf],\n            [inf, 0, inf],\n            [inf, inf, -1]\n        ]), 2), # s4=2\n        (np.array([\n            [0, 1, inf],\n            [1, 0, inf],\n            [inf, inf, -1]\n        ]), 0)  # s5=0\n    ]\n\n    results = []\n    for W, s in test_cases:\n        cycle_list = find_negative_cycle(W, s)\n        results.append(f\"[{','.join(map(str, cycle_list))}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Floyd-Warshall算法的真正威力在于其通用的动态规划结构，它不仅仅局限于求解最短路径。这项练习将展示其强大的通用性，要求你将其改造，用于解决一个完全不同的问题——“最宽路径”问题，即最大化路径上的最小边的权值。通过将标准的 $(\\min, +)$ 代数结构替换为 $(\\max, \\min)$ 结构，你将领会到该算法抽象而强大的本质。",
            "id": "3235604",
            "problem": "您会收到几个独立的测试用例。每个测试用例包含一个有向图，其非负边容量由邻接矩阵表示，以及一个指定源顶点和目标顶点的查询对。路径的容量定义为该路径上所有边的最小容量。目标是为每个测试用例计算从源到目标的最大可能路径容量，即在所有路径中，取每条路径的最小边容量，再在这些值中取最大值。这通常被称为最宽路径或瓶颈路径问题。\n\n基本原理和约束：\n- 一个有向图由一组顶点和一组有向边构成，其中每条从顶点 $i$ 到顶点 $j$ 的有向边都有一个非负容量 $w_{ij} \\in \\mathbb{R}_{\\ge 0}$。邻接矩阵 $W$ 将其编码为 $W[i][j] = w_{ij}$。\n- 路径 $P = (v_0, v_1, \\dots, v_\\ell)$ 的容量是值 $\\min\\{ w_{v_0 v_1}, w_{v_1 v_2}, \\dots, w_{v_{\\ell-1} v_\\ell} \\}$。\n- 如果从源到目标不存在路径，则容量定义为 $0$。\n- 邻接矩阵中没有用容量 $0$ 表示的边。图中可能存在自环；为了动态规划的目的，将从顶点到其自身的容量视为无穷大（概念上为 $+\\infty$），但请注意，下面的查询均不使用相同的源和目标顶点。\n- 您必须改编经典的 Floyd–Warshall 算法（该算法用于计算传递闭包或所有点对最短路径），通过使用基于最优性原理的动态规划公式来解决最宽路径问题：通过一个中间顶点扩展部分解，其路径容量不会超过其各部分容量的最小值，并且在候选路线中，您必须根据最宽路径目标选择最佳路线。利用这一点，推导出一个针对中间顶点、源点和目标点的三重嵌套迭代算法，该算法能在 $\\mathcal{O}(n^3)$ 时间内计算出具有 $n$ 个顶点的图的所有点对最宽路径容量。\n\n程序要求：\n- 实现一个程序，对于每个测试用例，根据给定的邻接矩阵构建所有点对最宽路径容量矩阵，并使用从 0 开始的索引返回指定查询对 $(s, t)$ 的容量。\n- 所有边容量和输出都是整数。如果从 $s$ 到 $t$ 没有路径，则输出 $0$。\n\n测试套件：\n对于下面的每个测试用例，图由其邻接矩阵 $W$ 指定，其中 $W[i][j]$ 是边 $(i \\to j)$ 的容量，$0$ 表示没有边。查询对 $(s, t)$ 在矩阵之后给出。顶点从 $0$ 开始索引。\n\n- 测试用例 1（顺利路径：间接路线优于直接路线）：\n  - $n = 4$\n  - $W = [ [\\,0, 5, 6, 3\\,], [\\,0, 0, 0, 7\\,], [\\,0, 0, 0, 4\\,], [\\,0, 0, 0, 0\\,] ]$\n  - 查询 $(s, t) = (0, 3)$\n  - 预期最宽容量为 $5$。\n\n- 测试用例 2（目标不可达）：\n  - $n = 3$\n  - $W = [ [\\,0, 2, 0\\,], [\\,0, 0, 0\\,], [\\,0, 0, 0\\,] ]$\n  - 查询 $(s, t) = (0, 2)$\n  - 预期最宽容量为 $0$。\n\n- 测试用例 3（自环无用；直接路径优于狭窄的绕行路径）：\n  - $n = 3$\n  - $W = [ [\\,0, 10, 2\\,], [\\,0, 100, 1\\,], [\\,0, 0, 0\\,] ]$\n  - 查询 $(s, t) = (0, 2)$\n  - 预期最宽容量为 $2$。\n\n- 测试用例 4（多条最宽路径并列）：\n  - $n = 4$\n  - $W = [ [\\,0, 8, 7, 4\\,], [\\,0, 0, 0, 5\\,], [\\,0, 0, 0, 5\\,], [\\,0, 0, 0, 0\\,] ]$\n  - 查询 $(s, t) = (0, 3)$\n  - 预期最宽容量为 $5$。\n\n- 测试用例 5（容量为零的边不能提高容量）：\n  - $n = 3$\n  - $W = [ [\\,0, 0, 3\\,], [\\,0, 0, 9\\,], [\\,0, 0, 0\\,] ]$\n  - 查询 $(s, t) = (0, 2)$\n  - 预期最宽容量为 $3$。\n\n- 测试用例 6（更长的链条优于直接边）：\n  - $n = 4$\n  - $W = [ [\\,0, 6, 0, 5\\,], [\\,0, 0, 6, 0\\,], [\\,0, 0, 0, 6\\,], [\\,0, 0, 0, 0\\,] ]$\n  - 查询 $(s, t) = (0, 3)$\n  - 预期最宽容量为 $6$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含按上述测试用例顺序排列的结果，形式为用方括号括起来的逗号分隔列表。对于提供的 $6$ 个测试用例，确切格式为：\n\"[r1,r2,r3,r4,r5,r6]\"\n其中每个 $r_i$ 是测试用例 $i$ 的整数最宽容量。",
            "solution": "我们在有向图上基于最优性原理，使用动态规划来构建最宽路径问题。考虑一个顶点集为 $\\{0, 1, \\dots, n-1\\}$ 的有向图，其邻接矩阵为 $W$，其中 $W[i][j] = w_{ij} \\in \\mathbb{R}_{\\ge 0}$ 表示边 $(i \\to j)$ 的容量，而 $w_{ij} = 0$ 表示不存在该边。\n\n将路径 $P = (v_0, v_1, \\dots, v_\\ell)$ 的容量定义为 $\\mathrm{cap}(P) = \\min\\{ w_{v_0 v_1}, w_{v_1 v_2}, \\dots, w_{v_{\\ell-1} v_\\ell} \\}$。对于顶点 $i$ 和 $j$，最宽路径容量为值\n$$\nC(i,j) = \\max_{P \\in \\mathcal{P}_{ij}} \\mathrm{cap}(P),\n$$\n其中 $\\mathcal{P}_{ij}$ 是从 $i$ 到 $j$ 的所有有向路径的集合。如果 $\\mathcal{P}_{ij}$ 为空，我们定义 $C(i,j) = 0$。\n\n为了在 $\\mathcal{O}(n^3)$ 时间内高效地计算所有点对的 $C(i,j)$，我们改编 Floyd–Warshall 范式。引入一个按中间顶点预算索引的动态规划。令 $D^{(k)}[i][j]$ 表示从 $i$ 到 $j$ 只使用来自 $\\{0,1,\\dots,k-1\\}$ 的中间顶点的最宽路径容量（即路径的内部顶点均取自前 $k$ 个顶点）。基本情况 $k=0$ 排除了所有中间顶点；因此只允许直接边和 $i=j$ 的平凡零长度路径。因此，\n- 对于 $i \\ne j$，我们设置 $D^{(0)}[i][j] = W[i][j]$，因为唯一的候选路径是直接边。\n- 对于 $i = j$，我们设置 $D^{(0)}[i][i] = +\\infty$，这反映了零边路径的容量是无穷大的，以便通过最小值与其他路径段组合；这确保了 $\\min(D^{(k)}[i][i], D^{(k)}[i][j]) = D^{(k)}[i][j]$ 并且不会人为地降低容量。\n\n对于归纳步骤，当顶点 $k$ 被允许作为中间顶点时，任何从 $i$ 到 $j$ 的路径要么不使用 $k$ 作为中间顶点，这种情况下其容量已由 $D^{(k)}[i][j]$ 记录；要么使用 $k$，这种情况下它可以分解为一条从 $i$ 到 $k$ 的路径和一条从 $k$ 到 $j$ 的路径，其容量分别为 $D^{(k)}[i][k]$ 和 $D^{(k)}[k][j]$。根据路径容量的定义，通过 $k$ 的拼接路径的容量是这两个容量的最小值。根据最宽路径的目标，我们在避开 $k$ 的选项和经过 $k$ 的选项中取最大值。因此，递推关系为\n$$\nD^{(k+1)}[i][j] = \\max\\Big( D^{(k)}[i][j], \\min\\big( D^{(k)}[i][k], D^{(k)}[k][j] \\big) \\Big).\n$$\n在处理完所有 $k \\in \\{0,1,\\dots,n-1\\}$ 后，我们得到 $D^{(n)} = C$，即所需的所有点对最宽路径容量矩阵。这正是 Floyd–Warshall 结构，只是其半环运算被替换为：用 $\\min$ 作为路径扩展算子，用 $\\max$ 作为路径选择算子。\n\n算法实现细节：\n- 初始化一个矩阵 $D$，对于 $i \\ne j$，设置 $D[i][j] \\leftarrow W[i][j]$，对于 $i = j$，设置 $D[i][i] \\leftarrow +\\infty$。\n- 对于 $k$ 从 $0$到 $n-1$：\n  - 对于 $i$ 从 $0$ 到 $n-1$：\n    - 对于 $j$ 从 $0$ 到 $n-1$：\n      - 更新 $D[i][j] \\leftarrow \\max\\big( D[i][j], \\min(D[i][k], D[k][j]) \\big)$。\n- 对于查询对 $(s,t)$，答案是 $D[s][t]$（如果有限），如果不存在路径则为 $0$。在我们的表示法中，不存在路径会使 $D[s][t]$ 始终保持为 $0$，因此返回 $D[s][t]$ 即可。\n\n正确性简述：\n- 基本情况的正确性：对于 $k=0$，$D^{(0)}$ 正确地记录了没有中间顶点的路径容量。对角线上的 $+\\infty$ 确保了与单位路径的组合不会降低容量。\n- 归纳步骤：假设 $D^{(k)}$ 正确地编码了使用 $\\{0,\\dots,k-1\\}$ 中间顶点的最宽路径容量。在步骤 $k+1$ 中允许的任何路径要么避开 $k$，要么包含 $k$。如果避开 $k$，其最佳容量是 $D^{(k)}[i][j]$。如果包含 $k$，则在第一次和最后一次出现 $k$ 的地方进行分解，得到两条子路径，其容量受 $D^{(k)}[i][k]$ 和 $D^{(k)}[k][j]$ 的限制，并且任何这样的拼接路径的容量等于两者中的最小值。在这两种情况下取最大值，即可得到使用 $\\{0,\\dots,k\\}$ 中间顶点的最优容量。因此，该递推关系保持了正确性。\n- 终止时得到 $D^{(n)} = C$。\n\n时间和空间复杂度：\n- 三重循环的运行时间为 $\\mathcal{O}(n^3)$，使用 $\\mathcal{O}(n^2)$ 的空间。\n\n现在将此算法应用于所提供的测试套件：\n\n- 测试用例 1：从 $0$ 到 $3$ 的路径包括直接容量为 $3$ 的路径，路径 $0 \\to 1 \\to 3$ 的容量为 $\\min(5, 7) = 5$，路径 $0 \\to 2 \\to 3$ 的容量为 $\\min(6, 4) = 4$。最宽容量是 $5$。\n\n- 测试用例 2：从 $0$ 到 $2$ 没有路径，因此容量保持为 $0$。\n\n- 测试用例 3：从 $0$ 到 $2$，直接边的容量为 $2$。绕行路径 $0 \\to 1 \\to 2$ 的容量为 $\\min(10, 1) = 1$。顶点 $1$ 处容量为 $100$ 的自环并不能增加此容量，因为 $\\min(10, 100, 1) = 1$。因此，最宽容量是 $\\max(2, 1) = 2$。\n\n- 测试用例 4：从 $0$ 到 $3$ 有两条候选绕行路径：$0 \\to 1 \\to 3$ 的容量为 $\\min(8, 5) = 5$，$0 \\to 2 \\to 3$ 的容量为 $\\min(7, 5) = 5$。直接边的容量为 $4$。最宽容量是 $5$。\n\n- 测试用例 5：经过顶点 $1$ 的绕行路径容量为 $\\min(0, 9) = 0$，这并未超过直接边容量 $3$。最宽容量是 $3$。\n\n- 测试用例 6：链式路径 $0 \\to 1 \\to 2 \\to 3$ 的容量为 $\\min(6, 6, 6) = 6$，超过了直接边容量 $5$。因此，最宽容量是 $6$。\n\n因此，按顺序输出的结果是 $[5, 0, 2, 5, 3, 6]$，程序必须以指定的单行格式生成此结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef widest_path_all_pairs(adj):\n    \"\"\"\n    Compute all-pairs widest path capacities using a Floyd–Warshall-style DP.\n    adj: list of lists (n x n) with nonnegative integers; 0 denotes no edge.\n    Returns: matrix D (n x n) of widest capacities; D[i][j] is an integer,\n             with D[i][j] == 0 meaning no path from i to j.\n    \"\"\"\n    n = len(adj)\n    # Initialize DP matrix with floats to use +inf on diagonal.\n    D = [[float(adj[i][j]) for j in range(n)] for i in range(n)]\n    for i in range(n):\n        D[i][i] = float('inf')\n    # Floyd–Warshall over max-min semiring\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                # Calculate capacity of the path via k\n                via_capacity = min(D[i][k], D[k][j])\n                # Update if the path via k is wider\n                if via_capacity  D[i][j]:\n                    D[i][j] = via_capacity\n                    \n    # Convert back to integers for final output.\n    # If a path does not exist, its capacity will remain 0 from initialization.\n    # If i == j, the capacity is conceptually infinite but should be 0 for output.\n    out = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i != j and D[i][j] > 0 and np.isfinite(D[i][j]):\n                out[i][j] = int(D[i][j])\n    return out\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case: (adjacency matrix, (s, t))\n    test_cases = [\n        # Test case 1\n        (\n            [\n                [0,5,6,3],\n                [0,0,0,7],\n                [0,0,0,4],\n                [0,0,0,0],\n            ],\n            (0,3),\n        ),\n        # Test case 2\n        (\n            [\n                [0,2,0],\n                [0,0,0],\n                [0,0,0],\n            ],\n            (0,2),\n        ),\n        # Test case 3\n        (\n            [\n                [0,10,2],\n                [0,100,1],\n                [0,0,0],\n            ],\n            (0,2),\n        ),\n        # Test case 4\n        (\n            [\n                [0,8,7,4],\n                [0,0,0,5],\n                [0,0,0,5],\n                [0,0,0,0],\n            ],\n            (0,3),\n        ),\n        # Test case 5\n        (\n            [\n                [0,0,3],\n                [0,0,9],\n                [0,0,0],\n            ],\n            (0,2),\n        ),\n        # Test case 6\n        (\n            [\n                [0,6,0,5],\n                [0,0,6,0],\n                [0,0,0,6],\n                [0,0,0,0],\n            ],\n            (0,3),\n        ),\n    ]\n\n    results = []\n    for adj, (s, t) in test_cases:\n        D = widest_path_all_pairs(adj)\n        results.append(D[s][t])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}