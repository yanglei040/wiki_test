{
    "hands_on_practices": [
        {
            "introduction": "网络流不仅能处理边的容量限制，还能巧妙地用于解决涉及点（顶点）限制的问题。本练习将引导你使用经典的“节点分裂”技巧，将一个关于寻找内部顶点不相交路径的问题，转化为一个标准的最大流问题。通过这个过程，你将深刻体会到最大流与网络连通性之间的内在联系。",
            "id": "3255356",
            "problem": "考虑一个有向图 $G = (V, E)$，其顶点集为 $V = \\{s, t, a, b, c, d, p, q, r, x, y, z\\}$，边集 $E$ 由以下有向边组成：$(s, a)$、$(s, b)$、$(s, c)$、$(s, d)$、$(a, p)$、$(a, q)$、$(a, r)$、$(b, p)$、$(b, q)$、$(b, r)$、$(c, p)$、$(c, q)$、$(c, r)$、$(d, p)$、$(d, q)$、$(d, r)$、$(p, x)$、$(p, y)$、$(q, y)$、$(q, z)$、$(r, x)$、$(r, z)$、$(x, t)$、$(y, t)$、$(z, t)$。你需要通过将 $G$ 转换为一个流网络 $G'$ 来强制实现 $s$-$t$ 路径的内部顶点不相交性，这需要使用标准的节点分裂构造方法：对于每个内部顶点 $v \\in V \\setminus \\{s, t\\}$，用两个顶点 $v^{\\mathrm{in}}$ 和 $v^{\\mathrm{out}}$ 替换 $v$，并连接一条容量为 $1$ 的有向边 $(v^{\\mathrm{in}}, v^{\\mathrm{out}})$。对于每条原始边 $(u, v) \\in E$，在 $G'$ 中添加一条容量为 $\\infty$ 的有向边 $(u^{\\mathrm{out}}, v^{\\mathrm{in}})$。源点 $s$ 和汇点 $t$ 不进行分裂；与 $s$ 或 $t$ 相邻的边分别变为 $(s, v^{\\mathrm{in}})$ 和 $(u^{\\mathrm{out}}, t)$，每条边的容量均为 $\\infty$。使用此构造，通过找到 $G'$ 中的最大 $s$-$t$ 流量值来建模并计算成对内部顶点不相交的 $s$-$t$ 路径的最大数量。将你的最终答案表示为单个整数。不需要四舍五入，也不涉及物理单位。",
            "solution": "用户希望通过以下步骤解决问题：\n1.  验证问题陈述是否有效。\n2.  如果有效，则继续进行解答。\n3.  如果无效，则说明原因并终止。\n\n### 步骤 1：提取已知条件\n-   **图：** 一个有向图 $G = (V, E)$。\n-   **顶点集：** $V = \\{s, t, a, b, c, d, p, q, r, x, y, z\\}$。源点是 $s$，汇点是 $t$。\n-   **边集：** $E = \\{(s, a), (s, b), (s, c), (s, d)\\} \\cup \\{(u, v) \\mid u \\in \\{a, b, c, d\\}, v \\in \\{p, q, r\\}\\} \\cup \\{(p, x), (p, y), (q, y), (q, z), (r, x), (r, z)\\} \\cup \\{(x, t), (y, t), (z, t)\\}$。\n-   **到流网络 $G'$ 的转换：**\n    -   对于每个内部顶点 $v \\in V \\setminus \\{s, t\\}$，用两个顶点 $v^{\\mathrm{in}}$ 和 $v^{\\mathrm{out}}$ 替换 $v$，并添加一条容量为 $c(v^{\\mathrm{in}}, v^{\\mathrm{out}}) = 1$ 的有向边 $(v^{\\mathrm{in}}, v^{\\mathrm{out}})$。\n    -   对于每条原始边 $(u, v) \\in E$，其中 $u, v \\in V \\setminus \\{s, t\\}$，在 $G'$ 中添加一条容量为 $c(u^{\\mathrm{out}}, v^{\\mathrm{in}}) = \\infty$ 的有向边 $(u^{\\mathrm{out}}, v^{\\mathrm{in}})$。\n    -   对于边 $(s, v) \\in E$，在 $G'$ 中添加一条容量为 $c(s, v^{\\mathrm{in}}) = \\infty$ 的边 $(s, v^{\\mathrm{in}})$。\n    -   对于边 $(u, t) \\in E$，在 $G'$ 中添加一条容量为 $c(u^{\\mathrm{out}}, t) = \\infty$ 的边 $(u^{\\mathrm{out}}, t)$。\n-   **目标：** 通过在构造的网络 $G'$ 中找到最大 $s-t$ 流量值，计算 $G$ 中成对内部顶点不相交的 $s-t$ 路径的最大数量。\n\n### 步骤 2：使用提取的已知条件进行验证\n-   **科学依据：** 该问题基于图论和网络流算法的基本概念。通过节点分裂将内部顶点不相交路径与最大流联系起来，是一个标准的、公认的结论，通常作为 Menger 定理和最大流最小割定理的推论出现。该问题具有科学合理性。\n-   **适定性：** 图 $G$ 的定义明确无歧义。流网络 $G'$ 的构造是精确的。目标清晰：计算最大流量值。存在唯一解。该问题是适定的。\n-   **客观性：** 问题使用形式化的数学语言陈述，没有任何主观性或歧义。\n\n### 步骤 3：结论与行动\n问题有效。将提供完整的解答。\n\n该问题要求在一个给定的有向图 $G$ 中，从源顶点 $s$ 到汇顶点 $t$ 的成对内部顶点不相交路径的最大数量。问题指定了使用的方法：标准的节点分裂构造来创建一个流网络 $G'$，然后进行最大流计算。$G'$ 中的最大流量值将等于 $G$ 中此类路径的数量。这是最大流最小割定理结合用于顶点连通性的 Menger 定理的直接应用。\n\n网络中的最大流量值等于 $s-t$ 割的最小容量。$s-t$ 割是将 $G'$ 的顶点划分为两个集合 $S$ 和 $T$ 的一种方式，使得 $s \\in S$ 且 $t \\in T$。割 $(S, T)$ 的容量是所有从 $S$ 中的顶点 $u$ 指向 $T$ 中的顶点 $v$ 的边 $(u, v)$ 的容量之和。\n\n我们来分析图 $G$ 的结构。内部顶点集可以划分为三个连续的层：\n- 第 1 层：$L_1 = \\{a, b, c, d\\}$\n- 第 2 层：$L_2 = \\{p, q, r\\}$\n- 第 3 层：$L_3 = \\{x, y, z\\}$\n\n每条从 $s$到 $t$ 的路径都必须先经过 $L_1$ 中的一个顶点，然后是 $L_2$ 中的一个顶点，最后是 $L_3$ 中的一个顶点。一个内部顶点集，如果移除它会断开所有从 $s$ 到 $t$ 的路径，则称之为 $s-t$ 顶点割。这种割的最小规模给出了内部顶点不相交路径的最大数量。\n\n$L_2$ 和 $L_3$ 集合本身就是 $s-t$ 顶点割。\n$L_1$ 的大小是 $|L_1| = 4$。\n$L_2$ 的大小是 $|L_2| = 3$。\n$L_3$ 的大小是 $|L_3| = 3$。\n\n这些基于层的割的最小规模是 $3$。这表明最小顶点割的大小至多为 $3$。让我们通过在流网络 $G'$ 中构造一个相应的 $s-t$ 割来形式化这个结论。\n\n考虑 $G$ 中的顶点割 $L_2 = \\{p, q, r\\}$。我们可以在 $G'$ 中定义一个 $s-t$ 割 $(S, T)$ 如下：\n- 令 $S = \\{s\\} \\cup \\{v^{\\mathrm{in}}, v^{\\mathrm{out}} \\mid v \\in L_1\\} \\cup \\{v^{\\mathrm{in}} \\mid v \\in L_2\\}$。\n- 令 $T$ 为 $G'$ 中所有其他顶点的集合，因此 $t \\in T$。\n\n从 $S$ 到 $T$ 的边是：\n$1$. 形式为 $(v^{\\mathrm{in}}, v^{\\mathrm{out}})$ 的边：\n对于 $v \\in L_2 = \\{p, q, r\\}$，我们有 $v^{\\mathrm{in}} \\in S$ 和 $v^{\\mathrm{out}} \\in T$。这三条边，$(p^{\\mathrm{in}}, p^{\\mathrm{out}})$、$(q^{\\mathrm{in}}, q^{\\mathrm{out}})$ 和 $(r^{\\mathrm{in}}, r^{\\mathrm{out}})$，跨越了该割。每条边的容量为 $1$。这些边的总容量是 $1+1+1=3$。\n\n$2$. 对应于 $E$ 中原始边（容量为 $\\infty$）的边：\n任何这样一条从 $S$ 到 $T$ 的边 $(u,v)$ 都会使该割的容量为无穷大。我们必须验证不存在这样的边。\n- 对于 $v \\in L_1$ 的边 $(s, v^{\\mathrm{in}})$：$s \\in S, v^{\\mathrm{in}} \\in S$。不跨越割。\n- 对于 $u \\in L_1, v \\in L_2$ 的边 $(u^{\\mathrm{out}}, v^{\\mathrm{in}})$：$u^{\\mathrm{out}} \\in S, v^{\\mathrm{in}} \\in S$。不跨越割。\n- 所有其他容量为无穷大的边（例如，对于 $u \\in L_2, v \\in L_3$ 的边 $(u^{\\mathrm{out}}, v^{\\mathrm{in}})$）要么两个端点都在 $T$ 中，要么不存在。例如，对于像 $(p^{\\mathrm{out}}, x^{\\mathrm{in}})$ 这样的边，$p^{\\mathrm{out}} \\in T$ 且 $x^{\\mathrm{in}} \\in T$。它不从 $S$ 跨越到 $T$。\n\n这个割 $(S,T)$ 的总容量恰好是 $3$。根据最大流最小割定理，最大流量值小于或等于任何割的容量，因此 $f_{\\max} \\le 3$。\n\n现在，我们需要为最大流建立一个下界。我们可以通过在 $G$ 中找到一组内部顶点不相交的路径来实现这一点。如果我们找到 $k$ 条这样的路径，那么最大流必须至少为 $k$。让我们尝试找到 $3$ 条这样的路径。\n考虑以下三条路径：\n- 路径 1：$s \\to a \\to p \\to x \\to t$。内部顶点集是 $P_1 = \\{a, p, x\\}$。\n- 路径 2：$s \\to b \\to q \\to y \\to t$。内部顶点集是 $P_2 = \\{b, q, y\\}$。\n- 路径 3：$s \\to c \\to r \\to z \\to t$。内部顶点集是 $P_3 = \\{c, r, z\\}$。\n\n我们必须验证这些路径是有效的（即边存在）并且它们是内部顶点不相交的。\n- 边 $(s,a)$、$(s,b)$、$(s,c)$ 存在。\n- 边 $(a,p)$、$(b,q)$、$(c,r)$ 存在，因为在 $\\{a,b,c,d\\}$ 和 $\\{p,q,r\\}$ 之间存在一个完全二分图。\n- 根据问题描述，边 $(p,x)$、$(q,y)$、$(r,z)$ 存在。\n- 边 $(x,t)$、$(y,t)$、$(z,t)$ 存在。\n所有路径都是有效的。\n\n内部顶点集分别为 $P_1 = \\{a, p, x\\}$、$P_2 = \\{b, q, y\\}$ 和 $P_3 = \\{c, r, z\\}$。这些集合是不相交的：$P_1 \\cap P_2 = \\emptyset$，$P_1 \\cap P_3 = \\emptyset$，以及 $P_2 \\cap P_3 = \\emptyset$。因此，这三条路径是成对内部顶点不相交的。\n\n存在 $3$ 条内部顶点不相交的路径意味着此类路径的最大数量至少为 $3$。在流网络 $G'$ 中，这对应于一个值为 $3$ 的流。因此，$f_{\\max} \\ge 3$。\n\n结合这两个结果：\n- 从最小割分析，我们得到 $f_{\\max} \\le 3$。\n- 从路径构造，我们得到 $f_{\\max} \\ge 3$。\n\n因此，最大流量值必须恰好为 $3$。这个值代表了成对内部顶点不相交的 $s-t$ 路径的最大数量。",
            "answer": "$$\\boxed{3}$$"
        },
        {
            "introduction": "当网络中所有边的容量都是整数时，最大流的值也必然是整数，这是网络流的一个优美特性。本练习将挑战这一整数性定理的边界，通过引入一个非整数容量的边，来探索最大流值何时会变为非整数。这能帮助你更深入地理解，最终决定流大小的是最小割的容量，而不仅仅是算法的执行过程。",
            "id": "3255308",
            "problem": "一个有向网络有源点 $s$、汇点 $t$ 以及中间顶点 $a$ 和 $b$。所有现有边的容量都是整数：\n- 边 $s \\to b$ 的容量为 $1$。\n- 边 $a \\to t$ 的容量为 $5$。\n- 边 $b \\to t$ 的容量为 $10$。\n\n允许你添加一条新的有向边 $e = (s,a)$，其容量为 $c \\in \\mathbb{R}_{>0}$，其中 $c$ 可以是非整数。令 $f^{\\star}(c)$ 表示所得网络中最大 $s$–$t$ 流的值。\n\n仅使用 $s$–$t$ 割的核心定义、最大流最小割定理以及 Ford–Fulkerson 方法（通过残差网络）对整数容量的经典整性属性作为基础。从第一性原理出发，推导出一个精确的最大实数 $T$，使得对于每个满足 $0 < c \\leq T$ 的非整数 $c$，最大流值 $f^{\\star}(c)$ 都是非整数。然后报告 $T$ 的值。\n\n给出你的答案为一个精确的数值（不要四舍五入）。",
            "solution": "我们将使用网络流理论的原理，特别是最大流最小割定理来解决这个问题。设给定网络为 $G_c$，其顶点集为 $V = \\{s, a, b, t\\}$，其中 $s$ 是源点，$t$ 是汇点。边的容量是参数 $c \\in \\mathbb{R}_{>0}$ 的函数，具体如下：\n$C(s, b) = 1$\n$C(a, t) = 5$\n$C(b, t) = 10$\n$C(s, a) = c$\n所有其他边的容量假定为 $0$。我们关心的是从 $s$ 到 $t$ 的最大流值 $f^{\\star}(c)$。\n\n最大流最小割定理指出，网络中最大流的值等于任何 $s$–$t$ 割的最小容量。一个 $s$–$t$ 割是将顶点集 $V$ 划分为两个不相交的集合 $S$ 和 $T$，使得 $s \\in S$ 且 $t \\in T$。一个割 $(S, T)$ 的容量是所有边 $(u, v)$（其中 $u \\in S$ 且 $v \\in T$）的容量之和。\n\n为了找到 $f^{\\star}(c)$，我们必须枚举网络 $G_c$ 中所有可能的 $s$–$t$ 割并计算它们的容量。顶点 $s$ 和 $t$ 必须分别在集合 $S$ 和 $T$ 中。中间顶点 $a$ 和 $b$ 既可以在 $S$ 中，也可以在 $T$ 中。这给出了 $2^2 = 4$ 种需要考虑的可能的最小 $s$–$t$ 割。\n\n1.  **割 1**：$S_1 = \\{s\\}$, $T_1 = \\{a, b, t\\}$。\n    从 $S_1$ 到 $T_1$ 的边是 $(s, a)$ 和 $(s, b)$。\n    这个割的容量是 $C(S_1, T_1) = C(s, a) + C(s, b) = c + 1$。\n\n2.  **割 2**：$S_2 = \\{s, a\\}$, $T_2 = \\{b, t\\}$。\n    从 $S_2$ 到 $T_2$ 的边是 $(s, b)$ 和 $(a, t)$。对于简单的割容量计算，没有从 $T_2$ 到 $S_2$ 的边需要考虑。边 $(s,a)$ 完全在 $S_2$ 内部。\n    这个割的容量是 $C(S_2, T_2) = C(s, b) + C(a, t) = 1 + 5 = 6$。\n\n3.  **割 3**：$S_3 = \\{s, b\\}$, $T_3 = \\{a, t\\}$。\n    从 $S_3$ 到 $T_3$ 的边是 $(s, a)$ 和 $(b, t)$。边 $(s,b)$ 完全在 $S_3$ 内部。\n    这个割的容量是 $C(S_3, T_3) = C(s, a) + C(b, t) = c + 10$。\n\n4.  **割 4**：$S_4 = \\{s, a, b\\}$, $T_4 = \\{t\\}$。\n    从 $S_4$ 到 $T_4$ 的边是 $(a, t)$ 和 $(b, t)$。\n    这个割的容量是 $C(S_4, T_4) = C(a, t) + C(b, t) = 5 + 10 = 15$。\n\n根据最大流最小割定理，最大流值 $f^{\\star}(c)$ 是这些割容量的最小值：\n$$f^{\\star}(c) = \\min(c + 1, 6, c + 10, 15)$$\n因为 $c > 0$，所以 $c + 10 > c + 1$ 恒成立。同样，$15 > 6$。因此，$f^{\\star}(c)$ 的表达式可以简化为：\n$$f^{\\star}(c) = \\min(c + 1, 6)$$\n这把 $f^{\\star}(c)$ 定义为一个关于 $c$ 的分段函数。当 $c + 1 = 6$ 时，函数的行为发生改变，这发生在 $c = 5$ 时。\n\n-   **情况一：$0 < c \\leq 5$**\n    在这个区间内，$c + 1 \\leq 6$，所以最小值是 $c + 1$。\n    $$f^{\\star}(c) = c + 1$$\n    问题要求的是对于每个非整数 $c$，$f^{\\star}(c)$ 也是非整数的条件。如果 $c$ 是一个非整数，那么 $c+1$ 也是一个非整数。（反证法：如果对于某个整数 $k$ 有 $c+1=k$，那么 $c=k-1$ 将是一个整数，这与假设相矛盾。）因此，对于区间 $(0, 5]$ 中的所有非整数 $c$，最大流值 $f^{\\star}(c)$ 都是非整数。\n\n-   **情况二：$c > 5$**\n    在这个区间内，$c + 1 > 6$，所以最小值是 $6$。\n    $$f^{\\star}(c) = 6$$\n    在这种情况下，无论 $c$ 是否为整数，最大流值总是整数 $6$。对于任何大于 5 的非整数 $c$（例如，$c=5.5$），最大流 $f^{\\star}(5.5) = 6$ 是一个整数。\n\n问题要求找到最大的实数 $T$，使得对于每个满足 $0 < c \\leq T$ 的非整数 $c$，值 $f^{\\star}(c)$ 都是非整数。\n\n根据我们的分析：\n-   对于区间 $(0, 5]$，任何非整数 $c$ 都会产生一个非整数的流值 $f^{\\star}(c) = c+1$。点 $c=5$ 本身是一个整数，所以它不属于“每个非整数 $c$”的条件。因此，任何 $T \\leq 5$ 都会满足该属性。\n\n-   考虑任何大于 $5$ 的值 $T$。例如，令 $T = 5 + \\epsilon$，其中 $\\epsilon > 0$。该区间为 $(0, 5+\\epsilon]$。我们可以在这个区间内选择一个非整数 $c_0$，使得 $5 < c_0 \\leq 5+\\epsilon$。例如，$c_0 = 5 + \\epsilon/2$。对于这个 $c_0$，$f^{\\star}(c_0) = 6$，这是一个整数。这违反了所要求的条件，即对于区间内的*每个*非整数 `c`，流都是非整数。\n\n因此，任何大于 $5$ 的 $T$ 值都不能满足该条件。$T$ 的最大可能值为 $5$。\n\n网络流的整性属性指出，如果所有容量都是整数，则最大流值也是整数。在这里，当 $c > 5$ 时，最小割由具有整数容量的边决定，即 $C(s,b)=1$ 和 $C(a,t)=5$。尽管网络包含一个非整数容量 $c$，但它不是瓶颈，最大流值最终为一个整数。当 $0 < c \\leq 5$ 时，具有非整数容量 $c$ 的边是瓶颈割的一部分，这迫使最大流值本身成为非整数。转换点恰好是两个竞争的割具有相等容量的地方，即 $c+1=6$，也就是在 $c=5$ 时。\n\n满足该条件的最大实数 $T$ 是 $5$。",
            "answer": "$$\\boxed{5}$$"
        },
        {
            "introduction": "掌握了最大流算法后，我们就可以将其作为工具来解决更复杂的网络分析问题。本练习将向你展示如何应用最大流来量化网络中各个节点的重要性，即识别出移除后对网络吞吐量影响最大的“关键节点”。这个例子充分体现了基础算法如何成为解决现实世界分析任务的基石。",
            "id": "3255325",
            "problem": "给定一个有向网络，其边具有非负整数容量，并有一个指定的源顶点和一个指定的汇顶点。该网络表示为一个有限有向图，其顶点集为 $\\{0,1,2,\\dots,n-1\\}$，并含有一组有向边，其中每条有向边 $(u,v)$ 都有一个相关的正整数容量 $c(u,v)$。一个可行流是一个定义在有向边上的函数 $f(u,v)$，它满足每条有向边 $(u,v)$ 的容量限制 $0 \\le f(u,v) \\le c(u,v)$，并且对于除指定源点 $s$ 和指定汇点 $t$ 之外的每个顶点 $u$，都满足流量守恒约束 $\\sum_{(x,u)} f(x,u) = \\sum_{(u,y)} f(u,y)$。一个可行流的值是从源点流出的净流量，即 $\\sum_{(s,y)} f(s,y) - \\sum_{(x,s)} f(x,s)$。最大流问题的目标是确定从 $s$ 到 $t$ 的可行流的最大可能值。\n\n关于一个可行流 $f$ 的残留网络是基于相同顶点集的有向图，其中每条有向边 $(u,v)$ 的残留容量为 $c_f(u,v) = c(u,v) - f(u,v)$，并且对于每条原始边 $(u,v)$，还存在一条残留容量为 $c_f(v,u) = f(u,v)$ 的反向边 $(v,u)$。一条增广路径是在残留网络中从 $s$ 到 $t$ 的一条有向路径，其上每条边的残留容量都严格为正。一个公认的事实是，当不存在增广路径时，当前流即为最大流。最大流最小割定理确保了最大流的值等于最小 $s$-$t$ 割的容量。\n\n定义“最有价值”的顶点为任意一个顶点 $v \\in \\{0,1,\\dots,n-1\\} \\setminus \\{s,t\\}$，移除该顶点（删除顶点及其所有邻接边）会导致最大 $s$-$t$ 流量值下降得最多，下降量衡量为 $\\Delta(v) = \\operatorname{maxflow}(G) - \\operatorname{maxflow}(G \\setminus \\{v\\})$。如果多个顶点都达到了相同的最大下降量，则选择索引最小的那个。如果没有可移除的顶点（即，网络恰好只有两个顶点 $s$ 和 $t$），则将答案定义为序对 $[-1,0]$。\n\n您的任务是编写一个完整的、可运行的程序，为每个给定的测试用例计算一个包含两个元素的列表 $[v^\\star,\\Delta^\\star]$，其中 $v^\\star$ 是最有价值顶点的索引（根据平局决胜规则），$\\Delta^\\star$ 是对应的最大流量下降值。您必须使用基于上述基本定义的、基于残留网络的算法来确定最大流。程序不得接受任何输入，并且必须将所有测试用例的聚合结果作为单行打印，格式化为一个用方括号括起来的逗号分隔列表，其中每个测试用例的结果本身是一个双元素列表 $[v^\\star,\\Delta^\\star]$。例如，总输出应类似于 $[ [a,b], [c,d], [e,f] ]$ 这样的列表的列表。\n\n解释细节和要求：\n- 顶点由 $\\{0,1,\\dots,n-1\\}$ 中的整数标记。\n- 图是有向的。同一有序顶点对之间的多条边是允许的，并应被视为不同的平行边。\n- 移除一个顶点 $v$ 意味着删除 $v$ 以及所有边 $(v, \\cdot)$ 和 $(\\cdot, v)$，然后在剩余顶点构成的图中重新计算从 $s$ 到 $t$ 的最大流。\n- 只有 $v \\notin \\{s,t\\}$ 的顶点才被视为可移除的候选顶点。\n- 如果没有候选顶点（即，顶点集恰好为 $\\{s,t\\}$），则对该测试用例输出 $[-1,0]$。\n\n需要实现和解决的测试套件：\n对于每个测试用例，实例由 $(n, s, t, \\text{Edges})$ 给出，其中 $\\text{Edges}$ 是一个三元组 $(u,v,c)$ 的列表。\n\n- 测试用例 1: $n=4$, $s=0$, $t=3$, $\\text{Edges} = \\{(0,1,3), (1,3,3), (0,2,2), (2,3,2)\\}$.\n- 测试用例 2: $n=4$, $s=0$, $t=3$, $\\text{Edges} = \\{(0,1,2), (1,3,2), (0,2,2), (2,3,2)\\}$.\n- 测试用例 3: $n=5$, $s=0$, $t=4$, $\\text{Edges} = \\{(0,1,5), (1,3,1), (3,4,5), (0,2,5), (2,3,1)\\}$.\n- 测试用例 4: $n=2$, $s=0$, $t=1$, $\\text{Edges} = \\{(0,1,7)\\}$.\n- 测试用例 5: $n=6$, $s=0$, $t=5$, $\\text{Edges} = \\{(0,1,10), (1,2,1), (2,5,10), (0,3,10), (3,4,1), (4,5,10), (1,3,10), (2,4,10)\\}$.\n\n最终输出格式规范：\n- 您的程序必须只产生一行输出，包含所有结果的组合，形式为一个列表，其中每个元素是对应测试用例的双元素列表 $[v^\\star,\\Delta^\\star]$，顺序与上述用例顺序一致。\n- 不要打印任何其他文本。输出必须是包含单个列表的单行。例如，形如 $[[a,b],[c,d],[e,f]]$ 的语法结构是可以接受的。",
            "solution": "用户提供了一个需要在有向网络中找到“最有价值”顶点的问题。一个顶点的价值由移除该顶点后最大 $s$-$t$ 流量的下降幅度来定义。这个问题根植于网络流的经典理论。\n\n### 问题验证\n问题陈述已经过验证，被确定为一个定义明确、有科学依据且客观的算法任务。\n\n1.  **给定条件**：问题提供了网络流问题所需的所有必要定义：一个有向图 $G$，其顶点集为 $\\{0, 1, \\dots, n-1\\}$，一个源点 $s$，一个汇点 $t$，以及边上的非负整数容量 $c(u,v)$。它定义了可行流 $f(u,v)$、流的值、残留网络 $G_f$ 的概念以及增广路径。它引入了“最有价值”顶点 $v^\\star$ 的定义，即不在 $\\{s,t\\}$ 中且能最大化流量下降量 $\\Delta(v) = \\operatorname{maxflow}(G) - \\operatorname{maxflow}(G \\setminus \\{v\\})$ 的顶点。问题还规定了平局决胜规则（最小索引）和一个基本情况（对于只有两个顶点 $s$ 和 $t$ 的网络）。提供了一套包含 5 个测试用例的套件。\n\n2.  **验证**：\n    -   **科学依据**：该问题建立在网络流理论的基础原则之上，包括最大流最小割定理。所有定义都是标准且正确的。\n    -   **定义明确性**：目标是找到一个特定的顶点 $v^\\star$ 和相应的流量下降值 $\\Delta^\\star$。最大流的存在性是有保证的。使用整数容量确保了像 Edmonds-Karp 这样的标准算法将终止并得到一个整数值的最大流。指定的平局决胜规则保证了 $v^\\star$ 的唯一解。\n    -   **客观性和完整性**：问题以精确、形式化的语言陈述。为每个测试用例提供了所有必要的数据和约束。\n\n3.  **结论**：问题是有效的，可以构建解决方案。\n\n### 基于原则的解决方案设计\n\n问题的核心是多次计算网络中的最大流：一次是为原始图，然后对每个移除了一个候选顶点的图变体各计算一次。\n\n**1. 最大流算法**\n\n最大流将使用 Edmonds-Karp 算法计算，该算法是 Ford-Fulkerson 方法的一种实现。此算法的原理是在残留网络中寻找增广路径。\n\n-   **残留网络**：给定一个流 $f$，前向边 $(u,v)$ 的残留容量为 $c_f(u,v) = c(u,v) - f(u,v)$，并引入一条容量为 $c_f(v,u) = f(u,v)$ 的反向边 $(v,u)$。\n-   **增广路径搜索**：Edmonds-Karp 算法采用广度优先搜索（BFS）来寻找从源点 $s$ 到汇点 $t$ 的增广路径。如果路径上每条边的残留容量都严格为正，则该路径是“增广的”。使用 BFS 是因为它能找到边数最少的路径，这保证了算法的终止性。\n-   **流量增广**：一旦找到增广路径，就将流量增加该路径的瓶颈容量，即其上所有边残留容量的最小值。然后相应地更新残留容量：前向边的容量减少，反向边的容量增加。\n-   **终止**：重复寻找增广路径和增加流量的过程，直到在残留网络中再也找不到从 $s$ 到 $t$ 的增广路径为止。根据最大流最小割定理，最终得到的流是最大的。\n\n**2. 寻找最有价值的顶点**\n\n对于每个测试用例 $(n, s, t, \\text{Edges})$，整体算法如下：\n\n-   **步骤 1：基本情况检查**：如果顶点数 $n$ 为 2（或更少），则没有可移除的顶点（即除 $s$ 和 $t$ 之外的顶点）。根据问题规范，这种情况的结果是 $[-1, 0]$。\n\n-   **步骤 2：计算初始最大流**：首先，为原始图 $G$ 构建容量矩阵。对于具有容量 $c_1, c_2, \\dots$ 的平行边 $(u,v)$，通过将其容量相加到一个条目 $c(u,v) = \\sum c_i$ 中来处理。然后，使用 Edmonds-Karp 算法计算该图的最大流 $\\operatorname{maxflow}(G)$。\n\n-   **步骤 3：迭代并评估候选顶点**：\n    -   识别可供移除的候选顶点集 $V' = \\{v \\in \\{0, \\dots, n-1\\} \\mid v \\ne s \\text{ and } v \\ne t\\}$。\n    -   初始化找到的最佳顶点 $v^\\star$ 和最大下降量 $\\Delta^\\star$。一个合理的初始化是 $v^\\star = -1$ 和 $\\Delta^\\star = -\\infty$。\n    -   按索引递增的顺序遍历每个候选顶点 $v \\in V'$。这个顺序对于正确应用平局决胜规则至关重要。\n    -   对于每个 $v$，通过移除 $v$ 及其所有邻接边来构建图 $G \\setminus \\{v\\}$。这等同于从原始边列表中构建一个新的容量矩阵，排除任何以 $v$ 为起点或终点的边。\n    -   计算这个修改后图的最大流 $\\operatorname{maxflow}(G \\setminus \\{v\\})$。\n    -   计算流量下降量：$\\Delta(v) = \\operatorname{maxflow}(G) - \\operatorname{maxflow}(G \\setminus \\{v\\})$。\n    -   将 $\\Delta(v)$ 与当前最大下降量 $\\Delta^\\star$进行比较。如果 $\\Delta(v) > \\Delta^\\star$，则更新 $\\Delta^\\star = \\Delta(v)$ 和 $v^\\star = v$。因为我们是按索引递增的顺序遍历顶点，所以第一个达到新的最大下降量的顶点，其索引在所有达到相同下降量的顶点中是最小的。因此，如果 $\\Delta(v) = \\Delta^\\star$，我们不进行更新。\n\n-   **步骤 4：最终结果**：遍历所有候选顶点后，序对 $[v^\\star, \\Delta^\\star]$ 即为该测试用例的结果。\n\n### 测试用例分析\n\n-   **测试用例 1**: $n=4, s=0, t=3, E=\\{(0,1,3), (1,3,3), (0,2,2), (2,3,2)\\}$。\n    -   网络有两条不相交的路径：$0 \\to 1 \\to 3$（容量 3）和 $0 \\to 2 \\to 3$（容量 2）。\n    -   $\\operatorname{maxflow}(G) = 3 + 2 = 5$。\n    -   可移除顶点：$\\{1, 2\\}$。\n    -   移除 $v=1$：路径 $0 \\to 1 \\to 3$ 被移除。$\\operatorname{maxflow}(G \\setminus \\{1\\}) = 2$。$\\Delta(1) = 5 - 2 = 3$。\n    -   移除 $v=2$：路径 $0 \\to 2 \\to 3$ 被移除。$\\operatorname{maxflow}(G \\setminus \\{2\\}) = 3$。$\\Delta(2) = 5 - 3 = 2$。\n    -   最大下降量为 $3$，由移除顶点 $1$ 产生。结果: $[1, 3]$。\n\n-   **测试用例 2**: $n=4, s=0, t=3, E=\\{(0,1,2), (1,3,2), (0,2,2), (2,3,2)\\}$。\n    -   路径：$0 \\to 1 \\to 3$（容量 2）和 $0 \\to 2 \\to 3$（容量 2）。\n    -   $\\operatorname{maxflow}(G) = 2 + 2 = 4$。\n    -   可移除顶点：$\\{1, 2\\}$。\n    -   移除 $v=1$：$\\operatorname{maxflow}(G \\setminus \\{1\\}) = 2$。$\\Delta(1) = 4-2=2$。\n    -   移除 $v=2$：$\\operatorname{maxflow}(G \\setminus \\{2\\}) = 2$。$\\Delta(2) = 4-2=2$。\n    -   两者都产生 $\\Delta=2$。根据平局决胜规则（最小索引），$v^\\star=1$。结果: $[1, 2]$。\n\n-   **测试用例 3**: $n=5, s=0, t=4, E=\\{(0,1,5), (1,3,1), (3,4,5), (0,2,5), (2,3,1)\\}$。\n    -   顶点 $3$ 是一个瓶颈。有两条路径经过它：$0 \\to 1 \\to 3 \\to 4$ 和 $0 \\to 2 \\to 3 \\to 4$。它们的流量分别受限于 $c(1,3)=1$ 和 $c(2,3)=1$，并且它们都必须通过 $3 \\to 4$。\n    -   最小割是 $S=\\{0,1,2\\}, T=\\{3,4\\}$，其容量为 $c(1,3)+c(2,3) = 1+1=2$。所以, $\\operatorname{maxflow}(G) = 2$。\n    -   可移除顶点：$\\{1, 2, 3\\}$。\n    -   移除 $v=1$：路径 $0 \\to 1 \\to 3 \\to 4$ 消失。剩余路径是 $0 \\to 2 \\to 3 \\to 4$，流量为 $1$。$\\Delta(1) = 2-1=1$。\n    -   移除 $v=2$：路径 $0 \\to 2 \\to 3 \\to 4$ 消失。剩余路径是 $0 \\to 1 \\to 3 \\to 4$，流量为 $1$。$\\Delta(2) = 2-1=1$。\n    -   移除 $v=3$：两条路径都被切断。流量为 $0$。$\\Delta(3) = 2-0=2$。\n    -   最大下降量为 $2$（对于顶点 $3$）。结果: $[3, 2]$。\n\n-   **测试用例 4**: $n=2, s=0, t=1, E=\\{(0,1,7)\\}$。\n    -   顶点集是 $\\{s,t\\}$。没有可移除的顶点。根据问题规则，答案是 $[-1, 0]$。\n\n-   **测试用例 5**: $n=6, s=0, t=5, E=\\{\\dots\\}$。\n    -   最小割是 $S=\\{0,1,3\\}, T=\\{2,4,5\\}$，其容量为 $c(1,2)+c(3,4) = 1+1=2$。所以，$\\operatorname{maxflow}(G)=2$。\n    -   可移除顶点：$\\{1, 2, 3, 4\\}$。\n    -   移除 $v=1$：$\\operatorname{maxflow}(G \\setminus \\{1\\})=1$。$\\Delta(1)=1$。\n    -   移除 $v=2$：$\\operatorname{maxflow}(G \\setminus \\{2\\})=1$。$\\Delta(2)=1$。\n    -   移除 $v=3$：$\\operatorname{maxflow}(G \\setminus \\{3\\})=1$。$\\Delta(3)=1$。\n    -   移除 $v=4$：$\\operatorname{maxflow}(G \\setminus \\{4\\})=1$。$\\Delta(4)=1$。\n    -   所有可移除顶点都导致流量下降 $1$。最大下降量是 $1$。达到此下降量的最小索引是 $1$。结果: $[1, 1]$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import deque\n\ndef max_flow(n, s, t, capacity_matrix):\n    \"\"\"\n    Computes the maximum flow from source s to sink t in a network\n    using the Edmonds-Karp algorithm.\n    \"\"\"\n    capacity = np.copy(capacity_matrix)\n    flow = 0\n    \n    while True:\n        # Find an augmenting path using BFS\n        parent = np.full(n, -1, dtype=int)\n        queue = deque([(s, float('inf'))])\n        parent[s] = s\n        path_flow = 0\n        \n        path_found = False\n        while queue:\n            u, current_flow = queue.popleft()\n            \n            for v in range(n):\n                if parent[v] == -1 and capacity[u, v] > 0:\n                    parent[v] = u\n                    new_flow = min(current_flow, capacity[u, v])\n                    if v == t:\n                        path_flow = new_flow\n                        path_found = True\n                        break\n                    queue.append((v, new_flow))\n            if path_found:\n                break\n        \n        # If no augmenting path is found, the flow is maximal\n        if not path_found:\n            break\n            \n        # Add path flow to total flow\n        flow += path_flow\n        \n        # Update residual capacities\n        v = t\n        while v != s:\n            u = parent[v]\n            capacity[u, v] -= path_flow\n            capacity[v, u] += path_flow\n            v = u\n            \n    return int(flow)\n\ndef build_capacity_matrix(n, edges, removed_vertex=None):\n    \"\"\"\n    Builds an n x n capacity matrix from a list of edges.\n    Handles parallel edges by summing their capacities.\n    Optionally ignores edges connected to a removed_vertex.\n    \"\"\"\n    capacity = np.zeros((n, n), dtype=int)\n    for u, v, c in edges:\n        if removed_vertex is not None and (u == removed_vertex or v == removed_vertex):\n            continue\n        capacity[u, v] += c\n    return capacity\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n    test_cases = [\n        (4, 0, 3, [(0, 1, 3), (1, 3, 3), (0, 2, 2), (2, 3, 2)]),\n        (4, 0, 3, [(0, 1, 2), (1, 3, 2), (0, 2, 2), (2, 3, 2)]),\n        (5, 0, 4, [(0, 1, 5), (1, 3, 1), (3, 4, 5), (0, 2, 5), (2, 3, 1)]),\n        (2, 0, 1, [(0, 1, 7)]),\n        (6, 0, 5, [(0, 1, 10), (1, 2, 1), (2, 5, 10), (0, 3, 10), (3, 4, 1), (4, 5, 10), (1, 3, 10), (2, 4, 10)])\n    ]\n\n    all_results = []\n\n    for n, s, t, edges in test_cases:\n        # Identify removable vertices (not source or sink)\n        removable_vertices = [v for v in range(n) if v != s and v != t]\n\n        # Handle the case with no removable vertices\n        if not removable_vertices:\n            all_results.append([-1, 0])\n            continue\n\n        # Calculate the original maximum flow\n        original_capacity_matrix = build_capacity_matrix(n, edges)\n        original_max_flow = max_flow(n, s, t, original_capacity_matrix)\n\n        best_v = -1\n        max_decrease = float('-inf')\n\n        # Iterate through removable vertices to find the \"most valuable\" one\n        for v in removable_vertices:\n            # Create capacity matrix with vertex v removed\n            capacity_matrix_removed = build_capacity_matrix(n, edges, removed_vertex=v)\n            \n            # Calculate the max flow in the modified graph\n            flow_after_removal = max_flow(n, s, t, capacity_matrix_removed)\n\n            decrease = original_max_flow - flow_after_removal\n\n            # Update if a larger decrease is found.\n            # Tie-breaking (smallest index) is handled by iterating in\n            # ascending order of v and only updating on strictly greater decreases.\n            if decrease > max_decrease:\n                max_decrease = decrease\n                best_v = v\n        \n        # This handles the case where all decreases are equal (e.g. 0 or negative).\n        # `best_v` would not have been updated from -1.\n        # The tie-breaker rule says pick the smallest index.\n        if best_v == -1 and removable_vertices:\n             v_first = removable_vertices[0]\n             capacity_matrix_first_removed = build_capacity_matrix(n, edges, removed_vertex=v_first)\n             flow_after_first_removal = max_flow(n, s, t, capacity_matrix_first_removed)\n             max_decrease = original_max_flow - flow_after_first_removal\n             best_v = v_first\n\n        all_results.append([best_v, int(max_decrease)])\n\n    # Format the final output as a single-line string representation of a list of lists.\n    # e.g., [[1,3],[1,2],[3,2],[-1,0],[1,1]]\n    output_str = \"[\" + \",\".join(map(str, all_results)) + \"]\"\n    print(output_str.replace(\" \", \"\"))\n\nsolve()\n```"
        }
    ]
}