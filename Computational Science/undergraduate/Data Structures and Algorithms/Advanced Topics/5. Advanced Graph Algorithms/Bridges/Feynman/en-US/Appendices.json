{
    "hands_on_practices": [
        {
            "introduction": "Before diving into complex algorithms, it's crucial to build a strong intuition for the fundamental properties of bridges. This exercise challenges a common misconception about the relationship between local vertex properties, like degree, and global graph structures, like bridges. By working through this problem, you will sharpen your ability to think critically about network resilience and construct counterexamples, a vital skill in graph theory .",
            "id": "1487123",
            "problem": "A network architect is designing a new robust communication network. The network's topology is modeled as a simple, connected graph $G=(V, E)$, where the set of vertices $V$ represents data centers and the set of edges $E$ represents high-bandwidth fiber optic links. A link is considered a \"single point of failure\" if its removal would disconnect the network into two or more separate components. In graph theory, such an edge is called a bridge.\n\nThe architect is exploring various design constraints related to vertex degrees to enhance network resilience. The degree of a vertex is the number of links connected to it. The minimum degree of the graph, denoted $\\delta(G)$, is the smallest degree among all vertices in the graph. The architect wants to understand the fundamental relationship between the minimum degree of a network graph and the possible existence of bridges.\n\nWhich of the following statements correctly describes this relationship for any simple, connected graph $G$ with at least two vertices?\n\nA. A connected graph $G$ has no bridges if and only if its minimum degree is $\\delta(G) \\geq 2$.\n\nB. If a connected graph $G$ has a bridge, then its minimum degree $\\delta(G)$ must be 1.\n\nC. For any integer $k \\geq 1$, it is possible to construct a connected graph $G$ with a bridge, such that the minimum degree of $G$ is exactly $k$.\n\nD. If an edge is a bridge in a connected graph $G$, then at least one of its endpoints must have a degree of 1.\n\nE. Any connected graph $G$ with a minimum degree of $\\delta(G) \\geq 2$ cannot contain a bridge.",
            "solution": "We recall definitions. In a simple connected graph $G=(V,E)$, an edge $e \\in E$ is a bridge if removing $e$ increases the number of connected components. The minimum degree is $\\delta(G)=\\min_{v \\in V}\\deg(v)$.\n\nEvaluate each statement:\n\nA. Claim: “$G$ has no bridges if and only if $\\delta(G) \\geq 2$.” The forward direction is true: if $G$ has no bridges, then no vertex can have degree $1$, because if there were a vertex $u$ with $\\deg(u)=1$, its unique incident edge would be a bridge, a contradiction. Hence $\\delta(G) \\geq 2$. The reverse direction is false. Counterexample: take two cycles and connect them by a single edge. Formally, let $G$ be obtained from two disjoint cycles $C_{m}$ and $C_{n}$ by adding a single edge $xy$ where $x \\in V(C_{m})$ and $y \\in V(C_{n})$. Then $\\delta(G)=2$, but the added edge $xy$ is the only connection between the two parts, so $xy$ is a bridge. Therefore A is false.\n\nB. Claim: “If $G$ has a bridge, then $\\delta(G)=1$.” This is false. The same counterexample as above has a bridge $xy$ while $\\delta(G)=2$. Hence B is false.\n\nC. Claim: “For any integer $k \\geq 1$, there exists a connected graph $G$ with a bridge and $\\delta(G)=k$.” Construction: \n- For $k=1$, any tree on at least two vertices is connected, has bridges, and $\\delta(G)=1$.\n- For $k \\geq 2$, take two connected $k$-regular graphs (for instance, two copies of $K_{k+1}$, which is $k$-regular). Pick one vertex from each copy and add a single edge between them. The resulting graph is connected; the added edge is the only interconnection between the two copies, hence it is a bridge. The degrees of the chosen endpoints increase to $k+1$, while all other vertices still have degree $k$, so the minimum degree remains $\\delta(G)=k$. Thus C is true.\n\nD. Claim: “If an edge is a bridge, then at least one endpoint has degree $1$.” This is false. In the earlier construction with two cycles (or two triangles) connected by a single edge, the bridge’s endpoints have degree at least $2$ (indeed $3$ in the two-triangles example), not $1$. Hence D is false.\n\nE. Claim: “Any connected graph with $\\delta(G) \\geq 2$ contains no bridge.” This is the converse of the true implication in A and is disproved by the same counterexample used for A and B. Hence E is false.\n\nTherefore, the only correct statement is C.",
            "answer": "$$\\boxed{C}$$"
        },
        {
            "introduction": "Moving from theory to practice, this exercise asks you to implement a core algorithm for identifying critical vulnerabilities in a network. You will apply a Depth-First Search (DFS) based approach to find all bridges in a weighted graph. The objective of finding the \"weakest link\" adds a practical optimization layer, requiring you to handle weights and specific tie-breaking rules, mirroring real-world scenarios in network analysis and infrastructure management .",
            "id": "3218710",
            "problem": "You are given an undirected weighted graph described by a finite set of vertices and edges. Let the graph be denoted by $G = (V, E)$ with a weight function $w : E \\to \\mathbb{N}$, where $\\mathbb{N}$ is the set of nonnegative integers. Each edge $e \\in E$ connects two vertices $u, v \\in V$ and has an associated integer weight $w(e)$. Multiple edges between the same unordered pair of vertices are permitted, and the graph may be disconnected. Vertices are labeled by consecutive integers from $0$ through $n-1$, where $n = |V|$.\n\nAn edge $e \\in E$ is called a bridge if removing $e$ from $G$ increases the number of connected components of $G$. Formally, $e$ is a bridge if the graph $G' = (V, E \\setminus \\{e\\})$ has strictly more connected components than $G$. Define the \"weakest link\" of $G$ to be a bridge with minimum weight. If there are multiple bridges with the same minimum weight, select the one whose unordered endpoint pair (written in ascending order) is lexicographically minimal. If there is still a tie (for example, parallel edges with the same unordered endpoints and the same weight), select the earliest edge in the given input order.\n\nYour task is to write a program that, starting from the core definitions of an undirected graph, connectedness, and Depth-First Search (DFS), derives and implements a method to determine the set of bridges and selects the weakest link according to the rule above. The program must return, for each test case, either the endpoints and weight of the weakest link as a list $[u, v, w]$ where $u < v$, or an empty list $[]$ if no bridge exists.\n\nInput is not provided interactively; instead, your program must embed and use the following test suite. Each test case specifies $n$ and a list of edges as triples $(u, v, w)$, where $u$ and $v$ are integers satisfying $0 \\le u, v \\le n-1$ and $w \\in \\mathbb{N}$.\n\nTest suite:\n- Test case $1$ (happy path with both cycles and leaves): $n = 5$, edges $= [(0, 1, 5), (1, 2, 2), (2, 3, 10), (1, 3, 4), (3, 4, 3)]$.\n- Test case $2$ (no bridges: a simple cycle): $n = 3$, edges $= [(0, 1, 7), (1, 2, 8), (2, 0, 9)]$.\n- Test case $3$ (path graph, all edges are bridges): $n = 4$, edges $= [(0, 1, 7), (1, 2, 1), (2, 3, 5)]$.\n- Test case $4$ (disconnected graph with a cycle and a single-edge component): $n = 5$, edges $= [(0, 1, 5), (1, 2, 6), (2, 0, 4), (3, 4, 8)]$.\n- Test case $5$ (parallel edges; only the leaf edge is a bridge): $n = 3$, edges $= [(0, 1, 1), (0, 1, 2), (1, 2, 4)]$.\n- Test case $6$ (tie on weight resolved by lexicographic endpoints): $n = 4$, edges $= [(0, 1, 3), (2, 3, 3)]$.\n\nYour program should produce a single line of output containing the results for all test cases as a comma-separated list enclosed in square brackets, where each element is either an empty list $[]$ or a list $[u, v, w]$ as defined. For example, a valid output for three cases would look like $[[u_1, v_1, w_1],[],[u_3, v_3, w_3]]$.",
            "solution": "The problem statement is parsed and determined to be valid. It presents a well-defined task within the domain of graph theory and algorithms, with all necessary conditions and data provided. The definitions of a bridge and the \"weakest link\" are precise and formalizable.\n\nThe task is to identify the \"weakest link\" in a given undirected, weighted graph $G = (V, E)$. This is defined as the bridge with the minimum weight, with specific tie-breaking rules for lexicographically smallest endpoints and earliest input order.\n\nA bridge is an edge whose removal increases the number of connected components in the graph. The canonical algorithm for finding all bridges in a graph is based on a Depth-First Search (DFS) traversal. The derivation of this method from first principles is as follows.\n\nA DFS traversal of a graph $G$ partitions its edges into two types: tree edges, which form a DFS spanning forest, and back edges, which connect a vertex to one of its ancestors in the DFS tree (excluding its immediate parent). An edge $(u, v)$, where $u$ is the parent of $v$ in a DFS tree, is a bridge if and only if there is no back edge from any vertex in the subtree rooted at $v$ to $u$ or any of its ancestors. The existence of such a back edge would imply an alternative path from $v$ back to $u$ (thus forming a cycle), meaning the removal of the tree edge $(u, v)$ would not disconnect the graph.\n\nThis principle can be formalized by tracking two key values for each vertex $u$ during the DFS:\n$1$. The discovery time, `$disc[u]`: A timestamp (a monotonically increasing counter) recording when $u$ is first visited.\n$2$. The low-link value, `$low[u]`: The lowest discovery time reachable from $u$ (including itself) by traversing zero or more tree edges in its subtree and then at most one back edge.\n\nThe algorithm proceeds with a recursive DFS function. For each vertex $u$, we initialize $low[u] = disc[u]$. Then, for each neighbor $v$ of $u$:\n- If $v$ has been visited, the edge $(u, v)$ is a back edge. The vertex $u$ can reach an ancestor or an already visited node, so we update its low-link value: $low[u] = \\min(low[u], disc[v])$.\n- If $v$ has not been visited, $(u, v)$ is a tree edge. We perform a recursive call `dfs(v)`. Upon returning from the recursion, the $low[v]$ value for the entire subtree at $v$ is computed. The vertex $u$ can reach everything $v$ can reach, so we update $low[u]$ accordingly: $low[u] = \\min(low[u], low[v])$.\n\nAfter this update, we apply the bridge condition. The edge $(u, v)$ is a bridge if and only if $low[v] > disc[u]$. This inequality signifies that the earliest vertex reachable from the subtree at $v$ is $v$ itself. No back edge from $v$'s subtree reaches $u$ or any of its ancestors. Therefore, removing the edge $(u, v)$ will separate the subtree rooted at $v$ from the rest of the graph, increasing the number of connected components.\n\nSpecial considerations for this problem:\n- **Multiple Edges**: The graph may contain parallel edges. A simple parent-vertex check in the DFS (i.e., `if v == parent`) is insufficient, as it would incorrectly ignore all parallel edges to the parent, not just the one used for traversal. A more robust approach, adopted here, is to pass the index of the parent edge to the recursive calls and ignore only that specific edge, correctly identifying parallel edges as potential back edges that form cycles.\n- **Disconnected Graphs**: The main procedure must iterate through all vertices from $0$ to $n-1$ and initiate a DFS from any unvisited vertex to ensure all connected components are traversed.\n\nThe overall algorithm is as follows:\n$1$. Augment the input edges with their original indices $0, 1, 2, \\dots$ to facilitate the final tie-breaking rule.\n$2$. Construct an adjacency list representation of the graph, where each entry stores the neighbor, weight, and original edge index.\n$3$. Initialize `disc`, `low`, and `visited` arrays.\n$4$. Iterate through all vertices. If a vertex is unvisited, start the modified DFS from it.\n$5$. The DFS function identifies all bridges using the $low[v] > disc[u]$ condition. Each discovered bridge is stored as a tuple containing its weight, its endpoints sorted ascendingly, and its original index: $(w, u_{sorted}, v_{sorted}, \\text{index})$.\n$6$. After the traversal is complete, if no bridges are found, the result is an empty list.\n$7$. Otherwise, the list of discovered bridges is sorted. Python's default tuple sorting mechanism naturally implements the required multi-level sorting criteria: first by weight, then by the first endpoint, then by the second endpoint, and finally by the original index.\n$8$. The first element of the sorted list is the \"weakest link.\" Its endpoints and weight are formatted into the required output list $[u, v, w]$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef find_weakest_link(n, edges):\n    \"\"\"\n    Finds the \"weakest link\" in a graph, defined as the bridge with the minimum\n    weight, with specific tie-breaking rules.\n    \"\"\"\n    if n == 0 or not edges:\n        return []\n\n    # Adjacency list: adj[u] -> list of (v, w, edge_idx)\n    adj = [[] for _ in range(n)]\n    for i, (u, v, w) in enumerate(edges):\n        # We assume u and v are valid vertex indices\n        adj[u].append((v, w, i))\n        adj[v].append((u, w, i))\n\n    # Tarjan's bridge-finding algorithm data structures\n    disc = np.full(n, -1, dtype=int)\n    low = np.full(n, -1, dtype=int)\n    time = 0\n    bridges = []\n\n    def dfs(u, parent_edge_idx):\n        \"\"\"\n        Performs Depth-First Search to find bridges.\n        \n        Args:\n            u: The current vertex.\n            parent_edge_idx: The index of the edge used to arrive at u. This is\n                             used to handle multigraphs correctly, preventing the\n                             traversal from immediately going back on the same edge.\n        \"\"\"\n        nonlocal time\n        disc[u] = low[u] = time\n        time += 1\n\n        for v, w, edge_idx in adj[u]:\n            if edge_idx == parent_edge_idx:\n                continue\n\n            if disc[v] != -1:  # v is a visited vertex (back edge)\n                low[u] = min(low[u], disc[v])\n            else:  # v is an unvisited vertex (tree edge)\n                dfs(v, edge_idx)\n                low[u] = min(low[u], low[v])\n\n                if low[v] > disc[u]:\n                    # The edge (u, v) is a bridge.\n                    # Sort endpoints for lexicographical comparison.\n                    u_sorted, v_sorted = sorted((u, v))\n                    # Store tuple for sorting: (weight, u, v, original_index)\n                    bridges.append((w, u_sorted, v_sorted, edge_idx))\n    \n    # Iterate through all vertices to handle disconnected graphs\n    for i in range(n):\n        if disc[i] == -1:\n            dfs(i, -1)\n    \n    if not bridges:\n        return []\n\n    # Sort according to the problem's tie-breaking rules:\n    # 1. Minimum weight (primary key)\n    # 2. Lexicographically minimal endpoint pair (secondary keys u, then v)\n    # 3. Earliest edge in input order (tertiary key, edge_idx)\n    # Python's default tuple sorting handles this hierarchy correctly.\n    bridges.sort()\n\n    weakest = bridges[0]\n    w, u, v, _ = weakest\n    return [u, v, w]\n\ndef solve():\n    \"\"\"\n    Defines the test suite, runs the solver for each case, and prints the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (5, [(0, 1, 5), (1, 2, 2), (2, 3, 10), (1, 3, 4), (3, 4, 3)]),\n        (3, [(0, 1, 7), (1, 2, 8), (2, 0, 9)]),\n        (4, [(0, 1, 7), (1, 2, 1), (2, 3, 5)]),\n        (5, [(0, 1, 5), (1, 2, 6), (2, 0, 4), (3, 4, 8)]),\n        (3, [(0, 1, 1), (0, 1, 2), (1, 2, 4)]),\n        (4, [(0, 1, 3), (2, 3, 3)]),\n    ]\n\n    results = []\n    for n, edges in test_cases:\n        result = find_weakest_link(n, edges)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The str() function for a list automatically adds spaces, e.g., '[1, 2, 4]'.\n    # This matches the example output format style.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "This final practice synthesizes multiple key concepts, demonstrating how identifying bridges can be a crucial sub-problem within a more complex task. Standard shortest-path algorithms often optimize for a single metric, like distance, but real-world routing may have more nuanced goals. This problem challenges you to find a path that is optimal under a lexicographical cost function $(b, \\ell)$, where you must first minimize the number of bridges crossed and then minimize the path length, a common requirement in designing robust and efficient communication pathways .",
            "id": "3218591",
            "problem": "You are given an undirected, simple graph with vertices labeled from $0$ to $n-1$ and an unweighted edge set. An edge is called a bridge if removing it increases the number of connected components of the graph. For two given vertices $u$ and $v$, define the objective for a $u$ to $v$ path as the lexicographically ordered pair $(b, \\ell)$, where $b$ is the number of bridge edges on the path and $\\ell$ is the number of edges on the path. The goal is to select a $u$ to $v$ path that is optimal in the following sense: minimize $b$ first, and among all such paths, minimize $\\ell$. If $u$ and $v$ are disconnected, the required output is the pair $(-1,-1)$.\n\nUse only the foundational definitions of undirected graphs, connected components, and bridges. You must implement a complete program that, for each test case below, computes the optimal pair $(b,\\ell)$ as defined. If there is no path between the specified $u$ and $v$, output $(-1,-1)$ for that test case.\n\nYour program must produce a single line of output containing a list of results corresponding to the test cases, where each result is the pair $[b,\\ell]$ for that test case. The format must be a single list of lists, for example, $[[b_1,\\ell_1],[b_2,\\ell_2],\\dots]$.\n\nTest suite to use:\n- Test case $1$:\n  - $n=8$\n  - Edge set $\\{(0,1),(1,2),(2,3),(3,0),(1,7),(3,4),(4,5),(5,6),(6,4)\\}$\n  - $u=0$, $v=5$\n- Test case $2$:\n  - $n=5$\n  - Edge set $\\{(0,1),(1,2),(2,3),(3,4),(4,0)\\}$\n  - $u=0$, $v=3$\n- Test case $3$:\n  - $n=4$\n  - Edge set $\\{(0,1),(2,3)\\}$\n  - $u=0$, $v=3$\n- Test case $4$:\n  - $n=7$\n  - Edge set $\\{(0,1),(1,2),(1,3),(3,4),(3,5),(5,6)\\}$\n  - $u=2$, $v=6$\n- Test case $5$:\n  - $n=3$\n  - Edge set $\\{(0,1),(1,2)\\}$\n  - $u=1$, $v=1$\n\nFinal output format:\n- Your program should print exactly one line that is a single list of lists, where each inner list is $[b,\\ell]$ for the corresponding test case in the same order as above. For unreachable pairs, use $[-1,-1]$. For example, a valid output looks like $[[0,3],[1,4],[-1,-1]]$.",
            "solution": "The user-provided problem is a well-defined exercise in graph theory, specifically requiring the computation of an optimal path between two vertices based on a lexicographical objective function. The problem is scientifically sound, self-contained, and algorithmically solvable.\n\nThe objective is to find a path from a source vertex $u$ to a target vertex $v$ that minimizes the pair $(b, \\ell)$, where $b$ is the number of bridges on the path and $\\ell$ is the total number of edges (path length). The minimization is lexicographical, meaning the primary goal is to minimize $b$, and the secondary goal is to minimize $\\ell$ among all paths with the minimum $b$.\n\nThis problem can be modeled as a shortest path problem on a weighted graph, where the \"weight\" of traversing an edge is not a single scalar but a pair of values. Let the cost of traversing an edge $(x, y)$ be a pair $(w_b, w_\\ell)$, where $w_b=1$ if the edge is a bridge and $w_b=0$ otherwise, and $w_\\ell=1$ for all edges. The total cost of a path is the component-wise sum of the costs of its constituent edges. The problem is then to find a path from $u$ to $v$ with the lexicographically smallest total cost.\n\nThe solution strategy involves two main phases:\n1.  **Bridge Identification**: Pre-processing the graph to identify all bridge edges.\n2.  **Optimal Path Search**: Employing a modified shortest path algorithm to find the path that minimizes the lexicographical cost $(b, \\ell)$.\n\n**Phase 1: Bridge Identification**\n\nA bridge in an undirected graph is an edge whose removal increases the number of connected components. A standard and efficient algorithm to find all bridges in a graph is based on a Depth-First Search (DFS) traversal. During the DFS, we maintain two values for each vertex $i$:\n-   $disc[i]$: The \"discovery time\" of vertex $i$, which is the time (a counter incremented at each vertex visit) when $i$ is first visited.\n-   $low[i]$: The \"low-link\" value of vertex $i$, which is the lowest discovery time reachable from $i$ (including itself) through the DFS tree, possibly by traversing a single \"back-edge\" to an ancestor.\n\nThe algorithm proceeds as follows:\nWe initialize discovery times, low-link values, and a parent tracker for all vertices. We iterate through each vertex from $0$ to $n-1$. If a vertex has not been visited, we start a DFS from it.\n\nIn the recursive DFS function for a vertex $u$ (with parent $p$):\n1.  Mark $u$ as visited. Set $disc[u]$ and $low[u]$ to the current time, and increment the time counter.\n2.  For each neighbor $v$ of $u$:\n    a. If $v$ is the parent $p$, ignore it.\n    b. If $v$ is already visited (and not the parent), it means there is a back-edge from $u$ to an ancestor $v$. This back-edge indicates a cycle. We update $low[u]$ as: $low[u] = \\min(low[u], disc[v])$.\n    c. If $v$ is not visited, we set $p$ as the parent of $v$ and recursively call DFS on $v$. After the recursive call returns, we update $low[u]$ based on the low-link value of its child $v$: $low[u] = \\min(low[u], low[v])$.\n    d. The crucial step for bridge detection: if $low[v] > disc[u]$, the edge $(u, v)$ is a bridge. This condition signifies that the earliest reachable vertex from the subtree rooted at $v$ is $v$ itself, and there is no back-edge from this subtree to any ancestor of $u$. Therefore, removing the edge $(u, v)$ disconnects $v$ and its descendants from $u$.\n\nWe collect all such identified bridges into a set for efficient lookup in the next phase.\n\n**Phase 2: Optimal Path Search**\n\nWith the set of bridges identified, we can proceed to find the optimal path. This is a shortest path problem with a vector-valued cost function, which can be solved using Dijkstra's algorithm, modified to handle lexicographical comparison.\n\nThe algorithm is as follows:\n1.  Initialize a distance data structure, $dist$, for all vertices. $dist[i]$ will store the lexicographically smallest pair $(b, \\ell)$ found so far for a path from $u$ to $i$. We initialize $dist[u] = (0, 0)$ and $dist[i] = (\\infty, \\infty)$ for all other vertices $i \\neq u$.\n2.  Use a min-priority queue to store tuples of the form $(b, \\ell, \\text{vertex})$. The priority queue will naturally order elements lexicographically by the pair $(b, \\ell)$.\n3.  Push the starting tuple $(0, 0, u)$ into the priority queue.\n4.  While the priority queue is not empty:\n    a. Extract the element with the minimum lexicographical cost: $(b_{curr}, \\ell_{curr}, v_{curr})$.\n    b. If $(b_{curr}, \\ell_{curr})$ is lexicographically greater than the currently known $dist[v_{curr}]$, it means we have found a better path to $v_{curr}$ previously. We skip this entry and continue.\n    c. For each neighbor $v_{next}$ of $v_{curr}$:\n        i. Determine the cost of the edge $(v_{curr}, v_{next})$. If it is a bridge, the cost is $(1, 1)$. Otherwise, it is $(0, 1)$. Let this be $(b_{edge}, \\ell_{edge})$.\n        ii. Calculate the cost of the new path to $v_{next}$: $(b_{new}, \\ell_{new}) = (b_{curr} + b_{edge}, \\ell_{curr} + \\ell_{edge})$.\n        iii. Compare this new cost with the current best known cost for $v_{next}$, $dist[v_{next}]$. If $(b_{new}, \\ell_{new})$ is lexicographically smaller than $dist[v_{next}]$, we have found a better path.\n        iv. Update $dist[v_{next}] = (b_{new}, \\ell_{new})$ and push the new tuple $(b_{new}, \\ell_{new}, v_{next})$ into the priority queue.\n\n5.  After the algorithm terminates, $dist[v]$ will contain the optimal pair $(b, \\ell)$ for the target vertex $v$. If $dist[v]$ remains $(\\infty, \\infty)$, it means $v$ is unreachable from $u$, and the result is $(-1, -1)$. The special case $u=v$ is handled correctly by the initialization $dist[u]=(0,0)$, yielding the path of cost $(0,0)$. This procedure guarantees finding the optimal path because, like the standard Dijkstra's algorithm, it explores vertices in increasing order of their \"distance\" (in this case, lexicographical cost).",
            "answer": "```python\nimport numpy as np\nimport heapq\nfrom collections import defaultdict\nimport sys\n\n# It is good practice to increase the recursion limit for deep graphs in DFS.\nsys.setrecursionlimit(2000)\n\ndef find_optimal_path(n, edges, u, v):\n    \"\"\"\n    Finds the optimal path from u to v based on lexicographical minimization of (bridges, length).\n    \"\"\"\n    if u == v:\n        return [0, 0]\n\n    adj = defaultdict(list)\n    for x, y in edges:\n        adj[x].append(y)\n        adj[y].append(x)\n\n    # --- Phase 1: Find all bridges using Tarjan's bridge-finding algorithm ---\n    \n    # Using numpy arrays for performance with large N.\n    disc = np.full(n, -1, dtype=int)\n    low = np.full(n, -1, dtype=int)\n    parent = np.full(n, -1, dtype=int)\n    visited = np.full(n, False, dtype=bool)\n    \n    bridges = set()\n    time = 0\n\n    def find_bridges_dfs(curr_node):\n        nonlocal time\n        visited[curr_node] = True\n        disc[curr_node] = low[curr_node] = time\n        time += 1\n\n        for neighbor in adj[curr_node]:\n            if neighbor == parent[curr_node]:\n                continue\n            if visited[neighbor]:\n                low[curr_node] = min(low[curr_node], disc[neighbor])\n            else:\n                parent[neighbor] = curr_node\n                find_bridges_dfs(neighbor)\n                low[curr_node] = min(low[curr_node], low[neighbor])\n                if low[neighbor] > disc[curr_node]:\n                    # The edge (curr_node, neighbor) is a bridge.\n                    # Store it in a canonical form (smaller, larger) for easy lookup.\n                    bridge_edge = tuple(sorted((curr_node, neighbor)))\n                    bridges.add(bridge_edge)\n\n    # The graph might be disconnected, so we iterate through all vertices.\n    for i in range(n):\n        if not visited[i]:\n            find_bridges_dfs(i)\n\n    # --- Phase 2: Modified Dijkstra's algorithm for lexicographical shortest path ---\n    \n    # dist[i] will store the pair (number_of_bridges, length)\n    dist = {i: (float('inf'), float('inf')) for i in range(n)}\n    dist[u] = (0, 0)\n\n    # Priority queue stores (bridges, length, vertex)\n    pq = [(0, 0, u)]\n\n    while pq:\n        b_curr, l_curr, v_curr = heapq.heappop(pq)\n\n        # If we found a better path already, skip\n        if (b_curr, l_curr) > dist[v_curr]:\n            continue\n\n        if v_curr == v:\n            # Since Dijkstra explores paths in increasing cost order,\n            # the first time we reach v, it's via an optimal path.\n            break\n\n        for v_next in adj[v_curr]:\n            edge = tuple(sorted((v_curr, v_next)))\n            b_edge = 1 if edge in bridges else 0\n            l_edge = 1\n            \n            b_new = b_curr + b_edge\n            l_new = l_curr + l_edge\n\n            # Lexicographical comparison\n            if (b_new, l_new)  dist[v_next]:\n                dist[v_next] = (b_new, l_new)\n                heapq.heappush(pq, (b_new, l_new, v_next))\n\n    final_dist = dist[v]\n    if final_dist == (float('inf'), float('inf')):\n        return [-1, -1]\n    else:\n        return [final_dist[0], final_dist[1]]\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        {'n': 8, 'edges': {(0, 1), (1, 2), (2, 3), (3, 0), (1, 7), (3, 4), (4, 5), (5, 6), (6, 4)}, 'u': 0, 'v': 5},\n        # Test case 2\n        {'n': 5, 'edges': {(0, 1), (1, 2), (2, 3), (3, 4), (4, 0)}, 'u': 0, 'v': 3},\n        # Test case 3\n        {'n': 4, 'edges': {(0, 1), (2, 3)}, 'u': 0, 'v': 3},\n        # Test case 4\n        {'n': 7, 'edges': {(0, 1), (1, 2), (1, 3), (3, 4), (3, 5), (5, 6)}, 'u': 2, 'v': 6},\n        # Test case 5\n        {'n': 3, 'edges': {(0, 1), (1, 2)}, 'u': 1, 'v': 1},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = find_optimal_path(case['n'], case['edges'], case['u'], case['v'])\n        results.append(result)\n\n    # The final output must be a single line in the specified format.\n    # We use join and map to construct the string representation of the list of lists.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}