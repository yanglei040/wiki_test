{
    "hands_on_practices": [
        {
            "introduction": "理论是实践的基石。在深入研究算法实现之前，通过一个思想实验来检验我们对双连通分量、割点和图结构之间基本关系的理解至关重要。这个练习要求我们基于给定的块（block）和割点数量，推导图的最小顶点和边数，这能有效锻炼我们对块-割树（block-cut tree）这一核心抽象结构的直观感知。",
            "id": "1484292",
            "problem": "一个连通简单图 $G$ 有 5 个块和 4 个割点。关于这种图的最小顶点数 $v_{\\min}$ 和最小边数 $e_{\\min}$，下列哪个陈述是正确的？",
            "solution": "设 $G$ 是一个有 $b=5$ 个块和 $c=4$ 个割点的连通简单图。考虑 $G$ 的块-割点树 $T$。这是一棵二分树，其二分部由 $b$ 个块节点和 $c$ 个割点节点组成，当一个割点属于一个块时，对应的块节点和割点节点之间有一条边。由于 $T$ 是一棵树，\n$$\n|V(T)|=b+c,\\qquad |E(T)|=b+c-1.\n$$\n因此，每一分部中节点的度数之和都等于 $b+c-1$。此外，每个割点至少属于两个块，所以每个割点节点的度至少为 $2$。因此，\n$$\n\\sum_{\\text{cut vertices}} \\deg_{T}=\\;b+c-1\\;\\ge\\;2c\\;\\;\\Longrightarrow\\;\\;c\\le b-1.\n$$\n当 $b=5$ 和 $c=4$ 时，等式 $b+c-1=2c$ 成立，即 $b+c-1=8=2c$，因此每个割点节点的度恰好为 $2$。在一棵树中，如果所有割点节点的度都为 $2$，那么 $T$ 必须是一条以块节点为起点和终点的路径。因此，这 $5$ 个块节点的度为\n$$\n\\{1,2,2,2,1\\}.\n$$\n\n为了最小化 $G$ 的顶点数，注意到每个属于多个块的顶点都是一个割点，而每个非割点只属于一个块。如果一个块节点在 $T$ 中的度为 $d_{B}$，则相应的块恰好包含 $d_{B}$ 个割点。对于一个给定的 $d_{B}$，一个块所需的最小非割点数为：\n- 如果块是 $K_{2}$（桥），对于 $d_{B}\\in\\{1,2\\}$，它恰好有 $2-d_{B}$ 个非割点。\n- 如果块是 2-连通的，最小值为 $\\max(3-d_{B},0)$，这可以通过一个穿过 $d_{B}$ 个割点的圈（对于 $d_{B}\\ge 3$）、一个三角形（对于 $d_{B}=2$）来实现，而对于 $d_{B}=1$ 则需要额外两个顶点。\n\n对于 $d_{B}\\in\\{1,2\\}$，使用 $K_{2}$ 可以最小化非割点数。由于我们的块度为 $\\{1,2,2,2,1\\}$，选择所有块都为 $K_{2}$ 可得总非割点数为\n$$\n(2-1)+(2-1)+3\\cdot(2-2)=1+1+0=2.\n$$\n因此，最小顶点数为\n$$\nv_{\\min}=c+\\text{(非割点数)}=4+2=6.\n$$\n\n对于边，由于边集被 $b$ 个块划分，且每个块至少有一条边，我们有\n$$\ne\\ge b=5.\n$$\n这个下界可以通过将所有块都设为 $K_{2}$ 并排列成一条有 $5$ 条边的路径（即路径 $P_{6}$）来达到。那么\n$$\ne_{\\min}=5.\n$$\n这个构造也恰好有 $c=4$ 个割点（$P_{6}$ 的 $4$ 个内部顶点），从而证实了可行性。因此，正确的陈述是，这样的图存在，且最小顶点数为 $v_{\\min}=6$，最小边数为 $e_{\\min}=5$。",
            "answer": "$$\\boxed{D}$$"
        },
        {
            "introduction": "将理论模型转化为精确的代码是算法学习的关键一步。这个练习要求我们从零开始，实现一个完整的算法来构建给定图的块-割树。这不仅需要我们正确地找出所有的割点和双连通分量，还需要我们精心设计数据结构，并按照明确的规则对树的节点进行索引和排序，最终输出其邻接表表示。",
            "id": "3214787",
            "problem": "给定一个无向简单图 $G$，其顶点集为有限集 $V$，边集为 $E$。目标是设计、论证并实现一个算法，该算法用于构建图 $G$ 的块割树的邻接表表示。块割树是一种二分结构，其节点由块（极大的2-顶点连通子图，以及桥边和孤立顶点）和割点（关节点）组成，每条边连接一个割点与其所属的每一个块。\n\n该问题的基础是割点（关节点）的定义、顶点连通性的概念，以及经过充分检验的图遍历事实，即深度优先搜索（DFS）可用于发现DFS树中的父子关系、识别返祖边，并计算反映通过返祖边可达性的发现时间和low值。根据这些定义和遍历事实，你需要推导出一个明确的算法，用于识别块和割点，并构建块割树。\n\n你的算法必须：\n\n- 接受一个无向简单图 $G$ 作为输入，其顶点标记为从 $0$ 到 $n-1$ 的整数，其中 $n$ 是顶点数。\n- 识别 $G$ 的所有关节点和所有块，包括将单个桥边和孤立顶点视为块。\n- 构建块割树，它是一个二分图，其节点对应于 $G$ 的关节点和块，其边连接一个割点节点到包含该割点的每个块节点。\n- 使用以下确定性的索引和排序约定，输出块割树的邻接表：\n  1. 设 $a$ 为关节点数量，$b$ 为块数量。\n  2. 关节点从 $0$ 到 $a-1$ 进行索引，按其原始顶点标号的升序排列。\n  3. 块节点从 $a$ 到 $a+b-1$ 进行索引，按其块键的升序排列。块键定义为一个元组，由块中最小的顶点标号、块的大小（顶点数）以及其顶点的字典序升序列表组成。\n  4. 邻接表必须是一个长度为 $a+b$ 的列表，其第 $i$ 个条目是块割树中节点 $i$ 的邻居索引的排序列表。\n  5. 对于没有顶点的图（$n=0$），输出应为空列表 $[]$。\n\n你的程序必须产生单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。每个结果对应一个测试图，其本身是一个嵌套列表，表示该图的块割树的邻接表。例如，输出可能看起来像 $[ [\\dots], [\\dots], \\dots ]$，其中每个内部列表是一个测试用例的邻接表。\n\n测试套件：\n在以下输入图集上实现并运行你的算法。每个图由一对 $(n, E)$ 指定，其中 $n$ 是顶点数，$E$ 是表示边的无序顶点对列表。\n\n- 测试 $1$（连通，多个块和关节点）：\n  $$n = 9,\\quad E = \\{(0,1),(1,2),(2,0),(1,3),(3,4),(4,5),(5,3),(4,6),(6,7),(7,8),(8,6)\\}.$$\n- 测试 $2$（单环，无关节点）：\n  $$n = 4,\\quad E = \\{(0,1),(1,2),(2,3),(3,0)\\}.$$\n- 测试 $3$（单边，无关节点）：\n  $$n = 2,\\quad E = \\{(0,1)\\}.$$\n- 测试 $4$（不连通，有孤立顶点和桥）：\n  $$n = 5,\\quad E = \\{(1,2),(2,3)\\},\\text{，其中顶点 }0\\text{ 和 }4\\text{ 是孤立的}。$$\n- 测试 $5$（空图）：\n  $$n = 0,\\quad E = \\{\\}.$$\n\n答案规范：\n- 对于每个测试用例，答案必须是一个整数列表的列表，具体是根据上述规则构建的块割树的邻接表。\n- 最终输出必须是单行：所有测试用例邻接表的列表，以逗号分隔并用方括号括起。",
            "solution": "用户要求设计并实现一个算法，用于为给定的无向简单图 $G=(V, E)$ 构建块割树。\n\n### 步骤 1：提取已知信息\n- **输入**：一个无向简单图 $G$，由顶点数 $n$（标记为 $0$ 到 $n-1$）和边集 $E$ 指定。\n- **核心定义**：\n    - **割点（关节点）**：移除后会增加图的连通分量数量的顶点。\n    - **块**：一个极大的2-顶点连通子图。桥（移除后会增加连通分量数量的边）和孤立顶点也被视作块。\n    - **块割树**：一个二分图，其节点代表 $G$ 的块和割点。如果对应的割点属于对应的块，则在割点节点和块节点之间存在一条边。\n- **输出**：块割树的邻接表。\n- **输出格式和索引约定**：\n    1.  设 $a$ 为关节点数量，$b$ 为块数量。\n    2.  关节点从 $0, \\dots, a-1$ 进行索引，按其原始顶点标号的升序排列。\n    3.  块节点从 $a, \\dots, a+b-1$ 进行索引，按“块键”排序。\n    4.  **块键**：一个元组 `(块中最小顶点标号, 块的大小, 其顶点的字典序升序列表)`。\n    5.  最终输出是一个长度为 $a+b$ 的邻接表，其中第 $i$ 个条目是节点 $i$ 的邻居的排序列表。\n    6.  对于空图（$n=0$），输出必须是空列表 `[]`。\n- **测试用例**：提供了五个特定的测试图。\n\n### 步骤 2：使用提取的已知信息进行验证\n根据验证标准对问题进行评估：\n- **科学性**：该问题植根于图论的基本、公认的概念，即顶点连通性、双连通分量（块）和深度优先搜索（DFS）算法。所提供的割点、块和块割树的定义都是标准的。使用DFS寻找这些结构是一种经典且正确的方法，通常归功于 John Hopcroft 和 Robert Tarjan。该问题在科学上是合理的。\n- **适定性**：该问题是适定的。输入格式定义清晰。输出格式，以及至关重要的块割树节点的确定性索引和排序规则，确保了对于任何给定的输入图都存在唯一的解。\n- **客观性**：问题陈述是客观、精确的，没有任何主观或模糊的语言。所有术语要么是图论中的标准术语，要么有明确的定义。\n\n### 步骤 3：结论与行动\n该问题是**有效的**。这是一个标准的、定义明确的算法任务，具有清晰的要求。我现在将继续提供一个完整、合理的解决方案。\n\n### 基于原理的解决方案\n构建块割树需要两个主要步骤：首先，识别图 $G$ 的关节点和块；其次，根据它们之间的关系构建树结构。寻找块和关节点的经典算法基于图的深度优先搜索（DFS）。\n\n**1. 通过DFS寻找关节点和块**\n\n我们从任意顶点开始执行DFS遍历。在遍历过程中，我们为每个顶点 $u$ 维护两个关键信息：\n- **发现时间 `disc[u]`**：首次发现 $u$ 的“时间”（每次访问顶点时递增的计数器）。\n- **Low-Link值 `low[u]`**：从 $u$（包括自身）出发，通过在DFS树中遍历零条或多条树边和最多一条返祖边所能到达的最低发现时间。\n\n`low[u]` 的计算方式是取以下各项的最小值：\n1.  `disc[u]`。\n2.  对于任意顶点 $w$，如果 $(u, w)$ 是DFS树中的一条返祖边，则取 `disc[w]`。\n3.  对于 $u$ 在DFS树中的任意子节点 $v$，则取 `low[v]`。\n\n为了管理块的识别，我们使用一个栈来存储遍历过的边。\n\n算法流程如下：\n我们为所有顶点初始化 `disc`、`low` 和 `visited` 数组。我们遍历每个顶点 $u \\in V$。如果 $u$ 尚未被访问，我们从 $u$ 开始进行递归DFS。\n\n**递归DFS函数 `dfs(u, p)`（从顶点 `u` 开始，其父节点为 `p`）：**\n1.  将 $u$ 标记为已访问。将 `disc[u]` 和 `low[u]` 设置为当前时间，并增加时间计数器。\n2.  记录 $u$ 在DFS树中的子节点数量，称之为 `children`。\n3.  对于 $u$ 的每个邻居 $v$：\n    a. 如果 $v$ 是父节点 $p$，则忽略。\n    b. 如果 $v$ 已被访问（即 `visited[v]` 为真），则 $(u, v)$ 是一条返祖边。我们更新 `low[u] = min(low[u], disc[v])` 并将边 $(u, v)$ 推入我们的边栈。仅当 `disc[v]  disc[u]` 时才推入，以确保每条边只处理一次。\n    c. 如果 $v$ 未被访问，则 $(u, v)$ 是一条树边。我们增加 `children` 计数，将 $(u, v)$ 推入边栈，并递归调用 `dfs(v, u)`。递归调用返回后，我们更新 `low[u] = min(low[u], low[v])`。\n\n**识别关节点和块：**\n在步骤3c中，当对子节点 $v$ 的递归调用返回到 $u$ 后，我们检查关节点条件：\n- 一个顶点 $u$ 是关节点，如果满足以下任一条件：\n    1. $u$ 是DFS树的根（即 $p$ 为空/无效）且 `children > 1`。\n    2. $u$ 不是根，且存在一个子节点 $v$ 使得 `low[v] >= disc[u]`。\n\n第二个条件 `low[v] >= disc[u]` 表示从子节点 $v$ 探索的子图无法在不经过 $u$ 的情况下到达 $u$ 的任何祖先。这一发现也标志着一个新块的识别。要提取这个块，我们从边栈中弹出边，直到弹出边 $(u, v)$。这些弹出的边所涉及的所有顶点构成新的块。\n\n**处理连通分量级别的双连通性和孤立顶点：**\n- 如果对一个连通分量的初始 `dfs(u, p)` 调用返回后，在执行期间添加到栈中的边仍然存在，这意味着整个连通分量是双连通的。这些剩余的边形成一个单独的块。\n- 在遍历所有顶点并对所有连通分量运行DFS后，任何未被访问过的顶点都是孤立顶点。每个孤立顶点形成一个大小为一的块。\n\n**2. 构建块割树**\n\n在识别出所有关节点（假设有 $a$ 个）和所有块（有 $b$ 个）之后，我们开始构建树。\n1.  **节点索引**：\n    - 创建一个唯一的关节点标号的排序列表。这给出了从顶点标号到其关节点索引（从 $0$ 到 $a-1$）的映射。\n    - 对于每个块（表示为顶点标号的集合），计算其在问题中定义的键：`(min_vertex, size, sorted_vertices)`。根据这个键对所有块进行排序。这给出了从块到其块节点索引（从 $a$ 到 $a+b-1$）的映射。\n\n2.  **构建邻接表**：\n    - 创建一个大小为 $a+b$ 的邻接表 `adj_bctree`。\n    - 对于每个块，遍历其包含的顶点。如果一个顶点是关节点，找到其对应的关节点索引，假设为 `ap_idx`。设当前块的节点索引为 `block_idx`。\n    - 通过将每个节点追加到对方的邻接表中，在 `ap_idx` 和 `block_idx` 之间添加一条块割树的边：`adj_bctree[ap_idx].append(block_idx)` 和 `adj_bctree[block_idx].append(ap_idx)`。\n\n3.  **定稿**：\n    - 根据要求，对 `adj_bctree` 中每个节点的邻居列表进行排序。\n    - 空图（$n=0$）的特殊情况导致一个空的邻接表 `[]`。\n\n这种结构化的、基于原理的方法正确地实现了所需的算法，并遵守了所有指定的约定，以获得确定性和有效的解决方案。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all given test cases.\n    \"\"\"\n    test_cases = [\n        # Test 1 (connected, multiple blocks and articulation points)\n        (9, [(0, 1), (1, 2), (2, 0), (1, 3), (3, 4), (4, 5), (5, 3), (4, 6), (6, 7), (7, 8), (8, 6)]),\n        # Test 2 (single cycle, no articulation points)\n        (4, [(0, 1), (1, 2), (2, 3), (3, 0)]),\n        # Test 3 (single edge, no articulation points)\n        (2, [(0, 1)]),\n        # Test 4 (disconnected, isolated vertices and bridges)\n        (5, [(1, 2), (2, 3)]),\n        # Test 5 (empty graph)\n        (0, [])\n    ]\n\n    results = []\n    for n, E in test_cases:\n        result = build_block_cut_tree(n, E)\n        results.append(result)\n\n    # The final output is a string representation of a list of lists.\n    # Python's default print for lists matches the required format.\n    print(results)\n\ndef build_block_cut_tree(n, edges):\n    \"\"\"\n    Computes the adjacency list of the block-cut tree for a given graph.\n    \"\"\"\n    if n == 0:\n        return []\n\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    visited = [False] * n\n    disc = np.full(n, -1, dtype=int)\n    low = np.full(n, -1, dtype=int)\n    time = 0\n    edge_stack = []\n    blocks = []\n    articulation_points = set()\n\n    def find_biconnected_components(u, p):\n        nonlocal time\n        visited[u] = True\n        disc[u] = low[u] = time\n        time += 1\n        children = 0\n\n        for v in adj[u]:\n            if v == p:\n                continue\n\n            # Ensure each undirected edge is pushed onto the stack only once\n            if not visited[v]:\n                children += 1\n                edge_stack.append((u, v))\n                find_biconnected_components(v, u)\n                low[u] = min(low[u], low[v])\n\n                if (p == -1 and children > 1) or (p != -1 and low[v] >= disc[u]):\n                    articulation_points.add(u)\n                    \n                    new_block = set()\n                    while True:\n                        e_u, e_v = edge_stack.pop()\n                        new_block.add(e_u)\n                        new_block.add(e_v)\n                        if (e_u, e_v) == (u, v):\n                            break\n                    blocks.append(frozenset(new_block))\n            elif disc[v]  disc[u]: # Back edge\n                low[u] = min(low[u], disc[v])\n                edge_stack.append((u, v))\n\n    for i in range(n):\n        if not visited[i]:\n            # For each component, find its biconnected components\n            stack_len_before = len(edge_stack)\n            find_biconnected_components(i, -1)\n            \n            # If edges remain on the stack for this component, they form a single biconnected component\n            if len(edge_stack) > stack_len_before:\n                new_block = set()\n                while len(edge_stack) > stack_len_before:\n                    e_u, e_v = edge_stack.pop()\n                    new_block.add(e_u)\n                    new_block.add(e_v)\n                blocks.append(frozenset(new_block))\n\n    # Identify vertices in blocks to find isolated ones\n    vertices_in_blocks = set()\n    for block in blocks:\n        vertices_in_blocks.update(block)\n    \n    # Isolated vertices form their own blocks\n    for i in range(n):\n        if i not in vertices_in_blocks:\n            blocks.append(frozenset([i]))\n\n    # Sort articulation points and blocks to create deterministic indices\n    sorted_aps = sorted(list(articulation_points))\n    ap_map = {label: i for i, label in enumerate(sorted_aps)}\n    num_aps = len(sorted_aps)\n\n    def get_block_key(block):\n        v_list = sorted(list(block))\n        return (v_list[0], len(v_list), tuple(v_list))\n\n    sorted_blocks = sorted(blocks, key=get_block_key)\n    block_map = {block: i + num_aps for i, block in enumerate(sorted_blocks)}\n    num_blocks = len(sorted_blocks)\n\n    num_bct_nodes = num_aps + num_blocks\n    bct_adj = [[] for _ in range(num_bct_nodes)]\n\n    # Build the block-cut tree edges\n    for block in sorted_blocks:\n        block_idx = block_map[block]\n        for vertex in block:\n            if vertex in ap_map:\n                ap_idx = ap_map[vertex]\n                bct_adj[ap_idx].append(block_idx)\n                bct_adj[block_idx].append(ap_idx)\n\n    # Sort neighbor lists as required\n    for i in range(num_bct_nodes):\n        bct_adj[i].sort()\n        \n    return bct_adj\n\nsolve()\n\n```"
        },
        {
            "introduction": "学习一个数据结构或算法的最终目的是为了解决实际问题。这个练习展示了块-割树的强大应用价值：解决图的双连通增广问题。我们的任务是计算最少需要添加多少条边才能使一个图变为双连通的，通过将问题转化并分析其块-割树的“叶子”节点，一个复杂的图论优化问题将迎刃而解。",
            "id": "3209569",
            "problem": "设 $G=(V,E)$ 是一个有限、简单、无向的连通图，其中 $|V|=n$ 且 $|E|=m$，$n \\ge 3$。如果移除顶点 $v \\in V$（及其所有关联的边）会增加图的连通分量数量，则该顶点是一个割点。如果一个图是连通的且没有割点，则该图是双连通（two-vertex-connected）的。你需要编写一个完整、可运行的程序，对于所提供测试套件中的每个图，计算为了使图成为双连通图，需要在当前不相邻的不同顶点之间添加的最少边数，且不能产生平行边或自环。\n\n你的程序必须基于基本原理构建答案，使用割点和双连通分量的核心定义，以及诸如深度优先搜索（DFS）树结构和 low-link 值的存在性等经过充分检验的算法事实。程序不得依赖于预设的快捷公式；相反，它必须识别割点和双连通分量，推导由这些分量和割点导出的块-割点树，并推断出需要添加的最少边数。\n\n该测试套件包含 $6$ 个连通图，每个图由其顶点数 $n$ 和边集 $E$ 指定（所有顶点由从 $0$ 到 $n-1$ 的整数标记）：\n\n- 测试用例 $1$：$n=5$，$E=\\{(0,1),(1,2),(2,3),(3,4),(4,0)\\}$（一个 5 顶点的环）。\n- 测试用例 $2$：$n=4$，$E=\\{(0,1),(1,2),(2,3)\\}$（一条 4 顶点的路径）。\n- 测试用例 $3$：$n=7$，$E=\\{(0,1),(0,2),(0,3),(0,4),(0,5),(0,6)\\}$（一个以 0 为中心、有 6 个叶子节点的星形图）。\n- 测试用例 $4$：$n=5$，$E=\\{(0,1),(1,2),(2,0),(2,3),(3,4),(4,2)\\}$（两个共享一个顶点的三角形）。\n- 测试用例 $5$：$n=6$，$E=\\{(0,1),(1,2),(2,3),(3,0),(1,4),(4,5)\\}$（一个环，其中一个环顶点上连接了一条长度为 2 的尾巴）。\n- 测试用例 $6$：$n=6$，$E=\\{(0,1),(1,2),(1,3),(3,4),(3,5)\\}$（一棵树，其内部顶点为 1 和 3）。\n\n你的程序应生成单行输出，其中包含六个测试用例的结果，按顺序排列，格式为一个用方括号括起来的逗号分隔列表，例如 $[r_1,r_2,r_3,r_4,r_5,r_6]$，其中每个 $r_i$ 是为测试用例 $i$ 添加的最少边数的整数值。",
            "solution": "该问题已经过验证，被认为是图论领域中一个定义明确、有科学依据的问题。给定条件是完整、一致且可形式化的。\n\n### 基于原理的解决方案设计\n\n核心任务是确定为使一个连通图 $G$ 成为双连通图所需添加的最小边数。一个图是双连通的，当且仅当它是连通的且不包含任何割点。割点（或称 cut vertex）是一个顶点，移除它会增加图的连通分量数量。\n\n#### 1. 块-割点树结构\n\n该问题可以通过考虑图在其双连通分量（BCCs 或 块）和割点方面的结构来分析。这些实体之间的关系可以通过一个**块-割点树** $T_{BC}$ 来建模。\n- $T_{BC}$ 的顶点对应于原始图 $G$ 的割点和双连通分量。\n- 在 $T_{BC}$ 中，当且仅当对应于割点顶点 $v_{ap}$ 的顶点是 $G$ 中块 $B$ 的成员时，$v_{ap}$ 和块顶点 $B$ 之间存在一条边。\n- 对于任何连通图 $G$，其对应的块-割点结构 $T_{BC}$ 是一棵树。\n\n将原始图 $G$ 变为双连通等价于将其块-割点树 $T_{BC}$ 转换为单个节点。当所有原始的双连通分量和割点合并成一个单一的、更大的双连通分量时，这种概念性转换就发生了。\n\n#### 2. 策略：连接叶子块\n\n图连通性的“弱点”是其“悬挂”组件。在块-割点树中，这些由叶子节点表示。由于树中的任何路径都必须连接两个叶子节点（或是单个节点），因此 $T_{BC}$ 中的叶子节点总是块顶点（假设树不是平凡的）。如果一个块 $B$ 在 $T_{BC}$ 中是叶子，那么它在图 $G$ 中恰好包含一个割点。我们称这些为**叶子块**。\n\n为了消除割点，我们必须在被割点分隔开的图的各个部分之间引入新的路径。实现这一点的最有效方法是在不同的叶子块的顶点之间添加边。在叶子块 $B_1$ 中的一个顶点和另一个叶子块 $B_2$ 中的一个顶点之间添加一条边，会在 $G$ 中创建一个新环。这会产生将 $B_1$、$B_2$ 以及它们在 $T_{BC}$ 之间的整个块和割点路径合并成一个单一的、更大的双连通分量的效果。\n\n此操作有效地减少了概念性块-割点树中叶子的数量。如果我们有 $l$ 个叶子块，我们可以将它们配对。每对之间添加一条边会使叶子数量减少两个。将所有 $l$ 个叶子连接成一个超级分量所需的最少边数为 $\\lceil l/2 \\rceil$。\n\n- 如果图已经是双连通的，它由单个块组成，没有割点。在这种情况下，叶子块的数量为 $l=0$，公式正确地得出 $\\lceil 0/2 \\rceil = 0$。\n- 如果图不是双连通的，它必须至少有一个割点，因此至少有两个叶子块（$l \\ge 2$）。\n\n#### 3. 算法实现\n\n总体算法如下：\n\n**步骤 1：寻找割点和双连通分量**\n这是算法的核心部分，通过一次深度优先搜索（DFS）遍历来执行。对于每个顶点 $u \\in V$，我们维护两个值：\n- $disc[u]$：在 DFS 期间发现 $u$ 的时间，即首次访问 $u$ 的“时间”（一个计数器）。\n- $low[u]$：从 $u$ 出发（包括通过其自身的 DFS 子树），通过遍历零条或多条树边和最多一条后向边可达到的最低发现时间。\n\n使用一个边栈来跟踪双连通分量的边。在从顶点 $u$ 到其邻居 $v$ 的 DFS 过程中：\n- 如果顶点 $u$ 是 DFS 树的根且有两个以上子节点，或者 $u$ 不是根且存在一个子节点 $v$ 使得 $low[v] \\ge disc[u]$，则 $u$ 被识别为割点。\n- 同样是这个条件，$low[v] \\ge disc[u]$，也标志着一个双连通分量（BCC）刚刚被完全遍历。该 BCC 的边位于边栈的顶部，可以被弹出，直到边 $(u,v)$ 被移除。这些弹出的边中的所有顶点集合构成了该 BCC。\n\n**步骤 2：计算叶子块的数量**\n在 DFS 完成且所有割点和 BCC 都被识别后，我们计算叶子块的数量 $l$。如果一个 BCC 中，其顶点是主图割点的数量恰好为一个，则该 BCC 是一个叶子块。\n\n**步骤 3：计算最少边数**\n需要添加的最少边数由公式 $\\lceil l / 2 \\rceil$ 给出。这可以使用整数算术计算为 $(l + 1) // 2$。如果图已经是双连通的，算法将只找到一个 BCC 且没有割点，从而得到 $l=0$ 和答案 $0$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the biconnectivity augmentation problem for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        # Test case 1: n=5, a cycle graph\n        (5, [(0, 1), (1, 2), (2, 3), (3, 4), (4, 0)]),\n        # Test case 2: n=4, a path graph\n        (4, [(0, 1), (1, 2), (2, 3)]),\n        # Test case 3: n=7, a star graph\n        (7, [(0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (0, 6)]),\n        # Test case 4: n=5, two triangles sharing a vertex\n        (5, [(0, 1), (1, 2), (2, 0), (2, 3), (3, 4), (4, 2)]),\n        # Test case 5: n=6, a cycle with a tail\n        (6, [(0, 1), (1, 2), (2, 3), (3, 0), (1, 4), (4, 5)]),\n        # Test case 6: n=6, a tree\n        (6, [(0, 1), (1, 2), (1, 3), (3, 4), (3, 5)]),\n    ]\n\n    results = []\n    for n, edges in test_cases:\n        solver = BiconnectivityAugmenter(n, edges)\n        result = solver.compute_min_edges()\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nclass BiconnectivityAugmenter:\n    \"\"\"\n    A class to find the minimum number of edges to make a graph biconnected.\n    \"\"\"\n    def __init__(self, n, edges):\n        self.n = n\n        self.adj = [[] for _ in range(n)]\n        for u, v in edges:\n            self.adj[u].append(v)\n            self.adj[v].append(u)\n        \n        # State for the BCC algorithm\n        self.time = 0\n        self.disc = [-1] * n\n        self.low = [-1] * n\n        self.edge_stack = []\n        \n        self.articulation_points = set()\n        self.bccs = []\n\n    def _find_aps_and_bccs(self, u, p):\n        \"\"\"\n        Recursive DFS utility to find articulation points and biconnected components.\n        'u' is the current vertex, 'p' is its parent in the DFS tree.\n        \"\"\"\n        self.disc[u] = self.low[u] = self.time\n        self.time += 1\n        children = 0\n\n        for v in self.adj[u]:\n            if v == p:\n                continue\n\n            if self.disc[v] != -1:  # Visited vertex, so a back edge\n                self.low[u] = min(self.low[u], self.disc[v])\n                if self.disc[v]  self.disc[u]:\n                    self.edge_stack.append((u, v))\n            else:  # Not visited, so a tree edge\n                children += 1\n                self.edge_stack.append((u, v))\n                self._find_aps_and_bccs(v, u)\n                \n                self.low[u] = min(self.low[u], self.low[v])\n\n                # Check for articulation point u\n                if (p == -1 and children > 1) or (p != -1 and self.low[v] >= self.disc[u]):\n                    self.articulation_points.add(u)\n                \n                # If low[v] >= disc[u], u is an AP and a new BCC is found\n                if self.low[v] >= self.disc[u]:\n                    new_bcc_edges = []\n                    while True:\n                        edge = self.edge_stack.pop()\n                        new_bcc_edges.append(edge)\n                        if edge == (u, v) or edge == (v, u):\n                            break\n                    \n                    bcc_nodes = set()\n                    for n1, n2 in new_bcc_edges:\n                        bcc_nodes.add(n1)\n                        bcc_nodes.add(n2)\n                    self.bccs.append(bcc_nodes)\n\n    def compute_min_edges(self):\n        \"\"\"\n        Computes the minimum number of edges to add to make the graph biconnected.\n        \"\"\"\n        # A connected graph with n  3 is always biconnected.\n        if self.n  3:\n            return 0\n            \n        # Run DFS from vertex 0. The graph is connected, so one run is sufficient.\n        self._find_aps_and_bccs(0, -1)\n\n        # If the whole graph is one BCC, the stack will not be empty.\n        if self.edge_stack:\n            bcc_nodes = set()\n            for u, v in self.edge_stack:\n                bcc_nodes.add(u)\n                bcc_nodes.add(v)\n            self.bccs.append(bcc_nodes)\n            self.edge_stack.clear()\n        \n        # If there are no articulation points, the graph is already biconnected.\n        # This is equivalent to having 0 or 1 BCCs.\n        if len(self.bccs) = 1:\n            return 0\n\n        # Count leaf blocks: BCCs with exactly one articulation point.\n        leaf_blocks = 0\n        for bcc in self.bccs:\n            ap_count_in_bcc = 0\n            for node in bcc:\n                if node in self.articulation_points:\n                    ap_count_in_bcc += 1\n            if ap_count_in_bcc == 1:\n                leaf_blocks += 1\n        \n        # The number of edges to add is ceil(number of leaf blocks / 2).\n        return int(np.ceil(leaf_blocks / 2))\n\nif __name__ == \"__main__\":\n    solve()\n\n```"
        }
    ]
}