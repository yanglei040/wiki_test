{
    "hands_on_practices": [
        {
            "introduction": "To build a solid understanding of the divide-and-conquer approach for the closest pair problem, we begin with a simplified one-dimensional case. This exercise challenges you to adapt the structure of the merge sort algorithm to simultaneously sort a list of points on a line and find the minimum distance between any pair. By focusing on 1D, you can master the recursive decomposition and the logic of the combine step without the geometric complexities of higher dimensions, providing a strong foundation for more advanced versions of the problem .",
            "id": "3252361",
            "problem": "You are given a finite list of real-valued points on the one-dimensional real line. For a list $A$ of size $n$, define the distance between two points $x$ and $y$ as $|x - y|$ and define the closest-pair distance as $d^{\\star} = \\min_{i \\ne j} |A_i - A_j|$ when $n \\ge 2$. If $n  2$, define the closest-pair distance to be $+\\infty$. Design and implement a program that computes the closest-pair distance using the divide-and-conquer structure of merge sort, achieving time complexity $\\mathcal{O}(n \\log n)$. You must not call any built-in sorting procedure; instead, the algorithm must explicitly perform a merge-based divide-and-conquer recursion that both sorts and computes the closest-pair distance.\n\nYour program must return, for each test case, a single nonnegative real number (the closest-pair distance), or $+\\infty$ when the definition specifies it as such. No physical units are involved in this problem. The order relation on real numbers must be treated as the usual total order.\n\nRequired test suite:\n- Case $1$: input $[7,1,5,9,3,2]$.\n- Case $2$: input $[1,2,4,8,16]$.\n- Case $3$: input $[10,8,6,4,2,0]$.\n- Case $4$: input $[5,5,5,5]$.\n- Case $5$: input $[-10,-3,0,2,7]$.\n- Case $6$: input $[42]$.\n- Case $7$: input $[]$.\n- Case $8$: input $[-1000000,1000000,-999999]$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[result_1,result_2,\\dots]$) in the same order as the test suite. Each result must be a real number (print $+\\infty$ as the floating-point infinity value).",
            "solution": "The problem asks for the design and implementation of an algorithm to find the closest-pair distance in a one-dimensional list of points, $A$. The distance between two points $x$ and $y$ is defined as $|x - y|$. For a list of size $n$, the closest-pair distance $d^{\\star}$ is defined as $d^{\\star} = \\min_{i \\ne j} |A_i - A_j|$ for $n \\ge 2$, and $d^{\\star} = +\\infty$ for $n  2$. The algorithm must adhere to a divide-and-conquer strategy based on the structure of merge sort, achieving a time complexity of $\\mathcal{O}(n \\log n)$, and must be implemented without using any built-in sorting functions.\n\nThe problem statement is valid. It is a well-defined computational problem grounded in standard mathematical concepts (real numbers, absolute distance, minima) and algorithmic theory (divide-and-conquer, time complexity). All terms are objective and precisely defined, and the constraints are self-consistent.\n\nThe core principle for solving this problem is to integrate the search for the minimum distance into the recursive structure of the merge sort algorithm. A naive brute-force approach would compare every pair of points, resulting in an $\\mathcal{O}(n^2)$ time complexity, which is too slow. A more efficient approach, which we will develop, leverages the sorting process to reduce the number of comparisons needed.\n\nA key mathematical insight for the one-dimensional case simplifies the problem significantly: if a list of points is sorted, the closest pair of points must be adjacent in the sorted list. This can be proven by contradiction. Assume the closest pair of points $(x, y)$ with $x  y$ is not adjacent in the sorted list. This implies the existence of at least one other point $z$ such that $x  z  y$. The distance $|z - x| = z - x$ is necessarily smaller than the distance $|y - x| = y - x$. This contradicts the assumption that $(x, y)$ is the closest pair. Therefore, the closest pair must be adjacent.\n\nThis insight suggests an algorithm: first sort the list $A$ in $\\mathcal{O}(n \\log n)$ time, and then perform a single linear scan ($\\mathcal{O}(n)$ time) to find the minimum distance between adjacent elements. However, the problem statement requires an integrated algorithm where the recursion **both sorts and computes** the distance. We can design a recursive function that accomplishes this by returning both the sorted list and the minimum distance found within that list at each step.\n\nLet us define a recursive function, $\\text{RecursiveClosestPair}(A)$, which takes a list $A$ of size $n$ and returns a tuple $(A_{\\text{sorted}}, d)$, where $A_{\\text{sorted}}$ is the sorted version of $A$ and $d$ is the closest-pair distance among the elements of $A$.\n\nThe structure of the algorithm follows the classic divide-and-conquer paradigm:\n\n1.  **Base Case**: If the list $A$ has $n  2$ elements (i.e., $n=0$ or $n=1$), no pairs can be formed. According to the problem definition, the closest-pair distance is $+\\infty$. The list is already sorted. Thus, for $n \\le 1$, the function returns $(A, +\\infty)$.\n\n2.  **Divide**: If $n \\ge 2$, the list $A$ is partitioned into two halves of roughly equal size, a left sublist $L$ and a right sublist $R$. We can choose the midpoint $m = \\lfloor n/2 \\rfloor$ such that $L = A[0..m-1]$ and $R = A[m..n-1]$.\n\n3.  **Conquer**: The function is called recursively on the two sublists:\n    *   $(L_{\\text{sorted}}, d_L) = \\text{RecursiveClosestPair}(L)$\n    *   $(R_{\\text{sorted}}, d_R) = \\text{RecursiveClosestPair}(R)$\n    By the end of this step, we have two sorted sublists, $L_{\\text{sorted}}$ and $R_{\\text{sorted}}$, and the minimum distances $d_L$ and $d_R$ internal to each respective sublist.\n\n4.  **Combine**: This step integrates the results from the subproblems to solve the problem for the list $A$.\n    a.  First, the two sorted sublists, $L_{\\text{sorted}}$ and $R_{\\text{sorted}}$, are merged into a single sorted list, $A_{\\text{merged}}$. This is the standard merge procedure from the merge sort algorithm, which takes $\\mathcal{O}(n)$ time.\n    b.  At this stage, we have a complete, sorted list $A_{\\text{merged}}$ containing all elements of the original list $A$. Based on our earlier proof, the overall closest-pair distance for the elements in $A$ must be the minimum distance between adjacent elements in $A_{\\text{merged}}$. We perform a linear scan over $A_{\\text{merged}}$ to find this minimum adjacent distance, let's call it $d_{\\text{adj}}$. This scan also takes $\\mathcal{O}(n)$ time.\n    c.  The true minimum distance for the list $A$ must be the minimum of the distances found in the left subproblem ($d_L$), the right subproblem ($d_R$), and the minimum distance found by inspecting the newly sorted list ($d_{\\text{adj}}$). So, the result for the current level of recursion is $d = \\min(d_L, d_R, d_{\\text{adj}})$.\n    d.  The function then returns the tuple $(A_{\\text{merged}}, d)$.\n\nThe final result for the initial list $A$ is the distance component of the tuple returned by the top-level call to $\\text{RecursiveClosestPair}(A)$.\n\nThe time complexity of this algorithm can be described by the recurrence relation $T(n) = 2T(n/2) + \\mathcal{O}(n)$. The term $2T(n/2)$ arises from the two recursive calls on subproblems of size $n/2$. The $\\mathcal{O}(n)$ term represents the work done in the combine step, which is dominated by the merging of the two sorted sublists and the subsequent linear scan, both of which are linear in the size of the list $n$. According to the Master Theorem, this recurrence solves to $T(n) = \\mathcal{O}(n \\log n)$, satisfying the problem's complexity requirement.\n\nThis design correctly implements a merge-based divide-and-conquer recursion that simultaneously sorts the data and computes the closest-pair distance, thereby satisfying all constraints of the problem.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef closest_pair_recursive(arr):\n    \"\"\"\n    Recursively sorts a list and finds the closest-pair distance within it.\n    This function explicitly follows the merge sort divide-and-conquer structure.\n\n    Args:\n        arr (list): A list of real numbers.\n\n    Returns:\n        tuple: A tuple containing:\n            - list: The sorted version of the input list.\n            - float: The minimum distance between any two distinct points in the list.\n    \"\"\"\n    n = len(arr)\n\n    # Base case: If the list has fewer than 2 elements, the distance is defined as infinity.\n    # A list with 0 or 1 elements is trivially sorted.\n    if n = 1:\n        return arr, np.inf\n\n    # Divide: Split the list into two halves.\n    mid = n // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n\n    # Conquer: Recursively process the left and right halves.\n    # This yields the sorted halves and the minimum distances within each half.\n    left_sorted, d_left = closest_pair_recursive(left_half)\n    right_sorted, d_right = closest_pair_recursive(right_half)\n\n    # Combine: Merge the sorted halves and find the overall minimum distance.\n    # 1. Merge the two sorted lists `left_sorted` and `right_sorted`.\n    merged_arr = []\n    i, j = 0, 0\n    while i  len(left_sorted) and j  len(right_sorted):\n        if left_sorted[i] = right_sorted[j]:\n            merged_arr.append(left_sorted[i])\n            i += 1\n        else:\n            merged_arr.append(right_sorted[j])\n            j += 1\n    \n    # Append any remaining elements from either list.\n    merged_arr.extend(left_sorted[i:])\n    merged_arr.extend(right_sorted[j:])\n\n    # 2. Scan the newly merged and sorted list to find the minimum adjacent distance.\n    # This check implicitly covers pairs where one point was in the original left\n    # half and the other was in the right half.\n    d_adj = np.inf\n    # The loop runs only if there are at least 2 elements to compare.\n    for k in range(len(merged_arr) - 1):\n        dist = merged_arr[k+1] - merged_arr[k]\n        if dist  d_adj:\n            d_adj = dist\n\n    # 3. The minimum distance for the current list is the minimum of the distances\n    # from the left subproblem, the right subproblem, and the adjacent scan.\n    min_dist = min(d_left, d_right, d_adj)\n\n    return merged_arr, min_dist\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [7, 1, 5, 9, 3, 2],\n        [1, 2, 4, 8, 16],\n        [10, 8, 6, 4, 2, 0],\n        [5, 5, 5, 5],\n        [-10, -3, 0, 2, 7],\n        [42],\n        [],\n        [-1000000, 1000000, -999999],\n    ]\n\n    results = []\n    for case in test_cases:\n        # For lists with fewer than 2 elements, the distance is defined as +inf.\n        # This handles the base case at the top level, consistent with the recursion.\n        if len(case)  2:\n            results.append(np.inf)\n        else:\n            # The recursive function returns both the sorted list and the min distance.\n            # We only need the distance for the final result.\n            _, distance = closest_pair_recursive(case)\n            results.append(float(distance))\n\n    # Final print statement in the exact required format.\n    # The representation of np.inf as a string 'inf' is standard.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Having mastered the one-dimensional case, we now generalize the algorithm to three-dimensional space. While the overall divide-and-conquer framework remains the same, the combine step requires a more sophisticated geometric argument to maintain efficiency. This practice is central to understanding the canonical closest-pair algorithm, as it forces you to tackle the challenge of efficiently searching for pairs that cross the dividing plane within a narrow 'strip' . Successfully solving this demonstrates a deep understanding of how geometric constraints can be leveraged to design highly efficient algorithms.",
            "id": "3205365",
            "problem": "You are given a finite set of points in three-dimensional Euclidean space. Let $P = \\{p_i\\}_{i=1}^n$, with each $p_i = (x_i,y_i,z_i) \\in \\mathbb{R}^3$. The task is to design and implement an algorithm based on the divide and conquer paradigm to compute the minimum Euclidean distance between any two distinct points. The algorithm must start from fundamental definitions and laws applicable to algorithm design within data structures and algorithms, including the Euclidean metric properties, recursion, asymptotic complexity, and problem decomposition. The only allowed operations are those derivable from these bases. The algorithm must be scientifically sound and entirely justified using these foundations, not by shortcut formulas or ad hoc hints. The output should be a numerical value for each test case, rounded to six decimal places, with no physical units required.\n\nFundamental base:\n- The Euclidean distance between two points $p=(x,y,z)$ and $q=(x',y',z')$ is defined as $$d(p,q) = \\sqrt{(x-x')^2 + (y-y')^2 + (z-z')^2}$$. This follows from the norm induced by the inner product on $\\mathbb{R}^3$ and the Pythagorean theorem.\n- The divide and conquer paradigm decomposes a problem on $n$ elements into subproblems on approximately $n/2$ elements, solves them recursively, and combines their solutions in time that must be justified as $O(n)$ to achieve the target complexity of $O(n \\log n)$.\n- Asymptotic complexity is measured in the standard Landau notation where $O(\\cdot)$ denotes an upper bound up to a constant factor.\n\nYour program must implement the following:\n- Input is fixed and embedded within the program. The program must compute the minimum Euclidean distance $d^*$ for each test case using a divide and conquer algorithm that:\n  1. Sorts points by their $x$-coordinate.\n  2. Recursively solves the closest-pair problem on the left and right halves to obtain distances $d_L$ and $d_R$.\n  3. Combines the two halves by considering points within a strip of width $2\\delta$ centered at the median $x$-plane, where $\\delta = \\min(d_L,d_R)$, and uses only first-principles geometric constraints to limit candidate comparisons. The correctness argument must rely on the property that if $d(p,q)  \\delta$, then $|x-x'|  \\delta$, $|y-y'|  \\delta$, and $|z-z'|  \\delta$, and that the number of points falling into any cube of side length $\\delta$ with pairwise separation at least $\\delta$ is bounded by a dimension-dependent constant, ensuring a linear-time merge step for fixed dimension.\n  4. Uses no heuristics that bypass these constraints.\n\nEdge cases to handle explicitly:\n- If two points are identical, the minimal distance is $0$, denoted $0.000000$ after rounding.\n- If $n=2$, the minimal distance is the distance between the two points.\n- Points may have negative coordinates and large magnitudes; the algorithm must remain correct and numerically stable.\n\nTest suite:\n- Test case $1$: $[(0,0,0),(10,10,10),(10,10,11),(20,25,30),(5,6,7),(100,-50,25),(-10,12,8)]$\n- Test case $2$: $[(0,0,0),(1,1,1)]$\n- Test case $3$: $[(5,-7,2),(5,-7,2),(0,0,0)]$\n- Test case $4$: $[(0,0,0),(1,0,0),(2,0,0),(3,0,0),(4,0,0),(5,0,0),(6,0,0),(7,0,0),(8,0,0),(9,0,0)]$\n- Test case $5$: $[(0,1,1),(0,2,2),(0,3,3),(0,4,4),(0,4,5)]$\n- Test case $6$: $[(-1000,500,-300),(-999,500,-300),(400,-800,1000),(401,-800,1000)]$\n\nFinal output format:\n- Your program should produce a single line of output containing the results for the above six test cases as a comma-separated list enclosed in square brackets. Each result must be a floating-point number rounded to six decimal places (e.g., $[1.000000,1.732051,0.000000,1.000000,1.000000,1.000000]$). No other text should be printed.",
            "solution": "The problem requires the design and implementation of a divide and conquer algorithm to find the minimum Euclidean distance between any two distinct points in a three-dimensional set $P = \\{p_i\\}_{i=1}^n \\subset \\mathbb{R}^3$. The solution must be derived from first principles of algorithm design and complexity theory.\n\n### Principle-Based Design\n\nThe problem of finding the closest pair of points is a classic problem in computational geometry. A brute-force approach, which checks the distance between every distinct pair of points, involves $\\binom{n}{2} = \\frac{n(n-1)}{2}$ comparisons. This results in a time complexity of $O(n^2)$, which is inefficient for large $n$. The divide and conquer paradigm offers a more efficient approach.\n\nThe core principle of a divide and conquer algorithm is to break a problem into smaller, similar subproblems, solve them recursively, and then combine their solutions to solve the original problem. For the closest pair problem, this can be structured as follows:\n\n1.  **Divide**: Partition the set of points $P$ into two roughly equal-sized subsets, $P_L$ and $P_R$.\n2.  **Conquer**: Recursively find the minimum distance in $P_L$ (let it be $\\delta_L$) and in $P_R$ (let it be $\\delta_R$).\n3.  **Combine**: The minimum distance in the entire set $P$ is the minimum of $\\delta_L$, $\\delta_R$, and the minimum distance between a pair of points $(p_L, p_R)$ where $p_L \\in P_L$ and $p_R \\in P_R$. Let $\\delta = \\min(\\delta_L, \\delta_R)$. If a pair $(p_L, p_R)$ exists with a distance smaller than $\\delta$, this pair must be sought.\n\nThe analysis of the algorithm's complexity depends on the recurrence relation $T(n) = 2T(n/2) + T_{\\text{combine}}(n)$. To achieve the target complexity of $O(n \\log n)$, the combine step, $T_{\\text{combine}}(n)$, must have a complexity of $O(n)$.\n\n### Detailed Algorithm and Justification\n\n**1. Preprocessing:**\nTo facilitate the divide step, we first sort the entire set of points $P$ based on their $x$-coordinates. This creates a sorted list $P_x$. This initial sort takes $O(n \\log n)$ time.\n\n**2. Recursive Structure:**\nThe recursive function, let's call it `find_closest(Px)`, operates on a list of points already sorted by their $x$-coordinate.\n\n*   **Base Case**: If the number of points is small (e.g., $n \\le 3$), the minimum distance is computed by brute force. This takes constant time, $O(1)$. For $n  2$, the distance is undefined, which we can represent as infinity.\n\n*   **Divide Step**: We split the sorted list $P_x$ into two halves, $P_L = P_x[0 \\dots n/2-1]$ and $P_R = P_x[n/2 \\dots n-1]$. The dividing line is a vertical plane passing through the median $x$-coordinate, $x_{med} = P_x[n/2].x$. This step takes $O(1)$ time due to array slicing.\n\n*   **Conquer Step**: We make two recursive calls: $\\delta_L = \\text{find\\_closest}(P_L)$ and $\\delta_R = \\text{find\\_closest}(P_R)$.\n\n*   **Combine Step**: This is the most critical part of the algorithm. Let $\\delta = \\min(\\delta_L, \\delta_R)$. If a closer pair exists, it must consist of one point from $P_L$ and one from $P_R$. Let such a pair be $(p_L, p_R)$ with $p_L \\in P_L$ and $p_R \\in P_R$. For their distance $d(p_L, p_R)$ to be less than $\\delta$, it must be that their coordinate differences are also bounded: $|x_L - x_R|  \\delta$, $|y_L - y_R|  \\delta$, and $|z_L - z_R|  \\delta$.\n\n    This observation allows us to drastically reduce the search space. We only need to consider points within a vertical \"strip\" of width $2\\delta$ centered at the dividing plane $x = x_{med}$. Let $S$ be the set of points in $P$ such that their $x$-coordinate is in the range $[x_{med} - \\delta, x_{med} + \\delta]$.\n\n    A naive comparison of all pairs in $S$ could still be $O(n^2)$ in the worst case. To ensure an $O(n)$ combine step, we must use the geometric constraints more effectively. We can employ a grid-based hashing technique.\n\n    1.  **Grid Construction**: We define a 2D grid on the $y-z$ plane with a cell side length of $\\delta$. We iterate through the points in the strip $S$. For each point $p=(x,y,z) \\in S$, we map it to a grid cell indexed by $(\\lfloor y/\\delta \\rfloor, \\lfloor z/\\delta \\rfloor)$. We use a hash map to store the points falling into each cell.\n    2.  **Neighbor Search**: For each point $p$ being processed from the strip, we only need to check for neighbors in a small, finite region around it. A point $q$ with $d(p, q)  \\delta$ must have $|p.y - q.y|  \\delta$ and $|p.z - q.z|  \\delta$. This means $q$ must lie either in $p$'s own grid cell or in one of the eight adjacent cells (a $3 \\times 3$ block of cells centered on $p$'s cell).\n    3.  **Complexity Justification**: The problem statement correctly notes that the number of points with pairwise separation at least $\\delta$ within any cube of side length $\\delta$ is bounded by a constant. Our cells partition a $2\\delta$-wide slab. A single cell corresponds to a volume of $2\\delta \\times \\delta \\times \\delta$. Any two points within this volume that originate from the same half ($P_L$ or $P_R$) are at least $\\delta$ apart. A packing argument proves that the number of points in any single cell is bounded by a small constant. Therefore, for each point $p \\in S$, we only need to check its distance against a constant number of other points.\n    4.  **Implementation**: We iterate through the points in the strip (which are already sorted by $x$-coordinate). For each point $p$, we check the relevant neighboring cells in the grid for points that have already been processed and added to the grid. Then, we add $p$ to its corresponding grid cell. This ensures each pair is effectively checked once.\n\nThis grid-based method for processing the strip takes $O(|S|) = O(n)$ time. The overall recurrence relation becomes $T(n) = 2T(n/2) + O(n)$, which solves to $T(n) = O(n \\log n)$ by the Master Theorem. The total time complexity including the initial sort is $O(n \\log n)$. This algorithm is scientifically sound and meets all requirements of the problem. If at any point a distance of $0$ is found (indicating identical points), the algorithm can terminate immediately and return $0$, as no smaller non-negative distance is possible.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef distance(p1, p2):\n    \"\"\"Computes the Euclidean distance between two points in 3D space.\"\"\"\n    return np.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2 + (p1[2] - p2[2])**2)\n\ndef brute_force_closest_pair(points):\n    \"\"\"\n    Finds the minimum distance in a small set of points by brute force.\n    Assumes len(points)  1.\n    \"\"\"\n    min_dist = float('inf')\n    for i in range(len(points)):\n        for j in range(i + 1, len(points)):\n            d = distance(points[i], points[j])\n            if d  min_dist:\n                min_dist = d\n    return min_dist\n\ndef closest_pair_recursive(Px):\n    \"\"\"\n    The recursive core of the divide-and-conquer algorithm.\n    Px is a list of points sorted by x-coordinate.\n    \"\"\"\n    n = len(Px)\n\n    # Base case: for a small number of points, use brute force.\n    if n = 3:\n        # If n  2, there are no pairs, so the distance is infinite.\n        if n  2:\n            return float('inf')\n        return brute_force_closest_pair(Px)\n\n    # Divide step: Split the points into two halves.\n    mid = n // 2\n    median_point = Px[mid]\n    \n    # Create left and right subsets of points sorted by x.\n    Px_left = Px[:mid]\n    Px_right = Px[mid:]\n\n    # Conquer step: Recursively find the closest pair in each half.\n    d_left = closest_pair_recursive(Px_left)\n    d_right = closest_pair_recursive(Px_right)\n\n    delta = min(d_left, d_right)\n\n    # Optimization: if a pair of identical points was found, the distance is 0.\n    # We can't find a smaller non-negative distance, so we can terminate early.\n    if delta == 0:\n        return 0.0\n\n    # Combine step: Check for a closer pair across the two halves.\n    # Such a pair must lie in a \"strip\" of width 2*delta around the median x-plane.\n    strip_points = [p for p in Px if abs(p[0] - median_point[0])  delta]\n    \n    # To achieve an O(n) combine step, we use a grid (hashing) method\n    # on the y-z plane to find candidate pairs in the strip efficiently.\n    grid = {}\n    cell_size = delta\n    min_dist_strip = delta\n\n    for p in strip_points:\n        # Determine the grid cell key for the point p based on its y and z coordinates.\n        key = (int(p[1] / cell_size), int(p[2] / cell_size))\n        \n        # Check neighboring cells for points closer than delta.\n        # We check a 3x3 block of cells in the y-z plane centered at the current point's cell.\n        for dy in range(-1, 2):\n            for dz in range(-1, 2):\n                check_key = (key[0] + dy, key[1] + dz)\n                if check_key in grid:\n                    for neighbor in grid[check_key]:\n                        d = distance(p, neighbor)\n                        if d  min_dist_strip:\n                            min_dist_strip = d\n        \n        # Add the current point to the grid for subsequent points to check against.\n        if key not in grid:\n            grid[key] = []\n        grid[key].append(p)\n        \n    return min_dist_strip\n\n\ndef solve_closest_pair(points):\n    \"\"\"\n    Main function to initiate the closest pair algorithm. It sorts the points\n    by the x-coordinate and calls the recursive helper function.\n    \"\"\"\n    # An initial sort by x-coordinate is required for the divide-and-conquer strategy.\n    # Sorting a list of tuples sorts them element by element, starting with the first (x).\n    sorted_points = sorted(list(points))\n\n    return closest_pair_recursive(sorted_points)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [(0,0,0),(10,10,10),(10,10,11),(20,25,30),(5,6,7),(100,-50,25),(-10,12,8)],\n        [(0,0,0),(1,1,1)],\n        [(5,-7,2),(5,-7,2),(0,0,0)],\n        [(0,0,0),(1,0,0),(2,0,0),(3,0,0),(4,0,0),(5,0,0),(6,0,0),(7,0,0),(8,0,0),(9,0,0)],\n        [(0,1,1),(0,2,2),(0,3,3),(0,4,4),(0,4,5)],\n        [(-1000,500,-300),(-999,500,-300),(400,-800,1000),(401,-800,1000)]\n    ]\n\n    results = []\n    for case in test_cases:\n        if len(case)  2:\n            # Although all given test cases have n=2, this handles the general case.\n            # The minimum distance between fewer than two points is considered infinite.\n            result = float('inf') \n        else:\n            result = solve_closest_pair(case)\n        \n        # Format the result to six decimal places.\n        results.append(f\"{result:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}