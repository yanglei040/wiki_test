{
    "hands_on_practices": [
        {
            "introduction": "The correctness of any geometric algorithm depends entirely on the reliability of its fundamental predicates. This first practice explores the critical issue of numerical robustness by having you compare a naive floating-point intersection test against one using exact integer arithmetic. By generating adversarial inputs, you will gain first-hand experience with how finite precision can lead to catastrophic failures and appreciate why robust computational geometry relies on exact predicates ().",
            "id": "3244227",
            "problem": "You are to design and implement a complete program that constructs adversarial collections of pairs of planar line segments and evaluates the robustness of a naive floating-point line-segment intersection test against an exact-predicate line-segment intersection test. The mathematical foundation must start from first principles: the definition of planar orientation via the determinant of translated vectors and the resulting logical conditions for segment intersection. Specifically, given three points $p=(p_x,p_y)$, $q=(q_x,q_y)$, and $r=(r_x,r_y)$ in the plane, the signed area of the triangle determined by these points is defined by the two-dimensional cross product\n$$\n\\operatorname{orient}(p,q,r) = (q_x - p_x)\\cdot(r_y - p_y) - (q_y - p_y)\\cdot(r_x - p_x).\n$$\nThe sign of $\\operatorname{orient}(p,q,r)$ yields the orientation: positive for counterclockwise, zero for collinear, negative for clockwise. Two line segments $[p_1,q_1]$ and $[p_2,q_2]$ intersect if and only if their orientations satisfy the general-case crossing condition and the boundary collinearity cases, derived from these definitions. The naive predicate computes $\\operatorname{orient}$ and all comparisons in double-precision floating point, while the exact predicate computes all values using integers, thereby guaranteeing exactness when all input coordinates are integers.\n\nYou must implement two intersection predicates grounded in the above definitions:\n- A naive floating-point predicate that evaluates all arithmetic in double-precision floating point as provided by the programming language's default $64$-bit floating type.\n- An exact predicate that evaluates all arithmetic using integer operations, leveraging exact integer arithmetic when coordinates are integers.\n\nThen, you must generate adversarial test inputs designed to stress numerical robustness:\n- Near-parallel or parallel segments with very large coordinate magnitudes and small separations, so that differences below the Unit in the Last Place ($ULP$) at the given magnitude are lost under floating-point rounding.\n- Segments that share endpoints to test boundary handling.\n- Overlapping collinear segments and non-overlapping collinear segments to test collinearity and on-segment logic.\n\nUse the following test suite. Each test case is a set of pairs of segments, and all coordinates must be integers. Let $B = 2^{60}$.\n\n1. Happy-path moderate scale ($N=12$ pairs): For $i=0,1,2,3,4,5$, include the pairs\n   - $[p_1,q_1]=[(i,0),(i,10)]$, $[p_2,q_2]=[(i-1,5),(i+1,5)]$,\n   which intersect. For $i=6,7,8,9,10,11$, include the pairs\n   - $[p_1,q_1]=[(i,0),(i,10)]$, $[p_2,q_2]=[(i-1,15),(i+1,15)]$,\n   which do not intersect. These exercise the general crossing logic at moderate magnitudes where floating-point arithmetic is expected to be reliable.\n\n2. Adversarial near-parallel at large scale ($N=16$ pairs): For $i=0,1,\\dots,15$, include the pairs\n   - $[p_1,q_1]=[(B+i,B),(B+i,B+10)]$ and $[p_2,q_2]=[(B+i+10,B),(B+i+10,B+10)]$.\n   These are two vertical segments separated by a horizontal gap of $10$. At magnitude $B=2^{60}$, the $ULP$ of double precision is $2^{8}=256$, so adding $10$ or any value less than $256$ is not represented in the floating-point format; differences like $(B+i+10)-(B+i)$ will be rounded to $0$ when cast to floating point. This creates severe rounding that can cause the naive predicate to misclassify non-intersecting segments.\n\n3. Shared endpoints at moderate scale ($N=10$ pairs): For $i=0,1,\\dots,9$, include the pairs\n   - $[p_1,q_1]=[(i,i),(i+5,i+5)]$ and $[p_2,q_2]=[(i+5,i+5),(i+10,i)]$.\n   These pairs share the endpoint $(i+5,i+5)$, forming a boundary intersection case.\n\n4. Collinear overlapping and non-overlapping at large scale ($N=12$ pairs): Include $6$ overlapping pairs and $6$ non-overlapping pairs on the horizontal line $y=B$:\n   - Overlapping ($6$ pairs): $[p_1,q_1]=[(B,B),(B+5,B)]$, $[p_2,q_2]=[(B+2,B),(B+7,B)]$.\n   - Non-overlapping ($6$ pairs): $[p_1,q_1]=[(B,B),(B+5,B)]$, $[p_2,q_2]=[(B+6,B),(B+10,B)]$.\n   At magnitude $B=2^{60}$, adding any integer less than $256$ to $B$ will be rounded away in floating-point, so the naive predicate may conflate distinct points or segments, misclassifying non-overlapping segments as overlapping.\n\nFor each test case, compute the failure rate of the naive predicate relative to the exact predicate as a decimal number $f = \\frac{\\text{number of mismatches}}{\\text{number of pairs}}$. Also compute the overall failure rate across all pairs in the entire suite. Your program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order: $[\\text{rate\\_happy},\\text{rate\\_near\\_parallel},\\text{rate\\_shared\\_endpoint},\\text{rate\\_collinear},\\text{rate\\_overall}]$. No input is required; all data must be generated by the program internally. The only acceptable output types for the entries are decimal numbers (floating point), integers, booleans, or lists of these; here you must use decimal numbers for the rates. No physical units or angles appear in this task.",
            "solution": "The problem is valid as it is scientifically grounded in the principles of computational geometry, is well-posed with a unique deterministic solution, and is stated using objective, formal language. The task is to implement and compare an exact-arithmetic line segment intersection predicate against a naive floating-point predicate, using adversarial test cases designed to highlight the pitfalls of finite-precision arithmetic.\n\nThe mathematical foundation for determining the intersection of two line segments is the orientation test. Given three ordered points $p=(p_x, p_y)$, $q=(q_x, q_y)$, and $r=(r_x, r_y)$ in a plane, the orientation can be determined by computing the sign of the two-dimensional cross product of the vectors $\\vec{pq}$ and $\\vec{pr}$. This is given by the determinant:\n$$\n\\operatorname{orient}(p,q,r) = \\det(\\vec{pq}, \\vec{pr}) = (q_x - p_x)(r_y - p_y) - (q_y - p_y)(r_x - p_x)\n$$\nThe sign of this expression determines the orientation:\n- If $\\operatorname{orient}(p,q,r) > 0$, the sequence of points $p \\to q \\to r$ constitutes a counter-clockwise (left) turn.\n- If $\\operatorname{orient}(p,q,r) < 0$, it is a clockwise (right) turn.\n- If $\\operatorname{orient}(p,q,r) = 0$, the three points are collinear.\n\nTwo line segments, $[p_1, q_1]$ and $[p_2, q_2]$, intersect if and only if one of two conditions holds:\n1.  **General Case:** The segments properly cross each other. This occurs if the endpoints of each segment lie on opposite sides of the line containing the other segment. This condition is met if and only if the orientations $(\\operatorname{orient}(p_1, q_1, p_2), \\operatorname{orient}(p_1, q_1, q_2))$ and $(\\operatorname{orient}(p_2, q_2, p_1), \\operatorname{orient}(p_2, q_2, q_1))$ are both pairs of opposite signs (one positive, one negative).\n2.  **Special Case (Collinear):** An endpoint of one segment lies on the other segment. This covers cases of shared endpoints and overlapping collinear segments. This occurs if an orientation test yields zero (e.g., $\\operatorname{orient}(p_1, q_1, p_2)=0$) and the point involved in that test (here, $p_2$) lies within the bounding box of the segment (here, $[p_1, q_1]$). A point $r$ is on a segment $[p,q]$ if it is collinear with $p$ and $q$ and its coordinates lie between those of $p$ and $q$:\n    $$\n    (\\min(p_x, q_x) \\le r_x \\le \\max(p_x, q_x)) \\land (\\min(p_y, q_y) \\le r_y \\le \\max(p_y, q_y))\n    $$\n\nThe program will implement two versions of this intersection algorithm:\n-   **Exact Predicate:** This predicate operates on integer coordinates. Since all inputs are specified as integers, the orientation formula involves only integer subtractions and multiplications. Python's arbitrary-precision integers guarantee that these operations are performed without loss of precision, leading to a mathematically exact result for the sign of the determinant.\n-   **Naive Predicate:** This predicate uses standard $64$-bit double-precision floating-point arithmetic (the language's `float` type, here explicitly `numpy.float64`). Input integer coordinates are first cast to floating-point numbers.\n\nThe adversarial test cases are designed to exploit the inherent limitations of floating-point representation. A standard $64$-bit float has a finite precision (a $52$-bit mantissa). This leads to two primary failure modes in geometric computations:\n-   **Precision Loss at Large Magnitudes:** For a large number $x$, the gap between it and the next representable floating-point number, known as the Unit in the Last Place ($ULP$), becomes large. For $x = B = 2^{60}$, the $ULP$ is $2^{60-52} = 2^8 = 256$. Consequently, adding a small integer $\\delta$ where $|\\delta| < ULP/2 = 128$ to $B$ results in a value that rounds back to the original floating-point representation of $B$. That is, $fl(B+\\delta) = fl(B)$. The adversarial tests use this by defining coordinates like $(B+i, B)$ and $(B+i+10, B)$, which are distinct in integer arithmetic but collapse to identical points in floating-point arithmetic, causing the naive predicate to fail.\n-   **Catastrophic Cancellation:** The orientation formula involves subtractions. When two nearly equal large numbers are subtracted, the leading significant digits cancel out, and the result is dominated by rounding errors. This can cause the computed orientation value to have an incorrect sign or to be erroneously zero, leading to incorrect intersection results.\n\nThe solution program follows these steps:\n1.  Implement the exact and naive orientation and intersection predicates.\n2.  Generate the four specified test suites: a \"happy path\" with moderate coordinates, a case with shared endpoints, and two adversarial cases using the large magnitude $B=2^{60}$ to test near-parallel non-intersecting segments and collinear segments.\n3.  For each pair of segments in each test suite, the results of the naive and exact predicates are compared. A mismatch is recorded if they differ.\n4.  The failure rate for each suite is computed as the ratio of mismatches to the total number of pairs in that suite. An overall failure rate across all test cases is also computed.\n5.  The final results are formatted and printed as a comma-separated list.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Designs, implements, and evaluates naive vs. exact line segment intersection predicates.\n    \"\"\"\n\n    # --- PREDICATE IMPLEMENTATIONS ---\n\n    def orient_exact(p, q, r):\n        \"\"\"\n        Computes the orientation of ordered triplet (p, q, r) using exact integer arithmetic.\n        Returns:\n            > 0 for counter-clockwise turn,\n            < 0 for clockwise turn,\n            = 0 for collinear points.\n        \"\"\"\n        # Python's `int` type supports arbitrary precision, ensuring exactness.\n        val = (q[0] - p[0]) * (r[1] - p[1]) - \\\n              (q[1] - p[1]) * (r[0] - p[0])\n        if val == 0:\n            return 0  # Collinear\n        return 1 if val > 0 else -1  # CCW or CW\n\n    def orient_naive(p, q, r):\n        \"\"\"\n        Computes the orientation using 64-bit floating-point arithmetic.\n        Coordinates are cast to np.float64, which may introduce rounding errors.\n        \"\"\"\n        px, py = np.float64(p[0]), np.float64(p[1])\n        qx, qy = np.float64(q[0]), np.float64(q[1])\n        rx, ry = np.float64(r[0]), np.float64(r[1])\n        \n        val = (qx - px) * (ry - py) - (qy - py) * (rx - px)\n        \n        if val == 0.0:\n            return 0\n        return 1 if val > 0.0 else -1\n\n    def on_segment(p, q, r):\n        \"\"\"\n        Given three collinear points p, q, r, this function checks\n        if point q lies on line segment 'pr'.\n        This works for both integer and float coordinate types.\n        \"\"\"\n        return (q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and\n                q[1] <= max(p[1], r[1]) and q[1] >= min(p[1], r[1]))\n\n    def intersects_exact(s1, s2):\n        \"\"\"\n        Returns true if line segment 's1' and 's2' intersect, using exact predicates.\n        s1 = (p1, q1), s2 = (p2, q2)\n        \"\"\"\n        p1, q1 = s1\n        p2, q2 = s2\n        \n        o1 = orient_exact(p1, q1, p2)\n        o2 = orient_exact(p1, q1, q2)\n        o3 = orient_exact(p2, q2, p1)\n        o4 = orient_exact(p2, q2, q1)\n\n        # General case: segments cross each other properly.\n        if (o1 * o2  0) and (o3 * o4  0):\n            return True\n\n        # Special Cases (Collinear and/or endpoint touches)\n        if o1 == 0 and on_segment(p1, p2, q1): return True\n        if o2 == 0 and on_segment(p1, q2, q1): return True\n        if o3 == 0 and on_segment(p2, p1, q2): return True\n        if o4 == 0 and on_segment(p2, q1, q2): return True\n            \n        return False\n\n    def intersects_naive(s1, s2):\n        \"\"\"\n        Returns true if line segment 's1' and 's2' intersect, using naive predicates.\n        \"\"\"\n        p1, q1 = s1\n        p2, q2 = s2\n        \n        o1 = orient_naive(p1, q1, p2)\n        o2 = orient_naive(p1, q1, q2)\n        o3 = orient_naive(p2, q2, p1)\n        o4 = orient_naive(p2, q2, q1)\n\n        # General case\n        if (o1 * o2  0) and (o3 * o4  0):\n            return True\n        \n        # Special Cases\n        p1_f, q1_f = (np.float64(p1[0]), np.float64(p1[1])), (np.float64(q1[0]), np.float64(q1[1]))\n        p2_f, q2_f = (np.float64(p2[0]), np.float64(p2[1])), (np.float64(q2[0]), np.float64(q2[1]))\n        \n        if o1 == 0 and on_segment(p1_f, p2_f, q1_f): return True\n        if o2 == 0 and on_segment(p1_f, q2_f, q1_f): return True\n        if o3 == 0 and on_segment(p2_f, p1_f, q2_f): return True\n        if o4 == 0 and on_segment(p2_f, q1_f, q2_f): return True\n        \n        return False\n\n    # --- TEST CASE GENERATION ---\n\n    def generate_test_cases():\n        B = 2**60\n        \n        # Case 1: Happy-path moderate scale\n        happy_path = []\n        for i in range(6):  # Intersecting\n            p1, q1 = (i, 0), (i, 10)\n            p2, q2 = (i - 1, 5), (i + 1, 5)\n            happy_path.append(((p1, q1), (p2, q2)))\n        for i in range(6, 12):  # Non-intersecting\n            p1, q1 = (i, 0), (i, 10)\n            p2, q2 = (i - 1, 15), (i + 1, 15)\n            happy_path.append(((p1, q1), (p2, q2)))\n\n        # Case 2: Adversarial near-parallel\n        near_parallel = []\n        for i in range(16):\n            p1, q1 = (B + i, B), (B + i, B + 10)\n            p2, q2 = (B + i + 10, B), (B + i + 10, B + 10)\n            near_parallel.append(((p1, q1), (p2, q2)))\n            \n        # Case 3: Shared endpoints\n        shared_endpoint = []\n        for i in range(10):\n            p1, q1 = (i, i), (i + 5, i + 5)\n            p2, q2 = (i + 5, i + 5), (i + 10, i)\n            shared_endpoint.append(((p1, q1), (p2, q2)))\n\n        # Case 4: Collinear large scale\n        collinear = []\n        # Overlapping (6 pairs)\n        p1_o, q1_o = (B, B), (B + 5, B)\n        p2_o, q2_o = (B + 2, B), (B + 7, B)\n        for _ in range(6):\n            collinear.append(((p1_o, q1_o), (p2_o, q2_o)))\n        # Non-overlapping (6 pairs)\n        p1_n, q1_n = (B, B), (B + 5, B)\n        p2_n, q2_n = (B + 6, B), (B + 10, B)\n        for _ in range(6):\n            collinear.append(((p1_n, q1_n), (p2_n, q2_n)))\n            \n        return [happy_path, near_parallel, shared_endpoint, collinear]\n\n    # --- MAIN EXECUTION LOGIC ---\n\n    test_suites = generate_test_cases()\n    failure_rates = []\n    total_mismatches = 0\n    total_pairs = 0\n\n    for suite in test_suites:\n        mismatches = 0\n        num_pairs = len(suite)\n        if num_pairs == 0:\n            failure_rates.append(0.0)\n            continue\n            \n        for s1, s2 in suite:\n            exact_result = intersects_exact(s1, s2)\n            naive_result = intersects_naive(s1, s2)\n            if exact_result != naive_result:\n                mismatches += 1\n        \n        rate = mismatches / num_pairs\n        failure_rates.append(rate)\n        \n        total_mismatches += mismatches\n        total_pairs += num_pairs\n        \n    overall_rate = total_mismatches / total_pairs if total_pairs  0 else 0.0\n    failure_rates.append(overall_rate)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, failure_rates))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "With a robust intersection primitive established, we can now apply it to solve more complex problems. This exercise challenges you to determine if a polygon is self-intersecting, a classic problem in computer graphics and computational geometry. The key skill you will develop is not just applying the intersection test, but correctly interpreting the problem's constraints to distinguish between valid connections at shared vertices and true self-intersections between non-adjacent edges ().",
            "id": "3244246",
            "problem": "You are given a planar polygon defined by an ordered list of vertices. Let the vertices be denoted by $p_0, p_1, \\dots, p_{n-1}$, where each $p_i$ is a point in the Euclidean plane with integer coordinates $p_i = (x_i, y_i)$. The polygon edges are the line segments $e_i = [p_i, p_{(i+1) \\bmod n}]$ for $i = 0, 1, \\dots, n-1$. A polygon is called self-intersecting if there exists a pair of edges $e_i$ and $e_j$ with $i \\neq j$ that have a nonempty intersection, except that intersections at shared endpoints of consecutive edges are allowed. Intersections between nonconsecutive edges that occur at endpoints or interiors are considered self-intersections. Degenerate edges, where $p_i = p_{(i+1) \\bmod n}$, are permitted. A degenerate edge alone does not make the polygon self-intersecting, but if a degenerate edge lies on or touches any nonadjacent edge, this counts as a self-intersection.\n\nStarting from the core definitions of planar geometry and orientation, design an algorithm that determines whether a given polygon is self-intersecting. Use only integer arithmetic. Your algorithm must be based on the following fundamental definitions and facts of planar geometry:\n\n- For points $a = (x_a, y_a)$, $b = (x_b, y_b)$, and $c = (x_c, y_c)$, the oriented area (signed cross product) of the triangle $(a, b, c)$ is\n$$\n\\Delta(a, b, c) = (x_b - x_a)(y_c - y_a) - (y_b - y_a)(x_c - x_a).\n$$\n- The orientation of $(a, b, c)$ is counterclockwise if $\\Delta(a, b, c)  0$, clockwise if $\\Delta(a, b, c)  0$, and collinear if $\\Delta(a, b, c) = 0$.\n- A point $b$ lies on the closed segment $[a, c]$ if and only if $b$ is collinear with $(a, c)$ and $x_b$ lies between $\\min(x_a, x_c)$ and $\\max(x_a, x_c)$, and $y_b$ lies between $\\min(y_a, y_c)$ and $\\max(y_a, y_c)$.\n\nYour program must implement an intersection test for two closed segments $[p_1, q_1]$ and $[p_2, q_2]$ that correctly handles the general case and the collinear special cases. Two edges are considered adjacent if their indices are consecutive modulo $n$ (that is, $j = (i+1) \\bmod n$ or $i = (j+1) \\bmod n$). Adjacent edge intersections at their shared endpoint must be ignored.\n\nYour task is to write a complete program that evaluates the following test suite of polygons, each given as a list of integer coordinate pairs in order, and outputs whether each polygon is self-intersecting:\n\n- Test $1$ (simple convex quadrilateral): $[(0, 0), (3, 0), (3, 3), (0, 3)]$.\n- Test $2$ (simple triangle): $[(0, 0), (5, 0), (2, 4)]$.\n- Test $3$ (bow-tie polygon with a proper crossing): $[(0, 0), (4, 4), (0, 4), (4, 0)]$.\n- Test $4$ (nonadjacent endpoint touch due to repeated vertex): $[(0, 0), (3, 0), (3, 3), (0, 3), (0, 0)]$.\n- Test $5$ (collinear overlapping nonadjacent edges): $[(0, 0), (2, 0), (3, 0), (1, 0)]$.\n- Test $6$ (zero-length edge that does not create a nonadjacent intersection): $[(0, 0), (2, 0), (2, 0), (2, 2), (0, 2)]$.\n- Test $7$ (interior crossing between nonadjacent edges): $[(0, 0), (2, 0), (1, 1), (1, -1)]$.\n- Test $8$ (concave but simple polygon): $[(0, 0), (4, 0), (4, 3), (2, 5), (0, 3)]$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each result must be a boolean. For example, the output format must be exactly like $[r_1, r_2, \\dots, r_8]$, where each $r_i$ is either $True$ or $False$ corresponding to Test $i$ in order.",
            "solution": "The user wants to solve a computational geometry problem.\n\nThe problem is to determine if a polygon, defined by an ordered list of vertices, is self-intersecting. The solution must be based on fundamental geometric primitives provided in the problem statement and must use only integer arithmetic.\n\n### Step 1: Extract Givens\n- **Vertices**: An ordered list of points $p_0, p_1, \\dots, p_{n-1}$, where each $p_i = (x_i, y_i)$ has integer coordinates.\n- **Edges**: Line segments $e_i = [p_i, p_{(i+1) \\bmod n}]$ for $i = 0, 1, \\dots, n-1$.\n- **Self-Intersection Definition**: A polygon is self-intersecting if there exists a pair of edges $e_i$ and $e_j$ with $i \\neq j$ that have a nonempty intersection.\n- **Exception to Self-Intersection**: Intersections at shared endpoints of consecutive edges are allowed (i.e., not considered self-intersections).\n- **Rule for Self-Intersection**: Intersections between nonconsecutive edges, whether at an endpoint or in the interior of an edge, are considered self-intersections.\n- **Degenerate Edges**: Edges where $p_i = p_{(i+1) \\bmod n}$ are permitted. A degenerate edge does not by itself cause a self-intersection, but it is counted if it intersects a nonadjacent edge.\n- **Adjacent Edges Definition**: Edges $e_i$ and $e_j$ are adjacent if their indices are consecutive modulo $n$, i.e., $j = (i+1) \\bmod n$ or $i = (j+1) \\bmod n$.\n- **Orientation Formula**: For points $a = (x_a, y_a)$, $b = (x_b, y_b)$, and $c = (x_c, y_c)$, the signed cross product is $\\Delta(a, b, c) = (x_b - x_a)(y_c - y_a) - (y_b - y_a)(x_c - x_a)$. The orientation is determined by the sign of $\\Delta(a, b, c)$: positive for counterclockwise, negative for clockwise, and zero for collinear.\n- **On-Segment Condition**: A point $b$ lies on the closed segment $[a, c]$ if and only if it is collinear with $a$ and $c$ (i.e., $\\Delta(a, b, c) = 0$) and its coordinates lie within the bounding box of the segment: $x_b \\in [\\min(x_a, x_c), \\max(x_a, x_c)]$ and $y_b \\in [\\min(y_a, y_c), \\max(y_a, y_c)]$.\n- **Test Cases**: The problem provides eight specific polygons to be tested.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is subjected to a rigorous validation process.\n\n- **Scientifically Grounded**: The problem is well-rooted in standard Euclidean and computational geometry. The definitions for orientation (cross product), collinearity, and segment intersection are fundamental and mathematically sound.\n- **Well-Posed**: The problem is clearly defined. The definitions of polygon, edge, adjacency, and self-intersection are precise and unambiguous. This structure guarantees a unique, deterministic boolean answer for any given polygon.\n- **Objective**: The language is formal and objective. It provides mathematical definitions and avoids any subjective or opinion-based statements.\n- **Completeness and Consistency**: The problem is self-contained. All necessary definitions and formulas are provided. The rules for handling general cases, special collinear cases, degenerate edges, and adjacency are explicit and consistent.\n- **Feasibility**: The constraints are realistic. All coordinates are integers, and the required calculations can be performed using integer arithmetic, thus avoiding floating-point precision issues.\n\nThe problem has no identifiable flaws. It is a standard, albeit subtle, problem in computational geometry. The definitions are rigorous and must be followed precisely, especially concerning the distinction between consecutive and non-consecutive edges, which is based on vertex indices, not just geometric adjacency.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A solution will be constructed based on the provided principles.\n\n### Algorithmic Design\n\nThe core of the algorithm is to check every pair of non-consecutive edges for intersection. This can be broken down into three main components.\n\n1.  **Geometric Primitives**: We first implement helper functions for the fundamental geometric tests based on the provided definitions.\n    -   `orientation(p, q, r)`: This function will take three points $p$, $q$, and $r$ and compute the value of $\\Delta(p, q, r)$. The sign of this value determines if the turn from segment $[p, q]$ to $[q, r]$ is counterclockwise ($ 0$), clockwise ($ 0$), or if the points are collinear ($= 0$).\n    -   `on_segment(p, q, r)`: This function checks if a point $q$ lies on the line segment $[p, r]$. It will be used only when it is already known that the three points are collinear. It verifies that the coordinates of $q$ are within the minimum and maximum coordinates of $p$ and $r$.\n\n2.  **Segment Intersection Test**: A function `segments_intersect(p1, q1, p2, q2)` will determine if two closed line segments, $[p1, q1]$ and $[p2, q2]$, intersect. This function must handle two categories of cases:\n    -   **General Case**: The segments cross each other properly. This occurs if the endpoints of each segment lie on opposite sides of the line containing the other segment. This can be tested by computing four orientations: $\\Delta(p1, q1, p2)$, $\\Delta(p1, q1, q2)$, $\\Delta(p2, q2, p1)$, and $\\Delta(p2, q2, q1)$. An intersection occurs if the first two orientations have opposite signs, and the last two also have opposite signs. Using integer arithmetic, this is checked by seeing if the product of the orientations is negative (e.g., $\\Delta_1 \\cdot \\Delta_2  0$).\n    -   **Special (Collinear) Cases**: An endpoint of one segment lies on the other segment. This covers cases where segments touch at an endpoint (a T-junction) or overlap along a line. For each of the four orientation calculations, if the result is $0$, it signifies that three points are collinear. We must then use the `on_segment` function to check if this collinear point lies on the relevant segment. For example, if $\\Delta(p1, q1, p2) = 0$, we check if $p2$ lies on the segment $[p1, q1]$. An intersection exists if any of these four collinear conditions are met.\n\n3.  **Polygon Self-Intersection Check**: The main function `is_self_intersecting(polygon)` iterates through all unique pairs of edges $(e_i, e_j)$ of the polygon and checks for intersection.\n    -   The number of vertices is $n$. The edges are $e_0, e_1, \\dots, e_{n-1}$.\n    -   We use nested loops to iterate through all pairs of indices $(i, j)$ such that $0 \\le i  j  n$.\n    -   For each pair $(i, j)$, we must first determine if the edges $e_i$ and $e_j$ are consecutive. According to the problem, edges are consecutive if their indices are consecutive modulo $n$. For a pair $(i, j)$ where $i  j$, this means we must skip the check if $j = i+1$ (standard adjacency) or if $i=0$ and $j=n-1$ (wrap-around adjacency).\n    -   If the edges are not consecutive, we call `segments_intersect` on them.\n    -   If `segments_intersect` returns true for any pair of non-consecutive edges, we have found a self-intersection. The function can immediately return `True`.\n    -   If the loops complete without finding any such intersections, the polygon is simple, and the function returns `False`.\n\nThis algorithmic structure systematically and correctly implements all rules specified in the problem statement, including the careful handling of non-consecutive edge intersections at endpoints, which can arise from repeated vertices in the polygon's definition.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the polygon self-intersection problem for a suite of test cases.\n    \"\"\"\n\n    # Helper function to compute the orientation of an ordered triplet (p, q, r).\n    # The orientation determines if the turn from segment pq to qr is\n    # counter-clockwise, clockwise, or collinear.\n    # Returns:\n    #  0 for counter-clockwise\n    #  0 for clockwise\n    # = 0 for collinear\n    def orientation(p, q, r):\n        # Using the formula: (q_x - p_x)(r_y - p_y) - (q_y - p_y)(r_x - p_x)\n        # All coordinates are integers, so the result is a guaranteed integer.\n        val = (q[0] - p[0]) * (r[1] - p[1]) - \\\n              (q[1] - p[1]) * (r[0] - p[0])\n        return val\n\n    # Helper function to check if point q lies on the closed segment [p, r].\n    # This function assumes p, q, and r are already known to be collinear.\n    def on_segment(p, q, r):\n        # Checks if q's coordinates are within the bounding box of p and r.\n        return (q[0] = max(p[0], r[0]) and q[0] = min(p[0], r[0]) and\n                q[1] = max(p[1], r[1]) and q[1] = min(p[1], r[1]))\n\n    # Function to check if line segment [p1, q1] and [p2, q2] intersect.\n    def segments_intersect(p1, q1, p2, q2):\n        # Calculate the four orientations needed for general and special cases.\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n\n        # General case: The segments cross each other.\n        # This happens if the orientations (p1,q1,p2) and (p1,q1,q2) are different,\n        # and (p2,q2,p1) and (p2,q2,q1) are also different.\n        if o1 * o2  0 and o3 * o4  0:\n            return True\n\n        # Special Cases (Collinear):\n        # An endpoint of one segment lies on the other segment.\n        # o1 = 0: p1, q1, p2 are collinear. Check if p2 is on segment [p1, q1].\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        # o2 = 0: p1, q1, q2 are collinear. Check if q2 is on segment [p1, q1].\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        # o3 = 0: p2, q2, p1 are collinear. Check if p1 is on segment [p2, q2].\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        # o4 = 0: p2, q2, q1 are collinear. Check if q1 is on segment [p2, q2].\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n\n        # If none of the above, the segments do not intersect.\n        return False\n\n    # Main function to determine if a polygon is self-intersecting.\n    def is_self_intersecting(polygon):\n        n = len(polygon)\n        if n  3:\n            # A polygon must have at least 3 vertices to potentially self-intersect.\n            return False\n\n        # Iterate through all unique pairs of edges (e_i, e_j).\n        for i in range(n):\n            for j in range(i + 1, n):\n                # According to the problem, adjacent edges are defined by consecutive indices.\n                # We must skip pairs of adjacent edges.\n                # Case 1: Standard adjacency (e.g., e_i and e_{i+1})\n                if j == i + 1:\n                    continue\n                # Case 2: Wrap-around adjacency (e.g., e_{n-1} and e_0)\n                if i == 0 and j == n - 1:\n                    continue\n\n                # Get the endpoints of the two edges e_i and e_j.\n                p1 = polygon[i]\n                q1 = polygon[(i + 1) % n]\n                p2 = polygon[j]\n                q2 = polygon[(j + 1) % n]\n\n                # Check for intersection between these non-adjacent edges.\n                # Any intersection (endpoint or interior) counts as a self-intersection.\n                if segments_intersect(p1, q1, p2, q2):\n                    return True\n        \n        # If no intersections between non-adjacent edges are found, the polygon is simple.\n        return False\n\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test 1: simple convex quadrilateral\n        [(0, 0), (3, 0), (3, 3), (0, 3)],\n        # Test 2: simple triangle\n        [(0, 0), (5, 0), (2, 4)],\n        # Test 3: bow-tie polygon with a proper crossing\n        [(0, 0), (4, 4), (0, 4), (4, 0)],\n        # Test 4: nonadjacent endpoint touch due to repeated vertex\n        [(0, 0), (3, 0), (3, 3), (0, 3), (0, 0)],\n        # Test 5: collinear overlapping nonadjacent edges\n        [(0, 0), (2, 0), (3, 0), (1, 0)],\n        # Test 6: non-consecutive edges touching due to a repeated vertex\n        [(0, 0), (2, 0), (2, 0), (2, 2), (0, 2)],\n        # Test 7: interior crossing between nonadjacent edges\n        [(0, 0), (2, 0), (1, 1), (1, -1)],\n        # Test 8: concave but simple polygon\n        [(0, 0), (4, 0), (4, 3), (2, 5), (0, 3)],\n    ]\n\n    results = []\n    for polygon in test_cases:\n        result = is_self_intersecting(polygon)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The output format is a string representation of a Python list of booleans.\n    # Using map(str, ...) and join handles the True/False capitalization correctly.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Often, simply detecting an intersection is not enough; we need to know the precise geometry of the intersection set. This final practice advances from detection to reporting, requiring you to compute all intersection points and segments between two sets of lines. You will tackle the challenge of representing collinear overlaps as maximal intervals and producing a canonical output, skills essential for developing sophisticated geometric software ().",
            "id": "3244163",
            "problem": "You are given two finite sets of line segments in the two-dimensional plane. Each segment is defined by two distinct endpoints. Define a line segment as an ordered pair of endpoints, where each endpoint is a point in $\\mathbb{R}^2$ written as $(x,y)$ with real-valued coordinates. A segment between points $(x_1,y_1)$ and $(x_2,y_2)$ has nonzero length, meaning $(x_1,y_1)\\neq(x_2,y_2)$. The geometric intersection of two sets of segments $A$ and $B$, denoted $A\\cap B$, consists of the set of points lying simultaneously on any segment of $A$ and any segment of $B$. This intersection can contain isolated points as well as continuous intervals when segments are collinear and overlap. Represent the final intersection as a canonical mixture of primitives: isolated points and maximal overlapping intervals (segments) along supporting lines. If overlapping collinear segments produce infinitely many points along an interval, that entire overlapping portion must be represented as a single maximal interval rather than as points. Points that lie inside or at the endpoints of any maximal interval should be removed from the point set to avoid duplication.\n\nFundamental base for design:\n- Use the determinant (two-dimensional cross product) of vectors in $\\mathbb{R}^2$ to determine orientation and collinearity. For vectors $u=(u_x,u_y)$ and $v=(v_x,v_y)$, the signed area (cross product) is $u_x v_y - u_y v_x$. The sign indicates orientation and zero indicates collinearity.\n- Use parametric representation of lines: a line through point $p$ in direction $r$ is $\\ell(t)=p+t r$ for scalar $t\\in\\mathbb{R}$. Intersection of two lines can be derived by equating parametric forms and solving for parameters.\n- Use One-Dimensional (1D) interval reasoning for collinear segments by projecting points onto a consistent one-dimensional coordinate along the supporting line.\n\nYour task is to design an algorithm that, given $A$ and $B$, computes a canonical representation of $A\\cap B$ as follows:\n1. For non-collinear intersections, compute isolated points where a segment in $A$ meets a segment in $B$ at exactly one point.\n2. For collinear overlapping intersections, compute the overlapping subsegment interval(s).\n3. Coalesce overlapping intervals that lie on the same infinite line into maximal intervals using a consistent one-dimensional parametrization along that line, so that adjacent or overlapping collinear intersections are merged.\n4. Remove any isolated points that lie within or at the endpoints of any maximal interval on its supporting line to avoid redundancy.\n5. Canonical representation:\n   - Each isolated point is represented as a two-element list $[x,y]$.\n   - Each maximal interval is represented as a four-element list $[x_1,y_1,x_2,y_2]$, where endpoints are ordered lexicographically (first by $x$, then by $y$) to enforce a canonical orientation.\n   - The final intersection for each test case is represented as a two-element list $[P,S]$, where $P$ is the lexicographically sorted list of points and $S$ is the lexicographically sorted list of intervals.\n   - The union across all test cases is a single list of these two-element lists.\n\nRestrictions and realism:\n- Segments have nonzero length.\n- Computations involve real coordinates without physical units; no angle units are needed.\n- Floating-point calculations must be handled with a small tolerance to account for numerical rounding.\n\nTest suite and output specification:\nImplement your algorithm for the following six test cases. Each test case consists of two sets $A$ and $B$ of segments, where each segment is given by its endpoints:\n- Test case 1:\n  - $A=\\{((0,0),(4,4))\\}$\n  - $B=\\{((0,4),(4,0))\\}$\n- Test case 2:\n  - $A=\\{((0,0),(5,0)),((7,0),(9,0))\\}$\n  - $B=\\{((3,0),(8,0)),((9,0),(12,0))\\}$\n- Test case 3:\n  - $A=\\{((0,0),(10,0)),((12,0),(14,0))\\}$\n  - $B=\\{((2,0),(6,0)),((5,0),(9,0))\\}$\n- Test case 4:\n  - $A=\\{((1,0),(1,5))\\}$\n  - $B=\\{((1,3),(1,7))\\}$\n- Test case 5:\n  - $A=\\{((0,0),(4,0)),((2,-1),(2,1))\\}$\n  - $B=\\{((2,0),(5,0)),((2,0),(2,5))\\}$\n- Test case 6:\n  - $A=\\{((0,1),(10,6))\\}$\n  - $B=\\{((5,3.5),(15,8.5)),((10,6),(10,10))\\}$\n\nYour program should produce a single line of output containing the results of all test cases as a comma-separated list enclosed in square brackets, with no spaces. Specifically, the output must be a list of six elements, one per test case, where each element is of the form $[P,S]$ as described above. For example, the formatting (not the actual values) must look like:\n\"[[[x,y,...],[x1,y1,x2,y2,...]],[[...],[...]],...]\" with no spaces anywhere.",
            "solution": "The user provided problem is rigorously analyzed and determined to be valid. It is a well-posed problem in computational geometry, grounded in established mathematical principles, and provides a complete and consistent set of requirements for a canonical representation of line segment set intersections. The solution proceeds as follows.\n\nThe problem requires computing the geometric intersection of two finite sets of line segments, $A$ and $B$, in the Euclidean plane $\\mathbb{R}^2$. The resulting intersection, which may consist of both isolated points and continuous line segments, must be reported in a canonical format. This involves identifying all intersection primitives, merging overlapping collinear segments into maximal intervals, and eliminating redundant points that lie on these intervals.\n\nThe algorithm is designed in three main stages:\n1.  Pairwise Intersection: Iterate through all pairs of segments, one from set $A$ and one from set $B$, and compute their individual intersection. The result of each pairwise intersection is either empty, a single point, or a line segment.\n2.  Aggregation and Merging: Collect all intersection segments. Group them by collinearity and merge overlapping or adjacent segments within each group to form maximal intervals.\n3.  Canonicalization: Filter out any intersection points that lie on the maximal intervals to avoid redundancy. Sort the final lists of points and intervals lexicographically to produce a unique, canonical representation.\n\nA small numerical tolerance, $\\epsilon$, is used for all floating-point comparisons to ensure robustness.\n\n### Mathematical Framework\n\nWe represent points as vectors in $\\mathbb{R}^2$. A line segment is defined by its two endpoints, say $p_1$ and $p_2$. Such a segment has a vector representation $\\mathbf{r} = p_2 - p_1$. The length of the segment is non-zero, so $p_1 \\neq p_2$.\n\nThe two-dimensional cross product of two vectors $\\mathbf{u}=(u_x, u_y)$ and $\\mathbf{v}=(v_x, v_y)$ is a scalar value given by $\\mathbf{u} \\times \\mathbf{v} = u_x v_y - u_y v_x$. The sign of the cross product indicates the orientation of $\\mathbf{v}$ relative to $\\mathbf{u}$, and a value of zero indicates that the vectors are parallel.\n\nA line segment from $p_1$ to $p_2$ can be described parametrically as $p(t) = p_1 + t(p_2 - p_1)$ for $t \\in [0, 1]$. An infinite line is described by the same equation with $t \\in \\mathbb{R}$.\n\n### Pairwise Segment Intersection\n\nConsider two line segments: $s_A$ defined by endpoints $p_1, p_2$ and $s_B$ defined by $p_3, p_4$. Let their direction vectors be $\\mathbf{r} = p_2 - p_1$ and $\\mathbf{s} = p_4 - p_3$. Their parametric representations are:\n$$\ns_A(t) = p_1 + t\\mathbf{r}, \\quad t \\in [0,1]\n$$\n$$\ns_B(u) = p_3 + u\\mathbf{s}, \\quad u \\in [0,1]\n$$\nAn intersection occurs where $s_A(t) = s_B(u)$, which yields the vector equation $p_1 + t\\mathbf{r} = p_3 + u\\mathbf{s}$. Rearranging gives $t\\mathbf{r} - u\\mathbf{s} = p_3 - p_1$. This is a linear system of two equations for the parameters $t$ and $u$.\n\n**Case 1: Non-collinear Segments**\nThe lines containing the segments are not parallel, which is true if the cross product of their direction vectors is non-zero: $D = \\mathbf{r} \\times \\mathbf{s} \\neq 0$. The system has a unique solution for $t$ and $u$:\n$$\nt = \\frac{(p_3 - p_1) \\times \\mathbf{s}}{\\mathbf{r} \\times \\mathbf{s}}, \\quad u = \\frac{(p_3 - p_1) \\times \\mathbf{r}}{\\mathbf{r} \\times \\mathbf{s}}\n$$\nAn intersection point lies on both segments if and only if $0 \\le t \\le 1$ and $0 \\le u \\le 1$. If these conditions are met, the intersection point is $I = p_1 + t\\mathbf{r}$, which is collected into a list of raw intersection points.\n\n**Case 2: Parallel and Collinear Segments**\nIf $D = \\mathbf{r} \\times \\mathbf{s} \\approx 0$, the segments are parallel. We must further check if they are collinear by verifying that a point from one segment lies on the line of the other. This is true if $(p_3-p_1) \\times \\mathbf{r} \\approx 0$. If they are not collinear, they cannot intersect.\n\nIf they are collinear, the problem reduces to a one-dimensional interval intersection. We must find the portion of the common line that is part of both segments. An overlap exists if at least one endpoint of one segment lies on the other segment. We define a helper function, $\\text{on_segment}(p, s_1, s_2)$, which checks if point $p$ lies on the segment between $s_1$ and $s_2$. This is true if $p$ is collinear with $s_1, s_2$ and its projection lies between them, which can be checked with a dot product: $(p-s_1) \\cdot (p-s_2) \\le 0$.\n\nLet's find all endpoints that lie on the opposing segment:\n$$\nO = \\{ p \\in \\{p_1, p_2\\} \\mid \\text{on_segment}(p, p_3, p_4) \\} \\cup \\{ p \\in \\{p_3, p_4\\} \\mid \\text{on_segment}(p, p_1, p_2) \\}\n$$\nLet $O_{\\text{unique}}$ be the set of unique points in $O$.\n- If $|O_{\\text{unique}}|  2$, the segments do not overlap in an interval. If $|O_{\\text{unique}}| = 1$, they intersect at a single point. This point is added to the list of raw points.\n- If $|O_{\\text{unique}}| \\ge 2$, they overlap over a segment. The endpoints of this overlap segment are the lexicographically smallest and largest points in $O_{\\text{unique}}$. This new segment is added to a list of raw intersection segments.\n\n### Aggregation and Canonicalization\n\nAfter checking all pairs $(s_A, s_B)$, we have a list of raw intersection points and a list of raw intersection segments.\n\n**1. Merging Collinear Segments**\nThe raw intersection segments must be merged into maximal intervals.\nFirst, we group the segments by the infinite line they lie upon. A canonical representation for a line $ax+by+c=0$ is derived from two points $p_1, p_2$ on it. The coefficients are given by $a = p_{1y}-p_{2y}$, $b = p_{2x}-p_{1x}$, and $c=-(a \\cdot p_{1x} + b \\cdot p_{1y})$. These are normalized by dividing by $\\sqrt{a^2+b^2}$ and a sign convention is applied (e.g., the first non-zero coefficient must be positive) to ensure uniqueness. This canonical tuple $(a,b,c)$ serves as a key for grouping.\n\nFor each group of collinear segments:\n- The segments are treated as one-dimensional intervals. The projection axis is chosen based on the line's slope to avoid numerical instability: x-axis for non-vertical lines ($|m| \\le 1$) and y-axis for near-vertical lines ($|m|1$).\n- The intervals are sorted by their start point.\n- A standard interval merging algorithm is applied. We iterate through the sorted intervals, merging each with the current merged interval if they overlap or are adjacent.\n- The resulting merged 1D intervals are converted back to 2D segments. These are the maximal intervals.\n\n**2. Point Filtering and Sorting**\nThe final set of intersection points must not include any points that are part of the computed maximal intervals.\n- For each point in the list of raw intersection points, we check if it lies on any of the maximal segments using the `on_segment` logic.\n- Points that are not on any maximal segment are kept.\n- Duplicates are removed from the filtered list of points.\n\n**3. Final Representation**\n- Each maximal interval is represented as a list $[x_1, y_1, x_2, y_2]$, where the endpoints are ordered lexicographically.\n- The final list of isolated points, $P$, is sorted lexicographically.\n- The final list of maximal intervals, $S$, is also sorted lexicographically.\n- The result for one test case is the two-element list $[P, S]$.\n\nThis structured approach ensures that all intersection components are correctly identified and represented in the specified canonical format, respecting all constraints of the problem statement.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n    \n    test_cases = [\n        # Test case 1\n        (\n            [((0, 0), (4, 4))],\n            [((0, 4), (4, 0))]\n        ),\n        # Test case 2\n        (\n            [((0, 0), (5, 0)), ((7, 0), (9, 0))],\n            [((3, 0), (8, 0)), ((9, 0), (12, 0))]\n        ),\n        # Test case 3\n        (\n            [((0, 0), (10, 0)), ((12, 0), (14, 0))],\n            [((2, 0), (6, 0)), ((5, 0), (9, 0))]\n        ),\n        # Test case 4\n        (\n            [((1, 0), (1, 5))],\n            [((1, 3), (1, 7))]\n        ),\n        # Test case 5\n        (\n            [((0, 0), (4, 0)), ((2, -1), (2, 1))],\n            [((2, 0), (5, 0)), ((2, 0), (2, 5))]\n        ),\n        # Test case 6\n        (\n            [((0, 1), (10, 6))],\n            [((5, 3.5), (15, 8.5)), ((10, 6), (10, 10))]\n        )\n    ]\n\n    results = []\n    for segments_A, segments_B in test_cases:\n        result = compute_intersections(segments_A, segments_B)\n        results.append(result)\n\n    # Manual string formatting to match the exact output requirement (no spaces).\n    result_strings = []\n    for P, S in results:\n        p_str_list = [f\"[{p[0]},{p[1]}]\" for p in P]\n        s_str_list = [f\"[{s[0]},{s[1]},{s[2]},{s[3]}]\" for s in S]\n        p_str = f\"[{','.join(p_str_list)}]\"\n        s_str = f\"[{','.join(s_str_list)}]\"\n        result_strings.append(f\"[{p_str},{s_str}]\")\n\n    print(f\"[{','.join(result_strings)}]\")\n\ndef compute_intersections(segments_A, segments_B):\n    \"\"\"\n    Computes the canonical intersection of two sets of line segments.\n    \"\"\"\n    # Precision settings for floating point comparisons\n    PRECISION = 9\n    EPSILON = 10**(-PRECISION)\n\n    def on_segment(p, s_p1, s_p2):\n        # Check if point p lies on segment s_p1-s_p2.\n        # Check for collinearity\n        if abs(np.cross(s_p2 - s_p1, p - s_p1))  EPSILON:\n            return False\n        # Check if p is between endpoints\n        # Dot product check: (p-s_p1) dot (p-s_p2) = 0\n        dot_product = np.dot(p - s_p1, p - s_p2)\n        return dot_product  EPSILON\n\n    # 1. Find raw intersections\n    raw_points = []\n    raw_segments = []\n\n    for seg_a in segments_A:\n        p1, p2 = np.array(seg_a[0]), np.array(seg_a[1])\n        r = p2 - p1\n        for seg_b in segments_B:\n            p3, p4 = np.array(seg_b[0]), np.array(seg_b[1])\n            s = p4 - p3\n\n            r_cross_s = np.cross(r, s)\n            \n            # Case 1: Non-parallel lines\n            if abs(r_cross_s)  EPSILON:\n                q_minus_p = p3 - p1\n                t = np.cross(q_minus_p, s) / r_cross_s\n                u = np.cross(q_minus_p, r) / r_cross_s\n                if -EPSILON  t  1 + EPSILON and -EPSILON  u  1 + EPSILON:\n                    intersection_point = p1 + t * r\n                    raw_points.append(intersection_point)\n            \n            # Case 2: Parallel lines\n            else:\n                # Check for collinearity\n                if abs(np.cross(p3 - p1, r))  EPSILON:\n                    # Collect endpoints on the other segment\n                    overlap_pts = []\n                    if on_segment(p1, p3, p4): overlap_pts.append(p1)\n                    if on_segment(p2, p3, p4): overlap_pts.append(p2)\n                    if on_segment(p3, p1, p2): overlap_pts.append(p3)\n                    if on_segment(p4, p1, p2): overlap_pts.append(p4)\n\n                    if len(overlap_pts)  0:\n                        unique_pts = np.unique(np.round(np.array(overlap_pts), PRECISION), axis=0)\n                        if len(unique_pts) == 1:\n                            raw_points.append(unique_pts[0])\n                        elif len(unique_pts)  1:\n                            # Lexicographical sort of points\n                            sorted_pts = sorted([tuple(pt) for pt in unique_pts])\n                            raw_segments.append((np.array(sorted_pts[0]), np.array(sorted_pts[-1])))\n\n    # 2. Merge collinear segments\n    line_groups = {}\n    for p1, p2 in raw_segments:\n        # Canonical line representation: Ax + By + C = 0\n        a = p1[1] - p2[1]\n        b = p2[0] - p1[0]\n        c = -a * p1[0] - b * p1[1]\n        \n        norm = np.sqrt(a**2 + b**2)\n        if norm  EPSILON:\n            a, b, c = a / norm, b / norm, c / norm\n        \n        # Canonical sign convention\n        if a  -EPSILON or (abs(a)  EPSILON and b  -EPSILON):\n            a, b, c = -a, -b, -c\n            \n        key = (round(a, PRECISION-2), round(b, PRECISION-2), round(c, PRECISION-2))\n        if key not in line_groups:\n            line_groups[key] = []\n        line_groups[key].append((p1, p2))\n\n    merged_segments = []\n    for key, segments in line_groups.items():\n        # Project to 1D and merge intervals\n        a, b, c = key\n        # Use x-axis if not vertical, y-axis if vertical\n        is_vertical = abs(b)  EPSILON \n        \n        intervals = []\n        for p1, p2 in segments:\n            if is_vertical:\n                intervals.append(sorted((p1[1], p2[1])))\n            else:\n                intervals.append(sorted((p1[0], p2[0])))\n        \n        intervals.sort()\n        \n        if not intervals:\n            continue\n            \n        current_merge_start, current_merge_end = intervals[0]\n        \n        for i in range(1, len(intervals)):\n            next_start, next_end = intervals[i]\n            if next_start  current_merge_end + EPSILON:\n                current_merge_end = max(current_merge_end, next_end)\n            else:\n                start_pt, end_pt = (0,0), (0,0)\n                if is_vertical:\n                    x_coord = -c / a if abs(a)  EPSILON else 0\n                    start_pt, end_pt = np.array([x_coord, current_merge_start]), np.array([x_coord, current_merge_end])\n                else:\n                    m = -a / b if abs(b)  EPSILON else 0\n                    intercept = -c / b if abs(b)  EPSILON else 0\n                    start_pt = np.array([current_merge_start, m * current_merge_start + intercept])\n                    end_pt = np.array([current_merge_end, m * current_merge_end + intercept])\n                merged_segments.append((start_pt, end_pt))\n                current_merge_start, current_merge_end = next_start, next_end\n        \n        start_pt, end_pt = (0,0), (0,0)\n        if is_vertical:\n            x_coord = -c / a if abs(a)EPSILON else 0\n            start_pt, end_pt = np.array([x_coord, current_merge_start]), np.array([x_coord, current_merge_end])\n        else:\n            m = -a / b if abs(b)  EPSILON else 0\n            intercept = -c / b if abs(b)  EPSILON else 0\n            start_pt = np.array([current_merge_start, m * current_merge_start + intercept])\n            end_pt = np.array([current_merge_end, m * current_merge_end + intercept])\n        merged_segments.append((start_pt, end_pt))\n\n    # 3. Filter points\n    final_points_set = set()\n    if raw_points:\n        raw_points_rounded = np.round(np.array(raw_points), PRECISION)\n        unique_raw_points = np.unique(raw_points_rounded, axis=0)\n\n        for p in unique_raw_points:\n            is_on_any_segment = False\n            for s_p1, s_p2 in merged_segments:\n                if on_segment(p, s_p1, s_p2):\n                    is_on_any_segment = True\n                    break\n            if not is_on_any_segment:\n                final_points_set.add(tuple(p))\n\n    # 4. Final canonical representation\n    P = sorted(list(final_points_set))\n    final_P_list = [[float(f'{coord:.12f}'.rstrip('0').rstrip('.')) for coord in p] for p in P]\n\n    S_list = []\n    for p1, p2 in merged_segments:\n        p1_tuple, p2_tuple = tuple(p1), tuple(p2)\n        if p1_tuple  p2_tuple:\n            p1_tuple, p2_tuple = p2_tuple, p1_tuple\n        \n        p1_clean = [float(f'{coord:.12f}'.rstrip('0').rstrip('.')) for coord in p1_tuple]\n        p2_clean = [float(f'{coord:.12f}'.rstrip('0').rstrip('.')) for coord in p2_tuple]\n        \n        S_list.append(p1_clean + p2_clean)\n\n    S = sorted(S_list)\n\n    return [final_P_list, S]\n\nsolve()\n```"
        }
    ]
}