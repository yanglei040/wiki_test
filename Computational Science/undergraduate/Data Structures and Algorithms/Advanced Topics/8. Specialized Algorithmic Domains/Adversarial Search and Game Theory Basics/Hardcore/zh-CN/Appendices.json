{
    "hands_on_practices": [
        {
            "introduction": "理论知识是基础，但真正的理解来自于实践。这项练习将指导你将极小化极大算法与Alpha-Beta剪枝应用于一个具体的游戏中，让你从零开始构建一个完整的人工智能玩家。通过在一个环形棋盘上实现游戏逻辑，你将直接面对并解决在实际项目中遇到的状态表示、规则判定和算法集成等挑战。",
            "id": "3204320",
            "problem": "设计并实现一个完整的程序，该程序在一个环形棋盘上进行的确定性、完全信息、双人、零和博弈中，使用带 Alpha-Beta 剪枝 (ABP) 的极小化极大原理执行对抗性搜索。环形棋盘是一种离散网格，其索引在边缘处会回绕。该博弈是放置标记的一种变体，玩家轮流放置自己的标记，当一名玩家在水平、垂直、东南对角线或西南对角线这四个基本方向中的任意一个方向上，创建了一条完全由其标记组成的长度为 $k$ 的线时，该玩家获胜。棋盘的边缘是回绕的，因此从一个边缘走出将从相对的边缘重新出现。\n\n基本和核心定义：\n- 一个双人零和博弈有一个状态 $s$ 的效用函数 $u(s)$，使得一个玩家的收益是另一个玩家的损失。最大化方寻求最大化 $u(s)$，最小化方寻求最小化 $u(s)$。我们用 $X$（最大化方）和 $O$（最小化方）表示这两位玩家。\n- 极小化极大算法递归地定义一个状态 $s$ 的值为：如果是 $X$ 的回合，则 $V(s) = \\max_{a \\in A(s)} V(T(s,a))$; 如果是 $O$ 的回合，则 $V(s) = \\min_{a \\in A(s)} V(T(s,a))$，其中 $A(s)$ 是状态 $s$ 下的合法行动集合，$T(s,a)$ 是确定性转移函数。\n- Alpha-Beta 剪枝维护边界 $\\alpha$ 和 $\\beta$，使得对于博弈树中的任何节点，如果最大化方当前的最优值至少为 $\\beta$，或者最小化方当前的最优值至多为 $\\alpha$，则可以剪枝对兄弟节点的进一步探索，而不会影响最终的极小化极大值。\n- 环形回绕通过对索引进行模运算来实现。对于一个大小为 $n \\times n$ 的棋盘，从单元格 $(r,c)$ 沿方向 $(\\Delta r, \\Delta c)$ 移动到下一个单元格 $(r', c')$ 的计算公式为 $r' = (r + \\Delta r) \\bmod n$ 和 $c' = (c + \\Delta c) \\bmod n$。四个方向为 $(\\Delta r, \\Delta c) \\in \\{(0,1), (1,0), (1,1), (1,-1)\\}$。\n\n游戏规则：\n- 棋盘是一个 $n \\times n$ 的网格，其中 $n \\in \\mathbb{Z}_{\\ge 2}$。\n- 每个单元格包含 $X$、$O$ 或空符号点 $.$.\n- 玩家轮流在一个空单元格中放置自己的标记。\n- 当存在一个长度为 $k$ 的单元格序列，其中每一步都沿着上述四个方向之一，并且所有 $k$ 个单元格都包含同一玩家的标记时，该玩家获胜。索引以 $n$ 为模进行回绕。\n- 终局效用定义为：如果 $X$ 有获胜线，则 $u(s) = +1$；如果 $O$ 有获胜线，则 $u(s) = -1$；如果棋盘已满且没有获胜线，则 $u(s) = 0$。如果 $X$ 和 $O$ 同时拥有获胜线（这在合法游戏过程中不会发生，但可能出现在任意输入中），则定义 $u(s) = 0$。\n- 程序必须实现带 ABP 的极小化极大算法，以计算当前状态下当前玩家的最优效用和一个最优移动。\n\n获胜检测的数学表述：\n- 对于每个起始单元格 $(r,c)$ 和每个方向 $(\\Delta r, \\Delta c)$，检查序列 $\\{(r + t \\Delta r \\bmod n, c + t \\Delta c \\bmod n) \\mid t \\in \\{0,1,\\dots,k-1\\}\\}$ 中的所有单元格是否都包含 $X$ 或都包含 $O$。\n\n此问题的输入和输出规范：\n- 没有用户输入。将下面描述的测试套件直接硬编码在程序中。\n- 程序必须为每个测试用例计算一个包含以下两项的配对：\n  - 当前玩家的最优极小化极大效用，表示为 $\\{-1,0,+1\\}$ 中的一个整数。\n  - 一个最优移动，表示为使用零基索引的坐标 $(r,c)$。如果位置已经是终局或没有合法移动，则输出哨兵值 $(r,c) = (-1,-1)$。\n- 最终输出格式为包含所有测试用例结果的单行列表。每个独立的结果必须是 $[u,r,c]$ 形式的三个整数的列表，整个输出必须是 $[[u_1,r_1,c_1],[u_2,r_2,c_2],\\dots]$ 格式的单个列表，使用逗号分隔且无空格。\n\n测试套件：\n每个测试用例指定为一个元组 $(n,k,\\text{board},P)$，其中 $n$ 是棋盘大小，$k$ 是获胜长度，$\\text{board}$ 是一个包含 $n$ 个长度为 $n$ 的字符串的列表（使用字母表 $\\{X,O,.\\}$），$P \\in \\{X,O\\}$ 是当前要移动的玩家。\n\n- 测试用例 1（$X$ 通过环绕东南对角线立即获胜）：\n  - $n = 3$, $k = 3$, $P = X$。\n  - $\\text{board} = [\".OO\", \".X.\", \"..X\"]$。\n  - 预期的最优移动涉及到环绕对角线 $(2,2) \\to (0,0) \\to (1,1)$。\n\n- 测试用例 2（$O$ 立即完成水平线）：\n  - $n = 3$, $k = 3$, $P = O$。\n  - $\\text{board} = [\"O.O\", \"X.X\", \"X..\"]$。\n  - 最优移动将完成顶行。\n\n- 测试用例 3（已经是终局，$X$ 在环绕对角线上获胜）：\n  - $n = 3$, $k = 3$, $P = O$。\n  - $\\text{board} = [\"XOO\", \"OXO\", \"..X\"]$。\n  - 东南对角线 $(0,0) \\to (1,1) \\to (2,2)$ 全部是 $X$。\n\n- 测试用例 4（大小为 4，$k=4$，$O$ 立即完成一行）：\n  - $n = 4$, $k = 4$, $P = O$。\n  - $\\text{board} = [\".OOO\", \"XX..\", \"....\", \"....\"]$。\n\n- 测试用例 5（大小为 4，$k=3$，$X$ 通过一个非平凡的模式在环绕东南对角线上获胜）：\n  - $n = 4$, $k = 3$, $P = X$。\n  - $\\text{board} = [\"....\", \"X...\", \"....\", \"..X.\"]$。\n  - 获胜移动将完成环绕对角线 $(3,2) \\to (0,3) \\to (1,0)$。\n\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔的结果列表（例如，\"[[u1,r1,c1],[u2,r2,c2],...]\"），输出行中任何地方都不能有空格。所有索引 $(r,c)$ 必须是零基整数，效用值必须是 $\\{-1,0,+1\\}$ 中的整数。",
            "solution": "该问题要求实现带 Alpha-Beta 剪枝（ABP）的极小化极大算法，以在一个环形网格上的双人零和博弈中找到最优移动。该解决方案通过形式化博弈规则和状态，然后应用对抗性搜索的原理来设计。\n\n整体方法涉及从当前状态对博弈树进行递归探索。每个状态的值由极小化极大原理确定，该原理假设双方都进行最优博弈。最大化方（玩家 $X$）旨在达到效用尽可能高的状态，而最小化方（玩家 $O$）则旨在达到效用尽可能低的状态。Alpha-Beta 剪枝用于优化此搜索，通过消除那些无法影响最终决策的博弈树分支。\n\n该实现分为四个主要组成部分：\n1.  **状态评估**：一个函数，用于确定博弈状态是否为终局并计算其效用。\n2.  **移动生成**：一个函数，用于识别给定状态下的所有合法移动。\n3.  **递归搜索**：核心的 Alpha-Beta 搜索函数，递归地计算一个状态的极小化极大值。\n4.  **顶层驱动程序**：一个函数，用于组织对初始状态的搜索，以识别最优移动及其对应的效用。\n\n**1. 状态表示与终局评估**\n一个博弈状态 $s$ 由 $n \\times n$ 的棋盘配置和轮到哪位玩家决定。棋盘表示为一个二维数组，其中单元格可以被 $X$、$O$ 占据，或为空（$_.$）。\n\n如果一个玩家形成了一条获胜线，或者棋盘已满，则状态为终局。效用函数 $u(s)$ 定义如下：\n- 如果玩家 $X$ 有获胜线，则 $u(s) = +1$。\n- 如果玩家 $O$ 有获胜线，则 $u(s) = -1$。\n- 如果棋盘已满且没有赢家（平局），则 $u(s) = 0$。\n- 如果双方玩家同时有获胜线，则 $u(s) = 0$。\n\n获胜检测逻辑至关重要。玩家通过形成一条由 $k$ 个自己的标记组成的线来获胜。由于棋盘的环形特性，线可以环绕边缘。为了检查获胜，我们必须检查棋盘上的每个单元格 $(r,c)$ 作为潜在获胜线的起点。对于每个起始单元格，我们在四个基本方向 $(\\Delta r, \\Delta c) \\in \\{(0,1), (1,0), (1,1), (1,-1)\\}$ 中的每一个方向上进行检查。如果序列\n$$ \\{(r + t \\Delta r \\pmod n, c + t \\Delta c \\pmod n) \\mid t \\in \\{0, 1, \\dots, k-1\\}\\} $$\n中的所有 $k$ 个单元格都被该玩家的标记占据，则该玩家存在一条获胜线。模运算符处理环形回绕。评估函数首先检查 $X$ 是否获胜，然后检查 $O$ 是否获胜，最后检查棋盘是否已满，以确定状态的效用。如果状态不是终局，则不返回效用。\n\n**2. 移动生成**\n在一个非终局状态 $s$ 下，可用的行动集合 $A(s)$ 包括棋盘上所有的空单元格。通过简单地遍历棋盘网格，可以识别出所有内容为空符号的坐标 $(r,c)$。\n\n**3. Alpha-Beta 搜索算法**\n解决方案的核心是一个递归函数 `alpha_beta_search(state, player, alpha, beta)`，它计算给定状态的极小化极大值。参数 $\\alpha$ 和 $\\beta$ 表示在搜索树中到目前为止发现的可能效用值的边界。\n- $\\alpha$：到根节点的路径上，为最大化方找到的最佳值（最高效用）。\n- $\\beta$：到根节点的路径上，为最小化方找到的最佳值（最低效用）。\n\n该函数的操作如下：\n首先，它评估输入状态。如果状态是终局，它返回相应的效用（$+1, -1, 0$）。如果棋盘已满且没有赢家，则为平局，效用为 $0$。\n\n如果状态不是终局，函数根据当前玩家继续进行：\n- **如果 `player` 是 $X$（最大化方）：** 目标是最大化结果。函数初始化一个值 $v = -\\infty$。然后，它遍历每个合法移动，应用它来创建一个新的后继状态，并为最小化方（`player` = $O$）的回合递归调用 `alpha_beta_search`。值 $v$ 被更新为在子节点中找到的最大效用：$v = \\max(v, \\text{recursive\\_result})$。最大化方的下界 $\\alpha$ 被更新：$\\alpha = \\max(\\alpha, v)$。如果任何时候 $\\alpha \\ge \\beta$，则该分支的搜索被终止（剪枝），因为这意味着最小化方在树的更高层有一个更好的替代移动。\n\n- **如果 `player` 是 $O$（最小化方）：** 目标是最小化结果。函数初始化一个值 $v = +\\infty$。它遍历合法移动，创建后继状态，并为最大化方（`player` = $X$）的回合递归调用 `alpha_beta_search`。值 $v$ 被更新为最小效用：$v = \\min(v, \\text{recursive\\_result})$。最小化方的上界 $\\beta$ 被更新：$\\beta = \\min(\\beta, v)$。如果 $\\beta \\le \\alpha$，则发生剪枝，因为这意味着最大化方在别处有一个更好的选择。\n\n**4. 顶层驱动程序**\n一个主驱动函数启动该过程。它将初始博弈状态 $(n, k, \\text{board}, P)$ 作为输入。\n1. 它首先检查初始状态是否已经是终局或没有合法移动。如果是，则返回状态的效用和哨兵移动 $(-1,-1)$。\n2. 否则，它遍历当前玩家 $P$ 可用的所有合法移动。\n3. 对于每个潜在的移动，它生成结果棋盘状态，并调用 `alpha_beta_search` 函数来确定该移动的效用，假设对手进行最优博弈。对搜索函数的初始调用使用 $\\alpha = -\\infty$ 和 $\\beta = +\\infty$。\n4. 它跟踪导致当前玩家 $P$ 获得最佳可能效用的移动。对于玩家 $X$，这是导致最大效用的移动；对于玩家 $O$，这是导致最小效用的移动。\n5. 函数返回计算出的最优效用和相应的最优移动 $(r,c)$。\n这种全面的、基于原则的设计确保了根据极小化极大定理正确且高效地确定最优移动。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass ToroidalGame:\n    \"\"\"\n    Implements the logic for a toroidal k-in-a-row game and its solution\n    using minimax with alpha-beta pruning.\n    \"\"\"\n    def __init__(self, n, k, board_str, current_player):\n        self.n = int(n)\n        self.k = int(k)\n        self.board = np.array([list(row) for row in board_str])\n        self.current_player = current_player\n        self.directions = [(0, 1), (1, 0), (1, 1), (1, -1)]\n\n    def _check_win(self, board, player_mark):\n        \"\"\"Checks if a given player has a winning line on the board.\"\"\"\n        for r in range(self.n):\n            for c in range(self.n):\n                for dr, dc in self.directions:\n                    is_win = True\n                    for t in range(self.k):\n                        nr, nc = (r + t * dr) % self.n, (c + t * dc) % self.n\n                        if board[nr, nc] != player_mark:\n                            is_win = False\n                            break\n                    if is_win:\n                        return True\n        return False\n\n    def _evaluate_terminal(self, board):\n        \"\"\"\n        Evaluates a board state. Returns utility if terminal, else None.\n        Utility: +1 for X win, -1 for O win, 0 for draw or simultaneous win.\n        \"\"\"\n        win_X = self._check_win(board, 'X')\n        win_O = self._check_win(board, 'O')\n\n        if win_X and win_O:\n            return 0\n        if win_X:\n            return 1\n        if win_O:\n            return -1\n        if np.all(board != '.'):\n            return 0\n        return None  # Not terminal\n\n    def _get_legal_moves(self, board):\n        \"\"\"Returns a list of legal moves (empty cells).\"\"\"\n        return [(r, c) for r, c in zip(*np.where(board == '.'))]\n\n    def _alpha_beta_search(self, board, player, alpha, beta):\n        \"\"\"\n        Recursive core of the minimax algorithm with alpha-beta pruning.\n        \"\"\"\n        utility = self._evaluate_terminal(board)\n        if utility is not None:\n            return utility\n\n        moves = self._get_legal_moves(board)\n        if not moves:\n            return 0  # Draw if no moves and not a win state\n\n        if player == 'X':  # Maximizer\n            max_eval = -np.inf\n            for r, c in moves:\n                new_board = board.copy()\n                new_board[r, c] = 'X'\n                eval_child = self._alpha_beta_search(new_board, 'O', alpha, beta)\n                max_eval = max(max_eval, eval_child)\n                alpha = max(alpha, eval_child)\n                if beta = alpha:\n                    break\n            return max_eval\n        else:  # Minimizer (player == 'O')\n            min_eval = np.inf\n            for r, c in moves:\n                new_board = board.copy()\n                new_board[r, c] = 'O'\n                eval_child = self._alpha_beta_search(new_board, 'X', alpha, beta)\n                min_eval = min(min_eval, eval_child)\n                beta = min(beta, eval_child)\n                if beta = alpha:\n                    break\n            return min_eval\n\n    def find_best_move(self):\n        \"\"\"\n        Top-level driver to find the optimal move and utility for the current player.\n        \"\"\"\n        utility = self._evaluate_terminal(self.board)\n        if utility is not None:\n            return utility, -1, -1\n\n        moves = self._get_legal_moves(self.board)\n        if not moves:\n            return 0, -1, -1\n\n        best_move = (-1, -1)\n        if self.current_player == 'X':\n            best_val = -np.inf\n            for r, c in moves:\n                new_board = self.board.copy()\n                new_board[r, c] = 'X'\n                val = self._alpha_beta_search(new_board, 'O', -np.inf, np.inf)\n                if val > best_val:\n                    best_val = val\n                    best_move = (r, c)\n                # Optimization: if a winning move is found, no need to search further.\n                if best_val == 1:\n                    break\n        else:  # self.current_player == 'O'\n            best_val = np.inf\n            for r, c in moves:\n                new_board = self.board.copy()\n                new_board[r, c] = 'O'\n                val = self._alpha_beta_search(new_board, 'X', -np.inf, np.inf)\n                if val  best_val:\n                    best_val = val\n                    best_move = (r, c)\n                # Optimization: if a winning move is found, no need to search further.\n                if best_val == -1:\n                    break\n        \n        return int(best_val), int(best_move[0]), int(best_move[1])\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        (3, 3, [\".OO\", \".X.\", \"..X\"], 'X'),\n        (3, 3, [\"O.O\", \"X.X\", \"X..\"], 'O'),\n        (3, 3, [\"XOO\", \"OXO\", \"..X\"], 'O'),\n        (4, 4, [\".OOO\", \"XX..\", \"....\", \"....\"], 'O'),\n        (4, 3, [\"....\", \"X...\", \"....\", \"..X.\"], 'X'),\n    ]\n\n    results = []\n    for n, k, board_str, player in test_cases:\n        game = ToroidalGame(n, k, board_str, player)\n        utility, r, c = game.find_best_move()\n        results.append([utility, r, c])\n\n    output_str = f\"[{','.join([f'[{u},{r},{c}]' for u, r, c in results])}]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "许多真实世界的博弈比简单的树形结构更复杂，可能包含循环或巨大的状态空间。这项练习将探讨如何在更普遍的博弈图上应用对抗搜索，引入深度限制搜索和启发式评估等实用技术。你将学习如何处理搜索中的循环，并理解转置表（transposition table）在避免重复计算和提升效率中的关键作用()。",
            "id": "3204272",
            "problem": "给定一个确定性的、双人、零和博弈，该博弈表示为一个有限的状态有向图。玩家轮流行动，最大化玩家 (Max) 选择行动以最大化结果，最小化玩家 (Min) 选择行动以最小化结果。设状态集为 $S$，有向边关系 $E \\subseteq S \\times S$ 描述了合法的移动。一个终止状态 $s \\in S$ 有一个确定的效用值 $u(s) \\in \\mathbb{R}$，一个非终止状态有一个启发式估值 $h(s) \\in \\mathbb{R}$。行动权随深度严格交替：在起始状态，由 Max 行动，然后是 Min，依此类推。\n\n请在此图上实现一个深度受限的极小化极大算法，该算法使用置换表（记忆化）来避免重复计算并安全地处理循环。你的算法必须计算一个价值函数 $V(s,d)$，该函数需满足以下要求，这些要求源于对抗性搜索和零和效用的核心定义：\n\n1. 对于终止状态 $s$，在任何剩余深度 $d \\geq 0$ 下，$V(s,d) = u(s)$。\n2. 对于非终止状态 $s$，当剩余深度为 $d = 0$ 时，$V(s,0) = h(s)$。\n3. 对于 $d  0$ 且 $s$ 为非终止状态：\n   - 如果轮到 Max 在 $s$ 行动，则\n     $$V(s,d) = \\max_{s' \\in \\text{Succ}(s)} V(s', d-1)。$$\n   - 如果轮到 Min 在 $s$ 行动，则\n     $$V(s,d) = \\min_{s' \\in \\text{Succ}(s)} V(s', d-1)。$$\n4. 循环处理：如果在递归过程中遇到一个已存在于当前递归栈中的状态 $s$（即在当前路径中形成循环的回边），立即使用启发式函数对其进行评估，并为当前调用返回 $h(s)$。此规则确保了算法的终止性，并为循环提供了一致的回退策略。\n5. 置换表：缓存并重用已计算的值，这些值以元组 $(s, d, \\text{player})$ 为键，其中 $\\text{player}$ 指示在状态 $s$ 时轮到 Max 还是 Min 行动。这确保了重复的子问题，即使通过不同路径到达，也只被解决一次。\n\n如果一个状态 $s$ 是非终止状态且没有后继状态，则将其视为启发式回退，并返回 $h(s)$。\n\n你的程序必须实现上述逻辑，并对以下每个测试用例的起始状态进行评估。下面提供的所有整数和实数都应解释为没有物理单位的纯数值。\n\n测试套件：\n- 测试用例 $1$（包含简单循环和可达终止状态的常规路径）：\n  - 状态：$\\{0,1,2,3\\}$。\n  - 边：$0 \\to \\{1,2\\}$, $1 \\to \\{3\\}$, $2 \\to \\{0\\}$, $3 \\to \\{\\}$。\n  - 终止状态效用值：$u(3) = 5$。\n  - 启发式估值：$h(0) = 1$, $h(1) = 2$, $h(2) = 0$, $h(3) = 5$。\n  - 深度限制：$L = 4$。\n  - 起始状态：$s_0 = 0$。\n- 测试用例 $2$（边界情况：起始深度限制为零）：\n  - 图与测试用例 1 相同，但深度限制 $L = 0$。\n- 测试用例 $3$（混合分支，包含循环、多个终止状态和负效用值）：\n  - 状态：$\\{0,1,2,3,4,5\\}$。\n  - 边：$0 \\to \\{1,2\\}$, $1 \\to \\{3,4\\}$, $2 \\to \\{5\\}$, $3 \\to \\{\\}$, $4 \\to \\{1\\}$, $5 \\to \\{\\}$。\n  - 终止状态效用值：$u(3) = -2$, $u(5) = 0$。\n  - 启发式估值：$h(0) = 0$, $h(1) = 3$, $h(2) = -1$, $h(3) = -2$, $h(4) = 2$, $h(5) = 0$。\n  - 深度限制：$L = 3$。\n  - 起始状态：$s_0 = 0$。\n- 测试用例 $4$（不含终止状态的纯循环）：\n  - 状态：$\\{0,1\\}$。\n  - 边：$0 \\to \\{1\\}$, $1 \\to \\{0\\}$。\n  - 终止状态效用值：无。\n  - 启发式估值：$h(0) = 2$, $h(1) = -3$。\n  - 深度限制：$L = 5$。\n  - 起始状态：$s_0 = 0$。\n- 测试用例 $5$（强调启发式截断的浅层搜索）：\n  - 图与测试用例 3 相同，但深度限制 $L = 1$。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $[v_1,v_2,v_3,v_4,v_5]$），其中 $v_i$是根据上述规则为测试用例 $i$ 计算出的整数值 $V(s_0, L)$。",
            "solution": "该问题要求在一个以有向图表示的博弈上，实现一个深度受限的极小化极大搜索算法。该算法必须增加一个用于记忆化的置换表，以及一条处理图中循环的特定规则。目标是在指定的初始搜索深度 $L$ 下，计算给定起始状态 $s_0$ 的博弈论价值。\n\n**算法的指导原则**\n\n1.  **极小化极大原则**：算法的核心是极小化极大过程，该过程专为双人、确定性、零和博弈设计。在此类博弈中，一个玩家 (Max) 试图最大化一个效用分数，而另一个玩家 (Min) 则试图将其最小化。一个博弈状态 $s$ 的价值，记作 $V(s)$，是递归定义的。如果轮到 Max 从状态 $s$ 移动，其价值是从任何后继状态可获得的最大值：$V(s) = \\max_{s' \\in \\text{Succ}(s)} V(s')$。相反，如果轮到 Min，其价值是最小值：$V(s) = \\min_{s' \\in \\text{Succ}(s)} V(s')$。这个递归过程会一直展开，直到达到终止状态，在这些状态下游戏结束并被赋予一个固定的效用值 $u(s) \\in \\mathbb{R}$。\n\n2.  **深度受限搜索与启发式评估**：对于大型或包含循环的博弈图，将整个博弈树探索到终止状态通常在计算上是不可行的。深度受限搜索通过将搜索限制在最大深度 $L$ 来解决这个问题。当剩余搜索深度 $d$ 递减到 $0$ 时，递归终止。在这些截断点（可能是非终止状态），状态的价值使用启发式函数 $h(s) \\in \\mathbb{R}$ 进行估计。因此，价值函数被推广为同时依赖于状态和剩余深度，即 $V(s, d)$。规则也相应地调整：对于非终止状态 $s$，$V(s, 0) = h(s)$。\n\n3.  **行动权判定**：问题规定，玩家的行动权随搜索深度严格交替。初始调用 $V(s_0, L)$ 对应于层数（从搜索开始的移动次数）$p = 0$。按照惯例，这是 Max 的回合。在深度 $d$ 处的递归调用对应于层数 $p = L-d$。如果 $p$ 是偶数，则轮到 Max；如果 $p$ 是奇数，则轮到 Min。这可以通过条件 $(L-d) \\pmod 2 = 0$ 来检查。\n\n**用于增强鲁棒性和效率的高级算法机制**\n\n问题陈述强制要求对基础算法进行两项关键增强。\n\n1.  **置换表（记忆化）**：在图中，一个状态常常可以通过多条不同的路径到达。一个朴素的递归实现会在每次遇到同一个子问题时都重复解决它——即为给定玩家计算 $V(s,d)$。置换表是记忆化或动态规划的一种应用，可以防止这种冗余工作。每个已解决的子问题的价值都存储在缓存中，以唯一标识该子问题的元组 $(s, d, \\text{player})$ 为键。在计算子问题的价值之前，算法首先检查该表。如果找到了值，就立即返回。\n\n2.  **循环处理**：状态图中存在循环（例如 $s_1 \\to s_2 \\to s_1$）会带来无限递归的风险。指定的处理方法是维护当前递归路径的记录（即当前调用栈中的祖先状态集合）。如果算法试图评估一个已经在此路径上的状态 $s$，则检测到一个循环。该分支的递归将立即终止，并返回启发式价值 $h(s)$。这为循环路径提供了一致且能终止的评估方法。\n\n**综合算法结构**\n完整的算法实现为一个递归函数，我们称之为 `compute_v(state, depth, path)`，它整合了上述所有原则。评估一个状态的逻辑流程遵循严格的操作顺序：\n\n1.  根据初始深度 $L$ 和当前剩余深度 $d$ 确定当前玩家（Max 或 Min）。\n2.  为当前子问题构造键：$(\\text{state}, d, \\text{player})$。\n3.  检查置换表中是否存在此键。如果条目存在，则返回缓存的值。\n4.  应用终止递归的基本情况：\n    a. 如果 `state` 是一个终止状态，其价值为 $u(\\text{state})$。\n    b. 如果 `depth` 为 $0$，搜索被截断，其价值为启发式估值 $h(\\text{state})$。\n    c. 如果检测到循环（即 `state` 已存在于递归 `path` 中），其价值为 $h(\\text{state})$。\n    d. 如果 `state` 是非终止状态但没有后继者（死胡同），其价值为 $h(\\text{state})$。\n5.  如果没有满足基本情况，则继续递归步骤：\n    a. 将当前 `state` 添加到 `path` 集合中，以标记其进入递归栈。\n    b. 通过对所有后继状态 $s'$ 递归调用 `compute_v`（深度减为 $d-1$）来生成一个价值列表。\n    c. 在其所有子节点都被评估后，从 `path` 集合中移除当前 `state`。\n    d. 如果轮到 Max，结果是子节点价值的最大值。如果轮到 Min，结果是最小值。\n6.  在返回计算结果之前，将其及其对应的键存储在置换表中，以供未来查找使用。\n\n这种设计确保了计算的正确性、高效性和终止性，并遵守了问题陈述中指定的所有约束。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass GameSolver:\n    \"\"\"\n    Implements a depth-limited minimax algorithm with transposition tables and cycle handling.\n    \"\"\"\n    def __init__(self, edges, terminals, heuristics, initial_depth):\n        # Graph representation as an adjacency list\n        self.adj = edges\n        # Terminal states and their utilities\n        self.terminals = terminals\n        # Heuristic values for non-terminal states\n        self.heuristics = heuristics\n        # The total depth of the search from the start node\n        self.initial_depth = initial_depth\n        # Transposition table for memoization\n        self.memo = {}\n\n    def is_max_turn(self, depth: int) -> bool:\n        \"\"\"\n        Determines if it is the maximizing player's turn based on ply.\n        Ply is the number of moves from the start of the search.\n        The starting state is at ply 0 (Max's turn).\n        \"\"\"\n        ply = self.initial_depth - depth\n        return ply % 2 == 0\n\n    def compute_v(self, state: int, depth: int, path: set) -> float:\n        \"\"\"\n        Recursively computes the value of a state using depth-limited minimax.\n\n        Args:\n            state: The current state to evaluate.\n            depth: The remaining search depth.\n            path: The set of states in the current recursion stack (to detect cycles).\n\n        Returns:\n            The computed value of the state.\n        \"\"\"\n        is_max = self.is_max_turn(depth)\n        \n        # 1. Check transposition table (memoization)\n        memo_key = (state, depth, is_max)\n        if memo_key in self.memo:\n            return self.memo[memo_key]\n\n        # 2. Base Case: Terminal state\n        if state in self.terminals:\n            return float(self.terminals[state])\n\n        # 3. Base Case: Depth limit reached\n        if depth == 0:\n            return float(self.heuristics[state])\n            \n        # 4. Base Case: Cycle detected\n        if state in path:\n            return float(self.heuristics[state])\n\n        successors = self.adj.get(state, [])\n        \n        # 5. Base Case: Non-terminal state with no successors\n        if not successors:\n            return float(self.heuristics[state])\n\n        # 6. Recursive step\n        path.add(state)\n        \n        child_values = [self.compute_v(next_state, depth - 1, path) for next_state in successors]\n        \n        path.remove(state) # Backtrack\n\n        if is_max:\n            result = max(child_values)\n        else:\n            result = min(child_values)\n            \n        # Store result in transposition table before returning\n        self.memo[memo_key] = result\n        return result\n\ndef solve():\n    \"\"\"\n    Sets up and runs the test cases for the minimax algorithm.\n    \"\"\"\n    test_cases = [\n        # Test Case 1\n        {\n            \"start_state\": 0,\n            \"depth_limit\": 4,\n            \"states\": {0, 1, 2, 3},\n            \"edges\": {0: [1, 2], 1: [3], 2: [0]},\n            \"terminals\": {3: 5},\n            \"heuristics\": {0: 1, 1: 2, 2: 0, 3: 5},\n        },\n        # Test Case 2\n        {\n            \"start_state\": 0,\n            \"depth_limit\": 0,\n            \"states\": {0, 1, 2, 3},\n            \"edges\": {0: [1, 2], 1: [3], 2: [0]},\n            \"terminals\": {3: 5},\n            \"heuristics\": {0: 1, 1: 2, 2: 0, 3: 5},\n        },\n        # Test Case 3\n        {\n            \"start_state\": 0,\n            \"depth_limit\": 3,\n            \"states\": {0, 1, 2, 3, 4, 5},\n            \"edges\": {0: [1, 2], 1: [3, 4], 2: [5], 4: [1]},\n            \"terminals\": {3: -2, 5: 0},\n            \"heuristics\": {0: 0, 1: 3, 2: -1, 3: -2, 4: 2, 5: 0},\n        },\n        # Test Case 4\n        {\n            \"start_state\": 0,\n            \"depth_limit\": 5,\n            \"states\": {0, 1},\n            \"edges\": {0: [1], 1: [0]},\n            \"terminals\": {},\n            \"heuristics\": {0: 2, 1: -3},\n        },\n        # Test Case 5\n        {\n            \"start_state\": 0,\n            \"depth_limit\": 1,\n            \"states\": {0, 1, 2, 3, 4, 5},\n            \"edges\": {0: [1, 2], 1: [3, 4], 2: [5], 4: [1]},\n            \"terminals\": {3: -2, 5: 0},\n            \"heuristics\": {0: 0, 1: 3, 2: -1, 3: -2, 4: 2, 5: 0},\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        solver = GameSolver(\n            edges=case[\"edges\"],\n            terminals=case[\"terminals\"],\n            heuristics=case[\"heuristics\"],\n            initial_depth=case[\"depth_limit\"]\n        )\n        # Initial call to compute the value from the start state\n        value = solver.compute_v(\n            state=case[\"start_state\"],\n            depth=case[\"depth_limit\"],\n            path=set()\n        )\n        # The problem asks for an integer value in the output\n        results.append(int(round(value)))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "高效的对抗搜索严重依赖于快速存取和识别之前已经评估过的游戏状态，这正是转置表的功能。这项练习将深入探讨转置表的核心实现细节：如何为复杂的游戏状态（如棋盘布局）生成一个独特且可高效计算的哈希值。通过实现Zobrist哈希()，你将掌握一项强大的技术，它利用位运算的特性为游戏AI的性能优化奠定基础。",
            "id": "3204243",
            "problem": "您需要为一种在六边形网格上进行的双人连接游戏设计并实现一个 Zobrist 哈希函数，该游戏的状态可以表示为一个 $n \\times n$ 的菱形单元格，类似于 Hex 游戏。目标是为给定的棋盘位置计算一个 $64$ 位的哈希值。解决方案必须基于数据结构和算法的核心原理，这些原理是对抗性搜索和基本博弈论的基础，即哈希函数的定义、按位运算的性质，以及适用于置换表的增量式和均匀哈希的要求。\n\n基本原理：\n- 哈希函数是一种从大定义域（此处为游戏状态）到固定大小的上域（此处为 $64$ 位整数）的映射，旨在将输入均匀分布以减少冲突。\n- 按位异或（XOR）运算符，用 $\\oplus$ 表示，具有结合律和交换律，且每个 $x$ 关于 $\\oplus$ 的逆是其自身（即 $x \\oplus x = 0$ 和 $x \\oplus 0 = x$）。这些性质使得增量式更新成为可能，非常适用于对抗性搜索。\n\n实现规范：\n- 棋盘表示：一个 $n \\times n$ 的菱形，行索引 $r \\in \\{0,\\dots,n-1\\}$，列索引 $c \\in \\{0,\\dots,n-1\\}$。将单元格 $(r,c)$ 扁平化为位置索引 $p = r \\cdot n + c$，其中 $p \\in \\{0,\\dots,n^2 - 1\\}$。\n- 玩家与棋子：两名玩家，黑方（Black）和白方（White）。每个被占用的单元格恰好包含一颗棋子，不是黑子就是白子。空单元格不参与哈希输入。\n- Zobrist 密钥表：\n  - 对于每个位置索引 $p \\in \\{0,\\dots,n^2-1\\}$ 和每种棋子类型 $t \\in \\{\\text{Black}, \\text{White}\\}$，都有一个 $64$ 位的密钥 $K[p,t]$。\n  - 此外，还有一个单独的 $64$ 位密钥 $K_{\\text{turn}}$，仅当轮到黑方走棋时使用。\n- 伪随机密钥生成：\n  - 密钥必须由 SplitMix64 序列生成，该序列使用一个固定的无符号 $64$ 位整数 $s$ 作为种子。\n  - SplitMix64 状态更新和输出在无符号 $64$ 位算术中定义如下：\n    1. 更新状态：$x \\leftarrow x + \\text{0x9E3779B97F4A7C15}$。\n    2. 令 $z \\leftarrow x$。\n    3. $z \\leftarrow \\left(z \\oplus (z \\gg 30)\\right) \\cdot \\text{0xBF58476D1CE4E5B9}$。\n    4. $z \\leftarrow \\left(z \\oplus (z \\gg 27)\\right) \\cdot \\text{0x94D049BB133111EB}$。\n    5. $z \\leftarrow z \\oplus (z \\gg 31)$。\n    6. 值 $z$ 是下一个 $64$ 位输出。\n  - 用 $x \\leftarrow s$ 初始化状态。然后按以下顺序生成密钥：对于从 $0$ 到 $n^2-1$ 的 $p$，首先是 $K[p,\\text{Black}]$，然后是 $K[p,\\text{White}]$，最后是 $K_{\\text{turn}}$。\n- 给定位置的哈希计算：\n  - 给定一个已占用单元格的列表 $S = \\{(r_i,c_i,t_i)\\}$，其中 $t_i \\in \\{\\text{Black}, \\text{White}\\}$，以及轮到走棋的一方 $\\text{side} \\in \\{\\text{Black}, \\text{White}\\}$，Zobrist 哈希值 $H$ 的计算方式如下\n    $$ H \\;=\\; \\left( \\bigoplus_{(r_i,c_i,t_i) \\in S} K[r_i \\cdot n + c_i, t_i] \\right) \\;\\oplus\\; \\begin{cases}\n    K_{\\text{turn}},  \\text{if side is Black} \\\\\n    0,  \\text{if side is White}\n    \\end{cases}. $$\n  - 输出必须解释为十进制表示的无符号 $64$ 位整数。\n\n您的程序的输入由本问题陈述固定，并且必须嵌入到您的代码中。不允许外部输入。\n\n使用以下固定种子进行密钥生成：$s = 1$。\n\n测试套件：\n- 案例 1：$n = 3$，棋子 $S = [\\,]$，轮到走棋方 $=$ Black。\n- 案例 2：$n = 3$，棋子 $S = [\\,($1$, $1$, Black)$\\,]$，轮到走棋方 $=$ White。\n- 案例 3：$n = 3$，棋子 $S = [\\,($1$, $1$, Black)$\\,]$，轮到走棋方 $=$ Black。\n- 案例 4：$n = 3$，棋子 $S = [\\,($0$, $0$, Black), ($0$, $2$, White), ($2$, $0$, White), ($2$, $2$, Black)$\\,]$，轮到走棋方 $=$ White。\n- 案例 5：$n = 5$，棋子 $S = [\\,($0$, $4$, Black), ($4$, $0$, White), ($2$, $2$, Black), ($1$, $3$, White)$\\,]$，轮到走棋方 $=$ Black。\n- 案例 6：$n = 5$，棋子 $S = [\\,($0$, $4$, Black), ($4$, $0$, White), ($2$, $2$, Black), ($1$, $3$, White)$\\,]$，轮到走棋方 $=$ Black。此案例与案例5重复，以验证相同的位置产生相同的哈希值。\n\n您的程序必须完全按照上述规定为每个测试案例计算哈希值，并生成单行输出，其中包含用方括号括起来的、以逗号分隔的哈希值列表。例如，输出格式必须完全符合\n- $[h_1,h_2,h_3,h_4,h_5,h_6]$\n其中每个 $h_i$ 是相应 $64$ 位哈希值的无符号十进制表示。本问题不涉及单位。角度和百分比不适用。",
            "solution": "用户提供了一个问题，要求为一个在 $n \\times n$ 六边形网格上进行的双人连接游戏设计并实现一个 Zobrist 哈希函数。在进行详细解答之前，本分析将首先验证问题陈述的科学合理性、良构性和客观性。\n\n### 步骤1：提取已知条件\n\n问题陈述提供了以下规范：\n- **任务**：为一个在 $n \\times n$ 菱形网格上的游戏状态设计并实现一个 Zobrist 哈希函数。\n- **哈希值大小**：输出的哈希值必须是一个 $64$ 位整数。\n- **基本原理**：解决方案必须基于哈希函数和按位异或（XOR, $\\oplus$）运算符的性质。\n- **棋盘表示**：一个 $n \\times n$ 的网格，其中单元格 $(r, c)$ 被扁平化为位置索引 $p = r \\cdot n + c$，其中 $r, c \\in \\{0, \\dots, n-1\\}$。\n- **游戏棋子**：两个玩家，黑方（Black）和白方（White）。被占用的单元格包含一个棋子。空的单元格不参与哈希计算。\n- **Zobrist 密钥表**：\n    - 对于每个位置索引 $p \\in \\{0, \\dots, n^2 - 1\\}$ 和每种棋子类型 $t \\in \\{\\text{Black}, \\text{White}\\}$，都存在一个 $64$ 位的密钥 $K[p, t]$。\n    - 一个单独的 $64$ 位密钥 $K_{\\text{turn}}$ 用于黑方走棋的情况。\n- **密钥生成**：\n    - 密钥使用 SplitMix64 算法生成。\n    - 该算法使用一个固定的无符号 $64$ 位整数 $s$ 作为种子。\n    - SplitMix64 状态 $x$ 通过 $x \\leftarrow x + \\text{0x9E3779B97F4A7C15}$ 更新。\n    - 输出 $z$ 是根据状态 $x$ 通过以下序列生成的：$z \\leftarrow x$, $z \\leftarrow (z \\oplus (z \\gg 30)) \\cdot \\text{0xBF58476D1CE4E5B9}$, $z \\leftarrow (z \\oplus (z \\gg 27)) \\cdot \\text{0x94D049BB133111EB}$，以及 $z \\leftarrow z \\oplus (z \\gg 31)$。所有操作均为无符号 $64$ 位算术。\n    - 初始种子为 $s = 1$。\n    - 密钥生成顺序为：对于 $p = 0, \\dots, n^2-1$，先生成 $K[p, \\text{Black}]$，然后是 $K[p, \\text{White}]$。最后，生成 $K_{\\text{turn}}$。\n- **哈希计算公式**：\n    $$ H \\;=\\; \\left( \\bigoplus_{(r_i,c_i,t_i) \\in S} K[r_i \\cdot n + c_i, t_i] \\right) \\;\\oplus\\; \\begin{cases} K_{\\text{turn}},  \\text{if side is Black} \\\\ 0,  \\text{if side is White} \\end{cases} $$\n    其中 $S$ 是已占用单元格的集合。\n- **输出格式**：哈希值 $H$ 是一个十进制表示的无符号 $64$ 位整数。\n- **测试套件**：\n    - 案例 1：$n = 3$, $S = [\\,]$, 走棋方 = Black。\n    - 案例 2：$n = 3$, $S = [\\,(1, 1, \\text{Black})\\,]$, 走棋方 = White。\n    - 案例 3：$n = 3$, $S = [\\,(1, 1, \\text{Black})\\,]$, 走棋方 = Black。\n    - 案例 4：$n = 3$, $S = [\\,(0, 0, \\text{Black}), (0, 2, \\text{White}), (2, 0, \\text{White}), (2, 2, \\text{Black})\\,]$, 走棋方 = White。\n    - 案例 5：$n = 5$, $S = [\\,(0, 4, \\text{Black}), (4, 0, \\text{White}), (2, 2, \\text{Black}), (1, 3, \\text{White})\\,]$, 走棋方 = Black。\n    - 案例 6：$n = 5$, $S = [\\,(0, 4, \\text{Black}), (4, 0, \\text{White}), (2, 2, \\text{Black}), (1, 3, \\text{White})\\,]$, 走棋方 = Black。\n\n### 步骤2：使用提取的已知条件进行验证\n\n根据既定标准对问题进行评估：\n- **科学依据**：该问题在根本上是合理的。Zobrist 哈希是计算机科学中一种标准且广泛使用的技术，用于高效地哈希游戏状态，特别是在棋类游戏程序中，如国际象棋、围棋和Hex。使用XOR进行增量更新是该技术的核心特性。SplitMix64 算法是一个定义明确且知名的伪随机数生成器。\n- **良构性**：该问题是良构的。它为任务的每个组成部分提供了完整而明确的规范：数据结构、密钥生成算法（包括种子和常量）、哈希计算公式以及所有测试用例的精确输入。这种确定性保证了唯一且可验证的解决方案。\n- **客观性**：问题陈述完全客观，使用形式化的数学和算法语言。它没有任何主观断言或歧义。\n\n该问题没有任何无效性标志。这是一个形式化且具体的算法实现问题，与指定的对抗性搜索主题直接相关。\n\n### 步骤3：结论与行动\n\n问题陈述有效。将提供一个完整的解决方案。\n\n### 解决方案\n\n该解决方案包含三个主要部分：SplitMix64 伪随机数生成器（PRNG）、Zobrist 密钥表生成逻辑，以及最终的哈希计算算法。\n\n**1. SplitMix64 伪随机数生成器**\n\nZobrist 哈希的基础是一个高质量的伪随机数表。问题指定了使用 SplitMix64 算法来完成此任务。该生成器维护一个单独的 $64$ 位无符号整数状态，我们将其表示为 $x$。\n\n- **初始化**：状态 $x$ 使用提供的种子 $s$ 进行初始化。对于本问题，$s=1$。\n- **生成**：要生成下一个 $64$ 位数字，需执行以下步骤，使用无符号 $64$ 位算术，其中所有溢出都会回绕（即模 $2^{64}$）：\n    1. 更新状态：$x \\leftarrow x + \\text{0x9E3779B97F4A7C15}$。\n    2. 将临时变量 $z$ 设置为新状态：$z \\leftarrow x$。\n    3. 变量 $z$ 通过一系列“雪崩”操作（异或、移位和乘法）以提高其统计随机性：\n        a. $z \\leftarrow (z \\oplus (z \\gg 30)) \\cdot \\text{0xBF58476D1CE4E5B9}$\n        b. $z \\leftarrow (z \\oplus (z \\gg 27)) \\cdot \\text{0x94D049BB133111EB}$\n        c. $z \\leftarrow z \\oplus (z \\gg 31)$\n    4. $z$ 的最终值就是生成的 $64$ 位伪随机密钥。\n\n**2. Zobrist 密钥表生成**\n\n所需的密钥一次性生成并存储在一个表中。对于一个大小为 $n \\times n$ 的棋盘，一个棋子有 $n^2$ 个可能的位置。由于有两种棋子类型（黑方和白方），我们需要 $2 \\cdot n^2$ 个棋子-位置密钥。另外还需要一个额外的密钥用于表示走棋方。\n\n- 使用种子 $s = 1$ 初始化一个 PRNG 实例。\n- 分配一个表，可以表示为一个大小为 $(n^2, 2)$ 的二维数组 `piece_keys`，用于存储 $K[p, t]$。我们可以将黑方（Black）映射到索引 0，白方（White）映射到索引 1。\n- 根据指定的顺序填充该表：\n    - 对于从 $0$ 到 $n^2 - 1$ 的每个位置索引 $p$：\n        - 生成该位置上黑棋的密钥：`piece_keys[p, 0]` $\\leftarrow$ `prng.next()`。\n        - 生成该位置上白棋的密钥：`piece_keys[p, 1]` $\\leftarrow$ `prng.next()`。\n- 填充完棋子-位置密钥后，生成最后一个用于表示走棋方的密钥：$K_{\\text{turn}} \\leftarrow$ `prng.next()`。\n\n由于测试套件包含 $n=3$ 和 $n=5$ 的情况，因此必须生成两个独立的密钥表，每种尺寸一个，两者都使用相同的初始种子 $s=1$。这是一个关键细节；生成器不会为每个表重新播种。相反，会为每个 $n$ 值创建一个新的生成器。\n\n**3. 哈希计算**\n\n给定棋盘状态的 Zobrist 哈希值是棋盘上存在的每个特征对应密钥的异或和。\n\n- 哈希计算以初始值 $H = 0$ 开始。XOR 的单位元是 $0$，所以这是一个中性的起始点。\n- 对于已放置棋子集合 $S$ 中的每个棋子 $(r_i, c_i, t_i)$：\n    - 将网格坐标 $(r_i, c_i)$ 转换为一维位置索引 $p_i = r_i \\cdot n + c_i$。\n    - 通过与该位置上该棋子的密钥进行异或运算来更新哈希值：$H \\leftarrow H \\oplus K[p_i, t_i]$。\n- 处理完所有棋子后，考虑走棋方：\n    - 如果当前轮到黑方走棋，则通过与走棋方密钥进行异或运算来更新哈希值：$H \\leftarrow H \\oplus K_{\\text{turn}}$。\n    - 如果轮到白方走棋，则不执行任何进一步操作（等同于与 $0$ 进行异或）。\n- $H$ 的最终值即为该棋盘状态的 $64$ 位 Zobrist 哈希值。然后将该值表示为十进制以供最终输出。\n\n此过程将应用于六个测试用例中的每一个，使用适当的密钥表（$n=3$ 或 $n=5$），以生成最终的哈希值序列。重复的测试用例（5 和 6）根据该算法的确定性，必须产生完全相同的哈希值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes Zobrist hashes for a series of board states according to the problem specification.\n    \"\"\"\n    \n    # Define constants for players and sides to improve readability\n    BLACK = 0\n    WHITE = 1\n\n    class SplitMix64:\n        \"\"\"\n        Implements the SplitMix64 pseudorandom number generator for 64-bit unsigned integers.\n        NumPy with dtype=np.uint64 is used to correctly handle 64-bit unsigned arithmetic.\n        \"\"\"\n        def __init__(self, seed: int):\n            self.state = np.uint64(seed)\n\n        def next(self) - np.uint64:\n            \"\"\"Generates the next 64-bit unsigned integer in the sequence.\"\"\"\n            # All arithmetic is performed on np.uint64, which handles wrap-around correctly.\n            self.state += np.uint64(0x9E3779B97F4A7C15)\n            z = self.state\n            z = (z ^ (z  np.uint64(30))) * np.uint64(0xBF58476D1CE4E5B9)\n            z = (z ^ (z  np.uint64(27))) * np.uint64(0x94D049BB133111EB)\n            z = z ^ (z  np.uint64(31))\n            return z\n\n    class ZobristHasher:\n        \"\"\"\n        Manages Zobrist keys and computes hashes for game states.\n        \"\"\"\n        def __init__(self, n: int, seed: int):\n            self.n = n\n            num_positions = n * n\n            # Table for piece-position keys: K[p, t]\n            self.piece_keys = np.zeros((num_positions, 2), dtype=np.uint64)\n            # Single key for side to move\n            self.turn_key = np.uint64(0)\n            self._generate_keys(seed)\n\n        def _generate_keys(self, seed: int):\n            \"\"\"\n            Generates and populates the Zobrist key table using SplitMix64.\n            \"\"\"\n            prng = SplitMix64(seed)\n            num_positions = self.n * self.n\n            for p in range(num_positions):\n                # As per spec: first K[p, Black], then K[p, White]\n                self.piece_keys[p, BLACK] = prng.next()\n                self.piece_keys[p, WHITE] = prng.next()\n            # Finally, the turn key\n            self.turn_key = prng.next()\n\n        def compute_hash(self, stones: list[tuple[int, int, int]], side_to_move: int) - np.uint64:\n            \"\"\"\n            Computes the Zobrist hash for a given board state.\n            \"\"\"\n            hash_val = np.uint64(0)\n            \n            # XOR keys for each piece on the board\n            for r, c, piece_type in stones:\n                pos_index = r * self.n + c\n                hash_val ^= self.piece_keys[pos_index, piece_type]\n            \n            # XOR turn key if it is Black's move\n            if side_to_move == BLACK:\n                hash_val ^= self.turn_key\n                \n            return hash_val\n\n    # Define the test cases from the problem statement.\n    # Player and side are represented by the integer constants BLACK and WHITE.\n    test_cases = [\n        {'n': 3, 'stones': [], 'side': BLACK},\n        {'n': 3, 'stones': [(1, 1, BLACK)], 'side': WHITE},\n        {'n': 3, 'stones': [(1, 1, BLACK)], 'side': BLACK},\n        {'n': 3, 'stones': [(0, 0, BLACK), (0, 2, WHITE), (2, 0, WHITE), (2, 2, BLACK)], 'side': WHITE},\n        {'n': 5, 'stones': [(0, 4, BLACK), (4, 0, WHITE), (2, 2, BLACK), (1, 3, WHITE)], 'side': BLACK},\n        {'n': 5, 'stones': [(0, 4, BLACK), (4, 0, WHITE), (2, 2, BLACK), (1, 3, WHITE)], 'side': BLACK},\n    ]\n\n    results = []\n    # Cache ZobristHasher instances to avoid re-generating keys for the same board size 'n'.\n    # A new hasher (and thus a new set of keys from a fresh PRNG) is created for each unique 'n'.\n    hashers = {}\n    seed = 1\n\n    for case in test_cases:\n        n = case['n']\n        \n        if n not in hashers:\n            hashers[n] = ZobristHasher(n=n, seed=seed)\n        \n        hasher = hashers[n]\n        h = hasher.compute_hash(case['stones'], case['side'])\n        results.append(str(h))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}