{
    "hands_on_practices": [
        {
            "introduction": "掌握Alpha-Beta剪枝算法的第一步是真正理解其内部机制。这个练习将指导你手动追踪在一个小型博弈树上的搜索过程。通过比较两种不同评估函数引导下的节点访问顺序，你将亲眼见证节点排序如何深刻影响剪枝效率和搜索路径，即使最终的极小化极大值保持不变，这是建立算法直觉的关键一步。",
            "id": "3252710",
            "problem": "考虑一个固定的层深度的确定性、零和、完美信息博弈树，其根节点 $R$ 位于深度 $0$。适用标准的极小化极大（minimax）定义：极大化（MAX）节点的值等于其子节点值的最大值，而极小化（MIN）节点的值等于其子节点值的最小值。Alpha-Beta 剪枝沿搜索路径维护边界 $[\\alpha,\\beta]$，其不变式为：当一个极大化节点的已知最佳下界 $\\alpha$ 达到或超过其祖先极小化节点的已知最佳上界 $\\beta$ 时，无需探索该节点的其他子节点；对称地，对于一个极小化节点，当 $\\beta \\le \\alpha$ 时也是如此。\n\n该树的结构如下。根节点 $R$ 是一个 MAX 节点，有两个 MIN 子节点，$A$（左）和 $B$（右）。$A$ 和 $B$ 各有两个 MAX 子节点。$A$ 的 MAX 子节点是 $A_1$（左）和 $A_2$（右）。$B$ 的 MAX 子节点是 $B_1$（左）和 $B_2$（右）。每个 MAX 子节点都恰好有两个终端叶节点，其效用值如下所示。所有终端效用值都是精确且确定性的。\n\n- $A_1$ 下的叶节点：$\\{4,2\\}$。\n- $A_2$ 下的叶节点：$\\{4,1\\}$。\n- $B_1$ 下的叶节点：$\\{4,1\\}$。\n- $B_2$ 下的叶节点：$\\{4,2\\}$。\n\n因此，该树是左右镜像的：$A$ 下的叶节点效用值的多重集是 $\\{4,2,4,1\\}$，而 $B$ 下的是 $\\{4,1,4,2\\}$。\n\n假设对终端叶节点进行全宽度搜索，但非终端节点的移动排序由一个局部评估函数驱动。给定了两个不同的评估函数，$E_1$ 和 $E_2$，两者都仅用于在搜索前对兄弟节点进行排序。在每个非终端节点，子节点都按照该节点上评估函数值的严格递减顺序进行扩展。在终端节点， $E_1$ 和 $E_2$ 都返回精确的效用值。由 $E_1$ 和 $E_2$ 导出的兄弟节点排序如下：\n\n- 在 $R$ 处：$E_1(A) = 4.10$ 且 $E_1(B) = 4.00$；$E_2(A) = 3.95$ 且 $E_2(B) = 4.05$。\n- 在 $A$ 处：$E_1(A_1) = 4.20$ 且 $E_1(A_2) = 4.15$；$E_2(A_1) = 4.00$ 且 $E_2(A_2) = 4.05$。\n- 在 $B$ 处：$E_1(B_1) = 4.60$ 且 $E_1(B_2) = 4.40$；$E_2(B_1) = 4.35$ 且 $E_2(B_2) = 4.50$。\n- 在每个 MAX 节点的叶节点处，排序按终端效用值递减，即效用值为 $4$ 的叶节点在效用值为 $2$ 或 $1$ 的叶节点之前被访问。\n\n极小化极大选择中的平局打破规则是“先到先得”：当一个节点有多个子节点共享相同的极小化极大值时，算法使用在这些并列者中首先访问的子节点来记录主变例（PV）。\n\n使用 $E_1$ 排序规则进行一次 alpha-beta 搜索，再使用 $E_2$ 排序规则进行一次。仅根据上述正式定义和精确的叶节点效用值，选择所有正确的陈述。\n\nA. 在 $E_1$ 和 $E_2$ 两种排序下，根节点的极小化极大值都是 $4$。\n\nB. 在 $E_1$ 和 $E_2$ 下，主变例不同：在 $E_1$ 下，主变例为 $R \\rightarrow A \\rightarrow A_1 \\rightarrow$ 效用值为 $4$ 的叶节点，而在 $E_2$ 下，主变例为 $R \\rightarrow B \\rightarrow B_2 \\rightarrow$ 效用值为 $4$ 的叶节点。\n\nC. 在 $E_1$ 和 $E_2$ 两种排序下，由于树的左右对称性以及指定的排序和平局打破规则，alpha-beta 剪枝都恰好剪掉了 $3$ 个终端叶节点的评估。\n\nD. 尽管在 $E_1$ 和 $E_2$ 下剪枝的叶节点数量可能相同，但两次搜索中被剪枝的叶节点的身份完全相同。\n\nE. 在 $E_2$ 下，因为 $B_1$ 包含一个效用值为 $5$ 的叶节点，所以根节点的极小化极大值变为 $5$。\n\n选择所有正确的选项。通过从所提供定义的第一性原理出发，推导极小化极大值和 alpha-beta 截断来证明你的选择。不要假设任何超出规定范围的未说明属性。",
            "solution": "## 问题验证\n\n### 步骤 1：提取已知条件\n- **博弈树**：确定性、零和、完美信息、固定层深度。\n- **根节点**：$R$，位于深度 $0$，是一个 MAX 节点。\n- **节点结构**：\n    - $R$ 有两个 MIN 子节点：$A$ (左) 和 $B$ (右)。\n    - $A$ 有两个 MAX 子节点：$A_1$ (左) 和 $A_2$ (右)。\n    - $B$ 有两个 MAX 子节点：$B_1$ (左) 和 $B_2$ (右)。\n- **终端效用值**：\n    - $A_1$ 下的叶节点：$\\{4, 2\\}$。\n    - $A_2$ 下的叶节点：$\\{4, 1\\}$。\n    - $B_1$ 下的叶节点：$\\{4, 1\\}$。\n    - $B_2$ 下的叶节点：$\\{4, 2\\}$。\n- **移动排序**：子节点按照评估函数值的严格递减顺序进行扩展。\n- **评估函数 $E_1$ 排序**：\n    - 在 $R$ 处：$E_1(A) = 4.10  E_1(B) = 4.00 \\implies$ 顺序为 $A$，然后是 $B$。\n    - 在 $A$ 处：$E_1(A_1) = 4.20  E_1(A_2) = 4.15 \\implies$ 顺序为 $A_1$，然后是 $A_2$。\n    - 在 $B$ 处：$E_1(B_1) = 4.60  E_1(B_2) = 4.40 \\implies$ 顺序为 $B_1$，然后是 $B_2$。\n- **评估函数 $E_2$ 排序**：\n    - 在 $R$ 处：$E_2(A) = 3.95  E_2(B) = 4.05 \\implies$ 顺序为 $B$，然后是 $A$。\n    - 在 $A$ 处：$E_2(A_1) = 4.00  E_2(A_2) = 4.05 \\implies$ 顺序为 $A_2$，然后是 $A_1$。\n    - 在 $B$ 处：$E_2(B_1) = 4.35  E_2(B_2) = 4.50 \\implies$ 顺序为 $B_2$，然后是 $B_1$。\n- **叶节点排序**：在 MAX 节点（$A_1, A_2, B_1, B_2$）处，终端叶节点按效用值递减顺序访问。\n- **平局打破**：对于主变例（PV），选择产生极小化极大值的第一个遇到的子节点。\n- **Alpha-Beta 剪枝规则**：在 MAX 节点，如果 $\\alpha \\ge \\beta$ 则剪枝。在 MIN 节点，如果 $\\beta \\le \\alpha$ 则剪枝。\n\n### 步骤 2：使用提取的已知条件进行验证\n问题陈述在科学上是合理的、适定的和客观的。它为两种独立场景提供了关于博弈树、终端效用值和确定性移动排序规则的完整且一致的描述。这使得对每种情况下的 alpha-beta 搜索算法进行严格且唯一的追踪成为可能。该问题是人工智能算法中的一个标准练习，没有事实错误、矛盾或歧义。前提是可形式化的，并与主题直接相关。选项 E 引入了一个与已知条件矛盾的前提（“$B_1$ 包含一个效用值为 $5$ 的叶节点”），但这是待评估选项的一个特点，而不是核心问题陈述中的缺陷。任务是根据所提供的设置确定哪些选项是正确的，而一个带有错误前提的选项根本不是关于给定问题的真实陈述。\n\n### 步骤 3：结论与行动\n此问题是**有效的**。解决方案将通过推导每种评估函数的 alpha-beta 搜索结果，然后评估每个选项来继续。\n\n## 解题推导\n\n首先，我们确定没有剪枝时树的真实极小化极大值，以此作为基准。\n- Value($A_1$) = $\\max(4, 2) = 4$。\n- Value($A_2$) = $\\max(4, 1) = 4$。\n- Value($B_1$) = $\\max(4, 1) = 4$。\n- Value($B_2$) = $\\max(4, 2) = 4$。\n- Value($A$) = $\\min(\\text{Value}(A_1), \\text{Value}(A_2)) = \\min(4, 4) = 4$。\n- Value($B$) = $\\min(\\text{Value}(B_1), \\text{Value}(B_2)) = \\min(4, 4) = 4$。\n- Value($R$) = $\\max(\\text{Value}(A), \\text{Value}(B)) = \\max(4, 4) = 4$。\n根节点 $R$ 的真实极小化极大值是 $4$。\n\n### 使用 $E_1$ 排序的 Alpha-Beta 搜索\n\n遍历顺序为：$R \\rightarrow A \\rightarrow A_1 \\rightarrow \\text{叶节点} \\rightarrow A_2 \\rightarrow \\text{叶节点} \\rightarrow B \\rightarrow B_1 \\rightarrow \\text{叶节点} \\rightarrow B_2 \\rightarrow \\text{叶节点}$。叶节点顺序按效用值从高到低。\n\n1.  **$R$ (MAX, $\\alpha=-\\infty, \\beta=+\\infty$)**：访问子节点 $A$。\n2.  **$A$ (MIN, $\\alpha=-\\infty, \\beta=+\\infty$)**：访问子节点 $A_1$。\n3.  **$A_1$ (MAX, $\\alpha=-\\infty, \\beta=+\\infty$)**：访问效用值为 $4$ 的叶节点。$A_1$ 的局部 $\\alpha$ 变为 $4$。访问效用值为 $2$ 的叶节点。$\\max(4,2)=4$。$A_1$ 返回值 $4$。\n4.  **$A$ (MIN, $\\alpha=-\\infty, \\beta=+\\infty$)**：从 $A_1$ 接收到值 $4$。作为一个 MIN 节点，其值现在 $\\le 4$。$A$ 将其 $\\beta$ 更新为 $4$。其剩余子节点的当前边界为 $[\\alpha=-\\infty, \\beta=4]$。\n5.  **$A$ (MIN, $\\alpha=-\\infty, \\beta=4$)**：访问子节点 $A_2$。\n6.  **$A_2$ (MAX, $\\alpha=-\\infty, \\beta=4$)**：访问效用值为 $4$ 的叶节点。$A_2$ 的局部 $\\alpha$ 变为 $4$。**剪枝检查**：$\\alpha \\ge \\beta$（$4 \\ge 4$）为真。**剪掉** $A_2$ 的剩余子节点（效用值为 $1$ 的叶节点）。$A_2$ 返回其当前最优值 $4$。\n7.  **$A$ (MIN, $\\alpha=-\\infty, \\beta=4$)**：从 $A_2$ 接收到值 $4$。值为 $\\min(4, 4)=4$。$A$ 没有更多子节点，返回最终值 $4$。\n8.  **$R$ (MAX, $\\alpha=-\\infty, \\beta=+\\infty$)**：从 $A$ 接收到值 $4$。作为一个 MAX 节点，其值现在 $\\ge 4$。$R$ 将其 $\\alpha$ 更新为 $4$。其剩余子节点的当前边界为 $[\\alpha=4, \\beta=+\\infty]$。\n9.  **$R$ (MAX, $\\alpha=4, \\beta=+\\infty$)**：访问子节点 $B$。\n10. **$B$ (MIN, $\\alpha=4, \\beta=+\\infty$)**：访问子节点 $B_1$。\n11. **$B_1$ (MAX, $\\alpha=4, \\beta=+\\infty$)**：访问效用值为 $4$ 的叶节点。局部 $\\alpha$ 为 $\\max(4,4)=4$。访问效用值为 $1$ 的叶节点。$\\max(4,1)=4$。$B_1$ 返回值 $4$。\n12. **$B$ (MIN, $\\alpha=4, \\beta=+\\infty$)**：从 $B_1$ 接收到值 $4$。作为一个 MIN 节点，其值现在 $\\le 4$。$B$ 将其 $\\beta$ 更新为 $4$。**剪枝检查**：$\\beta \\le \\alpha$（$4 \\le 4$）为真。**剪掉** $B$ 的剩余子节点（节点 $B_2$ 及其两个叶节点）。$B$ 返回其当前最优值 $4$。\n13. **$R$ (MAX, $\\alpha=4, \\beta=+\\infty$)**：从 $B$ 接收到值 $4$。值为 $\\max(4, 4)=4$。$R$ 没有更多子节点，返回最终值 $4$。\n\n**$E_1$ 总结**：\n- 根节点极小化极大值为 $4$。\n- 被剪枝的叶节点：1 个（在 $A_2$ 下），2 个（在 $B_2$ 下）。总计：$3$ 个叶节点。\n- 主变例 (PV)：$R \\rightarrow A \\rightarrow A_1 \\rightarrow \\text{leaf}(4)$。\n\n### 使用 $E_2$ 排序的 Alpha-Beta 搜索\n\n遍历顺序为：$R \\rightarrow B \\rightarrow B_2 \\rightarrow \\text{叶节点} \\rightarrow B_1 \\rightarrow \\text{叶节点} \\rightarrow A \\rightarrow A_2 \\rightarrow \\text{叶节点} \\rightarrow A_1 \\rightarrow \\text{叶节点}$。\n\n1.  **$R$ (MAX, $\\alpha=-\\infty, \\beta=+\\infty$)**：访问子节点 $B$。\n2.  **$B$ (MIN, $\\alpha=-\\infty, \\beta=+\\infty$)**：访问子节点 $B_2$。\n3.  **$B_2$ (MAX, $\\alpha=-\\infty, \\beta=+\\infty$)**：访问叶节点 $4$。局部 $\\alpha$ 变为 $4$。访问叶节点 $2$。$\\max(4,2)=4$。$B_2$ 返回值 $4$。\n4.  **$B$ (MIN, $\\alpha=-\\infty, \\beta=+\\infty$)**：从 $B_2$ 接收到值 $4$。值 $\\le 4$。$B$ 将其 $\\beta$ 更新为 $4$。边界为 $[\\alpha=-\\infty, \\beta=4]$。\n5.  **$B$ (MIN, $\\alpha=-\\infty, \\beta=4$)**：访问子节点 $B_1$。\n6.  **$B_1$ (MAX, $\\alpha=-\\infty, \\beta=4$)**：访问叶节点 $4$。局部 $\\alpha$ 变为 $4$。**剪枝检查**：$\\alpha \\ge \\beta$（$4 \\ge 4$）为真。**剪掉** 剩余的子叶节点（效用值 $1$）。$B_1$ 返回 $4$。\n7.  **$B$ (MIN, $\\alpha=-\\infty, \\beta=4$)**：从 $B_1$ 接收到值 $4$。值为 $\\min(4,4)=4$。$B$ 返回最终值 $4$。\n8.  **$R$ (MAX, $\\alpha=-\\infty, \\beta=+\\infty$)**：从 $B$ 接收到值 $4$。值 $\\ge 4$。$R$ 将其 $\\alpha$ 更新为 $4$。边界为 $[\\alpha=4, \\beta=+\\infty]$。\n9.  **$R$ (MAX, $\\alpha=4, \\beta=+\\infty$)**：访问子节点 $A$。\n10. **$A$ (MIN, $\\alpha=4, \\beta=+\\infty$)**：访问子节点 $A_2$。\n11. **$A_2$ (MAX, $\\alpha=4, \\beta=+\\infty$)**：访问叶节点 $4$。局部 $\\alpha$ 为 $\\max(4,4)=4$。访问叶节点 $1$。$\\max(4,1)=4$。$A_2$ 返回值 $4$。\n12. **$A$ (MIN, $\\alpha=4, \\beta=+\\infty$)**：从 $A_2$ 接收到值 $4$。值 $\\le 4$。$A$ 将其 $\\beta$ 更新为 $4$。**剪枝检查**：$\\beta \\le \\alpha$（$4 \\le 4$）为真。**剪掉** 剩余的子节点 $A_1$（及其两个叶节点）。$A$ 返回 $4$。\n13. **$R$ (MAX, $\\alpha=4, \\beta=+\\infty$)**：从 $A$ 接收到值 $4$。值为 $\\max(4, 4)=4$。$R$ 返回最终值 $4$。\n\n**$E_2$ 总结**：\n- 根节点极小化极大值为 $4$。\n- 被剪枝的叶节点：1 个（在 $B_1$ 下），2 个（在 $A_1$ 下）。总计：$3$ 个叶节点。\n- 主变例 (PV)：$R \\rightarrow B \\rightarrow B_2 \\rightarrow \\text{leaf}(4)$。\n\n## 选项评估\n\n**A. 在 $E_1$ 和 $E_2$ 两种排序下，根节点的极小化极大值都是 $4$。**\n我们的分析证实了这一点。使用 $E_1$ 的搜索得到根值为 $4$。使用 $E_2$ 的搜索也得到根值为 $4$。这些都与树的真实极小化极大值相匹配。\n结论：**正确**。\n\n**B. 在 $E_1$ 和 $E_2$ 下，主变例不同：在 $E_1$ 下，主变例为 $R \\rightarrow A \\rightarrow A_1 \\rightarrow$ 效用值为 $4$ 的叶节点，而在 $E_2$ 下，主变例为 $R \\rightarrow B \\rightarrow B_2 \\rightarrow$ 效用值为 $4$ 的叶节点。**\n我们对 $E_1$ 的追踪显示，主变例确实是 $R \\rightarrow A \\rightarrow A_1 \\rightarrow \\text{leaf}(4)$。在 $E_1$ 下，$A$ 首先被访问。在 $A$ 处，$A_1$ 首先被访问且值为 $4$。由于 $A$ 的极小化极大值为 $4$，根据平局打破规则，主变例遵循这条最先遇到的路径。\n我们对 $E_2$ 的追踪显示，主变例是 $R \\rightarrow B \\rightarrow B_2 \\rightarrow \\text{leaf}(4)$。在 $E_2$ 下，$B$ 首先被访问。在 $B$ 处，$B_2$ 首先被访问且值为 $4$。由于 $B$ 的极小化极大值为 $4$，主变例遵循这条路径。\n该陈述准确地描述了两个主变例。\n结论：**正确**。\n\n**C. 在 $E_1$ 和 $E_2$ 两种排序下，由于树的左右对称性以及指定的排序和平局打破规则，alpha-beta 剪枝都恰好剪掉了 $3$ 个终端叶节点的评估。**\n我们对 $E_1$ 的追踪显示，$A_2$ 下效用值为 $1$ 的叶节点和 $B_2$ 下的两个叶节点（效用值为 $4$ 和 $2$）被剪枝，总共剪枝了 $3$ 个叶节点。\n我们对 $E_2$ 的追踪显示，$B_1$ 下效用值为 $1$ 的叶节点和 $A_1$ 下的两个叶节点（效用值为 $4$ 和 $2$）被剪枝，总共剪枝了 $3$ 个叶节点。\n关于两种情况下都恰好剪枝 $3$ 个叶节点的陈述是正确的。\n结论：**正确**。\n\n**D. 尽管在 $E_1$ 和 $E_2$ 下剪枝的叶节点数量可能相同，但两次搜索中被剪枝的叶节点的身份完全相同。**\n- $E_1$ 下被剪枝的叶节点：$\\{$ $A_2$ 下的叶节点(1)，$B_2$ 下的叶节点(4)，$B_2$ 下的叶节点(2) $\\}$。\n- $E_2$ 下被剪枝的叶节点：$\\{$ $B_1$ 下的叶节点(1)，$A_1$ 下的叶节点(4)，$A_1$ 下的叶节点(2) $\\}$。\n这两组叶节点完全不同。该陈述是错误的。\n结论：**不正确**。\n\n**E. 在 $E_2$ 下，因为 $B_1$ 包含一个效用值为 $5$ 的叶节点，所以根节点的极小化极大值变为 $5$。**\n该陈述的前提，“因为 $B_1$ 包含一个效用值为 $5$ 的叶节点”，与问题给出的条件“$B_1$ 下的叶节点是 $\\{4, 1\\}$”在事实上不一致。一个基于错误前提的陈述不能被认为是关于所定义问题的真实陈述。此外，即使我们考虑这个假设：如果 $B_1$ 的叶节点是 $\\{5, 1\\}$，其值将变为 $\\max(5,1)=5$。按照 $E_2$ 的搜索顺序：$R$ 探索 $B$；$B$ 探索 $B_2$（值 $4$），将 $B$ 的 $\\beta$ 设置为 $4$。然后 $B$ 探索 $B_1$。$B_1$ 会访问其值为 $5$ 的叶节点，其局部 $\\alpha$ 会变为 $5$，并且由于 $\\alpha=5 \\ge \\beta=4$，它会立即剪掉其另一个叶节点。$B_1$ 会返回 $5$。节点 $B$ 的值将是 $\\min(4, 5)=4$。接着 `R` 会从 $B$ 分支获得值 $4$，将其 $\\alpha$ 设置为 $4$，搜索的其余部分会和之前一样进行，最终得到根值为 $4$，而不是 $5$。所以，前提和结论都是错误的。\n结论：**不正确**。",
            "answer": "$$\\boxed{ABC}$$"
        },
        {
            "introduction": "在掌握了剪枝的基本原理后，让我们从一个更实际的角度来思考优化。这个思想实验将挑战你像算法设计者一样思考，权衡执行一次预检查的固定成本 $c$ 与成功剪枝可能带来的巨大收益。通过这个练习，你将学会运用期望值的概念来做出理性的优化决策，这在设计高性能人工智能系统时至关重要。",
            "id": "3204290",
            "problem": "考虑一个由极大极小过程（minimax procedure）结合Alpha-Beta剪枝进行搜索的确定性、完全信息、双人、零和博弈树。搜索成本以节点扩展的期望数量来衡量。在一个作为极小化节点（Min节点）的特定内部节点上，当前的Alpha-Beta边界表示为 $\\alpha$ 和 $\\beta$，其中 $\\alpha  \\beta$。此时还剩下一个未扩展的子子树。如果该子树通过标准扩展被完全评估（即没有任何额外的预检查），它将产生一个随机的扩展成本 $K$，其有限均值为 $\\mathbb{E}[K] = T  0$。该子树的精确极大极小值（即完全扩展它将返回的值）是一个实值随机变量 $V$，其连续累积分布函数为 $F$；假设 $K$ 和 $V$ 是独立的。\n\n您可以选择运行一个剪枝预检查，该检查会产生一个固定的计算开销成本 $c  0$。如果在对子树进行任何扩展之前执行此预检查，它可以在不扩展子树的情况下检测到条件 $V \\le \\alpha$；如果检测到此条件，则可以在当前的Min节点立即对该子树进行剪枝（因为一个至多为 $\\alpha$ 的值不能增加其极大化祖先节点的最佳保证值）。如果检测到该条件，子树的扩展成本将完全避免。如果未检测到该条件，则必须完全评估该子树，从而产生扩展成本 $K$，并且预检查成本 $c$ 仍然需要支付。\n\n假设决策者的目标是最小化节点扩展的期望数量。请从极大极小和Alpha-Beta剪枝正确性的第一性原理出发，并使用基本的期望值推理，推导出临界成本阈值 $c_{\\star}(\\alpha)$，使得当且仅当 $c  c_{\\star}(\\alpha)$ 时，运行剪枝预检查是理性的（最优的）。将您的最终答案表示为关于 $T$、$F$ 和 $\\alpha$ 的单个闭式解析表达式。不要提供不等式；只提供阈值表达式本身。无需四舍五入。",
            "solution": "问题要求在Alpha-Beta搜索中的一个Min节点处，进行剪枝预检查的临界成本阈值 $c_{\\star}(\\alpha)$。当且仅当运行预检查能够最小化以节点扩展数量衡量的期望总计算成本时，才应做出运行预检查的决定。我们将通过比较两种不同策略的期望成本来确定这个阈值：一种是总是扩展子树，另一种是首先执行预检查。\n\n设 $C_1$ 为与第一种策略（总是扩展）相关的随机成本， $C_2$ 为与第二种策略（使用预检查）相关的随机成本。目标是找到阈值 $c_{\\star}(\\alpha)$，使得当且仅当其固定开销成本 $c$ 小于 $c_{\\star}(\\alpha)$ 时，选择第二种策略是理性的。这等同于找到使两种策略的期望成本相等的 $c$ 值。\n\n策略1：总是扩展子树。\n在此策略下，子树被无条件地评估。根据问题陈述，完全评估的成本是一个随机变量 $K$。因此，此策略的成本是 $C_1 = K$。期望成本 $\\mathbb{E}[C_1]$ 由 $K$ 的均值给出。\n$$\n\\mathbb{E}[C_1] = \\mathbb{E}[K]\n$$\n我们已知 $\\mathbb{E}[K] = T$。\n$$\n\\mathbb{E}[C_1] = T\n$$\n\n策略2：执行剪枝预检查。\n此策略涉及一个固定的初始成本 $c0$。后续成本取决于预检查的结果。预检查确定子树的真实极大极小值 $V$ 是否满足条件 $V \\le \\alpha$。在一个Min节点，如果一个子节点的值小于或等于当前的 $\\alpha$ 边界，则该分支可以被剪枝。\n\n预检查有两种可能的结果：\n1.  条件 $V \\le \\alpha$ 为真。预检查检测到这一点，子树被剪枝。扩展成本 $K$ 被完全避免。产生的总成本仅为预检查开销 $c$。此结果以概率 $P(V \\le \\alpha)$ 发生。由于 $V$ 是一个连续随机变量，其累积分布函数（CDF）为 $F(v) = P(V \\le v)$，这个概率是 $F(\\alpha)$。\n2.  条件 $V \\le \\alpha$ 为假，即 $V  \\alpha$。预检查不会导致剪枝。子树必须被完全评估，产生扩展成本 $K$。在这种情况下，总成本是预检查成本和扩展成本之和，即 $c + K$。此结果以概率 $P(V  \\alpha) = 1 - P(V \\le \\alpha) = 1 - F(\\alpha)$ 发生。\n\n策略2的期望成本 $\\mathbb{E}[C_2]$ 可以使用全期望定律计算，对这两个互斥的结果求和：\n$$\n\\mathbb{E}[C_2] = (\\text{cost if } V \\le \\alpha) \\cdot P(V \\le \\alpha) + (\\text{expected cost if } V  \\alpha) \\cdot P(V  \\alpha)\n$$\n代入成本和概率：\n$$\n\\mathbb{E}[C_2] = (c) \\cdot F(\\alpha) + \\mathbb{E}[c + K | V  \\alpha] \\cdot (1 - F(\\alpha))\n$$\n由于预检查成本 $c$ 是一个常数，$\\mathbb{E}[c + K | V  \\alpha] = c + \\mathbb{E}[K | V  \\alpha]$。根据问题陈述，扩展成本 $K$ 和子树值 $V$ 是独立的随机变量。这种独立性意味着 $K$ 的条件期望等于其无条件期望：$\\mathbb{E}[K | V  \\alpha] = \\mathbb{E}[K] = T$。\n因此，$\\mathbb{E}[C_2]$ 的表达式简化为：\n$$\n\\mathbb{E}[C_2] = c \\cdot F(\\alpha) + (c + T) \\cdot (1 - F(\\alpha))\n$$\n展开并简化各项：\n$$\n\\mathbb{E}[C_2] = c \\cdot F(\\alpha) + c \\cdot (1 - F(\\alpha)) + T \\cdot (1 - F(\\alpha))\n$$\n$$\n\\mathbb{E}[C_2] = c \\cdot F(\\alpha) + c - c \\cdot F(\\alpha) + T \\cdot (1 - F(\\alpha))\n$$\n$$\n\\mathbb{E}[C_2] = c + T \\cdot (1 - F(\\alpha))\n$$\n\n如果预检查的期望成本低于不运行它的期望成本，那么运行预检查就是最优决策：\n$$\n\\mathbb{E}[C_2]  \\mathbb{E}[C_1]\n$$\n$$\nc + T \\cdot (1 - F(\\alpha))  T\n$$\n临界成本阈值 $c_{\\star}(\\alpha)$ 是决策者无差异时的 $c$ 值，意味着期望成本相等：\n$$\nc_{\\star}(\\alpha) + T \\cdot (1 - F(\\alpha)) = T\n$$\n解出 $c_{\\star}(\\alpha)$：\n$$\nc_{\\star}(\\alpha) = T - T \\cdot (1 - F(\\alpha))\n$$\n$$\nc_{\\star}(\\alpha) = T - T + T \\cdot F(\\alpha)\n$$\n$$\nc_{\\star}(\\alpha) = T \\cdot F(\\alpha)\n$$\n因此，当且仅当 $c  c_{\\star}(\\alpha)$ 时，运行预检查是理性的，其中 $c_{\\star}(\\alpha) = T \\cdot F(\\alpha)$。这个结果是直观的：测试的成本 $c$ 应该小于期望的节省量，即可以节省的成本（$T$）与能够节省它的概率（$F(\\alpha)$）的乘积。问题要求的是阈值本身的表达式。",
            "answer": "$$\\boxed{T \\cdot F(\\alpha)}$$"
        },
        {
            "introduction": "现在，让我们将理论和分析付诸实践。在这个最终的动手练习中，你将通过编写代码来实现Alpha-Beta算法，并用它来衡量在最优、基准和最差节点排序策略下的性能差异。这个练习将为理论界限提供具体的实验证据，并生动地展示为何节点排序是影响Alpha-Beta剪枝效率最关键的因素。",
            "id": "3252714",
            "problem": "给定一个由分支因子 $b$ 和搜索深度 $d$ 定义的均匀博弈树。评估函数仅在叶节点上定义，内部节点在最大化层和最小化层之间交替，根节点为最大化层。设子节点索引路径 $(p_0,p_1,\\dots,p_{d-1})$ 的叶节点效用为整数\n$$\nU(p_0,p_1,\\dots,p_{d-1})=\\sum_{i=0}^{d-1} p_i \\cdot b^{\\,d-1-i},\n$$\n即由子节点索引构成的$b$进制数。此构造为每个内部节点的每个子节点导出了不相交且严格有序的效用区间。\n\n基本定义：\n- 深度为 $k$ 的节点的Minimax值是通过在最大化层应用最大化算子、在最小化层应用最小化算子，直至叶节点而获得的值。该值通过递归计算：在深度为 $d$ 的叶节点处，其值等于其效用 $U$；在内部节点处，其值等于子节点值的相应极值。\n- alpha-beta (AB) 剪枝算法维护一个区间 $[\\alpha,\\beta]$，其中 $\\alpha$ 是最大化方可达值的下界，$\\beta$ 是最小化方可达值的上界。剪枝条件为 $\\alpha \\ge \\beta$，此时当前分支无法影响最终决策，因此不再进一步探索。\n\n程序必须：\n1. 通过首先计算每个内部节点所有子节点的精确Minimax值，来构造一个完美排序生成器。在最大化节点处，完美排序按子节点Minimax值的非递增顺序评估子节点；在最小化节点处，则按非递减顺序评估。已知此排序能使alpha-beta剪枝的剪枝次数最大化。\n2. 通过反转每个节点的完美排序来构造一个人工最差情况排序，这将使剪枝次数最小化，并迫使探索尽可能接近整棵树。\n3. 实现alpha-beta剪枝，以测量在三种评估顺序下的已访问节点数：基准（自然子节点索引顺序 $0,1,\\dots,b-1$）、完美排序和人工最差情况排序。\n\n需要验证的理论界限：\n- 整棵树的节点总数 $T(b,d)$ 为\n$$\nT(b,d)=\\sum_{i=0}^{d} b^{\\,i}=\\frac{b^{\\,d+1}-1}{b-1},\n$$\n这是不进行剪枝的Minimax算法所访问的精确节点数。在最差情况排序下，alpha-beta剪枝访问的节点数至少与最小化剪枝所允许的一样多，而在本构造中，它应该恰好访问 $T(b,d)$ 个节点。\n- 在完美排序下，alpha-beta剪枝的复杂度为 $O\\!\\left(b^{\\,d/2}\\right)$。在均匀树的完美排序情况下，一个具体的保守上界是\n$$\nU(b,d)=2 \\cdot \\sum_{i=0}^{\\lceil d/2 \\rceil} b^{\\,i}.\n$$\n您的程序必须验证 $N_{\\text{best}}(b,d) \\le U(b,d)$，其中 $N_{\\text{best}}(b,d)$ 是在完美排序下测得的已访问节点数。\n\n测试套件：\n评估以下参数集 $(b,d)$：\n- $(2,0)$，一个仅有叶节点的边界情况，\n- $(1,5)$，一个每个节点只有一个子节点的退化链，\n- $(2,4)$，一个偶数深度的二叉树，\n- $(3,3)$，一个奇数深度的三叉树，\n- $(4,5)$，一个更高分支因子的树。\n\n对于每个测试用例，生成列表\n$$\n\\big[\\,T(b,d),\\,N_{\\text{worst}}(b,d),\\,N_{\\text{baseline}}(b,d),\\,N_{\\text{best}}(b,d),\\,U(b,d),\\,\\text{cond}_1,\\,\\text{cond}_2,\\,\\text{cond}_3\\,\\big],\n$$\n其中 $\\text{cond}_1$ 是 $N_{\\text{worst}}(b,d)=T(b,d)$ 的布尔结果，$\\text{cond}_2$ 是 $N_{\\text{best}}(b,d) \\le U(b,d)$ 的布尔结果，而 $\\text{cond}_3$ 是 $T(b,d) \\ge N_{\\text{baseline}}(b,d) \\ge N_{\\text{best}}(b,d)$ 的布尔结果。\n\n最终输出格式：\n您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表，其中每个测试用例的结果本身也是一个用方括号括起来、不含空格的逗号分隔列表，例如\n$$\n[\\,[1,1,1,1,2,\\text{True},\\text{True},\\text{True}],\\,[6,6,6,6,8,\\text{True},\\text{True},\\text{True}]\\,].\n$$\n程序不读取任何输入；所有测试用例都嵌入在程序中。不涉及物理单位或角度，所有输出均为整数或布尔值。",
            "solution": "用户提供了一个问题，要求在一个专门构造的均匀博弈树上实现并分析alpha-beta剪枝算法。\n\n### 步骤1：问题验证\n\n我将首先根据指定标准验证问题陈述。\n\n**1. 提取已知条件：**\n- **树结构**：一个分支因子为 $b$、深度为 $d$ 的均匀博弈树。根节点在深度0，是一个最大化（MAX）节点。层级在MAX和MIN节点间交替。叶节点在深度 $d$。\n- **叶节点效用**：通过子节点索引路径 $(p_0, p_1, \\dots, p_{d-1})$ 到达的叶节点的效用由公式 $U(p_0, \\dots, p_{d-1}) = \\sum_{i=0}^{d-1} p_i \\cdot b^{d-1-i}$ 给出。\n- **算法**：Minimax和Alpha-Beta (AB) 剪枝（剪枝条件为 $\\alpha \\ge \\beta$）。\n- **节点排序方案**：\n    - **基准**：自然子节点索引顺序：$(0, 1, \\dots, b-1)$。\n    - **完美**：MAX节点按子节点Minimax值的非递增顺序；MIN节点按非递减顺序。此排序已知可以最大化剪枝。\n    - **最差情况**：每个节点处完美排序的反转。\n- **测量指标**：\n    - $N_{\\text{baseline}}(b,d)$：使用基准排序时访问的节点数。\n    - $N_{\\text{best}}(b,d)$：使用完美排序时访问的节点数。\n    - $N_{\\text{worst}}(b,d)$：使用最差情况排序时访问的节点数。\n- **用于验证的理论界限**：\n    - 整棵树的大小：$T(b,d) = \\sum_{i=0}^{d} b^i = \\frac{b^{d+1}-1}{b-1}$（对于 $b1$）。\n    - 完美排序的上界：$U(b,d) = 2 \\cdot \\sum_{i=0}^{\\lceil d/2 \\rceil} b^i$。\n- **验证条件**：\n    - $\\text{cond}_1: N_{\\text{worst}}(b,d) = T(b,d)$。\n    - $\\text{cond}_2: N_{\\text{best}}(b,d) \\le U(b,d)$。\n    - $\\text{cond}_3: T(b,d) \\ge N_{\\text{baseline}}(b,d) \\ge N_{\\text{best}}(b,d)$。\n- **测试用例**：$(b,d)$ 对：$(2,0), (1,5), (2,4), (3,3), (4,5)$。\n- **输出格式**：列表的列表，例如 $[[T_1, N_{w1}, \\dots], [T_2, N_{w2}, \\dots]]$。\n\n**2. 验证分析：**\n- **科学依据**：该问题在计算机科学中博弈树搜索算法的既定理论中有充分的依据。Minimax、alpha-beta剪枝、完美排序和最差情况排序等概念都是标准的。叶节点效用函数是一种常见的构造，用于创建一个具有有序叶值的测试平台。\n- **良定性**：该问题是良定的。树、效用函数和算法的定义都是确定性的，确保每个测试用例都存在一组唯一、稳定且有意义的节点计数。\n- **客观性**：问题以精确、客观和数学化的语言陈述。\n- **完整性与一致性**：所有必要的参数（$b, d$）、函数和条件都已提供。定义在内部是一致的。验证任务是*检查*给定的条件，而不是证明它们。对于某些测试用例，某个条件可能为假，这将是实验的有效结果，而不是问题本身的失效。例如，提供的 $U(b,d)$ 公式是一个非标准的保守上界，验证其有效性是任务的一部分。\n- **可行性**：测试用例在计算上是可行的。最大的树，对于 $(b,d)=(4,5)$，有 $T(4,5) = 1365$ 个节点，这完全在现代计算机的分析能力范围之内。\n\n**3. 结论：**\n此问题是**有效的**。这是一个在算法领域内清晰、自洽且科学上合理的问题。\n\n### 步骤2：解决方案设计\n\n解决方案将涉及实现alpha-beta搜索算法，并使用三种不同的节点评估顺序运行它。\n\n**1. 确定节点排序：**\n一个关键步骤是确定完美排序和最差情况排序。这需要找到一个节点的子节点的Minimax值的排序。\n让我们分析一个深度为 $k+1$ 的子节点的Minimax值，该子节点通过路径 $(p_0, \\dots, p_k)$ 到达。其值由其下方子树的Minimax评估确定。此子树中的叶节点效用由下式给出：\n$$U(p_0, \\dots, p_{d-1}) = \\sum_{i=0}^{k} p_i b^{d-1-i} + \\sum_{i=k+1}^{d-1} p_i b^{d-1-i}$$\n该子树的Minimax值 $V(p_0, \\dots, p_k)$ 可以表示为：\n$$V(p_0, \\dots, p_k) = \\left( \\sum_{i=0}^{k-1} p_i b^{d-1-i} + p_k b^{d-k-1} \\right) + C_{k+1,d}$$\n其中 $C_{k+1,d}$ 是一个常数，它取决于剩余层级的Minimax选择，但与 $p_k$ 无关。由于 $p_k$ 的系数 $b^{d-k-1}$ 为正，子节点的Minimax值是其索引 $p_k$ 的严格递增函数。\n\n这个洞见使我们能够无需显式计算Minimax值即可定义排序：\n- **MAX节点（偶数深度 $k$）**：为了最大化结果，完美排序按其值的降序探索子节点，这对应于其索引的降序：$(b-1, b-2, \\dots, 0)$。最差情况则相反：$(0, 1, \\dots, b-1)$。\n- **MIN节点（奇数深度 $k$）**：为了最小化结果，完美排序按其值的升序探索子节点，即索引的升序：$(0, 1, \\dots, b-1)$。最差情况则相反：$(b-1, b-2, \\dots, 0)$。\n**基准**排序始终是 $(0, 1, \\dots, b-1)$。\n\n**2. Alpha-Beta实现：**\n一个递归函数 `alpha_beta_recursive` 将遍历概念上的博弈树。它将当前路径、alpha-beta边界和树参数作为参数。将使用一个全局计数器来跟踪每次运行所访问的节点数。\n- 递归在深度为 $d$ 时终止，此时它评估叶节点效用。\n- 在每个内部节点，它根据指定的排序（'perfect'、'worst'或'baseline'）迭代子节点。\n- 它更新alpha或beta值，并在满足条件 $\\alpha \\ge \\beta$ 时进行剪枝。\n- 节点的路径将作为索引列表传递，用于计算叶节点的效用。为优化效用计算，将预先计算 $b$ 的幂（$b^{d-1}, b^{d-2}, \\dots, b^0$）。\n\n**3. 主逻辑：**\n主函数将遍历测试套件。对于每个 $(b,d)$ 对：\n1. 计算理论值 $T(b,d)$ 和 $U(b,d)$，处理 $b=1$ 的边缘情况。\n2. 调用alpha-beta搜索函数三次，每种排序方案（`worst`、`baseline`、`perfect`）一次，以获得 $N_{\\text{worst}}$、$N_{\\text{baseline}}$ 和 $N_{\\text{best}}$。\n3. 评估三个布尔条件（$\\text{cond}_1$、$\\text{cond}_2$、$\\text{cond}_3$）。\n4. 将结果组合成一个列表，并为最终输出进行格式化。\n\n此设计系统地解决了问题陈述的所有要求。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\n# A mutable object to hold the visited nodes counter.\n# This avoids using 'global' keyword inside the recursive function directly,\n# making the data flow slightly more explicit.\n_visited_nodes_counter = [0]\n\ndef _calculate_utility(path, powers):\n    \"\"\"\n    Calculates the leaf utility value using pre-calculated powers of b.\n    The path must have length d, same as the length of powers vector.\n    \"\"\"\n    if not path:\n        return 0\n    return np.dot(path, powers)\n\ndef _alpha_beta_recursive(path, alpha, beta, b, d, orderings, powers):\n    \"\"\"\n    Recursive core of the alpha-beta search algorithm.\n    It returns the minimax value of the node defined by 'path'.\n    The number of visited nodes is updated via the counter.\n    \"\"\"\n    _visited_nodes_counter[0] += 1\n    depth = len(path)\n\n    if depth == d:\n        return _calculate_utility(path, powers)\n\n    is_max_node = (depth % 2 == 0)\n    order = orderings[depth]\n\n    if is_max_node:\n        value = -np.inf\n        for child_idx in order:\n            child_path = path + [child_idx]\n            child_value = _alpha_beta_recursive(child_path, alpha, beta, b, d, orderings, powers)\n            value = max(value, child_value)\n            alpha = max(alpha, value)\n            if alpha = beta:\n                break\n        return value\n    else:  # MIN node\n        value = np.inf\n        for child_idx in order:\n            child_path = path + [child_idx]\n            child_value = _alpha_beta_recursive(child_path, alpha, beta, b, d, orderings, powers)\n            value = min(value, child_value)\n            beta = min(beta, value)\n            if alpha = beta:\n                break\n        return value\n\ndef _get_orderings(b, d, order_type):\n    \"\"\"\n    Determines the child evaluation order for each depth based on the ordering type.\n    \"\"\"\n    orderings = []\n    natural_order = list(range(b))\n    reverse_order = list(range(b - 1, -1, -1))\n    \n    for depth in range(d):\n        is_max_node = (depth % 2 == 0)\n        if order_type == 'baseline':\n            orderings.append(natural_order)\n        elif order_type == 'perfect':\n            orderings.append(reverse_order if is_max_node else natural_order)\n        elif order_type == 'worst':\n            orderings.append(natural_order if is_max_node else reverse_order)\n    return orderings\n\ndef run_ab_search(b, d, order_type):\n    \"\"\"\n    Sets up and runs an alpha-beta search, returning the number of nodes visited.\n    \"\"\"\n    _visited_nodes_counter[0] = 0\n    \n    # A single node tree (root is a leaf)\n    if d == 0:\n        return 1\n\n    orderings = _get_orderings(b, d, order_type)\n    # Pre-calculate powers of b for efficient utility calculation\n    powers = np.array([b**(d - 1 - i) for i in range(d)], dtype=np.int64)\n\n    _alpha_beta_recursive([], -np.inf, np.inf, b, d, orderings, powers)\n    \n    return _visited_nodes_counter[0]\n\ndef solve_case(b, d):\n    \"\"\"\n    Solves a single test case for parameters (b, d) and returns the formatted result list.\n    \"\"\"\n    # Handle d=0 edge case\n    if d == 0:\n        T_bd, N_worst, N_baseline, N_best = 1, 1, 1, 1\n        U_bd = 2  # U(b,0) = 2 * b^0 = 2\n    # Handle b=1 edge case\n    elif b == 1:\n        T_bd, N_worst, N_baseline, N_best = d + 1, d + 1, d + 1, d + 1\n        ceil_d_2 = math.ceil(d / 2)\n        U_bd = 2 * (ceil_d_2 + 1)\n    # General case\n    else:\n        T_bd = (b**(d + 1) - 1) // (b - 1)\n        \n        ceil_d_2 = math.ceil(d / 2)\n        u_bd_sum_term = (b**(ceil_d_2 + 1) - 1) // (b - 1)\n        U_bd = 2 * u_bd_sum_term\n        \n        N_worst = run_ab_search(b, d, 'worst')\n        N_baseline = run_ab_search(b, d, 'baseline')\n        N_best = run_ab_search(b, d, 'perfect')\n    \n    cond1 = (N_worst == T_bd)\n    cond2 = (N_best = U_bd)\n    cond3 = (T_bd = N_baseline and N_baseline = N_best)\n    \n    return [int(T_bd), int(N_worst), int(N_baseline), int(N_best), int(U_bd), cond1, cond2, cond3]\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final output.\n    \"\"\"\n    test_cases = [\n        (2, 0),\n        (1, 5),\n        (2, 4),\n        (3, 3),\n        (4, 5),\n    ]\n\n    all_results_str = []\n    for b, d in test_cases:\n        case_result = solve_case(b, d)\n        str_case_result = f\"[{','.join(map(str, case_result))}]\"\n        all_results_str.append(str_case_result)\n\n    final_output = f\"[{','.join(all_results_str)}]\"\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}