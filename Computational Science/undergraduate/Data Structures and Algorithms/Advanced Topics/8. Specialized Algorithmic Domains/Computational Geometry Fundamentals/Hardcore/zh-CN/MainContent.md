## 引言
计算几何是一门研究如何为几何问题设计高效算法的学科，它在处理和理解日益增多的空间数据方面扮演着核心角色。从物理世界的[机器人导航](@entry_id:263774)到虚拟世界的图形渲染，再到抽象数据空间的[模式识别](@entry_id:140015)，我们都需要将几何直觉转化为计算机可以执行的精确指令。然而，这一转化过程并非一帆风顺，它面临着理论的优雅性与有限精度计算的现实性之间的矛盾，这构成了本领域的核心挑战与知识鸿沟。

本文旨在系统地引导读者跨越这一鸿沟，全面掌握计算几何的基础。我们将通过三个章节的旅程，从理论根基走向实际应用。在**第一章“原理与机制”**中，我们将深入探讨构成所有[几何算法](@entry_id:175693)基石的基本谓词、核心数据结构（如[凸包](@entry_id:262864)和Voronoi图）以及确保算法正确性的鲁棒性计算策略。接着，在**第二章“应用与交叉学科联系”**中，我们将展示这些理论如何在机器人学、[计算机图形学](@entry_id:148077)、机器学习等多个前沿领域中转化为强大的解决方案。最后，在**第三章“动手实践”**中，你将通过解决具体的编程问题，将所学知识付诸实践。

让我们从计算几何最根本的组成部分——那些定义几何关系并驱动算法决策的基本原理——开始我们的探索。

## 原理与机制

计算几何的核心在于将几何问题转化为离散的、可计算的结构。这一转化的成功依赖于一套强大的基本原理和机制。本章将深入探讨这些构成了几乎所有高级计算[几何算法](@entry_id:175693)基础的核心概念。我们将从定义几何关系的基本谓词出发，讨论在有限精度计算机上实现这些谓词的鲁棒性挑战，然后介绍诸如凸包、Voronoi图和Delaunay[三角剖分](@entry_id:272253)等基本几何结构。最后，我们将展示如何应用这些结构和原理来解决更复杂的问题，并介绍[对偶变换](@entry_id:137576)这一强大的理论工具。

### 基本几何谓词：[几何算法](@entry_id:175693)的[原子操作](@entry_id:746564)

[几何算法](@entry_id:175693)的决策过程通常归结为一系列基本的几何测试，称为**谓词（predicates）**。这些谓词如同算术中的比较运算符，是构建更复杂逻辑的基础。两个最核心的谓词是方向测试和内圆测试。

#### 方向谓词

最基本的几何问题之一是确定三个有序点$P_1, P_2, P_3$的相对方位。它们是构成了一个“左转”（逆时针方向），一个“右转”（顺时针方向），还是三点共线？这个问题的答案由**方向谓词（orientation predicate）**提供。

在二维平面上，给定点 $P_1=(x_1, y_1)$, $P_2=(x_2, y_2)$, 和 $P_3=(x_3, y_3)$，方向可以通过一个$3 \times 3$[行列式](@entry_id:142978)的符号来确定：

$$
\operatorname{orient}(P_1, P_2, P_3) = \operatorname{sign} \left( \det \begin{pmatrix} x_1 & y_1 & 1 \\ x_2 & y_2 & 1 \\ x_3 & y_3 & 1 \end{pmatrix} \right)
$$

通过对第一列进行[拉普拉斯展开](@entry_id:148225)，这个[行列式](@entry_id:142978)可以更直观地写成一个代数表达式，它等于以$P_1P_2$和$P_1P_3$为边的平行四边形的有符号面积：

$$
\Delta(P_1, P_2, P_3) = (x_2 - x_1)(y_3 - y_1) - (y_2 - y_1)(x_3 - x_1)
$$

该表达式的符号揭示了点$(P_1, P_2, P_3)$的几何关系 ``：
-   $\Delta > 0$: 点列构成一个**逆时针（counter-clockwise, CCW）**转角，或称“左转”。
-   $\Delta < 0$: 点列构成一个**顺时针（clockwise, CW）**转角，或称“右转”。
-   $\Delta = 0$: 三个点**共线（collinear）**。

方向谓词是许多算法的基石，例如，在构造凸包时，我们需要反复检查一个新点是否在当前船体链的“左侧”。

这一概念可以自然地推广到三维空间 ``。在三维中，我们考虑四个有序点$(P_0, P_1, P_2, P_3)$的方位。这四个点定义了一个四面体。其方位（“[右手系](@entry_id:166669)”或“左手系”）取决于从公共顶点（例如$P_0$）出发的三个有序向量 $\vec{v}_1 = P_1 - P_0$, $\vec{v}_2 = P_2 - P_0$, $\vec{v}_3 = P_3 - P_0$ 所构成的基的定向。

这个定向由这三个向量的**标量三重积（scalar triple product）** $(\vec{v}_1 \times \vec{v}_2) \cdot \vec{v}_3$ 的符号决定，该值等于由这三个[向量张成](@entry_id:152883)的平行六面体的[有符号体积](@entry_id:149928)。标量三重积又等价于以这些向量为列（或行）的矩阵的行列式。因此，[三维方向](@entry_id:164813)谓词可以定义为：

$$
\operatorname{orient}(P_0, P_1, P_2, P_3) = \operatorname{sign} \left( \det \begin{pmatrix} P_1-P_0 & P_2-P_0 & P_3-P_0 \end{pmatrix} \right)
$$

其中$P_i-P_0$是列向量。[行列式](@entry_id:142978)的符号决定了四面体的定向：正值对应[右手系](@entry_id:166669)，负值对应左手系，零值则表示四个点共面（退化四面体）。这种基于向量差的定义确保了谓词具有[平移不变性](@entry_id:195885)。

#### 内圆谓词

另一个关键谓词是**内圆谓词（in-circle predicate）**，它用于确定一个点$P_4$是位于由另外三个点$P_1, P_2, P_3$所定义的圆的内部、外部还是边界上。这个谓词是构建Delaunay三角剖分等结构的核心。

假设$P_1, P_2, P_3$构成逆时针方向，内圆谓词$\operatorname{incircle}(P_1, P_2, P_3; P_4)$的符号可以通过计算以下$4 \times 4$[行列式](@entry_id:142978)得到 ``：

$$
\operatorname{incircle}(P_1, P_2, P_3; P_4) = \operatorname{sign} \left( \det \begin{pmatrix} x_1 & y_1 & x_1^2 + y_1^2 & 1 \\ x_2 & y_2 & x_2^2 + y_2^2 & 1 \\ x_3 & y_3 & x_3^2 + y_3^2 & 1 \\ x_4 & y_4 & x_4^2 + y_4^2 & 1 \end{pmatrix} \right)
$$

这个[行列式](@entry_id:142978)的符号具有明确的几何意义：
-   结果 > 0: 点$P_4$位于圆的**内部**。
-   结果 < 0: 点$P_4$位于圆的**外部**。
-   结果 = 0: 四个点**共圆（cocircular）**。

这个谓词可以通过一个称为“提升（lifting）”的技巧来理解：将每个二维点$P=(x,y)$映射到三维抛物面$z=x^2+y^2$上。这样，四个二维点共圆的条件就等价于它们在三维空间中对应的点共面。上述[行列式](@entry_id:142978)正是用于测试这四个三维提升点是否共面的体积谓词。

### 鲁棒性的挑战：从理论到实践

理论上，几何谓词的定义清晰明了。然而，在实际的计算机实现中，使用标准浮点数（如[IEEE 754](@entry_id:138908)[双精度](@entry_id:636927)）进行计算会引入[舍入误差](@entry_id:162651)，从而在处理**退化情况（degenerate cases）**或**近退化情况（near-degenerate cases）**时导致灾难性的后果。当点几乎共[线或](@entry_id:170208)几乎共圆时，谓词[行列式](@entry_id:142978)的真实值非常接近于零，浮点计算的微小误差就可能导致符号判断错误，进而使整个算法失败。

#### 对抗性输入与计算失效

我们可以构造一些“对抗性”的输入来揭示浮点计算的脆弱性 ``。例如，考虑一系列几乎共线的点，其坐标被微小的扰动$\delta$偏离一条直线。一个典型的例子是点集 $P_i = (iL, iL + (-1)^i \delta)$。当$\delta$非常小时，方向谓词 $\operatorname{orient}(P_i, P_{i+1}, P_{i+2})$ 的精确值为 $4L(-1)^i\delta$，其符号取决于$i$的奇偶性。

然而，[浮点](@entry_id:749453)计算可能会在以下几种情况中失效：
-   **[下溢](@entry_id:635171)（Underflow）**：如果$\delta$的值（例如$10^{-350}$）小于浮点数能表示的最小正数，它将被舍入为零。计算出的[行列式](@entry_id:142978)也将为零，从而错误地报告点是共线的。
-   **吸收（Absorption）**：如果坐标值$L$非常大（例如$10^{154}$），而$\delta$相对很小（例如$10^{-154}$），在计算$iL + (-1)^i\delta$时，$\delta$项可能会因为远小于$iL$而被“吸收”，即计算结果等于$iL$。这同样会导致计算出的[行列式](@entry_id:142978)为零。
-   **灾难性抵消（Catastrophic Cancellation）**：当两个几乎相等的数相减时，会损失大量[有效数字](@entry_id:144089)。[行列式](@entry_id:142978)计算$(x_2-x_1)(y_3-y_1) - (y_2-y_1)(x_3-x_1)$的核心正是一次减法，如果两个乘积项非常接近，结果的精度会严重受损。

#### 策略一：使用误差边界的自适应精度

应对鲁棒性问题的一种强大策略是**自适应精度计算（adaptive precision arithmetic）**。其思想是：首先使用快速的[浮点运算](@entry_id:749454)计算谓词值，同时估算一个严格的**误差边界（error bound）** $\tau$，这个边界保证了计算结果与真实值之差的[绝对值](@entry_id:147688)不超过$\tau$。

如果计算出的[浮点](@entry_id:749453)值$\hat{\Delta}$的[绝对值](@entry_id:147688)$|\hat{\Delta}|$大于误差边界$\tau$，即$|\hat{\Delta}| > \tau$，那么$\hat{\Delta}$的符号必然与真实值$\Delta$的符号一致，我们可以安全地返回$\operatorname{sign}(\hat{\Delta})$。如果$|\hat{\Delta}| \le \tau$，则结果不可靠。此时，算法**回退（fall back）**到一种更慢但精确的算术方法，例如使用支持任意精度的有理数库，来得到确切的符号 ``。

这种[混合方法](@entry_id:163463)兼顾了效率和正确性：对于非退化情况，它和标准浮点计算一样快；仅在必要时才调用昂贵的精确计算。

#### 策略二：符号扰动

另一种处理退化情况的优雅方法是**符号扰动（symbolic perturbation）**，也称为**“模拟简单性”（Simulation of Simplicity, SoS）** ``。其核心思想是，在概念上对每个输入点的位置进行一个无穷小的、符号化的扰动，使得扰动后的点集处于**一般位置（general position）**，即不存在任何三点共线或四点共圆等退化情况。

这种扰动无需真正计算，而是通过为谓词定义一套确定性的**决胜规则（tie-breaking rules）**来模拟。这些规则通常基于点的唯一标签或索引。例如，对于方向谓词：
-   如果[行列式](@entry_id:142978)非零，则返回其符号。
-   如果[行列式](@entry_id:142978)为零（三点$a, b, c$共线），则根据它们的标签（例如，按标签排序为$i  j  k$）来打破僵局。可以规定，如果输入顺序$(a,b,c)$是排序后顺序$(i,j,k)$的偶[排列](@entry_id:136432)，则返回$+1$，否则返回$-1$。

类似地，对于内圆谓词的共圆情况，也可以定义一个依赖于点标签和低维谓词（如方向谓词）的决胜规则。SoS的关键在于，所有谓词的决胜规则必须相互一致，以保证算法的全局正确性。这种方法将所有退化情况系统地、一致地归约为非退化情况，从而简化了[算法设计](@entry_id:634229)。

### 核心几何结构

基于可靠的几何谓词，我们可以构建一些在计算几何中无处不在的核心结构。

#### 凸包

给定平面上的一个点集$S$，其**凸包（convex hull）** $\mathrm{CH}(S)$ 是包含$S$中所有点的最小[凸多边形](@entry_id:165008)。直观地说，它就像一个橡皮筋紧紧包住所给点集后形成的形状。

计算[凸包](@entry_id:262864)的经典算法之一是**Andrew[单调链算法](@entry_id:637563)（Andrew's monotone chain algorithm）** ``。该算法利用方向谓词，分两步高效地构造[凸包](@entry_id:262864)：
1.  **排序**：首先，将所有点按[字典序](@entry_id:143032)（先按$x$坐标，再按$y$坐标）排序。这需要$O(n \log n)$时间。
2.  **构建上下包**：
    -   **下包（Lower Hull）**：从字典序最小的点开始，按顺序遍历所有点。维护一个栈，表示当前的下包链。对于每个新点，检查它与栈顶的两个点是否构成一个“左转”。如果不是（即构成右转或共线），则说明栈顶的点是凹的，需要将其弹出。重复此过程，直到新点与栈顶两点构成左转，然后将新点压入栈中。
    -   **上包（Upper Hull）**：从字典序最大的点开始，按逆序遍历所有点，重复类似的过程来构建上包。
3.  **合并**：将上包和下包（除去重复的端点）合并，即可得到完整的[凸包](@entry_id:262864)顶点序列。

由于排序是算法的瓶颈，Andrew算法的总[时间复杂度](@entry_id:145062)为$O(n \log n)$。另外，**随机增量算法（randomized incremental algorithm）**也是一种重要的构造思想，它通过随机打乱输入点并逐个插入来维护凸包，其[期望时间复杂度](@entry_id:634638)同样为$O(n \log n)$ ``。

#### Voronoi图与Delaunay三角剖分

**Voronoi图（Voronoi diagram）**是平面划分的又一种基本形式。给定一组“站点”（sites），Voronoi图将平面划分为多个区域，每个区域（称为**Voronoi单元**）包含了所有离其对应站点比离任何其他站点都近的点。

这个概念在许多领域都有直接应用。例如，在城市规划中，我们可以将城市视为站点，那么每个城市的**市场区域（market region）**就是其Voronoi单元与国家边界多边形的交集 ``。
-   **半平面约束**：两个站点$s_i$和$s_j$之间的边界，是所有与它们等距的点的集合，即线段$s_i s_j$的**[垂直平分线](@entry_id:163148)**。这个平分线将平面分为两个半平面，其中一个半平面内的点离$s_i$更近，另一个则离$s_j$更近。
-   **单元的构造**：因此，站点$s_i$的Voronoi单元是所有以$s_i$为优势的半平面的交集，这是一个[凸多边形](@entry_id:165008)。通过对国家多边形进行迭代的**多边形裁剪（polygon clipping）**，可以精确地计算出每个市场区域的形状和面积。

与Voronoi图紧密相关且在计算几何中更为核心的结构是**Delaunay三角剖分（Delaunay triangulation）**。对于同一组站点，如果两个站点的Voronoi单元共享一条边，就在这两个站点之间连接一条边，由此形成的图就是Delaunay[三角剖分](@entry_id:272253)。
-   **[空圆性质](@entry_id:174456)**：Delaunay三角剖分的一个等价且至关重要的定义是**[空圆性质](@entry_id:174456)（empty circle property）**。一个三角剖分是Delaunay三角剖分，当且仅当其任何一个三角形的[外接圆](@entry_id:165300)内部都不包含点集中的任何其他点 ``。内圆谓词正是验证此性质的直接工具。

### 关键算法与应用

基于上述原理和结构，我们可以设计出解决各种复杂几何问题的有效算法。

#### 欧几里得[最小生成树](@entry_id:264423)

给定$n$个点，**欧几里得[最小生成树](@entry_id:264423)（Euclidean Minimum Spanning Tree, EMST）**是在这些点构成的完全图上，以欧几里得距离为权重，总权重最小的[生成树](@entry_id:261279)。

一个朴素的方法需要考虑所有$O(n^2)$条可能的边，导致至少$O(n^2 \log n)$的复杂度。然而，一个深刻的几何结论极大地简化了这个问题：**EMST是Delaunay[三角剖分](@entry_id:272253)的[子图](@entry_id:273342)** ``。

这个结论的证明非常优美，它依赖于图论中的**环性质（cycle property）**——任何环中最长的边都不可能属于最小生成树。证明链条如下：
1.  **EMST ⊆ Gabriel图 (GG)**：如果一条边$(u,v)$不属于GG，意味着以$uv$为直径的圆内存在另一个点$w$。此时，在$\triangle uvw$中，$uv$是最长边。根据环性质，$(u,v)$不属于EMST。因此，所有EMST的边都必须属于GG。
2.  **Gabriel图 ⊆ Delaunay三角剖分 (DT)**：如果一条边$(u,v)$属于GG，则以$uv$为直径的圆是空的。这个空圆自身就满足了Delaunay[三角剖分](@entry_id:272253)的[空圆性质](@entry_id:174456)，因此$(u,v)$必然是DT的一条边。

综上，我们得到EMST ⊆ DT。由于DT是一个[平面图](@entry_id:269787)，它只有$O(n)$条边。因此，计算EMST的高效算法是：
1.  计算点集的Delaunay[三角剖分](@entry_id:272253)（耗时$O(n \log n)$）。
2.  在DT的$O(n)$条边上运行标准的[最小生成树算法](@entry_id:636375)（如Kruskal或Prim），耗时$O(n \log n)$。

最终总时间复杂度为$O(n \log n)$，远优于朴素算法。

#### 艺术画廊问题

**艺术画廊问题（Art Gallery Problem）**探讨了用最少数量的守卫覆盖一个简单多边形画廊的问题。一个里程碑式的结论是：对于一个有$n$个顶点的简单多边形，$\lfloor n/3 \rfloor$个顶点守卫总是**足够**的 ``。

这个结论的[构造性证明](@entry_id:157587)巧妙地将几何问题转化为了[图论](@entry_id:140799)问题：
1.  **三角剖分**：首先，将多边形剖分成$n-2$个三角形。这可以通过**“切耳法”（ear clipping）**等算法在[多项式时间](@entry_id:263297)内完成。由于三角形是凸的，放置在任一顶点的守卫都能看守整个三角形。
2.  **三染色**：接下来，对多边形的顶点进行**三染色**，使得每个三角形的三个顶点颜色都不同。这一步总是可以实现的，因为[三角剖分](@entry_id:272253)的**对偶图**（每个节点代表一个三角形，共享边的三角形之间有边相连）是一个树。我们可以从任意一个三角形开始，为其顶点分配三种颜色，然后通过[图遍历](@entry_id:267264)（如BFS或DFS）将颜色传播到相邻的三角形，而不会产生冲突。
3.  **选择守卫**：三染色将$n$个顶点分成了三个颜色类 $C_1, C_2, C_3$。根据**[鸽巢原理](@entry_id:268698)**，其中必有一个颜色类的顶点数不多于$\lfloor n/3 \rfloor$。我们选择这个最小的颜色类作为守卫集合。
4.  **覆盖保证**：由于每个三角形的三个顶点颜色各不相同，它必然包含来自每个颜色类的一个顶点。因此，我们选择的守卫集合在每个三角形中都至少有一个代表。这意味着每个三角形都被覆盖，从而整个多边形都被覆盖。

#### 点在多面体内的包含测试

这是一个基本的点定位问题。对于一个给定的三维[多面体](@entry_id:637910)（不必是凸的），如何判断一个查询点是在其内部、外部还是边界上？一个通用且强大的方法是**射线投射算法（ray-casting algorithm）** ``。

该算法的原理基于拓扑学中的思想：
1.  从查询点$P$向任意一个固定的方向（例如$+x$方向）发射一条射线。
2.  计算这条射线与多面体边界的[交点数](@entry_id:161199)量。
3.  应用**奇偶规则（parity rule）**：如果[交点数](@entry_id:161199)量为奇数，则点$P$在[多面体](@entry_id:637910)内部；如果为偶数（包括0），则点$P$在外部。

实现此算法需要解决几个关键的子问题：
-   **边界表示**：通常将[多面体](@entry_id:637910)边界表示为一个**[三角网格](@entry_id:756169)（triangle mesh）**。
-   **射线-三角形相交测试**：这是算法的核心。高效的算法如**Möller–Trumbore算法**利用[重心坐标](@entry_id:155488)直接求解射[线与](@entry_id:177118)三角形的交点，而无需预先计算[平面方程](@entry_id:152977)。
-   **鲁棒性**：当射线擦过多面体的边或顶点时，可能会与多个三角形相交于同一点，导致计数错误。必须小心处理这些退化情况，例如，只计算射[线与](@entry_id:177118)三角形**严格内部**的交点，并对距离非常近的交点进行去重。

#### 基于轨迹的[几何优化](@entry_id:151817)

许多[几何优化](@entry_id:151817)问题可以通过将无限的搜索空间缩减为一组有限的“临界”候选点来解决。一个很好的例子是寻找最大重叠圆盘覆盖问题 ``。

给定一组圆盘，我们要找到平面上被最多数量的圆盘覆盖的点。定义覆盖函数$k(P)$为包含点$P$的圆盘数量。这个函数是一个[阶梯函数](@entry_id:159192)，其值只在点$P$穿过某个圆盘边界时才会改变。因此，函数$k(P)$的最大值必然出现在由圆弧界定的某个区域内。

这一观察的关键推论是：取得最大覆盖值的点，要么是某个圆盘的**圆心**，要么是某两个圆盘边界的**交点**。这样，一个在整个二维平面上的连续[优化问题](@entry_id:266749)，就被转化为了在一个离散且有限的候选点集上进行评估的组合问题。算法步骤如下：
1.  生成候选点集，包括所有圆心和所有圆盘两两之间的交点。
2.  遍历每个候选点，计算其覆盖数$k(P)$。
3.  返回所有候选点中最大的覆盖数。

### 对偶的力量

最后，**对偶（duality）**是一种深刻的变换思想，它在点的几何与线的几何之间建立了一座桥梁。一个标准的点-线[对偶变换](@entry_id:137576) `` 可能将平面上的一个点$P=(a,b)$映射到一条线$L^*: y=ax-b$，同时将一条线$L: y=mx+c$映射到一个点$P^*=(m,-c)$。

这种变换最神奇的特性是它**保持[关联关系](@entry_id:158296)（incidence preservation）**：
 点$P$在线$L$上，当且仅当对偶点$P^*$在对偶线$L^*$上。

我们可以通过简单的代数来验证这一点：
-   $P$在$L$上意味着 $b = ma+c$。
-   $P^*$在$L^*$上意味着 $-c = a(m)-b$。

这两个方程是等价的。这种关联保持性带来了深刻的几何推论：
-   一组**共线**的点被变换为一组**共点**（交于一点）的线。
-   一组**共点**的线被变换为一组**共线**的点。

[对偶变换](@entry_id:137576)是一个强大的理论工具，它允许我们将一个几何问题转化为一个等价的对偶问题，而后者可能更容易分析或解决。例如，寻找一组线的上包络线（upper envelope）问题，可以通过[对偶变换](@entry_id:137576)转化为寻找一组点的凸包下半部分的问题。

通过掌握这些基本原理、核心结构和算法机制，我们便拥有了分析、设计和实现复杂[几何算法](@entry_id:175693)的坚实基础。