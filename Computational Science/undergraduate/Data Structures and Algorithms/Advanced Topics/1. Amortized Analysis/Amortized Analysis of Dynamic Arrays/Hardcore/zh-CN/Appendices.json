{
    "hands_on_practices": [
        {
            "introduction": "我们经常讨论“平均”成本，但那个“最不幸”的元素的经历是怎样的呢？这个练习将我们的视角从总成本转移到单个元素的体验上——即第一个被添加到数组中的元素。通过追踪这个元素被复制了多少次，我们可以从根本上理解为什么容量倍增策略如此高效，并领悟到重置大小过程的对数特性。这为动态数组的行为提供了一个具体、以元素为中心的视角。",
            "id": "3206830",
            "problem": "考虑一个初始容量为 $1$ 且为空的动态数组。该数组支持一个追加操作，当有未使用的容量时，该操作以常数时间在末尾放置一个新元素。当追加操作发现数组已满时，数组会执行一次调整大小（resize）操作：它分配一个新的连续内存块，其容量恰好是当前容量的两倍，然后按顺序将所有当前元素从旧块复制到新块，之后再追加新元素。假设没有删除操作发生。定义元素的“复制”为在调整大小期间该元素的移动（元素在追加时的初始放置不计为复制）。\n\n在执行了恰好 $N \\ge 1$ 次追加操作后，请确定在此 $N$ 次追加序列中，任何单个元素因调整大小而被复制的最大可能次数，并以关于 $N$ 的封闭形式表达式给出。请提供精确表达式作为答案；不需要数值近似或四舍五入。",
            "solution": "用户希望我解决一个关于动态数组的问题。\n\n### 步骤 1：提取已知条件\n- 初始数组容量：$1$。\n- 初始数组大小：$0$。\n- 追加操作：在末尾放置一个新元素。\n- 调整大小条件：当试图向一个已满的数组追加元素时发生。\n- 调整大小机制：\n    1. 新分配的容量为当前容量的 $2 \\times$。\n    2. 所有现有元素被复制到新块中。\n    3. 然后追加新元素。\n- “复制”的定义：元素在调整大小期间的移动。元素的初始插入不算是复制。\n- 总操作数：执行了恰好 $N$ 次追加操作，其中 $N \\ge 1$。\n- 目标：确定任何单个元素被复制的最大可能次数。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据**：该问题是算法分析中的一个标准练习，特别是关于动态数组（也称为向量或 ArrayList）的摊销分析。所描述的模型（调整大小时容量加倍）是一种经典的实现策略。该问题在科学上和数学上都是合理的。\n- **适定性**：该问题是适定的。初始条件、操作规则以及待求量都已精确指定。存在唯一的、确定性的解。\n- **客观性**：问题陈述是客观的，并使用了正式、无歧义的语言。\n\n### 步骤 3：结论与行动\n该问题是**有效的**。它是计算机科学领域中关于数据结构和算法的一个明确定义的问题。我现在将进行正式求解。\n\n### 解题推导\n问题要求在 $N$ 次追加操作序列后，任何单个元素被复制的最大次数。为了最大化一个元素的复制次数，我们应该考虑在数组中存在时间最长的元素，因为它将经历其插入后发生的每一次调整大小操作。第一个被追加的元素，我们称之为 $E_1$，满足这个条件。因此，任何元素的最大复制次数就是 $E_1$ 被复制的次数。\n\n我们来分析动态数组的状态，特别是它的容量。容量，我们用 $C$ 表示，仅在调整大小操作期间发生变化。根据问题陈述，初始容量为 $C_0 = 1$。调整大小操作会使容量加倍。因此，数组可能具有的容量序列是 $2$ 的幂：$1, 2, 4, 8, \\dots, 2^k$，其中 $k$ 为非负整数。容量为 $C=2^k$ 的数组最多可以容纳 $2^k$ 个元素。\n\n当试图向一个已满的数组追加元素时，会触发调整大小。也就是说，如果数组的容量为 $C$ 并且已经包含 $C$ 个元素，下一次追加将导致调整大小。\n\n我们来追踪这个过程：\n1.  **初始状态**：容量 $C=1$，大小 $S=0$。\n2.  **第 1 次追加**：我们追加元素 $E_1$。数组有空间，因此不发生调整大小。状态变为 $C=1, S=1$。$E_1$ 的复制次数为 $0$。\n3.  **第 2 次追加**：我们尝试追加 $E_2$。数组已满 ($S=C=1$)。触发调整大小。\n    - 分配一个容量为 $2 \\times 1 = 2$ 的新数组。\n    - 元素 $E_1$ 从旧数组复制到新数组。这是 $E_1$ 的**第一次复制**。\n    - 追加元素 $E_2$。\n    - 状态变为 $C=2, S=2$。\n4.  **第 3 次追加**：我们尝试追加 $E_3$。数组已满 ($S=C=2$)。触发调整大小。\n    - 分配一个容量为 $2 \\times 2 = 4$ 的新数组。\n    - 元素 $E_1$ 和 $E_2$ 被复制。这是 $E_1$ 的**第二次复制**。\n    - 追加元素 $E_3$。\n    - 状态变为 $C=4, S=3$。\n5.  **第 4 次追加**：我们追加 $E_4$。数组未满 ($S=3, C=4$)。不调整大小。状态变为 $C=4, S=4$。$E_1$ 仍然被复制了两次。\n6.  **第 5 次追加**：我们尝试追加 $E_5$。数组已满 ($S=C=4$)。触发调整大小，容量变为 $2 \\times 4 = 8$。这涉及到 $E_1$ 的**第三次复制**。\n\n从这个分析中可以清楚地看到，$E_1$ 在其初始放置后发生的每一次调整大小事件中都会被复制。因此，$E_1$ 被复制的次数等于在 $N$ 次追加操作期间发生调整大小的总次数。\n\n从容量 $2^k$ 到 $2^{k+1}$ 的调整大小是由第 $(2^k+1)$ 次追加操作触发的。元素 $E_1$ 存在于所有从初始容量 $2^0$ 开始增加容量的调整大小操作中。\n\n经过 $N$ 次追加后，数组必须容纳 $N$ 个元素。数组的容量 $C_N$ 必须至少为 $N$。由于容量是 2 的幂，所以 $C_N$ 必须是大于或等于 $N$ 的最小的 2 的幂。设这个容量为 $C_N = 2^k$。\n条件 $C_N = 2^k \\ge N$ 且 $k$ 是满足该条件的最小整数，意味着之前的容量 $2^{k-1}$ 是不足的，即 $2^{k-1}  N$。\n因此，我们有不等式：\n$$2^{k-1}  N \\le 2^k$$\n这个不等式对 $N > 1$ 成立。如果 $N=1$，容量是 $1=2^0$，所以 $k=0$。\n对于 $N > 1$，我们可以对不等式两边取以 2 为底的对数：\n$$\\log_2(2^{k-1})  \\log_2(N) \\le \\log_2(2^k)$$\n$$k-1  \\log_2(N) \\le k$$\n这个关系是向上取整函数（ceiling function）的定义。因此，对于 $N > 1$，最终容量的指数 $k$ 由以下公式给出：\n$$k = \\lceil \\log_2(N) \\rceil$$\n我们来验证一下 $N=1$ 的情况。最终容量是 $1 = 2^0$，所以 $k=0$。该公式给出 $\\lceil \\log_2(1) \\rceil = \\lceil 0 \\rceil = 0$。所以这个公式对所有 $N \\ge 1$ 都成立。\n\n为了达到 $2^k$ 的容量，数组必须经历的容量序列是 $2^0, 2^1, 2^2, \\ldots, 2^k$。\n这个序列中从 $2^j$ 到 $2^{j+1}$ 的每一步（其中 $j=0, 1, \\ldots, k-1$）都对应一次调整大小操作。\n第一个元素 $E_1$ 从容量为 $C=2^0$ 时就存在于数组中。它将在随后的每一次调整大小中被复制。这些调整大小操作是：\n- 从 $2^0 \\to 2^1$\n- 从 $2^1 \\to 2^2$\n- ...\n- 从 $2^{k-1} \\to 2^k$\n\n这些调整大小事件的总数是 $(k-1) - 0 + 1 = k$。\n因此，任何单个元素被复制的最大次数是 $k$。代入 $k$ 的表达式：\n$$\\text{最大复制次数} = \\lceil \\log_2(N) \\rceil$$\n这个表达式是关于 $N$ 的封闭形式，并且对所有 $N \\ge 1$ 都有效。",
            "answer": "$$\\boxed{\\lceil \\log_2(N) \\rceil}$$"
        },
        {
            "introduction": "良好的摊还性能是精心设计的结果，而非一种神奇的属性。本题通过引入一个看似合理但最终存在缺陷的缩容（pop）操作重置策略，讲述了一个警示故事。通过分析一个特定的交替执行“追加”和“弹出”操作的序列，你将发现一种“颠簸”行为，其中每次操作都变得昂贵，导致性能低下。这个练习表明，摊还分析是识别和避免数据结构设计中此类性能陷阱的强大工具。",
            "id": "3206841",
            "problem": "考虑一个实现两种操作的动态数组：追加（append）和弹出（pop）。该数组维护一个容量 $C$ 和一个当前大小 $S$，其中 $0 \\leq S \\leq C$。该数组使用以下调整大小策略：\n- 在追加操作时，如果 $S = C$，数组会通过分配一个容量为 $\\lambda C$ 的新数组来进行扩容（其中 $\\lambda > 1$ 是一个固定的常数增长因子），并在追加新元素之前将所有 $S$ 个现有元素复制到新数组中。\n- 在弹出操作时，元素被移除后（因此新大小为 $S-1$），数组会通过分配一个容量恰好等于新大小的新数组来进行缩容，即 $C := S-1$，并将所有 $S-1$ 个现有元素复制到新数组中。\n\n使用以下成本模型：在任何调整大小期间，复制单个元素的成本为 $1$ 个单位，执行不带调整大小的追加或弹出操作的成本为 $1$ 个单位。调整大小期间的复制成本与移动的元素数量成线性关系。\n\n假设数组以大小为 $s_0 \\geq 1$ 且容量为 $c_0 = s_0$ 的稳态开始。考虑一个由 $2m$ 个操作组成的序列，该序列交替执行追加和弹出操作，从追加开始，因此整个过程中大小在 $s_0$ 和 $s_0+1$ 之间切换。使用基本原理的聚合摊还分析，推导出每个操作的摊还成本关于 $m$ 和 $s_0$ 的精确闭式表达式，并报告当 $m \\to \\infty$ 时，以 $s_0$ 表示的稳态下每个操作的摊还成本。将您的最终答案表示为单个闭式解析表达式。无需四舍五入。",
            "solution": "该问题陈述是有效的，因为它在算法分析领域有科学依据，定义明确且提供了所有必要信息，并以客观、正式的语言表述。其调整大小的策略虽然不寻常，但是明确无误的。因此我们可以着手解决。\n\n问题要求使用聚合方法计算一个由“$2m$”个操作组成的特定序列中每个操作的摊还成本。聚合方法计算操作序列的总成本，然后除以操作次数。\n\n设“$S$”为动态数组中元素的数量（其大小），设“$C$”为其容量。\n数组的初始状态给定为大小“$s_0 \\geq 1$”且容量“$c_0 = s_0$”。\n“$2m$”个操作的序列是一个交替的“append”和“pop”序列，从“append”开始。\n\n让我们分析一对 `append` 后跟 `pop` 操作的成本和数组状态。这对应于任何 $k \\in \\{1, 2, \\dots, m\\}$ 的操作 $2k-1$ 和 $2k$。\n\n设第一个操作前的状态为 $(S, C) = (s_0, s_0)$。\n\n**操作 1：Append**\n- 当前状态为 $(S, C) = (s_0, s_0)$。\n- 追加时调整大小的条件是 $S = C$，此条件已满足。\n- 执行调整大小操作。\n    - 所有 $S = s_0$ 个元素被复制到一个新数组中。此复制的成本为 $s_0$。\n    - 新容量为 $C' = \\lambda C = \\lambda s_0$。\n- 然后追加新元素。append 操作的固有成本为 $1$。\n- 此 append 操作的总成本是复制成本和操作成本之和：$s_0 + 1$。\n- 追加后，新大小为 $S' = s_0 + 1$。\n- 数组现在的状态是 $(S, C) = (s_0 + 1, \\lambda s_0)$。\n\n**操作 2：Pop**\n- 当前状态为 $(S, C) = (s_0 + 1, \\lambda s_0)$。\n- 移除一个元素。大小变为 $S' = S - 1 = (s_0 + 1) - 1 = s_0$。\n- `pop` 操作的调整大小策略是总是缩容数组。\n    - 分配一个容量等于新大小的新数组。新容量为 $C' = s_0$。\n    - 所有 $s_0$ 个剩余元素被复制到这个新数组中。此复制的成本为 $s_0$。\n- `pop` 操作的固有成本为 $1$。\n- 此 `pop` 操作的总成本是复制成本和操作成本之和：$s_0 + 1$。\n- 弹出并调整大小后，最终状态为 $(S, C) = (s_0, s_0)$。\n\n经过一对 `append-pop` 操作后，数组的状态 $(S, C)$ 返回到其初始状态 $(s_0, s_0)$。`append` 产生的成本是 $s_0 + 1$，`pop` 产生的成本也是 $s_0 + 1$。\n\n这就建立了一个循环。对于后续的每一对 `append-pop` 操作，过程和成本都将是相同的。增长因子 $\\lambda$ 会影响 `append` 后的中间容量，但该容量会立即被后续 `pop` 操作的调整大小策略所丢弃。因此，对于这个特定的操作序列，$\\lambda$ 的值不影响总成本。\n\n该序列由 $m$ 个这样的 `append-pop` 循环组成。\n- 有 $m$ 个 `append` 操作，每个成本为 $s_0 + 1$。\n- 有 $m$ 个 `pop` 操作，每个成本为 $s_0 + 1$。\n\n总操作次数为 $2m$。\n整个 $2m$ 个操作序列的总成本 $C_{total}$ 为：\n$$ C_{total} = m \\times (\\text{append 的成本}) + m \\times (\\text{pop 的成本}) $$\n$$ C_{total} = m(s_0 + 1) + m(s_0 + 1) = 2m(s_0 + 1) $$\n\n第一个任务是找到每个操作的摊还成本 $A(m, s_0)$ 的精确闭式表达式。这是总成本除以操作次数：\n$$ A(m, s_0) = \\frac{C_{total}}{2m} = \\frac{2m(s_0 + 1)}{2m} = s_0 + 1 $$\n该表达式是作为 $m$ 和 $s_0$ 的函数的摊还成本。它相对于 $m$ 是一个常数。\n\n第二个任务是找到当 $m \\to \\infty$ 时的稳态摊还成本。这是 $A(m, s_0)$ 当 $m$ 趋于无穷大时的极限：\n$$ \\lim_{m \\to \\infty} A(m, s_0) = \\lim_{m \\to \\infty} (s_0 + 1) $$\n由于 $s_0 + 1$ 不依赖于 $m$，该极限就是：\n$$ \\lim_{m \\to \\infty} (s_0 + 1) = s_0 + 1 $$\n\n稳态下每个操作的摊还成本是 $s_0 + 1$。",
            "answer": "$$\\boxed{s_0 + 1}$$"
        },
        {
            "introduction": "标准动态数组的常数摊还成本取决于一个关键假设：复制 $k$ 个元素的成本是线性的，即与 $k$ 成正比。如果这个假设不成立会怎样？本题探讨了一个假设性场景，其中复制成本是二次的（$k^2$），迫使我们重新评估容量倍增策略的效率。通过在这个新成本模型下进行聚合分析，你将看到最终的摊还成本对底层成本假设的敏感性，并发现它不再是一个常数。",
            "id": "3206794",
            "problem": "给定一个动态数组，它连续存储元素。该数组初始为空，初始容量为 $1$。每当一次追加操作会导致当前容量溢出时，数组会通过分配一个容量为当前容量 $2$ 倍的新数组来进行大小调整，然后将所有现有元素按顺序迁移到新数组中。\n\n成本模型如下：每次将单个元素写入可用位置的追加操作成本为 $1$ 个单位；当发生大小调整时，将 $k$ 个现有元素复制到新数组的成本为 $k^2$ 个单位（此外还有触发大小调整的追加操作本身的 $1$ 个单位成本）。你执行了恰好 $n$ 次追加操作，其中 $n$ 是 $2$ 的幂（即，对于某个整数 $t \\ge 0$，有 $n = 2^t$）。\n\n仅使用“每次操作的摊销成本等于总成本除以操作次数”这一定义以及指定的大小调整策略，推导出每次追加操作的精确摊销成本，作为 $n$ 的函数。请以关于 $n$ 的单个简化闭式解析表达式的形式给出你的最终答案。最终答案中不要包含单位。无需四舍五入。",
            "solution": "问题要求计算将元素序列追加到动态数组中 $n$ 次的每次追加操作的精确摊销成本，其中 $n$ 是 $2$ 的幂（$n = 2^t$，对于某个整数 $t \\ge 0$）。摊销成本定义为总成本除以操作次数。\n\n首先，我们必须计算执行 $n$ 次追加操作的总成本。总成本 $C_{total}$ 是两个部分的总和：所有追加操作的总成本和所有调整大小并复制操作的总成本。\n\n成本模型规定如下：\n1.  基本追加成本：每次将元素写入可用位置的追加操作成本为 $1$ 个单位。\n2.  调整大小成本：当触发大小调整时，复制 $k$ 个现有元素的成本为 $k^2$ 个单位。这是在触发调整的追加操作的 $1$ 个单位成本之外的。\n\n总基本追加成本：\n由于恰好有 $n$ 次追加操作，每次的基本成本为 $1$，所以总基本追加成本为 $n \\times 1 = n$。\n\n总调整大小成本：\n当试图对一个已满的数组进行追加操作时，就会发生大小调整。数组的初始容量为 $1$。每次调整大小时，容量都会加倍。\n让我们追踪数组的状态，特别是它的大小（元素数量）和容量。\n-   最初，大小为 $0$，容量为 $1$。\n-   追加 #$1$：大小变为 $1$。数组现在已满。\n-   追加 #$2$：这会触发第一次大小调整，因为大小（$1$）等于容量（$1$）。需要复制的元素数量为 $k=1$。新容量将为 $2 \\times 1 = 2$。这次复制的成本为 $k^2 = 1^2 = 1$。\n-   追加 #$3$：大小为 $2$，容量为 $2$。这会触发一次大小调整。需要复制的元素数量为 $k=2$。新容量将为 $2 \\times 2 = 4$。这次复制的成本为 $k^2 = 2^2 = 4$。\n-   追加 #$5$：大小为 $4$，容量为 $4$。这会触发一次大小调整。需要复制的元素数量为 $k=4$。新容量将为 $2 \\times 4 = 8$。这次复制的成本为 $k^2 = 4^2 = 16$。\n\n根据这个模式，我们可以进行概括。当数组中的元素数量是 $2$ 的幂（比如 $2^j$）时，如果我们需要追加一个新元素，就会触发大小调整。需要复制的元素数量为 $k=2^j$。单次调整大小操作的成本为 $k^2 = (2^j)^2 = 4^j$。\n\n我们总共执行 $n=2^t$ 次追加操作。会触发大小调整的数组大小为 $1, 2, 4, \\dots, 2^{t-1}$。\n-   当大小为 $1=2^0$ 时，下一次追加会触发大小调整。复制成本为 $(2^0)^2 = 4^0$。这对应于 $j=0$。\n-   当大小为 $2=2^1$ 时，下一次追加会触发大小调整。复制成本为 $(2^1)^2 = 4^1$。这对应于 $j=1$。\n-   这个过程一直持续到数组大小为 $2^{t-1}$。下一次追加（第 $2^{t-1}+1$ 次操作）会触发一次大小调整，新容量为 $2 \\times 2^{t-1} = 2^t$。需要复制的元素数量为 $k=2^{t-1}$，成本为 $(2^{t-1})^2 = 4^{t-1}$。这对应于 $j=t-1$。\n\n在最后一次追加操作（第 $n=2^t$ 次）之后，数组的大小将为 $2^t$，容量也为 $2^t$。在这 $n$ 次操作的序列中，不会再发生大小调整。因此，大小调整对应于 $j$ 从 $0$ 到 $t-1$。\n\n总调整大小成本 $C_{resize}$ 是所有这些调整大小操作的成本之和：\n$$C_{resize} = \\sum_{j=0}^{t-1} (2^j)^2 = \\sum_{j=0}^{t-1} 4^j$$\n这是一个包含 $t$ 项的有限几何级数，首项为 $4^0=1$，公比为 $4$。其和由公式 $\\frac{r^{\\text{number of terms}} - 1}{r-1}$ 给出。\n$$C_{resize} = \\frac{4^t - 1}{4 - 1} = \\frac{4^t - 1}{3}$$\n此计算对 $t \\ge 1$ 有效。如果 $t=0$，则 $n=1$，该求和为空，其值为 $0$。我们的公式得出 $\\frac{4^0-1}{3}=0$，因此它也对 $t=0$ 成立。\n\n现在，我们可以通过将总基本追加成本和总调整大小成本相加来得到总成本 $C_{total}$：\n$$C_{total} = (\\text{Total Append Cost}) + (\\text{Total Resize Cost}) = n + \\frac{4^t - 1}{3}$$\n\n为了纯粹用 $n$ 来表示这个表达式，我们使用给定的关系 $n=2^t$。两边平方得到 $n^2 = (2^t)^2 = 2^{2t} = (2^2)^t = 4^t$。\n将 $4^t = n^2$ 代入 $C_{total}$ 的表达式中：\n$$C_{total} = n + \\frac{n^2 - 1}{3}$$\n\n最后，每次追加的摊销成本 $A(n)$ 是总成本除以操作次数 $n$。\n$$A(n) = \\frac{C_{total}}{n} = \\frac{n + \\frac{n^2 - 1}{3}}{n}$$\n我们可以简化这个表达式：\n$$A(n) = \\frac{n}{n} + \\frac{n^2 - 1}{3n} = 1 + \\frac{n^2 - 1}{3n}$$\n为了将其写成一个单一的分数，我们找到一个共同的分母：\n$$A(n) = \\frac{3n}{3n} + \\frac{n^2 - 1}{3n} = \\frac{3n + n^2 - 1}{3n}$$\n重新排列分子中的项，得到最终的简化表达式：\n$$A(n) = \\frac{n^2 + 3n - 1}{3n}$$\n这就是每次追加的精确摊销成本，表示为关于 $n$ 的单个简化闭式解析表达式。",
            "answer": "$$ \\boxed{\\frac{n^2 + 3n - 1}{3n}} $$"
        }
    ]
}