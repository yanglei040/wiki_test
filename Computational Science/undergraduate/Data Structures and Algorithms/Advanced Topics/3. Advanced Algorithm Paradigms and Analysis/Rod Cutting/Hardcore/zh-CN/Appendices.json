{
    "hands_on_practices": [
        {
            "introduction": "在理论学习之后，让我们通过一个更贴近现实的变体来检验我们对动态规划核心思想的理解。在许多实际应用中，我们不仅要考虑收益，还要处理成本。这个练习  引入了负价格，它代表了处理不良长度切块的成本。这个挑战将促使你深入思考动态规划的边界条件和初始化过程，并验证贝尔曼最优性原理在更复杂价值函数下的普适性。",
            "id": "3267470",
            "problem": "给定一个钢条切割问题的实例，其中一些长度的钢条价格为负，表示处理不受欢迎长度的成本。一根总长度为 $n$ 的钢条必须被分割成一个正整数长度的多重集，其长度之和恰好为 $n$。对于每段长度为 $i$ 的钢条，其带来的收益为 $p[i]$，该值可能为负、零或正。目标是最大化通过分割钢条获得的总收益，其中总收益是所选钢条段价格的总和。每次切割没有费用，且钢条必须完全分割成总和为 $n$ 的整数长度；分解不能留下任何剩余部分。\n\n使用的基本原理和定义：\n- 动态规划中的最优性原理（Bellman 原理）指出，如果一个问题表现出最优子结构，那么该问题的最优解内必然包含其子问题的最优解。\n- 最优子结构：如果长度为 $n$ 的钢条的最优分解最后一段的长度为 $i$，那么剩余长度为 $n-i$ 的部分的分解本身也必须是对于长度 $n-i$ 的最优分解。\n- 重叠子问题：不同分解方案的子问题会重复使用相同剩余长度的解。\n\n任务：\n- 根据上述基本原理和定义，推导出正确的算法策略，以计算在给定任意钢条长度 $n$ 和价格列表 $p$ 的情况下可实现的最大收益，即使某些 $p[i]$ 为负数。\n- 实现一个完整的、可运行的程序来评估以下测试套件。对于每个测试用例，计算最大收益并以整数形式报告。\n\n测试套件：\n- 测试 $1$：$n = 8$，价格为 $p[1] = 1$, $p[2] = 5$, $p[3] = -3$, $p[4] = 4$, $p[5] = -2$, $p[6] = 7$, $p[7] = 0$, $p[8] = 8$。\n- 测试 $2$：$n = 5$，价格为 $p[1] = -5$, $p[2] = -1$, $p[3] = -4$, $p[4] = -3$, $p[5] = -2$。\n- 测试 $3$：$n = 0$，价格为 $p[1] = 2$, $p[2] = -1$。注意，由于 $n = 0$，空分解是唯一有效的分割，其收益为 $0$。\n- 测试 $4$：$n = 9$，价格为 $p[1] = -100$, $p[2] = 5$, $p[3] = 0$, $p[4] = 9$, $p[5] = -10$, $p[6] = 10$, $p[7] = -1$, $p[8] = 0$, $p[9] = 19$。\n- 测试 $5$：$n = 10$，价格为 $p[1] = 2$, $p[2] = 3$, $p[3] = 4$, $p[4] = -100$, $p[5] = 7$, $p[6] = 8$, $p[7] = 9$, $p[8] = 10$, $p[9] = 11$, $p[10] = 12$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。该列表必须按顺序包含测试 $1$、测试 $2$、测试 $3$、测试 $4$ 和测试 $5$ 的最大收益。例如，该行应由字符 '[' 后跟 $r_1$、','、$r_2$、','、$r_3$、','、$r_4$、','、$r_5$ 和字符 ']' 构成。",
            "solution": "首先根据指定标准对问题进行验证。\n\n### 问题验证\n**步骤 1：提取已知信息**\n- **问题类型**：带有非正价格的钢条切割问题。\n- **钢条长度**：$n$，一个非负整数。\n- **价格列表**：$p[i]$ 是长度为 $i$ 的一段钢条的收益，其中 $i$ 是一个正整数。价格可以是正数、负数或零。\n- **目标**：将长度为 $n$ 的钢条分割成一个整数长度的多重集，其长度之和恰好为 $n$，从而最大化总收益。\n- **约束**：必须分割整个钢条。没有“每次切割”的成本。\n- **基本原理**：解决方案必须从最优性原理以及最优子结构和重叠子问题的性质推导得出。\n- **测试套件**：\n  - 测试 $1$：$n = 8$，长度 $1$ 到 $8$ 的价格为 $p = [1, 5, -3, 4, -2, 7, 0, 8]$。\n  - 测试 $2$：$n = 5$，长度 $1$ 到 $5$ 的价格为 $p = [-5, -1, -4, -3, -2]$。\n  - 测试 $3$：$n = 0$，长度 $1$ 到 $2$ 的价格为 $p = [2, -1]$。规定对于 $n=0$，收益为 $0$。\n  - 测试 $4$：$n = 9$，长度 $1$ 到 $9$ 的价格为 $p = [-100, 5, 0, 9, -10, 10, -1, 0, 19]$。\n  - 测试 $5$：$n = 10$，长度 $1$ 到 $10$ 的价格为 $p = [2, 3, 4, -100, 7, 8, 9, 10, 11, 12]$。\n\n**步骤 2：使用提取的已知信息进行验证**\n- **科学依据**：该问题是经典钢条切割问题的一个变体，这是算法设计和动态规划中的一个标准课题。引入负价格（代表处理成本）是一个有效、合乎逻辑的扩展，并且没有违反任何数学或科学原理。\n- **良构性**：该问题是良构的。对于任何给定的 $n$ 和价格列表 $p$，都存在一组有效的分割方案（例如，切割成 $n$ 段长度为 $1$ 的钢条），因此保证存在一个最大收益值。目标定义明确。\n- **目标明确**：问题以精确、可形式化的语言陈述（例如，“最大化总收益”、“分割成一个多重集”、“总和恰好为 $n$”）。\n\n**步骤 3：结论与行动**\n该问题具有科学依据、良构、目标明确且自洽。这是一个可以推导出解决方案的有效问题。\n\n### 算法策略推导\n\n该问题旨在最大化收益，并表现出问题陈述中定义的最优子结构和重叠子问题的特性，这是一个可用动态规划解决的问题的标志。负价格的存在并不影响此结构。\n\n令 $r(j)$ 表示长度为 $j$ 的钢条可实现的最大收益，其中 $j$ 是一个非负整数。我们的目标是计算 $r(n)$。\n\n**基本情况：**\n对于长度为 $j=0$ 的钢条，唯一可能的分割是空集合。长度之和为 $0$，收益之和也为 $0$。这与测试 $3$ 的规定一致。因此，我们递推关系的基本情况是：\n$$r(0) = 0$$\n\n**递归公式：**\n对于长度为 $j > 0$ 的钢条，我们必须至少进行一次切割。最优分割是通过进行第一次切割得到一段长度为 $i$（其中 $1 \\le i \\le j$）的钢条，然后对剩余长度为 $j-i$ 的钢条进行最优分割而形成的。这是最优性原理的直接应用。\n\n如果我们选择的第一段长度为 $i$，我们将获得 $p_i$ 的收益（使用 $p_i$ 表示长度为 $i$ 的钢条的价格，如问题文本所示），然后剩下的问题是为长度为 $j-i$ 的钢条找到最大收益，即 $r(j-i)$。对于这个 $i$ 的选择，总收益是 $p_i + r(j-i)$。\n\n为了找到长度为 $j$ 的总的最大收益，我们必须考虑所有可能的首段长度 $i$（从 $1$ 到 $j$），并选择产生最大总收益的那个。这为我们提供了该问题的 Bellman 方程：\n$$r(j) = \\max_{1 \\le i \\le j} \\{ p_i + r(j-i) \\}$$\n无论价格 $p_i$ 的符号如何，该递推关系都成立。最大化运算符 $\\max(\\cdot)$ 正确地识别出最佳选项，无论产生的收益是正还是负。例如，$\\max(-5, -10) = -5$。\n\n**算法设计（自底向上动态规划）：**\n基于该递推关系，我们可以按 $j$ 从 $0$ 到 $n$ 的递增顺序迭代计算 $r(j)$ 的值。这避免了对重叠子问题的解进行重复计算。\n\n1.  创建一个数据结构，通常是一个数组，我们称之为 $R$，大小为 $n+1$，用于存储 $r(0), r(1), \\dots, r(n)$ 的值。\n2.  初始化数组。设置基本情况 $R[0] = 0$。对于所有其他索引 $j > 0$，将 $R[j]$ 初始化为一个保证小于任何可能收益的值，例如负无穷大 ($-\\infty$)。\n3.  使用变量 $j$ 从 $1$ 迭代到 $n$。在每次迭代中，使用推导出的递推关系计算 $R[j]$。这涉及一个从 $1$ 到 $j$ 的 $i$ 的嵌套循环：\n    $$R[j] = \\max_{1 \\le i \\le j} \\{ p_i + R[j-i] \\}$$\n    这里，$p_i$ 对应于长度为 $i$ 的价格（来自输入价格列表，例如，在0索引数组中为 `prices[i-1]`），而 $R[j-i]$ 是已经计算出的剩余长度的最优收益。\n4.  外层循环完成后，$R[n]$ 的值将包含长度为 $n$ 的钢条可能的最大收益。这个值就是解决方案。\n\n这种自底向上的动态规划方法通过建立在较小子问题的最优解之上，正确且高效地解决了钢条切割问题，即使存在负价格。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the provided test suite for the rod cutting problem with negative prices.\n    \"\"\"\n\n    def get_max_revenue(n, prices):\n        \"\"\"\n        Calculates the maximum revenue for cutting a rod of length n using dynamic programming.\n\n        Args:\n            n (int): The length of the rod.\n            prices (list[int]): A list of prices, where prices[i-1] is the price\n                                for a piece of length i.\n\n        Returns:\n            int: The maximum possible revenue.\n        \"\"\"\n        if n == 0:\n            return 0\n\n        # revenue[j] will store the maximum revenue for a rod of length j.\n        # We initialize with negative infinity because revenues can be negative.\n        revenue = np.full(n + 1, -np.inf, dtype=np.float64)\n\n        # Base case: a rod of length 0 has a revenue of 0.\n        revenue[0] = 0\n\n        # Build the table revenue[] in a bottom-up manner.\n        for j in range(1, n + 1):\n            # For each length j, consider all possible first cuts of length i.\n            for i in range(1, j + 1):\n                # The total revenue for this choice is the price of the first piece\n                # plus the optimal revenue for the remaining piece.\n                # price for length i is at index i-1 in the prices list.\n                current_revenue = prices[i - 1] + revenue[j - i]\n                \n                # Update the max revenue for length j if this choice is better.\n                if current_revenue > revenue[j]:\n                    revenue[j] = current_revenue\n        \n        # The final answer is the max revenue for length n.\n        return int(revenue[n])\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test 1\n        (8, [1, 5, -3, 4, -2, 7, 0, 8]),\n        # Test 2\n        (5, [-5, -1, -4, -3, -2]),\n        # Test 3\n        (0, [2, -1]),\n        # Test 4\n        (9, [-100, 5, 0, 9, -10, 10, -1, 0, 19]),\n        # Test 5\n        (10, [2, 3, 4, -100, 7, 8, 9, 10, 11, 12]),\n    ]\n\n    results = []\n    for n, p in test_cases:\n        result = get_max_revenue(n, p)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "一个正确的算法不一定是最高效的算法。在掌握了钢条切割问题的标准 $O(n^2)$ 动态规划解法后，是时候挑战自己，思考如何优化它了。这个练习  提出了一个价格表“稀疏”的场景，即大多数长度的切块价格为零。你的任务是重新审视动态规划的递推关系，设计一个时间复杂度优于标准解法的算法，这是提升算法设计和效率分析能力的关键一步。",
            "id": "3267293",
            "problem": "给定经典的杆切割问题：一根长度为整数 $n$ 的杆可以被切割成整数尺寸的小段，每段长度 $i \\in \\{1,2,\\dots,n\\}$ 都有一个对应的售价 $p_i \\ge 0$。目标是选择切割方案，使得切割后各段长度之和恰好为 $n$，并且总收益最大化。标准的动态规划解法时间复杂度为 $O(n^2)$，它为每个 $j \\in \\{1,2,\\dots,n\\}$ 计算将 $j$ 写成正整数之和的所有方式中能获得的最大收益。在本任务中，价格列表是稀疏的：大多数 $p_i$ 为零。你必须设计并实现一个算法，利用这种稀疏性，在非零价格数量较少时，实现严格优于 $O(n^2)$ 的渐进运行时间。\n\n基本原理和约束：\n- 该算法必须源自贝尔曼最优性原理（Bellman Optimality Principle）和动态规划的最优子结构定义，这两者都是经过充分检验的算法基石。具体来说，对于任何 $j \\in \\{1,\\dots,n\\}$，长度为 $j$ 的最优收益等于最佳的第一次切割收益加上剩余部分的最优收益。\n- 可用的小段长度集合恰好是 $\\{1,2,\\dots,n\\}$；对于可以使用哪些长度没有限制，但价格可能为零。所有 $p_i$ 均为整数，且 $p_i \\ge 0$。\n- 你必须基于这些基本原理构建一个改进算法，其最坏情况下的时间复杂度为 $O(n \\cdot m)$，其中 $m$ 是满足 $p_i > 0$ 的索引 $i$ 的数量。该改进必须通过消除涉及 $p_i=0$ 的状态转移，同时保持正确性来实现。\n- 你必须明确论证，为什么即使算法不遍历价格为零的长度，它仍然能计算出正确的最大收益。\n\n输出要求：\n- 对于每个测试用例，计算总杆长 $n$ 可获得的最大收益。\n- 你的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表（例如 $[r_1,r_2,\\dots]$），其中每个 $r_k$ 是一个整数。\n\n本问题不涉及角度单位、物理单位和百分比。\n\n测试套件：\n- 测试用例 1：$n = 8$，价格列表 $p = [1,0,4,5,0,0,0,0]$。\n- 测试用例 2：$n = 9$，价格列表 $p = [0,0,0,7,0,0,0,0,0]$。\n- 测试用例 3：$n = 5$，价格列表 $p = [0,0,0,0,0]$。\n- 测试用例 4：$n = 7$，价格列表 $p = [2,0,0,0,9,0,0]$。\n- 测试用例 5：$n = 20$，价格列表 $p = [0,5,7,0,0,0,17,19,0,0,0,0,0,0,0,0,0,0,0,0]$。\n\n覆盖性设计：\n- 测试用例 1 是一个一般情况，包含几个有利可图的长度，涵盖了小尺寸和中等尺寸的切割。\n- 测试用例 2 确保只有一个非零价格存在于长度大于 1 的位置，需要用价格为零的长度进行填充以达到精确尺寸。\n- 测试用例 3 是一个所有价格都为零的边界情况。\n- 测试用例 4 测试存在有利可图的单位长度段，以确保收益单调增长。\n- 测试用例 5 重点测试组合多个有利可图的长度，并检查高密度（高价/长度比）的段是否占主导地位。\n\n最终输出格式：\n- 你的程序必须打印单行：一个包含五个整数结果的列表，按测试用例的顺序排列，用逗号分隔并用方括号括起来，例如 $[r_1,r_2,r_3,r_4,r_5]$。",
            "solution": "该问题要求在价格列表稀疏的条件下，为杆切割问题设计一个高效算法。标准的动态规划解法时间复杂度为 $O(n^2)$，我们必须利用许多价格 $p_i$ 为零这一事实来改进它。目标复杂度为 $O(n \\cdot m)$，其中 $m$ 是价格非零的段数。推导过程必须基于贝尔曼最优性原理（Bellman Optimality Principle）。\n\n### 基于原理的稀疏算法推导\n\n杆切割问题具有最优子结构。设 $r_j$ 为长度为整数 $j$ 的杆可获得的最大收益。为了找到切割长度为 $j$ 的杆的最优方法，我们可以进行一次长度为 $i$（其中 $1 \\le i \\le j$）的首次切割，然后最优地切割剩余长度为 $j-i$ 的部分。此选择的收益为 $p_i + r_{j-i}$。贝尔曼最优性原理指出，我们必须选择使该值最大化的切割 $i$。这就得到了标准的动态规划递推关系：\n$$r_j = \\max_{1 \\le i \\le j} \\{p_i + r_{j-i}\\}$$\n基准情况为 $r_0 = 0$。直接计算 $j=1, \\dots, n$ 的这个递推关系需要嵌套循环，导致 $O(n^2)$ 的时间复杂度。\n\n为了利用稀疏性，我们分析不同切割的贡献。我们可以将可能的首次切割集合 $\\{1, 2, \\dots, j\\}$ 划分为两个不相交的集合：\n1. $I_p(j) = \\{i \\mid 1 \\le i \\le j, p_i > 0\\}$：价格为正的可用段长度集合。\n2. $I_z(j) = \\{i \\mid 1 \\le i \\le j, p_i = 0\\}$：价格为零的可用段长度集合。\n\n通过在这两个集合上分别进行最大化，可以将递推关系重写为：\n$$r_j = \\max \\left( \\max_{i \\in I_p(j)} \\{p_i + r_{j-i}\\}, \\max_{i \\in I_z(j)} \\{0 + r_{j-i}\\} \\right)$$\n我们来分析外层 $\\max$ 函数中的两项。第一项 $\\max_{i \\in I_p(j)} \\{p_i + r_{j-i}\\}$ 考虑了所有有利可图的首次切割。对于任何 $j$，此类切割的数量最多为 $m$，即非零价格的总数。\n\n第二项是 $\\max_{i \\in I_z(j)} \\{r_{j-i}\\}$。为简化此项，我们首先确立收益函数 $r_j$ 的一个关键性质：它随 $j$ 非递减。对于任何长度为 $j \\ge 1$ 的杆，一种可能（但不一定最优）的切割策略是切下一段长度为 1 的小段，然后最优地切割剩余长度为 $j-1$ 的部分。这种特定策略的收益是 $p_1 + r_{j-1}$。最优收益 $r_j$ 必须至少不小于任何单一策略的收益。因此，$r_j \\ge p_1 + r_{j-1}$。由于所有价格都是非负的（$p_i \\ge 0$），我们有 $p_1 \\ge 0$，这意味着 $r_j \\ge r_{j-1}$。通过归纳法，这对所有 $j \\ge 1$ 成立，所以 $r_0 \\le r_1 \\le r_2 \\le \\dots \\le r_n$。\n\n在确立 $r_j$ 为非递减函数后，我们回到 $\\max_{i \\in I_z(j)} \\{r_{j-i}\\}$ 这一项。由于任何切割的 $i \\ge 1$，我们有 $j-i \\le j-1$。因为 $r_k$ 是非递减的，所以对于所有 $i \\ge 1$，$r_{j-i} \\le r_{j-1}$。因此，集合 $\\{r_{j-i} \\mid i \\in I_z(j)\\}$ 中的最大值上限为 $r_{j-1}$。所以，我们有：\n$$\\max_{i \\in I_z(j)} \\{r_{j-i}\\} \\le r_{j-1}$$\n\n$r_j$ 的完整递推关系因此受限于：\n$$r_j \\le \\max \\left( \\max_{i \\in I_p(j)} \\{p_i + r_{j-i}\\}, r_{j-1} \\right)$$\n然而，我们又知道 $r_j \\ge r_{j-1}$。这意味着解必须至少为 $r_{j-1}$。任何长度为 $j$ 的最优解，要么是某个较短长度的最优解加上一些零价格的切割（在这种情况下，其收益被 $r_k$ 的非递减性所捕获，并以 $r_{j-1}$ 为界），要么涉及进行一次新的有利可图的切割。这导出了精确且改进的递推关系：\n$$r_j = \\max \\left( r_{j-1}, \\max_{i \\in I_p(j)} \\{p_i + r_{j-i}\\} \\right)$$\n\n### 正确性论证\n这个新的递推关系在避免遍历零价格切割的同时，正确地计算了最大收益。论证如下：长度为 $j$ 的杆的最优解来自一个划分 $j = \\sum_k c_k$。其收益为 $\\sum_k p_{c_k}$。\n1.  **情况 1：长度 $j$ 的最优解与某个长度 $j'  j$ 的最优解相同。** 如果长度 $j$ 的划分只是长度 $j'$ 的划分加上一些价格为零的段，就会发生这种情况。例如，长度 $j$ 的最大收益是通过将其切割成一段长度为 1（价格 $p_1=0$）的小段和一个最优切割的长度为 $j-1$ 的杆来实现的。在这种情况下，$r_j = r_{j-1}$。我们递推关系中的 `r_{j-1}` 项正确地捕获了可以从较短杆长“延续”过来的最大可能收益。由于 $r_k$ 是非递减的，因此 $r_{j-1}$ 是从任何较小长度 $j'  j$ 可能获得的最高收益。\n\n2.  **情况 2：长度 $j$ 的每个最优解都至少涉及一段价格 $p_i > 0$ 的段 $i$。** 在这种情况下，最优解是通过进行一次首次切割 $i$（价格 $p_i > 0$）并最优地解决剩余的 $j-i$ 部分来找到的。我们递推关系中的 $\\max_{i \\in I_p(j)} \\{p_i + r_{j-i}\\}$ 项明确地在所有有利可图的首次切割中找到了最佳选项。\n\n通过取这两种情况的最大值，我们覆盖了所有可能性并保证了最优性。该算法能正确计算最大收益，因为它既考虑了所有有利可图的切割，也考虑了长度为 $j$ 的最优策略可能只是将长度为 $j-1$ 的最优解用一个零收益的段来扩展。\n\n### 算法设计与复杂度分析\n基于推导出的递推关系，我们可以制定一个高效的算法。\n\n1.  初始化一个大小为 $n+1$ 的一维数组 `revenue`，用于存储最优收益 $r_0, r_1, \\dots, r_n$。设置 `revenue[0] = 0`。\n2.  预处理价格列表 $p$，为那些价格为正的长度 $i$ 创建一个 `(i, price)` 对的列表。设此列表的大小为 $m$。\n3.  使用一个循环，对 $j$ 从 $1$ 到 $n$ 进行迭代，以计算 `revenue[j]`。\n4.  对于每个 $j$，计算 `max_from_positive_cuts`，即进行一次有利可图的首次切割所能获得的最大收益。将其初始化为 $0$（或一个足够小的数）。遍历 $m$ 个有利可图的切割 `(i, price)`。如果 $i \\le j$，则用 `price + revenue[j-i]` 更新此最大值。\n5.  设置 `revenue[j] = max(revenue[j-1], max_from_positive_cuts)`。\n6.  最终答案是 `revenue[n]`。\n\n时间复杂度由嵌套循环决定。外层循环运行 $n$ 次（$j=1, \\dots, n$）。内层循环遍历包含 $m$ 个正价格的列表。因此，总时间复杂度为 $O(n \\cdot m)$，当 $m \\ll n$ 时，这严格优于 $O(n^2)$。空间复杂度为 $O(n)$，用于存储 `revenue` 数组。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the sparse rod cutting problem for a suite of test cases.\n    \"\"\"\n\n    test_cases = [\n        (8, [1, 0, 4, 5, 0, 0, 0, 0]),\n        (9, [0, 0, 0, 7, 0, 0, 0, 0, 0]),\n        (5, [0, 0, 0, 0, 0]),\n        (7, [2, 0, 0, 0, 9, 0, 0]),\n        (20, [0, 5, 7, 0, 0, 0, 17, 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n    ]\n\n    results = []\n    for n, p in test_cases:\n        result = compute_max_revenue(n, p)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_max_revenue(n: int, prices: list[int]) -> int:\n    \"\"\"\n    Computes the maximum revenue for the rod cutting problem using a sparse DP approach.\n    \n    The algorithm has a time complexity of O(n*m), where n is the rod length and m is the\n    number of pieces with a non-zero price.\n\n    Args:\n        n: The integer length of the rod.\n        prices: A list of integers where prices[i-1] is the price for a piece of length i.\n\n    Returns:\n        The maximum obtainable revenue.\n    \"\"\"\n    # revenue[j] will store the maximum revenue for a rod of length j.\n    # Initialize with zeros. revenue[0] is 0 by definition.\n    revenue = np.zeros(n + 1, dtype=int)\n\n    # Pre-process to find all pieces with positive prices.\n    # Store them as (length, price) tuples. Length is 1-based.\n    positive_prices = []\n    for i in range(len(prices)):\n        if prices[i] > 0:\n            length = i + 1\n            price = prices[i]\n            positive_prices.append((length, price))\n\n    # Main DP loop. Iterate from length j = 1 to n.\n    for j in range(1, n + 1):\n        # This variable will hold max_{i in I_p(j)} {p_i + r_{j-i}}.\n        # Initialize to 0, which is safe since revenues are non-negative.\n        max_rev_from_pos_cuts = 0\n\n        # Iterate only through pieces with positive prices.\n        for length, price in positive_prices:\n            if length = j:\n                # Consider making a first cut of this `length`.\n                current_rev = price + revenue[j - length]\n                if current_rev > max_rev_from_pos_cuts:\n                    max_rev_from_pos_cuts = current_rev\n        \n        # The recurrence relation is r_j = max(r_{j-1}, max_rev_from_pos_cuts).\n        # r_{j-1} accounts for optimal solutions that just append zero-priced pieces\n        # to an optimal solution for a smaller rod.\n        revenue[j] = max(revenue[j - 1], max_rev_from_pos_cuts)\n\n    return revenue[n]\n\nsolve()\n```"
        },
        {
            "introduction": "在优化问题中，计算出最优值往往只是第一步，我们最终的目标通常是了解如何实现这一最优结果。这个练习  将我们的任务从“计算最大收益”升级为“找出所有最优切割方案”。你将需要扩展你的动态规划算法，使其不仅能记录最优值，还能回溯并构建出所有能达到该值的独一无二的切割组合，这是将抽象的优化结果转化为具体可行方案的核心技能。",
            "id": "3267391",
            "problem": "给定经典的钢条切割任务，该任务以纯数学术语表述。对于整数钢条长度 $L \\ge 0$ 和价格表 $P_1, P_2, \\dots, P_L$（其中 $P_i$ 是长度为 $i$ 的单段钢条的售价），切割方案是指任何其元素之和恰好为 $L$ 的正整数多重集。一个切割方案的总收益是其组成片段价格的总和。您的任务是，对于每个指定的实例，重建所有能够实现最大可能总收益的唯一切割方案（视为多重集，因此顺序无关），并同时给出该最大收益值。\n\n您的算法设计必须仅基于基本定义和原则：离散优化中的最优子结构定义、动态规划（DP, Dynamic Programming）的定义，以及任何最优解均由其子问题的最优解构成的最优性原理。除这些原则外，不得假设任何快捷公式。切割是免费的，片段数量不受限制，且所有片段必须为整数长度。每个价格 $P_i$ 都是非负整数。\n\n用频率向量 $\\mathbf{c} = (c_1, c_2, \\dots, c_L)$ 表示每个唯一的切割方案，其中 $c_i$ 是长度为 $i$ 的片段数量。当且仅当两个切割方案的频率向量相同时，它们被认为是相同的。对于 $L = 0$，有且仅有一种方案：空多重集，表示为长度为 $0$ 的空频率向量。\n\n您的程序必须解决以下测试套件。每个测试用例由一对 $(\\mathbf{P}, L)$ 组成，其中 $\\mathbf{P}$ 是一个列表 $(P_1,P_2,\\dots,P_L)$。\n\n- 测试用例 1: $L = 4$, $\\mathbf{P} = (1, 5, 8, 9)$。\n- 测试用例 2: $L = 5$, $\\mathbf{P} = (2, 5, 7, 8, 10)$。\n- 测试用例 3: $L = 0$, $\\mathbf{P} = ()$。\n- 测试用例 4: $L = 7$, $\\mathbf{P} = (1, 5, 8, 9, 10, 17, 17)$。\n- 测试用例 5: $L = 6$, $\\mathbf{P} = (2, 4, 6, 8, 10, 12)$。\n\n对每个测试用例，计算：\n- 长度为 $L$ 的所有切割方案的最大收益 $R^\\star$。\n- 所有实现 $R^\\star$ 的唯一最优频率向量 $\\mathbf{c}$ 的完整集合。\n\n为了使输出完全确定且可解析，请将最优频率向量按 $(c_1, c_2, \\dots, c_L)$ 的字典升序排列，并将每个测试用例的答案编码为单个整数列表：\n- 首先放置 $R^\\star$。\n- 然后放置最优方案的数量 $K$。\n- 然后，对于指定顺序中的 $K$ 个方案中的每一个，追加其完整的频率向量 $(c_1, c_2, \\dots, c_L)$。\n\n您的程序应将所有五个测试用例的答案汇总到一行中，方法是打印这些按测试用例组织的列表所组成的列表，使用逗号分隔且无空格，例如 $[[\\dots],[\\dots],\\dots]$。此任务不涉及物理单位、角度或百分比。每个测试用例唯一可接受的输出是严格按照上述规定排列的整数。",
            "solution": "## 问题验证\n\n### 步骤 1：提取已知条件\n- **任务**：对于给定的整数钢条长度 $L \\ge 0$ 和价格表 $(P_1, P_2, \\dots, P_L)$，找出最大可能总收益 $R^\\star$ 以及所有实现此收益的唯一切割方案。\n- **切割方案**：一个正整数的多重集，其元素之和恰好为 $L$。片段的顺序无关紧要。\n- **方案表示**：一个频率向量 $\\mathbf{c} = (c_1, c_2, \\dots, c_L)$，其中 $c_i$ 是长度为 $i$ 的片段数量。\n- **特殊情况 $L=0$**：唯一的方案是空多重集，表示为长度为 $0$ 的空频率向量。\n- **约束条件**：$P_i$ 是非负整数。切割是免费的。所有片段都具有整数长度。\n- **输出格式**：对于每个测试用例，输出一个单一的整数列表：$[R^\\star, K, c_{1,1}, \\dots, c_{1,L}, \\dots, c_{K,1}, \\dots, c_{K,L}]$，其中 $K$ 是最优方案的数量，且 $K$ 个频率向量按字典序排序。\n- **测试套件**：\n    1. $L = 4$, $\\mathbf{P} = (1, 5, 8, 9)$\n    2. $L = 5$, $\\mathbf{P} = (2, 5, 7, 8, 10)$\n    3. $L = 0$, $\\mathbf{P} = ()$\n    4. $L = 7$, $\\mathbf{P} = (1, 5, 8, 9, 10, 17, 17)$\n    5. $L = 6$, $\\mathbf{P} = (2, 4, 6, 8, 10, 12)$\n\n### 步骤 2：使用提取的已知条件进行验证\n根据验证标准评估问题。\n- **科学性**：该问题是计算机科学和离散数学中动态规划的一个典型例子。它在数学上是严谨的，事實上是健全的。此标准已满足。\n- **适定性**：对于任何给定的输入，都存在有限数量的切割方案，保证了最大收益的存在。找出此最大值及所有对应方案的目标是明确定义的。此标准已满足。\n- **客观性**：该问题使用形式化的数学语言陈述，没有任何主观性或歧义。此标准已满足。\n- **不完整或矛盾的设置**：该问题是自洽的。所有必要的定义（方案、收益、向量表示）、约束和特殊情况（例如 $L=0$）都已提供。不存在矛盾之处。此标准已满足。\n- **其他缺陷**：该问题并非微不足道，因为它需要一个系统化的算法（DP）来解决。它不是隐喻性的、不适定的或无法验证的。\n\n### 步骤 3：结论与行动\n问题是**有效的**。将提供一个解决方案。\n\n## 算法解决方案\n\n寻找切割钢条的最优收益问题是一个经典的离散优化问题，它展现了最优子结构的特性。此特性是动态规划的基石。\n\n**最优性原理与最大收益的递推关系**\n\n最优性原理指出，一个问题的最优解可以由其子问题的最优解构造而成。对于钢条切割问题，长度为 $L$ 的钢条的最优切割方案必须包含对其余片段的最优切割方案。\n\n令 $R[j]$ 表示从长度为 $j$ 的钢条可获得的最大收益，其中 $j \\in \\{0, 1, \\dots, L\\}$。基准情况是长度为 $0$ 的钢条，它没有片段，因此收益为 $R[0] = 0$。对于任何长度 $j > 0$，我们可以通过考虑所有可能的首次切割来确定 $R[j]$。如果我们进行一次长度为 $i$（其中 $1 \\le i \\le j$）的首次切割，我们得到一个长度为 $i$、价格为 $P_i$ 的片段，以及一个剩余长度为 $j-i$ 的钢条。根据定义，我们可以从剩余部分获得的最大收益是 $R[j-i]$。选择这种首次切割的总收益是 $P_i + R[j-i]$。为了找到长度为 $j$ 的最优收益，我们必须对所有可能的首次切割 $i$ 进行最大化：\n\n$$R[j] = \\max_{1 \\le i \\le j} (P_i + R[j-i])$$\n\n这个递推关系允许我们以自底向上的方式计算从长度 $1$ 到 $L$ 的所有长度的最大收益。\n\n**所有最优切割方案的重建**\n\n任务不仅要求最大收益，还要求所有实现该收益的唯一切割方案。为了实现这一点，我们的动态规划状态必须存储的不仅仅是一个数值。我们定义 $S[j]$ 为长度为 $j$ 的钢条的所有最优频率向量的集合。频率向量 $\\mathbf{c} = (c_1, c_2, \\dots, c_L)$ 表示一个包含 $c_i$ 个长度为 $i$ 的片段的方案。\n\n这些方案集合的状态转移如下：\n对于给定的长度 $j$，在计算出最优收益 $R[j]$ 后，我们识别出所有导致此收益的首次切割 $i$，即所有满足 $P_i + R[j-i] = R[j]$ 的 $i \\in \\{1, \\dots, j\\}$。\n\n对于每个这样的最优首次切割 $i$，我们考虑剩余长度为 $j-i$ 的子问题的所有最优方案。令 $\\mathbf{c'} = (c'_1, \\dots, c'_L)$ 为集合 $S[j-i]$ 中的一个最优频率向量。通过向此方案添加一个长度为 $i$ 的片段，我们为长度 $j$ 形成了一个新方案。相应的新频率向量 $\\mathbf{c} = (c_1, \\dots, c_L)$ 是通过将 $\\mathbf{c'}$ 的第 $i$ 个分量加一得到的，即 $c_i = c'_i + 1$ 且对于 $k \\ne i$ 有 $c_k = c'_k$。\n\n集合 $S[j]$ 是由所有最优首次切割 $i$ 和 $S[j-i]$ 中所有对应的最优子方案生成的所有新方案的并集。对 $S[j]$ 使用集合数据结构自然地处理了可能由不同切割顺序（例如，切割 $1+2$ vs $2+1$）产生的重复方案的消除问题。\n\n**算法步骤**\n\n1.  处理 $L=0$ 的基准情况。根据问题描述，最大收益为 $R^\\star=0$，且有一个最优方案，即空频率向量。\n2.  对于 $L>0$，初始化一个大小为 $L+1$ 的收益数组 $R$ 和一个大小为 $L+1$ 的方案集合列表 $S$。\n3.  设置 DP 的基准情况：$R[0] = 0$，且 $S[0]$ 包含一个全零的频率向量，代表长度为 $0$ 的钢条的“空”切割集合。\n4.  从 $j=1$ 迭代到 $L$：\n    a. 使用已计算出的值 $R[0], \\dots, R[j-1]$，应用递推关系确定最大收益 $R[j]$。\n    b. 为 $S[j]$ 初始化一个空集。\n    c. 遍历所有可能的首次切割 $i$（从 $1$ 到 $j$）。\n    d. 如果切割 $i$ 是最优的（即 $P_i + R[j-i] = R[j]$），则遍历 $S[j-i]$ 中的每个方案 $\\mathbf{c'}$。对于每个 $\\mathbf{c'}$，通过添加一个长度为 $i$ 的片段来构建一个新方案 $\\mathbf{c}$，并将其添加到集合 $S[j]$ 中。\n5.  循环完成后，原始问题的最大收益为 $R[L]$。所有最优切割方案的集合为 $S[L]$。\n6.  为满足输出规范，将集合 $S[L]$ 转换为列表，并对其元素（频率向量）进行字典序排序。最后，构建指定的整数列表格式。\n\n这种基于 DP 的算法系统地探索解空间，基于 Bellman 原理保证了最优性，并正确地重建了所有唯一的最优解。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_optimal_cuts(P, L):\n    \"\"\"\n    Calculates the maximum revenue and all optimal cutting patterns for a given rod length and price table.\n    \"\"\"\n    if L == 0:\n        # As per the problem spec, L=0 has R*=0, K=1, and an empty frequency vector.\n        return [0, 1]\n\n    # prices P is a list/tuple where P[i] is the price for length i+1.\n    \n    # dp_rev[j] will store the maximum revenue for a rod of length j.\n    dp_rev = np.zeros(L + 1, dtype=int)\n    \n    # dp_patterns[j] will store a set of all optimal pattern vectors (as tuples) for length j.\n    dp_patterns = [set() for _ in range(L + 1)]\n\n    # Base case for a rod of length 0 within a larger problem of length L > 0.\n    # The pattern is a frequency vector of L zeros.\n    dp_patterns[0].add(tuple([0] * L))\n\n    # Bottom-up DP to fill the tables.\n    for j in range(1, L + 1):\n        # First pass: find the maximum possible revenue for length j.\n        max_rev = -1\n        for i in range(1, j + 1):\n            # i is the length of the first cut.\n            # Price for length i is at P[i-1].\n            # Remainder is j-i, with optimal revenue dp_rev[j-i].\n            current_rev = P[i-1] + dp_rev[j-i]\n            if current_rev > max_rev:\n                max_rev = current_rev\n        \n        dp_rev[j] = max_rev\n        \n        # Second pass: find all patterns that achieve this maximum revenue.\n        current_j_patterns = set()\n        for i in range(1, j + 1):\n            if P[i-1] + dp_rev[j-i] == max_rev:\n                # This first cut 'i' contributes to an optimal solution for length j.\n                \n                # Get all optimal patterns for the remainder piece of length j-i.\n                remainder_patterns = dp_patterns[j-i]\n                \n                for p_tuple in remainder_patterns:\n                    # p_tuple is a frequency vector (c_1, ..., c_L).\n                    # Create a new pattern by adding one piece of length i.\n                    new_pattern_list = list(p_tuple)\n                    new_pattern_list[i-1] += 1\n                    current_j_patterns.add(tuple(new_pattern_list))\n        \n        dp_patterns[j] = current_j_patterns\n\n    # Extract final results for length L.\n    R_star = dp_rev[L]\n    # Sort the patterns lexicographically as required.\n    optimal_patterns_sorted = sorted(list(dp_patterns[L]))\n    K = len(optimal_patterns_sorted)\n\n    # Format the output list as specified: [R*, K, pattern1..., pattern2...]\n    result = [R_star, K]\n    for p in optimal_patterns_sorted:\n        result.extend(p)\n        \n    return result\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final output.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1: L=4, P=(1, 5, 8, 9)\n        ((1, 5, 8, 9), 4),\n        # Test case 2: L=5, P=(2, 5, 7, 8, 10)\n        ((2, 5, 7, 8, 10), 5),\n        # Test case 3: L=0, P=()\n        ((), 0),\n        # Test case 4: L=7, P=(1, 5, 8, 9, 10, 17, 17)\n        ((1, 5, 8, 9, 10, 17, 17), 7),\n        # Test case 5: L=6, P=(2, 4, 6, 8, 10, 12)\n        ((2, 4, 6, 8, 10, 12), 6),\n    ]\n\n    results = []\n    for case in test_cases:\n        P, L = case\n        result = calculate_optimal_cuts(P, L)\n        results.append(result)\n\n    # The final print statement must produce the single-line format: [[...],[...],...]\n    # 1. Convert each inner list of integers to a string like \"[i1,i2,...]\".\n    inner_list_strs = [f\"[{','.join(map(str, res_list))}]\" for res_list in results]\n    # 2. Join these strings with commas.\n    # 3. Enclose the whole thing in brackets.\n    final_output_str = f\"[{','.join(inner_list_strs)}]\"\n    \n    print(final_output_str)\n\nsolve()\n```"
        }
    ]
}