{
    "hands_on_practices": [
        {
            "introduction": "The magic of the median-of-medians algorithm lies in its recursive structure, where it solves a smaller, similar problem to find a good pivot. This first exercise is a quick check on your understanding of this initial step. By calculating the minimum array size $n$ needed to generate a certain number of medians, you will build a foundational intuition for how the problem size is reduced in the first recursive call .",
            "id": "3250861",
            "problem": "Consider the deterministic linear-time selection procedure commonly known as Median-of-Medians (MoM). Given an input array of $n$ elements, the procedure partitions the array into contiguous groups of fixed size $g=5$, except possibly the last group, which may contain $s$ elements with $1 \\leq s \\leq 5$. For each group of size $s$, define its median to be the $\\lceil s/2 \\rceil$-th smallest element in that group, and collect one such median from every group into a separate auxiliary array, denoted by $M$. The size of $M$ equals the number of groups formed in the partitioning.\n\nStarting strictly from the definitions above, determine the smallest integer $n$ such that the size of the auxiliary array $M$ is greater than or equal to the group size $g=5$. Provide the exact integer value for $n$.",
            "solution": "The problem will first be validated against the specified criteria before a solution is attempted.\n\n### Step 1: Extract Givens\n- The algorithm is the Median-of-Medians (MoM) selection procedure.\n- The input is an array of $n$ elements.\n- The array is partitioned into contiguous groups of fixed size $g=5$.\n- The last group can have a size $s$ where $1 \\leq s \\leq 5$.\n- The median of a group of size $s$ is its $\\lceil s/2 \\rceil$-th smallest element.\n- An auxiliary array $M$ is formed by collecting one median from every group.\n- The size of $M$ is equal to the number of groups formed.\n- The objective is to find the smallest integer $n$ such that the size of $M$ is greater than or equal to the group size $g=5$.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientific Groundedness**: The problem describes a key step in the BFPR (Blum-Floyd-Pratt-Rivest-Tarjan) Median-of-Medians selection algorithm, a fundamental topic in computer science and algorithms. The definitions and setup are standard and scientifically sound.\n- **Well-Posedness**: The problem asks for the smallest integer $n$ satisfying a well-defined mathematical condition. A unique integer solution is expected to exist.\n- **Objectivity**: The language is formal and unambiguous, typical of an algorithm analysis problem.\n- **Completeness and Consistency**: All necessary parameters ($g=5$) and definitions are provided. The problem is self-contained and free of contradictions.\n\n### Step 3: Verdict and Action\nThe problem is deemed **valid**. A solution will be provided.\n\n### Solution\nThe problem asks for the smallest integer $n$ such that a specific condition is met. Let's analyze the components of this condition.\n\nThe input array has $n$ elements. It is partitioned into groups of size $g=5$. The last group may be smaller. Let $k$ be the total number of groups created. The number of groups $k$ is determined by the total number of elements $n$ and the group size $g$. Specifically, if we divide the $n$ elements into groups of size $g$, the number of groups will be the total number of elements divided by the group size, rounded up to the nearest integer. This is mathematically represented by the ceiling function:\n$$k = \\left\\lceil \\frac{n}{g} \\right\\rceil$$\n\nAccording to the problem statement, the auxiliary array $M$ contains one median from every group. Therefore, the size of $M$, which we can denote as $|M|$, is equal to the number of groups, $k$.\n$$|M| = k$$\n\nThe problem requires us to find the smallest integer $n$ such that the size of the auxiliary array $M$ is greater than or equal to the group size $g$. This condition can be written as:\n$$|M| \\geq g$$\n\nSubstituting $|M|=k$ and $k=\\lceil n/g \\rceil$, we get the inequality:\n$$\\left\\lceil \\frac{n}{g} \\right\\rceil \\geq g$$\n\nWe are given that the group size is $g=5$. Substituting this value into the inequality:\n$$\\left\\lceil \\frac{n}{5} \\right\\rceil \\geq 5$$\n\nWe need to find the smallest integer $n$ that satisfies this inequality. Let's analyze the properties of the ceiling function. The expression $\\lceil x \\rceil \\geq C$ for an integer $C$ is equivalent to the strict inequality $x > C-1$. If $x$ were equal to $C-1$, $\\lceil x \\rceil$ would be $C-1$. For $\\lceil x \\rceil$ to be at least $C$, $x$ must be strictly greater than $C-1$.\n\nApplying this property to our inequality, where $x = n/5$ and $C=5$:\n$$\\frac{n}{5} > 5 - 1$$\n$$\\frac{n}{5} > 4$$\n\nTo solve for $n$, we multiply both sides of the inequality by $5$:\n$$n > 20$$\n\nSince $n$ represents the number of elements in an array, it must be an integer. The problem asks for the smallest integer $n$ that satisfies the condition $n > 20$. The smallest integer greater than $20$ is $21$.\n\nTherefore, the smallest integer value for $n$ is $21$.\n\nWe can verify this result:\n- If $n=20$, the number of groups is $k = \\lceil 20/5 \\rceil = \\lceil 4 \\rceil = 4$. The condition $k \\geq 5$ is not met, since $4  5$.\n- If $n=21$, the number of groups is $k = \\lceil 21/5 \\rceil = \\lceil 4.2 \\rceil = 5$. The condition $k \\geq 5$ is met, since $5=5$.\n\nThus, the smallest integer $n$ for which the number of groups is at least $5$ is indeed $21$.",
            "answer": "$$\\boxed{21}$$"
        },
        {
            "introduction": "The algorithm's guaranteed $O(n)$ performance isn't magic; it comes from a mathematical proof that the chosen pivot will always create a \"reasonably balanced\" partition. This exercise challenges you to move from abstract theory to concrete construction. By building an array that forces the algorithm into its worst possible (yet still balanced) split, you will gain a hands-on appreciation for the partitioning bounds that are the very heart of this famous algorithm's efficiency .",
            "id": "3250877",
            "problem": "Consider the deterministic linear-time selection algorithm commonly known as the median-of-medians method. The algorithm operates by partitioning an input array into groups of equal size, computing medians of each group, selecting the median of these medians as a pivot, and performing a partition around this pivot; it then recurses on one side depending on the rank of the desired order statistic. For group size $5$, the analysis of the algorithm’s correctness and running time depends on counting how many elements are guaranteed to be strictly less than and strictly greater than the pivot selected as the median of medians.\n\nYou are to construct an explicit input array $A$ of size $n=25$ with distinct integers, arranged to force the algorithm’s partition step to produce the largest possible recursive subproblem under the standard grouping by contiguous blocks of size $5$ in the given array order. Your construction must follow these structural constraints:\n\n- Partition $A$ into the five contiguous groups $G_1, G_2, G_3, G_4, G_5$, each of size $5$, in the array order.\n- Within each $G_i$, the median (the third smallest element of the group) must be well-defined and distinct across groups.\n- The median-of-medians pivot $p$ must be the median of the five group medians, obtained by sorting the five medians and taking the third smallest.\n\nDesign $A$ so that, after partitioning around $p$, the number of elements strictly less than $p$ is minimized while still satisfying the guarantees implied by the algorithm’s grouping and pivot selection, and the remaining elements are placed adversarially to maximize the size of the larger recursive subarray. Explicitly provide the five groups $G_1, G_2, G_3, G_4, G_5$ you constructed, and justify that the median-of-medians pivot is indeed $p$ as intended.\n\nFinally, compute the exact size of the larger recursive subarray that results from your construction after the partition step around $p$. Report only this size as your final numerical answer. Your numerical answer should be exact; do not round.",
            "solution": "The problem as stated is formally sound, self-contained, and grounded in the established principles of algorithm analysis within computer science. It poses a well-defined question about the worst-case behavior of the median-of-medians selection algorithm under specific parameters. The problem is therefore valid, and a rigorous solution can be constructed.\n\nThe objective is to construct an array $A$ of $n=25$ distinct integers that, when processed by the median-of-medians algorithm with a group size of $5$, maximizes the size of the larger of the two subarrays for the recursive call. This corresponds to finding an adversarial input that forces the most unbalanced partition allowed by the algorithm's guarantees.\n\nThe algorithm proceeds as follows:\n1.  The input array $A$ of size $n=25$ is divided into $\\lceil n/5 \\rceil = \\lceil 25/5 \\rceil = 5$ contiguous groups, $G_1, G_2, G_3, G_4, G_5$, each of size $5$.\n2.  For each group $G_i$, its median $m_i$ is computed. This results in a set of $5$ medians, $\\{m_1, m_2, m_3, m_4, m_5\\}$.\n3.  The algorithm finds the median of these medians, which we denote as the pivot $p$. This is done by sorting the medians and selecting the middle element.\n4.  The original array $A$ is partitioned around the pivot $p$ into two subarrays: one containing elements strictly less than $p$ and another containing elements strictly greater than $p$.\n5.  The algorithm recurses on the subarray that contains the desired order statistic.\n\nTo maximize the size of the larger recursive subarray, we must make the partition as lopsided as possible. Let us analyze the theoretical bounds on the partition sizes. Let the set of medians be $M = \\{m_1, m_2, m_3, m_4, m_5\\}$. Let the sorted medians be $m_{(1)} \\le m_{(2)} \\le m_{(3)} \\le m_{(4)} \\le m_{(5)}$. The pivot is $p = m_{(3)}$.\n\nConsider the number of elements guaranteed to be less than or equal to $p$:\n- There are $\\lceil 5/2 \\rceil = 3$ medians less than or equal to $p$, namely $m_{(1)}$, $m_{(2)}$, and $p=m_{(3)}$.\n- For each of these $3$ medians, the median itself and the two smaller elements within its group are less than or equal to that median. Since each of these $3$ medians is less than or equal to $p$, the corresponding $3 \\times 3 = 9$ elements are all less than or equal to $p$.\n- As all elements of the array $A$ are distinct, these $9$ elements are distinct. Thus, there are at least $9$ elements in $A$ that are less than or equal to $p$. This implies that the number of elements strictly less than $p$ is at least $9 - 1 = 8$.\n\nConsider the number of elements guaranteed to be greater than or equal to $p$:\n- By a symmetric argument, there are $\\lceil 5/2 \\rceil = 3$ medians greater than or equal to $p$, namely $p=m_{(3)}$, $m_{(4)}$, and $m_{(5)}$.\n- For each of these $3$ groups, the median and the two larger elements are greater than or equal to that median. These $3 \\times 3 = 9$ elements are therefore all greater than or equal to $p$.\n- This guarantees that the number of elements strictly greater than $p$ is at least $8$.\n\nThe partition of $A$ around $p$ yields a subarray of elements smaller than $p$, of size $|S_|$, and a subarray of elements larger than $p$, of size $|S_|$. We have $|S_| \\ge 8$ and $|S_| \\ge 8$. Since $|S_| + |S_| = n-1 = 24$, if one side is minimized, the other is maximized. The minimum size for either partition is $8$. If $|S_|=8$, then $|S_| = 24 - 8 = 16$. If $|S_|=8$, then $|S_|=16$. In either case, the maximum possible size for the larger recursive subarray is $16$.\n\nWe now construct an explicit array $A$ that achieves this $8/16$ split. We will use the distinct integers from $1$ to $25$. To create the most unbalanced partition, we will design the groups such that the number of elements strictly less than the pivot $p$ is minimized to $8$. This forces the pivot to be $p=9$.\n\nLet the five groups be $G_1, G_2, G_3, G_4, G_5$. We construct them as follows:\n\n-   Let two groups, say $G_1$ and $G_2$, have medians less than $p=9$. To minimize the number of small elements, we pack them with large elements where possible.\n    -   $G_1 = \\{13, 1, 5, 12, 2\\}$: The sorted elements are $\\{1, 2, 5, 12, 13\\}$. The median is $m_1 = 5$. The elements $\\{1, 2, 5\\}$ are less than $p=9$. The elements $\\{12, 13\\}$ are greater than $p=9$.\n    -   $G_2 = \\{15, 3, 6, 14, 4\\}$: The sorted elements are $\\{3, 4, 6, 14, 15\\}$. The median is $m_2 = 6$. The elements $\\{3, 4, 6\\}$ are less than $p=9$. The elements $\\{14, 15\\}$ are greater than $p=9$.\n\n-   Let one group, say $G_3$, have the pivot $p=9$ as its median.\n    -   $G_3 = \\{11, 7, 9, 10, 8\\}$: The sorted elements are $\\{7, 8, 9, 10, 11\\}$. The median is $m_3 = 9$. The elements $\\{7, 8\\}$ are less than $p=9$. The element $9$ is the pivot. The elements $\\{10, 11\\}$ are greater than $p=9$.\n\n-   Let the remaining two groups, $G_4$ and $G_5$, have medians greater than $p=9$. To create the adversarial case, all elements in these groups must be greater than $p=9$.\n    -   $G_4 = \\{18, 16, 20, 17, 19\\}$: The sorted elements are $\\{16, 17, 18, 19, 20\\}$. The median is $m_4 = 18$. All $5$ elements are greater than $p=9$.\n    -   $G_5 = \\{23, 21, 25, 22, 24\\}$: The sorted elements are $\\{21, 22, 23, 24, 25\\}$. The median is $m_5 = 23$. All $5$ elements are greater than $p=9$.\n\nJustification of the pivot:\nThe set of medians is $M = \\{m_1, m_2, m_3, m_4, m_5\\} = \\{5, 6, 9, 18, 23\\}$.\nThe median of this set is the $3$rd element in the sorted list $(5, 6, 9, 18, 23)$, which is $9$. Therefore, the pivot selected by the algorithm is indeed $p=9$, as intended by the construction.\n\nPartitioning around $p=9$:\nThe full array $A$ consists of the concatenation of these groups. The set of all integers in $A$ is $\\{1, 2, \\dots, 25\\}$.\n-   The elements of $A$ strictly less than $p=9$ are: $\\{1, 2, 5\\}$ from $G_1$; $\\{3, 4, 6\\}$ from $G_2$; and $\\{7, 8\\}$ from $G_3$. This gives the set $\\{1, 2, 3, 4, 5, 6, 7, 8\\}$. The size of this subarray is $8$.\n-   The elements of $A$ strictly greater than $p=9$ are: $\\{12, 13\\}$ from $G_1$; $\\{14, 15\\}$ from $G_2$; $\\{10, 11\\}$ from $G_3$; $\\{16, 17, 18, 19, 20\\}$ from $G_4$; and $\\{21, 22, 23, 24, 25\\}$ from $G_5$. This gives the set $\\{10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25\\}$. The size of this subarray is $16$.\n\nThe two recursive subproblems would have sizes $8$ and $16$. The larger of these two has size $16$. Our construction has successfully produced the maximally unbalanced partition.\n\nThe size of the larger recursive subarray is therefore $16$.",
            "answer": "$$\\boxed{16}$$"
        },
        {
            "introduction": "A true test of understanding is the ability to extend a concept to solve new problems. This final practice challenges you to modify the selection algorithm to find two order statistics simultaneously, specifically the elements at ranks $\\lfloor n/3 \\rfloor$ and $\\lfloor 2n/3 \\rfloor$. This requires a deeper analysis of the recursive logic and proves that the linear-time guarantee holds even for more complex queries, showcasing the power and flexibility of the median-of-medians approach .",
            "id": "3250832",
            "problem": "You are to design and implement a deterministic \"dual-pivot\" selection algorithm that, using the median-of-medians approach, finds two pivot values corresponding to the $\\lfloor n/3 \\rfloor$-th and $\\lfloor 2n/3 \\rfloor$-th order statistics (under $0$-based indexing) of an input array of integers, and then uses these pivots to perform a $3$-way partition. The algorithm must be derived from foundational principles and analyzed for worst-case time complexity.\n\nDefinitions and foundational base:\n- The $k$-th order statistic of a multiset of $n$ integers (under $0$-based indexing) is the value that would appear at array index $k$ if the multiset were sorted in nondecreasing order. Equivalently, it is the $(k+1)$-th smallest element under $1$-based indexing.\n- A selection algorithm operates in the comparison model of computation, where primitive operations are comparisons and constant-time data movement.\n- The median-of-medians selection paradigm (Blum–Floyd–Pratt–Rivest–Tarjan) ensures that a pivot chosen as the median of medians of groups of fixed size reduces the problem size by a constant fraction at each recursive step in the worst case, enabling linear-time selection.\n\nYour tasks:\n1. Starting from the definition of order statistics and the comparison model, design a deterministic selection algorithm using the median-of-medians technique (with fixed group size $5$) to find simultaneously two pivots with ranks $k_1 = \\lfloor n/3 \\rfloor$ and $k_2 = \\lfloor 2n/3 \\rfloor$ under $0$-based indexing. Your algorithm must:\n   - Construct a pivot via the median-of-medians approach.\n   - Partition the input into three disjoint subsets $L$, $E$, and $G$, where $L = \\{x \\mid x  p\\}$, $E = \\{x \\mid x = p\\}$, and $G = \\{x \\mid x  p\\}$ for pivot $p$.\n   - Recursively determine both order statistics by descending only into the necessary partitions based on $k_1$ and $k_2$ positions relative to $\\lvert L \\rvert$ and $\\lvert E \\rvert$.\n   - Return the pair $(p_1, p_2)$ such that $p_1$ equals the element at sorted index $k_1$ and $p_2$ equals the element at sorted index $k_2$; ensure $p_1 \\le p_2$ always holds.\n\n2. Using the returned pivots $(p_1, p_2)$, perform a three-way partition of the input array into:\n   - $S_{\\text{low}} = \\{x \\mid x  p_1\\}$,\n   - $S_{\\text{mid}} = \\{x \\mid p_1 \\le x \\le p_2\\}$,\n   - $S_{\\text{high}} = \\{x \\mid x  p_2\\}$.\n   In the special case $p_1 = p_2$, $S_{\\text{mid}}$ contains all elements equal to this common pivot, and the partition remains well-defined.\n\n3. Analyze the worst-case time complexity of your dual-pivot median-of-medians selection. Derive a recurrence using the following well-tested facts:\n   - Grouping into size $5$ and selecting the median-of-medians $p$ guarantees that at least a constant fraction of elements are strictly less than $p$, and at least a constant fraction are strictly greater than $p$.\n   - The single-pivot selection recurrence of median-of-medians with group size $5$ satisfies a worst-case linear bound.\n   Extend the recurrence to the dual-pivot case, noting that in the worst case you might recurse into both sides after one partition, and argue linearity from first principles.\n\nImplementation requirements:\n- Implement the algorithm in Python and ensure determinism by avoiding any randomness in the selection logic.\n- The program must not read input; it must run with an internal test suite defined as follows.\n\nTest suite:\n- Test case $1$: $A_1 = \\{12, 7, 3, 9, 20, -5, 0, 13, 13, 2, 2, 2, 8, 8, 8, 100, -100, 50, 50, 50\\}$.\n- Test case $2$: $A_2 = \\{5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5\\}$.\n- Test case $3$: $A_3 = \\{9, -1\\}$.\n- Test case $4$: $A_4 = \\{-4, -4, -1, 0, 0, 3, 7, 7, 9, 15, 15\\}$.\n- Test case $5$: $A_5$ is a length $101$ array of integers deterministically generated with seed $42$, each entry drawn uniformly from $\\{-1000, -999, \\ldots, 999, 1000\\}$.\n- Test case $6$: $A_6 = \\{9, 8, 7, 6, 5, 4, 3, 2, 1\\}$.\n\nFor each test case $i$ with array $A_i$ of length $n_i$, define $k_1^{(i)} = \\lfloor n_i/3 \\rfloor$ and $k_2^{(i)} = \\lfloor 2n_i/3 \\rfloor$. The program must compute the pair $(p_1^{(i)}, p_2^{(i)})$, perform the prescribed $3$-way partition with these pivots, and produce for each case a result list containing:\n- The two pivot values $p_1^{(i)}$ and $p_2^{(i)}$,\n- A boolean indicating that $p_1^{(i)}$ equals the element at sorted index $k_1^{(i)}$ and $p_2^{(i)}$ equals the element at sorted index $k_2^{(i)}$,\n- A boolean indicating that the partition satisfies the three inequalities for all elements placed in $S_{\\text{low}}$, $S_{\\text{mid}}$, and $S_{\\text{high}}$ respectively.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case and is itself a list in the format $[p_1, p_2, \\text{is\\_correct}, \\text{partition\\_valid}]$. No additional text or whitespace should be printed.",
            "solution": "The problem requires the design, analysis, and implementation of a deterministic algorithm to find two order statistics, specifically those at ranks $k_1 = \\lfloor n/3 \\rfloor$ and $k_2 = \\lfloor 2n/3 \\rfloor$, from an array of $n$ integers. This simultaneous selection must be accomplished using the median-of-medians paradigm. Subsequently, these two statistics, denoted as pivots $(p_1, p_2)$, are used to perform a 3-way partition of the input array.\n\n### 1. Algorithm Design: Dual-Pivot Median-of-Medians Selection\n\nThe core of the assignment is to devise an algorithm for finding two order statistics, $p_1$ and $p_2$, simultaneously. A naive approach would be to call a linear-time selection algorithm twice, once for each rank. While this is correct and maintains an overall linear time complexity, the problem asks for a more integrated, \"simultaneous\" recursive approach. We will build this dual-selection algorithm on top of the established single-selection median-of-medians algorithm.\n\n#### 1.1. Foundational Single-Element Selection (`select`)\n\nThe median-of-medians algorithm (Blum-Floyd-Pratt-Rivest-Tarjan) provides a method for finding the $k$-th order statistic of an array in worst-case linear time, $O(n)$. It operates as follows on an array (or subarray) of size $n$:\n1.  **Divide**: The $n$ elements are divided into $\\lceil n/g \\rceil$ groups of size $g$ (the last group may be smaller). The problem specifies a group size $g=5$.\n2.  **Conquer (Median Finding)**: For each of the $\\lceil n/5 \\rceil$ groups, its median is found. Since each group has at most $5$ elements, finding its median takes constant time (e.g., by sorting the group). This step takes $O(n)$ time in total.\n3.  **Combine (Pivot Selection)**: The algorithm is called recursively on the list of $\\lceil n/5 \\rceil$ medians to find their true median. This element is chosen as the pivot, $p$.\n4.  **Partition**: The entire array of $n$ elements is partitioned around the pivot $p$ into three sets: $L = \\{x \\mid x  p\\}$, $E = \\{x \\mid x = p\\}$, and $G = \\{x \\mid x  p\\}$. This step takes $O(n)$ time.\n5.  **Recurse**: Let the sizes of the partitions be $|L|$, $|E|$, and $|G|$.\n    - If the target rank $k$ falls within $L$ (i.e., $k  |L|$), the algorithm recurses on $L$ to find the $k$-th statistic.\n    - If $k$ falls within $G$ (i.e., $k \\ge |L| + |E|$), the algorithm recurses on $G$ to find the $(k - |L| - |E|)$-th statistic.\n    - If $k$ falls within $E$, the pivot $p$ is the desired element, and the algorithm terminates.\n\nA crucial property of using groups of size $5$ is that the pivot $p$ is guaranteed to be greater than or equal to at least $3(\\lceil \\frac{1}{2}\\lceil n/5 \\rceil \\rceil - 2)$ elements and smaller than or equal to at least this many. For large $n$, this is approximately $3n/10$ elements. Consequently, the recursive subproblem size is at most about $7n/10$, which guarantees linear-time performance.\n\n#### 1.2. Simultaneous Dual-Element Selection (`dual_select`)\n\nWe now extend this logic to find two order statistics with ranks $k_1 = \\lfloor n/3 \\rfloor$ and $k_2 = \\lfloor 2n/3 \\rfloor$. The algorithm, which we'll call `dual_select(A, k1, k2)`, operates on an array `A` (or a subarray represented by indices) and the target ranks `k1` and `k2` relative to that array.\n\n1.  **Base Case**: If the array size $n$ is small (e.g., $n \\le 10$), sort the array and return the elements at indices $k_1$ and $k_2$.\n2.  **Pivot Selection**: As in the single-selection algorithm, find a pivot $p$ using the median-of-medians method with group size $5$. This involves a recursive call to the `select` algorithm on the list of group medians.\n3.  **Partition**: Partition the array around pivot $p$ into $L$, $E$, and $G$. Let their sizes be $n_L = |L|$ and $n_E = |E|$. Let the partitions be defined by index ranges.\n4.  **Recursive Case Analysis**: The key step is to determine where the ranks $k_1$ and $k_2$ fall relative to the partitions.\n    - **Case 1: Both ranks in $L$**. If $k_2  n_L$, both desired elements are in the 'less than' partition. We perform a single recursive call: `dual_select(L, k1, k2)`.\n    - **Case 2: Both ranks in $G$**. If $k_1 \\ge n_L + n_E$, both elements are in the 'greater than' partition. We recurse: `dual_select(G, k1 - (n_L + n_E), k2 - (n_L + n_E))`. Here, the ranks must be adjusted relative to the start of $G$.\n    - **Case 3: Ranks split between $L$ and $G$**. If $k_1  n_L$ and $k_2 \\ge n_L + n_E$, one element is in $L$ and the other is in $G$. The problem decouples into two independent single-selection problems. We solve them with two separate calls:\n        - $p_1 = \\text{select}(L, k_1)$\n        - $p_2 = \\text{select}(G, k_2 - (n_L + n_E))$\n    - **Case 4: Ranks split between other partitions**. Other combinations exist: one rank in $L$ and one in $E$; one in $E$ and one in $G$; both in $E$.\n        - If $k_1  n_L$ and $n_L \\le k_2  n_L + n_E$, then $p_2=p$. We find $p_1$ by a single call: $p_1 = \\text{select}(L, k_1)$.\n        - If $n_L \\le k_1  n_L + n_E$ and $k_2 \\ge n_L + n_E$, then $p_1=p$. We find $p_2$ by a single call: $p_2 = \\text{select}(G, k_2 - (n_L + n_E))$.\n        - If $n_L \\le k_1 \\le k_2  n_L + n_E$, then both ranks fall in the 'equal' partition, so $p_1 = p_2 = p$.\n\nThe algorithm returns the pair $(p_1, p_2)$ where $p_1$ is the $k_1$-th statistic and $p_2$ is the $k_2$-th statistic. Since $k_1 \\le k_2$ by definition, it will follow that $p_1 \\le p_2$.\n\n### 2. Algorithm Design: 3-Way Partitioning with Two Pivots\n\nGiven the two pivots $(p_1, p_2)$ with $p_1 \\le p_2$, the task is to partition the original array into three sets: $S_{\\text{low}} = \\{x \\mid x  p_1\\}$, $S_{\\text{mid}} = \\{x \\mid p_1 \\le x \\le p_2\\}$, and $S_{\\text{high}} = \\{x \\mid x  p_2\\}$.\nThis can be accomplished in-place in linear time, $O(n)$, using a modification of the Dutch National Flag problem's solution. We maintain three pointers, `i`, `j`, and `k`, that delimit the three partitions being built.\n\n- `A[0...i-1]` holds elements in $S_{\\text{low}}$.\n- `A[i...j-1]` holds elements in $S_{\\text{mid}}$.\n- `A[j...k]` is the unprocessed section of the array.\n- `A[k+1...n-1]` holds elements in $S_{\\text{high}}$.\n\nInitially, $i=0$, $j=0$, and $k=n-1$. We iterate by advancing $j$ as long as $j \\le k$:\n- If $A[j]  p_1$: Swap $A[i]$ with $A[j]$, then increment both $i$ and $j$.\n- If $A[j]  p_2$: Swap $A[j]$ with $A[k]$, then decrement $k$. We do not increment $j$ as the new element at `A[j]` must be processed.\n- If $p_1 \\le A[j] \\le p_2$: The element is in its correct partition, so we just increment $j$.\n\nThe process terminates when $j$ surpasses $k$, at which point the array is fully partitioned.\n\n### 3. Worst-Case Time Complexity Analysis\n\nLet $T_{dual}(n)$ be the worst-case time complexity for finding two order statistics in an array of size $n$, and $T_{select}(n)$ be the time for one statistic. We know from existing analysis that $T_{select}(n) = O(n)$. The recurrence for $T_{select}(n)$ with group size $5$ is approximately $T_{select}(n) \\le T_{select}(n/5) + T_{select}(7n/10) + O(n)$, which solves to $O(n)$.\n\nThe `dual_select` algorithm involves the following costs at each step:\n1.  Pivot selection: This requires running `select` on $\\lceil n/5 \\rceil$ medians, which takes $T_{select}(\\lceil n/5 \\rceil) = O(n/5) = O(n)$ time.\n2.  Partitioning: This takes $O(n)$ time.\n3.  Recursive calls: This is the dominant factor. The worst case for recursion occurs when the ranks $k_1$ and $k_2$ fall into different, large subproblems. The median-of-medians pivot guarantees that the sizes of partitions $L$ and $G$ are at most $\\approx \\frac{7}{10}n$.\n    - If the recursion is a single call to `dual_select` on a subproblem of size at most $\\frac{7}{10}n$, the recurrence is $T_{dual}(n) \\le T_{dual}(7n/10) + O(n)$. By the Master Theorem, this solves to $T_{dual}(n) = O(n)$.\n    - If the recursion splits into two independent `select` calls on partitions $L$ and $G$ (Case 3), the cost is $T_{select}(|L|) + T_{select}(|G|)$. Since $|L| \\le \\frac{7}{10}n$, $|G| \\le \\frac{7}{10}n$, and $|L|+|G|  n$, and we know $T_{select}(m) = c \\cdot m$ for some constant $c$, the recursive cost is $c|L| + c|G| = c(|L|+|G|)  c \\cdot n$.\n\nIn all scenarios, the work at each level of recursion is linear in the size of the current array. The total cost is therefore described by a recurrence that sums to a linear function of $n$.\n$$ T_{dual}(n) \\le O(n) + \\max(T_{dual}(\\frac{7n}{10}+\\text{const}), T_{select}(\\frac{7n}{10}+\\text{const}) + T_{select}(\\frac{7n}{10}+\\text{const})) $$\nBoth cases within the max lead to an overall $O(n)$ complexity. The cost of `dual_select` is dominated by the linear-time operations at each step (pivot finding, partitioning) and recursive calls on problems whose total size is a constant fraction smaller than $n$. Thus, the `dual_select` algorithm has a worst-case time complexity of $O(n)$. The final 3-way partitioning step is also $O(n)$, so the entire procedure is linear.",
            "answer": "```python\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the dual-pivot selection algorithm.\n    \"\"\"\n\n    # --- Helper functions for selection and partitioning ---\n\n    def _partition3way(arr, left, right, pivot_val):\n        \"\"\"3-way partition an array slice in-place around a pivot value.\"\"\"\n        lt, i, gt = left, left, right\n        while i = gt:\n            if arr[i]  pivot_val:\n                arr[lt], arr[i] = arr[i], arr[lt]\n                lt += 1\n                i += 1\n            elif arr[i]  pivot_val:\n                arr[gt], arr[i] = arr[i], arr[gt]\n                gt -= 1\n            else: # arr[i] == pivot_val\n                i += 1\n        return lt, gt\n\n    def _select(arr, left, right, k):\n        \"\"\"\n        Finds the k-th order statistic in arr[left...right] using median-of-medians.\n        k is the 0-based rank within the slice.\n        The implementation may use an auxiliary array for medians for simplicity,\n        while maintaining the core logic and complexity.\n        \"\"\"\n        while True:\n            n = right - left + 1\n            if n = 5:\n                # For small subarrays, sort and pick the element.\n                sub_arr = sorted(arr[left:right+1])\n                return sub_arr[k]\n\n            # 1. Divide into groups of 5 and find medians.\n            num_medians = math.ceil(n / 5)\n            medians = []\n            for i in range(num_medians):\n                start = left + i * 5\n                end = min(start + 4, right)\n                group = sorted(arr[start:end+1])\n                medians.append(group[len(group)//2])\n\n            # 2. Find the median of medians as the pivot.\n            pivot_val = _select(medians, 0, len(medians) - 1, len(medians) // 2)\n\n            # 3. Partition the array around the pivot.\n            lt, gt = _partition3way(arr, left, right, pivot_val)\n\n            # 4. Recurse into the correct partition.\n            len_L = lt - left\n            len_E = gt - lt + 1\n\n            if k  len_L:\n                right = lt - 1\n            elif k  len_L + len_E:\n                return pivot_val\n            else:\n                left = gt + 1\n                k = k - (len_L + len_E)\n\n    def dual_select(arr, left, right, k1, k2):\n        \"\"\"\n        Simultaneously finds two order statistics (ranks k1, k2) in arr[left...right].\n        \"\"\"\n        while True:\n            n = right - left + 1\n            if n = 10: # Base case for small arrays\n                sub_arr = sorted(arr[left:right+1])\n                return sub_arr[k1], sub_arr[k2]\n\n            # 1. Select pivot using median-of-medians.\n            num_medians = math.ceil(n / 5)\n            medians = []\n            for i in range(num_medians):\n                start = left + i * 5\n                end = min(start + 4, right)\n                group = sorted(arr[start:end+1])\n                medians.append(group[len(group)//2])\n            pivot_val = _select(medians, 0, len(medians) - 1, len(medians) // 2)\n\n            # 2. Partition around the pivot.\n            lt, gt = _partition3way(arr, left, right, pivot_val)\n\n            # 3. Analyze partitions and recurse or solve.\n            len_L = lt - left\n            len_E = gt - lt + 1\n            \n            p1, p2 = None, None\n\n            # Determine where k1 and k2 fall.\n            k1_in_L = k1  len_L\n            k1_in_E = len_L = k1  len_L + len_E\n            k1_in_G = k1 = len_L + len_E\n\n            k2_in_L = k2  len_L\n            k2_in_E = len_L = k2  len_L + len_E\n            k2_in_G = k2 = len_L + len_E\n\n            if k1_in_L and k2_in_L: # Case 1: Both in L\n                right = lt - 1\n                continue # Recurse on dual_select\n            elif k1_in_G and k2_in_G: # Case 2: Both in G\n                k1 -= (len_L + len_E)\n                k2 -= (len_L + len_E)\n                left = gt + 1\n                continue # Recurse on dual_select\n            elif k1_in_E and k2_in_E: # Both in E\n                return pivot_val, pivot_val\n            elif k1_in_L and k2_in_G: # Case 3: Split L/G\n                p1 = _select(arr, left, lt - 1, k1)\n                p2 = _select(arr, gt + 1, right, k2 - (len_L + len_E))\n                return p1, p2\n            elif k1_in_L and k2_in_E: # Split L/E\n                p1 = _select(arr, left, lt - 1, k1)\n                return p1, pivot_val\n            elif k1_in_E and k2_in_G: # Split E/G\n                p2 = _select(arr, gt + 1, right, k2 - (len_L + len_E))\n                return pivot_val, p2\n            # The logic exhaustively covers all partitions of (k1, k2)\n            # across (L, E, G). The case of L/E, E/G above handles combinations\n            # not caught by the primary three cases.\n            # e.g., if k1  len_L and len_L = k2  len_L + len_E, this is handled by `k1_in_L` and `k2_in_E`.\n\n    def three_way_partition_final(arr, p1, p2):\n        \"\"\"Partitions array `arr` in-place based on two pivots p1 and p2.\"\"\"\n        i, j, k = 0, 0, len(arr) - 1\n        while j = k:\n            if arr[j]  p1:\n                arr[i], arr[j] = arr[j], arr[i]\n                i += 1\n                j += 1\n            elif arr[j]  p2:\n                arr[k], arr[j] = arr[j], arr[k]\n                k -= 1\n            else: # p1 = arr[j] = p2\n                j += 1\n        return arr, i, k + 1\n\n    # --- Test Suite ---\n    test_cases_data = [\n        [12, 7, 3, 9, 20, -5, 0, 13, 13, 2, 2, 2, 8, 8, 8, 100, -100, 50, 50, 50],\n        [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],\n        [9, -1],\n        [-4, -4, -1, 0, 0, 3, 7, 7, 9, 15, 15],\n        list(np.random.default_rng(42).integers(-1000, 1001, size=101)),\n        [9, 8, 7, 6, 5, 4, 3, 2, 1],\n    ]\n\n    results = []\n    for test_array in test_cases_data:\n        n = len(test_array)\n        if n == 0:\n            results.append(\"[]\")\n            continue\n        \n        k1 = n // 3\n        k2 = (2 * n) // 3\n        \n        # Run the dual selection algorithm on a copy of the array\n        arr_copy = list(test_array)\n        p1, p2 = dual_select(arr_copy, 0, n - 1, k1, k2)\n\n        # Verification of p1 and p2\n        sorted_arr = sorted(test_array)\n        is_correct = (p1 == sorted_arr[k1] and p2 == sorted_arr[k2])\n\n        # Perform and verify the final 3-way partition\n        part_arr = list(test_array)\n        _, low_boundary, high_boundary = three_way_partition_final(part_arr, p1, p2)\n        \n        partition_valid = True\n        for i in range(len(part_arr)):\n            if i  low_boundary and not (part_arr[i]  p1):\n                partition_valid = False\n                break\n            if low_boundary = i  high_boundary and not (p1 = part_arr[i] = p2):\n                partition_valid = False\n                break\n            if i = high_boundary and not (part_arr[i]  p2):\n                partition_valid = False\n                break\n        \n        # Ensure p1 = p2 for consistent output, though correctness check covers it\n        if p1  p2:\n            p1, p2 = p2, p1\n\n        result_str = f\"[{p1},{p2},{is_correct},{partition_valid}]\"\n        results.append(result_str)\n\n    # Print the final output in the required format\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}