{
    "hands_on_practices": [
        {
            "introduction": "在许多实际应用中，序列中的元素值可能非常大，例如用户ID或高精度时间戳，这使得依赖数值本身大小的算法变得不切实际。本练习将引导你掌握一种关键的优化技巧——坐标离散化，它能将问题转化到更易于处理的紧凑整数域上。你将在此基础上，实践经典的基于二分搜索的 $O(n \\log n)$ 算法，高效求解最长递增子序列的长度，并分析该方法在不同数据分布下的性能表现。",
            "id": "3247924",
            "problem": "考虑一个有限整数序列 $A = (A_1, A_2, \\dots, A_n)$，其中每个 $A_i$ 的值可以高达 $10^{18}$。最长递增子序列（LIS）定义为子序列 $A_{i_1}  A_{i_2}  \\dots  A_{i_k}$（其中 $1 \\le i_1  i_2  \\dots  i_k \\le n$）的最大长度。此任务必须通过使用 $A$ 的坐标压缩表示来实现，以避免对值的绝对大小产生任何依赖。基本原理包括严格递增子序列的定义，以及一个观察：对值域进行保序转换不会改变元素之间的不等关系。\n\n您的目标是：\n- 推导为什么用其坐标压缩序列 $C$ 替换 $A$ 会保持 LIS 长度不变。形式上，从 $A$ 中不同值的排序集合到从 $0$ 开始的连续整数，构造一个严格递增的映射 $f$，并令 $C_i = f(A_i)$。解释为什么对于所有 $i,j$，当且仅当 $A_{i}  A_{j}$ 时，有 $C_{i}  C_{j}$，因此 LIS 长度在此转换下保持不变。\n- 实现一个算法，在压缩序列上使用基于二分搜索的最小结尾构造法来计算 LIS 长度。维护一个 `tails` 数组，其中 `tails[\\ell]` 存储在压缩域中任何长度为 $\\ell+1$ 的严格递增子序列的最小可能结尾值。对于每个 $C_i$，在 `tails` 上执行二分搜索，找到第一个满足 `tails[\\ell] >= C_i` 的索引 $\\ell$，并用 $C_i$ 替换它；如果不存在这样的 $\\ell$，则追加 $C_i$。计算所有二分搜索内部执行的元素间比较的总次数；将一次比较定义为对形如 `tails[m] >= C_i` 的谓词求值，其中 `m` 是二分搜索中的中间点索引。\n- 分析值稀疏与稠密时的边界情况，并阐明压缩如何通过影响 `tails` 数组的演变长度来影响二分搜索的步数。您的程序必须为每个测试用例报告 LIS 长度和所有二分搜索内部执行的比较累积次数。\n\n使用以下测试用例集，这些测试用例旨在覆盖正常路径、边界条件和重要的边缘情况（稀疏与稠密、重复值、单调序列和空输入）。对于每种情况，序列明确给出：\n1. 稀疏高值交错：$[10^{18}-3,\\;1,\\;10^{18}-2,\\;2,\\;10^{18}-1,\\;3]$。\n2. 稠密小幅递增：$[1,\\;2,\\;3,\\;4,\\;5,\\;6,\\;7,\\;8,\\;9]$。\n3. 所有值相等（大数）：$[10^{18},\\;10^{18},\\;10^{18},\\;10^{18},\\;10^{18}]$。\n4. 严格递减（大数）：$[10^{18},\\;10^{18}-1,\\;10^{18}-2,\\;10^{18}-3,\\;10^{18}-4,\\;10^{18}-5,\\;10^{18}-6,\\;10^{18}-7]$。\n5. 交替重复与增长：$[10^{18}-5,\\;5,\\;10^{18}-5,\\;6,\\;10^{18}-4,\\;7,\\;10^{18}-3,\\;8]$。\n6. 大数值附近的稠密重复：$[10^{18}-10,\\;10^{18}-9,\\;10^{18}-9,\\;10^{18}-8,\\;10^{18}-7,\\;10^{18}-7,\\;10^{18}-6,\\;10^{18}-5]$。\n7. 边界情况空序列：$[]$。\n\n对于每个测试用例 $A$，所需的输出是：\n- LIS 长度，一个整数。\n- 所有二分搜索中的总比较次数，一个整数。\n\n您的程序应生成单行输出，包含一个由方括号括起来的逗号分隔列表，其中每个测试用例的结果本身是一个双元素列表 $[\\text{lis\\_length},\\;\\text{comparison\\_count}]$。例如，包含两个测试用例的输出将类似于 $[[3,7],[5,9]]$。不涉及物理单位、角度或百分比；所有输出均为整数。",
            "solution": "该问题被评估为有效。这是一个定义明确的算法问题，基于已建立的计算机科学原理，特别是关于最长递增子序列（LIS）和坐标压缩。该问题是自包含的，提供了所有必要的定义、约束和测试用例。目标清晰且可形式化。\n\n### 1. 坐标压缩下 LIS 长度的不变性\n\n问题的核心是计算一个整数序列 $A = (A_1, A_2, \\dots, A_n)$ 的最长递增子序列（LIS）。$A_i$ 的值可能非常大，高达 $10^{18}$，但它们的绝对大小无关紧要；只有它们的相对顺序对确定递增子序列有影响。这一性质是使用坐标压缩的基础。\n\n设 $V$ 为序列 $A$ 中出现的唯一值的集合。我们可以对这些唯一值进行排序，得到一个有序集合 $v_1  v_2  \\dots  v_m$，其中 $m \\le n$ 是唯一元素的数量。\n\n坐标压缩是定义一个映射 $f$ 的过程，该映射将 $A$ 中的原始值转换为一个更小的、连续的整数范围。我们定义映射 $f: \\{v_1, \\dots, v_m\\} \\to \\{0, 1, \\dots, m-1\\}$ 如下：\n$$f(v_j) = j-1$$\n此函数将最小的唯一值 $v_1$ 映射到 $0$，第二小的值 $v_2$ 映射到 $1$，依此类推。函数 $f$ 是严格递增的，因为如果 $v_j  v_k$，那么根据它们的排序顺序，索引 $j$ 必须小于 $k$，这意味着 $f(v_j) = j-1  k-1 = f(v_k)$。\n\n然后通过将此映射应用于 $A$ 的每个元素来构造压缩序列 $C$：\n$$C_i = f(A_i) \\quad \\text{for } i=1, \\dots, n$$\n\n现在我们必须证明 LIS 长度在此转换下是不变的。这需要证明任何两个元素的相对顺序被保留。也就是说，对于任何索引 $i$ 和 $j$：\n$$A_i  A_j \\iff C_i  C_j$$\n\n**证明：**\n1.  **正向（$\\implies$）：** 假设 $A_i  A_j$。由于 $A_i$ 和 $A_j$ 是来自唯一值集合 $V$ 的元素，设 $A_i = v_p$ 和 $A_j = v_q$，其中 $p, q \\in \\{1, \\dots, m\\}$。条件 $A_i  A_j$ 意味着 $v_p  v_q$。因为值 $v_k$ 是排序的，这意味着它们的索引必须满足 $p  q$。根据我们的映射 $f$ 的定义，我们有 $C_i = f(A_i) = f(v_p) = p-1$ 和 $C_j = f(A_j) = f(v_q) = q-1$。因为 $p  q$，所以 $p-1  q-1$，因此 $C_i  C_j$。\n\n2.  **反向（$\\impliedby$）：** 假设 $C_i  C_j$。根据 $C$ 的定义，这意味着 $f(A_i)  f(A_j)$。由于映射 $f$ 是严格递增的，其逆映射 $f^{-1}$ 也必须是严格递增的。将 $f^{-1}$ 应用于不等式 $f(A_i)  f(A_j)$ 的两边，得到 $f^{-1}(f(A_i))  f^{-1}(f(A_j))$，化简为 $A_i  A_j$。\n\n由于任何一对元素的严格不等关系都被保留，一个子序列 $(A_{i_1}, A_{i_2}, \\dots, A_{i_k})$ 是严格递增的，当且仅当相应的压缩子序列 $(C_{i_1}, C_{i_2}, \\dots, C_{i_k})$ 是严格递增的。因此，$A$ 中所有递增子序列的集合与 $C$ 中所有递增子序列的集合存在一一对应关系。这证明了最长递增子序列的长度在坐标压缩下是不变的。\n\n### 2. 算法实现\n\n压缩序列 $C$ 的 LIS 可以在 $O(n \\log n)$ 时间内高效计算。该算法维护一个辅助数组，我们称之为 `tails`。`tails` 数组存储了给定长度的所有递增子序列的最小结尾（最后一个元素）。具体来说，`tails[k]` 将保存可以终止长度为 $k+1$ 的递增子序列的最小值。根据构造，`tails` 数组将始终按递增顺序排序。\n\n算法流程如下：\n1.  初始化一个空列表 `tails` 和一个比较计数器 `total_comparisons = 0`。\n2.  对于压缩序列 $C$ 中的每个元素 $c$：\n    a. 在 `tails` 数组上执行二分搜索，找到第一个大于或等于 $c$ 的元素的索引 `j`。问题将一次比较定义为对谓词 `tails[m] >= c` 的求值，其中 `m` 是二分搜索中的中间点索引。此步骤的求值次数被统计并加到 `total_comparisons` 中。\n    b. 如果在索引 `j` 处找到了这样的元素，这意味着我们找到了一个以 $c$ 结尾的长度为 $j+1$ 的递增子序列。由于 $c \\le \\text{tails}[j]$，这个新的子序列与之前同样长度的子序列相比，其结尾更小或相等。我们更新 `tails[j] = c` 来反映这个可能更优的子序列。\n    c. 如果没有找到这样的元素（即 $c$ 大于 `tails` 中的所有元素），这意味着我们可以扩展目前找到的最长递增子序列。我们将 $c$ 追加到 `tails` 数组中，从而有效地创建一个新的、更长的 LIS。\n3.  遍历完 $C$ 的所有元素后，`tails` 数组的长度就是 $C$ 的 LIS 长度，也即 $A$ 的 LIS 长度。\n\n### 3. 边界情况分析\n\n问题要求分析值的稀疏性与稠密性如何影响二分搜索的步数。\n\n坐标压缩转换了输入值，无论其原始稀疏性（例如，$[10, 10^{18}]$）或稠密性（例如，$[10, 11]$）如何，都将它们转换为一个紧凑的连续整数集合 $\\{0, 1, \\dots, m-1\\}$。因此，原始值的稀疏性对压缩*后*的 LIS 算法性能没有直接影响。压缩步骤本身的复杂度由于对唯一元素排序而为 $O(n \\log n)$。\n\n二分搜索执行的比较次数取决于两个因素：\n1.  序列中的元素数量 $n$。\n2.  `tails` 数组长度的增长速率。\n\n`tails` 数组的增长由压缩序列 $C$ 的结构决定，而不是其值的范围。\n-   **严格递增序列（例如，测试用例 2）：** 对于像 $[1, 2, \\dots, 9]$ 这样的序列，压缩后得到 $[0, 1, \\dots, 8]$。每个元素都大于之前的所有元素，因此它总是被追加到 `tails` 中。`tails` 的长度在每一步都增加一。总比较次数将是在大小为 $0, 1, 2, \\dots, n-1$ 的数组上进行二分搜索的比较次数之和。这导致大约 $\\sum_{k=1}^{n-1} \\log_2(k)$ 次比较，即 $O(n \\log n)$。\n-   **严格递减序列（例如，测试用例 4）：** 对于像 $[100, 99, \\dots, 93]$ 这样的序列，压缩后得到 $[7, 6, \\dots, 0]$。第一个元素将 `tails` 初始化为长度 $1$。随后的每个元素都小于 `tails` 中的当前元素，因此它将替换 `tails[0]`。`tails` 数组的长度永远不会超过 $1$。每一步（除第一步外）的二分搜索都是在大小为 $1$ 的数组上进行，花费常数次比较（通常是一次）。总比较次数将是 $O(n)$。\n-   **包含重复值的序列（例如，测试用例 3）：** 对于由相同值组成的序列，如 $[10^{18}, \\dots, 10^{18}]$，压缩序列为 $[0, 0, \\dots, 0]$。第一个 $0$ 初始化 `tails=[0]`。随后的每个 $0$ 都会被发现等于 `tails[0]`，导致更新 `tails[0] = 0`。`tails` 数组永不增长，LIS 长度为 $1$。总比较次数将是 $O(n)$，与递减情况类似。\n\n总之，坐标压缩将值域标准化，使得 LIS 算法的性能仅取决于序列元素的长度和相对顺序，而与原始数值的大小或间距无关。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the LIS problem for a predefined test suite.\n    \"\"\"\n    \n    # Test cases as specified in the problem statement.\n    test_cases = [\n        [10**18 - 3, 1, 10**18 - 2, 2, 10**18 - 1, 3], # 1. Sparse high-magnitude interleaving\n        [1, 2, 3, 4, 5, 6, 7, 8, 9],                     # 2. Dense small increasing\n        [10**18, 10**18, 10**18, 10**18, 10**18],       # 3. All equal large\n        [10**18, 10**18 - 1, 10**18 - 2, 10**18 - 3, 10**18 - 4, 10**18 - 5, 10**18 - 6, 10**18 - 7], # 4. Strictly decreasing large\n        [10**18 - 5, 5, 10**18 - 5, 6, 10**18 - 4, 7, 10**18 - 3, 8], # 5. Alternating duplicates and growth\n        [10**18 - 10, 10**18 - 9, 10**18 - 9, 10**18 - 8, 10**18 - 7, 10**18 - 7, 10**18 - 6, 10**18 - 5], # 6. Dense with duplicates near large values\n        [],                                               # 7. Boundary empty sequence\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_lis_with_stats(case)\n        results.append(result)\n\n    # Format the final output as specified.\n    # e.g., [[3, 7], [5, 9]]\n    formatted_results = [f\"[{res[0]},{res[1]}]\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef compute_lis_with_stats(A):\n    \"\"\"\n    Computes the LIS length and total binary search comparisons for a sequence.\n\n    Args:\n        A (list): A list of integers.\n\n    Returns:\n        tuple: A tuple containing (lis_length, total_comparisons).\n    \"\"\"\n    n = len(A)\n    if n == 0:\n        return [0, 0]\n\n    # Step 1: Coordinate Compression\n    unique_vals = np.unique(A)\n    val_to_rank = {val: i for i, val in enumerate(unique_vals)}\n    C = [val_to_rank[val] for val in A]\n\n    # Step 2: LIS with binary search and comparison counting\n    tails = []\n    total_comparisons = 0\n\n    for c_val in C:\n        # Custom binary search (lower_bound) to count comparisons.\n        # A comparison is defined as `tails[m] >= c_val`.\n        lo, hi = 0, len(tails)\n        num_comps_this_step = 0\n        \n        while lo  hi:\n            mid = lo + (hi - lo) // 2\n            num_comps_this_step += 1\n            if tails[mid] >= c_val:\n                hi = mid\n            else:\n                lo = mid + 1\n        \n        total_comparisons += num_comps_this_step\n        \n        idx = lo\n        if idx == len(tails):\n            tails.append(c_val)\n        else:\n            tails[idx] = c_val\n    \n    lis_length = len(tails)\n    return [lis_length, total_comparisons]\n\n# Execute the main function.\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "求出最长递增子序列的长度通常只是第一步，更进一步的需求是构造出这个子序列本身。然而，最长递增子序列可能不止一个，那么如何根据特定规则选择其中之一呢？本练习将探讨两种不同的“最优”标准——索引字典序最小和值字典序最小，并展示如何通过精巧的算法设计来精确地重构出满足这些特定条件的子序列，从而加深对动态规划状态与重构路径之间关系的理解。",
            "id": "3247880",
            "problem": "给定一个有限整数序列 $A = [a_0, a_1, \\dots, a_{n-1}]$，其中 $n \\geq 1$。子序列是满足 $0 \\leq i_0  i_1  \\dots  i_{k-1} \\leq n-1$ 的任意序列 $[a_{i_0}, a_{i_1}, \\dots, a_{i_{k-1}}]$。如果一个子序列满足 $a_{i_0}  a_{i_1}  \\dots  a_{i_{k-1}}$，则称其为严格递增子序列。最长递增子序列（Longest Increasing Subsequence, LIS）是所有严格递增子序列中长度最长的任意一个。在重构 LIS 时，考虑两种不同的决胜规则：\n- 字典序最小的索引向量：在所有 LIS 中，考虑其索引向量 $[i_0, i_1, \\dots, i_{k-1}]$；选择索引向量字典序最小的 LIS。\n- 字典序最小的值向量：在所有 LIS 中，考虑其值向量 $[a_{i_0}, a_{i_1}, \\dots, a_{i_{k-1}}]$；选择值向量字典序最小的 LIS。\n\n您的任务是从第一性原理出发，推导并实现一个方法来重构以下两种 LIS：\n- 一个具有字典序最小索引的 LIS（返回使用零基索引的索引列表）。\n- 一个具有字典序最小值的 LIS（返回其值）。\n\n您必须解释需要哪些数据结构来强制执行这些决胜规则，并从基于子序列、偏序和经过充分检验的算法事实的原理性角度，说明它们为何是正确的。\n\n您的程序必须是独立完整的，并为以下测试套件生成输出。每个测试用例都是一个序列 $A$：\n- 测试用例 1：$[3, 1, 2, 2, 4, 3, 5]$。\n- 测试用例 2：$[10]$。\n- 测试用例 3：$[2, 2, 2, 2]$。\n- 测试用例 4：$[1, 2, 3, 4]$。\n- 测试用例 5：$[5, 4, 3, 2, 1]$。\n- 测试用例 6：$[5, 1, 6, 2, 7, 3, 8, 0, 9]$。\n\n对于每个测试用例，结果必须是一个 $[I, V]$ 形式的列表对，其中 $I$ 是在字典序最小索引规则下选择的 LIS 的索引列表，而 $V$ 是在字典序最小数值规则下选择的 LIS 的值列表。\n\n最终输出格式：您的程序应生成一行输出，其中包含所有测试用例的结果，该结果是一个用方括号括起来的逗号分隔列表。此外部列表的每个元素必须是如上所述的 $[I, V]$ 对。例如，格式必须类似于 $[[I_1, V_1], [I_2, V_2], \\dots]$，其中每个 $I_j$ 和 $V_j$ 都是列表。不涉及物理单位、角度或百分比。\n\n覆盖性设计：测试套件包括一个带有重复值的通用案例、一个单元素边界案例、一个所有值相等的案例、一个严格递增案例、一个严格递减案例以及一个混合复杂案例。答案是列表，每个列表元素必须是整数。程序不得读取输入，且必须仅按指定的确切格式打印单行最终结果。",
            "solution": "该问题要求从给定的整数序列 $A = [a_0, a_1, \\dots, a_{n-1}]$ 中重构两种特定的最长递增子序列（LIS）。这两种所需的子序列通过分别应用于其索引向量和值向量的字典序最小化规则来区分。解决此问题的一个严谨、基于原理的方法涉及动态规划（DP）以及对算法选择如何映射到指定的决胜标准的理解。\n\nLIS 的长度是一个标准问题，可在 $O(n \\log n)$ 时间内解决。其核心思想是，对于每个可能的长度 $l$，维护一个可以终止长度为 $l$ 的递增子序列的最小值。我们的任务更复杂，因为它要求重构特定的子序列。这需要在 DP 过程中存储额外的信息。\n\n设 $L[i]$ 表示以序列 $A$ 的索引 $i$ 结尾的最长递增子序列的长度。可以为所有 $i \\in [0, n-1]$ 计算该值。计算数组 $L$ 的一种高效方法如下：我们维护一个“尾部”数组 $T$，其中 $T[j]$ 存储长度为 $j+1$ 的严格递增子序列的最小末端值。根据定义，$T$ 数组是严格递增的。处理元素 $a_i$ 时，我们使用二分搜索在 $T$ 中找到其位置。如果 $a_i$ 大于 $T$ 中的所有元素，它将延长 LIS，我们将其附加到 $T$。否则，它将替换元素 $T[j]$，其中 $T[j]$ 是 $T$ 中大于或等于 $a_i$ 的最小元素。此替换表示我们找到了一个以更小的值 $a_i$ 结尾的长度为 $j+1$ 的递增子序列，这对于扩展未来的子序列更为有利。以 $a_i$ 结尾的 LIS 的长度即为 $j+1$。整个过程耗时 $O(n \\log n)$。\n\n有了这种计算长度的基础方法，我们现在可以为这两个重构任务设计策略。\n\n### 1. 具有字典序最小值的 LIS (LSV)\n\n要构建一个值向量字典序最小的 LIS，我们应在子序列的每个位置（从左到右）优先选择较小的值。上述标准的 $O(n \\log n)$ 算法，只需稍作增强以存储前驱信息，便能自然地产生此结果。\n\n其原理是，通过始终为任何给定的子序列长度维持一个尽可能小的尾部（即 $T$ 数组的用途），我们做出的局部最优选择将导向一个全局字典序最小的值向量。\n\n算法如下：\n1. 初始化一个空索引列表 $M$，它将对应于尾部数组 $T$，但存储的是索引而非值（即 $T[j] = A[M[j]]$）。\n2. 初始化一个大小为 $n$ 的前驱映射或数组 $P$。$P[i]$ 将存储在以 $a_i$ 结尾的 LIS 中位于 $a_i$ 之前的元素的索引。\n3. 从 $0$到 $n-1$ 遍历输入序列 $A$ 的索引 $i$。对于每个元素 $a_i$：\n    a. 在与 $M$ 中索引对应的值上（即在 $[A[m] \\text{ for } m \\in M]$ 上）执行二分搜索（特别是 `lower_bound` 或 `bisect_left`），以找到 $a_i$ 的插入位置 $l$。此位置 $l$ 对应于长度为 $l+1$ 的子序列。\n    b. 如果 $l > 0$，则表示 $a_i$ 扩展了一个长度为 $l$ 的递增子序列。该子序列的最后一个元素由索引 $M[l-1]$ 表示。我们通过设置 $P[i] = M[l-1]$ 来记录此关系。\n    c. 更新 $M$：如果 $l$ 等于 $M$ 的当前长度，则将 $i$ 附加到 $M$。否则，设置 $M[l] = i$。此步骤确保对于长度 $l+1$，我们现在有了一个新的、可能更好（值更小）的终止元素 $a_i$。\n4. 遍历完所有元素后，LIS 的长度为 $k = |M|$。我们构建的 LIS 的最后一个元素的索引由 $M[k-1]$ 给出。\n5. 通过从索引 $j = M[k-1]$ 开始，并重复移动到前驱 $j = P[j]$，直到收集到 $k$ 个元素，来（以相反顺序）重构 LIS。将得到的值序列反转后，即为 LSV LIS。\n\n### 2. 具有字典序最小索引的 LIS (LSI)\n\n要找到具有字典序最小索引向量 $[i_0, i_1, \\dots, i_{k-1}]$ 的 LIS，我们必须在构建的每一步中，从 $i_0$ 开始，优先选择尽可能小的索引。这需要一种与 LSV 情况不同的方法。一种贪心的前向构造方法是合适的，即在每一步中，我们为子序列的下一个位置选择最小的有效索引。\n\n为了做出明智的贪心选择，我们需要关于序列的更多全局信息。具体来说，对于每个元素 $a_i$，我们不仅需要知道以索引 $i$ 结尾的 LIS 的长度（我们称之为 $L_{end}[i]$），还需要知道从索引 $i$ *开始*的 LIS 的长度（我们称之为 $L_{start}[i]$）。\n\n一个元素 $a_i$ 能成为*任何*最大长度为 $k$ 的 LIS 的一部分，当且仅当 $L_{end}[i] + L_{start}[i] - 1 = k$。\n\n算法如下：\n1. 计算数组 $L_{end}$，其中 $L_{end}[i]$ 是以索引 $i$ 结尾的 LIS 的长度。这可以使用前面描述的 $O(n \\log n)$ 方法完成。设 $k = \\max(L_{end})$ 为最大 LIS 长度。\n2. 计算数组 $L_{start}$，其中 $L_{start}[i]$ 是从索引 $i$ 开始的 LIS 的长度。这可以通过对反转序列 $A^{rev} = [a_{n-1}, \\dots, a_0]$ 计算每个索引结尾的 LIS 并进行修改比较来得到。一种等效且更简单的方法是在取反后的反转序列 $B = [-a_{n-1}, \\dots, -a_0]$ 上找到标准 LIS。将 $B$ 的结果长度数组反转，即可得到 $L_{start}$。\n3. 重构 LSI 索引向量：\n    a. 为结果索引初始化一个空列表。\n    b. 初始化 `last_index = -1`、`last_value = -\\infty` 和 `current_length = 1`。\n    c. 从 $j = 1$ 到 $k$ 迭代，以找到 LSI LIS 的第 $j$ 个元素。\n    d. 在每次迭代中，搜索满足以下条件的最小索引 `i`：\n        i. `i > last_index`：索引必须严格大于先前选择的索引。\n        ii. `A[i] > last_value`：值必须严格递增以维持递增子序列。\n        iii. `L_{end}[i] \\geq current_length`：以 $i$ 结尾的 LIS 必须足够长。\n        iv. `L_{end}[i] + L_{start}[i] - 1 = k`：在索引 `i` 处选择的元素必须是*某个*最大长度 LIS 的一部分，确保该选择不会导致死胡同。\n    e. 将找到的索引 `i` 附加到结果中，并为下一次迭代更新 `last_index = i`、`last_value = A[i]` 和 `current_length = current_length + 1`。\n4. 构造出的索引列表即为 LSI LIS 的索引向量。\n\n这个详细的两遍过程保证了字典序最小的索引向量，因为它在每步前向构造中都做出了一个贪心选择（最小的有效索引），并借助预先计算的信息来保证该选择可以扩展成一个完整的最大长度 LIS。",
            "answer": "```python\nimport numpy as np\nfrom bisect import bisect_left\n\ndef solve():\n    \"\"\"\n    Solves the Longest Increasing Subsequence problem with two different\n    tie-breaking rules for a predefined set of test cases.\n    \"\"\"\n\n    def get_lsv(A):\n        \"\"\"\n        Calculates the LIS with the lexicographically smallest value vector.\n        \n        Args:\n            A: A list of integers.\n        \n        Returns:\n            A list of integers representing the values of the LIS.\n        \"\"\"\n        n = len(A)\n        if n == 0:\n            return []\n        \n        # M stores indices of the tails of increasing subsequences.\n        tails_values = []\n        M = []\n        # P stores predecessor indices for reconstruction.\n        P = {} \n\n        for i, val in enumerate(A):\n            # Binary search for the position l where val should be placed.\n            l = bisect_left(tails_values, val)\n\n            if l > 0:\n                P[i] = M[l-1]\n\n            if l == len(M):\n                M.append(i)\n                tails_values.append(val)\n            else:\n                M[l] = i\n                tails_values[l] = val\n\n        # Reconstruct the LIS values from predecessors.\n        lis = []\n        if M:\n            curr_idx = M[-1]\n            while curr_idx in P:\n                lis.append(A[curr_idx])\n                curr_idx = P[curr_idx]\n            lis.append(A[curr_idx])\n        \n        return lis[::-1]\n\n    def get_lsi(A):\n        \"\"\"\n        Calculates the LIS with the lexicographically smallest index vector.\n        \n        Args:\n            A: A list of integers.\n        \n        Returns:\n            A list of integers representing the zero-based indices of the LIS.\n        \"\"\"\n        n = len(A)\n        if n == 0:\n            return []\n\n        def get_lengths(arr):\n            \"\"\"Helper to compute LIS lengths ending at each position.\"\"\"\n            if not arr:\n                return []\n            tails = []\n            lengths = []\n            for val in arr:\n                l = bisect_left(tails, val)\n                if l == len(tails):\n                    tails.append(val)\n                else:\n                    tails[l] = val\n                lengths.append(l + 1)\n            return lengths\n\n        # L_end[i]: length of LIS ending at index i\n        L_end = get_lengths(A)\n        \n        # L_start[i]: length of LIS starting at index i.\n        # Computed by finding LIS on the negated reversed array.\n        A_rev_neg = [-x for x in reversed(A)]\n        L_start_rev = get_lengths(A_rev_neg)\n        L_start = list(reversed(L_start_rev))\n        \n        if not L_end:\n            return []\n        \n        k = max(L_end)\n        \n        # Forward reconstruction using the precomputed length arrays.\n        result_indices = []\n        last_index = -1\n        last_value = -float('inf')\n        \n        # The current length of the LIS we are building.\n        current_lis_len = 1\n\n        for _ in range(k):\n            # Find the smallest index for the next element in the LSI LIS.\n            next_idx = -1\n            for i in range(last_index + 1, n):\n                # Conditions for the next element:\n                # 1. Index must be greater.\n                # 2. Value must be strictly increasing.\n                # 3. Must be part of a max-length LIS.\n                # 4. Must extend the LIS we are building.\n                if (A[i] > last_value and \n                    L_end[i] >= current_lis_len and\n                    L_end[i] + L_start[i] - 1 == k):\n                    next_idx = i\n                    break\n            \n            if next_idx != -1:\n                result_indices.append(next_idx)\n                last_index = next_idx\n                last_value = A[next_idx]\n                current_lis_len +=1\n        \n        return result_indices\n\n    test_cases = [\n        [3, 1, 2, 2, 4, 3, 5],\n        [10],\n        [2, 2, 2, 2],\n        [1, 2, 3, 4],\n        [5, 4, 3, 2, 1],\n        [5, 1, 6, 2, 7, 3, 8, 0, 9],\n    ]\n\n    results = []\n    for A in test_cases:\n        lsi_indices = get_lsi(A)\n        lsv_values = get_lsv(A)\n        results.append([lsi_indices, lsv_values])\n\n    # Convert the Python list of lists into the required string format.\n    # Eg: [[indices], [values]] -> \"[[indices], [values]]\"\n    result_str = \",\".join(str(res).replace(\" \", \"\") for res in results)\n    print(f\"[{result_str}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在解决了“是什么”（重构）和“有多长”（长度）的问题之后，一个自然而更具挑战性的问题是“有多少个？”。当存在多个不同的最长递增子序列时，计算其总数是一个更复杂的组合计数问题。本练习将带领你将动态规划的思想与高级数据结构（如线段树）相结合，设计出一个高效的 $O(n \\log n)$ 算法，来精确统计不同最长递增子序列的数量，这是对LIS问题理解的进一步深化。",
            "id": "3247972",
            "problem": "给定一个长度为 $n$ 的有限整数序列 $A = (A_1, A_2, \\dots, A_n)$。$A$ 的一个子序列是满足 $1 \\le i_1  i_2  \\dots  i_k \\le n$ 的任意序列 $(A_{i_1}, A_{i_2}, \\dots, A_{i_k})$。如果一个子序列满足 $A_{i_1}  A_{i_2}  \\dots  A_{i_k}$，则称其为严格递增子序列。最长递增子序列（LIS）是具有最大可能长度的任何严格递增子序列；将此最大长度表示为 $L$。如果两个子序列的索引序列 $(i_1, i_2, \\dots, i_k)$ 至少在一个位置上不同，则它们被认为是不同的。任务是计算长度为 $L$ 的不同 LIS 子序列的数量。\n\n对于任意输入序列 $A$，请仅从严格递增子序列的定义以及在满足严格不等式的前序索引上取最大值的概念出发，设计一个算法来计算最大长度 $L$ 和该长度下不同 LIS 子序列的数量，并证明其正确性。你的算法时间复杂度必须达到 $O(n \\log n)$，并使用坐标压缩来处理来自任意整数域的 $A$ 值。你的设计必须明确说明如何处理 $A$ 中的重复元素（即存在 $p \\ne q$ 且 $A_p = A_q$ 的情况），以确保严格递增比较 $A_{i}  A_{j}$ 得以执行，并且不发生重复计数。该算法必须从第一性原理（子序列的定义和严格不等式下的最大值）推导得出，并且你的数据结构必须通过一个能让你在保留计数的同时高效合并不同值范围结果的性质来证明其合理性。\n\n将该算法实现为一个完整的、可运行的程序，该程序内部计算以下测试集的答案。对于每个测试用的一维数组 $A$，每个测试的预期输出是一个包含两个整数的列表 $[L, C]$，其中 $L$ 是 LIS 的长度，$C$ 是长度为 $L$ 的不同 LIS 子序列的数量：\n- 测试 $1$：$A = [1,2,3,4]$（一个普通递增情况）。\n- 测试 $2$：$A = [4,3,2,1]$（一个严格递减的边界情况）。\n- 测试 $3$：$A = [2,2,2]$（所有元素相等，重复元素多的边界情况）。\n- 测试 $4$：$A = [1,3,5,4,7]$（一个混合情况，有多个 LIS 且没有相等的相邻转换）。\n- 测试 $5$：$A = [3,1,2,1,2,3]$（一个混合情况，在多个值处有重复）。\n- 测试 $6$：$A = [1,2,2,3,3,4]$（一个重复元素增加了最大长度选择数量的情况）。\n\n你的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，每个元素按上述顺序对应一个测试。每个元素必须是一个包含两个整数的列表 $[L, C]$。例如，三个测试的输出的整体形状为 $[[L_1,C_1],[L_2,C_2],[L_3,C_3]]$。程序不得读取输入；它必须计算给定测试集的结果并直接打印。此问题不涉及物理单位、角度单位或百分比表示；所有输出均为整数。",
            "solution": "问题要求设计一个算法，用于找出一个给定整数序列 $A = (A_1, A_2, \\dots, A_n)$ 的最长递增子序列（LIS）的长度 $L$，以及这类不同子序列的数量 $C$。该算法的时间复杂度必须为 $O(n \\log n)$。\n\n首先，我们使用动态规划从第一性原理出发构建一个解决方案。对于序列中的每个元素 $A_i$，我们关心以该元素结尾的严格递增子序列的性质。我们为每个索引 $i \\in \\{1, \\dots, n\\}$ 定义两个量：\n1.  $L_i$：以元素 $A_i$ 结尾的最长严格递增子序列的长度。\n2.  $C_i$：以 $A_i$ 结尾的长度为 $L_i$ 的不同子序列的数量。\n\n要计算元素 $A_i$ 的 $L_i$，我们必须扩展一个已有的递增子序列。一个以某个 $A_j$（其中 $j  i$）结尾的递增子序列当且仅当 $A_j  A_i$ 时才能被 $A_i$ 扩展。所得子序列的长度将是 $L_j + 1$。为了最大化长度 $L_i$，我们必须选择可能的最长子序列进行扩展。这导出了 $L_i$ 的递推关系：\n$$L_i = 1 + \\max(\\{L_j \\mid j  i \\text{ and } A_j  A_i\\} \\cup \\{0\\})$$\n当不存在这样的 $j$（集合为空）时，基准情况由与 $\\{0\\}$ 的 $\\max$ 操作处理，得到 $L_i = 1$。这对应于仅由 $A_i$ 组成的子序列。\n\n为了计算 $C_i$，我们计算有多少种方式可以形成一个以 $A_i$ 结尾、长度为 $L_i$ 的递增子序列。每个这样的子序列都是通过将 $A_i$ 追加到一个以某个 $A_j$（其中 $j  i$ 且 $A_j  A_i$）结尾、长度为 $L_i - 1$ 的递增子序列而形成的。为了得到总数 $C_i$，我们必须将所有这些有效的前驱子序列的计数 $C_j$ 相加。这得出了 $C_i$ 的递推关系：\n$$C_i = \\sum \\{C_j \\mid j  i, A_j  A_i, \\text{ and } L_j = L_i - 1\\}$$\n如果不存在这样的 $j$（即 $L_i = 1$），则计数 $C_i$ 为 1，对应于子序列 $(A_i)$ 本身。\n\n在计算完所有 $i = 1, \\dots, n$ 的 $(L_i, C_i)$ 之后，总的 LIS 长度 $L$ 是所有 $L_i$ 中的最大值：$L = \\max_{i=1}^n L_i$。总计数 $C$ 是所有长度 $L_i$ 等于最大长度 $L$ 的索引 $i$ 对应的计数 $C_i$ 之和：$C = \\sum \\{C_i \\mid L_i = L\\}$。\n\n直接实现这些递推关系，对于每个 $i$ 都需要遍历所有 $j  i$，这会导致 $O(n^2)$ 的时间复杂度。为了达到所要求的 $O(n \\log n)$ 复杂度，我们必须优化查找最大长度和相应计数总和的过程。对于每个元素 $A_i$，计算过程需要查询所有已处理过的且值 $A_j  A_i$ 的元素 $A_j$ 的聚合信息。这是一个关于元素值的前缀查询问题。\n\n$A$ 中的值可以来自任意整数域。为了高效处理，我们采用坐标压缩。我们找出 $A$ 中所有的唯一值，将它们排序，并为每个值分配一个从 $0$ 到 $m-1$ 的排名，其中 $m$ 是唯一值的数量。这将问题映射到一个紧凑的整数范围内，使其适用于由这些排名索引的数据结构。坐标压缩的排序步骤耗时 $O(n \\log n)$。\n\n优化的核心是使用一个能够高效执行所需查询的数据结构。我们需要一个结构，对于任何排名 $r$，它能返回所有以排名小于 $r$ 的元素结尾的子序列的聚合 $(L, C)$ 对。线段树是一个合适的选择。关键的洞见在于，合并来自不同值范围结果的过程是满足结合律的。我们定义一个在两个对 $(L_1, C_1)$ 和 $(L_2, C_2)$ 上的 `combine` 操作：\n$$ \\text{combine}((L_1, C_1), (L_2, C_2)) =\n\\begin{cases}\n(L_1, C_1)  \\text{if } L_1 > L_2 \\\\\n(L_2, C_2)  \\text{if } L_2 > L_1 \\\\\n(L_1, C_1 + C_2)  \\text{if } L_1 = L_2\n\\end{cases}\n$$\n此操作满足结合律，使得线段树能够高效地计算区间查询。\n\n使用线段树的算法如下：\n1.  **预处理**：对 $A$ 进行坐标压缩。设 $m$ 为唯一值的数量。这会给出一个从每个值到 $[0, m-1]$ 中一个排名的映射。\n2.  **数据结构**：在排名范围 $[0, m-1]$ 上创建一个线段树。树的每个叶子节点对应一个排名，并存储一个聚合的 $(L, C)$ 对。内部节点存储其子节点 `combine` 后的结果。所有节点初始化为 $(0, 0)$，它作为 `combine` 操作的单位元。\n3.  **主循环**：遍历序列中的每个元素 $A_i$。对于每个 $A_i$：\n    a. 设 $r$ 为 $A_i$ 的排名。\n    b. 查询线段树的范围 $[0, r-1]$。此查询耗时 $O(\\log m)$ 并返回对 $(L_{prev}, C_{prev})$，表示所有以严格小于 $A_i$ 的值结尾的递增子序列的最大长度和相应计数。\n    c. 根据查询结果，计算以 $A_i$ 结尾的子序列的新对。如果 $L_{prev}=0$，则不存在这样更小的前驱，因此我们得到一个新的长度为 1 的 LIS，即 $(L_{new}, C_{new}) = (1, 1)$。否则，我们扩展找到的子序列，得到 $(L_{new}, C_{new}) = (L_{prev} + 1, C_{prev})$。\n    d. 更新线段树。元素 $A_i$ 贡献了一组新的以值 $A_i$（排名为 $r$）结尾、长度为 $L_{new}$、数量为 $C_{new}$ 的子序列。如果具有相同值的其他元素已经被处理过，我们必须聚合它们的贡献。在排名 $r$ 处对线段树进行单点更新可以处理此问题。我们检索存储在排名 $r$ 的当前对 $(L_{curr}, C_{curr})$，将其与我们的新对 $(L_{new}, C_{new})$ 合并，并用结果更新排名 $r$ 的叶子节点。此单点更新耗时 $O(\\log m)$。\n4.  **最终结果**：遍历完所有 $n$ 个元素后，线段树的根节点包含了整个排名范围 $[0, m-1]$ 上的聚合 $(L, C)$ 对。这对就是最终答案 $(L, C)$。\n\n对重复元素的显式处理已嵌入此过程中。两个元素 $A_p = A_q$ 具有相同的排名。当处理第二个出现的元素时（假设在索引 $q > p$），查询小于 $A_q$ 排名的范围确保我们只考虑扩展以严格较小值结尾的子序列，这遵循了问题的定义。在相同排名上的更新步骤会正确地累加计数。例如，如果两个独立的元素 $A_p$ 和 $A_q$（其中 $p \\ne q$）都分别创建了长度为 $k$、数量为 $c_1$ 和 $c_2$ 的 LIS，并且它们都可以被后面的元素 $A_r$ 扩展，那么形成以 $A_r$ 结尾、长度为 $k+1$ 的 LIS 的总方式数将正确地将这些计数相加为 $c_1+c_2$。\n\n总时间复杂度主要由坐标压缩（$O(n \\log n)$）和主循环决定，主循环执行 $n$ 次迭代，每次迭代的线段树操作耗时 $O(\\log m)$。由于 $m \\le n$，总复杂度为 $O(n \\log n)$。空间复杂度为坐标压缩映射和线段树所需的 $O(m)$，在最坏情况下为 $O(n)$。此设计满足所有问题要求。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the number of longest increasing subsequences problem for a suite of test cases.\n    \"\"\"\n    \n    test_cases = [\n        [1, 2, 3, 4],\n        [4, 3, 2, 1],\n        [2, 2, 2],\n        [1, 3, 5, 4, 7],\n        [3, 1, 2, 1, 2, 3],\n        [1, 2, 2, 3, 3, 4]\n    ]\n\n    def combine(p1, p2):\n        \"\"\"Combines two (length, count) pairs.\"\"\"\n        l1, c1 = p1\n        l2, c2 = p2\n        if l1 > l2:\n            return p1\n        if l2 > l1:\n            return p2\n        return (l1, c1 + c2)\n\n    class SegmentTree:\n        \"\"\"\n        Segment Tree for range queries with a custom combine operation.\n        \"\"\"\n        def __init__(self, size):\n            self.size = size\n            self.tree = [(0, 0)] * (4 * size)\n\n        def _update(self, node, start, end, idx, val):\n            if start == end:\n                self.tree[node] = combine(self.tree[node], val)\n                return\n\n            mid = (start + end) // 2\n            if idx = mid:\n                self._update(2 * node, start, mid, idx, val)\n            else:\n                self._update(2 * node + 1, mid + 1, end, idx, val)\n            \n            self.tree[node] = combine(self.tree[2 * node], self.tree[2 * node + 1])\n\n        def update(self, idx, val):\n            self._update(1, 0, self.size - 1, idx, val)\n\n        def _query(self, node, start, end, l, r):\n            if r  start or end  l or l > r:\n                return (0, 0)\n            if l = start and end = r:\n                return self.tree[node]\n            \n            mid = (start + end) // 2\n            p1 = self._query(2 * node, start, mid, l, r)\n            p2 = self._query(2 * node + 1, mid + 1, end, l, r)\n            \n            return combine(p1, p2)\n\n        def query(self, l, r):\n            return self._query(1, 0, self.size - 1, l, r)\n            \n        def get_total_lis(self):\n            return self.tree[1]\n\n    def calculate_lis_count(A):\n        \"\"\"\n        Calculates the length and count of LIS for a single sequence A.\n        \"\"\"\n        n = len(A)\n        if n == 0:\n            return [0, 0]\n\n        # Coordinate Compression\n        unique_vals = sorted(list(set(A)))\n        m = len(unique_vals)\n        rank_map = {val: i for i, val in enumerate(unique_vals)}\n\n        # Segment Tree initialized for the range of ranks\n        st = SegmentTree(m)\n\n        for x in A:\n            r = rank_map[x]\n            \n            # Query for LIS ending in values smaller than x\n            # Query range of ranks is [0, r-1]\n            if r > 0:\n                l_prev, c_prev = st.query(0, r - 1)\n            else:\n                l_prev, c_prev = 0, 0\n\n            # Calculate new LIS pair for current element\n            if l_prev == 0:\n                # No smaller element seen, start a new LIS of length 1\n                new_pair = (1, 1)\n            else:\n                new_pair = (l_prev + 1, c_prev)\n            \n            # Update the segment tree at rank r with the new information\n            st.update(r, new_pair)\n            \n        # The root of the segment tree holds the final aggregated result\n        l_final, c_final = st.get_total_lis()\n        \n        return [l_final, c_final]\n        \n    results = []\n    for case in test_cases:\n        result = calculate_lis_count(case)\n        results.append(result)\n\n    # Format the entire output as a single string\n    formatted_results = \",\".join([str(r) for r in results])\n    print(f\"[{formatted_results.replace(' ', '')}]\")\n\nsolve()\n\n```"
        }
    ]
}