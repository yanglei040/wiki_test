{
    "hands_on_practices": [
        {
            "introduction": "要领略量子计算的威力，首先必须理解经典计算的局限性。这项练习将通过计算存储一个多量子比特系统状态所需的内存，来具体展示所谓的“指数墙”，揭示为何即便是对于最强大的超级计算机，模拟一个规模适中的量子计算机也是一项艰巨的任务。通过这个计算，你会亲身体会到量子状态空间的巨大以及量子计算的潜在优势。",
            "id": "3242197",
            "problem": "考虑在经典计算机上模拟一个$n$量子比特寄存器的纯态。一个纯态是维度为$2^{n}$的复希尔伯特空间中的一个单位向量，在计算基下，它可以写成一个由$2^{n}$个复数概率幅组成的列向量。为了在一台经典计算机上精确地存储这个态向量，您将每个复数幅记录为两个实值浮点数，每个浮点数占用$b$个字节。假设使用双精度，因此$b = 8$。\n\n给定一台机器，其随机存取存储器（RAM）容量为$M = 256 \\times 2^{30}$字节（即，以字节表示的$256$吉比字节）。忽略任何额外的开销，并假设内存可以完全用于存储该态向量。\n\n仅从“$n$个量子比特的态空间维度为$2^{n}$”以及“每个复数幅由两个实数组成”这两个定义出发，推导：\n\n- 存储完整态向量所需的实值浮点数总数，作为$n$的函数的表达式。\n- 使得精确的态向量能够存放在给定RAM中的最大量子比特数$n$。\n\n请以行矩阵的形式提供您的最终答案，其中第一个条目是作为$n$的函数的浮点数数量表达式，第二个条目是在内存限制下的最大$n$值。不需要进行四舍五入。",
            "solution": "问题陈述已经过验证，并被认为是合理的。它具有科学依据，是良定的、客观的，并包含推导出唯一解所需的所有必要信息。\n\n该问题要求两个量：首先，是存储一个$n$量子比特系统态向量所需的实值浮点数总数的表达式；其次，是在给定特定内存容量下可以模拟的最大量子比特整数$n$。\n\n让我们从推导浮点数的数量表达式开始。\n一个$n$量子比特寄存器的纯量子态由复希尔伯特空间$\\mathcal{H}$中的一个态向量$|\\psi\\rangle$描述。该空间的维度$D$由$D = 2^n$给出。这是因为$n$个量子比特中的每一个都具有一个二维的态空间，而复合系统的态空间是各个子空间的张量积，因此维度为$2 \\times 2 \\times \\dots \\times 2$（$n$次），即等于$2^n$。\n\n在计算基中，态向量$|\\psi\\rangle$表示为$2^n$个基向量的线性组合：\n$$|\\psi\\rangle = \\sum_{k=0}^{2^n - 1} c_k |k\\rangle$$\n其中系数$c_k$是称为概率幅的复数。该状态由这$2^n$个复数幅的集合完全确定。\n\n要在经典计算机上存储这个态向量，我们必须存储这$2^n$个复数中的每一个。一个复数$c_k$可以写成$c_k = a_k + i b_k$，其中$a_k$和$b_k$是分别表示实部和虚部的实数。问题陈述指出，每个复数幅存储为两个实值浮点数。\n\n令$N_{fp}(n)$为所需的实值浮点数总数。这个总数是复数幅的数量与每个复数幅所需实数数量的乘积。\n$$N_{fp}(n) = (\\text{Number of complex amplitudes}) \\times (\\text{Real numbers per complex amplitude})$$\n复数幅的数量是态空间的维度，即$2^n$。每个复数幅所需的实数数量给定为$2$。\n因此，作为$n$的函数的浮点数总数表达式为：\n$$N_{fp}(n) = 2^n \\times 2 = 2^{n+1}$$\n\n接下来，我们确定可以在给定RAM中存储的最大量子比特整数$n_{max}$。\n存储态向量所需的总内存大小，我们称之为$S(n)$，是浮点数的总数乘以每个数占用的内存大小。\n问题指明每个浮点数的大小为$b=8$字节（双精度）。\n所以，以字节为单位所需的总内存为：\n$$S(n) = N_{fp}(n) \\times b = 2^{n+1} \\times 8$$\n因为$8 = 2^3$，我们可以将$S(n)$表示为2的单一幂：\n$$S(n) = 2^{n+1} \\times 2^3 = 2^{n+4} \\text{ bytes}$$\n可用的RAM容量给定为$M = 256 \\times 2^{30}$字节。为了便于比较，我们需要将$M$表示为2的幂。数字$256$是$2^8$。\n$$M = 256 \\times 2^{30} = 2^8 \\times 2^{30} = 2^{38} \\text{ bytes}$$\n为了找到最大量子比特数$n$，我们必须找到使得所需内存$S(n)$不超过可用内存$M$的最大整数$n$。这可以表示为不等式：\n$$S(n) \\le M$$\n代入$S(n)$和$M$的表达式：\n$$2^{n+4} \\le 2^{38}$$\n由于指数函数的底数$2$大于$1$，该不等式对指数也成立：\n$$n+4 \\le 38$$\n解出$n$：\n$$n \\le 38 - 4$$\n$$n \\le 34$$\n由于$n$必须是整数，因此在给定的内存限制下可以模拟的最大量子比特数是$n_{max} = 34$。\n\n两个结果是：\n1. 浮点数数量的表达式是$2^{n+1}$。\n2. 最大量子比特整数是$34$。",
            "answer": "$$\\boxed{\\begin{pmatrix} 2^{n+1} & 34 \\end{pmatrix}}$$"
        },
        {
            "introduction": "虽然模拟大型量子系统是 intractable（不可行的），但模拟小型系统是建立量子算法工作原理直觉的最佳方式。在此实践中，你将编写一个程序来模拟一个3量子比特的量子线路，通过应用量子门并观察状态向量的演化。这项编码练习将从操作层面为你揭示叠加、纠缠以及像Hadamard门和CNOT门这样的基本门是如何工作的。",
            "id": "3242157",
            "problem": "设计并实现一个针对恰好 $3$ 个量子比特的量子电路的经典态矢量模拟器，该模拟器使用在复态矢量上的显式矩阵-向量乘法。计算基为 $\\{\\lvert 000\\rangle,\\lvert 001\\rangle,\\ldots,\\lvert 111\\rangle\\}$，一个 $n$ 量子比特的纯态表示为 $\\mathbb{C}^{2^n}$ 中的一个复向量，其 $\\ell_2$-范数等于 $1$。作用在量子比特索引 $t$（其中最低有效位是量子比特索引 $0$）上的单量子比特门由一个 $2\\times 2$ 幺正矩阵 $U$ 表示，该矩阵通过与单位阵的克罗内克积扩展到整个寄存器，并通过矩阵-向量乘积作用于状态。一个双量子比特受控非门（控制位 $c$，目标位 $t$）通过交换振幅来实现，这是一个线性操作，也可以通过适当的索引交换来实现。\n\n使用的基本原理：\n- 状态更新规则是线性的：如果一个矩阵为 $G$ 的门作用在寄存器上，则新状态为 $G\\psi$，其中 $\\psi\\in\\mathbb{C}^{2^n}$ 是当前状态。\n- 计算基态 $\\lvert q_{n-1}\\ldots q_1 q_0\\rangle$ 对应于小端序（little-endian）中的整数索引 $\\sum_{k=0}^{n-1} q_k 2^k$，其中 $q_k\\in\\{0,1\\}$。\n- 单量子比特门局部地作用于仅在目标量子比特上不同的不相交振幅对，形式为 $2\\times 2$ 矩阵-向量乘法。\n\n你的任务：\n1. 实现一个模拟器，该模拟器：\n   - 将状态初始化为 $\\lvert 000\\rangle$。\n   - 应用一个由电路描述指定的门序列。支持的门包括作用于指定量子比特的 Hadamard 门 $H=\\frac{1}{\\sqrt{2}}\\begin{pmatrix}1  1\\\\ 1  -1\\end{pmatrix}$，作用于指定量子比特的 Pauli $X$ 门 $X=\\begin{pmatrix}0  1\\\\ 1  0\\end{pmatrix}$，以及作用于指定控制和目标量子比特的受控非门 $(\\mathrm{CNOT}(c\\to t))$。\n   - 对单量子比特门使用显式矩阵-向量乘法语义，通过更新每个受影响的双振幅对 $\\begin{pmatrix}\\alpha\\\\ \\beta\\end{pmatrix}\\mapsto U\\begin{pmatrix}\\alpha\\\\ \\beta\\end{pmatrix}$。\n   - 对于 $\\mathrm{CNOT}(c\\to t)$，通过交换那些控制位为 $1$ 且目标位为 $0$ 的基索引与其目标位为 $1$ 的对应索引，来更新振幅。\n2. 根据以下统一成本模型，计算你的实现所执行的基本算术操作次数：\n   - 对于在 $n$ 个量子比特上应用的每个单量子比特门，计为 $4\\cdot 2^{n-1}$ 次复数乘法和 $2\\cdot 2^{n-1}$ 次复数加法。\n   - 对于在 $n$ 个量子比特上应用的每个受控非门，计为因交换而产生的 $3\\cdot 2^{n-2}$ 次标量赋值。将每次交换视为 $3$ 次赋值。\n   - 报告在整个电路上累积的这些计数。\n3. 对于下面的每个测试用例，计算从最终状态测量到基态 $\\lvert 111\\rangle$ 的概率，该概率是索引 $7$（根据上述指定的小端序索引）处振幅的模平方。\n\n测试套件：\n- 用例 A（边界情况，空电路）：$n=3$，电路深度 $d=0$，没有门。查询 $\\lvert 111\\rangle$ 的概率。\n- 用例 B（均匀叠加）：$n=3$，依次在量子比特 $0$、$1$ 和 $2$ 上应用 $H$ 门。查询 $\\lvert 111\\rangle$ 的概率。\n- 用例 C（纠缠到 Greenberger–Horne–Zeilinger 态）：$n=3$，在量子比特 $0$ 上应用 $H$ 门，然后是 $\\mathrm{CNOT}(0\\to 1)$，然后是 $\\mathrm{CNOT}(1\\to 2)$。查询 $\\lvert 111\\rangle$ 的概率。\n- 用例 D（通过对合抵消）：$n=3$，在量子比特 $2$ 上应用两次 $X$ 门。查询 $\\lvert 111\\rangle$ 的概率。\n\n答案规范和最终输出格式：\n- 对于每个测试用例，你的程序必须按此确切顺序生成一个包含六个条目的列表：\n  - $\\lvert 111\\rangle$ 的概率，为一个实数。\n  - 计数的复数乘法总数。\n  - 计数的复数加法总数。\n  - 计数的因交换而产生的标量赋值总数。\n  - 使用的量子比特数 $n$。\n  - 电路深度 $d$（电路中门的数量）。\n- 将四个用例的列表聚合到一个列表中。你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，例如，形状为 $[\\text{caseA},\\text{caseB},\\text{caseC},\\text{caseD}]$，其中每个用例本身是如上定义的列表。\n\n你的分析目标：\n- 根据第一性原理，在所述成本模型下，推导渐近运行时间作为量子比特数 $n$ 和电路深度 $d$ 的函数，不假设任何结果。解释每个用例的计数，以证明对于由 $O(1)$ 量子比特门组成的电路，运行时间对 $n$ 呈指数依赖，对 $d$ 呈线性依赖。不要在问题陈述中提供快捷公式；在解决方案中展示你的推理过程。不涉及物理单位或角度。所有角度（如果有）都将以弧度为单位，但此处未使用。",
            "solution": "问题陈述已经过验证，被认为是合理的。它在科学上基于量子计算的原理，问题提出得当，目标明确，数据充分，并且没有歧义或矛盾。我们可以继续进行解答。\n\n任务是为一个 $3$ 量子比特的量子系统设计一个经典态矢量模拟器，并分析其在特定电路上的性能。模拟通过显式更新代表量子态的复矢量来进行。\n\n一个 $n$ 量子比特的纯量子态由一个维度为 $2^n$ 的复希尔伯特空间中的态矢量 $\\psi$ 表示，即 $\\psi \\in \\mathbb{C}^{2^n}$。该矢量被归一化，使其 $\\ell_2$-范数为 $1$，即 $\\|\\psi\\|_2 = 1$。计算基态表示为 $\\lvert q_{n-1} \\ldots q_1 q_0 \\rangle$，其中每个 $q_k \\in \\{0, 1\\}$。问题指定了一个从小端序（little-endian）将这些基态映射到态矢量 $\\psi$ 索引的规则。基态 $\\lvert q_{n-1} \\ldots q_1 q_0 \\rangle$ 对应于整数索引 $i = \\sum_{k=0}^{n-1} q_k 2^k$。对于我们 $n=3$ 的情况，态矢量 $\\psi$ 有 $2^3 = 8$ 个复数分量，索引从 $0$ 到 $7$。基态 $\\lvert q_2 q_1 q_0 \\rangle$ 映射到索引 $i = 4q_2 + 2q_1 + q_0$。初始状态指定为 $\\lvert 000 \\rangle$，对应于索引 $0$。因此，初始态矢量为 $\\psi_{initial} = [1, 0, 0, 0, 0, 0, 0, 0]^T$。\n\n在一个矩阵表示为 $G$ 的量子门作用下，状态的演化由矩阵-向量乘积 $\\psi' = G\\psi$ 给出。对于一个 $n$ 量子比特系统，$G$ 是一个 $2^n \\times 2^n$ 的幺正矩阵。我们按照指定的方式实现门的应用。\n\n模拟的成本通过根据提供的统一成本模型计算基本算术操作来衡量：\n- 对于一个作用于 $n$ 量子比特的单量子比特门：$4 \\cdot 2^{n-1}$ 次复数乘法和 $2 \\cdot 2^{n-1}$ 次复数加法。\n- 对于一个作用于 $n$ 量子比特的 $\\mathrm{CNOT}$ 门：$3 \\cdot 2^{n-2}$ 次标量赋值。\n\n测量到特定基态，例如 $\\lvert 111 \\rangle$（对应索引 $i=7$）的概率，由最终态矢量中相应振幅的模平方给出：$P(\\lvert 111 \\rangle) = |\\psi_{final}[7]|^2$。\n\n**单量子比特门的应用**\n一个作用于量子比特 $t$ 的单量子比特门，其矩阵为 $U = \\begin{pmatrix} U_{00}  U_{01} \\\\ U_{10}  U_{11} \\end{pmatrix}$，由 $2^n \\times 2^n$ 矩阵 $G = I^{\\otimes(n-1-t)} \\otimes U \\otimes I^{\\otimes t}$ 表示。直接应用这个大矩阵是低效的。相反，我们使用指定的局部更新规则。该门只影响那些仅在量子比特 $t$ 上有差异的基态所对应的振幅对。\n对于从 $0$ 到 $2^n-1$ 的每个整数索引 $i$，如果其第 $t$ 位为 $0$，我们找到其配对的索引 $j = i + 2^t$，其中第 $t$ 位为 $1$。这些索引处的振幅 $\\psi_i$ 和 $\\psi_j$ 根据 $2 \\times 2$ 矩阵 $U$ 进行更新：\n$$\n\\begin{pmatrix} \\psi'_i \\\\ \\psi'_j \\end{pmatrix} = \\begin{pmatrix} U_{00}  U_{01} \\\\ U_{10}  U_{11} \\end{pmatrix} \\begin{pmatrix} \\psi_i \\\\ \\psi_j \\end{pmatrix} = \\begin{pmatrix} U_{00}\\psi_i + U_{01}\\psi_j \\\\ U_{10}\\psi_i + U_{11}\\psi_j \\end{pmatrix}\n$$\n共有 $2^{n-1}$ 对这样的索引。每对的更新需要 $4$ 次复数乘法和 $2$ 次复数加法。这使得每次应用单量子比特门的总开销为 $4 \\cdot 2^{n-1}$ 次复数乘法和 $2 \\cdot 2^{n-1}$ 次复数加法，与指定的成本模型完全匹配。对于 $n=3$，这是 $4 \\cdot 2^2 = 16$ 次乘法和 $2 \\cdot 2^2 = 8$ 次加法。\n\n具体的单量子比特门是 Hadamard 门 $H = \\frac{1}{\\sqrt{2}}\\begin{pmatrix} 1  1 \\\\ 1  -1 \\end{pmatrix}$ 和 Pauli-X 门 $X = \\begin{pmatrix} 0  1 \\\\ 1  0 \\end{pmatrix}$。\n\n**受控非（CNOT）门的应用**\n$\\mathrm{CNOT}(c \\to t)$ 门当且仅当控制量子比特 $c$ 为 $1$ 时翻转目标量子比特 $t$。在计算基中，这等价于一个置换：$\\mathrm{CNOT} \\lvert \\dots q_c \\dots q_t \\dots \\rangle = \\lvert \\dots q_c \\dots (q_t \\oplus q_c) \\dots \\rangle$。这仅在 $q_c=1$ 时产生影响。因此，该操作交换基态 $\\lvert \\dots 1_c \\dots 0_t \\dots \\rangle$ 和 $\\lvert \\dots 1_c \\dots 1_t \\dots \\rangle$ 的振幅。\n在态矢量索引方面，我们必须识别所有第 $c$ 位为 $1$ 且第 $t$ 位为 $0$ 的索引 $i$。对于每个这样的 $i$，对应的索引 $j$ 是 $i + 2^t$。模拟器接着交换振幅 $\\psi_i$ 和 $\\psi_j$。需要交换的此类索引对的数量是选择剩下 $n-2$ 个比特的方式数，即 $2^{n-2}$。对于 $n=3$，这是 $2^{3-2}=2$ 对。\n成本模型规定一次交换需要 $3$ 次标量赋值。因此，一个 $\\mathrm{CNOT}$ 门的成本是 $3 \\cdot 2^{n-2}$ 次赋值。对于 $n=3$，这是 $3 \\cdot 2^1 = 6$ 次赋值。\n\n**渐近运行时分析**\n态矢量的大小为 $N=2^n$。应用一个单量子比特门的成本是 $O(2^n)$。应用一个双量子比特 $\\mathrm{CNOT}$ 门的成本也是 $O(2^n)$。通常，模拟任何作用于常数个量子比特 $k$ 的门，需要更新 $2^k$ 个振幅的元组，这需要遍历 $2^{n-k}$ 个这样的元组，从而导致计算成本为 $O(2^n)$。\n对于一个深度为 $d$（此处解释为门的总数）的电路，总模拟成本是每个门成本的总和。这导致总运行时间为 $O(d \\cdot 2^n)$。这证实了对量子比特数 $n$ 的预期指数依赖关系和对电路深度 $d$ 的线性依赖关系。\n\n**测试用例分析**\n\n**用例 A：空电路**\n- 电路：无。$n=3$，$d=0$。\n- 初始状态：$\\psi = \\lvert 000 \\rangle = [1, 0, 0, 0, 0, 0, 0, 0]^T$。\n- 最终状态：不变，$\\psi_{final} = [1, 0, 0, 0, 0, 0, 0, 0]^T$。\n- $\\lvert 111 \\rangle$ 的概率：$P(\\lvert 111 \\rangle) = |\\psi_{final}[7]|^2 = |0|^2 = 0$。\n- 操作计数：没有应用任何门。\n  - 复数乘法：$0$。\n  - 复数加法：$0$。\n  - 交换赋值：$0$。\n- 结果：$[0.0, 0, 0, 0, 3, 0]$。\n\n**用例 B：均匀叠加**\n- 电路：在量子比特 $0$ 上应用 $H$ 门，然后在量子比特 $1$ 上应用 $H$ 门，然后在量子比特 $2$ 上应用 $H$ 门。$n=3$，$d=3$。\n- 状态演化：\n  - $\\psi_0 = \\lvert 000 \\rangle$。\n  - $\\psi_1 = H_0 \\psi_0 = \\frac{1}{\\sqrt{2}}(\\lvert 000 \\rangle + \\lvert 001 \\rangle)$。\n  - $\\psi_2 = H_1 \\psi_1 = \\frac{1}{2}(\\lvert 000 \\rangle + \\lvert 001 \\rangle + \\lvert 010 \\rangle + \\lvert 011 \\rangle)$。\n  - $\\psi_{final} = H_2 \\psi_2 = \\frac{1}{2\\sqrt{2}} \\sum_{i=0}^{7} \\lvert i \\rangle$。\n- 在最终状态中，所有振幅均为 $\\frac{1}{\\sqrt{8}}$。\n- $\\lvert 111 \\rangle$ 的概率：$P(\\lvert 111 \\rangle) = |\\psi_{final}[7]|^2 = |\\frac{1}{\\sqrt{8}}|^2 = \\frac{1}{8} = 0.125$。\n- 操作计数：应用了 $3$ 个单量子比特门。\n  - 每个门的成本：$16$ 次乘法，$8$ 次加法。\n  - 总乘法次数：$3 \\times 16 = 48$。\n  - 总加法次数：$3 \\times 8 = 24$。\n  - 总交换次数：$0$。\n- 结果：$[0.125, 48, 24, 0, 3, 3]$。\n\n**用例 C：GHZ 态制备**\n- 电路：在量子比特 $0$ 上应用 $H$ 门，然后是 $\\mathrm{CNOT}(0 \\to 1)$，然后是 $\\mathrm{CNOT}(1 \\to 2)$。$n=3$，$d=3$。\n- 状态演化：\n  - $\\psi_0 = \\lvert 000 \\rangle$。\n  - $\\psi_1 = H_0 \\psi_0 = \\frac{1}{\\sqrt{2}}(\\lvert 000 \\rangle + \\lvert 001 \\rangle)$。\n  - $\\psi_2 = \\mathrm{CNOT}(0 \\to 1) \\psi_1 = \\frac{1}{\\sqrt{2}}(\\lvert 000 \\rangle + \\lvert 011 \\rangle)$。这是因为 $\\lvert 001 \\rangle$ 分量的控制位 $0$ 为 $1$，因此目标位 $1$ 被翻转。\n  - $\\psi_{final} = \\mathrm{CNOT}(1 \\to 2) \\psi_2 = \\frac{1}{\\sqrt{2}}(\\lvert 000 \\rangle + \\lvert 111 \\rangle)$。$\\lvert 000 \\rangle$ 分量不变（控制位 $1$ 为 $0$）。$\\lvert 011 \\rangle$ 分量的控制位 $1$ 为 $1$，因此目标位 $2$ 被翻转 ($\\lvert 011 \\rangle \\to \\lvert 111 \\rangle$)。\n- 最终态矢量具有非零振幅 $\\psi_{final}[0] = \\frac{1}{\\sqrt{2}}$ 和 $\\psi_{final}[7] = \\frac{1}{\\sqrt{2}}$。\n- $\\lvert 111 \\rangle$ 的概率：$P(\\lvert 111 \\rangle) = |\\psi_{final}[7]|^2 = |\\frac{1}{\\sqrt{2}}|^2 = \\frac{1}{2} = 0.5$。\n- 操作计数：$1$ 个单量子比特门和 $2$ 个 $\\mathrm{CNOT}$ 门。\n  - $H(0)$：$16$ 次乘法，$8$ 次加法。\n  - $\\mathrm{CNOT}(0 \\to 1)$：$6$ 次交换赋值。\n  - $\\mathrm{CNOT}(1 \\to 2)$：$6$ 次交换赋值。\n  - 总乘法次数：$16$。\n  - 总加法次数：$8$。\n  - 总交换次数：$6 + 6 = 12$。\n- 结果：$[0.5, 16, 8, 12, 3, 3]$。\n\n**用例 D：对合**\n- 电路：在量子比特 $2$ 上应用两次 $X$ 门。$n=3$，$d=2$。\n- 状态演化：由于 $X^2=I$ (单位矩阵)，应用两次该门等同于不执行任何操作。\n  - $\\psi_0 = \\lvert 000 \\rangle$。\n  - $\\psi_1 = X_2 \\psi_0 = \\lvert 100 \\rangle$。\n  - $\\psi_{final} = X_2 \\psi_1 = X_2 \\lvert 100 \\rangle = \\lvert 000 \\rangle$。\n- 最终状态为初始状态 $\\lvert 000 \\rangle$。\n- $\\lvert 111 \\rangle$ 的概率：$P(\\lvert 111 \\rangle) = |\\psi_{final}[7]|^2 = |0|^2 = 0$。\n- 操作计数：应用了 $2$ 个单量子比特门。\n  - 每个门的成本：$16$ 次乘法，$8$ 次加法。\n  - 总乘法次数：$2 \\times 16 = 32$。\n  - 总加法次数：$2 \\times 8 = 16$。\n  - 总交换次数：$0$。\n- 结果：$[0.0, 32, 16, 0, 3, 2]$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass QuantumCircuitSimulator:\n    \"\"\"\n    A classical state-vector simulator for a multi-qubit quantum circuit.\n    \"\"\"\n    def __init__(self, n: int):\n        \"\"\"\n        Initializes the simulator for n qubits in the |0...0> state.\n        \n        Args:\n            n (int): The number of qubits.\n        \"\"\"\n        if not isinstance(n, int) or n = 0:\n            raise ValueError(\"Number of qubits n must be a positive integer.\")\n        self.n = n\n        self.num_states = 1  n  # This is 2**n\n        \n        # State vector, initialized to |0...0\n        self.state_vector = np.zeros(self.num_states, dtype=np.complex128)\n        self.state_vector[0] = 1.0\n\n        # Operation counters\n        self.op_counts = {\n            'complex_mult': 0,\n            'complex_add': 0,\n            'swap_assign': 0\n        }\n\n    def _apply_single_qubit_gate(self, U: np.ndarray, target_qubit: int):\n        \"\"\"\n        Applies a single-qubit gate U to the target qubit.\n        \n        Args:\n            U (np.ndarray): A 2x2 unitary matrix.\n            target_qubit (int): The index of the qubit to act on.\n        \"\"\"\n        U = U.flatten() # U00, U01, U10, U11\n        \n        for i in range(self.num_states):\n            # Check if the target bit is 0\n            if (i >> target_qubit)  1 == 0:\n                j = i | (1  target_qubit) # Index with target bit flipped to 1\n                \n                psi_i = self.state_vector[i]\n                psi_j = self.state_vector[j]\n                \n                # U is flattened: U[0]=U00, U[1]=U01, U[2]=U10, U[3]=U11\n                self.state_vector[i] = U[0] * psi_i + U[1] * psi_j\n                self.state_vector[j] = U[2] * psi_i + U[3] * psi_j\n        \n        # Update counts based on the problem's cost model\n        self.op_counts['complex_mult'] += 4 * (1  (self.n - 1))\n        self.op_counts['complex_add'] += 2 * (1  (self.n - 1))\n\n    def _apply_cnot_gate(self, control_qubit: int, target_qubit: int):\n        \"\"\"\n        Applies a CNOT gate.\n        \n        Args:\n            control_qubit (int): The index of the control qubit.\n            target_qubit (int): The index of the target qubit.\n        \"\"\"\n        for i in range(self.num_states):\n            # Check if control bit is 1 and target bit is 0\n            is_control_one = ((i >> control_qubit)  1) == 1\n            is_target_zero = ((i >> target_qubit)  1) == 0\n\n            if is_control_one and is_target_zero:\n                j = i | (1  target_qubit) # Index with target bit flipped\n                # Swap amplitudes; temp var for swap\n                temp = self.state_vector[i]\n                self.state_vector[i] = self.state_vector[j]\n                self.state_vector[j] = temp\n        \n        # Update counts based on the problem's cost model\n        # For n qubits, there are 2^(n-2) pairs to swap.\n        # Each swap is 3 assignments.\n        if self.n >= 2:\n            self.op_counts['swap_assign'] += 3 * (1  (self.n - 2))\n\n    def h(self, target_qubit: int):\n        \"\"\"Applies a Hadamard gate.\"\"\"\n        H = (1 / np.sqrt(2)) * np.array([[1, 1], [1, -1]], dtype=np.complex128)\n        self._apply_single_qubit_gate(H, target_qubit)\n\n    def x(self, target_qubit: int):\n        \"\"\"Applies a Pauli-X gate.\"\"\"\n        X = np.array([[0, 1], [1, 0]], dtype=np.complex128)\n        self._apply_single_qubit_gate(X, target_qubit)\n\n    def cnot(self, control_qubit: int, target_qubit: int):\n        \"\"\"Applies a CNOT gate.\"\"\"\n        self._apply_cnot_gate(control_qubit, target_qubit)\n\n    def get_prob(self, index: int) -> float:\n        \"\"\"Returns the probability of measuring the state at a given index.\"\"\"\n        amplitude = self.state_vector[index]\n        return np.abs(amplitude)**2\n\n    def get_result(self, prob_index: int, circuit_depth: int) -> list:\n        \"\"\"Formats the result for a given test case.\"\"\"\n        prob = self.get_prob(prob_index)\n        return [\n            prob,\n            self.op_counts['complex_mult'],\n            self.op_counts['complex_add'],\n            self.op_counts['swap_assign'],\n            self.n,\n            circuit_depth\n        ]\n\ndef format_list(data: list) -> str:\n    \"\"\"Formats a list into a string without spaces, e.g., [1,2,3].\"\"\"\n    return f\"[{','.join(map(str, data))}]\"\n\ndef solve():\n    \"\"\"\n    Runs the simulation for all test cases and prints the final result.\n    \"\"\"\n    n_qubits = 3\n    prob_idx_111 = 7  # Index for |111 is 4*1 + 2*1 + 1*1 = 7\n\n    all_results = []\n\n    # Case A: Empty circuit\n    sim_a = QuantumCircuitSimulator(n_qubits)\n    depth_a = 0\n    all_results.append(sim_a.get_result(prob_idx_111, depth_a))\n\n    # Case B: Uniform superposition\n    sim_b = QuantumCircuitSimulator(n_qubits)\n    sim_b.h(0)\n    sim_b.h(1)\n    sim_b.h(2)\n    depth_b = 3\n    all_results.append(sim_b.get_result(prob_idx_111, depth_b))\n\n    # Case C: GHZ state\n    sim_c = QuantumCircuitSimulator(n_qubits)\n    sim_c.h(0)\n    sim_c.cnot(0, 1)\n    sim_c.cnot(1, 2)\n    depth_c = 3\n    all_results.append(sim_c.get_result(prob_idx_111, depth_c))\n\n    # Case D: Involution\n    sim_d = QuantumCircuitSimulator(n_qubits)\n    sim_d.x(2)\n    sim_d.x(2)\n    depth_d = 2\n    all_results.append(sim_d.get_result(prob_idx_111, depth_d))\n\n    # Format the final list of lists into a single string.\n    # The default str(list) adds spaces, which might not be desired.\n    # The problem description's example format `[caseA,caseB,...]` is ambiguous.\n    # We follow the f-string template from the problem, which produces spaces.\n    results_str = ','.join([str(res) for res in all_results])\n    \n    # Final print statement in the exact required format.\n    print(f\"[{results_str}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "量子算法并不仅限于线路模型，本练习将带你探索另一个强大范式：量子行走。你将通过模拟经典随机行走与量子行走在同一个图上的行为，并比较它们的传播动态，从而发现量子行走的独特性质，例如“弹道式”传播速度。这个对比鲜明地展示了量子动力学如何产生根本不同的行为，也使其成为开发新算法的一个充满希望的基础。",
            "id": "3242062",
            "problem": "你需要实现一个模拟，比较在同一个循环图上，由经典随机游走和离散时间量子游走 (DTQW) 产生的概率分布随离散时间的演化。该设定纯粹是数学和算法层面的，依赖于图论、概率论和量子力学的核心定义。大小为 $N$ 的循环图的顶点集为 $\\{0,1,\\dots,N-1\\}$，边连接在 $x$ 和 $(x\\pm 1) \\bmod N$ 之间。经典随机游走是一个马尔可夫链，其在循环图上的转移规则是以等概率移动到任一邻居。离散时间量子游走使用一个维度为 $2$ 的硬币空间和一个根据硬币状态向左或向右移动的移位算符。\n\n需要使用的基本依据和定义：\n- 令 $N \\in \\mathbb{N}$ 表示循环图的顶点数，令 $x \\in \\{0,1,\\dots,N-1\\}$ 表示一个顶点索引。令起始顶点为 $x_0 \\in \\{0,1,\\dots,N-1\\}$。\n- 时间 $t$ 时的经典随机游走分布，记为 $p^{\\mathrm{c}}_t(x)$（其中 $t \\in \\{0,1,\\dots,T\\}$），遵循更新规则 $p^{\\mathrm{c}}_{t+1}(x)=\\frac{1}{2}\\,p^{\\mathrm{c}}_{t}((x-1)\\bmod N)+\\frac{1}{2}\\,p^{\\mathrm{c}}_{t}((x+1)\\bmod N)$，初始条件为：若 $x=x_0$ 则 $p^{\\mathrm{c}}_0(x)=1$，否则为 $0$。这是一个经过充分检验的、用于描述对称随机游走在循环图上演化的公式。\n- 离散时间量子游走的状态存在于希尔伯特空间 $\\mathcal{H}_\\mathrm{coin}\\otimes\\mathcal{H}_\\mathrm{pos}$ 中，其中 $\\mathcal{H}_\\mathrm{coin}$ 是由 $\\{|0\\rangle,|1\\rangle\\}$ 张成的二维复向量空间，$\\mathcal{H}_\\mathrm{pos}$ 是由 $\\{|x\\rangle: x\\in\\{0,1,\\dots,N-1\\}\\}$ 张成的 $N$ 维复向量空间。硬币算符 $C$ 是作用于 $\\mathcal{H}_\\mathrm{coin}$ 的 Hadamard 算符 $H=\\frac{1}{\\sqrt{2}}\\begin{pmatrix}1  1\\\\ 1  -1\\end{pmatrix}$。条件移位算符 $S$ 的作用方式为 $S\\,|0\\rangle\\otimes|x\\rangle=|0\\rangle\\otimes|x-1 \\bmod N\\rangle$ 和 $S\\,|1\\rangle\\otimes|x\\rangle=|1\\rangle\\otimes|x+1 \\bmod N\\rangle$。量子游走的一步是酉算符 $U=S\\,(H\\otimes I_N)$，其中 $I_N$ 是作用于 $\\mathcal{H}_\\mathrm{pos}$ 的 $N\\times N$ 单位算符。令初始状态为 $|\\psi_0\\rangle=\\left(\\frac{|0\\rangle + i\\,|1\\rangle}{\\sqrt{2}}\\right)\\otimes|x_0\\rangle$。状态通过 $|\\psi_{t+1}\\rangle=U\\,|\\psi_t\\rangle$ 演化。根据玻恩定则，时间 $t$ 时的位置概率分布为 $p^{\\mathrm{q}}_t(x)=\\sum_{c\\in\\{0,1\\}}|\\langle c|\\otimes\\langle x|\\psi_t\\rangle|^2$。\n- 定义从 $x_0$ 到 $x$ 的循环图测地距离为 $d(x_0,x)=\\min\\left(\\left[(x-x_0)\\bmod N\\right],\\,N-\\left[(x-x_0)\\bmod N\\right]\\right)$。这计算了沿循环图所需的最少步数。\n- 定义在时间 $t$ 时分布 $p_t$ 的均方根位移为 $\\mathrm{RMSD}(t)=\\sqrt{\\sum_{x=0}^{N-1}p_t(x)\\,d(x_0,x)^2}$。\n- 为了在时间上聚合比较，计算在时间 $t\\in\\{0,1,\\dots,T\\}$ 内量子游走和经典游走均方根位移的时间平均差，即\n$$\n\\Delta(N,T,x_0)=\\frac{1}{T+1}\\sum_{t=0}^{T}\\left(\\mathrm{RMSD}^{\\mathrm{q}}(t)-\\mathrm{RMSD}^{\\mathrm{c}}(t)\\right),\n$$\n其中 $\\mathrm{RMSD}^{\\mathrm{q}}(t)$ 和 $\\mathrm{RMSD}^{\\mathrm{c}}(t)$ 分别从 $p^{\\mathrm{q}}_t(x)$ 和 $p^{\\mathrm{c}}_t(x)$ 计算得出。\n\n你的任务是编写一个完整、可运行的程序，该程序：\n- 构建酉算符 $U$ 并从指定的初始状态模拟 $|\\psi_t\\rangle$（其中 $t\\in\\{0,1,\\dots,T\\}$）。\n- 从指定的初始条件模拟经典分布 $p^{\\mathrm{c}}_t(x)$（其中 $t\\in\\{0,1,\\dots,T\\}$）。\n- 在每个时间 $t$ 计算 $p^{\\mathrm{q}}_t(x)$ 和 $p^{\\mathrm{c}}_t(x)$，评估 $\\mathrm{RMSD}^{\\mathrm{q}}(t)$ 和 $\\mathrm{RMSD}^{\\mathrm{c}}(t)$，并为下面定义的每个测试用例返回四舍五入到六位小数的 $\\Delta(N,T,x_0)$。\n\n测试套件：\n- 用例 1：$(N,T,x_0)=(32,12,0)$，通用正常路径，循环足够大，可以观察到弹道式扩散与扩散式传播，而不会立即发生回绕。\n- 用例 2：$(N,T,x_0)=(6,0,0)$，时间上的边界条件，只有初始分布起作用。\n- 用例 3：$(N,T,x_0)=(4,2,0)$，小循环，其中回绕和干涉效应显著。\n- 用例 4：$(N,T,x_0)=(50,20,17)$，较大的循环，起始顶点索引非零，以展示平移不变性。\n\n要求的最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，顺序与上述测试套件一致。例如，采用示意格式 $[\\Delta_1,\\Delta_2,\\Delta_3,\\Delta_4]$，其中每个 $\\Delta_k$ 是为用例 $k$ 定义的四舍五入后的浮点数。不应打印任何额外文本。",
            "solution": "用户的要求是实现一个对循环图上的经典随机游走和离散时间量子游走 (DTQW) 进行比较的模拟。该问题被验证为合理、适定且在马尔可夫链和量子力学原理上具有科学依据。\n\n### **问题验证**\n\n**步骤 1：提取已知信息**\n\n- **图：** 具有 $N$ 个顶点的循环图，标记为 $\\{0, 1, \\dots, N-1\\}$。边存在于 $x$ 和 $(x \\pm 1) \\pmod N$ 之间。\n- **参数：** 顶点数 $N$，总时间步数 $T$，起始顶点 $x_0$。\n- **经典随机游走 (CRW)：**\n    - 时间 $t$ 的概率分布：$p^{\\mathrm{c}}_t(x)$。\n    - 初始条件：$p^{\\mathrm{c}}_0(x) = \\delta_{x, x_0}$，其中 $\\delta$ 是克罗内克 δ。\n    - 更新规则：$p^{\\mathrm{c}}_{t+1}(x) = \\frac{1}{2} p^{\\mathrm{c}}_t((x-1) \\pmod N) + \\frac{1}{2} p^{\\mathrm{c}}_t((x+1) \\pmod N)$。\n- **离散时间量子游走 (DTQW)：**\n    - 希尔伯特空间：$\\mathcal{H} = \\mathcal{H}_{\\mathrm{coin}} \\otimes \\mathcal{H}_{\\mathrm{pos}}$，其中 $\\mathrm{dim}(\\mathcal{H}_{\\mathrm{coin}}) = 2$ 且 $\\mathrm{dim}(\\mathcal{H}_{\\mathrm{pos}}) = N$。\n    - 基态：硬币空间 $\\{|0\\rangle, |1\\rangle\\}$，位置空间 $\\{|x\\rangle\\}_{x=0}^{N-1}$。\n    - 硬币算符：Hadamard 算符 $H = \\frac{1}{\\sqrt{2}}\\begin{pmatrix} 1  1 \\\\ 1  -1 \\end{pmatrix}$。\n    - 条件移位算符：$S(|0\\rangle \\otimes |x\\rangle) = |0\\rangle \\otimes |(x-1) \\pmod N\\rangle$ 和 $S(|1\\rangle \\otimes |x\\rangle) = |1\\rangle \\otimes |(x+1) \\pmod N\\rangle$。\n    - 游走算符 (一步)：$U = S(H \\otimes I_N)$。\n    - 初始状态：$|\\psi_0\\rangle = \\left(\\frac{|0\\rangle + i|1\\rangle}{\\sqrt{2}}\\right) \\otimes |x_0\\rangle$。\n    - 状态演化：$|\\psi_{t+1}\\rangle = U|\\psi_t\\rangle$。\n    - 概率分布：$p^{\\mathrm{q}}_t(x) = \\sum_{c \\in \\{0,1\\}} |\\langle c| \\otimes \\langle x | \\psi_t \\rangle|^2$。\n- **度量指标：**\n    - 测地距离：$d(x_0, x) = \\min([(x-x_0) \\pmod N], N - [(x-x_0) \\pmod N])$。\n    - 均方根位移 (RMSD)：$\\mathrm{RMSD}(t) = \\sqrt{\\sum_{x=0}^{N-1} p_t(x) d(x_0, x)^2}$。\n    - 目标量：$\\Delta(N, T, x_0) = \\frac{1}{T+1} \\sum_{t=0}^{T} (\\mathrm{RMSD}^{\\mathrm{q}}(t) - \\mathrm{RMSD}^{\\mathrm{c}}(t))$。\n- **测试套件：**\n    - 用例 1：$(N, T, x_0) = (32, 12, 0)$\n    - 用例 2：$(N, T, x_0) = (6, 0, 0)$\n    - 用例 3：$(N, T, x_0) = (4, 2, 0)$\n    - 用例 4：$(N, T, x_0) = (50, 20, 17)$\n\n**步骤 2：使用提取的已知信息进行验证**\n\n该问题是一个标准的、形式化的计算任务，基于理论物理和计算机科学中已建立的模型。\n- **科学依据：** 经典随机游走（循环上的对称马尔可夫链）和离散时间量子游走（使用 Hadamard 硬币）的定义在各自领域都是标准的。所有数学公式都是正确的。\n- **适定性：** 问题提供了所有必要的初始条件、演化规则和一个精确定义的目标量。对于任何给定的有效输入元组 $(N, T, x_0)$，模拟是确定性的，并产生唯一的、有意义的结果。\n- **客观性：** 问题以精确的数学语言陈述，没有歧义或主观解释。\n- 问题通过了所有有效性检查。它不是不合理、不完整、不适定或琐碎的。\n\n**步骤 3：结论与行动**\n\n问题是有效的。将制定一个合理的解决方案。\n\n### **方法论与实现**\n\n任务的核心是模拟两个系统（一个经典，一个量子）的时间演化，并比较它们的统计特性。这将通过编程方式实现，使用 NumPy 进行高效的向量化计算。\n\n**1. 通用设置**\n\n对于每个测试用例 $(N, T, x_0)$，我们首先计算从起始顶点 $x_0$ 到循环图上所有其他顶点 $x$ 的测地距离的平方。创建一个顶点数组为 $v = \\{0, 1, \\dots, N-1\\}$。对每个 $x \\in v$ 计算距离 $d(x_0, x)$，将其平方并存储在一个数组 $d^2$ 中，以便在 RMSD 计算中重复使用。\n令 $v$ 是一个从 $0$ 到 $N-1$ 的顶点索引数组。\n模 $N$ 的距离计算为 $\\delta_x = (v - x_0) \\pmod N$。\n测地距离为 $d_x = \\min(\\delta_x, N - \\delta_x)$。\n平方距离为 $d^2_x = d_x^2$。\n\n**2. 经典随机游走模拟**\n\n经典概率分布 $p^{\\mathrm{c}}_t$ 由一个大小为 $N$ 的一维 NumPy 数组表示。\n- **初始化 ($t=0$)：** 分布是起始顶点处的一个 δ 函数。$p^{\\mathrm{c}}_0$ 是一个零数组，索引为 $x_0$ 的元素设置为 $1.0$。\n- **时间演化 ($t \\to t+1$)：** 更新规则 $p^{\\mathrmc}_{t+1}(x) = \\frac{1}{2}p^{\\mathrm{c}}_{t}((x-1)\\bmod N)+\\frac{1}{2}p^{\\mathrm{c}}_{t}((x+1)\\bmod N)$ 描述了一个卷积。这可以使用数组移位高效实现。如果 $p^{\\mathrm{c}}_t$ 是时间 $t$ 的分布数组，则时间 $t+1$ 的数组由 $p^{\\mathrm{c}}_{t+1} = 0.5 \\times (\\mathrm{roll}(p^{\\mathrm{c}}_t, 1) + \\mathrm{roll}(p^{\\mathrm{c}}_t, -1))$ 给出，其中 $\\mathrm{roll}(A, k)$ 将数组 $A$ 的元素循环移位 $k$ 个位置。\n- **模拟循环：** 我们从 $t=0$ 迭代到 $T$。在每一步中，我们首先计算 $\\mathrm{RMSD}^{\\mathrm{c}}(t) = \\sqrt{\\sum_x p^{\\mathrm{c}}_t(x) d^2_x}$，然后将分布 $p^{\\mathrm{c}}_t$ 更新为 $p^{\\mathrm{c}}_{t+1}$。\n\n**3. 离散时间量子游走模拟**\n\n量子态 $|\\psi_t\\rangle \\in \\mathcal{H}_{\\mathrm{coin}} \\otimes \\mathcal{H}_{\\mathrm{pos}}$ 由一个大小为 $2N$ 的一维复数 NumPy 数组表示。我们采用一种方便的索引方案，其中索引 $0, \\dots, N-1$ 对应于状态 $|0\\rangle \\otimes |x\\rangle$（对于 $x=0, \\dots, N-1$），索引 $N, \\dots, 2N-1$ 对应于 $|1\\rangle \\otimes |x\\rangle$。因此，状态向量在概念上可以分为两个大小为 $N$ 的子向量：$|\\psi\\rangle_0$（用于硬币态 $|0\\rangle$）和 $|\\psi\\rangle_1$（用于硬币态 $|1\\rangle$）。\n- **初始化 ($t=0$)：** 初始状态为 $|\\psi_0\\rangle = \\frac{1}{\\sqrt{2}}(|0\\rangle \\otimes |x_0\\rangle + i|1\\rangle \\otimes |x_0\\rangle)$。相应的状态向量初始化为零，除了索引 $x_0$ 处的元素设置为 $1/\\sqrt{2}$，索引 $N+x_0$ 处的元素设置为 $i/\\sqrt{2}$。\n- **时间演化 ($t \\to t+1$)：** 单步操作是应用酉算符 $U=S(H \\otimes I_N)$。这在两个子步骤中执行，而无需构建完整的 $2N \\times 2N$ 矩阵。\n    1.  **硬币算符 $(H \\otimes I_N)$：** 将此应用于状态 $|\\psi\\rangle = (|\\psi\\rangle_0, |\\psi\\rangle_1)$ 产生一个新状态 $|\\psi'\\rangle = (|\\psi'\\rangle_0, |\\psi'\\rangle_1)$，其中 $|\\psi'\\rangle_0 = \\frac{1}{\\sqrt{2}}(|\\psi\\rangle_0 + |\\psi\\rangle_1)$ 且 $|\\psi'\\rangle_1 = \\frac{1}{\\sqrt{2}}(|\\psi\\rangle_0 - |\\psi\\rangle_1)$。\n    2.  **移位算符 $(S)$：** 此算符作用于 $|\\psi'\\rangle$。硬币态 $|0\\rangle$ 的子向量向左（负方向）移位，硬币态 $|1\\rangle$ 的子向量向右（正方向）移位。下一个状态是 $|\\psi_{t+1}\\rangle_0 = \\mathrm{roll}(|\\psi'\\rangle_0, -1)$ 和 $|\\psi_{t+1}\\rangle_1 = \\mathrm{roll}(|\\psi'\\rangle_1, 1)$。\n- **模拟循环：** 我们从 $t=0$ 迭代到 $T$。在每一步中，我们首先计算位置概率分布 $p^{\\mathrm{q}}_t(x) = |(|\\psi_t\\rangle_0)_x|^2 + |(|\\psi_t\\rangle_1)_x|^2$。由此，我们计算 $\\mathrm{RMSD}^{\\mathrm{q}}(t) = \\sqrt{\\sum_x p^{\\mathrm{q}}_t(x) d^2_x}$。然后我们将状态 $|\\psi_t\\rangle$ 演化为 $|\\psi_{t+1}\\rangle$。\n\n**4. 最终计算**\n\n在对 $t \\in \\{0, \\dots, T\\}$ 运行两个模拟后，我们将收集到两个值列表：$\\{\\mathrm{RMSD}^{\\mathrm{c}}(t)\\}_{t=0}^T$ 和 $\\{\\mathrm{RMSD}^{\\mathrm{q}}(t)\\}_{t=0}^T$。最终的量 $\\Delta(N, T, x_0)$ 是这两个列表之间逐元素差的平均值。\n\n此过程系统地应用于问题陈述中指定的每个测试用例。然后按要求格式化结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_delta(N, T, x_0):\n    \"\"\"\n    Simulates classical and quantum walks on a cycle graph and calculates the\n    time-averaged difference in their root-mean-square displacements.\n\n    Args:\n        N (int): The number of vertices in the cycle graph.\n        T (int): The number of time steps for the simulation.\n        x_0 (int): The starting vertex index.\n\n    Returns:\n        float: The calculated value of Delta(N, T, x_0), rounded to 6 decimal places.\n    \"\"\"\n    # 1. Common setup: Pre-calculate squared geodesic distances\n    positions = np.arange(N, dtype=np.float64)\n    # Distances from x_0, considering the cycle's wrap-around\n    d_mod = (positions - x_0) % N\n    distances = np.minimum(d_mod, N - d_mod)\n    distances_sq = distances**2\n\n    # Lists to store RMSD values for each time step\n    rmsd_c_t = np.zeros(T + 1, dtype=np.float64)\n    rmsd_q_t = np.zeros(T + 1, dtype=np.float64)\n\n    # --- 2. Classical Random Walk Simulation ---\n    # Initial probability distribution p_c at t=0\n    p_c = np.zeros(N, dtype=np.float64)\n    p_c[x_0] = 1.0\n\n    for t in range(T + 1):\n        # Calculate RMSD for the current classical distribution\n        rmsd_c_t[t] = np.sqrt(np.sum(p_c * distances_sq))\n        \n        # Evolve the classical distribution for the next step (if not the last step)\n        if t  T:\n            # p_{t+1}(x) = 0.5 * p_t(x-1) + 0.5 * p_t(x+1)\n            # np.roll(p_c, 1) shifts right, getting p_t(x-1) at index x\n            # np.roll(p_c, -1) shifts left, getting p_t(x+1) at index x\n            p_c = 0.5 * (np.roll(p_c, 1) + np.roll(p_c, -1))\n\n    # --- 3. Discrete-Time Quantum Walk Simulation ---\n    # State psi is a 2N-dimensional complex vector.\n    # Indices 0 to N-1 for coin state |0\n    # Indices N to 2N-1 for coin state |1\n    psi = np.zeros(2 * N, dtype=np.complex128)\n    \n    # Initial state: (1/sqrt(2)) * (|0 + i|1) @ |x_0\n    sqrt2_inv = 1.0 / np.sqrt(2.0)\n    psi[x_0] = sqrt2_inv\n    psi[N + x_0] = 1j * sqrt2_inv\n\n    for t in range(T + 1):\n        # Calculate position probability distribution p_q from the quantum state\n        # p_q(x) = |0,x|psi>|^2 + |1,x|psi>|^2\n        psi_0_part = psi[:N]\n        psi_1_part = psi[N:]\n        p_q = np.abs(psi_0_part)**2 + np.abs(psi_1_part)**2\n\n        # Calculate RMSD for the current quantum distribution\n        rmsd_q_t[t] = np.sqrt(np.sum(p_q * distances_sq))\n\n        # Evolve the quantum state using U = S(H @ I)\n        if t  T:\n            # a. Apply Coin operator (Hadamard)\n            psi_prime_0 = sqrt2_inv * (psi_0_part + psi_1_part)\n            psi_prime_1 = sqrt2_inv * (psi_0_part - psi_1_part)\n\n            # b. Apply Shift operator\n            # S|0|x -> |0|x-1, a left shift for the |0 component\n            # S|1|x -> |1|x+1, a right shift for the |1 component\n            psi[:N] = np.roll(psi_prime_0, -1)\n            psi[N:] = np.roll(psi_prime_1, 1)\n            \n    # --- 4. Final Calculation ---\n    # Calculate the time-averaged difference of RMSDs\n    delta = np.mean(rmsd_q_t - rmsd_c_t)\n\n    return round(delta, 6)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, T, x_0)\n        (32, 12, 0),   # Case 1\n        (6, 0, 0),     # Case 2\n        (4, 2, 0),     # Case 3\n        (50, 20, 17),  # Case 4\n    ]\n\n    results = []\n    for case in test_cases:\n        N, T, x_0 = case\n        result = calculate_delta(N, T, x_0)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}