{
    "hands_on_practices": [
        {
            "introduction": "Shor算法的威力在于其量子核心，即周期查找。在深入探索量子力学之前，理解其要解决的经典问题至关重要。这个练习将带你通过直接计算，为一个小的合数找到分解它所需要的关键周期 $r$，从而为后续更复杂的步骤打下坚实的基础。",
            "id": "1447896",
            "problem": "考虑一个函数 $f$，它将非负整数映射到一个有限的整数集合，其定义规则为 $f(x) = a^x \\pmod{N}$，其中 $a$ 和 $N$ 是正整数，且 $a$ 和 $N$ 的最大公约数为 1。这个函数是周期性的。周期，记为 $r$，是满足 $a^r \\equiv 1 \\pmod{N}$ 的最小正整数。\n\n对于基数为 $a=7$ 且模为 $N=15$ 的特定情况，请通过直接计算确定函数 $f(x) = 7^x \\pmod{15}$ 的周期 $r$。",
            "solution": "题目要求我们找到 $a=7$ 模 $N=15$ 的周期（乘法阶）$r$，定义为满足 $7^{r} \\equiv 1 \\pmod{15}$ 的最小正整数 $r$。因为 $\\gcd(7,15)=1$，所以 $7$ 模 $15$ 的幂在模 $15$ 的乘法群中是良定义的。根据欧拉定理，$7^{\\varphi(15)} \\equiv 1 \\pmod{15}$，其中 $\\varphi(15)=\\varphi(3)\\varphi(5)=2 \\cdot 4 = 8$，因此阶 $r$ 必须是 $8$ 的因子。我们通过直接计算来找到满足条件的最小 $r$。\n\n使用性质：若 $x \\equiv y \\pmod{15}$，则 $7x \\equiv 7y \\pmod{15}$，计算 $7$ 模 $15$ 的连续幂次：\n\n$7^{1} \\equiv 7 \\pmod{15}$，不与 $1$ 同余。\n\n$7^{2} \\equiv 7 \\cdot 7 = 49 \\equiv 49 - 45 = 4 \\pmod{15}$，不与 $1$ 同余。\n\n$7^{3} \\equiv 7 \\cdot 7^{2} \\equiv 7 \\cdot 4 = 28 \\equiv 28 - 15 = 13 \\pmod{15}$，不与 $1$ 同余。\n\n$7^{4} \\equiv 7 \\cdot 7^{3} \\equiv 7 \\cdot 13 = 91 \\equiv 91 - 90 = 1 \\pmod{15}$。\n\n因此，满足 $7^{r} \\equiv 1 \\pmod{15}$ 的最小正整数 $r$ 是 $r=4$。这也与阶必须是 $8$ 的因子的事实相符，并且我们已经验证了在 $1,2,3$ 中没有更小的正指数能使结果模 $15$ 为 $1$。",
            "answer": "$$\\boxed{4}$$"
        },
        {
            "introduction": "在真实的Shor算法中，量子计算机的输出是一个测量值 $s$，我们需要通过经典算法将其解读为我们需要的周期 $r$。本练习模拟了这一关键的后处理步骤，你将使用连分数算法这一强大的数学工具，从一个假设的测量结果 $\\frac{s}{Q}$ 中提取出真正的周期，体验从量子输出到经典答案的转换过程。",
            "id": "132580",
            "problem": "在用于分解整数 $N$ 的Shor算法中，一个关键的子程序是找到一个选定的整数 $a$ 模 $N$ 的周期（或阶）$r$。周期 $r$ 是满足 $a^r \\equiv 1 \\pmod N$ 的最小正整数。这通过制备一个量子态并进行测量来实现，测量结果是一个介于 $0$ 和 $Q-1$ 之间的整数 $s$，其中 $Q=2^L$ 是一个计算寄存器的大小。测量值 $s$ 与周期 $r$ 通过近似关系 $\\frac{s}{Q} \\approx \\frac{k}{r}$ 相关联，其中 $k$ 是某个未知的整数。\n\n为了从这个近似值中找到 $r$，可以使用连分数算法。该算法能找到一系列称为收敛子的有理数，这些有理数是给定值的逐次更优的近似。这些收敛子的分母是周期 $r$ 的候选值。\n\n考虑Shor算法的一个应用，使用基数 $a=13$ 来分解数 $N=35$。算法的量子测量部分使用大小为 $Q=1024$ 的寄存器执行。测量结果得到分数 $\\frac{s}{Q} = \\frac{192}{1024}$。\n\n你的任务是找到函数 $f(x) = 13^x \\mod 35$ 的基本周期 $r$。对测量比率 $\\frac{s}{Q}$ 使用连分数算法来确定一组候选周期。通过测试这些候选值，找出其中一个是真实周期倍数的那个，并由此确定基本周期 $r$。",
            "solution": "1. 表示测量比率：\n$$\\frac{s}{Q}=\\frac{192}{1024}=\\frac{3}{16}.$$\n\n2. 构造 $3/16$ 的连分数：\n$$\\frac{3}{16}=0+\\cfrac{1}{5+\\cfrac{1}{3}}=[0;5,3].$$\n\n3. 通过递推关系计算收敛子 $p_n/q_n$\n$$p_{-1}=1,\\ p_0=0,\\quad q_{-1}=0,\\ q_0=1,$$\n$$p_{n+1}=a_{n+1}p_n+p_{n-1},\\quad q_{n+1}=a_{n+1}q_n+q_{n-1}.$$\n这里 $a_1=5,\\ a_2=3$ 给出\n- $n=1$: $p_1=1,\\ q_1=5\\implies1/5$,\n- $n=2$: $p_2=3,\\ q_2=16\\implies3/16$。\n\n4. 周期的候选分母是 $q_1=5$ 和 $q_2=16$ (以及 $q_0=1$)。\n\n5. 通过检查 $13^{r'}\\bmod35$ 来测试每个候选值 $r'$：\n- $r'=1:\\ 13^1\\equiv13\\not\\equiv1\\pmod{35}$,\n- $r'=5:\\ 13^5\\equiv13\\not\\equiv1\\pmod{35}$,\n- $r'=16:\\ 13^{16}=(13^4)^4\\equiv1^4\\equiv1\\pmod{35}.$\n\n6. 由于 $16$ 是真实周期的倍数，并且使 $13^r\\equiv1$ 成立的最小指数是 $r=4$，因此基本周期是\n$$r=4.$$",
            "answer": "$$\\boxed{4}$$"
        },
        {
            "introduction": "理论知识最终需要通过实践来巩固。这个练习将挑战你编写一个程序，用经典的计算方法来模拟Shor算法的整个因子分解逻辑。通过从头开始实现包括最大公约数、模幂运算和周期查找在内的核心组件，你将对算法的每一步都建立起深刻而直观的理解。",
            "id": "3256587",
            "problem": "要求您设计并实现一个完全确定性的经典计算程序，该程序模拟Shor算法的周期寻找子程序，以尝试对一个整数进行因数分解。其目标是使用模算术和最大公约数（GCD）的变体来探究数论算法的设计。该程序必须仅基于模算术的第一性原理和基本定义进行操作，不得使用任何内置的数论原语。\n\n起始定义和事实：\n- 对于一个正整数 $N \\geq 2$，定义模 $N$ 的整数环，记作 $\\mathbb{Z}_N = \\{0,1,2,\\dots,N-1\\}$，其加法和乘法均在模 $N$ 的意义下进行。\n- 模 $N$ 的单位元集合，记作 $\\mathbb{Z}_N^\\times$，是 $\\mathbb{Z}_N$ 中满足 $\\gcd(a,N) = 1$ 的元素 $a$ 的集合，其中 $\\gcd$ 表示最大公约数（GCD）。\n- 对于 $a \\in \\mathbb{Z}_N^\\times$， $a$ 对模 $N$ 的乘法阶，记作 $\\operatorname{ord}_N(a)$，是满足 $a^r \\equiv 1 \\pmod{N}$ 的最小正整数 $r$。\n\n任务描述：\n- 对于给定的整数 $N$，您的程序必须确定性地选择候选底数 $a$（其中 $1  a  N$），并通过二进制最大公约数（Binary GCD）算法（也称为Stein算法）计算 $\\gcd(a,N)$。不允许使用随机性；$a$ 的迭代必须按递增顺序进行。\n- 对于每个满足 $\\gcd(a,N)=1$ 的候选 $a$，仅使用模算术的第一性原理计算其乘法阶 $r = \\operatorname{ord}_N(a)$。通过重复平方实现模幂运算，以高效计算模 $N$ 的幂。\n- 基于第一性原理推导，并应用相关条件，判断所发现的周期 $r$ 是否可用于仅通过整数算术和GCD计算来获得 $N$ 的非平凡因子。如果发现非平凡因子，则停止并输出一个因子对。\n- 如果对于某个 $a$ 获得了非平凡因子，则输出一个包含两个因子的列表，按非递减顺序排列。如果没有成功的 $a$，则输出平凡因子对 $[1,N]$。\n\n算法约束：\n- 您必须实现二进制GCD算法来计算 $\\gcd(x,y)$，并且不得使用任何内置的欧几里得算法或最大公约数函数。\n- 您必须通过重复平方实现模幂运算，并且不得使用任何内置的模幂运算函数（例如，不得使用内置的 $a^b \\bmod N$ 运算符）。\n- 您不得使用任何随机数生成器；$a$ 的选择必须是纯粹确定性的。\n- 您的程序必须仅基于上述定义和模算术中广为接受的事实。不允许调用外部数论库。\n\n输入和单位：\n- 没有外部输入。不涉及物理单位或角度；所有值都是 $\\mathbb{Z}$ 中的整数。\n\n测试套件：\n- 您的程序必须按顺序内部评估以下八个测试用例，其 $N$ 值如下：\n  - $N = 15$\n  - $N = 21$\n  - $N = 33$\n  - $N = 35$\n  - $N = 91$\n  - $N = 16$\n  - $N = 13$\n  - $N = 2$\n\n输出规范：\n- 对于每个 $N$，生成一个整数列表 $[p,q]$，表示一个按非递减顺序排列的因子对。对于未找到非平凡因子的情况，输出 $[1,N]$。\n- 您的程序应生成单行输出，其中包含所有测试用例的结果，聚合为一个由这些列表组成的逗号分隔列表，不含空格，并用方括号括起来。例如，输出必须如下所示\n  $$[[p_1,q_1],[p_2,q_2],\\dots,[p_8,q_8]]$$\n  其中每个 $[p_i,q_i]$ 对应测试套件中第 $i$ 个 $N$ 的因子对，按顺序排列。",
            "solution": "该问题要求设计并实现一个确定性的经典算法，该算法模拟Shor算法的核心逻辑来寻找整数 $N$ 的因子。这涉及数论概念，特别是模算术和最大公约数（GCD）。解决方案按要求从第一性原理构建。\n\n核心思想是在模 $N$ 的整数环（记作 $\\mathbb{Z}_N$）中找到 $1$ 的一个非平凡平方根。$1$ 的非平凡平方根是一个整数 $x$，满足 $x^2 \\equiv 1 \\pmod{N}$ 但 $x \\not\\equiv \\pm 1 \\pmod{N}$。如果能找到这样的 $x$，那么 $x^2 - 1 = (x-1)(x+1)$ 就是 $N$ 的倍数。由于 $x \\not\\equiv \\pm 1 \\pmod{N}$，因此 $(x-1)$ 和 $(x+1)$ 都不是 $N$ 的倍数。这意味着 $N$ 的因子必然分布在 $(x-1)$ 和 $(x+1)$ 之间。因此，计算 $\\gcd(x-1, N)$ 将得到 $N$ 的一个非平凡因子。\n\n寻找这样一个 $x$ 的算法过程如下：对于一个待分解的给定整数 $N \\geq 2$，我们确定性地遍历范围在 $1  a  N$ 内的候选底数 $a$。对每个 $a$，我们首先计算 $g = \\gcd(a, N)$。如果 $g  1$，我们就找到了 $N$ 的一个非平凡因子，算法终止，返回因子对 $[g, N/g]$。根据问题约束，此GCD计算必须使用二进制GCD算法（Stein算法）执行，该算法通过位移、比较和减法操作，避免了除法运算。\n\n如果 $\\gcd(a, N) = 1$，那么 $a$ 是模 $N$ 整数乘法群（记作 $\\mathbb{Z}_N^\\times$）的一个元素。接着我们计算 $a$ 对模 $N$ 的乘法阶，即满足 $a^r \\equiv 1 \\pmod{N}$ 的最小正整数 $r$。这可以通过顺序计算 $a^1, a^2, a^3, \\dots$ 模 $N$ 直到结果为 $1$ 来找到。可表示为 `power = (power * a) % N`。\n\n一旦找到阶 $r$，我们检查它是否可用于寻找因子。这需要满足两个条件：\n1.  阶 $r$ 必须是偶数。\n2.  $a^{r/2} \\pmod{N}$ 的值不能等于 $-1 \\pmod{N}$（即 $N-1$）。\n\n如果 $r$ 是偶数，我们可以令 $x = a^{r/2}$。关系式 $a^r \\equiv 1 \\pmod{N}$ 就变成了 $x^2 \\equiv 1 \\pmod{N}$。根据阶的定义，$r$ 是使 $a^r \\equiv 1 \\pmod{N}$ 成立的*最小*正整数，所以 $x = a^{r/2} \\not\\equiv 1 \\pmod{N}$。如果我们也足够“幸运”，使得 $x \\not\\equiv -1 \\pmod{N}$，那么 $x$ 就是模 $N$ 的 $1$ 的一个非平凡平方根。然后我们可以通过计算 $p = \\gcd(x-1, N)$ 来找到一个非平凡因子 $p$。另一个因子是 $q = N/p$。算法随后终止并返回排序后的因子对 $[p, q]$。\n\n幂 $a^k \\pmod{N}$ 的计算，特别是对于 $x=a^{r/2}$，要求使用通过重复平方的模幂运算来实现。这是一个高效的算法，能在 $O(\\log k)$ 时间内计算出 $a^k \\pmod{N}$。\n\n如果对于给定的 $a$，$r$ 是奇数或者 $a^{r/2} \\equiv -1 \\pmod{N}$，那么这个 $a$ 的选择无法产生因子，算法将继续处理下一个候选 $a$。如果遍历完从 $2$ 到 $N-1$ 的所有可能的 $a$ 值后仍未找到任何非平凡因子，算法将断定 $N$ 可能是素数（或者该方法对合数 $N$ 失败），并返回平凡因子对 $[1, N]$。\n\n这整个过程是确定性的。程序中封装的主要步骤是：\n1.  一个遍历测试用例 $N$ 的外层循环。\n2.  一个接受 $N$ 并遍历从 $2$ 到 $N-1$ 的底数 $a$ 的内层函数。\n3.  二进制GCD算法的自定义实现。\n4.  通过重复平方的模幂运算的自定义实现。\n5.  在遍历 $a$ 的循环内的逻辑，用于测试 $\\gcd(a,N)$、找到阶 $r$ 并根据 $r$ 应用因数分解条件。\n\n通过应用此确定性算法，可以得出每个指定测试用例（$N \\in \\{15, 21, 33, 35, 91, 16, 13, 2\\}$）的解。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    It orchestrates the factorization for each N and prints the final result.\n    \"\"\"\n\n    def binary_gcd(u, v):\n        \"\"\"\n        Computes the greatest common divisor of two non-negative integers u and v\n        using the Binary GCD algorithm (Stein's algorithm).\n        \"\"\"\n        u, v = abs(u), abs(v)\n        if u == 0:\n            return v\n        if v == 0:\n            return u\n\n        # Find k, the greatest power of 2 that divides both u and v.\n        shift = 0\n        while ((u | v)  1) == 0:\n            u = 1\n            v = 1\n            shift += 1\n\n        # From here on, u is always odd.\n        while (u  1) == 0:\n            u = 1\n\n        while v != 0:\n            # v can be even, so remove all factors of 2.\n            while (v  1) == 0:\n                v = 1\n\n            # Now both u and v are odd. Swap if necessary so u = v.\n            if u  v:\n                u, v = v, u\n            \n            # v is now guaranteed to be v' >= u', and v' - u' is even.\n            v = v - u\n        \n        # Restore the common factors of 2.\n        return u  shift\n\n    def mod_exp(base, exp, mod):\n        \"\"\"\n        Computes (base^exp) % mod using the method of repeated squaring.\n        \"\"\"\n        result = 1\n        base %= mod\n        while exp  0:\n            if exp % 2 == 1:\n                result = (result * base) % mod\n            exp = 1\n            base = (base * base) % mod\n        return result\n\n    def factor_shor_emulator(N):\n        \"\"\"\n        Performs factorization of N using a deterministic classical emulation\n        of Shor's algorithm's period-finding subroutine.\n        \"\"\"\n        if N = 1:\n            # Problem statement implies N >= 2, but handle defensively.\n            return [1, N]\n        if N % 2 == 0:\n            # If N is even, the first choice of a=2 will have gcd(2,N)=2.\n            # Except if N=2 itself, where the loop range is empty.\n            if N == 2:\n                return [1, 2]\n            return [2, N // 2]\n\n        # Iterate through candidate bases a deterministically.\n        for a in range(2, N):\n            # Step 1: Check for a trivial factor using GCD.\n            g = binary_gcd(a, N)\n            if g  1:\n                p = g\n                q = N // p\n                return sorted([p, q])\n\n            # Step 2: If gcd(a, N) = 1, find the order r of a modulo N.\n            # We find the order using simple repeated multiplication.\n            power = a\n            r = 1\n            while power != 1:\n                power = (power * a) % N\n                r += 1\n\n            # Step 3: Use the order r to find factors.\n            # This is possible if r is even and a^(r/2) is not -1 mod N.\n            if r % 2 == 0:\n                x = mod_exp(a, r // 2, N)\n                if x != (N - 1):\n                    # Found a non-trivial square root of 1.\n                    p = binary_gcd(x - 1, N)\n                    q = N // p\n                    return sorted([p, q])\n\n        # If the loop completes without finding factors, return the trivial pair.\n        return [1, N]\n\n    # Define the test cases from the problem statement.\n    test_cases = [15, 21, 33, 35, 91, 16, 13, 2]\n\n    results = []\n    for N in test_cases:\n        result = factor_shor_emulator(N)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # e.g., [[3, 5],[3, 7],...]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}