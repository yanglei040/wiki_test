{
    "hands_on_practices": [
        {
            "introduction": "At its core, Shor's algorithm's remarkable ability to factor large numbers hinges on a classical number theory concept: periodicity. The quantum part of the algorithm is a highly efficient tool for finding the period, or order, of a modular exponentiation function $f(x) = a^x \\pmod{N}$. Before we can appreciate the quantum speedup, we must first have a solid grasp of what this period is and how to find it classically. This first exercise  provides a direct, hands-on opportunity to calculate the period for a small example, making the abstract target of the quantum computation clear and concrete.",
            "id": "1447896",
            "problem": "Consider a function $f$ that maps non-negative integers to a finite set of integers, defined by the rule $f(x) = a^x \\pmod{N}$, where $a$ and $N$ are positive integers such that the greatest common divisor of $a$ and $N$ is 1. This function is periodic. The period, denoted by $r$, is the smallest positive integer for which $a^r \\equiv 1 \\pmod{N}$.\n\nFor the specific case where the base is $a=7$ and the modulus is $N=15$, determine the period $r$ of the function $f(x) = 7^x \\pmod{15}$ by direct computation.",
            "solution": "We are asked to find the period (multiplicative order) $r$ of $a=7$ modulo $N=15$, defined as the smallest positive integer $r$ such that $7^{r} \\equiv 1 \\pmod{15}$. Since $\\gcd(7,15)=1$, powers of $7$ modulo $15$ are well-defined in the multiplicative group modulo $15$. By Euler's theorem, $7^{\\varphi(15)} \\equiv 1 \\pmod{15}$, where $\\varphi(15)=\\varphi(3)\\varphi(5)=2 \\cdot 4 = 8$, so the order $r$ must divide $8$. We proceed by direct computation to find the smallest such $r$.\n\nCompute successive powers of $7$ modulo $15$ using the property that if $x \\equiv y \\pmod{15}$, then $7x \\equiv 7y \\pmod{15}$:\n\n$7^{1} \\equiv 7 \\pmod{15}$, which is not congruent to $1$.\n\n$7^{2} \\equiv 7 \\cdot 7 = 49 \\equiv 49 - 45 = 4 \\pmod{15}$, which is not congruent to $1$.\n\n$7^{3} \\equiv 7 \\cdot 7^{2} \\equiv 7 \\cdot 4 = 28 \\equiv 28 - 15 = 13 \\pmod{15}$, which is not congruent to $1$.\n\n$7^{4} \\equiv 7 \\cdot 7^{3} \\equiv 7 \\cdot 13 = 91 \\equiv 91 - 90 = 1 \\pmod{15}$.\n\nThus the smallest positive integer $r$ such that $7^{r} \\equiv 1 \\pmod{15}$ is $r=4$. This also aligns with the fact that the order must divide $8$, and we have verified that no smaller positive exponent among $1,2,3$ yields $1$ modulo $15$.",
            "answer": "$$\\boxed{4}$$"
        },
        {
            "introduction": "A common misconception is that the quantum period-finding subroutine directly outputs the period $r$. In reality, it returns a measurement that gives us a fraction which is a close approximation of $\\frac{k}{r}$ for some unknown integer $k$. The challenge then shifts to a classical post-processing step: how do we deduce the integer $r$ from this approximation? This is where the continued fraction algorithm comes in, a powerful method for finding the best rational approximations of a given number. This practice problem  allows you to perform this crucial step, bridging the gap between the quantum measurement and the classical result needed for factorization.",
            "id": "132580",
            "problem": "In Shor's algorithm for factoring an integer $N$, a key subroutine involves finding the period, or order, $r$ of a chosen integer $a$ modulo $N$. The period $r$ is the smallest positive integer such that $a^r \\equiv 1 \\pmod N$. This is achieved by preparing a quantum state and performing a measurement, which results in an integer $s$ between $0$ and $Q-1$, where $Q=2^L$ is the size of a computational register. The measured value $s$ is related to the period $r$ by the approximation $\\frac{s}{Q} \\approx \\frac{k}{r}$ for some unknown integer $k$.\n\nTo find $r$ from this approximation, one can use the continued fraction algorithm. This algorithm finds a sequence of rational numbers, called convergents, that are successively better approximations to a given value. The denominators of these convergents are candidates for the period $r$.\n\nConsider an application of Shor's algorithm to factor the number $N=35$ using the base $a=13$. The quantum measurement part of the algorithm is performed with a register of size $Q=1024$. The measurement outcome yields the fraction $\\frac{s}{Q} = \\frac{192}{1024}$.\n\nYour task is to find the fundamental period $r$ of the function $f(x) = 13^x \\mod 35$. Use the continued fraction algorithm on the measured ratio $\\frac{s}{Q}$ to determine a set of candidate periods. By testing these candidates, identify the one that is a multiple of the true period, and from it, determine the fundamental period $r$.",
            "solution": "1. Express the measured ratio:\n$$\\frac{s}{Q}=\\frac{192}{1024}=\\frac{3}{16}.$$\n\n2. Form the continued fraction of $3/16$:\n$$\\frac{3}{16}=0+\\cfrac{1}{5+\\cfrac{1}{3}}=[0;5,3].$$\n\n3. Compute the convergents $p_n/q_n$ by the recurrence\n$$p_{-1}=1,\\ p_0=0,\\quad q_{-1}=0,\\ q_0=1,$$\n$$p_{n+1}=a_{n+1}p_n+p_{n-1},\\quad q_{n+1}=a_{n+1}q_n+q_{n-1}.$$\nHere $a_1=5,\\ a_2=3$ gives\n- $n=1$: $p_1=1,\\ q_1=5\\implies1/5$,\n- $n=2$: $p_2=3,\\ q_2=16\\implies3/16$.\n\n4. Candidate denominators for the period are $q_1=5$ and $q_2=16$ (and $q_0=1$).\n\n5. Test each candidate $r'$ by checking $13^{r'}\\bmod35$:\n- $r'=1:\\ 13^1\\equiv13\\not\\equiv1\\pmod{35}$,\n- $r'=5:\\ 13^5\\equiv13\\not\\equiv1\\pmod{35}$,\n- $r'=16:\\ 13^{16}=(13^4)^4\\equiv1^4\\equiv1\\pmod{35}.$\n\n6. Since $16$ is a multiple of the true period and the smallest exponent with $13^r\\equiv1 \\pmod{35}$ is $r=4$, the fundamental period is\n$$r=4.$$",
            "answer": "$$\\boxed{4}$$"
        },
        {
            "introduction": "Having explored the key conceptual components—the period of a function and the method to extract it from a measurement—it's time to synthesize this knowledge. While a full quantum simulation is beyond our scope, we can build a powerful classical emulator that implements the entire logical framework of Shor's algorithm. This final practice  challenges you to write a program that ties everything together. You will implement the deterministic parts of the algorithm from first principles, including finding the order and using it to discover factors, providing an integrated, hands-on understanding of the complete factoring process.",
            "id": "3256587",
            "problem": "You are asked to design and implement a fully deterministic, classical computation program that emulates the period-finding subroutine of Shor's algorithm to attempt factoring an integer. The aim is to probe number-theoretic algorithm design using modular arithmetic and variants of the Greatest Common Divisor (GCD). The program must operate solely on the basis of first principles and fundamental definitions in modular arithmetic, without using built-in number theory primitives.\n\nStarting point definitions and facts:\n- For a positive integer $N \\geq 2$, define the ring of integers modulo $N$, denoted $\\mathbb{Z}_N = \\{0,1,2,\\dots,N-1\\}$ with addition and multiplication performed modulo $N$.\n- The set of units modulo $N$, denoted $\\mathbb{Z}_N^\\times$, is the set of elements $a \\in \\mathbb{Z}_N$ such that $\\gcd(a,N) = 1$, where $\\gcd$ denotes the Greatest Common Divisor (GCD).\n- For $a \\in \\mathbb{Z}_N^\\times$, the multiplicative order of $a$ modulo $N$, denoted by $\\operatorname{ord}_N(a)$, is the smallest positive integer $r$ such that $a^r \\equiv 1 \\pmod{N}$.\n\nTask description:\n- For a given integer $N$, your program must deterministically select candidate bases $a$ with $1  a  N$ and $\\gcd(a,N)$ computed via the Binary Greatest Common Divisor (Binary GCD) algorithm (also known as Stein's algorithm). No randomness is allowed; iterate $a$ in increasing order.\n- For each candidate $a$ with $\\gcd(a,N)=1$, compute the multiplicative order $r = \\operatorname{ord}_N(a)$ using only modular arithmetic from first principles. Implement modular exponentiation via repeated squaring to efficiently compute powers modulo $N$.\n- Based on first-principles reasoning, derive and apply conditions under which the discovered period $r$ can be used to obtain nontrivial factors of $N$ using only integer arithmetic and GCD computations. If a nontrivial factor is discovered, stop and output a factor pair.\n- If a nontrivial factor is obtained for some $a$, output a list containing the two factors in nondecreasing order. If no such $a$ succeeds, output the trivial pair $[1,N]$.\n\nAlgorithmic constraints:\n- You must implement the Binary GCD algorithm to compute $\\gcd(x,y)$ and must not use any built-in Euclidean algorithm or greatest common divisor function.\n- You must implement modular exponentiation by repeated squaring and must not use any built-in modular exponentiation function (e.g., no usage of a built-in $a^b \\bmod N$ operator).\n- You must not use any random number generator; the selection of $a$ must be purely deterministic.\n- You must base the program only on the above definitions and widely accepted facts from modular arithmetic. No external number theory library calls are permitted.\n\nInput and units:\n- There is no external input. No physical units or angles are involved; all values are integers in $\\mathbb{Z}$.\n\nTest suite:\n- Your program must internally evaluate the following eight test cases, in order, with values of $N$:\n  - $N = 15$\n  - $N = 21$\n  - $N = 33$\n  - $N = 35$\n  - $N = 91$\n  - $N = 16$\n  - $N = 13$\n  - $N = 2$\n\nOutput specification:\n- For each $N$, produce one list $[p,q]$ of integers representing a factor pair in nondecreasing order. For cases where no nontrivial factor is found, output $[1,N]$.\n- Your program should produce a single line of output containing the results for all test cases, aggregated as a comma-separated list of these lists with no spaces, enclosed in square brackets. For example, the output must look like\n  $$[[p_1,q_1],[p_2,q_2],\\dots,[p_8,q_8]]$$\n  where each $[p_i,q_i]$ corresponds to the factor pair for the $i$-th $N$ in the test suite, in order.",
            "solution": "The problem requires the design and implementation of a deterministic, classical algorithm that emulates the core logic of Shor's algorithm to find factors of an integer $N$. This involves number-theoretic concepts, specifically modular arithmetic and the greatest common divisor (GCD). The solution is constructed from first principles as specified.\n\nThe core idea is to find a non-trivial square root of $1$ in the ring of integers modulo $N$, denoted $\\mathbb{Z}_N$. A non-trivial square root of $1$ is an integer $x$ such that $x^2 \\equiv 1 \\pmod{N}$ but $x \\not\\equiv \\pm 1 \\pmod{N}$. If such an $x$ can be found, then $x^2 - 1 = (x-1)(x+1)$ is a multiple of $N$. Since $x \\not\\equiv \\pm 1 \\pmod{N}$, neither $(x-1)$ nor $(x+1)$ is a multiple of $N$. This implies that the factors of $N$ must be split between $(x-1)$ and $(x+1)$. Consequently, computing $\\gcd(x-1, N)$ will yield a non-trivial factor of $N$.\n\nThe algorithm to find such an $x$ proceeds as follows:\nFor a given integer $N \\geq 2$ to be factored, we deterministically iterate through candidate bases $a$ in the range $1  a  N$. For each $a$, we first compute $g = \\gcd(a, N)$. If $g  1$, we have found a non-trivial factor of $N$, and the algorithm terminates, returning the factor pair $[g, N/g]$. As per the problem constraints, this GCD computation must be performed using the Binary GCD algorithm (Stein's algorithm), which operates using bitwise shifts, comparisons, and subtractions, avoiding division.\n\nIf $\\gcd(a, N) = 1$, then $a$ is an element of the multiplicative group of integers modulo $N$, denoted $\\mathbb{Z}_N^\\times$. We then compute the multiplicative order of $a$ modulo $N$, which is the smallest positive integer $r$ such that $a^r \\equiv 1 \\pmod{N}$. This is found by sequentially computing $a^1, a^2, a^3, \\dots$ modulo $N$ until the result is $1$. Let this be `power = (power * a) % N`.\n\nOnce the order $r$ is found, we check if it can be used to find a factor. This occurs if two conditions are met:\n1.  The order $r$ must be an even number.\n2.  The value of $a^{r/2} \\pmod{N}$ must not be equal to $-1 \\pmod{N}$ (which is $N-1$).\n\nIf $r$ is even, we can set $x = a^{r/2}$. The relation $a^r \\equiv 1 \\pmod{N}$ becomes $x^2 \\equiv 1 \\pmod{N}$. By the definition of order, $r$ is the *smallest* positive integer for which $a^r \\equiv 1 \\pmod{N}$, so $x = a^{r/2} \\not\\equiv 1 \\pmod{N}$. If we are also \"lucky\" enough that $x \\not\\equiv -1 \\pmod{N}$, then $x$ is a non-trivial square root of $1$ modulo $N$. We can then find a non-trivial factor $p$ by computing $p = \\gcd(x-1, N)$. The other factor is $q = N/p$. The algorithm then terminates and returns the sorted factor pair $[p, q]$.\n\nThe computation of powers $a^k \\pmod{N}$, specifically for $x=a^{r/2}$, is required to be implemented using modular exponentiation by repeated squaring. This is an efficient algorithm that computes $a^k \\pmod{N}$ in $O(\\log k)$ time.\n\nIf for a given $a$, either $r$ is odd or $a^{r/2} \\equiv -1 \\pmod{N}$, that choice of $a$ fails to produce a factor, and the algorithm proceeds to the next candidate $a$. If the loop over all possible values of $a$ from $2$ to $N-1$ completes without finding any non-trivial factors, the algorithm concludes that $N$ is likely prime (or the method failed for the composite $N$) and returns the trivial factor pair $[1, N]$.\n\nThis entire procedure is deterministic. The main steps encapsulated in the program are:\n1.  An outer loop iterating through test cases $N$.\n2.  An inner function that takes $N$ and iterates through bases $a$ from $2$ to $N-1$.\n3.  A custom implementation of the Binary GCD algorithm.\n4.  A custom implementation of modular exponentiation by repeated squaring.\n5.  Logic within the loop over $a$ to test $\\gcd(a,N)$, find the order $r$, and apply the factoring conditions based on $r$.\n\nThe solution for each of the specified test cases ($N \\in \\{15, 21, 33, 35, 91, 16, 13, 2\\}$) is derived by applying this deterministic algorithm.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    It orchestrates the factorization for each N and prints the final result.\n    \"\"\"\n\n    def binary_gcd(u, v):\n        \"\"\"\n        Computes the greatest common divisor of two non-negative integers u and v\n        using the Binary GCD algorithm (Stein's algorithm).\n        \"\"\"\n        u, v = abs(u), abs(v)\n        if u == 0:\n            return v\n        if v == 0:\n            return u\n\n        # Find k, the greatest power of 2 that divides both u and v.\n        shift = 0\n        while ((u | v)  1) == 0:\n            u >>= 1\n            v >>= 1\n            shift += 1\n\n        # From here on, u is always odd.\n        while (u  1) == 0:\n            u >>= 1\n\n        while v != 0:\n            # v can be even, so remove all factors of 2.\n            while (v  1) == 0:\n                v >>= 1\n\n            # Now both u and v are odd. Swap if necessary so u = v.\n            if u > v:\n                u, v = v, u\n            \n            # v is now guaranteed to be v' >= u', and v' - u' is even.\n            v = v - u\n        \n        # Restore the common factors of 2.\n        return u  shift\n\n    def mod_exp(base, exp, mod):\n        \"\"\"\n        Computes (base^exp) % mod using the method of repeated squaring.\n        \"\"\"\n        result = 1\n        base %= mod\n        while exp > 0:\n            if exp % 2 == 1:\n                result = (result * base) % mod\n            exp >>= 1\n            base = (base * base) % mod\n        return result\n\n    def factor_shor_emulator(N):\n        \"\"\"\n        Performs factorization of N using a deterministic classical emulation\n        of Shor's algorithm's period-finding subroutine.\n        \"\"\"\n        if N = 1:\n            # Problem statement implies N >= 2, but handle defensively.\n            return [1, N]\n        if N % 2 == 0:\n            # If N is even, the first choice of a=2 will have gcd(2,N)=2.\n            # Except if N=2 itself, where the loop range is empty.\n            if N == 2:\n                return [1, 2]\n            return [2, N // 2]\n\n        # Iterate through candidate bases a deterministically.\n        for a in range(2, N):\n            # Step 1: Check for a trivial factor using GCD.\n            g = binary_gcd(a, N)\n            if g > 1:\n                p = g\n                q = N // p\n                return sorted([p, q])\n\n            # Step 2: If gcd(a, N) = 1, find the order r of a modulo N.\n            # We find the order using simple repeated multiplication.\n            power = a\n            r = 1\n            while power != 1:\n                power = (power * a) % N\n                r += 1\n\n            # Step 3: Use the order r to find factors.\n            # This is possible if r is even and a^(r/2) is not -1 mod N.\n            if r % 2 == 0:\n                x = mod_exp(a, r // 2, N)\n                if x != (N - 1):\n                    # Found a non-trivial square root of 1.\n                    p = binary_gcd(x - 1, N)\n                    q = N // p\n                    return sorted([p, q])\n\n        # If the loop completes without finding factors, return the trivial pair.\n        return [1, N]\n\n    # Define the test cases from the problem statement.\n    test_cases = [15, 21, 33, 35, 91, 16, 13, 2]\n\n    results = []\n    for N in test_cases:\n        result = factor_shor_emulator(N)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # e.g., [[3, 5],[3, 7],...]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}