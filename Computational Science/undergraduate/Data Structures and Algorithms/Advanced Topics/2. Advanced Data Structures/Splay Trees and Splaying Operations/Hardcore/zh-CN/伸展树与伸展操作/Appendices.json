{
    "hands_on_practices": [
        {
            "introduction": "伸展树虽然有良好的均摊性能保证，但理解其单次操作的性能边界也至关重要。这个练习将引导你从第一性原理出发，构建一个特定的操作序列，该序列会使单次伸展操作的成本达到线性时间复杂度 $O(N)$。通过这个练习，你将能深刻理解为什么我们需要均摊分析来评估伸展树的真实效率，并看到理论上的“最坏情况”是如何在实践中构造出来的。",
            "id": "3269554",
            "problem": "自平衡二叉搜索树 (BST) 是一种二叉搜索树，它在操作期间执行结构调整，以在不于每个节点存储显式平衡信息的情况下，维持有利的高度界限。伸展树是一个典型的例子：它执行一系列称为伸展 (splaying) 的旋转操作，将被访问的节点移动到根部。基本原语是单次旋转和三种伸展步骤，定义在一个节点 $x$ 及其父节点 $p$ 和祖父节点 $g$ 上：zig（当 $x$ 没有祖父节点时应用），zig-zig（当 $x$ 和 $p$ 同为左孩子或同为右孩子时应用），以及 zig-zag（当 $x$ 和 $p$ 位于相对侧时应用）。每次旋转都是常数时间的指针重排。考虑在伸展树上执行以下操作序列，该树在插入和搜索后使用经典的自底向上伸展方法，并且没有重复的键：\n\n- 从一棵空树开始。\n- 按严格递减的顺序 $N,N-1,\\dots,2,1$ 插入键，每次插入一个键 $k$ 后，立即对 $k$ 应用伸展操作（这是伸展树插入的标准做法）。\n- 然后执行对键 $N$ 的搜索，在搜索结束时对 $N$ 应用伸展操作。\n\n请从基本原理和伸展步骤的定义（zig、zig-zig、zig-zag）出发，推导出在最后一次对 $N$ 的搜索和伸展过程中执行的单次旋转的确切次数，作为 $N$ 的函数。请将最终答案表示为关于 $N$ 的封闭形式表达式。无需四舍五入，也无单位。您的推导必须从 BST 属性和伸展步骤的定义开始，不得借助未经证明的关于伸展树均摊界的捷径。在最后一次搜索之前，序列形成的树的形状的正确性必须使用这些基本原语和 BST 的顺序属性来证明。最终答案必须是关于 $N$ 的单个解析表达式。",
            "solution": "该问题要求从基本原理出发，推导在一系列特定的插入操作之后，于伸展树中搜索并接着伸展键 $N$ 的过程中，所执行的单次旋转的确切次数。\n\n解答分为两个主要部分。首先，我们确定在指定的插入序列之后，伸展树的精确结构。其次，我们基于此结构分析对 $N$ 的搜索以及对节点 $N$ 的伸展操作，以计算旋转次数。\n\n**第一部分：确定伸展树的结构**\n\n初始状态是一棵空树。键 $N, N-1, \\dots, 2, 1$ 按顺序插入。每次插入键 $k$ 后，包含 $k$ 的节点会被伸展到根部。\n\n我们将通过归纳法证明，在插入键 $N, N-1, \\dots, k$（对于 $1 \\le k \\le N$）之后，所得到的树是一个以 $k$ 为根的右倾链（一条“棍子”）。树中的节点为 $\\{k, k+1, \\dots, N\\}$，对于该集合中任何满足 $i  N$ 的节点 $i$，其右孩子是 $i+1$，其左孩子为空。\n\n**基本情况：** 第一个插入的键是 $N$。\n- 树只包含一个节点 $N$。伸展此节点没有效果，因为它已经是根节点。\n- 树是一个以 $N$ 为根、长度为 $1$ 的右倾链。该命题对于 $k=N$ 成立。\n\n**归纳假设：** 假设在插入键 $N, N-1, \\dots, k+1$ 之后，树是一个以 $k+1$ 为根的右倾链。其结构为：\n$$(k+1) \\rightarrow_R (k+2) \\rightarrow_R \\dots \\rightarrow_R N$$\n其中 $\\rightarrow_R$ 表示一个右孩子链接。\n\n**归纳步骤：** 现在我们插入键 $k$。\n1.  根据二叉搜索树 (BST) 的性质，要插入 $k$，我们从根节点 $k+1$ 开始。由于 $k  k+1$，我们必须向左移动。\n2.  根据归纳假设，根节点 $k+1$ 没有左孩子。因此，新节点 $k$ 被作为 $k+1$ 的左孩子插入。\n3.  在插入之后、伸展 $k$ 之前，树的结构是以 $k+1$ 为根，其左孩子为 $k$，并保留其原有的右子树。\n4.  下一步是伸展新插入的节点 $k$。节点 $k$ 的父节点是 $p = k+1$。父节点 $p$ 是树的根，所以 $k$ 没有祖父节点。\n5.  根据伸展步骤的定义，当要伸展的节点（$x=k$）有父节点但没有祖父节点时，执行一次 **Zig** 步骤。这包括一次单旋转，使 $x$ 成为新的根。\n6.  在此情况下，$k$ 是 $k+1$ 的左孩子。在 $k+1$ 和 $k$ 之间的边上执行一次右旋转。\n7.  旋转之后，$k$ 成为新的根节点。其前父节点 $k+1$ 成为 $k$ 的右孩子。$k$ 原来的右子树（为空）成为 $k+1$ 的左孩子。$k+1$ 原来的右子树保持为其右子树。\n8.  最终得到的树以 $k$ 为根，其右孩子是 $k+1$，后者的右孩子是 $k+2$，以此类推。结构为：\n$$k \\rightarrow_R (k+1) \\rightarrow_R (k+2) \\rightarrow_R \\dots \\rightarrow_R N$$\n这是一个以 $k$ 为根的右倾链。归纳完毕。\n\n通过此归纳论证，在插入从 $N$ 到 $1$ 的所有键之后，树的最终结构（对于 $k=1$）是一个以 $1$ 为根的右倾链：\n$$1 \\rightarrow_R 2 \\rightarrow_R 3 \\rightarrow_R \\dots \\rightarrow_R (N-1) \\rightarrow_R N$$\n\n**第二部分：分析最终的搜索和伸展操作**\n\n最后的操作是搜索键 $N$，然后将其节点伸展到根部。\n\n**搜索路径：**\n- 对 $N$ 的搜索从根节点开始，即键为 $1$ 的节点。\n- 由于 $N > 1$，我们遍历到右孩子，即节点 $2$。\n- 由于 $N > 2$，我们遍历到右孩子，即节点 $3$。\n- 这个过程沿着右倾链继续下去，直到我们到达键为 $N$ 的节点。\n- 遍历的路径是 $1 \\rightarrow 2 \\rightarrow \\dots \\rightarrow N$。\n- 节点的深度是指从根节点到该节点的路径上的边数。到 $N$ 的路径有 $N-1$ 条边。因此，节点 $N$ 的深度为 $d = N-1$。\n\n**伸展操作：**\n现在我们从深度 $d=N-1$ 的位置伸展节点 $N$。从根到 $N$ 的路径完全由右孩子链接组成。设 $x$ 为正在被伸展的节点，初始时 $x=N$。\n\n- 在我们的树中，只要 $x$ 有祖父节点 $g$，其父节点为 $p$。$x$ 是 $p$ 的右孩子，$p$ 是 $g$ 的右孩子。这种配置需要执行 **Zig-Zig** 步骤。\n- 一个 Zig-Zig 步骤包含两次单旋转。其效果是将 $x$ 在树中向上移动两层，取代其祖父节点。\n\n- 在一条直路径上，对一个深度为 $d$ 的节点进行伸展的过程如下：\n  1.  只要节点有祖父节点，就重复应用 Zig-Zig 步骤。每个 Zig-Zig 步骤消耗 $2$ 次旋转，并将节点的深度减少 $2$。可能执行的 Zig-Zig 步骤数为 $\\lfloor d/2 \\rfloor$。\n  2.  这些步骤产生的总旋转次数为：$2 \\times \\lfloor d/2 \\rfloor$。\n  3.  这些步骤之后，节点的剩余深度为 $d_{rem} = d - 2 \\times \\lfloor d/2 \\rfloor$。这等价于 $d \\pmod 2$。\n  4.  如果 $d_{rem} = 1$（当且仅当 $d$ 为奇数时发生），节点现在是根的子节点。它有父节点但没有祖父节点。需要一个最终的 **Zig** 步骤。一个 Zig 步骤消耗 $1$ 次旋转，并使该节点成为根。\n  5.  如果 $d_{rem} = 0$（当且仅当 $d$ 为偶数时发生），该节点已成为根，操作完成。\n\n单次旋转的总数是所有 Zig-Zig 步骤和最后可能的 Zig 步骤所产生的旋转次数之和。\n总旋转次数 $= (2 \\times \\text{Zig-Zig 步骤数}) + (1 \\times \\text{Zig 步骤数})$\n总旋转次数 $= 2 \\times \\lfloor d/2 \\rfloor + (d \\pmod 2)$。\n\n对于任何非负整数 $d$，表达式 $2 \\lfloor d/2 \\rfloor + (d \\pmod 2)$ 恒等于 $d$。\n- 如果 $d$ 是偶数，$d=2k$ 对于某个整数 $k \\ge 0$。表达式变为 $2 \\times \\lfloor 2k/2 \\rfloor + (2k \\pmod 2) = 2 \\times k + 0 = 2k = d$。\n- 如果 $d$ 是奇数，$d=2k+1$ 对于某个整数 $k \\ge 0$。表达式变为 $2 \\times \\lfloor (2k+1)/2 \\rfloor + ((2k+1) \\pmod 2) = 2 \\times k + 1 = 2k+1 = d$。\n\n所以，从一条深度为 $d$ 的直线上伸展一个节点的总旋转次数恰好是 $d$。\n\n在我们的问题中，要伸展的节点是 $N$，其深度为 $d = N-1$。\n将此代入我们的结果，单次旋转的总次数是 $N-1$。\n\n这对所有 $N \\ge 1$ 都成立。\n- 如果 $N=1$，树只有节点 $1$。搜索在根部找到它（深度 $d=0$）。旋转次数为 $0$。我们的公式给出 $1-1=0$。\n- 如果 $N1$，深度 $d=N-1 \\ge 1$，推导出的计数成立。\n\n因此，在最后一次对 $N$ 的搜索和伸展过程中执行的单次旋转的确切次数是 $N-1$。",
            "answer": "$$\\boxed{N-1}$$"
        },
        {
            "introduction": "与上一个关注单次最坏情况的练习不同，本练习将分析一个操作序列的总体成本。我们将从一个极端退化的树结构（一条向右的长链）开始，并对其进行顺序访问。这个练习揭示了伸展树的核心优势：即使初始状态不佳或单步成本很高，通过一系列操作的动态调整，其总体均摊成本可以非常高效。",
            "id": "3273374",
            "problem": "考虑一个初始固定的二叉搜索树 (BST)，它包含键 $1,2,3,\\dots,n$，并排列成一条严格右偏的路径：根节点是键 $1$，对于每个 $i \\in \\{1,2,\\dots,n-1\\}$，键为 $i$ 的节点没有左子节点，其右子节点是键为 $i+1$ 的节点。假设在伸展树中每次成功访问后，都会应用标准的自底向上伸展操作：对于一个节点 $x$，其父节点为 $p$，祖父节点为 $g$，伸展操作包括重复执行以下分类的旋转，直到 $x$ 成为根节点：\n- 当 $p$ 是根节点时，进行一次单旋转 ($\\text{zig}$)；\n- 当 $x$ 和 $p$ 都是其各自祖先的左子节点或都是右子节点时（同侧情况），进行两次旋转 ($\\text{zig-zig}$)；\n- 当 $x$ 和 $p$ 位于异侧时（异侧情况），进行两次旋转 ($\\text{zig-zag}$)。\n每次旋转在总旋转次数中计为一单位。\n\n您按升序对键进行一次完整的顺序访问，即访问序列 $(1,2,3,\\dots,n)$，并在每次成功访问后，使用上述规则将被访问的节点伸展至根。\n\n仅从二叉搜索树排序和自底向上伸展旋转的基本定义出发，推导出在整个 $n$ 次访问序列中执行的总旋转次数的精确封闭形式表达式（用 $n$ 表示）。将您的最终答案表示为关于 $n$ 的精确符号表达式，不含不等式。无需四舍五入。",
            "solution": "让我们将初始树表示为 $T_0$。根据问题描述，$T_0$ 是一条严格右偏的路径。根节点是键为 $1$ 的节点。对于 $i \\in \\{1, 2, \\dots, n-1\\}$，节点 $i$ 的右子节点是节点 $i+1$。键为 $n$ 的节点是一个叶节点。设 $C_k$ 为伸展键 $k$ 时执行的旋转次数。总旋转次数为 $C_{\\text{total}} = \\sum_{k=1}^{n} C_k$。\n\n**步骤 1：访问键 $k=1$**\n访问的是键 $1$。在初始树 $T_0$ 中，键为 $1$ 的节点是根节点。对根节点进行伸展操作不执行任何动作。因此，旋转次数为 $C_1 = 0$。\n树的结构保持不变。我们将此步骤后的树称为 $T_1$。因此，$T_1$ 与 $T_0$ 相同。\n\n**步骤 2：访问键 $k=2$**\n访问的是键 $2$。我们正在处理树 $T_1$。在 $T_1$ 中，键为 $2$ 的节点是根节点（键为 $1$）的右子节点。\n要伸展的节点是 $x=2$。其父节点是 $p=1$。由于父节点 $p$ 是树的根，这种情况对应于一次 `zig` 操作。一次 `zig` 操作包括一次单旋转。由于 $x$ 是一个右子节点，在 $p$ 和 $x$ 之间的边上执行一次左旋。\n这次单旋转的代价是 $1$ 个单位。所以，$C_2 = 1$。\n在节点 $1$ 处进行左旋后，节点 $2$ 成为新的根。节点 $1$ 成为节点 $2$ 的左子节点。节点 $2$ 原来的右子树，即路径 $3 \\to 4 \\to \\dots \\to n$，仍然是新根 $2$ 的右子树。\n得到的树 $T_2$ 的根是 $2$，左子节点是 $1$，右子节点是 $3$（它是右偏路径 $3 \\to \\dots \\to n$ 的根）。\n\n**推广过程**\n我们可以观察到一个模式。让我们为 $k \\ge 2$ 建立一个归纳假设。\n假设：在开始访问键 $k$ 时，树 $T_{k-1}$（伸展键 $k-1$ 之后的状态）的根是键 $k-1$。键 $k$ 是根的右子节点。\n\n基本情况 ($k=2$)：我们已经确定，在访问键 $2$ 时，树是 $T_1$，其中根是 $1$，其右子节点是 $2$。假设成立。\n\n归纳步骤：假设对于某个整数 $k \\ge 2$，该假设成立。也就是说，在访问键 $k$ 之前，树 $T_{k-1}$ 的根是 $k-1$，其右子节点是 $k$。\n现在，我们对键 $k$ 进行访问。\n要伸展的节点是 $x=k$。其父节点是 $p=k-1$。由于父节点 $p$ 是 $T_{k-1}$ 的根，伸展操作是一个 `zig` 步骤，包括一次单旋转。因此，代价是 $C_k = 1$。\n在根 $k-1$ 处执行一次左旋。这使得 $k$ 成为新的根。旧根 $k-1$ 成为 $k$ 的左子节点。$k$ 原来的右子树仍然是它的右子树。在树 $T_{k-1}$ 中，$k$ 的右子节点是 $k+1$。因此，在新树 $T_k$ 中，$k$ 是根，其右子节点是 $k+1$。\n这个结构与下一步 $k+1$ 的假设相符。因此，归纳假设对所有 $k \\in \\{2, 3, \\dots, n\\}$ 都成立。\n\n**计算总旋转次数**\n基于此分析，我们可以确定序列 $(1, 2, \\dots, n)$ 中每次访问的代价。\n- 对于 $k=1$：节点 $1$ 是根，所以 $C_1 = 0$ 次旋转。\n- 对于 $k \\in \\{2, 3, \\dots, n\\}$：节点 $k$ 始终是根（即 $k-1$）的右子节点。伸展操作是一个单 `zig` 步骤，代价为 $1$ 次旋转。所以，$C_k = 1$。\n\n总旋转次数 $C_{\\text{total}}$ 是每次访问的旋转次数之和：\n$$C_{\\text{total}} = \\sum_{k=1}^{n} C_k = C_1 + \\sum_{k=2}^{n} C_k$$\n代入我们找到的代价：\n$$C_{\\text{total}} = 0 + \\sum_{k=2}^{n} 1$$\n求和 $\\sum_{k=2}^{n} 1$ 包含 $n-1$ 项，每项都等于 $1$。\n$$C_{\\text{total}} = n-1$$\n这就是总旋转次数的精确封闭形式表达式。\n\n让我们对较小的 $n$ 值进行检查。\n- 如果 $n=1$，总旋转次数 = $1-1=0$。这是正确的，因为伸展根节点的代价为 $0$。\n- 如果 $n=2$，总旋转次数 = $2-1=1$。访问 $1$ 的代价为 $0$。访问 $2$ 的代价为 $1$（`zig` 旋转）。总计为 $1$。正确。\n- 如果 $n=3$，总旋转次数 = $3-1=2$。访问 $1$ 的代价为 $0$。访问 $2$ 的代价为 $1$。访问 $3$ 的代价为 $1$。总计为 $2$。正确。\n推导出的公式是一致的。",
            "answer": "$$\n\\boxed{n-1}\n$$"
        },
        {
            "introduction": "理论分析为我们提供了性能的边界，而经验验证则能让我们直观地感受算法在真实场景中的行为。这个动手编程练习将让你实现一棵伸展树，并将其与静态平衡二叉搜索树在多种访问模式下的性能进行比较。通过测量具有不同局部性特征的访问序列的成本，你将能够把“引用局部性”等抽象概念与具体的性能数据联系起来，从而获得对伸展树适用场景的实践性理解。",
            "id": "3273326",
            "problem": "您的任务是使用两种搜索树模型——静态平衡二叉搜索树 (BST) 和带有标准伸展操作的伸展树 (Splay Tree)——来构造并评估一系列作用于有序键集合的访问排列。二叉搜索树 (BST) 定义为一种有根二叉树，对其进行中序遍历会按排序顺序产生键；伸展树是一种自适应二叉搜索树，每次访问后会执行伸展旋转操作，通过称为 zig、zig-zig 和 zig-zag 的操作将被访问的节点移动到根部。推理的基本依据必须从核心定义出发：平衡二叉搜索树的高度为 $\\Theta(\\log n)$，因此搜索任何键需要 $\\Theta(\\log n)$ 次比较；而伸展树通过旋转动态地重组自身，其性能由引用局部性和工作集大小等结构特性决定。目标是构造一个排列族，在该族中，静态平衡二叉搜索树上的静态贪心搜索在单位成本模型下达到 $O(m \\log n)$，而伸展树在经验上表现更优；然后对导致这种性能差距的排列特性提出假设。\n\n形式上，考虑有序键集合 $\\{1,2,\\dots,n\\}$ 和一个作为这些键的排列的访问序列，因此访问次数为 $m=n$。在同一键集合上初始化两棵树：\n- 一棵在 $\\{1,2,\\dots,n\\}$ 上通过中位数递归构建的完全平衡的二叉搜索树，在所有访问过程中保持静态。\n- 一棵初始化为相同完全平衡结构的伸展树，每次访问后执行标准的伸展旋转（zig、zig-zig、zig-zag）以将被访问节点移动到根部。\n\n使用以下单位成本模型来量化处理单次访问的成本：\n- 静态平衡二叉搜索树成本：成本等于在从根到键的搜索路径上访问的节点数。由于二叉搜索树是平衡的，其高度为 $\\Theta(\\log n)$，因此每次搜索的成本为 $\\Theta(\\log n)$ 次节点访问，总成本为 $O(m \\log n)$。\n- 伸展树成本：成本等于在从根到键的搜索路径上访问的节点数，加上在伸展过程中执行的旋转次数（将每次单次旋转计为成本 $1$）。对于伸展操作，将 zig 视为一次旋转，将 zig-zig 和 zig-zag 各视为两次旋转，以反映实际执行的指针更改。\n\n您的程序必须构造以下排列族，并为每个排列计算静态平衡二叉搜索树总成本与伸展树总成本的比率，两者均根据上述单位成本模型计算。所有情况均使用 $n=64$，并在键 $\\{1,\\dots,64\\}$ 上构建初始树：\n- 情况 $1$（升序排列）：访问序列为 $[1,2,\\dots,64]$。\n- 情况 $2$（步长为4的排列）：按模 $4$ 的余数对索引进行分区，并按列主序访问：$[1,5,9,\\dots,61,2,6,10,\\dots,62,3,7,11,\\dots,63,4,8,12,\\dots,64]$。\n- 情况 $3$（步长为32的排列）：与情况 $2$ 类似，但步长为 $32$。\n- 情况 $4$（位反转排列）：将索引 $0$ 到 $63$ 解释为 $6$ 位的二进制数，反转每个索引的位，然后加 $1$ 以映射回键空间 $\\{1,\\dots,64\\}$。\n- 情况 $5$（交替极值，或锯齿形）：访问序列为 $[64,1,63,2,62,3,\\dots]$，交替访问剩余的最大键和最小键。\n\n对于每种情况，计算：\n- 静态平衡二叉搜索树的总成本，即在静态树下所有 $n$ 次访问的节点访问次数之和。\n- 伸展树的总成本，即所有 $n$ 次访问中，节点访问次数与将被访问节点伸展到根部时执行的旋转次数的总和。\n\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，第 $i$ 个元素是情况 $i$ 的静态平衡二叉搜索树总成本与伸展树总成本的比率，四舍五入到 $6$ 位小数。例如，输出格式必须与 $[r_1,r_2,r_3,r_4,r_5]$ 完全一样，其中每个 $r_i$ 是一个四舍五入到 $6$ 位小数的浮点数。不应读取任何输入；测试套件已按上述规定固定。关于导致性能差距的特性的假设必须在解决方案中讨论，这些假设源于基本定义和程序测量的经验结果。",
            "solution": "该问题要求对静态平衡二叉搜索树 (BST) 和动态伸展树 (Splay Tree) 进行比较分析。此分析将通过模拟它们在 $n=64$ 时对键集 $\\{1, 2, \\dots, n\\}$ 上的五种不同访问排列的性能来进行。任务的核心是实现指定的数据结构和成本模型，计算每种排列的总操作成本，并推导出静态 BST 成本与伸展树成本的比率。随后，将基于数据结构的理论原则，针对观察到的性能差异，对这些排列的特性提出假设。\n\n### 1. 模型定义\n\n设 $S = \\{1, 2, \\dots, n\\}$ 为键的集合，其中 $n=64$。访问次数为 $m=n=64$。\n\n**静态平衡二叉搜索树**：\n静态二叉搜索树在键集 $S$ 上构建一次后保持不变。构建方法指定为“中位数递归”：对于一个键的范围 `[low, high]`，选择位于索引 `mid = floor((low + high) / 2)` 的键作为子树的根，然后对子范围 `[low, mid-1]` 和 `[mid+1, high]` 递归应用此过程。虽然被称为“完全平衡”，但对于 $n=64$（其形式不是 $2^k-1$），这种构建方法产生的是一棵近乎平衡但并非严格意义上的完整二叉树的树。然而，其结构是唯一确定的。\n\n单次访问的成本定义为从根到包含被访问键的节点路径上访问的节点数。根的深度为 $1$。对于一个访问序列，总成本是每次单独访问成本的总和。由于指定的访问序列是 $S$ 中所有键的一个排列，因此静态二叉搜索树的总成本是树中所有节点深度的总和，即 $\\sum_{k=1}^{n} \\text{depth}(k)$。对于五种排列中的任何一种，这个总成本都是恒定的。\n\n**伸展树**：\n伸展树是一种自适应二叉搜索树。它初始化时具有与静态二叉搜索树完全相同的结构。每次访问一个键后，会对被访问的节点执行“伸展”(splaying) 操作，将其移动到树的根部。该操作由一系列旋转组成。标准的伸展步骤如下：\n- **Zig**：当被访问节点的父节点是根节点时执行。它涉及一次旋转。\n- **Zig-Zig**：当被访问节点及其父节点都是左孩子或都是右孩子时执行。它涉及两次旋转。\n- **Zig-Zag**：当被访问节点是右孩子而其父节点是左孩子（或反之）时执行。它涉及两次旋转。\n\n伸展树的成本模型更为复杂，同时考虑了搜索和重构。单次访问的成本是以下两项之和：\n$1.$ 搜索键时访问的节点数（即伸展前节点的深度）。\n$2.$ 随后伸展操作中执行的旋转次数。每个 zig 步骤成本为 $1$，而 zig-zig 和 zig-zag 步骤成本为 $2$，反映了基本旋转的次数。\n\n总成本是在整个排列上对这些单次访问成本求和。\n\n### 2. 访问排列与性能假设分析\n\n伸展树的性能在很大程度上取决于引用局部性原则。具有高时间或空间局部性的访问模式允许伸展树调整其结构，使频繁或最近访问的元素靠近根部，从而减少后续访问时间。所选的排列旨在展示一系列不同的局部性特性。\n\n**情况 1：升序排列 $[1, 2, \\dots, 64]$**\n该序列在键空间中表现出很强的空间局部性，但对于伸展树而言，这是一个已知的病态情况。访问最小的键 $1$ 会使其成为根，并将所有其他节点排列成一条长链作为其右子孙。随后访问键 $2$ 需要遍历此链，使 $2$ 成为新根，并重新形成另一条长链。每次访问基本上都需要遍历一条线性时间路径。第 $i$ 次访问的成本近似与 $i$ 成正比，导致总成本为 $O(n^2)$。静态二叉搜索树维持对数时间的访问，总成本为 $O(n \\log n)$。\n*假设*：伸展树的性能将显著差于静态二叉搜索树。成本比率（BST/Splay）预计将远小于 $1$。\n\n**情况 2：步长为4的排列 $[1, 5, \\dots, 61, 2, 6, \\dots]$**\n此模式以固定步长访问键，有效地交错了四个升序序列。虽然它打破了简单的顺序局部性，但它具有另一种规律性。访问像 $1, 5, 9, \\dots$ 这样的键可能会在树结构中表现出一定的局部性，因为伸展一个键可能会将来自同一余数类的其他键带到离根更近的位置。这是一个经典的例子，用于测试伸展树处理步进式内存访问模式的能力。\n*假设*：此模式具有中等局部性。伸展树的自适应特性可能有益，也可能无益，这取决于伸展操作如何与步进式访问相互作用。性能预计与静态二叉搜索树相当，或者可能稍好。比率应接近 $1$。\n\n**情况 3：步长为32的排列 $[1, 33, 2, 34, \\dots]$**\n此排列对 $i=1, \\dots, 32$ 重复地在两个键 $i$ 和 $i+32$ 之间交替。此模式呈现了一个小的、移动的键“工作集” $\\{i, i+32\\}$。伸展树的摊还分析保证了在最近访问的键集较小时具有高效的性能。访问 $i$ 之后，会访问键 $i+32$。伸展 $i$ 会重构树；然后，伸展 $i+32$ 也做同样的事情。对一对键的频繁访问应能使伸展树将它们保持在离根相对较近的位置。\n*假设*：伸展树预计能很好地适应这个小工作集。其性能应优于静态二叉搜索树每次访问的固定对数成本。比率应大于 $1$。\n\n**情况 4：位反转排列**\n此排列通过反转索引 $0, \\dots, 63$ 的二进制表示的位来生成。众所周知，它表现出较差的局部性；访问序列中的连续元素在键空间中往往相距很远（例如，索引 $0 \\to$ 键 $1$，索引 $1 \\to$ 键 $33$）。这种伪随机的访问模式几乎没有提供可供伸展树利用的规律性。\n*假设*：在没有明显局部性的情况下，伸展树的自适应启发式策略不太可能提供显著优势。重构的成本可能会抵消任何偶然的好处。性能预计与静态二叉搜索树非常相似。比率应接近 $1$。\n\n**情况 5：交替极值（锯齿形）排列 $[64, 1, 63, 2, \\dots]$**\n该序列重复访问可用键中的最大值和最小值。伸展树的“动态指定理”(Dynamic Finger Theorem)指出，在访问键 $y$ 之后访问键 $x$ 的成本与 $O(\\log |x-y|)$ 成正比。在这种情况下，连续访问之间的距离 $|x-y|$ 总是很大。这表明每次访问都将是昂贵的。树将在每一步中被急剧重构（例如，将最大元素移动到根部，然后将最小元素移动到根部）。\n*假设*：这种模式在每次访问时都强制进行最大程度的重构。访问远距离键所带来的高成本表明，伸展树的性能不会超过静态二叉搜索树，并且由于伸展的开销，其性能可能会更差。比率预计小于或等于 $1$。\n\n### 3. 经验验证\n提供的 Python 程序按描述实现了模拟。它计算了两种树类型在所有五种排列下的总成本，并计算了指定的性能比率。这些经验结果用于验证或驳斥上述假设，为伸展树在这些不同访问模式下的行为提供了具体数据。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np # Imported as per spec, but not strictly necessary for this logic.\n\nclass Node:\n    \"\"\"A node in a binary search tree.\"\"\"\n    def __init__(self, key, parent=None, left=None, right=None):\n        self.key = key\n        self.parent = parent\n        self.left = left\n        self.right = right\n\n    def __repr__(self):\n        return f\"Node({self.key})\"\n\nclass SplayTree:\n    \"\"\"Implementation of a Splay Tree.\"\"\"\n    def __init__(self, keys):\n        self.root = self._build_balanced_tree(keys)\n\n    def _build_balanced_tree(self, keys):\n        \"\"\"Builds a balanced BST using median recursion and sets parent pointers.\"\"\"\n        sorted_keys = sorted(keys)\n        return self._build_recursive(sorted_keys, 0, len(sorted_keys) - 1, None)\n\n    def _build_recursive(self, keys, low, high, parent):\n        if low  high:\n            return None\n        mid = (low + high) // 2\n        node = Node(keys[mid], parent=parent)\n        node.left = self._build_recursive(keys, low, mid - 1, node)\n        node.right = self._build_recursive(keys, mid + 1, high, node)\n        return node\n    \n    def _left_rotate(self, x):\n        y = x.right\n        x.right = y.left\n        if y.left is not None:\n            y.left.parent = x\n        y.parent = x.parent\n        if x.parent is None:\n            self.root = y\n        elif x == x.parent.left:\n            x.parent.left = y\n        else:\n            x.parent.right = y\n        y.left = x\n        x.parent = y\n\n    def _right_rotate(self, x):\n        y = x.left\n        x.left = y.right\n        if y.right is not None:\n            y.right.parent = x\n        y.parent = x.parent\n        if x.parent is None:\n            self.root = y\n        elif x == x.parent.right:\n            x.parent.right = y\n        else:\n            x.parent.left = y\n        y.right = x\n        x.parent = y\n\n    def _splay(self, x):\n        \"\"\"Splays node x to the root and returns the number of rotations.\"\"\"\n        rotations = 0\n        while x.parent is not None:\n            p = x.parent\n            g = p.parent\n            if g is None:  # Zig\n                if x == p.left:\n                    self._right_rotate(p)\n                else:\n                    self._left_rotate(p)\n                rotations += 1\n            elif x == p.left and p == g.left:  # Zig-Zig\n                self._right_rotate(g)\n                self._right_rotate(p)\n                rotations += 2\n            elif x == p.right and p == g.right:  # Zig-Zig\n                self._left_rotate(g)\n                self._left_rotate(p)\n                rotations += 2\n            elif x == p.right and p == g.left:  # Zig-Zag\n                self._left_rotate(p)\n                self._right_rotate(g)\n                rotations += 2\n            else:  # Zig-Zag (x is left child, p is right child)\n                self._right_rotate(p)\n                self._left_rotate(g)\n                rotations += 2\n        return rotations\n\n    def access(self, key):\n        \"\"\"Accesses a key, splays it, and returns the total cost.\"\"\"\n        # 1. Search for the key and find depth (search cost)\n        node = self.root\n        search_cost = 0\n        if node is None:\n            return 0\n        \n        while node is not None and node.key != key:\n            search_cost += 1\n            if key  node.key:\n                node = node.left\n            else:\n                node = node.right\n        \n        if node is None: # Should not happen for this problem's permutations\n            return search_cost \n\n        search_cost += 1 # Count the node itself\n\n        # 2. Splay the node and find rotation cost\n        rotation_cost = self._splay(node)\n\n        return search_cost + rotation_cost\n\ndef get_static_bst_cost(n):\n    \"\"\"Calculates the total cost for a static BST for a permutation of all keys.\"\"\"\n    depths = {}\n    \n    def build_and_get_depths(low, high, depth):\n        if low  high:\n            return\n        mid = (low + high) // 2\n        depths[mid] = depth\n        build_and_get_depths(low, mid - 1, depth + 1)\n        build_and_get_depths(mid + 1, high, depth + 1)\n\n    build_and_get_depths(1, n, 1)\n    # The total cost is the sum of depths for all nodes, as the permutation accesses each key once.\n    return sum(depths.values())\n\ndef generate_permutations(n):\n    \"\"\"Generates the five specified access permutations for n keys.\"\"\"\n    perms = {}\n    \n    # Case 1: Ascending\n    perms[1] = list(range(1, n + 1))\n    \n    # Case 2: Stride-4\n    perms[2] = [j for i in range(1, 5) for j in range(i, n + 1, 4)]\n    \n    # Case 3: Stride-32\n    perms[3] = [j for i in range(1, 33) for j in range(i, n + 1, 32)]\n    \n    # Case 4: Bit-reversal\n    seq = []\n    num_bits = (n - 1).bit_length()\n    for i in range(n):\n        binary_i = f'{i:0{num_bits}b}'\n        rev_binary_i = binary_i[::-1]\n        rev_i = int(rev_binary_i, 2)\n        seq.append(rev_i + 1)\n    perms[4] = seq\n\n    # Case 5: Alternating extremes\n    keys_list = list(range(1, n + 1))\n    seq = []\n    while keys_list:\n        seq.append(keys_list.pop())\n        if keys_list:\n            seq.append(keys_list.pop(0))\n    perms[5] = seq\n    \n    return perms\n\ndef solve():\n    \"\"\"Main function to run the simulation and produce the output.\"\"\"\n    n = 64\n    keys = list(range(1, n + 1))\n    \n    # Calculate static BST cost (this is constant for all cases)\n    static_bst_total_cost = get_static_bst_cost(n)\n    \n    # Generate the 5 test permutations\n    permutations = generate_permutations(n)\n    \n    results = []\n    for case_num in sorted(permutations.keys()):\n        perm = permutations[case_num]\n        \n        # Initialize a new splay tree for each case\n        splay_tree = SplayTree(keys)\n        \n        splay_total_cost = 0\n        for key in perm:\n            cost = splay_tree.access(key)\n            splay_total_cost += cost\n            \n        ratio = static_bst_total_cost / splay_total_cost\n        results.append(f\"{ratio:.6f}\")\n        \n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}