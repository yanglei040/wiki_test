{
    "hands_on_practices": [
        {
            "introduction": "要真正掌握像斐波那契堆这样复杂的数据结构，理解其核心不变量至关重要。一个有效的学习方法是观察当这些不变量被破坏时会发生什么。这个练习  引导你故意实现一个有缺陷的 `decrease-key` 操作，通过对比正确与错误的行为，你将深刻体会到“切分”和“级联切分”操作对于维护堆序属性和最小指针正确性的关键作用。",
            "id": "3234524",
            "problem": "考虑一个斐波那契堆，它是一个满足堆序性质的树的集合。堆序性质规定，对于每个键值为 $k(u)$ 的节点 $u$ 及其每个键值为 $k(v)$ 的子节点 $v$，关系 $k(u) \\leq k(v)$ 必须成立。一个标准的斐波那契堆维护一个指针 $min(H)$，该指针指向堆 $H$ 中所有根节点里键值最小的那个根节点。本练习的基本依据是堆序性质的核心定义，以及由该性质推导出的一个不变量：堆的最小元素必须是一个根节点。\n\n实现两个版本的斐波那契堆：\n- 一个遵循常规定义和不变量的正确版本。\n- 一个错误版本，其 $\\text{decrease-key}$ 操作仅将节点的键值设为新值，但不执行任何剪切操作（即使新键值严格小于其父节点的键值从而违反堆序性质），并且在减小键值后不更新全局最小指针 $min(H)$。这种错误行为必须被有意地实现。\n\n您必须在堆 $H$ 上验证以下不变量：\n- 堆序不变量：对于每条边 $(u,v)$，其中 $v$ 是 $u$ 的子节点，必须满足 $k(u) \\leq k(v)$。\n- 最小指针不变量：$min(H)$ 指向一个根节点，该节点的键值等于 $H$ 中所有节点的最小键值。\n\n设计一个包含三个操作序列的测试套件。对于每个序列，将其应用于正确版本和错误版本的堆，并生成一个布尔值，以指示该序列是否通过在错误堆上违反至少一个不变量而揭示了该错误，同时正确堆保持了所有不变量。这些序列是：\n\n- 序列 $S_1$（揭示堆序违规的一般情况）：\n  1. 将键值 $20$, $7$, $25$, $17$, $26$, $18$ 插入一个初始为空的堆 $H$。\n  2. 执行一次 $extract\\text{-}min$ 操作。\n  3. 选择任意一个非根节点 $x$（即满足 $parent(x) \\neq \\varnothing$ 的节点）。设 $p$ 为其父节点，$k(p)$ 为其键值。执行 $\\text{decrease-key}(x, k(p) - 5)$ 操作。\n\n- 序列 $S_2$（根节点键值减小揭示最小指针违规）：\n  1. 将键值 $30$, $10$, $40$ 插入一个初始为空的堆 $H$。\n  2. 设 $r$ 为当前键值为 $30$ 的根节点。执行 $\\text{decrease-key}(r, 5)$ 操作。\n\n- 序列 $S_3$（保持不变量的边界情况）：\n  1. 将键值 $50$, $60$, $70$, $80$ 插入一个初始为空的堆 $H$。\n  2. 执行一次 $extract\\text{-}min$ 操作。\n  3. 选择任意一个父节点为 $p$ 的非根节点 $x$。执行 $\\text{decrease-key}(x, k(p))$ 操作。\n\n对于每个序列 $S_i$，您的程序必须计算一个布尔结果，该结果为 $true$ 当且仅当错误堆违反了所述不变量中的至少一个而正确堆没有违反，否则为 $false$。您的程序应生成单行输出，其中包含以逗号分隔并用方括号括起来的结果列表，例如 $[true,false,true]$。\n\n本问题中给出的所有数值均为无量纲整数；不涉及物理单位。不涉及角度。不涉及百分比。\n\n您的解决方案必须是一个完整、可运行的程序，该程序构建正确和错误的堆，执行指定的序列，检查不变量，并以所描述的精确格式输出三个测试用例的聚合布尔结果。",
            "solution": "用户提供的问题陈述已经过分析和验证。它在科学上基于数据结构和算法的既定原则，特别是关于斐波那契堆的原则。该问题是适定的、客观的，并包含一套完整、一致的实现和测试规范。没有发现与科学合理性、可形式化性、完整性、可行性或结构相关的缺陷。因此，该问题被认定为**有效**。\n\n下面是一个根据问题要求设计的完整解决方案。这涉及实现一个 `Node` 类、一个包含共享功能的 `BaseFibHeap` 类，以及两个子类 `CorrectFibHeap` 和 `FaultyFibHeap`，它们在 `decrease_key` 方法上有所不同。解决方案中包含了不变量检查方法，用于在操作后验证堆的属性。最后，在两个堆的变体上执行三个测试序列，以确定错误实现的缺陷是否被揭示。\n\n### 数据结构\n\n定义了一个 `Node` 类来表示堆中的一个元素。每个节点存储其 `key`、用于构建树和列表的指针 `parent`、`child`、`left` 和 `right`。它还维护其 `degree`（子节点数量）和一个用于 `decrease_key` 操作的布尔标记 `mark`。为了根据测试序列的要求唯一地标识节点以便检索，还添加了一个 `initial_key` 属性。\n\n`BaseFibHeap` 类封装了两种堆实现的通用逻辑。这包括 `insert`、`extract_min` 以及辅助函数 `consolidate`，这些在两个版本中都是相同的。它还包含用于验证两个关键不变量的方法：\n1.  **堆序不变量**：`_check_heap_order` 遍历所有节点，以确保对于每个节点 `u` 及其子节点 `v`，都有 `k(u) \\leq k(v)`。\n2.  **最小指针不变量**：`_check_min_pointer` 验证 `min_node` 指针引用一个根节点，该节点的键值是堆中所有键值的最小值。\n\n### 堆的实现\n\n1.  **`CorrectFibHeap`**：该类实现了标准的斐波那契堆算法。其 `decrease_key` 方法通过执行 `cut` 和 `cascading_cut` 操作来正确处理违反堆序性质的情况，并且在创建了新的最小值时会更新堆的最小指针。\n\n2.  **`FaultyFibHeap`**：该类继承自 `BaseFibHeap`，但用问题中指定的、有意设置的错误行为重写了 `decrease_key` 方法。此版本仅改变节点的键值，不执行后续的结构调整（无剪切操作），也不更新最小指针。\n\n### 测试序列与分析\n\n解决方案为三个测试序列（$S_1$、$S_2$、$S_3$）中的每一个都定义了一个函数。每个函数实例化一个 `CorrectFibHeap` 和一个 `FaultyFibHeap`，应用指定的操作序列，然后在两个堆上评估不变量。如果正确堆保持有效而错误堆变为无效，则认为该序列揭示了错误。\n\n-   **序列 $S_1$（堆序违规）**：在插入和一次 `extract_min` 操作后，一个非根节点的键值被减小到一个小于其父节点键的值。\n    -   **正确堆**：`decrease_key` 操作触发一次 `cut`，将该节点移动到根列表以恢复堆序性质。最小指针更新为这个新的、更小的根节点。所有不变量都得以保持。\n    -   **错误堆**：键值被减小，但没有发生剪切。这就产生了一条边 $(p, x)$，其中 $k(p) > k(x)$，违反了堆序不变量。最小指针没有更新，同时也违反了最小指针不变量。\n    -   **结果**：错误被揭示。结果为 `true`。\n\n-   **序列 $S_2$（最小指针违规）**：一个根节点的键值被减小到一个小于当前最小值的值。\n    -   **正确堆**：由于该节点是根节点，因此不需要进行剪切。最小指针被更新为指向该节点。所有不变量都得以保持。\n    -   **错误堆**：键值被减小，但最小指针没有更新。该指针继续引用一个不再是最小值的节点，从而违反了最小指针不变量。\n    -   **结果**：错误被揭示。结果为 `true`。\n\n-   **序列 $S_3$（边界情况）**：一个非根节点的键值被减小到一个等于其父节点键值的值。\n    -   **正确堆**：新键值不严格小于父节点的键值（由于 $k(p) = k(x)$，所以 $k(p) \\leq k(x)$ 仍然成立），因此不需要剪切。最小值没有改变。所有不变量都得以保持。\n    -   **错误堆**：键值被减小。由于这一变化没有违反堆序性质，也没有产生新的整体最小值，两个不变量由于巧合而保持完好。\n    -   **结果**：错误未被揭示，因为错误堆仍然有效。结果为 `false`。\n\n最终程序将这些布尔结果汇集为所需的输出格式。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Note: numpy is imported to adhere to the specified environment but is not used.\nimport math\n\nclass Node:\n    \"\"\"Represents a node in the Fibonacci heap.\"\"\"\n    def __init__(self, key):\n        self.key = key\n        self.initial_key = key  # For stable node lookup\n        self.degree = 0\n        self.parent = None\n        self.child = None\n        self.left = self\n        self.right = self\n        self.mark = False\n\n    def __repr__(self):\n        return f\"Node({self.key})\"\n\nclass BaseFibHeap:\n    \"\"\"Base class with common Fibonacci heap functionality.\"\"\"\n    def __init__(self):\n        self.min_node = None\n        self.num_nodes = 0\n        self.nodes_by_initial_key = {}\n\n    def insert(self, key):\n        \"\"\"Inserts a new key into the heap.\"\"\"\n        node = Node(key)\n        self.nodes_by_initial_key[key] = node\n        self._add_to_root_list(node)\n        if self.min_node is None or node.key  self.min_node.key:\n            self.min_node = node\n        self.num_nodes += 1\n        return node\n    \n    def _add_to_root_list(self, node):\n        \"\"\"Adds a node to the circular doubly-linked root list.\"\"\"\n        if self.min_node is None:\n            self.min_node = node\n        else:\n            node.right = self.min_node.right\n            node.left = self.min_node\n            self.min_node.right.left = node\n            self.min_node.right = node\n\n    def _remove_from_list(self, node):\n        \"\"\"Removes a node from a circular doubly-linked list.\"\"\"\n        node.left.right = node.right\n        node.right.left = node.left\n\n    def extract_min(self):\n        \"\"\"Extracts the node with the minimum key.\"\"\"\n        z = self.min_node\n        if z is not None:\n            if z.child is not None:\n                child = z.child\n                while True:\n                    next_child = child.right\n                    child.parent = None\n                    self._add_to_root_list(child)\n                    if next_child == z.child:\n                        break\n                    child = next_child\n            \n            self._remove_from_list(z)\n\n            if z == z.right:\n                self.min_node = None\n            else:\n                self.min_node = z.right\n                self.consolidate()\n            self.num_nodes -= 1\n        return z\n\n    def consolidate(self):\n        \"\"\"Consolidates the root list to reduce the number of trees.\"\"\"\n        degree_table = {}\n        roots = []\n        if self.min_node is None:\n            return\n            \n        curr = self.min_node\n        while True:\n            roots.append(curr)\n            if curr.right == self.min_node:\n                break\n            curr = curr.right\n\n        for w in roots:\n            x = w\n            d = x.degree\n            while d in degree_table:\n                y = degree_table[d]\n                if x.key > y.key:\n                    x, y = y, x\n                self._link(y, x)\n                del degree_table[d]\n                d += 1\n            degree_table[d] = x\n\n        self.min_node = None\n        for d in degree_table:\n            node = degree_table[d]\n            node.left = node\n            node.right = node\n            self._add_to_root_list(node)\n            if self.min_node is None or node.key  self.min_node.key:\n                self.min_node = node\n\n    def _link(self, y, x):\n        \"\"\"Links tree rooted at y to tree rooted at x.\"\"\"\n        self._remove_from_list(y)\n        y.parent = x\n        if x.child is None:\n            x.child = y\n            y.right = y\n            y.left = y\n        else:\n            y.left = x.child\n            y.right = x.child.right\n            x.child.right.left = y\n            x.child.right = y\n        x.degree += 1\n        y.mark = False\n\n    def _iter_nodes(self):\n        \"\"\"Generator to iterate over all nodes in the heap.\"\"\"\n        if not self.min_node:\n            return\n        \n        q = []\n        visited = set()\n\n        curr = self.min_node\n        while True:\n            q.append(curr)\n            if curr.right == self.min_node:\n                break\n            curr = curr.right\n            \n        while q:\n            node = q.pop(0)\n            if node in visited: continue\n            visited.add(node)\n            yield node\n            if node.child:\n                child = node.child\n                while True:\n                    q.append(child)\n                    if child.right == node.child:\n                        break\n                    child = child.right\n\n    def check_invariants(self):\n        \"\"\"Checks both heap invariants.\"\"\"\n        return self._check_heap_order() and self._check_min_pointer()\n\n    def _check_heap_order(self):\n        \"\"\"Checks if k(parent) = k(child) for all nodes.\"\"\"\n        for node in self._iter_nodes():\n            if node.child:\n                child = node.child\n                while True:\n                    if node.key > child.key:\n                        return False\n                    if child.parent != node:\n                        return False # Parent pointer check\n                    if child.right == node.child:\n                        break\n                    child = child.right\n        return True\n\n    def _check_min_pointer(self):\n        \"\"\"Checks if min_node points to a root with the minimum key.\"\"\"\n        if self.num_nodes == 0:\n            return self.min_node is None\n        \n        if self.min_node is None:\n            return False\n            \n        if self.min_node.parent is not None:\n            return False # Min node must be a root\n\n        actual_min_key = float('inf')\n        for node in self._iter_nodes():\n            actual_min_key = min(actual_min_key, node.key)\n\n        return self.min_node.key == actual_min_key\n    \n    def get_any_non_root(self):\n        for node in self._iter_nodes():\n            if node.parent is not None:\n                return node\n        return None\n\nclass CorrectFibHeap(BaseFibHeap):\n    \"\"\"A correct implementation of a Fibonacci heap.\"\"\"\n    def decrease_key(self, x, k):\n        if k > x.key:\n            raise ValueError(\"New key is greater than current key\")\n        x.key = k\n        p = x.parent\n        if p is not None and x.key  p.key:\n            self._cut(x, p)\n            self._cascading_cut(p)\n        if x.key  self.min_node.key:\n            self.min_node = x\n\n    def _cut(self, x, p):\n        self._remove_from_list(x)\n        if x.right == x:\n            p.child = None\n        else:\n            p.child = x.right\n        p.degree -= 1\n        self._add_to_root_list(x)\n        x.parent = None\n        x.mark = False\n\n    def _cascading_cut(self, p):\n        pp = p.parent\n        if pp is not None:\n            if not p.mark:\n                p.mark = True\n            else:\n                self._cut(p, pp)\n                self._cascading_cut(pp)\n\nclass FaultyFibHeap(BaseFibHeap):\n    \"\"\"A faulty implementation of a Fibonacci heap for testing.\"\"\"\n    def decrease_key(self, x, k):\n        if k > x.key:\n            raise ValueError(\"New key is greater than current key\")\n        x.key = k\n        # Intentionally does not perform cuts or update min_node\n\ndef run_sequence(sequence_id):\n    \"\"\"Runs a test sequence on both correct and faulty heaps.\"\"\"\n    correct_heap = CorrectFibHeap()\n    faulty_heap = FaultyFibHeap()\n\n    if sequence_id == 1:\n        keys_to_insert = [20, 7, 25, 17, 26, 18]\n        for key in keys_to_insert:\n            correct_heap.insert(key)\n            faulty_heap.insert(key)\n        \n        correct_heap.extract_min()\n        faulty_heap.extract_min()\n        \n        node_c = correct_heap.get_any_non_root()\n        node_f = faulty_heap.nodes_by_initial_key[node_c.initial_key]\n        \n        parent_key = node_c.parent.key\n        new_key = parent_key - 5\n        \n        correct_heap.decrease_key(node_c, new_key)\n        faulty_heap.decrease_key(node_f, new_key)\n\n    elif sequence_id == 2:\n        keys_to_insert = [30, 10, 40]\n        for key in keys_to_insert:\n            correct_heap.insert(key)\n            faulty_heap.insert(key)\n        \n        node_c = correct_heap.nodes_by_initial_key[30]\n        node_f = faulty_heap.nodes_by_initial_key[30]\n        \n        correct_heap.decrease_key(node_c, 5)\n        faulty_heap.decrease_key(node_f, 5)\n\n    elif sequence_id == 3:\n        keys_to_insert = [50, 60, 70, 80]\n        for key in keys_to_insert:\n            correct_heap.insert(key)\n            faulty_heap.insert(key)\n        \n        correct_heap.extract_min()\n        faulty_heap.extract_min()\n\n        node_c = correct_heap.get_any_non_root()\n        node_f = faulty_heap.nodes_by_initial_key[node_c.initial_key]\n\n        new_key = node_c.parent.key\n\n        correct_heap.decrease_key(node_c, new_key)\n        faulty_heap.decrease_key(node_f, new_key)\n        \n    correct_valid = correct_heap.check_invariants()\n    faulty_valid = faulty_heap.check_invariants()\n\n    return correct_valid and not faulty_valid\n\ndef solve():\n    \"\"\"\n    Main function to execute the test sequences and print results.\n    \"\"\"\n    results = [\n        run_sequence(1),\n        run_sequence(2),\n        run_sequence(3)\n    ]\n    \n    # Format the final output as a comma-separated list of lowercase booleans\n    # e.g., [true,false,true]\n    print(f\"[{','.join(map(lambda b: str(b).lower(), results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了斐波那契堆的基本操作（如插入和提取最小值）之后，下一个挑战便是利用这些基础模块来构建更高级的功能。这个练习  要求你设计并实现一个 `split` 操作，它能根据一个给定的键值 $x$ 将一个堆分割成两个。这个过程不仅能锻炼你对堆的遍历和节点操作的熟练度，还能让你体验如何通过组合基本操作来解决更复杂的问题，这是算法设计中的一项核心技能。",
            "id": "3234478",
            "problem": "设计并实现一个完整的、可运行的程序，用于在斐波那契堆（FH）上实现分裂操作。斐波那契堆是一种由堆序树组成的集合，它支持一系列具有较低摊还时间的操作。设计的根本基础必须是堆序性质：对于每个键值为 $k_p$ 的父节点及其任何一个键值为 $k_c$ 的子节点，关系 $k_p \\le k_c$ 必须成立。堆表示为一个根节点的循环双向链表，每个根节点是一棵堆序树的入口。在任何算法中需要保持的关键结构不变量是：堆序性质、根节点之间的循环双向链表结构、正确的父子关系，以及一个指向堆中最小键根节点的指针。\n\n您的任务是：\n- 根据堆序性质，推导出一个正确的算法，将给定的斐波那契堆 $H$ 按照一个阈值 $x \\in \\mathbb{Z}$ 分裂成两个斐波那契堆 $(H_{\\le}, H_{>})$，使得 $H_{\\le}$ 精确包含 $H$ 中所有键 $k$ 满足 $k \\le x$ 的元素，而 $H_{>}$ 精确包含 $H$ 中所有键 $k$ 满足 $k > x$ 的元素。\n- 在一个程序中实现该算法，该程序能从给定的整数键序列构建斐波那契堆，可选择性地执行指定次数的最小元素提取操作以创建非平凡的树结构，然后应用分裂操作产生 $(H_{\\le}, H_{>})$。\n- 为每个测试用例计算并返回可量化的结果，以便进行自动验证：\n  - $c_{\\le}$：$H_{\\le}$ 中的键数量（一个整数）。\n  - $c_{>}$：$H_{>}$ 中的键数量（一个整数）。\n  - $s_{\\le}$：$H_{\\le}$ 中的键之和（一个整数）。\n  - $s_{>}$：$H_{>}$ 中的键之和（一个整数）。\n  - $m_{\\le}$：$H_{\\le}$ 中的最小键，如果 $H_{\\le}$ 为空则为 $-1$（一个整数）。\n  - $m_{>}$：$H_{>}$ 中的最小键，如果 $H_{>}$ 为空则为 $-1$（一个整数）。\n  - $v$：一个布尔标志，当且仅当以下所有条件都成立时为真：\n    - $H_{\\le}$ 中的每个键都满足 $k \\le x$，并且 $H_{>}$ 中的每个键都满足 $k > x$。\n    - $H_{\\le}$ 和 $H_{>}$ 中键的多重集并集等于 $H$ 中原始的键的多重集。\n    - $H_{\\le}$ 和 $H_{>}$ 都满足堆序性质，并具有正确的最小指针（如果非空），即存储的最小值等于存在的最小键。\n\n程序要求：\n- 使用显式节点表示斐波那契堆，节点包含键、度、标记、父节点、一个子节点指针以及形成循环双向链表的左、右兄弟指针字段。\n- 仅使用从定义派生的逻辑上合理的标准操作：插入、合并（union/meld），以及通过重复链接度数相等的树进行合并的最小元素提取。\n- 分裂算法必须从堆序性质推导而来，可以通过遍历 $H$ 的所有节点恰好一次，并将每个键插入到适当的目标堆中来实现。向斐波那契堆中插入操作的摊还时间为 $O(1)$；遍历会访问每个节点常数次，因此总摊还时间为 $O(n)$，其中 $n$ 是节点数。\n\n测试套件和构建协议：\n- 对于每个测试用例，通过插入给定序列中的键来构建堆 $H$。然后，精确执行 $e$ 次最小元素提取操作（如果在 $e$ 次提取完成前 $H$ 变空，则忽略后续的提取）。最后，在阈值 $x$ 处执行分裂操作。\n- 使用以下测试套件，其中每个测试用例是一个三元组 $(\\langle k_1, k_2, \\dots, k_m \\rangle, x, e)$：\n  - 测试 1：$\\left(\\langle 7, 3, 18, 39, 52, 41, 17, 30, 24, 26, 46 \\rangle, x = 30, e = 1\\right)$。\n  - 测试 2：$\\left(\\langle 1, 2, 2, 2, 3 \\rangle, x = 3, e = 0\\right)$。\n  - 测试 3：$\\left(\\langle 10, 11, 12 \\rangle, x = 5, e = 0\\right)$。\n  - 测试 4：$\\left(\\langle -5, -1, 0, 0, 6, 6, 7 \\rangle, x = 0, e = 2\\right)$。\n  - 测试 5：$\\left(\\langle \\rangle, x = 0, e = 0\\right)$ (空堆)。\n  - 测试 6：$\\left(\\langle 5, 5, 5 \\rangle, x = 5, e = 1\\right)$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个元素是每个测试用例的列表 $[c_{\\le}, c_{>}, s_{\\le}, s_{>}, m_{\\le}, m_{>}, v]$。例如，形式为 $[[\\dots],[\\dots],\\dots]$ 的一行。\n- 不从标准输入读取任何输入。所有计算都由编译进程序的测试套件确定。\n- 不涉及物理单位或角度；所有键和输出都是无单位的整数或布尔值。",
            "solution": "该问题要求设计并实现斐波那契堆的 `split` 操作。一个给定的斐波那契堆 $H$ 需要根据指定的整数阈值 $x$ 分割成两个新的斐波那契堆 $H_{\\le}$ 和 $H_{>}$。$H_{\\le}$ 必须包含 $H$ 中所有键 $k \\le x$ 的元素，$H_{>}$ 必须包含所有键 $k > x$ 的元素。该算法必须从基本的堆序性质推导而来，并且解决方案必须包含一个完整的、可运行的程序，该程序实现了堆、分裂操作，并为给定的测试套件计算多个验证指标。\n\n斐波那契堆是优先队列的一种具体实现，它由一组堆序树构成。这些树的根节点维护在一个循环双向链表中。其定义性特征是**堆序性质**：对于任何键为 $k_p$ 的节点 $p$ 及其任何键为 $k_c$ 的子节点 $c$，不等式 $k_p \\le k_c$ 必须成立。这个性质意味着从根到叶的任何路径上的键都是非递减的。堆维护一个指针 `min_node`，指向具有最小键的根节点，从而允许以 $O(1)$ 的时间访问最小元素。主要操作包括插入、查找最小值、提取最小值、减小键值和合并（union）。斐波那契堆的效率源于其“惰性”特性，即结构性工作被推迟到执行 `extract-min` 操作时才进行。\n\n任务是设计一个 `split(H, x)` 算法。要对 $H$ 中的键集进行分区，必须检查每个键以确定它是否小于等于 $x$ 或大于 $x$。因此，必须对堆 $H$ 中的所有节点进行一次完整遍历，这需要 $O(n)$ 的时间，其中 $n$ 是 $H$ 中的节点数。设这次遍历中的一个节点表示为 $u$。\n\n推导的核心与堆序性质有关。最终的结构 $H_{\\le}$ 和 $H_{>}$ 本身必须是有效的斐波那契堆，这意味着它们必须满足所有结构不变量，其中最主要的就是堆序性质。保证这一点的稳健而直接的方法是，使用一系列有效的堆操作从头开始构建 $H_{\\le}$ 和 $H_{>}$。\n\n提出的算法如下：\n1. 初始化两个新的空斐波那契堆，$H_{\\le}$ 和 $H_{>}$。\n2. 遍历原始堆 $H$ 中的每个节点 $u$。这可以通过从根列表中的根节点开始进行广度优先搜索或深度优先搜索来完成。\n3. 对于每个键为 $k$ 的节点 $u$，将 $k$ 与阈值 $x$ 进行比较。\n   - 如果 $k \\le x$，则使用其标准的 `insert` 操作将键 $k$ 插入到 $H_{\\le}$ 中。\n   - 如果 $k > x$，则使用其 `insert` 操作将键 $k$ 插入到 $H_{>}$ 中。\n4. 在处理完 $H$ 的所有节点后，堆 $H_{\\le}$ 和 $H_{>}$ 就包含了分割后的键集，并且根据其构造过程，它们是有效的斐波那契堆。\n\n该算法的正确性直接“从堆序性质推导而来”，因为 `insert` 操作在根本上就是为了保持这一性质而设计的。通过完全使用 `insert` 来构建新堆，我们确保了最终结构的有效性。虽然可以构想出更复杂的、涉及剪切子树和重组的就地算法，但对于此分区任务，它们在渐近时间复杂度上没有优势，并且会引入大量的出错可能性。遍历并重新插入的方法利用了基本 `insert` 操作已被证明的正确性，该操作的摊还时间为 $O(1)$。由于遍历每个节点一次，共 $n$ 个节点，所以分裂操作的总摊还时间复杂度为 $O(n)$。\n\n该实现需要一个完整的斐波那契堆数据结构。`Node` 类封装了以下字段：`key`、`degree`（子节点数）、`mark`（用于 `decrease-key` 操作，尽管在此问题中不是核心）、`parent`、`child`、`left` 和 `right` 兄弟指针。`FibonacciHeap` 类管理节点集合，维护一个指向最小键根 `min_node` 的指针和总节点数 `num_nodes`。需要实现的关键操作有：\n- `insert(key)`: 创建一个新的单节点树，并以 $O(1)$ 时间将其添加到根列表中。\n- `extract_min()`: 移除最小节点，将其子节点提升到根列表，并调用 `consolidate()` 来重组堆。这是最复杂的操作。\n- `consolidate()`: 合并根列表中的树，使得没有两棵树具有相同的度。这是通过迭代地链接度数相等的树来实现的。它确保了任何节点的最大度数有对数界限。\n- `get_all_nodes()`: 一个遍历函数，用于访问堆中的每个节点，这对于 `split` 操作和验证都是必需的。\n- `split(x)`: 实现上述的遍历和重新插入算法。\n\n最后，对于每个测试用例，程序构建一个堆，执行指定次数的 `extract-min` 操作，然后执行 `split`。结果通过以下方式验证：\n1. 遍历最终的堆 $H_{\\le}$ 和 $H_{>}$ 以收集它们的键。\n2. 计算所需的指标：数量（$c_{\\le}, c_{>}$）、总和（$s_{\\le}, s_{>}$）和最小值（$m_{\\le}, m_{>}$）。\n3. 为布尔标志 $v$ 执行一系列检查：\n   - **分区正确性**：$H_{\\le}$ 中的每个键都必须 $\\le x$，而 $H_{>}$ 中的每个键都必须 $> x$。\n   - **键守恒**：$H_{\\le}$ 和 $H_{>}$ 中键的多重集并集必须与分裂前原始堆 $H$ 中的键的多重集完全相同。\n   - **堆有效性**：$H_{\\le}$ 和 $H_{>}$ 都必须是结构上有效的斐波那契堆，这通过检查所有父子对的堆序性质并确认 `min_node` 指针是否正确来验证。\n这些指标的集合为算法的正确性提供了一个全面且可自动验证的评估。",
            "answer": "```python\nimport numpy as np\n\n# A meticulous and complete implementation of a Fibonacci Heap.\nclass FibonacciHeap:\n    \"\"\"\n    Implements a Fibonacci Heap data structure supporting insert, extract-min,\n    and a custom split operation.\n    \"\"\"\n    class Node:\n        \"\"\"Represents a node in the heap.\"\"\"\n        def __init__(self, key):\n            self.key = key\n            self.degree = 0\n            self.parent = None\n            self.child = None\n            self.left = self\n            self.right = self\n            self.mark = False\n\n    def __init__(self):\n        \"\"\"Initializes an empty Fibonacci Heap.\"\"\"\n        self.min_node = None\n        self.num_nodes = 0\n\n    def is_empty(self):\n        \"\"\"Returns True if the heap is empty, False otherwise.\"\"\"\n        return self.min_node is None\n\n    def insert(self, key):\n        \"\"\"Inserts a new key into the heap.\"\"\"\n        node = self.Node(key)\n        if self.min_node is None:\n            self.min_node = node\n        else:\n            # Add node to the root list\n            node.right = self.min_node.right\n            node.left = self.min_node\n            self.min_node.right.left = node\n            self.min_node.right = node\n            if key  self.min_node.key:\n                self.min_node = node\n        self.num_nodes += 1\n        return node\n\n    def get_min(self):\n        \"\"\"Returns the minimum key in the heap.\"\"\"\n        return self.min_node.key if self.min_node is not None else None\n\n    def _link(self, y, x):\n        \"\"\"Makes node y a child of node x.\"\"\"\n        # Remove y from root list\n        y.left.right = y.right\n        y.right.left = y.left\n        \n        # Make y a child of x\n        y.parent = x\n        if x.child is None:\n            x.child = y\n            y.right = y\n            y.left = y\n        else:\n            y.left = x.child\n            y.right = x.child.right\n            x.child.right.left = y\n            x.child.right = y\n        x.degree += 1\n        y.mark = False\n\n    def _consolidate(self):\n        \"\"\"Consolidates the root list to enforce the property of unique degrees.\"\"\"\n        if self.num_nodes = 1:\n            return\n        \n        # The max degree is bounded by log_phi(n)\n        max_degree = int(np.floor(np.log(self.num_nodes) / np.log((1 + np.sqrt(5)) / 2))) + 2\n        A = [None] * max_degree\n        \n        roots = []\n        curr = self.min_node\n        start = self.min_node\n        if curr is None: return\n        while True:\n            roots.append(curr)\n            curr = curr.right\n            if curr == start:\n                break\n        \n        for root in roots:\n            x = root\n            d = x.degree\n            while A[d] is not None:\n                y = A[d]\n                if x.key > y.key:\n                    x, y = y, x\n                self._link(y, x)\n                A[d] = None\n                d += 1\n            A[d] = x\n\n        self.min_node = None\n        for node in A:\n            if node is not None:\n                if self.min_node is None:\n                    self.min_node = node\n                    node.left = node.right = node\n                else:\n                    node.left = self.min_node\n                    node.right = self.min_node.right\n                    self.min_node.right.left = node\n                    self.min_node.right = node\n                    if node.key  self.min_node.key:\n                        self.min_node = node\n\n    def extract_min(self):\n        \"\"\"Extracts the minimum node from the heap.\"\"\"\n        z = self.min_node\n        if z is not None:\n            # Add children to the root list\n            if z.child is not None:\n                child = z.child\n                while True:\n                    next_child = child.right\n                    child.parent = None\n                    # Add child to root list next to z\n                    child.left = z\n                    child.right = z.right\n                    z.right.left = child\n                    z.right = child\n                    if next_child == z.child:\n                        break\n                    child = next_child\n\n            # Remove z from the root list\n            z.left.right = z.right\n            z.right.left = z.left\n\n            if z == z.right:\n                self.min_node = None\n            else:\n                self.min_node = z.right\n                self._consolidate()\n            \n            self.num_nodes -= 1\n        return z\n\n    def get_all_nodes(self):\n        \"\"\"Returns a list of all nodes in the heap via a traversal.\"\"\"\n        if self.is_empty():\n            return []\n        \n        all_nodes = []\n        queue = []\n        visited_roots = set()\n\n        # Add all roots to the queue to start traversal\n        start_node = self.min_node\n        curr = start_node\n        while True:\n            if curr in visited_roots: break\n            visited_roots.add(curr)\n            queue.append(curr)\n            curr = curr.right\n            if curr == start_node: break\n        \n        head = 0\n        while head  len(queue):\n            node = queue[head]\n            head += 1\n            all_nodes.append(node)\n            \n            if node.child is not None:\n                child_start = node.child\n                curr_child = child_start\n                while True:\n                    queue.append(curr_child)\n                    curr_child = curr_child.right\n                    if curr_child == child_start: break\n        \n        return all_nodes\n\n    def split(self, x):\n        \"\"\"Splits the heap into two heaps based on threshold x.\"\"\"\n        nodes = self.get_all_nodes()\n        h_le = FibonacciHeap()\n        h_gt = FibonacciHeap()\n        for node in nodes:\n            if node.key = x:\n                h_le.insert(node.key)\n            else:\n                h_gt.insert(node.key)\n        return h_le, h_gt\n\n    def is_valid(self):\n        \"\"\"Verifies the heap-order property and the min_node pointer.\"\"\"\n        if self.min_node is None:\n            return self.num_nodes == 0\n        \n        all_nodes = self.get_all_nodes()\n        if len(all_nodes) != self.num_nodes:\n            return False\n\n        if not all_nodes:\n            return self.num_nodes == 0\n\n        actual_min_key = float('inf')\n        for node in all_nodes:\n            actual_min_key = min(actual_min_key, node.key)\n            if node.parent is None: # It's a root\n                pass # No parent to check against\n            \n            if node.child is not None:\n                child_start = node.child\n                curr_child = child_start\n                while True:\n                    if curr_child.key  node.key: return False # Heap-order violation\n                    if curr_child.parent != node: return False # Parent pointer mismatch\n                    curr_child = curr_child.right\n                    if curr_child == child_start: break\n        \n        return self.min_node.key == actual_min_key\n\ndef solve():\n    \"\"\"\n    Runs the test suite for the Fibonacci heap split operation and prints results.\n    \"\"\"\n    test_cases = [\n        (tuple([7, 3, 18, 39, 52, 41, 17, 30, 24, 26, 46]), 30, 1),\n        (tuple([1, 2, 2, 2, 3]), 3, 0),\n        (tuple([10, 11, 12]), 5, 0),\n        (tuple([-5, -1, 0, 0, 6, 6, 7]), 0, 2),\n        (tuple([]), 0, 0),\n        (tuple([5, 5, 5]), 5, 1)\n    ]\n\n    final_results = []\n    for keys, x, e in test_cases:\n        h = FibonacciHeap()\n        for k in keys:\n            h.insert(k)\n\n        for _ in range(e):\n            if h.is_empty():\n                break\n            h.extract_min()\n\n        original_keys_after_extraction = sorted([node.key for node in h.get_all_nodes()])\n\n        h_le, h_gt = h.split(x)\n\n        keys_le = [node.key for node in h_le.get_all_nodes()]\n        keys_gt = [node.key for node in h_gt.get_all_nodes()]\n\n        c_le = len(keys_le)\n        c_gt = len(keys_gt)\n        s_le = sum(keys_le) if c_le > 0 else 0\n        s_gt = sum(keys_gt) if c_gt > 0 else 0\n        m_le = h_le.get_min() if c_le > 0 else -1\n        m_gt = h_gt.get_min() if c_gt > 0 else -1\n\n        v = True\n        # 1. Partition correctness\n        if not all(k = x for k in keys_le): v = False\n        if not all(k > x for k in keys_gt): v = False\n        # 2. Key conservation\n        if sorted(keys_le + keys_gt) != original_keys_after_extraction: v = False\n        # 3. Heap validity\n        if not h_le.is_valid(): v = False\n        if not h_gt.is_valid(): v = False\n\n        final_results.append([c_le, c_gt, s_le, s_gt, m_le, m_gt, v])\n\n    print(f\"[{','.join(f'[{\",\".join(map(str, res))}]' for res in final_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "对于斐波那契堆这样的复杂结构，编写代码只是第一步，保证其正确性同样充满挑战。当实现中出现难以捉摸的错误时，一个系统性的调试工具——不变量检查器——就显得不可或缺。这个练习  让你从调试者的角度出发，思考应该在代码中加入哪些断言（assertions）来捕捉常见的结构性错误，例如指针链接错误或节点度数不一致。这不仅是对斐波那契堆性质的深度复习，也是对编写健壮、可维护代码实践的宝贵训练。",
            "id": "3234539",
            "problem": "你正在为一个最小堆调试一个斐波那契堆的实现。经过长时间的随机化测试，你观察到一些症状，例如 `decrease-key` 操作偶尔无法调整报告的最小值，遍历根列表时零星出现循环，以及节点的报告度与其孩子列表中遍历遇到的孩子数量偶尔不匹配。你决定编写一个在每次操作后运行并标记结构不一致性的不变式检查器。仅使用斐波那契堆的基本定义和经过充分检验的事实，哪组断言最适合包含在内，以便在不过度约束有效状态的情况下暴露常见的结构性错误？\n\n选择最佳选项。\n\nA. 断言以下所有内容：\n- 堆序：对于每个父节点为 $p(x)$ 的非根节点 $x$，满足 $key(p(x)) \\le key(x)$。\n- 根列表结构：根列表是一个循环双向链表，具有指针一致性，即对于每个根 $r$，都有 $r.\\mathrm{left}.\\mathrm{right} = r$ 和 $r.\\mathrm{right}.\\mathrm{left} = r$，并且每个根的 $r.\\mathrm{parent} = \\mathrm{null}$。\n- 最小指针：$H.\\mathrm{min}$ 指向一个根，其键值等于 $\\min\\{key(r) : r \\text{ is a root}\\}$。\n- 度一致性：对于每个节点 $x$，存储的度 $deg(x)$ 等于遍历其孩子循环列表一圈可达的孩子数量；该列表中的每个孩子 $c$ 都满足 $c.\\mathrm{parent} = x$。\n- 标记一致性：所有根都未被标记；如果一个节点被标记，则它不是根节点且其 $x.\\mathrm{parent} \\ne \\mathrm{null}$。\n- 合并后唯一性：每次 `delete-min` 操作后，所有根的度都是两两不同的。\n\nB. 断言以下所有内容：\n- 根的数量恰好是 $\\lfloor \\log_{\\varphi} n \\rfloor$，其中 $\\varphi = \\frac{1+\\sqrt{5}}{2}$，$n$ 是节点数。\n- 最小指针 $H.\\mathrm{min}$ 是堆中所有节点（不仅仅是根节点）中的全局最小键值。\n- 孩子列表可以是单向链表，只要遍历能到达所有孩子即可。\n- 根节点可以被标记，因为标记仅表示一个节点在某个时刻失去了一个孩子。\n\nC. 断言以下所有内容：\n- 堆序是严格的：对于每个父节点为 $p(x)$ 的非根节点 $x$，满足 $key(p(x))  key(x)$。\n- 度是后代的总数：对于每个节点 $x$，$deg(x)$ 等于以 $x$ 为根的子树中的节点数减 1。\n- 度唯一性在任何时候都适用于整个堆：没有两个节点（根或非根）共享相同的 $deg(\\cdot)$ 值。\n- 如果可以从根列表通过指针追溯到达孩子节点，则它们无需维护父指针。\n\nD. 断言以下所有内容：\n- 势函数值 $\\Phi = T + 2M$（其中 $T$ 是根的数量，$M$ 是被标记节点的数量）在任何操作中都不会增加。\n- 在 `decrease-key` 之后，最小指针 $H.\\mathrm{min}$ 可能暂时不正确，但必须仅在 `extract-min` 之后进行修正。\n- 合并操作可以推迟配对度相等的根，直到执行了 $k$ 次 `delete-min` 操作（对于某个固定的 $k > 1$）。\n- 除非节点被标记，否则可以省略父指针；在这种情况下，它必须指向一个有效的父节点。",
            "solution": "## 问题验证\n\n### 步骤1：提取已知条件\n- **数据结构：** 一个作为斐波那契堆实现的最小堆。\n- **背景：** 正在通过随机化测试调试一个实现。\n- **观察到的症状：**\n    1. `decrease-key` 操作偶尔无法调整报告的最小值。\n    2. 遍历根列表时零星出现循环。\n    3. 节点的报告度与其孩子列表中遍历遇到的孩子数量偶尔不匹配。\n- **任务：** 为一个在每次操作后运行的不变式检查器定义一组断言。\n- **目标：** 断言必须能够在不过度约束有效状态的情况下暴露常见的结构性错误，且仅使用斐波那契堆的基本定义和经过充分检验的事实。\n- **问题：** 所提供的断言组中哪一个最合适？\n\n### 步骤2：使用提取的已知条件进行验证\n问题陈述是有效的。\n- **科学依据：** 该问题设置在数据结构和算法的背景下，这是计算机科学的一个正式分支。斐波那契堆是一个定义明确的数学构造，具有既定的属性（不变式）。所描述的症状是由于堆操作的不正确实现而可能出现的真实错误。创建不变式检查器是调试复杂数据结构的一种标准且严谨的方法。\n- **定义明确：** 问题要求找到“最合适的”断言集，以实现一个明确定义的目标：在不排除堆的有效中间状态的情况下，暴露特定类型的错误。这种结构允许通过将给定选项与斐波那契堆的既定理论进行比较，从而确定唯一的最佳答案。\n- **客观性：** 问题使用该领域特定的精确技术语言进行描述。症状是具体且可衡量的，而对断言所期望的属性是客观标准（暴露错误，不过度约束）。\n\n### 步骤3：结论与行动\n问题是有效的。分析将继续以推导出解决方案。\n\n## 解题推导\n\n目标是识别能正确捕捉斐波那契堆（作为最小堆）结构不变式的断言集。这样的集合应该足以检测所描述的实现错误。我们将根据斐波那契堆的规范定义来评估每个选项。\n\n一个斐波那契堆 $H$ 是满足最小堆性质的一组树的集合。在公共操作之间必须保持的结构不变式如下：\n\n1.  **最小堆序：** 对于每个有父节点 $p(x)$ 的节点 $x$，必须满足不等式 $key(p(x)) \\le key(x)$。\n2.  **根列表：** 所有树的根都链接在一个循环双向链表中。每个根的父节点都是 $\\mathrm{null}$。\n3.  **最小指针：** 一个指针 $H.\\mathrm{min}$ 必须指向具有最小键值的根节点。\n4.  **节点字段：** 每个节点 $x$ 维护其度 $deg(x)$（孩子数量）、一个孩子指针、一个父指针和一个布尔标记。\n5.  **孩子列表：** 每个节点 $x$ 的孩子也链接在一个循环双向链表中。每个孩子的父指针必须指回 $x$。\n6.  **标记规则：** 一个非根节点 $x$ 如果自 $x$ 最后一次成为其当前父节点的孩子以来失去过一个孩子，则该节点被标记。所有根都未被标记。\n\n所描述的错误对应于对这些不变式的违反：\n- `decrease-key` 未能更新最小值，违反了不变式#3。\n- 根列表中的循环违反了不变式#2。\n- 度与孩子数量不匹配违反了不变式#4和#5。\n\n现在，我们评估每个选项。\n\n### 逐项分析\n\n**A. 断言以下所有内容：**\n1.  **堆序：对于每个父节点为 $p(x)$ 的非根节点 $x$，满足 $key(p(x)) \\le key(x)$。** 这是基本的最小堆性质和核心不变式。**该断言是正确的。**\n2.  **根列表结构：根列表是一个循环双向链表，具有指针一致性，即对于每个根 $r$，都有 $r.\\mathrm{left}.\\mathrm{right} = r$ 和 $r.\\mathrm{right}.\\mathrm{left} = r$，并且每个根的 $r.\\mathrm{parent} = \\mathrm{null}$。** 这正确定地义了根列表的结构和指针完整性。检查这一点将能检测到“零星出现循环”的错误。**该断言是正确的。**\n3.  **最小指针：$H.\\mathrm{min}$ 指向一个根，其键值等于 $\\min\\{key(r) : r \\text{ is a root}\\}$。** 这是对最小指针作用的定义，确保了 `find-min` 操作的 $O(1)$ 复杂度。它将检测到 `decrease-key` 未能更新最小值的错误。**该断言是正确的。**\n4.  **度一致性：对于每个节点 $x$，存储的度 $deg(x)$ 等于遍历其孩子循环列表一圈可达的孩子数量；该列表中的每个孩子 $c$ 都满足 $c.\\mathrm{parent} = x$。** 这个检查直接针对关于度不匹配的错误，并验证了子-父链接的完整性，这对 `cut` 操作至关重要。**该断言是正确的。**\n5.  **标记一致性：所有根都未被标记；如果一个节点被标记，则它不是根节点且其 $x.\\mathrm{parent} \\ne \\mathrm{null}$。** 这正确地陈述了标记规则。根据定义，根节点是未标记的（当它们成为根时，它们的标记被清除）。**该断言是正确的。**\n6.  **合并后唯一性：每次 `delete-min` 操作后，所有根的度都是两两不同的。** 这是关于斐波那契堆在 `delete-min`（或 `extract-min`）操作的合并步骤*之后*状态的正确陈述。虽然它不是在*每次*操作后都成立的全局不变式（例如，`insert` 可能会创建一个度已存在的根），但它是 `delete-min` 的一个关键后置条件。不变式检查器可以有条件地使用此断言。在创建一个全面的检查套件以调试实现时，这是一个非常合适且有用的断言。\n\n这组断言完全由关于斐波那契堆的正确属性组成。前五个是全局不变式，第六个是一个主要操作的关键后置条件。它们共同作用，能高效地暴露所述的结构性错误。\n**结论：正确。**\n\n**B. 断言以下所有内容：**\n1.  **根的数量恰好是 $\\lfloor \\log_{\\varphi} n \\rfloor$，其中 $\\varphi = \\frac{1+\\sqrt{5}}{2}$，$n$ 是节点数。** 这是不正确的。根的数量不是固定的。它可以高达 $n$。$O(\\log n)$ 的界限适用于堆中任何节点的最大*度*，而不是根的数量。\n2.  **最小指针 $H.\\mathrm{min}$ 是堆中所有节点（不仅仅是根节点）中的全局最小键值。** 虽然这个陈述是最小堆性质的一个真实推论（最小值必须位于根节点），但主要的、可直接检查的不变式是 $H.\\mathrm{min}$ 指向*根节点中*的最小值。这样表述不如选项A中的断言直接。\n3.  **孩子列表可以是单向链表，只要遍历能到达所有孩子即可。** 这是不正确的。孩子列表必须是双向链表，以支持从其兄弟节点中高效地剪切一个节点，这是 `decrease-key` 实现 $O(1)$ 摊还时间所必需的。\n4.  **根节点可以被标记，因为标记仅表示一个节点在某个时刻失去了一个孩子。** 这是不正确的。根据定义，当一个节点成为根时，它会被取消标记。\n这组断言包含了多个基本错误。\n**结论：不正确。**\n\n**C. 断言以下所有内容：**\n1.  **堆序是严格的：对于每个父节点为 $p(x)$ 的非根节点 $x$，满足 $key(p(x))  key(x)$。** 这是一个过度约束。斐波那契堆可以存储具有重复键值的元素，因此堆性质是非严格的（$ \\le $）。\n2.  **度是后代的总数：对于每个节点 $x$，$deg(x)$ 等于以 $x$ 为根的子树中的节点数减 1。** 这是不正确的。节点的度是其直接孩子的数量，而不是其所有后代的数量。\n3.  **度唯一性在任何时候都适用于整个堆：没有两个节点（根或非根）共享相同的 $deg(\\cdot)$ 值。** 这是不正确的。度的唯一性没有保证，即使对于根节点，也只在合并操作后立即成立。\n4.  **如果可以从根列表通过指针追溯到达孩子节点，则它们无需维护父指针。** 这是不正确的。父指针对于 `decrease-key` 操作中的 `cut` 和 `cascading-cut` 过程至关重要，这些过程需要从一个节点向上移动到树中。\n这组断言包含了多个基本错误。\n**结论：不正确。**\n\n**D. 断言以下所有内容：**\n1.  **势函数值 $\\Phi = T + 2M$（其中 $T$ 是根的数量，$M$ 是被标记节点的数量）在任何操作中都不会增加。** 这是不正确的。势函数是用于摊还分析的工具；它不是一个不变式，并且在某些操作期间可能会增加（例如，`insert` 会增加 $T$）。被限制的是摊还成本，而不是势函数本身。\n2.  **在 `decrease-key` 之后，最小指针 $H.\\mathrm{min}$ 可能暂时不正确，但必须仅在 `extract-min` 之后进行修正。** 这是不正确的。`decrease-key` 操作负责在新的最小根的键值小于当前最小值时更新 $H.\\mathrm{min}$。允许它不正确将违反 `find-min` 操作的语义。问题中对此行为的描述是一个*错误的症状*，而不是一个允许的状态。\n3.  **合并操作可以推迟配对度相等的根，直到执行了 $k$ 次 `delete-min` 操作（对于某个固定的 $k > 1$）。** 这描述了对标准算法的修改，而不是斐波那契堆基本定义的属性。标准算法在每次 `delete-min` 期间都会进行合并。\n4.  **除非节点被标记，否则可以省略父指针；在这种情况下，它必须指向一个有效的父节点。** 这是不正确的。`cascading-cut` 过程从一个节点移动到其父节点，而该父节点最初可能未被标记。因此，所有非根节点都必须有父指针。\n这组断言包含了多个基本错误。\n**结论：不正确。**\n\n### 结论\n选项A提供了一组关于斐波那契堆结构和属性的断言，这些断言都是正确的。前五个是通用不变式，第六个是 `delete-min` 的一个特定后置条件。这个集合完美地定制用于检测问题陈述中提到的特定错误，同时又不会过于严格（因为那个特定的后置条件被正确地限定了）。选项B、C和D都包含了多个对斐波那契堆的基本错误描述。因此，选项A无疑是最合适的断言集。",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}