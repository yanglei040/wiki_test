{
    "hands_on_practices": [
        {
            "introduction": "The heart of a scapegoat tree's rebalancing strategy lies in its ability to detect when a part of the tree has become too lopsided. This practical exercise tasks you with implementing this core detection mechanism, the $\\alpha$-weight-balance check, where $\\alpha$ is the tree's balance parameter. By translating the formal definition of a scapegoat node into working code, you will gain a concrete understanding of how the data structure identifies the need for a localized rebuild following an insertion. ",
            "id": "3216147",
            "problem": "You are given the task of implementing the logic to detect an imbalanced subtree according to the scapegoat tree criterion, within a binary tree that has just undergone a single insertion. The detection must be performed along the specific insertion path. Begin from the following fundamental definitions and facts:\n\n- A binary tree is a data structure in which each node has at most two children, usually designated as a left child and a right child.\n- For any node, define the subtree size function $s(v)$ as the total number of nodes in the subtree rooted at node $v$, including $v$ itself.\n- For a real parameter $\\alpha$ with $\\frac{1}{2}  \\alpha  1$, a node $u$ is considered $\\alpha$-weight-balanced if both its left and right child subtrees have sizes at most $\\alpha \\cdot s(u)$. That is, if $L(u)$ denotes the size of the left child subtree of $u$ and $R(u)$ denotes the size of the right child subtree of $u$, then $u$ is $\\alpha$-weight-balanced if $L(u) \\le \\alpha \\cdot s(u)$ and $R(u) \\le \\alpha \\cdot s(u)$. A node $u$ is an $\\alpha$-scapegoat if it is not $\\alpha$-weight-balanced, meaning either $L(u) > \\alpha \\cdot s(u)$ or $R(u) > \\alpha \\cdot s(u)$.\n\nYou must implement a program that, given a binary tree, a parameter $\\alpha$, and a specified insertion path ending at the newly inserted node, detects the **highest** $\\alpha$-scapegoat ancestor on the path (i.e., the one closest to the root). If no ancestor along this path violates the $\\alpha$-weight-balance condition, return $-1$. The detection must be based on exact subtree sizes after the insertion is applied.\n\nRepresentation details to be used within the program:\n- Each tree is specified by a list of triples $(\\text{id}, \\text{left}, \\text{right})$ where $\\text{id}$, $\\text{left}$, and $\\text{right}$ are integers, and $-1$ denotes a null child.\n- The insertion path is given as a list $[p_0, p_1, \\dots, p_k]$, where $p_0$ is the root identifier and $p_k$ is the newly inserted node identifier. The insertion attaches $p_k$ as the left or right child of $p_{k-1}$ as specified by an explicit side indicator.\n- After applying the insertion, compute $s(v)$ for all nodes reachable from the root, and detect the highest ancestor on the path $[p_0, p_1, \\dots, p_{k-1}]$ that satisfies the violation $L(u) > \\alpha \\cdot s(u)$ or $R(u) > \\alpha \\cdot s(u)$.\n\nYour program must embed and process the following five test cases exactly as specified:\n\n- Test Case $1$:\n  - Nodes: $(8, 4, 12)$, $(4, 2, -1)$, $(12, 10, 14)$, $(2, -1, -1)$, $(6, -1, -1)$, $(10, -1, -1)$, $(14, -1, -1)$.\n  - Root: $8$.\n  - Parameter: $\\alpha = 0.7$.\n  - Insertion path: $[8, 12, 14, 15]$ with side $R$ at parent $14$, meaning attach node $15$ as the right child of $14$.\n  - Expected detection: compute $s(v)$ after insertion and determine the highest $\\alpha$-scapegoat ancestor along the path, or $-1$ if none.\n\n- Test Case $2$:\n  - Nodes: $(10, 5, -1)$, $(5, 3, -1)$, $(3, -1, -1)$.\n  - Root: $10$.\n  - Parameter: $\\alpha = 0.6$.\n  - Insertion path: $[10, 5, 3, 2]$ with side $L$ at parent $3$, meaning attach node $2$ as the left child of $3$.\n  - Expected detection: compute $s(v)$ after insertion and determine the highest $\\alpha$-scapegoat ancestor along the path, or $-1$ if none.\n\n- Test Case $3$:\n  - Nodes: $(50, 40, -1)$, $(40, 30, -1)$, $(30, 20, -1)$, $(20, 10, -1)$, $(10, -1, -1)$.\n  - Root: $50$.\n  - Parameter: $\\alpha = 0.8$.\n  - Insertion path: $[50, 40, 30, 20, 10, 5]$ with side $L$ at parent $10$, meaning attach node $5$ as the left child of $10$.\n  - Expected detection: compute $s(v)$ after insertion and determine the highest $\\alpha$-scapegoat ancestor along the path, or $-1$ if none.\n\n- Test Case $4$:\n  - Nodes: $(1, -1, -1)$.\n  - Root: $1$.\n  - Parameter: $\\alpha = 0.6$.\n  - Insertion path: $[1, 2]$ with side $L$ at parent $1$, meaning attach node $2$ as the left child of $1$.\n  - Expected detection: compute $s(v)$ after insertion and determine the highest $\\alpha$-scapegoat ancestor along the path, or $-1$ if none.\n\n- Test Case $5$:\n  - Nodes: $(9, 4, 13)$, $(4, -1, 6)$, $(6, 5, 7)$, $(5, -1, -1)$, $(7, -1, -1)$, $(13, -1, -1)$.\n  - Root: $9$.\n  - Parameter: $\\alpha = 0.6$.\n  - Insertion path: $[9, 4, 6, 7, 8]$ with side $R$ at parent $7$, meaning attach node $8$ as the right child of $7$.\n  - Expected detection: compute $s(v)$ after insertion and determine the highest $\\alpha$-scapegoat ancestor along the path, or $-1$ if none.\n\nYour program should produce a single line of output containing the results for the five test cases as a comma-separated list enclosed in square brackets, in the same order as the test cases (for example, $[r_1, r_2, r_3, r_4, r_5]$). Each $r_i$ must be an integer equal to the detected scapegoat node identifier, or $-1$ if no scapegoat is detected for that case.",
            "solution": "The problem requires us to identify the \"scapegoat\" ancestor on the insertion path in a binary tree, based on the definition of $\\alpha$-weight-balance. A node becomes a scapegoat if the size of one of its child subtrees exceeds a certain fraction $\\alpha$ of its own total subtree size. The problem specifies that if multiple ancestors are scapegoats, we must identify the one highest in the tree (closest to the root).\n\nThe solution proceeds systematically through four main steps for each test case:\n1.  **Tree Construction**: The tree is represented in memory using a more convenient graph-like structure than the provided list of triples. Each node is an object containing its identifier, references to its left child, right child, and parent, and an attribute to store its subtree size. We first create all node objects from the input list and store them in a dictionary mapping their integer identifiers to the objects. Then, we iterate through the list again to establish the parent-child links between these objects, forming the complete tree structure rooted at the specified root node.\n\n2.  **Simulating Insertion**: The problem specifies that an insertion has just occurred. We simulate this by creating a new node for the inserted element and attaching it as a child to its specified parent. The parent is the second-to-last node in the given insertion path, and the side of attachment (left or right) is explicitly provided. The `parent` pointer of the new node is also set accordingly.\n\n3.  **Subtree Size Calculation**: After the insertion, the subtree sizes of all ancestors of the newly inserted node are altered. To ensure correctness, we must re-calculate the size for every node in the tree. The subtree size $s(v)$ of a node $v$ is defined as $1$ (for the node itself) plus the sizes of its left and right subtrees: $s(v) = 1 + s(\\text{v.left}) + s(\\text{v.right})$. This recursive definition naturally leads to a post-order traversal (a form of Depth-First Search) for computation. The algorithm recursively calculates the sizes of a node's children before calculating its own size. This process is initiated from the root of the tree, guaranteeing that by the time we evaluate a node $v$, the sizes for all nodes in its subtrees have already been computed and stored.\n\n4.  **Scapegoat Detection**: The core task is to find the highest ancestor of the inserted node that violates the $\\alpha$-weight-balance condition. The condition for a node $u$ to be $\\alpha$-weight-balanced is $L(u) \\le \\alpha \\cdot s(u)$ and $R(u) \\le \\alpha \\cdot s(u)$, where $L(u)$ and $R(u)$ are the sizes of the left and right child subtrees, respectively. A violation, making $u$ a scapegoat, occurs if $L(u) > \\alpha \\cdot s(u)$ or $R(u) > \\alpha \\cdot s(u)$.\nTo find the \"highest\" such ancestor (the one closest to the root), we traverse the insertion path upwards, starting from the parent of the newly added node and moving towards the root. The insertion path is given as $[p_0, p_1, \\dots, p_{k-1}, p_k]$, so the ancestor path to check is $[p_{k-1}, p_{k-2}, \\dots, p_0]$. For each ancestor $u$ on this upward path, we retrieve the pre-computed sizes of its children, $L(u)$ and $R(u)$, and its own size, $s(u)$. We then apply the scapegoat test. We iterate through the entire ancestor path, and if we find a violator, we record it. If we find another violator higher up the path, we update our record. The last violator found will be the highest one. If the traversal completes without finding any scapegoat, we return $-1$.\n\nLet's apply this logic to Test Case 2:\n- **Given**: Root $10$, $\\alpha = 0.6$, insertion path $[10, 5, 3, 2]$ with side L.\n- **Initial Tree**: A linear chain: $10 \\to 5 \\to 3$.\n- **Insertion**: Node $2$ is attached as the left child of node $3$. The tree becomes $10 \\to 5 \\to 3 \\to 2$.\n- **Size Calculation**: A post-order traversal yields: $s(2) = 1$, $s(3) = 1 + s(2) = 2$, $s(5) = 1 + s(3) = 3$, $s(10) = 1 + s(5) = 4$.\n- **Scapegoat Detection**: The ancestor path to check, from bottom up, is $[3, 5, 10]$.\n  1.  **Check node $3$**: $s(3) = 2$. Its left child is $2$, with size $L(3) = s(2) = 1$. Its right child is null, so $R(3) = 0$. The balance condition is checked against $\\alpha \\cdot s(3) = 0.6 \\cdot 2 = 1.2$. Since $L(3) = 1 \\ngtr 1.2$ and $R(3) = 0 \\ngtr 1.2$, node $3$ is balanced.\n  2.  **Check node $5$**: $s(5) = 3$. Its left child is $3$, with size $L(5) = s(3) = 2$. Its right child is null, so $R(5) = 0$. The balance condition is checked against $\\alpha \\cdot s(5) = 0.6 \\cdot 3 = 1.8$. Here, $L(5) = 2 > 1.8$. The condition is violated. We provisionally identify $5$ as the scapegoat.\n  3.  **Check node $10$**: $s(10) = 4$. Its left child is $5$, with size $L(10) = s(5) = 3$. Its right child is null, so $R(10) = 0$. The balance condition is checked against $\\alpha \\cdot s(10) = 0.6 \\cdot 4 = 2.4$. Here, $L(10) = 3 > 2.4$. The condition is violated. We update our identification to $10$, as it is higher in the tree.\n- **Result**: Since $10$ was the last (and highest) scapegoat found on the path, the algorithm returns $10$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass Node:\n    \"\"\"Represents a node in the binary tree.\"\"\"\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n        self.parent = None\n        self.size = 0\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"nodes\": [(8, 4, 12), (4, 2, -1), (12, 10, 14), (2, -1, -1), (6, -1, -1), (10, -1, -1), (14, -1, -1)],\n            \"root\": 8,\n            \"alpha\": 0.7,\n            \"path\": [8, 12, 14, 15],\n            \"side\": 'R'\n        },\n        {\n            \"nodes\": [(10, 5, -1), (5, 3, -1), (3, -1, -1)],\n            \"root\": 10,\n            \"alpha\": 0.6,\n            \"path\": [10, 5, 3, 2],\n            \"side\": 'L'\n        },\n        {\n            \"nodes\": [(50, 40, -1), (40, 30, -1), (30, 20, -1), (20, 10, -1), (10, -1, -1)],\n            \"root\": 50,\n            \"alpha\": 0.8,\n            \"path\": [50, 40, 30, 20, 10, 5],\n            \"side\": 'L'\n        },\n        {\n            \"nodes\": [(1, -1, -1)],\n            \"root\": 1,\n            \"alpha\": 0.6,\n            \"path\": [1, 2],\n            \"side\": 'L'\n        },\n        {\n            \"nodes\": [(9, 4, 13), (4, -1, 6), (6, 5, 7), (5, -1, -1), (7, -1, -1), (13, -1, -1)],\n            \"root\": 9,\n            \"alpha\": 0.6,\n            \"path\": [9, 4, 6, 7, 8],\n            \"side\": 'R'\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        results.append(process_case(case))\n    \n    print(f\"[{','.join(map(str, results))}]\")\n\ndef process_case(case_data):\n    \"\"\"\n    Processes a single test case: builds the tree, performs insertion,\n    calculates sizes, and finds the scapegoat.\n    \"\"\"\n    node_list = case_data[\"nodes\"]\n    root_id = case_data[\"root\"]\n    alpha = case_data[\"alpha\"]\n    insertion_path = case_data[\"path\"]\n    insertion_side = case_data[\"side\"]\n\n    nodes = {}\n\n    # First pass: create all node objects\n    all_node_ids = set()\n    for key, left, right in node_list:\n        all_node_ids.add(key)\n        if left != -1: all_node_ids.add(left)\n        if right != -1: all_node_ids.add(right)\n    \n    for key in all_node_ids:\n        if key in nodes: continue\n        nodes[key] = Node(key)\n\n    # Second pass: link nodes\n    for key, left_key, right_key in node_list:\n        node = nodes[key]\n        if left_key != -1:\n            node.left = nodes[left_key]\n            nodes[left_key].parent = node\n        if right_key != -1:\n            node.right = nodes[right_key]\n            nodes[right_key].parent = node\n\n    # Perform insertion\n    parent_key = insertion_path[-2]\n    new_node_key = insertion_path[-1]\n\n    parent_node = nodes[parent_key]\n    new_node = Node(new_node_key)\n    nodes[new_node_key] = new_node\n    new_node.parent = parent_node\n\n    if insertion_side == 'L':\n        parent_node.left = new_node\n    else: # 'R'\n        parent_node.right = new_node\n    \n    # Calculate subtree sizes using post-order traversal (DFS)\n    root_node = nodes[root_id]\n    compute_sizes(root_node)\n\n    # Traverse up the insertion path to find the highest scapegoat\n    ancestor_path = insertion_path[:-1]\n    scapegoat_id = -1\n\n    for node_key in reversed(ancestor_path):\n        current_node = nodes[node_key]\n        \n        left_size = current_node.left.size if current_node.left else 0\n        right_size = current_node.right.size if current_node.right else 0\n        total_size = current_node.size\n        \n        # Check for alpha-weight-balance violation\n        if left_size > alpha * total_size or right_size > alpha * total_size:\n            scapegoat_id = current_node.key\n            # Do not break; continue checking ancestors further up the tree.\n            # The last violator found will be the highest one.\n            \n    return scapegoat_id\n\n\ndef compute_sizes(node):\n    \"\"\"\n    Recursively computes the size of the subtree rooted at `node`.\n    Uses post-order traversal logic.\n    \"\"\"\n    if node is None:\n        return 0\n    \n    left_size = compute_sizes(node.left)\n    right_size = compute_sizes(node.right)\n    \n    node.size = 1 + left_size + right_size\n    return node.size\n\nsolve()\n```"
        },
        {
            "introduction": "While the weight-balance condition is fundamental, checking it on every ancestor after each insertion would be inefficient. Scapegoat trees often use a clever heuristic: a rebuild is only considered if an insertion creates a path deeper than a logarithmic threshold dependent on the balance parameter $\\alpha$. This theoretical exercise challenges you to analyze this depth-based trigger from first principles, deriving the exact number of worst-case insertions required to force the first rebuild and revealing the mathematical underpinnings of the tree's performance. ",
            "id": "3268397",
            "problem": "Consider a Scapegoat Tree, a comparison-based Binary Search Tree (BST) that maintains balance using partial rebuilding, parameterized by a real number $\\alpha$ with $ \\frac{1}{2}  \\alpha  1$. The insertion rule is as follows: maintain a global counter $q$ equal to the maximum number of nodes ever present; on every insertion into a BST rooted at the current tree, if the depth $d$ of the newly inserted node exceeds $\\left\\lfloor \\log_{1/\\alpha}(q) \\right\\rfloor$, then a rebuilding of a certain ancestor subtree is triggered. Assume there are no deletions, so that after $k$ insertions we have $q = k$. You will consider an insertion sequence of $k$ distinct keys in strictly increasing order, so that the BST path degenerates into a single right-leaning path of length $k-1$ before any rebuilds.\n\nStarting from the definitions above and basic properties of logarithms and monotone functions, derive from first principles an exact, closed-form expression (you may use the Lambert $W$ function, defined by $W(z)e^{W(z)}=z$) for the minimum number $k$ of insertions into the initially empty tree required to trigger the first rebuild, expressed as a function of $\\alpha$. Your answer must be a single symbolic expression in terms of $\\alpha$. No rounding is required.",
            "solution": "The user wants to find the minimum number of insertions, $k$, into an initially empty Scapegoat Tree that will trigger the first rebuild, given a specific insertion pattern.\n\nFirst, let's establish the state of the tree at the $k$-th insertion. The problem states that $k$ distinct keys are inserted in strictly increasing order.\n- The first key inserted becomes the root of the Binary Search Tree (BST) at depth $d=0$.\n- The second key, being larger, becomes the right child of the root, at depth $d=1$.\n- This process continues, with the $i$-th key inserted becoming the right child of the $(i-1)$-th key.\n- Consequently, after $k$ insertions, the tree is a degenerate, right-leaning path of $k$ nodes. The $k$-th node is inserted at a depth of $d = k-1$, assuming the root is at depth $0$.\n\nThe problem states that there are no deletions. Therefore, after $k$ insertions, the total number of nodes in the tree is $k$. The global counter $q$, which tracks the maximum number of nodes ever present, is thus $q=k$.\n\nThe condition for triggering a rebuild upon insertion is that the depth $d$ of the new node exceeds $\\left\\lfloor \\log_{1/\\alpha}(q) \\right\\rfloor$. Substituting the values for the $k$-th insertion, we have:\n$d = k-1$\n$q = k$\nThe rebuild condition becomes:\n$$k-1 > \\left\\lfloor \\log_{1/\\alpha}(k) \\right\\rfloor$$\n\nWe are looking for the minimum integer $k \\ge 1$ that satisfies this inequality. Let's analyze this inequality. Since $k-1$ is an integer, the condition $A > \\lfloor B \\rfloor$ is equivalent to $A \\ge \\lfloor B \\rfloor + 1$ for an integer $A$.\nThus, we seek the minimum integer $k \\ge 1$ such that:\n$$k-1 \\ge \\left\\lfloor \\log_{1/\\alpha}(k) \\right\\rfloor + 1$$\n\nTo solve this, we can analyze the behavior of the functions on both sides. A common technique for such problems involving floor or ceiling functions is to first solve a continuous version of the problem. Let's consider the continuous functions $f(x) = x-1$ and $g(x) = \\log_{1/\\alpha}(x)$. The inequality $k-1 > \\lfloor \\log_{1/\\alpha}(k) \\rfloor$ is closely related to the inequality $x-1 > \\log_{1/\\alpha}(x)$.\n\nLet's find the point of intersection by solving the equation $x-1 = \\log_{1/\\alpha}(x)$.\nUsing the change of base formula for logarithms, $\\log_{b}(a) = \\frac{\\ln(a)}{\\ln(b)}$, we can rewrite the equation in terms of the natural logarithm $\\ln$:\n$$x-1 = \\frac{\\ln(x)}{\\ln(1/\\alpha)} = \\frac{\\ln(x)}{-\\ln(\\alpha)}$$\n$$-(x-1)\\ln(\\alpha) = \\ln(x)$$\n$$\\ln(x) + (x-1)\\ln(\\alpha) = 0$$\n$$\\ln(x) + x\\ln(\\alpha) - \\ln(\\alpha) = 0$$\n$$\\ln(x) - \\ln(\\alpha) = -x\\ln(\\alpha)$$\n$$\\ln\\left(\\frac{x}{\\alpha}\\right) = -x\\ln(\\alpha)$$\nExponentiating both sides:\n$$\\frac{x}{\\alpha} = e^{-x\\ln(\\alpha)}$$\nMultiply by $\\alpha\\ln(\\alpha)$:\n$$x\\ln(\\alpha) = \\alpha\\ln(\\alpha)e^{-x\\ln(\\alpha)}$$\nNow, multiply by $e^{x\\ln(\\alpha)}$:\n$$x\\ln(\\alpha) e^{x\\ln(\\alpha)} = \\alpha\\ln(\\alpha)$$\nThis equation is in the form $u e^{u} = z$, where $u = x\\ln(\\alpha)$ and $z = \\alpha\\ln(\\alpha)$. The solution is given by the Lambert W function, $u = W(z)$.\n$$x\\ln(\\alpha) = W(\\alpha\\ln(\\alpha))$$\n$$x = \\frac{W(\\alpha\\ln(\\alpha))}{\\ln(\\alpha)}$$\nThe function $y=t e^{t}$ has a minimum value of $-1/e$ at $t=-1$. For any $z \\in [-1/e, 0)$, the equation $t e^{t}=z$ has two real solutions, denoted by the two branches of the Lambert W function: $W_0(z)$ (the principal branch, where $W_0(z) \\ge -1$) and $W_{-1}(z)$ (the lower branch, where $W_{-1}(z) \\le -1$).\n\nThe argument of the W function is $z=\\alpha\\ln(\\alpha)$. For the given range $\\frac{1}{2}  \\alpha  1$, the value of $\\alpha\\ln(\\alpha)$ is in the interval $(\\frac{1}{2}\\ln(\\frac{1}{2}), 0) \\approx (-0.346, 0)$. This interval is within $[-1/e, 0)$, so two real roots for $x$ exist.\n\nLet's analyze the function $h(x) = x-1 - \\log_{1/\\alpha}(x)$. Its roots are the solutions we just found. $h(1) = 1-1-\\log_{1/\\alpha}(1) = 0$, so $x=1$ is one root. The derivative is $h'(x) = 1 - \\frac{1}{x\\ln(1/\\alpha)}$. Since $\\frac{1}{2}  \\alpha  1$, we have $1  1/\\alpha  2$, and $0  \\ln(1/\\alpha)  \\ln(2)  1$. Thus $h'(1) = 1 - \\frac{1}{\\ln(1/\\alpha)}  0$. The function starts at $h(1)=0$, decreases to a minimum, and then increases for all larger $x$ (since $h(x) \\to \\infty$ as $x \\to \\infty$). This means there is another root $x^* > 1$. For all $x > x^*$, we have $h(x) > 0$, which means $x-1 > \\log_{1/\\alpha}(x)$.\n\nThe larger root $x^*$ corresponds to the more negative value of $u = x\\ln(\\alpha)$ (since $\\ln(\\alpha)$ is negative). The two solutions for $u$ are $W_0(\\alpha\\ln(\\alpha)) \\in [-1, 0)$ and $W_{-1}(\\alpha\\ln(\\alpha)) \\le -1$. The larger root $x^*$ must correspond to the more negative $u$, which is from the $W_{-1}$ branch.\nThus, the crossover point is:\n$$x^* = \\frac{W_{-1}(\\alpha\\ln(\\alpha))}{\\ln(\\alpha)}$$\n\nWe are looking for the smallest integer $k$ such that $k-1 > \\lfloor \\log_{1/\\alpha}(k) \\rfloor$.\n\nLet's analyze any integer $k \\le x^*$. For such a $k$, we have $h(k) \\le 0$ (since $k=1$ is a root and $h(x)$ is negative between the roots).\nSo, $k-1 \\le \\log_{1/\\alpha}(k)$.\nSince $k-1$ is an integer, this implies $k-1 \\le \\lfloor \\log_{1/\\alpha}(k) \\rfloor$. This is the opposite of the condition we need to satisfy, so no integer $k \\le x^*$ can be the solution.\n\nNow, let's analyze any integer $k > x^*$. The smallest such integer is $k_{min} = \\lfloor x^* \\rfloor + 1$.\nFor any such $k$, we have $h(k) > 0$, so $k-1 > \\log_{1/\\alpha}(k)$.\nThis implies $k-1 \\ge \\lfloor \\log_{1/\\alpha}(k) \\rfloor$. We must check if equality can hold.\nIf equality holds, $k-1 = \\lfloor \\log_{1/\\alpha}(k) \\rfloor$. This means $k-1 \\le \\log_{1/\\alpha}(k)$, which contradicts $k-1 > \\log_{1/\\alpha}(k)$.\nTherefore, equality cannot hold, and the strict inequality $k-1 > \\lfloor \\log_{1/\\alpha}(k) \\rfloor$ must be true for any integer $k > x^*$.\n\nThe minimum integer $k$ satisfying the rebuild condition is the smallest integer greater than $x^*$. This is precisely $\\lfloor x^* \\rfloor + 1$.\nThus, the minimum number of insertions $k$ is given by:\n$$k = \\left\\lfloor \\frac{W_{-1}(\\alpha\\ln(\\alpha))}{\\ln(\\alpha)} \\right\\rfloor + 1$$\nThis is the exact, closed-form expression for the minimum number of insertions required to trigger the first rebuild under the specified conditions.",
            "answer": "$$\n\\boxed{\\left\\lfloor \\frac{W_{-1}(\\alpha\\ln(\\alpha))}{\\ln(\\alpha)} \\right\\rfloor + 1}\n$$"
        },
        {
            "introduction": "Beyond balancing after insertions, scapegoat trees must also remain efficient when many elements are deleted, which can leave the tree sparse relative to its peak size. This problem places you in the role of an adversary trying to trigger a global rebuild—governed by the balance parameter $\\alpha$—as efficiently as possible. By determining the minimal sequence of operations, you will develop a deeper appreciation for the amortized analysis that proves the tree's long-term efficiency. ",
            "id": "3268410",
            "problem": "Consider a Scapegoat Tree, a weight-balanced Binary Search Tree (BST) parameterized by a fixed balance constant $\\alpha \\in ( \\frac{1}{2}, 1 )$. The Scapegoat Tree maintains the following invariants and rules:\n\n- For any node $v$ with subtree size $s(v)$, the weight-balance requirement is that for each child $u$ of $v$, the subtree size satisfies $s(u) \\leq \\alpha \\, s(v)$.\n- On each insertion, a key is inserted as a leaf and, if necessary, a violating ancestor is identified and its subtree is rebuilt to satisfy the weight-balance condition.\n- On deletion, the tree maintains a variable $m$ equal to the maximum size the tree has had since the last full rebuild. After a deletion, if the current number of keys $n$ satisfies $n  \\alpha \\, m$, then the entire tree is rebuilt and $m$ is reset to $n$.\n\nAn adversary knows $\\alpha$ and may perform a sequence comprising insertions and deletions, starting from an empty Scapegoat Tree. The adversary’s goal is to force the most expensive possible single rebuild, defined as rebuilding the entire tree (that is, the root’s subtree) when it contains exactly $N$ keys, so that the cost is proportional to $N$.\n\nAmong all possible adversarial sequences that achieve a full-tree rebuild when the tree has exactly $N$ keys, determine the minimal possible length, as a closed-form expression in terms of $\\alpha$ and $N$. The length of a sequence is the total number of operations (insertions plus deletions) performed up to and including the operation that triggers the rebuild. Provide your answer in exact form; no rounding is required.",
            "solution": "The user wants to find the minimal length of a sequence of operations (insertions and deletions) that forces a full-tree rebuild of a Scapegoat Tree at the exact moment its size becomes $N$.\n\nThe problem states that a full-tree rebuild is triggered by a deletion if the resulting number of nodes, $n$, and the maximum size the tree has had since the last full rebuild, $m$, satisfy the condition $n  \\alpha m$. The adversary's goal is to trigger this event when the final size of the tree is $n=N$. Therefore, the sequence of operations must culminate in a state where a deletion results in a tree of size $N$, and the condition $N  \\alpha m$ is met.\n\nLet the sequence of operations consist of $I$ insertions and $D$ deletions. The total length of the sequence is $L = I + D$. Since the final number of nodes in the tree is $N$, we have the relation $I - D = N$. We can express the total length $L$ in terms of $I$ and $N$:\n$$L = I + D = I + (I - N) = 2I - N$$\nTo minimize the length $L$, the adversary must minimize the total number of insertions, $I$.\n\nThe variable $m$ tracks the maximum size the tree has attained. For the rebuild condition $N  \\alpha m$ to be met, the tree must have at some point contained at least $m$ nodes. The most efficient way to achieve this is to perform insertions until the tree size reaches some peak value, which we will set as our $m$. Thus, the number of insertions $I$ must be at least $m$, i.e., $I \\ge m$. To minimize $I$, the adversary should choose the smallest possible $m$ that works and set $I=m$. The problem thus reduces to finding the minimum feasible value of $m$.\n\nThe adversary's strategy to minimize operations is as follows:\n1. Perform $m$ insertions to reach a tree size of $n=m$. At this point, the maximum size variable is also $m$. No deletions have occurred.\n2. Perform $m - (N+1)$ deletions to reduce the tree size to $N+1$.\n3. Perform one final deletion to reduce the tree size from $N+1$ to $N$. This final operation must trigger the full-tree rebuild.\n\nFor this strategy to be successful and minimal, two conditions relating to the rebuild trigger must be satisfied:\na) The final deletion, which reduces the size from $N+1$ to $N$, must trigger the rebuild. According to the rule, this means the new size $N$ must satisfy:\n$$N  \\alpha m$$\nb) To ensure that this is the first such full-tree rebuild triggered during the deletion phase, the preceding deletion (from size $N+2$ to $N+1$) must *not* have triggered a rebuild. In general, no deletion that results in a size $k > N$ should trigger a rebuild. The most restrictive case is for the smallest such size, which is $N+1$. Therefore, the size $N+1$ must *not* satisfy the rebuild condition:\n$$N+1 \\ge \\alpha m$$\n\nCombining these two inequalities, we obtain a single condition that the integer $m$ must satisfy:\n$$N  \\alpha m \\le N+1$$\nDividing by $\\alpha$ (which is positive, since $\\alpha \\in (\\frac{1}{2}, 1)$), we get:\n$$\\frac{N}{\\alpha}  m \\le \\frac{N+1}{\\alpha}$$\nThe length of the interval $(\\frac{N}{\\alpha}, \\frac{N+1}{\\alpha}]$ is $\\frac{N+1}{\\alpha} - \\frac{N}{\\alpha} = \\frac{1}{\\alpha}$. Since $\\alpha \\in (\\frac{1}{2}, 1)$, we have $\\frac{1}{\\alpha} \\in (1, 2)$. An interval of length greater than $1$ is guaranteed to contain at least one integer, so there is always an integer $m$ that satisfies this condition.\n\nTo minimize the total number of operations $L = 2I - N$, we must minimize $I$. Since the minimal number of insertions is $I=m$, we must find the smallest integer $m$ that satisfies the derived inequality. The smallest integer $m$ strictly greater than $\\frac{N}{\\alpha}$ is given by:\n$$m_{\\min} = \\left\\lfloor \\frac{N}{\\alpha} \\right\\rfloor + 1$$\nWe have already established that an integer $m$ exists in the required interval, and since this formula gives the smallest integer greater than the lower bound $\\frac{N}{\\alpha}$, this $m_{\\min}$ must be the minimal valid peak size.\n\nThe minimal number of insertions is therefore $I_{\\min} = m_{\\min} = \\lfloor \\frac{N}{\\alpha} \\rfloor + 1$.\nThe corresponding number of deletions required to reach the final size $N$ is $D = I_{\\min} - N = (\\lfloor \\frac{N}{\\alpha} \\rfloor + 1) - N$.\nThe minimal total length of the adversarial sequence is $L_{\\min} = I_{\\min} + D$.\n$$L_{\\min} = \\left( \\left\\lfloor \\frac{N}{\\alpha} \\right\\rfloor + 1 \\right) + \\left( \\left( \\left\\lfloor \\frac{N}{\\alpha} \\right\\rfloor + 1 \\right) - N \\right)$$\n$$L_{\\min} = 2 \\left( \\left\\lfloor \\frac{N}{\\alpha} \\right\\rfloor + 1 \\right) - N$$\nThis is the minimal number of operations required. The adversary's sequence consists of $I_{\\min}$ insertions to reach the peak size $m_{\\min}$, followed by $D = m_{\\min} - N$ deletions. During this process, no insertion-triggered full rebuild needs to occur (the adversary can choose insertion keys to keep the tree balanced enough), and no deletion-triggered rebuild occurs until the very last one, by our choice of $m_{\\min}$.",
            "answer": "$$\n\\boxed{2 \\left( \\left\\lfloor \\frac{N}{\\alpha} \\right\\rfloor + 1 \\right) - N}\n$$"
        }
    ]
}