{
    "hands_on_practices": [
        {
            "introduction": "Our exploration of augmented trees begins with a fundamental task: efficiently tracking the range of a dynamic set of points. While a standard balanced binary search tree can find the minimum and maximum elements in $O(\\log n)$ time, we can do better. This practice challenges you to augment each node to store the minimum and maximum values within its own subtree . By maintaining this simple augmentation, you will see how a query for the farthest pair of points in the entire set—a global property—can be answered in constant time.",
            "id": "3210318",
            "problem": "You are given a dynamic finite set of one-dimensional integer points on the real line. The goal is to support three operations on the set: insert a point, delete a point, and query the two points in the current set that are farthest apart. You must design and implement a data structure based on an augmented balanced Binary Search Tree (BST) to achieve query time $O(\\log n)$ for a set of size $n$, under arbitrary sequences of insertions and deletions.\n\nStart from the following foundational base:\n- A Binary Search Tree (BST) maintains the invariant that for any node with key $k$, all keys in its left subtree are $ k$ and all keys in its right subtree are $\\ge k$.\n- A balanced BST maintains height $O(\\log n)$, which yields $O(\\log n)$ search, insertion, and deletion via tree rotations and structural adjustments.\n- In a totally ordered set on the real line, the difference between any two points is monotonic with respect to ordering.\n\nYour task is to derive and implement an augmented tree that maintains, at each node, enough information to answer the farthest pair query on the current set in $O(\\log n)$ time. The augmentation must be maintained under insertions and deletions, and the resulting operations must preserve the asymptotic complexity guarantees consistent with balanced BST design.\n\nAssume the following rules for the dynamic set:\n- Points are integers, and the set contains no duplicates. An insertion of an already present point leaves the set unchanged.\n- Deleting a point that is not present leaves the set unchanged.\n- When the set has at least two points, the \"farthest apart\" pair is the pair of points with minimum and maximum value. When the set has exactly one point $x$, the farthest pair is defined as $x$ and $x$, with distance $0$. When the set is empty, define the farthest pair result as the triple $[0,0,0]$.\n\nYour program must implement the data structure and process the following test suite of operation sequences. For each test case, apply all operations to an initially empty set, and then output the farthest pair result as a list $[m,M,d]$, where $m$ is the minimum point in the final set, $M$ is the maximum point in the final set, and $d = M - m$ is the distance. If the final set is empty, output $[0,0,0]$.\n\nTest suite (each bullet is a test case that starts from an empty set):\n- Insert $3$, insert $-2$, insert $5$.\n- Insert $10$.\n- (No operations; the set remains empty.)\n- Insert $-100$, insert $-50$, insert $-75$, delete $-75$, insert $-60$, delete $-100$, insert $-10$.\n- Insert $-1000000000$, insert $1000000000$, insert $0$, delete $0$.\n- Insert $4$, insert $4$, delete $7$, insert $-1$, insert $9$, delete $4$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case’s result must itself be a list $[m,M,d]$. For example, a valid output format is $[[m_1,M_1,d_1],[m_2,M_2,d_2],\\dots]$ with no extra whitespace or text.",
            "solution": "We begin by establishing a mathematical foundation for the farthest pair on the real line. Let $S$ be a finite subset of $\\mathbb{Z}$ (integers considered as points on the real line). Define the distance between two points $a,b \\in S$ as $|b-a|$. Since the set is totally ordered, enumerate $S$ in nondecreasing order as $x_1 \\le x_2 \\le \\dots \\le x_n$. For any pair $x_i, x_j$ with $i \\le j$, observe that $|x_j - x_i| = x_j - x_i$ because $x_j \\ge x_i$. By monotonicity, for fixed $x_i$, $x_j - x_i$ is maximized at $x_j = x_n$, and for fixed $x_j$, $x_j - x_i$ is maximized at $x_i = x_1$. Therefore, the farthest pair is always $(x_1, x_n)$, and its distance is $x_n - x_1$. This conclusion derives directly from the ordered structure of the real line and does not rely on any shortcut formula; it follows from comparing all possible pairs and the monotone increase of difference with respect to extremes.\n\nTo answer farthest pair queries quickly under dynamic updates, we rely on a balanced Binary Search Tree (BST), specifically a randomized balanced BST known as a Treap (Tree + Heap). A Treap maintains the BST invariant on keys and a heap invariant on randomly assigned priorities. The expected height is $O(\\log n)$, giving $O(\\log n)$ expected time for search, insert, and delete.\n\nAugmentation principle: To answer farthest pair queries, it suffices to be able to obtain the minimum and maximum keys in the current set. In a naive BST, finding minimum or maximum requires descending to the leftmost or rightmost node, which takes $O(h)$ time where $h$ is the height; under balancing $h = O(\\log n)$. We can make the query $O(1)$ by augmenting each node with the minimum and maximum keys present in its subtree. Specifically, for a node with key $k$ and children $L$ and $R$, define the augmented fields:\n- $\\text{sub\\_min} = \\min\\left(\\{k\\} \\cup (\\{L.\\text{sub\\_min}\\} \\text{ if } L \\ne \\varnothing) \\cup (\\{R.\\text{sub\\_min}\\} \\text{ if } R \\ne \\varnothing)\\right)$,\n- $\\text{sub\\_max} = \\max\\left(\\{k\\} \\cup (\\{L.\\text{sub\\_max}\\} \\text{ if } L \\ne \\varnothing) \\cup (\\{R.\\text{sub\\_max}\\} \\text{ if } R \\ne \\varnothing)\\right)$.\n\nCorrectness of augmentation: We argue by structural induction on the tree. For a leaf, $\\text{sub\\_min} = \\text{sub\\_max} = k$ is correct. Assume the fields are correct for subtrees $L$ and $R$. Then the minimum element in the current node’s subtree is the minimum among $k$, the minimum in $L$, and the minimum in $R$; similarly for the maximum. Therefore, the formulas maintain correct values. Upon insertions, deletions, and rotations (used to maintain treap heap property), we recompute these augmented fields from children to parent. Because a rotation only changes local parent-child relationships while preserving the in-order sequence, recomputation via the above formulas preserves correctness.\n\nComplexity analysis: Treap insertion and deletion perform a constant expected number of rotations along the search path of expected length $O(\\log n)$. Each node update of $\\text{sub\\_min}$ and $\\text{sub\\_max}$ is $O(1)$. Therefore, both insertion and deletion run in expected $O(\\log n)$ time. The farthest pair query reduces to reading the root’s $\\text{sub\\_min}$ and $\\text{sub\\_max}$ in $O(1)$ time if the tree is nonempty. Under the problem’s required complexity bound $O(\\log n)$, this design meets and exceeds the requirement.\n\nEdge cases and definitions:\n- When the set is empty, there is no minimum or maximum. We define the query result as $[0,0,0]$.\n- When the set has exactly one element $x$, the minimum and maximum are $x$, and the farthest distance is $0$, yielding $[x,x,0]$.\n- Duplicate insertions are ignored (set semantics) because allowing duplicates is not necessary for the farthest pair, which depends only on extremes. Deleting a non-existent element does nothing.\n\nImplementation plan:\n- Represent nodes with fields: key $k$, priority $p$, pointers to left and right children, and augmentation $\\text{sub\\_min}$, $\\text{sub\\_max}$.\n- Implement treap operations: insert (recursive with rotations), delete (recursive with rotations), and update (recompute augmentation from children).\n- Implement query: if root is $\\varnothing$, return $[0,0,0]$; else return $[\\text{root.sub\\_min}, \\text{root.sub\\_max}, \\text{root.sub\\_max} - \\text{root.sub\\_min}]$.\n\nTest suite interpretation aligned with the problem statement:\n- After inserts of $3$, $-2$, $5$: $m = -2$, $M = 5$, $d = 7$.\n- After insert of $10$: $m = 10$, $M = 10$, $d = 0$.\n- No operations: empty set $\\Rightarrow [0,0,0]$.\n- After operations on negatives with interleaved deletes: final set $\\{-60,-50,-10\\}$, so $m=-60$, $M=-10$, $d=50$.\n- Large magnitudes: final set $\\{-1000000000, 1000000000\\}$, $m=-1000000000$, $M=1000000000$, $d=2000000000$.\n- Duplicate insert and delete non-existent: final set $\\{-1,9\\}$, $m=-1$, $M=9$, $d=10$.\n\nThe program constructs the treap, executes the test suite, and prints a single line with the aggregated list of per-test-case results in the exact format specified.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport random\n\nclass TreapNode:\n    __slots__ = (\"key\", \"prio\", \"left\", \"right\", \"sub_min\", \"sub_max\")\n    def __init__(self, key, prio):\n        self.key = key\n        self.prio = prio\n        self.left = None\n        self.right = None\n        self.sub_min = key\n        self.sub_max = key\n\ndef update(node: TreapNode):\n    \"\"\"Recompute augmented fields for a node from its children.\"\"\"\n    if node is None:\n        return\n    min_val = node.key\n    max_val = node.key\n    if node.left is not None:\n        if node.left.sub_min  min_val:\n            min_val = node.left.sub_min\n        if node.left.sub_max  max_val:\n            max_val = node.left.sub_max\n    if node.right is not None:\n        if node.right.sub_min  min_val:\n            min_val = node.right.sub_min\n        if node.right.sub_max  max_val:\n            max_val = node.right.sub_max\n    node.sub_min = min_val\n    node.sub_max = max_val\n\ndef rotate_right(y: TreapNode) - TreapNode:\n    \"\"\"Right rotation around y.\"\"\"\n    x = y.left\n    y.left = x.right\n    x.right = y\n    update(y)\n    update(x)\n    return x\n\ndef rotate_left(x: TreapNode) - TreapNode:\n    \"\"\"Left rotation around x.\"\"\"\n    y = x.right\n    x.right = y.left\n    y.left = x\n    update(x)\n    update(y)\n    return y\n\ndef insert(node: TreapNode, key: int, prio_func) - TreapNode:\n    \"\"\"Insert key into treap rooted at node using prio_func to assign priority.\n       Set semantics: if key already exists, no change.\"\"\"\n    if node is None:\n        return TreapNode(key, prio_func(key))\n    if key == node.key:\n        # Duplicate insert ignored (set semantics)\n        return node\n    if key  node.key:\n        node.left = insert(node.left, key, prio_func)\n        update(node)\n        if node.left is not None and node.left.prio  node.prio:\n            node = rotate_right(node)\n    else:\n        node.right = insert(node.right, key, prio_func)\n        update(node)\n        if node.right is not None and node.right.prio  node.prio:\n            node = rotate_left(node)\n    update(node)\n    return node\n\ndef delete(node: TreapNode, key: int) - TreapNode:\n    \"\"\"Delete key from treap rooted at node. If key not present, no change.\"\"\"\n    if node is None:\n        return None\n    if key  node.key:\n        node.left = delete(node.left, key)\n    elif key  node.key:\n        node.right = delete(node.right, key)\n    else:\n        # Found node to delete\n        if node.left is None and node.right is None:\n            return None\n        elif node.left is None:\n            node = rotate_left(node)\n            node.left = delete(node.left, key)\n        elif node.right is None:\n            node = rotate_right(node)\n            node.right = delete(node.right, key)\n        else:\n            # Rotate the higher-priority child up\n            if node.left.prio  node.right.prio:\n                node = rotate_right(node)\n                node.right = delete(node.right, key)\n            else:\n                node = rotate_left(node)\n                node.left = delete(node.left, key)\n    update(node)\n    return node\n\nclass AugmentedTreap:\n    def __init__(self, seed: int = 42):\n        # Use a deterministic pseudo-random priority function seeded for reproducibility.\n        random.seed(seed)\n        # Pre-generate a map from keys to priorities lazily to keep deterministic.\n        self.root = None\n        self.prio_cache = {}\n        self.rng = random.Random(seed)\n\n    def prio_func(self, key: int) - float:\n        # Deterministic priority per key using a simple hash-like transform.\n        # This keeps reproducibility while providing reasonable randomization for balance.\n        if key not in self.prio_cache:\n            # Use a combination of random and key to avoid collisions.\n            # Assign a random float in (0,1) scaled by a deterministic function of the key.\n            # But final value is determined solely by the seeded RNG on first use.\n            self.prio_cache[key] = self.rng.random()\n        return self.prio_cache[key]\n\n    def insert(self, key: int):\n        self.root = insert(self.root, key, self.prio_func)\n\n    def delete(self, key: int):\n        self.root = delete(self.root, key)\n\n    def farthest_pair(self):\n        \"\"\"Return [min, max, distance] for current set; [0,0,0] if empty.\"\"\"\n        if self.root is None:\n            return [0, 0, 0]\n        m = self.root.sub_min\n        M = self.root.sub_max\n        return [m, M, M - m]\n\ndef run_case(ops):\n    treap = AugmentedTreap(seed=123456)  # fixed seed for deterministic structure\n    for op in ops:\n        cmd = op[0]\n        if cmd == 'ins':\n            treap.insert(op[1])\n        elif cmd == 'del':\n            treap.delete(op[1])\n        else:\n            # ignore unknown commands\n            pass\n    return treap.farthest_pair()\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [('ins', 3), ('ins', -2), ('ins', 5)],\n        [('ins', 10)],\n        [],\n        [('ins', -100), ('ins', -50), ('ins', -75), ('del', -75), ('ins', -60), ('del', -100), ('ins', -10)],\n        [('ins', -1000000000), ('ins', 1000000000), ('ins', 0), ('del', 0)],\n        [('ins', 4), ('ins', 4), ('del', 7), ('ins', -1), ('ins', 9), ('del', 4)],\n    ]\n\n    results = []\n    for ops in test_cases:\n        result = run_case(ops)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "Having learned to track extremal values, we now move to a more nuanced challenge: order-based queries. Finding the $k$-th smallest element is a classic application for augmented trees, but what if we are only interested in elements that satisfy a specific property? This exercise  asks you to find the $k$-th smallest odd number in a set. You will achieve this by augmenting each node with counts of its descendants, allowing you to intelligently navigate the tree and answer sophisticated rank-based queries on a filtered subset of the data.",
            "id": "3210334",
            "problem": "You are given a finite set of integer keys and asked to support order queries on its odd elements using a binary search tree augmented with subtree metadata. Use the following fundamental base to design your solution.\n\nStart from the definition of a Binary Search Tree (BST): for every node storing a key $x$, all keys in its left subtree are strictly less than $x$, and all keys in its right subtree are strictly greater than $x$. Augment each node $v$ in the tree with two fields that must be maintained exactly under insertion and rotations: the subtree size $s(v)$, which is the total number of nodes in the subtree rooted at $v$, and the number of even keys $e(v)$ in the subtree rooted at $v$. These fields must satisfy the invariants\n$$\ns(v) = 1 + s(\\text{left}(v)) + s(\\text{right}(v)),\n$$\n$$\ne(v) = \\mathbf{1}_{\\text{even}}( \\text{key}(v) ) + e(\\text{left}(v)) + e(\\text{right}(v)),\n$$\nwhere $\\mathbf{1}_{\\text{even}}(y)$ is $1$ if $y$ is an even integer and $0$ otherwise, and $\\text{left}(v)$ and $\\text{right}(v)$ denote the left and right children of $v$, with the conventions $s(\\text{null}) = 0$ and $e(\\text{null}) = 0$. Let the count of odd keys in the subtree rooted at $v$ be $o(v) = s(v) - e(v)$.\n\nYour task is to implement a complete, runnable program that:\n- builds a randomized balanced BST (for example, a Treap) over the given integer keys with the BST property and maintains the augmentation fields $s(v)$ and $e(v)$ exactly under insertions and rotations,\n- ignores duplicate insertions so that the structure represents a mathematical set of keys,\n- answers the query \"find the $k$-th odd key in ascending order\" using only the augmentation fields and BST structure, without converting the set to an array or performing an in-order traversal that enumerates all elements.\n\nIf the $k$-th odd key does not exist (for example, there are fewer than $k$ odd keys in the set or $k \\le 0$), output the integer $0$ to indicate \"not found.\" The domain of keys is all integers $\\mathbb{Z}$, and note that $0$ is not an odd integer, so this sentinel does not conflict with any valid odd key.\n\nDesign your procedure from first principles: use the BST ordering law and the augmentation invariants to reason about how to descend the tree to locate the $k$-th odd key. Do not rely on converting the structure into an array or on any shortcut formula not derived from the given invariants.\n\nYour program must run with an internally specified test suite. For each test case, the program will:\n- insert the provided sequence of integer keys into the set (duplicates ignored),\n- compute and record the result of the single query for the given $k$,\n- return the result as a single integer according to the rules above.\n\nTest suite (each case is a pair $(S, k)$ where $S$ is the insertion sequence and $k$ is the selection index):\n- Case $1$: $S = [\\,1, 2, 3, 4, 5, 6, 7\\,]$, $k = 3$.\n- Case $2$: $S = [\\,2, 4, 6, 8\\,]$, $k = 1$.\n- Case $3$: $S = [\\,\\,]$ (the empty sequence), $k = 1$.\n- Case $4$: $S = [\\,9, 11, 13\\,]$, $k = 3$.\n- Case $5$: $S = [\\,5, 5, 5, 2, 2, 9, 10\\,]$, $k = 2$.\n- Case $6$: $S = [\\,100, 99, 98, 97, 96, 95\\,]$, $k = 4$.\n- Case $7$: $S = [\\,-3, -2, -1, 0, 1\\,]$, $k = 2$.\n\nThe required final output format is a single line containing the results for the cases above as a comma-separated list enclosed in square brackets. For example, an output should look like $[\\text{result}_1,\\text{result}_2,\\dots,\\text{result}_7]$ with no additional characters or lines.\n\nNo physical units are involved in this problem; all outputs are integers. Angles are not applicable. Percentages are not applicable.",
            "solution": "The problem is valid. It is a well-posed, scientifically grounded problem in the field of data structures and algorithms. It provides a complete and consistent set of definitions, constraints, and objectives, with no ambiguity or contradiction. The task is to design and implement a specific augmented data structure, a randomized balanced Binary Search Tree (BST), to support order statistic queries on a subset of its elements (the odd keys). This is a classic application of tree augmentation, and the problem can be solved from first principles as requested.\n\n### Principle-Based Design of the Solution\n\nThe solution is founded on the principle of augmenting a balanced Binary Search Tree to maintain aggregate information about its subtrees. This information can then be used to answer queries in logarithmic time, far more efficiently than by linear traversal. We will use a Treap, a randomized BST, to ensure balance with high probability.\n\n#### 1. Data Structure: Augmented Treap Node\n\nA Treap is a BST that simultaneously satisfies the heap property with respect to randomly assigned priorities. Each node $v$ in our Treap will store:\n- `key(v)`: The integer key, which follows the BST property. All keys in the left subtree are less than `key(v)`, and all keys in the right subtree are greater than `key(v)`.\n- `priority(v)`: A randomly assigned priority. The max-heap property is maintained: `priority(v)` is greater than or equal to the priorities of its children.\n- `left(v)` and `right(v)`: Pointers to the left and right children.\n- `s(v)`: The total number of nodes in the subtree rooted at $v$ (subtree size).\n- `e(v)`: The number of even keys in the subtree rooted at $v$.\n\n#### 2. Maintaining Augmentation Invariants\n\nThe augmentation fields, $s(v)$ and $e(v)$, must be correctly maintained through all structural modifications (insertions and rotations). The problem provides the invariants:\n$$\ns(v) = 1 + s(\\text{left}(v)) + s(\\text{right}(v))\n$$\n$$\ne(v) = \\mathbf{1}_{\\text{even}}( \\text{key}(v) ) + e(\\text{left}(v)) + e(\\text{right}(v))\n$$\nwhere `s(null) = 0` and `e(null) = 0`. $\\mathbf{1}_{\\text{even}}(y)$ is an indicator function that is $1$ if $y$ is an even integer and $0$ otherwise. A local update function, applied to a node $v$, can re-compute $s(v)$ and $e(v)$ using the already correct values from its children `left(v)` and `right(v)`. This update must be performed on any node affected by a structural change, moving up the tree from the change.\n\n#### 3. Structural Operations: Insertion and Rotations\n\n- **Insertion**: To insert a new key, we first traverse the tree to find the correct position, as in a standard BST. To maintain set semantics, if the key already exists, the operation terminates. If it's a new key, a new leaf node is created with a randomly assigned priority. This new node may violate the heap property if its priority is greater than its parent's.\n- **Rotations**: To restore the heap property, tree rotations are performed. A `left_rotate` or `right_rotate` operation restructures the tree locally, moving a child with a higher priority up and its parent down. Rotations preserve the BST property. Crucially, after a rotation involving nodes $x$ and $y$, the augmentation fields of both $y$ and then $x$ (in that order, bottom-up) must be re-calculated using the update function to reflect their new subtrees. The recursive insertion algorithm for Treaps elegantly combines insertion path finding with the necessary rotations and updates.\n\n#### 4. Query Algorithm: Finding the $k$-th Odd Key\n\nThe core of the problem is to devise an algorithm that finds the $k$-th odd key in ascending order by using only the BST structure and the augmentation fields $s(v)$ and $e(v)$. We can also use the derived quantity for the count of odd keys in a subtree, $o(v) = s(v) - e(v)$. The search starts at the root of the tree. Let the current node be $v$ and the desired rank be $k$.\n\n1.  **Initial Checks**: The query is valid only if $k  0$ and $k$ does not exceed the total number of odd keys in the tree, $o(\\text{root})$. If these conditions are not met, the key does not exist, and we return the sentinel value $0$.\n\n2.  **Recursive Search**:\n    Let `left_odd_count = o(left(v))`, which represents the number of odd keys that are smaller than `key(v)`. We analyze the position of the $k$-th odd key relative to the current node $v$:\n\n    - **Case 1: Target is in the Left Subtree.** If $k \\le \\text{left\\_odd\\_count}$, the $k$-th odd key must be one of the keys in the left subtree. We continue our search by recursively calling the function on the left child: `find_kth_odd(left(v), k)`. The rank $k$ remains unchanged.\n\n    - **Case 2: Target is the Current Node.** The key `key(v)` is the $(\\text{left\\_odd\\_count} + 1)$-th odd key in the subtree rooted at $v$, provided `key(v)` itself is odd. If `key(v)` is odd and $k = \\text{left\\_odd\\_count} + 1$, then we have found our target, and we return `key(v)`.\n\n    - **Case 3: Target is in the Right Subtree.** If the key is not in the left subtree and is not `key(v)`, it must be in the right subtree. The number of odd keys in the left subtree and at the root (if `key(v)` is odd) must be subtracted from $k$ to find the relative rank of the target within the right subtree. Let this offset be `offset = left_odd_count + (1 if key(v) is odd else 0)`. We recursively search the right subtree for the $(k - \\text{offset})$-th odd key: `find_kth_odd(right(v), k - offset)`.\n\nThis recursive descent algorithm partitions the search space at each step, leveraging the BST ordering and the augmented counts to achieve a search time proportional to the height of the tree, which is $O(\\log N)$ for a balanced tree, where $N$ is the total number of keys. This correctly avoids a full traversal of the tree.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of finding the k-th odd key in a set of integers\n    using an augmented, randomized balanced binary search tree (Treap).\n    \"\"\"\n\n    class Node:\n        \"\"\"\n        A node in the Treap. It stores the key, a random priority,\n        pointers to left and right children, and augmentation fields:\n        s (subtree size) and e (count of even keys in the subtree).\n        \"\"\"\n        def __init__(self, key):\n            self.key = key\n            # Use numpy for random priorities as specified.\n            # Large range to reduce priority collision probability.\n            self.priority = np.random.randint(0, 2**31 - 1)\n            self.left = None\n            self.right = None\n            # s: size of subtree rooted at this node\n            self.s = 1\n            # e: number of even keys in the subtree\n            self.e = 1 if key % 2 == 0 else 0\n\n    class Treap:\n        \"\"\"\n        Implements an augmented Treap data structure to support\n        order statistic queries on odd keys.\n        \"\"\"\n        def __init__(self):\n            self.root = None\n            # Seed for reproducible random priorities for testing.\n            np.random.seed(42)\n\n        def _get_s(self, node):\n            return node.s if node else 0\n\n        def _get_e(self, node):\n            return node.e if node else 0\n        \n        def _get_o(self, node):\n            # o(v) = s(v) - e(v)\n            return self._get_s(node) - self._get_e(node)\n\n        def _update_node(self, node):\n            if node:\n                node.s = 1 + self._get_s(node.left) + self._get_s(node.right)\n                is_even = 1 if node.key % 2 == 0 else 0\n                node.e = is_even + self._get_e(node.left) + self._get_e(node.right)\n\n        def _rotate_right(self, y):\n            x = y.left\n            y.left = x.right\n            x.right = y\n            self._update_node(y)\n            self._update_node(x)\n            return x\n\n        def _rotate_left(self, x):\n            y = x.right\n            x.right = y.left\n            y.left = x\n            self._update_node(x)\n            self._update_node(y)\n            return y\n\n        def _insert(self, node, key):\n            if not node:\n                return Node(key)\n\n            if key == node.key:\n                # Duplicate key, do nothing to maintain set semantics.\n                return node\n            \n            if key  node.key:\n                node.left = self._insert(node.left, key)\n                if node.left and node.left.priority  node.priority:\n                    node = self._rotate_right(node)\n            else: # key  node.key\n                node.right = self._insert(node.right, key)\n                if node.right and node.right.priority  node.priority:\n                    node = self._rotate_left(node)\n\n            self._update_node(node)\n            return node\n\n        def insert(self, key):\n            self.root = self._insert(self.root, key)\n\n        def _query_kth_odd(self, node, k):\n            if not node:\n                return 0 # Should not be reached with initial checks\n            \n            left_odd_count = self._get_o(node.left)\n            \n            if k = left_odd_count:\n                return self._query_kth_odd(node.left, k)\n            \n            is_odd = (node.key % 2 != 0)\n            \n            current_rank = left_odd_count + 1\n            if is_odd and k == current_rank:\n                return node.key\n                \n            offset = left_odd_count + (1 if is_odd else 0)\n            return self._query_kth_odd(node.right, k - offset)\n\n        def find_kth_odd(self, k):\n            total_odds = self._get_o(self.root)\n            if k = 0 or k  total_odds:\n                return 0\n            \n            return self._query_kth_odd(self.root, k)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: S = [1, 2, 3, 4, 5, 6, 7], k = 3. Odd set: {1, 3, 5, 7}. 3rd is 5.\n        ([1, 2, 3, 4, 5, 6, 7], 3),\n        # Case 2: S = [2, 4, 6, 8], k = 1. Odd set: {}. Not found.\n        ([2, 4, 6, 8], 1),\n        # Case 3: S = [], k = 1. Odd set: {}. Not found.\n        ([], 1),\n        # Case 4: S = [9, 11, 13], k = 3. Odd set: {9, 11, 13}. 3rd is 13.\n        ([9, 11, 13], 3),\n        # Case 5: S = [5, 5, 5, 2, 2, 9, 10], k = 2. Set: {2, 5, 9, 10}. Odd: {5, 9}. 2nd is 9.\n        ([5, 5, 5, 2, 2, 9, 10], 2),\n        # Case 6: S = [100, 99, 98, 97, 96, 95], k = 4. Set: {95-100}. Odd: {95, 97, 99}. 4th not found.\n        ([100, 99, 98, 97, 96, 95], 4),\n        # Case 7: S = [-3, -2, -1, 0, 1], k = 2. Set: {-3, -2, -1, 0, 1}. Odd: {-3, -1, 1}. 2nd is -1.\n        ([-3, -2, -1, 0, 1], 2),\n    ]\n\n    results = []\n    for keys, k in test_cases:\n        treap = Treap()\n        for key in keys:\n            treap.insert(key)\n        result = treap.find_kth_odd(k)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "We now transition from single points to a more complex data type: intervals. Efficiently querying a large set of intervals is a critical problem in domains from scheduling to computational geometry, and the interval tree is the canonical solution. In this practice , you will build an interval tree by augmenting a balanced BST with the maximum endpoint found in each subtree. This crucial piece of information allows the query algorithm to intelligently prune entire branches of the tree, making it possible to find all overlapping intervals far more efficiently than a linear scan.",
            "id": "3210424",
            "problem": "You are to design and implement an augmented binary search tree that maintains a dynamic set of closed intervals on the integer line. Each interval is associated with a unique identifier. The tree must support inserting a new interval, resizing an existing interval by modifying its endpoints, and querying for all intervals that overlap a given closed query interval. The final program must be a complete, runnable program that executes a fixed test suite and prints the aggregated results on a single line.\n\nBegin from the following fundamental base: a binary search tree keyed by the left endpoint of an interval, augmented with subtree information sufficient to answer overlap queries efficiently; the notion of overlap between two closed intervals; and a balanced tree design ensuring logarithmic expected running time for updates and searches. You must derive your design and implementation by carefully defining invariants and proving how they are preserved by every operation.\n\nDefinitions and requirements:\n\n- Let an interval be a closed interval $\\left[\\ell,r\\right]$ on the integer line with $\\ell \\le r$ and endpoints $\\ell,r \\in \\mathbb{Z}$. Each interval has a unique identifier $i \\in \\mathbb{Z}$.\n- The tree must be a balanced binary search tree keyed by $\\left(\\ell,i\\right)$ in lexicographic order, and every node must be augmented to store the maximum right endpoint across its subtree. Specifically, for a node storing interval $\\left[\\ell,r\\right]$ with identifier $i$, define the augmented field $$\\mathrm{max\\_end} = \\max\\left(r, \\mathrm{max\\_end}\\left(\\text{left subtree}\\right), \\mathrm{max\\_end}\\left(\\text{right subtree}\\right)\\right).$$\n- Two closed intervals $\\left[\\ell_1,r_1\\right]$ and $\\left[\\ell_2,r_2\\right]$ overlap if and only if $$\\ell_1 \\le r_2 \\quad \\text{and} \\quad \\ell_2 \\le r_1.$$\n- The tree must support the following operations:\n  1. $\\mathrm{insert}\\left(i,\\ell,r\\right)$: insert a new interval with identifier $i$ and endpoints $\\ell,r$ with the rule $\\ell \\le r$.\n  2. $\\mathrm{resize}\\left(i,\\ell',r'\\right)$: change the endpoints of the existing interval identified by $i$ to the new endpoints $\\ell',r'$ with the rule $\\ell' \\le r'$, while preserving the identity $i$. This operation must correctly update all augmentations and maintain the balanced tree invariants.\n  3. $\\mathrm{query}\\left(q_\\ell,q_r\\right)$: return the list of identifiers of all intervals in the tree that overlap the query interval $\\left[q_\\ell,q_r\\right]$. The list must be sorted in ascending order of identifiers.\n- Target time bounds: Each operation must run in expected $O\\!\\left(\\log n\\right)$ time, where $n$ is the number of intervals in the tree, by using a balanced binary search tree with appropriate augmentation.\n\nYour program must implement the above specifications, run the following test suite, and produce the results of all queries in the exact final output format described later.\n\nTest Suite:\n\n- Test case $1$ (general functionality and resizing both shrinking and shifting):\n  1. $\\mathrm{insert}\\left(1,1,5\\right)$\n  2. $\\mathrm{insert}\\left(2,4,7\\right)$\n  3. $\\mathrm{insert}\\left(3,10,12\\right)$\n  4. $\\mathrm{insert}\\left(4,6,6\\right)$\n  5. $\\mathrm{insert}\\left(5,0,2\\right)$\n  6. $\\mathrm{query}\\left(5,6\\right)$\n  7. $\\mathrm{resize}\\left(1,2,3\\right)$\n  8. $\\mathrm{query}\\left(1,2\\right)$\n  9. $\\mathrm{resize}\\left(4,7,9\\right)$\n  10. $\\mathrm{query}\\left(8,10\\right)$\n  The expected outputs for the three queries are the sorted lists of identifiers that overlap the respective query intervals.\n\n- Test case $2$ (boundary conditions including zero-length intervals and negative endpoints):\n  1. $\\mathrm{insert}\\left(10,-5,-1\\right)$\n  2. $\\mathrm{insert}\\left(11,-1,0\\right)$\n  3. $\\mathrm{insert}\\left(12,0,0\\right)$\n  4. $\\mathrm{insert}\\left(13,0,1\\right)$\n  5. $\\mathrm{query}\\left(0,0\\right)$\n  6. $\\mathrm{resize}\\left(11,-2,-2\\right)$\n  7. $\\mathrm{query}\\left(-2,-2\\right)$\n  8. $\\mathrm{resize}\\left(12,-1,1\\right)$\n  9. $\\mathrm{query}\\left(-1,0\\right)$\n  The expected outputs for the three queries are the sorted lists of identifiers that overlap the respective query intervals.\n\n- Test case $3$ (multiple intervals with the same left endpoint, resizing that changes order, and comprehensive overlap):\n  1. $\\mathrm{insert}\\left(20,5,10\\right)$\n  2. $\\mathrm{insert}\\left(21,5,5\\right)$\n  3. $\\mathrm{insert}\\left(22,5,7\\right)$\n  4. $\\mathrm{insert}\\left(23,2,3\\right)$\n  5. $\\mathrm{query}\\left(4,5\\right)$\n  6. $\\mathrm{resize}\\left(23,6,12\\right)$\n  7. $\\mathrm{query}\\left(8,9\\right)$\n  8. $\\mathrm{resize}\\left(21,4,6\\right)$\n  9. $\\mathrm{query}\\left(6,6\\right)$\n  The expected outputs for the three queries are the sorted lists of identifiers that overlap the respective query intervals.\n\nFinal Output Format:\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a list of query results, and each query result is itself a list of identifiers. For example, the format must be $$\\left[\\text{result\\_case\\_1},\\text{result\\_case\\_2},\\text{result\\_case\\_3}\\right],$$ where each $\\text{result\\_case\\_k}$ is a list of lists of integers corresponding to the queries in test case $k$. No additional text, spaces are optional, and there must be exactly one line of output.",
            "solution": "The problem requires the design and implementation of a dynamic data structure for storing and querying closed intervals on the integer line. The structure must be a balanced binary search tree, augmented to support efficient overlap queries. The required operations are insertion of a new interval, resizing of an existing interval, and querying for all intervals that overlap a given query interval. All operations must achieve an expected time complexity of $O(\\log n)$, where $n$ is the number of intervals.\n\nTo meet these requirements, we will implement an augmented Treap. A Treap is a randomized binary search tree that maintains balance with high probability, thus providing expected logarithmic time for search, insertion, and deletion operations.\n\n### Data Structure: Augmented Treap Node\nEach node in the Treap will represent a single interval. The node structure contains the following fields:\n- **Key**: A tuple $(\\ell, i)$ representing the interval's left endpoint $\\ell$ and its unique identifier $i$. The tree is ordered lexicographically by this key. This ensures a unique position for each interval, even if multiple intervals share the same left endpoint.\n- **Identifier**: The unique integer identifier $i$.\n- **Interval**: The endpoints $(\\ell, r)$ of the closed interval $[\\ell, r]$.\n- **Priority**: A randomly assigned integer used to maintain the heap property of the Treap.\n- **Children**: Pointers to the left and right children, `left` and `right`.\n- **Augmentation**: A field `max_end`, which stores the maximum right endpoint of any interval in the subtree rooted at this node.\n\n### Invariants of the Augmented Treap\nThe correctness of our data structure relies on maintaining three invariants for every node $x$ in the tree:\n\n$1$. **Binary Search Tree (BST) Invariant**: For any node $x$, all keys in the left subtree of $x$ are less than the key of $x$, and all keys in the right subtree of $x$ are greater than the key of $x$. That is, for any node $y$ in $x$'s left subtree, $y.key  x.key$, and for any node $z$ in $x$'s right subtree, $z.key  x.key$.\n\n$2$. **Heap Invariant**: The priority of node $x$ is greater than or equal to the priorities of its children. That is, if $y$ is a child of $x$, then $x.priority \\ge y.priority$.\n\n$3$. **Augmentation Invariant**: The `max_end` field of node $x$ is the maximum of its own interval's right endpoint and the `max_end` values of its children. Let `x.interval` be $[\\ell, r]$. Then,\n$$x.\\mathrm{max\\_end} = \\max(r, x.\\mathrm{left}.\\mathrm{max\\_end}, x.\\mathrm{right}.\\mathrm{max\\_end})$$\nwhere the `max_end` of a non-existent child (i.e., `None`) is taken to be $-\\infty$.\n\n### Maintaining Invariants\nThe BST and heap invariants are maintained using standard Treap operations involving rotations. After any structural modification to the tree (insertion, deletion, rotation), the augmentation invariant must be restored. This is achieved by a helper function `_update_max_end(node)`, which recalculates `node.max_end` based on the definition. This function is called on all affected nodes in a bottom-up fashion. Rotations are the fundamental operations for rebalancing, and they must correctly update the `max_end` fields.\n\n- `_rotate_left(y)`: Let $x$ be the right child of $y$. The rotation makes $x$ the new root of this subtree and $y$ its left child. The `max_end` fields must be updated first for $y$ (the new child) and then for $x$ (the new parent), as $x$'s new value depends on $y$'s updated value.\n- `_rotate_right(x)`: Let $y$ be the left child of $x$. The rotation makes $y$ the new root and $x$ its right child. The `max_end` fields are updated first for $x$ and then for $y$.\n\n### Operation Implementation\nTo facilitate the `resize` operation, which requires finding a node by its identifier $i$, we use an auxiliary dictionary that maps each identifier $i$ to its corresponding node object in the tree.\n\n$1$. **$\\mathrm{insert}(i, \\ell, r)$**:\n- A new node is created with key $(\\ell, i)$, interval $[\\ell, r]$, and a randomly generated priority.\n- The node is inserted into the tree following the standard BST insertion logic, placing it at a leaf position based on its key.\n- The tree is then rebalanced by performing rotations up the path from the new node to the root, restoring the heap invariant wherever it is violated (i.e., where a child has a higher priority than its parent).\n- During the recursive unwinding of the insertion path, the `max_end` values of all ancestor nodes are updated.\n- The auxiliary dictionary is updated with the mapping from $i$ to the newly created node.\nThis process takes expected $O(\\log n)$ time.\n\n$2$. **$\\mathrm{resize}(i, \\ell', r')$**:\nThe `resize` operation modifies the interval associated with identifier $i$ to $[\\ell', r']$. If the left endpoint $\\ell$ changes to $\\ell'$, the node's key $(\\ell, i)$ changes, requiring its physical relocation within the tree to maintain the BST invariant. The most robust way to handle this is to perform a deletion followed by an insertion.\n- The node to be modified is located in $O(1)$ time using the auxiliary dictionary. Let its current interval be $[\\ell, r]$.\n- The node with key $(\\ell, i)$ is deleted from the Treap. Deletion in a Treap involves rotating the target node down until it becomes a leaf, then removing it. Throughout this process, `max_end` values on the path are updated.\n- A new interval with identifier $i$ and endpoints $[\\ell', r']$ is inserted into the tree using the `insert` operation described above.\nSince both deletion and insertion take expected $O(\\log n)$ time, the entire `resize` operation also takes expected $O(\\log n)$ time.\n\n$3$. **$\\mathrm{query}(q_\\ell, q_r)$**:\nThe query operation finds all intervals $[\\ell, r]$ in the tree that overlap with the query interval $[q_\\ell, q_r]$. Two intervals $[\\ell_1, r_1]$ and $[\\ell_2, r_2]$ overlap if $\\ell_1 \\le r_2$ and $\\ell_2 \\le r_1$. The query algorithm recursively traverses the tree, using the `max_end` augmentation to prune search paths.\n\nThe search procedure at a given node $x$ storing interval $[\\ell, r]$ is as follows:\n- **Check the current node**: Test if the interval $[\\ell, r]$ overlaps with $[q_\\ell, q_r]$. If $\\ell \\le q_r$ and $q_\\ell \\le r$, add the identifier $i$ to the result set.\n- **Search the left subtree**: The search must proceed to the left subtree if it might contain an overlapping interval. An interval $[l_{sub}, r_{sub}]$ in the left subtree could overlap with $[q_\\ell, q_r]$ only if $r_{sub} \\ge q_\\ell$. The `max_end` field of the left child, `x.left.max_end`, represents the maximum possible $r_{sub}$ in that entire subtree. Therefore, we only need to search the left subtree if `x.left` is not `None` and `x.left.max_end \\ge q_\\ell$. If this condition is not met, the entire left subtree can be pruned.\n- **Search the right subtree**: Due to the BST invariant, all intervals in the right subtree have a left endpoint greater than or equal to $\\ell$. If $\\ell  q_r$, then any interval in the right subtree will also have its left endpoint greater than $q_r$, making overlap impossible. Thus, we only search the right subtree if `x.right` is not `None` and $\\ell \\le q_r$.\n\nThis search strategy traverses a limited number of paths, leading to an efficient query time of $O(k + \\log n)$, where $k$ is the number of reported overlapping intervals. The problem statement's target is $O(\\log n)$, which is typically used as a shorthand for this complexity class in the context of range and interval queries. Finally, the collected identifiers are sorted in ascending order.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass IntervalTree:\n    \"\"\"\n    An augmented Treap for managing and querying dynamic sets of closed intervals.\n    The tree is keyed by (left_endpoint, identifier) and augmented with the\n    maximum right endpoint in each subtree.\n    \"\"\"\n\n    class Node:\n        def __init__(self, id, l, r, priority):\n            self.id = id\n            self.l = l\n            self.r = r\n            self.key = (l, id)\n            self.priority = priority\n            self.max_end = r\n            self.left = None\n            self.right = None\n\n    def __init__(self, seed=None):\n        self.root = None\n        self.id_to_node = {}\n        if seed is not None:\n            self._rng = np.random.RandomState(seed)\n        else:\n            self._rng = np.random\n        # Using a fixed seed for reproducibility across runs.\n        np.random.seed(42)\n\n    def _get_max_end(self, node):\n        return node.max_end if node else -float('inf')\n\n    def _update_max_end(self, node):\n        if node:\n            node.max_end = max(node.r, self._get_max_end(node.left), self._get_max_end(node.right))\n\n    def _rotate_right(self, y):\n        x = y.left\n        y.left = x.right\n        x.right = y\n        self._update_max_end(y)\n        self._update_max_end(x)\n        return x\n\n    def _rotate_left(self, x):\n        y = x.right\n        x.right = y.left\n        y.left = x\n        self._update_max_end(x)\n        self._update_max_end(y)\n        return y\n\n    def _insert(self, root, node):\n        if not root:\n            return node\n        \n        if node.key  root.key:\n            root.left = self._insert(root.left, node)\n            if root.left.priority  root.priority:\n                root = self._rotate_right(root)\n        else:\n            root.right = self._insert(root.right, node)\n            if root.right.priority  root.priority:\n                root = self._rotate_left(root)\n        \n        self._update_max_end(root)\n        return root\n\n    def insert(self, i, l, r):\n        if i in self.id_to_node:\n            raise ValueError(f\"Identifier {i} already exists.\")\n        \n        priority = self._rng.randint(0, 2**32 - 1)\n        node = self.Node(i, l, r, priority)\n        self.id_to_node[i] = node\n        self.root = self._insert(self.root, node)\n\n    def _delete(self, root, key):\n        if not root:\n            return None\n        \n        if key  root.key:\n            root.left = self._delete(root.left, key)\n        elif key  root.key:\n            root.right = self._delete(root.right, key)\n        else:\n            if not root.left:\n                return root.right\n            if not root.right:\n                return root.left\n            \n            if root.left.priority  root.right.priority:\n                root = self._rotate_right(root)\n                root.right = self._delete(root.right, key)\n            else:\n                root = self._rotate_left(root)\n                root.left = self._delete(root.left, key)\n        \n        self._update_max_end(root)\n        return root\n\n    def resize(self, i, l_new, r_new):\n        if i not in self.id_to_node:\n            raise ValueError(f\"Identifier {i} not found for resizing.\")\n        \n        # Delete the old node\n        old_node = self.id_to_node[i]\n        self.root = self._delete(self.root, old_node.key)\n        del self.id_to_node[i]\n        \n        # Insert the new version\n        self.insert(i, l_new, r_new)\n\n    def _query(self, node, q_l, q_r, results):\n        if not node:\n            return\n\n        # Prune left subtree if no interval can possibly overlap the query's start\n        if node.left and node.left.max_end = q_l:\n            self._query(node.left, q_l, q_r, results)\n        \n        # Check current node for overlap\n        if node.l = q_r and q_l = node.r:\n            results.add(node.id)\n\n        # Prune right subtree if its intervals start after the query ends\n        if node.l = q_r:\n            self._query(node.right, q_l, q_r, results)\n\n    def query(self, q_l, q_r):\n        results = set()\n        self._query(self.root, q_l, q_r, results)\n        return sorted(list(results))\n\ndef solve():\n    test_suite = [\n        [ # Test case 1\n            (\"insert\", (1, 1, 5)),\n            (\"insert\", (2, 4, 7)),\n            (\"insert\", (3, 10, 12)),\n            (\"insert\", (4, 6, 6)),\n            (\"insert\", (5, 0, 2)),\n            (\"query\", (5, 6)),\n            (\"resize\", (1, 2, 3)),\n            (\"query\", (1, 2)),\n            (\"resize\", (4, 7, 9)),\n            (\"query\", (8, 10)),\n        ],\n        [ # Test case 2\n            (\"insert\", (10, -5, -1)),\n            (\"insert\", (11, -1, 0)),\n            (\"insert\", (12, 0, 0)),\n            (\"insert\", (13, 0, 1)),\n            (\"query\", (0, 0)),\n            (\"resize\", (11, -2, -2)),\n            (\"query\", (-2, -2)),\n            (\"resize\", (12, -1, 1)),\n            (\"query\", (-1, 0)),\n        ],\n        [ # Test case 3\n            (\"insert\", (20, 5, 10)),\n            (\"insert\", (21, 5, 5)),\n            (\"insert\", (22, 5, 7)),\n            (\"insert\", (23, 2, 3)),\n            (\"query\", (4, 5)),\n            (\"resize\", (23, 6, 12)),\n            (\"query\", (8, 9)),\n            (\"resize\", (21, 4, 6)),\n            (\"query\", (6, 6)),\n        ]\n    ]\n\n    all_results = []\n    for case_ops in test_suite:\n        tree = IntervalTree()\n        case_results = []\n        for op, args in case_ops:\n            if op == \"insert\":\n                tree.insert(*args)\n            elif op == \"resize\":\n                tree.resize(*args)\n            elif op == \"query\":\n                result = tree.query(*args)\n                case_results.append(result)\n        all_results.append(case_results)\n    \n    # Format the output string precisely as required, with no spaces.\n    output_str = str(all_results).replace(\" \", \"\")\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}