{
    "hands_on_practices": [
        {
            "introduction": "我们从一个基础问题开始：对于数组中的每个元素，找到其左侧和右侧最近的比它大的元素。这个“下一个更大元素”模式是单调栈的经典应用。解决这个问题将帮助你掌握在单次遍历中，如何利用栈结构高效地追踪和淘汰候选元素的核心技巧，为应对更复杂的挑战奠定基础。",
            "id": "3253891",
            "problem": "给定一个长度为 $n$ 的整数序列 $A = [a_0, a_1, \\dots, a_{n-1}]$，使用基于 $0$ 的索引。对于每个满足 $0 \\le i  n$ 的位置 $i$，定义两个量：左侧最近的严格大于它的元素和右侧最近的严格大于它的元素。更准确地说，位置 $i$ 左侧最近的严格大于它的元素是指索引 $j$，满足 $0 \\le j  i$、$a_j > a_i$ 且 $i - j$ 最小；如果不存在这样的 $j$，则位置 $i$ 左侧的输出为 $-1$。类似地，位置 $i$ 右侧最近的严格大于它的元素是指索引 $k$，满足 $i  k \\le n-1$、$a_k > a_i$ 且 $k - i$ 最小；如果不存在这样的 $k$，则位置 $i$ 右侧的输出为 $-1$。你的任务是编写一个完整的、可运行的程序，该程序能为下面测试套件中的每个数组，计算出两个列表：一个是所有位置 $i$ 的左侧最近严格大于元素的索引列表，另一个是所有位置 $i$ 的右侧最近严格大于元素的索引列表。\n\n基本要求：使用双端队列（deque）的核心定义，即一种支持在两端进行插入和移除操作并保持顺序的序列，并利用单调数据结构的标准不变量，该结构在推入（push）和弹出（pop）操作下能保持非递增或非递减顺序。基于这些定义，推导出一个对每个数组都能在 $\\mathcal{O}(n)$ 时间内运行的算法，且不得使用任何快捷公式。\n\n用于评估你的程序的测试套件：\n- 情况 $1$：$A_1 = [3,7,1,7,8,4]$\n- 情况 $2$：$A_2 = [1,2,3,4]$\n- 情况 $3$：$A_3 = [9,7,5,3,1]$\n- 情况 $4$：$A_4 = [5,5,5,5]$\n- 情况 $5$：$A_5 = [10]$\n- 情况 $6$：$A_6 = [2,1,2,1,2]$\n\n输出规范：\n- 对于每个情况 $A_t$，输出一个列表对 $[L_t, R_t]$，其中 $L_t$ 包含所有位置 $i$ 的左侧最近严格大于元素的索引，而 $R_t$ 包含所有位置 $i$ 的右侧最近严格大于元素的索引。如果在位置 $i$ 的某一侧不存在严格大于它的元素，则在相应列表的该位置使用 $-1$。\n- 你的程序应生成单行输出，其中包含六个情况的结果，格式为一个由逗号分隔的列表，并用方括号括起来，不含空格。例如，一个有效的格式是 $[[L_1,R_1],[L_2,R_2],\\dots,[L_6,R_6]]$。\n\n所有答案都是整数索引列表。不涉及任何物理单位、角度单位或百分比。请确保算法设计具有普适性，并且是根据单调数据结构的不变量和定义逻辑推导出来的。",
            "solution": "经评估，该问题是有效的。它是一个定义明确、自成体系且客观的算法任务，植根于计算机科学原理。它没有科学上的不严谨性、模糊性或矛盾之处。\n\n任务是为序列 $A = [a_0, a_1, \\dots, a_{n-1}]$ 中的每个元素找到其左侧和右侧最近的严格大于它的元素。我们需要基于双端队列（deque）和单调数据结构的基本特性，推导出一个时间复杂度为 $\\mathcal{O}(n)$ 的算法。\n\n让我们首先将这两个子问题形式化：\n1.  **左侧最近更大值 (NGL)**：对于每个索引 $i \\in [0, n-1]$，找到一个索引 $j$，使得 $j  i$，$a_j > a_i$，并且距离 $i-j$ 最小化。如果不存在这样的 $j$，结果为 $-1$。\n2.  **右侧最近更大值 (NGR)**：对于每个索引 $i \\in [0, n-1]$，找到一个索引 $k$，使得 $k > i$，$a_k > a_i$，并且距离 $k-i$ 最小化。如果不存在这样的 $k$，结果为 $-1$。\n\n这两个问题是对称的。我们可以为 NGL 推导出一个解决方案，然后反向应用相同的逻辑来解决 NGR。\n\n### NGL 算法的推导\n\n为每个元素 $a_i$ 寻找 NGL 的一个朴素方法是扫描其左侧的所有元素，从 $j=i-1$ 向下到 $0$。第一个满足 $a_j > a_i$ 的 $j$ 就是答案。这需要一个嵌套循环结构，导致最坏情况下的时间复杂度为 $\\mathcal{O}(n^2)$，例如，当输入数组按升序排序时。这种方法效率低下，不满足问题的性能要求。\n\n为了实现 $\\mathcal{O}(n)$ 的解法，我们必须在单次遍历中处理数组。让我们从左到右遍历数组，从 $i=0$ 到 $n-1$。在每一步 $i$，我们需要在元素 $[a_0, a_1, \\dots, a_{i-1}]$ 中高效地找到 $a_i$ 的 NGL。\n\n考虑 $a_i$ 左侧的元素集合。并非所有这些元素都能成为未来元素的 NGL 的有效候选者。假设我们有两个索引 $p$ 和 $q$ 满足 $p  q  i$。如果 $a_p \\le a_q$，那么对于任何未来的元素 $a_k$ (其中 $k > i$)，$a_p$ 永远不可能是它的 NGL。这是因为如果 $a_p$ 是一个潜在候选者（即 $a_p > a_k$），那么 $a_q$ 也必定是一个候选者（$a_q \\ge a_p > a_k$），并且由于 $q$ 比 $p$ 更接近 $k$，$a_q$ 将被优先选择。因此，$a_p$ 被 $a_q$ “阻挡”了，可以从我们的潜在 NGL 候选集合中丢弃。\n\n这一观察导出了一个关键的不变量：有用的 NGL 候选者所对应的索引集合，当从左到右读取时，其对应的值必须构成一个严格递减的序列。假设这些候选索引存储在一个序列 $s = [j_1, j_2, \\dots, j_m]$ 中，其中 $j_1  j_2  \\dots  j_m  i$。要使这个集合有用，它必须满足 $a_{j_1} > a_{j_2} > \\dots > a_{j_m}$。这就是**单调递减栈**的定义属性。\n\n一个用作栈的双端队列是维护这个候选索引序列的理想数据结构。当我们处理一个新元素 $a_i$ 时，我们执行以下步骤：\n\n1.  **维护单调不变量**：我们查看栈顶的索引 $j$。如果 $a_j \\le a_i$，那么 $a_j$ 不能是 $a_i$ 的 NGL（因为它不是严格大于），也不能是任何未来元素的 NGL，因为 $a_i$ 更近并且值至少一样大。因此，我们可以将 $j$ 从栈中弹出。我们重复这个过程，直到栈为空，或者栈顶对应的元素值严格大于 $a_i$。\n\n2.  **寻找 NGL**：完成步骤 1 后，栈的状态就确定了。\n    *   如果此时栈为空，意味着 $a_i$ 左侧没有严格大于它的元素。$a_i$ 的 NGL 为 $-1$。\n    *   如果栈不为空，栈顶的索引 $j$ 就是 $i$ 左侧第一个满足 $a_j > a_i$ 的元素。由于我们是按递增顺序处理索引的，这个 $j$ 保证是最近的一个。因此，$a_i$ 的 NGL 就是栈顶的索引。\n\n3.  **添加当前元素**：我们将当前索引 $i$ 推入栈中。这使得 $a_i$ 成为后续元素的 NGL 候选者。不变量得以维持，因为其左侧任何值较小或相等的元素都已被移除。\n\n每个索引都只入栈一次，最多出栈一次。因此，栈操作的总数与 $n$ 成正比，从而使得整个遍历的摊还时间复杂度为 $\\mathcal{O}(n)$。\n\n### NGR 算法的推导\n\nNGR 问题是 NGL 问题的一个镜像。我们可以通过应用完全相同的单调栈逻辑来找到所有元素的 NGR，但需要从右到左遍历数组（即从 $i=n-1$ 到 $0$）。逻辑保持不变：对于每个 $a_i$，我们从栈中弹出所有对应值小于或等于 $a_i$ 的索引。栈顶剩下的索引（如果有的话）就是 NGR。\n\n### 完整算法\n\n最终算法包括对输入数组的两次独立遍历，每次遍历耗时 $\\mathcal{O}(n)$。\n\n**第 1 遍：左侧最近更大值 (NGL)**\n1.  初始化一个空的双端队列/栈 `s`，用于存储索引。\n2.  初始化一个大小为 $n$ 的结果数组 $L$。\n3.  使用索引 $i$ 从 $0$ 遍历到 $n-1$：\n    a. 当 `s` 不为空且 $a_{\\text{s.top()}} \\le a_i$ 时，从 `s` 中弹出元素。\n    b. 如果 `s` 不为空，则设置 $L[i] = \\text{s.top()}$，否则设置 $L[i] = -1$。\n    c. 将 $i$ 推入 `s`。\n\n**第 2 遍：右侧最近更大值 (NGR)**\n1.  清空双端队列/栈 `s`。\n2.  初始化一个大小为 $n$ 的结果数组 $R$。\n3.  使用索引 $i$ 从 $n-1$ 向下遍历到 $0$：\n    a. 当 `s` 不为空且 $a_{\\text{s.top()}} \\le a_i$ 时，从 `s` 中弹出元素。\n    b. 如果 `s` 不为空，则设置 $R[i] = \\text{s.top()}$，否则设置 $R[i] = -1$。\n    c. 将 $i$ 推入 `s`。\n\n列表对 $[L, R]$ 就是输入数组 $A$ 的解。总时间复杂度为 $\\mathcal{O}(n) + \\mathcal{O}(n) = \\mathcal{O}(n)$，空间复杂度为 $\\mathcal{O}(n)$，用于存储栈和结果数组。该设计具有普适性，并且是直接从单调数据结构的不变量推导出来的。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the nearest strictly greater element problem for a suite of test cases.\n    \"\"\"\n\n    test_cases = [\n        [3, 7, 1, 7, 8, 4],       # Case 1\n        [1, 2, 3, 4],             # Case 2\n        [9, 7, 5, 3, 1],          # Case 3\n        [5, 5, 5, 5],             # Case 4\n        [10],                     # Case 5\n        [2, 1, 2, 1, 2],          # Case 6\n    ]\n\n    def compute_nearest_greater_elements(arr):\n        \"\"\"\n        Computes the nearest strictly greater element to the left (NGL) and right (NGR)\n        for each element in the input array using a monotonic stack.\n\n        The algorithm performs two passes, one left-to-right for NGL and one\n        right-to-left for NGR. Each pass has an O(n) time complexity.\n\n        Args:\n            arr (list): The input list of integers.\n\n        Returns:\n            list: A pair of lists, [left_results, right_results], where\n                  left_results contains NGL indices and right_results contains\n                  NGR indices.\n        \"\"\"\n        n = len(arr)\n        if n == 0:\n            return [[], []]\n\n        # Initialize result arrays with -1\n        left_greater = np.full(n, -1, dtype=int)\n        right_greater = np.full(n, -1, dtype=int)\n\n        # Using a standard list as a stack to store indices\n        stack = []\n\n        # Pass 1: Left-to-Right for Nearest Greater to the Left (NGL)\n        for i in range(n):\n            # While stack is not empty and the element at the index on top of the stack\n            # is less than or equal to the current element, pop from the stack.\n            # This maintains the monotonic (strictly decreasing) property of the\n            # values corresponding to the indices in the stack.\n            while stack and arr[stack[-1]] = arr[i]:\n                stack.pop()\n            \n            # If the stack is not empty after popping, the index at the top is the NGL.\n            if stack:\n                left_greater[i] = stack[-1]\n            \n            # Push the current index onto the stack for future comparisons.\n            stack.append(i)\n\n        # Clear the stack for the second pass\n        stack.clear()\n\n        # Pass 2: Right-to-Left for Nearest Greater to the Right (NGR)\n        # The logic is symmetric to the first pass.\n        for i in range(n - 1, -1, -1):\n            while stack and arr[stack[-1]] = arr[i]:\n                stack.pop()\n            \n            if stack:\n                right_greater[i] = stack[-1]\n            \n            stack.append(i)\n            \n        return [left_greater.tolist(), right_greater.tolist()]\n\n    all_results_str = []\n    for case_array in test_cases:\n        # Compute the result pair [L, R]\n        result_pair = compute_nearest_greater_elements(case_array)\n        \n        # Manually format the output strings to avoid spaces, as per the specification.\n        # Format the list of left indices, e.g., \"[-1,-1,1,-1,-1,4]\"\n        left_str = f\"[{','.join(map(str, result_pair[0]))}]\"\n        # Format the list of right indices, e.g., \"[1,4,3,4,-1,-1]\"\n        right_str = f\"[{','.join(map(str, result_pair[1]))}]\"\n        \n        # Combine into the final string for one case, e.g., \"[[-1,-1,1,-1,-1,4],[1,4,3,4,-1,-1]]\"\n        pair_str = f\"[{left_str},{right_str}]\"\n        all_results_str.append(pair_str)\n\n    # Join all case results into a single line, e.g., \"[[...],[...],...]\"\n    final_output = f\"[{','.join(all_results_str)}]\"\n    \n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "现在，让我们在之前概念的基础上解决一个看似更复杂的问题：计算所有连续子数组最大值之和。暴力求解的计算成本很高，但我们可以转换思路，通过计算每个元素对总和的贡献来解决。一个元素的贡献取决于它作为最大值的子数组数量，而这个数量恰恰是由其“最近更大元素”所确定的边界来定义的——这直接应用了你刚刚练习的技巧。",
            "id": "3253905",
            "problem": "给定一个长度为 $n$ 的整数数组 $A$，其中可能包含负值。对于 $A$ 的每个连续子数组 $B$，令 $\\max(B)$ 表示 $B$ 中的最大元素。您的任务是计算所有非空连续子数组 $B$ 的 $\\max(B)$ 之和。如果 $A$ 为空，则总和定义为 $0$。\n\n推理和推导的基本依据：\n- 连续子数组的定义：一个序列 $A[\\ell], A[\\ell+1], \\dots, A[r]$，其中整数 $\\ell$ 和 $r$ 满足 $0 \\le \\ell \\le r \\le n-1$。\n- 最大值的定义：对于任何有限整数集合 $S$，值 $\\max(S)$ 是 $S$ 中的唯一元素 $m \\in S$，使得对于所有 $s \\in S$ 都有 $m \\ge s$。\n- 关于双端队列的成熟事实：双端队列（也称为 deque）支持在两端进行插入和删除。单调双端队列对其存储的索引所关联的值维持一个顺序不变量（非递增或非递减），并且在标准的推入-弹出规则下，每个索引最多被插入和移除一次，从而使每次操作的均摊时间为 $\\mathcal{O}(1)$，在 $n$ 次操作中的总时间为 $\\mathcal{O}(n)$。\n- 计数原理：如果若干不相交的组划分了一个有限集，则该集合的总大小等于各组大小之和。\n\n您的程序必须实现一个基于这些基本定义和事实的算法，不依赖任何给定的快捷公式，以推导出一种使用单调双端队列的 $\\mathcal{O}(n)$ 方法，来聚合 $A$ 中每个元素对总和的贡献。\n\n输入和输出由以下测试套件固定。不涉及物理单位或角度。\n\n测试套件：\n为以下每个数组 $A$ 评估所述的总和：\n- 测试 $1$：$[3,1,2,4]$\n- 测试 $2$：$[2,2,2]$\n- 测试 $3$：$[5,4,3,2,1]$\n- 测试 $4$：$[-1,0,-3,2]$\n- 测试 $5$：$[]$\n- 测试 $6$：$[7]$\n\n最终输出格式：\n您的程序应生成一行输出，其中包含测试 1 到 6 的结果，按顺序排列，形式为一个逗号分隔的列表，用方括号括起来，不含空格。例如，一个包含三个结果的输出应如 `[r1,r2,r3]` 所示。",
            "solution": "目标是计算给定整数数组 $A$ 的所有非空连续子数组的最大元素之和。设此和为 $S$。该问题可以正式表述为：\n$$ S = \\sum_{\\ell=0}^{n-1} \\sum_{r=\\ell}^{n-1} \\max(A[\\ell \\dots r]) $$\n其中 $A[\\ell \\dots r]$ 代表从索引 $\\ell$ 到 $r$ 的连续子数组，$n$ 是 $A$ 的长度。\n\n基于此公式的直接计算将涉及遍历所有 $\\mathcal{O}(n^2)$ 个连续子数组，并找到每个子数组的最大值（这可能需要高达 $\\mathcal{O}(n)$ 的时间），从而导致总体时间复杂度为 $\\mathcal{O}(n^3)$，或优化后为 $\\mathcal{O}(n^2)$。对于大的 $n$ 来说，这是低效的。对 $\\mathcal{O}(n)$ 解法的要求表明需要一种不同的方法。\n\n我们可以应用计数原理来重新构建这个问题。与其对子数组求和，不如我们对 $A$ 的元素求和，计算每个元素对总和的贡献。元素 $A[i]$ 的贡献是 $A[i]$ 乘以以 $A[i]$ 为最大元素的连续子数组的数量。\n$$ S = \\sum_{i=0}^{n-1} A[i] \\cdot (\\text{以 } A[i] \\text{ 为最大值的子数组数量}) $$\n\n一个关键方面是处理子数组中多个元素共享相同最大值的情况。为确保每个子数组的最大值只被计算一次，我们需要一个一致的平局打破规则。一个标准的约定是将子数组中最大值的*首次*出现指定为其“官方”最大值。\n因此，要使元素 $A[i]$ 成为子数组 $A[\\ell \\dots r]$ (其中 $\\ell \\le i \\le r$) 的指定最大值，必须满足两个条件：\n1.  对于子数组中的所有其他元素 $A[k]$ (即 $k \\in [\\ell, r]$)，有 $A[k] \\le A[i]$。\n2.  对于子数组中在 $A[i]$ 左侧的所有元素 $A[k]$ (即 $k \\in [\\ell, i-1]$)，不等式必须是严格的：$A[k]  A[i]$。\n\n为了对一个固定的索引 $i$ 计算这类子数组的数量，我们需要找到起始索引 $\\ell$ 和结束索引 $r$ 的有效范围。\n条件 $A[k]  A[i]$ 对于所有 $k \\in [\\ell, i-1]$ 成立，意味着子数组不能向左延伸以包含任何满足 $j  i$ 和 $A[j] \\ge A[i]$ 的元素 $A[j]$。设 $p_i$ 为 $i$ 左侧最近的满足 $A[p_i] \\ge A[i]$ 的元素索引。这就是“前一个大于或等于”的元素。如果不存在这样的元素，我们定义 $p_i = -1$。起始索引 $\\ell$ 必须大于 $p_i$，所以 $\\ell \\in [p_i+1, i]$。$\\ell$ 的选择数量为 $i - (p_i+1) + 1 = i - p_i$。\n\n条件 $A[k] \\le A[i]$ 对于所有 $k \\in [i+1, r]$ 成立，意味着子数组不能向右延伸以包含任何满足 $j > i$ 和 $A[j] > A[i]$ 的元素 $A[j]$。设 $q_i$ 为 $i$ 右侧最近的满足 $A[q_i] > A[i]$ 的元素索引。这就是“后一个严格大于”的元素。如果不存在这样的元素，我们定义 $q_i = n$。结束索引 $r$ 必须小于 $q_i$，所以 $r \\in [i, q_i-1]$。$r$ 的选择数量为 $(q_i-1) - i + 1 = q_i - i$。\n\n以 $A[i]$ 为指定最大值的子数组总数是 $\\ell$ 和 $r$ 选择数量的乘积，即 $(i - p_i) \\cdot (q_i - i)$。$A[i]$ 对总和的贡献是 $A[i] \\cdot (i - p_i) \\cdot (q_i - i)$。总和为：\n$$ S = \\sum_{i=0}^{n-1} A[i] \\cdot (i - p_i) \\cdot (q_i - i) $$\n\n剩下的任务是在线性时间内计算索引数组 $p$ (PGE) 和 $q$ (NSG)。这是一个单调双端队列（或栈）的经典应用。\n\n**1. 计算前一个大于或等于 (PGE) 的索引 ($p_i$)：**\n我们从 $i=0$ 遍历到 $n-1$，并使用一个栈来存储元素索引，这些元素的值呈单调递减顺序。\n设 `stack` 是一个用作栈的双端队列。对于每个索引 $i$：\n- 当 `stack` 非空且 $A[\\text{stack.top()}]  A[i]$ 时，从栈中弹出元素。被弹出的元素比 $A[i]$ 小且位于其左侧，因此它们不可能是 $A[i]$ 或任何后续元素的 PGE。\n- 循环结束后，如果 `stack` 为空，则左侧没有大于或等于 $A[i]$ 的元素，因此 $p_i = -1$。\n- 否则，`stack.top()` 持有左侧最近的、大于或等于 $A[i]$ 的元素的索引，因此 $p_i = \\text{stack.top()}$。\n- 将 $i$ 推入 `stack`。这维持了单调性。\n\n**2. 计算后一个严格大于 (NSG) 的索引 ($q_i$)：**\n可以使用类似的单调栈方法。一种优雅的方法是认识到数组 $A$ 的 NSG 与反转数组 $A^R$ 的前一个严格大于 (PSG) 有关。\n设 $A^R$ 为反转数组，其中 $A^R[j] = A[n-1-j]$。我们计算 $A^R$ 中每个元素的 PSG。\nPSG 算法与 PGE 算法类似：\n- 设 `stack` 为一个双端队列。对于 $A^R$ 的每个索引 $j=0, \\dots, n-1$：\n- 当 `stack` 非空且 $A^R[\\text{stack.top()}] \\le A^R[j]$ 时，从栈中弹出元素。\n- $A^R[j]$ 的 PSG 索引是 `stack.top()`（如果栈不为空），否则为 $-1$。\n- 将 $j$ 推入 `stack`。\n\n设 `psg_R` 为 $A^R$ 的 PSG 索引数组。元素 $A[i]$ 的 NSG 索引 $q_i$ 可以通过索引映射找到。元素 $A[i]$ 对应于 $A^R[n-1-i]$。其 PSG 位于 $A^R$ 中的某个索引 $j' = \\text{psg\\_R}[n-1-i]$。在原始数组 $A$ 中对应的索引是 $n-1-j'$。如果不存在 PSG（即 $j' = -1$），则 $A[i]$ 不存在 NSG，所以 $q_i = n$。因此，如果 $\\text{psg\\_R}[n-1-i] \\ne -1$，则 $q_i = n-1-\\text{psg\\_R}[n-1-i]$，否则 $q_i = n$。\n\n两次遍历都花费 $\\mathcal{O}(n)$ 时间，因为每个索引最多被推入和弹出一次。最终的求和也是 $\\mathcal{O}(n)$。总时间复杂度为 $\\mathcal{O}(n)$，空间复杂度为 $\\mathcal{O}(n)$，用于辅助数组和栈。\n\n对于空数组 $A$，$n=0$，总和定义为 $0$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the sum of maximums over all contiguous subarrays for multiple test cases.\n    \"\"\"\n\n    def calculate_sum_of_subarray_maxes(A: list[int]) - int:\n        \"\"\"\n        Computes the sum of max(B) for all contiguous subarrays B of A in O(n) time.\n        \"\"\"\n        n = len(A)\n        if n == 0:\n            return 0\n\n        # 1. Compute `left`: Previous Greater or Equal (PGE)\n        # `left[i]` stores the index of the nearest element to the left of `i`\n        # which is greater than or equal to A[i].\n        left = np.full(n, -1, dtype=np.int64)\n        stack = []  # A list used as a stack, stores indices\n        for i in range(n):\n            while stack and A[stack[-1]]  A[i]:\n                stack.pop()\n            if stack:\n                left[i] = stack[-1]\n            stack.append(i)\n        \n        # 2. Compute `right`: Next Strictly Greater (NSG)\n        # This is equivalent to finding Previous Strictly Greater (PSG) on the reversed array.\n        # `right[i]` stores the index of the nearest element to the right of `i`\n        # which is strictly greater than A[i].\n        right = np.full(n, n, dtype=np.int64)\n        stack = []\n        for i in range(n - 1, -1, -1):\n            while stack and A[stack[-1]] = A[i]:\n                stack.pop()\n            if stack:\n                right[i] = stack[-1]\n            stack.append(i)\n            \n        # 3. Calculate the total sum based on contributions\n        # The contribution of A[i] is A[i] * (number of subarrays where A[i] is the first max).\n        # Number of such subarrays is (i - left[i]) * (right[i] - i).\n        total_sum = 0\n        for i in range(n):\n            count = (i - left[i]) * (right[i] - i)\n            total_sum += A[i] * count\n            \n        return total_sum\n\n    test_cases = [\n        [3, 1, 2, 4],      # Test 1\n        [2, 2, 2],         # Test 2\n        [5, 4, 3, 2, 1],   # Test 3\n        [-1, 0, -3, 2],    # Test 4\n        [],                # Test 5\n        [7]                # Test 6\n    ]\n\n    results = []\n    for A in test_cases:\n        result = calculate_sum_of_subarray_maxes(A)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "我们的最后一个练习将探讨滑动窗口问题，这是单调队列大放异彩的一个领域。想象一个游戏场景，玩家在世界中移动，需要在一个固定大小的窗口内找到最近的“能量道具”。这个问题是经典“滑动窗口最小值/最大值”查询的变体。它展示了维护一个有序候选队列的核心思想如何被灵活应用，不仅能找到最小值，还能找到到某个目标的最小*距离*，从而体现了单调队列的多功能性。",
            "id": "3253942",
            "problem": "给定一个一维离散世界，该世界被建模为一个二进制指示符数组。世界中的每个位置 $j$ 由一个条目 $B[j] \\in \\{0,1\\}$ 表示，其中 $B[j] = 1$ 表示在位置 $j$ 存在一个“能量提升”物品，$B[j] = 0$ 表示没有物品。一个玩家从位置 $i = 0$ 向前移动到位置 $i = n-1$，其中 $n$ 是数组的长度。在每个位置 $i$，玩家考虑一个固定长度为 $L$ 的前向滚动窗口，定义为索引区间 $[i, \\min(n-1, i + L - 1)]$。在此窗口内，定义到位置 $j$ 的最近“能量提升”物品的前向距离为 $d(i) = \\min\\{ j - i \\mid B[j] = 1, i \\le j \\le \\min(n-1, i + L - 1) \\}$，如果不存在这样的 $j$，则定义 $d(i) = -1$。\n\n从基本定义开始：\n- 数组上的滑动窗口选择固定长度的连续子数组，并在每一步将窗口向前移动一个位置。\n- 双端队列 (deque) 支持在均摊常数时间内从两端进行插入和删除操作。\n- 单调队列是双端队列的一种特殊用法，它根据比较键来维护元素的有序性（非递增或非递减），从而支持在滑动窗口上高效地检索最小值或最大值。\n\n任务：编写一个完整、可运行的程序，对于下面的每个测试用例，根据上述定义计算距离列表 $[d(0), d(1), \\dots, d(n-1)]$。该程序必须实现一个源于这些基本定义的算法，每个测试用例的最坏情况时间复杂度为 $\\mathcal{O}(n)$，适用于较大的 $n$。不涉及物理单位、角度单位或百分比格式；所有输出均为整数。最终输出必须将所有测试用例的结果汇总到一行中。\n\n测试套件：\n使用以下测试用例来验证您算法的不同方面，包括典型行为、边界条件和边缘情况。在每个用例中，$B$ 是二进制数组，$L$ 是窗口长度。\n- 用例 $1$：$B = [0, 1, 0, 0, 1, 0, 0, 1, 0, 0]$, $L = 3$。\n- 用例 $2$：$B = [0, 1, 1, 0, 1]$, $L = 1$。\n- 用例 $3$：$B = [0, 0, 0, 0, 0]$, $L = 4$。\n- 用例 $4$：$B = [1, 1, 1, 1, 1, 1]$, $L = 5$。\n- 用例 $5$：$B = [0, 1, 0, 0, 0, 1, 0]$, $L = 100$。\n\n要求的最终输出格式：\n您的程序应生成单行输出，其中包含所有测试用例的结果，格式为一个由方括号括起来的逗号分隔列表，每个测试用例的结果本身也是一个整数列表。例如，结构必须类似于 $[\\text{case\\_1\\_result},\\text{case\\_2\\_result},\\dots]$，内部列表中没有空格。具体来说，上述测试套件的输出必须采用确切的格式\n$[[d_0^{(1)},d_1^{(1)},\\dots],[d_0^{(2)},d_1^{(2)},\\dots],[d_0^{(3)},\\dots],[d_0^{(4)},\\dots],[d_0^{(5)},\\dots]]$，\n打印为单行，其中 $d_i^{(k)}$ 表示测试用例 $k$ 在索引 $i$ 处的距离。",
            "solution": "该问题要求计算一个距离向量 $\\mathbf{d}$，该向量适用于一个由长度为 $n$ 的二进制数组 $B$ 表示的一维离散世界。对于每个位置 $i \\in \\{0, 1, \\dots, n-1\\}$，我们必须在长度为 $L$ 的前向窗口内找到到最近的“能量提升”（即条目 $B[j]=1$）的距离 $d(i)$。\n\n形式上，对于每个 $i \\in \\{0, 1, \\dots, n-1\\}$，值 $d(i)$ 定义如下：\n$$\nd(i) = \\begin{cases}\n\\min\\{ j - i \\mid B[j] = 1 \\text{ and } i \\le j \\le \\min(n-1, i + L - 1) \\}  \\text{if such a } j \\text{ exists} \\\\\n-1  \\text{otherwise}\n\\end{cases}\n$$\n问题规定，算法必须源于包括单调队列在内的数据结构基本原理，并且必须达到 $\\mathcal{O}(n)$ 的最坏情况时间复杂度。\n\n一个朴素的方法是遍历从 $0$ 到 $n-1$ 的每个位置 $i$，并对每个 $i$ 在窗口 $[i, \\min(n-1, i + L - 1)]$ 内进行线性扫描，以查找第一次出现的 $1$。这会导致时间复杂度为 $\\mathcal{O}(n \\cdot L)$，该方法效率低下，无法满足问题对较大 $L$ 的性能要求。\n\n为达到 $\\mathcal{O}(n)$ 的复杂度，我们必须避免冗余计算。核心挑战是滑动窗口查询，这是单调队列的典型应用领域。然而，标准的单调队列算法是在窗口中查找最小或最大*值*。在这里，我们要寻找值为 $1$ 的最小*索引* $j$。这是滑动窗口问题的一个特化变体。\n\n我们的策略源于维护一个候选解队列的原理，该队列随着窗口的滑动而被修剪。由于我们只对 $B[j]=1$ 的位置 $j$ 感兴趣，我们可以预处理数组 $B$ 以识别所有这些“能量提升”索引。设这个有序索引集为 $P = \\{j_0, j_1, \\dots, j_m\\}$，其中对于所有的 $k$ 都有 $B[j_k]=1$ 且 $j_0  j_1  \\dots  j_m$。此步骤耗时 $\\mathcal{O}(n)$。\n\n对于任何给定的 $i$，这些索引是我们寻找最小 $j$ 的唯一候选。我们可以将这些候选索引存储在一个双端队列 (deque) 中，我们将其表示为 $q$。由于这些索引是按其在 $B$ 中出现的顺序添加的，因此 $q$ 中的索引天然是有序的（单调的）。\n\n主算法接着通过遍历 $i$ 从 $0$ 到 $n-1$ 来计算每个 $d(i)$。对于每个 $i$，我们寻找满足 $j \\ge i$ 的最小候选索引 $j \\in P$。随着 $i$ 的递增，我们队列 $q$ 中任何小于新 $i$ 的候选索引 $j_k$ 都不可能成为当前或未来任何位置的解，因为窗口总是从 $i$ 或之后的位置开始。因此，我们可以从队列的前端永久丢弃这些索引。\n\n这引出了以下 $\\mathcal{O}(n)$ 算法：\n1.  初始化一个双端队列 $q$，将所有满足 $B[j]=1$ 的索引 $j$ 存入其中。这可以通过对 $B$ 的单次遍历完成。在 `numpy` 环境中，这可以通过 `np.where(B == 1)` 高效实现。\n2.  初始化一个空列表 `results`，用于存储计算出的距离 $d(i)$。\n3.  使用索引 $i$ 从 $0$ 遍历到 $n-1$：\n    a.  当队列 $q$ 非空且其队首元素 $q[0]$ 小于 $i$ 时，从 $q$ 的前端移除索引。这维持了不变量，即 $q[0]$ 是大于或等于当前位置 $i$ 的最小可用候选索引。\n    b.  修剪步骤之后，检查队首。有两种可能性：\n        i.  队列 $q$ 非空，其队首元素（我们称之为 $j_{\\text{cand}} = q[0]$）是位置 $i$ 或之后出现的第一个能量提升。我们必须检查该候选索引是否落在长度为 $L$ 的窗口内。窗口延伸到索引 $i+L-1$，因此条件是 $j_{\\text{cand}}  i+L$。如果条件成立，我们就找到了窗口内最近的能量提升，距离为 $d(i) = j_{\\text{cand}} - i$。\n        ii. 如果队列为空，或者 $j_{\\text{cand}} \\ge i+L$，则在窗口 $[i, \\min(n-1, i+L-1)]$ 内没有能量提升。在这种情况下，$d(i)=-1$。\n    c.  将计算出的 $d(i)$ 追加到 `results` 列表中。\n4.  循环结束后，`results` 列表包含了所要求的序列 $[d(0), d(1), \\dots, d(n-1)]$。\n\n**复杂度分析**：\n-   **时间复杂度**：双端队列 $q$ 的初始填充耗时 $\\mathcal{O}(n)$。主循环运行 $n$ 次。来自原始 `powerup_indices` 列表的每个索引在主循环的整个执行过程中最多入队一次，最多出队一次。因此，用于修剪的 `while` 循环所做的总工作在所有迭代中均摊为 $\\mathcal{O}(n)$。循环内的所有其他操作都耗时常数时间。因此，总时间复杂度为 $\\mathcal{O}(n) + \\mathcal{O}(n) = \\mathcal{O}(n)$。\n-   **空间复杂度**：双端队列 $q$ 存储所有能量提升的索引。在最坏的情况下，即 $B$ 的每个元素都为 $1$ 时，双端队列所需的空间为 $\\mathcal{O}(n)$。因此，空间复杂度为 $\\mathcal{O}(n)$。\n\n此算法使用源自单调队列的原理正确解决了问题，并满足指定的复杂度约束。",
            "answer": "```python\nimport numpy as np\nimport collections\n\ndef solve():\n    \"\"\"\n    Solves the forward distance to closest power-up problem for a suite of test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case 1\n        (np.array([0, 1, 0, 0, 1, 0, 0, 1, 0, 0], dtype=np.int8), 3),\n        # Case 2\n        (np.array([0, 1, 1, 0, 1], dtype=np.int8), 1),\n        # Case 3\n        (np.array([0, 0, 0, 0, 0], dtype=np.int8), 4),\n        # Case 4\n        (np.array([1, 1, 1, 1, 1, 1], dtype=np.int8), 5),\n        # Case 5\n        (np.array([0, 1, 0, 0, 0, 1, 0], dtype=np.int8), 100),\n    ]\n\n    all_results = []\n\n    for B, L in test_cases:\n        n = len(B)\n        \n        # 1. Find all power-up indices and store them in a deque.\n        # This deque is monotonically increasing by construction.\n        powerup_indices = np.where(B == 1)[0]\n        q = collections.deque(powerup_indices)\n        \n        distances = []\n        \n        # 2. Iterate through each position i to calculate d(i).\n        for i in range(n):\n            # 3a. Prune indices from the front of the deque that are no longer\n            # reachable from position i (i.e., indices  i).\n            while q and q[0]  i:\n                q.popleft()\n            \n            # 3b. Check the next available power-up.\n            if q:\n                candidate_j = q[0]\n                # Check if the candidate is within the window [i, i + L - 1].\n                if candidate_j  i + L:\n                    # The distance is the difference in indices.\n                    distances.append(candidate_j - i)\n                else:\n                    # The closest power-up is outside the window.\n                    distances.append(-1)\n            else:\n                # No more power-ups to consider.\n                distances.append(-1)\n        \n        all_results.append(distances)\n\n    # Format the final output string according to the specification.\n    # Inner lists should have no spaces, e.g., [d0,d1,d2].\n    # Outer list combines these, e.g., [[...],[...]].\n    formatted_inner_results = [f\"[{','.join(map(str, res))}]\" for res in all_results]\n    final_output = f\"[{','.join(formatted_inner_results)}]\"\n    \n    print(final_output)\n\nsolve()\n```"
        }
    ]
}