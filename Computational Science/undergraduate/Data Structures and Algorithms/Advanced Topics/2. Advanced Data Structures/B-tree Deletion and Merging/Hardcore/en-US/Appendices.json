{
    "hands_on_practices": [
        {
            "introduction": "To truly grasp the importance of B-tree rebalancing algorithms, it is crucial to understand their performance boundaries. This first practice explores the worst-case scenario for deletions by asking you to determine the maximum number of merge operations that a single key deletion can trigger . By constructing a 'pessimally' structured tree, you will uncover how a single underflow can set off a chain reaction, providing deep insight into why tree height ($h$) is a critical factor in the cost of B-tree maintenance.",
            "id": "3211412",
            "problem": "A balanced multiway search tree known as a B-tree is parameterized by a minimum degree $t \\geq 2$. In a B-tree of minimum degree $t$, every internal node (except possibly the root) contains between $t-1$ and $2t-1$ keys, and hence has between $t$ and $2t$ children; the root contains between $1$ and $2t-1$ keys unless it is also a leaf, in which case it may contain $0$ keys. Define the height $h$ of the B-tree to be the number of edges on a longest simple path from the root to any leaf, so that a tree consisting of just the root has height $0$.\n\nConsider the standard deletion operation from B-trees based on the following well-tested facts and core definitions: nodes must not underflow (drop below $t-1$ keys) except possibly the root; if an underflow would occur in a child during deletion, the algorithm either redistributes a key from a sibling by rotating through the parent or combines (merges) the child with an adjacent sibling by moving exactly one separator key from the parent into the combined node. A single combine step merges exactly $2$ sibling nodes into $1$ node and reduces the parent’s key-count by $1$.\n\nSuppose you perform a single key deletion in a B-tree of minimum degree $t$ and height $h$, measured as above. You are to count only the number of node merge operations that combine two siblings into one node; do not count redistributions (rotations), and do not count the final act of replacing the root by its only child as a merge (if that occurs), though any merge that immediately precedes that replacement should be counted.\n\nUnder an adversarial but valid arrangement of keys consistent with the B-tree invariants prior to the deletion, what is the theoretical maximum number of node merges that a single key deletion can cause, expressed in terms of $t$ and $h$? Express your answer as a closed-form analytic expression in the variables $t$ and $h$. No rounding is required.",
            "solution": "The user wants me to determine the theoretical maximum number of node merge operations caused by a single key deletion in a B-tree of minimum degree $t$ and height $h$.\n\n### Problem Validation\nThe problem statement provides a correct and standard definition of a B-tree, including the minimum degree $t$, key counts for nodes, and the definition of height $h$. The description of the B-tree deletion algorithm, specifically the handling of node underflow via redistribution (rotation) or merging, is also standard. The problem asks for the maximum number of merges under an \"adversarial but valid arrangement,\" which is a standard way of phrasing a worst-case analysis problem in algorithmics. The problem is self-contained, scientifically grounded in the theory of data structures, and well-posed. Therefore, the problem is valid and a solution can be derived.\n\n### Solution Derivation\n\nTo determine the maximum number of merge operations, we must construct a worst-case scenario. A merge operation is triggered when a node's key count drops below the minimum of $t-1$, and a key cannot be redistributed from an adjacent sibling. This happens when the node underflows to $t-2$ keys and its neighbors are also at the minimum, i.e., they have exactly $t-1$ keys. A cascade of merges, which would yield the maximum number, occurs if a merge at one level induces an underflow in the parent node, which in turn needs to be resolved by a merge, and so on up the tree.\n\nLet us define the adversarial B-tree structure that facilitates this maximum-merge cascade.\nThe height $h$ is the number of edges from the root to a leaf. This implies there are $h+1$ levels of nodes, which we can index from level $0$ (the root) to level $h$ (the leaves).\nThe worst-case scenario is a \"skinny\" B-tree where all nodes along a specific path from the root to a leaf are minimally filled.\n1.  We select a path of nodes $N_0, N_1, \\dots, N_h$, where $N_0$ is the root, $N_1$ is a child of $N_0$, and so on, until the leaf $N_h$.\n2.  For the cascade to propagate fully, every node $N_i$ for $i \\in \\{0, 1, \\dots, h-1\\}$ on this path must have the minimum number of keys for its type. For an internal node other than the root, this is $t-1$ keys. For the root, the minimum is $1$ key. So we assume $N_i$ has $t-1$ keys for $i \\in \\{1, \\dots, h-1\\}$ and the root $N_0$ has $1$ key.\n3.  The leaf node $N_h$ where the deletion will occur must also be minimal, containing $t-1$ keys.\n4.  Crucially, to force a merge at each level instead of a rotation, the siblings of the nodes on our path must also be minimal. That is, for each node $N_i$ that will underflow, its adjacent sibling $S_i$ must have exactly $t-1$ keys.\n\nWith this B-tree configuration, let's trace the effects of deleting a single key from the leaf node $N_h$.\n\n**Deletion from Leaf and Initial Merge (Level $h$)**\nWe delete one key from the leaf node $N_h$.\n*   Initial state of $N_h$: $t-1$ keys.\n*   State after deletion: $t-2$ keys. Since $t \\geq 2$, $t-2 < t-1$, so the node $N_h$ underflows.\n*   To fix the underflow, we examine an adjacent sibling of $N_h$, let's call it $S_h$. By our adversarial design, $S_h$ is also minimal with $t-1$ keys. A rotation is not possible.\n*   A merge operation is performed. The node $N_h$, its sibling $S_h$, and the separator key from their parent $N_{h-1}$ are combined into a single new node. This constitutes the **first merge**. The new merged node contains $(t-2) + (t-1) + 1 = 2t-2$ keys, which is a valid number of keys (since $2t-2 \\leq 2t-1$).\n\n**Propagation of Underflow and Cascade of Merges**\nThe merge at level $h$ required pulling a separator key down from the parent node, $N_{h-1}$.\n*   Initial state of $N_{h-1}$: $t-1$ keys (by our adversarial design).\n*   State after its key is pulled down: $(t-1)-1 = t-2$ keys. The node $N_{h-1}$ at level $h-1$ now underflows.\n*   To fix this underflow, we examine a sibling of $N_{h-1}$, say $S_{h-1}$. This sibling is also minimal with $t-1$ keys. A rotation is impossible.\n*   A merge is performed between $N_{h-1}$ and $S_{h-1}$, pulling down a separator key from their parent, $N_{h-2}$. This is the **second merge**.\n\nThis process continues to propagate up the tree. A merge operation at level $i$ (where $1 < i \\leq h$) is caused by an underflow at that level. This merge consumes a key from the parent at level $i-1$, causing it to underflow in turn, because it was also minimal. This triggers a merge at level $i-1$.\n\n**Final Merge (Level 1)**\nThe cascade proceeds up the ancestor path of the original deletion.\n*   An underflow is triggered at level $1$ in node $N_1$.\n*   Node $N_1$ had $t-1$ keys, but the merge at level $2$ caused it to have $t-2$ keys.\n*   Its sibling, $S_1$, also has $t-1$ keys. They must merge.\n*   This merge operation pulls a key from their parent, the root node $N_0$. This is a merge between two children of the root.\n\n**Counting the Merges**\nA merge operation occurs at each level, starting from the leaf level ($h$) and cascading up to the level of the root's children (level $1$).\n*   Merge 1: Occurs at level $h$.\n*   Merge 2: Occurs at level $h-1$.\n*   ...\n*   Merge $i$: Occurs at level $h-i+1$.\n*   ...\n*   Final Merge: Occurs at level $1$.\n\nThe total number of merges is the number of levels from $1$ to $h$, inclusive. The count is $h - 1 + 1 = h$.\n\nAfter the final merge at level $1$, the root node $N_0$ loses a key. In our worst-case setup, the root had only $1$ key. This key is pulled down into the merged node. The root is now left with $0$ keys and a single child. The B-tree structure then requires the empty root to be removed, and its single child to become the new root. The problem statement explicitly says not to count this final tree-height reduction step as a merge. Thus, the chain of merge operations stops after the one at level $1$.\n\nThe maximum number of merges is therefore equal to the number of merges in this cascade. This number is exactly $h$. This holds for any $t \\geq 2$. For instance, if $h=1$, the deletion from a minimal leaf causes one merge with its sibling, and the root loses a key. The total is $1$ merge. If $h=0$, the tree is a single node, no merges are possible, so the count is $0$. The formula holds.\n\nThe maximum number of merges depends only on the height $h$ and not on the minimum degree $t$. The parameter $t$ defines the condition for being minimal, but the length of the potential cascade is determined by the height of the tree.\n\nTherefore, the theoretical maximum number of node merges is $h$.",
            "answer": "$$\n\\boxed{h}\n$$"
        },
        {
            "introduction": "Theoretical limits provide a vital perspective, but mastery comes from applying the rules to concrete examples. This exercise asks you to meticulously trace the deletion of a specific key from a given B-tree and compare the cost, in terms of key comparisons, to the same operation on a Red-Black Tree . This hands-on trace will solidify your understanding of the decision-making process at the heart of B-tree deletion, particularly when to borrow from a sibling versus when to merge nodes.",
            "id": "3211517",
            "problem": "Consider the following two search trees built over the same finite set of distinct integer keys. Let the data set be\n$$\nS=\\{2,5,10,12,15,20,22,25,30,32,35\\}.\n$$\nTree A is a B-tree of minimum degree $t=3$ (so each node stores between $t-1=2$ and $2t-1=5$ keys, except possibly the root). Tree A has height $2$ with the following exact structure:\n- The root stores the keys $[10,20,30]$.\n- It has $4$ leaf children, in order from left to right:\n  - Child $0$: $[2,5]$,\n  - Child $1$: $[12,15]$,\n  - Child $2$: $[22,25]$,\n  - Child $3$: $[32,35]$.\nTree B is a valid Red-Black Tree (RBT) storing the same key set $S$, and its binary search tree (BST) shape is explicitly given by:\n- Root key $20$.\n- Left subtree of $20$ has root $10$; the left child of $10$ is $5$ with left child $2$ and no right child; the right child of $10$ is $15$ with left child $12$ and no right child.\n- Right subtree of $20$ has root $30$; the left child of $30$ is $25$ with left child $22$ and no right child; the right child of $30$ is $32$ with right child $35$ and no left child.\nYou are to compare the number of key-to-key comparisons performed when deleting the single key $k=20$ from each tree, under the following precise counting model and algorithmic assumptions grounded in the standard definitions of B-tree and Red-Black Tree operations:\n- A “key comparison” is counted only when an algorithm compares a search key $x$ with a stored key $y$ to decide equality or traversal direction; comparisons against sentinel pointers or node degrees do not count.\n- In the B-tree (Tree A), within any node containing $m$ keys, the algorithm locates the position of $x$ by a linear scan from left to right, comparing $x$ to each node key in order until finding the first key $\\ge x$ or equality. Count each such comparison. The standard B-tree deletion procedure is used: if $x$ is in an internal node and neither adjacent child has at least $t$ keys, a merge with the separator key is performed, and the deletion recurses into the merged child. Concatenation/redistribution during merges uses the known sorted order and incurs zero key comparisons.\n- In the Red-Black Tree (Tree B), deletion proceeds as in a standard Red-Black Tree: first locate $x$ by ordinary binary search on keys; if the node has two children, replace it with its in-order successor found by descending to the leftmost node of its right subtree using pointer checks only (no key comparisons), and then remove that successor node. Rotations, recolorings, and any pointer or null-child checks incur zero key comparisons; only comparisons between $x$ and node keys along key searches are counted.\nLet $C_{B}$ denote the total number of key comparisons to delete $k=20$ from Tree A (the B-tree), and let $C_{R}$ denote the total number of key comparisons to delete $k=20$ from Tree B (the Red-Black Tree). Compute the single numeric difference\n$$\n\\Delta = C_{B}-C_{R}.\n$$\nProvide the value of $\\Delta$ as a single integer. No rounding is necessary.",
            "solution": "The objective is to compute the difference $\\Delta = C_{B} - C_{R}$, where $C_{B}$ is the number of key-to-key comparisons required to delete the key $k=20$ from a given B-tree (Tree A), and $C_{R}$ is the number of key-to-key comparisons for the same deletion from a given Red-Black Tree (Tree B). The problem provides a specific set of rules for counting these comparisons.\n\nFirst, we analyze the deletion from the B-tree (Tree A) to determine $C_{B}$.\n\nThe B-tree is of minimum degree $t=3$. The root node contains the keys $[10, 20, 30]$. The key to be deleted is $k=20$. The deletion process proceeds in two main stages according to the provided rules.\n\n**Stage 1: Search for the key in the B-tree.**\nThe search begins at the root node. The problem states that the search within a node is a linear scan from left to right.\n1.  We start at the root node with keys $[10, 20, 30]$.\n2.  The search key $k=20$ is compared with the first key of the node, which is $10$. Since $20 > 10$, the search continues. This is the first comparison.\n3.  The search key $k=20$ is compared with the second key of the node, which is $20$. Since $20 = 20$, the key is found. This is the second comparison.\nThe total number of comparisons to locate the key $k=20$ in the root node is $2$.\n\n**Stage 2: Perform the deletion operation.**\nThe key $k=20$ is located in an internal node (the root). The problem specifies a particular deletion procedure: \"if $x$ is in an internal node and neither adjacent child has at least $t$ keys, a merge with the separator key is performed, and the deletion recurses into the merged child.\"\n\n1.  The key $k=20$ acts as a separator between Child 1 and Child 2 of the root.\n2.  Child 1 contains the keys $[12, 15]$, so it has $2$ keys.\n3.  Child 2 contains the keys $[22, 25]$, so it has $2$ keys.\n4.  The minimum degree is $t=3$. The condition \"at least $t$ keys\" means having $3$ or more keys.\n5.  Child 1 has $2$ keys, which is not at least $3$. Child 2 also has $2$ keys, which is not at least $3$.\n6.  The condition \"neither adjacent child has at least $t$ keys\" is satisfied. Therefore, a merge operation is performed.\n7.  Child 1, the separator key $k=20$, and Child 2 are merged into a single new node. The contents of this new node are the keys from Child 1, the key $20$, and the keys from Child 2, resulting in the sorted list $[12, 15, 20, 22, 25]$.\n8.  The problem states that this merge operation incurs zero key comparisons.\n9.  After the merge, the deletion algorithm recurses to delete $k=20$ from this newly formed node.\n\n**Stage 3: Recursive deletion step.**\nThe task is now to delete the key $k=20$ from the node containing $[12, 15, 20, 22, 25]$. This node is a leaf node. Deletion from a leaf involves searching for the key and then removing it.\n\n1.  A linear scan is used to find $k=20$ in the node $[12, 15, 20, 22, 25]$.\n2.  Compare $k=20$ with $12$. $20 > 12$. This is one comparison.\n3.  Compare $k=20$ with $15$. $20 > 15$. This is a second comparison.\n4.  Compare $k=20$ with $20$. $20 = 20$. The key is found. This is a third comparison.\nThe total number of comparisons in this recursive step is $3$.\n\nThe total number of key comparisons for the B-tree deletion, $C_{B}$, is the sum of comparisons from the initial search and the recursive deletion step.\n$C_{B} = 2 + 3 = 5$.\n\nNext, we analyze the deletion from the Red-Black Tree (Tree B) to determine $C_{R}$.\n\nThe RBT deletion process is also governed by specific rules laid out in the problem.\n\n**Stage 1: Search for the key in the RBT.**\nThe search for $k=20$ uses an \"ordinary binary search on keys\".\n\n1.  The search starts at the root of Tree B, which contains the key $20$.\n2.  The search key $k=20$ is compared with the root key $20$. They are equal. The node is found on the first comparison.\nThe total number of comparisons to locate the key is $1$.\n\n**Stage 2: Perform the deletion operation.**\nThe node containing $k=20$ is the root and has two children (nodes with keys $10$ and $30$).\n\n1.  The rule is to replace the key in this node with the key of its in-order successor, and then remove the successor's original node.\n2.  The problem states that the in-order successor is found \"by descending to the leftmost node of its right subtree using pointer checks only (no key comparisons)\". Therefore, finding the successor (which is the node with key $22$) costs $0$ comparisons.\n3.  The key $20$ is replaced by $22$. The problem is now reduced to deleting the original node of the successor.\n4.  The original node for key $22$ is a leaf (it has no children). Deleting a node that is already located costs no further key-search comparisons.\n5.  Any subsequent RBT fixup operations (rotations and recolorings) are also specified to incur zero key comparisons.\n\nThe total number of key comparisons for the RBT deletion, $C_{R}$, is solely from the initial search for the key.\n$C_{R} = 1$.\n\nFinally, we compute the required difference $\\Delta$.\n$\\Delta = C_{B} - C_{R}$\n$\\Delta = 5 - 1 = 4$.\nThe difference in the number of key comparisons is $4$.",
            "answer": "$$\n\\boxed{4}\n$$"
        },
        {
            "introduction": "Moving from analysis to synthesis, our final practice challenges you to design and implement an optimized algorithm for a practical, non-standard scenario: batch deletion. Instead of deleting keys one by one, you will develop a strategy to handle the removal of multiple keys from the same leaf node at once . The goal is to create an intelligent rebalancing function that minimizes costly merge operations by first attempting to borrow multiple keys from well-filled siblings, a common optimization problem in high-performance database indexing.",
            "id": "3211492",
            "problem": "You must design and implement a complete program that models a $B$-tree supporting a \"batch deletion\" operation in which $k$ keys are deleted from the same leaf node in one step, and then optimizes the subsequent merging and rebalancing process. Use the following foundational base for $B$-trees, and derive your algorithm from these principles rather than shortcut formulas.\n\nFundamental base and invariants:\n- A $B$-tree of minimum degree $t$ stores sorted keys in nodes, with each non-root node containing between $t-1$ and $2t-1$ keys, and each internal node containing between $t$ and $2t$ children. The root node may contain between $1$ and $2t-1$ keys if it is internal, and may be a leaf containing between $1$ and $2t-1$ keys or be empty if the tree has no keys.\n- All leaves reside at the same depth. Keys in the subtree of a child between two adjacent parent keys must be strictly within the corresponding interval defined by those parent keys.\n- Insertion splits when a node would exceed $2t-1$ keys, moving the median key up. Deletion from a leaf may create an underflow when a node falls below $t-1$ keys, requiring rotations (borrows) from siblings via parent separators when possible, or merging with a sibling via a parent separator when borrowing cannot fix the deficiency. Merging can propagate a deficiency upward to the parent, repeating the process.\n\nTask:\n- Implement a $B$-tree with minimum degree $t$ that supports insertion of integer keys and a batch deletion operation restricted to deleting $k$ keys that are all in the same leaf node. You must implement an optimized batch rebalancing strategy that, after removing $k$ keys from the leaf, performs multi-rotation (borrowing) from siblings when possible before merging, selecting the number of rotations based on sibling surplus capacities so as to minimize the number of merges. If rotations cannot satisfy the deficiency, perform a single merge with an adjacent sibling and then recursively fix any deficiency that propagates upward. For rotations, apply the standard $B$-tree rotation semantics: borrowing from the left replaces the parent separator with the left sibling’s largest key and moves the parent separator down into the underflowing node; borrowing from the right replaces the parent separator with the right sibling’s smallest key and moves the parent separator down into the underflowing node. For merging, move the parent separator down between the two nodes being merged and concatenate keys (and children if internal).\n- Your program must also verify that, after batch deletion and rebalancing, the $B$-tree invariants hold: key counts per node are within bounds, keys are sorted, internal nodes have one more child than keys, all leaves have the same depth, and the key ranges are respected.\n\nInterface design for test suite:\n- The program must construct initial $B$-trees by inserting given integer sequences, then perform the batch deletion on the leaf containing a specified pivot key. For the batch deletion, delete the $k$ smallest keys currently in that leaf. A boolean flag may request pre-reduction of both immediate siblings of the target leaf to the minimum key count $t-1$ before the batch deletion, to exercise merge-heavy behavior.\n- For each test case, your program must report the following as a list: the total number of merges performed (an integer), the total number of rotations performed (an integer), the final height of the $B$-tree (an integer, where a tree with a single leaf has height $1$), and a boolean indicating whether the $B$-tree invariants hold after all operations.\n\nTest suite:\n- Case $1$: $t=3$, insert the integers from $1$ to $30$, pivot key $11$, delete $k=3$ keys from that leaf, with pre-reduction disabled.\n- Case $2$: $t=3$, insert the integers from $1$ to $30$, pivot key $11$, delete $k=4$ keys from that leaf, with pre-reduction disabled.\n- Case $3$: $t=3$, insert the integers from $1$ to $30$, pivot key $11$, delete $k=4$ keys from that leaf, with pre-reduction enabled (reduce both siblings of the target leaf to $t-1$ keys before the batch deletion).\n- Case $4$: $t=2$, insert the integers from $1$ to $10$, pivot key $6$, delete $k=3$ keys from that leaf, with pre-reduction enabled.\n\nRequired output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each element corresponds to one test case and must itself be a list in the order $[$merges, rotations, height, valid$]$. For example: $[[m_1,r_1,h_1,v_1],[m_2,r_2,h_2,v_2],\\dots]$.",
            "solution": "The design must begin from the core invariants of a $B$-tree of minimum degree $t$. Each non-root node must contain at least $t-1$ keys and at most $2t-1$ keys, and internal nodes must have one more child than keys. The root must have at least $1$ key unless the tree is empty. All leaves are at the same depth, and key intervals per child are dictated by the parent separators. Any algorithm for deletion must restore these bounds whenever a node underflows.\n\nWhen deleting $k$ keys from a single leaf at once, the first step is to remove those $k$ keys from the leaf. Let the leaf initially have $m$ keys. After deletion, it has $m-k$ keys. If $m-k \\ge t-1$ (and the leaf is not the root), there is no underflow and we are done. Otherwise, there is a deficiency $d = (t-1) - (m-k) > 0$ that must be corrected by either borrowing from siblings via parent rotations or merging with a sibling and applying recursive fixes upward.\n\nOptimizing rebalancing after a batch deletion relies on analyzing sibling surplus capacities in one local computation rather than performing $k$ separate deletions. If the parent index of the leaf is $i$, define the left sibling $L$ (if $i>0$) and right sibling $R$ (if $i<\\text{degree}-1$). For a sibling $S$ with $\\ell_S$ keys, its surplus over the minimum is $\\max(0, \\ell_S-(t-1))$. The total available surplus for borrowing is the sum of the left and right surpluses. Each borrow operation corresponds to a standard $B$-tree rotation:\n\n- Borrowing from the left sibling uses the parent key $K_p = \\text{parent.keys}[i-1]$: move $K_p$ down into the underflowing node, and replace $K_p$ in the parent with the left sibling’s largest key; in an internal node case, also transfer the left sibling’s rightmost child pointer to become the new leftmost child of the underflowing node.\n- Borrowing from the right sibling uses the parent key $K_p = \\text{parent.keys}[i]$: move $K_p$ down into the underflowing node, and replace $K_p$ in the parent with the right sibling’s smallest key; in an internal node case, also transfer the right sibling’s leftmost child pointer to become the new rightmost child of the underflowing node.\n\nIf the sum of available surplus exceeds or equals the deficiency $d$, then a multi-rotation sequence that consumes the needed number of keys can restore the leaf to the minimum without any merge. Borrow greedily first from the left sibling (up to its surplus) and then from the right sibling to satisfy $d$, because rotations are strictly cheaper than merges: a rotation is a local constant-time operation $O(1)$, whereas a merge reduces the number of children of the parent and may cause parent underflow that must be repaired recursively up the tree.\n\nIf the total surplus is insufficient to satisfy $d$, perform a single merge with an adjacent sibling. Choose the side that exists; a single merge maximizes the number of keys added to the underflowing node with minimal structural changes. A merge involves moving the appropriate parent separator key down between the two nodes and concatenating the keys (and children if internal), then removing the separator and the redundant child from the parent. After a merge, the parent loses one key and one child; if the parent now underflows (has fewer than $t-1$ keys, or fewer than $1$ key if it is the root and internal), we must recursively apply the same borrow-or-merge logic at the parent level. This can cascade up to the root. If the root becomes empty and has a single child, collapse the root into its child, reducing the height by $1$.\n\nCorrectness follows from maintaining the $B$-tree invariants at each step. Rotations preserve sortedness within nodes and the global key interval property because the parent separators maintain their role and the borrowed keys move through the parent exactly as in standard $B$-tree deletion. Merging preserves the interval property because the parent separator moved down sequences keys between two adjacent children. Recursion upward ensures that any parent underflow is repaired in a manner consistent with $B$-tree rules. Because all operations occur along a single root-to-leaf path and potentially cascade upward, the time complexity of one batch deletion is $O(h + r + m)$ where $h$ is the tree height, $r$ is the number of rotations, and $m$ is the number of merges; with the optimization, the number of merges is minimized subject to the sibling surplus constraints, and rotations are bounded by the surplus available. Structurally, each rotation is $O(1)$ and each merge is $O(1)$ at a node, making the total work $O(h)$ in typical balanced scenarios.\n\nFor the test suite, the program constructs the $B$-tree via insertion of integers, locates the leaf containing the specified pivot key, and deletes the $k$ smallest keys inside that leaf. A flag optionally reduces both immediate siblings of the target leaf to exactly $t-1$ keys before the batch deletion to ensure borrowing is impossible and a merge is required, stressing the upward propagation logic. After each case, the program outputs the number of merges, the number of rotations, the final height (counting the root level as height $1$), and a boolean for validity. The final output aggregates the four cases into a single line list as required.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass BTreeNode:\n    def __init__(self, t, leaf=False):\n        self.t = t\n        self.keys = []\n        self.children = []\n        self.leaf = leaf\n\n    def __repr__(self):\n        return f\"Node(keys={self.keys}, leaf={self.leaf})\"\n\n\nclass BTree:\n    def __init__(self, t):\n        self.t = t\n        self.root = BTreeNode(t, leaf=True)\n        self.rotations = 0\n        self.merges = 0\n\n    # Standard B-tree insertion (CLRS style)\n    def insert(self, k):\n        root = self.root\n        if len(root.keys) == 2*self.t - 1:\n            s = BTreeNode(self.t, leaf=False)\n            s.children.append(root)\n            self._split_child(s, 0)\n            self.root = s\n            self._insert_nonfull(s, k)\n        else:\n            self._insert_nonfull(root, k)\n\n    def _insert_nonfull(self, x, k):\n        i = len(x.keys) - 1\n        if x.leaf:\n            # insert in sorted order\n            x.keys.append(k)\n            i = len(x.keys) - 2\n            while i >= 0 and x.keys[i] > k:\n                x.keys[i+1] = x.keys[i]\n                i -= 1\n            x.keys[i+1] = k\n        else:\n            while i >= 0 and k < x.keys[i]:\n                i -= 1\n            i += 1\n            if len(x.children[i].keys) == 2*self.t - 1:\n                self._split_child(x, i)\n                if k > x.keys[i]:\n                    i += 1\n            self._insert_nonfull(x.children[i], k)\n\n    def _split_child(self, x, i):\n        t = self.t\n        y = x.children[i]\n        z = BTreeNode(t, leaf=y.leaf)\n        # median key at index t-1\n        median = y.keys[t-1]\n        # distribute keys\n        z.keys = y.keys[t:]\n        y.keys = y.keys[:t-1]\n        if not y.leaf:\n            z.children = y.children[t:]\n            y.children = y.children[:t]\n        x.children.insert(i+1, z)\n        x.keys.insert(i, median)\n\n    # Search returns node containing key or leaf where it would be inserted\n    def search(self, k):\n        return self._search_node(self.root, k)\n\n    def _search_node(self, x, k):\n        i = 0\n        while i < len(x.keys) and k > x.keys[i]:\n            i += 1\n        if i < len(x.keys) and k == x.keys[i]:\n            return x, i\n        if x.leaf:\n            return x, None\n        else:\n            return self._search_node(x.children[i], k)\n\n    # Find parent of a given node and child's index\n    def find_parent(self, current, target):\n        if current.leaf:\n            return None, None\n        for i, child in enumerate(current.children):\n            if child is target:\n                return current, i\n            if not child.leaf:\n                p, idx = self.find_parent(child, target)\n                if p is not None:\n                    return p, idx\n            else:\n                # continue\n                pass\n        # Try descending anyway based on key ranges to find parent in deeper subtrees\n        for i, child in enumerate(current.children):\n            if child is target:\n                return current, i\n            p, idx = self.find_parent(child, target)\n            if p is not None:\n                return p, idx\n        return None, None\n\n    # Helpers for rotations\n    def rotate_from_left(self, parent, idx):\n        # Borrow from left sibling into child at idx\n        left = parent.children[idx-1]\n        node = parent.children[idx]\n        # Move parent separator down into node, replace parent separator with left's max key\n        # Also move child pointer for internal nodes\n        if node.leaf:\n            # insert parent key at beginning\n            node.keys.insert(0, parent.keys[idx-1])\n            # replace parent key with left's last key\n            parent.keys[idx-1] = left.keys.pop()\n        else:\n            # node gains parent.sep at beginning\n            node.keys.insert(0, parent.keys[idx-1])\n            # node must take left's last child to the front\n            child_to_move = left.children.pop()\n            node.children.insert(0, child_to_move)\n            # parent sep replaced with left's last key\n            parent.keys[idx-1] = left.keys.pop()\n        self.rotations += 1\n\n    def rotate_from_right(self, parent, idx):\n        right = parent.children[idx+1]\n        node = parent.children[idx]\n        if node.leaf:\n            # append parent key\n            node.keys.append(parent.keys[idx])\n            # replace parent key with right's first key\n            parent.keys[idx] = right.keys.pop(0)\n        else:\n            node.keys.append(parent.keys[idx])\n            child_to_move = right.children.pop(0)\n            node.children.append(child_to_move)\n            parent.keys[idx] = right.keys.pop(0)\n        self.rotations += 1\n\n    # Merge helpers\n    def merge_with_left(self, parent, idx):\n        # Merge child at idx with left sibling at idx-1\n        left = parent.children[idx-1]\n        node = parent.children[idx]\n        # move parent separator down\n        left.keys.append(parent.keys[idx-1])\n        # concatenate node\n        left.keys.extend(node.keys)\n        if not left.leaf:\n            left.children.extend(node.children)\n        # remove from parent\n        parent.keys.pop(idx-1)\n        parent.children.pop(idx)\n        self.merges += 1\n        return left  # merged node reference\n\n    def merge_with_right(self, parent, idx):\n        node = parent.children[idx]\n        right = parent.children[idx+1]\n        # move parent separator down\n        node.keys.append(parent.keys[idx])\n        node.keys.extend(right.keys)\n        if not node.leaf:\n            node.children.extend(right.children)\n        parent.keys.pop(idx)\n        parent.children.pop(idx+1)\n        self.merges += 1\n        return node\n\n    # Fix underflow after deletions\n    def fix_underflow(self, node):\n        # If node is root, handle special cases\n        while True:\n            if node is self.root:\n                # If root is internal and empty with one child, collapse\n                if not node.leaf and len(node.keys) == 0 and len(node.children) == 1:\n                    self.root = node.children[0]\n                # Leaf root may be empty if tree emptied; nothing else to do\n                return\n            parent, idx = self.find_parent(self.root, node)\n            if parent is None:\n                # Should not happen\n                return\n            min_keys = (self.t - 1)\n            if len(node.keys) >= min_keys:\n                return\n            deficiency = min_keys - len(node.keys)\n            # calculate available surplus from siblings\n            # Try left\n            if idx - 1 >= 0:\n                left = parent.children[idx-1]\n                avail_left = len(left.keys) - (self.t - 1)\n            else:\n                left = None\n                avail_left = 0\n            # Try right\n            if idx + 1 < len(parent.children):\n                right = parent.children[idx+1]\n                avail_right = len(right.keys) - (self.t - 1)\n            else:\n                right = None\n                avail_right = 0\n            # Borrow as much as possible\n            borrow_left = min(deficiency, max(0, avail_left))\n            for _ in range(borrow_left):\n                self.rotate_from_left(parent, idx)\n                deficiency -= 1\n                if deficiency == 0:\n                    break\n            if deficiency > 0:\n                borrow_right = min(deficiency, max(0, avail_right))\n                for _ in range(borrow_right):\n                    self.rotate_from_right(parent, idx)\n                    deficiency -= 1\n                    if deficiency == 0:\n                        break\n            # If still deficient, merge\n            if len(node.keys) < min_keys:\n                if left is not None:\n                    merged = self.merge_with_left(parent, idx)\n                    # After merge, set node to parent to check if parent underflows\n                    node = parent\n                    continue\n                elif right is not None:\n                    merged = self.merge_with_right(parent, idx)\n                    node = parent\n                    continue\n                else:\n                    # No siblings? Should not happen in B-tree except at root\n                    node = parent\n                    continue\n            else:\n                return\n\n    # Batch delete k smallest keys from leaf containing pivot key\n    def batch_delete_from_leaf_by_pivot(self, pivot_key, k, pre_reduce_siblings_to_min=False):\n        # Find leaf containing pivot key\n        node, idx = self.search(pivot_key)\n        # Ensure node is the leaf containing the key\n        # If the found node is internal (unlikely since search returns leaf when not found),\n        # traverse to leaf containing pivot_key\n        if not node.leaf:\n            # descend to the child where pivot would be\n            x = node\n            i = 0\n            while i < len(x.keys) and pivot_key > x.keys[i]:\n                i += 1\n            node = x.children[i]\n            while not node.leaf:\n                i = 0\n                while i < len(node.keys) and pivot_key > node.keys[i]:\n                    i += 1\n                node = node.children[i]\n        # Optionally pre-reduce siblings to minimum keys\n        if pre_reduce_siblings_to_min:\n            parent, child_idx = self.find_parent(self.root, node)\n            if parent is not None:\n                # Reduce left sibling\n                if child_idx - 1 >= 0:\n                    left = parent.children[child_idx-1]\n                    # delete from left to reach t-1 keys\n                    excess = len(left.keys) - (self.t - 1)\n                    if excess > 0:\n                        # delete excess smallest keys in left\n                        to_delete = left.keys[:excess]\n                        for key in to_delete:\n                            # Remove key from left\n                            left.keys.remove(key)\n                        # Fix underflow if created (shouldn't create underflow by removing surplus)\n                        # But if we removed too many due to earlier structure, still fix\n                        self.fix_underflow(left)\n                # Reduce right sibling\n                if child_idx + 1 < len(parent.children):\n                    right = parent.children[child_idx+1]\n                    excess = len(right.keys) - (self.t - 1)\n                    if excess > 0:\n                        to_delete = right.keys[:excess]\n                        for key in to_delete:\n                            right.keys.remove(key)\n                        self.fix_underflow(right)\n        # Now delete k smallest keys in the target leaf\n        to_remove = node.keys[:min(k, len(node.keys))]\n        for key in to_remove:\n            # Remove key\n            node.keys.remove(key)\n        # Fix potential underflow\n        self.fix_underflow(node)\n\n    # Validation of B-tree invariants\n    def validate(self):\n        if self.root is None:\n            return True\n        # Check leaf depths\n        leaf_depths = []\n\n        def dfs(node, depth):\n            # keys sorted\n            if any(node.keys[i] >= node.keys[i+1] for i in range(len(node.keys)-1)):\n                return False\n            # bounds\n            if node is self.root:\n                # root can be leaf or internal\n                if node.leaf:\n                    # allow empty root leaf or between 1 and 2t-1 keys\n                    if len(node.keys) < 0 or len(node.keys) > 2*self.t - 1:\n                        return False\n                else:\n                    if len(node.keys) < 1 or len(node.keys) > 2*self.t - 1:\n                        return False\n            else:\n                if len(node.keys) < self.t - 1 or len(node.keys) > 2*self.t - 1:\n                    return False\n            if not node.leaf:\n                if len(node.children) != len(node.keys) + 1:\n                    return False\n                for child in node.children:\n                    if child is None:\n                        return False\n            else:\n                leaf_depths.append(depth)\n            # recurse\n            if not node.leaf:\n                for child in node.children:\n                    if not dfs(child, depth+1):\n                        return False\n            return True\n\n        ok = dfs(self.root, 1)\n        if not ok:\n            return False\n        # All leaves same depth\n        if len(leaf_depths) == 0:\n            return True\n        return all(d == leaf_depths[0] for d in leaf_depths)\n\n    def height(self):\n        h = 0\n        node = self.root\n        while node is not None:\n            h += 1\n            if node.leaf:\n                break\n            node = node.children[0]\n        return h\n\n\ndef build_btree_with_range(t, start, end):\n    bt = BTree(t)\n    for k in range(start, end+1):\n        bt.insert(k)\n    return bt\n\n\ndef run_test_case(t, insert_range, pivot, k, pre_reduce=False):\n    bt = build_btree_with_range(t, insert_range[0], insert_range[1])\n    # perform batch deletion\n    bt.batch_delete_from_leaf_by_pivot(pivot, k, pre_reduce_siblings_to_min=pre_reduce)\n    # collect results\n    merges = bt.merges\n    rotations = bt.rotations\n    height = bt.height()\n    valid = bt.validate()\n    return [merges, rotations, height, valid]\n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: t=3, insert 1..30, pivot 11, k=3, no pre-reduction\n        (3, (1, 30), 11, 3, False),\n        # Case 2: t=3, insert 1..30, pivot 11, k=4, no pre-reduction\n        (3, (1, 30), 11, 4, False),\n        # Case 3: t=3, insert 1..30, pivot 11, k=4, pre-reduction enabled\n        (3, (1, 30), 11, 4, True),\n        # Case 4: t=2, insert 1..10, pivot 6, k=3, pre-reduction enabled\n        (2, (1, 10), 6, 3, True),\n    ]\n\n    results = []\n    for case in test_cases:\n        t, insert_range, pivot, k, pre_reduce = case\n        result = run_test_case(t, insert_range, pivot, k, pre_reduce)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}