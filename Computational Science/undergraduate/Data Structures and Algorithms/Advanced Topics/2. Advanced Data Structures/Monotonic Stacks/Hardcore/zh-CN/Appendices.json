{
    "hands_on_practices": [
        {
            "introduction": "第一个练习将帮助你掌握单调栈的基本模式：高效地找到“下一个更大元素”（Next Greater Element, NGE）和“上一个更大元素”（Previous Greater Element, PGE）。通过实现这个问题，你将学会如何单次遍历数组来回答元素间的关系查询，这是许多高级算法的基石。这个练习将巩固你为正向和反向搜索维护单调栈的核心机制。",
            "id": "3254179",
            "problem": "您必须编写一个完整的程序，对一个整数数组中的每个元素，计算其“下一个更大元素”与“前一个更大元素”的乘积，且只能使用下面给出的定义以及数组、整数顺序和栈的基本性质。程序不读取任何输入；相反，程序必须在内部评估本说明中指定的一个固定的数组测试套件，并按要求产生一个聚合后的输出。\n\n用作基本依据的定义：\n- 设 $A$ 是一个长度为 $n$ 的整数数组。索引从 $0$ 开始，即有效索引为 $0, 1, \\dots, n-1$。\n- 对于每个索引 $i$（$0 \\le i \\le n-1$），定义“下一个更大元素”$\\mathrm{NGE}(i)$ 如下：如果存在索引 $j$ 满足 $j  i$ 且 $A[j]  A[i]$，则令 $\\mathrm{NGE}(i) = A[j^{\\ast}]$，其中 $j^{\\ast}$ 是大于 $i$ 且满足 $A[j^{\\ast}]  A[i]$ 的最小索引。如果不存在这样的 $j$，则定义 $\\mathrm{NGE}(i) = -1$。\n- 对于每个索引 $i$（$0 \\le i \\le n-1$），定义“前一个更大元素”$\\mathrm{PGE}(i)$ 如下：如果存在索引 $k$ 满足 $k  i$ 且 $A[k]  A[i]$，则令 $\\mathrm{PGE}(i) = A[k^{\\ast}]$，其中 $k^{\\ast}$ 是小于 $i$ 且满足 $A[k^{\\ast}]  A[i]$ 的最大索引。如果不存在这样的 $k$，则定义 $\\mathrm{PGE}(i) = -1$。\n- 对于每个索引 $i$（$0 \\le i \\le n-1$），定义乘积 $P[i] = \\mathrm{NGE}(i) \\times \\mathrm{PGE}(i)$。\n\n您的任务是，对于每个给定的测试数组 $A$，计算出包含这些乘积的、长度为 $n$ 的列表 $P$，并按索引从 $0$ 到 $n-1$ 的顺序排列。\n\n科学真实性与约束条件：\n- 数组可以包含任意整数（包括负值）、重复值，且长度可以为 $0$ 或更大。\n- 严格不等式 $$ 用于定义“更大”，因此相等的值不被视为更大。\n- 如果数组长度为 $0$，则该情况的输出为一个空列表。\n\n程序需要评估的测试套件：\n- 情况 1：$A = [\\,5, 1, 3, 2, 4\\,]$。\n- 情况 2：$A = [\\,1, 2, 3, 4\\,]$。\n- 情况 3：$A = [\\,4, 3, 2, 1\\,]$。\n- 情况 4：$A = [\\,2, 2, 2\\,]$。\n- 情况 5：$A = [\\,7\\,]$。\n- 情况 6：$A = [\\,\\,]$ (空数组)。\n\n最终输出格式要求：\n- 您的程序应产生单行输出，其中包含所有测试用例的结果，这些结果组成一个单一的列表，该列表中的每个元素本身就是对应测试用例的列表 $P$，顺序与上述用例顺序相同。\n- 该行必须是一个用方括号括起来的、逗号分隔的列表，任何地方都不能有空格，包括内部列表中。例如，如果有两个测试用例的结果分别为 $[\\,x_1, x_2\\,]$ 和 $[\\,y_1\\,]$，则输出格式应精确为 \"[[x_1,x_2],[y_1]]\"，其中每个 $x_1, x_2, y_1$ 被替换为其整数值，并且完全没有空格。\n\n每个测试用例的答案是一个整数列表。程序必须对所提供的测试套件给出正确的结果，并且应使用适合数据结构与算法高级本科学习的原则进行设计，例如利用顺序属性和栈的行为，而不是通过临时枚举的方式。",
            "solution": "该问题陈述已经过验证并被认为是有效的。它是自洽的、数学上良定的，并且没有矛盾或歧义。对于“下一个更大元素”（$\\mathrm{NGE}$）和“前一个更大元素”（$\\mathrm{PGE}$）的定义是精确的，这确保了对于任何给定的整数数组都存在唯一的解。该问题是算法设计中的一个标准练习，适合用数据结构进行分析。\n\n下面提供一个完整的、带推理过程的解法。\n\n问题要求我们为给定长度为 $n$ 的数组 $A$ 中的每个元素 $A[i]$ 计算乘积 $P[i] = \\mathrm{NGE}(i) \\times \\mathrm{PGE}(i)$。“下一个更大元素” $\\mathrm{NGE}(i)$ 是 $A[i]$ 右侧第一个严格大于 $A[i]$ 的元素。“前一个更大元素” $\\mathrm{PGE}(i)$ 是 $A[i]$ 左侧第一个严格大于 $A[i]$ 的元素。如果不存在这样的元素，则相应的值定义为 $-1$。\n\n一个直接但效率低下的方法是为每个元素遍历数组。为了找到 $\\mathrm{NGE}(i)$，需要扫描所有 $j > i$ 的元素 $A[j]$。为了找到 $\\mathrm{PGE}(i)$，需要扫描所有 $k  i$ 的元素 $A[k]$。此方法涉及嵌套循环，对于长度为 $n$ 的数组，其时间复杂度为 $O(n^2)$。对于大数组，这种方法的计算成本高昂。问题暗示了一种更精巧的方法，可以使用单调栈实现一个线性时间 $O(n)$ 的解法。\n\n单调栈的原理是维护一个数据结构（一个栈），其中的元素始终保持特定的排序顺序（递增或递减）。这种结构允许在单次遍历中高效地确定所有元素的下一个或前一个更大/更小元素。\n\n整体算法包括三个主要步骤：\n1. 计算数组 $A$ 中每个元素的 $\\mathrm{NGE}$。\n2. 计算数组 $A$ 中每个元素的 $\\mathrm{PGE}$。\n3. 根据前两个步骤的结果计算最终的乘积数组 $P$。\n\n**1. 计算下一个更大元素 ($\\mathrm{NGE}$)**\n\n为了计算所有元素的 $\\mathrm{NGE}$，我们可以从右到左（从索引 $i = n-1$ 到 $0$）遍历数组 $A$，并使用一个栈来存储目前遇到的元素值。该栈将维持从栈底到栈顶的严格递减顺序。\n\n算法如下：\n- 初始化一个空栈 $s$ 和一个大小为 $n$ 的结果数组 $nge\\_arr$，所有值初始化为 $-1$。\n- 对于每个索引 $i$ 从 $n-1$ 到 $0$：\n    a. 当栈 $s$ 不为空且栈顶元素小于或等于 $A[i]$ 时（即 $s.\\mathrm{top}() \\le A[i]$），从栈中弹出元素。任何被弹出的元素，比如 $A[k]$（其中 $k>i$），都不能是 $A[i]$ 或 $A[i]$ 左侧任何元素的 $\\mathrm{NGE}$，因为 $A[i]$ 本身更近且更大。\n    b. while 循环结束后，如果栈不为空，其栈顶元素就是 $A[i]$ 右侧第一个大于 $A[i]$ 的元素。我们设置 $nge\\_arr[i] = s.\\mathrm{top}()$。\n    c. 如果栈为空，则右侧没有找到更大的元素，所以 $nge\\_arr[i]$ 保持为 $-1$。\n    d. 将当前元素 $A[i]$ 推入栈中。此操作保持了栈的单调（严格递减）性。\n\n$A$ 的每个元素最多被推入和弹出栈一次。因此，这次遍历的时间复杂度为 $O(n)$。\n\n**2. 计算前一个更大元素 ($\\mathrm{PGE}$)**\n\n计算 $\\mathrm{PGE}$ 的逻辑与计算 $\\mathrm{NGE}$ 的逻辑是对称的。我们从左到右（从索引 $i = 0$ 到 $n-1$）遍历数组 $A$，并使用类似的单调栈。\n\n算法如下：\n- 初始化一个空栈 $s$ 和一个大小为 $n$ 的结果数组 $pge\\_arr$，所有值初始化为 $-1$。\n- 对于每个索引 $i$ 从 $0$到 $n-1$：\n    a. 当栈 $s$ 不为空且栈顶元素小于或等于 $A[i]$ 时（即 $s.\\mathrm{top}() \\le A[i]$），从栈中弹出元素。其推理类似于 $\\mathrm{NGE}$ 的情况：这些被弹出的元素不能是当前元素或任何后续元素的 $\\mathrm{PGE}$。\n    b. 如果循环后栈不为空，其栈顶元素就是 $A[i]$ 左侧最近的更大元素。我们设置 $pge\\_arr[i] = s.\\mathrm{top}()$。\n    c. 如果栈为空，则左侧不存在更大的元素，所以 $pge\\_arr[i]$ 保持为 $-1$。\n    d. 将当前元素 $A[i]$ 推入栈中。\n\n这次遍历的时间复杂度也为 $O(n)$。\n\n**3. 最终乘积计算**\n\n在计算出 $nge\\_arr$ 和 $pge\\_arr$ 数组后，通过逐元素相乘得到最终的乘积数组 $P$：对于每个索引 $i$ 从 $0$ 到 $n-1$，计算 $P[i] = nge\\_arr[i] \\times pge\\_arr[i]$。这最后一步也需要 $O(n)$ 时间。\n\n该方法的总时间复杂度为 $O(n) + O(n) + O(n) = O(n)$，空间复杂度为 $O(n)$，用于存储栈和结果数组。这个设计是高效的，并按预期直接利用了问题的结构特性。对于空输入数组，结果如规定一样是一个空列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_products(A: list[int]) - list[int]:\n    \"\"\"\n    Computes the product of the Next Greater Element and Previous Greater Element\n    for each element in an array using a monotonic stack approach.\n    \"\"\"\n    n = len(A)\n    if n == 0:\n        return []\n\n    # Initialize result arrays for NGE and PGE with -1.\n    # We use numpy for efficient array operations as permitted.\n    nge_arr = np.full(n, -1, dtype=np.int64)\n    pge_arr = np.full(n, -1, dtype=np.int64)\n\n    # 1. Compute Next Greater Element (NGE) for each element.\n    # We iterate from right-to-left. The stack stores elements from the right\n    # that are candidates for being an NGE.\n    stack = []\n    for i in range(n - 1, -1, -1):\n        # Pop elements from the stack that are less than or equal to the current element.\n        # They cannot be the NGE for A[i] or any elements to the left of A[i].\n        while stack and stack[-1] = A[i]:\n            stack.pop()\n        \n        # If the stack is not empty, the top element is the NGE.\n        if stack:\n            nge_arr[i] = stack[-1]\n        \n        # Push the current element onto the stack for subsequent elements to the left.\n        stack.append(A[i])\n\n    # 2. Compute Previous Greater Element (PGE) for each element.\n    # We iterate from left-to-right. The logic is symmetric to the NGE computation.\n    stack = []\n    for i in range(n):\n        # Pop elements from the stack that are less than or equal to the current element.\n        while stack and stack[-1] = A[i]:\n            stack.pop()\n        \n        # If the stack is not empty, the top element is the PGE.\n        if stack:\n            pge_arr[i] = stack[-1]\n            \n        # Push the current element onto the stack for subsequent elements to the right.\n        stack.append(A[i])\n\n    # 3. Compute the element-wise product of NGE and PGE arrays.\n    products = np.multiply(nge_arr, pge_arr)\n    \n    # Return the result as a standard Python list of integers.\n    return products.tolist()\n\ndef solve():\n    \"\"\"\n    Defines the test suite, runs the computation for each case,\n    and prints the aggregated results in the specified format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [5, 1, 3, 2, 4],  # Case 1\n        [1, 2, 3, 4],      # Case 2\n        [4, 3, 2, 1],      # Case 3\n        [2, 2, 2],         # Case 4\n        [7],               # Case 5\n        [],                # Case 6\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_products(case)\n        results.append(result)\n\n    # Format the final output string as a list of lists with no spaces.\n    # E.g., [[r1_1,r1_2],[r2_1],[],...]\n    string_parts = []\n    for res_list in results:\n        # Format each inner list as \"[el1,el2,...]\"\n        string_parts.append(f\"[{','.join(map(str, res_list))}]\")\n    \n    # Join the inner list strings and wrap with outer brackets.\n    final_output = f\"[{','.join(string_parts)}]\"\n\n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "在上一个练习的基础上，这个问题增加了一层复杂性，要求你找到*最近的*更大元素，而不论其方向。这需要你首先找到左边和右边最近的更大元素，然后应用一个决策步骤来比较它们的距离。这个练习教授了一项关键的解题技巧：将一个复杂的查询分解为你已经知道如何用单调栈模式有效解决的子问题。",
            "id": "3254259",
            "problem": "给定一个在全序域（例如，具有常规顺序的整数）上的长度为 $n$ 的数组 $A$。对于每个索引 $i$（$0 \\le i  n$），定义目标索引 $j$ 为在满足严格不等式 $A[j]  A[i]$ 的前提下，使绝对索引距离 $|i - j|$ 最小化的索引。如果不存在这样的索引 $j$，则该位置返回 $-1$。如果出现平局情况，即存在索引 $j_\\ell$ 和 $j_r$ 满足 $j_\\ell  i  j_r$，$A[j_\\ell]  A[i]$，$A[j_r]  A[i]$ 且 $|i - j_\\ell| = |j_r - i|$，则选择较小的索引（即左侧的索引），也就是 $j_\\ell$。\n\n你的任务是实现一个程序，对于给定的数组 $A$，计算一个长度为 $n$ 的列表 $B$，其中 $B[i]$ 是按上述定义选择的索引 $j$，如果不存在这样的索引，则为 $-1$。\n\n请仅使用数组和栈的基本定义以及“栈数据结构支持后进先出顺序的推入和弹出操作”这一经过充分检验的事实，从基本原理出发设计你的解决方案。不要假设或引用任何预先推导出的关于最近更大值查询的专门公式；相反，应论证那些能够导向线性时间方法的数据结构不变量。\n\n测试套件和要求的输出：\n- 使用以下数组作为测试用例：\n    1. $[2,1,3,2,4]$\n    2. $[1,2,3,4]$\n    3. $[4,3,2,1]$\n    4. $[2,2,2,2]$\n    5. $[5,1,5,1,5]$\n    6. $[2,1,1,3]$\n    7. $[7]$\n- 对于每个测试用例，计算对应的整数索引列表 $B$。最终的程序输出必须将所有测试用例的结果聚合为单行，该行包含一个逗号分隔的列表，其中每个元素是单个测试用例的结果（本身也是一个整数列表），整个聚合结果用方括号括起来。例如，如果有三个测试用例，结果分别为 $R_1$、$R_2$ 和 $R_3$，输出格式将是 $[R_1,R_2,R_3]$，其中每个 $R_k$ 都以 $[\\dots]$ 的形式打印，不含空格。",
            "solution": "该问题是有效的，因为它是自包含的、数学上定义明确的，并且根植于计算机科学和离散数学的原理。它提出了一个清晰、客观的算法挑战，没有任何科学上的不一致或歧义。\n\n任务是为数组 $A$（长度为 $n$）中的每个元素 $A[i]$，找到一个元素 $A[j]$ 的索引 $j$，该元素严格大于 $A[i]$ 并且在索引距离 $|i - j|$ 上最接近 $i$。一个特定的平局规则规定，当存在两个等距离的这样的元素时，优先选择较小的索引（左侧的索引）。\n\n一种直接的暴力方法是，对于从 $0$ 到 $n-1$ 的每个索引 $i$，从 $i$ 开始向左和向右两个方向搜索，以找到第一个满足 $A[j]  A[i]$ 的索引 $j$。这将导致对于每个 $i$，都需要搜索最多 $O(n)$ 个其他索引，从而使得总体时间复杂度为 $O(n^2)$。我们可以利用栈数据结构设计一个更高效的解决方案，其时间复杂度为线性时间 $O(n)$。\n\n核心思想是将问题分解为两个独立的子问题：\n$1$. 对于每个索引 $i$，找到“左侧最近更大值”，我们将其表示为 $j_\\ell(i)$。这是最接近 $i$ 的索引 $k  i$（即最大的 $k$），使得 $A[k]  A[i]$。如果不存在这样的索引，我们定义 $j_\\ell(i) = -1$。\n$2$. 对于每个索引 $i$，找到“右侧最近更大值”，我们将其表示为 $j_r(i)$。这是最接近 $i$ 的索引 $k  i$（即最小的 $k$），使得 $A[k]  A[i]$。如果不存在这样的索引，我们定义 $j_r(i) = -1$。\n\n一旦我们计算出数组 $J_\\ell = [j_\\ell(0), j_\\ell(1), \\dots, j_\\ell(n-1)]$ 和 $J_r = [j_r(0), j_r(1), \\dots, j_r(n-1)]$，我们就可以通过比较候选的 $j_\\ell(i)$ 和 $j_r(i)$ 来确定每个索引 $i$ 的最终结果 $B[i]$：\n- 如果 $j_\\ell(i)$ 和 $j_r(i)$ 均为 $-1$，则不存在这样的更大元素，所以 $B[i] = -1$。\n- 如果只有一个存在（不为 $-1$），那么它就是答案。例如，如果 $j_\\ell(i) \\ne -1$ 且 $j_r(i) = -1$，则 $B[i] = j_\\ell(i)$。\n- 如果两者都存在，我们比较距离。到左侧的距离是 $d_\\ell = i - j_\\ell(i)$，到右侧的距离是 $d_r = j_r(i) - i$。根据问题的平局规则，如果 $d_\\ell \\le d_r$，我们选择左侧的索引。因此，如果 $i - j_\\ell(i) \\le j_r(i) - i$，则 $B[i] = j_\\ell(i)$，否则 $B[i] = j_r(i)$。\n\n主要挑战是以线性时间计算 $J_\\ell$ 和 $J_r$。我们可以使用单调栈来实现这一点。让我们从基本原理推导计算 $J_\\ell$ 的算法。计算 $J_r$ 的逻辑是对称的。\n\n为了计算 $J_\\ell$，我们从左到右遍历数组 $A$，从 $i=0$ 到 $n-1$。我们使用一个栈 `st` 来存储我们已处理过的元素的索引。关键步骤是在这个栈上维护一个特定的不变量。\n\n**不变量**：栈 `st` 将包含一个索引序列 $p_1, p_2, \\dots, p_k$（从底到顶），其在数组 $A$ 中对应的值是严格递减的：$A[p_1]  A[p_2]  \\dots  A[p_k]$。这被称为单调递减栈。\n\n**寻找左侧最近更大值（$J_\\ell$）的算法：**\n我们初始化一个空栈 `st` 和一个大小为 $n$、填充为 $-1$ 的结果数组 $J_\\ell$。然后我们用索引 $i$ 从 $0$ 遍历到 $n-1$：\n$1$. 对于当前元素 $A[i]$，我们查看栈顶的索引 $p$。\n$2$. 当栈不为空且栈顶索引对应的元素小于或等于当前元素（$A[st.\\text{top}()] \\le A[i]$）时，我们从栈中弹出元素。这样做是正确的，因为如果 $A[st.\\text{top}()] \\le A[i]$，那么索引 $st.\\text{top}()$ 永远不可能成为未来任何元素 $A[k]$（其中 $k>i$）的“左侧最近更大值”，因为 $i$ 是一个离 $k$ 更近的索引，并且 $A[i]$ 的值至少一样大，这使得 $st.\\text{top}()$ 成为一个次优的候选者。\n$3$. 弹出循环结束后，栈要么为空，要么其栈顶元素是一个索引 $p$，其中 $A[p]  A[i]$。因为我们已经弹出了所有在 $p$ 右侧且值小于或等于 $A[i]$ 的索引，所以这个索引 $p$ 是 $i$ 左侧值严格大于 $A[i]$ 的最近索引。因此，我们设置 $j_\\ell(i) = st.\\text{top}()$。如果栈变为空，则表示左侧没有比 $A[i]$ 更大的元素，$j_\\ell(i)$ 保持为 $-1$。\n$4$. 最后，我们将当前索引 $i$ 推入栈中。此操作保持了单调递减的不变量，因为所有值小于或等于 $A[i]$ 的元素都已被移除。\n\n这个过程对数组中的每个元素只访问一次。每个索引只被推入栈一次，最多被弹​​出一次。因此，计算整个 $J_\\ell$ 数组的时间复杂度为 $O(n)$。\n\n计算 $J_r$ 数组的逻辑是对称的。我们可以从右到左遍历数组 $A$，从 $i=n-1$ 到 $0$，应用相同的单调栈原理。\n\n完整的算法如下：\n$1$. 使用从左到右的遍历和单调栈，在 $O(n)$ 时间内计算 $J_\\ell$ 数组。\n$2$. 使用从右到左的遍历和单调栈，在 $O(n)$ 时间内计算 $J_r$ 数组。\n$3$. 通过从 $i=0$ 到 $n-1$ 遍历，应用距离比较和平局逻辑，在 $O(n)$ 时间内将结果合并到最终数组 $B$ 中。\n\n总时间复杂度为 $O(n) + O(n) + O(n) = O(n)$，空间复杂度为 $O(n)$，用于存储栈以及中间数组 $J_\\ell$ 和 $J_r$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the nearest greater element problem for a list of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [2, 1, 3, 2, 4],\n        [1, 2, 3, 4],\n        [4, 3, 2, 1],\n        [2, 2, 2, 2],\n        [5, 1, 5, 1, 5],\n        [2, 1, 1, 3],\n        [7]\n    ]\n\n    results = []\n    for a in test_cases:\n        n = len(a)\n        if n == 0:\n            results.append([])\n            continue\n\n        # 1. Compute Nearest Greater to the Left (ngl)\n        # We iterate from left to right. The stack stores indices of elements\n        # in a monotonically decreasing value order.\n        ngl = [-1] * n\n        stack = []\n        for i in range(n):\n            # While stack is not empty and the element at the index on top of the stack\n            # is less than or equal to the current element, pop.\n            while stack and a[stack[-1]] = a[i]:\n                stack.pop()\n            # If the stack is not empty after popping, the top element is the NGL.\n            if stack:\n                ngl[i] = stack[-1]\n            # Push the current index onto the stack.\n            stack.append(i)\n\n        # 2. Compute Nearest Greater to the Right (ngr)\n        # We iterate from right to left. The logic is symmetric to NGL.\n        ngr = [-1] * n\n        stack = []\n        for i in range(n - 1, -1, -1):\n            # Pop elements from stack that are less than or equal to current element.\n            while stack and a[stack[-1]] = a[i]:\n                stack.pop()\n            # If stack is not empty, its top is the NGR.\n            if stack:\n                ngr[i] = stack[-1]\n            # Push current index.\n            stack.append(i)\n\n        # 3. Combine ngl and ngr to find the final result\n        result = [-1] * n\n        for i in range(n):\n            j_left, j_right = ngl[i], ngr[i]\n\n            # Case 1: No greater element exists\n            if j_left == -1 and j_right == -1:\n                result[i] = -1\n            # Case 2: Only greater element is to the right\n            elif j_left == -1:\n                result[i] = j_right\n            # Case 3: Only greater element is to the left\n            elif j_right == -1:\n                result[i] = j_left\n            # Case 4: Greater elements exist on both sides\n            else:\n                dist_left = i - j_left\n                dist_right = j_right - i\n                # Tie-breaking rule: choose left if distances are equal or left is closer.\n                if dist_left = dist_right:\n                    result[i] = j_left\n                else:\n                    result[i] = j_right\n        \n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Each result list is formatted as a string \"[i1,i2,...]\"\n    formatted_results = [f\"[{','.join(map(str, res))}]\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "我们最后的练习挑战你将单调性思维应用于一个模式识别问题：识别最长的“山脉”子数组。虽然这不完全是一个直接的“下一个更大元素”查询，但其解决方案在于将“山脉”结构分解为其单调的组成部分——一个严格递增的斜坡和一个严格递减的斜坡。这个练习展示了分析单调性来解决更广泛问题的通用性，这些问题超出了简单的最近元素查找。",
            "id": "3254270",
            "problem": "给定一个有限整数序列，请你计算每个序列中最长连续“山脉”子数组的长度。山脉子数组被定义为一个先严格递增后严格递减的连续片段，其中至少包含一次递增和一次递减。形式上，给定一个长度为 $n$ 的数组 $A$，一个索引满足 $0 \\le \\ell \\le r  n$ 的子数组 $A[\\ell \\dots r]$ 是一个山脉，如果存在一个索引 $p$ 满足 $\\ell  p  r$，使得以下严格不等式成立：$A_{\\ell}  A_{\\ell+1}  \\dots  A_{p-1}  A_{p}$ 且 $A_{p}  A_{p+1}  \\dots  A_{r}$。该子数组的长度为 $r - \\ell + 1$。如果不存在山脉子数组，则所需长度为 $0$。\n\n你的程序必须是一个完整、可运行的程序，能够计算本说明中提供的每个测试用例的最长山脉长度，并以指定格式将结果汇总打印在单行中。\n\n算法设计必须基于数据结构和算法的基本定义。相关基础是：\n- 栈是一种支持后进先出（LIFO）访问的容器。单调栈是一种其内容被维护以使存储的键序列保持单调（通常是严格递增或严格递减）的栈，它能够通过单次遍历计算不等关系发生变化的边界索引。\n- 严格不等性、传递性和连续性约束定义了山脉的结构：从左到右遍历数组时，不等式 $A_{i-1}  A_{i}$ 表征一个递增步，而不等式 $A_{i}  A_{i+1}$ 表征一个递减步。这些属性是局部的，它们组合起来形成连续的区域。\n\n除了这些定义之外，你不得假定任何特定的捷径公式。设计必须从单调性和不变量维护的第一性原理出发。\n\n输入数组由整数组成，可能包含负值和重复值。严格性意味着任何等式 $A_{i} = A_{i+1}$ 都会在该边界处同时中断递增和递减序列。山脉长度必须是元素的整数计数。不涉及任何物理单位。\n\n测试套件：\n- 用例 $1$：$[2,1,4,7,3,2,5]$。\n- 用例 $2$：$[2,2,2]$。\n- 用例 $3$：$[1,2,3,4]$。\n- 用例 $4$：$[4,3,2,1]$。\n- 用例 $5$：$[1,3,2]$。\n- 用例 $6$：$[1,2,2,3,2,1]$。\n- 用例 $7$：$[0,1,2,3,4,5,4,3,2,1,0]$。\n- 用例 $8$：$[-3,-2,-1,-2,-3]$。\n- 用例 $9$：$[1]$。\n- 用例 $10$：$[2,1,2,3,4,3,2,1,2]$。\n\n输出规范：\n- 对于每个测试用例，计算一个整数，该整数等于给定数组中最长山脉子数组的长度（如果不存在山脉，则为 $0$）。\n- 你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，不含空格，并按上述测试用例的顺序排列，例如 $[x_1,x_2,\\dots,x_{10}]$，其中每个 $x_i$ 是第 $i$ 个用例的整数长度。\n\n你的程序必须在没有任何外部输入的情况下运行，并且必须使用嵌入在代码中的测试套件。运行环境是一种现代语言；实现必须具有通用性，并且应该能扩展到大型数组，但在这里它将在给定的小型测试套件上执行。核心设计必须基于所述的单调性原理，并通过仔细处理边界情况（例如长度小于 $3$ 的数组、存在 $A_{i} = A_{i+1}$ 的平台期的数组以及纯粹递增或纯粹递减的数组）来确保正确性。",
            "solution": "在进行求解之前，我们首先对问题陈述进行严谨的验证，以确保其科学和逻辑上的健全性。\n\n### 步骤 1：提取已知条件\n\n问题提供了以下数据、定义和约束：\n- **目标**：对于给定的有限整数序列，计算其最长连续“山脉”子数组的长度。\n- **山脉子数组的定义**：给定一个长度为 $n$ 的数组 $A$，一个索引满足 $0 \\le \\ell \\le r  n$ 的连续子数组 $A[\\ell \\dots r]$ 是一个山脉，如果存在一个索引 $p$ 满足 $\\ell  p  r$，使得 $A_{\\ell}  A_{\\ell+1}  \\dots  A_{p-1}  A_{p}$ 且 $A_{p}  A_{p+1}  \\dots  A_{r}$。\n- **核心条件**：子数组必须至少包含一个严格递增步和一个严格递减步。\n- **长度定义**：子数组 $A[\\ell \\dots r]$ 的长度定义为 $r - \\ell + 1$。\n- **基本情况**：如果不存在山脉子数组，则长度为 $0$。\n- **算法基础**：解决方案必须从单调性和不变量维护的第一性原理推导得出，并特别提到单调栈作为一个相关概念。\n- **输入属性**：输入数组由整数组成，可能包含负值和重复值。\n- **严格不等性**：等式 $A_{i} = A_{i+1}$ 构成一个“平台期”，并同时中断严格递增和严格递减的序列。\n- **测试套件**：\n    - 用例 $1$：$[2,1,4,7,3,2,5]$\n    - 用例 $2$：$[2,2,2]$\n    - 用例 $3$：$[1,2,3,4]$\n    - 用例 $4$：$[4,3,2,1]$\n    - 用例 $5$：$[1,3,2]$\n    - 用例 $6$：$[1,2,2,3,2,1]$\n    - 用例 $7$：$[0,1,2,3,4,5,4,3,2,1,0]$\n    - 用例 $8$：$[-3,-2,-1,-2,-3]$\n    - 用例 $9$：$[1]$\n    - 用例 $10$：$[2,1,2,3,4,3,2,1,2]$\n- **输出规范**：单行输出，包含用方括号括起来的逗号分隔的整数结果，例如 $[x_1,x_2,\\dots,x_{10}]$。\n\n### 步骤 2：使用提取的已知条件进行验证\n\n根据验证标准对问题进行评估：\n- **科学依据**：该问题是数学和计算机科学（特别是算法）领域中一个明确定义的练习。它依赖于序列、子数组和严格不等式的形式化定义。它不含任何非科学前提。\n- **适定性**：该问题是适定的。对于任何有限数组，其所有连续子数组的集合是有限的。对于每个子数组，“山脉”属性是可判定的。所有有效山脉子数组的长度集合是一个有限的非负整数集合，必然存在一个明确定义的最大值。因此，存在唯一的解。\n- **客观性**：该问题使用精确、客观的数学语言陈述。诸如“连续”、“严格递增”和“严格递减”之类的术语是明确无误的。\n- **缺陷分析**：\n    1.  **科学或事实上的不健全性**：无。该问题在逻辑上和数学上是一致的。\n    2.  **无法形式化或不相关**：该问题是可形式化的。这些概念可以直接转化为算法。对单调栈的引用正确定位了该问题在数据结构和算法领域中的位置。\n    3.  **不完整或矛盾的设定**：该问题是自洽的。山脉的定义是完整的，指明了结构、峰值的存在、严格的单调性、隐含的最小长度 $3$（一次上升，一次下降）以及默认结果 $0$。\n    4.  **不切实际或不可行**：不适用，因为该问题处理的是抽象的数学对象（整数数组）。\n    5.  **不适定或结构不良**：无。问题结构保证了唯一且有意义的解。\n    6.  **伪深刻、琐碎或同义反复**：该问题并非琐碎问题，需要有效的算法方法来高效求解。它代表了一类标准的数组处理问题。\n    7.  **超出科学可验证性**：对于任何给定的输入，其解在数学上都是可验证的。\n\n### 步骤 3：结论与行动\n\n该问题是**有效的**。它是一个清晰、自洽且逻辑健全的算法挑战。我们现在将基于第一性原理进行求解。\n\n### 解决方案\n\n该问题要求我们找到符合“山脉”结构的最长连续子数组的长度。山脉的特征是有一个峰值元素，一段通向峰值的严格递增序列，以及一段紧随峰值的严格递减序列。这种结构意味着，任何元素要成为峰值，都必须严格大于其直接相邻的元素。\n\n解决这个问题的核心原则是将山脉结构分解为其基本的单调组成部分：一个严格递增部分和一个严格递减部分。我们可以系统地分析数组，为每个潜在的峰值量化这些组成部分。动态规划方法非常适合此问题，因为它允许我们从更小子问题的解来构建最终解。\n\n设输入数组为 $A$，长度为 $n$。该算法分三个阶段进行：\n\n1.  **计算上坡长度**：我们定义一个与 $A$ 大小相同的数组 `up`。对于从 $0$ 到 $n-1$ 的每个索引 $i$，`up[i]` 将存储以索引 $i$ 结尾的最长严格递增连续子数组的长度。\n    这可以通过从左到右的一次遍历来计算。根据定义，`up[0] = 1`。对于任何后续索引 $i>0$：\n    - 如果 $A[i] > A[i-1]$，则递增序列得到延长。因此，`up[i] = up[i-1] + 1`。\n    - 如果 $A[i] \\le A[i-1]$，则严格递增序列被中断。一个长度为 $1$（仅包含 $A[i]$）的新序列从此索引开始。因此，`up[i] = 1`。\n\n2.  **计算下坡长度**：类似地，我们定义一个大小为 $n$ 的数组 `down`。对于每个索引 $i$，`down[i]` 将存储以索引 $i$ 开始的最长严格递减连续子数组的长度。\n    这可以通过从右到左的一次遍历来计算。根据定义，`down[n-1] = 1`。对于任何前面的索引 $i  n-1$：\n    - 如果 $A[i] > A[i+1]$，则递减序列从右侧得到延长。因此，`down[i] = down[i+1] + 1$。\n    - 如果 $A[i] \\le A[i+1]$，则严格递减序列被中断。一个长度为 $1$ 的新序列从此索引开始。因此，`down[i] = 1$。\n\n3.  **组合并寻找最大长度**：一个元素 $A[i]$ 能作为山脉的峰值，当且仅当其前是一个严格递增序列，其后是一个严格递减序列。这等价于条件 `up[i] > 1` 和 `down[i] > 1`。条件 `up[i] > 1` 确保至少有一个上坡步，而 `down[i] > 1` 确保至少有一个下坡步。\n    如果这些条件得到满足，以 $i$ 为峰值的山脉的总长度是上坡部分的长度加上下坡部分的长度。峰值元素 $A[i]$ 在 `up[i]` 和 `down[i]` 中都被计算了一次，所以我们必须减去 $1$ 以避免重复计数。这样一个山脉的长度是 `up[i] + down[i] - 1`。\n    我们遍历从 $0$ 到 $n-1$ 的所有索引 $i$。对于每个符合峰值条件的 $i$，我们计算山脉的长度并更新目前为止找到的最大长度记录。初始最大长度为 $0$。\n\n这种方法系统地检查每个潜在的峰值，正确计算与其关联的山脉长度，并找到全局最大值。由于对数组进行了三次独立的线性遍历，其时间复杂度为 $O(n)$；由于使用了辅助数组 `up` 和 `down`，其空间复杂度为 $O(n)$。这种方法直接体现了分析单调片段的原则，正如问题中对单调栈的引用所暗示的那样。\n\n任何能够包含山脉的数组的最小长度是 $3$。长度 $n  3$ 的数组无法满足条件 $\\ell  p  r$，因此它们的最长山脉长度自然为 $0$。这一点由 `up[i] > 1` 和 `down[i] > 1` 的条件自然处理，但对 $n  3$ 进行初始检查是一个审慎的优化。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_longest_mountain(arr: list[int]) - int:\n    \"\"\"\n    Computes the length of the longest contiguous mountain subarray.\n\n    A mountain subarray is defined as a contiguous segment that is strictly\n    increasing and then strictly decreasing. It must have at least one\n    increase and at least one decrease.\n\n    Args:\n        arr: A list of integers.\n\n    Returns:\n        The length of the longest mountain subarray, or 0 if none exists.\n    \"\"\"\n    n = len(arr)\n    # A mountain must have length at least 3.\n    if n  3:\n        return 0\n\n    # up[i] will store the length of the strictly increasing subarray ending at i.\n    # We use numpy arrays as permitted by the execution environment.\n    up = np.ones(n, dtype=int)\n    for i in range(1, n):\n        # Extend the increasing run if the current element is greater than the previous.\n        if arr[i] > arr[i-1]:\n            up[i] = up[i-1] + 1\n\n    # down[i] will store the length of the strictly decreasing subarray starting at i.\n    down = np.ones(n, dtype=int)\n    for i in range(n - 2, -1, -1):\n        # Extend the decreasing run if the current element is greater than the next.\n        if arr[i] > arr[i+1]:\n            down[i] = down[i+1] + 1\n            \n    max_length = 0\n    # Iterate through all possible peak indices.\n    for i in range(n):\n        # A valid peak requires at least one step up and one step down.\n        # This is equivalent to the uphill and downhill runs having length > 1.\n        if up[i] > 1 and down[i] > 1:\n            # The total length is the sum of the run lengths, subtracting 1\n            # to not double-count the peak element.\n            current_length = up[i] + down[i] - 1\n            if current_length > max_length:\n                max_length = current_length\n                \n    return int(max_length)\n\ndef solve():\n    \"\"\"\n    Defines the test suite, runs the solver on each case, and\n    prints the results in the specified format.\n    \"\"\"\n    test_cases = [\n        [2,1,4,7,3,2,5],          # Case 1\n        [2,2,2],                  # Case 2\n        [1,2,3,4],                # Case 3\n        [4,3,2,1],                # Case 4\n        [1,3,2],                  # Case 5\n        [1,2,2,3,2,1],            # Case 6\n        [0,1,2,3,4,5,4,3,2,1,0],  # Case 7\n        [-3,-2,-1,-2,-3],         # Case 8\n        [1],                      # Case 9\n        [2,1,2,3,4,3,2,1,2],    # Case 10\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_longest_mountain(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}