{
    "hands_on_practices": [
        {
            "introduction": "A key advantage of treaps over simple binary search trees is their resilience to pathological insertion orders. This exercise challenges you to think critically about this property by considering a highly structured, non-random insertion sequence of keys. By analyzing this scenario, you can solidify your understanding of the fundamental principle that makes treaps efficient: the randomly assigned priorities, not the key insertion order, are the ultimate determinant of the tree's final structure.",
            "id": "3280465",
            "problem": "Consider a treap, which is a binary search tree on keys that simultaneously satisfies the heap property on an independently drawn real-valued priority for each key. Specifically, for each key $k$ we draw a priority $p_k$ independently from a continuous distribution on $\\mathbb{R}$, and the tree maintains both the binary search tree property on the keys and the min-heap property on the priorities (the parent’s priority is less than the child’s priority). The keys are the distinct integers $\\{1, 2, \\dots, n\\}$, and they are inserted in the interleaved order $1, n, 2, n-1, 3, n-2, \\dots$ until all $n$ keys have been inserted. Let $h_n$ denote the final height of the treap and let $C_n$ denote the total number of key comparisons performed over all $n$ insertions by the standard treap insertion algorithm (place the new node as a binary search tree leaf by key comparisons, then perform rotations to restore the heap property on priorities).\n\nWhich of the following statements best characterizes the asymptotic performance and structural distribution of the treap resulting from this insertion sequence?\n\nA. Regardless of this interleaved key order, the joint distribution of the final treap shape is identical to that of a binary search tree built by inserting the keys in a uniformly random permutation induced by the random priorities; consequently, $\\mathbb{E}[h_n] = \\Theta(\\log n)$ and $\\mathbb{E}[C_n] = \\Theta(n \\log n)$, and the insertion order does not change these expectations.\n\nB. Because the key order is nearly sorted, the treap degenerates: $\\mathbb{E}[h_n] = \\Theta(n)$ and $\\mathbb{E}[C_n] = \\Theta(n^2)$.\n\nC. The alternation between extremal keys increases path oscillation and forces extra adjustments: $\\mathbb{E}[h_n] = \\Theta(\\log n)$ but with a strictly larger constant than if the keys were inserted in a random order, and $\\mathbb{E}[C_n] = \\Theta(n \\log n)$ with a strictly larger leading constant for this interleaved order.\n\nD. The final treap shape is determined solely by the key insertion order and not by the priorities; in particular, after the given sequence, $h_n$ equals the height of the plain binary search tree that would be built by inserting keys in the order $1, n, 2, n-1, \\dots$, so $h_n$ is linear in $n$.",
            "solution": "The solution hinges on a fundamental theorem about treaps: the final structure is uniquely determined by the set of key-priority pairs, regardless of the insertion order.\n\n**1. Structure of the Final Treap**\nA treap is simultaneously a Binary Search Tree (BST) on keys and a min-heap on priorities. For any given set of $n$ distinct key-priority pairs, the node with the absolute minimum priority must be the root of the tree. The BST property then dictates that all keys smaller than the root's key form the left subtree, and all keys larger form the right subtree. This principle applies recursively, defining a unique structure for the entire tree. Therefore, the final shape of the treap is independent of the order in which keys are inserted.\n\n**2. Equivalence to Randomized BSTs**\nSince priorities are chosen independently from a continuous distribution, sorting the nodes by priority yields a uniformly random permutation of the keys. The resulting treap structure is therefore statistically identical to that of a standard BST built by inserting the keys in a uniformly random order. The key insertion sequence given in the problem is irrelevant to the distribution of the final tree's shape.\n\n**3. Analysis of Performance Metrics**\n*   **Expected Height, $\\mathbb{E}[h_n]$**: The height $h_n$ is a property of the final tree structure. Since this structure's distribution is independent of the key insertion order, $\\mathbb{E}[h_n]$ is also independent of the order. For a BST built from a random permutation of $n$ keys, the expected height is a well-known result: $\\mathbb{E}[h_n] = \\Theta(\\log n)$. This holds for any insertion order.\n*   **Total Comparison Cost, $\\mathbb{E}[C_n]$**: The total number of key comparisons, $C_n$, is the sum of costs for each of the $n$ insertions. The cost of inserting the $i$-th key into the existing treap of $i-1$ nodes is proportional to the depth of the search path. In a randomized tree of size $i-1$, this expected depth is $O(\\log i)$. Summing over all insertions gives $\\mathbb{E}[C_n] = \\sum_{i=1}^n O(\\log i) = \\Theta(n \\log n)$. This asymptotic bound holds regardless of the insertion order.\n\n**Evaluation of the Options**\n*   **A. Correct.** This statement correctly identifies that the final treap shape is equivalent to that of a random BST, leading to an expected logarithmic height and an expected total insertion cost of $\\Theta(n \\log n)$. While the exact expectation of $C_n$ (including constants) can vary with insertion order, the asymptotic behavior and the expectation of the final height $h_n$ are unchanged. This option provides the best overall characterization.\n*   **B. Incorrect.** This confuses a treap with a standard BST. The random priorities prevent the treap from degenerating, even with a structured key insertion order.\n*   **C. Incorrect.** While the asymptotic bounds are correct, it falsely claims the expected height $\\mathbb{E}[h_n]$ depends on the insertion order. The distribution of the final height is independent of the insertion sequence.\n*   **D. Incorrect.** This statement is fundamentally wrong. The treap's shape is determined by both keys and priorities, not just the insertion order.",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "Having established that a treap's structure is governed by probability, we can now perform a \"hands-on\" theoretical derivation to quantify specific structural properties. This problem asks you to calculate the exact probability of a particular configuration—the smallest and largest keys becoming siblings—based on first principles. This practice will deepen your intuition for how the combination of the Binary Search Tree (BST) property and the heap property translates into predictable probabilistic outcomes, moving from a qualitative understanding to a quantitative one.",
            "id": "3280387",
            "problem": "Consider a treap built over a totally ordered set of $n$ distinct keys, labeled by their sorted order as $1,2,\\dots,n$, with $n \\ge 3$. Each key $i$ is assigned an independent priority $P_i$ drawn from a continuous distribution, and the treap is the unique binary tree that is simultaneously a Binary Search Tree (BST) on the keys and a heap (min-heap) on the priorities. In other words, the root holds the key whose priority is the minimum among all $n$ priorities, and recursively the left and right subtrees are treaps over the keys to the left and right of the root in the key order.\n\nTwo nodes are called direct siblings if they share the same parent. Using only the foundational definitions of treaps (independent and identically distributed continuous priorities, BST order on keys, and heap order on priorities) and basic probability, derive from first principles the exact probability, as a function of $n$, that the nodes with the smallest and the largest keys (that is, keys $1$ and $n$) are direct siblings in the treap.\n\nExpress your final answer as a closed-form analytic expression in terms of $n$ using standard mathematical functions and, if needed, harmonic numbers. No numerical approximation or rounding is required.",
            "solution": "The problem asks for the probability that the nodes with the smallest key, $1$, and the largest key, $n$, are direct siblings in a treap of $n$ keys, where $n \\ge 3$.\n\nLet the set of keys be $K = \\{1, 2, \\dots, n\\}$. Each key $i \\in K$ is associated with a priority $P_i$. The priorities are independent and identically distributed (i.i.d.) random variables drawn from a continuous distribution. The treap structure is a binary tree that is a Binary Search Tree (BST) on the keys and a min-heap on the priorities.\n\nFor two nodes to be direct siblings, they must share the same parent node. Let the key of the parent of nodes $1$ and $n$ be $k$.\nAccording to the BST property, for $k$ to be a parent of both $1$ and $n$, node $1$ must be in its left subtree and node $n$ must be in its right subtree. This implies that the key $k$ must satisfy $1  k  n$. Therefore, the possible keys for the parent node are $k \\in \\{2, 3, \\dots, n-1\\}$.\n\nA fundamental property of a treap is that the lowest common ancestor (LCA) of any two nodes with keys $i$ and $j$ (assuming $i  j$) is the node with key $x$ such that $i \\le x \\le j$ and $P_x$ is the minimum among all priorities $\\{P_y \\mid i \\le y \\le j\\}$. For nodes $1$ and $n$, their LCA is the node with key $k \\in \\{1, \\dots, n\\}$ that has the minimum priority among all priorities $\\{P_1, \\dots, P_n\\}$. This means the LCA of nodes $1$ and $n$ is always the root of the entire treap.\n\nFor nodes $1$ and $n$ to be siblings, their parent must be their LCA, which must be the root of the treap. Let the key of this root node be $k$. The event that $k$ is the parent of $1$ and $n$ requires three conditions to be met simultaneously:\n1.  **Node $k$ is the root of the entire treap.** This means its priority, $P_k$, must be the minimum of all priorities: $P_k = \\min\\{P_1, P_2, \\dots, P_n\\}$.\n\n2.  **Node $1$ is the direct left child of $k$.** The left child of the root $k$ is the root of the sub-treap constructed from the set of keys $\\{1, 2, \\dots, k-1\\}$. For node $1$ to be the root of this sub-treap, its priority, $P_1$, must be the minimum among the priorities of this set: $P_1 = \\min\\{P_1, P_2, \\dots, P_{k-1}\\}$.\n\n3.  **Node $n$ is the direct right child of $k$.** The right child of the root $k$ is the root of the sub-treap constructed from the set of keys $\\{k+1, k+2, \\dots, n\\}$. For node $n$ to be the root of this sub-treap, its priority, $P_n$, must be the minimum among the priorities of this set: $P_n = \\min\\{P_{k+1}, P_{k+2}, \\dots, P_n\\}$.\n\nWe can now calculate the probability of this joint event for a fixed $k \\in \\{2, 3, \\dots, n-1\\}$. Since the priorities are i.i.d. from a continuous distribution, for any finite set of priorities, each one has an equal chance of being the minimum. The three conditions above relate to the minimums of three disjoint sets of priorities: $\\{P_k\\}$, $\\{P_1, \\dots, P_{k-1}\\}$, and $\\{P_{k+1}, \\dots, P_n\\}$. Due to independence, we can multiply the probabilities.\n\n- The probability that $P_k$ is the minimum among $n$ priorities is $\\frac{1}{n}$.\n- The probability that $P_1$ is the minimum among the $k-1$ priorities in its group is $\\frac{1}{k-1}$.\n- The probability that $P_n$ is the minimum among the $n-k$ priorities in its group is $\\frac{1}{n-k}$.\n\nThe probability that a specific key $k$ is the parent of siblings $1$ and $n$, let's call it $P(E_k)$, is:\n$$P(E_k) = \\frac{1}{n} \\cdot \\frac{1}{k-1} \\cdot \\frac{1}{n-k} = \\frac{1}{n(k-1)(n-k)}$$\nThis holds for any $k \\in \\{2, 3, \\dots, n-1\\}$.\n\nTo find the total probability that nodes $1$ and $n$ are siblings, we sum $P(E_k)$ over all possible parent keys $k$, as these events are disjoint:\n$$P(\\text{siblings}) = \\sum_{k=2}^{n-1} P(E_k) = \\sum_{k=2}^{n-1} \\frac{1}{n(k-1)(n-k)} = \\frac{1}{n} \\sum_{k=2}^{n-1} \\frac{1}{(k-1)(n-k)}$$\nWe use partial fraction decomposition for the term in the sum:\n$$\\frac{1}{(k-1)(n-k)} = \\frac{1}{n-1} \\left( \\frac{1}{k-1} + \\frac{1}{n-k} \\right)$$\nSubstituting this back into the summation:\n$$P(\\text{siblings}) = \\frac{1}{n(n-1)} \\sum_{k=2}^{n-1} \\left( \\frac{1}{k-1} + \\frac{1}{n-k} \\right)$$\nThe summation splits into two parts:\n$$\\sum_{k=2}^{n-1} \\frac{1}{k-1} = \\frac{1}{1} + \\frac{1}{2} + \\dots + \\frac{1}{n-2} = H_{n-2}$$\nwhere $H_m = \\sum_{i=1}^m \\frac{1}{i}$ is the $m$-th harmonic number. The second part of the sum is:\n$$\\sum_{k=2}^{n-1} \\frac{1}{n-k} = \\frac{1}{n-2} + \\frac{1}{n-3} + \\dots + \\frac{1}{1} = H_{n-2}$$\nThe total sum is therefore $H_{n-2} + H_{n-2} = 2H_{n-2}$.\nFinally, the probability is:\n$$P(\\text{siblings}) = \\frac{1}{n(n-1)} (2H_{n-2}) = \\frac{2H_{n-2}}{n(n-1)}$$\nThe condition $n \\ge 3$ ensures that $n-2 \\ge 1$, so $H_{n-2}$ is well-defined and positive.",
            "answer": "$$\\boxed{\\frac{2H_{n-2}}{n(n-1)}}$$"
        },
        {
            "introduction": "Theory and practice go hand-in-hand, and this final exercise challenges you to implement one of the most intricate core operations: non-recursive deletion. While insertion is relatively straightforward, deletion requires carefully \"bubbling down\" the target node using rotations to maintain both the BST and heap invariants. Implementing this iteratively with a stack, as required by this problem, forces a meticulous approach to pointer and path management, providing an invaluable, in-depth understanding of the treap's dynamic mechanics.",
            "id": "3280508",
            "problem": "A treap is a data structure that combines the Binary Search Tree (BST) property and the heap property. In a treap, each node stores a key and an independent priority. The BST property requires that for any node with key $k$, all keys in its left subtree are strictly less than $k$ and all keys in its right subtree are strictly greater than $k$. The heap property (min-heap in this problem) requires that for any node with priority $p$, the priorities of its children are strictly greater than $p$. A treap can be viewed as the unique tree that simultaneously satisfies these two properties for a given set of key-priority pairs.\n\nFundamental definitions and facts for this problem are:\n- The Binary Search Tree (BST) property: for each node with key $k$, for all keys $x$ in the left subtree, $x  k$, and for all keys $y$ in the right subtree, $y > k$.\n- The heap property (min-heap on priorities): for each node with priority $p$, for any child priority $p_c$, $p \\le p_c$.\n- A tree rotation is a local transformation that preserves the BST property while modifying parent-child relationships. Rotations are the fundamental operation used to restore the heap property after structural changes.\n\nYour task is to derive, implement, and validate a non-recursive delete operation in a treap. The delete must use a stack to manage the path from the root to the target node. The design must be grounded in the fundamental properties above and must avoid recursion for the delete operation. The high-level steps you must implement are:\n- Search for the node with key $k$ using BST-guided traversal, recording the path in a stack.\n- If the node is found, repeatedly \"bubble it down\" via rotations so that the node to delete eventually has at most one child. At each step, select the child with the smaller priority to rotate with so that the heap property remains valid. Use the stack to keep and update ancestral links deterministically and non-recursively.\n- Remove the node by reconnecting its parent to its single child (or to the empty child if it is a leaf).\n- Verify that the resulting tree retains the BST and heap properties.\n\nIn addition to delete, you may implement insertion by any method. However, deletion must be non-recursive and must explicitly use a stack to manage the path.\n\nVerification requirements:\n- Implement a function that checks the BST property by performing an in-order traversal and confirming the sequence is strictly increasing.\n- Implement a function that checks the heap property (min-heap on priorities) by confirming for each node that its priority is less than or equal to its children's priorities.\n- Implement a function that returns the in-order sequence of keys.\n\nComplexity requirements:\n- For a treap built from $n$ nodes with independent priorities, the expected height is $\\mathcal{O}(\\log n)$, and the delete operation must run in $\\mathcal{O}(h)$ time where $h$ is the height of the treap.\n\nTest suite:\nFor determinism, you will be given explicit key-priority pairs rather than randomized priorities. For each test case, build the treap by inserting the given pairs, then perform one delete operation with the specified key. For each test case, your program must output a list containing:\n- A boolean indicating whether a node with the given key was found and deleted.\n- A boolean indicating whether the resulting structure satisfies the BST property.\n- A boolean indicating whether the resulting structure satisfies the heap property.\n- The in-order traversal list of keys after deletion.\n\nUse the following test cases:\n- Test case $1$: pairs $\\{(5,10),(3,20),(8,30)\\}$, delete key $3$.\n- Test case $2$: pairs $\\{(5,10),(3,20),(4,15)\\}$, delete key $4$.\n- Test case $3$: pairs $\\{(5,10),(3,20),(7,15),(6,25)\\}$, delete key $5$.\n- Test case $4$: pairs $\\{(5,10),(3,20),(7,15)\\}$, delete key $42$.\n- Test case $5$: pairs $\\{\\}$, delete key $1$.\n- Test case $6$: pairs $\\{(50,5),(20,15),(70,10),(10,25),(30,40),(60,35),(80,20),(25,30),(35,45)\\}$, delete key $50$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each element corresponds to one test case result and is itself a list of four elements as specified above. For example: `[[r_1], [r_2], \\dots]` where each `[r_i]` has the structure `[deleted, bst_ok, heap_ok, inorder]`. No units are involved in this problem.",
            "solution": "A treap is a randomized binary search tree that balances itself with high probability. Its name is a portmanteau of \"tree\" and \"heap\". Each node in a treap holds a key, which satisfies the binary search tree (BST) property, and a randomly assigned priority, which satisfies the heap property. This dual-structure ensures that for any given set of key-priority pairs, the shape of the treap is unique.\n\n**Fundamental Properties:**\n1.  **Binary Search Tree (BST) Property:** For any node with key $k$, all keys in its left subtree are strictly less than $k$, and all keys in its right subtree are strictly greater than $k$. This property allows for efficient searching.\n2.  **Min-Heap Property:** For any node with priority $p$, the priorities of its children, $p_c$, must be greater than or equal to $p$ (i.e., $p \\le p_c$). This means the node with the minimum priority in any subtree is always the root of that subtree.\n\n**Deletion by Rotation:**\nTo delete a node, a naive removal can disrupt the heap property. The canonical method for deletion involves a series of rotations to \"bubble down\" the target node until it becomes a leaf or a node with a single child. At this point, it can be spliced out of the tree without complex restructuring.\n\nThe core of the operation lies in choosing the correct rotations. If the node to be deleted has two children, we compare their priorities. We rotate the node with the child that has the smaller priority. For example, if the left child has a smaller priority, we perform a right rotation on the target node. This brings the left child up, becoming the new parent, while the target node moves down. This specific choice of rotation is crucial because it preserves the heap property among the involved nodes. Since rotations are designed to preserve the BST property, the tree remains a valid BST throughout the process.\n\n**Non-Recursive Implementation with a Stack:**\nThe problem mandates a non-recursive implementation using a stack to manage the path from the root to the node being manipulated.\n\n**Step-by-Step Algorithm:**\n1.  **Search and Path Tracking:** We traverse the tree from the root to find the node with the target key. During this traversal, we use a stack to store the path taken. Each element on the stack can represent a parent and the direction of the traversal (e.g., as a tuple `(parent_node, is_left_child)`). This path information is essential for updating parent-child links after rotations.\n\n2.  **Iterative \"Bubble-Down\":** If the target node is found and has two children, we enter a loop. In each iteration:\n    a. We compare the priorities of the left and right children.\n    b. If the left child's priority is less than the right's, we perform a right rotation on the target node. Otherwise, we perform a left rotation.\n    c. After the rotation, the target node has moved one level down. Its original parent must now point to the new root of the rotated subtree. We use the information from our path stack to find this parent and update its `left` or `right` child pointer.\n    d. The stack is then updated to reflect the new parent-child relationship for the target node, preparing for the next iteration if the node still has two children.\n\n3.  **Final Node Removal:** The loop terminates when the target node has at most one child. At this point, it can be removed by making its parent point directly to its single child (or to `None` if it is a leaf). The path stack provides the final parent needed for this pointer manipulation.\n\n**Verification:**\nTo ensure correctness, two verification functions are implemented:\n- `check_bst()`: This function performs an in-order traversal. If the treap is a valid BST, the resulting sequence of keys must be strictly increasing.\n- `check_heap()`: This function performs a tree traversal. For each node, it verifies that its priority is less than or equal to the priorities of its children, as per the min-heap property.\n\nThis principled approach ensures that the non-recursive delete operation correctly maintains both the BST and heap invariants. The time complexity is proportional to the height of the tree, which for a treap is expected to be $\\mathcal{O}(\\log n)$.",
            "answer": "```python\nimport numpy as np\nfrom collections import deque\n\nclass Node:\n    \"\"\"A class to represent a node in the treap.\"\"\"\n    def __init__(self, key, priority):\n        self.key = int(key)\n        self.priority = int(priority)\n        self.left = None\n        self.right = None\n\nclass Treap:\n    \"\"\"A class to represent a treap data structure.\"\"\"\n    def __init__(self):\n        self.root = None\n\n    def _rotate_left(self, y):\n        \"\"\"Performs a left rotation on the subtree rooted at y.\"\"\"\n        x = y.right\n        T2 = x.left\n        x.left = y\n        y.right = T2\n        return x\n\n    def _rotate_right(self, y):\n        \"\"\"Performs a right rotation on the subtree rooted at y.\"\"\"\n        x = y.left\n        T2 = x.right\n        x.right = y\n        y.left = T2\n        return x\n\n    def _insert_recursive(self, node, key, priority):\n        \"\"\"Recursive helper for insertion, maintaining treap properties.\"\"\"\n        if not node:\n            return Node(key, priority)\n\n        if key  node.key:\n            node.left = self._insert_recursive(node.left, key, priority)\n            # If heap property is violated, rotate right\n            if node.left.priority  node.priority:\n                node = self._rotate_right(node)\n        elif key > node.key:\n            node.right = self._insert_recursive(node.right, key, priority)\n            # If heap property is violated, rotate left\n            if node.right.priority  node.priority:\n                node = self._rotate_left(node)\n        \n        return node\n\n    def insert(self, key, priority):\n        \"\"\"Public method for insertion.\"\"\"\n        self.root = self._insert_recursive(self.root, key, priority)\n\n    def delete(self, key):\n        \"\"\"\n        Non-recursive deletion using a stack to manage the path.\n        \"\"\"\n        # Step 1: Find the node and store the path to it.\n        # The stack stores tuples of (parent_node, is_left_child_bool).\n        path_stack = []\n        node = self.root\n        \n        while node and node.key != key:\n            parent = node\n            if key  node.key:\n                path_stack.append((parent, True))\n                node = node.left\n            else:\n                path_stack.append((parent, False))\n                node = node.right\n        \n        if not node:\n            return False  # Key not found\n\n        # Step 2: \"Bubble down\" the node using rotations until it has at most one child.\n        while node.left and node.right:\n            # Decide rotation based on child priorities.\n            if node.left.priority  node.right.priority:\n                new_sub_root = self._rotate_right(node)\n            else:\n                new_sub_root = self._rotate_left(node)\n\n            # Update the parent of the rotated subtree.\n            if not path_stack:\n                self.root = new_sub_root\n            else:\n                parent, is_left = path_stack[-1]\n                if is_left:\n                    parent.left = new_sub_root\n                else:\n                    parent.right = new_sub_root\n            \n            # The node to delete has moved down. Update path_stack for the next iteration.\n            path_stack.append((new_sub_root, node is new_sub_root.left))\n\n        # Step 3: Remove the node, which now has at most one child.\n        child = node.left if node.left else node.right\n        \n        if not path_stack:\n            self.root = child\n        else:\n            parent, is_left = path_stack[-1]\n            if is_left:\n                parent.left = child\n            else:\n                parent.right = child\n        \n        return True\n\n    def get_in_order_keys(self):\n        \"\"\"Returns a list of keys from an in-order traversal.\"\"\"\n        if not self.root:\n            return []\n        \n        result = []\n        stack = []\n        current = self.root\n        while current or stack:\n            while current:\n                stack.append(current)\n                current = current.left\n            current = stack.pop()\n            result.append(current.key)\n            current = current.right\n        return result\n\n    def check_bst(self):\n        \"\"\"Checks if the tree satisfies the BST property (strictly increasing keys in-order).\"\"\"\n        keys = self.get_in_order_keys()\n        for i in range(1, len(keys)):\n            if keys[i] = keys[i-1]:\n                return False\n        return True\n\n    def check_heap(self):\n        \"\"\"Checks if the tree satisfies the min-heap property on priorities.\"\"\"\n        if not self.root:\n            return True\n        \n        q = deque([self.root])\n        while q:\n            node = q.popleft()\n            if node.left:\n                if node.priority > node.left.priority:\n                    return False\n                q.append(node.left)\n            if node.right:\n                if node.priority > node.right.priority:\n                    return False\n                q.append(node.right)\n        return True\n\ndef solve():\n    test_cases = [\n        ({'pairs': {(5,10),(3,20),(8,30)}, 'delete_key': 3}),\n        ({'pairs': {(5,10),(3,20),(4,15)}, 'delete_key': 4}),\n        ({'pairs': {(5,10),(3,20),(7,15),(6,25)}, 'delete_key': 5}),\n        ({'pairs': {(5,10),(3,20),(7,15)}, 'delete_key': 42}),\n        ({'pairs': set(), 'delete_key': 1}),\n        ({'pairs': {(50,5),(20,15),(70,10),(10,25),(30,40),(60,35),(80,20),(25,30),(35,45)}, 'delete_key': 50}),\n    ]\n\n    results = []\n    for case in test_cases:\n        treap = Treap()\n        for key, priority in case['pairs']:\n            treap.insert(key, priority)\n        \n        deleted = treap.delete(case['delete_key'])\n        bst_ok = treap.check_bst()\n        heap_ok = treap.check_heap()\n        inorder = treap.get_in_order_keys()\n        \n        results.append([deleted, bst_ok, heap_ok, inorder])\n\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```"
        }
    ]
}