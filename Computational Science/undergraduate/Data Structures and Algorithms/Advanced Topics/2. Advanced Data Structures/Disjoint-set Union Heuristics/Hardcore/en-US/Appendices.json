{
    "hands_on_practices": [
        {
            "introduction": "This first exercise provides a classic and intuitive application of the Disjoint-Set Union data structure for a dynamic connectivity problem. You will simulate the formation of islands on a grid, a scenario where the DSU's ability to efficiently track the merging of connected components is paramount. This practice will solidify your understanding of implementing the core `find` and `union` operations with path compression and union-by-size heuristics. ",
            "id": "3228210",
            "problem": "You are to implement a program that simulates the incremental formation of connected components of land in a grid using the Disjoint-Set Union (DSU) data structure with union-by-size and path compression heuristics. The objective is to compute, after each land addition, the current number of connected components (\"islands\") under $4$-neighborhood adjacency.\n\nFundamental base and definitions:\n- A Disjoint-Set Union (DSU) maintains a partition of a finite universe into disjoint sets and supports two operations: $find(x)$, which returns a canonical representative of the set containing element $x$, and $union(x,y)$, which merges the sets containing $x$ and $y$ if they are distinct.\n- In union-by-size, when merging two sets, the root with smaller size is attached to the root with larger size, ensuring that the tree height grows slowly. In path compression, during $find(x)$, each visited node on the path to the root is directly linked to the root, flattening the structure for future queries.\n- The $4$-neighborhood for a cell at coordinates $(i,j)$ consists of $(i-1,j)$, $(i+1,j)$, $(i,j-1)$, and $(i,j+1)$, restricted to valid grid indices. Two land cells are connected if there is a path through land cells via steps in the $4$-neighborhood. This induces an equivalence relation on the set of land cells, and each equivalence class corresponds to one island.\n\nTask:\n- Consider a grid of $r \\times c$ cells with $r \\in \\mathbb{Z}_{\\ge 0}$ and $c \\in \\mathbb{Z}_{\\ge 0}$, indexed by zero-based coordinates $(i,j)$ with $i \\in \\{0,\\dots,r-1\\}$ and $j \\in \\{0,\\dots,c-1\\}$. Initially, all cells are water.\n- You are given an ordered list of $k$ additions $(p_1, p_2, \\dots, p_k)$, where each $p_t = (i_t, j_t)$ specifies turning the cell at row $i_t$ and column $j_t$ into land at step $t$. If a specified cell is already land, the grid state does not change at that step.\n- After each step $t \\in \\{1,\\dots,k\\}$, compute the number of islands present under $4$-neighborhood connectivity.\n\nRequirements:\n- You must implement Disjoint-Set Union (DSU) with both union-by-size and path compression heuristics.\n- Your algorithm must not assume prior knowledge beyond the fundamental DSU definitions and the connectivity definition given above.\n- The program should not read input. Instead, it must internally run on the following test suite of parameter values (each specified as a tuple $(r,c,\\text{additions})$):\n  - Test case $1$: $(r,c) = (3,3)$, additions $\\left[(0,0),(0,1),(1,2),(2,1),(1,1)\\right]$.\n  - Test case $2$: $(r,c) = (1,1)$, additions $\\left[(0,0),(0,0),(0,0)\\right]$.\n  - Test case $3$: $(r,c) = (2,2)$, additions $\\left[(0,0),(1,1),(0,1),(1,0)\\right]$.\n  - Test case $4$: $(r,c) = (2,3)$, additions $\\left[(0,0),(1,1),(0,2),(1,2)\\right]$.\n  - Test case $5$: $(r,c) = (5,5)$, additions $\\left[\\right]$ (the empty list).\n- For each test case, your program must produce a list of integers of length $k$ (possibly length $0$ for the empty list) where the $t$-th integer is the number of islands after processing the $t$-th addition.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each element corresponds to one test case and is itself a list of integers for that test case. For example, the output must have the form $\\left[\\text{case}_1,\\text{case}_2,\\dots,\\text{case}_m\\right]$, where each $\\text{case}_i$ is a list like $\\left[a_1,a_2,\\dots,a_k\\right]$.\n- There are no physical units involved in this problem. All angles, if any, are irrelevant to this problem.",
            "solution": "The problem requires simulating the dynamic formation of connected components in a grid. This is a classic application of the Disjoint-Set Union (DSU) data structure, also known as the Union-Find data structure. The core of the problem is to maintain and query connectivity information as elements (grid cells) are added.\n\n**1. Theoretical Foundation: Dynamic Connectivity and Equivalence Relations**\n\nThe concept of \"islands\" or connected components of land cells is based on an equivalence relation. Two land cells are in the same component if there exists a path of adjacent land cells (under $4$-neighborhood adjacency) connecting them. The DSU data structure is explicitly designed to manage the partitions of a set induced by such an equivalence relation.\n\nA DSU structure on a universe of $N$ elements maintains a collection of disjoint sets. It primarily supports two operations:\n-   `find(x)`: Determines the canonical representative (or \"root\") of the set containing element $x$.\n-   `union(x,y)`: Merges the two sets containing elements $x$ and $y$.\n\nTo achieve near-constant time complexity on an amortized basis, two heuristics are crucial:\n-   **Union-by-Size**: When merging two sets, the root of the smaller set (in terms of the number of elements) is made a child of the root of the larger set. This keeps the trees representing the sets from becoming excessively deep.\n-   **Path Compression**: During a `find(x)` operation, every node on the path from $x$ to its root is made a direct child of the root. This flattens the tree structure, dramatically speeding up future `find` operations for elements in that path.\n\nWhen both heuristics are used, a sequence of $m$ operations on a set of $N$ elements takes $O(m \\cdot \\alpha(N))$ time, where $\\alpha(N)$ is the extremely slow-growing inverse Ackermann function. For all practical purposes, $\\alpha(N)$ is a small constant (less than $5$).\n\n**2. Algorithmic Model**\n\nTo apply the DSU data structure to the grid problem, we must map the grid cells to the elements of the DSU's universe.\n\n-   **Universe Mapping**: A grid of dimensions $r \\times c$ contains $r \\cdot c$ cells. We can map each cell at coordinates $(i,j)$, where $i \\in \\{0, \\dots, r-1\\}$ and $j \\in \\{0, \\dots, c-1\\}$, to a unique integer index. A standard row-major mapping is given by the formula: $\\text{index} = i \\cdot c + j$. This creates a universe of elements $\\{0, 1, \\dots, r \\cdot c - 1\\}$.\n\n-   **State Representation**: We need to manage the state of each cell (water or land) and the DSU data. A `parent` array of size $r \\cdot c$ is used for the DSU. We can use a sentinel value, such as $-1$, to indicate that a cell is water. When a cell at index `idx` becomes land, we initialize its DSU entry, e.g., by setting `parent[idx] = idx`. A `size` array of the same dimension stores the size of each set, which is only meaningful at the set's root.\n\n-   **Component Counting**: The number of islands is precisely the number of disjoint sets of land cells. We maintain a counter, `num_components`.\n    -   When a water cell is turned into land, it initially forms a new island of size $1$. Thus, we increment `num_components`.\n    -   When we perform a `union` operation on two cells that belong to different sets, their respective islands merge. This reduces the total number of islands by one. Therefore, we decrement `num_components` for each successful merge.\n\n**3. Step-by-Step Algorithm**\n\nFor each test case with parameters $(r, c, \\text{additions})$:\n\n1.  **Initialization**:\n    -   If $r=0$ or $c=0$, the grid has no cells. The result is an empty list.\n    -   Create a `parent` array of size $r \\cdot c$, and initialize all its elements to $-1$ to represent water.\n    -   Create a `size` array of size $r \\cdot c$, initialized to $1$.\n    -   Initialize `num_components` to $0$.\n    -   Initialize an empty list `results` to store the island count after each step.\n\n2.  **Process Additions**: Iterate through each coordinate pair $(i_t, j_t)$ in the `additions` list for $t=1, \\dots, k$.\n    a.  Calculate the $1$D index: $\\text{idx}_t = i_t \\cdot c + j_t$.\n    b.  **Check for existing land**: If `parent[idx_t]` is not $-1$, the cell is already land. The number of islands does not change. Append the current `num_components` to the `results` list and proceed to the next addition.\n    c.  **Add new land**: If `parent[idx_t]` is $-1$:\n        i.  Initialize the cell as a new component: set `parent[idx_t] = idx_t`.\n        ii. Increment `num_components` by $1$.\n        iii. **Check Neighbors**: For each of the $4$ neighbors $(n_i, n_j)$ of $(i_t, j_t)$:\n            -   Verify that the neighbor's coordinates are within the grid boundaries ($0 \\le n_i  r$ and $0 \\le n_j  c$).\n            -   Calculate the neighbor's index: $\\text{n_idx} = n_i \\cdot c + n_j$.\n            -   If the neighbor is land (i.e., `parent[n_idx] != -1`), perform a `union` operation on $\\text{idx}_t$ and $\\text{n_idx}$.\n            -   The `union` operation involves finding the roots of both elements using `find` with path compression. Let the roots be `root1` and `root2`.\n            -   If $root1 \\neq root2$, a merge occurs. Implement union-by-size: attach the smaller tree to the root of the larger tree and update the size of the larger tree's root. Critically, decrement `num_components` by $1$.\n    d.  After checking all neighbors, append the final `num_components` value for the current step $t$ to the `results` list.\n\n3.  **Final Result**: After processing all additions, the `results` list contains the required sequence of island counts.\n\n**4. Complexity Analysis**\n\n-   **Time Complexity**: $O(k \\cdot \\alpha(r \\cdot c))$, where $k$ is the number of additions. Each addition involves a constant number of DSU operations (one initialization and up to four `union` operations, each with two `find` calls).\n-   **Space Complexity**: $O(r \\cdot c)$ to store the `parent` and `size` arrays for the DSU structure.\n\nThis approach is highly efficient and correctly models the dynamic process of island formation.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation on the provided test suite.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (3, 3, [(0, 0), (0, 1), (1, 2), (2, 1), (1, 1)]),\n        (1, 1, [(0, 0), (0, 0), (0, 0)]),\n        (2, 2, [(0, 0), (1, 1), (0, 1), (1, 0)]),\n        (2, 3, [(0, 0), (1, 1), (0, 2), (1, 2)]),\n        (5, 5, []),\n    ]\n\n    all_results = []\n    for r, c, additions in test_cases:\n        result = _calculate_islands(r, c, additions)\n        all_results.append(result)\n\n    # Format the final output string as specified.\n    # Each case result, being a list, is converted to a string representation\n    # without spaces, e.g., \"[1,2,3]\".\n    # These strings are then joined by commas and enclosed in an outer bracket.\n    formatted_case_results = [f\"[{','.join(map(str, res))}]\" for res in all_results]\n    final_output_string = f\"[{','.join(formatted_case_results)}]\"\n    \n    print(final_output_string)\n\n\ndef _calculate_islands(r, c, additions):\n    \"\"\"\n    Calculates the number of islands after each addition for a single test case.\n    \n    This function implements the Disjoint-Set Union (DSU) data structure with\n    path compression and union-by-size heuristics to solve the dynamic\n    connectivity problem.\n    \"\"\"\n    if r = 0 or c = 0:\n        return []\n\n    num_cells = r * c\n    # The `parent` array serves dual purposes:\n    # 1. For the DSU structure, parent[i] stores the parent of element i.\n    # 2. A value of -1 indicates the cell is water.\n    parent = np.full(num_cells, -1, dtype=int)\n    \n    # The `size` array stores the size of the set for each root element.\n    # It is initialized to 1s, as each new land cell starts as a set of size 1.\n    size = np.ones(num_cells, dtype=int)\n    \n    num_components = 0\n    results_for_case = []\n\n    # The `find` operation with path compression.\n    # It is defined as a nested function to have access to the `parent` array.\n    def find(i):\n        if parent[i] == i:\n            return i\n        # Path compression: set the parent of i directly to the root.\n        parent[i] = find(parent[i])\n        return parent[i]\n\n    for row, col in additions:\n        idx = row * c + col\n\n        # If the cell is already land, the number of components does not change.\n        if parent[idx] != -1:\n            results_for_case.append(num_components)\n            continue\n\n        # A new land cell is added, so it initially forms a new island.\n        parent[idx] = idx\n        num_components += 1\n        \n        # Check the 4-directional neighbors.\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            n_row, n_col = row + dr, col + dc\n\n            # Check if the neighbor is within a valid grid range.\n            if 0 = n_row  r and 0 = n_col  c:\n                n_idx = n_row * c + n_col\n                \n                # If the neighbor is also land, attempt to union the two components.\n                if parent[n_idx] != -1:\n                    root1 = find(idx)\n                    root2 = find(n_idx)\n                    \n                    if root1 != root2:\n                        # Union-by-size: attach the smaller tree to the root of the larger tree.\n                        if size[root1]  size[root2]:\n                            root1, root2 = root2, root1\n                        \n                        parent[root2] = root1\n                        size[root1] += size[root2]\n                        \n                        # Merging two components reduces the island count by one.\n                        num_components -= 1\n        \n        results_for_case.append(num_components)\n        \n    return results_for_case\n\nsolve()\n```"
        },
        {
            "introduction": "Moving beyond simple connectivity, this practice demonstrates the power of augmenting the DSU data structure to solve more complex graph problems. You will enhance a standard DSU to dynamically check if a graph remains bipartite as edges are added, a property equivalent to detecting odd-length cycles. By tracking the parity of the path length from each node to its root, you will learn how to embed additional relational information within the DSU forest to answer sophisticated queries. ",
            "id": "3228343",
            "problem": "You are asked to design and implement an augmented Disjoint-Set Union (DSU) data structure to dynamically enforce a two-coloring constraint during edge insertions, thereby detecting whether a graph remains bipartite as edges are added.\n\nA Disjoint-Set Union (DSU), also known as Union-Find, maintains a partition of a set into disjoint subsets under two operations: find and union. The find operation locates the representative (root) of the subset containing a given element, and the union operation merges two subsets. When enhanced with two heuristics—path compression and union by size or rank—the amortized complexity per operation becomes near-constant.\n\nFundamental base:\n- A graph is bipartite if and only if its vertices can be colored with two colors so that every edge connects vertices of different colors. Equivalently, a graph is bipartite if and only if it contains no cycle of odd length.\n- The DSU maintains disjoint components under edge additions. To use DSU for bipartiteness under dynamics composed of only edge insertions, augment each node with a parity bit that stores the parity (modulo $2$) of the length of the path from the node to its current DSU root. This parity can be interpreted as the node’s color relative to the root.\n- The two DSU heuristics are:\n  - Path compression: update parents along the path to the root to point directly to the root to flatten the DSU trees.\n  - Union by size (or rank): attach the smaller tree under the root of the larger tree to keep trees shallow.\n\nYour task:\n- For each test case, you will be given a number of vertices $n$ and a list of undirected edges $(u, v)$ added one by one to an initially edgeless graph with vertex set $\\{1,2,\\dots,n\\}$.\n- You must determine the earliest edge index $i$ (using $1$-based indexing for the edge sequence) at which the graph becomes non-bipartite, assuming that before inserting edge $i$ the graph was bipartite. If the graph remains bipartite after all insertions, return $0$.\n\nPrecise definitions and constraints:\n- Let $G = (V, E)$ be a simple undirected graph, except that self-loops are allowed in the input for testing purposes. A self-loop $(u, u)$ renders the graph non-bipartite immediately.\n- Maintain a DSU with arrays storing for each node $x$: a parent pointer and a parity bit, `parity[x]`, that equals the parity (modulo $2$) of the length of the unique path from $x$ to $\\operatorname{root}(x)$ in the current DSU forest. Under path compression, update `parity[x]` so that it remains the parity from $x$ to the new parent after compression.\n- When inserting an edge $(u, v)$:\n  - If $\\operatorname{root}(u) \\ne \\operatorname{root}(v)$, merge the two sets using union by size, and set the parity of the attached root so that the parity constraint that $u$ and $v$ have opposite colors is preserved.\n  - If $\\operatorname{root}(u) = \\operatorname{root}(v)$, check whether the current parities imply that $u$ and $v$ are of opposite colors. If not, then an odd cycle is detected and the graph becomes non-bipartite at this insertion.\n\nRequired output for each test case:\n- An integer equal to the earliest violating edge index $i$ (with $1$-based indexing), or $0$ if no violation occurs.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with no spaces, in the order of the test cases, for example: \"[x,y,z]\".\n\nTest suite:\n- For each item below, $n$ is the number of vertices, followed by the sequence of edges added in order. You must output one integer per item, as specified above.\n  - Test case $1$: $n = 5$, edges $[(1,2),(3,4),(2,3),(4,5)]$.\n  - Test case $2$: $n = 4$, edges $[(1,2),(2,3),(3,4),(4,1)]$.\n  - Test case $3$: $n = 3$, edges $[(1,2),(2,3),(1,3)]$.\n  - Test case $4$: $n = 3$, edges $[(1,1)]$.\n  - Test case $5$: $n = 6$, edges $[(1,2),(2,3),(3,1),(4,5),(5,6)]$.\n  - Test case $6$: $n = 7$, edges $[(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(1,7)]$.\n  - Test case $7$: $n = 5$, edges $[]$.\n\nYour program must be a complete, runnable implementation that constructs the described DSU with union by size and path compression, processes each test case, and prints a single line with the results as described above. No user input should be read; all data should be embedded in the program.",
            "solution": "The problem requires designing an augmented Disjoint-Set Union (DSU) data structure to determine, for a sequence of edge insertions into an initially edgeless graph, the first edge that renders the graph non-bipartite.\n\nA graph is bipartite if and only if it contains no cycles of odd length. The task is to detect the formation of the first odd-length cycle as edges are added. A DSU is well-suited for tracking connected components. The augmentation involves storing extra information to check the odd cycle condition.\n\nThe core idea is to maintain a 2-coloring of the graph's components. For each component, we can assign a color (say, $0$ or $1$) to each vertex such that adjacent vertices have different colors. This is equivalent to maintaining the parity of the path length between any two nodes in a component. We augment each node $x$ in the DSU structure with a value, which we denote as a parity bit, representing its color relative to the root of its component.\n\nLet $c(x)$ be the color of vertex $x$, with $c(x) \\in \\{0, 1\\}$. For any edge $(u,v)$, we must have $c(u) \\neq c(v)$. This is equivalent to $(c(u) + c(v)) \\pmod 2 = 1$. In our DSU, we do not store absolute colors, but rather the parity of the distance from a node to its parent in the DSU tree. Let this be `parity[x]`. This value represents $c(x) \\oplus c(\\text{parent}[x])$, where $\\oplus$ is the XOR operation, equivalent to addition modulo $2$.\n\nThe DSU will be implemented with path compression and union by size for efficiency. The logic for the augmented operations is as follows:\n\n**State Representation:**\nFor a graph with $n$ vertices, we use three arrays of size $n+1$ to accommodate $1$-based vertex indexing:\n- $\\text{parent}[i]$: Stores the parent of node $i$. The root of a set is a node $r$ where $\\text{parent}[r] = r$.\n- $\\text{size}[i]$: Stores the number of elements in the set if $i$ is a root.\n- $\\text{parity}[i]$: Stores the parity of the path length from node $i$ to its parent, i.e., $c(i) \\oplus c(\\text{parent}[i])$.\n\n**Initialization:**\nFor each vertex $i \\in \\{1, \\dots, n\\}$:\n- $\\text{parent}[i] = i$.\n- $\\text{size}[i] = 1$.\n- $\\text{parity}[i] = 0$, since the distance from a node to itself is $0$.\n\n**Find Operation with Path Compression:**\nThe `find(i)` operation returns the root of the component containing $i$, and also the parity of the path length from $i$ to this root. This path parity is $c(i) \\oplus c(\\text{root}(i))$.\n\nLet's define `find(i)` to return a pair $(\\text{root}, d)$, where $d = c(i) \\oplus c(\\text{root})$.\nIf $i$ is a root ($\\text{parent}[i] = i$), then the path length is $0$, so we return $(i, 0)$.\nOtherwise, we recursively call `find` on its parent: $(\\text{root}, d_{\\text{parent}}) = \\text{find}(\\text{parent}[i])$.\nHere, $d_{\\text{parent}} = c(\\text{parent}[i]) \\oplus c(\\text{root})$.\nThe total parity from $i$ to the root is:\n$$d = (c(i) \\oplus c(\\text{parent}[i])) \\oplus (c(\\text{parent}[i]) \\oplus c(\\text{root})) = \\text{parity}[i] \\oplus d_{\\text{parent}}$$\nDuring path compression, we set $\\text{parent}[i] = \\text{root}$. The value $\\text{parity}[i]$ must be updated to reflect this new parent-child relationship. The new $\\text{parity}[i]$ becomes the total path parity $d$ we just computed.\n\n**Union Operation and Bipartiteness Check:**\nWhen considering adding an edge $(u, v)$:\n1. First, we find the roots and path parities for $u$ and $v$:\n   - $(\\text{root}_u, d_u) = \\text{find}(u)$\n   - $(\\text{root}_v, d_v) = \\text{find}(v)$\n   where $d_u = c(u) \\oplus c(\\text{root}_u)$ and $d_v = c(v) \\oplus c(\\text{root}_v)$.\n\n2. If $\\text{root}_u = \\text{root}_v$, the vertices $u$ and $v$ are already in the same connected component. Adding the edge $(u, v)$ creates a cycle. The graph remains bipartite if and only if this new cycle has even length. This means the path between $u$ and $v$ within the component must have odd length.\n   The colors of $u$ and $v$ relative to their common root are given by their path parities.\n   $c(u) = c(\\text{root}_u) \\oplus d_u$\n   $c(v) = c(\\text{root}_u) \\oplus d_v$\n   The condition for bipartiteness is $c(u) \\neq c(v)$, which implies $c(\\text{root}_u) \\oplus d_u \\neq c(\\text{root}_u) \\oplus d_v$, simplifying to $d_u \\neq d_v$. If we find that $d_u = d_v$, an odd cycle is formed, and the graph becomes non-bipartite. This is a conflict.\n\n3. If $\\text{root}_u \\neq \\text{root}_v$, the vertices are in different components. Adding the edge $(u, v)$ merges these components. The graph remains bipartite. We perform a union operation (by size) and update the parity information.\n   Let's say we attach $\\text{root}_v$'s tree to $\\text{root}_u$'s tree, making $\\text{parent}[\\text{root}_v] = \\text{root}_u$. We must define the new $\\text{parity}[\\text{root}_v]$, which is $c(\\text{root}_v) \\oplus c(\\text{root}_u)$.\n   The edge constraint $c(u) \\neq c(v)$ must hold. Substituting the relations from the `find` operation:\n   $c(\\text{root}_u) \\oplus d_u \\neq c(\\text{root}_v) \\oplus d_v$\n   Rearranging with XOR properties gives:\n   $c(\\text{root}_u) \\oplus c(\\text{root}_v) \\neq d_u \\oplus d_v$\n   The left side is exactly the quantity we need to set for $\\text{parity}[\\text{root}_v]$. For the inequality to hold, we must set $\\text{parity}[\\text{root}_v] = d_u \\oplus d_v \\oplus 1$. In modulo $2$ arithmetic, this is $(d_u + d_v + 1) \\pmod 2$.\n\nBy applying this logic for each edge in sequence, we can find the index of the first edge that introduces a conflict. If no conflicts arise after all edges are processed, the graph remains bipartite, and the answer is $0$. A self-loop $(u, u)$ is handled correctly by this logic: `find(u)` is called twice, returning identical roots and parities, leading to an immediate conflict since $d_u=d_u$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass DSU:\n    \"\"\"\n    An augmented Disjoint-Set Union (DSU) data structure.\n    It supports union by size, path compression, and tracks parity\n    to check for bipartiteness in a dynamic graph.\n    \"\"\"\n    def __init__(self, n):\n        # Vertices are 1-indexed, so we use size n+1\n        self.parent = list(range(n + 1))\n        # self.parity[i] stores the parity of the distance from i to its parent.\n        # This represents color(i) XOR color(parent(i)).\n        self.parity = [0] * (n + 1)\n        self.size = [1] * (n + 1)\n\n    def find(self, i):\n        \"\"\"\n        Finds the root of the set containing i, with path compression and parity update.\n        Returns a tuple (root, parity), where parity is the parity of the path from i to the root.\n        \"\"\"\n        if self.parent[i] == i:\n            return i, 0\n\n        # Recursively find the root of the parent\n        root, parent_parity = self.find(self.parent[i])\n\n        # Path compression: point i's parent directly to the root\n        self.parent[i] = root\n        \n        # Update parity: The new parity from i to the root is the XOR sum\n        # of parities along the old path: parity(i-parent) ^ parity(parent-root).\n        self.parity[i] = (self.parity[i] + parent_parity) % 2\n        \n        return self.parent[i], self.parity[i]\n\n    def union(self, i, j):\n        \"\"\"\n        Merges the sets containing i and j.\n        Returns True if the merge is consistent with bipartiteness, False otherwise.\n        A return value of False indicates that adding the edge (i,j) creates an odd cycle.\n        \"\"\"\n        root_i, parity_i = self.find(i)\n        root_j, parity_j = self.find(j)\n\n        if root_i != root_j:\n            # Union by size: attach smaller tree to the root of the larger tree\n            if self.size[root_i]  self.size[root_j]:\n                root_i, root_j = root_j, root_i # Ensure root_i is the larger set's root\n\n            self.parent[root_j] = root_i\n            self.size[root_i] += self.size[root_j]\n            \n            # Update parity of the attached root (root_j).\n            # The edge (i, j) requires color(i) != color(j).\n            # path_parity(i-root_i) = parity_i, path_parity(j-root_j) = parity_j.\n            # color(i) and color(j) must differ. Relative to root_i after merge:\n            # color_rel(i) = parity_i\n            # color_rel(j) = path_parity(j-root_j-root_i) = parity_j ^ parity(root_j-root_i)\n            # So, parity_i != parity_j ^ parity(root_j-root_i)\n            # which implies parity(root_j-root_i) = parity_i ^ parity_j ^ 1.\n            self.parity[root_j] = (parity_i + parity_j + 1) % 2\n            \n            return True\n        else:\n            # i and j are already in the same component.\n            # A conflict (odd cycle) occurs if they have the same relative color.\n            # This happens if their path parities to the common root are the same.\n            if parity_i == parity_j:\n                return False # Conflict detected\n            else:\n                return True # Consistent with existing coloring\n\ndef solve_case(n, edges):\n    \"\"\"\n    Processes a single test case to find the first edge that makes the graph non-bipartite.\n    \"\"\"\n    dsu = DSU(n)\n    for i, edge in enumerate(edges):\n        u, v = edge\n        if not dsu.union(u, v):\n            return i + 1  # Return 1-based index of the violating edge\n    return 0 # No violations found\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final output.\n    \"\"\"\n    test_cases = [\n        (5, [(1, 2), (3, 4), (2, 3), (4, 5)]),\n        (4, [(1, 2), (2, 3), (3, 4), (4, 1)]),\n        (3, [(1, 2), (2, 3), (1, 3)]),\n        (3, [(1, 1)]),\n        (6, [(1, 2), (2, 3), (3, 1), (4, 5), (5, 6)]),\n        (7, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (1, 7)]),\n        (5, []),\n    ]\n\n    results = []\n    for n, edges in test_cases:\n        result = solve_case(n, edges)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "This advanced exercise illustrates how the DSU can serve as a powerful engine within a larger algorithmic framework like Kruskal's algorithm for finding a Minimum Spanning Tree (MST). Your task is not just to build the MST, but to augment the process to answer queries about the maximum edge weight on any path within that MST. This is achieved by building a \"reconstruction tree\" based on the sequence of merges performed by the DSU, demonstrating how the operational history of the DSU can be leveraged to solve complex path-based queries efficiently. ",
            "id": "3228322",
            "problem": "You are given an undirected, weighted graph on $n$ labeled vertices with integer edge weights. The task is to compute a Minimum Spanning Tree (MST) using Kruskal’s algorithm grounded on Disjoint-Set Union (DSU) with union-by-rank and path-compression heuristics, and to augment this process to answer, for any pair of vertices $(u,v)$, the maximum edge weight on the unique path between $u$ and $v$ in the resulting MST. If $u$ and $v$ are not connected in the minimum spanning forest (i.e., the graph is disconnected), the query should return $-1$. If $u=v$, the query should return $0$.\n\nThe fundamental base for this problem is the definition and properties of Disjoint-Set Union (DSU), Kruskal’s algorithm, and the cut property of Minimum Spanning Trees. The cut property states that for any partition of the vertices into two nonempty sets, the minimum-weight edge crossing the cut that connects the two sets is included in every MST. Kruskal’s algorithm maintains a forest of components and repeatedly adds the minimum-weight edge that connects two different components until a spanning forest is formed. DSU supports efficient component membership and merging with union-by-rank and path-compression heuristics to ensure near-linear time complexity.\n\nYou must design the augmentation so that queries for the maximum edge weight on the MST path between $u$ and $v$ can be answered in $O(\\log n)$ per query after an $O(n \\log n)$ preprocessing. The augmentation should be logically derived from these foundations without relying on unproven shortcuts.\n\nYour program must implement the complete pipeline:\n- Construct the MST using Kruskal’s algorithm on top of Disjoint-Set Union (DSU) with union-by-rank and path-compression heuristics.\n- During the construction, build an auxiliary tree structure that enables answering maximum edge queries on MST paths. The augmentation must be justified by properties of Kruskal’s algorithm and DSU, and should support subsequent queries via a principled method that reduces the path maximum query to a tree ancestor query.\n- Preprocess this auxiliary structure to enable answering queries efficiently.\n\nInput is embedded in the program as a fixed test suite. For each test case, the input consists of:\n- An integer $n$ specifying the number of vertices labeled from $0$ to $n-1$.\n- A list of weighted edges $(u,v,w)$ with integer weights $w$.\n- A list of query pairs $(u,v)$.\n\nYour program should produce a single line of output containing the results for all queries across the test cases, flattened into one comma-separated list enclosed in square brackets. Each query’s answer is an integer. If $u$ and $v$ are disconnected, return $-1$. If $u=v$, return $0$.\n\nUse the following test suite:\n- Test case $1$:\n  - $n=6$\n  - Edges: $\\{(1,2,1),(1,3,2),(3,4,2),(0,2,3),(0,1,4),(2,3,4),(3,5,5),(4,5,6)\\}$\n  - Queries: $\\{(0,5),(4,0),(2,3),(1,1),(4,5),(0,4)\\}$\n- Test case $2$:\n  - $n=6$\n  - Edges: $\\{(0,1,2),(1,2,3),(0,2,4),(3,4,1),(4,5,7),(3,5,8)\\}$\n  - Queries: $\\{(0,2),(3,5),(0,5),(1,1)\\}$\n- Test case $3$:\n  - $n=1$\n  - Edges: $\\{\\}$\n  - Queries: $\\{(0,0),(0,0)\\}$\n- Test case $4$:\n  - $n=5$\n  - Edges: $\\{(0,1,1),(1,2,2),(2,3,3),(3,4,4)\\}$\n  - Queries: $\\{(0,4),(1,3),(2,2)\\}$\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[a_1,a_2,\\dots]$). The answers must strictly correspond to the queries in the order they are listed across all test cases.",
            "solution": "This problem combines Kruskal's algorithm for MSTs with a sophisticated query mechanism. The challenge is to find the maximum weight edge on the unique path between two vertices in the MST efficiently. A naive traversal for each query would be too slow. The key is to augment the MST construction process to build an auxiliary structure that allows these queries to be answered in logarithmic time.\n\n**1. Theoretical Foundation: Kruskal's, Path Maximums, and Lowest Common Ancestors**\n\nKruskal's algorithm builds an MST by iterating through all edges sorted by weight and adding an edge if and only if it connects two previously disconnected components. This process naturally creates a hierarchy of component merges. The crucial insight is that for any two vertices $u$ and $v$, the maximum weight edge on the path between them in the MST is precisely the edge that Kruskal's algorithm added to first connect the component containing $u$ to the component containing $v$.\n\nThis hierarchical merging process can be represented by a **reconstruction tree** (also known as a Kruskal tree or merge tree). In this tree:\n- The original $n$ vertices of the graph are the leaves.\n- Each time Kruskal's algorithm merges two components using an edge of weight $w$, we create a new internal node. This node becomes the parent of the two nodes representing the components being merged, and we store the weight $w$ at this new node.\n\nWith this structure, the query for the maximum weight on the path between $u$ and $v$ transforms into a query for the **Lowest Common Ancestor (LCA)** of nodes $u$ and $v$ in the reconstruction tree. The weight stored at the `LCA(u,v)` node is the answer.\n\n**2. Algorithmic Model and Implementation**\n\nThe algorithm consists of three main phases:\n\n**Phase I: MST and Reconstruction Tree Construction**\n1. Initialize a DSU structure for the $n$ vertices, using union-by-rank and path compression.\n2. Sort all graph edges in non-decreasing order of weight.\n3. Create an array to map DSU component representatives to nodes in the reconstruction tree. Initially, vertex $i$ is its own component, so its representative maps to leaf node $i$.\n4. Iterate through the sorted edges $(u, v, w)$. For each edge:\n    - If `find(u)` and `find(v)` are different, the edge belongs to the MST.\n    - Create a new internal node in the reconstruction tree. Let its index be `p`.\n    - Set the weight of node `p` to $w$.\n    - The parents of the nodes representing the components of $u$ and $v$ are set to `p`.\n    - Perform the `union(u,v)` operation in the DSU.\n    - Update the DSU-to-tree map so the new component's representative maps to node `p`.\n\n**Phase II: LCA Preprocessing (Binary Lifting)**\nAfter the reconstruction tree (or forest, if the graph is disconnected) is built, we preprocess it for fast LCA queries.\n1.  Perform a traversal (e.g., DFS) from the root(s) of the forest to compute the depth of each node and its immediate parent.\n2.  Build a binary lifting table, `up[i][j]`, which stores the $2^j$-th ancestor of node $i$. This table can be filled in $O(N \\log N)$ time, where $N$ is the number of nodes in the reconstruction tree ($N  2n$).\n\n**Phase III: Query Processing**\nFor each query pair $(u, v)$:\n1.  If $u=v$, the path is empty, so the max weight is $0$.\n2.  Use the final state of the DSU to check if `find(u) == find(v)`. If not, they are disconnected, and the answer is $-1$.\n3.  If they are connected, use the preprocessed binary lifting table to find the LCA of $u$ and $v$ in the reconstruction tree. The answer is the weight stored at this LCA node.\n\n**3. Complexity Analysis**\n-   **Preprocessing**: Sorting the edges takes $O(|E| \\log |E|)$. Kruskal's algorithm with DSU takes $O(|E| \\alpha(n))$. Building the binary lifting tables takes $O(n \\log n)$. The total preprocessing time is dominated by edge sorting, resulting in $O(|E| \\log |E|)$, which aligns with the specified $O(n \\log n)$ for sparse graphs.\n-   **Querying**: Each LCA query using binary lifting takes $O(\\log n)$ time.",
            "answer": "```python\nimport numpy as np\nimport math\nimport sys\n\n# Increase recursion limit for deep trees in large test cases.\nsys.setrecursionlimit(200000)\n\ndef solve():\n    \"\"\"\n    Main solver function that defines test cases and prints the final result.\n    \"\"\"\n    test_cases = [\n        {\n            \"n\": 6,\n            \"edges\": [(1, 2, 1), (1, 3, 2), (3, 4, 2), (0, 2, 3), (0, 1, 4), (2, 3, 4), (3, 5, 5), (4, 5, 6)],\n            \"queries\": [(0, 5), (4, 0), (2, 3), (1, 1), (4, 5), (0, 4)]\n        },\n        {\n            \"n\": 6,\n            \"edges\": [(0, 1, 2), (1, 2, 3), (0, 2, 4), (3, 4, 1), (4, 5, 7), (3, 5, 8)],\n            \"queries\": [(0, 2), (3, 5), (0, 5), (1, 1)]\n        },\n        {\n            \"n\": 1,\n            \"edges\": [],\n            \"queries\": [(0, 0), (0, 0)]\n        },\n        {\n            \"n\": 5,\n            \"edges\": [(0, 1, 1), (1, 2, 2), (2, 3, 3), (3, 4, 4)],\n            \"queries\": [(0, 4), (1, 3), (2, 2)]\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        results = _process_case(case['n'], case['edges'], case['queries'])\n        all_results.extend(results)\n\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nclass DSU:\n    \"\"\"Disjoint-Set Union with Union-by-Rank and Path-Compression.\"\"\"\n    def __init__(self, n):\n        self.parent = np.arange(n)\n        self.rank = np.zeros(n, dtype=int)\n\n    def find(self, i):\n        if self.parent[i] == i:\n            return i\n        self.parent[i] = self.find(self.parent[i])\n        return self.parent[i]\n\n    def union(self, i, j):\n        root_i = self.find(i)\n        root_j = self.find(j)\n        if root_i != root_j:\n            if self.rank[root_i] > self.rank[root_j]:\n                self.parent[root_j] = root_i\n            else:\n                self.parent[root_i] = root_j\n                if self.rank[root_i] == self.rank[root_j]:\n                    self.rank[root_j] += 1\n            return True\n        return False\n\ndef _process_case(n, edges, queries):\n    \"\"\"\n    Solves a single test case: builds MST and reconstruction tree,\n    preprocesses for LCA, and answers all queries.\n    \"\"\"\n    if n == 0:\n        return [0] * len(queries)\n\n    # In a graph with n vertices, Kruskal's will create at most n-1 merges.\n    # Total nodes in reconstruction tree = n leaves + (n-1) internal nodes.\n    max_nodes = 2 * n -1 if n > 0 else 0\n    if max_nodes == 0: max_nodes = 1\n\n    dsu = DSU(n)\n    \n    # Sort edges by weight\n    edges.sort(key=lambda x: x[2])\n\n    # Data structures for the reconstruction tree\n    # Maps a DSU component's root to its corresponding node in the reconstruction tree\n    dsu_root_to_tree_node = np.arange(n)\n    tree_parent = np.full(max_nodes, -1, dtype=int)\n    tree_weight = np.zeros(max_nodes, dtype=int)\n    next_internal_node = n\n\n    # Phase 1: Kruskal's algorithm and reconstruction tree construction\n    for u, v, w in edges:\n        root_u = dsu.find(u)\n        root_v = dsu.find(v)\n\n        if root_u != root_v:\n            # This edge connects two different components\n            tree_node_u = dsu_root_to_tree_node[root_u]\n            tree_node_v = dsu_root_to_tree_node[root_v]\n            \n            # Perform union and get the new root of the merged component\n            # The DSU implementation details determine the new root\n            if dsu.rank[root_u] > dsu.rank[root_v]:\n                new_dsu_root = root_u\n            else:\n                new_dsu_root = root_v\n            \n            dsu.union(u, v)\n\n            # Create a new internal node for the merge\n            p = next_internal_node\n            tree_parent[tree_node_u] = p\n            tree_parent[tree_node_v] = p\n            tree_weight[p] = w\n            \n            # The new component's representative maps to this new internal node\n            dsu_root_to_tree_node[new_dsu_root] = p\n            next_internal_node += 1\n    \n    num_total_nodes = next_internal_node\n    \n    # Phase 2: Preprocessing for LCA (Binary Lifting)\n    if num_total_nodes == 0:\n        return [0 if u == v else -1 for u,v in queries]\n        \n    MAX_LOG = (num_total_nodes).bit_length()\n    up = np.full((num_total_nodes, MAX_LOG), -1, dtype=int)\n    depth = np.full(num_total_nodes, -1, dtype=int)\n    \n    # Build adjacency list from parent array for easier traversal\n    adj = [[] for _ in range(num_total_nodes)]\n    roots = []\n    for i in range(num_total_nodes):\n        if tree_parent[i] != -1:\n            adj[tree_parent[i]].append(i)\n        else:\n            roots.append(i)\n\n    # DFS from each root of the forest to compute depth and up[i][0]\n    for root in roots:\n        stack = [(root, -1, 0)] # (current_node, parent_node, current_depth)\n        while stack:\n            curr, p, d = stack.pop()\n            depth[curr] = d\n            up[curr, 0] = p if p != -1 else curr # Root's parent is itself\n            for neighbor in adj[curr]:\n                stack.append((neighbor, curr, d + 1))\n\n    # Fill the rest of the 'up' table using dynamic programming\n    for j in range(1, MAX_LOG):\n        for i in range(num_total_nodes):\n            if up[i, j-1] != -1:\n                up[i, j] = up[up[i, j-1], j-1]\n\n    # --- LCA Query Function ---\n    def get_lca(u, v):\n        if depth[u]  depth[v]:\n            u, v = v, u\n\n        # Lift u to the same depth as v\n        for j in range(MAX_LOG - 1, -1, -1):\n            if depth[u] - (1  j) >= depth[v]:\n                u = up[u, j]\n\n        if u == v:\n            return u\n\n        # Lift u and v together\n        for j in range(MAX_LOG - 1, -1, -1):\n            if up[u, j] != up[v, j]:\n                u = up[u, j]\n                v = up[v, j]\n        \n        return up[u, 0]\n\n    # Phase 3: Answer queries\n    results = []\n    for u, v in queries:\n        if u == v:\n            results.append(0)\n            continue\n            \n        if dsu.find(u) != dsu.find(v):\n            results.append(-1)\n            continue\n\n        lca_node = get_lca(u, v)\n        results.append(tree_weight[lca_node])\n\n    return results\n\nsolve()\n```"
        }
    ]
}