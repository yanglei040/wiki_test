{
    "hands_on_practices": [
        {
            "introduction": "我们已经学习了如何在单个数组中进行选择，但如果数据分布在多个已排序的集合中呢？这个练习将挑战你在不合并数组（因为合并操作效率低下）的情况下，高效地找到两个已排序数组并集中的第 $k$ 小元素。你将通过一种分治策略，在概念上的合并结构上应用二分搜索，而无需实际构建它，这是高级算法设计中的一项关键技能。",
            "id": "3257990",
            "problem": "给定两个升序排序的数组 $A$ 和 $B$，它们的大小分别为 $m$ 和 $n$。设多重集并集 $U = A \\cup B$ 保留元素的重复次数并按升序排列。对于给定的正整数 $k$（满足 $1 \\le k \\le m + n$），任务是计算 $U$ 中第 $k$ 小的元素（索引从 1 开始）。\n\n基本原理：顺序统计量定义如下。对于任何元素按非递减顺序排列的有限多重集 $S$，第 $k$ 个顺序统计量是当索引从 1 开始时，位于位置 $k$ 的元素。数组 $A$和 $B$ 本身已按非递减顺序排序，因此它们的多重集并集 $U$ 在概念上是通过合并 $A$ 和 $B$ 并保留重复次数而形成的。目标是在不显式地构建 $U$ 的情况下，计算 $U$ 的第 $k$ 个顺序统计量。\n\n要求：\n- 输入模型：您的程序不得读取任何输入。相反，它必须在内部使用下面指定的固定测试套件。\n- 输出模型：您的程序必须生成一行输出，其中包含所有测试用例的结果，格式为逗号分隔的列表，并用方括号括起来，不含空格。例如，最终输出应类似于 $[r_1,r_2,\\dots,r_t]$，其中每个 $r_i$ 是第 $i$ 个测试用例的结果。\n- 索引约定：参数 $k$ 是从 1 开始的，因此最小元素对应 $k = 1$，最大元素对应 $k = m + n$。\n- 算法约束：请使用一种基于比较的选择方法来设计计算过程，该方法利用 $A$ 和 $B$ 的有序属性。您必须仅依赖于从有序性和顺序统计量定义中推导出的逻辑不变量。概念上允许将两个完整数组显式合并为 $U$，但这不应是您为满足大型 $m$ 和 $n$ 的典型效率期望而采用的方法。\n- 有效性约束：数组可以为空，也可以包含负值、零值、正值和重复值。整数 $k$ 始终满足 $1 \\le k \\le m + n$。\n\n测试套件：\n- 案例 $1$：$A = [1,4,7,10,13]$，$B = [2,3,5,6,8,9,11,12]$，$k = 9$。\n- 案例 $2$：$A = [-5,0,2]$，$B = [-6,-1,3,4]$，$k = 1$。\n- 案例 $3$：$A = [10,20,30]$，$B = [5,15,25,35]$，$k = 7$。\n- 案例 $4$：$A = [1,1,1,2,2]$，$B = [1,2,2,3]$，$k = 5$。\n- 案例 $5$：$A = []$，$B = [10,20,30,40,50]$，$k = 3$。\n- 案例 $6$：$A = [-100,-50,0,50,100,150,200]$，$B = [1]$，$k = 4$。\n- 案例 $7$：$A = [-3,-2,-1]$，$B = [-3,-2,-1,0,0,0,1,2]$，$k = 6$。\n\n答案规范：\n- 对于每个测试用例，计算多重集并集 $U$ 中的第 $k$ 小元素，并以整数形式返回。\n- 您的程序应生成一行输出，其中包含一个逗号分隔的列表形式的结果，并用方括号括起来（例如，$[r_1,r_2,\\dots,r_7]$）。",
            "solution": "问题陈述构成了一个有效且定义明确的算法挑战。它在科学上植根于计算机科学的原理，特别是关于顺序统计量和选择算法。该问题是客观、自洽的，并且没有任何事实或逻辑上的不一致之处。所有提供的数据、约束和定义都清晰且足以确定一个唯一、可验证的解决方案。\n\n问题要求在两个升序排序的数组 $A$（大小为 $m$）和 $B$（大小为 $n$）的多重集并集中找到第 $k$ 小的元素，其中 $1 \\le k \\le m+n$。一种朴素的方法是将两个数组合并成一个大小为 $m+n$ 的单一排序数组 $U$，然后选择索引为 $k-1$ 的元素（使用从零开始的索引）。这种方法的时间复杂度为 $O(m+n)$，空间复杂度为 $O(m+n)$，对于大型数组而言效率低下。\n\n可以使用基于二分搜索的分治策略设计一种更高效的方法，其时间复杂度为 $O(\\log(\\min(m, n)))$，空间复杂度为 $O(1)$。这种方法避免了显式构造合并后的数组 $U$。\n\n核心思想是在概念上的合并数组中找到一个分割点，将其分为两部分：包含最小的 $k$ 个元素的“左半部分”，以及包含剩余 $m+n-k$ 个较大元素的“右半部分”。所求的第 $k$ 个元素就是左半部分中的最大值。\n\n合并数组中的这个分割对应于对输入数组 $A$ 和 $B$ 进行分割。假设我们从数组 $A$ 中选取前 $i$ 个元素，从数组 $B$ 中选取前 $j$ 个元素来构成左半部分。要使这个集合包含 $k$ 个最小元素，必须满足 $i+j=k$。剩余的元素 $A[i \\dots m-1]$ 和 $B[j \\dots n-1]$ 构成右半部分。\n\n为了使这个分割正确，左半部分中的每个元素都必须小于或等于右半部分中的每个元素。由于数组 $A$ 和 $B$ 已经排序，这个条件可以简化为对边界元素的两个要求：\n1. 由 $A$ 贡献给左半部分的最大元素必须小于或等于由 $B$ 贡献给右半部分的最小元素。使用从零开始的数组索引，即为 $A[i-1] \\le B[j]$。\n2. 由 $B$ 贡献给左半部分的最大元素必须小于或等于由 $A$ 贡献给右半部分的最小元素。即为 $B[j-1] \\le A[i]$。\n\n如果我们找到满足 $i+j=k$ 以及这两个不等式的整数 $i$ 和 $j$，那么这个分割就是正确的。第 $k$ 小的元素即为 $\\max(A[i-1], B[j-1])$。\n\n因此，问题简化为找到正确的 $i$ 值（即从 $A$ 中取出的元素数量）。由于 $j$ 由 $i$ 通过关系 $j=k-i$ 确定，我们可以对 $i$ 进行二分搜索。为了优化，我们可以在两个数组中较小的一个上进行搜索。不失一般性，我们假设 $m \\le n$。从 $A$ 中取出的元素数量 $i$ 的范围可以是从 $0$ 到 $m$。此外，从 $B$ 中取出的元素数量 $j=k-i$ 必须有效，即 $0 \\le j \\le n$，这意味着 $0 \\le k-i \\le n$，或 $k-n \\le i \\le k$。综合这些条件，$i$ 的有效搜索范围是 $[\\max(0, k-n), \\min(m, k)]$。\n\n二分搜索过程如下：\n设 $i$ 的搜索范围为 $[low, high]$。\n1. 选取一个候选分割 `i_A = (low + high) // 2`。\n2. 确定 $B$ 对应的分割：`i_B = k - i_A`。\n3. 确定定义分割正确性的四个边界元素：\n   - `max_left_A`：$A$ 左半部分的最大元素，$A[i_A - 1]$。如果 $i_A=0$，则为 $-\\infty$。\n   - `min_right_A`：$A$ 右半部分的最小元素，$A[i_A]$。如果 $i_A=m$，则为 $+\\infty$。\n   - `max_left_B`：$B$ 左半部分的最大元素，$B[i_B - 1]$。如果 $i_B=0$，则为 $-\\infty$。\n   - `min_right_B`：$B$ 右半部分的最小元素，$B[i_B]$。如果 $i_B=n$，则为 $+\\infty$。\n\n4. 检查分割条件：\n   - 如果 `max_left_A > min_right_B`，说明值 $A[i_A-1]$ 太大，应该属于右半部分。这意味着我们选择的 $i_A$ 太大。我们必须通过设置 `high = i_A - 1` 在前半部分搜索。\n   - 如果 `max_left_B > min_right_A`，说明值 $B[i_B-1]$ 太大。这意味着 $i_B$ 太大，并且由于 $i_A+i_B=k$，所以 $i_A$ 必定太小。我们必须通过设置 `low = i_A + 1` 在后半部分搜索。\n   - 如果 `max_left_A = min_right_B` 和 `max_left_B = min_right_A` 这两个条件都满足，则分割是正确的。第 $k$ 个元素是 $\\max(\\text{max\\_left\\_A}, \\text{max\\_left\\_B})$。\n\n当找到正确的分割点 $i_A$ 时，该算法终止，从而在 $O(\\log(\\min(m,n)))$ 时间和 $O(1)$ 空间复杂度内得到解决方案。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef find_kth_element(A, B, k):\n    \"\"\"\n    Computes the k-th smallest element in the multiset union of two sorted arrays.\n    The algorithm uses binary search on the partitions of the arrays.\n    \n    Time complexity: O(log(min(len(A), len(B))))\n    Space complexity: O(1)\n    \"\"\"\n    m, n = len(A), len(B)\n    \n    # Ensure A is the smaller array to simplify the binary search range.\n    if m > n:\n        return find_kth_element(B, A, k)\n\n    # Binary search for the correct partition in array A.\n    # i_A is the number of elements taken from A's left partition.\n    # The valid range for i_A is constrained by the array sizes and k.\n    low = max(0, k - n)\n    high = min(k, m)\n    \n    while low = high:\n        i_A = (low + high) // 2\n        i_B = k - i_A\n\n        # Get the four boundary elements.\n        # Use -inf and +inf for elements outside the array bounds.\n        max_left_A = A[i_A - 1] if i_A > 0 else float('-inf')\n        min_right_A = A[i_A] if i_A  m else float('inf')\n        \n        max_left_B = B[i_B - 1] if i_B > 0 else float('-inf')\n        min_right_B = B[i_B] if i_B  n else float('inf')\n\n        # Check if we have found the correct partition.\n        if max_left_A = min_right_B and max_left_B = min_right_A:\n            # The partition is correct, the k-th element is the maximum of the left parts.\n            return max(max_left_A, max_left_B)\n        elif max_left_A > min_right_B:\n            # The partition point in A is too far to the right. Move left.\n            high = i_A - 1\n        else: # max_left_B > min_right_A\n            # The partition point in A is too far to the left. Move right.\n            low = i_A + 1\n            \n    # This path should not be reached if inputs are valid.\n    return -1\n\ndef solve():\n    \"\"\"\n    Solves the problem for the given test suite.\n    \"\"\"\n    test_cases = [\n        # Case 1:\n        {'A': np.array([1, 4, 7, 10, 13]), 'B': np.array([2, 3, 5, 6, 8, 9, 11, 12]), 'k': 9},\n        # Case 2:\n        {'A': np.array([-5, 0, 2]), 'B': np.array([-6, -1, 3, 4]), 'k': 1},\n        # Case 3:\n        {'A': np.array([10, 20, 30]), 'B': np.array([5, 15, 25, 35]), 'k': 7},\n        # Case 4:\n        {'A': np.array([1, 1, 1, 2, 2]), 'B': np.array([1, 2, 2, 3]), 'k': 5},\n        # Case 5:\n        {'A': np.array([]), 'B': np.array([10, 20, 30, 40, 50]), 'k': 3},\n        # Case 6:\n        {'A': np.array([-100, -50, 0, 50, 100, 150, 200]), 'B': np.array([1]), 'k': 4},\n        # Case 7:\n        {'A': np.array([-3, -2, -1]), 'B': np.array([-3, -2, -1, 0, 0, 0, 1, 2]), 'k': 6},\n    ]\n\n    results = []\n    for case in test_cases:\n        A, B, k = case['A'], case['B'], case['k']\n        # The result must be an integer as per the problem's examples.\n        result = int(find_kth_element(A, B, k))\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "从一维数组转向，我们现在探索组织在二维结构中的数据。这项练习要求在一个杨氏矩阵（一种按行和列排序的矩阵）中找到第 $k$ 小的元素。你将发现一种巧妙的算法，它将值域上的二分搜索与一个聪明的线性时间计数方法相结合，从而高效地解决问题。这项练习展示了一种在结构化、多维数据中进行搜索的强大技术，该技术在数据库和计算几何等领域均有应用。",
            "id": "3257856",
            "problem": "给定一个二维数组，表示一个大小为 $m \\times n$ 的杨氏矩阵，其中每一行都按从左到右的非递减顺序排序，每一列都按从上到下的非递减顺序排序。形式上，对于所有有效的索引 $i$ 和 $j$，数组 $A$ 满足 $A[i][j] \\leq A[i][j+1]$ 和 $A[i][j] \\leq A[i+1][j]$。所有条目都是整数（以无单位整数形式表示）。您的任务是计算该数组中第 $k$ 小的元素。\n\n您必须设计一个算法，其关于维度 $m$ 和 $n$ 的最坏情况运行时间为 $O(m+n)$。您的算法的正确性必须源于顺序统计量和单调结构的基本原理。您提交的程序必须为提供的测试套件产生正确的输出。\n\n请使用以下测试套件。每个测试用例包含一个杨氏矩阵和一个值 $k$：\n- 测试用例 1：$m=4$，$n=5$，$k=7$，其中\n  $A=\\begin{bmatrix}\n  1   3   7   10   12\\\\\n  2   4   8   13   15\\\\\n  5   6   9   14   20\\\\\n  11  16  17  18  21\n  \\end{bmatrix}$。\n- 测试用例 2：$m=4$，$n=5$，$k=1$，使用的 $A$ 与测试用例 1 相同。\n- 测试用例 3：$m=4$，$n=5$，$k=20$，使用的 $A$ 与测试用例 1 相同。\n- 测试用例 4：$m=3$，$n=3$，$k=4$，其中\n  $A=\\begin{bmatrix}\n  1   2  2\\\\\n  2   3  5\\\\\n  2   5  8\n  \\end{bmatrix}$。\n- 测试用例 5：$m=1$，$n=6$，$k=4$，其中\n  $A=\\begin{bmatrix}\n  3   5  7  11  13  19\n  \\end{bmatrix}$。\n- 测试用例 6：$m=5$，$n=1$，$k=3$，其中\n  $A=\\begin{bmatrix}\n  -10\\\\\n  -3\\\\\n  0\\\\\n  7\\\\\n  100\n  \\end{bmatrix}$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，例如 $[r_1,r_2,r_3,r_4,r_5,r_6]$，其中 $r_i$ 是测试用例 $i$ 的整数答案。\n\n不涉及物理单位或角度单位；答案是纯整数。所有计算都是纯粹组合和数值的。\n\n您的解决方案的逻辑必须源于顺序统计量和单调矩阵的基本定义和性质，并且不得依赖于未指定的启发式方法或经验性捷径。算法设计应具有通用性，并对任何满足 $1 \\leq k \\leq m\\cdot n$ 的有效 $m$、$n$ 和 $k$ 都是正确的。",
            "solution": "该问题经评估为有效问题。这是一个在计算机科学领域内定义明确的算法挑战，基于有序矩阵的既定属性。问题陈述是形式化、客观且自洽的。\n\n任务是在一个 $m \\times n$ 的矩阵（称为杨氏矩阵）中找到第 $k$ 小的元素，该矩阵的行和列都按非递减顺序排序。要求的最坏情况时间复杂度为 $O(m+n)$。\n\n一个朴素的解决方案是将矩阵展平为单个数组，然后使用排序算法找到第 $k$ 个元素，这至少需要 $O(mn \\log(mn))$ 的时间。对展平后的数组使用类似中位数的中位数这样的线性时间选择算法需要 $O(mn)$ 的时间。这两种方法都太慢，因为它们不满足 $O(m+n)$ 的约束。一个基于堆的解决方案，即提取 $k$ 次最小元素，需要 $O(k \\log(\\min(m,n)))$ 的时间，在 $k$ 接近 $mn$ 的最坏情况下也太慢。\n\n指定的复杂度表明需要一种避免处理矩阵中每个元素的算法。关键在于有效地剪枝搜索空间。一种高效的方法是将对可能值范围的二分搜索与线性时间计数过程相结合。\n\n设第 $k$ 小的元素为 $v^*$。根据顺序统计量的定义，$v^*$ 是满足矩阵中小于或等于 $v$ 的元素数量至少为 $k$ 的最小整数值。这个单调属性允许我们使用二分搜索来找到 $v^*$。\n\n值 $v^*$ 的搜索空间是矩阵中值的范围，其下界为最小元素 $A[0][0]$，上界为最大元素 $A[m-1][n-1]$。设此范围为 $[L, R]$。\n\n二分搜索过程如下：\n1.  初始化搜索范围：$L = A[0][0]$ 和 $R = A[m-1][n-1]$。答案初始化为循环逻辑之外的值，或由循环的终止条件处理。\n2.  当 $L \\le R$ 时：\n    a. 选择一个枢轴值 $p = L + \\lfloor(R - L) / 2\\rfloor$。\n    b. 计算矩阵中小于或等于 $p$ 的元素数量。设此为 `count`。此计数步骤必须高效。\n    c. 如果 `count  k`，这意味着 $p$ 太小，$v^*$ 必须大于 $p$。我们将搜索空间调整为 $[p+1, R]$。\n    d. 如果 `count >= k`，这意味着 $p$ 可能就是 $v^*$，或者 $v^*$ 可能是一个更小的值。我们将 $p$ 记录为答案的候选值，并通过将搜索空间调整为 $[L, p-1]$ 来尝试找到一个更小的有效值。\n3.  当 $L > R$ 时，二分搜索终止，最后记录的候选答案（或 $L$ 的最终值）就是所求的第 $k$ 小的元素。\n\n整个算法的效率取决于计数步骤（2.b）。我们可以设计一个函数 `count_le(p)`，它利用排序的行和列属性，在 $O(m+n)$ 时间内计算出这个数量。\n\n`count_le(p)` 算法的工作原理如下：\n1.  初始化一个计数器 `count = 0`，并从矩阵的右上角 $(r, c) = (0, n-1)$ 开始。\n2.  当指针在矩阵边界内时（$r  m$ 且 $c \\ge 0$）：\n    a. 如果当前元素 $A[r][c] \\le p$：\n       这意味着当前行 $r$ 中列 $c$ 左侧的所有元素（包括 $c$）也小于或等于 $p$，这是由于行的非递减属性。共有 $c+1$ 个这样的元素。\n       我们将 $c+1$ 加到总数 `count` 中。\n       由于我们已经考虑了这些元素，并且后续行中的任何元素也可能 $\\le p$，我们向下移动到下一行：$r \\leftarrow r+1$。\n    b. 如果当前元素 $A[r][c] > p$：\n       这意味着 $A[r][c]$ 及其在同一列 $c$ 下方的所有元素都大于 $p$，这是由于列的非递减属性。因此，我们可以从进一步的考虑中丢弃这整列。\n       我们向左移动到前一列：$c \\leftarrow c-1$。\n3.  当 $r$ 越过最后一行或 $c$ 越过第一列时，过程终止。总步数最多为 $m+n-1$，因为每一步中 $r$ 增加或 $c$ 减少。因此，时间复杂度为 $O(m+n)$。\n\n该解决方案的总体时间复杂度是计数函数的成本乘以二分搜索的迭代次数。迭代次数为 $O(\\log(A[m-1][n-1] - A[0][0]))$。在理论上，如果整数值可以任意大，这并不严格等于 $O(m+n)$。然而，在任何实际实现中，整数都有固定的位宽（例如，$64$ 位）。对于这种情况，值域的对数是一个常数（例如，$64$），因此复杂度变为 $O((m+n) \\cdot \\text{const}) = O(m+n)$，满足了问题的要求。对于需要实现的算法问题，这种解释是标准的。另一种复杂度严格独立于值域的算法（如 Frederickson-Johnson 算法）实现起来要复杂得多。\n\n最终的算法如下：\n定义 `find_kth(A, m, n, k)`:\n  $L \\leftarrow A[0][0], R \\leftarrow A[m-1][n-1]$\n  `ans` $\\leftarrow R$\n  当 $L \\le R$ 时:\n    $p \\leftarrow L + \\lfloor(R - L) / 2\\rfloor$\n    `count` $\\leftarrow$ `count_le(A, m, n, p)`\n    如果 `count  k`:\n      $L \\leftarrow p + 1$\n    否则 (`count >= k`):\n      `ans` $\\leftarrow p$\n      $R \\leftarrow p - 1$\n  返回 `ans`\n结束\n其中 `count_le(A, m, n, p)` 是上述的 $O(m+n)$ 计数函数。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the k-th smallest element in a Young tableau problem for the given test suite.\n    \"\"\"\n\n    def count_le(matrix, m, n, value):\n        \"\"\"\n        Counts the number of elements in the matrix less than or equal to `value`.\n        This function has a time complexity of O(m+n).\n        It starts from the top-right corner and traverses towards the bottom-left.\n\n        Args:\n            matrix (np.ndarray): The m x n Young tableau.\n            m (int): Number of rows.\n            n (int): Number of columns.\n            value (int): The value to compare against.\n\n        Returns:\n            int: The number of elements = value.\n        \"\"\"\n        count = 0\n        row, col = 0, n - 1\n        while row  m and col >= 0:\n            if matrix[row][col] = value:\n                # If the current element is = value, all elements in its row\n                # to its left are also = value. There are (col + 1) such elements.\n                count += (col + 1)\n                # Move to the next row.\n                row += 1\n            else:\n                # If the current element is > value, it and all elements\n                # below it are > value. So, we can discard this column.\n                col -= 1\n        return count\n\n    def find_kth_smallest(matrix, k):\n        \"\"\"\n        Finds the k-th smallest element in a Young tableau.\n        The algorithm uses binary search on the range of values in the matrix.\n        For each value, it counts how many elements are less than or equal to it\n        in O(m+n) time.\n\n        The overall complexity is O((m+n) * log(value_range)). Assuming fixed-width\n        integers (e.g., 64-bit), log(value_range) is a constant, leading to an\n        effective complexity of O(m+n).\n\n        Args:\n            matrix (np.ndarray): The m x n Young tableau.\n            k (int): The rank of the element to find (1-based).\n\n        Returns:\n            int: The k-th smallest element.\n        \"\"\"\n        m, n = matrix.shape\n        low = matrix[0, 0]\n        high = matrix[m - 1, n - 1]\n        \n        # The k-th smallest element v is the smallest number such that\n        # count_le(v) >= k. We binary search for this v.\n        ans = high\n        while low = high:\n            mid = low + (high - low) // 2\n            count = count_le(matrix, m, n, mid)\n            \n            if count  k:\n                # mid is too small, the answer must be larger.\n                low = mid + 1\n            else:\n                # mid is a potential answer. Try to find a smaller one.\n                # count >= k means mid or a smaller value could be the k-th element.\n                ans = mid\n                high = mid - 1\n        return ans\n\n    test_cases = [\n        (np.array([\n            [1, 3, 7, 10, 12],\n            [2, 4, 8, 13, 15],\n            [5, 6, 9, 14, 20],\n            [11, 16, 17, 18, 21]\n        ]), 7),\n        (np.array([\n            [1, 3, 7, 10, 12],\n            [2, 4, 8, 13, 15],\n            [5, 6, 9, 14, 20],\n            [11, 16, 17, 18, 21]\n        ]), 1),\n        (np.array([\n            [1, 3, 7, 10, 12],\n            [2, 4, 8, 13, 15],\n            [5, 6, 9, 14, 20],\n            [11, 16, 17, 18, 21]\n        ]), 20),\n        (np.array([\n            [1, 2, 2],\n            [2, 3, 5],\n            [2, 5, 8]\n        ]), 4),\n        (np.array([[3, 5, 7, 11, 13, 19]]), 4),\n        (np.array([\n            [-10],\n            [-3],\n            [0],\n            [7],\n            [100]\n        ]), 3)\n    ]\n\n    results = []\n    for matrix, k in test_cases:\n        result = find_kth_smallest(matrix, k)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "理论算法通常假设数据是理想的，但在实践中，我们会遇到像“非数字”（NaN）这样的特殊值。这个问题要求你调整选择算法，以正确处理包含浮点数 `NaN` 值的数组。关键在于首先建立一个数学上合理的“全序”关系，然后在标准的选择算法（如快速选择）中实现一个遵循此顺序的自定义比较函数。这项动手任务教授了使算法变得稳健的关键技能，通过回归基本原理来优雅地处理异常和边界情况，从而弥合了抽象理论与实际应用之间的鸿沟。",
            "id": "3257848",
            "problem": "给定一个遵循电气与电子工程师协会 (IEEE) 754 浮点标准的实数数组。其中一些元素可能是“非数字”(NaN)。您的任务是通过调整选择算法，在一个数学上明确定义的全序关系下，正确地计算存在 NaN 值时的顺序统计量。\n\n在包含 NaN 的扩展实数上定义以下全序关系：\n- 对于所有有限实数 $a,b \\in \\mathbb{R}$，使用常规顺序：$a \\le b$ 当且仅当 $b - a \\ge 0$。\n- 使用标准约定扩展至无穷大：对于所有有限的 $a$，有 $-\\infty \\le a \\le +\\infty$。\n- 将所有 NaN 值视为严格大于任何非 NaN 值。在所有 NaN 值之间，将它们视为处于顺序顶端的等价类，因此任何秩落在 NaN 块内的第 $k$ 顺序统计量都返回 NaN。\n\n形式上，对于任意浮点值 $x$，定义键映射 $\\varphi(x)$ 如下：\n$$\n\\varphi(x) = \n\\begin{cases}\n(0, x)  \\text{如果 $x$ 不是 NaN}，\\\\\n(1, 0)  \\text{如果 $x$ 是 NaN}。\n\\end{cases}\n$$\n我们对这些序对施加字典序。这引出一个全序关系，其中所有非 NaN 值按常规排序（以 $-\\infty$ 和 $+\\infty$ 为极值），而所有 NaN 值都被认为比任何非 NaN 值都大。NaN 的第二个分量是一个常数，因此永远不需要对 NaN 与 NaN 进行比较。\n\n给定一个长度为 $n$ 的数组 $A$ 和一个索引 $k$（$1 \\le k \\le n$），第 $k$ 顺序统计量被定义为数组 $A$ 中的元素 $x$，使得在上述全序关系下， $A$ 中恰好有 $k-1$ 个元素小于或等于 $x$，并且从 $A$ 中选出至少一个 $x$ 的实例（重复值通过重数处理）。如果秩 $k$ 落入 NaN 区域（即非 NaN 元素的数量少于 $k$），则答案必须是 NaN。\n\n您的任务：\n- 设计并实现一个选择算法，该算法返回由 $\\varphi$ 导出的全序关系下的第 $k$ 顺序统计量。设计应从顺序统计量的基本定义以及选择算法所依赖的划分属性开始。必须避免使用对 NaN 无效的部分比较；相反，应使用基于键的比较逻辑来精确实现该全序关系。\n- 您的算法必须在期望线性时间 $n$ 内运行，并且是原位的（最多使用常数额外空间）。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含所有测试用例的结果，格式为用方括号括起来的逗号分隔列表，无空格。对于 NaN，请打印该语言对“非数字”的规范浮点字符串表示。对于无穷大，也请打印其规范表示。\n- 示例格式：\"[1.0,2.0,nan]\"。\n\n测试套件：\n对于每个测试用例，给定一个数组 $A$ 和一个整数 $k$。计算在上述全序关系下的第 $k$ 顺序统计量。\n\n- 测试 1：$A = [3.0, \\text{NaN}, 1.0, 2.0, \\text{NaN}]$, $k = 2$。预期概念结果：排序后的顺序为 $[1.0, 2.0, 3.0, +\\infty, \\text{NaN}, \\text{NaN}]$，其中最后两个位置是 NaN；答案是 $2.0$。\n- 测试 2：$A = [\\text{NaN}, \\text{NaN}]$, $k = 1$。答案是 NaN。\n- 测试 3：$A = [5.0, -\\infty, +\\infty, \\text{NaN}, 0.0]$, $k = 3$。排序后的顺序为 $[-\\infty, 0.0, 5.0, +\\infty, \\text{NaN}]$；答案是 $5.0$。\n- 测试 4：$A = [7.0, 7.0, \\text{NaN}, -1.0]$, $k = 4$。答案是 NaN。\n- 测试 5：$A = [\\text{NaN}, 0.1]$, $k = 1$。答案是 $0.1$。\n- 测试 6：$A = [3.0, 1.0, 4.0, 1.0, 5.0, 9.0]$, $k = 5$。答案是 $5.0$。\n- 测试 7：$A = [\\text{NaN}, -2.0, -2.0, -1.0, -\\infty, +\\infty]$, $k = 1$。答案是 $-\\infty$。\n- 测试 8：$A = [2.0, \\text{NaN}, 1.0]$, $k = 2$。答案是 $2.0$。\n\n您的程序必须实现所述的选择算法，并生成单行输出，包含上述八个测试用例的结果，按顺序排列，格式为方括号内的逗号分隔列表，例如“[result1,result2,...,result8]”。每个结果必须是浮点数，可能是“nan”、“+inf”或“-inf”，具体由该语言对浮点特殊值的标准打印表示确定。不允许有任何额外输出。",
            "solution": "该问题要求计算一个包含 $n$ 个浮点数的数组 $A$ 的第 $k$ 顺序统计量，这些浮点数可能包括特殊值，如非数字 (NaN)、正无穷大 ($+\\infty$) 和负无穷大 ($-\\infty$)。问题的核心在于建立一个明确定义的全序关系，并实现一个遵循该顺序的高效选择算法。\n\n要求的算法必须以期望线性时间运行，并且是原位算法（使用常数辅助空间）。这直接指向了随机化选择算法家族，其中最著名的是 Hoare 的选择算法，通常称为 Quickselect。我们将设计一个 Quickselect 的迭代版本，以严格满足常数空间的要求。\n\n首先，我们形式化全序关系。问题定义了一个从浮点值 $x$ 到元组的映射 $\\varphi(x)$：\n$$\n\\varphi(x) = \n\\begin{cases}\n(0, x)  \\text{如果 } x \\text{ 不是 NaN},\\\\\n(1, 0)  \\text{如果 } x \\text{ 是 NaN}。\n\\end{cases}\n$$\n全序关系由这些元组上的字典序导出。对于任意两个值 $x_1$ 和 $x_2$，我们说 $x_1 \\le x_2$ 当且仅当 $\\varphi(x_1) \\le_{\\text{lex}} \\varphi(x_2)$。设 $\\varphi(x_1) = (c_1, v_1)$ 和 $\\varphi(x_2) = (c_2, v_2)$。字典序比较意味着 $\\varphi(x_1) \\le_{\\text{lex}} \\varphi(x_2)$，如果 $c_1  c_2$，或者如果 $c_1 = c_2$ 且 $v_1 \\le v_2$。\n\n这可以转化为以下比较逻辑：\n1. 如果 $x_1$ 不是 NaN ($c_1=0$) 而 $x_2$ 是 NaN ($c_2=1$)，则 $c_1  c_2$，所以 $x_1  x_2$。\n2. 如果 $x_1$ 是 NaN ($c_1=1$) 而 $x_2$ 不是 NaN ($c_2=0$)，则 $c_1 > c_2$，所以 $x_1 > x_2$。\n3. 如果两者都是 NaN，则 $c_1 = c_2 = 1$。第二个分量是常数 ($v_1=v_2=0$)，所以它们被认为是等价的。\n4. 如果两者都不是 NaN，则 $c_1 = c_2 = 0$。比较将依赖于它们值的标准数值顺序，即 $v_1=x_1$ 和 $v_2=x_2$。这能正确处理有限数以及 $-\\infty$ 和 $+\\infty$。\n\nQuickselect 算法通过递归地划分数组来工作。选择一个主元，然后重新排列数组，使得所有小于主元的元素都在它前面，所有大于主元的元素都在它后面。主元的最终位置告诉我们它的秩。如果这个秩与期望的秩 $k$ 匹配，那么主元就是答案。否则，搜索将递归地缩小到主元左侧或右侧的子数组中。\n\n为满足效率要求，我们将使用：\n- **随机化主元选择**：为实现期望 $O(n)$ 的时间复杂度并避免在近乎排序或病态输入上的最坏情况 $O(n^2)$ 性能，主元从当前子数组中随机选择。\n- **Lomuto 划分方案**：这是一个直接的划分算法。它选择一个主元（例如，子数组的最后一个元素），并维护一个索引 `store_index`。它遍历子数组，对于任何小于或等于主元的元素（根据我们的自定义全序关系），它将该元素与 `store_index` 处的元素交换，并递增 `store_index`。最后，它将主元交换到其正确的排序位置 `store_index`。此划分必须完全使用一个实现了上述全序关系的比较函数。\n- **迭代控制流**：为实现 $O(1)$ 的辅助空间，递归被一个调整所考虑子数组的 `low` 和 `high` 指针的 `while` 循环所取代。\n\n整个算法流程如下：\n1. 初始化 `low` 为 $0$，`high` 为 $n-1$。目标是秩为 $k$ 的元素，它对应于零索引排序数组中的索引 $k_{idx} = k-1$。\n2. 当 `low` $\\le$ `high` 时：\n   a. 对子数组 $A[\\text{low}..\\text{high}]$ 执行随机化划分。这包括选择一个随机元素，将其与 $A[\\text{high}]$ 交换，然后使用 $A[\\text{high}]$ 作为主元进行 Lomuto 划分。划分函数返回主元的最终索引 `pivot_index`。\n   b. 如果 `pivot_index` == $k_{idx}$，元素 $A[k_{idx}]$ 就是所求的第 $k$ 顺序统计量。返回它。\n   c. 如果 `pivot_index` $>$ $k_{idx}$，所求元素在左子数组中。更新 `high = pivot_index - 1`。\n   d. 如果 `pivot_index` $$ $k_{idx}$，所求元素在右子数组中。更新 `low = pivot_index + 1`。\n3. 当找到索引为 $k_{idx}$ 的元素时，循环终止。\n\n此设计根据指定的全序关系正确处理所有浮点值。如果秩 $k$ 大于非 NaN 元素的数量，划分过程会自然地将所有非 NaN 元素放在数组的初始部分。对 $k_{idx}$ 的搜索将接着在只包含 NaN 的右子数组中进行，算法将正确地返回一个 NaN 值并终止。这满足了问题陈述的所有要求。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport random\n\ndef solve():\n    \"\"\"\n    Solves the k-th order statistic problem for a series of test cases.\n    \"\"\"\n    \n    test_cases = [\n        ([3.0, np.nan, 1.0, 2.0, np.nan], 2),\n        ([np.nan, np.nan], 1),\n        ([5.0, -np.inf, np.inf, np.nan, 0.0], 3),\n        ([7.0, 7.0, np.nan, -1.0], 4),\n        ([np.nan, 0.1], 1),\n        ([3.0, 1.0, 4.0, 1.0, 5.0, 9.0], 5),\n        ([np.nan, -2.0, -2.0, -1.0, -np.inf, np.inf], 1),\n        ([2.0, np.nan, 1.0], 2),\n    ]\n\n    def is_le(a, b):\n        \"\"\"\n        Custom comparison function that implements the specified total order.\n        Returns True if a = b, False otherwise.\n        Order: non-NaN  NaN. NaNs are equivalent. Non-NaNs are ordered numerically.\n        \"\"\"\n        is_nan_a = np.isnan(a)\n        is_nan_b = np.isnan(b)\n\n        # Case 1: One is NaN, the other is not. The non-NaN is smaller.\n        if is_nan_a != is_nan_b:\n            return is_nan_b  # True if b is NaN, False if a is NaN\n\n        # Case 2: Both are NaN. They are equivalent, so a = b is true.\n        if is_nan_a:  # and is_nan_b must be true here.\n            return True\n\n        # Case 3: Neither is NaN. Use standard numeric comparison.\n        return a = b\n\n    def partition(arr, low, high, compare_func):\n        \"\"\"\n        Lomuto partition scheme using the custom comparison function.\n        The pivot is chosen to be the element at arr[high].\n        \"\"\"\n        pivot = arr[high]\n        i = low\n        for j in range(low, high):\n            if compare_func(arr[j], pivot):\n                arr[i], arr[j] = arr[j], arr[i]\n                i += 1\n        arr[i], arr[high] = arr[high], arr[i]\n        return i\n\n    def randomized_partition(arr, low, high, compare_func):\n        \"\"\"\n        Selects a random pivot to ensure expected linear time performance.\n        \"\"\"\n        rand_pivot_idx = random.randint(low, high)\n        arr[rand_pivot_idx], arr[high] = arr[high], arr[rand_pivot_idx]\n        return partition(arr, low, high, compare_func)\n\n    def find_kth_statistic(arr_orig, k):\n        \"\"\"\n        Finds the k-th smallest element using iterative randomized Quickselect.\n        k is 1-based.\n        \"\"\"\n        arr = list(arr_orig) # Make a copy to perform in-place operations\n        k_0based = k - 1\n        low, high = 0, len(arr) - 1\n\n        while low = high:\n            if low == high:\n                return arr[low]\n\n            pivot_index = randomized_partition(arr, low, high, is_le)\n\n            if pivot_index == k_0based:\n                return arr[k_0based]\n            elif pivot_index > k_0based:\n                high = pivot_index - 1\n            else: # pivot_index  k_0based\n                low = pivot_index + 1\n        return None # Should not be reached for valid k\n\n    results = []\n    for A, k in test_cases:\n        result = find_kth_statistic(A, k)\n        results.append(result)\n\n    # Format the final output string\n    # Python's str() correctly handles nan, inf, and -inf\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}