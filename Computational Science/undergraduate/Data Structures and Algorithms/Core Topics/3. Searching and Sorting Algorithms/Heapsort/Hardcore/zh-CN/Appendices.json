{
    "hands_on_practices": [
        {
            "introduction": "堆结构不仅能用于对单个数组进行排序，其本质上更是一个强大的优先队列。第一个练习将挑战你应用这一原理来解决一个经典的计算机科学问题：高效地合并多个已排序的数组 。通过设计这个算法，你将更深刻地理解堆如何用于管理和从动态变化的候选项中进行选择，这是许多复杂算法的基石。",
            "id": "3239740",
            "problem": "给定 $k$ 个已排序的数组 $A_1, A_2, \\dots, A_k$，总共包含 $N = \\sum_{i=1}^{k} n_i$ 个键，其中 $n_i$ 是 $A_i$ 的长度。您必须设计一个基于堆排序原理的算法，将这些数组合并成一个单一的非递减输出数组。假设一个具有堆序属性和完全二叉树形状的标准二叉堆是可用的。您的目标是从第一性原理出发，确定一种算法策略，并推导出其最坏情况下的运行时间和辅助空间（不包括输出数组的空间）。在以下选项中，选择唯一一个既正确指定了源于堆排序原理的有效算法，又在比较计算模型下实现了渐近最优运行时间，并给出了其时间和空间复杂度的选项。\n\nA. 初始化一个大小为 $k$ 的二叉最小堆，其中包含来自每个非空数组的一个键，形式为元组 $(\\text{key}, \\text{array\\_id}, \\text{index})$。重复提取最小元组，将其键追加到输出中，如果该元组来自数组 $A_j$ 且 $A_j$ 中仍有未合并的键，则插入来自 $A_j$ 的下一个元组。这会得到最坏情况时间 $\\Theta(N \\log k)$ 和辅助空间 $\\Theta(k)$。\n\nB. 将所有 $k$ 个数组连接成一个长度为 $N$ 的单一数组，并应用原地堆排序：在所有 $N$ 个键上构建一个单一的二叉堆，并重复提取极值进行排序。这会得到最坏情况时间 $\\Theta(N \\log N)$ 和辅助空间 $\\Theta(1)$。\n\nC. 在每个数组当前第一个未合并的键上维护一个大小为 $k$ 的二叉最大堆。重复提取最大值并将其追加到输出中，如果同一数组中存在下一个键，则重新插入。这会得到最坏情况时间 $\\Theta(N \\log k)$ 和辅助空间 $\\Theta(k)$。\n\nD. 对当前第一个未合并的键使用一个k叉堆，这样堆的高度为$1$；因此每次 extract-min 和 insert 操作需要 $\\Theta(1)$ 时间，总时间为 $\\Theta(N)$，辅助空间为 $\\Theta(k)$。\n\n选择唯一的正确选项。",
            "solution": "在尝试任何解决方案之前，需对问题陈述进行验证。\n\n**问题验证**\n\n**第1步：提取已知条件**\n- 有 $k$ 个已排序的数组，表示为 $A_1, A_2, \\dots, A_k$。\n- 键的总数为 $N = \\sum_{i=1}^{k} n_i$，其中 $n_i$ 是数组 $A_i$ 的长度。\n- 目标是将这些数组合并成一个单一的非递减输出数组。\n- 该算法必须基于堆排序的原理。\n- 一个具有堆序属性和完全二叉树形状的标准二叉堆是可用的。\n- 任务是确定一个有效的算法策略，推导其最坏情况运行时间和辅助空间（不包括输出数组），并选择正确指定此算法、其最优运行时间及其复杂度的选项。\n\n**第2步：使用提取的已知条件进行验证**\n这个问题是计算机科学中一个经典且明确定义的问题，称为 k 路归并。\n- **科学上成立：** 该问题基于算法和数据结构的基本概念，特别是排序、归并和优先队列（堆）。它完全没有伪科学或事实错误。\n- **良定义的：** 目标清晰：设计并分析一个高效的归并算法。在比较计算模型中存在一个唯一的、稳定的、有意义的解。\n- **客观的：** 问题使用精确、无歧义的技术语言陈述。\n\n**第3步：结论与行动**\n问题陈述是有效的。这是一个来自算法设计与分析领域的、良定义的、科学上成立的问题。我们可以继续进行解决方案的推导。\n\n**从第一性原理推导**\n\n任务是将 $k$ 个已排序的数组合并成一个单一的已排序输出数组。为了以非递减顺序构建输出数组，我们必须在所有尚未合并的键中重复识别并追加最小的元素。\n\n在归并过程的任何一步，下一个全局最小元素的候选者是来自 $k$ 个数组中每一个的当前第一个（即最小的）未合并的键。这是因为每个输入数组 $A_i$ 都已经排好序了。因此，问题的核心是高效地管理一个最多包含 $k$ 个候选键的动态集合，并从中重复提取最小值。\n\n问题要求一种“基于堆排序原理”的方法。堆排序利用堆数据结构，通过重复提取极值元素来高效地对数组进行排序。堆是一种满足堆属性的特殊树形数据结构。为了找到最小元素，**最小堆**是合适的选择。它允许高效地提取最小元素和插入新元素。\n\n让我们使用最小堆来形式化这个算法：\n1.  **初始化**：创建一个二叉最小堆。对于 $k$ 个数组中每个非空的数组 $A_i$，将其第一个键插入堆中。为了追踪每个键的来源，我们在堆中存储一个形式为 $(\\text{key}, \\text{array\\_id}, \\text{index})$ 的元组。堆中最多包含 $k$ 个元素。\n2.  **迭代**：重复以下过程直到堆为空，这将在处理完所有 $N$ 个键后发生。\n    a.  使用 `extract-min` 操作从堆中移除具有最小键的元组。设该元组为 $(v, i, j)$，其中 $v$ 是键值，$i$ 是其源数组 $A_i$ 的标识符，$j$ 是它在 $A_i$ 中的索引。\n    b.  将键 $v$ 追加到单一输出数组中。\n    c.  如果数组 $A_i$ 还有更多键（即，如果索引 $j+1$ 小于 $A_i$ 的长度 $n_i$），则将 $A_i$ 的下一个键插入堆中。这个新元组将是 $(A_i[j+1], i, j+1)$。\n\n**复杂度分析**\n-   **时间复杂度**：\n    -   初始化步骤涉及向最小堆中插入最多 $k$ 个键。对于二叉堆，每次插入需要 $O(\\log k)$ 的时间。初始化的总时间为 $O(k \\log k)$。\n    -   主循环执行 $N$ 次，总输入中的每个键执行一次。每次迭代涉及一次 `extract-min` 操作和最多一次 `insert` 操作。在一个大小最多为 $k$ 的二叉堆上，这两个操作的最坏情况时间复杂度都是 $O(\\log k)$。\n    -   因此，总的最坏情况时间复杂度为 $O(k \\log k) + N \\times O(\\log k) = O((N+k)\\log k)$。由于任何实际应用中都会有 $N \\ge k$，这可以简化为 $\\Theta(N \\log k)$。\n    -   这个运行时间在比较计算模型中是已知的渐近最优解。合并 $k$ 个列表的下界是 $\\Omega(N \\log k)$。\n\n-   **辅助空间复杂度**：\n    -   主要的辅助数据结构是最小堆。在任何时候，堆中最多存储来自 $k$ 个数组中每一个的一个键。\n    -   因此，堆的最大大小是 $k$。堆中的每个元素都是一个常数大小的小元组。\n    -   所需的辅助空间为 $\\Theta(k)$。问题陈述指明，输出数组的空间（大小为 $N$）不应计算在内。\n\n**逐项分析选项**\n\n**A. 初始化一个大小为 $k$ 的二叉最小堆，其中包含来自每个非空数组的一个键，形式为元组 $(\\text{key}, \\text{array\\_id}, \\text{index})$。重复提取最小元组，将其键追加到输出中，如果该元组来自数组 $A_j$ 且 $A_j$ 中仍有未合并的键，则插入来自 $A_j$ 的下一个元组。这会得到最坏情况时间 $\\Theta(N \\log k)$ 和辅助空间 $\\Theta(k)$。**\n\n此选项精确地描述了从第一性原理推导出的最优算法。它正确地指出了使用最小堆来管理候选元素、提取最小值并补充堆的迭代过程，以及堆中存储的数据。根据我们的分析，其所述的时间复杂度 $\\Theta(N \\log k)$ 和辅助空间复杂度 $\\Theta(k)$ 都是正确的。该算法是渐近最优的。\n**结论：正确**\n\n**B. 将所有 $k$ 个数组连接成一个长度为 $N$ 的单一数组，并应用原地堆排序：在所有 $N$ 个键上构建一个单一的二叉堆，并重复提取极值进行排序。这会得到最坏情况时间 $\\Theta(N \\log N)$ 和辅助空间 $\\Theta(1)$。**\n\n这种方法构成了一个有效的排序算法。但是，它没有利用 $k$ 个输入数组已排序的特性，而这正是*归并*问题的关键。其时间复杂度为 $\\Theta(N \\log N)$，在 $k \\ll N$ 的情况下，渐近地慢于最优的 $\\Theta(N \\log k)$。例如，如果 $k$ 是一个小常数，最优时间是 $\\Theta(N)$，而这个选项给出的是 $\\Theta(N \\log N)$。因此，它不是这个问题的渐近最优算法。此外，关于 $\\Theta(1)$ 辅助空间的说法是值得怀疑的；“连接”步骤需要一个大小为 $N$ 的辅助数组来存放合并后的元素才能开始排序，这导致 $\\Theta(N)$ 的辅助空间，而不是 $\\Theta(1)$。\n**结论：错误**\n\n**C. 在每个数组当前第一个未合并的键上维护一个大小为 $k$ 的二叉最大堆。重复提取最大值并将其追加到输出中，如果同一数组中存在下一个键，则重新插入。这会得到最坏情况时间 $\\Theta(N \\log k)$ 和辅助空间 $\\Theta(k)$。**\n\n这个选项的逻辑存在根本性缺陷。目标是生成一个“非递减”（即升序）的输出数组。要做到这一点，必须重复选择可用的*最小*键。该选项提议使用**最大堆**并提取*最大*键。这将产生一个非递增（降序）的键序列，与问题要求相矛盾。尽管基于堆的方法的复杂度分析给出了正确的数量级，但所提议的算法本身对于既定目标是错误的。\n**结论：错误**\n\n**D. 对当前第一个未合并的键使用一个k叉堆，这样堆的高度为$1$；因此每次 extract-min 和 insert 操作需要 $\\Theta(1)$ 时间，总时间为 $\\Theta(N)$，辅助空间为 $\\Theta(k)$。**\n\n这个选项在对k叉堆操作的分析中存在一个关键缺陷。一个包含 $k$ 个元素的k叉堆确实高度为 $1$（一个根和 $k-1$ 个子节点）。一个 `insert` 操作，涉及向上一层冒泡，确实需要 $O(1)$ 时间。然而，在k叉堆上的 `extract-min` 操作需要替换根节点然后将其下沉。每个节点的下沉过程涉及在其最多 $k$ 个子节点中找到最小值。在根节点层，这需要 $\\Theta(k)$ 次比较。因此，`extract-min` 操作并非花费 $\\Theta(1)$ 时间，而是 $\\Theta(k)$ 时间。最终的总时间复杂度将是 $N \\times \\Theta(k) = \\Theta(Nk)$，这明显差于使用二叉堆所能达到的 $\\Theta(N \\log k)$。操作耗时 $\\Theta(1)$ 的前提是错误的，从而使得声称的总时间 $\\Theta(N)$ 无效。\n**结论：错误**",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "在这个全面的实现挑战中，理论与实践在此交汇。你将需要改造堆排序算法，使其能够处理像字符串这样的复杂数据类型 。你不仅要从第一性原理出发实现算法，还要对其进行插桩以测量性能、分析其稳定性，并使用哈希技术验证其正确性。这项动手任务将填补抽象算法概念与软件工程实践细节之间的鸿沟。",
            "id": "3239748",
            "problem": "要求您修改堆排序算法，使其能使用字典序比较来处理字符串数据，并使用有原则的度量方法来分析其行为。此任务必须从第一性原理出发解决，仅基于核心定义和经过充分检验的事实，不得假定或使用任何专门的捷径。\n\n您可以假定的基本前提：\n- 二叉堆是一个存储在数组中的完全二叉树。对于数组索引 $i$（$0 \\le i  n$），其父节点索引为 $\\left\\lfloor \\frac{i-1}{2} \\right\\rfloor$，左子节点索引为 $2i+1$，右子节点索引为 $2i+2$。\n- 包含 $n$ 个元素的二叉堆的高度至多为 $\\left\\lfloor \\log_2 n \\right\\rfloor$。\n- 堆的下沉（sift-down）操作每次调用最多需要 $O(\\log n)$ 次比较和交换，而通过从中间到根节点逐个下沉来构建堆的总成本为 $O(n)$ 次比较和交换。\n- 使用定义了全序关系的比较器，在 Landau 符号 $O(\\cdot)$ 下，堆排序在最坏情况下的比较和交换次数为 $O(n \\log n)$。\n\n需要实现的字典序：\n- 对于字符串 $s$ 和 $t$，定义 $s \\prec t$ 当且仅当，在第一个不相同的索引 $j$ 处，$s[j]$ 的 Unicode 码点 $ord(s[j])$ 小于 $t[j]$ 的 Unicode 码点 $ord(t[j])$；如果其中一个字符串是另一个的严格前缀，则较短的字符串被视为较小。这是由 Unicode 码点诱导的标准字典序，是有限字符串上的一个全序关系。\n\n需使用的计数模型：\n- 一次字符串比较是指对两个字符串调用一次字典序比较器；每次调用计为字符串比较计数 $C^{(str)}$ 的一个单位。\n- 一次字符比较是指在两个字符串的相同位置比较两个字符的一个步骤；每次这样的位置字符检查计为字符比较计数 $C^{(char)}$ 的一个单位。如果两个字符串在较短字符串的长度范围内完全相等，仅因长度不同而不同，则最终的长度检查不计为字符比较。\n- 一次交换是指交换两个数组元素；每次数组元素交换计为交换计数 $S$ 的一个单位。\n- 当您验证属性（例如建堆阶段后的堆属性）时，不要增加 $C^{(str)}$、$C^{(char)}$ 或 $S$ 的值；这些验证步骤不得污染算法的计数。\n\n稳定性度量：\n- 众所周知，堆排序通常是不稳定的。为了根据输入凭经验测试其稳定性，请为每个字符串增补其原始索引，并使用仅检查字符串部分的比较来对偶对 $(\\text{string}, \\text{index})$ 进行排序。排序后，对于任何由相等字符串组成的最大连续块，检查其原始索引是否为非递减顺序。报告一个布尔值 $Stab$，当且仅当相等字符串的相对顺序被保留时，该值为真。\n\n排序后输出的哈希值：\n- 为避免打印字符串，同时仍能验证确切的排序顺序，请计算排序后字符串序列的多项式滚动哈希值 $H$。设 $B = 911382323$ 且 $M = 2^{64}$。初始化 $H \\gets 0$。对于排序后顺序中的每个字符串，首先处理一个分隔符值 $0$，然后将字符串中的每个字符 $c$ 作为整数 $ord(c)+1$ 处理，对于每个处理的整数 $x$，更新哈希值：\n$$\nH \\gets \\big(H \\cdot B + x\\big) \\bmod M\n$$\n分隔符 $0$ 不会与任何字符冲突，因为字符被映射为 $ord(c)+1 \\ge 1$。使用模 $M$ 的算术。\n\n程序要求：\n- 使用上述定义的字典序，实现对字符串的原地堆排序。\n- 对算法进行插桩（instrument），使其对每个输入数组返回元组 $[H, C^{(char)}, C^{(str)}, S, H^{(build)}, Stab]$，其中：\n  - $H$ 是按规定计算的排序后序列的 $64$ 位哈希值，\n  - $C^{(char)}$ 是堆排序期间比较器执行的字符比较总数，\n  - $C^{(str)}$ 是堆排序期间字符串比较器的调用总数，\n  - $S$ 是堆排序期间的交换总数，\n  - $H^{(build)}$ 是一个布尔值，指示在建堆阶段结束后，数组是否立即满足指定比较器下的最大堆属性，此检查不影响计数，\n  - $Stab$ 是如上定义的布尔稳定性结果。\n- 堆排序应按字典序升序排序（最小的在前）。\n\n需要实现和评估的测试套件：\n- 案例 A (一般混合): [\"pear\",\"apple\",\"banana\",\"peach\",\"apricot\",\"grape\"]\n- 案例 B (用于测试稳定性的重复项): [\"bob\",\"alice\",\"bob\",\"alice\",\"bob\"]\n- 案例 C (空数组): []\n- 案例 D (单个元素): [\"Z\"]\n- 案例 E (混合大小写及非ASCII Unicode): [\"éclair\",\"eclair\",\"Éclair\",\"ECLAIR\"]\n- 案例 F (前缀关系和空字符串): [\"\", \"a\", \"aa\", \"ab\", \"\"]\n\n对每个案例，运行插桩后的堆排序并报告上述指标。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的、以逗号分隔的各案例结果列表。每个案例的结果本身也格式化为由方括号括起来的逗号分隔列表，并且不含任何空格。例如，形如 `[[1,2,3,4,True,False],[...],...]` 的行是可以接受的，其中布尔值必须显示为 True 或 False。\n\n为覆盖率而设计的解释：\n- 案例 A 检验具有不同首字母的典型行为。\n- 案例 B 强调重复项，并暴露（缺乏）稳定性。\n- 案例 C 验证了对 $n=0$ 边界情况的正确处理，其成本为零且属性为空泛真（vacuously true）。\n- 案例 D 验证了 $n=1$ 的行为。\n- 案例 E 确保了正确的 Unicode 码点排序，包括大小写和带重音符号的字母。\n- 案例 F 测试了前缀排序以及空字符串的存在。\n\n以上所有数值和符号均为形式化的数学量，必须严格按照规定处理。此任务不涉及任何物理单位、角度或百分比；所有输出均为所述的整数或布尔值。最终答案必须是计算并打印所要求的单行输出的代码。不要读取任何输入，也不要打印任何其他内容。",
            "solution": "用户提供了一个明确定义的计算问题，该问题在科学上基于数据结构和算法的原理。问题是自包含的、一致的，并且要求严格实现带有特定插桩的堆排序算法，以进行性能和属性分析。所有定义、常量和测试用例都已明确给出，使得该问题完全可以形式化和验证。因此，该问题被认定为 **有效**。\n\n解决方案涉及为字符串数据创建一个详细的堆排序实现，遵循指定的字典序，并对其进行插桩以度量几个关键指标。该实现将被封装在一个类中，以管理状态，包括输入数组和各种计数器。\n\n**1. 整体结构**\n定义一个分析类，我们称之为 `HeapsortAnalysis`，用于处理单个输入数组的排序和分析。该类存储字符比较 ($C^{(char)}$)、字符串比较 ($C^{(str)}$) 和交换 ($S$) 的计数器。它还管理稳定性分析所需的增广数据结构。\n\n**2. 数据增广与稳定性**\n堆排序本质上不是一种稳定的排序算法。为了根据给定输入凭经验度量其稳定性，输入数组中的每个字符串都将增补其原始索引。我们创建一个由 $(\\text{string}, \\text{original\\_index})$ 对组成的列表。堆排序算法将对这个偶对列表进行排序，但比较逻辑只考虑字符串部分。排序完成后，我们可以通过检查具有相同字符串键的元素的原始索引，来判断它们的相对顺序是否被保留。如果对于每个由相等字符串组成的最大连续块，其原始索引都呈非递减顺序，则认为该输入的排序是稳定的，并且布尔标志 $Stab$ 被设置为真。\n\n**3. 插桩的字典序比较器**\n实现一个自定义比较器函数来执行所定义的字典序比较：对于两个字符串 $s$ 和 $t$，如果它们在第一个不同字符位置 $j$ 处满足 $\\mathrm{ord}(s[j])  \\mathrm{ord}(t[j])$，或者如果 $s$ 是 $t$ 的严格前缀，则 $s \\prec t$。由于我们是按升序排序，堆排序算法将构建一个最大堆（max-heap），这需要一个“大于”比较。我们的比较器将实现这一逻辑。\n\n关键在于，这个比较器是经过插桩的。每次调用它来比较两个字符串时，字符串比较计数器 $C^{(str)}$ 增加 1。在单次调用中，对于在给定位置比较的每一对字符，字符比较计数器 $C^{(char)}$ 增加 1。根据问题规范，当一个字符串是另一个的前缀时，最终的字符串长度检查不计为字符比较。\n\n**4. 堆排序算法实现**\n堆排序算法分两个主要阶段进行：\n\n*   **阶段 1：建堆 ($H^{(build)}$)**\n    该算法首先将增广数组原地转换为最大堆。最大堆是一种二叉树，其中每个节点的值都大于或等于其子节点的值。这是通过从最后一个非叶子节点（索引为 $\\left\\lfloor n/2 \\right\\rfloor - 1$）向后迭代至根节点（索引 0），并对每个节点应用 `sift-down`（下沉）操作来实现的。`sift-down` 操作通过反复将一个节点与其最大的子节点交换，直到它不再小于其子节点，从而确保堆属性得以维持。此阶段之后，会执行一次性的、非插桩的检查，以验证数组是否正确表示一个最大堆，并设置布尔标志 $H^{(build)}$。\n\n*   **阶段 2：排序**\n    一旦最大堆建成，最大元素就位于堆的根部（索引 0）。算法会重复提取最大元素并将其放置在数组的末尾。在每一步中，对于当前大小为 $k$ 的堆：\n    1.  将根元素（最大值）与索引 $k-1$ 处的元素交换。交换计数器 $S$ 增加。\n    2.  堆的大小在概念上减小到 $k-1$。\n    3.  将新的根元素（来自堆的末尾）下沉到其正确位置，以恢复缩减后堆的最大堆属性。\n    重复此过程，直到堆的大小变为 1，此时数组已完全按升序排好。\n\n**5. 对输出进行哈希计算 ($H$)**\n排序后，计算已排序字符串序列的 $64$ 位多项式滚动哈希值 $H$，以提供对最终状态的紧凑验证。哈希值使用公式 $H \\gets \\big(H \\cdot B + x\\big) \\bmod M$ 迭代计算，其中基数 $B = 911382323$，模数 $M = 2^{64}$。对于排序后数组中的每个字符串，首先处理一个分隔符值 $x=0$，然后是字符串中每个字符 $c$ 对应的整数值 $x = \\mathrm{ord}(c)+1$。使用 $64$ 位无符号整数算术可自然地处理模 $M$ 的运算。\n\n**6. 边界情况**\n该实现正确处理了边界情况：\n*   空数组 ($n=0$)：这会导致零成本（$C^{(char)}=0, C^{(str)}=0, S=0$），哈希值为 $0$，以及空泛为真的属性（$H^{(build)}=\\text{True}, Stab=\\text{True}$）。\n*   单元素数组 ($n=1$)：由于数组已经排序，这同样导致零排序成本。为该单个元素计算哈希值，且属性平凡为真。\n\n通过将这些组件集成到单个类中，可以为问题陈述中提供的每个测试用例系统地计算出所需的指标 $[H, C^{(char)}, C^{(str)}, S, H^{(build)}, Stab]$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the heapsort analysis on all test cases and print the results.\n    \"\"\"\n\n    class HeapsortAnalysis:\n        \"\"\"\n        Encapsulates the heapsort algorithm and its instrumentation for a single array.\n        This includes tracking comparison and swap counts, checking stability,\n        and computing a final hash.\n        \"\"\"\n        def __init__(self, arr):\n            self.original_arr = list(arr)\n            self.n = len(self.original_arr)\n            self.c_char = 0\n            self.c_str = 0\n            self.s = 0\n            # Use uint64 for modulus 2^64 arithmetic, as specified by M = 2^64.\n            self.B = np.uint64(911382323)\n\n        def _compare_greater(self, s1, s2):\n            \"\"\"\n            Instrumented lexicographical comparison for s1 > s2.\n            Increments string and character comparison counters according to the rules.\n            Returns True if s1 is lexicographically greater than s2.\n            \"\"\"\n            self.c_str += 1\n            min_len = min(len(s1), len(s2))\n            for i in range(min_len):\n                self.c_char += 1\n                if s1[i] != s2[i]:\n                    return ord(s1[i]) > ord(s2[i])\n            # One string is a prefix of the other, or they are equal.\n            # The longer string is considered greater. The length check itself\n            # does not count as a character comparison.\n            return len(s1) > len(s2)\n\n        def _sift_down(self, aug_arr, start, end):\n            \"\"\"\n            Restores the max-heap property for a subtree rooted at `start`.\n            The heap is bounded by the exclusive index `end`.\n            \"\"\"\n            root = start\n            while True:\n                child = 2 * root + 1\n                if child >= end:\n                    break\n                \n                swap = root\n                # Find the largest among root, left child, and right child\n                # using the instrumented comparator.\n                if self._compare_greater(aug_arr[child][0], aug_arr[swap][0]):\n                    swap = child\n                \n                right_child = child + 1\n                if right_child  end and self._compare_greater(aug_arr[right_child][0], aug_arr[swap][0]):\n                    swap = right_child\n\n                if swap == root:\n                    break\n                else:\n                    aug_arr[root], aug_arr[swap] = aug_arr[swap], aug_arr[root]\n                    self.s += 1\n                    root = swap\n\n        def _build_max_heap(self, aug_arr):\n            \"\"\"Converts the array `aug_arr` into a max-heap in-place.\"\"\"\n            start = (self.n // 2) - 1\n            for i in range(start, -1, -1):\n                self._sift_down(aug_arr, i, self.n)\n\n        def _check_heap_property(self, aug_arr):\n            \"\"\"\n            Verifies if `aug_arr` is a valid max-heap without affecting counters.\n            Uses standard un-instrumented string comparison.\n            \"\"\"\n            if self.n = 1:\n                return True\n            # Only need to check non-leaf nodes\n            for i in range(self.n // 2):\n                left = 2 * i + 1\n                right = 2 * i + 2\n                if left  self.n and aug_arr[i][0]  aug_arr[left][0]:\n                    return False\n                if right  self.n and aug_arr[i][0]  aug_arr[right][0]:\n                    return False\n            return True\n\n        def _check_stability(self, sorted_aug_arr):\n            \"\"\"\n            Checks if the sort was stable by examining original indices of equal elements.\n            \"\"\"\n            if self.n  2:\n                return True\n            i = 0\n            while i  self.n:\n                j = i + 1\n                while j  self.n and sorted_aug_arr[j][0] == sorted_aug_arr[i][0]:\n                    j += 1\n                # A block of equal elements exists from index i to j-1\n                if j > i + 1:\n                    # Check if original indices are in non-decreasing order\n                    for k in range(i, j - 1):\n                        if sorted_aug_arr[k][1] > sorted_aug_arr[k+1][1]:\n                            return False\n                i = j\n            return True\n\n        def _compute_hash(self, sorted_aug_arr):\n            \"\"\"\n            Computes the specified polynomial rolling hash of the sorted sequence of strings.\n            \"\"\"\n            h = np.uint64(0)\n            for s_item, _ in sorted_aug_arr:\n                # Process separator value 0\n                h *= self.B\n                # Process each character, mapping it to ord(c) + 1\n                for char in s_item:\n                    h = h * self.B + np.uint64(ord(char) + 1)\n            return int(h)\n\n        def run(self):\n            \"\"\"\n            Executes the instrumented heapsort and returns all specified metrics.\n            \"\"\"\n            if self.n == 0:\n                # Handle empty array case\n                return [0, 0, 0, 0, True, True]\n            \n            # Augment array with original indices for stability check\n            aug_arr = [(self.original_arr[i], i) for i in range(self.n)]\n\n            if self.n == 1:\n                # Handle single-element array case\n                h = self._compute_hash(aug_arr)\n                return [h, 0, 0, 0, True, True]\n\n            # Phase 1: Build a max-heap\n            self._build_max_heap(aug_arr)\n            \n            # After building, check if it's a valid max-heap\n            h_build = self._check_heap_property(aug_arr)\n            \n            # Phase 2: Sort by repeatedly extracting the max element\n            for i in range(self.n - 1, 0, -1):\n                # Move current root (max element) to the end of the unsorted part\n                aug_arr[0], aug_arr[i] = aug_arr[i], aug_arr[0]\n                self.s += 1\n                # Restore heap property on the reduced heap\n                self._sift_down(aug_arr, 0, i)\n                \n            # Post-processing and metric collection\n            h = self._compute_hash(aug_arr)\n            stab = self._check_stability(aug_arr)\n\n            return [h, self.c_char, self.c_str, self.s, h_build, stab]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [\"pear\",\"apple\",\"banana\",\"peach\",\"apricot\",\"grape\"],\n        [\"bob\",\"alice\",\"bob\",\"alice\",\"bob\"],\n        [],\n        [\"Z\"],\n        [\"éclair\",\"eclair\",\"Éclair\",\"ECLAIR\"],\n        [\"\", \"a\", \"aa\", \"ab\", \"\"]\n    ]\n\n    results = []\n    for case in test_cases:\n        analyzer = HeapsortAnalysis(case)\n        result = analyzer.run()\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    result_str = \",\".join([f\"[{','.join(map(str, r))}]\" for r in results])\n    print(f\"[{result_str.replace('True', 'True').replace('False', 'False')}]\")\n\nsolve()\n```"
        }
    ]
}