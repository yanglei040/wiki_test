{
    "hands_on_practices": [
        {
            "introduction": "The theoretical efficiency of an algorithm, described by its Big O notation, does not always tell the whole story in practice. This exercise explores a crucial engineering optimization by creating a hybrid algorithm that adapts its strategy based on the size of the data it is sorting. You will implement a bucket sort that intelligently switches between insertion sort for small buckets, where its low overhead is advantageous, and merge sort for large buckets, where its superior asymptotic complexity of $O(k \\log k)$ pays off. This practice  illuminates the important trade-off between asymptotic performance and constant-factor overheads, a key consideration in high-performance computing.",
            "id": "3219476",
            "problem": "You are to design and implement an adaptive bucket sort for real numbers based on first principles of sorting and distribution. The fundamental base is the definition of sorting, comparison-based algorithms, and the concept of distributing elements across buckets by a hashing function on the value domain. The adaptive design must select the per-bucket sorting algorithm according to the bucket size: insertion sort for small buckets and merge sort for larger buckets.\n\nGiven an array $A$ of $n$ real numbers, the task is to sort $A$ in ascending order. The algorithm must:\n\n- Use $b$ buckets and a linear value-to-bucket mapping $h(x)$ that partitions the interval from $m_{\\min}$ to $m_{\\max}$, where $m_{\\min} = \\min(A)$ and $m_{\\max} = \\max(A)$, into $b$ subintervals. The mapping is\n$$\nh(x) \\;=\\; \\left\\lfloor \\frac{(x - m_{\\min})}{m_{\\max} - m_{\\min}} \\cdot b \\right\\rfloor\n$$\nwith the convention that values equal to $m_{\\max}$ map to bucket index $b-1$ (clamping is required). If $m_{\\max} = m_{\\min}$, then the list is already sorted trivially and must be returned unchanged.\n- Sort each bucket $B_i$ based on its size $|B_i|$: use insertion sort if $|B_i|  T$ and merge sort if $|B_i| \\ge T$, where $T$ is a positive integer threshold.\n- Concatenate the buckets in increasing index order to produce the final sorted array.\n\nJustify the mapping $h(x)$ by the fact that the subintervals $[m_{\\min} + \\frac{i}{b}(m_{\\max}-m_{\\min}), \\, m_{\\min} + \\frac{i+1}{b}(m_{\\max}-m_{\\min}))$ for $i \\in \\{0,1,\\dots,b-2\\}$, and the final interval including the right endpoint for $i=b-1$, form a partition of the domain. Hence, for any $x$ in bucket $i$ and any $y$ in bucket $j$ with $ij$, it holds that $x \\le y$, and concatenation preserves global sorted order if each bucket is internally sorted.\n\nDesign the per-bucket algorithm choice from first principles: insertion sort performs at $O(k^2)$ comparisons on $k$ elements, but has excellent locality and low constant factors, whereas merge sort performs at $O(k \\log k)$ comparisons with predictable splitting and merging overhead. There exists a break-even threshold $T$ where the asymptotic and constant-factor trade-offs favor insertion sort for $kT$ and merge sort for $k \\ge T$. Use $T=16$ for this assignment, which is a widely used engineering choice grounded in empirical observations and consistent with theoretical trade-offs.\n\nImplement the algorithm as a complete, runnable program in the Python language that adheres to these specifications. The program must not read any input and must produce an output for the fixed test suite below. No randomness is permitted in constructing the test data.\n\nTest Suite:\n- Case $1$ (happy path, mixed values in $[0,1)$):\n  - $A_1 = [0.78, 0.17, 0.39, 0.26, 0.72, 0.94, 0.21, 0.12, 0.01, 0.56, 0.33, 0.88]$\n  - $b_1 = 5$, $T_1 = 16$\n- Case $2$ (threshold boundary behavior, exactly $16$ in one bucket and $15$ in another):\n  - $A_2 = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,$\n    $1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]$\n  - $b_2 = 5$, $T_2 = 16$\n- Case $3$ (degenerate case, all equal values):\n  - $A_3 = [3.3, 3.3, 3.3, 3.3, 3.3, 3.3, 3.3, 3.3, 3.3, 3.3, 3.3, 3.3, 3.3, 3.3, 3.3, 3.3, 3.3, 3.3, 3.3, 3.3]$\n  - $b_3 = 4$, $T_3 = 16$\n- Case $4$ (mixed negative and positive with duplicates):\n  - $A_4 = [-1.5, 2.3, 0.0, -0.2, 1.1, -1.5, 2.3, -0.2, 0.0, 1.1, -0.7, 1.8, -2.0, 0.5]$\n  - $b_4 = 7$, $T_4 = 16$\n- Case $5$ (adversarial cluster producing a large bucket, exercising merge sort):\n  - $A_5 = [0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.9, 0.5, 0.7, 0.65, 0.6, 0.55]$\n  - $b_5 = 10$, $T_5 = 16$\n\nRequired Output Format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each result must itself be the sorted list for the corresponding test case, formatted as a bracketed, comma-separated list with no whitespace characters. For example, the output must look like\n$$\n[[\\dots],[\\dots],[\\dots],[\\dots],[\\dots]]\n$$\nwith every inner list printed without spaces, such as $[0.01,0.12,0.17]$ and the outer list printed as $[[\\dots],[\\dots]]$ with commas but no spaces anywhere.\n\nThe final answer for each test case must be a list of real numbers in ascending order. No physical units or angles are involved in this problem. The numeric answers are pure real values.",
            "solution": "The user-provided problem is first subjected to a rigorous validation process.\n\n### Step 1: Extract Givens\n- **Algorithm**: Adaptive Bucket Sort for an array $A$ of $n$ real numbers.\n- **Number of Buckets**: $b$.\n- **Value Range**: Determined by $m_{\\min} = \\min(A)$ and $m_{\\max} = \\max(A)$.\n- **Mapping Function**: $h(x) \\;=\\; \\left\\lfloor \\frac{(x - m_{\\min})}{m_{\\max} - m_{\\min}} \\cdot b \\right\\rfloor$.\n- **Special Condition (Clamping)**: Values equal to $m_{\\max}$ are mapped to bucket index $b-1$.\n- **Special Condition (Degenerate Range)**: If $m_{\\max} = m_{\\min}$, the list is returned unchanged.\n- **Adaptive Sorting Strategy**:\n    - For a bucket $B_i$ of size $|B_i|$ and a threshold $T$:\n    - If $|B_i|  T$, use insertion sort.\n    - If $|B_i| \\ge T$, use merge sort.\n- **Specified Threshold**: $T=16$.\n- **Final Step**: Concatenate sorted buckets $B_0, B_1, \\dots, B_{b-1}$ in order.\n- **Test Suite**: Five test cases are provided, each with a specific array $A_i$, bucket count $b_i$, and threshold $T_i$.\n    - Case $1$: $A_1 = [0.78, 0.17, 0.39, 0.26, 0.72, 0.94, 0.21, 0.12, 0.01, 0.56, 0.33, 0.88]$, $b_1 = 5$, $T_1 = 16$.\n    - Case $2$: $A_2 = [\\text{16 zeros}, \\text{15 ones}]$, $b_2 = 5$, $T_2 = 16$.\n    - Case $3$: $A_3 = [\\text{20 copies of } 3.3]$, $b_3 = 4$, $T_3 = 16$.\n    - Case $4$: $A_4 = [-1.5, 2.3, 0.0, -0.2, 1.1, -1.5, 2.3, -0.2, 0.0, 1.1, -0.7, 1.8, -2.0, 0.5]$, $b_4 = 7$, $T_4 = 16$.\n    - Case $5$: $A_5 = [\\text{25 copies of } 0.2, 0.9, 0.5, 0.7, 0.65, 0.6, 0.55]$, $b_5 = 10$, $T_5 = 16$.\n- **Output Format**: A single line of text representing a list of lists, formatted as `[[...],[...]]` with no whitespace.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded**: The problem is well-grounded in the fundamental principles of computer science, specifically sorting algorithms. Bucket sort, insertion sort, and merge sort are canonical algorithms. The adaptive strategy of switching between insertion sort and a divide-and-conquer algorithm like merge sort is a standard, theoretically justified optimization used in practical sorting libraries (e.g., Timsort). The time complexities cited ($O(k^2)$ for insertion sort and $O(k \\log k)$ for merge sort) are correct.\n- **Well-Posed**: The problem is clearly specified. The inputs are defined, the algorithm steps are detailed, and the expected output format is unambiguous. All parameters ($A, b, T$) are provided for each test case, ensuring a unique and deterministic solution can be computed.\n- **Objective**: The problem statement is objective and precise, using formal mathematical and algorithmic language. There are no subjective or opinion-based components.\n\n- **Flaw Checklist**:\n    1.  **Scientific/Factual Unsoundness**: None. The problem is algorithmically sound.\n    2.  **Non-Formalizable/Irrelevant**: None. The problem is a direct and formalizable task in algorithm implementation.\n    3.  **Incomplete/Contradictory Setup**: None. The problem provides all necessary details, including handling of edge cases like $m_{\\min} = m_{\\max}$ and values equal to $m_{\\max}$.\n    4.  **Unrealistic/Infeasible**: None. The task is a standard programming exercise with small-scale data.\n    5.  **Ill-Posed/Poorly Structured**: None. The problem structure is clear and leads to a unique solution.\n    6.  **Pseudo-Profound/Trivial**: None. The problem requires the correct implementation and integration of multiple algorithms and concepts, representing a substantive challenge.\n    7.  **Outside Scientific Verifiability**: None. The correctness of the output (sorted arrays) is easily verifiable.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A solution will be formulated and implemented.\n\n### Solution Formulation\n\nThe problem requires the implementation of an adaptive bucket sort algorithm. This algorithm operates on the principle of \"distribute and conquer\": it first distributes the elements of an input array into a number of \"buckets\" and then sorts each bucket individually before concatenating the results.\n\n**1. Foundational Principles**\n\nThe correctness of bucket sort hinges on the properties of the distribution function, or hash function, $h(x)$. The specified mapping function is:\n$$h(x) \\;=\\; \\left\\lfloor \\frac{(x - m_{\\min})}{m_{\\max} - m_{\\min}} \\cdot b \\right\\rfloor$$\nwhere $b$ is the number of buckets, $m_{\\min} = \\min(A)$, and $m_{\\max} = \\max(A)$. This function linearly maps the value range $[m_{\\min}, m_{\\max}]$ to the bucket index range $[0, b-1]$. Let $x_i$ be an element in bucket $B_i$ and $x_j$ be an element in bucket $B_j$. If $i  j$, then $h(x_i) \\le h(x_j)$, which implies $x_i \\le x_j$. This property ensures that if each bucket $B_k$ is internally sorted, concatenating the buckets in index order ($B_0, B_1, \\dots, B_{b-1}$) yields a fully sorted array. A special case arises if $m_{\\min} = m_{\\max}$, where all elements are equal; the array is already sorted and can be returned directly, preventing division by zero in $h(x)$. Another detail is the handling of $x = m_{\\max}$, which would map to index $b$ without clamping; the problem correctly specifies this must map to index $b-1$.\n\n**2. Adaptive Sorting Strategy**\n\nThe core of the \"adaptive\" design is the choice of sorting algorithm for each bucket based on its size, $|B_i|$.\n- **Insertion Sort**: This algorithm has a time complexity of $O(k^2)$ for an input of size $k$. However, for small $k$, its simple loop structure results in low constant-factor overheads and excellent cache performance. It is efficient for nearly sorted data and small inputs.\n- **Merge Sort**: This algorithm has a time complexity of $O(k \\log k)$. Its performance is asymptotically superior to insertion sort, making it ideal for larger inputs. However, its recursive nature and the memory operations involved in the merging step introduce a higher constant-factor overhead.\n\nThe existence of a break-even threshold, $T$, is a direct consequence of this trade-off. For bucket sizes $k  T$, the lower overhead of insertion sort makes it faster, while for $k \\ge T$, the better asymptotic complexity of merge sort dominates. The problem specifies $T=16$, a common empirically-derived value.\n\n**3. Algorithm Implementation Steps**\n\nThe implementation will proceed as follows:\n\n- **Initialization**: Given an array $A$, number of buckets $b$, and threshold $T$. First, handle base cases: if $A$ has fewer than $2$ elements, it is already sorted.\n- **Range Calculation and Edge Case**: Compute $m_{\\min} = \\min(A)$ and $m_{\\max} = \\max(A)$. If $m_{\\min} = m_{\\max}$, return $A$.\n- **Bucket Creation**: Initialize a list of $b$ empty lists to serve as buckets.\n- **Element Distribution**: Iterate through each element $x \\in A$. Compute its bucket index $i = h(x)$, ensuring correct clamping for $x=m_{\\max}$. Append $x$ to bucket $B_i$.\n- **Per-Bucket Sorting**: Iterate through each bucket $B_i$:\n    - If $|B_i|  T$, sort $B_i$ using an implementation of insertion sort.\n    - If $|B_i| \\ge T$, sort $B_i$ using an implementation of merge sort.\n- **Concatenation**: Create a final result array by concatenating the sorted buckets in order from $B_0$ to $B_{b-1}$.\n- **Return**: Return the final sorted array.\n\nThis systematic process adheres to the specified design and leverages the stated first principles to construct a correct and efficient sorting algorithm. Helper functions for insertion sort and merge sort are required. Merge sort will be implemented recursively, and insertion sort iteratively.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the adaptive bucket sort problem for a fixed test suite.\n    \"\"\"\n\n    def insertion_sort(arr):\n        \"\"\"\n        Sorts an array in-place using the insertion sort algorithm.\n        This is efficient for small inputs, as specified in the problem.\n        \"\"\"\n        for i in range(1, len(arr)):\n            key = arr[i]\n            j = i - 1\n            while j = 0 and key  arr[j]:\n                arr[j + 1] = arr[j]\n                j -= 1\n            arr[j + 1] = key\n        return arr\n\n    def merge_sort(arr):\n        \"\"\"\n        Sorts an array using the merge sort algorithm.\n        This O(n log n) algorithm is used for larger buckets.\n        \"\"\"\n        if len(arr) = 1:\n            return arr\n\n        mid = len(arr) // 2\n        left_half = merge_sort(arr[:mid])\n        right_half = merge_sort(arr[mid:])\n\n        # Merge the sorted halves\n        sorted_arr = []\n        i, j = 0, 0\n        while i  len(left_half) and j  len(right_half):\n            if left_half[i]  right_half[j]:\n                sorted_arr.append(left_half[i])\n                i += 1\n            else:\n                sorted_arr.append(right_half[j])\n                j += 1\n        \n        # Append remaining elements\n        sorted_arr.extend(left_half[i:])\n        sorted_arr.extend(right_half[j:])\n        \n        return sorted_arr\n\n    def adaptive_bucket_sort(A, b, T):\n        \"\"\"\n        Implements the adaptive bucket sort algorithm.\n        - A: a list of real numbers.\n        - b: the number of buckets.\n        - T: the threshold for switching between insertion sort and merge sort.\n        \"\"\"\n        n = len(A)\n        if n = 1:\n            return A\n\n        m_min = np.min(A)\n        m_max = np.max(A)\n\n        # Handle degenerate case where all elements are equal\n        if m_min == m_max:\n            return A\n\n        # 1. Create buckets\n        buckets = [[] for _ in range(b)]\n        \n        # 2. Distribute elements into buckets\n        spread = m_max - m_min\n        for x in A:\n            # Calculate bucket index based on the formula, with clamping for the max value\n            # The problem states \"values equal to m_max map to bucket index b-1\"\n            if x == m_max:\n                idx = b - 1\n            else:\n                # The formula without clamping could map m_max to index b, which is out of bounds.\n                # For x  m_max, the ratio is  1, so (ratio * b) is  b, and floor gives index = b-1.\n                idx = int(((x - m_min) / spread) * b)\n            \n            buckets[idx].append(x)\n\n        # 3. Sort each bucket adaptively and 4. Concatenate\n        sorted_result = []\n        for i in range(b):\n            bucket = buckets[i]\n            bucket_size = len(bucket)\n            \n            if bucket_size == 0:\n                continue\n            \n            # Choose sorting algorithm based on threshold T\n            if bucket_size  T:\n                sorted_bucket = insertion_sort(bucket)\n            else:\n                sorted_bucket = merge_sort(bucket)\n            \n            sorted_result.extend(sorted_bucket)\n            \n        return sorted_result\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\n            [0.78, 0.17, 0.39, 0.26, 0.72, 0.94, 0.21, 0.12, 0.01, 0.56, 0.33, 0.88],\n            5,\n            16\n        ),\n        (\n            [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n             1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0],\n            5,\n            16\n        ),\n        (\n            [3.3, 3.3, 3.3, 3.3, 3.3, 3.3, 3.3, 3.3, 3.3, 3.3, 3.3, 3.3, 3.3, 3.3, 3.3, 3.3, 3.3, 3.3, 3.3, 3.3],\n            4,\n            16\n        ),\n        (\n            [-1.5, 2.3, 0.0, -0.2, 1.1, -1.5, 2.3, -0.2, 0.0, 1.1, -0.7, 1.8, -2.0, 0.5],\n            7,\n            16\n        ),\n        (\n            [0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.9, 0.5, 0.7, 0.65, 0.6, 0.55],\n            10,\n            16\n        )\n    ]\n\n    results_as_strings = []\n    for A, b, T in test_cases:\n        # Use lists for numpy array creation to avoid deprecation warnings\n        input_array = list(A)\n        # Main logic to calculate the result for one case goes here.\n        sorted_list = adaptive_bucket_sort(input_array, b, T)\n        # Format each inner list as a string without whitespace\n        # e.g., [0.01, 0.12] becomes \"[0.01,0.12]\"\n        formatted_list = f\"[{','.join(map(str, sorted_list))}]\"\n        results_as_strings.append(formatted_list)\n\n    # Final print statement in the exact required format.\n    # Join the formatted list strings and enclose in brackets.\n    # e.g., [\"[...]\", \"[...]\"] becomes \"[ [...],[...] ]\"\n    final_output = f\"[{','.join(results_as_strings)}]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "A key assumption for bucket sort's linear-time performance is that the input data is uniformly distributed, a condition rarely met in real-world datasets. This practice  addresses this fundamental weakness by guiding you through the design of a truly adaptive algorithm. You will learn to create a \"smart\" mapping function by sampling the input data and using its empirical cumulative distribution function ($\\hat{F}(x)$) to create bucket boundaries that reflect the data's actual density, ensuring a more balanced distribution and preserving efficiency even for highly clustered inputs.",
            "id": "3219485",
            "problem": "You are given the task to design and implement a bucket sort algorithm whose bucket assignment mapping function is learned from a deterministic sample of the input data to optimize bucket population balance. The algorithm must be derived from the following fundamental base: the definition of sorting, the principle of partitioning in bucket sort, and the construction and properties of an empirical cumulative distribution function (empirical CDF). The problem is to reason from these foundations to a complete algorithm for bucket sort with learned mapping and then implement it.\n\nLet an input array be denoted by $A = [a_1, a_2, \\dots, a_n]$ with length $n$. The sorting task is to produce an array $A^{\\mathrm{sorted}} = [a_{(1)}, a_{(2)}, \\dots, a_{(n)}]$ such that $a_{(1)} \\le a_{(2)} \\le \\dots \\le a_{(n)}$. In bucket sort, the high-level plan is to select a number of buckets $B \\in \\mathbb{N}$ with $B \\ge 1$, define a mapping function $g : \\mathbb{R} \\to \\{0, 1, \\dots, B-1\\}$ to assign each element $x \\in A$ to a bucket index $g(x)$, sort the elements within each bucket, and concatenate the buckets in increasing index order to produce $A^{\\mathrm{sorted}}$.\n\nThe mapping function $g$ is unknown a priori and must be learned from a sample of the data. The principle is that if one had access to the true cumulative distribution function $F(x) = \\mathbb{P}(X \\le x)$ of the data-generating process for $A$ where $X$ is a real-valued random variable, then mapping $x$ to a bucket according to quantiles can equalize expected bucket counts. Since $F$ is unknown, we estimate it using the empirical cumulative distribution function constructed from a deterministic sample $S$ of size $s$, where $1 \\le s \\le n$. The deterministic sample $S$ must be selected by evenly spaced indices across $A$, specifically\n$$\n\\text{if } s = 1,\\ \\ \\text{indices} = [0];\\quad \\text{if } s \\ge 2,\\ \\ \\text{indices} = \\left[\\, \\left\\lfloor \\frac{i \\cdot (n-1)}{s-1} \\right\\rfloor \\ :\\ i = 0, 1, \\dots, s-1 \\right].\n$$\nThen $S$ is formed by $S_i = a_{\\text{indices}[i]}$ for $i=0,1,\\dots,s-1$. The empirical cumulative distribution function is defined as\n$$\n\\hat{F}(x) = \\frac{1}{s}\\sum_{i=1}^{s} \\mathbf{1}\\{S_i \\le x\\},\n$$\nwhere $\\mathbf{1}\\{\\cdot\\}$ is the indicator function. The learned mapping function is then\n$$\ng(x) = \\min\\left( B - 1, \\left\\lfloor B \\cdot \\hat{F}(x) \\right\\rfloor \\right),\n$$\nwhich assigns each $x$ to a bucket index in $\\{0,1,\\dots,B-1\\}$. Sorting is performed independently within each bucket (in nondecreasing order), and the final output is the concatenation of all buckets in increasing index order.\n\nYour program must implement this bucket sort algorithm with the above deterministic sampling rule and empirical cumulative distribution function mapping. It must handle general real numbers, including negative values, zero, duplicates, and large magnitude outliers. Within each bucket, use a stable comparison-based sorting method to ensure the final order is nondecreasing.\n\nTest Suite and Parameter Specification:\nImplement and run the algorithm on the following test cases. For each test case, the parameters are the input array $A$, the number of buckets $B$, and the sample size $s$. In cases where $s > n$, use $s' = \\min(s, n)$ (that is, cap the sample size at the array length). All numbers and arrays are to be treated as dimensionless real numbers.\n\n- Test case $1$: $A = [\\, 0.15,\\, 0.85,\\, 0.40,\\, 0.01,\\, 0.99,\\, 0.75,\\, 0.50 \\,]$, $B = 3$, $s = 4$.\n- Test case $2$: $A = [\\, 5,\\, 5,\\, 5,\\, 5 \\,]$, $B = 5$, $s = 3$.\n- Test case $3$: $A = [\\, -10,\\, -0.5,\\, -3.3,\\, 2,\\, 0,\\, -1,\\, 8.8 \\,]$, $B = 4$, $s = 5$.\n- Test case $4$: $A = [\\, 1000,\\, -1000,\\, 10,\\, -10,\\, 0,\\, 0.1,\\, -0.1,\\, 500,\\, -500 \\,]$, $B = 6$, $s = 7$.\n- Test case $5$: $A = [\\, 1 \\,]$, $B = 1$, $s = 1$.\n- Test case $6$: $A = [\\, 3,\\, 1,\\, 4,\\, 1,\\, 5 \\,]$, $B = 4$, $s = 10$.\n\nRequired Final Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each result is the fully sorted array for the corresponding test case. For example, the outer format must be $[\\,\\text{result}_1, \\text{result}_2, \\dots \\,]$, where each $\\text{result}_i$ is a list of numbers. No additional text or lines should be printed.",
            "solution": "The problem statement is subjected to validation against the established criteria.\n\n### Step 1: Extract Givens\n- **Input Array**: An array $A = [a_1, a_2, \\dots, a_n]$ of length $n$.\n- **Number of Buckets**: $B \\in \\mathbb{N}$ with $B \\ge 1$.\n- **Sample Size**: $s$, with $1 \\le s \\le n$. A provision is made: if the provided $s > n$, use $s' = \\min(s, n)$.\n- **Sorting Definition**: Produce an array $A^{\\mathrm{sorted}} = [a_{(1)}, a_{(2)}, \\dots, a_{(n)}]$ such that $a_{(1)} \\le a_{(2)} \\le \\dots \\le a_{(n)}$.\n- **Bucket Sort Principle**: Partition elements into $B$ buckets using a mapping function $g$, sort each bucket, and concatenate the sorted buckets.\n- **Deterministic Sampling Rule**: The sample $S$ of size $s$ is formed from elements of $A$ at specific indices.\n  - If $s = 1$, indices = $[0]$.\n  - If $s \\ge 2$, indices = $\\left[\\, \\left\\lfloor \\frac{i \\cdot (n-1)}{s-1} \\right\\rfloor \\ :\\ i = 0, 1, \\dots, s-1 \\right]$.\n- **Empirical CDF Definition**: $\\hat{F}(x) = \\frac{1}{s}\\sum_{i=1}^{s} \\mathbf{1}\\{S_i \\le x\\}$, where $\\mathbf{1}\\{\\cdot\\}$ is the indicator function.\n- **Mapping Function Definition**: $g(x) = \\min\\left( B - 1, \\left\\lfloor B \\cdot \\hat{F}(x) \\right\\rfloor \\right)$.\n- **Internal Sorting**: Buckets are to be sorted using a stable comparison-based method.\n- **Test Cases**:\n  1. $A = [\\, 0.15,\\, 0.85,\\, 0.40,\\, 0.01,\\, 0.99,\\, 0.75,\\, 0.50 \\,]$, $B = 3$, $s = 4$.\n  2. $A = [\\, 5,\\, 5,\\, 5,\\, 5 \\,]$, $B = 5$, $s = 3$.\n  3. $A = [\\, -10,\\, -0.5,\\, -3.3,\\, 2,\\, 0,\\, -1,\\, 8.8 \\,]$, $B = 4$, $s = 5$.\n  4. $A = [\\, 1000,\\, -1000,\\, 10,\\, -10,\\, 0,\\, 0.1,\\, -0.1,\\, 500,\\, -500 \\,]$, $B = 6$, $s = 7$.\n  5. $A = [\\, 1 \\,]$, $B = 1$, $s = 1$.\n  6. $A = [\\, 3,\\, 1,\\, 4,\\, 1,\\, 5 \\,]$, $B = 4$, $s = 10$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is evaluated for validity.\n1.  **Scientifically Grounded**: The problem is well-grounded in the fields of computer science (algorithms) and statistics. Bucket sort is a standard sorting algorithm. The use of an empirical cumulative distribution function ($\\hat{F}(x)$) to approximate an unknown true data distribution $F(x)$ is a fundamental technique in non-parametric statistics. The proposed mapping function $g(x)$ is a direct application of this principle, aiming to partition the data domain into segments of roughly equal probability mass, thereby balancing bucket sizes. All mathematical definitions are standard and correct.\n2.  **Well-Posed**: The problem is specified with high precision. All inputs ($A$, $B$, $s$), intermediate constructs (sampling rule, $\\hat{F}(x)$, $g(x)$), and procedures (bucketing, internal sort, concatenation) are defined unambiguously. The edge cases $s=1$ and $s>n$ are explicitly handled. This structure guarantees that a unique and meaningful sorted array can be produced for any valid input.\n3.  **Objective**: The problem is stated in objective, mathematical language, free of any subjective or opinion-based assertions.\n\nThe problem does not exhibit any of the invalidity flaws. It is scientifically sound, formally specified, complete, consistent, and solvable.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. Proceeding with the derivation of the solution.\n\n### Algorithmic Derivation from First Principles\nThe task is to derive and implement a bucket sort algorithm where the bucket mapping is learned from the data. The derivation follows from the provided foundational principles.\n\n**1. The Goal: Sorting**\nThe fundamental objective is to transform an input array $A=[a_1, \\dots, a_n]$ into a permutation $A^{\\mathrm{sorted}}=[a_{(1)}, \\dots, a_{(n)}]$ where $a_{(1)} \\le a_{(2)} \\le \\dots \\le a_{(n)}$.\n\n**2. The Strategy: Bucket Sort**\nThe bucket sort algorithm partitions the sorting problem. It involves three primary stages:\n- **Partition**: Distribute the $n$ elements of $A$ into $B$ ordered containers, or buckets, based on a mapping function $g(x)$.\n- **Sort**: Sort the elements within each individual bucket.\n- **Concatenate**: Combine the sorted buckets in order to form the final sorted array.\nThe efficacy of bucket sort hinges on the quality of the mapping function $g(x)$. An ideal $g(x)$ would distribute elements uniformly across the buckets, making the sub-problems (sorting each bucket) of roughly equal and small size.\n\n**3. The Learned Mapping Function: $g(x)$**\nThe core of this problem lies in constructing $g(x)$. The principle is to use the data's distributional properties. If the true cumulative distribution function (CDF), $F(x) = \\mathbb{P}(X \\le x)$, were known, the function $F(x)$ would map values to the interval $[0, 1]$. Multiplying by $B$ and taking the floor, $g_{\\text{ideal}}(x) = \\lfloor B \\cdot F(x) \\rfloor$, would map elements to bucket indices $\\{0, 1, \\dots, B-1\\}$. For a continuous random variable $X$, $F(X)$ is uniformly distributed on $[0,1]$, so this mapping would, in expectation, perfectly balance the buckets.\n\nSince $F(x)$ is unknown, we must estimate it from the data. The problem specifies using the **empirical cumulative distribution function (ECDF)**, denoted $\\hat{F}(x)$. This is constructed from a deterministic sample $S$ drawn from the input array $A$. The ECDF is a non-parametric maximum likelihood estimate of the true CDF.\nThe algorithm proceeds as follows:\n\n**Step A: Sampling and Model Construction**\n   1.  Determine the effective sample size, $s_{\\text{eff}} = \\min(s, n)$, where $n$ is the length of $A$.\n   2.  Construct the deterministic sample $S$. An array of indices is first computed according to the rule:\n       - For $s_{\\text{eff}} = 1$, the index is $[0]$.\n       - For $s_{\\text{eff}} \\ge 2$, the indices are $\\left[\\left\\lfloor \\frac{i \\cdot (n-1)}{s_{\\text{eff}}-1} \\right\\rfloor\\right]$ for $i \\in \\{0, 1, \\dots, s_{\\text{eff}}-1\\}$.\n       The sample $S$ consists of the elements of $A$ at these computed indices.\n   3.  To facilitate the computation of $\\hat{F}(x)$, the sample $S$ is sorted into nondecreasing order, yielding $S^{\\text{sorted}}$.\n\n**Step B: Defining the Mapping and Partitioning**\n   1.  The ECDF, $\\hat{F}(x) = \\frac{1}{s_{\\text{eff}}}\\sum_{j=1}^{s_{\\text{eff}}} \\mathbf{1}\\{S_j \\le x\\}$, is implemented. For a given value $x$, the sum $\\sum \\mathbf{1}\\{S_j \\le x\\}$ is simply the count of elements in the sample $S$ that are less than or equal to $x$. This count can be found efficiently on $S^{\\text{sorted}}$ using a binary search algorithm, which has a time complexity of $O(\\log s_{\\text{eff}})$.\n   2.  The mapping function $g(x)$ is then given by $g(x) = \\min\\left( B - 1, \\left\\lfloor B \\cdot \\hat{F}(x) \\right\\rfloor \\right)$. The $\\min(B-1, \\dots)$ term ensures that even if $\\hat{F}(x)=1$, the resulting index $\\lfloor B \\cdot 1 \\rfloor = B$ is corrected to the maximum valid index $B-1$.\n   3.  An array of $B$ empty buckets is initialized. The input array $A$ is traversed, and for each element $a_i$, its bucket index $k = g(a_i)$ is computed, and $a_i$ is placed into bucket $k$.\n\n**Step C: Sorting and Concatenation**\n   1.  Each of the $B$ buckets is sorted independently. The problem mandates a stable sorting algorithm. This ensures that if $a_i = a_j$ for $i  j$, their relative order in the final sorted output is preserved. The stability of the overall algorithm is guaranteed because equal-valued elements will always map to the same bucket (since $g(x)$ is a function of value only), and the stable sort within that bucket maintains their original relative order.\n   2.  The final sorted array, $A^{\\mathrm{sorted}}$, is constructed by concatenating the sorted buckets in sequence, from bucket $0$ to bucket $B-1$.\n\nThis completes the derivation of the algorithm from the specified principles. The procedure is deterministic and produces a correctly sorted array.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and tests the bucket sort algorithm with a learned mapping function\n    based on an empirical cumulative distribution function (ECDF).\n    \"\"\"\n\n    test_cases = [\n        {'A': [0.15, 0.85, 0.40, 0.01, 0.99, 0.75, 0.50], 'B': 3, 's': 4},\n        {'A': [5, 5, 5, 5], 'B': 5, 's': 3},\n        {'A': [-10, -0.5, -3.3, 2, 0, -1, 8.8], 'B': 4, 's': 5},\n        {'A': [1000, -1000, 10, -10, 0, 0.1, -0.1, 500, -500], 'B': 6, 's': 7},\n        {'A': [1], 'B': 1, 's': 1},\n        {'A': [3, 1, 4, 1, 5], 'B': 4, 's': 10}\n    ]\n\n    results = []\n\n    for case in test_cases:\n        A = case['A']\n        B = case['B']\n        s = case['s']\n\n        n = len(A)\n\n        if n == 0:\n            results.append([])\n            continue\n\n        # Step A.1: Determine the effective sample size\n        s_eff = min(s, n)\n\n        # Step A.2: Construct the deterministic sample S\n        if s_eff == 1:\n            indices = [0]\n        else:\n            indices_float = np.arange(s_eff) * (n - 1) / (s_eff - 1)\n            indices = np.floor(indices_float).astype(int)\n        \n        sample_S = [A[i] for i in indices]\n\n        # Step A.3: Sort the sample to facilitate ECDF computation\n        sorted_sample_S = sorted(sample_S)\n\n        # Step B.1-2: Define the ECDF-based mapping function g(x)\n        def get_bucket_index(x):\n            # Compute F_hat(x)\n            # Find count of elements in sample_S = x using binary search\n            # np.searchsorted(side='right') is equivalent to bisect_right\n            count_le_x = np.searchsorted(sorted_sample_S, x, side='right')\n            f_hat_x = count_le_x / s_eff\n            \n            # Compute bucket index using the learned mapping function\n            bucket_idx = int(B * f_hat_x)\n            \n            # Ensure index is within the valid range [0, B-1]\n            return min(B - 1, bucket_idx)\n\n        # Step B.3: Partition elements into buckets\n        buckets = [[] for _ in range(B)]\n        for element in A:\n            idx = get_bucket_index(element)\n            buckets[idx].append(element)\n\n        # Step C.1: Sort each bucket (using Python's stable Timsort)\n        for i in range(B):\n            buckets[i].sort()\n\n        # Step C.2: Concatenate sorted buckets\n        sorted_A = [element for bucket in buckets for element in bucket]\n        \n        results.append(sorted_A)\n\n    # Format the final output as specified\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Sorting is straightforward when dealing with simple integers, but the real world is filled with complex data types like IEEE 754 floating-point numbers, which include special values like Not-a-Number ($NaN$) and infinities that break standard comparison logic. This advanced practice  challenges you to sort these values according to the IEEE 754 `totalOrder` specification. The solution lies in devising an ingenious order-preserving map from floats to integers by understanding the data's underlying bit-level representation, a powerful technique for building numerically robust and standards-compliant software.",
            "id": "3219392",
            "problem": "Design and implement a modification of bucket sort that correctly orders IEEE 754 double-precision floating-point values, including the special values Not-a-Number (NaN), positive infinity, and negative infinity, according to the IEEE 754 total order. Your program must implement the following.\n\n1. Fundamental base and constraints. Begin from the core definitions:\n   - Bucket sort assumes a list of $n$ keys drawn from a domain that can be mapped into $B$ buckets such that keys are approximately evenly distributed across buckets. Within each bucket, a stable, comparison-based method (for example, insertion sort) is applied, and buckets are concatenated in order.\n   - IEEE 754 double-precision floating-point numbers classify into signed zeros, finite numbers, signed infinities, and NaNs. Standard comparison operators do not define a total order over these values because any comparison with NaN is unordered. However, the IEEE 754 standard specifies a total order that distinguishes $-0.0$ from $+0.0$, places $-\\infty$ before all finite numbers, places $+\\infty$ after all finite numbers but before all NaNs, and places all NaNs after $+\\infty$.\n\n2. Task. Devise a principled way to modify bucket sort so that:\n   - It sorts any finite and special double-precision values into the IEEE 754 total order without relying on floating-point comparisons that are undefined for NaN.\n   - The bucket assignment is performed on an order-preserving mapping of each floating-point value to an integer key that is totally ordered according to the IEEE 754 total order, and this integer key is used consistently for both bucket placement and in-bucket ordering.\n   - The algorithm is stable for values that are equal under the total order.\n   - Choose the number of buckets $B$ as $B=\\lceil \\sqrt{n} \\rceil$ for an input of size $n$.\n   - For bucket index calculation, if $k_{\\min}$ and $k_{\\max}$ are the minimum and maximum integer keys in the input, respectively, then each element with key $k$ must be placed into bucket index\n     $$\\left\\lfloor \\dfrac{(k - k_{\\min}) \\cdot B}{(k_{\\max} - k_{\\min}) + 1} \\right\\rfloor,$$\n     which guarantees an index in $\\{0,1,\\dots,B-1\\}$ even when all keys are equal.\n\n3. Output. For each test case, output the sorted list. Aggregate the results for all test cases into a single line of output containing the per-test-case results as a comma-separated list enclosed in square brackets, with no spaces. For example, for three test cases producing results $r_1$, $r_2$, and $r_3$, the program must print a single line in the exact format\n   - $[r_1,r_2,r_3]$,\n   where each $r_i$ is itself a list literal with elements printed using the languageâ€™s canonical floating-point literal forms, namely \"nan\" for NaN, \"inf\" for $+\\infty$, and \"-inf\" for $-\\infty$, and signed zeros as \"$-0.0$\" and \"$0.0$\".\n\n4. Test suite. Your program must hard-code and sort the following test arrays and output their sorted forms in the format specified above.\n   - Test A (happy path, mixture): $[3.0,\\ \\text{NaN},\\ -\\infty,\\ +\\infty,\\ 2.5,\\ -0.0,\\ 0.0,\\ -1.0,\\ 1.0\\times10^{-308},\\ -1.0\\times10^{-308},\\ 0.5]$.\n   - Test B (boundary with only specials): $[\\text{NaN},\\ -\\infty,\\ +\\infty]$.\n   - Test C (zeros and subnormals): $[-0.0,\\ 0.0,\\ 5.0\\times10^{-324},\\ -5.0\\times10^{-324}]$.\n   - Test D (extreme finite magnitudes): $[1.7976931348623157\\times10^{308},\\ -1.7976931348623157\\times10^{308},\\ 2.2250738585072014\\times10^{-308},\\ -2.2250738585072014\\times10^{-308}]$.\n\n5. Answer format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets with no spaces, in the exact order of the tests A, B, C, D. Each per-test-case result must be a list literal in the same no-spaces format. The elements of each list must be printed as canonical literals: \"nan\" for $\\mathrm{NaN}$, \"inf\" for $+\\infty$, \"-inf\" for $-\\infty$, and with signed zeros preserved.\n\nNo input should be read; the program must be fully self-contained and must only output the single required line.",
            "solution": "The problem requires the design and implementation of a modified bucket sort algorithm capable of sorting IEEE 754 double-precision floating-point numbers according to the `totalOrder` predicate defined in the standard. This order is specified as:\n$$-\\infty  \\dots  \\text{negative finite numbers}  -0.0  +0.0  \\text{positive finite numbers}  \\dots  +\\infty  \\text{NaNs}$$\nA standard comparison-based sort fails because any comparison involving Not-a-Number (NaN) is undefined. The core of the solution is to devise an order-preserving mapping from any double-precision float $x$ to a $64$-bit unsigned integer key, $k = f(x)$, such that for any two floats $x_1$ and $x_2$, if $x_1  x_2$ under the `totalOrder` implies $f(x_1)  f(x_2)$. Bucket sort can then operate on these integer keys.\n\nThe principled design proceeds as follows:\n\n1.  **Integer Representation of Floating-Point Numbers**: An IEEE 754 double-precision float is stored as a $64$-bit value. We can reinterpret this bit pattern as a $64$-bit unsigned integer, let's call it $u$. This integer $u$ consists of a sign bit (most significant bit, MSB), an $11$-bit exponent, and a $52$-bit fraction.\n\n    -   If the sign bit is $0$ (for positive numbers, $+0.0$, $+\\infty$, and positive NaNs), the numerical order of the floats corresponds directly to the integer order of their $u$ representations. For two such floats $x_1$ and $x_2$, if $x_1  x_2$, then $u_1  u_2$.\n    -   If the sign bit is $1$ (for negative numbers, $-0.0$, $-\\infty$, and negative NaNs), the numerical order is the reverse of the integer order of their $u$ representations. For two such floats $x_1$ and $x_2$, if $x_1  x_2$, then $u_1  u_2$. This is because the representation is sign-magnitude, where larger magnitudes (more negative numbers) result in larger integer representations when the MSB is $1$.\n\n2.  **Constructing the Order-Preserving Key Mapping**: To establish a single monotonic sequence of keys that respects the `totalOrder`, we map the floats to a $64$-bit unsigned integer key space. We can map all negative values to the lower half of the key space ($[0, 2^{63}-1]$) and all positive values to the upper half ($[2^{63}, 2^{64}-1]$).\n\n    -   **For a float $x$ with sign bit $1$ (negative value)**: The `uint64` representation $u$ is order-inverting. To correct this, we apply an order-reversing transformation. The bitwise NOT operation, $\\sim u$, which for a $64$-bit unsigned integer is equivalent to $(2^{64}-1) - u$, serves this purpose. For example, $u(-0.0) = 0x8000000000000000$ is mapped to $\\sim u = 0x7FFFFFFFFFFFFFFF$, while $u(-\\infty) = 0xFFF0000000000000$ is mapped to $\\sim u = 0x000FFFFFFFFFFFFF$. This correctly places $-\\infty$ at the low end of this key range and $-0.0$ at the high end.\n\n    -   **For a float $x$ with sign bit $0$ (positive value)**: The `uint64` representation $u$ is already order-preserving. To ensure these keys are greater than all keys from negative floats, we shift them into the upper half of the $64$-bit range. This is achieved by adding $2^{63}$ (i.e., $0x8000000000000000$) to $u$. For example, $u(+0.0)=0x0$ is mapped to $0x8000000000000000$, and $u(+\\infty)=0x7FF0000000000000$ is mapped to $0xFFF0000000000000$.\n\n    This mapping function, $f(x)$, is defined as:\n    $$\n    f(x) = \\begin{cases} (2^{64}-1) - u  \\text{if sign bit of } u \\text{ is } 1 \\\\ u + 2^{63}  \\text{if sign bit of } u \\text{ is } 0 \\end{cases}\n    $$\n    where $u$ is the $64$-bit unsigned integer representation of the float $x$. This function correctly establishes a total ordering on the integer keys that matches the IEEE 754 `totalOrder`, including the relative order of $-0.0$ and $+0.0$.\n\n3.  **Modified Bucket Sort Algorithm**:\n    -   **Step 1: Key Generation**: For each float $x_i$ in the input array of size $n$, compute its corresponding integer key $k_i = f(x_i)$. Store these as pairs $(k_i, x_i)$.\n    -   **Step 2: Bucket Initialization**: Find the minimum key, $k_{\\min}$, and maximum key, $k_{\\max}$, among all generated keys. The number of buckets, $B$, is set to $\\lceil \\sqrt{n} \\rceil$. Create $B$ empty buckets.\n    -   **Step 3: Distribution**: For each pair $(k, x)$, calculate its bucket index $j$ using the formula specified in the problem:\n      $$j = \\left\\lfloor \\dfrac{(k - k_{\\min}) \\cdot B}{(k_{\\max} - k_{\\min}) + 1} \\right\\rfloor$$\n      This formula ensures that the index $j$ is in the valid range $\\{0, 1, \\dots, B-1\\}$. The properties of Python's arbitrary-precision integers are leveraged for the numerator to prevent overflow during this calculation. Place the pair $(k, x)$ into bucket $j$.\n    -   **Step 4: In-Bucket Sorting**: Sort each bucket individually based on the integer key $k$. To adhere to the stability requirement, a stable sorting algorithm must be used. Insertion sort is a simple, stable algorithm suitable for this task, as the buckets are expected to be small and nearly sorted.\n    -   **Step 5: Concatenation**: Concatenate the sorted buckets in order from bucket $0$ to bucket $B-1$ to produce the final sorted sequence of pairs.\n    -   **Step 6: Final Result**: Extract the original float values from the sorted sequence of pairs to obtain the final sorted array. The entire process is stable because the key mapping is deterministic and the in-bucket sort is stable.\n\nThis principled approach correctly transforms a problem that is ill-defined for standard comparison operators into a well-defined integer sorting problem, which is then solved efficiently using bucket sort.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the problem by implementing a modified bucket sort for IEEE 754 doubles,\n    including special values, and printing the sorted results for the given test suite.\n    \"\"\"\n\n    def float_to_key(x: float) - np.uint64:\n        \"\"\"\n        Maps an IEEE 754 double-precision float to a 64-bit unsigned integer key\n        that preserves the IEEE 754 totalOrder.\n        \"\"\"\n        # Reinterpret the 64-bit float as a 64-bit unsigned integer.\n        u = np.float64(x).view(np.uint64)\n        \n        # Check the sign bit (the most significant bit).\n        if (u  63)  1:\n            # Negative floats (including -0.0, -inf, and negative NaNs).\n            # Their uint64 representation is in reverse of the desired totalOrder.\n            # Applying bitwise NOT (on 64 bits) reverses the order.\n            # In Python, ~u doesn't work as expected for uint64, so we simulate it.\n            return np.uint64((1  64) - 1) - u\n        else:\n            # Positive floats (including +0.0, +inf, and positive NaNs).\n            # Their uint64 representation is already in the correct relative order.\n            # We add 2**63 to shift them to the upper half of the uint64 range,\n            # ensuring all positive keys are greater than all negative keys.\n            return u + np.uint64(1  63)\n\n    def insertion_sort(bucket: list):\n        \"\"\"\n        Sorts a bucket (list of (key, value) tuples) in-place using insertion sort.\n        This is a stable sorting algorithm.\n        \"\"\"\n        for i in range(1, len(bucket)):\n            key_item = bucket[i]\n            j = i - 1\n            # Compare items based on their integer key (item[0]).\n            while j = 0 and bucket[j][0]  key_item[0]:\n                bucket[j + 1] = bucket[j]\n                j -= 1\n            bucket[j + 1] = key_item\n\n    def modified_bucket_sort(arr: list) - list:\n        \"\"\"\n        Sorts a list of floats using a modified bucket sort algorithm.\n        \"\"\"\n        n = len(arr)\n        if n = 1:\n            return arr\n        \n        # 1. Map floats to order-preserving integer keys.\n        keyed_arr = [(float_to_key(x), x) for x in arr]\n\n        # 2. Find min and max keys.\n        keys = [item[0] for item in keyed_arr]\n        k_min = min(keys)\n        k_max = max(keys)\n\n        # 3. Initialize buckets.\n        num_buckets = math.ceil(math.sqrt(n))\n        buckets = [[] for _ in range(num_buckets)]\n\n        # If all keys are the same, all items go to the first bucket.\n        if k_max == k_min:\n            denominator = np.uint64(1)\n        else:\n            denominator = k_max - k_min + np.uint64(1)\n        \n        # 4. Distribute items into buckets.\n        for item in keyed_arr:\n            k = item[0]\n            # Use Python's arbitrary-precision integers for the numerator to avoid overflow.\n            numerator = (int(k) - int(k_min)) * num_buckets\n            idx = numerator // int(denominator)\n            buckets[idx].append(item)\n            \n        # 5. Sort each bucket and concatenate the results.\n        sorted_arr = []\n        for bucket in buckets:\n            # Use a stable sort (insertion sort as specified).\n            insertion_sort(bucket)\n            sorted_arr.extend(bucket)\n            \n        # 6. Extract the original float values.\n        return [item[1] for item in sorted_arr]\n\n    def format_float(f: float) - str:\n        \"\"\"\n        Formats a float into the required string representation for special values.\n        \"\"\"\n        if np.isnan(f):\n            return \"nan\"\n        if np.isposinf(f):\n            return \"inf\"\n        if np.isneginf(f):\n            return \"-inf\"\n        if f == 0.0 and np.signbit(f):\n            return \"-0.0\"\n        return str(f)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test A (happy path, mixture)\n        [3.0, np.nan, -np.inf, np.inf, 2.5, -0.0, 0.0, -1.0, 1.0e-308, -1.0e-308, 0.5],\n        # Test B (boundary with only specials)\n        [np.nan, -np.inf, np.inf],\n        # Test C (zeros and subnormals)\n        [-0.0, 0.0, 5.0e-324, -5.0e-324],\n        # Test D (extreme finite magnitudes)\n        [1.7976931348623157e+308, -1.7976931348623157e+308, 2.2250738585072014e-308, -2.2250738585072014e-308],\n    ]\n\n    results_str = []\n    for case in test_cases:\n        sorted_list = modified_bucket_sort(case)\n        formatted_list_str = \",\".join([format_float(x) for x in sorted_list])\n        results_str.append(f\"[{formatted_list_str}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```"
        }
    ]
}