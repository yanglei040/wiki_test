{
    "hands_on_practices": [
        {
            "introduction": "理论是抽象的，但代码是具体的。在本节中，我们将通过一个经典的例子——归并排序，来直观地理解稳定性。归并排序的稳定性完全取决于其合并（merge）操作中的一个关键细节。这个练习将让你亲身体验一个看似微不足道的比较符错误（使用 $\\lt$ 而非 $\\le$）是如何破坏稳定性的，从而让你对稳定性的实现机制有更深刻的认识。",
            "id": "3273649",
            "problem": "给定一个记录数组，每个记录是一个由整数键和标识符组成的对。数组长度为 $n$。目标是按键的升序对数组进行排序，同时保持键相等的记录的相对顺序，这就是稳定性的定义：对于任何索引 $i$ 和 $j$（其中 $0 \\le i  j  n$），如果键满足 $k_i = k_j$，那么在输出中，源自索引 $i$ 的记录必须位于源自索引 $j$ 的记录之前。形式上，设输入序列为 $A = \\langle a_0, a_1, \\dots, a_{n-1} \\rangle$，其中每个 $a_t = (k_t, \\mathrm{id}_t)$。如果对于所有 $i, j$（其中 $0 \\le i  j  n$ 且 $k_i = k_j$），输出序列 $B$ 将 $a_i$ 放在 $a_j$ 之前，则该排序算法是稳定的。\n\n考虑一个使用合并操作来组合两个已排序半区的递归分治排序过程。合并操作比较两个半区头部的键，并一次将一个记录移入输出。如果合并操作在键相等时总是从右半区选择，那么一个细微的错误可能会破坏稳定性，这种情况可能发生在选择规则不当地使用了严格小于号 $$ 时。具体来说，如果合并操作仅在左键严格小于右键时才取左侧元素，否则取右侧元素，那么当键相等时，会首先取右侧元素，这在相等键被分割到两个半区时会破坏稳定性。\n\n任务：\n- 在 `(k, id)` 对的数组上实现两个排序过程：\n  1. 一个有问题的归并排序，由于其合并操作使用严格小于号 $$ 来决定从左半区取哪个元素而导致不稳定。具体来说，在合并期间，如果左键 $k_L$ 和右键 $k_R$ 满足 $k_L  k_R$，则从左边取；否则从右边取。\n  2. 一个修正后的稳定归并排序，其合并操作确保当 $k_L \\le k_R$ 时从左边取，从而在合并过程中保持键相等记录的相对顺序。\n- 对于每个测试用例，输出三项内容：\n  1. 应用有问题的归并排序后的标识符序列 $\\langle \\mathrm{id} \\rangle$。\n  2. 应用修正后的稳定归并排序后的标识符序列 $\\langle \\mathrm{id} \\rangle$。\n  3. 一个布尔值，指示修正后的稳定归并排序是否保持了键相等记录的原始相对顺序。此布尔值必须通过比较输入和输出中每个键值 $v$ 对应的标识符序列来计算。\n\n基本原理和约束：\n- 使用上面所述的稳定性的核心定义：对于所有 $i, j$（其中 $0 \\le i  j  n$ 且 $k_i = k_j$），输出必须将来自索引 $i$ 的元素放在来自索引 $j$ 的元素之前。\n- 目标是修正合并决策，使稳定属性对所有输入都成立，并在精心选择的测试用例上展示其差异。\n\n测试套件：\n使用以下六个测试用例，每个都是一个 `(k, id)` 对的列表，其中标识符 `id` 是其在列表中的原始位置：\n- 测试用例 1（包含跨越半区的相等键的通用混合）：$[(3,0),(1,1),(2,2),(1,3),(2,4),(3,5),(1,6)]$。\n- 测试用例 2（所有键都不同）：$[(5,0),(1,1),(3,2),(4,3),(2,4)]$。\n- 测试用例 3（所有键都相等）：$[(1,0),(1,1),(1,2),(1,3),(1,4)]$。\n- 测试用例 4（跨越半区的重复块）：$[(1,0),(1,1),(2,2),(2,3),(1,4),(1,5),(2,6),(2,7)]$。\n- 测试用例 5（空输入）：$[]$。\n- 测试用例 6（单个元素）：$[(42,0)]$。\n\n最终输出格式：\n你的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，列表内无空格。每个元素对应一个测试用例，本身是一个形如 $[L_b,L_f,S]$ 的三元组，其中 $L_b$ 是有问题的排序后的标识符列表，$L_f$ 是修正后的稳定排序后的标识符列表，$S$ 是对修正后排序的稳定性检查布尔值。例如，最外层的列表应看起来像 $[[\\dots],[\\dots],\\dots]$，且任何地方都没有空格。",
            "solution": "该问题要求对稳定和不稳定排序进行分析和实现，特别关注归并排序算法。排序的稳定性要求键相等的元素在排序后的输出中必须保持其原始的相对顺序。我们将实现归并排序的两个变体：一个被故意破坏以使其不稳定，另一个则被正确实现以保证稳定性。两者区别在于合并子程序中的一个比较运算符。\n\n如果对于输入序列 $A = \\langle a_0, a_1, \\dots, a_{n-1} \\rangle$ 中的任意两个记录，例如 $a_i = (k_i, \\mathrm{id}_i)$ 和 $a_j = (k_j, \\mathrm{id}_j)$，其中 $0 \\le i  j  n$，条件 $k_i = k_j$ 蕴含 $a_i$ 在排序后的输出序列中必须出现在 $a_j$ 之前，那么该排序算法被定义为稳定的。\n\n归并排序算法遵循分治范式：\n1.  **分解 (Divide)**：将大小为 $n$ 的输入数组分成两个大小约为 $n/2$ 的子数组。\n2.  **解决 (Conquer)**：通过对两个子数组递归调用归并排序来对它们进行排序。\n3.  **合并 (Combine)**：将两个已排序的子数组合并成一个单一的有序数组。\n\n归并排序的稳定性完全由“合并”步骤决定。设待合并的两个已排序子数组为 $L$（左）和 $R$（右）。在被处理的数组段中，$L$ 中的每个元素原本都出现在 $R$ 中每个元素之前。为了保持稳定性，如果我们遇到一个来自 $L$ 的元素 $l$ 和一个来自 $R$ 的元素 $r$，使得它们的键相等，$key(l) = key(r)$，那么必须将来自左子数组的元素 $l$ 放入输出中，且位置在 $r$ 之前。\n\n**修正后的稳定合并逻辑**\n\n合并操作迭代遍历 $L$ 和 $R$，重复比较两个子数组当前头部的元素，并将较小的那个移动到输出中。为确保稳定性，比较必须是非严格的。设当前来自 $L$ 的元素为 $l$，其键为 $k_L$，来自 $R$ 的元素为 $r$，其键为 $k_R$。稳定合并的规则是：\n\n如果 $k_L \\le k_R$，取来自 $L$ 的元素 $l$。否则，取来自 $R$ 的元素 $r$。\n\n当 $k_L = k_R$ 时，此规则正确地选择了来自左子数组的元素 $l$，从而保留了原始相对顺序并保证了稳定性。\n\n**有问题的非稳定合并逻辑**\n\n问题描述了一个有错误的实现，其中比较是严格的：\n\n如果 $k_L  k_R$，取来自 $L$ 的元素 $l$。否则，取来自 $R$ 的元素 $r$。\n\n让我们分析键相等的情况，$k_L = k_R$。条件 $k_L  k_R$ 为假。`else` 分支被执行，导致来自右子数组的元素 $r$ 被选择并放入输出中，位置在 $l$ 之前。由于 $l$ 原本在 $r$ 之前，这个操作颠倒了它们的相对顺序，违反了稳定性的定义。这个错误虽然细微，但对于那些保持原始顺序至关重要的应用来说，会产生严重后果。\n\n**稳定性验证过程**\n\n要以编程方式验证修正后算法对给定测试用例的稳定性，我们必须确认键相等项的相对顺序没有改变。过程如下：\n1.  对于输入数组中存在的每个唯一键值 $v$，构建一个包含所有具有该键的记录的标识符列表，顺序与它们出现的顺序一致。设此为 $\\mathrm{IDs}_{\\text{input}}(v)$。\n2.  类似地，对于每个唯一键值 $v$，从排序算法的输出中构建一个标识符列表。设此为 $\\mathrm{IDs}_{\\text{output}}(v)$。\n3.  当且仅当对于每个键 $v$，标识符序列完全相同：$\\mathrm{IDs}_{\\text{input}}(v) = \\mathrm{IDs}_{\\text{output}}(v)$，该算法才是稳定的。如果此条件对所有键都成立，最终的布尔结果 $S$ 为真，否则为假。\n\n我们将应用这整个过程——实现两种合并变体，对测试用例进行排序，并执行稳定性检查——以展示稳定与非稳定方法之间的实际差异。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import defaultdict\n\ndef broken_merge(left, right):\n    \"\"\"\n    Merges two sorted numpy arrays unstably.\n    Takes the right element if keys are equal.\n    \"\"\"\n    if len(left) == 0:\n        return right\n    if len(right) == 0:\n        return left\n\n    dtype = left.dtype\n    result = np.empty(len(left) + len(right), dtype=dtype)\n    i, j, k = 0, 0, 0\n\n    while i  len(left) and j  len(right):\n        # Unstable condition: left key must be strictly less than right key\n        if left[i]['key']  right[j]['key']:\n            result[k] = left[i]\n            i += 1\n        else: # This includes the case left['key'] >= right['key']\n            result[k] = right[j]\n            j += 1\n        k += 1\n\n    while i  len(left):\n        result[k] = left[i]\n        i += 1\n        k += 1\n\n    while j  len(right):\n        result[k] = right[j]\n        j += 1\n        k += 1\n\n    return result\n\ndef stable_merge(left, right):\n    \"\"\"\n    Merges two sorted numpy arrays stably.\n    Takes the left element if keys are equal or less.\n    \"\"\"\n    if len(left) == 0:\n        return right\n    if len(right) == 0:\n        return left\n\n    dtype = left.dtype\n    result = np.empty(len(left) + len(right), dtype=dtype)\n    i, j, k = 0, 0, 0\n\n    while i  len(left) and j  len(right):\n        # Stable condition: left key is less than or equal to right key\n        if left[i]['key'] = right[j]['key']:\n            result[k] = left[i]\n            i += 1\n        else:\n            result[k] = right[j]\n            j += 1\n        k += 1\n\n    while i  len(left):\n        result[k] = left[i]\n        i += 1\n        k += 1\n\n    while j  len(right):\n        result[k] = right[j]\n        j += 1\n        k += 1\n\n    return result\n\ndef mergesort(arr, merge_func):\n    \"\"\"\n    Recursive mergesort implementation using a provided merge function.\n    \"\"\"\n    if len(arr) = 1:\n        return arr\n\n    mid = len(arr) // 2\n    left = mergesort(arr[:mid], merge_func)\n    right = mergesort(arr[mid:], merge_func)\n\n    return merge_func(left, right)\n\ndef check_stability(original_arr, sorted_arr):\n    \"\"\"\n    Verifies if the sort was stable by comparing relative order of equal-keyed items.\n    \"\"\"\n    if len(original_arr) == 0:\n        return True\n        \n    original_groups = defaultdict(list)\n    for record in original_arr:\n        original_groups[record['key']].append(record['id'])\n\n    sorted_groups = defaultdict(list)\n    for record in sorted_arr:\n        sorted_groups[record['key']].append(record['id'])\n\n    for key in original_groups:\n        if original_groups[key] != sorted_groups[key]:\n            return False\n            \n    return True\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [(3,0),(1,1),(2,2),(1,3),(2,4),(3,5),(1,6)],\n        [(5,0),(1,1),(3,2),(4,3),(2,4)],\n        [(1,0),(1,1),(1,2),(1,3),(1,4)],\n        [(1,0),(1,1),(2,2),(2,3),(1,4),(1,5),(2,6),(2,7)],\n        [],\n        [(42,0)],\n    ]\n\n    dtype = [('key', int), ('id', int)]\n    results = []\n    \n    for case in test_cases:\n        if not case:\n            # Handle empty list case\n            results.append([[], [], True])\n            continue\n\n        arr = np.array(case, dtype=dtype)\n        \n        # 1. Broken mergesort\n        broken_sorted_arr = mergesort(arr.copy(), broken_merge)\n        L_b = broken_sorted_arr['id'].tolist()\n\n        # 2. Corrected stable mergesort\n        stable_sorted_arr = mergesort(arr.copy(), stable_merge)\n        L_f = stable_sorted_arr['id'].tolist()\n        \n        # 3. Stability check\n        S = check_stability(arr, stable_sorted_arr)\n        \n        results.append([L_b, L_f, S])\n\n    # Final print statement in the exact required format (no spaces).\n    results_str_parts = []\n    for L_b, L_f, S in results:\n        lb_str = f\"[{','.join(map(str, L_b))}]\"\n        lf_str = f\"[{','.join(map(str, L_f))}]\"\n        s_str = 'True' if S else 'False'\n        results_str_parts.append(f\"[{lb_str},{lf_str},{s_str}]\")\n    \n    final_output = f\"[{','.join(results_str_parts)}]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "在实践中识别出不稳定的行为后，我们需要一个更严谨的方式来定义和验证稳定性。此练习将稳定性形式化为一个基于“（键，原始位置）”二元组的字典序比较规则。你将扮演一个“验证者”的角色，检查一个给定的交换操作序列是否遵循了稳定排序算法（如冒泡排序）的严格规则，这能帮助你从操作层面深入理解稳定性的本质。",
            "id": "3273737",
            "problem": "给定一个初始记录数组和一系列有限的交换操作。每个记录都有一个键和一个隐式的原始位置，即它在初始数组中的索引。如果对于任意两个键相等的记录，它们在输出中的相对顺序与输入中相同，则该排序算法称为稳定排序算法。形式上，设每个记录用 $x$ 表示，其键为 $\\kappa(x)$，原始位置为 $\\tau(x)$。通过字典序规则定义稳定比较器顺序 $\\prec_{\\text{stab}}$：对于任意两个记录 $x$ 和 $y$，$x \\prec_{\\text{stab}} y$ 当且仅当 $\\left(\\kappa(x),\\tau(x)\\right)$ 在字典序上小于 $\\left(\\kappa(y),\\tau(y)\\right)$。一个只交换相对于 $\\prec_{\\text{stab}}$ 乱序的相邻记录的相邻交换序列，构成了一个稳定相邻交换排序过程的规范模型，因为这样的过程从不违背其原始位置重新排序键值相等的记录，并且严格减少在 $\\prec_{\\text{stab}}$ 下的逆序数，直到达到一个 $\\prec_{\\text{stab}}$ 有序的数组。\n\n你将收到几个测试用例。对于每个测试用例，你必须判断所提供的交换序列是否可能由某个在给定输入上运行的稳定相邻交换排序算法生成（也就是说，每次交换是否都在相邻位置之间，并且交换的是当前在 $\\prec_{\\text{stab}}$ 下乱序的一对，以及在应用所有交换后，最终数组是否在 $\\prec_{\\text{stab}}$ 下有序）。你的程序应该在输入上模拟这些交换并检查这些条件。\n\n使用的基本原理：\n- 稳定性的定义：一个排序算法是稳定的，如果对于所有记录 $x$ 和 $y$，当 $\\kappa(x) = \\kappa(y)$ 且 $\\tau(x)  \\tau(y)$ 时，输出满足 $x$ 在 $y$ 之前。\n- 字典序：对于数对 $\\left(a,b\\right)$ 和 $\\left(c,d\\right)$，如果 $a  c$ 或者 ($a=c$ 且 $b  d$)，则 $\\left(a,b\\right)$ 在字典序上小于 $\\left(c,d\\right)$。\n- 稳定相邻交换排序算法生成的一个交换序列 $(i_t,j_t)$ 必须对每个 $t$ 满足三个条件：\n  1. 邻接性：$|i_t-j_t|=1$。\n  2. 局部乱序：交换前，位置 $\\min(i_t,j_t)$ 的记录 $a$ 和位置 $\\max(i_t,j_t)$ 的记录 $b$ 必须满足 $b \\prec_{\\text{stab}} a$。\n  3. 最终有序性：应用所有交换后，最终数组在 $\\prec_{\\text{stab}}$ 下是有序的。\n\n任务：\n- 编写一个程序，该程序接受一个键数组 $K$ 和一个交换索引对序列 $S$，并返回一个布尔值，指示该序列是否满足上述三个条件。\n- 使用以下五个测试用例运行您的程序。对于每个测试用例 $T_i = (K_i, S_i)$，计算一个布尔结果 $B_i$。\n\n测试套件：\n- $T_1 = \\left([3,1,1,2], [(0,1),(1,2),(2,3)]\\right)$\n- $T_2 = \\left([2,2,1], [(0,1),(1,2)]\\right)$\n- $T_3 = \\left([2,1,3], [(0,2)]\\right)$\n- $T_4 = \\left([3,2,1], [(0,1)]\\right)$\n- $T_5 = \\left([1,1,2,3], []\\right)$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的布尔值列表，列表内无空格：$[B_1,B_2,B_3,B_4,B_5]$。不应打印任何额外文本。",
            "solution": "我们从定义开始。一个稳定的排序算法会保留键值相等记录的相对顺序。形式上，设每个记录 $x$ 有一个键 $\\kappa(x)$ 和一个原始位置 $\\tau(x)$，并定义记录 $x$ 和 $y$ 上的顺序 $\\prec_{\\text{stab}}$ 为：$x \\prec_{\\text{stab}} y$ 当且仅当 $\\left(\\kappa(x),\\tau(x)\\right)$ 在字典序上小于 $\\left(\\kappa(y),\\tau(y)\\right)$。这将稳定性要求转化为输出序列相对于 $\\prec_{\\text{stab}}$ 是非递减的性质。特别地，如果 $\\kappa(x)=\\kappa(y)$ 且 $\\tau(x)\\tau(y)$，则 $x \\prec_{\\text{stab}} y$，这确保了键值相等的记录在排序后的输出中必须以其原始顺序出现。\n\n考虑在 $\\prec_{\\text{stab}}$ 下运行的相邻交换排序过程；这样的过程在每一步检查相邻位置，并且仅当右邻居 $b$ 严格小于左邻居 $a$（根据 $\\prec_{\\text{stab}}$，即 $b \\prec_{\\text{stab}} a$）时才交换它们。这是诸如冒泡排序等方法的局部规则，当比较操作将相等的键视为非乱序时，冒泡排序是稳定的。两个关键观察确立了我们可行性标准的原则性正确性：\n\n1. 通过字典序比较器实现的局部合法性，可以防止以不稳定的方式重新排序键值相等的记录。如果两个相邻记录的键相等，比如 $\\kappa(a)=\\kappa(b)$，那么比较器就简化为比较 $\\tau(a)$ 和 $\\tau(b)$。因为初始的 $\\tau$ 值反映了原始顺序并且永不改变，如果 $a$ 在数组中位于 $b$ 之前，则 $\\tau(a)  \\tau(b)$，因此 $a \\prec_{\\text{stab}} b$。所以 $b \\prec_{\\text{stab}} a$ 为假，一个稳定的相邻交换算法不会交换处于原始顺序的键值相等的邻居。因此，任何在已经处于原始顺序的键值相等的邻居之间的交换都违反了局部乱序条件，我们的可行性检查会拒绝这种情况。\n\n2. 每次有效的相邻交换都会严格减少在 $\\prec_{\\text{stab}}$ 下的逆序数。定义一个序列 $\\left(z_0,\\dots,z_{n-1}\\right)$ 在 $\\prec_{\\text{stab}}$ 下的逆序数 $I$ 为索引对 $\\left(i,j\\right)$ 的数量，其中 $0 \\le i  j \\le n-1$ 且 $z_j \\prec_{\\text{stab}} z_i$。如果我们交换满足 $b \\prec_{\\text{stab}} a$ 的相邻元素 $a$ 和 $b$，那么这对元素之间恰好一个逆序被消除，并且不会在非相邻元素之间引入新的逆序，因为 $a$ 向右移动一个位置，$b$ 向左移动一个位置；冒泡排序正确性的标准论证形式化了这一过程，即这样的相邻交换会单调递减 $I$ 直到 $I=0$，这等价于序列在 $\\prec_{\\text{stab}}$ 下有序。\n\n根据这些原则，对于一个交换序列要能由一个稳定的相邻交换排序算法产生，以下可行性标准是必要的：\n\n- 邻接性，即 $|i_t-j_t|=1$，确保交换是像冒泡排序和类似稳定方法那样的局部邻居交换。\n- 局部乱序条件，即交换前 $b \\prec_{\\text{stab}} a$，确保每次交换在编码了稳定性的比较器下是合法的，从而防止交换处于原始顺序的键值相等的项，并保证逆序数的减少。\n- 最终有序性确保交换序列确实完成了在 $\\prec_{\\text{stab}}$ 下的排序过程。\n\n它们在以下意义上也是充分的：如果序列中的每次交换都满足邻接性和局部合法性，并且最终数组是 $\\prec_{\\text{stab}}$ 有序的，那么就存在一个稳定的相邻交换排序例程（例如，一个只扫描并交换乱序邻居的冒泡排序变体），它可以在给定的输入上精确地产生这个序列，因为任何以有序状态结束的合法相邻交换序列都可以通过按给定序列指示的顺序选择要检查的位置来实现。\n\n检查可行性的算法设计遵循以下原则：\n\n- 用数对 $\\left(\\kappa,\\tau\\right)$ 表示每个记录，其中 $\\tau$ 是初始索引。定义一个比较器，当 $\\left(\\kappa(x),\\tau(x)\\right)$ 在字典序上小于 $\\left(\\kappa(y),\\tau(y)\\right)$ 时，对于 $x \\prec_{\\text{stab}} y$ 返回真。\n- 模拟交换序列：\n  - 对于每次交换 $(i_t,j_t)$，通过检查 $|i_t-j_t|=1$ 来验证邻接性。\n  - 令 $p=\\min(i_t,j_t)$ 和 $q=\\max(i_t,j_t)$，并检查位置 $p$ 上的邻居 $a$ 和位置 $q$ 上的邻居 $b$。通过测试 $b \\prec_{\\text{stab}} a$ 来检查局部合法性；如果为假，则拒绝该序列。\n  - 执行位置 $p$ 和 $q$ 的交换。\n- 处理完所有交换后，检查最终有序性：对于每对连续位置 $(r,r+1)$，确保位置 $r$ 的记录不大于位置 $r+1$ 的记录（在 $\\prec_{\\text{stab}}$ 下），等价于对所有 $r$ 检查 $\\neg\\left(z_{r+1} \\prec_{\\text{stab}} z_r\\right)$。\n\n将此应用于给定的测试套件：\n\n- 测试用例 1：$K=[3,1,1,2]$, $S=[(0,1),(1,2),(2,3)]$。每次交换都是相邻且局部合法的：$3$ 与 $1$ 交换，然后 $3$ 与下一个 $1$ 交换，再然后 $3$ 与 $2$ 交换。最终数组在 $\\prec_{\\text{stab}}$ 下有序，键值相等的 $1$ 记录保持原始顺序。结果为 $\\text{True}$。\n- 测试用例 2：$K=[2,2,1]$, $S=[(0,1),(1,2)]$。第一次交换试图交换原始位置为 $\\tau=0$ 和 $\\tau=1$ 的键值相等的邻居 $2$，它们在 $\\prec_{\\text{stab}}$ 下并非乱序。局部合法性检查失败。结果为 $\\text{False}$。\n- 测试用例 3：$K=[2,1,3]$, $S=[(0,2)]$。由于 $|0-2|=2$，该交换不是相邻的。邻接性检查失败。结果为 $\\text{False}$。\n- 测试用例 4：$K=[3,2,1]$, $S=[(0,1)]$。单次交换是相邻且局部合法的（$2 \\prec_{\\text{stab}} 3$），但最终数组 $[2,3,1]$ 在 $\\prec_{\\text{stab}}$ 下不是有序的。最终有序性检查失败。结果为 $\\text{False}$。\n- 测试用例 5：$K=[1,1,2,3], S=[]$。没有执行任何交换；初始数组在 $\\prec_{\\text{stab}}$ 下已经有序。所有标准均通过。结果为 $\\text{True}$。\n\n因此，程序按顺序输出对应于每个测试用例的布尔值列表，用方括号括起来并以逗号分隔。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nfrom typing import List, Tuple\n\ndef stable_less(a: Tuple[int, int], b: Tuple[int, int]) -> bool:\n    \"\"\"\n    Return True iff record a is less than record b under the stable comparator.\n    Records are tuples (key, original_index).\n    Lexicographic comparison on (key, original_index).\n    \"\"\"\n    # Compare keys first, then original indices for tie-breaking.\n    if a[0] != b[0]:\n        return a[0]  b[0]\n    return a[1]  b[1]\n\ndef is_stable_adjacent_swap_sequence(keys: List[int], swaps: List[Tuple[int, int]]) -> bool:\n    \"\"\"\n    Check whether the given swap sequence could have been generated by\n    a stable adjacent-swap sorting algorithm on the given keys.\n\n    Conditions:\n    - Each swap is between adjacent positions.\n    - Each swap exchanges a locally out-of-order adjacent pair under the stable comparator.\n    - After all swaps, the array is sorted under the stable comparator.\n    \"\"\"\n    # Build records (key, original_index)\n    arr = [(k, i) for i, k in enumerate(keys)]\n\n    n = len(arr)\n\n    # Simulate swaps\n    for (i, j) in swaps:\n        # Bounds check\n        if not (0 = i  n and 0 = j  n):\n            return False\n        # Adjacency check\n        if abs(i - j) != 1:\n            return False\n\n        p = min(i, j)\n        q = max(i, j)\n        a = arr[p]\n        b = arr[q]\n\n        # Local out-of-order check: swap only if b  a under stable comparator\n        if not stable_less(b, a):\n            return False\n\n        # Perform swap\n        arr[p], arr[q] = arr[q], arr[p]\n\n    # Final sortedness check: ensure the array is nondecreasing under stable comparator\n    for r in range(n - 1):\n        if stable_less(arr[r + 1], arr[r]):\n            return False\n\n    return True\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1: Happy path, valid stable adjacent swaps (bubble-like).\n        ([3, 1, 1, 2], [(0, 1), (1, 2), (2, 3)]),\n        # Test case 2: Invalid because swapping equal-key neighbors in original order.\n        ([2, 2, 1], [(0, 1), (1, 2)]),\n        # Test case 3: Invalid due to non-adjacent swap.\n        ([2, 1, 3], [(0, 2)]),\n        # Test case 4: Valid local swap but incomplete sorting; final array not sorted.\n        ([3, 2, 1], [(0, 1)]),\n        # Test case 5: Already sorted, no swaps; valid.\n        ([1, 1, 2, 3], []),\n    ]\n\n    results = []\n    for keys, swaps in test_cases:\n        result = is_stable_adjacent_swap_sequence(keys, swaps)\n        results.append(result)\n\n    # Final print statement in the exact required format (no spaces).\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "理解了稳定性的定义和验证方法后，真正的挑战在于亲手设计一个稳定的算法。这个练习要求你为通用记录（而不仅仅是整数）设计并实现一个稳定的计数排序。由于计数排序不是基于比较的，你必须创造性地思考如何利用键的频率计数来确定每个元素的最终位置，同时确保键值相同的元素保持其原始相对顺序，从而将稳定性的原则应用到一个全新的场景中。",
            "id": "3273671",
            "problem": "您的任务是为通用记录（对象）序列设计并实现一个基于整数键频率计数的稳定排序算法。目标是根据提取的整数键进行排序，同时保持具有相同键的记录的相对顺序。您必须实现一个完整、可运行的程序，该程序构建指定的测试套件，应用您的排序过程，为每个测试用例验证正确性和稳定性，并以要求的聚合输出格式打印结果。\n\n用于推理和验证的基本定义如下：\n- 排序算法接受一个长度为 $n$ 的序列 $S$，并产生一个排列 $S'$，使得选定的键函数 $K$ 在 $S'$ 上是非递减的。形式上，对于所有索引 $i$（其中 $0 \\le i  n-1$），$K(S'[i]) \\le K(S'[i+1])$。\n- 如果一个排序算法是稳定的，那么对于任意两个键值相等的记录 $x$ 和 $y$（$K(x) = K(y)$），若 $x$ 在原始序列 $S$ 中出现在 $y$ 之前，则在输出序列 $S'$ 中 $x$ 也必须出现在 $y$ 之前。\n\n要求的行为和约束：\n- 您的算法必须能对任意记录进行排序，每个记录至少包含一个标识符字段、一个键字段和一个任意的负载字段。键字段是由一个提取函数 $K$ 生成的整数。\n- 假设键是位于指定闭区间 $[k_{\\min}, k_{\\max}]$ 内的整数。如果任何记录的键超出了 $[k_{\\min}, k_{\\max}]$ 范围，则将该情况视为无效，并报告该测试用例失败。\n- 算法必须是稳定的，并且必须基于键的频率计数（即，使用键域上的计数来确定位置）。它必须能够通过适当地处理键范围 $[k_{\\min}, k_{\\max}]$ 来处理负数键。\n\n每个测试用例的验证标准：\n- 有序性：输出序列 $S'$ 必须对所有有效索引 $i$ 满足 $K(S'[i]) \\le K(S'[i+1])$。\n- 稳定性：对于键域中的每个值 $v$，考虑 $S$ 中键等于 $v$ 的记录的标识符子序列。在输出 $S'$ 中，与键 $v$ 关联的标识符必须以与它们在 $S$ 中完全相同的相对顺序出现。\n\n要实现的测试套件：\n使用以下六个测试用例。每个记录被描述为一个三元组 $(\\text{id}, \\text{key}, \\text{payload})$，其中 $\\text{id}$ 是唯一标识符，$\\text{key}$ 是整数键，$\\text{payload}$ 是任意字符串。\n\n- 测试用例 1（一般情况，包含重复和多个键，正常路径）：\n  - 序列 $S_1$：$(\\text{id}=0,\\text{key}=3,\\text{payload}='a')$, $(\\text{id}=1,\\text{key}=1,\\text{payload}='b')$, $(\\text{id}=2,\\text{key}=2,\\text{payload}='c')$, $(\\text{id}=3,\\text{key}=1,\\text{payload}='d')$, $(\\text{id}=4,\\text{key}=3,\\text{payload}='e')$, $(\\text{id}=5,\\text{key}=0,\\text{payload}='f')$, $(\\text{id}=6,\\text{key}=2,\\text{payload}='g')$, $(\\text{id}=7,\\text{key}=0,\\text{payload}='h')$, $(\\text{id}=8,\\text{key}=3,\\text{payload}='i')$。\n  - 范围：$[k_{\\min}, k_{\\max}] = [0, 3]$。\n\n- 测试用例 2（所有键相等，测试纯粹的稳定性）：\n  - 序列 $S_2$：$(\\text{id}=0,\\text{key}=5,\\text{payload}='x')$, $(\\text{id}=1,\\text{key}=5,\\text{payload}='y')$, $(\\text{id}=2,\\text{key}=5,\\text{payload}='z')$。\n  - 范围：$[k_{\\min}, k_{\\max}] = [5, 5]$。\n\n- 测试用例 3（从负到正的键，边界覆盖）：\n  - 序列 $S_3$：$(\\text{id}=0,\\text{key}=-3,\\text{payload}='a')$, $(\\text{id}=1,\\text{key}=-1,\\text{payload}='b')$, $(\\text{id}=2,\\text{key}=-3,\\text{payload}='c')$, $(\\text{id}=3,\\text{key}=0,\\text{payload}='d')$, $(\\text{id}=4,\\text{key}=2,\\text{payload}='e')$, $(\\text{id}=5,\\text{key}=-1,\\text{payload}='f')$。\n  - 范围：$[k_{\\min}, k_{\\max}] = [-3, 2]$。\n\n- 测试用例 4（空序列，边界情况）：\n  - 序列 $S_4$：空序列。\n  - 范围：$[k_{\\min}, k_{\\max}] = [0, 0]$。\n\n- 测试用例 5（因键超出范围而无效，错误检测）：\n  - 序列 $S_5$：$(\\text{id}=0,\\text{key}=0,\\text{payload}='a')$, $(\\text{id}=1,\\text{key}=10,\\text{payload}='b')$, $(\\text{id}=2,\\text{key}=5,\\text{payload}='c')$。\n  - 范围：$[k_{\\min}, k_{\\max}] = [0, 5]$。\n  - 一条记录的 $\\text{key} = 10$，超出了 $[0, 5]$ 的范围。此测试用例的预期布尔值为失败。\n\n- 测试用例 6（键不连续，键域中存在间隙）：\n  - 序列 $S_6$：$(\\text{id}=0,\\text{key}=4,\\text{payload}='a')$, $(\\text{id}=1,\\text{key}=0,\\text{payload}='b')$, $(\\text{id}=2,\\text{key}=4,\\text{payload}='c')$, $(\\text{id}=3,\\text{key}=2,\\text{payload}='d')$, $(\\text{id}=4,\\text{key}=2,\\text{payload}='e')$, $(\\text{id}=5,\\text{key}=0,\\text{payload}='f')$。\n  - 范围：$[k_{\\min}, k_{\\max}] = [0, 4]$。\n\n程序输出规范：\n- 对于每个测试用例 $i \\in \\{1, 2, 3, 4, 5, 6\\}$，计算一个布尔值，该值为 $true$ 当且仅当：\n  - 排序结果按键非递减，并且\n  - 排序结果保持了键值相等记录的相对顺序（稳定性），并且\n  - 所有键都在指定的范围 $[k_{\\min}, k_{\\max}]$ 内。\n  否则，该布尔值必须为 $false$。\n- 您的程序应产生单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，“[true,false,true,...]”）。列表中的每个条目应使用编程语言的原生布尔格式。不应打印任何额外文本。",
            "solution": "问题要求设计并实现一个基于键频率计数的稳定排序算法，该算法适用于具有整数键的记录序列。其实现必须根据有序性、稳定性以及对指定键范围 $[k_{\\min}, k_{\\max}]$ 的遵守情况进行验证。\n\n指定的要求直接导向对 **Counting Sort** 算法的改编。标准的 Counting Sort 是为已知有界范围内的整数设计的。为了满足问题的约束，我们必须将其泛化，以处理任意记录类型、确保稳定性，并管理可能包含负数的键范围 $[k_{\\min}, k_{\\max}]$。\n\n对于给定的长度为 $n$ 的输入序列 $S$ 和键范围 $[k_{\\min}, k_{\\max}]$，验证和排序过程按以下步骤进行。\n\n**步骤 1：输入验证（键范围检查）**\n这是排序的先决条件。算法必须首先遍历输入序列 $S$，以确保所有记录的键都在指定的闭区间 $[k_{\\min}, k_{\\max}]$ 内。\n设 $x$ 为 $S$ 中的一个记录，其整数键为 $K(x)$。我们必须验证对于所有 $x \\in S$，条件 $k_{\\min} \\le K(x) \\le k_{\\max}$ 都成立。如果任何记录违反了此条件，则该测试用例被视为无效，并且该用例的处理以 `false` 结果终止。\n\n**步骤 2：算法设计 - 稳定计数排序**\n\n如果输入有效，我们继续使用 Counting Sort 的稳定变体。其核心思想是使用一个辅助数组来存储每个键的计数，然后利用这些计数来确定每个记录在最终排序序列中的正确位置。为了处理任意整数范围 $[k_{\\min}, k_{\\max}]$，我们将键映射到从零开始的索引。\n\n设键域的大小为 $L = k_{\\max} - k_{\\min} + 1$。我们将使用一个大小为 $L$ 的辅助 `counts` 数组。输入中的键 $k$ 将映射到此数组中的索引 $i = k - k_{\\min}$。\n\n**2a. 频率计数**\n我们创建一个大小为 $L$ 的 `counts` 数组，并全部初始化为零。然后我们遍历输入序列 $S$。对于每个记录 $x$，我们增加其键 $K(x)$ 对应的计数。\n`counts[K(x) - k_{min}] \\leftarrow counts[K(x) - k_{min}] + 1`\n\n此阶段之后，`counts[i]` 存储了键为 $k = i + k_{\\min}$ 的记录数量。\n\n**2b. 累积位置计算（前缀和）**\n为了确定最终位置，我们将 `counts` 数组转换为一个存储每个键组*结束*位置的结构。这是通过计算前缀和来实现的。\n`for i from 1 to L-1:`\n  `counts[i] \\leftarrow counts[i] + counts[i-1]`\n\n转换后，`counts[i]` 持有键小于或等于 $k = i + k_{\\min}$ 的记录总数。这个值对应于排序输出中键为 $k$ 的记录的最后一个位置的*后一个*索引。例如，如果 `counts[i] = 5`，这意味着键为 $k=i+k_{\\min}$ 的记录应占据直到索引 $4$ 的位置。\n\n**2c. 输出放置与稳定性**\n我们创建一个与输入 $S$ 大小相同（即 $n$）的新输出序列 $S'$。为确保稳定性，我们必须通过从索引 $n-1$ 向下到 $0$ 的**逆序**遍历原始输入序列 $S$ 来将记录放入 $S'$。\n\n对于以逆序处理的每个记录 $x_j$（在 $S$ 中的索引为 $j$）：\n1. 提取其键 $k = K(x_j)$。\n2. 计算 `counts` 数组中的相应索引：$i = k - k_{\\min}$。\n3. 此记录在输出序列中的起始位置由 `counts[i] - 1` 给出。\n4. 将记录 $x_j$ 放入输出序列中：$S'[counts[i] - 1] \\leftarrow x_j$。\n5. 将该键的计数减一：`counts[i] \\leftarrow counts[i] - 1`。这可以确保下一个遇到的具有相同键的记录（该记录在原始序列 $S$ 中必须出现得更早）将被放置在前一个紧邻的槽位，从而保持它们的相对顺序。\n\n这种逆序放置是保证稳定性的关键机制。\n\n**步骤 3：验证**\n在生成排序后的序列 $S'$ 后，我们必须根据问题的标准验证其正确性。\n\n**3a. 有序性验证**\n从索引 $j = 0$ 到 $n-2$ 遍历 $S'$，并确认对于所有 $j$ 都有 $K(S'[j]) \\le K(S'[j+1])$。任何一个违反都会使结果无效。\n\n**3b. 稳定性验证**\n为验证稳定性，我们必须确认具有相同键的记录的相对顺序得到了保留。这可以通过以下方式完成：\n1. 对于输入中存在的每个不同键值 $k$，从 $S$ 中提取具有该键的记录的标识符子序列。设其为 $ID_{orig}(k)$。\n2. 同样，对于每个键值 $k$，从排序后的输出 $S'$ 中提取具有该键的记录的标识符子序列。设其为 $ID_{sorted}(k)$。\n3. 当且仅当对于所有键值 $k$ 都有 $ID_{orig}(k) = ID_{sorted}(k)$ 时，排序是稳定的。\n\n如果初始的范围检查、有序性检查和稳定性检查全部通过，则该测试用例的结果为 `true`。否则为 `false`。对于空输入序列，所有检查均无条件通过，结果为 `true`。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import defaultdict\n\ndef solve():\n    \"\"\"\n    Main function to define, run, and verify test cases for the stable counting sort.\n    \"\"\"\n\n    # Record is represented as a dictionary: {'id': int, 'key': int, 'payload': str}\n    \n    # Test case 1 (general case with duplicates and multiple keys, happy path)\n    s1 = [\n        {'id': 0, 'key': 3, 'payload': 'a'}, {'id': 1, 'key': 1, 'payload': 'b'},\n        {'id': 2, 'key': 2, 'payload': 'c'}, {'id': 3, 'key': 1, 'payload': 'd'},\n        {'id': 4, 'key': 3, 'payload': 'e'}, {'id': 5, 'key': 0, 'payload': 'f'},\n        {'id': 6, 'key': 2, 'payload': 'g'}, {'id': 7, 'key': 0, 'payload': 'h'},\n        {'id': 8, 'key': 3, 'payload': 'i'}\n    ]\n    r1 = (0, 3)\n\n    # Test case 2 (all keys equal, tests pure stability)\n    s2 = [\n        {'id': 0, 'key': 5, 'payload': 'x'}, {'id': 1, 'key': 5, 'payload': 'y'},\n        {'id': 2, 'key': 5, 'payload': 'z'}\n    ]\n    r2 = (5, 5)\n\n    # Test case 3 (negative to positive keys, boundary coverage)\n    s3 = [\n        {'id': 0, 'key': -3, 'payload': 'a'}, {'id': 1, 'key': -1, 'payload': 'b'},\n        {'id': 2, 'key': -3, 'payload': 'c'}, {'id': 3, 'key': 0, 'payload': 'd'},\n        {'id': 4, 'key': 2, 'payload': 'e'}, {'id': 5, 'key': -1, 'payload': 'f'}\n    ]\n    r3 = (-3, 2)\n\n    # Test case 4 (empty sequence, edge case)\n    s4 = []\n    r4 = (0, 0)\n    \n    # Test case 5 (invalid due to out-of-range key, error detection)\n    s5 = [\n        {'id': 0, 'key': 0, 'payload': 'a'}, {'id': 1, 'key': 10, 'payload': 'b'},\n        {'id': 2, 'key': 5, 'payload': 'c'}\n    ]\n    r5 = (0, 5)\n\n    # Test case 6 (non-contiguous keys with gaps in the key domain)\n    s6 = [\n        {'id': 0, 'key': 4, 'payload': 'a'}, {'id': 1, 'key': 0, 'payload': 'b'},\n        {'id': 2, 'key': 4, 'payload': 'c'}, {'id': 3, 'key': 2, 'payload': 'd'},\n        {'id': 4, 'key': 2, 'payload': 'e'}, {'id': 5, 'key': 0, 'payload': 'f'}\n    ]\n    r6 = (0, 4)\n\n    test_cases = [\n        (s1, r1), (s2, r2), (s3, r3), (s4, r4), (s5, r5), (s6, r6)\n    ]\n\n    results = []\n    for sequence, key_range in test_cases:\n        result = run_and_verify(sequence, key_range)\n        results.append(str(result).lower()) # Python bools are Capitalized\n\n    print(f\"[{','.join(results)}]\")\n\ndef stable_counting_sort(sequence, k_min, k_max):\n    \"\"\"\n    Implements a stable counting sort for a sequence of records.\n    Assumes keys have already been validated to be within the range [k_min, k_max].\n    \"\"\"\n    n = len(sequence)\n    if n == 0:\n        return []\n\n    range_size = k_max - k_min + 1\n    counts = np.zeros(range_size, dtype=int)\n    \n    # 1. Frequency Counting\n    for record in sequence:\n        key = record['key']\n        counts[key - k_min] += 1\n\n    # 2. Cumulative Position Calculation\n    for i in range(1, range_size):\n        counts[i] += counts[i-1]\n\n    # 3. Output Placement\n    output = [None] * n\n    for i in range(n - 1, -1, -1):\n        record = sequence[i]\n        key = record['key']\n        \n        pos_index = key - k_min\n        output_pos = counts[pos_index] - 1\n        \n        output[output_pos] = record\n        counts[pos_index] -= 1\n        \n    return output\n\ndef run_and_verify(sequence, key_range):\n    \"\"\"\n    Runs the sorting and verifies sortedness, stability, and key range constraints.\n    Returns a single boolean indicating if all criteria are met.\n    \"\"\"\n    k_min, k_max = key_range\n    \n    # 1. Key Range Validation\n    for record in sequence:\n        if not (k_min = record['key'] = k_max):\n            return False\n\n    # Handle empty sequence edge case\n    if not sequence:\n        return True\n\n    # Get sorted sequence\n    sorted_sequence = stable_counting_sort(list(sequence), k_min, k_max)\n    \n    # 2. Sortedness Verification\n    for i in range(len(sorted_sequence) - 1):\n        if sorted_sequence[i]['key'] > sorted_sequence[i+1]['key']:\n            return False\n            \n    # 3. Stability Verification\n    original_order = defaultdict(list)\n    for record in sequence:\n        original_order[record['key']].append(record['id'])\n        \n    sorted_order = defaultdict(list)\n    for record in sorted_sequence:\n        sorted_order[record['key']].append(record['id'])\n        \n    for key in original_order:\n        if original_order[key] != sorted_order[key]:\n            return False\n            \n    # All checks passed\n    return True\n\nsolve()\n```"
        }
    ]
}