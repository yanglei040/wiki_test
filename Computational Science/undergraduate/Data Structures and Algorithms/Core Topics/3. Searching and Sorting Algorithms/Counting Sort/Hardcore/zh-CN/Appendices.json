{
    "hands_on_practices": [
        {
            "introduction": "计数排序的威力远不止于排序简单的整数。这个练习将挑战你实现一个更通用的版本，通过提取一个整数“键”来对复杂的数据结构进行排序。这不仅能加深你对算法核心逻辑的理解，还能帮助你构建一个可复用的排序工具，适用于各种需要根据特定属性排序的场景。",
            "id": "3224624",
            "problem": "设计并实现一个稳定的排序程序，该程序通过使用键提取函数来改编计数排序，以对任意元素的数组进行操作。设 $A$ 为一个有限元素序列，$\\mathrm{key\\_func}$ 是一个函数，使得对于 $A$ 中的每个元素 $x \\in A$，$\\mathrm{key\\_func}(x)$ 是一个在给定非负整数 $k$ 的闭区间 $[0,k]$ 内的整数。你的任务是从第一性原理出发，推导出一个稳定的算法，该算法利用键的有界整数范围，根据 $\\mathrm{key\\_func}$ 计算出的键，对 $A$ 进行非递减排序。\n\n你的推导必须基于以下基本事实和定义：\n- 在随机存取机器（Random Access Machine）模型下，数组支持随机访问和索引，每次访问的时间是确定性的。\n- 一个有限离散值集合中各值的出现频率可以通过计数来制表，而累积总和可以用于计算分组放置的位置。\n- 一个排序算法是稳定的，当且仅当任何两个具有相等键的元素在输出中出现的相对顺序与它们在输入中出现的相对顺序相同。\n- 对于任何一个由上限为 $k$ 的非负整数组成的有限序列，其键的多重集可以用一个长度为 $k+1$ 的频率数组来表示。\n\n你必须构建的算法应满足以下条件：\n- 利用统计 $[0,k]$ 中每个可能键的出现次数的能力，并使用累积信息来确定性地放置元素。\n- 保持上述定义的稳定性属性。\n- 运行时间与 $|A| + k$ 成正比，使用的额外空间与 $|A| + k$ 成正比。\n\n程序规范：\n- 实现一个函数 $\\text{sort}(A,\\mathrm{key\\_func},k)$，它返回一个新序列，该序列由 $A$ 的元素根据 $\\mathrm{key\\_func}(x)$ 的非递减顺序排序组成，并保持键相等元素的输入顺序。\n- 为进行验证，请将你的函数应用于以下测试套件。在每种情况下，$A$ 是一个由数对 $(v,i)$ 组成的列表，其中 $v$ 是与键函数相关的值，$i$ 是一个唯一标识符。对于每个测试用例，要求的输出是经过基于键的稳定排序后得到的标识符 $i$ 的列表。测试用例如下：\n  1. 包含重复键的一般情况：$A_1 = [(3,101),(1,102),(3,103),(0,104),(5,105),(1,106),(2,107),(5,108),(4,109),(2,110)]$，$\\mathrm{key\\_func}_1(v,i) = v$，$k_1 = 5$。\n  2. 边界情况，k=0（所有键相同）：$A_2 = [(7,201),(3,202),(9,203),(1,204),(7,205),(3,206)]$，$\\mathrm{key\\_func}_2(v,i) = 0$，$k_2 = 0$。\n  3. 边缘情况，输入为空：$A_3 = []$，$\\mathrm{key\\_func}_3(v,i) = 0$，$k_3 = 3$。\n  4. 作用于字符串的非平凡键函数：$A_4 = [(\\text{\"delta\"},301),(\\text{\"mu\"},302),(\\text{\"epsilon\"},303),(\\text{\"pi\"},304),(\\text{\"alpha\"},305),(\\text{\"beta\"},306),(\\text{\"omicron\"},307)]$，$\\mathrm{key\\_func}_4(v,i) = |v| \\bmod 4$ 其中 $|v|$ 表示字符串 $v$ 的长度，以及 $k_4 = 3$。\n\n最终输出格式：\n- 你的程序必须生成单行输出，其中包含 4 个测试用例的结果，结果为一个由逗号分隔的列表，并用方括号括起。每个结果本身也必须是用方括号括起的、按排序后顺序排列的标识符列表。例如，输出格式为 $[[i_1,i_2,\\dots],[...],[...],[...]]$，不含任何额外文本。要求的输出是整数列表。",
            "solution": "我们从以下基本事实出发：对于任何在已知范围 $[0,k]$ 内有界的有限整数多重集，可以通过一个频率数组来统计其出现次数，而这些频率的累积总和可以为稳定排列提供确定性的放置索引。在随机存取机器（Random Access Machine）模型下，数组支持常数时间的索引访问，这确保了累积和放置步骤的运行时间与访问的索引数量成正比。\n\n设 $A$ 是一个长度为 $n = |A|$ 的序列，并设 $K(x) = \\mathrm{key\\_func}(x) \\in [0,k]$ 为元素 $x$ 的整数键。目标是构造一个对 $A$ 的稳定排序，使其按键 $K(x)$ 非递减排列，并且使用的操作在 $n+k$ 上是线性的，额外内存也在 $n+k$ 上是线性的。\n\n算法构造如下：\n1. 计数阶段。分配一个长度为 $k+1$ 的数组 $C$ 并初始化为 0。对 $A$ 中的每个元素 $x$，读取其键 $t = K(x)$ 并将 $C[t]$ 的值增加 1 ($C[t] \\leftarrow C[t] + 1$)。此遍完成后，$C[t]$ 存储了所有 $t \\in \\{0,1,\\dots,k\\}$ 对应键的元素数量。\n\n2. 前缀和（累积）阶段。原地转换 $C$，使得 $C[t]$ 成为键为 $t$ 的元素在输出数组中的起始索引（偏移量）。初始化一个累加器 $s \\leftarrow 0$，然后对 $t$ 从 $0$ 到 $k$ 执行以下操作：\n   - 令 $c \\leftarrow C[t]$。\n   - 设置 $C[t] \\leftarrow s$。\n   - 更新 $s \\leftarrow s + c$。\n   此阶段之后，对于每个键 $t$，$C[t]$ 等于键为 $t$ 的元素应被放置在输出数组中的第一个位置。由于 $s$ 按照截至键 $t$ 所见元素的总数递增，不同键的段是连续且不重叠的，其索引范围为 $[C[t], C[t] + \\text{count}(t) - 1]$。\n\n3. 稳定放置阶段。分配一个长度为 $n$ 的输出数组 $B$。从左到右遍历 $A$。对于每个元素 $x$，计算其键 $t = K(x)$，将 $x$ 放置在 $B$ 的索引 $C[t]$ 处，然后将 $C[t]$ 的值增加 1 ($C[t] \\leftarrow C[t] + 1$)。因为 $C[t]$ 最初存储的是键为 $t$ 的左边界，并且在每次放置后都会递增，所以具有相同键的元素会按照它们从 $A$ 中读取的顺序被分配到严格递增的索引上。这保持了稳定性：如果 $x$ 在 $A$ 中出现在 $y$ 之前且 $K(x)=K(y)$，那么 $x$ 在 $B$ 中的放置索引将小于 $y$。\n\n正确性论证：\n- 按键排序：根据构造，所有键为 $t$ 的元素都被分配在 $[L_t, R_t]$ 范围内的索引，其中 $L_t$ 是前缀和阶段后存储在 $C[t]$ 中的值，且 $R_t = L_t + \\text{count}(t) - 1$。对于 $t_1  t_2$，这些范围先按 $t_1$ 排序，再按 $t_2$ 排序，因为累加过程 $s$ 确保了 $L_{t_2} = L_{t_1} + \\sum_{u = t_1}^{t_2-1} \\text{count}(u) \\ge L_{t_1} + \\text{count}(t_1)$，所以所有用于 $t_1$ 的索引都在用于 $t_2$ 的索引之前。因此，输出 $B$ 是按键非递减的。\n- 稳定性：在键为 $t$ 的范围内，每次放置一个键为 $t$ 的元素时，用于放置的索引都会递增，这与对 $A$ 的从左到右遍历顺序相同。因此，键值相等的元素保持了其输入顺序。\n\n复杂度分析：\n- 计数阶段访问 $n$ 个元素中的每一个一次，对每个元素执行 $O(1)$ 的工作，总时间为 $O(n)$。\n- 前缀和阶段访问从 $0$ 到 $k$ 的每个键索引一次，总时间为 $O(k)$。\n- 放置阶段访问 $n$ 个元素中的每一个一次，总时间为 $O(n)$。\n- 总时间为 $O(n + k)$。使用的辅助存储是 $n$ 个元素的输出数组加上 $k+1$ 个条目的计数数组，因此额外空间为 $O(n + k)$。\n\n测试套件应用：\n- 测试 $1$：$A_1 = [(3,101),(1,102),(3,103),(0,104),(5,105),(1,106),(2,107),(5,108),(4,109),(2,110)]$，$\\mathrm{key\\_func}_1(v,i) = v$，$k_1 = 5$。稳定排序按键 $0,1,2,3,4,5$ 的顺序分组，产生的标识符顺序为 $[104,102,106,107,110,101,103,109,105,108]$。\n- 测试 $2$：$A_2$ 与 $\\mathrm{key\\_func}_2(v,i) = 0$ 和 $k_2 = 0$ 将所有元素放入同一个键桶中，并根据稳定性，按原始顺序返回标识符 $[201,202,203,204,205,206]$。\n- 测试 $3$：$A_3 = []$ 产生空列表 $[]$，与 $k_3$ 无关。\n- 测试 $4$：$A_4$ 与 $\\mathrm{key\\_func}_4(v,i) = |v| \\bmod 4$ 和 $k_4 = 3$ 对给定的字符串计算出键为 $[1,2,3,2,1,0,3]$，按键 $0,1,2,3$ 进行稳定分组后产生的标识符为 $[306,301,305,302,304,303,307]$。\n\n指定的输出是一行，将每个测试的列表按顺序聚合为一个由逗号分隔的列表，并用方括号括起，每个子列表也用方括号括起。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np  # Not strictly required; included per allowed environment.\n\ndef counting_sort_by_key(A, key_func, k):\n    \"\"\"\n    Stable counting-based sort of arbitrary elements by integer key in [0, k].\n    Returns a new list with elements of A sorted by key_func(x) in nondecreasing order.\n    \"\"\"\n    n = len(A)\n    # Frequency array for keys 0..k\n    counts = [0] * (k + 1)\n    for x in A:\n        t = key_func(x)\n        if not isinstance(t, int):\n            raise ValueError(\"key_func must return an integer.\")\n        if t  0 or t > k:\n            raise ValueError(\"key_func returned a key outside [0, k].\")\n        counts[t] += 1\n\n    # Convert counts to starting indices (prefix sums)\n    total = 0\n    for t in range(k + 1):\n        c = counts[t]\n        counts[t] = total\n        total += c\n\n    # Stable placement\n    output = [None] * n\n    for x in A:\n        t = key_func(x)\n        idx = counts[t]\n        output[idx] = x\n        counts[t] = idx + 1\n\n    return output\n\ndef solve():\n    # Define the test cases from the problem statement.\n\n    # Test 1: General case with repeated keys\n    A1 = [(3, 101), (1, 102), (3, 103), (0, 104), (5, 105),\n          (1, 106), (2, 107), (5, 108), (4, 109), (2, 110)]\n    def key_func1(x):\n        return x[0]\n    k1 = 5\n\n    # Test 2: Boundary case k = 0 (all keys identical)\n    A2 = [(7, 201), (3, 202), (9, 203), (1, 204), (7, 205), (3, 206)]\n    def key_func2(x):\n        return 0\n    k2 = 0\n\n    # Test 3: Edge case empty input\n    A3 = []\n    def key_func3(x):\n        return 0\n    k3 = 3\n\n    # Test 4: Nontrivial key function on strings: length mod 4\n    A4 = [(\"delta\", 301), (\"mu\", 302), (\"epsilon\", 303),\n          (\"pi\", 304), (\"alpha\", 305), (\"beta\", 306), (\"omicron\", 307)]\n    def key_func4(x):\n        return len(x[0]) % 4\n    k4 = 3\n\n    test_cases = [\n        (A1, key_func1, k1),\n        (A2, key_func2, k2),\n        (A3, key_func3, k3),\n        (A4, key_func4, k4),\n    ]\n\n    results = []\n    for A, key_func, k in test_cases:\n        sorted_A = counting_sort_by_key(A, key_func, k)\n        # Extract the identifiers (second component)\n        ids_in_order = [x[1] for x in sorted_A]\n        results.append(ids_in_order)\n\n    # Helper to format a list of ints without spaces\n    def format_list(lst):\n        return \"[\" + \",\".join(map(str, lst)) + \"]\"\n\n    # Final print statement in the exact required format.\n    print(\"[\" + \",\".join(format_list(lst) for lst in results) + \"]\")\n\nsolve()\n```"
        },
        {
            "introduction": "标准计数排序的一个主要限制是其 $O(n+k)$ 的复杂度，当密钥范围 $k$ 变得非常大时，这会带来性能问题。本练习将引导你使用哈希表来重新设计该算法，使其能够高效处理稀疏数据——即密钥分布在很大范围内，但实际使用的密钥数量有限。这是一种在现实世界数据处理中非常实用和重要的优化。",
            "id": "3224735",
            "problem": "您需要设计并分析一个用于整数键记录的稳定排序程序，该程序适用于可能非常大的键范围。这是一个稀疏场景：仅出现一小部分键，但键本身的值可能任意大。您必须开发一种计数排序的变体，该变体使用哈希表来存储计数，而不是使用由键直接索引的直接映射数组。该算法必须是稳定的：当两条记录的键相等时，它们在输出中的相对顺序必须与它们在输入中的相对顺序一致。\n\n推导的基本依据：仅使用以下基本事实来证明算法的正确性和复杂性。\n- 计数排序依赖于统计每个键的出现次数来确定输出位置，其稳定性是通过将具有相等键的元素按输入顺序放置到输出来实现的。\n- 在标准的随机化和均匀哈希假设下，哈希表为插入、查找和更新操作提供期望常数时间性能。\n- 对非负计数进行前缀和计算，可以为输出数组中的连续段提供起始索引。\n\n您的程序必须实现一个函数，该函数接受一个记录列表，其中每个记录是一个对 $(x_i, id_i)$，包含整数键 $x_i$ 和整数标识符 $id_i$，并返回按 $x_i$ 非递减排序后 $id_i$ 的稳定顺序。您不能分配大小与最大键值成正比的数组；相反，您必须使用哈希表进行计数。实现必须对所有输入都是稳定的。\n\n将输入大小定义为记录数 $n$，并设 $u$ 为输入中不同键的数量。您的分析必须从列出的基本依据出发，以建立关于 $n$ 和 $u$ 的渐近时间和空间复杂度。\n\n测试套件。您的程序必须在以下六个测试用例上运行该算法并汇总结果：\n- 测试用例 1：记录 $[(7,0),(3,1),(7,2),(2,3),(3,4),(9,5)]$。按键的稳定排序应产生与非递减顺序的键相对应的 $id$ 序列。\n- 测试用例 2：记录 $[]$（空列表）。\n- 测试用例 3：记录 $[(42,0)]$。\n- 测试用例 4：记录 $[(5,0),(5,1),(5,2),(5,3)]$。\n- 测试用例 5：记录 $[(-1000000000,0),(1000000000,1),(0,2),(-1000000000,3),(1000000000,4)]$。\n- 测试用例 6：记录 $[(100,0),(-50,1),(100,2),(50,3),(-50,4),(200,5),(0,6)]$。\n\n对于每个测试用例，结果是按键的稳定、非递减顺序排列的标识符 $id_i$ 列表。所有输出都是整数列表。\n\n最终输出格式。您的程序必须生成单行输出，其中包含六个测试用例的结果，格式为一个由方括号括起来的逗号分隔列表，其中每个元素本身也是一个由方括号括起来的逗号分隔的整数列表，并且任何地方都不能有空格。例如，如果六个结果是列表 $R_1,\\dots,R_6$，则输出必须是 $[R_1,R_2,R_3,R_4,R_5,R_6]$ 的精确格式。此问题不涉及物理单位或角度测量，也不需要百分比。程序必须是自包含的，且不得读取任何输入。",
            "solution": "该问题陈述被评估为有效。它在科学上基于计算机科学原理，特别是算法设计，并且是良构的、客观的和完整的。它提出了一个可以被形式化规定和解决的非平凡的算法挑战。\n\n任务是为整数键记录开发一种稳定的排序算法，其中键的范围可能非常大，但记录的数量是可控的。这种情况使得传统的计数排序不切实际，因为它需要一个大小与最大键值成正比的辅助数组。所提出的解决方案是计数排序的一个变体，它利用哈希表来管理计数，从而绕过大键范围的限制。该算法必须是稳定的，这意味着具有相等键的记录将保持其原始的相对顺序。\n\n设 $n$ 为输入列表中的记录数， $u$ 为唯一键的数量。每个记录是一个对 $(x_i, id_i)$，其中 $x_i$ 是一个整数键，$id_i$ 是一个整数标识符。\n\n该算法遵循所提供的基本原理，分为三个主要阶段构建。\n\n**阶段 1：频率计数**\n\n第一步是统计输入中每个唯一键的出现次数。为此，我们使用一个哈希表，称之为 `counts`。我们遍历 $n$ 个输入记录。对于每个记录 $(x_i, id_i)$，我们在 `counts` 哈希表中更新键 $x_i$ 的计数。如果 $x_i$ 尚不在表中，则以计数 1 插入；否则，其现有计数加一。\n\n- 原理：此步骤利用了哈希表为插入和更新操作提供期望常数时间性能的特性。因此，处理所有 $n$ 条记录的期望时间为 $O(n)$。\n- 空间：`counts` 哈希表将为 $u$ 个唯一键中的每一个存储一个条目。因此，此阶段的空间复杂度为 $O(u)$。\n\n**阶段 2：位置计算**\n\n第二个阶段为共享相同键的每组记录确定其在最终输出数组中的起始位置。这类似于标准计数排序中的前缀和计算。\n\n1.  提取并排序键：首先，我们从 `counts` 哈希表中提取 $u$ 个唯一键。为了给输出建立一个非递减顺序，必须对这些键进行排序。设排序后的唯一键为 $k_1, k_2, \\dots, k_u$。此步骤的时间复杂度由排序主导，使用标准的基于比较的排序算法为 $O(u \\log u)$。\n\n2.  计算起始索引：我们创建第二个哈希表 `positions`，用于将每个唯一键映射到其在最终排序数组中的起始索引。这是通过对已排序键的计数进行前缀和计算来完成的。一个运行的 `offset`（偏移量）初始化为 $0$。我们遍历已排序的键 $k_j$（其中 $j=1, \\dots, u$）：\n    - 键 $k_j$ 的起始位置是当前的 `offset`。我们设置 `positions[k_j] = offset`。\n    - 然后 `offset` 增加键为 $k_j$ 的元素数量，该数量存储在 `counts[k_j]` 中。\n    \n    这个过程计算出第一组元素（键为 $k_1$）将从索引 0 开始。第二组元素（键为 $k_2$）将从索引 `counts[k_1]` 开始。第三组元素（键为 $k_3$）将从索引 `counts[k_1] + counts[k_2]` 开始，以此类推。\n\n- 原理：此步骤直接应用了“对计数进行前缀和计算可提供连续段的起始索引”这一原理。通过对排序后的唯一键执行此操作，我们将键的抽象顺序映射到内存中的具体索引。\n- 复杂度：此步骤涉及对已排序键的 $O(u)$ 迭代。此阶段的主要成本仍然是 $O(u \\log u)$ 的排序步骤。`positions` 哈希表需要 $O(u)$ 的空间。\n\n**阶段 3：稳定放置**\n\n最后一个阶段将记录标识符以其稳定的、排序后的顺序放置到大小为 $n$ 的输出数组中。\n\n为确保稳定性，我们必须按原始顺序遍历输入记录 $(x_i, id_i)$（从 $i=1$ 到 $n$）。对于每个记录：\n1.  在 `positions` 哈希表中查找其键 $x_i$ 的当前放置索引。设此索引为 `p = positions[x_i]`。\n2.  将标识符 $id_i$ 放置到输出数组的索引 `p` 处。\n3.  在 `positions` 哈希表中增加键 $x_i$ 的位置：`positions[x_i] = p + 1`。\n\n- 原理：稳定性的实现是因为我们按顺序处理输入记录。如果两个记录具有相同的键，那么在输入中较早出现的那个将被首先放置。其放置操作会增加该键的起始位置，从而确保具有相同键的后续记录紧随其后放置，因此保留了它们初始的相对顺序。\n- 复杂度：此阶段涉及对 $n$ 个输入记录的单次遍历。循环内的每一步都包括一次哈希表查找和一次更新，这些都是期望 $O(1)$ 的操作。因此，此阶段的总时间为 $O(n)$。需要一个大小为 $n$ 的输出数组，这为空间复杂度贡献了 $O(n)$。\n\n**总体复杂度分析**\n\n- 时间复杂度：总期望时间是三个阶段复杂度的总和：$O(n)$（计数）+ $O(u \\log u)$（排序键）+ $O(n)$（放置）。这可以简化为 $O(n + u \\log u)$。\n- 空间复杂度：所需空间由 `counts` 哈希表（$O(u)$）、`positions` 哈希表（$O(u)$）、用于存储已排序键的临时空间（$O(u)$）以及输出数组（$O(n)$）决定。因此，总空间复杂度为 $O(n + u)$。\n\n这种算法设计成功地将计数排序应用于稀疏、大范围键的场景，同时保持了稳定性并遵守了指定的约束和基本原理。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the hash-based counting sort problem for the given test cases.\n    \"\"\"\n\n    def hash_counting_sort(records):\n        \"\"\"\n        Implements a stable, hash-based counting sort for integer-keyed records.\n\n        The algorithm handles sparse keys over a potentially large range by using\n        hash tables for counting and position mapping, avoiding the creation of\n        an array proportional to the key range.\n\n        Args:\n            records: A list of tuples, where each tuple is a pair (key, id).\n\n        Returns:\n            A list of ids, stably sorted by their corresponding keys in non-decreasing order.\n        \"\"\"\n        n = len(records)\n        if n == 0:\n            return []\n\n        # Phase 1: Frequency Counting\n        # Use a dictionary (hash table) to count occurrences of each key.\n        # Time: O(n) expected, Space: O(u) where u is the number of unique keys.\n        counts = {}\n        for key, _ in records:\n            counts[key] = counts.get(key, 0) + 1\n\n        # Phase 2: Position Calculation\n        # 1. Get unique keys and sort them to establish the output order.\n        # Time: O(u log u)\n        unique_keys = sorted(counts.keys())\n        \n        # 2. Compute prefix sums to find the starting index for each key's block.\n        #    Store these starting positions in a hash table.\n        # Time: O(u), Space: O(u)\n        positions = {}\n        start_pos = 0\n        for key in unique_keys:\n            positions[key] = start_pos\n            start_pos += counts[key]\n\n        # Phase 3: Stable Placement\n        # Create an output array. Iterate through the *original* input records to\n        # ensure stability. Place each item's id in its correct sorted position\n        # and increment the position for that key.\n        # Time: O(n) expected, Space: O(n) for the output array.\n        output = [0] * n\n        for key, item_id in records:\n            # Get the current position for this key\n            pos = positions[key]\n            # Place the id in the output array\n            output[pos] = item_id\n            # Increment the position for the next item with the same key\n            positions[key] += 1\n            \n        return output\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [(7, 0), (3, 1), (7, 2), (2, 3), (3, 4), (9, 5)],\n        [],\n        [(42, 0)],\n        [(5, 0), (5, 1), (5, 2), (5, 3)],\n        [(-1000000000, 0), (1000000000, 1), (0, 2), (-1000000000, 3), (1000000000, 4)],\n        [(100, 0), (-50, 1), (100, 2), (50, 3), (-50, 4), (200, 5), (0, 6)],\n    ]\n\n    results = []\n    for case in test_cases:\n        result = hash_counting_sort(case)\n        results.append(result)\n\n    # Format the final output string exactly as required: no spaces, comma-separated lists within a list.\n    formatted_results = [f\"[{','.join(map(str, res))}]\" for res in results]\n    final_output = f\"[{','.join(formatted_results)}]\"\n    \n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "这是一个专注于空间效率的高级挑战，要求你修改计数排序，使其能够“就地”操作，从而省去额外的输出数组。这个练习将迫使你更深入地思考算法的内部机制，并揭示其背后涉及的权衡，尤其是为了节省空间而牺牲算法宝贵的稳定性。通过这个练习，你将对算法设计中的时空权衡有更深刻的认识。",
            "id": "3224601",
            "problem": "给定一项任务，要求您在数据结构与算法课程中，从基本原理出发，推导并实现一个用于整数键的原地计数排序版本。请从核心定义开始：一个基于已知有界整数域的频率直方图，由前缀和推导出的桶边界，以及排序中稳定性的含义。您必须严格证明这些基本要素如何确保分布到桶区间的正确性，并设计一个在消除外部输出数组的同时仍能进行原地排序的算法。您必须分析在原地约束下必然会丢失哪些属性，并确定其渐进时间复杂度。\n\n您的程序必须实现两种从相同基础机制派生出的变体：\n- 针对整数列表的原地计数排序，其中仅使用大小为 $k$（域中不同整数值的数量）的频率数组作为辅助空间。该算法必须根据频率计数通过覆盖原始列表的方式，对给定列表进行非递减排序。此变体将元素视作纯粹的键，并且不得分配大小为 $n$ 的辅助输出数组。\n- 针对记录列表 $(\\text{key}, \\text{tag})$ 的原地计数排序，其中 $\\text{key}$ 是已知有界范围内的整数，而 $\\text{tag}$ 是表示原始顺序的标识符。使用源自前缀和的桶边界，并通过循环首元素风格的放置（cycle-leader style placement）执行原地分布。此变体不得分配大小为 $n$ 的辅助输出数组，并且必须通过原地交换将记录放入其正确的桶区间。\n\n用作基本依据的定义：\n- 设 $A$ 为一个长度为 $n$ 的输入数组，其整数键位于一个连续范围 $[\\min, \\max]$ 内。设 $k = \\max - \\min + 1$ 表示域中不同键值的数量。\n- 频率直方图是一个长度为 $k$ 的数组 $C$，其中 $C[i]$ 等于键值 $(\\min + i)$ 在 $A$ 中出现的次数。\n- $C$ 的前缀和决定了桶的起始索引。设 $S[0] = 0$ 且对于 $i \\geq 1$，有 $S[i] = \\sum_{j=0}^{i-1} C[j]$。那么，所有键为 $(\\min + i)$ 的项在排序后的数组中必须占据从 $S[i]$ (包含)到 $S[i] + C[i]$ (不包含)的索引。\n- 如果对于任意两个具有相等键的记录，它们在输出中的相对顺序与它们在输入中的相对顺序相同，则该排序算法是稳定的。\n\n任务：\n1. 实现整数原地计数排序，通过计算直方图 $C$ 然后使用 $C$ 以非递减顺序覆盖原始数组 $A$。此过程最多只能使用 $O(k)$ 的额外空间，并且不得使用大小为 $n$ 的辅助数组。报告每个测试用例中，此覆盖步骤对 $A$ 执行了多少次写操作。\n2. 实现记录原地计数排序（针对元组 $(\\text{key}, \\text{tag})$），使用直方图 $C$ 和来自前缀和的桶边界，通过原地交换将记录分布到桶区间，而不分配大小为 $n$ 的辅助输出数组。对每个测试用例，计算：\n   - 一个布尔值，指示排序相对于等键组内 $\\text{tag}$ 值的原始顺序是否稳定。\n   - 为将记录放入正确桶中而执行的总交换操作次数。\n3. 在您的解决方案中说明，原地版本丢失了哪个属性，以及新的渐进时间复杂度是多少，使用大O表示法以 $\\LaTeX$ 形式表示。\n\n输入域和单位：\n- 所有键均为整数；没有物理单位。角度单位不适用。没有百分比。\n\n测试套件：\n使用以下明确的测试用例。对于整数数组，每个用例是一个三元组 $(A, \\min, \\max)$，其中 $A$ 是一个整数列表。对于记录数组，每个用例是一个三元组 $(R, \\min, \\max)$，其中 $R$ 是一个 $(\\text{key}, \\text{tag})$ 对的列表。\n\n整数数组用例：\n- 用例 1: $A = [3,1,2,1,0,2,3,3]$, $\\min = 0$, $\\max = 3$。\n- 用例 2: $A = [5]$, $\\min = 5$, $\\max = 5$。\n- 用例 3: $A = [0,0,1,1,2,2,3]$, $\\min = 0$, $\\max = 3$。\n- 用例 4: $A = [4,3,2,1,0]$, $\\min = 0$, $\\max = 4$。\n- 用例 5: $A = [-2,-1,-1,0,1]$, $\\min = -2$, $\\max = 1$。\n\n记录数组用例（每个记录为 $(\\text{key}, \\text{tag})$）：\n- 用例 1: $R = [(2,'a'),(1,'b'),(2,'c'),(1,'d'),(0,'e')]$, $\\min = 0$, $\\max = 2$。\n- 用例 2: $R = [(0,'a'),(0,'b'),(1,'c'),(1,'d'),(2,'e')]$, $\\min = 0$, $\\max = 2$。\n- 用例 3: $R = [(1,'a'),(1,'b'),(1,'c')]$, $\\min = 1$, $\\max = 1$。\n- 用例 4: $R = [(-1,'a'),(0,'b'),(-1,'c'),(1,'d')]$, $\\min = -1$, $\\max = 1$。\n\n要求的最终输出格式：\n您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表。该单行必须具有以下结构：\n$[V,S,W,WV]$\n其中：\n- $V$ 是五个整数用例按顺序排序后的整数数组列表。\n- $S$ 是四个记录用例的布尔值列表，指示原地记录排序是否稳定。\n- $W$ 是四个记录用例的整数列表，给出执行的总交换次数。\n- $WV$ 是五个整数用例的整数列表，给出覆盖步骤中对数组的总写操作次数。\n\n例如，输出将类似于 $[[...],[...],[...],[...]]$，所有内部列表均根据上述规范填充，且无额外文本。",
            "solution": "该问题是有效的，因为它是在数据结构与算法领域中一个定义明确、有科学依据的任务。它提供了一套完整且一致的定义、约束和测试用例，用于推导和实现两个原地计数排序的变体，并分析它们的属性。\n\n计数排序的基本原理是利用键的已知、有界整数域。我们不比较元素之间的大小，而是计算它们的出现次数，并利用这些计数来确定它们的最终位置。标准实现是稳定的，但需要一个大小为 $n$ 的辅助输出数组，其中 $n$ 是元素数量。本任务旨在推导出消除此 $O(n)$ 空间需求、进行原地操作的版本。\n\n设 $A$ 为长度为 $n$ 的输入数组，其键在范围 $[\\min, \\max]$ 内。键域的大小为 $k = \\max - \\min + 1$。\n\n**第一部分：原地整数排序**\n\n第一个变体处理一个整数数组，其中元素本身就是键。目标是仅使用 $O(k)$ 的辅助空间（用于频率直方图）来原地排序数组。\n\n**原理与推导：**\n1. **频率直方图：** 首先，我们构建一个大小为 $k$ 的频率直方图数组 $C$。对于输入数组 $A$ 中的每个整数值 $v$，我们增加 $C$ 中索引为 $v - \\min$ 的计数。扫描完 $A$ 的所有 $n$ 个元素后，$C[i]$ 将保存键 $(\\min + i)$ 的总出现次数。此步骤需要 $O(n)$ 时间遍历 $A$，以及 $O(k)$ 空间存储 $C$。\n2. **原地覆盖：** 一旦计算出直方图 $C$，排序后数组的内容就完全确定了。我们知道排序后的数组必须由 $C[0]$ 个值 $(\\min + 0)$，紧接着 $C[1]$ 个值 $(\\min + 1)$，依此类推，直到 $C[k-1]$ 个值 $(\\min + k - 1)$ 组成。由于此变体中整数的原始位置不重要（因为它们只是键），我们可以直接覆盖原始数组 $A$。我们使用一个指针，例如 `write_idx`，初始化为 $0$。我们从 $i=0$ 遍历到 $k-1$。对于每个 $i$，我们将值 $(\\min + i)$ 写入 $A$ 的当前 `write_idx` 位置，共计 $C[i]$ 次，每次写入后递增 `write_idx`。此覆盖过程执行了恰好 $n$ 次写操作，耗时 $O(n+k)$。\n\n**分析：**\n- **时间复杂度：** 总时间复杂度是构建直方图（$O(n)$）和覆盖数组（$O(k+n)$）的总和，结果为 $O(n+k)$。\n- **空间复杂度：** 该算法使用一个大小为 $k$ 的辅助数组 $C$，因此辅助空间复杂度为 $O(k)$。这满足了不使用 $O(n)$ 辅助数组的约束。\n- **丢失的属性：** 此方法完全抹去了关于相同键原始相对顺序的任何信息。它仅根据频率计数重建数组。因此，这种原地变体是**不稳定**的。\n\n**第二部分：原地记录排序**\n\n第二个变体处理 $(\\text{key}, \\text{tag})$ 形式的记录，其中保留具有相同键的记录的原始顺序（稳定性）是一个考量因素。目标是通过原地交换元素到其正确的桶区间来进行排序。\n\n**原理与推导：**\n1. **桶边界：** 和之前一样，我们在 $O(n)$ 时间内计算频率直方图 $C$。为了确定元素组在最终排序数组中的位置，我们计算 $C$ 的前缀和。设 $S$ 是一个大小为 $k$ 的数组，其中 $S[0] = 0$，对于 $i > 0$，$S[i] = \\sum_{j=0}^{i-1} C[j]$。数组 $S$ 定义了每个键的“桶”的起始索引。键为 $(\\min + i)$ 的元素属于连续索引范围 $[S[i], S[i] + C[i] - 1]$。\n2. **原地置换（循环跟随）：** 标准的稳定计数排序使用 $S$ 将元素放入一个单独的输出数组。为了原地执行此操作，我们必须将 $A$ 中的元素置换到其正确的桶中。一个稳健的方法是跟随置换环。\n- 我们从 $0$到 $n-1$ 遍历数组 $A$ 的每个索引 $i$。\n- 在每个索引 $i$ 处，我们检查元素 $A[i]$。设其键为 $v$。此元素属于键 $v$ 的桶。我们检查当前索引 $i$ 是否在键 $v$ 的桶范围内。\n- 如果 $A[i]$ 已经在其正确的桶中（即在其“家”位置），我们移动到下一个索引 $i+1$。\n- 如果 $A[i]$ 不在其正确的桶中，我们必须将其交换到其目标桶内的一个位置。我们使用一个独立的指针数组 `next_pos`，其初始化与 $S$ 相同，用于跟踪每个桶中下一个可用的槽位。我们找到目标索引 `dest = next_pos[v - min]`，交换 $A[i]$ 和 $A[\\text{dest}]$，并递增 `next_pos[v - min]`。这会正确放置一个元素。\n- 至关重要的是，现在位于 $A[i]$ 的新元素也可能在错误的位置。我们不推进 $i$。相反，我们对新的 $A[i]$ 重复此过程：检查它是否在“家”位置，如果不在，则将其交换到其目的地。这个内部过程持续进行，直到一个在索引 $i$ 处是“家”的元素被移入 $A[i]$。此时，从 $i$ 开始的循环完成，我们可以将外层循环推进到 $i+1$。\n- 此过程确保每个元素最多被移动一次到其最终的桶中，置换的总工作量为 $O(n)$。\n\n**分析：**\n- **时间复杂度：** 步骤包括：构建直方图（$O(n)$）、计算前缀和（$O(k)$）以及执行原地置换（$O(n)$）。总时间复杂度为 $O(n+k)$。\n- **空间复杂度：** 此变体需要直方图 $C$（$O(k)$）和前缀和/指针数组 $S$（$O(k)$）。总辅助空间为 $O(k)$。\n- **丢失的属性：** 因为一个元素被交换到其桶中的*下一个可用*位置，而没有考虑其在具有相同键的其他元素中的原始相对位置，所以**稳定性通常会丢失**。虽然某些输入可能碰巧被稳定排序，但该算法不保证稳定性。这是为实现原地排序而牺牲的主要属性。\n\n**分析总结（任务3）：**\n\n这些原地计数排序变体必然丢失或充其量不再保证的属性是**稳定性**。两种所述原地算法的渐进时间复杂度仍然是 $O(n+k)$，这与标准的、非原地的、稳定的计数排序相同。原地操作的约束主要影响稳定性，而不是渐进性能。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import defaultdict\n\ndef solve():\n    \"\"\"\n    Derives and implements two variants of in-place counting sort.\n    \"\"\"\n\n    def inplace_counting_sort_int(A, min_val, max_val):\n        \"\"\"\n        Sorts a list of integers in-place using a frequency histogram.\n        Returns the sorted list and the number of write operations during the overwrite step.\n        \"\"\"\n        if not A:\n            return [], 0\n            \n        n = len(A)\n        k = max_val - min_val + 1\n        \n        # 1. Compute frequency histogram\n        counts = np.zeros(k, dtype=int)\n        for x in A:\n            counts[x - min_val] += 1\n            \n        # 2. Overwrite the original array\n        write_ops = 0\n        write_idx = 0\n        for i in range(k):\n            val = min_val + i\n            count = counts[i]\n            for _ in range(count):\n                A[write_idx] = val\n                write_idx += 1\n                write_ops += 1\n                \n        return A, write_ops\n\n    def inplace_counting_sort_record(R, min_val, max_val):\n        \"\"\"\n        Sorts a list of (key, tag) records in-place using cycle-following.\n        Returns the sorted list, a boolean for stability, and the number of swaps.\n        \"\"\"\n        n = len(R)\n        if n == 0:\n            return [], True, 0\n\n        original_R = list(R)\n        k = max_val - min_val + 1\n\n        # 1. Compute frequency histogram\n        counts = np.zeros(k, dtype=int)\n        for key, _ in R:\n            counts[key - min_val] += 1\n\n        # 2. Compute bucket boundaries (static) and next available positions (dynamic)\n        bucket_starts = np.zeros(k, dtype=int)\n        bucket_starts[1:] = np.cumsum(counts[:-1])\n        bucket_ends = bucket_starts + counts\n        next_pos = bucket_starts.copy()\n\n        swaps = 0\n        # 3. In-place permutation via cycle-following\n        for i in range(n):\n            key, _ = R[i]\n            key_idx = key - min_val\n            \n            # An element is \"home\" if its index is within its key's designated bucket\n            is_home = bucket_starts[key_idx] = i  bucket_ends[key_idx]\n\n            while not is_home:\n                dest_idx = next_pos[key_idx]\n                R[i], R[dest_idx] = R[dest_idx], R[i]\n                swaps += 1\n                next_pos[key_idx] += 1\n\n                # Re-evaluate the new element at R[i]\n                key, _ = R[i]\n                key_idx = key - min_val\n                is_home = bucket_starts[key_idx] = i  bucket_ends[key_idx]\n\n        # 4. Check stability\n        original_order = defaultdict(list)\n        for key, tag in original_R:\n            original_order[key].append(tag)\n        \n        final_order = defaultdict(list)\n        for key, tag in R:\n            final_order[key].append(tag)\n            \n        is_stable = True\n        for key in original_order:\n            if original_order[key] != final_order[key]:\n                is_stable = False\n                break\n                \n        return R, is_stable, swaps\n\n    # Define test cases from the problem statement.\n    integer_cases = [\n        ([3, 1, 2, 1, 0, 2, 3, 3], 0, 3),\n        ([5], 5, 5),\n        ([0, 0, 1, 1, 2, 2, 3], 0, 3),\n        ([4, 3, 2, 1, 0], 0, 4),\n        ([-2, -1, -1, 0, 1], -2, 1),\n    ]\n\n    record_cases = [\n        ([(2, 'a'), (1, 'b'), (2, 'c'), (1, 'd'), (0, 'e')], 0, 2),\n        ([(0, 'a'), (0, 'b'), (1, 'c'), (1, 'd'), (2, 'e')], 0, 2),\n        ([(1, 'a'), (1, 'b'), (1, 'c')], 1, 1),\n        ([(-1, 'a'), (0, 'b'), (-1, 'c'), (1, 'd')], -1, 1),\n    ]\n\n    # Process integer cases\n    V_results = []\n    WV_results = []\n    for A, min_val, max_val in integer_cases:\n        # A.copy() is important to not modify the original test case list\n        sorted_A, writes = inplace_counting_sort_int(A.copy(), min_val, max_val)\n        V_results.append(sorted_A)\n        # Number of writes to overwrite an array of length n is n\n        WV_results.append(len(A))\n\n    # Process record cases\n    S_results = []\n    W_results = []\n    for R, min_val, max_val in record_cases:\n        # R.copy() is important\n        _, is_stable, swaps = inplace_counting_sort_record(R.copy(), min_val, max_val)\n        S_results.append(is_stable)\n        W_results.append(swaps)\n\n    # Final print statement in the exact required format.\n    print(f\"[{V_results},{S_results},{W_results},{WV_results}]\")\n\nsolve()\n```"
        }
    ]
}