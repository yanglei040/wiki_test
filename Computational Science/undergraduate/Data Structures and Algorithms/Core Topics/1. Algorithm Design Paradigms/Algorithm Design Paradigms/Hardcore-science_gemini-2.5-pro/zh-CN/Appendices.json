{
    "hands_on_practices": [
        {
            "introduction": "分治法是一种强大的算法设计范式，它将问题分解为更小的相似子问题来求解。这个练习超越了简单的排序，它利用了类似归并排序算法中的“合并”步骤来高效地计算“逆序对”，这是一种衡量序列无序程度的指标。通过掌握此方法，你将学会如何利用“合并”步骤来解决复杂的计数问题。",
            "id": "3205394",
            "problem": "您的任务是设计并实现一个分治算法，用于计算一个有限的不同整数序列中的逆序对数量。逆序对定义为满足 $i<j$ 且 $A[i]>A[j]$ 的索引对 $(i,j)$。您必须实现一个算法，其最坏情况下的运行时间为 $O(n \\log n)$，其中 $n$ 表示输入序列的长度。\n\n定义和假设：\n- 一个长度为 $n$ 的序列 $A$ 如果包含 $n$ 个不同的整数（不一定是 $1$ 到 $n$ 的整数），则它是一个排列。\n- $A$ 的逆序数是满足 $i<j$ 且 $A[i]>A[j]$ 的索引对 $(i,j)$ 的数量。\n\n您的程序必须：\n- 实现一个分治算法来计算逆序数，仅使用整数比较和基本算术运算。不允许使用朴素的二次时间复杂度的遍历所有数对的方法。\n- 使用以下固定的测试套件，这是一个包含 7 个序列的列表，每个序列都以 Python 风格的列表表示。就此问题而言，将这些列表视为程序的全部输入，不要读取任何外部输入。\n    1. $[]$\n    2. $[1]$\n    3. $[1,2,3,4,5]$\n    4. $[5,4,3,2,1]$\n    5. $[2,3,8,6,1]$\n    6. $[1,3,5,2,4,6]$\n    7. $[10,3,7,4,9,1,8,2,5,6]$\n\n输出规范：\n- 对于上述 7 个序列中的每一个，计算其逆序数，结果为一个非负整数。\n- 您的程序应生成单行输出，包含这 7 个结果，格式为逗号分隔的列表，并用方括号括起来，不含空格。例如，如果 7 个测试用例的结果是 $r_1,r_2,\\dots,r_7$，输出应精确地为一行 $[r_1,r_2,\\dots,r_7]$。\n\n注意：\n- 不涉及物理或角度单位，也无需计算百分比。所有输出均为整数。\n- 需要使用的算法设计范式是分治法，时间复杂度目标是 $O(n \\log n)$。",
            "solution": "我们首先从离散数学和算法分析的核心定义开始。设一个长度为 $n$ 的序列 $A$ 是一个包含 $n$ 个不同整数的列表。一个逆序对是满足 $i<j$ 且 $A[i]>A[j]$ 的索引对 $(i,j)$。逆序数是集合 $\\{(i,j)\\mid 1\\le i<j\\le n,\\ A[i]>A[j]\\}$ 的基数。\n\n我们寻求一个在分治范式下，最坏情况时间复杂度为 $O(n \\log n)$ 的算法。我们依赖的基本原理是：\n- 分治方法论：通过将一个规模为 $n$ 的问题分解为大约 $n/2$ 大小的子问题，递归地解决这些子问题，并在 $O(n)$ 时间内合并它们的解来解决原问题。\n- 用于形如 $T(n)=a\\,T(n/b)+f(n)$ 的递推式的主定理，当 $a=2$，$b=2$ 且 $f(n)=\\Theta(n)$ 时，该定理得出 $T(n)=O(n \\log n)$。\n\n设计：\n1. 分解步骤：将 $A$ 分为两个子序列，左半部分 $L$ 和右半部分 $R$，大小分别为 $\\lfloor n/2\\rfloor$ 和 $\\lceil n/2\\rceil$。\n2. 解决步骤：递归计算 $L$ 和 $R$ 的逆序数，分别表示为 $I_L$ 和 $I_R$，并同时生成 $L$ 和 $R$ 的排序版本。由于整数是互不相同的，排序定义了一个严格的全序关系。\n3. 合并步骤：将两个已排序的子序列合并成一个单一的已排序序列，同时计算跨越逆序对 $I_C$，即索引 $i$ 在左半部分而索引 $j$ 在右半部分的逆序对 $(i,j)$。在标准的稳定归并过程中，维护指向 $L$ 和 $R$ 的索引 $p$ 和 $q$。当 $L[p]\\le R[q]$ 时，我们追加 $L[p]$ 并增加 $p$。当 $L[p]>R[q]$ 时，我们追加 $R[q]$ 并增加 $q$，并将 $(|L|-p)$ 加到逆序数上，因为 $R[q]$ 小于 $L$ 中所有剩余的元素 $L[p],L[p+1],\\dots,L[|L|-1]$，每个元素都贡献一个跨越逆序对。\n\n正确性：\n我们通过对 $n$ 进行归纳来证明该算法返回精确的逆序数和一个已排序的序列。\n- 基本情况：当 $n=0$ 和 $n=1$ 时，没有逆序对，所以计数为 0，且序列是平凡有序的。算法返回 0 和原始序列，这是正确的。\n- 归纳步骤：假设对于所有长度小于 $n$ 的序列，算法都是正确的。考虑一个长度为 $n$ 的序列 $A$。将其分为 $L$ 和 $R$ 后，根据归纳假设，递归调用正确地返回了 $I_L$ 和已排序的 $L$，以及 $I_R$ 和已排序的 $R$。$A$ 中的每一个逆序对要么完全在 $L$ 内部，要么完全在 $R$ 内部，要么是一个第一个索引在 $L$ 中、第二个索引在 $R$ 中的跨越逆序对。归并过程恰好计算了所有的跨越逆序对：每当来自 $R$ 的元素在归并后的顺序中排在 $L$ 中剩余元素的前面时，它与这些剩余元素中的每一个都恰好构成一个逆序对；而当来自 $L$ 的元素排在来自 $R$ 的元素前面时，没有形成新的跨越逆序对。因此，总逆序数是 $I_L+I_R+I_C$，这正是算法所计算的。归并操作也从两个已排序的子序列中生成了正确排序的序列。因此，该算法是正确的。\n\n复杂度：\n令 $T(n)$ 表示在长度为 $n$ 的序列上的运行时间。递推关系满足\n$$\nT(n)=\n\\begin{cases}\n\\Theta(1),  & \\text{if } n\\le 1,\\\\\n2\\,T(n/2)+\\Theta(n),  & \\text{if } n>1,\n\\end{cases}\n$$\n因为我们对两个子序列进行了两次递归调用，并执行了一个线性时间的归并操作。根据主定理，当 $a=2$，$b=2$ 且 $f(n)=\\Theta(n)$ 时，我们得到 $T(n)=\\Theta(n\\log n)$。因此，该算法在 $O(n\\log n)$ 时间内运行。\n\n在测试套件上的应用：\n我们将该算法应用于指定的 7 个序列。对于每个序列，算法输出一个整数逆序数。最终输出必须是单行，格式为 $[r_1,r_2,\\dots,r_7]$，不含空格，其中 $r_k$ 是第 $k$ 个测试用例的逆序数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\n\ndef count_inversions(arr):\n    # Returns (sorted_arr, inversion_count)\n    def sort_count(a):\n        n = len(a)\n        if n = 1:\n            return a[:], 0\n        mid = n // 2\n        left_sorted, left_inv = sort_count(a[:mid])\n        right_sorted, right_inv = sort_count(a[mid:])\n        merged = []\n        i = j = 0\n        cross_inv = 0\n        len_left = len(left_sorted)\n        len_right = len(right_sorted)\n        # Merge with inversion counting\n        while i  len_left and j  len_right:\n            if left_sorted[i] = right_sorted[j]:\n                merged.append(left_sorted[i])\n                i += 1\n            else:\n                merged.append(right_sorted[j])\n                # All remaining items in left_sorted form inversions with right_sorted[j]\n                cross_inv += (len_left - i)\n                j += 1\n        if i  len_left:\n            merged.extend(left_sorted[i:])\n        if j  len_right:\n            merged.extend(right_sorted[j:])\n        return merged, left_inv + right_inv + cross_inv\n\n    _, inv = sort_count(arr)\n    return inv\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [],  # 1: empty\n        [1],  # 2: single element\n        [1,2,3,4,5],  # 3: already sorted\n        [5,4,3,2,1],  # 4: reverse sorted\n        [2,3,8,6,1],  # 5: mixed distinct integers\n        [1,3,5,2,4,6],  # 6: interleaved\n        [10,3,7,4,9,1,8,2,5,6],  # 7: length 10 permutation\n    ]\n\n    results = []\n    for case in test_cases:\n        result = count_inversions(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "对于一般图而言，寻找最小顶点覆盖是一个计算上的难题，但树的特殊结构使得我们可以使用动态规划找到高效的解法。这个练习将引导你设计一个树形动态规划算法，通过定义节点是否被包含在覆盖集中的状态来解决问题。这个问题是通向“树形DP”这一重要领域的入门，是解决层次结构相关挑战的关键技能。",
            "id": "3205276",
            "problem": "给定一个无向、无权树，您的任务是计算其最小顶点覆盖。图的顶点覆盖是一个顶点集合，使得图中的每条边至少有一个端点在该集合中。形式上，给定一个图 $G = (V, E)$，一个集合 $C \\subseteq V$ 是一个顶点覆盖，如果对于每条边 $(u, v) \\in E$，u 或 v 中至少有一个属于 $C$。树是一个连通的无环图，有 $|V| = n$ 个顶点和 $|E| = n - 1$ 条边，其中 $n \\geq 1$。您的任务是设计一个程序，为每个给定的树计算其最小顶点覆盖的大小（基数）。\n\n使用的基本原理：图、树、顶点覆盖的定义，以及动态规划中使用的最优子结构原理。不要假设任何预先推导出的最小顶点覆盖公式；相反，应基于这些定义从第一性原理推导出算法。\n\n输入规范：没有外部输入。相反，您的程序必须在内部使用以下树的测试套件，每棵树由节点数 $n$ 和一个无向边集 $E$ 指定，边集表示为从 $1$ 到 $n$ 标记的不同顶点的无序对。\n\n树的测试套件：\n- 测试 $1$：$n = 1$, $E = \\{\\}$。\n- 测试 $2$：$n = 2$, $E = \\{(1, 2)\\}$。\n- 测试 $3$：$n = 6$, $E = \\{(1, 2), (1, 3), (1, 4), (1, 5), (1, 6)\\}$。\n- 测试 $4$：$n = 5$, $E = \\{(1, 2), (2, 3), (3, 4), (4, 5)\\}$。\n- 测试 $5$：$n = 7$, $E = \\{(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)\\}$。\n- 测试 $6$：$n = 9$, $E = \\{(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (6, 7), (6, 8), (8, 9)\\}$。\n\n算法要求：\n- 您的算法必须基于对定义的严格推导，并使用适合树的算法设计范式，在每棵树上以 $\\mathcal{O}(n)$ 的时间运行。\n- 由于输入图是树，您可以将每棵树以任意顶点为根，但无论选择哪个根，结果都必须相同。\n\n输出规范：\n- 对于每个测试树，计算其最小顶点覆盖的大小，结果为整数。\n- 您的程序应生成单行输出，其中包含测试 1 到 6 的结果，按顺序排列，形式为用方括号括起来的逗号分隔的整数列表（例如，“[result1,result2,result3,result4,result5,result6]”），不含空格。\n\n此问题不涉及物理量、角度或百分比。输出为无单位的整数。",
            "solution": "在一般图中找到最小顶点覆盖（MVC）的大小是 NP-hard 问题。然而，对于被称为树的特定图类，该问题可以在线性时间内有效解决。树的无环和层次结构使其适用于动态规划范式，该范式利用了最优子结构原理。\n\n核心思想是任意选择某个节点 $r$ 作为树的根，并以自底向上的方式计算子树的解。树的最优解可以由其组成子树的最优解构建而成。\n\n让我们为动态规划公式定义状态。对于树中的任何节点 $u$，我们关心以 $u$ 为根的子树的 MVC 大小。然而，是否将 $u$ 包含在顶点覆盖中的决定会影响其父节点可用的选择。为了解耦这种依赖关系，我们为每个节点 $u$ 定义两种状态：\n1.  令 $DP(u, 1)$ 为以 $u$ 为根的子树的最小顶点覆盖的大小，约束条件是节点 $u$ **被包含**在顶点覆盖中。\n2.  令 $DP(u, 0)$ 为以 $u$ 为根的子树的最小顶点覆盖的大小，约束条件是节点 $u$ **不被包含**在顶点覆盖中。\n\n我们现在可以为这些状态建立递推关系。计算通过后序遍历（例如深度优先搜索，DFS 隐式执行的遍历）进行，确保在计算节点 $u$ 的值时，其所有子节点的值已经确定。\n\n**递推关系推导：**\n设 $u$ 为一个节点，$\\text{children}(u)$ 为其在有根树中的子节点集合。\n\n**情况1：节点 $u$ 被包含在顶点覆盖中（计算 $DP(u, 1)$）。**\n如果我们将 $u$ 包含在覆盖中，我们为 $u$ 本身付出 $1$ 的代价。通过包含 $u$，所有连接 $u$ 与其子节点 $v \\in \\text{children}(u)$ 的边都被覆盖了。因此，对于每个子节点的子树，我们可以自由选择是否将 $v$ 包含在覆盖中。为了实现以 $u$ 为根的子树的最小覆盖，我们必须为每个子节点的子树独立地做出最优选择。因此，对于每个子节点 $v$，我们选择两个选项中较小的一个：$DP(v, 1)$（包含 $v$）或 $DP(v, 0)$（不包含 $v$）。\n递推关系是：\n$$DP(u, 1) = 1 + \\sum_{v \\in \\text{children}(u)} \\min(DP(v, 0), DP(v, 1))$$\n\n**情况2：节点 $u$ 不被包含在顶点覆盖中（计算 $DP(u, 0)$）。**\n如果我们不将 $u$ 包含在覆盖中，我们为 $u$ 付出 $0$ 的代价。然而，对于每条边 $(u, v)$，其中 $v \\in \\text{children}(u)$，这条边仍然必须被覆盖。由于 $u$ 不在覆盖中，覆盖边 $(u, v)$ 的唯一方法是将子节点 $v$ 包含在覆盖中。这是一个强制性要求，而不是一个选择。因此，对于 $u$ 的每个子节点 $v$，我们必须选择将 $v$ 包含在覆盖中的选项。\n递推关系是：\n$$DP(u, 0) = 0 + \\sum_{v \\in \\text{children}(u)} DP(v, 1)$$\n\n**基本情况：**\n递归在叶节点处终止。叶节点 $u$ 没有子节点，因此递推关系中的求和是空和，其值为 $0$。\n- $DP(u, 1) = 1 + 0 = 1$。这是正确的，因为单节点子树 $\\{u\\}$（没有边）的覆盖需要包含 $u$ 本身，大小为 $1$。\n- $DP(u, 0) = 0 + 0 = 0$。这也是正确的，因为对于没有边的图，空集是一个有效的顶点覆盖。\n\n**最终解：**\n后序遍历完成后，我们将计算出所有节点直到根节点 $r$ 的 DP 值。整个树的最小顶点覆盖的大小是根节点两种情况下的最小值：\n$$ \\text{MVC size} = \\min(DP(r, 0), DP(r, 1)) $$\n这个选择反映了将根节点包含在最终覆盖中是否更优。\n\n**算法实现与复杂度：**\n算法流程如下：\n1.  根据给定的边构建树的邻接表表示。对于一个有 $n$ 个节点的树，这需要 $O(n)$ 的时间。\n2.  选择一个任意的根（例如，节点 $1$）。\n3.  从根开始执行一次 DFS 遍历。DFS 的递归性质自然地促进了后序遍历。\n4.  对于每个节点 $u$，在从其子节点的递归调用返回后，使用推导出的递推关系计算 $DP(u, 0)$ 和 $DP(u, 1)$。\n5.  最终结果通过取 $\\min(DP(\\text{root}, 0), DP(\\text{root}, 1))$ 获得。\n\nDFS 访问每个节点和每条边一次。在每个节点上完成的工作量与其度成正比。树中度的总和是 $2|E| = 2(n-1)$。因此，总时间复杂度为 $O(n + |E|) = O(n)$，满足问题要求。空间复杂度为 $O(n)$，用于邻接表、DP 表和递归栈。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport sys\n\ndef solve():\n    \"\"\"\n    Solves the minimum vertex cover problem for a suite of test trees.\n    \"\"\"\n    # Setting a higher recursion limit is necessary for deep trees,\n    # though not strictly required for the given test cases.\n    sys.setrecursionlimit(2000)\n\n    test_cases = [\n        (1, []),\n        (2, [(1, 2)]),\n        (6, [(1, 2), (1, 3), (1, 4), (1, 5), (1, 6)]),\n        (5, [(1, 2), (2, 3), (3, 4), (4, 5)]),\n        (7, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)]),\n        (9, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (6, 7), (6, 8), (8, 9)]),\n    ]\n\n    results = []\n    \n    for n, edges in test_cases:\n        if n == 0:\n            results.append(0)\n            continue\n        if n == 1:\n            # A single node has no edges, so the minimum vertex cover is the empty set.\n            results.append(0)\n            continue\n\n        # Adjacency list representation for the tree. Nodes are 1-indexed.\n        adj = [[] for _ in range(n + 1)]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n\n        # DP table: dp[u][0] # cost if u is not in VC, dp[u][1] # cost if u is in VC.\n        dp = np.zeros((n + 1, 2), dtype=int)\n\n        # We can pick any node as the root. Let's pick node 1.\n        root = 1\n        # The parent of the root can be an invalid node index like 0.\n        parent_of_root = 0\n        \n        # Perform DFS from the root to compute DP values in a post-order fashion.\n        _dfs_vertex_cover(root, parent_of_root, adj, dp)\n        \n        # The final answer is the minimum of including or not including the root in the VC.\n        result = min(dp[root][0], dp[root][1])\n        results.append(result)\n\n    # Format the final output as specified.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef _dfs_vertex_cover(u, p, adj, dp):\n    \"\"\"\n    Performs a post-order traversal to calculate DP values for minimum vertex cover.\n    \n    Args:\n        u (int): The current node being visited.\n        p (int): The parent of the current node u.\n        adj (list of lists): The adjacency list of the tree.\n        dp (numpy.ndarray): The dynamic programming table.\n    \"\"\"\n    # Base case for the recurrence:\n    # DP(u, 1) starts at 1 for including u itself.\n    dp[u][1] = 1\n    # DP(u, 0) starts at 0 for not including u.\n    dp[u][0] = 0\n\n    # Visit all children of u.\n    for v in adj[u]:\n        if v == p:\n            continue  # Don't go back up the tree.\n        \n        # Recursively call for the child node.\n        _dfs_vertex_cover(v, u, adj, dp)\n        \n        # Apply the recurrence relations after child's DP values are computed.\n        \n        # If u is included (dp[u][1]), we can choose the minimum for its children.\n        dp[u][1] += min(dp[v][0], dp[v][1])\n        \n        # If u is not included (dp[u][0]), its children must be included.\n        dp[u][0] += dp[v][1]\n\nsolve()\n```"
        },
        {
            "introduction": "旅行商问题（TSP）是一个著名的NP-hard问题。虽然不存在适用于所有情况的高效（多项式时间）算法，但我们可以使用状态压缩动态规划为小规模实例找到精确解。这个练习要求你实现Held-Karp算法，其中位掩码（bitmask）用于表示已访问城市的子集，这展示了动态规划在求解计算难题方面的强大能力。这是一个在处理计算难题时，通过指数级复杂度换取精确解的绝佳范例。",
            "id": "3205307",
            "problem": "设计并实现一个程序，该程序使用带有位掩码（bitmasking）的动态规划方法解决小規模的旅行商问题（Traveling Salesperson Problem, TSP），然后从第一性原理推导其最坏情况下的时间和空间复杂度。问题定义如下：给定一个包含 $n$ 个城市（标记为 $\\{0,1,\\ldots,n-1\\}$）的完全有向或无向加权图，其边权重为非负整数，要求找到一条成本最低的哈密顿回路（Hamiltonian cycle），该回路从城市 $0$ 出发，恰好访问每个城市一次，并最终返回城市 $0$。假设 $n \\leq 20$，所有对角线上的元素均为 $0$；如果图是无向的，则权重是对称的。你的任务是完成以下工作。\n\n- 实现一个基于最优性原理和紧凑的子集位掩码表示的动态规划算法，以计算每个给定实例的精确最小旅行成本。请使用精确整数运算。\n- 使用子问题分解和动态规划最优性原理等基本概念来论证你的算法设计，而不是依赖于预先记忆的公式。你还必须使用关于子集和状态转移的计数论证，推导并证明最坏情况下的时间和空间复杂度（用 $n$ 表示）。\n- 对于下面的每个测试实例，计算从城市 $0$ 出发并返回城市 $0$ 的最小旅行成本。所有边的权重都是整数，所有测试用例的输出也都是整数。\n\n使用以下测试套件。每个邻接矩阵都明确地以数组的数组形式给出，第 $i$ 行第 $j$ 列的条目等于从城市 $i$ 到城市 $j$ 的旅行成本。\n\n- 测试用例 A: $n = 1$\n  - 矩阵: $[[0]]$\n- 测试用例 B: $n = 2$\n  - 矩阵: $[[0, 3],[4, 0]]$\n- 测试用例 C: $n = 4$\n  - 矩阵:\n    $[\n      [0, 10, 15, 20],\n      [10, 0, 35, 25],\n      [15, 35, 0, 30],\n      [20, 25, 30, 0]\n    ]$\n- 测试用例 D: $n = 5$ (非对称有向图)\n  - 矩阵:\n    $[\n      [0, 5, 1, 5, 5],\n      [1, 0, 7, 8, 7],\n      [5, 5, 0, 1, 5],\n      [5, 7, 9, 0, 1],\n      [5, 1, 5, 1, 0]\n    ]$\n  刻意设计的廉价回路是 $0 \\rightarrow 2 \\rightarrow 3 \\rightarrow 4 \\rightarrow 1 \\rightarrow 0$，成本为 $5$（此回路上每条边的成本均为 $1$，第一行中所有其他非对角线边的成本均为 $5$；其他行的选择是为了保持所有条目为非负整数）。\n- 测试用例 E: $n = 10$ (对称无向图)\n  - 矩阵:\n    $[\n      [0, 8, 12, 3, 20, 15, 9, 10, 19, 7],\n      [8, 0, 13, 6, 5, 12, 14, 9, 3, 16],\n      [12, 13, 0, 9, 13, 7, 6, 12, 11, 4],\n      [3, 6, 9, 0, 4, 8, 16, 7, 5, 14],\n      [20, 5, 13, 4, 0, 2, 12, 6, 15, 9],\n      [15, 12, 7, 8, 2, 0, 3, 17, 10, 11],\n      [9, 14, 6, 16, 12, 3, 0, 1, 13, 2],\n      [10, 9, 12, 7, 6, 17, 1, 0, 4, 8],\n      [19, 3, 11, 5, 15, 10, 13, 4, 0, 6],\n      [7, 16, 4, 14, 9, 11, 2, 8, 6, 0]\n    ]$\n\n最终输出格式。你的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来，结果按测试用例 A 到 E 的顺序排列。例如，对于通用结果 $r_A$、$r_B$、$r_C$、$r_D$ 和 $r_E$，输出必须是 [r_A,r_B,r_C,r_D,r_E]，不得包含额外的空格或文本。\n\n注释与说明。\n- 使用标准计算模型，其中对固定宽度整数的位运算视为常数时间操作。\n- 本问题不涉及角度和物理单位。\n- 每个测试用例的答案都是整数。",
            "solution": "问题陈述经评估有效。这是一个在算法设计领域中提法恰当、有科学依据的问题，具体涉及旅行商问题（TSP）的一个精确解。该问题是自包含的，提供了所有必要的数据、定义和约束。指定的方法——带位掩码的动态规划——是解决小规模TSP的标准且正确的方法。约束条件（$n \\leq 20$）与该精确算法已知的指数级复杂度是一致的。\n\n**1. 算法设计：基于最优性原理的动态规划**\n\n旅行商问题（TSP）旨在寻找加权图中的最小成本哈密頓回路。我们的任务是找到一个从特定城市（标记为 $0$）出发并结束的此类回路。动态规划解决方案的核心在于定义一个子问题，该子问题可以被用来构建解决更大问题的解，这一性质被称为最优子结构。\n\n设所有城市的集合为 $V = \\{0, 1, \\ldots, n-1\\}$。一次旅行是这些城市的一个排列。我们固定起始城市为 $0$。一条从城市 $0$ 出发并访问城市集合 $S \\subseteq V$ 的路径是一系列不同的城市 $(c_0, c_1, \\ldots, c_k)$，其中 $c_0=0$ 且 $\\{c_0, \\ldots, c_k\\} = S$。\n\n**子问题定义：**\n令 $dp(S, j)$ 表示从城市 $0$ 出发，恰好访问集合 $S \\subseteq V$ 中的每个城市一次，并最终停在城市 $j \\in S$ 的路径的最小成本。起始城市 $0$ 必須在 $S$ 中。\n\n**最优性原理与递推关系：**\n最优性原理指出，一个问题的最优解包含其子问题的最优解。考虑状态 $(S, j)$ 的一条最优路径，其中 $|S|  1$。这条路径必然是从集合 $S \\setminus \\{j\\}$ 中的某个其他城市 $k$ 到达城市 $j$ 的。为了使整条路径最优，从城市 $0$ 到城市 $k$、访问了 $S \\setminus \\{j\\}$ 中所有城市的子路径也必须是最优的。这恰好是子问题 $dp(S \\setminus \\{j\\}, k)$。将这个最优子路径延伸到城市 $j$ 的成本是 $dp(S \\setminus \\{j\\}, k) + \\text{cost}(k, j)$，其中 $\\text{cost}(k, j)$ 是从 $k$ 到 $j$ 的边的权重。为了找到状态 $(S, j)$ 的最小成本，我们必须考虑所有可能的前驱城市 $k$。这就导出了递推关系：\n\n$$\ndp(S, j) = \\min_{k \\in S \\setminus \\{j\\}} \\{ dp(S \\setminus \\{j\\}, k) + \\text{cost}(k, j) \\}\n$$\n\n**基础情况：**\n最小的子问题是从城市 $0$ 出发并结束于城市 $0$，只访问了集合 $\\{0\\}$ 的路径。这条平凡路径的成本为 $0$。\n$$\ndp(\\{0\\}, 0) = 0\n$$\n对于任何其他城市 $j \\neq 0$，$dp(\\{0\\}, j)$ 是未定义的，因为一条只包含城市 $0$ 的路径不能结束于 $j$。我们可以用无穷大作为初始值来表示这种情况。\n\n**使用位掩码实现：**\n已访问城市的集合 $S$ 可以用一个长度为 $n$ 的整数位掩码（bitmask）来高效表示。一个掩码是一个整数，如果城市 $i \\in S$，则其第 $i$ 位为 $1$，否则为 $0$。\n- 集合 $S$ 由一个整数 `mask` 表示。\n- 条件 $j \\in S$ 通过位运算 `(mask >> j)  1 == 1` 来检查。\n- 集合 $S \\setminus \\{j\\}$ 由 `mask ^ (1  j)` 表示。\n\nDP状态变为 $dp[\\text{mask}][j]$。我们可以通过按掩码大小（即置位比特数）递增的顺序，或者更简单地，直接按掩码本身的数值顺序进行迭代，来计算 $dp[\\text{mask}][j]$ 的值。由于子问题的掩码 `prev_mask` 在数值上总是小于当前问题的 `mask`，因此它的值已经被计算过了。\n\n算法流程如下：\n1. 初始化一个 $2^n \\times n$ 的表 $dp$，所有值设为无穷大，用于表示成本。\n2. 设置基础情况：$dp[1][0] = 0$。（集合 $\\{0\\}$ 的掩码是 $2^0 = 1$）。\n3. 从 $2$ 到 $2^n - 1$ 遍历 `mask`。对于每个 `mask`，遍历所有可能的终点城市 `j`（从 $0$ 到 $n-1$）。\n4. 如果城市 `j` 在 `mask` 所表示的集合中，则寻找最优子路径。令 `prev_mask = mask ^ (1  j)`。遍历所有可能的前驱城市 `k`（从 $0$ 到 $n-1$）。\n5. 如果城市 `k` 在 `prev_mask` 所表示的集合中，应用递推关系：$dp[\\text{mask}][j] = \\min(dp[\\text{mask}][j], dp[\\text{prev_mask}][k] + \\text{cost}[k][j])$。\n\n**最终解：**\n在 DP 表完全填充后，条目 $dp[(1 \\ll n) - 1][j]$ 包含了从城市 $0$ 到城市 $j$ 访问所有 $n$ 个城市的最小路径成本。最后一步是通过从城市 $j$ 返回城市 $0$ 来完成回路。我们必须检查所有可能的终点 $j \\in \\{1, \\ldots, n-1\\}$，并找出产生最小总旅行成本的那个。\n$$\n\\text{Minimum Tour Cost} = \\min_{j \\in \\{1, \\ldots, n-1\\}} \\{ dp[(1 \\ll n) - 1][j] + \\text{cost}(j, 0) \\}\n$$\n对于边界情况 $n=1$，旅行路径是平凡的 $0 \\to 0$，成本为 $0$。\n\n**2. 复杂度分析**\n\n**空间复杂度：**\n主要的数据结构是 DP 表，它存储所有子问题的成本。该表有一个维度用于 `mask`，另一个维度用于终点城市 `j`。\n- 可能的掩码数量为 $2^n$。\n- 可能的终点城市数量为 $n$。\n因此，状态（以及DP表中的条目）总数为 $n \\cdot 2^n$。假设每个条目需要常数存储空间，则空间复杂度为 $O(n \\cdot 2^n)$。\n\n**时间复杂度：**\n运行时间由填充 DP 表所需的操作数量决定。这等同于计算每个状态转移的成本之和。计算状态 $dp[\\text{mask}][j]$ 涉及遍历所有可能的前驱 $k$。\n基本计算的总数与以下成正比：\n$$\n\\sum_{\\text{mask}=1}^{2^n-1} \\sum_{j=0}^{n-1} \\sum_{k=0}^{n-1} \\text{work}(mask, j, k)\n$$\n其中，如果 $j$ 在 `mask` 中且 $k$ 在不含 $j$ 的 `mask` 中，则 `work` 为 $O(1)$。我们可以通过按已访问城市集合的大小 $s = |\\text{S}|$ 对状态进行分组来更精确地分析。\n\n设 $s$ 是掩码中置位比特的数量。大小为 $s$ 的掩码数量由二项式系数 $\\binom{n}{s}$ 给出。对于每个这样的掩码，我们可以选择 $s$ 个城市中的任意一个作为终点 $j$。对于 `mask` 和 $j$ 的每一种选择，我们遍历所有 $s-1$ 个可能的前驱城市 $k \\in S \\setminus \\{j\\}$。\n\n因此，内层循环的总执行次数为：\n$$\n\\text{Time} \\propto \\sum_{s=1}^{n} \\left( \\binom{n}{s} \\cdot s \\cdot (s-1) \\right)\n$$\n我们使用组合恒等式 $\\binom{n}{s} s = n \\binom{n-1}{s-1}$ 和 $\\binom{n-1}{s-1} (s-1) = (n-1) \\binom{n-2}{s-2}$：\n$$\n\\sum_{s=2}^{n} \\binom{n}{s} s(s-1) = \\sum_{s=2}^{n} n \\binom{n-1}{s-1} (s-1) = n \\sum_{s=2}^{n} (n-1) \\binom{n-2}{s-2}\n$$\n令 $p = s-2$。则求和变为：\n$$\nn(n-1) \\sum_{p=0}^{n-2} \\binom{n-2}{p}\n$$\n根据二项式定理，$\\sum_{p=0}^{m} \\binom{m}{p} = 2^m$。这里，$m=n-2$。\n$$\nn(n-1) \\cdot 2^{n-2}\n$$\n这个表达式表明，时间复杂度由与 $n^2 2^n$ 成正比的项主导。计算最终旅行成本的最后一步需要 $O(n)$ 时间，可以忽略不计。因此，该算法的最坏情况时间复杂度为 $O(n^2 \\cdot 2^n)$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_tsp(cost_matrix: np.ndarray) -> int:\n    \"\"\"\n    Solves the Traveling Salesperson Problem using dynamic programming with bitmasking.\n\n    Args:\n        cost_matrix: An n x n numpy array representing the cost of travel between cities.\n\n    Returns:\n        The minimum cost of a Hamiltonian cycle starting and ending at city 0.\n    \"\"\"\n    n = cost_matrix.shape[0]\n\n    if n = 1:\n        return 0\n\n    # DP table: dp[mask][j] stores the minimum cost of a path from city 0\n    # to city j, visiting the set of cities represented by 'mask'.\n    # Mask is an integer where the i-th bit is 1 if city i has been visited.\n    dp = np.full((1  n, n), float('inf'))\n\n    # Base case: The path from city 0 to city 0, visiting only {0}, has cost 0.\n    # The mask for {0} is 1 (binary ...001).\n    dp[1, 0] = 0\n\n    # Iterate through all subsets (masks) of cities, from size 2 up to n.\n    # The mask must contain the starting city 0, so bit 0 must be set.\n    for mask in range(3, 1  n, 2):  # iterate over odd masks > 1\n        # 'j' is the current endpoint of the path.\n        for j in range(1, n):\n            # Check if city 'j' is in the current subset 'mask'.\n            if (mask >> j)  1:\n                # 'prev_mask' represents the subset of cities visited before reaching 'j'.\n                prev_mask = mask ^ (1  j)\n                \n                # 'k' is the city visited just before 'j'. It can be any city in 'prev_mask'.\n                for k in range(n):\n                    if (prev_mask >> k)  1:\n                        # If a path to k exists, update the path to j.\n                        if dp[prev_mask, k] != float('inf'):\n                            dp[mask, j] = min(dp[mask, j], dp[prev_mask, k] + cost_matrix[k, j])\n\n    # After filling the DP table, find the minimum total tour cost.\n    # A full tour visits all cities, so the mask is (1  n) - 1.\n    final_mask = (1  n) - 1\n    min_tour_cost = float('inf')\n\n    # We need to return to city 0 from the last visited city 'j'.\n    for j in range(1, n):\n        if dp[final_mask, j] != float('inf'):\n            tour_cost = dp[final_mask, j] + cost_matrix[j, 0]\n            min_tour_cost = min(min_tour_cost, tour_cost)\n\n    # For n=2, the loop for mask starts at 3, so dp[3,1] is calculated.\n    # The final loop computes dp[3,1] + cost[1,0]. For symmetric case, it's correct.\n    # For asymmetric, it is also correct: 0->1->0 tour cost.\n    # If no tour is found (e.g., disconnected graph, but problem states complete graph),\n    # min_tour_cost would remain 'inf'. For TSP on a complete graph with n>1, a tour always exists.\n    # A special case is n=2, for which the main loop is not entered. `solve_tsp` for B (n=2) gives 7.\n    # Let's trace n=2: `range(3, 4, 2)` -> mask=3. `j=1`. `(3>>1)1` is true. `prev_mask = 3 ^ 2 = 1`. `k=0`. `(1>>0)1` is true. `dp[1,0]=0`. `dp[3,1] = min(inf, 0 + cost[0,1]) = 3`.\n    # Final loop: `j=1`. `dp[3,1]` is 3. `tour_cost = 3 + cost[1,0] = 3+4=7`. Correct.\n\n    return int(min_tour_cost) if min_tour_cost != float('inf') else 0\n\ndef solve():\n    test_cases_data = {\n        'A': [[0]],\n        'B': [[0, 3], [4, 0]],\n        'C': [\n            [0, 10, 15, 20],\n            [10, 0, 35, 25],\n            [15, 35, 0, 30],\n            [20, 25, 30, 0]\n        ],\n        'D': [\n            [0, 5, 1, 5, 5],\n            [1, 0, 7, 8, 7],\n            [5, 5, 0, 1, 5],\n            [5, 7, 9, 0, 1],\n            [5, 1, 5, 1, 0]\n        ],\n        'E': [\n            [0, 8, 12, 3, 20, 15, 9, 10, 19, 7],\n            [8, 0, 13, 6, 5, 12, 14, 9, 3, 16],\n            [12, 13, 0, 9, 13, 7, 6, 12, 11, 4],\n            [3, 6, 9, 0, 4, 8, 16, 7, 5, 14],\n            [20, 5, 13, 4, 0, 2, 12, 6, 15, 9],\n            [15, 12, 7, 8, 2, 0, 3, 17, 10, 11],\n            [9, 14, 6, 16, 12, 3, 0, 1, 13, 2],\n            [10, 9, 12, 7, 6, 17, 1, 0, 4, 8],\n            [19, 3, 11, 5, 15, 10, 13, 4, 0, 6],\n            [7, 16, 4, 14, 9, 11, 2, 8, 6, 0]\n        ]\n    }\n\n    results = []\n    # Process test cases in alphabetical order of their keys\n    for key in sorted(test_cases_data.keys()):\n        cost_matrix = np.array(test_cases_data[key])\n        result = solve_tsp(cost_matrix)\n        results.append(result)\n    \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}