{
    "hands_on_practices": [
        {
            "introduction": "掌握一个算法不仅意味着理解其一般情况，更在于洞悉其在边界条件下的行为。这个练习将带你探讨0/1背包问题的一个特殊实例：当背包容量甚至小于最轻物品的重量时，动态规划算法将如何处理。通过解决这个问题，你将能检验自己对DP表初始化（基础情况）和递推关系如何正确传播值的理解，从而加深对算法核心机制的掌握。",
            "id": "3202252",
            "problem": "考虑一个包含 $n$ 个物品的 $0/1$ 背包问题，其中每个物品 $i$ 都有一个正整数重量 $w_i$ 和一个正整数价值 $v_i$，背包的容量为一个正整数 $W$。目标是选择一个物品子集，使得在总重量不超过 $W$ 的约束下，总价值最大化。\n\n给定以下实例：\n$$\nn = 5, \\quad W = 6,\n$$\n$$\n(w_1, w_2, w_3, w_4, w_5) = (7, 9, 11, 13, 15),\n$$\n$$\n(v_1, v_2, v_3, v_4, v_5) = (10, 14, 20, 26, 31).\n$$\n\n使用 $0/1$ 背包问题的标准动态规划 (DP) 表述，确定算法针对此实例所能达到的最优总价值 $V^{\\ast}$。在您的推理中，请审视对于容量 $j$（其中 $0 \\leq j \\leq W$），DP基本情况的行为，以验证当 $W  \\min_{i} w_i$ 时的正确性。将最终答案表示为一个精确的实数。无需四舍五入。",
            "solution": "用户提供了一个有效的问题陈述。\n\n该问题是经典 $0/1$ 背包问题的一个实例，这是一个定义明确的组合优化问题。所提供的数据是自洽且一致的。要求是应用标准的动态规划 (DP) 算法，并审视其在背包容量小于任何物品重量的特定条件下的行为。这是一个合理且有科学依据的提问，旨在测试对算法机制的理解，特别是其基本情况和递推逻辑。\n\n$0/1$ 背包问题可正式表述如下：给定一组 $n$ 个物品，每个物品都有重量 $w_i  0$ 和价值 $v_i  0$，以及一个总容量为 $W$ 的背包，目标是找到一个物品子集，使其总价值最大化，但所选物品的重量之和不得超过 $W$。\n\n标准的动态规划解决方案涉及创建一个大小为 $(n+1) \\times (W+1)$ 的表，我们将其表示为 $dp$。状态 $dp(i, j)$ 表示使用前 $i$ 个物品（从物品1到物品 $i$）的子集，在背包容量为 $j$ 的情况下可以实现的最大价值。\n\n递推关系定义如下：\n$$\ndp(i, j) =\n\\begin{cases}\ndp(i-1, j),  \\text{if } w_i  j \\\\\n\\max(dp(i-1, j), v_i + dp(i-1, j-w_i)),  \\text{if } w_i \\le j\n\\end{cases}\n$$\n对于 $i \\in \\{1, \\dots, n\\}$ 和 $j \\in \\{1, \\dots, W\\}$。\n\n该递推的基本情况是：\n1. 对所有 $j \\in \\{0, \\dots, W\\}$，$dp(0, j) = 0$。这对应于没有物品可选的情况，因此无论背包容量如何，总价值始终为 $0$。\n2. 对所有 $i \\in \\{0, \\dots, n\\}$，$dp(i, 0) = 0$。这对应于容量为 $0$ 的背包，它无法容纳任何具有正重量的物品，因此总价值始终为 $0$。\n\n给定的问题实例提供了以下参数：\n- 物品数量：$n = 5$\n- 背包容量：$W = 6$\n- 物品重量：$(w_1, w_2, w_3, w_4, w_5) = (7, 9, 11, 13, 15)$\n- 物品价值：$(v_1, v_2, v_3, v_4, v_5) = (10, 14, 20, 26, 31)$\n\n最终答案是 $dp(n, W) = dp(5, 6)$ 的值。\n\n对于这个特定实例，一个关键的观察是每个物品的重量都大于背包的容量。最小重量是 $\\min_{i \\in \\{1, \\dots, 5\\}} w_i = w_1 = 7$。由于 $W=6$，对于所有物品 $i \\in \\{1, \\dots, 5\\}$，条件 $w_i  W$ 均成立。因此，对于任何容量 $j \\le W$ 的子问题，条件 $w_i  j$ 将永远为真。\n\n这意味着对于所有 $i \\in \\{1, \\dots, 5\\}$ 和所有 $j \\in \\{0, \\dots, 6\\}$，将只会调用递推关系的第一种情况：\n$$\ndp(i, j) = dp(i-1, j)\n$$\n这是因为不可能将任何物品 $i$ 放入容量为 $j \\le 6$ 的背包中，因为物品的重量 $w_i$ 太大了。DP 算法通过指出使用前 $i$ 个物品能达到的最优结果与使用前 $i-1$ 个物品能达到的最优结果相同，从而正确地捕捉了这一事实。\n\n让我们构建 $i \\in \\{0, \\dots, 5\\}$ 和 $j \\in \\{0, \\dots, 6\\}$ 的 DP 表，以按要求演示该过程。\n\n第0步：初始化（基本情况）\n表的第一行 ($i=0$) 和第一列 ($j=0$) 被初始化为 $0$。\n对 $j \\in \\{0, 1, 2, 3, 4, 5, 6\\}$，$dp(0, j) = 0$。\n对 $i \\in \\{0, 1, 2, 3, 4, 5\\}$，$dp(i, 0) = 0$。\n\n第1步：考虑物品1 ($i=1$)\n重量为 $w_1 = 7$。对于每个容量 $j \\in \\{1, \\dots, 6\\}$，我们有 $w_1  j$。\n因此，对于每个 $j$，我们应用 $dp(1, j) = dp(0, j)$。\n$dp(1, 1) = dp(0, 1) = 0$\n$dp(1, 2) = dp(0, 2) = 0$\n...\n$dp(1, 6) = dp(0, 6) = 0$\n对于 $i=1$ 的整行都保持为 $0$。\n\n第2步：考虑物品2 ($i=2$)\n重量为 $w_2 = 9$。对于每个容量 $j \\in \\{1, \\dots, 6\\}$，我们有 $w_2  j$。\n因此，对于每个 $j$，我们应用 $dp(2, j) = dp(1, j)$。\n$dp(2, 1) = dp(1, 1) = 0$\n$dp(2, 2) = dp(1, 2) = 0$\n...\n$dp(2, 6) = dp(1, 6) = 0$\n对于 $i=2$ 的整行都保持为 $0$。\n\n这个模式对所有后续物品都成立。\n\n第3步：考虑物品3 ($i=3$, $w_3=11$) 。对于所有 $j \\le 6$，$w_3  j$，因此 $dp(3, j) = dp(2, j) = 0$。\n第4步：考虑物品4 ($i=4$, $w_4=13$) 。对于所有 $j \\le 6$，$w_4  j$，因此 $dp(4, j) = dp(3, j) = 0$。\n第5步：考虑物品5 ($i=5$, $w_5=15$) 。对于所有 $j \\le 6$，$w_5  j$，因此 $dp(5, j) = dp(4, j) = 0$。\n\n传播过程是直接的：\n$dp(5, 6) = dp(4, 6)$ 因为 $w_5 = 15  6$。\n$dp(4, 6) = dp(3, 6)$ 因为 $w_4 = 13  6$。\n$dp(3, 6) = dp(2, 6)$ 因为 $w_3 = 11  6$。\n$dp(2, 6) = dp(1, 6)$ 因为 $w_2 = 9  6$。\n$dp(1, 6) = dp(0, 6)$ 因为 $w_1 = 7  6$。\n\n从基本情况我们知道 $dp(0, 6) = 0$。因此，通过这个递推链，我们得到 $dp(5, 6) = 0$。\n\n完整的 DP 表将是一个 $6 \\times 7$ 的矩阵（对于 $i=0..5, j=0..6$），完全由零填充。这正确地反映了没有物品可以放入背包的事实。最优总价值 $V^{\\ast}$ 是单元格 $dp(n, W) = dp(5, 6)$ 中的值。\n\n因此，最优总价值是 $0$。对 DP 算法行为的审视证实，它通过从基本情况系统地传播零值解，正确处理了 $W  \\min_{i} w_i$ 的情况。",
            "answer": "$$\n\\boxed{0}\n$$"
        },
        {
            "introduction": "理解动态规划的威力后，一个自然的问题是：为什么我们不能使用更简单的贪心策略，比如优先选择性价比（价值/重量比）最高的物品呢？这个练习将引导你深入探究贪心算法在0/1背包问题上的局限性。你将通过分析和构造一个“最坏情况”的实例，来证明贪心策略得到的结果可能与最优解相差甚远，这对于深刻理解0/1背包问题的复杂性至关重要。",
            "id": "3202339",
            "problem": "给定0-1背包问题，有一组物品，每个物品 $i$ 都有一个正整数重量 $w_i$ 和一个正整数价值 $v_i$，以及一个容量为 $C$ 的背包。目标是选择一个物品子集，使得在总重量不超过 $C$ 的约束下，价值总和最大化。考虑按价值重量比贪心的启发式算法，该算法重复选择剩余物品中价值重量比 $v_i / w_i$ 最高且仍然能放入背包的物品，直到没有物品可以再添加为止。仅使用问题的核心定义和贪心选择规则，确定以下哪个参数化实例族会导致按价值重量比贪心的启发式算法具有最差的渐近性能，即随着参数的增长，启发式算法的目标值与最优目标值的比率趋于 $0$。\n\n每个选项描述了一个由整数参数 $m$ 索引的实例族，并指定了容量和物品。在每个选项中，所有重量和价值都是整数。\n\nA. 对于每个整数 $m \\ge 2$：容量 $C = m$。物品：\n- 物品 $H$：重量 $w_H = m$，价值 $v_H = 2m - 1$。\n- 物品 $D$：重量 $w_D = 1$，价值 $v_D = 2$。\n没有其他物品。\n\nB. 对于每个整数 $m \\ge 2$：容量 $C = m$。物品：\n- $m$ 个物品，每个重量 $w = 1$，价值 $v = 1$。\n- 物品 $H$：重量 $w_H = m$，价值 $v_H = m - 1$。\n没有其他物品。\n\nC. 对于每个整数 $m \\ge 4$：容量 $C = m$。物品：\n- 物品 $H$：重量 $w_H = m$，价值 $v_H = m$。\n- 物品 $D$：重量 $w_D = \\lfloor m/2 \\rfloor + 1$，价值 $v_D = \\lfloor m/2 \\rfloor + 2$。\n没有其他物品。\n\nD. 对于每个整数 $m \\ge 3$：容量 $C = m$。物品：\n- 物品 $H$：重量 $w_H = m - 1$，价值 $v_H = m$。\n- 物品 $S$：重量 $w_S = 1$，价值 $v_S = 1$。\n没有其他物品。\n\n当 $m \\to \\infty$ 时，哪个选项展示了按价值重量比贪心的启发式算法最差的渐近性能？",
            "solution": "问题陈述是关于0/1背包问题贪心算法性能分析的一个标准表述。它具有科学依据，问题定义明确，客观，并包含了所有必要的信息。该问题是有效的。\n\n问题的核心是分析按价值重量比贪心的启发式算法在四种不同的、由整数 $m$ 参数化的0/1背包问题实例族上的渐近性能。性能度量是贪心启发式算法获得的价值 $V_{greedy}$ 与最优解获得的价值 $V_{optimal}$ 的比率。我们正在寻找当 $m \\to \\infty$ 时，该比率 $R(m) = V_{greedy} / V_{optimal}$ 趋于 $0$ 的实例族。\n\n我们来逐一分析每个选项。\n\nA. 对于每个整数 $m \\ge 2$：容量 $C = m$。\n物品：\n- 物品 $H$：重量 $w_H = m$，价值 $v_H = 2m - 1$\n- 物品 $D$：重量 $w_D = 1$，价值 $v_D = 2$\n\n首先，我们计算价值重量比：\n- 物品 $H$ 的比率：$\\frac{v_H}{w_H} = \\frac{2m - 1}{m} = 2 - \\frac{1}{m}$\n- 物品 $D$ 的比率：$\\frac{v_D}{w_D} = \\frac{2}{1} = 2$\n\n对于任何 $m \\ge 2$，我们有 $2  2 - \\frac{1}{m}$。因此，物品 $D$ 的比率严格更高。\n\n按价值重量比贪心的启发式算法过程如下：\n1.  选择物品 $D$（最高比率）。其重量 $w_D = 1 \\le C = m$，所以能装下。\n2.  背包现在包含物品 $D$，总价值为 $v_D = 2$。剩余容量为 $C' = C - w_D = m - 1$。\n3.  考虑下一个物品 $H$。其重量为 $w_H = m$。由于 $w_H  C'$，物品 $H$ 装不下。\n4.  没有更多物品可以添加。启发式算法终止。\n\n贪心启发式算法获得的总价值是 $V_{greedy} = 2$。\n\n现在，我们来寻找最优解。可能有效的物品子集是 $\\{D\\}$ 和 $\\{H\\}$。子集 $\\{H, D\\}$ 是无效的，因为其总重量 $w_H + w_D = m + 1  C = m$。\n- 子集 $\\{D\\}$ 的价值是 $v_D = 2$。\n- 子集 $\\{H\\}$ 的价值是 $v_H = 2m - 1$。\n对于 $m \\ge 2$，$v_H = 2m - 1 \\ge 2(2) - 1 = 3  2$。因此，最优选择是只拿物品 $H$。\n最优价值是 $V_{optimal} = v_H = 2m - 1$。\n\n性能比率为 $R_A(m) = \\frac{V_{greedy}}{V_{optimal}} = \\frac{2}{2m - 1}$。\n当 $m \\to \\infty$ 时，其渐近性能是该比率的极限：\n$$ \\lim_{m \\to \\infty} R_A(m) = \\lim_{m \\to \\infty} \\frac{2}{2m - 1} = 0 $$\n该比率趋于 $0$。这个实例族表现出了所描述的最差情况渐近行为。\n\n基于此分析，选项A是正确答案的候选者。\n\nB. 对于每个整数 $m \\ge 2$：容量 $C = m$。\n物品：\n- $m$ 个物品（我们称之为 $S_i$，其中 $i=1, \\dots, m$），每个重量 $w_{S_i} = 1$，价值 $v_{S_i} = 1$。\n- 物品 $H$：重量 $w_H = m$，价值 $v_H = m - 1$。\n\n价值重量比为：\n- 每个物品 $S_i$ 的比率：$\\frac{v_{S_i}}{w_{S_i}} = \\frac{1}{1} = 1$\n- 物品 $H$ 的比率：$\\frac{v_H}{w_H} = \\frac{m - 1}{m} = 1 - \\frac{1}{m}$\n\n对于任何 $m \\ge 2$，我们有 $1  1 - \\frac{1}{m}$。物品 $S_i$ 具有最高的比率。\n\n贪心启发式算法过程如下：\n1.  选择一个物品 $S_1$（比率为1）。能装下。剩余容量为 $m-1$。\n2.  选择 $S_2$。能装下。剩余容量为 $m-2$。\n...\nm. 选择 $S_m$。能装下。剩余容量为 $m - m = 0$。\n该启发式算法装入了所有 $m$ 个 S 类型的物品。总重量为 $m \\times 1 = m$，总价值为 $m \\times 1 = m$。没有其他物品可以添加。\n获得的总价值为 $V_{greedy} = m$。\n\n对于最优解，我们比较两种主要可能性：\n- 装入所有 $m$ 个 S 类型的物品：总价值为 $m$。\n- 装入物品 $H$：总价值为 $v_H = m - 1$。\n由于对所有 $m$ 都有 $m  m - 1$，最优解是装入 $m$ 个小物品。\n最优价值为 $V_{optimal} = m$。\n\n性能比率为 $R_B(m) = \\frac{V_{greedy}}{V_{optimal}} = \\frac{m}{m} = 1$。\n渐近性能为 $\\lim_{m \\to \\infty} R_B(m) = 1$。该比率不趋于 $0$。\n因此，该选项不正确。\n\nC. 对于每个整数 $m \\ge 4$：容量 $C = m$。\n物品：\n- 物品 $H$：重量 $w_H = m$，价值 $v_H = m$。\n- 物品 $D$：重量 $w_D = \\lfloor m/2 \\rfloor + 1$，价值 $v_D = \\lfloor m/2 \\rfloor + 2$。\n\n价值重量比为：\n- 物品 $H$ 的比率：$\\frac{v_H}{w_H} = \\frac{m}{m} = 1$。\n- 物品 $D$ 的比率：$\\frac{v_D}{w_D} = \\frac{\\lfloor m/2 \\rfloor + 2}{\\lfloor m/2 \\rfloor + 1} = 1 + \\frac{1}{\\lfloor m/2 \\rfloor + 1}$。\n由于 $m \\ge 4$，$\\lfloor m/2 \\rfloor \\ge 2$，所以 $D$ 的比率严格大于 $1$。\n\n贪心启发式算法首先选择物品 $D$。\n其重量 $w_D = \\lfloor m/2 \\rfloor + 1 \\le m/2 + 1$。对于 $m \\ge 2$，$m \\ge m/2 + 1$，所以该物品能装下。剩余容量为 $m - (\\lfloor m/2 \\rfloor + 1)$。重量为 $w_H = m$ 的物品 $H$ 装不下。\n启发式算法终止，背包中只有物品 $D$。\n获得的价值为 $V_{greedy} = v_D = \\lfloor m/2 \\rfloor + 2$。\n\n对于最优解，我们比较拿物品 $D$ 和拿物品 $H$ 的情况：\n- 拿 $D$ 的价值：$v_D = \\lfloor m/2 \\rfloor + 2$。\n- 拿 $H$ 的价值：$v_H = m$。\n对于 $m \\ge 4$，我们有 $m  m/2 + 1$，这意味着 $m/2 - 1  0$。同时，$\\lfloor m/2 \\rfloor \\le m/2$。因此 $m - (\\lfloor m/2 \\rfloor + 2) \\ge m - (m/2 + 2) = m/2 - 2$。对于 $m \\ge 4$，$m/2-2 \\ge 0$，所以 $m \\ge m/2+2 \\ge \\lfloor m/2 \\rfloor + 2$。最优解是拿物品 $H$。\n最优价值为 $V_{optimal} = m$。\n\n性能比率为 $R_C(m) = \\frac{V_{greedy}}{V_{optimal}} = \\frac{\\lfloor m/2 \\rfloor + 2}{m}$。\n为了求极限，我们可以使用夹逼定理 (Squeeze Theorem)。我们知道 $\\frac{m}{2} - 1 \\le \\lfloor m/2 \\rfloor \\le \\frac{m}{2}$。\n所以，$\\frac{m/2 + 1}{m} \\le \\frac{\\lfloor m/2 \\rfloor + 2}{m} \\le \\frac{m/2 + 2}{m}$。\n当 $m \\to \\infty$ 时，下界 $\\frac{m/2 + 1}{m} \\to \\frac{1}{2}$ 和上界 $\\frac{m/2 + 2}{m} \\to \\frac{1}{2}$。\n$$ \\lim_{m \\to \\infty} R_C(m) = \\frac{1}{2} $$\n该比率趋于 $1/2$，而不是 $0$。\n因此，该选项不正确。\n\nD. 对于每个整数 $m \\ge 3$：容量 $C = m$。\n物品：\n- 物品 $H$：重量 $w_H = m - 1$，价值 $v_H = m$。\n- 物品 $S$：重量 $w_S = 1$，价值 $v_S = 1$。\n\n价值重量比为：\n- 物品 $H$ 的比率：$\\frac{v_H}{w_H} = \\frac{m}{m - 1} = 1 + \\frac{1}{m - 1}$。\n- 物品 $S$ 的比率：$\\frac{v_S}{w_S} = \\frac{1}{1} = 1$。\n对于 $m \\ge 3$，$H$ 的比率严格大于 $S$ 的比率。\n\n贪心启发式算法过程如下：\n1.  选择物品 $H$。其重量 $w_H = m - 1 \\le C = m$，所以能装下。\n2.  背包中包含物品 $H$。价值为 $v_H = m$。剩余容量为 $C' = C - w_H = m - (m-1) = 1$。\n3.  考虑物品 $S$。其重量为 $w_S = 1$。由于 $w_S \\le C'$，它能装下。\n4.  背包现在同时包含物品 $H$ 和 $S$。\n总价值为 $V_{greedy} = v_H + v_S = m + 1$。\n\n最优解必须至少与贪心解一样好。贪心算法装入了所有可用的物品，实现了 $m+1$ 的总价值。由于没有更多物品可以添加，这显然就是最优解。\n最优价值为 $V_{optimal} = m + 1$。\n\n性能比率为 $R_D(m) = \\frac{V_{greedy}}{V_{optimal}} = \\frac{m + 1}{m + 1} = 1$。\n渐近性能为 $\\lim_{m \\to \\infty} R_D(m) = 1$。该比率不趋于 $0$。在这种情况下，贪心启发式算法总是最优的。\n因此，该选项不正确。\n\n结果总结：\n- 选项A: $\\lim_{m \\to \\infty} R_A(m) = 0$。\n- 选项B: $\\lim_{m \\to \\infty} R_B(m) = 1$。\n- 选项C: $\\lim_{m \\to \\infty} R_C(m) = 1/2$。\n- 选项D: $\\lim_{m \\to \\infty} R_D(m) = 1$。\n\n只有选项A中的实例族导致按价值重量比贪心的启发式算法的性能比率随着参数 $m$ 的增长而趋于 $0$。这代表了问题陈述中定义的最差渐近性能。\n\n选项的最终评估：\n- 选项A：正确。性能比率趋于 $0$。\n- 选项B：不正确。性能比率趋于 $1$。\n- 选项C：不正确。性能比率趋于 $1/2$。\n- 选项D：不正确。性能比率趋于 $1$。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "虽然动态规划是解决0/1背包问题的经典方法，但当背包容量 $W$ 极大时，其伪多项式时间的复杂度会变得不切实际。这个练习将向你介绍一种更高级的“相遇在中间”算法，它能有效应对这种情况。该方法将原问题分解为两个独立的子问题，然后巧妙地合并它们的解集。通过亲手执行枚举、剪枝（去除被支配的解）和合并结果的完整流程，你不仅能解决一个复杂的背包实例，还能掌握一种强大的分治思想，为解决其他指数级问题提供新的思路。",
            "id": "3202355",
            "problem": "考虑如下定义的$0/1$背包问题：给定一个包含$n$个物品的集合，每个物品$i$具有非负整数重量$w_i$和价值$v_i$，以及一个背包容量$W$。目标是选择一个子集$S \\subseteq \\{1,\\dots,n\\}$，在满足容量约束$\\sum_{i \\in S} w_i \\leq W$的条件下，最大化总价值$\\sum_{i \\in S} v_i$。请从这个组合优化问题及其可行解集的基本定义出发。特别地，使用以下核心思想：可行集是物品的所有子集，对于物品集的任意一个两半划分，可以构建每一半的所有子集-重量-价值对的集合，然后将它们组合起来以恢复全局最优解。\n\n给定$n = 10$个物品，它们被分成各有$5$个物品的两半$A$和$B$，背包容量为$W = 50$。这些物品的重量和价值如下：\n- $A$半部分：物品$A_1$的$(w,v) = (9,16)$，物品$A_2$为$(12,24)$，物品$A_3$为$(7,13)$，物品$A_4$为$(14,28)$，物品$A_5$为$(6,11)$。\n- $B$半部分：物品$B_1$的$(w,v) = (8,15)$，物品$B_2$为$(10,19)$，物品$B_3$为$(5,9)$，物品$B_4$为$(11,23)$，物品$B_5$为$(4,7)$。\n\n如果存在另一对$(w',v')$满足$w' \\leq w$和$v' \\geq v$（其中至少一个不等式为严格不等式），那么我们就称对$(w,v)$是被支配的，因为被支配的对永远不能比支配它的对导向更好的可行解。在“中途相遇”法中，我们为每一半枚举所有的子集对$(w,v)$，剪除被支配的对以获得一个在组合下保持最优性的前沿，然后在两个前沿之间搜索最优的可行组合。\n\n请仅从可行集和容量约束的基础定义出发，通过对枚举和支配关系进行仔细推理，不假定任何快捷公式，通过以下步骤确定给定物品在容量$W = 50$下可实现的最大总价值：\n1. 为每一半构建所有子集的$(w,v)$对。\n2. 剪除被支配的对，形成一个价值随重量增加而严格递增的前沿。\n3. 在容量约束下组合两个前沿，以找到最优的可行总价值。\n\n此外，请根据每一半中枚举的子集和存储的对的数量，解释为什么这种中途相遇构造法使用$O(2^{n/2})$的时间和$O(2^{n/2})$的内存。最终答案必须是实现的最大总价值的单个实数值；无需四舍五入。",
            "solution": "该问题要求使用“中途相遇”算法解决一个0/1背包问题的特定实例。这是一个有效的、定义明确的问题，旨在测试对分治策略、组合枚举和支配关系剪枝的理解。\n\n**中途相遇算法概述**\n\n该算法通过将问题分解为两个较小的、独立的子问题来解决0/1背包问题。\n1.  将 $n$ 个物品分成两个大小约为 $n/2$ 的子集（本例中为 $A$ 和 $B$）。\n2.  为每个子集，生成所有可能的物品组合（子集），并计算每个组合的总重量和总价值。这将为每个子集生成 $2^{n/2}$ 个 $(w,v)$ 对。\n3.  对每个子集的 $(w,v)$ 对列表进行剪枝，移除“被支配”的对。如果存在另一对 $(w',v')$ 使得 $w' \\leq w$ 且 $v' \\geq v$，则称对 $(w,v)$ 被支配。剪枝后，我们得到两个“帕累托前沿”列表，其中价值随重量的增加而严格递增。\n4.  组合这两个前沿列表，找到一对 $(w_A, v_A)$ 和 $(w_B, v_B)$（分别来自 $A$ 和 $B$ 的前沿），使得 $w_A + w_B \\leq W$ 并且 $v_A + v_B$ 最大化。\n\n**第 1 步：为每一半构建所有子集的 (w,v) 对**\n\n对于 $n=10$ 的物品，我们将其分成两半，每半有 $n/2=5$ 个物品。我们将为每一半生成 $2^5 = 32$ 个子集的重量-价值对。\n\n-   **A 半部分**：$A_1(9,16), A_2(12,24), A_3(7,13), A_4(14,28), A_5(6,11)$\n-   **B 半部分**：$B_1(8,15), B_2(10,19), B_3(5,9), B_4(11,23), B_5(4,7)$\n\n生成所有 32 个子集的列表过于冗长，但这个过程是系统性的。例如，对于 A 半部分，子集 $\\{A_1, A_5\\}$ 的对是 $(9+6, 16+11) = (15,27)$。空集的对是 $(0,0)$。包含所有物品的子集的对是 $(48, 92)$。对 B 半部分也进行同样的操作。\n\n**第 2 步：剪除被支配的对**\n\n在为每一半生成了 32 个 $(w,v)$ 对之后，我们对它们进行剪枝。首先按重量对列表进行排序，然后移除被支配的对，只保留那些形成帕累托最优前沿的对。\n\n经过枚举、排序和剪枝，我们得到以下两个前沿列表：\n\n**A 半部分的前沿 ($P_A$)**：\n$P_A = [(0,0), (6,11), (7,13), (9,16), (12,24), (14,28), (16,29), (18,35), (19,37), (20,39), (21,41), (23,44), (25,48), (26,52), (28,53), (29,55), (30,57), (32,63), (33,65), (35,68), (39,76), (41,79), (42,81), (48,92)]$\n\n**B 半部分的前沿 ($P_B$)**：\n$P_B = [(0,0), (4,7), (5,9), (8,15), (9,16), (10,19), (11,23), (13,24), (14,26), (15,30), (16,32), (18,34), (19,38), (20,39), (21,42), (23,45), (24,47), (25,49), (26,51), (28,54), (29,57), (30,58), (33,64), (34,66), (38,73)]$\n\n**第 3 步：组合两个前沿**\n\n现在我们组合这两个前沿以找到最大价值。背包容量 $W=50$。我们使用一种高效的双指针方法。一个指针 $i$ 从 $P_A$ 的开头开始，另一个指针 $j$ 从 $P_B$ 的末尾开始。\n\n1.  初始化 `max_value = 0`，`i = 0` (指向 $P_A$ 的第一个元素)，`j` 指向 $P_B$ 的最后一个元素。\n2.  循环直到两个指针交错。在每一步：\n    *   令 $(w_A, v_A)$ 为 $P_A[i]$，$(w_B, v_B)$ 为 $P_B[j]$。\n    *   如果 $w_A + w_B \\leq 50$：这是一个可行的组合。我们计算其总价值 $v_A + v_B$ 并更新 `max_value = max(max_value, v_A + v_B)`。由于我们已经为当前的 $w_A$ 找到了最佳的搭档（因为 $P_B$ 是按价值递增的），我们移动到 $P_A$ 的下一个元素以寻找更好的解，即 $i++$。\n    *   如果 $w_A + w_B  50$：组合的重量太大了。为了使总重量减小，我们必须从 $P_B$ 中选择一个较轻的物品（这将伴随着较低的价值），即 $j--$。\n\n执行此过程：\n-   初始，`i=0`, $P_A[0]=(0,0)$。`j` 从 $P_B$ 的末尾开始。\n-   $P_A[0]=(0,0) + P_B[24]=(38,73) \\implies w=38, v=73$。`max_value=73`。`i++`。\n-   $P_A[1]=(6,11) + P_B[24]=(38,73) \\implies w=44, v=84$。`max_value=84`。`i++`。\n-   $P_A[2]=(7,13) + P_B[24]=(38,73) \\implies w=45, v=86$。`max_value=86`。`i++`。\n-   $P_A[3]=(9,16) + P_B[24]=(38,73) \\implies w=47, v=89$。`max_value=89`。`i++`。\n-   $P_A[4]=(12,24) + P_B[24]=(38,73) \\implies w=50, v=97$。`max_value=97`。`i++`。\n-   $P_A[5]=(14,28) + P_B[24]=(38,73) \\implies w=52  50$。`j--`。\n-   $P_A[5]=(14,28) + P_B[23]=(34,66) \\implies w=48, v=94$。`max_value` 仍为 97。`i++`。\n-   ...\n-   $P_A[10]=(21,41) + P_B[20]=(29,57) \\implies w=50, v=98$。`max_value=98`。`i++`。\n-   ...\n-   $P_A[13]=(26,52) + P_B[16]=(24,47) \\implies w=50, v=99$。`max_value=99`。`i++`。\n-   ...\n-   $P_A[20]=(39,76) + P_B[6]=(11,23) \\implies w=50, v=99$。`max_value` 仍为 99。`i++`。\n\n继续该过程，直到两个指针遍历完各自的列表。最终，我们发现可实现的最大总价值是 99。\n\n**时间与空间复杂度分析**\n\n-   **时间复杂度**:\n    1.  将物品集分为两半。\n    2.  为每一半生成所有 $2^{n/2}$ 个子集，这需要 $O(2^{n/2})$ 时间。\n    3.  对每一半的 $2^{n/2}$ 个 $(w,v)$ 对进行排序，需要 $O(2^{n/2} \\log(2^{n/2})) = O(n \\cdot 2^{n/2})$ 时间。\n    4.  剪枝和合并步骤都需要线性时间，即 $O(2^{n/2})$。\n    因此，总时间复杂度由排序步骤主导，为 $O(n \\cdot 2^{n/2})$。问题的提问框架简化了这一点，强调了关键的指数因子 $2^{n/2}$，这是因为算法的核心开销来自于需要枚举和处理的子集数量，即 $2^{n/2}$ 个。\n-   **空间复杂度**:\n    我们需要存储为每一半生成的所有 $(w,v)$ 对。在剪枝之前，这需要存储 $2 \\times 2^{n/2}$ 个对。因此，空间复杂度为 $O(2^{n/2})$。\n\n这种方法显著优于暴力搜索所有 $2^n$ 个子集的 $O(n \\cdot 2^n)$ 复杂度，尤其是当 $n$ 适中时（例如，n=40）。\n\n**最终答案**\n\n通过执行中途相遇算法，我们确定给定物品和容量 $W=50$ 的最大总价值是 99。",
            "answer": "$$\n\\boxed{99}\n$$"
        }
    ]
}