{
    "hands_on_practices": [
        {
            "introduction": "这个首个练习旨在让学生掌握分治法的基本思想。通过将该算法应用于一个映射到整数权重的字符串，学生可以巩固处理左半部分、右半部分和跨越中点的子数组的核心逻辑。此外，严格的平局决胜规则能够锻炼学生对实现细节的关注，这是算法设计中一项至关重要的技能。",
            "id": "3250522",
            "problem": "给定一个由小写英文字母组成的有限字符串。通过对应关系 $a \\mapsto 1, b \\mapsto 2, \\ldots, z \\mapsto 26$ 将每个字符映射到一个整数权重。考虑按顺序从给定字符串构造的整数权重数组 $A$。一个连续子串对应于 $A$ 的一个连续子数组。定义连续子数组 $A[i..j]$ 的和为 $S(i,j) = \\sum_{t=i}^{j} A[t]$。任务是使用分治（DC）范式计算最大子数组和以及相应子串的索引，并遵循以下平局打破规则：如果多个子串达到相同的最大和，选择起始索引 $i$ 最小的那个；如果仍然存在平局，则选择结束索引 $j$ 最小的那个。索引必须使用从 $0$ 开始的编号方式报告。如果字符串为空，定义最大和为 $0$，索引为 $-1$ 和 $-1$。\n\n从基本定义开始：连续子数组、算术求和，以及将大小为 $n$ 的问题简化为大小小于 $n$ 的子问题外加一个线性时间合并步骤的分治原则。不要使用快捷公式。通过推理来设计算法，即 $A[i..j]$ 上的最大子数组必须完全位于左半部分、完全位于右半部分或跨越中点。推导出如何通过构造左半部分的最大后缀和右半部分的最大前缀并将它们组合来计算跨中点的情况。\n\n您的程序必须实现这种分治方法，为每个测试用例返回一个三元组 $[S,i,j]$，其中 $S$ 是最大和，$i$ 和 $j$ 是在所述平局打破规则下所选子串的从 $0$ 开始的起始和结束索引。\n\n测试套件：\n- 情况 $1$（一般情况）：字符串 \"abcxyz\"。\n- 情况 $2$（边界情况：空）：空字符串 \"\"。\n- 情况 $3$（单元素）：字符串 \"z\"。\n- 情况 $4$（同质）：字符串 \"aaaaa\"。\n- 情况 $5$（另一个一般情况）：字符串 \"lmnoa\"。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，每个结果本身的格式为 $[S,i,j]$ 并且没有空格。例如，对于上述五个情况，输出应与 \"[[S1,i1,j1],[S2,i2,j2],[S3,i3,j3],[S4,i4,j4],[S5,i5,j5]]\" 完全一样。",
            "solution": "**问题验证**\n\n所提供的问题是算法领域中一个定义明确的计算任务。它要求实现一种特定范式（分治法）来解决最大子数组和问题，并辅以字符到整数的映射和清晰的分级平局打破规则。\n\n1.  **提取的已知条件**：\n    *   **输入**：一个由小写英文字母组成的有限字符串。\n    *   **映射**：$a \\mapsto 1, b \\mapsto 2, \\ldots, z \\mapsto 26$。\n    *   **数组**：一个从字符串派生的整数权重数组 $A$。\n    *   **目标**：找到具有最大和 $S(i,j) = \\sum_{t=i}^{j} A[t]$ 的连续子数组 $A[i..j]$。\n    *   **算法**：必须使用分治法（DC）。\n    *   **平局打破**：如果和相等，选择起始索引 $i$ 最小的那个。如果仍然平局，选择结束索引 $j$ 最小的那个。\n    *   **索引**：从 $0$ 开始。\n    *   **边界情况**：对于空字符串，结果为和 $0$，索引为 $-1, -1$。\n    *   **输出**：一个三元组 $[S, i, j]$。\n\n2.  **验证结论**：\n    *   **科学依据**：该问题基于已建立的计算机科学和数学原理。该映射是一个简单的双射函数。\n    *   **良态问题**：该问题是无歧义的。输入、转换、目标函数（最大化）、约束（DC）以及平局打破规则都已明确指定，保证了唯一解。\n    *   **客观性**：该问题以形式化、客观的语言陈述。\n\n该问题是**有效的**。它是一个标准的算法练习，带有特定约束，用于测试对分治范式的理解以及对平局打破规则的仔细实现。\n\n**解法推导**\n\n该问题要求一种算法，用于在从字符串派生的给定数字数组 $A$ 中找到具有最大和的连续子数组。该算法必须遵循分治（DC）范式。\n\n设输入数组为大小为 $N$ 的 $A$。让我们的函数在一个由索引 `low` 和 `high` 定义的子数组上操作，记为 $A[low..high]$。\n\n**1. 基本原则：分治法**\n\n分治策略包括三个步骤：\n*   **分解**：将问题实例分解为两个或多个同类型的、更小的、独立的子问题。\n*   **解决**：递归地解决子问题。如果子问题的大小足够小，则直接解决它们（基本情况）。\n*   **合并**：将子问题的解合并成原始问题的解。\n\n对于 $A[low..high]$ 上的最大子数组问题，我们在中点 $mid = \\lfloor(low + high) / 2\\rfloor$ 处将数组分成两半。因此，最大子数组可以位于以下三个位置之一：\n1.  完全在左子数组 $A[low..mid]$ 中。\n2.  完全在右子数组 $A[mid+1..high]$ 中。\n3.  跨越中点，即一个子数组 $A[i..j]$，使得 $low \\le i \\le mid  j \\le high$。\n\n**2. 递归结构和基本情况**\n\n分治方法导致一个递归函数。\n\n*   **递归步骤**：我们通过两次递归调用来求解左半部分和右半部分的最大子数组。然后，我们计算跨越中点的最大子数组。最后，我们比较这三种情况的结果，以找到总体最大值，同时遵守平局打破规则。\n\n*   **基本情况**：当子数组只包含一个元素时，即当 $low = high$ 时，递归终止。对于这样的子数组 $A[i..i]$，最大子数组就是它本身。和为 $A[i]$，起始索引为 $i$，结束索引为 $i$。结果是 $[A[i], i, i]$。\n\n**3. 跨中点子数组的计算**\n\n这是“合并”步骤的核心。一个跨越中点 $mid$ 的子数组 $A[i..j]$ 是由左半部分的后缀 $A[i..mid]$ 和右半部分的前缀 $A[mid+1..j]$ 拼接而成的。\n其和为 $S(i,j) = (\\sum_{k=i}^{mid} A[k]) + (\\sum_{k=mid+1}^{j} A[k])$。\n\n为了最大化这个和，我们必须独立地最大化左后缀的和与右前缀的和。\n\n*   **左半部分的最大后缀**：我们需要在 $[low, mid]$ 中找到一个索引 $i$ 来最大化 $\\sum_{k=i}^{mid} A[k]$。我们可以通过从 $k = mid$ 向下迭代到 $low$ 来计算。我们维护一个运行总和，并跟踪到目前为止所见的最大和以及产生它的索引 $i$。\n    设 $S_{left\\_cross}$ 为最大后缀和，$i_{cross}$ 为其起始索引。我们将 $S_{left\\_cross}$ 初始化为一个比任何可能的和都小的值（例如，$-\\infty$），并维护一个 `current_sum`。\n    `current_sum = 0`\n    `max_left_sum = -∞`\n    `start_index = -1`\n    对于从 $mid$ 向下到 $low$ 的 $k$：\n        `current_sum = current_sum + A[k]`\n        如果 `current_sum >= max_left_sum`：\n            `max_left_sum = current_sum`\n            `start_index = k`\n    平局打破规则要求最小的起始索引 $i$。通过在 `current_sum >= max_left_sum` 时更新索引 `k`，我们确保对于给定的最大和，我们选择索引最小的那个（因为我们是从 `mid` 向下迭代到 `low`）。\n\n*   **右半部分的最大前缀**：类似地，我们需要在 $[mid+1, high]$ 中找到一个索引 $j$ 来最大化 $\\sum_{k=mid+1}^{j} A[k]$。我们从 $k = mid+1$ 向上迭代到 $high$。\n    设 $S_{right\\_cross}$ 为最大前缀和，$j_{cross}$ 为其结束索引。\n    `current_sum = 0`\n    `max_right_sum = -∞`\n    `end_index = -1`\n    对于从 $mid+1$ 向上到 $high$ 的 $k$：\n        `current_sum = current_sum + A[k]`\n        如果 `current_sum > max_right_sum`：\n            `max_right_sum = current_sum`\n            `end_index = k`\n    平局打破规则，在起始索引进一步平局的情况下，要求最小的结束索引 $j$。通过仅在 `current_sum > max_right_sum` 时更新索引 `k`，我们确保对于给定的最大和，我们保留第一个（因此是最小的）达到该和的索引 `k`。\n\n最大跨中点子数组的和为 $S_{cross} = S_{left\\_cross} + S_{right\\_cross}$，范围从 $i_{cross}$ 到 $j_{cross}$。\n\n**4. 合并与平局打破**\n\n设来自三种情况的结果为：\n*   左侧：$[S_{L}, i_{L}, j_{L}]$\n*   右侧：$[S_{R}, i_{R}, j_{R}]$\n*   跨中点：$[S_{C}, i_{C}, j_{C}]$\n\n我们必须从这三个结果中选择“最佳”的一个。如果满足以下条件，则结果 $[S_1, i_1, j_1]$ 优于 $[S_2, i_2, j_2]$：\n*   $S_1 > S_2$，或\n*   $S_1 = S_2$ 且 $i_1  i_2$，或\n*   $S_1 = S_2$ 且 $i_1 = i_2$ 且 $j_1  j_2$。\n\n必须依次应用此比较。首先，比较左侧和右侧的结果以找到一个中间最优解。然后，将此中间最优解与跨中点的结果进行比较，以确定当前递归调用的最终获胜者。\n\n**5. 初始调用和边界情况**\n\n主函数将首先处理空输入字符串的特殊情况，按规定返回 $[0, -1, -1]$。否则，它会将输入字符串转换为整数数组 $A$。然后通过在整个数组上调用递归函数来启动分治过程：`find_max_subarray(A, 0, N-1)`。\n\n字符到整数的映射为 $f(c) = \\text{ord}(c) - \\text{ord}('a') + 1$。由于所有字符都是小写英文字母，因此 $A$ 中的所有权重都将是 $1$ 到 $26$ 之间的正整数。这意味着对于非空字符串，最大子数组和将始终为正。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n\n    def get_weight(char):\n        \"\"\"Maps a character to its integer weight.\"\"\"\n        return ord(char) - ord('a') + 1\n\n    def is_better(res1, res2):\n        \"\"\"\n        Determines if result 1 is better than result 2 based on the tie-breaking rules.\n        A result is a list [Sum, start_index, end_index].\n        \"\"\"\n        s1, i1, j1 = res1\n        s2, i2, j2 = res2\n\n        if s1 > s2:\n            return True\n        if s1  s2:\n            return False\n        \n        # Sums are equal, check start index\n        if i1  i2:\n            return True\n        if i1 > i2:\n            return False\n            \n        # Sums and start indices are equal, check end index\n        if j1  j2:\n            return True\n        \n        return False\n\n    def find_max_crossing_subarray(arr, low, mid, high):\n        \"\"\"\n        Finds the maximum subarray that crosses the midpoint.\n        This is the 'combine' step of the Divide and Conquer algorithm.\n        \"\"\"\n        # Find maximum suffix sum in the left part (A[i..mid])\n        # We use '>=' to find the smallest start index 'i' in case of a tie in sum,\n        # as we iterate from mid down to low.\n        left_sum = -math.inf\n        current_sum = 0\n        cross_i = -1\n        for i in range(mid, low - 1, -1):\n            current_sum += arr[i]\n            if current_sum >= left_sum:\n                left_sum = current_sum\n                cross_i = i\n\n        # Find maximum prefix sum in the right part (A[mid+1..j])\n        # We use '>' to find the smallest end index 'j' in case of a tie in sum,\n        # as we iterate from mid+1 up to high.\n        right_sum = -math.inf\n        current_sum = 0\n        cross_j = -1\n        for j in range(mid + 1, high + 1):\n            current_sum += arr[j]\n            if current_sum > right_sum:\n                right_sum = current_sum\n                cross_j = j\n        \n        return [left_sum + right_sum, cross_i, cross_j]\n\n\n    def find_max_subarray_recursive(arr, low, high):\n        \"\"\"\n        Recursively finds the maximum subarray sum using Divide and Conquer.\n        Handles tie-breaking as specified.\n        \"\"\"\n        # Base case: only one element\n        if low == high:\n            return [arr[low], low, high]\n\n        # Recursive step\n        mid = (low + high) // 2\n\n        # 1. Maximum subarray is in the left half\n        left_res = find_max_subarray_recursive(arr, low, mid)\n\n        # 2. Maximum subarray is in the right half\n        right_res = find_max_subarray_recursive(arr, mid + 1, high)\n\n        # 3. Maximum subarray crosses the midpoint\n        cross_res = find_max_crossing_subarray(arr, low, mid, high)\n\n        # Compare the three results and return the best one\n        best_res = left_res\n        if is_better(right_res, best_res):\n            best_res = right_res\n        if is_better(cross_res, best_res):\n            best_res = cross_res\n            \n        return best_res\n\n    def find_max_subarray(s: str):\n        \"\"\"\n        Wrapper function to handle input string, including the empty string case.\n        \"\"\"\n        # Handle the empty string case as per the problem description\n        if not s:\n            return [0, -1, -1]\n\n        # Convert string to array of integer weights\n        arr = [get_weight(char) for char in s]\n        \n        return find_max_subarray_recursive(np.array(arr), 0, len(arr) - 1)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        \"abcxyz\",  # Case 1\n        \"\",        # Case 2\n        \"z\",       # Case 3\n        \"aaaaa\",   # Case 4\n        \"lmnoa\",   # Case 5\n    ]\n\n    results = []\n    for case in test_cases:\n        result = find_max_subarray(case)\n        # Ensure integer types for S, i, j in the final output.\n        result = [int(r) for r in result]\n        results.append(f\"[{result[0]},{result[1]},{result[2]}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "这个问题通过将数组扩展成环形，提升了挑战的难度。它教会我们一种强大的解题技巧：将一个新问题规约为一个已知如何解决的问题。其解决方案巧妙地结合了标准线性最大子数组算法的结果及其对偶问题——最小子数组和，展示了核心概念的通用性。",
            "id": "3250540",
            "problem": "给定一个长度为 $n$（$n \\geq 1$）的有限整数序列 $A = \\langle a_0, a_1, \\dots, a_{n-1} \\rangle$，在线性数组上，非空连续子数组定义为满足 $0 \\leq i \\leq j \\leq n-1$ 的整数 $i$ 和 $j$ 的任意序列 $\\langle a_i, a_{i+1}, \\dots, a_j \\rangle$。对于循环数组，索引算术在模 $n$ 下进行，因此非空连续子数组可以环绕边界，其形式为任意满足 $0 \\leq k \\leq n-1$ 和 $0 \\leq \\ell \\leq n-1$ 的整数 $k$ 和 $\\ell$ 的序列 $\\langle a_k, a_{k+1}, \\dots, a_{n-1}, a_0, a_1, \\dots, a_\\ell \\rangle$，且该序列至少包含一个元素。子数组的和是其元素的常规整数加法。循环数组中的最大子数组和是在循环索引下所有非空连续子数组中可能的最大和。\n\n仅从上述基本定义和分治法（Divide and Conquer, D and C）的一般设计原则出发——该原则将问题分解为不相交部分的子问题，独立解决它们，然后合并其解以获得原始问题的解——实现一个程序，为下面提供的每个测试用例计算循环数组中的最大子数组和。您的实现必须采用真正的分治策略来计算必要的量；不要使用贪心扫描或动态规划。\n\n用于评估您程序的测试套件：\n- 案例 $1$：$[5, -3, 5]$\n- 案例 $2$：$[-5, -1, -8]$\n- 案例 $3$：$[7]$\n- 案例 $4$：$[-7]$\n- 案例 $5$：$[2, 2, 2]$\n- 案例 $6$：$[0, -2, 0, -3]$\n- 案例 $7$：$[10, -12, 11, -1, 12]$\n- 案例 $8$：$[-2, 1]$\n\n对于每个案例，所需的输出是循环解释下的最大子数组和，表示为一个整数。\n\n最终输出格式规范：\n您的程序应生成单行输出，其中包含一个逗号分隔的结果列表，并用方括号括起来（例如，$[\\text{result}_1,\\text{result}_2,\\dots]$）。结果必须按案例 $1$ 到 $8$ 的顺序对应。不涉及单位，也不应打印任何附加文本。",
            "solution": "此题要求解决“最大循环子数组和”问题。\n这是一个有效的问题。它是在算法和数据结构领域内，基于标准数学定义的一个明确的计算问题。它自成体系、客观，并且其解是可验证的。使用分治（D and C）策略的约束使其成为算法设计中的一个非平凡练习，而不仅仅是已知贪心算法的简单应用。\n\n寻找循环数组中最大子数组和的问题可以分解为两种不同的情况。设输入数组为 $A = \\langle a_0, a_1, \\dots, a_{n-1} \\rangle$。在这种循环排列中，一个非空连续子数组要么是：\n$1$. 一个不环绕数组两端的标准线性子数组。\n$2$. 一个确实环绕的子数组，由数组的后缀和前缀组成，例如 $\\langle a_k, \\dots, a_{n-1}, a_0, \\dots, a_{\\ell} \\rangle$。\n\n因此，最大循环子数组和是在这两种情况下找到的和的最大值。\n\n**情况1：最大线性子数组和**\n\n这是标准的最大子数组问题。根据问题的约束，我们必须使用分治策略来解决它。对此问题的线性分治方法包括对数组段 $A[\\text{low} \\dots \\text{high}]$ 的以下步骤：\n- **分解**：在中间点 $m = \\lfloor (\\text{low} + \\text{high}) / 2 \\rfloor$ 将数组分成两半。两个子问题分别是 $A[\\text{low} \\dots m]$ 和 $A[m+1 \\dots \\text{high}]$。\n- **解决**：递归地解决这两个半区。\n- **合并**：$A[\\text{low} \\dots \\text{high}]$ 中的最大子数组可以位于以下三个位置之一：\n    a) 完全在左半部分 $A[\\text{low} \\dots m]$ 内。\n    b) 完全在右半部分 $A[m+1 \\dots \\text{high}]$ 内。\n    c) 跨越中点 $m$。一个跨越中点的子数组是左半部分最大可能后缀和与右半部分最大可能前缀和之和。\n\n为了有效地实现合并步骤，我们的递归函数不仅要返回给定段的最大子数组和，还必须返回更丰富的信息集。具体来说，对于任何数组段，我们将计算一个包含四个值的元组：\n$1$. $S_{\\text{total}}$：该段中所有元素的总和。\n$2$. $S_{\\text{max\\_sub}}$：该段内的最大子数组和。\n$3$. $S_{\\text{max\\_prefix}}$：该段的任意非空前缀的最大和。\n$4$. $S_{\\text{max\\_suffix}}$：该段的任意非空后缀的最大和。\n\n递归的基准情况是单元素数组 $\\langle x \\rangle$，此时所有四个值都就是 $x$。\n在合并步骤中，给定左半部分（$L$）和右半部分（$R$）的结果：\n- $S_{\\text{total}} = L.S_{\\text{total}} + R.S_{\\text{total}}$\n- $S_{\\text{max\\_prefix}} = \\max(L.S_{\\text{max\\_prefix}}, L.S_{\\text{total}} + R.S_{\\text{max\\_prefix}})$\n- $S_{\\text{max\\_suffix}} = \\max(R.S_{\\text{max\\_suffix}}, R.S_{\\text{total}} + L.S_{\\text{max\\_suffix}})$\n- $S_{\\text{max\\_sub}} = \\max(L.S_{\\text{max\\_sub}}, R.S_{\\text{max\\_sub}}, L.S_{\\text{max\\_suffix}} + R.S_{\\text{max\\_prefix}})$\n\n情况1的解，我们记为 $S_{\\text{max\\_linear}}$，是此分治过程对整个数组 $A$ 返回的 $S_{\\text{max\\_sub}}$ 值。\n\n**情况2：最大环绕子数组和**\n\n一个环绕子数组等价于从整个数组中“移除”一个不环绕（线性）的子数组。要最大化环绕部分的和，必须移除一个具有*最小*可能和的线性子数组。\n设 $S_{\\text{total}}$ 是 $A$ 中所有元素的总和。环绕子数组的和是 $S_{\\text{total}} - S_{\\text{removed}}$，其中 $S_{\\text{removed}}$ 是被排除的非空线性子数组的和。\n最大化此表达式等价于最小化 $S_{\\text{removed}}$。\n因此，最大环绕子数组和是 $S_{\\text{max\\_wrap}} = S_{\\text{total}} - S_{\\text{min\\_linear}}$，其中 $S_{\\text{min\\_linear}}$ 是最小线性子数组和。\n\n最小线性子数组和可以用相同的分治机制找到。注意这个恒等式：$\\min(X) = -\\max(-X)$。我们可以通过将 $A$ 的所有元素取反形成一个新数组 $A'$，找到 $A'$ 的最大线性子数组和，然后将结果取反来找到 $S_{\\text{min\\_linear}}$。\n$S_{\\text{min\\_linear}}(A) = -S_{\\text{max\\_linear}}(-A)$。\n\n**结合情况并处理边界情况**\n\n最终答案是 $\\max(S_{\\text{max\\_linear}}, S_{\\text{max\\_wrap}})$。然而，存在一个关键的边界情况。环绕和的逻辑，$S_{\\text{total}} - S_{\\text{min\\_linear}}$，假设被“移除”的子数组是 $A$ 的一个*真*子数组。如果最小线性子数组就是整个数组本身，“移除”它将留下一个空集，根据问题定义，这不是一个有效的非空子数组。\n\n这种情况当且仅当 $S_{\\text{min\\_linear}} = S_{\\text{total}}$ 时发生。例如，当数组的所有元素都是非正数时就会发生这种情况。在这种情况下，任何环绕子数组的和都将小于或等于一个不环绕的子数组和，因此环绕情况不是最大值的有效候选者。答案必须是最大线性子数组和 $S_{\\text{max\\_linear}}$。\n\n因此，最终的算法是：\n$1$. 对于长度为 $n$ 的数组 $A$：如果 $n = 1$，答案是 $a_0$。\n$2$. 使用分治过程计算数组 $A$ 的 $S_{\\text{total}}$ 和 $S_{\\text{max\\_linear}}$。\n$3$. 对取反后的数组 $-A$ 使用分治过程找到 $S'_{\\text{max\\_linear}}$，并计算 $S_{\\text{min\\_linear}} = -S'_{\\text{max\\_linear}}$。\n$4$. 如果 $S_{\\text{min\\_linear}} = S_{\\text{total}}$，则答案是 $S_{\\text{max\\_linear}}$。\n$5$. 否则，答案是 $\\max(S_{\\text{max\\_linear}}, S_{\\text{total}} - S_{\\text{min\\_linear}})$。\n这种方法正确地计算了最大循环子数组和，同时严格遵守了分治范式。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Validates and solves the maximum circular subarray sum problem\n    for a suite of test cases using a Divide and Conquer strategy.\n    \"\"\"\n\n    test_cases = [\n        [5, -3, 5],\n        [-5, -1, -8],\n        [7],\n        [-7],\n        [2, 2, 2],\n        [0, -2, 0, -3],\n        [10, -12, 11, -1, 12],\n        [-2, 1],\n    ]\n\n    results = []\n    for case in test_cases:\n        result = find_max_circular_subarray_sum(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef _dnc_linear_solver(arr: np.ndarray) -> tuple[int, int, int, int]:\n    \"\"\"\n    Computes linear subarray properties using Divide and Conquer.\n\n    Args:\n        arr: A numpy array of integers.\n\n    Returns:\n        A tuple containing:\n        (total_sum, max_subarray_sum, max_prefix_sum, max_suffix_sum)\n    \"\"\"\n    n = arr.shape[0]\n    if n == 1:\n        val = arr[0]\n        return (val, val, val, val)\n\n    mid = n // 2\n    left_arr, right_arr = arr[:mid], arr[mid:]\n\n    left_total, left_max_sub, left_max_pre, left_max_suf = _dnc_linear_solver(left_arr)\n    right_total, right_max_sub, right_max_pre, right_max_suf = _dnc_linear_solver(right_arr)\n\n    # Combine results\n    total_sum = left_total + right_total\n    \n    # Max prefix of combined array is either max prefix of left, or all of left + max prefix of right.\n    max_prefix_sum = max(left_max_pre, left_total + right_max_pre)\n    \n    # Max suffix of combined array is either max suffix of right, or all of right + max suffix of left.\n    max_suffix_sum = max(right_max_suf, right_total + left_max_suf)\n    \n    # Max subarray is in left, in right, or crosses the middle.\n    crossing_sum = left_max_suf + right_max_pre\n    max_subarray_sum = max(left_max_sub, right_max_sub, crossing_sum)\n\n    return (total_sum, max_subarray_sum, max_prefix_sum, max_suffix_sum)\n\ndef find_max_circular_subarray_sum(arr: list[int]) -> int:\n    \"\"\"\n    Calculates the maximum circular subarray sum for a given array.\n\n    Args:\n        arr: A list of integers, with length n >= 1.\n\n    Returns:\n        The maximum circular subarray sum.\n    \"\"\"\n    n = len(arr)\n    # The problem statement guarantees n >= 1. The D base case handles n = 1.\n    \n    arr_np = np.array(arr, dtype=np.int64)\n\n    # Case 1: Find the maximum subarray sum in the linear (non-wrapping) array.\n    total_sum, max_linear_sum, _, _ = _dnc_linear_solver(arr_np)\n\n    # Case 2: Find the maximum wrapping subarray sum.\n    # This is total_sum - min_linear_subarray_sum.\n    # We find min_linear_subarray_sum by finding the max subarray sum of the negated array.\n    # min_sum(A) = -max_sum(-A)\n    neg_arr_np = -arr_np\n    _, max_sum_of_neg_arr, _, _ = _dnc_linear_solver(neg_arr_np)\n    min_linear_sum = -max_sum_of_neg_arr\n\n    # Edge Case: If the minimum linear subarray is the entire array itself\n    # (which happens when all numbers are non-positive), total_sum == min_linear_sum.\n    # In this case, the wrapping sum corresponds to removing the whole array, leaving an\n    # empty set, which is invalid. So, the answer must be the non-wrapping max sum.\n    # This check correctly handles the all-non-positive (and single element) cases.\n    if total_sum == min_linear_sum and n > 0:\n        return max_linear_sum\n    else:\n        max_wrapping_sum = total_sum - min_linear_sum\n        return max(max_linear_sum, max_wrapping_sum)\n\nsolve()\n```"
        },
        {
            "introduction": "这个高级练习引入了一种新的约束：寻找不大于目标值 $T$ 的最大子数组和。这个变种要求在分治算法中使用一个更为复杂的“合并”步骤。它挑战学生在分治框架内融合排序和二分搜索等其他技术，以高效地找到最优的跨中点子数组，从而展示了如何调整分治法来解决更复杂的约束优化问题。",
            "id": "3250524",
            "problem": "给定一个整数数组 $A = [a_0,a_1,\\dots,a_{n-1}]$ 和一个整数目标值 $T$。对于索引 $0 \\leq i \\leq j  n$，连续子数组是任意连续元素的序列 $[a_i,a_{i+1},\\dots,a_j]$。定义子数组 $[a_i,\\dots,a_j]$ 的和为 $S(i,j) = \\sum_{k=i}^{j} a_k$。任务是为每个测试用例计算值\n$$M(T; A) = \\max\\{S(i,j) \\mid 0 \\leq i \\leq j  n, \\ S(i,j) \\leq T\\},$$\n即，小于或等于 $T$ 的最大子数组和。如果该集合为空（没有子数组和小于或等于 $T$），则定义 $M(T; A) = -\\infty$ (负无穷大)，程序应将其作为浮点数负无穷大返回。\n\n您的程序必须使用基于原则的分治 (DC) 方法：将数组递归地划分为两半的子问题，并仅使用可从这两半计算出的信息来组合它们的结果。程序不应接受任何输入，并且必须计算硬编码在程序中的以下测试套件的结果：\n\n- 测试用例 1：$A = [3,-2,5,-1]$, $T = 6$。\n- 测试用例 2：$A = [-4,-2,-7]$, $T = -3$。\n- 测试用例 3：$A = [5,6]$, $T = -1$。\n- 测试用例 4：$A = [2,-1,2,3,-9,5]$, $T = 100$。\n- 测试用例 5：$A = [7]$, $T = 7$。\n- 测试用例 6：$A = [4,-1,2,1]$, $T = 5$。\n\n所有值都是整数，和的计算使用整数算术。最终输出格式必须是单行文本，包含六个测试用例的结果列表，按顺序排列，用逗号分隔并用方括号括起来，例如 $[x_1,x_2,\\dots,x_6]$，其中每个 $x_i$ 是一个整数或负无穷大 $-\\infty$ 的浮点表示。\n\n此问题不涉及物理单位或角度。输出值为纯数字，如果出现 $-\\infty$，则必须打印为编程语言生成的浮点负无穷大标记（例如，在 Python 中 $-\\infty$ 打印为 $-inf$）。",
            "solution": "问题陈述已经过分析，并被认为是有效的。这是一个在算法领域内定义明确、自成体系且可形式化的问题，特别涉及分治法。其中没有科学或事实上的矛盾、歧义或缺失信息。因此，我们可以着手解决。\n\n该问题要求计算连续子数组的最大和，约束条件是该和不得超过给定的目标值 $T$。如果没有子数组和满足此条件，则结果应为 $-\\infty$。这是经典最大子数组问题的变体，解决方案必须采用分治策略。\n\n设给定数组为 $A$，长度为 $n$。分治算法的运作方式是，将一个问题递归地分解为两个或多个相同或相关类型的子问题，直到这些子问题变得足够简单可以直接解决。然后，将子问题的解合并起来，从而得到原问题的解。\n\n对于定义在索引 $[l, h]$ 上的数组 $A$，我们可以在中点 $m = \\lfloor(l+h)/2\\rfloor$ 将其分为两半。左子数组为 $A[l \\dots m]$，右子数组为 $A[m+1 \\dots h]$。$A[l \\dots h]$ 的任何连续子数组可以位于以下三个位置之一：\n1. 完全位于左子数组 $A[l \\dots m]$ 内。\n2. 完全位于右子数组 $A[m+1 \\dots h]$ 内。\n3. 跨越中点，即子数组 $A[i \\dots j]$，其中 $l \\le i \\le m  j \\le h$。\n\n分治策略的核心如下：\n\n**分解(Divide)：** 将数组 $A[l \\dots h]$ 分割成 $A[l \\dots m]$ 和 $A[m+1 \\dots h]$。\n\n**解决(Conquer)：** 递归地为左子数组和右子数组找到小于或等于 $T$ 的最大子数组和。设它们分别为 $M_{left}$ 和 $M_{right}$。\n\n**合并(Combine)：** $A[l \\dots h]$ 的最终解将是三个值的最大值：$M_{left}$、$M_{right}$ 和 $M_{cross}$，其中 $M_{cross}$ 是小于或等于 $T$ 的跨中点子数组的最大和。\n$$M(T; A[l \\dots h]) = \\max(M_{left}, M_{right}, M_{cross})$$\n\n递归的基准情形是单元素子数组 $A[i \\dots i]$。如果 $a_i \\le T$，则最大和就是 $a_i$，否则为 $-\\infty$。\n\n主要挑战在于高效地计算 $M_{cross}$。一个跨中点的子数组 $A[i \\dots j]$（其中 $i \\le m  j$）其和可以表示为两部分之和：左子数组的后缀和与右子数组的前缀和。\n$$ S(i,j) = \\sum_{k=i}^{j} a_k = \\left(\\sum_{k=i}^{m} a_k\\right) + \\left(\\sum_{k=m+1}^{j} a_k\\right) $$\n设 $\\mathcal{L}$ 为左子数组所有后缀和的集合，即 $\\mathcal{L} = \\{ \\sum_{k=i}^{m} a_k \\mid l \\le i \\le m \\}$。\n设 $\\mathcal{R}$ 为右子数组所有前缀和的集合，即 $\\mathcal{R} = \\{ \\sum_{k=m+1}^{j} a_k \\mid m+1 \\le j \\le h \\}$。\n\n我们需要计算 $M_{cross} = \\max \\{ l_{sum} + r_{sum} \\mid l_{sum} \\in \\mathcal{L}, r_{sum} \\in \\mathcal{R}, \\text{ 且 } l_{sum} + r_{sum} \\le T \\}$。对所有 $(l_{sum}, r_{sum})$ 对进行朴素检查会太慢，导致合并步骤的时间复杂度为 $O(n^2)$，总复杂度为 $O(n^2 \\log n)$。\n\n可以设计一种更高效的合并步骤方法。对于每个 $l_{sum} \\in \\mathcal{L}$，我们需要找到 $\\mathcal{R}$ 中满足 $r_{sum} \\le T - l_{sum}$ 的最大 $r_{sum}$。如果集合 $\\mathcal{R}$ 是排序的，这个搜索可以高效地执行。\n\n合并步骤的算法如下：\n1. 通过从索引 $m$ 向下迭代到 $l$ 来计算 $\\mathcal{L}$ 中的所有和。这需要 $O(m-l+1)$ 的时间，对于大小为 $n$ 的子数组来说是 $O(n)$。\n2. 通过从索引 $m+1$ 向上迭代到 $h$ 来计算 $\\mathcal{R}$ 中的所有和。这也需要 $O(n)$ 的时间。\n3. 将和数组 $\\mathcal{R}$ 按升序排序。这需要 $O(n \\log n)$ 的时间。\n4. 初始化 $M_{cross} = -\\infty$。\n5. 对于 $\\mathcal{L}$ 中的每个 $l_{sum}$：\n    a. 在排序后的 $\\mathcal{R}$ 上使用二分搜索，找到满足 $r_{sum} \\le T - l_{sum}$ 的最大元素 $r_{sum}$。\n    b. 如果存在这样的 $r_{sum}$，我们就有一个最大跨中点和的候选值：$l_{sum} + r_{sum}$。更新 $M_{cross} = \\max(M_{cross}, l_{sum} + r_{sum})$。\n这个循环在 $\\mathcal{R}$ 上进行了 $| \\mathcal{L} |$ 次二分搜索，总共需要 $O(n \\log n)$ 的时间。\n\n因此，合并步骤的复杂度主要由排序和搜索决定，为 $O(n \\log n)$。总时间复杂度的递推关系为 $T(n) = 2T(n/2) + O(n \\log n)$。根据主定理 (Master Theorem)，这得出的总时间复杂度为 $T(n) = O(n (\\log n)^2)$。此方法遵循了问题所要求的分治原则。\n\n使用 $float('-inf')$ 作为最大值操作的单位元，可确保在没有子数组和满足条件 $S(i,j) \\le T$ 的情况下，函数能正确返回 $-\\infty$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport bisect\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the problem for a hard-coded suite of test cases.\n    \"\"\"\n    test_cases = [\n        {'A': [3, -2, 5, -1], 'T': 6},\n        {'A': [-4, -2, -7], 'T': -3},\n        {'A': [5, 6], 'T': -1},\n        {'A': [2, -1, 2, 3, -9, 5], 'T': 100},\n        {'A': [7], 'T': 7},\n        {'A': [4, -1, 2, 1], 'T': 5},\n    ]\n\n    results = []\n    for case in test_cases:\n        arr = case['A']\n        target = case['T']\n        result = find_max_subarray_sum_le_T(arr, target)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef find_max_subarray_sum_le_T(arr, target):\n    \"\"\"\n    Main function to find the maximum subarray sum less than or equal to target T.\n    It initiates the divide-and-conquer recursive solver.\n    \"\"\"\n    if not arr:\n        return float('-inf')\n    return _dnc_solver(arr, target, 0, len(arr) - 1)\n\ndef _dnc_solver(arr, target, low, high):\n    \"\"\"\n    Recursive helper function that implements the divide-and-conquer logic.\n    \"\"\"\n    # Base case: if the subarray has one element.\n    if low == high:\n        return arr[low] if arr[low] = target else float('-inf')\n\n    # Divide: Find the midpoint.\n    mid = (low + high) // 2\n\n    # Conquer: Recursively solve for left and right subarrays.\n    max_left = _dnc_solver(arr, target, low, mid)\n    max_right = _dnc_solver(arr, target, mid + 1, high)\n\n    # Combine: Find the maximum sum of a subarray crossing the midpoint.\n    \n    # 1. Compute all suffix sums of the left part (ending at mid).\n    left_sums = []\n    current_sum = 0\n    for i in range(mid, low - 1, -1):\n        current_sum += arr[i]\n        left_sums.append(current_sum)\n\n    # 2. Compute all prefix sums of the right part (starting at mid+1).\n    right_sums = []\n    current_sum = 0\n    for i in range(mid + 1, high + 1):\n        current_sum += arr[i]\n        right_sums.append(current_sum)\n\n    # 3. Sort the right_sums to enable efficient searching.\n    right_sums.sort()\n    \n    max_cross = float('-inf')\n\n    # 4. For each left_sum, find the best matching right_sum.\n    for l_sum in left_sums:\n        # We need to find the largest r_sum in right_sums such that:\n        # r_sum = target - l_sum\n        required_r_sum = target - l_sum\n        \n        # bisect_right finds an insertion point. The element at index-1\n        # is the largest element = required_r_sum.\n        idx = bisect.bisect_right(right_sums, required_r_sum)\n        \n        if idx > 0:\n            # An element = required_r_sum exists.\n            r_sum = right_sums[idx - 1]\n            max_cross = max(max_cross, l_sum + r_sum)\n            \n    # The final result for this level is the max of the three parts.\n    return max(max_left, max_right, max_cross)\n\nsolve()\n```"
        }
    ]
}