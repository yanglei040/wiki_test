{
    "hands_on_practices": [
        {
            "introduction": "我们通常使用动态规划来寻找计算矩阵链乘积的最小标量乘法次数。这个练习将问题反转过来：假设我们已经知道了最优的计算顺序（即括号的划分方式）和最小成本，我们能否反推出关于原始矩阵维度的信息？通过这个练习，你将通过逻辑推理和代数运算来巩固对成本计算公式和最优性条件的理解，这是一个不依赖编程、纯粹考验思维能力的挑战 。",
            "id": "3249096",
            "problem": "给定一个由三个矩阵 $A_1$、$A_2$ 和 $A_3$ 组成的链，其维度兼容，$A_1 \\in \\mathbb{R}^{d_0 \\times d_1}$、$A_2 \\in \\mathbb{R}^{d_1 \\times d_2}$ 和 $A_3 \\in \\mathbb{R}^{d_2 \\times d_3}$，其中 $d_0$、$d_1$、$d_2$ 和 $d_3$ 是未知的正整数。假设已知（例如，通过完整的动态规划计算）该链的最优加括号方式是 $(A_1A_2)A_3$，并且此次最优计算所需标量乘法的确切最小数量为 $C^{\\ast} = 204$。此外，还告知您，单独计算子乘积 $A_1A_2$ 和 $A_2A_3$ 分别需要 $120$ 次和 $210$ 次标量乘法。\n\n仅从矩阵乘法的标准定义及其标量运算计数出发，推导出在 $(A_1A_2)A_3$ 为最优加括号方式的情况下，维度 $d_0$、$d_1$、$d_2$ 和 $d_3$ 必须满足的等式和不等式。然后，计算比值 $d_1/d_0$ 的值。将最终答案表示为最简分数。无需四舍五入，不涉及单位。",
            "solution": "该问题要求基于一个矩阵链乘法问题的成本信息，确定两个矩阵维度之比 $d_1/d_0$。\n\n首先，我们使用矩阵乘法成本的标准定义来形式化给定的信息。一个维度为 $p \\times q$ 的矩阵与一个维度为 $q \\times r$ 的矩阵相乘，需要 $p \\cdot q \\cdot r$ 次标量乘法。\n\n链中的矩阵为 $A_1 \\in \\mathbb{R}^{d_0 \\times d_1}$、$A_2 \\in \\mathbb{R}^{d_1 \\times d_2}$ 和 $A_3 \\in \\mathbb{R}^{d_2 \\times d_3}$，其中 $d_0, d_1, d_2, d_3$ 是正整数。\n\n给定我们单独计算两个子乘积的成本：\n1.  计算 $A_1A_2$ 的成本是 $120$。其维度为 $d_0 \\times d_1$ 和 $d_1 \\times d_2$。因此，标量乘法的次数由维度之积给出：\n    $$d_0 d_1 d_2 = 120$$\n2.  计算 $A_2A_3$ 的成本是 $210$。其维度为 $d_1 \\times d_2$ 和 $d_2 \\times d_3$。相关成本为：\n    $$d_1 d_2 d_3 = 210$$\n\n对于一个由三个矩阵组成的链，完整乘积 $A_1A_2A_3$ 有两种可能的加括号方式：\n-   $P_1: (A_1A_2)A_3$\n-   $P_2: A_1(A_2A_3)$\n\n我们来计算每种加括号方式的总成本。\n$P_1$ 的成本是计算中间乘积 $A_{12} = A_1A_2$ 的成本，加上将 $A_{12}$ 与 $A_3$ 相乘的成本。矩阵 $A_{12}$ 的维度为 $d_0 \\times d_2$。\n计算 $A_{12}$ 的成本已知为 $d_0 d_1 d_2 = 120$。\n将 $A_{12}$（大小为 $d_0 \\times d_2$）与 $A_3$（大小为 $d_2 \\times d_3$）相乘的成本是 $d_0 d_2 d_3$。\n所以，$P_1$ 的总成本是 $C_1 = d_0 d_1 d_2 + d_0 d_2 d_3$。\n\n$P_2$ 的成本是计算中间乘积 $A_{23} = A_2A_3$ 的成本，加上将 $A_1$ 与 $A_{23}$ 相乘的成本。矩阵 $A_{23}$ 的维度为 $d_1 \\times d_3$。\n计算 $A_{23}$ 的成本已知为 $d_1 d_2 d_3 = 210$。\n将 $A_1$（大小为 $d_0 \\times d_1$）与 $A_{23}$（大小为 $d_1 \\times d_3$）相乘的成本是 $d_0 d_1 d_3$。\n所以，$P_2$ 的总成本是 $C_2 = d_1 d_2 d_3 + d_0 d_1 d_3$。\n\n问题陈述 $(A_1A_2)A_3$ 是最优的加括号方式，且最小乘法次数为 $C^{\\ast} = 204$。这蕴含了两个条件：\n1.  最优路径的成本为 $C_1 = C^{\\ast} = 204$。\n2.  最优路径的成本小于或等于任何其他路径的成本，即 $C_1 \\le C_2$。\n\n使用第一个条件，我们有：\n$$C_1 = d_0 d_1 d_2 + d_0 d_2 d_3 = 204$$\n我们已知 $d_0 d_1 d_2 = 120$。将这个值代入 $C_1$ 的方程中：\n$$120 + d_0 d_2 d_3 = 204$$\n求解项 $d_0 d_2 d_3$：\n$$d_0 d_2 d_3 = 204 - 120 = 84$$\n\n现在我们有一个包含三个方程的方程组，关联了这些维度的乘积：\n(i) $d_0 d_1 d_2 = 120$\n(ii) $d_1 d_2 d_3 = 210$\n(iii) $d_0 d_2 d_3 = 84$\n\n问题要求比值 $d_1/d_0$ 的值。我们可以通过将方程(ii)除以方程(iii)来得到这个比值。由于所有维度 $d_i$ 都是正整数，乘积 $d_1 d_2 d_3$ 和 $d_0 d_2 d_3$ 均非零，因此除法是有效的操作。\n$$\\frac{d_1 d_2 d_3}{d_0 d_2 d_3} = \\frac{210}{84}$$\n分子和分母中的项 $d_2$ 和 $d_3$ 可以消去：\n$$\\frac{d_1}{d_0} = \\frac{210}{84}$$\n为了化简分数，我们可以求 $210$ 和 $84$ 的最大公约数。\n$210 = 2 \\cdot 3 \\cdot 5 \\cdot 7$\n$84 = 2^2 \\cdot 3 \\cdot 7$\n最大公约数是 $2 \\cdot 3 \\cdot 7 = 42$。\n或者，我们也可以看出 $210 = 21 \\times 10$ 和 $84 = 21 \\times 4$。\n$$\\frac{d_1}{d_0} = \\frac{21 \\times 10}{21 \\times 4} = \\frac{10}{4} = \\frac{5}{2}$$\n\n作为一致性检查，我们可以验证最优性条件 $C_1 \\le C_2$。\n$$d_0 d_1 d_2 + d_0 d_2 d_3 \\le d_1 d_2 d_3 + d_0 d_1 d_3$$\n代入已知值：\n$$120 + 84 \\le 210 + d_0 d_1 d_3$$\n$$204 \\le 210 + d_0 d_1 d_3$$\n由于 $d_0, d_1, d_3$ 是正整数，它们的乘积 $d_0 d_1 d_3$ 是一个正整数。该不等式成立，因为 $204$ 小于 $210$ 加上一个正值。这证实了问题数据是内部一致的。因此，比值 $d_1/d_0$ 的推导被确认为合理。\n最终答案是这个比值的最简分数。",
            "answer": "$$\\boxed{\\frac{5}{2}}$$"
        },
        {
            "introduction": "动态规划是一种解决最优化问题的强大框架。在掌握了如何最小化矩阵链乘法的成本之后，一个很好的检验你是否真正理解其核心思想的方法是解决它的对偶问题：如何最大化计算成本？这个练习  引导你思考如何调整标准的动态规划递推关系，以寻找成本最高的括号划分方式。你会发现，解决这个问题只需对算法进行微小的改动，这深刻地揭示了动态规划思想的灵活性和普适性。",
            "id": "3249152",
            "problem": "考虑一个由数组 $p = [p_0, p_1, \\dots, p_n]$ 表示的矩阵维度序列，其中矩阵 $A_i$ 的维度为 $p_i \\times p_{i+1}$（对于 $i \\in \\{0, 1, \\dots, n-1\\}$）。矩阵乘法这一二元运算满足结合律，因此最终乘积 $A_0 A_1 \\cdots A_{n-1}$ 是明确定义的，但标量乘法的总次数取决于乘积的加括号方式。此问题的基本依据是两个经过充分验证的事实：将一个 $a \\times b$ 的矩阵与一个 $b \\times c$ 的矩阵相乘需要 $a \\cdot b \\cdot c$ 次标量乘法，以及矩阵乘法满足结合律。利用这些事实，推导一种方法，该方法能针对给定的维度数组 $p$，确定一种可使计算乘积 $A_0 A_1 \\cdots A_{n-1}$ 所需标量乘法总次数最大化的加括号方式，并输出这种最优加括号方式下所需的最大标量乘法次数。除了 $p$ 的元素是正整数之外，你不能假设其具有任何特殊结构。你必须从所述事实出发，根据第一性原理进行推理，并设计一个在逻辑上遵循这些原理的算法解决方案，不得使用任何快捷公式。\n\n你的程序必须实现这一逻辑，并为以下维度数组测试套件计算最大标量乘法次数：\n案例 $1$：$p = [7, 13]$。\n案例 $2$：$p = [40, 20, 30]$。\n案例 $3$：$p = [5, 10, 3, 12]$。\n案例 $4$：$p = [10, 10, 10, 10, 10]$。\n案例 $5$：$p = [2, 100, 2, 100, 2]$。\n案例 $6$：$p = [6, 12, 8, 10, 20, 5]$。\n\n对于每个案例，输出必须是一个单一整数，等于由 $p$ 定义的矩阵链在所有有效加括号方式下的最大标量乘法次数。你的程序应生成单行输出，其中包含用逗号分隔并用方括号括起来的结果（例如 $[r_1,r_2,\\dots,r_6]$），其中 $r_i$ 对应于案例 $i$。此问题不涉及物理单位、角度单位或百分比格式；答案为纯整数。\n\n确保你的算法具有通用性，对任何满足 $n \\ge 0$ 且所有 $i$ 都有 $p_i \\in \\mathbb{N}$ 的有效输入 $p$ 都能给出正确结果，并在 $n = 1$ 时（单个矩阵“相乘”需要 0 次标量乘法）明确返回 0。测试套件的构建旨在覆盖多种场景：单个矩阵的边界情况、两个矩阵的平凡乘法、加括号方式会改变成本的小型链、维度统一导致不同加括号方式成本相同的链、大小维度交替以凸显加括号效果的链，以及一个用于测试一般行为的较长链。",
            "solution": "基本依据包括两个经过充分验证的事实：矩阵乘法满足结合律，以及一个 $a \\times b$ 矩阵与一个 $b \\times c$ 矩阵相乘的成本是 $a \\cdot b \\cdot c$ 次标量乘法。这些事实表明，虽然矩阵链的最终乘积与加括号方式无关，但标量乘法的总次数取决于执行乘法的顺序。为设计一个最大化标量乘法总次数的算法，我们使用基于原理的推理来推导一个利用了最优子结构和重叠子问题特性的递推关系，这自然引出了动态规划（DP）方法。\n\n设矩阵链为 $A_0, A_1, \\dots, A_{n-1}$，其中 $A_i$ 的维度为 $p_i \\times p_{i+1}$；因此，维度数组为 $p = [p_0, p_1, \\dots, p_n]$。考虑子链 $A_i \\cdots A_j$（其中 $0 \\le i \\le j \\le n-1$）的任意一种加括号方式。在该子链的任何有效加括号方式中，都存在一个索引 $k$（$i \\le k  j$），使得最后一次乘法是合并子乘积 $(A_i \\cdots A_k)$ 和 $(A_{k+1} \\cdots A_j)$。这最后一次乘法所贡献的成本是 $p_i \\cdot p_{k+1} \\cdot p_{j+1}$，因为 $(A_i \\cdots A_k)$ 的维度是 $p_i \\times p_{k+1}$，而 $(A_{k+1} \\cdots A_j)$ 的维度是 $p_{k+1} \\times p_{j+1}$。整个加括号方式的总成本是左子链成本、右子链成本与最后一次乘法成本之和。\n\n为了最大化标量乘法总次数，我们定义 DP 表 $M[i][j]$ 为计算 $A_i \\cdots A_j$ 所需的最大标量乘法次数。基本情况是对于所有 $i$，$M[i][i] = 0$，因为单个矩阵不需要任何乘法。对于 $i  j$，从基本成本分解推导出的递推关系为\n$$\nM[i][j] = \\max_{i \\le k  j} \\big( M[i][k] + M[k+1][j] + p_i \\cdot p_{k+1} \\cdot p_{j+1} \\big).\n$$\n这个递推关系直接源于矩阵乘法的结合律结构以及合并子链的成本可加性。最优子结构性质成立：如果计算 $A_i \\cdots A_j$ 的一种加括号方式在某个 $k$ 处分割并达到了最大总成本，那么其对 $A_i \\cdots A_k$ 和 $A_{k+1} \\cdots A_j$ 的加括号方式本身也必须是对应子问题的最大成本解。否则，若能用成本更高的子问题解替换，总成本将严格增加，这与已达最大值的假设相矛盾。重叠子问题之所以出现，是因为相同的子链会出现在不同的分割方式中。\n\nDP 算法按链长度递增的顺序计算 $M[i][j]$。具体而言，我们遍历子链长度 $\\ell$（从 $2$ 到 $n$），对于每个满足 $j = i + \\ell - 1$ 的 $(i,j)$ 对，使用上述递推关系计算 $M[i][j]$。由于存在关于 $\\ell$、$i$ 和 $k$ 的三层嵌套循环，该算法的运行时间为 $O(n^3)$，并使用 $O(n^2)$ 的空间来存储表 $M$。\n\n边界情况可以被自然地处理。当 $n = 1$（即 $|p| = 2$）时，只有一个矩阵，成本为 0。当 $n = 2$（即 $|p| = 3$）时，只有一次乘法，成本为 $p_0 \\cdot p_1 \\cdot p_2$。对于维度统一的情况，如 $p = [10, 10, 10, 10, 10]$，每次乘法的成本 $p_i \\cdot p_{k+1} \\cdot p_{j+1}$ 都等于 $10 \\cdot 10 \\cdot 10 = 1000$，且所有加括号方式的总成本相同，等于 $1000 \\cdot (n-1)$，其中 $n$ 是矩阵数量。对于 $n=4$ 的情况，这会得到 $3000$。\n\n以案例 3，$p = [5, 10, 3, 12]$（$n = 3$ 个矩阵）为例进行说明性推导：\n- 加括号方式 $(A_0 A_1) A_2$ 产生的成本为 $5 \\cdot 10 \\cdot 3 + 5 \\cdot 3 \\cdot 12 = 150 + 180 = 330$。\n- 加括号方式 $A_0 (A_1 A_2)$ 产生的成本为 $10 \\cdot 3 \\cdot 12 + 5 \\cdot 10 \\cdot 12 = 360 + 600 = 960$。\n因此最大值为 $960$，这与 DP 公式一致。对于案例 5，$p = [2, 100, 2, 100, 2]$（$n=4$ 个矩阵），DP 算法将选择一种强制在大的中间维度上进行乘法的分割，通过如 $((A_0(A_1A_2))A_3)$ 或 $(A_0((A_1A_2)A_3))$ 的加括号方式得到 $40400$ 的最大总成本，这两种方式都涉及两次昂贵的、包含 $100 \\times 100$ 中间矩阵的乘法。\n\n最终的程序实现了这种 DP 最大化方法，并为指定的测试套件生成一行整数结果，其格式为用方括号括起来的逗号分隔列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef max_mcm_cost(dimensions):\n    \"\"\"\n    Compute the maximum number of scalar multiplications needed to multiply\n    a chain of matrices with dimension array 'dimensions' using dynamic programming.\n    Each matrix A_i has dimensions dimensions[i] x dimensions[i+1].\n\n    Parameters:\n        dimensions (list[int]): The dimension array p of length n+1.\n\n    Returns:\n        int: The maximum number of scalar multiplications among all parenthesizations.\n    \"\"\"\n    # Number of matrices in the chain\n    n = len(dimensions) - 1\n    # If there is 0 or 1 matrix, cost is 0\n    if n = 1:\n        return 0\n\n    # dp[i][j] will store the maximum cost to compute Ai..Aj (0-based indices for matrices)\n    dp = [[0] * n for _ in range(n)]\n\n    # Consider chain lengths from 2 to n\n    for chain_len in range(2, n + 1):\n        for i in range(0, n - chain_len + 1):\n            j = i + chain_len - 1\n            max_cost = -1\n            # Try all possible splits k between i and j-1\n            for k in range(i, j):\n                cost_left = dp[i][k]\n                cost_right = dp[k + 1][j]\n                # Cost of multiplying the two resulting matrices:\n                # dims: (dimensions[i] x dimensions[k+1]) * (dimensions[k+1] x dimensions[j+1])\n                mult_cost = dimensions[i] * dimensions[k + 1] * dimensions[j + 1]\n                total_cost = cost_left + cost_right + mult_cost\n                if total_cost > max_cost:\n                    max_cost = total_cost\n            dp[i][j] = max_cost\n\n    return dp[0][n - 1]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [7, 13],                  # Case 1: single matrix -> 0\n        [40, 20, 30],             # Case 2: two matrices -> 40*20*30\n        [5, 10, 3, 12],           # Case 3: 3 matrices, nontrivial\n        [10, 10, 10, 10, 10],     # Case 4: uniform dimensions\n        [2, 100, 2, 100, 2],      # Case 5: alternating large/small dimensions\n        [6, 12, 8, 10, 20, 5],    # Case 6: larger chain\n    ]\n\n    results = []\n    for dims in test_cases:\n        result = max_mcm_cost(dims)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "理论算法在应用于实际时，常常需要考虑物理资源的限制。这个高级练习将矩阵链乘法问题置于一个更真实的场景中，引入了“工作空间”限制，即在计算过程中同时存储的中间矩阵数量不能超过一个给定值 $K$ 。解决这个问题需要你重新设计动态规划的状态，使其不仅记录成本，还要追踪资源使用情况。这不仅是对矩阵链乘法问题的深化，也是学习如何处理带约束优化问题的重要一步。",
            "id": "3249080",
            "problem": "给定一个矩阵链 $A_1, A_2, \\dots, A_n$，其中矩阵 $A_i$ 的维度为 $d_{i-1} \\times d_{i}$，维度数组为 $d = [d_0, d_1, \\dots, d_n]$。一个维度为 $p \\times q$ 的矩阵与一个维度为 $q \\times r$ 的矩阵相乘的成本定义为 $p \\cdot q \\cdot r$ 次标量乘法。矩阵链乘法问题的目标是确定一种加括号的顺序，以最小化计算乘积 $A_1 A_2 \\cdots A_n$ 所需的总标量乘法次数。\n\n在本问题中，计算受到工作空间限制的约束：在计算过程中的任何时刻，您最多可以存储 $K$ 个矩阵（包括尚未组合的原始矩阵和任何中间结果）。您必须假设以下操作模型。\n- 您选择一种对矩阵乘积的完全加括号方式（一种二叉树形态）。在每个内部节点，您将精确地对其左子乘积和右子乘积的结果进行一次乘法运算；禁止重新计算。\n- 您选择一种与加括号方式一致的计算顺序。在计算一个节点时，第一个被计算的子节点的结果必须保持可用，直到第二个子节点被计算并且它们的乘积形成。\n- 在计算过程中同时存储的矩阵峰值数量不能超过 $K$。如果没有任何加括号方式和计算顺序能满足此限制，则该计算是不可行的。\n\n从这些基本事实和定义出发，且在不提供任何快捷公式的情况下，请推导出一个算法，用于计算在工作空间限制 $K$ 下所需的最少标量乘法次数，或者在没有满足限制的计算顺序存在时报告不可行。\n\n您的程序必须解决以下测试套件。每个测试用例是一对 $(d, K)$，其中 $d$ 是维度数组，$K$ 是工作空间限制。\n- 测试 1: $d = [1, 1000, 1, 1000, 1]$, $K = 2$。\n- 测试 2: $d = [1, 1000, 1, 1000, 1]$, $K = 3$。\n- 测试 3: $d = [5, 4, 3]$, $K = 1$。\n- 测试 4: $d = [10, 20]$, $K = 1$。\n- 测试 5: $d = [13, 7, 3, 11]$, $K = 2$。\n- 测试 6: $d = [2, 3, 4]$, $K = 2$。\n\n对于每个测试用例，如果可行，则输出最小标量乘法次数作为非负整数；如果不可行，则输出 $-1$。您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[x_1,x_2,\\dots,x_6]$），顺序与上述测试用例相同。不涉及物理单位或角度单位。如果出现百分比解释，请将该值表示为小数或分数，但本问题仅要求按规定输出整数。",
            "solution": "为了解决带有工作空间限制的矩阵链乘法问题，我们必须扩展标准的动态规划方法，使其状态不仅记录最小成本，还要跟踪所需的资源（即工作空间）。该算法的核心在于推导出一个能够同时计算成本和工作空间需求的递推关系。\n\n首先，我们定义一个加括号方式（表示为一棵二元表达式树 $T$）的工作空间需求 $W(T)$。根据操作模型，计算一个节点需要先计算其两个子节点 $T_L$ 和 $T_R$，并将其中一个子结果存储起来，同时计算另一个。为了最小化峰值工作空间，最优策略是先计算工作空间需求较大的子树。设 $w_L = W(T_L)$ 和 $w_R = W(T_R)$ 分别是左右子树的工作空间需求。该策略的峰值需求（遵循 Sethi-Ullman 编号方案）为：\n$$\nW(T) = \\begin{cases} \\max(w_L, w_R)  \\text{如果 } w_L \\ne w_R \\\\ w_L + 1  \\text{如果 } w_L = w_R \\end{cases}\n$$\n\n基于此，我们构建动态规划。为方便起见，我们设矩阵链为 $A_0, \\dots, A_{n-1}$，其中 $A_k$ 的维度为 $d_k \\times d_{k+1}$。\n- **状态：** 我们定义一个 DP 表 $C[i][j]$，它是一个字典（或哈希表），将工作空间大小 $w$ 映射到计算子链 $A_i \\cdots A_j$ 所需的最小成本 $c$。即 $C[i][j][w] = c$。\n- **基本情况：** 对于单个矩阵 $A_i$（链长为1），计算成本为 0，需要 1 个工作空间槽。因此，对所有 $i$，如果 $K \\ge 1$，则 $C[i][i] = \\{1: 0\\}$。\n- **递推步骤：** 我们按链长 `len` 从 2 到 $n$ 的顺序填充 DP 表。对于每个子链 $A_i \\cdots A_j$ (其中 $j = i + \\text{len} - 1$)，我们遍历所有可能的分割点 $k$ ($i \\le k  j$)：\n  1. 考虑将链分割为 $(A_i \\cdots A_k)$ 和 $(A_{k+1} \\cdots A_j)$。\n  2. 遍历左子问题的所有可行解 $(w_L, c_L)$（来自 $C[i][k]$）和右子问题的所有可行解 $(w_R, c_R)$（来自 $C[k+1][j]$）。\n  3. 对于每一对解，计算新组合的工作空间 $w$ 和总成本 $c$。\n     - $w$ 根据上述 Sethi-Ullman 规则计算。\n     - 合并成本是 $(d_i \\times d_{k+1})$ 矩阵与 $(d_{k+1} \\times d_{j+1})$ 矩阵相乘的成本，即 $d_i \\cdot d_{k+1} \\cdot d_{j+1}$。\n     - 总成本 $c = c_L + c_R + d_i \\cdot d_{k+1} \\cdot d_{j+1}$。\n  4. 如果计算出的工作空间 $w \\le K$，则这是一个有效的加括号方式。我们用它来更新 DP 表：如果 $C[i][j]$ 中尚无 $w$ 的条目，或者 $c$ 小于现有的 $C[i][j][w]$，则令 $C[i][j][w] = c$。\n\n- **最终结果：** 填完整个表后，$C[0][n-1]$ 中包含了计算整个链在不同工作空间限制下的所有最小成本。我们寻找所有 $w \\le K$ 的条目中的最小成本。如果该集合为空，则问题不可行，返回 -1。否则，返回其中的最小值。\n\n该算法的时间复杂度约为 $O(n^3 \\cdot K^2)$，因为在三个嵌套循环（链长、起始点、分割点）内部，我们还需遍历两个子问题的所有可能工作空间大小（最多 $K$ 个）。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the matrix chain multiplication problem with a workspace constraint.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        ([1, 1000, 1, 1000, 1], 2), # Test 1\n        ([1, 1000, 1, 1000, 1], 3), # Test 2\n        ([5, 4, 3], 1),             # Test 3\n        ([10, 20], 1),             # Test 4\n        ([13, 7, 3, 11], 2),       # Test 5\n        ([2, 3, 4], 2)              # Test 6\n    ]\n\n    results = []\n    \n    for d, K in test_cases:\n        n = len(d) - 1 # Number of matrices\n\n        if n == 0:\n            results.append(0)\n            continue\n        \n        if n == 1:\n            results.append(0 if K >= 1 else -1)\n            continue\n\n        # For n > 1, multiplication requires at least 2 slots.\n        if K  2:\n            results.append(-1)\n            continue\n            \n        # dp[i][j] will be a dictionary mapping workspace size 'w' to min cost.\n        dp = [[{} for _ in range(n)] for _ in range(n)]\n\n        # Base case: a chain of length 1 (a single matrix).\n        # Cost is 0, workspace required is 1.\n        for i in range(n):\n            if 1 = K:\n                dp[i][i] = {1: 0}\n\n        # Fill DP table for chains of length 2 to n\n        for length in range(2, n + 1):\n            for i in range(n - length + 1):\n                j = i + length - 1\n                for p in range(i, j):\n                    # Left subproblem: matrices from i to p\n                    # Right subproblem: matrices from p+1 to j\n                    costs_L = dp[i][p]\n                    costs_R = dp[p+1][j]\n                    \n                    if not costs_L or not costs_R:\n                        continue\n                        \n                    for w_L, c_L in costs_L.items():\n                        for w_R, c_R in costs_R.items():\n                            # Calculate workspace required for this combination\n                            # based on the Sethi-Ullman numbering scheme.\n                            w = 0\n                            if w_L == w_R:\n                                w = w_L + 1\n                            else:\n                                w = max(w_L, w_R)\n\n                            # If workspace is within the limit K\n                            if w = K:\n                                # Cost of final multiplication + costs of subproblems\n                                multiplication_cost = d[i] * d[p+1] * d[j+1]\n                                total_cost = c_L + c_R + multiplication_cost\n                                \n                                # Update dp table if this path is better\n                                if w not in dp[i][j] or total_cost  dp[i][j][w]:\n                                    dp[i][j][w] = total_cost\n        \n        final_costs = dp[0][n-1]\n        \n        if not final_costs:\n            results.append(-1)\n        else:\n            min_cost = min(final_costs.values())\n            results.append(int(min_cost))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}