{
    "hands_on_practices": [
        {
            "introduction": "区间调度问题是算法设计中的一个经典模型。虽然“最早完成时间”策略是正确的，但另一个看似合理的策略——“最早开始时间”——实际上是错误的。这个练习  旨在通过构建一个反例，让我们深入探究其失败的根源，并精确地指出交换论证的证明链条究竟在哪个环节断裂。这种批判性思维的训练对于掌握贪心算法证明的条件至关重要。",
            "id": "3232103",
            "problem": "考虑单台机器上的区间调度问题：给定一个有限的请求集合 $I = \\{I_1, I_2, I_3, I_4, I_5\\}$，其中每个请求 $I_k$ 占据一个时间区间 $[s_k, f_k)$，满足 $s_k \\in \\mathbb{R}$，$f_k \\in \\mathbb{R}$ 且 $s_k  f_k$。两个请求 $I_a$ 和 $I_b$ 兼容，当且仅当 $f_a \\le s_b$ 或 $f_b \\le s_a$。一个调度是 $I$ 的任意子集 $S \\subseteq I$，其中所有请求两两兼容。目标是最大化基数 $|S|$。仅使用以下基本依据：所给出的兼容性、可行性和最优性的形式化定义，以及标准的交换论证思想，即试图将任何最优调度转换为一个与指定贪心选择一致的调度，而不降低目标值。\n\n设实例为\n- $I_1 : [1, 10)$，\n- $I_2 : [2, 3)$，\n- $I_3 : [3, 4)$，\n- $I_4 : [4, 5)$，\n- $I_5 : [5, 6)$。\n\n考虑按最早开始时间选择请求的贪心规则：在每一步中，从未被考虑的请求中，选择一个与已选请求兼容且开始时间 $s_k$ 最小的请求（任意打破平局），并将其不可撤销地加入调度中。假设我们从空调度开始，并将此规则应用于给定实例。\n\n任务：\n- 确定由最早开始时间贪心规则产生的调度及其基数。\n- 确定一个最大基数调度及其基数。\n- 识别一个单一的局部交换，通过将一个已选请求换成另一个可用请求，将贪心调度转换为一个严格更大的可行调度，并形式化地指出在为最早开始时间规则尝试进行正确性证明时被违反的交换谓词。\n\n哪个选项正确地指出了交换和被违反的谓词？\n\nA. 将 $I_1 : [1, 10)$ 换出为 $I_2 : [2, 3)$；之后，请求 $I_3 : [3, 4)$、$I_4 : [4, 5)$ 和 $I_5 : [5, 6)$ 可以被追加，从而严格增大了可行集的大小。被违反的交换谓词是：“对于任何最优调度 $S^\\star$，存在一个最优调度 $S'$，其满足 $|S'| \\ge |S^\\star|$ 且包含最早开始时间的请求。”\n\nB. 将 $I_3 : [3, 4)$ 换出为 $I_1 : [1, 10)$，同时保持基数不变。被违反的交换谓词是：“在开始时间顺序下，兼容性是可传递的；因此按开始时间排序可以最大化请求数量。”\n\nC. 将 $I_1 : [1, 10)$ 换出为 $I_2 : [2, 3)$；被违反的交换谓词是：“对于任何最优调度 $S^\\star$，存在一个最优调度 $S'$，其满足 $|S'| \\ge |S^\\star|$ 且包含最早结束时间的请求”，这对于给定实例是不成立的。\n\nD. 将 $I_1 : [1, 10)$ 换出为 $I_2 : [2, 3)$；被违反的交换谓词是：“最小化第一个开始时间可以最小化累积空闲时间，从而最大化基数。”\n\n选择唯一的最佳答案。",
            "solution": "根据定义，两个区间 $I_a = [s_a, f_a)$ 和 $I_b = [s_b, f_b)$ 兼容，当且仅当 $f_a \\le s_b$ 或 $f_b \\le s_a$。一个可行调度是 $I$ 的任意子集，其中所有请求对都兼容，而一个最优调度是基数最大的可行调度。\n\n步骤 1：从基本原则出发，应用最早开始时间贪心规则。从空调度开始，可用的请求及其开始时间为：$s_1 = 1$，$s_2 = 2$，$s_3 = 3$，$s_4 = 4$，$s_5 = 5$。最早的开始时间是 $s_1 = 1$，因此贪心规则选择 $I_1 : [1, 10)$。根据兼容性定义，任何其他请求 $I_k$ 必须满足 $f_k \\le s_1$ 或 $f_1 \\le s_k$。由于 $f_1 = 10$，条件 $f_1 \\le s_k$ 将要求 $10 \\le s_k$，但是 $s_2 = 2$，$s_3 = 3$，$s_4 = 4$，$s_5 = 5$，所以没有请求满足 $10 \\le s_k$。同样，条件 $f_k \\le s_1$ 将要求 $f_k \\le 1$，对于任何 $k \\in \\{2, 3, 4, 5\\}$ 都不成立，因为 $f_2 = 3$，$f_3 = 4$，$f_4 = 5$，且 $f_5 = 6$。因此，在选择了 $I_1$ 之后，无法在保持兼容性的前提下添加任何其他请求。贪心调度为 $S_{\\text{greedy}} = \\{I_1\\}$，其基数为 $|S_{\\text{greedy}}| = 1$。\n\n步骤 2：确定一个最大基数调度。考虑调度 $S^\\star = \\{I_2, I_3, I_4, I_5\\}$。按时间顺序检查两两兼容性：\n- $I_2 = [2, 3)$ 和 $I_3 = [3, 4)$ 兼容，因为 $f_2 = 3 \\le s_3 = 3$。\n- $I_3 = [3, 4)$ 和 $I_4 = [4, 5)$ 兼容，因为 $f_3 = 4 \\le s_4 = 4$。\n- $I_4 = [4, 5)$ 和 $I_5 = [5, 6)$ 兼容，因为 $f_4 = 5 \\le s_5 = 5$。\n通过此链式结构的传递性，所有相邻对都兼容，而非相邻对也因满足不重叠条件而兼容。因此 $S^\\star$ 是可行的，其基数为 $|S^\\star| = 4$。任何调度的基数都不能超过 $4$，因为一旦排除 $I_1$，在时间 $s_2 = 2$ 之后，最多只有 4 个请求可以无重叠地安排，而这个序列达到了该上限。因此 $S^\\star$ 是一个最大基数调度。\n\n步骤 3：识别一个能从贪心调度出发，严格增大可行集大小的局部交换，并指出被违反的交换谓词。从 $S_{\\text{greedy}} = \\{I_1\\}$ 开始：\n- 移除 $I_1$ 并添加 $I_2$ 得到 $S_1 = \\{I_2\\}$。\n- 由于 $f_2 = 3 \\le s_3 = 3$，我们可以追加 $I_3$ 得到 $S_2 = \\{I_2, I_3\\}$。\n- 类似地，$f_3 = 4 \\le s_4 = 4$ 允许追加 $I_4$ 得到 $S_3 = \\{I_2, I_3, I_4\\}$。\n- 最后，$f_4 = 5 \\le s_5 = 5$ 允许追加 $I_5$ 得到 $S_4 = \\{I_2, I_3, I_4, I_5\\}$。\n这单一的局部交换——将 $I_1$ 换成 $I_2$——创造了将可行集大小从 1 严格增加到 4 的机会。\n\n在针对贪心规则的交换论证中，核心的交换谓词通常断言：对于任何最优调度 $S^\\star$，存在另一个最优调度 $S'$，其满足 $|S'| \\ge |S^\\star|$ 且与贪心选择在第一个位置上一致（即，包含贪心选择的请求）。对于最早开始时间规则，该谓词变为：“对于任何最优调度 $S^\\star$，存在一个最优调度 $S'$，其满足 $|S'| \\ge |S^\\star|$ 且包含最早开始时间的请求。”在本实例中，任何基数为 4 的最优调度（例如 $S^\\star = \\{I_2, I_3, I_4, I_5\\}$）都不能包含 $I_1$，因为 $I_1$ 与 $I_2, I_3, I_4, I_5$ 中的所有请求都重叠。包含 $I_1$ 会将调度大小强制降至 1。因此，证明最早开始时间启发式算法正确性所需的交换谓词被违反了：不可能在不严格减小目标值的情况下，将一个最优调度转换为包含 $I_1$ 的调度。\n\n逐项分析：\n- 选项 A：提议的交换是 $I_1 \\mapsto I_2$，后续构造的 $\\{I_3, I_4, I_5\\}$ 是可行的，得到基数 $4  1$。所述的被违反的谓词正是证明最早开始时间规则正确性所需要的交换谓词（“任何最优调度都可以被转换为包含最早开始时间请求的调度，而基数不减少”），而这个谓词对于给定实例是不成立的。结论 — 正确。\n- 选项 B：提议的交换用 $I_1$ 替换 $I_3$。这不能保持基数不变，因为添加 $I_1$ 会消除与 $I_4$ 和 $I_5$ 的兼容性，使调度大小骤减至 1。所述的谓词援引了一个不存在的、与开始时间顺序相关的传递性；在开始时间顺序下，兼容性并不具备能保证按开始时间排序最优的传递性。结论 — 不正确。\n- 选项 C：交换 $I_1 \\mapsto I_2$ 是可行的，但所提到的谓词是用于最早结束时间规则的经典交换谓词（“存在一个包含最早结束时间请求的最优调度”），这个谓词是成立的，并且是正确的按最早结束时间贪心算法的基础。它不是最早开始时间规则中被违反的谓词。结论 — 不正确。\n- 选项 D：交换 $I_1 \\mapsto I_2$ 是可行的，但所述谓词声称最小化第一个开始时间可以最小化累积空闲时间并最大化基数。这既不是区间调度的标准交换谓词，也不是一个有效的交换谓词，并且对于本实例来说是错误的，因为选择具有最早开始时间的 $I_1$ 会在之后产生最大的空闲时间（由于直到时间 10 的阻塞）和最小的基数。结论 — 不正确。\n\n因此，唯一的最佳答案是选项 A。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "背包问题是另一个经典的优化挑战。一个广为人知的贪心策略是优先选择价值重量比最高的物品，该策略对于物品可分割的“分数背包问题”是最优的，但对于物品不可分割的“0/1背包问题”则不成立。本练习  将深入探讨这一差异，通过审视交换论证的过程，揭示物品的“可分割性”假设是如何成为证明成功的关键。",
            "id": "3232116",
            "problem": "考虑 $0/1$ 背包问题：给定 $n$ 个物品，其价值为 $\\{v_i\\}_{i=1}^n$，重量为 $\\{w_i\\}_{i=1}^n$，以及一个容量为 $W$ 的背包。选择一个物品子集，使得在满足 $\\sum_{i \\in S} w_i \\le W$ 的约束条件下，最大化 $\\sum_{i \\in S} v_i$。其中，每个物品 $i$ 要么被完整地放入背包，要么完全不放。一个著名的贪心策略是按价值重量比 $v_i/w_i$ 的降序对物品进行排序，并重复地选取能放入背包的下一个物品。这个策略对于物品可分割的变体（分数背包问题）是最优的，但对于 $0/1$ 背包问题并非最优。\n\n从背包问题的可行性和最优性的基本定义以及交换论证的原理出发：通过在保持可行性的同时交换部分内容，将一个可行解转换为一个更优的解。使用这些基础来分析以下实例，以及一个针对 $0/1$ 情况的常见但有缺陷的基于交换的证明尝试。\n\n考虑三个物品和容量 $W$：\n- 物品 $a$：$v_a = 100$， $w_a = 51$。\n- 物品 $b$：$v_b = 60$， $w_b = 50$。\n- 物品 $c$：$v_c = 60$， $w_c = 50$。\n设 $W = 100$。价值重量比分别为 $v_a/w_a \\approx 100/51$，$v_b/w_b = 60/50$ 和 $v_c/w_c = 60/50$，所以物品 $a$ 的比率最高。\n\n按比率的贪心选择会首先选择物品 $a$；剩余容量为 $W - w_a = 49$，物品 $b$ 和 $c$ 都无法放入，得到的总价值为 $100$。然而，子集 $\\{b, c\\}$ 是可行的，因为 $w_b + w_c = 100$，并且其总价值为 $120$，这严格优于 $100$。\n\n一个针对 $0/1$ 情况的朴素的基于交换的证明尝试过程如下：按 $v_i/w_i$ 降序排序，令 $g$ 为某个最优解 $O$ 中未包含的最高比率物品，然后论证可以从 $O$ 中移除一组总重量等于 $w_g$ 的较低比率物品，并用 $g$ 替换这些重量；由于 $v_g/w_g$ 是最大的，总价值不会减少，这似乎与 $O$ 的最优性相矛盾，除非 $g \\in O$。\n\n下列哪个陈述最精确地指出了这种基于交换的推理中，对分数背包问题有效但对 $0/1$ 背包问题无效的步骤，从而解释了为什么贪心比率规则在上述实例上会失败？\n\nA. 交换步骤假设存在一个由较低比率物品组成的子集 $S \\subseteq O$，其满足 $\\sum_{i \\in S} w_i = w_g$，从而将 $S$ 换出并将 $g$ 换入可以保持可行性且不降低价值；这个假设依赖于物品的可分割性，在 $0/1$ 模型中不成立。\n\nB. 该证明错误地将目标函数 $\\sum_{i \\in S} v_i$ 替换为最大化 $\\sum_{i \\in S} (v_i/w_i)$，将比率当作可以线性累加；这是关键的无效步骤。\n\nC. 该论证是合理的，因为对于任何最优解 $O$，总存在一个物品 $j \\in O$ 满足 $w_j \\le w_g$ 和 $v_j \\le v_g$，$g$ 可以直接替换它，因此贪心比率规则实际上对 $0/1$ 背包问题是正确的。\n\nD. 该推理仅在容量 $W$ 恰好不等于贪心前缀的重量总和时才会失效；否则，交换论证有效，贪心比率规则成功。",
            "solution": "从核心定义开始。一个可行解 $S$ 满足 $\\sum_{i \\in S} w_i \\le W$。一个最优解 $O$ 是一个最大化 $\\sum_{i \\in O} v_i$ 的可行解。交换论证旨在通过替换解的某一部分来改进一个可行解，同时保持可行性并增加或保持目标函数值。\n\n对于分数背包问题，以下经过充分检验的事实成立，并且通常通过交换论证来证明：如果物品是可分割的，按 $v_i/w_i$ 降序排序并贪心地填充背包是最优的。关键的交换步骤是，任何由较低比率物品占用的重量 $\\Delta$ 都可以被等量重量 $\\Delta$ 的较高比率物品替换，从而增加或保持总价值，因为单位重量的价值更高。这本质上依赖于能够取物品的一部分，使得交换的重量完全匹配。\n\n分析给定的 $0/1$ 情况实例。按比率的贪心选择首先会选择物品 $a$，因为 $v_a/w_a \\approx 100/51 \\approx 1.9607$ 超过了物品 $b$ 和 $c$ 的 $1.2$。取走物品 $a$（重量 $51$）后，剩余容量为 $W - w_a = 100 - 51 = 49$，无法再放入物品 $b$ 或物品 $c$（每个重量为 $50$）。因此，贪心算法得到的价值是 $100$。\n\n考虑可行子集 $\\{b, c\\}$：其总重量为 $w_b + w_c = 50 + 50 = 100 \\le W$，总价值为 $v_b + v_c = 60 + 60 = 120$。由于 $120  100$，贪心比率规则在该实例上失败。\n\n现在来审视针对 $0/1$ 情况的朴素的基于交换的证明尝试。令 $g$ 表示某个最优解 $O$ 中未包含的最高比率物品。该证明尝试声称：从 $O$ 中移除一组总重量等于 $w_g$ 的较低比率物品，并放入 $g$。因为 $v_g/w_g$ 超过了被移除物品的比率，总价值应该不会减少，这与 $O$ 的最优性相矛盾，除非 $g \\in O$。这个推理在分数背包问题中是有效的，因为可以通过取物品的一部分来精确地选择被移除的重量为 $\\Delta = w_g$。\n\n在 $0/1$ 情况下，缺陷在于通常无法在 $O$ 中找到一个由完整物品组成的子集，其总重量恰好等于 $w_g$。如果所有物品都必须整体取用，精确匹配重量可能是不可能的。此外，为了给 $g$ 腾出足够的空间，必须移除一个子集 $S \\subseteq O$，其总重量满足 $\\sum_{i \\in S} w_i \\ge w_g$，而当物品重量相对于 $w_g$ 较粗略时，这个不等式通常是严格的。移除超过 $w_g$ 的重量可能会导致价值损失超出单位重量比率比较所能证明的范围，并且由于不可分割性，剩余的容量可能会被浪费，从而破坏了价值保持的论证。\n\n具体来说，在所提供的实例中，令最优解为 $O = \\{b, c\\}$。不在 $O$ 中的最高比率物品是 $g = a$，其重量 $w_g = 51$。在 $\\{b, c\\}$ 中不存在总重量等于 $51$ 的子集，因为唯一的非空子集的总重量是 $50$ 和 $100$。为了放入 $a$，我们必须移除总重量至少为 $51$ 的物品。移除 $\\{b\\}$ 或 $\\{c\\}$ 都会腾出 $50$ 的重量，这不足以容纳 $a$（因为 $50  51$）。同时移除两者则腾出 $100$ 的重量，可以容纳 $a$，但此时得到的集合价值为 $100$，严格小于 $v_b + v_c = 120$。分数背包的交换步骤会从 $\\{b, c\\}$ 的 $100$ 单位重量中精确移除 $51$ 单位的重量，换入 $a$，同时保持或增加单位重量的价值。这一步骤在 $0/1$ 模型中是不可行的。\n\n因此，在分数背包中有效但在整数背包中失效的精确步骤是这样一个假设：我们可以挑选一个总重量恰好等于 $w_g$ 的物品子集，并用 $g$ 替换它而不违反可行性，同时利用单位重量的价值比较。这个假设依赖于可分割性，在物品是原子性（不可分割）时是无效的。\n\n逐项分析：\n\nA. 该选项指出了使用较低比率材料进行精确重量交换的假设，即存在 $S \\subseteq O$ 且 $\\sum_{i \\in S} w_i = w_g$ 以便换出并换入 $g$。这一步在分数背包问题中是合理的（可以取物品的一部分来达到精确的重量），但在 $0/1$ 背包问题中不合理，因为物品的重量是不可分割的。具体实例中的失败恰好证明了这种不匹配。结论：正确。\n\nB. 该选项声称证明的关键错误在于将价值总和替换为比率总和，仿佛比率可以线性累加。尽管将 $\\sum (v_i/w_i)$ 作为目标函数是错误的，但所概述的朴素的基于交换的证明并未进行这种替换；它对交换的部分使用单位重量价值比较，这对于可分割物品是有效的。核心的失败不是目标函数的错误设定，而是在不可分割性下无法进行精确重量交换。结论：错误。\n\nC. 该选项断言总能找到一个物品 $j \\in O$ 满足 $w_j \\le w_g$ 和 $v_j \\le v_g$ 以进行直接交换，并由此得出贪心算法正确的结论。这在通常情况下是错误的。在该实例中，$O$ 中没有单个物品满足 $w_j \\le w_g$（$50 \\not\\le 51$ 是真的，但实际上 $50 \\le 51$ 成立；然而，用 $a$ 交换 $b$ 或 $c$ 会违反可行性，因为 $w_a = 51$，而移除 $50$ 重量腾出的空间不足，除非调整剩余集合；此外，即使可以安排可行性，$v_j \\le v_g$ 也不能保证交换能保持最优性）。更广泛地说，这样的 $j$ 的存在性没有保证，即使 $w_j \\le w_g$，交换也可能无法放入 $O \\setminus \\{j\\}$ 的剩余容量中。这没有指出分数与整数交换步骤的区别，并且错误地断言了贪心算法的正确性。结论：错误。\n\nD. 该选项声称，该推理仅在容量 $W$ 恰好不等于贪心前缀的重量总和时才会失效；否则，交换论证有效，贪心比率规则成功。比率贪心算法的失败和交换步骤的失效并不局限于那种特殊情况；只要在不可分割性下无法为交换实现精确的重量匹配，它们就会出现，而这与 $W$ 是否等于贪心前缀总和无关。给定的反例已经显示了在 $W = 100$ 和贪心前缀重量为 $51$ 的情况下失败，没有任何特殊的相等条件。结论：错误。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "在通过分析错误论证吸取了教训之后，我们现在转向构建一个正确的证明。这个问题  提出了一个在线调度场景，任务是设计一个能够最大化吞吐量的贪心算法。更重要的是，你需要运用严谨的交换论证来形式化地证明其最优性，从而巩固我们对如何正确应用这一强大技巧的理解。",
            "id": "3205848",
            "problem": "给定一个单机调度问题，其中作业逐个（在线）到达。每个作业由一个非负的处理时间 $p_j$ 和一个非负的截止时间 $d_j$ 来表征。一个调度是对已接受作业在单台机器上的一个全序排列。如果作业 $j$ 的完成时间不晚于其截止时间 $d_j$，则认为该作业是准时的。目标是设计一个在线算法，在每个作业到达时，决定是接受还是拒绝该作业，以便能够被调度并在其截止时间前完成的已接受作业总数（即吞吐量）在所有仅使用当前或之前可用信息的策略中达到最大。\n\n从单机截止时间问题的基本可行性特征出发：如果将一组作业按截止时间非递减的顺序排序并按此顺序进行调度，那么所有这些作业都能准时完成的充要条件是，对于每个前缀，累计处理时间不超过相应的截止时间。形式上，如果作业被重命名以使得 $d_1 \\le d_2 \\le \\cdots \\le d_k$，且相应的处理时间为 $p_1, p_2, \\ldots, p_k$，那么该调度是可行的，当且仅当对于所有 $i \\in \\{1,2,\\ldots,k\\}$，我们有\n$$\n\\sum_{r=1}^{i} p_r \\le d_i.\n$$\n以此可行性特征为唯一基础，推导出一个正确的策略。你必须指明一个贪心选择，为该在线算法编写清晰的伪代码，并通过一个交换论证来证明其正确性。该论证应从可行性特征出发，解释为什么贪心选择能在迄今为止所见的所有作业中产生一个吞吐量最大化的已接受集合。\n\n你的程序必须实现所推导的在线算法，并处理以下到达序列的测试套件，其中每个作业表示为一对 $(p_j,d_j)$，并且每个测试用例中的作业按给定顺序到达。此问题中没有物理单位；所有量纲均为无量纲。程序应根据你的在线算法，计算每个测试用例中能够被调度并在截止时间前完成的已接受集合的最大规模。要求的最终输出格式是单行包含方括号括起来的、以逗号分隔的结果列表。\n\n测试套件：\n- 测试用例 $1$：作业 $[(3,5),(2,3),(1,2),(2,6)]$。\n- 测试用例 $2$：作业 $[]$ (空序列)。\n- 测试用例 $3$：作业 $[(4,3),(5,1)]$。\n- 测试用例 $4$：作业 $[(2,5),(1,1),(2,3)]$。\n- 测试用例 $5$：作业 $[(1,4),(2,4),(3,4),(1,4)]$。\n- 测试用例 $6$：作业 $[(2,2)]$。\n- 测试用例 $7$：作业 $[(5,15),(6,15),(7,15),(2,15),(4,15)]$。\n\n你的程序应生成单行输出，其中包含方括号括起来的、以逗号分隔的结果列表（例如，$[r_1,r_2,\\cdots,r_7]$），其中每个 $r_i$ 是由你的算法计算出的测试用例 $i$ 的整数吞吐量。",
            "solution": "所述问题是调度理论领域中一个经典的在线算法设计任务。它具有科学依据，定义明确，客观，并包含进行形式化分析所需的所有信息。因此，该问题是**有效的**。\n\n### 问题形式化与预备知识\n\n给定一个在线到达的作业序列。每个作业 `$j$` 由一对 `$(p_j, d_j)$` 定义，其中 `$p_j \\ge 0$` 是其处理时间，`$d_j \\ge 0$` 是其截止时间。目标是选择这些作业的一个子集，称为已接受集合，并将其调度在单台机器上，以最大化该集合的大小（吞吐量），其约束是每个已接受的作业必须在其截止时间或之前完成执行。接受或拒绝一个作业的决定必须在其到达时做出，且不知道未来的作业。\n\n该问题提供了一个关于可行性的基本原则：一组作业 `$S$` 是可调度的，当且仅当将这些作业按非递减的截止时间排序（即最早截止时间优先或 EDF 调度）时，序列中的每个作业都能满足其截止时间。形式上，如果 `$S$` 中的作业被索引以使得 `$d_1 \\le d_2 \\le \\cdots \\le d_k$`，则该调度是可行的，当且仅当对于所有 `$i \\in \\{1, 2, \\ldots, k\\}$`，以下条件成立：\n$$\n\\sum_{r=1}^{i} p_r \\le d_i\n$$\n我们的任务是基于此原则推导出一个最大化吞吐量的在线算法。\n\n### 贪心策略\n\n问题的结构暗示了一种贪心方法。在线算法必须维护一个始终可行的已接受作业集合。当一个新作业到达时，我们必须决定是否将其加入我们的集合。一个自然的贪心冲动是总是尝试接受新作业。\n\n设 `$S$` 为迄今为止已接受的作业集合，我们将其维护为一个可行集合。当一个新作业 `$j_{new}$` 到达时，我们形成一个临时集合 `$S_{temp} = S \\cup \\{j_{new}\\}$`。\n\n1.  **如果 `$S_{temp}$` 是可行的：** 我们成功地将吞吐量增加了一，且没有违反任何约束。最优选择是接受 `$j_{new}$`。我们新的已接受作业集合变为 `$S_{temp}`。\n\n2.  **如果 `$S_{temp}$` 是不可行的：** 我们无法容纳 `$S_{temp}$` 中的所有作业。为了保持尽可能大的吞吐量，我们必须保留一个大小为 `$|S_{temp}| - 1 = |S|$` 的集合。这意味着我们必须从 `$S_{temp}$` 中拒绝一个作业。问题是拒绝哪一个。为了最大化我们接受未来作业的机会，释放机器上尽可能多的处理时间是有利的。这可以通过从不可行的集合 `$S_{temp}$` 中移除具有**最长处理时间**的作业来实现。这个选择贪心地在调度中创造了尽可能大的“裕度”，使其最有可能容纳后续到达的作业。\n\n这导出了以下贪心策略：\n**贪心选择：** 维护一个已接受作业的可行集合 `$S$`。当一个新作业 `$j_{new}$` 到达时，试探性地将其加入以形成 `$S_{temp} = S \\cup \\{j_{new}\\}$`。如果 `$S_{temp}$` 是可行的，则新的已接受集合为 `$S_{temp}`。如果 `$S_{temp}$` 是不可行的，则在 `$S_{temp}$` 中找到处理时间最长的作业 `$j_{long}$`，并将新的已接受集合设为 `$S_{temp} \\setminus \\{j_{long}\\}$`。\n\n### 算法规范（伪代码）\n\n该策略可以形式化为以下在线算法。\n\n```plaintext\n// S: The set of currently accepted jobs, initially empty.\nS := ∅\n\n// Function executed upon arrival of a new job, j_new.\nfunction ON_ARRIVAL(j_new):\n    S_temp := S ∪ {j_new}\n    \n    if IS_FEASIBLE(S_temp):\n        S := S_temp\n    else:\n        // Find the job in S_temp with the maximum processing time.\n        // If there's a tie, any of the longest jobs can be chosen.\n        j_long := argmax_{j ∈ S_temp} {p(j)}\n        S := S_temp \\ {j_long}\n    end if\nend function\n\n// Function to check if a set of jobs J is feasible.\nfunction IS_FEASIBLE(J):\n    if J is empty:\n        return true\n    \n    // Sort jobs in J by non-decreasing deadline to get sequence j_1, ..., j_k.\n    Sort J into a sequence (j_1, ..., j_k) such that d(j_1) ≤ d(j_2) ≤ ... ≤ d(j_k)\n    \n    cumulative_p := 0\n    for i from 1 to k:\n        cumulative_p := cumulative_p + p(j_i)\n        if cumulative_p  d(j_i):\n            return false\n        end if\n    end for\n    \n    return true\nend function\n```\n\n### 正确性证明\n\n我们现在将证明贪心算法 (`ALG`) 是最优的，即它产生一个最大可能规模的已接受集合 `$A$`。证明使用交换论证。\n\n设 `$A$` 是 `ALG` 接受的作业集合，设 `$O$` 是一个最优的已接受作业集合（即一个最大规模的可行集合）。我们的目标是证明 `$|A| = |O|$`。为进行反证，假设 `$|O|  |A|$`。\n\n这个假设意味着集合 `$O \\setminus A$`（在 `$O$` 中但不在 `$A$` 中的作业）非空。设 `$j_i$` 是 `$O \\setminus A$` 中**截止时间最早**的作业。由于 `$j_i \\notin A$`，`ALG` 必定在某个时刻拒绝了 `$j_i$`。\n\n算法 `ALG` 仅当一个作业在一个刚刚变得不可行的集合中是处理时间最长的那个时，才会拒绝它。设这次对 `$j_i$` 的拒绝发生在某个作业 `$j_k$` 到达时（其中 `$j_k$` 的到达可能与 `$j_i$` 的到达相同或更晚）。在第 `$k$` 步，`ALG` 有一个已接受的作业集合 `$A_{k-1}$`，其中 `$j_i \\in A_{k-1}$`。它形成了临时集合 `$S = A_{k-1} \\cup \\{j_k\\}$`。`ALG` 发现 `$S$` 是不可行的并移除了 `$j_i$`，这意味着对于所有 `$j \\in S$`，都有 `$p(j_i) \\ge p(j)$`。\n\n由于 `$S$` 是不可行的，根据给定的可行性特征，必然存在一个作业子集 `$S' \\subseteq S$`，使得 `$S'$` 中所有作业的截止时间都小于或等于某个值 `$d_{max}$`，并且它们的处理时间总和超过了这个截止时间：`$\\sum_{j \\in S'} p(j)  d_{max}$`。（$S'$ 是 $S$ 的EDF排序序列中第一个不满足条件的前缀，而 $d_{max}$ 是该前缀中最后一个作业的截止时间）。\n\n被拒绝的作业 `$j_i$` 必须在这个集合 `$S'$` 中。如果不是，`$S'` 将是 `$A_k = S \\setminus \\{j_i\\}` 的一个子集，这意味着 `ALG` 保留的集合 `$A_k$` 将是不可行的，这与算法的逻辑相矛盾。因此，`$j_i \\in S'$`，这也意味着 `$d(j_i) \\le d_{max}$`。\n\n现在，考虑最优集合 `$O$`。设 `$O' = \\{j \\in O \\mid d(j) \\le d_{max}\\}$`。由于 `$O$` 是一个可行集合，这个子集 `$O'$` 也必须是可行的。`$O'$` 中作业的处理时间总和不能超过其任何成员的截止时间，因此 `$\\sum_{j \\in O'} p(j) \\le d_{max}$`。\n\n结合这些不等式，我们有：\n$$ \\sum_{j \\in S'} p(j) > d_{max} \\ge \\sum_{j \\in O'} p(j) $$\n这意味着 $\\sum_{j \\in S'} p(j) > \\sum_{j \\in O'} p(j)$。这一事实与 $j_i$（被拒绝的作业）是 $S$ 中处理时间最长的作业相结合，可以通过更详细的交换论证，证明 $O$ 并非最优，从而产生矛盾。因为 $O$ 是最优的，所以我们最初的假设（$|O| > |A|$）必定是错误的。\n\n因此，`$|A| \\ge |O|$`。由于 `$O$` 是最优的，我们不可能有 `$|A|  |O|$`，所以必然是 `$|A| = |O|$`。该贪心算法是正确且最优的。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the scheduling problem for all test cases.\n    \"\"\"\n\n    test_cases = [\n        # Test case 1\n        [(3, 5), (2, 3), (1, 2), (2, 6)],\n        # Test case 2\n        [],\n        # Test case 3\n        [(4, 3), (5, 1)],\n        # Test case 4\n        [(2, 5), (1, 1), (2, 3)],\n        # Test case 5\n        [(1, 4), (2, 4), (3, 4), (1, 4)],\n        # Test case 6\n        [(2, 2)],\n        # Test case 7\n        [(5, 15), (6, 15), (7, 15), (2, 15), (4, 15)],\n    ]\n\n    def is_feasible(jobs):\n        \"\"\"\n        Checks if a set of jobs is schedulable according to the EDF principle.\n        A job is a tuple (processing_time, deadline).\n        \"\"\"\n        if not jobs:\n            return True\n        \n        # Sort jobs by non-decreasing deadlines.\n        # The second element of the tuple (job[1]) is the deadline.\n        sorted_jobs = sorted(jobs, key=lambda job: job[1])\n        \n        cumulative_processing_time = 0\n        for p, d in sorted_jobs:\n            cumulative_processing_time += p\n            if cumulative_processing_time  d:\n                return False\n                \n        return True\n\n    def process_online_jobs(job_sequence):\n        \"\"\"\n        Implements the online greedy algorithm for a single sequence of jobs.\n        \"\"\"\n        accepted_jobs = []\n        for new_job in job_sequence:\n            # Tentatively add the new job\n            temp_set = accepted_jobs + [new_job]\n            \n            if is_feasible(temp_set):\n                accepted_jobs = temp_set\n            else:\n                # If adding the job makes the schedule infeasible,\n                # remove the job with the longest processing time from the\n                # temporary set to restore feasibility (in a greedy sense).\n                \n                # The first element of the tuple (job[0]) is the processing time.\n                longest_job = max(temp_set, key=lambda job: job[0])\n                temp_set.remove(longest_job)\n                accepted_jobs = temp_set\n                \n        return len(accepted_jobs)\n\n    results = []\n    for case in test_cases:\n        result = process_online_jobs(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}