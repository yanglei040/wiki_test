{
    "hands_on_practices": [
        {
            "introduction": "我们将从资源分配中最基本的问题开始：确定所需资源的最少数量。这个练习将引导你从第一性原理出发，通过分析区间重叠来推导出这个数量。关键的要点是“深度”这一概念——即并发事件的最大数量——它不仅为所需资源提供了一个硬性的下限，而且我们将会看到，这个下限也是可以达到的。",
            "id": "3241727",
            "problem": "一家公共图书馆通过在一段时间内将副本分配给读者来管理某一本书的借阅请求。每个请求在离散时间轴上表示为一个半开区间 $[s_i, e_i)$，其中 $s_i$ 是起始时间，$e_i$ 是归还时间，该区间包含时间 $s_i$ 但不包含时间 $e_i$。在任何时刻，一个副本最多只能满足一个请求，并且一个请求在其整个持续时间内必须被分配给唯一的一个副本。图书馆希望知道需要多少个副本才能无延迟、无中断地满足所有请求。\n\n考虑以下这 $12$ 个请求：\n- $I_1 = [1, 7)$\n- $I_2 = [3, 9)$\n- $I_3 = [6, 10)$\n- $I_4 = [8, 12)$\n- $I_5 = [11, 15)$\n- $I_6 = [14, 18)$\n- $I_7 = [16, 22)$\n- $I_8 = [20, 25)$\n- $I_9 = [4, 5)$\n- $I_{10} = [5, 6)$\n- $I_{11} = [9, 14)$\n- $I_{12} = [2, 3)$\n\n仅从区间重叠和资源分配的核心定义出发，并且不引用任何已有的结论，确定最小整数 $k^{*}$，使得图书馆可以用 $k^{*}$ 个副本满足所有这 $12$ 个请求。你的推理必须证明为什么 $k^{*}$ 个副本是足够的，以及为什么更少的副本是不够的。最终答案必须是一个整数。不需要四舍五入。",
            "solution": "问题要求解出满足给定的 $12$ 个借阅请求所需的最少副本数，记为 $k^*$。每个请求是一个时间区间，时间上重叠的两个请求不能由同一个副本服务。这是一个经典的区间划分问题。最小的划分数对应于所需的最少副本数。\n\n设请求集合为 $\\mathcal{I} = \\{I_1, I_2, \\dots, I_{12}\\}$，其中每个 $I_i = [s_i, e_i)$ 是时间轴上的一个半开区间。如果两个区间 $I_i = [s_i, e_i)$ 和 $I_j = [s_j, e_j)$ 的交集非空，即 $I_i \\cap I_j \\neq \\emptyset$，则称它们重叠。这种情况当且仅当 $s_i  e_j$ 且 $s_j  e_i$ 时发生。如果两个区间重叠，它们必须被分配给不同的副本。\n\n首先，我们确定 $k^*$ 的一个下界。在任意给定的时间点 $t$，令 $D(t)$ 为该时刻处于活动状态的请求数量。如果 $s_i \\le t  e_i$，则区间 $I_i=[s_i, e_i)$ 在时间 $t$ 是活动的。在时间 $t$ 同时活动的所有请求都必须分配给不同的副本。因此，对于任何时间 $t$，所需的副本数必须至少为 $D(t)$。因此，最小副本数 $k^*$ 必须至少是 $D(t)$ 在所有时间上的最大值。设这个最大值为 $\\omega$，即区间集合的最大深度。\n$$k^* \\ge \\max_{t} D(t) = \\omega$$\n为了找到 $\\omega$，我们可以分析活动区间数量随时间的变化。活动区间的数量仅在区间的开始或结束时间点发生变化。我们可以从所有开始和结束时间构建一个事件点集合，对它们进行排序，并沿时间轴进行“扫描”，跟踪活动区间的计数。\n\n给定的区间是：\n$I_1 = [1, 7)$，$I_2 = [3, 9)$，$I_3 = [6, 10)$，$I_4 = [8, 12)$，$I_5 = [11, 15)$，$I_6 = [14, 18)$，$I_7 = [16, 22)$，$I_8 = [20, 25)$，$I_9 = [4, 5)$，$I_{10} = [5, 6)$，$I_{11} = [9, 14)$，$I_{12} = [2, 3)$。\n\n让我们检查在不同时间点的活动区间数量：\n- 对于 $t \\in [1, 2)$：只有 $I_1$ 是活动的。$D(t)=1$。\n- 对于 $t \\in [2, 3)$：$I_1, I_{12}$ 是活动的。$D(t)=2$。\n- 对于 $t \\in [3, 4)$：$I_1, I_2$ 是活动的。$D(t)=2$。\n- 对于 $t \\in [4, 5)$：$I_1, I_2, I_9$ 是活动的。$D(t)=3$。\n- 对于 $t \\in [5, 6)$：$I_1, I_2, I_{10}$ 是活动的。$D(t)=3$。\n- 对于 $t \\in [6, 7)$：$I_1, I_2, I_3$ 是活动的。$D(t)=3$。\n- 对于 $t \\in [7, 8)$：$I_2, I_3$ 是活动的。$D(t)=2$。\n- 对于 $t \\in [8, 9)$：$I_2, I_3, I_4$ 是活动的。$D(t)=3$。\n- 对于 $t \\in [9, 10)$：$I_3, I_4, I_{11}$ 是活动的。$D(t)=3$。\n- 对于 $t \\in [10, 11)$：$I_4, I_{11}$ 是活动的。$D(t)=2$。\n- 对于 $t \\in [11, 12)$：$I_4, I_{11}, I_5$ 是活动的。$D(t)=3$。\n\n观察到的同时活动区间的最大数量是 $3$。例如，在时间 $t=6.5$，$I_1=[1, 7)$、$I_2=[3, 9)$ 和 $I_3=[6, 10)$ 这三个区间都是活动的。由于这三个请求必须由三个不同的副本服务，我们为所需副本数建立了一个下界：\n$$k^* \\ge 3$$\n这证明了少于 $3$ 个副本是不够的。\n\n接下来，我们必须证明 $3$ 个副本是足够的。为此，我们提供一个将区间分配给 $3$ 个副本的构造性方法。一个标准的贪心算法可以用于此目的。该算法按以下步骤进行：\n1. 按开始时间升序对区间进行排序。\n2. 遍历排序后的区间。对于每个区间，将其分配给第一个可用的副本（即，未被分配给重叠区间的、索引最小的副本）。\n\n设副本为 $C_1, C_2, C_3$。按开始时间排序的区间列表是：\n$I_1=[1, 7)$，$I_{12}=[2, 3)$，$I_2=[3, 9)$，$I_9=[4, 5)$，$I_{10}=[5, 6)$，$I_3=[6, 10)$，$I_4=[8, 12)$，$I_{11}=[9, 14)$，$I_5=[11, 15)$，$I_6=[14, 18)$，$I_7=[16, 22)$，$I_8=[20, 25)$。\n\n我们来分配它们：\n- $I_1 = [1, 7)$：$C_1$ 空闲。分配给 $C_1$。（$C_1$ 忙碌至时间 $7$）\n- $I_{12} = [2, 3)$：$C_1$ 忙碌。$C_2$ 空闲。分配给 $C_2$。（$C_2$ 忙碌至时间 $3$）\n- $I_2 = [3, 9)$：$C_1$ 忙碌。$C_2$ 在时间 $3$ 空闲。分配给 $C_2$。（$C_2$ 忙碌至时间 $9$）\n- $I_9 = [4, 5)$：$C_1$ 忙碌。$C_2$ 忙碌。$C_3$ 空闲。分配给 $C_3$。（$C_3$ 忙碌至时间 $5$）\n- $I_{10} = [5, 6)$：$C_1$ 忙碌。$C_2$ 忙碌。$C_3$ 在时间 $5$ 空闲。分配给 $C_3$。（$C_3$ 忙碌至时间 $6$）\n- $I_3 = [6, 10)$：$C_1$ 忙碌。$C_2$ 忙碌。$C_3$ 在时间 $6$ 空闲。分配给 $C_3$。（$C_3$ 忙碌至时间 $10$）\n- $I_4 = [8, 12)$：$C_1$ 在时间 $7$ 空闲。分配给 $C_1$。（$C_1$ 忙碌至时间 $12$）\n- $I_{11} = [9, 14)$：$C_1$ 忙碌。$C_2$ 在时间 $9$ 空闲。分配给 $C_2$。（$C_2$ 忙碌至时间 $14$）\n- $I_5 = [11, 15)$：$C_1$ 忙碌。$C_2$ 忙碌。$C_3$ 在时间 $10$ 空闲。分配给 $C_3$。（$C_3$ 忙碌至时间 $15$）\n- $I_6 = [14, 18)$：$C_1$ 在时间 $12$ 空闲。分配给 $C_1$。（$C_1$ 忙碌至时间 $18$）\n- $I_7 = [16, 22)$：$C_1$ 忙碌。$C_2$ 在时间 $14$ 空闲。分配给 $C_2$。（$C_2$ 忙碌至时间 $22$）\n- $I_8 = [20, 25)$：$C_1$ 在时间 $18$ 空闲。分配给 $C_1$。（$C_1$ 忙碌至时间 $25$）\n\n所有 $12$ 个区间都已成功分配，最多使用了 $3$ 个副本。这表明 $3$ 个副本是足够的。\n$$k^* \\le 3$$\n\n为了从核心定义证明此过程的正确性，我们来考虑为什么贪心算法是最优的。设该算法使用了 $M$ 个副本。这意味着存在一个区间，比如 $I_j = [s_j, e_j)$，被分配给了第 $M$ 个副本 $C_M$。根据算法的逻辑，这只可能在分配时副本 $C_1, C_2, \\dots, C_{M-1}$ 都处于忙碌状态。这意味着对于每个副本 $C_k$（其中 $k \\in \\{1, \\dots, M-1\\}$），都有一个已经分配给它的区间 $I_{p_k} = [s_{p_k}, e_{p_k})$ 与 $I_j$ 重叠。由于区间是按其开始时间顺序处理的，我们有 $s_{p_k} \\le s_j$。为了使 $I_{p_k}$ 和 $I_j$ 重叠，必须有 $s_j  e_{p_k}$。这意味着在特定时间点 $s_j$，所有 $M-1$ 个区间 $I_{p_1}, \\dots, I_{p_{M-1}}$ 都是活动的。区间 $I_j$ 本身在时间 $s_j$ 也是活动的。因此，在时间 $s_j$，至少有 $M$ 个同时活动的区间。这意味着最大深度 $\\omega$ 必须至少为 $M$。所以，$M \\le \\omega$。因为我们已经知道 $M \\ge \\omega$，所以可以得出 $M=\\omega$。贪心算法因此使用了恰好是可能的最少数量的副本。\n\n综合我们的发现，我们有 $k^* \\ge 3$ 和 $k^* \\le 3$。同时满足这两个条件的唯一整数是 $3$。因此，所需的最少副本数是 $3$。",
            "answer": "$$\\boxed{3}$$"
        },
        {
            "introduction": "现实世界中的调度问题，通常不仅仅是任务的持续时间本身；资源在任务开始前可能需要准备，结束后需要清理。本练习引入了准备和收尾时间，展示了如何通过将原始任务区间转换为“有效”的资源占用区间来解决新问题。这个练习体现了一种强大的解题技巧：将一个新问题归约到一个已知问题。",
            "id": "3241746",
            "problem": "考虑一个有限的任务集合，其中每个任务由一个起始时间 $s_i$ 和结束时间 $f_i$（其中 $f_i  s_i$，$i \\in \\{1,2,\\dots,n\\}$）的区间表示。一个资源在执行每个任务之前必须进行准备（setup），在每个任务之后必须进行收尾（teardown）。具体来说，当一个资源被分配给任务 $i$ 时，它在区间 $[s_i - S, f_i + T]$ 内是不可用的，其中 $S \\ge 0$ 是准备时间，$T \\ge 0$ 是收尾时间。分配到同一资源的两个任务，其资源不可用区间不得重叠，即如果任务 $j$ 在同一资源上安排在任务 $i$ 之后，则必须满足 $s_j - S \\ge f_i + T$。目标是将所有任务分配给最少数量的资源，以确保没有任何资源的不可用区间发生重叠。\n\n从区间、偏序和由准备与收尾导致的资源不可用性等基本定义出发，推导出一个计算在上述约束下调度所有任务所需最少资源数量的方法。您的推导不得依赖未经证明的捷径；它应从第一性原理以及关于区间和排序的公认事实出发。然后，您必须将此方法实现为一个完整、可运行的程序，为下面的每个测试用例计算所需的最小资源数。\n\n使用以下参数值测试套件，其中每个测试用例由常量 $S$、$T$ 和一个区间列表 $\\{(s_i,f_i)\\}$ 指定：\n\n- 测试用例 1：$S=0$，$T=0$，区间 $\\{(1,3),(2,4),(3,5),(7,8)\\}$。\n- 测试用例 2：$S=1$，$T=1$，区间 $\\{(1,2),(2,3),(3,4)\\}$。\n- 测试用例 3：$S=1$，$T=2$，区间 $\\{(4,6),(9,10)\\}$。\n- 测试用例 4：$S=0$，$T=2$，区间 $\\{(1,3),(3,4),(5,6),(6,7)\\}$。\n- 测试用例 5：$S=2$，$T=0$，区间 $\\{(5,8),(10,12),(12,13),(13,15)\\}$。\n- 测试用例 6：$S=2$，$T=2$，区间 $\\{(0,1),(5,6),(8,9)\\}$。\n\n对于每个测试用例，所需的答案是最小资源数，一个整数。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，结果按上述测试用例的顺序排列，例如 $[r_1,r_2,r_3,r_4,r_5,r_6]$，其中每个 $r_k$ 是测试用例 $k$ 的整数结果。此问题不涉及物理单位或角度单位，所有输出均为整数。",
            "solution": "该问题要求找到调度一组任务所需的最小资源数，其中每个任务都有指定的开始时间、结束时间、准备时间和收尾时间。我们将通过首先形式化约束条件，然后证明该问题等价于经典的区间划分问题来解决此问题。后者的解决方案将从第一性原理推导得出。\n\n设任务集合由 $i \\in \\{1, 2, \\dots, n\\}$ 索引。每个任务 $i$ 由一个时间区间 $(s_i, f_i)$ 定义，其中 $s_i$ 是开始时间，$f_i$ 是结束时间，且 $f_i  s_i$。任何任务开始前都需要一个恒定的准备时间 $S \\ge 0$，任何任务结束后都需要一个恒定的收尾时间 $T \\ge 0$。这意味着分配给任务 $i$ 的资源在闭区间 $[s_i - S, f_i + T]$ 内被占用且不可用。\n\n在同一资源上调度两个任务 $i$ 和 $j$ 的核心约束是，它们的资源不可用时段不得冲突。问题中对此的陈述是：如果任务 $j$ 被安排在任务 $i$ 之后，则必须满足 $s_j - S \\ge f_i + T$。更一般地说，如果要将任何两个不同的任务 $i$ 和 $j$ 分配给同一资源，其中一个必须在另一个开始之前完成。这意味着要么任务 $i$ 在任务 $j$ 开始前完成，要么任务 $j$ 在任务 $i$ 开始前完成。\n- 如果任务 $i$ 先执行，资源在时间 $f_i + T$ 变为可用。然后任务 $j$ 可以开始，其准备工作在时间 $s_j - S$ 开始。条件是 $s_j - S \\ge f_i + T$。\n- 如果任务 $j$ 先执行，条件对称地为 $s_i - S \\ge f_j + T$。\n\n因此，两个任务 $i$ 和 $j$ 是**兼容的**（可以放在同一资源上）当且仅当 $(s_j - S \\ge f_i + T) \\lor (s_i - S \\ge f_j + T)$。\n\n反之，任务 $i$ 和 $j$ 是**不兼容的**（它们冲突并需要不同的资源），如果它们不兼容。这发生在兼容条件的否定为真时：\n$\\neg((s_j - S \\ge f_i + T) \\lor (s_i - S \\ge f_j + T))$\n使用德摩根定律，这等价于：\n$(\\neg(s_j - S \\ge f_i + T)) \\land (\\neg(s_i - S \\ge f_j + T))$\n化简后得到：\n$(s_j - S  f_i + T) \\land (s_i - S  f_j + T)$\n\n为了简化此表达式，我们为每个任务 $i$ 定义一个**有效区间**，即 $I'_i = (s'_i, f'_i) = (s_i - S, f_i + T)$。请注意，我们使用开区间，因为冲突条件中的严格不等式暗示了这一点。现在，任务 $i$ 和 $j$ 之间的冲突条件可以使用它们的有效区间端点 $s'_i, f'_i, s'_j, f'_j$ 重写为：\n$(s'_j  f'_i) \\land (s'_i  f'_j)$\n这正是两个开区间 $I'_i$ 和 $I'_j$ 具有非空交集（即它们重叠）的精确数学定义。\n\n问题现在已转化为：给定一组开区间 $\\{I'_1, I'_2, \\dots, I'_n\\}$，将它们划分为最少数目的子集，使得任何给定子集中的任意两个区间都不重叠。这就是**区间划分问题**。\n\n区间划分问题的解是该区间集合的**深度**。深度，记为 $d$，是在任何单一时间点上相互重叠的最大区间数。形式上，\n$$d = \\max_{t \\in \\mathbb{R}} |\\{i \\mid t \\in I'_i\\}|$$\n我们必须从第一性原理证明所需的最小资源数 $k_{\\min}$ 等于 $d$。\n\n**下界：** $k_{\\min} \\ge d$。\n根据深度的定义，存在一个时间点 $t_0$，在该点上 $d$ 个不同的有效区间 $I'_{i_1}, I'_{i_2}, \\dots, I'_{i_d}$ 全部重叠。这意味着对于任务对 $j, l \\in \\{i_1, \\dots, i_d\\}$ 中的任意两个任务，它们的有效区间 $I'_j$ 和 $I'_l$ 都有非空交集。因此，这 $d$ 个任务都互相不兼容。所以，这 $d$ 个任务中的每一个都必须分配给不同的资源。这直接意味着至少需要 $d$ 个资源。因此，$k_{\\min} \\ge d$。\n\n**上界（构造性证明）：** $k_{\\min} \\le d$。\n我们可以通过提供一个贪心算法来证明 $d$ 个资源总是足够的，该算法使用最多 $d$ 个资源调度所有任务。计算 $d$ 以及隐式分配资源的最直接方法是**扫描线算法**。\n\n1.  对于每个有效区间 $I'_i = (s'_i, f'_i)$，创建两个事件：一个开始事件 $(s'_i, +1)$ 和一个结束事件 $(f'_i, -1)$。\n2.  将所有 $2n$ 个事件收集到一个列表中。\n3.  主要按事件的时间坐标对列表进行排序。对于在同一时间发生的事件，打破平局的规则至关重要。如果一个区间结束的时间恰好是另一个区间开始的时间（例如 $(1,3)$ 和 $(3,5)$），它们不被视为重叠。一个资源可以从第一个任务中释放出来，并立即用于第二个任务。为了正确地模拟这一点，结束事件 $(-1)$ 必须在同一时间坐标的开始事件 $(+1)$ 之前处理。因此，事件 $(t, \\text{type})$ 的次要排序键应为 `type`。\n4.  初始化一个计数器 `current_overlap = 0` 用于记录当前重叠的区间数，以及一个变量 `max_overlap = 0` 用于追踪至今发现的最大重叠数。\n5.  遍历排序后的事件列表。对于每个事件 $(t, \\text{type})$：\n    a. 更新当前重叠数：`current_overlap = current_overlap + type`。\n    b. 更新最大重叠数：`max_overlap = max(max_overlap, current_overlap)`。\n\n处理完所有事件后，`max_overlap` 将持有值 $d$。这个扫描线过程模拟了将一个时间点从 $-\\infty$ 移动到 $+\\infty$，并计算在每个时刻有多少个区间是“活动的”。`current_overlap` 在一个区间开始时增加 $1$，在结束时减少 $1$。它所达到的最大值根据定义就是深度 $d$。\n\n该算法不仅计算了 $d$，还为充分性提供了一个构造性论证。设想一种贪心分配策略，该策略按任务的有效开始时间顺序处理任务。当考虑一个任务时，它会将其分配给任何已变得可用的资源（即，该资源上的前一个任务的有效结束时间小于或等于当前任务的有效开始时间）。如果没有可用的资源，则分配一个新资源。这种贪心算法分配的资源数绝不会超过 $d$。如果它要为任务 $T_i$ 分配第 $(d+1)$ 个资源，那将意味着在开始时间 $s'_i$ 时，已有 $d$ 个其他任务处于活动状态并占用了前 $d$ 个资源。这将意味着有 $d+1$ 个区间（任务 $T_i$ 和其他 $d$ 个任务）同时处于活动状态，这与深度为 $d$ 的事实相矛盾。\n\n因此，$d$ 个资源是足够的。既然我们已经证明了 $k_{\\min} \\ge d$ 和 $k_{\\min} \\le d$，那么必然有 $k_{\\min} = d$。所需的最少资源数就是有效区间集合的深度，而这个深度可以使用所述的扫描线算法高效地计算出来。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run the solver for each,\n    and print the results in the specified format.\n    \"\"\"\n    # Each test case is a tuple: (S, T, list_of_intervals)\n    # Each interval is a tuple: (start_time, finish_time)\n    test_cases = [\n        (0, 0, [(1, 3), (2, 4), (3, 5), (7, 8)]),\n        (1, 1, [(1, 2), (2, 3), (3, 4)]),\n        (1, 2, [(4, 6), (9, 10)]),\n        (0, 2, [(1, 3), (3, 4), (5, 6), (6, 7)]),\n        (2, 0, [(5, 8), (10, 12), (12, 13), (13, 15)]),\n        (2, 2, [(0, 1), (5, 6), (8, 9)]),\n    ]\n\n    results = []\n    for S, T, intervals in test_cases:\n        result = compute_min_resources(S, T, intervals)\n        results.append(result)\n\n    # Format the output as a comma-separated list in square brackets\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_min_resources(S, T, intervals):\n    \"\"\"\n    Computes the minimum number of resources required for a given set of tasks.\n    This is equivalent to finding the depth of the set of effective intervals.\n\n    The method used is the sweep-line algorithm.\n\n    Args:\n        S (int): The setup time, S = 0.\n        T (int): The teardown time, T = 0.\n        intervals (list of tuples): A list of (start_time, finish_time) for each task.\n\n    Returns:\n        int: The minimum number of resources required.\n    \"\"\"\n    if not intervals:\n        return 0\n\n    events = []\n    # Define constants for event types to aid sorting and readability\n    START_EVENT = 1\n    FINISH_EVENT = -1\n\n    for s_i, f_i in intervals:\n        # Calculate the effective interval [s_i - S, f_i + T].\n        # The conflict condition s'_j  f'_i and s'_i  f'_j corresponds to\n        # overlapping open intervals (s'_i, f'_i).\n        s_prime = s_i - S\n        f_prime = f_i + T\n        \n        # Add a start event\n        events.append((s_prime, START_EVENT))\n        # Add a finish event\n        events.append((f_prime, FINISH_EVENT))\n\n    # Sort events:\n    # 1. Primarily by time.\n    # 2. Secondarily by event type. A finish event (-1) must come before a\n    #    start event (1) at the same time to correctly handle intervals that\n    #    touch at endpoints, like (1,3) and (3,5). The natural sort order of\n    #    the types (-1  1) achieves this.\n    events.sort()\n\n    max_resources = 0\n    current_resources = 0\n    for time, event_type in events:\n        current_resources += event_type\n        if current_resources  max_resources:\n            max_resources = current_resources\n            \n    return max_resources\n\n# Execute the main function\nsolve()\n```"
        },
        {
            "introduction": "任务之间很少是完全独立的；它们通常存在依赖关系，形成一个工作流。这个高级练习将区间划分问题与图论相结合，要求你首先使用拓扑排序解决任务的先后次序约束，以确定每个任务的实际执行区间。然后，你才能应用划分算法来找到所需的最小资源数，这说明了区间划分是如何作为复杂多阶段调度系统中的一个关键组成部分的。",
            "id": "3241721",
            "problem": "考虑一个有限的任务集合，每个任务由一个包含计划开始时间和计划结束时间的区间表示。设任务由整数索引，任务 $i$ 的计划区间表示为 $[s_i, e_i)$，其中 $s_i$ 是计划开始时间，$e_i$ 是计划结束时间。任务 $i$ 的持续时间为 $d_i = e_i - s_i$，且所有持续时间都满足 $d_i  0$。这些区间被视为半开区间，即 $[s_i, e_i)$ 包括 $s_i$ 但不包括 $e_i$，因此在一个时间点 $t$ 结束的任务与在时间点 $t$ 开始的任务不重叠。\n\n任务之间存在有向优先关系，形成一个有向无环图（DAG），由一组有向边 $p \\rightarrow i$ 定义，表示任务 $i$ 必须在任务 $p$ 完成后才能开始。设 $\\mathrm{pred}(i)$ 为任务 $i$ 的前驱任务集合。\n\n调度按以下规则构建：每个任务 $i$ 必须在其计划开始时间和优先约束所允许的最早时间开始。实际开始时间 $a_i$ 和实际完成时间 $f_i$ 定义如下：\n$$\na_i = \\max\\left(s_i,\\ \\max_{p \\in \\mathrm{pred}(i)} f_p\\right)\\quad\\text{约定空集上的内部最大值等于 } -\\infty\\text{，因此若 }\\mathrm{pred}(i)=\\varnothing\\text{，则 }a_i = s_i，\n$$\n且\n$$\nf_i = a_i + d_i.\n$$\n当优先关系图是无环图时，此规则产生一个唯一的最早可行调度。\n\n一旦确定了实际区间 $[a_i, f_i)$，区间划分问题要求的是将所有任务分配到不相交的轨道（资源）上所需的最小轨道数，以确保分配到同一轨道的任意两个任务在时间上不重叠。对于一个固定的区间集合，这个最小值等于任何时刻重叠区间的最大数量。\n\n您的任务是编写一个完整且可运行的程序，为每个提供的测试用例执行以下步骤：\n- 验证优先关系是否形成一个有向无环图（DAG）。如果不是，则为该测试用例输出整数 $-1$。\n- 否则，使用上述规则计算最早可行的实际区间 $[a_i, f_i)$。\n- 计算划分这些实际区间所需的最小轨道数，以确保同一轨道上的任意两个区间不重叠。\n\n程序必须生成一行输出，其中包含所有测试用例的结果，格式为一个逗号分隔的列表，并用方括号括起来。每个结果都必须是一个整数。\n\n基本假设和定义：\n- 优先约束定义了一个偏序；在有向无环图（DAG）中，存在拓扑排序。\n- 对于一个固定的区间族，所需的最小轨道数等于任何时刻重叠区间的最大数量。\n\n测试套件和参数规范：\n使用以下测试用例，其索引、计划开始时间、计划结束时间和前驱列表已指定。所有时间都是实数，但在以下测试中它们是整数。\n\n- 测试用例 1（具有优先关系引起的延迟的通用 DAG）：\n  - 索引：$0, 1, 2, 3, 4$。\n  - 计划开始时间：$[0, 1, 2, 3, 0]$。\n  - 计划结束时间：$[3, 4, 5, 7, 2]$。\n  - 前驱：$[\\varnothing, [0], [0], [1, 2], \\varnothing]$。\n  - 输出：最小轨道数（整数）。\n\n- 测试用例 2（无依赖关系，区间重叠）：\n  - 索引：$0, 1, 2$。\n  - 计划开始时间：$[0, 1, 2]$。\n  - 计划结束时间：$[2, 3, 4]$。\n  - 前驱：$[\\varnothing, \\varnothing, \\varnothing]$。\n  - 输出：最小轨道数（整数）。\n\n- 测试用例 3（依赖关系链，强制顺序执行）：\n  - 索引：$0, 1, 2$。\n  - 计划开始时间：$[0, 0, 0]$。\n  - 计划结束时间：$[3, 3, 3]$。\n  - 前驱：$[\\varnothing, [0], [1]]$。\n  - 输出：最小轨道数（整数）。\n\n- 测试用例 4（分支依赖关系，产生高重叠窗口）：\n  - 索引：$0, 1, 2, 3, 4$。\n  - 计划开始时间：$[0, 0, 0, 0, 1]$。\n  - 计划结束时间：$[1, 2, 2, 2, 2]$。\n  - 前驱：$[\\varnothing, [0], [0], [0], \\varnothing]$。\n  - 输出：最小轨道数（整数）。\n\n- 测试用例 5（因环路而无效；必须检测到）：\n  - 索引：$0, 1$。\n  - 计划开始时间：$[0, 0]$。\n  - 计划结束时间：$[1, 1]$。\n  - 前驱：$[[1], [0]]$。\n  - 输出：整数 $-1$。\n\n最终输出格式要求：\n您的程序应生成一行输出，其中包含结果，格式为逗号分隔的列表并用方括号括起来（例如，\"[r_1,r_2,r_3,r_4,r_5]\"），其中每个 $r_i$ 是按上述顺序列出的测试用例 $i$ 的整数结果。",
            "solution": "所提出的问题是一个复合任务，整合了图论、调度算法和计算几何的原理。它可以系统地分解为三个不同的顺序阶段：1) 验证优先约束是否为有向无环图（DAG），2) 基于这些约束计算最早可行调度，以及 3) 确定执行该调度而无重叠所需的最小资源（轨道）数量。\n\n一个有效的解决方案必须正确实现每个阶段。我们现在将详细说明每个阶段的正式方法。\n\n**阶段 1：优先关系图验证和拓扑排序**\n\n任务集合及其优先约束 $p \\rightarrow i$ 形成一个有向图 $G = (V, E)$，其中 $V$ 是任务集合，$E$ 是优先关系边的集合。用于计算实际开始时间的规则，\n$$\na_i = \\max\\left(s_i,\\ \\max_{p \\in \\mathrm{pred}(i)} f_p\\right),\n$$\n仅当图 $G$ 是无环的时才有明确定义。一个环路，例如 $i_1 \\rightarrow i_2 \\rightarrow \\dots \\rightarrow i_k \\rightarrow i_1$，将意味着任务 $i_1$ 的开始时间依赖于其自身的完成，这是一个逻辑上的不可能，会导致调度无法定义。因此，第一步是验证 $G$ 是否为 DAG。\n\n此验证使用深度优先搜索（DFS）遍历来执行。我们使用三个集合来维护每个节点的状态：\n1.  一个 `white` 集合，包含所有未访问的节点。\n2.  一个 `gray` 集合，包含当前正在访问的节点（即，在 DFS 当前递归堆栈中的节点）。\n3.  一个 `black` 集合，包含已完全探索的节点（即，DFS 已访问该节点及其所有后代）。\n\n算法通过从 `white` 集合中的每个节点启动 DFS 来进行。当访问节点 $u$ 时，它会从 `white` 集合移动到 `gray` 集合。对于 $u$ 的每个邻居 $v$，我们检查其状态。如果 $v$ 在 `gray` 集合中，则检测到一条反向边，这意味着存在一个环路。在这种情况下，该图不是 DAG，该问题实例无效，应返回结果 $-1$。如果所有节点的 DFS 完成而没有检测到反向边，则该图是 DAG。\n\n此 DFS 遍历的一个有价值的副产品是图节点的拓扑排序。拓扑排序是节点的一种线性排序，对于从节点 $u$ 到节点 $v$ 的每条有向边， $u$ 都在排序中位于 $v$ 之前。这种排序存在的充要条件是图是 DAG。通过按节点从 `gray` 集移动到 `black` 集的顺序记录节点，然后反转此列表，我们便获得了一个有效的拓扑排序。这个排序对于下一阶段至关重要。\n\n**阶段 2：最早可行调度计算**\n\n鉴于优先关系图是 DAG，我们可以为每个任务 $i$ 计算实际开始时间 $a_i$ 和完成时间 $f_i$。该计算依赖于在阶段 1 中获得的拓扑排序。通过按拓扑顺序处理任务，我们保证在计算任务 $i$ 的开始时间 $a_i$ 时，其所有前驱任务 $p \\in \\mathrm{pred}(i)$ 的实际完成时间 $f_p$ 都已经确定。\n\n过程如下：\n为所有任务的实际完成时间 $f$ 初始化一个数组（例如，初始化为 $-\\infty$）。\n按照拓扑排序遍历每个任务 $i$：\n1.  确定最晚完成的前驱任务的完成时间：$f_{\\max\\_pred} = \\max_{p \\in \\mathrm{pred}(i)} f_p$。按照约定，如果前驱集合 $\\mathrm{pred}(i)$ 为空，此最大值为 $-\\infty$。\n2.  通过取任务的计划开始时间 $s_i$ 和最晚前驱完成时间的最大值来计算实际开始时间 $a_i$：$$a_i = \\max(s_i, f_{\\max\\_pred})$$\n3.  通过将任务的持续时间 $d_i = e_i - s_i$ 加到其实际开始时间上来计算实际完成时间 $f_i$：$$f_i = a_i + d_i$$\n\n遍历所有任务后，我们将确定实际执行区间集合 $\\{[a_i, f_i) | i \\in V\\}$。\n\n**阶段 3：通过最大重叠计算实现最小轨道分配**\n\n最后阶段是为计算出的实际区间集合 $\\{[a_i, f_i)\\}$ 解决区间划分问题。目标是将每个任务（区间）分配到一个资源轨道上，使得同一轨道上的任意两个任务在时间上不重叠，并最小化所使用的轨道总数。该领域的一个基本结论指出，所需的最小轨道数等于区间集合的最大深度，即在任何单一时间点上重叠区间的最大数量。\n\n我们可以使用扫描线算法高效地计算这个最大重叠数。该算法将区间的起点和终点视为沿时间轴发生的“事件”。\n1.  对于每个区间 $[a_i, f_i)$，创建两个事件点：一个开始事件 $(a_i, +1)$ 和一个结束事件 $(f_i, -1)$。值 $+1$ 表示一个区间的开始，增加重叠计数；而 $-1$ 表示结束，减少重叠计数。\n2.  将所有事件点收集到一个列表中。\n3.  对该事件列表进行排序。主排序键是事件的时间。次排序键是事件类型。因为区间是半开的 $[a_i, f_i)$，在时间 $t$ 结束的任务不与在 $t$ 开始的任务重叠。为了正确地对此建模，时间 $t$ 处的结束事件 $(-1)$ 必须在同一时间 $t$ 处的开始事件 $(+1)$ 之前处理。因此，我们按时间的升序对事件进行排序，对于时间上的平局，按事件类型的升序排序（即 $-1$ 在 $+1$ 之前）。\n4.  初始化一个用于记录当前重叠区间数的计数器 `current_overlap` 为 $0$，以及一个用于记录迄今为止发现的最大重叠数的变量 `max_overlap` 为 $0$。\n5.  遍历排序后的事件列表。对于每个事件 $(t, \\text{type})$：\n    a. 更新重叠计数器：`current_overlap` = `current_overlap` + `type`。\n    b. 更新最大重叠数：`max_overlap` = $\\max(\\text{`max_overlap`}, \\text{`current_overlap`})$。\n\n处理完所有事件后，`max_overlap` 将持有任何时间点上重叠区间的最大数量，即所需的最小轨道数。这个整数值就是给定测试用例的结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to process all test cases and print results.\n    \"\"\"\n    # Test cases defined in the problem statement.\n    # Each case is a tuple: (starts, ends, predecessors)\n    # The number of tasks is inferred from the length of the starts list.\n    test_cases = [\n        # Test case 1\n        (\n            np.array([0, 1, 2, 3, 0]),\n            np.array([3, 4, 5, 7, 2]),\n            {0: [], 1: [0], 2: [0], 3: [1, 2], 4: []}\n        ),\n        # Test case 2\n        (\n            np.array([0, 1, 2]),\n            np.array([2, 3, 4]),\n            {0: [], 1: [], 2: []}\n        ),\n        # Test case 3\n        (\n            np.array([0, 0, 0]),\n            np.array([3, 3, 3]),\n            {0: [], 1: [0], 2: [1]}\n        ),\n        # Test case 4\n        (\n            np.array([0, 0, 0, 0, 1]),\n            np.array([1, 2, 2, 2, 2]),\n            {0: [], 1: [0], 2: [0], 3: [0], 4: []}\n        ),\n        # Test case 5\n        (\n            np.array([0, 0]),\n            np.array([1, 1]),\n            {0: [1], 1: [0]}\n        ),\n    ]\n\n    results = []\n    for s, e, preds in test_cases:\n        result = compute_tracks(s, e, preds)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_tracks(s_planned, e_planned, predecessors):\n    \"\"\"\n    Computes the minimum number of tracks for a single test case.\n    \n    This function implements the three-stage process:\n    1. DAG validation and topological sorting.\n    2. Earliest-feasible schedule calculation.\n    3. Maximum overlap calculation using a sweep-line algorithm.\n    \n    Returns -1 if the precedence graph contains a cycle.\n    \"\"\"\n    num_tasks = len(s_planned)\n    \n    # --- Stage 1: DAG Validation and Topological Sort ---\n    \n    # Build a forward adjacency list from the predecessor list\n    adj = {i: [] for i in range(num_tasks)}\n    for i, preds in predecessors.items():\n        for p in preds:\n            adj[p].append(i)\n\n    # Sets for DFS-based cycle detection\n    # white_set (unvisited): nodes not in visiting_set or visited_set\n    # gray_set (visiting): nodes in the current recursion stack\n    # black_set (visited): nodes fully explored\n    visiting_set = set()\n    visited_set = set()\n    topo_order = []\n    \n    has_cycle = [False] # Use a list to make it mutable inside the nested function\n\n    def dfs(u):\n        if has_cycle[0]:\n            return\n\n        visiting_set.add(u)\n\n        for v in adj.get(u, []):\n            if v in visiting_set:\n                has_cycle[0] = True\n                return\n            if v not in visited_set:\n                dfs(v)\n        \n        visiting_set.remove(u)\n        visited_set.add(u)\n        topo_order.append(u)\n\n    for i in range(num_tasks):\n        if i not in visited_set:\n            dfs(i)\n\n    if has_cycle[0]:\n        return -1\n    \n    topo_order.reverse() # The reverse of post-order traversal is a topological sort\n\n    # --- Stage 2: Earliest-Feasible Schedule Calculation ---\n    \n    durations = e_planned - s_planned\n    f_actual = np.full(num_tasks, -np.inf, dtype=float)\n    a_actual = np.zeros(num_tasks, dtype=float)\n\n    for i in topo_order:\n        max_pred_finish_time = -np.inf\n        if predecessors[i]:\n            pred_finish_times = [f_actual[p] for p in predecessors[i]]\n            max_pred_finish_time = max(pred_finish_times)\n        \n        a_actual[i] = max(s_planned[i], max_pred_finish_time)\n        f_actual[i] = a_actual[i] + durations[i]\n\n    # --- Stage 3: Minimal Track Allocation (Max Overlap) ---\n    \n    events = []\n    for i in range(num_tasks):\n        events.append((a_actual[i], 1))  # Start of an interval\n        events.append((f_actual[i], -1)) # End of an interval\n\n    # Sort events: primary key is time, secondary key is type (-1 before 1).\n    # This correctly handles intervals [s, e) where an interval ending at t\n    # does not overlap with one starting at t.\n    events.sort(key=lambda x: (x[0], x[1]))\n\n    max_overlap = 0\n    current_overlap = 0\n    for time, type in events:\n        current_overlap += type\n        if current_overlap  max_overlap:\n            max_overlap = current_overlap\n            \n    return max_overlap\n\nsolve()\n\n```"
        }
    ]
}