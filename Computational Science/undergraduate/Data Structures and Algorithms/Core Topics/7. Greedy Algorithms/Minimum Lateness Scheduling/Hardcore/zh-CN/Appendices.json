{
    "hands_on_practices": [
        {
            "introduction": "理论联系实际是掌握任何算法的关键。这个练习不仅要求你应用最早截止日期优先（EDD）规则来解决一个经典的调度问题，还挑战你从第一性原理出发，通过交换论证来证明其最优性。通过完成这项任务，你将为理解更复杂的调度场景奠定坚实的理论基础。",
            "id": "3252772",
            "problem": "在一个模拟密室逃脱的单资源环境中，一位密室逃脱主持人必须一次只向一个团队提供一个提示。共有$6$个提示，每个提示都需要一个已知的不可抢占的持续时间$t_i$，并有一个理想的完成截止时间$d_i$，以使团队能按计划进行。主持人从时间$0$开始，并且必须连续不断地提供提示，中间没有空闲时间。目标是，在$6$个提示的所有可能排序中，确定最大延迟的最小可能值，最大延迟定义为 $L_{\\max} = \\max_{i} \\left(C_i - d_i\\right)$，其中 $C_i$ 是所选序列中提示 $i$ 的完成时间。仅使用完成时间和延迟的核心定义，并通过相邻提示的成对交换，从基本原理出发，来证明您所选排序的最优性。\n\n这些提示是：\n- 提示 $1$：$t_1 = 3$， $d_1 = 4$。\n- 提示 $2$：$t_2 = 2$， $d_2 = 7$。\n- 提示 $3$：$t_3 = 5$， $d_3 = 9$。\n- 提示 $4$：$t_4 = 4$， $d_4 = 6$。\n- 提示 $5$：$t_5 = 2$， $d_5 = 3$。\n- 提示 $6$：$t_6 = 6$， $d_6 = 15$。\n\n将可实现的最小$L_{\\max}$值以单个实数形式表示。不需要单位。如果进行任何中间计算，请保持精确；最终答案无需四舍五入。",
            "solution": "问题要求，对于从时间 $t=0$ 开始由单一资源提供的一组$6$个不可抢占的提示，求出最大延迟$L_{\\max}$的最小可能值。提示必须连续提供，意味着没有空闲时间。\n\n首先，我们将问题形式化。设提示集为 $\\mathcal{J} = \\{1, 2, 3, 4, 5, 6\\}$。每个提示 $i \\in \\mathcal{J}$ 都有一个处理时间 $t_i  0$ 和一个截止日期 $d_i$。一个调度是 $\\mathcal{J}$ 中提示的一个排列 $\\sigma = (\\sigma(1), \\sigma(2), \\dots, \\sigma(6))$。第一个提示 $\\sigma(1)$ 的开始时间是 $S_{\\sigma(1)} = 0$。对于任何后续的提示 $\\sigma(k)$（其中 $k  1$），其开始时间是前一个提示的完成时间，即 $S_{\\sigma(k)} = C_{\\sigma(k-1)}$。提示 $\\sigma(k)$ 的完成时间是 $C_{\\sigma(k)} = S_{\\sigma(k)} + t_{\\sigma(k)}$。由于没有空闲时间，序列中位置 $k$ 的提示的完成时间是直到并包括该位置的所有提示的处理时间之和：\n$$C_{\\sigma(k)} = \\sum_{j=1}^{k} t_{\\sigma(j)}$$\n提示 $i$ 的延迟定义为 $L_i = C_i - d_i$。目标是找到一个调度 $\\sigma$，使得最大延迟 $L_{\\max}(\\sigma) = \\max_{i \\in \\mathcal{J}} (C_i - d_i)$ 最小化。\n\n问题规定，必须使用成对交换论证从基本原理出发来证明所选排序的最优性。该论证确立了最早截止日期（EDD）调度规则的最优性，该规则指出，按截止日期的非递减顺序对提示进行排序可以最小化最大延迟。\n\n我们来证明EDD规则的最优性。考虑一个非EDD调度的任意调度 $S$。如果 $S$ 不是EDD调度，那么必然存在至少一对提示，比如提示 $i$ 和提示 $j$，它们被安排为相邻的，且 $i$ 紧挨在 $j$ 之前，但它们的截止日期满足 $d_i  d_j$。设此调度形式为 $S = (\\pi_1, i, j, \\pi_2)$，其中 $\\pi_1$ 和 $\\pi_2$ 是其他提示的（可能为空的）子序列。\n\n设 $T$ 为前缀序列 $\\pi_1$ 中最后一个提示的完成时间。如果 $\\pi_1$ 为空，则 $T=0$。在调度 $S$ 中，提示 $i$ 和 $j$ 的完成时间为：\n$$C_i = T + t_i$$\n$$C_j = T + t_i + t_j$$\n它们各自的延迟为：\n$$L_i = T + t_i - d_i$$\n$$L_j = T + t_i + t_j - d_j$$\n这对提示中的最大延迟是 $\\max(L_i, L_j)$。\n\n现在，我们通过交换 $i$ 和 $j$ 的顺序来创建一个新的调度 $S'$：$S' = (\\pi_1, j, i, \\pi_2)$。$\\pi_1$ 中所有提示的完成时间保持不变。处理提示对 $(i, j)$ 的总时间是 $t_i + t_j$，这与处理提示对 $(j, i)$ 的时间相同。因此，后缀序列 $\\pi_2$ 中所有提示的开始时间和完成时间也保持不变。这样，$\\pi_1$ 或 $\\pi_2$ 中任何提示的延迟都不受此次交换的影响。我们只需要分析提示 $i$ 和 $j$ 的最大延迟变化。\n\n在调度 $S'$ 中，新的完成时间 $C'_j$ 和 $C'_i$ 是：\n$$C'_j = T + t_j$$\n$$C'_i = T + t_j + t_i$$\n新的延迟 $L'_j$ 和 $L'_i$ 是：\n$$L'_j = T + t_j - d_j$$\n$$L'_i = T + t_j + t_i - d_i$$\n这对提示新的最大延迟是 $\\max(L'_j, L'_i)$。\n\n我们要证明 $\\max(L'_j, L'_i) \\le \\max(L_i, L_j)$。\n我们来分析新旧延迟值的关系。\n比较 $L'_i$ 和 $L_j$：\n$L'_i = T + t_j + t_i - d_i$\n$L_j = T + t_i + t_j - d_j$\n因为我们假设存在逆序，$d_i  d_j$，这意味着 $-d_i  -d_j$。因此，$L'_i  L_j$。\n\n现在，我们来比较 $L'_j$ 和 $L_j$：\n$L'_j = T + t_j - d_j$\n$L_j = (T + t_j - d_j) + t_i$\n由于所有处理时间都是正数（$t_i  0$），很明显 $L'_j  L_j$。\n\n我们已经证明，两个新的延迟 $L'_i$ 和 $L'_j$ 都严格小于原来的延迟 $L_j$。\n$$L'_i  L_j \\quad \\text{and} \\quad L'_j  L_j$$\n这意味着新延迟的最大值也必须严格小于 $L_j$：\n$$\\max(L'_j, L'_i)  L_j$$\n根据最大函数的定义，$L_j \\le \\max(L_i, L_j)$，因此可得：\n$$\\max(L'_j, L'_i)  L_j \\le \\max(L_i, L_j)$$\n因此，将满足 $d_id_j$ 的相邻对 $(i,j)$ 交换为 $(j,i)$ 不会增加调度的最大延迟。实际上，它只能减小最大延迟或使其保持不变（如果最大延迟是由 $\\pi_1$ 或 $\\pi_2$ 中的其他提示决定的）。通过重复应用此类交换，任何调度都可以转换为 EDD 调度。每一步都不会增加最大延迟。因此，EDD 调度的最大延迟必须小于或等于任何其他调度的最大延迟。它是一个最优调度。\n\n我们现在将 EDD 规则应用于给定的数据：\n- 提示 $1$：$t_1 = 3$， $d_1 = 4$。\n- 提示 $2$：$t_2 = 2$， $d_2 = 7$。\n- 提示 $3$：$t_3 = 5$， $d_3 = 9$。\n- 提示 $4$：$t_4 = 4$， $d_4 = 6$。\n- 提示 $5$：$t_5 = 2$， $d_5 = 3$。\n- 提示 $6$：$t_6 = 6$， $d_6 = 15$。\n\n将这些提示按其截止日期（$d_i$）的非递减顺序排序，得到以下序列：\n$1$. 提示 $5$ ($d_5 = 3$)\n$2$. 提示 $1$ ($d_1 = 4$)\n$3$. 提示 $4$ ($d_4 = 6$)\n$4$. 提示 $2$ ($d_2 = 7$)\n$5$. 提示 $3$ ($d_3 = 9$)\n$6$. 提示 $6$ ($d_6 = 15$)\n\n最优调度是序列 $(5, 1, 4, 2, 3, 6)$。我们现在计算此序列中每个提示的完成时间和延迟。开始时间为 $S=0$。\n\n- **提示 5**：\n  - $t_5 = 2$， $d_5 = 3$。\n  - 开始时间 $S_5 = 0$。\n  - 完成时间 $C_5 = 0 + 2 = 2$。\n  - 延迟 $L_5 = C_5 - d_5 = 2 - 3 = -1$。\n\n- **提示 1**：\n  - $t_1 = 3$， $d_1 = 4$。\n  - 开始时间 $S_1 = C_5 = 2$。\n  - 完成时间 $C_1 = 2 + 3 = 5$。\n  - 延迟 $L_1 = C_1 - d_1 = 5 - 4 = 1$。\n\n- **提示 4**：\n  - $t_4 = 4$， $d_4 = 6$。\n  - 开始时间 $S_4 = C_1 = 5$。\n  - 完成时间 $C_4 = 5 + 4 = 9$。\n  - 延迟 $L_4 = C_4 - d_4 = 9 - 6 = 3$。\n\n- **提示 2**：\n  - $t_2 = 2$， $d_2 = 7$。\n  - 开始时间 $S_2 = C_4 = 9$。\n  - 完成时间 $C_2 = 9 + 2 = 11$。\n  - 延迟 $L_2 = C_2 - d_2 = 11 - 7 = 4$。\n\n- **提示 3**：\n  - $t_3 = 5$， $d_3 = 9$。\n  - 开始时间 $S_3 = C_2 = 11$。\n  - 完成时间 $C_3 = 11 + 5 = 16$。\n  - 延迟 $L_3 = C_3 - d_3 = 16 - 9 = 7$。\n\n- **提示 6**：\n  - $t_6 = 6$， $d_6 = 15$。\n  - 开始时间 $S_6 = C_3 = 16$。\n  - 完成时间 $C_6 = 16 + 6 = 22$。\n  - 延迟 $L_6 = C_6 - d_6 = 22 - 15 = 7$。\n\n最优调度中各提示的延迟值为 $\\{-1, 1, 3, 4, 7, 7\\}$。最大延迟是这些值的最大值：\n$$L_{\\max} = \\max(-1, 1, 3, 4, 7, 7) = 7$$\n因此，最大延迟的最小可能值为 $7$。",
            "answer": "$$\\boxed{7}$$"
        },
        {
            "introduction": "真实世界的调度问题很少是静态的；任务在不同时间到达，并且高优先级任务可能需要抢占当前任务。本练习将你带入这样一个动态环境，要求你设计并实现一个抢占式的最早截止日期优先（EDF）调度器来处理带到达时间的任务。这项实践将深化你对调度策略如何适应实时变化的理解。",
            "id": "3252827",
            "problem": "给定一个单机调度问题，其中每个作业必须在一台任何时刻最多只能处理一个作业的单机上进行非抢占式或抢占式处理。每个作业有三个属性：发布时间 $r_i$、处理时间 $p_i$ 和截止时间 $d_i$。机器持续可用，作业仅在其发布时间或之后才可被处理，作业可以被抢占并在之后无惩罚地恢复，并且所有参数都是整数。作业 $i$ 的完成时间是 $C_i$，其延迟定义为 $L_i = C_i - d_i$。目标是最小化最大延迟 $L_{\\max} = \\max_i L_i$。所有时间都是无单位的整数。\n\n从完成时间和延迟的基本定义出发，设计一个基于第一性原理的算法，该算法在每个时刻决定运行哪个可用作业，以最小化 $L_{\\max}$。你的算法必须对于允许抢占的任意整数输入 $\\{(r_i,p_i,d_i)\\}$ 都是正确的，并且必须计算出可能的最小 $L_{\\max}$ 值。你的推理过程不得依赖未经证明的启发式方法或黑箱定理，并且必须基于基本定义和逻辑上有效的交换论证。\n\n你的程序必须实现此算法，并为以下每个测试用例计算可能的最小 $L_{\\max}$。每个测试用例是一个作业列表，以三元组 $(r_i,p_i,d_i)$ 的形式给出：\n\n- 测试用例 $1$: $[(0,3,9),(0,2,8),(0,2,15)]$。\n- 测试用例 $2$: $[(0,10,100),(5,1,7)]$。\n- 测试用例 $3$: $[(0,5,3),(0,2,5)]$。\n- 测试用例 $4$: $[(0,3,10),(2,0,1)]$。\n- 测试用例 $5$: $[(0,7,20),(3,4,8),(4,2,6)]$。\n- 测试用例 $6$: $[(0,2,5),(5,2,20)]$。\n- 测试用例 $7$: $[(0,2,5),(1,2,5)]$。\n\n你的程序必须生成单行输出，其中包含按上述相同顺序排列的测试用例结果，格式为方括号内以逗号分隔的列表，例如 $[x_1,x_2,\\dots,x_7]$。每个测试用例的结果必须是一个整数，等于该测试用例在允许无惩罚抢占的情况下可实现的最小 $L_{\\max}$。不应打印额外的文本或空格，也不应读取任何输入。程序必须是自包含的，并且可以直接运行。",
            "solution": "用户要求提供一种算法来解决带发布时间和抢占的单机调度问题，目标是最小化最大延迟，定义为 $L_{\\max} = \\max_i L_i$，其中 $L_i = C_i - d_i$。这里，$C_i$ 是作业 $i$ 的完成时间，$d_i$ 是其截止时间。每个作业 $i$ 由一个三元组 $(r_i, p_i, d_i)$ 定义，分别代表其发布时间、处理时间和截止时间。所有参数均为整数。\n\n问题在于从第一性原理出发设计一个算法，并通过交换论证来证明其正确性。所要求的算法是“最早截止时间优先”（EDF）规则的一个动态版本。\n\n### 提出的算法：最早截止时间优先（EDF）\n\n贪心策略如下：在任何时间点 $t$，从可用作业集合（即已发布 $r_i \\le t$ 但尚未完成的作业）中，选择截止时间 $d_i$ 最早的作业进行处理。如果可用作业集合为空，则机器保持空闲。这被称为最早截止时间优先（EDF）算法。\n\n### 正确性证明\n\n我们将通过交换论证来证明 EDF 算法的最优性。证明包括两部分：首先，证明当有可用作业时，最优调度不需要有任何空闲时间；其次，证明任何非 EDF 调度都可以转换为 EDF 调度，而不会增加最大延迟。\n\n#### 第1部分：空闲时间\n\n设 $S_{OPT}$ 是一个最小化 $L_{\\max}$ 的最优调度。假设在某个时间 $t_1$，至少有一个可用作业，但机器在 $S_{OPT}$ 中于区间 $[t_1, t_2)$ 内是空闲的。设作业 $j$ 是在 $t_1$ 时刻的一个可用作业。由于机器是空闲的，这个作业 $j$（以及任何其他工作）必须被安排在某个时间 $t_3 \\ge t_2$ 执行。\n\n我们可以通过将某个作业的 $\\delta  0$ 单位工作从一个始于 $t_2$ 或之后的区间移动到始于 $t_1$ 的空闲区间，来从 $S_{OPT}$ 构建一个新的调度 $S'$。具体来说，我们可以从稍后的时间取出作业 $j$ 的一部分处理，并在区间 $[t_1, t_1+\\delta]$ 内执行它，其中 $\\delta = \\min(t_2-t_1, p_j(t_1))$，$p_j(t_1)$ 是作业 $j$ 在时间 $t_1$ 的剩余处理时间。\n\n在新调度 $S'$ 中，所有作业的完成时间都不晚于它们在 $S_{OPT}$ 中的完成时间，因此它们的延迟不会增加。所以，$L_{\\max}(S') \\le L_{\\max}(S_{OPT})$。我们可以重复这个过程，直到调度在有可用作业时没有任何空闲时间。这表明存在一个只要可能就保持“忙碌”状态的最优调度。\n\n#### 第2部分：交换论证\n\n设 $S_{EDF}$ 是由我们的 EDF 算法生成的调度。设 $S_{OPT}$ 是一个“忙碌”（根据第1部分）但不是 EDF 调度的最优调度。如果 $S_{OPT}$ 不是一个 EDF 调度，那么必然存在第一个时间 $t$，在该时刻它选择处理的作业与 EDF 的选择不同。\n\n在这个时间 $t$，$S_{EDF}$ 选择了一个可用作业 $j$，使得对于任何其他可用作业 $k$，都有 $d_j \\le d_k$。由于 $S_{OPT}$ 偏离了 EDF 策略，它必定选择了一个不同的可用作业，比如说 $k$，必然有 $d_k \\ge d_j$。为简化论证，我们假设 $d_k  d_j$。\n\n在 $S_{OPT}$ 中，作业 $k$ 从 $t$ 开始被处理一段时间 $\\Delta  0$。作业 $j$ 必须在稍后的时间被处理。我们找到 $t$ 之后 $S_{OPT}$ 处理作业 $j$ 的第一个区间 $[t', t'+\\Delta']$。\n\n我们现在通过交换这些工作块来从 $S_{OPT}$ 构建一个新的调度 $S'$。设 $\\delta = \\min(\\Delta, \\Delta')$。\n- 在 $S'$ 中，于区间 $[t, t+\\delta]$ 处理作业 $j$。\n- 在 $S'$ 中，于区间 $[t', t'+\\delta]$ 处理作业 $k$。\n- 在所有其他时间，$S'$ 与 $S_{OPT}$ 相同。\n\n这个新的调度 $S'$ 是有效的，因为作业 $j$ 在时间 $t$ 是可用的，而作业 $k$（在 $t$ 时可用）在稍后的时间 $t'$ 肯定也是可用的。\n\n让我们分析 $S'$ 相对于 $S_{OPT}$ 的延迟。设 $C_i$ 和 $C'_i$ 分别是 $S_{OPT}$ 和 $S'$ 中的完成时间。\n1.  对于任何作业 $i \\neq j, k$，其处理不受影响。因此，$C'_i = C_i$ 且 $L'_i = L_i$。\n2.  对于作业 $j$，其一部分工作被更早地执行。这只会导致其完成时间更早或相同。所以，$C'_j \\le C_j$，这意味着 $L'_j = C'_j - d_j \\le C_j - d_j = L_j$。\n3.  对于作业 $k$，其一部分工作被延迟了。其完成时间 $C'_k$ 可能大于 $C_k$。然而，作业 $j$ 在 $S_{OPT}$ 中于 $[t', t'+\\delta]$ 占用的时间片现在可用于其他工作，包括作业 $k$。作业 $j$ 和 $k$ 的总工作量在先前 $S_{OPT}$ 中包含它们执行的同一总时间窗口内完成。关键的是，作业 $k$ 在 $S'$ 中的完成时间 $C'_k$ 不会超过作业 $j$ 在 $S_{OPT}$ 中的完成时间 $C_j$。这是因为在 $S_{OPT}$ 中时间 $t$ 之后用于作业 $j$ 的任何时间片，现在在 $S'$ 中都可用于作业 $k$。因此，$C'_k \\le C_j$。\n\n现在我们可以比较作业 $k$ 的延迟：\n$L'_k = C'_k - d_k \\le C_j - d_k$。\n由于我们开始的前提是 $d_j  d_k$，因此有 $-d_k  -d_j$。\n所以，$L'_k \\le C_j - d_k  C_j - d_j = L_j$。\n\n我们已经证明了 $L'_j \\le L_j$ 且 $L'_k  L_j$。这意味着 $\\max(L'_j, L'_k) \\le L_j \\le \\max(L_j, L_k)$。作业对 $\\{j, k\\}$ 的最大延迟没有增加。由于所有其他作业的延迟都未改变，因此整体最大延迟没有增加：$L_{\\max}(S') \\le L_{\\max}(S_{OPT})$。\n\n通过重复应用这种交换，我们可以将 $S_{OPT}$ 转换为一个在每一步都与 $S_{EDF}$ 匹配的调度，而从不增加最大延迟。这证明了由最早截止时间优先算法生成的调度 $S_{EDF}$ 是最优的。\n\n### 算法实现\n\nEDF 算法可以作为离散事件模拟来实现。需要进行调度决策的“事件”是新作业的发布或当前运行作业的完成。\n\n1.  维护一个全局 `currentTime`。\n2.  保留一个尚未发布的作业列表，按发布时间 $r_i$ 排序。\n3.  使用一个最小优先队列来存储可用作业，按其截止时间 $d_i$ 排序。\n4.  主模拟循环将 `currentTime` 从一个事件推进到下一个事件。\n    -   在 `currentTime` 时刻，将任何新发布的作业添加到优先队列中。\n    -   如果机器正忙，检查优先队列中是否有任何作业的截止时间早于正在运行的作业。如果有，则抢占当前作业（将其返回优先队列）并开始新作业。\n    -   如果机器空闲，从优先队列中提取截止时间最小的作业来运行。\n    -   如果机器空闲且没有可用作业，将 `currentTime` 推进到下一个作业的发布时间。\n    -   计算到下一个事件（当前作业完成或下一个作业发布）发生前的时间。将 `currentTime` 增加此时间量，并更新当前作业的剩余处理时间。\n    -   如果一个作业完成，记录其完成时间并将机器设置为空闲状态。\n5.  当所有作业都完成时，模拟结束。\n6.  最后，计算所有作业的 $L_{\\max} = \\max_i(C_i - d_i)$。这将是可能的最小最大延迟。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport heapq\n\ndef solve():\n    \"\"\"\n    Main function to solve the scheduling problem for all test cases.\n    \"\"\"\n    test_cases = [\n        [(0, 3, 9), (0, 2, 8), (0, 2, 15)],\n        [(0, 10, 100), (5, 1, 7)],\n        [(0, 5, 3), (0, 2, 5)],\n        [(0, 3, 10), (2, 0, 1)],\n        [(0, 7, 20), (3, 4, 8), (4, 2, 6)],\n        [(0, 2, 5), (5, 2, 20)],\n        [(0, 2, 5), (1, 2, 5)],\n    ]\n\n    results = []\n    for case in test_cases:\n        result = edf_scheduler(case)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef edf_scheduler(jobs_data):\n    \"\"\"\n    Calculates the minimum maximum lateness for a set of jobs using the\n    Earliest Deadline First (EDF) scheduling algorithm with preemption.\n\n    Args:\n        jobs_data: A list of tuples, where each tuple is (r_i, p_i, d_i)\n                   representing release time, processing time, and deadline.\n\n    Returns:\n        The minimum possible maximum lateness (L_max).\n    \"\"\"\n    if not jobs_data:\n        return 0\n\n    # Job representation: Use a dictionary to hold mutable state (p_rem).\n    # 'id' is the original index, used for tracking.\n    jobs = [{'id': i, 'r': r, 'p': p, 'd': d, 'p_rem': p}\n            for i, (r, p, d) in enumerate(jobs_data)]\n    \n    # Map job IDs to their data for O(1) access.\n    job_map = {j['id']: j for j in jobs}\n    \n    # Jobs to be processed, sorted by release time.\n    unreleased_jobs = sorted(jobs, key=lambda j: j['r'])\n\n    # Min-priority queue for available jobs, ordered by deadline.\n    # Stores tuples of (deadline, job_id).\n    available_jobs_pq = []\n\n    completion_times = {}\n    current_time = 0\n    current_job_id = None\n    processed_job_count = 0\n\n    # The simulation runs until all jobs are completed.\n    while processed_job_count  len(jobs):\n        \n        # If the machine is idle and no jobs are available, jump time to the next release.\n        if current_job_id is None and not available_jobs_pq and unreleased_jobs:\n            current_time = max(current_time, unreleased_jobs[0]['r'])\n        \n        # Add all jobs released by the current time to the available pool.\n        while unreleased_jobs and unreleased_jobs[0]['r'] = current_time:\n            job = unreleased_jobs.pop(0)\n            heapq.heappush(available_jobs_pq, (job['d'], job['id']))\n\n        # If a job just finished or the machine was idle, select the next job to run (EDF).\n        if current_job_id is None and available_jobs_pq:\n            _, current_job_id = heapq.heappop(available_jobs_pq)\n\n        # Preemption check: if an available job has an earlier deadline than the current one.\n        if current_job_id is not None and available_jobs_pq:\n            best_available_d, _ = available_jobs_pq[0]\n            if best_available_d  job_map[current_job_id]['d']:\n                # The available job preempts the current job.\n                heapq.heappush(available_jobs_pq, (job_map[current_job_id]['d'], current_job_id))\n                _, current_job_id = heapq.heappop(available_jobs_pq)\n        \n        if current_job_id is None:\n            # This handles idle periods between jobs when the ready queue is temporarily empty.\n            continue\n            \n        current_job = job_map[current_job_id]\n\n        # Determine the time slice for the current job. It runs until it's finished\n        # or a new job is released, whichever comes first.\n        time_to_completion = current_job['p_rem']\n        time_to_next_release = float('inf')\n        if unreleased_jobs:\n            time_to_next_release = unreleased_jobs[0]['r'] - current_time\n        \n        time_to_run = max(0, min(time_to_completion, time_to_next_release))\n\n        # Update state based on the time slice.\n        current_job['p_rem'] -= time_to_run\n        current_time += time_to_run\n\n        # If the job has finished processing.\n        if current_job['p_rem'] == 0:\n            completion_times[current_job_id] = current_time\n            current_job_id = None\n            processed_job_count += 1\n            \n    # Calculate the maximum lateness over all jobs.\n    max_lateness = -float('inf')\n    for i in range(len(jobs_data)):\n        d = jobs_data[i][2]\n        c = completion_times[i]\n        max_lateness = max(max_lateness, c - d)\n            \n    return int(max_lateness)\n\nsolve()\n```"
        },
        {
            "introduction": "在许多应用中，我们不仅关心最坏情况下的延迟，还关心延迟的整体分布。这个高级练习将目标从最小化最大延迟，转变为最小化第$k$个最大延迟，这是一个更具挑战性的优化目标。解决这个问题需要你巧妙地结合二分搜索和贪心算法等多种高级技巧，是提升复杂算法设计能力的绝佳实践。",
            "id": "3252882",
            "problem": "给定一个单机调度问题，包含一组 $n$ 个独立任务。每个任务 $J_i$ 都有一个正处理时间 $p_i$ 和一个交货期 $d_i$，其中 $i \\in \\{1,2,\\dots,n\\}$。调度是任务的任意排列 $\\sigma$，这些任务在一台一次只能处理一个任务的单机上不可抢占地执行。对于给定的调度 $\\sigma$，任务 $J_i$ 的完成时间记为 $C_i(\\sigma)$，递归地定义为按 $\\sigma$ 顺序排列的处理时间的累积和。在调度 $\\sigma$ 下，任务 $J_i$ 的延迟为 $L_i(\\sigma) = C_i(\\sigma) - d_i$。对于任何调度 $\\sigma$，考虑多重集 $\\{L_1(\\sigma), L_2(\\sigma), \\dots, L_n(\\sigma)\\}$ 按非增序排序；对于给定的整数 $k$（$1 \\le k \\le n$），第 $k$ 大的任务延迟是此排序列表中的第 $k$ 个元素。\n\n您的任务是设计并实现一个完整的、可运行的程序，该程序针对几个指定的测试用例，计算所有有效调度中第 $k$ 大的任务延迟的最小可能值。推导过程必须从单机调度、完成时间和延迟的基本定义出发，且不得使用任何未经证实的捷径。最终输出必须是单行，包含所有测试用例的结果，格式为方括号括起来的逗号分隔列表。\n\n此问题中没有物理单位。所有返回值必须是整数。\n\n请使用以下测试套件。对于每个测试用例，输入是一个 $(p_i, d_i)$ 对的列表和一个整数 $k$。您的程序必须计算一个整数：所有调度中第 $k$ 大的任务延迟的最小可能值。\n\n- 测试用例 $1$：任务 $[(3,10),(2,5),(7,12),(4,8),(5,14),(6,7)]$，$k=2$。\n- 测试用例 $2$：任务 $[(1,4),(3,9),(2,8),(6,15),(4,16)]$，$k=1$。\n- 测试用例 $3$：任务 $[(2,20),(7,20),(1,20),(5,20),(4,20),(6,20),(3,20)]$，$k=3$。\n- 测试用例 $4$：任务 $[(5,25),(4,25),(7,25),(6,25)]$，$k=4$。\n- 测试用例 $5$：任务 $[(4,10),(4,10),(4,10),(4,10)]$，$k=2$。\n\n您的程序应生成单行输出，其中包含结果，格式为方括号括起来的逗号分隔列表（例如 $[r_1,r_2,r_3,r_4,r_5]$），其中每个 $r_i$ 是相应测试用例的整数答案。",
            "solution": "我们从单机调度的基本定义开始。调度 $\\sigma$ 是任务集合 $\\{J_1,\\dots,J_n\\}$ 的任意一个排列。任务 $J_i$ 的完成时间 $C_i(\\sigma)$ 定义为在调度 $\\sigma$ 中排在其前的所有任务的处理时间累积和再加上其自身的处理时间 $p_i$。在调度 $\\sigma$ 中，任务 $J_i$ 的延迟为 $L_i(\\sigma)=C_i(\\sigma)-d_i$。将 $\\{L_1(\\sigma),\\dots,L_n(\\sigma)\\}$ 按非增序排序，可以得到一个有序的延迟向量，第 $k$ 大的延迟就是这个排序后向量的第 $k$ 个元素。问题在于找到一个调度，使得该向量的第 $k$ 大元素最小化。\n\n一个关键的等价关系源于延迟的定义。固定任意一个阈值 $T \\in \\mathbb{Z}$。一个任务 $J_i$ 满足 $L_i(\\sigma)\\le T$ 当且仅当 $C_i(\\sigma)\\le d_i+T$。因此，对于给定的 $T$，在调度 $\\sigma$ 中延迟至多为 $T$ 的任务，恰好是那些能在其调整后的交货期 $d_i+T$ 前完成的任务。如果最多有 $(k-1)$ 个任务的延迟严格大于 $T$，那么第 $k$ 大的延迟至多为 $T$。反之，如果超过 $(k-1)$ 个任务的延迟严格大于 $T$，那么第 $k$ 大的延迟就超过 $T$。这就在 $T$ 上建立了一个单调决策性质：定义 $f(T)$ 为在相对于调整后交货期 $d_i+T$ 的最优调度中，延迟严格大于 $T$ 的任务数量。那么 $f(T)$ 是关于 $T$ 的非增函数，而第 $k$ 大任务延迟的最小可能值就等于满足 $f(T)\\le k-1$ 的最小整数 $T$。\n\n我们现在从第一性原理出发描述如何计算 $f(T)$。对于一个固定的 $T$，我们问：在单台机器上，不可抢占地调度，最多能有多少个任务可以满足其调整后的交货期 $\\tilde{d}_i=d_i+T$？这是一个经典的满足交货期的可行性问题，一个广为接受的解法是 Moore–Hodgson 算法：按调整后交货期的非减序（即对 $\\tilde{d}_i$ 采用最早交货期 (EDD) 顺序）对任务进行排序，然后贪心地加入任务，同时记录累积处理时间 $S$。每当 $S$ 超过当前任务的调整后交货期时，就从已包含的任务集合中移除处理时间最长的那个任务；这一步会严格地减小 $S$，并且通过交换论证可以证明，这保留了满足最大数量交货期的潜力。具体来说，假设在某个点上 $S > \\tilde{d}_j$。移除任何一个已包含的任务都会使其处理时间从 $S$ 中减去；移除处理时间最长的任务可以最大程度地减小 $S$，并且相对于移除一个较短的任务，这绝不会损害可行性，因为任何可行的调度都必须满足累积处理时间不超过调整后的交货期阈值。可以证明，使用标准的交换论证，最终保留下来的任务集合，在所有能够以 EDD 顺序调度并满足所有调整后交货期的子集中，其基数是最大的：任何违反 EDD 顺序的调度都可以通过交换调整，而不会减少准时任务的数量；任何选择移除非最长任务的调度，都可以转换为移除最长任务的调度，而不会减少准时任务的基数。\n\n令 $g(T)$ 表示在某个调度下，最多能在其调整后的交货期 $d_i+T$ 之前完成的任务数量。那么延迟严格大于 $T$ 的最小任务数量等于 $n-g(T)$。其单调性是显而易见的：随着 $T$ 的增加，每个调整后的交货期也会增加，因此 $g(T)$ 是非减的，而 $n-g(T)$ 是非增的。\n\n基于这个单调决策结构，我们对整数阈值应用二分搜索。我们需要有效的全局界限。对于任何任务 $J_i$，由于 $C_i(\\sigma)\\ge 0$，我们有 $L_i(\\sigma)=C_i(\\sigma)-d_i\\ge -d_i\\ge -\\max_i d_i$。因此，第 $k$ 大的延迟总是至少为 $-\\max_i d_i$。另一方面，由于 $C_i(\\sigma)\\le \\sum_{j=1}^n p_j$ 且 $d_i\\ge \\min_i d_i$，我们有 $L_i(\\sigma)\\le \\sum_{j=1}^n p_j - \\min_i d_i$，所以第 $k$ 大的延迟至多为 $\\sum_{j=1}^n p_j - \\min_i d_i$。因此，我们可以在整数区间 $[-\\max_i d_i,\\ \\sum_{j=1}^n p_j - \\min_i d_i]$ 内搜索 $T$。对于给定的中点 $T$，通过在 $d_i+T$ 上按 EDD 顺序执行 Moore–Hodgson 过程来计算 $g(T)$，并检验是否 $n-g(T)\\le k-1$。如果为真，则将搜索范围移向更小的 $T$；否则，移向更大的 $T$。满足该断言的最小 $T$ 值，就是第 $k$ 大任务延迟的最小可能值。\n\n正确性由以下等价关系确立：最小化第 $k$ 大的延迟等同于最小化 $T$ 使得最多有 $(k-1)$ 个任务的延迟超过 $T$，而 Moore–Hodgson 算法能对任意 $T$ 优化地计算出 $g(T)$。由于该断言对 $T$ 是单调的，二分搜索可以找到最小的可行 $T$。\n\n复杂度分析：对于每个 $T$，计算 $g(T)$ 需要按调整后交货期排序，这需要 $O(n\\log n)$ 的时间；然后需要用一个优先队列结构来处理任务，以便在需要时移除处理时间最长的任务。使用二叉堆每次插入和移除操作的时间复杂度为 $O(\\log n)$，因此每次可行性检查的总时间复杂度为 $O(n\\log n)$。在长度至多为 $\\sum_{j=1}^n p_j + \\max_i d_i$ 的整数区间上进行二分搜索，需要 $O(\\log(\\sum_{j=1}^n p_j + \\max_i d_i))$ 次迭代。因此，总时间复杂度为 $O(n\\log n \\cdot \\log(\\sum_{j=1}^n p_j + \\max_i d_i))$，空间复杂度为 $O(n)$。\n\n我们实现此算法，并在指定的测试套件上进行评估：\n- 测试用例 $1$：任务 $[(3,10),(2,5),(7,12),(4,8),(5,14),(6,7)]$，$k=2$。\n- 测试用例 $2$：任务 $[(1,4),(3,9),(2,8),(6,15),(4,16)]$，$k=1$。\n- 测试用例 $3$：任务 $[(2,20),(7,20),(1,20),(5,20),(4,20),(6,20),(3,20)]$，$k=3$。\n- 测试用例 $4$：任务 $[(5,25),(4,25),(7,25),(6,25)]$，$k=4$。\n- 测试用例 $5$：任务 $[(4,10),(4,10),(4,10),(4,10)]$，$k=2$。\n\n程序为每个案例生成一行输出，其中包含第 $k$ 大任务延迟的最小整数值，格式为方括号括起来的逗号分隔列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport heapq\n\ndef moore_hodgson_max_on_time(processing_times, due_dates, T):\n    \"\"\"\n    Compute the maximum number of jobs that can be completed no later than\n    their adjusted deadlines d_i + T using the Moore–Hodgson algorithm\n    in Earliest Due Date order.\n    \"\"\"\n    n = len(processing_times)\n    # Adjusted deadlines\n    adjusted = [(processing_times[i], due_dates[i] + T) for i in range(n)]\n    # Sort by adjusted deadline (EDD)\n    adjusted.sort(key=lambda x: x[1])\n\n    total_time = 0\n    # We use a max-heap by storing negative processing times in a min-heap\n    max_heap = []  # stores negative p to simulate max-heap\n\n    for p, adj_d in adjusted:\n        total_time += p\n        heapq.heappush(max_heap, -p)\n        # If total processing exceeds adjusted deadline, remove the longest job\n        if total_time > adj_d:\n            longest = -heapq.heappop(max_heap)\n            total_time -= longest\n\n    # The jobs remaining in the heap can meet their adjusted deadlines\n    return len(max_heap)\n\ndef minimize_kth_latest_lateness(processing_times, due_dates, k):\n    \"\"\"\n    Minimize the k-th largest lateness over all schedules by binary searching T,\n    where T is the threshold such that at most (k-1) jobs have lateness > T.\n    \"\"\"\n    n = len(processing_times)\n    if n == 0:\n        return 0\n\n    sum_p = sum(processing_times)\n    max_d = max(due_dates) if due_dates else 0\n    min_d = min(due_dates) if due_dates else 0\n\n    # Global bounds for lateness\n    low = -max_d\n    high = sum_p - min_d\n\n    best = high  # initialize with upper bound\n    while low = high:\n        mid = (low + high) // 2\n        on_time_count = moore_hodgson_max_on_time(processing_times, due_dates, mid)\n        tardy_count = n - on_time_count\n        if tardy_count = (k - 1):\n            best = mid\n            high = mid - 1\n        else:\n            low = mid + 1\n    return best\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case: (list_of_jobs_as_(p,d), k)\n    test_cases = [\n        ([(3,10),(2,5),(7,12),(4,8),(5,14),(6,7)], 2),\n        ([(1,4),(3,9),(2,8),(6,15),(4,16)], 1),\n        ([(2,20),(7,20),(1,20),(5,20),(4,20),(6,20),(3,20)], 3),\n        ([(5,25),(4,25),(7,25),(6,25)], 4),\n        ([(4,10),(4,10),(4,10),(4,10)], 2),\n    ]\n\n    results = []\n    for jobs, k in test_cases:\n        ps = [p for p, d in jobs]\n        ds = [d for p, d in jobs]\n        result = minimize_kth_latest_lateness(ps, ds, k)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}