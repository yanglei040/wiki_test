{
    "hands_on_practices": [
        {
            "introduction": "在许多现实世界的寻路问题中，我们不仅要找到最短路径，还必须遵守某些约束。一个常见的约束是路径不能经过某些特定的“禁行”顶点。这个练习将引导你处理这种情况，通过一个简单而强大的思想：将问题转化为我们已经知道如何解决的标准形式。你将学习如何通过修改图的结构来简化问题，然后应用Dijkstra算法找到所需路径。",
            "id": "3270849",
            "problem": "给定一个带非负边权的加权有向图 $G = (V, E)$ 以及两个指定的顶点 $s$ 和 $t$。设 $V_{bad} \\subset V$ 是一个禁止顶点集，这些顶点不能出现在任何可行路径上。一条路径是可行的，当且仅当其所有内部顶点都位于 $V \\setminus V_{bad}$ 中，并且其端点是指定的 $s$ 和 $t$，这两个端点都不属于 $V_{bad}$。目标是根据第一性原理，确定从 $s$ 到 $t$ 的最短可行路径的长度（总权重）。仅使用最短路径的核心定义和 Dijkstra 算法在非负边权图上的正确性作为基本事实，而不调用任何关于此特定图的预先计算的结果。\n\n考虑下面指定的实例。\n- 顶点集 $V = \\{s, a, b, c, d, e, f, g, h, t\\}$。\n- 禁止集 $V_{bad} = \\{c, f\\}$。\n- 边多重集 $E$ 及其权重 $w: E \\to \\mathbb{R}_{\\ge 0}$ 如下所示（每个三元组 $(u, v, w)$ 表示一条权重为 $w$ 的有向边 $u \\to v$）：\n  - $(s, a, 2)$, $(s, b, 5)$, $(s, h, 15)$, $(s, c, 1)$,\n  - $(a, c, 2)$, $(a, d, 4)$, $(a, e, 7)$,\n  - $(b, a, 1)$, $(b, d, 2)$, $(b, f, 6)$,\n  - $(c, d, 2)$, $(c, g, 5)$,\n  - $(d, e, 1)$, $(d, f, 2)$, $(d, g, 6)$,\n  - $(e, g, 1)$, $(e, h, 3)$,\n  - $(f, t, 3)$,\n  - $(g, h, 2)$, $(g, t, 4)$,\n  - $(h, t, 2)$。\n\n任务：\n- 通过移除 $V_{bad}$ 中的所有顶点以及所有与它们相关联的边，将问题形式化地归约为在诱导子图 $G[V \\setminus V_{bad}]$ 中计算最短路径。然后，利用路径长度的基本定义和 Dijkstra 算法在非负权图上的正确性，逻辑上推导出在归约后的图中以 $s$ 为根的最短路径树（shortest path tree, SPT），并由此确定从 $s$ 到 $t$ 的最短可行路径的长度。\n- 提供最终的数值答案，即精确的整数路径长度。不需要四舍五入。\n\n在此实例中，从 $s$ 到 $t$ 的最短可行路径的长度是多少？",
            "solution": "首先对问题进行验证。\n\n### 步骤 1：提取已知条件\n-   **图定义**：一个带非负边权的加权有向图 $G = (V, E)$。\n-   **顶点**：$V = \\{s, a, b, c, d, e, f, g, h, t\\}$。\n-   **起始和终点顶点**：源点 $s$，终点 $t$。\n-   **禁止顶点**：$V_{bad} = \\{c, f\\}$。\n-   **可行路径定义**：一条从 $s$ 到 $t$ 的路径，其所有内部顶点都在 $V \\setminus V_{bad}$ 中。端点 $s$ 和 $t$ 也不属于 $V_{bad}$。\n-   **边和权重**：\n    -   $(s, a, 2)$, $(s, b, 5)$, $(s, h, 15)$, $(s, c, 1)$,\n    -   $(a, c, 2)$, $(a, d, 4)$, $(a, e, 7)$,\n    -   $(b, a, 1)$, $(b, d, 2)$, $(b, f, 6)$,\n    -   $(c, d, 2)$, $(c, g, 5)$,\n    -   $(d, e, 1)$, $(d, f, 2)$, $(d, g, 6)$,\n    -   $(e, g, 1)$, $(e, h, 3)$,\n    -   $(f, t, 3)$,\n    -   $(g, h, 2)$, $(g, t, 4)$,\n    -   $(h, t, 2)$。\n-   **任务**：将问题归约为在诱导子图中寻找最短路径的问题，然后使用第一性原理的 Dijkstra 算法来找到从 $s$ 到 $t$ 的最短可行路径的长度。\n\n### 步骤 2：使用提取的已知条件进行验证\n1.  **科学依据**：该问题是图论和算法中的一个标准练习，这是计算机科学和离散数学的一个子领域。它基于已有的定义和算法。\n2.  **适定性**：该问题提供了一个完全指定的具有非负权重的图和一个明确的目标。“可行路径”的定义是精确的。条件 $s, t \\notin V_{bad}$（因为 $s, t \\notin \\{c, f\\}$）得到满足。由于边权非负，Dijkstra 算法适用并保证能找到解。因此，存在一个唯一的、稳定的、有意义的解（最短路径长度）。\n3.  **客观性**：语言正式且无歧义。所有术语都是图论中的标准术语。\n4.  **完整性和一致性**：问题是自包含的。所有必要的信息（顶点、边、权重、禁止集）都已提供。所提供的数据中没有矛盾。\n\n### 步骤 3：结论和行动\n问题是**有效的**。将推导求解。\n\n### 求解推导\n\n问题是要求解从顶点 $s$到顶点 $t$ 的最短可行路径的长度。一条路径被定义为可行的，如果其内部顶点不属于集合 $V_{bad} = \\{c, f\\}$。问题还指明了端点 $s$ 和 $t$ 不在 $V_{bad}$ 中。这意味着任何从 $s$ 到 $t$ 的可行路径必须完全由集合 $V' = V \\setminus V_{bad}$ 中的顶点组成。因此，在原始图 $G$ 中寻找最短可行路径等价于在由顶点集 $V'$ 导出的 $G$ 的子图中寻找最短路径。\n\n设这个归约后的图为 $G' = (V', E')$。\n顶点集 $V'$ 是：\n$V' = V \\setminus V_{bad} = \\{s, a, b, c, d, e, f, g, h, t\\} \\setminus \\{c, f\\} = \\{s, a, b, d, e, g, h, t\\}$。\n\n边集 $E'$ 由所有满足 $u$ 和 $v$ 都在 $V'$ 中的边 $(u, v) \\in E$ 组成。我们筛选原始的边列表：\n-   $(s, a, 2)$: 有效，因为 $s, a \\in V'$。\n-   $(s, b, 5)$: 有效，因为 $s, b \\in V'$。\n-   $(s, h, 15)$: 有效，因为 $s, h \\in V'$。\n-   $(s, c, 1)$: 无效，因为 $c \\notin V'$。\n-   $(a, c, 2)$: 无效，因为 $c \\notin V'$。\n-   $(a, d, 4)$: 有效，因为 $a, d \\in V'$。\n-   $(a, e, 7)$: 有效，因为 $a, e \\in V'$。\n-   $(b, a, 1)$: 有效，因为 $b, a \\in V'$。\n-   $(b, d, 2)$: 有效，因为 $b, d \\in V'$。\n-   $(b, f, 6)$: 无效，因为 $f \\notin V'$。\n-   $(c, d, 2)$: 无效，因为 $c \\notin V'$。\n-   $(c, g, 5)$: 无效，因为 $c \\notin V'$。\n-   $(d, e, 1)$: 有效，因为 $d, e \\in V'$。\n-   $(d, f, 2)$: 无效，因为 $f \\notin V'$。\n-   $(d, g, 6)$: 有效，因为 $d, g \\in V'$。\n-   $(e, g, 1)$: 有效，因为 $e, g \\in V'$。\n-   $(e, h, 3)$: 有效，因为 $e, h \\in V'$。\n-   $(f, t, 3)$: 无效，因为 $f \\notin V'$。\n-   $(g, h, 2)$: 有效，因为 $g, h \\in V'$。\n-   $(g, t, 4)$: 有效，因为 $g, t \\in V'$。\n-   $(h, t, 2)$: 有效，因为 $h, t \\in V'$。\n\n得到的图 $G' = (V', E')$ 的所有权重都是非负的。因此，我们可以应用 Dijkstra 算法来找到从 $s$ 到所有其他顶点的最短路径。设 $d(v)$ 为迄今为止找到的从 $s$ 到 $v$ 的最短距离，$\\pi(v)$ 为最短路径上 $v$ 的前驱节点。\n\n**初始化：**\n-   一个已访问顶点的集合，$S = \\emptyset$。\n-   一个优先队列 $Q$，包含 $V'$ 中的所有顶点，按距离优先。\n-   初始化距离：$d(s) = 0$，对于所有其他 $v \\in V'$，$d(v) = \\infty$。\n-   初始化前驱节点：对于所有 $v \\in V'$，$\\pi(v) = \\text{null}$。\n初始状态为：\n$d = \\{s:0, a:\\infty, b:\\infty, d:\\infty, e:\\infty, g:\\infty, h:\\infty, t:\\infty\\}$\n$Q = \\{s(0), a(\\infty), b(\\infty), d(\\infty), e(\\infty), g(\\infty), h(\\infty), t(\\infty)\\}$\n\n**Dijkstra 算法的执行过程：**\n\n1.  **提取 $s$**：$u = s$。将 $s$ 添加到 $S$。$S=\\{s\\}$。\n    -   松弛边 $(s, a)$，权重为 $2$：$d(a) > d(s)+2 \\implies \\infty > 0+2$。更新 $d(a)=2$，$\\pi(a)=s$。\n    -   松弛边 $(s, b)$，权重为 $5$：$d(b) > d(s)+5 \\implies \\infty > 0+5$。更新 $d(b)=5$，$\\pi(b)=s$。\n    -   松弛边 $(s, h)$，权重为 $15$：$d(h) > d(s)+15 \\implies \\infty > 0+15$。更新 $d(h)=15$，$\\pi(h)=s$。\n    $d = \\{s:0, a:2, b:5, d:\\infty, e:\\infty, g:\\infty, h:15, t:\\infty\\}$。\n    $Q = \\{a(2), b(5), h(15), d(\\infty), e(\\infty), g(\\infty), t(\\infty)\\}$.\n\n2.  **提取 $a$**：$u = a$。将 $a$ 添加到 $S$。$S=\\{s, a\\}$。\n    -   松弛边 $(a, d)$，权重为 $4$：$d(d) > d(a)+4 \\implies \\infty > 2+4$。更新 $d(d)=6$，$\\pi(d)=a$。\n    -   松弛边 $(a, e)$，权重为 $7$：$d(e) > d(a)+7 \\implies \\infty > 2+7$。更新 $d(e)=9$，$\\pi(e)=a$。\n    $d = \\{s:0, a:2, b:5, d:6, e:9, g:\\infty, h:15, t:\\infty\\}$。\n    $Q = \\{b(5), d(6), e(9), h(15), g(\\infty), t(\\infty)\\}$.\n\n3.  **提取 $b$**：$u = b$。将 $b$ 添加到 $S$。$S=\\{s, a, b\\}$。\n    -   松弛边 $(b, a)$，权重为 $1$：$d(a) > d(b)+1 \\implies 2 > 5+1$ 为假。不更新。\n    -   松弛边 $(b, d)$，权重为 $2$：$d(d) > d(b)+2 \\implies 6 > 5+2$ 为假。不更新。\n    $d$ 不变。 $Q = \\{d(6), e(9), h(15), g(\\infty), t(\\infty)\\}$。\n\n4.  **提取 $d$**：$u = d$。将 $d$ 添加到 $S$。$S=\\{s, a, b, d\\}$。\n    -   松弛边 $(d, e)$，权重为 $1$：$d(e) > d(d)+1 \\implies 9 > 6+1$。更新 $d(e)=7$，$\\pi(e)=d$。\n    -   松弛边 $(d, g)$，权重为 $6$：$d(g) > d(d)+6 \\implies \\infty > 6+6$。更新 $d(g)=12$，$\\pi(g)=d$。\n    $d = \\{s:0, a:2, b:5, d:6, e:7, g:12, h:15, t:\\infty\\}$。\n    $Q = \\{e(7), g(12), h(15), t(\\infty)\\}$.\n\n5.  **提取 $e$**：$u = e$。将 $e$ 添加到 $S$。$S=\\{s, a, b, d, e\\}$。\n    -   松弛边 $(e, g)$，权重为 $1$：$d(g) > d(e)+1 \\implies 12 > 7+1$。更新 $d(g)=8$，$\\pi(g)=e$。\n    -   松弛边 $(e, h)$，权重为 $3$：$d(h) > d(e)+3 \\implies 15 > 7+3$。更新 $d(h)=10$，$\\pi(h)=e$。\n    $d = \\{s:0, a:2, b:5, d:6, e:7, g:8, h:10, t:\\infty\\}$。\n    $Q = \\{g(8), h(10), t(\\infty)\\}$.\n\n6.  **提取 $g$**：$u = g$。将 $g$ 添加到 $S$。$S=\\{s, a, b, d, e, g\\}$。\n    -   松弛边 $(g, h)$，权重为 $2$：$d(h) > d(g)+2 \\implies 10 > 8+2$ 为假。不更新。\n    -   松弛边 $(g, t)$，权重为 $4$：$d(t) > d(g)+4 \\implies \\infty > 8+4$。更新 $d(t)=12$，$\\pi(t)=g$。\n    $d = \\{s:0, a:2, b:5, d:6, e:7, g:8, h:10, t:12\\}$。\n    $Q = \\{h(10), t(12)\\}$.\n\n7.  **提取 $h$**：$u = h$。将 $h$ 添加到 $S$。$S=\\{s, a, b, d, e, g, h\\}$。\n    -   松弛边 $(h, t)$，权重为 $2$：$d(t) > d(h)+2 \\implies 12 > 10+2$ 为假。不更新。\n    $d$ 不变。$Q = \\{t(12)\\}$.\n\n8.  **提取 $t$**：$u = t$。将 $t$ 添加到 $S$。$S=\\{s, a, b, d, e, g, h, t\\}$。算法终止，因为 $Q$ 现在为空。\n\n从 $s$ 出发的最终距离由数组 $d$ 给出。从 $s$ 出发的最短路径树（SPT）由前驱数组 $\\pi$ 隐式定义。从 $s$ 到 $t$ 的最短路径长度是 $d(t)$。\n\n从最终状态可知，$d(t) = 12$。\n\n我们可以追踪找到的最短路径：\n$t \\leftarrow \\pi(t)=g \\leftarrow \\pi(g)=e \\leftarrow \\pi(e)=d \\leftarrow \\pi(d)=a \\leftarrow \\pi(a)=s$。\n路径是 $s \\to a \\to d \\to e \\to g \\to t$。\n长度为 $w(s,a) + w(a,d) + w(d,e) + w(e,g) + w(g,t) = 2 + 4 + 1 + 1 + 4 = 12$。\n这证实了 Dijkstra 算法的结果。\n\n值得注意的是，存在另一条长度相同的路径：$s \\to a \\to d \\to e \\to h \\to t$。其长度为 $2+4+1+3+2=12$。Dijkstra 算法找到了其中一条路径，并且长度 $12$ 保证是最小的。\n\n从 $s$ 到 $t$ 的最短可行路径的长度是 $12$。",
            "answer": "$$\n\\boxed{12}\n$$"
        },
        {
            "introduction": "最短路径算法通常处理的是与边相关的成本（例如距离或时间）。但如果通过某个顶点本身也会产生额外成本呢？这个练习挑战你将一个非标准的路径成本函数（包括边的权重和中间顶点的成本）映射到标准的最短路径问题上。通过巧妙地调整边的权重来吸收顶点成本，你将能够应用Dijkstra等标准算法，这展示了算法设计中问题归约的精妙之处。",
            "id": "3270794",
            "problem": "考虑一个有向图 $G=(V,E)$，其顶点集为 $V=\\{v_1,v_2,v_3,v_4,v_5,v_6,v_7\\}$。每条有向边 $(u,v)\\in E$ 都有一个由函数 $w:E\\to \\mathbb{R}_{\\ge 0}$ 给出的非负边权重，每个顶点 $x\\in V$ 都有一个由函数 $c:V\\to \\mathbb{R}_{\\ge 0}$ 给出的非负顶点成本。对于任何有向 $s$-$t$ 路径 $P=\\langle s=x_0,x_1,\\dots,x_k=t\\rangle$，其路径成本定义为\n$$\n\\sum_{i=0}^{k-1} w(x_i,x_{i+1}) \\;+\\; \\sum_{i=1}^{k-1} c(x_i),\n$$\n即，路径上所有边的权重之和，加上路径上所有中间顶点（不包括源点和终点）的成本。假设所有边的权重和顶点的成本都是非负的。\n\n你的任务是，基于最短路径和Dijkstra算法（该算法适用于具有非负边权重的有向图）的核心定义进行推理，并且在不借助任何预先给定的规约公式的情况下，推导出一个正确的方法，用标准的单源最短路径计算（边权重为非负）来计算上述路径成本。然后，对于下面给出的源点为 $s=v_1$、终点为 $t=v_7$ 的具体实例，计算在该模型下从 $v_1$ 到 $v_7$ 的最小路径成本。\n\n有向边及其权重如下：\n- 边 $v_1\\to v_2$ 权重为 $w=4$；边 $v_1\\to v_3$ 权重为 $w=2$。\n- 边 $v_2\\to v_3$ 权重为 $w=1$；边 $v_2\\to v_4$ 权重为 $w=5$；边 $v_2\\to v_5$ 权重为 $w=7$。\n- 边 $v_3\\to v_4$ 权重为 $w=8$；边 $v_3\\to v_5$ 权重为 $w=10$；边 $v_3\\to v_6$ 权重为 $w=4$。\n- 边 $v_4\\to v_5$ 权重为 $w=2$；边 $v_4\\to v_6$ 权重为 $w=6$。\n- 边 $v_5\\to v_6$ 权重为 $w=2$；边 $v_5\\to v_7$ 权重为 $w=5$。\n- 边 $v_6\\to v_7$ 权重为 $w=1$。\n\n顶点成本如下：\n- $c(v_1)=3$, $c(v_2)=4$, $c(v_3)=2$, $c(v_4)=5$, $c(v_5)=1$, $c(v_6)=3$, $c(v_7)=6$。\n\n仅报告从 $v_1$ 到 $v_7$ 的最小路径成本值，以实数形式表示。此实例无需四舍五入。",
            "solution": "用户提供了一个在有向图上的最短路径问题，该问题定义明确但使用了非标准的成本函数。此问题在数学和算法上是合理的、自洽的且无歧义，因此是有效的。我将首先推导一种通过将其规约为标准单源最短路径问题来解决此类问题的方法，然后将该方法应用于所提供的具体实例。\n\n### 第一部分：规约推导\n设有一有向图 $G=(V,E)$，其非负边权重函数为 $w:E\\to \\mathbb{R}_{\\ge 0}$，非负顶点成本函数为 $c:V\\to \\mathbb{R}_{\\ge 0}$。对于给定的源顶点 $s \\in V$ 和目标顶点 $t \\in V$，我们需要找到一条路径 $P=\\langle s=x_0,x_1,\\dots,x_k=t\\rangle$，以最小化路径成本，其定义为：\n$$\nC(P) = \\sum_{i=0}^{k-1} w(x_i,x_{i+1}) \\;+\\; \\sum_{i=1}^{k-1} c(x_i)\n$$\n该成本是路径上所有边权重之和，加上所有中间顶点（即不包括源点 $s$ 和终点 $t$）的成本之和。\n\n标准的最短路径算法，如Dijkstra算法，作用于成本仅与边相关联的图。我们的目标是将给定问题转换为一个等价的、仅有边权重的图上问题，使得新图中的标准最短路径成本与自定义成本 $C(P)$ 直接相关。\n\n我们构建一个新图 $G'=(V, E)$，其顶点集和边集与 $G$ 相同。我们需要定义一个新的边权重函数 $w': E \\to \\mathbb{R}_{\\ge 0}$。关键在于将顶点成本并入这些新的边权重中。当一条路径穿过顶点 $v$ 时，会产生顶点成本 $c(v)$。这表明成本 $c(v)$ 可以加到所有进入 $v$ 的边的权重上，或者加到所有离开 $v$ 的边的权重上。\n\n我们来探讨第一种方法：将边 $(u,v)$ 的新权重定义为其原始权重与目标顶点 $v$ 的成本之和。\n令 $w'(u,v) = w(u,v) + c(v)$，对于每条边 $(u,v) \\in E$。\n由于 $w(u,v) \\ge 0$ 和 $c(v) \\ge 0$，新的边权重 $w'(u,v)$ 也都是非负的。这确保了Dijkstra算法适用于转换后的图 $G'$。\n\n现在，我们根据标准的最短路径度量，来考虑同一路径 $P = \\langle s=x_0,x_1,\\dots,x_k=t\\rangle$ 在这个新图 $G'$ 中的成本。这个成本我们称之为 $C'(P)$，是路径上新边权重之和：\n$$\nC'(P) = \\sum_{i=0}^{k-1} w'(x_i,x_{i+1})\n$$\n代入 $w'$ 的定义，我们得到：\n$$\nC'(P) = \\sum_{i=0}^{k-1} \\left( w(x_i,x_{i+1}) + c(x_{i+1}) \\right)\n$$\n我们可以将这个和式分为两部分：\n$$\nC'(P) = \\sum_{i=0}^{k-1} w(x_i,x_{i+1}) + \\sum_{i=0}^{k-1} c(x_{i+1})\n$$\n我们展开第二个求和式：\n$$\n\\sum_{i=0}^{k-1} c(x_{i+1}) = c(x_1) + c(x_2) + \\dots + c(x_{k-1}) + c(x_k)\n$$\n这个和式的第一部分 $\\sum_{i=1}^{k-1} c(x_i)$ 对应于中间顶点的成本。顶点 $x_k$ 是终点 $t$。所以，我们可以将 $C'(P)$ 的表达式重写为：\n$$\nC'(P) = \\left( \\sum_{i=0}^{k-1} w(x_i,x_{i+1}) + \\sum_{i=1}^{k-1} c(x_i) \\right) + c(x_k)\n$$\n括号中的表达式正是原始成本函数 $C(P)$。由于 $x_k = t$，我们得到：\n$$\nC'(P) = C(P) + c(t)\n$$\n这个关系表明，对于任何从 $s$ 到 $t$ 的路径，其在 $G'$ 中的标准成本等于其在 $G$ 中的自定义成本加上终点顶点 $t$ 的成本 $c(t)$。由于对于所有从 $s$ 到 $t$ 的路径，$c(t)$ 是一个常数，因此最小化 $C'(P)$ 的路径也就是最小化 $C(P)$ 的路径。\n\n因此，我们可以通过执行以下步骤来找到原始问题中的最小路径成本：\n1. 构建边权重为 $w'(u,v) = w(u,v) + c(v)$ 的图 $G'$。\n2. 在 $G'$ 上从源点 $s$ 开始运行Dijkstra算法，以找到到所有其他顶点的最短路径距离。设 $d'(s,v)$ 表示任意顶点 $v$ 的这个距离。\n3. 从 $s$ 到 $t$ 在 $G'$ 中的最短路径距离是 $d'(s,t)$。\n4. 原始定义下的最小路径成本为 $C_{min} = d'(s,t) - c(t)$。\n\n### 第二部分：应用于具体实例\n我们已知图 $G=(V, E)$，其中 $V=\\{v_1, \\dots, v_7\\}$，源点 $s=v_1$，终点 $t=v_7$，以及以下的边权重和顶点成本：\n\n**顶点成本：**\n$c(v_1)=3$, $c(v_2)=4$, $c(v_3)=2$, $c(v_4)=5$, $c(v_5)=1$, $c(v_6)=3$, $c(v_7)=6$。\n\n**图转换：**\n我们计算新的边权重 $w'(u,v) = w(u,v) + c(v)$：\n- $w'(v_1, v_2) = w(v_1, v_2) + c(v_2) = 4 + 4 = 8$\n- $w'(v_1, v_3) = w(v_1, v_3) + c(v_3) = 2 + 2 = 4$\n- $w'(v_2, v_3) = w(v_2, v_3) + c(v_3) = 1 + 2 = 3$\n- $w'(v_2, v_4) = w(v_2, v_4) + c(v_4) = 5 + 5 = 10$\n- $w'(v_2, v_5) = w(v_2, v_5) + c(v_5) = 7 + 1 = 8$\n- $w'(v_3, v_4) = w(v_3, v_4) + c(v_4) = 8 + 5 = 13$\n- $w'(v_3, v_5) = w(v_3, v_5) + c(v_5) = 10 + 1 = 11$\n- $w'(v_3, v_6) = w(v_3, v_6) + c(v_6) = 4 + 3 = 7$\n- $w'(v_4, v_5) = w(v_4, v_5) + c(v_5) = 2 + 1 = 3$\n- $w'(v_4, v_6) = w(v_4, v_6) + c(v_6) = 6 + 3 = 9$\n- $w'(v_5, v_6) = w(v_5, v_6) + c(v_6) = 2 + 3 = 5$\n- $w'(v_5, v_7) = w(v_5, v_7) + c(v_7) = 5 + 6 = 11$\n- $w'(v_6, v_7) = w(v_6, v_7) + c(v_7) = 1 + 6 = 7$\n\n**在 $G'$ 上从 $v_1$ 开始运行Dijkstra算法：**\n设 $d'[v]$ 为在 $G'$ 中从 $v_1$ 到 $v \\in V$ 的最短距离。\n1. 初始化：$d'[v_1]=0$, $d'[v_i]=\\infty$ 对于 $i \\in \\{2, \\dots, 7\\}$。优先队列 $Q=\\{(0, v_1)\\}$。\n2. 提取 $v_1$ ($d'[v_1]=0$)。\n   - 松弛 $(v_1,v_2)$: $d'[v_2] = 0 + 8 = 8$。\n   - 松弛 $(v_1,v_3)$: $d'[v_3] = 0 + 4 = 4$。\n   $d' = [0, 8, 4, \\infty, \\infty, \\infty, \\infty]$。$Q=\\{(4, v_3), (8, v_2)\\}$。\n3. 提取 $v_3$ ($d'[v_3]=4$)。\n   - 松弛 $(v_3,v_4)$: $d'[v_4] = \\min(\\infty, 4 + 13) = 17$。\n   - 松弛 $(v_3,v_5)$: $d'[v_5] = \\min(\\infty, 4 + 11) = 15$。\n   - 松弛 $(v_3,v_6)$: $d'[v_6] = \\min(\\infty, 4 + 7) = 11$。\n   $d' = [0, 8, 4, 17, 15, 11, \\infty]$。$Q=\\{(8, v_2), (11, v_6), (15, v_5), (17, v_4)\\}$。\n4. 提取 $v_2$ ($d'[v_2]=8$)。\n   - 松弛 $(v_2,v_3)$: $d'[v_3]=\\min(4, 8+3)=4$。无变化。\n   - 松弛 $(v_2,v_4)$: $d'[v_4]=\\min(17, 8+10)=17$。无变化。\n   - 松弛 $(v_2,v_5)$: $d'[v_5]=\\min(15, 8+8)=15$。无变化。\n   $Q=\\{(11, v_6), (15, v_5), (17, v_4)\\}$。\n5. 提取 $v_6$ ($d'[v_6]=11$)。\n   - 松弛 $(v_6,v_7)$: $d'[v_7] = \\min(\\infty, 11 + 7) = 18$。\n   $d' = [0, 8, 4, 17, 15, 11, 18]$。$Q=\\{(15, v_5), (17, v_4), (18, v_7)\\}$。\n6. 提取 $v_5$ ($d'[v_5]=15$)。\n   - 松弛 $(v_5,v_6)$: $v_6$ 已确定。\n   - 松弛 $(v_5,v_7)$: $d'[v_7]=\\min(18, 15+11)=18$。无变化。\n   $Q=\\{(17, v_4), (18, v_7)\\}$。\n7. 提取 $v_4$ ($d'[v_4]=17$)。\n   - 邻居 $v_5, v_6$ 已确定。无变化。\n   $Q=\\{(18, v_7)\\}$。\n8. 提取 $v_7$ ($d'[v_7]=18$)。算法终止。\n\n在转换后的图中，从 $v_1$ 到 $v_7$ 的最短路径距离是 $d'(v_1, v_7) = 18$。\n\n**最终成本计算：**\n原始问题中的最小路径成本由 $C_{min} = d'(v_1, v_7) - c(v_7)$ 给出。\n已知 $c(v_7) = 6$，我们求得：\n$$\nC_{min} = 18 - 6 = 12\n$$\n产生此成本的路径是 $\\langle v_1, v_3, v_6, v_7 \\rangle$。我们可以用原始公式验证其成本：\n$C(P) = (w(v_1,v_3)+w(v_3,v_6)+w(v_6,v_7)) + (c(v_3)+c(v_6)) = (2+4+1) + (2+3) = 7+5=12$。\n结果一致。",
            "answer": "$$\\boxed{12}$$"
        },
        {
            "introduction": "网络路由和物流规划等真实系统是动态变化的，边的权重（如延迟或成本）会随时间改变。每次变化后都从头重新计算所有最短路径是非常低效的。这个练习将带你探索一个更高级的主题：动态更新。你将学习如何利用现有的最短路径树（SPT）信息，在某条边的权重减少后，高效地局部更新路径和距离，而不是进行全局重新计算。",
            "id": "3270914",
            "problem": "考虑一个有向图 $G = (V, E)$，其边权重由函数 $w : E \\to \\mathbb{R}_{\\ge 0}$ 给出，均为非负值，并有一个指定的源顶点 $s \\in V$。最短路径树 (SPT) 定义为一个前驱映射 $\\pi : V \\to V \\cup \\{\\text{nil}\\}$，使得有向边集合 $\\{(\\pi(v), v) : v \\in V, \\pi(v) \\neq \\text{nil}\\}$ 构成一个以 $s$ 为根的有向生成树，并且相关的路径距离 $d : V \\to \\mathbb{R}_{\\ge 0} \\cup \\{\\infty\\}$ 满足：对于每个顶点 $v \\in V$，在该树中从 $s$ 到 $v$ 的路径总权重恰好为 $d(v)$，并且该值等于所有从 $s$ 到 $v$ 的有向路径中的最小值。\n\n目标是设计并实现一个程序，该程序在给定图 $G$ 相对于源点 $s$ 的一个 SPT 的情况下，当某条有向边 $(u, v) \\in E$ 的权重减小到一个新值 $w'(u, v)$（满足 $0 \\le w'(u, v)  w(u, v)$）后，能够更新此 SPT，而不是从头进行完全的重新计算。更新过程应依赖于最短路径的基本性质以及在非负权重下松弛操作的行为，并且必须通过复用现有的距离 $d(\\cdot)$ 和前驱 $\\pi(\\cdot)$ 来操作，而不是像没有任何已知信息一样重新初始化所有结构。更新后的 SPT 必须反映新的最短路径距离 $d'(\\cdot)$ 和更新后的前驱映射 $\\pi'(\\cdot)$。\n\n推导的基本依据：\n- 非负权重下最短路径距离的定义。\n- 最短路径的最优子结构：如果从 $s$到 $y$ 的一条路径是最短的，那么它从 $s$ 到任何中间顶点 $x$ 的任何前缀也都是最短的。\n- 松弛不变量：对于任意边 $(x, y) \\in E$，在有效的 SPT 中必须满足不等式 $d(y) \\le d(x) + w(x, y)$；当一条边的权重减少时，只有那些其最短路径可以通过遍历该边或从其头部可达的路径得到改善的顶点才可能发生变化。\n\n你的程序必须使用正确的非负权重算法计算从 $s$ 出发的初始最短路径距离，然后在满足 $d(u) + w'(u, v)  d(v)$ 的情况下，应用单边权重减少的更新步骤，该步骤仅使用以 $v$ 为起点的局部松弛操作，并通过一个最小优先队列将改进传播到受影响的顶点，直到没有改进的可能。程序不得从头开始重新运行完整的计算。\n\n你的程序必须是自包含的，并且不得读取输入。请使用以下测试套件，其中每个测试用例由顶点数、带权重的边列表、一个源顶点以及由 $(u, v, w')$ 指定的单边权重减少来规定。顶点由从 0 开始的整数索引。\n\n测试套件：\n- 测试用例 1：$|V| = 6$，$s = 0$，边以三元组 $(x, y, w)$ 列表形式给出：\n  $(0, 1, 7)$, $(0, 2, 9)$, $(0, 5, 14)$, $(1, 2, 10)$, $(1, 3, 15)$, $(2, 3, 11)$, $(2, 5, 2)$, $(3, 4, 6)$, $(5, 4, 9)$。将边 $(1, 2)$ 的权重减小到 $w' = 1$。\n- 测试用例 2：$|V| = 6$，$s = 0$，边与测试用例 1 相同。将边 $(3, 4)$ 的权重减小到 $w' = 4$。\n- 测试用例 3：$|V| = 6$，$s = 0$，边与测试用例 1 相同。将边 $(0, 2)$ 的权重减小到 $w' = 2$。\n\n对于每个测试用例，计算应用单边权重减少后更新的最短路径距离列表 $[d'(0), d'(1), \\dots, d'(5)]$。在这些用例中，所有距离都是整数。最终输出格式必须是单行，包含所有测试用例的结果，聚合为一个由方括号括起来的逗号分隔列表，其中每个测试用例的结果本身就是一个由方括号括起来的逗号分隔的整数列表。也就是说，输出必须采用 $[\\,[d'_0^{(1)}, d'_1^{(1)}, \\dots],\\,[d'_0^{(2)}, d'_1^{(2)}, \\dots],\\,[d'_0^{(3)}, d'_1^{(3)}, \\dots]\\,]$ 的形式，不含任何额外的空格或文本。",
            "solution": "用户提供的问题是有效的。它在科学上基于图论和算法设计的既定原则，特别是关于带非负边权重的有向图中的单源最短路径问题。该问题提法明确（well-posed），目标清晰，提供了所有必要的数据，且没有内部矛盾。它要求实现一个标准且高效的算法，用于在单条边权重减少后更新最短路径树 (SPT)，这在计算机科学中是一项非平凡但已被充分理解的任务。\n\n解决方案分两个阶段进行：首先，计算初始的最短路径树；其次，在一条边权重减少后增量更新此树。\n\n### 1. 初始最短路径树的计算\n\n给定一个有向图 $G = (V, E)$、一个非负权重函数 $w : E \\to \\mathbb{R}_{\\ge 0}$ 和一个源顶点 $s \\in V$，单源最短路径问题是为每个顶点 $v \\in V$ 找到从 $s$ 到 $v$ 的总权重最小的路径。这样一条路径的权重记为 $d(v)$。\n\n由于所有边权重都是非负的，Dijkstra 算法是完成此任务的经典且最高效的方法。该算法维护一个顶点集合，其中包含了已确定其到源点最短路径的顶点。它迭代地选择一个尚未最终确定且已知到 $s$ 距离最小的顶点 $u$。一旦选定，$u$ 就被视为已最终确定，其所有出边 $(u, v)$ 都会被“松弛”：如果通过 $u$ 发现了到任何邻居 $v$ 的更短路径（即，如果 $d(u) + w(u, v)  d(v)$），则更新距离 $d(v)$ 和前驱 $\\pi(v)$。通常使用最小优先队列来在每一步高效地选择具有最小距离的顶点。\n\n该算法流程如下：\n1. 初始化一个距离数组 $d$，使得 $d(s) = 0$ 且对于所有 $v \\neq s$ 都有 $d(v) = \\infty$。\n2. 初始化一个前驱数组 $\\pi$，使得对于所有 $v \\in V$ 都有 $\\pi(v) = \\text{nil}$。\n3. 初始化一个包含所有顶点的最小优先队列 $Q$，使用 $d$ 中的值作为键。\n4. 当 $Q$ 不为空时：\n   a. 从 $Q$ 中提取具有最小距离的顶点 $u$。\n   b. 对于每个与 $u$ 相邻的顶点 $v$（即，对于每条边 $(u, v) \\in E$）：\n      i. 执行松弛操作：如果 $d(u) + w(u, v)  d(v)$，则更新 $d(v) \\leftarrow d(u) + w(u, v)$ 和 $\\pi(v) \\leftarrow u$。必须更新优先队列 $Q$ 以反映 $v$ 的新距离。\n\n算法终止时，$d(v)$ 将保存从 $s$ 到所有顶点 $v \\in V$ 的最短路径距离，而 $\\pi$ 将定义 SPT。\n\n### 2. 边权重减少后更新最短路径树\n\n假设我们有一个已存在的 SPT，由距离数组 $d$ 和前驱映射 $\\pi$ 表示。给定一条边 $(u, v) \\in E$ 的权重从 $w(u, v)$ 减少到 $w'(u, v)$，其中 $0 \\le w'(u, v)  w(u, v)$。\n\n对于带非负权重的图，最短路径的一个重要性质是，边权重的减少只可能潜在地减少到其他顶点的最短路径距离；它永远不会导致距离增加。所有先前计算的最短路径仍然是有效的路径，尽管它们可能不再是最短的。\n\n只有当修改后的边 $(u, v)$ 提供了一条比之前已知的路径更短的到达顶点 $v$ 的路径时，才会触发对 SPT 的更新。到 $v$ 的新潜在路径是从 $s$ 到 $u$（成本为 $d(u)$），然后经过修改后的边 $(u, v)$（成本为 $w'(u, v)$）。因此，出现改进的条件是：\n$$d(u) + w'(u, v)  d(v)$$\n\n- 如果此条件为**假**，那么到 $v$ 的旧最短路径仍然优于或等于任何通过修改后边 $(u, v)$ 的新路径。因此，到所有其他顶点的最短路径也不受影响，SPT 保持不变。新的距离 $d'$ 与旧的距离 $d$ 相同。\n\n- 如果此条件为**真**，我们找到了到顶点 $v$ 的一条新最短路径。我们必须更新它的距离和前驱：\n$$d'(v) \\leftarrow d(u) + w'(u, v)$$\n$$\\pi'(v) \\leftarrow u$$\n到 $v$ 的距离的这一改进，可能反过来为从 $v$ 可达的顶点创造出更短的路径。对于 $v$ 的任何邻居 $z$，路径 $s \\to \\dots \\to u \\to v \\to z$ 现在可能比到 $z$ 的现有最短路径更短。\n\n这种距离改进的传播在结构上与 Dijkstra 算法本身的过程相同。因此，我们可以执行一次高效的局部更新。我们可以从距离首次得到改善的顶点 $v$ 开始，启动一个类似 Dijkstra 的过程，而不是在整个图上从源点 $s$ 重新运行 Dijkstra 算法。\n\n更新算法如下：\n1. 设初始 SPT 由距离 $d$ 和前驱 $\\pi$ 给出。\n2. 设边 $(u, v)$ 的权重减少到 $w'(u, v)$。更新图中该权重的内部表示。\n3. 检查触发条件。如果 $d(u) + w'(u, v)  d(v)$：\n   a. 更新距离数组：$d(v) \\leftarrow d(u) + w'(u, v)$。\n   b. 更新前驱数组：$\\pi(v) \\leftarrow u$。\n   c. 初始化一个最小优先队列 $Q_{update}$ 并将 $v$ 插入其中。\n   d. 当 $Q_{update}$ 不为空时：\n      i. 从 $Q_{update}$ 中提取具有最小距离的顶点 $x$。\n      ii. 对于 $x$ 的每个邻居 $y$，松弛边 $(x, y)$：如果 $d(x) + w(x, y)  d(y)$，则更新 $d(y) \\leftarrow d(x) + w(x, y)$，设置 $\\pi(y) \\leftarrow x$，并在 $Q_{update}$ 中添加或更新 $y$ 及其新的、更低的距离。\n4. 如果步骤 3 中的触发条件不满足，则无需任何更改。最终的距离数组 $d'$ 就是（现已更新的）数组 $d$。\n\n这个过程比完全重新计算更高效，因为它只处理那些最短路径确实受到边权重减少影响的顶点。\n\n### 测试用例应用\n\n让我们将此逻辑应用于测试用例 1：$|V| = 6$，$s = 0$，边集为 $\\{(0, 1, 7), (0, 2, 9), (0, 5, 14), (1, 2, 10), (1, 3, 15), (2, 3, 11), (2, 5, 2), (3, 4, 6), (5, 4, 9)\\}$。\n1.  **初始 Dijkstra**：从 $s=0$ 出发的初始最短路径距离计算为 $d = [0, 7, 9, 20, 20, 11]$。\n2.  **边权重减少**：边 $(1, 2)$ 的权重减少到 $w'(1, 2) = 1$。\n3.  **更新**：\n    a. 检查条件：$d(1) + w'(1, 2)  d(2)$ 变为 $7 + 1  9$，即 $8  9$。条件为真。\n    b. 更新 $d(2) \\leftarrow 8$。用顶点 $2$ 初始化 $Q_{update}$。\n    c. 提取 $2$ (成本 $8$)。松弛其出边：\n       - $(2, 3)$: $d(2) + w(2, 3) = 8 + 11 = 19$。由于 $19  d(3)=20$，更新 $d(3) \\leftarrow 19$ 并将 $3$ 添加到 $Q_{update}$。\n       - $(2, 5)$: $d(2) + w(2, 5) = 8 + 2 = 10$。由于 $10  d(5)=11$，更新 $d(5) \\leftarrow 10$ 并将 $5$ 添加到 $Q_{update}$。\n    d. $Q_{update}$ 现在包含 $\\{ (10, 5), (19, 3) \\}$。提取 $5$ (成本 $10$)。松弛其出边：\n       - $(5, 4)$: $d(5) + w(5, 4) = 10 + 9 = 19$。由于 $19  d(4)=20$，更新 $d(4) \\leftarrow 19$ 并将 $4$ 添加到 $Q_{update}$。\n    e. $Q_{update}$ 现在包含 $\\{ (19, 3), (19, 4) \\}$。提取 $3$ (成本 $19$)。松弛其出边：\n       - $(3, 4)$: $d(3) + w(3, 4) = 19 + 6 = 25$。由于 $25 \\not d(4)=19$，不更新。\n    f. 提取 $4$ (成本 $19$)。没有出边可以松弛。\n    g. $Q_{update}$ 为空。过程终止。\n4.  **最终距离**：更新后的距离数组为 $d' = [0, 7, 8, 19, 19, 10]$。\n\n类似的分析可以得出其他测试用例的结果。对于测试用例 2，触发条件未满足，因此距离保持不变。对于测试用例 3，触发条件被满足，并发生类似的更新传播。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport heapq\n\ndef solve():\n    \"\"\"\n    Solves the shortest path tree update problem for a given test suite.\n    \"\"\"\n\n    # Dijkstra's algorithm for SSSP on graphs with non-negative weights.\n    def dijkstra(num_vertices, edges, source):\n        adj = [[] for _ in range(num_vertices)]\n        for u, v, w in edges:\n            adj[u].append((v, w))\n        \n        dist = np.full(num_vertices, np.inf)\n        pred = np.full(num_vertices, -1, dtype=int)\n        \n        dist[source] = 0\n        pq = [(0, source)]\n        \n        while pq:\n            d, u = heapq.heappop(pq)\n            \n            if d > dist[u]:\n                continue\n            \n            for v, weight in adj[u]:\n                if dist[u] + weight  dist[v]:\n                    dist[v] = dist[u] + weight\n                    pred[v] = u\n                    heapq.heappush(pq, (dist[v], v))\n        \n        # Convert infinities to a large number if needed for integer output,\n        # but the test cases are all connected.\n        return dist.astype(int), pred\n\n    # Test suite definition\n    test_suite = [\n        {\n            \"num_vertices\": 6,\n            \"source\": 0,\n            \"edges\": [\n                (0, 1, 7), (0, 2, 9), (0, 5, 14), (1, 2, 10), (1, 3, 15),\n                (2, 3, 11), (2, 5, 2), (3, 4, 6), (5, 4, 9)\n            ],\n            \"decrease\": (1, 2, 1)\n        },\n        {\n            \"num_vertices\": 6,\n            \"source\": 0,\n            \"edges\": [\n                (0, 1, 7), (0, 2, 9), (0, 5, 14), (1, 2, 10), (1, 3, 15),\n                (2, 3, 11), (2, 5, 2), (3, 4, 6), (5, 4, 9)\n            ],\n            \"decrease\": (3, 4, 4)\n        },\n        {\n            \"num_vertices\": 6,\n            \"source\": 0,\n            \"edges\": [\n                (0, 1, 7), (0, 2, 9), (0, 5, 14), (1, 2, 10), (1, 3, 15),\n                (2, 3, 11), (2, 5, 2), (3, 4, 6), (5, 4, 9)\n            ],\n            \"decrease\": (0, 2, 2)\n        }\n    ]\n\n    results = []\n\n    for case in test_suite:\n        num_v = case[\"num_vertices\"]\n        edges = case[\"edges\"]\n        source = case[\"source\"]\n        u_dec, v_dec, w_prime = case[\"decrease\"]\n        \n        # 1. Compute initial SPT distances\n        initial_dist, initial_pred = dijkstra(num_v, edges, source)\n        \n        # Make a mutable copy for the update process\n        updated_dist = initial_dist.copy()\n        \n        # Build adjacency list with original weights for propagation\n        adj = [[] for _ in range(num_v)]\n        current_edges = { (u, v): w for u, v, w in edges }\n        \n        # Apply the weight decrease\n        current_edges[(u_dec, v_dec)] = w_prime\n        \n        for (u, v), w in current_edges.items():\n            adj[u].append((v, w))\n\n        # 2. Check update condition and propagate if necessary\n        if updated_dist[u_dec] + w_prime  updated_dist[v_dec]:\n            updated_dist[v_dec] = updated_dist[u_dec] + w_prime\n            \n            # 3. Propagate updates using a Dijkstra-like process\n            pq_update = [(updated_dist[v_dec], v_dec)]\n            \n            while pq_update:\n                d, x = heapq.heappop(pq_update)\n\n                if d > updated_dist[x]:\n                    continue\n                \n                for y, weight in adj[x]:\n                    if updated_dist[x] + weight  updated_dist[y]:\n                        updated_dist[y] = updated_dist[x] + weight\n                        heapq.heappush(pq_update, (updated_dist[y], y))\n        \n        results.append(list(updated_dist))\n\n    # Format the final output string exactly as required\n    inner_strings = [f\"[{','.join(map(str, res))}]\" for res in results]\n    final_output = f\"[{','.join(inner_strings)}]\"\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}