{
    "hands_on_practices": [
        {
            "introduction": "Finding the shortest path between two points is a fundamental task. However, real-world applications often add constraints, such as requiring a path to pass through a specific intermediate point. This exercise  explores how to handle such constraints by cleverly decomposing the problem. By breaking the journey into two separate shortest path calculations and combining the results, you can solve the constrained problem using the foundational algorithm for DAGs, reinforcing the core dynamic programming relaxation technique.",
            "id": "3271259",
            "problem": "Consider the following weighted Directed Acyclic Graph (DAG) with vertices $s$, $a$, $b$, $c$, $m$, $d$, $e$, $f$, $g$, $t$. The directed edges and their weights are specified as follows: there is a directed edge $s \\to a$ of weight $3$, a directed edge $s \\to b$ of weight $2$, a directed edge $a \\to c$ of weight $2$, a directed edge $a \\to m$ of weight $5$, a directed edge $b \\to c$ of weight $-1$, a directed edge $b \\to d$ of weight $4$, a directed edge $c \\to m$ of weight $1$, a directed edge $c \\to e$ of weight $3$, a directed edge $m \\to f$ of weight $-2$, a directed edge $m \\to d$ of weight $0$, a directed edge $d \\to e$ of weight $-3$, a directed edge $d \\to g$ of weight $2$, a directed edge $e \\to f$ of weight $4$, a directed edge $e \\to t$ of weight $7$, a directed edge $f \\to g$ of weight $1$, a directed edge $f \\to t$ of weight $-1$, and a directed edge $g \\to t$ of weight $2$. All edge weights are real numbers, including negative values, and the graph has no directed cycles.\n\nUsing only the foundational definitions of shortest paths and Directed Acyclic Graphs (DAGs), determine the total weight of the shortest path from $s$ to $t$ that is constrained to pass through the intermediate vertex $m$. Express your final answer as an exact real number, with no rounding.",
            "solution": "The fundamental basis is as follows. A Directed Acyclic Graph (DAG) is a directed graph with no directed cycles. In a DAG, shortest paths with real-valued edge weights (including negative values) can be computed in linear time using dynamic programming along any topological ordering of the vertices. Let $w(u,v)$ denote the edge weight from vertex $u$ to vertex $v$. Define the shortest-path distance from a source vertex $s$ to a vertex $v$ as $d_{s}(v)$, with $d_{s}(s)=0$ and $d_{s}(v)=+\\infty$ initially for other vertices. Processing vertices in a topological order, for each edge $u \\to v$ one applies the relaxation $d_{s}(v) \\leftarrow \\min\\{d_{s}(v), d_{s}(u) + w(u,v)\\}$. The absence of cycles ensures that once a vertex is processed, its finalized distance will not be improved by future relaxations.\n\nTo enforce that the path from $s$ to $t$ must pass through $m$, any such path can be decomposed uniquely into a prefix from $s$ to $m$ followed by a suffix from $m$ to $t$. The total weight is additive: if the prefix has weight $d_{s}(m)$ and the suffix has weight $d_{m}(t)$, the total is $d_{s}(m) + d_{m}(t)$. Minimizing the sum over all $s \\to m$ prefixes and $m \\to t$ suffixes independently yields the overall minimum because the choice of prefix and suffix are independent and the sum is separable.\n\nWe therefore compute $d_{s}(m)$ and $d_{m}(t)$ via dynamic programming in a topological order. One valid topological order consistent with the edges is $s, a, b, c, m, d, e, f, g, t$.\n\nCompute $d_{s}(\\cdot)$:\n- Initialize $d_{s}(s)=0$ and $d_{s}(v)=+\\infty$ for all other vertices $v$.\n- Process $s$: relax $s \\to a$ with weight $3$, so $d_{s}(a)=\\min\\{+\\infty, 0+3\\}=3$. Relax $s \\to b$ with weight $2$, so $d_{s}(b)=\\min\\{+\\infty, 0+2\\}=2$.\n- Process $a$: relax $a \\to c$ with weight $2$, so $d_{s}(c)=\\min\\{+\\infty, 3+2\\}=5$. Relax $a \\to m$ with weight $5$, so $d_{s}(m)=\\min\\{+\\infty, 3+5\\}=8$.\n- Process $b$: relax $b \\to c$ with weight $-1$, so $d_{s}(c)=\\min\\{5, 2+(-1)\\}=1$. Relax $b \\to d$ with weight $4$, so $d_{s}(d)=\\min\\{+\\infty, 2+4\\}=6$.\n- Process $c$: relax $c \\to m$ with weight $1$, so $d_{s}(m)=\\min\\{8, 1+1\\}=2$. Relax $c \\to e$ with weight $3$, so $d_{s}(e)=\\min\\{+\\infty, 1+3\\}=4$.\n- Process $m$: relax $m \\to f$ with weight $-2$, so $d_{s}(f)=\\min\\{+\\infty, 2+(-2)\\}=0$. Relax $m \\to d$ with weight $0$, so $d_{s}(d)=\\min\\{6, 2+0\\}=2$.\n- Process $d$: relax $d \\to e$ with weight $-3$, so $d_{s}(e)=\\min\\{4, 2+(-3)\\}=-1$. Relax $d \\to g$ with weight $2$, so $d_{s}(g)=\\min\\{+\\infty, 2+2\\}=4$.\n- Process $e$: relax $e \\to f$ with weight $4$, so $d_{s}(f)=\\min\\{0, -1+4\\}=0$. Relax $e \\to t$ with weight $7$, so $d_{s}(t)=\\min\\{+\\infty, -1+7\\}=6$.\n- Process $f$: relax $f \\to g$ with weight $1$, so $d_{s}(g)=\\min\\{4, 0+1\\}=1$. Relax $f \\to t$ with weight $-1$, so $d_{s}(t)=\\min\\{6, 0+(-1)\\}=-1$.\n- Process $g$: relax $g \\to t$ with weight $2$, so $d_{s}(t)=\\min\\{-1, 1+2\\}=-1$.\n\nThus, $d_{s}(m)=2$.\n\nCompute $d_{m}(\\cdot)$ starting from $m$ (restrict attention to vertices reachable from $m$ in the same topological order $m, d, e, f, g, t$):\n- Initialize $d_{m}(m)=0$ and $d_{m}(v)=+\\infty$ for other vertices $v$.\n- Process $m$: relax $m \\to f$ with weight $-2$, so $d_{m}(f)=\\min\\{+\\infty, 0+(-2)\\}=-2$. Relax $m \\to d$ with weight $0$, so $d_{m}(d)=\\min\\{+\\infty, 0+0\\}=0$.\n- Process $d$: relax $d \\to e$ with weight $-3$, so $d_{m}(e)=\\min\\{+\\infty, 0+(-3)\\}=-3$. Relax $d \\to g$ with weight $2$, so $d_{m}(g)=\\min\\{+\\infty, 0+2\\}=2$.\n- Process $e$: relax $e \\to f$ with weight $4$, so $d_{m}(f)=\\min\\{-2, -3+4\\}=-2$. Relax $e \\to t$ with weight $7$, so $d_{m}(t)=\\min\\{+\\infty, -3+7\\}=4$.\n- Process $f$: relax $f \\to g$ with weight $1$, so $d_{m}(g)=\\min\\{2, -2+1\\}=-1$. Relax $f \\to t$ with weight $-1$, so $d_{m}(t)=\\min\\{4, -2+(-1)\\}=-3$.\n- Process $g$: relax $g \\to t$ with weight $2$, so $d_{m}(t)=\\min\\{-3, -1+2\\}=-3$.\n\nThus, $d_{m}(t)=-3$.\n\nBy additivity, the shortest $s \\to t$ path constrained to pass through $m$ has total weight $d_{s}(m) + d_{m}(t) = 2 + (-3) = -1$. Therefore, the exact real-valued answer is $-1$.",
            "answer": "$$\\boxed{-1}$$"
        },
        {
            "introduction": "While knowing the minimum cost or distance is valuable, understanding the landscape of optimal solutions offers deeper insight. For instance, are there multiple ways to achieve the best outcome? This practice  moves beyond just finding the length of the shortest path to counting how many distinct shortest paths exist. You will learn to augment the standard dynamic programming algorithm to track not only the minimum distance but also the number of paths that achieve it, a technique crucial for applications like resilient network design.",
            "id": "3271300",
            "problem": "You are given a weighted Directed Acyclic Graph (DAG) with source vertex $s$ and target vertex $t$. A pathâ€™s length is defined as the sum of the weights of its constituent edges. Using only the fundamental definitions of path length and the existence of a topological ordering in a Directed Acyclic Graph, determine the number of distinct shortest paths from $s$ to $t$.\n\nThe vertex set is $\\{s,a,b,c,d,e,f,g,h,t\\}$, and the edge set with weights is as follows:\n- $s \\to a$ with weight $2$\n- $s \\to b$ with weight $2$\n- $s \\to c$ with weight $3$\n- $a \\to d$ with weight $2$\n- $a \\to e$ with weight $3$\n- $a \\to f$ with weight $3$\n- $b \\to d$ with weight $2$\n- $b \\to e$ with weight $3$\n- $b \\to f$ with weight $3$\n- $c \\to e$ with weight $2$\n- $c \\to f$ with weight $2$\n- $d \\to g$ with weight $2$\n- $d \\to h$ with weight $4$\n- $d \\to t$ with weight $8$\n- $e \\to g$ with weight $1$\n- $e \\to h$ with weight $2$\n- $e \\to t$ with weight $3$\n- $f \\to g$ with weight $0$\n- $f \\to h$ with weight $1$\n- $f \\to t$ with weight $5$\n- $g \\to t$ with weight $3$\n- $h \\to t$ with weight $2$\n\nCompute the number of distinct shortest $s$ to $t$ paths. Report your final answer as a single integer. No rounding is required.",
            "solution": "We begin from core definitions. In a weighted directed graph, the length of a path is the sum of the weights of its edges. In a Directed Acyclic Graph (DAG), there exists a topological ordering of vertices, and shortest-path distances from a source $s$ to all vertices can be computed by processing vertices in such an order and relaxing outgoing edges. Specifically, if $d(u)$ denotes the currently known shortest distance from $s$ to $u$, then for each edge $u \\to v$ of weight $w(u,v)$, we set $d(v) \\leftarrow \\min\\{d(v),\\, d(u)+w(u,v)\\}$. To count the number of distinct shortest paths, we maintain $c(u)$, the number of distinct shortest paths from $s$ to $u$. Initialization is $d(s)=0$, $c(s)=1$, and for all other vertices $x$, $d(x)=+\\infty$, $c(x)=0$. When relaxing $u \\to v$:\n- If $d(u)+w(u,v) < d(v)$, then set $d(v) = d(u)+w(u,v)$ and $c(v) = c(u)$.\n- If $d(u)+w(u,v) = d(v)$, then add $c(u)$ to $c(v)$, i.e., $c(v) \\leftarrow c(v) + c(u)$.\n\nWe now execute this dynamic program in a valid topological order. From the given edges, one valid order is $s, a, b, c, d, e, f, g, h, t$.\n\nInitialization:\n- $d(s)=0$, $c(s)=1$.\n- For all other vertices $x \\in \\{a,b,c,d,e,f,g,h,t\\}$, $d(x)=+\\infty$, $c(x)=0$.\n\nProcess $s$:\n- Edge $s \\to a$ with weight $2$: $d(a)=2$, $c(a)=1$.\n- Edge $s \\to b$ with weight $2$: $d(b)=2$, $c(b)=1$.\n- Edge $s \\to c$ with weight $3$: $d(c)=3$, $c(c)=1$.\n\nProcess $a$ with $d(a)=2$, $c(a)=1$:\n- $a \\to d$ with weight $2$: $d(d)=4$, $c(d)=1$.\n- $a \\to e$ with weight $3$: $d(e)=5$, $c(e)=1$.\n- $a \\to f$ with weight $3$: $d(f)=5$, $c(f)=1$.\n\nProcess $b$ with $d(b)=2$, $c(b)=1$:\n- $b \\to d$ with weight $2$: candidate distance $4$ equals current $d(d)=4$, so $c(d) \\leftarrow 1+1=2$.\n- $b \\to e$ with weight $3$: candidate distance $5$ equals current $d(e)=5$, so $c(e) \\leftarrow 1+1=2$.\n- $b \\to f$ with weight $3$: candidate distance $5$ equals current $d(f)=5$, so $c(f) \\leftarrow 1+1=2$.\n\nProcess $c$ with $d(c)=3$, $c(c)=1$:\n- $c \\to e$ with weight $2$: candidate distance $5$ equals current $d(e)=5$, so $c(e) \\leftarrow 2+1=3$.\n- $c \\to f$ with weight $2$: candidate distance $5$ equals current $d(f)=5$, so $c(f) \\leftarrow 2+1=3$.\n\nAt this point:\n- $d(d)=4$, $c(d)=2$.\n- $d(e)=5$, $c(e)=3$.\n- $d(f)=5$, $c(f)=3$.\n\nProcess $d$ with $d(d)=4$, $c(d)=2$:\n- $d \\to g$ with weight $2$: $d(g)=6$, $c(g)=2$.\n- $d \\to h$ with weight $4$: $d(h)=8$, $c(h)=2$.\n- $d \\to t$ with weight $8$: $d(t)=12$, $c(t)=2$.\n\nProcess $e$ with $d(e)=5$, $c(e)=3$:\n- $e \\to g$ with weight $1$: candidate $6$ equals current $d(g)=6$, so $c(g) \\leftarrow 2+3=5$.\n- $e \\to h$ with weight $2$: candidate $7$ improves $d(h)=8$, so set $d(h)=7$, $c(h)=3$.\n- $e \\to t$ with weight $3$: candidate $8$ improves $d(t)=12$, so set $d(t)=8$, $c(t)=3$.\n\nProcess $f$ with $d(f)=5$, $c(f)=3$:\n- $f \\to g$ with weight $0$: candidate $5$ improves $d(g)=6$, so set $d(g)=5$, $c(g)=3$.\n- $f \\to h$ with weight $1$: candidate $6$ improves $d(h)=7$, so set $d(h)=6$, $c(h)=3$.\n- $f \\to t$ with weight $5$: candidate $10$ is worse than $d(t)=8$, so no change.\n\nProcess $g$ with $d(g)=5$, $c(g)=3$:\n- $g \\to t$ with weight $3$: candidate $8$ equals current $d(t)=8$, so $c(t) \\leftarrow 3+3=6$.\n\nProcess $h$ with $d(h)=6$, $c(h)=3$:\n- $h \\to t$ with weight $2$: candidate $8$ equals current $d(t)=8$, so $c(t) \\leftarrow 6+3=9$.\n\nProcess $t$ concludes.\n\nTherefore the shortest-path distance is $d(t)=8$, and the number of distinct shortest $s$ to $t$ paths is $c(t)=9$. Concretely, there are three shortest paths through $e \\to t$ (since $e$ has three shortest ways from $s$), and six shortest paths through $f$ split as three via $f \\to g \\to t$ and three via $f \\to h \\to t$, totaling $9$ distinct shortest paths.",
            "answer": "$$\\boxed{9}$$"
        },
        {
            "introduction": "In many networks, some nodes are more critical than others; a node is a true bottleneck if every optimal path must pass through it. This final practice  provides a powerful synthesis of the previous concepts to algorithmically identify such critical vertices. To solve this, you will need to combine the logic for finding shortest path lengths with the method for counting them, demonstrating how different algorithmic tools can be integrated to answer complex structural questions about a graph.",
            "id": "3271249",
            "problem": "Consider a directed acyclic graph (DAG) with a finite set of vertices and weighted edges. Let the set of vertices be denoted by $V$ with $|V| = n$, and the set of directed edges be denoted by $E \\subseteq V \\times V$, where each edge $(u,v) \\in E$ carries an integer weight $w(u,v) \\in \\mathbb{Z}$. For any two vertices $s$ and $t$, define the shortest path weight from $s$ to $t$ as the minimum possible sum of weights along any directed path starting at $s$ and ending at $t$, if such a path exists. If no path exists, define the shortest path weight as $+\\infty$. Given a vertex $u$, the core question is to determine whether $u$ lies on every shortest path from $s$ to $t$.\n\nYour task is to design a program that, for each test case described below, returns a boolean indicating whether the given vertex $u$ lies on every shortest path from $s$ to $t$. The program must be derived from first principles appropriate to directed acyclic graphs, including the existence of a topological ordering and dynamic programming recurrences over such orders. If there is no path from $s$ to $t$, the answer must be $false$.\n\nThe input for your program is fixed and embedded within the program itself; no external input is permitted. Each test case is specified by:\n- The number of vertices $n$ labeled $0,1,\\dots,n-1$.\n- A list of directed, weighted edges of the form $(u,v,w)$ indicating an edge from $u$ to $v$ with weight $w$.\n- The source vertex $s$.\n- The target vertex $t$.\n- The query vertex $u$ to be tested.\n\nUse the following test suite, which is designed to probe general cases, boundary conditions, and significant edge cases. For each case, all numerical quantities are integers, and the graph is a DAG.\n\n- Test case $1$: $n=4$, edges $\\{(0,1,2),(1,3,2),(0,2,5),(2,3,1)\\}$, $s=0$, $t=3$, $u=1$. This is a case with a unique shortest path.\n- Test case $2$: $n=4$, edges $\\{(0,1,1),(1,3,1),(0,2,1),(2,3,1)\\}$, $s=0$, $t=3$, $u=1$. This is a case with multiple shortest paths of equal weight where the query vertex does not lie on all of them.\n- Test case $3$: $n=4$, edges $\\{(0,1,1),(1,3,2),(0,2,1),(2,3,1)\\}$, $s=0$, $t=3$, $u=1$. This is a case where the query vertex does not lie on any shortest path.\n- Test case $4$: $n=4$, edges $\\{(0,1,2),(1,3,2),(0,2,3),(2,3,-1)\\}$, $s=0$, $t=3$, $u=2$. This tests handling of negative edge weights in a DAG with a unique shortest path.\n- Test case $5$: $n=5$, edges $\\{(0,1,0),(1,2,0),(2,3,0),(0,4,0),(4,3,0)\\}$, $s=0$, $t=3$, $u=2$. This is a case with zero-weight edges and multiple shortest paths.\n- Test case $6$: $n=3$, edges $\\{(0,1,1)\\}$, $s=0$, $t=2$, $u=1$. This is a case where $t$ is unreachable from $s$.\n- Test case $7$: $n=1$, edges $\\{\\}$, $s=0$, $t=0$, $u=0$. This is a boundary case with $s=t$ and a single vertex.\n- Test case $8$: $n=2$, edges $\\{(0,1,1)\\}$, $s=0$, $t=0$, $u=1$. This tests $s=t$ with a query vertex different from $s$.\n- Test case $9$: $n=4$, edges $\\{(0,1,1),(1,2,1),(2,3,1)\\}$, $s=0$, $t=3$, $u=3$. This checks the trivial inclusion of the target vertex on every shortest path.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the same order as the test cases above, for example: $[result_1,result_2,\\dots,result_9]$, where each $result_i$ is either $true$ or $false$ (lowercase is not required; the program may use the native boolean representation of the language). No physical units or angles are involved, and all answers are booleans.",
            "solution": "The problem asks whether a given vertex $u$ is an intermediate vertex on *every* shortest path from a source vertex $s$ to a target vertex $t$ in a weighted, directed acyclic graph (DAG).\n\nFirst, let us formalize the necessary and sufficient conditions for a vertex $u$ to lie on every shortest path from $s$ to $t$.\n\nLet the graph be $G = (V, E)$, where $V$ is the set of vertices and $E$ is the set of weighted, directed edges. For any two vertices $x, y \\in V$, let $\\delta(x, y)$ denote the weight of the shortest path from $x$ to $y$. If no path exists, $\\delta(x, y) = \\infty$. Let $N_{SP}(x, y)$ denote the number of distinct shortest paths from $x$ to $y$.\n\nFor a vertex $u$ to lie on a shortest path from $s$ to $t$, the path must be decomposable into a shortest path from $s$ to $u$ and a shortest path from $u$ to $t$, with their combined weight equaling the overall shortest path weight from $s$ to $t$. This gives us our first condition:\n\n**Condition 1: Path Optimality**\nThe vertex $u$ lies on *at least one* shortest path from $s$ to $t$ if and only if the sum of the shortest path weights from $s$ to $u$ and from $u$ to $t$ equals the shortest path weight from $s$ to $t$.\n$$\n\\delta(s, u) + \\delta(u, t) = \\delta(s, t)\n$$\nIf this equality does not hold, or if any of the path weights are infinite (i.e., a path does not exist), then $u$ cannot lie on any shortest path from $s$ to $t$.\n\nFor $u$ to lie on *every* shortest path, we must ensure that no shortest path from $s$ to $t$ bypasses $u$. This can be quantified by counting the number of distinct shortest paths. The total number of shortest paths from $s$ to $t$ must be equal to the number of shortest paths that are forced to go through $u$. The number of shortest paths from $s$ to $t$ that pass through $u$ is the product of the number of shortest paths from $s$ to $u$ and the number of shortest paths from $u$ to $t$. This leads to our second condition:\n\n**Condition 2: Path Uniqueness through $u$**\nAssuming Condition 1 holds, the vertex $u$ lies on *every* shortest path from $s$ to $t$ if and only if the number of shortest paths from $s$ to $t$ is equal to the product of the number of shortest paths from $s$ to $u$ and the number of shortest paths from $u$ to $t$.\n$$\nN_{SP}(s, t) = N_{SP}(s, u) \\times N_{SP}(u, t)\n$$\n\nThe core of the algorithm is thus to compute the values $\\delta(x, y)$ and $N_{SP}(x, y)$ for the relevant pairs $(s,t)$, $(s,u)$, and $(u,t)$. Since the graph is a DAG, we can compute single-source shortest paths and path counts for all other vertices efficiently using dynamic programming over a topological sort of the graph.\n\n**Algorithm for Computing $\\delta$ and $N_{SP}$ from a source $x$:**\n1.  **Topological Sort:** Compute a topological ordering of the vertices in the graph $G$. This is possible because $G$ is a DAG. We can use Kahn's algorithm (based on in-degrees) or a depth-first search approach. Let the sorted sequence of vertices be $v_1, v_2, \\dots, v_n$.\n2.  **Initialization:** Create two arrays, `dist` and `count`, of size $|V|$. Initialize `dist[v] = \\infty` and `count[v] = 0$ for all $v \\in V$. For the source vertex $x$, set `dist[x] = 0` and `count[x] = 1$.\n3.  **Dynamic Programming:** Iterate through the vertices $v$ in the topological order. For each vertex $v$, relax its outgoing edges $(v, w) \\in E$:\n    *   If `dist[v] + weight(v, w)  dist[w]`: A new, shorter path to $w$ has been found through $v$. Update `dist[w]` to this new shorter distance and set `count[w]` to be equal to `count[v]`, as all shortest paths to $w$ now arrive via a shortest path to $v$.\n    $$\n    dist[w] \\leftarrow dist[v] + w(v, w)\n    $$\n    $$\n    count[w] \\leftarrow count[v]\n    $$\n    *   If `dist[v] + weight(v, w) == dist[w]`: Another set of paths of the same shortest length has been found. We add the number of shortest paths to $v$ to the current count for $w$.\n    $$\n    count[w] \\leftarrow count[w] + count[v]\n    $$\n\n**Overall Procedure:**\nTo solve the problem for a given test case $(n, \\text{edges}, s, t, u)$:\n1.  Compute the single-source shortest path distances and path counts from the source vertex $s$ to all other vertices. This yields arrays `dist_s` and `count_s`, corresponding to $\\delta(s, \\cdot)$ and $N_{SP}(s, \\cdot)$.\n2.  Check for reachability. According to the problem statement, if no path exists from $s$ to $t$, the answer is `false`. This corresponds to the case where `dist_s[t] = \\infty`.\n3.  Handle trivial cases. If a path from $s$ to $t$ exists:\n    *   If $u = s$ or $u = t$, then $u$ is trivially on every path from $s$ to $t$. The answer is `true`.\n    *   If $s = t$, the only path is the vertex itself. The condition becomes whether $u = s$. The answer is `true` if $u=s$ and `false` otherwise.\n4.  For the general, non-trivial case:\n    a. Compute the single-source shortest path distances and path counts from the vertex $u$. This yields arrays `dist_u` and `count_u`, corresponding to $\\delta(u, \\cdot)$ and $N_{SP}(u, \\cdot)$.\n    b. Check the Path Optimality condition: `dist_s[u] + dist_u[t] == dist_s[t]`.\n    c. Check the Path Uniqueness condition: `count_s[u] * count_u[t] == count_s[t]`.\n    d. The final answer is `true` if and only if both conditions are met. Otherwise, it is `false`. This logic also correctly handles cases where `dist_s[u]` or `dist_u[t]` are infinite, as the sum would not equal the finite `dist_s[t]`.\n\nThis complete procedure is robust and correctly handles all cases, including those with negative or zero-weight edges, as long as the graph remains a DAG.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import deque\n\ndef solve():\n    \"\"\"\n    Solves the problem for a fixed set of test cases.\n    For each case, determines if vertex u is on every shortest path from s to t.\n    \"\"\"\n\n    # Using a large integer to represent infinity.\n    # This avoids potential floating-point precision issues and aligns with integer weights.\n    INFINITY = np.iinfo(np.int64).max\n\n    def _get_shortest_paths_info(n, adj, source):\n        \"\"\"\n        Computes shortest path distances and counts from a source vertex in a DAG.\n        \n        This algorithm uses dynamic programming over a topological sort of the graph.\n        \n        Args:\n            n (int): Number of vertices.\n            adj (list): Adjacency list representation of the graph, where adj[i]\n                        is a list of (neighbor, weight) tuples.\n            source (int): The source vertex.\n\n        Returns:\n            A tuple (distances, counts):\n            - distances: A numpy array where distances[i] is the shortest path weight\n                         from source to i.\n            - counts: A numpy array where counts[i] is the number of distinct\n                      shortest paths from source to i.\n        \"\"\"\n        # Step 1: Topological Sort using Kahn's Algorithm\n        in_degree = np.zeros(n, dtype=int)\n        for u in range(n):\n            for v, _ in adj[u]:\n                in_degree[v] += 1\n        \n        queue = deque([i for i in range(n) if in_degree[i] == 0])\n        topo_order = []\n        while queue:\n            u = queue.popleft()\n            topo_order.append(u)\n            for v, _ in adj[u]:\n                in_degree[v] -= 1\n                if in_degree[v] == 0:\n                    queue.append(v)\n        \n        # In a valid DAG, all nodes will be in the topological sort.\n        # The problem guarantees a DAG, so we don't handle cycle detection.\n\n        # Step 2: Initialize distances and path counts\n        distances = np.full(n, INFINITY, dtype=np.int64)\n        counts = np.zeros(n, dtype=np.int64)\n        \n        if source in topo_order:\n            distances[source] = 0\n            counts[source] = 1\n        \n        # Step 3: Iterate through topologically sorted vertices to find shortest paths\n        for u in topo_order:\n            if distances[u] == INFINITY:\n                continue\n\n            for v, w in adj[u]:\n                new_dist = distances[u] + w\n                \n                # A new shortest path to v is found\n                if new_dist  distances[v]:\n                    distances[v] = new_dist\n                    counts[v] = counts[u]\n                # Another path of the same shortest length is found\n                elif new_dist == distances[v]:\n                    counts[v] += counts[u]\n        \n        return distances, counts\n\n    test_cases = [\n        # n, edges, s, t, u\n        (4, [(0, 1, 2), (1, 3, 2), (0, 2, 5), (2, 3, 1)], 0, 3, 1),\n        (4, [(0, 1, 1), (1, 3, 1), (0, 2, 1), (2, 3, 1)], 0, 3, 1),\n        (4, [(0, 1, 1), (1, 3, 2), (0, 2, 1), (2, 3, 1)], 0, 3, 1),\n        (4, [(0, 1, 2), (1, 3, 2), (0, 2, 3), (2, 3, -1)], 0, 3, 2),\n        (5, [(0, 1, 0), (1, 2, 0), (2, 3, 0), (0, 4, 0), (4, 3, 0)], 0, 3, 2),\n        (3, [(0, 1, 1)], 0, 2, 1),\n        (1, [], 0, 0, 0),\n        (2, [(0, 1, 1)], 0, 0, 1),\n        (4, [(0, 1, 1), (1, 2, 1), (2, 3, 1)], 0, 3, 3),\n    ]\n\n    results = []\n    for n, edges, s, t, u in test_cases:\n        # Build adjacency list\n        adj = [[] for _ in range(n)]\n        for src, dst, weight in edges:\n            adj[src].append((dst, weight))\n\n        # Handle trivial case s == t\n        if s == t:\n            results.append(u == s)\n            continue\n            \n        # Get shortest paths info from s\n        dist_s, count_s = _get_shortest_paths_info(n, adj, s)\n\n        # If t is not reachable from s, u cannot be on any path\n        if dist_s[t] == INFINITY:\n            results.append(False)\n            continue\n        \n        # If u is the source or target, it's trivially on every path\n        if u == s or u == t:\n            results.append(True)\n            continue\n\n        # Get shortest paths info from u\n        dist_u, count_u = _get_shortest_paths_info(n, adj, u)\n        \n        # Condition 1: Path Optimality\n        # Check if the shortest path through u is a shortest path overall\n        on_a_shortest_path = (dist_s[u] != INFINITY and \n                              dist_u[t] != INFINITY and\n                              dist_s[u] + dist_u[t] == dist_s[t])\n\n        if not on_a_shortest_path:\n            results.append(False)\n            continue\n            \n        # Condition 2: Path Uniqueness\n        # Check if the number of shortest paths through u equals the total\n        on_every_shortest_path = (count_s[u] * count_u[t] == count_s[t])\n        \n        results.append(on_every_shortest_path)\n\n    # Format the final output as specified\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}