{
    "hands_on_practices": [
        {
            "introduction": "理解图的表示不仅仅是存储数据，更重要的是学会如何操作这些数据结构。第一个练习将聚焦于一个基本操作：直接通过邻接矩阵计算图的补图。通过将补图的定义转化为矩阵运算，你将具体地理解抽象的图论概念是如何在代码中实现的。",
            "id": "3236932",
            "problem": "给定图的数学定义及其矩阵表示。设图定义为 $G = (V, E)$，其中 $V$ 是一个有限的顶点集合，$E \\subseteq V \\times V$ 是一个边集合。邻接矩阵 $A \\in \\{0,1\\}^{n \\times n}$ 按如下方式编码边：对于 $i,j \\in \\{1,\\dots,n\\}$，当且仅当存在一条从顶点 $i$ 到顶点 $j$ 的边时，条目 $A_{ij} = 1$，否则 $A_{ij} = 0$。在无向图中，$A$ 是对称的。在简单无向图中，不存在自环，因此对于所有 $i$，$A_{ii} = 0$。\n\n$G$ 的补图 $\\bar{G}$（在相同的顶点集 $V$ 上）定义为包含 $G$ 中不存在的、连接不同顶点的所有边。具体来说，对于无向图，当且仅当无序对 $\\{u,v\\}$（其中 $u \\neq v$）不是 $G$ 中的边时，它才是 $\\bar{G}$ 中的边。对于有向图，当且仅当有序对 $(u,v)$（其中 $u \\neq v$）不是 $G$ 中的边时，它才是 $\\bar{G}$ 中的边。根据建模选择，$\\bar{G}$ 中可能包含也可能不包含自环；这个选择将在下面的每个测试用例中明确指定。\n\n你的任务是根据第一性原理推导一个算法，该算法根据给定的邻接矩阵 $A$ 计算补图 $\\bar{G}$ 的邻接矩阵 $A^\\complement$，并遵循以下策略参数：每个测试用例有一个布尔标志 $c$，用于规定对角线条目的处理方式。当 $c$ 为 false 时，无论输入 $A$ 是什么，补图矩阵的对角线必须为 $0$。当 $c$ 为 true 时，补图的对角线条目必须反映 $A$ 的对角线条目的逻辑补。\n\n仅从上述核心定义出发，设计一个算法，该算法对于任何有效的邻接矩阵 $A \\in \\{0,1\\}^{n \\times n}$，都能生成与有向或无向解释以及所述对角线策略一致的 $A^\\complement$。提供一个完整的、可运行的程序来实现你的算法，该程序不读取用户输入。该程序必须处理以下明确的测试套件，并为每个测试用例输出按行主序展平的补图矩阵，作为整数列表。\n\n测试套件：\n- 案例 1：$n=4$ 的无向简单图，补图中无自环，$c = \\text{false}$。邻接矩阵为\n$$\nA_1 = \\begin{bmatrix}\n0  1  0  1 \\\\\n1  0  1  0 \\\\\n0  1  0  0 \\\\\n1  0  0  0\n\\end{bmatrix}.\n$$\n- 案例 2：$n=3$ 个顶点的无向完全图，$c = \\text{false}$。邻接矩阵为\n$$\nA_2 = \\begin{bmatrix}\n0  1  1 \\\\\n1  0  1 \\\\\n1  1  0\n\\end{bmatrix}.\n$$\n- 案例 3：$n=5$ 个顶点的无向空图，$c = \\text{false}$。邻接矩阵为\n$$\nA_3 = \\begin{bmatrix}\n0  0  0  0  0 \\\\\n0  0  0  0  0 \\\\\n0  0  0  0  0 \\\\\n0  0  0  0  0 \\\\\n0  0  0  0  0\n\\end{bmatrix}.\n$$\n- 案例 4：$n=3$ 个顶点的有向图，补图中无自环，$c = \\text{false}$。邻接矩阵为\n$$\nA_4 = \\begin{bmatrix}\n0  1  0 \\\\\n0  0  1 \\\\\n1  0  0\n\\end{bmatrix}.\n$$\n- 案例 5：$n=1$ 的单顶点图，其补图必须包含对角线条目的逻辑补，$c = \\text{true}$。邻接矩阵为\n$$\nA_5 = \\begin{bmatrix}\n0\n\\end{bmatrix}.\n$$\n\n最终输出格式规范：\n你的程序应该生成单行输出，其中包含五个案例的结果，格式为一个由方括号括起来的逗号分隔列表，其中每个元素本身也是一个列表，表示该案例按行主序展平的补图邻接矩阵。例如，输出必须看起来像\n$[ [\\dots], [\\dots], [\\dots], [\\dots], [\\dots] ]$\n不带任何附加文本。条目必须是 $\\{0,1\\}$ 中的整数。\n\n要求：\n- 从给定的基本定义出发，推导出一个正确且高效的算法方法，用于计算任何 $A \\in \\{0,1\\}^{n \\times n}$ 和对角线策略 $c$ 的 $A^\\complement$。\n- 算法的时间复杂度应明确证明为关于顶点数 $n$ 的 $O(n^2)$。\n- 使用现代编程语言实现该程序，确保其可直接运行，不使用任何输入，并完全按照指定格式打印单行输出。",
            "solution": "问题陈述已经过验证，被认为是科学上可靠、定义明确且客观的。它提出了算法图论中的一个标准任务——从图的邻接矩阵表示计算其补图——并为处理自环提供了明确定义的参数。这些定义是形式化的，并与数学和计算机科学中已建立的惯例一致。因此，可以推导出一个严谨且唯一的解决方案。\n\n任务是设计一个算法，根据图 $G$ 的邻接矩阵 $A$ 和一个控制对角线条目的布尔参数 $c$ 来计算补图 $\\bar{G}$ 的邻接矩阵 $A^\\complement$。设图有 $n$ 个顶点，因此 $A$ 是一个 $n \\times n$ 的矩阵，其条目在 $\\{0, 1\\}$ 中。\n\n**从第一性原理推导算法**\n\n该算法是通过分别考虑补图对非对角线元素和对角线元素的定义来推导的。\n\n**1. 非对角线条目 ($i \\neq j$)**\n\n问题陈述指出，对于任何一对不同的顶点 $(u, v)$（其中 $u \\neq v$），当且仅当边不存在于原图 $G$ 中时，它才存在于补图 $\\bar{G}$ 中。此规则适用于有向图和无向图。\n\n就邻接矩阵 $A$ 而言，如果存在从顶点 $i$ 到顶点 $j$ 的边，则条目 $A_{ij}$ 为 $1$，否则为 $0$。因此，对于补图的邻接矩阵 $A^\\complement$，如果 $A_{ij}$ 为 $0$，则条目 $A^\\complement_{ij}$ 必须为 $1$；如果 $A_{ij}$ 为 $1$，则为 $0$。这是一个逻辑非（NOT）操作。对于所有满足 $i \\neq j$ 的 $i, j \\in \\{1, \\dots, n\\}$，关系如下：\n$$A^\\complement_{ij} = 1 - A_{ij}$$\n\n**2. 对角线条目 ($i = j$)**\n\n对角线条目 $A_{ii}$ 代表自环。它们的转换由布尔策略参数 $c$ 控制。\n\n*   **策略 $c = \\text{false}$**：问题指定“无论输入 $A$ 是什么，补图矩阵的对角线必须为 $0$”。这提供了一个直接的规则：\n    $$A^\\complement_{ii} = 0 \\quad \\text{对于所有 } i \\in \\{1, \\dots, n\\}$$\n    在定义简单图的补图时，此策略很常见，以确保补图也是一个简单图（即没有自环）。\n\n*   **策略 $c = \\text{true}$**：问题指定“补图的对角线条目必须反映 $A$ 的对角线条目的逻辑补”。这将与非对角线元素相同的逻辑应用于对角线：\n    $$A^\\complement_{ii} = 1 - A_{ii} \\quad \\text{对于所有 } i \\in \\{1, \\dots, n\\}$$\n    此策略对应于对整个关系 $E \\subseteq V \\times V$ 取补，包括顶点相同的配对。\n\n**3. 统一的算法表述**\n\n我们可以将这些规则表达在一个统一的程序中。表示这种转换的一个有效方法是通过矩阵运算。设 $J_n$ 为每个条目都为 $1$ 的 $n \\times n$ 矩阵。对所有条目 $(i,j)$ 进行的 $1 - A_{ij}$ 操作等效于矩阵减法 $J_n - A$。\n\n*   对于策略 $c = \\text{true}$，规则是对于所有 $i,j$，$A^\\complement_{ij} = 1 - A_{ij}$。这正是：\n    $$A^\\complement = J_n - A$$\n\n*   对于策略 $c = \\text{false}$，非对角线条目遵循 $A^\\complement_{ij} = 1 - A_{ij}$，但对角线条目被强制为 $0$。这可以通过一个两步过程实现：\n    1.  首先，计算矩阵 $B = J_n - A$。\n    2.  其次，将 $B$ 的对角线条目设置为 $0$ 以获得 $A^\\complement$。\n    这第二步等同于减去 $B$ 的对角线。设 $I_n$ 为单位矩阵。$B = J_n - A$ 的对角线是一个向量。对于实现来说，更直接的逐元素算法通常更清晰。\n\n**算法流程**\n\n实现这些原则的算法如下：\n\n1.  给定一个 $n \\times n$ 矩阵 $A$ 和一个布尔标志 $c$。\n2.  创建一个新的 $n \\times n$ 矩阵 $A^\\complement$。\n3.  从 $1$ 到 $n$ 遍历每一行 $i$。\n4.  从 $1$ 到 $n$ 遍历每一列 $j$。\n5.  如果 $i = j$（对角线元素）：\n    -   如果 $c$ 为 true，则设置 $A^\\complement_{ii} = 1 - A_{ii}$。\n    -   如果 $c$ 为 false，则设置 $A^\\complement_{ii} = 0$。\n6.  如果 $i \\neq j$（非对角线元素）：\n    -   设置 $A^\\complement_{ij} = 1 - A_{ij}$。\n7.  返回 $A^\\complement$。\n\n**复杂度分析**\n\n该算法需要遍历一次 $n \\times n$ 矩阵的每个元素。对于每个元素，执行常数次操作（比较和减法）。因此，总操作数与矩阵中的元素数量成正比，即 $n^2$。时间复杂度为 $O(n^2)$。该算法需要为新矩阵 $A^\\complement$ 分配存储空间，导致空间复杂度为 $O(n^2)$。这是最优的，因为输出本身的大小就是 $n^2$。\n\n这个基于第一性原理的推导为在指定策略下计算补图的邻接矩阵提供了一个正确且高效的方法。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the graph complement problem for a suite of test cases.\n    \"\"\"\n\n    def compute_complement_matrix(A: np.ndarray, c: bool) -> np.ndarray:\n        \"\"\"\n        Computes the adjacency matrix of the complement graph.\n\n        Args:\n            A: The input adjacency matrix as a numpy array.\n            c: A boolean flag for the diagonal policy.\n               - If True, diagonal entries are complemented (1-A_ii).\n               - If False, diagonal entries are set to 0.\n\n        Returns:\n            The complement adjacency matrix as a numpy array.\n        \"\"\"\n        # The operation 1 - A computes the element-wise logical complement\n        # for a matrix A with entries in {0, 1}.\n        # For c=true, this is the final result.\n        # For c=false, this is an intermediate result for off-diagonal elements.\n        A_complement = 1 - A\n\n        if not c:\n            # When c is false, the diagonal of the complement matrix must be zero.\n            # We use np.fill_diagonal for an efficient in-place modification.\n            np.fill_diagonal(A_complement, 0)\n        \n        return A_complement\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (np.array([\n            [0, 1, 0, 1],\n            [1, 0, 1, 0],\n            [0, 1, 0, 0],\n            [1, 0, 0, 0]\n        ]), False),  # Case 1\n        (np.array([\n            [0, 1, 1],\n            [1, 0, 1],\n            [1, 1, 0]\n        ]), False),  # Case 2\n        (np.array([\n            [0, 0, 0, 0, 0],\n            [0, 0, 0, 0, 0],\n            [0, 0, 0, 0, 0],\n            [0, 0, 0, 0, 0],\n            [0, 0, 0, 0, 0]\n        ]), False),  # Case 3\n        (np.array([\n            [0, 1, 0],\n            [0, 0, 1],\n            [1, 0, 0]\n        ]), False),  # Case 4\n        (np.array([\n            [0]\n        ]), True),   # Case 5\n    ]\n\n    results = []\n    for A_in, c_flag in test_cases:\n        # Compute the complement matrix.\n        A_comp = compute_complement_matrix(A_in, c_flag)\n        \n        # Flatten the resulting matrix in row-major order (numpy's default)\n        # and convert it to a list of standard Python integers.\n        flat_list = A_comp.flatten().astype(int).tolist()\n        results.append(flat_list)\n\n    # The final print statement must follow the exact format specified.\n    # The default string representation of a list in Python, e.g., str([1, 2]),\n    # produces output like '[1, 2]' with spaces.\n    # Joining these string representations with a comma gives the required output format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "对于任何程序员来说，为特定任务选择最优的数据结构是一项至关重要的技能。本练习将通过让你使用三种不同的表示方法来反转一个有向图，从而探索这一权衡。通过分别为邻接表、邻接矩阵和关联矩阵实现反转操作，你将直接体验到表示方法的选择如何影响算法的设计和效率。",
            "id": "3236874",
            "problem": "考虑一个有限有向多重图，定义为有序对 $(V,E)$，其中 $V$ 是一个有限顶点集，顶点由从0开始的连续整数标记，而 $E$ 是有序对 $(u,v)$（其中 $u \\in V$ 且 $v \\in V$）的多重集，表示从 $u$ 到 $v$ 的有向边。图中不存在自环，即不存在形式为 $(u,u)$ 的边。目标是形式化并实现图反转操作：对于 $E$ 中的每条边 $(u,v)$，生成反转边 $(v,u)$，并研究当图分别用邻接表和邻接矩阵表示时，该操作如何执行，并使用关联矩阵交叉验证结果。\n\n基本定义：\n1. 邻接表是列表的集合 $\\{L_u\\}_{u \\in V}$，其中对于 $E$ 中的每条边 $(u,v)$，列表 $L_u$ 包含一个条目 $v$；对于平行边，会存在多个条目。\n2. 邻接矩阵是一个矩阵 $A \\in \\mathbb{N}^{|V| \\times |V|}$，其元素 $A[u,v]$ 等于从 $u$ 到 $v$ 的边数。\n3. 有向多重图的关联矩阵是一个矩阵 $M \\in \\{-1,0,1\\}^{|V| \\times |E|}$，每条边对应一列。对于一条边 $e = (u,v)$，以 $e$ 为索引的列满足 $M[u,e] = -1$，$M[v,e] = +1$，并且对于所有 $w \\in V$ 且 $w \\notin \\{u,v\\}$ 的情况，$M[w,e] = 0$。图中不包含自环，因此每列恰好有一个 $-1$ 和一个 $+1$。\n4. 图反转算子 $\\mathcal{R}$ 将图 $(V,E)$ 映射到 $(V,E')$，其中 $E' = \\{(v,u) : (u,v) \\in E\\}$。\n\n你必须实现算法，在输入为以下形式时计算反转图：\n- 邻接表 $\\{L_u\\}_{u \\in V}$。\n- 邻接矩阵 $A$。\n此外，通过从邻接表构造关联矩阵 $M$，将其所有元素取反进行反转，然后从反转后的关联矩阵重构邻接矩阵，来通过关联矩阵 $M$ 验证正确性。为了进行算法比较，定义一个简单的操作计数模型：\n- 对于邻接表反转，为每个 $u \\in V$ 初始化空列表 $L^{\\mathrm{rev}}_u$ 计为1次操作，反转过程中每附加一条边计为1次操作。总计数应为 $|V| + |E|$。\n- 对于邻接矩阵反转，构造一个相同大小的新矩阵 $A^{\\mathrm{rev}}$，并通过 $A^{\\mathrm{rev}}[i,j] := A[j,i]$ 设置每个元素。对 $A^{\\mathrm{rev}}[i,j]$ 的每次赋值计为1次操作，总计 $|V|^2$ 次操作。\n- 对于关联矩阵反转，给定大小为 $|V| \\times |E|$ 的矩阵 $M$，对所有元素设置 $M^{\\mathrm{rev}}[i,e] := -M[i,e]$，每次元素赋值计为1次操作，总计 $|V|\\cdot|E|$ 次操作。\n\n测试套件：\n您必须实现以下参数化测试用例，每个用例都由其顶点数 $|V|$ 和一个邻接表给出。对于每个用例，您应根据上述定义推导出相应的邻接矩阵。\n\n用例1：$|V| = 5$。邻接表 $= \\left[ [1,1], [3], [0,4], [2], [1] \\right]$。\n用例2：$|V| = 4$。邻接表 $= \\left[ [], [], [], [] \\right]$。\n用例3：$|V| = 2$。邻接表 $= \\left[ [1], [] \\right]$。\n用例4：$|V| = 4$。邻接表 $= \\left[ [1,2,3], [0,2,3], [0,1,3], [0,1,2] \\right]$。\n用例5：$|V| = 6$。邻接表 $= \\left[ [5,5], [2], [1], [], [2], [] \\right]$。\n\n对于每个测试用例，计算：\n1. 反转后的邻接表，并将其转换为矩阵 $A^{\\mathrm{rev}}_{\\text{list}}$。\n2. 通过对原始邻接矩阵进行转置得到的反转邻接矩阵 $A^{\\mathrm{rev}}_{\\text{matrix}}$。\n3. 从原始邻接表构造的关联矩阵 $M$，通过将所有元素取反得到的反转关联矩阵 $M^{\\mathrm{rev}}$，以及从 $M^{\\mathrm{rev}}$ 重构的邻接矩阵 $A^{\\mathrm{rev}}_{\\text{inc}}$。\n\n然后，为每个测试用例报告：\n- 一个布尔值，如果 $A^{\\mathrm{rev}}_{\\text{list}}$ 等于 $A^{\\mathrm{rev}}_{\\text{matrix}}$，则为真。\n- 一个布尔值，如果 $A^{\\mathrm{rev}}_{\\text{list}}$ 等于 $A^{\\mathrm{rev}}_{\\text{inc}}$，则为真。\n- 一个整数，等于邻接表反转的操作计数。\n- 一个整数，等于邻接矩阵反转的操作计数。\n- 一个整数，等于关联矩阵反转的操作计数。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个元素对应一个测试用例，并且必须是按上述顺序排列的列表。例如，最终输出应类似于 $\\left[ [b_1,b'_1,c^{\\mathrm{list}}_1,c^{\\mathrm{mat}}_1,c^{\\mathrm{inc}}_1], [b_2,b'_2,c^{\\mathrm{list}}_2,c^{\\mathrm{mat}}_2,c^{\\mathrm{inc}}_2], \\ldots \\right]$，其中 $b_i$ 和 $b'_i$ 是布尔值，$c^{\\mathrm{list}}_i$、$c^{\\mathrm{mat}}_i$ 和 $c^{\\mathrm{inc}}_i$ 是整数。",
            "solution": "该问题是有效的。这是一个关于图论和数据结构的适定且有科学依据的练习，涉及有向多重图的表示和变换。所提供的邻接表、邻接矩阵和关联矩阵的定义都是标准的，它们在图反转操作下的关系也被正确陈述。任务是通过算法实现并验证这些关系。\n\n给定一个有向多重图 $G=(V,E)$，其中 $V=\\{0, 1, \\dots, |V|-1\\}$ 是顶点集，$E$ 是有向边 $(u,v)$ 的多重集，其中 $u,v \\in V$ 且 $u \\neq v$。图反转操作，记为 $\\mathcal{R}$，将 $G$ 变换为一个新图 $G^{\\mathrm{rev}} = (V, E^{\\mathrm{rev}})$，其中 $E^{\\mathrm{rev}} = \\{ (v,u) : (u,v) \\in E \\}$。我们将针对表示图的三种不同数据结构，形式化计算 $G^{\\mathrm{rev}}$ 的过程。\n\n首先，让我们为给定的图 $G=(V,E)$ 建立基础表示。\n- 邻接表表示法是列表的集合 $\\{L_u\\}_{u \\in V}$，其中对于每条边 $(u,v) \\in E$，列表 $L_u$ 都包含一个顶点 $v$ 的条目。$v$ 在 $L_u$ 中出现的次数等于从 $u$ 到 $v$ 的平行边数量。\n- 邻接矩阵 $A$ 是一个 $|V| \\times |V|$ 的自然数 $\\mathbb{N}$ 矩阵，其中元素 $A[u,v]$ 表示边 $(u,v)$ 的重数，即从顶点 $u$ 到顶点 $v$ 的边数。\n- 关联矩阵 $M$ 是一个 $|V| \\times |E|$ 的矩阵，其元素取值于 $\\{-1, 0, 1\\}$。每一列对应 $E$ 中的一条唯一边。对于一条边 $e = (u,v)$，其对应的列满足 $M[u,e] = -1$，$M[v,e] = 1$，所有其他元素均为 $0$。\n\n任务要求基于这些表示方法，实现并比较三种获取反转图的方法。\n\n**1. 通过邻接表反转**\n\n反转操作通过直接应用其定义来执行。给定图 $G$ 的邻接表 $\\{L_u\\}_{u \\in V}$，我们为反转图 $G^{\\mathrm{rev}}$ 构造邻接表 $\\{L^{\\mathrm{rev}}_v\\}_{v \\in V}$。\n\n算法流程如下：\n1. 初始化 $|V|$ 个空列表，$L^{\\mathrm{rev}}_0, L^{\\mathrm{rev}}_1, \\dots, L^{\\mathrm{rev}}_{|V|-1}$。根据问题的计数模型，此步骤对应 $|V|$ 次操作。\n2. 遍历每个顶点 $u \\in V$。\n3. 对于列表 $L_u$ 中出现的每个顶点 $v$，这表示存在一条边 $(u,v) \\in E$：\n   a. 对应的反转边是 $(v,u)$。\n   b. 因此，将顶点 $u$ 附加到列表 $L^{\\mathrm{rev}}_v$ 中。此步骤对应每条边1次操作。\n4. 总操作计数是这两个步骤的操作之和，即 $|V| + |E|$，其中 $|E| = \\sum_{u \\in V} |L_u|$ 是总边数。\n\n最后，将得到的邻接表 $\\{L^{\\mathrm{rev}}_v\\}$ 转换为邻接矩阵 $A^{\\mathrm{rev}}_{\\text{list}}$ 以进行比较，其中 $A^{\\mathrm{rev}}_{\\text{list}}[i,j]$ 是 $j$ 在列表 $L^{\\mathrm{rev}}_i$ 中出现的次数。\n\n**2. 通过邻接矩阵反转**\n\n图 $G$ 的邻接矩阵 $A$ 与其反转图 $G^{\\mathrm{rev}}$ 的邻接矩阵 $A^{\\mathrm{rev}}$ 之间的关系是转置关系。设 $A[u,v]$ 是从 $u$ 到 $v$ 的边数。在反转图中，从 $v$ 到 $u$ 的边数，即 $A^{\\mathrm{rev}}[v,u]$，必须等于原始图中从 $u$ 到 $v$ 的边数。因此，对于所有 $u,v \\in V$，有 $A^{\\mathrm{rev}}[v,u] = A[u,v]$。这正是矩阵转置的定义，即 $A^{\\mathrm{rev}} = A^T$。\n\n算法如下：\n1. 从输入的邻接表构造原始邻接矩阵 $A$。\n2. 创建一个新的 $|V| \\times |V|$ 矩阵 $A^{\\mathrm{rev}}_{\\text{matrix}}$。\n3. 对于每对索引 $(i,j)$，其中 $i, j \\in V$：\n   a. 赋值 $A^{\\mathrm{rev}}_{\\text{matrix}}[i,j] = A[j,i]$。这是一个单一的赋值操作。\n4. 总操作计数是矩阵中的总元素数，即 $|V| \\times |V| = |V|^2$。\n\n**3. 通过关联矩阵验证**\n\n此方法通过关联矩阵表示法来验证反转操作。它涉及三个步骤：为原始图构造关联矩阵 $M$，将其反转得到 $M^{\\mathrm{rev}}$，然后从 $M^{\\mathrm{rev}}$ 重构邻接矩阵 $A^{\\mathrm{rev}}_{\\text{inc}}$。\n\n其代数原理是，反转一条边 $(u,v)$ 等同于交换源和目标的角色。在所定义的关联矩阵中，这对应于将与该边关联的列取反。对于一条边 $e=(u,v)$，其列的元素为 $M[u,e] = -1$ 和 $M[v,e] = 1$。反转后的边 $e^{\\mathrm{rev}} = (v,u)$ 将有一个关联列，其元素为 $M^{\\mathrm{rev}}[v,e^{\\mathrm{rev}}] = -1$ 和 $M^{\\mathrm{rev}}[u,e^{\\mathrm{rev}}] = 1$。这个新列恰好是原始列的负值。因此，反转图的关联矩阵是原始关联矩阵的负矩阵：$M^{\\mathrm{rev}} = -M$。\n\n算法如下：\n1. **M的构造**：从输入的邻接表 $\\{L_u\\}$，构造 $|V| \\times |E|$ 的关联矩阵 $M$。这是通过遍历所有边来完成的，对于每条边 $e_k = (u,v)$，设置 $M$ 的第 $k$ 列，使其满足 $M[u,k] = -1$ 和 $M[v,k] = 1$。\n2. **M的反转**：通过将 $M$ 的每个元素取反来创建一个新矩阵 $M^{\\mathrm{rev}}$：对于所有的 $i,k$，$M^{\\mathrm{rev}}[i,k] = -M[i,k]$。此步骤的操作计数是矩阵中的元素数量，即 $|V| \\cdot |E|$。\n3. **A的重构**：从 $M^{\\mathrm{rev}}$ 重构邻接矩阵 $A^{\\mathrm{rev}}_{\\text{inc}}$。对于 $M^{\\mathrm{rev}}$ 的每一列 $k$，找到行索引 $i$ 和 $j$，使得 $M^{\\mathrm{rev}}[i,k] = -1$（新的源点）和 $M^{\\mathrm{rev}}[j,k] = 1$（新的目标点）。这对应于反转图中的一条边 $(i,j)$。将计数 $A^{\\mathrm{rev}}_{\\text{inc}}[i,j]$ 加一。\n\n这一过程的成功完成以及 $A^{\\mathrm{rev}}_{\\text{list}} = A^{\\mathrm{rev}}_{\\text{matrix}} = A^{\\mathrm{rev}}_{\\text{inc}}$ 的验证，证明了这些基本图论变换在不同表示法下的一致性。操作计数为比较这些算法的计算成本提供了一个简化的度量，突显了数据结构的最优选择取决于图的密度以及需要执行的具体操作。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef adj_list_to_adj_matrix(adj_list, num_vertices):\n    \"\"\"Converts an adjacency list to an adjacency matrix.\"\"\"\n    adj_matrix = np.zeros((num_vertices, num_vertices), dtype=int)\n    for u, neighbors in enumerate(adj_list):\n        for v in neighbors:\n            adj_matrix[u, v] += 1\n    return adj_matrix\n\ndef adj_list_to_inc_matrix(adj_list, num_vertices, num_edges):\n    \"\"\"Converts an adjacency list to an incidence matrix.\"\"\"\n    if num_edges == 0:\n        return np.zeros((num_vertices, 0), dtype=int)\n    inc_matrix = np.zeros((num_vertices, num_edges), dtype=int)\n    edge_idx = 0\n    for u, neighbors in enumerate(adj_list):\n        for v in neighbors:\n            inc_matrix[u, edge_idx] = -1\n            inc_matrix[v, edge_idx] = 1\n            edge_idx += 1\n    return inc_matrix\n\ndef inc_matrix_to_adj_matrix(inc_matrix, num_vertices, num_edges):\n    \"\"\"Converts an incidence matrix to an adjacency matrix.\"\"\"\n    adj_matrix = np.zeros((num_vertices, num_vertices), dtype=int)\n    for e in range(num_edges):\n        col = inc_matrix[:, e]\n        # Find source (u) and destination (v)\n        # Using np.where returns arrays of indices.\n        u_indices = np.where(col == -1)[0]\n        v_indices = np.where(col == 1)[0]\n        if u_indices.size > 0 and v_indices.size > 0:\n            u = u_indices[0]\n            v = v_indices[0]\n            adj_matrix[u, v] += 1\n    return adj_matrix\n\ndef solve():\n    \"\"\"\n    Main function to process test cases and compute results.\n    \"\"\"\n    test_cases = [\n        (5, [[1, 1], [3], [0, 4], [2], [1]]),\n        (4, [[], [], [], []]),\n        (2, [[1], []]),\n        (4, [[1, 2, 3], [0, 2, 3], [0, 1, 3], [0, 1, 2]]),\n        (6, [[5, 5], [2], [1], [], [2], []])\n    ]\n\n    results = []\n\n    for num_vertices, adj_list in test_cases:\n        V = num_vertices\n        E = sum(len(neighbors) for neighbors in adj_list)\n\n        # 1. Adjacency List Reversal\n        rev_adj_list = [[] for _ in range(V)]\n        for u, neighbors in enumerate(adj_list):\n            for v in neighbors:\n                rev_adj_list[v].append(u)\n        \n        A_rev_list = adj_list_to_adj_matrix(rev_adj_list, V)\n        cost_list = V + E\n        \n        # 2. Adjacency Matrix Reversal\n        A_orig = adj_list_to_adj_matrix(adj_list, V)\n        A_rev_matrix = A_orig.T\n        cost_matrix = V * V\n\n        # 3. Incidence Matrix Verification\n        M_orig = adj_list_to_inc_matrix(adj_list, V, E)\n        M_rev = -M_orig\n        A_rev_inc = inc_matrix_to_adj_matrix(M_rev, V, E)\n        cost_inc = V * E\n\n        # Comparisons\n        eq_list_matrix = np.array_equal(A_rev_list, A_rev_matrix)\n        eq_list_inc = np.array_equal(A_rev_list, A_rev_inc)\n\n        results.append([\n            eq_list_matrix,\n            eq_list_inc,\n            cost_list,\n            cost_matrix,\n            cost_inc\n        ])\n\n    # Final print statement in the exact required format.\n    # The default str() for a list includes spaces, which is standard.\n    # The template 'print(f\"[{','.join(map(str, results))}]\")' ensures there are no spaces\n    # between the outer list elements, which is a subtle but important detail.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "当我们利用数据结构的特性来优雅而高效地解决问题时，它的真正威力才会显现。这个动手挑战要求你在线性时间内找到有向图中的“汇点”，这比朴素的二次方解法有了显著的改进。通过设计一个巧妙的排除策略，你将学会如何利用邻接矩阵的特性来解决算法难题，从而实现最优性能。",
            "id": "3236899",
            "problem": "给定一个仅由其邻接矩阵表示的有向图。一个有向图拥有一个顶点集 $V$，其中 $|V| = n$，顶点标记为 $0,1,\\dots,n-1$。其邻接矩阵是一个在 $\\{0,1\\}$ 上的 $n \\times n$ 矩阵 $A$，其中当且仅当存在一条从顶点 $i$ 到顶点 $j$ 的有向边时，$A[i][j] = 1$，否则 $A[i][j] = 0$。假设该图是简单有向图：没有自环，也没有多重边，因此对所有 $i$，$A[i][i] = 0$。一个汇点 (sink vertex) 是一个顶点 $s \\in V$，其出度为 $0$，入度为 $n-1$。等价地，在邻接矩阵中，整个第 $s$ 行全为零，而第 $s$ 列除了对角线位置的元素（在此设定中为零）外，所有位置都为一。\n\n根据上述核心定义，设计一个程序，仅使用邻接矩阵表示来判断是否存在汇点，如果存在，则返回其索引。你的程序必须在 $O(n)$ 时间内运行，其中 $n = |V|$，并且不得将邻接矩阵转换为其他表示形式，如邻接表或关联矩阵。如果没有汇点，则返回 $-1$。对于 $n = 0$ 的特殊边界情况，返回 $-1$。\n\n你的程序必须处理以下固定的邻接矩阵测试套件（每个矩阵是 $\\{0,1\\}$ 中整数的列表的列表），并为每个矩阵生成一个整数结果：\n\n- 测试用例 1 ($n = 5$)：一个在索引 3 处有汇点的图。\n  矩阵：\n  [\n    [$0$,$1$,$0$,$1$,$0$],\n    [$0$,$0$,$1$,$1$,$0$],\n    [$1$,$0$,$0$,$1$,$0$],\n    [$0$,$0$,$0$,$0$,$0$],\n    [$0$,$1$,$0$,$1$,$0$]\n  ]\n\n- 测试用例 2 ($n = 4$)：一个有向环；不存在汇点。\n  矩阵：\n  [\n    [$0$,$1$,$0$,$0$],\n    [$0$,$0$,$1$,$0$],\n    [$0$,$0$,$0$,$1$],\n    [$1$,$0$,$0$,$0$]\n  ]\n\n- 测试用例 3 ($n = 1$)：一个单顶点图；唯一的顶点是一个汇点。\n  矩阵：\n  [\n    [$0$]\n  ]\n\n- 测试用例 4 ($n = 0$)：空图；按约定返回 $-1$。\n  矩阵：\n  [ ]\n\n- 测试用例 5 ($n = 4$)：一个在索引 0 处有汇点的图。\n  矩阵：\n  [\n    [$0$,$0$,$0$,$0$],\n    [$1$,$0$,$1$,$0$],\n    [$1$,$0$,$0$,$1$],\n    [$1$,$1$,$0$,$0$]\n  ]\n\n- 测试用例 6 ($n = 4$)：一个在索引 2 处有出度为 0 的顶点，但缺少一条入边；不存在汇点。\n  矩阵：\n  [\n    [$0$,$1$,$0$,$0$],\n    [$0$,$0$,$1$,$0$],\n    [$0$,$0$,$0$,$0$],\n    [$1$,$0$,$1$,$0$]\n  ]\n\n输出规范：你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，结果顺序与测试用例 1 到 6 的顺序一致。例如，形如 [$r_1$,$r_2$,$r_3$,$r_4$,$r_5$,$r_6$] 的输出行，其中每个 $r_i$ 是测试用例 $i$ 的整数结果。",
            "solution": "该问题已经过验证，并被确定为图算法领域中一个有效且定义明确的问题。所有提供的信息都是自包含、一致的，并且在科学上基于图论的既定原则。有向图、其邻接矩阵表示以及汇点的定义都是标准的。该问题要求一个具有特定时间复杂度约束 $O(n)$ 的算法，这使其从一个简单的搜索问题提升为一个真正的算法挑战。\n\n任务是在一个由其 $n \\times n$ 邻接矩阵 $A$ 表示的有向图中找到一个汇点。汇点 $s$ 定义为一个入度为 $n-1$ 且出度为 $0$ 的顶点。就邻接矩阵 $A$ 而言，这意味着对于一个汇点 $s$：\n1.  第 $s$ 行必须全为零：对于所有 $j \\in \\{0, 1, \\dots, n-1\\}$，$A[s][j] = 0$。这对应于出度为 $0$。\n2.  第 $s$ 列必须全为一，对角线位置除外：对于所有 $j \\in \\{0, 1, \\dots, n-1\\}$ 且 $j \\neq s$，$A[j][s] = 1$。这对应于入度为 $n-1$。问题规定对所有 $i$，$A[i][i] = 0$，这与该定义一致。\n\n汇点的一个关键性质是其唯一性。如果一个图包含一个汇点，那么它只能包含一个。为了进行反证，假设存在两个不同的汇点 $s_1$ 和 $s_2$。由于 $s_1$ 是一个汇点，其入度必须为 $n-1$，这意味着必须存在从所有其他顶点到 $s_1$ 的有向边。因此，必须存在一条边 $(s_2, s_1)$。然而，由于 $s_2$ 也是一个汇点，其出度必须为 $0$，这意味着不能有任何从 $s_2$ 出发的边。这与边 $(s_2, s_1)$ 的存在相矛盾。因此，一个图最多只能有一个汇点。\n\n一个寻找汇点的朴素方法是遍历每个顶点 $i \\in \\{0, 1, \\dots, n-1\\}$ 并验证其是否满足汇点条件。验证单个顶点需要检查其整行和整列，这需要 $O(n)$ 时间。对所有 $n$ 个顶点重复此操作，总时间复杂度为 $O(n^2)$。该问题要求一个更高效的算法，其时间复杂度为 $O(n)$。\n\n可以通过一个两阶段过程来实现一个 $O(n)$ 的解法：候选者排除和验证。\n\n**阶段 1：候选者排除**\n\n此阶段的核心原则是在 $O(n)$ 时间内丢弃不可能是汇点的顶点，最终只留下最多一个候选者。我们可以遍历顶点并逐步排除非汇点候选者。\n\n1.  我们首先假定顶点 0 是一个潜在的汇点。我们维护一个变量 `candidate`，并将其初始化为 0。\n2.  然后我们遍历其余的顶点，$i = 1, 2, \\dots, n-1$。在每一步中，我们将当前的 `candidate` 与顶点 $i$ 进行比较。\n3.  我们检查矩阵项 $A[\\text{candidate}][i]$。\n    -   如果 $A[\\text{candidate}][i] = 1$，这表示存在一条从 `candidate` 到 $i$ 的边。汇点不能有任何出边（出度必须为 $0$）。因此，当前的 `candidate` 绝对不是汇点。我们将其从考虑中排除。在这种情况下，顶点 $i$ 成为我们新的 `candidate`。虽然 $i$ 本身可能不是汇点，但它成功地“否定”了前一个候选者，并且是下一个要考虑的顶点。\n    -   如果 $A[\\text{candidate}][i] = 0$，这表示不存在从 `candidate` 到 $i$ 的边。汇点必须有来自所有其他顶点的入边（入度必须为 $n-1$）。缺少从 `candidate` 到 $i$ 的边证明了顶点 $i$ 不可能是汇点。因此，我们可以将 $i$ 从考虑中排除。当前的 `candidate` 在此测试中幸存下来，并保持为 `candidate`。\n\n这个排除过程恰好执行 $n-1$ 次比较，对于从 $1$ 到 $n-1$ 的每个 $i$ 执行一次。循环完成后，我们只剩下一个在排除过程中幸存下来的顶点。这是我们唯一的汇点候选者。此阶段的时间复杂度为 $O(n)$。\n\n**阶段 2：候选者验证**\n\n排除阶段保证了如果存在汇点，它必定是最终的 `candidate`。然而，这并不能保证这个 `candidate` 实际上是一个汇点。这个候选者可能仅仅因为它排除了所有其他竞争者而被选中，即使它本身不满足汇点的属性。因此，最后的验证步骤是强制性的。\n\n设最终候选者为 $c$。我们必须验证 $c$ 是否满足成为汇点的两个条件：\n1.  **零出度**：遍历列索引 $j = 0, 1, \\dots, n-1$。如果我们发现任何 $j$ 使得 $A[c][j] = 1$，那么顶点 $c$ 的出度非零，不可能是汇点。\n2.  **$n-1$ 入度**：遍历行索引 $i = 0, 1, \\dots, n-1$。如果我们发现任何 $i \\neq c$ 使得 $A[i][c] = 0$，那么顶点 $c$ 缺少一条入边，其入度小于 $n-1$。它不可能是汇点。我们还必须确认 $A[c][c] = 0$，这是由问题陈述所保证的。\n\n这个验证需要扫描矩阵的一整行和一整列，这需要 $O(n)$ 的时间。\n\n如果候选者 $c$ 通过了两个验证检查，它就是唯一的汇点，并返回其索引 $c$。如果任一检查失败，则意味着图中没有顶点满足汇点条件，因此不存在汇点。在这种情况下，返回 $-1$。\n\n整个算法包括 $O(n)$ 的排除阶段和 $O(n)$ 的验证阶段，总时间复杂度为 $O(n) + O(n) = O(n)$，满足问题的约束。该算法为候选者和循环索引用了常数数量的额外空间，因此其空间复杂度为 $O(1)$。必须处理 $n=0$ 和 $n=1$ 的特殊情况。对于 $n=0$，没有顶点，因此没有汇点；我们返回 $-1$。对于 $n=1$，唯一的顶点 0 的入度为 $1-1=0$，出度为 $0$，因此它是一个汇点。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the sink-finding problem for a predefined test suite of graphs.\n    \"\"\"\n    # Define the test cases from the problem statement as numpy arrays.\n    test_cases = [\n        # Test case 1 (n=5, sink at 3)\n        np.array([\n            [0, 1, 0, 1, 0],\n            [0, 0, 1, 1, 0],\n            [1, 0, 0, 1, 0],\n            [0, 0, 0, 0, 0],\n            [0, 1, 0, 1, 0]\n        ]),\n        # Test case 2 (n=4, no sink)\n        np.array([\n            [0, 1, 0, 0],\n            [0, 0, 1, 0],\n            [0, 0, 0, 1],\n            [1, 0, 0, 0]\n        ]),\n        # Test case 3 (n=1, sink at 0)\n        np.array([\n            [0]\n        ]),\n        # Test case 4 (n=0, no sink)\n        np.array([]).reshape(0,0),\n        # Test case 5 (n=4, sink at 0)\n        np.array([\n            [0, 0, 0, 0],\n            [1, 0, 1, 0],\n            [1, 0, 0, 1],\n            [1, 1, 0, 0]\n        ]),\n        # Test case 6 (n=4, no sink)\n        np.array([\n            [0, 1, 0, 0],\n            [0, 0, 1, 0],\n            [0, 0, 0, 0],\n            [1, 0, 1, 0]\n        ])\n    ]\n\n    results = []\n    \n    for A in test_cases:\n        n = A.shape[0]\n\n        # Handle boundary case for an empty graph (n=0).\n        if n == 0:\n            results.append(-1)\n            continue\n        \n        # Phase 1: Candidate Elimination in O(n)\n        # We find a single candidate that could be a sink.\n        candidate = 0\n        for i in range(1, n):\n            # If A[candidate][i] is 1, there's an edge candidate -> i.\n            # This means 'candidate' cannot be a sink (out-degree > 0).\n            # The new candidate becomes i.\n            # If A[candidate][i] is 0, there is no edge candidate -> i.\n            # This means 'i' cannot be a sink (in-degree < n-1).\n            # The current 'candidate' survives.\n            if A[candidate, i] == 1:\n                candidate = i\n        \n        # Phase 2: Candidate Verification in O(n)\n        # Check if the final candidate is indeed a sink.\n        is_sink = True\n        for i in range(n):\n            # A sink must have an out-degree of 0.\n            # Check if the candidate's row has any 1s.\n            if A[candidate, i] == 1:\n                is_sink = False\n                break\n            \n            # A sink must have an in-degree of n-1.\n            # Check if the candidate's column has any 0s (for i != candidate).\n            # The A[i][i] == 0 condition is given.\n            if i != candidate and A[i, candidate] == 0:\n                is_sink = False\n                break\n        \n        if is_sink:\n            results.append(candidate)\n        else:\n            results.append(-1)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}