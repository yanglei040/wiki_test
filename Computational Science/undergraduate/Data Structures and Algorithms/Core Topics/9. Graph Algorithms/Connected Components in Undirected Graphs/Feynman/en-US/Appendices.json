{
    "hands_on_practices": [
        {
            "introduction": "A fundamental skill in algorithm design is translating a real-world scenario into a formal graph structure. This exercise challenges you to model a 2D grid with obstacles as an undirected graph and then apply a traversal algorithm to count the distinct, unconnected regions or 'islands'. Mastering this practice  is essential for tackling problems in areas like image analysis, robotics, and network mapping.",
            "id": "3223893",
            "problem": "Consider a finite two-dimensional grid modeled as the Cartesian product $\\{0,1,\\dots,m-1\\} \\times \\{0,1,\\dots,n-1\\}$, where $m$ and $n$ are nonnegative integers. A subset $B \\subseteq \\{0,1,\\dots,m-1\\} \\times \\{0,1,\\dots,n-1\\}$ specifies the blocked cells. Define an undirected graph $G=(V,E)$ by taking the vertex set $V$ to be all unblocked cells, i.e., $V = \\left(\\{0,1,\\dots,m-1\\} \\times \\{0,1,\\dots,n-1\\}\\right) \\setminus B$, and taking the edge set $E$ to contain exactly the unordered pairs $\\{(i,j),(i',j')\\}$ such that both endpoints are in $V$ and the cells are orthogonally adjacent, meaning $|i-i'|+|j-j'|=1$. Two vertices $u,v \\in V$ are said to be connected if there exists a sequence (a walk) of vertices $u=v_0,v_1,\\dots,v_k=v$ with each consecutive pair forming an edge in $E$. A connected component is a maximal subset of $V$ in which every pair of vertices is connected.\n\nStarting exclusively from the foregoing definitions, derive a correct and efficient algorithm to compute the number of connected components of unblocked cells as a function of $m$, $n$, and $B$. Your algorithm must operate under the orthogonal adjacency rule stated above and must be implementable in a deterministic manner using standard data structures.\n\nYour program should be self-contained (no input) and evaluate the following test suite, each test case given by a triple $(m,n,B)$, where the set $B$ is explicitly specified. The adjacency is orthogonal ($4$-neighbor) in all cases.\n\nTest case $1$: $(m,n)=(5,7)$ and $B_1=\\{(0,1),(0,5),(1,1),(1,5),(2,3),(2,5),(3,0),(3,1),(3,2),(3,3),(3,5),(4,5)\\}$.\n\nTest case $2$: $(m,n)=(0,5)$ and $B_2=\\emptyset$.\n\nTest case $3$: $(m,n)=(3,3)$ and $B_3=\\{(0,0),(0,1),(0,2),(1,0),(1,1),(1,2),(2,0),(2,1),(2,2)\\}$.\n\nTest case $4$: $(m,n)=(1,6)$ and $B_4=\\{(0,1),(0,3),(0,4)\\}$.\n\nTest case $5$: $(m,n)=(3,4)$ and $B_5=\\emptyset$.\n\nYour program should produce a single line of output containing the integer results for the five test cases, in order, as a comma-separated list enclosed in square brackets (for example, $[r_1,r_2,r_3,r_4,r_5]$). No physical units, angles, or percentages are involved in this problem; all outputs are unitless integers.",
            "solution": "The problem requires the computation of the number of connected components in an undirected graph $G=(V,E)$. The graph's structure is derived from a two-dimensional grid and a set of blocked cells. This is a classic problem in graph theory and computational geometry, solvable using standard graph traversal algorithms.\n\n### Problem Formalization\n\nThe grid is defined as the set of points $\\{0,1,\\dots,m-1\\} \\times \\{0,1,\\dots,n-1\\}$ for given non-negative integers $m$ and $n$. A subset $B$ of these points represents blocked cells.\n\nThe vertex set $V$ of the graph $G$ consists of all unblocked cells:\n$$V = \\left(\\{0,1,\\dots,m-1\\} \\times \\{0,1,\\dots,n-1\\}\\right) \\setminus B$$\nThe edge set $E$ connects any two vertices $(i,j) \\in V$ and $(i',j') \\in V$ if they are orthogonally adjacent. The condition for orthogonal adjacency is given by the Manhattan distance between the cell coordinates:\n$$|i-i'|+|j-j'|=1$$\nThis adjacency rule is also known as a $4$-neighbor connectivity.\n\nA connected component is a maximal subgraph where any two vertices are connected to each other by a path. The task is to determine the total number of such connected components.\n\n### Algorithmic Approach\n\nThe number of connected components can be determined by systematically exploring the grid. The core idea is to iterate through each cell of the grid. If an unvisited, unblocked cell is found, it must belong to a new, not-yet-discovered connected component. We then initiate a graph traversal, such as a Breadth-First Search (BFS) or Depth-First Search (DFS), starting from that cell. This traversal will visit and mark every cell belonging to that same component. By incrementing a counter each time we discover a new component, we can find the total number.\n\nA two-dimensional array, with dimensions $m \\times n$, will serve as the representation of the grid. We can use integer values in this array to encode the state of each cell:\n-  A value of $-1$ can represent a blocked cell.\n-  A value of $0$ can represent an unblocked and unvisited cell.\n-  A positive integer $k > 0$ can indicate that the cell has been visited and belongs to the $k$-th component found.\n\nThe algorithm proceeds as follows:\n\n1.  Initialize a counter for the number of components, `count`, to $0$.\n2.  Create an $m \\times n$ grid data structure, `grid`. Initialize all cells to a state representing \"unblocked, unvisited\" (e.g., value $0$).\n3.  For each cell coordinate $(i,j)$ in the input set $B$, update `grid` at position $(i,j)$ to the \"blocked\" state (e.g., value $-1$).\n4.  Handle the edge case where the grid is empty: if $m=0$ or $n=0$, the number of vertices is $0$, and thus the number of components is $0$.\n5.  Iterate through each cell $(r,c)$ of the grid, for $r$ from $0$ to $m-1$ and $c$ from $0$ to $n-1$.\n6.  At each cell $(r,c)$:\n    - If `grid[r,c]` indicates the cell is already visited (value $>0$) or is blocked (value $<0$), do nothing and continue to the next cell.\n    - If `grid[r,c]` indicates an unvisited, unblocked cell (value $0$), we have found a new component.\n        - Increment the component counter: `count` $\\leftarrow$ `count` $+ 1$.\n        - Begin a Breadth-First Search (BFS) starting from $(r,c)$ to find all cells in this new component.\n            - Create a queue and add the starting cell $(r,c)$ to it.\n            - Mark the starting cell as visited by setting `grid[r,c]` $\\leftarrow$ `count`.\n            - While the queue is not empty:\n                - Dequeue a cell, let it be $(r_{curr}, c_{curr})$.\n                - For each of its four orthogonal neighbors $(r_{neigh}, c_{neigh})$:\n                    - Check if the neighbor is within the grid boundaries ($0 \\le r_{neigh} < m$ and $0 \\le c_{neigh} < n$).\n                    - Check if the neighbor is unvisited and unblocked (`grid[r_{neigh}, c_{neigh}] == 0`).\n                    - If both conditions are met, mark the neighbor as visited (`grid[r_{neigh}, c_{neigh}]` $\\leftarrow$ `count`) and enqueue it.\n7. After the nested loops complete, the final value of `count` is the total number of connected components.\n\nThis procedure is guaranteed to be correct. It examines every cell. Each time a traversal is initiated, it is on a cell that has not been assigned to any prior component. The traversal algorithm (BFS/DFS) ensures that all reachable cells—and only those cells—are exhaustively identified and marked as part of the current component. Therefore, each component is counted exactly once.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport collections\n\ndef count_components(m: int, n: int, B: set) -> int:\n    \"\"\"\n    Computes the number of connected components in a 2D grid with blocked cells.\n\n    Args:\n        m: The number of rows in the grid.\n        n: The number of columns in the grid.\n        B: A set of tuples, where each tuple (r, c) is a blocked cell.\n\n    Returns:\n        The integer number of connected components of unblocked cells.\n    \"\"\"\n    if m == 0 or n == 0:\n        return 0\n\n    # grid[r, c] = 0: unblocked, unvisited\n    # grid[r, c] = -1: blocked\n    # grid[r, c] > 0: part of component with that ID\n    grid = np.zeros((m, n), dtype=np.int32)\n    for r, c in B:\n        if 0 <= r < m and 0 <= c < n:\n            grid[r, c] = -1\n\n    num_components = 0\n    for r in range(m):\n        for c in range(n):\n            if grid[r, c] == 0:\n                # Found a new component\n                num_components += 1\n                \n                # Start a Breadth-First Search (BFS) to find all cells in this component\n                q = collections.deque([(r, c)])\n                grid[r, c] = num_components # Mark as visited\n\n                while q:\n                    curr_r, curr_c = q.popleft()\n                    \n                    # Explore 4-directional neighbors\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        next_r, next_c = curr_r + dr, curr_c + dc\n                        \n                        # Check boundaries and if the neighbor is unvisited\n                        if 0 <= next_r < m and 0 <= next_c < n and grid[next_r, next_c] == 0:\n                            grid[next_r, next_c] = num_components\n                            q.append((next_r, next_c))\n                            \n    return num_components\n\ndef solve():\n    \"\"\"\n    Solves the pre-defined test cases for the connected components problem.\n    \"\"\"\n    test_cases = [\n        (5, 7, {(0, 1), (0, 5), (1, 1), (1, 5), (2, 3), (2, 5), (3, 0), (3, 1), (3, 2), (3, 3), (3, 5), (4, 5)}),\n        (0, 5, set()),\n        (3, 3, {(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)}),\n        (1, 6, {(0, 1), (0, 3), (0, 4)}),\n        (3, 4, set())\n    ]\n\n    results = []\n    for m, n, B in test_cases:\n        result = count_components(m, n, B)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "Graphs are not always static; in many systems, nodes or links can fail. This practice explores the effect of vertex removal on a graph's connectivity, a concept central to network robustness and fault tolerance. By calculating the number of connected components in the remaining graph , you will gain practical experience in analyzing how the removal of key vertices can fracture a network into separate parts.",
            "id": "3223832",
            "problem": "Consider an undirected simple graph $G = (V, E)$, where $V = \\{0, 1, \\dots, n-1\\}$ and $E \\subseteq \\{\\{u, v\\} \\mid u \\in V, v \\in V, u \\neq v\\}$. For a subset of vertices $S \\subseteq V$, define the induced subgraph $G[V \\setminus S]$ to have vertex set $V \\setminus S$ and edge set $\\{\\{u, v\\} \\in E \\mid u \\notin S, v \\notin S\\}$. Two vertices $u, v \\in V \\setminus S$ are said to be connected in $G[V \\setminus S]$ if there exists a path (a sequence of vertices with successive pairs adjacent) entirely within $V \\setminus S$ that starts at $u$ and ends at $v$. A connected component of $G[V \\setminus S]$ is a maximal subset $C \\subseteq V \\setminus S$ such that every pair of vertices in $C$ is connected in $G[V \\setminus S]$. A single isolated vertex (with no incident edges in $G[V \\setminus S]$) counts as a connected component.\n\nStarting only from these definitions, write a program that, for each specified test case below, computes the number of connected components in the induced subgraph after removing the given set $S$.\n\nThe graph is always finite, undirected, and simple (no self-loops or parallel edges). Vertices are labeled by integers from $0$ to $n-1$. Edges are given as unordered pairs $(u, v)$ with $u \\neq v$.\n\nTest suite (each case is given by the tuple $(n, E, S)$):\n- Case $1$: $n = 9$, $E = \\{(0, 1), (1, 2), (2, 3), (2, 4), (4, 5), (5, 6), (6, 4), (7, 8)\\}$, $S = \\{2, 5\\}$.\n- Case $2$: $n = 5$, $E = \\{(0, 1), (1, 2)\\}$, $S = \\varnothing$.\n- Case $3$: $n = 4$, $E = \\{(0, 1), (2, 3)\\}$, $S = \\{0, 1, 2, 3\\}$.\n- Case $4$: $n = 6$, $E = \\varnothing$, $S = \\{1, 3\\}$.\n- Case $5$: $n = 7$, $E = \\{(0, 1), (1, 2), (2, 3), (3, 0), (3, 4), (4, 5)\\}$, $S = \\{1\\}$.\n- Case $6$: $n = 7$, $E = \\{(0, 1), (0, 2), (0, 3), (3, 4), (3, 5), (5, 6)\\}$, $S = \\{0, 3\\}$.\n\nYour program should produce a single line of output containing the results for the six cases as a comma-separated list enclosed in square brackets (for example, $[r_1, r_2, \\dots, r_6]$), where each $r_i$ is the integer number of connected components for case $i$ in the order listed above.",
            "solution": "The problem requires us to determine the number of connected components in an induced subgraph $G[V \\setminus S]$ for several given graphs $G=(V, E)$ and vertex subsets $S$.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n- Graph Type: Undirected, simple graph $G = (V, E)$.\n- Vertex Set: $V = \\{0, 1, \\dots, n-1\\}$.\n- Edge Set: $E \\subseteq \\{\\{u, v\\} \\mid u \\in V, v \\in V, u \\neq v\\}$.\n- Removed Vertices: A subset $S \\subseteq V$.\n- Induced Subgraph: $G[V \\setminus S]$ has vertex set $V' = V \\setminus S$ and edge set $E' = \\{\\{u, v\\} \\in E \\mid u \\notin S, v \\notin S\\}$.\n- Connectivity: Two vertices $u, v \\in V'$ are connected in $G[V \\setminus S]$ if a path exists between them using only vertices in $V'$ and edges in $E'$.\n- Connected Component: A maximal subset of vertices in $V'$ that are mutually connected. An isolated vertex in $G[V \\setminus S]$ constitutes a component of size $1$.\n- Objective: Compute the number of connected components in $G[V \\setminus S]$ for each of the six provided test cases.\n- Test Cases:\n    1. $n=9$, $E = \\{(0, 1), (1, 2), (2, 3), (2, 4), (4, 5), (5, 6), (6, 4), (7, 8)\\}$, $S = \\{2, 5\\}$.\n    2. $n=5$, $E = \\{(0, 1), (1, 2)\\}$, $S = \\varnothing$.\n    3. $n=4$, $E = \\{(0, 1), (2, 3)\\}$, $S = \\{0, 1, 2, 3\\}$.\n    4. $n=6$, $E = \\varnothing$, $S = \\{1, 3\\}$.\n    5. $n=7$, $E = \\{(0, 1), (1, 2), (2, 3), (3, 0), (3, 4), (4, 5)\\}$, $S = \\{1\\}$.\n    6. $n=7$, $E = \\{(0, 1), (0, 2), (0, 3), (3, 4), (3, 5), (5, 6)\\}$, $S = \\{0, 3\\}$.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is scientifically grounded in the well-defined mathematical field of graph theory. The definitions of an undirected graph, induced subgraph, and connected components are standard and unambiguous. All necessary data ($n$, $E$, $S$) for each case are provided, making the problem self-contained and complete. The problem is well-posed, as for any finite graph, the number of connected components is a unique, determinable integer. The problem statement is objective and free of any factual errors, logical contradictions, or ill-posed structures.\n\n**Step 3: Verdict and Action**\nThe problem is **valid**. A solution will be developed.\n\n### Principle-Based Solution\n\nThe fundamental principle for counting connected components in a graph is to systematically explore its vertices. Each time a traversal must be initiated from a previously unvisited vertex, a new connected component has been discovered. A graph traversal algorithm, such as Depth-First Search (DFS) or Breadth-First Search (BFS), can be employed for this purpose.\n\nLet the induced subgraph be denoted by $G' = G[V \\setminus S]$, with vertex set $V' = V \\setminus S$ and edge set $E' = \\{\\{u, v\\} \\in E \\mid u, v \\in V'\\}$. The algorithm proceeds as follows:\n\n1.  **Construct the Induced Subgraph $G'$**:\n    First, we must explicitly represent the graph on which we will operate. The set of vertices $V'$ is obtained by taking the set difference $V \\setminus S = \\{v \\in V \\mid v \\notin S\\}$. The edge set $E'$ is constructed by filtering the original edge set $E$, retaining only those edges whose endpoints are both in $V'$. An adjacency list is an efficient data structure for this representation, where each vertex $v \\in V'$ is mapped to a list of its adjacent vertices in $G'$.\n\n2.  **Initialize State**:\n    We require a counter for the number of components, let's call it $c_{count}$, initialized to $0$. We also need a mechanism to track visited vertices to ensure each vertex is processed only once. A set data structure, let's call it $V_{visited}$, is suitable for this, initialized to be empty.\n\n3.  **Iterate and Traverse**:\n    The core of the algorithm is a loop over all vertices in the induced subgraph's vertex set, $V'$. For each vertex $v \\in V'$:\n    - If $v$ has already been visited (i.e., $v \\in V_{visited}$), we do nothing and proceed to the next vertex.\n    - If $v$ has not been visited (i.e., $v \\notin V_{visited}$), it signifies the discovery of a new, unexplored connected component. We then:\n        a. Increment the component counter: $c_{count} \\leftarrow c_{count} + 1$.\n        b. Initiate a graph traversal (e.g., DFS) starting from $v$. This traversal will explore all vertices reachable from $v$ in $G'$.\n        c. During the traversal, every vertex encountered is marked as visited by adding it to the set $V_{visited}$.\n\n4.  **Graph Traversal (Depth-First Search)**:\n    A standard iterative DFS can be implemented using a stack.\n    - To traverse a component starting from vertex $v_{start}$:\n        a. Initialize a stack and push $v_{start}$ onto it.\n        b. While the stack is not empty:\n            i. Pop a vertex, say $u$, from the stack.\n            ii. If $u$ is not in $V_{visited}$, mark it as visited ($V_{visited} \\leftarrow V_{visited} \\cup \\{u\\}$).\n            iii. For each neighbor $w$ of $u$ in the adjacency list of $G'$, if $w$ is not in $V_{visited}$, push $w$ onto the stack.\n\nAfter iterating through all vertices in $V'$, the final value of $c_{count}$ is the total number of connected components in $G'$.\n\nLet us apply this procedure to Case $1$:\n- $n=9$, $V=\\{0, ..., 8\\}$, $S=\\{2, 5\\}$.\n- $V' = V \\setminus S = \\{0, 1, 3, 4, 6, 7, 8\\}$.\n- Edges $(u,v) \\in E$ with $u,v \\in V'$ are: $(0,1)$, $(4,6)$, $(7,8)$.\n- Adjacency List for $G'$: $\\{0:[1], 1:[0], 3:[], 4:[6], 6:[4], 7:[8], 8:[7]\\}$.\n- Algorithm Execution:\n    - Initialize $c_{count} = 0$, $V_{visited} = \\varnothing$.\n    - Pick vertex $0 \\in V'$. It is not visited.\n        - $c_{count} \\leftarrow 1$.\n        - Start traversal from $0$. It will visit vertices $\\{0, 1\\}$. Now $V_{visited} = \\{0, 1\\}$.\n    - Pick vertex $3 \\in V'$. It is not visited.\n        - $c_{count} \\leftarrow 2$.\n        - Start traversal from $3$. It will visit only $\\{3\\}$. Now $V_{visited} = \\{0, 1, 3\\}$.\n    - Pick vertex $4 \\in V'$. It is not visited.\n        - $c_{count} \\leftarrow 3$.\n        - Start traversal from $4$. It will visit vertices $\\{4, 6\\}$. Now $V_{visited} = \\{0, 1, 3, 4, 6\\}$.\n    - Pick vertex $7 \\in V'$. It is not visited.\n        - $c_{count} \\leftarrow 4$.\n        - Start traversal from $7$. It will visit vertices $\\{7, 8\\}$. Now $V_{visited} = \\{0, 1, 3, 4, 6, 7, 8\\}$.\n    - All vertices in $V'$ are now in $V_{visited}$. The loop terminates.\n- The result for Case $1$ is $4$. This logic is applied to all test cases. For Case $3$, $V'$ is empty, so the number of components is correctly identified as $0$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the number of connected components for a series of graph test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (n, E, S)\n    # n: number of vertices\n    # E: set of edges as tuples\n    # S: set of vertices to remove\n    test_cases = [\n        (9, {(0, 1), (1, 2), (2, 3), (2, 4), (4, 5), (5, 6), (6, 4), (7, 8)}, {2, 5}),\n        (5, {(0, 1), (1, 2)}, set()),\n        (4, {(0, 1), (2, 3)}, {0, 1, 2, 3}),\n        (6, set(), {1, 3}),\n        (7, {(0, 1), (1, 2), (2, 3), (3, 0), (3, 4), (4, 5)}, {1}),\n        (7, {(0, 1), (0, 2), (0, 3), (3, 4), (3, 5), (5, 6)}, {0, 3}),\n    ]\n\n    results = []\n    for n, E, S in test_cases:\n        # Step 1: Determine the set of vertices in the induced subgraph G[V \\ S].\n        active_vertices = {i for i in range(n)} - S\n\n        # If there are no vertices in the induced subgraph, there are 0 components.\n        if not active_vertices:\n            results.append(0)\n            continue\n\n        # Step 2: Build the adjacency list for the induced subgraph.\n        # An adjacency list is a dictionary mapping each vertex to a list of its neighbors.\n        adj = {v: [] for v in active_vertices}\n        for u, v in E:\n            # An edge is part of the induced subgraph only if both its endpoints are.\n            if u in active_vertices and v in active_vertices:\n                adj[u].append(v)\n                adj[v].append(u)\n\n        # Step 3: Count connected components using a graph traversal algorithm.\n        visited = set()\n        num_components = 0\n\n        # Iterate through each vertex of the induced subgraph.\n        for vertex in active_vertices:\n            # If a vertex hasn't been visited, it belongs to a new component.\n            if vertex not in visited:\n                num_components += 1\n                # Start a traversal (iterative DFS) to find all vertices in this component.\n                stack = [vertex]\n                while stack:\n                    current_node = stack.pop()\n                    if current_node not in visited:\n                        visited.add(current_node)\n                        for neighbor in adj[current_node]:\n                            if neighbor not in visited:\n                                stack.append(neighbor)\n        \n        results.append(num_components)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Beyond simply identifying connected components, a crucial next step is to use this information to solve optimization problems. This advanced exercise  challenges you to determine the minimum cost to merge all components of a fragmented graph into a single connected entity. Successfully solving this requires a clever greedy strategy, treating the components themselves as nodes in a higher-level problem and finding the most efficient way to link them.",
            "id": "3223947",
            "problem": "You are given a finite, undirected, weighted graph with vertex set $V=\\{0,1,\\dots,n-1\\}$ and an edge set $E\\subseteq \\{\\{u,v\\}\\mid u\\neq v,\\,u,v\\in V\\}$ together with a nonnegative weight function on edges $w_E:\\,E\\to \\mathbb{R}_{\\ge 0}$. The edge weights $w_E$ are used only to define a realistic weighted graph instance; they do not contribute to the cost you must compute. The graph may be disconnected, forming several connected components. You are also given a nonnegative node-price function $p:\\,V\\to \\mathbb{R}_{\\ge 0}$. You are allowed to add any new undirected edge $\\{u,v\\}$ not already in $E$ between distinct vertices $u$ and $v$, and the cost you pay to add such an edge is $p(u)+p(v)$. Existing edges in $E$ are already present at no additional cost.\n\nTask. Starting only from the fundamental definitions of connected components in undirected graphs and the requirement that any two different components must be joined by at least one new edge to make the overall graph connected, derive an algorithm that computes the minimum total cost to add edges so that the entire graph becomes a single connected component. If the graph is already connected, the cost is $0$. All quantities must be treated as exact real numbers; there are no physical units to report. You must reason from first principles: define connected components precisely, characterize how a single new edge can merge two components, and determine how to combine such merges to achieve global connectivity with minimal total cost. Avoid any use of unproven shortcut formulas.\n\nPrecise input model for each test case. A test case is a triple $(n,E,p)$ where:\n1) $n$ is an integer with $n\\ge 1$ giving the number of vertices labeled $0$ through $n-1$;\n2) $E$ is a list of triples $(u,v,w)$ where $u$ and $v$ are integers with $0\\le u,v < n$, $u\\ne v$, and $w\\in \\mathbb{R}_{\\ge 0}$; each triple denotes an undirected edge between $u$ and $v$ with existing weight $w$ (which does not directly affect the cost you must compute);\n3) $p$ is a list of length $n$ whose $i$-th entry $p[i]$ equals $p(i)\\in \\mathbb{R}_{\\ge 0}$.\n\nYour program must compute, for each test case, a single number equal to the minimal additional cost required to add edges so that the entire graph becomes connected, under the rule that adding a new edge $\\{u,v\\}$ costs $p(u)+p(v)$. If the graph is already connected, the cost must be $0$.\n\nTest suite. Use the following five test cases exactly and in this order:\n1) $n=6$, $E=\\{(0,1,4),(1,2,3),(3,4,2)\\}$, $p=[4,2,7,1,3,5]$.\n2) $n=4$, $E=\\{(0,1,5),(1,2,2),(2,3,1)\\}$, $p=[10,10,10,10]$.\n3) $n=2$, $E=\\{\\}$, $p=[7,3]$.\n4) $n=7$, $E=\\{(0,1,5),(3,4,1),(5,6,8)\\}$, $p=[8,6,5,9,2,4,7]$.\n5) $n=1$, $E=\\{\\}$, $p=[5]$.\n\nOutput specification. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For example, if the results of the five test cases were $a_1,a_2,a_3,a_4,a_5$, then you must print exactly the string \"[a_1,a_2,a_3,a_4,a_5]\" on one line with no spaces.\n\nNotes.\n1) You must treat edges as undirected. If $(u,v,w)\\in E$, then $(v,u,w)$ is implicitly also in $E$.\n2) Your algorithm should not assume any special structure beyond what is specified. It must be correct for any nonnegative node prices and any undirected graph structure.\n3) The answer for each test case is a single integer in these specific instances, but the general algorithm must handle real-valued $p(i)$ if present in other inputs.",
            "solution": "The user-provided problem is evaluated as follows.\n\n### Step 1: Extract Givens\n- **Graph Structure**: A finite, undirected, weighted graph with vertex set $V=\\{0,1,\\dots,n-1\\}$ and edge set $E\\subseteq \\{\\{u,v\\}\\mid u\\neq v,\\,u,v\\in V\\}$.\n- **Edge Weights**: A nonnegative weight function on existing edges, $w_E:\\,E\\to \\mathbb{R}_{\\ge 0}$, which does not contribute to the cost to be computed.\n- **Node Prices**: A nonnegative node-price function $p:\\,V\\to \\mathbb{R}_{\\ge 0}$.\n- **Action**: New undirected edges $\\{u,v\\}$ not in $E$ can be added.\n- **Cost Function**: The cost to add a new edge $\\{u,v\\}$ is $p(u)+p(v)$.\n- **Objective**: Compute the minimum total cost to add edges to make the entire graph a single connected component.\n- **Base Case**: If the graph is already connected, the cost is $0$.\n- **Input Model**: A test case is a triple $(n, E, p)$, where $n$ is the number of vertices, $E$ is a list of existing edges as triples $(u,v,w)$, and $p$ is a list of node prices.\n- **Test Suite**:\n    1. $n=6$, $E=\\{(0,1,4),(1,2,3),(3,4,2)\\}$, $p=[4,2,7,1,3,5]$.\n    2. $n=4$, $E=\\{(0,1,5),(1,2,2),(2,3,1)\\}$, $p=[10,10,10,10]$.\n    3. $n=2$, $E=\\{\\}$, $p=[7,3]$.\n    4. $n=7$, $E=\\{(0,1,5),(3,4,1),(5,6,8)\\}$, $p=[8,6,5,9,2,4,7]$.\n    5. $n=1$, $E=\\{\\}$, $p=[5]$.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientific Grounding**: The problem is firmly rooted in graph theory, a standard field of discrete mathematics and computer science. All concepts used—graphs, connected components, minimum spanning trees, and cost optimization—are well-defined and mathematically rigorous.\n- **Well-Posedness**: The problem is well-posed. Given a finite graph, there is a finite (though potentially large) number of ways to add edges. Since the costs are nonnegative, a minimum cost solution is guaranteed to exist. The objective is clear and a unique minimum cost value can be found.\n- **Objectivity**: The problem is stated objectively using formal mathematical language and notation. There are no subjective or ambiguous terms.\n- **Flaw Analysis**:\n    1. **Scientific Unsoundness**: The problem adheres to the principles of graph theory. No flaws found.\n    2. **Non-Formalizable/Irrelevant**: The problem is formal and directly related to the topic of connected components in graphs. No flaws found.\n    3. **Incomplete/Contradictory**: The problem statement is self-contained. It provides all necessary information ($n, E, p$) to construct the graph and cost structure. The mention that existing edge weights $w_E$ are not used in the cost calculation is a clarification, not a contradiction. No flaws found.\n    4. **Unrealistic/Infeasible**: As a problem in abstract mathematics, physical realism is not a relevant criterion. The mathematical setup is consistent. No flaws found.\n    5. **Ill-Posed/Poorly Structured**: The problem is clearly structured and leads to a unique minimum cost. No flaws found.\n    6. **Pseudo-Profound/Trivial**: The problem requires a non-trivial algorithmic solution derived from fundamental principles, as requested. It is a standard but substantive problem. No flaws found.\n    7. **Outside Scientific Verifiability**: The solution can be mathematically proven to be correct. No flaws found.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A reasoned solution will be provided.\n\n### Solution\nThe objective is to find the minimum cost to make a given graph $G=(V, E)$ connected by adding new edges. The cost of adding an edge $\\{u, v\\}$ is defined as $p(u) + p(v)$. We are required to derive the solution from first principles.\n\n**1. Connected Components and the Goal**\n\nAn undirected graph is *connected* if there is a path between any two of its vertices. The relation \"is connected to\" is an equivalence relation on the vertex set $V$. The equivalence classes of this relation are called the *connected components* of the graph. Let the initial graph have $k$ connected components, denoted $C_1, C_2, \\dots, C_k$. To make the entire graph connected, we must add edges such that all vertices belong to a single component.\n\nIf $k=1$, the graph is already connected, and by definition, the cost is $0$.\n\nIf $k > 1$, we must add edges to merge these $k$ components into one. Adding an edge $\\{u, v\\}$ where $u \\in C_i$ and $v \\in C_j$ with $i \\neq j$ merges components $C_i$ and $C_j$ into a single larger component. Adding an edge within a component does not reduce the number of components. To connect a graph of $k$ components, we must add at least $k-1$ edges, forming a spanning tree structure on the components themselves. Our goal is to select these $k-1$ edges to minimize the total cost.\n\n**2. Optimal Connection Strategy**\n\nLet's model the problem on the components. Consider a \"super-graph\" where each vertex represents a connected component $C_i$. We wish to find a minimum spanning tree (MST) in this super-graph. The weight of an edge between two super-vertices $C_i$ and $C_j$ is the minimum possible cost to connect them with a single new edge.\n\nThe cost to connect component $C_i$ to component $C_j$ is given by:\n$$ \\min_{u \\in C_i, v \\in C_j} \\{p(u) + p(v)\\} $$\nSince the terms $p(u)$ and $p(v)$ are independent, this minimum is achieved by choosing the vertex with the minimum price in each component.\n$$ (\\min_{u \\in C_i} p(u)) + (\\min_{v \\in C_j} p(v)) $$\nLet us define $w_i = \\min_{u \\in C_i} p(u)$ as the minimum node price within component $C_i$. The cost to connect $C_i$ and $C_j$ is thus $w_i + w_j$.\n\nWe now need to find an MST on a complete graph of $k$ vertices (representing the components), where the edge weight between vertex $i$ and vertex $j$ is $w_i + w_j$. Let the chosen spanning tree have edge set $T_{comp}$. The total cost is:\n$$ \\text{Cost} = \\sum_{\\{i, j\\} \\in T_{comp}} (w_i + w_j) $$\nThis sum can be rewritten in terms of the degrees of the vertices in the component spanning tree. If $d(i)$ is the degree of component $C_i$ in the tree $T_{comp}$, then its minimum price $w_i$ is included in the sum $d(i)$ times.\n$$ \\text{Cost} = \\sum_{i=1}^{k} d(i) w_i $$\nFor any tree with $k$ vertices, we know that $d(i) \\ge 1$ and $\\sum_{i=1}^{k} d(i) = 2(k-1)$. To minimize the total cost, which is a weighted sum of degrees, we should assign the largest degrees to the vertices with the smallest weights (prices) $w_i$. This is a direct application of the rearrangement inequality.\n\nThe highest possible degree in a tree on $k$ vertices is $k-1$, which occurs in a star graph. A star graph has one central vertex of degree $k-1$ and $k-1$ leaf vertices of degree $1$. To minimize the cost, we should choose the component with the globally minimum price as the central \"anchor\" component. Let the component prices be sorted as $w_{(1)} \\le w_{(2)} \\le \\dots \\le w_{(k)}$. We choose the component corresponding to $w_{(1)}$ as the center. Its degree in the spanning tree will be $d((1)) = k-1$. All other components $C_{(j)}$ for $j \\in \\{2, \\dots, k\\}$ will have degree $d((j)) = 1$. This strategy connects every other component directly to the single \"cheapest\" anchor component.\n\n**3. Cost Formula Derivation**\n\nThe total cost for this optimal star-graph strategy is the sum of the costs of the $k-1$ edges connecting each non-anchor component to the anchor component:\n$$ \\text{Cost} = \\sum_{j=2}^{k} (w_{(1)} + w_{(j)}) $$\nThis can be expanded and simplified:\n$$ \\text{Cost} = (k-1) w_{(1)} + \\sum_{j=2}^{k} w_{(j)} $$\nLet $S = \\sum_{j=1}^{k} w_{(j)}$ be the sum of all component-minimum prices. We can write $\\sum_{j=2}^{k} w_{(j)} = S - w_{(1)}$. Substituting this into the cost expression:\n$$ \\text{Cost} = (k-1) w_{(1)} + (S - w_{(1)}) = k w_{(1)} - w_{(1)} + S - w_{(1)} = S + (k-2) w_{(1)} $$\nSo, the minimum cost is the sum of the minimum prices of all components, plus $(k-2)$ times the globally smallest of these minimum prices. This formula holds for $k \\ge 2$. For $k=2$, the cost is $S + (0)w_{(1)} = S = w_{(1)} + w_{(2)}$, which is correct. For $k=1$, the cost is $0$.\n\n**4. Final Algorithm**\n\nThe complete algorithm is as follows:\n1.  Given the graph parameters $(n, E, p)$, construct an adjacency list representation of the graph.\n2.  Identify the connected components of the graph. This can be done using a graph traversal algorithm like Breadth-First Search (BFS) or Depth-First Search (DFS). Maintain a `visited` array to keep track of discovered vertices.\n3.  During the traversal for each component, find the minimum node price among all vertices in that component. Store these minimum prices in a list, `component_min_prices`.\n4.  Let $k$ be the number of connected components found (i.e., the length of `component_min_prices`).\n5.  If $k \\le 1$, the graph is already connected or trivial. The cost is $0$.\n6.  If $k > 1$, calculate the total minimum cost using the derived formula:\n    a. Calculate $S$, the sum of all values in `component_min_prices`.\n    b. Find $w_{\\min\\_global}$, the minimum value in `component_min_prices`.\n    c. The total cost is $S + (k-2) \\times w_{\\min\\_global}$.\n7.  Return the calculated cost.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for a predefined suite of test cases.\n    \"\"\"\n    # Test cases as defined in the problem statement.\n    test_cases = [\n        (6, [(0, 1, 4), (1, 2, 3), (3, 4, 2)], [4, 2, 7, 1, 3, 5]),\n        (4, [(0, 1, 5), (1, 2, 2), (2, 3, 1)], [10, 10, 10, 10]),\n        (2, [], [7, 3]),\n        (7, [(0, 1, 5), (3, 4, 1), (5, 6, 8)], [8, 6, 5, 9, 2, 4, 7]),\n        (1, [], [5])\n    ]\n\n    results = []\n    for n, E, p in test_cases:\n        cost = compute_min_cost(n, E, p)\n        # The problem statement implies integer results for these specific test cases.\n        results.append(int(cost))\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_min_cost(n, edges, prices):\n    \"\"\"\n    Computes the minimum cost to make a graph connected.\n\n    The algorithm proceeds as follows:\n    1. Identify all connected components of the graph.\n    2. For each component, find the minimum node price among its vertices.\n    3. If there is only one component (or fewer), the graph is already connected; cost is 0.\n    4. If there are k > 1 components, the minimum cost is achieved by connecting all other\n       k-1 components to the one \"anchor\" component that contains the node with the\n       globally minimum price.\n    5. The total cost is derived as S + (k-2)*w_min_global, where S is the sum of\n       all component-minimum prices and w_min_global is the smallest of these prices.\n    \"\"\"\n    if n <= 1:\n        return 0\n\n    # Adjacency list representation of the graph\n    adj = [[] for _ in range(n)]\n    for u, v, _ in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    visited = [False] * n\n    component_min_prices = []\n\n    for i in range(n):\n        if not visited[i]:\n            # A new component is found, start a traversal (DFS)\n            min_price_in_component = float('inf')\n            \n            stack = [i]\n            visited[i] = True\n            \n            while stack:\n                u = stack.pop()\n                min_price_in_component = min(min_price_in_component, prices[u])\n                \n                for v in adj[u]:\n                    if not visited[v]:\n                        visited[v] = True\n                        stack.append(v)\n            \n            component_min_prices.append(min_price_in_component)\n\n    k = len(component_min_prices)\n    \n    if k <= 1:\n        return 0\n    else:\n        # Sum of the minimum node prices from each component\n        sum_of_min_prices = sum(component_min_prices)\n        \n        # Globally minimum price among all component minimums\n        global_min_price = min(component_min_prices)\n        \n        # Derived formula for the total minimum cost\n        total_cost = sum_of_min_prices + (k - 2) * global_min_price\n        return total_cost\n\n# Execute the solution\nsolve()\n\n```"
        }
    ]
}