{
    "hands_on_practices": [
        {
            "introduction": "堆操作的效率与其结构密切相关。本练习旨在探索节点在堆中的位置与其上浮（sift-up）操作成本之间的联系。通过确定哪个节点在调整过程中移动的路径最长，我们可以深入理解上浮操作的最坏情况性能，并揭示数组索引与树深度之间的内在关系。",
            "id": "3239465",
            "problem": "考虑一个以$1$为基准索引的数组存储的二元最小堆，其形状为一棵完全二叉树：除了最后一层可能未满外，所有层都被完全填充，最后一层从左到右填充。对于任意索引 $i \\in \\{1,2,\\dots,n\\}$，其父节点索引定义为 $\\left\\lfloor \\frac{i}{2} \\right\\rfloor$。在索引 $i$ 处执行的“减小键值”操作会将该索引处的键值设置为一个严格小于所有现存键的值，从而强制执行一个最长的上滤序列，该序列通过反复将节点与其父节点交换，直到堆属性恢复。\n\n定义索引 $i$ 处的上滤路径长度为该上滤过程中执行的交换次数。在所有索引 $i \\in \\{1,2,\\dots,n\\}$ 中，确定能产生最长可能上滤路径长度的最小索引 $i^{\\star}$。请用一个关于 $n$ 的封闭形式表达式表示你的答案。无需四舍五入。",
            "solution": "首先对问题陈述进行验证。\n\n**第一步：提取已知条件**\n- 数据结构：一个存储在数组中的二元最小堆。\n- 索引：以$1$为基准，从 $i=1$ 到 $n$。\n- 形状：一棵完全二叉树。\n- 父节点函数：索引为 $i$ 的节点的父节点位于索引 $\\lfloor \\frac{i}{2} \\rfloor$ 处。\n- 操作：在索引 $i$ 处执行的“减小键值”操作会将该键值设置为一个严格小于堆中所有其他键的值。\n- 上滤：此操作会触发一个最长的上滤序列，其中索引 $i$ 处的节点反复与其父节点交换，直到到达根节点。\n- 定义：索引 $i$ 处的“上滤路径长度”是执行的交换次数。\n- 目标：找到在 $\\{1, 2, \\dots, n\\}$ 中能产生最长可能上滤路径长度的最小索引 $i^{\\star}$。\n- 输出格式：一个关于 $n$ 的 $i^{\\star}$ 的封闭形式表达式。\n\n**第二步：使用提取的已知条件进行验证**\n该问题具有科学依据，提法明确且客观。这是算法和数据结构分析中的一个标准问题，特别关注二元堆的性质。定义和约束条件是一致且完整的。将一个键设置为所有键中的最小值这一前提，提供了一个明确定义的场景：上滤操作总是终止于根节点，从而使得从该起始节点出发的路径长度达到最大。要求找到最大化此路径长度的*最小*索引，确保了解决方案的唯一性。该问题没有任何缺陷，是有效的。\n\n**第三步：结论与行动**\n该问题被认定为有效。将提供解答。\n\n**解答推导**\n问题要求找到能产生最长上滤路径长度的最小索引 $i^{\\star}$。对索引为 $i$ 的节点进行上滤操作，涉及反复将该节点与其父节点交换，父节点的索引由 $\\lfloor \\frac{i}{2} \\rfloor$ 给出。这个过程持续进行，直到该节点遇到一个键值小于或等于它的祖先，或者它成为根节点。\n\n问题规定 `decrease-key` 操作将索引 $i$ 处的键值设置为一个严格小于所有现存键的值。这保证了上滤过程直到节点成为堆的根节点（位于索引 1）时才会终止。\n\n“上滤路径长度”定义为交换的次数。一个从索引 $i$ 开始向根节点移动的节点的索引序列为 $i_0 = i$, $i_1 = \\lfloor \\frac{i_0}{2} \\rfloor$, $i_2 = \\lfloor \\frac{i_1}{2} \\rfloor, \\dots, i_k = 1$。执行的交换次数等于此序列中的步数，即 $k$。这个值 $k$ 正是索引为 $i$ 的节点在二叉树中的深度（假设根节点深度为 0）。\n\n我们可以在节点的索引 $i$ 和其深度之间建立直接关系。在一个以 1 为基准索引、结构为完全二叉树的二元堆中，深度为 $d$ 的节点的索引范围是从 $2^d$ 到 $2^{d+1}-1$。对于任意索引 $i$，其深度 $d$ 必须满足不等式 $2^d \\le i  2^{d+1}$。对该不等式取以 2 为底的对数，得到 $d \\le \\log_2(i)  d+1$。根据向下取整函数的定义，这意味着索引为 $i$ 的节点的深度 $d$ 由 $d = \\lfloor \\log_2(i) \\rfloor$ 给出。\n\n因此，索引为 $i$ 的节点的上滤路径长度为 $L(i) = \\lfloor \\log_2(i) \\rfloor$。\n\n问题要求找到最长的可能上滤路径长度。这等价于找到 $L(i)$ 在 $i \\in \\{1, 2, \\dots, n\\}$ 上的最大值。函数 $\\lfloor \\log_2(i) \\rfloor$ 是一个关于 $i$ 的非递减函数。因此，它在区间 $[1, n]$ 上的最大值将在最大索引处取得，即 $i=n$。所以，最大路径长度为 $L_{\\max} = \\lfloor \\log_2(n) \\rfloor$。这对应于堆中包含至少一个节点的最深层的深度。\n\n接着，问题要求找到能产生这个最长路径长度 $L_{\\max}$ 的*最小*索引 $i^{\\star}$。我们需要找到最小的 $i \\in \\{1, 2, \\dots, n\\}$ 使得 $L(i) = L_{\\max}$，即 $\\lfloor \\log_2(i) \\rfloor = \\lfloor \\log_2(n) \\rfloor$。\n\n令 $H = \\lfloor \\log_2(n) \\rfloor$。我们正在寻找最小的整数 $i^{\\star} \\in \\{1, 2, \\dots, n\\}$，使得 $\\lfloor \\log_2(i^{\\star}) \\rfloor = H$。\n条件 $\\lfloor \\log_2(i) \\rfloor = H$ 等价于 $H \\le \\log_2(i)  H+1$。\n以 2 为底取幂，我们得到 $2^H \\le i  2^{H+1}$。\n所有具有最大路径长度 $H$ 的索引集合，是堆中索引集合 $\\{1, 2, \\dots, n\\}$ 与深度为 $H$ 的索引集合 $\\{i \\in \\mathbb{Z}^+ \\mid 2^H \\le i  2^{H+1}\\}$ 的交集。这给出了候选索引的集合为 $\\{i \\in \\mathbb{Z}^+ \\mid 2^H \\le i \\le n\\}$。\n\n我们被要求找到此集合中的最小索引。满足 $2^H \\le i \\le n$ 的最小整数 $i$ 就是这个范围的下界，即 $2^H$。\n\n将 $H$ 的表达式代回，能产生最长可能上滤路径的最小索引 $i^{\\star}$ 是：\n$$i^{\\star} = 2^H = 2^{\\lfloor \\log_2(n) \\rfloor}$$\n这个表达式给出了大小为 $n$ 的完全二叉树中最深层上第一个（最左边）节点的索引。",
            "answer": "$$\\boxed{2^{\\lfloor \\log_2(n) \\rfloor}}$$"
        },
        {
            "introduction": "标准的下沉（sift-down）操作遵循一套严格的逻辑规则。这个思想实验将过程反转：给定算法留下的一系列交换“踪迹”，你必须推断出所涉及元素的初始相对大小。这项练习将磨练你对最大堆性质以及下沉操作每一步精确逻辑的理解。",
            "id": "3239390",
            "problem": "考虑一个存储在数组 $A[1..n]$ 中的二叉最大堆，其中 $n \\ge 15$。该堆使用通常的数组到树的映射方式，即索引 $i$ 的父节点是 $\\lfloor i/2 \\rfloor$，其子节点是 $2i$ 和 $2i+1$（只要这些索引在 $[1..n]$ 范围内）。根据最大堆性质，对于每个有子节点的内部节点 $i$，都有 $A[i] \\ge A[2i]$ 且 $A[i] \\ge A[2i+1]$。一个从起始索引 $s$ 开始的标准下沉操作（也称为堆化下沉）会重复地将 $A[s]$ 与其子节点进行比较，选择较大的子节点 $c \\in \\{2s, 2s+1\\}$，如果 $A[s]  A[c]$，则交换索引 $s$ 和 $c$ 处的元素，然后从索引 $c$ 继续此过程；否则停止。\n\n假设我们在一个最大堆性质可能仅在索引 $1$ 处被违反的配置中，从根节点（即 $s = 1$）开始执行一次下沉操作（例如，在将一个新键放置在 $A[1]$ 后，而所有其他位置仍满足最大堆性质）。该下沉操作恰好执行了以下交换序列（写作索引的有序对）：$(1,3)$、$(3,7)$、$(7,15)$，然后终止。\n\n仅根据此交换序列和上述基本定义，以下关于初始值 $A[1]$、$A[3]$、$A[7]$ 和 $A[15]$ 的哪个陈述必须为真？\n\nA. $A[3] \\ge A[7] \\ge A[15] \\ge A[1]$\n\nB. $A[1] \\ge A[3] \\ge A[7] \\ge A[15]$\n\nC. $A[3] \\le A[7] \\le A[15] \\le A[1]$\n\nD. $A[3] \\ge A[1] \\ge A[7] \\ge A[15]$",
            "solution": "问题陈述是有效的。它在数据结构的原理上是科学合理的，问题定义良好、客观，并包含足够的信息以进行唯一的逻辑推导。\n\n设 $A[k]$ 表示在下沉操作开始前，数组中索引为 $k$ 的元素的初始值。我们有两个关键信息：下沉算法执行的交换序列和堆的初始状态。\n\n首先，我们分析堆的初始状态。题目指出，最大堆性质可能*仅*在索引 $1$ 处被违反。这意味着对于任何节点 $i  1$，以 $i$ 为根的子树是一个有效的最大堆。我们将此应用于与问题相关的节点。\n1.  以索引 $3$ 为根的子树是一个有效的最大堆。节点 $3$ 的子节点是节点 $2 \\times 3 = 6$ 和 $2 \\times 3 + 1 = 7$。因为 $n \\ge 15$，这些节点是存在的。节点 $3$ 处的最大堆性质要求 $A[3] \\ge A[6]$ 且 $A[3] \\ge A[7]$。特别地，我们有：\n    $$A[3] \\ge A[7]$$\n2.  以索引 $7$ 为根的子树是一个有效的最大堆。节点 $7$ 的子节点是节点 $2 \\times 7 = 14$ 和 $2 \\times 7 + 1 = 15$。因为 $n \\ge 15$，这些节点是存在的。节点 $7$ 处的最大堆性质要求 $A[7] \\ge A[14]$ 且 $A[7] \\ge A[15]$。特别地，我们有：\n    $$A[7] \\ge A[15]$$\n\n结合从初始堆结构中推导出的这两个不等式，我们得到关系：\n$$A[3] \\ge A[7] \\ge A[15]$$\n\n接下来，我们分析从根节点（索引 $s=1$）开始的下沉过程。被下沉的元素是初始位于 $A[1]$ 的元素。我们称其值为 $v = A[1]$。\n\n1.  **第一次交换：$(1, 3)$**。在索引 $1$ 处，下沉算法将 $A[1]$ 与其子节点 $A[2]$ 和 $A[3]$ 进行比较。与索引 $3$ 发生了交换。这意味着两个条件：\n    a. 索引 $3$ 处的值是两个子节点中较大的，所以 $A[3] \\ge A[2]$。\n    b. 索引 $1$ 处的值小于较大子节点的值，所以 $A[1]  A[3]$。\n    这次交换后，元素 $v$（最初的 $A[1]$）现在位于索引 $3$。\n\n2.  **第二次交换：$(3, 7)$**。下沉过程从索引 $3$ 继续，此时该处的值为 $v$。算法将 $v$ 与节点 $3$ 的子节点 $A[6]$ 和 $A[7]$ 进行比较。与索引 $7$ 发生了交换。这意味着：\n    a. 索引 $7$ 处的值是两个子节点中较大的，所以 $A[7] \\ge A[6]$。\n    b. 值 $v$ 小于较大子节点的值，所以 $v  A[7]$，即 $A[1]  A[7]$。\n    这次交换后，元素 $v$ 现在位于索引 $7$。\n\n3.  **第三次交换：$(7, 15)$**。过程从索引 $7$ 继续，此时该处的值为 $v$。算法将 $v$ 与节点 $7$ 的子节点 $A[14]$ 和 $A[15]$ 进行比较。与索引 $15$ 发生了交换。这意味着：\n    a. 索引 $15$ 处的值是两个子节点中较大的，所以 $A[15] \\ge A[14]$。\n    b. 值 $v$ 小于较大子节点的值，所以 $v  A[15]$，即 $A[1]  A[15]$。\n    这次交换后，元素 $v$ 现在位于索引 $15$。\n\n4.  **终止**。过程在第三次交换后终止。这意味着当在索引 $15$（$v$ 的新位置）考虑下沉时，没有进一步的交换发生。这要么是因为节点 $15$ 没有子节点（如果 $n  30$），要么是因为 $v$ 大于或等于其子节点（$A[30]$ 和 $A[31]$，如果存在）的值。\n\n我们来综合关于初始值 $A[1]$、$A[3]$、$A[7]$ 和 $A[15]$ 的发现。\n- 根据初始堆状态：$A[3] \\ge A[7] \\ge A[15]$。\n- 根据第三次交换 $(7,15)$：我们必须有 $A[1]  A[15]$。发生交换需要严格不等式。\n\n结合这些结果，我们可以形成一个不等式链：\n$$A[3] \\ge A[7] \\ge A[15] > A[1]$$\n因为 $A[15] > A[1]$ 意味着 $A[15] \\ge A[1]$，所以以下陈述必须为真：\n$$A[3] \\ge A[7] \\ge A[15] \\ge A[1]$$\n\n现在我们基于这个推导出的关系来评估每个选项。\n\nA. $A[3] \\ge A[7] \\ge A[15] \\ge A[1]$\n该陈述与我们的推论完全匹配。基于问题的给定前提，此链中的每个不等式都必须成立。\n结论：**正确**。\n\nB. $A[1] \\ge A[3] \\ge A[7] \\ge A[15]$\n该陈述包含 $A[1] \\ge A[3]$。我们对第一次交换 $(1,3)$ 的分析表明 $A[1]  A[3]$。因此，此选项为假。\n结论：**错误**。\n\nC. $A[3] \\le A[7] \\le A[15] \\le A[1]$\n该陈述包含 $A[15] \\le A[1]$。我们对第三次交换 $(7,15)$ 的分析表明 $A[1]  A[15]$。因此，此选项为假。\n结论：**错误**。\n\nD. $A[3] \\ge A[1] \\ge A[7] \\ge A[15]$\n该陈述包含 $A[1] \\ge A[7]$。我们对第二次交换 $(3,7)$ 的分析表明 $A[1]  A[7]$。因此，此选项为假。\n结论：**错误**。\n\n只有选项A与问题陈述的推论一致。",
            "answer": "$$\n\\boxed{A}\n$$"
        },
        {
            "introduction": "在最小堆中，为什么下沉操作总是与值*较小*的子节点交换？本练习将通过一个错误的算法变体来挑战你，该变体总是与值较大的子节点交换。通过找出这个错误代码在哪些特定场景下会失败，你将对那些维护堆不变量的精妙而关键的细节有更深刻的领会。",
            "id": "3239430",
            "problem": "一个二叉最小堆是一个用数组 $a[1..n]$ 表示的完全二叉树，它具有这样的性质：对于每个有子节点的索引 $i$，$a[i] \\leq a[2i]$ 并且 $a[i] \\leq a[2i+1]$。标准的下滤操作，当在一个持有可能会违反最小堆性质的键 $x$ 的节点 $i$ 上调用时，会重复地将 $x$ 与其两个子节点中较小的一个向下交换，直到沿该路径恢复性质。\n\n考虑一个有缺陷的下滤变体，它在每一步选择较大的子节点（确定性地选择右子节点来打破平局），并且仅当较大的子节点严格小于当前键时才进行交换。也就是说，在一个有子节点 $2i$ 和 $2i+1$ 的节点 $i$ 处，如果 $a[2i] \\leq a[2i+1]$，算法将 $a[2i+1]$（较大的子节点）与 $a[i]$ 进行比较；如果 $a[2i]  a[2i+1]$，算法将 $a[2i]$（较大的子节点）与 $a[i]$ 进行比较。当较大的子节点严格小于 $a[i]$ 时，算法将 $a[i]$ 与该较大的子节点交换，并在子节点的索引处继续；否则，它就停止。\n\n从索引为1的根节点开始，假设下面的数组以广度优先顺序（从1开始的索引）编码了堆。在每个选项中，$a[1]$ 是要下滤的当前键 $x$，并且在有缺陷的过程开始之前，所有子树相对于它们自己的根都初始满足最小堆性质。对于每个选项，判断这个有缺陷的下滤是否在根节点“看起来正常”（即，在第一次操作后，根节点与其两个子节点之间的局部关系没有违反最小堆性质），但随后由于选择与较大的子节点比较和交换，而在更深的层次上未能保持最小堆性质。\n\n选择出现此现象的所有选项。\n\nA. $a = \\langle 9, 4, 4, 12, 13, 10, 8 \\rangle$\n\nB. $a = \\langle 9, 4, 4, 12, 13, 20, 21 \\rangle$\n\nC. $a = \\langle 9, 4, 7, 12, 13, 20, 21 \\rangle$\n\nD. $a = \\langle 5, 5, 5, 12, 13, 20, 21 \\rangle$\n\nE. $a = \\langle 14, 10, 10, 16, 17, 11, 15 \\rangle$",
            "solution": "我们从核心定义开始。一个二叉最小堆要求对于每个节点索引 $i$，如果其子节点存在，则 $a[i] \\leq a[2i]$ 并且 $a[i] \\leq a[2i+1]$。正确的下滤操作背后的原理是，将一个违反性质的键 $x$ 沿着最小子节点的路径向下移动，这样每次交换后，新的父节点都是局部三者中最小的，从而保证交换后 $a[\\text{parent}] \\leq a[\\text{sibling child}]$，并且违规情况被限制在 $x$ 下降的路径上。形式上，如果两个子节点的键为 $s$ 和 $m$ 且 $s \\leq m$，将 $x$ 与 $s$ 交换（当 $s  x$ 时）会产生一个键为 $s$ 的局部父节点，并且由于 $s \\leq m$，局部性质得到满足。\n\n相比之下，这个有缺陷的算法只将 $x$ 与较大的子节点 $m$ 进行比较，并且当且仅当 $m  x$ 时才进行交换。当 $x > m > s$ 时，这个选择会立即失败，因为与 $m$ 交换后，新的父节点 $m$ 将严格大于其兄弟节点 $s$，从而在当前层级违反最小堆性质。即使在当前层级子节点相等，这个有缺陷的算法也可能在树的更深处引发失败：下降的 $x$ 可能到达一个节点，其子节点为 $s$ 和 $m$ 且 $s  x  m$，由于有缺陷的算法只将 $m$ 与 $x$ 比较，它会停止（因为 $m \\not x$），留下 $x$ 作为父节点，其下方有一个更小的子节点 $s$，这违反了最小堆性质。\n\n我们使用从1开始的索引和给定的数组，逐个分析每个选项。\n\n选项 A：$a = \\langle 9, 4, 4, 12, 13, 10, 8 \\rangle$。\n- 根节点和子节点：$a[1] = 9$, $a[2] = 4$, $a[3] = 4$。子节点相等。根据指定的打破平局规则，有缺陷的算法选择索引3处的右子节点作为“较大”的子节点进行比较。由于 $a[3] = 4  9$，有缺陷的算法交换 $a[1]$ 和 $a[3]$。\n- 交换后：$a[1] = 4$, $a[3] = 9$, $a[2] = 4$。在根节点局部，$a[1] \\leq a[2]$ 和 $a[1] \\leq a[3]$ 成立，因此它在根节点“看起来正常”。\n- 在索引3处继续对 $x = 9$ 进行有缺陷的下滤。其子节点在索引6和7处：$a[6] = 10$, $a[7] = 8$。这里较大的子节点是 $a[6] = 10$，较小的是 $a[7] = 8$。由于 $10 \\not 9$，有缺陷的算法停止，尽管 $8  9$。结果使得 $a[3] = 9$ 的一个子节点 $a[7] = 8$ 小于其父节点，在更深的层次上违反了最小堆性质。结论：正确——此选项展示了该现象。\n\n选项 B：$a = \\langle 9, 4, 4, 12, 13, 20, 21 \\rangle$。\n- 根节点和子节点：$a[1] = 9$, $a[2] = 4$, $a[3] = 4$。与选项A一样，有缺陷的算法选择索引3处的右子节点并进行交换，因为 $4  9$。\n- 交换后：$a[1] = 4$, $a[3] = 9$, $a[2] = 4$。在根节点局部，性质成立。\n- 在索引3处继续处理 $x = 9$。子节点为 $a[6] = 20$, $a[7] = 21$。较大的子节点是 $21$，并且由于 $21 \\not 9$，有缺陷的算法停止。关键是，两个子节点 $20$ 和 $21$ 都 $\\geq 9$，所以在索引3处没有违反性质。整个堆仍然有效。结论：不正确——没有发生更深层次的违反。\n\n选项 C：$a = \\langle 9, 4, 7, 12, 13, 20, 21 \\rangle$。\n- 根节点和子节点：$a[1] = 9$, $a[2] = 4$, $a[3] = 7$。较大的子节点是 $7$。由于 $7  9$，有缺陷的算法交换 $a[1]$ 和 $a[3]$。\n- 交换后：$a[1] = 7$, $a[3] = 9$，而 $a[2] = 4$ 保持不变。现在在根节点，$a[1] = 7$ 且 $a[2] = 4$，所以 $a[1] \\leq a[2]$ 不成立（$7 \\not\\leq 4$）。这是一个在当前层级的直接违规，而不是更深层次的违规。所描述的现象没有发生，因为它在根节点甚至没有“看起来正常”。结论：不正确。\n\n选项 D：$a = \\langle 5, 5, 5, 12, 13, 20, 21 \\rangle$。\n- 根节点和子节点：$a[1] = 5$, $a[2] = 5$, $a[3] = 5$。较大的子节点（根据打破平局规则）是 $a[3] = 5$。由于 $5 \\not 5$，有缺陷的算法立即停止。\n- 根节点 $a[1] = 5$ 满足 $a[1] \\leq a[2]$ 和 $a[1] \\leq a[3]$；所有子树已经满足最小堆性质。没有交换，也没有违反。结论：不正确——没有发生更深层次的违反。\n\n选项 E：$a = \\langle 14, 10, 10, 16, 17, 11, 15 \\rangle$。\n- 根节点和子节点：$a[1] = 14$, $a[2] = 10$, $a[3] = 10$。子节点相等；根据打破平局规则，有缺陷的算法选择索引3处的右子节点，并且由于 $10  14$，它交换 $a[1]$ 和 $a[3]$。\n- 交换后：$a[1] = 10$, $a[3] = 14$, $a[2] = 10$。在根节点局部，$a[1] \\leq a[2]$ 和 $a[1] \\leq a[3]$ 成立，因此它在根节点“看起来正常”。\n- 在索引3处继续处理 $x = 14$。其子节点是 $a[6] = 11$, $a[7] = 15$，较大的子节点是 $15$，较小的子节点是 $11$。由于 $15 \\not 14$，有缺陷的算法停止，尽管 $11  14$。这使得 $a[3] = 14$ 的上方有一个更小的子节点 $a[6] = 11$，在树的更深处违反了最小堆性质。结论：正确——此选项展示了该现象。\n\n各选项结论摘要：\n- A: 正确——在根节点看起来正常，但在更深处失败。\n- B: 不正确——仍然是一个有效的最小堆。\n- C: 不正确——立即在根节点失败。\n- D: 不正确——没有交换，也没有违反。\n- E: 正确——在根节点看起来正常，但在更深处失败。\n\n因此，正确的选择是选项A和E。\n\n除了这些具体实例，这些反例存在的原理性原因是，与较大的子节点 $m$ 进行比较不足以保证最小堆的正确性：任何时候，当一个节点有子节点 $s$ 和 $m$ 且 $s  m$，而父节点 $x$ 满足 $s  x \\leq m$ 时，有缺陷的算法将不会交换（因为 $m \\not x$），并会留下 $x$ 作为 $s$ 的父节点，从而违反 $a[\\text{parent}] \\leq a[\\text{child}]$。当根节点的两个子节点相等时，第一次有缺陷的交换可以产生一个局部不违反性质的根节点；然而，当 $x$ 向下移动，在某个更深的节点遇到 $s  x \\leq m$ 的模式时，就会产生选项A和E中所记录的隐藏违规。",
            "answer": "$$\\boxed{AE}$$"
        }
    ]
}