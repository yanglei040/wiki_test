{
    "hands_on_practices": [
        {
            "introduction": "理论上的算法常常依赖于具备特定强大功能的数据结构。然而在实践中，标准库可能只提供功能较为基础的版本。本练习将探讨一种常见而巧妙的技术，即如何使用一个不支持 `decrease-key` 操作的基础优先队列来实现戴克斯特拉算法（Dijkstra's algorithm），展示如何有效地“惰性”处理“过时”数据。",
            "id": "3227995",
            "problem": "给定一个带非负边权的有向图。设图表示为 $G = (V, E)$，其权重函数为 $w : E \\to \\mathbb{R}_{\\ge 0}$。对于一个顶点 $s \\in V$，到顶点 $v \\in V$ 的单源最短路径距离定义为：从 $s$ 到 $v$ 的所有有向路径中，路径上边权重之和的最小值。如果从 $s$ 到 $v$ 不存在路径，则认为距离未定义。\n\n你的任务是编写一个完整的程序，该程序仅依赖于路径长度和权重非负性的核心定义，来计算从给定源点 $s$ 出发的单源最短路径距离。你的程序必须实现以下算法约束：使用一个允许重复条目且不提供或模拟 `decrease-key` 操作的最小优先队列（Priority Queue (PQ)）。也就是说，当发现到一个顶点的更短暂定距离时，不是修改现有的 PQ 条目，而是向 PQ 中推入一个新条目，并允许在过时条目被弹出时进行惰性移除。\n\n形式上，程序必须：\n- 接受一个由顶点数 $n$ 和一组有向边 $\\{(u, v, w)\\}$ 描述的图，其中 $u, v \\in \\{0, 1, \\dots, n-1\\}$ 且 $w \\in \\mathbb{Z}_{\\ge 0}$。\n- 仅使用 PQ 的 push 和 pop 操作，计算从源点 $s$ 到每个顶点 $v \\in \\{0, 1, \\dots, n-1\\}$ 的最短路径距离，允许重复键，且不进行任何在 PQ 内部减小键值的操作。\n- 对于每个测试用例，输出一个包含 $n$ 个整数的列表，其中第 $i$ 个条目是从 $s$ 到 $i$ 的最短路径距离，不可达顶点编码为 $-1$。\n\n你必须依赖的基础仅限于以下事实：\n- 从顶点 $x$ 到顶点 $y$ 的路径是在 $G$ 中有效连接的边的序列，路径的长度是其边权重之和。\n- 对于每一个 $e \\in E$，所有边权重满足 $w(e) \\ge 0$。\n- 对于任意顶点 $x, y, z \\in V$，如果从 $x$ 到 $y$ 的路径长度为 $\\ell(x, y)$，从 $y$ 到 $z$ 的路径长度为 $\\ell(y, z)$，那么连接而成的从 $x$ 到 $z$ 的路径长度为 $\\ell(x, y) + \\ell(y, z)$。\n- 如果从 PQ 中提取出的一个顶点的值严格大于其当前已知的最佳距离，那么该 PQ 条目必定是过时的，必须被忽略。\n\n测试套件。你的程序必须解决以下七个测试用例。对于每一个用例，图由一个整数 $n$、一个源点 $s$ 和一组表示为三元组 $(u, v, w)$ 的有向边指定：\n\n- 测试用例 1：$n = 5$, $s = 0$, 边 $\\{(0, 1, 2), (0, 2, 5), (1, 2, 1), (1, 3, 2), (2, 3, 1), (3, 4, 3)\\}$。\n- 测试用例 2：$n = 3$, $s = 0$, 边 $\\{(0, 1, 0), (1, 2, 0), (0, 2, 5)\\}$。\n- 测试用例 3：$n = 4$, $s = 0$, 边 $\\{(0, 1, 7)\\}$。\n- 测试用例 4：$n = 1$, $s = 0$, 边 $\\{\\}$。\n- 测试用例 5：$n = 3$, $s = 0$, 边 $\\{(0, 1, 10), (0, 1, 3), (1, 2, 4), (0, 2, 10)\\}$。\n- 测试用例 6：$n = 6$, $s = 0$, 边 $\\{(0, 1, 1), (0, 2, 5), (0, 3, 10), (1, 2, 2), (1, 3, 4), (2, 3, 1), (1, 4, 7), (3, 4, 1), (4, 5, 2), (2, 5, 10)\\}$。\n- 测试用例 7：$n = 4$, $s = 0$, 边 $\\{(0, 1, 1), (0, 2, 1), (1, 3, 1), (2, 3, 1)\\}$。\n\n测试套件中所有边权重均为整数且满足非负性。\n\n最终输出格式。你的程序应生成单行输出，其中包含所有结果聚合而成的单个列表，每个元素是对应一个测试用例的距离列表，顺序与上文列出的一致。聚合结果必须打印为单个由逗号分隔、无空格且用方括号括起来的列表。例如，如果有两个测试用例，其各自结果为 $[0, 1]$ 和 $[0, 2]$，则最终输出将是 $[[0,1],[0,2]]$。在你的程序的最终输出中，使用 $-1$ 表示不可达的顶点。此问题不涉及物理单位；所有量均为纯数字。",
            "solution": "用户提供了一个问题陈述，要求在带非负边权的有向图中计算单源最短路径。其核心约束是实现一个等价于 Dijkstra 算法的算法，但使用的最小优先队列不支持 `decrease-key` 操作，因此需要处理过时条目。\n\n### 步骤 1：提取已知信息\n\n-   **图**：一个有向图 $G = (V, E)$，其中 $V = \\{0, 1, \\dots, n-1\\}$。\n-   **边权重**：一个函数 $w : E \\to \\mathbb{R}_{\\ge 0}$，为每条边赋予一个非负权重。对于测试用例，$w(e) \\in \\mathbb{Z}_{\\ge 0}$。\n-   **源顶点**：一个指定的顶点 $s \\in V$。\n-   **最短路径距离**：从 $s$ 到任何顶点 $v \\in V$ 的所有有向路径中，权重总和的最小值。不可达顶点的距离未定义。\n-   **算法约束 1**：实现必须使用一个只支持 `push` 和 `pop` 操作的最小优先队列（PQ）。\n-   **算法约束 2**：禁止使用 `decrease-key` 操作。如果发现了到某个顶点的更短路径，必须将一个新的 `(距离, 顶点)` 条目推入 PQ，允许存在重复的顶点条目。\n-   **算法约束 3**：必须惰性处理过时条目。从 PQ 中弹出的条目 `(d, u)`，如果 $d$ 严格大于当前已知的到 $u$ 的最短距离，则该条目是过时的。必须忽略此类条目。\n-   **输出规范**：对于每个测试用例，输出必须是一个包含 $n$ 个整数的列表，表示从 $s$ 出发的最短距离。不可达顶点必须编码为 $-1$。最终输出是这些列表的聚合。\n-   **提供的基础事实**：\n    1.  路径及其长度（边权重之和）的定义。\n    2.  边权重的非负性：对于所有 $e \\in E$，$w(e) \\ge 0$。\n    3.  与路径拼接相关的最优子结构性质：拼接路径的长度是其子路径长度之和。\n    4.  识别和忽略 PQ 中过时条目的具体规则。\n-   **测试套件**：\n    -   测试用例 1：$n = 5$, $s = 0$, 边 $\\{(0, 1, 2), (0, 2, 5), (1, 2, 1), (1, 3, 2), (2, 3, 1), (3, 4, 3)\\}$。\n    -   测试用例 2：$n = 3$, $s = 0$, 边 $\\{(0, 1, 0), (1, 2, 0), (0, 2, 5)\\}$。\n    -   测试用例 3：$n = 4$, $s = 0$, 边 $\\{(0, 1, 7)\\}$。\n    -   测试用例 4：$n = 1$, $s = 0$, 边 $\\{\\}$。\n    -   测试用例 5：$n = 3$, $s = 0$, 边 $\\{(0, 1, 10), (0, 1, 3), (1, 2, 4), (0, 2, 10)\\}$。\n    -   测试用例 6：$n = 6$, $s = 0$, 边 $\\{(0, 1, 1), (0, 2, 5), (0, 3, 10), (1, 2, 2), (1, 3, 4), (2, 3, 1), (1, 4, 7), (3, 4, 1), (4, 5, 2), (2, 5, 10)\\}$。\n    -   测试用例 7：$n = 4$, $s = 0$, 边 $\\{(0, 1, 1), (0, 2, 1), (1, 3, 1), (2, 3, 1)\\}$。\n\n### 步骤 2：使用提取的已知信息进行验证\n\n对问题进行严格验证。\n\n-   **科学基础**：该问题描述了 Dijkstra 算法的一种标准变体。该算法在处理带非负边权的图时的正确性是图论和计算机科学的基石。所指定的实现细节——通过插入重复项并惰性丢弃过时条目来处理缺少 `decrease-key` 操作的情况——是一种广为人知且正确的技术。这在科学上和算法上都是合理的。\n-   **定义明确**：问题定义明确。对于给定的带非负权重的图和源顶点，单源最短路径距离集合是唯一确定的。对算法的约束是精确的，会导向一个确定的结果。\n-   **客观性**：问题使用形式化的数学符号和无歧义的术语进行陈述。它不含主观或基于观点的内容。\n-   **自洽且一致**：问题为每个测试用例提供了所有必要的数据（$n$、$s$ 和边集）。约束是明确的且不矛盾。提供的基础事实是正确的，并与该算法的基本原理一致。\n-   **可形式化且相关**：该问题直接是在指定主题内实现一个核心算法——Dijkstra 算法的任务。它非常适合形式化为程序。\n-   **完整且无歧义**：顶点和边的规范是完整的。输出格式有精确定义。诸如“最短路径距离”和“非负”等术语是标准的且无歧义。\n-   **非平凡性**：问题并非微不足道。它要求正确实现一个非平凡的算法，包括根据指定约束仔细管理优先队列的状态。\n\n### 步骤 3：结论与行动\n\n问题陈述是**有效的**。它是算法领域中一个定义良好、科学合理的问题。我现在将着手构建解决方案。\n\n需要实现的算法是 Dijkstra 算法的一个变体。设 $d[v]$ 为从源点 $s$ 到顶点 $v$ 的暂定最短距离。\n\n1.  **初始化**：初始化一个大小为 $n$ 的数组 $d$ 来存储最短路径估计值。我们设置 $d[s] = 0$，对于所有其他顶点 $v \\in V \\setminus \\{s\\}$，设置 $d[v] = \\infty$。值 $\\infty$ 表示尚未发现从 $s$ 到 $v$ 的路径。初始化一个最小优先队列 PQ。PQ 将存储形如 `(距离, 顶点)` 的元组。我们首先将源顶点插入 PQ：`PQ.push((0, s))`。\n\n2.  **迭代处理**：算法通过重复从 PQ 中提取具有最小距离的顶点来继续。只要 PQ 不为空，我们就执行以下步骤：\n    a. 从 PQ 中提取具有最小 $dist_u$ 的条目 $(dist_u, u)$。\n    b. **过时条目检查**：这是由问题约束决定的关键步骤。我们将提取的距离 $dist_u$ 与当前已知的到 $u$ 的最短距离 $d[u]$ 进行比较。如果 $dist_u > d[u]$，这意味着我们已经找到了到 $u$ 的更短路径并在之前的迭代中处理了它。因此，条目 $(dist_u, u)$ 是“过时的”，必须被丢弃。然后我们继续循环的下一次迭代。\n    c. **顶点最终化与松弛**：如果 $dist_u \\le d[u]$（由于算法的性质和过时检查，这必须是 $dist_u = d[u]$），这意味着我们已经找到了到 $u$ 的最短路径。边权的非负性确保任何尚未发现的到 $u$ 的其他路径都必须经过当前 PQ 中的某个其他顶点，而根据定义，该顶点的暂定距离大于或等于 $d[u]$。因此，不可能有更短的路径。然后我们“松弛”从 $u$ 出发的边。对于每个由权重为 $w(u, v)$ 的边 $(u, v)$ 连接的邻居 $v$，我们计算通过 $u$ 到达 $v$ 的一个新的潜在距离：$d[u] + w(u, v)$。\n    d. **路径改进**：如果这条新路径比当前已知的到 $v$ 的最短路径更短（即，如果 $d[u] + w(u, v)  d[v]$），我们就找到了一个改进。我们更新距离数组：$d[v] = d[u] + w(u, v)$。关键是，我们不执行对 PQ 中 $v$ 的 `decrease-key` 操作，而是简单地将新的、改进的条目 $(d[v], v)$ 插入 PQ。这就是重复条目的来源。\n\n3.  **终止**：当 PQ 变为空时，循环终止。此时，对于每个顶点 $v$，$d[v]$ 的值是从 $s$ 到 $v$ 的最短路径长度。如果 $d[v]$ 仍然是 $\\infty$，则表示 $v$ 从 $s$ 不可达。\n\n4.  **最终输出格式化**：处理最终的距离数组 $d$，将任何剩余的 $\\infty$ 值替换为 $-1$，以符合输出规范。然后将所有测试用例的结果聚合成所需的字符串格式。对于实现，Python 的 `heapq` 模块是理想的最小优先队列，因为它天然支持重复条目且没有 `decrease-key` 方法。\n\n此过程在指定的约束下正确计算单源最短路径，依赖于非负边权的基本性质和从优先队列中提取最小距离顶点的贪心选择。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport heapq\n\ndef solve():\n    \"\"\"\n    Solves the single-source shortest path problem for a series of test cases\n    using a Dijkstra-like algorithm with a priority queue that allows duplicates\n    and has no decrease-key operation.\n    \"\"\"\n    \n    test_cases = [\n        {'n': 5, 's': 0, 'edges': [(0, 1, 2), (0, 2, 5), (1, 2, 1), (1, 3, 2), (2, 3, 1), (3, 4, 3)]},\n        {'n': 3, 's': 0, 'edges': [(0, 1, 0), (1, 2, 0), (0, 2, 5)]},\n        {'n': 4, 's': 0, 'edges': [(0, 1, 7)]},\n        {'n': 1, 's': 0, 'edges': []},\n        {'n': 3, 's': 0, 'edges': [(0, 1, 10), (0, 1, 3), (1, 2, 4), (0, 2, 10)]},\n        {'n': 6, 's': 0, 'edges': [(0, 1, 1), (0, 2, 5), (0, 3, 10), (1, 2, 2), (1, 3, 4), (2, 3, 1), (1, 4, 7), (3, 4, 1), (4, 5, 2), (2, 5, 10)]},\n        {'n': 4, 's': 0, 'edges': [(0, 1, 1), (0, 2, 1), (1, 3, 1), (2, 3, 1)]}\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        n = case['n']\n        s = case['s']\n        edges = case['edges']\n        \n        # Adjacency list representation of the graph\n        adj = [[] for _ in range(n)]\n        for u, v, w in edges:\n            adj[u].append((v, w))\n            \n        # Initialize distances: 0 for the source, infinity for all others.\n        # np.inf is used to represent infinite distance.\n        distances = np.full(n, np.inf)\n        distances[s] = 0\n        \n        # Min-priority queue storing tuples of (distance, vertex).\n        # We start with the source vertex.\n        pq = [(0, s)]\n        \n        while pq:\n            # Pop the vertex with the smallest tentative distance\n            dist_u, u = heapq.heappop(pq)\n            \n            # If the popped distance is greater than the known shortest distance,\n            # this is a stale entry. We ignore it and proceed.\n            if dist_u > distances[u]:\n                continue\n            \n            # Relax edges for the current vertex u\n            for v, weight in adj[u]:\n                # If we found a shorter path to v through u\n                if distances[u] + weight  distances[v]:\n                    # Update the distance to v\n                    distances[v] = distances[u] + weight\n                    # Push the new, better path information to the priority queue.\n                    # This may create duplicate entries for vertex v, as required.\n                    heapq.heappush(pq, (distances[v], v))\n                    \n        # Prepare the final result list for this test case.\n        # Replace np.inf with -1 for unreachable vertices.\n        # Convert all distances to integers.\n        result = [int(d) if d != np.inf else -1 for d in distances]\n        all_results.append(result)\n\n    # Format the final output string as specified in the problem.\n    # e.g., [[0,1,2],[0,-1]]\n    str_results = []\n    for res in all_results:\n        str_results.append(f\"[{','.join(map(str, res))}]\")\n    \n    final_output_string = f\"[{','.join(str_results)}]\"\n    \n    print(final_output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "“惰性”方法虽然巧妙，但可能会让优先队列充满冗余的条目，影响性能。一个更高效的解决方案是构建一个能直接更新或删除元素的优先队列。本练习将挑战你设计并实现一个“索引优先队列”（Indexed Priority Queue），这是一种强大的数据结构，能高效地支持 `decrease-key` 和 `delete` 操作，是高性能图算法的关键。",
            "id": "3261051",
            "problem": "设计并实现一个支持句柄操作的索引优先队列 (Indexed Priority Queue, IPQ)，该队列基于二叉堆实现，支持通过句柄进行 $insert$、$decrease\\text{-}key$、$delete$ 以及 $extract\\text{-}min$ 操作。提出一个健壮的句柄方案，并严格证明所有操作的最坏情况时间复杂度均为 $O(\\log n)$，其中 $n$ 是 IPQ 中当前的元素数量。IPQ 必须在键上维持堆序不变性，并使用基于数组的完全二叉树表示来确保证形不变性。为确保在存在相等键值时行为的确定性，必须使用不可变的标识符来打破平局。\n\n推导和设计所使用的基本原理：\n- 二叉堆是一个在键上满足堆序属性的完全二叉树。\n- 一个大小为 $n$、由数组支持的完全二叉树的高度为 $h = \\lfloor \\log_2 n \\rfloor$，且从任一节点到根节点或叶节点的路径长度最多为 $h$。\n- 上浮（bubble-up，也称 sift-up）操作通过将节点与其父节点反复比较和交换，直到堆序属性不再被违反，从而向上调整节点；下沉（bubble-down，也称 sift-down）操作通过将节点与其最小子节点反复比较和交换，直到堆序属性不再被违反，从而向下调整节点。\n\n句柄方案要求：\n- $insert$ 返回的句柄必须是一个健壮的令牌，在该特定元素的生命周期内保持有效，并在该元素被 $delete$ 后立即失效。\n- 句柄必须能防止“ABA问题”，即一个过时的句柄可能会意外地引用到一个复用了内部标识符的新插入元素。\n- 任何使用过时或无效句柄的操作都必须被拒绝，且不得修改 IPQ。\n\n操作语义：\n- $insert(k)$：插入一个键 $k$，并为插入的元素返回一个句柄 $h$。\n- $decrease\\text{-}key(h, k')$：将与句柄 $h$ 关联的键减小为新键 $k'$，前提条件是 $k'  k$；如果句柄无效或前提条件不满足，则必须拒绝该操作。\n- $delete(h)$：删除与句柄 $h$ 关联的元素；如果句柄无效，则必须拒绝该操作。\n- $extract\\text{-}min()$：移除并返回 IPQ 中当前的最小键。\n\n验证与复杂度论证：\n- 您必须实现一个检测机制，记录每次操作中由上浮或下沉执行的堆索引移动次数。一次索引移动定义为将一个元素从堆数组中的索引 $i$ 重新定位到不同索引 $j$ 的任何交换操作。使用此检测机制报告下文指定的各测试用例的摘要值。此检测机制仅用于报告目的；它不能改变所实现操作的渐近复杂度。\n\n需实现的健壮句柄方案：\n- 每个元素都有一个在插入时分配的不可变标识符 $i \\in \\mathbb{N}$，且永不为其他元素复用。\n- 为每个标识符维护一个代计数器 $g_i \\in \\mathbb{N}$。元素的当前有效句柄是在插入时由对 $(i, g_i)$ 组成。当元素被删除时，将 $g_i$ 增加 1，这会使先前为该标识符发出的任何句柄失效。有效性检查必须确保，仅当 $g = g_i$ 且标识符 $i$ 当前存在于堆中（即有一个映射的位置）时，所提供的句柄 $(i, g)$ 才被接受。\n- 必须在 $decrease\\text{-}key$ 和 $delete$ 中使用此 $(i, g_i)$ 方案，以确保对过时句柄的健壮性。\n\n测试套件及所需输出：\n- 测试用例 $1$（一般情况）：按顺序插入键 $A_1 = [\\,7,\\,3,\\,5,\\,2,\\,9,\\,1,\\,4\\,]$，并按相同顺序收集返回的句柄。然后对第三次插入（原始键为 $5$）对应的句柄执行 $decrease\\text{-}key$ 操作，将键更新为 $0$。接着对第一次插入（原始键为 $7$）对应的句柄执行 $delete$ 操作。最后，重复调用 $extract\\text{-}min$ 直到 IPQ 为空，并记录提取出的键列表。此测试的预期输出是经过这些操作后，按升序排列的提取键的整数列表。\n- 测试用例 $2$（高度限制压力测试）：按顺序插入键 $A_2 = [\\,10,\\,8,\\,6,\\,4,\\,2\\,]$。对最后一次插入（原始键为 $2$）对应的句柄执行 $decrease\\text{-}key$ 操作，将键更新为 $-100$。接着对第二次插入（原始键为 $8$）对应的句柄执行 $delete$ 操作。在此测试期间，记录此测试用例中所有操作的任意单次上浮或下沉所造成的最大堆索引移动次数。此测试的预期输出是等于此最大值的单个整数。\n- 测试用例 $3$（过时句柄与重复减小键值）：插入单个键 $A_3 = [\\,50\\,]$ 并捕获句柄 $h_0$。执行 $decrease\\text{-}key(h_0, 20)$，然后是 $decrease\\text{-}key(h_0, 10)$，再然后是 $decrease\\text{-}key(h_0, 5)$。接着执行 $delete(h_0)$。最后，尝试执行 $decrease\\text{-}key(h_0, 1)$ 并记录该操作是否因句柄过时而被拒绝。此测试的预期输出是一个布尔值，指示过时的句柄是否被正确拒绝。\n\n最终输出格式：\n- 您的程序应产生单行输出，包含一个逗号分隔的列表，用方括号括起，具体格式为 $[R_1, R_2, R_3]$，其中 $R_1$ 是测试用例 1 的列表，$R_2$ 是测试用例 2 的整数，$R_3$ 是测试用例 3 的布尔值。\n- 程序必须是自包含的，不需要任何输入，并且仅使用 Python $3.12$ 版本、Python 标准库以及 Numerical Python (NumPy) $1.23.5$ 版本。\n\n科学真实性与约束：\n- 所有键都是整数，所有操作都必须遵守所述语义。\n- 复杂度声明必须从给定的基本原理出发，基于完全二叉树和堆序不变性的属性进行论证，不得依赖未经证实的捷径或外部引用。",
            "solution": "一个健壮的索引优先队列 (IPQ) 的设计和实现必须基于二叉堆的既定原则，并通过辅助数据结构来增强，以支持高效的索引操作。我们将通过结合一个二叉堆、用于位置跟踪的辅助映射以及用于健壮句柄管理的基于代的方案来构建 IPQ。\n\n### 数据结构\n\nIPQ 通过四个主要组件实现：\n\n$1$. **堆数组, $\\mathcal{H}$**：一个表示完全二叉树的动态数组。为了代数上的方便，我们使用从 $1$ 开始的索引，其中索引为 $j > 0$ 的元素的父节点位于索引 $\\lfloor j/2 \\rfloor$，其子节点位于索引 $2j$ 和 $2j+1$。$\\mathcal{H}$ 中的每个条目都是一个元组 $(k, i)$，其中 $k$ 是优先级键（一个整数），$i$ 是一个来自 $\\mathbb{N}$ 的唯一的、不可变的标识符。堆序属性维持在这些元组上，其中 $(k_1, i_1)  (k_2, i_2)$ 当且仅当 $k_1  k_2$，或者 $k_1 = k_2$ 且 $i_1  i_2$。这建立了一个确定性的全序关系。\n\n$2$. **位置映射, $\\mathcal{P}$**：一个哈希映射，提供元素标识符与其在堆中位置之间的双向链接。它将一个标识符 $i$ 映射到其在 $\\mathcal{H}$ 中的当前索引 $j$，即 $\\mathcal{P}[i] = j$。此结构对于在 $decrease\\text{-}key$ 和 $delete$ 操作中实现对元素的 $O(1)$ 时间访问至关重要。\n\n$3$. **代映射, $\\mathcal{G}$**：一个哈希映射，存储曾被插入到 IPQ 中的每个标识符的当前代计数器。它将一个标识符 $i$ 映射到其代 $g_i \\in \\mathbb{N}$，即 $\\mathcal{G}[i] = g_i$。\n\n$4$. **标识符计数器, $N_{id}$**：一个单调递增的整数计数器，用于为新元素分发全新的、唯一的标识符，确保没有标识符被重复使用。\n\n### 健壮的句柄方案\n\n句柄 $h$ 提供了对 IPQ 中元素的一个外部引用。为确保对过时句柄意外滥用（例如“ABA问题”）的健壮性，句柄被定义为一个对 $h = (i, g)$，其中 $i$ 是元素的唯一标识符，$g$ 是在句柄签发时刻（即插入时）该标识符的代计数。\n\n使用句柄 $h=(i, g)$ 调用的操作被认为是有效的，当且仅当同时满足两个条件：\n- 标识符 $i$ 存在于位置映射 $\\mathcal{P}$ 中，意味着该元素当前在堆中。\n- 句柄中提供的代 $g$ 与代映射 $\\mathcal{G}$ 中存储的当前代 $g_i$ 相匹配。\n\n当一个带有标识符 $i$ 的元素从堆中移除时（通过 $delete$ 或 $extract\\text{-}min$），它在 $\\mathcal{P}$ 中的条目被移除，并且其代计数器 $\\mathcal{G}[i]$ 会增加。这个双重操作会立即让所有先前为该元素签发的句柄失效，因为它们现在将无法满足一个或两个有效性条件。任何后续试图使用过时句柄 $(i, g)$ 的操作都将被拒绝。\n\n### 算法设计与复杂度分析\n\n所有操作都必须维持堆的不变性：形属性（堆是一个完全二叉树）和堆序属性。形属性通过仅在数组末尾添加/移除元素来维持。堆序属性通过两个基本过程，$bubble\\text{-}up$ 和 $bubble\\text{-}down$ 来恢复，每个过程都沿着堆中的一条路径操作。由于堆是一个大小为 $n$ 的完全二叉树，其高度为 $h_{heap} = \\lfloor \\log_2 n \\rfloor$。因此，这两个恢复过程的复杂度受限于树的高度，从而得到 $O(\\log n)$ 的性能。\n\n**$insert(k)$**\n$1$. 从 $N_{id}$ 获取一个新的唯一标识符 $i$，$N_{id}$ 随后递增。\n$2$. 记录元素的初始代：$\\mathcal{G}[i] \\leftarrow 0$。创建一个句柄 $h = (i, 0)$。\n$3$. 新元素 $(k, i)$ 被附加到堆数组 $\\mathcal{H}$ 的末尾，位于索引 $j=n+1$。\n$4$. 更新位置映射：$\\mathcal{P}[i] \\leftarrow j$。\n$5$. 调用 $bubble\\text{-}up(j)$ 过程将元素沿树向上移动，直到恢复堆序属性。这最多涉及 $\\lfloor \\log_2 n \\rfloor$ 次比较和交换。\n$6$. 返回句柄 $h$。\n**复杂度**：步骤 1-4 是 $O(1)$。步骤 5，$bubble\\text{-}up$，的最坏情况复杂度是 $O(\\log n)$。因此，$insert$ 是 $O(\\log n)$。\n\n**$extract\\text{-}min()$**\n$1$. 确定堆的根部，即 $\\mathcal{H}[1]$ 处的最小元素 $(k_{min}, i_{min})$。\n$2$. 将堆中最后一个元素，即索引 $n$ 处的 $(k_{last}, i_{last})$，移动到根部：$\\mathcal{H}[1] \\leftarrow (k_{last}, i_{last})$。\n$3$. 更新被移动元素的位置映射：$\\mathcal{P}[i_{last}] \\leftarrow 1$。\n$4$. 堆大小递减，实际上移除了旧的最后一个元素的位置。\n$5$. 从位置映射 $\\mathcal{P}$ 中移除被提取元素的标识符 $i_{min}$，并在 $\\mathcal{G}$ 中增加其代：$\\mathcal{G}[i_{min}] \\leftarrow \\mathcal{G}[i_{min}] + 1$。\n$6$. 调用 $bubble\\text{-}down(1)$ 过程将现在位于根部的元素沿树向下移动到其正确位置，以恢复堆序属性。这最多涉及 $O(\\log n)$ 次比较和交换。\n$7$. 返回键 $k_{min}$。\n**复杂度**：除了 $bubble\\text{-}down$ 是 $O(\\log n)$ 之外，所有步骤都是 $O(1)$。因此，$extract\\text{-}min$ 是 $O(\\log n)$。\n\n**$decrease\\text{-}key(h, k')$**\n$1$. 如前所述验证句柄 $h=(i, g)$。如果无效，则拒绝操作。\n$2$. 在 $O(1)$ 时间内从 $\\mathcal{P}[i]$ 检索元素的当前位置 $j$。\n$3$. 验证前提条件 $k'  \\mathcal{H}[j].key$。如果不满足，则拒绝操作。\n$4$. 将 $\\mathcal{H}[j]$ 处元素的键更新为 $k'$。\n$5$. 由于键已减小，堆序属性可能与其父节点之间被违反。调用 $bubble\\text{-}up(j)$ 过程来恢复不变性。\n**复杂度**：句柄验证、位置查找和键更新是 $O(1)$。主要成本是 $bubble\\text{-}up$，其复杂度为 $O(\\log n)$。\n\n**$delete(h)$**\n$1$. 验证句柄 $h=(i, g)$。如果无效，则拒绝操作。\n$2$. 在 $O(1)$ 时间内从 $\\mathcal{P}[i]$ 检索元素的当前位置 $j$。\n$3$. 将要删除的位于索引 $j$ 的元素与堆中最后一个位于索引 $n$ 的元素交换。为交换进来的元素更新位置映射 $\\mathcal{P}$。\n$4$. 堆大小递减。从 $\\mathcal{P}$ 中移除标识符 $i$ 的条目，并增加其代 $\\mathcal{G}[i]$。\n$5$. 从索引 $n$ 移动到索引 $j$ 的元素可能会违反堆序属性。我们将其与其父节点比较。如果它小于其父节点，则执行 $bubble\\text{-}up(j)$。否则，执行 $bubble\\text{-}down(j)$。这两个过程中只有一个会执行任何工作。\n**复杂度**：除了最后的堆恢复步骤外，所有步骤都是 $O(1)$。$bubble\\text{-}up$ 和 $bubble\\text{-}down$ 都是 $O(\\log n)$，因此 $delete$ 的复杂度是 $O(\\log n)$。\n\n**检测机制**\n为满足验证要求，为每个高层操作维护一个计数器。每当堆数组 $\\mathcal{H}$ 中两个元素发生一次交换时，此计数器加 1。记录在给定测试用例中所有操作中观察到的最大计数值。此检测机制为交换操作增加了常数开销，但不会改变渐近复杂度。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Indexed Priority Queue problem by implementing the required class\n    and running the specified test cases.\n    \"\"\"\n\n    class IndexedPriorityQueue:\n        \"\"\"\n        An Indexed Priority Queue (IPQ) implemented with a binary heap.\n\n        This IPQ supports insert, extract-min, decrease-key by handle, and\n        delete by handle, all in O(log n) time. It uses a robust handle\n        scheme based on unique identifiers and generation counters to prevent\n        issues with stale handles.\n\n        The heap is 1-indexed for simpler parent/child arithmetic.\n        - parent(i) = i // 2\n        - left_child(i) = 2 * i\n        - right_child(i) = 2 * i + 1\n        \"\"\"\n\n        def __init__(self):\n            # self.heap stores tuples of (key, identifier).\n            # Index 0 is a placeholder to enable 1-based indexing.\n            self.heap = [None]\n            # self.pos maps an identifier to its index in the heap array.\n            self.pos = {}\n            # self.gen maps an identifier to its generation counter.\n            self.gen = {}\n            # self.next_id is a counter for assigning new unique identifiers.\n            self.next_id = 0\n            # Instrumentation: tracks max movements for any single operation.\n            self.max_movements_per_op = 0\n            self._current_op_movements = 0\n\n        def is_empty(self):\n            return len(self.heap) == 1\n\n        def _swap(self, i, j):\n            \"\"\"Swaps elements at heap indices i and j, updating position map.\"\"\"\n            h = self.heap\n            p = self.pos\n            h[i], h[j] = h[j], h[i]\n            p[h[i][1]] = i\n            p[h[j][1]] = j\n            self._current_op_movements += 1\n\n        def _compare(self, i, j):\n            \"\"\"\n            Compares elements at heap indices i and j.\n            Uses (key, identifier) for deterministic tie-breaking.\n            Returns True if element at i is smaller than element at j.\n            \"\"\"\n            return self.heap[i]  self.heap[j]\n\n        def _bubble_up(self, i):\n            \"\"\"Restores heap property by moving element at index i up.\"\"\"\n            parent = i // 2\n            while i > 1 and self._compare(i, parent):\n                self._swap(i, parent)\n                i = parent\n                parent = i // 2\n\n        def _bubble_down(self, i):\n            \"\"\"Restores heap property by moving element at index i down.\"\"\"\n            size = len(self.heap)\n            while 2 * i  size:\n                left = 2 * i\n                right = 2 * i + 1\n                smallest = left\n                if right  size and self._compare(right, left):\n                    smallest = right\n                \n                if self._compare(smallest, i):\n                    self._swap(i, smallest)\n                    i = smallest\n                else:\n                    break\n\n        def _start_op(self):\n            \"\"\"Resets the movement counter for a new operation.\"\"\"\n            self._current_op_movements = 0\n\n        def _end_op(self):\n            \"\"\"Updates the max movement counter at the end of an operation.\"\"\"\n            self.max_movements_per_op = max(self.max_movements_per_op, self._current_op_movements)\n\n        def _validate_handle(self, handle):\n            \"\"\"Validates a handle (identifier, generation).\"\"\"\n            identifier, generation = handle\n            return identifier in self.pos and self.gen.get(identifier) == generation\n\n        def insert(self, key):\n            \"\"\"\n            Inserts a key, returns a robust handle. Complexity: O(log n).\n            \"\"\"\n            self._start_op()\n            identifier = self.next_id\n            self.next_id += 1\n            \n            # This is the first time we see this identifier\n            self.gen[identifier] = 0\n            handle = (identifier, self.gen[identifier])\n\n            self.heap.append((key, identifier))\n            new_pos = len(self.heap) - 1\n            self.pos[identifier] = new_pos\n            \n            self._bubble_up(new_pos)\n            self._end_op()\n            return handle\n\n        def extract_min(self):\n            \"\"\"\n            Removes and returns the minimum key. Complexity: O(log n).\n            \"\"\"\n            if self.is_empty():\n                raise IndexError(\"extract_min from an empty priority queue\")\n            \n            self._start_op()\n            min_key, min_id = self.heap[1]\n            last_item = self.heap.pop()\n            \n            if not self.is_empty():\n                self.heap[1] = last_item\n                self.pos[last_item[1]] = 1\n                self._bubble_down(1)\n            \n            del self.pos[min_id]\n            self.gen[min_id] += 1\n            \n            self._end_op()\n            return min_key\n\n        def decrease_key(self, handle, new_key):\n            \"\"\"\n            Decreases the key of an element specified by a handle.\n            Complexity: O(log n). Returns True on success, False on failure.\n            \"\"\"\n            if not self._validate_handle(handle):\n                return False\n\n            self._start_op()\n            identifier, _ = handle\n            current_pos = self.pos[identifier]\n            current_key, _ = self.heap[current_pos]\n\n            if new_key >= current_key:\n                # Precondition k'  k failed, do not count movements\n                self._current_op_movements = 0\n                self._end_op() \n                return False\n\n            self.heap[current_pos] = (new_key, identifier)\n            self._bubble_up(current_pos)\n            self._end_op()\n            return True\n\n        def delete(self, handle):\n            \"\"\"\n            Deletes an element specified by a handle. Complexity: O(log n).\n            Returns True on success, False on failure.\n            \"\"\"\n            if not self._validate_handle(handle):\n                return False\n\n            self._start_op()\n            identifier, _ = handle\n            pos_to_delete = self.pos[identifier]\n            \n            # Swap with the last element\n            last_pos = len(self.heap) - 1\n            self._swap(pos_to_delete, last_pos) # This counts as 1 movement\n            \n            # Pop the target element (which is now at the end)\n            deleted_key, deleted_id = self.heap.pop()\n            del self.pos[deleted_id]\n            self.gen[deleted_id] += 1\n\n            # If the heap is now empty or we deleted the last element, we are done.\n            if not self.is_empty() and pos_to_delete  len(self.heap):\n                # The swapped-in element might need to be moved up or down.\n                # A bubble_up will only occur if the element is smaller than its parent.\n                # Otherwise, a bubble_down might be needed.\n                item_key, _ = self.heap[pos_to_delete]\n                parent_pos = pos_to_delete // 2\n\n                # If it's not the root and smaller than its parent, bubble up.\n                if parent_pos > 0 and self._compare(pos_to_delete, parent_pos):\n                    self._bubble_up(pos_to_delete)\n                else: # Otherwise, it might need to bubble down.\n                    self._bubble_down(pos_to_delete)\n\n            self._end_op()\n            return True\n\n    results = []\n\n    # --- Test Case 1 ---\n    ipq1 = IndexedPriorityQueue()\n    handles1 = []\n    keys1 = [7, 3, 5, 2, 9, 1, 4]\n    for k in keys1:\n        handles1.append(ipq1.insert(k))\n\n    ipq1.decrease_key(handles1[2], 0)  # Decrease key of 5 to 0\n    ipq1.delete(handles1[0])          # Delete key 7\n    \n    extracted_keys = []\n    while not ipq1.is_empty():\n        extracted_keys.append(ipq1.extract_min())\n    results.append(extracted_keys)\n\n    # --- Test Case 2 ---\n    ipq2 = IndexedPriorityQueue()\n    handles2 = []\n    keys2 = [10, 8, 6, 4, 2]\n    for k in keys2:\n        handles2.append(ipq2.insert(k))\n    \n    ipq2.decrease_key(handles2[4], -100) # Decrease key of 2 to -100\n    ipq2.delete(handles2[1])           # Delete key 8\n\n    results.append(ipq2.max_movements_per_op)\n\n    # --- Test Case 3 ---\n    ipq3 = IndexedPriorityQueue()\n    h0 = ipq3.insert(50)\n    ipq3.decrease_key(h0, 20)\n    ipq3.decrease_key(h0, 10)\n    ipq3.decrease_key(h0, 5)\n    ipq3.delete(h0)\n    \n    # Attempt to use the stale handle, expecting rejection.\n    # decrease_key returns False on rejection.\n    is_rejected = not ipq3.decrease_key(h0, 1)\n    results.append(is_rejected)\n\n    # Final print statement in the exact required format.\n    # We need to manually format the list R1 to avoid spaces.\n    r1_str = f\"[{','.join(map(str, results[0]))}]\"\n    print(f\"[{r1_str},{results[1]},{str(results[2]).lower()}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "标准的优先队列被设计用来高效地访问一个极端——最小值或最大值。但如果一个应用需要同时快速访问这两个值呢？本练习要求你通过组合两个独立的堆，并使它们同步工作，来设计一个“双端优先队列”（Double-Ended Priority Queue）。这个实践展示了一种强大的设计模式：通过组合简单的数据结构来构建功能更复杂、用途更广泛的工具。",
            "id": "3261069",
            "problem": "您必须设计并实现一个双端优先队列（Abstract Data Type, ADT），该队列支持对最小和最大值的操作，且每次更新的运行时间为对数级。其基础是以下定义和经过充分检验的事实：优先队列支持插入和移除最高或最低优先级的元素；二叉堆是一个具有堆序不变性的完全二叉树；具有 $n$ 个节点的完全二叉树的高度为 $\\lfloor \\log_2 n \\rfloor$。您必须从这些基本原理中推导出一个数据结构及其算法，以便能够高效地提取最小元素和最大元素。\n\n要求：\n- 实现一个双端优先队列，支持对整数多重集的以下操作：\n  - $insert(x)$：插入整数 $x$。\n  - $extract\\text{-}min()$：移除并返回最小的元素。\n  - $extract\\text{-}max()$：移除并返回最大的元素。\n  - $peek\\text{-}min()$：返回最小的元素但不移除它。\n  - $peek\\text{-}max()$：返回最大的元素但不移除它。\n  - $size()$：返回当前元素的数量。\n  - $is\\_empty()$：返回一个布尔值，指示元素数量是否为零。\n- 所有更新操作 $insert$、$extract\\text{-}min$ 和 $extract\\text{-}max$ 的运行时间必须为 $O(\\log n)$，其中 $n$ 是当前存储的元素数量。查询操作 $peek\\text{-}min$、$peek\\text{-}max$、$size$ 和 $is\\_empty$ 的运行时间必须为 $O(1)$。\n- 底层结构和算法必须根据堆和完全二叉树的基本定义和性质进行论证。您不得假设或使用任何更高级别的快捷公式；需从第一性原理推导设计和复杂度。\n\n为进行测试，您的程序必须构建该数据结构并执行以下测试套件。每个测试用例都是一个有序的操作序列。对于每个返回值的操作，请按相同顺序将该值包含在测试用例的结果列表中。对于修改数据结构但不返回值的操作（如 $insert$），请不要在该操作的输出中包含任何内容。\n\n测试套件：\n- 测试用例 $1$（混合操作的通用情况）：\n  - 操作：$insert(5)$, $insert(3)$, $insert(8)$, $insert(1)$, $insert(7)$, $peek\\text{-}min()$, $peek\\text{-}max()$, $extract\\text{-}min()$, $extract\\text{-}max()$, $peek\\text{-}min()$, $peek\\text{-}max()$, $size()$, $is\\_empty()$。\n  - 预期结果类型：一个列表，按查询返回的顺序包含整数和布尔值。\n- 测试用例 $2$（重复值和负值）：\n  - 操作：$insert(-2)$, $insert(-2)$, $insert(0)$, $insert(5)$, $insert(5)$, $insert(-1)$, $extract\\text{-}max()$, $extract\\text{-}max()$, $extract\\text{-}min()$, $extract\\text{-}min()$, $peek\\text{-}min()$, $peek\\text{-}max()$, $size()$。\n  - 预期结果类型：一个包含整数的列表。\n- 测试用例 $3$（小规模的边界条件）：\n  - 操作：$insert(10)$, $peek\\text{-}max()$, $extract\\text{-}min()$, $is\\_empty()$, $insert(4)$, $insert(6)$, $extract\\text{-}max()$, $extract\\text{-}min()$, $is\\_empty()$。\n  - 预期结果类型：一个列表，包含整数和布尔值。\n- 测试用例 $4$（大量插入后交替提取的压力测试）：\n  - 操作：$insert(9)$, $insert(1)$, $insert(4)$, $insert(7)$, $insert(3)$, $insert(8)$, $insert(2)$, $insert(6)$, $insert(5)$, $extract\\text{-}max()$, $extract\\text{-}max()$, $extract\\text{-}max()$, $extract\\text{-}min()$, $extract\\text{-}min()$, $extract\\text{-}min()$, $peek\\text{-}min()$, $peek\\text{-}max()$, $size()$, $is\\_empty()$。\n  - 预期结果类型：一个列表，包含整数和布尔值。\n- 测试用例 $5$（所有元素相等及空值检查）：\n  - 操作：$is\\_empty()$, $insert(0)$, $insert(0)$, $insert(0)$, $peek\\text{-}min()$, $peek\\text{-}max()$, $extract\\text{-}min()$, $extract\\text{-}max()$, $extract\\text{-}max()$, $is\\_empty()$。\n  - 预期结果类型：一个列表，包含布尔值和整数。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个元素对应一个测试用例的结果列表。例如，您的程序应打印类似 $[[r\\_1],[r\\_2],[r\\_3],[r\\_4],[r\\_5]]$ 的内容，其中每个 $[r\\_i]$ 是测试用例 $i$ 中操作按顺序返回的值的列表。\n- 不涉及任何单位，所有返回值均为整数或布尔值。程序必须是自包含的，且不得读取任何输入。",
            "solution": "用户希望解决以下问题：\n您必须设计并实现一个双端优先队列（Abstract Data Type, ADT），该队列支持对最小和最大值的操作，且每次更新的运行时间为对数级。其基础是以下定义和经过充分检验的事实：优先队列支持插入和移除最高或最低优先级的元素；二叉堆是一个具有堆序不变性的完全二叉树；具有 $n$ 个节点的完全二叉树的高度为 $\\lfloor \\log_2 n \\rfloor$。您必须从这些基本原理中推导出一个数据结构及其算法，以便能够高效地提取最小元素和最大元素。\n\n要求：\n- 实现一个双端优先队列，支持对整数多重集的以下操作：\n  - $insert(x)$：插入整数 $x$。\n  - $extract\\text{-}min()$：移除并返回最小的元素。\n  - $extract\\text{-}max()$：移除并返回最大的元素。\n  - $peek\\text{-}min()$：返回最小的元素但不移除它。\n  - $peek\\text{-}max()$：返回最大的元素但不移除它。\n  - $size()$：返回当前元素的数量。\n  - $is\\_empty()$：返回一个布尔值，指示元素数量是否为零。\n- 所有更新操作 $insert$、$extract\\text{-}min$ 和 $extract\\text{-}max$ 的运行时间必须为 $O(\\log n)$，其中 $n$ 是当前存储的元素数量。查询操作 $peek\\text{-}min$、$peek\\text{-}max$、$size$ 和 $is\\_empty$ 的运行时间必须为 $O(1)$。\n- 底层结构和算法必须根据堆和完全二叉树的基本定义和性质进行论证。您不得假设或使用任何更高级别的快捷公式；需从第一性原理推导设计和复杂度。\n\n为进行测试，您的程序必须构建该数据结构并执行以下测试套件。每个测试用例都是一个有序的操作序列。对于每个返回值的操作，请按相同顺序将该值包含在测试用例的结果列表中。对于修改数据结构但不返回值的操作（如 $insert$），请不要在该操作的输出中包含任何内容。\n\n测试套件：\n- 测试用例 $1$（混合操作的通用情况）：\n  - 操作：$insert(5)$, $insert(3)$, $insert(8)$, $insert(1)$, $insert(7)$, $peek\\text{-}min()$, $peek\\text{-}max()$, $extract\\text{-}min()$, $extract\\text{-}max()$, $peek\\text{-}min()$, $peek\\text{-}max()$, $size()$, $is\\_empty()$。\n  - 预期结果类型：一个列表，按查询返回的顺序包含整数和布尔值。\n- 测试用例 $2$（重复值和负值）：\n  - 操作：$insert(-2)$, $insert(-2)$, $insert(0)$, $insert(5)$, $insert(5)$, $insert(-1)$, $extract\\text{-}max()$, $extract\\text{-}max()$, $extract\\text{-}min()$, $extract\\text{-}min()$, $peek\\text{-}min()$, $peek\\text{-}max()$, $size()$。\n  - 预期结果类型：一个包含整数的列表。\n- 测试用例 $3$（小规模的边界条件）：\n  - 操作：$insert(10)$, $peek\\text{-}max()$, $extract\\text{-}min()$, $is\\_empty()$, $insert(4)$, $insert(6)$, $extract\\text{-}max()$, $extract\\text{-}min()$, $is\\_empty()$。\n  - 预期结果类型：一个列表，包含整数和布尔值。\n- 测试用例 $4$（大量插入后交替提取的压力测试）：\n  - 操作：$insert(9)$, $insert(1)$, $insert(4)$, $insert(7)$, $insert(3)$, $insert(8)$, $insert(2)$, $insert(6)$, $insert(5)$, $extract\\text{-}max()$, $extract\\text{-}max()$, $extract\\text{-}max()$, $extract\\text{-}min()$, $extract\\text{-}min()$, $extract\\text{-}min()$, $peek\\text{-}min()$, $peek\\text{-}max()$, $size()$, $is\\_empty()$。\n  - 预期结果类型：一个列表，包含整数和布尔值。\n- 测试用例 $5$（所有元素相等及空值检查）：\n  - 操作：$is\\_empty()$, $insert(0)$, $insert(0)$, $insert(0)$, $peek\\text{-}min()$, $peek\\text{-}max()$, $extract\\text{-}min()$, $extract\\text{-}max()$, $extract\\text{-}max()$, $is\\_empty()$。\n  - 预期结果类型：一个列表，包含布尔值和整数。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个元素对应一个测试用例的结果列表。例如，您的程序应打印类似 $[[r\\_1],[r\\_2],[r\\_3],[r\\_4],[r\\_5]]$ 的内容，其中每个 $[r\\_i]$ 是测试用例 $i$ 中操作按顺序返回的值的列表。\n- 不涉及任何单位，所有返回值均为整数或布尔值。程序必须是自包含的，且不得读取任何输入。\n***\n### 步骤 1：提取已知信息\n- **ADT**：双端优先队列 (DE-PQ)。\n- **支持的操作**：`insert(x)`、`extract-min()`、`extract-max()`、`peek-min()`、`peek-max()`、`size()`、`is_empty()`。\n- **性能约束**：\n    - 更新操作（`insert`、`extract-min`、`extract-max`）：$O(\\log n)$ 时间复杂度。\n    - 查询操作（`peek-min`、`peek-max`、`size`、`is_empty`）：$O(1)$ 时间复杂度。\n- **基本原理**：设计必须从优先队列、二叉堆和完全二叉树的性质推导而来。二叉堆是一个具有堆序不变性的完全二叉树。具有 $n$ 个节点的完全二叉树的高度为 $\\lfloor \\log_2 n \\rfloor$。\n- **测试套件**：提供了五个特定的测试用例，包含操作序列用于验证。\n\n### 步骤 2：使用提取的已知信息进行验证\n问题在于设计一个特定的数据结构——双端优先队列，它具有严格的性能保证，并且需要从堆和二叉树的第一性原理推导出来。\n\n- **科学基础（关键）**：该问题植根于数据结构与算法这一成熟的领域，这是计算机科学的核心部分。优先队列、二叉堆和复杂度分析等概念都是形式化且数学上严谨的。根据此标准，该问题是有效的。\n- **定义明确**：该问题是定义明确的。它指定了所需的操作、其输入、输出及其时间复杂度。期望并可能得到一个以数据结构及其相关算法形式存在的独特且有意义的解决方案。\n- **客观性（关键）**：问题以精确、客观的语言陈述。要求是形式化的，没有歧义。\n- **完整性与一致性**：该问题是自包含的。它提供了所有必要的定义、约束和测试用例。没有矛盾之处。例如，要求从堆原理推导出解决方案，同时实现对数级更新和常数时间查看，这是一个标准但非平凡的设计挑战，已有已知的解决方案。\n- **其他缺陷**：该问题不是比喻性的、琐碎的或无法验证的。这是一个算法设计中的标准且具有挑战性的问题。\n\n### 步骤 3：结论与行动\n问题有效。我将继续设计并实现解决方案。\n\n### 基于原理的设计与推导\n\n目标是创建一个双端优先队列（DE-PQ），能高效地访问最小和最大元素。标准的二叉堆是优先队列的基础实现，但不足以完成此任务。最小堆能以 $O(1)$ 的时间复杂度访问最小元素，但需要 $O(n)$ 的扫描来找到最大元素。最大堆具有对称的特性。\n\n为了达到期望的复杂度，我们可以使用一个由两个协同工作的二叉堆组成的复合结构：一个最小堆，记为 $H_{min}$，和一个最大堆，$H_{max}$。每个插入到 DE-PQ 的元素都将存储在这两个堆中。这确保了最小元素始终位于 $H_{min}$ 的根部，最大元素始终位于 $H_{max}$ 的根部，从而允许 $O(1)$ 的 `peek-min` 和 `peek-max` 操作。\n\n核心挑战在于提取操作期间两个堆的同步。当一个元素从一个堆中提取出来时（例如，从 $H_{min}$ 中提取最小元素），其在另一个堆（$H_{max}$）中的对应条目也必须被移除，以保持一致性。标准堆不支持高效地移除任意元素；定位这样一个元素需要线性扫描，这是一个 $O(n)$ 的操作，违反了问题约束。\n\n为了克服这个问题，我们通过一种高效的交叉引用和任意移除机制来增强堆结构。这通过以下方式实现：\n1.  **唯一标识**：问题允许使用多重集，这意味着可以存在重复的值。为了唯一标识值的每个实例，我们将元素存储为元组 $(v, id)$，其中 $v$ 是整数值，$id$ 是插入时分配的唯一标识符（例如，一个单调递增的整数）。\n2.  **位置映射**：我们维护两个字典（哈希映射），$P_{min}$ 和 $P_{max}$，它们将每个唯一的 $id$ 分别映射到其在 $H_{min}$ 和 $H_{max}$ 数组表示中的当前索引。这允许以 $O(1)$ 的平均时间查找任一堆中任何元素的位置。\n\n有了这个增强结构，我们可以为堆定义一个 `remove_at_index(i)` 操作，其运行时间为 $O(\\log n)$。该操作的工作方式如下：\n- 要移除索引 $i$ 处的元素，将其与堆数组中的最后一个元素交换。\n- 数组长度减一（即弹出原来的最后一个元素）。\n- 为移动到索引 $i$ 的元素更新位置映射。\n- 此时，索引 $i$ 处的堆属性可能被破坏。索引 $i$ 处的元素需要向上或向下筛选以恢复不变量。由于筛选遍历的路径长度最多为树的高度，即 $O(\\log n)$，因此整个移除操作的时间复杂度为 $O(\\log n)$。在筛选过程中执行的所有交换也必须更新位置映射，每次交换是 $O(1)$ 操作。\n\n基于此设计，ADT 操作实现如下：\n- **`size()`**、**`is_empty()`**：这些操作返回当前元素的数量，例如 `len(H_min)`，时间复杂度为 $O(1)$。\n- **`peek-min()`**：返回 $H_{min}$ 根元素的值，该元素位于索引 0。这是一个 $O(1)$ 操作。\n- **`peek-max()`**：返回 $H_{max}$ 根元素的值，也是一个 $O(1)$ 操作。请注意，如果 $H_{max}$ 是通过存储负值的最小堆实现的，我们必须返回根部值的相反数。\n- **`insert(x)`**：\n    1. 生成一个新的唯一 $id$。\n    2. 将元组 $(x, id)$ 插入 $H_{min}$ 并向上筛选。这需要 $O(\\log n)$ 的时间。\n    3. 将元组 $(-x, id)$ 插入 $H_{max}$ 并向上筛选。这也需要 $O(\\log n)$ 的时间。\n    4. 相应地更新位置映射 $P_{min}$ 和 $P_{max}$。总复杂度为 $O(\\log n)$。\n- **`extract-min()`**：\n    1. 识别 $H_{min}$ 的根元素 $(v, id)$。这是最小的元素。\n    2. 使用 $id$ 通过位置映射 $P_{max}$ 在 $H_{max}$ 中查找此元素的索引。此查找为 $O(1)$。\n    3. 使用上述的 $O(\\log n)$ `remove_at_index` 过程从 $H_{max}$ 中移除该元素。\n    4. 从 $H_{min}$ 中移除根元素，这也是一个 $O(\\log n)$ 操作。\n    5. 返回值 $v$。总时间复杂度为 $O(\\log n) + O(\\log n) = O(\\log n)$。\n- **`extract-max()`**：此操作与 `extract-min()` 对称。它从 $H_{max}$ 提取根元素，使用其 $id$ 在 $H_{min}$ 中找到并移除相应元素，然后返回值。复杂度也为 $O(\\log n)$。\n\n此设计满足了问题的所有要求。它直接从二叉堆的原理推导而来，并通过标准的索引技术进行了增强，以满足指定的时间复杂度。每次更新操作都包含恒定数量的基本堆操作（筛选），每个操作的复杂度受限于树的高度，即 $O(\\log n)$。查询操作是简单的数组/属性查找，耗时 $O(1)$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass DoubleEndedPriorityQueue:\n    \"\"\"\n    A Double-Ended Priority Queue implemented using two binary heaps\n    and position maps for efficient synchronization.\n    - _min_heap: a min-heap storing tuples of (value, uid).\n    - _max_heap: a max-heap storing tuples of (-value, uid).\n    - _pos_min: a dictionary mapping uid - index in _min_heap.\n    - _pos_max: a dictionary mapping uid - index in _max_heap.\n    \"\"\"\n    def __init__(self):\n        self._min_heap = []\n        self._max_heap = []\n        self._pos_min = {}\n        self._pos_max = {}\n        self._uid_counter = 0\n\n    def is_empty(self) - bool:\n        return len(self._min_heap) == 0\n\n    def size(self) - int:\n        return len(self._min_heap)\n\n    def insert(self, x: int):\n        uid = self._uid_counter\n        self._uid_counter += 1\n\n        # Insert into min-heap\n        self._min_heap.append((x, uid))\n        self._pos_min[uid] = self.size() - 1\n        self._sift_up(self._min_heap, self._pos_min, self.size() - 1)\n\n        # Insert into max-heap (using negative values in a min-heap)\n        self._max_heap.append((-x, uid))\n        self._pos_max[uid] = self.size() - 1\n        self._sift_up(self._max_heap, self._pos_max, self.size() - 1)\n\n    def peek_min(self) - int:\n        if self.is_empty():\n            raise IndexError(\"peek_min from an empty queue\")\n        return self._min_heap[0][0]\n\n    def peek_max(self) - int:\n        if self.is_empty():\n            raise IndexError(\"peek_max from an empty queue\")\n        return -self._max_heap[0][0]\n\n    def extract_min(self) - int:\n        if self.is_empty():\n            raise IndexError(\"extract_min from an empty queue\")\n        \n        val, uid = self._min_heap[0]\n\n        # Remove corresponding element from max-heap\n        idx_in_max = self._pos_max[uid]\n        self._remove_at_index(self._max_heap, self._pos_max, idx_in_max)\n        \n        # Remove min element from min-heap\n        self._remove_at_index(self._min_heap, self._pos_min, 0)\n        \n        return val\n\n    def extract_max(self) - int:\n        if self.is_empty():\n            raise IndexError(\"extract_max from an empty queue\")\n            \n        neg_val, uid = self._max_heap[0]\n        val = -neg_val\n        \n        # Remove corresponding element from min-heap\n        idx_in_min = self._pos_min[uid]\n        self._remove_at_index(self._min_heap, self._pos_min, idx_in_min)\n\n        # Remove max element from max-heap\n        self._remove_at_index(self._max_heap, self._pos_max, 0)\n        \n        return val\n\n    # Helper methods for heap manipulation\n    def _swap(self, h, p, i, j):\n        uid_i = h[i][1]\n        uid_j = h[j][1]\n        h[i], h[j] = h[j], h[i]\n        p[uid_i] = j\n        p[uid_j] = i\n\n    def _sift_up(self, h, p, i):\n        parent_idx = (i - 1) // 2\n        while i > 0 and h[i][0]  h[parent_idx][0]:\n            self._swap(h, p, i, parent_idx)\n            i = parent_idx\n            parent_idx = (i - 1) // 2\n\n    def _sift_down(self, h, p, i):\n        max_index = len(h) - 1\n        while True:\n            left_child_idx = 2 * i + 1\n            right_child_idx = 2 * i + 2\n            smallest = i\n\n            if left_child_idx = max_index and h[left_child_idx][0]  h[smallest][0]:\n                smallest = left_child_idx\n            \n            if right_child_idx = max_index and h[right_child_idx][0]  h[smallest][0]:\n                smallest = right_child_idx\n            \n            if smallest != i:\n                self._swap(h, p, i, smallest)\n                i = smallest\n            else:\n                break\n\n    def _remove_at_index(self, h, p, i):\n        uid_to_remove = h[i][1]\n        last_idx = len(h) - 1\n        \n        if i == last_idx:\n            h.pop()\n        else:\n            self._swap(h, p, i, last_idx)\n            h.pop()\n            # After swap, element at i might need sifting.\n            # It came from the bottom, so it won't be smaller than its parent\n            # unless it's a very small value. Sifting up first is safer.\n            # Then sifting down. Only one will do work.\n            self._sift_up(h, p, i)\n            self._sift_down(h, p, i)\n\n        del p[uid_to_remove]\n\n\ndef solve():\n    test_cases_ops = [\n        # Test Case 1\n        [\"insert(5)\", \"insert(3)\", \"insert(8)\", \"insert(1)\", \"insert(7)\", \"peek-min()\", \"peek-max()\", \"extract-min()\", \"extract-max()\", \"peek-min()\", \"peek-max()\", \"size()\", \"is_empty()\"],\n        # Test Case 2\n        [\"insert(-2)\", \"insert(-2)\", \"insert(0)\", \"insert(5)\", \"insert(5)\", \"insert(-1)\", \"extract-max()\", \"extract-max()\", \"extract-min()\", \"extract-min()\", \"peek-min()\", \"peek-max()\", \"size()\"],\n        # Test Case 3\n        [\"insert(10)\", \"peek-max()\", \"extract-min()\", \"is_empty()\", \"insert(4)\", \"insert(6)\", \"extract-max()\", \"extract-min()\", \"is_empty()\"],\n        # Test Case 4\n        [\"insert(9)\", \"insert(1)\", \"insert(4)\", \"insert(7)\", \"insert(3)\", \"insert(8)\", \"insert(2)\", \"insert(6)\", \"insert(5)\", \"extract-max()\", \"extract-max()\", \"extract-max()\", \"extract-min()\", \"extract-min()\", \"extract-min()\", \"peek-min()\", \"peek-max()\", \"size()\", \"is_empty()\"],\n        # Test Case 5\n        [\"is_empty()\", \"insert(0)\", \"insert(0)\", \"insert(0)\", \"peek-min()\", \"peek-max()\", \"extract-min()\", \"extract-max()\", \"extract-max()\", \"is_empty()\"]\n    ]\n    \n    all_results = []\n\n    for ops in test_cases_ops:\n        depq = DoubleEndedPriorityQueue()\n        case_results = []\n        for op_str in ops:\n            op_name, op_args_str = op_str[:-1].split('(', 1)\n            \n            result = None\n            if op_name == 'insert':\n                arg = int(op_args_str)\n                depq.insert(arg)\n            elif op_name == 'extract-min':\n                result = depq.extract_min()\n            elif op_name == 'extract-max':\n                result = depq.extract_max()\n            elif op_name == 'peek-min':\n                result = depq.peek_min()\n            elif op_name == 'peek-max':\n                result = depq.peek_max()\n            elif op_name == 'size':\n                result = depq.size()\n            elif op_name == 'is_empty':\n                result = depq.is_empty()\n\n            if result is not None:\n                case_results.append(result)\n        all_results.append(case_results)\n\n    # Format the final output string exactly as required.\n    # e.g., [[1, 8, 1, 8, 3, 5, 3, False], [...]]\n    output_str = \"[\" + \",\".join([str(res).replace(\" \", \"\") for res in all_results]) + \"]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}