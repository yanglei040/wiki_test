{
    "hands_on_practices": [
        {
            "introduction": "This first exercise provides a practical foundation for building a high-performance Sudoku solver. You will implement the core backtracking algorithm, but with a crucial enhancement: using bitmasks to efficiently track available digits for each row, column, and box. This practice  demonstrates how a clever choice of data structure can elegantly represent constraints and accelerate the search process, forming the basis for a fast and effective solver.",
            "id": "3277909",
            "problem": "You are asked to design and implement a complete, runnable program that solves standard Sudoku instances using a principled, data-structure-driven approach. The puzzle is a square grid of size $9\\times 9$ populated with digits from the set $\\{1,2,3,4,5,6,7,8,9\\}$ and zeros for blanks. A valid Sudoku solution assigns a digit to every blank such that three constraints hold: (i) every row contains each digit from $\\{1,\\dots,9\\}$ exactly once, (ii) every column contains each digit from $\\{1,\\dots,9\\}$ exactly once, and (iii) each $3\\times 3$ subgrid (box) contains each digit from $\\{1,\\dots,9\\}$ exactly once.\n\nUse the following fundamental base and definitions as the foundation for your algorithmic derivation and implementation:\n- Sets and set intersection: availability of digits for a cell is the intersection of the sets of digits not yet used in its row, column, and box.\n- Bit-level representation of sets: represent a set of digits $\\{1,\\dots,9\\}$ by a $9$-bit mask where bit $k$ (zero-indexed) corresponds to digit $k+1$. A bit value of $1$ denotes availability, and $0$ denotes unavailability. Bitwise AND models set intersection, bit clearing models removing an element from the set, and bit testing enumerates candidates.\n- Backtracking search (Depth-First Search (DFS)): systematically try candidates for a variable, backtracking on contradiction.\n- Deterministic tie-breaking to ensure reproducible solutions: always select an unfilled cell with the Minimum Remaining Values (MRV), that is, with the fewest currently available candidates; on ties select the earliest cell in row-major order; within a cell, try candidate digits in ascending order.\n\nYour program must adhere to the following requirements:\n- Maintain three arrays of bitmasks for availability: one per row, one per column, and one per $3\\times 3$ box. Initialize each mask to all ones (digit availability $\\{1,\\dots,9\\}$) and, for each pre-filled digit $d$ in the input grid, clear the bit for $d$ in the corresponding row, column, and box. If any pre-filled digit contradicts a previously seen digit in its row, column, or box (i.e., the bit is already cleared), the instance is unsatisfiable.\n- At each search step, compute the candidate mask for a blank cell as the bitwise AND of the corresponding row, column, and box availability masks. If this mask is zero, a contradiction has been found.\n- Upon placing a digit $d$ in a cell, update the three availability masks by clearing the bit of $d$; upon backtracking, restore the masks.\n- If an instance is solvable, return any solution that obeys the MRV and ascending-candidate policy. If an instance is unsatisfiable, report it as such.\n\nTest suite and answer specification:\nFor each test instance, your program must compute a single integer result defined as follows:\n- If the instance is solvable, let the solution’s top row digits be $[r_1,r_2,\\dots,r_9]$. Output the integer obtained by concatenating these $9$ digits in order, that is, the base-$10$ integer $r_1\\cdot 10^{8} + r_2\\cdot 10^{7} + \\dots + r_9$.\n- If the instance is unsatisfiable, output the integer $-1$.\n\nUse the following four test cases. Each test case is a $9\\times 9$ matrix with zeros for blanks.\n\nTest case $1$ (a standard solvable instance):\n- Row $1$: $(5,3,0,0,7,0,0,0,0)$\n- Row $2$: $(6,0,0,1,9,5,0,0,0)$\n- Row $3$: $(1,9,8,0,0,2,0,6,7)$\n- Row $4$: $(8,0,0,0,6,0,0,0,3)$\n- Row $5$: $(4,0,0,8,0,3,0,0,1)$\n- Row $6$: $(7,0,0,0,2,0,0,0,6)$\n- Row $7$: $(0,6,0,0,0,0,2,8,0)$\n- Row $8$: $(0,0,0,4,1,9,0,0,5)$\n- Row $9$: $(0,0,0,0,8,0,0,7,9)$\n\nTest case $2$ (already solved valid grid):\n- Row $1$: $(5,3,4,6,7,8,9,1,2)$\n- Row $2$: $(6,7,2,1,9,5,3,4,8)$\n- Row $3$: $(1,9,8,3,4,2,5,6,7)$\n- Row $4$: $(8,5,9,7,6,1,4,2,3)$\n- Row $5$: $(4,2,6,8,5,3,7,9,1)$\n- Row $6$: $(7,1,3,9,2,4,8,5,6)$\n- Row $7$: $(9,6,1,5,3,7,2,8,4)$\n- Row $8$: $(2,8,7,4,1,9,6,3,5)$\n- Row $9$: $(3,4,5,2,8,6,1,7,9)$\n\nTest case $3$ (unsatisfiable due to a row conflict; note the duplicate digit in the first row):\n- Row $1$: $(6,3,4,6,7,8,9,1,2)$\n- Row $2$: $(6,7,2,1,9,5,3,4,8)$\n- Row $3$: $(1,9,8,3,4,2,5,6,7)$\n- Row $4$: $(8,5,9,7,6,1,4,2,3)$\n- Row $5$: $(4,2,6,8,5,3,7,9,1)$\n- Row $6$: $(7,1,3,9,2,4,8,5,6)$\n- Row $7$: $(9,6,1,5,3,7,2,8,4)$\n- Row $8$: $(2,8,7,4,1,9,6,3,5)$\n- Row $9$: $(3,4,5,2,8,6,1,7,9)$\n\nTest case $4$ (a different solved valid grid):\n- Row $1$: $(1,2,3,4,5,6,7,8,9)$\n- Row $2$: $(4,5,6,7,8,9,1,2,3)$\n- Row $3$: $(7,8,9,1,2,3,4,5,6)$\n- Row $4$: $(2,1,4,3,6,5,8,9,7)$\n- Row $5$: $(3,6,5,8,9,7,2,1,4)$\n- Row $6$: $(8,9,7,2,1,4,3,6,5)$\n- Row $7$: $(5,3,1,6,4,2,9,7,8)$\n- Row $8$: $(6,4,2,9,7,8,5,3,1)$\n- Row $9$: $(9,7,8,5,3,1,6,4,2)$\n\nFinal output format:\nYour program should produce a single line of output containing the results for test cases $1$ through $4$ in order, as a comma-separated list enclosed in square brackets. For example, the line should look like $[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4]$ with no spaces.\n\nNo input should be read from standard input. All data required for execution must be embedded directly in the program.",
            "solution": "The problem requires the design and implementation of a Sudoku solver based on a specified set of principles: backtracking search, bitmask representation for digit availability, and the Minimum Remaining Values (MRV) heuristic for variable ordering. The solution must be deterministic and handle both solvable and unsatisfiable puzzle instances.\n\nThe problem is rigorously defined and algorithmically self-contained. It is scientifically grounded in the established theory of Constraint Satisfaction Problems (CSPs), for which Sudoku is a canonical example. The requested methodology—a combination of depth-first search, bit-level data structures for efficiency, and heuristic-guided search—is a standard and effective approach. The problem is well-posed, providing deterministic tie-breaking rules that guarantee a unique algorithmic path and, consequently, a unique solution for any given valid input. All terms are formally defined, and the test cases and output format are specified precisely. Therefore, the problem is valid, and we may proceed with a reasoned solution.\n\nA $9 \\times 9$ Sudoku puzzle can be modeled as a CSP. The variables are the $81$ cells of the grid, which we can denote by their coordinates $(i, j)$ where $i, j \\in \\{0, 1, \\dots, 8\\}$. The domain for each cell is the set of allowed digits, $\\{1, 2, \\dots, 9\\}$. The constraints require that for each row, each column, and each of the nine $3 \\times 3$ boxes, all cells must contain distinct digits.\n\nThe core of the specified algorithm is the representation of the set of available digits for each row, column, and box using bitmasks. A $9$-bit integer can represent the set $D = \\{1, 2, \\dots, 9\\}$. We map digit $d$ to the $(d-1)$-th bit (zero-indexed). A bit value of $1$ signifies that the digit is available, while a $0$ signifies it is not. The bitmask for a digit $d$ is thus $1 \\ll (d-1)$. The initial state, where all digits are available, is represented by the mask with all $9$ bits set to $1$, which is $2^9 - 1 = 511$, or `0b111111111` in binary. Set intersection, crucial for determining a cell's available candidates, is efficiently computed using the bitwise `AND` operation.\n\nWe will maintain three arrays to track digit availability:\n- `rows[9]`: An array where `rows[i]` is the bitmask for available digits in row $i$.\n- `cols[9]`: An array where `cols[j]` is the bitmask for available digits in column $j$.\n- `boxes[9]`: An array where `boxes[k]` is the bitmask for available digits in box $k$. The box index $k$ for a cell $(i, j)$ is calculated as $k = (i \\,//\\, 3) \\cdot 3 + (j \\,//\\, 3)$.\n\nThe solution process consists of two main phases: initialization and recursive search.\n\n**1. Initialization Phase**\nThe solver is initialized with a given $9 \\times 9$ grid.\n- First, the `rows`, `cols`, and `boxes` mask arrays are initialized with the \"all available\" mask, $511$.\n- A list of all blank cells (those containing $0$) is created, preserving row-major order. This is essential for the tie-breaking rule.\n- The algorithm then iterates through the input grid. For each pre-filled cell at `grid[i][j]` with a non-zero digit $d$:\n    a. The bitmask for the digit $d$, `mask_d = 1 << (d-1)`, is computed.\n    b. A validity check is performed. The digit $d$ must be available in its row $i$, column $j$, and corresponding box $k$. This is true if and only if the bit for $d$ is set in `rows[i]`, `cols[j]`, and `boxes[k]`. If `(rows[i] & mask_d) == 0`, or the same check fails for the column or box mask, the puzzle has an initial contradiction and is unsatisfiable.\n    c. If the check passes, the digit $d$ is now considered used in that row, column, and box. The corresponding masks are updated by clearing the bit for $d$: `rows[i] &= ~mask_d`, `cols[j] &= ~mask_d`, and `boxes[k] &= ~mask_d`.\n\nIf this initialization process completes without finding any contradictions, the algorithm proceeds to the search phase. Otherwise, it terminates and reports the instance as unsatisfiable.\n\n**2. Recursive Backtracking Search**\nThe search for a solution is performed by a recursive function, implementing a depth-first search (DFS) on the space of possible digit assignments for the blank cells.\n\n- **Base Case:** The recursion terminates successfully when the list of blank cells is empty. This signifies that every cell has been assigned a valid digit, and a complete solution has been found. The function returns `True`.\n\n- **Recursive Step:**\n    a. **Variable Selection (MRV Heuristic):** The algorithm selects which blank cell to fill next. According to the MRV heuristic, we must choose the cell with the minimum number of available candidates. To do this, we iterate through the current list of blank cells. For each blank cell $(i, j)$:\n        i. The set of candidate digits is the intersection of available digits in its row, column, and box. This is computed as `candidates_mask = rows[i] & cols[j] & boxes[(i//3)*3 + (j//3)]`.\n        ii. The number of candidates is the number of set bits in `candidates_mask`, also known as the population count.\n        iii. As a form of forward checking, if `candidates_mask` is $0$ for any blank cell, it means there are no valid digits for that cell in the current state. This path leads to a contradiction, so the function must immediately backtrack by returning `False`.\n        iv. The algorithm tracks the cell with the minimum positive number of candidates. The problem specifies that ties are broken by selecting the cell that appears earliest in row-major order. Since our list of blanks is already in this order, we only need to update our choice when a cell with a strictly smaller number of candidates is found.\n\n    b. **Value Selection and Recursion:** Once the best cell $(i, j)$ is chosen, the algorithm tries to place a digit in it.\n        i. It iterates through the digits $d \\in \\{1, \\dots, 9\\}$ in ascending order, as per the problem's tie-breaking rule.\n        ii. For each digit $d$, it checks if it is a valid candidate by testing its corresponding bit in the `candidates_mask`.\n        iii. If $d$ is a valid candidate:\n            - **Place:** The digit $d$ is placed in `grid[i][j]`. The state is updated by clearing the bit for $d$ from `rows[i]`, `cols[j]`, and `boxes[k]`. A bitwise `XOR` operation (`^=`) is well-suited for this, as it both clears the bit (if currently set) and can be used again to restore it during backtracking.\n            - **Recurse:** The recursive function is called to solve for the remaining blank cells.\n            - **Propagate Success:** If the recursive call returns `True`, it means a solution has been found. This `True` value is propagated up the call stack, and the search terminates.\n\n    c. **Backtracking:** If the loop over all candidate digits for cell $(i, j)$ completes without the recursive call returning `True`, it means no solution can be reached from the current state. The algorithm must backtrack.\n        i. The assignment is undone: `grid[i][j]` is reset to $0$.\n        ii. The state masks are restored to their previous values by applying the same `XOR` operation with `mask_d`.\n        iii. The function returns `False`, signaling to the parent call that the chosen path failed.\n\nIf the initial call to the recursive function returns `False`, the puzzle is unsatisfiable.\n\n**3. Output Generation**\nOnce the solver finishes, a single integer result is generated for the instance.\n- If a solution is found, the digits in the top row of the completed grid, $[r_1, r_2, \\dots, r_9]$, are concatenated to form a base-$10$ integer.\n- If the puzzle is determined to be unsatisfiable (either during initialization or by the search), the result is $-1$.\nThe solver is run for all provided test cases, and the results are collected and formatted into the specified string format.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass SudokuSolver:\n    \"\"\"\n    Solves a 9x9 Sudoku puzzle using backtracking, bitmasking, and the\n    Minimum Remaining Values (MRV) heuristic.\n    \"\"\"\n\n    def __init__(self, grid):\n        \"\"\"\n        Initializes the solver, sets up data structures, and validates the\n        initial grid configuration.\n        \"\"\"\n        self.grid = np.array(grid, dtype=int)\n        self.initial_grid_is_valid = True\n\n        # Bitmasks for rows, cols, and boxes. 0b111111111 represents {1..9}.\n        self.all_digits_mask = (1 << 9) - 1\n        self.rows = [self.all_digits_mask] * 9\n        self.cols = [self.all_digits_mask] * 9\n        self.boxes = [self.all_digits_mask] * 9\n        self.blanks = []\n\n        self._initialize_masks()\n\n    def _initialize_masks(self):\n        \"\"\"\n        Populates masks based on pre-filled numbers and identifies blank cells.\n        Checks for initial contradictions in the grid.\n        \"\"\"\n        for r in range(9):\n            for c in range(9):\n                digit = self.grid[r, c]\n                if digit != 0:\n                    if not self._update_masks(r, c, digit, 'place'):\n                        self.initial_grid_is_valid = False\n                        return\n                else:\n                    self.blanks.append((r, c))\n\n    def _update_masks(self, r, c, d, action):\n        \"\"\"\n        Updates the availability masks for a given cell and digit.\n        If 'place', it validates and clears the bit.\n        If 'backtrack_xor', it restores the bit.\n        The XOR operation is used for its self-reverting property, but initial\n        placement requires a stricter check and clear.\n        \"\"\"\n        box_idx = (r // 3) * 3 + (c // 3)\n        mask_d = 1 << (d - 1)\n\n        if action == 'place':\n            # Check for contradiction before placing\n            if not (self.rows[r] & mask_d and self.cols[c] & mask_d and self.boxes[box_idx] & mask_d):\n                return False\n            # Place the digit by clearing its bit\n            self.rows[r] &= ~mask_d\n            self.cols[c] &= ~mask_d\n            self.boxes[box_idx] &= ~mask_d\n        elif action == 'backtrack_xor':\n            # Flip the bit back (0->1) using XOR\n            self.rows[r] ^= mask_d\n            self.cols[c] ^= mask_d\n            self.boxes[box_idx] ^= mask_d\n        \n        return True\n    \n    def solve_puzzle(self):\n        \"\"\"\n        Public method to start the solving process.\n        \"\"\"\n        if not self.initial_grid_is_valid:\n            return -1\n\n        if self._backtrack():\n            top_row = self.grid[0, :]\n            return int(\"\".join(map(str, top_row)))\n        else:\n            return -1\n\n    def _backtrack(self):\n        \"\"\"\n        Recursive backtracking algorithm (DFS).\n        \"\"\"\n        if not self.blanks:\n            return True  # Base case: All cells filled\n\n        # 1. Variable Selection: Find blank cell with MRV\n        min_candidates_count = 10\n        best_cell_info = None  # (index in blanks list, r, c, candidates_mask)\n\n        for i, (r, c) in enumerate(self.blanks):\n            box_idx = (r // 3) * 3 + (c // 3)\n            candidates_mask = self.rows[r] & self.cols[c] & self.boxes[box_idx]\n            count = bin(candidates_mask).count('1')\n\n            if count == 0:\n                return False  # Forward checking: contradiction detected\n\n            if count < min_candidates_count:\n                min_candidates_count = count\n                best_cell_info = (i, r, c, candidates_mask)\n\n        idx_in_blanks, r, c, candidates_mask = best_cell_info\n        \n        # Temporarily remove the chosen cell from the list\n        cell_to_fill = self.blanks.pop(idx_in_blanks)\n\n        # 2. Value Selection: Try candidates in ascending order\n        for d in range(1, 10):\n            mask_d = 1 << (d - 1)\n            if candidates_mask & mask_d:\n                # Place digit and update state\n                self.grid[r, c] = d\n                # Using XOR to flip the bit from 1 to 0\n                self._update_masks(r, c, d, 'backtrack_xor') \n\n                if self._backtrack():\n                    return True\n\n                # Backtrack: undo placement and restore state\n                self._update_masks(r, c, d, 'backtrack_xor')\n\n        # If no candidate leads to a solution, restore the chosen cell and backtrack fully\n        self.blanks.insert(idx_in_blanks, cell_to_fill)\n        self.grid[r,c] = 0 # Explicitly clear the cell on the grid\n\n        return False\n\ndef solve():\n    \"\"\"\n    Main function to run the Sudoku solver on the provided test cases.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        np.array([\n            [5, 3, 0, 0, 7, 0, 0, 0, 0],\n            [6, 0, 0, 1, 9, 5, 0, 0, 0],\n            [1, 9, 8, 0, 0, 2, 0, 6, 7],\n            [8, 0, 0, 0, 6, 0, 0, 0, 3],\n            [4, 0, 0, 8, 0, 3, 0, 0, 1],\n            [7, 0, 0, 0, 2, 0, 0, 0, 6],\n            [0, 6, 0, 0, 0, 0, 2, 8, 0],\n            [0, 0, 0, 4, 1, 9, 0, 0, 5],\n            [0, 0, 0, 0, 8, 0, 0, 7, 9]\n        ]),\n        # Test case 2\n        np.array([\n            [5, 3, 4, 6, 7, 8, 9, 1, 2],\n            [6, 7, 2, 1, 9, 5, 3, 4, 8],\n            [1, 9, 8, 3, 4, 2, 5, 6, 7],\n            [8, 5, 9, 7, 6, 1, 4, 2, 3],\n            [4, 2, 6, 8, 5, 3, 7, 9, 1],\n            [7, 1, 3, 9, 2, 4, 8, 5, 6],\n            [9, 6, 1, 5, 3, 7, 2, 8, 4],\n            [2, 8, 7, 4, 1, 9, 6, 3, 5],\n            [3, 4, 5, 2, 8, 6, 1, 7, 9]\n        ]),\n        # Test case 3\n        np.array([\n            [6, 3, 4, 6, 7, 8, 9, 1, 2], # Duplicate 6\n            [6, 7, 2, 1, 9, 5, 3, 4, 8],\n            [1, 9, 8, 3, 4, 2, 5, 6, 7],\n            [8, 5, 9, 7, 6, 1, 4, 2, 3],\n            [4, 2, 6, 8, 5, 3, 7, 9, 1],\n            [7, 1, 3, 9, 2, 4, 8, 5, 6],\n            [9, 6, 1, 5, 3, 7, 2, 8, 4],\n            [2, 8, 7, 4, 1, 9, 6, 3, 5],\n            [3, 4, 5, 2, 8, 6, 1, 7, 9]\n        ]),\n        # Test case 4\n        np.array([\n            [1, 2, 3, 4, 5, 6, 7, 8, 9],\n            [4, 5, 6, 7, 8, 9, 1, 2, 3],\n            [7, 8, 9, 1, 2, 3, 4, 5, 6],\n            [2, 1, 4, 3, 6, 5, 8, 9, 7],\n            [3, 6, 5, 8, 9, 7, 2, 1, 4],\n            [8, 9, 7, 2, 1, 4, 3, 6, 5],\n            [5, 3, 1, 6, 4, 2, 9, 7, 8],\n            [6, 4, 2, 9, 7, 8, 5, 3, 1],\n            [9, 7, 8, 5, 3, 1, 6, 4, 2]\n        ])\n    ]\n\n    results = []\n    for grid in test_cases:\n        solver = SudokuSolver(grid)\n        result = solver.solve_puzzle()\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Building on the backtracking framework, this practice focuses on the intelligent heuristics that guide the search process in Constraint Satisfaction Problems (CSPs). You will implement two of the most powerful heuristics: the Most Constrained Variable (MCV) to decide which cell to fill next, and the Least Constraining Value (LCV) to decide which digit to try first. This exercise  offers deep insight into how strategic decision-making at each step of the search can drastically prune the search tree and lead to a solution more quickly.",
            "id": "3205403",
            "problem": "You must write a complete, runnable program that implements a backtracking solver for Sudoku as a Constraint Satisfaction Problem (CSP) using two specific heuristics: Most Constrained Variable (MCV) and Least Constraining Value (LCV). The problem must be solved in a purely algorithmic and mathematical way, starting from core definitions from constraint satisfaction and search, and using no domain-specific shortcuts beyond those definitions.\n\nA Sudoku instance consists of a square grid of size $9 \\times 9$, with variables $X_{r,c}$ for row $r \\in \\{1,\\ldots,9\\}$ and column $c \\in \\{1,\\ldots,9\\}$. Each variable $X_{r,c}$ has a domain $D_{r,c} \\subseteq \\{1,2,\\ldots,9\\}$. The constraints are that for each row $r$, all variables $X_{r,1},\\ldots,X_{r,9}$ must take pairwise distinct values; for each column $c$, all variables $X_{1,c},\\ldots,X_{9,c}$ must take pairwise distinct values; and for each $3 \\times 3$ subgrid indexed by $(R,C)$ where $R \\in \\{0,1,2\\}$ and $C \\in \\{0,1,2\\}$, all variables in rows $3R+1,\\ldots,3R+3$ and columns $3C+1,\\ldots,3C+3$ must take pairwise distinct values. The initial puzzle fixes some variables to specific values in $\\{1,2,\\ldots,9\\}$, and the remaining variables have domain $\\{1,2,\\ldots,9\\}$.\n\nYou must:\n- Model Sudoku as a CSP with variables $X_{r,c}$, domains $D_{r,c}$, and all-different constraints for rows, columns, and subgrids.\n- Implement backtracking search that at each step selects the next unassigned variable by the Most Constrained Variable (MCV) heuristic, i.e., choose a variable with the smallest current domain size $|D_{r,c}|$ among those with $|D_{r,c}| > 1$.\n- Order candidate values for a chosen variable by the Least Constraining Value (LCV) heuristic, i.e., for each candidate value $v \\in D_{r,c}$, prioritize those that eliminate the fewest options from the domains of neighboring variables (neighbors share a row, column, or subgrid).\n- Enforce forward checking with constraint propagation after each assignment: whenever a variable is assigned a value, remove that value from the domains of all its neighbors; if any neighbor’s domain becomes a singleton, propagate this effect. If any domain becomes empty, backtrack.\n- Detect inconsistency in the initial assignment (e.g., duplicate fixed values in a row, column, or subgrid) and declare the instance unsolvable.\n\nFoundational base you may assume:\n- The definition of a Constraint Satisfaction Problem (CSP) with variables, domains, and constraints.\n- The principle of depth-first backtracking search.\n- The definitions and effects of variable-ordering and value-ordering heuristics in search (e.g., MCV reduces expected branching factor; LCV reduces immediate constraint on future choices).\n- Basic set operations and graph adjacency notions.\n\nForbidden shortcuts:\n- You may not use precomputed Sudoku-specific patterns beyond the CSP definitions above.\n- You may not hard-code solutions or use non-explanatory rules beyond forward checking and the stated heuristics.\n\nTest suite:\nYour program must solve the following four Sudoku instances. Each instance is given as an $81$-character string in row-major order over the alphabet $\\{0,1,2,\\ldots,9\\}$, where character $0$ denotes an empty cell and characters $1$ through $9$ denote fixed values.\n\n- Test case $1$ (general solvable):\n  \"530070000600195000098000060800060003400803001700020006060000280000419005000080079\"\n\n- Test case $2$ (already solved; boundary condition):\n  \"534678912672195348198342567859761423426853791713924856961537284287419635345286179\"\n\n- Test case $3$ (unsolvable due to initial conflict; edge case):\n  \"550000000000000000000000000000000000000000000000000000000000000000000000000000000\"\n\n- Test case $4$ (nearly complete; single missing cell; boundary condition):\n  \"534678912672195348198342567859761423426853791713924856961537284287419635345286170\"\n\nRequired output for each test case:\n- If the puzzle is solvable, output a flattened list of $81$ integers in row-major order representing the completed grid, with each entry in $\\{1,2,\\ldots,9\\}$.\n- If the puzzle is unsolvable, output the integer $-1$.\n\nFinal output format:\nYour program should produce a single line of output containing the results for the four test cases as a comma-separated list enclosed in square brackets; each solvable instance contributes a bracketed list of $81$ integers, and the unsolvable instance contributes the integer $-1$. For example, a syntactically correct output shape is \"[[a_1,\\ldots,a_{81}],-1,[b_1,\\ldots,b_{81}],[c_1,\\ldots,c_{81}]]\". No additional text should be printed.",
            "solution": "The problem statement is a valid exercise in algorithm design, specifically for solving Constraint Satisfaction Problems (CSPs). It is scientifically grounded in established principles of artificial intelligence and discrete mathematics, is well-posed with a clear objective, and is free of ambiguity or contradiction. We shall proceed with a formal solution.\n\nThe problem requires the implementation of a backtracking search algorithm for Sudoku, augmented with the Most Constrained Variable (MCV) and Least Constraining Value (LCV) heuristics, along with forward checking for constraint propagation.\n\n**1. Formalization of Sudoku as a Constraint Satisfaction Problem (CSP)**\n\nA CSP is defined by a set of variables, a domain of possible values for each variable, and a set of constraints on the values of these variables. For the Sudoku problem on a $9 \\times 9$ grid, we define these components as follows:\n\n- **Variables:** The variables are the cells of the Sudoku grid. We denote the variable for the cell in row $r$ and column $c$ as $X_{r,c}$, where $r, c \\in \\{0, 1, \\ldots, 8\\}$. There are $9 \\times 9 = 81$ such variables.\n\n- **Domains:** Each variable $X_{r,c}$ has a domain, $D_{r,c}$, which is the set of values it is allowed to take. For a standard Sudoku puzzle, the values are the integers from $1$ to $9$. An initial puzzle configuration specifies some values.\n  - If a cell $(r, c)$ is empty (given as '$0$' in the input), its initial domain is the full set of possibilities: $D_{r,c} = \\{1, 2, 3, 4, 5, 6, 7, 8, 9\\}$.\n  - If a cell $(r, c)$ is pre-filled with a value $v \\in \\{1, \\ldots, 9\\}$, its domain is a singleton set: $D_{r,c} = \\{v\\}$.\n\n- **Constraints:** The rules of Sudoku impose `all-different` constraints on three types of variable groups:\n  1.  **Row Constraint:** For each row $r \\in \\{0, \\ldots, 8\\}$, the values assigned to the variables $\\{X_{r,0}, X_{r,1}, \\ldots, X_{r,8}\\}$ must all be distinct.\n  2.  **Column Constraint:** For each column $c \\in \\{0, \\ldots, 8\\}$, the values assigned to the variables $\\{X_{0,c}, X_{1,c}, \\ldots, X_{8,c}\\}$ must all be distinct.\n  3.  **Subgrid Constraint:** For each of the nine $3 \\times 3$ subgrids, the values assigned to the variables within that subgrid must all be distinct.\n\nTo manage these constraints efficiently, we define the concept of \"neighbors.\" Two variables $X_{r,c}$ and $X_{r',c'}$ are neighbors if they are in the same row ($r=r'$), the same column ($c=c'$), or the same $3 \\times 3$ subgrid. The constraint can then be stated more simply: for any variable $X_{r,c}$, its value must be different from the values of all its neighbors. For each of the $81$ variables, we can pre-compute a set of its $20$ unique neighbors.\n\n**2. The Backtracking Algorithm with Heuristics and Inference**\n\nWe implement a recursive, depth-first backtracking algorithm to search for a valid assignment. The efficiency of this search is critically enhanced by the specified heuristics and inference mechanism.\n\nThe state of our search is represented by the collection of domains $\\{D_{r,c}\\}$ for all $81$ variables. A solution is found when every domain is a singleton, i.e., $|D_{r,c}|=1$ for all $r, c$.\n\nThe recursive function `backtrack(domains)` operates as follows:\n\n- **Base Case:** If all variables are assigned (i.e., there are no variables $X_{r,c}$ with $|D_{r,c}| > 1$), a complete and consistent assignment has been found. The current state represents a solution, which is then returned.\n\n- **Variable Selection (Most Constrained Variable - MCV):** The algorithm must select an unassigned variable to assign next. The MCV heuristic dictates choosing a variable with the minimum remaining domain size. That is, we select an $X_{r,c}$ such that $|D_{r,c}|$ is minimized over all variables with $|D_{r,c}| > 1$. This strategy, also known as \"fail-first,\" aims to identify inevitable failures early in the search tree, leading to faster pruning of impossible branches.\n\n- **Value Ordering (Least Constraining Value - LCV):** Once a variable $X_{r,c}$ is selected, the algorithm must decide the order in which to try the values in its domain $D_{r,c}$. The LCV heuristic prioritizes values that are \"least constraining\" on the remaining variables. For each candidate value $v \\in D_{r,c}$, we compute a score based on how many choices it would eliminate from the domains of its neighbors. The score for a value $v$ is calculated as:\n$$ \\text{score}(v) = \\sum_{(r', c') \\in \\text{neighbors}(r,c)} \\mathbb{I}(v \\in D_{r',c'}) $$\nwhere $\\mathbb{I}(\\cdot)$ is the indicator function, which is $1$ if its argument is true and $0$ otherwise. The algorithm then iterates through the values in $D_{r,c}$ in increasing order of this score. This heuristic attempts to leave maximal flexibility for subsequent assignments, increasing the probability of finding a solution without backtracking.\n\n- **Recursive Step and Inference (Forward Checking with Propagation):** For each value $v$ in the LCV-ordered list for the chosen variable $X_{r,c}$:\n  1.  A tentative assignment is made by setting the domain of $X_{r,c}$ to $\\{v\\}$. This is done on a *copy* of the current state to allow for backtracking.\n  2.  This assignment triggers **constraint propagation**. The value $v$ is removed from the domain of every neighbor of $X_{r,c}$.\n  3.  If this removal causes any neighbor's domain to become empty, the assignment $X_{r,c} \\leftarrow v$ is invalid, and the algorithm immediately discards this path.\n  4.  If the removal causes a neighbor's domain to shrink to a singleton set, e.g., $D_{r',c'} = \\{v'\\}$, this constitutes a new assignment. This new assignment is recursively propagated: $v'$ is removed from the domains of all neighbors of $X_{r',c'}$. This propagation continues until no more domains can be reduced or a contradiction (an empty domain) is found.\n  5.  If propagation completes successfully without any domain becoming empty, the algorithm makes a recursive call: `backtrack(new_domains)`.\n  6.  If the recursive call returns a valid solution, that solution is propagated up the call stack and returned.\n  7.  If the recursive call returns a failure, it means the tentative assignment $X_{r,c} \\leftarrow v$ led to a dead end. The algorithm backtracks by undoing the assignment (which is implicit, as we operate on a copy) and tries the next value for $X_{r,c}$.\n\nIf all values for $X_{r,c}$ have been tried and none lead to a solution, the function returns a failure signal, indicating that the branch of the search tree leading to the current state is unsolvable.\n\n**3. Implementation Structure and Initial State Handling**\n\nThe overall process is initiated by a main solver function that prepares the initial state and invokes the backtracking search.\n\n- **Initialization:** The input string is parsed into a $9 \\times 9$ grid. The initial set of domains $\\{D_{r,c}\\}$ is constructed. For each pre-filled cell $(r, c)$ with value $v$, we perform an initial constraint propagation. This is identical to the propagation step within the backtracking search: we treat the pre-filled cells as a sequence of assignments and propagate their constraints.\n- **Inconsistency Detection:** If at any point during this initial propagation a domain becomes empty, it implies the initial puzzle is contradictory (e.g., two identical numbers in the same row). In this case, the puzzle is declared unsolvable without entering the main backtracking search. This correctly handles Test Case $3$.\n- **Final Output:** If the initial `backtrack` call returns a solution, the final $81$-element list is constructed from the solved domains. If it returns a failure signal, the puzzle is unsolvable, and the output is $-1$.\n\nThis structured approach correctly implements the specified CSP solution method, adhering to the principles of backtracking search, variable/value ordering heuristics, and constraint propagation.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef _get_neighbors():\n    \"\"\"Pre-computes and returns the neighbors for each cell in a 9x9 grid.\"\"\"\n    neighbors = {}\n    for r in range(9):\n        for c in range(9):\n            neighbor_set = set()\n            # Row neighbors\n            for i in range(9):\n                if i != c:\n                    neighbor_set.add((r, i))\n            # Column neighbors\n            for i in range(9):\n                if i != r:\n                    neighbor_set.add((i, c))\n            # Box neighbors\n            start_row, start_col = 3 * (r // 3), 3 * (c // 3)\n            for i in range(start_row, start_row + 3):\n                for j in range(start_col, start_col + 3):\n                    if (i, j) != (r, c):\n                        neighbor_set.add((i, j))\n            neighbors[(r, c)] = list(neighbor_set)\n    return neighbors\n\nNEIGHBORS = _get_neighbors()\n\ndef _propagate(domains, r, c):\n    \"\"\"\n    Propagates constraints after assigning a value to (r, c).\n    A cell's domain must be a singleton.\n    Modifies domains in place. Returns False if a contradiction is found.\n    \"\"\"\n    val = next(iter(domains[r][c]))\n    q = [(r, c)]\n    visited = set(q)\n\n    while q:\n        curr_r, curr_c = q.pop(0)\n        curr_val = next(iter(domains[curr_r][curr_c]))\n\n        for nr, nc in NEIGHBORS[(curr_r, curr_c)]:\n            if curr_val in domains[nr][nc]:\n                domains[nr][nc].remove(curr_val)\n                if not domains[nr][nc]:\n                    return False  # Contradiction\n                if len(domains[nr][nc]) == 1 and (nr, nc) not in visited:\n                    q.append((nr, nc))\n                    visited.add((nr, nc))\n    return True\n\ndef _backtrack(domains):\n    \"\"\"\n    Recursive backtracking solver.\n    \"\"\"\n    # Find Most Constrained Variable (MCV)\n    mcv_cell = None\n    min_domain_size = 10\n    unassigned_found = False\n    \n    for r in range(9):\n        for c in range(9):\n            if len(domains[r][c]) > 1:\n                unassigned_found = True\n                if len(domains[r][c]) < min_domain_size:\n                    min_domain_size = len(domains[r][c])\n                    mcv_cell = (r, c)\n    \n    # Base case: if no unassigned cells, solution is found\n    if not unassigned_found:\n        return domains\n    \n    r, c = mcv_cell\n    \n    # Order values by Least Constraining Value (LCV)\n    lcv_scores = []\n    for val in domains[r][c]:\n        score = 0\n        for nr, nc in NEIGHBORS[(r, c)]:\n            if val in domains[nr][nc]:\n                score += 1\n        lcv_scores.append((score, val))\n    \n    lcv_scores.sort()\n    \n    # Recursive step\n    for _, val in lcv_scores:\n        # Create a deep copy of domains for this branch\n        new_domains = [[cell_domain.copy() for cell_domain in row] for row in domains]\n        new_domains[r][c] = {val}\n        \n        # Propagate constraints\n        if _propagate(new_domains, r, c):\n            result = _backtrack(new_domains)\n            if result:\n                return result\n                \n    return None # Backtrack\n\ndef solve_sudoku(puzzle_str):\n    \"\"\"\n    Solves a Sudoku puzzle string using backtracking with MCV, LCV, and propagation.\n    \"\"\"\n    # 1. Initialize domains\n    domains = [[set(range(1, 10)) for _ in range(9)] for _ in range(9)]\n    grid = np.array([int(c) for c in puzzle_str]).reshape((9, 9))\n    \n    # 2. Initial assignments and propagation\n    for r in range(9):\n        for c in range(9):\n            if grid[r][c] != 0:\n                val = grid[r][c]\n                if val not in domains[r][c]:\n                    return -1 # Initial conflict\n                domains[r][c] = {val}\n                if not _propagate(domains, r, c):\n                    return -1 # Unsolvable from start\n    \n    # 3. Call backtracking search\n    solution = _backtrack(domains)\n    \n    # 4. Format output\n    if solution:\n        flat_solution = []\n        for r in range(9):\n            for c in range(9):\n                flat_solution.append(list(solution[r][c])[0])\n        return flat_solution\n    else:\n        return -1\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        \"530070000600195000098000060800060003400803001700020006060000280000419005000080079\",\n        \"534678912672195348198342567859761423426853791713924856961537284287419635345286179\",\n        \"550000000000000000000000000000000000000000000000000000000000000000000000000000000\",\n        \"534678912672195348198342567859761423426853791713924856961537284287419635345286170\",\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_sudoku(case)\n        results.append(str(result))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "This final practice challenges you to step outside the standard backtracking approach and solve Sudoku using a completely different and powerful paradigm. You will learn to reframe the puzzle as an Exact Cover problem, a classic combinatorial challenge. To solve it, you will implement Donald Knuth's Algorithm X with its famously elegant and efficient implementation, Dancing Links (DLX), a masterclass in algorithm design and data structure manipulation .",
            "id": "3277848",
            "problem": "Implement a complete, runnable program that solves standard Sudoku instances by reducing them to an exact cover problem and applying Donald Knuth’s Algorithm X with Dancing Links (DLX). The task is to design and implement the data structures and search algorithm from first principles using the following foundational base.\n\nFundamental base:\n- Definition of exact cover: Given a finite universe set $\\mathcal{U}$ and a family $\\mathcal{S}$ of subsets of $\\mathcal{U}$, an exact cover is a subcollection $\\mathcal{C} \\subseteq \\mathcal{S}$ such that every element of $\\mathcal{U}$ is contained in exactly one member of $\\mathcal{C}$.\n- Sudoku constraints: A standard Sudoku consists of a $9 \\times 9$ grid. Valid solutions satisfy these invariants:\n  1. Each cell contains a digit in $\\{1,2,\\dots,9\\}$.\n  2. Each row contains each digit in $\\{1,2,\\dots,9\\}$ exactly once.\n  3. Each column contains each digit in $\\{1,2,\\dots,9\\}$ exactly once.\n  4. Each $3 \\times 3$ box contains each digit in $\\{1,2,\\dots,9\\}$ exactly once.\n\nYour program must:\n- Formulate Sudoku as an exact cover instance where each candidate assignment “row” corresponds to placing digit $d \\in \\{1,\\dots,9\\}$ in cell $(r,c)$ with $r \\in \\{0,\\dots,8\\}$ and $c \\in \\{0,\\dots,8\\}$, and where the universe encodes four families of constraints: cell occupancy, row–digit, column–digit, and box–digit. This yields $729$ candidate rows and $324$ constraint columns in the unconstrained case.\n- Implement Dancing Links (DLX), which is a linked-structure implementation of Algorithm X, to efficiently perform cover and uncover operations on the sparse exact cover matrix during backtracking search.\n- Respect givens by restricting candidates to those consistent with the provided nonzero digits. Use $0$ to indicate an empty cell.\n\nTest suite:\nProvide solutions for the following three test cases. Each test case is a $9 \\times 9$ grid given as nine rows of nine integers. The integer $0$ denotes an empty cell.\n- Test case A (general solvable instance with a unique solution):\n  - Row $1$: $(5,\\,3,\\,0,\\,0,\\,7,\\,0,\\,0,\\,0,\\,0)$\n  - Row $2$: $(6,\\,0,\\,0,\\,1,\\,9,\\,5,\\,0,\\,0,\\,0)$\n  - Row $3$: $(0,\\,9,\\,8,\\,0,\\,0,\\,0,\\,0,\\,6,\\,0)$\n  - Row $4$: $(8,\\,0,\\,0,\\,0,\\,6,\\,0,\\,0,\\,0,\\,3)$\n  - Row $5$: $(4,\\,0,\\,0,\\,8,\\,0,\\,3,\\,0,\\,0,\\,1)$\n  - Row $6$: $(7,\\,0,\\,0,\\,0,\\,2,\\,0,\\,0,\\,0,\\,6)$\n  - Row $7$: $(0,\\,6,\\,0,\\,0,\\,0,\\,0,\\,2,\\,8,\\,0)$\n  - Row $8$: $(0,\\,0,\\,0,\\,4,\\,1,\\,9,\\,0,\\,0,\\,5)$\n  - Row $9$: $(0,\\,0,\\,0,\\,0,\\,8,\\,0,\\,0,\\,7,\\,9)$\n- Test case B (nearly complete, one hole):\n  - Row $1$: $(0,\\,3,\\,4,\\,6,\\,7,\\,8,\\,9,\\,1,\\,2)$\n  - Row $2$: $(6,\\,7,\\,2,\\,1,\\,9,\\,5,\\,3,\\,4,\\,8)$\n  - Row $3$: $(1,\\,9,\\,8,\\,3,\\,4,\\,2,\\,5,\\,6,\\,7)$\n  - Row $4$: $(8,\\,5,\\,9,\\,7,\\,6,\\,1,\\,4,\\,2,\\,3)$\n  - Row $5$: $(4,\\,2,\\,6,\\,8,\\,5,\\,3,\\,7,\\,9,\\,1)$\n  - Row $6$: $(7,\\,1,\\,3,\\,9,\\,2,\\,4,\\,8,\\,5,\\,6)$\n  - Row $7$: $(9,\\,6,\\,1,\\,5,\\,3,\\,7,\\,2,\\,8,\\,4)$\n  - Row $8$: $(2,\\,8,\\,7,\\,4,\\,1,\\,9,\\,6,\\,3,\\,5)$\n  - Row $9$: $(3,\\,4,\\,5,\\,2,\\,8,\\,6,\\,1,\\,7,\\,9)$\n- Test case C (unsolvable due to contradictory givens):\n  - Row $1$: $(5,\\,5,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0)$\n  - Row $2$: $(0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0)$\n  - Row $3$: $(0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0)$\n  - Row $4$: $(0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0)$\n  - Row $5$: $(0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0)$\n  - Row $6$: $(0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0)$\n  - Row $7$: $(0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0)$\n  - Row $8$: $(0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0)$\n  - Row $9$: $(0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0)$\n\nAnswer specification and output format:\n- For each test case, your program must compute one of the following:\n  - If a solution exists, output the solved grid as a flat list of $81$ integers in row-major order, each in $\\{1,\\dots,9\\}$.\n  - If no solution exists, output an empty list.\n- Your program should produce a single line of output containing the results for all three test cases as a comma-separated list enclosed in square brackets. For example: “$[[\\dots],[\\dots],[]]$”. No additional whitespace or text should be printed.\n\nConstraints and notes:\n- You must implement Donald Knuth’s Algorithm X with Dancing Links (DLX). Straightforward constraint propagation or naive backtracking without DLX is not acceptable.\n- Treat the given grids as immutable givens; interpret $0$ as an empty cell.\n- There are no physical units, angle units, or percentages involved in this problem. All outputs are unitless integers as specified.",
            "solution": "The user wants to solve Sudoku puzzles by reducing them to an exact cover problem and applying Donald Knuth's Algorithm X, implemented with the Dancing Links (DLX) technique.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n\n- **Problem:** Solve Sudoku using Algorithm X with Dancing Links (DLX).\n- **Core Concept (Exact Cover):** Given a universe $\\mathcal{U}$ and a family of subsets $\\mathcal{S}$, find a subcollection $\\mathcal{C} \\subseteq \\mathcal{S}$ where each element of $\\mathcal{U}$ appears in exactly one member of $\\mathcal{C}$.\n- **Sudoku Constraints:** For a $9 \\times 9$ grid:\n    1. Each cell has one digit from $\\{1, ..., 9\\}$.\n    2. Each row has each digit from $\\{1, ..., 9\\}$ exactly once.\n    3. Each column has each digit from $\\{1, ..., 9\\}$ exactly once.\n    4. Each $3 \\times 3$ box has each digit from $\\{1, ..., 9\\}$ exactly once.\n- **Implementation Requirements:**\n    1.  Formulate Sudoku as an exact cover problem with $729$ rows (choices) and $324$ columns (constraints).\n    2.  Implement DLX from first principles.\n    3.  Handle initial non-zero digits (givens) by restricting candidate choices.\n- **Test Cases:**\n    - Test Case A: A standard solvable puzzle.\n    - Test Case B: A nearly complete puzzle.\n    - Test Case C: An unsolvable puzzle with a contradiction.\n- **Output Format:**\n    - For solvable cases, a flat list of $81$ integers representing the solved grid in row-major order.\n    - For unsolvable cases, an empty list.\n    - A single line of output, e.g., `[[...],[...],[]]`, containing all results.\n\n**Step 2: Validate Using Extracted Givens**\n\n- **Scientifically Grounded:** The problem is firmly rooted in computer science, specifically in the domain of combinatorial search algorithms. The reduction of Sudoku to an exact cover problem is a classic, mathematically sound technique. Algorithm X and its DLX implementation are canonical methods for solving such problems. The problem adheres to established principles of algorithmics and discrete mathematics.\n- **Well-Posed:** The problem is clearly defined. The input is a set of $9 \\times 9$ grids. The task is to find a valid Sudoku solution for each. The conditions for a valid solution are explicitly stated. The output format for both solvable and unsolvable cases is precisely specified. A unique, meaningful answer exists for each test case (either a solution grid or a confirmation of unsolvability).\n- **Objective:** The problem statement is written in precise, unambiguous language. All constraints, data, and requirements are formal and objective. There are no subjective elements.\n\n**Step 3: Verdict and Action**\n\nThe problem is **valid**. It is a well-defined algorithmic task based on established computer science principles. The following solution provides a principled implementation of the required algorithm.\n\n### Solution Design\n\nThe solution is architected around the reduction of Sudoku to an exact cover problem, which is then solved using a custom implementation of Algorithm X with Dancing Links (DLX).\n\n**1. Sudoku as an Exact Cover Problem**\n\nThe core idea is to represent the Sudoku constraints as the universe $\\mathcal{U}$ of an exact cover problem, and the possible moves (placing a digit in a cell) as the family of subsets $\\mathcal{S}$.\n\n-   **Universe of Constraints ($\\mathcal{U}$):** The $324$ game rules are the elements of our universe, which become the columns of a matrix.\n    1.  **Cell Occupancy:** For each of the $81$ cells $(r, c)$, the constraint is that it must contain exactly one digit. This gives $9 \\times 9 = 81$ columns. Column index: $c_{1} = 9r + c$.\n    2.  **Row-Digit:** For each of the $9$ rows and $9$ digits, the constraint is that digit $d$ must appear exactly once in row $r$. This gives $9 \\times 9 = 81$ columns. Column index: $c_{2} = 81 + 9r + (d-1)$.\n    3.  **Column-Digit:** For each of the $9$ columns and $9$ digits, the constraint is that digit $d$ must appear exactly once in column $c$. This gives $9 \\times 9 = 81$ columns. Column index: $c_{3} = 162 + 9c + (d-1)$.\n    4.  **Box-Digit:** For each of the $9$ boxes and $9$ digits, the constraint is that digit $d$ must appear exactly once in box $b$. This gives $9 \\times 9 = 81$ columns. Column index: $c_{4} = 243 + 9b + (d-1)$, where the box index $b$ is calculated as $b = 3(r // 3) + (c // 3)$.\n\n-   **Family of Subsets ($\\mathcal{S}$):** The candidate moves are the rows of the matrix. A single \"choice\" is to place a digit $d \\in \\{1,...,9\\}$ in a cell $(r, c)$. There are $9 \\times 9 \\times 9 = 729$ such possible choices.\n    -   Each choice, such as placing digit $d$ in cell $(r,c)$, satisfies exactly four constraints: one cell constraint, one row-digit constraint, one column-digit constraint, and one box-digit constraint.\n    -   Therefore, each row in our $729 \\times 324$ matrix representation of the problem contains exactly four $1$s.\n\nFinding a Sudoku solution is equivalent to finding a subcollection of $81$ of these choices (rows) such that every one of the $324$ constraints (columns) is satisfied by exactly one chosen row. This is the definition of an exact cover.\n\n**2. Algorithm X and Dancing Links (DLX)**\n\nAlgorithm X is a recursive, backtracking algorithm for finding exact covers. Dancing Links (DLX) is an efficient implementation technique proposed by Donald Knuth that uses a specific data structure to represent the sparse matrix.\n\n-   **Data Structure:** The sparse $729 \\times 324$ matrix is represented using a toroidal doubly-linked list.\n    -   Each $1$ in the matrix becomes a `Node` object. Each node has four pointers: `L` (left), `R` (right), `U` (up), `D` (down).\n    -   Nodes in the same matrix row are linked horizontally into a circular list.\n    -   Nodes in the same matrix column are linked vertically into a circular list.\n    -   Each column has a special `Column` header node. These headers are themselves linked horizontally into a circular list, which also includes a master `root` node. This list keeps track of the currently active constraints.\n    -   Each `Column` header stores the `size` (number of $1$s) in its column, crucial for the search heuristic.\n\n-   **Search Algorithm (`search`):**\n    1.  **Base Case:** If the `root` node is its own right neighbor (i.e., `root.R == root`), all columns have been covered, and a solution has been found.\n    2.  **Column Selection:** Choose a column `c` to cover. The S-heuristic (shortest column) is used: select the column with the minimum `size`. This prunes the search tree effectively.\n    3.  **Cover Operation (`cover(c)`):** This is the core of DLX's efficiency. To cover column `c`:\n        -   It is unlinked from the horizontal list of column headers.\n        -   For each row `i` that has a node in column `c`, that entire row is \"removed\" from consideration by unlinking its *other* nodes from their respective columns. This is done by modifying the `U` and `D` pointers of their vertical neighbors.\n    4.  **Recursion & Backtracking:**\n        -   Iterate through each row `r` that was just \"removed\" by `cover(c)`.\n        -   For each `r`, tentatively add it to the solution.\n        -   For each node `j` in row `r` (other than the one in `c`), cover its column `j.col`.\n        -   Recursively call `search`. If it returns `True`, a solution is found; propagate `True` up the call stack.\n        -   If the recursive call fails, backtrack. Un-select row `r` and restore the matrix to its previous state by performing the `uncover` operations in the reverse order of the `cover` operations.\n    5.  **Uncover Operation (`uncover(c)`):** This operation perfectly reverses `cover(c)` by relinking all nodes and headers, restoring the matrix structure.\n\n**3. Handling Givens and Contradictions**\n\nThe initial puzzle state (the \"givens\") is handled by pre-processing the DLX structure.\n\n-   For each given digit $d$ at cell $(r, c)$, we are forced to make that choice.\n-   The matrix row corresponding to the choice $(r,c,d)$ is identified. This row is effectively \"selected\" as part of the solution from the start.\n-   Selecting this row means all constraints it satisfies must be fulfilled. This is achieved by iterating through the nodes of this row and calling the `cover` operation on each of their respective columns.\n-   If the givens are contradictory (e.g., two $5$s in the same row, as in Test Case C), this process will fail. For example, processing the first `5` will cover the `row-digit` constraint for \"5 in row 1\". When processing the second `5`, its corresponding row in the matrix will have already been eliminated by the previous `cover` operation. The program detects this impossibility and flags the puzzle as unsolvable without initiating the search.\n\nThis principled design translates the abstract Sudoku puzzle into a concrete mathematical structure and solves it using a highly efficient, specialized algorithm.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass SudokuDLXSolver:\n    \"\"\"\n    Solves a Sudoku puzzle by reducing it to an exact cover problem\n    and applying Donald Knuth's Algorithm X with Dancing Links (DLX).\n    \"\"\"\n\n    class Node:\n        \"\"\"A node in the DLX matrix, representing a '1'.\"\"\"\n        def __init__(self, col_header=None, row_idx=-1):\n            self.L = self.R = self.U = self.D = self\n            self.col = col_header\n            self.row_idx = row_idx\n\n    class Column(Node):\n        \"\"\"A column header in the DLX matrix, representing a constraint.\"\"\"\n        def __init__(self, name=\"\"):\n            super().__init__(self)\n            self.size = 0\n            self.name = name\n\n    def __init__(self, grid):\n        \"\"\"Initializes the solver and builds the DLX structure for the given grid.\"\"\"\n        self.grid = grid\n        self.N = 9\n        self.N2 = self.N * self.N\n        self.num_cols = 4 * self.N2  # 324 constraints\n        \n        self.solution_indices = []\n        self.solution_grid = None\n        self._build_dlx_structure()\n        self.is_solvable = self._handle_givens()\n\n    def _get_row_data_from_idx(self, row_idx):\n        \"\"\"Converts a matrix row index back to (row, col, digit) of the Sudoku.\"\"\"\n        val = row_idx\n        digit = (val % self.N) + 1\n        val //= self.N\n        col = val % self.N\n        val //= self.N\n        row = val\n        return row, col, digit\n\n    def _build_dlx_structure(self):\n        \"\"\"Constructs the toroidal doubly-linked list for the Sudoku exact cover matrix.\"\"\"\n        self.root = self.Column(\"root\")\n        self.columns = [self.Column(str(i)) for i in range(self.num_cols)]\n\n        self.root.R = self.columns[0]\n        self.columns[0].L = self.root\n        self.columns[-1].R = self.root\n        self.root.L = self.columns[-1]\n\n        for i in range(self.num_cols - 1):\n            self.columns[i].R = self.columns[i+1]\n            self.columns[i+1].L = self.columns[i]\n\n        for r in range(self.N):\n            for c in range(self.N):\n                for d_idx, d in enumerate(range(1, self.N + 1)):\n                    row_idx = r * self.N2 + c * self.N + d_idx\n                    box = (r // 3) * 3 + (c // 3)\n                    \n                    cols_to_cover = [\n                        r * self.N + c,                      # Cell (r,c) constraint\n                        self.N2 + r * self.N + d_idx,        # Row-Digit (r,d) constraint\n                        2 * self.N2 + c * self.N + d_idx,    # Col-Digit (c,d) constraint\n                        3 * self.N2 + box * self.N + d_idx,  # Box-Digit (b,d) constraint\n                    ]\n                    \n                    first_node = None\n                    prev_node = None\n                    for col_idx in cols_to_cover:\n                        col_header = self.columns[col_idx]\n                        new_node = self.Node(col_header, row_idx)\n\n                        new_node.U = col_header.U\n                        new_node.D = col_header\n                        col_header.U.D = new_node\n                        col_header.U = new_node\n                        col_header.size += 1\n\n                        if first_node is None:\n                            first_node = new_node\n                        if prev_node is not None:\n                            new_node.L = prev_node\n                            prev_node.R = new_node\n                        prev_node = new_node\n                    \n                    first_node.L = prev_node\n                    prev_node.R = first_node\n\n    def _handle_givens(self):\n        \"\"\"\n        Pre-processes the matrix by selecting rows corresponding to the givens.\n        Returns False if a contradiction is found in the givens.\n        \"\"\"\n        for r_idx in range(self.N):\n            for c_idx in range(self.N):\n                digit = self.grid[r_idx, c_idx]\n                if digit != 0:\n                    d_idx = digit - 1\n                    row_idx = r_idx * self.N2 + c_idx * self.N + d_idx\n                    \n                    found_row_node = None\n                    # Search for any node in the required row. We start from the cell constraint column.\n                    cell_col_idx = r_idx * self.N + c_idx\n                    p = self.columns[cell_col_idx].D\n                    while p != self.columns[cell_col_idx]:\n                        if p.row_idx == row_idx:\n                            found_row_node = p\n                            break\n                        p = p.D\n                    \n                    if found_row_node is None:\n                        return False # Contradiction in givens\n\n                    # Select this row: cover all columns it belongs to\n                    self.solution_indices.append(found_row_node.row_idx)\n                    self.cover(found_row_node.col)\n                    q = found_row_node.R\n                    while q != found_row_node:\n                        self.cover(q.col)\n                        q = q.R\n        return True\n\n    def cover(self, c):\n        \"\"\"Covers a column and all intersecting rows.\"\"\"\n        c.R.L = c.L\n        c.L.R = c.R\n        i = c.D\n        while i != c:\n            j = i.R\n            while j != i:\n                j.D.U = j.U\n                j.U.D = j.D\n                j.col.size -= 1\n                j = j.R\n            i = i.D\n\n    def uncover(self, c):\n        \"\"\"Uncovers a column, reversing a cover operation.\"\"\"\n        i = c.U\n        while i != c:\n            j = i.L\n            while j != i:\n                j.col.size += 1\n                j.D.U = j\n                j.U.D = j\n                j = j.L\n            i = i.U\n        c.R.L = c\n        c.L.R = c\n\n    def _search(self):\n        \"\"\"The recursive backtracking search of Algorithm X.\"\"\"\n        if self.root.R == self.root:\n            self._reconstruct_solution()\n            return True\n\n        # S-heuristic: choose column with the smallest size.\n        c = None\n        min_size = float('inf')\n        j = self.root.R\n        while j != self.root:\n            if j.size < min_size:\n                min_size = j.size\n                c = j\n            j = j.R\n\n        if c is None or c.size == 0:\n            return False\n\n        self.cover(c)\n\n        r_node = c.D\n        while r_node != c:\n            self.solution_indices.append(r_node.row_idx)\n            j_node = r_node.R\n            while j_node != r_node:\n                self.cover(j_node.col)\n                j_node = j_node.R\n\n            if self._search():\n                return True\n\n            self.solution_indices.pop()\n            j_node = r_node.L\n            while j_node != r_node:\n                self.uncover(j_node.col)\n                j_node = j_node.L\n            \n            r_node = r_node.D\n        \n        self.uncover(c)\n        return False\n\n    def _reconstruct_solution(self):\n        \"\"\"Builds the final 9x9 grid from the solution row indices.\"\"\"\n        solved_grid = np.zeros((self.N, self.N), dtype=int)\n        for row_idx in self.solution_indices:\n            r, c, d = self._get_row_data_from_idx(row_idx)\n            solved_grid[r, c] = d\n        self.solution_grid = solved_grid.flatten().tolist()\n\n    def solve(self):\n        \"\"\"Runs the solver and returns the solution.\"\"\"\n        if not self.is_solvable:\n            return []\n        if self._search():\n            return self.solution_grid\n        else:\n            return []\n\ndef solve():\n    test_cases = [\n        # Test Case A (General solvable)\n        np.array([\n            [5, 3, 0, 0, 7, 0, 0, 0, 0],\n            [6, 0, 0, 1, 9, 5, 0, 0, 0],\n            [0, 9, 8, 0, 0, 0, 0, 6, 0],\n            [8, 0, 0, 0, 6, 0, 0, 0, 3],\n            [4, 0, 0, 8, 0, 3, 0, 0, 1],\n            [7, 0, 0, 0, 2, 0, 0, 0, 6],\n            [0, 6, 0, 0, 0, 0, 2, 8, 0],\n            [0, 0, 0, 4, 1, 9, 0, 0, 5],\n            [0, 0, 0, 0, 8, 0, 0, 7, 9]\n        ]),\n        # Test Case B (Nearly complete)\n        np.array([\n            [0, 3, 4, 6, 7, 8, 9, 1, 2],\n            [6, 7, 2, 1, 9, 5, 3, 4, 8],\n            [1, 9, 8, 3, 4, 2, 5, 6, 7],\n            [8, 5, 9, 7, 6, 1, 4, 2, 3],\n            [4, 2, 6, 8, 5, 3, 7, 9, 1],\n            [7, 1, 3, 9, 2, 4, 8, 5, 6],\n            [9, 6, 1, 5, 3, 7, 2, 8, 4],\n            [2, 8, 7, 4, 1, 9, 6, 3, 5],\n            [3, 4, 5, 2, 8, 6, 1, 7, 9]\n        ]),\n        # Test Case C (Unsolvable)\n        np.array([\n            [5, 5, 0, 0, 0, 0, 0, 0, 0],\n            [0, 0, 0, 0, 0, 0, 0, 0, 0],\n            [0, 0, 0, 0, 0, 0, 0, 0, 0],\n            [0, 0, 0, 0, 0, 0, 0, 0, 0],\n            [0, 0, 0, 0, 0, 0, 0, 0, 0],\n            [0, 0, 0, 0, 0, 0, 0, 0, 0],\n            [0, 0, 0, 0, 0, 0, 0, 0, 0],\n            [0, 0, 0, 0, 0, 0, 0, 0, 0],\n            [0, 0, 0, 0, 0, 0, 0, 0, 0]\n        ])\n    ]\n\n    results = []\n    for grid in test_cases:\n        solver = SudokuDLXSolver(grid)\n        result = solver.solve()\n        results.append(result)\n\n    # Format the final output string exactly as specified.\n    # [ [1,2,3], [], [4,5,6] ] -> \"[[1,2,3],[],[4,5,6]]\"\n    result_strings = []\n    for r in results:\n        if r:\n            result_strings.append(f\"[{','.join(map(str, r))}]\")\n        else:\n            result_strings.append(\"[]\")\n    \n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```"
        }
    ]
}