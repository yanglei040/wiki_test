{
    "hands_on_practices": [
        {
            "introduction": "动手实践的第一步是构建一个强大而高效的数独求解器。我们将使用经典的回溯算法，并通过位掩码（bitmasking）技术来表示约束条件，从而显著提升其性能。这个练习  不仅能巩固你对递归和搜索的理解，还将向你介绍一种处理集合约束的强大技巧，这种技巧在许多编程挑战中都非常常见。",
            "id": "3277909",
            "problem": "要求您设计并实现一个完整的、可运行的程序，该程序使用一种基于原则、由数据结构驱动的方法来解决标准数独问题。数独谜题是一个 $9\\times 9$ 的方形网格，其中填充了集合 $\\{1,2,3,4,5,6,7,8,9\\}$ 中的数字，以及用于表示空白的零。一个有效的数独解法为每个空白格填入一个数字，并满足三个约束条件：(i) 每一行都恰好包含 $\\{1,\\dots,9\\}$ 中的每个数字一次；(ii) 每一列都恰好包含 $\\{1,\\dots,9\\}$ 中的每个数字一次；(iii) 每个 $3\\times 3$ 的子网格（宫）都恰好包含 $\\{1,\\dots,9\\}$ 中的每个数字一次。\n\n请使用以下基本原理和定义作为您算法推导和实现的基础：\n- 集合与集合交集：一个单元格的可用数字集合是其所在行、列和宫中尚未使用的数字集合的交集。\n- 集合的位级表示：用一个 9 位掩码来表示数字集合 $\\{1,\\dots,9\\}$，其中第 $k$ 位（从零开始索引）对应数字 $k+1$。位值为 1 表示可用，0 表示不可用。按位与（AND）操作模拟集合交集，位清除操作模拟从集合中移除元素，位测试操作用于枚举候选数字。\n- 回溯搜索（深度优先搜索，DFS）：系统地尝试一个变量的候选值，在遇到矛盾时进行回溯。\n- 确定性的平局打破规则以确保可复现的解：始终选择具有最少剩余值（Minimum Remaining Values, MRV）的未填充单元格，即当前可用候选数字最少的单元格；如果出现平局，则选择按行主序排列的最早的单元格；在单元格内，按升序尝试候选数字。\n\n您的程序必须遵守以下要求：\n- 维护三个用于表示可用性的位掩码数组：每行一个，每列一个，每个 $3\\times 3$ 宫一个。将每个掩码初始化为全 1（表示数字 $\\{1,\\dots,9\\}$ 均可用），然后对于输入网格中的每个预填数字 $d$，在其对应的行、列和宫的掩码中清除 $d$ 对应的位。如果任何预填数字与其所在行、列或宫中已有的数字相矛盾（即相应的位已被清除），则该实例无解。\n- 在每个搜索步骤中，通过对相应行、列和宫的可用性掩码进行按位与（AND）运算，来计算一个空白单元格的候选数字掩码。如果此掩码为零，则表明发现了矛盾。\n- 在单元格中填入数字 $d$ 后，通过清除 $d$ 对应的位来更新这三个可用性掩码；回溯时，恢复这些掩码。\n- 如果一个实例有解，则返回遵循 MRV 和升序候选数字策略的任意一个解。如果实例无解，则报告其无解。\n\n测试套件和答案规范：\n对于每个测试实例，您的程序必须计算一个单独的整数结果，定义如下：\n- 如果实例有解，设解的第一行数字为 $[r_1,r_2,\\dots,r_9]$。输出将这 9 个数字按顺序连接得到的整数，即十进制整数 $r_1\\cdot 10^{8} + r_2\\cdot 10^{7} + \\dots + r_9$。\n- 如果实例无解，则输出整数 $-1$。\n\n使用以下四个测试用例。每个测试用例都是一个 $9\\times 9$ 的矩阵，其中用零表示空白。\n\n测试用例 1（一个标准的可解实例）：\n- 第 1 行：$(5,3,0,0,7,0,0,0,0)$\n- 第 2 行：$(6,0,0,1,9,5,0,0,0)$\n- 第 3 行：$(1,9,8,0,0,2,0,6,7)$\n- 第 4 行：$(8,0,0,0,6,0,0,0,3)$\n- 第 5 行：$(4,0,0,8,0,3,0,0,1)$\n- 第 6 行：$(7,0,0,0,2,0,0,0,6)$\n- 第 7 行：$(0,6,0,0,0,0,2,8,0)$\n- 第 8 行：$(0,0,0,4,1,9,0,0,5)$\n- 第 9 行：$(0,0,0,0,8,0,0,7,9)$\n\n测试用例 2（一个已解出的有效网格）：\n- 第 1 行：$(5,3,4,6,7,8,9,1,2)$\n- 第 2 行：$(6,7,2,1,9,5,3,4,8)$\n- 第 3 行：$(1,9,8,3,4,2,5,6,7)$\n- 第 4 行：$(8,5,9,7,6,1,4,2,3)$\n- 第 5 行：$(4,2,6,8,5,3,7,9,1)$\n- 第 6 行：$(7,1,3,9,2,4,8,5,6)$\n- 第 7 行：$(9,6,1,5,3,7,2,8,4)$\n- 第 8 行：$(2,8,7,4,1,9,6,3,5)$\n- 第 9 行：$(3,4,5,2,8,6,1,7,9)$\n\n测试用例 3（因行冲突而无解；注意第一行中的重复数字）：\n- 第 1 行：$(6,3,4,6,7,8,9,1,2)$\n- 第 2 行：$(6,7,2,1,9,5,3,4,8)$\n- 第 3 行：$(1,9,8,3,4,2,5,6,7)$\n- 第 4 行：$(8,5,9,7,6,1,4,2,3)$\n- 第 5 行：$(4,2,6,8,5,3,7,9,1)$\n- 第 6 行：$(7,1,3,9,2,4,8,5,6)$\n- 第 7 行：$(9,6,1,5,3,7,2,8,4)$\n- 第 8 行：$(2,8,7,4,1,9,6,3,5)$\n- 第 9 行：$(3,4,5,2,8,6,1,7,9)$\n\n测试用例 4（另一个已解出的有效网格）：\n- 第 1 行：$(1,2,3,4,5,6,7,8,9)$\n- 第 2 行：$(4,5,6,7,8,9,1,2,3)$\n- 第 3 行：$(7,8,9,1,2,3,4,5,6)$\n- 第 4 行：$(2,1,4,3,6,5,8,9,7)$\n- 第 5 行：$(3,6,5,8,9,7,2,1,4)$\n- 第 6 行：$(8,9,7,2,1,4,3,6,5)$\n- 第 7 行：$(5,3,1,6,4,2,9,7,8)$\n- 第 8 行：$(6,4,2,9,7,8,5,3,1)$\n- 第 9 行：$(9,7,8,5,3,1,6,4,2)$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含按顺序排列的测试用例 1 到 4 的结果，形式为一个用方括号括起来的逗号分隔列表。例如，该行应类似于 $[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4]$，不含空格。\n\n不应从标准输入读取任何输入。执行所需的所有数据都必须直接嵌入到程序中。",
            "solution": "该问题要求设计并实现一个数独求解器，该求解器需基于一组指定的原则：回溯搜索、用于表示数字可用性的位掩码，以及用于变量排序的“最少剩余值”（Minimum Remaining Values, MRV）启发式算法。该解法必须是确定性的，并且能处理有解和无解的数独实例。\n\n该问题定义严谨，在算法上是自洽的。它在科学上基于已建立的约束满足问题（Constraint Satisfaction Problems, CSPs）理论，而数独是该理论的一个典型例子。所要求的方法论——结合了深度优先搜索、用于提高效率的位级数据结构以及启发式引导搜索——是一种标准且有效的方法。该问题提法恰当，提供了确定性的平局打破规则，从而保证了对于任何给定的有效输入，都存在唯一的算法路径，并因此得到唯一的解。所有术语都得到了正式定义，测试用例和输出格式也已精确指定。因此，该问题是有效的，我们可以着手进行合理的求解。\n\n一个 $9 \\times 9$ 的数独谜题可以被建模为一个 CSP。变量是网格中的 81 个单元格，我们可以用坐标 $(i, j)$ 来表示它们，其中 $i, j \\in \\{0, 1, \\dots, 8\\}$。每个单元格的定义域是允许的数字集合 $\\{1, 2, \\dots, 9\\}$。约束条件要求在每一行、每一列以及九个 $3 \\times 3$ 的宫格中，所有单元格都必须包含不同的数字。\n\n指定算法的核心是使用位掩码来表示每行、每列和每宫的可用数字集合。一个 9 位整数可以表示集合 $D = \\{1, 2, \\dots, 9\\}$。我们将数字 $d$ 映射到第 $(d-1)$ 位（从零开始索引）。位值为 1 表示该数字可用，而为 0 表示不可用。因此，数字 $d$ 的位掩码是 $1 \\ll (d-1)$。所有数字都可用的初始状态由所有 9 位都设置为 1 的掩码表示，即 $2^9 - 1 = 511$，或二进制的 `0b111111111`。对于确定一个单元格的可用候选数字至关重要的集合交集运算，可以通过按位 `AND` 操作高效地计算。\n\n我们将维护三个数组来跟踪数字的可用性：\n- `rows[9]`：一个数组，其中 `rows[i]` 是第 $i$ 行可用数字的位掩码。\n- `cols[9]`：一个数组，其中 `cols[j]` 是第 $j$ 列可用数字的位掩码。\n- `boxes[9]`：一个数组，其中 `boxes[k]` 是第 $k$ 个宫可用数字的位掩码。单元格 $(i, j)$ 的宫索引 $k$ 计算方式为 $k = (i \\,//\\, 3) \\cdot 3 + (j \\,//\\, 3)$。\n\n求解过程包括两个主要阶段：初始化和递归搜索。\n\n**1. 初始化阶段**\n求解器通过给定的 $9 \\times 9$ 网格进行初始化。\n- 首先，将 `rows`、`cols` 和 `boxes` 掩码数组初始化为“全部可用”掩码 $511$。\n- 创建一个包含所有空白单元格（值为 0 的单元格）的列表，并保持行主序。这对于平局打破规则至关重要。\n- 然后，算法遍历输入网格。对于 `grid[i][j]` 处每个值为非零数字 $d$ 的预填单元格：\n    a. 计算数字 $d$ 的位掩码 `mask_d = 1  (d-1)`。\n    b. 执行有效性检查。数字 $d$ 必须在其所在行 $i$、列 $j$ 和对应的宫 $k$ 中是可用的。这当且仅当 $d$ 对应的位在 `rows[i]`、`cols[j]` 和 `boxes[k]` 中都被置位时才成立。如果 `(rows[i]  mask_d) == 0`，或者对列或宫掩码的相同检查失败，则谜题存在初始矛盾，因而无解。\n    c. 如果检查通过，数字 $d$ 现在被认为在该行、列和宫中已被使用。通过清除 $d$ 对应的位来更新相应的掩码：`rows[i] = ~mask_d`、`cols[j] = ~mask_d` 和 `boxes[k] = ~mask_d`。\n\n如果此初始化过程完成而没有发现任何矛盾，算法将进入搜索阶段。否则，它将终止并报告该实例无解。\n\n**2. 递归回溯搜索**\n解的搜索是通过一个递归函数执行的，该函数在空白单元格的可能数字分配空间上实现深度优先搜索（DFS）。\n\n- **基准情形：** 当空白单元格列表为空时，递归成功终止。这表示每个单元格都已被分配一个有效的数字，找到了一个完整的解。函数返回 `True`。\n\n- **递归步骤：**\n    a. **变量选择（MRV 启发式算法）：** 算法选择下一个要填充的空白单元格。根据 MRV 启发式算法，我们必须选择可用候选数字数量最少的单元格。为此，我们遍历当前的空白单元格列表。对于每个空白单元格 $(i, j)$：\n        i. 候选数字集合是其所在行、列和宫中可用数字的交集。计算方式为 `candidates_mask = rows[i]  cols[j]  boxes[(i//3)*3 + (j//3)]`。\n        ii. 候选数字的数量是 `candidates_mask` 中置位（为1）的位数，也称为“population count”。\n        iii. 作为一种前向检查，如果任何空白单元格的 `candidates_mask` 为 0，则意味着在当前状态下该单元格没有有效的数字。这条路径会导致矛盾，因此函数必须立即通过返回 `False` 来回溯。\n        iv. 算法跟踪具有最少正数个候选数字的单元格。问题规定，平局通过选择按行主序最早出现的单元格来打破。由于我们的空白单元格列表已按此顺序排列，我们只需在找到具有严格更少候选数字的单元格时更新我们的选择。\n\n    b. **值选择与递归：** 一旦选定最佳单元格 $(i, j)$，算法会尝试在其中填入一个数字。\n        i. 根据问题的平局打破规则，它按升序遍历数字 $d \\in \\{1, \\dots, 9\\}$。\n        ii. 对于每个数字 $d$，它通过测试 `candidates_mask` 中对应的位来检查其是否为有效候选数字。\n        iii. 如果 $d$ 是一个有效的候选数字：\n            - **放置：** 将数字 $d$ 放置在 `grid[i][j]` 中。通过从 `rows[i]`、`cols[j]` 和 `boxes[k]` 中清除 $d$ 对应的位来更新状态。按位 `XOR` 操作 (`^=`) 非常适合此目的，因为它既能清除该位（如果当前已置位），又能在回溯时再次使用以恢复它。\n            - **递归：** 调用递归函数来求解剩余的空白单元格。\n            - **传播成功：** 如果递归调用返回 `True`，则意味着找到了解。这个 `True` 值会向上传递到调用栈，搜索终止。\n\n    c. **回溯：** 如果对单元格 $(i, j)$ 的所有候选数字的循环完成而递归调用没有返回 `True`，则意味着无法从当前状态达到解。算法必须回溯。\n        i. 撤销分配：将 `grid[i][j]` 重置为 $0$。\n        ii. 通过使用 `mask_d` 应用相同的 `XOR` 操作，将状态掩码恢复到其先前的值。\n        iii. 函数返回 `False`，向父调用发出信号，表明所选路径失败。\n\n如果对递归函数的初始调用返回 `False`，则该谜题无解。\n\n**3. 输出生成**\n求解器完成后，会为该实例生成一个单独的整数结果。\n- 如果找到了解，则将已完成网格顶行中的数字 $[r_1, r_2, \\dots, r_9]$ 连接起来，形成一个十进制整数。\n- 如果谜题被确定为无解（无论是在初始化期间还是通过搜索），结果为 $-1$。\n求解器会对所有提供的测试用例运行，并将结果收集并格式化为指定的字符串格式。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass SudokuSolver:\n    \"\"\"\n    Solves a 9x9 Sudoku puzzle using backtracking, bitmasking, and the\n    Minimum Remaining Values (MRV) heuristic.\n    \"\"\"\n\n    def __init__(self, grid):\n        \"\"\"\n        Initializes the solver, sets up data structures, and validates the\n        initial grid configuration.\n        \"\"\"\n        self.grid = np.array(grid, dtype=int)\n        self.initial_grid_is_valid = True\n\n        # Bitmasks for rows, cols, and boxes. 0b111111111 represents {1..9}.\n        self.all_digits_mask = (1  9) - 1\n        self.rows = [self.all_digits_mask] * 9\n        self.cols = [self.all_digits_mask] * 9\n        self.boxes = [self.all_digits_mask] * 9\n        self.blanks = []\n\n        self._initialize_masks()\n\n    def _initialize_masks(self):\n        \"\"\"\n        Populates masks based on pre-filled numbers and identifies blank cells.\n        Checks for initial contradictions in the grid.\n        \"\"\"\n        for r in range(9):\n            for c in range(9):\n                digit = self.grid[r, c]\n                if digit != 0:\n                    if not self._update_masks(r, c, digit, 'place'):\n                        self.initial_grid_is_valid = False\n                        return\n                else:\n                    self.blanks.append((r, c))\n\n    def _update_masks(self, r, c, d, action):\n        \"\"\"\n        Updates the availability masks for a given cell and digit.\n        If 'place', it validates and clears the bit.\n        If 'backtrack_xor', it restores the bit.\n        The XOR operation is used for its self-reverting property, but initial\n        placement requires a stricter check and clear.\n        \"\"\"\n        box_idx = (r // 3) * 3 + (c // 3)\n        mask_d = 1  (d - 1)\n\n        if action == 'place':\n            # Check for contradiction before placing\n            if not (self.rows[r]  mask_d and self.cols[c]  mask_d and self.boxes[box_idx]  mask_d):\n                return False\n            # Place the digit by clearing its bit\n            self.rows[r] = ~mask_d\n            self.cols[c] = ~mask_d\n            self.boxes[box_idx] = ~mask_d\n        elif action == 'backtrack_xor':\n            # Flip the bit back (0->1) using XOR\n            self.rows[r] ^= mask_d\n            self.cols[c] ^= mask_d\n            self.boxes[box_idx] ^= mask_d\n        \n        return True\n    \n    def solve_puzzle(self):\n        \"\"\"\n        Public method to start the solving process.\n        \"\"\"\n        if not self.initial_grid_is_valid:\n            return -1\n\n        if self._backtrack():\n            top_row = self.grid[0, :]\n            return int(\"\".join(map(str, top_row)))\n        else:\n            return -1\n\n    def _backtrack(self):\n        \"\"\"\n        Recursive backtracking algorithm (DFS).\n        \"\"\"\n        if not self.blanks:\n            return True  # Base case: All cells filled\n\n        # 1. Variable Selection: Find blank cell with MRV\n        min_candidates_count = 10\n        best_cell_info = None  # (index in blanks list, r, c, candidates_mask)\n\n        for i, (r, c) in enumerate(self.blanks):\n            box_idx = (r // 3) * 3 + (c // 3)\n            candidates_mask = self.rows[r]  self.cols[c]  self.boxes[box_idx]\n            count = bin(candidates_mask).count('1')\n\n            if count == 0:\n                return False  # Forward checking: contradiction detected\n\n            if count  min_candidates_count:\n                min_candidates_count = count\n                best_cell_info = (i, r, c, candidates_mask)\n\n        idx_in_blanks, r, c, candidates_mask = best_cell_info\n        \n        # Temporarily remove the chosen cell from the list\n        cell_to_fill = self.blanks.pop(idx_in_blanks)\n\n        # 2. Value Selection: Try candidates in ascending order\n        for d in range(1, 10):\n            mask_d = 1  (d - 1)\n            if candidates_mask  mask_d:\n                # Place digit and update state\n                self.grid[r, c] = d\n                # Using XOR to flip the bit from 1 to 0\n                self._update_masks(r, c, d, 'backtrack_xor') \n\n                if self._backtrack():\n                    return True\n\n                # Backtrack: undo placement and restore state\n                self._update_masks(r, c, d, 'backtrack_xor')\n\n        # If no candidate leads to a solution, restore the chosen cell and backtrack fully\n        self.blanks.insert(idx_in_blanks, cell_to_fill)\n        self.grid[r,c] = 0 # Explicitly clear the cell on the grid\n\n        return False\n\ndef solve():\n    \"\"\"\n    Main function to run the Sudoku solver on the provided test cases.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        np.array([\n            [5, 3, 0, 0, 7, 0, 0, 0, 0],\n            [6, 0, 0, 1, 9, 5, 0, 0, 0],\n            [1, 9, 8, 0, 0, 2, 0, 6, 7],\n            [8, 0, 0, 0, 6, 0, 0, 0, 3],\n            [4, 0, 0, 8, 0, 3, 0, 0, 1],\n            [7, 0, 0, 0, 2, 0, 0, 0, 6],\n            [0, 6, 0, 0, 0, 0, 2, 8, 0],\n            [0, 0, 0, 4, 1, 9, 0, 0, 5],\n            [0, 0, 0, 0, 8, 0, 0, 7, 9]\n        ]),\n        # Test case 2\n        np.array([\n            [5, 3, 4, 6, 7, 8, 9, 1, 2],\n            [6, 7, 2, 1, 9, 5, 3, 4, 8],\n            [1, 9, 8, 3, 4, 2, 5, 6, 7],\n            [8, 5, 9, 7, 6, 1, 4, 2, 3],\n            [4, 2, 6, 8, 5, 3, 7, 9, 1],\n            [7, 1, 3, 9, 2, 4, 8, 5, 6],\n            [9, 6, 1, 5, 3, 7, 2, 8, 4],\n            [2, 8, 7, 4, 1, 9, 6, 3, 5],\n            [3, 4, 5, 2, 8, 6, 1, 7, 9]\n        ]),\n        # Test case 3\n        np.array([\n            [6, 3, 4, 6, 7, 8, 9, 1, 2], # Duplicate 6\n            [6, 7, 2, 1, 9, 5, 3, 4, 8],\n            [1, 9, 8, 3, 4, 2, 5, 6, 7],\n            [8, 5, 9, 7, 6, 1, 4, 2, 3],\n            [4, 2, 6, 8, 5, 3, 7, 9, 1],\n            [7, 1, 3, 9, 2, 4, 8, 5, 6],\n            [9, 6, 1, 5, 3, 7, 2, 8, 4],\n            [2, 8, 7, 4, 1, 9, 6, 3, 5],\n            [3, 4, 5, 2, 8, 6, 1, 7, 9]\n        ]),\n        # Test case 4\n        np.array([\n            [1, 2, 3, 4, 5, 6, 7, 8, 9],\n            [4, 5, 6, 7, 8, 9, 1, 2, 3],\n            [7, 8, 9, 1, 2, 3, 4, 5, 6],\n            [2, 1, 4, 3, 6, 5, 8, 9, 7],\n            [3, 6, 5, 8, 9, 7, 2, 1, 4],\n            [8, 9, 7, 2, 1, 4, 3, 6, 5],\n            [5, 3, 1, 6, 4, 2, 9, 7, 8],\n            [6, 4, 2, 9, 7, 8, 5, 3, 1],\n            [9, 7, 8, 5, 3, 1, 6, 4, 2]\n        ])\n    ]\n\n    results = []\n    for grid in test_cases:\n        solver = SudokuSolver(grid)\n        result = solver.solve_puzzle()\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "拥有求解器后，一个自然而然的进阶是解决其逆问题：生成谜题。这个练习将挑战你创建具有唯一解的数独谜题，这是高质量谜题的标志。通过实现一个生成器 ，你将学习如何利用解计数算法来引导“挖洞”过程，从而更深入地洞察数独的结构以及约束满足问题的本质。",
            "id": "3277827",
            "problem": "你需要设计并实现一个完整、可运行的程序，该程序基于约束满足问题（CSP）的形式化框架，生成具有唯一解的数独谜题。数独谜题是一个部分填充的 $9\\times 9$ 网格，使用数字 $\\{1,2,3,4,5,6,7,8,9\\}$，并满足以下约束：每一行必须包含每个数字恰好一次，每一列必须包含每个数字恰好一次，且每个 $3\\times 3$ 的子网格也必须包含每个数字恰好一次。如果存在且仅存在一种将数字完整赋给所有单元格并满足所有约束的方案，则称该谜题有唯一解。目标是从基本原则出发生成此类谜题并验证其唯一性。\n\n需要使用的基本定义：\n- 一个数独实例是一个有限域约束满足问题（CSP），其中每个单元格是一个变量，其定义域为 $\\{1,2,3,4,5,6,7,8,9\\}$，约束条件在行、列和子网格上强制实施全不同关系。\n- CSP的一个解是一个赋值映射，它将每个变量映射到其定义域中的一个值，并满足所有约束。\n- 唯一性要求恰好只有一个解；形式上，解集的基数等于 $1$。\n\n你的程序必须：\n1. 从任何一个有效的已解决网格开始，通过应用结构保持变换来构造有效的已解决数独网格，确保行、列和子网格始终是 $\\{1,2,3,4,5,6,7,8,9\\}$ 的排列这一不变量。\n2. 通过从已解决的网格中移除提示数（已填充的单元格）来派生数独谜题，同时保持谜题具有唯一解的属性。必须通过使用带约束传播和回溯的原则性方法来计算解的数量，从而验证唯一性。当找到超过 $1$ 个解时，解计数器必须提前终止。\n3. 通过一个种子来使用确定性伪随机性，以便可复现地生成不同的谜题。\n\n测试套件：\n为以下参数对 $(s,k)$ 实现并运行生成器，其中 $s$ 是伪随机种子， $k$ 是尝试保留的目标提示数数量：\n- 情况 1：$(s,k) = (17,30)$。\n- 情况 2：$(s,k) = (12345,26)$。\n- 情况 3：$(s,k) = (2024,38)$。\n你的生成器应尝试移除提示数，直到谜题将失去唯一性或剩余提示数数量将低于 $k$ 时停止，以先发生者为准。\n\n答案规格：\n对于每个测试用例，计算以下结果：\n- 最终谜题中实际保留的提示数的整数计数。\n- 一个布尔值，表示是否通过计数验证了最终谜题恰好有唯一解。\n\n最终输出格式：\n你的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素对应一个测试用例（按给定顺序），且其本身是一个双元素列表 $\\big[\\text{clue\\_count},\\text{is\\_unique}\\big]$。例如，格式为 $[[a_1,b_1],[a_2,b_2],[a_3,b_3]]$，其中每个 $a_i$ 是一个整数，每个 $b_i$ 是一个布尔值。",
            "solution": "生成具有唯一解的数独谜题是一个定义明确的算法挑战，其根源在于约束满足问题（CSP）的理论。一个数独谜题可以被建模为一个包含 $81$ 个变量的 CSP，每个变量对应 $9 \\times 9$ 网格中的一个单元格。每个变量的定义域是数字集合 $\\{1, 2, 3, 4, 5, 6, 7, 8, 9\\}$。约束是应用于每行、每列以及九个 $3 \\times 3$ 子网格中变量的“全不同”约束。谜题的一个解是为所有变量赋予值的一个完整且一致的赋值。问题要求生成的谜题其解是唯一的，即解集的基数恰好为 $1$。\n\n我们的方法是系统性的，并基于这些原则。它包括三个主要阶段：首先，生成一个完整且有效的数独网格；其次，实现一个能够验证解唯一性的求解器；第三，使用此求解器从完整网格中移除提示数，以形成一个遵守唯一性和提示数数量约束的最小谜题。\n\n**1. 通过结构保持变换生成已解决的数独网格**\n\n与从空网格开始求解 CSP（这在计算上是昂贵的）不同，我们从一个已知的、有效的、已解决的数独网格开始。基于这个基础网格，可以通过应用一系列保持数独属性（即每行、每列和每个 $3 \\times 3$ 子网格都是 $\\{1, 2, ..., 9\\}$ 的一个排列）的变换来生成大量其他有效的已解决网格。这些变换包括：\n\n- **数字重标记**：对整个网格中的数字 $\\{1, ..., 9\\}$ 应用一个置换。例如，可以将每个 $1$ 替换为 $5$，每个 $5$ 替换为 $1$，依此类推。\n- **行和列的置换**：\n    - 行可以在其各自的 $3$ 行带内进行置换（例如，行 $0, 1, 2$ 可以重新排列）。\n    - 列可以在其各自的 $3$ 列栈内进行置换（例如，列 $3, 4, 5$ 可以重新排列）。\n    - 三个行带（行 $0-2$, $3-5$, $6-8$）可以相互置换。\n    - 三个列栈（列 $0-2$, $3-5$, $6-8$）可以相互置换。\n- **网格转置**：网格可以沿其主对角线进行转置，交换行和列的角色。\n\n通过应用一系列基于使用特定种子 $s$ 初始化的确定性伪随机数生成器选择的变换，我们可以以可复现的方式生成各种各样的已解决网格。\n\n**2. 通过带提前终止的回溯法进行唯一性验证**\n\n问题的核心是验证一个谜题是否恰好只有一个解。这是一个#P完全问题，但对于一个 $9 \\times 9$ 的网格，使用高效的回溯算法是可解的。该算法系统地探索可能赋值的搜索空间。\n\n过程如下：\n- 定义一个递归函数，该函数尝试逐个单元格地填充网格。\n- 它识别下一个未赋值的变量（单元格）。如果所有单元格都已赋值，则表示找到了一个有效解，函数返回 $1$。\n- 对于选定的未赋值单元格，函数遍历其定义域中所有可能的值（$1$ 到 $9$）。\n- 对于每个值，它检查将该值放入单元格是否违反任何数独约束（行、列或子网格）。\n- 如果该值有效，则将其暂时赋给该单元格，并递归调用自身来解决谜题的其余部分。递归调用找到的解的数量被加到一个运行总数中。\n- 递归调用返回后，该单元格被取消赋值（其值被重置为 $0$），以允许探索搜索树的其他分支（这就是“回溯”）。\n\n为了验证唯一性，我们采用了一个关键的优化。如果解的总数大于 $1$，我们就不关心确切的解数。因此，一旦找到两个不同的解，计数过程就可以终止。求解器的实现方式是返回 $0$（无解）、$1$（唯一解）或 $2$（代表至少两个解）。这种“提前退出”策略显著地修剪了搜索空间，使该过程比完整的解计数算法效率高得多。\n\n**3. 通过贪心移除提示数来派生谜题**\n\n从第一步生成的完全解出的网格开始，我们通过移除提示数（非零数字）来派生一个谜题。目标是尽可能多地移除提示数，同时确保谜题保持唯一解，并且最终提示数数量至少为给定的目标值 $k$。过程如下：\n\n- 创建一个包含所有 $81$ 个单元格位置的列表，并（使用带种子的生成器以保证可复现性）随机打乱。\n- 算法遍历这个被打乱的单元格位置列表。\n- 对于每个单元格，检查当前的提示数数量是否大于目标值 $k$。如果不是，则过程终止，因为我们无法在不低于目标值的情况下移除更多提示数。\n- 如果提示数数量大于 $k$，算法会暂时移除当前单元格的数字（将其值设为 $0$）。\n- 然后，它调用上述的回溯求解器来计算修改后网格的解的数量，上限为 $2$。\n- 如果求解器返回恰好为 $1$，则谜题仍然是唯一可解的。移除操作被确认，提示数数量减一。\n- 如果求解器返回任何其他值（$0$ 或 $2$），则移除该提示数会破坏唯一性属性。通过将原始数字恢复到该单元格来撤销移除操作。\n\n这个贪心过程持续进行，直到所有单元格位置都已考虑移除，或达到提示数数量的阈值 $k$。生成的谜题保证有唯一解，并且至少有 $k$ 个提示数。每个测试用例的最终输出包括在生成的谜题中实际保留的提示数数量和一个确认其唯一性的布尔值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to generate and validate Sudoku puzzles based on test cases.\n    \"\"\"\n\n    # Base solved Sudoku grid. All other solved grids are derived from this.\n    base_grid = np.array([\n        [5, 3, 4, 6, 7, 8, 9, 1, 2],\n        [6, 7, 2, 1, 9, 5, 3, 4, 8],\n        [1, 9, 8, 3, 4, 2, 5, 6, 7],\n        [8, 5, 9, 7, 6, 1, 4, 2, 3],\n        [4, 2, 6, 8, 5, 3, 7, 9, 1],\n        [7, 1, 3, 9, 2, 4, 8, 5, 6],\n        [9, 6, 1, 5, 3, 7, 2, 8, 4],\n        [2, 8, 7, 4, 1, 9, 6, 3, 5],\n        [3, 4, 5, 2, 8, 6, 1, 7, 9]\n    ])\n\n    def is_valid_placement(grid, row, col, num):\n        \"\"\"Checks if placing a number in a cell is valid.\"\"\"\n        if num in grid[row, :]:\n            return False\n        if num in grid[:, col]:\n            return False\n        start_row, start_col = 3 * (row // 3), 3 * (col // 3)\n        if num in grid[start_row:start_row + 3, start_col:start_col + 3]:\n            return False\n        return True\n\n    def count_solutions_limited(grid, limit):\n        \"\"\"\n        Recursively counts solutions of a Sudoku grid using backtracking.\n        Terminates early if the count reaches the specified limit.\n        \"\"\"\n        try:\n            row, col = np.argwhere(grid == 0)[0]\n        except IndexError:\n            # No empty cells found, so this is one complete solution.\n            return 1\n\n        count = 0\n        for num in range(1, 10):\n            if is_valid_placement(grid, row, col, num):\n                grid[row, col] = num\n                count += count_solutions_limited(grid, limit - count)\n                if count >= limit:\n                    # Early exit if we've found enough solutions\n                    grid[row, col] = 0 # Backtrack before returning\n                    return count\n        \n        # Backtrack\n        grid[row, col] = 0\n        return count\n\n    def generate_solved_grid(rng, base):\n        \"\"\"\n        Generates a new valid solved Sudoku grid from a base grid using\n        structure-preserving transformations.\n        \"\"\"\n        grid = base.copy()\n\n        # 1. Relabel digits\n        mapping = np.arange(10)\n        mapping[1:] = rng.permutation(np.arange(1, 10))\n        grid = mapping[grid]\n\n        # 2. Transpose (50% chance)\n        if rng.random() > 0.5:\n            grid = grid.T\n\n        # 3. Permute row bands and rows within bands\n        band_order = rng.permutation(3)\n        new_grid = np.vstack([grid[band_order[i]*3 : band_order[i]*3+3, :] for i in range(3)])\n        for band in range(3):\n            row_order = rng.permutation(3)\n            rows = new_grid[band*3:band*3+3, :]\n            new_grid[band*3:band*3+3, :] = rows[row_order, :]\n        grid = new_grid\n\n        # 4. Permute column stacks and columns within stacks\n        stack_order = rng.permutation(3)\n        new_grid = np.hstack([grid[:, stack_order[i]*3 : stack_order[i]*3+3] for i in range(3)])\n        for stack in range(3):\n            col_order = rng.permutation(3)\n            cols = new_grid[:, stack*3:stack*3+3]\n            new_grid[:, stack*3:stack*3+3] = cols[:, col_order]\n        grid = new_grid\n        \n        return grid\n\n    def create_puzzle(solved_grid, rng, k):\n        \"\"\"\n        Removes clues from a solved grid to create a puzzle with at least k clues\n        and a unique solution.\n        \"\"\"\n        puzzle = solved_grid.copy()\n        # Get a random order of cells to try removing\n        indices = rng.permutation(np.arange(81))\n        \n        clues = 81\n        for idx in indices:\n            if clues = k:\n                break\n            \n            row, col = divmod(idx, 9)\n            \n            value = puzzle[row, col]\n            puzzle[row, col] = 0\n            \n            # Check for uniqueness. We need exactly 1 solution.\n            # We count up to 2 solutions for efficiency.\n            num_sols = count_solutions_limited(puzzle.copy(), 2)\n            \n            if num_sols != 1:\n                # If not unique, restore the value and try the next cell\n                puzzle[row, col] = value\n            else:\n                # If unique, the removal is successful\n                clues -= 1\n        \n        final_clue_count = np.count_nonzero(puzzle)\n        is_unique = (count_solutions_limited(puzzle.copy(), 2) == 1)\n\n        return final_clue_count, is_unique\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (17, 30),\n        (12345, 26),\n        (2024, 38),\n    ]\n\n    results = []\n    for s, k in test_cases:\n        # Initialize the pseudo-random number generator with the seed\n        rng = np.random.default_rng(s)\n        \n        # 1. Generate a new valid solved grid\n        solved_grid = generate_solved_grid(rng, base_grid)\n        \n        # 2. Create a puzzle by removing clues\n        clue_count, is_unique = create_puzzle(solved_grid, rng, k)\n        \n        results.append([clue_count, is_unique])\n\n    # Format the results into the required string format `[[c1,b1],[c2,b2],...]`\n    formatted_results = []\n    for clue_count, is_unique in results:\n        # Python's `True`/`False` string representation is standard.\n        formatted_results.append(f\"[{clue_count},{is_unique}]\")\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "最后的这个练习将介绍一种完全不同且极为优雅的数独求解方法：将其构建为一个“精确覆盖”问题。你将使用 Donald Knuth 的舞蹈链（Dancing Links, DLX）技术来实现他的 X 算法，这是一种解决此类问题的高度专用方法。这个练习  充分展示了算法抽象的力量，并揭示了视角的转变如何能带来一个高效而优美的解决方案。",
            "id": "3277848",
            "problem": "实现一个完整的、可运行的程序，通过将标准数独实例归约为精确覆盖问题，并应用 Donald Knuth 的 X 算法与舞蹈链 (DLX) 来解决它们。任务是基于以下基础，从头设计和实现数据结构与搜索算法。\n\n基础原理：\n- 精确覆盖的定义：给定一个有限全集 $\\mathcal{U}$ 和一个 $\\mathcal{U}$ 的子集族 $\\mathcal{S}$，一个精确覆盖是一个子集族 $\\mathcal{C} \\subseteq \\mathcal{S}$，使得 $\\mathcal{U}$ 中的每个元素都恰好包含在 $\\mathcal{C}$ 的一个成员中。\n- 数独约束：标准数独由一个 $9 \\times 9$ 的网格组成。有效的解满足以下不变性条件：\n  1. 每个单元格包含一个 $\\{1,2,\\dots,9\\}$ 中的数字。\n  2. 每一行恰好包含一次 $\\{1,2,\\dots,9\\}$ 中的每个数字。\n  3. 每一列恰好包含一次 $\\{1,2,\\dots,9\\}$ 中的每个数字。\n  4. 每个 $3 \\times 3$ 的宫格恰好包含一次 $\\{1,2,\\dots,9\\}$ 中的每个数字。\n\n你的程序必须：\n- 将数独表述为一个精确覆盖实例，其中每个候选赋值“行”对应于在单元格 $(r,c)$（其中 $r \\in \\{0,\\dots,8\\}$，$c \\in \\{0,\\dots,8\\}$）中填入数字 $d \\in \\{1,\\dots,9\\}$，全集则编码了四类约束：单元格占用、行-数字、列-数字和宫格-数字。在无约束的情况下，这会产生 $729$ 个候选行和 $324$ 个约束列。\n- 实现舞蹈链 (DLX)，它是 X 算法的一种链式结构实现，以便在回溯搜索期间高效地对稀疏的精确覆盖矩阵执行覆盖和恢复操作。\n- 通过将候选解限制为与提供的非零数字一致的解来尊重“给定数”。使用 $0$ 表示空单元格。\n\n测试套件：\n为以下三个测试用例提供解决方案。每个测试用例是一个 $9 \\times 9$ 的网格，以九行九个整数的形式给出。整数 $0$ 表示空单元格。\n- 测试用例 A（具有唯一解的常规可解实例）：\n  - 第 $1$ 行：$(5,\\,3,\\,0,\\,0,\\,7,\\,0,\\,0,\\,0,\\,0)$\n  - 第 $2$ 行：$(6,\\,0,\\,0,\\,1,\\,9,\\,5,\\,0,\\,0,\\,0)$\n  - 第 $3$ 行：$(0,\\,9,\\,8,\\,0,\\,0,\\,0,\\,0,\\,6,\\,0)$\n  - 第 $4$ 行：$(8,\\,0,\\,0,\\,0,\\,6,\\,0,\\,0,\\,0,\\,3)$\n  - 第 $5$ 行：$(4,\\,0,\\,0,\\,8,\\,0,\\,3,\\,0,\\,0,\\,1)$\n  - 第 $6$ 行：$(7,\\,0,\\,0,\\,0,\\,2,\\,0,\\,0,\\,0,\\,6)$\n  - 第 $7$ 行：$(0,\\,6,\\,0,\\,0,\\,0,\\,0,\\,2,\\,8,\\,0)$\n  - 第 $8$ 行：$(0,\\,0,\\,0,\\,4,\\,1,\\,9,\\,0,\\,0,\\,5)$\n  - 第 $9$ 行：$(0,\\,0,\\,0,\\,0,\\,8,\\,0,\\,0,\\,7,\\,9)$\n- 测试用例 B（接近完成，只有一个空格）：\n  - 第 $1$ 行：$(0,\\,3,\\,4,\\,6,\\,7,\\,8,\\,9,\\,1,\\,2)$\n  - 第 $2$ 行：$(6,\\,7,\\,2,\\,1,\\,9,\\,5,\\,3,\\,4,\\,8)$\n  - 第 $3$ 行：$(1,\\,9,\\,8,\\,3,\\,4,\\,2,\\,5,\\,6,\\,7)$\n  - 第 $4$ 行：$(8,\\,5,\\,9,\\,7,\\,6,\\,1,\\,4,\\,2,\\,3)$\n  - 第 $5$ 行：$(4,\\,2,\\,6,\\,8,\\,5,\\,3,\\,7,\\,9,\\,1)$\n  - 第 $6$ 行：$(7,\\,1,\\,3,\\,9,\\,2,\\,4,\\,8,\\,5,\\,6)$\n  - 第 $7$ 行：$(9,\\,6,\\,1,\\,5,\\,3,\\,7,\\,2,\\,8,\\,4)$\n  - 第 $8$ 行：$(2,\\,8,\\,7,\\,4,\\,1,\\,9,\\,6,\\,3,\\,5)$\n  - 第 $9$ 行：$(3,\\,4,\\,5,\\,2,\\,8,\\,6,\\,1,\\,7,\\,9)$\n- 测试用例 C（因给定数矛盾而无解）：\n  - 第 $1$ 行：$(5,\\,5,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0)$\n  - 第 $2$ 行：$(0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0)$\n  - 第 $3$ 行：$(0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0)$\n  - 第 $4$ 行：$(0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0)$\n  - 第 $5$ 行：$(0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0)$\n  - 第 $6$ 行：$(0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0)$\n  - 第 $7$ 行：$(0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0)$\n  - 第 $8$ 行：$(0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0)$\n  - 第 $9$ 行：$(0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0,\\,0)$\n\n答案规范和输出格式：\n- 对每个测试用例，你的程序必须计算出以下之一：\n  - 如果存在解，则以行主序输出解出的网格，形式为一个包含 $81$ 个整数（每个都在 $\\{1,\\dots,9\\}$ 范围内）的扁平列表。\n  - 如果不存在解，则输出一个空列表。\n- 你的程序应生成单行输出，其中包含所有三个测试用例的结果，形式为用方括号括起来的逗号分隔列表。例如：“$[[\\dots],[\\dots],[]]$”。不应打印额外的空格或文本。\n\n约束和注意事项：\n- 你必须实现 Donald Knuth 的 X 算法与舞蹈链 (DLX)。不接受直接的约束传播或不使用 DLX 的朴素回溯。\n- 将给定的网格视为不可变的“给定数”；将 $0$ 解释为空单元格。\n- 该问题不涉及物理单位、角度单位或百分比。所有输出均为指定的无单位整数。",
            "solution": "用户希望通过将数独谜题归约为精确覆盖问题，并应用 Donald Knuth 的 X 算法（通过舞蹈链 (DLX) 技术实现）来解决它们。\n\n### 问题验证\n\n**步骤 1：提取给定信息**\n\n- **问题：** 使用 X 算法与舞蹈链 (DLX) 解决数独。\n- **核心概念（精确覆盖）：** 给定一个全集 $\\mathcal{U}$ 和一个子集族 $\\mathcal{S}$，找到一个子集族 $\\mathcal{C} \\subseteq \\mathcal{S}$，其中 $\\mathcal{U}$ 的每个元素恰好出现在 $\\mathcal{C}$ 的一个成员中。\n- **数独约束：** 对于一个 $9 \\times 9$ 的网格：\n    1. 每个单元格有一个 $\\{1, ..., 9\\}$ 中的数字。\n    2. 每一行恰好有一次 $\\{1, ..., 9\\}$ 中的每个数字。\n    3. 每一列恰好有一次 $\\{1, ..., 9\\}$ 中的每个数字。\n    4. 每个 $3 \\times 3$ 的宫格恰好有一次 $\\{1, ..., 9\\}$ 中的每个数字。\n- **实现要求：**\n    1.  将数独表述为一个具有 $729$ 行（选择）和 $324$ 列（约束）的精确覆盖问题。\n    2.  从头实现 DLX。\n    3.  通过限制候选选择来处理初始的非零数字（给定数）。\n- **测试用例：**\n    - 测试用例 A：一个标准的可解谜题。\n    - 测试用例 B：一个接近完成的谜题。\n    - 测试用例 C：一个因矛盾而无解的谜题。\n- **输出格式：**\n    - 对于可解的情况，输出一个表示已解出网格的、按行主序排列的 81 个整数的扁平列表。\n    - 对于无解的情况，输出一个空列表。\n    - 单行输出，例如 `[[...],[...],[]]`，包含所有结果。\n\n**步骤 2：使用提取的给定信息进行验证**\n\n- **科学基础：** 该问题牢固地植根于计算机科学，特别是在组合搜索算法领域。将数独归约为精确覆盖问题是一种经典且数学上合理的技巧。X 算法及其 DLX 实现是解决此类问题的标准方法。该问题遵循了算法学和离散数学的既定原则。\n- **良构性：** 问题定义清晰。输入是一组 $9 \\times 9$ 的网格。任务是为每个网格找到一个有效的数独解。有效解的条件已明确说明。对于可解和无解的情况，输出格式都已精确指定。每个测试用例都存在一个唯一且有意义的答案（一个解出的网格或一个无解的确认）。\n- **客观性：** 问题陈述使用精确、无歧义的语言编写。所有约束、数据和要求都是形式化和客观的。没有主观因素。\n\n**步骤 3：结论与行动**\n\n该问题是**有效的**。这是一个基于既定计算机科学原理的、定义明确的算法任务。以下解决方案提供了所需算法的原则性实现。\n\n### 解决方案设计\n\n该解决方案的架构核心是将数独归约为精确覆盖问题，然后使用自定义实现的、带有舞蹈链 (DLX) 的 X 算法来求解。\n\n**1. 将数独作为精确覆盖问题**\n\n核心思想是将数独的约束表示为精确覆盖问题的全集 $\\mathcal{U}$，并将可能的操作（在单元格中放置一个数字）表示为子集族 $\\mathcal{S}$。\n\n-   **约束全集 ($\\mathcal{U}$):** 324 条游戏规则是我们全集的元素，它们成为矩阵的列。\n    1.  **单元格占用：** 对于 81 个单元格中的每一个 $(r, c)$，其约束是必须恰好包含一个数字。这产生了 $9 \\times 9 = 81$ 列。列索引：$c_{1} = 9r + c$。\n    2.  **行-数字：** 对于 9 行和 9 个数字中的每一个，其约束是数字 $d$ 必须在行 $r$ 中恰好出现一次。这产生了 $9 \\times 9 = 81$ 列。列索引：$c_{2} = 81 + 9r + (d-1)$。\n    3.  **列-数字：** 对于 9 列和 9 个数字中的每一个，其约束是数字 $d$ 必须在列 $c$ 中恰好出现一次。这产生了 $9 \\times 9 = 81$ 列。列索引：$c_{3} = 162 + 9c + (d-1)$。\n    4.  **宫格-数字：** 对于 9 个宫格和 9 个数字中的每一个，其约束是数字 $d$ 必须在宫格 $b$ 中恰好出现一次。这产生了 $9 \\times 9 = 81$ 列。列索引：$c_{4} = 243 + 9b + (d-1)$，其中宫格索引 $b$ 计算为 $b = 3(r // 3) + (c // 3)$。\n\n-   **子集族 ($\\mathcal{S}$):** 候选操作是矩阵的行。单个“选择”是在单元格 $(r, c)$ 中放置一个数字 $d \\in \\{1,...,9\\}$。共有 $9 \\times 9 \\times 9 = 729$ 种这样的可能选择。\n    -   每个选择，例如在单元格 $(r,c)$ 中放置数字 $d$，恰好满足四个约束：一个单元格约束、一个行-数字约束、一个列-数字约束和一个宫格-数字约束。\n    -   因此，在我们的 $729 \\times 324$ 问题表示矩阵中，每一行都恰好包含四个 $1$。\n\n找到一个数独解等价于从这些选择（行）中找到一个包含 81 个选择的子集族，使得 324 个约束（列）中的每一个都恰好被一个选定的行所满足。这正是精确覆盖的定义。\n\n**2. X 算法与舞蹈链 (DLX)**\n\nX 算法是一种用于寻找精确覆盖的递归回溯算法。舞蹈链 (DLX) 是 Donald Knuth 提出的一种高效实现技巧，它使用一种特定的数据结构来表示稀疏矩阵。\n\n-   **数据结构：** 这个稀疏的 $729 \\times 324$ 矩阵使用一个环形双向链表来表示。\n    -   矩阵中的每个 $1$ 都成为一个 `Node` 对象。每个节点有四个指针：`L` (左)、`R` (右)、`U` (上)、`D` (下)。\n    -   矩阵同一行中的节点被水平链接成一个循环列表。\n    -   矩阵同一列中的节点被垂直链接成一个循环列表。\n    -   每一列都有一个特殊的 `Column` 头节点。这些头节点本身也被水平链接成一个循环列表，其中还包括一个主 `root` 节点。这个列表用于跟踪当前活动的约束。\n    -   每个 `Column` 头节点存储其列的 `size`（$1$ 的数量），这对于搜索启发式至关重要。\n\n-   **搜索算法 (`search`):**\n    1.  **基本情况：** 如果 `root` 节点的右邻居是它自己（即 `root.R == root`），则所有列都已被覆盖，已找到一个解。\n    2.  **列选择：** 选择一个要覆盖的列 `c`。使用 S-启发式（最短列）：选择 `size` 最小的列。这能有效地修剪搜索树。\n    3.  **覆盖操作 (`cover(c)`):** 这是 DLX 效率的核心。要覆盖列 `c`：\n        -   将它从列头节点的水平列表中移除链接。\n        -   对于在列 `c` 中有节点的每一行 `i`，通过将其*其他*节点从它们各自的列中移除链接，将这一整行“移出”考虑范围。这是通过修改其垂直邻居的 `U` 和 `D` 指针来完成的。\n    4.  **递归与回溯：**\n        -   遍历刚刚被 `cover(c)` “移除”的每一行 `r`。\n        -   对于每个 `r`，暂时将其添加到解中。\n        -   对于行 `r` 中的每个节点 `j`（`c` 中的那个除外），覆盖其所在的列 `j.col`。\n        -   递归调用 `search`。如果它返回 `True`，则找到了一个解；将 `True` 沿调用栈向上传播。\n        -   如果递归调用失败，则进行回溯。取消选择行 `r`，并通过以与 `cover` 操作相反的顺序执行 `uncover` 操作，将矩阵恢复到其先前的状态。\n    5.  **恢复操作 (`uncover(c)`):** 此操作通过重新链接所有节点和头节点来完美地逆转 `cover(c)`，从而恢复矩阵结构。\n\n**3. 处理给定数和矛盾**\n\n初始谜题状态（“给定数”）通过预处理 DLX 结构来处理。\n\n-   对于单元格 $(r, c)$ 中的每个给定数字 $d$，我们被迫做出该选择。\n-   识别出对应于选择 $(r,c,d)$ 的矩阵行。该行从一开始就被有效地“选定”为解的一部分。\n-   选择此行意味着它满足的所有约束都必须被满足。这是通过迭代此行的节点并对它们各自的列调用 `cover` 操作来实现的。\n-   如果给定数是矛盾的（例如，在同一行中有两个 5，如测试用例 C 所示），这个过程将会失败。例如，处理第一个 `5` 将覆盖“第 1 行中的 5”的 `row-digit` 约束。当处理第二个 `5` 时，其在矩阵中对应的行已经被前一个 `cover` 操作消除了。程序会检测到这种不可能性，并在不启动搜索的情况下将谜题标记为无解。\n\n这种原则性的设计将抽象的数独谜题转化为具体的数学结构，并使用一种高效的专用算法来解决它。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass SudokuDLXSolver:\n    \"\"\"\n    Solves a Sudoku puzzle by reducing it to an exact cover problem\n    and applying Donald Knuth's Algorithm X with Dancing Links (DLX).\n    \"\"\"\n\n    class Node:\n        \"\"\"A node in the DLX matrix, representing a '1'.\"\"\"\n        def __init__(self, col_header=None, row_idx=-1):\n            self.L = self.R = self.U = self.D = self\n            self.col = col_header\n            self.row_idx = row_idx\n\n    class Column(Node):\n        \"\"\"A column header in the DLX matrix, representing a constraint.\"\"\"\n        def __init__(self, name=\"\"):\n            super().__init__(self)\n            self.size = 0\n            self.name = name\n\n    def __init__(self, grid):\n        \"\"\"Initializes the solver and builds the DLX structure for the given grid.\"\"\"\n        self.grid = grid\n        self.N = 9\n        self.N2 = self.N * self.N\n        self.num_cols = 4 * self.N2  # 324 constraints\n        \n        self.solution_indices = []\n        self.solution_grid = None\n        self._build_dlx_structure()\n        self.is_solvable = self._handle_givens()\n\n    def _get_row_data_from_idx(self, row_idx):\n        \"\"\"Converts a matrix row index back to (row, col, digit) of the Sudoku.\"\"\"\n        val = row_idx\n        digit = (val % self.N) + 1\n        val //= self.N\n        col = val % self.N\n        val //= self.N\n        row = val\n        return row, col, digit\n\n    def _build_dlx_structure(self):\n        \"\"\"Constructs the toroidal doubly-linked list for the Sudoku exact cover matrix.\"\"\"\n        self.root = self.Column(\"root\")\n        self.columns = [self.Column(str(i)) for i in range(self.num_cols)]\n\n        self.root.R = self.columns[0]\n        self.columns[0].L = self.root\n        self.columns[-1].R = self.root\n        self.root.L = self.columns[-1]\n\n        for i in range(self.num_cols - 1):\n            self.columns[i].R = self.columns[i+1]\n            self.columns[i+1].L = self.columns[i]\n\n        for r in range(self.N):\n            for c in range(self.N):\n                for d_idx, d in enumerate(range(1, self.N + 1)):\n                    row_idx = r * self.N2 + c * self.N + d_idx\n                    box = (r // 3) * 3 + (c // 3)\n                    \n                    cols_to_cover = [\n                        r * self.N + c,                      # Cell (r,c) constraint\n                        self.N2 + r * self.N + d_idx,        # Row-Digit (r,d) constraint\n                        2 * self.N2 + c * self.N + d_idx,    # Col-Digit (c,d) constraint\n                        3 * self.N2 + box * self.N + d_idx,  # Box-Digit (b,d) constraint\n                    ]\n                    \n                    first_node = None\n                    prev_node = None\n                    for col_idx in cols_to_cover:\n                        col_header = self.columns[col_idx]\n                        new_node = self.Node(col_header, row_idx)\n\n                        new_node.U = col_header.U\n                        new_node.D = col_header\n                        col_header.U.D = new_node\n                        col_header.U = new_node\n                        col_header.size += 1\n\n                        if first_node is None:\n                            first_node = new_node\n                        if prev_node is not None:\n                            new_node.L = prev_node\n                            prev_node.R = new_node\n                        prev_node = new_node\n                    \n                    first_node.L = prev_node\n                    prev_node.R = first_node\n\n    def _handle_givens(self):\n        \"\"\"\n        Pre-processes the matrix by selecting rows corresponding to the givens.\n        Returns False if a contradiction is found in the givens.\n        \"\"\"\n        for r_idx in range(self.N):\n            for c_idx in range(self.N):\n                digit = self.grid[r_idx, c_idx]\n                if digit != 0:\n                    d_idx = digit - 1\n                    row_idx = r_idx * self.N2 + c_idx * self.N + d_idx\n                    \n                    found_row_node = None\n                    # Search for any node in the required row. We start from the cell constraint column.\n                    cell_col_idx = r_idx * self.N + c_idx\n                    p = self.columns[cell_col_idx].D\n                    while p != self.columns[cell_col_idx]:\n                        if p.row_idx == row_idx:\n                            found_row_node = p\n                            break\n                        p = p.D\n                    \n                    if found_row_node is None:\n                        return False # Contradiction in givens\n\n                    # Select this row: cover all columns it belongs to\n                    self.solution_indices.append(found_row_node.row_idx)\n                    self.cover(found_row_node.col)\n                    q = found_row_node.R\n                    while q != found_row_node:\n                        self.cover(q.col)\n                        q = q.R\n        return True\n\n    def cover(self, c):\n        \"\"\"Covers a column and all intersecting rows.\"\"\"\n        c.R.L = c.L\n        c.L.R = c.R\n        i = c.D\n        while i != c:\n            j = i.R\n            while j != i:\n                j.D.U = j.U\n                j.U.D = j.D\n                j.col.size -= 1\n                j = j.R\n            i = i.D\n\n    def uncover(self, c):\n        \"\"\"Uncovers a column, reversing a cover operation.\"\"\"\n        i = c.U\n        while i != c:\n            j = i.L\n            while j != i:\n                j.col.size += 1\n                j.D.U = j\n                j.U.D = j\n                j = j.L\n            i = i.U\n        c.R.L = c\n        c.L.R = c\n\n    def _search(self):\n        \"\"\"The recursive backtracking search of Algorithm X.\"\"\"\n        if self.root.R == self.root:\n            self._reconstruct_solution()\n            return True\n\n        # S-heuristic: choose column with the smallest size.\n        c = None\n        min_size = float('inf')\n        j = self.root.R\n        while j != self.root:\n            if j.size  min_size:\n                min_size = j.size\n                c = j\n            j = j.R\n\n        if c is None or c.size == 0:\n            return False\n\n        self.cover(c)\n\n        r_node = c.D\n        while r_node != c:\n            self.solution_indices.append(r_node.row_idx)\n            j_node = r_node.R\n            while j_node != r_node:\n                self.cover(j_node.col)\n                j_node = j_node.R\n\n            if self._search():\n                return True\n\n            self.solution_indices.pop()\n            j_node = r_node.L\n            while j_node != r_node:\n                self.uncover(j_node.col)\n                j_node = j_node.L\n            \n            r_node = r_node.D\n        \n        self.uncover(c)\n        return False\n\n    def _reconstruct_solution(self):\n        \"\"\"Builds the final 9x9 grid from the solution row indices.\"\"\"\n        solved_grid = np.zeros((self.N, self.N), dtype=int)\n        for row_idx in self.solution_indices:\n            r, c, d = self._get_row_data_from_idx(row_idx)\n            solved_grid[r, c] = d\n        self.solution_grid = solved_grid.flatten().tolist()\n\n    def solve(self):\n        \"\"\"Runs the solver and returns the solution.\"\"\"\n        if not self.is_solvable:\n            return []\n        if self._search():\n            return self.solution_grid\n        else:\n            return []\n\ndef solve():\n    test_cases = [\n        # Test Case A (General solvable)\n        np.array([\n            [5, 3, 0, 0, 7, 0, 0, 0, 0],\n            [6, 0, 0, 1, 9, 5, 0, 0, 0],\n            [0, 9, 8, 0, 0, 0, 0, 6, 0],\n            [8, 0, 0, 0, 6, 0, 0, 0, 3],\n            [4, 0, 0, 8, 0, 3, 0, 0, 1],\n            [7, 0, 0, 0, 2, 0, 0, 0, 6],\n            [0, 6, 0, 0, 0, 0, 2, 8, 0],\n            [0, 0, 0, 4, 1, 9, 0, 0, 5],\n            [0, 0, 0, 0, 8, 0, 0, 7, 9]\n        ]),\n        # Test Case B (Nearly complete)\n        np.array([\n            [0, 3, 4, 6, 7, 8, 9, 1, 2],\n            [6, 7, 2, 1, 9, 5, 3, 4, 8],\n            [1, 9, 8, 3, 4, 2, 5, 6, 7],\n            [8, 5, 9, 7, 6, 1, 4, 2, 3],\n            [4, 2, 6, 8, 5, 3, 7, 9, 1],\n            [7, 1, 3, 9, 2, 4, 8, 5, 6],\n            [9, 6, 1, 5, 3, 7, 2, 8, 4],\n            [2, 8, 7, 4, 1, 9, 6, 3, 5],\n            [3, 4, 5, 2, 8, 6, 1, 7, 9]\n        ]),\n        # Test Case C (Unsolvable)\n        np.array([\n            [5, 5, 0, 0, 0, 0, 0, 0, 0],\n            [0, 0, 0, 0, 0, 0, 0, 0, 0],\n            [0, 0, 0, 0, 0, 0, 0, 0, 0],\n            [0, 0, 0, 0, 0, 0, 0, 0, 0],\n            [0, 0, 0, 0, 0, 0, 0, 0, 0],\n            [0, 0, 0, 0, 0, 0, 0, 0, 0],\n            [0, 0, 0, 0, 0, 0, 0, 0, 0],\n            [0, 0, 0, 0, 0, 0, 0, 0, 0],\n            [0, 0, 0, 0, 0, 0, 0, 0, 0]\n        ])\n    ]\n\n    results = []\n    for grid in test_cases:\n        solver = SudokuDLXSolver(grid)\n        result = solver.solve()\n        results.append(result)\n\n    # Format the final output string exactly as specified.\n    # [ [1,2,3], [], [4,5,6] ] -> \"[[1,2,3],[],[4,5,6]]\"\n    result_strings = []\n    for r in results:\n        if r:\n            result_strings.append(f\"[{','.join(map(str, r))}]\")\n        else:\n            result_strings.append(\"[]\")\n    \n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```"
        }
    ]
}