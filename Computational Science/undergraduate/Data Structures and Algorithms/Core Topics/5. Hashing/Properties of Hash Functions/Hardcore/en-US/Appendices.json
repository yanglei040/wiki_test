{
    "hands_on_practices": [
        {
            "introduction": "A fundamental property of any hash function is that it maps a large domain of inputs to a smaller range of outputs, making collisions inevitable. This exercise invites you to explore this many-to-one nature by calculating the size of a hash function's \"preimage set\"—that is, counting how many different input pairs map to a single target value. By using the principles of modular arithmetic instead of brute force, you will develop a critical skill for analyzing the collision properties and structural behavior of any hash function. ",
            "id": "3261635",
            "problem": "Consider the hash function $h: \\mathbb{Z} \\times \\mathbb{Z} \\to \\{0,1,\\dots,m-1\\}$ defined by $h(x,y) = (x^2 + y) \\bmod m$, where $m$ is a given positive integer. For a fixed target hash value $v \\in \\{0,1,\\dots,m-1\\}$, the preimage set consists of all integer pairs $(x,y)$ such that $x \\in [X_{\\min}, X_{\\max}]$, $y \\in [Y_{\\min}, Y_{\\max}]$, and $x^2 + y \\equiv v \\pmod{m}$. Starting only from the formal definitions of a hash function, congruence modulo $m$, and integer intervals, derive a principled method to determine how many such pairs exist for any valid parameter set. Your program must compute, for each provided test case, the total number of pairs $(x,y)$ in the specified ranges that map to $v$ under $h$.\n\nAll quantities are integers. Assume $m \\geq 1$ and that $X_{\\min} \\leq X_{\\max}$ and $Y_{\\min} \\leq Y_{\\max}$. Your program must not enumerate all pairs explicitly unless the derivation justifies it; it must be based on logic derived from core definitions and properties of modular arithmetic. The required outputs are integers representing the counts of such pairs for each test case.\n\nTest Suite:\n- Case $1$: $m = 7$, $v = 3$, $X_{\\min} = 0$, $X_{\\max} = 20$, $Y_{\\min} = 0$, $Y_{\\max} = 30$.\n- Case $2$: $m = 1$, $v = 0$, $X_{\\min} = -5$, $X_{\\max} = 5$, $Y_{\\min} = -5$, $Y_{\\max} = 5$.\n- Case $3$: $m = 13$, $v = 0$, $X_{\\min} = 0$, $X_{\\max} = 100$, $Y_{\\min} = 0$, $Y_{\\max} = 100$.\n- Case $4$: $m = 9$, $v = 4$, $X_{\\min} = -20$, $X_{\\max} = -1$, $Y_{\\min} = -30$, $Y_{\\max} = -10$.\n- Case $5$: $m = 8$, $v = 7$, $X_{\\min} = 0$, $X_{\\max} = 50$, $Y_{\\min} = 3$, $Y_{\\max} = 3$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results, in the order of the cases above, as a comma-separated list enclosed in square brackets. For example, if the results for the five cases were $a_1, a_2, a_3, a_4, a_5$, the output must be exactly in the form $[a_1,a_2,a_3,a_4,a_5]$.",
            "solution": "The problem is well-defined, mathematically sound, and self-contained. It is based on established principles of number theory, specifically modular arithmetic, and computer science concepts related to hash functions. All provided parameters are clearly defined, and the constraints are consistent. Therefore, the problem is deemed valid and a formal solution can be derived.\n\nThe objective is to find the number of integer pairs $(x,y)$ that satisfy the following three conditions for given integers $m, v, X_{\\min}, X_{\\max}, Y_{\\min}, Y_{\\max}$:\n1.  $x \\in [X_{\\min}, X_{\\max}]$\n2.  $y \\in [Y_{\\min}, Y_{\\max}]$\n3.  $h(x,y) = (x^2 + y) \\bmod m = v$\n\nThe third condition can be expressed using the definition of congruence modulo $m$:\n$$x^2 + y \\equiv v \\pmod{m}$$\nThis congruence can be rearranged to isolate the variable $y$:\n$$y \\equiv v - x^2 \\pmod{m}$$\nA naive approach would be to iterate through all possible pairs $(x,y)$ in the specified rectangular domain and check if the congruence holds. However, this is computationally expensive if the ranges for $x$ and $y$ are large. The problem statement itself suggests that a more principled method based on modular arithmetic is required.\n\nA more efficient strategy is to iterate through the values of one variable, say $x$, and for each $x$, calculate the number of valid $y$ values. A crucial observation is that the condition on $y$ depends on $x$ only through the value of $x^2 \\pmod{m}$.\n\nLet $x_1$ and $x_2$ be two integers such that $x_1 \\equiv x_2 \\pmod{m}$. Then $x_1^2 \\equiv x_2^2 \\pmod{m}$. Consequently, the congruence for $y$ becomes identical for both $x_1$ and $x_2$:\n$$y \\equiv v - x_1^2 \\pmod{m} \\implies y \\equiv v - x_2^2 \\pmod{m}$$\nThis insight allows us to group all integers $x$ in the range $[X_{\\min}, X_{\\max}]$ by their residue class modulo $m$. For any $x$ belonging to a given residue class $r \\in \\{0, 1, \\dots, m-1\\}$, where $x \\equiv r \\pmod{m}$, the required residue for $y$ is the same. Let this required residue for $y$ be $c_r$:\n$$c_r = (v - r^2) \\pmod{m}$$\nThe problem is now reduced to two main steps:\n1.  For each residue class $r \\in \\{0, 1, \\dots, m-1\\}$, determine the number of integers $y$ in the interval $[Y_{\\min}, Y_{\\max}]$ that satisfy $y \\equiv c_r \\pmod{m}$.\n2.  For each residue class $r$, determine the number of integers $x$ in the interval $[X_{\\min}, X_{\\max}]$ that satisfy $x \\equiv r \\pmod{m}$.\n\nThe total number of pairs is the sum, over all residue classes $r$, of the product of these two counts.\nLet's formalize the counting method. We need a function to count the number of integers in an interval $[A, B]$ that are congruent to $c \\pmod{m}$. An integer $z$ satisfies $z \\equiv c \\pmod{m}$ if and only if $z-c$ is a multiple of $m$. Thus, we need to count the number of multiples of $m$ in the interval $[A-c, B-c]$. The number of multiples of $m$ in an interval $[L, R]$ can be calculated as $\\lfloor R/m \\rfloor - \\lfloor (L-1)/m \\rfloor$. This formula is robust for both positive and negative integers when using floor division.\n\nApplying this to our problem:\nLet $N_y(c_r)$ be the number of valid $y$ values for a required residue $c_r$. This corresponds to counting integers congruent to $c_r \\pmod{m}$ in the interval $[Y_{\\min}, Y_{\\max}]$.\n$$N_y(c_r) = \\left\\lfloor \\frac{Y_{\\max} - c_r}{m} \\right\\rfloor - \\left\\lfloor \\frac{Y_{\\min} - c_r - 1}{m} \\right\\rfloor$$\nLet $N_x(r)$ be the number of $x$ values in $[X_{\\min}, X_{\\max}]$ that are congruent to $r \\pmod{m}$.\n$$N_x(r) = \\left\\lfloor \\frac{X_{\\max} - r}{m} \\right\\rfloor - \\left\\lfloor \\frac{X_{\\min} - r - 1}{m} \\right\\rfloor$$\n\nThe overall algorithm proceeds as follows:\n1.  Initialize total count to $0$.\n2.  Loop through each possible residue class for $x$, i.e., for $r$ from $0$ to $m-1$.\n3.  For each $r$, calculate the required residue for $y$: $c_r = (v - r^2) \\pmod{m}$.\n4.  Calculate $N_y(c_r)$, the number of $y$ values in $[Y_{\\min}, Y_{\\max}]$ that are congruent to $c_r \\pmod{m}$.\n5.  If $N_y(c_r) > 0$, calculate $N_x(r)$, the number of $x$ values in $[X_{\\min}, X_{\\max}]$ that are congruent to $r \\pmod{m}$.\n6.  Add the product $N_x(r) \\times N_y(c_r)$ to the total count.\n7.  After iterating through all $r$, the total count is the final answer.\n\nThis algorithm has a time complexity of $O(m)$, which is highly efficient and independent of the size of the ranges for $x$ and $y$.\n\nA special case occurs when $m=1$. In this case, any integer is congruent to $0 \\pmod 1$. The condition $x^2 + y \\equiv v \\pmod 1$ is always satisfied (as $v$ must be $0$). The problem reduces to counting the total number of pairs in the rectangle, which is $(X_{\\max} - X_{\\min} + 1) \\times (Y_{\\max} - Y_{\\min} + 1)$. The general algorithm correctly handles this case as well.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_case(m, v, x_min, x_max, y_min, y_max):\n    \"\"\"\n    Calculates the number of integer pairs (x,y) in the given ranges satisfying\n    (x^2 + y) mod m = v, based on principles of modular arithmetic.\n    \"\"\"\n    # The condition is y === v - x^2 (mod m).\n    # The required remainder for y depends only on r_x = x mod m.\n    # The overall strategy is to iterate through each residue class r_x from 0 to m-1,\n    # calculate the number of valid y's for that class, calculate the number of\n    # x's belonging to that class, and sum up the products.\n\n    # This is a general function to count integers in [lower, upper]\n    # that are congruent to `rem` modulo `mod`.\n    # Based on the formula: count = floor( (upper-rem)/mod ) - floor( (lower-rem-1)/mod )\n    # This is equivalent to counting multiples of `mod` in the range [lower-rem, upper-rem].\n    def count_congruent(lower, upper, mod, rem):\n        u_bound = upper - rem\n        l_bound = lower - rem\n        return (u_bound // mod) - ((l_bound - 1) // mod)\n\n    # Special case for m=1. Any integer is congruent to 0 mod 1.\n    # Since v must be 0, the condition is always met.\n    if m == 1:\n        num_x = x_max - x_min + 1\n        num_y = y_max - y_min + 1\n        return num_x * num_y\n\n    # Step 1: Pre-calculate the number of valid y's for each possible residue class of x.\n    # Let r_x = x mod m. The required residue for y is c_r = (v - r_x^2) mod m.\n    y_counts_per_residue = [0] * m\n    for r_x in range(m):\n        c_r = (v - r_x**2) % m\n        y_counts_per_residue[r_x] = count_congruent(y_min, y_max, m, c_r)\n\n    # Step 2: Sum up contributions for each residue class.\n    total_pairs = 0\n    for r_x in range(m):\n        # Optimization: if no y values work for this residue, skip calculation for x.\n        if y_counts_per_residue[r_x] == 0:\n            continue\n\n        # Count how many x's in [x_min, x_max] belong to residue class r_x.\n        num_x = count_congruent(x_min, x_max, m, r_x)\n        \n        # Add the product to the total.\n        total_pairs += num_x * y_counts_per_residue[r_x]\n            \n    return total_pairs\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # m, v, X_min, X_max, Y_min, Y_max\n        (7, 3, 0, 20, 0, 30),\n        (1, 0, -5, 5, -5, 5),\n        (13, 0, 0, 100, 0, 100),\n        (9, 4, -20, -1, -30, -10),\n        (8, 7, 0, 50, 3, 3),\n    ]\n\n    results = []\n    for case in test_cases:\n        m, v, x_min, x_max, y_min, y_max = case\n        result = solve_case(m, v, x_min, x_max, y_min, y_max)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Building on the concept of collisions, we now examine how they are managed in a classic implementation: a hash table with separate chaining. The efficiency of this data structure hinges on how evenly keys are distributed across the available buckets. This practice challenges you to analyze the performance when hashing a non-uniform set of keys—the sequence of perfect squares—and to determine exactly when a collision chain will grow to a specific length.  This provides a concrete model for understanding how key distribution and the choice of modulus directly impact the real-world performance of hash tables.",
            "id": "3261674",
            "problem": "Consider a hash table with chaining where the hash function is defined by $h(k) = k \\bmod m$, and the keys are the set of squares $K_N = \\{1^2, 2^2, \\dots, N^2\\}$. For a given modulus $m \\in \\mathbb{Z}_{>0}$ and a target collision-chain length $L \\in \\mathbb{Z}_{>0}$, define the bucket occupancy function $c_j(N) = \\left|\\left\\{i \\in \\{1,2,\\dots,N\\} \\,\\mid\\, i^2 \\equiv j \\pmod{m}\\right\\}\\right|$ for each bucket index $j \\in \\{0,1,\\dots,m-1\\}$. A collision chain of length at least $L$ occurs at size $N$ if there exists $j$ such that $c_j(N) \\ge L$. The task is to determine, for each test case, the smallest integer $N$ such that the set $K_N$ produces a collision chain of length at least $L$ under $h(k) = k \\bmod m$.\n\nStart from the following fundamental bases:\n- The definition of hashing, modular arithmetic, and congruence: for integers $a,b,m$ with $m > 0$, $a \\equiv b \\pmod{m}$ if and only if $m$ divides $a-b$, and congruence classes partition $\\mathbb{Z}$.\n- The properties of squaring modulo $m$: for an odd prime $p$, every nonzero quadratic residue modulo $p$ has exactly two square roots modulo $p$, namely $x$ and $p-x$. For composite moduli, the number of solutions to $x^2 \\equiv r \\pmod{m}$ can exceed two, structured by the Chinese Remainder Theorem across prime powers.\n- The Pigeonhole Principle applied to buckets and residues.\n\nYour program must compute the minimal $N$ for each of the following test cases, which probe a range of behaviors (odd primes, small primes, composite moduli, and degenerate moduli). The test suite is:\n- $(m,L) = (37, 4)$\n- $(m,L) = (31, 4)$\n- $(m,L) = (7, 4)$\n- $(m,L) = (36, 4)$\n- $(m,L) = (2, 4)$\n- $(m,L) = (1, 4)$\n\nAll answers should be integers. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the same order as the test suite, for example $[n_1,n_2,\\dots,n_6]$.",
            "solution": "The problem requires the determination of the smallest integer $N$ for which the set of keys $K_N = \\{1^2, 2^2, \\dots, N^2\\}$ generates a collision chain of length at least $L$ in a hash table of size $m$. The hash function is $h(k) = k \\pmod m$. This is equivalent to finding the minimum $N$ such that there exists a bucket index $j \\in \\{0, 1, \\dots, m-1\\}$ for which its occupancy, $c_j(N) = \\left|\\left\\{i \\in \\{1,2,\\dots,N\\} \\,\\mid\\, i^2 \\equiv j \\pmod{m}\\right\\}\\right|$, satisfies $c_j(N) \\ge L$.\n\nThe analysis begins with an examination of the sequence of residues $a_i = i^2 \\pmod m$ for $i = 1, 2, 3, \\dots$. This sequence is periodic. The fundamental reason for this periodicity is the property of modular arithmetic that for any integer $i$ and any integer-multiple of the modulus $k \\cdot m$, we have $(i + k \\cdot m) \\equiv i \\pmod m$. Squaring both sides yields $(i + k \\cdot m)^2 \\equiv i^2 \\pmod m$. Specifically, choosing $k=1$, we see that $(i+m)^2 \\equiv i^2 \\pmod m$. This implies that the sequence of residues of squares, $\\{i^2 \\pmod m\\}_{i=1}^{\\infty}$, is periodic with a period that divides $m$. In fact, the sequence of residues generated by $i \\in \\{km+1, \\dots, (k+1)m\\}$ is identical to that generated by $i \\in \\{1, \\dots, m\\}$. The period is precisely $m$.\n\nThis periodicity allows us to characterize the distribution of keys into buckets by analyzing a single period of length $m$. For each bucket $j \\in \\{0, 1, \\dots, m-1\\}$, let us define the set of indices within the first period, $[1, m]$, that map to it:\n$$ I_j = \\{ i \\in \\{1, 2, \\dots, m\\} \\mid i^2 \\equiv j \\pmod m \\} $$\nLet $s_j = |I_j|$ be the number of such indices. These sets $I_j$ can be computed by iterating $i$ from $1$ to $m$ and recording the value of $i$ in the list corresponding to the bucket $j = i^2 \\pmod m$. If $s_j=0$ for a given $j$, no key ever hashes to bucket $j$, so it cannot contribute to a solution. We only consider buckets where $s_j > 0$.\n\nFor a bucket $j$ with $s_j > 0$, we need to find the smallest $N$ such that $c_j(N) \\ge L$. The integers $i$ for which $i^2 \\equiv j \\pmod m$ are precisely the elements of the set $\\{q \\cdot m + r \\mid q \\in \\mathbb{Z}_{\\ge 0}, r \\in I_j \\}$. To satisfy $c_j(N) \\ge L$, the value of $N$ must be at least as large as the $L$-th smallest integer in this set.\n\nLet the elements of $I_j$, sorted in increasing order, be $i_{j,1}, i_{j,2}, \\dots, i_{j,s_j}$. The complete sequence of positive integers $x$ such that $x^2 \\equiv j \\pmod m$, also in increasing order, is:\n$$ i_{j,1}, i_{j,2}, \\dots, i_{j,s_j}, \\quad (m+i_{j,1}), (m+i_{j,2}), \\dots, (m+i_{j,s_j}), \\quad (2m+i_{j,1}), \\dots $$\nThe $L$-th term in this sequence is the minimum $N$ required for bucket $j$ to achieve a count of $L$. Let this value be $N_j$. To find it, we express $L-1$ in terms of $s_j$ using the division algorithm: $L-1 = q \\cdot s_j + r$, where $q = \\lfloor (L-1)/s_j \\rfloor$ and $r = (L-1) \\pmod{s_j}$. This means that to find the $L$-th term, we must exhaust $q$ full blocks of $s_j$ indices and then pick the $(r+1)$-th index from the next block. The $q$ full blocks are generated by integers up to $q \\cdot m$. The $(r+1)$-th index in the subsequent block corresponds to $i_{j, r+1}$ (or $I_j[r]$ if using 0-based indexing for the sorted list). The value of this $L$-th index is therefore $q \\cdot m + i_{j,r+1}$.\nThus, the minimal $N$ for a specific bucket $j$ is:\n$$ N_j = \\left\\lfloor \\frac{L-1}{s_j} \\right\\rfloor \\cdot m + I_j\\left[ (L-1) \\pmod{s_j} \\right] $$\nwhere $I_j[\\cdot]$ denotes array access into the sorted, 0-indexed list of indices for bucket $j$.\n\nThe problem asks for the overall minimal $N$ that satisfies the condition for *any* bucket. This is the minimum of the individual minimal $N_j$ values over all buckets that can receive keys.\n$$ N_{\\text{min}} = \\min_{j \\in \\{0, \\dots, m-1\\} \\text{ s.t. } s_j>0} \\{N_j\\} $$\n\nThis analytical approach leads to the following algorithm:\n1.  For a given $(m, L)$, handle the trivial case $m=1$. Here, every key hashes to bucket $0$. Thus $c_0(N) = N$, and the condition $N \\ge L$ yields the minimal solution $N=L$.\n2.  For $m > 1$, create a collection of lists, one for each bucket $j \\in \\{0, \\dots, m-1\\}$.\n3.  Populate these lists by iterating $i$ from $1$ to $m$. For each $i$, compute $j = i^2 \\pmod m$ and add $i$ to the list for bucket $j$.\n4.  Initialize a variable `min_N` to a value representing infinity.\n5.  Iterate through each bucket $j=0, \\dots, m-1$. If the list of indices $I_j$ for bucket $j$ is not empty (i.e., $s_j > 0$), calculate the corresponding $N_j$ using the formula derived above. Update `min_N = min(min_N, N_j)`.\n6.  The final result is the computed value of `min_N`.\n\nThis algorithm is both correct and efficient for the specified problem constraints.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for all test cases and prints the results\n    in the required format.\n    \"\"\"\n\n    def solve_case(m, L):\n        \"\"\"\n        Computes the smallest integer N such that the set {1^2, ..., N^2}\n        produces a collision chain of length at least L under h(k) = k mod m.\n\n        Args:\n            m (int): The modulus for the hash function.\n            L (int): The target collision-chain length.\n\n        Returns:\n            int: The smallest integer N satisfying the condition.\n        \"\"\"\n        if m == 1:\n            # For m=1, h(k) is always 0. All keys go to bucket 0.\n            # The count of keys in bucket 0 is N.\n            # We need N >= L, so the smallest N is L.\n            return L\n\n        # Step 1: Pre-compute the indices within one period [1, m] for each bucket.\n        # indices_by_bucket[j] will store a sorted list of indices i in {1, ..., m}\n        # such that i^2 = j (mod m).\n        indices_by_bucket = [[] for _ in range(m)]\n        for i in range(1, m + 1):\n            bucket_index = (i * i) % m\n            indices_by_bucket[bucket_index].append(i)\n\n        # Step 2: For each bucket, calculate the smallest N to reach L collisions\n        # in that bucket. The overall answer is the minimum of these N's.\n        min_N = float('inf')\n\n        for j in range(m):\n            I_j = indices_by_bucket[j]\n            s_j = len(I_j)\n\n            if s_j > 0:\n                # We need to find the L-th smallest integer i such that i^2 = j (mod m).\n                # To find the L-th term, we can use integer division.\n                # L-1 = q * s_j + r, where q is number of full cycles of s_j terms.\n                q = (L - 1) // s_j\n                # r is the 0-indexed position in the next cycle.\n                r = (L - 1) % s_j\n\n                # The value of the L-th index is formed by q full periods of size m,\n                # plus the r-th index from the initial set I_j.\n                N_j = q * m + I_j[r]\n                \n                if N_j < min_N:\n                    min_N = N_j\n        \n        return int(min_N)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (37, 4),\n        (31, 4),\n        (7, 4),\n        (36, 4),\n        (2, 4),\n        (1, 4),\n    ]\n\n    results = []\n    for m, L in test_cases:\n        result = solve_case(m, L)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "We now turn our attention to another essential collision resolution strategy: open addressing with quadratic probing. The performance of this method is deeply connected to number theory, which guarantees that the probe sequence will visit a certain number of distinct slots, especially when the table size $M$ is a prime number. This advanced practice pushes you to reverse-engineer the probing mechanism; by constructing a specific sequence of keys that deliberately causes a maximal number of probes, you will gain a profound understanding of the theoretical guarantees and practical limitations of quadratic probing. ",
            "id": "3261658",
            "problem": "You are given an initially empty open-addressed hash table of size $M$ with the following properties. The base hash function is $h_0(k) = k \\bmod M$. Open addressing (OA) is performed by quadratic probing (QP) with the probe function $h(k,i) = \\left(h_0(k) + i^2\\right) \\bmod M$ for successive probe indices $i = 0, 1, 2, \\dots$. Assume $M$ is an odd prime and the hash table stores integers without deletions, with an insertion procedure that probes until it finds the first empty slot and places the key there.\n\nStarting from the foundational definitions above, design a sequence of integer keys $\\{k_j\\}$ to be inserted into the empty table such that the insertion of the final key in your sequence causes the probing process to examine exactly $\\frac{M+1}{2}$ distinct slots in total (counting both unsuccessful probes that find occupied slots and the final successful probe that finds an empty slot) before placing the key. Your construction must be justified by first principles of modular arithmetic and hash function behavior, not by ad hoc prescriptions.\n\nYour program must:\n- For each specified value of $M$, construct such a sequence of keys, insert them into the hash table using quadratic probing as defined, and record the total number of distinct probes performed during the insertion of the final key (including the successful probe that finds an empty slot).\n- Simulate the hash table faithfully according to the definitions provided, ensuring that each probe checks the slot index $h(k,i)$ in increasing order of $i$ starting from $i=0$, stopping on the first empty slot found and placing the key there.\n- Use only integers; there are no physical units involved.\n- Produce the final output aggregating the results for all provided test cases into a single line as a comma-separated list enclosed in square brackets, for example, $[r_1,r_2,r_3]$ where each $r_j$ is the integer probe count for the corresponding test case.\n\nTest suite:\n- Case 1: $M = 3$ (boundary prime).\n- Case 2: $M = 7$ (small prime).\n- Case 3: $M = 11$ (moderate prime).\n- Case 4: $M = 17$ (larger prime).\n- Case 5: $M = 101$ (significantly larger prime).\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,r_3,r_4,r_5]$), where each $r_j$ is the total number of probes (including the successful one) performed during the insertion of the final key for the corresponding $M$ in the test suite. The solution must be universally applicable in purely mathematical and logical terms to any modern programming language, but your final answer must be provided as runnable Python code as specified.",
            "solution": "The user's request is to design a sequence of integer keys $\\{k_j\\}$ to be inserted into an initially empty open-addressed hash table of size $M$. The insertion of the final key must result in exactly $\\frac{M+1}{2}$ distinct probe attempts. The hash table uses quadratic probing with the function $h(k,i) = (h_0(k) + i^2) \\bmod M$, where $h_0(k) = k \\bmod M$ and $M$ is an odd prime.\n\n**1. Analysis of Quadratic Probing with Prime Modulus**\n\nThe core of this problem lies in the number-theoretic properties of quadratic probing when the table size $M$ is a prime number. The sequence of indices probed for a key $k$ is given by $(h_0(k) + i^2) \\pmod M$ for $i = 0, 1, 2, \\dots$. The number of distinct slots visited depends on the number of distinct values of $i^2 \\pmod M$.\n\nLet's analyze the set of quadratic residues modulo a prime $M$, $S = \\{i^2 \\pmod M \\mid i \\in \\{0, 1, \\dots, M-1\\}\\}$.\n- For $i=0$, we have $0^2 \\equiv 0 \\pmod M$.\n- For any $i \\in \\{1, \\dots, M-1\\}$, if we have two probe indices $i$ and $j$ such that $0 \\le i < j < M$ and $i^2 \\equiv j^2 \\pmod M$, this implies $j^2 - i^2 \\equiv 0 \\pmod M$, which is $(j-i)(j+i) \\equiv 0 \\pmod M$.\n- Since $M$ is prime, it must divide either $(j-i)$ or $(j+i)$.\n- As $0 < j-i < M$, $M$ cannot divide $(j-i)$.\n- Therefore, $M$ must divide $(j+i)$. Since $0 < i+j < 2M$, the only possibility is $j+i = M$.\n\nThis means that for any $i \\in \\{1, 2, \\dots, \\frac{M-1}{2}\\}$, its square modulo $M$ is the same as that of $M-i$, since $(M-i)^2 = M^2 - 2Mi + i^2 \\equiv i^2 \\pmod M$.\nThe values of $i^2 \\pmod M$ for $i=1, 2, \\dots, \\frac{M-1}{2}$ are all distinct. If $i^2 \\equiv j^2 \\pmod M$ for $1 \\le i < j \\le \\frac{M-1}{2}$, then $j+i=M$. However, $i+j \\le (\\frac{M-1}{2}-1) + \\frac{M-1}{2} = M-2$, which is less than $M$. This is a contradiction.\n\nConsequently, the set of distinct values of $i^2 \\pmod M$ is generated by $i=0, 1, \\dots, \\frac{M-1}{2}$. The size of this set is precisely $\\frac{M-1}{2} + 1 = \\frac{M+1}{2}$. This proves that quadratic probing for any key will visit at most $\\frac{M+1}{2}$ distinct slots. The problem requires us to construct a scenario where this maximum is achieved.\n\n**2. Construction of the Key Sequence**\n\nTo force an insertion to perform exactly $N = \\frac{M+1}{2}$ probes, we must ensure that the first $N-1$ slots it attempts to access are occupied, and the $N$-th slot is empty.\n\nLet the final key be $k_{final}$. To simplify the analysis of its probe sequence, let's choose $k_{final}$ such that its base hash $h_0(k_{final})$ is $0$. A simple choice that has not been previously inserted is $k_{final} = M$, since $h_0(M) = M \\pmod M = 0$.\n\nThe probe sequence for $k_{final}=M$ will access slots at indices $h(M, i) = (0 + i^2) \\pmod M = i^2 \\pmod M$. The probe attempts correspond to $i=0, 1, 2, \\dots$.\n\nTo achieve $\\frac{M+1}{2}$ probes, we require probe attempts for $i = 0, 1, \\dots, \\frac{M-1}{2}$.\n- The probe for $i = \\frac{M-1}{2}$ must be the one that finds an empty slot.\n- The probes for $i = 0, 1, \\dots, \\frac{M-1}{2}-1 = \\frac{M-3}{2}$ must find occupied slots.\n\nThis means we must pre-fill the hash table by inserting a sequence of keys that occupy the slots at indices $j^2 \\pmod M$ for all $j \\in \\{0, 1, \\dots, \\frac{M-3}{2}\\}$. The number of such slots is $\\frac{M-3}{2} - 0 + 1 = \\frac{M-1}{2}$.\n\nThe most direct way to occupy a slot at a given index `idx` is to insert a key `k` such that $h_0(k) = \\text{idx}$. The simplest choice is to insert the key $k = \\text{idx}$ itself. Since we are pre-filling an empty table and all target indices $j^2 \\pmod M$ for $j \\in \\{0, \\dots, \\frac{M-3}{2}\\}$ are distinct and less than $M$, inserting the key $k = j^2 \\pmod M$ will place it directly into slot $j^2 \\pmod M$ in a single probe.\n\nTherefore, the constructed key sequence is as follows:\n1.  **Pre-fill Sequence**: Insert the keys $\\{k_j'\\} = \\{j^2 \\pmod M \\mid j=0, 1, \\dots, \\frac{M-3}{2}\\}$. There are $\\frac{M-1}{2}$ such keys.\n2.  **Final Key**: The final key to be inserted is $k_{final} = M$.\n\n**3. Verification of the Construction**\n\nLet's simulate the insertion of the final key, $k_{final}=M$, into the prepared hash table.\n- The base hash is $h_0(M) = 0$.\n- **Probe $i=0$**: Index is $(0+0^2) \\pmod M = 0$. This slot was filled by the key $0^2 \\pmod M$. The probe is unsuccessful.\n- **Probe $i=1$**: Index is $(0+1^2) \\pmod M = 1$. This slot was filled by the key $1^2 \\pmod M$. The probe is unsuccessful.\n- ...\n- **Probe $i = \\frac{M-3}{2}$**: Index is $(0 + (\\frac{M-3}{2})^2) \\pmod M$. This slot was filled by the key $(\\frac{M-3}{2})^2 \\pmod M$. The probe is unsuccessful.\nThese are $\\frac{M-1}{2}$ unsuccessful probes.\n\n- **Probe $i = \\frac{M-1}{2}$**: Index is $(0 + (\\frac{M-1}{2})^2) \\pmod M$. This slot was not part of the pre-fill sequence. It is empty. The probe is successful.\n\nThe total number of probes for the insertion of $k_{final}$ is the sum of unsuccessful probes and the one successful probe:\n$$ \\text{Total Probes} = \\left(\\frac{M-1}{2}\\right) + 1 = \\frac{M+1}{2} $$\nThis matches the problem's requirement. The design is thus validated. The program will implement this construction and simulation for each given value of $M$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the hash table problem for a given suite of test cases.\n\n    For each prime M, it constructs a sequence of keys that, when inserted,\n    causes the final key's insertion to take exactly (M+1)/2 probes\n    using quadratic probing. It then simulates this process and records the\n    probe count.\n    \"\"\"\n    # Test cases as specified in the problem statement.\n    test_cases = [3, 7, 11, 17, 101]\n    results = []\n\n    for M in test_cases:\n        # Initialize the hash table of size M.\n        # We use -1 as a sentinel for an empty slot, as all keys are non-negative.\n        table = np.full(M, -1, dtype=int)\n\n        # 1. CONSTRUCT AND INSERT THE PRE-FILL KEY SEQUENCE\n        # The goal is to occupy the first (M-1)/2 probe locations for a key hashing to 0.\n        # These locations correspond to probe indices j = 0, 1, ..., (M-3)/2.\n        # The slot indices are (j^2 mod M).\n        # The number of slots to pre-fill is (M-1)/2. The range upper bound is exclusive.\n        num_prefill_slots = (M - 1) // 2\n\n        for j in range(num_prefill_slots):\n            # The key to insert is the index of the slot we want to fill.\n            # h_0(k) = k % M. Since k < M, h_0(k) = k.\n            key_to_insert = (j * j) % M\n            \n            # Since all pre-fill keys are inserted into an empty table at distinct\n            # base hash locations, each insertion takes exactly one probe.\n            # We don't need to simulate the probing for these keys.\n            table[key_to_insert] = key_to_insert\n\n        # 2. DEFINE THE FINAL KEY AND SIMULATE ITS INSERTION\n        # We choose a final key that hashes to 0 but is not in the pre-fill set.\n        # k_final = M is a safe choice, as all pre-fill keys are < M.\n        final_key = M\n        base_hash = final_key % M  # This will be 0\n\n        # Simulate the insertion of the final key and count the probes.\n        probe_count = 0\n        i = 0\n        while True:\n            probe_count += 1\n            index = (base_hash + i*i) % M\n\n            if table[index] == -1:  # Found an empty slot.\n                # The problem asks for the probe count, so the simulation can stop here.\n                # The actual insertion would be: table[index] = final_key\n                break\n            \n            # The slot is occupied, continue to the next probe.\n            i += 1\n        \n        results.append(probe_count)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}