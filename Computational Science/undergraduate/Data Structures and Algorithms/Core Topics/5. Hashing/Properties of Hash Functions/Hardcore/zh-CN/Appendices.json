{
    "hands_on_practices": [
        {
            "introduction": "理解哈希函数的一个基本方面是认识到其多对一的映射特性，即不同的输入可能产生相同的哈希值。这个练习将引导你通过模运算的原理，精确计算在给定范围内有多少输入对会映射到同一个哈希值，从而加深对冲突（collision）和原像（preimage）概念的理解 。这项实践不仅是理论的检验，更是高效算法设计的基础，避免了对大规模数据集的暴力枚举。",
            "id": "3261635",
            "problem": "考虑哈希函数 $h: \\mathbb{Z} \\times \\mathbb{Z} \\to \\{0,1,\\dots,m-1\\}$，其定义为 $h(x,y) = (x^2 + y) \\bmod m$，其中 $m$ 是一个给定的正整数。对于一个固定的目标哈希值 $v \\in \\{0,1,\\dots,m-1\\}$，原像集包含所有满足 $x \\in [X_{\\min}, X_{\\max}]$、$y \\in [Y_{\\min}, Y_{\\max}]$ 且 $x^2 + y \\equiv v \\pmod{m}$ 的整数对 $(x,y)$。请仅从哈希函数、模 $m$ 同余和整数区间的形式化定义出发，推导出一个有原理可循的方法，以确定对于任何有效的参数集存在多少这样的数对。你的程序必须为每个提供的测试用例计算在指定范围内经由 $h$ 映射到 $v$ 的数对 $(x,y)$ 的总数。\n\n所有量都是整数。假设 $m \\geq 1$ 且 $X_{\\min} \\leq X_{\\max}$ 以及 $Y_{\\min} \\leq Y_{\\max}$。你的程序不能显式地枚举所有数对，除非推导过程证明了其合理性；它必须基于从模算术的核心定义和性质中推导出的逻辑。所要求的输出是表示每个测试用例中此类数对数量的整数。\n\n测试套件：\n- 案例 1：$m = 7$, $v = 3$, $X_{\\min} = 0$, $X_{\\max} = 20$, $Y_{\\min} = 0$, $Y_{\\max} = 30$。\n- 案例 2：$m = 1$, $v = 0$, $X_{\\min} = -5$, $X_{\\max} = 5$, $Y_{\\min} = -5$, $Y_{\\max} = 5$。\n- 案例 3：$m = 13$, $v = 0$, $X_{\\min} = 0$, $X_{\\max} = 100$, $Y_{\\min} = 0$, $Y_{\\max} = 100$。\n- 案例 4：$m = 9$, $v = 4$, $X_{\\min} = -20$, $X_{\\max} = -1$, $Y_{\\min} = -30$, $Y_{\\max} = -10$。\n- 案例 5：$m = 8$, $v = 7$, $X_{\\min} = 0$, $X_{\\max} = 50$, $Y_{\\min} = 3$, $Y_{\\max} = 3$。\n\n最终输出格式：\n你的程序应该生成一行输出，其中包含以上案例的结果，以逗号分隔并用方括号括起来的列表形式。例如，如果五个案例的结果是 $a_1, a_2, a_3, a_4, a_5$，则输出必须严格采用 $[a_1,a_2,a_3,a_4,a_5]$ 的形式。",
            "solution": "该问题定义明确、数学上可靠且自成体系。它基于数论的既定原理，特别是模算术，以及与哈希函数相关的计算机科学概念。所有提供的参数都已明确定义，且约束条件是一致的。因此，该问题被认为是有效的，可以推导出形式化的解。\n\n目标是找到满足以下三个条件的整数对 $(x,y)$ 的数量，其中整数 $m, v, X_{\\min}, X_{\\max}, Y_{\\min}, Y_{\\max}$ 均已给定：\n1.  $x \\in [X_{\\min}, X_{\\max}]$\n2.  $y \\in [Y_{\\min}, Y_{\\max}]$\n3.  $h(x,y) = (x^2 + y) \\bmod m = v$\n\n第三个条件可以使用模 $m$ 同余的定义来表示：\n$$x^2 + y \\equiv v \\pmod{m}$$\n这个同余式可以重排以分离出变量 $y$：\n$$y \\equiv v - x^2 \\pmod{m}$$\n一个朴素的方法是遍历指定矩形域中的所有可能的数对 $(x,y)$，并检查同余式是否成立。然而，如果 $x$ 和 $y$ 的范围很大，这种方法的计算成本会很高。问题陈述本身就表明，需要一种基于模算术的更有原理的方法。\n\n一个更高效的策略是遍历一个变量（例如 $x$）的值，并对每个 $x$ 计算有效的 $y$ 值的数量。一个关键的观察是，关于 $y$ 的条件仅通过 $x^2 \\pmod{m}$ 的值与 $x$ 相关。\n\n设 $x_1$ 和 $x_2$ 是两个整数，使得 $x_1 \\equiv x_2 \\pmod{m}$。那么 $x_1^2 \\equiv x_2^2 \\pmod{m}$。因此，对于 $x_1$ 和 $x_2$，关于 $y$ 的同余式变得相同：\n$$y \\equiv v - x_1^2 \\pmod{m} \\implies y \\equiv v - x_2^2 \\pmod{m}$$\n这一洞见使我们能够将范围 $[X_{\\min}, X_{\\max}]$ 中的所有整数 $x$ 按其模 $m$ 的余数类进行分组。对于属于给定余数类 $r \\in \\{0, 1, \\dots, m-1\\}$ 的任何 $x$，其中 $x \\equiv r \\pmod{m}$，对 $y$ 所要求的余数是相同的。设这个对 $y$ 所要求的余数为 $c_r$：\n$$c_r = (v - r^2) \\pmod{m}$$\n问题现在简化为两个主要步骤：\n1.  对于每个余数类 $r \\in \\{0, 1, \\dots, m-1\\}$，确定区间 $[Y_{\\min}, Y_{\\max}]$ 中满足 $y \\equiv c_r \\pmod{m}$ 的整数 $y$ 的数量。\n2.  对于每个余数类 $r$，确定区间 $[X_{\\min}, X_{\\max}]$ 中满足 $x \\equiv r \\pmod{m}$ 的整数 $x$ 的数量。\n\n总数对数量是这两个计数乘积对所有余数类 $r$ 的总和。\n让我们将计数方法形式化。我们需要一个函数来计算区间 $[A, B]$ 中与 $c \\pmod{m}$ 同余的整数数量。一个整数 $z$ 满足 $z \\equiv c \\pmod{m}$ 当且仅当 $z-c$ 是 $m$ 的倍数。因此，我们需要计算区间 $[A-c, B-c]$ 中 $m$ 的倍数的数量。区间 $[L, R]$ 中 $m$ 的倍数数量可以计算为 $\\lfloor R/m \\rfloor - \\lfloor (L-1)/m \\rfloor$。当使用向下取整除法时，这个公式对正整数和负整数都适用。\n\n将此应用于我们的问题：\n设 $N_y(c_r)$ 是对于一个要求的余数 $c_r$ 的有效 $y$ 值的数量。这对应于计算区间 $[Y_{\\min}, Y_{\\max}]$ 中与 $c_r \\pmod{m}$ 同余的整数数量。\n$$N_y(c_r) = \\left\\lfloor \\frac{Y_{\\max} - c_r}{m} \\right\\rfloor - \\left\\lfloor \\frac{Y_{\\min} - c_r - 1}{m} \\right\\rfloor$$\n设 $N_x(r)$ 是 $[X_{\\min}, X_{\\max}]$ 中与 $r \\pmod{m}$ 同余的 $x$ 值的数量。\n$$N_x(r) = \\left\\lfloor \\frac{X_{\\max} - r}{m} \\right\\rfloor - \\left\\lfloor \\frac{X_{\\min} - r - 1}{m} \\right\\rfloor$$\n\n总体算法流程如下：\n1.  初始化总计数为 $0$。\n2.  遍历 $x$ 的每个可能的余数类，即 $r$ 从 $0$ 到 $m-1$。\n3.  对于每个 $r$，计算 $y$ 所需的余数：$c_r = (v - r^2) \\pmod{m}$。\n4.  计算 $N_y(c_r)$，即 $[Y_{\\min}, Y_{\\max}]$ 中与 $c_r \\pmod{m}$ 同余的 $y$ 值的数量。\n5.  如果 $N_y(c_r) > 0$，则计算 $N_x(r)$，即 $[X_{\\min}, X_{\\max}]$ 中与 $r \\pmod{m}$ 同余的 $x$ 值的数量。\n6.  将乘积 $N_x(r) \\times N_y(c_r)$ 加到总计数中。\n7.  遍历完所有 $r$ 后，总计数即为最终答案。\n\n该算法的时间复杂度为 $O(m)$，效率非常高，且与 $x$ 和 $y$ 的范围大小无关。\n\n当 $m=1$ 时出现一个特殊情况。在这种情况下，任何整数都与 $0 \\pmod 1$ 同余。条件 $x^2 + y \\equiv v \\pmod 1$ 总是满足的（因为 $v$ 必须是 $0$）。问题简化为计算矩形内的总数对数量，即 $(X_{\\max} - X_{\\min} + 1) \\times (Y_{\\max} - Y_{\\min} + 1)$。通用算法也能正确处理这种情况。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_case(m, v, x_min, x_max, y_min, y_max):\n    \"\"\"\n    Calculates the number of integer pairs (x,y) in the given ranges satisfying\n    (x^2 + y) mod m = v, based on principles of modular arithmetic.\n    \"\"\"\n    # The condition is y === v - x^2 (mod m).\n    # The required remainder for y depends only on r_x = x mod m.\n    # The overall strategy is to iterate through each residue class r_x from 0 to m-1,\n    # calculate the number of valid y's for that class, calculate the number of\n    # x's belonging to that class, and sum up the products.\n\n    # This is a general function to count integers in [lower, upper]\n    # that are congruent to `rem` modulo `mod`.\n    # Based on the formula: count = floor( (upper-rem)/mod ) - floor( (lower-rem-1)/mod )\n    # This is equivalent to counting multiples of `mod` in the range [lower-rem, upper-rem].\n    def count_congruent(lower, upper, mod, rem):\n        u_bound = upper - rem\n        l_bound = lower - rem\n        return (u_bound // mod) - ((l_bound - 1) // mod)\n\n    # Special case for m=1. Any integer is congruent to 0 mod 1.\n    # Since v must be 0, the condition is always met.\n    if m == 1:\n        num_x = x_max - x_min + 1\n        num_y = y_max - y_min + 1\n        return num_x * num_y\n\n    # Step 1: Pre-calculate the number of valid y's for each possible residue class of x.\n    # Let r_x = x mod m. The required residue for y is c_r = (v - r_x^2) mod m.\n    y_counts_per_residue = [0] * m\n    for r_x in range(m):\n        c_r = (v - r_x**2) % m\n        y_counts_per_residue[r_x] = count_congruent(y_min, y_max, m, c_r)\n\n    # Step 2: Sum up contributions for each residue class.\n    total_pairs = 0\n    for r_x in range(m):\n        # Optimization: if no y values work for this residue, skip calculation for x.\n        if y_counts_per_residue[r_x] == 0:\n            continue\n\n        # Count how many x's in [x_min, x_max] belong to residue class r_x.\n        num_x = count_congruent(x_min, x_max, m, r_x)\n        \n        # Add the product to the total.\n        total_pairs += num_x * y_counts_per_residue[r_x]\n            \n    return total_pairs\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # m, v, X_min, X_max, Y_min, Y_max\n        (7, 3, 0, 20, 0, 30),\n        (1, 0, -5, 5, -5, 5),\n        (13, 0, 0, 100, 0, 100),\n        (9, 4, -20, -1, -30, -10),\n        (8, 7, 0, 50, 3, 3),\n    ]\n\n    results = []\n    for case in test_cases:\n        m, v, x_min, x_max, y_min, y_max = case\n        result = solve_case(m, v, x_min, x_max, y_min, y_max)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "开放寻址法是解决哈希冲突的常用策略，但其性能高度依赖于探测序列的设计。本练习将带你深入探索二次探测法的性能边界，你将需要主动构造一个特定的键序列，以触发该策略的最坏情况探测行为 。通过这种“对抗性”的实践，你不仅能掌握二次探测的工作原理，还能学会如何分析和评估不同哈希方案在压力下的稳健性。",
            "id": "3261658",
            "problem": "给定一个初始为空的开放定址哈希表，其大小为 $M$，并具有以下属性。基哈希函数为 $h_0(k) = k \\bmod M$。开放定址（OA）通过二次探测（QP）执行，探测函数为 $h(k,i) = \\left(h_0(k) + i^2\\right) \\bmod M$，其中 $i = 0, 1, 2, \\dots$ 为连续的探测索引。假设 $M$ 是一个奇素数，哈希表存储整数且不支持删除操作。其插入过程会一直探测，直到找到第一个空槽并将键放入其中。\n\n从上述基本定义出发，设计一个要插入到空表中的整数键序列 $\\{k_j\\}$，使得在插入该序列的最后一个键时，探测过程在放置该键之前总共检查恰好 $\\frac{M+1}{2}$ 个不同的槽位（包括找到已占用槽位的失败探测和找到空槽位的最终成功探测）。您的构造必须基于模运算和哈希函数行为的第一性原理进行论证，而不是通过临时的规定。\n\n您的程序必须：\n- 对于每个指定的 $M$ 值，构造这样一个键序列，使用所定义的二次探测将它们插入哈希表，并记录在插入最后一个键期间执行的不同探测总数（包括找到空槽位的成功探测）。\n- 根据所提供的定义忠实地模拟哈希表，确保每次探测都从 $i=0$ 开始按 $i$ 的递增顺序检查槽索引 $h(k,i)$，在找到第一个空槽时停止并将键放入其中。\n- 仅使用整数；不涉及物理单位。\n- 将所有给定测试用例的结果汇总到一行中，以逗号分隔的列表形式输出，并用方括号括起来，例如 $[r_1,r_2,r_3]$，其中每个 $r_j$ 是对应测试用例的整数探测计数。\n\n测试套件：\n- 情况 1: $M = 3$ (边界素数)。\n- 情况 2: $M = 7$ (小编素数)。\n- 情况 3: $M = 11$ (中等素数)。\n- 情况 4: $M = 17$ (较大素数)。\n- 情况 5: $M = 101$ (显著较大的素数)。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $[r_1,r_2,r_3,r_4,r_5]$），其中每个 $r_j$ 是在测试套件中对应 $M$ 的最后一个键插入期间执行的总探测次数（包括成功的一次）。该解决方案必须在纯数学和逻辑上普遍适用于任何现代编程语言，但您的最终答案必须按规定以可运行的 Python 代码形式提供。",
            "solution": "用户的要求是设计一个整数键序列 $\\{k_j\\}$，用于插入一个大小为 $M$ 的初始为空的开放定址哈希表。插入最后一个键时必须导致恰好 $\\frac{M+1}{2}$ 次不同的探测尝试。该哈希表使用二次探测，函数为 $h(k,i) = (h_0(k) + i^2) \\bmod M$，其中 $h_0(k) = k \\bmod M$ 且 $M$ 是一个奇素数。\n\n**1. 素数模下的二次探测分析**\n\n此问题的核心在于当表大小 $M$ 为素数时，二次探测的数论性质。对于一个键 $k$，其探测的索引序列由 $(h_0(k) + i^2) \\pmod M$ 给出，其中 $i = 0, 1, 2, \\dots$。访问的不同槽位数取决于 $i^2 \\pmod M$ 的不同值的数量。\n\n我们来分析素数 $M$ 模下的二次剩余集合，$S = \\{i^2 \\pmod M \\mid i \\in \\{0, 1, \\dots, M-1\\}\\}$。\n- 对于 $i=0$，我们有 $0^2 \\equiv 0 \\pmod M$。\n- 对于任何 $i \\in \\{1, \\dots, M-1\\}$，如果我们有两个探测索引 $i$ 和 $j$，满足 $0 \\le i  j  M$ 且 $i^2 \\equiv j^2 \\pmod M$，这意味着 $j^2 - i^2 \\equiv 0 \\pmod M$，即 $(j-i)(j+i) \\equiv 0 \\pmod M$。\n- 因为 $M$ 是素数，它必须整除 $(j-i)$ 或 $(j+i)$。\n- 由于 $0  j-i  M$，$M$ 不能整除 $(j-i)$。\n- 因此，$M$ 必须整除 $(j+i)$。由于 $0  i+j  2M$，唯一的可能性是 $j+i = M$。\n\n这意味着对于任何 $i \\in \\{1, 2, \\dots, \\frac{M-1}{2}\\}$，其模 $M$ 的平方与 $M-i$ 的模 $M$ 平方相同，因为 $(M-i)^2 = M^2 - 2Mi + i^2 \\equiv i^2 \\pmod M$。\n$i=1, 2, \\dots, \\frac{M-1}{2}$ 时，$i^2 \\pmod M$ 的值都是不同的。如果对于 $1 \\le i  j \\le \\frac{M-1}{2}$ 有 $i^2 \\equiv j^2 \\pmod M$，那么 $j+i=M$。然而，$i+j \\le (\\frac{M-1}{2}-1) + \\frac{M-1}{2} = M-2$，这小于 $M$。这是一个矛盾。\n\n因此，$i^2 \\pmod M$ 的不同值集合由 $i=0, 1, \\dots, \\frac{M-1}{2}$ 生成。这个集合的大小恰好是 $\\frac{M-1}{2} + 1 = \\frac{M+1}{2}$。这证明了对于任何键，二次探测最多会访问 $\\frac{M+1}{2}$ 个不同的槽位。问题要求我们构造一个达到此最大值的情景。\n\n**2. 键序列的构造**\n\n要强制一次插入执行恰好 $N = \\frac{M+1}{2}$ 次探测，我们必须确保它尝试访问的前 $N-1$ 个槽位已被占用，而第 $N$ 个槽位为空。\n\n设最后一个键为 $k_{final}$。为了简化其探测序列的分析，我们选择 $k_{final}$，使其基哈希 $h_0(k_{final})$ 为 $0$。一个之前未插入过的简单选择是 $k_{final} = M$，因为 $h_0(M) = M \\pmod M = 0$。\n\n$k_{final}=M$ 的探测序列将访问索引为 $h(M, i) = (0 + i^2) \\pmod M = i^2 \\pmod M$ 的槽位。探测尝试对应于 $i=0, 1, 2, \\dots$。\n\n为实现 $\\frac{M+1}{2}$ 次探测，我们需要对 $i = 0, 1, \\dots, \\frac{M-1}{2}$ 进行探测尝试。\n- 当 $i = \\frac{M-1}{2}$ 时的探测必须是找到空槽位的那一次。\n- 当 $i = 0, 1, \\dots, \\frac{M-1}{2}-1 = \\frac{M-3}{2}$ 时的探测必须找到已占用的槽位。\n\n这意味着我们必须通过插入一个键序列来预先填充哈希表，该序列占用所有 $j \\in \\{0, 1, \\dots, \\frac{M-3}{2}\\}$ 对应的索引 $j^2 \\pmod M$ 处的槽位。这样的槽位数是 $\\frac{M-3}{2} - 0 + 1 = \\frac{M-1}{2}$。\n\n占用给定索引 `idx` 处槽位的最直接方法是插入一个键 `k`，使得 $h_0(k) = \\text{idx}$。最简单的选择是插入键 $k = \\text{idx}$ 本身。因为我们正在预填充一个空表，并且所有目标索引 $j^2 \\pmod M$（其中 $j \\in \\{0, \\dots, \\frac{M-3}{2}\\}$）都是不同的且小于 $M$，所以插入键 $k = j^2 \\pmod M$ 将通过一次探测直接将其放入槽位 $j^2 \\pmod M$ 中。\n\n因此，构造的键序列如下：\n1.  **预填充序列**：插入键 $\\{k_j'\\} = \\{j^2 \\pmod M \\mid j=0, 1, \\dots, \\frac{M-3}{2}\\}$。共有 $\\frac{M-1}{2}$ 个这样的键。\n2.  **最终键**：最后要插入的键是 $k_{final} = M$。\n\n**3. 构造验证**\n\n让我们模拟将最后一个键 $k_{final}=M$ 插入已准备好的哈希表的过程。\n- 基哈希为 $h_0(M) = 0$。\n- **探测 $i=0$**：索引为 $(0+0^2) \\pmod M = 0$。此槽位已被键 $0^2 \\pmod M$ 填充。探测失败。\n- **探测 $i=1$**：索引为 $(0+1^2) \\pmod M = 1$。此槽位已被键 $1^2 \\pmod M$ 填充。探测失败。\n- ...\n- **探测 $i = \\frac{M-3}{2}$**：索引为 $(0 + (\\frac{M-3}{2})^2) \\pmod M$。此槽位已被键 $(\\frac{M-3}{2})^2 \\pmod M$ 填充。探测失败。\n这些是 $\\frac{M-1}{2}$ 次失败的探测。\n\n- **探测 $i = \\frac{M-1}{2}$**：索引为 $(0 + (\\frac{M-1}{2})^2) \\pmod M$。此槽位不属于预填充序列。它是空的。探测成功。\n\n插入 $k_{final}$ 的总探测次数是失败探测次数与一次成功探测次数之和：\n$$ \\text{总探测次数} = \\left(\\frac{M-1}{2}\\right) + 1 = \\frac{M+1}{2} $$\n这符合问题的要求。因此，该设计得到了验证。程序将为每个给定的 $M$ 值实现此构造和模拟。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the hash table problem for a given suite of test cases.\n\n    For each prime M, it constructs a sequence of keys that, when inserted,\n    causes the final key's insertion to take exactly (M+1)/2 probes\n    using quadratic probing. It then simulates this process and records the\n    probe count.\n    \"\"\"\n    # Test cases as specified in the problem statement.\n    test_cases = [3, 7, 11, 17, 101]\n    results = []\n\n    for M in test_cases:\n        # Initialize the hash table of size M.\n        # We use -1 as a sentinel for an empty slot, as all keys are non-negative.\n        table = np.full(M, -1, dtype=int)\n\n        # 1. CONSTRUCT AND INSERT THE PRE-FILL KEY SEQUENCE\n        # The goal is to occupy the first (M-1)/2 probe locations for a key hashing to 0.\n        # These locations correspond to probe indices j = 0, 1, ..., (M-3)/2.\n        # The slot indices are (j^2 mod M).\n        # The number of slots to pre-fill is (M-1)/2. The range upper bound is exclusive.\n        num_prefill_slots = (M - 1) // 2\n\n        for j in range(num_prefill_slots):\n            # The key to insert is the index of the slot we want to fill.\n            # h_0(k) = k % M. Since k  M, h_0(k) = k.\n            key_to_insert = (j * j) % M\n            \n            # Since all pre-fill keys are inserted into an empty table at distinct\n            # base hash locations, each insertion takes exactly one probe.\n            # We don't need to simulate the probing for these keys.\n            table[key_to_insert] = key_to_insert\n\n        # 2. DEFINE THE FINAL KEY AND SIMULATE ITS INSERTION\n        # We choose a final key that hashes to 0 but is not in the pre-fill set.\n        # k_final = M is a safe choice, as all pre-fill keys are  M.\n        final_key = M\n        base_hash = final_key % M  # This will be 0\n\n        # Simulate the insertion of the final key and count the probes.\n        probe_count = 0\n        i = 0\n        while True:\n            probe_count += 1\n            index = (base_hash + i*i) % M\n\n            if table[index] == -1:  # Found an empty slot.\n                # The problem asks for the probe count, so the simulation can stop here.\n                # The actual insertion would be: table[index] = final_key\n                break\n            \n            # The slot is occupied, continue to the next probe.\n            i += 1\n        \n        results.append(probe_count)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "哈希函数不仅用于构建哈希表，它也是解决复杂算法问题的强大工具，例如在生物信息学中进行序列比对。这个高级实践将向你展示如何利用滚动哈希（rolling hash）结合组合学原理，来高效地在两条DNA序列中寻找允许一定数量错配的最长公共子串 。完成这个练习将让你体会到哈希技术在近似匹配和大规模数据处理中的精妙应用。",
            "id": "3261679",
            "problem": "给定两个由脱氧核糖核酸 (DNA) 字母表 $\\{A,C,G,T\\}$ 构成的有限字符串 $S$ 和 $T$，以及一个非负整数 $k$。定义两个等长字符串 $U$ 和 $V$ 的汉明距离 $d_H(U,V)$ 为它们对应位置上符号不同的数量。最长 $k$ 错配公共子串长度是指满足以下条件的最大整数 $\\ell$：存在索引 $i$ 和 $j$，使得 $0 \\le i \\le |S| - \\ell$ 和 $0 \\le j \\le |T| - \\ell$ 成立，并且 $d_H\\big(S[i:i+\\ell], T[j:j+\\ell]\\big) \\le k$。\n\n从哈希函数、滚动哈希和汉明距离的基本定义出发，设计并实现一个算法。该算法利用滚动哈希来解决一个判定问题：对于一个固定的长度 $\\ell$，是否存在 $S$ 和 $T$ 的长度为 $\\ell$ 的子串，其汉明距离至多为 $k$。然后，在一个搜索过程中使用此判定程序，以确定最长的 $k$ 错配公共子串长度。该算法必须依赖于：\n- 在有限模下的多项式滚动哈希，通过预先计算的幂和前缀哈希，实现 $O(1)$ 的子串哈希查询。\n- 一个组合学事实：对于任意两个长度相同且在至多 $k$ 个位置上不同的字符串，如果将它们的长度划分为 $k+1$ 个连续块，则保证至少有一个块完全匹配。\n\n你的程序必须：\n- 将每个 DNA 字符映射到集合 $\\{1,2,3,4\\}$ 中的一个整数。\n- 使用双哈希，即采用两个不同的大素数模数，以降低碰撞概率。\n- 对于给定的 $\\ell$，将长度为 $\\ell$ 的位置划分为 $k+1$ 个连续块。其中，前 $r$ 个块的大小为 $q+1$，其余块的大小为 $q$，这里 $q = \\left\\lfloor \\frac{\\ell}{k+1} \\right\\rfloor$ 且 $r = \\ell \\bmod (k+1)$。\n- 对于每个块索引 $b \\in \\{0,1,\\dots,k\\}$，使用滚动哈希，按其第 $b$ 个块的哈希值对所有 $S$ 的长度为 $\\ell$ 的子串进行索引。对于每个 $T$ 的长度为 $\\ell$ 的子串，使用其第 $b$ 个块的哈希值从 $S$ 中检索候选子串，并通过直接计算汉明距离来验证候选子串，若距离小于或等于 $k$ 则接受。\n- 在 $\\ell \\in \\{0,1,\\dots,\\min(|S|,|T|)\\}$ 上进行搜索，以找到能被接受的最大 $\\ell$。对于所提供的测试套件，该搜索必须是正确且高效的。\n\n最终输出必须为单行文本，包含整个测试套件的结果，格式为方括号内以逗号分隔的列表（例如，“[result1,result2,result3]”）。每个结果都必须是一个整数，等于其测试用例的最长 $k$ 错配公共子串长度。\n\n测试套件：\n- 用例 $1$：$S = $ \"AAAAAA\", $T = $ \"AAAATA\", $k = 1$。\n- 用例 $2$：$S = $ \"ACGT\", $T = $ \"ACGT\", $k = 0$。\n- 用例 $3$：$S = $ \"AAAA\", $T = $ \"TTTT\", $k = 0$。\n- 用例 $4$：$S = $ \"ACGTCGTA\", $T = $ \"ACGACGTA\", $k = 2$。\n- 用例 $5$：$S = $ \"\", $T = $ \"ACGT\", $k = 1$。\n- 用例 $6$：$S = $ \"ACGTACGT\", $T = $ \"ACGTTTGT\", $k = 1$。\n\n你的程序必须生成单行输出，其中包含按上述顺序对应于各用例的六个整数结果，并采用指定的格式。",
            "solution": "用户提供了一个详细的问题陈述，我现在将对其进行验证。\n\n### 步骤 1：提取给定信息\n\n-   **输入**：\n    1.  两个由 DNA 字母表 $\\{A, C, G, T\\}$ 构成的有限字符串 $S$ 和 $T$。\n    2.  一个非负整数 $k$。\n\n-   **定义**：\n    1.  **汉明距离 $d_H(U,V)$**：对于两个等长字符串 $U$ 和 $V$，这是它们对应位置上符号不同的数量。\n    2.  **最长 $k$ 错配公共子串长度**：满足以下条件的最大整数 $\\ell$：存在索引 $i$ 和 $j$ ($0 \\le i \\le |S| - \\ell$, $0 \\le j \\le |T| - \\ell$)，使得 $d_H\\big(S[i:i+\\ell], T[j:j+\\ell]\\big) \\le k$。\n\n-   **算法约束**：\n    1.  解决方案必须采用一个两部分算法：一个嵌套在搜索过程中的判定程序。\n    2.  对于一个固定的长度 $\\ell$，判定程序确定是否存在 $S$ 和 $T$ 的长度为 $\\ell$ 的子串，其汉明距离至多为 $k$。\n    3.  搜索过程找到使判定程序返回“真”的最大 $\\ell$。搜索必须覆盖范围 $\\ell \\in \\{0, 1, \\dots, \\min(|S|,|T|)\\}$。\n    4.  该算法必须基于多项式滚动哈希，通过预先计算的幂和前缀哈希实现 $O(1)$ 的子串哈希查询。要求使用双哈希，即采用两个不同的大素数模数。\n    5.  DNA 字符必须映射到集合 $\\{1, 2, 3, 4\\}$ 中的整数。\n    6.  判定程序的核心必须使用组合学原理：对于任意两个长度为 $\\ell$ 且汉明距离 $\\le k$ 的字符串，如果将它们划分为 $k+1$ 个连续块，则保证至少有一对相应的块是完全相同的。\n    7.  对于给定的 $\\ell$，$k+1$ 个块定义如下：令 $q = \\lfloor \\frac{\\ell}{k+1} \\rfloor$ 且 $r = \\ell \\bmod (k+1)$。前 $r$ 个块的大小为 $q+1$，其余块的大小为 $q$。\n    8.  判定程序必须对每个块索引 $b \\in \\{0, 1, \\dots, k\\}$，按其第 $b$ 个块的哈希值对所有长度为 $\\ell$ 的 $S$ 子串进行索引。然后，对于每个长度为 $\\ell$ 的 $T$ 子串，它使用其第 $b$ 个块的哈希值从 $S$ 中寻找候选匹配，并通过计算完整的汉明距离来验证它们。\n\n-   **测试套件**：\n    -   用例 $1$：$S = $ \"AAAAAA\", $T = $ \"AAAATA\", $k = 1$。\n    -   用例 $2$：$S = $ \"ACGT\", $T = $ \"ACGT\", $k = 0$。\n    -   用例 $3$：$S = $ \"AAAA\", $T = $ \"TTTT\", $k = 0$。\n    -   用例 $4$：$S = $ \"ACGTCGTA\", $T = $ \"ACGACGTA\", $k = 2$。\n    -   用例 $5$：$S = $ \"\", $T = $ \"ACGT\", $k = 1$。\n    -   用例 $6$：$S = $ \"ACGTACGT\", $T = $ \"ACGTTTGT\", $k = 1$。\n\n-   **输出格式**：一个单行文本，包含一个用方括号括起来的、以逗号分隔的整数结果列表。\n\n### 步骤 2：使用提取的给定信息进行验证\n\n-   **科学或事实上的不健全性**：该问题在科学上是健全的。它基于计算机科学（字符串算法、哈希）和数学（组合学、数论）中的既定概念。其核心组合学原理是鸽巢原理的直接应用：如果至多有 $k$ 个错配（鸽子）分布在 $k+1$ 个块（鸽巢）中，那么至少有一个块必须不包含任何鸽子（错配）。\n-   **不可形式化或不相关**：该问题高度形式化，并且与字符串匹配算法的设计和分析直接相关。\n-   **不完整或矛盾的设置**：该问题的规定异常明确，不仅提供了目标，还为所需算法提供了详细的蓝图。没有任何矛盾之处。\n-   **不现实或不可行**：该问题是一个标准的计算任务，没有涉及任何物理上不可能的条件。\n-   **不适定或结构不良**：该问题是适定的。解的存在性得到保证（长度为 0 总是可能的），并且详细的算法规定导致了一个唯一的、确定性的结果。\n-   **伪深刻、琐碎或同义反复**：该问题并非无足轻重，它需要仔细实现几个复杂组件（二分搜索、双滚动哈希、基于块的候选生成）。它代表了一种标准而优雅的算法技术。\n-   **超出科学可验证性**：该算法的正确性可以通过数学推理得出，其输出对于任何给定的输入都是可验证的。\n\n### 步骤 3：结论与行动\n\n问题陈述是**有效的**。它自成体系、有科学依据且定义严谨。我将继续提供一个完整的解决方案。\n\n### 基于原则的设计和解决方案\n\n该问题要求设计一个算法，以找出两个字符串 $S$ 和 $T$ 之间最长的 $k$ 错配公共子串长度 $\\ell_{max}$。该方法被构建为一个优化问题，通过对一个判定问题进行搜索来解决。\n\n**1. 总体策略：对答案进行二分搜索**\n\n让我们定义一个布尔函数 `check(l)`，如果存在一对来自 $S$ 和 $T$ 的长度为 $\\ell$ 的子串，其汉明距离至多为 $k$，则该函数为真，否则为假。这个函数是单调的：如果 `check(l)` 为真，那么对于任何 $1 \\le \\ell'  \\ell$ ，`check(l')` 也为真。这是因为一对长度为 $\\ell$ 的有效子串的任何前缀都将构成一对长度为 $\\ell'$ 的有效子串，因为汉明距离不会增加。\n\n这种单调性使我们能够使用二分搜索来高效地找到使 `check(l)` 为真的最大 $\\ell$。$\\ell$ 的搜索空间是区间 $[0, \\min(|S|, |T|)]$。二分搜索将反复探测这个空间，收敛到最优值 $\\ell_{max}$。\n\n**2. 判定程序：`check(l)`**\n\n`check(l)` 函数是该算法的核心。一个朴素的实现会比较 $S$ 中的每个长度为 $\\ell$ 的子串与 $T$ 中的每个此类子串，这种方法的复杂度对于大字符串来说是令人望而却步的。该问题指定了一种基于关键组合学洞察的更复杂的方法。\n\n**组合学原理**：如果两个长度为 $\\ell$ 的字符串 $U$ 和 $V$ 的汉明距离 $d_H(U, V) \\le k$，并且我们将两个字符串都划分为 $k+1$ 个连续块，那么根据鸽巢原理，至少有一对相应的块必须是完全相同的。如果每一对块都至少有一个错配，那么总的错配数将至少是 $k+1$，这与前提相矛盾。\n\n这个原理使我们能够将问题从在整个长度 $\\ell$ 上寻找近似匹配，转变为在更小的块上寻找至少一个精确匹配。精确匹配可以用哈希非常高效地解决。\n\n**分块**：对于给定的长度 $\\ell$ 和错配容忍度 $k$，我们将长度划分为 $B = k+1$ 个块。基本块大小为 $q = \\left\\lfloor \\frac{\\ell}{B} \\right\\rfloor$，较大块的数量为 $r = \\ell \\bmod B$。前 $r$ 个块的大小为 $q+1$，剩下的 $B-r$ 个块的大小为 $q$。我们可以预先计算这 $k+1$ 个块的起始偏移量。\n\n**3. 使用滚动哈希进行高效精确匹配**\n\n为了高效地找到相同的块，我们使用多项式滚动哈希。\n\n**多项式滚动哈希**：一个字符串 $W = w_0w_1...w_{m-1}$ 被映射到一个整数哈希值。首先，每个字符 $w_i$ 从集合 $\\{1, 2, 3, 4\\}$ 中映射到一个正整数 $c(w_i)$。然后哈希值定义为：\n$$ H(W) = \\left( \\sum_{i=0}^{m-1} c(w_i) \\cdot p^{m-1-i} \\right) \\pmod{M} $$\n其中 $p$ 是一个比字母表大小更大的素数基数，$M$ 是一个大素数模数。\n\n**双哈希**：为了大幅降低哈希碰撞（两个不同字符串产生相同哈希值）的概率，我们使用不同的基数 ($p_1, p_2$) 和模数 ($M_1, M_2$)为每个字符串计算两个独立的哈希值。一个字符串因此由一对哈希值 $(h_1, h_2)$ 表示。\n\n**$O(1)$ 子串哈希**：在经过初始的 $O(|S|)$ 预计算后，我们可以在 $O(1)$ 时间内计算任何子串的哈希值。我们为每个哈希函数预计算两个数组：\n1.  基数的幂：$P[i] = p^i \\pmod M$。\n2.  前缀哈希：$H_{pref}[i] = H(S[0:i-1])$。\n\n子串 $S[i:j]$（长度为 $len = j-i+1$）的哈希值则为：\n$$ H(S[i:j]) = \\left( H_{pref}[j+1] - H_{pref}[i] \\cdot P[len] \\right) \\pmod M $$\n必须注意处理减法产生的负数结果，方法是在最终取模前加上 $M$。\n\n**4. `check(l)` 算法**\n\n有了这些工具，`check(l)` 的算法如下（假设 $\\ell > 0$）：\n\n1.  确定长度为 $\\ell$ 的字符串内 $k+1$ 个块中每一个的起始点和结束点。\n2.  对每个块索引 $b \\in \\{0, 1, ..., k\\}$：\n    a. 创建一个哈希映射 `hash_to_indices`，用于存储来自 $S$ 的子串的第 $b$ 个块的哈希值。\n    b. 遍历从 $0$ 到 $|S|-\\ell$ 的所有起始位置 $i$。对于每个子串 $S[i:i+\\ell]$：\n        i.  确定对应于第 $b$ 个块的切片：$S[i+\\text{start}_b : i+\\text{end}_b]$。\n        ii. 使用预计算的表，在 $O(1)$ 时间内计算其双哈希 $(h_1, h_2)$。\n        iii. 存储完整子串的起始索引：`hash_to_indices[(h_1, h_2)].append(i)`。\n    c. 遍历从 $0$ 到 $|T|-\\ell$ 的所有起始位置 $j$。对于每个子串 $T[j:j+\\ell]$：\n        i.  确定对应于第 $b$ 个块的切片：$T[j+\\text{start}_b : j+\\text{end}_b]$。\n        ii. 计算其双哈希 $(h'_1, h'_2)$。\n        iii. 如果这个哈希 $(h'_1, h'_2)$ 在 `hash_to_indices` 中作为键存在，我们就找到了候选对。\n        iv. 对于与此哈希关联的每个候选起始索引 $i_{cand}$：\n            -   执行直接的逐字符比较，以计算 $d_H(S[i_{cand}:i_{cand}+\\ell], T[j:j+\\ell])$。\n            -   如果距离 $\\le k$，则找到了一个有效的对。返回 `True`。\n3.  如果遍历所有 $k+1$ 个块的外部循环完成而没有找到匹配，则不存在这样一对长度为 $\\ell$ 的子串。返回 `False`。\n\n由于鸽巢原理，这个过程保证是正确的。其效率来源于将大量昂贵的 $O(\\ell)$ 近似比较，减少为数量少得多的 $O(1) $哈希计算和查找，随后仅对强有力的候选者进行少数几次 $O(\\ell)$ 的验证。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import defaultdict\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        (\"AAAAAA\", \"AAAATA\", 1),\n        # Case 2\n        (\"ACGT\", \"ACGT\", 0),\n        # Case 3\n        (\"AAAA\", \"TTTT\", 0),\n        # Case 4\n        (\"ACGTCGTA\", \"ACGACGTA\", 2),\n        # Case 5\n        (\"\", \"ACGT\", 1),\n        # Case 6\n        (\"ACGTACGT\", \"ACGTTTGT\", 1),\n    ]\n\n    results = []\n    for S, T, k in test_cases:\n        result = find_longest_k_mismatch_substring(S, T, k)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef find_longest_k_mismatch_substring(S, T, k):\n    \"\"\"\n    Finds the longest k-mismatch common substring length using binary search.\n    \"\"\"\n    n, m = len(S), len(T)\n    if n == 0 or m == 0:\n        return 0\n\n    checker = KMismatchChecker(S, T, k)\n    \n    ans = 0\n    low, high = 1, min(n, m)\n    \n    while low = high:\n        ell = low + (high - low) // 2\n        if checker.check(ell):\n            ans = ell\n            low = ell + 1\n        else:\n            high = ell - 1\n            \n    return ans\n\nclass KMismatchChecker:\n    \"\"\"\n    A class to check for the existence of a k-mismatch substring of a given length ell.\n    It precomputes rolling hash structures for efficiency.\n    \"\"\"\n    CHAR_MAP = {'A': 1, 'C': 2, 'G': 3, 'T': 4}\n    P1, M1 = 313, 10**9 + 7\n    P2, M2 = 353, 10**9 + 9\n\n    class RollingHasher:\n        def __init__(self, text, p, m, char_map):\n            self.n = len(text)\n            self.p = p\n            self.m = m\n            \n            self.prefix_hash = np.zeros(self.n + 1, dtype=np.int64)\n            self.powers = np.ones(self.n + 1, dtype=np.int64)\n            \n            for i in range(self.n):\n                self.prefix_hash[i+1] = (self.prefix_hash[i] * self.p + char_map[text[i]]) % self.m\n            \n            for i in range(self.n):\n                self.powers[i+1] = (self.powers[i] * self.p) % self.m\n\n        def get_hash(self, i, length):\n            \"\"\"Computes hash of substring of given length starting at i.\"\"\"\n            h = (self.prefix_hash[i + length] - self.prefix_hash[i] * self.powers[length]) % self.m\n            return h + self.m if h  0 else h\n\n    def __init__(self, S, T, k):\n        self.S = S\n        self.T = T\n        self.k = k\n        self.n = len(S)\n        self.m = len(T)\n        \n        self.s_hasher1 = self.RollingHasher(S, self.P1, self.M1, self.CHAR_MAP)\n        self.s_hasher2 = self.RollingHasher(S, self.P2, self.M2, self.CHAR_MAP)\n        self.t_hasher1 = self.RollingHasher(T, self.P1, self.M1, self.CHAR_MAP)\n        self.t_hasher2 = self.RollingHasher(T, self.P2, self.M2, self.CHAR_MAP)\n\n    @staticmethod\n    def _get_block_structure(ell, k):\n        \"\"\"Calculates the start and length of each of the k+1 blocks.\"\"\"\n        if ell == 0:\n            return [], []\n        num_blocks = k + 1\n        base_len = ell // num_blocks\n        rem = ell % num_blocks\n        \n        block_starts = [0] * (num_blocks + 1)\n        block_lengths = [0] * num_blocks\n\n        for i in range(num_blocks):\n            length = base_len + 1 if i  rem else base_len\n            block_lengths[i] = length\n            block_starts[i+1] = block_starts[i] + length\n            \n        return block_starts, block_lengths\n\n    def _hamming_distance(self, s1_start, s2_start, length):\n        \"\"\"Calculates Hamming distance between substrings of S and T.\"\"\"\n        dist = 0\n        for i in range(length):\n            if self.S[s1_start + i] != self.T[s2_start + i]:\n                dist += 1\n        return dist\n\n    def check(self, ell):\n        \"\"\"\n        Checks if a k-mismatch common substring of length ell exists.\n        \"\"\"\n        if ell == 0:\n            return True\n        if ell > min(self.n, self.m):\n            return False\n\n        block_starts, block_lengths = self._get_block_structure(ell, self.k)\n        \n        for b in range(self.k + 1):\n            s_block_hashes = defaultdict(list)\n            block_start_offset = block_starts[b]\n            block_len = block_lengths[b]\n            \n            if block_len == 0:\n                continue\n                \n            # Index substrings of S by their b-th block's hash\n            for i in range(self.n - ell + 1):\n                h1 = self.s_hasher1.get_hash(i + block_start_offset, block_len)\n                h2 = self.s_hasher2.get_hash(i + block_start_offset, block_len)\n                s_block_hashes[(h1, h2)].append(i)\n\n            if not s_block_hashes:\n                continue\n\n            # Check substrings of T against the index\n            for j in range(self.m - ell + 1):\n                h1 = self.t_hasher1.get_hash(j + block_start_offset, block_len)\n                h2 = self.t_hasher2.get_hash(j + block_start_offset, block_len)\n\n                if (h1, h2) in s_block_hashes:\n                    for s_start_idx in s_block_hashes[(h1, h2)]:\n                        # Candidate found, verify with Hamming distance\n                        if self._hamming_distance(s_start_idx, j, ell) = self.k:\n                            return True\n                            \n        return False\n\n# Execute the solver\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}