{
    "hands_on_practices": [
        {
            "introduction": "While average-case analysis provides valuable performance benchmarks, understanding the worst-case behavior of an algorithm is crucial for building robust systems. This exercise challenges you to step into the shoes of an adversary. You will design a specific sequence of keys to intentionally exploit the primary weakness of linear probingâ€”its tendency to form large, contiguous clusters of occupied slots. By constructing this pathological scenario and analyzing its performance, you will gain a concrete understanding of why linear probing can degrade significantly and why more sophisticated collision resolution strategies are often preferred. ",
            "id": "3244644",
            "problem": "Consider a hash table of size $m$ that uses open addressing with linear probing. The collision resolution rule is: upon inserting or searching for a key $k$, probe the sequence of table indices $h(k), h(k)+1, h(k)+2, \\dots$ taken modulo $m$ until an empty slot is found (during insertion) or the target key is found (during successful search). The primary hash function is $h(k) = k \\bmod m$. The table is initially empty. You will insert $n$ distinct keys $k_1, k_2, \\dots, k_n$ with $0 < n < m$, and after all insertions, a successful search is performed for a single key drawn uniformly at random from $\\{k_1, k_2, \\dots, k_n\\}$. Define the load factor $\\alpha$ as $\\alpha = \\frac{n}{m}$.\n\nYour task is to design an adversarial choice of $m$ and a sequence of distinct keys $k_1, \\dots, k_n$ so that linear probing creates a single contiguous cluster of length $n$ in the table, and then quantify the expected number of probes required for a successful search under the uniform random key model described above. You must do the following:\n\n- Specify a valid choice of $m$ and $k_1, \\dots, k_n$ in terms of $m$ that ensures all keys hash to the same initial index under $h(k) = k \\bmod m$, thereby forcing a single contiguous cluster through linear probing. Argue that the keys are distinct and that the resulting cluster is contiguous of length $n$.\n\n- Starting from the core definitions of open addressing, linear probing, and the probing sequence induced by $h(k)$, derive the expected number of probes required for a successful search when the query key is drawn uniformly from the $n$ inserted keys. Express your final answer as a closed-form analytic expression in terms of the load factor $\\alpha$ and $m$.\n\nNo shortcut formulas may be invoked; derive the result directly from the definitions and the structural effect of the adversarial sequence on the probe sequences. The final answer must be a single closed-form analytic expression. No rounding is required.",
            "solution": "The problem statement is validated as being scientifically grounded, well-posed, objective, and complete. It describes a classic worst-case scenario for linear probing in hashing, a standard topic in the analysis of algorithms. The problem is free of any scientific or logical flaws. We may therefore proceed with a solution.\n\nThe task is to first construct a sequence of keys that creates a specific adversarial condition (a single contiguous cluster) and then to derive the expected number of probes for a successful search under this condition.\n\n### Part 1: Adversarial Key Sequence Construction\n\nThe goal is to choose a hash table size $m$ and a sequence of $n$ distinct keys, $k_1, k_2, \\dots, k_n$, such that all keys hash to the same initial table index, thereby generating a single long cluster under linear probing.\n\nLet the hash table size $m$ be an integer satisfying $m > n > 0$.\nThe primary hash function is given as $h(k) = k \\bmod m$.\nTo ensure all keys hash to the same index, we must have $h(k_1) = h(k_2) = \\dots = h(k_n)$. Without loss of generality, let us choose this common hash index to be $0$. This requires that $k_i \\bmod m = 0$ for all $i \\in \\{1, 2, \\dots, n\\}$. This is equivalent to stating that each key $k_i$ must be an integer multiple of $m$.\n\nWe must also ensure the keys are distinct. A simple choice that satisfies both conditions is to define the keys as successive non-zero multiples of $m$. We specify the sequence of keys as:\n$$k_i = i \\cdot m \\quad \\text{for } i = 1, 2, \\dots, n$$\n\nWe verify that this choice of keys meets the required criteria:\n1.  **Distinctness**: Let $i$ and $j$ be two distinct indices in $\\{1, 2, \\dots, n\\}$, so $i \\neq j$. Since $m > n > 0$, it follows that $i \\cdot m \\neq j \\cdot m$. Thus, the keys $k_1, k_2, \\dots, k_n$ are all distinct.\n2.  **Common Hash Index**: For any key $k_i = i \\cdot m$ in the sequence, the hash function yields $h(k_i) = (i \\cdot m) \\bmod m = 0$. All keys hash to the initial index $0$.\n\nNow, we analyze the state of the hash table after inserting these $n$ keys in order into an initially empty table.\n-   **Insertion of $k_1 = 1 \\cdot m$**: The hash index is $h(k_1)=0$. The table slot at index $0$ is empty, so $k_1$ is placed at index $0$. This requires $1$ probe.\n-   **Insertion of $k_2 = 2 \\cdot m$**: The hash index is $h(k_2)=0$. Slot $0$ is now occupied by $k_1$. Linear probing proceeds to the next index, $(0+1) \\bmod m = 1$. Slot $1$ is empty, so $k_2$ is placed at index $1$. This requires $2$ probes (one for slot $0$, one for slot $1$).\n-   **Insertion of $k_3 = 3 \\cdot m$**: The hash index is $h(k_3)=0$. Slot $0$ is occupied. Probing to index $1$ finds it also occupied. Probing to index $(0+2) \\bmod m = 2$ finds an empty slot. So, $k_3$ is placed at index $2$. This requires $3$ probes.\n\nWe can formalize this with a simple inductive argument. Assume that after inserting keys $k_1, \\dots, k_{j-1}$, the table slots with indices $0, 1, \\dots, j-2$ are occupied. Now, consider the insertion of key $k_j = j \\cdot m$. Its hash index is $h(k_j)=0$. The linear probing sequence is $0, 1, 2, \\dots$. The probe will examine slots $0, 1, \\dots, j-2$, all of which are occupied. The next probe is to index $j-1$. Since $j-1  n  m$, this index is within the table bounds and, by our assumption, is empty. Thus, $k_j$ is placed at index $j-1$. The number of probes to insert $k_j$ is $(j-1) - 0 + 1 = j$.\n\nThis process holds for all $j$ from $1$ to $n$. After inserting all $n$ keys, $k_1, \\dots, k_n$, the hash table slots at indices $0, 1, \\dots, n-1$ are occupied. This forms a single contiguous cluster of length $n$, as required by the problem.\n\n### Part 2: Expected Number of Probes for Successful Search\n\nWe are to find the expected number of probes for a successful search, where the key to be searched is drawn uniformly at random from the set of $n$ inserted keys $\\{k_1, k_2, \\dots, k_n\\}$.\n\nThe number of probes required for a successful search for a key is identical to the number of probes that were required to insert that key in the first place. Let $C(k)$ be the number of probes to search for key $k$. From our analysis in Part 1, the number of probes to insert (and thus to find) key $k_i$ is $C(k_i) = i$.\n\nThe keys to be searched are drawn with uniform probability. This means the probability of searching for any particular key $k_i$ is $P(\\text{search } k_i) = \\frac{1}{n}$.\n\nLet $E[C_S]$ be the expected number of probes for a successful search. By the definition of expected value, we have:\n$$E[C_S] = \\sum_{i=1}^{n} C(k_i) \\cdot P(\\text{search } k_i)$$\nSubstituting the values we found:\n$$E[C_S] = \\sum_{i=1}^{n} i \\cdot \\frac{1}{n}$$\nWe can factor the constant $\\frac{1}{n}$ out of the summation:\n$$E[C_S] = \\frac{1}{n} \\sum_{i=1}^{n} i$$\nThe summation is the sum of the first $n$ positive integers, for which there is a well-known closed-form formula:\n$$\\sum_{i=1}^{n} i = \\frac{n(n+1)}{2}$$\nSubstituting this back into the expression for the expected value:\n$$E[C_S] = \\frac{1}{n} \\left( \\frac{n(n+1)}{2} \\right) = \\frac{n+1}{2}$$\nThe problem requires the final answer to be expressed in terms of the load factor $\\alpha = \\frac{n}{m}$ and the table size $m$. From the definition of the load factor, we can express $n$ as $n = \\alpha m$.\n\nSubstituting $n = \\alpha m$ into our result for $E[C_S]$:\n$$E[C_S] = \\frac{(\\alpha m) + 1}{2} = \\frac{\\alpha m + 1}{2}$$\nThis is the final closed-form analytic expression for the expected number of probes for a successful search under the specified adversarial conditions.",
            "answer": "$$\\boxed{\\frac{\\alpha m + 1}{2}}$$"
        },
        {
            "introduction": "After seeing the vulnerability of linear probing, it's natural to turn to more advanced methods like double hashing, which aims to mitigate clustering by using a key-dependent step size. However, the superior performance of double hashing is not guaranteed; it hinges on a crucial number-theoretic requirement. This diagnostic exercise presents a scenario where double hashing fails catastrophically, even at a very low load factor. Your task is to analyze why this failure occurs, solidifying your understanding that the probe sequence must be able to visit every slot in the table, a property guaranteed only when the step size $h_2(k)$ is coprime to the table size $m$. ",
            "id": "3244585",
            "problem": "You are given an open-address hash table with table size $m$ and a standard double hashing scheme. By definition, when inserting a key $k$, the $j$-th probe examines the table index\n$$\ni_j \\equiv h_1(k) + j \\cdot h_2(k) \\pmod m,\n$$\nfor $j \\in \\{0,1,2,\\dots\\}$, stopping as soon as an empty slot is found or reporting failure if no empty slot is encountered before an index repeats. The load factor is $\\alpha \\equiv n/m$, where $n$ is the current number of stored keys.\n\nConsider the following concrete setup designed to isolate the effect of the secondary hash function:\n\n- Table size $m = 64$.\n- Primary hash $h_1(k) \\equiv k \\bmod 64$ (so, for uniformly distributed residues modulo $64$, it is near-perfect).\n- Secondary hash $h_2(k) \\equiv 8$ for all keys (so the step size is fixed).\n- Key sequence $S$ of $9$ keys to be inserted into an initially empty table, in the given order:\n$$\nS = \\{0,\\,64,\\,128,\\,192,\\,256,\\,320,\\,384,\\,448,\\,512\\}.\n$$\n- The load factor after inserting all $9$ keys would be $\\alpha = 9/64$ if all insertions succeeded.\n\nUsing only the core definitions of open addressing with double hashing and fundamental properties of modular arithmetic, select all statements below that are correct about this setup and about how to avoid the pathology it exhibits.\n\nA. With $m=64$, $h_1(k) \\equiv k \\bmod 64$, $h_2(k) \\equiv 8$, and the sequence $S$ as given, the insertion of the $9$-th key fails even though $\\alpha = 9/64$ is small.\n\nB. If, instead, $m$ were any prime and $h_2(k)$ were guaranteed to lie in $\\{1,2,\\dots,m-1\\}$ for every key $k$, then for any insertion sequence no insertion can fail before the table is completely full, because each double-hash probe sequence can visit all $m$ slots.\n\nC. Replacing double hashing by linear probing (that is, using step size $1$) while keeping $m=64$ and $h_1(k) \\equiv k \\bmod 64$ would still fail on the $9$-th insertion for the same sequence $S$.\n\nD. The failure in this setup arises solely because $h_1$ is poor; if $h_1$ is replaced by any permutation on the residues modulo $64$ (that is, any $h_1$ that is a bijection on $\\{0,1,\\dots,63\\}$), the failure disappears even if $h_2(k) \\equiv 8$.\n\nE. For general $m$ and any fixed key $k$, the number of distinct table indices its double-hash probe sequence can reach equals $m / \\gcd(h_2(k), m)$, where $\\gcd$ denotes the greatest common divisor; consequently, if $\\gcd(h_2(k), m) > 1$, the probe sequence for $k$ is confined to a strict subset of the table.",
            "solution": "The problem statement describes an open-address hash table using a double hashing scheme. We are asked to analyze a specific pathological case and evaluate several statements about it and its underlying causes.\n\nFirst, let's validate the problem statement.\nThe givens are:\n- Hash table size: $m = 64$.\n- Primary hash function: $h_1(k) \\equiv k \\bmod 64$.\n- Secondary hash function: $h_2(k) \\equiv 8$ for all keys.\n- Probe sequence formula: $i_j \\equiv h_1(k) + j \\cdot h_2(k) \\pmod m$ for $j \\in \\{0, 1, 2, \\dots\\}$.\n- Key sequence for insertion into an initially empty table: $S = \\{0, 64, 128, 192, 256, 320, 384, 448, 512\\}$. There are $9$ keys in this sequence.\n\nThe problem is scientifically grounded in the principles of data structures and algorithms, specifically hashing. It is well-posed, with all necessary parameters defined. The language is objective and unambiguous. The setup, while demonstrating poor hashing practice, is not invalid as a theoretical exercise. It is a valid problem designed to test the understanding of double hashing mechanics.\n\nWe begin by analyzing the behavior of the given hash functions with the specified key sequence.\nFor every key $k$ in the sequence $S = \\{0, 64, \\dots, 512\\}$, $k$ is an integer multiple of $64$. That is, $k = q \\cdot 64$ for some integer $q \\in \\{0, 1, \\dots, 8\\}$.\nThe primary hash function, $h_1(k) \\equiv k \\bmod 64$, will therefore map every key in $S$ to the same initial index:\n$$h_1(k) = (q \\cdot 64) \\bmod 64 = 0$$\nThis is a case of extreme primary collision: all $9$ keys map to slot $0$.\n\nThe secondary hash function is a constant, $h_2(k) = 8$.\nConsequently, the probe sequence for any key $k \\in S$ is given by:\n$$i_j \\equiv h_1(k) + j \\cdot h_2(k) \\pmod m \\equiv 0 + j \\cdot 8 \\pmod{64} \\equiv 8j \\pmod{64}$$\n\nThe number of distinct indices visited by this probe sequence is given by the general formula $m / \\gcd(h_2(k), m)$, where $\\gcd$ is the greatest common divisor. In this case, the step size is $h_2(k) = 8$ and the table size is $m = 64$.\nThe number of distinct reachable slots is:\n$$ \\frac{m}{\\gcd(h_2(k), m)} = \\frac{64}{\\gcd(8, 64)} = \\frac{64}{8} = 8 $$\nThe probe sequence for any key in $S$ can only visit $8$ distinct slots. The specific slots are $\\{8 \\cdot 0 \\bmod 64, 8 \\cdot 1 \\bmod 64, \\dots, 8 \\cdot 7 \\bmod 64\\}$, which is the set $\\{0, 8, 16, 24, 32, 40, 48, 56\\}$. After $j=7$, the probe sequence repeats, as $i_8 = 8 \\cdot 8 \\bmod 64 = 0 = i_0$.\n\nNow, let's trace the insertion of the keys from $S$:\n1.  Insert $k=0$: Probes index $0$. The slot is empty. It is placed there.\n2.  Insert $k=64$: Probes index $0$ (occupied), then index $0 + 1 \\cdot 8 = 8$ (empty). It is placed at index $8$.\n3.  Insert $k=128$: Probes index $0$ (occupied), $8$ (occupied), then $16$ (empty). It is placed at index $16$.\n...\n8.  Insert $k=448$: Probes indices $0, 8, 16, 24, 32, 40, 48$ (all occupied), then $56$ (empty). It is placed at index $56$.\n\nAfter the first $8$ keys are inserted, all $8$ reachable slots $\\{0, 8, 16, 24, 32, 40, 48, 56\\}$ are filled. The table contains $n=8$ elements, and the load factor is $\\alpha = 8/64 = 1/8$.\n\nNow, consider the insertion of the $9$-th key, $k=512$.\nIts hash values are $h_1(512)=0$ and $h_2(512)=8$. The probe sequence is identical to the previous ones: $0, 8, 16, \\dots, 56$.\nThe insertion algorithm will check slots $0, 8, 16, 24, 32, 40, 48,$ and $56$. It will find all of them occupied. The next probe, for $j=8$, would be index $0$ again. Since the probe sequence has repeated and no empty slot was found, the insertion process fails. This failure occurs even though $64 - 8 = 56$ slots in the table are still empty.\n\nWith this analysis, we can evaluate each option.\n\nA. With $m=64$, $h_1(k) \\equiv k \\bmod 64$, $h_2(k) \\equiv 8$, and the sequence $S$ as given, the insertion of the $9$-th key fails even though $\\alpha = 9/64$ is small.\nAs derived above, after inserting the first $8$ keys, all reachable slots for a key with $h_1(k)=0$ are occupied. The $9$-th key, $k=512$, also has $h_1(512)=0$ and thus probes the same sequence of slots. As all are occupied, the insertion fails. The load factor at the time of this failed insertion attempt is $n/m = 8/64$. The potential load factor if it had succeeded would be $\\alpha=9/64$, which is approximately $0.14$, a small value. The statement is entirely consistent with our derivation.\n**Verdict: Correct.**\n\nB. If, instead, $m$ were any prime and $h_2(k)$ were guaranteed to lie in $\\{1,2,\\dots,m-1\\}$ for every key $k$, then for any insertion sequence no insertion can fail before the table is completely full, because each double-hash probe sequence can visit all $m$ slots.\nThe number of distinct slots visited by a probe sequence is $m / \\gcd(h_2(k), m)$. If $m$ is a prime number, then for any integer $c$ such that $1 \\le c \\le m-1$, it holds that $\\gcd(c, m) = 1$.\nSince $h_2(k)$ is guaranteed to be in $\\{1, 2, \\dots, m-1\\}$, we have $\\gcd(h_2(k), m) = 1$.\nThe number of distinct slots visited is $m / 1 = m$. This means the probe sequence for any key generates a permutation of all table indices $\\{0, 1, \\dots, m-1\\}$.\nTherefore, when attempting to insert a key, its probe sequence will eventually visit every slot in the table. If the table is not full (i.e., at least one empty slot exists), the insertion is guaranteed to find an empty slot and succeed. An insertion can only fail if the table is completely full ($n=m$). The statement is a correct and fundamental principle for designing robust double hashing schemes.\n**Verdict: Correct.**\n\nC. Replacing double hashing by linear probing (that is, using step size $1$) while keeping $m=64$ and $h_1(k) \\equiv k \\bmod 64$ would still fail on the $9$-th insertion for the same sequence $S$.\nLinear probing is equivalent to setting the step size to $1$ for all keys. In the context of the double hashing formula, this corresponds to $h_2(k) = 1$. The probe sequence is $i_j \\equiv h_1(k) + j \\pmod m$.\nAll keys in $S$ still map to $h_1(k)=0$.\n1.  Insert $k=0$: placed at index $0$.\n2.  Insert $k=64$: probes $0$ (occ.), placed at index $1$.\n3.  Insert $k=128$: probes $0, 1$ (occ.), placed at index $2$.\n...\n8.  Insert $k=448$: probes $0, \\dots, 6$ (occ.), placed at index $7$.\n9.  Insert $k=512$: probes $0, \\dots, 7$ (occ.). The next probe is for index $8$, which is empty. The insertion succeeds, placing $k=512$ at index $8$.\nThe insertion does not fail. The reason is that with a step size of $1$, $\\gcd(1, 64) = 1$, so the probe sequence can visit all $64$ slots. The statement claims the insertion would fail, which is false.\n**Verdict: Incorrect.**\n\nD. The failure in this setup arises solely because $h_1$ is poor; if $h_1$ is replaced by any permutation on the residues modulo $64$ (that is, any $h_1$ that is a bijection on $\\{0,1,\\dots,63\\}$), the failure disappears even if $h_2(k) \\equiv 8$.\nThe statement claims the failure is *solely* due to $h_1$. The failure mechanism has two components: first, $h_1$ maps all keys in $S$ to the same slot, creating a primary collision cluster; second, $h_2$ generates a short probe sequence because $\\gcd(h_2(k), m)  1$.\nIf $h_1$ were a permutation, the $9$ distinct keys in $S$ would map to $9$ distinct initial slots. Each key would be inserted into its initial slot without any collisions. The failure would indeed disappear for this specific sequence $S$.\nHowever, the word \"solely\" is critical. It implies that $h_2$ is not a cause. This is false. As shown in the analysis of option C, if we keep the \"poor\" $h_1$ but use a better $h_2$ (like $h_2(k) = 1$ for linear probing), the failure also disappears. Since fixing $h_2$ while keeping $h_1$ also solves the problem for this sequence, $h_1$ cannot be the sole cause. The pathology is a combined effect of primary collisions from $h_1$ and the deficient probe sequence length from $h_2$.\n**Verdict: Incorrect.**\n\nE. For general $m$ and any fixed key $k$, the number of distinct table indices its double-hash probe sequence can reach equals $m / \\gcd(h_2(k), m)$, where $\\gcd$ denotes the greatest common divisor; consequently, if $\\gcd(h_2(k), m) > 1$, the probe sequence for $k$ is confined to a strict subset of the table.\nThe probe sequence is an arithmetic progression modulo $m$: $p_j = a + j \\cdot s \\pmod m$, where $a=h_1(k)$ and $s=h_2(k)$. The set of values generated by this sequence is a coset of the cyclic subgroup generated by $s$ in the additive group of integers modulo $m$, $\\mathbb{Z}_m$. The order (size) of this subgroup is $|\\langle s \\rangle| = m / \\gcd(s, m)$. A coset has the same size as the subgroup. Thus, the number of distinct indices in the probe sequence is precisely $m / \\gcd(h_2(k), m)$.\nThe consequence follows directly: if $\\gcd(h_2(k), m)  1$, then the denominator is greater than $1$, which means the number of reachable indices $m / \\gcd(h_2(k), m)$ is strictly less than $m$. Therefore, the probe sequence is confined to a strict subset of the table. This statement is a correct and fundamental theorem from number theory applied to hashing.\n**Verdict: Correct.**\n\nIn summary, statements A, B, and E are correct.",
            "answer": "$$\\boxed{ABE}$$"
        },
        {
            "introduction": "Theory and thought experiments provide the foundation, but seeing algorithms in action provides true intuition. This final practice is a comprehensive coding exercise where you will build a test harness to empirically compare linear, quadratic, and double hashing. By systematically testing all insertion orders for given key sets, you will generate quantitative data on clustering and probing costs. This hands-on simulation will allow you to directly observe the practical consequences of different probing strategies: you will see how linear probing's performance is highly sensitive to insertion order, while well-designed double hashing offers more stable and predictable behavior, reinforcing the theoretical concepts in a tangible way. ",
            "id": "3244620",
            "problem": "You are asked to write a complete, runnable program that constructs a systematic test harness for open addressing hash tables and quantitatively demonstrates how insertion order affects cluster shape and probing cost under different probing strategies. The focus is on linear probing, quadratic probing, and double hashing.\n\nStart from the following fundamental base:\n- A hash table with open addressing stores each key in exactly one slot of a fixed-size array of size $m$. To insert a key $k$, we consider a probing sequence of indices, examine them in order, and place $k$ in the first empty slot encountered.\n- A hash function maps keys to initial indices modulo $m$.\n- For a given probing scheme, the probing sequence for key $k$ is defined by a deterministic function of $k$ and the probe count $t$, evaluated modulo $m$.\n\nDefinitions used in this problem:\n- For each key $k$, define the primary hash as $h(k) = k \\bmod m$.\n- Linear probing: the probing sequence is $h(k), h(k)+1, h(k)+2, \\dots$ modulo $m$.\n- Quadratic probing: the probing sequence is $h(k) + c_1 t + c_2 t^2$ modulo $m$ with constants $c_1 = 1$ and $c_2 = 1$. The probe index at attempt $t$ is thus $h(k) + t + t^2 \\pmod m$. If an empty slot is not found within $m$ probes, the insertion fails for that permutation under quadratic probing.\n- Double hashing: define the secondary step as $h_2(k) = 1 + (k \\bmod (m-1))$. The probing sequence is $h(k), h(k) + h_2(k), h(k) + 2 h_2(k), \\dots$ modulo $m$. Assume $m$ is prime so that $h_2(k)$ is coprime to $m$.\n\nClustering metric:\n- Consider the occupancy of the table after inserting all keys from a given set in a given order. A cluster is defined as a maximal contiguous run of occupied slots on the cyclic array of length $m$. Let the lengths of all such clusters (between empty slots) be collected into a multiset. The cluster signature of the table state is defined as the sorted list of these lengths. This signature depends on the final occupancy pattern but is invariant under rotation of the ring. For example, if $m=11$ and the occupied slots form three runs of lengths $[4,2,1]$, the cluster signature is $[1,2,4]$.\n- Probing cost metric: For an insertion of a key, the number of probes is the number of examined slots until the key is placed (including the successful slot). The total probing cost of a complete insertion order for a key set is the sum of probes over all inserted keys.\n\nYour task:\n- For each test case below, consider the identical set of keys and enumerate all permutations of their insertion order. For each probing scheme (linear, quadratic, double), simulate open addressing insertions for every permutation and compute:\n  1) The number of distinct cluster signatures observed across all permutations that successfully insert all keys for that scheme.\n  2) The minimum total probing cost over all such permutations.\n  3) The maximum total probing cost over all such permutations.\n- If a permutation leads to an insertion failure under quadratic probing (i.e., no empty slot found for some key within $m$ probes), exclude that permutation from all of its metrics; still include all other permutations that succeed. For linear probing and double hashing, with the given parameters, all permutations will succeed.\n\nTest suite:\n- Case 1: Table size $m = 11$, keys $K = [10,21,32,43,54]$.\n- Case 2: Table size $m = 13$, keys $K = [0,13,26,39,1,14]$.\n- Case 3: Table size $m = 17$, keys $K = [16,33,50,67,1,18,35]$.\n\nAll keys are integers and all $m$ are primes, with load factor less than or equal to $0.5$ to ensure realistic open addressing behavior.\n\nFinal output format:\n- Your program should produce a single line of output containing a list with one entry per test case, in order. Each entry must itself be a list of three entries, corresponding to linear probing, quadratic probing, and double hashing, respectively. For each probing scheme, output a list of three integers: $[\\text{distinct\\_signatures}, \\text{min\\_total\\_probes}, \\text{max\\_total\\_probes}]$.\n- Concretely, the final single line must look like:\n  - $[[a_1,b_1,c_1],[a_2,b_2,c_2],[a_3,b_3,c_3]],[[d_1,e_1,f_1],[d_2,e_2,f_2],[d_3,e_3,f_3]],[[g_1,h_1,i_1],[g_2,h_2,i_2],[g_3,h_3,i_3]]$ enclosed in one outer pair of brackets. There must be no additional text.\n- Example schema (not actual results): $[[1,10,14],[2,9,15],[1,8,12]],[[3,20,28],[2,18,27],[1,16,22]],[[5,24,35],[4,23,34],[2,20,30]]$.\n\nAngle units and physical units do not apply. All requested answers are integers. Your program must be fully self-contained and must not read any input. It must compute and print the single final line described above.",
            "solution": "The problem is subjected to validation before a solution is attempted.\n\n### Step 1: Extract Givens\n-   **Hash Table**: An open addressing hash table with a fixed-size array of size $m$.\n-   **Primary Hash Function**: $h(k) = k \\bmod m$.\n-   **Probing Strategies**:\n    1.  **Linear Probing**: The probe at attempt $t \\ge 0$ is $(h(k) + t) \\pmod m$.\n    2.  **Quadratic Probing**: The probe at attempt $t \\ge 0$ is $(h(k) + c_1 t + c_2 t^2) \\pmod m$, with constants $c_1 = 1$ and $c_2 = 1$. An insertion fails if no empty slot is found within $m$ probes.\n    3.  **Double Hashing**: The probe at attempt $t \\ge 0$ is $(h(k) + t \\cdot h_2(k)) \\pmod m$, with the secondary hash function $h_2(k) = 1 + (k \\bmod (m-1))$. It is assumed $m$ is prime.\n-   **Metrics**:\n    1.  **Cluster Signature**: A sorted list of the lengths of all maximal contiguous runs of occupied slots in the cyclic table array.\n    2.  **Total Probing Cost**: The sum of probes for all keys in a given insertion sequence, where the probes for a single key is the number of slots examined before placement.\n-   **Task**: For each test case, iterate through all permutations of the key insertion order. For each of the three probing schemes, calculate:\n    1.  The number of distinct cluster signatures across all successful permutations.\n    2.  The minimum total probing cost across all successful permutations.\n    3.  The maximum total probing cost across all successful permutations.\n-   **Exclusion Condition**: For quadratic probing, any permutation that results in an insertion failure is excluded from the metric calculations for that scheme.\n-   **Test Suite**:\n    -   Case 1: $m = 11$, Keys $K = [10, 21, 32, 43, 54]$.\n    -   Case 2: $m = 13$, Keys $K = [0, 13, 26, 39, 1, 14]$.\n    -   Case 3: $m = 17$, Keys $K = [16, 33, 50, 67, 1, 18, 35]$.\n-   **Output Format**: A single line representing a nested list of results: `[[case1_results], [case2_results], [case3_results]]`, where each `case_results` is `[[linear_metrics], [quadratic_metrics], [double_hashing_metrics]]`, and each `metrics` is `[distinct_signatures, min_total_probes, max_total_probes]`.\n\n### Step 2: Validate Using Extracted Givens\nThe problem statement is evaluated for validity.\n1.  **Scientific Grounding**: The problem is well-grounded in the fundamental principles of data structures and algorithms, specifically concerning hash tables and open addressing. The definitions for linear, quadratic, and double hashing are standard and correctly specified. The use of a prime modulus $m$ and the specific form of $h_2(k)$ are best practices for double hashing to ensure the entire table is searched.\n2.  **Well-Posedness**: The problem is well-posed. The inputs are clearly defined, the required computations are deterministic, and the desired outputs are unambiguously specified. The number of permutations for each key set ($5! = 120$, $6! = 720$, $7! = 5040$) is finite and computationally manageable, ensuring a unique solution can be derived.\n3.  **Objectivity**: The problem is stated in precise, objective, and mathematical language. Definitions for metrics like \"cluster signature\" and \"total probing cost\" are explicit, leaving no room for subjective interpretation.\n4.  **Completeness and Consistency**: The problem is self-contained. All necessary parameters ($m$, $K$, probing constants) and definitions are provided. The condition for failure in quadratic probing is clearly stated. The stated load factors ($\\alpha = |K|/m \\le 0.5$) are realistic for open addressing and guarantee success for linear and double hashing, as asserted.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. It is a rigorous computational exercise in computer science, free of any scientific, logical, or structural flaws. A complete solution will be provided.\n\n### Solution\nThe solution requires a systematic simulation and analysis of hash table performance under different conditions. The core of the methodology is to enumerate all possible insertion orders for a given set of keys and, for each order, simulate the insertion process for each of the three specified open addressing schemes.\n\n**Methodology**\n\n1.  **Systematic Enumeration**: For each test case, defined by a table size $m$ and a key set $K$, we generate all $|K|!$ permutations of the keys. This ensures that every possible insertion order is examined. The `itertools.permutations` library function in Python is suitable for this task.\n\n2.  **Hash Table Simulation**: For each permutation and each probing scheme, we simulate the insertion of keys into an initially empty hash table of size $m$. The hash table is represented as an array, initialized to a null state (e.g., `None`). For each key to be inserted:\n    -   We generate the probe sequence according to the specified formula for the active scheme (linear, quadratic, or double hashing). The probe attempt counter $t$ starts at $0$.\n    -   The probe sequence is $p(k, t) = (h(k) + f(t)) \\pmod m$, where $f(t)$ is the probing function:\n        -   Linear: $f(t) = t$.\n        -   Quadratic: $f(t) = t + t^2$.\n        -   Double Hashing: $f(t) = t \\cdot h_2(k)$, with $h_2(k) = 1 + (k \\bmod (m-1))$.\n    -   We traverse the probe sequence, counting the number of probes, until an empty slot is found. The key is then placed in this slot.\n    -   The number of probes for this key is added to a running total for the current permutation.\n    -   For quadratic probing, if the simulation loop completes $m$ attempts without finding an empty slot, the insertion is marked as a failure for that permutation, and this permutation's data is discarded for the quadratic probing scheme, as per the problem's rules.\n\n3.  **Metric Computation**: Upon the successful insertion of all keys for a given permutation:\n    -   **Total Probing Cost**: This is the accumulated sum of probes for all keys in that permutation.\n    -   **Cluster Signature**: This metric characterizes the final configuration of occupied slots. To compute it, we first represent the table's occupancy as a binary sequence (e.g., $1$ for occupied, $0$ for empty). To handle the cyclic nature of the table, we linearize the sequence by cyclically shifting it to start at the first empty slot. This does not alter the lengths or relative positions of clusters. We then split this linearized sequence by empty slots ('$0$') and collect the lengths of the resulting contiguous blocks of occupied slots ('$1$s'). These lengths are sorted to produce the canonical cluster signature.\n\n4.  **Aggregation of Results**: After iterating through all permutations, we aggregate the results for each probing scheme:\n    -   We collect all unique cluster signatures encountered across all successful permutations into a set to count the number of distinct signatures.\n    -   We track the minimum and maximum total probing costs observed across all successful permutations.\n\nThis complete process is repeated for each of the three test cases. The final results are assembled into the required nested list structure and formatted as a single-line string with no spaces. The provided Python implementation meticulously follows this logic.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport itertools\n\ndef solve():\n    \"\"\"\n    Constructs a test harness for open addressing hash tables to analyze the effect\n    of insertion order on clustering and probing cost for linear probing, quadratic\n    probing, and double hashing.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (m, K)\n        (11, [10, 21, 32, 43, 54]),\n        (13, [0, 13, 26, 39, 1, 14]),\n        (17, [16, 33, 50, 67, 1, 18, 35]),\n    ]\n\n    all_test_results = []\n\n    for m, K in test_cases:\n        \n        case_results = []\n        probe_types = ['linear', 'quadratic', 'double']\n\n        for probe_type in probe_types:\n            signatures = set()\n            min_probes = float('inf')\n            max_probes = float('-inf')\n            successful_perms = 0\n\n            for p in itertools.permutations(K):\n                table = [None] * m\n                total_probes_for_p = 0\n                is_successful = True\n\n                for key in p:\n                    probes_for_key = 0\n                    inserted = False\n                    for t in range(m):\n                        probes_for_key += 1\n                        h_k = key % m\n                        \n                        if probe_type == 'linear':\n                            idx = (h_k + t) % m\n                        elif probe_type == 'quadratic':\n                            # probe function is h(k) + t + t^2\n                            idx = (h_k + t + t**2) % m\n                        else:  # double\n                            h2_k = 1 + (key % (m - 1))\n                            idx = (h_k + t * h2_k) % m\n                        \n                        if table[idx] is None:\n                            table[idx] = key\n                            total_probes_for_p += probes_for_key\n                            inserted = True\n                            break\n                    \n                    if not inserted:\n                        is_successful = False\n                        break\n                \n                if is_successful:\n                    successful_perms += 1\n                    \n                    # Calculate cluster signature\n                    occupied = [1 if slot is not None else 0 for slot in table]\n                    \n                    if all(occ == 1 for occ in occupied):\n                        cluster_lengths = [m]\n                    elif not any(occ == 1 for occ in occupied):\n                        cluster_lengths = []\n                    else:\n                        occupied_str = \"\".join(map(str, occupied))\n                        first_zero_idx = occupied_str.find('0')\n                        # Linearize the cyclic array by breaking at the first empty slot\n                        linearized_str = occupied_str[first_zero_idx:] + occupied_str[:first_zero_idx]\n                        clusters = linearized_str.split('0')\n                        cluster_lengths = sorted([len(c) for c in clusters if c])\n\n                    # Add the immutable tuple representation to the set\n                    signatures.add(tuple(cluster_lengths))\n                    min_probes = min(min_probes, total_probes_for_p)\n                    max_probes = max(max_probes, total_probes_for_p)\n\n            if successful_perms == 0:\n                # Fallback for the case where no permutations succeed.\n                # Per problem description and analysis, this path is not expected to be taken.\n                scheme_results = [0, 0, 0]\n            else:\n                scheme_results = [len(signatures), min_probes, max_probes]\n            \n            case_results.append(scheme_results)\n            \n        all_test_results.append(case_results)\n\n    # Final print statement in the exact required format.\n    # The output is a string representation of the list, with all whitespace removed.\n    output_str = str(all_test_results).replace(\" \", \"\")\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}