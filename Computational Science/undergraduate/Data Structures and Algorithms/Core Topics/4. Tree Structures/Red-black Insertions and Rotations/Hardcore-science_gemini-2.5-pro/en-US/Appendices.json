{
    "hands_on_practices": [
        {
            "introduction": "Mastering red-black trees begins with a solid grasp of their core maintenance operations. This first exercise provides a direct, hands-on opportunity to trace the insertion fix-up procedure on a pre-existing tree. By predicting the exact sequence of recolorings and rotations triggered by a new key, you will reinforce your understanding of the conditions for each case in the fix-up algorithm .",
            "id": "3266139",
            "problem": "Consider a binary search tree (BST) augmented with red-black properties (commonly called a red-black tree), where the following core definitions hold: the root is black, every node is either red or black, every red node has black children, and every path from the root to a leaf contains the same number of black nodes (the black-height). Insertion proceeds by placing the new key as in a BST, initially coloring the new node red, and then restoring the red-black properties using local recoloring (only when both the parent and the uncle of the newly inserted node are red) and rotations (Left, Right, Left-Right, Right-Left) determined by the orientation of the parent-child relationships.\n\nLet $T$ be a valid red-black tree with keys and colors as follows. The root is the key $50$ colored black. Its left child is the key $30$ colored red, and its right child is the key $70$ colored black. The node $30$ has two children: the key $20$ colored black on the left, and the key $40$ colored black on the right. The node $20$ has two children: the key $15$ colored red on the left, and the key $25$ colored red on the right. All other children not explicitly mentioned are leaves and are black.\n\nWithout drawing or simulating the operations on $T$, use the red-black properties and the insertion restoration rules to predict the exact sequence of balancing operations triggered when inserting the key $k=23$. For the purposes of the final numerical answer, encode the sequence in temporal order using the mapping $L \\mapsto 1$, $R \\mapsto 2$, $\\text{LR} \\mapsto 3$, $\\text{RL} \\mapsto 4$, and a recoloring step when both the parent and the uncle are red (call this a color flip) $C \\mapsto 5$. If the sequence comprises $m$ steps with codes $c_{1},c_{2},\\ldots,c_{m}$, define the encoding integer by\n$$\nE \\;=\\; \\sum_{i=1}^{m} c_{i}\\,10^{\\,m-i}.\n$$\nReturn the single number $E$ as your final answer. No rounding is required.",
            "solution": "We start from the red-black tree invariants and the binary search tree (BST) insertion mechanism. The insertion of a key proceeds by placing the new key in its BST position and initially coloring the new node red. Any subsequent violations are repaired using local recoloring and rotations, guided by the following established facts:\n\n1. If the newly inserted node has a red parent and a red uncle, a color flip is performed at the grandparent: the parent and uncle are recolored black and the grandparent is recolored red, after which the restoration continues from the grandparent.\n2. If the newly inserted node has a red parent and a black uncle, rotations are needed. The specific rotation type depends on whether the local configuration is left-left, left-right, right-right, or right-left relative to the grandparent. In left-left, perform a right rotation at the grandparent; in right-right, perform a left rotation at the grandparent; in left-right, first a left rotation at the parent followed by a right rotation at the grandparent; in right-left, first a right rotation at the parent followed by a left rotation at the grandparent. After rotations, recoloring is performed locally to restore the red-black properties, and the loop terminates once the parent of the current node is black.\n\nNow we determine the BST location for the key $k=23$ in $T$:\n- Compare $23$ with $50$: since $23<50$, go to the left child $30$.\n- Compare $23$ with $30$: since $23<30$, go to the left child $20$.\n- Compare $23$ with $20$: since $23>20$, go to the right child $25$.\n- Compare $23$ with $25$: since $23<25$, the insertion location is the left child of $25$.\n\nThus the new node with key $23$ is inserted as the left child of the node $25$ and is initially colored red.\n\nImmediately after insertion, examine the local configuration around the newly inserted red node:\n- The parent is the node $25$, which is red.\n- The uncle is the sibling of the parent, which is the node $15$, and this node is red.\n- The grandparent is the node $20$, which is black.\n\nBecause both the parent and the uncle are red, we perform a color flip at the grandparent $20$. According to the recoloring rule, $25$ becomes black, $15$ becomes black, and $20$ becomes red. After this recoloring, the current node for continued restoration is the grandparent, namely the node $20$ (now red). This constitutes one color flip step, encoded as $C \\mapsto 5$.\n\nNext, we check for any violation with the current node $20$ and its parent:\n- The parent of $20$ is $30$, which is red.\n- The uncle of $20$ at this level is the node $40$, which is black.\n- The grandparent at this level is $50$, which is black.\n- The orientation is as follows: $20$ is the left child of $30$, and $30$ is the left child of $50$, which is the left-left case relative to $50$.\n\nWith a red parent and black uncle in the left-left configuration, the remedy is a right rotation at the grandparent $50$, followed by local recoloring. Performing a right rotation at $50$ places $30$ as the root of the subtree, with $50$ becoming its right child and $20$ its left child. The standard recoloring for this case makes $30$ black and $50$ red, restoring the red-black properties locally and breaking the red-red chain. This constitutes one right rotation step, encoded as $R \\mapsto 2$.\n\nAfter this rotation, the parent of the current node is black, so the fix-up terminates. The exact sequence of balancing operations, in temporal order, is therefore:\n- First, a color flip ($C$).\n- Second, a right rotation ($R$).\n\nUsing the prescribed encoding $L \\mapsto 1$, $R \\mapsto 2$, $\\text{LR} \\mapsto 3$, $\\text{RL} \\mapsto 4$, $C \\mapsto 5$, the sequence $(C, R)$ corresponds to the code sequence $(5, 2)$. The encoding integer is computed by\n$$\nE \\;=\\; \\sum_{i=1}^{m} c_{i}\\,10^{\\,m-i} \\;=\\; 5\\cdot 10^{\\,2-1} \\;+\\; 2\\cdot 10^{\\,2-2} \\;=\\; 5\\cdot 10 \\;+\\; 2\\cdot 1 \\;=\\; 50 \\;+\\; 2 \\;=\\; 52.\n$$\nTherefore, the required final number is $52$.",
            "answer": "$$\\boxed{52}$$"
        },
        {
            "introduction": "Beyond simply applying the rules, a deeper understanding of red-black trees involves knowing how to engineer specific outcomes. This problem challenges you to think like a test-case designer, constructing a minimal sequence of insertions that triggers the most complex fix-up scenario: a double rotation. Solving this requires a precise understanding of the 'inner child' configuration and how the fix-up logic transitions between cases .",
            "id": "3266096",
            "problem": "A Red-Black Tree (RBT) is a Binary Search Tree (BST) augmented with the following invariants: (i) each node is either red or black, (ii) the root is black, (iii) all external null leaves are black, (iv) no red node has a red child, and (v) every simple path from a node to any external leaf contains the same number of black nodes (black-height). Insertion proceeds by first inserting the new key as in a BST and coloring it red, then restoring invariants by a finite sequence of local recolorings and rotations. In the standard textbook fix-up, let the newly inserted node be $z$, its parent be $P$, its grandparent be $G$, and its uncle be $U$. While $P$ is red: \n- Case $1$: $U$ is red. Recolor $P$ and $U$ to black, $G$ to red, and continue with $z \\leftarrow G$. \n- Case $2$: $U$ is black and $z$ is an inner child (left-right or right-left relative to $G$). Rotate once about $P$ to transform into Case $3$. \n- Case $3$: $U$ is black and $z$ is an outer child (left-left or right-right relative to $G$). Rotate once about $G$ and recolor appropriately. Finally, recolor the root black.\n\nA single insertion can trigger at most $2$ rotations in this algorithm. Your task is to identify a minimal example (fewest total inserted keys) in which a single insertion requires exactly $2$ rotations during its fix-up, and to correctly state which case transitions produce those $2$ rotations for that insertion.\n\nChoose all options that simultaneously: \n- provide a minimal insertion sequence of distinct integer keys into an initially empty tree whose last insertion triggers exactly $2$ rotations during that insertion’s fix-up, and \n- correctly identify the case-transition explanation for those $2$ rotations, using the case numbering above.\n\nA. Insert in order $[10, 5, 7]$. Explanation: the last insertion’s fix-up performs $\\text{case }2$ followed by $\\text{case }3$ at the same grandparent, yielding exactly $2$ rotations.\n\nB. Insert in order $[10, 5, 1, 7]$. Explanation: the last insertion’s fix-up performs $\\text{case }1$ followed by $\\text{case }3$, yielding exactly $2$ rotations.\n\nC. Insert in order $[10, 15, 12]$. Explanation: the last insertion’s fix-up performs $\\text{case }2$ followed by $\\text{case }3$ (mirror image of left-right), yielding exactly $2$ rotations.\n\nD. Insert in order $[10, 5, 7]$. Explanation: the last insertion’s fix-up performs $\\text{case }1$ followed by $\\text{case }3$, yielding exactly $2$ rotations.\n\nE. Insert in order $[10, 5, 3]$. Explanation: the last insertion’s fix-up is $\\text{case }3$ only, yielding exactly $2$ rotations.",
            "solution": "The problem requires identifying minimal insertion sequences into a Red-Black Tree that cause exactly $2$ rotations during the fix-up of the final insertion, along with the correct explanation for these rotations based on the provided case definitions.\n\nThe core of the problem is to understand how rotations are generated by the fix-up algorithm. Let's analyze the number of rotations produced by each case:\n- **Case $1$**: The uncle $U$ is red. This case involves only recoloring nodes and propagating the problem up the tree by setting $z \\leftarrow G$. It performs **zero** rotations.\n- **Case $2$**: The uncle $U$ is black and $z$ is an inner child. This case performs **one** rotation about the parent $P$. The explicit purpose of this case is to transform the structure into a Case $3$ configuration.\n- **Case $3$**: The uncle $U$ is black and $z$ is an outer child. This case performs **one** rotation about the grandparent $G$ and then terminates the loop.\n\nA single insertion can trigger at most $2$ rotations. To achieve exactly $2$ rotations, the fix-up process must execute a sequence of case handlers that sum to $2$ rotations.\nBased on the definitions:\n- A `Case 1 -> Case 3` sequence would involve zero rotations from Case $1$, followed by one rotation from Case $3$ at a higher level in the tree, for a total of $1$ rotation.\n- A `Case 3` only situation yields $1$ rotation.\n- The only way to achieve exactly $2$ rotations is to first encounter **Case $2$**, which performs $1$ rotation, and which by definition transforms the subtree into a **Case $3$** configuration. This Case $3$ is then immediately handled, performing a second rotation and terminating the fix-up.\n\nTherefore, the only mechanism that produces exactly $2$ rotations is the sequence **Case $2 \\rightarrow$ Case $3$**. This occurs when fixing a double-red violation involving an \"inner child\" (a left-right or right-left zig-zag configuration relative to the grandparent). Now, we evaluate each option based on this principle.\n\nA minimal example requires a grandparent-parent-child structure, which implies a minimum of $3$ nodes. Both options A and C propose sequences of $3$ keys.\n\n**Option A: Insert in order $[10, 5, 7]$. Explanation: the last insertion’s fix-up performs $\\text{case }2$ followed by $\\text{case }3$ at the same grandparent, yielding exactly $2$ rotations.**\n\n1.  Insert $10$: The tree is a single black node, $10(\\text{B})$.\n2.  Insert $5$: The tree is $10(\\text{B}) \\leftarrow 5(\\text{R})$. This is a valid RBT.\n3.  Insert $7$:\n    -   Standard BST insertion places $7$ as the right child of $5$. The tree is $10(\\text{B}) \\leftarrow 5(\\text{R}) \\rightarrow 7(\\text{R})$.\n    -   This creates a violation: the parent of $7(\\text{R})$, which is $5(\\text{R})$, is also red.\n    -   In the fix-up for $z=7$: Parent $P=5$, Grandparent $G=10$. The uncle $U$ (right child of $10$) is a null leaf, which is black.\n    -   $P$ is a left child of $G$, and $z$ is a right child of $P$. This is a \"left-right\" configuration, which is an inner child. This is **Case $2$**.\n    -   Action for Case $2$: A single left rotation is performed on $P=5$. This is the **first rotation**. The subtree under $G=10$ now has $7(\\text{R})$ as its left child, which in turn has $5(\\text{R})$ as its left child.\n    -   This transforms the structure into a \"left-left\" outer child configuration. This is now **Case $3$**.\n    -   Action for Case $3$: A single right rotation is performed on $G=10$, along with recoloring. This is the **second rotation**.\n    -   The fix-up terminates. The total number of rotations is exactly $2$. The explanation is correct.\n    -   **Verdict: Correct.**\n\n**Option B: Insert in order $[10, 5, 1, 7]$. Explanation: the last insertion’s fix-up performs $\\text{case }1$ followed by $\\text{case }3$, yielding exactly $2$ rotations.**\n\n1.  Insert $10, 5, 1$: After these insertions, the tree becomes $5(\\text{B})$ with children $1(\\text{R})$ and $10(\\text{R})$.\n2.  Insert $7$:\n    -   BST insertion places $7$ as the left child of $10$. Tree: $5(\\text{B}) \\rightarrow 10(\\text{R}) \\leftarrow 7(\\text{R})$.\n    -   Violation: The parent of $7(\\text{R})$, $P=10(\\text{R})$, is red.\n    -   In the fix-up for $z=7$: $P=10$, $G=5$. The uncle $U$ is the other child of $G=5$, which is $1(\\text{R})$.\n    -   Since the uncle $U=1$ is red, this is **Case $1$**.\n    -   Action for Case $1$: Recolor $P(10)$ and $U(1)$ to black, and recolor $G(5)$ to red. $z$ is updated to $G=5$. Node $5$ is the root, so its parent is black (null). The loop `while P is red` terminates. The final step is to color the root black. Case $1$ performs **zero** rotations.\n    -   The insertion of $7$ causes zero rotations. The explanation is factually incorrect as it claims $2$ rotations occurred, and the case sequence `Case 1 -> Case 3` would only yield $1$ rotation anyway.\n    -   **Verdict: Incorrect.**\n\n**Option C: Insert in order $[10, 15, 12]$. Explanation: the last insertion’s fix-up performs $\\text{case }2$ followed by $\\text{case }3$ (mirror image of left-right), yielding exactly $2$ rotations.**\n\n1.  Insert $10$: The tree is a single black node, $10(\\text{B})$.\n2.  Insert $15$: The tree is $10(\\text{B}) \\rightarrow 15(\\text{R})$.\n3.  Insert $12$:\n    -   BST insertion places $12$ as the left child of $15$. Tree: $10(\\text{B}) \\rightarrow 15(\\text{R}) \\leftarrow 12(\\text{R})$.\n    -   Violation: The parent of $12(\\text{R})$, $P=15(\\text{R})$, is red.\n    -   In the fix-up for $z=12$: $P=15$, $G=10$. The uncle $U$ (left child of $10$) is a null leaf, which is black.\n    -   $P$ is a right child of $G$, and $z$ is a left child of $P$. This is a \"right-left\" configuration, the mirror image of option A. It is an inner child case. This is **Case $2$**.\n    -   Action for Case $2$: A single right rotation is performed on $P=15$. This is the **first rotation**.\n    -   This transforms the structure into a \"right-right\" outer child configuration. This is now **Case $3$**.\n    -   Action for Case $3$: A single left rotation is performed on $G=10$. This is the **second rotation**.\n    -   The fix-up terminates, having performed exactly $2$ rotations. The explanation is correct.\n    -   **Verdict: Correct.**\n\n**Option D: Insert in order $[10, 5, 7]$. Explanation: the last insertion’s fix-up performs $\\text{case }1$ followed by $\\text{case }3$, yielding exactly $2$ rotations.**\n\n-   The insertion sequence is the same as in option A. As established, the fix-up performs a `Case 2 -> Case 3` sequence. This option provides an incorrect explanation, `Case 1 -> Case 3`. A `Case 1` situation does not even occur. Furthermore, a `Case 1 -> Case 3` sequence would result in only $1$ rotation, not $2$. Therefore, the explanation is incorrect.\n-   **Verdict: Incorrect.**\n\n**Option E: Insert in order $[10, 5, 3]$. Explanation: the last insertion’s fix-up is $\\text{case }3$ only, yielding exactly $2$ rotations.**\n\n1.  Insert $10$: $10(\\text{B})$.\n2.  Insert $5$: $10(\\text{B}) \\leftarrow 5(\\text{R})$.\n3.  Insert $3$:\n    -   BST insertion places $3$ as the left child of $5$. Tree: $10(\\text{B}) \\leftarrow 5(\\text{R}) \\leftarrow 3(\\text{R})$.\n    -   Violation: The parent of $3(\\text{R})$, $P=5(\\text{R})$, is red.\n    -   In the fix-up for $z=3$: $P=5$, $G=10$. The uncle $U$ is black (null leaf).\n    -   $P$ is a left child of $G$, and $z$ is a left child of $P$. This is a \"left-left\" configuration, an outer child. This is **Case $3$** directly.\n    -   Action for Case $3$: Perform one rotation (right rotation on $G=10$) and recolor. The fix-up terminates.\n    -   This insertion yields exactly **one** rotation. The explanation incorrectly claims it yields $2$.\n    -   **Verdict: Incorrect.**\n\nIn summary, both options A and C provide minimal $3$-key insertion sequences where the final insertion triggers exactly $2$ rotations, and both provide the correct `Case 2 -> Case 3` explanation of this phenomenon.",
            "answer": "$$\\boxed{AC}$$"
        },
        {
            "introduction": "The robustness of an algorithm often lies in details that can seem minor, such as pointer updates. This final practice places you in the role of a debugger, tasked with analyzing a faulty rotation implementation. Your goal is to devise a sequence of insertions that exposes the bug by causing a violation of the red-black tree invariants, demonstrating why every step in the canonical algorithm is essential for correctness .",
            "id": "3266135",
            "problem": "Consider a Red-Black Tree (RBT) that maintains the following invariants: (i) the root is colored black, (ii) every leaf (the sentinel $\\mathsf{nil}$) is colored black, (iii) no red node has a red child, and (iv) for each node, all simple paths from the node to descendant leaves contain the same number of black nodes (equal black-height). The standard insertion procedure first inserts a new key as in a binary search tree (BST) and colors the new node red, then applies the widely used fix-up routine from Introduction to Algorithms (third edition) by Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein (CLRS) to restore the RBT invariants. Rotations are performed by the fix-up routine as needed; the sentinel $\\mathsf{nil}$ is used as a shared black leaf, and parent pointers are used as in the CLRS implementation.\n\nAssume the LeftRotate operation is implemented with the following bug: when performing a left rotation on a node $x$ with right child $y$, the implementation omits the assignment $x.\\mathrm{p} \\leftarrow y$ (the parent pointer of $x$ is not updated to point to $y$). All other assignments follow the standard CLRS LeftRotate specification, including $y.\\mathrm{p}$ being updated appropriately and child pointers being adjusted correctly. The RightRotate operation is implemented correctly. After each insertion, the CLRS insertion fix-up procedure is run to completion.\n\nStarting from an empty RBT, which of the following insertion sequences provides a minimal counterexample in the sense that, after all keys in the sequence have been inserted and the (buggy) fix-up has been applied, the tree violates at least one RBT invariant while its left/right child pointers still represent a valid BST?\n\nA. Insert $10$, then $20$, then $30$, then $5$.\n\nB. Insert $10$, then $20$, then $30$, then $25$.\n\nC. Insert $10$, then $5$, then $1$, then $0$.\n\nD. Insert $10$, then $2$, then $3$, then $4$.\n\nOnly choose an option that unambiguously demonstrates an RBT invariant violation caused by the stated LeftRotate parent-pointer bug, not due to incorrect BST ordering or other unspecified failures. Justify the choice based on first principles: the Red-Black Tree invariants, the CLRS insertion fix-up logic, and the pointer semantics of rotations.",
            "solution": "The problem asks for an insertion sequence that exposes a bug in the `LeftRotate` operation. The bug is the omission of the parent pointer update `x.p - y` after rotating a node `x` with its right child `y`. This means after a buggy `LeftRotate(x)`, `x`'s parent pointer remains unchanged, pointing to its original parent instead of its new parent `y`. An RBT invariant violation will occur if a subsequent operation in the `RB-INSERT-FIXUP` routine relies on this corrupted parent pointer, specifically when it tries to navigate up the tree. The `RB-INSERT-FIXUP` procedure frequently uses parent pointers to find the grandparent (`z.p.p`).\n\nWe need to find a sequence that first triggers a `LeftRotate`, creating a corrupted parent pointer, and then triggers another fix-up that attempts to use that corrupted pointer. A `LeftRotate` is triggered in the CLRS algorithm in two main cases:\n1.  **Case 3 (right-right \"zig-zig\"):** When the current node `z`, its parent `p`, and grandparent `g` form a right-leaning line, a `LeftRotate(g)` is performed.\n2.  **Symmetric Case 2 (left-right \"zig-zag\"):** When `p` is a left child of `g` and `z` is a right child of `p`, a `LeftRotate(p)` is performed to transform it into Case 3.\n\nLet's analyze the options:\n\n**A. Insert $10$, then $20$, then $30$, then $5$.**\n1.  **Insert $10, 20$**: The tree is `$10(B) \\rightarrow 20(R)$`. This is a valid RBT.\n2.  **Insert $30$**: This creates a red-red violation with parent $20$. The configuration is `10(B) -> 20(R) -> 30(R)`. This is a Case 3 (right-right) scenario at grandparent $10$.\n3.  The fix-up performs a `LeftRotate(10)`. The bug is triggered: after the rotation, the node $10$ has a new parent ($20$), but its parent pointer `10.p` is not updated and remains `nil` (since $10$ was the root). The tree structure (via child pointers) is now valid: root $20(B)$ with children $10(R)$ and $30(R)$.\n4.  **Insert $5$**: The node $5(R)$ is inserted as the left child of $10(R)$, creating a new red-red violation.\n5.  The fix-up procedure begins for node `z=5`. Its parent `p=10` is red. The procedure then attempts to find the grandparent `g = p.p = 10.p`. Because of the bug, `10.p` is `nil`. The fix-up routine fails (e.g., via null pointer dereference) before it can resolve the red-red violation.\n6.  **Result**: The final tree is left with an unresolved red-red violation between nodes $5$ and $10$. This violates RBT invariant (iii). This sequence is a minimal counterexample.\n\n**B. Insert $10$, then $20$, then $30$, then $25$.**\n- The insertion of $10, 20, 30$ triggers the buggy `LeftRotate` as in option A.\n- However, when $25$ is inserted, it creates a red-red violation with parent $30$. The uncle is node $10$, which is red. This is a Case 1 fix-up, which involves only recoloring. The corrupted parent pointer of node $10$ is never accessed. The fix-up completes successfully, and the final tree is a valid RBT.\n\n**C. Insert $10$, then $5$, then $1$, then $0$.**\n- This sequence of insertions (`10, 5, 1`) creates a left-left (\"zig-zig\") violation, which is fixed by a `RightRotate`. The buggy `LeftRotate` is never called. The resulting tree is valid.\n\n**D. Insert $10$, then $2$, then $3$, then $4$.**\n- Inserting $10, 2, 3$ creates a left-right (\"zig-zag\") violation. This triggers Symmetric Case 2, which calls `LeftRotate(2)`. The bug is triggered, and node $2$'s parent pointer becomes incorrect. However, the subsequent insertion of $4$ triggers a Case 1 (red uncle) fix-up, which does not rely on the corrupted pointer. The final tree is a valid RBT.\n\nTherefore, only the sequence in option A exposes the bug in a way that leads to a final, observable RBT invariant violation.",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}