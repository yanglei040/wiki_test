{
    "hands_on_practices": [
        {
            "introduction": "一棵二叉树的结构并非随意的，其叶子节点的深度分布必须遵循特定的数学约束。这个练习  将帮助你运用一个与前缀码的 Kraft 不等式相关的基本原理，来判断一组给定的深度值是否能够构成一棵合法的二叉树。通过这个练习，你将能更深刻地理解二叉树的结构限制。",
            "id": "3280782",
            "problem": "一个有根二叉树是一个有限的有序树，其中每个节点最多有两个子节点。叶节点是出度为 $0$ 的节点，节点的深度是从根节点到该节点的唯一路径上的边数。考虑一个有限有根二叉树中所有叶节点的深度多重集。以下哪个多重集可能是一个有效的有根二叉树的全部叶节点深度集合？选择所有适用项。\n\nA. $\\{1,1,2,3\\}$\n\nB. $\\{2,2,3,3,3\\}$\n\nC. $\\{0,2,3\\}$\n\nD. $\\{1,3,4,4,5,5,5\\}$\n\nE. $\\{2,2,2,2\\}$\n\n请在上述核心定义和二叉树的普遍公认属性的基础上提供论证，不假设内部节点恰好有两个子节点等特殊限制。",
            "solution": "问题要求确定给定的数字多重集中，哪些可以表示一个有限有根二叉树所有叶节点的深度。有根二叉树允许节点有 $0$、 $1$ 或 $2$ 个子节点。\n\n任何此类树的叶节点深度都遵循一个基本性质。设 $D$ 是一个有限有根二叉树中所有叶节点深度的多重集。这个多重集 $D = \\{d_1, d_2, \\ldots, d_k\\}$ 是有效的，当且仅当它满足以下两个条件：\n1.  如果 $0 \\in D$，那么 $D$ 必须是 $\\{0\\}$。深度为 $0$ 的叶节点意味着根节点是叶节点。如果根节点是叶节点，它就没有子节点，整个树只包含这一个节点。因此，不可能有其他深度的叶节点。\n2.  对于多重集中的每个深度 $d$，数量 $2^{-d}$ 的总和必须小于或等于 $1$。这是 Kraft 不等式的一种形式，应用于前缀码，其中叶节点深度对应于码字长度。\n    $$ \\sum_{i=1}^{k} 2^{-d_i} \\le 1 $$\n\n我们来为这个不等式提供一个简要的证明。我们可以通过从一个单一节点（根节点）开始，并重复应用扩展操作来构造任何二叉树。\n- **基本情况：** 最简单的树是单个节点，即根节点。这个节点也是一个深度为 $d=0$ 的叶节点。总和为 $2^{-0} = 1$。不等式 $1 \\le 1$ 成立。\n- **归纳步骤：** 假设我们有一个有效的二叉树，其总和为 $S = \\sum_{l \\in \\text{leaves}} 2^{-d(l)} \\le 1$。我们可以通过选择一个深度为 $d_0$ 的叶节点 $l_0$ 并使其成为一个内部节点来扩展该树。\n    - 如果我们给 $l_0$ 一个子节点，这个新子节点将成为一个深度为 $d_0+1$ 的叶节点。原来的叶节点 $l_0$ 从叶节点集合中移除。新的总和 $S'$ 为：\n      $$ S' = S - 2^{-d_0} + 2^{-(d_0+1)} = S - 2^{-d_0} + \\frac{1}{2} 2^{-d_0} = S - \\frac{1}{2} 2^{-d_0} $$\n      由于 $S \\le 1$，新的总和 $S'$ 也小于或等于 $1$。\n    - 如果我们给 $l_0$ 两个子节点，这两个新子节点都将成为深度为 $d_0+1$ 的叶节点。原来的叶节点 $l_0$ 被移除。新的总和 $S'$ 为：\n      $$ S' = S - 2^{-d_0} + 2^{-(d_0+1)} + 2^{-(d_0+1)} = S - 2^{-d_0} + 2 \\cdot \\left(\\frac{1}{2} 2^{-d_0}\\right) = S $$\n      总和保持不变。\n\n由于我们从总和为 $1$ 开始，并且这些操作要么保持总和不变，要么减少它，因此任何有限有根二叉树的总和必须小于或等于 $1$。反之亦然，即任何满足该不等式的深度多重集都对应一个有效的树，这可以通过构造性算法证明。\n\n我们现在将根据这一原则评估每个选项。\n\n**A. $\\{1,1,2,3\\}$**\n深度多重集为 $D = \\{1,1,2,3\\}$。我们计算总和：\n$$ S = 2^{-1} + 2^{-1} + 2^{-2} + 2^{-3} = \\frac{1}{2} + \\frac{1}{2} + \\frac{1}{4} + \\frac{1}{8} $$\n$$ S = 1 + \\frac{1}{4} + \\frac{1}{8} = \\frac{8}{8} + \\frac{2}{8} + \\frac{1}{8} = \\frac{11}{8} $$\n由于 $S = \\frac{11}{8} > 1$，不等式不成立。\n结论：**不正确**。\n\n**B. $\\{2,2,3,3,3\\}$**\n深度多重集为 $D = \\{2,2,3,3,3\\}$。我们计算总和：\n$$ S = 2^{-2} + 2^{-2} + 2^{-3} + 2^{-3} + 2^{-3} = 2 \\cdot 2^{-2} + 3 \\cdot 2^{-3} $$\n$$ S = 2 \\cdot \\frac{1}{4} + 3 \\cdot \\frac{1}{8} = \\frac{1}{2} + \\frac{3}{8} = \\frac{4}{8} + \\frac{3}{8} = \\frac{7}{8} $$\n由于 $S = \\frac{7}{8} \\le 1$，不等式成立。这样的树可以被构造出来。\n结论：**正确**。\n\n**C. $\\{0,2,3\\}$**\n深度多重集 $D = \\{0,2,3\\}$ 包含深度 $0$。深度为 $0$ 的叶节点意味着根节点是叶节点。如果根节点是叶节点，它的出度为 $0$，不能有任何子节点。因此，这棵树只由一个节点组成。在这种树中，所有叶节点深度的集合将仅为 $\\{0\\}$。其他叶节点深度 $2$ 和 $3$ 的存在造成了矛盾。\n结论：**不正确**。\n\n**D. $\\{1,3,4,4,5,5,5\\}$**\n深度多重集为 $D = \\{1,3,4,4,5,5,5\\}$。我们计算总和：\n$$ S = 2^{-1} + 2^{-3} + 2 \\cdot 2^{-4} + 3 \\cdot 2^{-5} $$\n$$ S = \\frac{1}{2} + \\frac{1}{8} + 2 \\cdot \\frac{1}{16} + 3 \\cdot \\frac{1}{32} = \\frac{1}{2} + \\frac{1}{8} + \\frac{1}{8} + \\frac{3}{32} $$\n$$ S = \\frac{1}{2} + \\frac{2}{8} + \\frac{3}{32} = \\frac{1}{2} + \\frac{1}{4} + \\frac{3}{32} $$\n为了对这些分数求和，我们使用公分母 $32$：\n$$ S = \\frac{16}{32} + \\frac{8}{32} + \\frac{3}{32} = \\frac{16+8+3}{32} = \\frac{27}{32} $$\n由于 $S = \\frac{27}{32} \\le 1$，不等式成立。这样的树可以被构造出来。\n结论：**正确**。\n\n**E. $\\{2,2,2,2\\}$**\n深度多重集为 $D = \\{2,2,2,2\\}$。我们计算总和：\n$$ S = 2^{-2} + 2^{-2} + 2^{-2} + 2^{-2} = 4 \\cdot 2^{-2} = 4 \\cdot \\frac{1}{4} = 1 $$\n由于 $S = 1 \\le 1$，不等式成立。这种树的一个简单例子是高度为 $2$ 的完美二叉树，它有 $4$ 个叶节点，所有叶节点的深度都为 $2$。\n结论：**正确**。",
            "answer": "$$\\boxed{BDE}$$"
        },
        {
            "introduction": "在网络设计或设施选址等问题中，找到一个“中心”位置至关重要，它能使得到最远点的距离最小化。这个练习  要求你将树的“中心” $C(T)$ 和“半径” $r(T)$ 这些抽象的图论定义，转化为一个具体的算法来实现。你将通过应用像广度优先搜索（BFS）这样的基本图遍历算法，来计算每个节点的离心率，从而找出树的中心，这会大大锻炼你将理论概念付诸实践的能力。",
            "id": "3280735",
            "problem": "给定一个有限、连通、无向的无环图，即一棵树。设这棵树表示为 $T=(V,E)$，其中 $|V|=n$ 个顶点的标记为 $0,1,\\dots,n-1$。两个顶点 $u$ 和 $v$ 之间的距离，记为 $d(u,v)$，是 $u$ 和 $v$ 之间唯一简单路径上的边数。一个顶点 $v$ 的离心率，记为 $\\mathrm{ecc}(v)$，是 $\\max_{u \\in V} d(v,u)$。树的半径，记为 $r(T)$，是 $\\min_{v \\in V} \\mathrm{ecc}(v)$。树的中心，记为 $C(T)$，是离心率等于 $r(T)$ 的顶点集合。\n\n仅从这些定义出发，设计并实现一个程序，对下面指定的每棵测试树，计算：\n- 树的中心 $C(T)$，以顶点索引的升序列表表示，\n- 树的半径 $r(T)$，以整数表示，\n- 以及一个布尔值，指示中心是否唯一，即 $|C(T)|=1$ 是否成立。\n\n您的算法必须对任何树都正确，并且必须仅依赖于树的基本性质：连通性、无环性以及顶点间简单路径的唯一性。您应该从这些基本定义出发，推导出您的方法为何能确定中心和半径，而不假设或引用任何快捷公式。\n\n测试套件：\n- 树 $\\mathrm{T}_1$：$n=5$，$E=\\{(0,1),(1,2),(2,3),(3,4)\\}$。\n- 树 $\\mathrm{T}_2$：$n=4$，$E=\\{(0,1),(1,2),(2,3)\\}$。\n- 树 $\\mathrm{T}_3$：$n=5$，$E=\\{(0,1),(0,2),(0,3),(0,4)\\}$。\n- 树 $\\mathrm{T}_4$：$n=1$，$E=\\emptyset$。\n- 树 $\\mathrm{T}_5$：$n=2$，$E=\\{(0,1)\\}$。\n- 树 $\\mathrm{T}_6$：$n=7$，$E=\\{(0,1),(1,2),(2,3),(2,4),(4,5),(5,6)\\}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果本身必须是一个形如 $[L,R,B]$ 的列表，其中 $L$ 是中心顶点索引的升序列表，$R$ 是整数半径，$B$ 是指示唯一性的布尔值。例如，对于三个测试，一个有效的最终行将类似于 $[[[a_1,\\dots],[r_1],b_1],[[a_2,\\dots],r_2,b_2],[[a_3,\\dots],r_3,b_3]]$，其中实际整数替换了符号占位符，布尔值写作 $True$ 或 $False$。\n\n您的程序必须是自包含的，并完全按照给定的方式使用所提供的测试套件。除了所需的单行输出外，它不得读取任何输入或写入任何其他输出。唯一可接受的库是 Python 标准库和指定的数值库。",
            "solution": "任务是设计一个算法来计算给定树 $T=(V,E)$ 的中心 $C(T)$ 和半径 $r(T)$，并且仅依赖于所提供的基本定义。这些定义是：\n- 距离 $d(u,v)$ 是顶点 $u, v \\in V$ 之间唯一简单路径上的边数。\n- 顶点 $v$ 的离心率 $\\mathrm{ecc}(v)$ 是 $\\max_{u \\in V} d(v,u)$。\n- 树的半径 $r(T)$ 是 $\\min_{v \\in V} \\mathrm{ecc}(v)$。\n- 树的中心 $C(T)$ 是顶点集合 $\\{v \\in V \\mid \\mathrm{ecc}(v) = r(T)\\}$。\n\n这些定义自然地规定了一个直接的计算过程。该算法的有效性在于它将这些数学陈述直接转化为一系列计算，而不是依赖于外部定理。该过程如下：\n\n首先，为了评估任何一个顶点的离心率，必须先确定它到树中所有其他顶点的距离。这需要计算所有顶点对之间的最短路径。由于图是一棵树且是无权的，距离 $d(u,v)$ 对应于路径上的边数。广度优先搜索 (BFS) 算法是在无权图中寻找单源最短路径的标准方法。通过从每个顶点 $s \\in V$ 开始执行一次 BFS，我们可以系统地找到到所有其他顶点 $v \\in V$ 的距离 $d(s,v)$。对树中的每个顶点重复此过程，从而得到所有必要的距离信息。设顶点数为 $n = |V|$。\n\n其次，在计算出所有距离后，每个顶点 $v$ 的离心率 $\\mathrm{ecc}(v)$ 直接根据其定义进行计算。对于每个 $v \\in V$，我们在距离集合 $\\{d(v,u) \\mid u \\in V\\}$ 中找到最大值。根据定义，这个最大值就是 $\\mathrm{ecc}(v)$。对所有 $n$ 个顶点执行此步骤，会得到一个包含每个顶点离心率的列表。\n\n第三，树的半径 $r(T)$ 定义为所有顶点中最小的离心率。在计算出所有 $n$ 个离心率后，我们在这个集合中找到最小值。该值就是半径 $r(T) = \\min_{v \\in V} \\mathrm{ecc}(v)$。\n\n第四，中心 $C(T)$ 是离心率等于半径的顶点集合。我们通过遍历离心率列表并收集所有满足 $\\mathrm{ecc}(v) = r(T)$ 的顶点 $v$ 来识别这些顶点。得到的顶点集合构成了树的中心。根据输出要求，该集合以顶点索引的升序列表形式存储。\n\n最后，中心的唯一性由其基数 $|C(T)|$ 决定。如果 $|C(T)| = 1$，则中心是唯一的；否则，不是。一个布尔值表示此结果。\n\n这个算法过程因其构造方式而正确，因为每一步都是对问题陈述中提供的相应数学定义的直接实现。它仅依赖于连通图中距离是良定义且可计算（例如，通过 BFS）这一基本性质。该方法没有援引任何关于树中心性质的、未在题目中说明的先进定理，从而遵守了问题的约束。对于一个有 $n$ 个顶点的树，该方法的计算复杂度主要由所有顶点对的距离计算决定。在树上进行单次 BFS 遍历所需时间与顶点和边的数量成正比，即 $O(n + m) = O(n)$，因为 $m=n-1$。对所有 $n$ 个顶点重复此操作，总时间复杂度为 $O(n^2)$。后续寻找半径和中心的步骤具有较低的复杂度 $O(n)$。对于所提供测试套件中的小 $n$ 值，这个 $O(n^2)$ 的复杂度是完全可行的。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import deque\n\ndef solve():\n    \"\"\"\n    Solves the tree center and radius problem for a predefined suite of test cases.\n    \"\"\"\n    \n    # Test Suite\n    test_cases = [\n        # T1: n=5, E={(0,1),(1,2),(2,3),(3,4)}\n        (5, [(0, 1), (1, 2), (2, 3), (3, 4)]),\n        # T2: n=4, E={(0,1),(1,2),(2,3)}\n        (4, [(0, 1), (1, 2), (2, 3)]),\n        # T3: n=5, E={(0,1),(0,2),(0,3),(0,4)}\n        (5, [(0, 1), (0, 2), (0, 3), (0, 4)]),\n        # T4: n=1, E=emptyset\n        (1, []),\n        # T5: n=2, E={(0,1)}\n        (2, [(0, 1)]),\n        # T6: n=7, E={(0,1),(1,2),(2,3),(2,4),(4,5),(5,6)}\n        (7, [(0, 1), (1, 2), (2, 3), (2, 4), (4, 5), (5, 6)]),\n    ]\n\n    results = []\n    for n, edges in test_cases:\n        result = compute_center_radius(n, edges)\n        results.append(result)\n\n    # Manual string formatting for exact output matching\n    res_strings = []\n    for L, R, B in results:\n        L_str = str(L).replace(' ', '')\n        res_strings.append(f\"[{L_str},{R},{B}]\")\n    \n    final_output = f\"[{','.join(res_strings)}]\"\n    print(final_output)\n\ndef compute_center_radius(n, edges):\n    \"\"\"\n    Computes the center, radius, and uniqueness of the center for a single tree.\n\n    The algorithm directly implements the definitions:\n    1. For each vertex, run a BFS to find its distance to all other vertices.\n    2. The maximum of these distances is the vertex's eccentricity.\n    3. The minimum of all eccentricities is the tree's radius.\n    4. The vertices with eccentricity equal to the radius form the center.\n    \"\"\"\n    if n == 0:\n        return [[], -1, False] # Or handle as an error, but problem implies n>=1\n    if n == 1:\n        return [[0], 0, True]\n\n    adj = {i: [] for i in range(n)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    all_eccentricities = []\n\n    for start_node in range(n):\n        # BFS to find distances from start_node\n        distances = [-1] * n\n        distances[start_node] = 0\n        queue = deque([start_node])\n        \n        max_dist = 0\n        \n        while queue:\n            u = queue.popleft()\n            max_dist = max(max_dist, distances[u])\n\n            for v in adj[u]:\n                if distances[v] == -1:\n                    distances[v] = distances[u] + 1\n                    queue.append(v)\n        \n        all_eccentricities.append(max_dist)\n\n    radius = min(all_eccentricities)\n    center = sorted([i for i, ecc in enumerate(all_eccentricities) if ecc == radius])\n    is_unique = (len(center) == 1)\n    \n    return [center, radius, is_unique]\n\nsolve()\n```"
        },
        {
            "introduction": "树的遍历序列是其线性化的表示，但仅有遍历序列往往不足以唯一确定一棵树的结构。这个练习  提出了一个更具挑战性的任务：结合后序遍历序列和其中每个节点的深度信息，来精确地重建出唯一的树结构。完成这个练习将加深你对树的遍历过程、节点深度以及它们如何共同决定树的拓扑结构的理解。",
            "id": "3280807",
            "problem": "给定一棵有根有序树的后序遍历序列，以及遍历序列中每个节点从根节点算起的深度（边的数量）。请仅使用有根树、后序遍历和节点深度的基本定义，设计一个算法来重建给定遍历顺序中每个节点的父节点。有根有序树被定义为一个连通无环图，其中有一个指定的根节点，且每个节点的子节点都是有序的。后序遍历被递归地定义为：对于一个节点，首先按顺序对其所有子节点进行后序遍历，然后访问该节点本身。节点的深度被定义为从根节点到该节点的唯一简单路径上的边数。您的程序必须验证给定序列与这些定义的一致性，如果有效，则返回父节点数组，如果无效，则返回一个空列表。\n\n每个测试用例的输入模型：\n- 一个按后序遍历给出的节点标识符序列 $S$。标识符是任意的，但为了输出表示的目的，节点按其在 $S$ 中的位置进行索引，即索引 $0$ 到 $n-1$，其中 $n$ 是节点数。\n- 一个与 $S$ 等长的非负整数深度序列 $D$，其中 $D[j]$ 是 $S[j]$ 的深度。\n\n输出规范：\n- 对每个测试用例，返回一个长度为 $n$ 的列表 $P$，其中 $P[j]$ 等于节点 $S[j]$ 的父节点在遍历顺序中的索引；如果 $S[j]$ 是根节点，则为 $-1$。\n- 如果输入序列不代表一个与给定的后序遍历和深度约束一致的有效有根有序树，则为该测试用例输出空列表 $[]$。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果本身也是一个用方括号括起来的、无空格的逗号分隔列表。例如，输出格式必须类似于 $[[p\\_0,p\\_1,\\dots,p\\_{n-1}],[q\\_0,q\\_1,\\dots],[\\dots]]$，且在同一行。\n\n科学真实性与基本依据：\n- 仅使用上述核心定义，并推导出重建树所需的算法属性。不要依赖未经证实的快捷公式。\n\n测试套件：\n- 案例 $1$ (通用分支)：$S=[0,1,2,3,4,5,6]$，$D=[2,2,1,2,2,1,0]$。\n- 案例 $2$ (单个节点)：$S=[0]$，$D=[0]$。\n- 案例 $3$ (深链)：$S=[0,1,2,3]$，$D=[3,2,1,0]$。\n- 案例 $4$ (无效；末尾没有根节点)：$S=[0,1]$，$D=[1,1]$。\n\n您的程序必须在内部精确处理这四个案例，并按上述格式生成最终的单行输出。",
            "solution": "该问题是良定的，可以从基本定义中推导出解决方案。\n\n### 算法推导\n\n1.  **后序遍历的核心属性**：在后序遍历序列中，任何一个节点都紧跟在它所有子树的遍历序列之后。这意味着一个节点的父节点一定出现在该节点之后。如果我们将节点按其在遍历序列 $S$ 中的出现顺序索引为 $0, 1, \\dots, n-1$，那么索引为 $j$ 的节点的父节点 $p$ 的索引 $k$ 必须满足 $k > j$。\n\n2.  **深度的核心属性**：如果节点 $p$ 是节点 $v$ 的父节点，那么它们的深度关系为 $depth(v) = depth(p) + 1$。\n\n3.  **结合推论**：结合以上两点，对于序列中索引为 $j$、深度为 $d$ 的节点，其父节点必须是序列中某个索引 $k > j$、深度为 $d-1$ 的节点。\n\n4.  **识别唯一父节点**：后序遍历的嵌套结构为我们提供了识别唯一父节点的关键。当我们从右到左（即按索引从 $n-1$ 到 $0$）扫描后序序列时，我们实际上是从树的根部向叶节点方向移动。对于当前扫描到的节点 $j$（深度为 $d$），其父节点（深度为 $d-1$）必须是我们在扫描过程中已经遇到的、位于其右侧（即索引 $k>j$）的节点。由于子树的遍历是连续的，节点 $j$ 的父节点必然是其右侧所有深度为 $d-1$ 的节点中，离它最近（即索引最大）的那个。\n\n### 算法步骤\n\n基于以上推导，我们可以设计出以下算法：\n\n1.  **输入验证**：\n    - 一个有效的树必须至少有一个节点。如果节点数 $n=0$，则输入无效。\n    - 根节点是整个树后序遍历的最后一个节点。因此，序列中的最后一个元素 $S[n-1]$ 的深度 $D[n-1]$ 必须为 $0$。如果不是，输入无效。\n    - 对于 $n>1$ 的树，除根节点外，所有其他节点的深度都必须大于 $0$。\n\n2.  **重建过程**：\n    - 我们从右到左遍历后序序列（索引从 $j = n-1$ 到 $0$）。\n    - 我们使用一个辅助数据结构（例如哈希表或数组），命名为 `last_node_at_depth`，来记录在扫描过程中每个深度层级上遇到的最后一个（即最右侧）节点的索引。\n    - 初始化一个父节点数组 `P`，长度为 $n$，所有值初始化为 $-1$。\n    - **循环**：对于每个索引 $j$ 从 $n-1$ 到 $0$：\n        a. 获取当前节点的深度 $d = D[j]$。\n        b. **寻找父节点**：如果 $d > 0$，那么父节点的深度应为 $d-1$。我们在 `last_node_at_depth` 中查找深度为 $d-1$ 的节点索引。如果存在，这个索引就是当前节点的父节点索引。将其存入 `P[j]`。如果不存在，说明结构不一致，输入无效。\n        c. **更新状态**：将当前节点的信息记录下来，更新 `last_node_at_depth[d] = j`。这使得当前节点成为后续（左侧）节点的潜在父节点。\n\n3.  **最终验证**：在循环中，如果一个非根节点（即 $j  n-1$）的深度为 $0$，这也是一个无效结构。\n\n如果算法顺利完成，`P` 数组就代表了重建后树的父子关系。如果任何验证失败，则返回一个空列表。\n\n### 案例追踪：$S=[0,1,2,3,4,5,6], D=[2,2,1,2,2,1,0]$\n- $n=7$。验证 $D[6]=0$，通过。\n- 初始化 $P = [-1, -1, -1, -1, -1, -1, -1]$, `last_node_at_depth = {}`。\n\n- $j=6$: $d=0$ (根节点)。`last_node_at_depth[0] = 6`。\n- $j=5$: $d=1$。父节点深度为 $0$。`last_node_at_depth[0]` 是 $6$。所以 $P[5]=6$。更新 `last_node_at_depth[1] = 5`。\n- $j=4$: $d=2$。父节点深度为 $1$。`last_node_at_depth[1]` 是 $5$。所以 $P[4]=5$。更新 `last_node_at_depth[2] = 4`。\n- $j=3$: $d=2$。父节点深度为 $1$。`last_node_at_depth[1]` 是 $5$。所以 $P[3]=5$。更新 `last_node_at_depth[2] = 3`。\n- $j=2$: $d=1$。父节点深度为 $0$。`last_node_at_depth[0]` 是 $6$。所以 $P[2]=6$。更新 `last_node_at_depth[1] = 2`。\n- $j=1$: $d=2$。父节点深度为 $1$。`last_node_at_depth[1]` 是 $2$。所以 $P[1]=2$。更新 `last_node_at_depth[2] = 1`。\n- $j=0$: $d=2$。父节点深度为 $1$。`last_node_at_depth[1]` 是 $2$。所以 $P[0]=2$。更新 `last_node_at_depth[2] = 0`。\n\n最终结果 $P = [2, 2, 6, 5, 5, 6, -1]$。该算法是正确且高效的。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef reconstruct_parent_array(S, D):\n    \"\"\"\n    Reconstructs the parent array of a rooted ordered tree from its post-order\n    traversal and node depths.\n\n    Args:\n        S (list): A sequence of node identifiers in post-order. For this problem,\n                  it's assumed to be [0, 1, ..., n-1].\n        D (list): A sequence of non-negative integer depths corresponding to S.\n\n    Returns:\n        list: A list P where P[j] is the parent index of node S[j], or -1 for the root.\n              Returns an empty list if the input is invalid.\n    \"\"\"\n    n = len(S)\n    if n == 0:\n        return []\n\n    # Validation: The last node in a post-order traversal must be the root,\n    # and the root's depth must be 0.\n    if D[n - 1] != 0:\n        return []\n\n    if n == 1:\n        return [-1]\n\n    # The parent array P, initialized with -1 for all nodes.\n    # P[j] will store the index of the parent of the node at index j.\n    P = np.full(n, -1, dtype=int)\n\n    # This dictionary maps a depth level to the index of the most recently\n    # seen node at that depth.\n    last_node_at_depth = {0: n - 1}\n\n    # Iterate from the second-to-last node down to the first.\n    for j in range(n - 2, -1, -1):\n        depth = D[j]\n        \n        # Validation: All non-root nodes must have a depth greater than 0.\n        if depth == 0:\n            return []\n\n        parent_depth = depth - 1\n        \n        # Validation: A parent must exist at the required depth. If not, the\n        # depth sequence is inconsistent with a valid tree structure.\n        if parent_depth not in last_node_at_depth:\n            return []\n\n        parent_idx = last_node_at_depth[parent_depth]\n        P[j] = parent_idx\n        \n        # Record the current node as the most recently seen at its depth.\n        last_node_at_depth[depth] = j\n\n    return P.tolist()\n\n\ndef solve():\n    \"\"\"\n    Defines the test cases from the problem, solves them, and prints the\n    final output in the exact specified format.\n    \"\"\"\n    test_cases = [\n        # Case 1 (general branching)\n        (list(range(7)), [2, 2, 1, 2, 2, 1, 0]),\n        # Case 2 (single node)\n        (list(range(1)), [0]),\n        # Case 3 (deep chain)\n        (list(range(4)), [3, 2, 1, 0]),\n        # Case 4 (invalid; no root at the end)\n        (list(range(2)), [1, 1]),\n    ]\n\n    results = []\n    for s, d in test_cases:\n        result = reconstruct_parent_array(s, d)\n        results.append(result)\n\n    # Format the results into the required single-line string format.\n    # Example: [[-1],[1,2,3,-1]]\n    output_parts = []\n    for res in results:\n        if not res:\n            output_parts.append(\"[]\")\n        else:\n            output_parts.append(f\"[{','.join(map(str, res))}]\")\n    \n    final_output_string = f\"[{','.join(output_parts)}]\"\n\n    # Final print statement in the exact required format.\n    print(final_output_string)\n\nsolve()\n\n```"
        }
    ]
}