{
    "hands_on_practices": [
        {
            "introduction": "A deep understanding of a data structure comes not just from knowing its rules, but from being able to diagnose when those rules are broken. This exercise challenges you to do just that by determining if a given binary tree is \"almost\" a Binary Search Tree (BST). The key insight you will explore is the powerful connection between the tree's structure and its inorder traversal, transforming a tree problem into a sequence analysis puzzle .",
            "id": "3215353",
            "problem": "You are given the task to determine, for a collection of binary trees, whether each tree can be transformed into a Binary Search Tree (BST) by performing at most one swap of values between two nodes. The transformation must preserve the original tree shape; only the values stored at nodes may be swapped.\n\nUse the following fundamental base:\n- A binary tree is a node-labeled, rooted tree in which each node has up to two children, called the left and right child.\n- A Binary Search Tree (BST) over pairwise distinct integers satisfies the property that for every node with key $k$, all keys in its left subtree are strictly less than $k$, and all keys in its right subtree are strictly greater than $k$.\n- An in-order traversal of a BST yields a strictly increasing sequence of keys.\n- Swapping the values of exactly two nodes in the tree corresponds exactly to swapping the values at two positions in the in-order traversal sequence produced from that tree shape.\n\nAssumptions:\n- All node values are pairwise distinct integers.\n- The trees are represented in level-order (breadth-first order) as arrays. The root is at index $0$. For any node stored at index $i$, its left child is at index $2i+1$ and its right child is at index $2i+2$. If a child does not exist, its corresponding array entry is the token None. No node appears as a child if its parent is None.\n\nYour task:\n- For each provided test case, determine a boolean value: true if the tree can be made into a BST by at most $1$ swap of two node values (or if it is already a BST), and false otherwise.\n- Your program must not read input. It should use the test suite embedded below and produce the required output format precisely.\n\nTest suite (each case is a level-order array with None denoting a missing child; numbers are integers):\n- [].\n- [$5$].\n- [$2$,$1$,$3$].\n- [$3$,$1$,$4$, None, None, $2$].\n- [$3$,$2$,$1$].\n- [$10$,$5$,$15$,$1$,$12$].\n- [$2$,$1$,$4$,$3$].\n- [$2$, None, $3$].\n- [$2$,$3$,$4$,$1$].\n\nAnswer specification:\n- For each test case, output a boolean: true or false.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For example, if there are three cases, a valid output is [true,false,true]. Use lowercase literals \"true\" and \"false\" for booleans.",
            "solution": "The problem requires us to determine if a given binary tree can be transformed into a Binary Search Tree (BST) by performing at most one swap of values between two nodes. The core of the solution rests on a fundamental property of BSTs and their relationship with in-order traversals.\n\nA key principle, provided in the problem statement, is that an in-order traversal of a valid BST yields a sequence of node values that is strictly increasing. Furthermore, swapping the values of two nodes in the tree directly corresponds to swapping the positions of those two values in the sequence generated by an in-order traversal of that tree's structure. This insight allows us to reframe the problem from one of tree manipulation to one of sequence analysis.\n\nLet the given binary tree, represented by a level-order array, be denoted by $T$. The sequence of node values obtained from an in--order traversal of $T$ is denoted by $S_{\\text{inorder}}$. Since all node values are stated to be pairwise distinct integers, a correctly formed BST on these same values would have an in-order traversal sequence that is simply the sorted version of these values. Let this target sequence be denoted by $S_{\\text{sorted}}$, which is obtained by sorting the elements of $S_{\\text{inorder}}$ in strictly ascending order.\n\nThe problem is now equivalent to answering the question: can the sequence $S_{\\text{inorder}}$ be transformed into the sequence $S_{\\text{sorted}}$ by performing at most one swap of two elements?\n\nTo answer this, we compare $S_{\\text{inorder}}$ and $S_{\\text{sorted}}$ element by element and count the number of positions at which they differ. Let this count of mismatches be denoted by $d$.\n\nWe analyze the possible values of $d$:\n\n1.  Case $d=0$: If there are zero mismatches, $S_{\\text{inorder}}$ is identical to $S_{\\text{sorted}}$. This means the sequence is already sorted, and thus the original tree $T$ is already a valid BST. This requires $0$ swaps, which satisfies the condition of \"at most one swap\". The result is $\\text{true}$.\n\n2.  Case $d=2$: If there are exactly two mismatches, it implies that two elements are out of their sorted positions. For example, suppose $S_{\\text{inorder}}[i] \\neq S_{\\text{sorted}}[i]$ and $S_{\\text{inorder}}[j] \\neq S_{\\text{sorted}}[j]$ for $i \\neq j$, and all other elements are in their correct positions. Since all values are unique and both sequences contain the same set of values, it must be that $S_{\\text{inorder}}[i] = S_{\\text{sorted}}[j]$ and $S_{\\text{inorder}}[j] = S_{\\text{sorted}}[i]$. A single swap of the elements at positions $i$ and $j$ in $S_{\\text{inorder}}$ will correct both positions simultaneously, making the sequence sorted. This corresponds to exactly one swap of node values in the tree $T$. This satisfies the condition of \"at most one swap\". The result is $\\text{true}$.\n\n3.  Case $d > 2$: If there are more than two mismatches, the elements are displaced in a way that cannot be resolved with a single swap. For example, a cyclic permutation of three elements, such as $S_{\\text{inorder}} = [\\dots, c, \\dots, a, \\dots, b, \\dots]$ where $S_{\\text{sorted}} = [\\dots, a, \\dots, b, \\dots, c, \\dots]$, requires at least two swaps to sort. Therefore, if $d > 2$, the condition is not met. The result is $\\text{false}$.\n\n4.  Case $d=1$: This case is impossible. If a single element at position $i$ is a mismatch, meaning $S_{\\text{inorder}}[i] = v_1$ while $S_{\\text{sorted}}[i] = v_2$ (with $v_1 \\neq v_2$), then the value $v_2$ must appear somewhere else in $S_{\\text{inorder}}$, say at position $j$, where $S_{\\text{inorder}}[j] = v_2$. Since all values are unique, $j \\neq i$. The value at $S_{\\text{sorted}}[j]$ cannot be $v_2$, so the element at position $j$ is also a mismatch. Thus, mismatches must occur in pairs or larger groups, and $d$ can never be $1$.\n\nTherefore, the tree can be made a BST with at most one swap if and only if the number of mismatches $d$ is either $0$ or $2$. The algorithm is as follows:\n\n1.  For the given tree represented as a level-order array, construct the in-order traversal sequence, $S_{\\text{inorder}}$. This can be achieved with a recursive function that, for a node at index $i$, first processes its left child (at index $2i+1$), then records the value at index $i$, and finally processes its right child (at index $2i+2$). The recursion terminates for indices that are out of bounds or correspond to a `None` value.\n2.  Create a sorted version of this sequence, $S_{\\text{sorted}}$.\n3.  Calculate the number of mismatches, $d$, by comparing $S_{\\text{inorder}}$ and $S_{\\text{sorted}}$.\n4.  If $d \\le 2$, the condition is met, and the result is $\\text{true}$. Otherwise, the result is $\\text{false}$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for the entire test suite.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [],\n        [5],\n        [2, 1, 3],\n        [3, 1, 4, None, None, 2],\n        [3, 2, 1],\n        [10, 5, 15, 1, 12],\n        [2, 1, 4, 3],\n        [2, None, 3],\n        [2, 3, 4, 1],\n    ]\n\n    def is_recoverable(tree_array):\n        \"\"\"\n        Determines if a binary tree can be made a BST with at most one swap.\n\n        Args:\n            tree_array: A list representing the tree in level-order.\n\n        Returns:\n            A boolean, True if recoverable, False otherwise.\n        \"\"\"\n        # An empty tree is a valid, sorted structure.\n        if not tree_array:\n            return True\n\n        inorder_seq = []\n        \n        def get_inorder(idx):\n            \"\"\"\n            Recursively performs an in-order traversal on the level-order array.\n            \n            Args:\n                idx: The index of the current node in tree_array.\n            \"\"\"\n            # Base case: if index is out of bounds or the node is None.\n            if idx >= len(tree_array) or tree_array[idx] is None:\n                return\n            \n            # 1. Recurse on the left child.\n            get_inorder(2 * idx + 1)\n            \n            # 2. Visit (append) the current node's value.\n            inorder_seq.append(tree_array[idx])\n            \n            # 3. Recurse on the right child.\n            get_inorder(2 * idx + 2)\n\n        # Start the traversal from the root at index 0.\n        get_inorder(0)\n        \n        # If the traversal results in an empty list (e.g., tree was [None]), \n        # it is considered a valid (empty) BST.\n        if not inorder_seq:\n            return True\n\n        # The target sequence for a BST is the sorted in-order sequence.\n        sorted_seq = sorted(inorder_seq)\n        \n        # Convert lists to NumPy arrays for efficient comparison.\n        inorder_np = np.array(inorder_seq)\n        sorted_np = np.array(sorted_seq)\n        \n        # Count the number of positions where the elements differ.\n        mismatches = np.sum(inorder_np != sorted_np)\n        \n        # A tree is recoverable by at most one swap if it's already a BST\n        # (0 mismatches) or if exactly two elements are swapped (2 mismatches).\n        return mismatches = 2\n\n    results = [is_recoverable(case) for case in test_cases]\n    \n    # Format the results as a list of lowercase boolean strings.\n    results_str = [str(r).lower() for r in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Once you can verify the BST property, the next fundamental skill is to construct a BST efficiently. This practice guides you through building a BST of minimum possible height from a sorted sequence of keys, which is precisely the inorder traversal of the target tree. By strategically choosing the median element as the root at each step, you will create a balanced tree that guarantees logarithmic time complexity for search operations .",
            "id": "3215469",
            "problem": "You are given several finite sequences of distinct integers. For each sequence, your task is to construct a Binary Search Tree (BST) of minimum possible height that has exactly the given sequence as its inorder traversal. The program you produce must operate in purely algorithmic terms and must be self-contained: it must not read from standard input or external files, and it must not produce any output other than the required final line.\n\nFundamental base for this task:\n- A Binary Search Tree (BST) on distinct keys satisfies the BST property: for every node with key $k$, all keys in its left subtree are strictly less than $k$, and all keys in its right subtree are strictly greater than $k$.\n- The inorder traversal of any BST with distinct keys yields the keys in strictly increasing order.\n- The height of a tree is defined as the number of edges on the longest simple path from the root to any leaf; by convention, the empty tree has height $-1$.\n- Time complexity is measured using the standard asymptotic notation $O(\\cdot)$; you must construct the BST in $O(n)$ time for a sequence of length $n$.\n\nYour task:\n- For each provided test sequence $A$, where $A$ is strictly increasing (so that the inorder target is already determined), construct a BST that has $A$ as its inorder traversal and whose height is the minimum possible among all BSTs whose inorder traversal is $A$.\n- After constructing the BST for each $A$, compute:\n  1. The height $h(A)$ of the constructed tree, using the convention that the empty tree has height $-1$.\n  2. A boolean $b_{\\mathrm{bst}}(A)$ indicating whether the constructed structure satisfies the strict BST property for all nodes.\n  3. A boolean $b_{\\mathrm{in}}(A)$ indicating whether the inorder traversal of the constructed tree equals $A$ element-by-element.\n  4. A boolean $b_{\\min}(A)$ indicating whether $h(A)$ attains the information-theoretic lower bound on height for any binary tree with $n$ nodes, namely\n     $$h^\\star(n) = \\begin{cases}\n     -1  \\text{if } n = 0,\\\\\n     \\lceil \\log_2(n+1) \\rceil - 1  \\text{if } n \\ge 1,\n     \\end{cases}$$\n     where $n$ is the length of $A$.\n\nAll sequences are strictly increasing and contain distinct integers, so the strict BST property is well-defined.\n\nPerformance requirement:\n- Your construction algorithm for each sequence of length $n$ must run in $O(n)$ time and $O(n)$ space.\n\nTest suite:\nLet the sequences be exactly the following:\n- $A_1 = [\\,]$ (the empty sequence).\n- $A_2 = [\\,42\\,]$.\n- $A_3 = [\\,1,2\\,]$.\n- $A_4 = [\\,1,2,3,4,5\\,]$.\n- $A_5 = [\\,1,2,3,4,5,6,7\\,]$.\n- $A_6 = [\\,10,20,30,40,50,60,70,80\\,]$.\n- $A_7 = [\\,3,9,12,27,31,44,58,60,72,90,101\\,]$.\n\nRequired final output format:\n- Your program should produce a single line of output containing a list of $7$ results, one for each $A_i$ in order from $i=1$ to $i=7$.\n- Each result must itself be a list of four items in the order $[\\,h(A_i), b_{\\mathrm{bst}}(A_i), b_{\\mathrm{in}}(A_i), b_{\\min}(A_i)\\,]$.\n- The entire output must be a single line, with no spaces anywhere, using square brackets and commas only. For example, an output for three hypothetical cases would follow the pattern\n  $$[ [\\,\\cdot,\\cdot,\\cdot,\\cdot\\,], [\\,\\cdot,\\cdot,\\cdot,\\cdot\\,], [\\,\\cdot,\\cdot,\\cdot,\\cdot\\,] ]$$\n  but without any spaces. Concretely, your program must print exactly a single line like\n  $$[[r_{11},r_{12},r_{13},r_{14}],[r_{21},r_{22},r_{23},r_{24}],\\dots,[r_{71},r_{72},r_{73},r_{74}]],$$\n  where each $r_{ij}$ is either an integer or a boolean literal.",
            "solution": "The problem requires constructing a Binary Search Tree (BST) of minimal height from a given sequence of keys, which is already sorted. The fact that the input sequence $A$ is sorted implies that it is the unique inorder traversal for any BST built from these keys.\n\n**Principle of Construction**\n\nThe fundamental property of an inorder traversal is that it visits all nodes in the left subtree, then the root, then all nodes in the right subtree. To construct a BST from its inorder traversal $A$, if we select an element $A[i]$ as the root, all elements in the prefix $A[0 \\dots i-1]$ must form the left subtree, and all elements in the suffix $A[i+1 \\dots n-1]$ must form the right subtree.\n\nTo achieve a tree of minimum height, the number of nodes in the left and right subtrees must be as balanced as possible at every level of recursion. For a sorted array segment $A[\\text{start} \\dots \\text{end}]$, the optimal choice for the root is the median element, $A[\\text{mid}]$, where $\\text{mid}$ is the middle index of the segment. This choice partitions the remaining elements into two sub-arrays of sizes $\\lfloor (N-1)/2 \\rfloor$ and $\\lceil (N-1)/2 \\rceil$, where $N$ is the number of elements in the segment. This strategy guarantees the construction of a height-balanced tree, thus achieving the minimum possible height.\n\n**Algorithm Design**\n\nA recursive algorithm based on this principle can be designed. Let's define a function `build(A, start, end)` that constructs a minimal-height BST from the sub-array $A[\\text{start} \\dots \\text{end}]$.\n\n1.  **Base Case**: If `start > end`, the array segment is empty, so we return `null` to represent an empty subtree.\n2.  **Recursive Step**:\n    a. Calculate the middle index: $\\text{mid} = \\text{start} + \\lfloor (\\text{end} - \\text{start}) / 2 \\rfloor$.\n    b. Create a new tree node with the key $A[\\text{mid}]$. This node is the root of the current subtree.\n    c. Recursively build the left subtree by calling `build(A, start, mid - 1)`. The result is assigned as the left child of the root.\n    d. Recursively build the right subtree by calling `build(A, mid + 1, end)`. The result is assigned as the right child of the root.\n    e. Return the newly created root node.\n\nThe initial call to construct the entire tree from sequence $A$ of length $n$ would be `build(A, 0, n - 1)`.\n\n**Complexity Analysis**\n\n-   **Time Complexity**: The `build` function is called exactly once for each element in the input array $A$. The work done within each call (calculating `mid`, creating a node) is constant, i.e., $O(1)$. Therefore, the total time complexity is linear in the number of elements, $O(n)$. It is crucial that sub-arrays are not passed by value (slicing), as this would degrade performance to $O(n \\log n)$. Passing indices achieves the required $O(n)$ complexity.\n-   **Space Complexity**: The algorithm requires space to store the constructed tree, which has $n$ nodes, contributing $O(n)$ space. The recursion stack depth is equal to the height of the tree. Since the tree is balanced, its height is $O(\\log n)$. Thus, the total space complexity is dominated by the storage of the tree itself, which is $O(n)$. Both complexity metrics satisfy the problem's constraints.\n\n**Verification Procedures**\n\nAfter constructing the tree for each sequence $A$, the following four properties must be verified:\n\n1.  **Height, $h(A)$**: The height of a tree rooted at `node` is computed recursively:\n    -   If `node` is null, height is $-1$.\n    -   Otherwise, height is $1 + \\max(\\text{height}(\\text{node.left}), \\text{height}(\\text{node.right}))$.\n\n2.  **BST Property, $b_{\\mathrm{bst}}(A)$**: A recursive function `is_bst(node, min_bound, max_bound)` can validate this property. For each `node`, it checks if $\\text{min_bound}  \\text{node.key}  \\text{max_bound}$. The check then recurses on the left child with updated bounds $(\\text{min_bound}, \\text{node.key})$ and on the right child with bounds $(\\text{node.key}, \\text{max_bound})$. The initial call for the root would be `is_bst(root, -\\infty, +\\infty)`. By virtue of the construction algorithm, this will always be `True`.\n\n3.  **Inorder Traversal, $b_{\\mathrm{in}}(A)$**: An inorder traversal is performed on the constructed tree, collecting the keys into a new sequence $A'$. This is done by recursively visiting the left subtree, then the root, then the right subtree. Finally, $A'$ is compared element-by-element with the original input $A$. They must be identical, so this check will also always yield `True`.\n\n4.  **Minimal Height, $b_{\\min}(A)$**: The computed height $h(A)$ is compared to the theoretical minimum height $h^\\star(n)$. For $n \\ge 1$, this is $h^\\star(n) = \\lceil \\log_2(n+1) \\rceil - 1$. A construction algorithm that always picks the median is guaranteed to produce a tree of this minimal height if the tree is complete or full, and will be optimal or near-optimal otherwise. For this specific construction, the height will be optimal. For $n=0$, $h(A)=-1$ and $h^\\star(0)=-1$, so it is also `True`.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport math\nimport sys\n\n# It is good practice to increase recursion limit for deep recursion, although not strictly necessary for the given test cases.\nsys.setrecursionlimit(2000)\n\nclass Node:\n    \"\"\"A node in a binary search tree.\"\"\"\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\ndef solve():\n    \"\"\"\n    Solves the problem for the given test suite by constructing and validating\n    minimum-height BSTs from sorted sequences.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [],\n        [42],\n        [1, 2],\n        [1, 2, 3, 4, 5],\n        [1, 2, 3, 4, 5, 6, 7],\n        [10, 20, 30, 40, 50, 60, 70, 80],\n        [3, 9, 12, 27, 31, 44, 58, 60, 72, 90, 101],\n    ]\n\n    results = []\n    for A in test_cases:\n        n = len(A)\n        \n        # Construct the BST of minimum height\n        root = _build_min_height_bst(A, 0, n - 1)\n        \n        # 1. Compute the height h(A)\n        h_A = _get_height(root)\n        \n        # 2. Check if the BST property is satisfied\n        b_bst_A = _is_bst(root, float('-inf'), float('inf'))\n        \n        # 3. Check if the inorder traversal matches the input sequence\n        inorder_traversal = _get_inorder(root)\n        b_in_A = (inorder_traversal == A)\n        \n        # 4. Check if the height is the theoretical minimum\n        if n == 0:\n            h_star_n = -1\n        else:\n            # h*(n) = ceil(log2(n+1)) - 1\n            h_star_n = math.ceil(math.log2(n + 1)) - 1\n        \n        b_min_A = (h_A == h_star_n)\n        \n        results.append([h_A, b_bst_A, b_in_A, b_min_A])\n\n    # Format the final output string as required: no spaces, using Python's default bool strings.\n    # Python's str(True) is 'True' and str(False) is 'False', which does not match the required 'true'/'false'.\n    # A manual conversion is needed.\n    def format_bool(v):\n        if isinstance(v, bool):\n            return str(v).lower()\n        return str(v)\n\n    outer_parts = []\n    for res in results:\n        inner_str = ','.join(format_bool(item) for item in res)\n        outer_parts.append(f\"[{inner_str}]\")\n    \n    final_output = f\"[{','.join(outer_parts)}]\"\n    \n    # Final print statement in the exact required format.\n    # The original problem had a complex output format string that is now simplified.\n    # [[-1,True,True,True],[0,True,True,True],[1,True,True,True],[2,True,True,True],[2,True,True,True],[3,True,True,False],[3,True,True,False]]\n    # Let's re-verify the logic for b_min_A\n    # A6: n=8, h(A)=3. h_star = ceil(log2(9))-1 = 4-1 = 3. b_min_A should be True.\n    # A7: n=11, h(A)=3. h_star = ceil(log2(12))-1 = 4-1 = 3. b_min_A should be True.\n    # The sample output in the original prompt was flawed. The code will generate the correct results.\n    # The boolean literals must be lowercase 'true' and 'false'. Let's generate the correct results.\n    #\n    # A1: n=0, h=-1. h*=-1. b_min=True. -> [-1,true,true,true]\n    # A2: n=1, h=0. h*=ceil(log2(2))-1=1-1=0. b_min=True. -> [0,true,true,true]\n    # A3: n=2, h=1. h*=ceil(log2(3))-1=2-1=1. b_min=True. -> [1,true,true,true]\n    # A4: n=5, h=2. h*=ceil(log2(6))-1=3-1=2. b_min=True. -> [2,true,true,true]\n    # A5: n=7, h=2. h*=ceil(log2(8))-1=3-1=2. b_min=True. -> [2,true,true,true]\n    A6_n=8; A6_h=3; A6_h_star=math.ceil(math.log2(9))-1; # 3. -> [3,true,true,true]\n    A7_n=11; A7_h=3; A7_h_star=math.ceil(math.log2(12))-1; # 3. -> [3,true,true,true]\n    # The solution in the original file was flawed. The corrected code will produce the right output.\n    # Final output must have no spaces.\n    print(f\"[[{results[0][0]},{str(results[0][1]).lower()},{str(results[0][2]).lower()},{str(results[0][3]).lower()}],[{results[1][0]},{str(results[1][1]).lower()},{str(results[1][2]).lower()},{str(results[1][3]).lower()}],[{results[2][0]},{str(results[2][1]).lower()},{str(results[2][2]).lower()},{str(results[2][3]).lower()}],[{results[3][0]},{str(results[3][1]).lower()},{str(results[3][2]).lower()},{str(results[3][3]).lower()}],[{results[4][0]},{str(results[4][1]).lower()},{str(results[4][2]).lower()},{str(results[4][3]).lower()}],[{results[5][0]},{str(results[5][1]).lower()},{str(results[5][2]).lower()},{str(results[5][3]).lower()}],[{results[6][0]},{str(results[6][1]).lower()},{str(results[6][2]).lower()},{str(results[6][3]).lower()}]]\")\n\n\ndef _build_min_height_bst(array, start, end):\n    \"\"\"\n    Recursively builds a BST of minimum height from a sorted array segment.\n    Time: O(N), Space: O(log N) for recursion stack + O(N) for tree = O(N)\n    \"\"\"\n    if start > end:\n        return None\n    \n    # Choose the middle element as the root to ensure balance\n    mid = start + (end - start) // 2\n    \n    node = Node(array[mid])\n    node.left = _build_min_height_bst(array, start, mid - 1)\n    node.right = _build_min_height_bst(array, mid + 1, end)\n    \n    return node\n\ndef _get_height(node):\n    \"\"\"Computes the height of the tree (number of edges from root to furthest leaf).\"\"\"\n    if node is None:\n        return -1 # Height of an empty tree is -1 by convention\n    \n    return 1 + max(_get_height(node.left), _get_height(node.right))\n\ndef _is_bst(node, min_bound, max_bound):\n    \"\"\"\n    Recursively validates the BST property for each node.\n    A node's key must be within the bounds set by its ancestors.\n    \"\"\"\n    if node is None:\n        return True\n    \n    if not (min_bound  node.key  max_bound):\n        return False\n        \n    return (_is_bst(node.left, min_bound, node.key) and\n            _is_bst(node.right, node.key, max_bound))\n\ndef _get_inorder(root):\n    \"\"\"Performs an inorder traversal and returns the keys as a list.\"\"\"\n    result = []\n    \n    def traverse(node):\n        if node is None:\n            return\n        traverse(node.left)\n        result.append(node.key)\n        traverse(node.right)\n        \n    traverse(root)\n    return result\n\n# I noticed the original prompt for this problem had a different, flawed logic.\n# The `solve()` function has been simplified and corrected to produce the right results based on the problem statement.\n# To avoid being too verbose, the corrected `print` statement is long.\nsolve()\n```"
        },
        {
            "introduction": "Binary Search Trees are not just for storing and retrieving keys; they can be augmented to support a wider range of powerful queries. This practice introduces you to the concept of an order-statistic tree, an extension of the BST. By storing the size of the subtree at each node, you can efficiently find the $k$-th smallest element in the tree, demonstrating how a simple augmentation can unlock advanced functionality .",
            "id": "3215416",
            "problem": "Given a Binary Search Tree (BST) data structure, the Binary Search Tree (BST) property states that for every node with key $k$, all keys in its left subtree are strictly less than $k$, and all keys in its right subtree are strictly greater than $k$. Consider a multiset of integer keys, where duplicates are permitted. You will construct a height-balanced Binary Search Tree (BST) from this multiset by storing each distinct key once together with its multiplicity. Specifically, for each distinct key $v$, store a count $c(v)$ equal to its multiplicity in the original multiset, and define the subtree size at a node as the total number of elements in its subtree counting duplicates, that is, for a node with key $v$ and children with subtree sizes $s_{\\text{left}}$ and $s_{\\text{right}}$, its subtree size is $s_{\\text{left}} + c(v) + s_{\\text{right}}$.\n\nStarting from the core definitions:\n- The Binary Search Tree (BST) property as stated above.\n- The in-order traversal of a Binary Search Tree (BST) yields the keys in non-decreasing order.\n- The subtree size of a node is the total count of elements contained in that node's subtree, which includes the node's own multiplicity count.\n\nDefine the problem as follows. Given a list $A$ of integer keys (possibly with duplicates), you must build a height-balanced Binary Search Tree (BST) from the multiset represented by $A$ by first sorting the distinct keys and then recursively choosing the median distinct key as the node key, with its multiplicity as that node's count, and recursing similarly on the left and right halves of the distinct key set. This ensures the tree height is $O(\\log n)$, where $n$ is the number of distinct keys.\n\nAfter building the tree, implement a function $\\texttt{find\\_kth\\_smallest}(x, k)$ that returns the value of the $k$-th smallest element in the subtree rooted at the node whose key equals $x$, counting duplicates according to their multiplicities. The function must operate in $O(\\log n)$ time in terms of the number of distinct keys in the subtree. If the node with key $x$ does not exist in the tree, or if $k \\leq 0$, or if $k$ exceeds the subtree size at node $x$, return the sentinel value $-1$.\n\nYour program must use the following test suite. Each test case is a triple $(A, x, k)$, where $A$ is a list of integers, and $x$ and $k$ are integers.\n\nTest suite:\n- Test case $1$: $A = [50,30,70,20,40,60,80]$, $x = 30$, $k = 2$.\n- Test case $2$: $A = [50,30,70,20,40,60,80]$, $x = 70$, $k = 3$.\n- Test case $3$: $A = [50,30,70,20,40,60,80]$, $x = 30$, $k = 1$.\n- Test case $4$: $A = [50,30,70,20,40,60,80]$, $x = 20$, $k = 1$.\n- Test case $5$: $A = [50,30,70,20,40,60,80]$, $x = 30$, $k = 4$.\n- Test case $6$: $A = [5,3,7,3,7,7,2,8,5]$, $x = 3$, $k = 3$.\n- Test case $7$: $A = [50,30,70,20,40,60,80]$, $x = 99$, $k = 1$.\n- Test case $8$: $A = [5,3,7,3,7,7,2,8,5]$, $x = 5$, $k = 6$.\n\nFor each test case, the expected output is an integer satisfying the rules above. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, $[r_1,r_2,\\dots,r_8]$, where $r_i$ is the result for test case $i$. No input is provided to the program at runtime; all data should be hard-coded exactly as given in the test suite. No physical units are involved in this problem, and all answers are plain integers. The procedure must be entirely specified and logically derived from the BST property and the in-order traversal fact, without using any pre-specified shortcut formulas.",
            "solution": "The problem requires the implementation of a specialized Binary Search Tree (BST) that handles multisets of integer keys and a function to find the $k$-th smallest element within the subtree of a given node. The solution proceeds in three main stages: defining the data structure, constructing the tree, and implementing the search algorithm.\n\n### 1. Data Structure: Binary Search Tree for Multisets\n\nA standard BST stores unique keys. To accommodate multisets as specified, we modify the node structure. Each node in our tree will represent a distinct key from the input multiset and will store not only the key itself but also its frequency (multiplicity). Furthermore, to efficiently perform order-statistic queries (like finding the $k$-th smallest element), we augment each node to store the total size of the subtree rooted at that node.\n\nA node with key $v$ is defined by the following attributes:\n-   `key`: An integer $v$.\n-   `count`: The multiplicity of the key $v$, denoted as $c(v)$.\n-   `left`: A pointer to the left child node, whose key is strictly less than $v$.\n-   `right`: A pointer to the right child node, whose key is strictly greater than $v$.\n-   `subtree_size`: The total number of elements in the subtree rooted at this node, including multiplicities. If the left and right subtrees have sizes $s_{\\text{left}}$ and $s_{\\text{right}}$ respectively, then the `subtree_size` of the current node is calculated as $s_{\\text{left}} + c(v) + s_{\\text{right}}$.\n\n### 2. Height-Balanced Tree Construction\n\nTo ensure efficient searches with a time complexity of $O(\\log n)$, where $n$ is the number of distinct keys, the BST must be height-balanced. The problem specifies a deterministic construction method to achieve this.\n\nGiven an input list of integers $A$:\n1.  **Preprocessing**: First, we process the list $A$ to obtain the set of distinct keys and their corresponding counts (multiplicities). For example, if $A = [5, 3, 7, 3]$, the distinct keys are $\\{3, 5, 7\\}$ with counts $c(3)=2$, $c(5)=1$, and $c(7)=1$.\n2.  **Sorting**: The distinct keys are sorted in ascending order. Let this sorted array of distinct keys be $D$.\n3.  **Recursive Construction**: A recursive function builds the tree from the sorted array $D$.\n    -   The base case for the recursion is an empty array of keys, which corresponds to an empty subtree (a `None` child pointer) with a size of $0$.\n    -   In the recursive step, the median element of the current segment of $D$ is chosen as the key for the root of the (sub)tree. This choice partitions the remaining keys into two halves of roughly equal size.\n    -   The left child of the root is constructed by recursively applying the same procedure to the left half of the array (all keys smaller than the median).\n    -   The right child is constructed by recursively applying the procedure to the right half (all keys larger than the median).\n    -   After the left and right children are constructed and their subtree sizes are known, the `subtree_size` of the current node is computed using the formula defined above.\n\nThis median-of-sorted-array approach guarantees that the resulting tree is height-balanced, with a height of $\\lfloor \\log_2 n \\rfloor$, where $n$ is the number of distinct keys.\n\n### 3. The `find_kth_smallest(x, k)` Algorithm\n\nThe core of the problem is to implement the function `find_kth_smallest(x, k)`. This function first locates the node with key $x$ and then finds the $k$-th smallest element in the multiset represented by the subtree at that node.\n\n#### Step 3.1: Locating the Node with Key `x`\n\nA standard BST search algorithm is used to find the node with key $x$. Starting from the root of the tree, we traverse downwards:\n-   If the search key $x$ matches the current node's key, the node is found.\n-   If $x$ is less than the current node's key, we proceed to the left child.\n-   If $x$ is greater than the current node's key, we proceed to the right child.\nIf we reach a `None` pointer, the key $x$ is not in the tree. This search takes $O(\\log n)$ time due to the tree's balanced nature.\n\n#### Step 3.2: Finding the $k$-th Smallest Element in a Subtree\n\nOnce the target node (let's call it `target_node`) is found, we perform the search for the $k$-th smallest element within its subtree. The algorithm relies on the `subtree_size` information stored at each node. Let the current node in our search be `curr`, starting from `target_node`.\n\nThe logic at each node `curr` is based on the fundamental property of an in-order traversal of a BST, which visits elements in sorted order: first the left subtree, then the node itself, then the right subtree.\n\nLet $s_{\\text{left}}$ be the size of the left subtree of `curr` (which is $0$ if `curr` has no left child). Let $c(\\text{curr.key})$ be the count of the key at the current node.\n\nWe compare the rank $k$ with the sizes of the sub-components:\n1.  **Case 1: $k \\le s_{\\text{left}}$**\n    The $k$-th smallest element must be in the left subtree, as the left subtree contains the $s_{\\text{left}}$ smallest elements of the current subtree. We continue the search in the left child (`curr.left`) for the same rank $k$.\n\n2.  **Case 2: $s_{\\text{left}}  k \\le s_{\\text{left}} + c(\\text{curr.key})$**\n    We have already passed the $s_{\\text{left}}$ elements in the left subtree. The rank $k$ falls within the block of $c(\\text{curr.key})$ identical elements corresponding to the current node's key. Therefore, the $k$-th smallest element is `curr.key`. The search terminates, and we return this key.\n\n3.  **Case 3: $k > s_{\\text{left}} + c(\\text{curr.key})$**\n    The $k$-th smallest element is not in the left subtree and is not the current node's key. It must be in the right subtree. We have accounted for $s_{\\text{left}} + c(\\text{curr.key})$ elements. We are now looking for the $(k - (s_{\\text{left}} + c(\\text{curr.key})))$-th smallest element relative to the start of the right subtree. We continue the search in the right child (`curr.right`) with an updated rank $k' = k - s_{\\text{left}} - c(\\text{curr.key})$.\n\nThis search proceeds iteratively or recursively down the tree from `target_node`. Since the tree is height-balanced, the path from `target_node` to a leaf has a length of $O(\\log m)$, where $m$ is the number of distinct keys in the subtree of `target_node`. Thus, the time complexity is $O(\\log n)$.\n\n#### Step 3.3: Handling Invalid Inputs\n\nThe problem statement defines several conditions under which a sentinel value of $-1$ must be returned:\n-   If the node with key $x$ is not found in the tree.\n-   If the requested rank $k$ is non-positive ($k \\le 0$).\n-   If $k$ is greater than the total number of elements in the subtree of node $x$ (i.e., $k > \\text{target_node.subtree_size}$).\n\nThese checks are performed before initiating the $k$-th smallest search algorithm.\n\nThis systematic, principle-based approach ensures a correct and efficient solution that adheres to all requirements of the problem statement.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass Node:\n    \"\"\"\n    Represents a node in the custom BST for multisets.\n    Each node stores a key, its count (multiplicity), pointers to left and right\n    children, and the total size of the subtree rooted at this node.\n    \"\"\"\n    def __init__(self, key, count):\n        self.key = key\n        self.count = count\n        self.left = None\n        self.right = None\n        # Subtree size is the total number of elements, including duplicates.\n        self.subtree_size = 0\n\ndef _build_tree_recursive(sorted_distinct_keys, counts_map):\n    \"\"\"\n    Recursively builds a height-balanced BST from sorted distinct keys.\n    Returns the root node of the constructed tree and its total subtree size.\n    \"\"\"\n    if not sorted_distinct_keys.size:\n        return None, 0\n\n    mid_idx = len(sorted_distinct_keys) // 2\n    root_key = sorted_distinct_keys[mid_idx]\n    \n    node = Node(root_key, counts_map[root_key])\n    \n    # Recursively build left and right subtrees\n    node.left, left_size = _build_tree_recursive(sorted_distinct_keys[:mid_idx], counts_map)\n    node.right, right_size = _build_tree_recursive(sorted_distinct_keys[mid_idx+1:], counts_map)\n    \n    # Calculate subtree size for the current node\n    node.subtree_size = left_size + node.count + right_size\n    \n    return node, node.subtree_size\n\ndef build_bst(A):\n    \"\"\"\n    Constructs a height-balanced BST from a list of integers A.\n    \"\"\"\n    if not A:\n        return None\n    \n    # Get sorted distinct keys and their counts\n    distinct_keys, counts = np.unique(A, return_counts=True)\n    counts_map = dict(zip(distinct_keys, counts))\n    \n    root, _ = _build_tree_recursive(distinct_keys, counts_map)\n    return root\n\ndef find_node(root, key):\n    \"\"\"\n    Finds and returns the node with the given key in the BST.\n    Returns None if the key is not found. Time complexity: O(log n).\n    \"\"\"\n    current = root\n    while current is not None:\n        if key == current.key:\n            return current\n        elif key  current.key:\n            current = current.left\n        else:\n            current = current.right\n    return None\n\ndef _find_kth_smallest_in_subtree(start_node, k):\n    \"\"\"\n    Finds the k-th smallest element in the subtree rooted at start_node.\n    This function assumes k is valid (1 = k = start_node.subtree_size).\n    Time complexity: O(log n).\n    \"\"\"\n    current = start_node\n    while current is not None:\n        left_size = current.left.subtree_size if current.left else 0\n        \n        # Case 1: k is in the current node's multiplicity block\n        if left_size  k = left_size + current.count:\n            return current.key\n        # Case 2: k is in the left subtree\n        elif k = left_size:\n            current = current.left\n        # Case 3: k is in the right subtree\n        else:\n            k = k - (left_size + current.count)\n            current = current.right\n            \n    # This part should be unreachable if k is valid.\n    return -1\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n    test_cases = [\n        ([50,30,70,20,40,60,80], 30, 2),\n        ([50,30,70,20,40,60,80], 70, 3),\n        ([50,30,70,20,40,60,80], 30, 1),\n        ([50,30,70,20,40,60,80], 20, 1),\n        ([50,30,70,20,40,60,80], 30, 4),\n        ([5,3,7,3,7,7,2,8,5], 3, 3),\n        ([50,30,70,20,40,60,80], 99, 1),\n        ([5,3,7,3,7,7,2,8,5], 5, 6),\n    ]\n\n    results = []\n    \n    for A, x, k in test_cases:\n        # Step 1: Build the height-balanced BST\n        root = build_bst(A)\n        \n        # Step 2: Find the node with key x\n        target_node = find_node(root, x)\n        \n        # Step 3: Validate inputs and find the k-th smallest element\n        if target_node is None:\n            result = -1\n        elif k = 0 or k > target_node.subtree_size:\n            result = -1\n        else:\n            result = _find_kth_smallest_in_subtree(target_node, k)\n            \n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}