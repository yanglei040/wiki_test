{
    "hands_on_practices": [
        {
            "introduction": "学习自平衡二叉搜索树，第一步是深刻理解其背后复杂的维护规则。本练习将带你从理论走向实践，通过编写一个红黑树验证器，你将不再仅仅是记忆红黑树的五条性质，而是要将这些性质转化为精确的代码逻辑。这个过程能极大地巩固你对数据结构不变量的理解，是掌握更高级操作的基础。",
            "id": "3269583",
            "problem": "设计并实现一个验证器，用于判断给定的着色二叉搜索树是否为有效的红黑树 (RBT)，时间复杂度为 $O(N)$，其中 $N$ 是从指定根节点可达的节点数。该验证器必须从第一性原理出发，仅从核心定义开始，并且对所有有限树都必须是正确的。\n\n红黑树 (RBT) 是一种二叉搜索树 (BST)，其每个内部节点都带有一种颜色，并满足以下从搜索树的基本定义和平衡黑高概念派生出的不变量：\n- 二叉搜索树 (BST) 属性：对于每个键为 $k$ 的节点，其左子树中的所有键都严格小于 $k$，其右子树中的所有键都严格大于 $k$。假设键是整数且严格有序。\n- 根颜色属性：根节点（如果存在）被着色为黑色。\n- 红色属性 (无红-红边)：红色节点不能有红色的子节点。\n- 黑高属性：对于每个节点，从该节点到其任何后代空叶节点的任意简单路径上，黑色节点的数量相同。此处的空子节点被视作黑色叶节点。\n- 按照约定，空树被认为是黑高为 $0$ 的有效红黑树。\n\n在程序内部使用的输入模型（不应读取外部输入）：一个着色的 BST 表示为一个序对 $(\\text{nodes}, \\text{root})$，其中：\n- $\\text{nodes}$ 是一个从 $0$ 到 $n-1$ 索引的数组，每个条目是一个记录 $(\\text{key}, \\text{color}, \\text{left}, \\text{right})$。\n- $\\text{key}$ 是一个整数键。\n- $\\text{color}$ 是一个字符，'B' (黑色) 或 'R' (红色)。\n- $\\text{left}$ 和 $\\text{right}$ 是子节点在 $\\{0,\\dots,n-1\\}$ 中的索引，或用 $-1$ 表示空子节点。\n- $\\text{root}$ 是根节点在 $\\{0,\\dots,n-1\\}$ 中的索引，或用 $-1$ 表示空树。\n- 只有从 $\\text{root}$ 可达的节点在语义上是树的一部分；不可达的节点可能存在，但必须被验证器忽略。\n\n任务要求：\n- 推导并实现一个验证算法，该算法仅使用上述定义，通过一次深度优先遍历，同时强制执行 BST 排序约束、红色属性和黑高均等性，从而在 $O(N)$ 时间和 $O(H)$ 额外空间内检查所有 RBT 不变量，其中 $H$ 是树的高度。\n- 程序应硬编码并评估以下参数值测试套件，每个都是一个独立的 $(\\text{nodes}, \\text{root})$ 实例。对于每种情况，返回一个布尔值，指示该实例是否为有效的 RBT。\n\n嵌入程序中的测试套件：\n\n- 情况 1 (有效的 RBT，非平凡)：\n  - $\\text{nodes} = [ (10, 'B', 1, 2), (5, 'R', 3, 4), (15, 'B', -1, -1), (2, 'B', -1, -1), (7, 'B', -1, -1) ]$\n  - $\\text{root} = 0$\n\n- 情况 2 (右子树中存在 BST 排序违规)：\n  - $\\text{nodes} = [ (10, 'B', 1, 2), (5, 'R', 3, 4), (9, 'B', -1, -1), (2, 'B', -1, -1), (7, 'B', -1, -1) ]$\n  - $\\text{root} = 0$\n\n- 情况 3 (孤立的红-红违规，所有其他不变量均满足，包括相等的黑高)：\n  - $\\text{nodes} = [ (10, 'B', 1, 2), (5, 'R', 3, -1), (15, 'R', -1, -1), (2, 'R', -1, -1), (7, 'B', -1, -1) ]$\n  - $\\text{root} = 0$\n\n- 情况 4 (黑高不匹配，无红-红违规)：\n  - $\\text{nodes} = [ (10, 'B', 1, 2), (5, 'R', -1, -1), (15, 'B', -1, -1), (2, 'B', -1, -1), (7, 'B', -1, -1) ]$\n  - $\\text{root} = 0$\n\n- 情况 5 (根非黑色，其他不变量满足)：\n  - $\\text{nodes} = [ (10, 'R', 1, 2), (5, 'B', 3, 4), (15, 'B', -1, -1), (2, 'R', -1, -1), (7, 'R', -1, -1) ]$\n  - $\\text{root} = 0$\n\n- 情况 6 (单节点黑树)：\n  - $\\text{nodes} = [ (42, 'B', -1, -1) ]$\n  - $\\text{root} = 0$\n\n- 情况 7 (空树)：\n  - $\\text{nodes} = [\\ ]$\n  - $\\text{root} = -1$\n\n输出格式：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的、以逗号分隔的布尔值列表，其顺序与测试用例的顺序完全一致，例如 $[ \\text{True}, \\text{False}, \\dots ]$。\n\n不允许用户输入或外部文件。所有计算都是无单位且纯组合的；不适用任何物理单位。不使用角度。不出现百分比。每种情况的答案必须是一个布尔值。",
            "solution": "该问题要求设计并实现一个红黑树 (RBT) 的验证器。验证器必须在 $O(N)$ 时间和 $O(H)$ 辅助空间内判断给定的着色二叉搜索树是否为有效的 RBT，其中 $N$ 是从根可达的节点数，$H$ 是树的高度。推导过程必须从第一性原理出发。\n\n### 问题验证\n\n**第 1 步：提取已知条件**\n\n问题提供了有效红黑树的以下定义和约束：\n1.  **二叉搜索树 (BST) 属性**：对于每个键为 $k$ 的节点，其左子树中的所有键都严格小于 $k$，其右子树中的所有键都严格大于 $k$。\n2.  **根颜色属性**：根节点（如果存在）被着色为黑色（'$B$'）。\n3.  **红色属性 (无红-红边)**：红色（'$R$'）节点不能有红色的子节点。\n4.  **黑高属性**：对于每个节点，从该节点到其任何后代空叶节点的任意简单路径上，黑色节点的数量相同。空子节点被视作黑色叶节点。\n5.  **空树**：空树是有效的 RBT。\n\n输入是一个序对 $(\\text{nodes}, \\text{root})$，其中 $\\text{nodes}$ 是节点记录 $(\\text{key}, \\text{color}, \\text{left}, \\text{right})$ 的数组，而 `root` 是根节点的索引。根索引为 $-1$ 表示空树。\n\n**第 2 步：使用提取的已知条件进行验证**\n\n根据所需标准对问题陈述进行评估：\n-   **科学上成立**：该问题基于红黑树的正式定义，这是计算机科学中的一个经典数据结构。所列出的属性是 RBT 的标准、普遍接受的不变量。该问题在科学上是合理的。\n-   **定义明确**：问题定义清晰。输入格式已指定，期望的输出是一个布尔判定。时间和空间复杂度约束（$O(N)$ 和 $O(H)$）是具体且可实现的。对于任何给定的输入，都存在唯一、正确的答案。\n-   **客观性**：问题使用正式、客观的定义进行陈述，避免了任何主观或模糊的语言。\n\n该问题没有任何导致其无效的缺陷。它是算法和数据结构领域中一个定义明确的正式问题。\n\n**第 3 步：结论与行动**\n\n该问题是**有效的**。将开发并实现一个解决方案。\n\n### 验证算法的推导\n\n目标是在单次遍历中同时验证所有 RBT 属性，以实现 $O(N)$ 的时间复杂度。对树进行递归的深度优先遍历是自然的方法。我们将设计一个递归辅助函数，该函数遍历树并在此过程中验证属性。\n\n设递归辅助函数为 `validate_subtree(node_idx, parent_color, min_bound, max_bound)`。此函数将分析以索引 `node_idx` 为根的子树，并返回一个序对 `(is_valid, black_height)`，其中 `is_valid` 是一个布尔值，指示该子树是否满足 RBT 属性（给定其祖先的上下文），而 `black_height` 是从 `node_idx` 到任一后代空叶节点的路径上黑色节点的数量，包括 `node_idx` 和空叶节点。\n\n**1. 基本情况：空节点**\n\n空节点由索引 $-1$ 表示。根据**黑高属性**，空子节点被视为黑色叶节点。因此，从一个空叶节点到其自身的路径只包含一个节点（即空叶节点本身），它是黑色的。所以，一个空子树的黑高是 $1$。一个空子树自然满足所有其他属性。\n-   `validate_subtree(-1, ...)` 返回 `(True, 1)`。\n\n**2. 递归步骤：内部节点**\n\n对于索引为 `node_idx` 的内部节点，我们必须验证所有属性。\n\n-   **不可达节点**：遍历从指定的 `root` 开始，并且只跟随有效的子节点索引。`nodes` 数组中任何从 `root` 不可达的节点都永远不会被访问，从而按照问题规范正确地忽略它们。\n\n-   **红色属性**：此属性规定红色节点不能有红色子节点。为了检查这一点，递归函数必须知道父节点的颜色。参数 `parent_color` 即为此目的。在当前颜色为 `current_color` 的节点上，我们检查 `current_color == 'R'` 且 `parent_color == 'R'` 是否成立。如果满足此条件，则违反了该属性。\n\n-   **BST 属性**：为确保树是有效的二叉搜索树，每个节点的键必须位于其祖先定义的特定范围内。根节点可以有任何键。对于任何其他节点，其键必须大于其左链祖先的键，且小于其右链祖先的键。我们通过传递一个有效范围 `(min_bound, max_bound)` 来强制执行此约束。对于键为 $k$ 的节点，其左子树中的所有键必须在 `(min_bound, k)` 范围内，其右子树中的所有键必须在 `(k, max_bound)` 范围内。\n\n-   **黑高属性**：此属性规定，对于任何节点 $n$，从 $n$ 到任何后代空叶节点的简单路径上的黑色节点数量是恒定的。设此数为 $BH(n)$。如果节点 $n$ 有子节点 $n_l$ 和 $n_r$，则从 $n$ 出发的任何路径都必须经过 $n_l$ 或 $n_r$。为了使黑色节点的总数恒定，必须有 $BH(n_l) = BH(n_r)$。我们的递归函数返回它所验证的子树的黑高。因此，在对左右子节点的递归调用返回 `(is_left_valid, left_bh)` 和 `(is_right_valid, right_bh)` 之后，我们必须检查 `left_bh == right_bh` 是否成立。如果它们不相等，则违反了该属性。\n\n-   **计算黑高**：如果子节点满足属性，则当前节点子树的黑高 $BH(\\text{node})$ 是根据其子节点（现已验证相等）的黑高 $BH(\\text{child})$ 及其自身颜色计算的。从当前节点开始的路径上的黑色节点计数是其自身的贡献（如果为黑色则为 $1$，如果为红色则为 $0$）加上其子节点的计数。因此，$BH(\\text{node}) = BH(\\text{child}) + (\\text{如果节点是黑色的则为 1，否则为 0})$。\n\n**3. 主验证函数**\n\n主函数 `is_valid_rbt(nodes, root)` 协调验证过程。\n\n1.  **空树**：如果 `root` 是 $-1$，则树为空。根据定义，这是一个有效的 RBT。返回 `True`。\n2.  **根颜色属性**：如果树非空，则根节点必须是黑色的。我们获取根节点的数据并检查其颜色。如果为红色，则树无效。返回 `False`。\n3.  **启动遍历**：遍历从根开始。根没有父节点，因此我们可以认为其父节点是“黑色”的，以确保“红色属性”检查不会错误地失败。初始键范围是无界的，表示为 $(-\\infty, +\\infty)$。\n4.  **最终判定**：主函数调用 `validate_subtree(root, 'B', -infinity, +infinity)` 并返回结果元组的布尔部分。\n\n这个全面的、单次遍历的递归算法验证了所有指定的属性。它对每个可达节点只访问一次，在每个节点上执行常数时间的工作。这导致时间复杂度为 $O(N)$。空间复杂度由递归栈的最大深度决定，该深度等于树的高度 $H$，因此实现了 $O(H)$ 的辅助空间。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the RBT verification problem for a hard-coded suite of test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (valid RBT, non-trivial)\n        (\n            [ (10, 'B', 1, 2), (5, 'R', 3, 4), (15, 'B', -1, -1), (2, 'B', -1, -1), (7, 'B', -1, -1) ],\n            0\n        ),\n        # Case 2 (BST ordering violation in the right subtree)\n        (\n            [ (10, 'B', 1, 2), (5, 'R', 3, 4), (9, 'B', -1, -1), (2, 'B', -1, -1), (7, 'B', -1, -1) ],\n            0\n        ),\n        # Case 3 (isolated red-red violation)\n        (\n            [ (10, 'B', 1, 2), (5, 'R', 3, -1), (15, 'R', -1, -1), (2, 'R', -1, -1), (7, 'B', -1, -1) ],\n            0\n        ),\n        # Case 4 (black-height mismatch)\n        (\n            [ (10, 'B', 1, 2), (5, 'R', -1, -1), (15, 'B', -1, -1), (2, 'B', -1, -1), (7, 'B', -1, -1) ],\n            0\n        ),\n        # Case 5 (root not black)\n        (\n            [ (10, 'R', 1, 2), (5, 'B', 3, 4), (15, 'B', -1, -1), (2, 'R', -1, -1), (7, 'R', -1, -1) ],\n            0\n        ),\n        # Case 6 (single-node black tree)\n        (\n            [ (42, 'B', -1, -1) ],\n            0\n        ),\n        # Case 7 (empty tree)\n        (\n            [],\n            -1\n        ),\n    ]\n\n    results = []\n    for nodes, root in test_cases:\n        verifier = RBTVerifier(nodes)\n        results.append(verifier.is_valid_rbt(root))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nclass RBTVerifier:\n    \"\"\"\n    A verifier for Red-Black Trees derived from first principles.\n    \"\"\"\n    def __init__(self, nodes):\n        self._nodes = nodes\n\n    def is_valid_rbt(self, root_idx: int) -> bool:\n        \"\"\"\n        Checks if the tree rooted at root_idx is a valid Red-Black Tree.\n        \"\"\"\n        # Property 5: The empty tree is a valid RBT.\n        if root_idx == -1:\n            return True\n\n        root_node = self._nodes[root_idx]\n        root_color = root_node[1]\n\n        # Property 2: The root node, if it exists, is colored black.\n        if root_color == 'R':\n            return False\n\n        # Start recursive validation. The root's parent can be considered black.\n        # The key range for the root is unbounded.\n        is_valid, _ = self._validate_subtree(root_idx, 'B', float('-inf'), float('inf'))\n        return is_valid\n\n    def _validate_subtree(self, node_idx: int, parent_color: str, min_bound: float, max_bound: float) -> tuple[bool, int]:\n        \"\"\"\n        Recursively validates the RBT properties for the subtree at node_idx.\n\n        Returns a tuple: (is_valid, black_height).\n        black_height is the count of black nodes on any path from this node\n        to a descendant null leaf, inclusive of this node and the null leaf.\n        A black_height of 0 is used to signal failure internally.\n        \"\"\"\n        # Base case: A null child is a conceptual black leaf.\n        # The path from this leaf to itself contains one node (itself), which is black.\n        # Its black-height is 1.\n        if node_idx == -1:\n            return True, 1\n\n        key, color, left_idx, right_idx = self._nodes[node_idx]\n\n        # Property 3 (Red Property): A red node cannot have a red child.\n        if color == 'R' and parent_color == 'R':\n            return False, 0\n\n        # Property 1 (BST Property): Key must be within the bounds set by ancestors.\n        if not (min_bound  key  max_bound):\n            return False, 0\n        \n        # Recurse on children, updating bounds and passing current node's color.\n        left_valid, left_bh = self._validate_subtree(left_idx, color, min_bound, key)\n        if not left_valid:\n            return False, 0\n            \n        right_valid, right_bh = self._validate_subtree(right_idx, color, key, max_bound)\n        if not right_valid:\n            return False, 0\n\n        # Property 4 (Black-height Property): All simple paths from this node to\n        # descendant leaves must contain the same number of black nodes.\n        # This means the black-heights returned by its children must be equal.\n        if left_bh != right_bh:\n            return False, 0\n\n        # This subtree is valid. Calculate its black-height.\n        # The black-height is the child's black-height plus 1 if this node is black.\n        current_bh = left_bh + (1 if color == 'B' else 0)\n        \n        return True, current_bh\n\n\nif __name__ == '__main__':\n    solve()\n\n```"
        },
        {
            "introduction": "在掌握了红黑树的基本操作（插入和删除）之后，一个自然而然的挑战是如何扩展其功能。这个练习要求你设计一个高效的“键值更新”操作，这在实际应用中非常常见。解决这个问题的关键在于思维的转换：不要试图在原地修改节点并进行复杂的修复，而是要学会利用已有的、可靠的基本操作来组合成新的、功能更强的算法。",
            "id": "3269521",
            "problem": "要求你从二叉搜索树 (BST) 和红黑树 (RBT) 的基本定义出发进行推理，并实现一个程序，在对数时间内支持红黑树中的键值更新操作。二叉搜索树 (BST) 存储可比较的键，使得其中序遍历会得到一个严格递增的序列。红黑树 (RBT) 是一种带有颜色的增强型 BST，满足以下经典约束条件：每个节点要么是红色要么是黑色；根节点是黑色；每个叶子哨兵（空子节点）是黑色；每个红色节点的子节点都是黑色；从任一节点到其每个后代叶子节点的每条简单路径都包含相同数量的黑色节点。这些经过充分检验的性质意味着，标准的 RBT 插入和删除操作通过执行对数次旋转和重新着色，并始终保持 BST 的排序性质，其运行时间为 $O(\\log N)$，其中 $N$ 是键的数量。\n\n请设计一个算法，在 $O(\\log N)$ 时间内更新 RBT 中的一个键，此算法仅能基于基本定义和已有的标准 RBT 插入和删除过程。更新操作必须接受一个现有键 $k_{\\text{old}}$ 和一个新键 $k_{\\text{new}}$，并将树进行转换，使得原先等于 $k_{\\text{old}}$ 的键变为 $k_{\\text{new}}$，同时保持 BST 的排序性质和 RBT 的约束条件。你必须明确处理以下情况：\n- 如果 $k_{\\text{old}}$ 不在树中，不执行任何更改。\n- 如果 $k_{\\text{new}}$ 已经存在于树中且 $k_{\\text{new}} \\neq k_{\\text{old}}$，不执行任何更改。\n- 如果 $k_{\\text{new}} = k_{\\text{old}}$ 且 $k_{\\text{old}}$ 存在，这是一个空操作。\n\n每个测试用例的输出必须以一个列表的形式量化树的最终状态，该列表按顺序包含以下组成部分：\n- 一个整数有效性标志，当且仅当最终的树满足所有 RBT 约束条件并且是一个有效的 BST 时为 $1$，否则为 $0$。\n- 最终的键数量（一个整数）。\n- 树的黑高（一个整数），定义为从根节点到任一空叶子哨兵（包括哨兵）的简单路径上的黑色节点数量；如果树不是一个有效的 RBT，则此项输出 $-1$。\n- 树的高度（一个整数），定义为从根到叶子的最长简单路径上的实节点数量；空树的高度为 $0$。\n- 中序遍历，以严格递增的整数列表形式表示。\n\n你的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如，`\"[result1,result2,result3]\"`）。每个结果都必须是按上述结构组织的列表。\n\n测试套件。对于每个测试，初始树通过按所列顺序插入给定的键来构建，然后按顺序应用所列的更新请求序列 $(k_{\\text{old}}, k_{\\text{new}})$。键是整数，初始列表包含唯一值。\n- 测试 1：\n  - 初始键：$[10, 20, 30, 15, 25, 5, 1]$。\n  - 更新：$(15, 17)$、$(25, 22)$、$(1, 26)$。\n- 测试 2：\n  - 初始键：$[7, 3, 18, 10, 22, 8, 11, 26]$。\n  - 更新：$(3, 2)$、$(26, 30)$、$(7, 7)$、$(8, 9)$。\n- 测试 3：\n  - 初始键：$[1, 2, 3, 4, 5]$。\n  - 更新：$(6, 0)$、$(2, 3)$、$(5, 5)$、$(4, -1)$。\n- 测试 4：\n  - 初始键：$[50, 25, 75, 12, 37, 62, 87, 6, 18, 31, 43, 56, 68, 81, 93]$。\n  - 更新：$(37, 38)$、$(62, 24)$、$(81, 90)$、$(12, 13)$、$(93, 1)$。\n\n你的实现必须基于上述核心定义和事实，不得假定任何专门的快捷公式。更新操作所需的时间复杂度为 $O(\\log N)$，并需从第一性原理出发进行论证。最终输出必须是单行，格式为类似 JSON 的 Python 列表，其中包含按上述测试顺序排列的每个测试用例的结果列表。",
            "solution": "该问题要求设计并实现一个算法，在 $O(\\log N)$ 时间内将红黑树 (RBT) 中的一个键从值 $k_{\\text{old}}$ 更新为 $k_{\\text{new}}$，其中 $N$ 是树中键的数量。该解决方案必须从二叉搜索树 (BST) 和红黑树 (RBT) 的基本性质推导得出。\n\n二叉搜索树维持一个关键的不变性：对于任意键为 $k$ 的节点，其左子树中的所有键都小于 $k$，其右子树中的所有键都大于 $k$。这个性质决定了树中每个节点的结构位置。红黑树是一种特殊类型的自平衡 BST，它在维持这种排序性质的同时，还满足一组基于颜色的不变性，以确保树的高度保持为节点数量的对数级别，即 $O(\\log N)$。由于只需要有限数量的局部重新着色和结构调整操作（旋转），RBT 上的标准插入和删除操作能够保持所有不变性，并在 $O(\\log N)$ 时间内完成。\n\n考虑一种朴素的更新操作方法：\n1. 找到包含键 $k_{\\text{old}}$ 的节点 $x$。\n2. 直接修改此节点的键：$x.key \\leftarrow k_{\\text{new}}$。\n\n这种方法是有缺陷的，因为它可能违反基本的 BST 排序性质。节点 $x$ 在树中的特定位置是基于 $k_{\\text{old}}$ 的值相对于其祖先和后代确定的。将其键更改为 $k_{\\text{new}}$ 并不会改变其位置。如果 $k_{\\text{new}}$ 违反了与 $x$ 的父节点、子节点或树中任何其他节点的排序关系，BST 性质就会被破坏。例如，如果一个键为 $10$ 的节点有一个键为 $15$ 的右子节点，将父节点的键更新为 $20$ 将违反 BST 性质，因为一个键为 $20$ 的父节点将大于其键为 $15$ 的右子节点。通过移动节点及其子树来修复这种结构性违规，同时保持 RBT 不变性，将是一个高度复杂、非局部的操作，其复杂性可能等同于甚至超过删除和插入操作。\n\n一种更具原则性的方法是认识到，更改键的值等同于更改其在树的顺序中的身份。$k_{\\text{new}}$ 的正确结构位置可能与 $k_{\\text{old}}$ 的完全不同。因此，该操作必须有效地将键从其旧位置“移动”到新位置。使用标准的、定义明确的 RBT 操作来实现此目的的最直接方法是执行一次删除，然后执行一次插入。\n\n提出的算法如下：\n1.  **处理先决条件**：问题为几种边界情况指定了行为。\n    - 如果 $k_{\\text{old}} = k_{\\text{new}}$，则该操作为空操作 (no-op)。无需进行任何更改。\n    - 如果树中已存在键为 $k_{\\text{new}}$ 的节点（且 $k_{\\text{new}} \\neq k_{\\text{old}}$），则不应执行任何更改。这可以防止创建重复的键，因为这会违反 BST 性质。此检查需要搜索 $k_{\\text{new}}$，耗时 $O(\\log N)$。\n    - 如果树中不存在键 $k_{\\text{old}}$，则不进行任何更改。\n\n2.  **核心逻辑**：如果不满足不执行操作的先决条件（即，$k_{\\text{old}} \\neq k_{\\text{new}}$，$k_{\\text{new}}$ 不在树中，且 $k_{\\text{old}}$ 在树中），则继续进行更新。\n    - **删除**：执行标准的 RBT 删除操作，删除键 $k_{\\text{old}}$。问题指出此操作是可用的，并在 $O(\\log N)$ 时间内运行。这个过程会正确移除节点并重新平衡树以保持所有 RBT 不变性。如果未找到 $k_{\\text{old}}$，`delete` 操作自然不执行任何操作，满足了问题的要求。\n    - **插入**：执行标准的 RBT 插入操作，插入新键 $k_{\\text{new}}$。此操作同样在 $O(\\log N)$ 时间内运行，将新键放置在其正确的结构位置，同时保持所有 RBT 不变性。\n\n**复杂度分析**：\n整个 `update` 算法由常数个标准 RBT 操作组成：\n- 一次搜索操作，检查 $k_{\\text{new}}$ 是否存在：$O(\\log N)$。\n- 一次删除操作，删除 $k_{\\text{old}}$（该操作包含一次搜索）：$O(\\log N)$。\n- 一次插入操作，插入 $k_{\\text{new}}$：$O(\\log N)$。\n\n总时间复杂度是这些操作的总和，即 $O(\\log N) + O(\\log N) + O(\\log N) = O(\\log N)$。这满足了问题的性能要求。这种“先删除后插入”的策略通过利用基础 RBT 操作所保证的正确性和性能，正确而高效地执行了键更新操作。\n\n实现将包含一个完整的 RBT 数据结构，包括 `insert`、`delete`、它们的修复程序（fixup routines）和旋转操作。`update` 方法将如上所述组织这些基本操作。最后，将实现一组验证方法，用以根据所有 BST 和 RBT 不变性检查树的最终状态，并计算所需的输出指标（有效性标志、节点数、黑高、高度和中序遍历）。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport sys\n\n# Increase recursion limit for deep trees; a safeguard for robust tree algorithms.\nsys.setrecursionlimit(2000)\n\nclass Node:\n    \"\"\"A node in the Red-Black Tree.\"\"\"\n    def __init__(self, key, color='RED', parent=None, left=None, right=None):\n        self.key = key\n        self.color = color\n        self.parent = parent\n        self.left = left\n        self.right = right\n    \n    def __repr__(self):\n        return f\"Node(key={self.key}, color={self.color})\"\n\nclass RedBlackTree:\n    \"\"\"A Red-Black Tree implementation supporting key updates.\"\"\"\n    def __init__(self):\n        # The NIL sentinel is a single black node representing all leaves.\n        self.NIL = Node(key=None, color='BLACK')\n        self.root = self.NIL\n        self.size = 0\n\n    def _left_rotate(self, x):\n        y = x.right\n        x.right = y.left\n        if y.left is not self.NIL:\n            y.left.parent = x\n        y.parent = x.parent\n        if x.parent is self.NIL:\n            self.root = y\n        elif x == x.parent.left:\n            x.parent.left = y\n        else:\n            x.parent.right = y\n        y.left = x\n        x.parent = y\n\n    def _right_rotate(self, y):\n        x = y.left\n        y.left = x.right\n        if x.right is not self.NIL:\n            x.right.parent = y\n        x.parent = y.parent\n        if y.parent is self.NIL:\n            self.root = x\n        elif y == y.parent.right:\n            y.parent.right = x\n        else:\n            y.parent.left = x\n        x.right = y\n        y.parent = x\n\n    def insert(self, key):\n        if self.find(key) is not self.NIL:\n            return\n\n        z = Node(key=key, left=self.NIL, right=self.NIL)\n        y = self.NIL\n        x = self.root\n\n        while x is not self.NIL:\n            y = x\n            if z.key  x.key:\n                x = x.left\n            else:\n                x = x.right\n\n        z.parent = y\n        if y is self.NIL:\n            self.root = z\n        elif z.key  y.key:\n            y.left = z\n        else:\n            y.right = z\n\n        z.color = 'RED'\n        self._insert_fixup(z)\n        self.size += 1\n\n    def _insert_fixup(self, z):\n        while z.parent.color == 'RED':\n            if z.parent == z.parent.parent.left:\n                y = z.parent.parent.right  # Uncle\n                if y.color == 'RED':\n                    z.parent.color = 'BLACK'\n                    y.color = 'BLACK'\n                    z.parent.parent.color = 'RED'\n                    z = z.parent.parent\n                else:\n                    if z == z.parent.right:\n                        z = z.parent\n                        self._left_rotate(z)\n                    z.parent.color = 'BLACK'\n                    z.parent.parent.color = 'RED'\n                    self._right_rotate(z.parent.parent)\n            else:\n                y = z.parent.parent.left  # Uncle\n                if y.color == 'RED':\n                    z.parent.color = 'BLACK'\n                    y.color = 'BLACK'\n                    z.parent.parent.color = 'RED'\n                    z = z.parent.parent\n                else:\n                    if z == z.parent.left:\n                        z = z.parent\n                        self._right_rotate(z)\n                    z.parent.color = 'BLACK'\n                    z.parent.parent.color = 'RED'\n                    self._left_rotate(z.parent.parent)\n        self.root.color = 'BLACK'\n\n    def _transplant(self, u, v):\n        if u.parent is self.NIL:\n            self.root = v\n        elif u == u.parent.left:\n            u.parent.left = v\n        else:\n            u.parent.right = v\n        v.parent = u.parent\n\n    def delete(self, key):\n        z = self.find(key)\n        if z is self.NIL:\n            return False\n\n        y = z\n        y_original_color = y.color\n        if z.left is self.NIL:\n            x = z.right\n            self._transplant(z, z.right)\n        elif z.right is self.NIL:\n            x = z.left\n            self._transplant(z, z.left)\n        else:\n            y = self._tree_minimum(z.right)\n            y_original_color = y.color\n            x = y.right\n            if y.parent == z:\n                x.parent = y\n            else:\n                self._transplant(y, y.right)\n                y.right = z.right\n                y.right.parent = y\n            self._transplant(z, y)\n            y.left = z.left\n            y.left.parent = y\n            y.color = z.color\n        \n        if y_original_color == 'BLACK':\n            self._delete_fixup(x)\n        \n        self.size -= 1\n        return True\n\n    def _delete_fixup(self, x):\n        while x is not self.root and x.color == 'BLACK':\n            if x == x.parent.left:\n                w = x.parent.right\n                if w.color == 'RED':\n                    w.color = 'BLACK'\n                    x.parent.color = 'RED'\n                    self._left_rotate(x.parent)\n                    w = x.parent.right\n                if w.left.color == 'BLACK' and w.right.color == 'BLACK':\n                    w.color = 'RED'\n                    x = x.parent\n                else:\n                    if w.right.color == 'BLACK':\n                        w.left.color = 'BLACK'\n                        w.color = 'RED'\n                        self._right_rotate(w)\n                        w = x.parent.right\n                    w.color = x.parent.color\n                    x.parent.color = 'BLACK'\n                    w.right.color = 'BLACK'\n                    self._left_rotate(x.parent)\n                    x = self.root\n            else:\n                w = x.parent.left\n                if w.color == 'RED':\n                    w.color = 'BLACK'\n                    x.parent.color = 'RED'\n                    self._right_rotate(x.parent)\n                    w = x.parent.left\n                if w.right.color == 'BLACK' and w.left.color == 'BLACK':\n                    w.color = 'RED'\n                    x = x.parent\n                else:\n                    if w.left.color == 'BLACK':\n                        w.right.color = 'BLACK'\n                        w.color = 'RED'\n                        self._left_rotate(w)\n                        w = x.parent.left\n                    w.color = x.parent.color\n                    x.parent.color = 'BLACK'\n                    w.left.color = 'BLACK'\n                    self._right_rotate(x.parent)\n                    x = self.root\n        x.color = 'BLACK'\n\n    def find(self, key):\n        x = self.root\n        while x is not self.NIL and key != x.key:\n            if key  x.key:\n                x = x.left\n            else:\n                x = x.right\n        return x\n\n    def _tree_minimum(self, x):\n        while x.left is not self.NIL:\n            x = x.left\n        return x\n\n    def update(self, k_old, k_new):\n        if k_old == k_new:\n            return\n        if self.find(k_new) is not self.NIL:\n            return\n        if self.delete(k_old):\n            self.insert(k_new)\n\n    def get_in_order_traversal(self):\n        result = []\n        def _in_order(node):\n            if node is not self.NIL:\n                _in_order(node.left)\n                result.append(node.key)\n                _in_order(node.right)\n        _in_order(self.root)\n        return result\n\n    def get_height(self):\n        if self.root is self.NIL:\n            return 0\n        def _height(node):\n            if node is self.NIL:\n                return 0\n            return 1 + max(_height(node.left), _height(node.right))\n        return _height(self.root)\n\n    def get_final_state(self):\n        in_order = self.get_in_order_traversal()\n        \n        is_bst = all(in_order[i]  in_order[i+1] for i in range(len(in_order)-1))\n\n        def _validate_rbt(node):\n            if node is self.NIL:\n                return True, True, 1\n            \n            p4_node = True\n            if node.color == 'RED' and (node.left.color == 'RED' or node.right.color == 'RED'):\n                p4_node = False\n            \n            p4_left, p5_left, bh_left = _validate_rbt(node.left)\n            p4_right, p5_right, bh_right = _validate_rbt(node.right)\n            \n            is_p4_valid = p4_node and p4_left and p4_right\n            is_p5_valid = p5_left and p5_right and (bh_left == bh_right)\n            \n            bh = -1\n            if is_p5_valid:\n                bh = bh_left + (1 if node.color == 'BLACK' else 0)\n            \n            return is_p4_valid, is_p5_valid, bh\n\n        validity_flag = 0\n        black_height = -1\n        \n        if self.root is self.NIL:\n            validity_flag = 1\n            black_height = 1\n        elif self.root.color == 'BLACK':\n            p4_valid, p5_valid, bh = _validate_rbt(self.root)\n            if is_bst and p4_valid and p5_valid:\n                validity_flag = 1\n                black_height = bh\n        \n        return [validity_flag, self.size, black_height, self.get_height(), in_order]\n\ndef solve():\n    test_cases = [\n        {\"initial_keys\": [10, 20, 30, 15, 25, 5, 1], \"updates\": [(15, 17), (25, 22), (1, 26)]},\n        {\"initial_keys\": [7, 3, 18, 10, 22, 8, 11, 26], \"updates\": [(3, 2), (26, 30), (7, 7), (8, 9)]},\n        {\"initial_keys\": [1, 2, 3, 4, 5], \"updates\": [(6, 0), (2, 3), (5, 5), (4, -1)]},\n        {\"initial_keys\": [50, 25, 75, 12, 37, 62, 87, 6, 18, 31, 43, 56, 68, 81, 93], \"updates\": [(37, 38), (62, 24), (81, 90), (12, 13), (93, 1)]}\n    ]\n\n    results = []\n    for case in test_cases:\n        tree = RedBlackTree()\n        for key in case[\"initial_keys\"]:\n            tree.insert(key)\n        \n        for k_old, k_new in case[\"updates\"]:\n            tree.update(k_old, k_new)\n            \n        final_state = tree.get_final_state()\n        results.append(final_state)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "伸展树（Splay Tree）的魅力在于其优秀的均摊性能，但理解其单次操作的最坏情况同样重要。本练习将引导你构造一个特殊的序列，从而揭示伸展树在特定场景下的 $O(N)$ 线性时间开销。通过从第一性原理出发，一步步追踪“伸展”操作中的旋转过程，你将对均摊分析与最坏情况分析之间的差异有更直观和深刻的认识。",
            "id": "3269554",
            "problem": "一种自平衡二叉搜索树（BST）是一种二叉搜索树，它在操作过程中执行结构调整以维持良好的高度界限，而无需在每个节点上存储明确的平衡信息。伸展树（splay tree）是一个典型的例子：它执行一系列称为“伸展”（splaying）的旋转操作，将被访问的节点移动到根部。基本操作是单次旋转和三种伸展步骤，这些步骤定义在节点 $x$ 及其父节点 $p$ 和祖父节点 $g$ 上：zig（当 $x$ 没有祖父节点时应用）、zig-zig（当 $x$ 和 $p$ 都是左孩子或都是右孩子时应用），以及 zig-zag（当 $x$ 和 $p$ 分别是左右孩子时应用）。每次旋转都是一次常数时间的指针重排。考虑对一棵伸展树执行以下操作序列，该树在插入和搜索后使用经典的自底向上伸展方法，并且没有重复的键：\n\n- 从一棵空树开始。\n- 按严格递减顺序 $N,N-1,\\dots,2,1$ 插入键，其中每次插入键 $k$ 后，立即对 $k$ 应用伸展操作（这是伸展树插入的标准做法）。\n- 然后执行对键 $N$ 的搜索，在搜索结束时对 $N$ 应用伸展操作。\n\n根据第一性原理和伸展步骤的定义（zig、zig-zig、zig-zag），推导出在最后一次对 $N$ 的搜索和伸展过程中执行的单次旋转的确切次数，并将其表示为 $N$ 的函数。将你的最终答案表示为关于 $N$ 的封闭形式表达式。无需四舍五入，也不涉及单位。你的推导必须从 BST 属性和伸展步骤的定义（zig、zig-zig、zig-zag）开始，并且不得使用关于伸展树均摊界限的未经证实的捷径。在最后一次搜索之前，序列形成的树的形状的正确性必须使用这些基本操作和 BST 的顺序属性来证明。最终答案必须是关于 $N$ 的单个解析表达式。",
            "solution": "问题要求根据一个特定的插入序列，推导在一棵伸展树中搜索键 $N$ 并随后对其进行伸展操作时所执行的单次旋转的确切次数。推导必须从第一性原理出发。\n\n解决方案分为两个主要部分。首先，我们确定在指定的插入序列之后伸展树的精确结构。其次，我们基于此结构分析对 $N$ 的搜索和对节点 $N$ 的伸展操作，以计算旋转次数。\n\n**第一部分：确定伸展树的结构**\n\n初始状态是一棵空树。按顺序插入键 $N, N-1, \\dots, 2, 1$。每次插入键 $k$ 后，包含 $k$ 的节点会被伸展到根部。\n\n我们将通过归纳法证明，在插入键 $N, N-1, \\dots, k$（对于 $1 \\le k \\le N$）后，得到的树是一个以 $k$ 为根的右倾链（一条“棍子”）。树中的节点为 $\\{k, k+1, \\dots, N\\}$，对于该集合中满足 $i  N$ 的任何节点 $i$，其右孩子是 $i+1$，其左孩子为空。\n\n**基本情况：** 第一个插入的键是 $N$。\n- 树只包含一个节点， $N$。伸展此节点没有效果，因为它已经是根。\n- 该树是一个长度为 $1$、以 $N$ 为根的右倾链。命题对 $k=N$ 成立。\n\n**归纳假设：** 假设在插入键 $N, N-1, \\dots, k+1$ 后，树是一个以 $k+1$ 为根的右倾链。其结构为：\n$$(k+1) \\rightarrow_R (k+2) \\rightarrow_R \\dots \\rightarrow_R N$$\n其中 $\\rightarrow_R$ 表示一个右孩子链接。\n\n**归纳步骤：** 我们现在插入键 $k$。\n1.  根据二叉搜索树（BST）的属性，要插入 $k$，我们从根节点（即 $k+1$）开始。因为 $k  k+1$，我们必须向左走。\n2.  根据归纳假设，根节点 $k+1$ 没有左孩子。因此，新节点 $k$ 被插入为 $k+1$ 的左孩子。\n3.  紧接着插入之后、但在伸展 $k$ 之前，树的结构是：根为 $k+1$，其左孩子为 $k$，并保留其原始的右子树。\n4.  下一步是伸展新插入的节点 $k$。节点 $k$ 的父节点是 $p = k+1$。父节点 $p$ 是树的根，所以 $k$ 没有祖父节点。\n5.  根据伸展步骤的定义，当要伸展的节点（$x=k$）有父节点但没有祖父节点时，执行一次 **Zig** 步骤。这包括一次单旋转，使 $x$ 成为新的根。\n6.  在这种情况下，$k$ 是 $k+1$ 的左孩子。对 $k+1$ 和 $k$ 之间的边执行一次右旋转。\n7.  旋转后，$k$ 成为新的根。其前父节点 $k+1$ 成为 $k$ 的右孩子。$k$ 的原始右子树（为空）成为 $k+1$ 的左孩子。$k+1$ 的原始右子树保持为其右子树。\n8.  结果树的根是 $k$，其右孩子是 $k+1$，其右孩子是 $k+2$，依此类推。结构为：\n$$k \\rightarrow_R (k+1) \\rightarrow_R (k+2) \\rightarrow_R \\dots \\rightarrow_R N$$\n这是一个以 $k$ 为根的右倾链。归纳完成。\n\n根据这个归纳论证，在插入从 $N$ 到 $1$ 的所有键之后，树的最终结构（对于 $k=1$）是一个以 $1$ 为根的右倾链：\n$$1 \\rightarrow_R 2 \\rightarrow_R 3 \\rightarrow_R \\dots \\rightarrow_R (N-1) \\rightarrow_R N$$\n\n**第二部分：分析最终的搜索和伸展操作**\n\n最后一个操作是搜索键 $N$，然后将其节点伸展到根部。\n\n**搜索路径：**\n- 对 $N$ 的搜索从根节点开始，即键为 $1$ 的节点。\n- 因为 $N > 1$，我们遍历到右孩子，即节点 $2$。\n- 因为 $N > 2$，我们遍历到右孩子，即节点 $3$。\n- 这个过程沿着右倾链一直向下，直到我们到达键为 $N$ 的节点。\n- 遍历路径是 $1 \\rightarrow 2 \\rightarrow \\dots \\rightarrow N$。\n- 节点的深度是从根到该节点的路径上的边数。到 $N$ 的路径有 $N-1$ 条边。因此，节点 $N$ 的深度是 $d = N-1$。\n\n**伸展操作：**\n我们现在从深度 $d=N-1$ 的位置伸展节点 $N$。从根到 $N$ 的路径完全由右孩子链接组成。设 $x$ 是被伸展的节点，初始时 $x=N$。\n\n- 每当 $x$ 有一个祖父节点 $g$ 时，它的父节点是 $p$。在我们的树中，$x$ 是 $p$ 的右孩子，$p$ 是 $g$ 的右孩子。这种配置需要一个 **Zig-Zig** 步骤。\n- 一个 Zig-Zig 步骤包含两次单旋转。其效果是将 $x$ 在树中向上移动两层，取代其祖父节点。\n\n- 对位于直路径上深度为 $d$ 的节点进行伸展的过程如下：\n  1.  只要节点有祖父节点，就重复应用 Zig-Zig 步骤。每个 Zig-Zig 步骤花费 $2$ 次旋转，并将节点的深度减少 $2$。可能进行的 Zig-Zig 步骤数为 $\\lfloor d/2 \\rfloor$。\n  2.  这些步骤的总旋转次数为：$2 \\times \\lfloor d/2 \\rfloor$。\n  3.  这些步骤之后，节点的剩余深度为 $d_{rem} = d - 2 \\times \\lfloor d/2 \\rfloor$。这等价于 $d \\pmod 2$。\n  4.  如果 $d_{rem} = 1$（当且仅当 $d$ 是奇数时发生），节点现在是根的孩子。它有父节点但没有祖父节点。需要一个最后的 **Zig** 步骤。一个 Zig 步骤花费 $1$ 次旋转，并使该节点成为根。\n  5.  如果 $d_{rem} = 0$（当且仅当 $d$ 是偶数时发生），节点已成为根，操作完成。\n\n单次旋转的总数是所有 Zig-Zig 步骤和最后的 Zig 步骤（如果有的话）的旋转次数之和。\n总旋转次数 $= (2 \\times \\text{Zig-Zig 步骤数}) + (1 \\times \\text{Zig 步骤数})$\n总旋转次数 $= 2 \\times \\lfloor d/2 \\rfloor + (d \\pmod 2)$。\n\n对于任何非负整数 $d$，表达式 $2 \\lfloor d/2 \\rfloor + (d \\pmod 2)$ 恒等于 $d$。\n- 如果 $d$ 是偶数，$d=2k$ (对于某个整数 $k \\ge 0$）。表达式变为 $2 \\times \\lfloor 2k/2 \\rfloor + (2k \\pmod 2) = 2 \\times k + 0 = 2k = d$。\n- 如果 $d$ 是奇数，$d=2k+1$ (对于某个整数 $k \\ge 0$）。表达式变为 $2 \\times \\lfloor (2k+1)/2 \\rfloor + ((2k+1) \\pmod 2) = 2 \\times k + 1 = 2k+1 = d$。\n\n所以，从深度为 $d$ 的直线路经上伸展一个节点的总旋转次数恰好是 $d$。\n\n在我们的问题中，要伸展的节点是 $N$，其深度为 $d = N-1$。\n将此代入我们的结果，单次旋转的总次数是 $N-1$。\n\n这对所有 $N \\ge 1$ 都成立。\n- 如果 $N=1$，树只有一个节点 $1$。搜索在根部找到它（深度 $d=0$）。旋转次数是 $0$。我们的公式给出 $1-1=0$。\n- 如果 $N>1$，深度 $d=N-1 \\ge 1$，推导出的计数成立。\n\n因此，在对 $N$ 的最后一次搜索和伸展过程中执行的单次旋转的确切次数是 $N-1$。",
            "answer": "$$\\boxed{N-1}$$"
        }
    ]
}