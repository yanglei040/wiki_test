{
    "hands_on_practices": [
        {
            "introduction": "Red-black tree invariants are a set of rules that ensure the tree remains balanced, guaranteeing logarithmic time complexity for search, insertion, and deletion. This first exercise challenges you to think about these invariants in isolation, particularly the crucial black-height property. By determining if a given tree *shape* can be validly colored , you will develop a deeper intuition for the structural constraints that any red-black tree must satisfy, independent of the keys it might store.",
            "id": "3280790",
            "problem": "A binary tree is a connected, acyclic, directed structure with a designated root in which each node has at most two children, called the left child and the right child. Consider the canonical definition of a Red-Black Tree (RBT), which is a binary search tree augmented with a coloring and subject to properties that do not depend on key ordering when only structural feasibility is considered. The feasibility of red-black coloring depends solely on the following properties: each node is colored either red or black, the root is black, all absent children (conceptual sentinel leaves) are black, no red node has a red child, and all simple paths from any node to a descendant sentinel leaf contain the same number of black nodes. Let the black-height of a node be the number of black nodes encountered along any simple path from that node down to a sentinel leaf, excluding the sentinel leaf itself.\n\nGiven only the shape of a binary tree (without keys), determine for each provided test case whether there exists a coloring of the actual nodes into red or black such that the Red-Black Tree properties listed above are satisfied. The determination must treat all absent children as sentinel leaves that are black.\n\nInput representation for each test case: the tree is given by a list of ordered pairs $(\\ell_i, r_i)$ for $i \\in \\{0, 1, \\dots, n-1\\}$, where $\\ell_i$ and $r_i$ are indices of the left and right children of node $i$, respectively, and $-1$ denotes an absent child. The root of the tree is node $0$ when $n \\geq 1$, and the tree is empty when $n = 0$. The structure is guaranteed to be a valid rooted binary tree (no cycles, at most two children per node, and children indices refer within the array or are $-1$). The output for each test case must be a boolean indicating whether a valid red-black coloring exists, with the convention that an empty tree is considered colorable in a manner that satisfies the properties (vacuously, the root condition does not apply because there is no root).\n\nFundamental base and definitions to be used:\n- Binary tree structure and sentinel leaves as conceptual black nodes.\n- Red-Black Tree properties (root black, leaves black, no red parent with red child, equal black-height across all paths from any node to its descendant leaves).\n- Black-height definition: for a node $v$, the black-height $\\mathrm{bh}(v)$ is the number of black nodes on any simple path from $v$ to a sentinel leaf, excluding the sentinel leaf.\n\nYour task: For each test case, output a boolean indicating whether the given shape admits at least one red-black coloring satisfying the properties, subject to the root being black when the root exists.\n\nTest suite (each test case is a list of pairs; $-1$ denotes no child):\n- Case $1$: $[]$ (the empty tree).\n- Case $2$: $[(-1,-1)]$.\n- Case $3$: $[(1,2),(3,4),(5,6),(-1,-1),(-1,-1),(-1,-1),(-1,-1)]$.\n- Case $4$: $[(1,-1),(2,-1),(-1,-1)]$.\n- Case $5$: $[(1,2),(3,4),(-1,-1),(-1,-1),(-1,-1)]$.\n- Case $6$: $[(-1,1),(-1,-1)]$.\n\nRequired final output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, $[\\text{result}_1,\\text{result}_2,\\dots,\\text{result}_m]$, where each $\\text{result}_i$ is a boolean corresponding to the $i$-th test case in the order provided above.",
            "solution": "The problem is subjected to validation to ensure its scientific and logical integrity.\n\n### Step 1: Extract Givens\n\n- **Structure:** The input is a binary tree defined by a list of ordered pairs $(\\ell_i, r_i)$ for nodes $i \\in \\{0, 1, \\dots, n-1\\}$. $\\ell_i$ and $r_i$ are child indices. The value $-1$ signifies an absent child (a conceptual sentinel leaf). Node $0$ is the root if $n \\geq 1$. An empty tree has $n=0$. The input is guaranteed to be a valid rooted binary tree.\n- **Coloring:** Each node is either red or black.\n- **Red-Black Tree Properties (Structural):**\n    1.  The root is black.\n    2.  All sentinel leaves are black.\n    3.  A red node cannot have a red child.\n    4.  For any given node, all simple paths from it to any of its descendant sentinel leaves have the same number of black nodes.\n- **Definition (Black-Height):** The black-height of a node $v$, denoted $\\mathrm{bh}(v)$, is the count of black nodes on any simple path from $v$ to a sentinel leaf, not including the sentinel leaf itself.\n- **Task:** Determine if a valid red-black coloring exists for the given tree structure. an empty tree is considered validly colorable.\n- **Output:** A boolean value for each test case.\n\n### Step 2: Validate Using Extracted Givens\n\n- **Scientifically Grounded:** The problem is founded on the standard, formal definition of a Red-Black Tree, a cornerstone data structure in computer science. The properties listed are canonical. The problem is well-situated within the domain of algorithms and discrete mathematics. The premise is factually sound.\n- **Well-Posed:** The problem is clearly defined. The input representation is unambiguous, the constraints (RBT properties) are explicit, and the desired output is a definite boolean, indicating the existence of a valid coloring. This forms a standard decision problem for which a unique answer exists.\n- **Objective:** The problem statement is expressed in precise, objective language, using standard terminology from computer science. There are no subjective or ambiguous elements.\n\nAll validation criteria are met. The problem does not exhibit any flaws such as scientific unsoundness, ambiguity, or incompleteness.\n\n### Step 3: Verdict and Action\n\nThe problem is **valid**. A solution will be developed.\n\n### Principle-Based Solution Design\n\nThe problem requires determining the existence of a valid red-black coloring for a given tree structure. The constraints are imposed by the Red-Black Tree properties. We can devise a recursive algorithm, leveraging dynamic programming (memoization), that computes the set of possible structural outcomes for each subtree.\n\nA key insight can be derived from the black-height property: For any node $v$ with children $v_L$ and $v_R$, the number of black nodes on all paths from $v$ through $v_L$ must be equal to the number of black nodes on all paths from $v$ through $v_R$. If we let $\\delta(v) = 1$ if node $v$ is black and $\\delta(v) = 0$ if it is red, this implies $\\delta(v) + \\mathrm{bh}(v_L) = \\delta(v) + \\mathrm{bh}(v_R)$, which simplifies to $\\mathrm{bh}(v_L) = \\mathrm{bh}(v_R)$. If a child is a sentinel leaf $s$, its black-height $\\mathrm{bh}(s)$ is taken to be $0$.\n\nThis suggests a post-order traversal (bottom-up) approach. For each node $u$, we can determine the possible black-heights of the subtree rooted at $u$ based on the possible black-heights of its children's subtrees. However, the \"no red-red parent-child\" rule is a top-down constraint: the color of a node constrains the color of its children.\n\nTo handle both constraints, our recursive function, let's call it $\\Phi(u)$, for a node $u$ must return the set of possible black-heights conditioned on the color of $u$. Thus, $\\Phi(u)$ will compute a pair of sets:\n1.  $\\mathcal{B}_u$: The set of possible black-heights for the subtree at $u$, assuming $u$ is colored **black**.\n2.  $\\mathcal{R}_u$: The set of possible black-heights for the subtree at $u$, assuming $u$ is colored **red**.\n\nThe computation proceeds as follows:\n\n**Base Case:** For a sentinel leaf $s$ (represented by index $-1$), it is conceptually black and has no descendants. The path from it to a sentinel is empty, so its black-height is $0$. Therefore, $\\Phi(s) = (\\mathcal{B}_s, \\mathcal{R}_s) = (\\{0\\}, \\emptyset)$. The set for red-rooted height is empty as sentinels are always black.\n\n**Recursive Step:** For a node $u$ with children $u_L$ and $u_R$, we first recursively compute $(\\mathcal{B}_L, \\mathcal{R}_L) = \\Phi(u_L)$ and $(\\mathcal{B}_R, \\mathcal{R}_R) = \\Phi(u_R)$.\nLet $\\mathcal{A}_L = \\mathcal{B}_L \\cup \\mathcal{R}_L$ and $\\mathcal{A}_R = \\mathcal{B}_R \\cup \\mathcal{R}_R$ be the sets of all possible black-heights for the left and right subtrees, respectively, regardless of their root colors.\n\n1.  **To compute $\\mathcal{B}_u$ (if $u$ is colored black):**\n    - The node $u$ contributes $1$ to the black-height.\n    - Its children, $u_L$ and $u_R$, can be any color.\n    - The black-heights of their respective subtrees must be equal. So, we seek a common height $h$ that is achievable by both subtrees.\n    - $\\mathcal{B}_u = \\{h + 1 \\mid h \\in \\mathcal{A}_L \\cap \\mathcal{A}_R\\}$.\n\n2.  **To compute $\\mathcal{R}_u$ (if $u$ is colored red):**\n    - The node $u$ contributes $0$ to the black-height.\n    - The \"no red-red\" rule dictates that its children, $u_L$ and $u_R$, must be colored **black**.\n    - Thus, their subtrees must have matching black-heights achievable only with black-colored roots ($u_L$ and $u_R$).\n    - $\\mathcal{R}_u = \\{h \\mid h \\in \\mathcal{B}_L \\cap \\mathcal{B}_R\\}$.\n\n**Final Determination:**\n- For an empty tree ($n=0$), the condition is vacuously met, so the answer is `True`.\n- For a non-empty tree with root $r$ (node $0$), we compute $(\\mathcal{B}_r, \\mathcal{R}_r) = \\Phi(r)$.\n- The RBT root must be black. Therefore, a valid coloring exists if and only if there is at least one possible black-height when the root is colored black. This means the set $\\mathcal{B}_r$ must be non-empty.\n\nThis recursive process can be implemented efficiently using memoization to store the results of $\\Phi(u)$ for each node $u$, avoiding recomputation for shared subtrees. The algorithm explores all valid coloring configurations implicitly and determines if any satisfy all properties.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# A memoization table to store the results for each subtree, keyed by node index.\n# The value will be a tuple: (set_of_black_rooted_heights, set_of_red_rooted_heights).\nmemo = {}\n# The adjacency list representation of the tree for the current test case.\nadj = []\n\ndef compute_heights(u):\n    \"\"\"\n    Recursively computes possible black-heights for the subtree rooted at u.\n\n    For each node u, it returns a pair of frozensets:\n    1. The set of black-heights if the subtree at u is rooted with a BLACK node.\n    2. The set of black-heights if the subtree at u is rooted with a RED node.\n\n    Args:\n        u (int): The index of the node. -1 represents a sentinel leaf.\n\n    Returns:\n        tuple[frozenset[int], frozenset[int]]: A pair of frozensets for black-rooted\n        and red-rooted colorings of the subtree.\n    \"\"\"\n    if u in memo:\n        return memo[u]\n\n    # Base Case: A sentinel leaf (represented by u = -1).\n    # It is conceptually black and has a black-height of 0. It cannot be red.\n    if u == -1:\n        return (frozenset([0]), frozenset())\n\n    left_child, right_child = adj[u]\n\n    # Recursively compute possible heights for children's subtrees.\n    left_black_h, left_red_h = compute_heights(left_child)\n    right_black_h, right_red_h = compute_heights(right_child)\n\n    # Union of a child's black-rooted and red-rooted heights gives all its possibilities.\n    left_all_h = left_black_h.union(left_red_h)\n    right_all_h = right_black_h.union(right_red_h)\n    \n    # --- Case 1: Node 'u' is colored BLACK ---\n    # Its children can be any color. The black-heights of the children's subtrees must match.\n    # We find the intersection of all possible heights from both children.\n    common_h_for_black_u = left_all_h.intersection(right_all_h)\n    # The black-height of the current subtree is 1 (for node u) + the common child height.\n    my_black_h = {h + 1 for h in common_h_for_black_u}\n\n    # --- Case 2: Node 'u' is colored RED ---\n    # Its children MUST be black. Their black-heights must match.\n    # We find the intersection of heights achievable only with black-rooted children subtrees.\n    common_h_for_red_u = left_black_h.intersection(right_black_h)\n    # The black-height of the current subtree is 0 (for red node u) + the common child height.\n    my_red_h = {h for h in common_h_for_red_u}\n\n    result = (frozenset(my_black_h), frozenset(my_red_h))\n    memo[u] = result\n    return result\n\ndef is_colorable(tree_adj):\n    \"\"\"\n    Determines if a given tree structure can be colored as a Red-Black Tree.\n    \n    Args:\n        tree_adj (list[tuple[int, int]]): The tree structure.\n        \n    Returns:\n        bool: True if a valid coloring exists, False otherwise.\n    \"\"\"\n    # Set up global state for this test case.\n    global adj, memo\n    adj = tree_adj\n    memo = {}\n\n    # Per problem statement, an empty tree is considered colorable.\n    if not adj:\n        return True\n\n    # For a non-empty tree, compute possible heights starting from the root (node 0).\n    # The root of a Red-Black Tree must be black.\n    root_black_h, _ = compute_heights(0)\n    \n    # A valid coloring exists if there's at least one possible black-height\n    # when the root is colored black.\n    return len(root_black_h) > 0\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [],  # Case 1: Empty tree\n        [(-1, -1)],  # Case 2: Single node tree\n        [(1, 2), (3, 4), (5, 6), (-1, -1), (-1, -1), (-1, -1), (-1, -1)],  # Case 3: Perfect binary tree h=2\n        [(1, -1), (2, -1), (-1, -1)],  # Case 4: A stick of 3 nodes\n        [(1, 2), (3, 4), (-1, -1), (-1, -1), (-1, -1)],  # Case 5: An unbalanced tree\n        [(-1, 1), (-1, -1)],  # Case 6: Root with one child\n    ]\n\n    results = []\n    for case in test_cases:\n        result = is_colorable(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Example: [True,True,True,False,True,True]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Maintaining the red-black tree invariants during an insertion requires a sequence of recolorings and rotations. This next practice shifts focus from the abstract properties to the concrete mechanics of the rebalancing algorithm. By meticulously counting the number of pointer manipulations in a worst-case insertion scenario , you will gain a precise understanding of the operational cost of these fundamental operations and appreciate how they contribute to the tree's overall efficiency.",
            "id": "3266391",
            "problem": "A Red-Black Tree (RBT) is a Binary Search Tree (BST) augmented with the following invariants: the root is black; all leaves are the distinguished sentinel leaf $T.nil$ which is black; every red node has black children; and every simple path from a node to a descendant leaf contains the same number of black nodes. Consider the standard single-key insertion into a non-empty RBT using the conventional approach: first perform BST insertion of a newly allocated node $z$ with key $k$, initializing $\\text{z.left} \\gets T.nil$, $\\text{z.right} \\gets T.nil$, linking $\\text{z.parent}$ to its discovered parent $y$, and setting either $\\text{y.left} \\gets z$ or $\\text{y.right} \\gets z$ according to the BST property. Then perform the usual red-black fix-up, which consists of color changes and possibly rotations, until the invariants are restored. Assume the standard left rotation and right rotation operations are implemented by the following pointer assignments on node fields, where the sentinels and root pointer $T.root$ are used in the conventional way but are not counted as node pointer manipulations.\n\nLeft rotation at node $x$: let $y \\gets \\text{x.right}$. Perform the pointer assignments\n- $\\text{x.right} \\gets \\text{y.left}$\n- if $\\text{y.left} \\neq T.nil$ then $\\text{y.left.parent} \\gets x$\n- $\\text{y.parent} \\gets \\text{x.parent}$\n- if $x$ is a left child then $\\text{x.parent.left} \\gets y$ else $\\text{x.parent.right} \\gets y$ (if $\\text{x.parent} = T.nil$, the assignment $T.root \\gets y$ occurs but does not count as a node pointer manipulation)\n- $\\text{y.left} \\gets x$\n- $\\text{x.parent} \\gets y$\n\nRight rotation at node $y$: let $x \\gets \\text{y.left}$. Perform the pointer assignments\n- $\\text{y.left} \\gets \\text{x.right}$\n- if $\\text{x.right} \\neq T.nil$ then $\\text{x.right.parent} \\gets y$\n- $\\text{x.parent} \\gets \\text{y.parent}$\n- if $y$ is a right child then $\\text{y.parent.right} \\gets x$ else $\\text{y.parent.left} \\gets x$ (if $\\text{y.parent} = T.nil$, the assignment $T.root \\gets x$ occurs but does not count as a node pointer manipulation)\n- $\\text{x.right} \\gets y$\n- $\\text{y.parent} \\gets x$\n\nDefine a “node pointer manipulation” to mean any assignment to a node’s $parent$, $left$, or $right$ fields (that is, writes to these fields), including assignments where the assigned value is the sentinel $T.nil$. Do not count any assignments to the color field, any reads of pointers, or any writes to the external tree root pointer $T.root$.\n\nUsing only the above fundamental definitions and the well-tested fact that a single RBT insertion fix-up performs at most $2$ rotations, determine, in the worst-case scenario for a single insertion into a non-empty tree where all conditional branches in both rotations that assign to node fields are taken, the total number of node pointer manipulations (writes to $parent$, $left$, or $right$) that occur. Express your final answer as an exact integer with no rounding.",
            "solution": "The problem is valid as it is a well-posed, self-contained, and scientifically grounded question in the domain of data structures and algorithms. It provides clear definitions, constraints, and an objective goal, free from any of the flaws listed in the validation criteria.\n\nThe task is to determine the worst-case total number of \"node pointer manipulations\" for a single insertion into a non-empty Red-Black Tree (RBT). A node pointer manipulation is defined as an assignment to a node's $parent$, $left$, or $right$ field. We are instructed to exclude assignments to the color field, any read operations, and any writes to the external tree root pointer, $T.root$.\n\nThe insertion process is composed of two phases:\n1.  The initial standard Binary Search Tree (BST) insertion.\n2.  The subsequent RBT fix-up procedure to restore the RBT invariants.\n\nWe will calculate the number of manipulations for each phase and sum them to find the total.\n\n**Phase 1: Initial BST Insertion**\n\nThe problem describes the insertion of a new node, let's call it $z$, with parent $y$. This initial step involves the following pointer assignments:\n1.  The left child of the new node $z$ is set to the sentinel leaf: $\\text{z.left} \\gets T.nil$. This is one write to a $left$ field.\n2.  The right child of the new node $z$ is set to the sentinel leaf: $\\text{z.right} \\gets T.nil$. This is one write to a $right$ field.\n3.  The parent of the new node $z$ is set to $y$: $\\text{z.parent} \\gets y$. This is one write to a $parent$ field.\n4.  Node $z$ is made a child of $y$. This involves either $\\text{y.left} \\gets z$ or $\\text{y.right} \\gets z$, depending on the key of $z$ relative to the key of $y$. In either case, this is one write to a child field ($left$ or $right$) of node $y$.\n\nThe total number of node pointer manipulations during the initial BST insertion phase is the sum of these individual manipulations: $1 + 1 + 1 + 1 = 4$.\n\n**Phase 2: RBT Fix-up Procedure**\n\nThe problem provides the \"well-tested fact that a single RBT insertion fix-up performs at most $2$ rotations.\" To find the worst-case number of manipulations, we must assume that $2$ rotations occur. We also need to find the maximum number of manipulations that can occur in a single rotation, based on the provided definitions and the worst-case assumption that \"all conditional branches in both rotations that assign to node fields are taken\".\n\nLet's analyze the number of manipulations for a `Left rotation at node x`. The pseudocode provided translates to the following pointer assignments:\n1.  $\\text{x.right} \\gets \\text{y.left}$: This is one assignment to a $right$ field. ($1$ manipulation)\n2.  `if $\\text{y.left} \\neq T.nil$ then $\\text{y.left.parent} \\gets x$`: The problem states that for the worst-case, we assume this conditional branch is taken. This assignment is to a $parent$ field and thus counts. ($1$ manipulation)\n3.  $\\text{y.parent} \\gets \\text{x.parent}$: This is one assignment to a $parent$ field. ($1$ manipulation)\n4.  `if $x$ is a left child then $\\text{x.parent.left} \\gets y$ else $\\text{x.parent.right} \\gets y$`: This block results in a single assignment to either the $left$ or $right$ child pointer of $x$'s parent. To maximize the count, we must assume this assignment occurs. This requires that $x$ is not the root of the tree, i.e., $\\text{x.parent} \\neq T.nil$. If $x$ were the root, the assignment would be to $T.root$, which is explicitly not counted. Therefore, the worst-case for counting manipulations assumes $x$ is not the root. ($1$ manipulation)\n5.  $\\text{y.left} \\gets x$: This is one assignment to a $left$ field. ($1$ manipulation)\n6.  $\\text{x.parent} \\gets y$: This is one assignment to a $parent$ field. ($1$ manipulation)\n\nSumming these up, a single left rotation performs a maximum of $1 + 1 + 1 + 1 + 1 + 1 = 6$ node pointer manipulations.\n\nThe `Right rotation at node y` is symmetric to the left rotation, and an identical analysis shows it also performs a maximum of $6$ node pointer manipulations.\n\nGiven that the fix-up procedure performs at most $2$ rotations in the worst case, the total number of manipulations for this phase is $2 \\times 6 = 12$.\n\n**Total Manipulations**\n\nThe total number of node pointer manipulations in the worst-case scenario for a single insertion is the sum of the manipulations from the initial BST insertion phase and the fix-up phase.\n$$ \\text{Total Manipulations} = (\\text{BST Insertion Manipulations}) + (\\text{Fix-up Manipulations}) $$\n$$ \\text{Total Manipulations} = 4 + 12 = 16 $$\nTherefore, the total number of node pointer manipulations is $16$.",
            "answer": "$$\\boxed{16}$$"
        },
        {
            "introduction": "True mastery of a data structure comes not just from knowing the rules, but from being able to reason with them to predict behavior. This final exercise challenges you to do just that, by predicting the final color of a newly inserted node without simulating the full fix-up algorithm . This practice encourages you to think like a designer of the algorithm, using your knowledge of the invariants and local tree configurations to deduce the outcome, demonstrating a powerful form of analytical problem-solving.",
            "id": "3266375",
            "problem": "You are given the formal invariants that define a red-black tree (RBT) and the binary search tree property. Using only these invariants and without simulating any structural update, your task is to derive and implement a method that predicts the final color of a newly inserted node with key $k$ when the standard red-black tree insertion procedure completes. You must reason from the invariants to determine how the color of the newly added node will end up after the algorithm terminates, exclusively through logical analysis of the local configuration at the would-be insertion position. The following definitions form the fundamental base for your derivation.\n\nThe binary search tree property: For any node with key $x$, all keys in its left subtree are strictly less than $x$, and all keys in its right subtree are strictly greater than $x$.\n\nRed-black tree invariants:\n- The root is black.\n- Every leaf node (the external sentinel leaf) is black.\n- If a node is red, then both of its children are black.\n- For every node, all simple paths from that node to a descendant leaf contain the same number of black nodes (this number is called the black-height of the node, and the count excludes the node itself but includes the black sentinel leaves).\n\nYour program must:\n- Walk the existing tree using the binary search tree property to determine the would-be parent and side ($\\text{left}$ or $\\text{right}$) of the new key $k$.\n- Use only the above invariants to deduce the final color of the new node after the insertion procedure completes, without performing any rotations or recolorings.\n- Encode colors as integers: `0` denotes red and `1` denotes black.\n\nTest suite:\nProvide predictions for the following fixed scenarios, each consisting of an existing tree and an insertion key $k$.\n\n- Test case $1$: An empty tree; insert $k=42$.\n- Test case $2$: A tree whose root is key $10$ (black), with left child key $5$ (black) and right child key $15$ (black); insert $k=2$.\n- Test case $3$: A tree whose root is key $10$ (black), with left child key $5$ (red) and right child key $15$ (red); insert $k=7$.\n- Test case $4$: A tree whose root is key $10$ (black), with left child key $5$ (red) and right child key $15$ (black); insert $k=7$.\n- Test case $5$: A tree whose root is key $10$ (black), with left child key $5$ (black) and right child key $15$ (red); insert $k=20$.\n\nAssumptions:\n- All given trees satisfy the red-black tree invariants prior to insertion.\n- The key $k$ is distinct from all existing keys.\n- The external leaf is considered a black sentinel and is not an internal node; when reasoning about colors, a missing child is treated as a black leaf.\n\nRequired final output format:\nYour program should produce a single line of output containing the results, one per test case in order from $1$ to $5$, as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,r_3,r_4,r_5]$), where each $r_i$ is an integer in $\\{0,1\\}$. No other text should be printed.",
            "solution": "We begin from the binary search tree property and the red-black tree invariants. The binary search tree property identifies the unique place where the new key $k$ would attach, namely as a child of some parent $P$ on either the $\\text{left}$ or $\\text{right}$ side. The red-black tree invariants constrain how the final color of the inserted node can be after the algorithm completes, without specifying the intermediate steps.\n\nFoundational facts consistent with the invariants and standard insertion practice:\n- The new internal node is initially colored red. Coloring it black immediately would increase the black-height of paths that traverse the new node by $1$, violating the invariant that all simple paths from the root to leaves contain the same number of black nodes. Coloring it red preserves black-height locally at the moment of attachment.\n- If the parent $P$ is black, then attaching a red child does not violate the invariant that no red node has a red child. Therefore, no corrective actions are needed that would change the new node’s color; the new node remains red.\n- If the parent $P$ is red, then attaching a red child violates the invariant that a red node must have black children. This violation must be resolved by local recoloring and possibly rotations while preserving black-height.\n\nLet $G$ be the grandparent of the would-be inserted node, and let $U$ be the uncle (the sibling of $P$). By the invariant that no red node has a red parent, $G$ must be black when $P$ is red.\n\nWe consider the cases implied by the invariants:\n\nCase $1$: The tree is empty. By the invariant that the root is black, the inserted node must become the root and end black. Thus, the final color is $1$.\n\nCase $2$: The parent $P$ is black. Because the new node starts red and a black parent having a red child does not violate any invariant, no transformations affecting the new node’s color are required. The final color is $0$.\n\nCase $3$: The parent $P$ is red and the uncle $U$ is red. The violation at $P$ can be eliminated by recoloring $P$ and $U$ to black and $G$ to red. This preserves black-height because the number of black nodes on all paths through $G$ remains unchanged: we remove one black at $G$ but add one black via $P$ and $U$ across both sides, and the new node stays red. If the recoloring causes $G$ to have a red parent, the process logically continues up the tree, but the original new node’s color remains red. Thus, the final color is $0$.\n\nCase $4$: The parent $P$ is red and the uncle $U$ is black (including the sentinel). The invariant that all paths have equal black-height and that red nodes cannot have red children forces a local restructuring. There are two geometric subcases determined by the orientation of $k$ relative to $P$ and $G$:\n- Inner orientation: $P$ is a left child of $G$ and $k$ goes to $P$’s right, or $P$ is a right child of $G$ and $k$ goes to $P$’s left. In this configuration, the only local resolution consistent with invariants is that after a preparatory local rotation, the middle key among {$G,P,k$} becomes the parent and is colored black to restore the red-child constraint and maintain black-height. In the inner case, this middle node is the newly inserted node, which therefore ends black. The final color is $1$.\n- Outer orientation: $P$ is a left child of $G$ and $k$ goes to $P$’s left, or $P$ is a right child of $G$ and $k$ goes to $P$’s right. In this configuration, a single rotation around $G$ with a recoloring that makes the middle node (which is $P$) black and $G$ red restores the invariants, while the new node remains red as one of $P$’s children. The final color is $0$.\n\nThese conclusions follow uniquely from the invariants: preservation of equal black-height across all root-to-leaf paths and the prohibition of red nodes having red children. No complete simulation of rotations is necessary; one needs only to inspect the local colors of $P$ and $U$ and the relative orientation of $k$ with respect to $P$ and $G$.\n\nApplying this reasoning to the test suite:\n\n- Test case $1$ ($k=42$ on empty tree): The new node becomes the root, which must be black. Output $1$.\n- Test case $2$ (root $10$ black; children $5$ black, $15$ black; $k=2$): The would-be parent is $5$ black, so the new node remains red. Output $0$.\n- Test case $3$ (root $10$ black; left $5$ red; right $15$ red; $k=7$): Parent red, uncle red, recoloring applies, and the new node remains red. Output $0$.\n- Test case $4$ (root $10$ black; left $5$ red; right $15$ black; $k=7$): Parent red, uncle black, inner orientation (left-right). The new node ends black. Output $1$.\n- Test case $5$ (root $10$ black; left $5$ black; right $15$ red; $k=20$): Parent red, uncle black, outer orientation (right-right). The new node remains red. Output $0$.\n\nTherefore, the required outputs in order are $[1,0,0,1,0]$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nRED = 0\nBLACK = 1\n\nclass Node:\n    def __init__(self, key: int, color: int):\n        self.key = key\n        self.color = color\n        self.left = None\n        self.right = None\n        self.parent = None\n\n    def set_left(self, child):\n        self.left = child\n        if child is not None:\n            child.parent = self\n\n    def set_right(self, child):\n        self.right = child\n        if child is not None:\n            child.parent = self\n\ndef bst_find_parent(root, k):\n    \"\"\"\n    Traverse the BST to find the would-be parent of key k and the side ('L' or 'R').\n    Returns (parent_node, side) where side is None if tree is empty.\n    \"\"\"\n    if root is None:\n        return None, None\n    curr = root\n    parent = None\n    side = None\n    while curr is not None:\n        parent = curr\n        if k  curr.key:\n            side = 'L'\n            curr = curr.left\n        else:\n            side = 'R'\n            curr = curr.right\n    return parent, side\n\ndef is_left_child(node):\n    return node.parent is not None and node.parent.left is node\n\ndef is_right_child(node):\n    return node.parent is not None and node.parent.right is node\n\ndef predicted_final_color(root, k):\n    \"\"\"\n    Predict the final color (0 for red, 1 for black) of the node with key k\n    after insertion completes, using only RBT invariants and local configuration.\n    \"\"\"\n    # Empty tree: new node becomes root, which must be black.\n    if root is None:\n        return BLACK\n\n    parent, side = bst_find_parent(root, k)\n    # Parent is black: new node remains red.\n    if parent.color == BLACK:\n        return RED\n\n    # Parent is red: examine grandparent and uncle.\n    grandparent = parent.parent\n    # In a valid RBT, grandparent must exist and be black if parent is red.\n    # Determine uncle (sibling of parent).\n    if grandparent is None:\n        # Defensive fallback: if this happens, treat as becoming root (black).\n        return BLACK\n    uncle = grandparent.right if is_left_child(parent) else grandparent.left\n\n    # Treat missing uncle (None) as black sentinel.\n    uncle_color = BLACK if uncle is None else uncle.color\n\n    if uncle_color == RED:\n        # Recoloring case: new node remains red.\n        return RED\n    else:\n        # Uncle is black: orientation determines outcome.\n        # Inner if parent is left child and insertion to right, or parent is right child and insertion to left.\n        parent_is_left = is_left_child(parent)\n        inner = (parent_is_left and side == 'R') or ((not parent_is_left) and side == 'L')\n        if inner:\n            # Triangle (inner) case: inserted node becomes black.\n            return BLACK\n        else:\n            # Linear (outer) case: inserted node remains red.\n            return RED\n\ndef build_test_cases():\n    tests = []\n\n    # Test 1: Empty tree, insert k=42\n    root1 = None\n    k1 = 42\n    tests.append((root1, k1))\n\n    # Test 2: Root 10 (black), left 5 (black), right 15 (black); insert k=2\n    root2 = Node(10, BLACK)\n    n5_2 = Node(5, BLACK)\n    n15_2 = Node(15, BLACK)\n    root2.set_left(n5_2)\n    root2.set_right(n15_2)\n    k2 = 2\n    tests.append((root2, k2))\n\n    # Test 3: Root 10 (black), left 5 (red), right 15 (red); insert k=7\n    root3 = Node(10, BLACK)\n    n5_3 = Node(5, RED)\n    n15_3 = Node(15, RED)\n    root3.set_left(n5_3)\n    root3.set_right(n15_3)\n    k3 = 7\n    tests.append((root3, k3))\n\n    # Test 4: Root 10 (black), left 5 (red), right 15 (black); insert k=7\n    root4 = Node(10, BLACK)\n    n5_4 = Node(5, RED)\n    n15_4 = Node(15, BLACK)\n    root4.set_left(n5_4)\n    root4.set_right(n15_4)\n    k4 = 7\n    tests.append((root4, k4))\n\n    # Test 5: Root 10 (black), left 5 (black), right 15 (red); insert k=20\n    root5 = Node(10, BLACK)\n    n5_5 = Node(5, BLACK)\n    n15_5 = Node(15, RED)\n    root5.set_left(n5_5)\n    root5.set_right(n15_5)\n    k5 = 20\n    tests.append((root5, k5))\n\n    return tests\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = build_test_cases()\n\n    results = []\n    for root, k in test_cases:\n        result = predicted_final_color(root, k)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}