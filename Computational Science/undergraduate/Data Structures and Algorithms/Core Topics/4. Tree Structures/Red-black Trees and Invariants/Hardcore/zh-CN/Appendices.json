{
    "hands_on_practices": [
        {
            "introduction": "真正掌握红黑树，不仅仅是记住插入和删除的步骤，更在于深刻理解其背后的不变性。本练习旨在挑战你仅通过分析新节点的局部环境——即其父节点、祖父节点和叔父节点的颜色与位置——来预测其插入后的最终颜色，而无需模拟任何旋转或重新着色操作。这个练习将锻炼你直接从支配树平衡与结构的核心原则出发进行逻辑推理的能力 。",
            "id": "3266375",
            "problem": "给定定义红黑树（RBT）的形式不变式和二叉搜索树属性。你的任务是仅使用这些不变式，并且不模拟任何结构更新，推导并实现一个方法，该方法在标准红黑树插入过程完成后，预测新插入的键为 $k$ 的节点的最终颜色。你必须根据不变式进行推理，仅通过对预插入位置的局部配置进行逻辑分析，来确定新添加节点在算法终止后的最终颜色。以下定义构成了你推导的基础。\n\n二叉搜索树属性：对于任意键为 $x$ 的节点，其左子树中的所有键都严格小于 $x$，其右子树中的所有键都严格大于 $x$。\n\n红黑树不变式：\n- 根节点是黑色的。\n- 每个叶节点（外部哨兵叶节点）都是黑色的。\n- 如果一个节点是红色的，那么它的两个子节点都是黑色的。\n- 对于每个节点，从该节点到其所有后代叶节点的简单路径都包含相同数量的黑色节点（这个数量称为节点的黑高，计数不包括节点本身，但包括黑色哨兵叶节点）。\n\n你的程序必须：\n- 使用二叉搜索树属性遍历现有树，确定新键 $k$ 的预插入父节点及其所在侧（$\\text{left}$ 或 $\\text{right}$）。\n- 仅使用上述不变式推导新节点在插入过程完成后的最终颜色，而不执行任何旋转或重新着色。\n- 将颜色编码为整数：$0$ 表示红色，$1$ 表示黑色。\n\n测试套件：\n为以下固定场景提供预测，每个场景包含一棵现有的树和一个插入键 $k$。\n\n- 测试用例 1：一棵空树；插入 $k=42$。\n- 测试用例 2：一棵树，根节点为键 $10$（黑色），左子节点为键 $5$（黑色），右子节点为键 $15$（黑色）；插入 $k=2$。\n- 测试用例 3：一棵树，根节点为键 $10$（黑色），左子节点为键 $5$（红色），右子节点为键 $15$（红色）；插入 $k=7$。\n- 测试用例 4：一棵树，根节点为键 $10$（黑色），左子节点为键 $5$（红色），右子节点为键 $15$（黑色）；插入 $k=7$。\n- 测试用例 5：一棵树，根节点为键 $10$（黑色），左子节点为键 $5$（黑色），右子节点为键 $15$（红色）；插入 $k=20$。\n\n假设：\n- 所有给定的树在插入前都满足红黑树不变式。\n- 键 $k$ 与所有现有键都不同。\n- 外部叶节点被视为黑色哨兵，不是内部节点；在推理颜色时，缺失的子节点被视为黑色叶节点。\n\n要求的最终输出格式：\n你的程序应生成一行输出，其中包含从 $1$ 到 $5$ 的每个测试用例的结果，结果为逗号分隔的列表，并用方括号括起来（例如 $[r_1,r_2,r_3,r_4,r_5]$），其中每个 $r_i$ 是 $\\{0,1\\}$ 中的一个整数。不应打印其他任何文本。",
            "solution": "我们从二叉搜索树属性和红黑树不变式开始。二叉搜索树属性确定了新键 $k$ 将被附加到的唯一位置，即作为某个父节点 $P$ 的左侧（$\\text{left}$）或右侧（$\\text{right}$）子节点。红黑树不变式约束了插入节点在算法完成后可能的最终颜色，而无需指定中间步骤。\n\n与不变式和标准插入实践一致的基本事实：\n- 新的内部节点初始被着色为红色。立即将其着色为黑色会使经过该新节点的路径的黑高增加 $1$，这违反了从根到叶的所有简单路径包含相同数量黑色节点的不变式。将其着色为红色在附加的瞬间局部地保持了黑高。\n- 如果父节点 $P$ 是黑色的，那么附加一个红色子节点不会违反红色节点不能有红色子节点的不变式。因此，不需要采取任何会改变新节点颜色的纠正措施；新节点保持红色。\n- 如果父节点 $P$ 是红色的，那么附加一个红色子节点违反了红色节点必须有黑色子节点的不变式。这个冲突必须通过局部重新着色和可能的旋转来解决，同时保持黑高。\n\n设 $G$ 为预插入节点的祖父节点，设 $U$ 为叔父节点（$P$ 的兄弟节点）。根据红色节点不能有红色父节点的不变式，当 $P$ 是红色时，$G$ 必须是黑色的。\n\n我们考虑由不变式所引申出的情况：\n\n情况 1：树为空。根据根节点必须是黑色的不变式，插入的节点必须成为根节点并最终为黑色。因此，最终颜色是 $1$。\n\n情况 2：父节点 $P$ 是黑色的。因为新节点初始为红色，且一个黑色父节点拥有一个红色子节点不违反任何不变式，所以不需要进行影响新节点颜色的转换。最终颜色是 $0$。\n\n情况 3：父节点 $P$ 是红色的，且叔父节点 $U$ 是红色的。在 $P$ 处的冲突可以通过将 $P$ 和 $U$ 重新着色为黑色，并将 $G$ 重新着色为红色来消除。这保持了黑高，因为所有通过 $G$ 的路径上的黑色节点数量保持不变：我们在 $G$ 处减少一个黑色节点，但通过 $P$ 和 $U$ 在两侧各增加一个黑色节点，而新节点保持红色。如果重新着色导致 $G$ 有一个红色的父节点，这个过程会逻辑上地向树的上方继续，但原始新节点的颜色保持红色。因此，最终颜色是 $0$。\n\n情况 4：父节点 $P$ 是红色的，且叔父节点 $U$ 是黑色的（包括哨兵节点）。所有路径具有相等黑高以及红色节点不能有红色子节点的不变式强制进行局部重组。存在两种由 $k$ 相对于 $P$ 和 $G$ 的方向决定的几何子情况：\n- 内部朝向：$P$ 是 $G$ 的左子节点，且 $k$ 插入到 $P$ 的右侧；或者 $P$ 是 $G$ 的右子节点，且 $k$ 插入到 $P$ 的左侧。在这种配置下，唯一与不变式一致的局部解决方案是，在一次预备性的局部旋转之后，$\\{G,P,k\\}$ 中的中间键成为父节点并被着色为黑色，以恢复红-子节点约束并维持黑高。在内部情况中，这个中间节点是新插入的节点，因此它最终变为黑色。最终颜色是 $1$。\n- 外部朝向：$P$ 是 $G$ 的左子节点，且 $k$ 插入到 $P$ 的左侧；或者 $P$ 是 $G$ 的右子节点，且 $k$ 插入到 $P$ 的右侧。在这种配置下，围绕 $G$ 进行一次旋转，并重新着色，使中间节点（即 $P$）变为黑色， $G$ 变为红色，即可恢复不变式，而新节点作为 $P$ 的一个子节点保持红色。最终颜色是 $0$。\n\n这些结论唯一地源于不变式：所有从根到叶的路径上保持相等的黑高，以及禁止红色节点有红色子节点。不需要完全模拟旋转；只需要检查 $P$ 和 $U$ 的局部颜色以及 $k$ 相对于 $P$ 和 $G$ 的相对方向。\n\n将此推理应用于测试套件：\n\n- 测试用例 1（在空树上插入 $k=42$）：新节点成为根节点，必须是黑色的。输出 $1$。\n- 测试用例 2（根为 $10$ 黑色；子节点为 $5$ 黑色，$15$ 黑色；$k=2$）：预插入的父节点是 $5$（黑色），所以新节点保持红色。输出 $0$。\n- 测试用例 3（根为 $10$ 黑色；左子节点 $5$ 红色；右子节点 $15$ 红色；$k=7$）：父节点为红色，叔父节点为红色，应用重新着色规则，新节点保持红色。输出 $0$。\n- 测试用例 4（根为 $10$ 黑色；左子节点 $5$ 红色；右子节点 $15$ 黑色；$k=7$）：父节点为红色，叔父节点为黑色，内部朝向（左-右）。新节点最终为黑色。输出 $1$。\n- 测试用例 5（根为 $10$ 黑色；左子节点 $5$ 黑色；右子节点 $15$ 红色；$k=20$）：父节点为红色，叔父节点为黑色，外部朝向（右-右）。新节点保持红色。输出 $0$。\n\n因此，按顺序要求的输出是 $[1,0,0,1,0]$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nRED = 0\nBLACK = 1\n\nclass Node:\n    def __init__(self, key: int, color: int):\n        self.key = key\n        self.color = color\n        self.left = None\n        self.right = None\n        self.parent = None\n\n    def set_left(self, child):\n        self.left = child\n        if child is not None:\n            child.parent = self\n\n    def set_right(self, child):\n        self.right = child\n        if child is not None:\n            child.parent = self\n\ndef bst_find_parent(root, k):\n    \"\"\"\n    Traverse the BST to find the would-be parent of key k and the side ('L' or 'R').\n    Returns (parent_node, side) where side is None if tree is empty.\n    \"\"\"\n    if root is None:\n        return None, None\n    curr = root\n    parent = None\n    side = None\n    while curr is not None:\n        parent = curr\n        if k  curr.key:\n            side = 'L'\n            curr = curr.left\n        else:\n            side = 'R'\n            curr = curr.right\n    return parent, side\n\ndef is_left_child(node):\n    return node.parent is not None and node.parent.left is node\n\ndef is_right_child(node):\n    return node.parent is not None and node.parent.right is node\n\ndef predicted_final_color(root, k):\n    \"\"\"\n    Predict the final color (0 for red, 1 for black) of the node with key k\n    after insertion completes, using only RBT invariants and local configuration.\n    \"\"\"\n    # Empty tree: new node becomes root, which must be black.\n    if root is None:\n        return BLACK\n\n    parent, side = bst_find_parent(root, k)\n    # Parent is black: new node remains red.\n    if parent.color == BLACK:\n        return RED\n\n    # Parent is red: examine grandparent and uncle.\n    grandparent = parent.parent\n    # In a valid RBT, grandparent must exist and be black if parent is red.\n    # Determine uncle (sibling of parent).\n    if grandparent is None:\n        # Defensive fallback: if this happens, treat as becoming root (black).\n        return BLACK\n    uncle = grandparent.right if is_left_child(parent) else grandparent.left\n\n    # Treat missing uncle (None) as black sentinel.\n    uncle_color = BLACK if uncle is None else uncle.color\n\n    if uncle_color == RED:\n        # Recoloring case: new node remains red.\n        return RED\n    else:\n        # Uncle is black: orientation determines outcome.\n        # Inner if parent is left child and insertion to right, or parent is right child and insertion to left.\n        parent_is_left = is_left_child(parent)\n        inner = (parent_is_left and side == 'R') or ((not parent_is_left) and side == 'L')\n        if inner:\n            # Triangle (inner) case: inserted node becomes black.\n            return BLACK\n        else:\n            # Linear (outer) case: inserted node remains red.\n            return RED\n\ndef build_test_cases():\n    tests = []\n\n    # Test 1: Empty tree, insert k=42\n    root1 = None\n    k1 = 42\n    tests.append((root1, k1))\n\n    # Test 2: Root 10 (black), left 5 (black), right 15 (black); insert k=2\n    root2 = Node(10, BLACK)\n    n5_2 = Node(5, BLACK)\n    n15_2 = Node(15, BLACK)\n    root2.set_left(n5_2)\n    root2.set_right(n15_2)\n    k2 = 2\n    tests.append((root2, k2))\n\n    # Test 3: Root 10 (black), left 5 (red), right 15 (red); insert k=7\n    root3 = Node(10, BLACK)\n    n5_3 = Node(5, RED)\n    n15_3 = Node(15, RED)\n    root3.set_left(n5_3)\n    root3.set_right(n15_3)\n    k3 = 7\n    tests.append((root3, k3))\n\n    # Test 4: Root 10 (black), left 5 (red), right 15 (black); insert k=7\n    root4 = Node(10, BLACK)\n    n5_4 = Node(5, RED)\n    n15_4 = Node(15, BLACK)\n    root4.set_left(n5_4)\n    root4.set_right(n15_4)\n    k4 = 7\n    tests.append((root4, k4))\n\n    # Test 5: Root 10 (black), left 5 (black), right 15 (red); insert k=20\n    root5 = Node(10, BLACK)\n    n5_5 = Node(5, BLACK)\n    n15_5 = Node(15, RED)\n    root5.set_left(n5_5)\n    root5.set_right(n15_5)\n    k5 = 20\n    tests.append((root5, k5))\n\n    return tests\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = build_test_cases()\n\n    results = []\n    for root, k in test_cases:\n        result = predicted_final_color(root, k)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "在理解了插入操作的局部逻辑后，让我们来探讨红黑树不变性施加的全局结构性约束。本练习提出了一个更根本的问题：是否任何给定的二叉树“形状”都可以被有效地着色，使其成为一棵合法的红黑树？通过仅关注树的结构，你将构建一个强大的递归算法来探索所有可能的着色方案，从而更深刻地体会到“黑高”这一不变性是如何决定一棵有效红黑树的整体架构的 。",
            "id": "3280790",
            "problem": "二叉树是一种连通、无环的有向结构，拥有一个指定的根节点，其中每个节点最多有两个子节点，分别称为左子节点和右子节点。考虑红黑树（RBT）的规范定义，它是一种二叉搜索树，增加了颜色属性，并遵循一系列性质。当仅考虑结构可行性时，这些性质不依赖于键的排序。红黑着色的可行性仅取决于以下性质：每个节点被着色为红色或黑色；根节点是黑色的；所有缺失的子节点（概念上的哨兵叶节点）都是黑色的；红色节点不能有红色的子节点；以及从任一节点到其所有后代哨兵叶节点的简单路径上，均包含相同数目的黑色节点。定义节点的“黑高”为从该节点到任一哨兵叶节点的简单路径上所经过的黑色节点数量，不包括哨兵叶节点本身。\n\n仅给定一个二叉树的形状（不含键值），请对每个提供的测试用例判断是否存在一种将实际节点着色为红色或黑色的方案，使得上述红黑树性质得以满足。判断时必须将所有缺失的子节点视作黑色的哨兵叶节点。\n\n每个测试用例的输入表示：树由一个有序对列表 $(\\ell_i, r_i)$ 给出，其中 $i \\in \\{0, 1, \\dots, n-1\\}$，$\\ell_i$ 和 $r_i$ 分别是节点 $i$ 的左、右子节点的索引，$-1$ 表示子节点缺失。当 $n \\geq 1$ 时，树的根是节点 $0$；当 $n = 0$ 时，树为空。保证输入结构是一个有效的有根二叉树（无环，每个节点最多两个子节点，且子节点索引在数组范围内或为 $-1$）。每个测试用例的输出必须是一个布尔值，表示是否存在一个有效的红黑着色方案。按照惯例，空树被认为是可着色的，其性质得到满足（因没有根节点，根节点条件不适用，故性质自然满足）。\n\n使用的基本原则和定义：\n- 二叉树结构，以及将哨兵叶节点视为概念上的黑色节点。\n- 红黑树性质（根黑，叶黑，无红色父节点带红色子节点，从任一节点到其所有后代叶节点的路径上黑高相等）。\n- 黑高定义：对于一个节点 $v$，其黑高 $\\mathrm{bh}(v)$ 是从 $v$ 到任一哨兵叶节点的简单路径上的黑色节点数量，不包括该哨兵叶节点。\n\n你的任务是：对于每个测试用例，输出一个布尔值，指明给定的树形结构是否允许至少一种满足性质的红黑着色方案，且当根节点存在时，根节点必须为黑色。\n\n测试套件（每个测试用例是一个有序对列表；$-1$ 表示没有子节点）：\n- 案例 1：$[]$ (空树)。\n- 案例 2：$[(-1,-1)]$。\n- 案例 3：$[(1,2),(3,4),(5,6),(-1,-1),(-1,-1),(-1,-1),(-1,-1)]$。\n- 案例 4：$[(1,-1),(2,-1),(-1,-1)]$。\n- 案例 5：$[(1,2),(3,4),(-1,-1),(-1,-1),(-1,-1)]$。\n- 案例 6：$[(-1,1),(-1,-1)]$。\n\n要求的最终输出格式：你的程序应生成单行输出，包含一个由方括号括起来的逗号分隔列表，例如 $[\\text{result}_1,\\text{result}_2,\\dots,\\text{result}_m]$，其中每个 $\\text{result}_i$ 是一个布尔值，对应于上面提供的第 $i$ 个测试用例。",
            "solution": "对问题进行验证，以确保其科学和逻辑上的完整性。\n\n### 步骤 1：提取已知条件\n\n- **结构：** 输入是一个二叉树，由节点 $i \\in \\{0, 1, \\dots, n-1\\}$ 的有序对 $(\\ell_i, r_i)$ 列表定义。$\\ell_i$ 和 $r_i$ 是子节点索引。值 $-1$ 表示一个缺失的子节点（一个概念上的哨兵叶节点）。如果 $n \\geq 1$，则节点 $0$ 是根节点。如果 $n=0$，则树为空。保证输入是一个有效的有根二叉树。\n- **着色：** 每个节点要么是红色，要么是黑色。\n- **红黑树性质（结构性）：**\n    1.  根节点是黑色的。\n    2.  所有哨兵叶节点都是黑色的。\n    3.  红色节点不能有红色的子节点。\n    4.  对于任意给定节点，从它到其任何后代哨兵叶节点的所有简单路径都包含相同数量的黑色节点。\n- **定义（黑高）：** 一个节点 $v$ 的黑高，记为 $\\mathrm{bh}(v)$，是从 $v$ 到一个哨兵叶节点的任何简单路径上的黑色节点数量，不包括哨兵叶节点本身。\n- **任务：** 判断对于给定的树结构是否存在一个有效的红黑着色方案。空树被认为是有效可着色的。\n- **输出：** 每个测试用例对应一个布尔值。\n\n### 步骤 2：使用提取的已知条件进行验证\n\n- **科学依据：** 该问题基于红黑树的标准形式化定义，红黑树是计算机科学中的一个基石数据结构。所列出的性质是规范的。该问题很好地定位在算法和离散数学领域内。其前提在事实上是健全的。\n- **适定性：** 问题定义清晰。输入表示明确，约束（RBT 性质）是显式的，期望的输出是一个确定的布尔值，指示是否存在有效的着色方案。这构成了一个存在唯一答案的标准决策问题。\n- **客观性：** 问题陈述使用计算机科学的标准术语，以精确、客观的语言表达。没有主观或模棱两可的元素。\n\n所有验证标准均已满足。该问题没有表现出任何诸如科学性不健全、模糊不清或不完整等缺陷。\n\n### 步骤 3：结论与行动\n\n该问题是**有效的**。将着手开发一个解决方案。\n\n### 基于原则的解决方案设计\n\n该问题要求确定给定树结构是否存在有效的红黑着色方案。约束由红黑树的性质施加。我们可以设计一个递归算法，利用动态规划（记忆化），来计算每个子树所有可能结构结果的集合。\n\n一个关键的见解可以从黑高性质中得出：对于任何有子节点 $v_L$ 和 $v_R$ 的节点 $v$，从 $v$ 经由 $v_L$ 的所有路径上的黑色节点数必须等于从 $v$ 经由 $v_R$ 的所有路径上的黑色节点数。如果我们设 $\\delta(v) = 1$ （如果节点 $v$ 是黑色）和 $\\delta(v) = 0$ （如果它是红色），这意味着 $\\delta(v) + \\mathrm{bh}(v_L) = \\delta(v) + \\mathrm{bh}(v_R)$，可以简化为 $\\mathrm{bh}(v_L) = \\mathrm{bh}(v_R)$。如果一个子节点是哨兵叶节点 $s$，其黑高 $\\mathrm{bh}(s)$ 被视为 $0$。\n\n这提示我们可以采用后序遍历（自底向上）的方法。对于每个节点 $u$，我们可以根据其子节点子树的可能黑高来确定以 $u$ 为根的子树的可能黑高。然而，“无红-红父子”规则是一个自顶向下的约束：一个节点的颜色约束了其子节点的颜色。\n\n为了同时处理这两个约束，我们的递归函数（我们称之为 $\\Phi(u)$）对于一个节点 $u$ 必须返回一组以 $u$ 的颜色为条件的可能黑高。因此，$\\Phi(u)$ 将计算一对集合：\n1.  $\\mathcal{B}_u$：假设 $u$ 被着色为**黑色**时，以 $u$ 为根的子树的可能黑高集合。\n2.  $\\mathcal{R}_u$：假设 $u$ 被着色为**红色**时，以 $u$ 为根的子树的可能黑高集合。\n\n计算过程如下：\n\n**基本情况：** 对于一个哨兵叶节点 $s$（由索引 $-1$ 表示），它在概念上是黑色的，并且没有后代。从它到一个哨兵节点的路径是空的，所以它的黑高是 $0$。因此，$\\Phi(s) = (\\mathcal{B}_s, \\mathcal{R}_s) = (\\{0\\}, \\emptyset)$。因为哨兵节点总是黑色的，所以以红色为根的黑高集合为空。\n\n**递归步骤：** 对于一个有子节点 $u_L$ 和 $u_R$ 的节点 $u$，我们首先递归地计算 $(\\mathcal{B}_L, \\mathcal{R}_L) = \\Phi(u_L)$ 和 $(\\mathcal{B}_R, \\mathcal{R}_R) = \\Phi(u_R)$。令 $\\mathcal{A}_L = \\mathcal{B}_L \\cup \\mathcal{R}_L$ 和 $\\mathcal{A}_R = \\mathcal{B}_R \\cup \\mathcal{R}_R$ 分别为左、右子树所有可能的黑高集合，不考虑其根节点的颜色。\n\n1.  **计算 $\\mathcal{B}_u$ （如果 $u$ 是黑色的）：**\n    - 节点 $u$ 对黑高贡献 $1$。\n    - 它的子节点 $u_L$ 和 $u_R$ 可以是任何颜色。\n    - 它们各自子树的黑高必须相等。所以，我们寻找一个两个子树都能达到的共同高度 $h$。\n    - $\\mathcal{B}_u = \\{h + 1 \\mid h \\in \\mathcal{A}_L \\cap \\mathcal{A}_R\\}$。\n\n2.  **计算 $\\mathcal{R}_u$ （如果 $u$ 是红色的）：**\n    - 节点 $u$ 对黑高贡献 $0$。\n    - “无红-红”规则规定它的子节点 $u_L$ 和 $u_R$ 必须是**黑色**的。\n    - 因此，它们的子树必须具有匹配的黑高，而这些黑高只能通过以黑色为根的子树（$u_L$ 和 $u_R$）来实现。\n    - $\\mathcal{R}_u = \\{h \\mid h \\in \\mathcal{B}_L \\cap \\mathcal{B}_R\\}$。\n\n**最终判定：**\n- 对于空树 ($n=0$)，条件不言自明地满足，所以答案是 `True`。\n- 对于一个根为 $r$（节点 0）的非空树，我们计算 $(\\mathcal{B}_r, \\mathcal{R}_r) = \\Phi(r)$。\n- 红黑树的根必须是黑色的。因此，当且仅当根节点被着色为黑色时，存在至少一个可能的黑高，一个有效的着色方案才存在。这意味着集合 $\\mathcal{B}_r$ 必须非空。\n\n这个递归过程可以使用记忆化来高效实现，通过为每个节点 $u$ 存储 $\\Phi(u)$ 的结果，避免对共享子树的重复计算。该算法隐式地探索所有有效的着色配置，并确定是否有任何一种配置满足所有性质。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# A memoization table to store the results for each subtree, keyed by node index.\n# The value will be a tuple: (set_of_black_rooted_heights, set_of_red_rooted_heights).\nmemo = {}\n# The adjacency list representation of the tree for the current test case.\nadj = []\n\ndef compute_heights(u):\n    \"\"\"\n    Recursively computes possible black-heights for the subtree rooted at u.\n\n    For each node u, it returns a pair of frozensets:\n    1. The set of black-heights if the subtree at u is rooted with a BLACK node.\n    2. The set of black-heights if the subtree at u is rooted with a RED node.\n\n    Args:\n        u (int): The index of the node. -1 represents a sentinel leaf.\n\n    Returns:\n        tuple[frozenset[int], frozenset[int]]: A pair of frozensets for black-rooted\n        and red-rooted colorings of the subtree.\n    \"\"\"\n    if u in memo:\n        return memo[u]\n\n    # Base Case: A sentinel leaf (represented by u = -1).\n    # It is conceptually black and has a black-height of 0. It cannot be red.\n    if u == -1:\n        return (frozenset([0]), frozenset())\n\n    left_child, right_child = adj[u]\n\n    # Recursively compute possible heights for children's subtrees.\n    left_black_h, left_red_h = compute_heights(left_child)\n    right_black_h, right_red_h = compute_heights(right_child)\n\n    # Union of a child's black-rooted and red-rooted heights gives all its possibilities.\n    left_all_h = left_black_h.union(left_red_h)\n    right_all_h = right_black_h.union(right_red_h)\n    \n    # --- Case 1: Node 'u' is colored BLACK ---\n    # Its children can be any color. The black-heights of the children's subtrees must match.\n    # We find the intersection of all possible heights from both children.\n    common_h_for_black_u = left_all_h.intersection(right_all_h)\n    # The black-height of the current subtree is 1 (for node u) + the common child height.\n    my_black_h = {h + 1 for h in common_h_for_black_u}\n\n    # --- Case 2: Node 'u' is colored RED ---\n    # Its children MUST be black. Their black-heights must match.\n    # We find the intersection of heights achievable only with black-rooted children subtrees.\n    common_h_for_red_u = left_black_h.intersection(right_black_h)\n    # The black-height of the current subtree is 0 (for red node u) + the common child height.\n    my_red_h = {h for h in common_h_for_red_u}\n\n    result = (frozenset(my_black_h), frozenset(my_red_h))\n    memo[u] = result\n    return result\n\ndef is_colorable(tree_adj):\n    \"\"\"\n    Determines if a given tree structure can be colored as a Red-Black Tree.\n    \n    Args:\n        tree_adj (list[tuple[int, int]]): The tree structure.\n        \n    Returns:\n        bool: True if a valid coloring exists, False otherwise.\n    \"\"\"\n    # Set up global state for this test case.\n    global adj, memo\n    adj = tree_adj\n    memo = {}\n\n    # Per problem statement, an empty tree is considered colorable.\n    if not adj:\n        return True\n\n    # For a non-empty tree, compute possible heights starting from the root (node 0).\n    # The root of a Red-Black Tree must be black.\n    root_black_h, _ = compute_heights(0)\n    \n    # A valid coloring exists if there's at least one possible black-height\n    # when the root is colored black.\n    return len(root_black_h) > 0\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [],  # Case 1: Empty tree\n        [(-1, -1)],  # Case 2: Single node tree\n        [(1, 2), (3, 4), (5, 6), (-1, -1), (-1, -1), (-1, -1), (-1, -1)],  # Case 3: Perfect binary tree h=2\n        [(1, -1), (2, -1), (-1, -1)],  # Case 4: A stick of 3 nodes\n        [(1, 2), (3, 4), (-1, -1), (-1, -1), (-1, -1)],  # Case 5: An unbalanced tree\n        [(-1, 1), (-1, -1)],  # Case 6: Root with one child\n    ]\n\n    results = []\n    for case in test_cases:\n        result = is_colorable(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Example: [True,True,True,False,True,True]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "理论知识在应用于调试等实际问题时才能发挥其最大威力。本练习将让你扮演一名软件测试工程师，分析一个存在缺陷的红黑树实现。通过设计一个能揭示旋转逻辑中特定错误的插入序列，你将学会批判性地思考算法的边界情况以及修复算法中每一步的精确目的。这个练习不仅能磨练你的分析能力，也揭示了为什么透彻理解不变性对于编写正确的代码至关重要 。",
            "id": "3266349",
            "problem": "您正在测试一个红黑树 (RBT) 的实现，它是一种满足以下不变性的二叉搜索树：根节点是黑色的，每个红色节点都有黑色的子节点，并且从根节点到任意空叶子节点的每条路径都包含相同数量的黑色节点（黑高）。\n\n在标准的插入修复操作中，当一个新插入的节点与其黑色（或空）叔叔节点一起导致红-红冲突时，旋转的选择取决于其相对于祖父节点的形状：一个同侧配置 (zig-zig) 通过在祖父节点处进行一次单旋转来解决，而一个异侧配置 (zig-zag) 则通过在父节点处进行一次旋转、接着在祖父节点处进行一次旋转组成的双旋转来解决。\n\n假设该实现在 zig-zag 情况下存在特定缺陷：每当新插入的节点及其父节点位于祖父节点的两侧（zig-zag）且叔叔节点为黑色时，代码会执行$2$次同方向的单旋转 (zig-zig)，而不是所要求的交叉方向的双旋转。换句话说，它不是在父节点处向着插入节点的方向进行旋转，然后在祖父节点处向相反方向进行旋转，而是应用了两次同方向的旋转，就好像当前情况是 zig-zig 一样。\n\n从一个初始为空的树开始，插入来自一个全序域的不同的键，下列哪个插入序列必然会通过强制一个带有黑色叔叔节点的 zig-zag 再平衡步骤来暴露这个缺陷，从而使得不正确的 zig-zig 操作无法恢复红黑树的不变性或二叉搜索树的性质？\n\n选择所有适用的选项。\n\nA. 按顺序插入：$3,1,2$。\n\nB. 按顺序插入：$3,5,4$。\n\nC. 按顺序插入：$1,2,3$。\n\nD. 按顺序插入：$3,2,1$。",
            "solution": "用户希望我验证问题陈述的有效性，如果有效，则解决该问题。\n\n### 问题验证\n\n**步骤1：提取已知条件**\n- 数据结构是红黑树 (RBT)，具有以下不变性：\n    1. 根节点是黑色的。\n    2. 每个红色节点都有黑色的子节点。\n    3. 从根节点到任意空叶子节点的每条路径都包含相同数量的黑色节点（黑高）。\n- 背景是针对新插入节点 $X$、其父节点 $P$ 和祖父节点 $G$ 产生的红-红冲突的插入修复过程。\n- $X$ 的叔叔节点是黑色或空。\n- 标准的 zig-zig（同侧）配置通过在祖父节点处进行一次单旋转来解决。\n- 标准的 zig-zag（异侧）配置通过一次双旋转（先在父节点旋转，然后在祖父节点旋转）来解决。\n- 该实现在特定条件下存在缺陷：一个 zig-zag 情况且叔叔节点为黑色。\n- 错误行为的描述是：“代码会执行$2$次同方向的单旋转 (zig-zig)，而不是所要求的交叉方向的双旋转。换句话说，... 它应用了两次同方向的旋转，就好像当前情况是 zig-zig 一样。”\n- 任务是识别从空树开始的哪些插入序列必然会暴露这个缺陷。\n\n**步骤2：使用提取的已知条件进行验证**\n- **科学依据**：该问题在红黑树理论中有充分的根据，这是计算机科学和数据结构中的一个标准主题。RBT 的不变性和再平衡情况（zig-zig、zig-zag）在原则上描述正确。\n- **问题的适定性/模糊性**：关于错误行为的描述非常模糊。一个标准的 zig-zig 冲突修复涉及*一次*单旋转，而不是两次。“执行$2$次同方向的单旋转 (zig-zig)” 这个短语是自相矛盾的。此外，尝试执行两次同方向的旋转（例如，两次左旋）通常是不可能的，因为被旋转的节点可能没有所需的子节点。\n\n然而，“就好像当前情况是 zig-zig 一样”这句话提出了一个合理的解释：算法错误地识别了 zig-zag 情况，并应用了相应 zig-zig 情况的修复程序。这是一种常见的实现错误类型。\n- **标准的 L-R zig-zag 情况**：新节点 $X$ 是左子节点父节点 $P$ 的右子节点。正确的修复是在 $P$ 处进行一次左旋，然后在祖父节点 $G$ 处进行一次右旋。相应的 L-L zig-zig 情况将通过在 $G$ 处进行一次单次右旋来修复。\n- **标准的 R-L zig-zag 情况**：新节点 $X$ 是右子节点父节点 $P$ 的左子节点。正确的修复是在 $P$ 处进行一次右旋，然后在祖父节点 $G$ 处进行一次左旋。相应的 R-R zig-zig 情况将通过在 $G$ 处进行一次单次左旋来修复。\n\n对这个错误行为最宽容且技术上最合理的解释是，当遇到 zig-zag 情况时，代码错误地应用了适用于类似 zig-zig 情况的单次旋转。\n- 对于左-右 (Left-Right) zig-zag，错误的操作是在祖父节点处进行一次右旋。\n- 对于右-左 (Right-Left) zig-zag，错误的操作是在祖父节点处进行一次左旋。\n\n在这个解释下，问题变得适定且可解。\n\n**步骤3：结论和行动**\n- **结论**：该问题被认为是有效的，但这取决于对上述模糊的缺陷描述所做的合理解释。分析将基于此解释进行。\n\n### 解题过程\n\n分析将追踪每个序列在初始为空的红黑树中的插入过程。如果一个序列 (1) 创建了一个带有黑色叔叔节点的 zig-zag 再平衡场景，并且 (2) 错误的修复操作导致生成的树违反了二叉搜索树 (BST) 性质或红黑树的某个不变性，那么该序列就暴露了缺陷。在下面的图示中，(B) 表示黑色节点，(R) 表示红色节点。\n\n**解释后的错误行为：**\n- 如果出现左-右 (L-R) zig-zag，则在祖父节点上执行一次右旋。\n- 如果出现右-左 (R-L) zig-zag，则在祖父节点上执行一次左旋。\n- 在这两种情况下，都会应用标准的 zig-zig 修复的重新着色：子树的新根变为黑色，其子节点变为红色。\n\n**选项 A：按顺序插入：$3, 1, 2$**\n\n1.  **插入 $3$**：根节点是 $3(B)$。\n    $$3(B)$$\n2.  **插入 $1$**：$1  3$。$1$ 成为 $3$ 的左子节点。\n    $$\n    \\begin{array}{c}\n    3(B) \\\\\n    /    \\\\\n    1(R)\n    \\end{array}\n    $$\n3.  **插入 $2$**：$2 > 1$ 且 $2  3$。$2$ 成为 $1$ 的右子节点。\n    $$\n    \\begin{array}{c}\n    3(B) \\\\\n    /    \\\\\n    1(R) \\\\\n    \\ \\ \\ \\ \\setminus \\\\\n    \\ \\ \\ \\ \\ \\ \\ 2(R)\n    \\end{array}\n    $$\n    出现红-红冲突。新节点是 $X=2$，其父节点是 $P=1$，祖父节点是 $G=3$。\n    -   $P=1$ 是 $G=3$ 的左子节点。\n    -   $X=2$ 是 $P=1$ 的右子节点。\n    -   这是一个**左-右 (L-R) zig-zag** 配置。\n    -   $X=2$ 的叔叔节点是 $G=3$ 的右子节点，它是一个空叶子节点，被视作黑色。\n    -   满足了触发缺陷的条件。\n\n    **应用错误操作**：代码将其视为左-左 (L-L) zig-zig 情况，并对祖父节点 $G=3$ 执行一次右旋。标准的 L-L 修复的重新着色也被应用（子树的新根 $1$ 继承旧根的颜色——黑色，而旧根 $3$ 变为红色）。\n\n    初始子树：\n    $$\n    \\begin{array}{c}\n    3(B) \\\\\n    /    \\\\\n    1(R) \\\\\n    \\ \\ \\ \\ \\setminus \\\\\n    \\ \\ \\ \\ \\ \\ \\ 2(R)\n    \\end{array}\n    $$\n    在 Right-Rotate($3$) 和重新着色之后：\n    $$\n    \\begin{array}{c}\n    1(B) \\\\\n    \\setminus \\\\\n    \\ \\ \\ 3(R) \\\\\n    \\ \\ / \\\\\n    \\ 2(R)\n    \\end{array}\n    $$\n    **对结果树的分析**：\n    -   **BST 性质**：中序遍历为 $1, 2, 3$。BST 性质得以维持。\n    -   **RBT 不变性**：节点 $3(R)$ 有一个红色子节点 $2(R)$。这违反了每个红色节点必须有黑色子节点的不变性。\n    -   由于一个 RBT 不变性被违反，该缺陷被暴露。\n\n    **对 A 的结论**：**正确**。\n\n**选项 B：按顺序插入：$3, 5, 4$**\n\n1.  **插入 $3$**：根节点是 $3(B)$。\n2.  **插入 $5$**：$5 > 3$。$5$ 成为 $3$ 的右子节点。\n    $$\n    \\begin{array}{c}\n    3(B) \\\\\n    \\setminus \\\\\n    \\ \\ \\ 5(R)\n    \\end{array}\n    $$\n3.  **插入 $4$**：$4  5$ 且 $4 > 3$。$4$ 成为 $5$ 的左子节点。\n    $$\n    \\begin{array}{c}\n    3(B) \\\\\n    \\setminus \\\\\n    \\ \\ \\ 5(R) \\\\\n    \\ \\ / \\\\\n    \\ 4(R)\n    \\end{array}\n    $$\n    出现红-红冲突。新节点是 $X=4$，其父节点是 $P=5$，祖父节点是 $G=3$。\n    -   $P=5$ 是 $G=3$ 的右子节点。\n    -   $X=4$ 是 $P=5$ 的左子节点。\n    -   这是一个**右-左 (R-L) zig-zag** 配置。\n    -   $X=4$ 的叔叔节点是 $G=3$ 的左子节点，它是一个空叶子节点，被视作黑色。\n    -   满足了触发缺陷的条件。\n\n    **应用错误操作**：代码将其视为右-右 (R-R) zig-zig 情况，并对祖父节点 $G=3$ 执行一次左旋。标准的 R-R 修复的重新着色被应用。\n\n    初始子树：\n    $$\n    \\begin{array}{c}\n    3(B) \\\\\n    \\setminus \\\\\n    \\ \\ \\ 5(R) \\\\\n    \\ \\ / \\\\\n    \\ 4(R)\n    \\end{array}\n    $$\n    在 Left-Rotate($3$) 和重新着色之后：\n    $$\n    \\begin{array}{c}\n    5(B) \\\\\n    /    \\\\\n    3(R) \\\\\n    \\ \\ \\ \\ \\setminus \\\\\n    \\ \\ \\ \\ \\ \\ \\ 4(R)\n    \\end{array}\n    $$\n    **对结果树的分析**：\n    -   **BST 性质**：中序遍历为 $3, 4, 5$。BST 性质得以维持。\n    -   **RBT 不变性**：节点 $3(R)$ 有一个红色子节点 $4(R)$。这违反了每个红色节点必须有黑色子节点的不变性。\n    -   由于一个 RBT 不变性被违反，该缺陷被暴露。\n\n    **对 B 的结论**：**正确**。\n\n**选项 C：按顺序插入：$1, 2, 3$**\n\n1.  **插入 $1$**：根节点是 $1(B)$。\n2.  **插入 $2$**：$2 > 1$。$2$ 成为 $1$ 的右子节点。\n3.  **插入 $3$**：$3 > 2$。$3$ 成为 $2$ 的右子节点。\n    $$\n    \\begin{array}{c}\n    1(B) \\\\\n    \\setminus \\\\\n    \\ \\ \\ 2(R) \\\\\n    \\ \\ \\ \\ \\ \\setminus \\\\\n    \\ \\ \\ \\ \\ \\ \\ \\ \\ 3(R)\n    \\end{array}\n    $$\n    出现红-红冲突。新节点是 $X=3$，父节点是 $P=2$，祖父节点是 $G=1$。\n    -   $P=2$ 是 $G=1$ 的右子节点。\n    -   $X=3$ 是 $P=2$ 的右子节点。\n    -   这是一个**右-右 (R-R) zig-zig** 配置。\n    -   缺陷被定义为仅在 zig-zag 情况下发生。此序列不会触发错误代码。将应用标准的、正确的修复。\n\n    **对 C 的结论**：**不正确**。\n\n**选项 D：按顺序插入：$3, 2, 1$**\n\n1.  **插入 $3$**：根节点是 $3(B)$。\n2.  **插入 $2$**：$2  3$。$2$ 成为 $3$ 的左子节点。\n3.  **插入 $1$**：$1  2$。$1$ 成为 $2$ 的左子节点。\n    $$\n    \\begin{array}{c}\n    3(B) \\\\\n    /    \\\\\n    2(R) \\\\\n    /    \\\\\n    1(R)\n    \\end{array}\n    $$\n    出现红-红冲突。新节点是 $X=1$，父节点是 $P=2$，祖父节点是 $G=3$。\n    -   $P=2$ 是 $G=3$ 的左子节点。\n    -   $X=1$ 是 $P=2$ 的左子节点。\n    -   这是一个**左-左 (L-L) zig-zig** 配置。\n    -   缺陷被定义为仅在 zig-zag 情况下发生。此序列不会触发错误代码。\n\n    **对 D 的结论**：**不正确**。",
            "answer": "$$\\boxed{AB}$$"
        }
    ]
}