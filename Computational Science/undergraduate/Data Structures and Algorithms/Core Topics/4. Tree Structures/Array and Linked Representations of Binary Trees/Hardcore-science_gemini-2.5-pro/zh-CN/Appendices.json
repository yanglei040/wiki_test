{
    "hands_on_practices": [
        {
            "introduction": "本练习探讨了树的遍历序列与其结构之间的基本关系。你将直接从树的前序和中序遍历序列重建其隐式数组表示，这是一个经典问题，可以加深你对这些遍历如何唯一确定一棵二叉树的理解。此练习要求绕过中间的链式结构，迫使你将重建的递归逻辑直接映射到数组索引上。",
            "id": "3207658",
            "problem": "给你一个二叉树的两个遍历数组：一个先序遍历数组和一个中序遍历数组。每个数组都包含代表树节点标签的、不重复的正整数。任务是重建该二叉树，并直接生成其隐式数组表示，而不构建任何中间链式节点表示。\n\n基本定义：\n- 二叉树是一个有限的节点集合，其中每个节点可能有一个左子节点和一个右子节点。遍历是一种系统性地访问所有节点的方法。\n- 深度优先搜索 (DFS) 先序遍历按以下顺序访问节点：根节点、左子树、右子树。\n- 深度优先搜索 (DFS) 中序遍历按以下顺序访问节点：左子树、根节点、右子树。\n- 二叉树的隐式数组表示定义在一个从零开始索引的数组上，即如果一个节点占据索引 $i$，则其左子节点占据索引 $2i+1$，右子节点占据索引 $2i+2$。如果某个子节点不存在，相应的位置则被视为空置。在本问题中，空置位置必须用哨兵值 $-1$ 填充。\n\n要求：\n- 你必须直接从遍历数组重建隐式数组表示，根据左、右子节点分别对应 $i \\mapsto (2i+1, 2i+2)$ 的映射，将每个节点值放置在其正确的索引处。你不得构建或存储任何中间链式节点结构。\n- 所有节点值都是不重复的正整数，且这些遍历描述了一个有效的二叉树。\n\n测试套件：\n对于每个测试用例，第一个数组是先序遍历，第二个数组是中序遍历。必须重建该树并以其隐式数组表示形式输出，其中空置位置用 $-1$ 填充。\n\n1. 平衡树（正常情况）：\n   - 先序：$[4,2,1,3,6,5,7]$\n   - 中序：$[1,2,3,4,5,6,7]$\n\n2. 空树（边界情况）：\n   - 先序：$[]$\n   - 中序：$[]$\n\n3. 单节点（边界情况）：\n   - 先序：$[10]$\n   - 中序：$[10]$\n\n4. 左偏树（边缘情况）：\n   - 先序：$[5,4,3,2,1]$\n   - 中序：$[1,2,3,4,5]$\n\n5. 右偏树（边缘情况）：\n   - 先序：$[1,2,3,4,5]$\n   - 中序：$[1,2,3,4,5]$\n\n6. 混合形状（非平凡稀疏）：\n   - 先序：$[8,4,6,12,10]$\n   - 中序：$[4,6,8,10,12]$\n\n最终输出格式：\n你的程序应生成单行输出，按顺序包含所有测试用例的构造数组，形式为用方括号括起来的逗号分隔列表。具体来说，如果有 $k$ 个测试用例，且为其构造的数组为 $A_1, A_2, \\dots, A_k$，那么输出必须是单行 $[A_1,A_2,\\dots,A_k]$，其中每个 $A_j$ 本身是一个用方括号括起来的、无空格的逗号分隔整数列表，且空置位置用 $-1$ 填充。",
            "solution": "从先序和中序遍历重建二叉树的问题是有效的。这是一个在计算机科学中公认的、非平凡的问题，其基础在于树遍历算法的基本属性。\n\n### 步骤 1：提取已知信息\n- **输入**：两个包含不重复正整数的数组：一个二叉树的先序遍历数组和一个中序遍历数组。\n- **任务**：重建该树并将其表示为隐式数组。\n- **定义（先序遍历）**：根节点、左子树、右子树。\n- **定义（中序遍历）**：左子树、根节点、右子树。\n- **定义（隐式数组表示）**：位于从零开始的索引 $i$ 处的节点，其左子节点位于索引 $2i+1$ 处，右子节点位于索引 $2i+2$ 处。\n- **约束**：必须直接生成隐式数组表示，而不构建任何中间链式节点数据结构。\n- **哨兵值**：输出数组中的空置位置必须用 $-1$ 填充。\n- **测试用例**：\n    1. 先序：$[4,2,1,3,6,5,7]$，中序：$[1,2,3,4,5,6,7]$\n    2. 先序：$[]$，中序：$[]$\n    3. 先序：$[10]$，中序：$[10]$\n    4. 先序：$[5,4,3,2,1]$，中序：$[1,2,3,4,5]$\n    5. 先序：$[1,2,3,4,5]$，中序：$[1,2,3,4,5]$\n    6. 先序：$[8,4,6,12,10]$，中序：$[4,6,8,10,12]$\n\n### 步骤 2：使用提取的已知信息进行验证\n问题陈述是内部一致的、有科学依据的，并且是良构的。\n- **科学依据**：（具有唯一节点值的）二叉树可由其先序和中序遍历唯一确定这一前提，是数据结构中的一个基本定理。\n- **良构性**：输入有清晰的定义，期望的输出格式也已精确指定。对节点值唯一性的保证确保了可以解析出唯一的树结构。\n- **客观性**：问题使用了正式、无歧义的语言进行描述。\n\n该问题不符合任何无效性标准。这是一个标准的算法挑战，既可形式化也具可解性。\n\n### 步骤 3：结论与行动\n该问题是 **有效的**。将提供一个合理的解决方案。\n\n### 基于原则的解决方案设计\n从先序和中序遍历重建二叉树的核心原则在于每次遍历所提供的特定排序信息。\n1.  任何先序遍历序列的第一个元素始终是相应树或子树的根。\n2.  一旦知道了根节点的值，其在中序遍历序列中的位置会将所有其他节点划分为两个不相交的集合：出现在根节点左侧的节点构成左子树，出现在右侧的节点构成右子树。\n\n挑战在于应用此原则直接构建一个隐式数组表示 $A$，其中索引为 $i$ 的节点的子节点位于索引 $2i+1$（左）和 $2i+2$（右），而不创建中间的链式 `Node` 对象表示。\n\n递归方法天然适合这种分解过程。我们可以定义一个递归函数，该函数操作先序遍历和中序遍历的子数组（或更高效地，操作索引范围），其任务是将给定子树的根放置在最终数组中的一个特定目标索引处。\n\n为了管理隐式数组表示潜在的稀疏性（例如，在偏斜树中），并在不进行预先遍历的情况下确定最终数组的大小，我们可以使用字典或哈希表来存储确定下来的 `(索引, 值)` 对。此映射充当最终数组的稀疏表示。递归完成后，该映射包含所有节点的放置位置。然后，可以通过初始化一个大小为 `max_index + 1` 并填充哨兵值 $-1$ 的数组，再用该映射中的数据填充它，来构建最终的密集数组。\n\n该算法按以下步骤进行：\n1.  为了实现高效查找，预处理中序遍历数组，将其转换为一个哈希表 `inorder_map`，该表将每个节点值映射到其索引。这使得在 $O(1)$ 时间内查找根在中序序列中的位置成为可能，这对于实现一个整体高效的算法至关重要。否则，每一步都需要 $O(N)$ 的扫描，从而导致算法时间复杂度为 $O(N^2)$。\n2.  定义一个递归函数 `build(pre_start, pre_end, in_start, in_end, array_idx)`，其中：\n    - `pre_start, pre_end`：当前子问题在先序遍历数组中的起始和结束索引。\n    - `in_start, in_end`：当前子问题在中序遍历数组中的起始和结束索引。\n    - `array_idx`：当前子树的根必须被放置在概念性输出数组中的索引。\n3.  `build` 函数的逻辑：\n    - **基本情况**：如果 `pre_start > pre_end`，则子树为空。终止此路径的递归。\n    - **识别根节点**：当前子树的根是 `root_val = preorder[pre_start]`。\n    - **放置根节点**：将根的值存储在我们的稀疏映射中的指定索引处：`tree_map[array_idx] = root_val`。\n    - **分区**：在当前中序段中找到根的索引：`in_root_idx = inorder_map[root_val]`。左子树中的节点数是 `left_subtree_size = in_root_idx - in_start`。\n    - **在左子树上递归**：左子树对应于 `preorder` 索引 `pre_start + 1` 到 `pre_start + left_subtree_size` 和 `inorder` 索引 `in_start` 到 `in_root_idx - 1`。其根将被放置在索引 `2 * array_idx + 1` 处。使用这些新参数进行递归调用。\n    - **在右子树上递归**：右子树对应于 `preorder` 索引 `pre_start + left_subtree_size + 1` 到 `pre_end` 和 `inorder` 索引 `in_root_idx + 1` 到 `in_end`。其根将被放置在索引 `2 * array_idx + 2` 处。进行第二次递归调用。\n4.  要启动该过程，进行初始调用 `build(0, N-1, 0, N-1, 0)`，其中 $N$ 是节点的总数，整个树的根放置在索引 $0$ 处。\n5.  初始调用返回后，`tree_map` 将包含所有节点及其正确的索引。\n6.  如果树不为空，通过在 `tree_map` 中找到最大索引来确定所需的数组大小：`max_idx = max(tree_map.keys())`。\n7.  创建大小为 `max_idx + 1` 的最终数组，将其所有元素初始化为 $-1$，然后使用 `tree_map` 中的 `(索引, 值)` 对填充它。\n\n这种单遍递归方法以 $O(N)$ 的最优时间复杂度正确地构建了隐式数组表示，因为每个节点仅被处理一次，并且递归栈和 `inorder_map` 的空间复杂度为 $O(N)$。在最坏情况（如偏斜树）下，输出数组的大小可能高达 $O(2^N)$，但其大小是由特定树的结构动态确定的。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to process all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # 1. Balanced tree (happy path)\n        ([4, 2, 1, 3, 6, 5, 7], [1, 2, 3, 4, 5, 6, 7]),\n        # 2. Empty tree (boundary)\n        ([], []),\n        # 3. Single node (boundary)\n        ([10], [10]),\n        # 4. Left-skewed tree (edge case)\n        ([5, 4, 3, 2, 1], [1, 2, 3, 4, 5]),\n        # 5. Right-skewed tree (edge case)\n        ([1, 2, 3, 4, 5], [1, 2, 3, 4, 5]),\n        # 6. Mixed shape (non-trivial sparse)\n        ([8, 4, 6, 12, 10], [4, 6, 8, 10, 12]),\n    ]\n\n    results = []\n    for preorder, inorder in test_cases:\n        result = build_implicit_array(preorder, inorder)\n        results.append(result)\n\n    # Format each result list into a string like \"[v1,v2,...]\" with no spaces\n    formatted_results = [f\"[{','.join(map(str, r))}]\" for r in results]\n    \n    # Print the final output as a single-line comma-separated list of these strings\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef build_implicit_array(preorder: list[int], inorder: list[int]) -> list[int]:\n    \"\"\"\n    Reconstructs the implicit array representation of a binary tree from its\n    preorder and inorder traversals.\n\n    Args:\n        preorder: A list of integers representing the preorder traversal.\n        inorder: A list of integers representing the inorder traversal.\n\n    Returns:\n        A list of integers for the implicit array representation, with -1\n        for unused positions.\n    \"\"\"\n    if not preorder:\n        return []\n\n    # O(N) step to create a map for O(1) lookups of inorder indices.\n    inorder_map = {val: i for i, val in enumerate(inorder)}\n    tree_map = {}  # Using a dictionary as a sparse array for {index: value}\n    n = len(preorder)\n\n    def build_recursive(pre_start, pre_end, in_start, in_end, array_idx):\n        \"\"\"\n        Recursively populates the tree_map.\n        \n        Args:\n            pre_start, pre_end: Slice indices for the preorder array.\n            in_start, in_end: Slice indices for the inorder array.\n            array_idx: The index in the final implicit array for the current root.\n        \"\"\"\n        # Base case: If the current subtree is empty, do nothing.\n        if pre_start > pre_end:\n            return\n\n        # The root of the current subtree is the first element in its preorder traversal.\n        root_val = preorder[pre_start]\n        tree_map[array_idx] = root_val\n\n        # Find the root's position in the inorder traversal to partition subtrees.\n        in_root_idx = inorder_map[root_val]\n        left_subtree_size = in_root_idx - in_start\n        \n        # Recurse for the left child.\n        # Its preorder traversal is the next 'left_subtree_size' elements.\n        # Its inorder traversal is the elements to the left of the root.\n        # Its array index is 2*i+1.\n        build_recursive(\n            pre_start + 1,\n            pre_start + left_subtree_size,\n            in_start,\n            in_root_idx - 1,\n            2 * array_idx + 1\n        )\n        \n        # Recurse for the right child.\n        # Its preorder traversal follows the left subtree's elements.\n        # Its inorder traversal is the elements to the right of the root.\n        # Its array index is 2*i+2.\n        build_recursive(\n            pre_start + left_subtree_size + 1,\n            pre_end,\n            in_root_idx + 1,\n            in_end,\n            2 * array_idx + 2\n        )\n\n    # Initial call for the entire tree, root at index 0.\n    build_recursive(0, n - 1, 0, n - 1, 0)\n    \n    # Determine the size of the final array from the maximum index used.\n    if not tree_map:\n        return []\n    max_idx = max(tree_map.keys())\n    \n    # Create the dense array and populate it from the sparse map.\n    # Using np.full for initialization as per environment specification.\n    result_array = np.full(max_idx + 1, -1, dtype=int)\n    for idx, val in tree_map.items():\n        result_array[idx] = val\n        \n    return result_array.tolist()\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "一个稳健的数据结构实现不仅需要构建，还需要验证。本练习挑战你诊断一个已损坏的、基于数组的二叉树，识别出那些违反父子索引规则的节点。通过找出“孤儿”节点和不连续的组件，你将对支撑数组表示法的结构不变量有更实际的理解。",
            "id": "3207807",
            "problem": "给定一个长度为 $n$ 的数组 $A$，该数组使用从 0 开始的索引来编码一个二叉树。在此表示法中，如果索引 $i$ 处存在一个节点，则其左子节点位于索引 $2i + 1$ 处，右子节点位于索引 $2i + 2$ 处，前提是这些索引小于 $n$。数组条目满足以下约束：每个有效节点的键都是一个严格的正整数，而整数 $0$ 表示一个已损坏或缺失的节点。您的任务是设计并实现一个算法，该算法基于二叉树的数组和链式表示法的基本属性，来检测由损坏引起的结构不一致性。\n\n基本原理：\n- 二叉树是一个节点的有限集合，每个节点最多有两个子节点（左子节点和右子节点）。\n- 在使用从 0 开始的索引的数组表示法中，索引 $j > 0$ 的父节点是 $p = \\left\\lfloor \\dfrac{j - 1}{2} \\right\\rfloor$。根节点位于索引 $0$ 处。\n- 在任何一致的二叉树数组表示中，对于索引 $j$ 处存在的任何节点（即 $A[j] > 0$），其沿着链 $j, \\left\\lfloor \\dfrac{j - 1}{2} \\right\\rfloor, \\left\\lfloor \\dfrac{\\left\\lfloor \\dfrac{j - 1}{2} \\right\\rfloor - 1}{2} \\right\\rfloor, \\dots$ 直到索引 $0$ 的所有祖先也必须存在。等价地说，如果任何祖先缺失，则节点不能存在。\n- 在链式表示中，每个存在的节点都有指向其存在的左子节点和右子节点的指针，从而形成一个父子关系图。此图的连通分量是通过仅考虑存在的节点以及连接它们的父子关系来形成的。\n\n要报告的结构不一致性：\n1. 满足 $A[j] > 0$ 且从 $j$ 到根节点的路径上至少存在一个缺失祖先的索引 $j$ 的列表（按升序排序）。这些节点违反了所有祖先必须存在的要求。为清晰起见，这些索引被称为孤儿索引，但其定义要求检查整个祖先链，而不仅仅是直接父节点。\n2. 一个布尔值，指示根节点是否缺失而同时存在其他节点，即是否 $A[0] = 0$ 且存在索引 $j > 0$ 使得 $A[j] > 0$。\n3. 由存在的节点在父子关系下形成的连通分量的数量。这等于满足 $A[j] > 0$ 且 $j = 0$ 或 $A\\left[\\left\\lfloor \\dfrac{j - 1}{2} \\right\\rfloor\\right] = 0$ 的索引 $j$ 的数量（即，其直接父节点缺失的节点被视为分量的根）。\n\n您的程序必须为以下每个测试用例构建这些报告（数组已明确给出；键使用整数，其中 $0$ 表示损坏）：\n- 测试用例 1：$A_1 = [1, 2, 3, 4, 0, 0, 7]$，其中 $n_1 = 7$。\n- 测试用例 2：$A_2 = [0, 2, 0, 0, 5]$，其中 $n_2 = 5$。\n- 测试用例 3：$A_3 = [1, 0, 3, 0, 0, 6, 0, 8]$，其中 $n_3 = 8$。\n- 测试用例 4：$A_4 = []$，其中 $n_4 = 0$。\n- 测试用例 5：$A_5 = [9]$，其中 $n_5 = 1$。\n\n对于每个测试用例，输出应为一个列表，包含：\n- 孤儿索引列表（如上定义），按升序排序。\n- 指示根节点是否缺失而同时存在其他节点的布尔值。\n- 如上定义的连通分量的整数数量。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含所有测试用例的结果，格式为一个由方括号括起来的逗号分隔列表。此顶层列表的每个元素本身也是一个具有上述结构的列表。例如，包含两个测试用例的输出将如下所示：$[[\\dots,\\dots,\\dots],[\\dots,\\dots,\\dots]]$。",
            "solution": "问题陈述已经过严格验证，并被评估为有效。它在科学上基于数据结构的原理，特别是二叉树的数组表示。该问题定义良好，所有术语、约束和目标都清晰、客观地进行了定义。没有内部矛盾、信息缺失或歧义。该问题是可形式化的，并需要基于所提供的定义给出一个实质性的算法解决方案。\n\n任务是设计一个算法，用于分析基于数组的二叉树表示，以查找由值为 $0$ 表示的损坏或缺失节点引起的三种特定类型的结构不一致性。数组 $A$ 的长度为 $n$，使用从 0 开始的索引，其中对于索引为 $i$ 的节点，其左、右子节点分别位于索引 $2i + 1$ 和 $2i + 2$。\n\n分析将分为三个独立的算法，每个算法对应一份所需的报告。\n\n**1. 检测孤儿索引**\n\n第一份所需的报告是一个排序后的“孤儿”索引列表。一个索引 $j$ 被定义为孤儿，如果该位置的节点存在（$A[j] > 0$），但其到根节点（索引 $0$）的路径上至少有一个祖先是缺失的。\n\n**原理：** 在一个结构一致的、基于数组的二叉树中，一个非根索引 $j$ 处节点的存在，必然要求其父节点在索引 $p = \\left\\lfloor \\frac{j-1}{2} \\right\\rfloor$ 处也存在。通过归纳法，这个要求扩展到从 $j$ 到根节点 $0$ 的整个祖先链。如果一个节点 $A[j] > 0$ 的某个祖先 $A[k] = 0$（其中 $k$ 在从 $j$ 到 $0$ 的路径上），这就违反了该原则，表明存在结构性断裂。\n\n**算法：** 为了识别所有孤儿索引，我们可以遍历数组 $A$ 的每个索引 $j$（从 $1$ 到 $n-1$）。位于索引 $0$ 的根节点不可能是孤儿，因为它没有祖先。对于每个 $A[j] > 0$ 的索引 $j$，我们向上追溯其祖先。设一个临时变量 `current_index` 初始化为 $j$。当 `current_index` 大于 $0$ 时，我们计算父索引 $p = \\left\\lfloor \\frac{\\text{current\\_index}-1}{2} \\right\\rfloor$。然后我们检查 $A[p]$ 是否等于 $0$。如果是，则索引 $j$ 处的节点有一个缺失的祖先，因此将 $j$ 添加到我们的孤儿索引列表中，并且对这个特定 $j$ 的检查可以终止。如果 $A[p] > 0$，我们通过设置 `current_index = p` 继续向上遍历。如果循环完成而没有发现缺失的祖先，则索引 $j$ 处的节点不是孤儿。最终得到的索引列表将保持升序排序。\n\n**2. 识别存在节点但无根的树**\n\n第二份报告是一个布尔值，指示位于索引 $0$ 的根节点是否缺失，而同时其他节点却存在。\n\n**原理：** 数组表示法隐含地定义了一个源自索引 $0$ 处根节点的单一层级结构。当 $A[0] = 0$ 而存在某个 $j>0$ 使得 $A[j] > 0$ 时，这种情况代表了一个根本性的不一致：树结构缺少其指定的起点，但却包含其他非空部分。\n\n**算法：** 这是对两个条件的直接检查。首先，我们验证数组是否非空（$n>0$）且其第一个元素是否为零（$A[0] = 0$）。如果不满足此情况，则条件为假。如果为真，我们接着检查数组中是否有任何其他元素为正数。这可以通过从索引 $j=1$ 遍历到 $n-1$ 并检查 $A[j] > 0$ 来实现。一旦找到第一个这样的元素，我们就可以断定整个条件为真。如果循环结束仍未找到任何正元素，则条件为假。对于空数组（$n=0$），该条件定义为假。\n\n**3. 枚举连通分量**\n\n第三份报告是连通分量的数量。一个分量由通过直接父子关系连接的一组存在节点定义。\n\n**原理：** 问题将分量的根定义为任何存在的节点（$A[j] > 0$），该节点要么是主根（$j=0$），要么其直接父节点缺失（$A[\\left\\lfloor \\frac{j-1}{2} \\right\\rfloor] = 0$）。每个这样的节点都作为一个不相交子树或分量的根。因此，分量的总数等于这些分量根的总数。\n\n**算法：** 我们初始化一个分量计数器为 $0$。然后我们遍历从 $0$ 到 $n-1$ 的每个索引 $j$。对于每个索引，我们首先检查节点是否存在，即 $A[j] > 0$。如果存在，我们应用分量根测试。如果 $j=0$，根据定义它是一个分量的根，因此我们增加计数器。如果 $j>0$，我们计算其父索引 $p = \\left\\lfloor \\frac{j-1}{2} \\right\\rfloor$ 并检查 $A[p]$ 是否等于 $0$。如果父节点缺失，则索引 $j$ 处的节点是一个分量的根，我们增加计数器。检查完所有索引后，计数器的最终值就是连通分量的总数。\n\n这三个算法为检测指定的结构不一致性提供了一个完整且正确的方法。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Analyzes binary trees encoded in arrays for structural inconsistencies.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [1, 2, 3, 4, 0, 0, 7],       # Test case 1\n        [0, 2, 0, 0, 5],             # Test case 2\n        [1, 0, 3, 0, 0, 6, 0, 8],    # Test case 3\n        [],                          # Test case 4\n        [9],                         # Test case 5\n    ]\n\n    results = []\n    for A in test_cases:\n        n = len(A)\n\n        # 1. Detect orphan indices\n        orphan_indices = []\n        # Iterate from index 1, as the root at index 0 has no ancestors.\n        for j in range(1, n):\n            if A[j] > 0:\n                is_orphan = False\n                current_idx = j\n                # Traverse up the ancestor chain to the root\n                while current_idx > 0:\n                    # Calculate parent index using floor, as per the definition.\n                    # int() is used because np.floor returns a float.\n                    parent_idx = int(np.floor((current_idx - 1) / 2))\n                    \n                    if A[parent_idx] == 0:\n                        is_orphan = True\n                        break  # An orphan is found, no need to check further ancestors.\n                    \n                    current_idx = parent_idx\n                \n                if is_orphan:\n                    orphan_indices.append(j)\n        # The list is naturally sorted as we iterate j in ascending order.\n\n        # 2. Check for rootless tree condition\n        is_rootless = False\n        if n > 0 and A[0] == 0:\n            # Check if any other node is present\n            if any(val > 0 for val in A[1:]):\n                is_rootless = True\n\n        # 3. Count connected components\n        num_components = 0\n        for j in range(n):\n            if A[j] > 0:\n                # A present node is a component root if it is the main root (j=0)\n                # or if its immediate parent is missing.\n                if j == 0:\n                    num_components += 1\n                else:\n                    parent_idx = int(np.floor((j - 1) / 2))\n                    if A[parent_idx] == 0:\n                        num_components += 1\n\n        # Collate the results for the current test case.\n        case_result = [orphan_indices, is_rootless, num_components]\n        results.append(case_result)\n\n    # Final print statement in the exact required format.\n    # The default string representation of lists is used as it matches the\n    # structure of the example output format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "标准的隐式数组表示法虽然优雅，但对于稀疏或倾斜的树来说，其空间效率可能极低。这个问题要求你分析这种最坏情况，并为完全倾斜的树设计一种空间高效的替代方案。通过比较标准方法所需的指数级空间与线性空间解决方案，你将掌握不同数据表示策略之间的关键权衡。",
            "id": "3207810",
            "problem": "给你一套标准的基于数组的索引规则来表示二叉树，其中在一个基于 1 的数组中，索引为 $i$ 的节点的左子节点位于索引 $2i$ 处，右子节点位于索引 $2i+1$ 处。考虑一个包含 $N$ 个节点的完全偏斜二叉树，这是一种每个节点都只有一个子节点的二叉树，并且在整个树中，子节点始终在同一侧。这种树在结构上等同于一个包含 $N$ 个节点的链表，其中所有边要么都是左边，要么都是右边。\n\n从二叉树和基于数组表示的基本定义出发，注意到在标准映射下，经过 $d$ 条连续左边后到达的索引是 $2^{d}$，而经过 $d$ 条连续右边后到达的索引是 $2^{d+1}-1$。因此，对于一个包含 $N$ 个节点的完全偏斜树，最深的节点出现在深度 $N-1$ 处，其标准数组索引对于全左树是 $2^{N-1}$，对于全右树是 $2^{N}-1$。因此，为了无冲突地忠实表示该树，所需的最小标准数组大小是 $N$ 的指数级别。\n\n你的任务是设计一个自定义的数组映射函数，用大小为 $O(N)$ 的数组来表示任意一个包含 $N$ 个节点的完全偏斜树，同时保留仅使用算术运算就能在 $O(1)$ 时间内计算父节点和唯一子节点索引的能力。具体来说，定义一个从沿唯一路径（从根到叶）的逻辑节点顺序到数组索引的映射 $\\varphi$，使得：\n- $\\varphi$ 在这 $N$ 个节点的集合上是单射的，\n- 父节点索引和唯一子节点索引可以根据一个节点的数组索引和全局偏斜方向，通过常数时间的算術运算计算得出，\n- 所使用的数组大小为 $\\Theta(N)$，意即它与 $N$ 呈线性关系。\n\n实现一个程序，该程序：\n1. 为一个包含 $N$ 个节点的完全偏斜树构建此自定义映射，该映射由偏斜方向字符串 $s$ 参数化，$s$ 为 \"L\" 表示全左树，或为 \"R\" 表示全右树。\n2. 计算在标准映射规则下所需的最小标准数组大小，以及在你的映射下所需的最小自定义数组大小。\n3. 计算定义为 $R = \\frac{\\text{标准大小}}{\\text{自定义大小}}$ 的比率 $R$，结果为一个实数。\n4. 对自定义数组中的每个节点索引 $i$ 进行验证，确保计算出的父节点和子节点索引与线性链一致：对于 $i \\ge 2$，$i$ 的父节点是 $i-1$；对于 $i \\le N-1$，$i$ 在 $s$ 方向上的子节点是 $i+1$；不存在的父节点或子节点用一个哨兵整数值 $-1$ 来编码。\n\n仅使用算术计算和给定的参数；不要依赖除数组和整数之外的外部数据结构。当且仅当所有节点在自定义映射下都满足预期的父子关系时，验证必须返回一个布尔值 true。\n\n测试套件：\n- 案例 1：$N=1$，$s=\\text{\"L\"}$。\n- 案例 2：$N=3$，$s=\\text{\"L\"}$。\n- 案例 3：$N=3$，$s=\\text{\"R\"}$。\n- 案例 4：$N=10$，$s=\\text{\"L\"}$。\n- 案例 5：$N=10$，$s=\\text{\"R\"}$。\n- 案例 6：$N=20$，$s=\\text{\"R\"}$。\n\n对于每个测试用例，你的程序必须按顺序输出一个列表，其中包含以下内容：\n- 自定义数组大小（整数）。\n- 标准数组大小（整数）。\n- 比率 $R$（浮点数）。\n- 一个布尔值，指示验证是否成功。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果本身也是一个用相同逗号分隔和方括号形式表示的列表。例如，输出应看起来像 $[\\,[\\ldots],\\,[\\ldots],\\,\\ldots\\,]$。不应打印任何额外文本。",
            "solution": "所提出的问题要求为一个包含 $N$ 个节点的完全偏斜二叉树设计一个自定义的基于数组的表示方法，使得数组大小与 $N$ 呈线性关系，并且父节点和子节点之间的导航可以在常数时间内完成。这与标准数组表示法形成对比，后者会导致数组大小为 $N$ 的指数级别。\n\n### **1. 问题陈述与给定条件分析**\n\n问题提供了将二叉树映射到基于 1 的数组中的标准方法：索引为 $i$ 的节点，其左子节点位于索引 $2i$，右子节点位于索引 $2i+1$。问题正确地推断出，对于一个包含 $N$ 个节点的完全偏斜树（一个只有左子节点或只有右子节点的线性链），其深度为 $d=N-1$ 的最深节点位于一个指数增长的索引处。\n- 对于全左偏斜树，从根节点（索引 1）开始的路径涉及 $N-1$ 次连续的左子节点操作。第 $k$ 个节点（深度为 $k-1$）的索引是 $2^{k-1}$。最后一个节点的索引是 $2^{N-1}$。\n- 对于全右偏斜树，路径涉及 $N-1$ 次右子节点操作。第 $k$ 个节点的索引是 $2^k-1$。最后一个节点的索引是 $2^N-1$。\n\n在这两种情况下，容纳最后一个节点所需的数组大小为 $O(2^N)$，这对于存储一个拓扑上等同于包含 $N$ 个元素的列表的结构来说，效率极低。\n\n### **2. 自定义线性空间映射 $\\varphi$ 的设计**\n\n目标是定义一个从偏斜链中节点的逻辑位置到数组索引的单射映射 $\\varphi$，并使用一个大小为 $\\Theta(N)$ 的数组。\n\n设从根到叶的唯一路径上节点的逻辑位置由整数 $k \\in \\{1, 2, \\dots, N\\}$ 表示，其中 $k=1$是根节点，$k=2$是其子节点，以此类推，直到 $k=N$ 的叶节点。\n\n最直接且高效的映射是将逻辑位置为 $k$ 的节点存储在数组索引 $k$ 处。我们定义映射 $\\varphi$ 为：\n$$\n\\varphi(k) = k\n$$\n为了概念上的清晰，我们将使用一个基于 1 的数组，索引范围从 1 到 $N$。\n- **单射性**：此映射是集合 $\\{1, 2, \\dots, N\\}$ 上的一个简单恒等函数，因此显然是单射的。\n- **数组大小**：该映射使用从 1 到 $N$ 的索引，因此所需的最小数组大小为 $N$。这满足了 $\\Theta(N)$ 的要求。\n\n### **3. 常数时间父节点和子节点访问器函数**\n\n问题要求使用常数时间的算术函数来计算父节点和子节点的索引。设 $i$ 是给定节点的数组索引。由于我们的映射是 $\\varphi(k)=k$，数组索引 $i$ 与逻辑位置 $k$ 相同。\n\n**父节点访问器函数 `getParent(i, N)`：**\n逻辑位置为 $i$（$i>1$）的节点的父节点是逻辑位置为 $i-1$ 的节点。因此，父节点的数组索引是 $\\varphi(i-1) = i-1$。根节点位于索引 $i=1$ 处，没有父节点。问题指定使用哨兵值 $-1$ 表示不存在的节点。\n父节点索引因此由以下公式给出：\n$$\n\\text{getParent}(i, N) = \\begin{cases} i - 1  \\text{if } i > 1 \\\\ -1  \\text{if } i = 1 \\end{cases}\n$$\n此函数使用一次比较和一次减法，这些都是 $O(1)$ 的算術运算。\n\n**子节点访问器函数 `getChild(i, N)`：**\n逻辑位置为 $i$（$i",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the skewed binary tree representation problem for a suite of test cases.\n    \"\"\"\n    # Test cases as defined in the problem statement.\n    test_cases = [\n        (1, \"L\"),\n        (3, \"L\"),\n        (3, \"R\"),\n        (10, \"L\"),\n        (10, \"R\"),\n        (20, \"R\"),\n    ]\n\n    results = []\n    for N, s in test_cases:\n        # 1. Compute the size of the custom array representation.\n        # The mapping phi(k) = k uses indices 1...N, so the size is N.\n        if N > 0:\n            custom_size = N\n        else:\n            custom_size = 0\n\n        # 2. Compute the minimal standard array size required.\n        # Python's arbitrary-precision integers are used via dtype=object with numpy\n        # to prevent overflow with large N, although N=20 fits in int64.\n        if N == 0:\n            standard_size = 0\n        elif N == 1:\n            standard_size = 1\n        elif s == \"L\":\n            standard_size = int(np.power(2, N - 1, dtype=object))\n        elif s == \"R\":\n            standard_size = int(np.power(2, N, dtype=object) - 1)\n        else:\n            # This case should not be reached with the given test suite.\n            raise ValueError(\"Invalid skew direction specified.\")\n\n        # 3. Compute the ratio R.\n        # Handle division by zero for the edge case N=0, though not in test suite.\n        if custom_size == 0:\n            ratio = 0.0\n        else:\n            ratio = float(standard_size) / float(custom_size)\n\n        # 4. Verify the custom mapping's accessor logic.\n        verification_succeeded = True\n        if N > 0:\n            for i in range(1, N + 1):\n                # The implementation of our O(1) accessor functions.\n                # These define the computed parent and child indices.\n                computed_parent = (i - 1) if i > 1 else -1\n                computed_child = (i + 1) if i  N else -1\n\n                # The problem's definition of correctness for a linear chain.\n                expected_parent = (i - 1) if i >= 2 else -1\n                expected_child = (i + 1) if i = N - 1 else -1\n\n                if not (computed_parent == expected_parent and computed_child == expected_child):\n                    verification_succeeded = False\n                    break\n        \n        results.append([custom_size, standard_size, ratio, verification_succeeded])\n\n    # Final print statement in the exact required format.\n    # The format is a list of lists, represented as a string.\n    result_str = \",\".join([f\"[{c},{s},{r},{v}]\" for c, s, r, v in results])\n    print(f\"[{result_str}]\")\n\nsolve()\n```"
        }
    ]
}