{
    "hands_on_practices": [
        {
            "introduction": "The elegance of the array-based binary tree representation lies in its implicit parent-child relationships, governed by simple arithmetic. This exercise challenges you to act as a data structure detective, using the parent-of-$j$ rule, $p = \\lfloor \\frac{j-1}{2} \\rfloor$, to diagnose structural inconsistencies in a corrupted tree. Mastering this allows you to validate and debug array-based data structures by codifying their fundamental integrity constraints. ",
            "id": "3207807",
            "problem": "You are given an array $A$ of length $n$ that encodes a binary tree using $0$-based indexing. In this representation, if a node exists at index $i$, then its left child is at index $2i + 1$ and its right child is at index $2i + 2$, provided those indices are less than $n$. The array entries satisfy the following constraints: each valid node key is a strictly positive integer, and the integer $0$ denotes a corrupted or missing node. Your task is to design and implement an algorithm that detects structural inconsistencies that arise from corruption, based on fundamental properties of the array and linked representations of binary trees.\n\nFundamental base:\n- A binary tree is a finite set of nodes, each with at most two children (left and right).\n- In the array representation with $0$-based indexing, the parent of an index $j > 0$ is $p = \\left\\lfloor \\dfrac{j - 1}{2} \\right\\rfloor$. The root is at index $0$.\n- In any consistent array representation of a binary tree, for any node at index $j$ that is present (i.e., $A[j] > 0$), all ancestors along the chain $j, \\left\\lfloor \\dfrac{j - 1}{2} \\right\\rfloor, \\left\\lfloor \\dfrac{\\left\\lfloor \\dfrac{j - 1}{2} \\right\\rfloor - 1}{2} \\right\\rfloor, \\dots$ down to index $0$ must also be present. Equivalently, no node can exist if any ancestor is missing.\n- In the linked representation, each present node has pointers to its present left and right children, thereby forming a parent-child graph. The connected components of this graph are formed by considering only present nodes and the parent-child relationships that link them.\n\nStructural inconsistencies to report:\n1. The list of indices $j$ (sorted in ascending order) such that $A[j] > 0$ and there exists at least one missing ancestor on the path from $j$ to the root. These are nodes that violate the requirement that all ancestors must be present. For clarity, these indices are called the orphan indices, but the definition requires checking the entire ancestor chain, not just the immediate parent.\n2. A boolean indicating whether the root is missing while some nodes are present, that is, whether $A[0] = 0$ and there exists an index $j > 0$ with $A[j] > 0$.\n3. The number of connected components formed by present nodes under the parent-child relation. This equals the count of indices $j$ with $A[j] > 0$ such that either $j = 0$ or $A\\left[\\left\\lfloor \\dfrac{j - 1}{2} \\right\\rfloor\\right] = 0$ (i.e., nodes whose immediate parent is missing are considered roots of components).\n\nYour program must construct these reports for each of the following test cases (arrays are given explicitly; keys use integers, where $0$ indicates corruption):\n- Test case $1$: $A_1 = [1, 2, 3, 4, 0, 0, 7]$ with $n_1 = 7$.\n- Test case $2$: $A_2 = [0, 2, 0, 0, 5]$ with $n_2 = 5$.\n- Test case $3$: $A_3 = [1, 0, 3, 0, 0, 6, 0, 8]$ with $n_3 = 8$.\n- Test case $4$: $A_4 = []$ with $n_4 = 0$.\n- Test case $5$: $A_5 = [9]$ with $n_5 = 1$.\n\nFor each test case, the output should be a list containing:\n- The list of orphan indices (as defined above), sorted in ascending order.\n- The boolean indicating whether the root is missing while some nodes are present.\n- The integer number of connected components as defined above.\n\nFinal output format:\nYour program should produce a single line of output containing the results for all test cases as a comma-separated list enclosed in square brackets. Each element of this top-level list is itself a list with the structure described above. For example, an output with two test cases would look like $[[\\dots,\\dots,\\dots],[\\dots,\\dots,\\dots]]$.",
            "solution": "The problem statement has been rigorously validated and is assessed to be valid. It is scientifically grounded in the principles of data structures, specifically the array representation of binary trees. The problem is well-posed, with all terms, constraints, and objectives clearly and objectively defined. There are no internal contradictions, missing information, or ambiguities. The problem is formalizable and requires a substantive algorithmic solution based on the provided definitions.\n\nThe task is to devise an algorithm to analyze an array-based representation of a binary tree for three specific types of structural inconsistencies arising from corrupted or missing nodes, denoted by the value $0$. The array $A$ of length $n$ uses $0$-based indexing, where for a node at index $i$, its left and right children are at indices $2i + 1$ and $2i + 2$, respectively.\n\nThe analysis will be broken down into three distinct algorithms, one for each required report.\n\n**1. Detection of Orphan Indices**\n\nThe first required report is a sorted list of \"orphan\" indices. An index $j$ is defined as an orphan if the node at that position is present ($A[j] > 0$) but at least one of its ancestors on the path to the root (index $0$) is missing.\n\n**Principle:** In a structurally consistent array-based binary tree, the presence of a node at a non-root index $j$ necessitates the presence of its parent at index $p = \\left\\lfloor \\frac{j-1}{2} \\right\\rfloor$. By induction, this requirement extends to the entire chain of ancestors from $j$ to the root at index $0$. A violation of this principle, where a node $A[j] > 0$ has an ancestor $A[k] = 0$ for some $k$ on the path from $j$ to $0$, indicates a structural break.\n\n**Algorithm:** To identify all orphan indices, we can iterate through each index $j$ of the array $A$ from $1$ to $n-1$. The root at index $0$ cannot be an orphan as it has no ancestors. For each index $j$ where $A[j] > 0$, we trace its ancestry upward. Let a temporary variable `current_index` be initialized to $j$. While `current_index` is greater than $0$, we compute the parent index $p = \\left\\lfloor \\frac{\\text{current\\_index}-1}{2} \\right\\rfloor$. We then check if $A[p] = 0$. If it is, the node at $j$ has a missing ancestor, so $j$ is added to our list of orphan indices, and the check for this particular $j$ can be terminated. If $A[p] > 0$, we continue the traversal by setting `current_index = p$. If the loop completes without finding a missing ancestor, the node at $j$ is not an orphan. The resulting list of indices is maintained in ascending sorted order.\n\n**2. Identification of a Rootless Tree with Present Nodes**\n\nThe second report is a boolean value indicating whether the root at index $0$ is missing while other nodes are present.\n\n**Principle:** The array representation implicitly defines a single hierarchical structure originating from the root at index $0$. The condition where $A[0] = 0$ while there exists some $j>0$ such that $A[j] > 0$ represents a fundamental inconsistency: the tree structure lacks its designated starting point, yet contains other non-empty parts.\n\n**Algorithm:** This is a direct check of two conditions. First, we verify if the array is non-empty ($n>0$) and if its first element is zero ($A[0] = 0$). If this is not the case, the condition is false. If it is true, we then proceed to check if any other element in the array is positive. This can be done by iterating from index $j=1$ to $n-1$ and checking if $A[j] > 0$. The first time such an element is found, we can conclude the overall condition is true. If the loop finishes without finding any positive element, the condition is false. For an empty array ($n=0$), the condition is defined to be false.\n\n**3. Enumeration of Connected Components**\n\nThe third report is the number of connected components. A component is defined by the set of present nodes linked by the immediate parent-child relationship.\n\n**Principle:** The problem defines a component's root as any present node ($A[j] > 0$) that either is the main root ($j=0$) or whose immediate parent is missing ($A[\\left\\lfloor \\frac{j-1}{2} \\right\\rfloor] = 0$). Each such node acts as the root of a disjoint subtree, or component. The total number of components is therefore equivalent to the total number of these component roots.\n\n**Algorithm:** We initialize a counter for the number of components to $0$. We then iterate through every index $j$ from $0$ to $n-1$. For each index, we first check if a node is present, i.e., $A[j] > 0$. If it is, we apply the component root test. If $j=0$, it is by definition a root of a component, so we increment the counter. If $j>0$, we calculate its parent's index $p = \\left\\lfloor \\frac{j-1}{2} \\right\\rfloor$ and check if $A[p] = 0$. If the parent is missing, the node at $j$ is the root of a component, and we increment the counter. After checking all indices, the final value of the counter is the total number of connected components.\n\nThese three algorithms provide a complete and correct method for detecting the specified structural inconsistencies.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Analyzes binary trees encoded in arrays for structural inconsistencies.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [1, 2, 3, 4, 0, 0, 7],       # Test case 1\n        [0, 2, 0, 0, 5],             # Test case 2\n        [1, 0, 3, 0, 0, 6, 0, 8],    # Test case 3\n        [],                          # Test case 4\n        [9],                         # Test case 5\n    ]\n\n    results = []\n    for A in test_cases:\n        n = len(A)\n\n        # 1. Detect orphan indices\n        orphan_indices = []\n        # Iterate from index 1, as the root at index 0 has no ancestors.\n        for j in range(1, n):\n            if A[j] > 0:\n                is_orphan = False\n                current_idx = j\n                # Traverse up the ancestor chain to the root\n                while current_idx > 0:\n                    # Calculate parent index using floor, as per the definition.\n                    # int() is used because np.floor returns a float.\n                    parent_idx = int(np.floor((current_idx - 1) / 2))\n                    \n                    if A[parent_idx] == 0:\n                        is_orphan = True\n                        break  # An orphan is found, no need to check further ancestors.\n                    \n                    current_idx = parent_idx\n                \n                if is_orphan:\n                    orphan_indices.append(j)\n        # The list is naturally sorted as we iterate j in ascending order.\n\n        # 2. Check for rootless tree condition\n        is_rootless = False\n        if n > 0 and A[0] == 0:\n            # Check if any other node is present\n            if any(val > 0 for val in A[1:]):\n                is_rootless = True\n\n        # 3. Count connected components\n        num_components = 0\n        for j in range(n):\n            if A[j] > 0:\n                # A present node is a component root if it is the main root (j=0)\n                # or if its immediate parent is missing.\n                if j == 0:\n                    num_components += 1\n                else:\n                    parent_idx = int(np.floor((j - 1) / 2))\n                    if A[parent_idx] == 0:\n                        num_components += 1\n\n        # Collate the results for the current test case.\n        case_result = [orphan_indices, is_rootless, num_components]\n        results.append(case_result)\n\n    # Final print statement in the exact required format.\n    # The default string representation of lists has spaces, so remove them\n    # to strictly match the output format requested.\n    print(f\"[{','.join(map(str, results))}]\".replace(' ', ''))\n\nsolve()\n```"
        },
        {
            "introduction": "Moving from analysis to creation, this practice bridges the conceptual gap between dynamic linked structures and static arrays. You will transform a tree from a pointer-based linked representation into a flat array where the node order is determined by a post-order traversal. This task involves performing a depth-first search to establish the sequence and then remapping all child pointers to the new coordinate system, a core skill in data serialization and graph processing. ",
            "id": "3207735",
            "problem": "Consider a finite, rooted binary tree represented in linked form. The linked representation consists of an integer number of nodes $n$, with nodes labeled by their original indices $0,1,\\dots,n-1$, and two arrays $L$ and $R$ of length $n$ such that $L[i]$ is the index of the left child of node $i$ or the sentinel $-1$ if the left child does not exist, and $R[i]$ is the index of the right child of node $i$ or the sentinel $-1$ if the right child does not exist. The tree has a designated root index $r$; for an empty tree, the root is $-1$ and both arrays $L$ and $R$ are empty. Each node index refers to a unique node, and the structure is acyclic and connected from the root to all nodes.\n\nYour task is to devise and implement an algorithm that constructs a flat array representation of the same tree in memory such that a post-order traversal becomes a simple linear scan of the array from index $0$ to index $n-1$. In other words, the array should contain the nodes in the exact post-order of the original tree. Additionally, the child pointers must be updated to reflect the new array indices: for the node placed at position $i$ in the new array, its left pointer should be the new array index of its left child (or $-1$ if none), and similarly for its right pointer.\n\nThe fundamental base for this problem is the definition of a binary tree, the definition of tree traversals, and the procedural steps of Depth-First Search (DFS). A binary tree is a directed acyclic graph where each node has at most two children, designated as left and right. A post-order traversal is defined recursively as visiting the left subtree in post-order, then the right subtree in post-order, and finally the node itself. Depth-First Search (DFS) explores along one branch of the tree as deep as possible before backtracking, and can be implemented iteratively using an explicit stack or recursively using function calls.\n\nYour program must, for each test case, compute:\n- The array $A$ of length $n$ such that scanning $A$ from index $0$ to $n-1$ yields the nodes in post-order with respect to the original linked representation.\n- The updated left-child array $L'$ of length $n$ in the new array coordinate system, where $L'[i]$ is the new array index of the left child of the node at position $i$ in $A$, or $-1$ if it has no left child.\n- The updated right-child array $R'$ of length $n$ in the new array coordinate system, where $R'[i]$ is the new array index of the right child of the node at position $i$ in $A$, or $-1$ if it has no right child.\n\nDesign your algorithm to run in time linear in $n$ and space linear in $n$. Do not assume any special properties beyond the given definitions. The computation must be exact and must not rely on unstated heuristics.\n\nTest Suite:\nProvide solutions for the following test cases. For each case, $n$ equals the length of $L$ and $R$, and nodes are labeled $0,1,\\dots,n-1$.\n\n- Case $1$ (empty tree): $n=0$, $L=\\left[ \\right]$, $R=\\left[ \\right]$, $r=-1$.\n- Case $2$ (single node): $n=1$, $L=\\left[ -1 \\right]$, $R=\\left[ -1 \\right]$, $r=0$.\n- Case $3$ (left-skewed tree): $n=4$, $L=\\left[ 1,2,3,-1 \\right]$, $R=\\left[ -1,-1,-1,-1 \\right]$, $r=0$.\n- Case $4$ (complete binary tree of height $2$): $n=7$, $L=\\left[ 1,3,5,-1,-1,-1,-1 \\right]$, $R=\\left[ 2,4,6,-1,-1,-1,-1 \\right]$, $r=0$.\n- Case $5$ (tree with missing children): $n=6$, $L=\\left[ 1,-1,4,-1,-1,-1 \\right]$, $R=\\left[ 2,3,-1,-1,5,-1 \\right]$, $r=0$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results for all five cases as a comma-separated list enclosed in square brackets. Each case’s result must be the triple $\\left[ A, L', R' \\right]$, where $A$, $L'$, and $R'$ are lists of integers as defined above. For example, the overall output should look like $\\left[ \\text{case}_1,\\text{case}_2,\\text{case}_3,\\text{case}_4,\\text{case}_5 \\right]$, where each $\\text{case}_i$ is the triple for the $i$-th test case.",
            "solution": "The user-provided problem is valid. It is scientifically grounded in the domain of computer science, specifically data structures and algorithms. The problem is well-posed, with a clear objective, sufficient input data, and unambiguous definitions of a binary tree and post-order traversal. It is an objective, formalizable task free of contradictions, unsound premises, or subjective claims.\n\nThe problem asks for a transformation of a given linked representation of a rooted binary tree into a flat array representation. The key constraint is that a linear scan of this new array, from index $0$ to $n-1$, must be equivalent to a post-order traversal of the original tree. This requires constructing three arrays: an array $A$ containing the original node indices in post-order, and two corresponding arrays, $L'$ and $R'$, containing the updated child pointers in the new coordinate system. The algorithm must operate in time and space linear in the number of nodes, $n$.\n\nA two-pass algorithm provides an efficient and direct solution to this problem, adhering to the specified complexity constraints.\n\n### Algorithmic Design\n\nThe core of the problem is to re-index the tree's nodes according to a specific traversal order. This can be broken down into two main phases:\n$1$. **Generating the Post-Order Sequence**: First, we must determine the post-order sequence of the original node indices. This sequence will define the contents of the target array $A$.\n$2$. **Remapping the Child Pointers**: Once the new ordering of nodes in array $A$ is established, the original left and right child pointers must be translated from the original index space to the new index space of array $A$.\n\n### Phase 1: Post-Order Traversal\n\nA post-order traversal of a binary tree is recursively defined as:\n$1$. Traverse the left subtree.\n$2$. Traverse the right subtree.\n$3$. Visit the root node.\n\nThis definition lends itself naturally to a recursive Depth-First Search (DFS) implementation. We can define a function, let's call it $\\text{DFS-Post-Order}(u)$, which takes an original node index $u$ as input.\n\nThe procedure for $\\text{DFS-Post-Order}(u)$ is as follows:\n- If the node index $u$ is the sentinel value $-1$ (indicating a non-existent child), the function returns immediately.\n- The function recursively calls itself on the left child of $u$, which is given by $L[u]$: $\\text{DFS-Post-Order}(L[u])$.\n- The function then recursively calls itself on the right child of $u$, which is given by $R[u]$: $\\text{DFS-Post-Order}(R[u])$.\n- Finally, after the recursive calls for both subtrees have completed, the function processes the node $u$ itself by appending its index to a global list. This list will become our target array $A$.\n\nBy initiating this process with a call to $\\text{DFS-Post-Order}(r)$, where $r$ is the root of the tree, we will populate the list $A$ with the original node indices in the exact post-order sequence. For an empty tree where $r = -1$, this process is simply skipped, resulting in an empty array $A$, which is the correct outcome. The time complexity of this phase is $O(n)$, as the DFS visits each node and edge precisely once. The space complexity is determined by the depth of the recursion stack, which is $O(h)$ where $h$ is the height of the tree. In the worst case of a degenerate (skewed) tree, $h$ can be $O(n)$, leading to a space complexity of $O(n)$.\n\n### Phase 2: Pointer Remapping\n\nAfter Phase $1$, we have the array $A$ of length $n$, where $A[i]$ is the original index of the node that now occupies the position $i$ in the new, post-ordered representation. To compute the new pointer arrays $L'$ and $R'$, we need to determine, for each node, the new indices of its children.\n\nFor a node at new index $i$, its original index is $A[i]$. Its original children had indices $L[A[i]]$ and $R[A[i]]$. To find the new indices corresponding to these original child indices, we require a mapping from the original index space to the new index space.\n\nLet us define a mapping array, $M$, of size $n$, where $M[j]$ stores the new index of the node that originally had index $j$. This map can be constructed in a single pass over the array $A$. We iterate with an index $i$ from $0$ to $n-1$:\n$$M[A[i]] = i$$\nThis construction takes $O(n)$ time and $O(n)$ space.\n\nWith the mapping $M$ in hand, we can construct the final pointer arrays $L'$ and $R'$. We initialize $L'$ and $R'$ as arrays of size $n$. We then iterate through the new indices, from $i = 0$ to $n-1$:\n- The node at new position $i$ is the one with original index $u_{\\text{orig}} = A[i]$.\n- The original left child of this node is $c_L = L[u_{\\text{orig}}]$.\n- If $c_L$ is not $-1$, its new index is $M[c_L]$. We set $L'[i] = M[c_L]$. Otherwise, if $c_L$ is $-1$, we set $L'[i] = -1$.\n- Similarly, for the original right child $c_R = R[u_{\\text{orig}}]$: if $c_R \\neq -1$, we set $R'[i] = M[c_R]$; otherwise, $R'[i] = -1$.\n\nThis second pass also takes $O(n)$ time. The total algorithm, therefore, has a time complexity of $O(n) + O(n) + O(n) = O(n)$ and a space complexity for the intermediate and final arrays of $O(n) + O(n) = O(n)$, satisfying all problem constraints.\n\n### Summary of the Algorithm\n1.  Handle the empty tree case ($n=0, r=-1$) by returning three empty arrays.\n2.  Initialize an empty list for the post-order sequence, $A$.\n3.  Perform a recursive DFS starting from the root $r$. In the post-visit step of the DFS for a node $u$, append $u$ to $A$.\n4.  Create a mapping array $M$ of size $n$. Populate it by iterating through $A$: for each $i \\in [0, n-1]$, set $M[A[i]] = i$.\n5.  Initialize two result arrays, $L'$ and $R'$, of size $n$ with a default value of $-1$.\n6.  Iterate from $i=0$ to $n-1$:\n    a. Let $u_{\\text{orig}} = A[i]$.\n    b. Find original children: $c_L = L[u_{\\text{orig}}]$ and $c_R = R[u_{\\text{orig}}]$.\n    c. If $c_L \\neq -1$, set $L'[i] = M[c_L]$.\n    d. If $c_R \\neq -1$, set $R'[i] = M[c_R]$.\n7.  Return the triple $[A, L', R']$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport sys\n\n# It is good practice to increase the recursion limit for deep trees,\n# although not strictly necessary for the given test cases.\nsys.setrecursionlimit(2000)\n\ndef solve():\n    \"\"\"\n    Solves the tree representation problem for a suite of test cases.\n    \"\"\"\n    \n    test_cases = [\n        # Case 1 (empty tree)\n        {'n': 0, 'L': [], 'R': [], 'r': -1},\n        # Case 2 (single node)\n        {'n': 1, 'L': [-1], 'R': [-1], 'r': 0},\n        # Case 3 (left-skewed tree)\n        {'n': 4, 'L': [1, 2, 3, -1], 'R': [-1, -1, -1, -1], 'r': 0},\n        # Case 4 (full binary tree of height 2)\n        {'n': 7, 'L': [1, 3, 5, -1, -1, -1, -1], 'R': [2, 4, 6, -1, -1, -1, -1], 'r': 0},\n        # Case 5 (tree with missing children)\n        {'n': 6, 'L': [1, -1, 4, -1, -1, -1], 'R': [2, 3, -1, -1, 5, -1], 'r': 0}\n    ]\n\n    all_results = []\n\n    def format_case_result(result_triple):\n        \"\"\"Custom formatter to produce output strings without spaces.\"\"\"\n        A, Lp, Rp = result_triple\n        A_str = f\"[{','.join(map(str, A))}]\"\n        Lp_str = f\"[{','.join(map(str, Lp))}]\"\n        Rp_str = f\"[{','.join(map(str, Rp))}]\"\n        return f\"[{A_str},{Lp_str},{Rp_str}]\"\n    \n    for case in test_cases:\n        n, L, R, r = case['n'], case['L'], case['R'], case['r']\n\n        if n == 0:\n            all_results.append(format_case_result([[], [], []]))\n            continue\n        \n        # Phase 1: Perform post-order traversal to get array A\n        A = []\n        def dfs_post_order(node_idx):\n            if node_idx == -1:\n                return\n            \n            # 1. Traverse left subtree\n            dfs_post_order(L[node_idx])\n            # 2. Traverse right subtree\n            dfs_post_order(R[node_idx])\n            # 3. Visit node\n            A.append(node_idx)\n\n        dfs_post_order(r)\n\n        # Phase 2: Remap child pointers\n        \n        # Create a map from original node index to new array index\n        original_to_new_map = [-1] * n\n        for i in range(n):\n            original_node_idx = A[i]\n            original_to_new_map[original_node_idx] = i\n\n        # Create new pointer arrays L' and R'\n        L_prime = [-1] * n\n        R_prime = [-1] * n\n\n        for i in range(n):\n            # i is the new index\n            # A[i] is the original index of the node at this new position\n            original_node_idx = A[i]\n            \n            # Get original children\n            original_left_child = L[original_node_idx]\n            original_right_child = R[original_node_idx]\n            \n            # Update left pointer for the new representation\n            if original_left_child != -1:\n                new_left_child_idx = original_to_new_map[original_left_child]\n                L_prime[i] = new_left_child_idx\n            \n            # Update right pointer for the new representation\n            if original_right_child != -1:\n                new_right_child_idx = original_to_new_map[original_right_child]\n                R_prime[i] = new_right_child_idx\n        \n        all_results.append(format_case_result([A, L_prime, R_prime]))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The standard implicit array representation is convenient but not universally efficient. This exercise exposes its critical weakness: the potential for exponential space waste when representing sparse or unbalanced trees. By focusing on a completely skewed tree, you will quantify this inefficiency and then design a simple, custom mapping that reduces the space requirement from $O(2^N)$ to a lean $O(N)$. This practice powerfully illustrates the trade-offs in data structure design and the value of tailoring a representation to the problem's specific structure. ",
            "id": "3207810",
            "problem": "You are given the standard array-based indexing rules for representing a binary tree, where the left child of a node at index $i$ is placed at index $2 i$ and the right child is placed at index $2 i + 1$ in a $1$-based array. Consider a completely skewed binary tree on $N$ nodes, which is a binary tree where each node has exactly one child and the child is consistently on the same side for the entire tree. Such a tree is structurally equivalent to a linked list of $N$ nodes, where the edges are either all left edges or all right edges.\n\nStarting from the fundamental definitions of binary trees and the array-based representation, note that under the standard mapping the index reached after $d$ successive left edges is $2^{d}$, and the index reached after $d$ successive right edges is $2^{d+1} - 1$. Therefore, for a completely skewed tree of $N$ nodes, the deepest node occurs at depth $N - 1$, and its standard array index is $2^{N-1}$ for an all-left tree and $2^{N} - 1$ for an all-right tree. Consequently, the minimal standard array size required to faithfully represent the tree without collisions is exponential in $N$.\n\nYour task is to design a custom array mapping function that represents any completely skewed tree on $N$ nodes in an array of size $O(N)$, while preserving the ability to compute the parent and the single child index in $O(1)$ time using only arithmetic operations. Specifically, define a mapping $\\varphi$ from the logical node order along the unique path (root to leaf) to array indices such that:\n- $\\varphi$ is injective over the set of $N$ nodes,\n- the parent index and the single child index can be computed from a node’s array index and global skew direction using constant-time arithmetic,\n- the array size used is $\\Theta(N)$, meaning it scales linearly with $N$.\n\nImplement a program that:\n1. Constructs this custom mapping for a completely skewed tree of $N$ nodes, parameterized by the skew direction string $s$, which is either \"L\" for an all-left tree or \"R\" for an all-right tree.\n2. Computes the minimal standard array size required under the standard mapping rules and the minimal custom array size under your mapping.\n3. Computes the ratio $R$ defined as $R = \\frac{\\text{standard size}}{\\text{custom size}}$ as a real number.\n4. Verifies, for each node index $i$ in the custom array, that the computed parent and child indices are consistent with a linear chain: the parent of $i$ is $i - 1$ for $i \\geq 2$, the child of $i$ is $i + 1$ for $i \\leq N - 1$ in the direction $s$, and nonexistent parents or children are encoded by a sentinel integer value of $-1$.\n\nUse only arithmetic computations and the provided parameters; do not rely on external data structures other than arrays and integers. The verification must return a boolean that is true if and only if all nodes satisfy the expected parent and child relationships under the custom mapping.\n\nTest Suite:\n- Case $1$: $N = 1$, $s = \\text{\"L\"}$.\n- Case $2$: $N = 3$, $s = \\text{\"L\"}$.\n- Case $3$: $N = 3$, $s = \\text{\"R\"}$.\n- Case $4$: $N = 10$, $s = \\text{\"L\"}$.\n- Case $5$: $N = 10$, $s = \\text{\"R\"}$.\n- Case $6$: $N = 20$, $s = \\text{\"R\"}$.\n\nFor each test case, your program must output a list containing the following in order:\n- The custom array size as an integer.\n- The standard array size as an integer.\n- The ratio $R$ as a floating-point number.\n- A boolean indicating whether the verification succeeded.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case’s result is itself a list in the same comma-separated bracketed form. For example, the output should look like $[\\,[\\ldots],\\,[\\ldots],\\,\\ldots\\,]$. No additional text should be printed.",
            "solution": "The posed problem requires the design of a custom array-based representation for a completely skewed binary tree of $N$ nodes, such that the array size is linear in $N$ and navigation between parent and child nodes is achievable in constant time. This is contrasted with the standard array representation, which results in an array of size exponential in $N$.\n\n### **1. Analysis of the Problem Statement and Givens**\n\nThe problem provides the standard mapping for a binary tree into a $1$-based array: a node at index $i$ has its left child at index $2i$ and its right child at index $2i+1$. It correctly deduces that for a completely skewed tree of $N$ nodes (a linear chain of left-only or right-only children), the deepest node at depth $d=N-1$ resides at an index that grows exponentially.\n- For an all-left skewed tree, the path from the root (index $1$) involves $N-1$ successive left-child operations. The index of the $k$-th node (at depth $k-1$) is $2^{k-1}$. The final node is at index $2^{N-1}$.\n- For an all-right skewed tree, the path involves $N-1$ right-child operations. The index of the $k$-th node is $2^k-1$. The final node is at index $2^N-1$.\n\nIn both scenarios, the required array size to contain the final node is $O(2^N)$, which is highly inefficient for storing a structure that is topologically equivalent to a list of $N$ elements.\n\n### **2. Design of a Custom Linear-Space Mapping $\\varphi$**\n\nThe objective is to define an injective mapping $\\varphi$ from the logical position of a node in the skewed chain to an array index, using an array of size $\\Theta(N)$.\n\nLet the logical position of nodes along the unique path from root to leaf be denoted by the integer $k \\in \\{1, 2, \\dots, N\\}$, where $k=1$ is the root, $k=2$ is its child, and so on, up to the leaf at $k=N$.\n\nThe most direct and efficient mapping is to store the node with logical position $k$ at the array index $k$. We define the mapping $\\varphi$ as:\n$$\n\\varphi(k) = k\n$$\nWe will use a $1$-based array for conceptual clarity, using indices from $1$ to $N$.\n- **Injectivity**: This mapping is a simple identity function on the set $\\{1, 2, \\dots, N\\}$, and is therefore trivially injective.\n- **Array Size**: The mapping uses indices from $1$ to $N$, so the minimal required array size is $N$. This satisfies the $\\Theta(N)$ requirement.\n\n### **3. Constant-Time Parent and Child Accessor Functions**\n\nThe problem requires constant-time arithmetic functions to compute parent and child indices. Let $i$ be the array index of a given node. Since our mapping is $\\varphi(k)=k$, the array index $i$ is identical to the logical position $k$.\n\n**Parent Accessor Function `getParent(i, N)`:**\nThe parent of the node at logical position $i$ (for $i>1$) is the node at logical position $i-1$. The array index of the parent is therefore $\\varphi(i-1) = i-1$. The root node, at index $i=1$, has no parent. The problem specifies a sentinel value of $-1$ for nonexistent nodes.\nThe parent index is thus given by:\n$$\n\\text{getParent}(i, N) = \\begin{cases} i - 1 & \\text{if } i > 1 \\\\ -1 & \\text{if } i = 1 \\end{cases}\n$$\nThis function uses one comparison and one subtraction, which are $O(1)$ arithmetic operations.\n\n**Child Accessor Function `getChild(i, N)`:**\nThe child of the node at logical position $i$ (for $i<N$) is the node at logical position $i+1$. The array index of the child is $\\varphi(i+1) = i+1$. The leaf node, at index $i=N$, has no child.\nThe child index is given by:\n$$\n\\text{getChild}(i, N) = \\begin{cases} i + 1 & \\text{if } i < N \\\\ -1 & \\text{if } i = N \\end{cases}\n$$\nThis function uses one comparison and one addition, which are also $O(1)$ arithmetic operations.\n\nNote that the global skew direction $s$ (\"L\" or \"R\") is not required for calculating the *index* of the parent or the single child in this particular mapping, because the array stores the nodes contiguously according to their logical order in the chain. The parameter $s$ would be necessary if the functions had to distinguish between a *left* child and a *right* child (e.g., `getLeftChild(i, N, s)` would return $i+1$ if $s=\\text{\"L\"}$ and $-1$ if $s=\\text{\"R\"}$). However, the problem asks only for the index of \"the single child,\" for which $s$ is not needed. The parameter $s$ is crucial, however, for calculating the size of the standard representation.\n\n### **4. Calculation and Verification Procedure**\n\nThe implementation will follow these steps for each test case $(N, s)$:\n\n1.  **Custom Array Size**: The size is simply $N$.\n\n2.  **Standard Array Size**: This is determined by the index of the deepest node.\n    - If $N=0$, the size is $0$. The test cases start at $N=1$.\n    - If $N=1$, the tree has only a root at index $1$. The size is $1$.\n    - If $N>1$ and $s = \\text{\"L\"}$, the size is $2^{N-1}$.\n    - If $N>1$ and $s = \\text{\"R\"}$, the size is $2^N-1$.\n\n3.  **Ratio $R$**: The ratio is computed as $R = \\frac{\\text{standard size}}{\\text{custom size}}$.\n\n4.  **Verification**: The verification step confirms that the implemented accessor functions adhere to the problem's definition of a linear chain. For each index $i \\in \\{1, \\dots, N\\}$:\n    - We compute `p_computed = getParent(i, N)` and `c_computed = getChild(i, N)`.\n    - We determine the expected indices based on the problem's definition: `p_expected` is $i-1$ for $i \\ge 2$ (or $i>1$) and $-1$ otherwise; `c_expected` is $i+1$ for $i \\le N-1$ (or $i<N$) and $-1$ otherwise.\n    - The verification passes if and only if `p_computed == p_expected` and `c_computed == c_expected` for all $i$. By our design, this condition will always be met.\n\nThis structured approach provides a comprehensive solution that is efficient, correct, and directly follows from the principles of data structure representation.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the skewed binary tree representation problem for a suite of test cases.\n    \"\"\"\n    # Test cases as defined in the problem statement.\n    test_cases = [\n        (1, \"L\"),\n        (3, \"L\"),\n        (3, \"R\"),\n        (10, \"L\"),\n        (10, \"R\"),\n        (20, \"R\"),\n    ]\n\n    results = []\n    for N, s in test_cases:\n        # 1. Compute the size of the custom array representation.\n        # The mapping phi(k) = k uses indices 1...N, so the size is N.\n        if N > 0:\n            custom_size = N\n        else:\n            custom_size = 0\n\n        # 2. Compute the minimal standard array size required.\n        # Python's arbitrary-precision integers are used via dtype=object with numpy\n        # to prevent overflow with large N, although N=20 fits in int64.\n        if N == 0:\n            standard_size = 0\n        elif N == 1:\n            standard_size = 1\n        elif s == \"L\":\n            standard_size = int(np.power(2, N - 1, dtype=object))\n        elif s == \"R\":\n            standard_size = int(np.power(2, N, dtype=object) - 1)\n        else:\n            # This case should not be reached with the given test suite.\n            raise ValueError(\"Invalid skew direction specified.\")\n\n        # 3. Compute the ratio R.\n        # Handle division by zero for the edge case N=0, though not in test suite.\n        if custom_size == 0:\n            ratio = 0.0\n        else:\n            ratio = float(standard_size) / float(custom_size)\n\n        # 4. Verify the custom mapping's accessor logic.\n        verification_succeeded = True\n        if N > 0:\n            for i in range(1, N + 1):\n                # The implementation of our O(1) accessor functions.\n                # These define the computed parent and child indices.\n                computed_parent = (i - 1) if i > 1 else -1\n                computed_child = (i + 1) if i  N else -1\n\n                # The problem's definition of correctness for a linear chain.\n                # 'parent of i is i-1 for i >= 2' is equivalent to 'i > 1' for integers.\n                # 'child of i is i+1 for i = N-1' is equivalent to 'i  N' for integers.\n                expected_parent = (i - 1) if i >= 2 else -1\n                expected_child = (i + 1) if i = N - 1 else -1\n\n                if not (computed_parent == expected_parent and computed_child == expected_child):\n                    verification_succeeded = False\n                    break\n        \n        results.append([custom_size, standard_size, ratio, verification_succeeded])\n\n    # Final print statement in the exact required format.\n    # The format is a list of lists, represented as a string.\n    result_str = \",\".join([f\"[{c},{s},{r},{v}]\" for c, s, r, v in results])\n    print(f\"[{result_str}]\")\n\nsolve()\n```"
        }
    ]
}