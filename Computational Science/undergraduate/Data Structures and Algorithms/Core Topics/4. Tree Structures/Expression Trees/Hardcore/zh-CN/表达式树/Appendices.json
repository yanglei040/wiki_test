{
    "hands_on_practices": [
        {
            "introduction": "表达式树不仅是理论上的数据结构，它在编译器设计中扮演着核心角色。这个练习将理论与实践相结合，要求你将一个给定的表达式树翻译成一个简单的基于栈的虚拟机指令序列。通过这个过程，你将亲身体验后序遍历如何自然地生成可执行代码，并加深对表达式求值过程的理解。",
            "id": "3232522",
            "problem": "您将获得有根、有序的表达式树，其中每个内部节点都是一个运算符，每个叶节点则是一个变量或一个常量。目标是将每个表达式树转换为一个扁平的整数编码指令序列，供一个基于堆栈的虚拟机使用。当执行此序列时，虚拟机会根据实数算术的语义对表达式进行求值。语义是根据树的结构和后进先出堆栈的行为从基本原理定义的。\n\n基本定义：\n- 表达式树是一个有限的有根有序树。每个叶节点代表一个常量或一个变量。每个一元运算符节点恰好有一个子节点，每个二元运算符节点恰好有两个子节点。设树计算的总体表达式表示为 $E$，其求值由树的结构递归定义。\n- 基于堆栈的虚拟机维护一个值堆栈 $S$。指令以确定性的方式作用于 $S$。\n\n指令集和编码：\n- 操作码是具有以下映射的整数代码：\n  - $0$: 推入常量，表示为 $\\text{PUSH\\_CONST}$，它接受一个立即操作数，即常量值。\n  - $1$: 推入变量，表示为 $\\text{PUSH\\_VAR}$，它接受一个立即操作数，即变量的非负整数索引。\n  - $2$: 加法，表示为 $\\text{ADD}$，它从 $S$ 中弹出顶部两个元素 $r$ 和 $l$（其中 $r$ 是右操作数，$l$ 是左操作数），然后推入 $l + r$。\n  - $3$: 减法，表示为 $\\text{SUB}$，它弹出 $r$ 和 $l$，然后推入 $l - r$。\n  - $4$: 乘法，表示为 $\\text{MUL}$，它弹出 $r$ 和 $l$，然后推入 $l \\cdot r$。\n  - $5$: 除法，表示为 $\\text{DIV}$，它弹出 $r$ 和 $l$，然后推入 $l / r$。\n  - $6$: 一元取反，表示为 $\\text{NEG}$，它弹出一个元素 $a$，然后推入 $-a$。\n  - $7$: 幂运算，表示为 $\\text{POW}$，它弹出 $r$ 和 $l$，然后推入 $l^r$。\n- 指令流是一个扁平的整数列表。对于 $\\text{PUSH\\_CONST}$ 和 $\\text{PUSH\\_VAR}$，操作码后面紧跟着一个整数操作数（分别是常量值或变量索引）。对于所有其他操作码，指令仅为单个操作码整数。\n- 变量由非负整数索引标识。例如，变量 $x$ 可以绑定到索引 $0$，变量 $y$ 绑定到索引 $1$，以此类推。常量是整数；假设它们在 $64$ 位有符号整数范围内。\n\n要求的编译语义：\n- 表达式树的指令序列必须通过对树进行后序遍历（子节点在父节点之前）来生成，并按如下方式发出指令：\n  - 对于值为 $c$ 的常量叶节点：发出 $[0, c]$。\n  - 对于索引为 $i$ 的变量叶节点：发出 $[1, i]$。\n  - 对于带有一个子节点 $u$ 的一元取反节点：发出 $u$ 的序列，然后发出 $[6]$。\n  - 对于带有左子节点 $L$、右子节点 $R$ 和运算符 $\\oplus \\in \\{+, -, \\cdot, /, \\wedge\\}$ 的二元运算符节点：发出 $L$ 的序列，然后发出 $R$ 的序列，最后发出对应于 $\\oplus$ 的操作码（即，$+$ 对应 $[2]$，$-$ 对应 $[3]$，$\\cdot$ 对应 $[4]$，$/$ 对应 $[5]$，$\\wedge$ 对应 $[7]$）。\n\n科学真实性和通用性：\n- 该方法必须从表达式树的核心定义和上述确定性堆栈语义中推导出来，而不依赖于这些定义之外的任何捷径。\n- 在这些语义下，对于由支持的运算符组成的任何表达式，编译后的序列都必须是正确的。\n\n测试套件：\n- 使用以下六个不同的表达式树和变量索引绑定来测试您的编译。对于每种情况，根据上述编码，生成相应的整数列表形式的指令流。\n  - 情况 $1$（通用二元组合）：$(x + 3) \\cdot (y - 2)$，其中 $x$ 映射到索引 $0$，$y$ 映射到索引 $1$。\n  - 情况 $2$（一元和二元混合）：$-x + 5$，其中 $x$ 映射到索引 $0$。\n  - 情况 $3$（幂运算和除法）：$\\dfrac{a^{3}}{b + 1}$，其中 $a$ 映射到索引 $2$，$b$ 映射到索引 $3$。\n  - 情况 $4$（单个常量）：$42$。\n  - 情况 $5$（深度左结合减法）：$(((x - 1) - 2) - 3)$，其中 $x$ 映射到索引 $0$。\n  - 情况 $6$（双重一元取反）：$-(-(c))$，其中 $c$ 映射到索引 $5$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表内任何地方都不能有空格。每个元素都应是对应一个测试用例的内部指令列表，顺序为情况$1$到情况$6$。例如，生成类似于 `[[i_{1,1},i_{1,2},...],[i_{2,1},...],...]` 的内容，其中每个 $i_{k,j}$ 都是一个整数。请确保确切的格式不含任何空格。",
            "solution": "问题陈述已经过验证，并被认为是合理的。它在科学上基于计算机科学的原理，特别是涉及数据结构（表达式树）和编译理论（堆栈机和指令编码）。该问题是适定的，具有清晰、客观且完备的定义和约束集，从而可以为每个测试用例推导出唯一且可验证的解。\n\n将表达式树转换为基于堆栈的虚拟机指令序列的核心原理是后序遍历算法。后序遍历先访问左子节点，然后是右子节点（对于二元节点），最后是父节点。这个 `左-右-父` 的序列自然对应于逆波兰表示法（RPN），或称后缀表示法，其中操作数出现在其运算符之前。基于堆栈的机器旨在高效地对RPN表达式求值：它将操作数推入堆栈，当遇到运算符时，弹出所需数量的操作数，执行运算，然后将结果推回堆栈。\n\n该问题要求我们将此过程形式化为一个编译算法。让我们将为以节点 $N$ 为根的给定子树生成指令序列的函数表示为 $\\text{Compile}(N)$。$\\text{Compile}(N)$ 的输出是一个代表机器指令的扁平整数列表。该函数的行为根据节点 $N$ 的类型递归定义。\n\n指令集由整数操作码定义：\n- $\\text{PUSH\\_CONST} = 0$：接受一个操作数（常量值）。\n- $\\text{PUSH\\_VAR} = 1$：接受一个操作数（变量索引）。\n- $\\text{ADD} = 2$, $\\text{SUB} = 3$, $\\text{MUL} = 4$, $\\text{DIV} = 5$：二元运算符。\n- $\\text{NEG} = 6$：一元运算符。\n- $\\text{POW} = 7$：二元运算符。\n\n编译算法由以下规则定义：\n\n1.  **基本情况：叶节点**\n    - 如果节点 $N$ 是值为 $c$ 的常量叶节点，机器必须将此常量推入堆栈。指令序列为 $[\\text{PUSH\\_CONST}, c]$。因此，$\\text{Compile}(N) = [0, c]$。\n    - 如果节点 $N$ 是索引为 $i$ 的变量叶节点，机器必须将此变量的值推入堆栈。指令序列为 $[\\text{PUSH\\_VAR}, i]$。因此，$\\text{Compile}(N) = [1, i]$。\n\n2.  **递归情况：一元运算符节点**\n    - 如果节点 $N$ 是一个带单个子节点 $U$ 的一元运算符（例如，取反 $\\text{NEG}$），后序遍历规定我们首先处理子树。求值要求操作数（对 $U$ 求值的结果）在应用运算符之前位于堆栈上。因此，我们首先为子节点生成指令，然后附加运算符的操作码。\n    - $\\text{Compile}(N) = \\text{Compile}(U) \\oplus [\\text{OP}_{\\text{unary}}]$，其中 $\\oplus$ 表示列表拼接，$\\text{OP}_{\\text{unary}}$ 是一元运算符的操作码（例如，$\\text{NEG}$ 为 $6$）。\n\n3.  **递归情况：二元运算符节点**\n    - 如果节点 $N$ 是一个带有左子节点 $L$ 和右子节点 $R$ 的二元运算符（例如，加法 $+$），后序遍历会先访问 $L$，然后是 $R$，最后是 $N$。为了求值，机器需要左操作数在堆栈上，其后是右操作数。因此，我们先为 $L$ 生成指令，然后为 $R$ 生成指令，最后附加运算符的操作码。\n    - $\\text{Compile}(N) = \\text{Compile}(L) \\oplus \\text{Compile}(R) \\oplus [\\text{OP}_{\\text{binary}}]$，其中 $\\text{OP}_{\\text{binary}}$ 是二元运算符的操作码（例如，$\\text{ADD}$ 为 $2$）。\n\n让我们用测试用例1来演示这个算法：表达式 $(x + 3) \\cdot (y - 2)$，其中变量 $x$ 的索引为 $0$，$y$ 的索引为 $1$。\n\n表达式树的根节点是一个乘法节点（$\\cdot$）。\n- 左子节点 $L$ 是子表达式 $(x + 3)$ 的加法节点（$+$）。\n- 右子节点 $R$ 是子表达式 $(y - 2)$ 的减法节点（$-$）。\n\n编译过程如下：\n$\\text{Compile}(\\cdot) = \\text{Compile}(+) \\oplus \\text{Compile}(-) \\oplus [4]$\n\n- 计算 $(x + 3)$ 的 $\\text{Compile}(+)$：\n  - 左子节点是变量 $x$（索引 $0$）。$\\text{Compile}(x) = [1, 0]$。\n  - 右子节点是常量 $3$。$\\text{Compile}(3) = [0, 3]$。\n  - $+$ 的操作码是 $2$。\n  - $\\text{Compile}(+) = \\text{Compile}(x) \\oplus \\text{Compile}(3) \\oplus [2] = [1, 0] \\oplus [0, 3] \\oplus [2] = [1, 0, 0, 3, 2]$。\n\n- 计算 $(y - 2)$ 的 $\\text{Compile}(-)$：\n  - 左子节点是变量 $y$（索引 $1$）。$\\text{Compile}(y) = [1, 1]$。\n  - 右子节点是常量 $2$。$\\text{Compile}(2) = [0, 2]$。\n  - $-$ 的操作码是 $3$。\n  - $\\text{Compile}(-) = \\text{Compile}(y) \\oplus \\text{Compile}(2) \\oplus [3] = [1, 1] \\oplus [0, 2] \\oplus [3] = [1, 1, 0, 2, 3]$。\n\n- 最后，我们组装完整的序列：\n  - $\\text{Compile}(\\cdot) = [1, 0, 0, 3, 2] \\oplus [1, 1, 0, 2, 3] \\oplus [4]$\n  - 最终的指令流是 $[1, 0, 0, 3, 2, 1, 1, 0, 2, 3, 4]$。\n\n当执行时，该序列执行以下堆栈操作：\n1. PUSH\n2. PUSH\n3. ADD (堆栈现在包含 $x+3$)\n4. PUSH\n5. PUSH\n6. SUB (堆栈现在包含 $x+3, y-2$)\n7. MUL (堆栈现在包含 $(x+3) \\cdot (y-2)$)\n\n此过程被系统地应用于所有提供的测试用例，以生成它们各自对应的指令流。该逻辑是确定性的，并且直接源于表达式树和基于堆栈的计算的基本定义。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of compiling expression trees into a flat sequence\n    of integer-encoded instructions for a stack-based virtual machine.\n    \"\"\"\n\n    # Opcodes as defined in the problem statement.\n    OP_PUSH_CONST = 0\n    OP_PUSH_VAR = 1\n    OP_ADD = 2\n    OP_SUB = 3\n    OP_MUL = 4\n    OP_DIV = 5\n    OP_NEG = 6\n    OP_POW = 7\n\n    # Mapping from operator symbols to opcodes for convenience.\n    OPCODE_MAP = {\n        '+': OP_ADD,\n        '-': OP_SUB,\n        '*': OP_MUL,\n        '/': OP_DIV,\n        'NEG': OP_NEG,\n        '^': OP_POW,\n    }\n\n    def compile_tree(node):\n        \"\"\"\n        Recursively compiles an expression tree node into an instruction list\n        based on a postorder traversal.\n        The tree structure is represented using nested dictionaries.\n        \"\"\"\n        # Case 1: Binary operator node\n        if 'op' in node and 'L' in node and 'R' in node:\n            left_instr = compile_tree(node['L'])\n            right_instr = compile_tree(node['R'])\n            op_code = OPCODE_MAP[node['op']]\n            return left_instr + right_instr + [op_code]\n        \n        # Case 2: Unary operator node\n        elif 'op' in node and 'arg' in node:\n            arg_instr = compile_tree(node['arg'])\n            op_code = OPCODE_MAP[node['op']]\n            return arg_instr + [op_code]\n            \n        # Case 3: Variable leaf node\n        elif 'var' in node:\n            return [OP_PUSH_VAR, node['var']]\n            \n        # Case 4: Constant leaf node\n        elif 'const' in node:\n            return [OP_PUSH_CONST, node['const']]\n            \n        else:\n            # This should not be reached with well-formed trees.\n            raise ValueError(\"Invalid node format in expression tree\")\n\n    # Define the six test cases using the nested dictionary representation.\n    test_cases = [\n        # Case 1: (x + 3) * (y - 2) with x=0, y=1\n        {'op': '*', 'L': {'op': '+', 'L': {'var': 0}, 'R': {'const': 3}}, 'R': {'op': '-', 'L': {'var': 1}, 'R': {'const': 2}}},\n        \n        # Case 2: (-x) + 5 with x=0\n        {'op': '+', 'L': {'op': 'NEG', 'arg': {'var': 0}}, 'R': {'const': 5}},\n        \n        # Case 3: a^3 / (b + 1) with a=2, b=3\n        {'op': '/', 'L': {'op': '^', 'L': {'var': 2}, 'R': {'const': 3}}, 'R': {'op': '+', 'L': {'var': 3}, 'R': {'const': 1}}},\n        \n        # Case 4: 42\n        {'const': 42},\n        \n        # Case 5: (((x - 1) - 2) - 3) with x=0\n        {'op': '-', 'L': {'op': '-', 'L': {'op': '-', 'L': {'var': 0}, 'R': {'const': 1}}, 'R': {'const': 2}}, 'R': {'const': 3}},\n        \n        # Case 6: -(-(c)) with c=5\n        {'op': 'NEG', 'arg': {'op': 'NEG', 'arg': {'var': 5}}},\n    ]\n\n    results = []\n    for tree in test_cases:\n        instruction_list = compile_tree(tree)\n        results.append(instruction_list)\n\n    # Format the output exactly as specified: [[i_1,1,...],[i_2,1,...],...] with no spaces.\n    # 1. Convert each inner list of integers to a string like '[1,2,3]'.\n    # 2. Join these strings with commas.\n    # 3. Enclose the final result in brackets.\n    result_strings = []\n    for res_list in results:\n        # Create string representation of inner list without spaces\n        inner_str = '[' + ','.join(map(str, res_list)) + ']'\n        result_strings.append(inner_str)\n    \n    final_output = '[' + ','.join(result_strings) + ']'\n    \n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "掌握了如何分析表达式树后，我们来挑战一个逆向问题：如何构建一棵树来达成特定目标。这个练习以经典的“24点”游戏为背景，要求你利用给定的数字和运算符，通过系统性的递归搜索，构建一个能精确计算出目标值的表达式树。这不仅能锻炼你的算法设计能力，还能让你深入理解树的组合可能性。",
            "id": "3232629",
            "problem": "给定一个有限的整数多重集和一个整数目标值。将每个整数视为一个二元表达式树中的叶节点。内部节点是从集合 $\\{+,-,\\*,/\\}` 中选取的二元运算符。你必须将每个给定的整数恰好使用一次作为叶节点，并且不能引入任何新的常数。括号隐含在树的结构中。除法是精确的有理数除法，不允许除以零。没有一元运算符。表达式树的值是通过对内部节点的二元运算符，以常规代数方式作用于其子树的值来获得的。\n\n仅使用二元表达式树的核心定义、有理数的精确算术，以及任何具有多于一个叶节点的二元树都可以在其根部被分解为两个真子树这一事实，从第一性原理出发，推导出一个算法。该算法在给定一个叶节点多重集的情况下，能够枚举出通过使用所有叶节点恰好一次的某个表达式树可以达成的所有值，以及每个值的最小可能高度。树的高度定义为从根到叶的最长路径上的边数；单个叶节点的树高度为 $0$。对于任何内部节点，若其左子树高度为 $h_\\ell$，右子树高度为 $h_r$，则该节点的高度为 $1+\\max(h_\\ell,h_r)$。\n\n你的程序必须对下面的每个测试用例，计算出所有能够精确等于给定目标值（在有理数上精确相等）的有效表达式树中，最小的可能高度 $h^\\star$。如果不存在这样的树，则对该用例输出 $-1$。所有算术运算必须在有理数上精确执行，相等性判断也必须在有理数上精确进行。任何中间步骤的除零操作都是无效的，必须被舍弃。\n\n测试套件：\n- 用例 1：多重集 $[8, 8, 3, 3]$, 目标值 $24$.\n- 用例 2：多重集 $[24]$, 目标值 $24$.\n- 用例 3：多重集 $[1, 1, 1, 1]$, 目标值 $24$.\n- 用例 4：多重集 $[4, 4, 4, 4]$, 目标值 $24$.\n- 用例 5：多重集 $[-1, 2, 3, 4]$, 目标值 $-24$.\n\n最终输出格式：\n- 你的程序应生成一行输出，其中包含五个结果，以逗号分隔的列表形式，并用方括号括起来，顺序与上述用例一致，例如：$[h_1, h_2, h_3, h_4, h_5]$。每个 $h_i$ 是一个整数，如果可以达到目标值，则等于最小高度，否则为 $-1$。\n\n覆盖性设计：\n- 该套件包括一个典型的可解用例、一个单叶边界用例、一个无解用例、一个包含重复数字的可解用例以及一个涉及负数的用例。你的算法必须系统地考虑所有与给定叶节点一致的二元树形状和运算符放置方式，并且必须强制执行上述的精确有理数算术和高度定义。",
            "solution": "该问题要求从第一性原理出发，推导出一个算法，用于寻找能够计算出特定目标值的二元表达式树的最小高度。该树必须由给定的整数多重集构建，其中每个整数恰好作为叶节点使用一次，并使用一组二元运算符 $\\{+,-,*,/\\}`。\n\n设 $S$ 为给定的整数多重集。设 $V(T)$ 为表达式树 $T$ 的值，$H(T)$ 为其高度。我们需要找到 $h^\\star = \\min \\{ H(T) \\mid V(T) = \\text{target} \\land \\text{leaves}(T) = S \\}$。如果不存在这样的树，则 $h^\\star = -1$。\n\n推导过程源于二元树的基本递归结构，正如问题陈述所提示的：“任何具有多于一个叶节点的二元树都可以在其根部被分解为两个真子树”。\n\n让我们定义一个函数 $\\text{Compute}(S)$，它返回一个映射，其中包含使用多重集 $S$ 中的数字可以达成的所有可能值。这个映射会将每个可达成的值 $v$ 与产生该值的树的最小可能高度 $h$ 相关联。我们将此映射表示为 $M_S$，其中 $M_S[v] = h$。\n\n**基本情况**\n如果多重集 $S$ 只包含一个元素 $S=\\{x\\}$，唯一可能的树是单个叶节点。\n- 该树的值为 $x$。\n- 该树的高度定义为 $0$。\n因此，对于单元素多重集 $\\{x\\}$，结果是 $\\text{Compute}(\\{x\\}) = \\{x \\mapsto 0\\}$。\n\n**递归步骤**\n如果 $S$ 包含多个元素（$|S| > 1$），任何以 $S$ 中元素为叶节点的表达式树 $T$ 都必须有一个对应于二元运算符 $\\circ \\in \\{+, -, *, /\\}$ 的根节点。这个根节点有一个左子节点和一个右子节点，它们分别是两个非空子树 $T_L$ 和 $T_R$ 的根。\n\n$T$ 的叶节点集合是 $T_L$ 和 $T_R$ 叶节点的多重集并集。这意味着多重集 $S$ 必须被划分为两个非空的、不相交的子多重集 $S_L$ 和 $S_R$，使得 $S_L \\cup S_R = S$。$T_L$ 的叶节点来自 $S_L$，$T_R$ 的叶节点来自 $S_R$。\n\n树 $T$ 的值为 $V(T) = V(T_L) \\circ V(T_R)$。\n树 $T$ 的高度为 $H(T) = 1 + \\max(H(T_L), H(T_R))$。\n\n这种分解是我们算法的基础。要找到一个多重集 $S$ 的所有可达成值及其最小高度，我们可以：\n1.  生成 $S$ 的所有可能的划分为两个非空子多重集 $S_L$ 和 $S_R$。\n2.  对每个划分 $(S_L, S_R)$，递归调用 $\\text{Compute}(S_L)$ 和 $\\text{Compute}(S_R)$ 以获得结果映射 $M_{S_L}$ 和 $M_{S_R}$。\n3.  对于来自 $M_{S_L}$ 的每对值 $(v_L, h_L)$ 和来自 $M_{S_R}$ 的 $(v_R, h_R)$，我们可以形成一棵新的、更大的树。\n    - 新的高度将是 $h = 1 + \\max(h_L, h_R)$。\n    - 对于每个运算符 $\\circ \\in \\{+,-,*,/\\}`，我们计算一个新值 $v = v_L \\circ v_R$。\n    - 我们必须处理无效的除零情况。例如，仅当 $v_R \\neq 0$ 时才计算 $v_L / v_R$。\n    - 对于非交换运算符（减法和除法），我们必须同时考虑 $v_L \\circ v_R$ 和 $v_R \\circ v_L$。\n    - 对于每个新计算出的值 $v$，我们更新它在 $S$ 的结果映射 $M_S$ 中的条目。如果 $v$ 尚未在 $M_S$ 中，我们以高度 $h$ 将其添加。如果它已存在，我们将其高度更新为 $\\min(M_S[v], h)$。\n\n这个递归过程天然地适合动态规划或记忆化方法。我们可以存储原始 $S$ 的每个子多重集 $S'$ 的 $\\text{Compute}(S')$ 的结果，以避免重复计算。记忆化表的键可以是多重集的规范表示，例如其元素的排序元组。\n\n**有理数算术**\n问题要求精确的有理数算术。这对于除法运算符和与目标值的精确相等性检查至关重要。我们必须使用一种能将数字表示为分数的数据类型，例如 $a/b$，其中 $a, b$ 是整数。标准的浮点算术因精度误差而不适用。\n\n**算法纲要**\n1.  初始化一个记忆化字典 `memo`。\n2.  定义一个递归函数 `compute(s_tuple)`，其中 `s_tuple` 是一个代表多重集的排序元组。\n3.  在 `compute(s_tuple)` 内部：\n    a. 如果 `s_tuple` 在 `memo` 中，返回存储的结果。\n    b. 如果 `len(s_tuple) == 1`，返回一个映射 `{Fraction(s_tuple[0]): 0}`。\n    c. 初始化一个空映射 `current_results`。\n    d. 遍历 `s_tuple` 的所有唯一划分为两个非空的、排序的子元组 `s_L` 和 `s_R`。这可以通过遍历子集大小 $k$ 从 $1$ 到 $|S|/2$ 并生成索引组合来完成。\n    e. 对于每个划分 $(s_L, s_R)$：\n        i. 递归地获取 $M_{S_L} = \\text{compute}(s_L)$ 和 $M_{S_R} = \\text{compute}(s_R)$。\n        ii. 对于 $M_{S_L}$ 中的每个 $(v_L, h_L)$ 和 $M_{S_R}$ 中的每个 $(v_R, h_R)$：\n            - 计算 $h = 1 + \\max(h_L, h_R)$。\n            - 计算所有运算符的新值：$v_L+v_R$, $v_L-v_R$, $v_R-v_L$, $v_L \\times v_R$。如果分母非零，也计算 $v_L/v_R$ 和 $v_R/v_L$。\n            - 对于每个新值 $v$，更新 `current_results`：如果 $v$ 不在映射中或 $h  \\text{current\\_results}[v]$，则设置 $\\text{current\\_results}[v] = h$。\n    f. 将 `current_results` 存储在 `memo` 中，键为 `s_tuple`，并返回它。\n\n4.  要解决一个特定的测试用例（多重集 `initial_S`，整数 `target`），调用 `compute(tuple(sorted(initial_S)))`。\n5.  检查 `Fraction(target)` 是否作为键存在于返回的映射中。如果是，其值就是最小高度。如果不是，则目标无法达成，结果为 $-1$。\n\n该算法系统地探索了所有可以形成的有效表达式树，保证了正确性，并能找到任何可达成值的最小高度。\n例如，对于多重集 $[8, 8, 3, 3]$ 和目标值 $24$, 算法会探索像 $(\\{3,3,8\\}, \\{8\\})$ 这样的划分，并最终发现表达式 $8 / (3 - 8/3)$，它对应于树 $(\\text{root}=/,\\, T_L=\\{8\\},\\, T_R=\\{3,3,8\\} \\text{ 形成 } 1/3)$，高度为 $1 + \\max(H(T_L), H(T_R)) = 1+\\max(0,2) = 3$。它也会评估像 $(\\{3,8\\}, \\{3,8\\})$ 这样的平衡划分，以检查是否存在高度更小（为 $2$）的解，但会发现没有能得出 $24$ 的解。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom fractions import Fraction\nfrom collections.abc import Mapping\nfrom itertools import combinations\n\n# Global memoization table\n# Key: sorted tuple of numbers (representing a multiset)\n# Value: a dictionary mapping achievable Fraction values to their minimum height\nmemo: dict[tuple[int, ...], dict[Fraction, int]] = {}\n\ndef update_results(res_map: dict[Fraction, int], val: Fraction, height: int):\n    \"\"\"\n    Updates the results map with a new value and height.\n    If the value is new, it's added.\n    If the value exists, its height is updated only if the new height is smaller.\n    \"\"\"\n    if val not in res_map or height  res_map[val]:\n        res_map[val] = height\n\ndef compute_achievable_values(s_tuple: tuple[int, ...]) - dict[Fraction, int]:\n    \"\"\"\n    Recursively computes all achievable values from a multiset of numbers (s_tuple)\n    and returns a map from each value to its minimum achievable height.\n    Uses memoization to store results for subproblems.\n    \"\"\"\n    if s_tuple in memo:\n        return memo[s_tuple]\n\n    n = len(s_tuple)\n    if n == 1:\n        # Base case: a single number forms a leaf node with height 0.\n        result = {Fraction(s_tuple[0]): 0}\n        memo[s_tuple] = result\n        return result\n\n    current_results: dict[Fraction, int] = {}\n    \n    # Partition s_tuple into two non-empty sub-multisets, s_L and s_R.\n    # We iterate through the size of the left partition, k, up to n // 2.\n    # This, combined with canonical representation of partitions, avoids duplicates.\n    processed_partitions = set()\n    for k in range(1, n // 2 + 1):\n        # Generate partitions by choosing k indices for the left sub-multiset.\n        for left_indices in combinations(range(n), k):\n            left_list = [s_tuple[i] for i in left_indices]\n            \n            right_list = []\n            right_indices_set = set(range(n)) - set(left_indices)\n            for i in sorted(list(right_indices_set)):\n                 right_list.append(s_tuple[i])\n\n            # Use sorted tuples as canonical representations for sub-multisets\n            s_L = tuple(left_list)\n            s_R = tuple(right_list)\n\n            # Canonical representation of the partition pair to avoid duplicates\n            # like ((a,b), (c,d)) and ((c,d), (a,b)).\n            if s_L  s_R:\n                s_L, s_R = s_R, s_L\n            \n            if (s_L, s_R) in processed_partitions:\n                continue\n            processed_partitions.add((s_L, s_R))\n\n            # Recursive calls to solve for the sub-multisets\n            results_L = compute_achievable_values(s_L)\n            results_R = compute_achievable_values(s_R)\n\n            # Combine results from left and right subtrees\n            for val_L, h_L in results_L.items():\n                for val_R, h_R in results_R.items():\n                    height = 1 + max(h_L, h_R)\n                    \n                    # Addition\n                    update_results(current_results, val_L + val_R, height)\n                    \n                    # Subtraction (non-commutative)\n                    update_results(current_results, val_L - val_R, height)\n                    update_results(current_results, val_R - val_L, height)\n                    \n                    # Multiplication\n                    update_results(current_results, val_L * val_R, height)\n                    \n                    # Division (non-commutative and guards against zero division)\n                    if val_R != 0:\n                        update_results(current_results, val_L / val_R, height)\n                    if val_L != 0:\n                        update_results(current_results, val_R / val_L, height)\n\n    memo[s_tuple] = current_results\n    return current_results\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        {'multiset': [8, 8, 3, 3], 'target': 24},  # Case 1\n        {'multiset': [24], 'target': 24},          # Case 2\n        {'multiset': [1, 1, 1, 1], 'target': 24},  # Case 3\n        {'multiset': [4, 4, 4, 4], 'target': 24},  # Case 4\n        {'multiset': [-1, 2, 3, 4], 'target': -24} # Case 5\n    ]\n    \n    results = []\n    \n    for case in test_cases:\n        # Clear memoization table for each independent test case\n        global memo\n        memo.clear()\n        \n        multiset = case['multiset']\n        target = case['target']\n        \n        # The algorithm requires a sorted tuple for keys\n        s_tuple = tuple(sorted(multiset))\n        \n        all_values = compute_achievable_values(s_tuple)\n        \n        target_fraction = Fraction(target)\n        \n        if target_fraction in all_values:\n            results.append(all_values[target_fraction])\n        else:\n            results.append(-1)\n            \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the solver\nsolve()\n\n```"
        },
        {
            "introduction": "在数学上等价的表达式，其树形结构可能千差万别，而不同的结构会影响计算性能。此练习旨在探讨表达式树的优化问题，你将利用加法和乘法的结合律与交换律，将给定的表达式树重构成高度最小的等价形式。这个过程揭示了如何通过变换树的拓扑结构来获得更“平衡”的树，这在并行计算和减少计算延迟等场景中至关重要。",
            "id": "3232681",
            "problem": "给定算术表达式树，其中每个内部节点是一个二元运算符，每个叶节点是一个变量或非负整数常量。您的任务是，对于每个给定的表达式树，计算等价树的最小可能高度。您只允许在任何相同运算符的最大区域内更改操作数的分组和排序，利用结合律和交换律，但不能更改运算符、引入或移除操作数、应用分配律或进行任何代数简化。\n\n定义与约束：\n- 表达式树是一个满二叉树，其中内部节点由集合 $\\{+,\\ast\\}$ 中的运算符标记，叶节点由变量（单个小写字母）或非负整数常量标记。\n- 高度函数 $H(\\cdot)$ 在树上递归定义如下：对于叶节点 $\\ell$，$H(\\ell)=1$；对于具有左子树 $L$ 和右子树 $R$ 的内部节点，$H(\\mathrm{node})=1+\\max\\{H(L),H(R)\\}$。\n- 您只能使用加法和乘法的结合律与交换律。即，$a+b=b+a$，$a+(b+c)=(a+b)+c$，$a\\ast b=b\\ast a$，以及 $a\\ast(b\\ast c)=(a\\ast b)\\ast c$。您不允许应用分配律 $a\\ast(b+c)=a\\ast b + a\\ast c$，也不允许进行任何单位元或零元简化（例如，您不能从和中删除 $0$ 或从积中删除 $1$）。\n- 对于运算符 $\\oplus\\in\\{+,\\ast\\}$，一个最大结合交换区域是仅由标记为 $\\oplus$ 的内部节点组成的最大连通子图。在此类区域内，您可以任意重新排序和重新组合操作数，但必须保留运算符 $\\oplus$。\n- 对于每个以运算符 $\\oplus$ 为根的最大结合交换区域，其操作数子树的高度为 $h_1,h_2,\\dots,h_m$，重排的唯一效果是为这 $m$ 个操作数子树选择一个二叉满树的形状和排序，以最小化最终的高度。\n\n此任务的输入模型：\n- 您无需读取任何输入。相反，您的程序必须内部评估下面指定的固定测试套件。每个表达式都以 ASCII 字符串形式给出，使用以下语法：$+$ 的优先级低于 $\\ast$，可以出现括号 $($ 和 $)$，变量是单个小写字母，常量是数字序列。\n\n待评估的测试套件：\n- $a+b+c+d+e+f+g$\n- $\\bigl((a\\ast b)\\ast((c\\ast d)\\ast e)\\bigr)$\n- $(a+b)\\ast(c+d+e)$\n- $\\bigl((a\\ast b)+(c\\ast d)+((e\\ast f)+g)\\bigr)$\n- $((((a))))$\n- $\\bigl(a+(b+(c+d))\\bigr)$\n- $\\bigl(((a\\ast b)\\ast c)\\ast(d\\ast(e\\ast(f\\ast(g\\ast h))))+i\\bigr)$\n- $(((a+b)\\ast(c+d))\\ast((e+f)\\ast(g+h)))$\n\n您必须计算和输出的内容：\n- 对于每个表达式，计算通过仅在如上定义的相同运算符的最大区域内应用结合律和交换律可达到的任何等价树的最小可能高度 $H_{\\min}$。\n- 最终输出必须是单行，包含所有按顺序排列的结果，形式为方括号内以逗号分隔的列表，例如，[$r_1$,$r_2$,$r_3$]，其中每个 $r_k$ 是一个整数。\n\n您的程序必须严格按此格式生成一行，不含空格，汇总与上述 8 个表达式对应的 8 个结果。",
            "solution": "用户提供的问题是有效的。这是一个在数据结构和算法领域中定义明确的问题，具体涉及表达式树的优化。约束和定义清晰，目标是在指定的转换规则下计算一个最小值，这是一个标准的算法任务。该问题依赖于结合律和交换律等基本数学属性，没有任何科学或逻辑上的缺陷。\n\n该问题要求计算算术表达式树的最小可能高度，其中仅允许在相同结合交换运算符（$+$ 或 $*$）的最大区域内进行重排。树的高度递归定义如下：叶节点的高度为 $H(\\ell)=1$，具有子节点 $L$ 和 $R$ 的内部节点的高度为 $H(\\mathrm{node}) = 1 + \\max\\{H(L), H(R)\\}$。\n\n问题的核心在于理解，对于运算符 $\\oplus \\in \\{+, *\\}$ 的任何最大连通区域，我们可以对其操作数进行重新排序和重新分组，以形成尽可能平衡的树，从而最小化其高度。这表明可以采用递归方法来计算最小高度。\n\n让我们定义一个函数 $H_{\\min}(T)$，它计算以节点 $T$ 为根的子树的最小可能高度。\n\n1.  **基准情况**：如果节点 $T$ 是一个叶节点（变量或常量），其结构无法改变。其高度固定为 $H_{\\min}(T) = 1$。\n\n2.  **递归步骤**：如果节点 $T$ 是一个带有运算符 $\\oplus$ 的内部节点，它属于 $\\oplus$ 节点的一个最大结合交换（AC）区域。第一步是识别这个整个区域的所有操作数。操作数是一个子树，其根要么是叶节点，要么是不同于 $\\oplus$ 的运算符。我们可以通过从 $T$ 开始遍历 $\\oplus$ 节点的连通分量，并收集构成该区域边界的子树来找到这些操作数，例如 $\\{O_1, O_2, \\dots, O_m\\}$。\n\n3.  对于每个操作数子树 $O_i$，我们必须递归地找到它自己的最小可能高度 $h_i = H_{\\min}(O_i)$。这是因为优化可以在每个操作数子树内独立应用。\n\n4.  在计算出 $m$ 个操作数的最小化高度集合 $\\{h_1, h_2, \\dots, h_m\\}$ 后，我们面临一个子问题：使用这 $m$ 个子树作为叶节点，用运算符 $\\oplus$ 进行操作，构建一个新的满二叉树，使得结果树的高度最小化。由两个高度为 $H_A$ 和 $H_B$ 的子树组合而成的树的高度是 $1 + \\max\\{H_A, H_B\\}$。为了最小化最终高度，我们应该采用一种类似于构建霍夫曼树的贪心策略。在每一步，我们合并两个具有最小高度的可用子树。重复此过程，直到只剩下一棵树。\n\n    算法如下：\n    a. 设 $S$ 为操作数高度的多重集 $\\{h_1, h_2, \\dots, h_m\\}$。\n    b. 当 $|S|  1$ 时：\n        i.  从 $S$ 中找到并移除两个最小的高度，设为 $h_a$ 和 $h_b$。\n        ii. 通过组合两个相应的子树形成一个新的子树。这个新子树的高度是 $h_{new} = 1 + \\max\\{h_a, h_b\\}$。\n        iii. 将 $h_{new}$ 添加到多重集 $S$ 中。\n    c. 当 $|S|=1$ 时，剩下的单个元素就是整个 AC 区域树的最小化高度。这就是 $H_{\\min}(T)$ 的值。\n\n为了避免对相同的子树重复计算高度，这个递归过程应该用记忆化来增强。\n\n让我们将此方法应用于测试套件中的一个示例：$(a+b)*(c+d+e)$。\n该树的根是运算符 $*$。这个 $*$ 的 AC 区域由单个节点组成。其操作数是子树 $O_1=(a+b)$ 和 $O_2=(c+d+e)$。我们需要找到它们的最小高度。\n\n-   对于 $O_1=(a+b)$：这是一个最大 `+` 区域，有两个叶操作数 $a$ 和 $b$。它们的高度是 $h_a=1$ 和 $h_b=1$。我们组合它们形成一棵高度为 $1+\\max\\{1,1\\}=2$ 的树。因此，$H_{\\min}(O_1)=2$。\n-   对于 $O_2=(c+d+e)$：这是一个最大 `+` 区域，有三个叶操作数 $c$、$d$ 和 $e$。它们的高度是 $\\{1,1,1\\}$。\n    -   组合两个最小的：$h_{new} = 1+\\max\\{1,1\\}=2$。高度集合变为 $\\{1,2\\}$。\n    -   组合剩下的两个：$h_{new} = 1+\\max\\{1,2\\}=3$。\n    -   因此，$H_{\\min}(O_2)=3$。\n\n现在，我们回到根运算符 $*$。其操作数的最小化高度为 $\\{2,3\\}$。组合它们得到的最终树高度为 $1+\\max\\{2,3\\}=4$。\n\n另一个例子：$a+b+c+d+e+f+g$。\n这是一个单一的最大 `+` 区域，有 $m=7$ 个叶操作数，每个高度为 $1$。高度集合为 $S=\\{1,1,1,1,1,1,1\\}$。\n1.  组合 $(1,1) \\to 2$。$S = \\{1,1,1,1,1,2\\}$。\n2.  组合 $(1,1) \\to 2$。$S = \\{1,1,1,2,2\\}$。\n3.  组合 $(1,1) \\to 2$。$S = \\{1,2,2,2\\}$。\n4.  组合 $(1,2) \\to 1+\\max\\{1,2\\}=3$。$S = \\{2,2,3\\}$。\n5.  组合 $(2,2) \\to 1+\\max\\{2,2\\}=3$。$S = \\{3,3\\}$。\n6.  组合 $(3,3) \\to 1+\\max\\{3,3\\}=4$。\n最小高度为 $4$。\n\n提供的 Python 代码实现了这一逻辑。它首先为固定的测试套件构建表达式树，然后对每棵树应用带记忆化的递归最小化算法。",
            "answer": "```python\nimport heapq\n\n# No numpy is necessary for this problem.\n\nclass Node:\n    \"\"\"Represents a node in the expression tree.\"\"\"\n\n    def __init__(self, value, left=None, right=None):\n        self.value = value  # Operator, variable, or constant\n        self.left = left\n        self.right = right\n        # Precompute string representation for memoization\n        self._str_repr = self._compute_str_repr()\n\n    def _compute_str_repr(self):\n        if self.left is None and self.right is None:\n            return str(self.value)\n        # Canonical representation is not needed as the algorithm handles reordering\n        return f\"({self.left._str_repr}{self.value}{self.right._str_repr})\"\n    \n    def __str__(self):\n        return self._str_repr\n\n    def __repr__(self):\n        return f\"Node({self.value})\"\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n    # Define leaves for reuse\n    a, b, c, d, e, f, g, h, i = [Node(ch) for ch in \"abcdefghi\"]\n\n    test_cases_trees = [\n        # 1. a+b+c+d+e+f+g (parsed as left-associative)\n        Node('+', Node('+', Node('+', Node('+', Node('+', Node('+', a, b), c), d), e), f), g),\n        # 2. ((a*b)*((c*d)*e))\n        Node('*', Node('*', a, b), Node('*', Node('*', c, d), e)),\n        # 3. (a+b)*(c+d+e) (c+d+e is (c+d)+e)\n        Node('*', Node('+', a, b), Node('+', Node('+', c, d), e)),\n        # 4. ((a*b)+(c*d)+((e*f)+g)) (parsed as left-associative for +)\n        Node('+', Node('+', Node('*', a, b), Node('*', c, d)), Node('+', Node('*', e, f), g)),\n        # 5. ((((a))))\n        a,\n        # 6. a+(b+(c+d))\n        Node('+', a, Node('+', b, Node('+', c, d))),\n        # 7. (((a*b)*c)*(d*(e*(f*(g*h)))))+i\n        Node('+', Node('*', Node('*', Node('*', a, b), c), Node('*', d, Node('*', e, Node('*', f, Node('*', g, h))))), i),\n        # 8. (((a+b)*(c+d))*((e+f)*(g+h)))\n        Node('*', Node('*', Node('+', a, b), Node('+', c, d)), Node('*', Node('+', e, f), Node('+', g, h)))\n    ]\n\n    memo = {}\n\n    def get_min_height(node):\n        \"\"\"\n        Recursively computes the minimum height of a tree/subtree.\n        \"\"\"\n        if node._str_repr in memo:\n            return memo[node._str_repr]\n\n        # Base case: leaf node\n        if node.left is None and node.right is None:\n            return 1\n\n        # Recursive step: internal node\n        op = node.value\n        \n        # 1. Collect all operands of the maximal associative-commutative region\n        operands = []\n        q = [node]\n        visited = {node._str_repr}\n\n        while q:\n            curr = q.pop(0)\n            \n            # Check left child\n            if curr.left.value == op:\n                if curr.left._str_repr not in visited:\n                    q.append(curr.left)\n                    visited.add(curr.left._str_repr)\n            else:\n                operands.append(curr.left)\n            \n            # Check right child\n            if curr.right.value == op:\n                if curr.right._str_repr not in visited:\n                    q.append(curr.right)\n                    visited.add(curr.right._str_repr)\n            else:\n                operands.append(curr.right)\n        \n        # 2. Recursively find the min height of each operand\n        operand_heights = [get_min_height(op_node) for op_node in operands]\n        \n        # 3. Combine heights using a greedy strategy (like Huffman coding)\n        heapq.heapify(operand_heights)\n        \n        if not operand_heights: # Should not happen for a valid tree\n            return 1\n        if len(operand_heights) == 1:\n            # This case can happen if the original tree was unary-like,\n            # which is not the case here (full binary trees).\n            result = operand_heights[0]\n        else:\n            while len(operand_heights) > 1:\n                h1 = heapq.heappop(operand_heights)\n                h2 = heapq.heappop(operand_heights)\n                new_h = 1 + max(h1, h2)\n                heapq.heappush(operand_heights, new_h)\n            result = operand_heights[0]\n\n        memo[node._str_repr] = result\n        return result\n\n    results = []\n    for tree in test_cases_trees:\n        # Clear memo for each top-level expression to be safe, though not strictly necessary\n        # with unique string representations.\n        memo.clear() \n        results.append(get_min_height(tree))\n\n    # Format and print the final output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}