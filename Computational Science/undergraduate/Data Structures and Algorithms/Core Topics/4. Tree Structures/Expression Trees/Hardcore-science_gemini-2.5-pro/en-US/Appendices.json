{
    "hands_on_practices": [
        {
            "introduction": "This exercise bridges the gap between the abstract structure of an expression tree and its concrete execution. You will translate a tree into a sequence of instructions for a stack-based virtual machine, a process that reveals how a postorder traversal naturally maps to the evaluation logic of Reverse Polish Notation (RPN). Mastering this translation () is fundamental to understanding how compilers and interpreters execute mathematical formulas.",
            "id": "3232522",
            "problem": "You are given rooted, ordered expression trees where each internal node is an operator and each leaf node is either a variable or a constant. The goal is to convert each expression tree into a flat sequence of integer-encoded instructions for a stack-based virtual machine that, when executed, evaluates the expression according to the semantics of arithmetic on real numbers. The semantics are defined from first principles using the structure of the tree and the behavior of a last-in-first-out stack.\n\nFundamental base definitions:\n- An expression tree is a finite rooted, ordered tree. Each leaf represents either a constant or a variable. Each unary operator node has exactly one child, and each binary operator node has exactly two children. Let the overall expression computed by a tree be denoted $E$, with evaluation defined recursively by the structure of the tree.\n- A stack-based virtual machine maintains a stack $S$ of values. Instructions act on $S$ deterministically.\n\nInstruction set and encoding:\n- Opcodes are integer codes with the following mapping:\n  - $0$: push constant, denoted $\\text{PUSH\\_CONST}$, which takes one immediate operand that is the constant value.\n  - $1$: push variable, denoted $\\text{PUSH\\_VAR}$, which takes one immediate operand that is the nonnegative integer index of the variable.\n  - $2$: addition, denoted $\\text{ADD}$, which pops the top two elements $r$ and $l$ from $S$ (where $r$ is the right operand and $l$ is the left operand), and pushes $l + r$.\n  - $3$: subtraction, denoted $\\text{SUB}$, which pops $r$ and $l$ and pushes $l - r$.\n  - $4$: multiplication, denoted $\\text{MUL}$, which pops $r$ and $l$ and pushes $l \\cdot r$.\n  - $5$: division, denoted $\\text{DIV}$, which pops $r$ and $l$ and pushes $l / r$.\n  - $6$: unary negation, denoted $\\text{NEG}$, which pops $a$ and pushes $-a$.\n  - $7$: exponentiation, denoted $\\text{POW}$, which pops $r$ and $l$ and pushes $l^r$.\n- The instruction stream is a flat list of integers. For $\\text{PUSH\\_CONST}$ and $\\text{PUSH\\_VAR}$, the opcode is immediately followed by the integer operand (the constant value or variable index, respectively). For all other opcodes, the instruction is just the single opcode integer.\n- Variables are identified by nonnegative integer indices. For example, variable $x$ may be bound to index $0$, variable $y$ to index $1$, and so on. Constants are integers; assume they fit within $64$-bit signed integer range.\n\nRequired compilation semantics:\n- The instruction sequence for an expression tree must be produced by a postorder traversal of the tree (children before parent), emitting instructions as follows:\n  - For a constant leaf with value $c$: emit $[0, c]$.\n  - For a variable leaf with index $i$: emit $[1, i]$.\n  - For a unary negation node with child $u$: emit the sequence for $u$, then emit $[6]$.\n  - For a binary operator node with left child $L$ and right child $R$ and operator $\\oplus \\in \\{+, -, \\cdot, /, ^\\}$: emit the sequence for $L$, then the sequence for $R$, then the opcode corresponding to $\\oplus$ (i.e., $[2]$ for $+$, $[3]$ for $-$, $[4]$ for $\\cdot$, $[5]$ for $/$, $[7]$ for $^$).\n\nScientific realism and generality:\n- The approach must be derived from the core definitions of expression trees and the deterministic stack semantics above, without relying on shortcuts beyond these definitions.\n- The compiled sequence must be correct for any expression composed from the supported operators under these semantics.\n\nTest suite:\n- Use the following five distinct expression trees and variable index bindings to test your compilation. For each case, produce the corresponding instruction stream as a list of integers, per the encoding above.\n  - Case $1$ (general binary composition): $(x + 3) \\cdot (y - 2)$ with $x$ mapped to index $0$ and $y$ mapped to index $1$.\n  - Case $2$ (unary and binary mix): $(-x) + 5$ with $x$ mapped to index $0$.\n  - Case $3$ (exponentiation and division): $\\dfrac{a^{3}}{b + 1}$ with $a$ mapped to index $2$ and $b$ mapped to index $3$.\n  - Case $4$ (single constant): $42$.\n  - Case $5$ (deep left-associative subtraction): (((x - 1) - 2) - 3) with $x$ mapped to index $0$.\n  - Case $6$ (double unary negation): $-(-(c))$ with $c$ mapped to index $5$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with no spaces anywhere. Each element should be the inner instruction list corresponding to one test case, in order from Case $1$ through Case $6$. For example, your output might look like `[[1,0,0,3,2],[1,1,0,2,3,4],...]` where each inner element is an integer. Ensure the exact format has no spaces.",
            "solution": "The problem statement has been validated and is deemed sound. It is scientifically grounded in the principles of computer science, specifically concerning data structures (expression trees) and compilation theory (stack machines and instruction encoding). The problem is well-posed, with a clear, objective, and complete set of definitions and constraints that allow for the derivation of a unique and verifiable solution for each test case.\n\nThe core principle for converting an expression tree into a sequence of instructions for a stack-based virtual machine is the postorder traversal algorithm. A postorder traversal visits the left child, then the right child (for binary nodes), and finally the parent node. This sequence, `Left-Right-Parent`, naturally corresponds to Reverse Polish Notation (RPN), or postfix notation, where operands appear before their operator. A stack-based machine is designed to evaluate RPN expressions efficiently: it pushes operands onto the stack and, upon encountering an operator, pops the required number of operands, performs the operation, and pushes the result back onto the stack.\n\nThe problem requires us to formalize this process into a compilation algorithm. Let us denote the function that generates the instruction sequence for a given subtree rooted at node $N$ as $\\text{Compile}(N)$. The output of $\\text{Compile}(N)$ is a flat list of integers representing machine instructions. The behavior of this function is defined recursively based on the type of the node $N$.\n\nThe instruction set is defined with integer opcodes:\n- $\\text{PUSH\\_CONST} = 0$: takes one operand (the constant value).\n- $\\text{PUSH\\_VAR} = 1$: takes one operand (the variable's index).\n- $\\text{ADD} = 2$, $\\text{SUB} = 3$, $\\text{MUL} = 4$, $\\text{DIV} = 5$: binary operators.\n- $\\text{NEG} = 6$: unary operator.\n- $\\text{POW} = 7$: binary operator.\n\nThe compilation algorithm is defined by the following rules:\n\n1.  **Base Case: Leaf Nodes**\n    - If the node $N$ is a constant leaf with value $c$, the machine must push this constant onto the stack. The instruction sequence is $[\\text{PUSH\\_CONST}, c]$. Therefore, $\\text{Compile}(N) = [0, c]$.\n    - If the node $N$ is a variable leaf with index $i$, the machine must push the value of this variable onto the stack. The instruction sequence is $[\\text{PUSH\\_VAR}, i]$. Therefore, $\\text{Compile}(N) = [1, i]$.\n\n2.  **Recursive Case: Unary Operator Node**\n    - If the node $N$ is a unary operator (e.g., negation, $\\text{NEG}$) with a single child $U$, a postorder traversal dictates that we first process the child subtree. The evaluation requires that the operand (the result of evaluating $U$) is on the stack before the operator is applied. Thus, we first generate the instructions for the child, then append the operator's opcode.\n    - $\\text{Compile}(N) = \\text{Compile}(U) \\oplus [\\text{OP}_{\\text{unary}}]$, where $\\oplus$ denotes list concatenation and $\\text{OP}_{\\text{unary}}$ is the opcode for the unary operator (e.g., $6$ for $\\text{NEG}$).\n\n3.  **Recursive Case: Binary Operator Node**\n    - If the node $N$ is a binary operator (e.g., addition, $+$) with a left child $L$ and a right child $R$, a postorder traversal visits $L$, then $R$, then $N$. For evaluation, the machine needs the left operand on the stack, followed by the right operand. Thus, we generate instructions for $L$, then for $R$, and finally append the operator's opcode.\n    - $\\text{Compile}(N) = \\text{Compile}(L) \\oplus \\text{Compile}(R) \\oplus [\\text{OP}_{\\text{binary}}]$, where $\\text{OP}_{\\text{binary}}$ is the opcode for the binary operator (e.g., $2$ for $\\text{ADD}$).\n\nLet us demonstrate this algorithm with Test Case $1$: the expression $(x + 3) \\cdot (y - 2)$, where variable $x$ has index $0$ and $y$ has index $1$.\n\nThe expression tree has a multiplication node ($\\cdot$) at its root.\n- The left child, $L$, is an addition node ($+$) for the subexpression $(x + 3)$.\n- The right child, $R$, is a subtraction node ($-$) for the subexpression $(y - 2)$.\n\nThe compilation proceeds as follows:\n$\\text{Compile}(\\cdot) = \\text{Compile}(+) \\oplus \\text{Compile}(-) \\oplus [4]$\n\n- To compute $\\text{Compile}(+)$ for $(x + 3)$:\n  - The left child is the variable $x$ (index $0$). $\\text{Compile}(x) = [1, 0]$.\n  - The right child is the constant $3$. $\\text{Compile}(3) = [0, 3]$.\n  - The opcode for $+$ is $2$.\n  - $\\text{Compile}(+) = \\text{Compile}(x) \\oplus \\text{Compile}(3) \\oplus [2] = [1, 0] \\oplus [0, 3] \\oplus [2] = [1, 0, 0, 3, 2]$.\n\n- To compute $\\text{Compile}(-)$ for $(y - 2)$:\n  - The left child is the variable $y$ (index $1$). $\\text{Compile}(y) = [1, 1]$.\n  - The right child is the constant $2$. $\\text{Compile}(2) = [0, 2]$.\n  - The opcode for $-$ is $3$.\n  - $\\text{Compile}(-) = \\text{Compile}(y) \\oplus \\text{Compile}(2) \\oplus [3] = [1, 1] \\oplus [0, 2] \\oplus [3] = [1, 1, 0, 2, 3]$.\n\n- Finally, we assemble the full sequence:\n  - $\\text{Compile}(\\cdot) = [1, 0, 0, 3, 2] \\oplus [1, 1, 0, 2, 3] \\oplus [4]$\n  - The resulting instruction stream is $[1, 0, 0, 3, 2, 1, 1, 0, 2, 3, 4]$.\n\nWhen executed, this sequence performs the following stack operations:\n1. PUSH\n2. PUSH\n3. ADD (stack now contains $x+3$)\n4. PUSH\n5. PUSH\n6. SUB (stack now contains $x+3$, $y-2$)\n7. MUL (stack now contains $(x+3) \\cdot (y-2)$)\n\nThis procedure is systematically applied to all provided test cases to generate their corresponding instruction streams. The logic is deterministic and directly derived from the fundamental definitions of expression trees and stack-based computation.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\n\ndef solve():\n    \"\"\"\n    Solves the problem of compiling expression trees into a flat sequence\n    of integer-encoded instructions for a stack-based virtual machine.\n    \"\"\"\n\n    # Opcodes as defined in the problem statement.\n    OP_PUSH_CONST = 0\n    OP_PUSH_VAR = 1\n    OP_ADD = 2\n    OP_SUB = 3\n    OP_MUL = 4\n    OP_DIV = 5\n    OP_NEG = 6\n    OP_POW = 7\n\n    # Mapping from operator symbols to opcodes for convenience.\n    OPCODE_MAP = {\n        '+': OP_ADD,\n        '-': OP_SUB,\n        '*': OP_MUL,\n        '/': OP_DIV,\n        'NEG': OP_NEG,\n        '^': OP_POW,\n    }\n\n    def compile_tree(node):\n        \"\"\"\n        Recursively compiles an expression tree node into an instruction list\n        based on a postorder traversal.\n        The tree structure is represented using nested dictionaries.\n        \"\"\"\n        # Case 1: Binary operator node\n        if 'op' in node and 'L' in node and 'R' in node:\n            left_instr = compile_tree(node['L'])\n            right_instr = compile_tree(node['R'])\n            op_code = OPCODE_MAP[node['op']]\n            return left_instr + right_instr + [op_code]\n        \n        # Case 2: Unary operator node\n        elif 'op' in node and 'arg' in node:\n            arg_instr = compile_tree(node['arg'])\n            op_code = OPCODE_MAP[node['op']]\n            return arg_instr + [op_code]\n            \n        # Case 3: Variable leaf node\n        elif 'var' in node:\n            return [OP_PUSH_VAR, node['var']]\n            \n        # Case 4: Constant leaf node\n        elif 'const' in node:\n            return [OP_PUSH_CONST, node['const']]\n            \n        else:\n            # This should not be reached with well-formed trees.\n            raise ValueError(\"Invalid node format in expression tree\")\n\n    # Define the six test cases using the nested dictionary representation.\n    test_cases = [\n        # Case 1: (x + 3) * (y - 2) with x=0, y=1\n        {'op': '*', 'L': {'op': '+', 'L': {'var': 0}, 'R': {'const': 3}}, 'R': {'op': '-', 'L': {'var': 1}, 'R': {'const': 2}}},\n        \n        # Case 2: (-x) + 5 with x=0\n        {'op': '+', 'L': {'op': 'NEG', 'arg': {'var': 0}}, 'R': {'const': 5}},\n        \n        # Case 3: a^3 / (b + 1) with a=2, b=3\n        {'op': '/', 'L': {'op': '^', 'L': {'var': 2}, 'R': {'const': 3}}, 'R': {'op': '+', 'L': {'var': 3}, 'R': {'const': 1}}},\n        \n        # Case 4: 42\n        {'const': 42},\n        \n        # Case 5: (((x - 1) - 2) - 3) with x=0\n        {'op': '-', 'L': {'op': '-', 'L': {'op': '-', 'L': {'var': 0}, 'R': {'const': 1}}, 'R': {'const': 2}}, 'R': {'const': 3}},\n        \n        # Case 6: -(-(c)) with c=5\n        {'op': 'NEG', 'arg': {'op': 'NEG', 'arg': {'var': 5}}},\n    ]\n\n    results = []\n    for tree in test_cases:\n        instruction_list = compile_tree(tree)\n        results.append(instruction_list)\n\n    # Format the output exactly as specified: [[i_1,1,...],[i_2,1,...],...] with no spaces.\n    # 1. Convert each inner list of integers to a string like '[1,2,3]'.\n    # 2. Join these strings with commas.\n    # 3. Enclose the final result in brackets.\n    result_strings = []\n    for res_list in results:\n        # Create string representation of inner list without spaces\n        inner_str = '[' + ','.join(map(str, res_list)) + ']'\n        result_strings.append(inner_str)\n    \n    final_output = '[' + ','.join(result_strings) + ']'\n    \n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "While expression trees provide an unambiguous internal representation, we often need to convert them back into a linear, infix format for human readers. This practice challenges you to develop a \"pretty printer\" that inserts the minimum number of parentheses necessary to preserve the original order of operations. Successfully completing this task () requires a deep understanding of operator precedence and associativity, the very rules that make expression trees so powerful.",
            "id": "3232525",
            "problem": "Implement a program that, given a set of expression trees, produces an infix string for each tree with the minimum number of parentheses required so that, under conventional parsing rules for operator precedence and associativity, the original tree is reconstructed uniquely and exactly. The output to be printed must be the count of parenthesis pairs used for each tree, aggregated in a single line as a comma-separated list enclosed in square brackets.\n\nAn expression tree is a rooted, ordered tree in which each internal node is an operator and each leaf node is either a variable or a constant. The canonical operators and their conventional parsing rules for this problem are defined as follows:\n- Binary operators: $+$, $-$, $\\times$, $\\div$, and $^$.\n- Unary prefix operator: $-$ (unary negation).\n- Precedence (from highest to lowest): $^$ has precedence level $4$, unary $-$ has precedence level $3$, $\\times$ and $\\div$ have precedence level $2$, and $+$ and $-$ have precedence level $1$.\n- Associativity: $^$ is right-associative, $+$, $-$, $\\times$, and $\\div$ are left-associative. Unary $-$ applies to its single operand before any binary operator of lower precedence in the usual manner.\n\nThe fundamental base of this task is the definition of an expression tree together with the well-tested parsing facts about operator precedence and associativity: when parsing infix notation, operators of higher precedence bind tighter than operators of lower precedence, and when precedence is equal, associativity dictates grouping ($^$ groups to the right; $+$, $-$, $\\times$, and $\\div$ group to the left). Parentheses override these default grouping rules locally. Your goal is to derive, from these foundational definitions, an algorithm that decides exactly when parentheses are necessary around subexpressions to ensure that the printed infix string parses back to the original tree.\n\nYour program must internally construct and pretty-print the following test suite of expression trees. Each tree is specified in a structural form using node constructors with variables and constants shown in LaTeX for readability, but your program should represent them in a standard tree structure. For clarity, let $\\operatorname{Bin}(op, L, R)$ denote a binary node with operator $op$ and left and right children $L$ and $R$, and let $\\operatorname{Un}(op, C)$ denote a unary node with operator $op$ and child $C$. Let $\\operatorname{Var}(name)$ and $\\operatorname{Const}(value)$ denote leaf nodes.\n\nTest Suite (covering happy path, associativity and precedence boundaries, unary operator interactions, and nested edge cases):\n1. $\\operatorname{Var}(x)$\n2. $\\operatorname{Bin}(+, \\operatorname{Var}(a), \\operatorname{Bin}(+, \\operatorname{Var}(b), \\operatorname{Var}(c)))$\n3. $\\operatorname{Bin}(-, \\operatorname{Var}(a), \\operatorname{Bin}(-, \\operatorname{Var}(b), \\operatorname{Var}(c)))$\n4. $\\operatorname{Bin}(\\div, \\operatorname{Var}(a), \\operatorname{Bin}(+, \\operatorname{Var}(b), \\operatorname{Var}(c)))$\n5. $\\operatorname{Bin}(^, \\operatorname{Bin}(^, \\operatorname{Var}(a), \\operatorname{Var}(b)), \\operatorname{Var}(c))$\n6. $\\operatorname{Bin}(^, \\operatorname{Var}(a), \\operatorname{Bin}(^, \\operatorname{Var}(b), \\operatorname{Var}(c)))$\n7. $\\operatorname{Un}(-, \\operatorname{Bin}(\\times, \\operatorname{Bin}(+, \\operatorname{Var}(a), \\operatorname{Var}(b)), \\operatorname{Var}(c)))$\n8. $\\operatorname{Bin}(^, \\operatorname{Un}(-, \\operatorname{Var}(a)), \\operatorname{Un}(-, \\operatorname{Var}(b)))$\n9. $\\operatorname{Bin}(+, \\operatorname{Var}(a), \\operatorname{Bin}(\\times, \\operatorname{Var}(b), \\operatorname{Var}(c)))$\n10. $\\operatorname{Un}(-, \\operatorname{Bin}(^, \\operatorname{Var}(a), \\operatorname{Var}(b)))$\n\nYour program must implement a pretty printer that decides, for each node, whether to wrap its child expressions in parentheses according to the precedence and associativity rules, such that re-parsing the printed string using those same rules reconstructs the original expression tree exactly. After generating the pretty-printed string for each test case, your program should compute the integer count of parenthesis pairs used in that string (every occurrence of the character \"(\" must match a corresponding \")\" and counts as one pair). This count is the result for the corresponding test case.\n\nFinal Output Format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, `[r_1,r_2,...,r_10]`, where each $r_i$ is the integer count of parenthesis pairs for test case $i$.\n\nThere are no physical units involved. Angles do not appear. Percentages do not appear. The answers are integers.\n\nEnsure scientific realism by adhering to the fundamental definitions and facts stated above. The algorithm must not rely on any shortcuts that presuppose the final decision rules; rather, derive the decision of when to add parentheses from the precedence and associativity properties of the operators.",
            "solution": "The problem is to determine the minimum number of parenthesis pairs required to represent a given expression tree as an infix string, such that parsing the string according to standard operator precedence and associativity rules reconstructs the original tree.\n\n### Step 1: Problem Formalization and Principle of Minimality\n\nAn expression tree's structure explicitly defines the order of operations. An infix string, however, relies on parsing rules to determine this order. Parentheses serve one purpose: to override the default parsing rules where they conflict with the tree's structure. The principle of minimality dictates that we should only insert parentheses when their absence would lead to a different parse tree.\n\nThe decision to parenthesize a subexpression depends on the interplay between the operator at the root of the subexpression (the \"child\" operator) and the operator of its parent node in the tree (the \"parent\" operator).\n\nLet's define the operator properties as given:\n- **Precedence**: A mapping from an operator to an integer, where a higher value indicates higher precedence.\n  - $P(^) = 4$\n  - $P(\\text{unary}-) = 3$\n  - $P(\\times), P(\\div) = 2$\n  - $P(+), P(-) = 1$\n- **Associativity**: A rule for grouping operators of equal precedence.\n  - Right-associative (`R`): $^$ (e.g., $a \\wedge b \\wedge c \\equiv a \\wedge (b \\wedge c)$)\n  - Left-associative (`L`): $+, -, \\times, \\div$ (e.g., $a - b - c \\equiv (a - b) - c$)\n\n### Step 2: Derivation of Parenthesization Rules\n\nWe can derive the conditions requiring parentheses by analyzing cases where the default parsing would alter the tree structure. We consider a node $N$ in the tree, which corresponds to a subexpression. Let $op_N$ be the operator at node $N$, and let $P$ be its parent node with operator $op_P$.\n\n#### Rule 1: Precedence Conflict\nIf the operator $op_N$ has a lower precedence than its parent operator $op_P$, the operation at $N$ must be enclosed in parentheses. Without them, the high-precedence parent operator $op_P$ would bind to one of $N$'s immediate operands, restructuring the tree.\n- **Condition**: Add parentheses if $P(op_N)  P(op_P)$.\n- **Example**: For the tree `$\\operatorname{Bin}(\\div, \\operatorname{Var}(a), \\operatorname{Bin}(+, \\operatorname{Var}(b), \\operatorname{Var}(c)))$`, representing $a / (b+c)$, the parent operator is $\\div$ ($P=2$) and the child operator is $+$ ($P=1$). Since $P(+)  P(\\div)$, the subexpression $(b+c)$ requires parentheses. Omitting them, $a / b + c$, would parse as $(a/b)+c$.\n\n#### Rule 2: Associativity Conflict\nIf $op_N$ and $op_P$ have the same precedence, associativity rules determine the default grouping. Parentheses are needed if the tree's structure contradicts this default grouping.\n\n- **Case 2a: Left-Associative Operators** ($+, -, \\times, \\div$)\n  - These operators group from left to right. The structure $(L \\, op \\, M) \\, op \\, R$ is the default.\n  - If a node $N$ with operator $op_N$ is the *right* child of a node $P$ with a left-associative operator $op_P$ of the same precedence, parentheses are required.\n  - **Condition**: Add parentheses if $P(op_N) = P(op_P)$, $op_P$ is left-associative, and $N$ is the right child.\n  - **Example**: For `$\\operatorname{Bin}(-, \\operatorname{Var}(a), \\operatorname{Bin}(-, \\operatorname{Var}(b), \\operatorname{Var}(c)))$`, representing $a - (b-c)$, both operators are $-$, which is left-associative. The subexpression $(b-c)$ is the right child. Omitting parentheses yields $a-b-c$, which parses as $(a-b)-c$, a different tree.\n\n- **Case 2b: Right-Associative Operators** ($^$)\n  - This operator groups from right to left. The structure $L \\, op \\, (M \\, op \\, R)$ is the default.\n  - If a node $N$ with operator $op_N$ is the *left* child of a node $P$ with a right-associative operator $op_P$ of the same precedence, parentheses are required.\n  - **Condition**: Add parentheses if $P(op_N) = P(op_P)$, $op_P$ is right-associative, and $N$ is the left child.\n  - **Example**: For `$\\operatorname{Bin}(^, \\operatorname{Bin}(^, \\operatorname{Var}(a), \\operatorname{Var}(b)), \\operatorname{Var}(c))$`, representing $(a^b)^c$, both operators are $^$, which is right-associative. The subexpression $(a^b)$ is the left child. Omitting parentheses yields $a^b^c$, which parses as $a^(b^c)$.\n\n#### Rule 3: Special Cases for Unary Minus ($-$)\n\nThe unary minus operator introduces unique scenarios.\n\n- **Case 3a: Unary subexpression as a child of a binary operator.**\n  - If `$\\operatorname{Un}(-, C)$` is the *left* child of a binary operator $op_P$ and $P(\\text{unary}-)  P(op_P)$, parentheses are needed.\n  - **Example**: `$\\operatorname{Bin}(^, \\operatorname{Un}(-, \\operatorname{Var}(a)), \\operatorname{Var}(b))$` represents $(-a)^b$. Here, $P(\\text{unary}-) = 3$ and $P(^) = 4$. Without parentheses, the string `-a^b` would be parsed as `-(a^b)` because $^$ has higher precedence. Thus, parentheses are mandatory: `(-a)^b`.\n\n  - If `$\\operatorname{Un}(-, C)$` is the *right* child of a binary operator $op_P$, parentheses are generally not needed, as in $a \\times -b$, which is unambiguously $a \\times (-b)$.\n  - **Exception**: If the parent operator $op_P$ is itself a binary minus, parentheses are required to avoid ambiguity.\n  - **Example**: For an expression tree representing $a - (-b)$, the string $a - -b$ is syntactically invalid or ambiguous in many contexts. Parentheses are necessary: $a - (-b)$.\n\n- **Case 3b: Binary subexpression as a child of a unary minus.**\n  - If a node $N$ with operator $op_N$ is the child of `$\\operatorname{Un}(-, ...)$`, the rule is simpler: If $P(op_N)  P(\\text{unary}-)$, parentheses are needed.\n  - **Example**: `$\\operatorname{Un}(-, \\operatorname{Bin}(+, \\operatorname{Var}(a), \\operatorname{Var}(b)))$` represents $-(a+b)$. Since $P(+)  P(\\text{unary}-)$, parentheses are needed. `-a+b` would parse as `(-a)+b`.\n\n### Step 3: Algorithmic Implementation\n\nThese derived rules can be implemented in a recursive function that traverses the expression tree. The function, `get_paren_count(node, parent_op, is_right_child)`, calculates the number of parenthesis pairs for the subtree rooted at `node`.\n\n1.  **Base Case**: If `node` is a leaf (`Var` or `Const`), it requires $0$ parentheses.\n2.  **Recursive Step**:\n    a. Recursively call `get_paren_count` for all children of `node`, passing `node`'s operator as the new `parent_op`. Sum the counts returned by these calls.\n    b. Apply the derived rules to determine if the subexpression for `node` itself needs to be parenthesized, based on `node.op`, `parent_op`, and its position (`is_right_child`).\n    c. If parentheses are needed, add $1$ to the total count.\n    d. Return the total count.\n\nThis algorithm systematically applies the fundamental principles of operator parsing to count the minimum required parentheses, ensuring the generated infix string is both correct and concise.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\n\n# --- Data Structures for Expression Trees ---\n\nclass Node:\n    \"\"\"Base class for a node in an expression tree.\"\"\"\n    def __init__(self, op):\n        self.op = op\n\nclass Var(Node):\n    \"\"\"Represents a variable or constant (a leaf node).\"\"\"\n    def __init__(self, name):\n        super().__init__(name)\n    def __repr__(self):\n        return f\"Var({self.op})\"\n\nclass UnaryOp(Node):\n    \"\"\"Represents a unary operation.\"\"\"\n    def __init__(self, op, child):\n        super().__init__(op)\n        self.child = child\n    def __repr__(self):\n        return f\"UnaryOp({self.op}, {self.child})\"\n\nclass BinaryOp(Node):\n    \"\"\"Represents a binary operation.\"\"\"\n    def __init__(self, op, left, right):\n        super().__init__(op)\n        self.left = left\n        self.right = right\n    def __repr__(self):\n        return f\"BinaryOp({self.op}, {self.left}, {self.right})\"\n\n# --- Problem Definition: Operators and Rules ---\n\nOP_INFO = {\n    # Operator: (precedence, associativity)\n    '^': (4, 'R'),\n    'u-': (3, 'R'), # Unary minus\n    '*': (2, 'L'),\n    '/': (2, 'L'),\n    'x': (2, 'L'), # For representation of the multiplication symbol\n    '÷': (2, 'L'), # For representation of the division symbol\n    '+': (1, 'L'),\n    '-': (1, 'L'), # Binary minus\n}\n\ndef solve():\n    \"\"\"\n    Main function to construct test cases and compute parenthesis counts.\n    \"\"\"\n    # --- Test Suite Construction ---\n    \n    # Aliases for brevity in test case definitions\n    Bin = BinaryOp\n    Un = UnaryOp\n    V = Var\n    \n    # Test cases defined as per the problem statement's structural form.\n    # LaTeX representations: +, -, ×, ÷, ^\n    test_cases = [\n        # 1. Var(x)\n        V('x'),\n        # 2. Bin(+, Var(a), Bin(+, Var(b), Var(c)))\n        Bin('+', V('a'), Bin('+', V('b'), V('c'))),\n        # 3. Bin(-, Var(a), Bin(-, Var(b), Var(c)))\n        Bin('-', V('a'), Bin('-', V('b'), V('c'))),\n        # 4. Bin(÷, Var(a), Bin(+, Var(b), Var(c)))\n        Bin('÷', V('a'), Bin('+', V('b'), V('c'))),\n        # 5. Bin(^, Bin(^, Var(a), Var(b)), Var(c))\n        Bin('^', Bin('^', V('a'), V('b')), V('c')),\n        # 6. Bin(^, Var(a), Bin(^, Var(b), Var(c)))\n        Bin('^', V('a'), Bin('^', V('b'), V('c'))),\n        # 7. Un(-, Bin(×, Bin(+, Var(a), Var(b)), Var(c)))\n        Un('u-', Bin('x', Bin('+', V('a'), V('b')), V('c'))),\n        # 8. Bin(^, Un(-, Var(a)), Un(-, Var(b)))\n        Bin('^', Un('u-', V('a')), Un('u-', V('b'))),\n        # 9. Bin(+, Var(a), Bin(×, Var(b), Var(c)))\n        Bin('+', V('a'), Bin('x', V('b'), V('c'))),\n        # 10. Un(-, Bin(^, Var(a), Var(b)))\n        Un('u-', Bin('^', V('a'), V('b'))),\n    ]\n\n    results = []\n    for tree in test_cases:\n        count = get_paren_count(tree, parent_op=None, is_right_child=False)\n        results.append(count)\n        \n    print(f\"[{','.join(map(str, results))}]\")\n\ndef needs_parens(node, parent_op, is_right_child):\n    \"\"\"\n    Determines if a subexpression rooted at `node` needs parentheses.\n    This function implements the derived rules for parenthesization.\n    \"\"\"\n    if parent_op is None:\n        return False\n\n    node_op = node.op\n    p_node, assoc_node = OP_INFO[node_op]\n    p_parent, assoc_parent = OP_INFO[parent_op]\n\n    # Rule 1: Precedence conflict\n    if p_node  p_parent:\n        return True\n\n    # Rule 2: Associativity conflict for binary operators\n    if isinstance(node, BinaryOp) and p_node == p_parent:\n        if assoc_parent == 'L' and is_right_child:\n            return True\n        if assoc_parent == 'R' and not is_right_child:\n            return True\n\n    # Rule 3: Special cases for UnaryOp children\n    if isinstance(node, UnaryOp):\n        # Case `(-a)^b`: precedence of u- is less than ^\n        if not is_right_child and p_node  p_parent:\n            return True\n        # Case `a - (-b)`\n        if is_right_child and parent_op == '-':\n            return True\n            \n    return False\n\ndef get_paren_count(node, parent_op, is_right_child):\n    \"\"\"\n    Recursively traverses the tree to count the minimum required parenthesis pairs.\n    \"\"\"\n    if isinstance(node, Var):\n        return 0\n\n    count = 0\n    if isinstance(node, UnaryOp):\n        # Recurse on the single child\n        # The child's position is irrelevant for a unary parent\n        count += get_paren_count(node.child, node.op, False)\n    elif isinstance(node, BinaryOp):\n        # Recurse on left and right children\n        count += get_paren_count(node.left, node.op, False)\n        count += get_paren_count(node.right, node.op, True)\n\n    # Check if the current node's subexpression needs parentheses\n    if needs_parens(node, parent_op, is_right_child):\n        count += 1\n        \n    return count\n\n# Execute the solution\nsolve()\n\n```"
        },
        {
            "introduction": "Not all trees that represent the same mathematical expression are structurally identical. This advanced practice explores tree transformation, where you will apply algebraic properties like associativity and commutativity to find an equivalent tree with the minimum possible height. This optimization () is crucial in compiler design for reordering computations to maximize performance, especially in parallel processing environments where a shorter tree can mean a faster result.",
            "id": "3232681",
            "problem": "You are given arithmetic expression trees where each internal node is a binary operator and each leaf is either a variable or a nonnegative integer constant. Your task is to compute, for each given expression tree, the minimum possible height of an equivalent tree when you are allowed to change only the grouping and the ordering of operands inside any maximal region of identical operators, using associativity and commutativity, but without changing operators, introducing or removing operands, applying distributivity, or performing any algebraic simplifications.\n\nDefinitions and constraints:\n- An expression tree is a full binary tree where internal nodes are labeled by operators from the set $\\{+,\\ast\\}$ and leaves are labeled by variables (single lowercase letters) or nonnegative integer constants.\n- The height function $H(\\cdot)$ is defined recursively on trees as follows: for a leaf $\\ell$, $H(\\ell)=1$; for an internal node with left subtree $L$ and right subtree $R$, $H(\\mathrm{node})=1+\\max\\{H(L),H(R)\\}$.\n- You may use only the associativity and commutativity of addition and multiplication. That is, $a+b=b+a$, $a+(b+c)=(a+b)+c$, $a\\ast b=b\\ast a$, and $a\\ast(b\\ast c)=(a\\ast b)\\ast c$. You are not allowed to apply distributivity $a\\ast(b+c)=a\\ast b + a\\ast c$ nor any identity or annihilator simplifications (for example, you may not delete $0$ from a sum nor $1$ from a product).\n- A maximal associative-commutative region for an operator $\\oplus\\in\\{+,\\ast\\}$ is the maximal connected subgraph consisting only of $\\oplus$-labeled internal nodes. Within such a region, you may reorder and re-associate operands arbitrarily but must keep the operator $\\oplus$.\n- For each maximal associative-commutative region rooted at operator $\\oplus$ with operand subtrees having heights $h_1,h_2,\\dots,h_m$, the only effect of rearrangement is to choose a binary full tree shape and ordering over these $m$ operand subtrees to minimize the resulting height.\n\nInput model for this task:\n- You do not read any input. Instead, your program must internally evaluate a fixed test suite specified below. Each expression is given as an ASCII string using the grammar in which $+$ has lower precedence than $\\ast$, parentheses $($ and $)$ may appear, variables are single lowercase letters, and constants are sequences of digits.\n\nTest suite to evaluate:\n- $a+b+c+d+e+f+g$\n- $\\bigl((a\\ast b)\\ast((c\\ast d)\\ast e)\\bigr)$\n- $(a+b)\\ast(c+d+e)$\n- $\\bigl((a\\ast b)+(c\\ast d)+((e\\ast f)+g)\\bigr)$\n- $((((a))))$\n- $\\bigl(a+(b+(c+d))\\bigr)$\n- $\\bigl(((a\\ast b)\\ast c)\\ast(d\\ast(e\\ast(f\\ast(g\\ast h))))+i\\bigr)$\n- $(((a+b)\\ast(c+d))\\ast((e+f)\\ast(g+h)))$\n\nWhat you must compute and output:\n- For each expression, compute the minimum possible height $H_{\\min}$ of any equivalent tree reachable by applying only associativity and commutativity within maximal regions of identical operators as defined above.\n- The final output must be a single line containing all results in order, as a comma-separated list enclosed in square brackets, for example, `[r_1,r_2,r_3]`, where each $r_k$ is an integer.\n\nYour program must produce exactly one line in this format, with no spaces, aggregating the $8$ results corresponding to the $8$ expressions above.",
            "solution": "The user-provided problem is valid. It is a well-posed problem in the domain of data structures and algorithms, specifically concerning the optimization of expression trees. The constraints and definitions are clear, and the objective is to compute a minimum value under specified transformation rules, which is a standard algorithmic task. The problem relies on the fundamental mathematical properties of associativity and commutativity and is free from any scientific or logical flaws.\n\nThe problem asks for the minimum possible height of an arithmetic expression tree, where rearrangements are permitted only within maximal regions of identical associative and commutative operators ($+$ or $*$). The height of a tree is defined recursively: a leaf has height $H(\\ell)=1$, and an internal node with children $L$ and $R$ has height $H(\\mathrm{node}) = 1 + \\max\\{H(L), H(R)\\}$.\n\nThe core of the problem lies in understanding that for any maximal connected region of an operator $\\oplus \\in \\{+, *\\}$, we can reorder and regroup its operands to form the most balanced tree possible, thereby minimizing its height. This suggests a recursive approach to compute the minimum height.\n\nLet us define a function, $H_{\\min}(T)$, that computes the minimum possible height for a subtree rooted at node $T$.\n\n1.  **Base Case**: If the node $T$ is a leaf (a variable or a constant), its structure cannot be changed. Its height is fixed at $H_{\\min}(T) = 1$.\n\n2.  **Recursive Step**: If the node $T$ is an internal node with operator $\\oplus$, it belongs to a maximal associative-commutative (AC) region of $\\oplus$ nodes. The first step is to identify all the operands of this entire region. An operand is a subtree whose root is either a leaf or an operator different from $\\oplus$. We can find these operands, say $\\{O_1, O_2, \\dots, O_m\\}$, by traversing the connected component of $\\oplus$ nodes starting from $T$ and collecting the subtrees that form the boundary of this region.\n\n3.  For each of these operand subtrees $O_i$, we must recursively find its own minimum possible height, $h_i = H_{\\min}(O_i)$. This is because optimizations can be applied independently within each operand subtree.\n\n4.  After computing the set of minimized heights $\\{h_1, h_2, \\dots, h_m\\}$ for the $m$ operands, we face the subproblem of constructing a new full binary tree using these $m$ subtrees as leaves, operated on by $\\oplus$, such that the height of the resulting tree is minimized. The height of a tree formed by combining two subtrees of heights $H_A$ and $H_B$ is $1 + \\max\\{H_A, H_B\\}$. To minimize the final height, we should employ a greedy strategy analogous to the construction of a Huffman tree. At each step, we combine the two available subtrees with the smallest heights. This process is repeated until only one tree remains.\n\n    The algorithm is as follows:\n    a. Let $S$ be the multiset of operand heights $\\{h_1, h_2, \\dots, h_m\\}$.\n    b. While $|S|  1$:\n        i.  Find and remove the two smallest heights from $S$, let them be $h_a$ and $h_b$.\n        ii. Form a new subtree by combining the two corresponding subtrees. The height of this new subtree is $h_{new} = 1 + \\max\\{h_a, h_b\\}$.\n        iii. Add $h_{new}$ to the multiset $S$.\n    c. When $|S|=1$, the single remaining element is the minimized height of the tree for the entire AC region. This is the value of $H_{\\min}(T)$.\n\nTo avoid recomputing heights for identical subtrees, this recursive process should be augmented with memoization.\n\nLet's apply this methodology to an example from the test suite: $(a+b)*(c+d+e)$.\nThe root of the tree is the operator $*$. This AC region for $*$ consists of a single node. Its operands are the subtrees $O_1=(a+b)$ and $O_2=(c+d+e)$. We need to find their minimal heights.\n\n-   For $O_1=(a+b)$: This is a maximal `+` region with two leaf operands, $a$ and $b$. Their heights are $h_a=1$ and $h_b=1$. We combine them to form a tree of height $1+\\max\\{1,1\\}=2$. Thus, $H_{\\min}(O_1)=2$.\n-   For $O_2=(c+d+e)$: This is a maximal `+` region with three leaf operands, $c$, $d$, and $e$. Their heights are $\\{1,1,1\\}$.\n    -   Combine the two smallest: $h_{new} = 1+\\max\\{1,1\\}=2$. The set of heights becomes $\\{1,2\\}$.\n    -   Combine the remaining two: $h_{new} = 1+\\max\\{1,2\\}=3$.\n    -   Thus, $H_{\\min}(O_2)=3$.\n\nNow, we return to the root operator $*$. Its operands have minimized heights $\\{2,3\\}$. Combining them gives a final tree of height $1+\\max\\{2,3\\}=4$.\n\nAnother example: $a+b+c+d+e+f+g$.\nThis is a single maximal `+` region with $m=7$ leaf operands, each of height $1$. The set of heights is $S=\\{1,1,1,1,1,1,1\\}$.\n1.  Combine $(1,1) \\to 2$. $S = \\{1,1,1,1,1,2\\}$.\n2.  Combine $(1,1) \\to 2$. $S = \\{1,1,1,2,2\\}$.\n3.  Combine $(1,1) \\to 2$. $S = \\{1,2,2,2\\}$.\n4.  Combine $(1,2) \\to 1+\\max\\{1,2\\}=3$. $S = \\{2,2,3\\}$.\n5.  Combine $(2,2) \\to 1+\\max\\{2,2\\}=3$. $S = \\{3,3\\}$.\n6.  Combine $(3,3) \\to 1+\\max\\{3,3\\}=4$.\nThe minimum height is $4$.\n\nThe provided Python code implements this logic. It first constructs the expression trees for the fixed test suite, then applies the recursive minimization algorithm with memoization to each tree.",
            "answer": "```python\nimport heapq\n\n# No numpy is necessary for this problem.\n\nclass Node:\n    \"\"\"Represents a node in the expression tree.\"\"\"\n\n    def __init__(self, value, left=None, right=None):\n        self.value = value  # Operator, variable, or constant\n        self.left = left\n        self.right = right\n        # Precompute string representation for memoization\n        self._str_repr = self._compute_str_repr()\n\n    def _compute_str_repr(self):\n        if self.left is None and self.right is None:\n            return str(self.value)\n        # Canonical representation is not needed as the algorithm handles reordering\n        return f\"({self.left._str_repr}{self.value}{self.right._str_repr})\"\n    \n    def __str__(self):\n        return self._str_repr\n\n    def __repr__(self):\n        return f\"Node({self.value})\"\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n    # Define leaves for reuse\n    a, b, c, d, e, f, g, h, i = [Node(ch) for ch in \"abcdefghi\"]\n\n    test_cases_trees = [\n        # 1. a+b+c+d+e+f+g (parsed as left-associative)\n        Node('+', Node('+', Node('+', Node('+', Node('+', Node('+', a, b), c), d), e), f), g),\n        # 2. ((a*b)*((c*d)*e))\n        Node('*', Node('*', a, b), Node('*', Node('*', c, d), e)),\n        # 3. (a+b)*(c+d+e) (c+d+e is (c+d)+e)\n        Node('*', Node('+', a, b), Node('+', Node('+', c, d), e)),\n        # 4. ((a*b)+(c*d)+((e*f)+g)) (parsed as left-associative for +)\n        Node('+', Node('+', Node('*', a, b), Node('*', c, d)), Node('+', Node('*', e, f), g)),\n        # 5. ((((a))))\n        a,\n        # 6. a+(b+(c+d))\n        Node('+', a, Node('+', b, Node('+', c, d))),\n        # 7. (((a*b)*c)*(d*(e*(f*(g*h)))))+i\n        Node('+', Node('*', Node('*', Node('*', a, b), c), Node('*', d, Node('*', e, Node('*', f, Node('*', g, h))))), i),\n        # 8. (((a+b)*(c+d))*((e+f)*(g+h)))\n        Node('*', Node('*', Node('+', a, b), Node('+', c, d)), Node('*', Node('+', e, f), Node('+', g, h)))\n    ]\n\n    memo = {}\n\n    def get_min_height(node):\n        \"\"\"\n        Recursively computes the minimum height of a tree/subtree.\n        \"\"\"\n        if node._str_repr in memo:\n            return memo[node._str_repr]\n\n        # Base case: leaf node\n        if node.left is None and node.right is None:\n            return 1\n\n        # Recursive step: internal node\n        op = node.value\n        \n        # 1. Collect all operands of the maximal associative-commutative region\n        operands = []\n        q = [node]\n        visited = {node._str_repr}\n\n        while q:\n            curr = q.pop(0)\n            \n            # Check left child\n            if curr.left.value == op:\n                if curr.left._str_repr not in visited:\n                    q.append(curr.left)\n                    visited.add(curr.left._str_repr)\n            else:\n                operands.append(curr.left)\n            \n            # Check right child\n            if curr.right.value == op:\n                if curr.right._str_repr not in visited:\n                    q.append(curr.right)\n                    visited.add(curr.right._str_repr)\n            else:\n                operands.append(curr.right)\n        \n        # 2. Recursively find the min height of each operand\n        operand_heights = [get_min_height(op_node) for op_node in operands]\n        \n        # 3. Combine heights using a greedy strategy (like Huffman coding)\n        heapq.heapify(operand_heights)\n        \n        if not operand_heights: # Should not happen for a valid tree\n            return 1\n        if len(operand_heights) == 1:\n            # This case can happen if the original tree was unary-like,\n            # which is not the case here (full binary trees).\n            result = operand_heights[0]\n        else:\n            while len(operand_heights) > 1:\n                h1 = heapq.heappop(operand_heights)\n                h2 = heapq.heappop(operand_heights)\n                new_h = 1 + max(h1, h2)\n                heapq.heappush(operand_heights, new_h)\n            result = operand_heights[0]\n\n        memo[node._str_repr] = result\n        return result\n\n    results = []\n    for tree in test_cases_trees:\n        # Clear memo for each top-level expression to be safe, though not strictly necessary\n        # with unique string representations.\n        memo.clear() \n        results.append(get_min_height(tree))\n\n    # Format and print the final output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}