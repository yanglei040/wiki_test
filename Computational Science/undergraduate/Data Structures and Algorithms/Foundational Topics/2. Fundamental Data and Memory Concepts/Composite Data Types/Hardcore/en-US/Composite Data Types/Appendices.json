{
    "hands_on_practices": [
        {
            "introduction": "A deep understanding of composite data types begins at the level of bits and bytes. This first practice challenges you to think like a systems programmer by packing multiple pieces of information—a pointer and several boolean flags—into a single $64$-bit word. By exploiting memory alignment guarantees, a common feature in modern computer architectures, you will learn how to use bitwise operations to create highly efficient and compact data representations .",
            "id": "3223001",
            "problem": "You are asked to design a composite data type representation that packs a memory pointer and three independent boolean flags into a single $64$-bit word. The context is a $64$-bit system where dynamic memory allocation guarantees that any heap pointer is aligned to $8$ bytes. Alignment to $8$ bytes means that the pointer value $p$ is always divisible by $8$, equivalently $p \\bmod 8 = 0$, so the least significant three bits are zero.\n\nFundamental base and definitions to use:\n- Binary integers occupy a fixed-width bit-vector representation; a $64$-bit word represents integers in the range $[0,2^{64}-1]$.\n- Bitwise logic follows well-tested rules: bitwise and, bitwise or, bitwise exclusive-or, and bit shifts operate per bit position. In particular, if two sets of bits occupy disjoint positions, their bitwise or aggregates them without interference.\n- Memory alignment to $2^{a}$ bytes implies that the lowest $a$ bits of any aligned address are zero.\n- Boolean values can be represented as bits where $0$ encodes logical false and $1$ encodes logical true.\n\nTask:\n1. Construct an encoding function that, given an aligned pointer $p$ and a triple of boolean flags $(b_0,b_1,b_2)$, produces a single $64$-bit word $w$ that stores both without loss of information.\n2. Construct a decoding function that, given $w$, recovers the original pointer $p$ and the flags $(b_0,b_1,b_2)$ exactly.\n3. Prove, using only the alignment guarantee and the properties of bitwise operations, that your encoding and decoding are inverses on the valid domain. You must ensure that the pointer bits and flag bits do not interfere.\n4. If the input pointer $p$ is not aligned to $8$ bytes, the encoding must signal an invalid case. For the purpose of this program, return the integer $-1$ for such cases.\n\nDomain and constraints:\n- Treat pointers as unsigned integers with $p \\in \\{0,8,16,\\dots,2^{61}-8\\}$, which ensures there is room for three lowest bits to store flags while keeping the result within a $64$-bit word.\n- Use only integer and bitwise operations; do not rely on floating-point or string manipulation to perform the packing and unpacking.\n\nTest suite:\nImplement your solution and run it on the following parameter sets, each consisting of a pointer $p$ and flags $(b_0,b_1,b_2)$:\n- Case A (general case): $p = 4096$, $(b_0,b_1,b_2) = (1,0,1)$.\n- Case B (all flags false, zero pointer): $p = 0$, $(b_0,b_1,b_2) = (0,0,0)$.\n- Case C (all flags true, high pointer): $p = 2^{60}$, $(b_0,b_1,b_2) = (1,1,1)$.\n- Case D (boundary pointer near the maximum representable under the domain): $p = 2^{61} - 8$, $(b_0,b_1,b_2) = (1,0,0)$.\n- Case E (invalid unaligned pointer): $p = 12345$, $(b_0,b_1,b_2) = (1,1,0)$.\n\nRequired output format:\n- For each case, output a single integer: the packed $64$-bit word $w$ for valid cases and $-1$ for invalid cases.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[resultA,resultB,resultC,resultD,resultE]\").\n- No physical units are involved in this problem.",
            "solution": "The problem requires the design of a composite data type that packs a $64$-bit memory pointer $p$ and three boolean flags $(b_0, b_1, b_2)$ into a single $64$-bit word. The fundamental principle that enables this is the explicit guarantee that any such pointer $p$ is aligned to $8$ bytes.\n\nA memory address, or pointer value, $p$ being aligned to $8$ bytes implies that $p$ is an integer multiple of $8$. Mathematically, this is expressed as $p \\equiv 0 \\pmod{8}$. In the binary number system, any integer multiple of $8 = 2^3$ must have its three least significant bits (LSBs), corresponding to positions $0$, $1$, and $2$, equal to zero. These three bits are therefore available for storage without interfering with the pointer's value, as the alignment property ensures they are predictable. We can leverage these \"free\" bits to store the three boolean flags.\n\n### Encoding Function\nThe encoding function, let's call it $\\text{encode}(p, (b_0, b_1, b_2))$, takes as input a pointer $p$ (represented as a $64$-bit unsigned integer) and a triple of boolean flags. It produces a single $64$-bit word $w$.\n\nFirst, the function must validate the input pointer $p$. The alignment is a critical precondition. The check is performed by verifying that $p$ is a multiple of $8$. This can be computed arithmetically as $p \\pmod{8} = 0$, or more efficiently using bitwise operations as $p \\ \\& \\ 7 = 0$. If the pointer is not aligned, it is considered an invalid input, and the function must return the integer value $-1$ as specified by the problem.\n\nIf the pointer is valid, the encoding proceeds. The boolean flags $(b_0, b_1, b_2)$ are represented by integers $f_0, f_1, f_2 \\in \\{0, 1\\}$. We establish a direct mapping where flag $b_i$ is stored in bit position $i$. These flags are combined into a single $3$-bit integer, denoted $\\text{flags\\_val}$, which lies in the range $[0, 7]$:\n$$\n\\text{flags\\_val} = (f_2 \\ll 2) \\ | \\ (f_1 \\ll 1) \\ | \\ f_0\n$$\nThis expression is equivalent to the arithmetic sum $4f_2 + 2f_1 + f_0$.\n\nSince the three LSBs of a valid pointer $p$ are guaranteed to be zero, we can merge $p$ and $\\text{flags\\_val}$ using a bitwise OR operation. This places the flag bits into the zeroed LSBs of the pointer's binary representation without disturbing any of the more significant bits that define the pointer's value. The final encoded word $w$ is:\n$$\nw = p \\ | \\ \\text{flags\\_val}\n$$\n\n### Decoding Function\nThe decoding function, $\\text{decode}(w)$, performs the inverse operation. It takes a $64$-bit word $w$ created by our encoding scheme and recovers the original pointer $p$ and the three flags $(b_0, b_1, b_2)$.\n\nTo recover the original pointer $p$, we must clear the three LSBs of $w$, which now hold the flag data. This is achieved by performing a bitwise AND operation between $w$ and a mask where the three LSBs are $0$ and all other bits are $1$. This mask is the bitwise complement of $7$ (i.e., $\\sim 7$), which corresponds to the $64$-bit hexadecimal value $0xFFFFFFFFFFFFFFF8$.\n$$\np_{\\text{recovered}} = w \\ \\& \\ (\\sim 7)\n$$\nThis operation zeroes out bits $0$, $1$, and $2$, restoring the pointer to its original aligned value.\n\nTo recover the flags, we must isolate each of the three LSBs from the word $w$:\n- The integer value for flag $b_0$, $f_0$, is stored in bit $0$ of $w$:\n  $$\n  f_0 = w \\ \\& \\ 1\n  $$\n- The value for flag $b_1$, $f_1$, is in bit $1$. We isolate it and normalize it by right-shifting:\n  $$\n  f_1 = (w \\ \\& \\ 2) \\gg 1\n  $$\n- The value for flag $b_2$, $f_2$, is in bit $2$:\n  $$\n  f_2 = (w \\ \\& \\ 4) \\gg 2\n  $$\nThese operations successfully extract the individual flag values as either $0$ or $1$.\n\n### Proof of Correctness\nWe will now prove that for any valid pointer $p$ and any set of flags $(f_0, f_1, f_2)$, the decoding process perfectly inverts the encoding. Let $w = \\text{encode}(p, (f_0, f_1, f_2))$ and $(p', (f'_0, f'_1, f'_2)) = \\text{decode}(w)$. We must show that $p' = p$ and $f'_i = f_i$ for $i \\in \\{0, 1, 2\\}$.\n\n1.  **Premises**:\n    - The input pointer $p$ is aligned to $8$ bytes, meaning $p \\bmod 8 = 0$. Its binary representation must end in three zeros: $p = (p_{63} \\dots p_3 000)_2$.\n    - The flags are combined into an integer $f_{\\text{val}} = 4f_2 + 2f_1 + f_0$. Its binary representation has bits $3$ through $63$ as zero: $f_{\\text{val}} = (0 \\dots 0 f_2 f_1 f_0)_2$.\n\n2.  **Encoding Analysis**:\n    The encoded word $w$ is calculated as $w = p \\ | \\ f_{\\text{val}}$.\n    $$\n    w = (p_{63} \\dots p_3 000)_2 \\ | \\ (0 \\dots 0 f_2 f_1 f_0)_2 = (p_{63} \\dots p_3 f_2 f_1 f_0)_2\n    $$\n    Because the bit positions being set by $f_{\\text{val}}$ (bits $0, 1, 2$) are guaranteed to be clear in $p$, the bitwise OR operations simply fill in these bits. The upper $61$ bits of $w$ are identical to the upper $61$ bits of $p$, and the lower $3$ bits of $w$ hold the flag values.\n\n3.  **Decoding Analysis**:\n    - **Pointer Recovery**: The recovered pointer $p'$ is computed as $p' = w \\ \\& \\ (\\sim 7)$. The mask $(\\sim 7)$ has a binary representation of $(1 \\dots 1000)_2$.\n      $$\n      p' = (p_{63} \\dots p_3 f_2 f_1 f_0)_2 \\ \\& \\ (1 \\dots 11111000)_2 = (p_{63} \\dots p_3 000)_2\n      $$\n      This result is bit-for-bit identical to the original pointer $p$. Thus, $p' = p$.\n\n    - **Flag Recovery**: The recovered flags $f'_0, f'_1, f'_2$ are extracted as follows:\n      $$\n      f'_0 = (w \\ \\& \\ 1) = ((p_{63} \\dots f_0)_2 \\ \\& \\ (0 \\dots 001)_2) = (0 \\dots 0 f_0)_2 = f_0\n      $$\n      $$\n      f'_1 = ((w \\ \\& \\ 2) \\gg 1) = (((p_{63} \\dots f_0)_2 \\ \\& \\ (0 \\dots 010)_2) \\gg 1) = ((0 \\dots f_1 0)_2 \\gg 1) = (0 \\dots 0 f_1)_2 = f_1\n      $$\n      $$\n      f'_2 = ((w \\ \\& \\ 4) \\gg 2) = (((p_{63} \\dots f_0)_2 \\ \\& \\ (0 \\dots 100)_2) \\gg 2) = ((0 \\dots f_2 00)_2 \\gg 2) = (0 \\dots 0 f_2)_2 = f_2\n      $$\n      The recovered flags $(f'_0, f'_1, f'_2)$ are identical to the original flags $(f_0, f_1, f_2)$.\n\n**Conclusion**: The defined encoding and decoding functions are lossless inverses for the specified domain of valid inputs. This system of pointer tagging is correct and robust, relying solely on the guaranteed memory alignment and the fundamental properties of bitwise logic.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the pointer packing problem for the given test suite.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: p = 4096, (b0,b1,b2) = (1,0,1)\n        (4096, (1, 0, 1)),\n        # Case B: p = 0, (b0,b1,b2) = (0,0,0)\n        (0, (0, 0, 0)),\n        # Case C: p = 2^60, (b0,b1,b2) = (1,1,1)\n        (2**60, (1, 1, 1)),\n        # Case D: p = 2^61 - 8, (b0,b1,b2) = (1,0,0)\n        (2**61 - 8, (1, 0, 0)),\n        # Case E: p = 12345, (b0,b1,b2) = (1,1,0)\n        (12345, (1, 1, 0)),\n    ]\n\n    def encode(p, flags):\n        \"\"\"\n        Packs a memory pointer and three boolean flags into a single 64-bit word.\n        \n        Args:\n            p (int): The pointer value, treated as an unsigned integer.\n            flags (tuple): A tuple of three integers (0 or 1) representing (b0, b1, b2).\n            \n        Returns:\n            int: The packed 64-bit word, or -1 if the pointer is not aligned.\n        \"\"\"\n        # A pointer is aligned to 8 bytes if its value is divisible by 8.\n        # This can be checked efficiently using the modulo operator or bitwise AND.\n        # p % 8 == 0 is equivalent to (p & 7) == 0.\n        if p % 8 != 0:\n            return -1\n        \n        # Unpack the flag tuple. The problem uses (b0, b1, b2), so we map\n        # b0 to bit 0, b1 to bit 1, and b2 to bit 2.\n        b0, b1, b2 = flags\n        \n        # Combine the boolean flags (represented as 0 or 1) into a single\n        # integer value where each flag corresponds to a bit position.\n        flags_val = (b2 << 2) | (b1 << 1) | b0\n        \n        # Since the 3 least significant bits of an aligned pointer are zero,\n        # we can use a bitwise OR to merge the pointer and the flags without\n        # corrupting the pointer's original value.\n        return p | flags_val\n\n    results = []\n    for p, flags in test_cases:\n        result = encode(p, flags)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Composite types are not just for static data; they are essential for building dynamic data structures. This exercise simulates the creation and management of a custom dynamic array, one of the most fundamental data structures in computer science . You will implement the logic for growing and shrinking the array's capacity, gaining insight into the performance trade-offs and the concept of amortized analysis, which explains why these structures are so efficient in practice.",
            "id": "3223151",
            "problem": "Design and analyze a composite data type that models a C dynamic array with a flexible array member. Consider a C definition that uses a structure with a flexible array member to store a resizable sequence of bytes: a structure with two header fields and a trailing array of elements, specifically, a header containing two fields of type $size\\_t$ (each of size $8$ bytes) named $length$ and $capacity$, and a flexible array member of type $char$ named $data[]$. The total size of an allocation is the sum of the header and the number of data bytes. In this model, one element occupies $1$ byte. Therefore, the header has a constant size of $16$ bytes and an allocation for $capacity$ elements occupies $16 + capacity$ bytes. The dynamic array is an instance of a composite data type because it aggregates multiple fields and an array into a single logical entity. The task is to simulate manual memory management and resizing rules, and calculate quantitative metrics about the resulting memory operations.\n\nStart from the following fundamental base:\n- The definition of an array and structure composition in memory: contiguous layout with a header followed by an array makes a single composite memory block.\n- A sequence of operations updates the logical length of the array via insertions and deletions, while $capacity$ determines the size of the allocated block.\n- Copying cost during reallocation measures the amount of data moved when the array grows or shrinks.\n\nYou must implement the following behavior rules precisely:\n- Initialization: The array is created with an initial $capacity$ of $c\\_0 \\ge 1$, $length = 0$, and a single initial allocation of $16 + c\\_0$ bytes.\n- Push operation of $n$ elements: Perform $n$ single-element insertions. For each single insertion, if $length = capacity$, grow the array by doubling capacity, that is, set $capacity \\leftarrow 2 \\cdot capacity$, and perform a reallocation. A reallocation incurs a copying cost equal to the number of elements currently stored, which is $length$ bytes. After any necessary growth, append one element, increasing $length$ by $1$.\n- Pop operation of $n$ elements: Perform $n$ single-element deletions with the following rule. For each single deletion, if $length > 0$, decrement $length$ by $1$ and then, while $capacity > 1$ and $length \\le \\left\\lfloor \\frac{capacity}{4} \\right\\rfloor$, shrink by halving capacity, that is, set $capacity \\leftarrow \\left\\lfloor \\frac{capacity}{2} \\right\\rfloor$. Each shrink incurs a reallocation and a copying cost equal to the current $length$ in bytes. If $length = 0$, the pop does nothing and no shrink is triggered. Capacity never falls below $1$.\n- Reallocation counting: Count a reallocation event whenever $capacity$ changes due to growth or shrink. The initial allocation at creation is not counted as a reallocation event.\n- Copying cost: Accumulate the total number of bytes copied across all reallocation events during the lifetime of the array.\n- Current memory: At the end of processing a test case, the currently allocated bytes equal $16 + capacity$.\n\nFrom these rules, compute for each test case:\n- Final logical length $L$.\n- Final capacity $C$.\n- Number of reallocations $R$.\n- Total bytes copied during reallocations $K$.\n- Amortized copy cost per push $A$, defined as $A = \\frac{K}{N\\_{\\text{push}}}$ where $N\\_{\\text{push}}$ is the total number of single-element push operations executed in the test case. If $N\\_{\\text{push}} = 0$, define $A = 0$.\n- Final currently allocated bytes $M = 16 + C$.\n\nAll quantities $L$, $C$, $R$, $K$, and $M$ are integers measured in bytes where applicable; $A$ is a real number and must be expressed as a decimal rounded to $6$ places. No physical units beyond bytes are involved in this problem. Angles are not involved. Percentages are not involved.\n\nTest suite:\nUse the following parameter sets, each described by an initial capacity and an ordered sequence of operations, where “$+$” denotes a push of the given cardinality and “$-$” denotes a pop of the given cardinality. Each push or pop cardinality applies to single-element operations repeated that many times.\n- Case $1$: Initial capacity $c\\_0 = 4$. Operations: $+10$, $-3$, $+5$.\n- Case $2$: Initial capacity $c\\_0 = 1$. Operations: $-5$, $+1$, $-1$.\n- Case $3$: Initial capacity $c\\_0 = 3$. Operations: $+7$, $-4$, $+2$, $-1$, $-1$.\n- Case $4$: Initial capacity $c\\_0 = 8$. Operations: $-2$, $-2$, $-2$, $-2$.\n- Case $5$: Initial capacity $c\\_0 = 2$. Operations: $+100$, $-60$, $+20$.\n\nYour program should produce a single line of output containing the results for all test cases as a comma-separated list enclosed in square brackets, with each test case’s result encoded as a list in the order $[L,C,R,K,A,M]$. For example, the overall format is $[[L\\_1,C\\_1,R\\_1,K\\_1,A\\_1,M\\_1],[L\\_2,C\\_2,R\\_2,K\\_2,A\\_2,M\\_2],\\dots]$ with no spaces.",
            "solution": "The problem statement is evaluated to be **valid**. It is self-contained, scientifically grounded in the principles of data structures and algorithms, and mathematically well-posed. The rules for the dynamic array simulation are unambiguous and can be formalized into a deterministic algorithm. We will proceed with a detailed analysis and solution.\n\nThe problem requires us to simulate a dynamic array, a composite data type, whose memory is manually managed according to specific rules for growth and shrinkage. We must track several key metrics throughout a sequence of push and pop operations. The state of the array at any point is characterized by its logical length, denoted as $length$, and its allocated capacity, denoted as $capacity$. We will also track the total number of reallocations $R$, the total bytes copied $K$, and the total number of push operations $N_{\\text{push}}$.\n\nThe header of the data structure has a fixed size of $16$ bytes. An element is of type $char$ and occupies $1$ byte. The total memory allocated for an array with capacity $C$ is $M = 16 + C$ bytes.\n\nThe rules for modifying the array state are as follows:\n- **Initialization**: Given an initial capacity $c_0$, the state is initialized as $length \\leftarrow 0$, $capacity \\leftarrow c_0$, $R \\leftarrow 0$, $K \\leftarrow 0$, and $N_{\\text{push}} \\leftarrow 0$. The initial memory allocation is not counted as a reallocation event.\n- **Single Push Operation**:\n    1. Increment the total push count: $N_{\\text{push}} \\leftarrow N_{\\text{push}} + 1$.\n    2. Check for growth: If $length = capacity$, a reallocation is triggered.\n        - The capacity is doubled: $capacity \\leftarrow 2 \\cdot capacity$.\n        - The number of reallocations is incremented: $R \\leftarrow R + 1$.\n        - The copy cost is updated by the number of elements being moved: $K \\leftarrow K + length$.\n    3. The length is incremented to accommodate the new element: $length \\leftarrow length + 1$.\n- **Single Pop Operation**:\n    1. Check if the array is empty: If $length = 0$, the operation has no effect.\n    2. If $length > 0$, the length is first decremented: $length \\leftarrow length - 1$.\n    3. After decrementing, check for shrinkage. The condition is checked repeatedly in a loop: While $capacity > 1$ and $length \\le \\lfloor \\frac{capacity}{4} \\rfloor$, a reallocation is triggered.\n        - The capacity is halved: $capacity \\leftarrow \\lfloor \\frac{capacity}{2} \\rfloor$.\n        - The number of reallocations is incremented: $R \\leftarrow R + 1$.\n        - The copy cost is updated by the number of elements being moved: $K \\leftarrow K + length$. Note that $length$ has already been decremented.\n\nWe will now apply these rules to each test case.\n\n**Case 1: Initial capacity $c_0 = 4$. Operations: $+10, -3, +5$.**\n\n- **Initial State**: $length=0$, $capacity=4$, $R=0$, $K=0$, $N_{\\text{push}}=0$.\n- **Operation $+10$**: Perform $10$ single push operations.\n    - Pushes $1-4$: $length$ increments from $1$ to $4$. State: $length=4, capacity=4$.\n    - Push $5$: $length=capacity$. Grow. $R \\leftarrow 1$, $K \\leftarrow 0+4=4$. $capacity \\leftarrow 2 \\cdot 4 = 8$. Then, $length \\leftarrow 5$. State: $length=5, capacity=8, R=1, K=4$.\n    - Pushes $6-8$: $length$ increments from $6$ to $8$. State: $length=8, capacity=8, R=1, K=4$.\n    - Push $9$: $length=capacity$. Grow. $R \\leftarrow 2$, $K \\leftarrow 4+8=12$. $capacity \\leftarrow 2 \\cdot 8 = 16$. Then, $length \\leftarrow 9$. State: $length=9, capacity=16, R=2, K=12$.\n    - Push $10$: $length \\leftarrow 10$.\n    - After $+10$: $N_{\\text{push}}=10$. State: $length=10, capacity=16, R=2, K=12$.\n- **Operation $-3$**: Perform $3$ single pop operations.\n    - Pop $1$: $length \\leftarrow 9$. Check shrink: $9 > \\lfloor 16/4 \\rfloor = 4$. No shrink.\n    - Pop $2$: $length \\leftarrow 8$. Check shrink: $8 > 4$. No shrink.\n    - Pop $3$: $length \\leftarrow 7$. Check shrink: $7 > 4$. No shrink.\n    - After $-3$: State: $length=7, capacity=16, R=2, K=12$.\n- **Operation $+5$**: Perform $5$ single push operations.\n    - Pushes $1-5$: $length$ increments from $8$ to $12$. No growth needed as $capacity=16$.\n    - After $+5$: $N_{\\text{push}} \\leftarrow 10+5=15$. State: $length=12, capacity=16, R=2, K=12$.\n- **Final Metrics**:\n    - $L = 12$\n    - $C = 16$\n    - $R = 2$\n    - $K = 12$\n    - $A = K/N_{\\text{push}} = 12/15 = 0.8$\n    - $M = 16+C = 16+16 = 32$\n\n**Case 2: Initial capacity $c_0 = 1$. Operations: $-5, +1, -1$.**\n\n- **Initial State**: $length=0$, $capacity=1$, $R=0$, $K=0$, $N_{\\text{push}}=0$.\n- **Operation $-5$**: Perform $5$ single pop operations. Since $length=0$ initially, these operations have no effect.\n- **Operation $+1$**: Perform $1$ single push operation.\n    - Push $1$: $length=0 < capacity=1$. No growth. $length \\leftarrow 1$.\n    - After $+1$: $N_{\\text{push}}=1$. State: $length=1, capacity=1, R=0, K=0$.\n- **Operation $-1$**: Perform $1$ single pop operation.\n    - Pop $1$: $length \\leftarrow 0$. Check shrink: The condition $capacity > 1$ is false. No shrink.\n    - After $-1$: State: $length=0, capacity=1, R=0, K=0$.\n- **Final Metrics**:\n    - $L = 0$\n    - $C = 1$\n    - $R = 0$\n    - $K = 0$\n    - $A = K/N_{\\text{push}} = 0/1 = 0.0$\n    - $M = 16+C = 16+1 = 17$\n\n**Case 3: Initial capacity $c_0 = 3$. Operations: $+7, -4, +2, -1, -1$.**\n\n- **Initial State**: $length=0$, $capacity=3$, $R=0, K=0, N_{\\text{push}}=0$.\n- **Operation $+7$**:\n    - Pushes $1-3$: $length \\rightarrow 3$.\n    - Push $4$: Grow. $R \\leftarrow 1, K \\leftarrow 0+3=3, capacity \\leftarrow 6$. $length \\rightarrow 4$.\n    - Pushes $5-6$: $length \\rightarrow 6$.\n    - Push $7$: Grow. $R \\leftarrow 2, K \\leftarrow 3+6=9, capacity \\leftarrow 12$. $length \\rightarrow 7$.\n    - After $+7$: $N_{\\text{push}}=7$. State: $length=7, capacity=12, R=2, K=9$.\n- **Operation $-4$**:\n    - Pop $1$: $length \\rightarrow 6$. Check shrink: $6 > \\lfloor 12/4 \\rfloor = 3$. No.\n    - Pop $2$: $length \\rightarrow 5$. Check shrink: $5 > 3$. No.\n    - Pop $3$: $length \\rightarrow 4$. Check shrink: $4 > 3$. No.\n    - Pop $4$: $length \\rightarrow 3$. Check shrink: $3 \\le 3$. Yes. Shrink. $R \\leftarrow 3, K \\leftarrow 9+3=12, capacity \\leftarrow \\lfloor 12/2 \\rfloor = 6$. Check again: $length=3$, $capacity=6$. $3 > \\lfloor 6/4 \\rfloor=1$. Stop shrinking.\n    - After $-4$: State: $length=3, capacity=6, R=3, K=12$.\n- **Operation $+2$**: $length \\rightarrow 5$. No growth. $N_{\\text{push}} \\leftarrow 7+2=9$. State: $length=5, capacity=6$.\n- **Operation $-1$**: $length \\rightarrow 4$. Check shrink: $4 > \\lfloor 6/4 \\rfloor = 1$. No. State: $length=4, capacity=6$.\n- **Operation $-1$**: $length \\rightarrow 3$. Check shrink: $3 > 1$. No. State: $length=3, capacity=6$.\n- **Final Metrics**:\n    - $L = 3$\n    - $C = 6$\n    - $R = 3$\n    - $K = 12$\n    - $A = K/N_{\\text{push}} = 12/9 \\approx 1.333333$\n    - $M = 16+C = 16+6 = 22$\n\n**Case 4: Initial capacity $c_0 = 8$. Operations: $-2, -2, -2, -2$.**\n\n- **Initial State**: $length=0$, $capacity=8$, $R=0, K=0, N_{\\text{push}}=0$.\n- **All operations**: All are pop operations on an empty array. They have no effect.\n- **Final Metrics**:\n    - $L = 0$\n    - $C = 8$\n    - $R = 0$\n    - $K = 0$\n    - $N_{\\text{push}} = 0$, so $A = 0.0$ by definition.\n    - $M = 16+C = 16+8 = 24$\n\n**Case 5: Initial capacity $c_0 = 2$. Operations: $+100, -60, +20$.**\n\n- **Initial State**: $length=0$, $capacity=2$, $R=0, K=0, N_{\\text{push}}=0$.\n- **Operation $+100$**:\n    - Growth at $length=2$: $R=1, K=2, c=4$.\n    - Growth at $length=4$: $R=2, K=2+4=6, c=8$.\n    - Growth at $length=8$: $R=3, K=6+8=14, c=16$.\n    - Growth at $length=16$: $R=4, K=14+16=30, c=32$.\n    - Growth at $length=32$: $R=5, K=30+32=62, c=64$.\n    - Growth at $length=64$: $R=6, K=62+64=126, c=128$.\n    - After $100$ pushes, $length = 100$.\n    - After $+100$: $N_{\\text{push}}=100$. State: $length=100, capacity=128, R=6, K=126$.\n- **Operation $-60$**:\n    - $length$ decreases from $100$ to $40$.\n    - The shrink condition is $length \\le \\lfloor capacity/4 \\rfloor = \\lfloor 128/4 \\rfloor = 32$.\n    - Since the minimum $length$ reached is $40$, this condition is never met. No shrinks occur.\n    - After $-60$: State: $length=40, capacity=128, R=6, K=126$.\n- **Operation $+20$**:\n    - $length$ increases from $40$ to $60$. The capacity is $128$, so no growth is needed.\n    - $N_{\\text{push}} \\leftarrow 100+20=120$.\n    - After $+20$: State: $length=60, capacity=128, R=6, K=126$.\n- **Final Metrics**:\n    - $L = 60$\n    - $C = 128$\n    - $R = 6$\n    - $K = 126$\n    - $A = K/N_{\\text{push}} = 126/120 = 1.05$\n    - $M = 16+C = 16+128 = 144$\n\nThis completes the step-by-step analysis for all test cases. The implementation will codify this logic.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Simulates a dynamic array for a series of test cases and computes performance metrics.\n    \"\"\"\n\n    class DynamicArray:\n        \"\"\"\n        Models a dynamic array with specific growth and shrink rules.\n        \"\"\"\n        def __init__(self, initial_capacity):\n            self.length = 0\n            self.capacity = initial_capacity\n            self.reallocations = 0\n            self.copy_cost = 0\n            self.push_count = 0\n\n        def push(self):\n            \"\"\"\n            Appends a single element, growing the array if necessary.\n            \"\"\"\n            self.push_count += 1\n            if self.length == self.capacity:\n                self.reallocations += 1\n                self.copy_cost += self.length\n                self.capacity *= 2\n            self.length += 1\n\n        def pop(self):\n            \"\"\"\n            Removes a single element, shrinking the array if it becomes sparse enough.\n            \"\"\"\n            if self.length == 0:\n                return\n\n            self.length -= 1\n            \n            # The 'while' loop handles cases where multiple shrinks might be needed.\n            while self.capacity > 1 and self.length <= (self.capacity // 4):\n                self.reallocations += 1\n                # Copy cost is based on the new, smaller length.\n                self.copy_cost += self.length\n                self.capacity = self.capacity // 2\n\n        def get_metrics(self):\n            \"\"\"\n            Calculates and returns the final metrics for the array's lifetime.\n            \"\"\"\n            L = self.length\n            C = self.capacity\n            R = self.reallocations\n            K = self.copy_cost\n            \n            if self.push_count == 0:\n                A = 0.0\n            else:\n                A = K / self.push_count\n            \n            M = 16 + C\n            \n            # Format A to 6 decimal places as a string.\n            return [L, C, R, K, f\"{A:.6f}\", M]\n\n    test_cases = [\n        (4, ['+10', '-3', '+5']),\n        (1, ['-5', '+1', '-1']),\n        (3, ['+7', '-4', '+2', '-1', '-1']),\n        (8, ['-2', '-2', '-2', '-2']),\n        (2, ['+100', '-60', '+20']),\n    ]\n\n    results = []\n    for c0, operations in test_cases:\n        array = DynamicArray(c0)\n        for op in operations:\n            op_type = op[0]\n            count = int(op[1:])\n            \n            if op_type == '+':\n                for _ in range(count):\n                    array.push()\n            elif op_type == '-':\n                for _ in range(count):\n                    array.pop()\n        \n        results.append(array.get_metrics())\n\n    # Format the final output string as specified, with no spaces.\n    # e.g., [[L1,C1,...],[L2,C2,...]]\n    result_strings = [f\"[{','.join(map(str, res))}]\" for res in results]\n    final_output = f\"[{','.join(result_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "The true power of custom data types is revealed when they are used to model and solve complex, real-world problems. In this final practice, you will design the core components of a stock market limit order book, a system at the heart of modern financial exchanges . By defining composite types to represent buy and sell orders and implementing a matching engine based on price-time priority, you will see how well-chosen data structures lead to elegant and efficient solutions for sophisticated algorithmic challenges.",
            "id": "3223154",
            "problem": "You are tasked with designing composite data types to implement a simplified stock market limit order book. Each order is a record with three fields: a side, a price, and a volume. The side indicates whether the order is a buy or a sell, the price is the limit price at which the order is willing to transact, and the volume is the number of units. The objective is to convert a sequence of arriving orders into a final state of the order book by matching orders according to rigorously defined rules, and then report aggregated results for specified test cases. Your program must be a complete, runnable program.\n\nFoundational base. Begin with the following core definitions and facts, which you should use as the basis for your design and algorithm:\n- A composite data type is a data structure whose elements are composed of more primitive types; here, an order is a record composed of a side, a price, and a volume. Formally, an order can be represented as a tuple $\\langle side, price, volume \\rangle$.\n- Define two total orders over orders for prioritization that encode price-time priority: buy orders are prioritized by descending $price$ and then ascending arrival time, and sell orders are prioritized by ascending $price$ and then ascending arrival time. This induces a strict weak ordering consistent with First-In First-Out (FIFO) within each price level.\n- Matching rule: an incoming buy order with price $p_b$ can immediately match with the best sell order with price $p_s$ if and only if $p_b \\ge p_s$. An incoming sell order with price $p_s$ can immediately match with the best buy order with price $p_b$ if and only if $p_s \\le p_b$.\n- Execution price rule: the execution price equals the resting order’s limit price; for an incoming buy matched to a resting sell at price $p_s$, the trade executes at price $p_s$, and for an incoming sell matched to a resting buy at price $p_b$, the trade executes at price $p_b$.\n- Conservation: a trade reduces the incoming order’s remaining $volume$ and the resting order’s remaining $volume$ by the same nonnegative integer amount equal to the matched quantity, and volumes are always nonnegative integers.\n- Invariant: after processing each incoming order, any unfilled remainder is inserted into the corresponding side’s book respecting the total order described above.\n\nRequired composite data types. Design the following:\n- A record type for orders with fields $side \\in \\{\\text{BUY}, \\text{SELL}\\}$, $price \\in \\mathbb{N}$, and $volume \\in \\mathbb{N}$, together with an arrival index $t \\in \\mathbb{N}$ that strictly increases with each arrival and is used to break ties within a price level. Your program should enforce that $price \\ge 1$ and $volume \\ge 1$ for every order.\n- Two collections representing the buy and sell books, each maintaining the total order described above at all times.\n\nAlgorithmic requirements. Implement an algorithm that processes a finite ordered sequence of incoming orders as follows:\n- For each incoming order $\\langle side, price, volume \\rangle$ at time $t$, repeatedly match it against the best available order on the opposite side of the book while the price condition ($p_b \\ge p_s$ for buys or $p_s \\le p_b$ for sells) holds and the incoming $volume$ is positive.\n- In each match, compute the matched quantity $q = \\min(v_{\\text{incoming}}, v_{\\text{resting}})$, reduce both volumes by $q$, and record the executed volume $q$ for aggregation. If the resting order’s $volume$ becomes $0$, remove it from the book; otherwise, update its remaining $volume$.\n- If after all possible matches the incoming order retains a positive $volume$, insert the remainder into the appropriate book according to the total order described above.\n\nFinal output specification. For each test case, after processing the entire sequence of orders, compute:\n- The total executed volume $V_{\\text{exec}} = \\sum q$ across all trades in the case.\n- The best bid tuple $(p_{\\text{bid}}, v_{\\text{bid}})$ which is the highest $price$ buy order (breaking ties by earliest time). If the buy book is empty, report $p_{\\text{bid}} = -1$ and $v_{\\text{bid}} = 0$.\n- The best ask tuple $(p_{\\text{ask}}, v_{\\text{ask}})$ which is the lowest $price$ sell order (breaking ties by earliest time). If the sell book is empty, report $p_{\\text{ask}} = -1$ and $v_{\\text{ask}} = 0$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[\\text{result1},\\text{result2}]$), where each result is a list $[V_{\\text{exec}}, p_{\\text{bid}}, v_{\\text{bid}}, p_{\\text{ask}}, v_{\\text{ask}}]$ for the corresponding test case.\n\nTest suite. Use the following test cases, each specified as an ordered list of orders $(side, price, volume)$ with explicit integer values:\n- Case $1$: $[\\langle \\text{BUY}, 100, 10 \\rangle, \\langle \\text{SELL}, 99, 5 \\rangle, \\langle \\text{SELL}, 100, 4 \\rangle, \\langle \\text{SELL}, 101, 10 \\rangle]$. Expected behavior: the first sell at $99$ matches $5$ units against the buy at $100$, then the sell at $100$ matches $4$ units, leaving a buy remainder of $1$ at $100$ and an unmatched sell at $101$. Output format: $[V_{\\text{exec}}, p_{\\text{bid}}, v_{\\text{bid}}, p_{\\text{ask}}, v_{\\text{ask}}]$ with integers.\n- Case $2$: $[\\langle \\text{SELL}, 50, 10 \\rangle, \\langle \\text{SELL}, 50, 7 \\rangle, \\langle \\text{BUY}, 50, 12 \\rangle]$. Expected behavior: FIFO at equal price, the buy matches $10$ then $2$ units at $50$, leaving $5$ units on the second sell at $50$; no buy remains. Output format: integers as specified.\n- Case $3$: $[\\langle \\text{BUY}, 30, 3 \\rangle, \\langle \\text{BUY}, 30, 4 \\rangle, \\langle \\text{SELL}, 25, 5 \\rangle]$. Expected behavior: the sell at $25$ matches $3$ units then $2$ units at the resting buy price $30$, leaving $2$ units on the second buy; no sells remain.\n- Case $4$: $[\\langle \\text{BUY}, 20, 10 \\rangle, \\langle \\text{SELL}, 25, 1 \\rangle, \\langle \\text{BUY}, 19, 5 \\rangle]$. Expected behavior: no matches occur because the highest buy price $20$ is less than the lowest sell price $25$; both sides retain orders.\n- Case $5$: $[\\langle \\text{SELL}, 42, 2 \\rangle, \\langle \\text{SELL}, 45, 1 \\rangle, \\langle \\text{BUY}, 50, 5 \\rangle]$. Expected behavior: the buy at $50$ consumes sells at $42$ then $45$, leaving $2$ units on the buy at $50$; no sells remain.\n\nUnits and representation. All $price$ and $volume$ values are integers without physical units. The side must be one of $\\{\\text{BUY}, \\text{SELL}\\}$.\n\nYour program must define these test cases explicitly, compute the results according to the rules above, and print a single line in the exact format described: a single bracketed list of the per-case result lists, comma-separated, with no extra text.",
            "solution": "The problem requires the design of a system to simulate a stock market limit order book. This involves creating composite data types for orders and the order books, implementing an algorithm to process a sequence of orders based on price-time priority, and calculating aggregate statistics from the final state of the book.\n\nThe solution is designed around a few core principles: the choice of appropriate composite data types to represent the state of the order book, and an algorithm that correctly processes transactions according to the specified matching rules.\n\n**1. Composite Data Type Design**\n\nThe fundamental unit is an order, which is a record containing a side, price, and volume. To handle the price-time priority rule, which mandates a First-In-First-Out (FIFO) discipline for orders at the same price level, each order must also be associated with its arrival time.\n\n-   **Order Representation**: An incoming order is defined by the tuple $\\langle side, price, volume \\rangle$. Within the system, to enforce time priority, we augment this with a strictly increasing arrival index $t \\in \\mathbb{N}$. An order waiting in the book is thus represented by its volume and arrival time, stored at a specific price level. The `price` and `volume` are positive integers ($\\mathbb{N}$ where $price \\ge 1, volume \\ge 1$), and the `side` is an enumeration of $\\{\\text{BUY}, \\text{SELL}\\}$.\n\n-   **Order Book Representation**: The core of the design is the data structure for the buy and sell books. Each book must maintain a collection of orders sorted according to a specific total order:\n    -   **Buy Book**: Orders are prioritized by descending price, then ascending arrival time.\n    -   **Sell Book**: Orders are prioritized by ascending price, then ascending arrival time.\n\n    To achieve this, we design a composite data structure for each book. Each book is represented as a list of price levels. Each price level itself is a composite type: a list containing two elements, `[price, order_queue]`.\n    -   The `price` is an integer.\n    -   The `order_queue` is a First-In-First-Out queue (implemented using `collections.deque` in Python) that stores the individual orders at that price level. Each element in the queue is a tuple $\\langle arrival\\_time, volume \\rangle$.\n\n    The list of price levels is kept sorted at all times. For the buy book, this list is sorted in descending order of price. For the sell book, it is sorted in ascending order of price. This structure ensures that the best order—the highest-priced buy or the lowest-priced sell—is always located at the beginning of the list (index $0$), allowing for efficient $O(1)$ access. When new orders are added, they are placed into the correct price level's queue. If the price level does not exist, a new one is created and inserted into the list while maintaining the sort order, an operation taking $O(N)$ time where $N$ is the number of distinct price levels.\n\n**2. Algorithmic Implementation**\n\nThe algorithm processes a sequence of incoming orders one by one, updating the state of the buy and sell books and tracking the total executed volume.\n\n-   **Initialization**: For each test case, we start with empty buy and sell books, a total executed volume $V_{\\text{exec}}$ of $0$, and an arrival time counter $t$ initialized to $0$.\n\n-   **Order Processing Loop**: For each incoming order $\\langle side_{in}, price_{in}, volume_{in} \\rangle$:\n    1.  The arrival time $t$ is incremented.\n    2.  The algorithm checks for potential matches on the opposite side of the book.\n    3.  **If the incoming order is a BUY order**:\n        -   It is matched against the best available sell order (the \"best ask\"), which is at the head of the `sell_book` data structure.\n        -   A match can occur if the sell book is not empty and the incoming buy price is greater than or equal to the best ask price, i.e., $p_{b, in} \\ge p_{s, best}$.\n        -   The matching process is repeated as long as the incoming order has volume remaining and the price condition holds. In each step:\n            a.  The matched quantity $q$ is the minimum of the incoming order's remaining volume and the resting sell order's volume, per the conservation rule: $q = \\min(v_{incoming}, v_{resting})$.\n            b.  The total executed volume $V_{\\text{exec}}$ is increased by $q$.\n            c.  Both the incoming and resting orders' volumes are reduced by $q$.\n            d.  If the resting sell order's volume becomes $0$, it is removed from its queue. If this leaves the price level's queue empty, the entire price level is removed from the `sell_book`.\n        -   If any volume remains on the incoming buy order after all possible matches ($v_{in} > 0$), it is added to the `buy_book` as a new resting order with its arrival time $t$ and remaining volume.\n\n    4.  **If the incoming order is a SELL order**:\n        -   The logic is symmetric. It is matched against the best available buy order (the \"best bid\") from the `buy_book`.\n        -   A match occurs if the buy book is not empty and $p_{s, in} \\le p_{b, best}$.\n        -   Matching proceeds iteratively, reducing volumes and updating $V_{\\text{exec}}$ as described above. If a resting buy order is fully filled, it is removed from the book.\n        -   Any remaining volume on the incoming sell order is added to the `sell_book`.\n\n**3. Final Output Calculation**\n\nAfter all orders in a test case sequence have been processed, the final required metrics are computed from the final state of the order books:\n\n-   **Total Executed Volume ($V_{\\text{exec}}$)**: This value has been accumulated throughout the simulation.\n-   **Best Bid ($(p_{\\text{bid}}, v_{\\text{bid}})$)**:\n    -   If the `buy_book` is empty, the result is $(-1, 0)$.\n    -   Otherwise, the best bid is the first price level in the `buy_book`. The price $p_{\\text{bid}}$ is the price of this level. The volume $v_{\\text{bid}}$ is the sum of volumes of all orders in the queue at this price level.\n-   **Best Ask ($(p_{\\text{ask}}, v_{\\text{ask}})$)**:\n    -   If the `sell_book` is empty, the result is $(-1, 0)$.\n    -   Otherwise, the best ask is the first price level in the `sell_book`. The price $p_{\\text{ask}}$ is its price, and the volume $v_{\\text{ask}}$ is the aggregate volume of all orders at that price.\n\nThis structured approach ensures that all rules defined in the problem statement—price-time priority, matching logic, and conservation of volume—are rigorously followed, leading to a deterministic and correct final state for any given input sequence.",
            "answer": "```python\nimport numpy as np\nimport collections\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run the simulation for each,\n    and print the results in the required format.\n    \"\"\"\n    # Define test cases as specified in the problem statement.\n    # Each order is a tuple: (side, price, volume)\n    test_cases = [\n        # Case 1\n        [('BUY', 100, 10), ('SELL', 99, 5), ('SELL', 100, 4), ('SELL', 101, 10)],\n        # Case 2\n        [('SELL', 50, 10), ('SELL', 50, 7), ('BUY', 50, 12)],\n        # Case 3\n        [('BUY', 30, 3), ('BUY', 30, 4), ('SELL', 25, 5)],\n        # Case 4\n        [('BUY', 20, 10), ('SELL', 25, 1), ('BUY', 19, 5)],\n        # Case 5\n        [('SELL', 42, 2), ('SELL', 45, 1), ('BUY', 50, 5)],\n    ]\n\n    all_results = []\n    for case_orders in test_cases:\n        result = process_order_sequence(case_orders)\n        all_results.append(result)\n\n    # Format the final output string as a list of lists.\n    # e.g., [[9,100,1,101,10],[12,-1,0,50,5]]\n    print(f\"[{','.join(map(str, all_results))}]\")\n\ndef add_order_to_book(book, price, time, volume, is_buy):\n    \"\"\"\n    Adds a new order to the specified book, maintaining price sort order.\n    \n    A book is a list of [price, deque_of_orders], sorted by price.\n    - Buy book: descending price.\n    - Sell book: ascending price.\n    An order in the deque is a tuple (arrival_time, volume).\n    \"\"\"\n    # Find the correct position to insert or update.\n    for i, (p_level_price, order_queue) in enumerate(book):\n        if p_level_price == price:\n            order_queue.append((time, volume))\n            return\n        \n        # Determine insertion point to maintain sort order.\n        is_insert_point = (is_buy and price > p_level_price) or \\\n                          (not is_buy and price < p_level_price)\n        if is_insert_point:\n            book.insert(i, [price, collections.deque([(time, volume)])])\n            return\n    \n    # If the loop completes, append to the end.\n    book.append([price, collections.deque([(time, volume)])])\n\ndef process_order_sequence(orders):\n    \"\"\"\n    Processes a single sequence of orders and returns the final book state summary.\n    \"\"\"\n    # The buy_book is sorted by price descending.\n    # Each element: [price, collections.deque([(time, volume), ...])]\n    buy_book = []\n    \n    # The sell_book is sorted by price ascending.\n    sell_book = []\n\n    total_executed_volume = 0\n    arrival_time = 0\n\n    for side, price, volume in orders:\n        arrival_time += 1\n        \n        # Enforce problem constraints\n        if price < 1 or volume < 1:\n            # Skip invalid orders as a robust measure, though test data is valid.\n            continue\n        \n        if side == 'BUY':\n            volume_in = volume\n            # Match against the sell book\n            while volume_in > 0 and sell_book and price >= sell_book[0][0]:\n                best_ask_price_level = sell_book[0]\n                best_ask_queue = best_ask_price_level[1]\n                resting_order_time, resting_order_vol = best_ask_queue[0]\n\n                matched_vol = min(volume_in, resting_order_vol)\n                total_executed_volume += matched_vol\n                volume_in -= matched_vol\n                \n                new_resting_vol = resting_order_vol - matched_vol\n                if new_resting_vol == 0:\n                    best_ask_queue.popleft()\n                else:\n                    best_ask_queue[0] = (resting_order_time, new_resting_vol)\n                \n                if not best_ask_queue:\n                    sell_book.pop(0)\n\n            if volume_in > 0:\n                add_order_to_book(buy_book, price, arrival_time, volume_in, is_buy=True)\n\n        elif side == 'SELL':\n            volume_in = volume\n            # Match against the buy book\n            while volume_in > 0 and buy_book and price <= buy_book[0][0]:\n                best_bid_price_level = buy_book[0]\n                best_bid_queue = best_bid_price_level[1]\n                resting_order_time, resting_order_vol = best_bid_queue[0]\n\n                matched_vol = min(volume_in, resting_order_vol)\n                total_executed_volume += matched_vol\n                volume_in -= matched_vol\n\n                new_resting_vol = resting_order_vol - matched_vol\n                if new_resting_vol == 0:\n                    best_bid_queue.popleft()\n                else:\n                    best_bid_queue[0] = (resting_order_time, new_resting_vol)\n                \n                if not best_bid_queue:\n                    buy_book.pop(0)\n\n            if volume_in > 0:\n                add_order_to_book(sell_book, price, arrival_time, volume_in, is_buy=False)\n\n    # Calculate final results for the test case\n    p_bid, v_bid = (-1, 0)\n    if buy_book:\n        p_bid = buy_book[0][0]\n        v_bid = sum(order[1] for order in buy_book[0][1])\n\n    p_ask, v_ask = (-1, 0)\n    if sell_book:\n        p_ask = sell_book[0][0]\n        v_ask = sum(order[1] for order in sell_book[0][1])\n\n    return [total_executed_volume, p_bid, v_bid, p_ask, v_ask]\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}