{
    "hands_on_practices": [
        {
            "introduction": "引用计数是一种直观的内存管理方法，但它有一个著名的弱点：无法回收循环引用的数据结构。本练习将引导你实现“试验性删除”算法，这是一种用于增强引用计数系统、以检测并回收这些循环垃圾的经典方法。通过这个实践，你将深入理解基于图的可达性分析，并学会如何解决特定垃圾回收方案中的一个根本性问题。",
            "id": "3236414",
            "problem": "给定自动内存管理中引用计数的概念框架，以及仅使用引用计数收集循环垃圾所面临的挑战。从以下基础概念出发：堆对象图被建模为一个有向图 $G = (V, E)$，其中 $|V| = n$，每个顶点 $v \\in V$ 是一个对象，每条有向边 $(u,v) \\in E$ 是一个从对象 $u$ 到对象 $v$ 的引用。对象 $v$ 的引用计数 $rc(v)$ 等于来自所有对象的对 $v$ 的引用总数，加上来自堆外部（例如，来自栈或寄存器等根）的引用数量，这些外部引用被建模为一个外部引用向量 $ext: V \\to \\mathbb{N}$。修改器（mutator）提供了一个候选对象集 $S \\subseteq V$，这些对象被“怀疑”可能参与了循环。\n\n仅使用这些基本概念，推导限制在 $S$ 上的试验性删除（trial deletion）的语义：它必须保守地精确检测出 $S$ 中那些从 $S$ 外部无法到达的对象。形式上，令 $ext\\_in(v)$ 表示从 $S$ 外部指向 $v$ 的引用数量，其计算公式为 $ext\\_in(v) = ext(v) + |\\{(u,v) \\in E \\mid u \\notin S\\}|$。定义基础集 $B = \\{ v \\in S \\mid ext\\_in(v) > 0 \\}$ 和存活集 $R \\subseteq S$ 为 $S$ 中所有可从 $B$ 出发、仅通过 $S$ 内部的边能到达的顶点集合。可回收垃圾集为 $G_S = S \\setminus R$。你的程序必须在算法上实现这些语义，并且其行为应如同一个在有限候选集 $S$ 上使用试验性删除的引用计数系统中的循环检测器。\n\n输入格式和执行模型：没有运行时输入。相反，你的程序必须硬编码一小组测试用例。每个测试用例是一个四元组 $(n, E, ext, S)$，其中 $n$ 是对象的数量，标记为从 $0$ 到 $n-1$ 的整数；$E$ 是有序对 $(u,v)$ 的列表；$ext$ 是一个长度为 $n$ 的列表，给出 $ext(i)$ 对于 $i \\in \\{0,\\dots,n-1\\}$ 的值；$S$ 是候选整数的列表。对于每个测试用例，计算 $G_S$ 中对象标识符的排序列表。\n\n测试套件：\n- 测试用例 1：$n = 5$, $E = [(0,1),(1,2),(2,0),(2,3)]$, $ext = [0,0,0,1,0]$, $S = [0,1,2]$。\n- 测试用例 2：$n = 3$, $E = [(0,1)]$, $ext = [0,0,0]$, $S = []$。\n- 测试用例 3：$n = 3$, $E = [(0,1),(1,2)]$, $ext = [1,0,0]$, $S = [0,1,2]$。\n- 测试用例 4：$n = 3$, $E = [(0,1),(1,2),(2,0)]$, $ext = [0,0,0]$, $S = [0,1]$。\n- 测试用例 5：$n = 1$, $E = [(0,0)]$, $ext = [0]$, $S = [0]$。\n- 测试用例 6：$n = 6$, $E = [(0,1),(1,2),(2,0),(3,4),(4,5),(5,3)]$, $ext = [0,1,0,0,0,0]$, $S = [0,1,2,3,4,5]$。\n\n要求：\n- 推导并实现一个正确且高效的算法，该算法与上述基础概念所定义的、限制在 $S$ 上的试验性删除语义一致。你的程序不得依赖任何外部输入。\n- 对于每个测试用例，输出将在 $S$ 上通过试验性删除回收的对象标识符的排序列表。\n- 最终输出格式：你的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，且不含任何空格。每个元素是对应于单个测试用例的排序列表。例如，最终输出应类似于 `[[\\dots],[\\dots],\\dots]`。\n\n答案规范：\n- 对于每个测试用例，答案是一个整数列表（可能为空）。\n- 单行输出必须按上述顺序汇总所有测试用例的列表，并且在行中任何位置都不得包含空格字符。",
            "solution": "已根据指定标准对用户提供的问题陈述进行了分析和验证。\n\n### 步骤1：提取已知信息\n\n-   **堆模型**：一个有向图 $G = (V, E)$，其中有 $|V| = n$ 个顶点（对象）和一组有向边 $E$（引用）。\n-   **对象标识符**：从 $0$ 到 $n-1$ 的整数。\n-   **外部引用**：一个向量 $ext: V \\to \\mathbb{N}$，其中 $ext(v)$ 是从堆外部到对象 $v$ 的引用数。\n-   **候选集**：对象的一个子集 $S \\subseteq V$，被怀疑是垃圾循环的一部分。\n-   **到 S 的外部入引用**：对于对象 $v \\in S$，从 $S$ 外部引用的数量定义为 $ext\\_in(v) = ext(v) + |\\{(u,v) \\in E \\mid u \\notin S\\}|$。\n-   **基础集**：$B = \\{ v \\in S \\mid ext\\_in(v) > 0 \\}$。这些是 $S$ 中可从 $S$ 外部直接到达的对象。\n-   **存活集**：$R \\subseteq S$，定义为 $S$ 中所有可从基础集 $B$ 出发、仅由 $S$ 内部的边构成的路径到达的顶点集合。\n-   **可回收垃圾集**：$G_S = S \\setminus R$。\n-   **任务**：对于给定的一组测试用例，计算 $G_S$ 中对象标识符的排序列表。\n-   **测试套件**：\n    1.  测试用例 1：$n = 5$, $E = [(0,1),(1,2),(2,0),(2,3)]$, $ext = [0,0,0,1,0]$, $S = [0,1,2]$。\n    2.  测试用例 2：$n = 3$, $E = [(0,1)]$, $ext = [0,0,0]$, $S = []$。\n    3.  测试用例 3：$n = 3$, $E = [(0,1),(1,2)]$, $ext = [1,0,0]$, $S = [0,1,2]$。\n    4.  测试用例 4：$n = 3$, $E = [(0,1),(1,2),(2,0)]$, $ext = [0,0,0]$, $S = [0,1]$。\n    5.  测试用例 5：$n = 1$, $E = [(0,0)]$, $ext = [0]$, $S = [0]$。\n    6.  测试用例 6：$n = 6$, $E = [(0,1),(1,2),(2,0),(3,4),(4,5),(5,3)]$, $ext = [0,1,0,0,0,0]$, $S = [0,1,2,3,4,5]$。\n-   **输出格式**：一个单行字符串 `[[...],[...],...]`，表示所有测试用例的结果列表，不含空格。\n\n### 步骤2：使用提取的已知信息进行验证\n\n根据验证标准对问题进行评估：\n\n-   **科学性**：该问题在计算机科学领域有充分的依据，特别是在涉及自动内存管理（垃圾回收）的数据结构和算法领域。基于图的对象堆模型、引用计数的概念以及循环垃圾问题是该领域的基本主题。“试验性删除”的语义被严格定义，并代表了一种有效的循环检测方法。该问题与*垃圾回收概念*的主题直接相关。\n-   **良构性**：该问题在数学上是良构的。所有术语（$G, E, S, ext, ext\\_in, B, R, G_S$）都得到了明确的定义。目标——计算 $G_S$——是清晰的。该过程涉及标准的图算法（可达性），对此存在唯一且稳定的解。每个测试用例都提供了所有必要的数据。\n-   **客观性**：问题陈述使用精确、正式、客观的语言，没有任何主观性或歧义。\n\n该问题没有表现出任何列出的缺陷（不具科学性、非形式化、设定不完整、不切实际、不良构、伪深刻、外部可验证性）。\n\n### 步骤3：结论与行动\n\n问题陈述是**有效的**。将推导并实现一个解决方案。\n\n### 算法推导\n\n任务是为每个测试用例计算可回收垃圾集 $G_S = S \\setminus R$。该算法直接实现了所提供的形式化定义。该过程可分解为三个主要的计算步骤。\n\n1.  **基础集 B 的计算**：基础集 $B$ 包含候选集 $S$ 中所有可从 $S$ 外部到达的对象。如果一个对象具有非零的外部引用计数（$ext(v) > 0$），或者至少有一个来自不在 $S$ 中的对象的引用指向它，那么它就是可从 $S$ 外部到达的。这对应于条件 $ext\\_in(v) > 0$。\n\n    要计算 $B$，我们首先必须为每个 $v \\in S$ 计算 $ext\\_in(v)$。算法如下：\n    - 对于 $S$ 中的每个对象 $v$，用外部引用向量的值 $ext(v)$ 初始化一个 $ext\\_in(v)$ 的计数器。\n    - 遍历所有边 $(u, w) \\in E$。如果源 $u$ 不在 $S$ 中（$u \\notin S$）且目标 $w$ 在 $S$ 中（$w \\in S$），则增加 $ext\\_in(w)$ 的计数器。\n    - 在评估所有边之后，基础集 $B$ 由所有 $v \\in S$ 且其最终计算出的 $ext\\_in(v)$ 大于 $0$ 的对象构成。\n\n2.  **存活集 R 的计算**：存活集 $R$ 包含 $S$ 中所有可从基础集 $B$ 出发、使用完全位于 $S$ 内部的路径到达的对象。这是一个在由 $S$ 导出的子图上的经典图可达性问题。该子图的节点是 $S$ 中的对象，其边是所有 $(u, v) \\in E$ 且 $u$ 和 $v$ 都在 $S$ 中的边。\n\n    一个从起始节点集（$B$）查找所有可达节点的有效算法是广度优先搜索（BFS）。算法如下：\n    - 初始化存活集 $R$ 为基础集 $B$ 的一个副本。\n    - 初始化一个用于遍历的队列，并将 $B$ 的所有元素入队。\n    - 当队列不为空时：\n        - 从队列中取出一个对象 $u$。\n        - 对于 $u$ 引用的每个对象 $v$（即，对于每个边 $(u, v) \\in E$）：\n            - 如果 $v$ 在候选集 $S$ 中，并且尚未被添加到存活集 $R$ 中，则将 $v$ 添加到 $R$ 中并将其入队。\n    - BFS 终止时，集合 $R$ 精确地包含了 $S$ 中所有可从 $B$ 通过 $S$ 内部路径到达的对象。\n\n3.  **可回收垃圾集 G_S 的计算**：问题将可回收垃圾集定义为 $G_S = S \\setminus R$。这是在候选集 $S$ 中但不在存活集 $R$ 中的对象集合。这些是 $S$ 中的对象，它们无法从任何外部源直接或间接通过其他存活对象的路径到达。\n\n    这最后一步是一个简单的集合差集操作。然后，根据问题规范的要求，将得到的对象标识符集合按升序排序。\n\n这个三步过程正确且高效地实现了在候选集 $S$ 上的指定试验性删除语义。实现将对每个提供的测试用例应用此逻辑。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the cyclic garbage collection problem based on trial deletion\n    semantics for a predefined suite of test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1: A simple cycle [0,1,2] that is garbage.\n        {\n            \"n\": 5,\n            \"E\": [(0, 1), (1, 2), (2, 0), (2, 3)],\n            \"ext\": [0, 0, 0, 1, 0],\n            \"S\": [0, 1, 2]\n        },\n        # Test case 2: Empty candidate set.\n        {\n            \"n\": 3,\n            \"E\": [(0, 1)],\n            \"ext\": [0, 0, 0],\n            \"S\": []\n        },\n        # Test case 3: A chain kept alive by an external reference.\n        {\n            \"n\": 3,\n            \"E\": [(0, 1), (1, 2)],\n            \"ext\": [1, 0, 0],\n            \"S\": [0, 1, 2]\n        },\n        # Test case 4: A cycle where S is a subset of the cycle, and an\n        #              external reference (from node 2) saves the S-subset.\n        {\n            \"n\": 3,\n            \"E\": [(0, 1), (1, 2), (2, 0)],\n            \"ext\": [0, 0, 0],\n            \"S\": [0, 1]\n        },\n        # Test case 5: A single-node cycle with no external refs.\n        {\n            \"n\": 1,\n            \"E\": [(0, 0)],\n            \"ext\": [0],\n            \"S\": [0]\n        },\n        # Test case 6: Two disjoint cycles. One is saved by an ext ref, one is not.\n        {\n            \"n\": 6,\n            \"E\": [(0, 1), (1, 2), (2, 0), (3, 4), (4, 5), (5, 3)],\n            \"ext\": [0, 1, 0, 0, 0, 0],\n            \"S\": [0, 1, 2, 3, 4, 5]\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        n, E, ext, S = case[\"n\"], case[\"E\"], case[\"ext\"], case[\"S\"]\n        \n        # For efficient lookups, convert S to a set.\n        S_set = set(S)\n        if not S_set:\n            results.append([])\n            continue\n\n        # Step 1: Compute the Base Set B\n        # B = { v in S | ext_in(v) > 0 }\n        # where ext_in(v) = ext(v) + |{(u,v) in E | u not in S}|\n        \n        ext_in = {v: ext[v] for v in S_set}\n        \n        # To find references from outside S, we can build a predecessor graph\n        # or iterate through all edges. Iterating through edges is straightforward.\n        for u, v in E:\n            if v in S_set and u not in S_set:\n                ext_in[v] += 1\n        \n        B = {v for v, count in ext_in.items() if count > 0}\n        \n        # Step 2: Compute the Survivor Set R\n        # R is the set of all vertices in S reachable from B using only edges within S.\n        # This is a graph traversal (BFS) starting from all nodes in B.\n        \n        adj = {i: [] for i in range(n)}\n        for u, v in E:\n            adj[u].append(v)\n            \n        R = set(B)\n        queue = list(B)\n        head = 0\n        \n        while head  len(queue):\n            u = queue[head]\n            head += 1\n            \n            for v in adj[u]:\n                # Traversal is restricted to paths within S\n                if v in S_set and v not in R:\n                    R.add(v)\n                    queue.append(v)\n\n        # Step 3: Compute the Recyclable Garbage Set G_S = S \\ R\n        G_S = S_set - R\n        \n        # Sort the results as required by the problem statement.\n        sorted_garbage = sorted(list(G_S))\n        results.append(sorted_garbage)\n\n    # Final print statement in the exact required format.\n    # The string representation of a list of lists, with no whitespace.\n    print(str(results).replace(' ', ''))\n\nsolve()\n```"
        },
        {
            "introduction": "与引用计数不同，追踪式垃圾回收器（如标记-清除算法）能够从本质上处理循环引用。然而，它们也引入了新的挑战，特别是如何高效地管理空闲内存。本练习要求你在一个标记-清除-压缩回收器框架下，模拟并比较两种基本的内存分配策略——“首次适应”与“最佳适应”，并通过测量外部碎片率来量化它们的性能。 通过这次模拟，你将对不同分配策略之间的权衡以及内存压缩在维持堆健康方面的关键作用获得具体的认识。",
            "id": "3236476",
            "problem": "你必须编写一个完整、可运行的程序，在一个标记-清除-紧凑收集方案中，模拟两种分配策略（首次适配和最佳适配）下的外部碎片情况，并比较它们在相同工作负载下的平均外部碎片。该模拟必须基于基本定义进行设计，而非使用任何现成的结果。\n\n定义和模型假设：\n- 托管堆与布局。堆是一个总大小为 $H$ 的一维字节数组。一个空闲列表 $\\mathcal{F}=\\{(s_i,\\ell_i)\\}_{i=1}^m$ 表示 $m$ 个空闲块，其中 $s_i$ 是起始地址，$\\ell_i$ 是以字节为单位的长度，这些块按地址排序且不重叠。对齐值为 $a$，每个请求的大小 $r$ 都会向上取整到不小于 $r$ 的最小 $a$ 的倍数。\n- 分配策略。对于一个大小为 $R$ 的对齐后分配请求，首次适配策略选择地址顺序上第一个满足 $\\ell_i\\ge R$ 的块 $(s_i,\\ell_i)$。最佳适配策略选择满足 $\\ell_i\\ge R$ 且 $\\ell_i$ 最小的块；若大小相同，则选择 $s_i$ 较小的块来打破平局。无论哪种情况，如果 $\\ell_i=R$，该块将从 $\\mathcal{F}$ 中移除；如果 $\\ell_iR$，该块被分割成一个在 $s_i$ 处大小为 $R$ 的已分配段和一个剩余的空闲块 $(s_i+R,\\ell_i-R)$。\n- 外部碎片度量。对于给定的空闲列表 $\\mathcal{F}$，当 $m\\ge 1$ 时，定义总空闲内存 $F=\\sum_{i=1}^{m}\\ell_i$ 和最大块 $L=\\max_{1\\le i\\le m}\\ell_i$；当 $m=0$ 时，设置 $F=0$ 和 $L=0$。那一刻的外部碎片为\n$$ E=\\begin{cases} 0,  \\text{if } F=0,\\\\ 1-\\frac{L}{F},  \\text{if } F>0. \\end{cases} $$\n- 标记-清除-紧凑方案与回收节奏。时间被划分为 $C$ 个周期。在每个周期内，依次进行 $A$ 次分配尝试。垃圾回收在每个周期之后（结束时）发生。当且仅当周期索引是 $P$ 的倍数时，该周期才会应用紧凑化。在没有紧凑化的周期结束时，方案执行标记-清除而不移动对象；释放的空间与相邻的空闲区域合并，形成新的空闲列表 $\\mathcal{F}$，作为 $[0,H)$ 中存活段的补集。在有紧凑化的周期结束时，所有存活对象按其地址顺序被连续地重定位到从地址 0 开始的位置，并创建一个单独的空闲块 $(U,H-U)$，其中 $U$ 是紧凑化后存活对象的总大小。\n- 存活性。每个已分配对象独立地拥有一个以其将存活的未来回收次数衡量的生命周期。设 $d$ 为每次回收的死亡概率，$s=1-d$ 为每次回收的存活概率。对于每个新分配的对象，从支撑集为 $\\{1,2,\\dots\\}$ 的几何分布 $S\\sim\\mathrm{Geometric}(d)$ 中抽取一个值，并将其存活次数设置为 $S-1\\in\\{0,1,2,\\dots\\}$。在每次回收时，当前存活计数器为 $k$ 的对象，如果 $k=0$ 则死亡，否则将其计数器更新为 $k-1$。\n- 分配失败处理。在一个周期内，如果一个分配请求无法被当前的空闲列表 $\\mathcal{F}$ 满足，该请求将被丢弃（不进行分配），模拟继续处理下一个请求。在一个周期内，除了周期结束时的回收外，不会触发任何其他回收。\n- 测量协议。在每次分配尝试之前，立即根据 $\\mathcal{F}$ 计算当前的外部碎片 $E$，并将其添加到一个用于该次运行的运行列表中。平均外部碎片是算术平均值 $\\bar{E}=\\dfrac{1}{T}\\sum_{t=1}^{T} E_t$，其中 $T=C\\cdot A$ 是总分配尝试次数，$E_t$ 是在运行的第 $t$ 次分配尝试之前立即计算的。报告的数值是分别针对首次适配和最佳适配的 $\\bar{E}$，它们在相同的工作负载和相同的随机性下进行测量。\n- 随机性与可复现性。对于给定的测试用例，请求的大小和生命周期使用指定的种子生成，并对两种策略完全相同地重用，以确保公平比较。请求大小作为整数在 $[r_{\\min},r_{\\max}]$ 范围内均匀随机抽取，然后向上对齐到 $a$。\n\n你的任务：\n- 遵循以上规则，实现一个包含两种分配策略（首次适配和最佳适配）的模拟器。对于每个提供的测试用例，使用给定的种子生成 $C\\cdot A$ 个请求大小和生命周期的序列，然后计算首次适配和最佳适配的平均外部碎片 $\\bar{E}$。\n- 对于每个测试用例，严格按照此顺序输出一个包含两个浮点数 $[\\bar{E}_{\\mathrm{first}},\\bar{E}_{\\mathrm{best}}]$ 的列表。所有浮点数必须使用标准的“四舍五入到最近”规则四舍五入到 $6$ 位小数，当平局时，可接受如典型浮点格式化中远离零的舍入方式。\n\n测试套件：\n使用以下参数集，每个参数集由一个元组 $(H,C,P,A,r_{\\min},r_{\\max},a,d,\\text{seed})$ 完全指定。\n- 测试 $1$：$(H,C,P,A,r_{\\min},r_{\\max},a,d,\\text{seed})=(300000,20,5,800,8,128,8,0.3,42)$。\n- 测试 $2$：$(H,C,P,A,r_{\\min},r_{\\max},a,d,\\text{seed})=(300000,10,1,800,8,128,8,0.4,12345)$。\n- 测试 $3$：$(H,C,P,A,r_{\\min},r_{\\max},a,d,\\text{seed})=(250000,25,7,600,8,128,8,0.2,2024)$。\n- 测试 $4$：$(H,C,P,A,r_{\\min},r_{\\max},a,d,\\text{seed})=(50000,10,3,500,8,64,8,1.0,777)$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个由方括号括起来的、逗号分隔的列表。此顶层列表的每个元素对应一个测试用例，顺序与上面列出的一致，并且本身是一个双元素列表 $[\\bar{E}_{\\mathrm{first}},\\bar{E}_{\\mathrm{best}}]$。例如，一个有效的输出看起来像\n\"[ [0.012345,0.009876],[0.000000,0.000000],[0.023456,0.019999],[0.000000,0.000000] ]\"\n但其中的实际数字由你的模拟确定，并且除非你的编程语言插入空格，否则不应包含空格；你的实际程序必须严格按照指定格式打印一行。",
            "solution": "该问题要求实现一个内存管理堆的离散时间模拟，以比较首次适配和最佳适配分配策略产生的外部碎片。该模拟必须遵守一套关于内存布局、分配、垃圾回收（包括周期性紧凑化）、对象存活性和测量的特定规则。\n\n该模型基于计算机科学中内存管理的既定原则。堆是一个大小为 $H$ 的连续内存块。堆在任何时刻的状态由已分配对象的集合和空闲块的集合表示。在此模拟中，它们被维护为两个独立的列表，两者都按起始内存地址排序。\n\n- 已分配对象列表包含形式为 $(s, \\ell, k)$ 的元组，表示一个起始地址为 $s$、长度为 $\\ell$、存活计数器为 $k$ 的对象。\n- 空闲列表，记作 $\\mathcal{F}$，包含元组 $(s_i, \\ell_i)$，表示一个地址为 $s_i$、长度为 $\\ell_i$ 的空闲块。\n\n保持这些列表有序至关重要。它确保了首次适配策略（选择地址顺序上的第一个可用块）可以通过简单的线性扫描实现。它还能正确处理最佳适配策略的平局打破规则（在具有最小合适尺寸的块中选择起始地址较低的那个）。此外，有序的存活对象列表对于垃圾回收的清除和紧凑化阶段都至关重要。Python 的 `bisect` 模块被用来在插入操作期间高效地维护这种有序状态。\n\n模拟进行 $C$ 个周期，每个周期包含 $A$ 次分配尝试。工作负载由 $C \\times A$ 对（请求大小，生命周期）组成，使用指定的随机种子预先生成，以确保两种分配策略都在完全相同的请求序列下进行测试，从而实现公平比较。\n- **请求生成**：原始请求大小 $r$ 从 $[r_{\\min}, r_{\\max}]$ 中均匀抽取。然后每个大小都向上对齐到对齐值 $a$ 的倍数，得到实际请求的大小 $R$。计算方式为 $R = \\lceil r/a \\rceil \\times a$。\n- **存活性模型**：对象的生命周期由每次回收的死亡概率 $d$ 决定。一个对象存活的回收次数 $S$ 服从支撑集为 {$1, 2, \\dots$} 的几何分布 $S \\sim \\mathrm{Geometric}(d)$。一个新分配的对象被赋予一个值为 $S-1$ 的存活计数器。\n\n对于总共 $T = C \\times A$ 次的每一次分配尝试，模拟遵循以下步骤：\n$1$。**测量碎片**：在一次分配尝试之前，立即从当前空闲列表 $\\mathcal{F}$ 计算外部碎片 $E$。使用总空闲内存 $F = \\sum \\ell_i$ 和最大空闲块大小 $L = \\max \\ell_i$，当 $F>0$ 时碎片率为 $E = 1 - L/F$，当 $F=0$ 时为 $E=0$。该值被记录下来。\n$2$。**分配**：处理一个大小为 $R$ 的对齐请求。\n   - **首次适配**：按地址顺序扫描空闲列表 $\\mathcal{F}$，并选择第一个满足 $\\ell_i \\ge R$ 的块 $(s_i, \\ell_i)$。\n   - **最佳适配**：完全扫描空闲列表 $\\mathcal{F}$，以找到一个满足 $\\ell_i \\ge R$ 并使 $\\ell_i$ 最小化的块。\n如果找到一个合适的块，它将被用于分配。如果其大小 $\\ell_i$ 大于 $R$，该块将被分割，创建一个大小为 $R$ 的新分配对象和一个大小为 $\\ell_i - R$ 的较小空闲块。如果 $\\ell_i = R$，则使用整个块。如果找不到合适的块，分配请求失败并被丢弃。\n\n$3$。**垃圾回收**：每 $A$ 次分配后（在每个周期结束时），执行一次垃圾回收。\n   - **存活性更新**：对于每个存活计数器为 $k$ 的已分配对象，如果 $k=0$，该对象被标记为死亡。如果 $k>0$，其计数器递减为 $k-1$。\n   - **紧凑化**：如果周期索引是紧凑化周期 $P$ 的倍数，则执行一个紧凑化阶段。所有存活对象按照它们现有的相对地址顺序，被重定位到堆的起始位置（从地址 $0$ 开始）。这消除了所有碎片，从而形成一个单独的连续存活数据块，后跟一个单独的大空闲块。\n   - **清除（无紧凑化）**：如果不是紧凑化周期，则执行一次清除操作。死亡对象占用的内存被回收。通过识别剩余的（已排序的）存活对象与堆边界之间的间隙来构建一个新的空闲列表 $\\mathcal{F}$。这个过程隐式地合并了相邻的空闲空间。\n\n每种策略的最终报告值是所有在 $T$ 次分配尝试前记录的碎片值的算术平均值 $\\bar{E}$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport bisect\n\nclass MemorySimulator:\n    \"\"\"\n    Simulates heap memory management with first-fit or best-fit allocation,\n    and a mark-sweep-compact garbage collector.\n    \"\"\"\n    def __init__(self, params, workload, strategy):\n        \"\"\"\n        Initializes the simulator with given parameters.\n        \n        Args:\n            params (tuple): Simulation parameters (H, C, P, A, ...).\n            workload (list): A list of (request_size, survival_counter) tuples.\n            strategy (str): Allocation strategy, 'first_fit' or 'best_fit'.\n        \"\"\"\n        (self.H, self.C, self.P, self.A, \n         self.r_min, self.r_max, self.a, self.d, self.seed) = params\n        self.workload = workload\n        self.strategy = strategy\n        \n        # State variables\n        self.allocated_objects = []  # List of (start, size, survival_counter)\n        self.free_list = [(0, self.H)] # List of (start, size)\n        self.fragmentation_scores = []\n\n    def run_simulation(self):\n        \"\"\"\n        Executes the full simulation over all cycles and allocation attempts.\n        \n        Returns:\n            float: The average external fragmentation over the simulation run.\n        \"\"\"\n        workload_idx = 0\n        for c in range(1, self.C + 1):\n            for _ in range(self.A):\n                self._measure_fragmentation()\n                \n                request_size, survival_counter = self.workload[workload_idx]\n                self._allocate(request_size, survival_counter)\n                workload_idx += 1\n                \n            self._collect_garbage(c)\n        \n        if not self.fragmentation_scores:\n            return 0.0\n        return np.mean(self.fragmentation_scores)\n\n    def _measure_fragmentation(self):\n        \"\"\"\n        Calculates and records the current external fragmentation.\n        \"\"\"\n        if not self.free_list:\n            total_free, largest_block = 0, 0\n        else:\n            free_block_sizes = [block[1] for block in self.free_list]\n            total_free = sum(free_block_sizes)\n            largest_block = max(free_block_sizes)\n        \n        fragmentation = 0.0 if total_free == 0 else 1.0 - (largest_block / total_free)\n        self.fragmentation_scores.append(fragmentation)\n\n    def _find_block_idx(self, size):\n        \"\"\"Finds a suitable free block index based on the allocation strategy.\"\"\"\n        if self.strategy == 'first_fit':\n            for i, (_, length) in enumerate(self.free_list):\n                if length >= size:\n                    return i\n            return None\n        \n        elif self.strategy == 'best_fit':\n            best_idx = -1\n            min_size = float('inf')\n            # The free list is sorted by address, so the first match in case of a\n            # size tie will have the smallest start address, satisfying the\n            # tie-breaking rule.\n            for i, (_, length) in enumerate(self.free_list):\n                if length >= size:\n                    if length  min_size:\n                        min_size = length\n                        best_idx = i\n            return best_idx if best_idx != -1 else None\n\n    def _allocate(self, size, survival_counter):\n        \"\"\"Attempts to allocate a block of memory of a given size.\"\"\"\n        block_idx = self._find_block_idx(size)\n        if block_idx is not None:\n            start, length = self.free_list.pop(block_idx)\n            \n            # Add to allocated list, keeping it sorted by start address.\n            new_obj = (start, size, survival_counter)\n            bisect.insort_left(self.allocated_objects, new_obj)\n            \n            # If the block was larger than needed, return remainder to free list.\n            if length > size:\n                new_free_block = (start + size, length - size)\n                bisect.insort_left(self.free_list, new_free_block)\n\n    def _collect_garbage(self, cycle_num):\n        \"\"\"Performs garbage collection at the end of a cycle.\"\"\"\n        # Identify live objects and decrement their survival counters.\n        live_objects = []\n        for obj in self.allocated_objects:\n            if obj[2] > 0:  # Object survives if counter > 0\n                live_objects.append((obj[0], obj[1], obj[2] - 1))\n        \n        self.allocated_objects = live_objects\n\n        # Perform compaction or sweep.\n        if cycle_num % self.P == 0:\n            # Compaction: Relocate all live objects to the start of the heap.\n            current_addr = 0\n            compacted_objects = []\n            for _, size, counter in self.allocated_objects:\n                compacted_objects.append((current_addr, size, counter))\n                current_addr += size\n            self.allocated_objects = compacted_objects\n            self.free_list = [] if current_addr >= self.H else [(current_addr, self.H - current_addr)]\n        else:\n            # Sweep: Rebuild free list from gaps between live objects.\n            self.free_list = []\n            last_addr = 0\n            for start, size, _ in self.allocated_objects:\n                if start > last_addr:\n                    self.free_list.append((last_addr, start - last_addr))\n                last_addr = start + size\n            if last_addr  self.H:\n                self.free_list.append((last_addr, self.H - last_addr))\n                \ndef solve():\n    \"\"\"\n    Main function to run simulations for all test cases and print results.\n    \"\"\"\n    test_cases = [\n        (300000, 20, 5, 800, 8, 128, 8, 0.3, 42),\n        (300000, 10, 1, 800, 8, 128, 8, 0.4, 12345),\n        (250000, 25, 7, 600, 8, 128, 8, 0.2, 2024),\n        (50000, 10, 3, 500, 8, 64, 8, 1.0, 777),\n    ]\n\n    all_results = []\n    for params in test_cases:\n        H, C, P, A, r_min, r_max, a, d, seed = params\n        \n        # 1. Generate a single, reproducible workload for the test case.\n        rng = np.random.default_rng(seed)\n        total_attempts = C * A\n        \n        request_sizes = rng.integers(r_min, r_max + 1, size=total_attempts)\n        aligned_sizes = np.ceil(request_sizes / a) * a\n        aligned_sizes = aligned_sizes.astype(int)\n        \n        # S ~ Geometric(d) on {1, 2, ...}, survival counter is S-1\n        survival_draws = rng.geometric(p=d, size=total_attempts)\n        survival_counters = survival_draws - 1\n\n        workload = list(zip(aligned_sizes, survival_counters))\n\n        # 2. Run simulation for First-Fit\n        sim_ff = MemorySimulator(params, workload, 'first_fit')\n        avg_frag_ff = sim_ff.run_simulation()\n\n        # 3. Run simulation for Best-Fit using the same workload\n        sim_bf = MemorySimulator(params, workload, 'best_fit')\n        avg_frag_bf = sim_bf.run_simulation()\n\n        all_results.append([avg_frag_ff, avg_frag_bf])\n\n    # 4. Format and print the final output string exactly as required.\n    result_strings = [f\"[{ff:.6f},{bf:.6f}]\" for ff, bf in all_results]\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "现实世界的应用程序通常表现出一种共同的行为：大多数对象“生命短暂”。现代垃圾回收器利用“分代假设”来优化性能，这使得它们极为高效。本练习将让你构建一个双代垃圾回收器的模拟器，并设计一种有意违反弱分代假设的分配模式，以观察和衡量由此产生的性能下降。 这个练习将巩固你对分代回收为何如此高效的理解，并揭示当其基本假设不成立时会发生什么，从而突显对象分配模式与GC性能之间的密切联系。",
            "id": "3236439",
            "problem": "你必须编写一个完整、可运行的程序，模拟一个简化的两代垃圾回收器 (GC)，并评估一个故意违反弱分代假说的具体分配模式。弱分代假说断言，大多数对象都很年轻就死亡；而这种违规模式则会产生许多中等寿命的对象，它们存活足够多的次要回收后被晋升，然后在老年代中很快死亡，从而导致低效的晋升和昂贵的主要回收。\n\n请从以下基础开始：\n- 垃圾回收器 (GC) 术语和核心定义：\n  - 分代 GC 将堆对象划分为不相交的几代。新生代被频繁回收（次要回收），老年代则较少被回收（主要回收）。\n  - 当一个对象在经历指定次数的次要回收后仍然存活时，就会发生晋升。\n  - 一次回收会扫描一组对象，以识别哪些是死的（不可达的）并回收它们。\n- 弱分代假说是一个经验性观察，即大多数对象都很年轻就死亡。\n- 标记-清除回收会扫描并移除死对象，而不移动存活对象；在本问题中，对象是抽象的，其可达性通过一个生命周期计数器进行确定性建模，而非通过图遍历。\n\n要实现的模型：\n- 堆模型：\n  - 两代：新生代和老年代。\n  - 容量：新生代容量 $C_y$ 和老年代容量 $C_o$，以对象数量计算。\n- 对象模型：\n  - 每个对象都具有：\n    - 以时间步为单位的剩余生命周期 $L \\in \\mathbb{Z}_{\\ge 0}$。当 $L \\le 0$ 时，对象被视为死亡。\n    - 次要回收存活年龄 $a \\in \\mathbb{Z}_{\\ge 0}$，即对象在新生代中存活所经历的次要回收次数。\n    - 一个分代标签，新生代或老年代。\n- 分配模式：\n  - 在每个离散时间步 $t \\in \\{1,2,\\dots,T\\}$，会有 $A$ 个新对象被分配到新生代中。\n  - 在测试用例中分配的第 $i$ 个对象会获得一个确定性的生命周期，该生命周期通过在整数区间 $[L_{\\min}, L_{\\max}]$（包含两端）内循环分配：整个运行过程中的第 $k$ 次分配被赋值为\n    $$L = L_{\\min} + \\left((k - 1) \\bmod (L_{\\max} - L_{\\min} + 1)\\right)。$$\n  - 这种循环消除了随机性，使模拟过程具有确定性。\n- 每个时间步的时间和 GC 事件（严格顺序）：\n  1. 如上所述，分配 $A$ 个新的新生代对象。\n  2. 当新生代对象数量超过 $C_y$ 时，运行一次要回收：\n     - 扫描所有当前的新生代对象（计入成本，见下文）。\n     - 移除死的新生代对象（$L \\le 0$ 的对象）。\n     - 对于每个存活的新生代对象，将其次要回收存活年龄增加 $a \\leftarrow a + 1$。\n     - 如果 $a \\ge p$（晋升阈值），则将该对象晋升到老年代，并重置其年龄记录（晋升后可以丢弃 $a$）。\n     - 计算每次晋升。\n  3. 将两代中所有对象的 $L$ 减 1，即 $L \\leftarrow L - 1$（这模拟了一个时间步的流逝）。\n  4. 当老年代对象数量超过 $C_o$ 时，运行一次主要回收：\n     - 扫描两代中的所有对象（计入成本，见下文）。\n     - 移除死的老年代对象（$L \\le 0$ 的对象）。\n     - 在此模型中，主要回收不会晋升新生代对象。\n- 成本模型：\n  - 分配标量成本来近似工作量：\n    - 次要回收成本是 $\\alpha$ 乘以回收开始时扫描的新生代对象数量。\n    - 主要回收成本是 $\\beta$ 乘以回收开始时扫描的两代中对象总数。\n    - 晋升成本是每个晋升对象 $\\gamma$。\n  - 总 GC 成本是整个运行过程中所有扫描成本和晋升成本的总和。\n- 低效率指数：\n  - 将低效率指数定义为\n    $$I = \\frac{\\text{总 GC 成本}}{\\text{总分配次数}} = \\frac{\\text{总 GC 成本}}{T \\cdot A}。$$\n\n违反弱分代假说的具体模式：\n- 选择合适的生命周期，使得大多数对象存活的时间刚好足够经历足够多的次要回收从而被晋升（达到或超过晋升阈值 $p$），但之后很快就在老年代中死亡。这会导致频繁的晋升和昂贵的主要回收，因为许多晋升的对象并不会长期存活。\n- 次要回收的频率由负载决定；如果新生代大约在 $s = \\left\\lceil \\frac{C_y}{A} \\right\\rceil$ 步后填满，那么将生命周期设置在 $p \\cdot s$ 附近可以确保许多对象会被晋升并很快死亡。在下面的测试套件中，提供的 $(L_{\\min}, L_{\\max})$ 值就是为了具体实例化这种模式而选择的。\n\n所有测试中使用的常量：\n- 次要回收扫描权重 $\\alpha = 1.0$。\n- 主要回收扫描权重 $\\beta = 5.0$。\n- 晋升成本 $\\gamma = 0.2$。\n\n你的任务：\n- 完全按照规定实现模拟器。\n- 对于每个测试用例，计算上面定义的低效率指数 $I$。\n- 你的程序必须在没有输入的情况下执行，并且必须打印一行包含按指定顺序排列的十进制数列表。\n\n测试套件：\n- 每个测试用例都以元组 $(C_y, C_o, p, A, T, L_{\\min}, L_{\\max})$ 的形式给出。\n- 使用以下四个测试用例，它们展示了不同的行为：\n  1. 弱分代假说的“理想路径”违规情况：\n     - $(C_y, C_o, p, A, T, L_{\\min}, L_{\\max}) = (100, 500, 2, 30, 200, 9, 10)$.\n  2. 大多数对象年轻时死亡的合规工作负载：\n     - $(C_y, C_o, p, A, T, L_{\\min}, L_{\\max}) = (100, 500, 2, 30, 200, 1, 3)$.\n  3. 具有极其频繁的次要回收和立即晋升的边界情况：\n     - $(C_y, C_o, p, A, T, L_{\\min}, L_{\\max}) = (30, 60, 1, 40, 120, 2, 2)$.\n  4. 即使在违规模式下，大的老年代容量也会延迟主要回收：\n     - $(C_y, C_o, p, A, T, L_{\\min}, L_{\\max}) = (50, 10000, 2, 25, 300, 5, 6)$.\n\n要求的最终输出格式：\n- 你的程序应该产生单行输出，其中包含四个测试用例的低效率指数，以逗号分隔的列表形式放在方括号内，顺序与上面列出的一致。例如，格式必须如下所示：\n  $$[I_1, I_2, I_3, I_4].$$\n- 每个 $I_k$ 都必须打印为十进制数。如果你愿意，可以将它们格式化为固定的小数位数，但它们必须是有效的十进制数字。",
            "solution": "问题陈述是有效的。它在计算机科学领域，特别是关于内存管理算法方面，提出了一个定义明确、自成体系且有科学依据的模拟任务。参数、规则和目标都以足够的精度进行了规定，从而能够得出一个唯一的、确定性的解决方案。\n\n### 步骤 1：提取已知条件\n\n- **分代 GC 模型**：一个具有两代（新生代和老年代）的垃圾回收器 (GC)。\n- **堆容量**：新生代容量 $C_y$，老年代容量 $C_o$。\n- **对象状态**：每个对象拥有一个剩余生命周期 $L \\in \\mathbb{Z}_{\\ge 0}$，一个次要回收存活年龄 $a \\in \\mathbb{Z}_{\\ge 0}$，以及一个分代标签（新生代或老年代）。如果 $L \\le 0$，则对象死亡。\n- **晋升阈值**：如果一个对象的次要回收存活年龄 $a$ 达到或超过阈值 $p$（即 $a \\ge p$），它就会从新生代晋升到老年代。\n- **模拟时间**：模拟运行 $T$ 个离散时间步，从 $t=1$ 到 $t=T$。\n- **分配模式**：在每个时间步 $t$，$A$ 个新对象被分配到新生代。\n- **生命周期分配**：模拟期间分配的第 $k$ 个对象的生命周期被赋值为 $L = L_{\\min} + \\left((k - 1) \\bmod (L_{\\max} - L_{\\min} + 1)\\right)$。\n- **每个时间步的操作顺序**：\n    1.  将 $A$ 个新对象分配到新生代中。\n    2.  只要新生代对象数量超过 $C_y$，就循环执行次要回收。\n    3.  将两代中所有对象的生命周期 $L$ 减 1。\n    4.  只要老年代对象数量超过 $C_o$，就循环执行主要回收。\n- **次要回收过程**：\n    - 产生的成本是 $\\alpha$ 乘以回收开始时新生代中的对象数量。\n    - 新生代中所有死对象（$L \\le 0$）被移除。\n    - 每个存活的新生代对象的次要回收存活年龄 $a$ 增加。\n    - $a \\ge p$ 的存活新生代对象被晋升到老年代。每次晋升的成本是 $\\gamma$。\n- **主要回收过程**：\n    - 产生的成本是 $\\beta$ 乘以回收开始时两代中的对象总数。\n    - 老年代中所有死对象（$L \\le 0$）被移除。\n- **成本模型常量**：\n    - 次要回收扫描权重：$\\alpha = 1.0$。\n    - 主要回收扫描权重：$\\beta = 5.0$。\n    - 晋升成本：$\\gamma = 0.2$。\n- **低效率指数**：评估指标为 $I = \\frac{\\text{总 GC 成本}}{\\text{总分配次数}} = \\frac{\\text{总 GC 成本}}{T \\cdot A}$。\n- **测试套件**：\n    1.  $(C_y, C_o, p, A, T, L_{\\min}, L_{\\max}) = (100, 500, 2, 30, 200, 9, 10)$。\n    2.  $(C_y, C_o, p, A, T, L_{\\min}, L_{\\max}) = (100, 500, 2, 30, 200, 1, 3)$。\n    3.  $(C_y, C_o, p, A, T, L_{\\min}, L_{\\max}) = (30, 60, 1, 40, 120, 2, 2)$。\n    4.  $(C_y, C_o, p, A, T, L_{\\min}, L_{\\max}) = (50, 10000, 2, 25, 300, 5, 6)$。\n\n### 步骤 2：验证已知条件\n\n提供的问题陈述是有效的。\n- **科学依据**：该模型是一个双代垃圾回收器的简化但标准的表示，这是系统编程和计算机科学中的一个基本概念。弱分代假说是推动此项设计的公认经验法则。该问题是基于这些思想的确定性模拟。\n- **良态问题**：所有参数和操作规则都已明确定义，确保模拟在每一步的状态都是唯一且可计算的。问题的结构旨在为每个测试用例产生一个单一、有意义的数值结果 ($I$）。\n- **客观性**：问题使用精确的技术语言，避免了主观性。所有量都经过了形式化定义。\n\n问题表述没有指定的缺陷（例如，科学上不健全、不完整、模棱两可）。这是一个形式化的、可解决的问题。\n\n### 步骤 3：求解过程\n\n将根据指定的模型实现一个确定性模拟。系统在任何时间点的状态由新生代和老年代中的对象集合、它们各自的生命周期和年龄，以及累积的 GC 成本定义。\n\n**状态表示**\n堆将由两个对象集合表示，一个用于新生代，一个用于老年代。每个对象将是一个封装其状态（剩余生命周期 $L$ 和次要回收存活年龄 $a$）的类的实例。\n\n- `young_generation`：新生代中的对象列表。\n- `old_generation`：老年代中的对象列表。\n- `total_gc_cost`：一个浮点数，用于跟踪累积成本。\n- `total_allocations_count`：一个整数 $k$，用于跟踪到目前为止已分配的对象总数，从 1 开始。\n\n**模拟算法**\n模拟通过从 $1$ 到 $T$ 的离散时间步 $t$ 进行。\n\n对于每个具有参数 $(C_y, C_o, p, A, T, L_{\\min}, L_{\\max})$ 的测试用例：\n1.  将 `young_generation` 和 `old_generation` 初始化为空。初始化 `total_gc_cost = 0.0` 和 `total_allocations_count = 0`。\n2.  开始主循环：对于从 $1$ 到 $T$ 的 $t$：\n    a.  **分配**：\n        - 生成 $A$ 个新对象。对于每个 $j \\in \\{1, \\dots, A\\}$：\n            - 增加 `total_allocations_count`。设当前值为 $k$。\n            - 计算对象生命周期：$L = L_{\\min} + \\left((k - 1) \\bmod (L_{\\max} - L_{\\min} + 1)\\right)$。\n            - 创建一个具有此生命周期 $L$ 和初始年龄 $a=0$ 的新对象。\n            - 将该对象添加到 `young_generation`。\n\n    b.  **次要回收阶段**：\n        - 循环 `while` `young_generation` 中的对象数量大于 $C_y$：\n            i.   将 $\\alpha \\times |\\text{young\\_generation}|$ 加到 `total_gc_cost`。\n            ii.  创建三个临时列表：`survivors`、`promoted`、`next_young_generation`。\n            iii. 对于 `young_generation` 中的每个对象：\n                 - 如果其生命周期 $L > 0$，它就是一个存活者。增加其年龄：$a \\leftarrow a + 1$。\n                 - 如果其新年龄 $a \\ge p$，将其添加到 `promoted` 列表。\n                 - 否则（如果 $L > 0$ 且 $a  p$），将其添加到 `next_young_generation` 列表。\n            iv.  将 `promoted` 对象添加到 `old_generation`。\n            v.   将 $\\gamma \\times |\\text{promoted}|$ 加到 `total_gc_cost`。\n            vi.  用 `next_young_generation` 替换 `young_generation`。\n\n    c.  **时间推进**：\n        - 对于 `young_generation` 中的每个对象，将其生命周期减一：$L \\leftarrow L - 1$。\n        - 对于 `old_generation` 中的每个对象，将其生命周期减一：$L \\leftarrow L - 1$。\n\n    d.  **主要回收阶段**：\n        - 循环 `while` `old_generation` 中的对象数量大于 $C_o$：\n            i.   将 $\\beta \\times (|\\text{young\\_generation}| + |\\text{old\\_generation}|)$ 加到 `total_gc_cost`。\n            ii.  就地过滤 `old_generation`，只保留 $L > 0$ 的对象。\n\n3.  **最终计算**：\n    - 在 $T$ 步的循环完成后，计算低效率指数：\n      $$I = \\frac{\\text{total\\_gc_cost}}{T \\cdot A}$$\n    - 存储此值。\n\n对所提供的四个测试用例中的每一个执行此过程，并收集得出的指数。",
            "answer": "```python\nimport numpy as np\n\n# Constants from the problem statement\nALPHA = 1.0  # Minor scan weight\nBETA = 5.0   # Major scan weight\nGAMMA = 0.2  # Promotion cost\n\nclass Object:\n    \"\"\"Represents an object in the heap with its state.\"\"\"\n    def __init__(self, lifetime):\n        self.lifetime = lifetime\n        self.age = 0  # Minor-survival age\n\ndef run_simulation(Cy, Co, p, A, T, Lmin, Lmax):\n    \"\"\"\n    Runs a single simulation for a given set of GC parameters.\n    \n    Args:\n        Cy (int): Young generation capacity.\n        Co (int): Old generation capacity.\n        p (int): Promotion threshold (age).\n        A (int): Allocations per time step.\n        T (int): Total time steps for the simulation.\n        Lmin (int): Minimum lifetime for allocated objects.\n        Lmax (int): Maximum lifetime for allocated objects.\n    \n    Returns:\n        float: The calculated inefficiency index.\n    \"\"\"\n    young_gen = []\n    old_gen = []\n    total_gc_cost = 0.0\n    total_allocations_count = 0\n    \n    lifetime_range_size = Lmax - Lmin + 1\n\n    for _ in range(1, T + 1):\n        # 1. Allocate A new objects\n        for _ in range(A):\n            total_allocations_count += 1\n            lifetime_offset = (total_allocations_count - 1) % lifetime_range_size\n            lifetime = Lmin + lifetime_offset\n            new_obj = Object(lifetime)\n            young_gen.append(new_obj)\n\n        # 2. Minor collection phase\n        while len(young_gen) > Cy:\n            # Add cost for scanning young generation\n            total_gc_cost += ALPHA * len(young_gen)\n            \n            survivors = []\n            promoted_count = 0\n            \n            # Identify survivors and objects to be promoted\n            for obj in young_gen:\n                if obj.lifetime > 0:\n                    obj.age += 1\n                    if obj.age >= p:\n                        # This object gets promoted. Resetting its age is not\n                        # strictly necessary as it's no longer used.\n                        old_gen.append(obj)\n                        promoted_count += 1\n                    else:\n                        survivors.append(obj)\n            \n            # Add promotion cost\n            total_gc_cost += GAMMA * promoted_count\n            \n            # Update the young generation\n            young_gen = survivors\n\n        # 3. Decrement lifetime for all objects\n        for obj in young_gen:\n            obj.lifetime -= 1\n        for obj in old_gen:\n            obj.lifetime -= 1\n\n        # 4. Major collection phase\n        while len(old_gen) > Co:\n            # Add cost for scanning both generations\n            total_gc_cost += BETA * (len(young_gen) + len(old_gen))\n            \n            # Reclaim dead objects in the old generation\n            old_gen = [obj for obj in old_gen if obj.lifetime > 0]\n\n    # Calculate the inefficiency index\n    total_allocations = T * A\n    if total_allocations == 0:\n        return 0.0\n    \n    inefficiency_index = total_gc_cost / total_allocations\n    return inefficiency_index\n\ndef solve():\n    \"\"\"\n    Executes the simulation for all test cases and prints the results.\n    \"\"\"\n    test_cases = [\n        # (Cy, Co, p, A, T, Lmin, Lmax)\n        (100, 500, 2, 30, 200, 9, 10),    # 1. Weak generational hypothesis violation\n        (100, 500, 2, 30, 200, 1, 3),     # 2. Conforming workload (objects die young)\n        (30, 60, 1, 40, 120, 2, 2),       # 3. Frequent GCs and immediate promotions\n        (50, 10000, 2, 25, 300, 5, 6),    # 4. Large old gen delaying major collections\n    ]\n\n    results = []\n    for params in test_cases:\n        result = run_simulation(*params)\n        results.append(result)\n\n    # Format output as a comma-separated list in brackets\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}