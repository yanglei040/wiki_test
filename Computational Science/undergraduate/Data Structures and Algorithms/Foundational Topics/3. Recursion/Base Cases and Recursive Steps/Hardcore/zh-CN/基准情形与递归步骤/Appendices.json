{
    "hands_on_practices": [
        {
            "introduction": "硬币找零问题是组合计数中的一个经典范例。其递归解法优美地展示了“包含/排除”这一核心策略：将问题分解为包含某个元素和不包含该元素的子问题。这种思维模式是设计许多递归算法的强大工具。",
            "id": "3213512",
            "problem": "你需要设计并实现一个递归过程，用于计算使用无限数量的硬币类型凑成一个非负整数总额的不同方式的数量，其中顺序无关。设 $S$ 是一个包含 $m$ 个正整数的数组，代表硬币的面额，设 $n$ 为目标总和。该计数函数必须基于组合枚举和递归分解的基本原理，并且必须正确处理所有防止无限递归并确保正确性的基本情况。\n\n形式上，定义一个函数 $count(S, m, n)$，它返回 $S$ 中前 $m$ 种硬币类型组成总和为 $n$ 的不同多重集的数量。仅硬币顺序不同的相同多重集表示必须被视为同一种（例如，使用硬币 $[1,2,2]$ 和 $[2,1,2]$ 没有区别）。每种硬币类型都可以使用任意非负次数。\n\n你的设计必须从组合计数的基本定义出发，并且必须使用一个将解空间划分为不相交子问题的递归步骤。该函数必须实现并论证以下基本情况：\n- $n = 0$ 应返回 $1$，对应于空多重集是凑成零的一种有效方式。\n- $n  0$ 应返回 $0$，因为正数面额的多重集不可能加和成一个负数目标。\n- $m \\le 0$ 且 $n > 0$ 应返回 $0$，因为在没有可用硬币类型的情况下，无法凑成一个正数总和。\n\n你的程序必须使用与这些基本情况一致的递归来实现 $count(S, m, n)$，并采用从组合计数原理推导出的逻辑上合理的递归步骤。实现不得依赖任何非递归的捷径；任何优化都必须保留递归结构。\n\n不涉及物理单位、角度或百分比。所有输出均为整数。\n\n测试套件：\n按给定的确切顺序为以下参数集计算 $count(S, m, n)$：\n- 情况 1：S = [2, 3, 5, 6], m = 4, n = 10。\n- 情况 2：S = [2, 3, 5, 6], m = 4, n = 0。\n- 情况 3：S = [2, 3], m = 0, n = 7。\n- 情况 4：S = [1, 2, 3], m = 3, n = 4。\n- 情况 5：S = [1, 2, 5], m = 2, n = 5。\n- 情况 6：S = [2], m = 1, n = -5。\n\n最终输出格式：\n你的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的结果与测试套件的顺序完全一致（例如，[$r_1$,$r_2$,$r_3$,$r_4$,$r_5$,$r_6$]，其中每个 $r_i$ 是情况 $i$ 的整数结果）。",
            "solution": "用户提出的问题是组合枚举和算法设计中的一个经典练习，通常被称为硬币找零问题（或整数划分问题的变种）。任务是构建一个递归函数 $count(S, m, n)$，用于计算使用数组 $S$ 中给定的前 $m$ 种硬币面额凑成总和 $n$ 的不同方式的数量。该问题要求一个从基本原理出发的解决方案，特别是递归分解和对指定基本情况的显式处理。\n\n递归解决方案的设计基于将问题的解空间划分为一系列更小的不相交子问题的原则。解的总数就是这些子问题解的和。令 $C(m, n)$ 表示函数 $count(S, m, n)$，代表使用集合 $\\{S[0], S[1], \\dots, S[m-1]\\}$ 中的硬币凑成总和 $n$ 的方法数。\n\n递归步骤的核心是考虑可用集合中的最后一种硬币，即 $S[m-1]$（假设数组 $S$ 是零基索引的）。凑成总和 $n$ 的每一种可能方式，要么至少使用一次该硬币，要么完全不使用它。这两类情况是互斥且穷尽的，构成了对解空间的完美划分。\n\n1.  **不包含第 $m$ 种硬币 ($S[m-1]$) 的解：** 如果我们决定不使用硬币 $S[m-1]$，问题就简化为仅使用剩下的 $m-1$ 种硬币（即 $\\{S[0], \\dots, S[m-2]\\}$）凑成总和 $n$ 的方法数。根据定义，这个方法数是 $C(m-1, n)$。\n\n2.  **至少包含一次第 $m$ 种硬币 ($S[m-1]$) 的解：** 如果我们确定至少使用一次硬币 $S[m-1]$，我们可以先拿出一个这样的硬币。剩下需要凑成的总和是 $n - S[m-1]$。这个剩余的总和必须使用可用集合中的硬币来凑成。由于硬币可无限次重复使用，可用的硬币集合仍然是 $\\{S[0], \\dots, S[m-1]\\}$。因此，凑成这个剩余总和的方法数是 $C(m, n - S[m-1])$。\n\n根据组合学的加法法则，用前 $m$ 种硬币凑成总和 $n$ 的总方法数是这两个不相交集合中解的数量之和。这给出了基本的递推关系：\n$$C(m, n) = C(m-1, n) + C(m, n - S[m-1])$$\n\n这个递推关系必须由终止递归的基本情况来锚定。问题陈述中提供了这些基本情况，其理由如下：\n\n-   **基本情况 1: $n = 0$**\n    函数必须返回 $1$。目标总和为 $0$ 只能通过一种方式实现：不选择任何硬币（即空多重集）。无论可用的硬币是什么，这一点都成立，因此对于任何 $m \\ge 0$，都有 $C(m, 0) = 1$。\n\n-   **基本情况 2: $n  0$**\n    函数必须返回 $0$。使用全是正整数的面额不可能凑成负数总和。这种情况通常在递归步骤中减去一个硬币值 $S[m-1]$ 后，该值大于剩余目标 $n$ 时达到。因此，对于 $n  0$，有 $C(m, n) = 0$。\n\n-   **基本情况 3: $m \\le 0$ 且 $n > 0$**\n    函数必须返回 $0$。如果没有可用的硬币 ($m \\le 0$) 且目标总和为正 ($n > 0$)，则不可能凑成该总和。这种情况在递归步骤 $C(m-1, n)$ 将 $m$ 递减至零或负数时达到。条件 $n > 0$ 至关重要，因为 $n=0$ 的情况有优先权。\n\n将递推关系和基本情况结合起来，就得到了 $count(S, m, n)$ 的完整递归算法：\n1.  如果 $n = 0$，返回 $1$。\n2.  如果 $n  0$，返回 $0$。\n3.  如果 $m \\le 0$ 且 $n > 0$，返回 $0$。\n4.  否则，返回 $count(S, m-1, n) + count(S, m, n - S[m-1])$。\n\n这个公式正确地实现了基于基本原理所需满足的逻辑，并满足问题陈述的所有条件。实现部分将把这个逻辑直接转化为一个递归的 Python 函数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\n\ndef count(S, m, n):\n    \"\"\"\n    Recursively counts the number of ways to form the sum n using the first m coins from S.\n\n    Args:\n        S (list[int]): The array of coin denominations.\n        m (int): The number of coin types to consider from the start of S.\n        n (int): The target sum.\n\n    Returns:\n        int: The number of distinct ways to make the sum.\n    \"\"\"\n    # Base Case 1: If the target sum is 0, there is one solution (the empty set).\n    if n == 0:\n        return 1\n\n    # Base Case 2: If the target sum is negative, no solution is possible.\n    if n  0:\n        return 0\n\n    # Base Case 3: If there are no coins (m = 0) and the sum is positive (n > 0),\n    # no solution is possible.\n    if m = 0 and n > 0:\n        return 0\n\n    # Recursive Step:\n    # The total number of solutions is the sum of two disjoint sets:\n    # 1. Solutions that do not include the m-th coin (S[m-1]).\n    #    This is count(S, m - 1, n).\n    # 2. Solutions that include at least one m-th coin (S[m-1]).\n    #    This is count(S, m, n - S[m-1]).\n    # Note that S is 0-indexed, so the m-th coin is at index m-1.\n    return count(S, m - 1, n) + count(S, m, n - S[m - 1])\n\ndef solve():\n    \"\"\"\n    Defines and runs the test suite for the coin change problem.\n    \"\"\"\n    # The test cases are defined as tuples of (S, m, n).\n    test_cases = [\n        # Case 1: S = [2,3,5,6], m = 4, n = 10\n        ([2, 3, 5, 6], 4, 10),\n        # Case 2: S = [2,3,5,6], m = 4, n = 0\n        ([2, 3, 5, 6], 4, 0),\n        # Case 3: S = [2,3], m = 0, n = 7\n        ([2, 3], 0, 7),\n        # Case 4: S = [1,2,3], m = 3, n = 4\n        ([1, 2, 3], 3, 4),\n        # Case 5: S = [1,2,5], m = 2, n = 5\n        ([1, 2, 5], 2, 5),\n        # Case 6: S = [2], m = 1, n = -5\n        ([2], 1, -5)\n    ]\n\n    results = []\n    for S, m, n in test_cases:\n        result = count(S, m, n)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了数值递归之后，我们将转向字符串操作。全排列问题要求我们生成一个字符串所有可能的字符顺序，其递归思想是固定一个字符作为开头，然后对其余部分进行递归。此练习的挑战在于处理重复字符，这需要我们在递归调用中传递额外状态，从而展示了更复杂的递归结构。",
            "id": "3213530",
            "problem": "要求您实现并论证一个纯递归算法，该算法通过重复选择一个字符作为首字符来生成给定字符串的所有排列。该算法必须遵循以下递归形式：基准情形是输入字符串长度为 $1$ 时，递归步骤是通过固定一个首字符并对其余字符进行递归，从而从长度为 $n-1$ 的解构建长度为 $n$ 的解。您还必须正确处理包含重复字符的输入字符串，以确保生成的排列是唯一的，并且不能使用非递归的全局去重方法。\n\n基本基础和约束条件：\n- 设 $s$ 是一个非空的小写英文字母字符串，且 $|s| = n$。\n- 算法必须根据 $n$ 定义为结构递归：\n  - 基准情形：如果 $n = 1$，返回仅包含 $s$ 的列表。\n  - 递归步骤：如果 $n \\ge 2$，对于每个索引 $i$（$0 \\le i  n$），选择字符 $s_i$ 作为首字符，递归地生成移除了第 $i$ 个字符后的剩余字符串 $s$ 的所有排列，并将 $s_i$ 前置到每个子排列的前面。\n- 为确保当 $s$ 含有重复字符时排列的唯一性，在每次递归调用时，您必须避免在该调用深度多次选择相同的首字符。这必须通过跟踪当前深度已使用的首字符并跳过重复项来完成。请勿使用库中的排列工具或迭代算法来替代此递归结构。\n- 该函数必须生成排列；但是，为了可测试性，您的程序应仅输出为每个测试用例生成的唯一排列的数量。\n\n输入规范：\n- 没有外部输入。您必须将下面描述的测试套件硬编码到程序中。\n\n输出规范：\n- 对于测试套件中的每个测试用例，计算您的递归算法产生的唯一排列的数量，并按顺序收集这些计数。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，例如，“[1,2,3]”。元素必须是整数。\n\n测试套件：\n- 按此顺序使用以下字符串作为测试用例，以检验一般行为、基准情形以及对重复字符的处理：\n  - s_1 = \"a\"。\n  - s_2 = \"ab\"。\n  - s_3 = \"aba\"。\n  - s_4 = \"abcd\"。\n  - s_5 = \"aabb\"。\n  - s_6 = \"aaa\"。\n\n覆盖率设计：\n- $s_1$ 检查基准情形 $n=1$。\n- $s_2$ 检查所有字符都不同的最小非平凡情形。\n- $s_3$ 检查当字符重复时是否能正确控制唯一性。\n- $s_4$ 检查所有字符都不同的较大数据规模情形。\n- $s_5$ 检查具有更复杂去重需求的多个重复字符情形。\n- $s_6$ 检查所有字符都相同的极端情形。\n\n您的任务：\n- 严格遵循基准情形 $n=1$ 和选择首字符的递归步骤，实现排列生成器，并在每个深度跳过重复的首字符选择。\n- 将其应用于测试套件，计算每个用例的唯一排列数，并按要求格式打印计数列表。",
            "solution": "该问题已经过分析并被认为是有效的。这是一个在算法和计算机科学领域中定义明确、自成体系且具有科学依据的问题。问题陈述清晰、客观，并为构建唯一且可验证的解决方案提供了所有必要信息。\n\n任务是实现一个纯递归算法，用于生成一个可能包含重复字符的字符串 $s$ 的所有唯一排列。唯一性必须在递归生成过程中强制执行，而不是通过后处理。该算法的核心由其递归结构指定。\n\n设 $P(s)$ 是生成长度为 $n = |s|$ 的字符串 $s$ 的唯一排列集合的函数。该算法通过对 $n$ 进行结构递归来定义。\n\n**基准情形：**\n对于长度 $n = 1$ 的字符串 $s$，只有一个排列：字符串本身。\n$$P(s) = \\{s\\}, \\quad \\text{if } |s| = 1$$\n例如，$P(\\text{\"a\"}) = \\{\\text{\"a\"}\\}$。排列的数量为 $1$。\n\n**递归步骤：**\n对于长度 $n \\ge 2$ 的字符串 $s$，通过从 $s$ 中选择每个唯一的字符作为新排列的首字符来构建排列集合。对于每个这样的唯一首字符，我们递归地生成剩余字符的排列，并将所选的首字符前置到它们的前面。\n\n为了正确处理重复字符并避免生成重复的排列，我们必须确保在任何给定的递归层级，我们不会多次使用相同的首字符来启动递归子问题。我们可以通过维护一个集合来实现这一点，该集合用于记录在当前递归调用中已经被选为首字符的字符。\n\n设 $s = s_0s_1\\dots s_{n-1}$。设 $U$ 是一个集合，用于跟踪在当前递归深度下已被选为前导字符的字符。初始时，$U$ 为空。我们从索引 $i=0$到 $n-1$ 遍历 $s$。\n\n对于每个索引 $i$：\n1. 设候选首字符为 $c = s_i$。\n2. 检查 $c$ 是否已在集合 $U$ 中。\n   - 如果 $c \\in U$，我们已经在此深度将此字符作为前导字符处理过。我们跳过本次迭代以避免冗余计算和重复结果。\n   - 如果 $c \\notin U$，我们继续。将 $c$ 添加到 $U$ 中（即 $U := U \\cup \\{c\\}$）。\n3. 通过从 $s$ 中移除字符 $s_i$ 来构造剩余的子字符串 $s'$。这可以表示为 $s' = s_0\\dots s_{i-1}s_{i+1}\\dots s_{n-1}$。\n4. 对剩余字符串递归调用排列函数：$P(s')$。\n5. 对于返回的集合 $P(s')$ 中的每个排列 $p$，通过前置 $c$ 形成一个新的排列：$c \\cdot p$。\n6. 从所有唯一的 $c$ 选择中收集所有这样生成的排列。\n\n$P(s)$ 的最终结果是为每个唯一首字符生成的所有排列的并集：\n$$P(s) = \\bigcup_{c \\in \\text{unique\\_chars}(s)} \\{c \\cdot p \\mid p \\in P(s' \\text{ where } s' \\text{ is } s \\text{ with one instance of } c \\text{ removed})\\}$$\n\n让我们跟踪 $s = \\text{\"aba\"}$（其中 $n=3$）的执行过程。\n$P(\\text{\"aba\"})$:\n- 初始化 $U = \\emptyset$。\n- **迭代 $i=0$**：$c = s_0 = \\text{'a'}$。因为 $\\text{'a'} \\notin U$，将其加入：$U = \\{\\text{'a'}\\}$。\n  - 剩余字符串为 $s' = \\text{\"ba\"}$。\n  - 递归调用 $P(\\text{\"ba\"})$。\n    - $P(\\text{\"ba\"})$ 将生成 $\\{\\text{\"ba\"}, \\text{\"ab\"}\\}$。\n  - 将 $\\text{'a'}$ 前置到每个排列上：$\\{\\text{\"aba\"}, \\text{\"aab\"}\\}$。\n- **迭代 $i=1$**：$c = s_1 = \\text{'b'}$。因为 $\\text{'b'} \\notin U$，将其加入：$U = \\{\\text{'a'}, \\text{'b'}\\}$。\n  - 剩余字符串为 $s' = \\text{\"aa\"}$。\n  - 递归调用 $P(\\text{\"aa\"})$。\n    - $P(\\text{\"aa\"})$：初始化 $U' = \\emptyset$。\n      - 迭代 $i=0$：$c' = \\text{'a'}$。加入到 $U'$。剩余为 $\\text{\"a\"}$。$P(\\text{\"a\"})$ 返回 $\\{\\text{\"a\"}\\}$。前置 $c'$ 得到 $\\{\\text{\"aa\"}\\}$。\n      - 迭代 $i=1$：$c' = \\text{'a'}$。因为 $\\text{'a'} \\in U'$，跳过。\n    - $P(\\text{\"aa\"})$ 返回 $\\{\\text{\"aa\"}\\}$。\n  - 将 $\\text{'b'}$ 前置到每个排列上：$\\{\\text{\"baa\"}\\}$。\n- **迭代 $i=2$**：$c = s_2 = \\text{'a'}$。因为 $\\text{'a'} \\in U$，跳过。\n- 最终的排列集合是所有有效迭代结果的并集：$\\{\\text{\"aba\"}, \\text{\"aab\"}, \\text{\"baa\"}\\} = \\{\\text{\"aba\"}, \\text{\"aab\"}, \\text{\"baa\"}\\}$。\n- 唯一排列的数量为 $3$。\n\n这个计数与多重集排列的组合公式相符。如果一个长度为 $n$ 的字符串有 $k$ 个不同字符，其重数分别为 $n_1, n_2, \\dots, n_k$（其中 $\\sum_{j=1}^{k} n_j = n$），则唯一排列的数量由多项式系数给出：\n$$ \\frac{n!}{n_1! n_2! \\dots n_k!} $$\n\n让我们用这个公式来验证测试用例：\n- $s_1 = \\text{\"a\"}$：$n=1, n_a=1$。计数 = $\\frac{1!}{1!} = 1$。\n- $s_2 = \\text{\"ab\"}$：$n=2, n_a=1, n_b=1$。计数 = $\\frac{2!}{1!1!} = 2$。\n- $s_3 = \\text{\"aba\"}$：$n=3, n_a=2, n_b=1$。计数 = $\\frac{3!}{2!1!} = \\frac{6}{2} = 3$。\n- $s_4 = \\text{\"abcd\"}$：$n=4$。不同字符。计数 = $\\frac{4!}{1!1!1!1!} = 24$。\n- $s_5 = \\text{\"aabb\"}$：$n=4, n_a=2, n_b=2$。计数 = $\\frac{4!}{2!2!} = \\frac{24}{4} = 6$。\n- $s_6 = \\text{\"aaa\"}$：$n=3, n_a=3$。计数 = $\\frac{3!}{3!} = 1$。\n\n所描述的算法通过递归正确地实现了这一组合原理。每个深度的‘已用字符’集合可以防止递归树中出现冗余分支，这等效于在组合公式中除以重复字符计数的阶乘。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\n\ndef solve():\n    \"\"\"\n    Solves the problem of finding the number of unique permutations for a given\n    set of test strings using a specified recursive algorithm.\n    \"\"\"\n\n    def get_unique_permutations(s: str) -> list[str]:\n        \"\"\"\n        Generates all unique permutations of a string using a recursive approach.\n\n        The algorithm adheres to the specified recursive structure:\n        - Base Case: If the string length is 1, return the string itself.\n        - Recursive Step: For each unique character in the string, fix it as the\n          first character, and recursively find all permutations of the remaining\n          characters. Prepend the fixed character to each of these sub-permutations.\n\n        Uniqueness is handled by tracking which characters have been used as the\n        first character at each level of the recursion to avoid redundant computations.\n\n        Args:\n            s: The input string.\n\n        Returns:\n            A list of unique permutation strings.\n        \"\"\"\n        # Base case: if |s| = 1, there is only one permutation.\n        # This matches the problem specification.\n        n = len(s)\n        if n == 1:\n            return [s]\n\n        # Recursive step: for |s| >= 2.\n        result_permutations = []\n        \n        # used_first_chars tracks characters already chosen to be first at this depth.\n        # This is the key to ensuring uniqueness without global deduplication.\n        used_first_chars = set()\n\n        for i in range(n):\n            first_char = s[i]\n            \n            # If this character has already been used as a starting point at this\n            # level of recursion, skip it to prevent duplicate permutations.\n            if first_char in used_first_chars:\n                continue\n            \n            # Mark this character as used for this recursion depth.\n            used_first_chars.add(first_char)\n\n            # Construct the remaining string by removing the character at index i.\n            remaining_s = s[:i] + s[i+1:]\n\n            # Recursively find all permutations of the remaining substring.\n            sub_permutations = get_unique_permutations(remaining_s)\n\n            # Prepend the current first_char to each sub-permutation and add to results.\n            for p in sub_permutations:\n                result_permutations.append(first_char + p)\n                \n        return result_permutations\n\n    # The test suite provided in the problem statement.\n    test_cases = [\n        \"a\",      # s_1: Base case n=1\n        \"ab\",     # s_2: Simple distinct case\n        \"aba\",    # s_3: Repeated character\n        \"abcd\",   # s_4: Larger distinct case\n        \"aabb\",   # s_5: Multiple repeated characters\n        \"aaa\",    # s_6: All characters identical\n    ]\n\n    results = []\n    for s_test in test_cases:\n        # The problem asks for the *count* of unique permutations.\n        permutations = get_unique_permutations(s_test)\n        count = len(permutations)\n        results.append(count)\n\n    # Final print statement must be in the exact required format.\n    # e.g., \"[1,2,3,24,6,1]\"\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the solution.\nsolve()\n```"
        },
        {
            "introduction": "单词拆分问题是递归概念的集大成者，它不仅涉及复杂的字符串递归，还会因重叠子问题而导致朴素递归解法出现指数级时间复杂度。这个问题是引入“记忆化”这一关键优化技术的绝佳案例，它能将低效的递归转变为高效的动态规划算法。",
            "id": "3213661",
            "problem": "您需要实现一个单词拆分判定问题的递归解法，该解法基于字符串递归的原理。设字母表为 $\\Sigma$，词典为一个有限集合 $\\mathcal{D} \\subseteq \\Sigma^{\\ast}$，输入字符串为 $s \\in \\Sigma^{\\ast}$。递归设计必须基于以下基本概念：每个字符串 $s$ 都可以分解为一个前缀 $p$ 和一个后缀 $t$，使得 $s = p \\cdot t$；空字符串用 $\\epsilon$ 表示；递归在严格变短的后缀上进行，直到达到 $\\epsilon$。基本情况是当 $s = \\epsilon$ 时。递归步骤检查词典中的某个单词 $w \\in \\mathcal{D}$ 是否为 $s$ 的前缀，如果是，则对相应的后缀 $t$ 进行递归。\n\n对于任何 $s \\in \\Sigma^{\\ast}$，相对于 $\\mathcal{D}$ 定义以下两个量：\n- 分割计数 $C(s)$，即将 $s$ 拆分成一个由 $\\mathcal{D}$ 中单词组成的序列且该序列连接后等于 $s$ 的不同方式的数量。\n- 最小单词数 $M(s)$，即使用 $\\mathcal{D}$ 对 $s$ 进行任意有效分割所需的最少单词数。约定如果没有有效的分割，则 $M(s) = -1$。\n\n您的程序必须为每个测试用例计算三个输出：\n- 一个布尔值 $B(s)$，指示是否存在至少一种有效的分割，即当且仅当 $C(s) > 0$ 时 $B(s)$ 为 $\\text{True}$，否则为 $\\text{False}$。\n- 整数 $C(s)$。\n- 整数 $M(s)$。\n\n递归必须遵守以下设计约束：\n- 基本情况：对于 $s = \\epsilon$，$C(\\epsilon) = 1$ 且 $M(\\epsilon) = 0$。\n- 递归步骤：对于 $s \\neq \\epsilon$，考虑所有满足 $w$ 是 $s$ 的前缀的 $w \\in \\mathcal{D}$。对于每个这样的 $w$，设后缀为 $t$ 满足 $s = w \\cdot t$，并对 $t$ 进行递归。对于 $C(s)$，将所有有效前缀的贡献相加。对于 $M(s)$，在所有允许有效分割的后缀 $t$ 上，取 $1 + M(t)$ 的最小值。如果没有有效的前缀能导向一个有效的分割，则 $C(s) = 0$ 且 $M(s) = -1$。\n- 使用记忆化来避免对重叠子问题的重复计算，确保递归的运行时间以 $|s|$ 和 $|\\mathcal{D}|$ 的多项式为界。说明保证递归终止并确保其良基性的度量。\n\n测试套件。您的程序必须为以下测试用例集计算结果，每个测试用例都是一个对 $(s, \\mathcal{D})$：\n- 案例 1：s = \"catsanddog\"，$\\mathcal{D} = \\{\"cat\", \"cats\", \"and\", \"sand\", \"dog\"\\}$。\n- 案例 2：s = \"\" (空字符串)，$\\mathcal{D} = \\{\"a\"\\}$。\n- 案例 3：s = \"abc\"，$\\mathcal{D} = \\{\"ab\", \"ac\"\\}$。\n- 案例 4：s = \"leetcode\"，$\\mathcal{D} = \\{\"leet\", \"code\", \"leetcode\"\\}$。\n- 案例 5：s = \"aaaaaaa\"，$\\mathcal{D} = \\{\"a\", \"aa\", \"aaaa\"\\}$。\n\n输出规范。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果本身是一个形式为 $[\\;B(s),\\;C(s),\\;M(s)\\;]$ 的列表。例如，输出格式必须为 $[\\,[\\;B(s_1),C(s_1),M(s_1)\\;],\\,[\\;B(s_2),C(s_2),M(s_2)\\;],\\ldots\\,]$。本问题不涉及物理单位，也不出现角度或百分比。",
            "solution": "该问题要求实现一个递归算法来解决单词拆分问题，并增加了计算可能分割的数量以及寻找有效分割中最小单词数的功能。该解法必须采用记忆化来实现多项式时间性能。\n\n解决方案的核心是一个递归函数，它对给定的字符串 $s \\in \\Sigma^{\\ast}$ 和词典 $\\mathcal{D} \\subseteq \\Sigma^{\\ast}$ 进行操作。该函数计算三个量：一个布尔值 $B(s)$，指示是否存在任何有效分割；一个整数 $C(s)$，表示不同分割的总数；以及一个整数 $M(s)$，表示分割中的最小单词数。\n\n递归结构通过将字符串 $s$ 分解为前缀 $w$ 和后缀 $t$ 来定义，使得 $s = w \\cdot t$。递归过程是找到 $s$ 的所有在词典 $\\mathcal{D}$ 中存在的前缀 $w$，然后对相应的后缀 $t$ 递归地解决问题。\n\n递归关系和基本情况形式化定义如下：\n\n设 $s$ 为输入字符串，$\\mathcal{D}$ 为词典。\n\n基本情况：对于空字符串 $s = \\epsilon$：\n- 空字符串被认为是其自身的有效分割，包含零个单词。\n- 分割空字符串的方法数为 1：$C(\\epsilon) = 1$。\n- 此分割中的最小单词数为 0：$M(\\epsilon) = 0$。\n- 由于 $C(\\epsilon) > 0$，存在分割：$B(\\epsilon) = \\text{True}$。\n\n递归步骤：对于非空字符串 $s \\neq \\epsilon$：\n通过考虑所有作为 $s$ 前缀的单词 $w \\in \\mathcal{D}$ 来计算这些量。对于每个这样的 $w$，我们找到相应的后缀 $t$（其中 $s = w \\cdot t$），并对 $t$ 进行递归调用。\n\n1.  分割计数 $C(s)$：$s$ 的总分割数是所有可能的后缀 $t$ 的分割数之和，这些后缀是通过从 $s$ 中剥离一个有效的词典单词前缀 $w$ 得到的。\n    $$\n    C(s) = \\sum_{w \\in \\mathcal{D} \\mid s \\text{ starts with } w} C(s[|w|..])\n    $$\n    其中 $s[|w|..]$ 表示从 $s$ 中移除长度为 $|w|$ 的前缀 $w$ 后的后缀。如果不存在这样的 $w$，则和为空，且 $C(s) = 0$。\n\n2.  最小单词数 $M(s)$：$s$ 的最小单词数是其所有可有效分割的后缀的最小单词数的最小值再加一。\n    $$\n    M(s) = \\min \\{1 + M(t) \\mid s = w \\cdot t, w \\in \\mathcal{D}, C(t) > 0\\}\n    $$\n    如果这样的后缀 $t$ 的集合为空（即，没有任何前缀 $w \\in \\mathcal{D}$ 能导出一个可以被分割的后缀 $t$），那么 $s$ 就没有有效的分割。在这种情况下，我们遵循约定 $M(s) = -1$。\n\n3.  分割的存在性 $B(s)$：这个布尔值直接由分割计数确定。\n    $$\n    B(s) = (C(s) > 0)\n    $$\n\n终止性与良基性：递归保证会终止。确保终止的度量是字符串的长度 $|s|$，它是一个非负整数。每次递归调用都是对 $s$ 的一个后缀 $t$ 进行的，其中相应的前缀 $w$ 是词典中的一个单词，因此是非空的。这意味着 $|t|  |s|$。一个严格递减的非负整数序列必定是有限的。因此，该递归是良基的，并且总会在 $|s| = 0$（即 $s = \\epsilon$）的基本情况处终止。\n\n记忆化：一个朴素的递归实现会因为多次重复计算相同子串的结果（重叠子问题）而具有指数级的时间复杂度。为了优化这一点，我们使用记忆化，这是动态规划的一个典型技术。一个缓存（例如，哈希映射）存储已处理过的每个子串 $s'$ 的结果 $(B(s'), C(s'), M(s'))$。在为任何字符串 $s'$ 计算结果之前，会检查缓存。如果结果存在，则立即返回。否则，继续进行计算，并将新计算出的结果在返回前存入缓存。这确保了每个唯一的后缀子问题只被解决一次。时间复杂度变为多项式级别，在一个直接的实现中，大约与 $|s|^2 \\cdot |\\mathcal{D}|$ 成正比，或者更精确地说，由子问题的数量（$s$ 的每个后缀对应一个，共 $|s|+1$ 个）乘以每个子问题的工作量（遍历 $\\mathcal{D}$）决定。\n\n算法实现：设计一个单一的递归函数来计算三元组 $(B(s), C(s), M(s))$，以避免对递归树的冗余遍历。\n- 函数以字符串 $s$、词典 $\\mathcal{D}$ 和记忆化缓存作为参数。\n- 它首先在缓存中查找 $s$。如果找到，则返回缓存的值。\n- 然后检查基本情况 $s = \\epsilon$，如果成立则返回 $(\\text{True}, 1, 0)$。\n- 对于递归步骤，它将 `total_count` 初始化为 $0$，将 `min_words` 初始化为一个代表无穷大的值（例如 `float('inf')`）。\n- 它遍历 $\\mathcal{D}$ 中的每个单词 $w$。如果 $w$ 是 $s$ 的前缀，它就对后缀 $t$ 进行递归调用。\n- 如果对 $t$ 的递归调用返回的结果表明存在有效分割（即 $B(t)$ 为 True），它会聚合结果：`total_count` 增加 $C(t)$，`min_words` 更新为 $\\min(\\text{min\\_words}, 1 + M(t))$。\n- 检查完所有前缀后，如果 `total_count` 仍为 $0$，则表示没有找到分割。$s$ 的结果是 $(\\text{False}, 0, -1)$。\n- 否则，结果是 $(\\text{True}, \\text{total\\_count}, \\text{min\\_words})$。\n- 最后，这个结果被存储在 $s$ 的缓存中并返回。\n这种集成方法能在一个高效的递归过程中正确计算所有三个所需的量。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\n\ndef solve():\n    \"\"\"\n    Main function to run the specified test cases and print results.\n    \"\"\"\n\n    test_cases = [\n        (\"catsanddog\", {\"cat\", \"cats\", \"and\", \"sand\", \"dog\"}),\n        (\"\", {\"a\"}),\n        (\"abc\", {\"ab\", \"ac\"}),\n        (\"leetcode\", {\"leet\", \"code\", \"leetcode\"}),\n        (\"aaaaaaa\", {\"a\", \"aa\", \"aaaa\"}),\n    ]\n\n    results = []\n    for s, word_dict in test_cases:\n        memo = {}\n        b_s, c_s, m_s = _solve_recursive(s, word_dict, memo)\n        results.append([b_s, c_s, m_s])\n\n    # Final print statement in the exact required format.\n    # str() on a list gives a good representation, e.g., \"[True, 2, 3]\"\n    # Replacing single quotes with no quotes for exact match.\n    print(f\"[{','.join(str(r) for r in results)}]\")\n\ndef _solve_recursive(s: str, word_dict: set, memo: dict):\n    \"\"\"\n    Recursively solves the word break problem with memoization.\n\n    Args:\n        s (str): The input string to segment.\n        word_dict (set): The dictionary of valid words.\n        memo (dict): The memoization cache.\n\n    Returns:\n        tuple[bool, int, int]: A tuple containing (B(s), C(s), M(s)).\n            - B(s): True if a segmentation exists, False otherwise.\n            - C(s): The number of distinct valid segmentations.\n            - M(s): The minimum number of words in a segmentation (-1 if none).\n    \"\"\"\n    if s in memo:\n        return memo[s]\n\n    # Base case: The empty string has one segmentation (the empty one)\n    # with zero words.\n    if not s:\n        # C(epsilon) = 1, M(epsilon) = 0\n        return True, 1, 0\n\n    total_count = 0\n    min_words = float('inf')\n\n    # Recursive step: Iterate through all dictionary words as potential prefixes.\n    for word in word_dict:\n        if s.startswith(word):\n            suffix = s[len(word):]\n            \n            # Recurse on the suffix.\n            b_suffix, c_suffix, m_suffix = _solve_recursive(suffix, word_dict, memo)\n\n            # If the suffix can be segmented, aggregate the results.\n            if b_suffix:\n                # Add the number of segmentations of the suffix.\n                total_count += c_suffix\n                \n                # Update the minimum words count for the current string.\n                min_words = min(min_words, 1 + m_suffix)\n\n    # After checking all possible prefixes, finalize the result for s.\n    if total_count == 0:\n        # No valid segmentation found for s.\n        result = (False, 0, -1)\n    else:\n        # A valid segmentation was found.\n        result = (True, total_count, int(min_words))\n    \n    # Cache the result before returning.\n    memo[s] = result\n    return result\n\n# Execute the solution.\nsolve()\n```"
        }
    ]
}