{
    "hands_on_practices": [
        {
            "introduction": "判断一个字符串是否为回文是递归的一个经典应用。这个练习将一个直观的递归问题转化为尾递归形式，通过传递代表子问题边界的左右索引来管理状态。这个练习旨在让你掌握将标准递归思路转化为高效尾递归实现的基本技巧，即通过参数传递来避免在递归调用返回后进行额外计算。",
            "id": "3278431",
            "problem": "给定一个关于有限字符串的回文形式化定义。设一个在有限字母表上的有限字符串表示为 $s$，其长度为 $n = |s|$。定义反转操作符 $\\operatorname{rev}(s)$，它产生一个字符顺序相反的字符串。一个字符串 $s$ 是回文，当且仅当 $s = \\operatorname{rev}(s)$，这等价于逐点条件 $\\forall i \\in \\{0,1,\\dots,n-1\\},\\ s[i] = s[n-1-i]$。你的任务是设计并实现一个尾递归算法，用于判断一个给定字符串在经过规范化后是否为回文。规范化定义为将输入字符串 $s$ 映射到 $\\nu(s)$ 的过程，该过程移除所有非字母数字（字母或数字）的字符，并将剩余字符转换为小写，同时保持原有顺序。形式上，如果 $s = s_0 s_1 \\dots s_{n-1}$，则\n$$\n\\nu(s) = \\text{concat} \\left( \\left\\{ \\operatorname{lower}(s_i) \\mid s_i \\text{ is alphanumeric} \\right\\} \\right),\n$$\n其中 $\\operatorname{lower}(\\cdot)$ 将大写字母映射为小写字母，并保持数字不变，而 concat 按原始顺序拼接字符。\n\n从递归的基本定义出发，尾递归函数是一种递归函数，其中递归调用是函数执行路径中的最后一个操作。请使用一个作用于规范化字符串 $\\nu(s)$ 的索引 $l$ 和 $r$ 上的谓词 $P(l,r)$ 来形式化回文判定问题，其中 $0 \\le l \\le r  |\\nu(s)|$。该谓词返回一个布尔值，指示由 $l$ 和 $r$ 界定的子串是否为回文。函数 $P(l,r)$ 必须是尾递归的，即递归调用（如果存在）是函数执行的最后一个动作。基准情形必须确保终止，递归步骤必须严格减小问题规模。\n\n你的程序必须在 $\\nu(s)$ 上实现这个尾递归谓词，并将其应用于以下输入字符串的测试套件：\n- $s_1 =$ \"racecar\"\n- $s_2 =$ \"\"\n- $s_3 =$ \"a\"\n- $s_4 =$ \"A man, a plan, a canal: Panama\"\n- $s_5 =$ \"No 'x' in Nixon\"\n- $s_6 =$ \"abca\"\n- $s_7 =$ \"abc\"\n- $s_8 =$ \"!!!\"\n- $s_9 =$ \"Was it a car or a cat I saw?\"\n- $s_{10} =$ \"abcbaX\"\n\n覆盖性设计：\n- $s_1$ 测试一个仅包含小写字母的简单回文。\n- $s_2$ 测试空字符串，其规范化后仍为空，根据定义应被视作回文（无条件为真）。\n- $s_3$ 测试单字符字符串，它总是一个回文。\n- $s_4$、$s_5$ 和 $s_9$ 测试在规范化下的回文，包括混合大小写和标点符号，其中只考虑字母数字字符，并且字母以不区分大小写的方式进行比较。\n- $s_6$、$s_7$ 和 $s_{10}$ 测试在规范化后明显不是回文的字符串。\n- $s_8$ 测试一个在规范化后变为空字符串的字符串。\n\n每个测试用例必须产生一个布尔结果。你的程序应生成单行输出，其中包含 $[s_1,s_2,\\dots,s_{10}]$ 的结果，形式为一个用方括号括起来的逗号分隔列表，使用编程语言的布尔字面量表示（对于 Python，即 \"True\" 和 \"False\"）。例如，输出格式必须严格符合 $[b_1,b_2,\\dots,b_{10}]$ 的形式，其中每个 $b_i$ 是字面量 \"True\" 或 \"False\"。程序不读取任何输入；它必须是自包含的，并使用嵌入在代码中的指定测试套件。",
            "solution": "该问题要求设计并实现一个尾递归算法，以判断给定字符串在经过特定规范化过程后是否为回文。解决方案分两个主要阶段进行开发：首先，定义字符串规范化；其次，形式化用于回文检查的尾递归谓词。\n\n### 步骤 1：字符串规范化\n\n问题定义了一个规范化函数 $\\nu(s)$，它为回文检查准备输入字符串 $s$。此过程包括按顺序执行的两个操作：\n1.  **过滤**：从字符串中移除所有非字母数字的字符（即，非 'a'-'z'、'A'-'Z' 的字母或 '0'-'9' 的数字）。\n2.  **大小写转换**：将所有剩余的字符（保证为字母数字）转换为它们的小写等效形式。大写字母被映射为小写，而数字保持不变。\n\n形式上，对于字符串 $s = s_0 s_1 \\dots s_{n-1}$，规范化后的字符串 $\\nu(s)$ 由以下公式给出：\n$$\n\\nu(s) = \\text{concat} \\left( \\left\\{ \\operatorname{lower}(s_i) \\mid s_i \\text{ is alphanumeric} \\right\\} \\right)\n$$\n例如，将此应用于字符串 $s_4 = \\text{\"A man, a plan, a canal: Panama\"}$：\n1.  过滤掉空格、逗号和冒号后得到 `\"AmanaplanacanalPanama\"`。\n2.  转换为小写后得到规范化字符串 $\\nu(s_4) = \\text{\"amanaplanacanalpanama\"}$。\n\n对于像 $s_8 = \\text{\"!!!\"}$ 这样的字符串，所有字符都是非字母数字，因此它们都被移除。最终的规范化字符串是空字符串，即 $\\nu(s_8) = \\text{\"\"}$。\n\n### 步骤 2：尾递归回文谓词\n\n回文是一个正向和反向读取都相同的序列。对于一个长度为 $m = |s'|$ 的规范化字符串 $s' = \\nu(s)$，这等价于条件 $s'[i] = s'[m-1-i]$ 对所有 $i \\in \\{0, 1, \\dots, m-1\\}$ 成立。我们可以使用一个递归谓词 $P(l, r)$ 来为此属性制定一个判定算法，该谓词评估 $s'$ 中从索引 $l$ 到索引 $r$（含两端）的子串是否构成回文。对整个字符串 $s'$ 的初始检查通过调用 $P(0, m-1)$ 来执行。\n\n$P(l, r)$ 的设计必须是尾递归的，这意味着递归调用（如果发生）必须是函数执行的绝对最后一个操作。\n\n**基准情形：** 递归必须终止。当“外部”指针（由索引 $l$ 和 $r$ 表示）相遇或交叉时，回文检查可以停止。\n- 如果 $l = r$，子串只有一个字符，它总是一个回文。\n- 如果 $l > r$，子串是空的（例如，原字符串有偶数个字符且所有字符对都匹配）。空字符串无条件地是回文。\n综合这些，终止的基准情形是 $l \\ge r$。在这种情况下，谓词 $P(l,r)$ 必须返回 $\\text{True}$。\n\n**递归步骤：** 对于 $l  r$ 的情况，我们比较当前子串两端的字符，$s'[l]$ 和 $s'[r]$。\n1.  如果 $s'[l] \\neq s'[r]$，则该子串不是回文。无需进一步检查。函数必须终止并返回 $\\text{False}$。这是一个非递归的终止路径。\n2.  如果 $s'[l] = s'[r]$，则外部字符匹配。问题被简化为判断内部子串（从索引 $l+1$到 $r-1$）是否也是回文。函数必须接着计算 $P(l+1, r-1)$ 的值。为了满足尾递归约束，函数必须直接返回此递归调用的结果，而不进行任何进一步的计算。\n\n这个逻辑被以下关于字符串 $s'$ 的谓词 $P(l,r)$ 的分段定义形式化地捕捉：\n$$\nP(l,r) =\n\\begin{cases}\n\\text{True}  \\text{if } l \\ge r \\\\\n\\text{False}  \\text{if } l  r \\text{ and } s'[l] \\neq s'[r] \\\\\nP(l+1, r-1)  \\text{if } l  r \\text{ and } s'[l] = s'[r]\n\\end{cases}\n$$\n\n**示例演练：**\n让我们分析 $s_{10} = \\text{\"abcbaX\"}$。\n1.  **规范化**：$\\nu(s_{10}) = s' = \\text{\"abcbax\"}$。长度为 $m=6$。\n2.  **初始调用**：我们评估 $P(0, 5)$。\n    - $P(0, 5)$：$l=0, r=5$。我们检查 $s'[0] \\overset{?}{=} s'[5]$。即 $\\text{'a'} \\overset{?}{=} \\text{'x'}$。条件为假。函数返回 $\\text{False}$。过程终止。\n\n让我们分析 $s_9 = \\text{\"Was it a car or a cat I saw?\"}$。\n1.  **规范化**：$\\nu(s_9) = s' = \\text{\"wasitacaroracatisaw\"}$。长度为 $m=19$。\n2.  **初始调用**：我们评估 $P(0, 18)$。\n    - $P(0, 18)$：$l=0, r=18$。$s'[0]=\\text{'w'}, s'[18]=\\text{'w'}$。它们匹配。返回 $P(1, 17)$。\n    - $P(1, 17)$：$l=1, r=17$。$s'[1]=\\text{'a'}, s'[17]=\\text{'a'}$。它们匹配。返回 $P(2, 16)$。\n    - ... 这个过程持续进行，直到到达中心。\n    - $P(8, 10)$：$l=8, r=10$。$s'[8]=\\text{'r'}, s'[10]=\\text{'r'}$。它们匹配。返回 $P(9, 9)$。\n    - $P(9, 9)$：$l=9, r=9$。满足基准情形 $l \\ge r$。函数返回 $\\text{True}$。\n\n这个最终的 $\\text{True}$ 结果会沿着尾调用链向上传播，成为初始调用的最终结果。因此，$s_9$ 在规范化后是回文。\n\n这种结构化的递归公式能够正确解决问题，并遵守尾递归的要求。实现将包含一个规范化函数和一个用于谓词 $P(l,r)$ 的函数，该函数会递归地调用自身。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\n\ndef solve():\n    \"\"\"\n    Solves the palindrome problem for a given test suite using a \n    tail-recursive approach on normalized strings.\n    \"\"\"\n\n    # The test suite of input strings as per the problem statement.\n    test_cases = [\n        \"racecar\",                          # s_1\n        \"\",                                 # s_2\n        \"a\",                                # s_3\n        \"A man, a plan, a canal: Panama\",   # s_4\n        \"No 'x' in Nixon\",                  # s_5\n        \"abca\",                             # s_6\n        \"abc\",                              # s_7\n        \"!!!\",                             # s_8\n        \"Was it a car or a cat I saw?\",     # s_9\n        \"abcbaX\",                           # s_10\n    ]\n\n    def normalize_string(s: str) - str:\n        \"\"\"\n        Applies the normalization function nu(s).\n        Removes non-alphanumeric characters and converts to lowercase.\n        \"\"\"\n        return \"\".join(char.lower() for char in s if char.isalnum())\n\n    def is_palindrome_tail_recursive(s_prime: str, l: int, r: int) - bool:\n        \"\"\"\n        Implements the tail-recursive predicate P(l, r) to check if the\n        substring of s_prime from index l to r is a palindrome.\n        \n        Args:\n            s_prime: The normalized string.\n            l: The left index of the substring.\n            r: The right index of the substring.\n        \n        Returns:\n            True if the substring is a palindrome, False otherwise.\n        \"\"\"\n        # Base Case: If indices cross or meet, the substring is a palindrome.\n        # This handles empty strings (l=0, r=-1) and single-char strings (l=r=0).\n        if l = r:\n            return True\n        \n        # Recursive Step:\n        # 1. Check if the outer characters are different.\n        if s_prime[l] != s_prime[r]:\n            return False\n        \n        # 2. If they are the same, the result depends on the inner substring.\n        #    This is a tail call as it's the final action of the function.\n        return is_palindrome_tail_recursive(s_prime, l + 1, r - 1)\n\n    results = []\n    for s in test_cases:\n        # 1. Normalize the input string s.\n        normalized_s = normalize_string(s)\n        \n        # 2. Apply the tail-recursive predicate P(l, r) to the normalized string.\n        # The initial call covers the entire string.\n        is_pal = is_palindrome_tail_recursive(normalized_s, 0, len(normalized_s) - 1)\n        \n        results.append(is_pal)\n\n    # Format the final output as a comma-separated list of booleans in brackets.\n    # The map(str, ...) ensures Python's \"True\" and \"False\" literals are used.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了如何通过索引管理状态后，我们将探索如何使用尾递归来构建一个复杂的结果，例如字符串。整数到任意进制的转换过程天然地会按从低位到高位的顺序（即从右到左）产生数字，而尾递归中的累加器模式恰好能优雅地处理这种情况，通过在每次递归调用前将新数字前置拼接，最终得到正确顺序的字符串。这个练习将巩固累加器模式，这是将许多非尾递归函数转换为尾递归形式的关键技术。",
            "id": "3278420",
            "problem": "您的任务是设计、实现并验证一个尾递归函数，该函数能将任意整数转换为其在给定基数下的字符串表示形式。所要求的函数必须遵循尾递归的约束：在递归分支中，递归调用必须是执行的最后一个操作。不允许使用循环。对于大于 $10$ 的基数，数字字母表必须为大写序列 $0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ$，其中数值 $10$ 到 $35$ 由 $A$ 到 $Z$ 表示。基数 $b$ 被限制在闭区间 $2 \\leq b \\leq 36$ 内。\n\n您的实现应基于除法算法：对于任意整数 $n$ 和 $b$（其中 $b \\geq 2$），存在唯一的整数 $q$ 和 $r$，使得 $n = q \\cdot b + r$ 且 $0 \\leq r  b$。利用此算法，每个非零整数 $n$ 都可以表示为一个有限的 $b$ 进制数字序列 $d_k, d_{k-1}, \\dots, d_0$，使得 $n = \\sum_{i=0}^{k} d_i \\cdot b^i$ 且每个 $d_i \\in \\{0,1,\\dots,b-1\\}$。您的函数必须使用尾递归来累积正确的字符串，在非基本情况的递归调用返回后不执行任何工作。\n\n要求与规则：\n- 实现一个尾递归核心，以正确的从左到右的顺序累积数字。使用一个向前传递并在递归调用前修改的累加器，确保递归分支中的最后一个操作是递归调用本身。对于负数 $n$，使用一个单独的前缀累加器来存储符号，并对 $|n|$ 应用除法算法。$n=0$ 的表示必须是单个数字字符串 $0$，不带符号。\n- 函数必须验证 $b$ 的有效性，并以数学上一致的方式处理所有整数 $n$（正数、负数和零）。\n- 不要使用任何迭代结构，如 for 循环或 while 循环。\n\n测试套件：\n在以下有序对 $(n,b)$ 上评估您的程序，覆盖典型和边界场景：\n1. $(0,2)$\n2. $(12345,10)$\n3. $(-255,16)$\n4. $(987654321,36)$\n5. $(1,2)$\n6. $(35,36)$\n\n最终输出格式：\n- 对于每个测试用例，计算其 $b$ 进制字符串表示，然后根据映射关系：$'0' \\mapsto 0$, $'1' \\mapsto 1$, $\\dots$, $'9' \\mapsto 9$, $'A' \\mapsto 10$, $\\dots$, $'Z' \\mapsto 35$，将该字符串转换为一个整数数字值列表。如果表示的是负数，则在列表的开头包含一个 $-1$ 来表示负号。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个元素本身也是一个逗号分隔的整数列表，用于描述一个测试用例的数字值。例如，格式必须类似于 $[[a_1,a_2], [b_1,b_2,b_3]]$，但外部列表中的逗号后不能有空格（精确的打印格式必须由您的程序处理）。",
            "solution": "将整数转换为给定基数的字符串表示是计算机科学中的一项基本任务，其根源在于数论原理。解决方案必须使用尾递归实现，这是一种特殊的递归模式，其中递归调用是函数中的最后一个操作。\n\n此转换的数学基础是**除法算法**。对于任意整数 $n$（待转换的数）和一个整数基数 $b \\geq 2$，存在唯一的整数 $q$（商）和 $r$（余数），使得：\n$$n = q \\cdot b + r \\quad \\text{其中} \\quad 0 \\leq r  b$$\n该算法使我们能够系统地提取 $n$ 在基数 $b$ 下的各位数字。余数 $r$ 对应最低有效位。后续的数字通过对商 $q$ 重复应用相同的算法来找到。例如，如果 $n_0 = n$，我们得到 $n_0 = q_0 \\cdot b + d_0$。然后对于 $n_1 = q_0$，我们得到 $n_1 = q_1 \\cdot b + d_1$，依此类推。此过程持续进行，直到商变为 $0$。余数序列 $d_0, d_1, d_2, \\dots$ 代表了 $n$ 在基数 $b$ 下从右到左（从最低有效位到最高有效位）的各位数字。\n\n为了满足尾递归的要求，我们设计一个核心递归函数，它接受当前数字、基数和一个累加器作为参数。累加器的作用是构建最终的字符串表示。由于除法算法从右到左生成数字，每个新数字都必须前置到累加器中，以按正确的从左到右顺序构造最终字符串。\n\n尾递归辅助函数的结构，我们称之为 $\\text{convert\\_recursive}(num, base, acc)$，如下所示：\n1.  **基本情况**：如果 $num = 0$，则过程完成。在累加器 $acc$ 中构建的字符串是最终结果，并将其返回。如果初始数字为 $0$，累加器将为空，这必须作为特殊情况处理以返回 \"0\"。\n2.  **递归步骤**：如果 $num > 0$：\n    a. 计算商 $q = \\lfloor num / base \\rfloor$ 和余数 $r = num \\pmod{base}$。\n    b. 将余数 $r$ 转换为其对应的字符表示。我们使用字符集 `$0123456789\\text{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$` 进行此映射。设此字符为 $c_r$。\n    c. 将此字符前置到累加器：$acc_{new} = c_r + acc_{old}$。\n    d. 进行尾递归调用：$\\text{return convert\\_recursive}(q, base, acc_{new})$。因为此调用是最后一个动作，所以该函数是尾递归的。\n\n一个主包装函数将在启动递归之前处理初步检查和特殊情况：\n-   **基数验证**：它首先验证基数 $b$ 是否在允许的范围 $2 \\leq b \\leq 36$ 内。\n-   **零处理**：如果输入整数 $n$ 为 $0$，函数立即返回字符串 \"$0$\"，绕过递归逻辑。\n-   **符号处理**：如果 $n$ 是负数，则存储负号，并对绝对值 $|n|$ 应用递归转换。递归完成后，将符号前置到最终结果。\n\n最后一步是将生成的字符串表示处理成指定的输出格式。这包括：\n1.  创建一个字符到值的映射（例如，$'0' \\to 0, \\dots, '9' \\to 9, 'A' \\to 10, \\dots, 'Z' \\to 35$）。\n2.  遍历 $b$ 进制字符串的字符。\n3.  如果字符串表示一个负数（由前导 `'-'` 字符表示），则输出列表以 $-1$ 开头。\n4.  每个后续字符都使用该映射转换为其整数值，并追加到列表中。\n\n这个完整、基于原则的过程确保了正确性，遵守了问题的所有约束，并为给定的测试套件生成了所需的输出格式。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\n\ndef solve():\n    \"\"\"\n    Solves the integer-to-base-string conversion problem using tail recursion for the given test suite.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0, 2),\n        (12345, 10),\n        (-255, 16),\n        (987654321, 36),\n        (1, 2),\n        (35, 36),\n    ]\n\n    # The alphabet of digits for bases up to 36.\n    DIGITS = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    \n    # Pre-computed map for converting character digits to integer values.\n    DIGIT_MAP = {char: val for val, char in enumerate(DIGITS)}\n\n    def _int_to_base_str_recursive(num, base, acc):\n        \"\"\"\n        The core tail-recursive helper function. This function must not be called directly.\n        It builds the string representation by prepending digits to an accumulator.\n        \"\"\"\n        if num == 0:\n            # Base case: when the number is reduced to 0, return the accumulated string.\n            return acc\n        \n        quotient = num // base\n        remainder = num % base\n        \n        # Prepend the new digit to the accumulator and make the tail call.\n        return _int_to_base_str_recursive(quotient, base, DIGITS[remainder] + acc)\n\n    def int_to_base_str(n, b):\n        \"\"\"\n        Main function to convert an integer to its base-b string representation.\n        It handles validation, special cases (zero), and sign before calling the\n        tail-recursive helper.\n        \"\"\"\n        if not isinstance(b, int) or not (2 = b = 36):\n            raise ValueError(\"Base must be an integer between 2 and 36.\")\n        \n        if n == 0:\n            return \"0\"\n            \n        sign = \"\"\n        if n  0:\n            sign = \"-\"\n            n = -n\n        \n        # Initial call to the recursive helper with an empty accumulator.\n        # If the number was initially 0, this part is skipped. The _recursive\n        # function needs a non-empty result, so this initial empty string\n        # is fine because n0 here.\n        num_str = _int_to_base_str_recursive(n, b, \"\")\n        \n        return sign + num_str\n\n    def format_output_string(s):\n        \"\"\"\n        Converts the string representation (e.g., \"-FF\") into the required\n        list of integer values (e.g., [-1, 15, 15]).\n        \"\"\"\n        result_list = []\n        is_negative = s.startswith('-')\n        \n        if is_negative:\n            result_list.append(-1)\n            s = s[1:]\n            \n        for char in s:\n            result_list.append(DIGIT_MAP[char])\n            \n        return result_list\n\n    results = []\n    for n, b in test_cases:\n        base_str = int_to_base_str(n, b)\n        formatted_result = format_output_string(base_str)\n        results.append(formatted_result)\n\n    # Format the final output string exactly as required.\n    # e.g., [[0],[1,2,3,4,5],[-1,15,15],...]\n    inner_parts = [f\"[{','.join(map(str, r))}]\" for r in results]\n    final_output_str = f\"[{','.join(inner_parts)}]\"\n\n    print(final_output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "在学习了如何实现尾递归之后，这个终极练习将揭示其背后的核心优势：空间效率。简单地使用递归来反转一个链表会导致与链表长度成正比的调用栈空间消耗，这在处理大规模数据时是不可接受的。通过实现尾递归版本，并模拟尾调用优化（TCO）的效果，你将亲手编写代码来测量和对比不同实现下的栈深度，从而将尾调用优化的理论概念转化为具体可感的性能差异。",
            "id": "3278410",
            "problem": "你需要从第一性原理出发，设计并实现一个使用累加器的尾递归列表反转模式。你必须依赖的基础包括：(i) 单链表的定义，其中在列表前端添加元素的构造函数（通常称为“cons”）以常数时间 $O(1)$ 运行；(ii) 尾调用的定义，即作为函数最后一个操作的递归调用；以及 (iii) 随机存取机器（RAM）的标准成本模型，其中对常数大小数据的每个基本操作成本为 $O(1)$，运行时间是所有执行的基本操作成本之和。你还必须论证在使用和不使用尾调用优化（TCO）时调用栈空间的使用情况，其中尾调用优化（TCO）指运行时系统为尾调用重用当前栈帧的转换，从而防止额外的栈增长。你的程序必须以忠实于单链表模型（常数时间前端插入）的方式实现该算法，并且必须对实现进行检测，以计算元素转移步骤的数量和反转函数达到的最大调用栈深度。\n\n任务要求如下：\n1. 在单链表表示上，使用累加器 $R$ 构建一个尾递归反转算法。设 $X$ 表示输入列表，$n$ 表示 $|X|$。该算法的形态必须是：每一步剥离输入的头元素 $h$，并设置 $R \\leftarrow \\mathrm{cons}(h,R)$，然后对其余部分进行尾调用，这样当输入为空时，$R$ 就是结果。使用一种允许 $O(1)$ 前端插入的表示（你不能依赖于在前端插入成本超过 $O(1)$ 的动态数组）。\n2. 实现反转算法的两个变体：\n   - 一个普通的尾递归函数（不假设语言运行时支持尾调用优化 TCO）。\n   - 一个使用 trampoline 或等效迭代转换的 TCO 模拟变体，该变体保证无论 $n$ 为何，调用栈使用量均为 $O(1)$。\n3. 对两个变体进行检测以记录：\n   - 元素转移步骤的数量，根据构造，该数量应等于 $n$。\n   - 反转函数所致的最大递归深度。对于没有尾调用优化（TCO）的普通变体，这应该是 $n+1$（包括基本情况的调用帧）。对于 TCO 模拟变体，这应该是 $1$。\n4. 使用宿主语言的递归深度限制 $L$ 来防止程序崩溃。对于列表长度 $m$ 满足 $m+1 > L$ 的测试，不要运行普通递归变体；相反，对于因预测溢出而无法获得的字段，报告一个哨兵值。\n5. 时间和空间论证：根据成本模型论证为何总工作量为 $O(n)$，以及在没有尾调用优化（TCO）时调用栈消耗为 $O(n)$，而在有尾调用优化（TCO）时为 $O(1)$。\n\n测试套件：\n为以下输入列表 $X$ 提供结果：\n- $X_1 = [\\,]$。\n- $X_2 = [7]$。\n- $X_3 = [1,2,3,4,5]$。\n- $X_4 = [0,1,2,\\dots,799]$（长度为 $800$）。\n- $X_5 = [0,1,2,\\dots,(L+49)]$，其中 $L$ 是运行时的宿主语言递归限制，列表长度为 $L+50$。对于这最后一个案例，你必须跳过执行普通递归变体，并将其视为预测溢出。\n\n对于每个输入列表为 $X$ 且长度为 $n$ 的测试用例，你必须生成一个形式如下的单一结果记录：\n$[ \\text{ok\\_tramp}, \\text{plain\\_status}, \\text{steps}, \\text{stack\\_plain}, \\text{stack\\_tramp}, \\text{overflow\\_predicted} ]$\n其语义如下：\n- $\\text{ok\\_tramp}$ 是一个布尔值，指示 TCO 模拟变体是否返回了 $X$ 的精确反转结果。\n- $\\text{plain\\_status}$ 是一个整数：如果普通变体被执行并返回了正确的反转结果，则为 $1$；如果执行后返回了不正确的结果，则为 $0$；如果因预测溢出而被跳过，则为 $-1$。\n- $\\text{steps}$ 是在被报告计数的已执行变体中观察到的元素转移步骤的整数数量（当普通变体被跳过时，报告 TCO 模拟变体的计数）。此值应等于 $n$。\n- $\\text{stack\\_plain}$ 是普通变体（如果执行）的反转函数所致的最大调用栈深度，如果跳过则为 $-1$。\n- $\\text{stack\\_tramp}$ 是 TCO 模拟变体的反转函数所致的最大调用栈深度（期望为 $1$）。\n- $\\text{overflow\\_predicted}$ 是一个布尔值，指示 $n+1 > L$ 是否成立。\n\n最终输出格式：\n你的程序应生成一行输出，其中包含从 $X_1$ 到 $X_5$ 的结果记录列表，形式为以逗号分隔并用方括号括起来的列表（例如，\"[[...],[...],...]\"）。不应打印任何额外的文本。所有使用或报告的数字都是无单位的。此问题中没有角度或百分比；除了无单位的整数和布尔值外，不需要任何单位说明。",
            "solution": "我们从基本定义和成本模型开始。\n\n一个单链表要么是空的，要么是一个序对 $(h,t)$，其中 $h$ 是头值，$t$ 是列表的其余部分。构造 $\\mathrm{cons}(h,R)$ 的时间复杂度是 $O(1)$，将一个节点解构为 $h$ 和 $t$ 的时间复杂度是 $O(1)$。尾调用是在函数语法上处于最终位置的调用；在调用者中没有后续工作。在随机存取机器（RAM）成本模型下，对常数大小数据的每个基本操作都是 $O(1)$。\n\n我们使用一个显式的累加器 $R$ 来构造反转函数：\n- 要维护的状态不变量：处理完输入列表 $X$ 的前 $k$ 个元素后，累加器 $R$ 等于已处理前缀的反转，即 $R = \\mathrm{rev}(X[0..k-1])$。\n- 转换：如果输入非空，头为 $h$，尾为 $t$，则定义 $R' \\leftarrow \\mathrm{cons}(h,R)$ 并对 $(t,R')$ 进行递归（尾调用）。\n- 基本情况：当输入为空时，返回 $R$。\n\n正确性证明通过对 $n = |X|$ 进行归纳。\n基本情况 ($n=0$)：输入为空。不变量给出 $R = \\mathrm{rev}([]) = []$，因此返回 $R$ 是正确的。\n归纳步骤：假设对于长度为 $n-1$ 的列表是正确的。设 $X = [h] \\cdot T$ 且 $|T| = n-1$。算法的一步设置 $R' \\leftarrow \\mathrm{cons}(h,R)$ 并对 $(T,R')$ 进行递归。根据应用于 $T$ 的归纳假设，递归调用返回累加到 $R'$ 上的 $\\mathrm{rev}(T)$，根据不变量的构造，这等于 $\\mathrm{rev}([h] \\cdot T)$。因此，算法返回 $\\mathrm{rev}(X)$。\n\n时间复杂度遵循 RAM 模型。$n$ 个元素中的每一个都被精确地检查一次，并且每一步都执行恒定数量的工作：解构节点并通过 $\\mathrm{cons}$ 构造一个新节点。因此，总运行时间是 $O(n)$。\n\n调用栈上的空间复杂度取决于尾调用优化（TCO）。如果没有尾调用优化（TCO），每个尾调用仍然会分配一个新的帧，因此递归深度达到 $n+1$（包括最终的基本情况调用）；因此调用栈空间是 $O(n)$。有了尾调用优化（TCO），运行时会为尾调用重用当前帧，因此调用栈深度保持恒定，$O(1)$。在像 Python 这样不应用尾调用优化（TCO）的语言中，我们可以使用 trampoline 或等效的迭代转换来模拟它：我们不在一个循环中更新状态变量 $(X,R)$ 和迭代，而不是进行尾调用。这保留了 $O(n)$ 的运行时间，并将调用栈使用量减少到 $O(1)$。\n\n为遵循每步 $O(1)$ 模型的实现细节：\n- 我们将列表表示为一个单链结构，其中空列表是一个特殊的哨兵值（如 $\\text{None}$），非空列表是一个序对 $(h,t)$。这使得 $\\mathrm{cons}$ 是 $O(1)$，并与理论分析相匹配。我们仅为输入和输出提供与宿主语言数组之间的转换器。\n- 普通的尾递归函数接受 $(X,R)$ 和一个记录当前递归深度的显式参数 $d$；它在进入时更新观察到的最大深度。每个非空步骤都会增加一个步骤计数器，并以深度 $d+1$ 对 $(t,\\mathrm{cons}(h,R))$ 进行尾调用。基本情况返回 $R$。\n- TCO 模拟变体在一个循环内执行相同的状态转换。它同样计算步骤，但不执行递归调用，因此其最大调用深度贡献为 $1$。\n- 为避免在有递归限制 $L$ 的环境中发生崩溃，我们在 $n+1 > L$ 时预测溢出。对于这种情况，我们跳过执行普通递归变体，并为那些本应在普通变体上测量的字段报告一个哨兵值 $-1$，并将一个预测溢出的布尔值设置为 $\\text{True}$。对于其他情况，我们执行两个变体并报告它们的测量值。在所有情况下，我们都检查 TCO 模拟的结果是否等于真实的反转结果。\n\n对于测试套件，设 $X_1 = [\\,]$ 所以 $n=0$，$X_2 = [7]$ 所以 $n=1$，$X_3 = [1,2,3,4,5]$ 所以 $n=5$，$X_4 = [0,1,2,\\dots,799]$ 所以 $n=800$，以及 $X_5 = [0,1,2,\\dots,(L+49)]$ 所以 $n=L+50$。对于 $X_1$ 到 $X_4$，普通变体应该会运行，并表现出最大深度 $n+1$ 和步骤数 $n$，而 TCO 模拟变体应显示最大深度 $1$ 和步骤数 $n$。对于 $X_5$，我们预测普通变体将溢出，因为 $n+1 > L$，跳过它，并将其字段报告为 $-1$，同时将 overflow-predicted 设置为 $\\text{True}$；TCO 模拟变体仍然在 $O(n)$ 时间和 $O(1)$ 栈空间内执行。\n\n最后，程序按 $X_1$ 到 $X_5$ 的顺序为每个测试聚合一条记录，并打印包含这些记录的外部列表的单行内容，以符合所要求的输出格式。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport sys\n\n# Singly linked list representation:\n# Empty list is None; node is a tuple (head, tail)\n\ndef cons(h, t):\n    return (h, t)\n\ndef from_pylist(lst):\n    head = None\n    for x in reversed(lst):\n        head = cons(x, head)\n    return head\n\ndef to_pylist(node):\n    out = []\n    while node is not None:\n        out.append(node[0])\n        node = node[1]\n    return out\n\ndef reverse_tail_plain(node, acc, depth, metrics):\n    # metrics: dict with keys 'steps', 'max_depth'\n    # Record call depth on entry.\n    if depth  metrics['max_depth']:\n        metrics['max_depth'] = depth\n    if node is None:\n        return acc\n    # Transfer one element: move head to front of acc.\n    metrics['steps'] += 1\n    h, t = node\n    return reverse_tail_plain(t, cons(h, acc), depth + 1, metrics)\n\ndef reverse_tail_trampoline(node, acc, metrics):\n    # metrics: dict with keys 'steps', 'max_depth'\n    # Simulate TCO by iterative loop; only one call frame.\n    # We record the function's call depth contribution as 1.\n    if metrics['max_depth']  1:\n        metrics['max_depth'] = 1\n    while node is not None:\n        metrics['steps'] += 1\n        h, t = node\n        acc = cons(h, acc)\n        node = t\n    return acc\n\ndef solve():\n    # Define the recursion limit L from the runtime.\n    L = sys.getrecursionlimit()\n\n    # Define the test cases from the problem statement.\n    X1 = []\n    X2 = [7]\n    X3 = [1, 2, 3, 4, 5]\n    X4 = list(range(800))\n    X5 = list(range(L + 50))  # length L+50 triggers overflow if using plain recursion\n\n    test_cases = [X1, X2, X3, X4, X5]\n\n    results = []\n    for xs in test_cases:\n        n = len(xs)\n        linked = from_pylist(xs)\n        expected = list(reversed(xs))\n\n        # Trampoline/TCO-simulated variant\n        metrics_tramp = {'steps': 0, 'max_depth': 0}\n        tramp_result_linked = reverse_tail_trampoline(linked, None, metrics_tramp)\n        tramp_result = to_pylist(tramp_result_linked)\n        ok_tramp = (tramp_result == expected)\n        stack_tramp = metrics_tramp['max_depth']\n        steps_tramp = metrics_tramp['steps']\n\n        # Decide if plain recursion is safe to run\n        overflow_predicted = (n + 1)  L\n\n        if not overflow_predicted:\n            metrics_plain = {'steps': 0, 'max_depth': 0}\n            plain_result_linked = reverse_tail_plain(linked, None, 1, metrics_plain)\n            plain_result = to_pylist(plain_result_linked)\n            ok_plain = (plain_result == expected)\n            plain_status = 1 if ok_plain else 0\n            stack_plain = metrics_plain['max_depth']\n            steps_plain = metrics_plain['steps']\n            # Steps should match n; report from either; choose plain's count\n            steps_report = steps_plain\n        else:\n            # Skip executing plain recursion to avoid overflow\n            plain_status = -1\n            stack_plain = -1\n            steps_report = steps_tramp  # report trampoline steps\n\n        result_record = [ok_tramp, plain_status, steps_report, stack_plain, stack_tramp, overflow_predicted]\n        results.append(result_record)\n\n    # Final print statement in the exact required format.\n    # Single line with the list of result records.\n    def fmt(item):\n        if isinstance(item, bool):\n            return \"True\" if item else \"False\"\n        elif isinstance(item, list):\n            return \"[\" + \",\".join(fmt(x) for x in item) + \"]\"\n        else:\n            return str(item)\n\n    print(fmt(results))\n\nsolve()\n```"
        }
    ]
}