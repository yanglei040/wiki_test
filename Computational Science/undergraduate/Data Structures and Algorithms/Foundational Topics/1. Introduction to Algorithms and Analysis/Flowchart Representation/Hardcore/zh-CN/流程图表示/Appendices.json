{
    "hands_on_practices": [
        {
            "introduction": "二分查找是一种基础且高效的算法，但其流程图实现却因“差一错误”而臭名昭昭。本练习将引导你深入分析一个看似正确的二分查找流程图，通过追踪其执行路径，你将发现中点计算和边界更新中的微小差异是如何导致无限循环的。这项实践旨在强调精确的控制流逻辑对于保证算法正确性的至关重要性，并锻炼你识别和修复此类微妙错误的能力。",
            "id": "3235351",
            "problem": "一个排序数组 $A[0], A[1], \\dots, A[n-1]$ 由 $A[i] = 2i$ 定义，适用于所有满足 $0 \\leq i \\leq n-1$ 的整数 $i$。考虑两个二分查找流程图，以决策和赋值原语（处理框和决策菱形）的级别表示，每个流程图都旨在数组 $A$ 中找到目标键 $x$：\n\n流程图 $\\mathcal{F}_{\\mathrm{low}}$ (下中点，无中点偏置):\n- 初始化 $L \\leftarrow 0$, $R \\leftarrow n-1$。\n- 循环守卫：当 $L  R$ 时，执行：\n  - 计算 $m \\leftarrow \\left\\lfloor \\frac{L+R}{2} \\right\\rfloor$。\n  - 决策：如果 $A[m]  x$，则赋值 $L \\leftarrow m$；否则赋值 $R \\leftarrow m$。\n\n流程图 $\\mathcal{F}_{\\mathrm{up}}$ (上中点，中点偏置):\n- 初始化 $L \\leftarrow 0$, $R \\leftarrow n-1$。\n- 循环守卫：当 $L  R$ 时，执行：\n  - 计算 $m \\leftarrow \\left\\lceil \\frac{L+R}{2} \\right\\rceil$。\n  - 决策：如果 $A[m] > x$，则赋值 $R \\leftarrow m$；否则赋值 $L \\leftarrow m$。\n\n假设 $x$ 被选为闭区间 $[1, 2n-3]$ 内的一个奇数。仅使用单调数组的基本性质和二分查找的循环不变量（即，所维护的搜索区间由索引 $L$ 和 $R$ 界定，且终止要求每次迭代时区间严格缩小），执行以下操作：\n\n1. 确定 $[1, 2n-3]$ 中奇数 $x$ 的集合的基数，对于这些 $x$，任一流程图会因所示的差一更新规则而进入无限循环。结果应表示为 $n$ 的精确函数。\n2. 识别可能出现此类无限循环的 $n$ 值，并从循环不变量和整数中点计算出发，给出推理链条来解释原因。\n3. 提出精确的流程图修复方案（描述修正后的决策和赋值更新，以及对循环守卫的任何必要调整），以保证对于所有输入 $(A, x)$（其中 $A$ 是按定义排序且严格递增的）都能终止。\n\n将您的最终答案表示为问题1中函数的单个闭式解析表达式。无需四舍五入。不要包含任何单位。",
            "solution": "在进行解答之前，需对问题进行验证。\n\n### 第1步：提取已知条件\n- 一个排序数组 $A[0], A[1], \\dots, A[n-1]$ 由 $A[i] = 2i$ 定义，其中 $i$ 为满足 $0 \\leq i \\leq n-1$ 的整数。\n- 目标键 $x$ 是闭区间 $[1, 2n-3]$ 内的一个奇数。\n- 流程图 $\\mathcal{F}_{\\mathrm{low}}$:\n    - 初始化 $L \\leftarrow 0$, $R \\leftarrow n-1$。\n    - 循环守卫：`while` $L  R$。\n    - 中点：$m \\leftarrow \\left\\lfloor \\frac{L+R}{2} \\right\\rfloor$。\n    - 更新：`if` $A[m]  x$, `then` $L \\leftarrow m$, `else` $R \\leftarrow m$。\n- 流程图 $\\mathcal{F}_{\\mathrm{up}}$:\n    - 初始化 $L \\leftarrow 0$, $R \\leftarrow n-1$。\n    - 循环守卫：`while` $L  R$。\n    - 中点：$m \\leftarrow \\left\\lceil \\frac{L+R}{2} \\right\\rceil$。\n    - 更新：`if` $A[m] > x$, `then` $R \\leftarrow m$, `else` $L \\leftarrow m$。\n- 任务：\n    1. 确定在 $[1, 2n-3]$ 中导致任一流程图进入无限循环的奇数 $x$ 的集合的基数。\n    2. 识别可能出现此类循环的 $n$ 值，并解释原因。\n    3. 提出精确的流程图修复方案以保证终止。\n\n### 第2步：使用提取的已知条件进行验证\n- **科学依据**：该问题是算法分析中的一个经典练习，特别关注二分查找实现的正确性和终止性。这是计算机科学中的一个基本主题。该问题是科学合理的。\n- **适定性**：该问题定义明确。数组、目标值和两种算法都以数学精度进行了规定。问题是具体的，并且期望得到一个唯一的、可推导的解。\n- **客观性**：该问题以精确、客观的语言陈述。没有主观或含糊不清的术语。\n- 该问题没有任何列出的缺陷。它是自包含的、一致的、可形式化的和可验证的。\n\n### 第3步：结论与行动\n该问题是**有效的**。将提供完整的解答。\n\n### 解答推导\n\n问题的核心是分析两种二分查找变体的终止条件。带有守卫 $L  R$ 的 `while` 循环当且仅当搜索区间的大小 $R-L$ 在每次迭代中严格减小时才会终止。如果状态 $(L, R)$ 未能改变，则会发生无限循环，这意味着在某个 $L",
            "answer": "$$\\boxed{n-1}$$"
        },
        {
            "introduction": "在理解了特定算法的流程缺陷后，我们可以将视野提升到任意流程图的通用结构分析。任何流程图都可以被抽象为一个有向图，这种强大的表示法使我们能运用图论算法来分析程序行为，例如检测那些永远无法到达终止状态的无限循环。在本练习中，你将设计一个算法来识别这些“黑洞”循环，这需要你综合运用可达性分析和环路检测等图论核心概念，从而体验从程序流程到图结构分析的思维跃迁。",
            "id": "3235265",
            "problem": "给定一个流程图的形式化表示，即一个有向图。该流程图由一个有向图 $G = (V, E)$ 表示，其中 $V = \\{0, 1, \\dots, n-1\\}$ 是节点集合，$E \\subseteq V \\times V$ 是有向边集合。每个节点代表流程图中的一个步骤：动作、决策或终止。一个特殊的起始节点表示为 $s \\in V$。一组终止节点（代表流程图停止条件的节点）表示为 $T \\subseteq V$。有向边由一个邻接表给出，其中对于每个 $v \\in V$，我们有一个后继节点列表 $N^+(v) = \\{u \\in V \\mid (v, u) \\in E\\}$。\n\n目标是确定流程图是否包含一个满足以下所有属性的无限循环：\n- 它可以从起始节点 $s$ 通过一条路径到达，即存在一个节点序列 $s = v_0, v_1, \\dots, v_k$（其中 $k \\geq 1$），使得对于所有 $i \\in \\{0, \\dots, k-1\\}$ 都有 $(v_i, v_{i+1}) \\in E$，并且循环中的某个节点在 $\\{v_0, \\dots, v_k\\}$ 中。\n- 它是一个真正的循环，意味着它包含一个有向环。形式上，存在一个非空节点序列 $w_0, w_1, \\dots, w_m$（其中 $m \\geq 1$），使得对于所有 $i \\in \\{0, \\dots, m-1\\}$ 都有 $(w_i, w_{i+1}) \\in E$ 且 $w_m = w_0$。等价地，它是 $G$ 的一个强连通分量 (SCC)，其中包含至少两个节点，或者是一个带有自环的单节点。\n- 从此循环中的任何节点都无法到达任何终止节点。形式上，对于循环中的所有 $u$ 和 $T$ 中的所有 $t$，不存在从 $u$ 到 $t$ 的路径。\n\n用于推导和算法设计的基础知识：\n- 有向图 $G = (V, E)$ 和可达性的定义：如果存在一条从节点 $x$ 到节点 $y$ 的路径，则节点 $x \\in V$ 可以到达节点 $y \\in V$。\n- 强连通分量 (SCC) 的定义：一个最大子集 $S \\subseteq V$，使得对于所有 $x, y \\in S$，都存在一条从 $x$ 到 $y$ 的路径和一条从 $y$ 到 $x$ 的路径。\n- 事实：存在有向环的充要条件是，存在一个包含至少两个节点的强连通分量，或者一个带有到自身边的单节点。\n\n你的任务是编写一个程序，对于一组预定义的测试用例，确定每个用例是否存在这样的无限循环，并输出结果。\n\n每个测试用例的输入表示（固定在程序代码中，无外部输入）：\n- 一个整数 $n$，表示节点数量，标记为 $0$ 到 $n-1$。\n- 一个长度为 $n$ 的邻接表 $A$，其中 $A[v]$ 是节点 $v$ 的后继节点列表。\n- 一个起始节点索引 $s \\in \\{0, \\dots, n-1\\}$。\n- 一组终止节点 $T \\subseteq \\{0, \\dots, n-1\\}$。\n\n用于验证解决方案不同方面的测试套件：\n- 案例 1（可达循环，无路径到达任何终止节点）：$n = 7$, $A = [[1],[2],[3],[1,4],[6],[],[]]$, $s = 0$, $T = \\{5\\}$。预期的输出元素是一个布尔值，指示是否检测到从 $s$ 可达且无法到达任何终止节点的无限循环。\n- 案例 2（循环有出口通向终止节点）：$n = 6$, $A = [[1],[2],[3,4],[1],[5],[]]$, $s = 0$, $T = \\{5\\}$。该循环可以到达一个终止节点，因此不应检测到无限循环条件。\n- 案例 3（无环图）：$n = 5$, $A = [[1],[2],[3],[4],[]]$, $s = 0$, $T = \\{4\\}$。不存在循环。\n- 案例 4（从起始节点不可达的循环）：$n = 7$, $A = [[1],[2],[3],[4],[],[6],[5]]$, $s = 0$, $T = \\{4\\}$。节点 $\\{5, 6\\}$ 上存在循环，但从 $s$ 不可达。\n- 案例 5（带有自环且无路径到达任何终止节点）：$n = 3$, $A = [[1],[1],[]]$, $s = 0$, $T = \\{2\\}$。节点 $1$ 有一个自环，并且从它无法到达任何终止节点，同时它也从 $s$ 可达。\n- 案例 6（起始节点即终止节点）：$n = 2$, $A = [[1],[]]$, $s = 0$, $T = \\{0\\}$。不应检测到无限循环。\n- 案例 7（无终止节点）：$n = 3$, $A = [[1],[2],[1]]$, $s = 0$, $T = \\emptyset$。任何可达循环都符合条件，因为没有可以到达的终止节点。\n\n要求的最终输出格式：\n- 你的程序应生成一行输出，包含一个用方括号括起来的逗号分隔的结果列表，例如 $[result_1, result_2, \\dots, result_k]$，其中每个 $result_i$ 是对应测试用例的布尔值（$\\text{True}$ 或 $\\text{False}$）。",
            "solution": "问题要求我们确定一个给定的流程图（表示为有向图 $G = (V, E)$）是否包含特定类型的无限循环。一个有效的无限循环必须同时满足一组三个属性。设一个循环由一个节点集合 $C \\subseteq V$ 表示，该集合形成一个非平凡的强连通分量（一个 $|C| > 1$ 的 SCC，或者是一个对应于带有自环节点的 $|C|=1$ 的 SCC）。要考虑这样的循环，需满足以下条件：\n\n1.  **可达性**：该循环必须能从指定的起始节点 $s \\in V$ 到达。这意味着必须存在一条从 $s$ 到至少一个节点 $w \\in C$ 的路径。\n2.  **循环性**：该循环必须是一个“真正的循环”，即它对应于图 $G$ 的一个非平凡 SCC。\n3.  **无出口**：从循环内的任何节点 $u \\in C$，都不能到达任何终止节点 $t \\in T$。\n\n对每个可能的循环直接验证这些属性在计算上可能非常密集。一种更结构化、有原则的方法是将问题分解为一系列逻辑步骤，逐步过滤图以分离出相关结构。核心策略是首先识别所有能到达终止状态的节点，将它们从构成有效循环的考虑中剪除，然后在图的剩余“安全”部分中搜索可达的循环。\n\n算法解决方案分为三个主要阶段：\n\n**阶段 1：识别能够到达终止节点的节点**\n\n设 $\\mathcal{C}_T$ 为 $V$ 中所有能够到达 $T$ 中至少一个终止节点的节点集合。形式上，\n$$ \\mathcal{C}_T = \\{ v \\in V \\mid \\exists t \\in T \\text{ 并且在 } G \\text{ 中存在一条从 } v \\text{ 到 } t \\text{ 的路径} \\} $$\n为了高效地计算这个集合，我们可以反向分析问题。在 $G$ 中存在从 $v$ 到 $t$ 的路径，当且仅当在转置图 $G^T$ 中存在从 $t$ 到 $v$ 的路径。转置图定义为 $G^T = (V, E^T)$，其中 $E^T = \\{ (u, v) \\mid (v, u) \\in E \\}$。\n\n因此，我们可以通过在 $G^T$ 上从终止集 $T$ 中的所有节点同时开始进行多源图遍历（如广度优先搜索或深度优先搜索）来找到 $\\mathcal{C}_T$ 中的所有节点。在此遍历期间访问的所有节点的集合正是 $\\mathcal{C}_T$。\n\n**阶段 2：识别“安全”循环**\n\n一个循环 $C$ 满足“无出口”属性，当且仅当其所有构成节点都是“安全”的，即它们中没有一个可以到达终止节点。设安全节点集为 $V_{\\text{safe}} = V \\setminus \\mathcal{C}_T$。一个安全循环是其所有节点都属于 $V_{\\text{safe}}$ 的循环。\n\n要找到所有属于此类安全循环的节点，我们可以分析由 $V_{\\text{safe}}$ 诱导的子图，表示为 $G_{\\text{safe}} = (V_{\\text{safe}}, E_{\\text{safe}})$，其中 $E_{\\text{safe}} = \\{ (u, v) \\in E \\mid u \\in V_{\\text{safe}} \\text{ 且 } v \\in V_{\\text{safe}} \\}$。\n\n我们需要在 $G_{\\text{safe}}$ 中找到所有非平凡的强连通分量。可以在 $G_{\\text{safe}}$ 上应用一种标准的用于在有向图中寻找所有 SCC 的算法，例如 Tarjan 算法或 Kosaraju 算法。设 $U_{\\text{safe\\_cycle}}$ 为属于 $G_{\\text{safe}}$ 的一个非平凡 SCC 的所有节点的集合。一个非平凡 SCC 是指包含多个节点，或者是一个具有自环的单节点 SCC。集合 $U_{\\text{safe\\_cycle}}$ 包含了所有满足条件 2 和 3 的节点。\n\n**阶段 3：验证从起始节点的可达性**\n\n最后一步是确定是否有任何安全循环中的节点可以从起始节点 $s$ 到达。这对应于检查在原始图 $G$ 中，$U_{\\text{safe\\_cycle}}$ 中的任何节点是否可以从 $s$ 到达。\n\n这可以通过在原始图 $G$ 上从节点 $s$ 开始进行标准的单源图遍历（BFS 或 DFS）来解决。设 $\\mathcal{R}_s$ 为从 $s$ 可达的所有节点的集合。当且仅当从 $s$ 可达的节点集合与安全循环中的节点集合的交集非空时，问题的条件得到满足。\n$$ \\mathcal{R}_s \\cap U_{\\text{safe\\_cycle}} \\neq \\emptyset $$\n在从 $s$ 开始的遍历过程中，如果我们遇到任何节点 $v$ 使得 $v \\in U_{\\text{safe\\_cycle}}$，我们就找到了从 $s$ 到一个安全循环的路径。算法此时可以终止并报告 $\\text{True}$。如果遍历完成而没有找到任何这样的节点，则不存在可达的安全循环，结果为 $\\text{False}$。\n\n这个三阶段算法通过系统地应用基本的图论原理，正确且高效地确定了指定类型的无限循环的存在性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import deque\n\ndef solve():\n    \"\"\"\n    Solves a series of test cases for detecting a specific type of infinite loop in a flowchart.\n    \"\"\"\n\n    test_cases = [\n        # Case 1 (reachable cycle without a path to any terminal)\n        {'n': 7, 'adj': [[1],[2],[3],[1,4],[6],[],[]], 's': 0, 'T': {5}},\n        # Case 2 (cycle with an exit to a terminal)\n        {'n': 6, 'adj': [[1],[2],[3,4],[1],[5],[]], 's': 0, 'T': {5}},\n        # Case 3 (acyclic graph)\n        {'n': 5, 'adj': [[1],[2],[3],[4],[]], 's': 0, 'T': {4}},\n        # Case 4 (unreachable cycle from the start node)\n        {'n': 7, 'adj': [[1],[2],[3],[4],[],[6],[5]], 's': 0, 'T': {4}},\n        # Case 5 (self-loop with no path to any terminal)\n        {'n': 3, 'adj': [[1],[1],[]], 's': 0, 'T': {2}},\n        # Case 6 (start is terminal)\n        {'n': 2, 'adj': [[1],[]], 's': 0, 'T': {0}},\n        # Case 7 (no terminal nodes)\n        {'n': 3, 'adj': [[1],[2],[1]], 's': 0, 'T': set()},\n    ]\n\n    results = []\n    for case in test_cases:\n        results.append(has_infinite_loop(case['n'], case['adj'], case['s'], case['T']))\n\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef has_infinite_loop(n, adj, s, T):\n    \"\"\"\n    Determines if a flowchart contains a reachable, non-escapable infinite loop.\n\n    This function implements a three-phase algorithm:\n    1.  Find all nodes that can reach a terminal node.\n    2.  Identify all \"safe\" cycles (cycles whose nodes cannot reach a terminal).\n    3.  Check if any node in a safe cycle is reachable from the start node.\n    \"\"\"\n\n    # Phase 1: Find all nodes that can reach a terminal node.\n    rev_adj = [[] for _ in range(n)]\n    for u in range(n):\n        for v in adj[u]:\n            rev_adj[v].append(u)\n\n    can_reach_terminal = set()\n    q = deque(list(T))\n    can_reach_terminal.update(T)\n\n    while q:\n        u = q.popleft()\n        for v in rev_adj[u]:\n            if v not in can_reach_terminal:\n                can_reach_terminal.add(v)\n                q.append(v)\n                \n    safe_nodes = {i for i in range(n) if i not in can_reach_terminal}\n\n    # Phase 2: Identify all \"safe\" cycles using Tarjan's algorithm.\n    nodes_in_safe_cycle = set()\n    \n    # Tarjan's algorithm state\n    ids = np.full(n, -1, dtype=int)\n    low_link = np.full(n, -1, dtype=int)\n    on_stack = np.full(n, False, dtype=bool)\n    stack = []\n    at_index = 0\n\n    def tarjan_dfs(u):\n        nonlocal at_index\n        stack.append(u)\n        on_stack[u] = True\n        ids[u] = low_link[u] = at_index\n        at_index += 1\n\n        for v in adj[u]:\n            if v not in safe_nodes:\n                continue\n            \n            if ids[v] == -1:\n                tarjan_dfs(v)\n                low_link[u] = min(low_link[u], low_link[v])\n            elif on_stack[v]:\n                low_link[u] = min(low_link[u], ids[v])\n\n        if low_link[u] == ids[u]:\n            scc = []\n            while stack:\n                node = stack.pop()\n                on_stack[node] = False\n                scc.append(node)\n                if node == u:\n                    break\n            \n            # Check for non-trivial SCC\n            if len(scc) > 1:\n                nodes_in_safe_cycle.update(scc)\n            elif len(scc) == 1:\n                node = scc[0]\n                # Check for self-loop\n                if node in adj[node]:\n                    nodes_in_safe_cycle.add(node)\n\n    for i in range(n):\n        if i in safe_nodes and ids[i] == -1:\n            tarjan_dfs(i)\n\n    if not nodes_in_safe_cycle:\n        return False\n\n    # Phase 3: Check if any node in a safe cycle is reachable from the start node s.\n    q_reach = deque([s])\n    visited_reach = {s}\n\n    while q_reach:\n        u = q_reach.popleft()\n        if u in nodes_in_safe_cycle:\n            return True\n        for v in adj[u]:\n            if v not in visited_reach:\n                visited_reach.add(v)\n                q_reach.append(v)\n                \n    return False\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "本章的实践将从分析走向优化。一旦我们将计算流程表示为有向无环图（DAG），我们就能系统地对其进行改进，提升其效率。本练习将向你介绍一种经典的编译器优化技术——公共子表达式消除（CSE）。你将通过为计算节点建立规范“签名”的方法，来识别并合并执行相同计算的冗余节点。这项实践不仅能让你掌握一种实用的图优化算法，更能让你体会到良好的抽象表示如何为强大的自动化优化奠定基础。",
            "id": "3235275",
            "problem": "你的任务是构建一个程序，对表示为有向无环图 (DAG) 的流程图执行公共子表达式消除 (CSE)。该流程图由纯计算节点组成，这确保了引用透明性成立：任何节点计算出的值仅取决于其输入和操作。核心问题是设计并实现一个优化器，通过合并计算相同子表达式的节点来识别并移除冗余计算，同时保留图的语义。\n\n基本基础：\n- 有向无环图 (DAG) 是一个没有有向环的有向图 $G = (V, E)$，其中 $V$ 是节点集合，$E \\subseteq V \\times V$ 是边集合。\n- 纯计算的流程图可以建模为一个 DAG，其中每个节点 $v \\in V$ 代表一个常量、一个变量（假定为静态单赋值 (SSA) 形式），或一个应用于其输入节点的操作。\n- 公共子表达式消除 (CSE) 依赖于纯计算的等价性：如果两个节点计算的是相同输入的相同数学函数，那么用一个单一的代表替换它们会保留输出。\n\n表示法：\n- 每个节点 $v \\in V$是以下之一：\n  1. 常量：$\\text{const}(c)$，其中 $c$ 是一个字面数。\n  2. 变量：$\\text{var}(x)$，其中 $x$ 是静态单赋值 (SSA) 中的变量名。\n  3. 操作：$\\text{op}(o, [u_1, u_2, \\dots])$，其中 $o \\in \\mathcal{O}$ 是一个运算符，$[u_1, u_2, \\dots]$ 是输入节点的标识符。在本问题中，运算符集合为 $\\mathcal{O} = \\{\\text{add}, \\text{mul}, \\text{sub}, \\text{div}\\}$。运算符 $\\text{add}$ 和 $\\text{mul}$ 是可交换的；$\\text{sub}$ 和 $\\text{div}$ 是不可交换的。\n- 输出是 $V$ 中指定的节点，其计算值是程序的结果。\n\n等价性的规范化：\n- 为每个节点 $v$ 定义一个规范签名函数 $\\sigma(v)$：\n  - 如果 $v = \\text{const}(c)$，则 $\\sigma(v) = (\\text{const}, c)$。\n  - 如果 $v = \\text{var}(x)$，则 $\\sigma(v) = (\\text{var}, x)$。\n  - 如果 $v = \\text{op}(o, [u_1,\\dots,u_k])$，令 $S_i = \\sigma(u_i)$ 为每个输入的签名。\n    - 如果 $o$ 是可交换的，定义 $\\sigma(v) = (o, \\text{sort}(S_1, \\dots, S_k))$，其中排序是基于签名的字典序。\n    - 如果 $o$ 是不可交换的，定义 $\\sigma(v) = (o, (S_1, \\dots, S_k))$，保留顺序。\n- 两个节点 $v$ 和 $w$ 被认为是等价的，当且仅当 $\\sigma(v) = \\sigma(w)$，记作 $v \\equiv w$。\n\n目标：\n- 实现一个优化器，给定一个流程图 DAG，它以拓扑顺序为所有节点计算 $\\sigma(v)$，并通过将边重定向到一个唯一的代表节点来合并具有相同签名的节点。移除重复节点，同时保留输出。\n\n要求：\n- 假设所有图都是无环的。\n- 假设计算是纯的，没有副作用，并且变量处于静态单赋值 (SSA) 形式，因此相同的变量名表示相同的值。\n- 实现拓扑处理，以确保输入在其依赖节点之前被规范化。\n\n输出规格：\n- 对于提供的每个测试用例，计算三元组 $[n_{\\text{before}}, n_{\\text{after}}, n_{\\text{eliminated}}]$，其中 $n_{\\text{before}}$ 是优化前的节点数，$n_{\\text{after}}$ 是优化后的节点数，以及 $n_{\\text{eliminated}} = n_{\\text{before}} - n_{\\text{after}}$。这些都是整数。\n- 你的程序应该生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个元素是对应测试用例的三元组（也用方括号括起来），并按测试套件的顺序排列。\n\n测试套件：\n- 案例1（包含重复常量和操作的正常路径）：\n  - 节点：\n    - $0$: $\\text{const}(3)$\n    - $1$: $\\text{const}(3)$\n    - $2$: $\\text{const}(4)$\n    - $3$: $\\text{const}(4)$\n    - $4$: $\\text{add}([0, 2])$\n    - $5$: $\\text{add}([1, 3])$\n    - $6$: $\\text{mul}([4, 5])$\n  - 输出：$[6]$\n  - 预期效果：常量和加法操作被去重。\n- 案例2（交换律与非交换律）：\n  - 节点：\n    - $0$: $\\text{var}(x)$\n    - $1$: $\\text{var}(y)$\n    - $2$: $\\text{add}([0, 1])$\n    - $3$: $\\text{add}([1, 0])$\n    - $4$: $\\text{sub}([0, 1])$\n    - $5$: $\\text{sub}([1, 0])$\n  - 输出：$[2, 3, 4, 5]$\n  - 预期效果：加法操作被去重；减法操作不会。\n- 案例3（无冗余）：\n  - 节点：\n    - $0$: $\\text{var}(x)$\n    - $1$: $\\text{const}(1)$\n    - $2$: $\\text{add}([0, 1])$\n    - $3$: $\\text{mul}([0, 1])$\n  - 输出：$[2, 3]$\n- 案例4（未利用结合律）：\n  - 节点：\n    - $0$: $\\text{var}(a)$\n    - $1$: $\\text{var}(b)$\n    - $2$: $\\text{var}(c)$\n    - $3$: $\\text{add}([0, 1])$\n    - $4$: $\\text{add}([3, 2])$\n    - $5$: $\\text{add}([1, 2])$\n    - $6$: $\\text{add}([0, 5])$\n  - 输出：$[4, 6]$\n  - 预期效果：由于分组不同，没有去重；只考虑交换律。\n- 案例5（边界情况：单个节点）：\n  - 节点：\n    - $0$: $\\text{const}(42)$\n  - 输出：$[0]$\n- 案例6（嵌套重复项传播）：\n  - 节点：\n    - $0$: $\\text{var}(x)$\n    - $1$: $\\text{var}(y)$\n    - $2$: $\\text{var}(z)$\n    - $3$: $\\text{add}([0, 1])$\n    - $4$: $\\text{mul}([3, 2])$\n    - $5$: $\\text{add}([0, 1])$\n    - $6$: $\\text{mul}([5, 2])$\n  - 输出：$[4, 6]$\n  - 预期效果：重复的 $\\text{add}$ 和重复的 $\\text{mul}$ 都被去重。\n\n最终输出格式：\n- 你的程序应该准确地生成一行输出，其中包含一个包含6个结果三元组的列表，例如：$[[n_{1,\\text{before}},n_{1,\\text{after}},n_{1,\\text{eliminated}}],\\dots,[n_{6,\\text{before}},n_{6,\\text{after}},n_{6,\\text{eliminated}}]]$。不需要空格。",
            "solution": "用户提供了一个问题陈述，要求实现对以有向无环图 (DAG) 表示的流程图进行公共子表达式消除 (CSE)。第一步是验证问题陈述。\n\n### 步骤1：提取已知信息\n\n- **图模型**：一个有向无环图 $G = (V, E)$。\n- **节点类型**：\n    1.  常量：$\\text{const}(c)$，其中 $c$ 是一个字面数。\n    2.  变量：$\\text{var}(x)$，其中 $x$ 是静态单赋值 (SSA) 中的变量名。\n    3.  操作：$\\text{op}(o, [u_1, u_2, \\dots])$，其中 $o$ 是一个运算符，$[u_1, u_2, \\dots]$ 是输入节点的标识符。\n- **运算符集合**：$\\mathcal{O} = \\{\\text{add}, \\text{mul}, \\text{sub}, \\text{div}\\}$。\n- **交换律**：运算符 $\\text{add}$ 和 $\\text{mul}$ 是可交换的。运算符 $\\text{sub}$ 和 $\\text{div}$ 是不可交换的。\n- **规范签名 $\\sigma(v)$**：\n    - 对于 $v = \\text{const}(c)$，$\\sigma(v) = (\\text{const}, c)$。\n    - 对于 $v = \\text{var}(x)$，$\\sigma(v) = (\\text{var}, x)$。\n    - 对于 $v = \\text{op}(o, [u_1,\\dots,u_k])$，令 $S_i = \\sigma(u_i)$。\n        - 如果 $o$ 是可交换的，$\\sigma(v) = (o, \\text{sort}(S_1, \\dots, S_k))$。\n        - 如果 $o$ 是不可交换的，$\\sigma(v) = (o, (S_1, \\dots, S_k))$。\n- **等价性**：两个节点 $v, w$ 是等价的 ($v \\equiv w$) 当且仅当 $\\sigma(v) = \\sigma(w)$。\n- **目标**：实现一个优化器，以拓扑顺序合并具有相同签名的节点。优化器应移除重复节点并保留输出。\n- **假设**：\n    1.  所有图都是无环的。\n    2.  计算是纯的，没有副作用。\n    3.  变量采用静态单赋值（SSA）。\n- **输出要求**：对于每个测试用例，计算并输出一个三元组 $[n_{\\text{before}}, n_{\\text{after}}, n_{\\text{eliminated}}]$，其中 $n_{\\text{before}}$ 是初始节点数，$n_{\\text{after}}$ 是最终节点数，$n_{\\text{eliminated}} = n_{\\text{before}} - n_{\\text{after}}$。最终输出必须是包含所有测试用例的这些三元组的单行列表。\n- **测试套件**：提供了六个特定的测试用例，每个用例都有一组节点和指定的输出节点。\n\n### 步骤2：使用提取的已知信息进行验证\n\n- **科学依据**：该问题基于公共子表达式消除，这是编译器设计中一项基本且标准的优化技术。DAG、SSA 和引用透明性的使用是该领域的核心概念。该问题在科学上是合理的。\n- **适定性**：该问题是适定的。输入是一个由一组具有指定属性的节点定义的图。优化过程通过规范签名函数 $\\sigma(v)$ 和按拓扑顺序处理节点的指令被清晰定义。等价规则是明确的。预期的输出格式有明确的详细说明。这种结构确保了可以为每个测试用例确定一个唯一且有意義的解决方案。\n- **客观性**：该问题以正式、客观的语言陈述，没有歧义或主观主张。节点类型、运算符和交换律的定义是精确的。\n\n该问题不存在任何无效性缺陷：\n1.  **科学或事实不健全**：无。其原理是标准的计算机科学概念。\n2.  **不可形式化或不相关**：无。该问题可直接形式化为图上的算法。\n3.  **不完整或矛盾的设置**：无。该问题是自洽的。测试用例中提供的节点列表已按其整数ID进行拓扑排序，这简化了实现且不失一般性。\n4.  **不切实际或不可行**：无。该模型是现实世界问题的有效简化。\n5.  **不适定或结构不良**：无。使用拓扑处理结合明确定义的签名函数保证了结果的唯一性。\n6.  **伪深刻、平凡或同义反复**：无。该问题需要正确实现一个涉及哈希和节点重映射的非平凡图算法。忽略结合律的约束是一个合理的简化，而不是将其变得無價值。\n7aws **超出科学可验证性**：无。算法的结果可以通过手动将指定规则应用于测试用例来确定性地验证。\n\n### 步驟3：結論與行動\n\n该问题是**有效的**。将开发一个解决方案。\n\n### 解决方案\n\n目标是在给定的有向无环图（DAG）上执行公共子表达式消除（CSE）。核心思想是识别并合并那些对相同输入执行相同计算的节点。\n\n**原理：**\n该算法利用了纯函数中的引用透明性原理。如果两个节点使用等效的输入计算相同的函数，它们的输出也是相同的。因此，我们可以用其中一个节点替换另一个节点的所有出现。识别等价性的过程基于每个节点 $v$ 的规范签名 $\\sigma(v)$。\n\n**算法设计：**\n我们将按拓扑顺序处理图的节点。问题陈述指出，每个测试用例的节点列表已经按拓扑排序提供（即，节点的依赖项总是具有更小的ID）。这允许我们从第一个节点到最后一个节点进行简单的迭代。\n\n在此遍历过程中，我们维护两个主要的数据结构：\n1.  一个哈希表 `signatures_to_id`，它将一个规范签名映射到其首次出现的代表节点的ID。签名唯一地标识了一个计算。\n2.  一个映射数组 `canonical_map`，其中 `canonical_map[i]` 存储代表原始节点 $i$ 的规范节点的ID。如果节点 $i$ 被合并到节点 $j$ 中，那么 `canonical_map[i]` 将为 $j$。\n\n对于给定的图，分步过程如下：\n\n1.  初始化 `signatures_to_id = {}` 和 `canonical_map = [i for i in range(n_before)]`，其中 $n_{\\text{before}}$ 是初始节点数。\n2.  从ID 0到 $n_{\\text{before}} - 1$ 遍历每个节点 $v$。\n3.  对于每个节点 $v$，计算其规范签名。该签名取决于节点的类型：\n    - 如果 $v$ 是 $\\text{const}(c)$，签名为 $(\\text{'const'}, c)$。\n    - 如果 $v$ 是 $\\text{var}(x)$，签名为 $(\\text{'var'}, x)$。\n    - 如果 $v$ 是 $\\text{op}(o, [u_1, u_2, \\dots, u_k])$，签名由运算符 $o$ 和其输入的*规范ID*构成。输入 $u_j$ 的规范ID通过 `canonical_map[u_j]` 找到。\n        - 令规范输入ID列表为 $U' = [\\text{canonical\\_map}[u_1], \\text{canonical\\_map}[u_2], \\dots, \\text{canonical\\_map}[u_k]]$。\n        - 如果运算符 $o$ 是可交换的（例如 $\\text{add}$，$\\text{mul}$），则列表 $U'$ 在用于签名之前进行排序。这确保了像 $\\text{add}(a, b)$ 和 $\\text{add}(b, a)$ 这样的表达式产生相同的签名。签名变为 $(o, \\text{tuple}(\\text{sorted}(U')))$。\n        - 如果运算符 $o$ 是不可交换的（例如 $\\text{sub}$，$\\text{div}$），则输入的顺序被保留。签名为 $(o, \\text{tuple}(U')))$。\n4.  一旦计算出节点 $v$ 的签名 `sig`，检查 `sig` 是否作为键存在于 `signatures_to_id` 中。\n    - **如果找到 `sig`**：这意味着我们遇到了一个冗余计算。节点 $v$ 是ID为 `signatures_to_id[sig]` 的节点的副本。设这个规范节点ID为 $j$。我们更新映射：`canonical_map[v.id] = j`。\n    - **如果未找到 `sig`**：这是第一次看到这个计算。节点 $v$ 成为此签名的规范代表。我们将新签名添加到我们的映射中：`signatures_to_id[sig] = v.id`。$v$ 的映射保持为 `canonical_map[v.id] = v.id`。\n5.  遍历所有节点后，优化完成。优化前的总节点数是 $n_{\\text{before}}$。优化后的节点数 $n_{\\text{after}}$ 是唯一规范节点的数量。这等同于 `canonical_map` 数组中唯一值的数量。\n6.  消除的节点数是 $n_{\\text{eliminated}} = n_{\\text{before}} - n_{\\text{after}}$。\n7.  该测试用例的最终结果是三元组 $[n_{\\text{before}}, n_{\\text{after}}, n_{\\text{eliminated}}]$。对测试套件中的每个测试用例重复此过程。\n\n这种动态规划方法正确地实现了签名 $\\sigma(v)$ 的递归定义，因为它确保了当我们在计算一个节点的签名时，其输入的签名已经被解析为它们的规范形式。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Common Subexpression Elimination problem for a suite of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each node is represented as a dictionary.\n    test_suite = [\n        # Case 1 (happy path with duplicate constants and operations)\n        {\n            \"nodes\": [\n                {'id': 0, 'type': 'const', 'value': 3},\n                {'id': 1, 'type': 'const', 'value': 3},\n                {'id': 2, 'type': 'const', 'value': 4},\n                {'id': 3, 'type': 'const', 'value': 4},\n                {'id': 4, 'type': 'op', 'op': 'add', 'inputs': [0, 2]},\n                {'id': 5, 'type': 'op', 'op': 'add', 'inputs': [1, 3]},\n                {'id': 6, 'type': 'op', 'op': 'mul', 'inputs': [4, 5]},\n            ],\n            \"outputs\": [6]\n        },\n        # Case 2 (commutativity versus non-commutativity)\n        {\n            \"nodes\": [\n                {'id': 0, 'type': 'var', 'name': 'x'},\n                {'id': 1, 'type': 'var', 'name': 'y'},\n                {'id': 2, 'type': 'op', 'op': 'add', 'inputs': [0, 1]},\n                {'id': 3, 'type': 'op', 'op': 'add', 'inputs': [1, 0]},\n                {'id': 4, 'type': 'op', 'op': 'sub', 'inputs': [0, 1]},\n                {'id': 5, 'type': 'op', 'op': 'sub', 'inputs': [1, 0]},\n            ],\n            \"outputs\": [2, 3, 4, 5]\n        },\n        # Case 3 (no redundancy)\n        {\n            \"nodes\": [\n                {'id': 0, 'type': 'var', 'name': 'x'},\n                {'id': 1, 'type': 'const', 'value': 1},\n                {'id': 2, 'type': 'op', 'op': 'add', 'inputs': [0, 1]},\n                {'id': 3, 'type': 'op', 'op': 'mul', 'inputs': [0, 1]},\n            ],\n            \"outputs\": [2, 3]\n        },\n        # Case 4 (associativity not exploited)\n        {\n            \"nodes\": [\n                {'id': 0, 'type': 'var', 'name': 'a'},\n                {'id': 1, 'type': 'var', 'name': 'b'},\n                {'id': 2, 'type': 'var', 'name': 'c'},\n                {'id': 3, 'type': 'op', 'op': 'add', 'inputs': [0, 1]},\n                {'id': 4, 'type': 'op', 'op': 'add', 'inputs': [3, 2]},\n                {'id': 5, 'type': 'op', 'op': 'add', 'inputs': [1, 2]},\n                {'id': 6, 'type': 'op', 'op': 'add', 'inputs': [0, 5]},\n            ],\n            \"outputs\": [4, 6]\n        },\n        # Case 5 (boundary: single node)\n        {\n            \"nodes\": [\n                {'id': 0, 'type': 'const', 'value': 42},\n            ],\n            \"outputs\": [0]\n        },\n        # Case 6 (nested duplicates propagate)\n        {\n            \"nodes\": [\n                {'id': 0, 'type': 'var', 'name': 'x'},\n                {'id': 1, 'type': 'var', 'name': 'y'},\n                {'id': 2, 'type': 'var', 'name': 'z'},\n                {'id': 3, 'type': 'op', 'op': 'add', 'inputs': [0, 1]},\n                {'id': 4, 'type': 'op', 'op': 'mul', 'inputs': [3, 2]},\n                {'id': 5, 'type': 'op', 'op': 'add', 'inputs': [0, 1]},\n                {'id': 6, 'type': 'op', 'op': 'mul', 'inputs': [5, 2]},\n            ],\n            \"outputs\": [4, 6]\n        }\n    ]\n\n    commutative_ops = {'add', 'mul'}\n\n    def optimize_graph(nodes):\n        \"\"\"\n        Performs CSE on a single graph and returns node counts.\n        \"\"\"\n        n_before = len(nodes)\n        if n_before == 0:\n            return [0, 0, 0]\n\n        signatures_to_id = {}\n        canonical_map = list(range(n_before))\n\n        for node in nodes:\n            node_id = node['id']\n            node_type = node['type']\n            \n            signature = None\n            if node_type == 'const':\n                signature = ('const', node['value'])\n            elif node_type == 'var':\n                signature = ('var', node['name'])\n            elif node_type == 'op':\n                op = node['op']\n                canonical_inputs = [canonical_map[i] for i in node['inputs']]\n                \n                if op in commutative_ops:\n                    canonical_inputs.sort()\n                \n                signature = (op, tuple(canonical_inputs))\n\n            if signature in signatures_to_id:\n                canonical_id = signatures_to_id[signature]\n                canonical_map[node_id] = canonical_id\n            else:\n                signatures_to_id[signature] = node_id\n                # map already has canonical_map[node_id] = node_id by default\n\n        unique_canonical_nodes = set(canonical_map)\n        n_after = len(unique_canonical_nodes)\n        n_eliminated = n_before - n_after\n        \n        return [n_before, n_after, n_eliminated]\n\n    results = []\n    for case in test_suite:\n        nodes = case[\"nodes\"]\n        result_triple = optimize_graph(nodes)\n        results.append(result_triple)\n\n    # Format the final output string exactly as specified.\n    case_strings = [f\"[{r[0]},{r[1]},{r[2]}]\" for r in results]\n    final_output = f\"[{','.join(case_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```"
        }
    ]
}