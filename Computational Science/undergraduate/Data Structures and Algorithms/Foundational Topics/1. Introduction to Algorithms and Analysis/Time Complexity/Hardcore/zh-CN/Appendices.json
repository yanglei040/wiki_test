{
    "hands_on_practices": [
        {
            "introduction": "许多分治算法将问题分解为大小相等的子问题，但实际情况可能更为复杂。本练习将引导你分析一个不平衡的递归关系，其中子问题的大小并不相等 。通过这个练习，你将学会如何运用递归树或替换法等基本原理，来处理那些无法直接套用主定理（Master Theorem）的常见情况，从而加深对分治算法时间复杂度分析核心思想的理解。",
            "id": "3279209",
            "problem": "一个处理大小为 $n$ 的输入的算法遵循分治原则：它将问题分解为两个规模分别为 $\\lfloor n/2 \\rfloor$ 和 $\\lfloor n/3 \\rfloor$ 的子问题，递归地解决每个子问题，然后执行一个合并步骤，其成本与当前问题的规模成线性关系。令 $T(n)$ 表示处理大小为 $n$ 的输入时，最坏情况下的基本操作次数，并假设一个常数时间的基准情况 $T(1)=d$ (对于某个固定的 $d0$)。合并步骤需要 $cn$ 次操作 (对于某个固定的 $c0$)。\n\n从分治递推关系的核心定义以及大Theta ($\\Theta$) 符号作为渐近增长分类（在常数因子范围内）的意义出发，首先为 $T(n)$ 建立一个能描述此算法的精确数学递推关系。然后，通过从第一性原理和递推分析中成熟的结果来分析此递推关系，确定主导项增长函数 $f(n)$，使得对于足够大的 $n$，$T(n)$ 的上下界分别为 $f(n)$ 的常数倍。\n\n将你的最终答案表示为一个仅含 $n$ 的单一封闭形式解析表达式 $f(n)$，不使用任何渐近分类符号（例如，不要写 $\\Theta(\\cdot)$、$\\mathcal{O}(\\cdot)$ 或 $\\Omega(\\cdot)$）。无需进行四舍五入。",
            "solution": "题目要求建立并对一个分治递推关系进行渐近分析。\n\n首先，我们必须为处理大小为 $n$ 的输入时的最坏情况操作次数 $T(n)$ 建立递推关系。根据题目描述，该算法将问题分解为两个规模分别为 $\\lfloor n/2 \\rfloor$ 和 $\\lfloor n/3 \\rfloor$ 的子问题。解决这些子问题的时间分别为 $T(\\lfloor n/2 \\rfloor)$ 和 $T(\\lfloor n/3 \\rfloor)$。合并步骤需要与当前问题规模成线性的操作次数，即 $cn$ (对于某个常数 $c  0$)。递归的基准情况被指定为 $T(1) = d$ (对于某个常数 $d  0$)。\n\n综合这些部分，$T(n)$ 的递推关系是：\n$$\nT(n) = \\begin{cases}\n    d  \\text{if } n=1 \\\\\n    T(\\lfloor n/2 \\rfloor) + T(\\lfloor n/3 \\rfloor) + cn  \\text{if } n1\n\\end{cases}\n$$\n题目要求我们找到主导项增长函数 $f(n)$，使得 $T(n) = \\Theta(f(n))$，这意味着我们必须找到函数 $f(n)$ 以及正常数 $k_1, k_2, n_0$，使得对于所有 $n \\ge n_0$ 都有 $k_2 f(n) \\le T(n) \\le k_1 f(n)$。\n\n我们可以通过检查递归树中每一层所做的工作来形成关于 $T(n)$ 增长的假设。在根部（第0层），工作量是 $cn$。在第1层，工作量是 $c(\\lfloor n/2 \\rfloor) + c(\\lfloor n/3 \\rfloor) \\approx c(n/2 + n/3) = cn(5/6)$。在第2层，工作量近似为 $cn(1/2+1/3)^2 = cn(5/6)^2$。总工作量是所有层级工作量的总和。这个和构成一个公比为 $5/6$ 的几何级数，该公比小于1。因此，该和由第一项 $cn$ 主导。这表明 $T(n)$ 随 $n$ 线性增长，因此我们假设 $T(n) = \\Theta(n)$。现在我们将使用代入法来正式证明这个假设。\n\n为了证明 $T(n) = \\Theta(n)$，我们必须同时证明 $T(n) = O(n)$ 和 $T(n) = \\Omega(n)$。\n\n**1. 上界：$T(n) = O(n)$**\n\n我们必须证明存在常数 $k_1  0$ 和整数 $n_0$，使得对于所有 $n \\ge n_0$，$T(n) \\le k_1 n$。我们使用归纳法证明。\n归纳假设 (I.H.)：假设对于所有 $m  n$，$T(m) \\le k_1 m$。\n\n对于 $n  1$，我们有：\n$$\nT(n) = T(\\lfloor n/2 \\rfloor) + T(\\lfloor n/3 \\rfloor) + cn\n$$\n将归纳假设应用于 $T(\\lfloor n/2 \\rfloor)$ 和 $T(\\lfloor n/3 \\rfloor)$（因为当 $n1$ 时，$\\lfloor n/2 \\rfloor  n$ 且 $\\lfloor n/3 \\rfloor  n$）：\n$$\nT(n) \\le k_1 \\lfloor n/2 \\rfloor + k_1 \\lfloor n/3 \\rfloor + cn\n$$\n使用性质 $\\lfloor x \\rfloor \\le x$：\n$$\nT(n) \\le k_1 (n/2) + k_1 (n/3) + cn = k_1 n \\left(\\frac{1}{2} + \\frac{1}{3}\\right) + cn = k_1 n \\left(\\frac{5}{6}\\right) + cn\n$$\n为了完成证明，我们需要证明对于一个合适的 $k_1$ 选择，此表达式小于或等于 $k_1 n$：\n$$\nk_1 n \\left(\\frac{5}{6}\\right) + cn \\le k_1 n\n$$\n$$\ncn \\le k_1 n - k_1 n \\left(\\frac{5}{6}\\right)\n$$\n$$\ncn \\le k_1 n \\left(1 - \\frac{5}{6}\\right)\n$$\n$$\ncn \\le k_1 n \\left(\\frac{1}{6}\\right)\n$$\n由于 $n0$，我们可以两边同除以 $n$：\n$$\nc \\le \\frac{k_1}{6} \\implies k_1 \\ge 6c\n$$\n由于 $c  0$，我们可以选择一个常数 $k_1$，例如 $k_1 = 6c$。为了使这个选择有效，基准情况也必须满足。我们需要 $T(1) \\le k_1(1)$，即 $d \\le 6c$。如果此条件不成立（即 $d  6c$），我们可以选择一个更大的 $k_1$，例如 $k_1 = \\max(6c, d)$，这样既能满足归纳步骤，也能满足 $n=1$ 时的基准情况。或者，我们可以选择一个足够大的 $n_0$ 来克服基准情况的影响。通过适当地选择 $k_1$（例如 $k_1=7c$ 并通过调整 $n_0$ 来处理小 $n$ 的基准情况），不等式成立。因此，$T(n) = O(n)$。\n\n**2. 下界：$T(n) = \\Omega(n)$**\n\n我们必须证明存在常数 $k_2  0$ 和整数 $n_0$，使得对于所有 $n \\ge n_0$，$T(n) \\ge k_2 n$。\n归纳假设 (I.H.)：假设对于所有 $m  n$，$T(m) \\ge k_2 m$。\n\n对于 $n  1$：\n$$\nT(n) = T(\\lfloor n/2 \\rfloor) + T(\\lfloor n/3 \\rfloor) + cn\n$$\n应用归纳假设：\n$$\nT(n) \\ge k_2 \\lfloor n/2 \\rfloor + k_2 \\lfloor n/3 \\rfloor + cn\n$$\n这一次，为了建立下界，我们使用性质 $\\lfloor x \\rfloor  x - 1$：\n$$\nT(n)  k_2 (n/2 - 1) + k_2 (n/3 - 1) + cn = k_2 n \\left(\\frac{5}{6}\\right) - 2k_2 + cn\n$$\n我们想证明这个表达式大于或等于 $k_2 n$：\n$$\nk_2 n \\left(\\frac{5}{6}\\right) - 2k_2 + cn \\ge k_2 n\n$$\n$$\ncn \\ge k_2 n - k_2 n \\left(\\frac{5}{6}\\right) + 2k_2\n$$\n$$\ncn \\ge k_2 n \\left(\\frac{1}{6}\\right) + 2k_2\n$$\n两边同除以 $n$（对于 $n0$）：\n$$\nc \\ge \\frac{k_2}{6} + \\frac{2k_2}{n}\n$$\n这个不等式必须对所有 $n \\ge n_0$ 成立。随着 $n$ 的增加，项 $2k_2/n$ 减小。因此，如果该不等式对 $n_0$ 成立，那么它对所有 $n  n_0$ 也成立。当 $n \\to \\infty$ 时，该条件趋近于 $c \\ge k_2/6$。这意味着我们必须选择 $k_2$ 使得 $k_2 \\le 6c$。\n让我们选择 $k_2 = c$。由于 $c0$，所以 $k_20$。条件变为：\n$$\nc \\ge \\frac{c}{6} + \\frac{2c}{n} \\implies 1 \\ge \\frac{1}{6} + \\frac{2}{n} \\implies \\frac{5}{6} \\ge \\frac{2}{n} \\implies 5n \\ge 12 \\implies n \\ge \\frac{12}{5} = 2.4\n$$\n所以，归纳步骤对所有 $n \\ge 3$ 成立。我们必须检查 $n=1, 2$ 的基准情况。\n对于 $n=1$，我们需要 $T(1) = d \\ge k_2(1) = c$。如果 $d  c$，我们可以选择一个较小的 $k_2$（例如，只要 $d0$，$k_2 = \\min(c, d)$），或者简单地指出渐近界在 $n \\ge n_0$ 时成立，其中 $n_0$ 足够大。为简单起见，并且由于渐近分析关注的是大的 $n$，我们可以选择 $n_0 \\ge 3$。一个简单的论证是，对于所有 $n \\ge 1$，$T(n) \\ge cn$，这立即意味着 $T(n) = \\Omega(n)$ 且 $k_2=c$。这是因为 $T(n)$ 是非负项 $T(\\lfloor n/2 \\rfloor)$、$T(\\lfloor n/3 \\rfloor)$ 和一个正项 $cn$ 的和。\n\n由于我们已经证明了 $T(n) = O(n)$ 和 $T(n) = \\Omega(n)$，我们可以得出结论 $T(n) = \\Theta(n)$。\n题目要求描述这种渐进行为的主导项增长函数 $f(n)$。这个函数是 $f(n) = n$。",
            "answer": "$$\n\\boxed{n}\n$$"
        },
        {
            "introduction": "即使是形式上看起来很标准的分治递归式，其非递归部分 $f(n)$ 的细微差别也可能导致其分析超出标准主定理的应用范畴。本练习探讨的正是这样一个经典的“临界”情况 ，其中非递归项的增长速度刚好处于主定理两个判例之间的“灰色地带”。解决这个问题将深化你对主定理背后原理的理解，并掌握如何通过精确地对递归树的各层工作量求和来进行更精细的复杂度分析。",
            "id": "3279114",
            "problem": "考虑一个分治递归式：\n$$T(n)=2\\,T\\!\\left(\\frac{n}{2}\\right)+\\frac{n}{\\ln n},$$\n对于所有为2的幂的整数输入 $n \\geq 2$，其基本情况为 $T(1)=\\Theta(1)$。此处 $\\ln$ 表示自然对数。在标准分析中，主定理（MT）不能直接处理非递归工作项为 $f(n)=n/\\ln n$ 的情况。\n\n从渐进增长的核心定义和分治递归式的结构出发，并仅使用经过充分检验的分析工具（如严格的递归树求和和积分近似论证），推导当 $n \\to \\infty$ 时 $T(n)$ 的紧渐进增长阶。将您的最终答案表示为关于 $n$ 和初等函数的单一标准复杂度类表达式。不需要进行数值取舍。",
            "solution": "我们的任务是找出以下递归关系的紧渐进增长阶\n$$T(n) = 2 T\\left(\\frac{n}{2}\\right) + \\frac{n}{\\ln n}$$\n其基本情况为 $T(1) = \\Theta(1)$，适用于 $n$ 为2的整数次幂的情况，即对于某个整数 $k \\ge 0$，有 $n=2^k$。\n\n我们将使用递归树方法来求解这个递归式。设 $n=2^k$，这意味着 $k = \\log_2(n)$。递归树的深度为 $k$。\n\n在递归树的每一层 $i$（根节点在第 $i=0$ 层），有 $2^i$ 个子问题。在第 $i$ 层，每个子问题的规模为 $n_i = n/2^i$。在第 $i$ 层的每个节点所做的工作（不包括递归调用）是 $f(n_i) = \\frac{n_i}{\\ln n_i}$。\n\n在第 $i$ 层完成的总工作量是该层的节点数乘以每个节点的工作量：\n$$\\text{Work at level } i = 2^i \\times f\\left(\\frac{n}{2^i}\\right) = 2^i \\times \\frac{n/2^i}{\\ln(n/2^i)} = \\frac{n}{\\ln(n) - i \\ln(2)}$$\n总运行时间 $T(n)$ 是树的所有层级所做工作的总和，从根节点（第0层）到叶子节点的前一层（第 $k-1$ 层），再加上在叶子节点（第 $k$ 层）所做的工作。\n\n叶子节点的数量是 $2^k = n$。每个叶子节点的问题规模是 $n/2^k = 1$。每个叶子节点的成本是 $T(1) = \\Theta(1)$。因此，叶子节点的总成本是 $n \\times T(1) = \\Theta(n)$。\n\n总的非递归工作量是从第 $i=0$ 层到第 $k-1$ 层的工作量之和：\n$$\\sum_{i=0}^{k-1} \\frac{n}{\\ln(n) - i \\ln(2)}$$\n为了简化这个和式，我们代入 $\\ln(n) = \\ln(2^k) = k \\ln(2)$：\n$$\\text{Sum} = \\sum_{i=0}^{k-1} \\frac{n}{k \\ln(2) - i \\ln(2)} = \\frac{n}{\\ln(2)} \\sum_{i=0}^{k-1} \\frac{1}{k-i}$$\n我们在求和中进行换元。令 $j = k-i$。当 $i$ 从 $0$ 变为 $k-1$ 时，$j$ 从 $k$ 递减到 $1$。和式变为：\n$$\\text{Sum} = \\frac{n}{\\ln(2)} \\sum_{j=1}^{k} \\frac{1}{j}$$\n求和 $\\sum_{j=1}^{k} \\frac{1}{j}$ 是第 $k$ 个调和数，记作 $H_k$。一个公认的结论是，对于较大的 $k$，调和级数具有以下渐近行为：\n$$H_k = \\ln(k) + \\gamma + O\\left(\\frac{1}{k}\\right)$$\n其中 $\\gamma$ 是欧拉-马斯刻若尼常数。因此，$H_k = \\Theta(\\ln k)$。\n\n将此结果代回非递归工作量的表达式中：\n$$\\text{Sum} = \\frac{n}{\\ln(2)} H_k = \\frac{n}{\\ln(2)} \\Theta(\\ln k) = \\Theta(n \\ln k)$$\n总运行时间 $T(n)$ 是叶子节点成本和非递归工作量之和：\n$$T(n) = \\Theta(n) + \\Theta(n \\ln k)$$\n当 $n \\to \\infty$ 时，$k = \\log_2(n) \\to \\infty$。由于 $\\ln(k)$ 是 $k$ 的增长函数，因此 $\\Theta(n \\ln k)$ 项主导 $\\Theta(n)$ 项。\n因此，$T(n)$ 的渐近行为由下式给出：\n$$T(n) = \\Theta(n \\ln k)$$\n最后，我们必须用 $n$ 来表示这个结果。我们代入 $k = \\log_2(n)$：\n$$T(n) = \\Theta(n \\ln(\\log_2 n))$$\n我们可以简化对数项。使用对数的换底公式，$\\log_2(n) = \\frac{\\ln(n)}{\\ln(2)}$：\n$$\\ln(\\log_2 n) = \\ln\\left(\\frac{\\ln n}{\\ln 2}\\right) = \\ln(\\ln n) - \\ln(\\ln 2)$$\n当 $n \\to \\infty$ 时，$\\ln(\\ln n) \\to \\infty$，而 $\\ln(\\ln 2)$ 是一个负常数。因此，$\\ln(\\ln n)$ 项占主导地位。这意味着 $\\ln(\\log_2 n) = \\Theta(\\ln(\\ln n))$。\n\n将这最终的简化代入我们关于 $T(n)$ 的表达式中：\n$$T(n) = \\Theta(n \\cdot \\Theta(\\ln(\\ln n))) = \\Theta(n \\ln(\\ln n))$$\n这就是给定递推式的紧渐近增长阶。",
            "answer": "$$\\boxed{\\Theta(n \\ln(\\ln n))}$$"
        },
        {
            "introduction": "算法分析不仅在于评估一个给定算法的效率（寻找时间复杂度的上界），更在于探索一个问题固有的计算难度（确定时间复杂度的下界）。本练习将视角从“上界”转向“下界”，要求你推导出找出数组中第二小元素所需的最少比较次数 。这个经典的“选择问题”将教会你如何运用“对手论证”（adversary argument）来思考算法为了确保正确性必须获取的“信息量”，从而确定任何基于比较的算法都无法逾越的性能底线。",
            "id": "3279201",
            "problem": "考虑一个算法，它只能通过成对比较来访问一个包含 $n$ 个元素的数组，每次查询都会询问一个元素是否小于另一个元素。假设所有元素都互不相同，并且来自一个严格全序集。该算法是自适应的：它可以根据先前比较的结果来选择接下来要比较的元素对。在这种仅比较模型中，我们将查询复杂度定义为保证对所有输入都得到正确结果所需的最坏情况下的成对比较次数。\n\n从比较决策树（CDT）的基本原理出发——其中每次比较产生一位信息，一个算法对应于一个二叉决策树，其叶节点代表与正确识别相一致的结果——并结合以下两个经过充分验证的事实：高度为 $h$ 的二叉树最多有 $2^{h}$ 个叶节点，以及仅通过比较在 $k$ 个元素中选出最小值至少需要 $k-1$ 次比较，请推导出识别数组中第二小元素所需的紧确的最坏情况下最小成对比较次数。你的答案必须是一个关于 $n$ 的单一闭式解析表达式。不需要进行取整。",
            "solution": "本题要求推导出在包含 $n$ 个不同元素的数组中，识别第二小元素所需的最坏情况下最小成对比较次数。\n\n### 推导过程\n\n推导过程分为两部分：首先，通过构建一个算法来建立一个上界；其次，证明一个任何基于比较的算法都必须遵守的、与之匹配的下界。\n\n#### 上界\n\n我们可以通过首先识别出最小元素 $S_1$ 来找到第二小元素（我们将其记作 $S_2$）。\n\n1.  **寻找最小值 ($S_1$)**：我们可以将寻找最小元素的过程建模为一场单败淘汰赛。这 $n$ 个元素是参赛者。我们将它们两两配对进行比较，胜者进入下一轮。这个过程持续进行，直到剩下唯一的总冠军。这个总冠军就是最小元素 $S_1$。在这样的锦标赛中，除了冠军之外的每个元素都必须恰好输掉一场比赛。由于每次比较产生一个失败者，因此确定 $S_1$ 总共需要进行 $n-1$ 次比较。\n\n2.  **确定第二小值 ($S_2$) 的候选者**：第二小元素 $S_2$ 必定在某次比较中输给了另一个元素。如果 $S_2$ 在与元素 $x$ 的比较中落败，那么必然有 $x = S_1$。如果 $x$ 是任何其他元素，我们就会得到关系 $S_1  x  S_2$，这意味着 $S_2$ 至少是第三小的元素，这与假设矛盾。因此，$S_2$ 必定是那些与 $S_1$ 直接比较并落败的元素之一。\n\n3.  **寻找第二小值 ($S_2$)**：设 $K$ 为在锦标赛期间直接输给 $S_1$ 的元素集合。第二小元素 $S_2$ 就是集合 $K$ 中的最小元素。$K$ 中元素的数量（我们记为 $|K|$）是 $S_1$ 在成为锦标赛冠军的路径上遇到并击败的对手数量。在一个平衡的锦标赛结构中，冠军会参与 $\\lceil \\log_2(n) \\rceil$ 次比较。因此，在最坏情况下（就 $K$ 的大小而言），$|K| = \\lceil \\log_2(n) \\rceil$。为了找到集合 $K$ 中的最小元素，我们还需要进行 $|K|-1$ 次额外的比较。\n\n4.  **总比较次数（上界）**：该算法的总比较次数是步骤1和步骤3中比较次数的总和：\n    $$ C_{\\text{upper}} = (n-1) + (|K|-1) $$\n    在该算法的最坏情况下， $|K| = \\lceil \\log_2(n) \\rceil$。\n    $$ C_{\\text{upper}} = (n-1) + (\\lceil \\log_2(n) \\rceil - 1) = n + \\lceil \\log_2(n) \\rceil - 2 $$\n    这就确定了所需比较次数的一个上界。\n\n#### 下界\n\n我们现在为*任何*能够找到第二小元素的基于比较的算法推导其最坏情况复杂度的下界。\n\n1.  **所需信息**：任何正确的算法都必须获取足够的信息来证明其输出的正确性。为了证明一个元素 $y$ 是 $S_2$，该算法必须已经确定：\n    a. 恰好只有一个元素 $S_1$ 小于 $y$。\n    b. 所有其他 $n-2$ 个元素都大于 $y$。\n\n2.  **计算必要的比较结果**：\n    - **寻找 $S_1$**：要确定一个元素 $S_1$ 是最小值，每个其他元素 $x$ 都必须被证明大于至少一个其他元素（即，必须至少输掉一次比较）。每次比较只有一个失败者，因此要确保 $n-1$ 个不同的元素都失败过，至少需要 $n-1$ 次比较。\n    - **寻找 $S_2$**：如前所述，$S_2$ 必定在直接输给 $S_1$ 的元素集合 $K$ 中。设 $|K| = k$。为了将 $S_2$ 确定为集合 $K$ 中的最小值，算法必须确定 $S_2$ 小于 $K$ 中的其他 $k-1$ 个元素。证明这一点至少需要 $K$ 中元素之间的 $k-1$ 次比较。\n\n3.  **结合所需条件**：让我们来计算总比较次数 $C$。\n    - 一次 $(x,y)$ 的比较，其中 $x$ 和 $y$ 都不是 $S_1$，会确定一个元素的失败。为了确保不在 $\\{S_1\\} \\cup K$ 中的 $n-1-k$ 个元素被确定为非最小值，必须发生至少 $n-1-k$ 次这样的比较，让它们成为失败者。\n    - $K$ 中的 $k$ 个元素必须输给 $S_1$。这需要 $k$ 次形如 $(S_1, y)$（其中 $y \\in K$）的比较。\n    - $K \\setminus \\{S_2\\}$ 中的 $k-1$ 个元素必须被证明大于 $S_2$。这至少需要 $K$ 中元素之间的 $k-1$ 次比较。\n\n    从这三种必要的事件中获得的信息是截然不同的。类型为 $(S_1, y)$ 的比较确认了 $y \\in K$。类型为 $(y_i, y_j)$（其中 $y_i, y_j \\in K$）的比较建立了 $K$ 内部的顺序，这是找到其最小值所必需的。这种顺序信息无法由涉及 $S_1$ 的比较提供。因此，我们可以将这些不同信息需求所需的最小比较次数相加，从而得到总比较次数的下界。\n    $$ C_{\\text{lower}} \\ge (n-1-k) + k + (k-1) = n + k - 2 $$\n    这个下界取决于 $k$，即直接输给最终最小值 $S_1$ 的元素数量。\n\n4.  **对 $k$ 取下界**：表达式 $n+k-2$ 为给定的 $k$ 提供了一个下界。为了获得一个通用的复杂度下界，我们必须确定无论算法的策略如何，对手可以强制产生的 $k$ 的最小可能值。\n    $k$ 的值对应于 $S_1$ 赢得的比较次数。在赢得 $k$ 次胜利后，一个元素最多可以被证明比其他 $2^k-1$ 个元素小（这种情况发生在该元素赢得一个大小为 $2^k$ 的完美平衡锦标赛时）。要被确认为 $n$ 个元素中的最小值，一个元素必须被证明比所有其他 $n-1$ 个元素都小。抽象地说，这 $n-1$ 个失败者的集合必须被划分给直接输给 $S_1$ 的 $k$ 个元素。这 $k$ 个直接失败者中的每一个都是一个由被击败元素组成的子树的“胜者”。一个元素若没有任何胜利，最多只能是一组 $2^0=1$ 个元素（其自身）的胜者。赢得一次胜利，它可以是 $2^1=2$ 个元素的胜者。赢得 $c$ 次胜利，它最多可以是 $2^c$ 个元素的胜者。胜者 $S_1$ 必须“征服”一个包含所有 $n$ 个元素的层级结构。直接对手的数量 $k$ 是其胜者被 $S_1$ 击败的子锦标赛的数量。为了覆盖 $n$ 个元素，我们必须有 $2^k \\ge n$。\n    这意味着 $k \\ge \\log_2(n)$。由于 $k$ 必须是整数，我们有：\n    $$ k \\ge \\lceil \\log_2(n) \\rceil $$\n    任何算法都可能被对手强制使其最终的胜者至少进行 $\\lceil \\log_2(n) \\rceil$ 场比赛。\n\n5.  **最终下界**：将 $k$ 的最小可能值代入我们的 $C$ 的下界表达式中：\n    $$ C_{\\text{lower}} \\ge n + \\lceil \\log_2(n) \\rceil - 2 $$\n\n#### 结论\n\n比较次数的上界是 $n + \\lceil \\log_2(n) \\rceil - 2$，并且任何算法的最坏情况下界也是 $n + \\lceil \\log_2(n) \\rceil - 2$。由于上界和下界相匹配，因此这就是紧确的最坏情况复杂度。",
            "answer": "$$\n\\boxed{n + \\lceil \\log_2(n) \\rceil - 2}\n$$"
        }
    ]
}