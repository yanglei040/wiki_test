{
    "hands_on_practices": [
        {
            "introduction": "在分析空间复杂度时，首要任务是区分算法自身所需的“辅助空间”与存储输入数据所需的空间。这是一个至关重要的区别，因为它决定了算法在处理大规模数据时的可行性。本练习  将通过一个经典的原地矩阵转置算法，引导你精确计算算法运行所需的额外内存，小到用于索引和临时存储的每一个比特，从而深刻理解 $O(\\log N)$ 级别的辅助空间与 $O(MN)$ 级别的输入空间之间的本质差异。",
            "id": "3272578",
            "problem": "考虑一个大小为 $M \\times N$（$M, N \\in \\mathbb{N}$，$M \\neq N$）的非方形矩阵，它以基于数组、行主序的方式存储在连续内存中。每个矩阵元素精确地占用 $w$ 位。给定一个原地转置算法，该算法不分配任何 $M \\times N$ 的辅助矩阵，而是通过将索引映射引起的置换分解为循环，并使用单个临时变量在移动期间保存一个矩阵元素来旋转每个循环，从而实现转置。\n\n假设有以下计算模型和约束：\n- 空间复杂度定义为在执行过程中的任何时刻所使用的辅助内存（即输入数组本身之外的任何内存）的最大位数，表示为 $M$、$N$ 和 $w$ 的函数。\n- 除了输入数组外，该算法仅使用常数个标量变量：\n  1. 一个临时变量，用于在循环旋转期间保存单个矩阵元素。\n  2. 常数个索引变量，用于在遍历循环时跟踪循环的起始元素、当前位置和下一个位置。\n- 每个索引变量必须能够寻址数组中的任何位置，即 $\\{0, 1, \\dots, MN - 1\\}$ 中的任何整数，并使用表示任何此类索引所需的最少位数以二进制形式存储。\n- 忽略固定的、与实现相关的开销（例如返回地址或固定大小的帧指针），并且在计算空间复杂度时不包括输入数组本身的 $MN \\cdot w$ 位。\n\n仅使用空间复杂度和整数二进制表示大小的基本定义，推导出该算法在任何时候使用的辅助位数的精确最坏情况数量，并以 $M$、$N$ 和 $w$ 的封闭形式表示。你的最终答案必须是单一的解析表达式。不要四舍五入。",
            "solution": "在尝试求解之前，对问题陈述进行验证。\n\n### 步骤 1：提取已知条件\n- **矩阵属性**：一个 $M \\times N$ 矩阵，其中 $M, N \\in \\mathbb{N}$ 且 $M \\neq N$。\n- **存储**：基于数组、行主序、连续内存。\n- **元素大小**：每个元素占用 $w$ 位。\n- **算法**：通过循环分解和旋转进行原地转置。不分配辅助的 $M \\times N$ 矩阵。\n- **辅助内存定义**：空间复杂度是所使用的辅助内存的最大位数，即输入数组本身的 $M N \\cdot w$ 位之外的任何内存。\n- **辅助内存组成部分**：\n    1. 一个用于单个矩阵元素的临时变量。\n    2. 常数个索引变量。\n- **索引变量属性**：\n    1. 角色：跟踪循环的起始元素、当前位置和下一个位置。\n    2. 范围：必须能表示 $\\{0, 1, \\dots, MN - 1\\}$ 中的任何整数。\n    3. 大小：使用其范围所需的最少位数进行存储。\n- **排除项**：固定的、与实现相关的开销（例如返回地址、帧指针）以及输入数组本身。\n- **目标**：推导出所使用的辅助位数的精确最坏情况数量，表示为 $M$、$N$ 和 $w$ 的封闭形式函数。\n\n### 步骤 2：使用提取的已知条件进行验证\n根据验证标准对问题进行分析。\n\n- **科学依据**：该问题在计算机科学领域，特别是算法分析领域，有充分的依据。空间复杂度、原地算法、矩阵转置、循环分解和整数的二进制表示等概念都是基础且公认的。\n- **适定性**：该问题是适定的。它清晰地定义了什么是辅助空间，并给出了计算其大小的充分约束。目标是基于给定参数找到一个唯一的解析表达式。短语“常数个索引变量”通过列举的角色（“循环的起始元素”、“当前”和“下一个位置”）加以明确，这意味着一个特定的、小的整数常量，对于此类算法通常为 3。这使得问题对于一个“精确”表达式是可解的。\n- **客观性**：语言精确、正式，没有任何主观或含糊的术语。\n\n该问题没有表现出科学上不健全、不完整、矛盾或含糊不清等任何缺陷。它提出了一个算法分析中的标准、正式问题。\n\n### 步骤 3：结论与行动\n该问题被判定为**有效**。将按如下方式推导解答。\n\n总辅助空间复杂度，记为 $S(M, N, w)$，是算法使用的所有辅助变量所需空间的总和。根据问题陈述，这部分内存由两个不同部分组成：用于保存一个矩阵元素的单个临时变量的空间，以及用于常数个索引变量的空间。\n\n设 $S_{temp}$ 为临时变量的空间，$S_{index}$ 为索引变量的总空间。总辅助空间为：\n$$ S(M, N, w) = S_{temp} + S_{index} $$\n\n我们现在将推导每个组成部分的大小。\n\n首先，我们确定 $S_{temp}$。问题陈述该算法使用“一个临时变量来保存单个矩阵元素”。又给定“每个矩阵元素精确地占用 $w$ 位”。因此，该临时变量所需的内存量恰好是 $w$ 位。\n$$ S_{temp} = w $$\n\n接下来，我们确定 $S_{index}$。这需要计算两个量：所使用的索引变量的数量，以及存储每个变量所需的位数。\n问题陈述该算法使用“常数个索引变量来跟踪循环的起始元素、当前位置和下一个位置”。一个标准的循环跟踪算法的实现至少需要三个这样的变量：\n1. 一个索引，用于存储当前循环的起始位置（“循环的起始元素”），这对于检测循环何时完成是必需的。\n2. 一个索引，用于跟踪其元素将被替换的“当前”位置。\n3. 一个索引，用于存储将要获取新元素的“下一个”位置。\n因此，索引变量的常数数量是 $3$。\n\n现在，我们必须确定每个索引变量的大小。问题规定“每个索引变量必须能够寻址数组中的任何位置，即 $\\{0, 1, \\dots, MN - 1\\}$ 中的任何整数”。矩阵中的元素总数为 $MN$。要表示范围 $[0, MN-1]$ 内的一个整数，我们需要能够表示 $MN$ 个不同的值。表示 $K$ 个不同值所需的最小位数 $b$ 由以 2 为底的 $K$ 的对数的向上取整函数给出。\n$$ b = \\lceil \\log_2(K) \\rceil $$\n在我们的例子中，$K = MN$。因此，单个索引变量所需的位数 $b_{idx}$ 是：\n$$ b_{idx} = \\lceil \\log_2(MN) \\rceil $$\n问题进一步明确，每个索引都“使用所需的最少位数以二进制形式存储”，这证实了此计算。\n\n索引变量的总空间 $S_{index}$ 是索引变量的数量（$3$）乘以每个变量的位数（$b_{idx}$）。\n$$ S_{index} = 3 \\cdot b_{idx} = 3 \\lceil \\log_2(MN) \\rceil $$\n\n最后，我们将临时变量的空间和索引变量的空间相加，以获得总的辅助空间复杂度。这些内存是同时使用的，因此任何时刻使用的最大空间是所有已分配辅助变量大小的总和。\n$$ S(M, N, w) = S_{temp} + S_{index} = w + 3 \\lceil \\log_2(MN) \\rceil $$\n此表达式表示该算法所使用的辅助位数的精确最坏情况数量，这符合问题陈述的定义。空间使用量不随输入数据的值波动，只随其维度变化，因此最坏情况、平均情况和最好情况下的空间复杂度都是相同的。",
            "answer": "$$\\boxed{w + 3 \\lceil \\log_2(MN) \\rceil}$$"
        },
        {
            "introduction": "在掌握了基本变量的辅助空间计算后，我们将更进一步，分析真实世界中动态数据结构的内存开销。程序并非仅由简单的变量构成，更多的是由数组、列表、堆等复杂结构组成。本练习  模拟了一个高性能拍卖引擎的场景，要求你分析基于动态数组实现的堆结构。你不仅要考虑存储的元素本身，还需将元数据、容量管理策略（例如容量翻倍）等实现细节纳入考量，从而精确推导出其空间占用的数学表达式。",
            "id": "3272546",
            "problem": "一个电子拍卖撮合引擎使用两个二叉堆（BH）来维护一个限价订单簿，一个堆用于买单，一个堆用于卖单。每个二叉堆都实现为一个连续的动态数组，用于内联存储订单记录。该动态数组具有以下调整大小的策略：它以 $16$ 个元素的初始容量开始，并且每当数组满时，其容量就会加倍。在任何时刻，容量都是2的幂，并且至少是堆中当前元素的数量。每个堆的动态数组元数据恰好由三个 $64$-位字段组成：一个指向底层缓冲区的指针、逻辑大小和容量，每个堆的元数据总共为 $24$ 字节。系统在具有字节寻址的随机存取存储器（RAM）上运行，所有内存使用量都应以字节为单位进行度量。\n\n存储在堆中的每个订单记录都是一个普通旧数据（POD）结构体，包含以下字段：\n- $64$-位订单标识符（$8$ 字节）。\n- $64$-位时间戳（$8$ 字节）。\n- $64$-位以整数报价单位表示的价格（$8$ 字节）。\n- $32$-位数量（$4$ 字节）。\n- $32$-位交易员标签（$4$ 字节）。\n\n假设没有每个元素的指针开销，没有需要考虑的外部碎片，也没有超出所描述的堆元数据的分配器簿记。假设在给定快照中，买单堆中恰好有 $N$ 个买单，卖单堆中恰好有 $M$ 个卖单。\n\n仅使用基于数组的堆的空间复杂度的基本定义以及上述实现细节，推导出一个单一的封闭形式解析表达式，用于表示存储两个堆所使用的总内存（以字节为单位），作为 $N$ 和 $M$ 的函数。请以字节为单位表示您的最终答案。不要提供不等式；请提供精确的表达式。不需要四舍五入。",
            "solution": "该问题要求推导一个封闭形式的解析表达式，用于表示两个二叉堆（一个用于买单，一个用于卖单）所消耗的总内存，作为它们所含订单数量（分别表示为 $N$ 和 $M$）的函数。推导过程将首先确定单个订单记录的内存占用，然后确定单个堆的内存使用情况，最后将两个堆的内存使用量相加。\n\n首先，我们确定单个订单记录的大小。问题指明每个记录是一个由五个字段组成的普通旧数据（POD）结构体。一个记录的总大小，我们表示为 $S_{rec}$，是其组成字段大小的总和。\n这些字段是：\n- $64$-位订单标识符：$64 \\text{ bits} / 8 \\frac{\\text{bits}}{\\text{byte}} = 8$ 字节\n- $64$-位时间戳：$8$ 字节\n- $64$-位价格：$8$ 字节\n- $32$-位数量：$32 \\text{ bits} / 8 \\frac{\\text{bits}}{\\text{byte}} = 4$ 字节\n- $32$-位交易员标签：$4$ 字节\n\n将这些大小相加，得到单个订单记录的总大小：\n$$S_{rec} = 8 + 8 + 8 + 4 + 4 = 32 \\text{ 字节}$$\n问题说明假设没有填充，这与这些数据类型在 $64$-位架构上的标准对齐方式一致，因此总大小为 $32$ 字节。\n\n接下来，我们分析单个堆结构的内存使用情况。一个堆的总内存是其元数据所用内存与为其底层动态数组缓冲区分配的内存之和。\n问题指明每个堆的元数据由三个 $64$-位字段组成，总共 $3 \\times 8 = 24$ 字节。我们将这个固定的元数据大小表示为 $S_{meta}$。\n$$S_{meta} = 24 \\text{ 字节}$$\n\n动态数组缓冲区的大小取决于其容量，而不是其逻辑大小（当前持有的元素数量）。容量由一组特定的规则决定：\n1.  初始容量为 $16$ 个元素。\n2.  容量始终是2的幂。\n3.  容量始终至少是堆中元素的数量。\n4.  当数组满时，其容量加倍。\n\n设 $k$ 为给定堆中的元素数量。我们必须找到一个满足所有这些条件的容量表达式 $C(k)$。问题要求一个精确的表达式，这意味着容量是满足所有约束的最小可能值，这是对此类数据结构进行空间复杂度分析时的标准假设。\n容量必须是2的幂，即 $C(k) = 2^p$，其中 $p$ 为某个整数。\n容量必须至少为 $k$，因此 $C(k) \\ge k$。\n容量还必须至少为初始容量 $16$，因此 $C(k) \\ge 16$。\n结合这些条件，容量必须是大于或等于 $k$ 和 $16$ 的最小的2的幂。这可以表示为找到大于或等于 $\\max(k, 16)$ 的最小的2的幂。\n\n这可以数学地表述。对于任何正整数 $x$，大于或等于 $x$ 的最小的2的幂由表达式 $2^{\\lceil \\log_2(x) \\rceil}$ 给出。这个公式适用于我们的容量函数。我们必须处理对数的参数为零的情况。让我们分析当 $k \\ge 0$ 时 $\\max(k, 16)$ 的行为：\n- 如果 $k=0$，则 $\\max(0, 16) = 16$。\n- 如果 $1 \\le k \\le 16$，则 $\\max(k, 16) = 16$。\n- 如果 $k  16$，则 $\\max(k, 16) = k$。\n对数的参数 $\\max(k, 16)$ 始终至少为 $16$，因此它总是正数。因此，容量函数 $C(k)$ 是：\n$$C(k) = 2^{\\lceil \\log_2(\\max(k, 16)) \\rceil}$$\n这个单一表达式正确地捕捉了任意元素数量 $k \\ge 0$ 时的容量。\n\n为缓冲区分配的内存 $S_{buffer}(k)$ 是容量乘以每个元素的大小：\n$$S_{buffer}(k) = C(k) \\times S_{rec} = 32 \\times 2^{\\lceil \\log_2(\\max(k, 16)) \\rceil}$$\n\n包含 $k$ 个元素的单个堆的总内存 $M_{heap}(k)$ 是元数据和缓冲区大小的总和：\n$$M_{heap}(k) = S_{meta} + S_{buffer}(k) = 24 + 32 \\times 2^{\\lceil \\log_2(\\max(k, 16)) \\rceil}$$\n\n最后，我们计算买单堆（有 $N$ 个订单）和卖单堆（有 $M$ 个订单）的总内存 $M_{total}$。这是每个堆所用内存的总和。\n$$M_{total}(N, M) = M_{heap}(N) + M_{heap}(M)$$\n$$M_{total}(N, M) = \\left( 24 + 32 \\times 2^{\\lceil \\log_2(\\max(N, 16)) \\rceil} \\right) + \\left( 24 + 32 \\times 2^{\\lceil \\log_2(\\max(M, 16)) \\rceil} \\right)$$\n合并各项，我们得到最终的封闭形式解析表达式：\n$$M_{total}(N, M) = 48 + 32 \\left( 2^{\\lceil \\log_2(\\max(N, 16)) \\rceil} + 2^{\\lceil \\log_2(\\max(M, 16)) \\rceil} \\right)$$\n该表达式表示了作为 $N$ 和 $M$ 的函数的精确总内存（以字节为单位），符合问题的所有规范。",
            "answer": "$$\\boxed{48 + 32 \\left( 2^{\\lceil \\log_2(\\max(N, 16)) \\rceil} + 2^{\\lceil \\log_2(\\max(M, 16)) \\rceil} \\right)}$$"
        },
        {
            "introduction": "学会分析空间复杂度之后，下一步便是主动进行空间优化。在许多内存受限的场景下，例如嵌入式系统或大规模数据处理，优化内存使用是算法设计的核心挑战。本练习  提出了一个常见的设计问题：在有限的内存预算内统计数据流中的唯一元素个数。你将通过设计并实现一个基于“位图”的巧妙解决方案，体验如何利用位操作将内存消耗降低一个数量级，将理论知识转化为高效实用的代码。",
            "id": "3272560",
            "problem": "给定一个从已知的固定范围 $[1,K]$（其中 $K$ 是一个正整数）中抽取的整数数据流。任务是设计并实现一个算法，用于计算数据流中出现的不同整数的数量，并且在随机存取机 (RAM) 模型（Random Access Machine (RAM) 定义为一种计算模型，其中内存是单元的线性数组，对字的基本操作耗时为常数）的意义下，最多使用 $K/8 + O(1)$ 字节的内存。你的算法必须从第一性原理出发，从空间复杂度、位和字节的基本定义以及 RAM 模型的约束开始推导。你必须证明内存使用界限和计数方法的正确性。\n\n需使用的基本原理：\n- 空间复杂度定义为函数 $S(n)$，它将输入大小 $n$ 映射到算法使用的内存单元数量，不包括常数时间寄存器。\n- 位是可取值为 $0$ 或 $1$ 的基本信息单位；一个字节正好是 $8$ 位。\n- 在随机存取机 (RAM) 模型中，读取和写入一个字是常数时间操作，内存使用量按分配的字数（或在使用子字封装时，按分配的位数或字节数）计算。\n\n算法要求：\n- 假设数据流中的每个元素都保证是 $[1,K]$ 内的整数，但数据流可能包含重复项，且流的长度是任意且事先未知的。\n- 设计一种使用位数组来跟踪存在性的方法，其中每个位精确对应 $[1,K]$ 中的一个值。\n- 为表示存在性结构而分配的总辅助内存必须恰好是 $\\lceil K/8 \\rceil$ 字节，外加 $O(1)$ 个额外变量。你必须解释为什么这满足 $K/8 + O(1)$ 字节的要求。\n- 处理完数据流后，必须通过对存在性结构中设置为 $1$ 的位数求和来计算不同整数的数量。\n- 必须明确指定并证明从值 $x \\in [1,K]$ 到其比特位的映射是合理的。\n\n程序要求：\n- 在一个无需用户输入的、完整的单一程序中实现该算法。\n- 使用紧凑的字节级结构来存储位，其中为存在性结构分配的字节数为 $\\lceil K/8 \\rceil$。\n- 在计算设置为 $1$ 的位数时，使用一种在字节粒度上操作并对每个字节中的“1”的个数求和的方法。\n\n测试套件：\n你的程序必须嵌入并处理以下测试用例。对于每个测试用lest，输入是一对 $(K,\\text{stream})$，其中 $K$ 是已知的最大值，$\\text{stream}$ 是要处理的序列。对于每个案例，输出观察到的不同整数的数量。\n1. $K=20$，$\\text{stream}=[1,3,3,5,20,20,2,2,2]$。\n2. $K=1$，$\\text{stream}=[1,1,1]$。\n3. $K=10$，$\\text{stream}=[10,9,8,1,2,2]$。\n4. $K=16$，$\\text{stream}=[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,1,2,3,4]$。\n5. $K=32$，$\\text{stream}=[]$ (空流)。\n6. $K=1000$，$\\text{stream}=[1,1000,500,500,250,750,250,999,2,2,3,4,4,10]$。\n\n最终输出格式：\n你的程序应生成一行输出，其中包含所有测试用例的结果，格式为方括号括起来的逗号分隔列表，顺序与上述测试用例相同。例如，输出必须看起来像 $[\\text{result}_1,\\text{result}_2,\\ldots,\\text{result}_6]$，其中每个 $\\text{result}_i$ 是一个整数。",
            "solution": "对用户提供的问题陈述进行严格验证。\n\n### 步骤1：提取已知条件\n- **输入：** 一个整数数据流。\n- **数据域：** 整数从已知的固定范围 $[1,K]$ 中抽取，其中 $K$ 是一个正整数。\n- **任务：** 计算数据流中出现的不同整数的数量。\n- **内存约束：** 算法必须最多使用 $K/8 + O(1)$ 字节的内存。\n- **计算模型：** 随机存取机 (RAM)，其中内存是一个线性数组，基本操作耗时为常数。\n- **定义：**\n    - 空间复杂度 $S(n)$：对于大小为 $n$ 的输入，算法使用的内存单元数量，不包括常数时间寄存器。\n    - $1$ 字节正好是 $8$ 位。\n- **算法要求：**\n    1. 必须使用一个位数组来跟踪每个整数的存在性。\n    2. 每个位必须精确对应 $[1,K]$ 中的一个值。\n    3. 用于存在性结构的总辅助内存必须恰好是 $\\lceil K/8 \\rceil$ 字节。\n    4. 总内存使用量必须是 $\\lceil K/8 \\rceil$ 字节外加 $O(1)$ 个额外变量。\n    5. 在处理完数据流后，通过对设置为 $1$ 的位数求和来计算最终计数。\n    6. 必须明确定义从整数 $x \\in [1,K]$ 到其比特位的映射。\n- **程序要求：**\n    1. 在一个独立的、自包含的程序中实现。\n    2. 使用大小为 $\\lceil K/8 \\rceil$ 字节的紧凑字节级结构。\n    3. 在字节粒度上计算置位（set bits）。\n- **测试套件：** 提供了一组六个测试用例，每个用例都附有参数 $(K, \\text{stream})$。\n\n### 步骤2：使用提取的已知条件进行验证\n- **科学基础：** 该问题牢固地定位于计算机科学领域，特别是在数据结构和算法方面。位向量（或位图）、空间复杂度、RAM 模型和位运算等概念都是标准且成熟的原理。该问题在科学和数学上是合理的。\n- **适定性：** 该问题是适定的。它指定了输入、输出以及对解决方案资源（内存）的清晰、可验证的约束。对于任何给定的输入流，都存在一个唯一的整数计数。\n- **客观性：** 问题陈述是客观的，使用了精确、无歧义的技术语言。没有主观或基于意见的成分。\n- **完整性和一致性：** 问题是自包含的。内存约束既指定为“最多 $K/8 + O(1)$ 字节”，也指定为“恰好 $\\lceil K/8 \\rceil$ 字节，外加 $O(1)$ 个额外变量。” 这两者是一致的。因为对于任何正整数 $K$，向上取整函数 $\\lceil K/8 \\rceil$ 满足不等式 $K/8 \\le \\lceil K/8 \\rceil \\le K/8 + 1$，所以 $\\lceil K/8 \\rceil$ 的确等于 $K/8 + c$，其中常数 $c \\in [0, 1)$。这是 $K/8 + O(1)$ 的一种特定形式。因此，这个设定是一致且完整的。\n- **现实性和可行性：** 该问题在计算上是可行的，并且植根于内存管理的实践现实中，其中位级封装是一种常见的优化技术。\n- **结构性和非平凡性：** 问题结构良好且非平凡。它要求正确实现位操作，并对内存使用进行形式化证明，这考验了对基础知识的理解。这是一个展示空间高效数据结构的典型问题。\n\n### 步骤3：结论与行动\n问题陈述是**有效的**。这是一个定义明确、标准的算法设计问题，它一致、完整，并基于成熟的计算机科学原理。将提供一个解决方案。\n\n### 基于第一性原理的解决方案推导\n\n目标是计算一个数据流中不同整数的数量，其中每个整数 $x$ 都保证在范围 $[1,K]$ 内。主要约束是内存使用量，不得超过 $K/8 + O(1)$ 字节。\n\n**1. 基本原理：存在性跟踪**\n\n要计算不同的元素，我们必须记录哪些元素已经被看到。一种自然的方式是为范围 $[1,K]$ 内的每个可能整数维护一组布尔标志。我们将这组标志表示为 $S$。对于每个整数 $i \\in [1,K]$，我们可以有一个标志 $s_i$，如果 $i$ 已在流中出现，则 $s_i$ 为真，否则为假。最初，所有标志都为假。当一个整数 $x$ 从流中到达时，我们将其对应的标志 $s_x$ 设置为真。那么，在流被完全处理后，不同元素的数量就是为真的标志的总数。\n\n**2. 数据结构设计与空间复杂度分析**\n\n使用标准布尔数组的直接实现需要 $K$ 个布尔变量。在许多编程语言中，一个布尔变量至少占用一个完整的字节（$8$ 位）内存。这将导致总内存使用量至少为 $K$ 字节，这严重违反了指定的 $K/8 + O(1)$ 字节的内存约束。\n\n问题的核心在于以最高的空间效率实现这 $K$ 个标志。单个位是能够表示二元状态（真/假，或 $1$/$0$）的最小信息单位。因此，对于我们的 $K$ 个标志，最节省空间的表示是一个包含 $K$ 个位的数组，通常称为位向量或位图。\n\n根据指定的 RAM 模型，内存是按字节寻址的。要存储 $K$ 个位，我们必须分配一个连续的字节块。由于每个字节包含 $8$ 位，所需的总字节数是能够容纳 $K$ 个位的最小整数字节数。这个数量恰好是 $\\lceil K/8 \\rceil$。\n\n让我们正式分析这个内存使用量。位向量的内存为 $M_{vec} = \\lceil K/8 \\rceil$ 字节。我们知道对于任何实数 $z$，$\\lceil z \\rceil  z+1$。应用这一点，我们有：\n$$M_{vec}  \\frac{K}{8} + 1$$\n$1$ 这一项是一个常数，即 $O(1)$。因此，位向量的内存使用量是 $M_{vec} \\in O(K/8)$。更具体地说，它满足了 $K/8 + O(1)$ 字节的界限要求。该算法还需要少量、恒定数量的辅助变量用于循环索引和处理当前流元素。这部分内存相对于 $K$ 和流长度是常数，并被包含在总空间复杂度的 $O(1)$ 项中，使得总空间使用量为 $\\lceil K/8 \\rceil + O(1)$ 字节。\n\n**3. 整数到位映射**\n\n我们必须为每个整数 $x \\in [1,K]$ 定义一个到我们的位向量中唯一位的确定性、一对一的映射。位向量可以看作是一个0索引的、$K$ 位的序列。一个自然的映射是将整数 $x$ 与第 $(x-1)$ 位关联。令 $i_x = x-1$ 为整数 $x$ 的0索引位位置。\n\n要访问这个位，我们必须确定它在我们的字节数组中的位置。设字节数组为 `bit_vector`。\n- 包含所需位的字节索引由整数除法给出：$j = \\lfloor i_x / 8 \\rfloor = (x-1) \\text{ div } 8$。\n- 该位在该字节内的位置（从最低有效位 $0$ 到最高有效位 $7$）由余数给出：$p = i_x \\pmod 8 = (x-1) \\pmod 8$。\n\n**4. 算法步骤**\n\n**初始化：**\n1.  计算所需的字节数：$N_{bytes} = \\lceil K/8 \\rceil$。\n2.  分配一个大小为 $N_{bytes}$ 的字节数组 `bit_vector`，并将其所有元素初始化为 $0$。这确保了所有 $K$ 个逻辑位初始都为 $0$，表示还没有看到任何整数。\n\n**流处理：**\n对于输入流中的每个整数 $x$：\n1.  计算位的0索引位置：$i_x = x - 1$。\n2.  确定字节索引：$j = i_x // 8$。\n3.  确定字节内的位位置：$p = i_x \\% 8$。\n4.  为了将位设置为 $1$，我们使用按位或运算。通过将 $1$ 左移 $p$ 位来创建一个掩码：$mask = 1 \\ll p$。\n5.  更新向量中的字节：`bit_vector[j] |= mask`。此操作是幂等的，意味着一旦位被设置为 $1$，对同一个 $x$ 的重复操作不会改变该位的状态。\n\n**最终计数：**\n在整个流处理完毕后：\n1.  初始化一个总计数：`distinct_count = 0`。\n2.  从索引 $0$ 到 $N_{bytes}-1$ 遍历 `bit_vector` 中的每个字节 `b`。\n3.  对于每个字节，计算其置位计数（population count，即设置为 $1$ 的位数）。这可以使用内置函数或位操作技巧高效完成。\n4.  将这个每字节的计数加到 `distinct_count` 上。\n5.  `distinct_count` 的最终值就是流中观察到的不同整数的总数。\n\n此算法正确地计算了不同元素的数量，同时严格遵守了问题陈述中规定的内存约束和原则。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the distinct integer counting problem for a suite of test cases.\n    \"\"\"\n\n    # Define the test cases as specified in the problem statement.\n    # Each case is a tuple (K, stream).\n    test_cases = [\n        (20, [1, 3, 3, 5, 20, 20, 2, 2, 2]),\n        (1, [1, 1, 1]),\n        (10, [10, 9, 8, 1, 2, 2]),\n        (16, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 1, 2, 3, 4]),\n        (32, []),\n        (1000, [1, 1000, 500, 500, 250, 750, 250, 999, 2, 2, 3, 4, 4, 10]),\n    ]\n\n    results = []\n\n    for K, stream in test_cases:\n        # 1. Initialization\n        # Calculate the number of bytes needed to store K bits.\n        # This is equivalent to ceil(K / 8).\n        num_bytes = math.ceil(K / 8)\n\n        # Allocate the bit vector as an array of 8-bit unsigned integers (bytes),\n        # initialized to all zeros.\n        bit_vector = np.zeros(num_bytes, dtype=np.uint8)\n\n        # 2. Stream Processing\n        for x in stream:\n            # The problem guarantees x is in [1, K].\n            # Map the integer x to a 0-indexed bit position.\n            bit_index = x - 1\n\n            # Determine the byte in the vector that contains this bit.\n            byte_index = bit_index // 8\n\n            # Determine the position of the bit within the byte (0-7).\n            bit_in_byte = bit_index % 8\n\n            # Create a mask to set the specific bit.\n            # (1  bit_in_byte) creates an integer with only the target bit set.\n            mask = np.uint8(1  bit_in_byte)\n\n            # Use bitwise OR to set the bit, marking the integer as seen.\n            # This operation is idempotent.\n            bit_vector[byte_index] |= mask\n        \n        # 3. Final Counting\n        distinct_count = 0\n        # Iterate through each byte of the bit vector.\n        for byte_val in bit_vector:\n            # Count the number of set bits (population count) in the current byte.\n            # int.bit_count() is a highly efficient method available in Python 3.10+.\n            distinct_count += int(byte_val).bit_count()\n        \n        results.append(distinct_count)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the main function.\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}