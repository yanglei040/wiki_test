{
    "hands_on_practices": [
        {
            "introduction": "This first practice serves as a foundational exercise in frequency analysis. By focusing on a specific subset of characters (vowels) within a string, you will implement the core mechanics of counting: iterating through data, using a fixed-size map to store frequencies, and handling case-insensitivity. This problem also introduces a common real-world requirement of applying a tie-breaking rule, forcing a more detailed analysis of the collected frequency data .",
            "id": "3236059",
            "problem": "You are given a finite character string $S$ over the standard American Standard Code for Information Interchange (ASCII) character set. Define the vowel set $V = \\{a,e,i,o,u\\}$. Consider the lowercase normalization function $\\mathrm{lower}(\\cdot)$ that maps uppercase letters to their lowercase counterparts and leaves other characters unchanged. For each vowel $v \\in V$, define the frequency function\n$$\nf_S(v) = \\left|\\{\\, i \\in \\{0,1,\\dots,|S|-1\\} \\mid \\mathrm{lower}(S[i]) = v \\,\\}\\right|.\n$$\nAlso define, for any vowel $v$ with $f_S(v) > 0$, the first-occurrence index\n$$\n\\iota_S(v) = \\min\\{\\, i \\in \\{0,1,\\dots,|S|-1\\} \\mid \\mathrm{lower}(S[i]) = v \\,\\}.\n$$\nYour task is to determine, for each provided test string $S$, a vowel $c \\in V$ that maximizes $f_S(c)$. If there are multiple vowels tying for the maximum frequency, break ties by selecting the vowel with the smallest $\\iota_S(\\cdot)$ (that is, the earliest occurrence in $S$ when scanned from left to right). If $f_S(v) = 0$ for all $v \\in V$ (that is, $S$ contains no vowels from $V$), then there is no such $c$.\n\nTo make the output numeric and unambiguous, define the function $\\mathrm{code}(x)$ to be the Unicode code point of the character $x$, which for vowels in $V$ coincides with its ASCII code. For each input $S$, your program must output either:\n- a two-integer list $[\\mathrm{code}(c), f_S(c)]$ if there exists at least one vowel in $S$, or\n- the two-integer list $[-1, 0]$ if $S$ contains no vowels from $V$.\n\nDesign an algorithm starting from the fundamental definitions of counting and sequence scanning to compute these values efficiently. You should analyze and justify the time and space complexity in terms of $|S|$.\n\nInput is not read from standard input. Instead, your program must internally use the following test suite of $S$ values, in this exact order:\n- $S =$ \"Data Structures and Algorithms\"\n- $S =$ \"eagle arena\"\n- $S =$ \"rhythms\"\n- $S =$ \"OOO!!!aaa111\"\n- $S =$ \"\" (the empty string)\n\nOutput specification:\n- Your program should produce a single line of output containing the results for all the above test cases aggregated into a single list. For $k$ test cases (here $k = 5$), output a list of length $k$ where each element is the two-integer list for the corresponding test case, in order. The printed line must be exactly a bracketed, comma-separated list of the $k$ results with no spaces, for example a list of the form [[xA,yA],[xB,yB],...], where each $x\\cdot$ and $y\\cdot$ is an integer as defined above.\n\nAssumptions and constraints:\n- Only the vowels in $V = \\{a,e,i,o,u\\}$ count as vowels for this problem; the letter $y$ is not considered a vowel.\n- The analysis is case-insensitive due to $\\mathrm{lower}(\\cdot)$.\n- All characters not in $V$ after normalization are ignored for counting.\n- The algorithm should be designed to run in time $\\mathcal{O}(|S|)$ with additional space $\\mathcal{O}(1)$ relative to $|S|$ (treating the size of $V$ as a constant).",
            "solution": "The problem statement has been rigorously evaluated and is determined to be valid. It is scientifically grounded in the domain of computer science and algorithm design, mathematically well-posed with clear definitions and constraints, and presented objectively. All necessary information is provided, the constraints are consistent and feasible, and the objectives are unambiguous, leading to a unique, verifiable solution for any given input string.\n\nThe task is to design an algorithm to find a specific vowel in a string $S$. The target vowel, $c$, must have the highest frequency of occurrence. In case of a tie in frequency, the vowel that appears earliest in the string (i.e., has the minimum first-occurrence index) is chosen. The algorithm must operate with a time complexity of $\\mathcal{O}(|S|)$ and additional space complexity of $\\mathcal{O}(1)$, where $|S|$ is the length of the string.\n\nOur approach is based on a two-phase process that adheres to these constraints: a data collection phase followed by an analysis phase. This design ensures that we process the input string in a single pass while keeping memory usage constant, independent of the string's length.\n\n**Phase 1: Data Collection via a Single Pass**\n\nThe core of an efficient solution is to gather all required information in a single scan of the input string $S$. The problem requires two pieces of data for each vowel $v$ in the predefined set $V = \\{a, e, i, o, u\\}$: its frequency, $f_S(v)$, and its first-occurrence index, $\\iota_S(v)$.\n\nTo store this information, we will use a fixed-size data structure, specifically a hash map (or dictionary), which we can call $D$. The keys of this map will be the vowels from the set $V$. The value associated with each vowel key $v$ will be a pair of numbers, $(count, index)$, representing the frequency and first-occurrence index, respectively. The size of this map is $|V| = 5$, which is a constant, thus satisfying the $\\mathcal{O}(1)$ space complexity requirement.\n\nThe algorithm for this phase is as follows:\n$1$. Initialize the map $D$. For each vowel $v \\in V$, create an entry $D[v]$ and initialize its associated pair to $(0, -1)$. The frequency count starts at $0$, and the index is set to a sentinel value of $-1$ to indicate that the vowel has not yet been encountered.\n$2$. Iterate through the string $S$ from the first character to the last, keeping track of the current index $i$, where $i$ ranges from $0$ to $|S|-1$.\n$3$. For each character $S[i]$ at index $i$:\n    a. Apply the lowercase normalization function: $c' = \\mathrm{lower}(S[i])$.\n    b. Check if $c'$ is a member of the vowel set $V$.\n    c. If $c'$ is a vowel, update its entry in the map $D$. Let $c' = v$.\n        i. Increment the frequency count: $D[v].count \\leftarrow D[v].count + 1$.\n        ii. If the first-occurrence index is still the sentinel value (i.e., $D[v].index = -1$), update it to the current index $i$: $D[v].index \\leftarrow i$. Since we are scanning from left to right, the first time we encounter a vowel guarantees that we are recording its minimum index.\n\nAfter this single pass is complete, the map $D$ will contain the final frequency $f_S(v)$ and first-occurrence index $\\iota_S(v)$ for every vowel $v \\in V$.\n\n**Phase 2: Analysis of Collected Data**\n\nWith the data collection complete, the next phase is to analyze the contents of the map $D$ to identify the vowel $c$ that satisfies the problem's criteria.\n\n$1$. Initialize variables to track the winning vowel and its properties. Let $c_{best}$ be the best vowel found so far, $f_{max}$ be the maximum frequency, and $\\iota_{min}$ be the minimum index for tie-breaking. Initialize $f_{max} = 0$ and $c_{best} = \\mathrm{null}$.\n\n$2$. Iterate through the vowels $v \\in V$ (e.g., in their alphabetical order: 'a', 'e', 'i', 'o', 'u'). For each vowel $v$, retrieve its statistics $(f_v, \\iota_v)$ from the map $D$, where $f_v = D[v].count$ and $\\iota_v = D[v].index$.\n\n$3$. We apply the selection logic. For each vowel $v$:\n    a. If its frequency $f_v$ is greater than the current maximum frequency $f_{max}$, then $v$ becomes the new best candidate. Update $f_{max} \\leftarrow f_v$, $\\iota_{min} \\leftarrow \\iota_v$, and $c_{best} \\leftarrow v$.\n    b. If its frequency $f_v$ is equal to the current maximum frequency $f_{max}$, we must apply the tie-breaking rule. The tie is broken by the smaller first-occurrence index. If $\\iota_v < \\iota_{min}$, then $v$ wins the tie and becomes the new best candidate. Update $\\iota_{min} \\leftarrow \\iota_v$ and $c_{best} \\leftarrow v$.\n\n$4$. After iterating through all $5$ vowels, the analysis is complete.\n    a. If $f_{max}$ is still $0$ (its initial value), it means no vowels were found in the string $S$. In this case, the specified output is the list $[-1, 0]$.\n    b. Otherwise, the winning vowel is $c_{best}$ and its frequency is $f_{max}$. The output is the list $[\\mathrm{code}(c_{best}), f_{max}]$.\n\n**Complexity Analysis**\n\n- **Time Complexity**: The first phase involves a single iteration over the string $S$, where each character operation (lowercase, hash map lookup, and update) takes constant time. This phase has a time complexity of $\\mathcal{O}(|S|)$. The second phase involves a single iteration over the fixed-size vowel set $V$. This takes $\\mathcal{O}(|V|)$ time, which is $\\mathcal{O}(1)$ since $|V| = 5$. Therefore, the total time complexity is dominated by the first phase, resulting in $\\mathcal{O}(|S|)$, which meets the problem requirement.\n\n- **Space Complexity**: The algorithm uses a map $D$ to store statistics for the $|V|$ vowels. As $|V|$ is a constant ($5$), the space required for this map is constant. No other data structures dependent on the size of $S$ are used. Thus, the additional space complexity is $\\mathcal{O}(1)$, also meeting the problem requirement.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the vowel frequency analysis problem for a predefined suite of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        \"Data Structures and Algorithms\",\n        \"eagle arena\",\n        \"rhythms\",\n        \"OOO!!!aaa111\",\n        \"\"\n    ]\n    \n    # Define the vowel set as per the problem.\n    VOWELS = {'a', 'e', 'i', 'o', 'u'}\n    \n    results = []\n\n    for s in test_cases:\n        # Phase 1: Data Collection\n        # The data structure stores frequency and first-occurrence index for each vowel.\n        # Format: {vowel: {'freq': count, 'first_idx': index}}\n        stats = {v: {'freq': 0, 'first_idx': -1} for v in VOWELS}\n        \n        for i, char in enumerate(s):\n            # Normalize character to lowercase for case-insensitive comparison.\n            norm_char = char.lower()\n            \n            if norm_char in VOWELS:\n                # Increment frequency for the vowel.\n                stats[norm_char]['freq'] += 1\n                \n                # If this is the first time seeing the vowel, record its index.\n                if stats[norm_char]['first_idx'] == -1:\n                    stats[norm_char]['first_idx'] = i\n\n        # Phase 2: Analysis of Collected Data\n        best_vowel = None\n        max_freq = 0\n        # Initialize min_first_idx to a value larger than any possible index.\n        min_first_idx = float('inf')\n        \n        # Iterate through the vowels in a deterministic order (alphabetical).\n        # This helps in predictable behavior, though the logic handles any order.\n        for vowel in sorted(VOWELS):\n            v_freq = stats[vowel]['freq']\n            v_idx = stats[vowel]['first_idx']\n            \n            # Skip vowels that were not found in the string.\n            if v_freq == 0:\n                continue\n            \n            # Check for a new maximum frequency.\n            if v_freq > max_freq:\n                max_freq = v_freq\n                min_first_idx = v_idx\n                best_vowel = vowel\n            # If frequencies are tied, break ties with the first-occurrence index.\n            elif v_freq == max_freq:\n                if v_idx  min_first_idx:\n                    min_first_idx = v_idx\n                    best_vowel = vowel\n        \n        # Format the result based on whether a vowel was found.\n        if best_vowel is None:\n            # Case where the string has no vowels.\n            results.append([-1, 0])\n        else:\n            # Case where a best vowel was determined.\n            # ord() gives the Unicode code point (ASCII for these characters).\n            results.append([ord(best_vowel), max_freq])\n\n    # Final print statement in the exact required format.\n    # custom string formatting to avoid spaces inside the lists\n    formatted_results = [f\"[{x},{y}]\" for x, y in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Moving beyond simply finding the most common item, this exercise challenges you to use frequency counts to identify an element with a unique property. The \"anti-majority\" element is defined by a specific frequency signature relative to all other elements in the sequence. This problem encourages you to think of frequency analysis not just as a tool for finding modes, but as a method for creating a complete statistical profile of a dataset that can be queried for complex patterns .",
            "id": "3236040",
            "problem": "You are given a finite sequence of integers $A = \\langle a_1, a_2, \\ldots, a_n \\rangle$. For an integer $x$, define the frequency function $f(x)$ on $A$ as the cardinality of the set $\\{ i \\mid a_i = x \\}$, that is, $f(x)$ counts how many times $x$ appears in $A$. An element $m$ is called an anti-majority element of $A$ if it satisfies $f(m) = 1$ and for every $y \\neq m$ with $y$ appearing in $A$, $f(y) \\geq 2$. The sequence may or may not possess an anti-majority element. Your task is to design an algorithm that, given $A$, returns $m$ if there exists exactly one element $m$ with $f(m) = 1$ and all other appearing elements have frequencies at least $2$, and returns $-1$ otherwise.\n\nThe fundamental base for this problem is the definition of a frequency function over a multiset and the canonical data structure operations for counting frequencies in an associative map (also called a dictionary). Your solution should start from these definitions and reason about how to compute, validate, and return the anti-majority element using frequency count analysis.\n\nFormally, the required behavior of your program for a given $A$ is:\n- If there exists exactly one element $m$ such that $f(m) = 1$ and for all $y \\in \\{ a_1, \\ldots, a_n \\}$ with $y \\neq m$ we have $f(y) \\geq 2$, output $m$.\n- Otherwise, output $-1$.\n\nNote that when $n = 1$, the sole element $a_1$ vacuously satisfies the condition $f(a_1) = 1$ and for all other elements (of which there are none) the frequency condition holds; therefore, $a_1$ is the anti-majority element.\n\nYour program must implement this logic and apply it to the following test suite of sequences:\n- Test $1$: $A = \\langle 4, 7, 7, 4, 5, 4, 4 \\rangle$.\n- Test $2$: $A = \\langle -1, -1, 0, 0, 0, 2 \\rangle$.\n- Test $3$: $A = \\langle 9, 9, 9, 8, 8 \\rangle$.\n- Test $4$: $A = \\langle 1, 2, 2, 3 \\rangle$.\n- Test $5$: $A = \\langle 42 \\rangle$.\n- Test $6$: $A = \\langle 5, 5, 7, 8, 8 \\rangle$.\n- Test $7$: $A = \\langle 1000000, 1000000, -1000000, -1000000, 123456789 \\rangle$.\n\nFor each test, your program must compute the corresponding result as an integer as specified above. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, $\\texttt{[result1,result2,\\ldots]}$.\n\nNo physical units or angles are involved. All outputs are integers.\n\nYour program must be a complete, runnable program that performs the computations for the given test suite without requiring any user input and prints only the final aggregated line as described.",
            "solution": "The problem statement has been analyzed and validated against the specified criteria.\n\n### Step 1: Extracted Givens\n- **Input Sequence:** A finite sequence of integers $A = \\langle a_1, a_2, \\ldots, a_n \\rangle$.\n- **Frequency Function:** $f(x)$ is defined as the number of occurrences of an integer $x$ in the sequence $A$. Formally, $f(x) = |\\{ i \\mid a_i = x \\}|$.\n- **Anti-Majority Element Definition:** An element $m$ is an anti-majority element if $f(m) = 1$ and for every other element $y$ that appears in $A$ ($y \\neq m$), the condition $f(y) \\geq 2$ holds.\n- **Task:** The algorithm must return the element $m$ if there is exactly one such anti-majority element. Otherwise, it must return $-1$.\n- **Special Case:** For a sequence of length $n=1$, e.g., $A = \\langle a_1 \\rangle$, the element $a_1$ is the anti-majority element.\n- **Test Suite:** The algorithm must be applied to a specific set of $7$ test sequences.\n- **Output:** A single line of text containing a comma-separated list of integer results enclosed in square brackets.\n\n### Step 2: Validation\nThe problem is well-defined, mathematically sound, and objective. It is grounded in the fundamental concepts of combinatorics (counting) and computer science (data structures and algorithms), specifically frequency count analysis. The definitions are precise, and the requirements are unambiguous. The problem is self-contained and does not contain any scientific inaccuracies, contradictions, or ill-posed structures.\n\n### Step 3: Verdict\nThe problem is **valid**. A solution will be developed.\n\n### Principle-Based Algorithmic Design\n\nThe problem requires determining the frequency of each element in a sequence and then applying a specific set of conditions. This is a classic frequency counting problem. The foundational principle for solving this efficiently is the use of an associative map (also known as a dictionary or hash map) to store the frequency of each unique element.\n\n**Step 1: Frequency Analysis**\nFirst, we must compute the frequency function $f(x)$ for all unique elements $x$ in the input sequence $A = \\langle a_1, a_2, \\ldots, a_n \\rangle$. An associative map, let's call it `freq_map`, is the ideal data structure for this task. We iterate through the sequence $A$ one element at a time. For each element $a_i$, we update its count in `freq_map`. If $a_i$ is not yet a key in the map, it is added with a count of $1$. If it already exists, its count is incremented. This process takes a total of $O(n)$ time on average, where $n$ is the length of the sequence, because each of the $n$ hash map operations (insertion or update) takes $O(1)$ average time. The space complexity required is $O(k)$, where $k$ is the number of unique elements in $A$, to store the map.\n\n**Step 2: Identification of the Anti-Majority Element**\nThe core of the task is to interpret the condition for the existence of an anti-majority element. The condition is: \"there exists exactly one element $m$ such that $f(m) = 1$ and for all $y \\in \\{ a_1, \\ldots, a_n \\}$ with $y \\neq m$ we have $f(y) \\geq 2$\".\n\nLet's analyze this condition. Let $S$ be the set of all unique elements present in the sequence $A$. The condition can be stated formally as: there exists a unique element $m \\in S$ such that $f(m) = 1$, and for every other element $y \\in S \\setminus \\{m\\}$, it holds that $f(y) \\geq 2$.\n\nThis condition can be simplified. The frequencies $f(y)$ for any element $y \\in S$ must be positive integers. If we find that there is exactly one element $m$ in $S$ with frequency $f(m)=1$, it logically follows that every other element $y \\in S \\setminus \\{m\\}$ must have a frequency that is a positive integer not equal to $1$. Therefore, for all such $y$, their frequencies must be $f(y) \\geq 2$.\n\nConsequently, the two parts of the condition are linked, and the problem reduces to finding the number of elements with a frequency of exactly $1$.\n- If zero elements have a frequency of $1$, the condition fails. The output must be $-1$.\n- If more than one element has a frequency of $1$, the \"exactly one\" part of the condition fails. The output must be $-1$.\n- If exactly one element has a frequency of $1$, that element is the anti-majority element, and it should be returned.\n\n**Step 3: Final Algorithm**\nBased on the analysis, a complete and efficient algorithm is as follows:\n1. Construct the frequency map from the input sequence $A$.\n2. Create a list of `candidates` for the anti-majority element by iterating through the frequency map and collecting all elements whose frequency is exactly $1$.\n3. Check the number of elements in the `candidates` list.\n   - If the list contains exactly one element, this element is the anti-majority element. Return it.\n   - If the list is empty or contains more than one element, no unique anti-majority element exists. Return $-1$.\n\n**Example Walkthrough (Test Case 1):**\n- Input: $A = \\langle 4, 7, 7, 4, 5, 4, 4 \\rangle$.\n- Step 1: Construct frequency map. `freq_map` = $\\{4: 4, 7: 2, 5: 1\\}$.\n- Step 2: Identify candidates with frequency $1$. The only such element is $5$, since $f(5)=1$. So, `candidates` = $[5]$.\n- Step 3: Check candidate count. The list `candidates` has one element. Thus, $5$ is the anti-majority element. The result is $5$.\n\n**Example Walkthrough (Test Case 4):**\n- Input: $A = \\langle 1, 2, 2, 3 \\rangle$.\n- Step 1: Construct frequency map. `freq_map` = $\\{1: 1, 2: 2, 3: 1\\}$.\n- Step 2: Identify candidates with frequency $1$. Here, $f(1)=1$ and $f(3)=1$. So, `candidates` = $[1, 3]$.\n- Step 3: Check candidate count. The list `candidates` has two elements. Since this is not exactly one, the condition is not met. The result is $-1$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef find_anti_majority(A: list[int]) - int:\n    \"\"\"\n    Finds the anti-majority element in a sequence A.\n\n    An anti-majority element m is an element that appears exactly once (f(m) = 1),\n    while all other distinct elements in the sequence appear at least twice.\n    The function returns m if a unique anti-majority element exists, and -1 otherwise.\n\n    Args:\n        A: A list of integers.\n\n    Returns:\n        The unique anti-majority element, or -1 if none exists.\n    \"\"\"\n    # If the input sequence is empty, no elements exist, so no anti-majority element can be found.\n    # The problem implies n >= 1, but this handles the edge case.\n    if not A:\n        return -1\n\n    # Use numpy.unique to efficiently get unique elements and their corresponding counts.\n    # This forms the basis of our frequency count analysis.\n    input_array = np.array(A, dtype=np.int64)\n    unique_elements, counts = np.unique(input_array, return_counts=True)\n\n    # The condition for an anti-majority element implies we are looking for an element\n    # with a frequency of exactly 1. All other elements must have frequencies >= 2.\n    # This is equivalent to finding if there is exactly one element with a count of 1.\n    \n    # We use boolean array indexing to filter for elements where the count is 1.\n    candidates = unique_elements[counts == 1]\n\n    # According to the problem definition, we must return the element if there is\n    # 'exactly one' such element.\n    if len(candidates) == 1:\n        # The result must be a standard Python int, not a numpy integer type.\n        return int(candidates[0])\n    else:\n        # If there are zero or more than one elements with a count of 1,\n        # the condition is not met.\n        return -1\n\ndef solve():\n    \"\"\"\n    Defines the test suite, runs the find_anti_majority function on each case,\n    and prints the results in the specified format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [4, 7, 7, 4, 5, 4, 4],                             # Test 1\n        [-1, -1, 0, 0, 0, 2],                               # Test 2\n        [9, 9, 9, 8, 8],                                    # Test 3\n        [1, 2, 2, 3],                                       # Test 4\n        [42],                                               # Test 5\n        [5, 5, 7, 8, 8],                                    # Test 6\n        [1000000, 1000000, -1000000, -1000000, 123456789],   # Test 7\n    ]\n\n    results = []\n    for case in test_cases:\n        result = find_anti_majority(case)\n        results.append(result)\n\n    # Final print statement in the exact required format: [result1,result2,...]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "This advanced practice demonstrates the versatility of frequency analysis as a component in multi-step algorithms. Here, the items to be counted are not the elements of the input array itself, but a set of derived values: the sums of all contiguous subarrays. This problem requires you to first generate the dataset of interest using an efficient technique like prefix sums, and then apply frequency counting to find the most common sum, showcasing how these methods can be combined to solve more intricate problems .",
            "id": "3236140",
            "problem": "You are given a finite sequence of integers and are asked to analyze the frequency of sums of all contiguous subarrays. A contiguous subarray of a sequence $A = [a_0, a_1, \\dots, a_{n-1}]$ is any sequence $[a_i, a_{i+1}, \\dots, a_j]$ with $0 \\le i \\le j \\le n-1$. For each contiguous subarray, define its sum as the integer obtained by adding all its elements. Define a frequency count function $c(s)$ that maps each integer $s$ to the number of contiguous subarrays of $A$ whose sum equals $s$. Your task is to compute a single integer $s^\\star$ that maximizes $c(s)$ over all possible sums $s$, and also output the corresponding frequency $c(s^\\star)$. In case multiple sums yield the same maximum frequency, you must choose the smallest such sum by value. If the input array is empty (that is, $n = 0$), define by convention that no contiguous subarray exists and the output shall be $s^\\star = 0$ and $c(s^\\star) = 0$.\n\nStart from first principles in data structures and algorithms: use the definition of a contiguous subarray as above, the basic property of integer addition associativity and commutativity over contiguous segments, and the well-tested fact that a subarray sum can be computed via a partial (prefix) sum difference. Concretely, let the prefix sum array $P$ be defined by $P[0] = 0$ and $P[k] = \\sum_{t=0}^{k-1} a_t$ for $1 \\le k \\le n$. For any indices $i, j$ with $0 \\le i \\le j \\le n-1$, the sum of the contiguous subarray $[a_i, \\dots, a_j]$ is given by $P[j+1] - P[i]$. Design an algorithm that leverages this principle to generate all contiguous subarray sums and compute their frequency distribution via a suitable data structure for counting.\n\nYour program must implement this logic and run on the following test suite of arrays:\n- Test case $1$: $A_1 = [3, -1, 2, -1, 2]$.\n- Test case $2$: $A_2 = [2, 2, 2]$.\n- Test case $3$: $A_3 = [0, 0, 0]$.\n- Test case $4$: $A_4 = [1, -2, 1]$.\n- Test case $5$: $A_5 = []$.\n\nFor each test case $A_k$, your program must output the pair $[s^\\star, c(s^\\star)]$ as a list of two integers. The final output must aggregate the results of all test cases in the exact format described next. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each element itself being a two-integer list in square brackets and no spaces. For example, an output for $3$ test cases should look like $[[x_1,y_1],[x_2,y_2],[x_3,y_3]]$.\n\nNo physical units or angles are involved in this problem. The answer for each test case must be a list of integers in the form $[s^\\star, c(s^\\star)]$. Ensure your algorithm is correct and efficient relative to the fundamental definitions provided, noting that the total number of contiguous subarrays is $n(n+1)/2$, which is on the order of $O(n^2)$, and that enumerating all subarray sums inherently requires considering these $O(n^2)$ cases in the general setting.",
            "solution": "The user-provided problem statement has been analyzed and validated against the established criteria.\n\n### Step 1: Extract Givens\n- **Input**: A finite sequence of integers $A = [a_0, a_1, \\dots, a_{n-1}]$.\n- **Contiguous Subarray**: A sequence $[a_i, a_{i+1}, \\dots, a_j]$ with $0 \\le i \\le j \\le n-1$.\n- **Subarray Sum**: The sum of all elements in a contiguous subarray.\n- **Frequency Count Function $c(s)$**: A function mapping an integer sum $s$ to the number of contiguous subarrays of $A$ whose sum equals $s$.\n- **Objective**: Find the integer $s^\\star$ that maximizes $c(s)$ and its corresponding frequency $c(s^\\star)$.\n- **Tie-breaking Rule**: If multiple sums yield the same maximum frequency, choose the smallest such sum.\n- **Edge Case**: If $A$ is empty ($n=0$), the output must be $s^\\star = 0$ and $c(s^\\star) = 0$.\n- **Algorithmic Guideline**: Utilize the prefix sum method. The prefix sum array $P$ is defined by $P[0] = 0$ and $P[k] = \\sum_{t=0}^{k-1} a_t$ for $1 \\le k \\le n$. The sum of a subarray $[a_i, \\dots, a_j]$ is given by $P[j+1] - P[i]$.\n- **Test Cases**:\n    - $A_1 = [3, -1, 2, -1, 2]$\n    - $A_2 = [2, 2, 2]$\n    - $A_3 = [0, 0, 0]$\n    - $A_4 = [1, -2, 1]$\n    - $A_5 = []$\n- **Output Format**: For each test case, a list of two integers $[s^\\star, c(s^\\star)]$. The final aggregated output for all test cases must be a single string in the format `[[s_1,c_1],[s_2,c_2],...]`.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is evaluated as follows:\n- **Scientifically Grounded**: The problem is a well-defined exercise in mathematics and computer science (specifically, algorithms and data structures). It relies on standard definitions of arrays, subarrays, and integer arithmetic. All principles are logically and mathematically sound.\n- **Well-Posed**: The problem is clearly structured. The objective is unambiguous, and the inclusion of a tie-breaking rule and an edge-case definition ensures that a unique and stable solution exists for any valid input.\n- **Objective**: The problem is stated in precise, formal language, free of any subjectivity or ambiguity.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. It is self-contained, mathematically consistent, well-posed, and directly pertains to the analysis of algorithms. Therefore, a solution will be provided.\n\n### Solution Derivation\nThe problem requires us to find the most frequent sum among all possible contiguous subarrays of a given integer sequence $A$. A brute-force enumeration of all subarrays and their sums would be computationally intensive. The problem directs an approach based on prefix sums, which is a standard and efficient technique for such problems.\n\nLet the input sequence be $A = [a_0, a_1, \\dots, a_{n-1}]$ of length $n$.\n\nFirst, we address the special case where the input array is empty. As per the problem definition, if $n=0$, the result is $s^\\star=0$ and $c(s^\\star)=0$.\n\nFor a non-empty array, we construct the prefix sum array, denoted by $P$. This array will have a length of $n+1$. It is defined as:\n$$P[k] = \\sum_{t=0}^{k-1} a_t \\quad \\text{for } 1 \\le k \\le n$$\nwith the base case:\n$$P[0] = 0$$\nThe prefix sum array can be computed in $O(n)$ time by iterating through $A$ once: $P[k] = P[k-1] + a_{k-1}$ for $k=1, \\dots, n$.\n\nThe sum of any contiguous subarray, $S_{i,j} = \\sum_{k=i}^{j} a_k$, where $0 \\le i \\le j \\le n-1$, can be calculated efficiently using the prefix sum array. The sum is the difference between two prefix sums:\n$$ S_{i,j} = \\left(\\sum_{k=0}^{j} a_k\\right) - \\left(\\sum_{k=0}^{i-1} a_k\\right) = P[j+1] - P[i] $$\nThis formulation is key. It transforms the problem from summing up elements in subarrays to finding differences between elements of the prefix sum array $P$. Every contiguous subarray sum corresponds to a difference $P[k] - P[l]$ for some $0 \\le l  k \\le n$. There are exactly $\\frac{n(n+1)}{2}$ such pairs of indices $(l, k)$, which corresponds to the total number of contiguous subarrays.\n\nThe algorithm proceeds as follows:\n1.  Handle the edge case: If $n=0$, return $[0, 0]$.\n2.  Initialize an empty data structure, such as a hash map (or a dictionary in Python), to store the frequencies of the subarray sums. Let's call this `freq_map`.\n3.  Compute the prefix sum array $P$ of size $n+1$.\n4.  Iterate through all possible pairs of indices $(l, k)$ of the prefix sum array $P$ such that $0 \\le l  k \\le n$. For each pair, calculate the subarray sum $s = P[k] - P[l]$.\n5.  For each calculated sum $s$, increment its count in `freq_map`. That is, `freq_map[s] = freq_map.get(s, 0) + 1`. This can be implemented with a nested loop structure, where the outer loop iterates $k$ from $1$ to $n$ and the inner loop iterates $l$ from $0$ to $k-1$. This process generates all $\\frac{n(n+1)}{2}$ subarray sums and correctly counts their frequencies. The time complexity of this step is $O(n^2)$.\n6.  After populating `freq_map`, the final step is to find the pair $(s, c(s))$ that maximizes $c(s)$, adhering to the tie-breaking rule. We need to find $s^\\star = \\arg\\max_s c(s)$, choosing the smallest $s$ in case of a tie.\n7.  This can be achieved by iterating through the items in `freq_map`. We maintain two variables: `max_freq` initialized to a value less than any possible frequency (e.g., $-1$), and `s_star` for the optimal sum. During iteration, for each sum $s$ with frequency $c$:\n    - If $c  \\text{max\\_freq}$, we have found a new most frequent sum. We update $\\text{max\\_freq} = c$ and $\\text{s\\_star} = s$.\n    - If $c = \\text{max\\_freq}$, we apply the tie-breaking rule. We update $\\text{s\\_star} = \\min(\\text{s\\_star}, s)$.\n    An elegant way to implement this is to convert the map items into a list and sort it. Sorting first by frequency in descending order, and then by sum value in ascending order, guarantees that the first element of the sorted list is the desired result.\n\nThe overall time complexity is dominated by the nested loops for generating and counting sums, which is $O(n^2)$. The space complexity is $O(n)$ for the prefix sum array plus the space for `freq_map`, which can be up to $O(n^2)$ in the worst case if all subarray sums are unique.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import defaultdict\n\ndef solve():\n    \"\"\"\n    Solves the frequency analysis problem for contiguous subarray sums for a suite of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [3, -1, 2, -1, 2],  # Test case 1\n        [2, 2, 2],           # Test case 2\n        [0, 0, 0],           # Test case 3\n        [1, -2, 1],          # Test case 4\n        [],                  # Test case 5\n    ]\n\n    all_results = []\n    for A in test_cases:\n        n = len(A)\n\n        # Handle the edge case for an empty array as per the problem definition.\n        if n == 0:\n            all_results.append([0, 0])\n            continue\n\n        # Step 1: Compute the prefix sum array P.\n        # P[0] = 0\n        # P[k] = sum of A[0]...A[k-1] for k > 0.\n        prefix_sums = np.zeros(n + 1, dtype=np.int64)\n        prefix_sums[1:] = np.cumsum(A, dtype=np.int64)\n        \n        # Step 2: Generate all subarray sums and count their frequencies.\n        # A subarray sum from index i to j is P[j+1] - P[i].\n        # In our loop notation, this is P[k] - P[l] where 0 = l  k = n.\n        freq_map = defaultdict(int)\n        for k in range(1, n + 1):\n            for l in range(k):\n                sub_sum = prefix_sums[k] - prefix_sums[l]\n                freq_map[sub_sum] += 1\n        \n        # Step 3: Find the sum with the highest frequency.\n        # The tie-breaking rule is to choose the smallest sum.\n        # We can achieve this by sorting:\n        # 1. By frequency in descending order.\n        # 2. By sum in ascending order for ties in frequency.\n        # The first element after sorting will be the answer.\n        \n        # Convert map to a list of (sum, frequency) tuples\n        sum_freq_pairs = list(freq_map.items())\n        \n        # Sort using a lambda function that implements the desired ordering\n        # -item[1] for descending frequency, item[0] for ascending sum\n        sum_freq_pairs.sort(key=lambda item: (-item[1], item[0]))\n        \n        # The optimal sum and its frequency is the first element of the sorted list.\n        s_star, max_freq = sum_freq_pairs[0]\n        \n        all_results.append([s_star, max_freq])\n\n    # Final print statement in the exact required format.\n    # Format: [[s1,c1],[s2,c2],...] with no spaces.\n    result_str = \",\".join([f\"[{s},{c}]\" for s, c in all_results])\n    print(f\"[{result_str}]\")\n\nsolve()\n```"
        }
    ]
}