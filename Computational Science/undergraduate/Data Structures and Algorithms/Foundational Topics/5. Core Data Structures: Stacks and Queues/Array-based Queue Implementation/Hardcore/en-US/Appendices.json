{
    "hands_on_practices": [
        {
            "introduction": "This first practice is a cornerstone exercise in data structures: building a fully-featured, resizable circular queue. You will implement the essential `enqueue` and `dequeue` operations, paying close attention to the logic of dynamic resizing for both growing and shrinking the underlying array. This challenge  will deepen your understanding of how modular arithmetic and amortized analysis come together to create an efficient and flexible queue.",
            "id": "3209149",
            "problem": "Design and implement a first-in-first-out queue using a circular, resizable array that can store elements of any data type. The core of the design must follow from the fundamental definition of a queue and modular arithmetic on array indices. Specifically, use the following fundamental base: a queue is an abstract data type that enforces first-in-first-out order, and circular buffer indexing advances indices by replacing an index $i$ with $(i+1) \\bmod C$ where $C$ is the current capacity of the underlying array.\n\nImplementation requirements:\n- Maintain an array of current capacity $C$, a head index $h$, a tail index $t$, and a size $s$ (the number of elements). The head index $h$ points to the position of the logical front of the queue, and the tail index $t$ points to the position where the next element will be inserted.\n- Enqueue operation: before inserting a new element, if $s = C$ then allocate a new array of capacity $2C$ and copy the current $s$ elements in logical order starting at index $0$. After copying, set $h \\leftarrow 0$ and $t \\leftarrow s$, and then insert the new element at index $t$, advance $t \\leftarrow (t+1) \\bmod C$, and increase the size $s \\leftarrow s+1$.\n- Dequeue operation: remove and return the front element at index $h$, clear that slot, advance $h \\leftarrow (h+1) \\bmod C$, and decrease the size $s \\leftarrow s-1$. After removal, if $s \\le \\lfloor C/4 \\rfloor$ and $C$ is strictly greater than the initial capacity $C_0$, then allocate a new array of capacity $\\max(C_0,\\lfloor C/2 \\rfloor)$, copy the $s$ elements in logical order starting at index $0$, and set $h \\leftarrow 0$, $t \\leftarrow s$.\n- Never shrink the capacity below the initial capacity $C_0$. Assume no operations will attempt to dequeue or peek from an empty queue.\n- The implementation must be logically generic: it must preserve the order of arbitrary elements and must not depend on operations specific to a particular data type. In a statically typed language, this is naturally achieved with templates or generics; in a dynamically typed language, the same behavior is achieved by not restricting the element type.\n\nCorrectness requirement:\n- Maintain the invariants that after any finite sequence of operations, the logical content of the queue is exactly the sequence of enqueued elements that have not been dequeued, in the same order; the head index $h$ always indicates the position of the current front (when $s > 0$); and the tail index $t$ always indicates the position immediately after the last element. All operations must run in worst-case time $O(C)$ when resizing occurs and $O(1)$ otherwise, with amortized time $O(1)$ over any sequence of $m$ operations.\n\nYour program must implement this queue and run the following test suite. For each test, compute the specified integer or floating-point results.\n\nTest case A (wrap-around and growth with integers):\n- Parameters: initial capacity $C_0 = 4$.\n- Operations in order: enqueue $10$, enqueue $20$, enqueue $30$, dequeue, dequeue, enqueue $40$, enqueue $50$, enqueue $60$, enqueue $70$.\n- Required result for this test: a list $[s, C, f, S_{\\text{dq}}]$ where $s$ is the final size, $C$ is the final capacity, $f$ is the final front element, and $S_{\\text{dq}}$ is the sum of all values dequeued in this test.\n\nTest case B (growth followed by shrink with integers):\n- Parameters: initial capacity $C_0 = 2$.\n- Operations in order: enqueue the integers $0,1,2,\\dots,15$ (inclusive), then perform exactly $13$ dequeues.\n- Required result for this test: a list $[s, C, f, S_{\\text{dq}}]$ as above, where $f$ is the current front element after the last dequeue, and $S_{\\text{dq}}$ is the sum of all dequeued integers.\n\nTest case C (strings with growth and shrink; aggregate by length):\n- Parameters: initial capacity $C_0 = 3$.\n- Operations in order: enqueue the strings \"x\", \"yy\", \"zzz\", \"wwww\", then dequeue twice, then enqueue \"vv\", then enqueue \"u\", then dequeue repeatedly until empty.\n- Required result for this test: a list $[s, C, L]$ where $s$ is the final size, $C$ is the final capacity, and $L$ is the sum of lengths of all strings dequeued during this test.\n\nTest case D (floats with wrap-around, no growth):\n- Parameters: initial capacity $C_0 = 5$.\n- Operations in order: enqueue $1.5$, enqueue $2.5$, enqueue $3.5$, dequeue once, enqueue $4.5$, enqueue $5.5$, dequeue twice, enqueue $6.5$, enqueue $7.5$, enqueue $8.5$.\n- Required result for this test: a list $[s, C, f, S_{\\text{dq}}]$ where $s$ is the final size, $C$ is the final capacity, $f$ is the final front element, and $S_{\\text{dq}}$ is the sum (as a floating-point number) of all dequeued values.\n\nFinal output format:\n- Your program should produce a single line of output containing the results of the four tests as a comma-separated list enclosed in square brackets. Each test result itself must appear as a bracketed, comma-separated list. For example, the overall shape must be of the form $[[\\cdots],[\\cdots],[\\cdots],[\\cdots]]$ with no additional text. There are no physical units, and no angles or percentages are involved in this problem.",
            "solution": "The problem requires the design and implementation of a first-in-first-out (FIFO) queue using a resizable, circular array. The design must be derived from fundamental principles of data structures and modular arithmetic.\n\n### Principle-Based Design\n\n**1. The Queue Abstract Data Type (ADT)**\nA queue is an abstract data type defined by its behavior: it stores a collection of elements and enforces a First-In-First-Out (FIFO) access policy. Elements are added to one end (the \"tail\" or \"rear\") via an `enqueue` operation and removed from the other end (the \"head\" or \"front\") via a `dequeue` operation. This strict ordering is the core principle guiding the design.\n\n**2. Array-Based Implementation and Circular Indexing**\nA simple array can be used to store the queue's elements. A naive implementation might shift all elements one position to the left upon every `dequeue` to keep the head at index $0$. This, however, results in an $O(s)$ time complexity for `dequeue`, where $s$ is the number of elements, which is inefficient.\n\nTo achieve constant-time $O(1)$ operations, we treat the array as a circular buffer. This is accomplished using modular arithmetic. We maintain two indices: a head index $h$ pointing to the first logical element, and a tail index $t$ pointing to the next available slot. When an index advances past the end of the array (at capacity $C-1$), it \"wraps around\" to the beginning ($0$). This is mathematically expressed as advancing an index $i$ to $(i+1) \\bmod C$. With this scheme, `enqueue` and `dequeue` operations simply involve updating the $h$ or $t$ index, achieving $O(1)$ time complexity. To disambiguate between a full and an empty queue (which can both occur when $h=t$), we explicitly maintain a size counter, $s$. An `enqueue` operation increments $s$ and a `dequeue` decrements it. The queue is empty if $s=0$ and full if $s=C$.\n\n**3. Dynamic Resizing and Amortized Analysis**\nA fixed-capacity array is limiting. To support an arbitrary number of elements, the underlying array must be resizable. The specified strategy is a common and efficient one:\n- **Growth (on `enqueue` when $s=C$):** The capacity is doubled ($C \\to 2C$). A new, larger array is allocated. The existing $s$ elements, which may be wrapped around in the old array, are copied into the new array in their logical order, starting from index $0$. The head and tail indices are then reset to $h \\leftarrow 0$ and $t \\leftarrow s$.\n- **Shrinkage (on `dequeue` when $s \\le \\lfloor C/4 \\rfloor$):** To conserve memory, the array shrinks if its occupancy falls to a quarter or less of its capacity. The capacity is halved ($C \\to \\lfloor C/2 \\rfloor$), with the constraint that it never falls below the initial capacity $C_0$. The copy and index reset procedure is the same as for growth.\n\nWhile a single `enqueue` or `dequeue` that triggers a resize takes time proportional to the current capacity, $O(C)$, these events are infrequent. The cost of resizing is amortized over the sequence of operations. After a growth to capacity $2C$, at least $C$ more `enqueue` operations must occur before the next growth. Similarly, after a shrink to capacity $C/2$, at least $C/4$ `dequeue` operations are needed to trigger another shrink. This ensures that the total work for $m$ operations remains proportional to $m$, leading to an amortized time complexity of $O(1)$ per operation.\n\n**4. Implementation Structure**\nThe implementation encapsulates this logic within a class. This class maintains the state variables: the data array, the current capacity $C$, the initial capacity $C_0$, the head index $h$, the tail index $t$, and the size $s$.\nThe method for copying elements during a resize (`_resize`) is critical. It must iterate through the elements in their logical FIFO order, starting from the physical index $h$ in the old array and wrapping around using the modulo operator, and place them into the first $s$ positions of the new array. Specifically, the $k$-th logical element (where $k \\in \\{0, 1, \\dots, s-1\\}$) is located at physical index $(h+k) \\bmod C_{\\text{old}}$ and is copied to index $k$ in the new array.\n\nThis design is logically generic as it does not perform any operations on the elements themselves, other than storage and retrieval. It thus preserves the integrity and order of elements of any data type, as required.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and tests the ResizableCircularQueue as per the problem statement.\n    \"\"\"\n\n    class ResizableCircularQueue:\n        \"\"\"\n        A FIFO queue implemented with a resizable, circular numpy array.\n        \"\"\"\n        def __init__(self, initial_capacity: int):\n            \"\"\"\n            Initializes an empty queue with a given initial capacity.\n            \"\"\"\n            if initial_capacity  1:\n                raise ValueError(\"Initial capacity must be at least 1.\")\n            self._C0 = initial_capacity\n            self._C = self._C0\n            # dtype=object allows storing elements of any type.\n            self._data = np.full(self._C, None, dtype=object)\n            self._h = 0  # Head index (points to the front element)\n            self._t = 0  # Tail index (points to the next available slot)\n            self._s = 0  # Number of elements in the queue\n\n        @property\n        def size(self) -> int:\n            \"\"\"Returns the number of elements in the queue.\"\"\"\n            return self._s\n\n        @property\n        def capacity(self) -> int:\n            \"\"\"Returns the current capacity of the underlying array.\"\"\"\n            return self._C\n        \n        def get_front(self):\n            \"\"\"Returns the front element of the queue without removing it.\"\"\"\n            if self.size == 0:\n                # Per problem statement, this will not be called on an empty queue.\n                return None\n            return self._data[self._h]\n\n        def _resize(self, new_capacity: int):\n            \"\"\"\n            Resizes the underlying array to new_capacity and copies elements.\n            \"\"\"\n            old_data = self._data\n            old_capacity = self._C\n            \n            self._data = np.full(new_capacity, None, dtype=object)\n            \n            # Copy elements from the old (circular) array to the new (linear) one.\n            walk = self._h\n            for k in range(self._s):\n                self._data[k] = old_data[walk]\n                walk = (walk + 1) % old_capacity\n            \n            # Reset indices and update capacity\n            self._C = new_capacity\n            self._h = 0\n            self._t = self._s\n\n        def enqueue(self, element):\n            \"\"\"\n            Adds an element to the tail of the queue.\n            \"\"\"\n            if self._s == self._C:\n                # Grow array if it is full.\n                self._resize(2 * self._C)\n            \n            self._data[self._t] = element\n            self._t = (self._t + 1) % self._C\n            self._s += 1\n\n        def dequeue(self):\n            \"\"\"\n            Removes and returns the element from the head of the queue.\n            Assumes the queue is not empty, as per problem statement.\n            \"\"\"\n            element = self._data[self._h]\n            self._data[self._h] = None  # Clear the slot\n            self._h = (self._h + 1) % self._C\n            self._s -= 1\n            \n            # Shrink array if it is sparsely populated, but not below C0.\n            if self._s = self._C // 4 and self._C > self._C0:\n                new_capacity = max(self._C0, self._C // 2)\n                self._resize(new_capacity)\n\n            return element\n\n    # --- Test Cases ---\n    all_results = []\n\n    # Test Case A\n    q_a = ResizableCircularQueue(initial_capacity=4)\n    dequeued_vals_a = []\n    q_a.enqueue(10)\n    q_a.enqueue(20)\n    q_a.enqueue(30)\n    dequeued_vals_a.append(q_a.dequeue())\n    dequeued_vals_a.append(q_a.dequeue())\n    q_a.enqueue(40)\n    q_a.enqueue(50)\n    q_a.enqueue(60)\n    q_a.enqueue(70)\n    result_a = [q_a.size, q_a.capacity, q_a.get_front(), sum(dequeued_vals_a)]\n    all_results.append(result_a)\n\n    # Test Case B\n    q_b = ResizableCircularQueue(initial_capacity=2)\n    dequeued_vals_b = []\n    for i in range(16):\n        q_b.enqueue(i)\n    for _ in range(13):\n        dequeued_vals_b.append(q_b.dequeue())\n    result_b = [q_b.size, q_b.capacity, q_b.get_front(), sum(dequeued_vals_b)]\n    all_results.append(result_b)\n\n    # Test Case C\n    q_c = ResizableCircularQueue(initial_capacity=3)\n    dequeued_vals_c = []\n    q_c.enqueue(\"x\")\n    q_c.enqueue(\"yy\")\n    q_c.enqueue(\"zzz\")\n    q_c.enqueue(\"wwww\")\n    dequeued_vals_c.append(q_c.dequeue())\n    dequeued_vals_c.append(q_c.dequeue())\n    q_c.enqueue(\"vv\")\n    q_c.enqueue(\"u\")\n    while q_c.size > 0:\n        dequeued_vals_c.append(q_c.dequeue())\n    L_c = sum(len(s) for s in dequeued_vals_c)\n    result_c = [q_c.size, q_c.capacity, L_c]\n    all_results.append(result_c)\n    \n    # Test Case D\n    q_d = ResizableCircularQueue(initial_capacity=5)\n    dequeued_vals_d = []\n    q_d.enqueue(1.5)\n    q_d.enqueue(2.5)\n    q_d.enqueue(3.5)\n    dequeued_vals_d.append(q_d.dequeue())\n    q_d.enqueue(4.5)\n    q_d.enqueue(5.5)\n    dequeued_vals_d.append(q_d.dequeue())\n    dequeued_vals_d.append(q_d.dequeue())\n    q_d.enqueue(6.5)\n    q_d.enqueue(7.5)\n    q_d.enqueue(8.5)\n    f_d = q_d.get_front()\n    # Ensure float precision is handled correctly for output\n    S_dq_d = float(sum(dequeued_vals_d))\n    result_d = [q_d.size, q_d.capacity, f_d, S_dq_d]\n    all_results.append(result_d)\n\n    # Format the final output string exactly as specified.\n    results_str_list = []\n    for res in all_results:\n        # Convert each item in a result list to string\n        res_items_as_str = [str(item) for item in res]\n        # Join items with a comma and enclose in brackets\n        results_str_list.append(f\"[{','.join(res_items_as_str)}]\")\n    \n    # Join all test case results with a comma and enclose in brackets\n    final_output = f\"[{','.join(results_str_list)}]\"\n    \n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "While queues are defined by front and back access, a true mastery of the circular array implementation allows for more. This practice challenges you to implement an efficient `peek_kth(k)` operation, which retrieves the $k^{\\text{th}}$ element from the front in constant time. Successfully deriving the index formula for this operation  demonstrates a deep understanding of the mathematical mapping between logical queue positions and physical array indices.",
            "id": "3209065",
            "problem": "You are asked to implement an Array-Based Circular Queue as a concrete realization of the Queue Abstract Data Type (ADT), with particular emphasis on achieving an efficient $\\text{peek\\_kth}(k)$ operation. The Queue ADT follows the First-In-First-Out (FIFO) semantics, meaning that the first element enqueued is the first element dequeued. The required implementation must use a fixed-capacity array that simulates a circular buffer by employing modular arithmetic for index arithmetic. All operations must be defined in purely mathematical and logical terms, independent of any specific programming language.\n\nFundamental base assumptions and definitions to use:\n- A queue is a collection that supports the operations $\\text{enqueue}(x)$, $\\text{dequeue}()$, and read-only operations such as $\\text{front}()$ and $\\text{rear}()$, under FIFO semantics.\n- An array of capacity $n$ supports constant-time access to element $A[i]$ for any valid index $i$.\n- Circularity is modeled by performing index arithmetic in the ring of integers modulo $n$, denoted $\\mathbb{Z}_n$.\n- The queue maintains three integer state variables: the capacity $n$, the front index $f$, and the current size $s$. The rear index is implicitly maintained by $r$ where $r$ is the position where the next element is placed on $\\text{enqueue}$.\n- All operations must run in $O(1)$ time.\n\nYour task:\n- Implement an Array-Based Circular Queue with operations $\\text{enqueue}(x)$, $\\text{dequeue}()$, $\\text{is\\_empty}()$, $\\text{is\\_full}()$, $\\text{size}()$, and critically $\\text{peek\\_kth}(k)$ which returns the $k^{\\text{th}}$ element from the front without removing it.\n- The operation $\\text{peek\\_kth}(k)$ must run in $O(1)$ time, using only arithmetic on indices and array access. Derive the correct index mapping for the $k^{\\text{th}}$ element from the fundamental base above (array indexing and modular arithmetic on $\\mathbb{Z}_n$) and implement accordingly.\n- Error handling: if $k  1$, or $k > s$, or the queue is empty ($s = 0$), $\\text{peek\\_kth}(k)$ must return the sentinel value $-1$.\n- Validity constraints: $\\text{enqueue}(x)$ on a full queue should not change the queue and should return a boolean indicator; $\\text{dequeue}()$ on an empty queue should return the sentinel value $-1$.\n- All indices and sizes are integers, and all queue elements in the test suite are integers.\n\nTest suite:\nFor each test case, the parameters are a capacity $n$ and a sequence of operations. Each operation is one of $\\text{ENQ } v$, $\\text{DEQ}$, or $\\text{PEEK } k$, where $v$ and $k$ are integers. The required outputs for a test case are the integers returned by each $\\text{PEEK } k$ encountered while executing the operation sequence in order. The following test cases must be executed in order:\n\n- Test case $1$ (general happy path):\n  - Capacity $n = 8$.\n  - Operations:\n    - $\\text{ENQ } 10$, $\\text{ENQ } 20$, $\\text{ENQ } 30$, $\\text{ENQ } 40$, $\\text{PEEK } 1$, $\\text{PEEK } 2$, $\\text{PEEK } 4$, $\\text{DEQ}$, $\\text{ENQ } 50$, $\\text{ENQ } 60$, $\\text{PEEK } 3$.\n  - Expected sequence of outputs: a list of integers corresponding to the results of the four $\\text{PEEK}$ operations.\n\n- Test case $2$ (wrap-around without full capacity):\n  - Capacity $n = 5$.\n  - Operations:\n    - $\\text{ENQ } 1$, $\\text{ENQ } 2$, $\\text{ENQ } 3$, $\\text{DEQ}$, $\\text{DEQ}$, $\\text{ENQ } 4$, $\\text{ENQ } 5$, $\\text{ENQ } 6$, $\\text{PEEK } 1$, $\\text{PEEK } 3$, $\\text{PEEK } 4$.\n\n- Test case $3$ (full queue and boundary $k$ values):\n  - Capacity $n = 4$.\n  - Operations:\n    - $\\text{ENQ } 7$, $\\text{ENQ } 8$, $\\text{ENQ } 9$, $\\text{ENQ } 10$, $\\text{PEEK } 1$, $\\text{PEEK } 4$, $\\text{DEQ}$, $\\text{ENQ } 11$, $\\text{PEEK } 4$.\n\n- Test case $4$ (single element and invalid $k$ values):\n  - Capacity $n = 3$.\n  - Operations:\n    - $\\text{ENQ } 42$, $\\text{PEEK } 1$, $\\text{PEEK } 2$, $\\text{PEEK } 0$, $\\text{DEQ}$, $\\text{PEEK } 1$.\n\n- Test case $5$ (alternating $\\text{enqueue}$ and $\\text{dequeue}$ with wrap-around):\n  - Capacity $n = 6$.\n  - Operations:\n    - $\\text{ENQ } 100$, $\\text{ENQ } 200$, $\\text{DEQ}$, $\\text{ENQ } 300$, $\\text{ENQ } 400$, $\\text{ENQ } 500$, $\\text{DEQ}$, $\\text{DEQ}$, $\\text{ENQ } 600$, $\\text{ENQ } 700$, $\\text{ENQ } 800$, $\\text{PEEK } 1$, $\\text{PEEK } 2$, $\\text{PEEK } 5$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results of all test cases as a comma-separated list of lists enclosed in square brackets, for example $[[a_1,a_2],[b_1],[c_1,c_2,c_3]]$. Each inner list contains the integers returned by the $\\text{PEEK}$ operations in that test case, in order.",
            "solution": "The posed problem is valid as it is scientifically grounded in the principles of data structures, is well-posed, objective, and internally consistent. It presents a standard but non-trivial challenge in implementing a circular queue with an efficient `peek_kth` operation.\n\nWe shall construct the Array-Based Circular Queue by defining its state and operations in formal mathematical terms. The implementation will be based on a fixed-capacity array, with indices managed through modular arithmetic.\n\nA circular queue is defined by the following state variables:\n- $n \\in \\mathbb{Z}^+$: The fixed capacity of the queue.\n- $A$: An array of size $n$, with indices in $\\{0, 1, \\dots, n-1\\}$.\n- $f \\in \\{0, 1, \\dots, n-1\\}$: The index in $A$ where the front (first) element of the queue is located.\n- $s \\in \\{0, 1, \\dots, n\\}$: The current number of elements in the queue.\n\nFrom these state variables, we can derive other properties. The set of occupied indices in the array $A$ represents the elements of the queue. These elements are located at indices $(f+i) \\pmod n$ for $i \\in \\{0, 1, \\dots, s-1\\}$. The rear index $r$, which is the location for the next enqueue operation, is implicitly given by $r = (f + s) \\pmod n$. All arithmetic on indices is performed in the ring of integers modulo $n$, denoted $\\mathbb{Z}_n$. All operations are designed to have a time complexity of $O(1)$.\n\nThe operations are defined as follows:\n\n1.  $\\text{size}()$: This operation returns the number of elements currently in the queue.\n    - Output: $s$.\n    - This is an $O(1)$ operation as it is a direct read of the state variable $s$.\n\n2.  $\\text{is\\_empty}()$: This operation checks if the queue contains any elements.\n    - Output: A boolean value, true if $s = 0$, and false otherwise.\n    - This is an $O(1)$ operation involving a single comparison.\n\n3.  $\\text{is\\_full}()$: This operation checks if the queue has reached its capacity.\n    - Output: A boolean value, true if $s = n$, and false otherwise.\n    - This is an $O(1)$ operation involving a single comparison.\n\n4.  $\\text{enqueue}(x)$: This operation adds an element $x$ to the rear of the queue.\n    - Precondition: The queue must not be full, i.e., $s  n$.\n    - If $\\text{is\\_full}()$ is true, the operation fails, the queue state remains unchanged, and a 'false' indicator is returned.\n    - If the queue is not full, the following steps are executed:\n        1.  Determine the rear index for insertion: $r \\leftarrow (f + s) \\pmod n$.\n        2.  Store the element: $A[r] \\leftarrow x$.\n        3.  Increment the size: $s \\leftarrow s + 1$.\n        4.  Return a 'true' indicator.\n    - This operation involves a few arithmetic calculations and one array write, making it $O(1)$.\n\n5.  $\\text{dequeue}()$: This operation removes and returns the element at the front of the queue.\n    - Precondition: The queue must not be empty, i.e., $s  0$.\n    - If $\\text{is\\_empty}()$ is true, the operation fails, and the sentinel value $-1$ is returned.\n    - If the queue is not empty, the following steps are executed:\n        1.  Retrieve the front element: $v \\leftarrow A[f]$.\n        2.  Update the front index: $f \\leftarrow (f + 1) \\pmod n$.\n        3.  Decrement the size: $s \\leftarrow s - 1$.\n        4.  Return the retrieved value $v$.\n    - This operation involves one array read and a few arithmetic calculations, making it $O(1)$.\n\n6.  $\\text{peek\\_kth}(k)$: This is the critical operation that returns the $k^{\\text{th}}$ element from the front of the queue without removing it. The parameter $k$ is $1$-indexed, meaning $k=1$ refers to the front element.\n    - Error conditions: The operation must return the sentinel value $-1$ if the queue is empty ($s=0$) or if $k$ is out of bounds (i.e., $k  1$ or $k  s$).\n    - Derivation of the index:\n        - The first element ($k=1$) is at index $f$, which can be written as $(f + 1 - 1) \\pmod n$.\n        - The second element ($k=2$) is at index $(f+1) \\pmod n$, which can be written as $(f + 2 - 1) \\pmod n$.\n        - By induction, the $i^{\\text{th}}$ element in the logical sequence of the queue is located at a physical array index that is offset by $i-1$ from the front index $f$, with wrap-around.\n        - Therefore, the physical index `idx` for the $k^{\\text{th}}$ element is given by the formula:\n          $$ \\text{idx} = (f + k - 1) \\pmod n $$\n    - Algorithm:\n        1.  Validate input: If $s = 0$ or $k  1$ or $k  s$, return $-1$.\n        2.  Calculate the physical index: $\\text{idx} \\leftarrow (f + k - 1) \\pmod n$.\n        3.  Return the element at that index: $A[\\text{idx}]$.\n    - This operation consists of input validation, a few arithmetic operations, and a single array access. It is therefore an $O(1)$ operation, satisfying the problem's constraint.\n\nThis formal definition provides a complete and correct blueprint for the implementation of the specified circular queue data structure.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass CircularQueue:\n    \"\"\"\n    An implementation of a fixed-capacity circular queue using a NumPy array.\n    \n    The state of the queue is maintained by three variables:\n    - n: capacity of the queue\n    - f: index of the front element\n    - s: current number of elements in the queue\n    \n    Index arithmetic is performed using the modulo operator to achieve\n    circular behavior.\n    \"\"\"\n    def __init__(self, capacity: int):\n        \"\"\"\n        Initializes the circular queue.\n        \n        Args:\n            capacity (int): The maximum number of elements the queue can hold.\n        \"\"\"\n        self.n = capacity\n        # Using numpy.zeros with dtype=int gives a default value of 0.\n        # It's better to use an uninitialized array for performance or fill with a\n        # known non-data value like None or a sentinel, but integers are specified.\n        # We will use numpy.empty and rely on the logic to only access initialized parts.\n        self.data = np.empty(capacity, dtype=int)\n        self.f = 0\n        self.s = 0\n\n    def is_empty(self) -> bool:\n        \"\"\"Checks if the queue is empty.\"\"\"\n        return self.s == 0\n\n    def is_full(self) -> bool:\n        \"\"\"Checks if the queue is full.\"\"\"\n        return self.s == self.n\n\n    def size(self) -> int:\n        \"\"\"Returns the number of elements in the queue.\"\"\"\n        return self.s\n\n    def enqueue(self, value: int) -> bool:\n        \"\"\"\n        Adds an element to the rear of the queue.\n\n        Args:\n            value (int): The element to add.\n\n        Returns:\n            bool: True if the operation was successful, False if the queue was full.\n        \"\"\"\n        if self.is_full():\n            return False\n        \n        # The rear index is where the next element is to be placed.\n        # It's located at an offset of s from the front index f.\n        rear_idx = (self.f + self.s) % self.n\n        self.data[rear_idx] = value\n        self.s += 1\n        return True\n\n    def dequeue(self) -> int:\n        \"\"\"\n        Removes and returns the front element of the queue.\n\n        Returns:\n            int: The front element, or -1 if the queue is empty.\n        \"\"\"\n        if self.is_empty():\n            return -1\n        \n        value = self.data[self.f]\n        self.f = (self.f + 1) % self.n\n        self.s -= 1\n        return int(value) # Ensure return type is standard Python int\n\n    def peek_kth(self, k: int) -> int:\n        \"\"\"\n        Returns the k-th element from the front without removing it.\n\n        Args:\n            k (int): The 1-based index from the front.\n\n        Returns:\n            int: The k-th element, or -1 if k is invalid or the queue is empty.\n        \"\"\"\n        if self.is_empty() or k  1 or k > self.s:\n            return -1\n            \n        # The index of the k-th element is at an offset of (k-1) from the front.\n        idx = (self.f + k - 1) % self.n\n        return int(self.data[idx]) # Ensure return type is standard Python int\n\ndef solve():\n    \"\"\"\n    Executes the test suite for the CircularQueue implementation.\n    \"\"\"\n    test_cases = [\n        (8, [\"ENQ 10\", \"ENQ 20\", \"ENQ 30\", \"ENQ 40\", \"PEEK 1\", \"PEEK 2\", \"PEEK 4\", \"DEQ\", \"ENQ 50\", \"ENQ 60\", \"PEEK 3\"]),\n        (5, [\"ENQ 1\", \"ENQ 2\", \"ENQ 3\", \"DEQ\", \"DEQ\", \"ENQ 4\", \"ENQ 5\", \"ENQ 6\", \"PEEK 1\", \"PEEK 3\", \"PEEK 4\"]),\n        (4, [\"ENQ 7\", \"ENQ 8\", \"ENQ 9\", \"ENQ 10\", \"PEEK 1\", \"PEEK 4\", \"DEQ\", \"ENQ 11\", \"PEEK 4\"]),\n        (3, [\"ENQ 42\", \"PEEK 1\", \"PEEK 2\", \"PEEK 0\", \"DEQ\", \"PEEK 1\"]),\n        (6, [\"ENQ 100\", \"ENQ 200\", \"DEQ\", \"ENQ 300\", \"ENQ 400\", \"ENQ 500\", \"DEQ\", \"DEQ\", \"ENQ 600\", \"ENQ 700\", \"ENQ 800\", \"PEEK 1\", \"PEEK 2\", \"PEEK 5\"]),\n    ]\n\n    all_results = []\n\n    for capacity, operations in test_cases:\n        queue = CircularQueue(capacity)\n        case_results = []\n        for op in operations:\n            parts = op.split()\n            command = parts[0]\n            \n            if command == \"ENQ\":\n                value = int(parts[1])\n                queue.enqueue(value)\n            elif command == \"DEQ\":\n                queue.dequeue()\n            elif command == \"PEEK\":\n                k = int(parts[1])\n                result = queue.peek_kth(k)\n                case_results.append(result)\n        all_results.append(case_results)\n\n    # Format the final output string to match the problem specification\n    # e.g., [[10,20],[3,5,6]] with no spaces.\n    final_output_string = str(all_results).replace(\" \", \"\")\n    print(final_output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "Real-world systems often require more flexibility than a strict FIFO queue can offer. This practice  extends the circular queue concept to a double-ended queue (deque), which allows insertions at both the front and back. By modeling a call center with standard and priority customers, you will see how a simple modification to index management creates a more powerful data structure capable of handling differentiated service levels.",
            "id": "3208994",
            "problem": "Implement an array-backed queue that models a call center waiting line using a circular buffer and then modify it to support inserting \"priority customers\" at the front. The required operations are: enqueue at back for standard arrivals, enqueue at front for priority arrivals, and dequeue from front for service. The implementation must be array-based (no linked structures), maintain a circular layout, and automatically resize the underlying array by doubling its capacity when the array is full just before an insertion. The objective is to derive the correctness and complexity of these operations from the abstract definition of a queue and the properties of modular arithmetic over array indices, and to confirm behavior through a fixed test suite.\n\nUse the following fundamental base:\n- A queue is an abstract data type defined by First-In-First-Out (FIFO), meaning the item that has been in the queue the longest is served first.\n- An array supports constant-time random access by index.\n- Circular layout on an array uses modular arithmetic; if the head index is $h$, tail index is $t$, and capacity is $C$, then advancing by one position corresponds to adding $1$ modulo $C$. Specifically, $i \\mapsto (i+1) \\bmod C$.\n- Resizing an array by allocating a new array of size $2C$ and copying existing items in logical order $0,1,2,\\dots$ preserves item order and enables amortized constant time per insertion.\n\nYour task:\n- Design and implement an array-based queue with the following operations using a circular buffer with dynamic resizing:\n  - Standard arrival enqueue_back: append customer identifier $x$ at the back.\n  - Priority arrival enqueue_front: insert customer identifier $x$ at the front.\n  - Serve dequeue_front: remove and return the identifier at the front; if the queue is empty, no identifier is returned for that serve step.\n- Maintain indices $h$ (head), $t$ (tail), size $s$, and capacity $C$ such that the logical order of items is at positions $(h + k) \\bmod C$ for $k \\in \\{0,1,\\dots,s-1\\}$.\n- When inserting into a full buffer where $s = C$, first resize to capacity $2C$ by relocating the $s$ items to positions $0,1,\\dots,s-1$ in order, and then perform the pending insertion. Do not shrink the buffer.\n\nEvent model:\n- Each test case consists of an initial capacity $C$ and a sequence of events of three kinds:\n  - Standard arrival $A(x)$ meaning enqueue_back with identifier $x$.\n  - Priority arrival $P(x)$ meaning enqueue_front with identifier $x$.\n  - Serve $S(k)$ meaning perform dequeue_front up to $k$ times; if fewer than $k$ customers are available, serve as many as available. Collect the sequence of all served identifiers, in order, across all $S(\\cdot)$ events of the test case.\n\nRequired output:\n- For each test case, the program must output the list of served identifiers, in order, as a list of integers.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each result itself is a list, and lists must be printed without spaces, for example: $[[1,2],[3],[4,5,6]]$.\n\nTest suite:\n- Use exactly the following five test cases. Each test case is a pair $(C, \\text{events})$, where $C$ is the initial capacity and $\\text{events}$ is the finite sequence of events.\n  - Test $1$: $C = 4$, events $[A(1), A(2), A(3), S(2), A(4), P(99), S(3)]$.\n  - Test $2$: $C = 3$, events $[S(1), P(5), S(2), S(1)]$.\n  - Test $3$: $C = 5$, events $[A(10), A(11), A(12), A(13), S(3), A(14), A(15), A(16), P(7), S(4)]$.\n  - Test $4$: $C = 2$, events $[A(1), A(2), P(3), A(4), A(5), S(5)]$.\n  - Test $5$: $C = 4$, events $[P(1), P(2), P(3), A(4), A(5), S(5)]$.\n\nNotes and constraints:\n- All customer identifiers and $k$ values are nonnegative integers.\n- Correctness must follow from the abstract definition of a queue and the semantics of the additional priority operation, with indices updated via modular arithmetic. Ensure that enqueue_front and enqueue_back both run in $\\mathcal{O}(1)$ time in the absence of resizing and that resizing yields amortized $\\mathcal{O}(1)$ time per insertion over any sequence of $n$ insertions.\n- The program must be fully self-contained and produce the required single-line output with no user input and no external files.",
            "solution": "The problem statement is valid. It presents a well-defined task in the domain of data structures and algorithms, grounded in established computer science principles. The problem is self-contained, objective, and its requirements are internally consistent and formalizable.\n\nThe core task is to implement a double-ended queue (deque) using a circular array that supports dynamic resizing. The deque must provide three operations: `enqueue_back` (standard append), `enqueue_front` (priority prepend), and `dequeue_front` (serve). The solution must be validated against a specific test suite.\n\nThe implementation will be encapsulated within a class, which we can name `CircularDeque`. This class will manage the state of the queue through four primary attributes:\n- An underlying `numpy` array, `data`, which stores the queue elements.\n- The capacity of this array, $C$, which we will call `capacity`.\n- The index of the first element in the queue, $h$, which we will call `head`.\n- The number of elements currently in the queue, $s$, which we will call `size`.\n\nAn empty queue is defined by $s=0$. A full queue is defined by $s=C$. The problem statement also mentions a tail index $t$. This index is not an independent state variable but can be derived from the others. It points to the first available slot at the back of the queue and is given by $t = (h+s) \\pmod C$. We will use $h$ and $s$ as the canonical state variables for managing the queue's structure.\n\nThe logical sequence of elements in the queue, indexed from $0$ to $s-1$, is mapped to the physical array indices using modular arithmetic. The $k$-th logical element (where $k \\in \\{0, 1, \\dots, s-1\\}$) is stored at the physical index $(h+k) \\pmod C$.\n\nLet us detail the design of each required operation.\n\n**1. Initialization `__init__(self, capacity)`**\nThis constructor initializes an empty queue with a given initial capacity $C$.\n- The `capacity` is set to the provided value.\n- The `data` array is created as a `numpy` array of size $C$, initialized to zeros.\n- The `head` index $h$ is initialized to $0$.\n- The `size` $s$ is initialized to $0$.\n\n**2. `enqueue_back(self, x)`**\nThis operation adds an element $x$ to the rear of the queue.\n- First, it checks if the queue is full ($s=C$). If so, it must resize the underlying array by calling a helper method, `_resize()`.\n- The physical index for the new element is the tail position, calculated as $t = (h+s) \\pmod C$.\n- The element $x$ is placed at `data[t]`.\n- The size of the queue, $s$, is incremented by $1$.\nThis operation has a time complexity of $\\mathcal{O}(1)$ when no resizing occurs.\n\n**3. `enqueue_front(self, x)`**\nThis operation adds a priority element $x$ to the front of the queue.\n- Similar to `enqueue_back`, it first checks for and handles overflow by calling `_resize()` if $s=C$.\n- To insert at the front, the `head` index $h$ must be moved one position backward (circularly). The new head index is calculated as $h' = (h - 1 + C) \\pmod C$.\n- The `head` is updated to $h'$.\n- The new element $x$ is placed at `data[h']`.\n- The size of the queue, $s$, is incremented by $1$.\nThis operation also has a time complexity of $\\mathcal{O}(1)$ when no resizing occurs.\n\n**4. `dequeue_front(self)`**\nThis operation removes and returns the element at the front of the queue.\n- It first checks if the queue is empty ($s=0$). If so, it returns an indicator (e.g., `None`) signifying that no element was served, as per the problem description.\n- If the queue is not empty, the element to be returned is `data[h]`.\n- The `head` index is advanced one position forward (circularly): $h' = (h+1) \\pmod C$.\n- The `head` is updated to $h'$.\n- The size of the queue, $s$, is decremented by $1$.\n- The retrieved element is returned.\nThis operation is always $\\mathcal{O}(1)$.\n\n**5. Resizing `_resize(self)`**\nThis helper method is invoked by the enqueue operations when $s=C$.\n- A new capacity $C_{new}$ is set to $2C$.\n- A new `numpy` array, `new_data`, is allocated with capacity $C_{new}$.\n- The crucial step is copying the elements from the old array to the new one. The problem specifies that elements should be relocated to occupy indices $0, 1, \\dots, s-1$ in the new array. This process \"unrolls\" the circular buffer. For each logical element $k$ from $0$ to $s-1$:\n    - Its index in the old array is $i_{old} = (h+k) \\pmod C$.\n    - The element `data[i_old]` is copied to `new_data[k]`.\n- After the copy is complete, the `data` array is replaced with `new_data`, and the `capacity` is updated to $C_{new}$.\n- Because the elements are now at the start of the new array in their logical order, the `head` index $h$ is reset to $0$. The `size` $s$ remains unchanged by the resize operation itself.\n\n**Correctness and Complexity Analysis**\nThe correctness of this design is rooted in the consistent application of modular arithmetic for all index calculations, which correctly implements the circular nature of the buffer. The resizing procedure, by explicitly unrolling the elements into a linear sequence at the start of the new, larger array, correctly preserves the FIFO order and simplifies the state by resetting $h$ to $0$.\n\nThe complexity meets the problem's requirements. In the absence of resizing, both `enqueue_front` and `enqueue_back` perform a constant number of arithmetic operations and a single array access, making them $\\mathcal{O}(1)$. The `dequeue_front` operation is always $\\mathcal{O}(1)$. The `_resize` operation takes $\\mathcal{O}(C)$ time, where $C$ is the current capacity. According to standard amortized analysis for dynamic arrays that grow geometrically, this $\\mathcal{O}(C)$ cost is distributed over the next $C$ insertions (in this case, doubling capacity from $C$ to $2C$ allows for at least $C$ new insertions). This yields an amortized time complexity of $\\mathcal{O}(1)$ per insertion operation over a long sequence of operations.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass CircularDeque:\n    \"\"\"\n    An array-backed queue (deque) implemented with a circular buffer\n    and dynamic resizing.\n    \"\"\"\n    def __init__(self, capacity):\n        \"\"\"\n        Initializes the deque with a given capacity.\n        \"\"\"\n        if capacity  1:\n            raise ValueError(\"Capacity must be at least 1\")\n        self.capacity = capacity\n        # Using a numpy array of a specific dtype as required.\n        # Initializing with 0s is fine as we track size separately.\n        self.data = np.zeros(self.capacity, dtype=int)\n        self.head = 0  # Index of the front element\n        self.size = 0  # Number of elements in the deque\n\n    def _resize(self):\n        \"\"\"\n        Doubles the capacity of the deque when it is full.\n        The elements are unrolled into the new array starting from index 0.\n        \"\"\"\n        old_capacity = self.capacity\n        self.capacity *= 2\n        new_data = np.zeros(self.capacity, dtype=int)\n        \n        # Unroll the circular buffer into a linear layout in the new array\n        for k in range(self.size):\n            old_index = (self.head + k) % old_capacity\n            new_data[k] = self.data[old_index]\n        \n        self.data = new_data\n        self.head = 0\n\n    def enqueue_back(self, value):\n        \"\"\"\n        Adds an element to the back of the deque.\n        \"\"\"\n        if self.size == self.capacity:\n            self._resize()\n        \n        # Calculate the index for the new element at the tail\n        tail_index = (self.head + self.size) % self.capacity\n        self.data[tail_index] = value\n        self.size += 1\n\n    def enqueue_front(self, value):\n        \"\"\"\n        Adds an element to the front of the deque.\n        \"\"\"\n        if self.size == self.capacity:\n            self._resize()\n            \n        # Move head one step backwards (circularly)\n        self.head = (self.head - 1 + self.capacity) % self.capacity\n        self.data[self.head] = value\n        self.size += 1\n\n    def dequeue_front(self):\n        \"\"\"\n        Removes and returns the element from the front of the deque.\n        Returns None if the deque is empty.\n        \"\"\"\n        if self.size == 0:\n            return None\n        \n        value = self.data[self.head]\n        # Advance head one step forward (circularly)\n        self.head = (self.head + 1) % self.capacity\n        self.size -= 1\n        return value\n\ndef solve():\n    \"\"\"\n    Runs the full test suite as defined in the problem statement.\n    \"\"\"\n    # Test suite definition: (Initial Capacity, [Events])\n    # Events are tuples: ('A', value), ('P', value), ('S', count)\n    test_cases = [\n        (4, [('A', 1), ('A', 2), ('A', 3), ('S', 2), ('A', 4), ('P', 99), ('S', 3)]),\n        (3, [('S', 1), ('P', 5), ('S', 2), ('S', 1)]),\n        (5, [('A', 10), ('A', 11), ('A', 12), ('A', 13), ('S', 3), ('A', 14), ('A', 15), ('A', 16), ('P', 7), ('S', 4)]),\n        (2, [('A', 1), ('A', 2), ('P', 3), ('A', 4), ('A', 5), ('S', 5)]),\n        (4, [('P', 1), ('P', 2), ('P', 3), ('A', 4), ('A', 5), ('S', 5)]),\n    ]\n\n    all_results = []\n\n    for capacity, events in test_cases:\n        queue = CircularDeque(capacity)\n        served_identifiers = []\n        \n        for event_type, value in events:\n            if event_type == 'A':\n                queue.enqueue_back(value)\n            elif event_type == 'P':\n                queue.enqueue_front(value)\n            elif event_type == 'S':\n                for _ in range(value):\n                    served = queue.dequeue_front()\n                    if served is not None:\n                        served_identifiers.append(served)\n        \n        all_results.append(served_identifiers)\n\n    # Format the final output string as per the problem requirements.\n    # e.g., [[1,2,99,3,4],[5],[10,11,12,7,13,14,15],[3,1,2,4,5],[3,2,1,4,5]]\n    result_strings = []\n    for res_list in all_results:\n        # Create string for each inner list, e.g., \"[1,2,3]\"\n        list_str = f\"[{','.join(map(str, res_list))}]\"\n        result_strings.append(list_str)\n    \n    # Join all list strings into the final output format\n    final_output = f\"[{','.join(result_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```"
        }
    ]
}