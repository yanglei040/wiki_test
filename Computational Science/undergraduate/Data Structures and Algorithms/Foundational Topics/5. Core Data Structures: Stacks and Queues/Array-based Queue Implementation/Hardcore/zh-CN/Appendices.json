{
    "hands_on_practices": [
        {
            "introduction": "我们的动手实践将从构建一个基础数据结构——固定容量的循环队列——开始。这项练习将聚焦于其核心机制，特别是如何利用模运算在标准数组中实现“环绕”效果。此练习的关键挑战在于实现一个高效的 $\\text{peek\\_kth}$ 函数 ()，这将巩固你对循环缓冲区中索引映射的理解。",
            "id": "3209065",
            "problem": "要求您实现一个基于数组的循环队列，作为队列抽象数据类型（ADT）的一个具体实现，并特别强调实现一个高效的 $\\text{peek\\_kth}(k)$ 操作。队列 ADT 遵循先进先出（FIFO）语义，即第一个入队的元素将是第一个出队的元素。所需的实现必须使用一个固定容量的数组，并通过模运算进行索引计算来模拟循环缓冲区。所有操作必须以纯数学和逻辑术语定义，独立于任何特定的编程语言。\n\n使用的基本假设和定义：\n- 队列是一种集合，在 FIFO 语义下支持 $\\text{enqueue}(x)$、$\\text{dequeue}()$ 以及如 $\\text{front}()$ 和 $\\text{rear}()$ 等只读操作。\n- 容量为 $n$ 的数组支持对任何有效索引 $i$ 的元素 $A[i]$ 进行常数时间访问。\n- 循环性通过在整数模 $n$ 环（记作 $\\mathbb{Z}_n$）中执行索引算术来建模。\n- 队列维护三个整数状态变量：容量 $n$、队头索引 $f$ 和当前大小 $s$。队尾索引 $r$ 是隐式维护的，其中 $r$ 是执行 $\\text{enqueue}$ 操作时下一个元素要放置的位置。\n- 所有操作的运行时间必须为 $O(1)$。\n\n您的任务：\n- 实现一个基于数组的循环队列，包含操作 $\\text{enqueue}(x)$、$\\text{dequeue}()$、$\\text{is\\_empty}()$、$\\text{is\\_full}()$、$\\text{size}()$，以及至关重要的 $\\text{peek\\_kth}(k)$，该操作返回从队头数起的第 $k^{\\text{th}}$ 个元素而不移除它。\n- 操作 $\\text{peek\\_kth}(k)$ 的运行时间必须为 $O(1)$，且仅使用索引算术和数组访问。请根据上述基本原理（数组索引和在 $\\mathbb{Z}_n$ 上的模运算），推导出第 $k^{\\text{th}}$ 个元素的正确索引映射，并据此实现。\n- 错误处理：如果 $k  1$ 或 $k  s$，或队列为空（$s = 0$），$\\text{peek\\_kth}(k)$ 必须返回哨兵值 $-1$。\n- 有效性约束：对满队列执行 $\\text{enqueue}(x)$ 不应改变队列状态，并应返回一个布尔指示符；对空队列执行 $\\text{dequeue}()$ 应返回哨兵值 $-1$。\n- 所有索引和大小均为整数，测试套件中的所有队列元素也均为整数。\n\n测试套件：\n对于每个测试用例，参数为一个容量 $n$ 和一个操作序列。每个操作是 $\\text{ENQ } v$、$\\text{DEQ}$ 或 $\\text{PEEK } k$ 之一，其中 $v$ 和 $k$ 是整数。一个测试用例所需的输出是按顺序执行操作序列时遇到的每个 $\\text{PEEK } k$ 操作返回的整数。以下测试用例必须按顺序执行：\n\n- 测试用例 $1$ (通用正常路径)：\n  - 容量 $n = 8$。\n  - 操作：\n    - $\\text{ENQ } 10$, $\\text{ENQ } 20$, $\\text{ENQ } 30$, $\\text{ENQ } 40$, $\\text{PEEK } 1$, $\\text{PEEK } 2$, $\\text{PEEK } 4$, $\\text{DEQ}$, $\\text{ENQ } 50$, $\\text{ENQ } 60$, $\\text{PEEK } 3$。\n  - 预期输出序列：一个整数列表，对应四个 $\\text{PEEK}$ 操作的结果。\n\n- 测试用例 $2$ (未满容量时的环绕)：\n  - 容量 $n = 5$。\n  - 操作：\n    - $\\text{ENQ } 1$, $\\text{ENQ } 2$, $\\text{ENQ } 3$, $\\text{DEQ}$, $\\text{DEQ}$, $\\text{ENQ } 4$, $\\text{ENQ } 5$, $\\text{ENQ } 6$, $\\text{PEEK } 1$, $\\text{PEEK } 3$, $\\text{PEEK } 4$。\n\n- 测试用例 $3$ (满队列与边界 $k$ 值)：\n  - 容量 $n = 4$。\n  - 操作：\n    - $\\text{ENQ } 7$, $\\text{ENQ } 8$, $\\text{ENQ } 9$, $\\text{ENQ } 10$, $\\text{PEEK } 1$, $\\text{PEEK } 4$, $\\text{DEQ}$, $\\text{ENQ } 11$, $\\text{PEEK } 4$。\n\n- 测试用例 $4$ (单个元素与无效 $k$ 值)：\n  - 容量 $n = 3$。\n  - 操作：\n    - $\\text{ENQ } 42$, $\\text{PEEK } 1$, $\\text{PEEK } 2$, $\\text{PEEK } 0$, $\\text{DEQ}$, $\\text{PEEK } 1$。\n\n- 测试用例 $5$ (入队和出队交替及环绕)：\n  - 容量 $n = 6$。\n  - 操作：\n    - $\\text{ENQ } 100$, $\\text{ENQ } 200$, $\\text{DEQ}$, $\\text{ENQ } 300$, $\\text{ENQ } 400$, $\\text{ENQ } 500$, $\\text{DEQ}$, $\\text{DEQ}$, $\\text{ENQ } 600$, $\\text{ENQ } 700$, $\\text{ENQ } 800$, $\\text{PEEK } 1$, $\\text{PEEK } 2$, $\\text{PEEK } 5$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含所有测试用例的结果，格式为方括号括起来的、由逗号分隔的列表的列表，例如 $[[a_1,a_2],[b_1],[c_1,c_2,c_3]]$。每个内部列表按顺序包含该测试用例中 $\\text{PEEK}$ 操作返回的整数。",
            "solution": "所提出的问题是有效的，因为它基于数据结构的科学原理，提法恰当、客观且内部一致。它在实现带有高效 `peek_kth` 操作的循环队列方面，提出了一个标准但具有一定挑战性的任务。\n\n我们将通过形式化数学术语定义其状态和操作来构建基于数组的循环队列。该实现将基于一个固定容量的数组，其索引通过模运算进行管理。\n\n循环队列由以下状态变量定义：\n- $n \\in \\mathbb{Z}^+$: 队列的固定容量。\n- $A$: 一个大小为 $n$ 的数组，索引范围为 $\\{0, 1, \\dots, n-1\\}$。\n- $f \\in \\{0, 1, \\dots, n-1\\}$: 队列的队头（第一个）元素在数组 $A$ 中的索引。\n- $s \\in \\{0, 1, \\dots, n\\}$: 队列中当前的元素数量。\n\n从这些状态变量中，我们可以推导出其他属性。数组 $A$ 中被占用的索引集合代表队列中的元素。这些元素位于索引 $(f+i) \\pmod n$ 处，其中 $i \\in \\{0, 1, \\dots, s-1\\}$。队尾索引 $r$，即下一次入队操作的位置，由 $r = (f + s) \\pmod n$ 隐式给出。所有索引上的算术运算都在整数模 $n$ 环（记作 $\\mathbb{Z}_n$）中进行。所有操作都设计为具有 $O(1)$ 的时间复杂度。\n\n操作定义如下：\n\n1.  $\\text{size}()$: 此操作返回队列中当前的元素数量。\n    - 输出: $s$。\n    - 这是一个 $O(1)$ 操作，因为它直接读取状态变量 $s$。\n\n2.  $\\text{is\\_empty}()$: 此操作检查队列中是否包含任何元素。\n    - 输出: 一个布尔值，如果 $s = 0$ 则为 true，否则为 false。\n    - 这是一个 $O(1)$ 操作，仅涉及一次比较。\n\n3.  $\\text{is\\_full}()$: 此操作检查队列是否已达到其容量。\n    - 输出: 一个布尔值，如果 $s = n$ 则为 true，否则为 false。\n    - 这是一个 $O(1)$ 操作，仅涉及一次比较。\n\n4.  $\\text{enqueue}(x)$: 此操作将元素 $x$ 添加到队尾。\n    - 前置条件：队列不能为满，即 $s  n$。\n    - 如果 $\\text{is\\_full}()$ 为 true，则操作失败，队列状态保持不变，并返回一个 'false' 指示符。\n    - 如果队列未满，则执行以下步骤：\n        1.  确定用于插入的队尾索引：$r \\leftarrow (f + s) \\pmod n$。\n        2.  存储元素：$A[r] \\leftarrow x$。\n        3.  增加大小：$s \\leftarrow s + 1$。\n        4.  返回一个 'true' 指示符。\n    - 此操作涉及几次算术计算和一次数组写入，因此时间复杂度为 $O(1)$。\n\n5.  $\\text{dequeue}()$: 此操作移除并返回队头的元素。\n    - 前置条件：队列不能为空，即 $s > 0$。\n    - 如果 $\\text{is\\_empty}()$ 为 true，则操作失败，并返回哨兵值 $-1$。\n    - 如果队列不为空，则执行以下步骤：\n        1.  检索队头元素：$v \\leftarrow A[f]$。\n        2.  更新队头索引：$f \\leftarrow (f + 1) \\pmod n$。\n        3.  减小大小：$s \\leftarrow s - 1$。\n        4.  返回检索到的值 $v$。\n    - 此操作涉及一次数组读取和几次算术计算，因此时间复杂度为 $O(1)$。\n\n6.  $\\text{peek\\_kth}(k)$: 这是一个关键操作，它返回从队头数起的第 $k^{\\text{th}}$ 个元素，但不移除它。参数 $k$ 是从1开始计数的，意味着 $k=1$ 指的是队头元素。\n    - 错误条件：如果队列为空（$s=0$）或 $k$ 超出范围（即 $k  1$ 或 $k > s$），该操作必须返回哨兵值 $-1$。\n    - 索引的推导：\n        - 第一个元素（$k=1$）位于索引 $f$ 处，可写作 $(f + 1 - 1) \\pmod n$。\n        - 第二个元素（$k=2$）位于索引 $(f+1) \\pmod n$ 处，可写作 $(f + 2 - 1) \\pmod n$。\n        - 通过归纳法，队列逻辑序列中的第 $i^{\\text{th}}$ 个元素位于物理数组索引处，该索引相对于队头索引 $f$ 有 $i-1$ 的偏移量，并考虑环绕。\n        - 因此，第 $k^{\\text{th}}$ 个元素的物理索引 `idx` 由以下公式给出：\n          $$ \\text{idx} = (f + k - 1) \\pmod n $$\n    - 算法：\n        1.  验证输入：如果 $s = 0$ 或 $k  1$ 或 $k > s$，返回 $-1$。\n        2.  计算物理索引：$\\text{idx} \\leftarrow (f + k - 1) \\pmod n$。\n        3.  返回该索引处的元素：$A[\\text{idx}]$。\n    - 此操作包括输入验证、几次算术运算和单次数组访问。因此，它是一个 $O(1)$ 操作，满足了问题的约束。\n\n这个形式化定义为实现指定的循环队列数据结构提供了一个完整且正确的蓝图。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass CircularQueue:\n    \"\"\"\n    An implementation of a fixed-capacity circular queue using a NumPy array.\n    \n    The state of the queue is maintained by three variables:\n    - n: capacity of the queue\n    - f: index of the front element\n    - s: current number of elements in the queue\n    \n    Index arithmetic is performed using the modulo operator to achieve\n    circular behavior.\n    \"\"\"\n    def __init__(self, capacity: int):\n        \"\"\"\n        Initializes the circular queue.\n        \n        Args:\n            capacity (int): The maximum number of elements the queue can hold.\n        \"\"\"\n        self.n = capacity\n        # Using numpy.zeros with dtype=int gives a default value of 0.\n        # It's better to use an uninitialized array for performance or fill with a\n        # known non-data value like None or a sentinel, but integers are specified.\n        # We will use numpy.empty and rely on the logic to only access initialized parts.\n        self.data = np.empty(capacity, dtype=int)\n        self.f = 0\n        self.s = 0\n\n    def is_empty(self) - bool:\n        \"\"\"Checks if the queue is empty.\"\"\"\n        return self.s == 0\n\n    def is_full(self) - bool:\n        \"\"\"Checks if the queue is full.\"\"\"\n        return self.s == self.n\n\n    def size(self) - int:\n        \"\"\"Returns the number of elements in the queue.\"\"\"\n        return self.s\n\n    def enqueue(self, value: int) - bool:\n        \"\"\"\n        Adds an element to the rear of the queue.\n\n        Args:\n            value (int): The element to add.\n\n        Returns:\n            bool: True if the operation was successful, False if the queue was full.\n        \"\"\"\n        if self.is_full():\n            return False\n        \n        # The rear index is where the next element is to be placed.\n        # It's located at an offset of s from the front index f.\n        rear_idx = (self.f + self.s) % self.n\n        self.data[rear_idx] = value\n        self.s += 1\n        return True\n\n    def dequeue(self) - int:\n        \"\"\"\n        Removes and returns the front element of the queue.\n\n        Returns:\n            int: The front element, or -1 if the queue is empty.\n        \"\"\"\n        if self.is_empty():\n            return -1\n        \n        value = self.data[self.f]\n        self.f = (self.f + 1) % self.n\n        self.s -= 1\n        return int(value) # Ensure return type is standard Python int\n\n    def peek_kth(self, k: int) - int:\n        \"\"\"\n        Returns the k-th element from the front without removing it.\n\n        Args:\n            k (int): The 1-based index from the front.\n\n        Returns:\n            int: The k-th element, or -1 if k is invalid or the queue is empty.\n        \"\"\"\n        if self.is_empty() or k  1 or k  self.s:\n            return -1\n            \n        # The index of the k-th element is at an offset of (k-1) from the front.\n        idx = (self.f + k - 1) % self.n\n        return int(self.data[idx]) # Ensure return type is standard Python int\n\ndef solve():\n    \"\"\"\n    Executes the test suite for the CircularQueue implementation.\n    \"\"\"\n    test_cases = [\n        (8, [\"ENQ 10\", \"ENQ 20\", \"ENQ 30\", \"ENQ 40\", \"PEEK 1\", \"PEEK 2\", \"PEEK 4\", \"DEQ\", \"ENQ 50\", \"ENQ 60\", \"PEEK 3\"]),\n        (5, [\"ENQ 1\", \"ENQ 2\", \"ENQ 3\", \"DEQ\", \"DEQ\", \"ENQ 4\", \"ENQ 5\", \"ENQ 6\", \"PEEK 1\", \"PEEK 3\", \"PEEK 4\"]),\n        (4, [\"ENQ 7\", \"ENQ 8\", \"ENQ 9\", \"ENQ 10\", \"PEEK 1\", \"PEEK 4\", \"DEQ\", \"ENQ 11\", \"PEEK 4\"]),\n        (3, [\"ENQ 42\", \"PEEK 1\", \"PEEK 2\", \"PEEK 0\", \"DEQ\", \"PEEK 1\"]),\n        (6, [\"ENQ 100\", \"ENQ 200\", \"DEQ\", \"ENQ 300\", \"ENQ 400\", \"ENQ 500\", \"DEQ\", \"DEQ\", \"ENQ 600\", \"ENQ 700\", \"ENQ 800\", \"PEEK 1\", \"PEEK 2\", \"PEEK 5\"]),\n    ]\n\n    all_results = []\n\n    for capacity, operations in test_cases:\n        queue = CircularQueue(capacity)\n        case_results = []\n        for op in operations:\n            parts = op.split()\n            command = parts[0]\n            \n            if command == \"ENQ\":\n                value = int(parts[1])\n                queue.enqueue(value)\n            elif command == \"DEQ\":\n                queue.dequeue()\n            elif command == \"PEEK\":\n                k = int(parts[1])\n                result = queue.peek_kth(k)\n                case_results.append(result)\n        all_results.append(case_results)\n\n    # Format the final output string to match the problem specification\n    # e.g., [[10,20],[3,5,6]] with no spaces.\n    final_output_string = str(all_results).replace(\" \", \"\")\n    print(final_output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "现实世界的应用通常需要能够适应数据量变化的数据结构。在本次实践中，我们将把固定容量的队列升级为动态可调整大小的循环队列 ()。你将实现当队列满时自动扩容和当队列元素稀疏时自动缩容的逻辑，学习这些操作如何保持数据完整性并实现高效的摊销性能。",
            "id": "3209149",
            "problem": "设计并实现一个先进先出的队列，该队列使用一个可调整大小的循环数组，能够存储任何数据类型的元素。设计的核心必须遵循队列的基本定义和数组索引的模运算。具体来说，使用以下基本原理：队列是一种强制执行先进先出顺序的抽象数据类型，而循环缓冲区的索引通过将索引 $i$ 替换为 $(i+1) \\bmod C$ 来推进，其中 $C$ 是底层数组的当前容量。\n\n实现要求：\n- 维护一个当前容量为 $C$ 的数组、一个头索引 $h$、一个尾索引 $t$ 和一个大小 $s$（元素数量）。头索引 $h$ 指向队列逻辑前端的位置，尾索引 $t$ 指向下一个元素将被插入的位置。\n- 入队操作：在插入新元素之前，如果 $s = C$，则分配一个容量为 $2C$ 的新数组，并从索引 0 开始按逻辑顺序复制当前的 $s$ 个元素。复制后，设置 $h \\leftarrow 0$ 和 $t \\leftarrow s$，然后将新元素插入索引 $t$ 处，推进 $t \\leftarrow (t+1) \\bmod C$，并增加大小 $s \\leftarrow s+1$。\n- 出队操作：移除并返回索引 $h$ 处的前端元素，清空该位置，推进 $h \\leftarrow (h+1) \\bmod C$，并减小大小 $s \\leftarrow s-1$。移除后，如果 $s \\le \\lfloor C/4 \\rfloor$ 且 $C$ 严格大于初始容量 $C_0$，则分配一个容量为 $\\max(C_0,\\lfloor C/2 \\rfloor)$ 的新数组，从索引 0 开始按逻辑顺序复制 $s$ 个元素，并设置 $h \\leftarrow 0$， $t \\leftarrow s$。\n- 绝不将容量缩小到初始容量 $C_0$ 以下。假设没有任何操作会尝试从空队列中出队或查看元素。\n- 实现必须是逻辑上通用的：它必须保留任意元素的顺序，并且不能依赖于特定数据类型的操作。在静态类型语言中，这自然通过模板或泛型实现；在动态类型语言中，通过不限制元素类型来达到相同的行为。\n\n正确性要求：\n- 维护不变量：在任何有限的操作序列之后，队列的逻辑内容恰好是已入队但尚未出队的元素序列，且顺序相同；头索引 $h$ 始终指示当前前端的位置（当 $s  0$ 时）；尾索引 $t$ 始终指示最后一个元素之后的位置。所有操作在发生大小调整时的最坏情况时间复杂度必须为 $O(C)$，否则为 $O(1)$，在任何 $m$ 个操作序列上的均摊时间复杂度为 $O(1)$。\n\n您的程序必须实现此队列并运行以下测试套件。对于每个测试，计算指定的整数或浮点数结果。\n\n测试用例 A（整数的环绕和增长）：\n- 参数：初始容量 $C_0 = 4$。\n- 操作顺序：入队 $10$，入队 $20$，入队 $30$，出队，出队，入队 $40$，入队 $50$，入队 $60$，入队 $70$。\n- 此测试要求的结果：一个列表 $[s, C, f, S_{\\text{dq}}]$，其中 $s$ 是最终大小，$C$ 是最终容量，$f$ 是最终的前端元素，$S_{\\text{dq}}$ 是此测试中所有出队值的总和。\n\n测试用例 B（整数的增长后收缩）：\n- 参数：初始容量 $C_0 = 2$。\n- 操作顺序：将整数 $0,1,2,\\dots,15$（含）入队，然后执行恰好 $13$ 次出队操作。\n- 此测试要求的结果：一个如上所述的列表 $[s, C, f, S_{\\text{dq}}]$，其中 $f$ 是最后一次出队后的当前前端元素，$S_{\\text{dq}}$ 是所有出队整数的总和。\n\n测试用例 C（字符串的增长和收缩；按长度聚合）：\n- 参数：初始容量 $C_0 = 3$。\n- 操作顺序：将字符串 \"x\", \"yy\", \"zzz\", \"wwww\" 入队，然后出队两次，然后入队 \"vv\"，然后入队 \"u\"，然后重复出队直到队列为空。\n- 此测试要求的结果：一个列表 $[s, C, L]$，其中 $s$ 是最终大小，$C$ 是最终容量，$L$ 是此测试期间所有出队字符串的长度总和。\n\n测试用例 D（浮点数的环绕，无增长）：\n- 参数：初始容量 $C_0 = 5$。\n- 操作顺序：入队 $1.5$，入队 $2.5$，入队 $3.5$，出队一次，入队 $4.5$，入队 $5.5$，出队两次，入队 $6.5$，入队 $7.5$，入队 $8.5$。\n- 此测试要求的结果：一个列表 $[s, C, f, S_{\\text{dq}}]$，其中 $s$ 是最终大小，$C$ 是最终容量，$f$ 是最终的前端元素，$S_{\\text{dq}}$ 是所有出队值的总和（作为浮点数）。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的、逗号分隔的列表。每个测试结果本身必须显示为由方括号括起来的、逗号分隔的列表。例如，整体形式必须为 $[[\\cdots],[\\cdots],[\\cdots],[\\cdots]]$，不含任何额外文本。此问题不涉及物理单位、角度或百分比。",
            "solution": "问题要求使用可调整大小的循环数组来设计和实现一个先进先出（FIFO）队列。该设计必须源于数据结构和模运算的基本原理。\n\n### 基于原则的设计\n\n**1. 队列抽象数据类型（ADT）**\n队列是一种通过其行为定义的抽象数据类型：它存储一个元素集合，并强制执行先进先出（FIFO）的访问策略。元素通过 `enqueue` 操作添加到一个末端（“队尾”或“后端”），并通过 `dequeue` 操作从另一端（“队首”或“前端”）移除。这种严格的顺序是指导设计的核心原则。\n\n**2. 基于数组的实现和循环索引**\n可以使用一个简单的数组来存储队列的元素。一种简单的实现方式可能是在每次 `dequeue` 操作时将所有元素向左移动一个位置，以保持队首在索引 $0$ 处。然而，这会导致 `dequeue` 的时间复杂度为 $O(s)$（其中 $s$ 是元素数量），效率低下。\n\n为实现常数时间 $O(1)$ 的操作，我们将数组视为一个循环缓冲区。这通过使用模运算来实现。我们维护两个索引：一个指向第一个逻辑元素的头索引 $h$，以及一个指向下一个可用位置的尾索引 $t$。当索引前进超过数组末尾（容量为 $C-1$）时，它会“环绕”到开头（$0$）。这在数学上表示为将索引 $i$ 推进到 $(i+1) \\bmod C$。通过这种方案，`enqueue` 和 `dequeue` 操作仅涉及更新 $h$ 或 $t$ 索引，从而达到 $O(1)$ 的时间复杂度。为了区分满队列和空队列（这两种情况都可能在 $h=t$ 时发生），我们明确地维护一个大小计数器 $s$。`enqueue` 操作会增加 $s$，而 `dequeue` 操作会减少 $s$。如果 $s=0$，队列为空；如果 $s=C$，队列为满。\n\n**3. 动态调整大小和均摊分析**\n固定容量的数组是有限制的。为了支持任意数量的元素，底层数组必须是可调整大小的。所指定的策略是一种常见且高效的策略：\n- **增长（当 `enqueue` 时 $s=C$）：** 容量加倍（$C \\to 2C$）。分配一个新的、更大的数组。将旧数组中可能已环绕的现有 $s$ 个元素按其逻辑顺序复制到新数组中，从索引 $0$ 开始。然后将头尾索引重置为 $h \\leftarrow 0$ 和 $t \\leftarrow s$。\n- **收缩（当 `dequeue` 时 $s \\le \\lfloor C/4 \\rfloor$）：** 为节省内存，如果数组的占用率降至其容量的四分之一或更少，则数组会收缩。容量减半（$C \\to \\lfloor C/2 \\rfloor$），但有约束条件，即容量永远不会低于初始容量 $C_0$。复制和索引重置过程与增长时相同。\n\n虽然触发调整大小的单个 `enqueue` 或 `dequeue` 操作需要与当前容量成正比的时间，即 $O(C)$，但这些事件并不频繁。调整大小的成本被均摊到操作序列中。在增长到容量 $2C$ 后，至少需要再进行 $C$ 次 `enqueue` 操作才会发生下一次增长。类似地，在收缩到容量 $C/2$ 后，至少需要 $C/4$ 次 `dequeue` 操作才能触发另一次收缩。这确保了 $m$ 次操作的总工作量与 $m$ 成正比，从而使每次操作的均摊时间复杂度为 $O(1)$。\n\n**4. 实现结构**\n实现将此逻辑封装在一个类中。该类维护状态变量：数据数组、当前容量 $C$、初始容量 $C_0$、头索引 $h$、尾索引 $t$ 和大小 $s$。\n在调整大小时复制元素的方法（`_resize`）至关重要。它必须按照逻辑上的 FIFO 顺序遍历元素，从旧数组中的物理索引 $h$ 开始，并使用模运算符进行环绕，然后将它们放入新数组的前 $s$ 个位置。具体来说，第 $k$ 个逻辑元素（其中 $k \\in \\{0, 1, \\dots, s-1\\}$）位于物理索引 $(h+k) \\bmod C_{\\text{old}}$ 处，并被复制到新数组的索引 $k$ 处。\n\n这种设计在逻辑上是通用的，因为它除了存储和检索之外，不对元素本身执行任何操作。因此，它按要求保留了任何数据类型元素的完整性和顺序。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and tests the ResizableCircularQueue as per the problem statement.\n    \"\"\"\n\n    class ResizableCircularQueue:\n        \"\"\"\n        A FIFO queue implemented with a resizable, circular numpy array.\n        \"\"\"\n        def __init__(self, initial_capacity: int):\n            \"\"\"\n            Initializes an empty queue with a given initial capacity.\n            \"\"\"\n            if initial_capacity  1:\n                raise ValueError(\"Initial capacity must be at least 1.\")\n            self._C0 = initial_capacity\n            self._C = self._C0\n            # dtype=object allows storing elements of any type.\n            self._data = np.full(self._C, None, dtype=object)\n            self._h = 0  # Head index (points to the front element)\n            self._t = 0  # Tail index (points to the next available slot)\n            self._s = 0  # Number of elements in the queue\n\n        @property\n        def size(self) - int:\n            \"\"\"Returns the number of elements in the queue.\"\"\"\n            return self._s\n\n        @property\n        def capacity(self) - int:\n            \"\"\"Returns the current capacity of the underlying array.\"\"\"\n            return self._C\n        \n        def get_front(self):\n            \"\"\"Returns the front element of the queue without removing it.\"\"\"\n            if self.size == 0:\n                # Per problem statement, this will not be called on an empty queue.\n                return None\n            return self._data[self._h]\n\n        def _resize(self, new_capacity: int):\n            \"\"\"\n            Resizes the underlying array to new_capacity and copies elements.\n            \"\"\"\n            old_data = self._data\n            old_capacity = self._C\n            \n            self._data = np.full(new_capacity, None, dtype=object)\n            \n            # Copy elements from the old (circular) array to the new (linear) one.\n            walk = self._h\n            for k in range(self._s):\n                self._data[k] = old_data[walk]\n                walk = (walk + 1) % old_capacity\n            \n            # Reset indices and update capacity\n            self._C = new_capacity\n            self._h = 0\n            self._t = self._s\n\n        def enqueue(self, element):\n            \"\"\"\n            Adds an element to the tail of the queue.\n            \"\"\"\n            if self._s == self._C:\n                # Grow array if it is full.\n                self._resize(2 * self._C)\n            \n            self._data[self._t] = element\n            self._t = (self._t + 1) % self._C\n            self._s += 1\n\n        def dequeue(self):\n            \"\"\"\n            Removes and returns the element from the head of the queue.\n            Assumes the queue is not empty, as per problem statement.\n            \"\"\"\n            element = self._data[self._h]\n            self._data[self._h] = None  # Clear the slot\n            self._h = (self._h + 1) % self._C\n            self._s -= 1\n            \n            # Shrink array if it is sparsely populated, but not below C0.\n            if self._s = self._C // 4 and self._C  self._C0:\n                new_capacity = max(self._C0, self._C // 2)\n                self._resize(new_capacity)\n\n            return element\n\n    # --- Test Cases ---\n    all_results = []\n\n    # Test Case A\n    q_a = ResizableCircularQueue(initial_capacity=4)\n    dequeued_vals_a = []\n    q_a.enqueue(10)\n    q_a.enqueue(20)\n    q_a.enqueue(30)\n    dequeued_vals_a.append(q_a.dequeue())\n    dequeued_vals_a.append(q_a.dequeue())\n    q_a.enqueue(40)\n    q_a.enqueue(50)\n    q_a.enqueue(60)\n    q_a.enqueue(70)\n    result_a = [q_a.size, q_a.capacity, q_a.get_front(), sum(dequeued_vals_a)]\n    all_results.append(result_a)\n\n    # Test Case B\n    q_b = ResizableCircularQueue(initial_capacity=2)\n    dequeued_vals_b = []\n    for i in range(16):\n        q_b.enqueue(i)\n    for _ in range(13):\n        dequeued_vals_b.append(q_b.dequeue())\n    result_b = [q_b.size, q_b.capacity, q_b.get_front(), sum(dequeued_vals_b)]\n    all_results.append(result_b)\n\n    # Test Case C\n    q_c = ResizableCircularQueue(initial_capacity=3)\n    dequeued_vals_c = []\n    q_c.enqueue(\"x\")\n    q_c.enqueue(\"yy\")\n    q_c.enqueue(\"zzz\")\n    q_c.enqueue(\"wwww\")\n    dequeued_vals_c.append(q_c.dequeue())\n    dequeued_vals_c.append(q_c.dequeue())\n    q_c.enqueue(\"vv\")\n    q_c.enqueue(\"u\")\n    while q_c.size  0:\n        dequeued_vals_c.append(q_c.dequeue())\n    L_c = sum(len(s) for s in dequeued_vals_c)\n    result_c = [q_c.size, q_c.capacity, L_c]\n    all_results.append(result_c)\n    \n    # Test Case D\n    q_d = ResizableCircularQueue(initial_capacity=5)\n    dequeued_vals_d = []\n    q_d.enqueue(1.5)\n    q_d.enqueue(2.5)\n    q_d.enqueue(3.5)\n    dequeued_vals_d.append(q_d.dequeue())\n    q_d.enqueue(4.5)\n    q_d.enqueue(5.5)\n    dequeued_vals_d.append(q_d.dequeue())\n    dequeued_vals_d.append(q_d.dequeue())\n    q_d.enqueue(6.5)\n    q_d.enqueue(7.5)\n    q_d.enqueue(8.5)\n    f_d = q_d.get_front()\n    # Ensure float precision is handled correctly for output\n    S_dq_d = float(sum(dequeued_vals_d))\n    result_d = [q_d.size, q_d.capacity, f_d, S_dq_d]\n    all_results.append(result_d)\n\n    # Format the final output string exactly as specified.\n    results_str_list = []\n    for res in all_results:\n        # Convert each item in a result list to string\n        res_items_as_str = [str(item) for item in res]\n        # Join items with a comma and enclose in brackets\n        results_str_list.append(f\"[{','.join(res_items_as_str)}]\")\n    \n    # Join all test case results with a comma and enclose in brackets\n    final_output = f\"[{','.join(results_str_list)}]\"\n    \n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了循环队列之后，我们可以探索其更强大的泛化形式：双端队列（deque）。这项练习 () 将挑战你实现一个允许在前端和后端进行插入操作的双端队列，并以一个包含优先客户的呼叫中心作为实践模型。这将深化你对循环缓冲区操作的理解，并展示类队列结构在解决实际问题时的灵活性。",
            "id": "3208994",
            "problem": "实现一个基于数组的队列，该队列使用循环缓冲区模拟呼叫中心的等待队列，然后修改它以支持在队首插入“优先客户”。所需的操作是：标准到达时在队尾入队，优先到达时在队首入队，以及为提供服务而从队首出队。该实现必须基于数组（无链式结构），维持一个循环布局，并在插入前数组已满时通过将其容量加倍来自动调整底层数组的大小。目标是从队列的抽象定义和数组索引上的模运算性质推导出这些操作的正确性和复杂性，并通过一个固定的测试套件来验证其行为。\n\n使用以下基本基础：\n- 队列是一种由先进先出（FIFO）定义的抽象数据类型，意味着在队列中停留时间最长的项目将首先被服务。\n- 数组支持通过索引进行常数时间的随机访问。\n- 数组上的循环布局使用模运算；如果头索引是 $h$，尾索引是 $t$，容量是 $C$，那么前进一个位置对应于对 $C$ 取模加 $1$。具体来说，是 $i \\mapsto (i+1) \\bmod C$。\n- 通过分配一个大小为 $2C$ 的新数组并按逻辑顺序 $0,1,2,\\dots$ 复制现有项目来调整数组大小，可以保留项目顺序，并实现每次插入的摊销常数时间。\n\n您的任务：\n- 设计并实现一个基于数组的队列，该队列使用带有动态调整大小功能的循环缓冲区，并包含以下操作：\n  - 标准到达 enqueue_back：在队尾附加客户标识符 $x$。\n  - 优先到达 enqueue_front：在队首插入客户标识符 $x$。\n  - 服务 dequeue_front：移除并返回队首的标识符；如果队列为空，则该服务步骤不返回任何标识符。\n- 维护索引 $h$（头）、$t$（尾）、大小 $s$ 和容量 $C$，使得项目的逻辑顺序位于位置 $(h + k) \\bmod C$ 上，其中 $k \\in \\{0,1,\\dots,s-1\\}$。\n- 当向一个 $s = C$ 的已满缓冲区插入时，首先通过将 $s$ 个项目按顺序重新定位到位置 $0,1,\\dots,s-1$ 来将容量调整为 $2C$，然后执行待处理的插入操作。不要缩小缓冲区。\n\n事件模型：\n- 每个测试用例由一个初始容量 $C$ 和一个包含三种事件的序列组成：\n  - 标准到达 $A(x)$，表示使用标识符 $x$ 执行 enqueue_back 操作。\n  - 优先到达 $P(x)$，表示使用标识符 $x$ 执行 enqueue_front 操作。\n  - 服务 $S(k)$，表示执行 dequeue_front 操作最多 $k$ 次；如果可用客户少于 $k$ 个，则为所有可用的客户提供服务。收集测试用例中所有 $S(\\cdot)$ 事件所服务的所有标识符的有序序列。\n\n要求输出：\n- 对于每个测试用例，程序必须按顺序输出一个由服务过的标识符组成的整数列表。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。每个结果本身就是一个列表，并且列表必须无空格打印，例如：$[[1,2],[3],[4,5,6]]$。\n\n测试套件：\n- 恰好使用以下五个测试用例。每个测试用例是一个序对 $(C, \\text{events})$，其中 $C$ 是初始容量，$\\text{events}$ 是事件的有限序列。\n  - 测试 $1$：$C = 4$，事件 $[A(1), A(2), A(3), S(2), A(4), P(99), S(3)]$。\n  - 测试 $2$：$C = 3$，事件 $[S(1), P(5), S(2), S(1)]$。\n  - 测试 $3$：$C = 5$，事件 $[A(10), A(11), A(12), A(13), S(3), A(14), A(15), A(16), P(7), S(4)]$。\n  - 测试 $4$：$C = 2$，事件 $[A(1), A(2), P(3), A(4), A(5), S(5)]$。\n  - 测试 $5$：$C = 4$，事件 $[P(1), P(2), P(3), A(4), A(5), S(5)]$。\n\n注释与约束：\n- 所有客户标识符和 $k$ 值均为非负整数。\n- 正确性必须遵循队列的抽象定义和附加优先操作的语义，并通过模运算更新索引。确保在没有调整大小的情况下，enqueue_front 和 enqueue_back 的运行时间均为 $\\mathcal{O}(1)$，并且调整大小操作在任意 $n$ 次插入序列中，每次插入的摊销时间为 $\\mathcal{O}(1)$。\n- 程序必须完全独立，无需用户输入或外部文件即可生成所需的单行输出。",
            "solution": "问题陈述是有效的。它在数据结构和算法领域提出了一个定义明确的任务，该任务基于公认的计算机科学原理。该问题是自包含的、客观的，其要求是内部一致且可形式化的。\n\n核心任务是使用支持动态调整大小的循环数组实现一个双端队列（deque）。该双端队列必须提供三个操作：`enqueue_back`（标准追加）、`enqueue_front`（优先前置）和 `dequeue_front`（服务）。解决方案必须通过一个特定的测试套件进行验证。\n\n该实现将被封装在一个类中，我们可以将其命名为 `CircularDeque`。该类将通过四个主要属性来管理队列的状态：\n- 一个底层的 `numpy` 数组 `data`，用于存储队列元素。\n- 该数组的容量 $C$，我们称之为 `capacity`。\n- 队列中第一个元素的索引 $h$，我们称之为 `head`。\n- 当前队列中的元素数量 $s$，我们称之为 `size`。\n\n空队列定义为 $s=0$。满队列定义为 $s=C$。问题陈述还提到了一个尾索引 $t$。该索引不是一个独立的状态变量，而是可以从其他变量推导出来。它指向队列尾部的第一个可用空位，由 $t = (h+s) \\pmod C$ 给出。我们将使用 $h$ 和 $s$ 作为管理队列结构的主要状态变量。\n\n队列中元素的逻辑序列（索引从 $0$ 到 $s-1$）通过模运算映射到物理数组索引上。第 $k$ 个逻辑元素（其中 $k \\in \\{0, 1, \\dots, s-1\\}$）存储在物理索引 $(h+k) \\pmod C$ 处。\n\n让我们详细说明每个所需操作的设计。\n\n**1. 初始化 `__init__(self, capacity)`**\n此构造函数用给定的初始容量 $C$ 初始化一个空队列。\n- `capacity` 设置为所提供的值。\n- `data` 数组被创建为一个大小为 $C$ 的 `numpy` 数组，初始化为零。\n- `head` 索引 $h$ 初始化为 $0$。\n- `size` $s$ 初始化为 $0$。\n\n**2. `enqueue_back(self, x)`**\n此操作将元素 $x$ 添加到队列的尾部。\n- 首先，它检查队列是否已满 ($s=C$)。如果是，它必须通过调用一个辅助方法 `_resize()` 来调整底层数组的大小。\n- 新元素的物理索引是尾部位置，计算公式为 $t = (h+s) \\pmod C$。\n- 元素 $x$ 被放置在 `data[t]`。\n- 队列的大小 $s$ 增加 1。\n当不发生调整大小时，此操作的时间复杂度为 $\\mathcal{O}(1)$。\n\n**3. `enqueue_front(self, x)`**\n此操作将一个优先元素 $x$ 添加到队列的头部。\n- 与 `enqueue_back` 类似，如果 $s=C$，它首先检查并通过调用 `_resize()` 来处理溢出。\n- 要在队首插入，`head` 索引 $h$ 必须（循环地）向后移动一个位置。新的头索引计算为 $h' = (h - 1 + C) \\pmod C$。\n- `head` 更新为 $h'$。\n- 新元素 $x$ 被放置在 `data[h']`。\n- 队列的大小 $s$ 增加 1。\n当不发生调整大小时，此操作的时间复杂度也为 $\\mathcal{O}(1)$。\n\n**4. `dequeue_front(self)`**\n此操作移除并返回队列头部的元素。\n- 它首先检查队列是否为空 ($s=0$)。如果是，它返回一个指示符（例如 `None`），表示没有元素被服务，这符合问题描述。\n- 如果队列不为空，要返回的元素是 `data[h]`。\n- `head` 索引（循环地）向前推进一个位置：$h' = (h+1) \\pmod C$。\n- `head` 更新为 $h'$。\n- 队列的大小 $s$ 减少 1。\n- 返回检索到的元素。\n此操作始终是 $\\mathcal{O}(1)$。\n\n**5. 调整大小 `_resize(self)`**\n当 $s=C$ 时，入队操作会调用此辅助方法。\n- 新容量 $C_{new}$ 设置为 $2C$。\n- 分配一个容量为 $C_{new}$ 的新 `numpy` 数组 `new_data`。\n- 关键步骤是将元素从旧数组复制到新数组。问题指定元素应重新定位以占据新数组中的索引 $0, 1, \\dots, s-1$。这个过程“展开”了循环缓冲区。对于从 $0$ 到 $s-1$ 的每个逻辑元素 $k$：\n    - 其在旧数组中的索引为 $i_{old} = (h+k) \\pmod C$。\n    - 元素 `data[i_old]` 被复制到 `new_data[k]`。\n- 复制完成后，`data` 数组被替换为 `new_data`，并且 `capacity` 更新为 $C_{new}$。因为元素现在按其逻辑顺序位于新数组的开头，所以 `head` 索引 $h$ 被重置为 $0$。`size` $s$ 在调整大小操作本身中保持不变。\n\n**正确性与复杂度分析**\n此设计的正确性根植于对所有索引计算一致地应用模运算，这正确地实现了缓冲区的循环特性。调整大小过程通过将元素显式地展开到新的、更大的数组开头的线性序列中，正确地保留了 FIFO 顺序，并通过将 $h$ 重置为 $0$ 来简化状态。\n\n复杂度满足问题要求。在没有调整大小的情况下，`enqueue_front` 和 `enqueue_back` 都执行常数次算术运算和单次数组访问，使其时间复杂度为 $\\mathcal{O}(1)$。`dequeue_front` 操作始终是 $\\mathcal{O}(1)$。`_resize` 操作需要 $\\mathcal{O}(C)$ 的时间，其中 $C$ 是当前容量。根据对几何增长的动态数组的标准摊销分析，这个 $\\mathcal{O}(C)$ 的成本被分摊到接下来的 $C$ 次插入中（在本例中，将容量从 $C$ 加倍到 $2C$ 至少允许 $C$ 次新插入）。这使得在一长串操作中，每次插入操作的摊销时间复杂度为 $\\mathcal{O}(1)$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass CircularDeque:\n    \"\"\"\n    An array-backed queue (deque) implemented with a circular buffer\n    and dynamic resizing.\n    \"\"\"\n    def __init__(self, capacity):\n        \"\"\"\n        Initializes the deque with a given capacity.\n        \"\"\"\n        if capacity  1:\n            raise ValueError(\"Capacity must be at least 1\")\n        self.capacity = capacity\n        # Using a numpy array of a specific dtype as required.\n        # Initializing with 0s is fine as we track size separately.\n        self.data = np.zeros(self.capacity, dtype=int)\n        self.head = 0  # Index of the front element\n        self.size = 0  # Number of elements in the deque\n\n    def _resize(self):\n        \"\"\"\n        Doubles the capacity of the deque when it is full.\n        The elements are unrolled into the new array starting from index 0.\n        \"\"\"\n        old_capacity = self.capacity\n        self.capacity *= 2\n        new_data = np.zeros(self.capacity, dtype=int)\n        \n        # Unroll the circular buffer into a linear layout in the new array\n        for k in range(self.size):\n            old_index = (self.head + k) % old_capacity\n            new_data[k] = self.data[old_index]\n        \n        self.data = new_data\n        self.head = 0\n\n    def enqueue_back(self, value):\n        \"\"\"\n        Adds an element to the back of the deque.\n        \"\"\"\n        if self.size == self.capacity:\n            self._resize()\n        \n        # Calculate the index for the new element at the tail\n        tail_index = (self.head + self.size) % self.capacity\n        self.data[tail_index] = value\n        self.size += 1\n\n    def enqueue_front(self, value):\n        \"\"\"\n        Adds an element to the front of the deque.\n        \"\"\"\n        if self.size == self.capacity:\n            self._resize()\n            \n        # Move head one step backwards (circularly)\n        self.head = (self.head - 1 + self.capacity) % self.capacity\n        self.data[self.head] = value\n        self.size += 1\n\n    def dequeue_front(self):\n        \"\"\"\n        Removes and returns the element from the front of the deque.\n        Returns None if the deque is empty.\n        \"\"\"\n        if self.size == 0:\n            return None\n        \n        value = self.data[self.head]\n        # Advance head one step forward (circularly)\n        self.head = (self.head + 1) % self.capacity\n        self.size -= 1\n        return value\n\ndef solve():\n    \"\"\"\n    Runs the full test suite as defined in the problem statement.\n    \"\"\"\n    # Test suite definition: (Initial Capacity, [Events])\n    # Events are tuples: ('A', value), ('P', value), ('S', count)\n    test_cases = [\n        (4, [('A', 1), ('A', 2), ('A', 3), ('S', 2), ('A', 4), ('P', 99), ('S', 3)]),\n        (3, [('S', 1), ('P', 5), ('S', 2), ('S', 1)]),\n        (5, [('A', 10), ('A', 11), ('A', 12), ('A', 13), ('S', 3), ('A', 14), ('A', 15), ('A', 16), ('P', 7), ('S', 4)]),\n        (2, [('A', 1), ('A', 2), ('P', 3), ('A', 4), ('A', 5), ('S', 5)]),\n        (4, [('P', 1), ('P', 2), ('P', 3), ('A', 4), ('A', 5), ('S', 5)]),\n    ]\n\n    all_results = []\n\n    for capacity, events in test_cases:\n        queue = CircularDeque(capacity)\n        served_identifiers = []\n        \n        for event_type, value in events:\n            if event_type == 'A':\n                queue.enqueue_back(value)\n            elif event_type == 'P':\n                queue.enqueue_front(value)\n            elif event_type == 'S':\n                for _ in range(value):\n                    served = queue.dequeue_front()\n                    if served is not None:\n                        served_identifiers.append(served)\n        \n        all_results.append(served_identifiers)\n\n    # Format the final output string as per the problem requirements.\n    # e.g., [[1,2,99,3,4],[5],[10,11,12,7,13,14,15],[3,1,2,4,5],[3,2,1,4,5]]\n    result_strings = []\n    for res_list in all_results:\n        # Create string for each inner list, e.g., \"[1,2,3]\"\n        list_str = f\"[{','.join(map(str, res_list))}]\"\n        result_strings.append(list_str)\n    \n    # Join all list strings into the final output format\n    final_output = f\"[{','.join(result_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```"
        }
    ]
}