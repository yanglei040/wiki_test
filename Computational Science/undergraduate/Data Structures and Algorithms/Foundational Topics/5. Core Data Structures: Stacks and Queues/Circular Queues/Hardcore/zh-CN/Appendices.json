{
    "hands_on_practices": [
        {
            "introduction": "在操作或修改数据结构之前，我们必须首先理解如何访问其内部数据。这个练习 () 将帮助你专注于在不改变队列状态的情况下，按其逻辑顺序读取元素。掌握从逻辑位置到物理数组索引的映射关系，是精通循环队列的关键一步，也是所有更复杂操作的基础。",
            "id": "3221146",
            "problem": "给定一个基于数组的循环队列的形式化定义。一个容量为 $C$ 的循环队列由一个长度为 $C$ 的数组 $A$、一个标识下一个待出队元素位置的队头索引 $f$ 以及一个等于当前存储元素数量的大小 $s$ 来表示。队尾索引 $r$ 由不变式 $r \\equiv (f + s) \\bmod C$ 推导得出，并且所有索引始终位于集合 $\\{0, 1, \\dots, C-1\\}$ 中。该队列支持入队（enqueue）和出队（dequeue）操作，并遵循以下不变式：$0 \\le s \\le C$，入队操作仅在 $s \\lt C$ 时有定义，而出队操作仅在 $s \\gt 0$ 时有定义。概念上的队列顺序是从逻辑队头开始，并按照未来出队的顺序排列的元素序列，这与它们在数组 $A$ 中的具体排列方式无关。\n\n设计并实现一个函数，该函数接收一个这样的循环队列，返回概念上出队顺序中的接下来 $k$ 个元素，而不从队列中移除任何元素。该函数必须在 $\\mathcal{O}(k)$ 时间内运行，除了输出列表外只使用常数级别的额外工作空间（即，不包括存储返回元素所需的空间），并且不得修改队列的状态。如果 $k$ 超出可用元素的数量 $s$，函数必须返回长度为 $\\min(k, s)$ 的最长前缀；如果 $k = 0$ 或队列为空 ($s = 0$)，函数必须返回空列表。\n\n将您的解决方案实现为一个完整的、可运行的程序。该程序应构建多个循环队列，并对每个队列使用指定的 $k$ 值调用该函数。请使用以下测试套件，它涵盖了一般情况、环绕行为、边界条件和边缘情况：\n\n- 测试用例 1：容量 $C = 7$，将元素 $10, 20, 30, 40$ 入队；然后使用 $k = 3$ 调用函数。\n- 测试用例 2：容量 $C = 5$，将元素 $1, 2, 3, 4$ 入队；执行三次出队操作；将元素 $5, 6, 7$ 入队；然后使用 $k = 4$ 调用函数。\n- 测试用例 3：容量 $C = 6$，将元素 $9, 8$ 入队；然后使用 $k = 0$ 调用函数。\n- 测试用例 4：容量 $C = 8$，将元素 $100, 200, 300$ 入队；然后使用 $k = 3$ 调用函数。\n- 测试用例 5：容量 $C = 6$，将元素 $5, 15$ 入队；然后使用 $k = 5$ 调用函数。\n- 测试用例 6：容量 $C = 4$，不执行入队操作；然后使用 $k = 2$ 调用函数。\n- 测试用例 7：容量 $C = 4$，将元素 $7, 8, 9, 10$ 入队；然后使用 $k = 2$ 调用函数。\n- 测试用例 8：容量 $C = 3$，将元素 $1, 2, 3$ 入队；执行两次出队操作；将元素 $4, 5$ 入队；然后使用 $k = 3$ 调用函数。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个条目本身都是对应测试用例返回的元素列表，例如 $[r_1, r_2, \\dots, r_8]$，其中每个 $r_i$ 都是一个列表。",
            "solution": "设计一个函数来预览循环队列中接下来的 $k$ 个元素而不修改队列状态，这是数据结构实现中一个定义明确且标准的任务。所提供的循环队列定义在形式上是严谨的，它使用基于容量为 $C$ 的数组 $A$、队头索引 $f$ 和大小 $s$ 的状态表示。\n\n解决这个问题的基本原理在于队列中元素的概念顺序与其在底层数组 $A$ 中物理位置之间的映射关系。概念顺序就是元素将被出队的顺序。第一个要出队的元素位于数组的索引 $f$ 处。第二个元素在下一个物理位置，由于队列的循环特性，该位置为 $(f+1) \\pmod C$。以此类推，概念上出队顺序中的第 $i$ 个元素（对于 $i=0, 1, 2, \\dots, s-1$）存储在由以下表达式给出的物理数组索引处：\n$$\n\\text{physical\\_index}(i) = (f + i) \\pmod C\n$$\n这个关系对当前队列中的所有元素都成立，从队头 ($i=0$) 到逻辑队尾 ($i=s-1$)，并且能正确处理队列元素跨越数组末尾和开头边界的环绕行为。\n\n任务是设计一个函数，返回此概念顺序中的接下来 $k$ 个元素。该函数不得改变队列的状态变量（$f$、$s$）或数组 $A$ 的内容。它必须在 $\\mathcal{O}(k)$ 时间内执行，并使用 $\\mathcal{O}(1)$ 的额外内存（不包括输出列表的存储空间）。\n\n该算法可以直接根据索引映射原​​理来设计：\n\n1.  **确定要返回的元素数量**：问题规定，如果 $k$ 超过可用元素的数量 $s$，函数应返回所有可用元素。如果 $k=0$ 或队列为空 ($s=0$)，则应返回一个空列表。这可以通过计算要返回的元素数量（我们称之为 $n_{peek}$）来统一处理：\n    $$\n    n_{peek} = \\min(k, s)\n    $$\n    当 $k  s$ 时，该表达式正确地得到 $s$；当 $k \\le s$ 时，得到 $k$；如果 $k=0$ 或 $s=0$，则得到 $0$。\n\n2.  **迭代并收集元素**：如果 $n_{peek}  0$，我们开始收集元素。我们可以迭代 $n_{peek}$ 次，循环索引 $i$ 从 $0$ 到 $n_{peek}-1$。在每次迭代中，$i$ 代表概念上出队顺序中的位置。\n\n3.  **计算物理索引**：对于每个 $i$ 值，我们使用核心映射公式来找到元素在数组 $A$ 中的物理索引 $j$：\n    $$\n    j = (f + i) \\pmod C\n    $$\n\n4.  **访问并存储**：访问 $A[j]$ 处的元素并将其附加到结果列表中。此操作纯属读取操作，不会改变队列的状态。\n\n5.  **返回结果**：循环完成后，结果列表包含概念顺序中的前 $n_{peek}$ 个元素，并将其返回。\n\n该算法满足所有给定的约束条件：\n-   **无状态修改**：该算法仅从队列的内部状态（$f$、$s$ 和 $A$）读取数据，不执行任何写入操作。队列的状态保持不变。\n-   **时间复杂度**：主要工作是一个运行 $n_{peek} = \\min(k, s)$ 次的单循环。由于 $s$ 最大为 $C$，$k$ 是输入参数，迭代次数受 $k$ 的限制。循环内的每一步（索引计算、数组访问、列表追加）都花费常数时间，即 $\\mathcal{O}(1)$。因此，总时间复杂度为 $\\mathcal{O}(\\min(k, s))$，这与要求的 $\\mathcal{O}(k)$ 一致。\n-   **空间复杂度**：该算法使用少量变量用于循环计数器和索引计算，消耗 $\\mathcal{O}(1)$ 的空间。返回列表所需空间被明确排除在此约束之外。因此，满足了额外工作空间的要求。\n\n实现将包括一个表示循环队列的类，该类具有 `enqueue`、`dequeue` 和预览接下来 $k$ 个元素的所需函数的方法，然后是一个执行指定测试套件的主程序。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass CircularQueue:\n    \"\"\"\n    An array-backed circular queue.\n    \"\"\"\n    def __init__(self, capacity: int):\n        if capacity  1:\n            raise ValueError(\"Capacity must be a positive integer.\")\n        self._capacity = capacity\n        # Use dtype=object to store any Python object, including integers.\n        self._data = np.empty(capacity, dtype=object)\n        self._front = 0\n        self._size = 0\n\n    def enqueue(self, element):\n        \"\"\"Adds an element to the rear of the queue.\"\"\"\n        if self._size == self._capacity:\n            raise OverflowError(\"Queue is full\")\n        \n        # The rear index is derived from front and size.\n        rear_index = (self._front + self._size) % self._capacity\n        self._data[rear_index] = element\n        self._size += 1\n\n    def dequeue(self):\n        \"\"\"Removes and returns the front element of the queue.\"\"\"\n        if self._size == 0:\n            raise IndexError(\"Dequeue from an empty queue\")\n        \n        element = self._data[self._front]\n        self._data[self._front] = None # Optional: clear the dequeued slot\n        self._front = (self._front + 1) % self._capacity\n        self._size -= 1\n        return element\n\n    def peek_k(self, k: int):\n        \"\"\"\n        Returns the next k elements in the conceptual dequeue order\n        without mutating the queue.\n        \"\"\"\n        if k  0:\n            k = 0\n        num_to_peek = min(k, self._size)\n        if num_to_peek == 0:\n            return []\n        \n        result = []\n        for i in range(num_to_peek):\n            # The i-th element (0-indexed) in conceptual order is at\n            # physical index (front + i) % capacity.\n            physical_index = (self._front + i) % self._capacity\n            result.append(self._data[physical_index])\n            \n        return result\n\ndef solve():\n    \"\"\"\n    Constructs and tests circular queues as per the problem statement.\n    \"\"\"\n    # Test suite definition: (capacity, list_of_operations, k)\n    # Operations: ('e', value) for enqueue, ('d',) for dequeue\n    test_cases = [\n        # Test case 1\n        (7, [('e', 10), ('e', 20), ('e', 30), ('e', 40)], 3),\n        # Test case 2\n        (5, [('e', 1), ('e', 2), ('e', 3), ('e', 4), ('d',), ('d',), ('d',), ('e', 5), ('e', 6), ('e', 7)], 4),\n        # Test case 3\n        (6, [('e', 9), ('e', 8)], 0),\n        # Test case 4\n        (8, [('e', 100), ('e', 200), ('e', 300)], 3),\n        # Test case 5\n        (6, [('e', 5), ('e', 15)], 5),\n        # Test case 6\n        (4, [], 2),\n        # Test case 7\n        (4, [('e', 7), ('e', 8), ('e', 9), ('e', 10)], 2),\n        # Test case 8\n        (3, [('e', 1), ('e', 2), ('e', 3), ('d',), ('d',), ('e', 4), ('e', 5)], 3),\n    ]\n\n    results = []\n    for capacity, operations, k_val in test_cases:\n        queue = CircularQueue(capacity)\n        for op in operations:\n            if op[0] == 'e':\n                queue.enqueue(op[1])\n            elif op[0] == 'd':\n                queue.dequeue()\n        \n        peek_result = queue.peek_k(k_val)\n        results.append(peek_result)\n\n    # The final print statement must produce the specified single-line format.\n    # The default str() for a list includes spaces, which is acceptable.\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the solution\nsolve()\n\n```"
        },
        {
            "introduction": "在我们学会了如何正确“查看”队列中的元素之后 ()，下一个挑战是直接在底层数组上对它们进行操作。本练习 () 要求你就地反转队列中的元素，这是一个将标准算法（双指针反转）与循环索引的复杂性相结合的有趣任务。通过解决这个问题，你将更深刻地理解如何利用模运算在循环缓冲区内进行高效的数据操作。",
            "id": "3221166",
            "problem": "给定一个基于固定长度数组实现的循环队列的定义。循环队列是一种先进先出（FIFO）的数据结构，其内容通过模运算在一个环中进行维护。设底层数组的容量为 $N$，队列的活动段由一个头索引 $H$ 和一个长度 $K$ 指定。逻辑位置为 $i$（其中 $0 \\le i \\le K-1$）的活动元素位于物理索引 $(H+i) \\bmod N$ 处。数组中未被这 $K$ 个活动索引覆盖的位置是未使用的，并且与队列的逻辑序列无关。\n\n从循环队列中元素逻辑顺序由映射 $i \\mapsto (H+i) \\bmod N$ 控制这一基本定义出发，设计一个算法，原地反转循环队列的 $K$ 个活动元素，仅使用 $O(1)$ 的额外空间，并且不改变 $H$、$K$ 或 $N$。您必须从模运算和队列定义的基本原理出发进行推理，以确保算法对于所有有效的参数值（包括边界情况）都是正确的。该算法必须在 $O(K)$ 时间内运行，并且最多使用与 $N$ 和 $K$ 无关的常数个辅助变量。\n\n您的程序必须在以下测试套件上实现此反转操作。每个测试用例都提供了 $N$、$A$、$H$ 和 $K$ 的具体值，其中 $A$ 是数组内容，且只有 $K$ 个活动位置需要被反转。反转后，对于每个测试用例，按从头到尾的顺序列出 $K$ 个活动元素的逻辑序列，作为整数列表输出。\n\n测试套件：\n- 用例 1：$N=8$, $H=3$, $K=5$, $A=[0,0,0,10,20,30,40,50]$。\n- 用例 2：$N=7$, $H=5$, $K=4$, $A=[3,4,0,0,0,1,2]$。\n- 用例 3：$N=5$, $H=2$, $K=0$, $A=[9,8,7,6,5]$。\n- 用例 4：$N=6$, $H=4$, $K=1$, $A=[0,0,0,0,99,0]$。\n- 用例 5：$N=6$, $H=2$, $K=6$, $A=[11,12,7,8,9,10]$。\n- 用例 6：$N=1$, $H=0$, $K=1$, $A=[42]$。\n\n约束条件：\n- $N$ 是一个整数，$N \\ge 1$。\n- $H$ 是一个整数，$0 \\le H \\le N-1$。\n- $K$ 是一个整数，$0 \\le K \\le N$。\n- $A$ 是一个长度为 $N$ 的列表；仅索引 $(H+i) \\bmod N$（对于 $i \\in \\{0,1,\\dots,K-1\\}$）构成活动队列内容。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[result_1,result_2,\\dots]$），其中每个 $result_j$ 本身是第 $j$ 个测试用例反转后 $K$ 个活动元素的列表。输出行中不得有任何空格。每个 $result_j$ 是一个整数列表。例如，一个可能的输出可能看起来像 $[[2,1],[],[9]]$，其中 $[]$ 表示空列表。在您的输出中，请使用 $[]$ 表示空列表。",
            "solution": "我们从一个容量为 $N$ 的数组上的循环队列的核心定义开始。$K$ 个活动元素的逻辑序列由以下映射确定：\n$$\n\\text{phys}(i) = (H + i) \\bmod N,\\quad \\text{for } i \\in \\{0,1,\\dots,K-1\\}.\n$$\n反转逻辑序列意味着对于序列前半部分的所有 $i$，逻辑位置 $i$ 处的元素必须与逻辑位置 $(K-1-i)$ 处的元素交换。在标准的数组反转中，这是通过围绕中心的对称交换来实现的，当索引以模 $N$ 解释时，同样的原则也适用。\n\n基于原理的推导：\n1. 队列的逻辑顺序完全由 $H$、$K$ 和 $N$ 通过模运算确定。要在不改变表示参数（$H$、$K$、$N$）的情况下反转序列，我们必须仅对存储在与活动范围相对应的物理索引处的值进行排列。\n2. 定义逻辑位置和物理位置之间的双射：\n   $$\n   f(i) = (H+i) \\bmod N,\\quad i \\in \\{0,1,\\dots,K-1\\}.\n   $$\n   此函数在指定定义域上是单射的，因为 $N \\ge 1$ 且定义域大小为 $K \\le N$。陪域中的位置在模 $N$ 意义下是不同的。\n3. 反转需要将序列 $\\langle a_0,a_1,\\dots,a_{K-1} \\rangle$ 变换为 $\\langle a_{K-1},\\dots,a_1,a_0 \\rangle$。这可以通过对从 $0$ 到 $\\left\\lfloor\\frac{K}{2}\\right\\rfloor - 1$ 的每个 $i$ 执行以下交换来实现：\n   $$\n   \\text{swap}\\left(A[f(i)],\\ A[f(K-1-i)]\\right).\n   $$\n   此类交换的数量为 $\\left\\lfloor\\frac{K}{2}\\right\\rfloor$，每次交换使用常数额外空间（一个临时变量）。\n4. 正确性论证：\n   - 对于每一对 $(i, K-1-i)$，交换操作将 $a_{K-1-i}$ 放置在物理索引 $f(i)$ 处，并将 $a_i$ 放置在物理索引 $f(K-1-i)$ 处。\n   - 因为索引 $i$ 恰好覆盖了 $\\{0,\\dots,K-1\\}$ 的前半部分，而 $K-1-i$ 恰好覆盖了后半部分，所以在所有交换之后，序列被反转。\n   - 不会触及任何非活动索引，因为 $f(i)$ 仅对 $[0, K-1]$ 中的 $i$ 进行计算。\n   - 参数 $H$、$K$、$N$ 保持不变，保留了队列的表示，而逻辑顺序现在被反转了。\n5. 复杂度：\n   - 时间：该算法执行 $\\left\\lfloor\\frac{K}{2}\\right\\rfloor$ 次交换，每次交换的工作量为 $O(1)$，因此总时间为 $O(K)$。\n   - 空间：除了常数个变量（循环计数器、两个索引和一个用于交换的临时变量），没有使用额外的存储空间，因此空间复杂度为 $O(1)$。\n6. 边界条件：\n   - 如果 $K=0$，循环不执行，数组保持不变，输出为空列表 $[]$。\n   - 如果 $K=1$，循环不执行，因此单个元素保持不变。\n   - 如果 $K=N$，所有位置 $\\{0,1,\\dots,N-1\\}$ 都是活动的，由于模运算，同样的过程也适用于索引正确环绕的情况。\n   - 环绕情况被自然处理，因为 $f(i)$ 使用 $(H+i) \\bmod N$，确保了连续的逻辑位置可以跨越数组边界映射到正确的物理位置。\n\n输出的实现细节：\n- 执行反转后，通过读取 $A[(H+i) \\bmod N]$（对于 $i=0,1,\\dots,K-1$）来重构用于输出的逻辑序列。\n- 对于提供的测试套件，每个结果都是一个整数列表。程序将所有六个结果聚合到一个列表中，并以指定的无空格格式打印，确保严格遵守输出要求。\n\n此方法直接源于逻辑位置和模物理索引之间的基础映射，并使用了经过充分检验的、适用于循环索引的序列反转技术，从而实现了所需的原地、$O(1)$ 空间、$O(K)$ 时间复杂度的反转。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np  # Imported as allowed; not strictly required by the solution.\n\ndef reverse_circular_queue_in_place(A, N, H, K):\n    \"\"\"\n    Reverse the K active elements of a circular queue in-place.\n    Active logical positions i in [0, K-1] map to physical indices (H+i) % N.\n    The reversal maintains H, K, and N unchanged.\n    \"\"\"\n    # Handle trivial cases gracefully.\n    if K = 1:\n        return  # Nothing to do\n\n    # Perform symmetric swaps using modular arithmetic.\n    half = K // 2\n    for i in range(half):\n        left_idx = (H + i) % N\n        right_idx = (H + (K - 1 - i)) % N\n        # Swap A[left_idx] and A[right_idx]\n        A[left_idx], A[right_idx] = A[right_idx], A[left_idx]\n\n\ndef linearize_active(A, N, H, K):\n    \"\"\"\n    Return the logical sequence of active elements as a list:\n    [A[(H+0)%N], A[(H+1)%N], ..., A[(H+K-1)%N]]\n    \"\"\"\n    return [A[(H + i) % N] for i in range(K)]\n\n\ndef format_list_no_spaces(lst):\n    \"\"\"\n    Format a Python list (of ints) as a string without spaces, e.g., [1,2,3].\n    \"\"\"\n    return \"[\" + \",\".join(str(x) for x in lst) + \"]\"\n\n\ndef format_list_of_lists_no_spaces(list_of_lists):\n    \"\"\"\n    Format a list of lists (each inner list contains ints) without spaces.\n    Example: [[1,2],[3],[ ]] -> \"[[1,2],[3],[]]\"\n    \"\"\"\n    inner = \",\".join(format_list_no_spaces(inner_lst) for inner_lst in list_of_lists)\n    return \"[\" + inner + \"]\"\n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case: (N, A, H, K)\n    test_cases = [\n        (8, [0, 0, 0, 10, 20, 30, 40, 50], 3, 5),   # Case 1\n        (7, [3, 4, 0, 0, 0, 1, 2], 5, 4),           # Case 2\n        (5, [9, 8, 7, 6, 5], 2, 0),                 # Case 3 (empty)\n        (6, [0, 0, 0, 0, 99, 0], 4, 1),             # Case 4 (single element)\n        (6, [11, 12, 7, 8, 9, 10], 2, 6),           # Case 5 (full queue)\n        (1, [42], 0, 1),                            # Case 6 (degenerate capacity)\n    ]\n\n    results = []\n    for N, A, H, K in test_cases:\n        # Reverse the active elements in place.\n        reverse_circular_queue_in_place(A, N, H, K)\n        # Collect the logical sequence after reversal.\n        linearized = linearize_active(A, N, H, K)\n        results.append(linearized)\n\n    # Final print statement in the exact required format (no spaces).\n    print(format_list_of_lists_no_spaces(results))\n\nsolve()\n```"
        },
        {
            "introduction": "最后，让我们将所学知识应用于一个动态模拟问题中。约瑟夫斯问题是一个经典的算法谜题，而循环队列的“旋转”能力为其提供了一种优雅的建模方式。这个综合性练习 () 旨在展示“先进先出”原则与循环队列的环绕特性相结合，如何为涉及循环过程的问题提供自然且高效的解决方案。",
            "id": "3221203",
            "problem": "设计并实现一个完整的程序，该程序使用循环队列作为管理圈中人员的唯一数据结构，来模拟约瑟夫环淘汰过程。圈中最初包含 $n$ 个不同的人，其标签为 $1$ 到 $n$。计数从一个指定的起始标签 $s$ 开始。在每一轮淘汰中，你沿着圈向前计数；被数到的第 $k$ 个人将从圈中淘汰。这个过程持续进行，直到只剩下一个人，即幸存者。\n\n使用以下基本原理和定义：\n- 队列是一种具有先进先出（FIFO）属性的抽象数据类型。在 FIFO 规则中，最早进入的元素最先离开。\n- 循环队列是一种有界容量、由数组支持的队列，具有两个索引 $front$ 和 $rear$ 以及一个大小计数器。在 $rear$ 处添加和从 $front$ 处移除元素会以容量为模更新索引。形式上，如果容量为 $C$，则索引 $i$ 的递增操作为 $i \\leftarrow (i + 1) \\bmod C$。\n- 将圈旋转一个位置的操作通过移除当前的 $front$ 元素并立即将其添加到 $rear$ 来实现；这保留了相对顺序，并在不改变元素集合的情况下将计数位置前进一格。\n\n在循环队列上实现以下操作，并用它们来模拟约瑟夫过程：\n- 初始化一个容量为 $n$ 的空循环队列。\n- 按升序将所有标签从 $1$ 到 $n$ 入队。\n- 通过将队列精确旋转 $s-1$ 次来对齐起始标签 $s$，使得 $front$ 等于 $s$。\n- 重复以下步骤，直到只剩下一个元素：\n  1. 将队列精确旋转 $k-1$ 个位置。使用模运算来避免冗余的整圈旋转：如果当前大小为 $m$，旋转 $r$ 个位置等同于旋转 $(r \\bmod m)$ 个位置。\n  2. 将 $front$ 元素出队；这是该轮被淘汰的人。\n- 将淘汰顺序报告为一个列表，将最终幸存者报告为一个整数。\n\n您的程序必须为以下测试套件生成结果，其中每个测试用例以三元组 $\\langle n,k,s \\rangle$ 的形式提供：\n- 测试 $1$：$\\langle 7,3,1 \\rangle$。\n- 测试 $2$：$\\langle 5,2,1 \\rangle$。\n- 测试 $3$：$\\langle 10,1,1 \\rangle$。\n- 测试 $4$：$\\langle 1,5,1 \\rangle$。\n- 测试 $5$：$\\langle 6,7,2 \\rangle$。\n- 测试 $6$：$\\langle 8,100,4 \\rangle$。\n\n对于每个测试用例，您的程序必须计算并返回一个包含两项的列表：淘汰顺序（一个整数列表）和幸存者（一个整数）。将所有测试用例的结果汇总到单行输出中，该输出包含一个用方括号括起来的、逗号分隔的结果列表。具体来说，最终输出必须是以下形式：\n$$\n[\\,[\\text{elim\\_order}_1,\\text{survivor}_1],\\,[\\text{elim\\_order}_2,\\text{survivor}_2],\\,\\dots\\,]\n$$\n其中每个 $\\text{elim\\_order}_i$ 是一个整数列表，每个 $\\text{survivor}_i$ 是一个整数。不涉及任何物理单位或角度；所有输出都纯粹是整数和整数列表。",
            "solution": "该问题要求使用一个特制的循环队列来模拟约瑟夫环淘汰过程。解决方案将分为两个主要部分：一个按规定实现循环队列的类，以及一个使用该类为给定参数 $n$、$k$ 和 $s$ 运行模拟的函数。\n\n首先，我们设计 `CircularQueue` 类。它将由一个固定容量的 NumPy 数组支持，因为这对于存储同类的整数标签集合是高效的。队列的状态由三个属性管理：`front`，一个指向第一个元素的索引；`rear`，一个指向下一个可用元素槽位的索引；以及 `size`，队列中当前的元素数量。所有索引操作都将使用相对于队列容量的模运算，以确保循环行为。核心操作是 `enqueue`（添加到队尾）、`dequeue`（从队首移除）和 `get_size`。\n\n其次，我们设计模拟函数 `josephus_simulation(n, k, s)`。此函数按照问题陈述中概述的方式组织整个过程。\n1. **初始化**：给定 $n$，创建一个容量为 $n$ 的 `CircularQueue`。将代表人员的整数标签从 $1$ 到 $n$ 按顺序入队。\n2. **起始对齐**：计数必须从第 $s$ 个人开始。初始队列中第 $1$ 个人在队首。为了将第 $s$ 个人移到队首，我们必须将队列旋转 $s-1$ 次。一次旋转被精确定义为一次 `dequeue` 操作后跟一次相同元素的 `enqueue` 操作。这将队首元素移到队尾，使队伍前进。\n3. **淘汰循环**：模拟的核心是一个循环，只要队列中的人数大于 $1$ 就持续进行。在循环的每次迭代中：\n    a. 从队列的大小获取当前人数 $m$。\n    b. 为了找到要淘汰的第 $k$ 个人，我们必须从当前队首开始将计数推进 $k-1$ 个位置。这通过将队列旋转 $k-1$ 次来完成。问题正确地指出，对于大小为 $m$ 的圈，旋转 $r$ 次等同于旋转 $r \\pmod m$ 次。因此，我们执行 $(k-1) \\pmod m$ 次旋转。\n    c. 旋转之后，队列 `front` 位置的人就是计数中的第 $k$ 个人。通过执行一次 `dequeue` 操作来淘汰此人。出队的标签被附加到一个 `elimination_order` 列表中。\n4. **终止**：当队列中只剩下一个人时，循环终止。这最后一个人就是幸存者。通过最后一次 `dequeue` 操作将他们从队列中移除。\n5. **结果**：函数返回一个列表，其中包含 `elimination_order` 列表和单个整数 `survivor`。\n\n这种结构化方法将问题的形式化规范直接映射到一个具体的算法中，确保了正确性并遵守了所有约束。使用自定义的 `CircularQueue` 类是满足问题要求的核心。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass CircularQueue:\n    \"\"\"\n    An array-backed circular queue with fixed capacity, front and rear pointers,\n    and a size counter, as specified in the problem.\n    \"\"\"\n    def __init__(self, capacity: int):\n        if capacity = 0:\n            raise ValueError(\"Capacity must be a positive integer.\")\n        self.capacity = capacity\n        # Using np.zeros of dtype=int for the underlying array\n        self.data = np.zeros(capacity, dtype=int)\n        self.front = 0\n        self.rear = 0\n        self.size = 0\n\n    def is_empty(self) - bool:\n        \"\"\"Returns True if the queue is empty.\"\"\"\n        return self.size == 0\n\n    def is_full(self) - bool:\n        \"\"\"Returns True if the queue is full.\"\"\"\n        return self.size == self.capacity\n\n    def enqueue(self, item: int):\n        \"\"\"Adds an item to the rear of the queue.\"\"\"\n        if self.is_full():\n            # This condition should not be met in the context of this problem\n            # as the queue size only decreases after initial setup.\n            raise OverflowError(\"Queue is full\")\n        self.data[self.rear] = item\n        self.rear = (self.rear + 1) % self.capacity\n        self.size += 1\n\n    def dequeue(self) - int:\n        \"\"\"Removes and returns the item from the front of the queue.\"\"\"\n        if self.is_empty():\n            raise IndexError(\"Dequeue from an empty queue\")\n        item = self.data[self.front]\n        self.front = (self.front + 1) % self.capacity\n        self.size -= 1\n        return int(item)\n\n    def get_size(self) - int:\n        \"\"\"Returns the current number of items in the queue.\"\"\"\n        return self.size\n\ndef josephus_simulation(n: int, k: int, s: int) - list:\n    \"\"\"\n    Simulates the Josephus problem using a circular queue.\n\n    Args:\n        n: The total number of people.\n        k: The counting step for elimination.\n        s: The starting label for the count.\n\n    Returns:\n        A list containing two elements:\n        1. A list of the eliminated people in order.\n        2. The integer label of the survivor.\n    \"\"\"\n    if n = 0:\n        # Based on problem \"1 through n\", n must be >= 1.\n        # This handles the degenerate case, returning an empty result.\n        return [[], None]\n\n    # Step 1  2: Initialize queue and enqueue all people\n    q = CircularQueue(n)\n    for i in range(1, n + 1):\n        q.enqueue(i)\n\n    # Step 3: Align the queue so the starting person 's' is at the front.\n    # This requires s-1 rotations.\n    for _ in range(s - 1):\n        q.enqueue(q.dequeue())\n\n    elimination_order = []\n    \n    # Step 4: Elimination loop\n    while q.get_size()  1:\n        current_size = q.get_size()\n        \n        # Determine number of rotations to get to the k-th person.\n        # This is k-1 steps. Use modulo for efficiency.\n        rotations = (k - 1) % current_size\n        \n        # Rotate the queue to bring the k-th person to the front\n        for _ in range(rotations):\n            q.enqueue(q.dequeue())\n            \n        # Dequeue the front element (the one to be eliminated)\n        eliminated = q.dequeue()\n        elimination_order.append(eliminated)\n\n    # Step 5: The last person remaining is the survivor\n    survivor = None\n    if not q.is_empty():\n        survivor = q.dequeue()\n\n    return [elimination_order, survivor]\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print the final output.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (7, 3, 1),\n        (5, 2, 1),\n        (10, 1, 1),\n        (1, 5, 1),\n        (6, 7, 2),\n        (8, 100, 4),\n    ]\n\n    results = []\n    for n, k, s in test_cases:\n        result = josephus_simulation(n, k, s)\n        results.append(result)\n\n    # The final print must match the specified format. Using map(str,...)\n    # on lists will generate representations with spaces (e.g., '[1, 2]'),\n    # which is the standard Python behavior and implied by the template.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}