{
    "hands_on_practices": [
        {
            "introduction": "标准的队列操作（入队和出队）只在两端进行。本练习将挑战你实现一个更复杂的操作：在队列中间查找并移除一个特定元素。通过处理移除头节点、尾节点或中间节点等不同情况，你将能更深入地掌握链表操作的细节，并为构建更复杂的数据结构打下坚实的基础。",
            "id": "3246760",
            "problem": "你需要使用一个带有显式头指针和尾指针的单向链表来实现一个先进先出队列。该队列必须支持三个以纯逻辑术语定义的操作：`enqueue` 用于追加一个元素，`dequeue` 用于移除并返回队首的元素，`find_and_remove` 用于移除第一个其存储值等于给定查询值的节点。你必须从队列作为一种抽象数据类型的核心定义以及单向链表的标准属性出发：\n- 队列存储元素的方式应确保，通过 `dequeue` 操作移除的元素始终是队列中停留时间最长的元素，这与先进先出的按到达顺序排列的不变性一致。\n- 单向链表由节点组成，每个节点包含一个值和一个指向下一个节点的指针。头指针引用第一个节点，尾指针引用最后一个节点；如果链表为空，则尾指针为空。\n- 如果头指针和尾指针得到一致的维护，那么在队尾进行 `enqueue` 和在队首进行 `dequeue` 的标准操作可以在时间复杂度 $\\mathcal{O}(1)$ 内实现。\n\n你的任务：\n- 使用单向链表实现一个队列类，维护头指针和尾指针。`enqueue` 必须在队尾以 $\\mathcal{O}(1)$ 时间插入，`dequeue` 必须在队首以 $\\mathcal{O}(1)$ 时间移除，并在队列为空时返回一个特定的空值。`find_and_remove` 必须从头到尾扫描，如果存在给定整数，则移除其第一次出现（即，在值相等的元素中最早入队的那个）。`find_and_remove` 操作必须返回一个布尔值，以指示是否发生了移除操作。\n- 你必须确保在每次操作后，数据结构都维持以下不变性：头指针指向第一个节点（如果队列为空则为 null），尾指针指向最后一个节点（如果队列为空则为 null），并且尾指针为 null 当且仅当头指针为 null。特别地，在通过 `find_and_remove` 移除头节点或尾节点后，相应的指针必须被正确更新，且该结构必须保持为一个有效的单向链表。\n\n语义和约束：\n- 队列中存储的值是整数。相等性是标准的整数相等性。对于 `find_and_remove` 操作，队列必须只移除第一个匹配的节点，这与队列的顺序属性一致。如果没有匹配的节点存在，`find_and_remove` 必须返回 false 并且不执行任何结构性更改。\n- `dequeue` 操作返回的特定空值必须是一个不会在队列中作为整数出现的值；在支持引用的语言中，自然的选择是空引用。你必须确保即使在对空队列执行 `dequeue` 操作后，内部结构仍然保持有效。\n\n测试套件：\n你必须精确地实现并运行以下固定的测试用例，无需从输入中读取。对于每个测试用例，按顺序应用所列出的操作。每个操作是以下之一：\n- enqueue $x$\n- dequeue\n- find\\_and\\_remove $x$\n\n对于每个测试用例，你的程序必须产生一个单一的结果，该结果是一个扁平的整数列表，由两部分串联而成：\n- 从头到尾的最终队列内容，编码为一个整数列表。\n- 一个分隔符值 $-1$，后跟此测试用例中每次 `find_and_remove` 操作结果的二进制指示符序列，其中 $1$ 表示成功，$0$ 表示失败。\n在任何测试用例中，整数 $-1$ 都不会被入队；它被保留用作输出编码中的分隔符。\n\n五个测试用例如下：\n- 测试用例 $1$（正常路径，中间删除，删除不存在的元素以及多次出队）：\n  - enqueue $3$, enqueue $1$, enqueue $4$, enqueue $1$, enqueue $5$, enqueue $9$, find\\_and\\_remove $4$, find\\_and\\_remove $2$, dequeue, dequeue.\n- 测试用例 $2$（头部删除，尾部删除，以及对空队列执行出队）：\n  - enqueue $10$, enqueue $20$, find\\_and\\_remove $10$, find\\_and\\_remove $20$, dequeue.\n- 测试用例 $3$（在非平凡队列中进行尾部删除并进一步入队）：\n  - enqueue $7$, enqueue $8$, enqueue $9$, find\\_and\\_remove $9$, enqueue $10$.\n- 测试用例 $4$（重复值，重复移除首次出现的元素直至队列为空，然后失败）：\n  - enqueue $1$, enqueue $1$, enqueue $1$, find\\_and\\_remove $1$, find\\_and\\_remove $1$, find\\_and\\_remove $1$, find\\_and\\_remove $1$.\n- 测试用例 $5$（通过 `find_and_remove` 删除单个元素，之后删除失败）：\n  - enqueue $42$, find\\_and\\_remove $42$, enqueue $5$, dequeue, find\\_and\\_remove $5$.\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含五个测试用例各自的结果，以逗号分隔并用方括号括起来的列表形式。每个测试用例的结果本身也是一个用方括号括起来、以逗号分隔且无空格的整数列表。例如，一个包含 $3$ 个测试用例的输出应如下所示：$[ [\\ldots], [\\ldots], [\\ldots] ]$，但其中不含任何空格。\n- 具体来说，对于此任务，你的程序必须打印完全符合 $[r_1,r_2,r_3,r_4,r_5]$ 形式的单行输出，其中每个 $r_i$ 是如上所述对测试用例 $i$ 的结果进行编码的无空格整数列表。\n\n此问题不涉及物理单位或角度单位。所有答案均为纯整数和编码为整数的布尔值。\n\n你的程序必须是自包含的，除了指定的单行输出外，不得读取任何输入或写入任何其他输出。",
            "solution": "问题陈述已经过严格验证，并被认为是有效的。它在数据结构和算法领域提出了一个定义明确、具有科学依据的问题。使用单向链表实现队列的要求，包括具体操作 `enqueue`、`dequeue` 和 `find_and_remove`，都清晰、一致且完整。测试用例和输出格式的规定足够精确，可以得出一个唯一且可验证的解决方案。\n\n该实现将基于单向链表和先进先出（FIFO）队列的基本原理。单向链表是数据元素的线性集合，这些元素称为节点，其中每个节点指向序列中的下一个节点。为了高效地实现队列，我们维护两个指针：一个指向第一个节点的 `$head$` 指针和一个指向最后一个节点的 `$tail$` 指针。\n\n核心数据结构是 `Node` 和 `Queue` 本身。\n- `Node` 包含两个字段：一个 `$value$`（根据题目要求，是一个整数）和一个 `$next$` 指针，该指针引用后续节点，如果它是最后一个节点，则为 `$null$`。\n- `Queue` 类封装了链表，并维护三个状态：`$head$` 指针、`$tail$` 指针以及隐式地，元素的数量。必须严格保持 `$head$ 为 $null$` 当且仅当 `$tail$ 为 $null$` 这一不变性。\n\n三个所需操作的实现如下：\n\n1.  **入队操作**：`$enqueue(x)$` 操作将一个值为 `$x$` 的元素添加到队列的尾部。通过操作 `$tail$` 指针，这可以在常数时间 $\\mathcal{O}(1)$ 内完成。\n    - 创建一个值为 `$x$` 的新 `Node`。\n    - 如果队列为空（即 `$head$` 为 `$null$`），则 `$head$` 和 `$tail$` 都被设置为指向这个新节点。\n    - 如果队列不为空，当前 `$tail$` 节点的 `$next$` 指针被更新为指向新节点，然后 `$tail$` 指针本身也被更新为这个新节点。这样就正确地将元素追加到了列表的末尾。\n\n2.  **出队操作**：`$dequeue()` 操作移除并返回队列头部的元素。通过操作 `$head$` 指针，这可以在常数时间 $\\mathcal{O}(1)$ 内完成。\n    - 如果队列为空（`$head$` 为 `$null$`），则按要求返回一个特定的 `$null$` 值，并且结构保持不变。\n    - 如果队列不为空，存储 `$head$` 节点的值以供返回。\n    - `$head$` 指针前移，指向列表中的下一个节点（`$head = head.next$`）。\n    - 关键步骤是检查移除后队列是否变空。如果新的 `$head$` 为 `$null$`，这意味着刚刚移除了最后一个元素，因此 `$tail$` 指针也必须设置为 `$null$`，以维护队列的结构完整性。\n\n3.  **查找并删除操作**：`$find\\_and\\_remove(x)$` 操作搜索第一个包含值 `$x$` 的节点，并将其从队列中移除。此操作需要遍历，其时间复杂度为 $\\mathcal{O}(n)$，其中 `$n$` 是队列中元素的数量。它必须在成功移除时返回 `$True$`，否则返回 `$False$`，并在所有情况下正确更新指针。\n    - **情况1：空队列。** 如果 `$head$` 为 `$null$`，则找不到该值，函数立即返回 `$False$`。\n    - **情况2：头节点匹配。** 如果 `$head.value$` 等于 `$x$`，问题简化为移除头元素。这可以通过简单调用现有的 `$dequeue()` 方法来完成，该方法能正确处理所有指针更新。然后函数返回 `$True$`。\n    - **情况3：非头节点匹配。** 必须遍历列表。我们使用两个指针，`$previous$` 和 `$current$`，起始时 `$previous = head$` 且 `$current = head.next$`。循环在 `$current$` 不为 `$null$` 的条件下进行。\n        - 如果 `$current.value$` 等于 `$x$`，我们就找到了要移除的节点。`$previous$` 节点的 `$next$` 指针被设置为绕过 `$current$` 节点（`$previous.next = current.next$`）。\n        - 这里需要一个特殊检查：如果被移除的节点是 `$tail$`（`$current == tail$`），那么 `$tail$` 指针必须更新为指向 `$previous$`。\n        - 成功移除节点后，函数返回 `$True$`。\n    - 如果遍历完成而没有找到匹配的值，函数返回 `$False$`。\n\n此设计严格遵守问题规范，确保在所有操作中都维护了所有不变性，并且正确处理了如空队列、单元素队列以及移除头或尾元素等边界情况。\n\n提供的测试套件将对此实现进行执行，以验证其正确性并生成指定的输出格式。每个测试用例都将在一个全新的 `Queue` 实例上运行。每个测试用例的最终结果是通过将队列中剩余的值列表（从头到尾）、一个分隔符值 `$-1$` 以及来自 `$find\\_and\\_remove$` 调用的布尔结果序列（`$1$` 代表 `$True$`，`$0$` 代表 `$False$`）连接起来而构建的。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass Node:\n    \"\"\"A node in a singly linked list.\"\"\"\n    def __init__(self, value, next_node=None):\n        self.value = value\n        self.next = next_node\n\nclass Queue:\n    \"\"\"A FIFO queue implemented using a singly linked list.\"\"\"\n    def __init__(self):\n        \"\"\"Initializes an empty queue.\"\"\"\n        self.head = None\n        self.tail = None\n\n    def enqueue(self, value):\n        \"\"\"Adds an element to the tail of the queue in O(1) time.\"\"\"\n        new_node = Node(value)\n        if self.head is None:\n            self.head = new_node\n            self.tail = new_node\n        else:\n            self.tail.next = new_node\n            self.tail = new_node\n\n    def dequeue(self):\n        \"\"\"Removes and returns the element from the head of the queue in O(1) time.\"\"\"\n        if self.head is None:\n            return None  # Distinguished null value for an empty queue\n        \n        value = self.head.value\n        self.head = self.head.next\n        \n        if self.head is None:\n            self.tail = None  # The queue is now empty\n        \n        return value\n\n    def find_and_remove(self, value):\n        \"\"\"Finds and removes the first occurrence of a value from the queue.\"\"\"\n        if self.head is None:\n            return False\n\n        # Case 1: The head node needs to be removed.\n        if self.head.value == value:\n            self.dequeue()\n            return True\n\n        # Case 2: A non-head node needs to be removed.\n        # We need a previous pointer to re-link the list.\n        prev = self.head\n        current = self.head.next\n        while current is not None:\n            if current.value == value:\n                prev.next = current.next\n                # If the removed node was the tail, update the tail pointer.\n                if current == self.tail:\n                    self.tail = prev\n                return True\n            prev = current\n            current = current.next\n\n        # Case 3: Value not found.\n        return False\n\n    def get_contents(self):\n        \"\"\"Returns the contents of the queue as a list of integers.\"\"\"\n        items = []\n        current = self.head\n        while current is not None:\n            items.append(current.value)\n            current = current.next\n        return items\n\ndef solve():\n    \"\"\"\n    Runs the entire test suite and prints the final result.\n    \"\"\"\n    test_cases = [\n        [\"enqueue 3\", \"enqueue 1\", \"enqueue 4\", \"enqueue 1\", \"enqueue 5\", \"enqueue 9\", \"find_and_remove 4\", \"find_and_remove 2\", \"dequeue\", \"dequeue\"],\n        [\"enqueue 10\", \"enqueue 20\", \"find_and_remove 10\", \"find_and_remove 20\", \"dequeue\"],\n        [\"enqueue 7\", \"enqueue 8\", \"enqueue 9\", \"find_and_remove 9\", \"enqueue 10\"],\n        [\"enqueue 1\", \"enqueue 1\", \"enqueue 1\", \"find_and_remove 1\", \"find_and_remove 1\", \"find_and_remove 1\", \"find_and_remove 1\"],\n        [\"enqueue 42\", \"find_and_remove 42\", \"enqueue 5\", \"dequeue\", \"find_and_remove 5\"]\n    ]\n\n    all_results = []\n\n    for operations in test_cases:\n        q = Queue()\n        find_remove_outcomes = []\n        for op_str in operations:\n            parts = op_str.split()\n            command = parts[0]\n            \n            if command == \"enqueue\":\n                value = int(parts[1])\n                q.enqueue(value)\n            elif command == \"dequeue\":\n                q.dequeue()\n            elif command == \"find_and_remove\":\n                value = int(parts[1])\n                success = q.find_and_remove(value)\n                find_remove_outcomes.append(1 if success else 0)\n\n        final_contents = q.get_contents()\n        result_list = final_contents + [-1] + find_remove_outcomes\n        all_results.append(result_list)\n    \n    # Format the final output string exactly as specified, with no spaces.\n    print(str(all_results).replace(\" \", \"\"))\n\nsolve()\n```"
        },
        {
            "introduction": "在某些应用场景（如 LRU 缓存）中，我们需要一种特殊的队列行为：当一个已存在项目再次入队时，它会被移到队尾。本练习要求你在 $O(1)$ 的时间复杂度内实现这一功能，这迫使你超越简单的单链表，去设计一种由双向链表和哈希表组合而成的复合数据结构。这个练习将向你展示，性能需求是如何驱动数据结构设计的，并让你掌握一种经典而高效的设计模式。",
            "id": "3246702",
            "problem": "您需要使用链表实现一个队列，该队列满足以下语义：当一个元素 $x$ 入队时，如果 $x$ 已存在于队列中，则将包含 $x$ 的现有节点移动到队尾；如果 $x$ 不存在，则将一个存储 $x$ 的新节点追加到队尾。执行出队操作时，移除队头元素。元素为整数。初始队列是一个由不同整数组成的序列。在此任务中，要执行的操作仅为一系列入队操作，并严格按照给定顺序应用。目标是在所有操作完成后，生成从队头到队尾的最终队列内容。\n\n用于推导和实现的基本原理和约束：\n- 队列是一种抽象数据类型，其典型策略是先进先出（FIFO）。其最小不变量是：队头是下一个要被移除的元素，队尾是最近追加的元素，并且链接必须保持从队头到队尾的节点的单线性顺序。\n- 链表是节点的集合，每个节点存储一个值和指向相邻节点的指针。为了支持高效的重新链接，节点必须能够在保持单线性顺序不变量和头/尾引用的同时被断开链接和追加。\n- 正确性要求每次操作后，头指针和尾指针都有效，并且节点序列形成从头到尾的单链，没有循环，也没有悬空指针。\n\n您的实现必须使用链表结构来维护队列，并确保入队和出队操作的单次操作最坏情况时间复杂度均为 $O(1)$。程序应完全确定，并且不得依赖随机化。\n\n您将获得一个测试套件，其中包含多个案例，每个案例由一个初始队列和一个入队序列组成。对于每个案例，应用这些操作并输出最终的队列内容，格式为一个整数列表（从队头到队尾）。元素是整数，初始队列没有重复项。入队序列可能包含重复项。\n\n测试套件：\n- 案例 $1$：初始队列 $[1,2,3]$，入队序列 $[2,4,2]$。预期行为：将一个内部元素移动到队尾，追加一个新元素，然后再次移动队尾元素。\n- 案例 $2$：初始队列 $[]$，入队序列 $[5,5,5]$。预期行为：向一个空结构中追加元素，然后重复移动队尾元素（这在第一次追加后不会改变结构）。\n- 案例 $3$：初始队列 $[10,20]$，入队序列 $[10,30,20,30]$。预期行为：将队头移动到队尾，追加一个新元素，再次将队头移动到队尾，然后将一个中间元素移动到队尾。\n- 案例 $4$：初始队列 $[1,2,3,4]$，入队序列 $[3,1,4,5,3]$。预期行为：多次移动队头和中间元素，并追加一个新元素。\n- 案例 $5$：初始队列 $[0,1,2,3,4]$，入队序列 $[2,2,3,4,5,0,5,6]$。预期行为：重复移动包括队头和中间位置在内的元素，并进行多次追加。\n\n要求的最终输出格式：\n您的程序应生成单行输出，其中包含所有案例的结果，这些结果聚合为一个由方括号括起来的逗号分隔列表，每个案例的结果本身也是一个由方括号括起来的逗号分隔列表。例如，输出格式为 $[[r_1,r_2,\\dots],[s_1,s_2,\\dots],\\dots]$。\n\n您的程序不得读取任何输入，并且必须在内部包含测试套件。每个案例的答案必须是整数列表。",
            "solution": "用户指定了一个问题，要求实现一个具有特殊入队语义的队列，并受到严格的性能约束。我将首先根据要求的协议验证问题陈述。\n\n### 步骤 1：提取给定信息\n- **数据结构**：用链表实现的队列。\n- **元素类型**：整数 (`...are integers.`)。\n- **初始状态**：一个由不同整数组成的序列 (`The initial queue is a sequence of distinct integers.`)。\n- **`enqueue(x)` 语义**：\n    1. 如果元素 $x$ 已存在于队列中，则将包含 $x$ 的节点移动到队尾。\n    2. 如果元素 $x$ 不存在，则将一个存储 $x$ 的新节点追加到队尾。\n- **`dequeue()` 语义**：移除队头元素 (`Dequeue, when performed, removes the item at the head.`)。\n- **此任务的操作**：仅为一系列入队操作 (`The operations to be performed are a sequence of enqueues only for this task...`)。\n- **性能约束**：入队和出队操作的最坏情况时间复杂度必须为 $O(1)$ (`...ensure that both enqueue and dequeue operations run in worst-case O(1) time per operation.`)。\n- **目标**：对每个测试案例，在所有指定的入队操作完成后，确定从队头到队尾的最终队列内容。\n- **测试套件**：\n    - 案例 $1$：初始队列 $[1,2,3]$，入队序列 $[2,4,2]$。\n    - 案例 $2$：初始队列 $[]$，入队序列 $[5,5,5]$。\n    - 案例 $3$：初始队列 $[10,20]$，入队序列 $[10,30,20,30]$。\n    - 案例 $4$：初始队列 $[1,2,3,4]$，入队序列 $[3,1,4,5,3]$。\n    - 案例 $5$：初始队列 $[0,1,2,3,4]$，入队序列 $[2,2,3,4,5,0,5,6]$。\n- **输出格式**：一个表示列表的列表的单行字符串，例如 `[[r_1,r_2,...],[s_1,s_2,...],...]`。\n\n### 步骤 2：使用提取的给定信息进行验证\n对问题进行严格的验证检查。\n\n1.  **科学依据**：该问题描述了一种队列的变体，队列是计算机科学中的一种基础数据结构。指定的 `enqueue` 行为，即将现有元素移动到末尾，是缓存算法中使用的数据结构的特征（例如，与最近最少使用（LRU）缓存相关的某些策略）。该问题牢固地植根于已有的数据结构和算法原理。它在科学上是合理的。\n\n2.  **良构性**：问题提供了初始条件、一组确定性的操作和一个明确的目标。对于任何给定的输入，队列的最终状态是唯一确定的。因此，存在唯一且有意义的解。\n\n3.  **客观性**：问题以精确、客观的语言陈述。“队列”、“链表”、“队头”、“队尾”等术语以及操作语义都是该领域的标准术语。\n\n4.  **缺陷分析**：问题的核心在于性能约束：`enqueue` 必须在 $O(1)$ 的最坏情况时间内运行。使用简单链表的朴素实现需要一个搜索操作来检查元素是否存在，这需要 $O(n)$ 时间，其中 $n$ 是队列中的元素数量。这似乎是一个矛盾。然而，这不是一个缺陷，而是这个问题的核心设计挑战。为了实现 $O(1)$ 的查找，需要一个辅助数据结构。哈希表（或字典）可以将元素值映射到其在链表中的相应节点，从而实现 $O(1)$ 的平均时间查找。为了满足在 $O(1)$ 时间内移动任意节点的要求，链表必须是双向链表，因为这允许在不预先搜索其前驱节点的情况下将节点从其邻居中解开。双向链表和哈希表的组合是解决此类问题的标准且易于理解的模式。因此，该问题并非不完整或自相矛盾；它含蓄地要求解决者推导并应用这种特定的复合数据结构设计。\n\n### 步骤 3：结论与行动\n该问题是**有效的**。这是一个在数据结构设计方面良构且有实质内容的问题，它测试了对时间复杂度的理解以及为满足性能目标而综合不同数据结构的能力。我将继续提供完整的解决方案。\n\n### 基于原则的设计与解决方案\n\n该问题要求实现一个队列，其中 `enqueue` 操作在常数时间 $O(1)$ 内完成。此操作有两种情况：追加一个新元素或将现有元素移动到队尾。后一种情况需要快速的查找和快速的重新链接操作。\n\n**1. 时间复杂度约束分析**\n\n$O(1)$ 时间约束决定了数据结构的选择。`enqueue(x)` 操作涉及两个主要子任务：\n- **查找**：确定元素 $x$ 是否存在于队列中，如果存在，则找到其位置。对链表的顺序扫描需要线性时间 $O(n)$，这违反了约束。需要一个能提供常数时间查找的结构。哈希表（在 Python 中是字典）为插入、删除和查找提供了平均情况为 $O(1)$ 的时间复杂度。我们将假定这满足 $O(1)$ 约束的精神，这在算法分析中是常见的做法。\n- **重定位**：如果一个元素存在，其对应的节点必须从当前位置移动到队列的尾部。为了在 $O(1)$ 时间内从链表中移除一个节点，需要一个指向该节点本身的指针，并且必须能够更新其前驱和后继节点的指针。在单向链表中，找到给定节点的前驱需要遍历，耗时 $O(n)$。在**双向链表**中，每个节点都维护指向其 `next` 和 `prev` 节点的指针。给定一个指向节点的直接指针，可以通过设置 `node.prev.next = node.next` 和 `node.next.prev = node.prev` 在 $O(1)$ 时间内将其解开链接。\n\n**2. 复合数据结构设计**\n\n基于以上分析，最优解决方案是一个由**双向链表**和**哈希表**组成的复合数据结构。\n\n- **双向链表**将按从`队头`到`队尾`的精确顺序存储队列元素。列表中的每个节点将包含整数值、一个 `prev` 指针和一个 `next` 指针。队列本身将维护 `head` 和 `tail` 指针，以便在 $O(1)$ 时间内访问列表的两端。\n- **哈希表**将用作索引。它将把队列中存在的每个整数值映射到其在双向链表中对应节点对象的直接引用。这允许在 $O(1)$ 平均时间内通过其值找到任何节点。\n\n**3. `enqueue(x)` 算法**\n\n`enqueue` 方法将实现如下：\n1.  使用哈希表检查值 $x$ 是否存在。这是一个 $O(1)$ 的平均时间查找。\n2.  **情况 A：元素 $x$ 存在。**\n    a. 从哈希表中检索 `node` 引用。\n    b. 如果此 `node` 不是列表的 `tail`，则必须移动它。\n    c. 将 `node` 从其当前位置解开链接。在双向链表中这是一个 $O(1)$ 操作。它涉及更新该节点前驱的 `next` 指针和其后继的 `prev` 指针。如果被解开链接的节点是 `head`，则需特别注意。\n    d. 将 `node` 追加到列表的末尾。这也是一个 $O(1)$ 操作，涉及更新旧 `tail` 的 `next` 指针和队列的 `tail` 指针。\n3.  **情况 B：元素 $x$ 不存在。**\n    a. 创建一个值为 $x$ 的新 `Node` 实例。\n    b. 将这个新 `node` 追加到双向链表的尾部。这是一个 $O(1)$ 操作。如果列表为空，则将 `head` 和 `tail` 指针都设置为这个新节点。\n    c. 在哈希表中添加一个新条目，将值 $x$ 映射到新创建的 `node`。这是一个 $O(1)$ 的平均时间插入。\n\n此设计确保 `enqueue` 操作中的每一步都在常数（平均）时间内执行，满足了问题的性能要求。`dequeue` 操作的逻辑，尽管在测试套件中未执行，同样也是 $O(1)$：它将涉及移除 `head` 节点，更新 `head` 指针，并从哈希表中删除相应的条目。\n\n现在将通过将此设计应用于提供的测试套件来实施解决方案。每个案例都将通过初始化复合数据结构，然后应用入队操作序列来处理。链表的最终状态，从头到尾读取，构成该案例的结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Move-to-Tail Queue problem for a given test suite.\n    \"\"\"\n\n    class Node:\n        \"\"\"\n        A node in a doubly linked list.\n        \"\"\"\n        def __init__(self, value):\n            self.value = value\n            self.prev = None\n            self.next = None\n\n    class MoveToTailQueue:\n        \"\"\"\n        A queue implementation using a doubly linked list and a hash map\n        to achieve O(1) time complexity for the specified enqueue operation.\n        \"\"\"\n        def __init__(self, initial_items=None):\n            self.head = None\n            self.tail = None\n            self.map = {}\n            if initial_items:\n                for item in initial_items:\n                    self.enqueue(item)\n\n        def _unlink(self, node):\n            \"\"\"\n            Unlinks a node from the list in O(1) time.\n            Assumes node is not None and is in the list.\n            \"\"\"\n            prev_node = node.prev\n            next_node = node.next\n\n            if prev_node:\n                prev_node.next = next_node\n            else: # Node was the head\n                self.head = next_node\n\n            if next_node:\n                next_node.prev = prev_node\n            else: # Node was the tail\n                self.tail = prev_node\n\n        def _append(self, node):\n            \"\"\"\n            Appends a node to the tail of the list in O(1) time.\n            \"\"\"\n            if not self.head: # List is empty\n                self.head = node\n                self.tail = node\n                node.prev = None\n                node.next = None\n            else: # List is not empty\n                self.tail.next = node\n                node.prev = self.tail\n                node.next = None\n                self.tail = node\n\n        def enqueue(self, value):\n            \"\"\"\n            Enqueues an item. If it exists, moves it to the tail.\n            If not, adds it to the tail. O(1) average time complexity.\n            \"\"\"\n            if value in self.map:\n                node = self.map[value]\n                # Only move if it's not already the tail\n                if node is not self.tail:\n                    self._unlink(node)\n                    self._append(node)\n            else:\n                new_node = Node(value)\n                self._append(new_node)\n                self.map[value] = new_node\n\n        def to_list(self):\n            \"\"\"\n            Returns the queue content as a list from head to tail.\n            \"\"\"\n            result = []\n            current = self.head\n            while current:\n                result.append(current.value)\n                current = current.next\n            return result\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'initial': [1,2,3], 'enqueues': [2,4,2]},\n        {'initial': [],      'enqueues': [5,5,5]},\n        {'initial': [10,20], 'enqueues': [10,30,20,30]},\n        {'initial': [1,2,3,4], 'enqueues': [3,1,4,5,3]},\n        {'initial': [0,1,2,3,4], 'enqueues': [2,2,3,4,5,0,5,6]},\n    ]\n\n    results = []\n    for case in test_cases:\n        queue = MoveToTailQueue(case['initial'])\n        for item in case['enqueues']:\n            queue.enqueue(item)\n        results.append(queue.to_list())\n\n    # Final print statement in the exact required format.\n    # Format: [[r1,r2,...],[s1,s2,...],...] with no spaces after commas.\n    print(f\"[[{'],['.join([','.join(map(str, r)) for r in results])}]]\")\n\nsolve()\n```"
        },
        {
            "introduction": "数据结构不仅仅是理论概念，更是解决实际问题的强大工具。本练习将队列应用到一个具体的模拟场景中：为一个层级组织中的信息流（如请求上传和指令下达）建模。你需要使用你实现的链表队列作为基本构建块，在一个树形结构上模拟复杂的轮询合并与分发逻辑。这个实践将帮助你理解如何将基础数据结构集成为复杂算法的一部分，从而解决更宏大的问题。",
            "id": "3246732",
            "problem": "您的任务是使用单向链表实现一个先入先出（FIFO）队列，并用它来模拟一个层级组织中的请求传播。该层级结构是一个有根树，其中每个节点代表指挥链中的一个位置。您的程序必须模拟两种传播方向：请求从叶节点向根节点上传，以及指令从根节点向下达。解决方案必须完全依赖于链表的基本定义和FIFO队列的不变性，并且必须从这些基础上推导出其正确性，不得使用任何捷径公式。\n\n基本原理：\n- 队列是先入先出（FIFO）的，意味着元素按其插入顺序被移除。基于链表的队列维护一个头指针和一个尾指针，使得无论队列长度如何，从队尾入队和从队头出队的时间复杂度均为 $O(1)$。\n- 单向链表由节点组成，每个节点包含一个值和一个指向下一个节点的指针。在基于链表的队列中，入队操作是在当前尾节点之后附加一个新节点并更新尾指针；出队操作是移除头节点并前移头指针。\n\n层级模型：\n- 该组织被建模为一个有根树 $T$，节点由非负整数标记。根节点的索引为 $0$。对于任何节点 $u$，其子节点由一个整数索引列表给出。子节点按索引递增顺序处理。\n- 向上传播：每个叶节点持有一个初始的请求（整数）FIFO队列。在任何内部节点 $u$，您需要将其子队列中的请求合并到 $u$ 的一个新FIFO队列中。合并方式是按子节点索引递增的顺序进行轮询，每一轮从每个非空子队列的队头取至多一个元素，并保持每个子队列内部的FIFO顺序。这个合并后的队列随后向上传播到父节点。根节点的合并队列将被完全出队，以产生根节点的最终处理序列。\n- 向下传播：根节点持有一个指令（整数）FIFO队列。每个内部节点 $u$ 使用轮询方式将其入站FIFO队列中的指令转发给其子节点（按索引递增顺序）：每当 $u$ 从其队列中取出一个指令时，它会将该指令放入轮询顺序中下一个子节点的入站FIFO队列，并前移其子节点指针。当一个指令到达叶节点时，在该指令于叶节点出队的瞬间，即视为已在该叶节点送达。指令到达的叶节点索引序列构成了向下传播的结果。\n\n您的实现要求：\n- 实现一个具有 enqueue、dequeue、peek 和 is_empty 操作的单向链表队列。所有操作必须维护队列的不变性，并为 enqueue 和 dequeue 提供 $O(1)$ 的时间复杂度。\n- 使用此队列实现来模拟所述的向上和向下传播。核心队列操作不得使用基于数组的队列捷径。\n\n测试套件：\n为以下三个测试用例提供结果。\n\n测试用例 $1$（向上传播，一般情况）：\n- 树的邻接关系（子节点列表）：节点 $0$ 的子节点为 $[1,2]$，节点 $1$ 的子节点为 $[3,4]$，节点 $2$ 的子节点为 $[5]$，节点 $3,4,5$ 是叶节点。\n- 叶节点请求队列：节点 $3$ 有 $[101,103]$，节点 $4$ 有 $[102]$，节点 $5$ 有 $[104,105]$。\n- 预期行为：节点 $1$ 轮询合并 $[3,4]$ 产生 $[101,102,103]$；节点 $2$ 产生 $[104,105]$；根节点轮询合并子节点 $[1,2]$ 产生最终的根处理顺序 $[101,104,102,105,103]$。\n\n测试用例 $2$（向上传播，含空队列的边界情况）：\n- 树的邻接关系：节点 $0$ 的子节点为 $[1,4]$，节点 $1$ 的子节点为 $[2]$，节点 $2$ 的子节点为 $[3]$，节点 $3$ 和 $4$ 是叶节点。\n- 叶节点请求队列：节点 $3$ 有 $[201,202,203]$，节点 $4$ 有 $[]$（空）。\n- 预期行为：根节点轮询合并子节点 $[1,4]$；由于节点 $4$ 为空，最终的根处理顺序为 $[201,202,203]$。\n\n测试用例 $3$（向下传播，一般情况）：\n- 树的邻接关系：节点 $0$ 的子节点为 $[1,2,3]$，节点 $1$ 的子节点为 $[4]$，节点 $2$ 的子节点为 $[5]$，节点 $3$ 的子节点为 $[6]$，节点 $4,5,6$ 是叶节点。\n- 根指令队列：$[31,32,33,34,35]$。\n- 转发策略：在每个内部节点，按子节点索引递增顺序进行轮询。\n- 预期行为：指令被转发，使得叶节点按叶节点索引序列 $[4,5,6,4,5]$ 接收到指令。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[result1,result2,result3]$），其中每个 $resulti$ 是一个表示该测试用例最终序列的整数列表。对于指定的测试套件，单行输出必须是一个包含三个列表的列表，按顺序对应于测试用例 1、2 和 3。",
            "solution": "该问题要求使用单向链表实现一个先入先出（FIFO）队列，并将其应用于模拟树状层级结构中的两种信息流——向上和向下。解决方案的正确性必须从这些数据结构的基本原理中推导出来。\n\n首先，我们建立核心数据结构：一个基于单向链表的FIFO队列。单向链表是一系列节点的序列，其中每个节点包含一个数据负载和一个指向序列中下一个节点的引用（或指针）。对于我们的队列，我们定义一个`Node`结构，它持有一个`value`和一个`next`指针。`Queue`本身维护两个指针：`head`，指向第一个节点，和`tail`，指向最后一个节点。这种双指针设计对于实现所需的时间复杂度至关重要。\n\n基本的队列操作实现如下：\n- **入队 (Enqueue)**：一个元素被添加到队列的尾部。创建一个具有给定值的新`Node`。通过将`tail.next`设置为新节点，将此新节点附加到当前`tail`节点之后。然后`tail`指针更新为此新节点。如果队列为空（`head`和`tail`都为`None`），则两个指针都设置为新节点。此操作仅涉及几次指针操作，使其时间复杂度为 $O(1)$。\n- **出队 (Dequeue)**：一个元素从队列的前端被移除。检索`head`节点的值。然后`head`指针前进到`head.next`。如果此操作使队列变空（`head`变为`None`），则`tail`指针也必须设置为`None`以维护队列的不变性。此操作的时间复杂度也为 $O(1)$。\n- **查看队首 (Peek)**：此操作返回`head`节点的值而不移除它。这是一个 $O(1)$ 操作。\n- **判空 (Is_empty)**：检查队列是否为空，如果`head`为`None`则为真。这是一个 $O(1)$ 检查。\n\n然后，问题指定了在有根树 $T$ 上的两种传播模型。该树由邻接表定义，其中每个节点 $u$ 都关联一个其子节点的列表，这些子节点按其整数索引排序。\n\n**向上传播模型：**\n此模型模拟了从层级结构的叶节点到根节点的请求聚合。该过程是递归定义的，对应于树的后序遍历。\n对于树 $T$ 中的任何节点 $u$：\n1.  **基本情况**：如果 $u$ 是一个叶节点，其队列用给定的请求列表进行初始化。\n2.  **递归步骤**：如果 $u$ 是一个内部节点，我们首先递归地计算其所有子节点的队列。然后，通过合并其子节点的队列来构建 $u$ 的队列。合并过程是一个轮询过程，按子节点指定的递增索引顺序执行。在每一轮中，我们尝试从每个非空子队列的前端取出一个元素，并将其入队到 $u$ 的队列中。这个过程持续到所有子队列都为空。这种轮询策略确保了来自不同子节点的元素是交错的，同时保留了源自同一子节点的元素的FIFO顺序。\n\n向上传播测试用例的最终结果是通过完全清空为根节点（节点 $0$）计算的队列而获得的元素序列。\n\n**向下传播模型：**\n此模型模拟了指令从根节点分发到叶节点的过程。该过程由根节点的初始指令队列驱动。与向上传播不同，指令是逐个处理的，每个指令在下一个指令被处理之前，都会从根节点遍历到叶节点。\n1.  树中的每个内部节点 $u$ 必须维护一个状态以处理对其子节点的轮询分发。这个状态可以是一个简单的计数器 `next_child_ptr`，指示接收下一个指令的子节点的索引。\n2.  模拟从根节点的队列中取出第一个指令开始。\n3.  对于一个给定的指令，会从根节点向下追踪一条路径。在这条路径上的任何内部节点 $v$ 处，该节点会查询其 `next_child_ptr` 来选择一个子节点，将指令转发给该子节点，然后为其将要处理的下一个指令递增其 `next_child_ptr`（循环递增）。\n4.  此遍历持续进行，直到指令到达一个叶节点。该叶节点的索引被记录为指令的到达目的地。\n5.  对根节点初始队列中的每个指令重复此整个过程。向下传播测试用例的最终结果是指令到达的叶节点索引的有序序列。\n\n通过从第一性原理实现`Queue`类，然后基于这些严格定义的模型构建`solve_upward`和`solve_downward`过程，我们可以模拟测试用例并产生所需的结果。所提供的测试用例，包括其预期结果，用于确认对这些模型的正确解释，特别是向下传播的微妙机制。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# A meticulous and exacting implementation of a singly linked-list based queue.\n\nclass Node:\n    \"\"\"\n    A node in a singly linked list.\n    \"\"\"\n    def __init__(self, value):\n        self.value = value\n        self.next = None\n\nclass Queue:\n    \"\"\"\n    A FIFO queue implemented using a singly linked list.\n    All core operations (enqueue, dequeue) are O(1).\n    \"\"\"\n    def __init__(self):\n        self.head = None\n        self.tail = None\n        self._size = 0\n\n    def is_empty(self):\n        \"\"\"Checks if the queue is empty. O(1).\"\"\"\n        return self.head is None\n\n    def enqueue(self, value):\n        \"\"\"Adds an element to the back of the queue. O(1).\"\"\"\n        new_node = Node(value)\n        if self.is_empty():\n            self.head = new_node\n            self.tail = new_node\n        else:\n            self.tail.next = new_node\n            self.tail = new_node\n        self._size += 1\n\n    def dequeue(self):\n        \"\"\"Removes and returns the element from the front of the queue. O(1).\"\"\"\n        if self.is_empty():\n            raise IndexError(\"dequeue from an empty queue\")\n        \n        value = self.head.value\n        self.head = self.head.next\n        if self.head is None:\n            self.tail = None\n        self._size -= 1\n        return value\n\n    def peek(self):\n        \"\"\"Returns the value of the front element without removing it. O(1).\"\"\"\n        if self.is_empty():\n            return None\n        return self.head.value\n\n    def size(self):\n        \"\"\"Returns the number of elements in the queue. O(1).\"\"\"\n        return self._size\n\n    def to_list(self):\n        \"\"\"Drains the queue and returns its elements as a list.\"\"\"\n        result = []\n        while not self.is_empty():\n            result.append(self.dequeue())\n        return result\n\ndef solve_upward(adj, leaf_queues_data):\n    \"\"\"\n    Solves for upward propagation.\n    Uses a post-order traversal (recursive with memoization) to build queues up the tree.\n    \"\"\"\n    memo = {}\n    \n    all_nodes = set(adj.keys())\n    for children in adj.values():\n        all_nodes.update(children)\n    \n    leaves = {node for node in all_nodes if node not in adj or not adj[node]}\n\n    def get_or_compute_queue(node_id):\n        if node_id in memo:\n            return memo[node_id]\n\n        # Base case: Leaf node\n        if node_id in leaves:\n            q = Queue()\n            for item in leaf_queues_data.get(node_id, []):\n                q.enqueue(item)\n            memo[node_id] = q\n            return q\n        \n        # Recursive step: Internal node\n        child_queues = [get_or_compute_queue(child_id) for child_id in adj[node_id]]\n        \n        merged_queue = Queue()\n        \n        # Round-robin merge\n        active_children = True\n        while active_children:\n            active_children = False\n            for child_q in child_queues:\n                if not child_q.is_empty():\n                    merged_queue.enqueue(child_q.dequeue())\n                    active_children = True\n        \n        memo[node_id] = merged_queue\n        return merged_queue\n\n    root_queue = get_or_compute_queue(0)\n    return root_queue.to_list()\n\n\ndef solve_downward(adj, root_directives):\n    \"\"\"\n    Solves for downward propagation.\n    Simulates item by item, with each internal node maintaining round-robin state.\n    \"\"\"\n    leaves = set()\n    all_nodes = set(adj.keys())\n    for children in adj.values():\n        all_nodes.update(children)\n    for node in all_nodes:\n        if node not in adj or not adj[node]:\n            leaves.add(node)\n\n    root_queue = Queue()\n    for directive in root_directives:\n        root_queue.enqueue(directive)\n        \n    # State for round-robin at each internal node\n    rr_state = {node_id: 0 for node_id in adj if adj[node_id]}\n    \n    arrival_sequence = []\n    \n    while not root_queue.is_empty():\n        directive = root_queue.dequeue()\n        current_node = 0\n        \n        while current_node not in leaves:\n            children = adj[current_node]\n            child_ptr = rr_state[current_node]\n            next_node = children[child_ptr]\n            \n            # Update state for next time\n            rr_state[current_node] = (child_ptr + 1) % len(children)\n            \n            current_node = next_node\n            \n        arrival_sequence.append(current_node)\n        \n    return arrival_sequence\n\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final output.\n    \"\"\"\n    test_cases = [\n        {\n            \"type\": \"upward\",\n            \"adj\": {0: [1, 2], 1: [3, 4], 2: [5]},\n            \"data\": {3: [101, 103], 4: [102], 5: [104, 105]}\n        },\n        {\n            \"type\": \"upward\",\n            \"adj\": {0: [1, 4], 1: [2], 2: [3]},\n            \"data\": {3: [201, 202, 203], 4: []}\n        },\n        {\n            \"type\": \"downward\",\n            \"adj\": {0: [1, 2, 3], 1: [4], 2: [5], 3: [6]},\n            \"data\": [31, 32, 33, 34, 35]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        if case[\"type\"] == \"upward\":\n            result = solve_upward(case[\"adj\"], case[\"data\"])\n            results.append(result)\n        elif case[\"type\"] == \"downward\":\n            result = solve_downward(case[\"adj\"], case[\"data\"])\n            results.append(result)\n\n    # Format the final output string to match the required format `[[...],[...]]`\n    # by removing spaces from the default string representation of a list of lists.\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```"
        }
    ]
}