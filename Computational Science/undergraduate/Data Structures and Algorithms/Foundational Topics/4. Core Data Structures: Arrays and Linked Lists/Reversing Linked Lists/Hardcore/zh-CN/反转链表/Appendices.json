{
    "hands_on_practices": [
        {
            "introduction": "反转链表指定区间的子链表是掌握链表操作的核心基本功。这个练习  将帮助你深入理解指针操作的精髓：如何精确地断开链表的一部分，在内部进行反转，然后无缝地重新连接回去。熟练掌握这项技能是解决更复杂链表问题的关键第一步。",
            "id": "3267063",
            "problem": "给定一个单向链表，它被建模为一种抽象数据类型（ADT），其中每个节点包含一个值和一个指向下一个节点的指针。此问题的基础是单向链表的定义：一个节点序列，其中每个节点包含一个数据项和指向其后继节点的指针。可用的核心操作是指针重定向和遍历，每个节点的操作时间为常数时间。目标是设计一个纯粹基于指针操作的算法，以反转从位置 $m$ 到 $n$（含两端）的连续子链表，位置采用 1-基索引。\n\n形式上，对于一个长度为 $L$ 的链表，位置 $m$ 和 $n$ 必须满足 $1 \\leq m \\leq n \\leq L$ 才能进行有效的反转。如果输入违反此条件（即 $m  1$、$n  L$ 或 $m  n$），则输出必须是未经修改的原始链表。必须正确处理 $m = 1$ 和 $n = L$ 的边界情况，这两种情况分别对应从链表头部开始反转和反转至链表尾部。该算法必须在 $O(L)$ 时间内运行，并使用 $O(1)$ 的辅助空间，通过原地修改链表而不分配任何新节点来完成。\n\n你的任务是实现这个算法，并将其应用于以下测试套件。每个测试用例是一个三元组 $(A, m, n)$，其中 $A$ 是输入的整数列表，$m$ 是待反转子链表的起始位置，$n$ 是结束位置。位置使用 1-基索引。\n\n测试套件：\n- 用例 1：$A = [1,2,3,4,5,6,7]$，$m = 3$，$n = 5$。\n- 用例 2：$A = [10,20,30,40]$，$m = 1$，$n = 3$。\n- 用例 3：$A = [5,6,7,8]$，$m = 3$，$n = 4$。\n- 用例 4：$A = [9,8,7]$，$m = 2$，$n = 2$。\n- 用例 5：$A = [1,2,3]$，$m = 1$，$n = 3$。\n- 用例 6：$A = [1,2,3]$，$m = 0$，$n = 2$。\n- 用例 7：$A = [1,2]$，$m = 1$，$n = 3$。\n- 用例 8：$A = []$，$m = 1$，$n = 1$。\n\n对于每个用例，输出必须是应用所述反转规则后得到的结果链表。最终输出格式必须是单行字符串，其中包含八个测试用例的结果，聚合为一个由逗号分隔的列表的列表，并用方括号括起来，行内任何位置都不能有空白字符。例如，最终输出的形式必须是 $[[a_1],[a_2],\\dots,[a_8]]$，其中每个 $[a_i]$ 是用例 $i$ 的结果列表，以整数形式表示。所有用例的答案都是整数列表。",
            "solution": "在单向链表中反转一个连续子链表的问题，是一个关于指针操作的明确练习，这是数据结构中的一个基本概念。解决方案必须遵守严格的性能约束，即在 $O(1)$ 辅助空间内进行原地修改，并且时间复杂度为 $O(L)$，其中 $L$ 是链表的长度。\n\n### 问题验证\n经过严格验证，确认问题陈述是合理且可解的。\n\n**1. 已知条件提取：**\n- **数据结构：** 单向链表。\n- **目标：** 反转从位置 $m$ 到位置 $n$ 的子链表（采用 1-基索引）。\n- **约束：** 仅当 $1 \\leq m \\leq n \\leq L$ 时操作有效，其中 $L$ 是链表长度。若不满足此条件，必须返回原始链表。\n- **性能：** 时间复杂度 $O(L)$，空间复杂度 $O(1)$。不得分配新节点。\n- **测试套件：** 提供了八个测试用例，涵盖了标准操作、边界情况（$m=n$、反转整个链表）以及无效输入（$m1$、$n>L$、空链表）。\n\n**2. 验证结论：**\n该问题是**有效的**。它在科学上基于计算机科学的既定原则，特别是数据结构和算法。问题陈述清晰，为得到唯一且有意义的解提供了所有必要的条件、约束和定义。语言客观且正式。该问题提出了一个非平凡的算法挑战，是该领域的标准课题，满足有效问题陈述的所有标准。\n\n### 算法解决方案\n该算法主要分三个阶段进行：验证与定位、原地反转以及重新连接。我们使用一个虚拟头节点（dummy head node）来简化指针逻辑，特别是当反转从链表头部开始（$m=1$）的边界情况。\n\n**阶段 1：验证与定位**\n\n1.  **计算链表长度：** 首先，我们通过从头到尾遍历链表来确定其长度 $L$。这需要 $O(L)$ 时间。\n2.  **输入验证：** 我们检查给定的位置 $m$ 和 $n$ 是否满足条件 $1 \\leq m \\leq n \\leq L$。如果它们不满足，根据规定，算法终止并返回未经修改的原始链表头。此步骤正确处理了用例 6、7 和 8 中的无效输入。像空链表（$L=0$）或反转单个元素（$m=n$）等特殊情况也自然地被此逻辑处理。如果 $m=n$，待反转子链表的长度为 1，反转循环将正确地不执行任何更改。\n\n3.  **子链表定位：** 为了修改链表，我们必须确定精确的连接点。\n    - 创建一个 `dummy` 节点，使得 `dummy.next` 指向原始链表的头节点。这简化了对 $m=1$ 情况的处理，因为需要修改的指针（`dummy.next`）永远不会是头节点本身。\n    - 我们从 `dummy` 节点开始遍历 $m-1$ 步，以定位到待反转子链表的前一个节点。此节点被指定为 `pre_m`。它的 `next` 指针当前指向位置 $m$ 的节点，后续需要重新连接。\n    - 位置为 $m$ 的节点，即 `pre_m.next`，是待反转子链表的起始点。我们称之为 `start_of_reversal`。反转后，该节点将成为反转后子链表的尾部。\n\n**阶段 2：原地子链表反转**\n\n算法的核心是反转长度为 $n-m+1$ 的子链表。这通过一个迭代方法完成，该方法使用三个指针，通常命名为 `prev`、`curr` 和 `next_node`。\n\n1.  **初始化：** 反转过程在从 `start_of_reversal` 开始的子链表上启动。我们将 `prev` 指针初始化为 `None`，`curr` 指针初始化为 `start_of_reversal`。\n2.  **迭代：** 我们迭代 $n-m+1$ 次。在每次迭代中：\n    a. `next_node` 指针临时存储对原始序列中下一个节点（`curr.next`）的引用。\n    b. `curr` 节点的 `next` 指针被反转，指向 `prev`。\n    c. `prev` 指针前进到 `curr`。\n    d. `curr` 指针前进到 `next_node`。\n\n经过 $n-m+1$ 次迭代后，`prev` 将指向原先在位置 $n$ 的节点（反转后子链表的新头部），而 `curr` 将指向原先在位置 $n+1$ 的节点（链表剩余部分的开始）。\n\n**阶段 3：重新连接**\n\n最后一步是通过操作在阶段 1 中识别的指针，将反转后的子链表重新连接到主链表中。\n\n1.  **连接第一部分：** `pre_m`（子链表之前的节点）的 `next` 指针更新为指向 `prev`（反转后子链表的新头部）。\n2.  **连接第二部分：** `start_of_reversal`（现在是反转后子链表的尾部）的 `next` 指针更新为指向 `curr`（跟在子链表后面的节点）。\n\n通过这两次重新连接，链表的结构完整性得以恢复，现在包含了反转后的子链表。可能被修改过的链表的头节点是 `dummy.next`，它作为最终结果返回。整个过程使用了常数数量的辅助指针变量，因此实现了 $O(1)$ 的空间复杂度；并且涉及对链表或其部分的常数次遍历，从而使总体时间复杂度为 $O(L)$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass ListNode:\n    \"\"\"\n    Definition for a singly-linked list node.\n    \"\"\"\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef create_linked_list(items):\n    \"\"\"\n    Helper function to create a singly linked list from a list of items.\n    \"\"\"\n    if not items:\n        return None\n    head = ListNode(items[0])\n    current = head\n    for item in items[1:]:\n        current.next = ListNode(item)\n        current = current.next\n    return head\n\ndef linked_list_to_list(head):\n    \"\"\"\n    Helper function to convert a singly linked list back to a Python list.\n    \"\"\"\n    items = []\n    current = head\n    while current:\n        items.append(current.val)\n        current = current.next\n    return items\n\ndef reverse_sublist(head, m, n):\n    \"\"\"\n    Reverses a sublist of a singly linked list from position m to n.\n    1-based indexing is used.\n    \"\"\"\n    # Phase 1: Validation and Localization\n    if not head:\n        return None\n\n    # Calculate length L\n    length = 0\n    curr = head\n    while curr:\n        length += 1\n        curr = curr.next\n\n    # Validate m and n against list properties\n    if not (1 = m = n = length):\n        return head\n    \n    # Trivial case: no reversal needed\n    if m == n:\n        return head\n\n    # Use a dummy node to simplify edge cases (m=1)\n    dummy = ListNode(0, head)\n    \n    # Traverse to the node before the reversal segment\n    pre_m = dummy\n    for _ in range(m - 1):\n        pre_m = pre_m.next\n    \n    # Identify the start of the reversal segment\n    start_of_reversal = pre_m.next\n\n    # Phase 2: In-place Sublist Reversal\n    prev = None\n    curr = start_of_reversal\n    num_reversals = n - m + 1\n    \n    for _ in range(num_reversals):\n        next_node = curr.next\n        curr.next = prev\n        prev = curr\n        curr = next_node\n\n    # Phase 3: Reconnection\n    # prev is now the new head of the reversed sublist\n    # curr is the node that was originally at position n+1\n    # start_of_reversal is the original node m, now the tail of the reversed sublist\n    \n    pre_m.next = prev\n    start_of_reversal.next = curr\n    \n    return dummy.next\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and generate the final output.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        ([1,2,3,4,5,6,7], 3, 5),\n        ([10,20,30,40], 1, 3),\n        ([5,6,7,8], 3, 4),\n        ([9,8,7], 2, 2),\n        ([1,2,3], 1, 3),\n        ([1,2,3], 0, 2),\n        ([1,2], 1, 3),\n        ([], 1, 1),\n    ]\n\n    results = []\n    for case in test_cases:\n        list_data, m, n = case\n        head = create_linked_list(list_data)\n        \n        # Apply the reversal algorithm\n        result_head = reverse_sublist(head, m, n)\n        \n        # Convert the resulting linked list back to a Python list\n        result_list = linked_list_to_list(result_head)\n        results.append(result_list)\n\n    # Format the final output as a comma-separated list of lists, with no whitespace.\n    result_strings = [str(res).replace(' ', '') for res in results]\n    final_output = f\"[{','.join(result_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "链表反转不仅是一种基础操作，更是一种强大的问题解决工具。本练习  展示了一个巧妙的两步算法思想：先对整个链表进行全局反转，再对其中的每个单词进行局部反转，从而实现单词顺序的逆序。这个练习不仅能让你领会到反转操作在高级算法设计中的应用，还能将你的技能扩展到双向链表。",
            "id": "3266919",
            "problem": "给定一个由字符组成的双向链表 (DLL)，它表示一个基于 Unicode 基本拉丁字符集的有限句子。每个节点存储一个字符，对于每个具有前驱节点 `x.prev` 和后继节点 `x.next` 的节点 $x$，双向链表的不变性是 $(`x.prev` \\neq \\varnothing) \\Rightarrow (`x.prev.next` = x)$ 和 $(`x.next` \\neq \\varnothing) \\Rightarrow (`x.next.prev` = x)$。该句子被定义为一个有限的字符序列 $S$，编码为一个带有头节点 $h$ 和尾节点 $t$ 的双向链表，其中节点的顺序与句子的顺序完全对应。\n\n定义“单词”(word)为非空格字符的任意最大连续序列，定义“空格序列”(space-run)为单个空格字符的任意最大连续序列。形式上，让句子 $S$ 被划分为交替的序列 $R_1, R_2, \\dots, R_k$，其中每个 $R_i$ 要么是一个单词（所有字符 $\\neq$ 空格字符），要么是一个空格序列（所有字符 $=$ 空格字符）。这些序列是最大的，因此按顺序连接所有序列会重现原始句子。像逗号或字母这样的字符被简单地视为非空格字符，因此是单词序列的一部分。问题要求反转单词序列的顺序，同时保留每个单词序列内部的字符顺序，并保留每个空格序列内部的字符顺序。等价地，将最大序列的顺序从 $R_1, \\dots, R_k$ 反转为 $R_k, \\dots, R_1$，同时不反转任何序列内部的字符。\n\n从双向链表和指针交换操作的核心定义出发，推导出一个算法，该算法对给定的双向链表进行 in-place 转换，最多使用 $O(1)$ 的辅助空间和 $O(n)$ 的时间，其中 $n$ 是节点数。您的算法不能构建字符或单词的辅助数组；它必须通过操作现有节点的 `prev` 和 `next` 指针来运行。您需要：\n- 通过单次指针交换来反转整个双向链表，从而反转节点的全局序列。\n- 然后，在反转后的双向链表中识别每个最大单词序列，并反转该序列内的指针，以恢复单词的内部字符顺序。空格序列除了因全局反转而发生的隐式重定位外，不应被更改。\n\n为了测试，您的程序必须是自包含的（无输入），并将转换应用于以下作为双向链表的句子测试套件：\n- $S_1$: \"the sky is blue\"\n- $S_2$: \"  hello   world  \"\n- $S_3$: \"\" (the empty string)\n- $S_4$: \"     \" (five spaces)\n- $S_5$: \"solitary\"\n- $S_6$: \"mix  of   words and  spaces\"\n\n对于每个测试句子，您的程序必须将结果句子输出为 Unicode 码点（整数）的列表。最终的输出格式必须是单行，包含一个由方括号括起来的、逗号分隔的各个测试用例列表的列表，不含空格。例如，您的程序应生成一行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，`[[a11,a12,...],[b11,b12,...],...]`），其中每个内部列表对应一个测试用例，每个元素是一个整数码点。不应打印任何其他文本。",
            "solution": "## 问题验证\n\n### 步骤 1：提取给定信息\n\n1.  **数据结构**：一个由 Unicode 基本拉丁字符集中的字符组成的双向链表 (DLL)。\n2.  **节点定义**：每个节点 $x$ 具有属性 `x.char`、`x.prev` 和 `x.next`。\n3.  **双向链表不变性**：对于任何节点 $x$，如果 `x.prev` 不为 null ($\\varnothing$)，则 `x.prev.next` = x。如果 `x.next` 不为 null ($\\varnothing$)，则 `x.next.prev` = x。\n4.  **句子表示**：一个有限的字符序列 $S$ 被编码为一个双向链表，其中节点顺序与句子顺序匹配。\n5.  **序列定义**：\n    *   “单词”(word) 是非空格字符的最大连续序列。\n    *   “空格序列”(space-run) 是单个空格字符的最大连续序列。\n    *   句子 $S$ 是划分为交替序列 $R_1, R_2, \\dots, R_k$ 的分区。\n6.  **任务**：将序列 $R_1, \\dots, R_k$ 的顺序反转为 $R_k, \\dots, R_1$。每个序列内部的字符顺序必须保留。\n7.  **约束**：\n    *   转换必须是“in-place”的。\n    *   辅助空间复杂度最多为 $O(1)$。\n    *   时间复杂度必须为 $O(n)$，其中 $n$ 是节点数。\n    *   算法不得构建字符或单词的辅助数组。\n8.  **指定算法**：\n    *   首先，通过单次指针交换反转整个双向链表。\n    *   其次，在现已全局反转的双向链表中识别每个最大单词序列，并反转该序列内的指针以恢复其原始字符顺序。\n9.  **测试用例**：\n    *   $S_1$: \"the sky is blue\"\n    *   $S_2$: \"  hello   world  \"\n    *   $S_3$: \"\" (the empty string)\n    *   $S_4$: \"     \" (five spaces)\n    *   $S_5$: \"solitary\"\n    *   $S_6$: \"mix  of   words and  spaces\"\n10. **输出格式**：对于每个测试用例，生成一个 Unicode 码点（整数）列表。最终输出必须是单行：一个由方括号括起来的、逗号分隔的这些列表的列表。例如：`[[a11,a12,...],[b11,b12,...],...]`。\n\n### 步骤 2：使用提取的给定信息进行验证\n\n根据验证标准评估问题陈述：\n\n*   **科学基础**：该问题植根于计算机科学领域，特别是数据结构和算法。它使用双向链表及其操作的形式化标准定义。所有概念在逻辑和数学上都是合理的。\n*   **适定性**：该问题是适定的。输入被清晰定义（一个表示句子的双向链表）。期望的输出被明确指定（一个表示单词反转后句子的双向链表）。对时间和空间复杂度的约束，以及 in-place 操作的要求，定义了一个精确的算法挑战，对此存在唯一且有意义的解决方案。\n*   **客观性**：问题以精确、客观的语言陈述。诸如“最大连续序列”之类的术语被正式定义。约束和所需的输出格式是定量的且明确的。\n\n该问题没有表现出任何使其无效的缺陷：\n1.  **科学或事实不健全**：无。该问题遵循数据结构操作的原则。\n2.  **不可形式化或不相关**：该问题是形式化的，并与链表操作的主题直接相关。\n3.  **不完整或矛盾的设置**：该问题是自包含的，并提供了所有必要的定义和约束。指定的两步算法与实现最终目标是一致的。\n4.  **不切实际或不可行**：这些约束对于此类算法问题是标准的，并且完全可行。\n5.  **不适定或结构不良**：该问题结构良好，能够导出一个唯一的、稳定的解决方案。\n6.  **伪深刻、琐碎或同义反复**：该问题是指针操作的一个非平凡练习，需要仔细实现以满足 in-place 和复杂性约束。\n7.  **超出科学可验证性**：所得算法的正确性可以通过给定的测试用例进行形式化证明和经验验证。\n\n### 步骤 3：结论与行动\n\n该问题是**有效的**。将提供一个解决方案。\n\n## 算法推导与解决方案\n\n问题要求在由双向链表 (DLL) 表示的句子中，对单词进行 in-place 反转，严格要求时间复杂度为 $O(n)$，空间复杂度为 $O(1)$，其中 $n$ 是字符（节点）的数量。解决方案遵循问题陈述所要求的两遍扫描法。\n\n### 数据结构\n\nDLL 中的节点由三个字段定义：`char` 用于存储字符，`prev` 是指向前一个节点的指针，`next` 是指向后一个节点的指针。列表由指向第一个节点的 `head` 指针和两端的空指针（`head` 的 `prev` 为 `null`，尾节点的 `next` 为 `null`）界定。\n\n### 第一遍：全局反转双向链表\n\n第一步是反转整个双向链表。此操作交换列表的头和尾，并反转所有节点的顺序。对于像 \"the sky is blue\" 这样的句子，这一遍的结果将是表示 \"eulb si yks eht\" 的双向链表。\n\n这个反转可以通过对列表的一次遍历来完成。我们使用一个从 `head` 开始的 `current` 指针遍历列表。对于访问的每个节点，我们交换其 `prev` 和 `next` 指针。如果语言支持元组赋值（例如，`current.prev, current.next = current.next, current.prev`），则不一定需要临时变量。交换后，原始的 `next` 指针现在位于 `current.prev` 字段中，因此我们通过将 `current` 指针赋值为 `current.prev` 的值来推进它。\n\n循环过程如下：\n设 `current` 为指向正在处理的节点的指针，初始化为 `head`。\n设 `new_head` 为一个指针，初始化为 `null`。\n当 `current` 不为 `null` 时：\n1.  将 `current` 存储在 `new_head` 中，因为访问的最后一个节点将成为反转后列表的新头节点。\n2.  设 `original_next = current.next`。\n3.  交换指针：`current.next = current.prev` 和 `current.prev = original_next`。\n4.  前进到原始序列中的下一个节点：`current = original_next`。\n\n步骤 2-4 的更紧凑写法是：\n1.  设 `temp = current.prev`。\n2.  `current.prev = current.next`。\n3.  `current.next = temp`。\n4.  `current = current.prev` (因为 `current.prev` 现在持有原始的 `next` 指针)。\n\n在这一遍之后，它访问了 $n$ 个节点中的每一个一次，双向链表被全局反转。这一遍需要 $O(n)$ 的时间和 $O(1)$ 的辅助空间用于像 `current` 和 `new_head` 这样的指针。原始的尾节点现在是列表的头节点。\n\n### 第二遍：反转单个单词序列\n\n第二步纠正每个单词的内部顺序。在第一遍之后，句子 \"the sky is blue\" 变成了 \"eulb si yks eht\"。单词处于期望的最终顺序，但每个单词内部是反转的。我们现在必须遍历这个新列表，并将每个单词序列反转回其原始拼写。\n\n我们用一个指针（比如 `current`）从新的 `head` 开始遍历全局反转的列表。\n1.  我们寻找一个单词的开头，即一个字符不是空格的节点。\n2.  当找到一个单词的起始位置（我们称之为 `word_start`）时，我们从这个节点向前扫描，以找到该单词序列的结尾。结尾 `word_end` 是最后一个连续的非空格字符节点。\n3.  我们现在有了一个从 `word_start` 到 `word_end` 的子列表段，需要进行 in-place 反转。我们还必须跟踪紧邻该段之前的节点 (`before_word = word_start.prev`) 和之后的节点 (`after_word = word_end.next`)，以便将反转后的段正确地重新链接回主列表中。\n4.  子列表 `[word_start, ..., word_end]` 的反转与全局反转类似。我们从 `word_start` 迭代到 `word_end`，交换段中每个节点的 `prev` 和 `next` 指针。\n5.  在段内的指针被交换后，`word_start` 和 `word_end` 的角色实际上互换了。原始的 `word_end` 是段的新开始，而原始的 `word_start` 是新的结尾。我们必须小心地将该段重新连接到列表的其余部分：\n    *   如果 `before_word` 存在，它的 `next` 指针现在必须指向该段的新起点（即原始的 `word_end`）。\n    *   该段新起点的 `prev` 指针必须指向 `before_word`。\n    *   如果 `after_word` 存在，它的 `prev` 指针现在必须指向该段的新终点（即原始的 `word_start`）。\n    *   该段新终点的 `next` 指针必须指向 `after_word`。\n    *   如果 `before_word` 为 `null`，这意味着该单词位于列表的开头。在这种情况下，整个列表的 `head` 必须更新为指向该段的新起点（即原始的 `word_end`）。\n6.  在一个单词被反转并重新链接后，我们的主遍历从 `after_word` 继续。如果 `current` 节点是空格，我们只需前进到下一个节点。\n\n这第二遍也以常数次数访问每个节点（扫描一次，如果它是一个被反转的单词的一部分，则再访问一次）。因此，它的时间复杂度也为 $O(n)$，空间复杂度为 $O(1)$。总复杂度保持为 $O(n)$ 时间和 $O(1)$ 空间，满足所有问题约束。这个两遍指针操作算法正确地对句子进行了 in-place 转换。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass Node:\n    \"\"\"\n    Represents a node in a Doubly Linked List.\n    \"\"\"\n    def __init__(self, char: str):\n        self.char = char\n        self.prev = None\n        self.next = None\n\ndef string_to_dll(s: str) - Node | None:\n    \"\"\"\n    Builds a Doubly Linked List from a string.\n    Returns the head of the list.\n    \"\"\"\n    if not s:\n        return None\n    \n    head = Node(s[0])\n    current = head\n    for char in s[1:]:\n        new_node = Node(char)\n        current.next = new_node\n        new_node.prev = current\n        current = new_node\n    return head\n\ndef dll_to_ord_list(head: Node | None) - list[int]:\n    \"\"\"\n    Converts a Doubly Linked List back to a list of Unicode code points.\n    \"\"\"\n    ords = []\n    current = head\n    while current:\n        ords.append(ord(current.char))\n        current = current.next\n    return ords\n\ndef reverse_words_in_dll(head: Node | None) - Node | None:\n    \"\"\"\n    Reverses the words in a sentence represented by a DLL, in-place.\n    \"\"\"\n    if not head or not head.next:\n        return head\n\n    # --- Pass 1: Reverse the entire DLL ---\n    # This pass reverses the order of all characters.\n    # e.g., \"the sky\" - \"yks eht\"\n    current = head\n    new_head = None\n    while current:\n        new_head = current  # The last non-null node visited will be the new head.\n        # Swap prev and next pointers\n        temp_prev = current.prev\n        current.prev = current.next\n        current.next = temp_prev\n        # Move to the next node in the original list\n        current = current.prev\n\n    head = new_head\n\n    # --- Pass 2: Reverse each word run ---\n    # This pass corrects the order of characters within each word.\n    # e.g., \"yks eht\" - \"sky the\"\n    current = head\n    while current:\n        if current.char != ' ':\n            # Found the start of a reversed word.\n            word_start = current\n            \n            # Find the end of this word run.\n            runner = word_start\n            while runner.next and runner.next.char != ' ':\n                runner = runner.next\n            word_end = runner\n            \n            # Store the nodes connecting this segment to the rest of the list.\n            before_word = word_start.prev\n            after_word = word_end.next\n            \n            # Reverse the pointers within the word sublist [word_start...word_end].\n            p = word_start\n            while True:\n                # This loop correctly reverses a segment of a DLL.\n                temp_next = p.next\n                p.next, p.prev = p.prev, p.next\n                if p == word_end:\n                    break\n                p = temp_next\n\n            # Relink the reversed word segment back into the main list.\n            # The original word_end is now the start of the segment.\n            word_end.prev = before_word\n            if before_word:\n                before_word.next = word_end\n            else:\n                # If there was no node before, this word is at the start of the list.\n                head = word_end\n            \n            # The original word_start is now the end of the segment.\n            word_start.next = after_word\n            if after_word:\n                after_word.prev = word_start\n            \n            # Continue scanning from the node after the processed word.\n            current = after_word\n        else:\n            # It's a space, just move to the next node.\n            current = current.next\n            \n    return head\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and print the final output.\n    \"\"\"\n    test_cases = [\n        \"the sky is blue\",\n        \"  hello   world  \",\n        \"\",\n        \"     \",\n        \"solitary\",\n        \"mix  of   words and  spaces\",\n    ]\n\n    results_as_strings = []\n    for s in test_cases:\n        # 1. Convert the input string to a DLL.\n        head_node = string_to_dll(s)\n        \n        # 2. Apply the in-place word reversal algorithm.\n        transformed_head = reverse_words_in_dll(head_node)\n        \n        # 3. Convert the resulting DLL to the required list of code points.\n        result_ords = dll_to_ord_list(transformed_head)\n        \n        # 4. Format the list of integers as a string \"[i1,i2,...]\".\n        results_as_strings.append(f\"[{','.join(map(str, result_ords))}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_as_strings)}]\")\n\nsolve()\n```"
        }
    ]
}