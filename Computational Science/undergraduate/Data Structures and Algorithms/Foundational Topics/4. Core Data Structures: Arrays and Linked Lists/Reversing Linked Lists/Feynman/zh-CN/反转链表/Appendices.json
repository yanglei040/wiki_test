{
    "hands_on_practices": [
        {
            "introduction": "第一个练习侧重于反转链表中特定片段的核心机制。掌握这种精准的指针操作是解决所有其他反转相关问题的基础。你将学习如何仔细地分离出子链表，反转其方向，然后无缝地重新连接它，同时要特别注意处理如从头部开始反转等关键的边界情况 。",
            "id": "3267063",
            "problem": "给定一个单向链表，它被建模为一种抽象数据类型（ADT），其中每个节点包含一个值和一个指向下一个节点的指针。本问题的基础是单向链表的定义：一个节点序列，其中每个节点包含一个数据项及其指向后继节点的指针。可用的核心操作是指针重定向和遍历，这些操作对于每个节点都是常数时间复杂度的。目标是设计一个纯粹基于指针操作的算法，以反转从位置$m$到$n$（含两端）的连续子链表，位置采用1-based索引。\n\n形式上，对于一个长度为$L$的链表，位置$m$和$n$必须满足$1 \\le m \\le n \\le L$才能进行有效的反转。如果输入违反了此条件（即$m  1$、$n > L$或$m > n$），则输出必须是未经修改的原始链表。必须正确处理$m = 1$和$n = L$的边界情况，即分别从链表头部开始反转以及反转至链表尾部。算法必须在$O(L)$时间内运行，并使用$O(1)$的辅助空间，通过原地修改链表而不分配任何新节点来完成操作。\n\n您的任务是实现此算法，并将其应用于以下测试套件。每个测试用例是一个三元组$(A, m, n)$，其中$A$是输入的整数列表，$m$是待反转子链表的起始位置，$n$是结束位置。位置使用1-based索引。\n\n测试套件：\n- 用例 $1$：$A = [1,2,3,4,5,6,7]$, $m = 3$, $n = 5$。\n- 用例 $2$：$A = [10,20,30,40]$, $m = 1$, $n = 3$。\n- 用例 $3$：$A = [5,6,7,8]$, $m = 3$, $n = 4$。\n- 用例 $4$：$A = [9,8,7]$, $m = 2$, $n = 2$。\n- 用例 $5$：$A = [1,2,3]$, $m = 1$, $n = 3$。\n- 用例 $6$：$A = [1,2,3]$, $m = 0$, $n = 2$。\n- 用例 $7$：$A = [1,2]$, $m = 1$, $n = 3$。\n- 用例 $8$：$A = []$, $m = 1$, $n = 1$。\n\n对于每个用例，输出必须是应用所述反转规则后得到的结果链表。最终输出格式必须是单行字符串，其中包含八个测试用例的结果，聚合为一个由方括号括起来的逗号分隔的列表的列表，且行内不含任何空白字符。例如，最终输出必须形如$[[a_1],[a_2],\\dots,[a_8]]$，其中每个$[a_i]$是用例$i$的结果列表，以整数形式表示。所有用例的答案都是整数列表。",
            "solution": "在单向链表中反转一个连续子链表的问题，是指针操作方面一个明确定义的练习，也是数据结构中的一个基本概念。解决方案必须遵循严格的性能约束，即使用$O(1)$辅助空间进行原地修改，并且时间复杂度为$O(L)$，其中$L$是链表的长度。\n\n### 问题验证\n严谨的验证证实了问题陈述的合理性和可解性。\n\n**1. 提取的已知条件：**\n- **数据结构：**单向链表。\n- **目标：**反转从位置$m$到位置$n$的子链表（1-based索引）。\n- **约束：**仅当$1 \\le m \\le n \\le L$（其中$L$是链表长度）时，操作才有效。如果违反此条件，必须返回原始链表。\n- **性能：**时间复杂度$O(L)$，空间复杂度$O(1)$。不允许分配新节点。\n- **测试套件：**提供了八个测试用例，涵盖标准操作、边界情况（$m=n$、反转整个链表）和无效输入（$m1$、$n>L$、空链表）。\n\n**2. 验证结论：**\n该问题是**有效的**。它在科学上基于计算机科学的既定原则，特别是数据结构和算法。问题陈述清晰，为得出唯一且有意义的解提供了所有必要的条件、约束和定义。语言客观、正式。该问题提出了一个非平凡的算法挑战，这是该领域的标准课题，满足有效问题陈述的所有标准。\n\n### 算法解法\n该算法主要分三个阶段进行：验证与定位、原地反转以及重新连接。算法采用一个虚拟头节点（dummy head node）来简化指针逻辑，特别是处理反转从链表头部开始（$m=1$）的边界情况。\n\n**阶段 1：验证与定位**\n\n1.  **计算链表长度：**首先，我们通过从头到尾遍历链表来确定其长度$L$。此操作耗时$O(L)$。\n2.  **输入验证：**我们检查给定的位置$m$和$n$是否满足条件$1 \\le m \\le n \\le L$。如果不满足，则按规定终止算法并返回未经修改的原始链表头。此步骤能正确处理无效输入，例如用例 6、7 和 8 中的情况。空链表（$L=0$）或单元素反转（$m=n$）等特殊情况也自然地被此逻辑处理。如果$m=n$，待反转的子链表长度为 1，反转循环将正确地不执行任何更改。\n\n3.  **子链表定位：**为了修改链表，我们必须确定精确的连接点。\n    - 创建一个`dummy`节点，使其`next`指针指向原始链表的头节点。这简化了对$m=1$情况的处理，因为需要修改的指针（`dummy.next`）永远不会是头节点本身。\n    - 我们从`dummy`节点开始遍历$m-1$步，以定位到待反转子链表的前一个节点。该节点被指定为`pre_m`。它的`next`指针当前指向位置$m$的节点，之后需要被重新连接。\n    - 位置$m$处的节点，即`pre_m.next`，是待反转子链表的起始点。我们称之为`start_of_reversal`。反转后，此节点将成为反转后子链表的尾部。\n\n**阶段 2：原地子链表反转**\n\n算法的核心是反转长度为$n-m+1$的子链表。这通过一个迭代方法完成，该方法使用三个常规命名的指针：`prev`、`curr`和`next_node`。\n\n1.  **初始化：**反转过程从`start_of_reversal`开始的子链表上启动。我们将一个`prev`指针初始化为`None`，一个`curr`指针初始化为`start_of_reversal`。\n2.  **迭代：**我们迭代$n-m+1$次。在每次迭代中：\n    a. `next_node`指针临时存储原始序列中下一个节点的引用（`curr.next`）。\n    b. `curr`节点的`next`指针被反转，指向`prev`。\n    c. `prev`指针前移至`curr`。\n    d. `curr`指针前移至`next_node`。\n\n经过$n-m+1$次迭代后，`prev`将指向原在位置$n$的节点（反转后子链表的新头节点），而`curr`将指向原在位置$n+1$的节点（链表剩余部分的开始）。\n\n**阶段 3：重新连接**\n\n最后一步是通过操作在阶段 1 中确定的指针，将反转后的子链表重新连接回主链表中。\n\n1.  **连接第一部分：**`pre_m`（子链表之前的节点）的`next`指针被更新为指向`prev`（反转后子链表的新头节点）。\n2.  **连接第二部分：**`start_of_reversal`（现在是反转后子链表的尾节点）的`next`指针被更新为指向`curr`（子链表之后的节点）。\n\n通过这两次重新连接，链表的结构完整性得以恢复，现在其中包含了反转后的子链表。可能被修改过的链表的头节点是`dummy.next`，它作为最终结果返回。整个过程使用了常数个辅助指针变量，因此实现了$O(1)$的空间复杂度，并且涉及对链表或其部分进行常数次遍历，从而得出总时间复杂度为$O(L)$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass ListNode:\n    \"\"\"\n    Definition for a singly-linked list node.\n    \"\"\"\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef create_linked_list(items):\n    \"\"\"\n    Helper function to create a singly linked list from a list of items.\n    \"\"\"\n    if not items:\n        return None\n    head = ListNode(items[0])\n    current = head\n    for item in items[1:]:\n        current.next = ListNode(item)\n        current = current.next\n    return head\n\ndef linked_list_to_list(head):\n    \"\"\"\n    Helper function to convert a singly linked list back to a Python list.\n    \"\"\"\n    items = []\n    current = head\n    while current:\n        items.append(current.val)\n        current = current.next\n    return items\n\ndef reverse_sublist(head, m, n):\n    \"\"\"\n    Reverses a sublist of a singly linked list from position m to n.\n    1-based indexing is used.\n    \"\"\"\n    # Phase 1: Validation and Localization\n    if not head:\n        return None\n\n    # Calculate length L\n    length = 0\n    curr = head\n    while curr:\n        length += 1\n        curr = curr.next\n\n    # Validate m and n against list properties\n    if not (1 = m = n = length):\n        return head\n    \n    # Trivial case: no reversal needed\n    if m == n:\n        return head\n\n    # Use a dummy node to simplify edge cases (m=1)\n    dummy = ListNode(0, head)\n    \n    # Traverse to the node before the reversal segment\n    pre_m = dummy\n    for _ in range(m - 1):\n        pre_m = pre_m.next\n    \n    # Identify the start of the reversal segment\n    start_of_reversal = pre_m.next\n\n    # Phase 2: In-place Sublist Reversal\n    prev = None\n    curr = start_of_reversal\n    num_reversals = n - m + 1\n    \n    for _ in range(num_reversals):\n        next_node = curr.next\n        curr.next = prev\n        prev = curr\n        curr = next_node\n\n    # Phase 3: Reconnection\n    # prev is now the new head of the reversed sublist\n    # curr is the node that was originally at position n+1\n    # start_of_reversal is the original node m, now the tail of the reversed sublist\n    \n    pre_m.next = prev\n    start_of_reversal.next = curr\n    \n    return dummy.next\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and generate the final output.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        ([1,2,3,4,5,6,7], 3, 5),\n        ([10,20,30,40], 1, 3),\n        ([5,6,7,8], 3, 4),\n        ([9,8,7], 2, 2),\n        ([1,2,3], 1, 3),\n        ([1,2,3], 0, 2),\n        ([1,2], 1, 3),\n        ([], 1, 1),\n    ]\n\n    results = []\n    for case in test_cases:\n        list_data, m, n = case\n        head = create_linked_list(list_data)\n        \n        # Apply the reversal algorithm\n        result_head = reverse_sublist(head, m, n)\n        \n        # Convert the resulting linked list back to a Python list\n        result_list = linked_list_to_list(result_head)\n        results.append(result_list)\n\n    # Format the final output as a comma-separated list of lists, with no whitespace.\n    result_strings = [str(res).replace(' ', '') for res in results]\n    final_output = f\"[{','.join(result_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "最后的这个练习从抽象的机制转向实际应用，展示了反转原语的一种巧妙用法。通过先反转整个列表，然后再次反转每个独立的单词，你可以用简单、重复的操作实现一个复杂的目标。这个问题不仅巩固了你的指针操作技能，尤其是在双向链表上的应用，也鼓励了你的算法思维 。",
            "id": "3266919",
            "problem": "给定一个由字符组成的双向链表（DLL），它表示一个由Unicode基本拉丁字符集构成的有限句子。每个节点存储一个字符，对于每个具有前驱$x.\\mathrm{prev}$和后继$x.\\mathrm{next}$的节点$x$，双向链表的不变式为$(x.\\mathrm{prev} \\neq \\varnothing) \\Rightarrow (x.\\mathrm{prev}.\\mathrm{next} = x)$且$(x.\\mathrm{next} \\neq \\varnothing) \\Rightarrow (x.\\mathrm{next}.\\mathrm{prev} = x)$。该句子被定义为字符的有限序列$S$，编码为一个带有头节点$h$和尾节点$t$的双向链表，其中节点的顺序与句子的顺序完全对应。\n\n定义“单词”为任意由非空格字符组成的最大连续序列，定义“空格串”为任意由单个空格字符组成的最大连续序列。形式上，设$S$被划分为交替出现的序列$R_1, R_2, \\dots, R_k$，其中每个$R_i$要么是一个单词（所有字符$\\neq$空格字符），要么是一个空格串（所有字符$=$空格字符）。这些序列是最大的，因此按顺序连接所有序列会重现原始句子。像逗号或字母这样的字符被简单地视为非空格字符，因此是单词序列的一部分。问题要求反转单词序列的顺序，同时保留每个单词序列内部的字符顺序，并保留每个空格串内部的字符顺序。等价地，将最大序列的顺序从$R_1, \\dots, R_k$反转为$R_k, \\dots, R_1$，同时不反转任何序列内部的字符。\n\n从双向链表的核心定义和指针交换操作出发，推导出一个算法，该算法能够原地转换给定的双向链表，最多使用$O(1)$的辅助空间和$O(n)$的时间，其中$n$是节点数。您的算法不能构建字符或单词的辅助数组；它必须通过操作现有节点的$\\mathrm{prev}$和$\\mathrm{next}$指针来完成。您需要：\n- 通过单次指针交换遍历来反转整个双向链表，从而反转节点的全局序列。\n- 然后，在已反转的双向链表中识别出每个最大单词序列，并反转该序列内的指针，以恢复单词内部的字符顺序。空格串除了因全局反转而被隐式重新定位外，不应被更改。\n\n为了测试，您的程序必须是自包含的（无输入），并将转换应用于以下作为双向链表的句子测试套件：\n- $S_1$：“the sky is blue”\n- $S_2$：“  hello   world  ”\n- $S_3$：“” (空字符串)\n- $S_4$：“     ” (五个空格)\n- $S_5$：“solitary”\n- $S_6$：“mix  of   words and  spaces”\n\n对于每个测试句子，您的程序必须将结果句子输出为转换后双向链表中字符的Unicode码点（整数）列表。最终输出格式必须是单行，包含一个由方括号括起来的、逗号分隔的列表，该列表包含每个测试用例的列表，且没有空格。例如，您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，“[[a11,a12,...],[b11,b12,...],...]”），其中每个内部列表对应一个测试用例，每个元素是一个整数码点。不应打印任何其他文本。",
            "solution": "## 问题验证\n\n### 步骤1：提取已知条件\n\n1.  **数据结构**：一个由Unicode基本拉丁字符集中的字符组成的双向链表（DLL）。\n2.  **节点定义**：每个节点$x$具有属性$x.\\mathrm{char}$、$x.\\mathrm{prev}$和$x.\\mathrm{next}$。\n3.  **双向链表不变式**：对于任何节点$x$，如果$x.\\mathrm{prev}$不为null ($\\varnothing$)，则$x.\\mathrm{prev}.\\mathrm{next} = x$。如果$x.\\mathrm{next}$不为null ($\\varnothing$)，则$x.\\mathrm{next}.\\mathrm{prev} = x$。\n4.  **句子表示**：一个有限的字符序列$S$被编码为一个双向链表，其中节点顺序与句子顺序匹配。\n5.  **序列定义**：\n    *   “单词”是由非空格字符组成的最大连续序列。\n    *   “空格串”是由单个空格字符组成的最大连续序列。\n    *   句子$S$是划分为交替出现的序列$R_1, R_2, \\dots, R_k$。\n6.  **任务**：将序列的顺序$R_1, \\dots, R_k$反转为$R_k, \\dots, R_1$。每个序列内部的字符顺序必须保留。\n7.  **约束**：\n    *   转换必须是“原地”的。\n    *   辅助空间复杂度最多为$O(1)$。\n    *   时间复杂度必须为$O(n)$，其中$n$是节点数。\n    *   算法不能构建字符或单词的辅助数组。\n8.  **指定算法**：\n    *   首先，通过单次指针交换遍历来反转整个双向链表。\n    *   其次，在全局反转后的双向链表中识别每个最大单词序列，并反转该序列内的指针以恢复其原始字符顺序。\n9.  **测试用例**：\n    *   $S_1$：“the sky is blue”\n    *   $S_2$：“  hello   world  ”\n    *   $S_3$：“” (空字符串)\n    *   $S_4$：“     ” (五个空格)\n    *   $S_5$：“solitary”\n    *   $S_6$：“mix  of   words and  spaces”\n10. **输出格式**：对于每个测试用例，生成一个Unicode码点（整数）列表。最终输出必须是单行：一个由方括号括起来的、逗号分隔的这些列表的列表。例如：`[[a11,a12,...],[b11,b12,...],...]`。\n\n### 步骤2：使用提取的已知条件进行验证\n\n根据验证标准评估问题陈述：\n\n*   **有科学依据**：该问题植根于计算机科学领域，特别是数据结构和算法。它使用了双向链表及其操作的形式化、标准定义。所有概念在逻辑和数学上都是合理的。\n*   **定义明确**：该问题是定义明确的。输入被清晰定义（一个表示句子的双向链表）。期望的输出被明确指定（一个表示单词反转后句子的双向链表）。对时间和空间复杂度的约束，以及原地操作的要求，定义了一个精确的算法挑战，存在唯一且有意义的解。\n*   **客观**：问题以精确、客观的语言陈述。“最大连续序列”等术语有形式化定义。约束和要求的输出格式是定量的、无歧义的。\n\n该问题没有表现出任何使其无效的缺陷：\n1.  **科学或事实上的不合理性**：无。该问题遵循数据结构操作的原则。\n2.  **非形式化或不相关**：问题是形式化的，并与链表操作的主题直接相关。\n3.  **不完整或矛盾的设置**：问题是自包含的，提供了所有必要的定义和约束。指定的两步算法与实现最终目标是一致的。\n4.  **不现实或不可行**：这些约束是此类算法问题的标准配置，并且完全可行。\n5.  **不明确或结构不良**：问题结构良好，导向一个唯一的、稳定的解决方案。\n6.  **伪深刻、琐碎或同义反复**：该问题是一个非琐碎的指针操作练习，需要仔细实现以满足原地和复杂度的约束。\n7.  **超出科学可验证性**：所得算法的正确性可以被形式化证明，并可以通过给定的测试用例进行经验验证。\n\n### 步骤3：结论与行动\n\n此问题是**有效的**。将提供解决方案。\n\n## 算法推导与解决方案\n\n问题要求在由双向链表（DLL）表示的句子中原地反转单词，时间复杂度严格为$O(n)$，空间复杂度为$O(1)$，其中$n$是字符（节点）的数量。该解决方案遵循问题陈述中强制要求的两遍扫描法。\n\n### 数据结构\n\nDLL中的一个节点由三个字段定义：`char`用于存储字符，`prev`用于指向前一个节点的指针，`next`用于指向后一个节点的指针。链表由一个指向第一个节点的`head`指针和两端的空指针（`head`的`prev`为`null`，尾节点的`next`为`null`）界定。\n\n### 第一遍：全局反转双向链表\n\n第一步是反转整个双向链表。此操作会交换链表的头和尾，并反转所有节点的顺序。对于像“the sky is blue”这样的句子，此遍操作的结果将是一个表示“eulb si yks eht”的双向链表。\n\n这个反转可以通过对链表的一次遍历来完成。我们使用一个`current`指针从`head`开始遍历链表。对于访问的每个节点，我们交换其`prev`和`next`指针。如果语言支持元组赋值（例如`current.prev, current.next = current.next, current.prev`），则不一定需要临时变量。交换后，原始的`next`指针现在位于`current.prev`字段中，因此我们通过将`current`指针赋为其`current.prev`的值来前进。\n\n循环过程如下：\n设 `current` 是指向正在处理的节点的指针，初始化为`head`。\n设 `new_head` 是一个指针，初始化为`null`。\n当 `current` 不为 `null` 时：\n1.  将 `current` 存入 `new_head`，因为访问的最后一个节点将是反转后链表的新头节点。\n2.  令 `original_next = current.next`。\n3.  交换指针：`current.next = current.prev` 和 `current.prev = original_next`。\n4.  前进到原始序列中的下一个节点：`current = original_next`。\n\n一种更紧凑的写法来完成步骤2-4：\n1.  令 `temp = current.prev`。\n2.  `current.prev = current.next`。\n3.  `current.next = temp`。\n4.  `current = current.prev`（因为`current.prev`现在持有原始的`next`指针）。\n\n在这一遍之后，每个节点都被访问一次，双向链表被全局反转。这一遍耗时$O(n)$，并使用$O(1)$的辅助空间来存放像`current`和`new_head`这样的指针。原始的尾节点现在是链表的头节点。\n\n### 第二遍：反转单个单词序列\n\n第二步是纠正每个单词的内部顺序。在第一遍之后，句子“the sky is blue”变成了“eulb si yks eht”。单词处于最终期望的顺序，但每个单词本身是反转的。我们现在必须遍历这个新链表，并将每个单词序列反转回其原始拼写。\n\n我们用一个指针（例如`current`）从新的`head`开始遍历全局反转后的链表。\n1.  我们寻找一个单词的开头，即其字符不是空格的节点。\n2.  当找到单词的起始处（我们称之为`word_start`）时，我们从此节点向前扫描以找到单词序列的末尾。末尾`word_end`是最后一个连续的非空格字符节点。\n3.  现在我们有了一个需要原地反转的子链表段，从`word_start`到`word_end`。我们还必须跟踪紧接在此段之前（`before_word = word_start.prev`）和之后（`after_word = word_end.next`）的节点，以便将反转后的段正确地重新链接到主链表中。\n4.  子链表`[word_start, ..., word_end]`的反转方式与全局反转类似。我们从`word_start`迭代到`word_end`，交换段中每个节点的`prev`和`next`指针。\n5.  在段内的指针被交换后，`word_start`和`word_end`的角色实际上互换了。原始的`word_end`成为该段的新起点，而原始的`word_start`成为新终点。我们必须小心地将该段重新连接到链表的其余部分：\n    *   `before_word`的`next`指针（如果存在）现在必须指向该段的新起点（原始的`word_end`）。\n    *   该段新起点的`prev`指针必须指向`before_word`。\n    *   `after_word`的`prev`指针（如果存在）现在必须指向该段的新终点（原始的`word_start`）。\n    *   该段新终点的`next`指针必须指向`after_word`。\n    *   如果`before_word`为`null`，这意味着该单词位于链表的开头。在这种情况下，整个链表的`head`必须更新为指向该段的新起点（原始的`word_end`）。\n6.  在一个单词被反转并重新链接后，我们的主遍历从`after_word`继续。如果`current`节点是空格，我们只需前进到下一个节点。\n\n这第二遍也以常数次数访问每个节点（一次用于扫描，如果是单词的一部分则再有一次用于反转）。因此，它的时间复杂度也为$O(n)$，空间复杂度为$O(1)$。总复杂度保持为$O(n)$时间和$O(1)$空间，满足所有问题约束。这个两遍指针操作算法正确地原地转换了句子。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass Node:\n    \"\"\"\n    Represents a node in a Doubly Linked List.\n    \"\"\"\n    def __init__(self, char: str):\n        self.char = char\n        self.prev = None\n        self.next = None\n\ndef string_to_dll(s: str) - Node | None:\n    \"\"\"\n    Builds a Doubly Linked List from a string.\n    Returns the head of the list.\n    \"\"\"\n    if not s:\n        return None\n    \n    head = Node(s[0])\n    current = head\n    for char in s[1:]:\n        new_node = Node(char)\n        current.next = new_node\n        new_node.prev = current\n        current = new_node\n    return head\n\ndef dll_to_ord_list(head: Node | None) - list[int]:\n    \"\"\"\n    Converts a Doubly Linked List back to a list of Unicode code points.\n    \"\"\"\n    ords = []\n    current = head\n    while current:\n        ords.append(ord(current.char))\n        current = current.next\n    return ords\n\ndef reverse_words_in_dll(head: Node | None) - Node | None:\n    \"\"\"\n    Reverses the words in a sentence represented by a DLL, in-place.\n    \"\"\"\n    if not head or not head.next:\n        return head\n\n    # --- Pass 1: Reverse the entire DLL ---\n    # This pass reverses the order of all characters.\n    # e.g., \"the sky\" - \"yks eht\"\n    current = head\n    new_head = None\n    while current:\n        new_head = current  # The last non-null node visited will be the new head.\n        # Swap prev and next pointers\n        temp_prev = current.prev\n        current.prev = current.next\n        current.next = temp_prev\n        # Move to the next node in the original list\n        current = current.prev\n\n    head = new_head\n\n    # --- Pass 2: Reverse each word run ---\n    # This pass corrects the order of characters within each word.\n    # e.g., \"yks eht\" - \"sky the\"\n    current = head\n    while current:\n        if current.char != ' ':\n            # Found the start of a reversed word.\n            word_start = current\n            \n            # Find the end of this word run.\n            runner = word_start\n            while runner.next and runner.next.char != ' ':\n                runner = runner.next\n            word_end = runner\n            \n            # Store the nodes connecting this segment to the rest of the list.\n            before_word = word_start.prev\n            after_word = word_end.next\n            \n            # Reverse the pointers within the word sublist [word_start...word_end].\n            p = word_start\n            while True:\n                # This loop correctly reverses a segment of a DLL.\n                temp_next = p.next\n                p.next, p.prev = p.prev, p.next\n                if p == word_end:\n                    break\n                p = temp_next\n\n            # Relink the reversed word segment back into the main list.\n            # The original word_end is now the start of the segment.\n            word_end.prev = before_word\n            if before_word:\n                before_word.next = word_end\n            else:\n                # If there was no node before, this word is at the start of the list.\n                head = word_end\n            \n            # The original word_start is now the end of the segment.\n            word_start.next = after_word\n            if after_word:\n                after_word.prev = word_start\n            \n            # Continue scanning from the node after the processed word.\n            current = after_word\n        else:\n            # It's a space, just move to the next node.\n            current = current.next\n            \n    return head\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and print the final output.\n    \"\"\"\n    test_cases = [\n        \"the sky is blue\",\n        \"  hello   world  \",\n        \"\",\n        \"     \",\n        \"solitary\",\n        \"mix  of   words and  spaces\",\n    ]\n\n    results_as_strings = []\n    for s in test_cases:\n        # 1. Convert the input string to a DLL.\n        head_node = string_to_dll(s)\n        \n        # 2. Apply the in-place word reversal algorithm.\n        transformed_head = reverse_words_in_dll(head_node)\n        \n        # 3. Convert the resulting DLL to the required list of code points.\n        result_ords = dll_to_ord_list(transformed_head)\n        \n        # 4. Format the list of integers as a string \"[i1,i2,...]\".\n        results_as_strings.append(f\"[{','.join(map(str, result_ords))}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_as_strings)}]\")\n\nsolve()\n```"
        }
    ]
}