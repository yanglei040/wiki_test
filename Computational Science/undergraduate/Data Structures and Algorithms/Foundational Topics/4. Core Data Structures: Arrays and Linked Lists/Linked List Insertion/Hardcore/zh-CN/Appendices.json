{
    "hands_on_practices": [
        {
            "introduction": "本练习将带你超越简单的插入和删除操作。在这里，你将挑战为一个有序循环双向链表实现排序插入，这种数据结构具有更复杂的约束。完成此项任务需要你精确地管理多个指针并处理各种边界情况，从而巩固你对链式数据结构如何维持其完整性的基本理解。",
            "id": "3229897",
            "problem": "你需要实现一个支持排序插入的循环双向链表（DLL），同时保持节点键值的非递减顺序不变量。一个循环双向链表由节点组成，其中每个节点存储一个键、一个指向下一个节点的指针和一个指向前一个节点的指针。该链表是循环的：如果链表非空，则头节点的前驱指针指向尾节点，尾节点的后继指针指向头节点。头指针必须始终指向列表中键值最小的节点。排序插入操作必须将新键放置到这样一个位置：使得从头节点开始的正向遍历依然保持非递减顺序。\n\n需要维护的定义和不变量：\n- 每个节点存储一个整数键，记为 $k \\in \\mathbb{Z}$。\n- 对于一个头节点为 $H$ 的非空列表，令 $H = v_0$。一次完整的正向遍历会精确访问节点 $v_0, v_1, \\dots, v_{n-1}$ 各一次，并返回到 $v_0$。非递减顺序不变量要求对于所有 $i \\in \\{0,1,\\dots,n-2\\}$，都有 $v_i.\\text{key} \\le v_{i+1}.\\text{key}$。循环性要求 $v_{n-1}.\\text{next} = v_0$ 且 $v_0.\\text{prev} = v_{n-1}$。\n- 头指针必须始终指向当前存储的键集合中键值最小的节点。如果列表为空，则头指针为 null。\n\n你的任务：\n- 实现一个循环双向链表，并包含一个 `SortedInsert` 方法。该方法接受一个整数键 $x \\in \\mathbb{Z}$，并插入一个键为 $x$ 的新节点，以保持非递减顺序不变量。该算法必须在所有情况下都正确，包括：\n  - 向空列表中插入。\n  - 作为新的最小值插入（成为新的头节点）。\n  - 作为新的最大值插入（在尾部）。\n  - 在两个现有键之间插入。\n  - 当存在重复键时插入（最终顺序必须保持非递减；在相等键之间的任何有效位置都是可接受的）。\n- 对于给定的每个测试用例，在其所有插入操作完成后，从头节点开始执行一次正向遍历，以生成最终的键序列。该序列将是该测试用例的结果。\n\n设计和推理的基本依据：\n- 节点级指针不变量：对于正向遍历中的任意两个相邻节点（例如节点 $u$ 和 $v$），双向链表结构必须满足 $u.\\text{next} = v$ 和 $v.\\text{prev} = u$。\n- 循环性约束：对于一个头节点为 $H$ 且尾节点为 $T$ 的非空列表，必须满足 $T.\\text{next} = H$ 和 $H.\\text{prev} = T$。\n- 顺序关系：非递减顺序意味着对于正向遍历 $v_0, v_1, \\dots, v_{n-1}$，要求对于所有适用的 $i$ 都有 $v_i.\\text{key} \\le v_{i+1}.\\text{key}$。\n- 遍历的终止条件：当移动指针重新访问头节点 $H$ 时，即表示完成了一次完整的遍历。\n\n输入规范：\n- 没有外部输入。你的程序必须在内部构建并处理以下测试套件。每个测试用例都是一个整数键序列，需要按照给定顺序插入到一个初始为空的循环双向链表中：\n  1. 插入单个元素 $[5]$。\n  2. 插入升序序列 $[1, 2, 3, 4]$。\n  3. 插入降序序列 $[4, 3, 2, 1]$。\n  4. 插入带有重复项的混合序列 $[3, 1, 2, 2, 5, 4, 0, 3]$。\n  5. 插入负数和非负数键 $[-1, -3, 2, -2, 0, 2]$。\n  6. 插入所有相等的键 $[2, 2, 2, 2]$。\n\n输出规范：\n- 对于每个测试用例，在完成所有插入操作后，生成从头节点开始的正向遍历序列，作为一个整数列表。\n- 你的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。这个顶层列表的每个元素对应一个测试用例的结果，其本身也是一个整数列表。输出中不得包含任何空格。例如，如果有两个测试用例，其正向遍历序列分别为 $[1, 2]$ 和 $[3]$，则输出格式必须严格为 \"[[1,2],[3]]\"。\n\n计算要求：\n- `SortedInsert` 操作在最坏情况下对大小为 $n$ 的列表必须在 $O(n)$ 时间内运行，并且必须在所有情况下保持 DLL 的指针不变量和循环性。\n\n角度单位、物理单位和百分比格式在此不适用。\n\n每个测试用例的最终答案类型是一个整数列表。因此，程序的单行输出是一个整数列表的列表，其格式必须严格符合上述规定。",
            "solution": "问题陈述已经过验证，被认为是合理的。在数据结构和算法领域，这是一个定义明确、自成体系且可形式化的问题。不存在科学或事实上的不健全、矛盾或模糊之处。所有的不变量和要求都已明确说明。\n\n任务是为循环双向链表（DLL）设计并实现一个 `SortedInsert` 方法，该方法维护键的非递减顺序。实现必须遵守几个不变量：列表的循环性、双向链接指针的完整性，以及 `head` 指针始终引用具有最小键的节点的约束。\n\n首先，我们定义基本的数据结构——节点。每个节点（表示为 $v$）是一个包含三个字段的对象：一个整数键 $v.\\text{key} \\in \\mathbb{Z}$、一个指向下一个节点的指针 $v.\\text{next}$ 和一个指向前一个节点的指针 $v.\\text{prev}$。\n\n循环双向链表本身由一个类管理，该类维护一个单一指针 `head`。如果列表为空，`head` 为 null。否则，`head` 指向节点 $v_0$，其中 $v_0.\\text{key}$ 是列表中所有键的最小值。对于一个头节点为 $H$ 且尾节点为 $T$ 的非空列表，循环性不变量要求 $T.\\text{next} = H$ 和 $H.\\text{prev} = T$。\n\n问题的核心是 `SortedInsert(x)` 方法的实现，该方法将一个键为 $x \\in \\mathbb{Z}$ 的新节点插入到列表中，同时保持所有不变量。其逻辑可以系统地分解为不同的情况。设 $N$ 为要创建的新节点，使得 $N.\\text{key} = x$。\n\n情况 1：向空列表插入。\n如果列表的 `head` 指针为 null，则列表为空。新节点 $N$ 成为唯一的元素。为了保持循环性，其 `next` 和 `prev` 指针必须指向自身。\n$$N.\\text{next} \\leftarrow N$$\n$$N.\\text{prev} \\leftarrow N$$\n然后，列表的 `head` 指针更新为指向 $N$。\n$$\\text{head} \\leftarrow N$$\n\n情况 2：向非空列表插入。\n设 $H$ 为列表的当前头节点。根据新键 $x$ 相对于现有最小值 $H.\\text{key}$ 的值，可以分为两种子情况。\n\n子情况 2a：新键是新的最小值。\n当 $x \\le H.\\text{key}$ 时，会发生这种情况。根据头节点不变量，新节点 $N$ 必须成为列表的新头节点。$N$ 必须紧接在 $H$ 之前插入。列表的尾节点 $T$ 可以通过 $T = H.\\text{prev}$ 找到。必须更新指针以建立链接 $T \\leftrightarrow N \\leftrightarrow H$。\n所需的指针赋值操作如下：\n$1$. $N.\\text{next} \\leftarrow H$\n$2$. $N.\\text{prev} \\leftarrow T$\n$3$. $H.\\text{prev} \\leftarrow N$\n$4$. $T.\\text{next} \\leftarrow N$\n最后，列表的 `head` 指针必须更新为 $N$：\n$$\\text{head} \\leftarrow N$$\n\n子情况 2b：新键不是新的最小值。\n当 $x > H.\\text{key}$ 时，会发生这种情况。新节点 $N$ 必须插入到头节点之后的某个位置。我们必须遍历列表以找到正确的位置。目标是找到两个相邻的节点 $u$ 和 $v = u.\\text{next}$，使得 $u.\\text{key} \\le x$ 且在它们之间插入 $N$ 能保持非递减顺序。我们可以通过搜索键值小于 $x$ 的最后一个节点 $u$ 来实现这一点。\n我们将一个遍历指针 `current` 初始化为 `head`。然后，只要下一个节点的键小于 $x$，我们就向前移动 `current`。关键是，遍历还必须处理循环列表的回绕情况。循环条件是 `current.next != head` 并且 `current.next.key  x`。\n当 `current` 是应紧邻 $N$ 之前的节点时，循环终止。设这个前驱节点为 $P = \\text{current}$，其后继节点为 $S = P.\\text{next}$。节点 $N$ 将被插入到 $P$ 和 $S$ 之间。指针更新如下：\n$1$. $N.\\text{next} \\leftarrow S$\n$2$. $N.\\text{prev} \\leftarrow P$\n$3$. $P.\\text{next} \\leftarrow N$\n$4$. $S.\\text{prev} \\leftarrow N$\n这一个逻辑块能正确处理在列表中间插入以及在末尾插入（即当 $x$ 大于或等于所有现有键时）的情况。在后一种情况下，遍历循环将完成一个完整的圈，`current` 将成为尾节点 $T$，而 `current.next` 将是头节点 $H$。新节点将被正确地插入到 $T$ 和 $H$ 之间，成为新的尾节点。\n\n为了生成所需的输出，需要一个正向遍历方法。该方法从 `head` 节点开始。如果列表非空，它将使用 `next` 指针遍历列表，按顺序收集键，直到遍历指针返回到 `head`。do-while 循环是实现此功能的自然结构，因为循环体必须至少为头节点执行一次。\n\n`SortedInsert` 操作的计算复杂度由遍历步骤决定。在最坏情况下（插入一个成为新最大值的键），算法必须遍历整个大小为 $n$ 的列表。因此，时间复杂度为 $O(n)$。空间复杂度为 $O(1)$，因为它只需要固定数量的指针和一个新节点。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass Node:\n    \"\"\"\n    Represents a node in a doubly linked list.\n    Each node stores an integer key and pointers to the next and previous nodes.\n    \"\"\"\n    def __init__(self, key: int):\n        self.key = key\n        self.next = None\n        self.prev = None\n\nclass CircularDLL:\n    \"\"\"\n    Implements a circular doubly linked list that maintains keys in nondecreasing order.\n    The head pointer always points to the node with the minimum key.\n    \"\"\"\n    def __init__(self):\n        self.head = None\n\n    def sorted_insert(self, key: int):\n        \"\"\"\n        Inserts a new node with the given key into the list while maintaining\n        the sorted, circular, and doubly linked properties.\n        \"\"\"\n        new_node = Node(key)\n\n        # Case 1: The list is empty.\n        if self.head is None:\n            new_node.next = new_node\n            new_node.prev = new_node\n            self.head = new_node\n            return\n\n        # Case 2: The new key is less than or equal to the head's key.\n        # The new node becomes the new head.\n        if key = self.head.key:\n            tail = self.head.prev\n            \n            new_node.next = self.head\n            new_node.prev = tail\n            \n            tail.next = new_node\n            self.head.prev = new_node\n            \n            self.head = new_node\n            return\n\n        # Case 3: The new key must be inserted in the middle or at the end.\n        # Traverse to find the correct insertion point.\n        current = self.head\n        # Find the node after which the new node should be inserted.\n        while current.next != self.head and current.next.key  key:\n            current = current.next\n        \n        # 'current' is now the predecessor. 'next_node' is the successor.\n        next_node = current.next\n        \n        new_node.next = next_node\n        new_node.prev = current\n        \n        current.next = new_node\n        next_node.prev = new_node\n\n    def get_list_as_array(self) - list[int]:\n        \"\"\"\n        Performs a forward traversal from the head and returns the keys as a list.\n        \"\"\"\n        if self.head is None:\n            return []\n        \n        result = []\n        current = self.head\n        # Emulate a do-while loop to traverse the circular list\n        while True:\n            result.append(current.key)\n            current = current.next\n            if current == self.head:\n                break\n        return result\n\ndef solve():\n    \"\"\"\n    Runs the test suite as specified in the problem statement and prints the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [5],\n        [1, 2, 3, 4],\n        [4, 3, 2, 1],\n        [3, 1, 2, 2, 5, 4, 0, 3],\n        [-1, -3, 2, -2, 0, 2],\n        [2, 2, 2, 2],\n    ]\n\n    results = []\n    for insertions in test_cases:\n        dll = CircularDLL()\n        for key in insertions:\n            dll.sorted_insert(key)\n        results.append(dll.get_list_as_array())\n\n    # Format the final output string to be exactly \"[[...],[...]]\" with no spaces.\n    # The default str() for lists includes spaces, which violates the output requirement.\n    # We construct the string manually for precise formatting.\n    list_of_list_strs = []\n    for res_list in results:\n        list_str = f\"[{','.join(map(str, res_list))}]\"\n        list_of_list_strs.append(list_str)\n    \n    final_output_str = f\"[{','.join(list_of_list_strs)}]\"\n\n    # Final print statement in the exact required format.\n    print(final_output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "软件开发常常需要根据特定问题创建专属的操作。本练习要求你为一个双向链表实现一个自定义的“交换-插入”函数。解决问题的关键在于将这个复杂操作分解为一系列更简单的、保持链表核心不变量的原子指针操作，这为你提供了算法设计与实现的宝贵实践。",
            "id": "3246042",
            "problem": "您的任务是，基于双向链表的核心定义及​​其不变式，形式化并实现一个在双向链表上的专门插入操作。双向链表是节点 $\\{N_0, N_1, \\dots, N_{n-1}\\}$ 的有限序列，其中每个节点存储一个值和两个引用：$prev$ 和 $next$。根据定义，对于每个满足 $0 \\le i  n$ 的有效索引 $i$，以下不变式必须成立：如果 $N_i.next$ 不为 null，则 $(N_i.next).prev = N_i$；并且如果 $N_i.prev$ 不为 null，则 $(N_i.prev).next = N_i$。头节点 $H$ 是唯一的 $H.prev = \\text{null}$ 的节点，尾节点 $T$ 是唯一的 $T.next = \\text{null}$ 的节点。标准的头部插入、尾部插入和中间插入操作是通过在保持这些不变式的前提下，重设恒定数量的引用来定义的。\n\n定义一个在双向链表上的操作，称为 swap-insert。给定：\n- 一个初始双向链表 $L$，\n- $L$ 中一个由其从0开始的索引位置指定的节点 $A$，\n- 以及一个用于新分配节点 $B$ 的新值 $b$，\n\n执行操作 swap-insert$(L, A, b)$，它由以下原子列表编辑序列组成，每一步都重设恒定数量的引用并保持不变式：\n\n1. 通过连接其邻居节点，将 $A$ 从当前位置移除。形式上，令 $P = A.prev$ 且 $Q = A.next$。设置如下：\n   - 如果 $P \\ne \\text{null}$，则 $P.next \\leftarrow Q$；否则，将头节点设为 $Q$，\n   - 如果 $Q \\ne \\text{null}$，则 $Q.prev \\leftarrow P$。\n   此步骤后，$A$ 不在 $L$ 中。\n2. 创建一个值为 $b$ 的新节点 $B$，并将其插入到 $A$ 原来的间隙中。即，设置如下：\n   - $B.prev \\leftarrow P$ 且 $B.next \\leftarrow Q$，\n   - 如果 $P \\ne \\text{null}$，则 $P.next \\leftarrow B$；否则，将头节点设为 $B$，\n   - 如果 $Q \\ne \\text{null}$，则 $Q.prev \\leftarrow B$。\n   此步骤后，$B$ 占据了先前由 $A$ 占据的精确相对位置。\n3. 在头部插入 $A$。令当前头节点为 $H$（可能 $H = \\text{null}$）。设置如下：\n   - $A.prev \\leftarrow \\text{null}$，$A.next \\leftarrow H$，\n   - 如果 $H \\ne \\text{null}$，则 $H.prev \\leftarrow A$，\n   - 将头节点设为 $A$。\n\n即使对于边界情况，例如当 $A$ 是头节点（此时 $P = \\text{null}$）、$A$ 是尾节点（此时 $Q = \\text{null}$）以及列表仅含单个节点时，此定义也能产生明确定义的结果。您的任务是仅使用双向链表的定义和不变式，以及作为指针赋值组合的标准头部、尾部和中间插入，从头开始实现此操作。\n\n不使用输入格式；相反，您必须在程序中嵌入以下测试套件。每个测试用例是一个三元组 $(L, i, b)$，其中 $L$ 是初始整数列表，$i$ 是 $L$ 中节点 $A$ 的从0开始的索引，$b$ 是新节点 $B$ 的整数值：\n- 测试用例 1：$L = [10,20,30,40,50]$，$i = 2$，$b = 99$。\n- 测试用例 2：$L = [1,2,3]$，$i = 0$，$b = 7$。\n- 测试用例 3：$L = [4,5,6]$，$i = 2$，$b = 8$。\n- 测试用例 4：$L = [42]$，$i = 0$，$b = 100$。\n- 测试用例 5：$L = [5,5,5,5]$，$i = 1$，$b = -1$。\n\n对于每个测试用例，计算在执行 swap-insert$(L, A, b)$ 操作后得到的值列表，其中 $A$ 是初始列表 $L$ 中索引为 $i$ 的节点，$B$ 是一个值为 $b$ 的新节点。要求的最终输出是包含结果列表的单行，其中每个结果是代表该测试用例最终列表的整数列表，整个集合以方括号括起来的逗号分隔列表形式书写。具体来说，输出格式必须是形如 $[$result\\_case\\_1$, $result\\_case\\_2$, \\dots$]$ 的单行，其中每个 result\\_case\\_k 本身是对应于测试用例 $k$ 的、用方括号括起来的逗号分隔整数列表。",
            "solution": "该问题是形式化指定且自包含的，它提供了双向链表、其不变式以及一个名为 `swap-insert` 的新操作的严格定义。因此，该问题是有效的。我们将着手提供一个解决方案。\n\n双向链表是节点的集合，其中每个节点包含一个值和两个指针 `prev` 和 `next`，建立了一个双向序列。设列表由大小为 $n$ 的节点序列 $\\{N_0, N_1, \\dots, N_{n-1}\\}$ 表示。定义该结构完整性的基本不变式如下：\n1.  对于任何节点 $N_i$（其中 $0 \\le i  n-1$），其 `next` 指针指向 $N_{i+1}$，反之，$(N_{i+1})$.`prev` 指向 $N_i$。即 $(N_i.next).prev = N_i$。\n2.  对于任何节点 $N_i$（其中 $0  i \\le n-1$），其 `prev` 指针指向 $N_{i-1}$，反之，$(N_{i-1})$.`next` 指向 $N_i$。即 $(N_i.prev).next = N_i$。\n3.  列表的头节点 $H = N_0$，是其 `prev` 指针为 null（$H.prev = \\text{null}$）的唯一节点。\n4.  列表的尾节点 $T = N_{n-1}$，是其 `next` 指针为 null（$T.next = \\text{null}$）的唯一节点。\n\n该问题定义了一个复合操作 `swap-insert(L, A, b)`，作用于给定节点 $A$（由其从0开始的索引标识）和新节点 $B$ 的值 $b$ 的列表 $L$ 上。该操作由三个不同且连续的步骤组成。我们将对每个步骤的指针操作进行形式化，确保不变式得以维持。\n\n我们用 $A$ 表示索引 $i$ 处的节点。我们将分析一般情况及其边界条件下的过程。\n\n**步骤 1：从列表中移除节点 $A$。**\n目标是将 $A$ 从其邻居节点中断开，从而在列表中有效地创建一个“间隙”。令 $P = A.prev$ 且 $Q = A.next$。\n-   我们必须连接 $P$ 和 $Q$。$P$ 的 `next` 指针必须更新为指向 $Q$，$Q$ 的 `prev` 指针必须更新为指向 $P$。\n-   **指针更新：**\n    -   `P.next` $\\leftarrow$ $Q$\n    -   `Q.prev` $\\leftarrow$ $P$\n-   这维持了链的连续性。此后，$(P.next).prev = Q.prev = P$，保持了对于 $P$ 的不变式。同样地，$(Q.prev).next = P.next = Q$，保持了对于 $Q$ 的不变式。\n-   **边界条件：**\n    -   如果 $A$ 是头节点（$i=0$），那么 $P = \\text{null}$。第一个更新（`P.next` $\\leftarrow$ $Q$）不执行。列表的头节点必须更新为 $Q$。更新后，$Q.prev$ 将被设置为 $P$（即 `null`），从而正确地使 $Q$ 成为新的头节点。\n    -   如果 $A$ 是尾节点（$i=n-1$），那么 $Q = \\text{null}$。第二个更新（`Q.prev` $\\leftarrow$ $P$）不执行。列表的尾节点必须更新为 $P$。更新后，$P.next$ 将被设置为 $Q$（即 `null`），从而正确地使 $P$ 成为新的尾节点。\n    -   如果列表只有一个节点（$n=1$），那么 $A$ 同时是头节点和尾节点，所以 $P = \\text{null}$ 且 $Q = \\text{null}$。列表变为空；列表结构的头指针和尾指针都变为 `null`。\n在此步骤结束时，节点 $A$ 被隔离，但保留其原始的 `prev` 和 `next` 指针。列表 $L$ 的长度现在减少了一个节点，但仍然是一个有效、连续的双向链表。\n\n**步骤 2：将新节点 $B$ 插入间隙中。**\n创建一个值为 $b$ 的新节点 $B$。它必须被插入到先前由 $A$ 占据的位置，即节点 $P$ 和 $Q$ 之间。\n-   **指针更新：**\n    -   $B.prev$ $\\leftarrow$ $P$\n    -   $B.next$ $\\leftarrow$ $Q$\n    -   $P.next$ $\\leftarrow$ $B$\n    -   $Q.prev$ $\\leftarrow$ $B$\n-   不变式得以恢复。例如，$(P.next).prev = B.prev = P$ 且 $(B.next).prev = Q.prev = B$。\n-   **边界条件：**这些条件的处理方式与步骤1相同。\n    -   如果 $P = \\text{null}$（间隙在头部），我们将列表的头节点设为 $B$。\n    -   如果 $Q = \\text{null}$（间隙在尾部），我们将列表的尾节点设为 $B$。\n    -   如果列表为空，则 $P$ 和 $Q$ 均为 `null`。$B$ 成为大小为1的新列表的头节点和尾节点。\n此步骤后，列表的长度恢复为 $n$，节点 $B$ 位于原节点 $A$ 的位置。\n\n**步骤 3：在列表头部插入节点 $A$。**\n现在将被隔离的节点 $A$ 前插到列表中。令列表当前的头节点为 $H$。\n-   **指针更新：**\n    -   $A.prev$ $\\leftarrow$ $\\text{null}$ (这对于使 $A$ 成为有效的头节点是必要的)。\n    -   $A.next$ $\\leftarrow$ $H$\n    -   $H.prev$ $\\leftarrow$ $A$\n-   列表的头指针必须更新为指向 $A$。\n-   **边界条件：**\n    -   如果在此步骤之前列表为空（$H = \\text{null}$），这种情况发生在原始列表只有一个节点时，那么 $A$ 将被插入到一个空列表中。$A.next$ 被设置为 `null`，$A$ 同时成为头节点和尾节点。`H.prev` 的更新被跳过。\n\n在最后这个步骤之后，列表包含 $n+1$ 个节点。节点 $A$ 是新的头节点，新节点 $B$ 位于 $A$ 的原始索引处，列表的总长度增加了一。\n\n我们来追踪测试用例1：$L = [10,20,30,40,50]$, $i = 2$, $b = 99$。\n1.  初始列表：$10 \\leftrightarrow 20 \\leftrightarrow 30 \\leftrightarrow 40 \\leftrightarrow 50$。节点 $A$ 的值为 $30$。$P$ 是节点 $20$，$Q$ 是节点 $40$。\n2.  步骤1（移除 $A$）：节点 $20$ 的 `next` 指向节点 $40$。节点 $40$ 的 `prev` 指向节点 $20$。列表现在是 $10 \\leftrightarrow 20 \\leftrightarrow 40 \\leftrightarrow 50$。\n3.  步骤2（插入 $B$）：创建一个值为 $99$ 的新节点 $B$。其 `prev` 设置为节点 $20$，`next` 设置为节点 $40$。节点 $20$ 的 `next` 设置为 $B$，节点 $40$ 的 `prev` 设置为 $B$。列表现在是 $10 \\leftrightarrow 20 \\leftrightarrow 99 \\leftrightarrow 40 \\leftrightarrow 50$。头节点仍然是节点 $10$。\n4.  步骤3（在头部插入 $A$）：当前头节点 $H$ 是节点 $10$。节点 $A$（值为 $30$）的 `prev` 设置为 `null`，`next` 设置为 $H$。节点 $H$ 的 `prev` 设置为 $A$。列表的头指针更新为 $A$。最终列表为 $30 \\leftrightarrow 10 \\leftrightarrow 20 \\leftrightarrow 99 \\leftrightarrow 40 \\leftrightarrow 50$。\n结果值：$[30, 10, 20, 99, 40, 50]$。\n\n通过系统地应用指针操作，并仔细处理边界处的 `null` 指针，可以正确实现指定的 `swap-insert` 操作，同时在每个阶段都保持双向链表的基本不变式。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np # numpy is required by the environment but not used in this solution.\n\nclass Node:\n    \"\"\"A node in a doubly linked list.\"\"\"\n    def __init__(self, value, prev=None, next_node=None):\n        self.value = value\n        self.prev = prev\n        self.next = next_node\n\n    def __repr__(self):\n        return f\"Node({self.value})\"\n\nclass DoublyLinkedList:\n    \"\"\"A doubly linked list implementation.\"\"\"\n    def __init__(self):\n        self.head = None\n        self.tail = None\n        self.size = 0\n\n    def from_list(self, values):\n        \"\"\"Creates a doubly linked list from a Python list.\"\"\"\n        if not values:\n            return\n        \n        # Create head\n        self.head = Node(values[0])\n        self.tail = self.head\n        self.size = 1\n        \n        # Add subsequent nodes\n        current = self.head\n        for value in values[1:]:\n            new_node = Node(value, prev=current)\n            current.next = new_node\n            current = new_node\n            self.tail = current\n            self.size += 1\n\n    def to_list(self):\n        \"\"\"Converts the doubly linked list to a Python list.\"\"\"\n        values = []\n        current = self.head\n        while current:\n            values.append(current.value)\n            current = current.next\n        return values\n\n    def get_node_at(self, index):\n        \"\"\"Returns the node at a specific index.\"\"\"\n        if not (0 = index  self.size):\n            return None\n        \n        # Optimization: traverse from head or tail depending on index\n        if index  self.size / 2:\n            current = self.head\n            for _ in range(index):\n                current = current.next\n        else:\n            current = self.tail\n            for _ in range(self.size - 1 - index):\n                current = current.prev\n        return current\n\n    def swap_insert(self, A_index, b_value):\n        \"\"\"\n        Performs the swap-insert operation as defined in the problem.\n        The net result is that the list grows by one element.\n        \"\"\"\n        # Step 0: Find node A\n        A = self.get_node_at(A_index)\n        if A is None:\n            return\n\n        # Step 1: Remove A from its current place\n        P = A.prev\n        Q = A.next\n        \n        if P:\n            P.next = Q\n        else: # A was the head\n            self.head = Q\n        \n        if Q:\n            Q.prev = P\n        else: # A was the tail\n            self.tail = P\n        \n        self.size -= 1\n        # Node A is now isolated.\n\n        # Step 2: Create a new node B and insert it into the gap\n        B = Node(b_value)\n        \n        B.prev = P\n        B.next = Q\n        \n        if P:\n            P.next = B\n        else: # The gap was at the head\n            self.head = B\n            \n        if Q:\n            Q.prev = B\n        else: # The gap was at the tail\n            self.tail = B\n        \n        if self.size == 0: # If the list became empty after removing A\n            self.head = B\n            self.tail = B\n\n        self.size += 1\n        \n        # Step 3: Insert A at the head\n        H = self.head\n\n        A.prev = None\n        A.next = H\n        \n        if H:\n            H.prev = A\n        \n        self.head = A\n        \n        # If the list was empty before this step, A becomes both head and tail.\n        if self.size == 1: # The list now has 2 elements, but before A was added it had 1 (B)\n             self.tail = H # H is node B in this case.\n        \n        # Final check if tail needs setting (only if list was empty before A insertion)\n        if not self.tail:\n             self.tail = A\n\ndef solve():\n    \"\"\"\n    Executes the test suite and prints the formatted output.\n    \"\"\"\n    test_cases = [\n        ([10, 20, 30, 40, 50], 2, 99),\n        ([1, 2, 3], 0, 7),\n        ([4, 5, 6], 2, 8),\n        ([42], 0, 100),\n        ([5, 5, 5, 5], 1, -1),\n    ]\n\n    results = []\n    for case in test_cases:\n        initial_list_values, index, new_value = case\n        \n        # Create and populate the doubly linked list\n        dll = DoublyLinkedList()\n        dll.from_list(initial_list_values)\n        \n        # Perform the swap-insert operation\n        dll.swap_insert(index, new_value)\n        \n        # Store the result\n        results.append(dll.to_list())\n\n    # Format the final output string to be exactly as required,\n    # specifically removing spaces after commas within the lists.\n    # str(results) -> '[[1, 2], [3, 4]]'\n    # .replace(' ', '') -> '[[1,2],[3,4]]'\n    final_output = str(results).replace(' ', '')\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "到目前为止，我们都假设代码是顺序执行的。下一个练习是一个思想实验，它将打破这一假设，带你初探并发编程的挑战。通过分析一个在并发环境下执行的尾部插入算法，你将诊断出一种被称为“竞争条件”的严重错误。这个练习对于理解为何共享数据结构需要精密的同步机制至关重要。",
            "id": "3245948",
            "problem": "考虑一个带有指针 $head$ 和 $tail$ 的单链表，其表示不变量为：该链表是一个由节点 $n_0, n_1, \\dots, n_k$ 组成的有限序列，其中 $head = n_0$， $tail = n_k$，对于所有满足 $0 \\le i  k$ 的 $i$ 都有 $n_i.next = n_{i+1}$，并且 $n_k.next = \\varnothing$。尾部插入例程是作为一个线程对新节点 $x$ 执行的以下复合、非原子序列来实现的：\n- 步骤 $1$：设置 $x.next \\leftarrow \\varnothing$，\n- 步骤 $2$：读取 $t \\leftarrow tail$，\n- 步骤 $3$：设置 $t.next \\leftarrow x$，\n- 步骤 $4$：设置 $tail \\leftarrow x$。\n假设所有指针的读取和写入都是单独原子的，并且内存模型是顺序一致性（Sequential Consistency, SC），这意味着所有线程观察到的操作都是某种保留了每个线程程序顺序的交错。有两个并发线程 $T_1$ 和 $T_2$，它们都使用上述例程执行尾部插入，且没有使用互斥。\n\n在压力测试中报告了一个错误，在并发尾部插入的情况下，$tail$ 指针会丢失或与链中的实际最后一个节点不一致，从而违反了不变量 $tail = n_k$。你需要诊断一个在给定假设下可能导致此问题的错误模式，并设计一个压力测试调度，通过使用屏障或锁存器（例如，每个线程在一个共享标志上忙等待直到某个条件满足）将操作对齐到一个精确的时间窗口中，从而确定性地触发该故障。\n\n哪个选项正确地识别了一个与顺序一致性（SC）相符的错误机制，并提供了一个能触发 $tail$ 丢失的确定性双线程调度？\n\nA. 诊断：复合的尾部推进操作是非原子的，因此两个线程可以在共享前驱节点的 $next$ 字段上发生竞争；对 $t.next$ 的最后一次写入会“获胜”，如果较早的线程稍后用其自己的节点写入 $tail$，那么 $tail$ 最终可能指向一个并未链接在列表末尾的节点。确定性调度：\n- 初始化一个单节点 $a$，使得 $head = tail = a$。\n- 线程 $T_1$：分配 $x_1$，执行步骤 $1$，执行步骤 $2$ 读取 $t = a$，执行步骤 $3$ 写入 $a.next \\leftarrow x_1$，然后在步骤 $4$ 之前在屏障 $b_1$ 上阻塞。\n- 线程 $T_2$：分配 $x_2$，执行步骤 $1$，执行步骤 $2$ 读取 $t = a$（因为 $tail$ 仍然是 $a$），执行步骤 $3$ 写入 $a.next \\leftarrow x_2$（覆盖了 $x_1$），然后执行步骤 $4$ 写入 $tail \\leftarrow x_2$，接着发信号给 $b_1$ 以释放 $T_1$。\n- 恢复线程 $T_1$：执行步骤 $4$ 写入 $tail \\leftarrow x_1$。\n后置条件：$a.next = x_2$，$tail = x_1$，这违反了 $tail = n_k$，因为 $x_1$ 不在链的末尾；不变量被确定性地破坏了。\n\nB. 诊断：指令重排导致 $tail \\leftarrow x$（步骤 $4$）发生在 $t.next \\leftarrow x$（步骤 $3$）之前，从而创建了一个时间窗口，在此期间 $tail$ 指向一个未链接的节点，而另一个线程读取并错误地更新了 $tail$。确定性调度：通过处理器重排强制 $T_1$ 的步骤 $4$ 在其步骤 $3$ 之前执行，然后让 $T_2$ 读取 $tail$ 并迅速执行步骤 $3$ 和步骤 $4$。\n\nC. 诊断：在使用比较并交换（CAS）更新 $tail$ 而未保护 $next$ 字段时，在 $tail$ 上出现“ABA问题”；一个节点可以暂时成为 $tail$，然后不再是，然后相同的节点值再次出现，从而迷惑了基于 CAS 的逻辑。确定性调度：交错三次插入，使得 $tail$ 依次变为 $x_1$、$x_2$、$x_1$，导致对 $tail$ 的一次 CAS 操作伪成功，并丢失最后的 $next$ 链接。\n\nD. 诊断：基于遍历的尾部发现与并发插入发生竞争，因为最后一个节点的 $next$ 未被设置为 $\\varnothing$，所以遍历会继续经过预期的末尾；同时的更新导致遍历跳过节点并最终定位到一个过时的尾部。确定性调度：从一个最后一个节点的 $next$ 非 $\\varnothing$ 的列表开始，然后运行一个插入者和一个遍历者到尾部，在步骤 $2$ 和步骤 $3$ 之间暂停插入者，以导致遍历者错误地识别尾部，并使插入者通过一个过时的节点进行写入。\n\n选择正确的选项。",
            "solution": "用户提供了一个关于单链表中并发、非原子、尾部插入算法的竞争条件问题。任务是验证该问题，在顺序一致性下推导出一个正确的故障机制，并评估给定的选项。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n-   **数据结构：** 一个带有 `$head$` 和 `$tail$` 指针的单链表。\n-   **表示不变量：** 列表是一个序列 `$n_0, n_1, \\dots, n_k$`，其中 `$head = n_0$`，`$tail = n_k$`，对于 `$0 \\le i  k$` 有 `$n_i.next = n_{i+1}$`，以及 `$n_k.next = \\varnothing$`。\n-   **对新节点 `$x$` 的尾部插入例程：**\n    1.  `$x.next \\leftarrow \\varnothing$`\n    2.  `$t \\leftarrow tail$`\n    3.  `$t.next \\leftarrow x$`\n    4.  `$tail \\leftarrow x$`\n-   **并发模型：**\n    -   两个线程 `$T_1$` 和 `$T_2$` 并发执行尾部插入例程。\n    -   不使用互斥。\n    -   指针的读写是单独原子的。\n    -   内存模型是顺序一致性（SC）。\n\n**步骤 2：使用提取的已知条件进行验证**\n-   **科学上是合理的：** 该问题是并发数据结构中的一个经典例子，说明了由于对共享数据结构的非原子读-改-写序列而导致的竞争条件。所使用的概念（链表、指针、原子性、顺序一致性）在计算机科学中是基础且定义正确的。\n-   **提法得当：** 该问题提供了一个精确的算法、一个特定的并发模型（SC）和一个明确的目标：识别一个故障模式（违反 `$tail$` 不变量）和一个确定性地触发它的调度。一个唯一的、可验证的答案是可能的。\n-   **客观性：** 该问题使用精确、无歧义的技术术语陈述。\n\n问题陈述被认为是**有效的**。这是一个在并发算法分析中定义明确的问题，没有任何科学、逻辑或结构上的缺陷。\n\n### 错误机制的推导\n\n问题的核心在于四步序列的非原子性。具体来说，该操作是一个对列表尾部的“读-改-写”模式，但被分成了两个独立的部分：更新旧尾部的链接（`$t.next \\leftarrow x$`）和更新全局 `$tail$` 指针本身（`$tail \\leftarrow x$`）。在并发环境下，线程可以在这些步骤之间交错它们的操作。\n\n假设初始列表包含一个节点 `$a$`，使得 `$head = a$` 和 `$tail = a$`。设线程 `$T_1$` 正在插入节点 `$x_1$`，线程 `$T_2$` 正在插入节点 `$x_2$`。一个违反 `$tail = n_k$` 不变量的故障可以如下构建：\n\n1.  **两个线程都读取旧的尾部：**\n    -   `$T_1$` 执行步骤 2：`$t_1 \\leftarrow tail$`。所以 `$t_1$` 持有 `$a$` 的地址。\n    -   `$T_2$` 执行步骤 2：`$t_2 \\leftarrow tail$`。所以 `$t_2$` 也持有 `$a$` 的地址。此时，两个线程都打算在 `$a$` 之后附加它们的新节点。\n\n2.  **两个线程都更新旧尾部的 `next` 指针：**\n    -   `$T_1$` 执行步骤 3：`$t_1.next \\leftarrow x_1$`。这将设置 `$a.next \\leftarrow x_1$`。列表变为 `$a \\rightarrow x_1$`。\n    -   `$T_2$` 执行步骤 3：`$t_2.next \\leftarrow x_2$`。这将设置 `$a.next \\leftarrow x_2$`。这次写入覆盖了 `$T_1$` 的写入。列表现在是 `$a \\rightarrow x_2$`，节点 `$x_1$` 不再能从列表的头部访问到；它已经“丢失”了。\n\n3.  **线程更新全局 `tail` 指针：** 这些更新的顺序至关重要。让我们假设以下交错：\n    -   `$T_2$` 执行步骤 4：`$tail \\leftarrow x_2$`。`$tail$` 指针现在正确地指向 `$x_2$`，后者是列表 `$a \\rightarrow x_2$` 的实际最后一个节点。在这一特定时刻，不变量成立。\n    -   `$T_1$` 执行其最后的步骤 4：`$tail \\leftarrow x_1$`。这次写入覆盖了 `$tail$` 指针。\n\n4.  **最终状态分析：**\n    -   从 `$head$` 遍历的列表结构是 `$a \\rightarrow x_2 \\rightarrow \\varnothing$`。最后一个节点 `$n_k$` 是 `$x_2$`。\n    -   全局 `$tail$` 指针存储了 `$x_1$` 的地址。\n    -   因此，`$tail \\neq n_k$`，这违反了表示不变量。`$tail$` 指针现在指向一个不属于从 `$head$` 可访问的链表中的节点。\n\n这种特定的交错演示了非原子更新序列如何导致不一致的状态。\n\n### 逐项分析\n\n**A. 诊断：复合的尾部推进操作是非原子的... 确定性调度：...**\n-   **诊断：** 该诊断正确地指出了非原子序列允许两个线程在前驱节点的 `$next$` 字段上竞争。它还正确地预测了后续的、乱序的对 `$tail$` 指针的更新会破坏不变量。这与我们的推导完全吻合。\n-   **调度：** 提议的调度强制执行了产生故障所需的确切交错：\n    1.  `$T_1$` 读取 `$tail = a$` 并链接 `$a.next \\leftarrow x_1$`。\n    2.  然后 `$T_1$` 被暂停。\n    3.  `$T_2$` 读取相同的 `$tail = a$`，覆盖该链接（`$a.next \\leftarrow x_2$`），然后更新 `$tail$` 指针（`$tail \\leftarrow x_2$`）。此时，列表是一致的：`$a \\rightarrow x_2$` 且 `$tail = x_2$`。\n    4.  `$T_1$` 被恢复并执行其最后一步：`$tail \\leftarrow x_1$`。\n-   **后置条件：** 最终状态是 `$a.next = x_2$` 和 `$tail = x_1$`。列表在 `$x_2$` 结束，但 `$tail$` 指针指向孤立的节点 `$x_1$`。这如所述违反了不变量。\n-   **结论：** 此选项提供了正确的诊断和在 SC 模型下触发特定错误的有效、确定性调度。**正确**。\n\n**B. 诊断：指令重排导致 `$tail \\leftarrow x$` (步骤 $4$) 发生在 `$t.next \\leftarrow x$` (步骤 $3$) 之前...**\n-   **分析：** 问题明确指定了顺序一致性（SC）内存模型。在 SC 模型下，虽然处理器可能在内部对其自身的指令进行重排，但这些重排对其他线程是不可见的。每个线程的操作必须对所有其他线程表现为按指定的程序顺序执行。因此，让步骤 4 在步骤 3 之前全局可见违反了 SC 模型。这个诊断适用于更弱的内存模型（如松散模型或 TSO），但不适用于 SC。\n-   **结论：** 该诊断与指定的内存模型不一致。**错误**。\n\n**C. 诊断：在使用比较并交换（CAS）更新 `$tail$` 时出现的“ABA问题”...**\n-   **分析：** 问题陈述中描述的算法使用简单的原子读写（`t \\leftarrow tail`，`$t.next \\leftarrow x$`）。它没有使用比较并交换（CAS）原子原语。ABA 问题是基于 CAS 的算法特有的一个著名问题，其中一个内存位置被读取（A），被另一个线程修改（B），然后恢复到原始值（A），从而欺骗了后续的 CAS 操作。由于给定的算法不使用 CAS，因此这个诊断是不相关的。\n-   **结论：** 该诊断涉及一个在问题的算法中不存在的机制。**错误**。\n\n**D. 诊断：基于遍历的尾部发现与并发插入发生竞争...**\n-   **分析：** 问题中的插入例程不是基于遍历的。步骤 $2$（`$t \\leftarrow tail$`）通过 `$tail$` 指针直接访问最后一个节点。该算法不会从 `$head$` 开始迭代以查找列表的末尾。因此，基于“基于遍历的尾部发现”竞争的诊断是不适用的。问题还指出是两个线程在执行尾部插入，而不是一个插入者和一个遍历者。\n-   **结论：** 该诊断描述了与问题中给出的不同的场景和算法。**错误**。",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}