{
    "hands_on_practices": [
        {
            "introduction": "掌握链表删除操作的第一步是理解其基本构成。这个练习将带你实现三种最核心的删除功能：删除头节点、尾节点和指定索引的节点。通过亲手实现这些操作，你将深刻体会到单向链表的结构特性（只能向前遍历）如何直接决定了不同删除算法的效率，特别是为何删除头节点是 $O(1)$ 操作，而删除尾节点却是 $O(n)$ 操作。",
            "id": "3245711",
            "problem": "给定单向链表的定义，它是一个有限的节点序列，其中每个节点存储一个非负整数键和一个指向下一个节点的引用，最后一个节点存储一个空引用。删除操作通过移除一个节点并根据需要重新链接引用来改变列表。使用单向链表作为抽象数据类型 (ADT) 定义的第一性原理，设计并实现以下操作，以转换头指针为 $H$ 的列表：\n- 操作 $delete\\_head(H)$：如果头节点存在，则移除它，并返回一个包含新头指针和被移除键的对。如果列表为空，则返回未改变的空头指针和整数 $-1$。\n- 操作 $delete\\_tail(H)$：如果尾节点存在，则移除它，并返回一个包含（可能更新的）头指针和被移除键的对。如果列表为空，则返回未改变的空头指针和整数 $-1$。\n- 操作 $delete\\_index(H,i)$，对于整数索引 $i \\ge 0$：如果存在位于从零开始的位置 $i$ 处的节点，则移除它，并返回一个包含（可能更新的）头指针和被移除键的对。如果不存在这样的节点，则返回未改变的头指针和整数 $-1$。\n\n您的实现必须纯粹遵循单向链表的核心定义：每个节点只有一个指向其后继节点的引用，没有指向前驱节点的引用。您必须基于此基础来推理设计算法，包括确定在执行删除之前是否必须通过遍历来找到前驱节点。您必须确保以下属性成立：\n- 对于 $delete\\_head(H)$，操作的运行时间为 $\\mathcal{O}(1)$，因为只触及 $H$ 和最多下一个引用。\n- 对于 $delete\\_tail(H)$，在最坏情况下，操作的运行时间为 $\\mathcal{O}(n)$，其中 $n$ 是节点数，因为必须通过遍历找到最后一个节点的唯一前驱。\n- 对于 $delete\\_index(H,i)$，在最坏情况下，操作的运行时间为 $\\mathcal{O}(n)$，因为当 $i \\ge 1$ 时，必须通过遍历找到索引 $i$ 处节点的唯一前驱。\n\n为使结果可量化和机器可检查，您的程序必须将一系列操作应用于指定的初始列表，并为每个测试用例报告两个产物：\n- 被移除键的有序列表，每个操作一个，当无法进行删除时使用整数 $-1$。\n- 最终列表，表示为一个普通整数数组（从头到尾的键）。所有初始列表中的所有键都是非负整数，因此整数 $-1$ 是一个明确的哨兵值，表示“未执行删除操作”。\n\n输入在程序中是固定的；没有外部输入。使用以下测试套件，其中每个测试用例包含一个初始列表和一系列操作。使用以下操作代码：$H$ 表示 $delete\\_head$，$T$ 表示 $delete\\_tail$，以及带一个整数参数的 $I$ 表示 $delete\\_index$。\n- 测试用例 $1$：初始列表 $[1, 2, 3, 4, 5]$，操作 $[(H), (I, 2), (T)]$。\n- 测试用例 $2$：初始列表 $[10]$，操作 $[(H), (T), (I, 0)]$。\n- 测试用例 $3$：初始列表 $[7, 8]$，操作 $[(I, 0), (I, 1), (T)]$。\n- 测试用例 $4$：初始列表 $[9, 9, 9]$，操作 $[(T), (I, 1), (H)]$。\n- 测试用例 $5$：初始列表 $[0, 1, 2]$，操作 $[(I, 5), (T), (I, 1), (H)]$。\n- 测试用例 $6$：初始列表 $[]$，操作 $[(H), (T), (I, 0)]$。\n\n您的程序必须生成单行输出，其中包含所有测试用例的结果，格式为一个由方括号括起来的逗号分隔列表。对于每个测试用例，结果是一个包含两个元素的列表：第一个元素是被移除键的列表（在适用时使用 $-1$），第二个元素是最终列表。具体来说，整体输出格式是形如\n$\\left[\\,\\text{case\\_1\\_result},\\text{case\\_2\\_result},\\ldots,\\text{case\\_6\\_result}\\,\\right]$ 的单行，\n其中每个 $\\text{case\\_k\\_result}$ 的格式为 $\\left[\\,\\text{removed\\_keys},\\ \\text{final\\_list}\\,\\right]$。\n\n此问题不涉及物理单位、角度或百分比。所有输出都是整数或整数列表。程序不得读取任何输入，并且必须严格按照上述格式打印一行输出。",
            "solution": "该问题要求设计并实现单向链表的三个基本删除操作：删除头节点、尾节点以及位于特定从零开始的索引 $i$ 处的节点。设计必须源于第一性原理，并认识到在单向链表中，每个节点只包含指向其后继节点的引用，而不包含指向其前驱节点的引用。\n\n单向链表是一种抽象数据类型 (ADT)，定义为一个节点序列。每个节点包含两个字段：一个值（在本例中为非负整数键）和一个指向序列中下一个节点的引用（或指针）。通过头指针 $H$ 访问列表，该指针引用第一个节点。最后一个节点的 `next` 引用为空，表示列表的结束。空列表由空头指针 $H$ 表示。\n\n让我们将节点结构定义为 `Node(key, next)`。\n\n**1. 操作 $delete\\_head(H)$**\n\n此操作移除列表的第一个节点。\n\n*   **原理与设计**：头节点可通过指针 $H$ 直接访问。要删除它，我们必须更新 $H$ 使其指向列表中的第二个节点。原始第二个节点的引用存储在原始头节点的 `next` 字段中。\n*   **算法**：\n    1.  检查列表是否为空（即 $H$ 是否为空）。如果是，则无法执行删除操作。根据问题规范，我们返回未改变的空头指针和哨兵值 $-1$。\n    2.  如果列表不为空，要移除的节点就是 $H$ 指向的节点。我们存储其键（称之为 $k_{removed}$）以备返回值使用。\n    3.  列表的新头节点将是当前头节点的后继节点。我们通过赋值 $H = H.next$ 来更新头指针。\n    4.  返回新的头指针和被移除的键 $k_{removed}$。\n*   **复杂度分析**：此操作涉及一次空检查、一次键检索和一次指针重新赋值。这些都是基本的、常数时间的操作。因此，时间复杂度为 $\\mathcal{O}(1)$，满足题目要求。\n\n**2. 操作 $delete\\_tail(H)$**\n\n此操作移除列表的最后一个节点。\n\n*   **原理与设计**：尾节点被定义为 `next` 指针为空的节点。要移除它，我们必须修改其前驱节点，将前驱节点的 `next` 指针设置为空。由于单向链表没有提供直接访问节点前驱的方法，我们必须从头指针 $H$ 开始遍历列表以找到尾节点的前驱。\n*   **算法**：\n    1.  处理空列表情况：如果 $H$ 为空，返回 $(H, -1)$。\n    2.  处理单节点列表情况：如果 $H.next$ 为空，则头节点也是尾节点。这简化为删除头节点。我们存储键，将 $H$ 设置为空，并返回新的空头指针和存储的键。\n    3.  对于具有 $n > 1$ 个节点的列表，我们必须找到尾节点的前驱。我们可以使用双指针遍历。设 `current` 为遍历列表的指针，`previous` 为始终落后 `current` 一步的指针。\n    4.  初始化 `previous = H` 和 `current = H.next`。\n    5.  遍历列表直到 `current.next` 为空。在每一步中，同时推进两个指针：`previous = current`，`current = current.next`。\n    6.  当循环终止时，`current` 指向尾节点，而 `previous` 指向其前驱（即新的尾节点）。\n    7.  存储尾节点的键 `current.key`。\n    8.  将新尾节点的 `next` 引用更新为空：`previous.next = null`。\n    9.  返回原始头指针 $H$（除非列表只有一个节点，否则它不变）和被移除的键。\n*   **复杂度分析**：对于大小为 $n$ 的列表，在最坏情况下（对于 $n > 1$），找到尾节点的前驱需要遍历 $n-1$ 个节点。遍历操作主导了运行时间。因此，时间复杂度为 $\\mathcal{O}(n)$，符合要求。\n\n**3. 操作 $delete\\_index(H, i)$**\n\n此操作移除给定从零开始的索引 $i \\ge 0$ 处的节点。\n\n*   **原理与设计**：\n    *   如果索引 $i$ 为 $0$，此操作等同于 $delete\\_head(H)$。\n    *   如果索引 $i$ 大于 $0$，我们必须移除位置 $i$ 处的节点。为此，我们需要将位置 $i-1$ 处的节点连接到位置 $i+1$ 处的节点。这需要从头开始遍历列表以找到位置 $i-1$ 处的节点（前驱节点）。\n*   **算法**：\n    1.  验证索引和列表状态。如果 $H$ 为空或 $i  0$，则索引无效或列表为空。我们可以返回 $(H, -1)$。问题陈述保证 $i \\ge 0$。\n    2.  处理 $i=0$ 的情况：这等同于删除头节点。我们可以简单地调用我们的 $delete\\_head(H)$ 逻辑并返回其结果。\n    3.  处理 $i  0$ 的情况：我们需要找到索引 $i-1$ 处的前驱节点。\n    4.  初始化一个指针 `previous = H` 和一个计数器 `count = 0`。\n    5.  遍历列表，推进 `previous` 并递增 `count`，直到 `count` 达到 $i-1$。循环条件应为 `count  i - 1` 且 `previous.next` 不为空。`previous.next` 的检查对于优雅地处理越界索引 $i$至关重要。\n    6.  循环结束后，检查遍历是否成功。如果 `previous` 为空或 `previous.next` 为空，这意味着我们在找到索引 $i$ 处的节点之前就到达了列表的末尾。因此，索引越界。返回 $(H, -1)$。\n    7.  如果找到了前驱节点，设 `node_to_delete = previous.next`。\n    8.  存储 `node_to_delete` 的键。\n    9.  通过更新前驱节点的 `next` 指针来绕过该节点：`previous.next = node_to_delete.next`。\n    10. 返回（未改变的）头指针 $H$ 和被移除的键。\n*   **复杂度分析**：\n    *   对于 $i=0$，复杂度为 $\\mathcal{O}(1)$。\n    *   对于 $i  0$，算法必须执行 $i-1$ 步的遍历以找到前驱。在最坏情况下，$i$ 可能是 $n-1$，需要遍历 $n-2$ 步。因此，最坏情况下的时间复杂度与 $n$ 成正比，即 $\\mathcal{O}(n)$，满足问题要求。\n\n这些设计严格遵守单向链表的约束，并为以下实现提供了基础。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass Node:\n    \"\"\"\n    Represents a node in a singly linked list.\n    Each node has a non-negative integer key and a reference to the next node.\n    \"\"\"\n    def __init__(self, key):\n        self.key = key\n        self.next = None\n\ndef build_list(keys):\n    \"\"\"\n    Builds a singly linked list from a list of keys.\n    Returns the head of the list.\n    \"\"\"\n    if not keys:\n        return None\n    head = Node(keys[0])\n    current = head\n    for key in keys[1:]:\n        current.next = Node(key)\n        current = current.next\n    return head\n\ndef list_to_array(head):\n    \"\"\"\n    Converts a singly linked list to a Python list of its keys.\n    \"\"\"\n    arr = []\n    current = head\n    while current:\n        arr.append(current.key)\n        current = current.next\n    return arr\n\ndef delete_head(head):\n    \"\"\"\n    Removes the head node if it exists.\n    Returns a pair (new head pointer, removed key).\n    If the list is empty, returns (null head, -1).\n    Time complexity: O(1).\n    \"\"\"\n    if not head:\n        return None, -1\n    \n    removed_key = head.key\n    new_head = head.next\n    return new_head, removed_key\n\ndef delete_tail(head):\n    \"\"\"\n    Removes the tail node if it exists.\n    Returns a pair ((possibly updated) head pointer, removed key).\n    If the list is empty, returns (null head, -1).\n    Time complexity: O(n).\n    \"\"\"\n    if not head:\n        return None, -1\n\n    # Case: Single node in the list\n    if not head.next:\n        removed_key = head.key\n        return None, removed_key\n\n    # Case: More than one node\n    # Traverse to find the second-to-last node\n    previous = head\n    current = head.next\n    while current.next:\n        previous = current\n        current = current.next\n    \n    removed_key = current.key\n    previous.next = None\n    return head, removed_key\n\ndef delete_index(head, i):\n    \"\"\"\n    Removes the node at zero-based position i.\n    Returns a pair ((possibly updated) head pointer, removed key).\n    If no such node exists, returns (unchanged head, -1).\n    Time complexity: O(n) in the worst case.\n    \"\"\"\n    if i  0 or not head:\n        return head, -1\n    \n    # Case: Delete head (i=0)\n    if i == 0:\n        return delete_head(head)\n\n    # Case: Delete at i > 0\n    # Traverse to the predecessor at index i-1\n    previous = head\n    count = 0\n    while count  i - 1 and previous:\n        previous = previous.next\n        count += 1\n    \n    # Check if index is out of bounds\n    if not previous or not previous.next:\n        return head, -1\n        \n    node_to_delete = previous.next\n    removed_key = node_to_delete.key\n    previous.next = node_to_delete.next\n    \n    return head, removed_key\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        ([1, 2, 3, 4, 5], [('H',), ('I', 2), ('T',)]),\n        # Test case 2\n        ([10], [('H',), ('T',), ('I', 0)]),\n        # Test case 3\n        ([7, 8], [('I', 0), ('I', 1), ('T',)]),\n        # Test case 4\n        ([9, 9, 9], [('T',), ('I', 1), ('H',)]),\n        # Test case 5\n        ([0, 1, 2], [('I', 5), ('T',), ('I', 1), ('H',)]),\n        # Test case 6\n        ([], [('H',), ('T',), ('I', 0)]),\n    ]\n\n    all_results = []\n    for initial_keys, operations in test_cases:\n        head = build_list(initial_keys)\n        removed_keys = []\n\n        for op in operations:\n            op_code = op[0]\n            removed_key = -1\n            if op_code == 'H':\n                head, removed_key = delete_head(head)\n            elif op_code == 'T':\n                head, removed_key = delete_tail(head)\n            elif op_code == 'I':\n                index = op[1]\n                head, removed_key = delete_index(head, index)\n            \n            removed_keys.append(removed_key)\n\n        final_list_array = list_to_array(head)\n        case_result = [removed_keys, final_list_array]\n        all_results.append(case_result)\n    \n    # Using str() on a list gives a compact representation like '[1,2,3]'\n    # Joining these string representations with a comma produces the final format.\n    results_str = ','.join(map(str, all_results))\n    \n    # The final output requires a specific format which includes replacing spaces\n    # that python's default str() for lists creates. E.g., '[1, 2]' becomes '[1,2]'\n    # (actually modern python str() is compact, no spaces, so this is fine)\n    final_output_str = f\"[{results_str}]\"\n    \n    # The problem description's example format has spaces: `[removed_keys, final_list]`\n    # and the template `f\"[{','.join(map(str, results))}]\"` produces `[[...],[...]]`\n    # without interior spaces. We will follow the template's output exactly.\n    # The default str() in Python 3 for lists does not add spaces after commas.\n    print(final_output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "链表问题的一大难点在于其线性访问的局限性，例如，我们无法轻易地“向后看”。这个练习提出了一个经典挑战：在一次遍历中删除链表倒数第 $k$ 个节点。为了解决这个问题，你将学习并应用强大的“双指针”技巧，这是一种在链表算法中应用极为广泛的核心技术。",
            "id": "3245572",
            "problem": "给定单链表和指针操作的核心定义作为基础。单链表是节点的一个有限序列，每个节点存储一个数据值和一个指向下一个节点的指针。形式上，一个长度为 $n$ 的列表可以表示为一个序列 $L = \\langle x_0, x_1, \\dots, x_{n-1} \\rangle$，其中对于 $i \\in \\{0,1,\\dots,n-1\\}$，每个节点 $x_i$ 包含一个指向 $x_{i+1}$ 的引用（对于 $i \\le n-2$），而 $x_{n-1}$ 包含一个指向空哨兵的引用，表示列表的末尾。删除位置 $i$（$i \\in \\{0,1,\\dots,n-1\\}$）的节点，需要更新位置 $i-1$ 的节点中存储的指针（如果 $i=0$ 则调整头指针），使其引用位置 $i+1$ 的节点（如果 $i=n-1$ 则引用空）。沿单链表的指针移动遵循以下规则：前进一步将从节点 $x_i$ 移动到节点 $x_{i+1}$（当 $i \\le n-2$ 时），或移动到空（当 $i=n-1$ 时）。\n\n任务：实现一个单次遍历算法，删除列表中倒数第 $k$ 个节点。给定指向列表 $L$ 的头指针和一个整数 $k \\ge 0$，您的算法必须最多从头到尾遍历一次（总体上每个节点最多访问一次）并使用 $O(1)$ 的辅助空间。要求的行为如下：\n- 如果 $k = 0$，不移除任何节点，并原样返回原始列表。\n- 如果 $k \\in \\{1,2,\\dots,n\\}$，移除索引为 $n - k$ 的节点（其中头节点的索引为 $0$）。\n- 如果 $k  n$，不移除任何节点，并原样返回原始列表。\n- 如果 $n = 0$（列表为空），则对任何 $k$ 都返回空列表。\n\n您必须根据上述核心定义逻辑地推导出您的算法，不依赖于未经解释的捷径。该算法必须可通过单次遍历实现，方法是维持一个不变量，当到达列表末尾时，该不变量能正确识别待删除节点的前驱节点。\n\n您的程序的输入格式是内部固定的；没有外部输入。您的程序应嵌入并运行以下测试套件，其中每个测试用例包含一个列表和一个 $k$ 值。每个列表都写为数学序列，而 $k$ 是一个整数。为清楚起见，以下列表应被解释为按相同顺序排列的整数序列：\n- 测试 $1$：$L = \\langle 1,2,3,4,5 \\rangle$, $k=2$。\n- 测试 $2$：$L = \\langle 10 \\rangle$, $k=1$。\n- 测试 $3$：$L = \\langle \\rangle$, $k=1$。\n- 测试 $4$：$L = \\langle 7,8,9 \\rangle$, $k=3$。\n- 测试 $5$：$L = \\langle 1,2,3 \\rangle$, $k=4$。\n- 测试 $6$：$L = \\langle 1,1,1,1 \\rangle$, $k=1$。\n- 测试 $7$：$L = \\langle 5,6 \\rangle$, $k=2$。\n- 测试 $8$：$L = \\langle 2,3,4,5 \\rangle$, $k=0$。\n- 测试 $9$：$L = \\langle 1,2,3 \\rangle$, $k=2$。\n- 测试 $10$：$L = \\langle 9,8,7,6,5 \\rangle$, $k=5$。\n\n对于每个测试，您的程序必须应用上述删除规则计算结果列表。最终输出必须将所有结果聚合到单一行中，格式如下：一个用方括号括起来的逗号分隔列表，其中每个元素本身是另一个用方括号书写且不含空格的结果列表。例如，如果前两个结果是 $\\langle 1,3,5 \\rangle$ 和 $\\langle \\rangle$，它们将显示为 $[ [1,3,5],[] ]$，所有方括号内都没有空格。具体来说，您的程序必须精确地打印一行，其内容是单个方括号括起来的、由方括号列表组成的列表，且所有方括号内都没有空格，即形式为 $[ [a_1,\\dots],[],[b_1,b_2],\\dots ]$，但移除所有方括号内的空格。\n\n您的程序必须是一个完整的、可运行的实现，它执行测试套件并按规定格式打印聚合的单行结果。每个测试用例的答案是一个整数列表。",
            "solution": "问题陈述是有效的。它提出了一个定义明确的关于数据结构的算法任务，特别是在严格的性能约束下从单链表中删除一个节点。该问题在科学上基于基础的计算机科学原理，提供了一套完整且一致的规则，并使用了客观、形式化的语言。因此，我们可以着手提供一个解决方案。\n\n任务是设计一个使用 $O(1)$ 辅助空间的单次遍历算法，从一个长度为 $n$ 的单链表 $L$ 中删除倒数第 $k$ 个节点。该列表由其头指针给出。删除规则针对所有非负整数 $k$ 值进行了规定。\n\n设列表为 $L = \\langle x_0, x_1, \\dots, x_{n-1} \\rangle$。要删除的节点是倒数第 $k$ 个，对应于索引为 $n-k$ 的节点（对于 $k \\in \\{1, 2, \\dots, n\\}$）。为执行删除操作，我们必须修改其前驱节点（即索引为 $n-k-1$ 的节点）的 `next` 指针。在不先计算长度 $n$ 的情况下，通过单次遍历定位这个前驱节点是核心挑战。单次遍历和 $O(1)$ 空间约束排除了一个简单的两次遍历方法（第一次遍历找到 $n$，第二次遍历迭代到节点 $n-k-1$）。\n\n该问题可以通过在两个指针遍历列表时维持它们之间的固定距离来解决。这通常被称为双指针技术。让我们形式化地推导该算法。\n\n为了透明地处理边缘情况，例如删除列表的头节点（当 $k=n$ 时）或处理空列表，我们引入一个哨兵节点，我们称之为 `dummy`。这个 `dummy` 节点放置在列表的实际头节点之前，使得 `dummy.next` 指向原始头节点 $x_0$。我们的算法将返回 `dummy.next` 作为列表的新头节点。\n\n算法流程如下：\n\n1.  **初始检查**：根据问题规范，如果 $k=0$，则不发生删除。算法应立即返回原始列表。如果列表为空（$n=0$），`head` 指针为 `null`，算法应返回一个 `null` 指针。\n\n2.  **指针初始化**：我们初始化两个指针，分别称为 `slow` 和 `fast`，它们都从 `dummy` 节点开始。\n    $$ \\text{slow} \\leftarrow \\text{dummy} $$\n    $$ \\text{fast} \\leftarrow \\text{dummy} $$\n\n3.  **建立间距**：核心思想是在 `slow` 和 `fast` 指针之间创建一个 $k$ 个节点的间距。我们通过将 `fast` 指针从其初始位置向前推进 $k$ 步来实现这一点。\n    $$ \\text{for } i \\text{ from } 1 \\text{ to } k: $$\n    $$ \\quad \\text{fast} \\leftarrow \\text{fast.next} $$\n    在此阶段，我们必须处理 $k  n$ 的情况。如果 `fast` 在任何时候变为空，意味着列表的节点数少于 $k$。在这种情况下，按照规定，列表保持不变。因此，我们在循环中检查 `fast` 是否为空，如果满足条件，则返回原始 `head`。\n\n4.  **同步遍历**：在 `fast` 指针前进了 $k$ 步之后，我们开始同步地向前移动两个指针，一次一步，直到 `fast` 指针到达列表的最后一个节点。循环终止的条件是 `fast.next` 为空。\n    $$ \\text{while fast.next is not null}: $$\n    $$ \\quad \\text{slow} \\leftarrow \\text{slow.next} $$\n    $$ \\quad \\text{fast} \\leftarrow \\text{fast.next} $$\n\n    让我们分析指针的最终位置以确认此过程的正确性。设列表长度为 $n$。指针 `slow` 从有效索引 $-1$（`dummy` 节点）开始，而 `fast` 在其初始的 $k$ 次推进后从索引 $k-1$ 开始。然后两个指针同步前进相同的步数，比如说 $m$ 步，直到 `fast` 到达索引为 $n-1$ 的最后一个节点。`fast` 的最终索引是 $(k-1) + m$。将其等同于最后一个节点的索引，我们得到：\n    $$ (k-1) + m = n-1 \\implies m = n-k $$\n    `slow` 指针也从其位于索引 $-1$ 的起始位置移动了 $m = n-k$ 步。因此其最终位置是：\n    $$ \\text{index}(\\text{slow}) = -1 + m = -1 + (n-k) = n-k-1 $$\n    这正是待删除节点（位于索引 $n-k$）的前驱节点的索引。这个不变量——即 `fast` 指针领先 `slow` 指针 $k$ 个节点——确保了当 `fast` 遍历到末尾时，`slow` 正好位于正确的位置。\n\n5.  **节点删除**：当 `slow` 指向目标节点的前驱节点时，删除操作就只是一个简单的指针操作。`slow` 的 `next` 指针被更新以绕过目标节点：\n    $$ \\text{slow.next} \\leftarrow \\text{slow.next.next} $$\n\n6.  **返回值**：最终可能被修改的列表的头节点是 `dummy.next`。返回此指针。\n\n此算法正确处理了所有指定情况。对于 $k=n$ 的情况，`fast` 指针在初始的 $k$ 次前进后恰好落在最后一个节点上，因此 `while` 循环不会执行。`slow` 指针保持在 `dummy` 节点。删除步骤 `dummy.next = dummy.next.next` 正确地移除了原始头节点。该算法只遍历列表一次，并使用常数数量的辅助变量（`dummy`、`slow`、`fast`），从而满足 $O(1)$ 空间和单次遍历的约束。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Definition for singly-linked list node.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the formatted output.\n    \"\"\"\n\n    test_cases = [\n        ([1, 2, 3, 4, 5], 2),\n        ([10], 1),\n        ([], 1),\n        ([7, 8, 9], 3),\n        ([1, 2, 3], 4),\n        ([1, 1, 1, 1], 1),\n        ([5, 6], 2),\n        ([2, 3, 4, 5], 0),\n        ([1, 2, 3], 2),\n        ([9, 8, 7, 6, 5], 5)\n    ]\n\n    def build_list(values: list[int]) - ListNode | None:\n        \"\"\"Helper to build a linked list from a Python list of values.\"\"\"\n        if not values:\n            return None\n        dummy = ListNode()\n        current = dummy\n        for val in values:\n            current.next = ListNode(val)\n            current = current.next\n        return dummy.next\n\n    def list_to_py_list(head: ListNode | None) - list[int]:\n        \"\"\"Helper to convert a linked list back to a Python list.\"\"\"\n        result = []\n        current = head\n        while current:\n            result.append(current.val)\n            current = current.next\n        return result\n\n    def removeNthFromEnd(head: ListNode | None, k: int) - ListNode | None:\n        \"\"\"\n        Deletes the k-th node from the end of the list.\n        k = 0.\n        \"\"\"\n        # Per problem spec, if k=0, return the list unchanged.\n        if k == 0:\n            return head\n\n        # A dummy node helps handle edge cases like removing the head.\n        dummy = ListNode(0, head)\n        slow = dummy\n        fast = dummy\n\n        # Advance the fast pointer k steps ahead of the slow pointer.\n        # This creates a gap of k nodes.\n        for _ in range(k):\n            # If fast becomes None, it means k = n, the length of the list.\n            # If k  n, the list should be returned unchanged as per spec.\n            # If k == n, the head will be removed by the main logic later,\n            # but this structure requires a check to prevent `fast.next` on None.\n            # My check is done after the loop for k>n, and the traversal for k=n handles it.\n            if fast.next is None:\n                # This condition means k = n (number of nodes).\n                # If k  n, do nothing.\n                # If k == n, we need to remove the head.\n                # The node to remove is n-th from end. With dummy, it is (n+1)-th from dummy.\n                # If we advanced fast n times and fast.next is None, then k=n.\n                # The only way to know if k  n is to traverse again.\n                # A better way is to move fast k+1 steps.\n                #\n                # Let's try simpler logic.\n                # A counter can tell us list length to detect k  n. This is 2 passes.\n                # Let's stick with the two-pointer system which is O(1) space, 1 pass.\n                # To handle k>n, we can count the list length while moving 'fast'\n                # but this is messy. Let's reconsider.\n                # A clean method: advance fast by k nodes. If it reaches null, k  n.\n                fast_probe = head\n                for _ in range(k):\n                    if not fast_probe: # k > n\n                        return head\n                    fast_probe = fast_probe.next\n                # If fast_probe is null, k=n. Remove head.\n                if not fast_probe:\n                    return head.next\n\n                # now we know 1 = k = n.\n                # fast_probe is k steps ahead of head.\n                # let slow_probe starts at head.\n                slow_probe = head\n                while fast_probe.next:\n                    slow_probe = slow_probe.next\n                    fast_probe = fast_probe.next\n                # slow_probe is now the predecessor of the node to delete.\n                slow_probe.next = slow_probe.next.next\n                return head\n\n        # This logic is what was derived in the solution text, it's elegant.\n        # It handles all cases correctly.\n        fast = head\n        slow = head\n        # Advance fast pointer k steps.\n        for _ in range(k):\n            if not fast: # k > n, return original list.\n                return head\n            fast = fast.next\n\n        # If fast is None, it means k = n, so we remove the head.\n        if not fast:\n            return head.next\n\n        # Move both until fast reaches the end. slow will be the predecessor.\n        while fast.next:\n            slow = slow.next\n            fast = fast.next\n        \n        # Delete the node.\n        slow.next = slow.next.next\n\n        return head\n\n    def removeNthFromEnd_final(head: ListNode | None, k: int) - ListNode | None:\n        \"\"\"My final, most robust derived algorithm\"\"\"\n        if k == 0:\n            return head\n\n        dummy = ListNode(0, head)\n        left = dummy\n        right = head\n\n        # Advance right pointer k steps\n        for _ in range(k):\n             if not right: # k > n\n                 return head\n             right = right.next\n        \n        # Move both until right reaches end\n        while right:\n            left = left.next\n            right = right.next\n        \n        # left is now the predecessor of the node to delete\n        left.next = left.next.next\n        \n        return dummy.next\n\n    results = []\n    for case in test_cases:\n        list_vals, k_val = case\n        linked_list_head = build_list(list_vals)\n        \n        # Call the algorithm\n        modified_head = removeNthFromEnd_final(linked_list_head, k_val)\n        \n        # Convert result back to Python list\n        result_py_list = list_to_py_list(modified_head)\n        \n        # Format the list as a string without spaces\n        result_str = str(result_py_list).replace(\" \", \"\")\n        results.append(result_str)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了基本的删除和双指针技巧后，让我们来挑战一个更复杂的场景。这个练习要求你从一个有序链表中移除所有重复出现过的元素，只保留那些独一无二的值。这不仅考验你对指针的精妙操控，更需要你结合模式识别（识别连续的重复元素块）来设计算法，从而将之前学到的技能融会贯通。",
            "id": "3245645",
            "problem": "给定单链表和有序序列的基本定义。单链表是一个节点序列，其中每个节点包含一个值和一个指向下一个节点的引用，最后一个节点引用一个空后继。如果对于每对相邻的值 $x_i$ 和 $x_{i+1}$ 都满足 $x_i \\le x_{i+1}$，则称该序列为按非递减顺序排序。在此类有序列表中，任何值 $v$ 的所有出现都是连续的。\n\n任务：从这些定义和事实出发，编写一个完整的、可运行的程序。对于每个提供的测试用例，该程序从一个有序的整数序列构建一个单链表，然后删除列表中值出现两次或多次的所有节点，只保留值恰好出现一次的节点。剩余节点的顺序必须保持不变。\n\n形式上，对于给定的有限有序输入序列 $A = [a_1,a_2,\\dots,a_m]$，定义计数函数 $c(v) = |\\{\\,i \\in \\{1,\\dots,m\\} : a_i = v\\,\\}|$。您的程序必须删除其值 $v$ 满足 $c(v) \\ge 2$ 的每个节点，并保留其值 $v$ 满足 $c(v) = 1$ 的每个节点。结果列表必须编码输出序列 $B$，该序列精确包含在 $A$ 中仅出现一次的那些值，并保持其原始顺序。\n\n您的程序不得读取输入。相反，它必须在内部运行以下有序序列的测试套件（每个序列定义一个单链表）：\n\n- 案例 $1$：$[1,2,3,3,4,4,5]$\n- 案例 $2$：$[1,1,1,2,3]$\n- 案例 $3$：$[1,2,3,3]$\n- 案例 $4$：$[1,1,1]$\n- 案例 $5$：$[1]$\n- 案例 $6$：$[]$\n- 案例 $7$：$[1,2,2,2,3,4,4,5,5,5,6]$\n- 案例 $8$：$[1,1,2,3,3,4,5,5,6,7,7,7,8]$\n- 案例 $9$：$[-3,-3,-2,-1,-1,0,1,1,2]$\n- 案例 $10$：$[0,1,2,3,4,5,6]$\n\n测试套件的覆盖意图：\n- 具有多个重复段的一般情况：案例 $1$、$7$ 和 $8$。\n- 仅在头部有重复项：案例 $2$。\n- 仅在尾部有重复项：案例 $3$。\n- 所有节点都是重复的：案例 $4$。\n- 单节点和空列表：案例 $5$ 和 $6$。\n- 存在负值和零：案例 $9$。\n- 已是唯一序列：案例 $10$。\n\n您的程序必须输出一行，其中包含聚合在单个外部列表中的所有结果。每个结果必须是该测试用例的结果序列 $B$，表示为用方括号括起来、逗号分隔的整数列表。因此，最终输出必须是这些内部列表的方括号括起来、逗号分隔的列表。输出中不得包含任何空白字符。例如，如果有 $k$ 个名为 $R_1,\\dots,R_k$ 的结果，输出将打印为\n$[R_1,R_2,\\dots,R_k]$，\n其中每个 $R_i$ 本身的形式为 $[x_1,x_2,\\dots,x_t]$ 且 $t \\ge 0$。\n\n每个测试用例的答案是一个整数列表。您的程序必须仅使用单链表的结构和操作来实现删除，利用其有序属性，并且运行时间应为 $\\mathcal{O}(n)$，额外空间复杂度为 $\\mathcal{O}(1)$（不包括输入和输出），其中 $n$ 是列表的长度。\n\n不适用任何物理单位或角度单位。所有整数都是精确的，必须以十进制打印，不带任何附加格式。",
            "solution": "从有序单链表中删除所有具有重复值的节点的问题，可以通过利用输入序列的有序特性来解决。该特性确保了任何给定值 $v$ 的所有出现都是连续的。目标是设计一个算法，如果一个连续的节点块包含多个节点（即，该值出现两次或多次），则移除整个节点块。该算法必须仅使用链表操作原地执行，时间复杂度达到 $\\mathcal{O}(n)$，空间复杂度在列表本身存储之外达到 $\\mathcal{O}(1)$，其中 $n$ 是节点数。\n\n核心原则是对列表进行单次遍历，识别并绕过任何重复节点的子列表。这可以使用恒定数量的指针高效实现。\n\n算法的一个关键要素是使用 `sentinel`（哨兵）或 `dummy`（哑）节点。这是链表操作中的一种标准技术，可以简化边界情况，特别是当列表的头节点本身需要被移除时。创建哨兵节点，并将其 `next` 指针设置为列表的原始头节点。然后，算法将从哨兵节点开始处理列表，最终结果将是由 `sentinel.next` 指向的列表。\n\n遍历和修改逻辑依赖于两个主要指针：\n$1$. 一个 `predecessor`（前驱）指针，我们称之为 $p_{pred}$，它始终指向已验证的“干净”列表（已确认只包含唯一元素的部分）的最后一个节点。最初，$p_{pred}$ 设置为哨兵节点。\n$2$. 一个 `current`（当前）指针，$p_{curr}$，用于扫描原始列表。最初，$p_{curr}$ 设置为列表的原始头节点。\n\n算法通过在 $p_{curr}$ 不为空时进行迭代来推进：\n- 在 $p_{curr}$ 指向的每个节点处，我们检查它是否是重复序列的一部分。如果 $p_{curr}$ 有后继节点（$p_{curr}$.next 不为空）并且它们的值相等（$p_{curr}$.val == $p_{curr}$.next.val），则为真。\n\n- **情况 1：发现重复序列。**如果 $p_{curr}$ 是一个重复块的开始，我们必须跳过整个块。使用一个内部循环来推进 $p_{curr}$，直到它指向重复值连续块中的*最后一个*节点。一旦找到块的末尾，就重新连接列表以排除整个块。这是通过将前驱节点 $p_{pred}$ 的 `next` 指针设置为指向重复块紧随其后的节点，即 $p_{curr}$.next 来完成的。请注意，在这种情况下，前驱指针 $p_{pred}$ 本身不前进，因为我们还没有找到要附加到干净列表的新节点。\n\n- **情况 2：当前节点不是重复项。**如果未满足重复序列的条件，则意味着 $p_{curr}$ 处的节点是唯一的（至少相对于其直接后继而言）。因此，该节点应包含在最终列表中。我们通过简单地将前驱指针移动到当前节点来实现这一点：$p_{pred} = p_{pred}$.next。\n\n- 在这两种情况下，主遍历指针 $p_{curr}$ 都前进到其下一个节点，以继续扫描列表。\n\n这个过程一直持续到 $p_{curr}$ 遍历完整个列表。最终修改后列表的头节点由 `sentinel.next` 给出。这种方法正确处理了所有情况，包括列表头部、尾部或中间的重复项，以及整个列表都由重复项组成（导致空列表）或根本不包含重复项的情况。每个节点被访问常数次，从而实现了所需的 $\\mathcal{O}(n)$ 时间复杂度，并且只使用了少数几个额外指针，满足了 $\\mathcal{O}(1)$ 空间复杂度的约束。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass ListNode:\n    \"\"\"\n    Represents a node in a singly linked list.\n    \"\"\"\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n    def __repr__(self):\n        # Helper for debugging\n        return f\"ListNode({self.val})\"\n\ndef build_linked_list(items):\n    \"\"\"\n    Constructs a singly linked list from a list of values.\n    \"\"\"\n    if not items:\n        return None\n    head = ListNode(items[0])\n    current = head\n    for item in items[1:]:\n        current.next = ListNode(item)\n        current = current.next\n    return head\n\ndef linked_list_to_pylist(head):\n    \"\"\"\n    Converts a singly linked list back into a Python list.\n    \"\"\"\n    items = []\n    current = head\n    while current:\n        items.append(current.val)\n        current = current.next\n    return items\n\ndef delete_all_duplicates(head: ListNode | None) - ListNode | None:\n    \"\"\"\n    Deletes all nodes that have duplicate numbers from a sorted linked list,\n    leaving only nodes with distinct numbers from the original list.\n    The algorithm runs in O(n) time and O(1) space.\n    \"\"\"\n    # Sentinel node to handle edge cases like removing the head.\n    sentinel = ListNode(0, head)\n    \n    # Predecessor is the last node in the result list so far.\n    predecessor = sentinel\n    \n    current = head\n    \n    while current:\n        # If current is the start of a duplicate sequence.\n        if current.next and current.val == current.next.val:\n            # Move to the end of the duplicate sequence.\n            while current.next and current.val == current.next.val:\n                current = current.next\n            # Skip all duplicates. The predecessor's next will point\n            # to the node after the entire duplicate sequence.\n            predecessor.next = current.next\n        else:\n            # If no duplicate, the current node is kept.\n            # Move the predecessor pointer forward.\n            predecessor = predecessor.next\n            \n        # Move the current pointer forward to continue scanning.\n        current = current.next\n            \n    return sentinel.next\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and produce the final output.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [1,2,3,3,4,4,5],\n        [1,1,1,2,3],\n        [1,2,3,3],\n        [1,1,1],\n        [1],\n        [],\n        [1,2,2,2,3,4,4,5,5,5,6],\n        [1,1,2,3,3,4,5,5,6,7,7,7,8],\n        [-3,-3,-2,-1,-1,0,1,1,2],\n        [0,1,2,3,4,5,6]\n    ]\n\n    results = []\n    for case_data in test_cases:\n        # 1. Construct the linked list from the input sequence.\n        head = build_linked_list(case_data)\n        \n        # 2. Apply the deletion algorithm.\n        new_head = delete_all_duplicates(head)\n        \n        # 3. Convert the resulting linked list back to a Python list.\n        result_list = linked_list_to_pylist(new_head)\n        \n        results.append(result_list)\n\n    # Final print statement in the exact required format.\n    # e.g., [[1,2,5],[2,3],[],[1],[]] with no whitespace.\n    output_str = \"[\" + \",\".join([str(r).replace(\" \", \"\") for r in results]) + \"]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}