{
    "hands_on_practices": [
        {
            "introduction": "理论学习之后，最好的巩固方式莫过于动手实践。我们从一个基础但至关重要的操作开始：合并两个已排序的循环链表。这个练习将经典的线性归并思想应用于循环结构，要求我们首先“断开”链表的环，执行标准的线性合并，然后巧妙地“闭合”新链表，恢复其循环特性。通过这个实践 ，你将加深对循环链表指针操作的理解，并学会如何将线性算法适配到循环数据结构中。",
            "id": "3220711",
            "problem": "给定两个已排序的循环单链表，其节点包含整数键。循环单链表定义为一系列节点，其中每个节点都有一个指向下一个节点的指针，最后一个节点指回初始节点，形成一个环。已排序的循环单链表是指存在一个指定的起始节点（称为头节点），从该头节点开始遍历与列表中节点数量完全相同的步数，会得到一个非递减的键序列。目标是通过仅重用现有节点和重连指针，将两个输入列表合并成一个已排序的循环单链表。合并操作必须在 $O(n+m)$ 的时间内完成，其中 $n$ 和 $m$ 分别是两个输入列表的长度，并且节点的额外空间复杂度为 $O(1)$。您可以使用辅助变量和常数个额外指针，但不得分配、删除或复制任何节点。\n\n使用的基本定义：\n- 单链表节点由一个来自整数集的键和一个指向下一个节点的指针组成。循环单链表的特征是不变量：最后一个节点的 next 指针引用头节点。\n- 如果对于每对相邻的键 $x_i$ 和 $x_{i+1}$，都有 $x_i \\le x_{i+1}$，则称该序列为非递减排序。\n\n任务：\n1. 从第一性原理出发，构建一个方法，该方法仅使用指针重连和整数键比较，从上述定义开始，确定性地生成一个正确的合并后循环列表。您必须基于排序性和循环性的不变量来论证其正确性，并实现 $O(n+m)$ 的时间复杂度。\n2. 在一个完整的可运行程序中实现此方法，该程序：\n   - 根据给定的有限整数序列内部构建循环列表（每个序列代表从头节点开始、遍历列表确切长度的顺序）。\n   - 将两个循环列表合并成一个已排序的循环列表。\n   - 通过选择合并后列表的头节点为最小键，并精确遍历 $n+m$ 步，生成合并后循环列表的规范线性表示作为输出。如果两个输入列表都为空，则合并后的列表也为空，该情况下的输出为空列表。\n\n测试套件：\n对于下面的每个测试用例，程序必须：\n- 从提供的序列 $A$ 和 $B$ 构建两个循环列表。\n- 在 $O(n+m)$ 时间内将它们合并成一个已排序的循环列表。\n- 输出一个列表，该列表代表从合并后列表中的最小键开始、精确遍历 $|A|+|B|$ 步的结果。\n\n测试用例如下：\n- 用例 $1$：$A=\\langle 1,4,7 \\rangle$, $B=\\langle 2,3,9,10 \\rangle$。\n- 用例 $2$：$A=\\langle \\rangle$, $B=\\langle 5,6 \\rangle$。\n- 用例 $3$：$A=\\langle \\rangle$, $B=\\langle \\rangle$。\n- 用例 $4$：$A=\\langle 1,1,2 \\rangle$, $B=\\langle 1,2,2,3 \\rangle$。\n- 用例 $5$：$A=\\langle 5 \\rangle$, $B=\\langle 4 \\rangle$。\n- 用例 $6$：$A=\\langle -3,-1,2 \\rangle$, $B=\\langle -2,0,1,3 \\rangle$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如，$[result_1,result_2,\\dots]$）。每个 $result_i$ 必须是一个 Python 整数列表，代表相应测试用例的合并后遍历结果。",
            "solution": "问题要求将两个已排序的循环单链表（分别表示为 $A$ 和 $B$，长度为 $n$ 和 $m$）合并成一个单一的、已排序的循环单链表。约束条件是合并必须通过重连指针就地（in-place）完成，时间复杂度为 $O(n+m)$，节点分配的空间复杂度为 $O(1)$。\n\n首先，我们确立问题陈述的有效性。\n\n### 步骤 1：提取已知信息\n- **输入数据**：两个已排序的循环单链表。设其头节点为 $H_A$ 和 $H_B$。\n- **节点定义**：一个节点包含一个整数键和一个 `next` 指针。\n- **循环列表定义**：遍历序列中的最后一个节点指回头节点。\n- **已排序循环列表定义**：存在一个头节点，从该节点开始遍历列表长度的步数会产生一个非递减的键序列。每个测试用例的输入序列代表从指定的头节点开始的这种遍历。\n- **目标**：将两个列表合并成一个单一的、已排序的循环单链表。\n- **约束条件**：\n    - 合并必须是就地的（重用现有节点）。\n    - 时间复杂度必须是 $O(n+m)$。\n    - 新节点的辅助空间必须是 $O(1)$，但允许使用常数个额外指针。\n- **输出规格**：合并后的列表必须表示为一个线性的键序列，该序列通过从具有最小键的节点开始遍历列表生成。对于两个空列表，输出为空列表。\n- **测试用例**：\n    - 用例 $1$：$A=\\langle 1,4,7 \\rangle$, $B=\\langle 2,3,9,10 \\rangle$。\n    - 用例 $2$：$A=\\langle \\rangle$, $B=\\langle 5,6 \\rangle$。\n    - 用例 $3$：$A=\\langle \\rangle$, $B=\\langle \\rangle$。\n    - 用例 $4$：$A=\\langle 1,1,2 \\rangle$, $B=\\langle 1,2,2,3 \\rangle$。\n    - 用例 $5$：$A=\\langle 5 \\rangle$, $B=\\langle 4 \\rangle$。\n    - 用例 $6$：$A=\\langle -3,-1,2 \\rangle$, $B=\\langle -2,0,1,3 \\rangle$。\n\n### 步骤 2：使用提取的已知信息进行验证\n该问题定义明确，并且基于数据结构和算法这一标准计算机科学主题。\n- **科学依据**：循环链表、排序性、就地合并等概念都是已确立的正式主题。没有科学或事实上的谬误。\n- **适定性**：问题规范清晰。对于给定的输入，“已排序循环列表”的定义是明确的。从最小键开始的规范输出格式确保了解决方案表示的唯一性。\n- **完整性和一致性**：所有必要的定义和约束（时间、空间、就地操作）都已提供。特殊情况（如空列表）也已明确提及。该问题是自洽的，没有矛盾。\n\n### 步骤 3：结论与行动\n该问题被判定为**有效**。我们继续构建解决方案。\n\n### 基于第一性原理的合并算法设计\n\n核心原理是将合并两个已排序循环列表的问题，简化为合并两个已排序线性列表这个众所周知的问题。这可以通过临时断开循环、执行标准的线性合并，然后在最终的合并列表中恢复循环性来实现。\n\n**步骤 1：处理边界情况**\n最简单的情况涉及一个或两个列表为空。\n- 如果列表 $A$ 为空（即其头指针 $H_A$ 为空），则合并结果就是列表 $B$。\n- 如果列表 $B$ 为空（即其头指针 $H_B$ 为空），则合并结果就是列表 $A$。\n- 如果两者都为空，则结果是一个空列表（一个空指针）。\n\n**步骤 2：将循环列表线性化**\n要执行线性合并，我们必须首先将循环列表视为线性列表。一个头节点为 $H$、长度为 $n > 0$ 的已排序循环列表有一个唯一的尾节点 $T$，使得从 $H$ 开始遍历 $n-1$ 步可以到达 $T$，并且 $T.\\text{next} = H$。\n1.  识别列表 $A$ 的尾节点，记为 $T_A$。这可以通过从 $H_A$ 开始遍历，直到找到一个节点 `curr` 使得 `curr.next` 等于 $H_A$。此操作耗时 $O(n)$。对于只有一个节点的列表，头节点也是尾节点。\n2.  类似地，在 $O(m)$ 时间内识别列表 $B$ 的尾节点，记为 $T_B$。\n3.  通过设置 $T_A.\\text{next} = \\text{null}$ 和 $T_B.\\text{next} = \\text{null}$ 来断开循环链接。现在我们有两个标准的、已排序的线性链表，分别从 $H_A$ 和 $H_B$ 开始。\n\n**步骤 3：执行就地线性合并**\n我们将两个线性列表合并成一个单一的、已排序的线性列表。一个稳健的方法是使用一个虚拟头节点来简化合并列表的初始化。\n1.  创建一个临时虚拟节点 `dummy_head`。创建一个指针 `current_tail` 并将其初始化为 `dummy_head`。这个 `current_tail` 指针将跟踪新形成列表的末尾。\n2.  初始化两个指针 $p_A = H_A$ 和 $p_B = H_B$，用于遍历这两个列表。\n3.  在 $p_A$ 和 $p_B$ 都不为空时进行迭代。在每次迭代中，比较 $p_A$ 和 $p_B$ 处的键。\n    - 如果 $p_A.\\text{key} \\le p_B.\\text{key}$，通过设置 `current_tail.next = p_A` 将 $p_A$ 追加到合并列表中，并将 $p_A$ 前进到其下一个节点。\n    - 否则，通过设置 `current_tail.next = p_B` 追加 $p_B$，并将 $p_B$ 前进。\n    - 无论哪种情况，都将 `current_tail` 前进到刚刚追加的节点（`current_tail = current_tail.next`）。\n4.  循环终止后，其中一个列表将被耗尽（其指针将为空）。另一个列表可能仍包含剩余节点。将未耗尽列表的整个剩余部分追加到合并列表的末尾。如果 $p_A$ 不为空，则 `current_tail.next = p_A`。否则，`current_tail.next = p_B`。\n\n完全合并后的线性列表的头节点是 `dummy_head.next`。根据问题对已排序循环列表的定义，给定的头节点 $H_A$ 和 $H_B$ 分别是它们各自列表的最小元素。线性合并过程从选择 $H_A$ 和 $H_B$ 中较小者开始，确保合并后列表的头节点是全局最小元素。\n\n**步骤 4：恢复循环性**\n线性合并后，我们得到一个单一的、已排序的线性列表。最后一步是使其变为循环的。\n1.  合并后列表的头节点 `merged_head` 是 `dummy_head.next`。\n2.  合并后列表的尾节点是那个其剩余部分被最后追加的原始列表的尾节点。如果列表 $A$ 先被耗尽，那么列表 $B$ 的剩余部分被追加，新的尾节点就是原始的 $T_B$。如果列表 $B$ 先被耗尽，新的尾节点就是 $T_A$。如果两个列表同时被耗尽，新的尾节点就是循环中 `current_tail` 的最终值。一个简单的识别尾节点的方法是，我们已经存储了 $T_A$ 和 $T_B$。指向被追加的列表段的指针（循环后的 `p_A` 或 `p_B`）决定了最终的尾节点。\n3.  将这个新尾节点的 `next` 指针设置为指向 `merged_head`。\n\n**复杂度分析**\n- **时间复杂度**：找到尾节点需要 $O(n) + O(m)$。线性合并涉及对所有节点的一次遍历，需要 $O(n+m)$。所有其他操作（指针赋值）需要 $O(1)$ 时间。因此，总时间复杂度为 $O(n+m)$。\n- **空间复杂度**：该算法使用常数数量的辅助指针（$H_A, T_A, H_B, T_B, p_A, p_B, \\text{dummy\\_head}, \\text{current\\_tail}$）。除了单个 `dummy_head` 外，没有分配新节点。因此，辅助空间复杂度为 $O(1)$，满足问题的约束条件。\n\n此过程正确且高效地合并了两个列表，同时遵守所有指定的约束。结果列表是已排序的循环列表，其头节点是具有最小键的节点，为规范的输出遍历做好了准备。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass Node:\n    \"\"\"\n    A node in a singly linked list.\n    It holds an integer key and a pointer to the next node.\n    \"\"\"\n    def __init__(self, key):\n        self.key = key\n        self.next = None\n\n    def __repr__(self):\n        return f\"Node({self.key})\"\n\ndef build_circular_list(sequence):\n    \"\"\"\n    Builds a sorted circular singly linked list from a sequence of integers.\n    The sequence is assumed to be sorted and represents the traversal from the head.\n    \"\"\"\n    if not sequence:\n        return None\n\n    head = Node(sequence[0])\n    current = head\n    for i in range(1, len(sequence)):\n        current.next = Node(sequence[i])\n        current = current.next\n    \n    # Make it circular\n    current.next = head\n    return head\n\ndef traverse_and_format(head):\n    \"\"\"\n    Traverses a circular linked list starting from the head and returns the keys as a list.\n    \"\"\"\n    if not head:\n        return []\n\n    result = []\n    current = head\n    # Use a do-while loop emulation\n    result.append(current.key)\n    current = current.next\n    while current != head:\n        result.append(current.key)\n        current = current.next\n    \n    return result\n\ndef merge_sorted_circular_lists(head_a, head_b):\n    \"\"\"\n    Merges two sorted circular singly linked lists into one.\n\n    The method follows these steps:\n    1. Handles edge cases where one or both lists are empty.\n    2. Finds the tail of each list to facilitate breaking the circular structure.\n    3. Breaks the circles, turning them into two sorted linear lists.\n    4. Performs an in-place merge of the two linear lists.\n    5. Restores the circular structure on the final merged list.\n    \"\"\"\n    # 1. Handle edge cases\n    if not head_a:\n        return head_b\n    if not head_b:\n        return head_a\n\n    # 2. Find the tails of both lists\n    tail_a = head_a\n    while tail_a.next != head_a:\n        tail_a = tail_a.next\n    \n    tail_b = head_b\n    while tail_b.next != head_b:\n        tail_b = tail_b.next\n\n    # 3. Temporarily break the circles to form linear lists\n    tail_a.next = None\n    tail_b.next = None\n\n    # 4. Perform in-place linear merge using a dummy head\n    p_a, p_b = head_a, head_b\n    dummy_head = Node(None)  # A temporary node\n    current_tail = dummy_head\n\n    while p_a and p_b:\n        if p_a.key = p_b.key:\n            current_tail.next = p_a\n            p_a = p_a.next\n        else:\n            current_tail.next = p_b\n            p_b = p_b.next\n        current_tail = current_tail.next\n\n    # Append the remaining list\n    # The new overall tail will be the tail of the list that is appended.\n    new_tail = None\n    if p_a:\n        current_tail.next = p_a\n        new_tail = tail_a\n    else: # p_b must exist or be None\n        current_tail.next = p_b\n        new_tail = tail_b\n\n    merged_head = dummy_head.next\n    \n    # If merged list is empty (should not happen if inputs are valid), return None\n    if not merged_head:\n        return None\n\n    # 5. Restore circularity\n    # If both lists had elements, new_tail is correctly set.\n    # If one of the original lists was empty (handled at start), this code is not reached.\n    # If both input lists had equal length and merge ended perfectly,\n    # current_tail is the true tail. new_tail was set to tail_b by default.\n    final_tail = current_tail\n    while final_tail.next:\n        final_tail = final_tail.next\n    \n    final_tail.next = merged_head\n    \n    return merged_head\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and produce the final output.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        ([1, 4, 7], [2, 3, 9, 10]),\n        # Case 2\n        ([], [5, 6]),\n        # Case 3\n        ([], []),\n        # Case 4\n        ([1, 1, 2], [1, 2, 2, 3]),\n        # Case 5\n        ([5], [4]),\n        # Case 6\n        ([-3, -1, 2], [-2, 0, 1, 3]),\n    ]\n\n    results = []\n    for case_a, case_b in test_cases:\n        head_a = build_circular_list(case_a)\n        head_b = build_circular_list(case_b)\n\n        merged_head = merge_sorted_circular_lists(head_a, head_b)\n        \n        # The problem requires traversal starting from the smallest key.\n        # The merge logic ensures merged_head is the node with the minimum key\n        # because the input heads are the minimums of their respective lists.\n        result_list = traverse_and_format(merged_head)\n        results.append(result_list)\n\n    # Format the final output as a string representing a list of lists.\n    # Python's default str() for a list already uses brackets and commas, so this is simple.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "接下来，我们挑战一个更具巧思的问题：在只有一个任意节点指针、不知道头节点和链表长度的情况下，如何将一个循环链表对半分割。这个问题模拟了在某些系统应用中可能遇到的真实场景。解决此问题的关键在于运用经典的“龟兔赛跑”（快慢指针）算法 ，通过两个移动速度不同的指针，我们可以在一次遍历中同时确定链表的长度奇偶性并找到中点。这个练习将向你展示一种非常优雅且高效的算法技巧，它在处理未知长度的链表和环路检测问题时极为有用。",
            "id": "3220641",
            "problem": "给定一个循环单链表。循环单链表是一系列节点，每个节点都有一个指向下一个节点的指针，且最后一个节点的next指针指回第一个节点。你只获得一个指向某个任意节点的指针，记为$p$，而不是指向任何指定的“头”节点。目标是设计一个算法，当节点数$n$为偶数时，将该链表拆分为两个大小相等的循环链表；当$n$为奇数时，检测并报告无法进行均等拆分。\n\n基本原理和假设：\n- 一个包含$n$个节点的循环单链表构成一个长度为$n$的唯一环。\n- 在一个长度为$n$的环上，一个前进$s$个节点的指针会到达一个距离其起始位置$s \\bmod n$步的位置。\n- 使用两个指针时，一个每次迭代前进$1$个节点（“慢指针”），另一个每次迭代前进$2$个节点（“快指针”）。$k$次迭代后，慢指针前进了$k$步，快指针前进了$2k$步。\n\n任务：\n- 从$p$开始，确定链表的长度$n$是否为偶数。如果是，则定位到沿环路方向恰好在$p$前方$n/2$步的节点$q$。\n- 重置next指针，形成两个大小相等且不相交的循环链表。第一个链表必须包含$p$，第二个链表必须包含$q$。如果$n$为奇数，则输出无法进行均等拆分。\n- 拆分算法必须仅依赖于从$p$派生的链表结构中的指针操作，在拆分步骤中不得使用辅助数组来存储整个序列。\n\n测试输入规范（嵌入程序中）：\n- 程序将根据以下参数值的测试套件在内部构建循环单链表。每个测试用例由一个包含节点值序列和零基索引$i$的对指定，该索引$i$指示哪个节点的指针将作为任意指针$p$提供。\n- 测试套件：\n    1. 值 $\\{10,20,30,40,50,60,70,80\\}$ 和索引 $i=3$。\n    2. 值 $\\{1,2\\}$ 和索引 $i=1$。\n    3. 值 $\\{5,5,5,5,5,5\\}$ 和索引 $i=4$。\n    4. 值 $\\{1,2,3,4,5\\}$ 和索引 $i=2$。\n    5. 值 $\\{0,-1,-2,-3\\}$ 和索引 $i=0$。\n\n输出规范：\n- 对于每个$n$为偶数的测试用例，输出一个包含两个列表的列表：\n    - 第一个内部列表是通过遍历第一个生成的循环链表遇到的值的序列，从$p$开始，恰好经过$n/2$步后返回到$p$。\n    - 第二个内部列表是通过遍历第二个生成的循环链表遇到的值的序列，从$q$开始，恰好经过$n/2$步后返回到$q$。\n- 对于每个$n$为奇数的测试用例，输出整数$-1$。\n- 最终输出格式：你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个元素要么是$-1$，要么是如上所述的一对列表（例如，`[[a_1,a_2,...],[b_1,b_2,...]]`）。\n\n解决方案中需证明的正确性标准：\n- 论证快慢指针技术如何在不需要头指针的情况下检测$n$的奇偶性并识别分割点$q$。\n- 解释为什么当$n$为偶数时，通过局部指针更改可以产生两个长度相等且不相交的环。\n- 提供使用大O表示法（Big-O）表示的渐进时间复杂度和空间复杂度。\n\n程序必须实现此逻辑，并为提供的测试套件生成精确的聚合输出。此问题不涉及任何物理单位、角度单位或百分比单位。",
            "solution": "对用户提供的问题陈述进行形式化分析和验证。\n\n### 第1步：提取已知信息\n- **数据结构**：一个节点数$n$未知的循环单链表。\n- **输入**：一个指向链表中任意节点的指针$p$。\n- **目标**：\n    1. 确定链表长度$n$是偶数还是奇数。\n    2. 如果$n$为偶数，将链表拆分为两个大小为$n/2$的不相交循环链表。第一个链表必须包含$p$，第二个链表必须包含距离$p$有$n/2$步的节点$q$。\n    3. 如果$n$为奇数，报告无法进行均等拆分。\n- **约束**：算法必须“就地”操作，仅使用指针操作，在拆分过程中不得使用辅助数据结构（如数组）来存储节点序列。\n- **基本假设**：\n    - 一个包含$n$个节点的循环链表构成一个长度为$n$的唯一环。\n    - 在长度为$n$的环上，指针前进$s$步会到达一个由$s \\pmod n$决定的位置。\n    - 一个慢指针（每次迭代前进$1$步）和一个快指针（每次迭代前进$2$步）在$k$次迭代后分别移动了$k$步和$2k$步。\n- **输出规范**：对于偶数$n$，输出一个包含两个节点值列表的列表，分别对应从$p$和$q$开始的两个新环。对于奇数$n$，输出整数$-1$。\n- **正确性标准**：解决方案必须论证奇偶性检测方法的正确性、拆分过程的正确性，并提供时间和空间复杂度的分析。\n\n### 第2步：使用提取的已知信息进行验证\n对问题进行严格的验证过程。\n- **科学依据**：该问题设定在数据结构和算法的形式化领域内，这是计算机科学的核心领域。它依赖于链表、指针运算以及“龟兔赛跑”（快慢指针）算法等成熟概念。所有前提在事实上和逻辑上都是合理的。\n- **良构性**：该问题是良构的。输入、目标和约束都以数学精度进行了规定。对于偶数和奇数长度的情况，期望的输出都有明确的定义，确保可以推导出唯一且有意义的解决方案。\n- **客观性**：问题以客观、形式化的语言陈述，没有任何主观或模糊的术语。\n\n### 第3步：结论与行动\n问题陈述是**有效的**。它是自包含的、逻辑一致的，并基于计算机科学的既定原则。因此，有必要提供一个完整的解决方案。\n\n### 算法设计与论证\n\n解决方案是一个三步过程：($1$) 确定链表长度$n$的奇偶性，并同时找到分割点$q$；($2$) 重置指针以形成两个独立的链表；以及($3$) 分析算法的性能。\n\n**第1部分：奇偶性检测与分割点识别**\n\n这一步的核心是快慢指针技术。我们将两个指针`slow`和`fast`初始化为给定的起始节点$p$。\n- `slow_ptr` = $p$\n- `fast_ptr` = $p$\n\n然后我们进行迭代，以不同速度推进指针，直到满足终止条件。在每次迭代 $k \\ge 1$中：\n- `slow_ptr` 前进$1$步：`slow_ptr = slow_ptr.next`。\n- `fast_ptr` 前进$2$步：`fast_ptr = fast_ptr.next.next`。\n\n经过$k$次迭代后，`slow_ptr`从$p$移动了$k$步，而`fast_ptr`从$p$移动了$2k$步。关键的洞见在于`fast_ptr`何时首次返回起始节点$p$。\n\n**论证**：\n- **情况1：$n$为偶数。** 设$n = 2m$，其中$m \\ge 1$为整数。当`fast_ptr`的总位移$2k$是$n=2m$的倍数时，它会返回到$p$。使之发生的最小正整数$k$是$k=m$。在这一确切时刻：\n    - `fast_ptr`相对于$p$的位置是 $(2m) \\pmod{2m} = 0$。因此，`fast_ptr == p`。\n    - `slow_ptr`相对于$p$的位置是 $k=m=n/2$。这正是所需分割节点$q$的定义。\n    - 在这种情况下，条件`fast_ptr.next == p`永远不会在`fast_ptr == p`之前满足，因为那将意味着$2k+1$是$n=2m$的倍数，而奇数不可能是偶数的倍数，所以这是不可能的。\n\n- **情况2：$n$为奇数。** 设$n = 2m+1$，其中$m \\ge 1$为整数。\n    - 要使`fast_ptr`位于$p$，则$2k$必须是$n=2m+1$的倍数。由于$\\gcd(2, 2m+1) = 1$，这要求$k$是$n$的倍数。第一次发生这种情况是在$k=n$步时。\n    - 考虑条件`fast_ptr.next == p`。这意味着`fast_ptr`位于$p$的前一个节点，即相对于$p$的位置为$n-1$或$-1$。这种情况发生在 $2k \\equiv n-1 \\pmod n$时。对于$n=2m+1$，即 $2k \\equiv 2m \\pmod{2m+1}$。如果我们选择$k=m$，则有 $2m \\equiv 2m \\pmod{2m+1}$，这是成立的。这个条件在$k=m=(n-1)/2$步时满足。\n    - 由于$k=(n-1)/2$小于$k=n$，对于奇数长度的链表，`fast_ptr.next == p`这个条件将首先被满足。\n\n因此，算法如下：\n$1$. 将`slow`和`fast`指针初始化为$p$。\n$2$. 循环，每一步将`slow`前进$1$，`fast`前进$2$。\n$3$. 如果`fast == p`，则链表长度为偶数。此时`slow`指针指向$q$。进入第2部分。\n$4$. 如果`fast.next == p`，则链表长度为奇数。无法进行均等拆分。终止并报告。\n\n**第2部分：对偶数长度$n$的链表进行拆分**\n\n如果链表长度$n$为偶数，第1部分为我们提供了指针$p$和指针$q$（即`slow_ptr`的最终位置）。节点$q$恰好在$p$前方$n/2$步。原始链表结构是一个单一的环：\n$p \\rightarrow \\dots \\rightarrow p_{\\text{end}} \\rightarrow q \\rightarrow \\dots \\rightarrow q_{\\text{end}} \\rightarrow p$\n\n要创建两个长度为$n/2$的不相交环，我们必须识别节点$p_{\\text{end}}$和$q_{\\text{end}}$，并重置它们的`next`指针。\n- $p_{\\text{end}}$是$q$的前驱节点。\n- $q_{\\text{end}}$是$p$的前驱节点。\n\n这些前驱节点可以通过简单的遍历找到：\n- 寻找$p_{\\text{end}}$：从$p$开始一个临时指针，并前进它，直到其`next`指针为$q$。这需要$n/2 - 1$步。\n- 寻找$q_{\\text{end}}$：从$q$开始一个临时指针，并前进它，直到其`next`指针为$p$。这也需要$n/2 - 1$步。\n\n一旦$p_{\\text{end}}$和$q_{\\text{end}}$被定位，重置指针就变得很简单：\n$1$. `p_end.next = p`\n$2$. `q_end.next = q`\n\n这将第一个链的末端重新指向其起点（$p$），并将第二个链的末端重新指向其起点（$q$），从而创建了两个独立的循环链表：\n- 环1：$p \\rightarrow \\dots \\rightarrow p_{\\text{end}} \\rightarrow p$\n- 环2：$q \\rightarrow \\dots \\rightarrow q_{\\text{end}} \\rightarrow q$\n\n两个环的长度都为$n/2$，符合要求。此过程仅依赖于局部指针操作，并遵守了问题的约束。\n\n**第3部分：复杂度分析**\n\n- **时间复杂度**：算法的运行时间主要由指针遍历决定。\n    - 奇偶性检测（第1部分）：循环运行大约$n/2$次迭代。在每次迭代中，我们执行常数数量的操作（3次指针前进）。这是$O(n)$。\n    - 寻找前驱节点（第2部分，对于偶数$n$）：找到$p_{\\text{end}}$需要$n/2 - 1$步。找到$q_{\\text{end}}$需要$n/2 - 1$步。这也是$O(n)$。\n    - 总体时间复杂度为$O(n) + O(n) = O(n)$。\n\n- **空间复杂度**：无论链表大小如何，算法都使用固定数量的指针（`p`、`q`、`slow`、`fast`以及用于遍历的临时指针）。没有使用随$n$扩展的辅助数据结构。\n    - 空间复杂度是常数级的，即$O(1)$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass Node:\n    \"\"\"A node in a circular singly linked list.\"\"\"\n    def __init__(self, value, next_node=None):\n        self.value = value\n        self.next = next_node\n\n    def __repr__(self):\n        return f\"Node({self.value})\"\n\ndef build_circular_linked_list(values, start_index):\n    \"\"\"Constructs a circular linked list from a sequence of values.\"\"\"\n    if not values:\n        return None\n    \n    n = len(values)\n    nodes = [Node(val) for val in values]\n    \n    for i in range(n):\n        nodes[i].next = nodes[(i + 1) % n]\n        \n    return nodes[start_index]\n\ndef traverse_and_collect(start_node):\n    \"\"\"Traverses a circular list from a start node and collects values.\"\"\"\n    if not start_node:\n        return []\n    \n    path = []\n    current = start_node\n    while True:\n        path.append(current.value)\n        current = current.next\n        if current == start_node:\n            break\n    return path\n\ndef split_circular_list(p):\n    \"\"\"\n    Splits a circular linked list into two halves if its length is even.\n    \n    Args:\n        p: A pointer to an arbitrary node in the circular linked list.\n\n    Returns:\n        A list of two lists of node values for the new cycles if n is even.\n        -1 if n is odd.\n    \"\"\"\n    if not p or p.next == p:\n        # A list with 0 or 1 node cannot be split into two non-empty lists.\n        # The problem implies n = 2 for a split. Odd length - impossible.\n        return -1\n        \n    slow = p\n    fast = p\n    \n    while True:\n        slow = slow.next\n        \n        # Fast pointer must be able to advance twice\n        if not fast.next or not fast.next.next:\n            # This case should not be reached in a proper circular list  1 node\n            return -1 \n        fast = fast.next.next\n        \n        # Condition for odd length list\n        if fast.next == p:\n            return -1\n        \n        # Condition for even length list\n        if fast == p:\n            q = slow\n            break\n            \n    # At this point, n is even and q is the node at distance n/2 from p.\n    # Now we need to find the predecessors of p and q to rewire the list.\n    \n    # Find p_end (predecessor of q)\n    p_end = p\n    while p_end.next != q:\n        p_end = p_end.next\n        \n    # Find q_end (predecessor of p)\n    q_end = q\n    while q_end.next != p:\n        q_end = q_end.next\n        \n    # Rewire the pointers to form two separate cycles\n    p_end.next = p\n    q_end.next = q\n    \n    # Collect the values from the two new lists\n    list1_values = traverse_and_collect(p)\n    list2_values = traverse_and_collect(q)\n    \n    return [list1_values, list2_values]\n    \ndef solve():\n    \"\"\"\n    Defines test cases and runs the splitting algorithm on each,\n    producing the final formatted output.\n    \"\"\"\n    test_suite = [\n        ({'values': [10, 20, 30, 40, 50, 60, 70, 80], 'index': 3}),\n        ({'values': [1, 2], 'index': 1}),\n        ({'values': [5, 5, 5, 5, 5, 5], 'index': 4}),\n        ({'values': [1, 2, 3, 4, 5], 'index': 2}),\n        ({'values': [0, -1, -2, -3], 'index': 0}),\n    ]\n\n    results = []\n    for case in test_suite:\n        p = build_circular_linked_list(case['values'], case['index'])\n        result = split_circular_list(p)\n        \n        if result == -1:\n            results.append(str(-1))\n        else:\n            list1, list2 = result\n            l1_str = f\"[{','.join(map(str, list1))}]\"\n            l2_str = f\"[{','.join(map(str, list2))}]\"\n            results.append(f\"[{l1_str},{l2_str}]\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "最后，我们来解决一个综合性的高级挑战：在$O(n \\\\log n)$的时间复杂度和$O(1)$的额外空间复杂度下对循环链表进行就地排序。这项任务的严格约束使得标准的递归归并排序（会占用$O(\\\\log n)$的栈空间）不再适用。正确的思路是实现一种自底向上的迭代式归并排序 ，它从最小的有序子列表（单个节点）开始，通过多轮迭代，逐步合并成越来越大的有序子列表，最终完成整个链表的排序。这个练习综合了分治思想、迭代算法设计以及对空间复杂度的深刻理解，是检验你对链表操作掌握程度的绝佳试金石。",
            "id": "3220604",
            "problem": "您的任务是设计并实现一个算法，该算法接收一个循环单链表（其节点各包含一个整数键值），通过重排节点指针，使得从头节点开始遍历 $n$ 步时（$n$ 为链表中节点的数量）能得到一个非递减序列。该算法的运行时间必须为 $O(n \\log n)$，仅使用 $O(1)$ 的额外空间，且不得分配辅助数组、使用递归或创建超过常数数量的额外节点或指针。循环单链表定义为一个节点序列，其中每个节点有一个指向其后继节点的指针，且最后一个节点指向第一个节点。\n\n基本依据和定义：\n- 单链表是一个节点序列，其中每个节点有一个指向下一个节点的指针和一个存储的键值。循环单链表是一种单链表，其中最后一个节点指向第一个节点，形成一个环。节点数量表示为 $n$。\n- 允许的操作包括整数键值的比较、指针的读写以及节点指针的重新链接。存储的键值可以包含任何整数，包括负值和重复值。不允许使用超过 $O(1)$ 额外空间的外部存储；具体来说，您可以使用常数数量的临时指针和可选的常数大小的辅助节点，但不得分配数组或使用其栈深度依赖于 $n$ 的递归。\n\n您的目标：\n- 从第一性原理出发，推导一种在 $O(n \\log n)$ 时间和仅 $O(1)$ 额外空间内将循环单链表按非递减顺序排序的方法。您的推导应仅基于链表的核心定义和基于比较的合并操作的不变性，不应使用任何捷径。\n- 将此方法实现为一个完整、可运行的程序，该程序构建多个测试循环链表，对它们进行原地排序，并以整数列表的形式输出其排序后的内容。\n\n测试套件：\n提供并处理以下测试用例，每个用例都表示为一个整数数组，将被嵌入程序中，并在排序前转换为循环单链表：\n1. 空列表：$[\\ ]$，其中 $n = 0$。\n2. 单个元素：$[7]$，其中 $n = 1$。\n3. 已排序：$[1,2,3,4,5]$，其中 $n = 5$。\n4. 逆序：$[5,4,3,2,1]$，其中 $n = 5$。\n5. 含重复元素：$[3,1,2,3,2,1]$，其中 $n = 6$。\n6. 旋转的非递减循环链表：$[4,5,1,2,3]$，其中 $n = 5$。\n7. 含负数：$[-2,-1,-3,0,2]$，其中 $n = 5$。\n8. 所有元素相等：$[2,2,2,2]$，其中 $n = 4$。\n\n输出规范：\n- 对于每个测试用例，在排序后，通过从结果循环链表的头节点开始遍历 $n$ 步，提取恰好 $n$ 个值，生成一个非递减的数组表示。\n- 您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如，[$r_1$,$r_2$,$r_3$,$\\dots$]），其中每个 $r_i$ 是测试用例 $i$ 的非递减顺序整数列表。不应打印任何其他文本。",
            "solution": "提交审议的问题陈述是有效的。它提出了一个在数据结构和算法领域中定义明确且具有科学依据的问题。其目标是为循环单链表设计并实现一个时间复杂度为 $O(n \\log n)$、空间复杂度为 $O(1)$ 的原地排序算法，其中 $n$ 是节点数。这些约束条件严苛但并不矛盾，共同构成了一个经典的、非平凡的算法挑战。该问题是可形式化的，其解决方案也是可验证的。因此，我们可以着手进行推导和求解。\n\n推导过程从第一性原理出发，通过分析约束条件来选择并调整一个合适的排序算法。\n\n**1. 算法选择：Merge Sort**\n\n$O(n \\log n)$ 的时间复杂度和链表数据结构的约束强烈指向 **Merge Sort**。让我们分析一下其他替代方案：\n- 最坏情况时间复杂度为 $O(n^2)$ 的基于比较的排序算法，如 **Insertion Sort** 或 **Selection Sort**，速度太慢，无法满足 $O(n \\log n)$ 的要求。\n- **Quick Sort** 虽然平均时间复杂度为 $O(n \\log n)$，但它不适合链表。其效率依赖于分区步骤，该步骤需要高效地访问相对于枢轴的元素。在数组中，这通过交换两端元素（一种随机访问操作）来实现。而在链表中，这将需要复杂的指针操作或反向遍历（单链表不支持），从而降低性能并使实现复杂化。此外，其最坏情况时间复杂度仍为 $O(n^2)$。\n- **Heap Sort** 需要堆数据结构，而堆最高效的实现方式是使用数组，以便在 $O(1)$ 时间内计算父节点和子节点的索引。在链表上模拟堆效率低下，无法达到所要求的时间复杂度。\n\n**Merge Sort** 是自然的选择。其操作方式是递归地将列表分成两半，然后合并已排序的两半。这种顺序访问模式与链表的结构完美兼容。标准的 Merge Sort 可实现 $O(n \\log n)$ 的时间复杂度。然而，标准实现是递归的，对于大小为 $n$ 的列表，它会在调用栈上消耗 $O(\\log n)$ 的空间。这违反了严格的 $O(1)$ 空间约束。\n\n**2. 满足空间约束：迭代式自底向上 Merge Sort**\n\n为了满足 $O(1)$ 的空间约束，我们必须采用 **Merge Sort** 的**迭代式、自底向上**版本。该方法通过从最小的已排序子列表开始，并系统地将它们合并成逐渐增大的已排序子列表，从而消除了递归。\n\n该算法分轮次进行。在第一轮中，我们将单个节点视为大小为 $k=1$ 的已排序子列表。我们合并这些子列表的相邻对，以形成大小为 2 的已排序子列表。在第二轮中，我们设置 $k=2$，并合并大小为 2 的相邻已排序子列表，以形成大小为 4 的已排序子列表。此过程持续进行，每一轮将子列表大小 $k$ 加倍（$k = 1, 2, 4, 8, \\dots$），直到整个列表成为一个单一的已排序序列。由于 $k$ 在每一轮中都加倍，总共将有 $\\lceil \\log_2 n \\rceil$ 轮，从而得到 $O(n \\log n)$ 的总时间复杂度。\n\n**3. 整体算法结构**\n\n完整的算法包括三个主要阶段：\n\n**阶段 1：预处理（线性化）**\n输入是一个循环单链表。这种结构对于拆分和合并逻辑来说不方便，因为它缺乏明确的起点和终点。第一步是将其转换为标准的线性链表。\n- 我们从任意一个 `head` 节点开始遍历列表，找到最后一个节点（即其 `next` 指针指向 `head` 的节点）。\n- 在遍历过程中，我们计算节点数量 $n$。\n- 然后，我们将最后一个节点的 `next` 指针设置为 `None`，从而有效地断开环，创建一个长度为 $n$ 的线性链表。此阶段耗时 $O(n)$。\n\n**阶段 2：迭代合并**\n这是排序算法的核心部分。它包含一个循环，该循环以递增的子列表大小 $k$ 来迭代执行合并轮次。\n- 外层循环在 $k  n$ 的条件下，以 $k = 1, 2, 4, \\dots$ 的方式运行。\n- 在此循环内部，执行一次“合并轮次”。一轮操作会遍历当前列表，反复取出两个大小为 $k$ 的相邻子列表，将它们合并成一个大小为 $2k$ 的已排序子列表，并将这个合并后的子列表链接到一个新的、部分排序的列表中。\n- 为了在 $O(1)$ 额外空间内管理指针，我们维护一个指向列表未处理部分头部的指针，以及一个指向正在构建的新列表尾部的指针。\n- 在一轮中的每次合并操作：\n    1.  分割出第一个大小至多为 $k$ 的子列表。\n    2.  分割出第二个大小至多为 $k$ 的子列表。\n    3.  对这两个子列表调用 `merge` 函数。\n    4.  将得到的已排序列表追加到正在构建的新列表的尾部。\n    5.  更新尾指针和指向未处理部分的指针。\n- 在每一轮完整操作之后，新构建列表的头部将成为下一轮（$k$ 值加倍）要处理的列表。\n\n**`merge(list1, list2)` 函数：**\n这个辅助函数是基于比较的排序的核心。它接收两个已排序链表的头节点 `list1` 和 `list2` 作为输入。通过迭代比较 `list1` 和 `list2` 中当前节点的键值，并将键值较小的节点追加到合并列表中，它创建了一个包含两个输入列表所有节点的新排序列表。使用一个临时的虚拟头节点来简化构建合并列表的逻辑。该函数返回新创建的单一排序列表的头节点。此操作所需时间与两个列表的长度之和成正比。\n\n**阶段 3：后处理（再循环化）**\n在最后一轮合并（当 $k \\ge n$ 时）之后，结果是一个单一的、已排序的线性链表。该列表的头节点是包含整个数据集中最小键值的节点。\n- 为了恢复循环结构，我们遍历这个已排序的线性链表以找到其最后一个节点。\n- 然后我们将这个最后节点的 `next` 指针设置回指向列表的头节点。\n- 这个新的循环链表的头节点就是最终结果。此阶段耗时 $O(n)$。\n\n**复杂度分析**\n- **时间复杂度**：该算法的外层循环运行 $\\log n$ 次（因为 $k$ 每次加倍）。内层的 `merge_pass` 在每一轮中恰好处理 $n$ 个节点中的每一个一次。因此，总时间复杂度为 $O(n \\log n)$。\n- **空间复杂度**：该算法使用常数数量的指针进行遍历和链接（例如 `head`、`current`、`tail`），无论列表大小 $n$ 如何。像 `merge` 这样的辅助函数可能会使用一个临时的虚拟节点。这构成了常数数量的额外空间，因此空间复杂度为 $O(1)$。\n\n这个遵循第一性原理的推导得出的算法满足了所有问题约束。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass Node:\n    \"\"\"A node in a singly linked list.\"\"\"\n    def __init__(self, key, next_node=None):\n        self.key = key\n        self.next = next_node\n\n    def __repr__(self):\n        return f\"Node({self.key})\"\n\ndef build_circular_linked_list(keys):\n    \"\"\"Builds a circular singly linked list from a list of keys.\"\"\"\n    if not keys:\n        return None, 0\n    n = len(keys)\n    head = Node(keys[0])\n    current = head\n    for key in keys[1:]:\n        current.next = Node(key)\n        current = current.next\n    current.next = head  # Make it circular\n    return head, n\n\ndef to_list(head, n):\n    \"\"\"Converts n nodes of a circular linked list to a Python list.\"\"\"\n    if not head:\n        return []\n    result = []\n    current = head\n    for _ in range(n):\n        if current is None: # Should not happen for a circular list of size n  0\n            break\n        result.append(current.key)\n        current = current.next\n    return result\n\ndef merge(list1, list2):\n    \"\"\"Merges two sorted linked lists into one.\"\"\"\n    dummy = Node(0)\n    tail = dummy\n    while list1 and list2:\n        if list1.key = list2.key:\n            tail.next = list1\n            list1 = list1.next\n        else:\n            tail.next = list2\n            list2 = list2.next\n        tail = tail.next\n    tail.next = list1 if list1 else list2\n    return dummy.next\n\ndef sort_circular_list(head, n):\n    \"\"\"\n    Sorts a circular singly linked list in-place using iterative merge sort.\n    Time complexity: O(n log n)\n    Space complexity: O(1)\n    \"\"\"\n    # 1. Handle edge cases where the list is already sorted.\n    if n = 1:\n        return head\n\n    # 2. Convert circular list to a linear list.\n    # The last node is found by traversing n-1 steps.\n    current = head\n    for _ in range(n - 1):\n        current = current.next\n    current.next = None  # Break the circle. `head` is the start of the linear list.\n\n    list_head = head\n    k = 1\n    while k  n:\n        # Each pass merges sublists of size k.\n        dummy_head = Node(0)\n        current_tail = dummy_head\n        current_head = list_head\n\n        while current_head:\n            # a. Split off list1 of size k\n            list1 = current_head\n            temp = list1\n            for _ in range(k - 1):\n                if not temp: break\n                temp = temp.next\n            \n            if not temp:  # list1 is shorter than k\n                current_head = None\n            else:\n                current_head = temp.next\n                temp.next = None  # Cut list1\n\n            # b. Split off list2 of size k, if it exists\n            list2 = current_head\n            if not list2:\n                current_tail.next = list1\n                break  # This pass is done\n\n            temp = list2\n            for _ in range(k - 1):\n                if not temp: break\n                temp = temp.next\n\n            if not temp:  # list2 is shorter than k\n                current_head = None\n            else:\n                current_head = temp.next\n                temp.next = None  # Cut list2\n\n            # c. Merge list1 and list2 and append to the result\n            merged = merge(list1, list2)\n            current_tail.next = merged\n            \n            # d. Find the new tail to continue appending\n            while current_tail.next:\n                current_tail = current_tail.next\n\n        list_head = dummy_head.next\n        k *= 2\n\n    # 3. Re-circularize the sorted list\n    new_head = list_head\n    if new_head:\n        last_node = new_head\n        while last_node.next:\n            last_node = last_node.next\n        last_node.next = new_head\n        \n    return new_head\n\n\ndef solve():\n    \"\"\"\n    Defines test cases, runs the sorting algorithm, and prints the results.\n    \"\"\"\n    test_cases = [\n        [],\n        [7],\n        [1, 2, 3, 4, 5],\n        [5, 4, 3, 2, 1],\n        [3, 1, 2, 3, 2, 1],\n        [4, 5, 1, 2, 3],\n        [-2, -1, -3, 0, 2],\n        [2, 2, 2, 2],\n    ]\n\n    results = []\n    for case_keys in test_cases:\n        head, n = build_circular_linked_list(case_keys)\n        sorted_head = sort_circular_list(head, n)\n        sorted_list = to_list(sorted_head, n)\n        results.append(str(sorted_list))\n\n    # Final print statement in the exact required format.\n    # The str() on a list gives a string like '[1, 2, 3]'.\n    # Joining these with commas gives '[1, 2, 3],[4, 5, 6]'.\n    # We then wrap the whole thing in one more pair of brackets.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}