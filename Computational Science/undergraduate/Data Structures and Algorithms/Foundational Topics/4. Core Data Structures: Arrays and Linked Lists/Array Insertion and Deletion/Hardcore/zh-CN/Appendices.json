{
    "hands_on_practices": [
        {
            "introduction": "数组删除操作的成本并非一成不变；它取决于被删除元素的位置和数组的当前状态。本练习将挑战你深入思考，为何删除操作的*顺序*会显著影响总体成本。通过分析一个删除特定元素的场景，你将从第一性原理出发，发现从数组末尾向前逐个删除元素可以最大限度地减少元素移动的开销，从而揭示优化此类操作的一个关键策略。",
            "id": "3208390",
            "problem": "考虑一个长度为 $N$ 的连续数组，其索引从 $1$ 到 $N$。你的任务是逐个删除那些原始索引为完全平方数的条目，即索引 $i$ 满足 $i = k^{2}$（对于某个整数 $k \\ge 1$）。在任何时刻，删除当前位于位置 $j$ 的元素需要将所有严格位于位置 $j$ 右侧的元素向左移动一个位置，每次单独的元素移动成本为 $1$ 个单位。操作不是批处理的：每次删除都是一个独立的操作，其成本是在该操作期间移动的元素数量。你可以选择执行删除操作的顺序。\n\n仅从数组删除的核心定义（即移动所有后续元素）以及每次移动成本为 $1$ 个单位这一事实出发，从第一性原理推导出完成所有删除操作的最小可能总成本（以元素移动单位衡量）。用一个关于 $N$ 的单一闭式解析表达式来表示你的最终答案，只使用标准算术运算符和（如果需要）向下取整函数。不需要四舍五入，最终答案必须是一个不带单位的单一表达式。",
            "solution": "用户希望我扮演一位严谨的STEM教授来解决给定的问题。\n\n### 问题验证\n\n**步骤1：提取已知条件**\n- 一个长度为 $N$ 的数组，索引从 $1$ 到 $N$。\n- 任务：删除原始索引为完全平方数的条目，即 $i = k^2$（对于任意整数 $k \\ge 1$）。\n- 删除过程：删除当前位置 $j$ 的元素会导致其右侧的所有元素向左移动一个位置。\n- 成本：一次删除的成本是移动的元素数量，每次移动为 $1$ 个单位。\n- 删除是顺序执行的，非批处理。\n- 删除的顺序是可选的。\n- 目标：从第一性原理推导最小可能总成本。\n- 最终答案：一个关于 $N$ 的单一闭式解析表达式，使用标准算术运算符和向下取整函数。\n\n**步骤2：使用提取的已知条件进行验证**\n- **科学依据：**该问题是一个定义明确的算法分析练习，特别关注数组操作的运算成本。它完全基于数据结构和算法的原理。\n- **良态问题：**该问题提供了所有必要信息。它要求在一个有限的可能删除顺序集合上最小化一个成本函数。保证存在最小成本。\n- **客观性：**该问题以精确的数学和算法术语陈述，没有歧义或主观内容。\n- **其他标准：**该问题是自包含的、一致的且可形式化的。它提出了一个非凡但可解的推理挑战。\n\n**步骤3：结论与行动**\n问题有效。将提供完整解答。\n\n### 解答推导\n\n找到最小成本的过程如下：\n1.  确定要删除的元素集合。\n2.  构建单次删除操作的成本公式。\n3.  将总成本表示为删除顺序的函数。\n4.  确定使总成本最小化的最优删除顺序。\n5.  计算此最优顺序下的总成本，并将其简化为闭式表达式。\n\n设初始数组长度为 $N$。要删除的元素是那些原始索引为完全平方数的元素。这些索引是 $1^2, 2^2, 3^2, \\dots, K^2$，满足 $K^2 \\le N$。满足此条件的最大整数 $K$ 是 $K = \\lfloor\\sqrt{N}\\rfloor$。我们用 $M$ 表示这个值。因此，总共有 $M = \\lfloor\\sqrt{N}\\rfloor$ 个元素要被删除。设这些原始索引的集合（按升序排列）为 $S = \\{s_1, s_2, \\dots, s_M\\}$，其中对于 $k \\in \\{1, 2, \\dots, M\\}$，$s_k = k^2$。\n\n在当前长度为 $L$ 的数组中，删除当前位置为 $j$ 的元素的成本是必须移动的元素数量。这些元素位于位置 $j+1, j+2, \\dots, L$。这样的元素数量为 $L - j$。所以成本是 $L - j$。\n\n总成本取决于这 $M$ 个元素的删除顺序。设 $\\pi$ 为集合 $\\{1, 2, \\dots, M\\}$ 的一个排列，表示删除的顺序。在第 $t$ 步（对于 $t=1, \\dots, M$），我们删除最初位于索引 $s_{\\pi(t)}$ 的元素。\n\n让我们分析第 $t$ 次删除的成本。\n在第 $t$ 步开始时，已经删除了 $t-1$ 个元素。数组的当前长度为 $L_t = N - (t-1)$。\n要删除的元素最初位于索引 $s_{\\pi(t)}$。其当前位置 $P_t$ 是其原始索引减去那些位于比 $s_{\\pi(t)}$ 更小的原始位置且已经被删除的元素数量。在步骤 $1, \\dots, t-1$ 中删除的元素集合来自原始索引 $\\{s_{\\pi(1)}, s_{\\pi(2)}, \\dots, s_{\\pi(t-1)}\\}$。\n在这些已删除元素中，最初位置在 $s_{\\pi(t)}$ 之前的是 $d_t = |\\{j \\in \\{1, \\dots, t-1\\} \\mid s_{\\pi(j)}  s_{\\pi(t)}\\}|$。\n因此，要删除的元素的当前位置是 $P_t = s_{\\pi(t)} - d_t$。\n这第 $t$ 次删除的成本是 $C_t = L_t - P_t = (N - t + 1) - (s_{\\pi(t)} - d_t)$。\n$C_t = N + 1 - t - s_{\\pi(t)} + d_t$。\n\n由排列 $\\pi$ 定义的删除序列的总成本是各次删除成本之和：\n$C_{total}(\\pi) = \\sum_{t=1}^{M} C_t = \\sum_{t=1}^{M} (N + 1 - t - s_{\\pi(t)} + d_t)$。\n我们可以把各项分开：\n$C_{total}(\\pi) = \\sum_{t=1}^{M} (N+1) - \\sum_{t=1}^{M} t - \\sum_{t=1}^{M} s_{\\pi(t)} + \\sum_{t=1}^{M} d_t$。\n\n我们来分析和中的每一项：\n- $\\sum_{t=1}^{M} (N+1) = M(N+1)$。这一项与删除顺序 $\\pi$ 无关。\n- $\\sum_{t=1}^{M} t = \\frac{M(M+1)}{2}$。这一项也与 $\\pi$ 无关。\n- $\\sum_{t=1}^{M} s_{\\pi(t)} = \\sum_{k=1}^{M} s_k = \\sum_{k=1}^{M} k^2 = \\frac{M(M+1)(2M+1)}{6}$。这是对要删除的索引集合求和，与顺序 $\\pi$ 无关。\n- $\\sum_{t=1}^{M} d_t = \\sum_{t=1}^{M} |\\{j \\in \\{1, \\dots, t-1\\} \\mid s_{\\pi(j)}  s_{\\pi(t)}\\}|$。这是唯一依赖于所选排列 $\\pi$ 的项。\n\n为了最小化总成本 $C_{total}(\\pi)$，我们必须最小化项 $\\sum_{t=1}^{M} d_t$。由于 $d_t$ 是元素计数，所以 $d_t \\ge 0$。因此，当每个 $d_t$ 都最小时，该和最小。每个 $d_t$ 的最小可能值为 $0$。\n对于所有 $t \\in \\{1, \\dots, M\\}$，条件 $d_t = 0$ 意味着在每一步 $t$，不存在任何先前删除的元素（来自步骤 $j  t$），其原始索引 $s_{\\pi(j)}$ 小于当前元素的原始索引 $s_{\\pi(t)}$。这可以通过对所有 $j  t$ 都有 $s_{\\pi(j)} > s_{\\pi(t)}$ 来实现。这意味着用于删除的原始索引序列必须是严格递减的：\n$s_{\\pi(1)} > s_{\\pi(2)} > \\dots > s_{\\pi(M)}$。\n由于 $s_k = k^2$ 是关于 $k$ 的严格递增函数，这要求 $\\pi(1) > \\pi(2) > \\dots > \\pi(M)$。满足此条件的唯一排列是逆序排列：$\\pi(t) = M - t + 1$。\n这意味着最优策略是按其原始索引的降序删除元素：先删除 $M^2$，然后是 $(M-1)^2$，依此类推，直到 $1^2$。\n\n现在，我们使用这个最优顺序计算最小成本 $C_{min}$。在此顺序下，对于所有 $t$ 都有 $d_t = 0$。\n$C_{min} = \\sum_{t=1}^{M} (N + 1 - t - s_{\\pi(t)})$。\n使用 $\\pi(t) = M-t+1$，我们得到 $s_{\\pi(t)} = s_{M-t+1} = (M-t+1)^2$。\n$C_{min} = \\sum_{t=1}^{M} [ (N+1) - t - (M-t+1)^2 ]$。\n$C_{min} = \\sum_{t=1}^{M} (N+1) - \\sum_{t=1}^{M} t - \\sum_{t=1}^{M} (M-t+1)^2$。\n- $\\sum_{t=1}^{M} (N+1) = M(N+1)$。\n- $\\sum_{t=1}^{M} t = \\frac{M(M+1)}{2}$。\n- 对于第三项，设 $k = M-t+1$。当 $t$ 从 $1$ 到 $M$ 时，$k$ 从 $M$ 到 $1$。\n  $\\sum_{t=1}^{M} (M-t+1)^2 = \\sum_{k=1}^{M} k^2 = \\frac{M(M+1)(2M+1)}{6}$。\n\n将这些代入 $C_{min}$ 的表达式中：\n$C_{min} = M(N+1) - \\frac{M(M+1)}{2} - \\frac{M(M+1)(2M+1)}{6}$。\n我们可以提出公因子 $\\frac{M}{6}$ 来简化：\n$C_{min} = \\frac{M}{6} [6(N+1) - 3(M+1) - (M+1)(2M+1)]$。\n展开括号内的项：\n$C_{min} = \\frac{M}{6} [ (6N+6) - (3M+3) - (2M^2+3M+1) ]$。\n$C_{min} = \\frac{M}{6} [ 6N+6 - 3M-3 - 2M^2-3M-1 ]$。\n合并同类项：\n$C_{min} = \\frac{M}{6} [ 6N + (6-3-1) - (3M+3M) - 2M^2 ]$。\n$C_{min} = \\frac{M}{6} [ 6N + 2 - 6M - 2M^2 ]$。\n从括号中提出因子 $2$：\n$C_{min} = \\frac{M \\cdot 2}{6} [ 3N + 1 - 3M - M^2 ]$。\n$C_{min} = \\frac{M}{3} (3N + 1 - 3M - M^2)$。\n\n最后，我们代回 $M = \\lfloor\\sqrt{N}\\rfloor$。最小总成本为：\n$C_{min} = \\frac{\\lfloor\\sqrt{N}\\rfloor}{3} (3N + 1 - 3\\lfloor\\sqrt{N}\\rfloor - (\\lfloor\\sqrt{N}\\rfloor)^2)$。\n这就是从第一性原理推导出的所要求的单一闭式解析表达式。",
            "answer": "$$\n\\boxed{\\frac{\\lfloor\\sqrt{N}\\rfloor}{3} (3N + 1 - 3\\lfloor\\sqrt{N}\\rfloor - \\lfloor\\sqrt{N}\\rfloor^2)}\n$$"
        },
        {
            "introduction": "在优化思想的基础上，我们进一步探讨插入操作。当需要插入多个元素时，是逐个插入更优，还是一次性“批量”处理更好？本练习构建了一个算法设计中常见的权衡场景：比较简单的迭代方法与更复杂的批处理策略。通过严谨的渐进成本分析，你将推导出两种策略之间的“盈亏平衡点”，理解在何种条件下一种策略会比另一种更高效。",
            "id": "3208573",
            "problem": "给定一个长度为 $N$ 的、包含不同键的已排序数组，以及 $k$ 个待插入的新键。这些新键是从一个连续分布中独立同分布地抽取的，其在现有 $N$ 个键中的插入排名是独立的，并均匀分布在所有 $N+1$ 个可能的位置上。在一个成本模型下考虑两种策略，其中每次比较的单位成本为 $c_{\\mathrm{cmp}}  0$，移动（写入）内存中单个元素位置的单位成本为 $c_{\\mathrm{mov}}  0$。\n\n策略 A（逐个插入）：依次插入每个新键。对于每次向一个当前长度为 $L$ 的已排序数组中插入的操作，使用二分搜索找到插入索引，并执行必要的右移操作以腾出空间。假设二分搜索使用 $\\lceil \\log_{2} L \\rceil$ 次比较。将移位操作建模为将严格位于插入索引右侧的每个元素向右移动一个位置，每次此类移动的成本为 $c_{\\mathrm{mov}}$。\n\n策略 B（通过排序后合并进行批量插入）：首先，使用一个基于比较的排序算法对 $k$ 个新键进行排序，该算法最多使用 $\\beta k \\log_{2} k$ 次比较（其中 $\\beta \\ge 1$ 是一个常数）。然后，使用经典的二路归并，将两个已排序的序列（长度为 $N$ 的原始数组和长度为 $k$ 的新排序的键）合并到一个长度为 $N+k$ 的新数组中。该归并操作最多执行 $N+k-1$ 次比较和恰好 $N+k$ 次移动。你可以假设除了指定的比较和移动外，没有额外的开销成本。\n\n在 $1 \\ll k \\ll N$ 的渐近区域内进行分析。从算法分析的第一性原理和标准定义出发，在均匀秩假设下，推导出两种策略的主阶期望总成本，找出使得策略 B 的期望成本不大于策略 A 的最小 $k$ 值，并用 $c_{\\mathrm{cmp}}$ 和 $c_{\\mathrm{mov}}$ 表示该阈值 $k$ 的主阶渐近表达式。你的最终答案必须是该主阶阈值 $k$ 的一个封闭形式的解析表达式；不要提供不等式。不需要进行舍入。",
            "solution": "问题要求在 $1 \\ll k \\ll N$ 的渐近区域下，比较向一个大小为 $N$ 的已排序数组中插入 $k$ 个新键的两种策略。我们需要找到使策略 B 比策略 A 更具成本效益的阈值 $k$。成本是比较（每次比较成本为 $c_{\\mathrm{cmp}}$）和内存移动（每次移动成本为 $c_{\\mathrm{mov}}$）的函数。\n\n首先，我们推导策略 A 的主阶期望总成本。\n\n**策略 A：逐个插入**\n\n策略 A 包括依次插入 $k$ 个键中的每一个。让我们分析插入第 $i$ 个键的成本，其中 $i \\in \\{1, 2, \\dots, k\\}$。在第 $i$ 次插入时，数组的长度为 $L = N+i-1$。\n\n这次插入的成本是比较成本和移动成本之和。\n1.  **比较成本：** 问题陈述了使用二分搜索来找到插入点，这需要 $\\lceil \\log_{2} L \\rceil$ 次比较。成本为 $c_{\\mathrm{cmp}} \\lceil \\log_{2} (N+i-1) \\rceil$。\n\n2.  **移动成本：** 新键的插入排名均匀分布在 $L+1$ 个可能的位置上。设插入索引为 $j$，其中 $j \\in \\{0, 1, \\dots, L\\}$。在索引 $j$ 处插入需要将从索引 $j$ 到 $L-1$ 的所有元素向右移动一个位置。这构成了 $L-j$ 次移动。由于每个索引 $j$ 的概率都相等，为 $P(j) = \\frac{1}{L+1}$，所以期望的移动次数为：\n    $$E[\\text{moves}] = \\sum_{j=0}^{L} (L-j) P(j) = \\frac{1}{L+1} \\sum_{j=0}^{L} (L-j)$$\n    令 $m = L-j$。当 $j$ 从 $0$ 变为 $L$ 时，$m$ 从 $L$ 变为 $0$。\n    $$E[\\text{moves}] = \\frac{1}{L+1} \\sum_{m=0}^{L} m = \\frac{1}{L+1} \\frac{L(L+1)}{2} = \\frac{L}{2}$$\n    第 $i$ 次插入的期望移动成本为 $c_{\\mathrm{mov}} \\frac{L}{2} = c_{\\mathrm{mov}} \\frac{N+i-1}{2}$。\n\n策略 A 的总期望成本 $E[C_A]$ 是每次插入的期望成本之和，共 $k$ 次插入：\n$$E[C_A] = \\sum_{i=1}^{k} \\left( c_{\\mathrm{cmp}} \\lceil \\log_{2} (N+i-1) \\rceil + c_{\\mathrm{mov}} \\frac{N+i-1}{2} \\right)$$\n\n对于 $1 \\ll k \\ll N$ 的渐近分析，我们可以对各项进行近似。\n对于比较成本，有 $N \\le N+i-1  N+k$。因为 $k \\ll N$，所以 $\\log_{2}(N+i-1) = \\log_{2} N + \\log_{2}(1+\\frac{i-1}{N}) \\approx \\log_2 N$。因此，$\\lceil \\log_{2} (N+i-1) \\rceil \\approx \\log_2 N$。总比较成本约为 $k c_{\\mathrm{cmp}} \\log_{2} N$。\n总移动成本为：\n$$c_{\\mathrm{mov}} \\sum_{i=1}^{k} \\frac{N+i-1}{2} = \\frac{c_{\\mathrm{mov}}}{2} \\left( \\sum_{i=1}^{k} N + \\sum_{i=1}^{k} (i-1) \\right) = \\frac{c_{\\mathrm{mov}}}{2} \\left( kN + \\frac{k(k-1)}{2} \\right) = \\frac{c_{\\mathrm{mov}} k N}{2} + \\frac{c_{\\mathrm{mov}} k(k-1)}{4}$$\n所以，总期望成本为：\n$$E[C_A] \\approx k c_{\\mathrm{cmp}} \\log_{2} N + \\frac{c_{\\mathrm{mov}} k N}{2} + \\frac{c_{\\mathrm{mov}} (k^2 - k)}{4}$$\n在 $1 \\ll k \\ll N$ 的区域内，与 $N$ 成正比的项是主导项。$k^2$ 项远小于 $kN$，$k \\log_2 N$ 项也远小于 $kN$。因此，策略 A 的主阶期望成本为：\n$$E[C_A] \\approx \\frac{c_{\\mathrm{mov}} k N}{2}$$\n\n**策略 B：通过排序后合并进行批量插入**\n\n策略 B 包括两个步骤：对 $k$ 个新键进行排序，然后将它们与包含 $N$ 个键的原始数组进行合并。\n1.  **排序成本：** $k$ 个新键通过一个最多需要 $\\beta k \\log_{2} k$ 次比较的算法进行排序。问题陈述没有指定此步骤的移动成本；我们假设它相对于涉及 $N$ 个元素的合并步骤而言，被归入低阶项。比较成本最多为 $c_{\\mathrm{cmp}} \\beta k \\log_{2} k$。\n2.  **合并成本：** 将已排序的 $k$ 个键的列表与已排序的 $N$ 个键的数组合并到一个大小为 $N+k$ 的新数组中。此操作最多需要 $N+k-1$ 次比较和恰好 $N+k$ 次移动。成本为 $c_{\\mathrm{cmp}} (N+k-1) + c_{\\mathrm{mov}} (N+k)$。\n\n策略 B 的总成本 $C_B$ 的上界为：\n$$C_B \\le c_{\\mathrm{cmp}} (\\beta k \\log_{2} k) + c_{\\mathrm{cmp}} (N+k-1) + c_{\\mathrm{mov}} (N+k)$$\n$$C_B \\le (c_{\\mathrm{cmp}} + c_{\\mathrm{mov}})N + (c_{\\mathrm{cmp}} (\\beta \\log_{2} k + 1) + c_{\\mathrm{mov}})k - c_{\\mathrm{cmp}}$$\n对于 $1 \\ll k \\ll N$ 的渐近分析，与 $N$ 成正比的项是主导项。与 $k \\log_2 k$ 和 $k$ 成正比的项是低阶项。因此，策略 B 的主阶成本为：\n$$C_B \\approx (c_{\\mathrm{cmp}} + c_{\\mathrm{mov}}) N$$\n\n**阈值确定**\n\n我们寻找最小的 $k$，使得策略 B 的期望成本不大于策略 A 的期望成本。这对应于不等式 $C_B \\le E[C_A]$。为了找到阈值 $k$ 的主阶渐近表达式，我们比较两种策略的主阶成本：\n$$(c_{\\mathrm{cmp}} + c_{\\mathrm{mov}}) N \\le \\frac{c_{\\mathrm{mov}} k N}{2}$$\n由于 $N$ 是一个大的正长度，我们可以将两边同时除以 $N$：\n$$c_{\\mathrm{cmp}} + c_{\\mathrm{mov}} \\le \\frac{c_{\\mathrm{mov}} k}{2}$$\n现在，我们求解 $k$：\n$$k \\ge \\frac{2(c_{\\mathrm{cmp}} + c_{\\mathrm{mov}})}{c_{\\mathrm{mov}}}$$\n$$k \\ge 2\\left(\\frac{c_{\\mathrm{cmp}}}{c_{\\mathrm{mov}}} + 1\\right)$$\n使策略 B 更优的最小 $k$ 值由这个阈值给出。问题要求给出这个主阶阈值的单一封闭形式解析表达式。这是主阶成本相等时的值。\n$$k_{\\text{threshold}} = 2\\left(\\frac{c_{\\mathrm{cmp}}}{c_{\\mathrm{mov}}} + 1\\right)$$\n这个结果与 $N$ 无关，并且与渐近区域 $1 \\ll k \\ll N$ 一致，因为阈值 $k$ 是一个常数，对于大的 $N$ 满足 $k \\ll N$。条件 $k \\gg 1$ 取决于比率 $c_{\\mathrm{cmp}}/c_{\\mathrm{mov}}$。对于典型的处理器架构，其中内存访问（$c_{\\mathrm{mov}}$）比寄存器/缓存比较（$c_{\\mathrm{cmp}}$）更昂贵，该比率很小，但阈值仍然可以大于1。",
            "answer": "$$\\boxed{2\\left(\\frac{c_{\\mathrm{cmp}}}{c_{\\mathrm{mov}}} + 1\\right)}$$"
        },
        {
            "introduction": "作为总结，我们将学习一种功能强大且通用的技术。前面的练习分析了批量操作的*成本*，而本练习则提供了一个高效执行批量删除的*构造性算法*。你将学习如何巧妙地运用前缀和（scan）操作，在单次遍历中计算出所有幸存元素的新位置，从而为这个看似复杂的问题提供一个优雅的线性时间解决方案。",
            "id": "3208395",
            "problem": "给定一个长度为 $n$ 的抽象数组 $A$，其索引范围为 $0$ 到 $n-1$。一次批量删除操作会移除数组 $A$ 中位于指定索引集合 $D \\subseteq \\{0,1,\\ldots,n-1\\}$ 的元素（在 $D$ 的指定中，重复的索引没有额外效果）。删除这些元素后，$A$ 中剩余的元素会保持其原始相对顺序向左紧凑排列，形成一个新数组 $A'$。对于任意原始索引 $i \\in \\{0,1,\\ldots,n-1\\}$，定义一个索引映射函数，该函数返回 $A[i]$ 在 $A'$ 中的位置（如果 $A[i]$ 被保留），或者在 $A[i]$ 被删除时返回一个哨兵值。\n\n基本原理。仅使用以下核心定义来推导映射关系和算法：\n- 数组索引和顺序：数组是一个有序序列；删除操作会保留幸存元素的相对顺序。\n- 指示函数：对于每个 $j \\in \\{0,1,\\ldots,n-1\\}$，定义 $x[j] = 1$ 如果 $j \\in D$，否则 $x[j] = 0$。\n- 前缀和：对于一个序列 $x[0],x[1],\\ldots,x[n-1]$，定义前缀和数组 $S$ 为 $S[i] = \\sum_{j=0}^{i} x[j]$，对于每个 $i \\in \\{0,1,\\ldots,n-1\\}$。\n\n任务。从上述基本原理出发，不使用任何其他专门的公式，完成以下任务。\n1. 推导一个数学上精确的函数，该函数将每个原始索引 $i$ 映射到删除和数组紧凑化操作后的新位置，或指示该索引已被删除。你必须用指示函数及其前缀和来表示这个映射关系。\n2. 设计一个算法，为给定的数组长度 $n$、大小为 $k = |D|$ 的删除集合 $D$ 以及包含 $q$ 个查询索引的列表 $Q = [q_0,q_1,\\ldots,q_{q-1}]$ 构建此映射。你的算法运行时间必须为 $O(n + k + q)$，并使用 $O(n)$ 的额外空间。使用整数 $-1$ 作为哨兵值来指示原始索引已被删除。你必须从第一性原理出发证明其时间复杂度。\n3. 将你的算法实现为一个完整的程序，为下面提供的每个测试用例计算映射。\n\n每个测试用例的输入约束：\n- 数组长度 $n$ 是一个正整数。\n- 删除列表 $D$ 包含 $\\{0,1,\\ldots,n-1\\}$ 中的索引，并可能包含重复项；只有集合成员关系重要。\n- 查询列表 $Q$ 包含 $\\{0,1,\\ldots,n-1\\}$ 中的索引。\n\n测试套件。你的程序必须在以下五个案例中，为每个测试用例的查询列表 $Q$ 计算映射后的索引，对已删除的位置使用 $-1$：\n- 案例1：$n = 10$, $D = [2,5,6]$, $Q = [0,1,2,3,6,7,9]$。\n- 案例2：$n = 5$, $D = [0]$, $Q = [0,1]$。\n- 案例3：$n = 5$, $D = [0,1,2,3,4]$, $Q = [0,2,4]$。\n- 案例4：$n = 5$, $D = [3,3,1]$, $Q = [1,2,3,4]$。\n- 案例5：$n = 1$, $D = []$, $Q = [0]$。\n\n最终输出格式。你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的第 $i$ 个元素对应第 $i$ 个测试用例，它本身也是该测试用例中 $Q$ 的映射索引的逗号分隔列表。例如，如果有两个测试用例的结果分别为 $[a_0,a_1]$ 和 $[b_0,b_1,b_2]$，则输出应为单行的 $[[a_0,a_1],[b_0,b_1,b_2]]$。",
            "solution": "该问题要求推导一个用于数组删除的索引映射函数，基于此函数设计一个高效的算法，并加以实现。推导过程必须基于指定的第一性原理。\n\n**第1部分：索引映射函数的推导**\n\n设 $A$ 是长度为 $n$ 的原始数组，索引范围为 $\\{0, 1, \\ldots, n-1\\}$。设 $D$ 是要删除的索引集合。问题定义了一个长度为 $n$ 的指示序列 $x$，其中如果索引 $j$ 在删除集合 $D$ 中，则 $x[j] = 1$，否则 $x[j] = 0$。我们的任务是找到一个函数 $\\text{map}(i)$，它能给出原始索引为 $i$ 的元素的新索引，或者在该元素被删除时返回一个哨兵值。指定的哨兵值为 $-1$。\n\n首先，考虑一个位于将被删除的原始索引 $i$ 处的元素。这种情况当且仅当 $i \\in D$ 时发生，这等价于条件 $x[i] = 1$。对于任何此类索引，映射函数必须返回哨兵值。\n$$ \\text{if } x[i] = 1, \\text{then } \\text{map}(i) = -1 $$\n\n接下来，考虑一个在删除操作中幸存的、位于原始索引 $i$ 处的元素。这种情况当且仅当 $i \\notin D$ 时发生，这等价于 $x[i] = 0$。删除后，剩余元素被紧凑排列，并保持其相对顺序。幸存元素 $A[i]$ 的新索引由在原始数组中排在它之前的其他幸存元素的数量决定。排在 $A[i]$ 之前的元素是那些位于索引 $\\{0, 1, \\ldots, i-1\\}$ 的元素。这类元素的总数为 $i$。\n\n要计算排在 $A[i]$ 前的幸存元素数量，我们可以计算排在 $A[i]$ 前的*已删除*元素的数量，然后从前面的元素总数 $i$ 中减去这个数量。索引小于 $i$ 的已删除元素的数量由这些索引的指示函数值之和给出：\n$$ \\text{Number of deleted elements before } i = \\sum_{j=0}^{i-1} x[j] $$\n问题将前缀和序列 $S$ 定义为 $S[k] = \\sum_{j=0}^{k} x[j]$，其中 $k \\in \\{0, 1, \\ldots, n-1\\}$。根据这个定义，索引 $i$ 之前的已删除元素数量为 $S[i-1]$（对于 $i=0$ 的情况，我们可以定义 $S[-1] = 0$）。\n\n$A[i]$ 的新的从0开始的索引是它前面幸存元素的数量。这个数量是：\n$$ \\text{New index} = (\\text{total elements before } i) - (\\text{deleted elements before } i) = i - \\sum_{j=0}^{i-1} x[j] $$\n对于 $i0$，这个数量是 $i - S[i-1]$。对于 $i=0$，求和为空，等于 $0$，所以新索引是 $0-0=0$。因此，如果 $x[i]=0$，则 $\\text{map}(i) = i - S[i-1]$ (其中 $S[-1]=0$)。\n\n我们可以推导出一种等价且更简洁的表述。直到并包括索引 $i$ 在内的幸存元素数量，等于元素总数 $(i+1)$ 减去直到并包括索引 $i$ 在内的已删除元素数量，即 $S[i]$。因此，在 $\\{0, 1, \\ldots, i\\}$ 中的幸存者数量是 $(i+1) - S[i]$。如果索引 $i$ 处的元素幸存（即 $x[i]=0$），其新的从0开始的索引将是这个计数减一。\n$$ \\text{if } x[i] = 0, \\text{then } \\text{map}(i) = ((i+1) - S[i]) - 1 = i - S[i] $$\n这个公式对所有 $i \\in \\{0, \\ldots, n-1\\}$ 都成立，无需为 $S[-1]$ 设置特殊情况。它也与之前的公式等价，因为如果 $x[i]=0$，那么 $S[i] = S[i-1] + x[i] = S[i-1]$。\n\n结合删除和幸存两种情况，完整的索引映射函数是：\n$$ \\text{map}(i) = \\begin{cases} i - S[i]  \\text{if } x[i] = 0 \\\\ -1  \\text{if } x[i] = 1 \\end{cases} $$\n其中 $S[i] = \\sum_{j=0}^{i} x[j]$。此函数完全按照要求，仅用原始索引 $i$、指示序列 $x$ 及其前缀和 $S$ 来表示。\n\n**第2部分：算法设计与复杂度分析**\n\n基于推导出的映射函数，我们可以设计一个算法来为给定的数组长度 $n$、大小为 $k$ 的删除列表 $D$ 和大小为 $q$ 的查询列表 $Q$ 计算映射。该算法的运行时间必须在 $O(n + k + q)$ 内，并使用 $O(n)$ 的额外空间。\n\n该算法分三个主要阶段进行：\n1.  **构建指示数组和前缀和数组：** 首先，我们预先计算映射所需的信息：指示数组 $x$ 和前缀和数组 $S$。\n    a.  初始化一个大小为 $n$ 的整数数组 `x_arr`，所有元素设置为 $0$。这需要 $O(n)$ 的时间。\n    b.  遍历长度为 $k$ 的输入删除列表 $D$。对于每个索引 $d \\in D$，设置 `x_arr[d] = 1`。此步骤需要 $O(k)$ 的时间。\n    c.  计算 `x_arr` 的前缀和数组 `S_arr`。这可以通过初始化 `S_arr[0] = x_arr[0]`，然后从 $i=1$ 到 $n-1$ 迭代，计算 `S_arr[i] = S_arr[i-1] + x_arr[i]` 来完成。此阶段需要 $O(n)$ 的时间。\n\n2.  **计算完整索引映射（可选但清晰）：** 为了高效地回答查询，我们可以预先计算从原始索引到新索引的完整映射。\n    a.  创建一个大小为 $n$ 的映射数组 `map_arr`。\n    b.  从 $i=0$ 迭代到 $n-1$。对于每个索引 $i$：\n        i. 如果 `x_arr[i] == 1`，则设置 `map_arr[i] = -1`。\n        ii. 如果 `x_arr[i] == 0`，则设置 `map_arr[i] = i - S_arr[i]`。\n    此步骤需要 $O(n)$ 的时间。\n\n3.  **处理查询：** 遍历长度为 $q$ 的查询列表 $Q$。对于每个查询索引 $q_j \\in Q$，结果就是 `map_arr[q_j]`。每次查询都是一次 $O(1)$ 的查找。此阶段总共需要 $O(q)$ 的时间。\n\n**复杂度分析：**\n*   **时间复杂度：** 总时间是每个步骤的时间之和：$O(n)$ (用于 `x_arr` 初始化) + $O(k)$ (用于填充 `x_arr`) + $O(n)$ (用于 `S_arr` 计算) + $O(n)$ (用于 `map_arr` 计算) + $O(q)$ (用于查询)。总计为 $O(n + k + q)$，符合问题要求。\n*   **空间复杂度：** 该算法使用了三个大小为 $n$ 的数组：`x_arr`、`S_arr` 和 `map_arr`。总的额外空间是 $O(n) + O(n) + O(n) = O(n)$，也符合要求。\n\n该算法正确实现了推导出的映射函数，并满足给定的性能约束。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the index mapping problem for a suite of test cases.\n    The core logic is implemented in the compute_mapping_for_case function.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: n = 10, D = [2, 5, 6], Q = [0, 1, 2, 3, 6, 7, 9]\n        (10, [2, 5, 6], [0, 1, 2, 3, 6, 7, 9]),\n        # Case 2: n = 5, D = [0], Q = [0, 1]\n        (5, [0], [0, 1]),\n        # Case 3: n = 5, D = [0, 1, 2, 3, 4], Q = [0, 2, 4]\n        (5, [0, 1, 2, 3, 4], [0, 2, 4]),\n        # Case 4: n = 5, D = [3, 3, 1], Q = [1, 2, 3, 4]\n        (5, [3, 3, 1], [1, 2, 3, 4]),\n        # Case 5: n = 1, D = [], Q = [0]\n        (1, [], [0]),\n    ]\n\n    def compute_mapping_for_case(n, D, Q):\n        \"\"\"\n        Computes the new indices for a single test case based on the derived formula.\n        \n        Args:\n            n (int): The length of the abstract array.\n            D (list[int]): A list of original indices to delete.\n            Q (list[int]): A list of original indices to query.\n\n        Returns:\n            list[int]: A list of mapped indices, with -1 for deleted elements.\n        \"\"\"\n        \n        # Step 1: Create the indicator array `x`.\n        # `x[i] = 1` if index `i` is deleted, `0` otherwise.\n        # This takes O(n + |D|) time.\n        x = np.zeros(n, dtype=np.int32)\n        for del_idx in D:\n            if 0 = del_idx  n:\n                x[del_idx] = 1\n\n        # Step 2: Compute the prefix sum array `S`.\n        # `S[i]` stores the number of deleted elements in the range `[0, i]`.\n        # np.cumsum is an efficient O(n) operation.\n        S = np.cumsum(x, dtype=np.int32)\n\n        # Step 3: Respond to queries.\n        # For each query index q, apply the mapping function:\n        # map(q) = -1 if x[q] == 1\n        # map(q) = q - S[q] if x[q] == 0\n        # This takes O(|Q|) time.\n        results = []\n        for q_idx in Q:\n            if x[q_idx] == 1:\n                results.append(-1)\n            else:\n                # The new index is the original index minus the number of\n                # deleted items up to that point.\n                new_idx = q_idx - S[q_idx]\n                results.append(new_idx)\n        \n        return results\n\n    all_results = []\n    for case in test_cases:\n        n, D, Q = case\n        result = compute_mapping_for_case(n, D, Q)\n        all_results.append(result)\n\n    # Format the final output string to match the problem specification exactly.\n    # Produces a string like \"[[r1_1,r1_2],[r2_1,r2_2],...]\"\n    inner_strings = [f\"[{','.join(map(str, res))}]\" for res in all_results]\n    final_output = f\"[{','.join(inner_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```"
        }
    ]
}