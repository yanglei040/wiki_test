{
    "hands_on_practices": [
        {
            "introduction": "在我们开始编码之前，让我们先建立一些理论直觉。动态数组的一个关键特性是其几何级数的增长方式。这个练习  将挑战你计算在加倍扩容策略下，单个元素可能被复制的最大次数。通过这个分析，你将揭示为何看起来昂贵的重置大小（resize）操作，在整体上却能为追加（append）操作带来高效的均摊性能。",
            "id": "3206830",
            "problem": "考虑一个初始容量为$1$且为空的动态数组。该数组支持追加操作，当有可用容量时，该操作以常数时间在末尾放置一个新元素。当追加操作发现数组已满时，数组会执行一次扩容：它会分配一个新的连续内存块，其容量恰好是当前容量的两倍，然后将所有当前元素按顺序从旧块复制到新块中，之后再追加新元素。假设没有删除操作。我们将元素的“复制”定义为在扩容期间该元素的移动（元素在追加时的初始放置不计为一次复制）。\n\n在执行了恰好$N \\ge 1$次追加操作后，请确定，在这$N$次追加操作序列中，任何单个元素因扩容而被复制的最大可能次数，并以$N$的闭式表达式表示。请提供精确表达式，无需数值近似或舍入。",
            "solution": "用户希望我解决一个关于动态数组的问题。\n\n### 步骤 1：提取已知条件\n- 初始数组容量：$1$。\n- 初始数组大小：$0$。\n- 追加操作：在末尾放置一个新元素。\n- 扩容条件：当试图向一个已满的数组追加元素时发生。\n- 扩容机制：\n    1. 新分配的容量是当前容量的$2 \\times$倍。\n    2. 所有现有元素被复制到新块中。\n    3. 然后追加新元素。\n- “复制”的定义：元素在扩容期间的移动。元素的初始插入不算是复制。\n- 总操作数：执行了恰好$N$次追加操作，其中$N \\ge 1$。\n- 目标：确定任何单个元素被复制的最大可能次数。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据**：该问题是算法分析中的一个标准练习，具体涉及动态数组（也称为向量或ArrayList）的摊还分析。所描述的模型（扩容时容量加倍）是一种经典的实现策略。该问题在科学上和数学上都是合理的。\n- **适定性**：该问题是适定的。初始条件、操作规则以及待求量都得到了精确的规定。存在一个唯一的、确定性的解。\n- **客观性**：问题陈述是客观的，并使用了正式、无歧义的语言。\n\n### 步骤 3：结论与行动\n该问题是**有效的**。它是计算机科学领域中一个关于数据结构和算法的明确定义的问题。我现在将进行正式求解。\n\n### 解题推导\n问题要求在$N$次追加操作序列之后，任何单个元素被复制的最大次数。为了最大化一个元素的复制次数，我们应该考虑在数组中存在时间最长的元素，因为它将经历其插入后发生的每一次扩容操作。第一个被追加的元素，我们称之为$E_1$，满足这个条件。因此，任何元素的最大复制次数就是$E_1$被复制的次数。\n\n我们来分析动态数组的状态，特别是它的容量。容量（我们用$C$表示）仅在扩容操作期间发生变化。根据问题陈述，初始容量为$C_0 = 1$。扩容操作将容量加倍。因此，数组可能具有的容量序列是$2$的幂：$1, 2, 4, 8, \\dots, 2^k$，其中$k$为非负整数。容量为$C=2^k$的数组最多可以容纳$2^k$个元素。\n\n当试图向一个已满的数组追加元素时，会触发扩容。也就是说，如果数组的容量为$C$并且已经包含$C$个元素，那么下一次追加操作将导致扩容。\n\n我们来追踪一下这个过程：\n1.  **初始状态**：容量$C=1$，大小$S=0$。\n2.  **第 1 次追加**：我们追加元素$E_1$。数组有空间，因此不发生扩容。状态变为$C=1$, $S=1$。$E_1$的复制次数为$0$。\n3.  **第 2 次追加**：我们尝试追加$E_2$。数组已满（$S=C=1$）。触发扩容。\n    - 分配一个容量为$2 \\times 1 = 2$的新数组。\n    - 元素$E_1$从旧数组复制到新数组。这是$E_1$的**第一次复制**。\n    - 追加元素$E_2$。\n    - 状态变为$C=2$, $S=2$。\n4.  **第 3 次追加**：我们尝试追加$E_3$。数组已满（$S=C=2$）。触发扩容。\n    - 分配一个容量为$2 \\times 2 = 4$的新数组。\n    - 元素$E_1$和$E_2$被复制。这是$E_1$的**第二次复制**。\n    - 追加元素$E_3$。\n    - 状态变为$C=4$, $S=3$。\n5.  **第 4 次追加**：我们追加$E_4$。数组未满（$S=3, C=4$）。不扩容。状态变为$C=4, S=4$。$E_1$仍然被复制了两次。\n6.  **第 5 次追加**：我们尝试追加$E_5$。数组已满（$S=C=4$）。触发扩容至容量$2 \\times 4 = 8$。这涉及$E_1$的**第三次复制**。\n\n从这个分析中可以清楚地看到，$E_1$在其初始放置后发生的每一次扩容事件中都会被复制。因此，$E_1$被复制的次数等于在$N$次追加操作期间发生扩容的总次数。\n\n从容量$2^k$到$2^{k+1}$的扩容是由第$(2^k+1)$次追加操作触发的。元素$E_1$存在于所有从初始容量$2^0$开始增加容量的扩容过程中。\n\n经过$N$次追加后，数组必须容纳$N$个元素。数组的容量$C_N$必须至少为$N$。由于容量是2的幂，所以$C_N$必须是大于或等于$N$的最小的2的幂。设这个容量为$C_N = 2^k$。\n条件$C_N = 2^k \\ge N$且$k$是满足该条件的最小整数，这意味着之前的容量$2^{k-1}$是不够的，即$2^{k-1}  N$。\n因此，我们有不等式：\n$$2^{k-1}  N \\le 2^k$$\n这个不等式对$N > 1$成立。如果$N=1$，容量为$1=2^0$，所以$k=0$。\n对于$N > 1$，我们可以对不等式两边取以2为底的对数：\n$$\\log_2(2^{k-1})  \\log_2(N) \\le \\log_2(2^k)$$\n$$k-1  \\log_2(N) \\le k$$\n这个关系是向上取整函数（ceiling function）的定义。因此，对于$N > 1$，最终容量的指数$k$由下式给出：\n$$k = \\lceil \\log_2(N) \\rceil$$\n我们来验证$N=1$的情况。最终容量是$1 = 2^0$，所以$k=0$。该公式给出$\\lceil \\log_2(1) \\rceil = \\lceil 0 \\rceil = 0$。所以该公式对所有$N \\ge 1$都成立。\n\n数组为了达到$2^k$的容量所必须经历的容量序列是$2^0, 2^1, 2^2, \\ldots, 2^k$。\n这个序列中从$2^j$到$2^{j+1}$（其中$j=0, 1, \\ldots, k-1$）的每一步都对应一次扩容操作。\n第一个元素$E_1$从容量为$C=2^0$时就存在于数组中。它将在随后的每一次扩容中被复制。这些扩容是：\n- 从$2^0 \\to 2^1$\n- 从$2^1 \\to 2^2$\n- ...\n- 从$2^{k-1} \\to 2^k$\n\n这些扩容事件的总数是$(k-1) - 0 + 1 = k$。\n因此，任何单个元素被复制的最大次数是$k$。代入$k$的表达式：\n$$\\text{最大复制次数} = \\lceil \\log_2(N) \\rceil$$\n这个表达式是关于$N$的闭式表达式，并且对所有$N \\ge 1$都有效。",
            "answer": "$$\\boxed{\\lceil \\log_2(N) \\rceil}$$"
        },
        {
            "introduction": "虽然动态数组在末尾添加元素方面表现出色，但从开头移除元素却效率低下。这个练习  首先会让你实现一个朴素但缓慢的 `pop_front` 操作来亲身体会这一点。然后，你将通过在动态数组之上实现一个环形缓冲区（circular buffer）来设计一个更优的解决方案，从而实现对队首和队尾操作的均摊常数时间复杂度，这是系统编程中的一项关键技术。",
            "id": "3230221",
            "problem": "你的任务是根据第一性原理，对动态数组和摊还分析进行推理，并通过实现两种具体的基于数组的结构来验证你的推理。仅使用以下基本原则：随机存取存储器（RAM）中的数组索引是常数时间操作；复制或赋值单个元素的成本为单位成本；复制 $k$ 个元素的成本与 $k$ 成正比；除了显式赋值外，创建新数组和复制现有元素是数据移动的唯一来源；当通过加倍方式增长时，动态数组的容量始终是 $2$ 的幂。\n\n你的任务是：\n\n- 实现一个标准的动态数组，在数组满时通过加倍容量的方式来支持摊还常数时间的 $push\\_back$ 操作。通过将所有剩余元素向左移动一个位置来实现 $pop\\_front$。纯粹通过计算在 $pop\\_front$ 操作内部执行的元素赋值次数来分析 $pop\\_front$ 的时间成本。在回答有关 $pop\\_front$ 的问题时，忽略由 $push\\_back$ 引起的任何重分配成本。\n\n- 设计并实现一个基于数组的队列，使其 $push\\_back$ 和 $pop\\_front$ 操作都能达到摊还 $\\mathcal{O}(1)$ 的时间复杂度。在一个动态数组上使用循环缓冲区（环形缓冲区），当溢出时容量加倍，当某次操作后，元素数量最多为容量的四分之一时容量减半。在调整大小（无论是增长还是缩减）时，将所有元素按逻辑顺序复制到一个从索引 $0$ 开始的新数组中。每次操作最多执行一次大小调整。计算在调整大小期间（且仅在调整大小期间）完成的元素复制次数，以量化成本。\n\n根据上述基本原则和你的实现，推导出为什么朴素的 $pop\\_front$ 操作的成本与当前大小呈线性关系，以及为什么在指定的加倍/减半策略下，环形缓冲区能够为 $push\\_back$ 和 $pop\\_front$ 操作都实现摊还常数时间。\n\n测试套件和要求的输出：\n\n实现你的程序以执行以下四个测试用例，使用精确的操作序列。对于朴素动态数组，仅计算因移位而在 $pop\\_front$ 内部执行的元素赋值次数。对于环形缓冲区，仅计算在调整大小期间执行的元素复制次数。对于在空结构上执行的任何 $pop\\_front$ 操作，不执行任何操作并在内部返回一个特殊值（如 null）；此类空操作不应影响计数器。\n\n- 测试用例 1（朴素动态数组的移动成本）：\n  - 从空数组开始。\n  - 按递增顺序执行 $push\\_back$ 操作，插入整数 $1$ 到 $10$。\n  - 执行 $pop\\_front$ 操作正好 $3$ 次。\n  - 按递增顺序执行 $push\\_back$ 操作，插入整数 $11$ 到 $15$。\n  - 执行 $pop\\_front$ 操作正好 $4$ 次。\n  - 按递增顺序执行 $push\\_back$ 操作，插入整数 $16$ 到 $20$。\n  - 此用例的输出：一个整数，等于所有 $pop\\_front$ 操作执行的元素赋值总数（忽略由 $push\\_back$ 引起的任何重分配）。\n\n- 测试用例 2（混合操作下环形缓冲区调整大小的复制计数）：\n  - 从空数组开始。\n  - 执行 $push\\_back$ 操作，插入 $1$ 到 $10$。\n  - 执行 $pop\\_front$ 操作 $3$ 次。\n  - 执行 $push\\_back$ 操作，插入 $11$ 到 $15$。\n  - 执行 $pop\\_front$ 操作 $4$ 次。\n  - 执行 $push\\_back$ 操作，插入 $16$ 到 $20$。\n  - 此用例的输出：一个整数，等于在所有大小调整（包括增长和缩减）期间执行的元素复制总数。\n\n- 测试用例 3（环形缓冲区的正确性和环绕行为）：\n  - 从空数组开始。\n  - 执行 $push\\_back$ 操作，插入 $1$ 到 $6$。\n  - 执行 $pop\\_front$ 操作 $4$ 次。\n  - 执行 $push\\_back$ 操作，插入 $7$、$8$、$9$、$10$。\n  - 执行 $pop\\_front$ 操作 $2$ 次。\n  - 此用例的输出：环形缓冲区的最终内容，表示为从头到尾按逻辑顺序排列的整数列表。\n\n- 测试用例 4（环形缓冲区增长和缩减的复制计数）：\n  - 从空数组开始。\n  - 执行 $push\\_back$ 操作，插入 $1$ 到 $16$。\n  - 执行 $pop\\_front$ 操作 $12$ 次。\n  - 执行 $push\\_back$ 操作，插入 $17$ 到 $24$。\n  - 执行 $pop\\_front$ 操作 $8$ 次。\n  - 此用例的输出：一个整数，等于在所有大小调整（包括增长和缩减）期间执行的元素复制总数。\n\n最终输出格式：\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按顺序包含四个测试用例的结果：$[$result\\_1,result\\_2,result\\_3,result\\_4$]$。第一个、第二个和第四个结果是整数。第三个结果是一个整数列表。例如，一个语法上有效的输出看起来像 $[42,7,[3,5,8],19]$，其中具体的数字必须与上述测试套件的正确结果相匹配。",
            "solution": "该问题要求对两种基于数组的数据结构进行分析和实现，以比较它们在类队列操作（特别是 `push_back` 和 `pop_front`）上的性能。分析必须从第一性原理出发，基于一个指定的成本模型，其中元素赋值和复制是工作量的主要度量标准。\n\n**基本原理和成本模型**\n\n分析基于以下公理：\n1.  随机存取存储器（RAM）允许以常数时间 $\\mathcal{O}(1)$ 访问数组中任意索引的元素。\n2.  单个元素赋值或复制的成本是单位成本，我们可以表示为 $\\mathcal{O}(1)$。\n3.  复制一个包含 $k$ 个连续元素的块的成本是 $\\mathcal{O}(k)$。\n4.  数据移动仅限于显式赋值或数组调整大小期间的块复制。\n5.  当动态数组增长时，其容量始终是 $2$ 的幂，通过将当前容量加倍来实现。\n\n**第 1 部分：使用移位 `pop_front` 的朴素动态数组**\n\n标准的动态数组通过在末尾追加一个元素来支持 `push_back`。如果底层数组已满，则会分配一个更大的新数组（在本例中，容量是原先的两倍），将所有现有元素复制到新数组中，然后丢弃旧数组。这种加倍策略确保了 `push_back` 的摊还成本为 $\\mathcal{O}(1)$。\n\n问题指定了一个朴素的 `pop_front` 实现。此操作必须移除索引为 $0$ 的元素。为了保持数组的连续性，并使其第一个逻辑元素位于索引 $0$，所有后续元素都必须向左移动一个位置。\n\n**朴素 `pop_front` 的成本分析**\n假设动态数组包含 $N$ 个元素，索引从 $0$ 到 $N-1$。\n1.  移除索引为 $0$ 的元素。\n2.  将索引为 $1$ 的元素复制到索引 $0$。\n3.  将索引为 $2$ 的元素复制到索引 $1$。\n4.  此过程一直持续到最后一个位于索引 $N-1$ 的元素被复制到索引 $N-2$。\n\n这个序列涉及 $N-1$ 次独立的元素赋值操作。根据规定的成本模型，每次赋值的成本为单位成本，因此单次 `pop_front` 操作的总成本与 $N-1$ 成正比。因此，朴素 `pop_front` 的时间复杂度为 $\\mathcal{O}(N)$，其中 $N$ 是数组中当前的元素数量。每次调用 `pop_front` 都会产生此成本，因此没有摊还的机会；最坏情况和平均情况的成本都与数组的大小成线性关系。\n\n**第 2 部分：使用循环缓冲区（环形缓冲区）的基于数组的队列**\n\n为了同时实现高效的 `push_back` 和 `pop_front` 操作，我们采用循环缓冲区（或环形缓冲区）。这种结构在动态数组之上实现，但将数组的内存视为一个环。使用两个指针，`head` 和 `tail`（或等效的表示，如 `head` 和 `size`），来标记队列的逻辑起点和终点。\n\n-   `push_back`：在 `tail` 位置添加一个元素，并前移 `tail`。\n-   `pop_front`：从 `head` 位置移除一个元素，并前移 `head`。\n\n两个指针在经过数组末尾时都会回绕到数组的开头，通常使用取模运算符：`new_index = (old_index + 1) % capacity`。在不调整大小的情况下，`push_back` 和 `pop_front` 都只需要更新一个指针和进行一次元素读/写。这些都是 $\\mathcal{O}(1)$ 操作。\n\n**环形缓冲区大小调整的摊还分析**\n这种结构的成本主要由其大小调整操作决定。指定的策略是：\n-   **增长**：如果在 `push_back` 时 `size == capacity`，则将容量加倍 ($C \\to 2C$)。\n-   **缩减**：如果在一次操作后 `size = capacity / 4`，则将容量减半 ($C \\to C/2$)。\n\n当发生大小调整时，所有 $N$ 个元素都会从（可能已环绕的）旧数组复制到一个新的、从索引 $0$ 开始的连续数组中。这个过程“展开”了队列，成本为 $\\mathcal{O}(N)$。我们可以使用势函数分析来证明这两个操作的摊还成本都是 $\\mathcal{O}(1)$。\n\n设 $N$ 为元素数量， $C$ 为容量。我们定义一个势函数 $\\Phi$，它存储“信用”以支付未来昂贵的大小调整操作。适用于此方案的一个势函数是：\n$$ \\Phi = \\begin{cases} 2N - C  \\text{if } N/C \\ge 1/2 \\\\ C/2 - N  \\text{if } N/C  1/2 \\end{cases} $$\n一个操作的摊还成本 $\\hat{c}$ 是其实际成本 $c$ 加上势能的变化 $\\Delta\\Phi$。\n\n1.  **`push_back` 导致增长**：假设我们有 $N=C$ 个元素，并执行一次 `push_back`。实际成本 $c$ 是 $1$（用于元素写入）$+ C$（用于将 $C$ 个元素复制到新数组）。总成本为 $c = C+1$。容量从 $C$ 变为 $C' = 2C$，元素数量变为 $N' = C+1$。\n    -   旧势能（$N=C$ 时，所以 $N/C=1 \\ge 1/2$）：$\\Phi_{old} = 2N - C = 2C - C = C$。\n    -   新势能（$N' = C+1, C'=2C$ 时，所以 $N'/C' \\approx 1/2$）：$\\Phi_{new} = 2N' - C' = 2(C+1) - 2C = 2$。\n    -   $\\Delta\\Phi = \\Phi_{new} - \\Phi_{old} = 2 - C$。\n    -   摊还成本：$\\hat{c} = c + \\Delta\\Phi = (C+1) + (2-C) = 3$。这是 $\\mathcal{O}(1)$。\n\n2.  **`pop_front` 导致缩减**：假设一次 `pop_front` 使元素数量减少到 $N = C/4$。实际成本 $c$ 是 $1$（用于 pop 逻辑）$+ N$（用于复制 $N$ 个元素）。总成本为 $c = C/4+1$。容量从 $C$ 变为 $C' = C/2$，元素数量保持 $N' = N = C/4$。\n    -   缩减前的状态是，在容量为 $C$ 的数组中有 $N_{pre} = C/4+1$ 个元素。由于 $N_{pre}/C  1/2$，势能为 $\\Phi_{old} = C/2 - N_{pre} = C/2 - (C/4+1) = C/4 - 1$。\n    -   新势能（$N' = C/4, C' = C/2$ 时，所以 $N'/C' = 1/2$）：$\\Phi_{new} = 2N' - C' = 2(C/4) - C/2 = 0$。\n    -   $\\Delta\\Phi = \\Phi_{new} - \\Phi_{old} = 0 - (C/4-1) = 1-C/4$。\n    -   摊还成本：$\\hat{c} = c + \\Delta\\Phi = (C/4+1) + (1-C/4) = 2$。这是 $\\mathcal{O}(1)$。\n\n在所有情况下（包括可以类似分析的非调整大小的情况），摊还成本都由一个小的常数界定。大小调整策略确保了在一次调整之后，必须执行与新容量成正比数量的操作，才会需要下一次调整。这个间隔允许积累足够的“信用”（势能）来支付下一次线性成本的大小调整，从而使得每次单一操作的摊还成本为 $\\mathcal{O}(1)$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Executes the four test cases defined in the problem statement\n    and prints the results in the specified format.\n    \"\"\"\n\n    # --- Test Case 1: Naive Dynamic Array Shift Cost ---\n    \n    class NaiveDynamicArray:\n        def __init__(self):\n            self.size = 0\n            self.capacity = 0\n            self.data = np.empty(self.capacity, dtype=object)\n            self.pop_front_cost = 0\n\n        def _resize(self, new_capacity):\n            new_data = np.empty(new_capacity, dtype=object)\n            if self.size > 0:\n                new_data[0:self.size] = self.data[0:self.size]\n            self.data = new_data\n            self.capacity = new_capacity\n\n        def push_back(self, value):\n            if self.size == self.capacity:\n                new_cap = 1 if self.capacity == 0 else self.capacity * 2\n                self._resize(new_cap)\n            self.data[self.size] = value\n            self.size += 1\n\n        def pop_front(self):\n            if self.size == 0:\n                return None\n            \n            value = self.data[0]\n            # Cost is the number of element assignments for the shift.\n            shift_cost = self.size - 1\n            self.pop_front_cost += shift_cost\n            \n            # Shift all elements to the left.\n            if shift_cost > 0:\n                self.data[0:shift_cost] = self.data[1:self.size]\n            \n            self.size -= 1\n            return value\n\n    nda = NaiveDynamicArray()\n    for i in range(1, 11): nda.push_back(i)\n    for _ in range(3): nda.pop_front()\n    for i in range(11, 16): nda.push_back(i)\n    for _ in range(4): nda.pop_front()\n    for i in range(16, 21): nda.push_back(i)\n    result_1 = nda.pop_front_cost\n\n    # --- Test Cases 2, 3, 4: Ring Buffer ---\n    \n    class RingBuffer:\n        def __init__(self):\n            self.size = 0\n            self.capacity = 0\n            self.head = 0\n            self.data = np.empty(self.capacity, dtype=object)\n            self.resize_cost = 0\n\n        def _resize(self, new_capacity):\n            # Cost is the number of elements copied.\n            self.resize_cost += self.size\n            \n            new_data = np.empty(new_capacity, dtype=object)\n            # Unwraps the circular buffer into a linear array.\n            for i in range(self.size):\n                old_idx = (self.head + i) % self.capacity\n                new_data[i] = self.data[old_idx]\n            \n            self.data = new_data\n            self.capacity = new_capacity\n            self.head = 0\n\n        def push_back(self, value):\n            if self.size == self.capacity:\n                new_cap = 1 if self.capacity == 0 else self.capacity * 2\n                self._resize(new_cap)\n            \n            tail_idx = (self.head + self.size) % self.capacity\n            self.data[tail_idx] = value\n            self.size += 1\n            # Per problem spec, shrink check is done after an operation.\n            # A push_back will never cause size = capacity / 4 if the\n            # invariant held before, so no shrink check needed here.\n            \n        def pop_front(self):\n            if self.size == 0:\n                return None\n            \n            value = self.data[self.head]\n            self.head = (self.head + 1) % self.capacity\n            self.size -= 1\n            \n            # Shrink condition: size is at most one quarter of capacity.\n            # Must also ensure capacity > 0 to avoid division by zero.\n            if self.capacity > 0 and self.size = self.capacity // 4:\n                # Halve capacity, minimum capacity is 1 if not empty.\n                new_cap = max(1, self.capacity // 2)\n                if new_cap  self.capacity:\n                    self._resize(new_cap)\n\n            return value\n\n        def get_contents(self):\n            contents = []\n            for i in range(self.size):\n                idx = (self.head + i) % self.capacity\n                contents.append(self.data[idx])\n            return contents\n\n    # Test Case 2\n    rb2 = RingBuffer()\n    for i in range(1, 11): rb2.push_back(i)\n    for _ in range(3): rb2.pop_front()\n    for i in range(11, 16): rb2.push_back(i)\n    for _ in range(4): rb2.pop_front()\n    for i in range(16, 21): rb2.push_back(i)\n    result_2 = rb2.resize_cost\n\n    # Test Case 3\n    rb3 = RingBuffer()\n    for i in range(1, 7): rb3.push_back(i)\n    for _ in range(4): rb3.pop_front()\n    for i in range(7, 11): rb3.push_back(i)\n    for _ in range(2): rb3.pop_front()\n    result_3 = rb3.get_contents()\n\n    # Test Case 4\n    rb4 = RingBuffer()\n    for i in range(1, 17): rb4.push_back(i)\n    for _ in range(12): rb4.pop_front()\n    for i in range(17, 25): rb4.push_back(i)\n    for _ in range(8): rb4.pop_front()\n    result_4 = rb4.resize_cost\n    \n    # Final output formatting\n    # The f-string conversion of a list automatically includes spaces, e.g., '[7, 8]'.\n    # We must remove them to match a strict list representation like '[7,8,9,10]'.\n    result_3_str = str(result_3).replace(\" \", \"\")\n\n    print(f\"[{result_1},{result_2},{result_3_str},{result_4}]\")\n\n\nsolve()\n```"
        },
        {
            "introduction": "动态数组是许多算法的基础容器。本练习  的任务是实现随机化的“快速选择”（Quickselect）算法，该算法能以期望线性时间找到第 $k$ 小的元素。这个实践将展示如何直接操作动态数组的底层存储来实现高效的、原地（in-place）的算法，从而加深你对数据结构与算法如何协同工作的理解。",
            "id": "3230152",
            "problem": "您需要设计、分析并实现一个算法，该算法在给定一个未排序的动态数组和一个索引 $k$ 的情况下，返回第 $k$ 小的元素。该方法在数组长度上的期望运行时间应为线性。动态数组必须使用倍增扩容策略在连续存储上显式实现，并且您的选择算法必须直接在此结构上操作，不能使用任何内置的排序或选择例程。\n\n使用的基本定义：\n- 动态数组是存储在连续内存块中的一系列元素，其逻辑长度 $n$（元素数量）可以小于或等于一个单独的容量 $C$，$C$ 表示当前预留了空间的元素数量。当 $n = C$ 并且要附加一个新元素时，动态数组会分配一个大小为 $2C$ 的新块，并复制这 $n$ 个元素，之后 $C$ 更新为 $2C$，然后继续执行附加操作。\n- 在倍增扩容规则下，根据随机存取机 (RAM) 模型测量，附加操作的均摊常数时间为 $O(1)$。\n- 基于分区的选择算法会围绕一个主元重复地对数组进行分区，并对包含目标顺位的一侧进行递归（或迭代）。如果主元是从当前子数组中均匀随机选择的，则找到第 $k$ 小元素的期望运行时间在 $n$ 上是线性的。\n\n您的任务：\n1. 从上述定义出发，推导出一个正确的算法策略，该策略能均匀随机地选择一个主元，并原地对动态数组进行分区，以便只需要进一步处理一侧。解释为什么期望运行时间在元素数量 $n$ 上是线性的，并解释为什么使用倍增扩容的动态数组在构建数组时能够保持附加操作的均摊常数时间。\n2. 从基本原理出发，实现一个 DynamicArray 数据结构，该结构在倍增扩容策略下至少支持附加、按索引读取、按索引写入和获取长度等操作。索引应从零开始，但选择查询使用 $k$ 作为基于 1 的顺序统计量（即，$k = 1$ 表示最小值）。\n3. 实现一个随机化的原地选择算法，对于 $\\{1,\\dots,n\\}$ 中的有效 $k$，返回第 $k$ 小的元素。您的实现不得使用任何内置的排序或选择工具。\n4. 使用您实现的 DynamicArray，通过逐个附加元素来为以下测试套件构建数组，然后在每对 $(A_i,k_i)$ 上运行选择算法。\n\n测试套件：\n- 情况 $1$：$A_1 = [\\,7,2,9,4,1,5\\,]$，$k_1 = 3$。\n- 情况 $2$：$A_2 = [\\,-5,-1,-3,-2\\,]$，$k_2 = 1$。\n- 情况 $3$：$A_3 = [\\,3,3,3,3\\,]$，$k_3 = 4$。\n- 情况 $4$：$A_4 = [\\,5,1,5,2,5,3,5\\,]$，$k_4 = 5$。\n- 情况 $5$：$A_5 = [\\,9,8,7,6,5,4,3,2,1\\,]$，$k_5 = 9$。\n- 情况 $6$：$A_6$ 是降序序列 $[\\,1000,999,\\dots,2,1\\,]$，$k_6 = 500$。\n- 情况 $7$：$A_7 = [\\,0,-10,10,0,-10,10\\,]$，$k_7 = 4$。\n\n所有 $k_i$ 值保证有效，即 $1 \\le k_i \\le |A_i|$。\n\n要求的最终输出格式：\n- 您的程序应生成一行输出，其中包含情况 $1$到 $7$ 的结果，格式为方括号括起来的逗号分隔列表，例如 $[\\,r_1,r_2,\\dots,r_7\\,]$，其中每个 $r_i$ 是为情况 $i$ 返回的第 $k_i$ 小的元素。\n- 此任务不涉及物理单位、角度或百分比。\n\n约束与说明：\n- 当在每个分区步骤中均匀随机地选择主元时，每个选择查询的算法必须具有期望线性时间 $O(n)$。\n- 程序必须是完全自包含的，除了指定的单行输出外，不得读取输入或写入任何其他内容。\n- 您必须使用您实现的动态数组来存储和处理数据，通过 $|A_i|$ 次附加操作序列来构建每个 $A_i$。",
            "solution": "该问题要求设计、分析并实现一个随机化选择算法，以在动态数组中找到第 $k$ 小的元素。解决方案分为两部分：首先是对数据结构和算法的理论推导与分析，其次是具体的实现。\n\n**1. 算法与数据结构分析**\n\n**1.1. 采用倍增扩容策略的动态数组**\n\n动态数组必须能够容纳可变数量的元素 $n$，同时存储在容量为 $C$ 的固定大小连续内存块中，其中 $n \\le C$。当数组已满 ($n=C$) 且需要附加一个元素时，将采用倍增扩容策略。系统会分配一个容量为 $2C$ 的新内存块，将现有的 $n$ 个元素复制到新块中，并释放旧块。然后更新容量，$C \\leftarrow 2C$，并继续执行附加操作。\n\n我们使用聚合方法来分析 `append` 操作的均摊成本。考虑在一个初始容量为 $C_0=1$ 的空动态数组上执行 $N$ 次附加操作。对于 $i \\in \\{1, \\dots, N\\}$，第 $i$ 次附加操作的成本 $c_i$ 通常是 $1$ 个单位（用于写入本身），如果触发了扩容，则还需加上复制成本。当附加第 $(2^j+1)$ 个元素时（对于 $j \\ge 0$）会发生扩容。此时，元素数量为 $n = 2^j$，容量为 $C = 2^j$。这次附加操作的成本是 $c_{2^j+1} = 1 + 2^j$（1 用于写入，$2^j$ 用于复制现有元素）。所有其他附加操作的成本均为 $1$。\n\n$N$ 次附加操作的总成本 $T(N)$ 是所有非扩容附加和所有扩容附加的成本之和。\n设 $N$ 为元素总数。非扩容附加的次数为 $N$ 次（每次附加至少涉及一次写入）。当元素数量为 $1, 2, 4, \\dots, 2^m$（其中 $2^m  N$）时会发生扩容。这些扩容的成本是每一步复制的元素数量之和。\n$$ T(N) = \\sum_{i=1}^N c_i = N + \\sum_{j=0}^{\\lfloor\\log_2(N-1)\\rfloor} 2^j $$\n该求和是一个几何级数：$\\sum_{j=0}^{k} 2^j = 2^{k+1} - 1$。这里，$k = \\lfloor\\log_2(N-1)\\rfloor$。\n$$ \\sum_{j=0}^{\\lfloor\\log_2(N-1)\\rfloor} 2^j  \\sum_{j=0}^{\\log_2(N)} 2^j = 2^{\\log_2(N)+1} - 1 = 2N - 1 $$\n因此，复制的总成本受 $2N$ 的限制。$N$ 次附加的总成本为 $T(N)  N + 2N = 3N$。\n所以，$T(N) = O(N)$。每次操作的均摊成本是总成本除以操作次数，即 $T(N)/N = O(N)/N = O(1)$。这证实了附加操作具有均摊常数时间复杂度。\n\n**1.2. 随机化分区选择算法 (Quickselect)**\n\n在长度为 $n$ 的未排序数组中找到第 $k$ 小元素的算法通过递归地对数组进行分区来运作。这个算法通常被称为快速选择 (Quickselect)。\n\n策略如下：\n1.  给定一个子数组（初始时为整个数组），从该子数组中均匀随机地选择一个主元 (pivot) 元素。\n2.  将该子数组划分为三个部分：小于主元的元素、主元本身以及大于主元的元素。这可以在线性时间 $O(m)$ 内原地完成，其中 $m$ 是子数组的大小。分区后，主元元素位于其最终排序后的位置，比如说索引 $p$。\n3.  设小于或等于主元的分区中的元素数量为 $L$。这对应于主元的顺位。如果目标顺位 $k$ 等于 $L$，则主元就是第 $k$ 小的元素，算法终止。\n4.  如果 $k  L$，第 $k$ 小的元素必定在较小元素的子数组中。算法对这个较小的子数组进行递归，仍然寻找第 $k$ 小的元素。\n5.  如果 $k > L$，第 $k$ 小的元素必定在较大元素的子数组中。算法对这个较大的子数组进行递归，但现在寻找的是第 $(k-L)$ 小的元素，因为左侧已经排除了 $L$ 个元素。\n\n效率的关键在于我们只对两个分区中的一个进行递归，而不是像快速排序 (Quicksort) 那样对两个都进行递归。\n\n**期望时间复杂度分析：**\n设 $T(n)$ 是算法在大小为 $n$ 的数组上的期望运行时间。分区步骤需要 $cn$ 的时间，其中 $c$ 为某个常数。主元是均匀随机选择的，因此它有相同的概率（$1/n$）成为第 $i$ 小的元素，对于任何 $i \\in \\{1, \\dots, n\\}$。\n如果主元是第 $i$ 小的元素，我们将得到一个大小为 $i-1$（如果 $k  i$）或 $n-i$（如果 $k > i$）的子问题。因此，递归调用的规模为 $\\max(i-1, n-i)$。期望时间的递推关系为：\n$$ T(n) \\le cn + \\frac{1}{n}\\sum_{i=1}^{n} T(\\max(i-1, n-i)) $$\n对于大多数值，$\\max(i-1, n-i)$ 项会出现两次。\n$$ T(n) \\le cn + \\frac{2}{n}\\sum_{i=\\lceil n/2 \\rceil}^{n-1} T(i) $$\n我们可以通过归纳法证明 $T(n) = O(n)$。假设对于某个常数 $a$，所有 $m  n$ 都有 $T(m) \\le am$。\n$$ T(n) \\le cn + \\frac{2}{n}\\sum_{i=\\lceil n/2 \\rceil}^{n-1} (ai) $$\n$$ T(n) \\le cn + \\frac{2a}{n} \\left( \\sum_{i=1}^{n-1} i - \\sum_{i=1}^{\\lceil n/2 \\rceil - 1} i \\right) $$\n使用前 $k$ 个整数的和的公式 $\\sum_{i=1}^{k}i = \\frac{k(k+1)}{2}$：\n$$ \\sum_{i=\\lceil n/2 \\rceil}^{n-1} i \\approx \\frac{(n-1)n}{2} - \\frac{(n/2)(n/2-1)}{2} = \\frac{n^2-n}{2} - \\frac{n^2/4-n/2}{2} \\approx \\frac{n^2}{2} - \\frac{n^2}{8} = \\frac{3n^2}{8} $$\n将此代入递推关系：\n$$ T(n) \\le cn + \\frac{2a}{n} \\left( \\frac{3n^2}{8} \\right) = cn + \\frac{3a}{4}n = n \\left(c + \\frac{3a}{4}\\right) $$\n为了使归纳成立，我们需要 $n(c + \\frac{3a}{4}) \\le an$。如果 $c + \\frac{3a}{4} \\le a$，即 $c \\le \\frac{a}{4}$ 或 $a \\ge 4c$，这是成立的。我们总可以选择一个足够大的常数 $a$ 来满足这个条件。\n因此，根据数学归纳法原理，$T(n) = O(n)$。期望运行时间在元素数量上是线性的。最坏情况下的时间是 $O(n^2)$，这发生在主元总是被选为最小或最大元素时，但通过随机选择主元，这种情况发生的概率极小。",
            "answer": "```python\nimport numpy as np\nimport random\nimport sys\n\n# Set a higher recursion limit for safety, although the iterative implementation avoids this.\n# sys.setrecursionlimit(2000)\n\nclass DynamicArray:\n    \"\"\"\n    A dynamic array implementation using a contiguous numpy array with a doubling-resize strategy.\n    \"\"\"\n    def __init__(self):\n        \"\"\"\n        Initializes an empty dynamic array with an initial capacity of 1.\n        \"\"\"\n        self._n = 0  # Number of elements\n        self._capacity = 1  # Allocated memory size\n        self._A = np.empty(self._capacity, dtype=object)  # Underlying storage\n\n    def __len__(self):\n        \"\"\"\n        Returns the number of elements in the array.\n        \"\"\"\n        return self._n\n\n    def __getitem__(self, k):\n        \"\"\"\n        Returns the element at index k.\n        \"\"\"\n        if not (0 = k  self._n):\n            raise IndexError('Index out of range')\n        return self._A[k]\n\n    def __setitem__(self, k, v):\n        \"\"\"\n        Sets the element at index k to value v.\n        \"\"\"\n        if not (0 = k  self._n):\n            raise IndexError('Index out of range')\n        self._A[k] = v\n\n    def append(self, item):\n        \"\"\"\n        Appends an item to the end of the array.\n        Resizes the array by doubling its capacity if it's full.\n        \"\"\"\n        if self._n == self._capacity:\n            self._resize(2 * self._capacity)\n        self._A[self._n] = item\n        self._n += 1\n\n    def _resize(self, new_capacity):\n        \"\"\"\n        Resizes the internal array to a new capacity.\n        \"\"\"\n        B = np.empty(new_capacity, dtype=object)\n        for i in range(self._n):\n            B[i] = self._A[i]\n        self._A = B\n        self._capacity = new_capacity\n\n    def __repr__(self):\n        \"\"\"\n        String representation of the array content.\n        \"\"\"\n        return f\"[{', '.join(map(str, [self._A[i] for i in range(self._n)]))}]\"\n\n\ndef _partition(arr, low, high):\n    \"\"\"\n    Helper function to partition the subarray arr[low..high] using the Lomuto partition scheme.\n    A random element is chosen as the pivot.\n    Returns the final index of the pivot.\n    \"\"\"\n    # Select a random pivot and move it to the end\n    pivot_index = random.randint(low, high)\n    arr[pivot_index], arr[high] = arr[high], arr[pivot_index]\n    pivot_value = arr[high]\n\n    # i is the index of the last element smaller than or equal to the pivot\n    i = low - 1\n    for j in range(low, high):\n        if arr[j] = pivot_value:\n            i += 1\n            arr[i], arr[j] = arr[j], arr[i]\n\n    # Place the pivot in its final sorted position\n    arr[i + 1], arr[high] = arr[high], arr[i + 1]\n    return i + 1\n\ndef randomized_select(arr, k):\n    \"\"\"\n    Finds the k-th smallest element in a DynamicArray in expected linear time.\n    arr: A DynamicArray instance.\n    k: The one-based rank of the element to find (e.g., k=1 for minimum).\n    \"\"\"\n    n = len(arr)\n    if not (1 = k = n):\n        raise ValueError(\"k must be between 1 and the length of the array\")\n\n    # The algorithm works with 0-based indices. The k-th smallest element\n    # is at index k-1 in a sorted array.\n    target_idx = k - 1\n    \n    low, high = 0, n - 1\n\n    while True:\n        # If the subarray has only one element, it must be the one we're looking for.\n        if low == high:\n            return arr[low]\n\n        pivot_idx = _partition(arr, low, high)\n\n        if pivot_idx == target_idx:\n            return arr[pivot_idx]\n        elif target_idx  pivot_idx:\n            high = pivot_idx - 1\n        else:  # target_idx > pivot_idx\n            low = pivot_idx + 1\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the final output.\n    \"\"\"\n    # Set a seed for the random number generator for reproducible results.\n    random.seed(42)\n\n    test_cases = [\n        {'A': [7, 2, 9, 4, 1, 5], 'k': 3},\n        {'A': [-5, -1, -3, -2], 'k': 1},\n        {'A': [3, 3, 3, 3], 'k': 4},\n        {'A': [5, 1, 5, 2, 5, 3, 5], 'k': 5},\n        {'A': [9, 8, 7, 6, 5, 4, 3, 2, 1], 'k': 9},\n        {'A': list(range(1000, 0, -1)), 'k': 500},\n        {'A': [0, -10, 10, 0, -10, 10], 'k': 4},\n    ]\n\n    results = []\n    for case in test_cases:\n        # 1. Construct the dynamic array by appending elements one by one.\n        dynamic_arr = DynamicArray()\n        for x in case['A']:\n            dynamic_arr.append(x)\n        \n        # 2. Find the k-th smallest element.\n        k = case['k']\n        result = randomized_select(dynamic_arr, k)\n        results.append(result)\n\n    # 3. Print the results in the required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}