{
    "hands_on_practices": [
        {
            "introduction": "This exercise provides a foundational challenge in direct, in-place data manipulation. By implementing a circular rotation under strict memory constraints, you will explore the permutation's underlying cycle structure, a key concept for writing efficient algorithms. Mastering this reveals how number theory, specifically the greatest common divisor, can be applied to optimize array operations .",
            "id": "3275350",
            "problem": "You are given a static array, that is, a contiguous block of memory with a fixed length $n$ holding elements in indexed positions from $0$ to $n-1$. The task is to implement an in-place circular right rotation by $k$ positions on such an array, subject to strict constraints. The rotation mapping from index $i$ to its destination is the permutation $T(i) = (i + k) \\bmod n$. The implementation must not allocate any temporary array and should perform a minimal number of writes to the array. A write is defined as any assignment to an array cell that changes its content. You may use a constant number of scalar variables.\n\nYour program must implement a function that, given an array and an integer $k$, performs a circular right rotation by $k$ positions in place, while achieving the minimal number of writes implied by the rotation. You must normalize $k$ via modular arithmetic so that the rotation is well-defined for any integer input $k$, including negative values. The program must then run the following test suite and output the results exactly in the specified format.\n\nTest suite:\n- Case $1$: array $[0,1,2,3,4,5,6,7]$, $k=3$.\n- Case $2$: array $[1,2,3,4,5]$, $k=0$.\n- Case $3$: array $[5,4,3,2,1,0]$, $k=12$.\n- Case $4$: array $[10,20,30,40,50]$, $k=-2$.\n- Case $5$: array $[1,2,3,4,5,6,7,8,9,10,11,12]$, $k=4$.\n- Case $6$: array $[42]$, $k=999$.\n\nFor each case, your program must output a list consisting of the rotated array and the integer count of writes performed. The final output must be a single line containing a comma-separated list of these per-case results, enclosed in square brackets. Concretely, the final output format is\n$[[\\text{rotated\\_array}_1,\\text{writes}_1],[\\text{rotated\\_array}_2,\\text{writes}_2],\\ldots]$,\nfor example, $[[[5,6,7,0,1,2,3,4],8],[\\ldots,\\ldots],\\ldots]$.\n\nThe design must start from fundamental definitions appropriate to static arrays and index permutations, must be scientifically realistic and internally consistent, and must not introduce any temporary arrays. All answers are integers or lists of integers; no physical units or angle units apply to this problem.",
            "solution": "The problem statement is evaluated as valid. It is a well-posed, scientifically grounded problem in the domain of data structures and algorithms, free of contradictions or ambiguities.\n\n**Problem Statement Validation**\n\nStep 1: Extract Givens\n- **Data Structure**: A static array, defined as a contiguous block of memory of fixed length $n$.\n- **Indexing**: Elements are in indexed positions from $0$ to $n-1$.\n- **Task**: Implement an in-place circular right rotation by $k$ positions.\n- **Permutation**: The rotation mapping is defined by the permutation $T(i) = (i + k) \\bmod n$.\n- **Constraints**:\n    1. The implementation must be in-place, meaning it must not allocate any temporary array.\n    2. It should perform a minimal number of writes.\n    3. It may use a constant number of scalar variables.\n- **Write Definition**: A \"write\" is an assignment to an array cell that changes its content.\n- **Input `k`**: Any integer, including negative values, which must be normalized.\n- **Test Suite**: Six specific test cases are provided for validation.\n- **Output Format**: For each case, produce a list containing the rotated array and the integer count of writes. The final output must be a single line: $[[\\text{rotated\\_array}_1,\\text{writes}_1],[\\text{rotated\\_array}_2,\\text{writes}_2],\\ldots]$.\n\nStep 2: Validate Using Extracted Givens\n- **Scientifically Grounded**: The problem is fundamentally about permutations on a finite set of indices, a core topic in discrete mathematics and algorithm design. The concepts of modular arithmetic, greatest common divisor (GCD), and cycle decomposition are standard mathematical tools. The problem is scientifically and mathematically sound.\n- **Well-Posed**: The problem is clearly defined, and the constraints guide the solution toward a specific, efficient class of algorithms. A unique and stable solution exists for any given valid input.\n- **Objective**: The problem is described using precise, formal language without subjective or opinion-based statements.\n\nThe problem does not exhibit any of the invalidity flaws. It is a canonical, formalizable problem in computer science.\n\nStep 3: Verdict and Action\nThe problem is **valid**. Proceeding to the solution.\n\n**Principle-Based Solution Design**\n\nThe task is to perform a circular right rotation on an array of length $n$ by $k$ positions. This operation can be modeled as a permutation $T$ on the set of indices $\\{0, 1, \\ldots, n-1\\}$, where each element at index $i$ is moved to index $T(i)$.\n\nFirst, we normalize the rotation amount $k$. A rotation by $k$ is equivalent to a rotation by $k \\bmod n$. For any integer $k$, we define an effective rotation $k' = k \\bmod n$. If $k' = 0$, the permutation is the identity, no elements move, and the number of writes required is $0$. For all other cases, we consider rotation by $k'$. The permutation is explicitly $T(i) = (i + k') \\bmod n$.\n\nAn in-place algorithm with minimal writes must operate by following the cycle structure of the permutation $T$. Any permutation can be uniquely decomposed into a set of disjoint cycles. To move the elements of a single cycle, we can save one element in a temporary scalar variable, and then shift the remaining elements of the cycle one by one into the vacant positions. The saved element is then written into the final vacant position. This completes the permutation of one cycle.\n\nLet's analyze the structure of the permutation $T(i) = (i + k') \\bmod n$. A cycle starting from an index $s$ is the sequence $s, (s+k') \\bmod n, (s+2k') \\bmod n, \\ldots$. The cycle is complete when we return to $s$. This occurs for the smallest positive integer $m$ such that $(s + m \\cdot k') \\bmod n = s$, which simplifies to $(m \\cdot k') \\bmod n = 0$. This means $m \\cdot k'$ must be a multiple of $n$. Let $g = \\gcd(n, k')$. We can write $n = g \\cdot n_{rel}$ and $k' = g \\cdot k_{rel}$, where $n_{rel}$ and $k_{rel}$ are relatively prime. The condition becomes $(m \\cdot g \\cdot k_{rel}) \\bmod (g \\cdot n_{rel}) = 0$, which is equivalent to $(m \\cdot k_{rel}) \\bmod n_{rel} = 0$. Since $\\gcd(k_{rel}, n_{rel}) = 1$, the smallest positive integer $m$ satisfying this is $m = n_{rel}$. Thus, the length of every cycle in the permutation is $L = n_{rel} = n / \\gcd(n, k')$.\n\nThe total number of elements is $n$, and each cycle has length $L$. Therefore, the number of disjoint cycles is $n/L = n / (n/g) = g = \\gcd(n, k')$. The starting elements of these $g$ cycles can be chosen as the indices $s = 0, 1, \\ldots, g-1$.\n\nThis leads to the \"cycle leader\" algorithm:\n$1$. Calculate the effective rotation $k' = k \\bmod n$. If $k' = 0$, the number of writes is $0$.\n$2$. If $k' \\neq 0$, calculate $g = \\gcd(n, k')$. This is the number of cycles.\n$3$. Iterate through the cycle leaders $s = 0, 1, \\ldots, g-1$.\n$4$. For each cycle leader $s$, traverse its cycle. A temporary variable holds the value of the element being displaced. Starting with `val_to_move = array[s]`, we iteratively move elements forward. In each step of a cycle traversal, a value is moved from its current position to its destination, and the value originally at the destination is picked up to be moved in the next step. This process continues until we cycle back to the start.\n$5$. For a cycle of length $L$, this procedure involves exactly $L$ assignments to array cells. The total number of assignments is $g \\times L = \\gcd(n, k') \\times (n / \\gcd(n, k')) = n$.\n$6$. Per the problem's strict definition, a \"write\" only occurs if an assignment changes the content of an array cell. Our implementation will therefore check if the value being written differs from the value being overwritten before incrementing the write counter. For the given test cases, where array elements are unique, the number of writes will be $n$ for any non-identity rotation.\n\nThis algorithm satisfies all constraints: it is in-place, uses a constant number of scalar variables (for indices and one temporary value), and achieves the minimal number of writes ($n$ for a non-trivial permutation, $0$ otherwise).",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the in-place circular array rotation problem for a suite of test cases.\n    \"\"\"\n\n    test_cases = [\n        (np.array([0, 1, 2, 3, 4, 5, 6, 7]), 3),\n        (np.array([1, 2, 3, 4, 5]), 0),\n        (np.array([5, 4, 3, 2, 1, 0]), 12),\n        (np.array([10, 20, 30, 40, 50]), -2),\n        (np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]), 4),\n        (np.array([42]), 999),\n    ]\n\n    results = []\n    \n    for arr, k_val in test_cases:\n        rotated_arr, writes = rotate_array(arr.copy(), k_val)\n        # Convert numpy array to list for exact output format\n        result = [rotated_arr.tolist(), writes]\n        results.append(result)\n\n    # Format the final output string to match the problem specification exactly\n    # by removing spaces from the default string representation of the list.\n    str_results = [str(r).replace(' ', '') for r in results]\n    print(f\"[{','.join(str_results)}]\")\n\ndef rotate_array(arr: np.ndarray, k: int):\n    \"\"\"\n    Performs an in-place circular right rotation on a numpy array by k positions.\n\n    The algorithm is based on the cycle decomposition of the rotation permutation.\n    It achieves the minimal number of writes and uses O(1) extra space.\n\n    Args:\n        arr: The numpy array to be rotated.\n        k: The number of positions to rotate right. Can be any integer.\n\n    Returns:\n        A tuple containing:\n        - The rotated numpy array (same object as input `arr`).\n        - The total number of writes performed, where a write is an assignment\n          that changes an array cell's content.\n    \"\"\"\n    n = len(arr)\n    if n == 0:\n        return arr, 0\n\n    # 1. Normalize k to be in the range [0, n-1]\n    k = k % n\n    if k == 0:\n        return arr, 0\n\n    writes = 0\n    \n    # 2. The number of disjoint cycles is the greatest common divisor of n and k.\n    num_cycles = math.gcd(n, k)\n    \n    # 3. Iterate through each cycle.\n    # The starting elements of the cycles can be taken as 0, 1, ..., num_cycles-1.\n    for start_node in range(num_cycles):\n        current_idx = start_node\n        val_to_move = arr[current_idx]\n\n        # Use a \"do-while\" loop pattern to traverse the cycle\n        while True:\n            # 4. Determine the next index in the cycle\n            next_idx = (current_idx + k) % n\n            \n            # 5. Swap values and count write if content changes\n            # The value at next_idx is saved before being overwritten.\n            temp = arr[next_idx]\n            \n            # A write is counted only if the value actually changes.\n            if arr[next_idx] != val_to_move:\n                arr[next_idx] = val_to_move\n                writes += 1\n            \n            val_to_move = temp\n            current_idx = next_idx\n\n            # The cycle is complete when we return to the starting node.\n            if current_idx == start_node:\n                break\n                \n    return arr, writes\n\nsolve()\n```"
        },
        {
            "introduction": "Building on in-place manipulation, this problem introduces a more abstract use of the static array's structure. The challenge is to find a missing positive integer in linear time and with constant extra space, forcing you to use the array itself as a form of hash map. This practice demonstrates the powerful technique of rearranging elements to encode information directly within the array's indices .",
            "id": "3275160",
            "problem": "You are given multiple independent test cases, each consisting of an unsorted static array of integers. For each array, compute the smallest missing positive integer. The algorithmic requirements are that, for an array of length $N$, your method must run in $O(N)$ time and use $O(1)$ additional space beyond the given static array. A static array is a fixed-length, contiguous block of memory that supports constant-time random access and in-place updates.\n\nUse only the following fundamental base: the definition and properties of static arrays (constant-time indexing and assignment), the notion of in-place updates via a constant number of assignments (including element swaps), and the standard definitions of time complexity $O(\\cdot)$ and space complexity $O(\\cdot)$. Do not resize arrays, allocate auxiliary arrays proportional to $N$, or use hashing structures whose size depends on $N$.\n\nImplement a program that applies your algorithm to the following test suite of arrays:\n- $[3,4,-1,1]$\n- $[1,1,0,-1,-2,2]$\n- $[1,2,3]$\n- $[-5,-1,-3]$\n- $[7,8,9,11,12]$\n- $[2,3,4,5,6,7]$\n- $[]$\n- $[2]$\n- $[1]$\n\nFor each array, the answer is a single integer: the smallest missing positive integer in that array. Your program must hard-code the above test suite, must not read any input, and must not write any extraneous output.\n\nFinal output format: Your program should produce a single line of output containing the results for the test suite, in order, as a comma-separated list enclosed in square brackets, for example, $[a,b,c,\\dots]$, where each entry is the integer result for the corresponding test case.",
            "solution": "The problem as stated is valid. It is a well-defined algorithmic challenge from the field of computer science, grounded in the formal properties of static arrays and complexity theory. The problem is self-contained, objective, and its constraints are stringent but achievable.\n\nThe task is to find the smallest missing positive integer in an unsorted static array of length $N$. The solution must achieve a time complexity of $O(N)$ and a space complexity of $O(1)$ (constant additional space).\n\nThe core principle behind an efficient solution lies in the observation that the smallest missing positive integer must be in the range $[1, N+1]$. If the array contains all integers from $1$ to $N$, the answer is $N+1$. Otherwise, the answer is the smallest integer from the set $\\{1, 2, \\dots, N\\}$ that is not present in the array. This insight narrows the search space considerably.\n\nGiven the $O(1)$ space constraint, we cannot use auxiliary data structures like a hash map or a boolean array of size $N$ to track the presence of numbers. We must repurpose the input array itself to store this information. The strategy is to treat the array's indices as a hash table and the values as the elements to be placed. Specifically, we aim to place the integer $k$ at index $k-1$ for all $k \\in \\{1, \\dots, N\\}$ that are present in the array.\n\nThe algorithm proceeds in two main phases:\n\n**Phase 1: In-Place Cyclical Placement**\n\nThe goal of this phase is to rearrange the array such that if an integer $k$ (where $1 \\le k \\le N$) is present, it is moved to the index $k-1$.\n\nWe iterate through the array from index $i=0$ to $N-1$. For each element $A[i]$, we check its value, which we can call $v$. An inner `while` loop is used to handle the placement of $v$:\n1.  The value $v = A[i]$ is a candidate for placement only if it falls within the valid range, i.e., $1 \\le v \\le N$.\n2.  To prevent infinite loops when duplicate values are present, we must also ensure that the value $v$ is not already at its target location. The target location for value $v$ is index $v-1$, which should contain the value $v$. So, the swap should only occur if $A[v-1] \\neq v$.\n\nIf both conditions are met ($1 \\le A[i] \\le N$ and $A[A[i]-1] \\neq A[i]$), we swap the element $A[i]$ with the element at its target index, $A[A[i]-1]$. After a swap, the element at index $i$ is new, and we must re-evaluate it in the inner `while` loop. This cyclical process continues until the value at $A[i]$ is no longer a candidate for moving (either because it is out of the $[1, N]$ range or because it is a duplicate of a value already correctly placed).\n\nThis phase has a time complexity of $O(N)$. Although there is a nested loop structure, each swap places at least one integer into its correct final position. An integer is never moved again once it reaches its correct index. Since there are at most $N$ integers to place, the total number of swaps across all iterations of the outer loop is bounded by $N$.\n\n**Phase 2: First Mismatch Detection**\n\nAfter the placement phase, the array has been rearranged. For any integer $k \\in \\{1, \\dots, N\\}$, if $k$ was in the original array, we now have $A[k-1] = k$. There might be \"junk\" values (negative numbers, zeros, or numbers greater than $N$) in positions corresponding to missing integers.\n\nWe perform a single linear scan of the modified array from index $j = 0$ to $N-1$. We check if $A[j] = j+1$. The first index $j$ for which this condition fails ($A[j] \\neq j+1$) tells us that $j+1$ is the smallest positive integer that was missing from the original array. We can then return $j+1$.\n\nIf the loop completes without finding any such mismatch, it means that for every $j \\in [0, N-1]$, we found $A[j] = j+1$. This implies that the array contained all integers from $1$ to $N$. In this case, the smallest missing positive integer is $N+1$.\n\nThis two-phase approach correctly identifies the smallest missing positive integer while adhering to the strict $O(N)$ time and $O(1)$ space complexity requirements. It correctly handles edge cases such as empty arrays, arrays with all negative numbers, arrays with duplicates, and arrays that are already sorted.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the smallest missing positive integer for a list of test cases,\n    adhering to O(N) time and O(1) space complexity.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # We convert them to numpy arrays to better model the concept of a 'static array'.\n    test_cases_lists = [\n        [3,4,-1,1],\n        [1,1,0,-1,-2,2],\n        [1,2,3],\n        [-5,-1,-3],\n        [7,8,9,11,12],\n        [2,3,4,5,6,7],\n        [],\n        [2],\n        [1],\n    ]\n    \n    test_cases = [np.array(tc, dtype=np.int64) for tc in test_cases_lists]\n\n    results = []\n    for nums in test_cases:\n        result = find_smallest_missing_positive(nums)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef find_smallest_missing_positive(nums: np.ndarray) - int:\n    \"\"\"\n    Finds the smallest missing positive integer in a static array.\n    The algorithm rearranges the array in-place to use indices as a hash map.\n\n    Args:\n        nums: A numpy array of integers. The array is modified in-place.\n\n    Returns:\n        The smallest positive integer not present in the array.\n    \"\"\"\n    n = nums.size\n\n    # Phase 1: In-place cyclical placement.\n    # The goal is to place each number k (in [1, n]) at index k-1.\n    for i in range(n):\n        # Continue swapping nums[i] into its correct place as long as it's a\n        # valid candidate and not already in its correct place.\n        # Condition 1: The value must be in the range [1, n].\n        # Condition 2: The value at the target index must not already be the correct value.\n        # This prevents infinite loops on duplicate entries.\n        while 1 = nums[i] = n and nums[nums[i] - 1] != nums[i]:\n            target_idx = nums[i] - 1\n            # Swap the current number to its correct position.\n            nums[i], nums[target_idx] = nums[target_idx], nums[i]\n\n    # Phase 2: Find the first missing positive.\n    # After rearrangement, the first index i where nums[i] != i + 1\n    # indicates that i + 1 is the smallest missing positive number.\n    for i in range(n):\n        if nums[i] != i + 1:\n            return i + 1\n    \n    # If the loop completes, it means all integers from 1 to n were present.\n    # The smallest missing positive is therefore n + 1.\n    return n + 1\n\nsolve()\n```"
        },
        {
            "introduction": "This final practice elevates the array concept to an abstract representation of a mathematical structure. By treating the array's values as pointers in a functional graph, you can solve the problem of finding a duplicate in a read-only array. This exercise introduces the powerful Floyd's \"Tortoise and Hare\" cycle-finding algorithm, showcasing how a static array can model more complex data relationships like linked lists and graphs .",
            "id": "3275310",
            "problem": "Consider a static array, defined as a fixed-size, contiguous block of memory that supports constant-time random access, storing integers without any in-place modification once constructed. Let there be an array of length $N+1$ containing integers constrained to the closed interval $[1,N]$. By definition, a static array does not permit element insertion, deletion, or value changes; only read operations are allowed. The task is to determine a duplicate value that must exist due to the cardinality constraint, without modifying the array and using only constant extra space, while executing in a time bounded above by a linear function of $N$.\n\nBase facts to use for reasoning and design:\n- The Pigeonhole Principle: If $N+1$ items are placed into $N$ containers, at least one container holds at least $2$ items.\n- A static array of length $N+1$ with entries in $[1,N]$ can be treated as a function $f$ from indices to values, where $f(i)=A[i]$ for an index $i$ and array $A$.\n- In a directed functional graph where each node has out-degree $1$, any sufficiently long traversal must eventually enter a cycle.\n\nDesign a program that, given several such static arrays, returns the duplicate value for each array using constant additional space and without altering any array. The program must be entirely self-contained and must not read input from any external source. It must process the following test suite and produce the results in the specified final output format.\n\nTest suite arrays to process, each complying with the constraints:\n- Array $A_1 = [1,3,4,2,2,5]$ with $N=5$.\n- Array $A_2 = [1,1]$ with $N=1$.\n- Array $A_3 = [3,1,3,4,2,5,6]$ with $N=6$.\n- Array $A_4 = [7,2,4,3,5,6,1,7]$ with $N=7$.\n- Array $A_5 = [1,5,4,3,2,6,7,8,9,10,5]$ with $N=10$.\n- Array $A_6 = [2,5,1,1,4,3,6,8,7]$ with $N=8$.\n\nFor each array $A_i$, the required output is a single integer in $[1,N]$ equal to the duplicated value in $A_i$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order $A_1$ through $A_6$, for example, $[r_1,r_2,r_3,r_4,r_5,r_6]$, where each $r_i$ is the integer duplicate found for array $A_i$.",
            "solution": "The problem statement is evaluated as valid. It is scientifically grounded in the principles of discrete mathematics and algorithm theory, well-posed with sufficient constraints for a unique algorithmic solution, and expressed in objective, formal language. All provided data and constraints are self-consistent and formalizable.\n\nThe task is to find a duplicate integer in a static array $A$ of length $N+1$ whose elements are drawn from the set $\\{1, 2, \\dots, N\\}$. The solution must operate in time linear in $N$, use constant extra space, and not modify the input array.\n\nThe existence of at least one duplicate value is guaranteed by the Pigeonhole Principle. We have $N+1$ items (the elements of the array $A$) to be placed in $N$ containers (the possible integer values from $1$ to $N$). Therefore, at least one value must be present more than once.\n\nThe provided constraints guide us toward an algorithm based on cycle detection in a functional graph. Let us model the array as a directed graph where the nodes are the indices of the array, $\\{0, 1, \\dots, N\\}$. A directed edge exists from each index $i$ to the index specified by the value $A[i]$. Since array indices are 0-based in standard implementations, we must be precise about the mapping. The array values are in the range $[1, N]$, which are all valid indices within the set $\\{0, 1, \\dots, N\\}$. Thus, we can define a successor function $s(i) = A[i]$ that maps an index $i$ to a successor index $A[i]$.\n\nThe structure of this functional graph is key. The set of nodes is $V = \\{0, 1, \\dots, N\\}$, a set of cardinality $N+1$. The set of possible successor nodes, determined by the values in the array, is $A[V] \\subseteq \\{1, 2, \\dots, N\\}$. This means that no edge in the graph points to node $0$. Consequently, the node corresponding to index $0$ must have an in-degree of $0$.\n\nAny node with an in-degree of $0$ cannot be part of a cycle. Therefore, node $0$ must be the starting point of a path that is not part of a cycle. Since the graph is finite, any path starting from node $0$ must eventually enter a cycle. This structure, a path leading into a cycle, is known as a rho-shape ($\\rho$).\n\nThe algorithm to find the duplicate value leverages this structure by applying Floyd's Tortoise and Hare cycle-finding algorithm. Let's trace the sequence of indices starting from node $0$: $x_0 = 0$, $x_1 = A[x_0]$, $x_2 = A[x_1]$, and so on, with $x_{k+1} = A[x_k]$. The algorithm proceeds in two phases.\n\nPhase 1: Finding an intersection point within the cycle.\nWe use two pointers, a \"tortoise\" ($t$) and a \"hare\" ($h$). Both start at index $0$. In each step, the tortoise advances one position ($t \\to A[t]$), while the hare advances two positions ($h \\to A[A[h]]$). Since the sequence starting from $0$ enters a cycle, the hare, moving faster, will eventually lap the tortoise. They are guaranteed to meet at some index within the cycle.\n\nLet $t_0 = 0$ and $h_0 = 0$.\nThe sequence of positions is:\n$t_{k+1} = A[t_k]$\n$h_{k+1} = A[A[h_k]]$\n\nWe iterate until $t_k = h_k$ for some $k  0$. Let this meeting index be $m$.\n\nPhase 2: Finding the entrance to the cycle.\nThe theory behind Floyd's algorithm states that the length of the initial path from the start node ($0$) to the cycle's entrance is equal to the distance from the meeting point ($m$) to the cycle's entrance (modulo the cycle's length). Therefore, to find the cycle's entrance, we reset one pointer ($p_1$) to the start ($0$) and keep the other pointer ($p_2$) at the meeting point ($m$). We then advance both pointers one step at a time ($p_1 \\to A[p_1]$ and $p_2 \\to A[p_2]$). The index where they meet is the first node of the cycle.\n\nLet $p_{1,0} = 0$ and $p_{2,0} = m$.\nThe sequence of positions is:\n$p_{1, k+1} = A[p_{1,k}]$\n$p_{2, k+1} = A[p_{2,k}]$\n\nWe iterate until $p_{1,k} = p_{2,k}$. This common index is the entrance to the cycle. Let this entrance index be $d$.\n\nJustification: Why is the cycle entrance index the duplicate value?\nLet the entrance to the cycle be the index $d$. By definition of being the cycle entrance for the path starting at $0$, there must be a predecessor index $p$ on the path such that $A[p] = d$. Since $d$ is also part of a cycle, there must be another predecessor index $q$ that is part of the cycle, such that $A[q] = d$. The index $p$ is on the non-cyclic path, while $q$ is in the cycle. Therefore, $p \\neq q$. We have found two distinct indices, $p$ and $q$, that both map to the value $d$. This means $A[p] = A[q] = d$, and thus, the value $d$ is the duplicate we seek.\n\nThis algorithm fulfills all requirements:\n1.  It is non-destructive, only performing read operations on the array.\n2.  It uses constant extra space for a few pointer variables ($t, h, p_1, p_2$).\n3.  Its time complexity is linear, as both phases of the algorithm traverse a number of nodes proportional to the length of the path and cycle, which is bounded by $N+1$.\n\nThe implementation will follow these two phases to find the cycle entrance index for each given array, which corresponds to the duplicate value.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of finding a duplicate number in a static array.\n    \"\"\"\n\n    def find_duplicate(arr: np.ndarray) - int:\n        \"\"\"\n        Finds a duplicate number in a static array using Floyd's Tortoise and Hare algorithm.\n\n        The array is modeled as a functional graph where indices are nodes and the\n        value at an index is the pointer to the next node. The problem constraints\n        (array of length N+1 with values in [1,N]) guarantee that index 0 has an\n        in-degree of 0, serving as the start of a path that must lead into a cycle.\n        The entrance to this cycle is the duplicate number.\n\n        Args:\n            arr: A numpy array of length N+1 containing integers in [1,N].\n\n        Returns:\n            The duplicate integer value.\n        \"\"\"\n        # Phase 1: Find the intersection point of the two runners.\n        # Tortoise moves one step at a time. Hare moves two steps.\n        tortoise = arr[0]\n        hare = arr[arr[0]]\n        while tortoise != hare:\n            tortoise = arr[tortoise]\n            hare = arr[arr[hare]]\n\n        # Phase 2: Find the entrance to the cycle.\n        # Move one pointer to the start of the list (index 0) and keep the other at the\n        # intersection point. Move them both one step at a time until they meet.\n        # The meeting point is the start of the cycle, which is the duplicate number.\n        p1 = 0\n        p2 = tortoise\n        while p1 != p2:\n            p1 = arr[p1]\n            p2 = arr[p2]\n        \n        return p1\n\n    # Define the test cases from the problem statement.\n    test_suite = [\n        ([1, 3, 4, 2, 2, 5], 5),\n        ([1, 1], 1),\n        ([3, 1, 3, 4, 2, 5, 6], 6),\n        ([7, 2, 4, 3, 5, 6, 1, 7], 7),\n        ([1, 5, 4, 3, 2, 6, 7, 8, 9, 10, 5], 10),\n        ([2, 5, 1, 1, 4, 3, 6, 8, 7], 8)\n    ]\n\n    results = []\n    for arr_list, n_val in test_suite:\n        # Convert list to numpy array for processing.\n        arr_np = np.array(arr_list, dtype=int)\n        duplicate = find_duplicate(arr_np)\n        results.append(duplicate)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}