{
    "hands_on_practices": [
        {
            "introduction": "当我们需要在有限的内存空间内追踪特定范围内数字的出现情况时，一个非常巧妙的技巧是利用数组自身的索引。这个练习  挑战你在 $O(N)$ 时间和 $O(1)$ 额外空间内找到缺失的最小正整数。通过原地重排元素，你将学会如何将数组本身转变为一个高效的哈希表，从而优雅地解决问题。",
            "id": "3275160",
            "problem": "给定多个独立的测试用例，每个测试用例包含一个未排序的静态整数数组。对于每个数组，计算其中缺失的最小正整数。算法要求是，对于一个长度为 $N$ 的数组，您的方法必须在 $O(N)$ 时间内运行，并且除了给定的静态数组外，只使用 $O(1)$ 的额外空间。静态数组是一个固定长度、连续的内存块，支持常数时间的随机访问和原地更新。\n\n仅可使用以下基本原理：静态数组的定义和属性（常数时间的索引和赋值）、通过常数次赋值（包括元素交换）进行原地更新的概念，以及时间复杂度 $O(\\cdot)$ 和空间复杂度 $O(\\cdot)$ 的标准定义。不得调整数组大小，不得分配与 $N$ 成正比的辅助数组，也不得使用大小依赖于 $N$ 的哈希结构。\n\n实现一个程序，将您的算法应用于以下数组测试套件：\n- $[3,4,-1,1]$\n- $[1,1,0,-1,-2,2]$\n- $[1,2,3]$\n- $[-5,-1,-3]$\n- $[7,8,9,11,12]$\n- $[2,3,4,5,6,7]$\n- $[]$\n- $[2]$\n- $[1]$\n\n对于每个数组，答案是一个单独的整数：该数组中缺失的最小正整数。您的程序必须硬编码上述测试套件，不得读取任何输入，也不得写入任何无关的输出。\n\n最终输出格式：您的程序应生成单行输出，其中包含测试套件的结果，结果按顺序排列，以逗号分隔并用方括号括起来，例如 $[a,b,c,\\dots]$，其中每个条目是对应测试用例的整数结果。",
            "solution": "所述问题是有效的。这是一个来自计算机科学领域的、定义明确的算法挑战，其基础是静态数组的形式化属性和复杂度理论。该问题是自包含的、客观的，其约束条件虽然严格但可以实现。\n\n任务是在一个长度为 $N$ 的未排序静态数组中找到缺失的最小正整数。解决方案必须达到 $O(N)$ 的时间复杂度和 $O(1)$ 的空间复杂度（常数额外空间）。\n\n高效解决方案的核心原理在于一个观察：缺失的最小正整数必定在 $[1, N+1]$ 的范围内。如果数组包含从 $1$ 到 $N$ 的所有整数，答案就是 $N+1$。否则，答案是集合 $\\{1, 2, \\dots, N\\}$ 中未出现在数组里的最小整数。这一洞见极大地缩小了搜索空间。\n\n在 $O(1)$ 空间复杂度的约束下，我们不能使用哈希表或大小为 $N$ 的布尔数组等辅助数据结构来追踪数字是否存在。我们必须重用输入数组本身来存储这些信息。策略是将数组的索引视为一个哈希表，将值视为要放置的元素。具体来说，我们的目标是对于数组中所有存在的整数 $k \\in \\{1, \\dots, N\\}$，都将其放置到索引 $k-1$ 的位置。\n\n该算法分为两个主要阶段进行：\n\n**阶段 1：原地循环放置**\n\n此阶段的目标是重新排列数组，使得如果整数 $k$（其中 $1 \\le k \\le N$）存在，它将被移动到索引 $k-1$ 的位置。\n\n我们从索引 $i=0$ 到 $N-1$ 遍历数组。对于每个元素 $A[i]$，我们检查它的值（可称之为 $v$）。一个内部的 `while` 循环用于处理 $v$ 的放置：\n1.  仅当值 $v = A[i]$ 落在有效范围，即 $1 \\le v \\le N$ 内时，它才是可被放置的候选值。\n2.  为防止存在重复值时出现无限循环，我们还必须确保值 $v$ 尚未在其目标位置。值 $v$ 的目标位置是索引 $v-1$，该位置应包含值 $v$。因此，只有当 $A[v-1] \\neq v$ 时才应进行交换。\n\n如果两个条件都满足（$1 \\le A[i] \\le N$ 且 $A[A[i]-1] \\neq A[i]$），我们就将元素 $A[i]$ 与其目标索引 $A[A[i]-1]$ 处的元素交换。交换后，索引 $i$ 处的元素是新的，我们必须在内部 `while` 循环中对其重新评估。这个循环过程会一直持续，直到 $A[i]$ 处的值不再是移动的候选对象（原因可能是它超出了 $[1, N]$ 的范围，或者它是一个已被正确放置的值的副本）。\n\n此阶段的时间复杂度为 $O(N)$。虽然存在嵌套循环结构，但每次交换都至少将一个整数放置到其正确的最终位置。一个整数一旦到达其正确索引，就不会再被移动。由于最多有 $N$ 个整数需要放置，因此在所有外层循环迭代中，交换的总数以 $N$ 为界。\n\n**阶段 2：首次不匹配检测**\n\n放置阶段结束后，数组已被重新排列。对于任何整数 $k \\in \\{1, \\dots, N\\}$，如果 $k$ 存在于原始数组中，那么现在就有 $A[k-1] = k$。在与缺失整数对应的位置上，可能存在“垃圾”值（负数、零或大于 $N$ 的数）。\n\n我们对修改后的数组进行一次从索引 $j = 0$ 到 $N-1$ 的线性扫描。我们检查是否有 $A[j] = j+1$。第一个不满足此条件（$A[j] \\neq j+1$）的索引 $j$ 告诉我们，$j+1$ 就是原始数组中缺失的最小正整数。然后我们就可以返回 $j+1$。\n\n如果循环完成而没有发现任何此类不匹配，则意味着对于每一个 $j \\in [0, N-1]$，我们都发现 $A[j] = j+1$。这意味着数组包含了从 $1$ 到 $N$ 的所有整数。在这种情况下，缺失的最小正整数是 $N+1$。\n\n这种两阶段方法能够正确识别缺失的最小正整数，同时严格遵守 $O(N)$ 时间和 $O(1)$ 空间复杂度的要求。它能正确处理各种边缘情况，例如空数组、全为负数的数组、包含重复值的数组以及已经排好序的数组。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the smallest missing positive integer for a list of test cases,\n    adhering to O(N) time and O(1) space complexity.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # We convert them to numpy arrays to better model the concept of a 'static array'.\n    test_cases_lists = [\n        [3,4,-1,1],\n        [1,1,0,-1,-2,2],\n        [1,2,3],\n        [-5,-1,-3],\n        [7,8,9,11,12],\n        [2,3,4,5,6,7],\n        [],\n        [2],\n        [1],\n    ]\n    \n    test_cases = [np.array(tc, dtype=np.int64) for tc in test_cases_lists]\n\n    results = []\n    for nums in test_cases:\n        result = find_smallest_missing_positive(nums)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef find_smallest_missing_positive(nums: np.ndarray) - int:\n    \"\"\"\n    Finds the smallest missing positive integer in a static array.\n    The algorithm rearranges the array in-place to use indices as a hash map.\n\n    Args:\n        nums: A numpy array of integers. The array is modified in-place.\n\n    Returns:\n        The smallest positive integer not present in the array.\n    \"\"\"\n    n = nums.size\n\n    # Phase 1: In-place cyclical placement.\n    # The goal is to place each number k (in [1, n]) at index k-1.\n    for i in range(n):\n        # Continue swapping nums[i] into its correct place as long as it's a\n        # valid candidate and not already in its correct place.\n        # Condition 1: The value must be in the range [1, n].\n        # Condition 2: The value at the target index must not already be the correct value.\n        # This prevents infinite loops on duplicate entries.\n        while 1 = nums[i] = n and nums[nums[i] - 1] != nums[i]:\n            target_idx = nums[i] - 1\n            # Swap the current number to its correct position.\n            nums[i], nums[target_idx] = nums[target_idx], nums[i]\n\n    # Phase 2: Find the first missing positive.\n    # After rearrangement, the first index i where nums[i] != i + 1\n    # indicates that i + 1 is the smallest missing positive number.\n    for i in range(n):\n        if nums[i] != i + 1:\n            return i + 1\n    \n    # If the loop completes, it means all integers from 1 to n were present.\n    # The smallest missing positive is therefore n + 1.\n    return n + 1\n\nsolve()\n```"
        },
        {
            "introduction": "如果问题约束更严格，甚至不允许修改数组呢？这个实践  将引导你进行一次深刻的思维转变：将数组不仅仅看作一个数据容器，而是看作一个函数映射或一个“函数图”。通过追踪从索引到其存储值的“链接”，你将发现一个隐藏的循环结构，并利用图论中的经典环检测算法来找出重复的数字，全程无需修改原始数据。",
            "id": "3275310",
            "problem": "考虑一个静态数组，其被定义为一个固定大小的、支持常数时间随机访问的连续内存块，其中存储整数，且一旦构造后不允许任何原地修改。假设存在一个长度为 $N+1$ 的数组，其包含的整数被限制在闭区间 $[1,N]$ 内。根据定义，静态数组不允许元素插入、删除或值更改；只允许读取操作。任务是确定一个由于基数约束而必然存在的重复值，要求不修改数组、仅使用常数额外空间，并在一个以 $N$ 的线性函数为上界的时间内执行。\n\n用于推理和设计的基本事实：\n- 鸽巢原理：如果将 $N+1$ 个物品放入 $N$ 个容器中，则至少有一个容器中包含至少2个物品。\n- 一个长度为 $N+1$、条目在 $[1,N]$ 范围内的静态数组可以被视为一个从索引到值的函数 $f$，其中对于索引 $i$ 和数组 $A$，有 $f(i)=A[i]$。\n- 在一个每个节点的出度都为1的有向函数图中，任何足够长的遍历最终必然会进入一个环。\n\n设计一个程序，给定若干个这样的静态数组，为每个数组返回其重复值，要求使用常数额外空间且不改变任何数组。该程序必须完全自包含，且不得从任何外部源读取输入。它必须处理以下测试套件，并以指定的最终输出格式生成结果。\n\n待处理的测试套件数组，每个都符合约束条件：\n- 数组 $A_1 = [1,3,4,2,2,5]$，其中 $N=5$。\n- 数组 $A_2 = [1,1]$，其中 $N=1$。\n- 数组 $A_3 = [3,1,3,4,2,5,6]$，其中 $N=6$。\n- 数组 $A_4 = [7,2,4,3,5,6,1,7]$，其中 $N=7$。\n- 数组 $A_5 = [1,5,4,3,2,6,7,8,9,10,5]$，其中 $N=10$。\n- 数组 $A_6 = [2,5,1,1,4,3,6,8,7]$，其中 $N=8$。\n\n对于每个数组 $A_i$，要求的输出是一个在 $[1,N]$ 范围内的整数，该整数等于 $A_i$ 中的重复值。\n\n最终输出格式：\n你的程序应生成一行输出，其中包含一个逗号分隔的列表，用方括号括起来，按 $A_1$ 到 $A_6$ 的顺序排列结果，例如 $[r_1,r_2,r_3,r_4,r_5,r_6]$，其中每个 $r_i$ 是为数组 $A_i$ 找到的整数重复值。",
            "solution": "问题陈述被评估为有效。它在离散数学和算法理论的原理上具有科学依据，提法明确，具有足够的约束条件以得出唯一的算法解，并以客观、形式化的语言表达。所有提供的数据和约束都是自洽且可形式化的。\n\n任务是在一个长度为 $N+1$ 的静态数组 $A$ 中找到一个重复的整数，其元素取自集合 $\\{1, 2, \\dots, N\\}$。解决方案的运行时间必须是 $N$ 的线性时间，使用常数额外空间，并且不修改输入数组。\n\n至少存在一个重复值由鸽巢原理保证。我们有 $N+1$ 个物品（数组 $A$ 的元素）要放入 $N$ 个容器（从 $1$ 到 $N$ 的可能整数值）。因此，至少有一个值必须出现一次以上。\n\n所提供的约束引导我们走向一个基于函数图中环检测的算法。让我们将数组建模为一个有向图，其中节点是数组的索引 $\\{0, 1, \\dots, N\\}$。从每个索引 $i$ 到由值 $A[i]$ 指定的索引存在一条有向边。由于在标准实现中数组索引是基于0的，我们必须精确地定义映射关系。数组值的范围是 $[1, N]$，这些都是集合 $\\{0, 1, \\dots, N\\}$ 内的有效索引。因此，我们可以定义一个后继函数 $s(i) = A[i]$，它将一个索引 $i$ 映射到一个后继索引 $A[i]$。\n\n这个函数图的结构是关键。节点集为 $V = \\{0, 1, \\dots, N\\}$，这是一个基数为 $N+1$ 的集合。由数组中的值决定的可能的后继节点集为 $A[V] \\subseteq \\{1, 2, \\dots, N\\}$。这意味着图中没有边指向节点 $0$。因此，与索引 $0$ 对应的节点入度必须为 $0$。\n\n任何入度为 $0$ 的节点都不可能成为环的一部分。因此，节点 $0$ 必须是某个不属于环的路径的起点。由于图是有限的，任何从节点 $0$ 开始的路径最终都必须进入一个环。这种结构，即一条路径进入一个环，被称为 rho形 ($\\rho$)。\n\n找到重复值的算法利用了这种结构，应用了 Floyd 的“龟兔赛跑”环检测算法。让我们从节点 $0$ 开始追踪索引序列：$x_0 = 0$，$x_1 = A[x_0]$，$x_2 = A[x_1]$，依此类推，有 $x_{k+1} = A[x_k]$。该算法分两个阶段进行。\n\n阶段1：在环内找到一个交点。\n我们使用两个指针，一个“乌龟”($t$) 和一个“兔子”($h$)。两者都从索引 $0$ 开始。在每一步中，乌龟前进一个位置（$t \\to A[t]$），而兔子前进两个位置（$h \\to A[A[h]]$）。由于从 $0$ 开始的序列会进入一个环，移动更快的兔子最终会追上乌龟。它们保证会在环内的某个索引处相遇。\n\n设 $t_0 = 0$ 且 $h_0 = 0$。\n位置序列为：\n$t_{k+1} = A[t_k]$\n$h_{k+1} = A[A[h_k]]$\n\n我们迭代直到对于某个 $k  0$ 有 $t_k = h_k$。设这个相遇索引为 $m$。\n\n阶段2：找到环的入口。\nFloyd 算法背后的理论指出，从起始节点（$0$）到环入口的初始路径长度等于从相遇点（$m$）到环入口的距离（以环的长度为模）。因此，为了找到环的入口，我们将一个指针（$p_1$）重置到起点（$0$），并将另一个指针（$p_2$）保持在相遇点（$m$）。然后我们同时将两个指针每次前进一步（$p_1 \\to A[p_1]$ 和 $p_2 \\to A[p_2]$）。它们相遇的索引就是环的第一个节点。\n\n设 $p_{1,0} = 0$ 且 $p_{2,0} = m$。\n位置序列为：\n$p_{1, k+1} = A[p_{1,k}]$\n$p_{2, k+1} = A[p_{2,k}]$\n\n我们迭代直到 $p_{1,k} = p_{2,k}$。这个公共索引就是环的入口。设这个入口索引为 $d$。\n\n理由：为什么环的入口索引是重复值？\n设环的入口是索引 $d$。根据其作为从 $0$ 开始的路径的环入口的定义，路径上必须存在一个前驱索引 $p$ 使得 $A[p] = d$。由于 $d$ 也是环的一部分，因此必须存在另一个属于环的前驱索引 $q$，使得 $A[q] = d$。索引 $p$ 在非环路径上，而 $q$ 在环中。因此，$p \\neq q$。我们找到了两个不同的索引 $p$ 和 $q$，它们都映射到值 $d$。这意味着 $A[p] = A[q] = d$，因此，值 $d$ 就是我们寻找的重复值。\n\n此算法满足所有要求：\n1.  它是非破坏性的，只对数组执行读取操作。\n2.  它使用常数额外空间存储少数指针变量（$t, h, p_1, p_2$）。\n3.  其时间复杂度是线性的，因为算法的两个阶段遍历的节点数都与路径和环的长度成比例，而这个长度的上界是 $N+1$。\n\n实现将遵循这两个阶段，为每个给定的数组找到环的入口索引，该索引即对应重复值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of finding a duplicate number in a static array.\n    \"\"\"\n\n    def find_duplicate(arr: np.ndarray) - int:\n        \"\"\"\n        Finds a duplicate number in a static array using Floyd's Tortoise and Hare algorithm.\n\n        The array is modeled as a functional graph where indices are nodes and the\n        value at an index is the pointer to the next node. The problem constraints\n        (array of length N+1 with values in [1,N]) guarantee that index 0 has an\n        in-degree of 0, serving as the start of a path that must lead into a cycle.\n        The entrance to this cycle is the duplicate number.\n\n        Args:\n            arr: A numpy array of length N+1 containing integers in [1,N].\n\n        Returns:\n            The duplicate integer value.\n        \"\"\"\n        # Phase 1: Find the intersection point of the two runners.\n        # Tortoise moves one step at a time. Hare moves two steps.\n        tortoise = arr[0]\n        hare = arr[arr[0]]\n        while tortoise != hare:\n            tortoise = arr[tortoise]\n            hare = arr[arr[hare]]\n\n        # Phase 2: Find the entrance to the cycle.\n        # Move one pointer to the start of the list (index 0) and keep the other at the\n        # intersection point. Move them both one step at a time until they meet.\n        # The meeting point is the start of the cycle, which is the duplicate number.\n        p1 = 0\n        p2 = tortoise\n        while p1 != p2:\n            p1 = arr[p1]\n            p2 = arr[p2]\n        \n        return p1\n\n    # Define the test cases from the problem statement.\n    test_suite = [\n        ([1, 3, 4, 2, 2, 5], 5),\n        ([1, 1], 1),\n        ([3, 1, 3, 4, 2, 5, 6], 6),\n        ([7, 2, 4, 3, 5, 6, 1, 7], 7),\n        ([1, 5, 4, 3, 2, 6, 7, 8, 9, 10, 5], 10),\n        ([2, 5, 1, 1, 4, 3, 6, 8, 7], 8)\n    ]\n\n    results = []\n    for arr_list, n_val in test_suite:\n        # Convert list to numpy array for processing.\n        arr_np = np.array(arr_list, dtype=int)\n        duplicate = find_duplicate(arr_np)\n        results.append(duplicate)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "许多数组问题的计算都同时依赖于局部信息和全局边界。这个模拟雨水收集的练习  是展示“双指针”技术的绝佳范例。通过从数组两端向中心智能地移动两个指针，你可以在一次遍历中解决问题，高效地处理不断变化的边界条件，这是处理类似问题的一种强大模式。",
            "id": "3275269",
            "problem": "设一个长度为 $n$ 的静态数组 $A$ 表示一维海拔景观，其中每个条目 $A[i]$ 是一个非负整数，表示在索引 $i$ 处由单位单元格构成的不透水垂直柱体的高度，柱体宽度统一为一个单位单元格。一场均匀的降雨发生后，水在柱体之间形成的凹陷处积聚，直到达到静水力平衡。在平衡状态下，水不能穿过柱体，不能从内部柱体间逃逸，并且可以从数组的最外两端 ($A[0]$ 和 $A[n-1]$) 自由溢出。计算柱体上方容纳的水的总单位单元格数量，假设重力垂直作用，且有水的地方水面是水平的。\n\n只能使用固定大小静态数组上可用的操作：基于索引的读取、向辅助变量进行基于索引的写入以及比较。你可以假设 $n$ 是一个整数且 $n \\ge 1$，所有高度都是整数且 $A[i] \\ge 0$，并且在该模型下景观是物理上合理的。\n\n你的程序必须处理以下静态数组测试套件，并为每个数组输出以单位单元格计量的总积水体积（一个整数）：\n\n- $[0,1,0,2,1,0,1,3,2,1,2,1]$\n- $[1,2,3,4]$\n- $[4,3,2,1]$\n- $[0,0,0,0,0]$\n- $[5,0,0,0,5]$\n- $[3,0,2,0,4]$\n\n最终输出格式要求为单行，包含按顺序排列的结果，形式为方括号括起来的逗号分隔列表，例如 $[r_1,r_2,\\dots,r_6]$，其中每个 $r_k$ 是第 $k$ 个测试用例的整数总积水量。不应打印任何其他文本。",
            "solution": "## 问题验证\n\n### 步骤 1：提取已知条件\n- 数据结构：一个长度为 $n$ 的静态数组 $A$。\n- 数组条目：$A[i]$ 是表示海拔的非负整数。\n- 几何：由宽度统一为一个单位单元格的垂直柱体构成的一维景观。\n- 物理模型：\n    - 均匀降雨导致积水。\n    - 系统达到静水力平衡。\n    - 柱体不透水。\n    - 水可以从数组的最外两端（$A[0]$ 和 $A[n-1]$）自由溢出。\n    - 水不能从内部柱体间逃逸。\n    - 重力垂直作用。\n    - 有水的地方水面是水平的。\n- 任务：计算柱体上方容纳的水的总单位单元格数量。\n- 约束：\n    - 允许的操作：基于索引的读取、向辅助变量进行基于索引的写入、比较。\n    - $n \\ge 1$ 且为整数。\n    - $A[i] \\ge 0$ 且为整数。\n    - 景观在所描述的模型下是物理上合理的。\n- 测试用例：\n    1. $[0,1,0,2,1,0,1,3,2,1,2,1]$\n    2. $[1,2,3,4]$\n    3. $[4,3,2,1]$\n    4. $[0,0,0,0,0]$\n    5. $[5,0,0,0,5]$\n    6. $[3,0,2,0,4]$\n- 输出格式：单行，结果为方括号括起来的逗号分隔列表：$[r_1,r_2,\\dots,r_6]$。\n\n### 步骤 2：使用提取的已知条件进行验证\n根据验证标准评估问题陈述。\n\n- **科学性：** 问题描述了一个简化但物理上一致的离散系统静水力平衡模型。不透水障碍物、水平水面以及水从边缘溢出等假设是用于构建易于处理的物理模型的标准理想化方法。问题不含伪科学，并遵循基本的物理原理。\n- **良构性：** 问题是良构的。关于蓄水的规则（由相邻更高的墙体约束以及从两端溢出）唯一地决定了景观中每个点的最终水位。这保证了对于任何给定的输入数组 $A$，都存在一个单一、稳定且有意义的解。\n- **客观性：** 问题以客观和精确的语言表述。所有量（$A[i]$、$n$、单位单元格）都有明确定义，目标是明确计算总水量。\n\n该问题不存在任何无效性缺陷：\n1.  **科学/事实不健全：** 无。该模型是一个有效的物理抽象。\n2.  **不可形式化/不相关：** 无。该问题是一个经典的算法挑战，可直接形式化，且与静态数组的主题相关。\n3.  **不完整/矛盾的设置：** 无。所有必要条件（$n \\ge 1$、$A[i] \\ge 0$、边界条件）都已提供且相互一致。\n4.  **不切实际/不可行：** 无。该模型是一种理想化，但并非物理上不可能或科学上不合理。数据是一致的。\n5.  **不适定/结构不良：** 无。存在唯一解，且所有术语都定义明确。\n6.  **伪深刻/琐碎：** 无。这个问题，通常被称为“接雨水”，是一个需要仔细推理数组局部和全局属性的非平凡算法设计练习。\n7.  **超出科学可验证范围：** 无。任何给定输入的解都是确定性可计算和可验证的。\n\n### 步骤 3：结论与行动\n该问题是 **有效的**。将提供一个解决方案。\n\n## 解决方案\n\n### 基于原理的设计\n问题是计算由长度为 $n$ 的静态数组 $A$ 表示的一维海拔图中积存的水量。其基本物理原理是，特定位置的水只能积聚到由周围地形限制的高度。\n\n对于任何给定的位置 $i$（其中 $0  i  n-1$），水位受到其周围不透水柱体高度的限制。由于水可以从数组的两端溢出，只有当一个水坑在景观中的左右两侧都被更高的柱体所包围时，它才能形成。\n\n让我们将其形式化。对于索引为 $i$、高度为 $A[i]$ 的任何柱体，其上方所能维持的最大水位 $h_i$ 由其左侧最高的柱体和其右侧最高的柱体决定。令 $L_i = \\max_{0 \\le j \\le i} A[j]$ 为从索引 $0$ 到 $i$ 的子数组中的最大柱体高度，令 $R_i = \\max_{i \\le j  n} A[j]$ 为从索引 $i$ 到 $n-1$ 的子数组中的最大高度。索引 $i$ 处的水面将是水平的，并将受到这两个周围峰值中较低者的限制。因此，水位 $h_i$ 由以下公式给出：\n$$ h_i = \\min(L_i, R_i) $$\n在索引 $i$ 的柱体*上方*积存的水量，记为 $V_i$，是该水位与柱体本身高度之间的差。由于水量不能为负，我们有：\n$$ V_i = \\max(0, h_i - A[i]) = \\max(0, \\min(L_i, R_i) - A[i]) $$\n请注意，根据 $L_i$ 和 $R_i$ 的定义，它们都大于或等于 $A[i]$，因此 $\\min(L_i, R_i) \\ge A[i]$，确保 $V_i \\ge 0$。\n\n总积水体积 $V$ 是每个独立柱体上方体积的总和：\n$$ V = \\sum_{i=0}^{n-1} V_i = \\sum_{i=0}^{n-1} (\\min(L_i, R_i) - A[i]) $$\n\n基于此公式的直接计算效率不高。一个更高效的算法可以通过认识到对每个单元格，我们只需要其左侧和右侧的最大高度来设计。一种朴素的实现方式是预先计算两个辅助数组，一个用于从左侧开始的最大值，一个用于从右侧开始的最大值，两者都在 $O(n)$ 时间内完成。然后可以在最后的 $O(n)$ 遍历中计算出总体积。这种方法的时间复杂度为 $O(n)$，空间复杂度为 $O(n)$。\n\n一个最优算法可以使用双指针方法，以 $O(1)$ 的辅助空间复杂度达到相同结果。我们定义一个从索引 $0$ 开始的指针 `left` 和一个从索引 $n-1$ 开始的指针 `right`。我们还维护两个变量 `max_l` 和 `max_r`，它们分别存储从左端和右端到目前为止遇到的最大高度。\n\n算法通过向内移动指针来进行：\n1. 初始化 `left = 0`，`right = n-1`，`max_l = 0`，`max_r = 0`，以及 `total_water = 0`。\n2. 当 `left  right` 时：\n   a. 比较两个指针处的高度，$A[\\text{left}]$ 和 $A[\\text{right}]$。\n   b. 如果 $A[\\text{left}] \\le A[\\text{right}]$：\n      `left` 位置的水位保证受限于左侧的最大高度 `max_l`，因为我们知道其右侧有一个高度至少为 $A[\\text{right}]$（即 $\\ge A[\\text{left}]$）的墙。我们更新 `max_l = \\max(\\text{max\\_l}, A[\\text{left}])$，并将该位置的积水量 $\\text{max\\_l} - A[\\text{left}]$ 加到我们的总和中。然后，我们增加 `left`。\n   c. 如果 $A[\\text{left}] > A[\\text{right}]$：\n      一个对称的论证适用。`right` 位置的水位受限于 `max_r`。我们更新 `max_r = \\max(\\text{max\\_r}, A[\\text{right}])$，并将 $\\text{max\\_r} - A[\\text{right}]$ 加到总水量中。然后，我们减少 `right`。\n3. 当 `left` 和 `right` 相遇或交错时，循环终止。累积的 `total_water` 就是最终结果。\n\n这种双指针方法每个元素只处理一次，因此时间复杂度为 $O(n)$，同时只使用常数数量的辅助变量，空间复杂度为 $O(1)$。这是满足问题约束的最有效方法。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the trapping rain water problem for a given suite of test cases.\n    \"\"\"\n\n    test_cases = [\n        np.array([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]),\n        np.array([1, 2, 3, 4]),\n        np.array([4, 3, 2, 1]),\n        np.array([0, 0, 0, 0, 0]),\n        np.array([5, 0, 0, 0, 5]),\n        np.array([3, 0, 2, 0, 4]),\n    ]\n\n    def calculate_trapped_water(height: np.ndarray) - int:\n        \"\"\"\n        Calculates the total volume of trapped water using a two-pointer approach.\n\n        This algorithm achieves O(n) time complexity and O(1) space complexity.\n\n        Args:\n            height: A numpy array of non-negative integers representing the elevation map.\n\n        Returns:\n            The total number of unit cells of water trapped.\n        \"\"\"\n        n = height.shape[0]\n        if n  3:\n            return 0\n\n        left, right = 0, n - 1\n        max_l, max_r = 0, 0\n        total_water = 0\n\n        while left  right:\n            # If the left column is shorter or equal to the right one\n            if height[left] = height[right]:\n                # The water level at 'left' is primarily determined by the max height\n                # seen from the left, because we know there's a boundary on the right\n                # that is at least as high as height[left].\n                if height[left] > max_l:\n                    # This column is a new left-side boundary, no water can be trapped above it.\n                    max_l = height[left]\n                else:\n                    # Water is trapped. The depth is max_l - height[left].\n                    total_water += max_l - height[left]\n                left += 1\n            else: # height[left] > height[right]\n                # Symmetrical case for the right pointer.\n                # The water level at 'right' is determined by max_r.\n                if height[right] > max_r:\n                    # New right-side boundary.\n                    max_r = height[right]\n                else:\n                    # Water is trapped. The depth is max_r - height[right].\n                    total_water += max_r - height[right]\n                right -= 1\n        \n        return int(total_water)\n\n    results = []\n    for case in test_cases:\n        result = calculate_trapped_water(case)\n        results.append(result)\n\n    # Final print statement must match the exact specified format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}