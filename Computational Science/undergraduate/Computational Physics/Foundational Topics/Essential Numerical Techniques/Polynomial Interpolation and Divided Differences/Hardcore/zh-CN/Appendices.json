{
    "hands_on_practices": [
        {
            "introduction": "本练习提供了一个牛顿插值法的基础应用。我们将利用离散的数据点，例如那些来自散射实验的数据点，并使用多项式来估计中间点的值。这是分析实验数据的一项核心技能，因为在实验中，测量通常只能在特定的间隔上进行()。",
            "id": "2428275",
            "problem": "一个散射实验报告了在若干极角 $\\theta$（角度单位：弧度）处测得的微分截面 $\\sigma(\\theta)$ 的离散测量值，单位为靶/球面度 (barn/sr)。假设在每种情况下，$\\sigma(\\theta)$ 在给定数据所覆盖的角度区间内足够光滑，请通过计算对每个案例中能精确拟合所提供数据点的唯一最小次数多项式，来确定 $\\sigma(\\pi/2)$ 的插值估计值。角度必须以弧度为单位进行处理和计算。最终的插值结果必须以靶/球面度为单位表示，并四舍五入到 $10$ 位小数。\n\n使用以下三个独立的测试用例。在每个用例中，输入包含一个严格递增的角度列表 $\\{\\theta_i\\}$（单位为弧度）和相应的测量截面值 $\\{\\sigma_i\\}$（单位为靶/球面度）。对每个用例，计算 $\\sigma(\\pi/2)$ 的插值估计值（单位为靶/球面度）。\n\n测试用例 A（常规内部插值）：\n- 角度 $\\{\\theta_i\\}$：$\\{0.5,\\,1.2,\\,2.0\\}$ 弧度。\n- 截面 $\\{\\sigma_i\\}$：$\\{12.2,\\,10.1,\\,7.3\\}$ 靶/球面度。\n\n测试用例 B（目标角度作为数据节点，用于在精确算术中进行精确匹配）：\n- 角度 $\\{\\theta_i\\}$：$\\{0.2,\\,1.0,\\,1.5707963267948966,\\,2.4\\}$ 弧度。\n- 截面 $\\{\\sigma_i\\}$：$\\{11.0,\\,10.0,\\,9.87654321,\\,7.0\\}$ 靶/球面度。\n\n测试用例 C（具有更多节点的非均匀间距）：\n- 角度 $\\{\\theta_i\\}$：$\\{0.1,\\,0.9,\\,1.3,\\,1.8,\\,2.5\\}$ 弧度。\n- 截面 $\\{\\sigma_i\\}$：$\\{15.0,\\,11.0,\\,9.5,\\,8.2,\\,6.0\\}$ 靶/球面度。\n\n您的程序必须：\n- 对每个用例，构建一个次数最多为 $n-1$ 的唯一多项式，该多项式插值于 $n$ 个给定的数据点 $(\\theta_i,\\sigma_i)$。\n- 在 $\\theta=\\pi/2$ 弧度处计算该多项式的值。\n- 将每个结果值四舍五入到 $10$ 位小数。\n- 生成单行输出，其中包含用例 A、B、C 的结果，按此顺序排列，形式为逗号分隔的列表并用方括号括起，例如 $[\\text{result}_A,\\text{result}_B,\\text{result}_C]$。\n\n角度单位：弧度。截面必须以靶/球面度 (barn/sr) 为单位报告，并四舍五入到 $10$ 位小数。最终输出必须是严格符合上述格式的单行文本。",
            "solution": "问题陈述已经过验证，并被认定为有效。它具有计算物理的科学依据，在数学上是适定的，并且是一个客观定义的多项式插值问题。三个测试用例所需的全部数据和条件都已提供，且无内部矛盾。因此，我将继续提供完整的解决方案。\n\n目标是针对三个独立的数据集，估计在特定极角 $\\theta = \\pi/2$ 弧度处的微分截面 $\\sigma(\\theta)$。指定的方法是使用通过给定数据点 $(\\theta_i, \\sigma_i)$ 的唯一最小次数插值多项式。对于一组 $n$ 个不同的点，这对应于次数最多为 $n-1$ 的唯一多项式。\n\n完成此任务的一种数值稳健且计算高效的方法是牛顿形式的插值多项式，它利用了均差。这种方法特别适用，因为它避免了通过范德蒙矩阵求解单项式基下的多项式系数时常出现的病态问题。\n\n给定一组 $n$ 个数据点 $(x_0, y_0), (x_1, y_1), \\dots, (x_{n-1}, y_{n-1})$，插值多项式 $P(x)$ 的牛顿形式由下式给出：\n$$ P(x) = \\sum_{k=0}^{n-1} c_k \\prod_{j=0}^{k-1} (x - x_j) $$\n其中系数 $c_k$ 是均差，定义为 $c_k = f[x_0, x_1, \\dots, x_k]$。它们通过递归计算：\n$$ f[x_i] = y_i $$\n$$ f[x_i, \\dots, x_{i+j}] = \\frac{f[x_{i+1}, \\dots, x_{i+j}] - f[x_i, \\dots, x_{i+j-1}]}{x_{i+j} - x_i} $$\n系数 $c_k$ 是均差表的顶部对角线项。一旦确定了这些系数，就可以使用霍纳（Horner）方法在点 $x_{\\text{eval}}$ 处高效地计算多项式的值：\n$$ P(x_{\\text{eval}}) = c_{n-1}(x_{\\text{eval}} - x_{n-2}) + c_{n-2})(x_{\\text{eval}} - x_{n-3}) + \\dots)(x_{\\text{eval}} - x_0) + c_0 $$\n这个表达式从内向外求值，或者在实现中更常见的是迭代计算：\n令 $val = c_{n-1}$。\n对于从 $n-2$ 到 $0$ 的 $i$：$val = val \\cdot (x_{\\text{eval}} - x_i) + c_i$。\n最终的 $val$ 即为 $P(x_{\\text{eval}})$。\n\n现在，我们将此过程应用于每个测试用例，其中 $\\theta$ 对应于 $x$，$\\sigma(\\theta)$ 对应于 $y$。目标角度为 $\\theta_{\\text{eval}} = \\pi/2$。\n\n测试用例 A：\n提供的数据是 $n=3$ 个点：\n- 角度 $\\{\\theta_i\\}: \\{0.5, 1.2, 2.0\\}$\n- 截面 $\\{\\sigma_i\\}: \\{12.2, 10.1, 7.3\\}$\n插值多项式的次数最多为 $3-1 = 2$。我们构建均差表：\n- 零阶均差：$f[\\theta_0] = 12.2$, $f[\\theta_1] = 10.1$, $f[\\theta_2] = 7.3$\n- 一阶均差：\n  - $f[\\theta_0, \\theta_1] = \\frac{10.1 - 12.2}{1.2 - 0.5} = \\frac{-2.1}{0.7} = -3.0$\n  - $f[\\theta_1, \\theta_2] = \\frac{7.3 - 10.1}{2.0 - 1.2} = \\frac{-2.8}{0.8} = -3.5$\n- 二阶均差：\n  - $f[\\theta_0, \\theta_1, \\theta_2] = \\frac{-3.5 - (-3.0)}{2.0 - 0.5} = \\frac{-0.5}{1.5} = -1/3$\n牛顿多项式的系数为 $c_0 = 12.2$，$c_1 = -3.0$ 和 $c_2 = -1/3$。我们在 $\\theta = \\pi/2$ 处计算该多项式的值：\n$P(\\pi/2) = c_2 \\cdot (\\pi/2 - \\theta_1) + c_1$\n$P(\\pi/2) = (P(\\pi/2)) \\cdot (\\pi/2 - \\theta_0) + c_0$\n数值计算得出：\n$P(\\pi/2) = (-1/3) \\cdot (\\pi/2 - 1.2) - 3.0$\n$P(\\pi/2) = ((-1/3) \\cdot (\\pi/2 - 1.2) - 3.0) \\cdot (\\pi/2 - 0.5) + 12.2 \\approx 8.8552689974$。\n\n测试用例 B：\n提供的数据是 $n=4$ 个点：\n- 角度 $\\{\\theta_i\\}: \\{0.2, 1.0, 1.5707963267948966, 2.4\\}$\n- 截面 $\\{\\sigma_i\\}: \\{11.0, 10.0, 9.87654321, 7.0\\}$\n插值的目标角度是 $\\theta = \\pi/2$。我们观察到第三个数据节点 $\\theta_2 = 1.5707963267948966$ 是 $\\pi/2$ 的浮点表示。根据定义，插值多项式必须精确地穿过所有给定的数据点。因此，对于所有 $i = 0, 1, 2, 3$，都有 $P(\\theta_i) = \\sigma_i$。\n因此，对于 $\\theta = \\theta_2 = \\pi/2$，多项式的值就是相应的截面值 $\\sigma_2$。\n$P(\\pi/2) = \\sigma_2 = 9.87654321$。无需进一步计算。\n\n测试用例 C：\n提供的数据是 $n=5$ 个点：\n- 角度 $\\{\\theta_i\\}: \\{0.1, 0.9, 1.3, 1.8, 2.5\\}$\n- 截面 $\\{\\sigma_i\\}: \\{15.0, 11.0, 9.5, 8.2, 6.0\\}$\n插值多项式的次数最多为 $5-1=4$。其过程与用例 A 相同，但适用于更多的数据点。我们计算均差以找到牛顿系数 $c_0, c_1, c_2, c_3, c_4$。\n- $c_0 = f[\\theta_0] = 15.0$\n- $c_1 = f[\\theta_0, \\theta_1] = -5.0$\n- $c_2 = f[\\theta_0, \\theta_1, \\theta_2] \\approx 1.0416666667$\n- $c_3 = f[\\theta_0, \\theta_1, \\theta_2, \\theta_3] \\approx 0.1388888889$\n- $c_4 = f[\\theta_0, \\theta_1, \\theta_2, \\theta_3, \\theta_4] \\approx -0.50843254$\n使用这些系数和霍纳方法来计算 $P(\\pi/2)$：\n$P(\\pi/2) = ((((c_4(\\pi/2 - \\theta_3) + c_3)(\\pi/2 - \\theta_2) + c_2)(\\pi/2 - \\theta_1) + c_1)(\\pi/2 - \\theta_0) + c_0)$\n此计算得出的值为 $P(\\pi/2) \\approx 8.9410183358$。\n\n根据要求，将用例 A、B 和 C 的最终结果四舍五入到 $10$ 位小数，分别为 $8.8552689974$、$9.87654321$ 和 $8.9410183358$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the polynomial interpolation problem for three test cases.\n    \"\"\"\n\n    # --- Test Cases ---\n    test_cases = [\n        # Case A: General interior interpolation\n        (np.array([0.5, 1.2, 2.0]), np.array([12.2, 10.1, 7.3])),\n        # Case B: Target angle is a data node\n        (np.array([0.2, 1.0, 1.5707963267948966, 2.4]), np.array([11.0, 10.0, 9.87654321, 7.0])),\n        # Case C: Nonuniform spacing with more nodes\n        (np.array([0.1, 0.9, 1.3, 1.8, 2.5]), np.array([15.0, 11.0, 9.5, 8.2, 6.0])),\n    ]\n\n    target_angle = np.pi / 2\n    results = []\n\n    def get_newton_coeffs(x_nodes: np.ndarray, y_nodes: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Computes the coefficients of the Newton form of the interpolating polynomial.\n        The algorithm computes the divided differences table in-place.\n        \"\"\"\n        n = len(x_nodes)\n        coeffs = np.copy(y_nodes).astype(float)\n        for k in range(1, n):\n            # To compute the k-th order differences, we need x distance of k\n            # coeffs[i] becomes f[x_{i-k}, ..., x_i]\n            for i in range(n - 1, k - 1, -1):\n                coeffs[i] = (coeffs[i] - coeffs[i - 1]) / (x_nodes[i] - x_nodes[i - k])\n        return coeffs\n\n    def eval_newton_poly(x_nodes: np.ndarray, coeffs: np.ndarray, x_eval: float) -> float:\n        \"\"\"\n        Evaluates the Newton polynomial at a given point using Horner's method.\n        \"\"\"\n        n = len(coeffs)\n        # Start from the highest order coefficient\n        result = coeffs[n - 1]\n        # Apply Horner's method\n        for i in range(n - 2, -1, -1):\n            result = result * (x_eval - x_nodes[i]) + coeffs[i]\n        return result\n\n    for x_nodes, y_nodes in test_cases:\n        # Check if the target angle is one of the nodes\n        # Use np.isclose for robust floating-point comparison\n        is_node, indices = np.isclose(x_nodes, target_angle), np.where(np.isclose(x_nodes, target_angle))\n        if np.any(is_node):\n            # If the target is a node, the interpolated value is the node's y-value\n            result = y_nodes[indices[0][0]]\n        else:\n            # Otherwise, perform Newton interpolation\n            coeffs = get_newton_coeffs(x_nodes, y_nodes)\n            result = eval_newton_poly(x_nodes, coeffs, target_angle)\n        \n        # Round the result to 10 decimal places\n        results.append(round(result, 10))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "许多物理量，例如交流电路的阻抗，都是复数值。本练习展示了均差法不仅限于实数，它同样适用于复平面。我们将对一个电子电路的复阻抗进行插值，将其实部和虚部作为一个统一的复数实体来处理()。",
            "id": "2428278",
            "problem": "你的任务是通过多项式插值来重构一个关于角频率的复值阻抗函数。该阻抗被定义为函数 $Z(\\omega) = R(\\omega) + i X(\\omega)$，其中 $\\omega$ 是角频率，单位为弧度/秒，$R(\\omega)$ 是实部（单位为欧姆），$X(\\omega)$ 是虚部（单位为欧姆），$i$ 表示虚数单位。目标是数值上构建一个在复数域上的唯一插值多项式，该多项式与一小组采样频率及其对应的复阻抗相匹配，然后在一系列指定的查询频率上计算该多项式的值。你必须使用基于复数域上差商构建的牛顿多项式插值方法。\n\n基本原理：使用以下定义：存在一个次数至多为 $n$ 的唯一多项式 $p\\_n(\\omega)$，它对 $n+1$ 个不同的样本 $\\{(\\omega\\_k, Z(\\omega\\_k))\\}$ 进行插值。将差商定义为与 $p\\_n(\\omega)$ 的唯一性相一致的递归定义的离散导数。根据复数域的代数规则处理复数值，并使用复数绝对值 $|z|$（其中 $z \\in \\mathbb{C}$）来量化误差。\n\n你的程序必须：\n- 使用 $\\mathbb{C}$ 上的差商为给定样本构建牛顿形式的插值多项式。\n- 在指定的查询角频率处计算该插值多项式的值。\n- 在所有提供的查询点上计算最大绝对误差大小 $E = \\max\\_j |Z\\_{\\mathrm{interp}}(\\omega\\_j) - Z\\_{\\mathrm{true}}(\\omega\\_j)|$（单位为欧姆）。\n- 将每个测试用例的最大误差 $E$ 报告为一个实数（单位为欧姆），并四舍五入到六位小数。\n\n所有角频率的单位都是弧度/秒。所有阻抗量的单位都是欧姆。角度不直接出现；不要进行单位转换。\n\n测试套件：\n- 测试用例 1（串联电阻-电感，恰好为1次多项式）：\n  - 真实阻抗：$Z(\\omega) = R + i \\,\\omega L$，其中 $R = 47\\,\\mathrm{\\Omega}$ 且 $L = 0.01\\,\\mathrm{H}$。\n  - 采样节点：$\\{\\omega\\_0,\\omega\\_1\\} = \\{100, 700\\}$。\n  - 查询点：$\\{150, 1000\\}$。\n  - 预期行为：由于 $Z(\\omega)$ 关于 $\\omega$ 是线性的，插值对于任何 $\\omega$ 都应是精确的；最大误差在舍入误差范围内应为数值上的0。\n- 测试用例 2（串联电阻-电感-电容，关于 $\\omega$ 非多项式）：\n  - 真实阻抗：$Z(\\omega) = R + i\\left(\\omega L - \\dfrac{1}{\\omega C}\\right)$，其中 $R = 10\\,\\mathrm{\\Omega}$，$L = 0.005\\,\\mathrm{H}$，$C = 20\\times 10^{-6}\\,\\mathrm{F}$。\n  - 采样节点：$\\{\\omega\\_0,\\omega\\_1,\\omega\\_2,\\omega\\_3,\\omega\\_4\\} = \\{100, 400, 700, 1000, 1300\\}$。\n  - 查询点：$\\{250, 450, 900, 1100\\}$。\n  - 预期行为：插值是一个近似；报告以欧姆为单位的最大绝对误差大小。\n- 测试用例 3（纯电容，单个样本的边界情况）：\n  - 真实阻抗：$Z(\\omega) = -\\dfrac{i}{\\omega C}$，其中 $C = 50\\times 10^{-6}\\,\\mathrm{F}$。\n  - 采样节点：$\\{\\omega\\_0\\} = \\{500\\}$。\n  - 查询点：$\\{250, 1000\\}$。\n  - 预期行为：插值函数是一个常数，等于在 $\\omega = 500$ 处的采样值，因此误差反映了常数插值函数与真实函数之间的偏差；报告以欧姆为单位的最大绝对误差大小。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含三个最大误差大小，每个都四舍五入到六位小数，形式为用方括号括起来的逗号分隔列表，即 $[e\\_1,e\\_2,e\\_3]$，其中每个 $e\\_k$ 的单位是欧姆，并且是格式化为小数点后六位的实数。",
            "solution": "所提出的问题是数值分析中的一个标准练习，具体来说是应用多项式插值来近似一个复值函数。任务是使用复数域 $\\mathbb{C}$ 上的差商来构建牛顿形式的插值多项式，并评估其准确性。对问题陈述进行彻底验证是强制性的第一步。\n\n### 第 1 步：提取给定信息\n- **目标**：使用牛顿多项式插值重构一个复值阻抗函数 $Z(\\omega) = R(\\omega) + i X(\\omega)$。\n- **方法**：使用 $\\mathbb{C}$ 上的差商来找到牛顿形式插值多项式的系数。\n- **评估指标**：在指定的查询频率上计算最大绝对误差 $E = \\max_j |Z_{\\mathrm{interp}}(\\omega_j) - Z_{\\mathrm{true}}(\\omega_j)|$。\n- **测试用例 1**：\n    - 真实函数：$Z(\\omega) = R + i \\,\\omega L$，其中 $R = 47\\,\\mathrm{\\Omega}$ 且 $L = 0.01\\,\\mathrm{H}$。\n    - 采样节点：$\\omega \\in \\{100, 700\\}$。\n    - 查询节点：$\\omega \\in \\{150, 1000\\}$。\n- **测试用例 2**：\n    - 真实函数：$Z(\\omega) = R + i\\left(\\omega L - \\dfrac{1}{\\omega C}\\right)$，其中 $R = 10\\,\\mathrm{\\Omega}$，$L = 0.005\\,\\mathrm{H}$ 且 $C = 20\\times 10^{-6}\\,\\mathrm{F}$。\n    - 采样节点：$\\omega \\in \\{100, 400, 700, 1000, 1300\\}$。\n    - 查询节点：$\\omega \\in \\{250, 450, 900, 1100\\}$。\n- **测试用例 3**：\n    - 真实函数：$Z(\\omega) = -\\dfrac{i}{\\omega C}$，其中 $C = 50\\times 10^{-6}\\,\\mathrm{F}$。\n    - 采样节点：$\\omega \\in \\{500\\}$。\n    - 查询节点：$\\omega \\in \\{250, 1000\\}$。\n- **输出格式**：一个包含三个最大误差值的列表 `[e_1, e_2, e_3]`，四舍五入到六位小数。\n\n### 第 2 步：使用提取的给定信息进行验证\n对问题进行严格验证。\n\n- **科学上成立**：该问题基于电气工程（RLC电路的阻抗）和数学（复数域上的多项式插值）的基本原理。所用的物理模型和数学方法都是成熟且事实合理的。根据此标准，该问题是有效的。\n- **适定的**：对于每个测试用例，不同采样节点的数量足以定义一个唯一的插值多项式。真实函数已指定，从而可以计算误差。问题提供了所有必要的数据并定义了明确的目标。它是适定的。\n- **客观的**：问题陈述使用了精确、无歧义的数学和物理术语。没有主观或基于观点的元素。该问题是客观的。\n\n该问题没有表现出任何诸如科学上不合理、有歧义或不完整等缺陷。元件值和频率在物理上是现实的。\n\n### 第 3 步：结论与行动\n问题被判定为**有效**。将构建一个解决方案。\n\n### 解决方案推导\n\n这个问题的基础是插值多项的存在性与唯一性。对于一组给定的 $n+1$ 个不同数据点 $\\{(\\omega_0, z_0), (\\omega_1, z_1), \\dots, (\\omega_n, z_n)\\}$，其中 $\\omega_k \\in \\mathbb{R}$ 是不同的采样频率，$z_k = Z(\\omega_k) \\in \\mathbb{C}$ 是对应的复阻抗，存在一个次数至多为 $n$ 的唯一多项式 $P_n(\\omega)$，使得对于所有 $k \\in \\{0, \\dots, n\\}$ 都有 $P_n(\\omega_k) = z_k$。\n\n我们采用该多项式的牛顿形式，其表达式为：\n$$\nP_n(\\omega) = \\sum_{k=0}^{n} c_k \\prod_{j=0}^{k-1} (\\omega - \\omega_j)\n$$\n其中对于 $k=0$ 的乘积项 $\\prod_{j=0}^{-1} (\\dots)$ 定义为 $1$。系数 $c_k$ 是递归定义的差商。所有算术运算都在复数域 $\\mathbb{C}$ 中执行。\n\n差商由以下公式给出：\n- 零阶：$c_0 = f[\\omega_0] = z_0$\n- $k$阶：$c_k = f[\\omega_0, \\omega_1, \\dots, \\omega_k]$\n通用的递归定义是：\n$$\nf[\\omega_i, \\dots, \\omega_j] = \\frac{f[\\omega_{i+1}, \\dots, \\omega_j] - f[\\omega_i, \\dots, \\omega_{j-1}]}{\\omega_j - \\omega_i}\n$$\n为了计算方便，我们构建一个差商表。系数 $c_k = f[\\omega_0, \\dots, \\omega_k]$ 构成了此表的顶部对角线。一个高效的算法逐列计算，只存储必要的中间值。\n\n一旦系数 $\\{c_0, c_1, \\dots, c_n\\}$ 被确定，多项式 $P_n(\\omega)$ 可以在任何查询点 $\\omega_{query}$ 使用嵌套形式进行求值，这是霍纳（Horner）方法的一种应用，以提高数值稳定性和效率：\n$$\nP_n(\\omega_{query}) = c_0 + (\\omega_{query} - \\omega_0)(c_1 + (\\omega_{query} - \\omega_1)(c_2 + \\dots + (\\omega_{query} - \\omega_{n-1})c_n)\\dots)\n$$\n求值过程从最内层项向外进行。\n\n在查询点 $\\omega_{query}$ 处的绝对误差计算为插值与真实值之差的模：\n$$\n\\text{Error} = |P_n(\\omega_{query}) - Z_{\\mathrm{true}}(\\omega_{query})|\n$$\n每个测试用例的最终结果是所有指定查询点上这些误差的最大值。\n\n**测试用例分析：**\n\n- **测试用例 1：** 真实阻抗函数 $Z(\\omega) = 47 + i(0.01)\\omega$ 是一个关于 $\\omega$ 的 1 次多项式。我们给定了两个不同的采样点 $(\\omega_0, \\omega_1) = (100, 700)$。穿过这两点的次数至多为 1 的唯一插值多项式必须是函数 $Z(\\omega)$ 本身。\n    - $z_0 = Z(100) = 47 + 1i$\n    - $z_1 = Z(700) = 47 + 7i$\n    - $c_0 = z_0 = 47 + 1i$\n    - $c_1 = \\frac{z_1 - z_0}{\\omega_1 - \\omega_0} = \\frac{(47 + 7i) - (47 + 1i)}{700 - 100} = \\frac{6i}{600} = 0.01i$\n    - $P_1(\\omega) = c_0 + c_1(\\omega - \\omega_0) = (47 + 1i) + 0.01i(\\omega - 100) = 47 + 1i + 0.01i\\omega - 1i = 47 + 0.01i\\omega$。\n    这与 $Z_{\\mathrm{true}}(\\omega)$ 完全相同。因此，在任何查询点上的误差都将是 $0$。最大误差 $E_1$ 必须为 $0$，仅受机器精度限制。\n\n- **测试用例 2：** 真实函数 $Z(\\omega) = 10 + i(\\omega L - 1/(\\omega C))$ 包含一个与 $1/\\omega$ 成比例的项，因此不是一个多项式。用一个 4 次多项式（因为有 5 个采样点）进行的插值将是一个近似。预计会产生误差。必须数值上执行所述算法来找到这个误差。\n\n- **测试用例 3：** 我们给定一个单个采样点 $(\\omega_0) = (500)$。插值多项式的次数必须至多为 $1-1=0$，这意味着它是一个常数。\n    - $z_0 = Z_{\\mathrm{true}}(500) = -\\dfrac{i}{500 \\times 50 \\times 10^{-6}} = -\\dfrac{i}{0.025} = -40i$。\n    - 插值多项式是 $P_0(\\omega) = z_0 = -40i$。\n    我们在查询点上计算误差：\n    - 在 $\\omega_{q1} = 250$ 处：\n        - $Z_{\\mathrm{interp}}(250) = -40i$。\n        - $Z_{\\mathrm{true}}(250) = -\\dfrac{i}{250 \\times 50 \\times 10^{-6}} = -80i$。\n        - 误差$_1 = |-40i - (-80i)| = |40i| = 40$。\n    - 在 $\\omega_{q2} = 1000$ 处：\n        - $Z_{\\mathrm{interp}}(1000) = -40i$。\n        - $Z_{\\mathrm{true}}(1000) = -\\dfrac{i}{1000 \\times 50 \\times 10^{-6}} = -20i$。\n        - 误差$_2 = |-40i - (-20i)| = |-20i| = 20$。\n    最大误差是 $E_3 = \\max(40, 20) = 40.0$。\n\n实现将精确地遵循这一逻辑，对所有情况使用数值计算。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef get_newton_coeffs(sample_nodes: np.ndarray, sample_values: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Computes the coefficients for Newton's divided difference interpolating polynomial.\n    This implementation uses an efficient, space-optimized algorithm that reuses a\n    single array to compute the coefficients, which are the top diagonal of the\n    divided difference table.\n    \n    Args:\n        sample_nodes (np.ndarray): The x-coordinates of the sample points (real).\n        sample_values (np.ndarray): The y-coordinates of the sample points (complex).\n\n    Returns:\n        np.ndarray: The array of complex-valued Newton coefficients.\n    \"\"\"\n    n = len(sample_nodes)\n    if n == 0:\n        return np.array([], dtype=np.complex128)\n        \n    # Use a copy of sample_values to build the divided differences in-place\n    F = np.copy(sample_values)\n    coeffs = np.zeros(n, dtype=np.complex128)\n    coeffs[0] = F[0]\n    \n    # For each order of difference k > 0\n    for k in range(1, n):\n        # Update the F array to represent the k-th column of the DD table\n        # F[j] will become f[x_{j-k}, ..., x_j]\n        for j in range(n - 1, k - 1, -1):\n            denominator = sample_nodes[j] - sample_nodes[j-k]\n            if denominator == 0:\n                # This should not happen with distinct nodes\n                raise ValueError(\"Sample nodes must be distinct.\")\n            F[j] = (F[j] - F[j-1]) / denominator\n        coeffs[k] = F[k]\n        \n    return coeffs\n\ndef evaluate_newton_poly(sample_nodes: np.ndarray, coeffs: np.ndarray, query_point: float) -> np.complex128:\n    \"\"\"\n    Evaluates the Newton-form polynomial at a given query point.\n    Uses Horner's method for numerical stability and efficiency.\n    \n    P(x) = c_0 + (x - x_0)(c_1 + (x - x_1)(c_2 + ...))\n    \n    Args:\n        sample_nodes (np.ndarray): The original sample nodes x_0, x_1, ...\n        coeffs (np.ndarray): The Newton coefficients c_0, c_1, ...\n        query_point (float): The point at which to evaluate the polynomial.\n\n    Returns:\n        np.complex128: The value of the polynomial at the query point.\n    \"\"\"\n    n = len(coeffs) - 1\n    if n < 0:\n        return np.complex128(0.0) # Or handle as an error for empty coefficients\n        \n    # Horner's method evaluation, starting from the innermost term\n    p_val = coeffs[n]\n    for k in range(n - 1, -1, -1):\n        p_val = coeffs[k] + (query_point - sample_nodes[k]) * p_val\n    return p_val\n\ndef solve_case(Z_true, sample_nodes_list, query_nodes_list):\n    \"\"\"\n    Orchestrates the solution for a single test case.\n    \n    Args:\n        Z_true (callable): The true impedance function Z(omega).\n        sample_nodes_list (list): List of sample frequencies.\n        query_nodes_list (list): List of query frequencies.\n\n    Returns:\n        float: The maximum absolute error.\n    \"\"\"\n    sample_nodes = np.array(sample_nodes_list, dtype=float)\n    query_nodes = np.array(query_nodes_list, dtype=float)\n\n    # 1. Generate sample impedance values from the true function\n    sample_impedances = Z_true(sample_nodes)\n\n    # 2. Compute the Newton polynomial coefficients from the samples\n    coeffs = get_newton_coeffs(sample_nodes, sample_impedances)\n\n    # 3. Evaluate the interpolating polynomial at each query frequency\n    interp_impedances = np.array([evaluate_newton_poly(sample_nodes, coeffs, q) for q in query_nodes], dtype=np.complex128)\n    \n    # 4. Evaluate the true function at each query frequency\n    true_impedances_at_query = Z_true(query_nodes)\n    \n    # 5. Compute the absolute errors and find the maximum\n    errors = np.abs(interp_impedances - true_impedances_at_query)\n    max_error = np.max(errors) if errors.size > 0 else 0.0\n    \n    return max_error\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"Z_true\": lambda omega: 47.0 + 1j * omega * 0.01,\n            \"samples\": [100.0, 700.0],\n            \"queries\": [150.0, 1000.0]\n        },\n        {\n            \"Z_true\": lambda omega: 10.0 + 1j * (omega * 0.005 - 1.0 / (omega * 20e-6)),\n            \"samples\": [100.0, 400.0, 700.0, 1000.0, 1300.0],\n            \"queries\": [250.0, 450.0, 900.0, 1100.0]\n        },\n        {\n            \"Z_true\": lambda omega: -1j / (omega * 50e-6),\n            \"samples\": [500.0],\n            \"queries\": [250.0, 1000.0]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Calculate the maximum error for one case.\n        max_error = solve_case(case[\"Z_true\"], case[\"samples\"], case[\"queries\"])\n        results.append(max_error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "最后一个练习超越了简单的数值估计。我们不仅使用插值多项式来找出一个值，还将用它来推断原始数据的几何特性，例如其局部曲率。通过计算插值多项式的导数，我们可以估计通过三个点的圆的圆心和半径，并且，重要的是，研究测量噪声如何影响我们几何估计的准确性()。",
            "id": "2428257",
            "problem": "给定三个不同的采样点 $\\left(x_0,y_0\\right)$、$\\left(x_1,y_1\\right)$ 和 $\\left(x_2,y_2\\right)$，这些点位于一条光滑的平面曲线上，该曲线在 $x_1$ 附近可表示为单值函数 $y=y(x)$。假设其基底曲线是一个圆心为 $\\left(a,b\\right)$、半径为 $R$ 的未知圆。您的任务是使用通过牛顿均差构建的多项式插值，仅根据这三个点来估计该圆的圆心和半径，然后检验这些估计值对 $y$ 坐标中的观测噪声的敏感程度。\n\n基本依据和目标：\n- 从牛顿均差的定义和穿过 $\\left(x_0,y_0\\right)$、$\\left(x_1,y_1\\right)$ 和 $\\left(x_2,y_2\\right)$ 的二次插值多项式的构建开始。\n- 仅使用这些基础和核心几何事实，从第一性原理出发，推导如何在 $x_1$ 处获得二次插值函数的一阶和二阶导数，而不依赖任何无法从定义中推导出的结果。\n- 根据平面曲线的曲率与密切圆之间的几何关系，推导 $x_1$ 处的曲率如何确定密切圆的半径及其圆心相对于 $\\left(x_1,y_1\\right)$ 和局部切线与法线方向的位置。\n- 用代码实现此方法，并在一个小型测试集上进行评估，该测试集包括无噪声和有噪声数据、对称和非对称节点布置，以及一个近似直线（大半径）的弧段案例。所有量均视为无量纲；不涉及任何物理单位。\n\n详细要求：\n1. 使用牛顿均差构建穿过三个给定点的唯一二次插值函数 $p_2(x)$。以基于节点 $x_0$、$x_1$ 和 $x_2$ 的牛顿形式表示 $p_2(x)$。然后，通过对该多项式求导，得到 $p_2'(x)$ 和 $p_2''(x)$，从而直接从均差计算出 $p_2'(x_1)$ 和 $p_2''(x_1)$。除了从均差和多项式微分的定义得出的结论外，不要假设任何特殊公式。\n2. 根据几何原理，由 $y=y(x)$ 给出的平面曲线的曲率 $\\kappa$ 与其在某点的一阶和二阶导数相关。使用此关系将 $x_1$ 处的曲率与密切圆的半径 $R$ 联系起来。此外，通过从 $\\left(x_1,y_1\\right)$ 沿适当的单位法线方向移动等于半径的距离，来确定密切圆的圆心 $\\left(a,b\\right)$。使用局部凹凸性的符号来选择正确的法线方向。在您的推导中，除了基本的微分几何定义和向量归一化外，不要假设任何封闭形式的捷径。\n3. 实现一个程序，对每个提供的测试用例执行以下操作：\n   - 使用 $y_i=b+s\\sqrt{R^2-\\left(x_i-a\\right)^2}$，根据给定的真实参数 $\\left(a,b,R\\right)$ 和指定的分支符号 $s\\in\\{+1,-1\\}$，在一个圆上生成三个点 $\\left(x_i,y_i\\right)$。在以下所有案例中均使用 $s=+1$。\n   - 可选择性地为每个 $y_i$ 添加一个指定的标准差为 $\\sigma$ 的独立、零均值高斯噪声，保持 $x_i$ 不变，以获得观测值 $\\tilde{y}_i$。\n   - 构建通过 $\\left(x_i,\\tilde{y}_i\\right)$ 的二次牛顿插值函数，计算在 $x_1$ 处的一阶和二阶导数，并根据这些估计值计算密切圆的圆心 $\\left(\\hat{a},\\hat{b}\\right)$ 和半径 $\\hat{R}$。\n   - 报告该案例的绝对误差 $\\left(|\\hat{a}-a|,|\\hat{b}-b|,|\\hat{R}-R|\\right)$。\n\n数值和格式要求：\n- 所有计算都是无量纲的。\n- 如果使用噪声，则将其作为从均值为零、标准差为指定 $\\sigma$ 的正态分布中抽取的独立样本，添加到每个 $y_i$ 中。为保证可复现性，请使用提供的随机种子。如果在推导中隐式涉及任何角度，无需报告，也不需要角度单位。\n- 对于每个测试用例，报告一个包含三个浮点数的列表，对应于 $\\left(|\\hat{a}-a|,|\\hat{b}-b|,|\\hat{R}-R|\\right)$。在打印前将每个报告的浮点数四舍五入到 $12$ 位小数。\n- 您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来，每个测试用例的三元组也用自己的方括号括起来，且没有空格。例如，一个有效的格式是 $\\left[\\left[0.0,0.0,0.0\\right],\\left[1.0,2.0,3.0\\right]\\right]$。\n\n测试集：\n- 案例 $1$（无噪声，对称节点，中等曲率）：\n  - 真实参数：$\\left(a,b,R\\right)=\\left(0.75,-0.5,1.9\\right)$。\n  - 节点：$x_0=a-0.5$，$x_1=a$，$x_2=a+0.5$。\n  - 分支：$s=+1$。\n  - 噪声：$\\sigma=0$。\n- 案例 $2$（无噪声，非对称节点，中等曲率）：\n  - 真实参数：$\\left(a,b,R\\right)=\\left(0.75,-0.5,1.9\\right)$。\n  - 节点：$x_0=a-0.6$，$x_1=a+0.1$，$x_2=a+0.7$。\n  - 分支：$s=+1$。\n  - 噪声：$\\sigma=0$。\n- 案例 $3$（有噪声，对称节点，中等曲率）：\n  - 真实参数：$\\left(a,b,R\\right)=\\left(0.75,-0.5,1.9\\right)$。\n  - 节点：$x_0=a-0.5$，$x_1=a$，$x_2=a+0.5$。\n  - 分支：$s=+1$。\n  - 噪声：$\\sigma=10^{-5}$，随机种子 $12345$。\n- 案例 $4$（无噪声，对称节点，近似直线弧）：\n  - 真实参数：$\\left(a,b,R\\right)=\\left(10.0,-20.0,1000.0\\right)$。\n  - 节点：$x_0=a-0.1$，$x_1=a$，$x_2=a+0.1$。\n  - 分支：$s=+1$。\n  - 噪声：$\\sigma=0$。\n- 案例 $5$（有噪声，对称节点，近似直线弧）：\n  - 真实参数：$\\left(a,b,R\\right)=\\left(10.0,-20.0,1000.0\\right)$。\n  - 节点：$x_0=a-0.1$，$x_1=a$，$x_2=a+0.1$。\n  - 分支：$s=+1$。\n  - 噪声：$\\sigma=10^{-8}$，随机种子 $24680$。\n\n最终输出格式：\n- 单行输出，包含一个按案例1到5顺序排列的五个误差三元组的列表，该列表为单个逗号分隔的列表，用方括号括起来，没有空格，并且每个三元组都四舍五入到12位小数。例如：$\\left[\\left[e_{1a},e_{1b},e_{1R}\\right],\\left[e_{2a},e_{2b},e_{2R}\\right],\\left[e_{3a},e_{3b},e_{3R}\\right],\\left[e_{4a},e_{4b},e_{4R}\\right],\\left[e_{5a},e_{5b},e_{5R}\\right]\\right]$，其中每个 $e$ 表示相应的绝对误差。",
            "solution": "所呈现的问题陈述是有效的。它在科学上基于数值分析和微分几何的原理，问题提法得当，目标明确，并提供了获得唯一解所需的所有信息。任务是通过使用牛顿均差构建的二次插值函数，根据三个采样点估计圆的参数，然后利用其中间点处密切圆的几何性质。这是计算物理学中一个标准且可验证的问题。\n\n我们将严格遵循指定的要求，进行推导和求解。\n\n**第1部分：二次插值函数及其导数**\n\n给定三个横坐标不同的点 $(x_0, y_0)$、$(x_1, y_1)$ 和 $(x_2, y_2)$，存在一个唯一的、次数最多为二的多项式穿过它们。我们使用牛顿形式构造这个多项式 $p_2(x)$。\n\n首先，我们定义所需的均差：\n零阶均差就是函数值：\n$$f[x_i] = y_i$$\n一阶均差是两点之间割线的斜率：\n$$f[x_i, x_j] = \\frac{f[x_j] - f[x_i]}{x_j - x_i}$$\n二阶均差是一阶均差的差：\n$$f[x_i, x_j, x_k] = \\frac{f[x_j, x_k] - f[x_i, x_j]}{x_k - x_i}$$\n\n穿过 $(x_0, y_0)$、$(x_1, y_1)$ 和 $(x_2, y_2)$ 的二次插值多项式的牛顿形式由以下公式给出：\n$$p_2(x) = f[x_0] + f[x_0, x_1](x - x_0) + f[x_0, x_1, x_2](x - x_0)(x - x_1)$$\n让我们将作为均差的系数表示为 $c_0 = f[x_0]$、$c_1 = f[x_0, x_1]$ 和 $c_2 = f[x_0, x_1, x_2]$。则多项式为：\n$$p_2(x) = c_0 + c_1(x - x_0) + c_2(x - x_0)(x - x_1)$$\n\n为了求出插值多项式的一阶和二阶导数，我们对 $p_2(x)$ 关于 $x$ 求导。\n一阶导数 $p_2'(x)$ 为：\n$$p_2'(x) = \\frac{d}{dx} \\left[ c_0 + c_1(x - x_0) + c_2(x^2 - (x_0 + x_1)x + x_0x_1) \\right]$$\n$$p_2'(x) = 0 + c_1 + c_2(2x - (x_0 + x_1))$$\n$$p_2'(x) = c_1 + c_2((x - x_0) + (x - x_1))$$\n我们在中心点 $x_1$ 处计算此式：\n$$p_2'(x_1) = c_1 + c_2((x_1 - x_0) + (x_1 - x_1)) = c_1 + c_2(x_1 - x_0)$$\n代入均差 $c_1$ 和 $c_2$ 的定义：\n$$p_2'(x_1) = f[x_0, x_1] + f[x_0, x_1, x_2](x_1 - x_0)$$\n\n二阶导数 $p_2''(x)$ 通过对 $p_2'(x)$ 求导得到：\n$$p_2''(x) = \\frac{d}{dx} \\left[ c_1 + c_2(2x - x_0 - x_1) \\right] = 2c_2$$\n二次多项式的二阶导数是常数。因此，在 $x_1$ 处：\n$$p_2''(x_1) = 2c_2 = 2f[x_0, x_1, x_2]$$\n这些关于 $p_2'(x_1)$ 和 $p_2''(x_1)$ 的表达式是直接从牛顿多项式的定义中推导出来的，我们将在计算中使用它们。\n\n**第2部分：密切圆参数**\n\n曲线上某一点的密切圆是在该点最能逼近曲线的圆。其半径是曲率的倒数，其圆心位于法线上。\n\n对于由 $y = y(x)$ 定义的曲线，其曲率 $\\kappa$ 由以下公式给出：\n$$\\kappa(x) = \\frac{|y''(x)|}{(1 + [y'(x)]^2)^{3/2}}$$\n我们用插值多项式 $p_2(x)$ 在 $x=x_1$ 处的曲率来近似基底曲线在 $(x_1, y_1)$ 处的曲率。记此近似曲率为 $\\hat{\\kappa}$。\n$$\\hat{\\kappa} = \\frac{|p_2''(x_1)|}{(1 + [p_2'(x_1)]^2)^{3/2}}$$\n密切圆的估计半径 $\\hat{R}$ 是该曲率的倒数：\n$$\\hat{R} = \\frac{1}{\\hat{\\kappa}} = \\frac{(1 + [p_2'(x_1)]^2)^{3/2}}{|p_2''(x_1)|}$$\n\n密切圆的圆心 $(\\hat{a}, \\hat{b})$ 位于距离点 $(x_1, y_1)$ 为 $\\hat{R}$ 且沿着单位法向量的方向上。曲线 $y=p_2(x)$ 在 $x_1$ 处的切向量与 $\\langle 1, p_2'(x_1) \\rangle$ 成比例。因此，法向量与 $\\langle -p_2'(x_1), 1 \\rangle$ 成比例。单位法向量 $\\vec{n}$ 为：\n$$\\vec{n} = \\frac{\\langle -p_2'(x_1), 1 \\rangle}{\\sqrt{(-p_2'(x_1))^2 + 1^2}} = \\frac{\\langle -p_2'(x_1), 1 \\rangle}{\\sqrt{1 + [p_2'(x_1)]^2}}$$\n该向量指向上方（y分量为正）。如果曲线是上凹的（$p_2''(x_1) > 0$），曲率中心位于此方向；如果曲线是下凹的（$p_2''(x_1) < 0$），则位于相反方向。因此，我们可以将从 $(x_1, y_1)$ 到 $(\\hat{a}, \\hat{b})$ 的位移向量表示为 $\\hat{R} \\cdot \\text{sign}(p_2''(x_1)) \\cdot \\vec{n}$。\n\n圆心的位置向量是：\n$$\\langle \\hat{a}, \\hat{b} \\rangle = \\langle x_1, y_1 \\rangle + \\hat{R} \\cdot \\text{sign}(p_2''(x_1)) \\cdot \\vec{n}$$\n代入 $\\hat{R}$ 和 $\\vec{n}$ 的表达式：\n$$\\langle \\hat{a}, \\hat{b} \\rangle = \\langle x_1, y_1 \\rangle + \\frac{(1 + [p_2'(x_1)]^2)^{3/2}}{|p_2''(x_1)|} \\cdot \\text{sign}(p_2''(x_1)) \\cdot \\frac{\\langle -p_2'(x_1), 1 \\rangle}{\\sqrt{1 + [p_2'(x_1)]^2}}$$\n使用恒等式 $|z| \\cdot \\text{sign}(z) = z$，令 $z = p_2''(x_1)$，我们简化标量部分：\n$$\\frac{(1 + [p_2'(x_1)]^2)^{3/2}}{p_2''(x_1)} \\cdot \\frac{1}{\\sqrt{1 + [p_2'(x_1)]^2}} = \\frac{1 + [p_2'(x_1)]^2}{p_2''(x_1)}$$\n圆心的向量方程变为：\n$$\\langle \\hat{a}, \\hat{b} \\rangle = \\langle x_1, y_1 \\rangle + \\frac{1 + [p_2'(x_1)]^2}{p_2''(x_1)} \\langle -p_2'(x_1), 1 \\rangle$$\n由此，我们提取出估计的圆心坐标：\n$$\\hat{a} = x_1 - p_2'(x_1) \\frac{1 + [p_2'(x_1)]^2}{p_2''(x_1)}$$\n$$\\hat{b} = y_1 + \\frac{1 + [p_2'(x_1)]^2}{p_2''(x_1)}$$\n请注意，用于 $\\hat{b}$ 公式中的 $y$ 坐标是观测到的（且可能带噪声的）值 $\\tilde{y}_1$，因为这是构建密切圆所依据的插值多项式上的点。\n\n这些推导出的公式被实现用于求解每个测试用例的估计参数及其误差。在曲率小（半径大）的情况下，对噪声的敏感性尤其明显，此时 $p_2''(x_1)$ 接近于零，使得 $\\hat{a}$、$\\hat{b}$ 和 $\\hat{R}$ 的表达式在数值上不稳定。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the estimated circle parameters using a quadratic interpolant\n    and calculates the absolute errors for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1: noise-free, symmetric, moderate curvature\n        {'true_params': (0.75, -0.5, 1.9), 'a_offset': -0.5, 'c_offset': 0.5,\n         'noise_sigma': 0.0, 'seed': None},\n        # Case 2: noise-free, asymmetric, moderate curvature\n        {'true_params': (0.75, -0.5, 1.9), 'a_offset': -0.6, 'c_offset': 0.7,\n         'x1_offset': 0.1, 'noise_sigma': 0.0, 'seed': None},\n        # Case 3: noisy, symmetric, moderate curvature\n        {'true_params': (0.75, -0.5, 1.9), 'a_offset': -0.5, 'c_offset': 0.5,\n         'noise_sigma': 1e-5, 'seed': 12345},\n        # Case 4: noise-free, symmetric, large radius\n        {'true_params': (10.0, -20.0, 1000.0), 'a_offset': -0.1, 'c_offset': 0.1,\n         'noise_sigma': 0.0, 'seed': None},\n        # Case 5: noisy, symmetric, large radius\n        {'true_params': (10.0, -20.0, 1000.0), 'a_offset': -0.1, 'c_offset': 0.1,\n         'noise_sigma': 1e-8, 'seed': 24680},\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        a_true, b_true, R_true = case['true_params']\n        sigma = case['noise_sigma']\n        seed = case['seed']\n        \n        # Define nodes\n        x0 = a_true + case['a_offset']\n        x1 = a_true + case.get('x1_offset', 0.0) # a_true if symmetric\n        x2 = a_true + case['c_offset']\n        \n        xs = np.array([x0, x1, x2])\n        \n        # Generate true y-values on the upper branch (s=+1)\n        ys_true = b_true + np.sqrt(R_true**2 - (xs - a_true)**2)\n        \n        # Add noise if specified\n        ys_observed = ys_true.copy()\n        if sigma > 0:\n            rng = np.random.default_rng(seed)\n            noise = rng.normal(0, sigma, 3)\n            ys_observed += noise\n        \n        y0_obs, y1_obs, y2_obs = ys_observed\n        \n        # Calculate divided differences\n        # c0 = f[x0]\n        # c1 = f[x0, x1]\n        # c2 = f[x0, x1, x2]\n        c0 = y0_obs\n        \n        # First order differences\n        f_x0_x1 = (y1_obs - y0_obs) / (x1 - x0)\n        f_x1_x2 = (y2_obs - y1_obs) / (x2 - x1)\n        \n        c1 = f_x0_x1\n        \n        # Second order difference\n        c2 = (f_x1_x2 - f_x0_x1) / (x2 - x0)\n        \n        # Calculate derivatives of the interpolant p2(x) at x1\n        p2_prime_x1 = c1 + c2 * (x1 - x0)\n        p2_double_prime_x1 = 2 * c2\n        \n        # Check for near-zero second derivative (collinear points)\n        if abs(p2_double_prime_x1) < 1e-15:\n            # For collinear points, radius is infinite, center is at infinity.\n            # This problem's setup avoids this, but it's good practice.\n            # Report large error.\n            errors = [np.inf, np.inf, np.inf]\n            results.append(errors)\n            continue\n            \n        # Estimate parameters of the osculating circle\n        y_prime_sq = p2_prime_x1**2\n        common_term = (1 + y_prime_sq) / p2_double_prime_x1\n        \n        a_hat = x1 - p2_prime_x1 * common_term\n        b_hat = y1_obs + common_term\n        R_hat = np.abs((1 + y_prime_sq)**(3/2) / p2_double_prime_x1)\n\n        # Calculate absolute errors\n        error_a = abs(a_hat - a_true)\n        error_b = abs(b_hat - b_true)\n        error_R = abs(R_hat - R_true)\n        \n        results.append([error_a, error_b, error_R])\n\n    # Format the final output string as per requirements\n    formatted_results = []\n    for res_triple in results:\n        formatted_triple = f\"[{res_triple[0]:.12f},{res_triple[1]:.12f},{res_triple[2]:.12f}]\"\n        formatted_results.append(formatted_triple)\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}