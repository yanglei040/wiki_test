{
    "hands_on_practices": [
        {
            "introduction": "我们的理查森外推法（Richardson Extrapolation）实践之旅始于一个基础计算。这个练习提供了一个常见场景：我们从具有不同步长的两次模拟中获得了两个数值估计。通过应用针对一阶误差方法的外推公式，你将学会如何系统地组合这些结果，以消除主导误差项，从而获得更精确的预测 。",
            "id": "2197893",
            "problem": "一个航空航天工程师团队正在开发一个计算机模拟程序，以预测探测器在一颗新发现的系外行星上的最终着陆速度。该模拟采用数值积分算法来求解运动方程。已知所使用的主要数值方法的全局截断误差为一阶，通常表示为 $O(h)$，其中 $h$ 是模拟的时间步长。\n\n该团队使用不同的时间步长进行了两次模拟运行，以评估其结果的收敛性。\n1.  当时间步长为 $h_1 = 0.20$ 秒时，模拟预测的最终着陆速度为 $V(h_1) = 15.60$ m/s。\n2.  当时间步长减小到 $h_2 = 0.10$ 秒时，模拟得出的着陆速度更为精确，为 $V(h_2) = 15.85$ m/s。\n\n为了在不增加进行更小时间步长模拟的计算成本的情况下获得更准确的预测，该团队决定使用理查森外推法。应用理查森外推法于这两个可用的速度估计值，以计算出真实着陆速度的改进估计值。\n\n以 m/s 为单位，将您改进后的速度最终答案四舍五入到四位有效数字。",
            "solution": "令真实着陆速度为 $V$，时间步长为 $h$ 时的数值估计值为 $V(h)$。对于一阶方法，全局截断误差模型为\n$$\nV(h) = V + C h + O(h^{2}),\n$$\n其中 $C$ 是一个与 $h$ 无关的常数。对于两个步长 $h_{1}$ 和 $h_{2}$，我们有\n$$\nV(h_{1}) = V + C h_{1} + O(h_{1}^{2}), \\quad V(h_{2}) = V + C h_{2} + O(h_{2}^{2}).\n$$\n忽略 $O(h^{2})$ 项并消去 $C$，得到\n$$\nC \\approx \\frac{V(h_{2}) - V(h_{1})}{h_{2} - h_{1}}, \\quad V \\approx V(h_{2}) - C h_{2}.\n$$\n代入 $C$ 得到一阶方法的理查森外推公式：\n$$\nV \\approx V(h_{2}) - h_{2}\\,\\frac{V(h_{2}) - V(h_{1})}{h_{2} - h_{1}} = V(h_{2}) + \\frac{V(h_{2}) - V(h_{1})}{\\frac{h_{1}}{h_{2}} - 1}.\n$$\n当 $h_{1} = 0.20$，$h_{2} = 0.10$，$V(h_{1}) = 15.60$ 和 $V(h_{2}) = 15.85$ 时，步长比为 $r = \\frac{h_{1}}{h_{2}} = 2$，所以\n$$\nV \\approx 15.85 + \\frac{15.85 - 15.60}{2 - 1} = 15.85 + 0.25 = 16.10.\n$$\n四舍五入到四位有效数字，改进后的真实着陆速度估计值为 $16.10$。",
            "answer": "$$\\boxed{16.10}$$"
        },
        {
            "introduction": "在掌握了基本应用之后，我们现在进入一个更深的概念层面。这项练习挑战你进行逆向思维：你不会被告知误差的阶数，而是会得到一个用于提高精度的特定外推公式。你的任务是分析这个公式的结构，以推断出它旨在消除的误差阶数，这有助于深入理解为何特定的外推方案（例如针对二阶方法的方案）会以其特有的形式构建 。",
            "id": "2197927",
            "problem": "在一个数值分析任务中，函数 $A(h)$ 提供了一个未知精确值 $L$ 的近似值。该近似值依赖于一个小的正步长 $h$。已知此近似的误差遵循以下渐近关系：\n$$L = A(h) + C h^{p} + O(h^{q})$$\n其中 $C$ 是一个非零常数，$p$ 是一个代表首项误差阶的正整数，而 $q$ 是另一个满足 $q  p$ 的整数。\n\n为了获得 $L$ 的一个更精确的估计，使用步长为 $h$ 和 $h/2$ 的近似值执行单步理查森外推（Richardson extrapolation）。得到的外推值记为 $R(h)$，使用以下特定公式计算：\n$$R(h) = \\frac{4A(h/2) - A(h)}{3}$$\n当 $h \\to 0$ 时，新的近似 $R(h)$ 比 $A(h)$ 更快地收敛到 $L$。通过分析此外推公式的结构，确定 $p$ 的整数值。",
            "solution": "我们从给定的渐近展开式开始\n$$L = A(h) + C h^{p} + O(h^{q}),$$\n其中 $C \\neq 0$，$p \\in \\mathbb{Z}_{0}$，且 $q  p$。整理后，可得\n$$A(h) = L - C h^{p} + O(h^{q}).$$\n将 $h$ 替换为 $h/2$ 可得\n$$A(h/2) = L - C \\left(\\frac{h}{2}\\right)^{p} + O\\left(\\left(\\frac{h}{2}\\right)^{q}\\right) = L - C 2^{-p} h^{p} + O(h^{q}),$$\n因为 $O\\left((h/2)^{q}\\right) = O(h^{q})$。\n\n给定的理查森外推法为\n$$R(h) = \\frac{4 A(h/2) - A(h)}{3}.$$\n代入 $A(h/2)$ 和 $A(h)$ 的展开式：\n$$R(h) = \\frac{4\\left(L - C 2^{-p} h^{p} + O(h^{q})\\right) - \\left(L - C h^{p} + O(h^{q})\\right)}{3}.$$\n简化分子：\n$$4L - 4 C 2^{-p} h^{p} + O(h^{q}) - L + C h^{p} - O(h^{q}) = 3L + h^{p}\\left(C - 4 C 2^{-p}\\right) + O(h^{q}).$$\n因此，\n$$R(h) = L + \\frac{h^{p}}{3} C \\left(1 - 4 \\cdot 2^{-p}\\right) + O(h^{q}).$$\n\n为了使 $R(h)$ 的收敛速度快于 $A(h)$，首项误差项 $h^{p}$ 的系数必须为零，这要求\n$$1 - 4 \\cdot 2^{-p} = 0 \\quad \\Longrightarrow \\quad 4 = 2^{p} \\quad \\Longrightarrow \\quad p = 2.$$\n因此，给定外推公式的结构意味着首项误差阶为 $p=2$。",
            "answer": "$$\\boxed{2}$$"
        },
        {
            "introduction": "最后的这项练习将所有概念融合成一个完整的计算项目。你将使用著名的二阶Verlet算法来实现一个非线性摆的模拟。我们的目标是超越简单的模拟，通过提取一个物理量——振荡周期，然后对你的数值结果应用理查森外推法，以获得一个精度显著更高的估计值，从而展示该方法在科学计算中的实际威力 。",
            "id": "2435010",
            "problem": "我们要求您设计并实现一个程序，该程序使用理查森外推法来提高非线性摆振荡周期的数值估计精度，其中摆的运动通过Verlet算法进行模拟。请完全在国际单位制（SI单位）下工作。角度必须以弧度为单位，时间以秒为单位，长度以米为单位，加速度以米/秒²为单位。您的程序必须按照末尾的描述，产生单行输出。\n\n物理模型是长度为$L$、重力加速度为$g$的平面、无阻尼、非线性摆，其角位移$\\theta(t)$遵循以下常微分方程（ODE）演化\n$$\n\\frac{d^2 \\theta}{dt^2} + \\frac{g}{L}\\,\\sin\\!\\big(\\theta(t)\\big) = 0.\n$$\n假设初始条件为 $\\theta(0) = \\theta_0$ 和 $\\frac{d\\theta}{dt}(0) = 0$。\n\n使用速度Verlet算法（一种二阶辛方法）来模拟运动，处理状态变量 $\\theta$ 和 $\\omega = d\\theta/dt$ 以及加速度 $a(\\theta) = -\\frac{g}{L}\\sin(\\theta)$。在足够长的时间窗口内，以固定的时间步长 $\\Delta t$ 对系统进行演化，以确定振荡周期 $T(\\Delta t)$。通过检测$\\theta$的两个连续的同向过零点（例如，两次都从正值穿越到负值）来估计周期，并计算这两个过零点之间的时间差。使用离散时间样本之间的线性插值来估计每个过零点的时间。使用更精细的时间步长 $\\Delta t/2$ 重复模拟，以获得 $T(\\Delta t/2)$。\n\n假设从速度Verlet轨迹中提取的任何平滑标量的主要全局离散化误差与 $\\mathcal{O}(\\Delta t^2)$ 成正比。利用此假设，应用理查森外推法，将 $T(\\Delta t)$ 和 $T(\\Delta t/2)$ 结合成一个改进的真实周期 $T$ 的估计值 $\\widehat{T}$，方法是消除主导误差项。\n\n针对以下参数集测试套件实现上述过程，这些参数集旨在探究多种不同情况：\n- 情况1（理想情况，中等振幅）：$L = 1.0\\,\\text{m}$，$g = 9.81\\,\\text{m}/\\text{s}^2$，$\\theta_0 = 0.5\\,\\text{rad}$，$\\Delta t = 0.05\\,\\text{s}$。\n- 情况2（较大振幅，更强的非线性）：$L = 1.0\\,\\text{m}$，$g = 9.81\\,\\text{m}/\\text{s}^2$，$\\theta_0 = 1.2\\,\\text{rad}$，$\\Delta t = 0.05\\,\\text{s}$。\n- 情况3（近分离线边缘情况，非常大的振幅）：$L = 1.0\\,\\text{m}$，$g = 9.81\\,\\text{m}/\\text{s}^2$，$\\theta_0 = 2.9\\,\\text{rad}$，$\\Delta t = 0.02\\,\\text{s}$。\n\n您的程序必须：\n- 对每种情况，使用 $\\Delta t$ 和 $\\Delta t/2$ 进行模拟，根据$\\theta(t)$的同向过零点估计 $T(\\Delta t)$ 和 $T(\\Delta t/2)$，然后计算理查森外推周期估计值 $\\widehat{T}$。\n- 将每个最终周期估计值 $\\widehat{T}$ 以秒为单位表示，并四舍五入到小数点后 $6$ 位。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含三个外推周期估计值，格式为方括号内的逗号分隔列表，顺序与上述情况一致，例如 $[\\widehat{T}_1,\\widehat{T}_2,\\widehat{T}_3]$。确保每个 $\\widehat{T}_k$ 都四舍五入到小数点后 $6$ 位。",
            "solution": "在尝试任何解决方案之前，问题陈述都经过了严格的验证。\n\n**第一步：提取已知条件**\n\n-   **控制方程**：$\\frac{d^2 \\theta}{dt^2} + \\frac{g}{L}\\,\\sin(\\theta(t)) = 0$。\n-   **初始条件**：$\\theta(0) = \\theta_0$，$\\frac{d\\theta}{dt}(0) = 0$。\n-   **数值积分器**：速度Verlet算法。\n-   **状态变量**：$\\theta$（角位移）和 $\\omega = d\\theta/dt$（角速度）。\n-   **加速度函数**：$a(\\theta) = -\\frac{g}{L}\\sin(\\theta)$。\n-   **周期估计方法**：$\\theta(t)$ 在相同方向上连续两次过零点之间的时间间隔，使用线性插值定位。\n-   **误差假设**：从模拟中导出的量的全局离散化误差与 $\\mathcal{O}(\\Delta t^2)$ 成正比。\n-   **改进方法**：使用时间步长 $\\Delta t$ 和 $\\Delta t/2$ 的结果进行理查森外推。\n-   **测试用例1**：$L = 1.0\\,\\text{m}$，$g = 9.81\\,\\text{m}/\\text{s}^2$，$\\theta_0 = 0.5\\,\\text{rad}$，$\\Delta t = 0.05\\,\\text{s}$。\n-   **测试用例2**：$L = 1.0\\,\\text{m}$，$g = 9.81\\,\\text{m}/\\text{s}^2$，$\\theta_0 = 1.2\\,\\text{rad}$，$\\Delta t = 0.05\\,\\text{s}$。\n-   **测试用例3**：$L = 1.0\\,\\text{m}$，$g = 9.81\\,\\text{m}/\\text{s}^2$，$\\theta_0 = 2.9\\,\\text{rad}$，$\\Delta t = 0.02\\,\\text{s}$。\n-   **输出格式**：三个外推周期估计值的逗号分隔列表 $[\\widehat{T}_1, \\widehat{T}_2, \\widehat{T}_3]$，每个值四舍五入到小数点后6位。\n\n**第二步：使用提取的已知条件进行验证**\n\n根据验证标准对问题进行评估。\n\n-   **科学基础**：该问题涉及非线性摆，这是经典力学中的一个典型系统。其控制方程陈述正确。速度Verlet算法是用于此类系统的标准、稳健的辛积分器。理查森外推法是数值分析中的一种基本技术。对于Verlet方法，假设的 $\\mathcal{O}(\\Delta t^2)$ 全局误差是正确的。该问题在科学上和数学上都是合理的。\n-   **适定性**：该问题是适定的。具有指定初始条件的常微分方程有唯一解。数值方法、步长和周期估计过程都有明确定义。这种结构保证了可以计算出唯一的、有意义的解。\n-   **客观性**：该问题以精确、客观的语言陈述。所有参数都已量化，并且所需输出的规定明确无误。\n-   **完整性**：所有必要的信息都已提供。关于“足够长的时间窗口”的模拟指令是此类问题中的标准指令，意味着模拟必须至少跨越一个完整周期才能捕获必要的数据点。这不是模糊不清，而是任务的逻辑必然性。\n\n**第三步：结论与行动**\n\n该问题具有科学基础、适定性、客观性和完整性。它是**有效的**。将提供一个解决方案。\n\n任务是计算非线性摆振荡周期的高精度估计值。这需要三个组成部分：动力学的数值模拟，从模拟数据中提取周期的方法，以及用于提高结果精度的外推技术。\n\n物理系统是一个长度为 $L$ 的单摆，在重力加速度为 $g$ 的场中运动。其运动由角位移 $\\theta(t)$ 描述。其运动由以下二阶非线性常微分方程描述：\n$$\n\\frac{d^2 \\theta}{dt^2} = -\\frac{g}{L} \\sin(\\theta(t))\n$$\n我们用角度 $\\theta$ 和角速度 $\\omega = \\frac{d\\theta}{dt}$ 来定义系统的状态。系统从静止开始模拟，所以初始条件是 $\\theta(0) = \\theta_0$ 和 $\\omega(0) = 0$。\n\n系统的演化是使用速度Verlet算法进行数值计算的，这是一种非常适合保守力学系统的二阶辛方法。给定时间 $t_n = n \\Delta t$ 时的状态 $(\\theta_n, \\omega_n)$，其中 $\\Delta t$ 是时间步长，时间 $t_{n+1}$ 时的状态通过以下步骤找到：\n1.  计算依赖于角度的加速度：$a_n = a(\\theta_n) = -\\frac{g}{L} \\sin(\\theta_n)$。\n2.  将速度更新半步：$\\omega_{n+1/2} = \\omega_n + a_n \\frac{\\Delta t}{2}$。\n3.  使用这个中间速度将位置更新一整步：$\\theta_{n+1} = \\theta_n + \\omega_{n+1/2} \\Delta t$。\n4.  计算新的加速度：$a_{n+1} = a(\\theta_{n+1}) = -\\frac{g}{L} \\sin(\\theta_{n+1})$。\n5.  将速度更新第二个半步：$\\omega_{n+1} = \\omega_{n+1/2} + a_{n+1} \\frac{\\Delta t}{2}$。\n\n振荡周期 $T$ 是通过跟踪角位置 $\\theta(t)$ 来确定的。由于摆是从正角度 $\\theta_0$ 静止释放的，其首次过零将是负向（向下）的。一个完整周期是两个连续的同向过零点之间经过的时间。我们将找到第一次向下穿越和第二次向下穿越的时间。如果过零点发生在时间 $t_{n-1}$ 和 $t_n$ 之间，其中 $\\theta_{n-1} > 0$ 且 $\\theta_n \\leq 0$，我们使用线性插值来找到更精确的过零时间 $t_{cross}$：\n$$\nt_{cross} = t_{n-1} - \\theta_{n-1} \\frac{\\Delta t}{\\theta_n - \\theta_{n-1}}\n$$\n设前两次此类过零的时间为 $t_{cross,1}$ 和 $t_{cross,2}$。那么对于给定的时间步长 $\\Delta t$，周期的数值估计为 $T(\\Delta t) = t_{cross,2} - t_{cross,1}$。\n\n速度Verlet算法的全局误差为二阶。这意味着数值计算出的周期 $T(\\Delta t)$ 与真实周期 $T_{true}$ 的关系如下：\n$$\nT(\\Delta t) = T_{true} + C (\\Delta t)^2 + \\mathcal{O}(\\Delta t^4)\n$$\n其中 $C$ 是一个与 $\\Delta t$ 无关的常数。我们进行两次模拟：一次使用步长 $\\Delta t$ 得到 $T(\\Delta t)$，另一次使用步长 $\\Delta t/2$ 得到 $T(\\Delta t/2)$。我们有：\n$$\nT(\\Delta t/2) = T_{true} + C \\left(\\frac{\\Delta t}{2}\\right)^2 + \\mathcal{O}(\\Delta t^4) = T_{true} + \\frac{1}{4} C (\\Delta t)^2 + \\mathcal{O}(\\Delta t^4)\n$$\n我们可以通过构造这两个方程的线性组合来消除主导的 $\\mathcal{O}(\\Delta t^2)$ 误差项。将第二个方程乘以4，然后减去第一个方程，得到：\n$$\n4T(\\Delta t/2) - T(\\Delta t) = (4T_{true} - T_{true}) + (C(\\Delta t)^2 - C(\\Delta t)^2) + \\mathcal{O}(\\Delta t^4) = 3T_{true} + \\mathcal{O}(\\Delta t^4)\n$$\n求解 $T_{true}$ 得到理查森外推估计值 $\\widehat{T}$，其精度为 $\\mathcal{O}(\\Delta t^4)$：\n$$\n\\widehat{T} = \\frac{4T(\\Delta t/2) - T(\\Delta t)}{3}\n$$\n将此过程应用于每个测试用例，以获得最终的、改进的周期估计值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef get_period_from_simulation(L, g, theta0, dt):\n    \"\"\"\n    Simulates the nonlinear pendulum using the velocity Verlet algorithm and\n    calculates the oscillation period.\n\n    The period is determined by finding the time between two successive\n    downward zero-crossings of the angle theta, using linear interpolation\n    for precision.\n\n    Args:\n        L (float): Length of the pendulum in meters.\n        g (float): Gravitational acceleration in m/s^2.\n        theta0 (float): Initial angular displacement in radians.\n        dt (float): Time step for the simulation in seconds.\n\n    Returns:\n        float: The estimated period of oscillation in seconds.\n               Returns None if the period cannot be determined.\n    \"\"\"\n    theta = theta0\n    omega = 0.0\n    t = 0.0\n    \n    # Pre-calculate constant for acceleration\n    g_over_L = g / L\n\n    # Store previous state to detect crossing\n    theta_prev = theta\n\n    # Store times of downward zero crossings (theta from positive to negative)\n    crossing_times = []\n\n    # Estimate a safe maximum simulation time. The period increases with amplitude.\n    # The small angle period is 2*pi*sqrt(L/g). The true period is always longer.\n    # For theta0 near pi, the period can be very long.\n    # We simulate for at least 1.5 times a generous estimate of the period.\n    # Using an elliptic integral-based estimate for safety.\n    approx_period = 2.0 * np.pi * np.sqrt(L / g) * (1 + theta0**2 / 16.0)\n    if theta0 > 2.8: # Near separatrix, period grows rapidly\n        max_t = 10.0\n    else:\n        max_t = approx_period * 2.0\n    \n    # Simulation loop\n    num_steps = int(max_t / dt)\n    for _ in range(num_steps):\n        # Velocity Verlet integration step\n        accel_prev = -g_over_L * np.sin(theta)\n        omega_half = omega + 0.5 * accel_prev * dt\n        theta_next = theta + omega_half * dt\n        accel_next = -g_over_L * np.sin(theta_next)\n        omega_next = omega_half + 0.5 * accel_next * dt\n        \n        t += dt\n        theta_prev = theta\n        theta = theta_next\n        omega = omega_next\n\n        # Detect downward zero-crossing: theta from positive to non-positive\n        if theta_prev > 0 and theta = 0:\n            # Linear interpolation to find the precise crossing time t_cross\n            # Point 1: (t-dt, theta_prev), Point 2: (t, theta)\n            # Equation of line: T(th) = (t-dt) + (th - theta_prev) * dt / (theta - theta_prev)\n            # Find T at th=0:\n            t_cross = (t - dt) - theta_prev * dt / (theta - theta_prev)\n            crossing_times.append(t_cross)\n            \n            # If two downward crossings are found, calculate period and exit\n            if len(crossing_times) >= 2:\n                return crossing_times[1] - crossing_times[0]\n                \n    # This part should not be reached if max_t is sufficient\n    return None\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It computes the Richardson-extrapolated period for each case and\n    prints the results in the specified format.\n    \"\"\"\n    test_cases = [\n        # (L, g, theta0, dt)\n        (1.0, 9.81, 0.5, 0.05),\n        (1.0, 9.81, 1.2, 0.05),\n        (1.0, 9.81, 2.9, 0.02),\n    ]\n\n    results = []\n    \n    for i, case in enumerate(test_cases):\n        L, g, theta0, dt = case\n        \n        # Calculate period with coarse time step dt\n        T_coarse = get_period_from_simulation(L, g, theta0, dt)\n        \n        # Calculate period with fine time step dt/2\n        T_fine = get_period_from_simulation(L, g, theta0, dt / 2.0)\n        \n        if T_coarse is None or T_fine is None:\n            raise ValueError(f\"Failed to determine period for case {i+1}\")\n\n        # Apply Richardson extrapolation for a method with O(h^2) error\n        # T_extrapolated = (4 * T_fine - T_coarse) / 3\n        T_extrapolated = (4.0 * T_fine - T_coarse) / 3.0\n        \n        # Format the result to 6 decimal places\n        results.append(f\"{T_extrapolated:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```"
        }
    ]
}