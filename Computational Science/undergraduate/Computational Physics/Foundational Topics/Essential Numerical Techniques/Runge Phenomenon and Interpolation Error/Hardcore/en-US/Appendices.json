{
    "hands_on_practices": [
        {
            "introduction": "Our exploration begins with a practical application from quantum mechanics: approximating the wavefunction of a particle in an infinite square well. This exercise () uses the sinusoidal stationary states, $\\psi_{n}(x)$, as a model for smooth but increasingly oscillatory functions. By comparing the interpolation accuracy achieved with uniformly spaced nodes versus Chebyshev-Lobatto nodes, you will gain firsthand insight into how a strategic choice of interpolation points can dramatically suppress the large errors characteristic of the Runge phenomenon.",
            "id": "2436069",
            "problem": "Consider the one-dimensional (1D) time-independent Schrödinger equation in an infinite square well of width $L$, whose normalized stationary states are given by $\\psi_{n}(x)=\\sin\\!\\left(\\dfrac{n\\pi x}{L}\\right)$ on the closed interval $[0,L]$, where $n$ is a positive integer and the sine function takes its argument in radians. For a given integer $M\\geq 2$, define an interpolation node set $\\{x_{j}\\}_{j=0}^{M-1}\\subset[0,L]$ and the unique polynomial $p(x)$ of degree at most $M-1$ that satisfies $p(x_{j})=\\psi_{n}(x_{j})$ for all $j$. For each case in the test suite below, your task is to compute the maximum absolute interpolation error on a uniform evaluation grid of $Q$ points, defined by\n$$E=\\max_{0\\leq k \\leq Q-1}\\left|\\psi_{n}(x_{k})-p(x_{k})\\right|,\\quad x_{k}=\\frac{k\\,L}{Q-1},$$\nwith $Q=10001$. All quantities are dimensionless, and all angles are in radians.\n\nTwo node-set types are to be used:\n- Equispaced nodes: $x_{j}=\\dfrac{j\\,L}{M-1}$ for $j=0,1,\\dots,M-1$.\n- Chebyshev–Lobatto (CL) nodes mapped to $[0,L]$: $x_{j}=\\dfrac{L}{2}\\left(1-\\cos\\!\\left(\\dfrac{j\\pi}{M-1}\\right)\\right)$ for $j=0,1,\\dots,M-1$.\n\nFor each parameter tuple $(L,n,M,\\text{node\\_type})$ in the test suite, construct the corresponding polynomial interpolant $p(x)$ and compute $E$ as defined above.\n\nTest suite (in the exact order to be used for output):\n1. $(L=\\;1,\\;n=\\;3,\\;M=\\;9,\\;\\text{node\\_type}=\\text{equispaced})$,\n2. $(L=\\;1,\\;n=\\;15,\\;M=\\;9,\\;\\text{node\\_type}=\\text{equispaced})$,\n3. $(L=\\;1,\\;n=\\;15,\\;M=\\;9,\\;\\text{node\\_type}=\\text{CL})$,\n4. $(L=\\;1,\\;n=\\;20,\\;M=\\;21,\\;\\text{node\\_type}=\\text{equispaced})$,\n5. $(L=\\;1,\\;n=\\;20,\\;M=\\;21,\\;\\text{node\\_type}=\\text{CL})$,\n6. $(L=\\;2,\\;n=\\;15,\\;M=\\;21,\\;\\text{node\\_type}=\\text{equispaced})$,\n7. $(L=\\;1,\\;n=\\;50,\\;M=\\;51,\\;\\text{node\\_type}=\\text{equispaced})$,\n8. $(L=\\;1,\\;n=\\;50,\\;M=\\;51,\\;\\text{node\\_type}=\\text{CL})$.\n\nYour program should produce a single line of output containing the $8$ results as a comma-separated list enclosed in square brackets, in the same order as the test suite. Each result must be a floating-point number equal to $E$ for the corresponding case, rounded to exactly $8$ digits after the decimal point (for example, $[0.12345679,0.00000001,\\dots]$).",
            "solution": "The problem presented is a well-defined exercise in computational physics and numerical analysis, specifically concerning the error analysis of polynomial interpolation. It requires the computation of the maximum absolute error when approximating a given function, derived from the stationary states of the one-dimensional quantum infinite square well, with a polynomial interpolant. The core of the problem is to compare the efficacy of two different sets of interpolation nodes: equispaced nodes and Chebyshev-Lobatto nodes.\n\nThe problem is scientifically and mathematically sound. The function to be interpolated is $\\psi_{n}(x) = \\sin\\left(\\frac{n\\pi x}{L}\\right)$, which is an analytic function on the entire real line, making it infinitely differentiable and well-suited for such analysis. The task is to construct a unique polynomial $p(x)$ of degree at most $M-1$ that passes through $M$ given points $(x_j, \\psi_{n}(x_j))$. The existence and uniqueness of such a polynomial is a cornerstone of numerical analysis.\n\nThe methodology for solving this problem involves the following steps:\n$1$. For each test case specified by the parameters $(L, n, M, \\text{node\\_type})$, the set of $M$ interpolation nodes $\\{x_j\\}_{j=0}^{M-1}$ is generated within the interval $[0, L]$.\n    - For equispaced nodes, the formula is $x_j = j \\frac{L}{M-1}$.\n    - For Chebyshev-Lobatto (CL) nodes, the formula is $x_j = \\frac{L}{2}\\left(1 - \\cos\\left(\\frac{j\\pi}{M-1}\\right)\\right)$. This distribution maps the extrema of the Chebyshev polynomial of the first kind, $T_{M-1}(t)$, from the canonical interval $[-1, 1]$ to $[0, L]$.\n\n$2$. The corresponding function values $\\{y_j = \\psi_n(x_j)\\}_{j=0}^{M-1}$ are computed.\n\n$3$. The interpolating polynomial $p(x)$ is constructed. While the Lagrange formula provides the theoretical definition of $p(x)$, its direct implementation is numerically unstable for high degrees. A superior method for evaluation is the barycentric interpolation formula. Given the nodes $x_j$ and values $y_j$, the polynomial can be evaluated at any point $x$ as:\n$$ p(x) = \\frac{\\sum_{j=0}^{M-1} \\frac{w_j}{x - x_j} y_j}{\\sum_{j=0}^{M-1} \\frac{w_j}{x - x_j}} $$\nwhere $w_j$ are the barycentric weights. This form is numerically stable and efficient. The `scipy.interpolate.BarycentricInterpolator` class provides a robust implementation of this method.\n\n$4$. To find the maximum interpolation error, $E$, a fine, uniform grid of $Q=10001$ evaluation points, $\\{x_k\\}_{k=0}^{Q-1}$, is created over $[0, L]$.\n\n$5$. The absolute error $|\\psi_n(x_k) - p(x_k)|$ is computed at each evaluation point $x_k$. The maximum of these values is taken as the result $E$:\n$$ E = \\max_{k} |\\psi_n(x_k) - p(x_k)| $$\n\nThis problem serves to demonstrate a critical concept in approximation theory: the choice of interpolation nodes profoundly impacts the accuracy of the approximation. The error of polynomial interpolation is bounded by a term that depends on the $(M)$-th derivative of the function and the node polynomial $\\omega(x) = \\prod_{j=0}^{M-1}(x - x_j)$. Chebyshev-Lobatto nodes minimize the maximum value of $|\\omega(x)|$ over the interval, leading to a much smaller theoretical error bound compared to equispaced nodes. For equispaced nodes, the interpolation error can grow uncontrollably near the interval boundaries as $M$ increases, a behavior known as Runge's phenomenon. This is especially pronounced when the function being interpolated has large derivatives, as is the case for $\\sin(k x)$ with large $k$. The problem's test cases are designed to highlight this precise behavior. Cases with large ratios of $n$ to $M$ and equispaced nodes are expected to yield substantial errors, which will be significantly mitigated by using Chebyshev-Lobatto nodes.\n\nThe algorithm is implemented in Python, leveraging a vectorized approach with the `numpy` library for efficient array computations and `scipy.interpolate.BarycentricInterpolator` for stable polynomial construction and evaluation. The procedure is executed for each of the eight test cases, and the resulting maximum errors are collected and formatted as specified.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.interpolate import BarycentricInterpolator\n\ndef solve():\n    \"\"\"\n    Solves the interpolation error problem for the given test suite.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (L, n, M, node_type)\n        (1.0, 3, 9, 'equispaced'),\n        (1.0, 15, 9, 'equispaced'),\n        (1.0, 15, 9, 'CL'),\n        (1.0, 20, 21, 'equispaced'),\n        (1.0, 20, 21, 'CL'),\n        (2.0, 15, 21, 'equispaced'),\n        (1.0, 50, 51, 'equispaced'),\n        (1.0, 50, 51, 'CL'),\n    ]\n\n    results = []\n    Q = 10001 # Number of evaluation points\n\n    for L, n, M, node_type in test_cases:\n        # 1. Define the function to be interpolated\n        # psi_n(x) = sin(n*pi*x/L)\n        psi_n = lambda x: np.sin(n * np.pi * x / L)\n\n        # 2. Generate M interpolation nodes\n        if node_type == 'equispaced':\n            x_interp = np.linspace(0.0, L, M)\n        elif node_type == 'CL':\n            j = np.arange(M)\n            # Chebyshev-Lobatto nodes mapped from [-1, 1] to [0, L]\n            x_interp = L / 2.0 * (1.0 - np.cos(j * np.pi / (M - 1)))\n        \n        # 3. Compute function values at interpolation nodes\n        y_interp = psi_n(x_interp)\n\n        # 4. Construct the barycentric interpolant\n        poly = BarycentricInterpolator(x_interp, y_interp)\n\n        # 5. Define the fine evaluation grid\n        x_eval = np.linspace(0.0, L, Q)\n\n        # 6. Evaluate the true function and the polynomial on the grid\n        y_true = psi_n(x_eval)\n        y_poly = poly(x_eval)\n\n        # 7. Compute the maximum absolute error\n        max_error = np.max(np.abs(y_true - y_poly))\n        results.append(max_error)\n\n    # Final print statement in the exact required format.\n    # Each result is rounded to exactly 8 digits after the decimal point.\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Building on the previous example, we now tackle a more complex function from quantum mechanics: the transmission probability $T(E)$ for a rectangular potential barrier. Unlike the infinitely smooth sine function, $T(E)$ is not analytic at the energy corresponding to the barrier height ($E=V_0$), posing a significant challenge for polynomial approximation. This practice () will allow you to investigate how this lack of smoothness affects interpolation error and test the limits of even well-chosen Chebyshev nodes, reinforcing the principle that the properties of the function itself are paramount.",
            "id": "2436011",
            "problem": "Write a complete, runnable program that quantifies interpolation error and illustrates the emergence or mitigation of Runge’s phenomenon when approximating a quantum mechanical tunneling probability function with a global polynomial interpolant. Consider a non-relativistic particle of mass $m$ incident on a one-dimensional rectangular barrier of height $V_0$ and width $a$. The transmission probability as a function of kinetic energy $E \\ge 0$ is defined by the following piecewise function, expressed in the International System of Units (SI):\n\nFor $0 \\le E  V_0$,\n$$\nT(E) = \\frac{1}{1 + \\dfrac{V_0^2 \\sinh^2\\!\\big(\\kappa a\\big)}{4 E (V_0 - E)}}, \\quad \\kappa = \\frac{\\sqrt{2 m (V_0 - E)}}{\\hbar}.\n$$\n\nFor $E = V_0$,\n$$\nT(E) = \\frac{1}{1 + \\dfrac{m V_0 a^2}{2 \\hbar^2}}.\n$$\n\nFor $E  V_0$,\n$$\nT(E) = \\frac{1}{1 + \\dfrac{V_0^2 \\sin^2\\!\\big(k_2 a\\big)}{4 E (E - V_0)}}, \\quad k_2 = \\frac{\\sqrt{2 m (E - V_0)}}{\\hbar}.\n$$\n\nIf $E = 0$, take $T(0) = 0$. Here $\\hbar$ is the reduced Planck constant. The function $T(E)$ is dimensionless. All computations inside these formulas must be performed in SI units. Energies given in electronvolts must be converted to joules using $1\\ \\text{electronvolt} = 1.602176634 \\times 10^{-19}\\ \\text{joule}$, lengths given in nanometers must be converted to meters using $1\\ \\text{nanometer} = 1.0 \\times 10^{-9}\\ \\text{meter}$, and the reduced Planck constant and the electron mass must be taken as\n$$\n\\hbar = 1.054571817 \\times 10^{-34}\\ \\text{joule}\\cdot\\text{second}, \\quad m_e = 9.1093837015 \\times 10^{-31}\\ \\text{kilogram}.\n$$\n\nFor each test case in the suite below, do the following:\n\n1. Use $m = m_e$.\n2. Define the energy interval as $[0, E_{\\max}]$ with $E_{\\max} = \\alpha V_0$, where $\\alpha$ is a unitless factor provided in the test case, and both $E_{\\max}$ and $V_0$ must be used in joules inside $T(E)$.\n3. Construct the unique polynomial interpolant of degree at most $N-1$ that interpolates $T(E)$ at $N$ nodes in $[0, E_{\\max}]$, where the node set is specified by a node-type flag:\n   - If the node type is “equispaced”, the nodes are $x_i = \\dfrac{i}{N-1} E_{\\max}$ for $i = 0, 1, \\ldots, N-1$.\n   - If the node type is “Chebyshev”, the nodes are the $N$ Chebyshev points of the first kind mapped from $[-1,1]$ to $[0, E_{\\max}]$, namely $x_i = \\dfrac{E_{\\max}}{2}\\left(1 + \\cos\\!\\left(\\dfrac{2 i + 1}{2 N} \\pi\\right)\\right)$ for $i = 0, 1, \\ldots, N-1$.\n4. Evaluate the maximum absolute interpolation error over a uniform evaluation grid of $1001$ points in $[0, E_{\\max}]$, that is, over the set $\\left\\{ 0, \\dfrac{E_{\\max}}{1000}, \\dfrac{2 E_{\\max}}{1000}, \\ldots, E_{\\max} \\right\\}$, by comparing the interpolant against the exact $T(E)$ at these grid points. Report the maximum absolute error as a dimensionless decimal number.\n\nYour program must compute and output, in a single line, the list of maximum absolute errors for the following test suite, in the order listed:\n\n- Test case $1$: $V_0 = 0.6\\ \\text{electronvolt}$, $a = 1.0\\ \\text{nanometer}$, $\\alpha = 1.2$, $N = 11$, node type = equispaced.\n- Test case $2$: $V_0 = 0.6\\ \\text{electronvolt}$, $a = 1.0\\ \\text{nanometer}$, $\\alpha = 1.2$, $N = 11$, node type = Chebyshev.\n- Test case $3$: $V_0 = 0.6\\ \\text{electronvolt}$, $a = 1.0\\ \\text{nanometer}$, $\\alpha = 1.2$, $N = 41$, node type = equispaced.\n- Test case $4$: $V_0 = 0.6\\ \\text{electronvolt}$, $a = 1.0\\ \\text{nanometer}$, $\\alpha = 1.2$, $N = 41$, node type = Chebyshev.\n- Test case $5$: $V_0 = 0.8\\ \\text{electronvolt}$, $a = 2.0\\ \\text{nanometer}$, $\\alpha = 1.2$, $N = 21$, node type = equispaced.\n- Test case $6$: $V_0 = 0.3\\ \\text{electronvolt}$, $a = 0.3\\ \\text{nanometer}$, $\\alpha = 1.2$, $N = 21$, node type = equispaced.\n\nThe required final output format is a single line containing a comma-separated list of the six maximum absolute errors enclosed in square brackets, for example, “[e1,e2,e3,e4,e5,e6]”, where each $e_k$ is a decimal rounded to six significant digits. The errors are dimensionless, so no physical unit specification is required in the output. No additional text must be printed.",
            "solution": "The supplied problem statement is subjected to rigorous validation and is found to be valid. It is scientifically sound, well-posed, and contains all necessary information for a unique, verifiable solution. The physical model is based on the standard quantum mechanical treatment of a particle tunneling through a rectangular potential barrier, a cornerstone of introductory quantum mechanics. The numerical task, which involves polynomial interpolation and the analysis of Runge's phenomenon, is a canonical problem in computational physics and numerical analysis. All parameters, constants, and procedural steps are specified with sufficient precision.\n\nThe core of the problem is to approximate a given function, the quantum tunneling probability $T(E)$, using a single polynomial interpolant $P_{N-1}(E)$ of degree at most $N-1$. The error of this approximation is then quantified. The function $T(E)$ is defined for a particle of mass $m$ and kinetic energy $E \\ge 0$ incident on a potential barrier of height $V_0$ and width $a$. The function is piecewise, with its analytical form depending on whether the energy $E$ is less than, equal to, or greater than the barrier height $V_0$. The definitions are:\nFor $0 \\le E  V_0$:\n$$\nT(E) = \\frac{1}{1 + \\dfrac{V_0^2 \\sinh^2\\!\\big(\\kappa a\\big)}{4 E (V_0 - E)}}, \\quad \\text{where} \\quad \\kappa = \\frac{\\sqrt{2 m (V_0 - E)}}{\\hbar}\n$$\nFor $E = V_0$:\n$$\nT(E) = \\frac{1}{1 + \\dfrac{m V_0 a^2}{2 \\hbar^2}}\n$$\nFor $E  V_0$:\n$$\nT(E) = \\frac{1}{1 + \\dfrac{V_0^2 \\sin^2\\!\\big(k_2 a\\big)}{4 E (E - V_0)}}, \\quad \\text{where} \\quad k_2 = \\frac{\\sqrt{2 m (E - V_0)}}{\\hbar}\n$$\nA special case is given for $E=0$, where $T(0)=0$. Here, $\\hbar$ is the reduced Planck constant. Analysis shows that the function $T(E)$ is continuous for all $E \\ge 0$. However, the transition from hyperbolic sine (for $E  V_0$) to trigonometric sine (for $E  V_0$) indicates that the function is not analytic at $E=V_0$. This lack of analyticity is a key condition for the emergence of Runge's phenomenon when using high-degree polynomial interpolants with equispaced nodes.\n\nThe interpolation is performed over the energy interval $[0, E_{\\max}]$, where $E_{\\max} = \\alpha V_0$. The polynomial $P_{N-1}(E)$ is constructed to match the exact function $T(E)$ at $N$ specified points, or nodes, $\\{x_i\\}_{i=0}^{N-1}$. Two types of node distributions are considered:\n$1$. Equispaced nodes: $x_i = \\dfrac{i}{N-1} E_{\\max}$ for $i=0, 1, \\ldots, N-1$. These nodes are known to lead to large oscillations near the interval endpoints for non-analytic functions, a behavior known as Runge's phenomenon.\n$2$. Chebyshev nodes: $x_i = \\dfrac{E_{\\max}}{2}\\left(1 + \\cos\\!\\left(\\dfrac{(2i+1)\\pi}{2N}\\right)\\right)$ for $i=0, 1, \\ldots, N-1$. These nodes are the roots of the Chebyshev polynomial of the first kind $T_N(x)$, scaled and shifted to the interval $[0, E_{\\max}]$. Their density is higher near the endpoints, which is proven to suppress or mitigate Runge's phenomenon, leading to superior convergence properties for continuous functions.\n\nThe solution is implemented algorithmically as follows. For each test case, the parameters $V_0$, $a$, $\\alpha$, $N$, and the node type are used. All physical quantities given in non-SI units (electronvolts, nanometers) are first converted to their SI counterparts (joules, meters) using the provided conversion factors. The particle mass $m$ is set to the electron mass $m_e$.\n\nFirst, the set of $N$ interpolation nodes $\\{x_i\\}$ is generated according to the specified type. Then, the exact function value $y_i = T(x_i)$ is computed at each node, creating the data set $\\{(x_i, y_i)\\}_{i=0}^{N-1}$. A single polynomial interpolant $P_{N-1}(E)$ that passes through these $N$ points is then constructed. For numerical stability and efficiency, especially for large $N$, the barycentric interpolation formula is the method of choice. The `scipy.interpolate.BarycentricInterpolator` class provides a robust implementation of this technique.\n\nTo quantify the quality of the approximation, the maximum absolute error, $\\|T - P_{N-1}\\|_{\\infty}$, is estimated over the interval $[0, E_{\\max}]$. This is done by computing the error on a fine, uniform grid of $1001$ evaluation points, $\\{E_j\\}_{j=0}^{1000}$, where $E_j = j \\cdot E_{\\max} / 1000$. The maximum absolute error is then calculated as:\n$$\n\\text{Error} = \\max_{j} | T(E_j) - P_{N-1}(E_j) |\n$$\nThis procedure is repeated for each of the six test cases specified in the problem statement. The resulting maximum error values are collected and formatted to six significant digits. The final output is a list of these error values as a single line of text. The comparison between equispaced and Chebyshev nodes, and the effect of increasing the polynomial degree $N-1$, will directly illustrate the theoretical predictions of numerical analysis regarding interpolation error and Runge's phenomenon.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.interpolate import BarycentricInterpolator\n\ndef t_prob(E_J, V0_J, a_m):\n    \"\"\"\n    Calculates the quantum tunneling transmission probability T(E).\n    All inputs must be in SI units.\n    \"\"\"\n    # Physical constants in SI units\n    hbar = 1.054571817e-34  # J*s\n    m_e = 9.1093837015e-31  # kg\n\n    # Ensure E_J is a numpy array for vectorized operations\n    E = np.atleast_1d(E_J).astype(float)\n    T = np.zeros_like(E)\n\n    # Define condition masks for the piecewise function\n    mask_zero = (E == 0)\n    mask_tunnel = (E  0)  (E  V0_J)\n    mask_barrier_top = (E == V0_J)\n    mask_above_barrier = (E  V0_J)\n\n    # Case 1: T(0) = 0\n    T[mask_zero] = 0.0\n\n    # Case 2: 0  E  V0 (tunneling)\n    if np.any(mask_tunnel):\n        E_sub = E[mask_tunnel]\n        kappa = np.sqrt(2 * m_e * (V0_J - E_sub)) / hbar\n        sinh_term = np.sinh(kappa * a_m)\n        denom_term = (V0_J**2 * sinh_term**2) / (4 * E_sub * (V0_J - E_sub))\n        T[mask_tunnel] = 1.0 / (1.0 + denom_term)\n\n    # Case 3: E = V0\n    if np.any(mask_barrier_top):\n        denom_term = (m_e * V0_J * a_m**2) / (2 * hbar**2)\n        T[mask_barrier_top] = 1.0 / (1.0 + denom_term)\n\n    # Case 4: E  V0 (above-barrier transmission)\n    if np.any(mask_above_barrier):\n        E_sup = E[mask_above_barrier]\n        k2 = np.sqrt(2 * m_e * (E_sup - V0_J)) / hbar\n        sin_term = np.sin(k2 * a_m)\n        denom_term = (V0_J**2 * sin_term**2) / (4 * E_sup * (E_sup - V0_J))\n        T[mask_above_barrier] = 1.0 / (1.0 + denom_term)\n\n    # Return scalar if input was scalar\n    return T[0] if np.isscalar(E_J) else T\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    \"\"\"\n    # Unit conversion factors\n    eV_to_J = 1.602176634e-19\n    nm_to_m = 1.0e-9\n\n    # Test cases from the problem statement\n    test_cases = [\n        # (V0_eV, a_nm, alpha, N, node_type)\n        (0.6, 1.0, 1.2, 11, \"equispaced\"),\n        (0.6, 1.0, 1.2, 11, \"Chebyshev\"),\n        (0.6, 1.0, 1.2, 41, \"equispaced\"),\n        (0.6, 1.0, 1.2, 41, \"Chebyshev\"),\n        (0.8, 2.0, 1.2, 21, \"equispaced\"),\n        (0.3, 0.3, 1.2, 21, \"equispaced\"),\n    ]\n\n    results = []\n    for V0_eV, a_nm, alpha, N, node_type in test_cases:\n        # Convert parameters to SI units\n        V0_J = V0_eV * eV_to_J\n        a_m = a_nm * nm_to_m\n\n        # Define the interpolation interval\n        E_max = alpha * V0_J\n\n        # Generate interpolation nodes based on type\n        if node_type == \"equispaced\":\n            x_nodes = np.linspace(0, E_max, N)\n        elif node_type == \"Chebyshev\":\n            # Chebyshev nodes of the first kind mapped to [0, E_max]\n            i = np.arange(N)\n            # The formula produces nodes in descending order, which is acceptable\n            cos_term = np.cos((2 * i + 1) * np.pi / (2 * N))\n            x_nodes = 0.5 * E_max * (1 + cos_term)\n        \n        # Compute exact function values at interpolation nodes\n        y_nodes = t_prob(x_nodes, V0_J, a_m)\n\n        # Construct the barycentric polynomial interpolant\n        poly_interpolant = BarycentricInterpolator(x_nodes, y_nodes)\n\n        # Create a fine grid for error evaluation\n        eval_grid = np.linspace(0, E_max, 1001)\n\n        # Evaluate the exact function and the interpolant on the grid\n        T_exact = t_prob(eval_grid, V0_J, a_m)\n        T_interp = poly_interpolant(eval_grid)\n        \n        # Find the maximum absolute error\n        max_error = np.max(np.abs(T_exact - T_interp))\n        \n        # Format result to six significant digits and store\n        results.append(\"{:.6g}\".format(max_error))\n\n    # Print the final list of errors in the required format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Having explored the approximation error between a function and its interpolant, we now look 'under the hood' at the numerical process of constructing the polynomial itself. The choice of basis—such as the monomial, Newton, or Lagrange basis—profoundly impacts the stability of finding the polynomial's coefficients. In this final exercise (), you will compute and compare the condition numbers of the linear systems associated with these different bases, providing a clear, quantitative understanding of why some computational methods are robust while others are fragile, especially for high-degree polynomials.",
            "id": "2436091",
            "problem": "You will write a complete program that quantitatively analyzes how the choice of polynomial basis affects the numerical conditioning of the interpolation calculation. Start from the fundamental definition of polynomial interpolation: given distinct nodes $\\{x_i\\}_{i=0}^{n}$ and data $\\{y_i\\}_{i=0}^{n}$, the interpolating polynomial $p(x)$ of degree at most $n$ is the unique polynomial satisfying $p(x_i)=y_i$ for all $i$. In any fixed polynomial basis $\\{\\phi_k(x)\\}_{k=0}^{n}$, one forms the linear system $B \\mathbf{a}=\\mathbf{y}$, where $B_{ik}=\\phi_k(x_i)$, $\\mathbf{a}$ are the basis coefficients, and $\\mathbf{y}=(y_0,\\dots,y_n)^\\top$. The numerical conditioning of solving for $\\mathbf{a}$ is governed by the spectral condition number $\\kappa_2(B)$, which quantifies the worst-case amplification of relative perturbations in $\\mathbf{y}$ into relative perturbations in $\\mathbf{a}$ in Floating-Point (FP) arithmetic. This conditioning depends on the basis choice but not on the underlying function $f(x)$ being interpolated. Separately, the interpolation error and its sensitivity to perturbations of $\\mathbf{y}$ at evaluation points are controlled by the Lebesgue constant, which depends on node choice; in particular, equispaced nodes on $[-1,1]$ exhibit large Lebesgue constants as $n$ grows, a hallmark of Runge’s phenomenon.\n\nYour task is to compute, for several test cases, the base-$10$ logarithm of the spectral condition number $\\log_{10}\\kappa_2(B)$ for three polynomial bases:\n- Monomial basis: $\\phi_k(x)=x^k$ for $k=0,1,\\dots,n$.\n- Newton basis: $\\phi_0(x)=1$ and $\\phi_k(x)=\\prod_{m=0}^{k-1}(x-x_m)$ for $k=1,2,\\dots,n$ with the nodes ordered increasingly.\n- Lagrange basis: $\\phi_k(x)=\\ell_k(x)$, where $\\ell_k(x_i)=\\delta_{ik}$ for all $i,k$, so that the basis matrix $B$ is the identity.\n\nYour program must construct the basis matrix $B$ for the monomial and Newton bases as specified above and compute $\\log_{10}\\kappa_2(B)$ using the spectral norm. For the Lagrange basis, use the fact that $B$ is the identity and hence $\\kappa_2(B)=1$.\n\nTest Suite:\nCompute $\\log_{10}\\kappa_2(B)$ for each of the following three cases, always on the interval $[-1,1]$ and with nodes sorted increasingly:\n1. Degree $n=10$ with $n+1=11$ equispaced nodes on $[-1,1]$.\n2. Degree $n=14$ with $n+1=15$ equispaced nodes on $[-1,1]$.\n3. Degree $n=20$ with $n+1=21$ Chebyshev nodes of the first kind $x_j=\\cos\\left(\\dfrac{\\pi j}{n}\\right)$ for $j=0,1,\\dots,n$.\n\nDesign for coverage:\n- Case $1$ is a moderate-degree, equispaced-node scenario (happy path).\n- Case $2$ increases degree on equispaced nodes, stressing numerical conditioning and reflecting the onset of Runge’s phenomenon in equispaced interpolation.\n- Case $3$ uses Chebyshev nodes at higher degree to contrast node choices while isolating basis effects on coefficient-solve conditioning.\n\nFinal output format:\n- Your program should produce a single line of output containing a comma-separated list of $9$ floating-point numbers enclosed in square brackets.\n- The order must be: for each case in the sequence $\\{1,2,3\\}$, list the three values $\\left[\\log_{10}\\kappa_2(B_{\\text{monomial}}),\\log_{10}\\kappa_2(B_{\\text{Newton}}),\\log_{10}\\kappa_2(B_{\\text{Lagrange}})\\right]$, and concatenate these triplets across the three cases to form a flat list of length $9$.\n- Each number must be formatted with exactly $6$ digits after the decimal point (use fixed-point format, not scientific notation).\n- There are no physical units or angles involved in the output; print raw numbers as specified.\n\nYour program must be self-contained, use no external input, and rely only on valid numerical linear algebra to compute $\\kappa_2(B)$ for the constructed basis matrices. Do not include any additional text in the output line.",
            "solution": "The problem requires a quantitative analysis of the numerical conditioning of solving for the coefficient vector $\\mathbf{a}$ in polynomial interpolation. This analysis is to be performed for different polynomial bases $\\{\\phi_k(x)\\}_{k=0}^{n}$. The core of the problem lies in the linear system $B \\mathbf{a} = \\mathbf{y}$, which arises from the interpolation conditions $p(x_i) = \\sum_{k=0}^{n} a_k \\phi_k(x_i) = y_i$. The matrix $B$, with entries $B_{ik} = \\phi_k(x_i)$, dictates the stability of this system.\n\nThe numerical stability is rigorously quantified by the spectral condition number of the basis matrix $B$, denoted $\\kappa_2(B)$. It is defined as:\n$$\\kappa_2(B) = \\|B\\|_2 \\|B^{-1}\\|_2 = \\frac{\\sigma_{\\text{max}}(B)}{\\sigma_{\\text{min}}(B)}$$\nwhere $\\sigma_{\\text{max}}(B)$ and $\\sigma_{\\text{min}}(B)$ are the maximum and minimum singular values of $B$, respectively. A large condition number signifies an ill-conditioned problem, where small perturbations in the input data $\\mathbf{y}$ can lead to disproportionately large perturbations in the computed solution for the coefficients $\\mathbf{a}$. We are tasked to compute $\\log_{10}\\kappa_2(B)$ for three distinct bases across several scenarios.\n\nThe three polynomial bases specified are:\n\n1.  **Monomial Basis**: The basis functions are $\\phi_k(x) = x^k$ for $k = 0, 1, \\dots, n$. The corresponding basis matrix, $B_{\\text{mono}}$, is a Vandermonde matrix with entries $(B_{\\text{mono}})_{ik} = x_i^k$. These matrices are known to be severely ill-conditioned, particularly for high-degree polynomials and uniformly spaced nodes.\n\n2.  **Newton Basis**: With respect to a set of ordered nodes $x_0  x_1  \\dots  x_n$, the Newton basis functions are defined as $\\phi_0(x) = 1$ and $\\phi_k(x) = \\prod_{m=0}^{k-1}(x-x_m)$ for $k \\geq 1$. The entries of the basis matrix $B_{\\text{Newton}}$ are given by $(B_{\\text{Newton}})_{ik} = \\prod_{m=0}^{k-1}(x_i-x_m)$. A crucial property of this matrix, given the ordered nodes, is that for any row index $i$, if the column index $k  i$, the product defining the entry $(B_{\\text{Newton}})_{ik}$ contains the term $(x_i - x_i) = 0$. Consequently, $(B_{\\text{Newton}})_{ik} = 0$ for all $k  i$, which makes $B_{\\text{Newton}}$ a lower triangular matrix. This structure typically results in significantly better conditioning compared to the full Vandermonde matrix of the monomial basis.\n\n3.  **Lagrange Basis**: The basis functions are the Lagrange cardinal polynomials, $\\phi_k(x) = \\ell_k(x)$, which possess the defining property $\\ell_k(x_i) = \\delta_{ik}$, where $\\delta_{ik}$ is the Kronecker delta. The basis matrix $B_{\\text{Lagrange}}$ therefore has entries $(B_{\\text{Lagrange}})_{ik} = \\delta_{ik}$, meaning $B_{\\text{Lagrange}}$ is the identity matrix $I$. The condition number of the identity matrix is the ideal value of $1$. Thus, for the Lagrange basis, we have:\n    $$\\kappa_2(B_{\\text{Lagrange}}) = \\kappa_2(I) = 1$$\n    and consequently,\n    $$\\log_{10}\\kappa_2(B_{\\text{Lagrange}}) = \\log_{10}(1) = 0$$\n    This demonstrates that determining the coefficients $a_k = y_k$ in the Lagrange basis is perfectly conditioned. It is important to note, however, that this perfect conditioning applies only to finding the coefficients; the evaluation of the resulting polynomial sum may still be susceptible to numerical error.\n\nThe computational procedure for each test case is as follows:\nFirst, the set of $n+1$ interpolation nodes $\\{x_i\\}_{i=0}^n$ is generated on the interval $[-1, 1]$ and sorted in increasing order. This sorting is essential for the correct definition of the Newton basis.\nSecond, the $(n+1) \\times (n+1)$ matrices $B_{\\text{mono}}$ and $B_{\\text{Newton}}$ are constructed according to their definitions.\nThird, the spectral condition number of each matrix is computed using a standard numerical linear algebra library routine, which typically relies on Singular Value Decomposition (SVD). For the Lagrange basis, the result is known to be $0$ without computation.\nFinally, the base-$10$ logarithm of each condition number is calculated and stored.\n\nThe selected test cases allow for a systematic comparison:\n*   Cases $1$ ($n=10$) and $2$ ($n=14$) with equispaced nodes are designed to show the degradation of conditioning with increasing degree for a poor choice of nodes.\n*   Case $3$ ($n=20$) with Chebyshev nodes is designed to contrast with the equispaced cases, demonstrating how a better node distribution can mitigate the ill-conditioning, even at a higher degree.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_log_conds(n: int, node_type: str) - tuple[float, float, float]:\n    \"\"\"\n    Computes the log10 of the spectral condition number for the monomial,\n    Newton, and Lagrange basis matrices for a given degree and node distribution.\n\n    Args:\n        n: The degree of the interpolating polynomial.\n        node_type: The type of nodes, either 'equispaced' or 'chebyshev'.\n\n    Returns:\n        A tuple containing the log10 condition numbers for the monomial,\n        Newton, and Lagrange bases, respectively.\n    \"\"\"\n    N = n + 1\n    \n    # Generate and sort the interpolation nodes\n    if node_type == 'equispaced':\n        # Generate n+1 equispaced nodes on [-1, 1]\n        nodes = np.linspace(-1.0, 1.0, N, dtype=np.float64)\n    elif node_type == 'chebyshev':\n        # Generate n+1 Chebyshev nodes of the first kind\n        j = np.arange(N, dtype=np.float64)\n        nodes = np.cos(np.pi * j / n)\n        # The problem requires nodes to be ordered increasingly for Newton basis\n        nodes = np.sort(nodes)\n    else:\n        raise ValueError(\"Invalid node type specified.\")\n\n    # 1. Monomial basis: B_ik = x_i^k\n    # np.vander with increasing=True produces columns [x^0, x^1, ..., x^n]\n    B_mono = np.vander(nodes, increasing=True)\n    cond_mono = np.linalg.cond(B_mono, 2)\n    log_cond_mono = np.log10(cond_mono)\n\n    # 2. Newton basis: B_ik = product_{m=0}^{k-1} (x_i - x_m)\n    # The matrix is lower triangular due to the definition and sorted nodes.\n    B_newton = np.ones((N, N), dtype=np.float64)\n    # Recursively build columns: phi_k(x) = phi_{k-1}(x) * (x - x_{k-1})\n    for k in range(1, N):\n        B_newton[:, k] = B_newton[:, k-1] * (nodes - nodes[k-1])\n    cond_newton = np.linalg.cond(B_newton, 2)\n    log_cond_newton = np.log10(cond_newton)\n\n    # 3. Lagrange basis: B_ik = delta_ik\n    # B is the identity matrix. Its condition number is exactly 1.\n    log_cond_lagrange = np.log10(1.0)  # This is always 0.0\n\n    return log_cond_mono, log_cond_newton, log_cond_lagrange\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (10, 'equispaced'),  # Case 1\n        (14, 'equispaced'),  # Case 2\n        (20, 'chebyshev'),   # Case 3\n    ]\n\n    results = []\n    for n, node_type in test_cases:\n        # Calculate the log condition numbers for the current case\n        log_conds_tuple = compute_log_conds(n, node_type)\n        # Append the three results to the final list\n        results.extend(log_conds_tuple)\n\n    # Final print statement in the exact required format.\n    # The output is a flat list of 9 numbers formatted to 6 decimal places.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}