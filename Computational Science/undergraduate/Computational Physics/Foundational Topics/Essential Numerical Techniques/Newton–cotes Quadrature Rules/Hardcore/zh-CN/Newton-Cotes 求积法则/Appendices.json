{
    "hands_on_practices": [
        {
            "introduction": "我们从一个基础练习开始，将一个特定的闭合型牛顿-科特斯公式——辛普森3/8法则——应用于一个经典的物理问题：计算旋转体的体积。这项实践旨在巩固复合求积法的核心概念，并为实现任何固定步长的牛顿-科特斯法则提供一个基本模板。通过这个练习，你将把理论知识转化为可运行的代码，解决一个具体的物理计算问题。",
            "id": "2418036",
            "problem": "编写一个完整、可运行的程序，该程序通过近似计算相应的定积分，来计算曲线 $y=\\mathrm{e}^{-x^{2}}$ 在有限区间 $[a,b]$ 上绕 $x$ 轴旋转生成的旋转体的体积。近似计算使用三次闭合牛顿-科特斯求积法则，通常称为辛普森 $3/8$ 法则。程序不得接受任何输入，必须硬编码一个由参数三元组 $(a,b,n)$ 组成的测试套件，其中 $a$ 和 $b$ 是指定积分限的实数，$n$ 是指定子区间数量的正整数。数字 $n$ 必須是 $3$ 的正整数倍。对于每个测试用例，程序必须以浮点数形式生成体积的数值近似值。此问题不涉及任何角度。输出中不需要任何物理单位。\n\n使用以下测试套件，表示为三元组 $(a,b,n)$ 的列表：\n- 案例 1：$(a,b,n)=\\big(0,1,300\\big)$。\n- 案例 2：$(a,b,n)=\\big(0,1,3\\big)$。\n- 案例 3：$(a,b,n)=\\big(-1,1,300\\big)$。\n- 案例 4：$(a,b,n)=\\big(0,10^{-3},3\\big)$。\n- 案例 5：$(a,b,n)=\\big(0.5,0.5,3\\big)$。\n\n您的程序必须应用辛普森 $3/8$ 法则，使用标准的绕 $x$ 轴旋转体体积公式，来近似计算每种情况下的体积。最终的程序输出必须是单行，包含一个 Python 风格的列表，其中包含按上述案例顺序排列的五个结果，每个结果都以科学记数法打印，小数点后恰好有 $12$ 位数字，且无任何附加文本。例如，输出格式必须类似于单行\n[result1,result2,result3,result4,result5]\n其中每个 result 是一个浮点数，采用科学记数法格式，小数点后恰好有 $12$ 位数字（例如，$\\texttt{1.234000000000e+00}$），并且列表中没有空格。\n\n要求的最终输出类型是按上述规定打印在一行上的包含 $5$ 个浮点数的单个列表。程序不得打印任何其他内容。",
            "solution": "所提出的问题是使用一种特定的数值求积方法，即复合辛普森 $3/8$ 法则，来計算旋转体的体积。该问题定义明确、科学上合理且内部一致。我们将着手进行其形式化求解。\n\n将由函数 $y = g(x)$ 定义的曲线在区间 $[a, b]$ 上绕 $x$ 轴旋转所生成的旋转体体积 $V$ 由以下定积分给出：\n$$ V = \\int_a^b \\pi [g(x)]^2 \\, dx $$\n在此问题中，函数被指定为 $g(x) = \\mathrm{e}^{-x^{2}}$。将此代入体积公式，我们得到需要计算的积分：\n$$ V = \\int_a^b \\pi \\left(\\mathrm{e}^{-x^{2}}\\right)^2 \\, dx = \\int_a^b \\pi \\mathrm{e}^{-2x^{2}} \\, dx $$\n该积分没有以初等函数表示的闭式解。因此，如题目所规定，需要进行数值近似。问题要求使用复合辛普森 $3/8$ 法则。\n\n设被积函数为 $f(x) = \\pi \\mathrm{e}^{-2x^{2}}$。我们的任务是近似计算积分 $I = \\int_a^b f(x) \\, dx$。\n复合辛普森 $3/8$ 法则是通过将积分区间 $[a, b]$ 分成 $n$ 个等宽子区间而导出的，其中 $n$ 必须是 $3$ 的正整数倍。每个子区间的宽度为 $h = \\frac{b-a}{n}$。区间由点 $x_i = a + i h$（对于 $i = 0, 1, 2, \\ldots, n$）划分。\n\n复合规则是通过对连续的三组子区间应用基本的辛普森 $3/8$ 法则并求和而形成的。在区间 $[x_k, x_{k+3}]$ 上的基本法则是：\n$$ \\int_{x_k}^{x_{k+3}} f(x) \\, dx \\approx \\frac{3h}{8} [f(x_k) + 3f(x_{k+1}) + 3f(x_{k+2}) + f(x_{k+3})] $$\n将这些近似值在从 $i=0$ 到 $n/3-1$ 的整个积分范围内对三子区间组 $[x_{3i}, x_{3i+3}]$ 进行求和，我们得到复合公式：\n$$ I = \\sum_{i=0}^{(n/3) - 1} \\int_{x_{3i}}^{x_{3i+3}} f(x) \\, dx \\approx \\sum_{i=0}^{(n/3) - 1} \\frac{3h}{8} [f(x_{3i}) + 3f(x_{3i+1}) + 3f(x_{3i+2}) + f(x_{3i+3})] $$\n展开并合并整个和的项，得到复合辛普森 $3/8$ 法则的通用公式：\n$$ I \\approx \\frac{3h}{8} \\left[ f(x_0) + 3f(x_1) + 3f(x_2) + 2f(x_3) + 3f(x_4) + \\ldots + 3f(x_{n-1}) + f(x_n) \\right] $$\n系数模式为 $\\{1, 3, 3, 2, 3, 3, 2, \\ldots, 2, 3, 3, 1\\}$。更正式地，积分近似值 $I_S$ 为：\n$$ I_S = \\frac{3h}{8} \\left( f(x_0) + f(x_n) + 2 \\sum_{j=1}^{n/3 - 1} f(x_{3j}) + 3 \\sum_{i \\in \\{1, \\dots, n-1\\}, i \\pmod 3 \\neq 0} f(x_i) \\right) $$\n括号内求和的一种高效算法形式为：\n$$ S = \\sum_{i=0}^{n} w_i f(x_i) $$\n其中权重 $w_i$ 定义为：\n$$ w_i = \\begin{cases} 1  &\\text{if } i=0 \\text{ or } i=n \\\\ 2  &\\text{if } i \\pmod 3 = 0 \\text{ and } 0 < i < n \\\\ 3  &\\text{if } i \\pmod 3 \\neq 0 \\text{ and } 0 < i < n \\end{cases} $$\n体积的最终近似值为 $V \\approx \\frac{3h}{8} S$。\n\n待实现的算法如下：\n1.  对于每个测试用例 $(a, b, n)$，计算步长 $h = \\frac{b-a}{n}$。请注意，如果 $a = b$，则 $h = 0$，这会正确地得到体积 $V=0$。\n2.  生成从 $a$到 $b$（含）的 $n+1$ 个点 $x_i$ 的集合，即 $x_i = a + i h$ for $i \\in \\{0, 1, \\dots, n\\}$。\n3.  定义被积函数 $f(x) = \\pi e^{-2x^2}$。\n4.  对所有点 $x_i$ 计算 $f(x_i)$。\n5.  使用如上定义的系数 $w_i$ 计算加权和 $S = \\sum_{i=0}^{n} w_i f(x_i)$。\n6.  计算最终体积估计值 $V = \\frac{3h}{8} S$。\n此过程将应用于每个给定的测试用例。实现将使用向量运算以提高计算效率并减少索引错误的可能性。生成一个点数组 $x$，按元素方式应用函数 $f$，根据规则构建一个权重数组 $w$，并通过权重和函数值的点积乘以因子 $\\frac{3h}{8}$ 来计算结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the volume of a solid of revolution using Simpson's 3/8 rule.\n    \"\"\"\n    # The problem specifies the function y = exp(-x^2) is rotated about the x-axis.\n    # The volume is given by the integral of pi * y^2.\n    # The integrand is therefore f(x) = pi * exp(-2*x^2).\n    integrand = lambda x: np.pi * np.exp(-2 * x**2)\n\n    # The test suite is given as a list of triples (a, b, n).\n    # a, b are integration limits, and n is the number of subintervals.\n    test_cases = [\n        (0.0, 1.0, 300),\n        (0.0, 1.0, 3),\n        (-1.0, 1.0, 300),\n        (0.0, 1.0e-3, 3),\n        (0.5, 0.5, 3),\n    ]\n\n    results = []\n    \n    # Process each test case.\n    for a, b, n in test_cases:\n        # The composite Simpson's 3/8 rule requires n to be a multiple of 3.\n        # This is satisfied by all test cases.\n\n        # Calculate the width of each subinterval.\n        # If a=b, h will be 0, correctly yielding a volume of 0 after multiplication.\n        h = (b - a) / n\n\n        # Generate the n+1 evaluation points for the interval [a, b].\n        x_points = np.linspace(a, b, n + 1)\n\n        # Evaluate the integrand at these points.\n        y_values = integrand(x_points)\n\n        # Construct the weight coefficients for Simpson's 3/8 rule.\n        # The pattern of weights is {1, 3, 3, 2, 3, 3, ..., 2, 3, 3, 1}.\n        weights = np.full(n + 1, 3.0)\n        weights[0] = 1.0\n        weights[-1] = 1.0\n        # For interior points with an index divisible by 3, the weight is 2.\n        # Slicing `weights[3:-1:3]` correctly targets these points for n > 3.\n        # For n=3, the slice is empty, so no change is made, which is correct.\n        weights[3:-1:3] = 2.0\n\n        # Compute the integral approximation by taking the dot product of weights\n        # and function values, then scaling by the rule's constant factor.\n        integral_approximation = (3 * h / 8) * np.dot(weights, y_values)\n        \n        results.append(integral_approximation)\n\n    # Final print statement in the exact required format.\n    # The format specifier \"{:.12e}\" ensures scientific notation with 12 digits\n    # after the decimal point.\n    output_string = \",\".join([f\"{res:.12e}\" for res in results])\n    print(f\"[{output_string}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在物理学和工程学中，许多积分的被积函数在端点处会趋于无穷大，这使得像辛普森法则这样的闭合型规则失效。本练习将介绍开型牛顿-科特斯公式，特别是中点法则，它巧妙地避免了在有问题的端点上计算函数值。通过这个练习，你将学会如何处理这类瑕积分，并体会到开型规则在处理奇异性问题时的独特优势。",
            "id": "2418007",
            "problem": "您需要编写一个完整、可运行的程序，用于计算可能带有代数端点奇点的积分的复合开放牛顿-柯特斯求积近似值，并报告与已知解析值的绝对误差。对于区间 $[a,b]$ 上的可积函数 $f$ 和正整数 $N$，定义基于 $0$ 次插值（中点求积）的复合开放牛顿-柯特斯求积为\n$$\nQ_N[f;[a,b]] \\equiv h \\sum_{k=0}^{N-1} f\\!\\left(a + \\left(k+\\tfrac{1}{2}\\right)h\\right), \\quad h \\equiv \\frac{b-a}{N}.\n$$\n对于下方的每个测试用例，计算近似值 $Q_N[f;[a,b]]$、精确积分\n$$\nI \\equiv \\int_a^b f(x)\\,dx,\n$$\n以及绝对误差 $E \\equiv \\lvert Q_N[f;[a,b]] - I \\rvert$。在适用的情况下，角度必须以弧度为单位进行解释。\n\n测试套件（每一项都指定了 $f(x)$、$[a,b]$、$N$ 以及精确值 $I$）：\n- 用例 1 (边界最小分辨率): $f(x)=x^{-1/2}$ 在 $[a,b]=[0,1]$ 上，其中 $N=1$，精确值 $I=2$。\n- 用例 2 (增加分辨率): $f(x)=x^{-1/2}$ 在 $[a,b]=[0,1]$ 上，其中 $N=8$，精确值 $I=2$。\n- 用例 3 (单端点奇点，大 $N$ 值): $f(x)=x^{-1/2}$ 在 $[a,b]=[0,1]$ 上，其中 $N=1024$，精确值 $I=2$。\n- 用例 4 (右端点奇点): $f(x)=(1-x)^{-1/2}$ 在 $[a,b]=[0,1]$ 上，其中 $N=64$，精确值 $I=2$。\n- 用例 5 (双端点奇点): $f(x)=x^{-1/2}(1-x)^{-1/2}$ 在 $[a,b]=[0,1]$ 上，其中 $N=1024$，精确值 $I=\\pi$。\n- 用例 6 (强但可积的左端点奇点): $f(x)=x^{-0.9}$ 在 $[a,b]=[0,1]$ 上，其中 $N=1000$，精确值 $I=10$。\n- 用例 7 (平滑基线，角度以弧度为单位): $f(x)=\\sin(x)$ 在 $[a,b]=[0,\\pi]$ 上，其中 $N=100$，精确值 $I=2$。\n- 用例 8 (靠近奇异端点的极短区间): $f(x)=x^{-1/2}$ 在 $[a,b]=[0,10^{-6}]$ 上，其中 $N=4$，精确值 $I=2\\sqrt{10^{-6}}$。\n\n您的程序必须按给定顺序计算上述用例的绝对误差 $E$，并生成单行输出，其中包含这些误差的列表。该列表应为逗号分隔，并用方括号括起，每个浮点数都应格式化为具有 $12$ 位有效数字的科学记数法。例如，要求的格式为\n\"[1.23456789012e+00,3.40000000000e-05,...]\"。",
            "solution": "该问题陈述是计算物理和数值分析领域的一个有效练习。它要求实现并应用复合中点求积法则来近似定积分，其中包括几个涉及在端点处具有代数奇点的反常积分的用例。\n\n需要实现的求积法则是复合中点法则，这是一种 $0$ 次开放牛顿-柯特斯公式。对于给定区间 $[a,b]$ 上的可积函数 $f(x)$ 和 $N$ 个子区间，近似值 $Q_N[f;[a,b]]$ 定义为：\n$$\nQ_N[f;[a,b]] \\equiv h \\sum_{k=0}^{N-1} f\\!\\left(x_k\\right),\n$$\n其中步长为 $h = \\frac{b-a}{N}$，求值点 $x_k$ 是各子区间的中点，由下式给出：\n$$\nx_k = a + \\left(k+\\frac{1}{2}\\right)h, \\quad \\text{for} \\quad k \\in \\{0, 1, \\dots, N-1\\}.\n$$\n核心任务是计算绝对误差 $E = \\lvert Q_N[f;[a,b]] - I \\rvert$，其中 $I$ 是给定的积分 $\\int_a^b f(x)\\,dx$ 的精确解析值。\n\n该问题的一个关键特征是存在具有端点奇点的被积函数，例如在 $[0,1]$ 上的 $f(x) = x^{-1/2}$ 或在 $[0,1]$ 上的 $f(x) = x^{-1/2}(1-x)^{-1/2}$。这些函数在一个或两个端点处不为有限值。复合中点法则是*开放*求积公式，这意味着它不在区间端点 $a$ 和 $b$ 处对被积函数求值。求值点集 $\\{x_k\\}$ 严格包含在开区间 $(a,b)$ 内。第一个点是 $x_0 = a + \\frac{h}{2}$，最后一个点是 $x_{N-1} = b - \\frac{h}{2}$。这一性质至关重要，因为它确保算法永远不会尝试在奇点处对函数求值，从而避免了除零错误和其他致命的计算问题。因此，该方法非常适合对此类反常积分进行数值近似，前提是它们是收敛的。测试套件中指定的所有积分确实都是收敛的。\n\n计算流程如下：\n$1$. 构建一个可重用函数来计算求积 $Q_N[f;[a,b]]$。该函数接受被积函数 $f$、区间限 $a$ 和 $b$ 以及子区间数 $N$ 作为输入。\n$2$. 步长 $h$ 按 $(b-a)/N$ 计算。为保证数值稳定性，所有计算均使用双精度浮点算术（在 `numpy` 中为 `float64`）执行。\n$3$. 生成一个包含 $N$ 个求值点 $x_k$ 的向量。使用向量化操作（例如 `numpy` 库提供的操作）对于此任务非常高效。这些点通过公式 $a + (\\text{np.arange}(N) + 0.5) \\cdot h$ 生成。\n$4$. 在该点向量上对被积函数 $f$ 求值，以生成一个函数值向量 $f(x_k)$。\n$5$. 计算这些值的总和，并乘以 $h$，得到最终的近似值 $Q_N$。\n$6$. 对问题陈述中定义的八个测试用例中的每一个重复此过程。对于每个用例，都使用相应的被积函数（表示为 `lambda` 函数）、区间、子区间数和精确积分值。\n$7$. 对于每个用例，通过取数值近似值 $Q_N$ 与给定的精确值 $I$ 之间的绝对差来计算绝对误差 $E$。\n$8$. 将生成的绝对误差列表格式化为单个字符串。根据要求，每个误差值都以具有 $12$ 位有效数字精度的科学记数法表示。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes composite midpoint quadrature approximations for integrals\n    and calculates the absolute error against known analytic values.\n    \"\"\"\n\n    def midpoint_quadrature(f, a, b, N):\n        \"\"\"\n        Calculates the composite midpoint rule approximation for the integral of f from a to b.\n\n        Args:\n            f (callable): The integrand function.\n            a (float): The lower limit of integration.\n            b (float): The upper limit of integration.\n            N (int): The number of subintervals.\n\n        Returns:\n            float: The numerical approximation of the integral.\n        \"\"\"\n        if N == 0:\n            raise ValueError(\"Number of subintervals N must be positive.\")\n        \n        h = (b - a) / N\n        \n        # Generate the sequence of k values: 0, 1, ..., N-1\n        k = np.arange(N)\n        \n        # Calculate the midpoints of the N subintervals\n        x_k = a + (k + 0.5) * h\n        \n        # Evaluate the function at all midpoints in a vectorized manner\n        f_values = f(x_k)\n        \n        # Compute the sum and multiply by the subinterval width h\n        approximation = h * np.sum(f_values)\n        \n        return approximation\n\n    # Define the test cases from the problem statement.\n    # Each tuple contains: (integrand_lambda, a, b, N, exact_I)\n    test_cases = [\n        # Case 1: boundary minimal resolution\n        (lambda x: x**(-0.5), 0.0, 1.0, 1, 2.0),\n        # Case 2: increased resolution\n        (lambda x: x**(-0.5), 0.0, 1.0, 8, 2.0),\n        # Case 3: large N on one-endpoint singularity\n        (lambda x: x**(-0.5), 0.0, 1.0, 1024, 2.0),\n        # Case 4: singularity at the right endpoint\n        (lambda x: (1.0 - x)**(-0.5), 0.0, 1.0, 64, 2.0),\n        # Case 5: singularities at both endpoints\n        (lambda x: x**(-0.5) * (1.0 - x)**(-0.5), 0.0, 1.0, 1024, np.pi),\n        # Case 6: strong but integrable left-endpoint singularity\n        (lambda x: x**(-0.9), 0.0, 1.0, 1000, 10.0),\n        # Case 7: smooth baseline, angles in radians\n        (lambda x: np.sin(x), 0.0, np.pi, 100, 2.0),\n        # Case 8: very short interval near a singular endpoint\n        (lambda x: x**(-0.5), 0.0, 1e-6, 4, 2.0 * np.sqrt(1e-6)),\n    ]\n\n    absolute_errors = []\n    for f_integrand, a_val, b_val, N_val, I_exact in test_cases:\n        # Calculate the numerical approximation Q_N\n        Q_N = midpoint_quadrature(f_integrand, a_val, b_val, N_val)\n        \n        # Compute the absolute error\n        error = np.abs(Q_N - I_exact)\n        absolute_errors.append(error)\n\n    # Format the results into the required output string.\n    # The format specifier '.11e' provides 12 significant digits.\n    # (1 digit before the decimal + 11 digits after).\n    formatted_errors = [f\"{err:.11e}\" for err in absolute_errors]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_errors)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "固定步长的求积法则效率低下，因为它在函数平滑的区域使用过多的采样点，而在函数复杂的区域采样又不足。这最后一个练习将指导你使用辛普森法则构建一个自适应求积算法。通过基于局部误差估计递归地细分区间，你将创建一个“智能”的积分器，它能自动将计算资源集中在最需要的区域，从而以最高的效率达到预设的精度要求。",
            "id": "2417964",
            "problem": "您需要实现一个自适应求积算法，该算法基于三节点闭式牛顿-柯特斯公式（辛普森法则）来近似定积分，并分析为满足指定的绝对容差所需的递归深度。您的实现必须是完全递归的，使用通过比较单区间近似与双子区间复合近似推导出的严格局部误差估计，并报告遇到的最大调用栈深度。所有三角函数的参数都应解释为弧度。\n\n基本原理：从定积分作为黎曼和的极限的定义出发，并遵循插值型求积法的原理：在区间 $[a,b]$ 上用一个穿过采样点的低次多项式来近似函数 $f(x)$，然后精确地对该多项式进行积分。使用三节点闭式牛顿-柯特斯求积法，通过细分区间进行递归应用。通过比较在 $[a,b]$ 上的近似值与在 $[a,c]$ 和 $[c,b]$（其中 $c=(a+b)/2$）上的近似值之和，推导出一个终止准则，以保证返回的近似值的绝对误差不大于指定的容差 $\\,\\varepsilon\\,$。您必须设计递归过程，以便传递已经计算过的函数值，从而避免冗余计算。\n\n您的函数必须：\n- 接受一个函数 $f$、一个区间 $[a,b]$ 和一个绝对容差 $\\,\\varepsilon>0$。\n- 使用基于三节点闭式牛顿-柯特斯公式的递归自适应细化策略，该策略作用于区间 $[a,b]$ 以及两个子区间 $[a,c]$ 和 $[c,b]$，其中 $c=(a+b)/2$。\n- 通过比较在 $[a,b]$ 上的单区间近似和在 $[a,c]$ 与 $[c,b]$ 上的双子区间复合近似，使用一个数学上合理的局部误差估计来决定是接受该近似还是进一步递归。\n- 在子问题之间分配容差，以确保全局绝对误差不超过 $\\,\\varepsilon$。\n- 跟踪并返回最大调用栈深度。将顶层调用的深度定义为 $0$，每次递归调用时深度加 $1$。\n- 包含一个递归深度的硬性限制，以保证在最坏情况下程序能够终止；如果达到此限制，则返回该分支上当前可用的最佳复合近似值。\n\n测试套件：\n实现您的程序以运行以下测试用例。对于每个用例，计算近似积分和遇到的最大递归深度。没有物理单位；仅报告无量纲的量。所有角度均以弧度为单位。\n\n- 测试 1：$f(x)=\\sin(x)$，区间为 $[0,\\pi]$，容差为 $\\varepsilon=10^{-10}$。\n- 测试 2：$f(x)=\\exp(-x^2)$，区间为 $[0,1]$，容差为 $\\varepsilon=10^{-8}$。\n- 测试 3：$f(x)=\\dfrac{1}{1+25x^2}$，区间为 $[-1,1]$，容差为 $\\varepsilon=10^{-8}$。\n- 测试 4：$f(x)=x^8-x^4+1$，区间为 $[0,1]$，容差为 $\\varepsilon=10^{-12}$。\n- 测试 5（边界尺度案例）：$f(x)=\\cos(x)$，区间为 $[0,10^{-6}]$，容差为 $\\varepsilon=10^{-14}$。\n- 测试 6（局部特征案例）：$f(x)=\\exp\\!\\big(-100\\,(x-0.3)^2\\big)$，区间为 $[0,1]$，容差为 $\\varepsilon=10^{-8}$。\n\n最终输出格式：\n您的程序应生成单行输出，包含一个逗号分隔的列表，列表用方括号括起来，其中每个测试用例对应一个双元素列表 $[I_{\\text{approx}},d_{\\max}]$，$I_{\\text{approx}}$ 是积分的浮点近似值，$d_{\\max}$ 是整数表示的最大递归深度。例如，整体输出必须类似于\n\"[[I1,d1],[I2,d2],[I3,d3],[I4,d4],[I5,d5],[I6,d6]]\"\n且不含空格。请将 $I1,\\dots,I6$ 和 $d1,\\dots,d6$ 替换为您的计算值。\n\n约束与说明：\n- 直接实现递归算法；不要依赖外部库中预构建的求积自适应功能。\n- 确保递归调用在共享节点上重用已评估的函数值，以避免冗余计算。\n- 选择一个足够大的有限最大允许递归深度，以处理给定的容差，避免在典型的平滑函数情况下过早终止。",
            "solution": "此问题是有效的。它提出了一个在计算物理学中明确定义的任务：实现并分析一个基于辛普森法则的自适应求积算法。该问题在科学上基于数值积分和误差分析的原理，内容自洽，并提供了一套清晰且客观的要求和测试用例。\n\n目标是在指定的绝对误差容差 $\\varepsilon$ 内，近似计算定积分 $I = \\int_a^b f(x) dx$。所采用的方法是基于三节点闭式牛顿-柯特斯公式（通常称为辛普森法则）的自适应求积。\n\n首先，我们建立基本的求积法则。辛普森法则用一个二次多项式来近似被积函数 $f(x)$，该多项式在三个等距点上插值 $f(x)$：端点 $a$ 和 $b$，以及中点 $c = (a+b)/2$。该多项式的积分为 $f(x)$ 的积分提供了一个近似值。对于单个区间 $[a, b]$ 的公式为：\n$$ S(a,b) = \\frac{b-a}{6}\\left[f(a) + 4f\\left(\\frac{a+b}{2}\\right) + f(b)\\right] $$\n此近似的误差 $E = I - S(a,b)$，可通过泰勒级数展开证明为：\n$$ E(a,b) = -\\frac{(b-a)^5}{2880} f^{(4)}(\\xi) $$\n其中某个 $\\xi \\in (a,b)$。这表明辛普森法则对于最高三次的多项式是精确的，因为对于这类多项式，其四阶导数 $f^{(4)}(x)$ 恒为零。\n\n为了高效地达到全局误差容差 $\\varepsilon$，需要一个自适应策略。这涉及将区间 $[a,b]$ 细分为更小的子区间（在函数 $f(x)$ 变化较快的地方）和使用较大的子区间（在函数较平滑的地方）。自适应算法的核心在于一个稳健的局部误差估计。\n\n为了推导这个估计，我们比较区间 $[a,b]$ 上积分的两种近似。第一种是粗略近似 $S_1$，通过在整个区间上应用一次辛普森法则得到：\n$$ S_1 = S(a,b) $$\n第二种是更精细的近似 $S_2$，通过在 $c=(a+b)/2$ 处二等分区间，并将辛普森法则应用于每个子区间 $[a,c]$ 和 $[c,b]$ 的结果相加得到：\n$$ S_2 = S(a,c) + S(c,b) $$\n设 $I$ 为在 $[a,b]$ 上的积分真值。$S_1$ 和 $S_2$ 的误差分别为 $E_1 = I - S_1$ 和 $E_2 = I - S_2$。如果我们假设四阶导数 $f^{(4)}(x)$ 在区间 $[a,b]$ 上近似为常数，我们就可以关联这两个误差。$S_2$ 的子区间长度是 $S_1$ 的一半。辛普森法则的误差与区间长度的五次方成正比，因此 $S_2$ 的误差大约是 $S_1$ 误差的 $2 \\times (1/2)^5 = 1/16$。\n$$ E_2 \\approx \\frac{1}{16} E_1 $$\n现在我们可以使用可计算的量 $S_1$ 和 $S_2$ 来估计误差：\n$$ I \\approx S_1 + E_1 \\approx S_1 + 16 E_2 $$\n$$ I \\approx S_2 + E_2 $$\n将这两个关于 $I$ 的表达式相等，得到 $S_1 + 16 E_2 \\approx S_2 + E_2$，简化后为：\n$$ 15 E_2 \\approx S_2 - S_1 $$\n这为更精确的近似 $S_2$ 的误差提供了一个实用的估计：\n$$ |E_2| = |I - S_2| \\approx \\frac{|S_2 - S_1|}{15} $$\n\n递归算法的流程如下。定义一个函数，用于计算区间 $[a,b]$ 上具有局部容差 $\\text{tol}$ 的积分。\n1.  给定区间 $[a,b]$ 和预先计算的函数值 $f(a)$、$f(b)$ 和 $f(c)$（其中 $c=(a+b)/2$），计算粗略近似 $S_1$ 和精细近似 $S_2$。这需要在 $[a,c]$ 和 $[c,b]$ 的中点进行两次新的函数求值。为避免重复工作，所有计算出的函数值在递归中向下传递。\n2.  计算误差估计值，$E_{\\text{est}} = |S_2 - S_1|/15$。\n3.  将误差估计值与局部容差 $\\text{tol}$ 进行比较。如果 $E_{\\text{est}} \\le \\text{tol}$，则认为近似 $S_2$ 对此区间足够精确。返回 $S_2$ 的值（它比 $S_1$ 更精确），该分支上的递归终止。\n4.  如果 $E_{\\text{est}} > \\text{tol}$，则必须细分该区间。算法对两个子区间 $[a,c]$ 和 $[c,b]$ 进行递归调用。容差在两个递归调用之间分配，通常是为每个调用分配 $\\text{tol}/2$ 的容差。这确保了子问题的误差之和受其父级容差的限制。\n5.  将两个递归调用的结果相加，得到原始区间 $[a,b]$ 上的积分。\n6.  跟踪递归深度。初始调用深度为 $0$。每次递归调用使深度增加 $1$。函数不仅要返回积分近似值，还要返回其计算分支中达到的最大深度。最终的最大深度是所有分支中的最大值。\n7.  为了防止对于病态被积函数的栈溢出，施加一个递归深度的硬性限制。如果达到此限制，则返回当前最佳近似值（$S_2$）。\n\n这个过程保证了在整个积分域 $[a,b]$ 上的总绝对误差被控制在小于用户指定的初始容差 $\\varepsilon$，同时根据函数的局部行为自动调整计算量。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef adaptive_quadrature(f, a, b, tol, max_depth=50):\n    \"\"\"\n    Computes the definite integral of f from a to b using a recursive\n    adaptive Simpson's rule.\n\n    Args:\n        f (callable): The function to integrate.\n        a (float): The lower limit of integration.\n        b (float): The upper limit of integration.\n        tol (float): The desired absolute error tolerance.\n        max_depth (int): The maximum recursion depth.\n\n    Returns:\n        tuple[float, int]: A tuple containing the approximate integral and\n                           the maximum recursion depth reached.\n    \"\"\"\n    c = (a + b) / 2.0\n    fa = f(a)\n    fb = f(b)\n    fc = f(c)\n    integral, max_d = _adaptive_simpson_recursive(f, a, b, tol, 0, max_depth, fa, fb, fc)\n    return integral, max_d\n\ndef _adaptive_simpson_recursive(f, a, b, tol, depth, max_depth, fa, fb, fc):\n    \"\"\"\n    Recursive helper for adaptive Simpson's rule.\n    It reuses pre-computed function values fa=f(a), fb=f(b), fc=f((a+b)/2).\n    \"\"\"\n    h = b - a\n    c = (a + b) / 2.0\n    \n    # Coarse approximation S1 = S(a,b)\n    s1 = (h / 6.0) * (fa + 4.0 * fc + fb)\n\n    # Refined approximation S2 = S(a,c) + S(c,b)\n    d = (a + c) / 2.0\n    e = (c + b) / 2.0\n    fd = f(d)\n    fe = f(e)\n    \n    s_left = (h / 12.0) * (fa + 4.0 * fd + fc)\n    s_right = (h / 12.0) * (fc + 4.0 * fe + fb)\n    s2 = s_left + s_right\n\n    error_estimate = abs(s2 - s1) / 15.0\n\n    if depth >= max_depth:\n        # Depth limit reached, return best current estimate S2\n        return s2, depth\n\n    if error_estimate = tol:\n        # Tolerance met, return S2 (more accurate)\n        return s2, depth\n\n    # Tolerance not met, recurse\n    next_depth = depth + 1\n    tol_sub = tol / 2.0\n    \n    left_integral, left_depth = _adaptive_simpson_recursive(f, a, c, tol_sub, next_depth, max_depth, fa, fc, fd)\n    right_integral, right_depth = _adaptive_simpson_recursive(f, c, b, tol_sub, next_depth, max_depth, fc, fb, fe)\n    \n    integral_sum = left_integral + right_integral\n    max_d = max(left_depth, right_depth)\n    \n    return integral_sum, max_d\n\n\ndef solve():\n    \"\"\"\n    Runs the adaptive quadrature algorithm on the defined test suite\n    and prints the results in the required format.\n    \"\"\"\n    \n    # Define test case functions\n    f1 = lambda x: np.sin(x)\n    f2 = lambda x: np.exp(-x**2)\n    f3 = lambda x: 1.0 / (1.0 + 25.0 * x**2)\n    f4 = lambda x: x**8 - x**4 + 1.0\n    f5 = lambda x: np.cos(x)\n    f6 = lambda x: np.exp(-100.0 * (x - 0.3)**2)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (f1, 0.0, np.pi, 1e-10),\n        (f2, 0.0, 1.0, 1e-8),\n        (f3, -1.0, 1.0, 1e-8),\n        (f4, 0.0, 1.0, 1e-12),\n        (f5, 0.0, 1e-6, 1e-14),\n        (f6, 0.0, 1.0, 1e-8),\n    ]\n\n    results = []\n    for case in test_cases:\n        f, a, b, tol = case\n        integral, max_depth = adaptive_quadrature(f, a, b, tol)\n        results.append([integral, max_depth])\n\n    # Format the results into the required string format \"[[I1,d1],[I2,d2],...]\"\n    formatted_results = [f\"[{i},{d}]\" for i, d in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}