{
    "hands_on_practices": [
        {
            "introduction": "Before applying the powerful machinery of Gaussian quadrature, we must ensure our problem is in the correct format. Standard Gauss-Legendre quadrature rules are defined for integrals over the canonical interval $[-1, 1]$. This first exercise  walks you through the essential preliminary step of transforming an integral from an arbitrary interval $[a, b]$ to the required $[-1, 1]$ form using a linear change of variables.",
            "id": "2175481",
            "problem": "In numerical analysis, many standard algorithms for approximating definite integrals, such as Gauss-Legendre quadrature, are defined over a canonical interval, typically $[-1, 1]$. To apply these algorithms to an integral over an arbitrary interval $[a, b]$, a linear change of variables is first required to map the integral to the standard form.\n\nConsider the definite integral $I = \\int_{0}^{2} \\sin(t) \\, dt$. This integral is to be evaluated numerically using a method that requires it to be in the form $I = \\int_{-1}^{1} g(x) \\, dx$.\n\nDetermine the analytic expression for the function $g(x)$ that results from this transformation.",
            "solution": "We need to transform the integral from $[0,2]$ to $[-1,1]$ using a linear change of variables. For a general integral $I=\\int_{a}^{b} f(t)\\,dt$, the standard linear mapping from $x\\in[-1,1]$ to $t\\in[a,b]$ is\n$$\nt=\\frac{b-a}{2}\\,x+\\frac{a+b}{2},\n$$\nwhich implies\n$$\ndt=\\frac{b-a}{2}\\,dx.\n$$\nBy the change of variables theorem,\n$$\nI=\\int_{a}^{b} f(t)\\,dt=\\int_{-1}^{1} f\\!\\left(\\frac{b-a}{2}\\,x+\\frac{a+b}{2}\\right)\\,\\frac{b-a}{2}\\,dx.\n$$\nThus, to write $I=\\int_{-1}^{1} g(x)\\,dx$, we identify\n$$\ng(x)=\\frac{b-a}{2}\\,f\\!\\left(\\frac{b-a}{2}\\,x+\\frac{a+b}{2}\\right).\n$$\n\nFor the given problem, $a=0$, $b=2$, and $f(t)=\\sin(t)$. Therefore,\n$$\n\\frac{b-a}{2}=1,\\qquad \\frac{a+b}{2}=1,\n$$\nso\n$$\ng(x)=1\\cdot \\sin\\!\\left(1\\cdot x+1\\right)=\\sin(x+1).\n$$\nThis yields the required form $I=\\int_{-1}^{1} \\sin(x+1)\\,dx$.",
            "answer": "$$\\boxed{\\sin(x+1)}$$"
        },
        {
            "introduction": "The magic of Gaussian quadrature lies in its incredible efficiency and accuracy for a specific class of functions. An $n$-point Gauss-Legendre rule can integrate any polynomial of degree up to $2n-1$ not just approximately, but exactly. This exercise  provides a direct, hands-on verification of this powerful property, demonstrating why Gaussian quadrature is a cornerstone of methods like the Finite Element Method (FEM).",
            "id": "2665798",
            "problem": "In one-dimensional solid mechanics, consider a two-node isoparametric bar element used in the Finite Element Method (FEM). Let the parent coordinate be denoted by $\\xi \\in [-1,1]$. Suppose that a nondimensionalized internal energy density per unit Jacobian associated with a certain virtual deformation mode is given by the quadratic function $u(\\xi) = 3\\xi^{2} + 2\\xi + 1$. The elemental contribution of this mode to the nondimensional internal virtual work is the integral\n$$\nI = \\int_{-1}^{1} u(\\xi)\\, d\\xi.\n$$\nUsing the two-point Gaussâ€“Legendre quadrature rule on $[-1,1]$ with nodes $\\xi = \\pm 1/\\sqrt{3}$ and weights $w = 1$, evaluate $I$ by quadrature. Then, verify the exactness of the quadrature by computing the analytic value of the integral directly from the definition of the Riemann integral. Report the value of $I$ as a pure number (dimensionless). No rounding is necessary because the result is exact.",
            "solution": "The problem requires the evaluation of the integral $I = \\int_{-1}^{1} u(\\xi)\\, d\\xi$ for the function $u(\\xi) = 3\\xi^{2} + 2\\xi + 1$. The evaluation must be performed using two methods for comparison: two-point Gauss-Legendre quadrature and direct analytical integration.\n\nFirst, we apply the two-point Gauss-Legendre quadrature rule. The general form for this quadrature on the interval $[-1,1]$ is given by:\n$$\n\\int_{-1}^{1} f(\\xi)\\, d\\xi \\approx \\sum_{i=1}^{n} w_i f(\\xi_i)\n$$\nFor a two-point rule ($n=2$), the nodes are $\\xi_1 = -\\frac{1}{\\sqrt{3}}$ and $\\xi_2 = \\frac{1}{\\sqrt{3}}$, and the corresponding weights are $w_1 = 1$ and $w_2 = 1$. The integrand is $f(\\xi) = u(\\xi) = 3\\xi^{2} + 2\\xi + 1$.\n\nWe evaluate the function $u(\\xi)$ at each of the quadrature nodes:\nAt $\\xi_1 = -\\frac{1}{\\sqrt{3}}$:\n$$\nu\\left(-\\frac{1}{\\sqrt{3}}\\right) = 3\\left(-\\frac{1}{\\sqrt{3}}\\right)^{2} + 2\\left(-\\frac{1}{\\sqrt{3}}\\right) + 1 = 3\\left(\\frac{1}{3}\\right) - \\frac{2}{\\sqrt{3}} + 1 = 1 - \\frac{2}{\\sqrt{3}} + 1 = 2 - \\frac{2}{\\sqrt{3}}\n$$\nAt $\\xi_2 = \\frac{1}{\\sqrt{3}}$:\n$$\nu\\left(\\frac{1}{\\sqrt{3}}\\right) = 3\\left(\\frac{1}{\\sqrt{3}}\\right)^{2} + 2\\left(\\frac{1}{\\sqrt{3}}\\right) + 1 = 3\\left(\\frac{1}{3}\\right) + \\frac{2}{\\sqrt{3}} + 1 = 1 + \\frac{2}{\\sqrt{3}} + 1 = 2 + \\frac{2}{\\sqrt{3}}\n$$\nNow, we compute the approximate value of the integral, which we denote $I_{GQ}$:\n$$\nI_{GQ} = w_1 u(\\xi_1) + w_2 u(\\xi_2) = (1) \\left(2 - \\frac{2}{\\sqrt{3}}\\right) + (1) \\left(2 + \\frac{2}{\\sqrt{3}}\\right)\n$$\n$$\nI_{GQ} = 2 - \\frac{2}{\\sqrt{3}} + 2 + \\frac{2}{\\sqrt{3}} = 4\n$$\nThe value of the integral using two-point Gauss quadrature is $4$.\n\nNext, we proceed with the verification by computing the exact value of the integral analytically using the Fundamental Theorem of Calculus.\n$$\nI = \\int_{-1}^{1} (3\\xi^{2} + 2\\xi + 1)\\, d\\xi\n$$\nThe antiderivative of the integrand is:\n$$\n\\int (3\\xi^{2} + 2\\xi + 1)\\, d\\xi = 3\\frac{\\xi^{3}}{3} + 2\\frac{\\xi^{2}}{2} + \\xi + C = \\xi^{3} + \\xi^{2} + \\xi + C\n$$\nEvaluating the definite integral between the limits $\\xi = -1$ and $\\xi = 1$:\n$$\nI = \\left[ \\xi^{3} + \\xi^{2} + \\xi \\right]_{-1}^{1} = \\left( (1)^{3} + (1)^{2} + (1) \\right) - \\left( (-1)^{3} + (-1)^{2} + (-1) \\right)\n$$\n$$\nI = (1 + 1 + 1) - (-1 + 1 - 1) = (3) - (-1) = 3 + 1 = 4\n$$\nThe exact analytical value of the integral is $4$.\n\nThe result from the two-point Gauss quadrature, $I_{GQ} = 4$, matches the exact analytical result, $I = 4$. This is expected. A Gauss-Legendre quadrature rule with $n$ points integrates polynomials of degree up to $2n-1$ exactly. In this problem, $n=2$, so the rule must be exact for any polynomial of degree up to $2(2)-1 = 3$. The integrand $u(\\xi) = 3\\xi^{2} + 2\\xi + 1$ is a polynomial of degree $2$. Since $2 \\le 3$, the quadrature yields the exact result. The verification confirms this theoretical principle. The required value of $I$ is therefore $4$.",
            "answer": "$$\\boxed{4}$$"
        },
        {
            "introduction": "While Gaussian quadrature is exact for polynomials, real-world physics problems often involve functions that are not so well-behaved. This computational exercise  explores what happens when we integrate a function with a 'kink' or discontinuity in its derivative, a common feature in physical models. By writing a short program to measure the convergence rate, you will gain practical insight into the performance limitations of the method and the importance of analyzing your integrand's smoothness.",
            "id": "2397754",
            "problem": "Consider the integral of the function $f(x)=\\lvert x-c\\rvert$ over the interval $[-1,1]$ for a fixed parameter $c\\in(-1,1)$. Let $I(c)$ denote the exact value of the integral, and let $Q_n(c)$ denote the $n$-point Gaussian quadrature approximation with Legendre weight on $[-1,1]$. Define the absolute error $E_n(c)=\\lvert Q_n(c)-I(c)\\rvert$. Investigate how the empirical algebraic convergence rate of $E_n(c)$ with respect to $n$ depends on the location of $c$ relative to the quadrature nodes.\n\nYour program must:\n- Compute the exact integral $I(c)$ from first principles.\n- For each $n$ in the integer set $\\{2,3,4,\\dots,80\\}$, compute $Q_n(c)$ and the absolute error $E_n(c)$.\n- For each fixed $c$, estimate two empirical algebraic convergence rates, $p_{\\mathrm{even}}(c)$ and $p_{\\mathrm{odd}}(c)$, by fitting a straight line to $(\\log n,\\log E_n(c))$ separately over the even subsequence $\\{n\\in\\mathbb{N}: n\\in\\{2,4,6,\\dots,80\\}\\}$ and the odd subsequence $\\{n\\in\\mathbb{N}: n\\in\\{3,5,7,\\dots,79\\}\\}$, respectively. Use the least-squares slope $\\hat{s}$ of $\\log E_n(c)$ versus $\\log n$ and define the empirical rate as $p=-\\hat{s}$. To avoid floating-point saturation, exclude any $(n,E_n(c))$ pairs with $E_n(c)\\le 10^{-14}$ from the fit; if fewer than $3$ points remain, use all available points without exclusion.\n- Use the natural logarithm for all logarithms in the rate estimation.\n\nUse the following test suite of parameter values:\n- $c_1=0$,\n- $c_2=0.1$,\n- $c_3=0.5773502691896257$.\n\nFor each $c_j$ in the test suite, compute and report the pair $\\big(p_{\\mathrm{even}}(c_j),\\,p_{\\mathrm{odd}}(c_j)\\big)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the following order and format:\n$[p_{\\mathrm{even}}(c_1),p_{\\mathrm{odd}}(c_1),p_{\\mathrm{even}}(c_2),p_{\\mathrm{odd}}(c_2),p_{\\mathrm{even}}(c_3),p_{\\mathrm{odd}}(c_3)]$.\nAll reported values must be real-valued numbers (no units), and angles do not appear in this task. The final output must be a single line and must not contain any additional text.",
            "solution": "The task is to investigate the empirical algebraic convergence rate of $n$-point Gauss-Legendre quadrature for the integral of the function $f(x) = \\lvert x-c \\rvert$ over the interval $[-1, 1]$. The function $f(x)$ is continuous, but its first derivative, $f'(x) = \\text{sgn}(x-c)$, has a jump discontinuity at $x=c$. This lack of smoothness is known to degrade the convergence rate of high-order quadrature rules from exponential (for analytic functions) to algebraic. We hypothesize an error scaling of the form $E_n(c) \\propto n^{-p}$, where $E_n(c)$ is the absolute error for an $n$-point rule and $p$ is the algebraic convergence rate.\n\nFirst, we determine the exact value of the integral, denoted by $I(c)$. For $c \\in (-1, 1)$, we split the integral at the point of non-differentiability, $x=c$:\n$$\nI(c) = \\int_{-1}^{1} \\lvert x-c \\rvert \\, dx = \\int_{-1}^{c} -(x-c) \\, dx + \\int_{c}^{1} (x-c) \\, dx\n$$\nEvaluating the elementary integrals gives:\n$$\nI(c) = \\left[ cx - \\frac{x^2}{2} \\right]_{-1}^{c} + \\left[ \\frac{x^2}{2} - cx \\right]_{c}^{1}\n$$\n$$\nI(c) = \\left( (c^2 - \\frac{c^2}{2}) - (-c - \\frac{1}{2}) \\right) + \\left( (\\frac{1}{2} - c) - (\\frac{c^2}{2} - c^2) \\right)\n$$\n$$\nI(c) = \\left( \\frac{c^2}{2} + c + \\frac{1}{2} \\right) + \\left( \\frac{1}{2} - c + \\frac{c^2}{2} \\right) = c^2 + 1\n$$\nThis analytical result, $I(c) = c^2+1$, is the benchmark against which the numerical approximation is compared.\n\nThe $n$-point Gauss-Legendre quadrature approximation, $Q_n(c)$, of the integral is given by the sum:\n$$\nQ_n(c) = \\sum_{i=1}^{n} w_i f(x_i) = \\sum_{i=1}^{n} w_i \\lvert x_i - c \\rvert\n$$\nwhere $\\{x_i\\}_{i=1}^n$ are the roots of the $n$-th degree Legendre polynomial $P_n(x)$ and $\\{w_i\\}_{i=1}^n$ are the corresponding quadrature weights. The absolute error is then $E_n(c) = \\lvert Q_n(c) - I(c) \\rvert$.\n\nTheoretical considerations for functions with singularities of this type (a jump in the first derivative) suggest an asymptotic convergence rate of $E_n(c) = O(n^{-2})$, so we expect to find $p \\approx 2$. However, the problem asks for an empirical rate, which we must compute from the numerical data. The analysis is to be performed separately for even and odd values of $n$. This distinction is important because the node distributions of Gauss-Legendre quadrature have different symmetry properties for even and odd $n$. Specifically, for odd $n$, $x=0$ is always a node, which is highly relevant for the case $c=0$.\n\nTo estimate the convergence rate $p$, we assume the model $E_n(c) = A n^{-p}$ for some constant $A$. Taking the natural logarithm of this relation yields a linear equation:\n$$\n\\ln(E_n(c)) = \\ln(A) - p \\ln(n)\n$$\nThis equation is of the form $y = b + sx$, where $y = \\ln(E_n(c))$, $x = \\ln(n)$, the intercept is $b = \\ln(A)$, and the slope is $s = -p$. The problem requires us to find the slope $s$ of the best-fit line for the data points $(\\ln(n), \\ln(E_n(c)))$ using the method of least squares. The empirical rate is then given by $p = -s$.\n\nThe computational procedure is as follows:\n1. For each value of $c$ in the test suite $\\{0, 0.1, 0.5773502691896257\\}$, we compute the exact integral $I(c) = c^2+1$.\n2. We iterate through $n \\in \\{2, 3, \\ldots, 80\\}$. In each iteration, we compute the $n$ Gauss-Legendre nodes and weights, calculate the quadrature approximation $Q_n(c)$, and find the error $E_n(c)$.\n3. The pairs $(n, E_n(c))$ are collected and separated into two subsequences based on the parity of $n$.\n4. For each subsequence (even and odd), we perform a linear regression on the log-transformed data $(\\ln(n), \\ln(E_n(c)))$. The specific rule for data filtering is applied: any point with $E_n(c) \\le 10^{-14}$ is excluded from the fit, unless this would leave fewer than $3$ points, in which case all points are used.\n5. The slope $s$ of the linear fit is obtained. The convergence rates are then $p_{\\mathrm{even}}(c) = -s_{\\mathrm{even}}$ and $p_{\\mathrm{odd}}(c) = -s_{\\mathrm{odd}}$.\n6. The resulting six values, $(p_{\\mathrm{even}}(c_1), p_{\\mathrm{odd}}(c_1), \\ldots)$, are reported in the specified format.\n\nThe following program implements this entire procedure.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef estimate_rate(n_values, E_values, min_points=3, threshold=1e-14):\n    \"\"\"\n    Estimates the algebraic convergence rate p from E ~ n^(-p).\n\n    This is done by a linear least-squares fit on log-log data.\n    The rate p is the negative of the slope of log(E) vs log(n).\n    \n    Args:\n        n_values (np.ndarray): Array of integer orders n.\n        E_values (np.ndarray): Array of corresponding errors E_n.\n        min_points (int): The minimum number of points required for a filtered fit.\n        threshold (float): The error threshold for filtering.\n    \n    Returns:\n        float: The estimated convergence rate p.\n    \"\"\"\n    # Ensure there are enough points to attempt a fit\n    if len(n_values) < 2:\n        return np.nan\n\n    # Filter out points where the error is at or below the floating-point precision limit.\n    # This prevents these points from corrupting the log-log fit.\n    mask = E_values > threshold\n    \n    if np.sum(mask) < min_points:\n        # If filtering leaves too few points, use all available points as per the rule.\n        x_fit = np.log(n_values)\n        y_fit = np.log(E_values)\n    else:\n        # Use the filtered data for the fit.\n        x_fit = np.log(n_values[mask])\n        y_fit = np.log(E_values[mask])\n\n    # Check again if there are enough points for polyfit after filtering.\n    if len(x_fit) < 2:\n        return np.nan\n\n    # Perform a linear fit (degree 1 polynomial) to the log-log data.\n    # The slope is the first element of the returned coefficients.\n    slope = np.polyfit(x_fit, y_fit, 1)[0]\n    \n    # The convergence rate p is the negative of the slope.\n    return -slope\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem as stated.\n    - Computes exact and approximate integrals.\n    - Calculates errors for n-point Gaussian quadrature.\n    - Estimates convergence rates for even and odd n subsequences.\n    \"\"\"\n    # Test suite of parameter values for c.\n    test_cases = [\n        0.0,\n        0.1,\n        0.5773502691896257,  # This is 1/sqrt(3)\n    ]\n\n    # The range of n for the quadrature rule.\n    n_range = np.arange(2, 81)\n    \n    all_results = []\n    \n    for c in test_cases:\n        # Compute the exact integral I(c) = c^2 + 1.\n        I_c = c**2 + 1.0\n        \n        # Lists to store n and the corresponding errors for even and odd subsequences.\n        n_even, E_even = [], []\n        n_odd, E_odd = [], []\n        \n        # Compute errors for each n in the specified range.\n        for n in n_range:\n            # Get the n-point Gauss-Legendre quadrature nodes and weights.\n            nodes, weights = np.polynomial.legendre.leggauss(n)\n            \n            # Compute the quadrature approximation Q_n(c) for f(x) = |x-c|.\n            Q_n = np.sum(weights * np.abs(nodes - c))\n            \n            # Compute the absolute error.\n            E_n = np.abs(Q_n - I_c)\n            \n            # Separate the results into even and odd subsequences.\n            if n % 2 == 0:\n                n_even.append(n)\n                E_even.append(E_n)\n            else:\n                n_odd.append(n)\n                E_odd.append(E_n)\n        \n        # Estimate the convergence rates for both subsequences.\n        p_even = estimate_rate(np.array(n_even), np.array(E_even))\n        p_odd = estimate_rate(np.array(n_odd), np.array(E_odd))\n        \n        all_results.extend([p_even, p_odd])\n\n    # Print the final results in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n\n```"
        }
    ]
}