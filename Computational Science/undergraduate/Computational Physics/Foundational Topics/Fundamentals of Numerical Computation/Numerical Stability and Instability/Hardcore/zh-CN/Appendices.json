{
    "hands_on_practices": [
        {
            "introduction": "即使是我们在中学代数中学过的简单公式，在计算机中也可能失效。本练习将探讨二次方程求根公式在特定条件下遇到的灾难性舍入问题，即当两个几乎相等的浮点数相减时发生的“灾难性抵消”。通过完成这个练习 ，您将亲手揭示有限精度计算中隐藏的风险，并学会一种通过代数重构来恢复计算精度的基本技巧。",
            "id": "2421654",
            "problem": "您需要研究在使用浮点运算计算二次多项式根时的数值稳定性和不稳定性。考虑二次方程 $a x^{2} + b x + c = 0$ 的实数根，在精确算术中，这些根由求根公式给出。在有限精度算术中，当 $b^{2} \\gg 4 a c$ 时，相消会严重降低精度。您的任务是从第一性原理出发分析这种情况，并实现一个程序，对一组精心选择的测试用例量化由此产生的误差。\n\n起点和目标：\n1) 从二次方程根的精确定义开始：对于给定的实系数 $a$、$b$ 和 $c$，根是满足 $a x^{2} + b x + c = 0$ 的值 $x$。在精确算术中，使用求根公式和实数的常规法则可以得到两个精确的根。定义判别式 $D = b^{2} - 4 a c$ 并假设 $D \\ge 0$，因此两个根都是实数。在浮点运算中，必须考虑舍入，特别是相消（减去几乎相等的数时有效数字的损失）。\n2) 分析不稳定性：当 $b^{2} \\gg 4 a c$ 时，$\\sqrt{b^{2} - 4 a c}$ 的值接近 $|b|$。使用 $x = \\frac{-b \\pm \\sqrt{b^{2} - 4 a c}}{2 a}$ 的形式，其中一个符号会导致分子中两个几乎相等的大数相减，这在浮点运算中会导致灾难性抵消和该根的巨大相对误差。使用二次方程的标准代数恒等式（例如 Vieta 定理：根的和 $r_{1} + r_{2} = -b/a$ 和根的积 $r_{1} r_{2} = c/a$），重新表达计算以避免这种减法。不要给出死记硬背的“修正”公式；相反，应从这些恒等式和精确代数出发进行推理，以构建一种在精确算术中代数上等价，但在浮点计算中避免减去几乎相等数值的替代方法。\n3) 量化误差：对于真实根 $x^{\\star}$ 的一个计算近似值 $\\hat{x}$，将相对误差定义为 $|\\hat{x} - x^{\\star}| / |x^{\\star}|$。您将使用任意高精度算术来获得一个基准真相 $x^{\\star}$，用以与浮点计算结果进行比较。\n\n编程要求：\n- 实现求解 $a x^{2} + b x + c = 0$ 根的两种算法：\n  1) 在标准双精度浮点运算中，使用 $x = \\frac{-b \\pm \\sqrt{b^{2} - 4 a c}}{2 a}$ 进行直接计算。\n  2) 一种数值稳定的替代方法，您需要通过对精确恒等式进行代数变换来推导，旨在避免当 $b^{2} \\gg 4 a c$ 时出现相消；然后使用精确的乘积关系 $r_{1} r_{2} = c/a$ 计算第二个根，以同样避免第二个根的计算中出现相消。\n- 为了进行误差评估，请使用至少有 $80$ 位十进制精度的任意精度浮点运算来计算一个高精度参考值。在高精度计算中也使用同样的避免相消的代数方法，以确保参考值尽可能精确。\n- 对于每个测试用例，将两个真实根中绝对值较小的那个根确定为“绝对值较小的根” $x^{\\star}_{\\text{small}} = \\operatorname{argmin}_{r \\in \\{r_{1}, r_{2}\\}} |r|$。对于每种算法，从其两个输出中选择绝对值较小的根，并通过相对误差 $|\\hat{x} - x^{\\star}_{\\text{small}}| / |x^{\\star}_{\\text{small}}|$ 将其与 $x^{\\star}_{\\text{small}}$ 进行比较。\n- 您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例贡献一个双元素列表 $[e_{\\text{naive}}, e_{\\text{stable}}]$，其中 $e_{\\text{naive}}$ 是直接求根公式计算的绝对值较小根的相对误差，$e_{\\text{stable}}$ 是您的数值稳定方法计算的绝对值较小根的相对误差。因此，如果有 $N$ 个测试用例，输出将是一个包含 $N$ 个双元素列表的单列表。\n\n测试用例集：\n使用以下六个测试用例，每个用例以 $(a,b,c)$ 的形式给出，选择它们是为了测试不同的稳定性状况。在所有表达式中，所有数字都是纯实数单位（没有物理单位），并且不涉及角度。\n- 用例 1：$(a,b,c) = (\\,1,\\; 10^{8} + 1,\\; 1\\,)$，即 $(\\,1,\\; 100000001,\\; 1\\,)$。\n- 用例 2：$(a,b,c) = (\\,1,\\; 10^{16},\\; 1\\,)$。\n- 用例 3：$(a,b,c) = (\\,1,\\; -\\,10^{8} - 1,\\; 1\\,)$，即 $(\\,1,\\; -\\,100000001,\\; 1\\,)$。\n- 用例 4：$(a,b,c) = (\\,1,\\; 2,\\; 1\\,)$，由于 $D = 0$，它有一个重实根。\n- 用例 5：$(a,b,c) = (\\,1,\\; 2,\\; 10^{-16}\\,)$。\n- 用例 6：$(a,b,c) = (\\,10^{-16},\\; 1,\\; 10^{-16}\\,)$。\n\n最终输出规范：\n- 程序必须精确打印一行：一个 Python 风格的列表的列表，其顺序与上述测试用例集相同。每个内部列表包含两个浮点数 $[e_{\\text{naive}}, e_{\\text{stable}}]$，分别表示朴素计算和稳定计算得到的绝对值较小根的相对误差。例如，对于两个假设的测试用例，一个有效的输出格式是：$[[0.1,1e-12],[0.5,2.3e-16]]$。",
            "solution": "当前的问题是从第一性原理出发，分析在使用有限精度算术和标准求根公式计算二次方程 $a x^2 + b x + c = 0$ 的根时遇到的数值不稳定性，并实现一个数值稳定的替代方案。\n\n如果一个问题在科学上是合理的、适定的和客观的，那么它就是有效的。这个问题是数值分析中的一个经典练习，它基于浮点运算和误差分析的既定原则。给定条件是完整的，目标是明确定义的，并且在计算科学领域内，其前提在事实上是正确的。因此，该问题被认为是有效的。\n\n我们从解析解开始。对于实系数 $a$、$b$ 和 $c$（其中 $a \\ne 0$），二次方程 $a x^{2} + b x + c = 0$ 的根由以下求根公式给出：\n$$\nx = \\frac{-b \\pm \\sqrt{D}}{2a}\n$$\n其中判别式为 $D = b^2 - 4ac$。给定条件是 $D \\ge 0$，这确保了根是实数。设两个根表示为 $r_1$ 和 $r_2$。\n\n**数值不稳定性分析**\n\n不稳定性的来源是在使用有限精度浮点运算时，特别是在 $b^2 \\gg 4ac$ 的情况下。这个条件意味着判别式 $D = b^2 - 4ac$ 非常接近 $b^2$。因此，$\\sqrt{D}$ 非常接近 $\\sqrt{b^2} = |b|$。\n\n让我们分析求根公式的分子 $-b \\pm \\sqrt{D}$。\n其中一个根的计算将涉及 $-b + \\sqrt{D}$ 或 $-b - \\sqrt{D}$。\n考虑当 $\\operatorname{sgn}(b) = +1$ 时，即 $b > 0$。那么 $|b|=b$。\n$\\sqrt{D} = \\sqrt{b^2 - 4ac}$ 这一项略小于 $b$。\n两个根通过以下方式计算：\n$$\nx_1 = \\frac{-b + \\sqrt{D}}{2a} \\quad \\text{和} \\quad x_2 = \\frac{-b - \\sqrt{D}}{2a}\n$$\n在 $x_1$ 的表达式中，分子涉及两个几乎相等的数值的减法运算。这种运算被称为**灾难性抵消**。在浮点运算中，如果 $\\sqrt{D}$ 足够接近 $b$，它们的差可能只有很少甚至没有有效数字，导致计算出的 $x_1$ 值有很大的相对误差。相反，根 $x_2$ 涉及两个大的负数相加，这是一个数值稳定的运算。\n\n同样地，如果 $\\operatorname{sgn}(b) = -1$，即 $b  0$，那么 $|b| = -b$。在这种情况下，$\\sqrt{D}$ 接近 $|b| = -b$。两个根是：\n$$\nx_1' = \\frac{-b - \\sqrt{D}}{2a} \\quad \\text{和} \\quad x_2' = \\frac{-b + \\sqrt{D}}{2a}\n$$\n在这里，$x_1'$ 的分子涉及两个几乎相等的数相减（因为 $\\sqrt{D} \\approx -b$），导致灾难性抵消。而 $x_2'$ 的计算涉及两个大的正数相加，是稳定的。\n\n总的来说，当根号的符号选择为与 $-b$ 的符号相反时（这等价于与 $b$ 的符号相同），根的计算是不稳定的。这种不稳定的计算总是产生绝对值较小的那个根。\n\n**稳定算法的推导**\n\n为了解决这个问题，我们必须构建一个代数上等价但能避免相消的替代表达式。问题指导我们使用 Vieta 定理，该定理将多项式的根与其系数联系起来。对于我们的二次方程，它们是：\n$$\nr_1 + r_2 = -\\frac{b}{a} \\quad \\text{(根的和)}\n$$\n$$\nr_1 r_2 = \\frac{c}{a} \\quad \\text{(根的积)}\n$$\n策略是首先使用标准公式计算*不*会遭受相消的根（绝对值较大的根），然后使用 Vieta 定理精确地找到第二个根（绝对值较小的根）。\n\n一个根的稳定计算涉及分子中同号量的相加。这对应于表达式：\n$$\nr_{\\text{large}} = \\frac{-b - \\operatorname{sgn}(b)\\sqrt{b^2 - 4ac}}{2a}\n$$\n此处，$\\operatorname{sgn}(b)$ 是符号函数，如果 $b \\ge 0$ 则为 $+1$，如果 $b  0$ 则为 $-1$（$b=0$ 时的选择是任意的，但必须保持一致；该公式无论如何都有效）。这个表达式可以稳健地计算出绝对值较大的根，因为它避免了几乎相等的量相减。\n\n一旦精确计算出 $r_{\\text{large}}$，我们就可以使用乘积恒等式 $r_{\\text{large}} \\cdot r_{\\text{small}} = c/a$ 来找到另一个根 $r_{\\text{small}}$：\n$$\nr_{\\text{small}} = \\frac{c/a}{r_{\\text{large}}} = \\frac{c}{a \\cdot r_{\\text{large}}}\n$$\n代入 $r_{\\text{large}}$ 的表达式，我们得到：\n$$\nr_{\\text{small}} = \\frac{c}{a \\left( \\frac{-b - \\operatorname{sgn}(b)\\sqrt{b^2 - 4ac}}{2a} \\right)} = \\frac{2c}{-b - \\operatorname{sgn}(b)\\sqrt{b^2-4ac}}\n$$\n这种形式的 $r_{\\text{small}}$ 避免了困扰朴素公式的相消问题，因为除法在浮点运算中是一种表现良好的运算（前提是分母不接近于零，而这里情况并非如此，因为 $|-b - \\operatorname{sgn}(b)\\sqrt{D}| \\approx 2|b|$）。\n\n由此产生的稳定算法如下：\n1.  计算判别式 $D = b^2 - 4ac$。\n2.  使用稳定形式计算一个根 $r_1$：$r_1 = \\frac{-b - \\operatorname{sgn}(b)\\sqrt{D}}{2a}$。\n3.  使用 Vieta 乘积公式计算第二个根 $r_2$：$r_2 = \\frac{c}{a \\cdot r_1}$。\n\n**实现与误差量化**\n\n对于每个测试用例 $(a,b,c)$，实现将包括三个部分：\n1.  **参考值计算：** 我们使用 Python 的 `decimal` 库和 85 位精度，通过稳定算法计算“真实”根 $x^{\\star}_1$ 和 $x^{\\star}_2$。并确定绝对值较小的根 $x^{\\star}_{\\text{small}}$。\n2.  **朴素计算：** 我们使用标准双精度浮点运算 (`float`)，通过直接求根公式 $x = \\frac{-b \\pm \\sqrt{D}}{2a}$ 计算根 $\\hat{x}_{n1}, \\hat{x}_{n2}$。我们从这对根中确定绝对值较小的根 $\\hat{x}_{n, \\text{small}}$。\n3.  **稳定计算：** 我们使用 `float` 运算，通过上面推导的稳定算法计算根 $\\hat{x}_{s1}, \\hat{x}_{s2}$。我们确定绝对值较小的根 $\\hat{x}_{s, \\text{small}}$。\n\n对于朴素算法和稳定算法，计算出的绝对值较小的根相对于高精度参考值的相对误差计算如下：\n$$\ne = \\frac{|\\hat{x}_{\\text{small}} - x^{\\star}_{\\text{small}}|}{|x^{\\star}_{\\text{small}}|}\n$$\n这种误差量化将展示在 $b^2 \\gg 4ac$ 的情况下，朴素方法的失败和稳定方法的成功。对于不满足此条件的用例（例如，$D=0$），两种方法预计都将表现良好。",
            "answer": "```python\nimport numpy as np\nfrom decimal import Decimal, getcontext\n\ndef solve():\n    \"\"\"\n    Analyzes numerical stability in solving quadratic equations and quantifies the error\n    of a naive vs. a stable algorithm for a given test suite.\n    \"\"\"\n    \n    # Set precision for high-accuracy reference calculations.\n    # At least 80 decimal digits are required; 85 provides a margin.\n    getcontext().prec = 85\n\n    # Define the test cases as per the problem statement.\n    test_cases = [\n        (1, 10**8 + 1, 1),\n        (1, 10**16, 1),\n        (1, -(10**8 + 1), 1),\n        (1, 2, 1),\n        (1, 2, 1e-16),\n        (1e-16, 1, 1e-16)\n    ]\n\n    results = []\n\n    for a_val, b_val, c_val in test_cases:\n        # --- 1. High-Precision Reference Calculation ---\n        a_hp, b_hp, c_hp = Decimal(a_val), Decimal(b_val), Decimal(str(c_val))\n\n        d_hp = b_hp**2 - 4 * a_hp * c_hp\n        \n        # Stable algorithm for high-precision reference roots\n        if d_hp  0:\n            # Problem constraints ensure D >= 0, but as a safeguard.\n            # For this problem, we can assume this branch is not taken.\n            ref_r1, ref_r2 = float('nan'), float('nan')\n        else:\n            sqrt_d_hp = d_hp.sqrt()\n            # Use np.copysign on the float value of b_hp to determine the sign.\n            # This is robust for b=0.\n            r1_hp = (-b_hp - Decimal(np.copysign(1, b_val)) * sqrt_d_hp) / (2 * a_hp)\n            if r1_hp == 0:\n                # This case happens if c=0, so one root is 0. The other is -b/a.\n                # The stable algorithm for r2 would fail.\n                # However, test cases do not have c=0.\n                r2_hp = -b_hp / a_hp\n            else:\n                r2_hp = c_hp / (a_hp * r1_hp)\n            ref_r1, ref_r2 = r1_hp, r2_hp\n\n        # Identify the smaller-magnitude reference root\n        if abs(ref_r1)  abs(ref_r2):\n            x_star_small = ref_r1\n        else:\n            x_star_small = ref_r2\n            \n        # --- 2. Standard Double-Precision Calculations ---\n        a_f, b_f, c_f = float(a_val), float(b_val), float(c_val)\n        d_f = b_f**2 - 4 * a_f * c_f\n        \n        if d_f  0:\n            # Handle cases where floating point error makes D negative\n            sqrt_d_f = 0.0\n        else:\n            sqrt_d_f = np.sqrt(d_f)\n\n        # 2a. Naive algorithm\n        naive_r1 = (-b_f + sqrt_d_f) / (2 * a_f)\n        naive_r2 = (-b_f - sqrt_d_f) / (2 * a_f)\n\n        # Identify smaller-magnitude root from naive method\n        x_hat_n_small = naive_r1 if abs(naive_r1)  abs(naive_r2) else naive_r2\n\n        # 2b. Stable algorithm\n        stable_r1 = (-b_f - np.copysign(sqrt_d_f, b_f)) / (2 * a_f)\n        if stable_r1 == 0:\n             # As before, this is for c=0 case not present in tests.\n             stable_r2 = -b_f / a_f\n        else:\n            stable_r2 = c_f / (a_f * stable_r1)\n        \n        # Identify smaller-magnitude root from stable method\n        # Note: The way the stable method is structured, stable_r2 is derived\n        # to be the smaller magnitude root when b^2 >> 4ac. Comparing magnitudes\n        # is a more general approach that is always correct.\n        if abs(stable_r1)  abs(stable_r2):\n            x_hat_s_small = stable_r1\n        else:\n            x_hat_s_small = stable_r2\n\n        # --- 3. Error Calculation ---\n        # Perform error calculation in high precision to avoid further errors.\n        if x_star_small == 0:\n            # If the true root is 0, relative error is 0 if computed is 0, else infinite.\n            # Test cases do not have zero roots.\n            e_naive = 0.0 if x_hat_n_small == 0.0 else float('inf')\n            e_stable = 0.0 if x_hat_s_small == 0.0 else float('inf')\n        else:\n            e_naive = float(abs(Decimal(x_hat_n_small) - x_star_small) / abs(x_star_small))\n            e_stable = float(abs(Decimal(x_hat_s_small) - x_star_small) / abs(x_star_small))\n        \n        results.append([e_naive, e_stable])\n\n    # Final print statement in the exact required format.\n    print(f\"{results}\")\n\nsolve()\n```"
        },
        {
            "introduction": "在计算物理中，近似计算函数的导数是一项基本任务，但这并非如看上去那般简单。本练习旨在揭示数值微分中一个核心的权衡关系：截断误差（源于近似公式本身）与舍入误差（源于计算机的有限精度）之间的矛盾。通过寻找最优步长 $h$ ，您将直观地理解如何在两个相互竞争的误差源之间取得平衡，这是数值方法中一个反复出现的主题。",
            "id": "2421640",
            "problem": "你需要编写一个完整的程序，对于一组有限的步长，确定能够最小化 $\\sin(x)$ 在指定点 $x_0$ 处导数的有限差分近似的绝对误差的步长 $h$，所用的差分格式为预设格式。角度必须以弧度处理。\n\n请使用以下完整指定的设置。\n\n1. 函数及其精确导数：\n   - 目标函数：$f(x) = \\sin(x)$。\n   - 精确导数：$f'(x) = \\cos(x)$。\n\n2. 待评估的有限差分格式：\n   - 向前差分：$D_{\\mathrm{fwd}}(x_0;h) = \\dfrac{\\sin(x_0 + h) - \\sin(x_0)}{h}$。\n   - 中心差分：$D_{\\mathrm{cen}}(x_0;h) = \\dfrac{\\sin(x_0 + h) - \\sin(x_0 - h)}{2h}$。\n\n3. 对于给定的 $x_0$ 和差分格式，需要最小化的误差度量：\n   - 绝对误差：$E(h) = \\left| D(x_0;h) - \\cos(x_0) \\right|$。\n\n4. 候选步长：\n   - 考虑等比序列 $h_k = 10^{a + k\\Delta}$，其中 $a=-16$，$\\Delta=10^{-2}$，且 $k \\in \\{0,1,2,\\dots,K\\}$，$K=1500$。这将产生一个有限集合 $\\{h_k\\}$，范围从 $10^{-16}$ 到 $10^{-1}$（含两端）。\n\n5. 选择规则：\n   - 对于每个测试用例，从上述候选集合中选择使 $E(h)$ 最小的 $h^\\star$。如果多个 $h$ 值达到相同的最小误差值，则选择其中最大的 $h$。\n\n6. 测试套件（所有角度均为弧度）：\n   - 情况 1：$x_0 = 1.0$，格式 = 中心差分。\n   - 情况 2：$x_0 = 1.0$，格式 = 向前差分。\n   - 情况 3：$x_0 = \\dfrac{\\pi}{2}$，格式 = 中心差分。\n   - 情况 4：$x_0 = \\dfrac{\\pi}{2}$，格式 = 向前差分。\n   - 情况 5：$x_0 = 0.0$，格式 = 中心差分。\n   - 情况 6：$x_0 = 0.123$，格式 = 向前差分。\n\n你的程序必须根据上述第 1-5 项，为六种情况中的每一种计算出最小化误差的步长 $h^\\star$。最终输出必须是单行文本，包含一个由逗号分隔的六个选定的 $h^\\star$ 值列表，按所列情况的顺序排列，并用方括号括起来。每个返回的步长值需使用科学记数法表示，小数点后保留六位有效数字，例如 $1.234567\\mathrm{e}{-08}$。因此，要求的最终输出格式为单行：\n[$h^\\star_1$,$h^\\star_2$,$h^\\star_3$,$h^\\star_4$,$h^\\star_5$,$h^\\star_6$]。",
            "solution": "该问题要求我们确定最优步长 $h^\\star$，以最小化函数 $f(x) = \\sin(x)$ 在若干点 $x_0$ 处的导数的有限差分近似的绝对误差。这是数值分析中的一个经典问题，它阐释了截断误差和舍入误差之间的基本权衡。\n\n我们首先分析数值微分中的误差来源。对于给定的步长 $h$，总绝对误差 $E(h)$ 是数值近似值 $D(x_0;h)$ 与真实导数 $f'(x_0)$ 之差的绝对值：\n$$\nE(h) = |D(x_0;h) - f'(x_0)|\n$$\n这个总误差可以看作是两个主要部分的和：截断误差 $E_{\\text{trunc}}(h)$ 和舍入误差 $E_{\\text{round}}(h)$。\n\n1.  **截断误差**：这种误差是近似公式本身固有的，源于对泰勒级数展开的截断。\n    -   对于**向前差分格式** $D_{\\mathrm{fwd}}(x_0;h) = \\frac{f(x_0+h) - f(x_0)}{h}$，我们将 $f(x_0+h)$ 在 $x_0$ 附近展开：\n        $$\n        f(x_0+h) = f(x_0) + h f'(x_0) + \\frac{h^2}{2} f''(x_0) + O(h^3)\n        $$\n        将其代入 $D_{\\mathrm{fwd}}$ 的公式可得：\n        $$\n        D_{\\mathrm{fwd}}(x_0;h) = f'(x_0) + \\frac{h}{2} f''(x_0) + O(h^2)\n        $$\n        因此，主阶截断误差与 $h$ 成正比：\n        $$\n        E_{\\text{trunc, fwd}}(h) = \\left| \\frac{h}{2} f''(x_0) \\right|\n        $$\n        这是一种一阶精度方法。对于 $f(x)=\\sin(x)$，我们有 $f''(x)=-\\sin(x)$，所以 $E_{\\text{trunc, fwd}}(h) = \\frac{h}{2} |\\sin(x_0)|$。\n\n    -   对于**中心差分格式** $D_{\\mathrm{cen}}(x_0;h) = \\frac{f(x_0+h) - f(x_0-h)}{2h}$，我们对 $f(x_0+h)$ 和 $f(x_0-h)$ 使用泰勒展开：\n        $$\n        f(x_0 \\pm h) = f(x_0) \\pm h f'(x_0) + \\frac{h^2}{2} f''(x_0) \\pm \\frac{h^3}{6} f'''(x_0) + O(h^4)\n        $$\n        将 $f(x_0+h)$ 的展开式减去 $f(x_0-h)$ 的展开式可得：\n        $$\n        f(x_0+h) - f(x_0-h) = 2h f'(x_0) + \\frac{h^3}{3} f'''(x_0) + O(h^5)\n        $$\n        除以 $2h$，我们得到：\n        $$\n        D_{\\mathrm{cen}}(x_0;h) = f'(x_0) + \\frac{h^2}{6} f'''(x_0) + O(h^4)\n        $$\n        主阶截断误差与 $h^2$ 成正比：\n        $$\n        E_{\\text{trunc, cen}}(h) = \\left| \\frac{h^2}{6} f'''(x_0) \\right|\n        $$\n        这是一种二阶精度方法。对于 $f(x)=\\sin(x)$，我们有 $f'''(x)=-\\cos(x)$，所以 $E_{\\text{trunc, cen}}(h) = \\frac{h^2}{6} |\\cos(x_0)|$。\n\n    在这两种情况下，截断误差都随着 $h$ 的减小而减小。\n\n2.  **舍入误差**：这种误差源于计算机中浮点运算的有限精度。当 $h$ 非常小时，分子中的减法，例如 $f(x_0+h) - f(x_0)$，涉及两个几乎相等的数。这会导致有效数字的损失，这种效应被称为灾难性抵消。计算 $f(x)$ 时的误差大致与机器 epsilon $\\epsilon_{\\text{mach}}$ 以及 $f(x)$ 的大小成正比。因此，分子中的误差量级为 $\\epsilon_{\\text{mach}} |f(x_0)|$。这个很小的绝对误差再被一个很小的数 $h$ 除，从而放大了舍入误差。\n    $$\n    E_{\\text{round}}(h) \\approx \\frac{\\epsilon_{\\text{mach}} |f(x_0)|}{h}\n    $$\n    与截断误差不同，舍入误差随着 $h$ 的减小而*增大*。\n\n总误差 $E(h) \\approx E_{\\text{trunc}}(h) + E_{\\text{round}}(h)$ 是一个关于 $h$ 的递减函数和一个关于 $1/h$ 的递增函数之和。这个和在某个最优步长 $h^\\star$ 处存在一个最小值。当 $h > h^\\star$ 时，误差由截断误差主导；当 $h  h^\\star$ 时，误差由舍入误差主导。\n\n该问题要求在一个离散的有限候选步长集合 $\\{h_k\\}$ 上对 $h^\\star$ 进行经验性搜索，其中 $h_k = 10^{-16 + k \\cdot 10^{-2}}$，对于 $k \\in \\{0, 1, \\dots, 1500\\}$。对于每个测试用例，算法流程如下：\n\n1.  定义点 $x_0$ 和数值微分格式（向前或中心）。\n2.  计算精确导数，$d_{\\text{true}} = \\cos(x_0)$。\n3.  生成从最小到最大排序的候选步长集合 $\\{h_k\\}$。\n4.  将最小误差 $E_{\\min}$ 初始化为无穷大，最优步长 $h^\\star$ 初始化为一个占位符值。\n5.  遍历集合中的每个候选步长 $h_k$。\n    a. 使用指定的格式计算数值导数 $D(x_0; h_k)$。\n    b. 计算绝对误差 $E(h_k) = |D(x_0; h_k) - d_{\\text{true}}|$。\n    c. 将 $E(h_k)$ 与 $E_{\\min}$ 比较。如果 $E(h_k) \\le E_{\\min}$，则更新 $E_{\\min} = E(h_k)$ 和 $h^\\star = h_k$。这个更新规则确保了，如果多个 $h_k$ 值产生相同的最小误差，所选的将是最大的那个，因为迭代是从较小的 $h_k$ 向较大的 $h_k$ 进行的。这直接满足了问题陈述中指定的平局决胜规则。\n6.  遍历所有 $h_k$ 后，$h^\\star$ 的最终值就是该测试用例所要求的结果。\n\n对所有六个指定的测试用例重复此过程。然后收集得到的最优步长，并根据输出规范进行格式化。对于 $x_0 = \\pi/2$ 处的中心差分，出现了一个特殊情况。由于 $\\sin(\\pi/2+h) = \\cos(h)$ 和 $\\sin(\\pi/2-h) = \\cos(h)$，分子 $f(x_0+h) - f(x_0-h)$ 在数学上为零。对于很大范围内的 $h$ 值，数值近似产生的误差都接近于机器精度。在这种情况下，选择最大 $h$ 作为平局决胜的规则变得至关重要。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the optimal finite-difference step size h by minimizing absolute error.\n\n    The function iterates through a set of candidate step sizes for six different\n    test cases involving forward and central difference approximations of the\n    derivative of sin(x). It finds the step size h that minimizes the\n    absolute error |D(x0;h) - cos(x0)|.\n    \"\"\"\n    # Define the six test cases as per the problem statement.\n    # Each case is a tuple: (x0, 'scheme_name')\n    test_cases = [\n        (1.0, 'central'),\n        (1.0, 'forward'),\n        (np.pi / 2, 'central'),\n        (np.pi / 2, 'forward'),\n        (0.0, 'central'),\n        (0.123, 'forward'),\n    ]\n\n    # Generate the candidate step sizes h_k = 10^(a + k*Delta)\n    a = -16.0\n    delta = 1e-2\n    K = 1500\n    exponents = a + np.arange(K + 1) * delta\n    h_values = np.power(10.0, exponents)\n\n    optimal_h_results = []\n\n    for x0, scheme in test_cases:\n        true_derivative = np.cos(x0)\n        \n        min_error = np.inf\n        optimal_h = -1.0\n\n        # Iterate through all candidate step sizes to find the minimum error.\n        # h_values are sorted in increasing order.\n        for h in h_values:\n            numerical_derivative = 0.0\n            if scheme == 'forward':\n                # Forward difference: (f(x+h) - f(x)) / h\n                numerical_derivative = (np.sin(x0 + h) - np.sin(x0)) / h\n            elif scheme == 'central':\n                # Central difference: (f(x+h) - f(x-h)) / (2h)\n                numerical_derivative = (np.sin(x0 + h) - np.sin(x0 - h)) / (2 * h)\n\n            error = np.abs(numerical_derivative - true_derivative)\n\n            # If the current error is less than or equal to the minimum error found so far,\n            # update the minimum error and the optimal h.\n            # Because we iterate from smallest h to largest h, this correctly implements\n            # the tie-breaking rule: \"select the largest such h\".\n            if error = min_error:\n                min_error = error\n                optimal_h = h\n        \n        optimal_h_results.append(optimal_h)\n\n    # Format the results as specified: scientific notation with 6 decimal places.\n    formatted_results = [f\"{h:.6e}\" for h in optimal_h_results]\n    \n    # Print the final output in the required single-line format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "模拟物理系统（如行星轨道或分子振动）的长期演化对数值方法的稳定性提出了更高的要求。这个练习对比了一个非辛积分器（前向欧拉法）和一个辛积分器（速度Verlet算法）在模拟单摆运动时的表现。通过分析能量的长期漂移 ，您将深刻体会到，对于哈密顿系统，选择一个能保持其内在几何结构的积分器对于保证长期稳定性和物理真实性是至关重要的。",
            "id": "2421691",
            "problem": "您需要编写一个完整、可运行的程序，该程序比较一个使用非辛时间积分器和一个使用辛时间积分器演化的单摆的长期能量行为。使用单位长度、单位质量和单位引力加速度的无量纲单摆，其运动方程为\n$$\n\\frac{d\\theta}{dt}=\\omega,\\quad \\frac{d\\omega}{dt}=-\\sin(\\theta),\n$$\n其中 $\\theta$ 是角位移，$\\omega$ 是角速度。总机械能为\n$$\nE(\\theta,\\omega)=\\frac{1}{2}\\,\\omega^2 + \\left(1-\\cos\\theta\\right).\n$$\n角度必须以弧度为单位。所有量均为无量纲。实现一个非辛积分器（前向显式欧拉格式）和一个辛积分器（速度Verlet格式）。对于每次模拟，在长时程上计算每个时间步的能量，并量化长期能量漂移。\n\n对于每个测试用例，从初始状态 $(\\theta(0),\\omega(0))$、恒定时间步长 $\\Delta t$ 和总时间 $T$ 开始，您必须：\n- 使用前向显式欧拉方法，在区间 $[0,T]$ 上以步长 $\\Delta t$ 模拟该系统。\n- 使用速度Verlet方法，在相同的区间和步长上模拟该系统。\n- 对于每种方法，使用在时间 $t_n=n\\,\\Delta t$（其中 $N=T/\\Delta t$）的离散能量时间序列 $\\{E_n\\}_{n=0}^N$ 计算以下指标：\n  1. 最终相对能量误差，\n  $$\n  \\frac{E_N - E_0}{E_0}.\n  $$\n  2. $E_n$ 相对于 $t_n$ 的线性最小二乘漂移率除以 $E_0$（这是 $(t_n,E_n)$ 的最佳拟合线的斜率除以 $E_0$），这是一个每单位时间的无量纲漂移率。\n  3. 最大绝对相对能量偏差，\n  $$\n  \\max_{0\\le n\\le N}\\frac{|E_n - E_0|}{E_0}.\n  $$\n\n使用以下初始条件和数值参数的测试套件；所有角度均以弧度为单位：\n- 案例 1：$\\theta(0)=0.1$, $\\omega(0)=0.0$, $\\Delta t=0.01$, $T=100.0$。\n- 案例 2：$\\theta(0)=1.0$, $\\omega(0)=0.0$, $\\Delta t=0.05$, $T=200.0$。\n- 案例 3：$\\theta(0)=0.5$, $\\omega(0)=0.0$, $\\Delta t=0.2$, $T=100.0$。\n- 案例 4：$\\theta(0)=3.0$, $\\omega(0)=0.0$, $\\Delta t=0.01$, $T=200.0$。\n\n您的程序必须为每个案例生成一个包含六个实数的列表，顺序如下：\n$$\n\\left[\\text{欧拉法最终相对误差},\\ \\text{Verlet法最终相对误差},\\ \\text{欧拉法相对漂移率},\\ \\text{Verlet法相对漂移率},\\ \\text{欧拉法最大相对偏差},\\ \\text{Verlet法最大相对偏差}\\right].\n$$\n将四个案例的结果汇总成一个单一的列表的列表，保持上述给定的案例顺序。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，`[[a,b,c,d,e,f],[...],...]`）。所有输出均为无量纲实数。不需要绘制图表，也不应打印任何其他输出。",
            "solution": "该问题要求通过将非辛积分器（前向显式欧拉方法）和辛积分器（速度Verlet方法）应用于无量纲单摆来进行比较。目标是量化和对比它们的长期能量守恒特性。分析将首先验证问题陈述的有效性，然后定义物理系统和数值格式，最后概述计算所需指标的实现方案。\n\n该问题被确定为有效。它在科学上基于经典力学和数值分析的原理。方程组、能量函数、数值方法和评估指标都是标准且明确定义的。问题是自洽的，为每个测试用例提供了所有必要的参数。没有矛盾、歧义或事实不准确之处。因此，我们着手进行求解。\n\n无量纲单摆的动力学由以下两个一阶常微分方程组描述：\n$$\n\\frac{d\\theta}{dt} = \\omega\n$$\n$$\n\\frac{d\\omega}{dt} = -\\sin(\\theta)\n$$\n这里，$\\theta$ 是与垂直方向的角位移，$\\omega$ 是角速度。系统的总机械能 $E$ 是其动能和势能之和，由下式给出：\n$$\nE(\\theta, \\omega) = \\frac{1}{2}\\omega^2 + (1 - \\cos\\theta)\n$$\n其中势能在稳定平衡点 $\\theta=0$ 处为零。对于一个孤立的物理系统，这个能量必须是守恒的。\n\n我们现在将定义两种数值积分器，用于在离散的时间步长集合 $t_n = n \\Delta t$ 上近似求解 $(\\theta(t), \\omega(t))$。\n\n**1. 前向显式欧拉方法 (Forward Explicit Euler Method):**\n前向欧拉方法是一种一阶、非辛的积分器。它使用以下更新规则将时间 $t_n$ 的状态 $(\\theta_n, \\omega_n)$ 推进到时间 $t_{n+1} = t_n + \\Delta t$ 的状态 $(\\theta_{n+1}, \\omega_{n+1})$：\n$$\n\\theta_{n+1} = \\theta_n + \\Delta t \\cdot \\omega_n\n$$\n$$\n\\omega_{n+1} = \\omega_n - \\Delta t \\cdot \\sin(\\theta_n)\n$$\n由于其非辛性，该方法不能保持哈密顿系统相空间流的几何结构。局部截断误差的阶数为 $O(\\Delta t^2)$，在许多步之后会系统性地累积。对于像单摆这样的振荡系统，这通常会导致计算出的能量出现长期漂移，通常是增加。能量误差预计会随时间 $T$ 线性增长。\n\n**2. 速度Verlet方法 (Velocity Verlet Method):**\n速度Verlet方法是一种二阶、辛积分器。它专为形如 $\\ddot{x} = a(x)$ 的系统设计，单摆系统 $\\ddot{\\theta} = -\\sin(\\theta)$ 正是这种情况。更新分三步执行：\n首先，将速度推进半步：\n$$\n\\omega_{n+1/2} = \\omega_n - \\sin(\\theta_n) \\frac{\\Delta t}{2}\n$$\n其次，使用这个中间速度将位置推进一整步：\n$$\n\\theta_{n+1} = \\theta_n + \\omega_{n+1/2} \\Delta t\n$$\n最后，使用新位置处的加速度将速度推进剩下的半步：\n$$\n\\omega_{n+1} = \\omega_{n+1/2} - \\sin(\\theta_{n+1}) \\frac{\\Delta t}{2}\n$$\n辛积分器在设计上会守恒一个与系统真实哈密顿量非常接近的“影子哈密顿量”。因此，它们不会表现出长期的能量漂移。计算出的能量 $E_n$ 会在真实的初始能量 $E_0$ 附近振荡，但误差 $|E_n - E_0|$ 在非常长（通常是指数级长）的模拟时间内保持有界。\n\n为了量化这些行为，我们将从离散能量时间序列 $\\{E_n\\}_{n=0}^N$（其中 $N=T/\\Delta t$）中计算三个指标：\n1.  **最终相对能量误差，$\\frac{E_N - E_0}{E_0}$**：该指标衡量整个模拟区间内的净能量变化。对于欧拉方法，预计该值会显著不为零，而对于Verlet方法，该值应接近于零。\n2.  **相对漂移率**：这是拟合点 $(t_n, E_n)$ 的普通最小二乘法直线的斜率 $m$，并由初始能量 $E_0$ 归一化。斜率通过公式 $m = \\frac{\\sum_{n=0}^{N} (t_n - \\bar{t})(E_n - \\bar{E})}{\\sum_{n=0}^{N} (t_n - \\bar{t})^2}$ 计算，其中 $\\bar{t}$ 和 $\\bar{E}$ 是平均值。该指标直接量化了长期能量漂移的平均速率。我们预计欧拉方法会得到一个显著的正值，而Verlet方法会得到一个接近零的值。\n3.  **最大绝对相对能量偏差，$\\max_{0\\le n\\le N}\\frac{|E_n - E_0|}{E_0}$**：该指标捕捉能量波动的最大幅度。对于欧拉方法，这主要由长期漂移决定。对于Verlet方法，它衡量的是有界能量振荡的幅度。\n\n实现将包括一个主程序，该程序遍历四个指定的测试用例。对于每个案例，分别使用欧拉和Verlet积分器执行模拟。每次运行的完整状态历史 $(\\theta_n, \\omega_n)$ 都会被存储。根据这些历史数据，计算出相应的能量时间序列 $\\{E_n\\}$。然后，为每个积分器计算三个指标。将得到的六个值收集起来并按要求格式化。这种系统化的方法可以对积分器进行直接和定量的比较，从而展示辛速度Verlet方法优越的长期稳定性。",
            "answer": "```python\nimport numpy as np\nimport json\n\ndef energy(theta, omega):\n    \"\"\"\n    Calculates the non-dimensional energy of the simple pendulum.\n    \"\"\"\n    return 0.5 * omega**2 + (1.0 - np.cos(theta))\n\ndef euler_step(theta, omega, dt):\n    \"\"\"\n    Performs a single step of the forward explicit Euler method.\n    \"\"\"\n    theta_next = theta + dt * omega\n    omega_next = omega - dt * np.sin(theta)\n    return theta_next, omega_next\n\ndef verlet_step(theta, omega, dt):\n    \"\"\"\n    Performs a single step of the velocity Verlet method.\n    \"\"\"\n    # Force (acceleration) function\n    def acceleration(th):\n        return -np.sin(th)\n\n    omega_half = omega + acceleration(theta) * (dt / 2.0)\n    theta_next = theta + omega_half * dt\n    omega_next = omega_half + acceleration(theta_next) * (dt / 2.0)\n    return theta_next, omega_next\n\ndef run_simulation(integrator_step_func, theta0, omega0, dt, T):\n    \"\"\"\n    Runs a simulation for the pendulum dynamics using a given integrator.\n    \"\"\"\n    if dt = 0:\n        raise ValueError(\"Time step dt must be positive.\")\n    N = int(round(T / dt))\n    num_points = N + 1\n    \n    theta_hist = np.zeros(num_points)\n    omega_hist = np.zeros(num_points)\n    \n    theta_hist[0] = theta0\n    omega_hist[0] = omega0\n    \n    theta_n, omega_n = theta0, omega0\n    for n in range(N):\n        theta_n, omega_n = integrator_step_func(theta_n, omega_n, dt)\n        theta_hist[n + 1] = theta_n\n        omega_hist[n + 1] = omega_n\n        \n    return theta_hist, omega_hist\n\ndef calculate_metrics(T, dt, theta_hist, omega_hist):\n    \"\"\"\n    Calculates the three required energy metrics from a simulation history.\n    \"\"\"\n    num_points = len(theta_hist)\n    times = np.linspace(0, T, num_points)\n    \n    energies = energy(theta_hist, omega_hist)\n    E0 = energies[0]\n    EN = energies[-1]\n\n    if E0 == 0:\n        # This case is avoided by the problem's initial conditions,\n        # but as a safeguard, return NaNs.\n        return np.nan, np.nan, np.nan\n\n    # Metric 1: Final relative energy error\n    final_rel_err = (EN - E0) / E0\n\n    # Metric 2: Linear least-squares drift rate divided by E0\n    # The slope of the best-fit line to (times, energies) is the first\n    # coefficient returned by np.polyfit with deg=1.\n    slope = np.polyfit(times, energies, deg=1)[0]\n    rel_drift_rate = slope / E0\n\n    # Metric 3: Maximum absolute relative energy deviation\n    max_abs_rel_dev = np.max(np.abs((energies - E0) / E0))\n    \n    return final_rel_err, rel_drift_rate, max_abs_rel_dev\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # (theta(0), omega(0), dt, T)\n        (0.1, 0.0, 0.01, 100.0),\n        (1.0, 0.0, 0.05, 200.0),\n        (0.5, 0.0, 0.2, 100.0),\n        (3.0, 0.0, 0.01, 200.0),\n    ]\n\n    all_results = []\n    for theta0, omega0, dt, T in test_cases:\n        # Run simulation with Forward Euler\n        euler_theta, euler_omega = run_simulation(euler_step, theta0, omega0, dt, T)\n        euler_metrics = calculate_metrics(T, dt, euler_theta, euler_omega)\n\n        # Run simulation with Velocity Verlet\n        verlet_theta, verlet_omega = run_simulation(verlet_step, theta0, omega0, dt, T)\n        verlet_metrics = calculate_metrics(T, dt, verlet_theta, verlet_omega)\n        \n        # Assemble the 6 metrics for the current case in the specified order\n        case_results = [\n            euler_metrics[0],  # Euler final relative error\n            verlet_metrics[0], # Verlet final relative error\n            euler_metrics[1],  # Euler relative drift rate\n            verlet_metrics[1], # Verlet relative drift rate\n            euler_metrics[2],  # Euler max relative deviation\n            verlet_metrics[2]  # Verlet max relative deviation\n        ]\n        all_results.append(case_results)\n\n    # Print the final result in the exact specified format `[[...],...]`\n    # Using json.dumps and replacing spaces ensures a compact, correct format.\n    print(json.dumps(all_results).replace(\" \", \"\"))\n\nsolve()\n```"
        }
    ]
}