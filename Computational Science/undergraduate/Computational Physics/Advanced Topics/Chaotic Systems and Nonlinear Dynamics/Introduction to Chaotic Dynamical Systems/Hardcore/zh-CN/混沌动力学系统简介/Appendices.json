{
    "hands_on_practices": [
        {
            "introduction": "尽管混沌系统的定义是其不可预测性，但它们的长期行为可以表现出显著的统计规律性。本练习将使用处于完全混沌状态（$r=4$）的逻辑斯蒂映射来探索这一概念。通过模拟一条长轨迹并绘制其访问点的分布，你将以数值方式构建系统的不变密度，并将其与已知的解析形式进行比较，从而为遍历性在混沌系统中的作用提供一个具体实例 。",
            "id": "2403543",
            "problem": "考虑由递推关系 $x_{n+1} = r\\,x_n(1 - x_n)$ 定义的一维逻辑斯蒂映射，其中 $r = 4$，初始条件 $x_0 \\in (0,1)$。当 $r = 4$ 时，已知这个离散时间动力系统在单位区间上表现出混沌行为。迭代值所访问的值的不变密度 $p(x)$ 由 $p(x) = \\frac{1}{\\pi\\sqrt{x(1-x)}}$（对于 $x \\in (0,1)$）给出，其他情况下 $p(x) = 0$。对于一个给定的正整数 $B$，将 $[0,1]$ 均匀划分为 $B$ 个区间，其边界为 $0 = e_0  e_1  \\dots  e_B = 1$，其中 $e_k = \\frac{k}{B}$。将这些区间解释为半开区间 $[e_k, e_{k+1})$（对于 $k = 0,1,\\dots,B-2$），最后一个区间为 $[e_{B-1}, e_B]$。对于指定的非负整数预迭代次数 $M$ 和正整数样本量 $N$，生成迭代序列 $\\{x_{M+1}, x_{M+2}, \\dots, x_{M+N}\\}$，并构建经验区间概率向量 $\\mathbf{p}^{\\text{emp}} \\in \\mathbb{R}^B$，其第 $k$ 个分量是这 $N$ 个值中落入区间 $k$ 的比例。设理论区间概率向量 $\\mathbf{p}^{\\text{th}} \\in \\mathbb{R}^B$ 定义为\n$$\np^{\\text{th}}_k = \\int_{e_k}^{e_{k+1}} p(x)\\,dx \\quad \\text{对于 } k = 0,1,\\dots,B-1,\n$$\n其中 $p(x) = \\frac{1}{\\pi\\sqrt{x(1-x)}}$，并且用于计算该积分的任何反三角函数的角度单位必须是弧度。仅使用上述数学定义。对于下方的每个测试用例，计算标量\n$$\nE = \\sum_{k=0}^{B-1} \\left| p^{\\text{emp}}_k - p^{\\text{th}}_k \\right|,\n$$\n此值是经验与理论区间概率向量之间的 $\\ell^1$ 距离。\n\n您的程序必须为以下每个测试用例计算 $E$。在每个元组中，参数以 $(N, M, B, x_0)$ 的形式给出，且 $r=4$ 固定不变：\n\n- 测试 1：$(N=\\;200000,\\; M=\\;5000,\\; B=\\;400,\\; x_0=\\;0.123456789)$。\n- 测试 2：$(N=\\;100000,\\; M=\\;1000,\\; B=\\;200,\\; x_0=\\;10^{-12})$。\n- 测试 3：$(N=\\;\\;\\;5000,\\; M=\\;\\;500,\\; B=\\;\\;50,\\; x_0=\\;0.37)$。\n- 测试 4：$(N=\\;100000,\\; M=\\;1000,\\; B=\\;200,\\; x_0=\\;0.999999123)$。\n\n所有迭代值和计算都是无量纲的。在适用的情况下，角度以弧度表示。要求的最终输出是一行，包含与上述测试相对应的四个 $E$ 值，每个值四舍五入到六位小数，形式为用方括号括起来的逗号分隔列表，例如 $[e_1,e_2,e_3,e_4]$，其中每个 $e_i$ 是一个小数点后有六位数字的十进制数。您的程序必须仅输出这一行格式作为其唯一输出。",
            "solution": "问题陈述经评估有效。它具有科学依据，提法明确，且客观。它提出了一个混沌动力系统研究中的标准计算练习，特别是关于逻辑斯蒂映射的遍历性质。获得唯一解所需的所有定义、参数和条件都已明确无误地给出，没有歧义或矛盾。我们将直接进行求解。\n\n问题要求计算逻辑斯蒂映射的经验生成概率分布与其理论对应分布之间的 $\\ell^1$ 距离，记为 $E$。逻辑斯蒂映射由以下递推关系给出：\n$$\nx_{n+1} = r x_n (1 - x_n)\n$$\n其中参数 $r$ 固定为 $r=4$。对于由元组 $(N, M, B, x_0)$ 定义的每个测试用例，其中 $N$ 是样本量，$M$ 是预迭代次数，$B$ 是区间数量，$x_0$ 是初始条件，我们必须执行以下步骤。\n\n首先，我们必须生成经验数据。从初始条件 $x_0 \\in (0,1)$ 开始，我们迭代该映射。前 $M$ 次迭代值被舍弃，以使系统状态收敛到吸引子上，从而有效消除初始条件带来的瞬态效应。随后，我们生成并存储 $N$ 个迭代值，形成集合 $\\{x_{M+1}, x_{M+2}, \\dots, x_{M+N}\\}$。\n\n其次，我们构建经验概率向量 $\\mathbf{p}^{\\text{emp}} \\in \\mathbb{R}^B$。区间 $[0,1]$ 被划分为 $B$ 个均匀的子区间。区间边界为 $e_k = k/B$，其中 $k \\in \\{0, 1, \\dots, B\\}$。第 $k$ 个区间（对于 $k \\in \\{0, 1, ..., B-1\\}$）是区间 $[e_k, e_{k+1})$。对最右侧的边界做了特殊处理，使得最后一个区间是闭合的，即 $[e_{B-1}, e_B]$。我们计算落入每个区间 $k$ 的迭代值数量 $c_k$。那么，区间 $k$ 的经验概率由以下比例给出：\n$$\np^{\\text{emp}}_k = \\frac{c_k}{N}\n$$\n\n第三，我们必须确定理论概率向量 $\\mathbf{p}^{\\text{th}} \\in \\mathbb{R}^B$。对于 $r=4$ 的逻辑斯蒂映射，迭代值的不变概率密度函数已知为：\n$$\np(x) = \\frac{1}{\\pi\\sqrt{x(1-x)}}\n$$\n对于 $x \\in (0,1)$。一个迭代值落入区间 $k$ 的理论概率是该密度函数在该区间上的积分：\n$$\np^{\\text{th}}_k = \\int_{e_k}^{e_{k+1}} p(x) \\,dx = \\int_{k/B}^{(k+1)/B} \\frac{1}{\\pi\\sqrt{x(1-x)}} \\,dx\n$$\n该积分可以解析求解。设 $F(x)$ 是 $p(x)$ 的原函数。我们进行换元 $x = \\sin^2(\\theta)$，因此 $dx = 2\\sin(\\theta)\\cos(\\theta)\\,d\\theta$。通过此换元，不定积分变为：\n$$\nF(x) = \\int \\frac{1}{\\pi\\sqrt{\\sin^2(\\theta)(1-\\sin^2(\\theta))}} (2\\sin(\\theta)\\cos(\\theta)\\,d\\theta) = \\int \\frac{2}{\\pi} \\,d\\theta = \\frac{2}{\\pi}\\theta + C\n$$\n反代换 $\\theta = \\arcsin(\\sqrt{x})$，我们得到原函数：\n$$\nF(x) = \\frac{2}{\\pi}\\arcsin(\\sqrt{x})\n$$\n根据微积分基本定理，区间 $k$ 的理论概率为：\n$$\np^{\\text{th}}_k = F(e_{k+1}) - F(e_k) = \\frac{2}{\\pi} \\left( \\arcsin\\left(\\sqrt{\\frac{k+1}{B}}\\right) - \\arcsin\\left(\\sqrt{\\frac{k}{B}}\\right) \\right)\n$$\n按照规定，反正弦函数的角度单位均为弧度。\n\n最后，我们计算所需的误差度量 $E$，即两个概率向量之间的 $\\ell^1$ 距离：\n$$\nE = \\sum_{k=0}^{B-1} \\left| p^{\\text{emp}}_k - p^{\\text{th}}_k \\right|\n$$\n此过程通过算法实现，并应用于四个指定的测试用例。然后将结果按要求格式化。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for all test cases and prints the formatted result.\n    \"\"\"\n\n    def calculate_error(N, M, B, x0):\n        \"\"\"\n        Calculates the error metric E for a single test case.\n\n        Args:\n            N (int): Sample size.\n            M (int): Burn-in count.\n            B (int): Number of bins.\n            x0 (float): Initial condition.\n\n        Returns:\n            float: The calculated L1 error E.\n        \"\"\"\n        r = 4.0\n\n        # Step 1: Generate the sequence of iterates for the logistic map.\n        # Use float64 for precision.\n        x = np.float64(x0)\n        \n        # Burn-in phase to let the system settle onto the attractor.\n        for _ in range(M):\n            x = r * x * (1.0 - x)\n\n        # Sampling phase.\n        iterates = np.zeros(N, dtype=np.float64)\n        for i in range(N):\n            x = r * x * (1.0 - x)\n            iterates[i] = x\n\n        # Step 2: Calculate the empirical probability vector p_emp.\n        # np.histogram correctly handles the half-open intervals on the right,\n        # which matches the problem's specification.\n        counts, _ = np.histogram(iterates, bins=B, range=(0.0, 1.0))\n        p_emp = counts / N\n\n        # Step 3: Calculate the theoretical probability vector p_th.\n        # The bin edges are e_k = k/B.\n        bin_edges = np.linspace(0.0, 1.0, B + 1, dtype=np.float64)\n        \n        # The antiderivative is F(x) = (2/pi) * arcsin(sqrt(x)).\n        # We evaluate F at all bin edges.\n        F_at_edges = (2.0 / np.pi) * np.arcsin(np.sqrt(bin_edges))\n        \n        # p_th_k = F(e_{k+1}) - F(e_k). This is vectorized for efficiency.\n        p_th = F_at_edges[1:] - F_at_edges[:-1]\n\n        # Step 4: Calculate the L1 error metric E.\n        E = np.sum(np.abs(p_emp - p_th))\n        \n        return E\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (200000, 5000, 400, 0.123456789),\n        (100000, 1000, 200, 10**-12),\n        (5000, 500, 50, 0.37),\n        (100000, 1000, 200, 0.999999123),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, M, B, x0 = case\n        result = calculate_error(N, M, B, x0)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Each result is formatted to six decimal places.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "当一个系统的参数被推到稳定混沌区域之外时会发生什么？本练习将研究逻辑斯蒂映射在 $r > 4$ 时的瞬态混沌现象，此时轨道在逃逸到无穷大之前会暂时表现出混沌行为。你将学习通过计算逃逸时间和有限时间李雅普诺夫指数来量化这种行为，后者是衡量系统对初始条件敏感性的关键指标 。",
            "id": "2403547",
            "problem": "考虑由递推关系定义的一维逻辑斯谛映射\n$$x_{n+1} = f_r(x_n) = r\\,x_n\\,(1 - x_n), \\quad n = 0,1,2,\\dots,$$\n其控制参数为 $$r > 4$$，初始条件为 $$x_0 \\in [0,1]。$$ 对于这样的 $$r$$，$$[0,1]$$ 中的大多数初始条件会产生在有限步数内于 $$[0,1]$$ 中混沌地游走的轨迹，然后逃离该区间并随后发散到负无穷大。这种行为被称为由 $$[0,1]$$ 内的混沌鞍所支持的瞬态混沌。\n\n仅根据上述定义和标准微积分（导数和绝对值），编写一个程序，使用以下定义来量化轨迹发散的速度。\n\n1) 将逃逸时间 $$\\tau(x_0;r)$$ 定义为使得 $$x_n \\notin [0,1]$$ 成立的最小非负整数 $$n$$；如果在明确的迭代上限（如下文规定）内不存在这样的 $$n$$，则记为 $$\\tau(x_0;r) = -1。$$\n\n2) 将到幅值阈值 $$T > 0$$ 的发散时间定义为\n$$\\sigma(x_0;r,T) = \\min\\{n \\ge 0 : |x_n| \\ge T\\},$$\n约定如果轨迹在规定的上限内未能从 $$[0,1]$$ 逃逸，则设 $$\\sigma(x_0;r,T) = -1。$$ 如果轨迹已经逃逸，但在逃逸后的次级上限（如下文规定）内未能达到 $$|x_n| \\ge T$$，也设 $$\\sigma(x_0;r,T) = -1。$$\n\n3) 将仅在轨迹停留在 $$[0,1]$$ 内时累积的有限时间李雅普诺夫指数定义为\n$$\\lambda_{N}(x_0;r) = \\frac{1}{N} \\sum_{k=0}^{N-1} \\ln\\left| f_r'(x_k) \\right|,$$\n其中 $$f_r'(x) = r(1 - 2x)$$ 且 $$N = \\min\\big(\\tau(x_0;r), N_{\\text{in,max}}\\big)。$$ 如果 $$N = 0$$，按惯例定义 $$\\lambda_N(x_0;r) = 0$$。在实际的浮点数计算中，当计算 $$\\ln|f_r'(x_k)|$$ 时，如果 $$|f_r'(x_k)|$$ 小于一个下限值 $$\\varepsilon_d$$，则在取对数前用 $$\\varepsilon_d$$ 替换它，以避免因 $$\\ln(0)$$ 导致的未定义值。\n\n程序中使用的数值规范和约定：\n- 使用阈值 $$T = 10^6。$$\n- 在 $$[0,1]$$ 区间内允许的最大迭代次数为 $$N_{\\text{in,max}} = 200{,}000。$$\n- 逃逸后（即，一旦某个迭代值首次满足 $$x_n \\notin [0,1]$$），最多允许额外进行 $$N_{\\text{after,max}} = 1{,}000$$ 次迭代来达到阈值 $$T。$$\n- 在计算 $$\\ln|f_r'(x_k)|$$ 时，使用导数幅值的下限 $$\\varepsilon_d = 10^{-300}。$$\n- 所有量都是无量纲的；不适用任何物理单位。\n- 报告的有限时间李雅普诺夫指数需四舍五入到六位小数。\n\n测试套件：\n对以下每一组参数 $$(r,x_0)$$，计算三元组 $$\\big[\\tau(x_0;r),\\,\\sigma(x_0;r,T),\\,\\lambda_{N}(x_0;r)\\big]$$：\n- 情况1：$$r = 4.01,$$ $$x_0 = 0.5001。$$\n- 情况2：$$r = 4.2,$$ $$x_0 = 0.123456789。$$\n- 情况3：$$r = 5.0,$$ $$x_0 = 0.9。$$\n- 情况4：$$r = 4.5,$$ $$x_0 = 0.0。$$\n- 情况5：$$r = 4.001,$$ $$x_0 = 0.2。$$\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个类JSON数组的结果，每个测试用例一个，按上面列出的顺序排列。每个结果都是一个列表，恰好包含三个数 $$[\\tau, \\sigma, \\lambda]$$，其中 $$\\tau$$ 和 $$\\sigma$$ 是整数，$$\\lambda$$ 是一个四舍五入到六位小数的浮点数。总输出必须是单行且没有空格，例如：\n$$\\texttt{[[tau1,sigma1,lambda1],[tau2,sigma2,lambda2],...]}。$$",
            "solution": "我们从逻辑斯谛映射的定义开始\n$$x_{n+1} = f_r(x_n) = r\\,x_n\\,(1-x_n),$$\n并考虑 $$r > 4$$ 和初始条件 $$x_0 \\in [0,1]。$$ 瞬态混沌现象源于 $$[0,1]$$ 区间内存在一个排斥典型轨迹的混沌鞍。计算的核心是量化离开 $$[0,1]$$ 的时间以及随后趋近于大的负值所需的时间。\n\n为什么离开 $$[0,1]$$ 的轨迹会发散到负无穷大。假设对于某个 $$n$$，我们有 $$x_n \\notin [0,1]。$$ 首先考虑 $$x_n > 1$$ 的情况。那么\n$$x_{n+1} = r\\,x_n\\,(1 - x_n) = -r\\,x_n\\,(x_n - 1)  0,$$\n因此，一旦向上穿越 $$1$$，下一个迭代值立即变为负数。现在假设 $$x_n  0$$。令 $$y_n = -x_n > 0$$。那么\n$$x_{n+1} = r\\,x_n\\,(1 - x_n) = r\\,(-y_n)\\,(1 + y_n) = -r\\,y_n\\,(1 + y_n),$$\n所以 $$x_{n+1}  0$$，因此一旦变为负数，所有后续迭代值都将保持为负数。此外，用 $$y_n = |x_n|$$ 来表示，我们有\n$$y_{n+1} = |x_{n+1}| = r\\,y_n\\,(1 + y_n) \\ge r\\,y_n^2.$$\n这个不等式表明，对于任何 $$y_n > 0$$，一旦 $$y_n \\ge 1$$，该序列就满足一个超二次增长下界，即使当 $$0  y_n  1$$ 时，重复迭代也必然会使 $$y_n$$ 超过 $$1$$，除非它落入某个特殊的轨道。此后，$$y_{n+1} \\ge r\\,y_n^2$$ 这个界限意味着会快速发散到无穷大。因此，一旦轨迹离开 $$[0,1]$$，它就会变为负数，其幅值趋于无穷大，我们将其解释为发散到负无穷大。\n\n逃逸时间。我们定义逃逸时间\n$$\\tau(x_0;r) = \\min\\{n \\ge 0 : x_n \\notin [0,1]\\},$$\n约定如果这个集合在预定的最大内部迭代次数 $$N_{\\text{in,max}}$$ 内为空，我们记为 $$\\tau = -1。$$ 在实践中，我们实现这个递推关系，从 $$x_0$$ 开始应用映射。在每个以 $$k = 0,1,2,\\dots$$ 索引的步骤中，我们：\n- 在 $$x_k$$ 处累积有限时间李雅普诺夫信息，并且\n- 计算 $$x_{k+1} = f_r(x_k)，$$\n- 测试 $$x_{k+1} \\notin [0,1]$$ 是否成立。满足条件的最小索引 $$k+1$$ 就是 $$\\tau。$$\n\n内部的有限时间李雅普诺夫指数。逻辑斯谛映射的导数是\n$$f_r'(x) = r(1 - 2x).$$\n限制在逃逸时间或迭代上限中较小者之前的内部动力学的有限时间李雅普诺夫指数为\n$$\\lambda_N(x_0;r) = \\frac{1}{N} \\sum_{k=0}^{N-1} \\ln\\left| r(1 - 2x_k) \\right|, \\quad N = \\min(\\tau, N_{\\text{in,max}}).$$\n如果 $$N = 0$$，我们定义 $$\\lambda_N = 0$$ 以避免除以零。在数值上，为避免对极接近零的值取自然对数（这可能在临界点 $$x = \\tfrac{1}{2}$$ 附近发生，此时 $$f_r'(x) = 0$$），我们采用一个下限值 $$\\varepsilon_d = 10^{-300}$$ 并计算\n$$\\ln\\left(\\max\\left(|f_r'(x_k)|,\\varepsilon_d\\right)\\right)。$$\n这是一种标准的数值正则化方法，它不改变典型轨道的理论定义，但可以防止在有限精度下出现未定义的操作。\n\n到阈值的发散时间。在时间 $$\\tau$$ 逃逸后，迭代值 $$x_\\tau \\notin [0,1]。$$ 如上所示，我们接着有 $$x_{\\tau+1}  0$$ 并且序列保持负值，幅值迅速增加。我们将到阈值的发散时间定义为\n$$\\sigma(x_0;r,T) = \\min\\{n \\ge 0 : |x_n| \\ge T\\}.$$\n因为对于所有 $$x_n \\in [0,1]$$，有 $$|x_n| \\le 1$$，所以阈值 $$T = 10^6$$ 只能在逃逸后达到。因此，如果轨迹在 $$N_{\\text{in,max}}$$ 步内没有逃逸，我们设 $$\\sigma = -1。$$ 如果它确实逃逸了，我们继续迭代最多 $$N_{\\text{after,max}}$$ 个额外步骤，在每一步后检查 $$|x_n| \\ge T$$ 是否成立。\n如果在这个逃逸后的上限内没有达到阈值，我们也设 $$\\sigma = -1。$$ 对于负迭代值，超二次增长界 $$|x_{n+1}| \\ge r |x_n|^2$$ 使得对于测试套件中的参数选择，它几乎肯定能非常快地达到阈值。\n\n每个测试用例 $$(r,x_0)$$ 的算法摘要：\n- 初始化 $$x \\leftarrow x_0$$，$$s \\leftarrow 0$$ 用于累积 $$\\sum \\ln|f_r'(x_k)|$$，并设 $$\\tau \\leftarrow -1。$$\n- 对于 $$k = 0,1,\\dots,N_{\\text{in,max}}-1:$$\n  - 计算 $$d_k = |r(1 - 2x)|$$，然后 $$s \\leftarrow s + \\ln(\\max(d_k,\\varepsilon_d))。$$\n  - 计算 $$x \\leftarrow f_r(x)。$$\n  - 如果 $$x \\notin [0,1]$$，设 $$\\tau \\leftarrow k+1$$ 并跳出循环。\n- 若 $$\\tau \\neq -1$$，则令 $$N \\leftarrow \\tau$$，否则 $$N \\leftarrow N_{\\text{in,max}}。$$ 如果 $$N = 0$$，设 $$\\lambda \\leftarrow 0;$$ 否则 $$\\lambda \\leftarrow s/N。$$\n- 如果 $$\\tau = -1$$，设 $$\\sigma \\leftarrow -1。$$\n- 否则，以当前的 $$x = x_\\tau$$，设 $$n \\leftarrow \\tau。$$ 在最多 $$N_{\\text{after,max}}$$ 步内：\n  - 如果 $$|x| \\ge T$$，设 $$\\sigma \\leftarrow n$$ 并停止。\n  - 否则更新 $$x \\leftarrow f_r(x)$$，增加 $$n \\leftarrow n+1$$，并继续。\n  - 如果循环结束而未达到 $$T$$，设 $$\\sigma \\leftarrow -1。$$\n- 报告 $$[\\tau, \\sigma, \\lambda]$$，其中 $$\\lambda$$ 四舍五入到六位小数。\n\n测试套件的覆盖范围：\n- 情况1（$$r = 4.01, x_0 = 0.5001$$）在临界点附近，$$r$$ 刚刚超过 $$4$$，用于探测长的瞬态行为。\n- 情况2（$$r = 4.2, x_0 = 0.123456789$$）是一个典型的混沌瞬态和逃逸。\n- 情况3（$$r = 5.0, x_0 = 0.9$$）从上边界附近开始，产生快速逃逸和快速发散。\n- 情况4（$$r = 4.5, x_0 = 0.0$$）是一条永不逃逸的特殊轨道；它保持在 $$0$$，所以 $$\\tau = -1$$ 且 $$\\lambda \\approx \\ln r。$$\n- 情况5（$$r = 4.001, x_0 = 0.2$$）非常接近 $$r=4$$，在逃逸前引发了更长的混沌瞬态。\n\n该程序精确地实现了这个逻辑，并打印出单行的、无空格的类JSON行：\n$$\\texttt{[[tau1,sigma1,lambda1],[tau2,sigma2,lambda2],...]}。$$",
            "answer": "```python\nimport math\nimport json\n\ndef logistic_step(r, x):\n    return r * x * (1.0 - x)\n\ndef compute_case(r, x0, T=1_000_000.0, N_in_max=200_000, N_after_max=1000, eps_d=1e-300):\n    # Initialize\n    x = x0\n    sum_log = 0.0\n    tau = -1  # escape time; -1 means no escape within cap\n    # Iterate while inside [0,1], up to N_in_max\n    for k in range(N_in_max):\n        # Accumulate finite-time Lyapunov exponent term at current x_k\n        df = r * (1.0 - 2.0 * x)\n        adf = abs(df)\n        if adf  eps_d:\n            adf = eps_d\n        sum_log += math.log(adf)\n        # Update to x_{k+1}\n        x_next = logistic_step(r, x)\n        # Check for escape at x_{k+1}\n        if not (0.0 = x_next = 1.0):\n            tau = k + 1  # first index for which x_n is outside\n            x = x_next\n            break\n        x = x_next\n\n    # Determine N for finite-time Lyapunov exponent\n    if tau == -1:\n        N = N_in_max\n    else:\n        N = tau\n    if N == 0:\n        lam = 0.0\n    else:\n        lam = sum_log / N\n\n    # Determine divergence time to threshold T\n    if tau == -1:\n        sigma = -1\n    else:\n        n = tau\n        # If already above threshold (rare), record; else iterate post-escape\n        if abs(x) >= T:\n            sigma = n\n        else:\n            sigma = -1\n            for _ in range(N_after_max):\n                x = logistic_step(r, x)\n                n += 1\n                if abs(x) >= T:\n                    sigma = n\n                    break\n\n    # Round Lyapunov exponent to six decimals as specified\n    lam_rounded = round(lam, 6)\n    return [tau, sigma, lam_rounded]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (4.01, 0.5001),\n        (4.2, 0.123456789),\n        (5.0, 0.9),\n        (4.5, 0.0),\n        (4.001, 0.2),\n    ]\n\n    results = []\n    for r, x0 in test_cases:\n        result = compute_case(r, x0)\n        results.append(result)\n\n    # Final print statement in the exact required format (no spaces).\n    print(json.dumps(results, separators=(',', ':')))\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "迭代动力学的原理不仅限于实数，它们在复平面上有着更为壮观的体现。本练习邀请你探索曼德博集合，这可以说是数学中最著名的分形。它源于在复平面上对简单二次映射 $z_{n+1} = z_n^2 + c$ 的迭代。通过检验哪些复数参数 $c$ 会导致有界轨道，你将亲手实现揭示这个具有无限复杂性和美感的数学对象的算法 。",
            "id": "2403617",
            "problem": "实现一个完整、可运行的程序，通过测试对于哪些复数参数 $c \\in \\mathbb{C}$，复二次映射的临界轨道保持有界，来探索曼德博集合。复二次映射由迭代式 $z_{n+1} = f_c(z_n) = z_n^2 + c$ 定义，其临界初始条件为 $z_0 = 0$。曼德博集合是所有使得轨道 $\\{z_n\\}_{n=0}^{\\infty}$ 有界的参数 $c$ 的集合。\n\n使用以下基本依据：\n- 迭代规则 $z_{n+1} = z_n^2 + c$ 在 $\\mathbb{C}$ 上定义了一个离散时间动力系统。\n- 复数 $z$ 的模为 $|z| = \\sqrt{\\operatorname{Re}(z)^2 + \\operatorname{Im}(z)^2}$。\n- 如果在迭代过程中 $|z_n|$ 超过了某个固定的逃逸半径 $R$，那么轨道将发散至无穷大。对于二次多项式族 $z^2 + c$，一个经过充分检验的标准事实是取 $R = 2$ 即可：如果对于某个 $n$ 有 $|z_n| > 2$，那么 $z$ 的轨道就会发散至无穷大。\n\n您的任务是：\n1. 实现一个函数，对于给定的参数 $c$，该函数从 $z_0 = 0$ 开始进行 $z_{n+1} = z_n^2 + c$ 的迭代，并根据以下数值判据返回一个布尔值，以指示轨道是否保持有界：\n   - 使用逃逸半径 $R = 2$。\n   - 使用最大迭代次数 $N = 10000$。\n   - 如果存在 $n \\in \\{0,1,2,\\dots,N-1\\}$ 使得 $|z_n| > R$，则判定轨道为无界。否则，判定其为有界。\n2. 将您的函数应用于下面列出的参数测试套件，并计算每个参数的布尔结果，其中 $\\mathrm{True}$ 表示“在 $N$ 次迭代内有界”，$\\mathrm{False}$ 表示“在 $N$ 次迭代内逃逸”。\n3. 虚数单位是 $i = \\sqrt{-1}$，并且任何复数的复指数形式中的辐角都应以弧度为单位进行解释。本问题不涉及物理单位。\n\n测试套件（按此确切顺序进行评估）：\n- $c_1 = 0 + 0 i$\n- $c_2 = -1 + 0 i$\n- $c_3 = -2 + 0 i$\n- $c_4 = 0.25 + 0 i$\n- $c_5 = 1 + 0 i$\n- $c_6 = 0.26 + 0 i$\n- $c_7 = 0.28 + 0.207846 i$\n- $c_8 = 0.5 + 0.5 i$\n\n覆盖性设计：\n- $c_1$ 是一个简单的内部点。\n- $c_2$ 会为临界轨道产生一个已知的有界周期为 2 的循环。\n- $c_3$ 和 $c_4$ 是实轴上的边界情况。\n- $c_5$ 和 $c_6$ 是实轴上的外部点（其中 $c_6$ 靠近尖点）。\n- $c_7$ 是一个内部的非实数点，其构造使其位于主心形线内。\n- $c_8$ 是一个快速逃逸的非实数点。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的布尔值列表。例如，输出必须形如 $[\\mathrm{True},\\mathrm{False},\\dots]$，但在实际输出字符串中逗号后没有空格。具体来说，您的程序必须恰好产生一行：\n- 一个表示 Python 风格列表的字符串，包含 8 个布尔值，其顺序与测试套件中的顺序相同，例如 $[\\mathrm{True},\\mathrm{True},\\dots]$。\n\n不需要用户输入，也不应读取或写入任何外部文件。所有计算都必须使用标准的双精度复数算术进行。在复数算术中隐式涉及的角度均以弧度为单位。没有需要报告的物理单位。最终程序必须是自包含且确定性的。",
            "solution": "问题陈述已经过严格审查，并被确定为**有效**。它在科学上基于已确立的复动力系统数学理论，问题定义良好，具有清晰完整的定义和约束条件，并以客观、正式的语言表述。任务是实现一个标准算法，用于为一组给定的参数确定其是否属于曼德博集合。\n\n该问题围绕复二次映射的迭代展开，其定义如下：\n$$\nz_{n+1} = f_c(z_n) = z_n^2 + c\n$$\n其中 $z_n$ 和 $c$ 是复数，$z, c \\in \\mathbb{C}$。对于每个参数 $c$，此方程定义了一个离散时间动力系统。\n\n曼德博集合，记作 $\\mathcal{M}$，是所有使得临界点 $z_0 = 0$ 的轨道保持有界的参数 $c$ 的集合。临界点是映射导数为零的点，即 $f_c'(z) = 2z = 0$，由此得出 $z=0$。这个临界轨道（其中 $z_0=0$）的行为 $\\{z_n\\}_{n=0}^{\\infty}$ 对系统的结构至关重要。\n\n复动力学中的一个关键定理为有界性提供了一个实用的判据。该定理指出，如果任何迭代值 $z_n$ 的模 $|z_n|$ 超过了 2，轨道就保证会发散到无穷大。因此，轨道有界的充要条件是对于所有 $n \\ge 0$ 都有 $|z_n| \\le 2$。\n\n这为测试是否属于 $\\mathcal{M}$ 的数值算法提供了基础。由于我们无法执行无限次迭代，因此我们使用有限步近似。对于给定的参数 $c$，我们从 $z_0 = 0$ 开始，最多迭代 $N$ 步。如果在任何一步 $k  N$ 时，满足条件 $|z_k| > R$（其中 $R=2$ 是逃逸半径），我们就将轨道归类为无界，并得出结论 $c \\notin \\mathcal{M}$。如果在 $N$ 次迭代后模长仍未超过 $R$，我们就判定轨道为有界，从而提供一个近似结论 $c \\in \\mathcal{M}$。\n\n本问题的具体参数是：\n-   初始条件：$z_0 = 0 + 0i$。\n-   最大迭代次数：$N = 10000$。\n-   逃逸半径：$R = 2$。\n\n需要实现的算法如下：\n\n对于给定的复数参数 $c$：\n1.  将复数变量 $z$ 初始化为 $z_0 = 0$。\n2.  对 $n$ 从 $0$ 到 $N - 1$ 进行迭代：\n    a.  检查逃逸条件：$|z| > R$ 是否成立？注意，检查 $|z|^2 > R^2$ 在计算上是等效且更高效的，在我们的情况下即为 $\\operatorname{Re}(z)^2 + \\operatorname{Im}(z)^2 > 4$。如果满足此条件，则轨道无界。函数终止并返回 $\\mathrm{False}$。\n    b.  如果未满足逃逸条件，则使用规则 $z \\leftarrow z^2 + c$ 更新 $z$。\n3.  如果循环完成而逃逸条件从未满足，则对于此数值测试而言，轨道被认为是有界的。函数终止并返回 $\\mathrm{True}$。\n\n此过程将应用于测试套件中指定的 8 个复数参数中的每一个：\n-   $c_1 = 0 + 0i$\n-   $c_2 = -1 + 0i$\n-   $c_3 = -2 + 0i$\n-   $c_4 = 0.25 + 0i$\n-   $c_5 = 1 + 0i$\n-   $c_6 = 0.26 + 0i$\n-   $c_7 = 0.28 + 0.207846i$\n-   $c_8 = 0.5 + 0.5i$\n\n最终输出将是一个布尔值列表，每个值对应一个参数，指示有界性测试的结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Mandelbrot set membership problem for a given test suite.\n    \"\"\"\n\n    def is_bounded(c, max_iter=10000, radius=2.0):\n        \"\"\"\n        Tests if the orbit of z_n+1 = z_n^2 + c starting from z_0 = 0 remains\n        bounded within a given number of iterations.\n\n        Args:\n            c (complex): The parameter of the quadratic map.\n            max_iter (int): The maximum number of iterations.\n            radius (float): The escape radius.\n\n        Returns:\n            bool: True if the orbit is bounded within max_iter, False otherwise.\n        \"\"\"\n        z = np.complex128(0)\n        # It is more efficient to compare squared moduli to avoid sqrt.\n        radius_sq = radius * radius\n\n        for _ in range(max_iter):\n            # Check the escape condition using squared modulus.\n            if z.real**2 + z.imag**2 > radius_sq:\n                return False\n            # Update z\n            z = z*z + c\n        \n        # If the loop completes, the orbit is considered bounded.\n        return True\n\n    # Define the test cases from the problem statement.\n    # We use np.complex128 to be explicit about using double-precision complex numbers.\n    test_cases = [\n        np.complex128(0, 0),          # c_1\n        np.complex128(-1, 0),         # c_2\n        np.complex128(-2, 0),         # c_3\n        np.complex128(0.25, 0),       # c_4\n        np.complex128(1, 0),          # c_5\n        np.complex128(0.26, 0),       # c_6\n        np.complex128(0.28, 0.207846),# c_7\n        np.complex128(0.5, 0.5)        # c_8\n    ]\n\n    results = []\n    for c_param in test_cases:\n        result = is_bounded(c_param)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The output format is a string representing a Python list of booleans,\n    # with no spaces after commas. e.g., [True,False,True]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}