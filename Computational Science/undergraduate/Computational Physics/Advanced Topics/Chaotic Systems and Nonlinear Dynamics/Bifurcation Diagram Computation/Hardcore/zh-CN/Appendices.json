{
    "hands_on_practices": [
        {
            "introduction": "分岔点附近的系统行为往往表现出普适性，即许多不同的系统都遵循相同的标度律，并由临界指数来描述。这个练习  将引导你通过数值方法，为一个经典的超临界叉式分岔验证这种普适性。通过拟合从系统正规形式产生的数据，你将能够提取出临界指数 $\\beta$，从而将一个深刻的理论概念与具体的计算任务联系起来。",
            "id": "2376529",
            "problem": "考虑一个一维系统，其经历由实参数 $r$ 控制的超临界叉式分岔。在临界值 $r_c$ 附近，该系统可以用范式表示为连续时间流 $dx/dt = (r-r_c)x - a x^3$ 或离散时间迭代映射 $x_{n+1} = r x_n - a x_n^3$，其中 $a>0$ 是一个实常数。在这两种情况下，不动点 $x^\\star$ 被定义为满足不动点方程的实数值\n$$\n(r - r_c) x^\\star - a (x^\\star)^3 = 0.\n$$\n对于 $r>r_c$，对称破缺分支包含两个非零不动点 $x_+(r)>0$ 和 $x_-(r)0$。定义这些新不动点之间的距离为\n$$\nd(r) = \\lvert x_+(r) - x_-(r) \\rvert.\n$$\n您的任务是根据以下关系，数值确定临界指数 $\\beta$，该指数表征 $d(r)$ 如何随与临界点的距离而标度\n$$\nd(r) \\propto (r - r_c)^\\beta \\quad \\text{as } r \\downarrow r_c.\n$$\n对于下方的每个测试用例，使用指定的参数值列表 $r = r_c + \\varepsilon$（其中给定了 $\\varepsilon0$），计算所有列出的 $r$ 的 $d(r)$，并根据这些数据为该测试用例生成 $\\beta$ 的单个数值估计。不涉及物理单位。\n\n测试套件（每个测试用例由 $(r_c, a, \\{\\varepsilon\\})$ 组成）：\n- 测试用例 1：$r_c = 0$, $a = 1$, 且 $\\varepsilon \\in \\{10^{-5}, 3\\cdot 10^{-5}, 10^{-4}, 3\\cdot 10^{-4}, 10^{-3}, 3\\cdot 10^{-3}, 10^{-2}\\}$。\n- 测试用例 2：$r_c = 0$, $a = 2$, 且 $\\varepsilon \\in \\{10^{-5}, 3\\cdot 10^{-5}, 10^{-4}, 3\\cdot 10^{-4}, 10^{-3}, 3\\cdot 10^{-3}, 10^{-2}\\}$。\n- 测试用例 3：$r_c = 1$, $a = 1$, 且 $\\varepsilon \\in \\{10^{-5}, 3\\cdot 10^{-5}, 10^{-4}, 3\\cdot 10^{-4}, 10^{-3}, 3\\cdot 10^{-3}, 10^{-2}\\}$。\n- 测试用例 4：$r_c = -0.5$, $a = 3$, 且 $\\varepsilon \\in \\{10^{-5}, 3\\cdot 10^{-5}, 10^{-4}, 3\\cdot 10^{-4}, 10^{-3}, 3\\cdot 10^{-3}, 10^{-2}\\}$。\n\n对于每个测试用例：\n1. 对于每个列出的 $\\varepsilon$，设置 $r = r_c + \\varepsilon$。\n2. 仅使用上述不动点定义，找到两个非零不动点 $x_+(r)$ 和 $x_-(r)$ 并计算 $d(r)$。\n3. 从集合 $\\{(\\varepsilon, d(r_c+\\varepsilon))\\}$ 中，为该测试用例确定 $\\beta$ 的单个数值估计。\n\n您的程序应生成单行输出，其中包含 $\\beta$ 的四个估计值（每个测试用例一个，按上述顺序排列），四舍五入到三位小数，并以逗号分隔列表的形式括在方括号中，例如 $[0.500,0.500,0.500,0.500]$。",
            "solution": "首先对问题陈述进行强制性验证程序。\n\n**第 1 步：提取的已知信息**\n- **系统定义**：一个表现出超临界叉式分岔的一维系统，由一个控制参数 $r$、一个临界值 $r_c$ 和一个正实常数 $a  0$ 描述。\n- **不动点方程**：系统的不动点 $x^\\star$ 由方程 $(r - r_c) x^\\star - a (x^\\star)^3 = 0$ 定义。\n- **对称破缺不动点**：对于 $r  r_c$，存在两个非零不动点，记为 $x_+(r)  0$ 和 $x_-(r)  0$。\n- **距离定义**：这些点之间的距离是 $d(r) = \\lvert x_+(r) - x_-(r) \\rvert$。\n- **标度律**：断言距离 $d(r)$ 在 $r$ 从上方趋近于 $r_c$ ($r \\downarrow r_c$) 时遵循标度律 $d(r) \\propto (r - r_c)^\\beta$。\n- **目标**：为几个测试用例数值估计临界指数 $\\beta$。\n- **步骤**：对于每个测试用例 $(r_c, a, \\{\\varepsilon\\})$，计算点集 $\\{(\\varepsilon, d(r_c+\\varepsilon))\\}$，并由此生成 $\\beta$ 的单个估计值。\n- **测试用例**：\n    - 测试用例 $1$：($r_c = 0$, $a = 1$, $\\varepsilon \\in \\{10^{-5}, 3\\cdot 10^{-5}, 10^{-4}, 3\\cdot 10^{-4}, 10^{-3}, 3\\cdot 10^{-3}, 10^{-2}\\}$)。\n    - 测试用例 $2$：($r_c = 0$, $a = 2$, $\\varepsilon \\in \\{10^{-5}, 3\\cdot 10^{-5}, 10^{-4}, 3\\cdot 10^{-4}, 10^{-3}, 3\\cdot 10^{-3}, 10^{-2}\\}$)。\n    - 测试用例 $3$：($r_c = 1$, $a = 1$, $\\varepsilon \\in \\{10^{-5}, 3\\cdot 10^{-5}, 10^{-4}, 3\\cdot 10^{-4}, 10^{-3}, 3\\cdot 10^{-3}, 10^{-2}\\}$)。\n    - 测试用例 $4$：($r_c = -0.5$, $a = 3$, $\\varepsilon \\in \\{10^{-5}, 3\\cdot 10^{-5}, 10^{-4}, 3\\cdot 10^{-4}, 10^{-3}, 3\\cdot 10^{-3}, 10^{-2}\\}$)。\n\n**第 2 步：验证**\n- **科学依据**：该问题基于超临界叉式分岔的范式，这是动力系统和混沌理论中的一个典型概念。使用临界指数 $\\beta$ 来表征连续相变附近的序参量（此处由 $d(r)$ 表示）的标度行为，是统计力学和非线性物理学中的标准做法。该问题在根本上是合理的。\n- **适定性**：该问题是适定的。不动点方程是一个简单的代数方程，其解法直接明了。从幂律关系中估计指数是一项标准的数值练习。所有必要的参数和数据点都已提供。该问题是自洽且明确的。关于流与映射的不同不动点方程可能引起的混淆点，由于明确给出了要使用的方程 $(r - r_c) x^\\star - a (x^\\star)^3 = 0$，因而不成问题。\n\n**第 3 步：结论**\n该问题是有效的。它是一项明确定义的计算物理练习，旨在测试分析理解能力和数值计算熟练度。我们可以继续进行解答。\n\n**解法推导**\n\n解答需要两个阶段：首先，进行解析处理以理解其理论基础；其次，设计一个数值程序以满足问题的具体要求。\n\n**1. 解析解**\n\n问题的核心在于不动点方程：\n$$\n(r - r_c) x^\\star - a (x^\\star)^3 = 0\n$$\n该方程可以因式分解为：\n$$\nx^\\star \\left( (r - r_c) - a (x^\\star)^2 \\right) = 0\n$$\n在 $r  r_c$（给定 $a  0$）的条件下，该方程为不动点提供了三个实数解：\n$1$. 平凡不动点，对所有 $r$ 都存在：$x^\\star_0 = 0$。\n$2$. 来自第二个因子的两个非平凡不动点：$(r - r_c) - a (x^\\star)^2 = 0$。这得出 $(x^\\star)^2 = \\frac{r - r_c}{a}$。\n解是：\n$$\nx^\\star = \\pm \\sqrt{\\frac{r - r_c}{a}}\n$$\n这些是对称破缺不动点，我们将其确定为 $x_+(r)$ 和 $x_-(r)$：\n$$\nx_+(r) = \\sqrt{\\frac{r - r_c}{a}} \\quad \\text{和} \\quad x_-(r) = -\\sqrt{\\frac{r - r_c}{a}}\n$$\n那么，这两点之间的距离 $d(r)$ 是：\n$$\nd(r) = |x_+(r) - x_-(r)| = \\left| \\sqrt{\\frac{r - r_c}{a}} - \\left(-\\sqrt{\\frac{r - r_c}{a}}\\right) \\right| = \\left| 2 \\sqrt{\\frac{r - r_c}{a}} \\right|\n$$\n由于 $r  r_c$ 且 $a  0$，该表达式为实数且为正。因此：\n$$\nd(r) = \\frac{2}{\\sqrt{a}} (r - r_c)^{1/2}\n$$\n将此解析结果与所要求的标度形式 $d(r) \\propto (r - r_c)^\\beta$ 进行比较，我们可以立即且精确地确定临界指数：\n$$\n\\beta = \\frac{1}{2}\n$$\n对于由该范式描述的任何超临界叉式分岔，该理论值是普适的，与 $r_c$ 和 $a$ 的具体值无关。\n\n**2. 数值估计方法**\n\n该问题要求对 $\\beta$ 进行数值估计。从幂律关系确定指数的标准、稳健的方法是对该方程的对数形式进行线性回归。\n设标度关系为 $d = C \\cdot \\varepsilon^\\beta$，其中 $\\varepsilon = r - r_c$，$C$ 是比例常数（这里 $C=2/\\sqrt{a}$）。对两边取自然对数可将方程线性化：\n$$\n\\ln(d) = \\ln(C \\cdot \\varepsilon^\\beta) = \\ln(C) + \\beta \\ln(\\varepsilon)\n$$\n这是一个直线方程 $Y = mX + b$，其中：\n- 因变量：$Y = \\ln(d(\\varepsilon))$\n- 自变量：$X = \\ln(\\varepsilon)$\n- 斜率：$m = \\beta$\n- 截距：$b = \\ln(C)$\n\n对于每个测试用例，我们都给定了一组 $\\varepsilon$ 的值。我们首先计算相应的 $d(r_c + \\varepsilon) = 2\\sqrt{\\varepsilon/a}$ 的值。这提供了一组数据点 $(\\varepsilon_i, d_i)$。然后我们将这些点转换为它们的对数对应点 $(X_i, Y_i) = (\\ln(\\varepsilon_i), \\ln(d_i))$。\n\n通过这些对数数据点的最佳拟合线的斜率 $\\beta$ 是使用最小二乘法（线性回归）找到的。对于一组 $N$ 个数据点 $(X_i, Y_i)$，斜率的公式为：\n$$\n\\beta = \\frac{N \\sum(X_i Y_i) - (\\sum X_i)(\\sum Y_i)}{N \\sum(X_i^2) - (\\sum X_i)^2}\n$$\n实现将为 4 个测试用例中的每一个计算该值。由于数据点是从精确的解析公式生成的，因此没有实验噪声或高阶项污染。因此，数值拟合必须得出一个在浮点精度范围内等于 0.5 的 $\\beta$ 值。所有测试用例的计算都应产生相同的指数，从而证实 $\\beta$ 的普适性。最终结果将按要求四舍五入到 3 位小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import stats\n\ndef solve():\n    \"\"\"\n    Solves the problem of numerically estimating the critical exponent beta\n    for a supercritical pitchfork bifurcation for four different test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (r_c, a, list_of_epsilons)\n    test_cases = [\n        (0.0, 1.0, [1e-5, 3e-5, 1e-4, 3e-4, 1e-3, 3e-3, 1e-2]),\n        (0.0, 2.0, [1e-5, 3e-5, 1e-4, 3e-4, 1e-3, 3e-3, 1e-2]),\n        (1.0, 1.0, [1e-5, 3e-5, 1e-4, 3e-4, 1e-3, 3e-3, 1e-2]),\n        (-0.5, 3.0, [1e-5, 3e-5, 1e-4, 3e-4, 1e-3, 3e-3, 1e-2]),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        r_c, a, epsilons = case\n        \n        # Convert list of epsilons to a numpy array for vectorized operations\n        eps_array = np.array(epsilons)\n        \n        # 1. Calculate d(r) for each epsilon\n        # The fixed-point equation is (r - r_c)x - ax^3 = 0.\n        # Let epsilon = r - r_c. Then epsilon*x - a*x^3 = 0.\n        # x(epsilon - ax^2) = 0.\n        # Non-zero solutions are x = +/- sqrt(epsilon/a).\n        # x_plus = sqrt(epsilon/a), x_minus = -sqrt(epsilon/a).\n        # d = |x_plus - x_minus| = 2 * sqrt(epsilon/a).\n        d_values = 2 * np.sqrt(eps_array / a)\n        \n        # 2. Prepare data for linear regression\n        # The scaling law is d = C * epsilon^beta.\n        # Taking the log: ln(d) = ln(C) + beta * ln(epsilon).\n        # This is a linear relationship. We fit ln(d) vs ln(epsilon).\n        # The slope of the line is the exponent beta.\n        log_eps = np.log(eps_array)\n        log_d = np.log(d_values)\n        \n        # 3. Perform linear regression to find the slope (beta)\n        # scipy.stats.linregress returns (slope, intercept, r-value, p-value, stderr)\n        lin_reg_result = stats.linregress(log_eps, log_d)\n        beta_estimate = lin_reg_result.slope\n        \n        results.append(beta_estimate)\n\n    # Final print statement in the exact required format.\n    # Results are rounded to three decimal places.\n    print(f\"[{','.join([f'{res:.3f}' for res in results])}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "探索分岔图的一个常用方法是“放大”感兴趣的区域，以揭示其更精细的结构。这个实践  将模拟对著名的逻辑斯蒂映射进行这一探索过程。你将学习如何通过提高参数扫描的分辨率来量化分岔图特征的变化，这是计算探索中的一项基本技能。",
            "id": "2376483",
            "problem": "您的任务是计算一维逻辑斯蒂映射分岔图的标量诊断。这需要通过在更高的参数分辨率下重新计算该图来实现，该过程模拟了对控制参数轴上某一区域的“放大”操作。考虑由逻辑斯蒂映射定义的离散时间动力系统\n$$\nx_{n+1} = r\\,x_n\\,(1 - x_n),\n$$\n其中 $r$ 是一个实值控制参数，$x_n \\in [0,1]$，迭代指数为 $n \\in \\mathbb{N}$。对于给定的控制参数闭区间 $[r_{\\min}, r_{\\max}]$，定义一个包含 $N_r$ 个参数样本的均匀网格为\n$$\n\\{r_i\\}_{i=1}^{N_r},\\quad r_i = r_{\\min} + \\frac{i-1}{N_r-1}\\,(r_{\\max} - r_{\\min}),\n$$\n其中 $N_r \\in \\mathbb{N}$ 且 $N_r \\ge 1$。对于每个参数值 $r_i$，系统从一个初始条件 $x_0 \\in (0,1)$ 开始迭代，总共进行 $N_{\\text{trans}} + K$ 步，其中 $N_{\\text{trans}} \\in \\mathbb{N}$ 表示要舍弃的暂态迭代次数，$K \\in \\mathbb{N}$ 表示要保留的后续迭代次数。为每个 $r_i$ 定义保留迭代均值\n$$\n\\overline{x}(r_i) = \\frac{1}{K}\\sum_{j=1}^{K} x_{N_{\\text{trans}}+j}(r_i),\n$$\n其中 $x_{n}(r_i)$ 表示在参数 $r_i$ 下生成的序列。定义粗分辨率图均值为\n$$\nM_{\\text{coarse}} = \\frac{1}{N_r}\\sum_{i=1}^{N_r} \\overline{x}(r_i).\n$$\n为了模拟使用更高参数分辨率的“放大”重计算，在同一区间 $[r_{\\min}, r_{\\max}]$ 上定义一个精细化网格，其参数为\n$$\nN_r^{(\\text{refined})} = q\\,N_r,\n$$\n其中 $q \\in \\mathbb{N}$ 是一个精细化因子。使用相同的 $x_0$、$N_{\\text{trans}}$ 和 $K$，计算\n$$\nM_{\\text{refined}} = \\frac{1}{N_r^{(\\text{refined})}} \\sum_{i=1}^{N_r^{(\\text{refined})}} \\overline{x}(r_i^{(\\text{refined})})\n$$\n在精细化网格 $\\{r_i^{(\\text{refined})}\\}$ 上。对于每种情况，报告其绝对差\n$$\nD = \\left| M_{\\text{refined}} - M_{\\text{coarse}} \\right|.\n$$\n\n您的程序必须为以下每个测试用例计算 $D$，每个用例以有序七元组 $(r_{\\min}, r_{\\max}, N_r, q, N_{\\text{trans}}, K, x_0)$ 的形式给出：\n\n- 情况 1：$(2.8, 3.0, 200, 4, 800, 200, 0.5)$。\n- 情况 2：$(3.569, 3.571, 400, 5, 1200, 256, 0.5)$。\n- 情况 3：$(3.7, 3.8, 500, 3, 1000, 256, 0.5)$。\n- 情况 4：$(3.99, 4.0, 600, 2, 1000, 256, 0.5)$。\n- 情况 5：$(3.5, 3.5, 300, 1, 500, 128, 0.123456)$。\n\n以上所有实数均为无量纲。不涉及角度。对于每种情况，计算 $D$ 作为一个实数。您的程序应生成单行输出，其中包含这五个值，按上述用例顺序列出，形式为用方括号括起来的逗号分隔列表，例如\n$$\n[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5].\n$$",
            "solution": "问题陈述已经过严格审查，并被确定为有效。它在科学上基于已建立的离散动力系统理论，特别是逻辑斯蒂映射，这是混沌研究中的一个典范模型。该问题是适定的，所有必要的参数、定义和函数都已明确给出。所要求的计算是客观且计算上可行的。未发现科学、逻辑或结构上的缺陷。\n\n任务是计算一个标量诊断值 $D$，它表示在更高参数分辨率下重新计算时，分岔图片段均值的变化。问题的核心在于逻辑斯蒂映射的数值模拟，其递推关系为\n$$\nx_{n+1} = r\\,x_n\\,(1 - x_n),\n$$\n适用于一系列控制参数值 $r$。\n\n解决方案围绕一个系统化且数值稳健的算法构建。对于每个测试用例 $(r_{\\min}, r_{\\max}, N_r, q, N_{\\text{trans}}, K, x_0)$ 的总体流程是计算两个量，$M_{\\text{coarse}}$ 和 $M_{\\text{refined}}$，并求出它们的绝对差。\n\n这些均值 $M$ 的计算被封装在一个专用函数中。该函数接收参数区间 $[r_{\\min}, r_{\\max}]$、网格点数（$N_r$ 或 $N_r^{(\\text{refined})}$）、迭代次数 $N_{\\text{trans}}$ 和 $K$，以及初始条件 $x_0$ 作为输入。\n\n该算法流程如下：\n$1$. 在区间 $[r_{\\min}, r_{\\max}]$ 上构建一个均匀的参数值网格 $\\{r_i\\}$。对于大小为 $N$ 的网格，点由 $r_i = r_{\\min} + \\frac{i-1}{N-1}\\,(r_{\\max} - r_{\\min})$ 给出，其中 $i=1, \\dots, N$。这一步使用 `numpy.linspace` 实现，它可以正确生成这样的网格。\n\n$2$. 对于网格中的每个参数值 $r_i$，对逻辑斯蒂映射进行迭代。此过程的结构旨在高效处理大量所需的计算。每个 $r_i$ 的计算是相互独立的。这种“易于并行”的结构是一个关键的观察。我们通过使用 `numpy` 库提供的矢量化操作来利用这一点。我们不使用缓慢的、遍历每个 $r_i$ 然后再遍历时间的嵌套循环结构，而是使用一个状态向量 $X = [x(r_1), x(r_2), \\dots, x(r_{N})]^T$。整个状态向量在每个时间步 $n$ 根据逐元素操作 $X_{n+1} = R \\odot X_n \\odot (1 - X_n)$ 同时更新，其中 $R$ 是参数值向量，$\\odot$ 表示逐元素乘法。\n\n$3$. 对于每个 $r_i$，前 $N_{\\text{trans}}$ 次迭代的结果被舍弃。这被称为暂态阶段，它允许系统状态稳定到其吸引子上。在矢量化实现中，这对应于对状态向量 $X$ 执行 $N_{\\text{trans}}$ 次更新。\n\n$4$. 在暂态阶段之后，生成接下来的 $K$ 次迭代。这些迭代值，记为 $x_{N_{\\text{trans}}+j}(r_i)$，其中 $j=1, \\dots, K$，代表了系统在吸引子上的长期行为。对每个 $r_i$，将这些值求和。\n\n$5$. 对于每个 $r_i$，通过将上一步得到的和除以 $K$ 来计算保留迭代均值 $\\overline{x}(r_i)$：\n$$\n\\overline{x}(r_i) = \\frac{1}{K}\\sum_{j=1}^{K} x_{N_{\\text{trans}}+j}(r_i).\n$$\n在矢量化实现中，这对应于将和向量逐元素除以标量 $K$。\n\n$6$. 最终的图均值 $M$ 是通过对参数网格上所有单个的保留迭代均值 $\\overline{x}(r_i)$ 进行平均来计算的：\n$$\nM = \\frac{1}{N}\\sum_{i=1}^{N} \\overline{x}(r_i).\n$$\n这一步通过对 $\\overline{x}(r_i)$ 值的向量使用 `numpy.mean` 来高效计算。\n\n整个过程对粗网格参数（$N_r$ 个点）执行一次以获得 $M_{\\text{coarse}}$，然后对精细化网格参数（$N_r^{(\\text{refined})} = q\\,N_r$ 个点）执行第二次以获得 $M_{\\text{refined}}$。测试用例的最终结果是绝对差 $D = |M_{\\text{refined}} - M_{\\text{coarse}}|$。对于 $r_{\\min} = r_{\\max}$ 的特殊情况，两个网格都由相同的点组成，导致 $M_{\\text{coarse}} = M_{\\text{refined}}$，因此 $D=0$，这是正确的。该实现使用64位浮点运算（`numpy.float64`）以确保数值精度和稳健性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_diagram_mean(r_min, r_max, num_r, N_trans, K, x0):\n    \"\"\"\n    Computes the mean of retained-iterate means over a grid of parameters r.\n    This corresponds to M_coarse or M_refined in the problem statement.\n    The implementation is vectorized using numpy for efficiency.\n    \n    Args:\n        r_min (float): The minimum value of the control parameter r.\n        r_max (float): The maximum value of the control parameter r.\n        num_r (int): The number of points in the parameter grid.\n        N_trans (int): The number of transient iterations to discard.\n        K (int): The number of subsequent iterations to retain and average.\n        x0 (float): The initial condition for the iteration.\n\n    Returns:\n        float: The computed diagram mean (M_coarse or M_refined).\n    \"\"\"\n    # 1. Construct the uniform grid of parameter values {r_i}.\n    r_values = np.linspace(r_min, r_max, num=num_r, dtype=np.float64)\n\n    # Initialize the state vector x. Each element corresponds to a value in r_values.\n    x_values = np.full(num_r, x0, dtype=np.float64)\n\n    # 2. Iterate to discard transient states (transient phase).\n    # The calculation is vectorized across all r values.\n    # The logistic map equation is x_{n+1} = r * x_n * (1 - x_n).\n    for _ in range(N_trans):\n        x_values = r_values * x_values * (1.0 - x_values)\n\n    # 3. Iterate to collect retained states and compute their sum (retained phase).\n    sum_of_retained_x = np.zeros(num_r, dtype=np.float64)\n    for _ in range(K):\n        x_values = r_values * x_values * (1.0 - x_values)\n        sum_of_retained_x += x_values\n\n    # 4. Compute the mean of retained states for each r_i.\n    # This creates a vector of \\overline{x}(r_i).\n    retained_iterate_means = sum_of_retained_x / K\n\n    # 5. Compute the final mean M over all r_i values.\n    diagram_mean = np.mean(retained_iterate_means)\n\n    return diagram_mean\n\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Format: (r_min, r_max, N_r, q, N_trans, K, x0)\n    test_cases = [\n        (2.8, 3.0, 200, 4, 800, 200, 0.5),\n        (3.569, 3.571, 400, 5, 1200, 256, 0.5),\n        (3.7, 3.8, 500, 3, 1000, 256, 0.5),\n        (3.99, 4.0, 600, 2, 1000, 256, 0.5),\n        (3.5, 3.5, 300, 1, 500, 128, 0.123456),\n    ]\n\n    results = []\n    for case in test_cases:\n        r_min, r_max, N_r, q, N_trans, K, x0 = case\n        \n        # Calculate M_coarse using the coarse grid parameters.\n        M_coarse = compute_diagram_mean(r_min, r_max, N_r, N_trans, K, x0)\n        \n        # Determine the size of the refined grid.\n        N_r_refined = q * N_r\n        \n        # Calculate M_refined using the refined grid parameters.\n        M_refined = compute_diagram_mean(r_min, r_max, N_r_refined, N_trans, K, x0)\n        \n        # Compute the absolute difference D.\n        D = abs(M_refined - M_coarse)\n        results.append(D)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "任何计算机模拟的结果都受到有限精度算法的限制。这个练习  深入探讨了这一关键方面，研究浮点数精度如何影响在混沌区域内计算出的逻辑斯蒂映射分岔图的结构。通过比较单精度和双精度计算的结果，你将对数值误差如何影响混沌系统模拟的最终输出获得一个实际的理解。",
            "id": "2376515",
            "problem": "要求您通过比较在两种精度下获得的渐近分布，来量化数值浮点精度如何影响在混沌区计算出的逻辑斯谛映射的分岔图。考虑由以下迭代定义的逻辑斯谛映射\n$$\nx_{n+1} = f_r(x_n) = r\\,x_n\\,(1 - x_n),\n$$\n其中控制参数 $r \\in [0,4]$，状态 $x_n \\in [0,1]$。对于一个固定的 $r$，分岔图是当 $n \\to \\infty$ 时 $x_n$ 所访问的值的渐近集合。在实践中，可以通过在丢弃初始瞬态后对迭代值进行采样来近似该集合。浮点精度会影响计算出的迭代值，从而影响分岔图。您将比较由电气与电子工程师协会 (IEEE) $754$ 标准化的二进制 $32$ 位（单精度）和二进制 $64$ 位（双精度）浮点格式之间的结果。\n\n您的程序必须为每个指定的 $r$ 值实现以下操作：\n- 使用固定的初始条件 $x_0 = 0.123456789$。\n- 对于两种精度（二进制 $32$ 位和二进制 $64$ 位）中的每一种，将逻辑斯谛映射迭代 $N_{\\mathrm{discard}} = 5000$ 步以丢弃瞬态，然后迭代 $N_{\\mathrm{keep}} = 4096$ 步以采样渐近行为。\n- 通过一个在 $[0,1]$ 区间上具有 $B = 256$ 个箱的均匀直方图来近似 $[0,1]$ 上的渐近分布。设两种精度下的归一化直方图密度分别为 $\\{p_i\\}_{i=1}^{B}$ 和 $\\{q_i\\}_{i=1}^{B}$，其中归一化使得 $\\sum_{i=1}^{B} p_i \\,\\Delta = 1$ 且 $\\sum_{i=1}^{B} q_i \\,\\Delta = 1$，箱宽为 $\\Delta = 1/B$。\n- 计算两个近似不变分布之间的差异，即离散 $L^1$ 距离\n$$\nD_{L^1}(r) = \\sum_{i=1}^{B} \\left| p_i - q_i \\right| \\, \\Delta.\n$$\n\n此问题不涉及物理单位或角度；所有量均为无量纲实数。为了数值可复现性，将每个 $D_{L^1}(r)$ 四舍五入到 $6$ 位小数。\n\n测试套件：\n- 使用以下 $r$ 值，它们探测了混沌区的不同深度和一个边界情况：\n  - $r_1 = 3.6$\n  - $r_2 = 3.9$\n  - $r_3 = 3.99$\n  - $r_4 = 4.0$\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $[D_{L^1}(r_1), D_{L^1}(r_2), D_{L^1}(r_3), D_{L^1}(r_4)]$，每个值都四舍五入到 $6$ 位小数。例如，输出行应如下所示\n$$\n[\\text{value}_1,\\text{value}_2,\\text{value}_3,\\text{value}_4].\n$$\n每个条目唯一接受的数据类型是浮点数。不应打印其他文本或行。",
            "solution": "所述问题是有效的。它具有科学依据，算法上定义明确，并且为获得唯一的数值解提供了所有必要的参数。任务是计算在使用两种不同浮点精度模拟时，逻辑斯谛映射的渐近行为之间的差异。\n\n逻辑斯谛映射是一个由以下迭代方程定义的离散时间动力系统：\n$$\nx_{n+1} = f_r(x_n) = r \\, x_n \\, (1 - x_n)\n$$\n其中 $n$ 是迭代指数，$x_n \\in [0, 1]$ 是系统在第 $n$ 步的状态，$r \\in [0, 4]$ 是控制参数。对于特定的 $r$ 值，特别是在 $r \\gtrsim 3.57$ 的范围内，系统表现出混沌行为。在混沌区中，系统对初始条件具有敏感依赖性，这意味着初始状态 $x_0$ 的无穷小差异会导致指数级发散的轨迹。由有限精度浮点运算引入的数值舍入误差在每次迭代中充当了这种微小差异，导致数值计算的轨迹偏离真实的数学轨迹，并且在使用不同精度时彼此之间也会发生偏离。\n\n目标是通过比较吸引子的近似不变概率分布来量化这种发散。这是通过对每个给定的 $r$ 值执行以下计算过程来实现的：\n\n1.  **并行模拟**：执行两次独立的逻辑斯谛映射模拟。\n    - 第一次模拟使用单精度浮点数（根据 IEEE $754$ 标准的二进制$32$格式），在指定的计算环境中对应于 `numpy.float32`。\n    - 第二次模拟使用双精度浮点数（二进制$64$格式），对应于 `numpy.float64`。\n    - 为保持一致性，在每次模拟开始时，状态变量 $x_n$ 和参数 $r$ 都被显式转换为相应的精度。\n\n2.  **轨迹生成**：对于每种精度：\n    - 模拟从初始条件 $x_0 = 0.123456789$ 开始。\n    - 该映射迭代 $N_{\\mathrm{discard}} = 5000$ 步。这些初始迭代值被丢弃，以确保轨迹已收敛到系统的吸引子，并且不再受瞬态动力学的影响。\n    - 然后，该映射再额外迭代 $N_{\\mathrm{keep}} = 4096$ 步。收集这些步骤中的状态值 $\\{x_n\\}$。这 $4096$ 个点构成了吸引子的一个数值样本。\n\n3.  **分布近似**：收集到的样本用于近似吸引子的不变概率密度。\n    - 为收集到的两个数据系列（一个用于单精度，一个用于双精度）中的每一个构建一个直方图。\n    - 将域 $[0, 1]$ 分割成 $B = 256$ 个均匀的箱，每个箱的宽度为 $\\Delta = 1/B$。\n    - 直方图被归一化以表示概率密度，为单精度生成密度集 $\\{p_i\\}_{i=1}^{B}$，为双精度生成 $\\{q_i\\}_{i=1}^{B}$。这种归一化确保了 $\\sum_{i=1}^{B} p_i \\Delta = 1$ 和 $\\sum_{i=1}^{B} q_i \\Delta = 1$。带有 `density=True` 参数的 `numpy.histogram` 函数可以正确执行此归一化。\n\n4.  **差异计算**：使用离散 $L^1$ 距离来量化两个所得概率分布之间的差异，定义为：\n    $$\n    D_{L^1}(r) = \\sum_{i=1}^{B} | p_i - q_i | \\Delta\n    $$\n    该度量标准对每个箱的概率密度绝对差进行求和，并按箱宽加权。它提供了两种分布之间总变差的度量。$D_{L^1}(r)=0$ 的值表示分布相同，而 $D_{L^1}(r)=2$ 的值则对应于完全不相交的分布。\n\n对于每个测试的 $r$ 值，最终计算出的 $D_{L^1}(r)$ 值按要求四舍五入到 $6$ 位小数。该算法是为 $r$ 值的测试套件实现的：$r_1 = 3.6$、$r_2 = 3.9$、$r_3 = 3.99$ 和 $r_4 = 4.0$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the L1 distance between asymptotic distributions of the logistic map\n    generated using single and double floating-point precision.\n    \"\"\"\n\n    def generate_series(r, x0, n_discard, n_keep, precision):\n        \"\"\"\n        Generates a time series from the logistic map for a given precision.\n\n        Args:\n            r (float): The control parameter of the logistic map.\n            x0 (float): The initial condition.\n            n_discard (int): The number of transient steps to discard.\n            n_keep (int): The number of steps to record for the series.\n            precision (type): The numpy float type (e.g., np.float32, np.float64).\n\n        Returns:\n            np.ndarray: The array of recorded state values.\n        \"\"\"\n        # Cast parameter and initial state to the specified precision.\n        r_prec = precision(r)\n        x = precision(x0)\n        one = precision(1.0)\n\n        # Discard the initial transient iterations.\n        for _ in range(n_discard):\n            x = r_prec * x * (one - x)\n\n        # Record the subsequent iterations to sample the attractor.\n        series = np.zeros(n_keep, dtype=precision)\n        for i in range(n_keep):\n            x = r_prec * x * (one - x)\n            series[i] = x\n\n        return series\n\n    # Problem parameters\n    test_cases = [3.6, 3.9, 3.99, 4.0]\n    initial_condition = 0.123456789\n    num_discard = 5000\n    num_keep = 4096\n    num_bins = 256\n\n    results = []\n\n    for r_val in test_cases:\n        # Generate time series for both single (32-bit) and double (64-bit) precision.\n        series_32 = generate_series(r_val, initial_condition, num_discard, num_keep, np.float32)\n        series_64 = generate_series(r_val, initial_condition, num_discard, num_keep, np.float64)\n\n        # Define histogram parameters.\n        hist_range = (0.0, 1.0)\n        bin_width = 1.0 / num_bins\n\n        # Compute normalized histograms (probability densities).\n        p_density, _ = np.histogram(series_32, bins=num_bins, range=hist_range, density=True)\n        q_density, _ = np.histogram(series_64, bins=num_bins, range=hist_range, density=True)\n        \n        # Calculate the discrete L1 distance.\n        l1_distance = np.sum(np.abs(p_density - q_density)) * bin_width\n\n        # Round the result to 6 decimal places.\n        results.append(round(l1_distance, 6))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}