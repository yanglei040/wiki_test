{
    "hands_on_practices": [
        {
            "introduction": "在深入研究复杂的数值模拟之前，物理学家和工程师的首要步骤通常是通过量纲分析来把握流动的主要特征。纳维-斯托克斯方程中的惯性项和粘性项的相对大小，可以通过一个称为雷诺数 ($Re$) 的无量纲数来量化。这个实践将带你通过一个有趣的生物学例子，动手计算雷诺数，从而判断微观尺度下流体的行为模式，这是连接理论与实际问题的重要一步。",
            "id": "2654181",
            "problem": "在斑马鱼（Danio rerio）胚胎中，被称为Kupffer氏囊泡（KV）的左右组织者是一个充满液体的腔体，其内部流动由活动纤毛驱动，并被认为有助于左右模式建成。从第一性原理出发，可以通过比较不可压缩Navier–Stokes方程中惯性项和粘性项的特征量级来评估该流动的流态。利用此比较，确定用于量化惯性效应与粘性效应之比的无量纲数群，并根据以下符合物理现实的参数计算其在KV流动中的数值：特征长度尺度 $L = 50\\,\\mu\\mathrm{m}$，特征流速 $U = 50\\,\\mu\\mathrm{m/s}$，流体质量密度 $\\rho = 10^{3}\\,\\mathrm{kg/m^{3}}$，以及动力粘度 $\\mu = 10^{-3}\\,\\mathrm{Pa\\cdot s}$。所有物理量在经过适当转换后，均应采用国际单位制（SI）。根据计算出的无量纲数群相对于$1$的量级，在你的推理中解释KV流动是由惯性主导还是由粘性主导，并预期其定性流态是什么（例如，层流蠕动流）。\n\n最终答案只提供该无量纲数群的数值。以无量纲小数形式表示，无需四舍五入。",
            "solution": "首先对问题进行验证。\n\n从问题陈述中逐字提取的已知条件如下：\n- 系统：斑马鱼（*Danio rerio*）胚胎中的Kupffer氏囊泡（KV）。\n- 任务：从第一性原理出发，确定代表惯性效应与粘性效应之比的无量纲数群，并计算其值。\n- 特征长度尺度：$L = 50\\,\\mu\\mathrm{m}$。\n- 特征流速：$U = 50\\,\\mu\\mathrm{m/s}$。\n- 流体质量密度：$\\rho = 10^{3}\\,\\mathrm{kg/m^{3}}$。\n- 动力粘度：$\\mu = 10^{-3}\\,\\mathrm{Pa\\cdot s}$。\n- 指示：所有物理量均采用国际单位制（SI）。\n- 指示：将结果与$1$进行比较，以确定主导机制（惯性 vs. 粘性）和预期的流动类型。\n\n该问题被认为是有效的。这是一个基于Navier-Stokes方程基本原理的、生物物理流体动力学领域的适定问题。其生物学背景科学准确，所提供的物理参数对于细胞尺度的流体动力学而言是符合现实的。该问题没有歧义、矛盾和事实错误。\n\n我们开始求解。粘性、不可压缩牛顿流体的运动由Navier-Stokes方程描述。对于密度$\\rho$和动力粘度$\\mu$恒定的流体，其动量守恒方程为：\n$$ \\rho \\left( \\frac{\\partial \\mathbf{v}}{\\partial t} + (\\mathbf{v} \\cdot \\nabla) \\mathbf{v} \\right) = -\\nabla p + \\mu \\nabla^2 \\mathbf{v} $$\n此处，$\\mathbf{v}$是流体速度矢量，$p$是压力，$t$是时间。我们忽略了体积力，因为在此微观尺度下，与粘性力和压力相比，体积力通常可以忽略不计。\n\n左边的项，特别是对流加速度项$\\rho (\\mathbf{v} \\cdot \\nabla) \\mathbf{v}$，代表惯性效应。右边的项$\\mu \\nabla^2 \\mathbf{v}$，代表由流体内部摩擦引起的粘性效应。为了确定流动的特性，我们比较这两项的特征量级。这通过量级分析来完成。\n\n我们引入问题中提供的特征尺度：速度尺度$U$和长度尺度$L$。微分算子$\\nabla$的量级可表示为$\\nabla \\sim 1/L$。\n惯性项的量级估计为：\n$$ |\\rho (\\mathbf{v} \\cdot \\nabla) \\mathbf{v}| \\sim \\rho \\frac{U^2}{L} $$\n粘性项的量级估计为：\n$$ |\\mu \\nabla^2 \\mathbf{v}| \\sim \\mu \\frac{U}{L^2} $$\n量化惯性效应与粘性效应之比的无量纲数群是这两个量级的比值。该数群被称为雷诺数（Reynolds number），记为$Re$。\n$$ Re = \\frac{\\text{Magnitude of inertial term}}{\\text{Magnitude of viscous term}} \\sim \\frac{\\rho U^2 / L}{\\mu U / L^2} = \\frac{\\rho U L}{\\mu} $$\n现在我们必须计算$Re$的数值。首先，我们将所有给定参数转换为国际单位制（SI）的基本单位。\n- 特征长度尺度：$L = 50\\,\\mu\\mathrm{m} = 50 \\times 10^{-6}\\,\\mathrm{m}$。\n- 特征流速：$U = 50\\,\\mu\\mathrm{m/s} = 50 \\times 10^{-6}\\,\\mathrm{m/s}$。\n- 质量密度：$\\rho = 10^{3}\\,\\mathrm{kg/m^{3}}$（已是国际单位制）。\n- 动力粘度：$\\mu = 10^{-3}\\,\\mathrm{Pa\\cdot s}$。帕斯卡-秒（Pascal-second）是国际单位制单位，等同于$\\mathrm{kg} \\cdot \\mathrm{m}^{-1} \\cdot \\mathrm{s}^{-1}$。\n\n我们将这些值代入雷诺数的表达式中：\n$$ Re = \\frac{(10^{3}\\,\\mathrm{kg/m^{3}}) \\times (50 \\times 10^{-6}\\,\\mathrm{m/s}) \\times (50 \\times 10^{-6}\\,\\mathrm{m})}{10^{-3}\\,\\mathrm{Pa\\cdot s}} $$\n计算过程如下：\n$$ Re = \\frac{10^{3} \\times (50 \\times 50) \\times (10^{-6} \\times 10^{-6})}{10^{-3}} = \\frac{10^{3} \\times 2500 \\times 10^{-12}}{10^{-3}} $$\n$$ Re = \\frac{2.5 \\times 10^{3} \\times 10^{3} \\times 10^{-12}}{10^{-3}} = \\frac{2.5 \\times 10^{6} \\times 10^{-12}}{10^{-3}} = \\frac{2.5 \\times 10^{-6}}{10^{-3}} $$\n$$ Re = 2.5 \\times 10^{-6 - (-3)} = 2.5 \\times 10^{-3} $$\n数值为$Re = 0.0025$。\n\n按照要求，我们对该结果进行解释。计算出的雷诺数$Re = 2.5 \\times 10^{-3}$远小于$1$（$Re \\ll 1$）。由于雷诺数代表惯性力与粘性力之比，该结果表明粘性力远大于惯性力，占绝对主导地位。因此，Kupffer氏囊泡内的流动是粘性主导的。这种流态被称为斯托克斯流（Stokes flow）或蠕动流（creeping flow）。此类流动的特征是层流、有序且时间可逆（在没有扩散的情况下），其动量平流可以忽略不计。这对于大多数细胞和亚细胞水平的生物过程而言，是预期的物理流态。",
            "answer": "$$\\boxed{2.5 \\times 10^{-3}}$$"
        },
        {
            "introduction": "在不可压缩流体的数值模拟中，压力场并非一个独立的状态变量，而是扮演着一个确保速度场满足无散条件的拉格朗日乘子的角色。本实践将引导你解决一个经典的“逆问题”：给定一个目标速度场，我们需要施加怎样的压力场才能维持该流动？通过这个练习，你将亲手实现求解压力泊松方程的谱方法，深刻理解压力在流体动力学中的独特作用，并掌握一种高效求解周期性问题中椭圆型偏微分方程的强大计算工具。",
            "id": "2416637",
            "problem": "给定一个在无体力情况下的二维、定常、不可压缩粘性流，该流动由纳维-斯托克斯方程描述。其基本依据是作用于牛顿流体的单位体积牛顿第二定律和质量守恒：定常不可压缩流的动量方程，\n$$\n(\\mathbf{u}\\cdot\\nabla)\\mathbf{u} \\;=\\; -\\frac{1}{\\rho}\\nabla p \\;+\\; \\nu \\nabla^2 \\mathbf{u},\n$$\n以及不可压缩约束，\n$$\n\\nabla\\cdot \\mathbf{u} \\;=\\; 0,\n$$\n其中 $\\mathbf{u} = (u_x,u_y)$ 是速度，$p$ 是压力，$\\rho$ 是恒定密度，$\\nu$ 是恒定运动粘度。在一个边长为 $L$ 米的周期性方形区域上，目标速度场是一个空间周期性涡阵，由一个速度标度 $U$ 和两个整数 $(m_x,m_y)$ 参数化，这两个整数指定了在 $x$ 和 $y$ 方向上的周期数。定义波数 $k_x = 2\\pi m_x/L$ 和 $k_y = 2\\pi m_y/L$。考虑不可压缩目标场\n$$\nu_x(x,y) \\;=\\; U \\,\\sin(k_x x)\\,\\cos(k_y y), \\qquad\nu_y(x,y) \\;=\\; -\\,U \\,\\frac{k_x}{k_y}\\,\\cos(k_x x)\\,\\sin(k_y y),\n$$\n对于所有 $m_x \\ge 1$，$m_y \\ge 1$，该场都满足 $\\nabla\\cdot \\mathbf{u} = 0$。\n\n您的任务是：\n- 从定常不可压缩动量方程和不可压缩约束出发，推导方形区域上具有周期性边界条件的压力 $p(x,y)$ 的标量泊松方程。您的推导必须从这些基本定律开始，通过对动量方程取散度来消去压力梯度，并使用 $\\nabla\\cdot\\mathbf{u}=0$ 和 $\\nabla\\cdot(\\nabla^2 \\mathbf{u}) = \\nabla^2 (\\nabla\\cdot\\mathbf{u})$。\n- 在一个均匀的 $N\\times N$ 网格上，使用快速傅里叶变换实现一个谱方法求解器，通过在傅里叶空间中求解推导出的泊松方程，计算出压力 $p(x,y)$（其值可相差一个任意加性常数）。通过将 $p$ 的零波数傅里叶系数设为零来施加零均值规范。\n- 通过评估残余加速度场，量化在无体力的情况下，目标场能被压力单独维持的程度\n$$\n\\mathbf{a}_{\\mathrm{res}}(x,y) \\;=\\; -\\frac{1}{\\rho}\\nabla p(x,y) \\;+\\; \\nu \\nabla^2 \\mathbf{u}(x,y) \\;-\\; (\\mathbf{u}\\cdot\\nabla)\\mathbf{u}(x,y).\n$$\n计算均方根大小\n$$\na_{\\mathrm{rms}} \\;=\\; \\sqrt{\\langle \\|\\mathbf{a}_{\\mathrm{res}}(x,y)\\|^2 \\rangle},\n$$\n其中 $\\langle\\cdot\\rangle$ 表示在区域上的空间平均，$\\|\\cdot\\|$ 是欧几里得范数。量 $a_{\\mathrm{rms}}$ 的单位是米每平方秒，它表示除了压力之外，为精确维持目标场所需要的单位质量的体力大小。\n- 对于下方的每个测试用例，报告两个标量：\n  1. 网格上的最大绝对压力，$p_{\\max} = \\max_{x,y} |p(x,y)|$，以帕斯卡（Pascals）为单位。\n  2. 残余均方根加速度 $a_{\\mathrm{rms}}$，以米每平方秒为单位。\n  \n除非另有说明，所有用例均使用以下参数：区域边长 $L = 1$ 米，网格大小 $N = 128$，密度 $\\rho = 1$ 千克每立方米。三个测试用例是：\n- 用例 1（理想情况）：$U = 1$ 米每秒，$\\nu = 0.05$ 平方米每秒，$(m_x,m_y) = (1,1)$。\n- 用例 2（欧拉极限）：$U = 1$ 米每秒，$\\nu = 0$ 平方米每秒，$(m_x,m_y) = (2,1)$。\n- 用例 3（更高波数和粘度）：$U = 0.5$ 米每秒，$\\nu = 0.1$ 平方米每秒，$(m_x,m_y) = (3,2)$。\n\n您的程序必须：\n- 为每个用例在指定的网格上构建 $\\mathbf{u}(x,y)$。\n- 使用谱方法通过带有周期性边界条件的压力泊松方程求解 $p(x,y)$。\n- 为每个用例计算以帕斯卡为单位的 $p_{\\max}$ 和以米每平方秒为单位的 $a_{\\mathrm{rms}}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个以逗号分隔的列表的列表，每个内部列表对应一个测试用例，并按顺序包含 $[p_{\\max}, a_{\\mathrm{rms}}]$。例如：$[[p_{\\max}^{(1)},a_{\\mathrm{rms}}^{(1)}],[p_{\\max}^{(2)},a_{\\mathrm{rms}}^{(2)}],[p_{\\max}^{(3)},a_{\\mathrm{rms}}^{(3)}]]$。\n- 所有量必须使用国际单位制（SI）：压力单位为帕斯卡，加速度单位为米每平方秒，长度单位为米，速度单位为米每秒，密度单位为千克每立方米，粘度单位为平方米每秒。",
            "solution": "所提出的问题是计算流体力学中一个适定且科学上合理的练习。它要求从基本的纳维-斯托克斯方程推导稳态不可压缩粘性流的压力泊松方程，然后实现一个谱方法来求解压力场并评估残余加速度。问题是自包含的，没有矛盾。因此，我将提供一个完整的解决方案。\n\n第一个任务是推导压力 $p(x,y)$ 的泊松方程。我们从无体力情况下的定常不可压缩动量方程开始：\n$$(\\mathbf{u}\\cdot\\nabla)\\mathbf{u} = -\\frac{1}{\\rho}\\nabla p + \\nu \\nabla^2 \\mathbf{u}$$\n其中 $\\mathbf{u}$ 是速度场，$p$ 是压力，$\\rho$ 是恒定密度，$\\nu$ 是恒定运动粘度。为了分离出压力项，我们对这个方程取散度：\n$$\\nabla \\cdot ((\\mathbf{u}\\cdot\\nabla)\\mathbf{u}) = \\nabla \\cdot \\left(-\\frac{1}{\\rho}\\nabla p\\right) + \\nabla \\cdot (\\nu \\nabla^2 \\mathbf{u})$$\n鉴于 $\\rho$ 和 $\\nu$ 是常数，它们可以移到散度算子之外。梯度的散度是拉普拉斯算子，因此 $\\nabla \\cdot (\\nabla p) = \\nabla^2 p$。这给出：\n$$\\nabla \\cdot ((\\mathbf{u}\\cdot\\nabla)\\mathbf{u}) = -\\frac{1}{\\rho}\\nabla^2 p + \\nu \\nabla \\cdot (\\nabla^2 \\mathbf{u})$$\n问题说明要使用恒等式 $\\nabla\\cdot(\\nabla^2 \\mathbf{u}) = \\nabla^2 (\\nabla\\cdot\\mathbf{u})$。流动是不可压缩的，这由约束 $\\nabla\\cdot\\mathbf{u} = 0$ 表示。应用此约束，粘性项的散度消失：\n$$\\nu \\nabla \\cdot (\\nabla^2 \\mathbf{u}) = \\nu \\nabla^2 (\\nabla\\cdot\\mathbf{u}) = \\nu \\nabla^2(0) = 0$$\n方程因此简化为：\n$$\\nabla \\cdot ((\\mathbf{u}\\cdot\\nabla)\\mathbf{u}) = -\\frac{1}{\\rho}\\nabla^2 p$$\n对压力的拉普拉斯算子进行整理，得到所需的压力泊松方程：\n$$\\nabla^2 p = -\\rho \\nabla \\cdot ((\\mathbf{u}\\cdot\\nabla)\\mathbf{u})$$\n这个方程表明，压力场会进行调整以抵消对流加速度的散度，从而确保流动始终保持不可压缩。\n\n第二个任务是使用基于快速傅里叶变换（FFT）的谱方法，在一个边长为 $L$ 的周期性方形区域上数值求解该方程。该区域被离散化为一个均匀的 $N \\times N$ 网格。谱方法的关键原理是，物理空间中的微分对应于傅里叶空间中的乘法。如果 $\\hat{g}(k_x, k_y)$ 是函数 $g(x,y)$ 的二维离散傅里叶变换，那么其关于 $x$ 的偏导数的傅里叶变换由 $i k_x \\hat{g}(k_x, k_y)$ 给出，其中 $k_x$ 是 $x$ 方向的波数。\n\n对压力泊松方程应用傅里叶变换（用 $\\mathcal{F}$ 表示），得到：\n$$\\mathcal{F}\\{\\nabla^2 p\\} = \\mathcal{F}\\{-\\rho \\nabla \\cdot ((\\mathbf{u}\\cdot\\nabla)\\mathbf{u})\\}$$\n拉普拉斯算子 $\\nabla^2 = \\frac{\\partial^2}{\\partial x^2} + \\frac{\\partial^2}{\\partial y^2}$ 的傅里叶变换是乘以 $-(k_x^2 + k_y^2)$。设 $S(x,y) = -\\rho \\nabla \\cdot ((\\mathbf{u}\\cdot\\nabla)\\mathbf{u})$ 为源项。傅里叶空间中的方程变为：\n$$-(k_x^2 + k_y^2) \\hat{p}(k_x, k_y) = \\hat{S}(k_x, k_y)$$\n压力场 $\\hat{p}$ 的傅里叶系数可以通过代数除法找到：\n$$\\hat{p}(k_x, k_y) = -\\frac{\\hat{S}(k_x, k_y)}{k_x^2 + k_y^2}$$\n在零波数模式 $(k_x, k_y) = (0,0)$ 处存在一个奇异点，此时分母为零。这反映了一个物理事实：压力仅在相差一个任意加性常数的意义下才能确定。问题指定了“零均值规范”，通过将压力的零波数傅里叶系数设为零来强制执行：$\\hat{p}(0,0) = 0$。为保持一致性，源项的零波数模式 $\\hat{S}(0,0)$ 也必须为零。这一点是有保证的，因为 $S$ 是一个矢量场的散度，而散度在周期域上的积分为零。\n\n数值实现过程如下：\n1. 使用 `numpy.fft.fftfreq` 定义 $N \\times N$ 空间网格 $(x_i, y_j)$ 和相应的波数网格 $(K_x, K_y)$。\n2. 在空间网格上构建速度场分量 $u_x$ 和 $u_y$。\n3. 计算对流项分量 $A_x = (\\mathbf{u}\\cdot\\nabla)u_x$ 和 $A_y = (\\mathbf{u}\\cdot\\nabla)u_y$。所需的空间导数（例如 $\\frac{\\partial u_x}{\\partial x}$）通过 FFT、乘以 $i K_x$ 和逆 FFT 进行谱方法计算。\n4. 再次使用谱微分法计算泊松源项 $S = -\\rho(\\frac{\\partial A_x}{\\partial x} + \\frac{\\partial A_y}{\\partial y})$。\n5. 通过二维 FFT 计算 $\\hat{S}$。\n6. 如前所述处理 $k=0$ 模式，在傅里叶空间中求解 $\\hat{p}$。\n7. 对 $\\hat{p}$ 应用二维逆 FFT 计算压力场 $p(x,y)$。然后从此网格中找到最大绝对压力 $p_{\\max}$。\n\n最后，我们必须计算均方根残余加速度 $a_{\\mathrm{rms}}$。残余加速度场定义为：\n$$\\mathbf{a}_{\\mathrm{res}}(x,y) = -\\frac{1}{\\rho}\\nabla p(x,y) + \\nu \\nabla^2 \\mathbf{u}(x,y) - (\\mathbf{u}\\cdot\\nabla)\\mathbf{u}(x,y)$$\n这个残余项表示，要使给定的速度场成为具有所计算压力场的定常纳维-斯托克斯方程的精确解，所需的单位质量的强迫项。所有项都在网格上计算。梯度 $\\nabla p$ 和拉普拉斯算子 $\\nabla^2 \\mathbf{u}$ 均通过谱方法计算以保持一致性。对流项 $(\\mathbf{u}\\cdot\\nabla)\\mathbf{u}$ 已经计算过了。\n均方根大小由下式给出：\n$$a_{\\mathrm{rms}} = \\sqrt{\\frac{1}{N^2}\\sum_{i,j=0}^{N-1} \\| \\mathbf{a}_{\\mathrm{res}}(x_i, y_j) \\|^2}$$\n其中求和遍及所有网格点。对于给定的特定速度场，解析研究表明对流项 $(\\mathbf{u}\\cdot\\nabla)\\mathbf{u}$ 是无旋的，这意味着它可以表示为标量势的梯度。通过泊松方程计算出的压力场 $p$ 正是使 $-\\frac{1}{\\rho}\\nabla p$ 与 $(\\mathbf{u}\\cdot\\nabla)\\mathbf{u}$ 相平衡的场。因此，残余项定义中的第一项和第三项相互抵消，残余项简化为 $\\mathbf{a}_{\\mathrm{res}} = \\nu \\nabla^2 \\mathbf{u}$。这意味着对于无粘情况（$\\nu=0$），残余加速度应为零。数值实现将计算完整的残余表达式以保持通用性和鲁棒性。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the pressure Poisson equation for a given 2D periodic flow\n    and computes the residual of the Navier-Stokes equations.\n    \"\"\"\n    # Global parameters\n    L = 1.0  # meters\n    N = 128  # grid size\n    rho = 1.0  # kg/m^3\n\n    # Test cases from the problem statement\n    test_cases = [\n        # (U, nu, (mx, my))\n        (1.0, 0.05, (1, 1)),  # Case 1\n        (1.0, 0.0, (2, 1)),   # Case 2\n        (0.5, 0.1, (3, 2)),   # Case 3\n    ]\n\n    results = []\n\n    # Discretization\n    delta = L / N\n    x = np.arange(N) * delta\n    y = np.arange(N) * delta\n    X, Y = np.meshgrid(x, y, indexing='ij')\n\n    # Wavenumbers\n    k_freq = np.fft.fftfreq(N, d=delta)\n    Kx_1d = 2 * np.pi * k_freq\n    Ky_1d = 2 * np.pi * k_freq\n    Kx, Ky = np.meshgrid(Kx_1d, Ky_1d, indexing='ij')\n\n    # Laplacian operator in Fourier space\n    lap_fourier = -(Kx**2 + Ky**2)\n\n    for U, nu, (mx, my) in test_cases:\n        # Case-specific parameters\n        kx = 2 * np.pi * mx / L\n        ky = 2 * np.pi * my / L\n\n        # 1. Construct velocity field u = (ux, uy)\n        ux = U * np.sin(kx * X) * np.cos(ky * Y)\n        uy = -U * (kx / ky) * np.cos(kx * X) * np.sin(ky * Y)\n\n        # Fourier transform of velocity components\n        ux_hat = np.fft.fft2(ux)\n        uy_hat = np.fft.fft2(uy)\n\n        # 2. Compute derivatives and advection term (u.grad)u\n        # Derivatives are computed in Fourier space\n        dux_dx = np.fft.ifft2(1j * Kx * ux_hat).real\n        dux_dy = np.fft.ifft2(1j * Ky * ux_hat).real\n        duy_dx = np.fft.ifft2(1j * Kx * uy_hat).real\n        duy_dy = np.fft.ifft2(1j * Ky * uy_hat).real\n        \n        # Advection term components\n        adv_x = ux * dux_dx + uy * dux_dy\n        adv_y = ux * duy_dx + uy * duy_dy\n\n        # 3. Solve pressure Poisson equation: lap(p) = -rho * div((u.grad)u)\n        # Source term for Poisson equation\n        adv_x_hat = np.fft.fft2(adv_x)\n        adv_y_hat = np.fft.fft2(adv_y)\n        \n        # Divergence in Fourier space\n        div_adv_hat = 1j * Kx * adv_x_hat + 1j * Ky * adv_y_hat\n        \n        source_hat = -rho * div_adv_hat\n\n        # Solve for pressure in Fourier space\n        p_hat = np.zeros_like(source_hat, dtype=complex)\n        \n        # Avoid division by zero at k=0 mode\n        non_zero_k = lap_fourier != 0\n        p_hat[non_zero_k] = source_hat[non_zero_k] / lap_fourier[non_zero_k]\n        \n        # Impose zero-mean gauge explicitly\n        p_hat[0, 0] = 0.0\n\n        # Transform pressure back to physical space\n        p = np.fft.ifft2(p_hat).real\n        \n        # 4. Calculate maximum absolute pressure\n        p_max = np.max(np.abs(p))\n\n        # 5. Compute residual acceleration: a_res = -1/rho*grad(p) + nu*lap(u) - (u.grad)u\n        \n        # Pressure gradient term\n        dp_dx = np.fft.ifft2(1j * Kx * p_hat).real\n        dp_dy = np.fft.ifft2(1j * Ky * p_hat).real\n        \n        grad_p_x = dp_dx\n        grad_p_y = dp_dy\n\n        # Viscous term\n        lap_ux = np.fft.ifft2(lap_fourier * ux_hat).real\n        lap_uy = np.fft.ifft2(lap_fourier * uy_hat).real\n\n        # Assemble residual components\n        a_res_x = - (1 / rho) * grad_p_x + nu * lap_ux - adv_x\n        a_res_y = - (1 / rho) * grad_p_y + nu * lap_uy - adv_y\n\n        # 6. Compute RMS of residual acceleration\n        a_res_sq_mag = a_res_x**2 + a_res_y**2\n        a_rms = np.sqrt(np.mean(a_res_sq_mag))\n\n        results.append([p_max, a_rms])\n\n    # Format the final output string as a list of lists\n    result_str = \",\".join([f\"[{res[0]},{res[1]}]\" for res in results])\n    print(f\"[{result_str}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "纳维-斯托克斯方程的框架不仅限于描述被动流体，它还可以被推广用于模拟如细菌悬浮液或细胞组织这类“活性物质”的复杂行为。本实践将挑战一个前沿课题：模拟一种具有效“负粘性”的活性流体，它能自发地从无序状态中涌现出宏观的流动斑图。你将通过实现伪谱方法和时间积分因子等高等数值技术，探索非平衡系统中的斑图形成之谜，并学会使用线性稳定性分析来预测复杂系统的临界行为。",
            "id": "2416615",
            "problem": "您需要编写一个完整的、可运行的程序，对一个二维不可压缩活性流体中的自发模式选择进行数值研究。该流体由一个修正的纳维-斯托克斯（Navier–Stokes）系统建模，该系统具有有效的大尺度负粘性和小尺度稳定项。物理和数学设置必须从不可压缩的纳维-斯托克斯方程开始，并推导到周期性域下的涡量表述。您的任务是实现一个伪谱法时间积分器，用于演化涡量场，并在一组指定的测试案例中，当模式存在时，测量其主导的涌现波长。\n\n起点是速度场 $\\mathbf{u}(\\mathbf{x},t)$ 和压力 $p(\\mathbf{x},t)$ 的不可压缩纳维-斯托克斯方程，\n$$\n\\partial_t \\mathbf{u} + (\\mathbf{u}\\cdot \\nabla)\\mathbf{u} = -\\nabla p + \\nu \\nabla^2 \\mathbf{u} + \\mathbf{f},\n$$\n其不可压缩性约束为 $\\nabla \\cdot \\mathbf{u} = 0$。考虑一个边长为 $L$（单位：米）的二维周期性正方形，并定义标量涡量 $\\omega = \\partial_x u_y - \\partial_y u_x$。本着活性流体建模的精神，用一个有效的线性算子替换通常的粘性项，该算子在大尺度上注入能量，在小尺度上进行阻尼。在涡量形式中，您将演化\n$$\n\\partial_t \\omega + J(\\psi,\\omega) = -\\alpha \\nabla^2 \\omega - \\beta \\nabla^4 \\omega,\n$$\n其中 $J(\\psi,\\omega) = \\partial_x \\psi \\, \\partial_y \\omega - \\partial_y \\psi \\, \\partial_x \\omega$ 是雅可比非线性项，$\\psi$ 是通过 $-\\nabla^2 \\psi = \\omega$ 关联的流函数，$\\alpha > 0$（单位：$\\mathrm{m^2/s}$）模拟一个有效的负粘度 $-\\alpha \\nabla^2 \\omega$，它使长波长不稳定，而 $\\beta > 0$（单位：$\\mathrm{m^4/s}$）通过 $-\\beta \\nabla^4 \\omega$ 提供小尺度稳定化。所有量都应作为物理空间中的实值场处理。\n\n您必须：\n- 使用基于快速傅里叶变换（FFT）的伪谱法，通过流函数关系强制不可压缩性，并计算空间导数。在谱空间中使用标准的“三分之二去混叠”规则。\n- 使用积分因子法对线性部分进行处理，并结合对非线性项的显式处理来进行时间推进。您可以使用一阶指数时间差分格式，其中线性算子在傅里叶空间中被精确应用。\n- 将涡量 $\\omega(\\mathbf{x},0)$ 初始化为零均值、小振幅的随机场（无量纲涡量振幅），并以时间步长 $\\Delta t$（单位：秒）演化至指定的最终时间 $T$（单位：秒）。\n- 在每次模拟结束时，通过计算傅里叶空间中涡量场的角平均径向谱来估计主导波长。设基本波数为 $k_0 = 2\\pi/L$。对于整数 $m \\ge 1$，定义离散波数 $k_m = m k_0$，并按 $k_m \\pm k_0/2$ 对谱能量进行分箱。选择具有最大分箱能量的 $m$（不包括 $m=0$），并报告主导波长 $\\lambda = 2\\pi / k_m$（单位：米）。\n- 如果流在所有已解析的非零波数下都是线性稳定的，则没有模式可报告。为了在这种情况下避免不必要的模拟，首先确定在忽略非线性项时，是否有任何已解析的离散 $k_m$ 具有正的线性增长率。线性增长率是通过将傅里叶模式代入线性化方程得到的。如果没有 $m \\ge 1$ 的 $k_m$ 是线性不稳定的，则在该情况下返回 $\\lambda = 0.0$，而不执行时间积分。\n- 将每个测试案例的最终报告波长以米为单位表示，并四舍五入到三位小数。\n\n您的程序必须实现以上内容，然后运行以下测试套件。每个测试案例是一个元组 $\\left(L,\\alpha,\\beta,N,T,\\Delta t\\right)$，其中 $L$ 是域边长（单位：米），$\\alpha$ 的单位是 $\\mathrm{m^2/s}$，$\\beta$ 的单位是 $\\mathrm{m^4/s}$，$N$ 是每边的网格点数（无量纲），$T$ 是最终时间（单位：秒），$\\Delta t$ 是时间步长（单位：秒）：\n\n- 测试 1: $\\left(2\\pi,\\,1.0,\\,0.1,\\,64,\\,0.8,\\,0.01\\right)$。\n- 测试 2: $\\left(2\\pi,\\,0.05,\\,0.1,\\,64,\\,0.8,\\,0.01\\right)$。\n- 测试 3: $\\left(4\\pi,\\,1.0,\\,0.1,\\,64,\\,0.8,\\,0.01\\right)$。\n- 测试 4: $\\left(2\\pi,\\,1.0,\\,0.5,\\,64,\\,3.0,\\,0.01\\right)$。\n\n您的程序应生成单行输出，其中包含一个逗号分隔的四个波长列表的结果，四舍五入到三位小数，并用方括号括起来，例如 $\\left[\\lambda_1,\\lambda_2,\\lambda_3,\\lambda_4\\right]$。\n\n所有答案必须以米为单位。角度（如有）必须以弧度为单位。百分比（如有）必须表示为小数。\n\n最终输出必须是单行。不应打印其他任何文本。",
            "solution": "问题陈述提出了一个计算物理学中有效且明确定义的任务。它要求对二维广义纳维-斯托克斯方程的涡量形式进行数值求解，该模型常用于研究活性流体中的模式形成。该问题具有科学依据，数学上定义明确，并且提供了模拟和分析所需的所有参数。没有矛盾、歧义或不合理的假设。因此，我们将着手提供一个完整的解决方案。\n\n在边长为 $L$ 的二维周期性域上，标量涡量场 $\\omega(\\mathbf{x},t)$ 的控制方程是\n$$\n\\partial_t \\omega + J(\\psi,\\omega) = -\\alpha \\nabla^2 \\omega - \\beta \\nabla^4 \\omega,\n$$\n其中 $\\psi$ 是由泊松方程 $-\\nabla^2 \\psi = \\omega$ 定义的流函数。参数 $\\alpha > 0$ 对应于一个有效的负粘度，在长波长处注入能量，而 $\\beta > 0$ 提供一个超粘性阻尼，用以稳定短波长。项 $J(\\psi,\\omega) = \\partial_x \\psi \\, \\partial_y \\omega - \\partial_y \\psi \\, \\partial_x \\omega$ 代表涡量的非线性平流。\n\n我们使用伪谱法在 $N \\times N$ 点的均匀网格上求解此方程。该方法特别适用于具有周期性边界条件的问题，因为它允许使用快速傅里叶变换（FFT）高精度地计算空间导数。在傅里叶空间中，空间导数变为简单的乘法。一个场 $f(\\mathbf{x})$ 及其傅里叶变换 $\\hat{f}(\\mathbf{k})$ 通过 $\\hat{f}(\\mathbf{k}) = \\mathcal{F}\\{f(\\mathbf{x})\\}$ 相关联。偏导数的变换是 $\\mathcal{F}\\{\\partial_x f\\} = i k_x \\hat{f}(\\mathbf{k})$，拉普拉斯算子变为 $\\mathcal{F}\\{\\nabla^2 f\\} = -(k_x^2+k_y^2)\\hat{f}(\\mathbf{k}) = -k^2 \\hat{f}(\\mathbf{k})$，其中 $\\mathbf{k}=(k_x, k_y)$ 是波矢量。\n\n因此，傅里叶空间中的控制方程被转换为针对每个傅里叶模式 $\\hat{\\omega}(\\mathbf{k}, t)$ 的常微分方程（ODE）系统：\n$$\n\\frac{d\\hat{\\omega}_{\\mathbf{k}}}{dt} = (\\alpha k^2 - \\beta k^4)\\hat{\\omega}_{\\mathbf{k}} - \\widehat{J(\\psi,\\omega)}_{\\mathbf{k}}.\n$$\n该方程的形式为 $\\frac{d\\hat{\\omega}}{dt} = \\mathcal{L}\\hat{\\omega} + \\mathcal{N}(\\hat{\\omega})$，其中 $\\mathcal{L}_{\\mathbf{k}} = \\alpha k^2 - \\beta k^4$ 是线性部分，$\\mathcal{N}_{\\mathbf{k}} = -\\widehat{J(\\psi,\\omega)}_{\\mathbf{k}}$ 是非线性部分。\n\n在模拟之前，需要进行线性稳定性分析。具有波数 $k=|\\mathbf{k}|$ 的模式的增长率由线性算子给出，$\\sigma(k) = \\alpha k^2 - \\beta k^4$。只有当存在至少一个不稳定模式，即对于某个 $k \\neq 0$ 有 $\\sigma(k) > 0$ 时，模式才能涌现。这个条件在 $\\alpha k^2 > \\beta k^4$ 时满足，可简化为 $k^2 < \\alpha/\\beta$。离散网格上最小的非零波数大小是 $k_{\\min} = 2\\pi/L$。因此，不稳定的一个必要条件是 $k_{\\min}^2 < \\alpha/\\beta$。如果不满足此条件，所有已解析的模式都是线性稳定的，并且不会从小初始噪声中形成模式。在这种情况下，主导波长 $\\lambda$ 报告为 $0.0$，不进行模拟。\n\n对于时间积分，采用一阶指数时间差分（ETD1）格式。线性部分被精确处理，而非线性部分在单个时间步长 $\\Delta t$ 内被近似为常数。傅里叶模式 $\\hat{\\omega}_n = \\hat{\\omega}(t_n)$ 到 $\\hat{\\omega}_{n+1} = \\hat{\\omega}(t_{n+1})$ 的更新规则是\n$$\n\\hat{\\omega}_{n+1} = e^{\\mathcal{L} \\Delta t} \\hat{\\omega}_n + \\left(\\frac{e^{\\mathcal{L} \\Delta t} - 1}{\\mathcal{L}}\\right) \\mathcal{N}(\\hat{\\omega}_n),\n$$\n当 $\\mathcal{L} \\to 0$ 时，括号中的项趋近于 $\\Delta t$，这对应于 $k=0$ 模式的情况。\n\n非线性项 $\\mathcal{N}(\\hat{\\omega})$ 是通过伪谱法计算的。在每个时间步：\n1.  通过傅里叶空间关系 $k^2 \\hat{\\psi} = \\hat{\\omega}$ 从 $\\hat{\\omega}$ 求得流函数 $\\hat{\\psi}$，即对于 $\\mathbf{k} \\neq 0$ 有 $\\hat{\\psi}_{\\mathbf{k}} = \\hat{\\omega}_{\\mathbf{k}} / k^2$，且 $\\hat{\\psi}_{\\mathbf{k}=0} = 0$。\n2.  为防止雅可比项中二次非线性引起的混叠误差，应用标准的“三分之二去混叠”规则。这涉及对 $\\hat{\\omega}$ 和 $\\hat{\\psi}$ 的傅里叶空间表示进行滤波，将任一方向上整数波指数超过 $N/3$ 的所有模式置为零。\n3.  在傅里叶空间中计算必要的空间导数（$\\partial_x\\psi, \\partial_y\\psi, \\partial_x\\omega, \\partial_y\\omega$）（例如，$i k_x \\hat{\\psi}$）。\n4.  使用逆FFT将这些导数场变换回物理空间。\n5.  在物理空间中通过逐点相乘计算雅可比项 $J(\\psi,\\omega)$。\n6.  将结果变换回傅里叶空间以获得 $\\widehat{J(\\psi,\\omega)}$，从而得到 $\\mathcal{N}(\\hat{\\omega})$。\n\n模拟从一个小的、零均值的随机涡量场开始，演化直到最终时间 $T$。\n\n最后，为了确定主导波长，计算最终涡量场的角平均功率谱。傅里叶网格上每个点的波矢量大小计算为 $k = \\sqrt{k_x^2 + k_y^2}$。能量 $|\\hat{\\omega}(\\mathbf{k},T)|^2$ 根据整数 $m = \\text{round}(k/k_0)$ 进行分箱，其中 $k_0 = 2\\pi/L$ 是基本波数。识别出对应于最大能量（对于 $m \\ge 1$）的箱子的索引 $m^*$。然后，主导波长为 $\\lambda = 2\\pi/k_{m^*} = 2\\pi/(m^* k_0) = L/m^*$。\n\n实现过程首先是定义一个函数，为给定的一组参数 $(L, \\alpha, \\beta, N, T, \\Delta t)$ 执行单个模拟运行，然后将此函数应用于每个指定的测试案例。将得到的波长四舍五入到三位小数后，收集并以所需格式呈现。",
            "answer": "```python\nimport numpy as np\n\ndef run_simulation(L, alpha, beta, N, T, dt, seed=42):\n    \"\"\"\n    Runs a single simulation for the 2D active fluid model.\n\n    Args:\n        L (float): Domain side length in meters.\n        alpha (float): Negative viscosity coefficient in m^2/s.\n        beta (float): Hyperviscosity coefficient in m^4/s.\n        N (int): Number of grid points per side.\n        T (float): Total simulation time in seconds.\n        dt (float): Time step in seconds.\n        seed (int): Seed for the random number generator for reproducibility.\n\n    Returns:\n        float: The dominant wavelength in meters, or 0.0 if stable.\n    \"\"\"\n    # Step 1: Linear stability pre-check.\n    # The system is unstable if there is any k > 0 such that sigma(k) > 0.\n    # sigma(k) = alpha*k^2 - beta*k^4. This is positive for 0  k^2  alpha/beta.\n    # The smallest non-zero wavenumber squared on the grid is k_min^2 = (2*pi/L)^2.\n    # If k_min^2 >= alpha/beta, all k > 0 are stable.\n    k_min_sq = (2 * np.pi / L)**2\n    if k_min_sq >= alpha / beta:\n        return 0.0\n\n    # Step 2: Grid and wavenumber setup\n    k_vec = 2 * np.pi * np.fft.fftfreq(N, d=L/N)\n    kx, ky = np.meshgrid(k_vec, k_vec, indexing='ij')\n    k_squared = kx**2 + ky**2\n\n    # Inverse Laplacian operator in Fourier space (for finding psi from omega)\n    # psi_hat = omega_hat / k_squared, from -nabla^2 psi = omega\n    inv_k_squared = np.zeros_like(k_squared)\n    non_zero_k = k_squared != 0\n    inv_k_squared[non_zero_k] = 1.0 / k_squared[non_zero_k]\n\n    # Step 3: ETD1 coefficients\n    L_op = alpha * k_squared - beta * k_squared**2\n    exp_L_dt = np.exp(L_op * dt)\n    \n    # The integrating factor for the nonlinear term\n    integrating_factor = np.zeros_like(L_op, dtype=float)\n    non_zero_L = np.abs(L_op) > 1e-15\n    integrating_factor[non_zero_L] = (exp_L_dt[non_zero_L] - 1.0) / L_op[non_zero_L]\n    integrating_factor[~non_zero_L] = dt  # Taylor expansion for L_op -> 0\n\n    # Step 4: De-aliasing mask (2/3 rule)\n    k_indices = np.fft.fftfreq(N) * N\n    kx_indices, ky_indices = np.meshgrid(k_indices, k_indices, indexing='ij')\n    dealias_mask = (np.abs(kx_indices)  N/3)  (np.abs(ky_indices)  N/3)\n\n    # Step 5: Initialization\n    rng = np.random.default_rng(seed)\n    omega = 1e-4 * (rng.random((N, N)) - 0.5)\n    omega -= np.mean(omega)  # Enforce zero mean\n    omega_hat = np.fft.fft2(omega)\n\n    # Step 6: Time integration loop\n    num_steps = int(round(T / dt))\n    for _ in range(num_steps):\n        # Compute nonlinear term N_hat using pseudo-spectral method with de-aliasing\n        omega_hat_dealiased = omega_hat * dealias_mask\n        psi_hat_dealiased = omega_hat_dealiased * inv_k_squared\n\n        # Derivatives in Fourier space\n        d_omega_dx_hat = 1j * kx * omega_hat_dealiased\n        d_omega_dy_hat = 1j * ky * omega_hat_dealiased\n        d_psi_dx_hat = 1j * kx * psi_hat_dealiased\n        d_psi_dy_hat = 1j * ky * psi_hat_dealiased\n\n        # Transform derivatives to real space\n        d_omega_dx = np.fft.ifft2(d_omega_dx_hat).real\n        d_omega_dy = np.fft.ifft2(d_omega_dy_hat).real\n        d_psi_dx = np.fft.ifft2(d_psi_dx_hat).real\n        d_psi_dy = np.fft.ifft2(d_psi_dy_hat).real\n\n        # Compute Jacobian J(psi, omega) in real space\n        jacobian = d_psi_dx * d_omega_dy - d_psi_dy * d_omega_dx\n\n        # Transform Jacobian to Fourier space to get N_hat = -J_hat\n        N_hat = -np.fft.fft2(jacobian)\n\n        # Update vorticity in Fourier space using ETD1 scheme\n        omega_hat = exp_L_dt * omega_hat + integrating_factor * N_hat\n\n    # Step 7: Dominant wavelength analysis\n    power_spectrum = np.abs(omega_hat)**2\n    k_magnitudes = np.sqrt(k_squared)\n    k0 = 2 * np.pi / L\n    \n    if k0 == 0: return 0.0\n\n    m_indices = np.round(k_magnitudes / k0).astype(int)\n    max_m = N // 2\n    \n    # Use bincount for efficient radial averaging of the spectrum\n    binned_energy = np.bincount(m_indices.flatten(), weights=power_spectrum.flatten(), minlength=max_m + 1)\n    \n    # Exclude m=0 mode (mean) and find the mode with maximum energy\n    relevant_bins = binned_energy[1:max_m + 1]\n    \n    if len(relevant_bins) == 0 or np.sum(relevant_bins)  1e-12: # Check if pattern emerged\n        return 0.0\n        \n    m_star = np.argmax(relevant_bins) + 1  # Add 1 because we sliced from index 1\n    lambda_dominant = L / m_star  # lambda = 2*pi/k = 2*pi/(m*k0) = L/m\n    \n    return lambda_dominant\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Test cases: (L, alpha, beta, N, T, dt)\n    test_cases = [\n        (2 * np.pi, 1.0, 0.1, 64, 0.8, 0.01),  # Test 1\n        (2 * np.pi, 0.05, 0.1, 64, 0.8, 0.01), # Test 2\n        (4 * np.pi, 1.0, 0.1, 64, 0.8, 0.01),  # Test 3\n        (2 * np.pi, 1.0, 0.5, 64, 3.0, 0.01),  # Test 4\n    ]\n\n    results = []\n    for case in test_cases:\n        L, alpha, beta, N, T, dt = case\n        wavelength = run_simulation(L, alpha, beta, N, T, dt)\n        results.append(f\"{wavelength:.3f}\")\n    \n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}