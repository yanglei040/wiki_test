{
    "hands_on_practices": [
        {
            "introduction": "At its core, the projection method is an application of the Helmholtz-Hodge decomposition, which orthogonally splits a vector field into a divergence-free component and a curl-free component. This exercise  connects this abstract mathematical concept to the concrete physical quantity of kinetic energy. By first proving that the projection operator minimizes kinetic energy and then verifying this result with a numerical experiment, you will gain a deep and intuitive understanding of what the pressure-projection step physically accomplishes in a fluid simulation.",
            "id": "2430752",
            "problem": "Consider an incompressible fluid on a two-dimensional periodic domain. Let the domain be the square $[0,2\\pi]\\times[0,2\\pi]$ with periodic boundary conditions in both directions. Let $\\vec{u}(\\vec{x})$ denote a sufficiently smooth velocity field, and define the kinetic energy\n$$\nE[\\vec{u}] \\;=\\; \\int_{[0,2\\pi]^2} \\frac{1}{2}\\, \\lvert \\vec{u}(\\vec{x}) \\rvert^2 \\,\\mathrm{d}\\vec{x}.\n$$\nIn the projection framework for incompressible flow, given an intermediate velocity field $\\vec{u}^{\\star}$, the continuous projection step produces a solenoidal velocity $\\vec{u}^{\\mathrm{proj}}$ by solving for a scalar field $p$ such that\n$$\n\\nabla^2 p \\;=\\; \\nabla\\cdot \\vec{u}^{\\star}, \\quad \\text{and} \\quad \\vec{u}^{\\mathrm{proj}} \\;=\\; \\vec{u}^{\\star} - \\nabla p,\n$$\nwith the periodic boundary condition on $p$ and zero-mean normalization for uniqueness. Angles in all trigonometric functions are in radians.\n\nTasks:\n1. Prove, from first principles, that the continuous projection step is energy-dissipating in the sense that\n$$\nE[\\vec{u}^{\\mathrm{proj}}] \\;\\le\\; E[\\vec{u}^{\\star}],\n$$\nwith equality if and only if $\\nabla\\cdot \\vec{u}^{\\star} = 0$.\n\n2. Implement a program that, for each of the prescribed test cases listed below, constructs the velocity field $\\vec{u}^{\\star}$ on a uniform grid of $N\\times N$ points over $[0,2\\pi]\\times[0,2\\pi]$, applies a numerically consistent discrete projection step to obtain a discretely divergence-free velocity field $\\vec{u}^{\\mathrm{proj}}$, and computes the relative change in kinetic energy\n$$\n\\delta \\;=\\; \\frac{E_h[\\vec{u}^{\\mathrm{proj}}] - E_h[\\vec{u}^{\\star}]}{E_h[\\vec{u}^{\\star}]},\n$$\nwhere $E_h[\\cdot]$ is the standard rectangle-rule discrete approximation of $E[\\cdot]$ on the uniform grid:\n$$\nE_h[\\vec{u}] \\;=\\; \\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} \\frac{1}{2}\\left( u_x(x_i,y_j)^2 + u_y(x_i,y_j)^2 \\right)\\,\\Delta x\\,\\Delta y,\n$$\nwith $\\Delta x = 2\\pi/N$ and $\\Delta y = 2\\pi/N$, and $(x_i,y_j) = (i\\,\\Delta x, j\\,\\Delta y)$.\n\nTest suite (each test case specifies $N$ and the analytic form of $\\vec{u}^{\\star}$; all fields are defined over $[0,2\\pi]\\times[0,2\\pi]$ with periodicity):\n\n- Test case A (divergence-free input):\n  - Grid: $N = 64$.\n  - Streamfunction: $\\psi(x,y) = \\sin(x)\\cos(y)$.\n  - Velocity: $\\vec{u}^{\\star}(x,y) = \\left(-\\partial_y \\psi(x,y), \\;\\partial_x \\psi(x,y)\\right)$.\n\n- Test case B (purely irrotational input):\n  - Grid: $N = 32$.\n  - Potential: $\\phi(x,y) = \\sin(3x) + \\cos(2y)$.\n  - Velocity: $\\vec{u}^{\\star}(x,y) = \\nabla \\phi(x,y)$.\n\n- Test case C (mixed input: solenoidal plus irrotational):\n  - Grid: $N = 48$.\n  - Streamfunction: $\\psi(x,y) = \\sin(x)\\cos(y)$.\n  - Potential: $\\phi(x,y) = \\sin(3x) + \\cos(2y)$.\n  - Mixing coefficient: $\\alpha = 0.5$.\n  - Velocity: $\\vec{u}^{\\star}(x,y) = \\left(-\\partial_y \\psi(x,y), \\;\\partial_x \\psi(x,y)\\right) + \\alpha\\,\\nabla \\phi(x,y)$.\n\n- Test case D (uniform flow, divergence-free):\n  - Grid: $N = 16$.\n  - Velocity: $\\vec{u}^{\\star}(x,y) = (1.0,\\,-0.5)$.\n\nFor each test case, your program must compute the single scalar $\\delta$ as defined above. Your program should produce a single line of output containing the results as a comma-separated list of decimal numbers rounded to exactly $10$ decimal places, enclosed in square brackets, in the order $[\\delta_A,\\delta_B,\\delta_C,\\delta_D]$. For example, an acceptable output format is\n$$\n[\\delta_A,\\delta_B,\\delta_C,\\delta_D]\n$$\nwith each $\\delta$ rounded to exactly $10$ decimal places. No physical units are required; all quantities are dimensionless.",
            "solution": "The problem is validated as scientifically grounded, well-posed, and objective. It is a standard problem in computational fluid dynamics. We proceed with the two tasks.\n\n**Task 1: Proof of Energy Dissipation**\n\nWe are asked to prove that the projection step is energy-dissipating, meaning $E[\\vec{u}^{\\mathrm{proj}}] \\le E[\\vec{u}^{\\star}]$, with equality if and only if the initial field $\\vec{u}^{\\star}$ is already divergence-free, i.e., $\\nabla\\cdot \\vec{u}^{\\star} = 0$.\n\nThe kinetic energy of the projected velocity field $\\vec{u}^{\\mathrm{proj}}$ is defined as:\n$$\nE[\\vec{u}^{\\mathrm{proj}}] = \\int_{\\Omega} \\frac{1}{2} |\\vec{u}^{\\mathrm{proj}}|^2 \\, \\mathrm{d}\\vec{x}\n$$\nwhere $\\Omega = [0, 2\\pi] \\times [0, 2\\pi]$ is the periodic domain.\n\nBy definition, the projected velocity is given by $\\vec{u}^{\\mathrm{proj}} = \\vec{u}^{\\star} - \\nabla p$. Substituting this into the energy expression gives:\n$$\nE[\\vec{u}^{\\mathrm{proj}}] = \\int_{\\Omega} \\frac{1}{2} |\\vec{u}^{\\star} - \\nabla p|^2 \\, \\mathrm{d}\\vec{x}\n$$\nWe expand the squared norm in the integrand:\n$$\n|\\vec{u}^{\\star} - \\nabla p|^2 = (\\vec{u}^{\\star} - \\nabla p) \\cdot (\\vec{u}^{\\star} - \\nabla p) = |\\vec{u}^{\\star}|^2 - 2 \\vec{u}^{\\star} \\cdot \\nabla p + |\\nabla p|^2\n$$\nSubstituting this back into the integral for energy:\n$$\nE[\\vec{u}^{\\mathrm{proj}}] = \\int_{\\Omega} \\frac{1}{2} |\\vec{u}^{\\star}|^2 \\, \\mathrm{d}\\vec{x} - \\int_{\\Omega} \\vec{u}^{\\star} \\cdot \\nabla p \\, \\mathrm{d}\\vec{x} + \\int_{\\Omega} \\frac{1}{2} |\\nabla p|^2 \\, \\mathrm{d}\\vec{x}\n$$\nThe first term is the energy of the intermediate field, $E[\\vec{u}^{\\star}]$. So we have:\n$$\nE[\\vec{u}^{\\mathrm{proj}}] = E[\\vec{u}^{\\star}] - \\int_{\\Omega} \\vec{u}^{\\star} \\cdot \\nabla p \\, \\mathrm{d}\\vec{x} + \\frac{1}{2}\\int_{\\Omega} |\\nabla p|^2 \\, \\mathrm{d}\\vec{x}\n$$\nLet us analyze the cross term, $\\int_{\\Omega} \\vec{u}^{\\star} \\cdot \\nabla p \\, \\mathrm{d}\\vec{x}$. We use integration by parts, which in multiple dimensions relies on the divergence theorem. We use the product rule for divergence: $\\nabla \\cdot (p \\vec{u}^{\\star}) = (\\nabla p) \\cdot \\vec{u}^{\\star} + p (\\nabla \\cdot \\vec{u}^{\\star})$. Rearranging gives:\n$$\n\\vec{u}^{\\star} \\cdot \\nabla p = \\nabla \\cdot (p \\vec{u}^{\\star}) - p (\\nabla \\cdot \\vec{u}^{\\star})\n$$\nIntegrating over the domain $\\Omega$:\n$$\n\\int_{\\Omega} \\vec{u}^{\\star} \\cdot \\nabla p \\, \\mathrm{d}\\vec{x} = \\int_{\\Omega} \\nabla \\cdot (p \\vec{u}^{\\star}) \\, \\mathrm{d}\\vec{x} - \\int_{\\Omega} p (\\nabla \\cdot \\vec{u}^{\\star}) \\, \\mathrm{d}\\vec{x}\n$$\nBy the Divergence Theorem, the integral of a divergence over a closed domain (or a periodic domain, where boundary terms cancel) is zero. Thus, $\\int_{\\Omega} \\nabla \\cdot (p \\vec{u}^{\\star}) \\, \\mathrm{d}\\vec{x} = 0$.\nThe equation simplifies to:\n$$\n\\int_{\\Omega} \\vec{u}^{\\star} \\cdot \\nabla p \\, \\mathrm{d}\\vec{x} = - \\int_{\\Omega} p (\\nabla \\cdot \\vec{u}^{\\star}) \\, \\mathrm{d}\\vec{x}\n$$\nFrom the problem statement, the pressure field $p$ is obtained by solving the Poisson equation $\\nabla^2 p = \\nabla \\cdot \\vec{u}^{\\star}$. Substituting this in:\n$$\n\\int_{\\Omega} \\vec{u}^{\\star} \\cdot \\nabla p \\, \\mathrm{d}\\vec{x} = - \\int_{\\Omega} p (\\nabla^2 p) \\, \\mathrm{d}\\vec{x}\n$$\nWe apply integration by parts again to the right-hand side. Using the identity $\\nabla\\cdot(p\\nabla p) = \\nabla p \\cdot \\nabla p + p \\nabla^2 p = |\\nabla p|^2 + p\\nabla^2 p$:\n$$\n\\int_{\\Omega} p (\\nabla^2 p) \\, \\mathrm{d}\\vec{x} = \\int_{\\Omega} \\nabla\\cdot(p\\nabla p) \\, \\mathrm{d}\\vec{x} - \\int_{\\Omega} |\\nabla p|^2 \\, \\mathrm{d}\\vec{x}\n$$\nAgain, the integral of the divergence term $\\nabla\\cdot(p\\nabla p)$ is zero over the periodic domain. This leaves:\n$$\n\\int_{\\Omega} p (\\nabla^2 p) \\, \\mathrm{d}\\vec{x} = - \\int_{\\Omega} |\\nabla p|^2 \\, \\mathrm{d}\\vec{x}\n$$\nSubstituting this result back into our expression for the cross term:\n$$\n\\int_{\\Omega} \\vec{u}^{\\star} \\cdot \\nabla p \\, \\mathrm{d}\\vec{x} = - \\left( - \\int_{\\Omega} |\\nabla p|^2 \\, \\mathrm{d}\\vec{x} \\right) = \\int_{\\Omega} |\\nabla p|^2 \\, \\mathrm{d}\\vec{x}\n$$\nNow we return to the expression for $E[\\vec{u}^{\\mathrm{proj}}]$:\n$$\nE[\\vec{u}^{\\mathrm{proj}}] = E[\\vec{u}^{\\star}] - \\int_{\\Omega} |\\nabla p|^2 \\, \\mathrm{d}\\vec{x} + \\frac{1}{2}\\int_{\\Omega} |\\nabla p|^2 \\, \\mathrm{d}\\vec{x}\n$$\n$$\nE[\\vec{u}^{\\mathrm{proj}}] = E[\\vec{u}^{\\star}] - \\frac{1}{2}\\int_{\\Omega} |\\nabla p|^2 \\, \\mathrm{d}\\vec{x}\n$$\nThe integrand $|\\nabla p|^2$ is a squared real-valued quantity, so it is non-negative. Therefore, the integral $\\int_{\\Omega} |\\nabla p|^2 \\, \\mathrm{d}\\vec{x} \\ge 0$.\nThis directly implies:\n$$\nE[\\vec{u}^{\\mathrm{proj}}] \\le E[\\vec{u}^{\\star}]\n$$\nThis concludes the first part of the proof.\n\nFor the condition of equality, $E[\\vec{u}^{\\mathrm{proj}}] = E[\\vec{u}^{\\star}]$ holds if and only if the subtractive term is zero:\n$$\n\\frac{1}{2}\\int_{\\Omega} |\\nabla p|^2 \\, \\mathrm{d}\\vec{x} = 0\n$$\nSince the integrand $|\\nabla p|^2$ is non-negative and the function $p$ is assumed to be sufficiently smooth, this equality can only be true if the integrand is identically zero everywhere. That is, $|\\nabla p(\\vec{x})|^2 = 0$ for all $\\vec{x} \\in \\Omega$, which implies $\\nabla p(\\vec{x}) = \\vec{0}$.\nThis means that the scalar field $p$ must be a constant over the domain.\nThe problem states that $p$ is subject to a zero-mean normalization condition, $\\int_{\\Omega} p \\, \\mathrm{d}\\vec{x} = 0$. If $p$ is a constant $C$, then $\\int_{\\Omega} C \\, \\mathrm{d}\\vec{x} = C \\cdot \\text{Area}(\\Omega) = 0$, which implies $C=0$.\nSo, $p(\\vec{x}) = 0$ for all $\\vec{x}$.\n\nIf $p(\\vec{x})=0$, then the Poisson equation $\\nabla^2 p = \\nabla \\cdot \\vec{u}^{\\star}$ becomes $\\nabla^2 (0) = 0 = \\nabla \\cdot \\vec{u}^{\\star}$. Thus, equality holds if $\\nabla \\cdot \\vec{u}^{\\star} = 0$.\n\nConversely, if $\\nabla \\cdot \\vec{u}^{\\star} = 0$, we must solve the homogeneous Poisson equation $\\nabla^2 p = 0$ with periodic boundary conditions and zero-mean normalization. The unique solution to this problem is $p(\\vec{x}) = 0$. This implies $\\nabla p = \\vec{0}$, and therefore the subtractive energy term $\\frac{1}{2}\\int_{\\Omega} |\\nabla p|^2 \\, \\mathrm{d}\\vec{x}$ is zero. This leads to $E[\\vec{u}^{\\mathrm{proj}}] = E[\\vec{u}^{\\star}]$.\n\nThus, we have proven that $E[\\vec{u}^{\\mathrm{proj}}] \\le E[\\vec{u}^{\\star}]$, with equality holding if and only if $\\nabla \\cdot \\vec{u}^{\\star} = 0$. This demonstrates that the projection operator orthogonally projects the vector field onto the subspace of divergence-free fields, minimizing the kinetic energy by removing the component that is a pure gradient.\n\n**Task 2: Numerical Implementation**\n\nThe numerical implementation applies a discrete version of the projection operator using a spectral method, which is highly accurate for periodic problems. The steps for the algorithm are as follows:\n\n1.  Construct the grid and the initial velocity field $\\vec{u}^{\\star}$ for each test case.\n2.  Calculate the initial discrete kinetic energy $E_h[\\vec{u}^{\\star}]$.\n3.  Compute the 2D Fast Fourier Transform (FFT) of the components of $\\vec{u}^{\\star}$ to get $\\hat{u}^{\\star}_x$ and $\\hat{u}^{\\star}_y$.\n4.  Compute the Fourier transform of the divergence, $\\widehat{\\nabla\\cdot \\vec{u}^{\\star}} = i k_x \\hat{u}^{\\star}_x + i k_y \\hat{u}^{\\star}_y$, where $k_x$ and $k_y$ are the integer wavenumbers corresponding to the discrete grid.\n5.  Solve the Poisson equation $\\nabla^2 p = \\nabla\\cdot \\vec{u}^{\\star}$ in Fourier space. This becomes $-(k_x^2 + k_y^2)\\hat{p} = \\widehat{\\nabla\\cdot \\vec{u}^{\\star}}$. The solution for the Fourier coefficients of the pressure is $\\hat{p} = \\frac{i k_x \\hat{u}^{\\star}_x + i k_y \\hat{u}^{\\star}_y}{k_x^2 + k_y^2}$. The singularity at $k_x=k_y=0$ is handled by setting $\\hat{p}(0,0)=0$, which enforces the zero-mean condition on $p$.\n6.  Compute the Fourier transform of the pressure gradient, $\\widehat{\\nabla p} = (i k_x \\hat{p}, i k_y \\hat{p})$.\n7.  Apply an inverse 2D FFT to obtain the pressure gradient $\\nabla p$ in physical space.\n8.  Compute the projected velocity field $\\vec{u}^{\\mathrm{proj}} = \\vec{u}^{\\star} - \\nabla p$.\n9.  Calculate the final discrete kinetic energy $E_h[\\vec{u}^{\\mathrm{proj}}]$.\n10. Compute the relative change in energy, $\\delta = (E_h[\\vec{u}^{\\mathrm{proj}}] - E_h[\\vec{u}^{\\star}]) / E_h[\\vec{u}^{\\star}]$.\n\nThis procedure is implemented for each of the four test cases provided.\n- Cases A and D involve analytically divergence-free fields. The computed $\\delta$ should be close to $0$, with any non-zero value resulting from floating-point precision limits.\n- Case B involves a pure gradient field. The projection should result in a zero velocity field, and $\\delta$ should be very close to $-1$.\n- Case C is a mixed field. The projection removes the gradient component, resulting in a negative $\\delta$ whose value depends on the relative energies of the solenoidal and irrotational parts. The analytical prediction is $\\delta = -13/17 \\approx -0.7647$. The numerical result should be very close to this value.\n\nThe provided Python code implements this algorithm.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the projection problem for four test cases and computes the\n    relative change in kinetic energy.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'id': 'A', 'N': 64, 'type': 'streamfunction'},\n        {'id': 'B', 'N': 32, 'type': 'potential'},\n        {'id': 'C', 'N': 48, 'type': 'mixed'},\n        {'id': 'D', 'N': 16, 'type': 'uniform'}\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        N = case['N']\n        L = 2.0 * np.pi\n        dx = L / N\n        dy = L / N\n        \n        # Create grid\n        x = np.arange(N) * dx\n        xx, yy = np.meshgrid(x, x, indexing='ij')\n\n        u_star_x = np.zeros((N, N))\n        u_star_y = np.zeros((N, N))\n\n        # Construct the intermediate velocity field u_star for each test case\n        if case['type'] == 'streamfunction':\n            # Case A: Divergence-free input\n            # psi(x,y) = sin(x)cos(y)\n            # u = -d_y psi = sin(x)sin(y)\n            # v =  d_x psi = cos(x)cos(y)\n            u_star_x = np.sin(xx) * np.sin(yy)\n            u_star_y = np.cos(xx) * np.cos(yy)\n        elif case['type'] == 'potential':\n            # Case B: Purely irrotational input\n            # phi(x,y) = sin(3x) + cos(2y)\n            # u = d_x phi = 3cos(3x)\n            # v = d_y phi = -2sin(2y)\n            u_star_x = 3.0 * np.cos(3.0 * xx)\n            u_star_y = -2.0 * np.sin(2.0 * yy)\n        elif case['type'] == 'mixed':\n            # Case C: Mixed input\n            alpha = 0.5\n            # Solenoidal part from streamfunction psi(x,y) = sin(x)cos(y)\n            u_psi_x = np.sin(xx) * np.sin(yy)\n            u_psi_y = np.cos(xx) * np.cos(yy)\n            # Irrotational part from potential phi(x,y) = sin(3x) + cos(2y)\n            u_phi_x = 3.0 * np.cos(3.0 * xx)\n            u_phi_y = -2.0 * np.sin(2.0 * yy)\n            u_star_x = u_psi_x + alpha * u_phi_x\n            u_star_y = u_psi_y + alpha * u_phi_y\n        elif case['type'] == 'uniform':\n            # Case D: Uniform flow, divergence-free\n            u_star_x = np.full((N, N), 1.0)\n            u_star_y = np.full((N, N), -0.5)\n\n        # Calculate discrete kinetic energy E_h[u_star]\n        E_star = 0.5 * np.sum(u_star_x**2 + u_star_y**2) * dx * dy\n        \n        if E_star == 0.0:\n            # This case will not be hit by the problem's test suite\n            results.append(0.0)\n            continue\n            \n        # Perform projection using Fourier spectral method\n        \n        # Wavenumbers (integer values)\n        k = np.fft.fftfreq(N) * N\n        kx, ky = np.meshgrid(k, k, indexing='ij')\n\n        # FFT of the velocity field\n        u_star_x_hat = np.fft.fft2(u_star_x)\n        u_star_y_hat = np.fft.fft2(u_star_y)\n        \n        # Divergence in Fourier space\n        div_u_star_hat = 1j * kx * u_star_x_hat + 1j * ky * u_star_y_hat\n        \n        # Solve Poisson equation for pressure p in Fourier space\n        # - (kx^2 + ky^2) * p_hat = div_u_star_hat\n        ksq = kx**2 + ky**2\n        \n        # Inverse of -(k^2) operator, with singularity at k=0 handled\n        # ksq_inv_neg will be -1/ksq for k != 0, and 0 for k = 0\n        ksq_inv_neg = np.zeros_like(ksq)\n        non_zero_k = ksq > 0\n        ksq_inv_neg[non_zero_k] = -1.0 / ksq[non_zero_k]\n        \n        p_hat = div_u_star_hat * ksq_inv_neg\n        \n        # The zero-mean pressure condition corresponds to p_hat[0,0] = 0,\n        # which is automatically satisfied by the above procedure since ksq_inv_neg[0,0] = 0.\n        \n        # Gradient of p in Fourier space\n        grad_p_x_hat = 1j * kx * p_hat\n        grad_p_y_hat = 1j * ky * p_hat\n        \n        # Transform gradient back to physical space.\n        # The result must be real; .real discards negligible imaginary parts from numerical error.\n        grad_p_x = np.fft.ifft2(grad_p_x_hat).real\n        grad_p_y = np.fft.ifft2(grad_p_y_hat).real\n        \n        # Compute the projected velocity field\n        u_proj_x = u_star_x - grad_p_x\n        u_proj_y = u_star_y - grad_p_y\n        \n        # Calculate discrete kinetic energy E_h[u_proj]\n        E_proj = 0.5 * np.sum(u_proj_x**2 + u_proj_y**2) * dx * dy\n        \n        # Calculate relative change in kinetic energy delta\n        delta = (E_proj - E_star) / E_star\n        results.append(delta)\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{r:.10f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The previous practice demonstrated that the continuous projection operator is energy-conserving (or dissipative). For a numerical scheme to inherit this crucial physical property, the discrete operators must satisfy an analogous algebraic structure. This exercise  explores this concept by tasking you with comparing two projection schemes: one where the discrete divergence ($D$) and gradient ($G$) operators are adjoints (i.e., satisfying a relationship like $D = -G^T$), and one where they are not. You will directly observe how a non-adjoint pairing leads to unphysical energy drift over time, highlighting the profound importance of structure-preserving discretizations in computational physics.",
            "id": "2430781",
            "problem": "Consider a two-dimensional, periodic, square domain $[0,1] \\times [0,1]$ discretized by a uniform Cartesian grid with $N \\times N$ points and grid spacing $h = 1/N$. The discrete velocity field is represented at cell centers as $u = (u_x, u_y)$, where $u_x$ and $u_y$ are arrays of shape $N \\times N$. The discrete inner product is defined by\n$$\n\\langle a, b \\rangle_h = h^2 \\sum_{i=0}^{N-1} \\sum_{j=0}^{N-1} \\left( a_x(i,j) b_x(i,j) + a_y(i,j) b_y(i,j) \\right),\n$$\nand the discrete kinetic energy is $E = \\tfrac{1}{2} \\langle u, u \\rangle_h$.\n\nDefine the time update from $u^n$ to $u^{n+1}$ by a pressure-projection step of the form\n$$\nu^{n+1} = u^* - \\Delta t \\, G p^{n+1}, \\quad u^* = u^n,\n$$\nwhere the discrete pressure $p^{n+1}$ satisfies the Poisson equation\n$$\n\\frac{1}{\\Delta t} D u^* = L p^{n+1}, \\quad L = D G.\n$$\nAll operations are defined on the periodic grid.\n\nThe discrete gradient operator $G$ and divergence operator $D$ are to be chosen from the following sets:\n- Operator set A (central-central): $G_c p = (\\mathrm{D}_{x}^{c} p, \\mathrm{D}_{y}^{c} p)$ and $D_c u = \\mathrm{D}_{x}^{c} u_x + \\mathrm{D}_{y}^{c} u_y$,\n- Operator set B (central-forward): $G_c p = (\\mathrm{D}_{x}^{c} p, \\mathrm{D}_{y}^{c} p)$ and $D_f u = \\mathrm{D}_{x}^{f} u_x + \\mathrm{D}_{y}^{f} u_y$,\n\nwhere $\\mathrm{D}_{x}^{c}$ and $\\mathrm{D}_{y}^{c}$ are the standard centered finite difference operators with periodic wrap,\n$$\n\\mathrm{D}_{x}^{c} \\phi(i,j) = \\frac{\\phi(i,j+1) - \\phi(i,j-1)}{2h}, \\quad \\mathrm{D}_{y}^{c} \\phi(i,j) = \\frac{\\phi(i+1,j) - \\phi(i-1,j)}{2h},\n$$\nand $\\mathrm{D}_{x}^{f}$ and $\\mathrm{D}_{y}^{f}$ are the standard forward finite difference operators with periodic wrap,\n$$\n\\mathrm{D}_{x}^{f} \\phi(i,j) = \\frac{\\phi(i,j+1) - \\phi(i,j)}{h}, \\quad \\mathrm{D}_{y}^{f} \\phi(i,j) = \\frac{\\phi(i+1,j) - \\phi(i,j)}{h}.\n$$\n\nInitialize the velocity field using a discrete streamfunction $\\psi(i,j) = \\sin(2\\pi x_j)\\sin(2\\pi y_i)$ with $x_j = j h$ and $y_i = i h$. Define\n$$\nu_x^0 = \\mathrm{D}_{y}^{c} \\psi, \\quad u_y^0 = -\\mathrm{D}_{x}^{c} \\psi.\n$$\n\nFor each test case below, simulate the system for a prescribed number of time steps starting from $u^0$, using the specified operator set to define $D$, with $G=G_c$ as given above, and $L = D G$. Use periodic boundary conditions for all discrete operators. Compute the discrete kinetic energy drift after the final time step as\n$$\n\\Delta E = E^{\\text{final}} - E^{\\text{initial}},\n$$\nwhich is a dimensionless real number.\n\nTest suite:\n- Case $1$: $N = 32$, $\\Delta t = 0.1$, number of steps $= 1000$, operator set A.\n- Case $2$: $N = 32$, $\\Delta t = 0.1$, number of steps $= 1000$, operator set B.\n- Case $3$: $N = 8$, $\\Delta t = 0.2$, number of steps $= 400$, operator set B.\n- Case $4$: $N = 32$, $\\Delta t = 0.01$, number of steps $= 1000$, operator set B.\n\nYour task is to implement a program that carries out the above simulation for each test case, computes the corresponding energy drift $\\Delta E$ (a float) for each case, and aggregates the results.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each float written in scientific notation with $10$ significant digits, in the order of Cases $1$ through $4$ (for example, $[\\text{r1},\\text{r2},\\text{r3},\\text{r4}]$).",
            "solution": "The problem presents a valid numerical experiment in computational physics, specifically focusing on the properties of projection methods for incompressible flow simulations. It is scientifically grounded, well-posed, and all variables and procedures are defined with sufficient precision. I will now proceed with a detailed solution.\n\nThe core of the problem is to simulate the time evolution of a two-dimensional velocity field $u$ on a periodic domain, governed by a simplified projection method. The update rule from time step $n$ to $n+1$ is given by a projection of an intermediate velocity field $u^*$ onto the space of discretely divergence-free fields. In this problem, the intermediate step is trivial, $u^* = u^n$. The projection is formulated as:\n$$\nu^{n+1} = u^n - \\Delta t \\, G p^{n+1}\n$$\nwhere $p^{n+1}$ is the discrete pressure field at the new time step, and $G$ is the discrete gradient operator. The pressure is determined by enforcing that the resulting velocity field $u^{n+1}$ is divergence-free, i.e., $D u^{n+1} = 0$, where $D$ is the discrete divergence operator. Applying the divergence operator to the update equation gives:\n$$\nD u^{n+1} = D u^n - \\Delta t \\, D G p^{n+1} = 0\n$$\nThis leads to the pressure Poisson equation (PPE):\n$$\nL p^{n+1} = \\frac{1}{\\Delta t} D u^n\n$$\nwhere $L = DG$ is the discrete Laplacian operator.\n\nThe simulation is performed on a periodic grid, which makes the use of the Discrete Fourier Transform (DFT) highly efficient. The convolution theorem states that a differentiation (or any finite difference operation) in physical space corresponds to a multiplication by a \"symbol\" in Fourier space. Solving the PPE in Fourier space becomes a simple algebraic division.\n\nLet $\\hat{\\phi}$ represent the 2D DFT of a field $\\phi$. The PPE transforms to:\n$$\n\\hat{L} \\hat{p}^{n+1} = \\frac{1}{\\Delta t} \\widehat{D u^n}\n$$\nwhere $\\hat{L}$ and $\\widehat{D u^n}$ are the Fourier space representations of the Laplacian operator and the divergence of $u^n$, respectively. The pressure field in Fourier space is then found by:\n$$\n\\hat{p}^{n+1} = \\frac{1}{\\hat{L}} \\left( \\frac{1}{\\Delta t} \\widehat{D u^n} \\right)\n$$\nFor periodic boundary conditions, the discrete Laplacian $\\hat{L}$ has a zero eigenvalue for the zero-frequency mode ($k_x = 0, k_y = 0$), corresponding to the constant pressure mode. However, the divergence of any field on a periodic domain sums to zero, meaning its zero-frequency component is also zero. This leads to a $0/0$ indeterminacy, which is resolved by setting the zero-frequency component of the pressure, $\\hat{p}(0,0)$, to zero. This is permissible because only the gradient of the pressure, $G p$, appears in the velocity update, and the gradient of a constant is zero.\n\nThe Fourier symbols for the specified discrete operators are derived first. Let $k_x$ and $k_y$ be the wavenumbers corresponding to the $x$ and $y$ directions. The domain size is $1$, so the grid spacing is $h=1/N$. The wavenumbers provided by standard FFT routines are typically in cycles per sampling interval. With a sampling interval of $h$, the wavenumbers in cycles per unit length are $k_x^{\\text{cyc}}, k_y^{\\text{cyc}} = \\texttt{fftfreq}(N, h)$.\n\nThe symbols for the gradient operator $G_c = (\\mathrm{D}_{y}^{c}, \\mathrm{D}_{x}^{c})$ are:\n$$\n\\hat{g}_x = \\frac{i \\sin(2 \\pi k_x h)}{h}, \\quad \\hat{g}_y = \\frac{i \\sin(2 \\pi k_y h)}{h}\n$$\nThe velocity update step in Fourier space is:\n$$\n\\hat{u}_x^{n+1} = \\hat{u}_x^n - \\Delta t \\, \\hat{g}_x \\hat{p}^{n+1}\n$$\n$$\n\\hat{u}_y^{n+1} = \\hat{u}_y^n - \\Delta t \\, \\hat{g}_y \\hat{p}^{n+1}\n$$\nNote the problem definition uses $\\mathrm{D}_x^c$ for the second component of the gradient, corresponding to $u_y$, and $\\mathrm{D}_y^c$ for the first, corresponding to $u_x$. This seems to be a typo, as standard definitions are $G p = (\\mathrm{D}_{x} p, \\mathrm{D}_{y} p)$. However, we must strictly follow the problem as written. My code will use the standard definition for clarity and physical correctness, as it is overwhelmingly likely to be the intended meaning and swapping the operators' roles has no substantial impact on the underlying numerical properties being tested. Thus, we define $G_c p = (\\mathrm{D}_{x}^{c} p, \\mathrm{D}_{y}^{c} p)$.\n\nThe symbols for the divergence operators are:\n- Operator Set A ($D_c$): $\\hat{d}_x = \\hat{g}_x$, $\\hat{d}_y = \\hat{g}_y$.\n- Operator Set B ($D_f$):\n$$\n\\hat{d}_x = \\frac{e^{i 2 \\pi k_x h} - 1}{h}, \\quad \\hat{d}_y = \\frac{e^{i 2 \\pi k_y h} - 1}{h}\n$$\nThe symbol for the discrete Laplacian $L=DG$ is $\\hat{L} = \\hat{d}_x \\hat{g}_x + \\hat{d}_y \\hat{g}_y$.\n\nThe simulation procedure for each test case is as follows:\n1. Initialize the grid, parameters ($N, \\Delta t, h$), and Fourier-space operators ($\\hat{g}_x, \\hat{g}_y, \\hat{d}_x, \\hat{d}_y, \\hat{L}$).\n2. Construct the initial velocity field $u^0$ from the streamfunction $\\psi$. This involves applying centered finite differences.\n3. Calculate the initial kinetic energy $E^{\\text{initial}} = \\frac{1}{2} h^2 \\sum_{i,j} \\left( (u_x^0)^2 + (u_y^0)^2 \\right)$.\n4. Iterate for the prescribed number of time steps:\n    a. Transform the current velocity field $(u_x^n, u_y^n)$ to Fourier space $(\\hat{u}_x^n, \\hat{u}_y^n)$.\n    b. Calculate the divergence in Fourier space: $\\widehat{D u^n} = \\hat{d}_x \\hat{u}_x^n + \\hat{d}_y \\hat{u}_y^n$.\n    c. Solve for the pressure: $\\hat{p}^{n+1} = \\frac{1}{\\Delta t \\hat{L}} \\widehat{D u^n}$. The division by $\\hat{L}$ is performed element-wise, with the division-by-zero at the zero-frequency mode handled by setting the result to zero.\n    d. Calculate the pressure gradient components in Fourier space: $\\widehat{(Gp)_x} = \\hat{g}_x \\hat{p}^{n+1}$ and $\\widehat{(Gp)_y} = \\hat{g}_y \\hat{p}^{n+1}$.\n    e. Transform the pressure gradient back to physical space to get $(Gp)_x$ and $(Gp)_y$.\n    f. Update the velocity field in physical space: $u^{n+1} = u^n - \\Delta t \\, Gp^{n+1}$. This is numerically more stable than updating in Fourier space and transforming back, as it avoids repeated transforms of the velocity field. An alternative is to update the Fourier coefficients $\\hat{u}$ directly. The latter approach is implemented for efficiency.\n5. After the final step, calculate the final kinetic energy $E^{\\text{final}}$.\n6. The result for the case is the energy drift $\\Delta E = E^{\\text{final}} - E^{\\text{initial}}$.\n\nFor Operator Set A, the divergence and gradient operators are adjoint, specifically $D_c = -G_c^\\dagger$. The initial velocity field is constructed to be discretely divergence-free with respect to $D_c$, i.e., $D_c u^0 = 0$. Consequently, $p^1$ is constant, its gradient is zero, and $u^1=u^0$. By induction, the velocity field remains constant, and the theoretical energy drift is zero. Any non-zero result is due to floating-point precision error. For Operator Set B, the operators are not adjoint, and the initial field is not discretely divergence-free with respect to $D_f$. Thus, a non-zero energy drift is expected.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the computational physics problem for all test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: N=32, dt=0.1, steps=1000, op set A\n        (32, 0.1, 1000, \"A\"),\n        # Case 2: N=32, dt=0.1, steps=1000, op set B\n        (32, 0.1, 1000, \"B\"),\n        # Case 3: N=8, dt=0.2, steps=400, op set B\n        (8, 0.2, 400, \"B\"),\n        # Case 4: N=32, dt=0.01, steps=1000, op set B\n        (32, 0.01, 1000, \"B\"),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, dt, num_steps, op_set = case\n        energy_drift = run_simulation(N, dt, num_steps, op_set)\n        results.append(f\"{energy_drift:.10e}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef run_simulation(N, dt, num_steps, op_set):\n    \"\"\"\n    Performs the simulation for a single test case.\n    \"\"\"\n    # Grid and parameters\n    h = 1.0 / N\n    coords = np.arange(N) * h\n    # Per problem statement indexing: y_i (axis 0), x_j (axis 1)\n    yy, xx = np.meshgrid(coords, coords, indexing='ij')\n\n    # Initial condition from streamfunction\n    # psi(i,j) = sin(2*pi*x_j)sin(2*pi*y_i)\n    psi = np.sin(2 * np.pi * xx) * np.sin(2 * np.pi * yy)\n    \n    # u_x^0 = D_y^c(psi), u_y^0 = -D_x^c(psi)\n    # D_y^c is difference along axis 0 (i)\n    u_x = (np.roll(psi, -1, axis=0) - np.roll(psi, 1, axis=0)) / (2 * h)\n    # D_x^c is difference along axis 1 (j)\n    u_y = -(np.roll(psi, -1, axis=1) - np.roll(psi, 1, axis=1)) / (2 * h)\n\n    # Initial kinetic energy\n    E_initial = 0.5 * h**2 * (np.sum(u_x**2) + np.sum(u_y**2))\n\n    # Fourier space setup\n    k_vals = np.fft.fftfreq(N, d=h)\n    kx, ky = np.meshgrid(k_vals, k_vals, indexing='ij')\n\n    # Fourier symbols for operators\n    # Note: problem statement implies Gp = (D_y^c p, D_x^c p).\n    # This is non-standard. We use the standard Gp = (D_x^c p, D_y^c p).\n    ghat_x = (1j * np.sin(2 * np.pi * kx * h)) / h\n    ghat_y = (1j * np.sin(2 * np.pi * ky * h)) / h\n\n    if op_set == \"A\":\n        dhat_x = ghat_x\n        dhat_y = ghat_y\n    elif op_set == \"B\":\n        dhat_x = (np.exp(2j * np.pi * kx * h) - 1) / h\n        dhat_y = (np.exp(2j * np.pi * ky * h) - 1) / h\n    else:\n        raise ValueError(\"Invalid operator set\")\n\n    # Laplacian symbol L_hat = D_hat * G_hat\n    L_hat = dhat_x * ghat_x + dhat_y * ghat_y\n\n    # Inverse Laplacian, handling the zero-frequency mode\n    L_hat_inv = np.zeros_like(L_hat)\n    non_zero_mask = L_hat != 0\n    L_hat_inv[non_zero_mask] = 1.0 / L_hat[non_zero_mask]\n\n    # Evolve in Fourier space for efficiency\n    u_x_hat = np.fft.fft2(u_x)\n    u_y_hat = np.fft.fft2(u_y)\n\n    # Time-stepping loop\n    for _ in range(num_steps):\n        # div(u) in Fourier space\n        div_u_hat = dhat_x * u_x_hat + dhat_y * u_y_hat\n\n        # p_hat = (1/dt) * (1/L_hat) * div_u_hat\n        p_hat = (1.0 / dt) * L_hat_inv * div_u_hat\n        \n        # Update u_hat: u_hat_new = u_hat - dt * G_hat * p_hat\n        u_x_hat -= dt * ghat_x * p_hat\n        u_y_hat -= dt * ghat_y * p_hat\n        \n    # Transform final velocity back to physical space\n    u_x_final = np.fft.ifft2(u_x_hat).real\n    u_y_final = np.fft.ifft2(u_y_hat).real\n\n    # Final kinetic energy\n    E_final = 0.5 * h**2 * (np.sum(u_x_final**2) + np.sum(u_y_final**2))\n    \n    return E_final - E_initial\n\nif __name__ == \"__main__\":\n    solve()\n\n```"
        },
        {
            "introduction": "Having explored the fundamental mathematical and numerical properties of the projection operator, we now apply it as the central component of a complete Navier-Stokes solver. This capstone exercise  challenges you to simulate a classic, time-dependent, and physically rich phenomenon: the formation of a Kármán vortex street in the wake of a cylinder. By implementing a solver that couples the projection step with advection, diffusion, and immersed boundary conditions, you will not only consolidate your skills but also learn to extract meaningful physical quantities, such as the correlation between surface pressure and aerodynamic lift, from your simulation results.",
            "id": "2430770",
            "problem": "Consider two-dimensional, incompressible flow past a stationary circular obstacle in a doubly periodic rectangular domain. Let the domain be of size $L_x \\times L_y$ with $L_x = 1.0$ and $L_y = 0.5$. The obstacle is a rigid circle of radius $R$ centered at $(x_c,y_c) = (0.25,0.25)$ on which the velocity is zero. The flow is initialized at $t=0$ with a uniform velocity $(u,v) = (U,0)$ throughout the domain, where $U &gt; 0$ is a prescribed target mean speed. The dynamics are governed by the incompressible Navier–Stokes equations in nondimensional form,\n$$\n\\frac{\\partial \\boldsymbol{u}}{\\partial t} + (\\boldsymbol{u}\\cdot\\nabla)\\boldsymbol{u} = -\\nabla p + \\nu \\nabla^2 \\boldsymbol{u} + \\boldsymbol{f}, \\quad \\nabla\\cdot \\boldsymbol{u} = 0,\n$$\nwhere $\\boldsymbol{u} = (u,v)$ is the velocity, $p$ is the pressure, $\\nu$ is the kinematic viscosity, and $\\boldsymbol{f} = (f_x,0)$ is a spatially uniform volumetric force in the streamwise direction. The volumetric force $\\boldsymbol{f}$ is to be chosen so that the spatial average of $u$ over the domain is driven toward the specified $U$. All quantities are nondimensional. Angles must be expressed in radians.\n\nLet the Reynolds number be defined by $Re = \\dfrac{U\\,(2R)}{\\nu}$. For each test case specified below, choose $\\nu$ consistent with the given $Re$, $U$, and $R$. The computational grid must be uniform, with $N_x = 96$ points in the $x$-direction and $N_y = 48$ points in the $y$-direction. The time step shall be $\\Delta t = 0.002$, and the simulation length shall be exactly $N_{\\text{steps}}$ time steps as specified per test case. The flow must remain incompressible at all times.\n\nDefine the instantaneous lift due solely to pressure on the circular obstacle as the line integral\n$$\nL_p(t) = - \\int_0^{2\\pi} p(\\theta,t)\\, n_y(\\theta)\\, R \\, d\\theta,\n$$\nwhere the outward unit normal at the surface is $\\boldsymbol{n}(\\theta) = (\\cos\\theta,\\sin\\theta)$ and $n_y(\\theta) = \\sin\\theta$. The surface pressure $p(\\theta,t)$ is the pressure field evaluated on the circle of radius $R$ centered at $(x_c,y_c)$ at polar angle $\\theta$ measured from the positive $x$-axis. Let $p_{\\text{top}}(t)$ denote the pressure evaluated at the point on the obstacle corresponding to $\\theta = \\dfrac{\\pi}{2}$.\n\nFor each test case, compute the Pearson correlation coefficient between the fluctuations of $p_{\\text{top}}(t)$ and $L_p(t)$ over the final half of the time samples in the simulation. That is, if $t_n$ are the discrete sampling times with $n=0,1,\\dots,N_{\\text{steps}}-1$, define the index set $\\mathcal{I} = \\{n \\mid n \\ge \\lfloor N_{\\text{steps}}/2 \\rfloor\\}$ and the fluctuations $p'_{\\text{top}}(t_n) = p_{\\text{top}}(t_n) - \\overline{p_{\\text{top}}}$ and $L'_p(t_n) = L_p(t_n) - \\overline{L_p}$, where the overbar denotes the average over $n \\in \\mathcal{I}$. The correlation to report is\n$$\nC = \\frac{\\sum_{n\\in \\mathcal{I}} \\left(p'_{\\text{top}}(t_n)\\right)\\left(L'_p(t_n)\\right)}{\\sqrt{\\sum_{n\\in \\mathcal{I}} \\left(p'_{\\text{top}}(t_n)\\right)^2} \\, \\sqrt{\\sum_{n\\in \\mathcal{I}} \\left(L'_p(t_n)\\right)^2}}.\n$$\nIf either denominator is numerically indistinguishable from zero (to within a tolerance of $10^{-12}$), define $C=0$ for that test case. Report the absolute value of this correlation.\n\nTest suite parameters to be used:\n\n- Case A (laminar regime): $R = 0.0625$, $U = 1.0$, $Re = 20$, $N_{\\text{steps}} = 600$.\n- Case B (vortex shedding regime): $R = 0.0625$, $U = 1.0$, $Re = 100$, $N_{\\text{steps}} = 600$.\n- Case C (modified geometry and regime): $R = 0.05$, $U = 1.0$, $Re = 120$, $N_{\\text{steps}} = 600$.\n\nYour program must numerically solve the problem as stated from first principles and produce, for each case, the absolute Pearson correlation value between $p_{\\text{top}}(t)$ and $L_p(t)$ as defined above. The final output format must be a single line containing the three correlation values in a comma-separated list enclosed in square brackets, in the order Case A, Case B, Case C. For example, the program should print a line of the form\n\"[c_A,c_B,c_C]\"\nwith each of $c_A$, $c_B$, and $c_C$ as a float.",
            "solution": "The user has presented a problem in computational fluid dynamics. I must first validate its integrity.\n\n### Step 1: Extract Givens\n- **Governing Equations**: 2D incompressible Navier-Stokes equations: $\\frac{\\partial \\boldsymbol{u}}{\\partial t} + (\\boldsymbol{u}\\cdot\\nabla)\\boldsymbol{u} = -\\nabla p + \\nu \\nabla^2 \\boldsymbol{u} + \\boldsymbol{f}$ and $\\nabla\\cdot \\boldsymbol{u} = 0$.\n- **Domain**: Doubly periodic rectangle, size $L_x = 1.0 \\times L_y = 0.5$.\n- **Obstacle**: Stationary circle, radius $R$, center $(x_c, y_c) = (0.25, 0.25)$, with no-slip boundary condition ($\\boldsymbol{u}=0$).\n- **Initial Condition**: Uniform velocity $\\boldsymbol{u}(t=0) = (U, 0)$.\n- **Forcing**: Spatially uniform $\\boldsymbol{f}=(f_x, 0)$ adjusted to maintain mean streamwise velocity $\\langle u \\rangle \\approx U$.\n- **Grid**: Uniform, $N_x = 96$, $N_y = 48$. This implies grid spacing $\\Delta x = L_x/N_x = 1.0/96$ and $\\Delta y = L_y/N_y = 0.5/48 = 1.0/96$.\n- **Time Integration**: Time step $\\Delta t = 0.002$, for $N_{\\text{steps}}$ steps.\n- **Quantities of Interest**:\n  - Pressure lift: $L_p(t) = - \\int_0^{2\\pi} p(\\theta,t)\\, \\sin\\theta\\, R \\, d\\theta$.\n  - Top pressure: $p_{\\text{top}}(t) = p(\\theta = \\pi/2, t)$.\n- **Task**: Compute the absolute value of the Pearson correlation coefficient, $|C|$, between the fluctuations of $p_{\\text{top}}(t)$ and $L_p(t)$ over the final half of the simulation.\n- **Test Cases**:\n  - Case A: $R = 0.0625$, $U = 1.0$, $Re = \\frac{U(2R)}{\\nu} = 20$, $N_{\\text{steps}} = 600$.\n  - Case B: $R = 0.0625$, $U = 1.0$, $Re = 100$, $N_{\\text{steps}} = 600$.\n  - Case C: $R = 0.05$, $U = 1.0$, $Re = 120$, $N_{\\text{steps}} = 600$.\n\n### Step 2: Validate Using Extracted Givens\n1.  **Scientifically Grounded**: The problem is a canonical benchmark in fluid dynamics—flow past a cylinder. The governing equations are the fundamental Navier-Stokes equations. The setup is physically and mathematically sound. **(Valid)**\n2.  **Well-Posed**: The problem provides a complete set of physical and numerical parameters (domain, boundary conditions, initial conditions, grid, time step). The choice of numerical scheme is left to the implementer, which is standard for a problem specified \"from first principles\", as it tests the solver's knowledge of appropriate methods. The stability of the chosen time step and grid can be verified. The CFL condition $U \\Delta t / \\Delta x \\approx 1.0 \\cdot 0.002 / (1/96) \\approx 0.19$, which is well within the stable range. The diffusion stability condition $\\nu \\Delta t / \\Delta x^2$ is also satisfied for all cases. **(Valid)**\n3.  **Objective**: The problem is stated with precise, unambiguous mathematical and physical definitions. All quantities are objective and measurable. **(Valid)**\n4.  **Incomplete or Contradictory Setup**: The parameters are self-consistent. The viscosity $\\nu$ is uniquely determined by the given $Re$, $U$, and $R$. There are no contradictions. **(Valid)**\n5.  **Unrealistic or Infeasible**: The physical regimes ($Re=20, 100, 120$) are well-documented and computationally tractable. The setup is a standard, realistic numerical experiment. **(Valid)**\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A solution will be constructed based on established numerical methods.\n\n### Principle-Based Design of the Solution\n\nThe problem will be solved by numerically integrating the incompressible Navier-Stokes equations from first principles.\n\n**1. Numerical Method: Fractional-Step Projection Method**\nThis method decouples the velocity and pressure calculations. Each time step is split into two stages:\na. **Prediction**: An intermediate velocity field, $\\boldsymbol{u}^*$, is computed by solving the momentum equation without the pressure gradient term. We will use a second-order Adams-Bashforth scheme for the explicit advection and diffusion terms.\n$$\n\\frac{\\boldsymbol{u}^* - \\boldsymbol{u}^n}{\\Delta t} = \\frac{3}{2}\\boldsymbol{A}^n - \\frac{1}{2}\\boldsymbol{A}^{n-1} + \\boldsymbol{f}^n\n$$\nwhere $\\boldsymbol{A} = -(\\boldsymbol{u}\\cdot\\nabla)\\boldsymbol{u} + \\nu \\nabla^2 \\boldsymbol{u}$ represents the advection and diffusion terms. For the first time step, a first-order Forward Euler scheme is used.\n\nb. **Projection**: The intermediate velocity $\\boldsymbol{u}^*$ does not in general satisfy the incompressibility constraint $\\nabla \\cdot \\boldsymbol{u} = 0$. It is projected onto the space of divergence-free fields. This is achieved by solving a Pressure Poisson Equation (PPE) for the pressure $p^{n+1}$:\n$$\n\\nabla^2 p^{n+1} = \\frac{\\nabla \\cdot \\boldsymbol{u}^*}{\\Delta t}\n$$\nThe velocity is then corrected using this pressure:\n$$\n\\boldsymbol{u}^{n+1} = \\boldsymbol{u}^* - \\Delta t \\nabla p^{n+1}\n$$\n\n**2. Spatial Discretization: MAC Grid**\nA staggered Marker-and-Cell (MAC) grid is employed to avoid the pressure-velocity decoupling issues common with collocated grids.\n- Pressure $p$ is located at cell centers $(i+1/2)\\Delta x, (j+1/2)\\Delta y$.\n- Streamwise velocity $u$ is at vertical cell faces $(i+1)\\Delta x, (j+1/2)\\Delta y$.\n- Transverse velocity $v$ is at horizontal cell faces $(i+1/2)\\Delta x, (j+1)\\Delta y$.\nAll spatial derivatives (advection, diffusion, gradient, divergence) are approximated using second-order centered finite differences, respecting the staggered arrangement.\n\n**3. Poisson Solver: Fast Fourier Transform (FFT)**\nGiven the doubly periodic domain, the PPE is most efficiently solved in Fourier space. The equation $\\nabla^2 p = S$ becomes $\\hat{L}(\\boldsymbol{k})\\hat{p}(\\boldsymbol{k}) = \\hat{S}(\\boldsymbol{k})$ after a 2D FFT, where $\\hat{L}(\\boldsymbol{k})$ is the discrete Fourier symbol of the Laplacian operator. $\\hat{p}$ is found by division, and $p$ by an inverse FFT. The mean pressure mode ($\\boldsymbol{k}=0$) is singular and is set to zero, enforcing a zero mean pressure for the domain.\n\n**4. Immersed Boundary: Brinkman Penalization**\nThe stationary circular obstacle with a no-slip condition is handled using a simple and robust Brinkman penalization method.\n- Grid points for $u$ and $v$ that lie inside the cylinder radius $R$ are identified and stored in a boolean mask.\n- At each step, after computing the velocity fields (both intermediate and final), the velocity values at these internal grid points are forced to zero. This effectively treats the obstacle as a region of zero permeability.\n\n**5. Mean Flow Control**\nThe spatially uniform forcing term $\\boldsymbol{f} = (f_x, 0)$ is updated at each time step using a proportional controller to drive the mean fluid velocity $\\langle u \\rangle$ towards the target $U$:\n$$\nf_x = K_p(U - \\langle u \\rangle_{\\text{fluid}})\n$$\nwhere $\\langle u \\rangle_{\\text{fluid}}$ is the average of $u$ over the grid points in the fluid region (outside the cylinder mask) and $K_p$ is a gain constant (e.g., $K_p=0.5$).\n\n**6. Data Calculation and Post-processing**\n-  After computing the pressure field $p$ at each relevant time step, the pressure on the cylinder surface is found by bilinearly interpolating from the four surrounding cell-centered pressure grid points.\n- The pressure lift $L_p(t)$ is computed by numerically integrating the interpolated surface pressure according to its definition. $p_{\\text{top}}(t)$ is the interpolated pressure at $\\theta=\\pi/2$.\n- These time series are collected for the final half of the simulation.\n- Finally, the Pearson correlation coefficient between the fluctuations of $L_p$ and $p_{\\text{top}}$ is calculated as specified.",
            "answer": "```python\nimport numpy as np\nfrom scipy import fft\n\ndef solve():\n    \"\"\"\n    Solves for the correlation between pressure lift and top pressure\n    for flow past a cylinder in a doubly periodic domain.\n    \"\"\"\n\n    def get_advection_terms(u, v, dx, dy):\n        \"\"\"Calculates advection terms using centered differences on a MAC grid.\"\"\"\n        # Interpolate v to u-locations: (i+1, j+0.5)\n        v_at_u = 0.25 * (v + np.roll(v, -1, axis=1) + \n                         np.roll(v, 1, axis=0) + np.roll(np.roll(v, 1, axis=0), -1, axis=1))\n\n        # Derivatives of u, centered at u-locations\n        dudx = (np.roll(u, -1, axis=1) - np.roll(u, 1, axis=1)) / (2 * dx)\n        dudy = (np.roll(u, -1, axis=0) - np.roll(u, 1, axis=0)) / (2 * dy)\n        adv_u = u * dudx + v_at_u * dudy\n\n        # Interpolate u to v-locations: (i+0.5, j+1)\n        u_at_v = 0.25 * (u + np.roll(u, 1, axis=1) + \n                         np.roll(u, -1, axis=0) + np.roll(np.roll(u, -1, axis=0), 1, axis=1))\n\n        # Derivatives of v, centered at v-locations\n        dvdx = (np.roll(v, -1, axis=1) - np.roll(v, 1, axis=1)) / (2 * dx)\n        dvdy = (np.roll(v, -1, axis=0) - np.roll(v, 1, axis=0)) / (2 * dy)\n        adv_v = u_at_v * dvdx + v * dvdy\n\n        return -adv_u, -adv_v\n\n    def get_diffusion_terms(u, v, nu, dx, dy):\n        \"\"\"Calculates diffusion terms using centered differences.\"\"\"\n        lap_u = ((np.roll(u, -1, axis=1) - 2 * u + np.roll(u, 1, axis=1)) / dx**2 +\n                 (np.roll(u, -1, axis=0) - 2 * u + np.roll(u, 1, axis=0)) / dy**2)\n        lap_v = ((np.roll(v, -1, axis=1) - 2 * v + np.roll(v, 1, axis=1)) / dx**2 +\n                 (np.roll(v, -1, axis=0) - 2 * v + np.roll(v, 1, axis=0)) / dy**2)\n        return nu * lap_u, nu * lap_v\n\n    def solve_pressure_poisson_fft(rhs, kx_sq, ky_sq):\n        \"\"\"Solves the Poisson equation using FFT.\"\"\"\n        lap_f = kx_sq + ky_sq\n        rhs_hat = fft.fft2(rhs)\n        p_hat = np.zeros_like(rhs_hat)\n        non_zero_k = lap_f != 0\n        p_hat[non_zero_k] = rhs_hat[non_zero_k] / lap_f[non_zero_k]\n        p_hat[0, 0] = 0\n        return fft.ifft2(p_hat).real\n\n    def get_cylinder_masks(Nx, Ny, dx, dy, xc, yc, R):\n        \"\"\"Creates masks for points inside the cylinder on the MAC grid.\"\"\"\n        # p-grid coordinates (cell centers)\n        px_coords = (np.arange(Nx) + 0.5) * dx\n        py_coords = (np.arange(Ny) + 0.5) * dy\n        pxx, pyy = np.meshgrid(px_coords, py_coords)\n        mask_p = (pxx - xc)**2 + (pyy - yc)**2 < R**2\n        \n        # u-grid coordinates (vertical faces)\n        ux_coords = (np.arange(Nx) + 1.0) * dx\n        uy_coords = (np.arange(Ny) + 0.5) * dy\n        uxx, uyy = np.meshgrid(ux_coords, uy_coords)\n        mask_u = (uxx - xc)**2 + (uyy - yc)**2 < R**2\n        \n        # v-grid coordinates (horizontal faces)\n        vx_coords = (np.arange(Nx) + 0.5) * dx\n        vy_coords = (np.arange(Ny) + 1.0) * dy\n        vxx, vyy = np.meshgrid(vx_coords, vy_coords)\n        mask_v = (vxx - xc)**2 + (vyy - yc)**2 < R**2\n        \n        return mask_p, mask_u, mask_v\n\n    def interpolate_pressure(p, theta_pts, xc, yc, R, dx, dy):\n        \"\"\"Interpolates pressure onto the cylinder surface.\"\"\"\n        Ny, Nx = p.shape\n        x_surf = xc + R * np.cos(theta_pts)\n        y_surf = yc + R * np.sin(theta_pts)\n        \n        ix = np.floor(x_surf / dx - 0.5)\n        iy = np.floor(y_surf / dy - 0.5)\n        \n        ix = ix.astype(int)\n        iy = iy.astype(int)\n\n        # Periodic wrapping for indices\n        ixp1 = (ix + 1) % Nx\n        iyp1 = (iy + 1) % Ny\n\n        # Fractional coordinates\n        xf = (x_surf / dx) - (ix + 0.5)\n        yf = (y_surf / dy) - (iy + 0.5)\n        \n        # Bilinear interpolation\n        p_surf = (p[iy, ix] * (1 - xf) * (1 - yf) +\n                  p[iy, ixp1] * xf * (1 - yf) +\n                  p[iyp1, ix] * (1 - xf) * yf +\n                  p[iyp1, ixp1] * xf * yf)\n        return p_surf\n\n    def run_simulation(case_params):\n        R, U, Re, N_steps = case_params\n        \n        Lx, Ly = 1.0, 0.5\n        Nx, Ny = 96, 48\n        dx, dy = Lx / Nx, Ly / Ny\n        dt = 0.002\n        nu = U * (2 * R) / Re\n        xc, yc = 0.25, 0.25\n\n        u = np.full((Ny, Nx), U)\n        v = np.zeros((Ny, Nx))\n        p = np.zeros((Ny, Nx))\n\n        kx_v = 2 * np.pi * fft.fftfreq(Nx, d=dx)\n        ky_v = 2 * np.pi * fft.fftfreq(Ny, d=dy)\n        kx, ky = np.meshgrid(kx_v, ky_v)\n        kx_sq = 2 * (np.cos(kx * dx) - 1) / dx**2\n        ky_sq = 2 * (np.cos(ky * dy) - 1) / dy**2\n\n        _, mask_u, mask_v = get_cylinder_masks(Nx, Ny, dx, dy, xc, yc, R)\n        u[mask_u] = 0\n        v[mask_v] = 0\n\n        A_u_prev, A_v_prev = None, None\n        \n        p_top_series, Lp_series = [], []\n        start_sampling = N_steps // 2\n        \n        M_pts = 100\n        theta_pts = np.linspace(0, 2 * np.pi, M_pts, endpoint=False)\n        theta_top_idx = np.argmin(np.abs(theta_pts - np.pi / 2))\n\n        for n in range(N_steps):\n            adv_u, adv_v = get_advection_terms(u, v, dx, dy)\n            diff_u, diff_v = get_diffusion_terms(u, v, nu, dx, dy)\n            A_u, A_v = adv_u + diff_u, adv_v + diff_v\n\n            mean_u = np.mean(u[~mask_u]) if np.any(~mask_u) else U\n            fx = 0.5 * (U - mean_u)\n\n            if n == 0:\n                u_star = u + dt * (A_u + fx)\n                v_star = v + dt * A_v\n            else:\n                u_star = u + dt * (1.5 * A_u - 0.5 * A_u_prev + fx)\n                v_star = v + dt * (1.5 * A_v - 0.5 * A_v_prev)\n            A_u_prev, A_v_prev = A_u, A_v\n            \n            u_star[mask_u], v_star[mask_v] = 0, 0\n            \n            div_star = ((u_star - np.roll(u_star, 1, axis=1)) / dx +\n                        (v_star - np.roll(v_star, 1, axis=0)) / dy)\n            \n            p = solve_pressure_poisson_fft(div_star / dt, kx_sq, ky_sq)\n            \n            grad_p_x = (np.roll(p, -1, axis=1) - p) / dx\n            grad_p_y = (np.roll(p, -1, axis=0) - p) / dy\n            \n            u = u_star - dt * grad_p_x\n            v = v_star - dt * grad_p_y\n            u[mask_u], v[mask_v] = 0, 0\n\n            if n >= start_sampling:\n                p_surf = interpolate_pressure(p, theta_pts, xc, yc, R, dx, dy)\n                p_top_series.append(p_surf[theta_top_idx])\n                Lp = -np.sum(p_surf * np.sin(theta_pts) * R * (2 * np.pi / M_pts))\n                Lp_series.append(Lp)\n                \n        p_top_np = np.array(p_top_series)\n        Lp_np = np.array(Lp_series)\n        \n        var_p_top = np.var(p_top_np)\n        var_Lp = np.var(Lp_np)\n\n        if var_p_top < 1e-24 or var_Lp < 1e-24:\n            return 0.0\n            \n        corr_matrix = np.corrcoef(p_top_np, Lp_np)\n        return np.abs(corr_matrix[0, 1])\n\n    test_cases = [\n        (0.0625, 1.0, 20, 600),   # Case A\n        (0.0625, 1.0, 100, 600),  # Case B\n        (0.05,   1.0, 120, 600),  # Case C\n    ]\n\n    results = [run_simulation(case) for case in test_cases]\n    \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}