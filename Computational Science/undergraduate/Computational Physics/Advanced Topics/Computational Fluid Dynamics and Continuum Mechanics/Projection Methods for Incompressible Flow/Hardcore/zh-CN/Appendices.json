{
    "hands_on_practices": [
        {
            "introduction": "第一个练习将从能量的角度深入探讨投影方法的基本原理。我们将证明，投影步骤通过移除速度场中的非螺线（irrotational）分量所关联的动能，其本质上是耗能的。通过实现一个使用精心选择的初始条件的数值实验，你将直接观察并量化这种能量变化，从而巩固对作为投影方法核心的亥姆霍兹-霍奇分解（Helmholtz-Hodge decomposition）的理解。",
            "id": "2430752",
            "problem": "考虑一个二维周期性域上的不可压缩流体。设该域为正方形 $[0,2\\pi]\\times[0,2\\pi]$，且在两个方向上都具有周期性边界条件。令 $\\vec{u}(\\vec{x})$ 表示一个足够光滑的速度场，并定义动能为\n$$\nE[\\vec{u}] \\;=\\; \\int_{[0,2\\pi]^2} \\frac{1}{2}\\, \\lvert \\vec{u}(\\vec{x}) \\rvert^2 \\,\\mathrm{d}\\vec{x}.\n$$\n在不可压缩流动的投影框架中，给定一个中间速度场 $\\vec{u}^{\\star}$，连续投影步骤通过求解一个标量场 $p$ 来产生一个无散度速度场 $\\vec{u}^{\\mathrm{proj}}$，使得\n$$\n\\nabla^2 p \\;=\\; \\nabla\\cdot \\vec{u}^{\\star}, \\quad \\text{和} \\quad \\vec{u}^{\\mathrm{proj}} \\;=\\; \\vec{u}^{\\star} - \\nabla p,\n$$\n其中 $p$ 满足周期性边界条件和零均值归一化以确保唯一性。所有三角函数中的角度均以弧度为单位。\n\n任务：\n1. 从第一性原理出发，证明连续投影步骤在以下意义上是能量耗散的：\n$$\nE[\\vec{u}^{\\mathrm{proj}}] \\;\\le\\; E[\\vec{u}^{\\star}],\n$$\n且等号成立当且仅当 $\\nabla\\cdot \\vec{u}^{\\star} = 0$。\n\n2. 实现一个程序，对于下面列出的每个指定测试用例，在 $[0,2\\pi]\\times[0,2\\pi]$ 上的 $N\\times N$ 均匀网格上构建速度场 $\\vec{u}^{\\star}$，应用一个数值上一致的离散投影步骤以获得一个离散无散度速度场 $\\vec{u}^{\\mathrm{proj}}$，并计算动能的相对变化\n$$\n\\delta \\;=\\; \\frac{E_h[\\vec{u}^{\\mathrm{proj}}] - E_h[\\vec{u}^{\\star}]}{E_h[\\vec{u}^{\\star}]},\n$$\n其中 $E_h[\\cdot]$ 是在均匀网格上对 $E[\\cdot]$ 的标准矩形法则离散近似：\n$$\nE_h[\\vec{u}] \\;=\\; \\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} \\frac{1}{2}\\left( u_x(x_i,y_j)^2 + u_y(x_i,y_j)^2 \\right)\\,\\Delta x\\,\\Delta y,\n$$\n其中 $\\Delta x = 2\\pi/N$ 和 $\\Delta y = 2\\pi/N$，且 $(x_i,y_j) = (i\\,\\Delta x, j\\,\\Delta y)$。\n\n测试套件（每个测试用例指定了 $N$ 和 $\\vec{u}^{\\star}$ 的解析形式；所有场都在 $[0,2\\pi]\\times[0,2\\pi]$ 上定义并具有周期性）：\n\n- 测试用例 A（无散度输入）：\n  - 网格：$N = 64$。\n  - 流函数：$\\psi(x,y) = \\sin(x)\\cos(y)$。\n  - 速度：$\\vec{u}^{\\star}(x,y) = \\left(-\\partial_y \\psi(x,y), \\;\\partial_x \\psi(x,y)\\right)$。\n\n- 测试用例 B（纯无旋输入）：\n  - 网格：$N = 32$。\n  - 势函数：$\\phi(x,y) = \\sin(3x) + \\cos(2y)$。\n  - 速度：$\\vec{u}^{\\star}(x,y) = \\nabla \\phi(x,y)$。\n\n- 测试用例 C（混合输入：无散度加无旋）：\n  - 网格：$N = 48$。\n  - 流函数：$\\psi(x,y) = \\sin(x)\\cos(y)$。\n  - 势函数：$\\phi(x,y) = \\sin(3x) + \\cos(2y)$。\n  - 混合系数：$\\alpha = 0.5$。\n  - 速度：$\\vec{u}^{\\star}(x,y) = \\left(-\\partial_y \\psi(x,y), \\;\\partial_x \\psi(x,y)\\right) + \\alpha\\,\\nabla \\phi(x,y)$。\n\n- 测试用例 D（均匀流，无散度）：\n  - 网格：$N = 16$。\n  - 速度：$\\vec{u}^{\\star}(x,y) = (1.0,\\,-0.5)$。\n\n对于每个测试用例，您的程序必须计算如上定义的单个标量 $\\delta$。您的程序应生成单行输出，其中包含结果，格式为一个逗号分隔的十进制数列表，四舍五入到恰好 $10$ 位小数，并用方括号括起来，顺序为 $[\\delta_A,\\delta_B,\\delta_C,\\delta_D]$。例如，一个可接受的输出格式是\n$$\n[\\delta_A,\\delta_B,\\delta_C,\\delta_D]\n$$\n其中每个 $\\delta$ 都四舍五入到恰好 $10$ 位小数。不需要物理单位；所有量均为无量纲。",
            "solution": "该问题被验证为具有科学依据、良态的且客观的。这是计算流体动力学中的一个标准问题。我们着手处理这两项任务。\n\n**任务 1：能量耗散的证明**\n\n我们被要求证明投影步骤是能量耗散的，即 $E[\\vec{u}^{\\mathrm{proj}}] \\le E[\\vec{u}^{\\star}]$，且等号成立当且仅当初始场 $\\vec{u}^{\\star}$ 已经是无散度的，即 $\\nabla\\cdot \\vec{u}^{\\star} = 0$。\n\n投影后速度场 $\\vec{u}^{\\mathrm{proj}}$ 的动能定义为：\n$$\nE[\\vec{u}^{\\mathrm{proj}}] = \\int_{\\Omega} \\frac{1}{2} |\\vec{u}^{\\mathrm{proj}}|^2 \\, \\mathrm{d}\\vec{x}\n$$\n其中 $\\Omega = [0, 2\\pi] \\times [0, 2\\pi]$ 是周期性域。\n\n根据定义，投影后的速度由 $\\vec{u}^{\\mathrm{proj}} = \\vec{u}^{\\star} - \\nabla p$ 给出。将其代入能量表达式得到：\n$$\nE[\\vec{u}^{\\mathrm{proj}}] = \\int_{\\Omega} \\frac{1}{2} |\\vec{u}^{\\star} - \\nabla p|^2 \\, \\mathrm{d}\\vec{x}\n$$\n我们展开被积函数中的平方范数：\n$$\n|\\vec{u}^{\\star} - \\nabla p|^2 = (\\vec{u}^{\\star} - \\nabla p) \\cdot (\\vec{u}^{\\star} - \\nabla p) = |\\vec{u}^{\\star}|^2 - 2 \\vec{u}^{\\star} \\cdot \\nabla p + |\\nabla p|^2\n$$\n将其代回到能量积分中：\n$$\nE[\\vec{u}^{\\mathrm{proj}}] = \\int_{\\Omega} \\frac{1}{2} |\\vec{u}^{\\star}|^2 \\, \\mathrm{d}\\vec{x} - \\int_{\\Omega} \\vec{u}^{\\star} \\cdot \\nabla p \\, \\mathrm{d}\\vec{x} + \\int_{\\Omega} \\frac{1}{2} |\\nabla p|^2 \\, \\mathrm{d}\\vec{x}\n$$\n第一项是中间场的能量 $E[\\vec{u}^{\\star}]$。所以我们有：\n$$\nE[\\vec{u}^{\\mathrm{proj}}] = E[\\vec{u}^{\\star}] - \\int_{\\Omega} \\vec{u}^{\\star} \\cdot \\nabla p \\, \\mathrm{d}\\vec{x} + \\frac{1}{2}\\int_{\\Omega} |\\nabla p|^2 \\, \\mathrm{d}\\vec{x}\n$$\n让我们分析交叉项 $\\int_{\\Omega} \\vec{u}^{\\star} \\cdot \\nabla p \\, \\mathrm{d}\\vec{x}$。我们使用分部积分法，在多维情况下，这依赖于散度定理。我们使用散度的乘积法则：$\\nabla \\cdot (p \\vec{u}^{\\star}) = (\\nabla p) \\cdot \\vec{u}^{\\star} + p (\\nabla \\cdot \\vec{u}^{\\star})$。整理后得到：\n$$\n\\vec{u}^{\\star} \\cdot \\nabla p = \\nabla \\cdot (p \\vec{u}^{\\star}) - p (\\nabla \\cdot \\vec{u}^{\\star})\n$$\n在域 $\\Omega$ 上积分：\n$$\n\\int_{\\Omega} \\vec{u}^{\\star} \\cdot \\nabla p \\, \\mathrm{d}\\vec{x} = \\int_{\\Omega} \\nabla \\cdot (p \\vec{u}^{\\star}) \\, \\mathrm{d}\\vec{x} - \\int_{\\Omega} p (\\nabla \\cdot \\vec{u}^{\\star}) \\, \\mathrm{d}\\vec{x}\n$$\n根据散度定理，散度在一个闭合域（或周期性域，其边界项会抵消）上的积分为零。因此，$\\int_{\\Omega} \\nabla \\cdot (p \\vec{u}^{\\star}) \\, \\mathrm{d}\\vec{x} = 0$。\n方程简化为：\n$$\n\\int_{\\Omega} \\vec{u}^{\\star} \\cdot \\nabla p \\, \\mathrm{d}\\vec{x} = - \\int_{\\Omega} p (\\nabla \\cdot \\vec{u}^{\\star}) \\, \\mathrm{d}\\vec{x}\n$$\n根据问题陈述，压力场 $p$ 是通过求解泊松方程 $\\nabla^2 p = \\nabla \\cdot \\vec{u}^{\\star}$ 得到的。代入此式：\n$$\n\\int_{\\Omega} \\vec{u}^{\\star} \\cdot \\nabla p \\, \\mathrm{d}\\vec{x} = - \\int_{\\Omega} p (\\nabla^2 p) \\, \\mathrm{d}\\vec{x}\n$$\n我们对右侧再次应用分部积分法。使用恒等式 $\\nabla\\cdot(p\\nabla p) = \\nabla p \\cdot \\nabla p + p \\nabla^2 p = |\\nabla p|^2 + p\\nabla^2 p$：\n$$\n\\int_{\\Omega} p (\\nabla^2 p) \\, \\mathrm{d}\\vec{x} = \\int_{\\Omega} \\nabla\\cdot(p\\nabla p) \\, \\mathrm{d}\\vec{x} - \\int_{\\Omega} |\\nabla p|^2 \\, \\mathrm{d}\\vec{x}\n$$\n同样，散度项 $\\nabla\\cdot(p\\nabla p)$ 在周期性域上的积分为零。剩下的是：\n$$\n\\int_{\\Omega} p (\\nabla^2 p) \\, \\mathrm{d}\\vec{x} = - \\int_{\\Omega} |\\nabla p|^2 \\, \\mathrm{d}\\vec{x}\n$$\n将此结果代回到我们的交叉项表达式中：\n$$\n\\int_{\\Omega} \\vec{u}^{\\star} \\cdot \\nabla p \\, \\mathrm{d}\\vec{x} = - \\left( - \\int_{\\Omega} |\\nabla p|^2 \\, \\mathrm{d}\\vec{x} \\right) = \\int_{\\Omega} |\\nabla p|^2 \\, \\mathrm{d}\\vec{x}\n$$\n现在我们回到 $E[\\vec{u}^{\\mathrm{proj}}]$ 的表达式：\n$$\nE[\\vec{u}^{\\mathrm{proj}}] = E[\\vec{u}^{\\star}] - \\int_{\\Omega} |\\nabla p|^2 \\, \\mathrm{d}\\vec{x} + \\frac{1}{2}\\int_{\\Omega} |\\nabla p|^2 \\, \\mathrm{d}\\vec{x}\n$$\n$$\nE[\\vec{u}^{\\mathrm{proj}}] = E[\\vec{u}^{\\star}] - \\frac{1}{2}\\int_{\\Omega} |\\nabla p|^2 \\, \\mathrm{d}\\vec{x}\n$$\n被积函数 $|\\nabla p|^2$ 是一个实值量的平方，因此是非负的。所以，积分 $\\int_{\\Omega} |\\nabla p|^2 \\, \\mathrm{d}\\vec{x} \\ge 0$。这直接意味着：\n$$\nE[\\vec{u}^{\\mathrm{proj}}] \\le E[\\vec{u}^{\\star}]\n$$\n这完成了证明的第一部分。\n\n对于等号成立的条件，$E[\\vec{u}^{\\mathrm{proj}}] = E[\\vec{u}^{\\star}]$ 成立当且仅当相减的项为零：\n$$\n\\frac{1}{2}\\int_{\\Omega} |\\nabla p|^2 \\, \\mathrm{d}\\vec{x} = 0\n$$\n由于被积函数 $|\\nabla p|^2$ 是非负的，且函数 $p$ 假定为足够光滑，该等式只能在被积函数处处为零的情况下成立。也就是说，对于所有 $\\vec{x} \\in \\Omega$ 都有 $|\\nabla p(\\vec{x})|^2 = 0$，这意味着 $\\nabla p(\\vec{x}) = \\vec{0}$。\n这意味着标量场 $p$ 在整个域上必须是一个常数。\n问题陈述中指出 $p$ 须满足零均值归一化条件，$\\int_{\\Omega} p \\, \\mathrm{d}\\vec{x} = 0$。如果 $p$ 是一个常数 $C$，那么 $\\int_{\\Omega} C \\, \\mathrm{d}\\vec{x} = C \\cdot \\text{Area}(\\Omega) = 0$，这意味着 $C=0$。所以，对于所有 $\\vec{x}$ 都有 $p(\\vec{x}) = 0$。\n\n如果 $p(\\vec{x})=0$，那么泊松方程 $\\nabla^2 p = \\nabla \\cdot \\vec{u}^{\\star}$ 变为 $\\nabla^2 (0) = 0 = \\nabla \\cdot \\vec{u}^{\\star}$。因此，如果 $\\nabla \\cdot \\vec{u}^{\\star} = 0$，则等号成立。\n\n反之，如果 $\\nabla \\cdot \\vec{u}^{\\star} = 0$，我们必须求解具有周期性边界条件和零均值归一化的齐次泊松方程 $\\nabla^2 p = 0$。该问题的唯一解是 $p(\\vec{x}) = 0$。这意味着 $\\nabla p = \\vec{0}$，因此能量减项 $\\frac{1}{2}\\int_{\\Omega} |\\nabla p|^2 \\, \\mathrm{d}\\vec{x}$ 为零。这导致 $E[\\vec{u}^{\\mathrm{proj}}] = E[\\vec{u}^{\\star}]$。\n\n因此，我们证明了 $E[\\vec{u}^{\\mathrm{proj}}] \\le E[\\vec{u}^{\\star}]$，且等号成立当且仅当 $\\nabla \\cdot \\vec{u}^{\\star} = 0$。这表明投影算子将向量场正交投影到无散度场子空间上，通过移除纯梯度分量来最小化动能。\n\n**任务 2：数值实现**\n\n数值实现使用谱方法应用投影算子的离散版本，该方法对于周期性问题具有很高的精度。算法步骤如下：\n\n1.  为每个测试用例构建网格和初始速度场 $\\vec{u}^{\\star}$。\n2.  计算初始离散动能 $E_h[\\vec{u}^{\\star}]$。\n3.  计算 $\\vec{u}^{\\star}$ 各分量的二维快速傅里叶变换 (FFT) 以得到 $\\hat{u}^{\\star}_x$ 和 $\\hat{u}^{\\star}_y$。\n4.  计算散度的傅里叶变换，$\\widehat{\\nabla\\cdot \\vec{u}^{\\star}} = i k_x \\hat{u}^{\\star}_x + i k_y \\hat{u}^{\\star}_y$，其中 $k_x$ 和 $k_y$ 是对应于离散网格的整数波数。\n5.  在傅里叶空间中求解泊松方程 $\\nabla^2 p = \\nabla\\cdot \\vec{u}^{\\star}$。这变为 $-(k_x^2 + k_y^2)\\hat{p} = \\widehat{\\nabla\\cdot \\vec{u}^{\\star}}$。压力的傅里叶系数解为 $\\hat{p} = \\frac{i k_x \\hat{u}^{\\star}_x + i k_y \\hat{u}^{\\star}_y}{k_x^2 + k_y^2}$。通过设置 $\\hat{p}(0,0)=0$ 来处理 $k_x=k_y=0$ 处的奇点，这强制了对 $p$ 的零均值条件。\n6.  计算压力梯度的傅里叶变换，$\\widehat{\\nabla p} = (i k_x \\hat{p}, i k_y \\hat{p})$。\n7.  应用二维逆傅里叶变换 (FFT) 以在物理空间中获得压力梯度 $\\nabla p$。\n8.  计算投影后的速度场 $\\vec{u}^{\\mathrm{proj}} = \\vec{u}^{\\star} - \\nabla p$。\n9.  计算最终的离散动能 $E_h[\\vec{u}^{\\mathrm{proj}}]$。\n10. 计算能量的相对变化，$\\delta = (E_h[\\vec{u}^{\\mathrm{proj}}] - E_h[\\vec{u}^{\\star}]) / E_h[\\vec{u}^{\\star}]$。\n\n对所提供的四个测试用例中的每一个都实施此过程。\n- 用例 A 和 D 涉及解析上无散度的场。计算出的 $\\delta$ 应接近于 $0$，任何非零值都是由浮点精度限制造成的。\n- 用例 B 涉及一个纯梯度场。投影应导致速度场为零，$\\delta$ 应非常接近 $-1$。\n- 用例 C 是一个混合场。投影移除了梯度分量，导致一个负的 $\\delta$，其值取决于无散度部分和无旋部分的相对能量。解析预测值为 $\\delta = -13/17 \\approx -0.7647$。数值结果应非常接近此值。\n\n提供的 Python 代码实现了该算法。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the projection problem for four test cases and computes the\n    relative change in kinetic energy.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'id': 'A', 'N': 64, 'type': 'streamfunction'},\n        {'id': 'B', 'N': 32, 'type': 'potential'},\n        {'id': 'C', 'N': 48, 'type': 'mixed'},\n        {'id': 'D', 'N': 16, 'type': 'uniform'}\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        N = case['N']\n        L = 2.0 * np.pi\n        dx = L / N\n        dy = L / N\n        \n        # Create grid\n        x = np.arange(N) * dx\n        xx, yy = np.meshgrid(x, x, indexing='ij')\n\n        u_star_x = np.zeros((N, N))\n        u_star_y = np.zeros((N, N))\n\n        # Construct the intermediate velocity field u_star for each test case\n        if case['type'] == 'streamfunction':\n            # Case A: Divergence-free input\n            # psi(x,y) = sin(x)cos(y)\n            # u = -d_y psi = sin(x)sin(y)\n            # v =  d_x psi = cos(x)cos(y)\n            u_star_x = np.sin(xx) * np.sin(yy)\n            u_star_y = np.cos(xx) * np.cos(yy)\n        elif case['type'] == 'potential':\n            # Case B: Purely irrotational input\n            # phi(x,y) = sin(3x) + cos(2y)\n            # u = d_x phi = 3cos(3x)\n            # v = d_y phi = -2sin(2y)\n            u_star_x = 3.0 * np.cos(3.0 * xx)\n            u_star_y = -2.0 * np.sin(2.0 * yy)\n        elif case['type'] == 'mixed':\n            # Case C: Mixed input\n            alpha = 0.5\n            # Solenoidal part from streamfunction psi(x,y) = sin(x)cos(y)\n            u_psi_x = np.sin(xx) * np.sin(yy)\n            u_psi_y = np.cos(xx) * np.cos(yy)\n            # Irrotational part from potential phi(x,y) = sin(3x) + cos(2y)\n            u_phi_x = 3.0 * np.cos(3.0 * xx)\n            u_phi_y = -2.0 * np.sin(2.0 * yy)\n            u_star_x = u_psi_x + alpha * u_phi_x\n            u_star_y = u_psi_y + alpha * u_phi_y\n        elif case['type'] == 'uniform':\n            # Case D: Uniform flow, divergence-free\n            u_star_x = np.full((N, N), 1.0)\n            u_star_y = np.full((N, N), -0.5)\n\n        # Calculate discrete kinetic energy E_h[u_star]\n        E_star = 0.5 * np.sum(u_star_x**2 + u_star_y**2) * dx * dy\n        \n        if E_star == 0.0:\n            # This case will not be hit by the problem's test suite\n            results.append(0.0)\n            continue\n            \n        # Perform projection using Fourier spectral method\n        \n        # Wavenumbers (integer values)\n        k = np.fft.fftfreq(N) * N\n        kx, ky = np.meshgrid(k, k, indexing='ij')\n\n        # FFT of the velocity field\n        u_star_x_hat = np.fft.fft2(u_star_x)\n        u_star_y_hat = np.fft.fft2(u_star_y)\n        \n        # Divergence in Fourier space\n        div_u_star_hat = 1j * kx * u_star_x_hat + 1j * ky * u_star_y_hat\n        \n        # Solve Poisson equation for pressure p in Fourier space\n        # - (kx^2 + ky^2) * p_hat = div_u_star_hat\n        ksq = kx**2 + ky**2\n        \n        # Inverse of -(k^2) operator, with singularity at k=0 handled\n        # ksq_inv_neg will be -1/ksq for k != 0, and 0 for k = 0\n        ksq_inv_neg = np.zeros_like(ksq)\n        non_zero_k = ksq > 0\n        ksq_inv_neg[non_zero_k] = -1.0 / ksq[non_zero_k]\n        \n        p_hat = div_u_star_hat * ksq_inv_neg\n        \n        # The zero-mean pressure condition corresponds to p_hat[0,0] = 0,\n        # which is automatically satisfied by the above procedure since ksq_inv_neg[0,0] = 0.\n        \n        # Gradient of p in Fourier space\n        grad_p_x_hat = 1j * kx * p_hat\n        grad_p_y_hat = 1j * ky * p_hat\n        \n        # Transform gradient back to physical space.\n        # The result must be real; .real discards negligible imaginary parts from numerical error.\n        grad_p_x = np.fft.ifft2(grad_p_x_hat).real\n        grad_p_y = np.fft.ifft2(grad_p_y_hat).real\n        \n        # Compute the projected velocity field\n        u_proj_x = u_star_x - grad_p_x\n        u_proj_y = u_star_y - grad_p_y\n        \n        # Calculate discrete kinetic energy E_h[u_proj]\n        E_proj = 0.5 * np.sum(u_proj_x**2 + u_proj_y**2) * dx * dy\n        \n        # Calculate relative change in kinetic energy delta\n        delta = (E_proj - E_star) / E_star\n        results.append(delta)\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{r:.10f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在理想连续情况的基础上，本练习将探讨数值实现中的一个关键细节：离散算子的选择。你将研究离散梯度算子 $G$ 和散度算子 $D$ 是否互为伴随（adjoint）如何影响模拟的长期能量行为。这个练习将展示，一个看似合理的离散化方案可能导致虚假的能量产生或耗散，从而凸显了设计兼容的或“仿生”的（mimetic）数值格式对于稳健的长期模拟的重要性。",
            "id": "2430781",
            "problem": "考虑一个二维、周期性的正方形域 $[0,1] \\times [0,1]$，该域被一个具有 $N \\times N$ 个点和网格间距 $h = 1/N$ 的均匀笛卡尔网格离散化。离散速度场在单元中心表示为 $u = (u_x, u_y)$，其中 $u_x$ 和 $u_y$ 是形状为 $N \\times N$ 的数组。离散内积定义为\n$$\n\\langle a, b \\rangle_h = h^2 \\sum_{i=0}^{N-1} \\sum_{j=0}^{N-1} \\left( a_x(i,j) b_x(i,j) + a_y(i,j) b_y(i,j) \\right),\n$$\n离散动能为 $E = \\tfrac{1}{2} \\langle u, u \\rangle_h$。\n\n将从 $u^n$到 $u^{n+1}$ 的时间更新定义为一个压力投影步骤，其形式如下\n$$\nu^{n+1} = u^* - \\Delta t \\, G p^{n+1}, \\quad u^* = u^n,\n$$\n其中离散压力 $p^{n+1}$ 满足泊松方程\n$$\n\\frac{1}{\\Delta t} D u^* = L p^{n+1}, \\quad L = D G.\n$$\n所有运算都在周期性网格上定义。\n\n离散梯度算子 $G$ 和离散散度算子 $D$ 将从以下算子集中选择：\n- 算子集 A（中心-中心）：$G_c p = (\\mathrm{D}_{x}^{c} p, \\mathrm{D}_{y}^{c} p)$ 和 $D_c u = \\mathrm{D}_{x}^{c} u_x + \\mathrm{D}_{y}^{c} u_y$，\n- 算子集 B（中心-向前）：$G_c p = (\\mathrm{D}_{x}^{c} p, \\mathrm{D}_{y}^{c} p)$ 和 $D_f u = \\mathrm{D}_{x}^{f} u_x + \\mathrm{D}_{y}^{f} u_y$，\n\n其中 $\\mathrm{D}_{x}^{c}$ 和 $\\mathrm{D}_{y}^{c}$ 是带周期性环绕的标准中心有限差分算子，\n$$\n\\mathrm{D}_{x}^{c} \\phi(i,j) = \\frac{\\phi(i,j+1) - \\phi(i,j-1)}{2h}, \\quad \\mathrm{D}_{y}^{c} \\phi(i,j) = \\frac{\\phi(i+1,j) - \\phi(i-1,j)}{2h},\n$$\n而 $\\mathrm{D}_{x}^{f}$ 和 $\\mathrm{D}_{y}^{f}$ 是带周期性环绕的标准向前有限差分算子，\n$$\n\\mathrm{D}_{x}^{f} \\phi(i,j) = \\frac{\\phi(i,j+1) - \\phi(i,j)}{h}, \\quad \\mathrm{D}_{y}^{f} \\phi(i,j) = \\frac{\\phi(i+1,j) - \\phi(i,j)}{h}.\n$$\n\n使用离散流函数 $\\psi(i,j) = \\sin(2\\pi x_j)\\sin(2\\pi y_i)$（其中 $x_j = j h$ 且 $y_i = i h$）来初始化速度场。定义\n$$\nu_x^0 = \\mathrm{D}_{y}^{c} \\psi, \\quad u_y^0 = -\\mathrm{D}_{x}^{c} \\psi.\n$$\n\n对于下面的每个测试用例，从 $u^0$ 开始，使用指定的算子集定义 $D$（其中 $G=G_c$ 如上所给），并令 $L = D G$，模拟系统指定的步数。对所有离散算子使用周期性边界条件。计算最后一个时间步后的离散动能漂移为\n$$\n\\Delta E = E^{\\text{final}} - E^{\\text{initial}},\n$$\n这是一个无量纲实数。\n\n测试套件：\n- 用例 1：$N = 32$，$\\Delta t = 0.1$，步数 $= 1000$，算子集 A。\n- 用例 2：$N = 32$，$\\Delta t = 0.1$，步数 $= 1000$，算子集 B。\n- 用例 3：$N = 8$，$\\Delta t = 0.2$，步数 $= 400$，算子集 B。\n- 用例 4：$N = 32$，$\\Delta t = 0.01$，步数 $= 1000$，算子集 B。\n\n您的任务是实现一个程序，对每个测试用例执行上述模拟，计算每个用例对应的能量漂移 $\\Delta E$（一个浮点数），并汇总结果。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个浮点数以科学记数法书写，保留 $10$ 位有效数字，并按用例 1 到 4 的顺序排列（例如，$[\\text{r1},\\text{r2},\\text{r3},\\text{r4}]$）。",
            "solution": "该问题提出了一个计算物理学中有效的数值实验，特别关注不可压缩流模拟中投影法的性质。它具有科学依据，是适定的，并且所有变量和过程都有足够精确的定义。我现在将进行详细的解答。\n\n问题的核心是在周期性域上模拟一个二维速度场 $u$ 的时间演化，该演化由一个简化的投影法控制。从时间步 $n$ 到 $n+1$ 的更新规则，是通过将一个中间速度场 $u^*$ 投影到离散无散度场空间上得到的。在这个问题中，中间步骤是平凡的，$u^* = u^n$。该投影表述为：\n$$\nu^{n+1} = u^n - \\Delta t \\, G p^{n+1}\n$$\n其中 $p^{n+1}$ 是新时间步的离散压力场， $G$ 是离散梯度算子。压力是通过强制要求最终的速度场 $u^{n+1}$ 是无散度的来确定的，即 $D u^{n+1} = 0$，其中 $D$ 是离散散度算子。将散度算子应用于更新方程可得：\n$$\nD u^{n+1} = D u^n - \\Delta t \\, D G p^{n+1} = 0\n$$\n这导出了压力泊松方程（PPE）：\n$$\nL p^{n+1} = \\frac{1}{\\Delta t} D u^n\n$$\n其中 $L = DG$ 是离散拉普拉斯算子。\n\n模拟在周期性网格上进行，这使得离散傅里叶变换（DFT）的使用非常高效。卷积定理指出，物理空间中的微分（或任何有限差分运算）对应于傅里叶空间中与一个“符号”的乘法。在傅里叶空间中求解 PPE 变成了一个简单的代数除法。\n\n令 $\\hat{\\phi}$ 表示场 $\\phi$ 的二维 DFT。PPE 变换为：\n$$\n\\hat{L} \\hat{p}^{n+1} = \\frac{1}{\\Delta t} \\widehat{D u^n}\n$$\n其中 $\\hat{L}$ 和 $\\widehat{D u^n}$ 分别是拉普拉斯算子和 $u^n$ 散度的傅里叶空间表示。傅里叶空间中的压力场则通过以下方式求得：\n$$\n\\hat{p}^{n+1} = \\frac{1}{\\hat{L}} \\left( \\frac{1}{\\Delta t} \\widehat{D u^n} \\right)\n$$\n对于周期性边界条件，离散拉普拉斯算子 $\\hat{L}$ 对零频率模式（$k_x = 0, k_y = 0$）有一个零特征值，对应于常数压力模式。然而，周期域上任何场的散度之和为零，这意味着其零频率分量也为零。这导致了一个 $0/0$ 的不确定性，通过将压力的零频率分量 $\\hat{p}(0,0)$ 设为零来解决。这是允许的，因为在速度更新中只出现压力的梯度 $G p$，而常数的梯度为零。\n\n首先推导指定离散算子的傅里叶符号。令 $k_x$ 和 $k_y$ 为对应于 $x$ 和 $y$ 方向的波数。域的大小为 $1$，因此网格间距为 $h=1/N$。标准 FFT 例程提供的波数通常以每个采样区间的周期数为单位。当采样间隔为 $h$ 时，每单位长度的周期数波数为 $k_x^{\\text{cyc}}, k_y^{\\text{cyc}} = \\texttt{fftfreq}(N, h)$。\n\n梯度算子 $G_c = (\\mathrm{D}_{y}^{c}, \\mathrm{D}_{x}^{c})$ 的符号为：\n$$\n\\hat{g}_x = \\frac{i \\sin(2 \\pi k_x h)}{h}, \\quad \\hat{g}_y = \\frac{i \\sin(2 \\pi k_y h)}{h}\n$$\n傅里叶空间中的速度更新步骤为：\n$$\n\\hat{u}_x^{n+1} = \\hat{u}_x^n - \\Delta t \\, \\hat{g}_x \\hat{p}^{n+1}\n$$\n$$\n\\hat{u}_y^{n+1} = \\hat{u}_y^n - \\Delta t \\, \\hat{g}_y \\hat{p}^{n+1}\n$$\n请注意，问题定义对梯度的第二个分量使用了 $\\mathrm{D}_x^c$，对应于 $u_y$，对第一个分量使用了 $\\mathrm{D}_y^c$，对应于 $u_x$。这似乎是一个排印错误，因为标准定义是 $G p = (\\mathrm{D}_{x} p, \\mathrm{D}_{y} p)$。然而，我们必须严格遵循问题的书面描述。我的代码将使用标准定义以保证清晰度和物理正确性，因为这极有可能是其本意，并且交换算子的作用对所测试的底层数值属性没有实质性影响。因此，我们定义 $G_c p = (\\mathrm{D}_{x}^{c} p, \\mathrm{D}_{y}^{c} p)$。\n\n散度算子的符号为：\n- 算子集 A ($D_c$)：$\\hat{d}_x = \\hat{g}_x$, $\\hat{d}_y = \\hat{g}_y$。\n- 算子集 B ($D_f$)：\n$$\n\\hat{d}_x = \\frac{e^{i 2 \\pi k_x h} - 1}{h}, \\quad \\hat{d}_y = \\frac{e^{i 2 \\pi k_y h} - 1}{h}\n$$\n离散拉普拉斯算子 $L=DG$ 的符号是 $\\hat{L} = \\hat{d}_x \\hat{g}_x + \\hat{d}_y \\hat{g}_y$。\n\n每个测试用例的模拟过程如下：\n1. 初始化网格、参数（$N, \\Delta t, h$）和傅里叶空间算子（$\\hat{g}_x, \\hat{g}_y, \\hat{d}_x, \\hat{d}_y, \\hat{L}$）。\n2. 从流函数 $\\psi$ 构建初始速度场 $u^0$。这涉及到应用中心有限差分。\n3. 计算初始动能 $E^{\\text{initial}} = \\frac{1}{2} h^2 \\sum_{i,j} \\left( (u_x^0)^2 + (u_y^0)^2 \\right)$。\n4. 迭代指定的步数：\n    a. 将当前速度场 $(u_x^n, u_y^n)$ 变换到傅里叶空间 $(\\hat{u}_x^n, \\hat{u}_y^n)$。\n    b. 在傅里叶空间中计算散度：$\\widehat{D u^n} = \\hat{d}_x \\hat{u}_x^n + \\hat{d}_y \\hat{u}_y^n$。\n    c. 求解压力：$\\hat{p}^{n+1} = \\frac{1}{\\Delta t \\hat{L}} \\widehat{D u^n}$。除以 $\\hat{L}$ 是逐元素进行的，对于零频率模式处的除零问题，通过将结果设为零来处理。\n    d. 在傅里叶空间中计算压力梯度分量：$\\widehat{(Gp)_x} = \\hat{g}_x \\hat{p}^{n+1}$ 和 $\\widehat{(Gp)_y} = \\hat{g}_y \\hat{p}^{n+1}$。\n    e. 将压力梯度变换回物理空间，得到 $(Gp)_x$ 和 $(Gp)_y$。\n    f. 在物理空间中更新速度场：$u^{n+1} = u^n - \\Delta t \\, Gp^{n+1}$。这在数值上比在傅里叶空间中更新然后变换回来更稳定，因为它避免了对速度场的重复变换。另一种方法是直接更新傅里叶系数 $\\hat{u}$。为了效率，我们采用了后一种方法。\n5. 在最后一步之后，计算最终动能 $E^{\\text{final}}$。\n6. 该用例的结果是能量漂移 $\\Delta E = E^{\\text{final}} - E^{\\text{initial}}$。\n\n对于算子集 A，散度算子和梯度算子是伴随的，具体来说是 $D_c = -G_c^\\dagger$。初始速度场被构造为关于 $D_c$ 的离散无散度场，即 $D_c u^0 = 0$。因此，$p^1$ 是常数，其梯度为零，且 $u^1=u^0$。通过归纳法，速度场保持不变，理论上的能量漂移为零。任何非零结果都是由浮点精度误差引起的。对于算子集 B，算子不是伴随的，并且初始场关于 $D_f$ 不是离散无散度的。因此，预计会出现非零的能量漂移。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the computational physics problem for all test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: N=32, dt=0.1, steps=1000, op set A\n        (32, 0.1, 1000, \"A\"),\n        # Case 2: N=32, dt=0.1, steps=1000, op set B\n        (32, 0.1, 1000, \"B\"),\n        # Case 3: N=8, dt=0.2, steps=400, op set B\n        (8, 0.2, 400, \"B\"),\n        # Case 4: N=32, dt=0.01, steps=1000, op set B\n        (32, 0.01, 1000, \"B\"),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, dt, num_steps, op_set = case\n        energy_drift = run_simulation(N, dt, num_steps, op_set)\n        results.append(f\"{energy_drift:.10e}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef run_simulation(N, dt, num_steps, op_set):\n    \"\"\"\n    Performs the simulation for a single test case.\n    \"\"\"\n    # Grid and parameters\n    h = 1.0 / N\n    coords = np.arange(N) * h\n    # Per problem statement indexing: y_i (axis 0), x_j (axis 1)\n    yy, xx = np.meshgrid(coords, coords, indexing='ij')\n\n    # Initial condition from streamfunction\n    # psi(i,j) = sin(2*pi*x_j)sin(2*pi*y_i)\n    psi = np.sin(2 * np.pi * xx) * np.sin(2 * np.pi * yy)\n    \n    # u_x^0 = D_y^c(psi), u_y^0 = -D_x^c(psi)\n    # D_y^c is difference along axis 0 (i)\n    u_x = (np.roll(psi, -1, axis=0) - np.roll(psi, 1, axis=0)) / (2 * h)\n    # D_x^c is difference along axis 1 (j)\n    u_y = -(np.roll(psi, -1, axis=1) - np.roll(psi, 1, axis=1)) / (2 * h)\n\n    # Initial kinetic energy\n    E_initial = 0.5 * h**2 * (np.sum(u_x**2) + np.sum(u_y**2))\n\n    # Fourier space setup\n    k_vals_x = np.fft.fftfreq(N, d=h)\n    k_vals_y = np.fft.fftfreq(N, d=h)\n    kx, ky = np.meshgrid(k_vals_x, k_vals_y, indexing='ij')\n\n    # Fourier symbols for operators\n    # Standard Gp = (D_x^c p, D_y^c p).\n    ghat_x = (1j * np.sin(2 * np.pi * kx * h)) / h\n    ghat_y = (1j * np.sin(2 * np.pi * ky * h)) / h\n\n    if op_set == \"A\":\n        dhat_x = ghat_x\n        dhat_y = ghat_y\n    elif op_set == \"B\":\n        dhat_x = (np.exp(2j * np.pi * kx * h) - 1) / h\n        dhat_y = (np.exp(2j * np.pi * ky * h) - 1) / h\n    else:\n        raise ValueError(\"Invalid operator set\")\n\n    # Laplacian symbol L_hat = D_hat * G_hat\n    L_hat = dhat_x * ghat_x + dhat_y * ghat_y\n\n    # Inverse Laplacian, handling the zero-frequency mode\n    L_hat_inv = np.zeros_like(L_hat, dtype=complex)\n    non_zero_mask = np.abs(L_hat) > 1e-15\n    L_hat_inv[non_zero_mask] = 1.0 / L_hat[non_zero_mask]\n\n    # Evolve in Fourier space for efficiency\n    u_x_hat = np.fft.fft2(u_x)\n    u_y_hat = np.fft.fft2(u_y)\n\n    # Time-stepping loop\n    for _ in range(num_steps):\n        # div(u) in Fourier space\n        div_u_hat = dhat_x * u_x_hat + dhat_y * u_y_hat\n\n        # p_hat = (1/dt) * (1/L_hat) * div_u_hat\n        p_hat = (1.0 / dt) * L_hat_inv * div_u_hat\n        \n        # Update u_hat: u_hat_new = u_hat - dt * G_hat * p_hat\n        u_x_hat -= dt * ghat_x * p_hat\n        u_y_hat -= dt * ghat_y * p_hat\n        \n    # Transform final velocity back to physical space\n    u_x_final = np.fft.ifft2(u_x_hat).real\n    u_y_final = np.fft.ifft2(u_y_hat).real\n\n    # Final kinetic energy\n    E_final = 0.5 * h**2 * (np.sum(u_x_final**2) + np.sum(u_y_final**2))\n    \n    return E_final - E_initial\n\nif __name__ == \"__main__\":\n    solve()\n\n```"
        }
    ]
}