{
    "hands_on_practices": [
        {
            "introduction": "理论学习之后，最好的消化方式莫过于亲手实践。本练习将引导你将位置-Verlet积分器应用于一个我们都非常熟悉的物理场景——抛体运动。通过手动计算前几个时间步的状态，你将对辛积分器如何迭代更新系统的位置与速度建立起直观的认识。",
            "id": "1713079",
            "problem": "在计算物理学中，一个常见的任务是模拟粒子在力作用下的运动。辛积分器是一类特别适用于此任务的数值方法，因为它们在长时间的模拟中倾向于保持系统的总能量守恒。\n\n考虑一个粒子在均匀引力场中进行二维运动 $(x,y)$。该粒子的轨迹将使用位置Verlet算法进行模拟。在离散时间步长 $n$ 时，粒子位置矢量 $\\vec{r}_n$ 和速度矢量 $\\vec{v}_n$ 的更新规则如下：\n$$ \\vec{r}_{n+1} = \\vec{r}_n + \\vec{v}_n \\Delta t + \\frac{1}{2} \\vec{a}(\\vec{r}_n) (\\Delta t)^2 $$\n$$ \\vec{v}_{n+1} = \\vec{v}_n + \\frac{1}{2} (\\vec{a}(\\vec{r}_n) + \\vec{a}(\\vec{r}_{n+1})) \\Delta t $$\n其中 $\\Delta t$ 是时间步长，$\\vec{a}(\\vec{r})$ 是加速度矢量，它可能取决于位置 $\\vec{r}$。\n\n粒子受到一个恒定的向下引力加速度，由矢量 $\\vec{g} = (0, -g)$ 描述。在时间 $t_0 = 0$ 时，粒子具有初始位置 $\\vec{r}_0 = (0, 0)$ 和初始速度 $\\vec{v}_0 = (12.5 \\text{ m/s}, 25.0 \\text{ m/s})$。\n\n使用以下常量：\n- 引力加速度大小：$g = 9.80 \\text{ m/s}^2$\n- 时间步长：$\\Delta t = 1.20 \\text{ s}$\n\n计算在时间 $t_2 = 2\\Delta t$ 时，粒子的位置矢量分量 $(x_2, y_2)$ 和速度矢量分量 $(v_{x,2}, v_{y,2})$。\n\n您的答案应包含 $x_2, y_2, v_{x,2}, v_{y,2}$ 这四个分量的数值，并按此特定顺序排列。请将您的最终答案中，位置以米为单位，速度以米/秒为单位，并将每个值四舍五入到三位有效数字。",
            "solution": "目标是使用位置Verlet算法，求解粒子在两个时间步长之后的位置 $\\vec{r}_2 = (x_2, y_2)$ 和速度 $\\vec{v}_2 = (v_{x,2}, v_{y,2})$。\n\n题目说明粒子处于均匀引力场中，因此其加速度是恒定的，不依赖于其位置。对于任何位置 $\\vec{r}$，加速度矢量为 $\\vec{a}(\\vec{r}) = \\vec{g} = (0, -g)$。这意味着 $\\vec{a}(\\vec{r}_n) = \\vec{a}(\\vec{r}_{n+1}) = (0, -g)$。\n\n这简化了速度更新规则：\n$$ \\vec{v}_{n+1} = \\vec{v}_n + \\frac{1}{2} ((0, -g) + (0, -g)) \\Delta t = \\vec{v}_n + (0, -g) \\Delta t $$\n位置更新规则为：\n$$ \\vec{r}_{n+1} = \\vec{r}_n + \\vec{v}_n \\Delta t + \\frac{1}{2} (0, -g) (\\Delta t)^2 $$\n\n我们已知 $n=0$ 时的初始条件：\n$\\vec{r}_0 = (x_0, y_0) = (0, 0)$\n$\\vec{v}_0 = (v_{x,0}, v_{y,0}) = (12.5, 25.0)$\n常量为 $g = 9.80$ 和 $\\Delta t = 1.20$。\n\n**第1步：计算时间 $t_1 = \\Delta t$ 时的状态（即，对于 $n=1$）。**\n\n我们使用 $n=0$ 时的更新规则。\n对于位置 $\\vec{r}_1 = (x_1, y_1)$：\nx分量的更新为：\n$x_1 = x_0 + v_{x,0} \\Delta t + \\frac{1}{2}(0)(\\Delta t)^2 = 0 + (12.5 \\text{ m/s})(1.20 \\text{ s}) = 15.0 \\text{ m}$\ny分量的更新为：\n$y_1 = y_0 + v_{y,0} \\Delta t + \\frac{1}{2}(-g)(\\Delta t)^2 = 0 + (25.0 \\text{ m/s})(1.20 \\text{ s}) - \\frac{1}{2}(9.80 \\text{ m/s}^2)(1.20 \\text{ s})^2$\n$y_1 = 30.0 \\text{ m} - \\frac{1}{2}(9.80 \\text{ m/s}^2)(1.44 \\text{ s}^2) = 30.0 \\text{ m} - 7.056 \\text{ m} = 22.944 \\text{ m}$\n因此，$\\vec{r}_1 = (15.0, 22.944)$ m。\n\n对于速度 $\\vec{v}_1 = (v_{x,1}, v_{y,1})$：\nx分量的更新为：\n$v_{x,1} = v_{x,0} + (0)\\Delta t = 12.5 \\text{ m/s}$\ny分量的更新为：\n$v_{y,1} = v_{y,0} - g \\Delta t = 25.0 \\text{ m/s} - (9.80 \\text{ m/s}^2)(1.20 \\text{ s}) = 25.0 \\text{ m/s} - 11.76 \\text{ m/s} = 13.24 \\text{ m/s}$\n因此，$\\vec{v}_1 = (12.5, 13.24)$ m/s。\n\n**第2步：计算时间 $t_2 = 2\\Delta t$ 时的状态（即，对于 $n=2$）。**\n\n现在我们使用 $n=1$ 时的更新规则，并利用我们刚刚计算出的状态 $(\\vec{r}_1, \\vec{v}_1)$。\n对于位置 $\\vec{r}_2 = (x_2, y_2)$：\nx分量的更新为：\n$x_2 = x_1 + v_{x,1} \\Delta t + \\frac{1}{2}(0)(\\Delta t)^2 = 15.0 \\text{ m} + (12.5 \\text{ m/s})(1.20 \\text{ s}) = 15.0 \\text{ m} + 15.0 \\text{ m} = 30.0 \\text{ m}$\ny分量的更新为：\n$y_2 = y_1 + v_{y,1} \\Delta t + \\frac{1}{2}(-g)(\\Delta t)^2 = 22.944 \\text{ m} + (13.24 \\text{ m/s})(1.20 \\text{ s}) - \\frac{1}{2}(9.80 \\text{ m/s}^2)(1.20 \\text{ s})^2$\n$y_2 = 22.944 \\text{ m} + 15.888 \\text{ m} - 7.056 \\text{ m} = 31.776 \\text{ m}$\n因此，$\\vec{r}_2 = (30.0, 31.776)$ m。\n\n对于速度 $\\vec{v}_2 = (v_{x,2}, v_{y,2})$：\nx分量的更新为：\n$v_{x,2} = v_{x,1} + (0)\\Delta t = 12.5 \\text{ m/s}$\ny分量的更新为：\n$v_{y,2} = v_{y,1} - g \\Delta t = 13.24 \\text{ m/s} - (9.80 \\text{ m/s}^2)(1.20 \\text{ s}) = 13.24 \\text{ m/s} - 11.76 \\text{ m/s} = 1.48 \\text{ m/s}$\n因此，$\\vec{v}_2 = (12.5, 1.48)$ m/s。\n\n**第3步：最终答案整理**\n\n计算出的分量是：\n$x_2 = 30.0$ m\n$y_2 = 31.776$ m\n$v_{x,2} = 12.5$ m/s\n$v_{y,2} = 1.48$ m/s\n\n将每个值四舍五入到三位有效数字：\n$x_2 = 30.0$\n$y_2 \\approx 31.8$\n$v_{x,2} = 12.5$\n$v_{y,2} = 1.48$\n\n最终答案应是这四个值，按 $x_2, y_2, v_{x,2}, v_{y,2}$ 的顺序排列。",
            "answer": "$$\\boxed{\\begin{pmatrix} 30.0  31.8  12.5  1.48 \\end{pmatrix}}$$"
        },
        {
            "introduction": "在掌握了辛积分方法的基本操作后，我们来深入探讨其为何如此特别。这个练习将通过一个编程任务，揭示辛积分器最核心的几何特性——相空间面积守恒。你将对比一个辛积分器和一个非辛积分器（如前向欧拉法），直观地观察到前者如何保持相空间区域的面积不变，而后者则不然，从而深刻理解它们在长期模拟中表现迥异的根本原因。",
            "id": "2444632",
            "problem": "考虑一个二维谐振子，其哈密顿量为 $H(x,p)=\\dfrac{p^2}{2 m}+\\dfrac{1}{2} k x^2$，其中 $m=1$，$k=\\omega^2$，$x$ 是位置坐标，$p$ 是共轭动量。哈密顿运动方程为 $\\dot{x}=p$ 和 $\\dot{p}=-\\omega^2 x$。定义如下两个时间步长为 $h$ 的离散时间单步映射：\n- 映射 $\\mathcal{F}$（一个显式前向步）：$x_{n+1}=x_n+h\\,p_n$， $p_{n+1}=p_n-h\\,\\omega^2 x_n$。\n- 映射 $\\mathcal{S}$（一个半隐式步）：$p_{n+1}=p_n-h\\,\\omega^2 x_n$， $x_{n+1}=x_n+h\\,p_{n+1}$。\n设 $\\mathcal{C}_0$ 是 $(x,p)$ 相平面中的一个闭合凸多边形，有 $M$ 个顶点 $\\{(x_j(0),p_j(0))\\}_{j=0}^{M-1}$，按逆时针排序，由下式给出\n$$\nx_j(0)=R\\cos\\theta_j,\\quad p_j(0)=R\\sin\\theta_j,\\quad \\theta_j=\\dfrac{2\\pi j}{M},\n$$\n对于 $j\\in\\{0,1,\\dots,M-1\\}$，所有角度均以弧度为单位。所有量均为无量纲。\n\n对于给定的映射 $\\mathcal{M}\\in\\{\\mathcal{F},\\mathcal{S}\\}$ 和一个正整数 $N$，定义 $\\mathcal{C}_N$ 为将 $\\mathcal{M}$ 的 $N$ 个连续步骤应用于 $\\mathcal{C}_0$ 的每个顶点所得到的多边形，并保持顶点顺序。定义多边形面积泛函\n$$\nA[\\mathcal{C}]=\\dfrac{1}{2}\\left|\\sum_{j=0}^{M-1}\\left(x_j\\,p_{j+1}-x_{j+1}\\,p_j\\right)\\right|,\n$$\n采用循环索引 $x_M\\equiv x_0$ 和 $p_M\\equiv p_0$。对于下面的每个测试用例，计算 $\\mathcal{M}=\\mathcal{F}$ 和 $\\mathcal{M}=\\mathcal{S}$ 的面积比 $A[\\mathcal{C}_N]/A[\\mathcal{C}_0]$。\n\n使用以下参数集测试套件 $(\\omega,h,N,M,R)$:\n- 测试 $1$: $(\\omega,h,N,M,R)=\\left(1,\\,0.1,\\,100,\\,128,\\,1\\right)$。\n- 测试 $2$: $(\\omega,h,N,M,R)=\\left(1,\\,0.5,\\,20,\\,128,\\,1\\right)$。\n- 测试 $3$: $(\\omega,h,N,M,R)=\\left(2,\\,0.1,\\,100,\\,128,\\,1\\right)$。\n- 测试 $4$: $(\\omega,h,N,M,R)=\\left(1,\\,0.01,\\,1000,\\,128,\\,1\\right)$。\n\n您的程序必须为每个测试（按所列顺序）生成两个浮点数：首先是映射 $\\mathcal{F}$ 的面积比，然后是映射 $\\mathcal{S}$ 的面积比。将每个数字四舍五入到 $6$ 位小数。最终输出必须是单行，包含一个用方括号括起来的逗号分隔列表，其中包含所有按顺序排列的结果，即\n$$\n\\left[\\rho^{(\\mathcal{F})}_1,\\rho^{(\\mathcal{S})}_1,\\rho^{(\\mathcal{F})}_2,\\rho^{(\\mathcal{S})}_2,\\rho^{(\\mathcal{F})}_3,\\rho^{(\\mathcal{S})}_3,\\rho^{(\\mathcal{F})}_4,\\rho^{(\\mathcal{S})}_4\\right],\n$$\n其中 $\\rho^{(\\mathcal{M})}_i=A[\\mathcal{C}_N]/A[\\mathcal{C}_0]$ 是第 $i$ 个测试用例和映射 $\\mathcal{M}$ 的结果。此问题不涉及物理单位，所有角度必须以弧度为单位。",
            "solution": "该问题要求计算一个多边形在两种不同的谐振子数值积分方案下演化后的相空间面积之比。对 $M$ 个顶点中的每一个进行 $N$ 个时间步的直接模拟是一种有效但计算效率低下的方法。通过分析映射的代数性质，可以找到一个更有洞察力的解决方案。\n\n设系统在相空间中的状态由向量 $z = (x, p)^T$ 表示。哈密顿运动方程为 $\\dot{x} = \\partial H / \\partial p = p/m$ 和 $\\dot{p} = -\\partial H / \\partial x = -kx$。当 $m=1$ 和 $k=\\omega^2$ 时，我们有 $\\dot{z} = A z$，其中 $A = \\begin{pmatrix} 0  1 \\\\ -\\omega^2  0 \\end{pmatrix}$。映射 $\\mathcal{F}$ 和 $\\mathcal{S}$ 是该线性系统流的离散近似。\n\n映射 $\\mathcal{F}$ 和 $\\mathcal{S}$ 都是从时间步 $n$ 的状态 $(x_n, p_n)$ 到时间步 $n+1$ 的状态 $(x_{n+1}, p_{n+1})$ 的线性变换。我们可以将它们表示为矩阵形式 $z_{n+1} = M z_n$。\n\n对于映射 $\\mathcal{F}$（显式前向欧拉法）：\n$$\n\\begin{cases}\nx_{n+1} = x_n + h\\,p_n \\\\\np_{n+1} = p_n - h\\,\\omega^2 x_n\n\\end{cases}\n\\implies\n\\begin{pmatrix} x_{n+1} \\\\ p_{n+1} \\end{pmatrix} =\n\\begin{pmatrix} 1  h \\\\ -h\\omega^2  1 \\end{pmatrix}\n\\begin{pmatrix} x_n \\\\ p_n \\end{pmatrix}\n$$\n因此，单步演化矩阵为 $M_{\\mathcal{F}} = \\begin{pmatrix} 1  h \\\\ -h\\omega^2  1 \\end{pmatrix}$。\n\n对于映射 $\\mathcal{S}$（半隐式欧拉法）：\n$$\n\\begin{cases}\np_{n+1} = p_n - h\\,\\omega^2 x_n \\\\\nx_{n+1} = x_n + h\\,p_{n+1} = x_n + h(p_n - h\\omega^2 x_n) = (1-h^2\\omega^2)x_n + h p_n\n\\end{cases}\n$$\n$$\n\\implies\n\\begin{pmatrix} x_{n+1} \\\\ p_{n+1} \\end{pmatrix} =\n\\begin{pmatrix} 1-h^2\\omega^2  h \\\\ -h\\omega^2  1 \\end{pmatrix}\n\\begin{pmatrix} x_n \\\\ p_n \\end{pmatrix}\n$$\n单步演化矩阵为 $M_{\\mathcal{S}} = \\begin{pmatrix} 1-h^2\\omega^2  h \\\\ -h\\omega^2  1 \\end{pmatrix}$。\n\n经过 $N$ 步后，从初始状态 $z_0$ 到最终状态 $z_N$ 的变换由 $z_N = (M_{\\mathcal{M}})^N z_0$ 给出，其中 $\\mathcal{M} \\in \\{\\mathcal{F}, \\mathcal{S}\\}$。这是一个线性变换，我们称其矩阵为 $T = (M_{\\mathcal{M}})^N$。\n\n具有顶点 $\\{(x_j, p_j)\\}_{j=0}^{M-1}$ 的多边形 $\\mathcal{C}$ 的面积由鞋带公式给出：\n$$\nA[\\mathcal{C}]=\\dfrac{1}{2}\\left|\\sum_{j=0}^{M-1}\\left(x_j\\,p_{j+1}-x_{j+1}\\,p_j\\right)\\right|\n$$\n当一个多边形受到一个矩阵为 $T$ 的线性变换时，其面积 $A$ 将变为 $A' = |\\det(T)| A$。\n在我们的例子中，初始多边形 $\\mathcal{C}_0$ 的顶点 $\\{z_j(0)\\}$ 被变换为最终多边形 $\\mathcal{C}_N$ 的顶点 $\\{z_j(N) = T z_j(0)\\}$。因此，最终多边形的面积为 $A[\\mathcal{C}_N] = |\\det(T)| A[\\mathcal{C}_0]$。\n\n所求的面积比为：\n$$\n\\dfrac{A[\\mathcal{C}_N]}{A[\\mathcal{C}_0]} = |\\det(T)| = |\\det((M_{\\mathcal{M}})^N)| = |\\det(M_{\\mathcal{M}})|^N\n$$\n这个结果与初始多边形的具体几何形状无关，即参数 $M$ 和 $R$ 与最终的比率无关。我们只需要计算单步矩阵的行列式。\n\n对于映射 $\\mathcal{F}$：\n$$\n\\det(M_{\\mathcal{F}}) = (1)(1) - (h)(-h\\omega^2) = 1 + h^2\\omega^2\n$$\n面积比为 $\\rho^{(\\mathcal{F})} = (1 + h^2\\omega^2)^N$。由于 $h > 0$ 和 $\\omega > 0$，这个值总是大于 $1$，表明面积呈指数增长。该映射不是辛映射。\n\n对于映射 $\\mathcal{S}$：\n$$\n\\det(M_{\\mathcal{S}}) = (1-h^2\\omega^2)(1) - (h)(-h\\omega^2) = 1 - h^2\\omega^2 + h^2\\omega^2 = 1\n$$\n面积比为 $\\rho^{(\\mathcal{S})} = (1)^N = 1$。该映射对于任何参数选择都能精确保持相空间面积，因此是一个辛映射。\n\n现在我们将这些公式应用于给定的测试用例。\n\n测试 $1$: $(\\omega,h,N,M,R)=\\left(1,\\,0.1,\\,100,\\,128,\\,1\\right)$\n$\\rho^{(\\mathcal{F})} = (1 + (0.1)^2(1)^2)^{100} = (1.01)^{100} \\approx 2.704814$\n$\\rho^{(\\mathcal{S})} = 1.0$\n\n测试 $2$: $(\\omega,h,N,M,R)=\\left(1,\\,0.5,\\,20,\\,128,\\,1\\right)$\n$\\rho^{(\\mathcal{F})} = (1 + (0.5)^2(1)^2)^{20} = (1.25)^{20} \\approx 86.736174$\n$\\rho^{(\\mathcal{S})} = 1.0$\n\n测试 $3$: $(\\omega,h,N,M,R)=\\left(2,\\,0.1,\\,100,\\,128,\\,1\\right)$\n$\\rho^{(\\mathcal{F})} = (1 + (0.1)^2(2)^2)^{100} = (1.04)^{100} \\approx 50.504948$\n$\\rho^{(\\mathcal{S})} = 1.0$\n\n测试 $4$: $(\\omega,h,N,M,R)=\\left(1,\\,0.01,\\,1000,\\,128,\\,1\\right)$\n$\\rho^{(\\mathcal{F})} = (1 + (0.01)^2(1)^2)^{1000} = (1.0001)^{1000} \\approx 1.105116$\n$\\rho^{(\\mathcal{S})} = 1.0$\n\n这些计算将在提供的程序结构中实现。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by analytically calculating the area ratios for the two maps.\n    The area ratio for a polygon under a linear map T is given by |det(T)|.\n    For N steps, the transformation is T = M^N, where M is the one-step matrix.\n    The area ratio is |det(M^N)| = |det(M)|^N.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each test case is a tuple: (omega, h, N, M, R)\n    test_cases = [\n        (1.0, 0.1, 100, 128, 1.0),\n        (1.0, 0.5, 20, 128, 1.0),\n        (2.0, 0.1, 100, 128, 1.0),\n        (1.0, 0.01, 1000, 128, 1.0),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        omega, h, N, M, R = case\n\n        # --- Map F (Explicit Euler) ---\n        # The one-step matrix M_F has determinant det(M_F) = 1 + h^2 * omega^2.\n        # The area ratio after N steps is (det(M_F))^N.\n        det_M_F = 1.0 + h**2 * omega**2\n        rho_F = np.power(det_M_F, N)\n\n        # --- Map S (Symplectic Euler) ---\n        # The one-step matrix M_S has determinant det(M_S) = 1.\n        # The area ratio after N steps is (det(M_S))^N = 1^N = 1.\n        rho_S = 1.0\n\n        # Append the rounded results for the current test case.\n        results.append(round(rho_F, 6))\n        results.append(round(rho_S, 6))\n\n    # Final print statement in the exact required format.\n    # The output is a single line, comma-separated list of numbers in brackets.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "我们已经看到的几何特性会带来深刻的实际影响。这最后一个练习将探讨其中一个关键特性：时间可逆性。你将通过编程对比辛积分器（速度Verlet算法）与一种广泛使用但非辛的高阶方法（四阶龙格-库塔法）。通过先正向积分再反向积分，你会发现只有辛方法能够精确地回到初始状态，这对于保证长期模拟的稳定性和可靠性至关重要。",
            "id": "2444614",
            "problem": "考虑一个一维谐振子，其哈密顿量为 $H(q,p)=\\dfrac{p^2}{2m}+\\dfrac{k}{2}q^2$，其中 $q$ 是位置，$p$ 是动量，$m$ 是质量，$k$ 是弹簧常数。其动力学由哈密顿方程决定。从时间 $t=0$ 时的初始状态 $(q_0,p_0)$ 开始，为给定的时间步进方法定义以下数值可逆性的定量诊断：将系统以大小为 $h$ 的 $N$ 个均匀步长随时间正向积分，得到 $(q_N,p_N)$，然后从 $(q_N,p_N)$ 开始，以大小为 $-h$ 的 $N$ 个均匀步长随时间反向积分，得到 $(\\tilde{q}_0,\\tilde{p}_0)$。数值可逆性误差是欧几里得范数 $E=\\sqrt{(\\tilde{q}_0-q_0)^2+(\\tilde{p}_0-p_0)^2}$。\n\n编写一个完整的、可运行的程序，为以下两种积分器计算这个先正向后反向的数值可逆性误差 $E$：\n- 经典四阶龙格－库塔方法（fourth-order Runge–Kutta (RK4)），\n- 速度 Verlet 辛格式。\n\n本问题中所有量都是无量纲的，因此所有数值结果都应报告为无量纲实数。您的程序必须为两种积分器计算下列每个测试用例的误差 $E$，每个用例由 $(m,k,q_0,p_0,h,N)$ 指定：\n1. $(m,k,q_0,p_0,h,N)=\\left(1.0,\\,1.0,\\,1.0,\\,0.0,\\,0.1,\\,100\\right)$，一个通用情况。\n2. $(m,k,q_0,p_0,h,N)=\\left(1.0,\\,1.0,\\,1.0,\\,0.0,\\,0.01,\\,1000\\right)$，一个小时间步长情况。\n3. $(m,k,q_0,p_0,h,N)=\\left(1.0,\\,1.0,\\,1.0,\\,0.0,\\,1.9,\\,100\\right)$，一个接近谐振子稳定性边界的大时间步长。\n4. $(m,k,q_0,p_0,h,N)=\\left(1.0,\\,1.0,\\,1.0,\\,0.0,\\,0.05,\\,10000\\right)$，一次长时间积分。\n5. $(m,k,q_0,p_0,h,N)=\\left(1.0,\\,1.0,\\,0.2,\\,-0.3,\\,0.37,\\,0\\right)$，一个零步长的边界条件情况。\n6. $(m,k,q_0,p_0,h,N)=\\left(2.0,\\,0.5,\\,0.3,\\,0.7,\\,0.07,\\,1234\\right)$，一个非平凡的质量和刚度。\n\n对于每个测试用例，计算两个误差：$E_{\\mathrm{RK4}}$ 和 $E_{\\mathrm{Verlet}}$。最终输出必须是单行，包含一个用方括号括起来的逗号分隔列表，顺序为\n$[E_{\\mathrm{RK4}}^{(1)},E_{\\mathrm{Verlet}}^{(1)},E_{\\mathrm{RK4}}^{(2)},E_{\\mathrm{Verlet}}^{(2)},\\dots,E_{\\mathrm{RK4}}^{(6)},E_{\\mathrm{Verlet}}^{(6)}]$，\n其中上标表示测试用例编号。每个数值必须四舍五入到12位小数。\n\n您的实现必须从给定 $H(q,p)$ 的哈密顿方程出发，并使用指定的两种积分器，不依赖任何外部数据。不涉及角度。最终输出必须严格符合指定的单行格式。",
            "solution": "该问题要求对一维谐振子的两种积分器——四阶龙格－库塔方法和速度 Verlet 方法——的数值可逆性进行比较分析。我们首先建立运动控制方程。\n\n该系统由哈密顿量 $H(q,p)=\\dfrac{p^2}{2m}+\\dfrac{k}{2}q^2$ 描述，其中 $q$ 是位置，$p$ 是动量，$m$ 是质量，$k$ 是弹簧常数。所有量均为无量纲。其动力学由哈密顿方程决定：\n$$ \\dot{q} = \\frac{\\partial H}{\\partial p} = \\frac{p}{m} $$\n$$ \\dot{p} = -\\frac{\\partial H}{\\partial q} = -kq $$\n这是一个由两个耦合的一阶常微分方程组成的系统。我们可以用一个向量 $\\mathbf{y}(t) = [q(t), p(t)]^T$ 来表示系统的状态。运动方程可以写成紧凑形式 $\\dot{\\mathbf{y}} = \\mathbf{f}(\\mathbf{y})$，其中向量场 $\\mathbf{f}$ 由下式给出：\n$$ \\mathbf{f}(\\mathbf{y}) = \\mathbf{f}(q, p) = \\begin{pmatrix} p/m \\\\ -kq \\end{pmatrix} $$\n我们的任务是使用两种不同的方法对该系统进行数值积分。\n\n首先，我们考虑经典的四阶龙格－库塔（RK4）方法。给定在时间 $t_n$ 的状态 $\\mathbf{y}_n$，通过大小为 $h$ 的单步计算得到在时间 $t_{n+1} = t_n + h$ 的状态 $\\mathbf{y}_{n+1}$ 的公式如下：\n$$ \\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{h}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4) $$\n其中中间阶段定义为：\n$$ \\mathbf{k}_1 = \\mathbf{f}(\\mathbf{y}_n) $$\n$$ \\mathbf{k}_2 = \\mathbf{f}(\\mathbf{y}_n + \\frac{h}{2}\\mathbf{k}_1) $$\n$$ \\mathbf{k}_3 = \\mathbf{f}(\\mathbf{y}_n + \\frac{h}{2}\\mathbf{k}_2) $$\n$$ \\mathbf{k}_4 = \\mathbf{f}(\\mathbf{y}_n + h\\mathbf{k}_3) $$\n注意，在实现中，因子 $h$ 通常在最后阶段应用。RK4 方法是一种通用的显式积分器，其局部截断误差为 $O(h^5)$ 阶，导致全局误差为 $O(h^4)$ 阶。然而，它不是一个辛积分器，这意味着它通常不保留哈密顿系统的几何结构。因此，它不是时间可逆的。\n\n其次，我们考虑速度 Verlet 方法。这种方法是专门为形式可分离的哈密顿系统 $H(q,p) = T(p) + V(q)$ 设计的，我们的谐振子哈密顿量满足此形式，其中 $T(p)=p^2/(2m)$ 且 $V(q)=kq^2/2$。从 $(q_n, p_n)$ 到 $(q_{n+1}, p_{n+1})$ 的单步算法如下：\n$1$. 使用力 $F(q) = -\\partial V/\\partial q = -kq$ 将动量更新半步：\n$$ p_{n+1/2} = p_n + \\frac{h}{2} F(q_n) = p_n - \\frac{h}{2} k q_n $$\n$2$. 使用半步后的动量将位置更新一整步：\n$$ q_{n+1} = q_n + h \\frac{p_{n+1/2}}{m} $$\n$3$. 使用新的力 $F(q_{n+1})$ 将动量完成最后半步的更新：\n$$ p_{n+1} = p_{n+1/2} + \\frac{h}{2} F(q_{n+1}) = p_{n+1/2} - \\frac{h}{2} k q_{n+1} $$\n速度 Verlet 方法的局部截断误差为 $O(h^3)$ 阶，全局误差为 $O(h^2)$ 阶。它在哈密顿力学中的关键优势在于它是一个辛积分器。此性质的一个关键结果是该方法是时间可逆的（或对称的）。\n\n数值可逆性误差 $E$ 就是为了直接测试此性质而设计的。设 $\\Phi_h$ 是将系统推进一个大小为 $h$ 的步长的数值映射。该过程如下：\n$1$. 从初始状态 $\\mathbf{y}_0 = (q_0, p_0)$ 开始正向积分 $N$ 步，得到 $\\mathbf{y}_N = \\Phi_h^N(\\mathbf{y}_0)$。\n$2$. 从 $\\mathbf{y}_N$ 开始，使用大小为 $-h$ 的步长反向积分 $N$ 步，得到 $\\tilde{\\mathbf{y}}_0 = \\Phi_{-h}^N(\\mathbf{y}_N)$。\n$3$. 误差是欧几里得距离 $E = \\|\\tilde{\\mathbf{y}}_0 - \\mathbf{y}_0\\| = \\sqrt{(\\tilde{q}_0-q_0)^2+(\\tilde{p}_0-p_0)^2}$。\n\n对于一个时间可逆的积分器，一个正向步和一个反向步的精确复合是恒等映射：$\\Phi_{-h} \\circ \\Phi_h = \\mathrm{Id}$。此性质可推广到任意步数，因此 $\\Phi_{-h}^N \\circ \\Phi_h^N = \\mathrm{Id}$。因此，对于速度 Verlet 方法，在精确算术中我们期望 $\\tilde{\\mathbf{y}}_0 = \\mathbf{y}_0$。因此，计算出的误差 $E_{\\mathrm{Verlet}}$ 应该为零，或者是一个可归因于浮点精度误差累积的非常小的数。\n\n对于非对称的 RK4 方法，$\\Phi_{-h} \\circ \\Phi_h \\neq \\mathrm{Id}$。正向-反向积分将不会返回到初始状态。产生的误差 $E_{\\mathrm{RK4}}$ 将不为零，并将提供该方法缺乏可逆性的定量度量。预期该误差将取决于步长 $h$ 和步数 $N$。\n\n程序将实现这两种算法，根据先正向后反向的程序将其应用于指定的测试用例，并计算误差 $E$。对于测试用例 5，其中 $N=0$，不执行任何积分步骤。因此，$\\mathbf{y}_N = \\mathbf{y}_0$ 且 $\\tilde{\\mathbf{y}}_0 = \\mathbf{y}_N = \\mathbf{y}_0$，导致两种方法的误差均为 $E=0$，这是平凡的结果。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the numerical reversibility error for RK4 and Velocity Verlet integrators\n    for a 1D harmonic oscillator across several test cases.\n    \"\"\"\n\n    test_cases = [\n        # (m, k, q0, p0, h, N)\n        (1.0, 1.0, 1.0, 0.0, 0.1, 100),       # 1. General case\n        (1.0, 1.0, 1.0, 0.0, 0.01, 1000),     # 2. Small time step\n        (1.0, 1.0, 1.0, 0.0, 1.9, 100),       # 3. Large time step\n        (1.0, 1.0, 1.0, 0.0, 0.05, 10000),    # 4. Long-time integration\n        (1.0, 1.0, 0.2, -0.3, 0.37, 0),      # 5. Zero steps\n        (2.0, 0.5, 0.3, 0.7, 0.07, 1234),     # 6. Nontrivial parameters\n    ]\n\n    def rk4_step(q, p, h, m, k):\n        \"\"\"Performs a single RK4 step for the harmonic oscillator.\"\"\"\n        \n        # k1\n        k1q = p / m\n        k1p = -k * q\n\n        # k2\n        q2 = q + 0.5 * h * k1q\n        p2 = p + 0.5 * h * k1p\n        k2q = p2 / m\n        k2p = -k * q2\n\n        # k3\n        q3 = q + 0.5 * h * k2q\n        p3 = p + 0.5 * h * k2p\n        k3q = p3 / m\n        k3p = -k * q3\n\n        # k4\n        q4 = q + h * k3q\n        p4 = p + h * k3p\n        k4q = p4 / m\n        k4p = -k * q4\n        \n        q_new = q + (h / 6.0) * (k1q + 2.0 * k2q + 2.0 * k3q + k4q)\n        p_new = p + (h / 6.0) * (k1p + 2.0 * k2p + 2.0 * k3p + k4p)\n        \n        return q_new, p_new\n\n    def verlet_step(q, p, h, m, k):\n        \"\"\"Performs a single Velocity Verlet step for the harmonic oscillator.\"\"\"\n        \n        force_initial = -k * q\n        p_half = p + 0.5 * h * force_initial\n        q_new = q + h * (p_half / m)\n        force_final = -k * q_new\n        p_new = p_half + 0.5 * h * force_final\n        \n        return q_new, p_new\n\n    def compute_reversibility_error(integrator_step, m, k, q0, p0, h, N):\n        \"\"\"\n        Computes the forward-then-backward numerical reversibility error E.\n        \"\"\"\n        if N == 0:\n            return 0.0\n\n        q, p = q0, p0\n        \n        # Forward integration\n        for _ in range(N):\n            q, p = integrator_step(q, p, h, m, k)\n        \n        # Backward integration\n        for _ in range(N):\n            q, p = integrator_step(q, p, -h, m, k)\n            \n        q_tilde_0, p_tilde_0 = q, p\n        \n        error = np.sqrt((q_tilde_0 - q0)**2 + (p_tilde_0 - p0)**2)\n        return error\n\n    results = []\n    for case in test_cases:\n        m, k, q0, p0, h, N = case\n        \n        m, k, q0, p0, h = float(m), float(k), float(q0), float(p0), float(h)\n        N = int(N)\n        \n        error_rk4 = compute_reversibility_error(rk4_step, m, k, q0, p0, h, N)\n        error_verlet = compute_reversibility_error(verlet_step, m, k, q0, p0, h, N)\n        \n        results.append(round(error_rk4, 12))\n        results.append(round(error_verlet, 12))\n    \n    final_output = \",\".join(map(str, results))\n    print(f\"[{final_output}]\")\n\nsolve()\n```"
        }
    ]
}