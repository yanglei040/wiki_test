{
    "hands_on_practices": [
        {
            "introduction": "The best way to understand a new numerical algorithm is to apply it. This first exercise provides a concrete starting point for using symplectic integrators by tasking you with applying the position-Verlet method, a popular form of the Störmer-Verlet algorithm, to the familiar physics problem of projectile motion. By manually computing the first few steps of the trajectory, you will gain a hands-on feel for how the positions and velocities are updated and how the algorithm progresses through time, grounding the abstract formulas in a tangible calculation .",
            "id": "1713079",
            "problem": "A common task in computational physics is to simulate the motion of particles under the influence of forces. Symplectic integrators are a class of numerical methods particularly well-suited for this, as they tend to conserve the total energy of a system over long simulation times.\n\nConsider a particle moving in two dimensions $(x,y)$ under a uniform gravitational field. The particle's trajectory is to be simulated using the position-Verlet algorithm. The update rules for the particle's position vector $\\vec{r}_n$ and velocity vector $\\vec{v}_n$ at discrete time-step $n$ are given by:\n$$ \\vec{r}_{n+1} = \\vec{r}_n + \\vec{v}_n \\Delta t + \\frac{1}{2} \\vec{a}(\\vec{r}_n) (\\Delta t)^2 $$\n$$ \\vec{v}_{n+1} = \\vec{v}_n + \\frac{1}{2} (\\vec{a}(\\vec{r}_n) + \\vec{a}(\\vec{r}_{n+1})) \\Delta t $$\nwhere $\\Delta t$ is the time step size and $\\vec{a}(\\vec{r})$ is the acceleration vector, which may depend on the position $\\vec{r}$.\n\nThe particle is subject to a constant downward gravitational acceleration described by the vector $\\vec{g} = (0, -g)$. At time $t_0 = 0$, the particle has an initial position $\\vec{r}_0 = (0, 0)$ and an initial velocity $\\vec{v}_0 = (12.5 \\text{ m/s}, 25.0 \\text{ m/s})$.\n\nUsing the following constants:\n- Magnitude of gravitational acceleration: $g = 9.80 \\text{ m/s}^2$\n- Time step size: $\\Delta t = 1.20 \\text{ s}$\n\nCalculate the components of the position vector $(x_2, y_2)$ and the velocity vector $(v_{x,2}, v_{y,2})$ of the particle at time $t_2 = 2\\Delta t$.\n\nYour answer should consist of four numerical values for the components $x_2, y_2, v_{x,2}, v_{y,2}$, in that specific order. Express your final answer for positions in meters and velocities in meters per second, with each value rounded to three significant figures.",
            "solution": "The goal is to find the position $\\vec{r}_2 = (x_2, y_2)$ and velocity $\\vec{v}_2 = (v_{x,2}, v_{y,2})$ of the particle after two time steps, using the position-Verlet algorithm.\n\nThe problem states the particle is in a uniform gravitational field, so its acceleration is constant and does not depend on its position. The acceleration vector is $\\vec{a}(\\vec{r}) = \\vec{g} = (0, -g)$ for any position $\\vec{r}$. This means $\\vec{a}(\\vec{r}_n) = \\vec{a}(\\vec{r}_{n+1}) = (0, -g)$.\n\nThis simplifies the velocity update rule:\n$$ \\vec{v}_{n+1} = \\vec{v}_n + \\frac{1}{2} ((0, -g) + (0, -g)) \\Delta t = \\vec{v}_n + (0, -g) \\Delta t $$\nThe position update rule is:\n$$ \\vec{r}_{n+1} = \\vec{r}_n + \\vec{v}_n \\Delta t + \\frac{1}{2} (0, -g) (\\Delta t)^2 $$\n\nWe are given the initial conditions at $n=0$:\n$\\vec{r}_0 = (x_0, y_0) = (0, 0)$\n$\\vec{v}_0 = (v_{x,0}, v_{y,0}) = (12.5, 25.0)$\nThe constants are $g = 9.80$ and $\\Delta t = 1.20$.\n\n**Step 1: Calculate the state at time $t_1 = \\Delta t$ (i.e., for $n=1$).**\n\nWe use the update rules with $n=0$.\nFor the position $\\vec{r}_1 = (x_1, y_1)$:\nThe x-component update is:\n$x_1 = x_0 + v_{x,0} \\Delta t + \\frac{1}{2}(0)(\\Delta t)^2 = 0 + (12.5 \\text{ m/s})(1.20 \\text{ s}) = 15.0 \\text{ m}$\nThe y-component update is:\n$y_1 = y_0 + v_{y,0} \\Delta t + \\frac{1}{2}(-g)(\\Delta t)^2 = 0 + (25.0 \\text{ m/s})(1.20 \\text{ s}) - \\frac{1}{2}(9.80 \\text{ m/s}^2)(1.20 \\text{ s})^2$\n$y_1 = 30.0 \\text{ m} - \\frac{1}{2}(9.80 \\text{ m/s}^2)(1.44 \\text{ s}^2) = 30.0 \\text{ m} - 7.056 \\text{ m} = 22.944 \\text{ m}$\nSo, $\\vec{r}_1 = (15.0, 22.944)$ m.\n\nFor the velocity $\\vec{v}_1 = (v_{x,1}, v_{y,1})$:\nThe x-component update is:\n$v_{x,1} = v_{x,0} + (0)\\Delta t = 12.5 \\text{ m/s}$\nThe y-component update is:\n$v_{y,1} = v_{y,0} - g \\Delta t = 25.0 \\text{ m/s} - (9.80 \\text{ m/s}^2)(1.20 \\text{ s}) = 25.0 \\text{ m/s} - 11.76 \\text{ m/s} = 13.24 \\text{ m/s}$\nSo, $\\vec{v}_1 = (12.5, 13.24)$ m/s.\n\n**Step 2: Calculate the state at time $t_2 = 2\\Delta t$ (i.e., for $n=2$).**\n\nNow we use the update rules with $n=1$, using the state $(\\vec{r}_1, \\vec{v}_1)$ we just calculated.\nFor the position $\\vec{r}_2 = (x_2, y_2)$:\nThe x-component update is:\n$x_2 = x_1 + v_{x,1} \\Delta t + \\frac{1}{2}(0)(\\Delta t)^2 = 15.0 \\text{ m} + (12.5 \\text{ m/s})(1.20 \\text{ s}) = 15.0 \\text{ m} + 15.0 \\text{ m} = 30.0 \\text{ m}$\nThe y-component update is:\n$y_2 = y_1 + v_{y,1} \\Delta t + \\frac{1}{2}(-g)(\\Delta t)^2 = 22.944 \\text{ m} + (13.24 \\text{ m/s})(1.20 \\text{ s}) - \\frac{1}{2}(9.80 \\text{ m/s}^2)(1.20 \\text{ s})^2$\n$y_2 = 22.944 \\text{ m} + 15.888 \\text{ m} - 7.056 \\text{ m} = 31.776 \\text{ m}$\nSo, $\\vec{r}_2 = (30.0, 31.776)$ m.\n\nFor the velocity $\\vec{v}_2 = (v_{x,2}, v_{y,2})$:\nThe x-component update is:\n$v_{x,2} = v_{x,1} + (0)\\Delta t = 12.5 \\text{ m/s}$\nThe y-component update is:\n$v_{y,2} = v_{y,1} - g \\Delta t = 13.24 \\text{ m/s} - (9.80 \\text{ m/s}^2)(1.20 \\text{ s}) = 13.24 \\text{ m/s} - 11.76 \\text{ m/s} = 1.48 \\text{ m/s}$\nSo, $\\vec{v}_2 = (12.5, 1.48)$ m/s.\n\n**Step 3: Final Answer Formulation**\n\nThe calculated components are:\n$x_2 = 30.0$ m\n$y_2 = 31.776$ m\n$v_{x,2} = 12.5$ m/s\n$v_{y,2} = 1.48$ m/s\n\nRounding each value to three significant figures:\n$x_2 = 30.0$\n$y_2 \\approx 31.8$\n$v_{x,2} = 12.5$\n$v_{y,2} = 1.48$\n\nThe final answer should be these four values in the order $x_2, y_2, v_{x,2}, v_{y,2}$.",
            "answer": "$$\\boxed{\\begin{pmatrix} 30.0 & 31.8 & 12.5 & 1.48 \\end{pmatrix}}$$"
        },
        {
            "introduction": "The true power of symplectic integrators lies not just in their accuracy, but in their faithful preservation of the geometric structure of Hamiltonian dynamics. This exercise demonstrates this crucial property by having you investigate how an area in phase space evolves under two different integrators. By comparing a non-symplectic map (forward Euler) with a symplectic one, you will see firsthand how the former can artificially cause the phase-space area to grow, while the symplectic map conserves it exactly, a property fundamental to long-term simulation stability .",
            "id": "2444632",
            "problem": "Consider the two-dimensional harmonic oscillator with Hamiltonian $H(x,p)=\\dfrac{p^2}{2 m}+\\dfrac{1}{2} k x^2$ with $m=1$ and $k=\\omega^2$, where $x$ is the position coordinate and $p$ is the conjugate momentum. The Hamiltonian equations of motion are $\\dot{x}=p$ and $\\dot{p}=-\\omega^2 x$. Define two discrete-time one-step maps with time step $h$ as follows:\n- Map $\\mathcal{F}$ (an explicit forward step): $x_{n+1}=x_n+h\\,p_n$, $p_{n+1}=p_n-h\\,\\omega^2 x_n$.\n- Map $\\mathcal{S}$ (a semi-implicit step): $p_{n+1}=p_n-h\\,\\omega^2 x_n$, $x_{n+1}=x_n+h\\,p_{n+1}$.\nLet $\\mathcal{C}_0$ be a closed convex polygon in the $(x,p)$ phase plane with $M$ vertices $\\{(x_j(0),p_j(0))\\}_{j=0}^{M-1}$ ordered counterclockwise, given by\n$$\nx_j(0)=R\\cos\\theta_j,\\quad p_j(0)=R\\sin\\theta_j,\\quad \\theta_j=\\dfrac{2\\pi j}{M},\n$$\nfor $j\\in\\{0,1,\\dots,M-1\\}$, with all angles measured in radians. All quantities are dimensionless.\n\nFor a given map $\\mathcal{M}\\in\\{\\mathcal{F},\\mathcal{S}\\}$ and a positive integer $N$, define $\\mathcal{C}_N$ as the polygon obtained by applying $N$ successive steps of $\\mathcal{M}$ to each vertex of $\\mathcal{C}_0$, preserving vertex order. Define the polygonal area functional\n$$\nA[\\mathcal{C}]=\\dfrac{1}{2}\\left|\\sum_{j=0}^{M-1}\\left(x_j\\,p_{j+1}-x_{j+1}\\,p_j\\right)\\right|,\n$$\nwith cyclic indexing $x_M\\equiv x_0$ and $p_M\\equiv p_0$. For each test case below, compute the area ratio $A[\\mathcal{C}_N]/A[\\mathcal{C}_0]$ for $\\mathcal{M}=\\mathcal{F}$ and for $\\mathcal{M}=\\mathcal{S}$.\n\nUse the following test suite of parameter sets $(\\omega,h,N,M,R)$:\n- Test $1$: $(\\omega,h,N,M,R)=\\left(1,\\,0.1,\\,100,\\,128,\\,1\\right)$.\n- Test $2$: $(\\omega,h,N,M,R)=\\left(1,\\,0.5,\\,20,\\,128,\\,1\\right)$.\n- Test $3$: $(\\omega,h,N,M,R)=\\left(2,\\,0.1,\\,100,\\,128,\\,1\\right)$.\n- Test $4$: $(\\omega,h,N,M,R)=\\left(1,\\,0.01,\\,1000,\\,128,\\,1\\right)$.\n\nYour program must produce, for each test in the order listed, two floating-point numbers: first the area ratio for map $\\mathcal{F}$, then the area ratio for map $\\mathcal{S}$. Round each number to $6$ decimal places. The final output must be a single line containing a comma-separated list enclosed in square brackets with all results in order, that is,\n$$\n\\left[\\rho^{(\\mathcal{F})}_1,\\rho^{(\\mathcal{S})}_1,\\rho^{(\\mathcal{F})}_2,\\rho^{(\\mathcal{S})}_2,\\rho^{(\\mathcal{F})}_3,\\rho^{(\\mathcal{S})}_3,\\rho^{(\\mathcal{F})}_4,\\rho^{(\\mathcal{S})}_4\\right],\n$$\nwhere $\\rho^{(\\mathcal{M})}_i=A[\\mathcal{C}_N]/A[\\mathcal{C}_0]$ for the $i$-th test case and map $\\mathcal{M}$. No physical units are involved in this problem, and all angles must be in radians.",
            "solution": "The problem asks for the ratio of phase-space areas of a polygon evolved under two different numerical integration schemes for the harmonic oscillator. A direct simulation of each of the $M$ vertices for $N$ time steps is a valid but computationally inefficient approach. A more insightful solution is found by analyzing the algebraic properties of the maps.\n\nLet the state of the system in phase space be represented by the vector $z = (x, p)^T$. The Hamiltonian equations of motion are $\\dot{x} = \\partial H / \\partial p = p/m$ and $\\dot{p} = -\\partial H / \\partial x = -kx$. With $m=1$ and $k=\\omega^2$, we have $\\dot{z} = A z$ where $A = \\begin{pmatrix} 0 & 1 \\\\ -\\omega^2 & 0 \\end{pmatrix}$. The maps $\\mathcal{F}$ and $\\mathcal{S}$ are discrete approximations to the flow of this linear system.\n\nBoth maps, $\\mathcal{F}$ and $\\mathcal{S}$, are linear transformations from the state $(x_n, p_n)$ at time step $n$ to the state $(x_{n+1}, p_{n+1})$ at step $n+1$. We can express them in matrix form, $z_{n+1} = M z_n$.\n\nFor map $\\mathcal{F}$ (explicit forward Euler):\n$$\n\\begin{cases}\nx_{n+1} = x_n + h\\,p_n \\\\\np_{n+1} = p_n - h\\,\\omega^2 x_n\n\\end{cases}\n\\implies\n\\begin{pmatrix} x_{n+1} \\\\ p_{n+1} \\end{pmatrix} =\n\\begin{pmatrix} 1 & h \\\\ -h\\omega^2 & 1 \\end{pmatrix}\n\\begin{pmatrix} x_n \\\\ p_n \\end{pmatrix}\n$$\nThe one-step evolution matrix is thus $M_{\\mathcal{F}} = \\begin{pmatrix} 1 & h \\\\ -h\\omega^2 & 1 \\end{pmatrix}$.\n\nFor map $\\mathcal{S}$ (semi-implicit Euler):\n$$\n\\begin{cases}\np_{n+1} = p_n - h\\,\\omega^2 x_n \\\\\nx_{n+1} = x_n + h\\,p_{n+1} = x_n + h(p_n - h\\omega^2 x_n) = (1-h^2\\omega^2)x_n + h p_n\n\\end{cases}\n$$\n$$\n\\implies\n\\begin{pmatrix} x_{n+1} \\\\ p_{n+1} \\end{pmatrix} =\n\\begin{pmatrix} 1-h^2\\omega^2 & h \\\\ -h\\omega^2 & 1 \\end{pmatrix}\n\\begin{pmatrix} x_n \\\\ p_n \\end{pmatrix}\n$$\nThe one-step evolution matrix is $M_{\\mathcal{S}} = \\begin{pmatrix} 1-h^2\\omega^2 & h \\\\ -h\\omega^2 & 1 \\end{pmatrix}$.\n\nAfter $N$ steps, the transformation from the initial state $z_0$ to the final state $z_N$ is given by $z_N = (M_{\\mathcal{M}})^N z_0$, where $\\mathcal{M} \\in \\{\\mathcal{F}, \\mathcal{S}\\}$. This is a linear transformation, let us call its matrix $T = (M_{\\mathcal{M}})^N$.\n\nThe area of a polygon $\\mathcal{C}$ with vertices $\\{(x_j, p_j)\\}_{j=0}^{M-1}$ is given by the shoelace formula:\n$$\nA[\\mathcal{C}]=\\dfrac{1}{2}\\left|\\sum_{j=0}^{M-1}\\left(x_j\\,p_{j+1}-x_{j+1}\\,p_j\\right)\\right|\n$$\nWhen a polygon is subjected to a linear transformation with matrix $T$, its area $A$ is transformed to $A' = |\\det(T)| A$.\nIn our case, the vertices $\\{z_j(0)\\}$ of the initial polygon $\\mathcal{C}_0$ are transformed into the vertices $\\{z_j(N) = T z_j(0)\\}$ of the final polygon $\\mathcal{C}_N$. Therefore, the area of the final polygon is $A[\\mathcal{C}_N] = |\\det(T)| A[\\mathcal{C}_0]$.\n\nThe required area ratio is:\n$$\n\\dfrac{A[\\mathcal{C}_N]}{A[\\mathcal{C}_0]} = |\\det(T)| = |\\det((M_{\\mathcal{M}})^N)| = |\\det(M_{\\mathcal{M}})|^N\n$$\nThis result is independent of the specific geometry of the initial polygon, i.e., the parameters $M$ and $R$ are irrelevant to the final ratio. We only need to compute the determinants of the one-step matrices.\n\nFor map $\\mathcal{F}$:\n$$\n\\det(M_{\\mathcal{F}}) = (1)(1) - (h)(-h\\omega^2) = 1 + h^2\\omega^2\n$$\nThe area ratio is $\\rho^{(\\mathcal{F})} = (1 + h^2\\omega^2)^N$. Since $h > 0$ and $\\omega > 0$, this value is always greater than $1$, indicating that the area grows exponentially. This map is not symplectic.\n\nFor map $\\mathcal{S}$:\n$$\n\\det(M_{\\mathcal{S}}) = (1-h^2\\omega^2)(1) - (h)(-h\\omega^2) = 1 - h^2\\omega^2 + h^2\\omega^2 = 1\n$$\nThe area ratio is $\\rho^{(\\mathcal{S})} = (1)^N = 1$. This map preserves the phase-space area exactly for any choice of parameters and is therefore a symplectic map.\n\nWe now apply these formulas to the given test cases.\n\nTest $1$: $(\\omega,h,N,M,R)=\\left(1,\\,0.1,\\,100,\\,128,\\,1\\right)$\n$\\rho^{(\\mathcal{F})} = (1 + (0.1)^2(1)^2)^{100} = (1.01)^{100} \\approx 2.704814$\n$\\rho^{(\\mathcal{S})} = 1.0$\n\nTest $2$: $(\\omega,h,N,M,R)=\\left(1,\\,0.5,\\,20,\\,128,\\,1\\right)$\n$\\rho^{(\\mathcal{F})} = (1 + (0.5)^2(1)^2)^{20} = (1.25)^{20} \\approx 86.736174$\n$\\rho^{(\\mathcal{S})} = 1.0$\n\nTest $3$: $(\\omega,h,N,M,R)=\\left(2,\\,0.1,\\,100,\\,128,\\,1\\right)$\n$\\rho^{(\\mathcal{F})} = (1 + (0.1)^2(2)^2)^{100} = (1.04)^{100} \\approx 50.504948$\n$\\rho^{(\\mathcal{S})} = 1.0$\n\nTest $4$: $(\\omega,h,N,M,R)=\\left(1,\\,0.01,\\,1000,\\,128,\\,1\\right)$\n$\\rho^{(\\mathcal{F})} = (1 + (0.01)^2(1)^2)^{1000} = (1.0001)^{1000} \\approx 1.105116$\n$\\rho^{(\\mathcal{S})} = 1.0$\n\nThese calculations will be implemented in the provided program structure.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by analytically calculating the area ratios for the two maps.\n    The area ratio for a polygon under a linear map T is given by |det(T)|.\n    For N steps, the transformation is T = M^N, where M is the one-step matrix.\n    The area ratio is |det(M^N)| = |det(M)|^N.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each test case is a tuple: (omega, h, N, M, R)\n    test_cases = [\n        (1.0, 0.1, 100, 128, 1.0),\n        (1.0, 0.5, 20, 128, 1.0),\n        (2.0, 0.1, 100, 128, 1.0),\n        (1.0, 0.01, 1000, 128, 1.0),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        omega, h, N, M, R = case\n\n        # --- Map F (Explicit Euler) ---\n        # The one-step matrix M_F has determinant det(M_F) = 1 + h^2 * omega^2.\n        # The area ratio after N steps is (det(M_F))^N.\n        det_M_F = 1.0 + h**2 * omega**2\n        rho_F = np.power(det_M_F, N)\n\n        # --- Map S (Symplectic Euler) ---\n        # The one-step matrix M_S has determinant det(M_S) = 1.\n        # The area ratio after N steps is (det(M_S))^N = 1^N = 1.\n        rho_S = 1.0\n\n        # Append the rounded results for the current test case.\n        results.append(round(rho_F, 6))\n        results.append(round(rho_S, 6))\n\n    # Final print statement in the exact required format.\n    # The output is a single line, comma-separated list of numbers in brackets.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "Real-world physics simulations often involve complex systems with many degrees of freedom. This final practice challenges you to build a practical and flexible tool: a d-dimensional symplectic integrator for any system with a separable Hamiltonian of the form $H(\\mathbf{q},\\mathbf{p})=T(\\mathbf{p})+V(\\mathbf{q})$. You will implement the robust \"kick-drift-kick\" leapfrog algorithm and use it to investigate one of the most celebrated features of symplectic methods: their excellent long-term energy conservation, which manifests as bounded energy fluctuations rather than a systematic drift over long simulation times .",
            "id": "2444622",
            "problem": "Develop a program that advances canonical variables in an arbitrary number of spatial dimensions using a symplectic integrator for separable Hamiltonian systems. The Hamiltonian is defined as $H(\\mathbf{q},\\mathbf{p})=T(\\mathbf{p})+V(\\mathbf{q})$, where $\\mathbf{q}\\in\\mathbb{R}^{d}$ and $\\mathbf{p}\\in\\mathbb{R}^{d}$ denote the generalized coordinates and momenta, respectively, and $d$ is a positive integer. The kinetic energy is given by $T(\\mathbf{p})=\\sum_{i=1}^{d}\\dfrac{p_{i}^{2}}{2m_{i}}$ with strictly positive masses $\\{m_{i}\\}_{i=1}^{d}$, and the potential energy $V(\\mathbf{q})$ depends only on $\\mathbf{q}$. The evolution is governed by Hamilton’s equations $\\dot{\\mathbf{q}}=\\dfrac{\\partial H}{\\partial \\mathbf{p}},\\ \\dot{\\mathbf{p}}=-\\dfrac{\\partial H}{\\partial \\mathbf{q}}$. Use dimensionless units. The program must accept, as parameters in code, the dimension $d$, the masses $\\{m_{i}\\}_{i=1}^{d}$, an initial state $(\\mathbf{q}_{0},\\mathbf{p}_{0})$, a time step $h>0$, a number of time steps $N\\ge 0$, and a specification of the potential $V(\\mathbf{q})$ and its gradient $\\nabla V(\\mathbf{q})$. For each test case below, integrate the system from time $t=0$ to time $t=Nh$ and compute the relative Hamiltonian drift defined by\n$$\\Delta_{\\mathrm{rel}}=\\dfrac{H(\\mathbf{q}_{N},\\mathbf{p}_{N})-H(\\mathbf{q}_{0},\\mathbf{p}_{0})}{H(\\mathbf{q}_{0},\\mathbf{p}_{0})}.$$\nAll quantities are dimensionless; no physical units are to be reported. Angles, where present implicitly within potential definitions, are to be interpreted in radians. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[\\text{result}_{1},\\text{result}_{2},\\text{result}_{3}]$), in the order of the test cases provided below.\n\nTest Suite:\n- Test A (one-dimensional harmonic oscillator): $d=1$, $m_{1}=1$, $V(q)=\\dfrac{1}{2}\\,q^{2}$, initial condition $q_{0}=1$, $p_{0}=0$, time step $h=0.1$, number of steps $N=1000$.\n- Test B (two-dimensional anisotropic oscillator with distinct masses): $d=2$, $(m_{1},m_{2})=(1,2)$, $V(q_{1},q_{2})=\\dfrac{1}{2}\\left(\\omega_{1}^{2}q_{1}^{2}+\\omega_{2}^{2}q_{2}^{2}\\right)$ with $(\\omega_{1},\\omega_{2})=(1,1.5)$, initial condition $(q_{1,0},q_{2,0})=(1,0.5)$, $(p_{1,0},p_{2,0})=(0,1)$, time step $h=0.05$, number of steps $N=2000$.\n- Test C (three-dimensional weakly coupled anharmonic potential): $d=3$, $(m_{1},m_{2},m_{3})=(1,1,1)$, $V(q_{1},q_{2},q_{3})=\\dfrac{1}{2}\\,\\omega^{2}\\left(q_{1}^{2}+q_{2}^{2}+q_{3}^{2}\\right)+\\lambda\\,q_{1}q_{2}q_{3}$ with $\\omega=0.7$ and $\\lambda=0.1$, initial condition $(q_{1,0},q_{2,0},q_{3,0})=(0.2,-0.1,0.15)$, $(p_{1,0},p_{2,0},p_{3,0})=(0,0.05,-0.02)$, time step $h=0.01$, number of steps $N=5000$.\n- Test D (five-dimensional quartic potential, boundary condition with zero steps): $d=5$, $m_{i}=1$ for $i\\in\\{1,2,3,4,5\\}$, $V(\\mathbf{q})=\\dfrac{1}{4}\\sum_{i=1}^{5}q_{i}^{4}$, initial condition $\\mathbf{q}_{0}=(0.1,-0.2,0.3,-0.4,0.5)$, $\\mathbf{p}_{0}=(0.2,0.1,-0.1,0,-0.3)$, time step $h=0.2$, number of steps $N=0$.\n- Test E (one-dimensional harmonic oscillator near the linear stability limit): $d=1$, $m_{1}=1$, $V(q)=\\dfrac{1}{2}\\,q^{2}$, initial condition $q_{0}=1$, $p_{0}=0$, time step $h=1.9$, number of steps $N=100$.\n\nFor each test case, report the single float $\\Delta_{\\mathrm{rel}}$ as defined above. The final output must be a single line in the format $[\\Delta_{\\mathrm{rel}}^{(A)},\\Delta_{\\mathrm{rel}}^{(B)},\\Delta_{\\mathrm{rel}}^{(C)},\\Delta_{\\mathrm{rel}}^{(D)},\\Delta_{\\mathrm{rel}}^{(E)}]$ with no additional whitespace.",
            "solution": "The problem statement is critically examined and found to be valid. It is a well-posed problem in computational physics, grounded in the established principles of Hamiltonian mechanics and its numerical treatment. All required data and conditions are provided, and there are no scientific or logical inconsistencies.\n\nThe system is described by a separable Hamiltonian of the form $H(\\mathbf{q},\\mathbf{p}) = T(\\mathbf{p}) + V(\\mathbf{q})$, where $\\mathbf{q} \\in \\mathbb{R}^{d}$ and $\\mathbf{p} \\in \\mathbb{R}^{d}$ are the generalized coordinates and momenta, respectively. The kinetic energy is $T(\\mathbf{p}) = \\sum_{i=1}^{d} \\frac{p_{i}^{2}}{2m_{i}}$ and the potential energy $V(\\mathbf{q})$ depends solely on the coordinates. The time evolution of the system is governed by Hamilton's equations:\n$$\n\\dot{\\mathbf{q}} = \\frac{\\partial H}{\\partial \\mathbf{p}} = \\nabla_{\\mathbf{p}}T(\\mathbf{p})\n$$\n$$\n\\dot{\\mathbf{p}} = -\\frac{\\partial H}{\\partial \\mathbf{q}} = -\\nabla_{\\mathbf{q}}V(\\mathbf{q})\n$$\nFor the given kinetic energy, these equations become $\\dot{q}_{i} = p_{i}/m_{i}$ and $\\dot{p}_{i} = -(\\nabla V(\\mathbf{q}))_{i}$.\n\nTo solve these equations numerically, we must employ an integrator that respects the underlying structure of Hamiltonian dynamics. Symplectic integrators are designed for this purpose. They preserve the phase-space volume element $d\\mathbf{q} \\wedge d\\mathbf{p}$ and exhibit excellent long-term energy conservation properties, characterized by bounded oscillations of the numerical energy around the true conserved value.\n\nFor a separable Hamiltonian, we can construct a symplectic integrator by splitting the evolution operator. The formal solution to Hamilton's equations over a time step $h$ is given by $Z(t+h) = e^{h\\hat{L}_H} Z(t)$, where $Z = (\\mathbf{q}, \\mathbf{p})$ is the state vector and $\\hat{L}_H = \\{ \\cdot, H \\}$ is the Liouvillian operator corresponding to the Hamiltonian $H$. The separability of $H$ implies that $\\hat{L}_H = \\hat{L}_T + \\hat{L}_V$, where $\\hat{L}_T$ and $\\hat{L}_V$ are the operators for the kinetic and potential parts, respectively.\n\nSince $\\hat{L}_T$ and $\\hat{L}_V$ do not commute, we use a symmetric splitting, such as the Strang splitting, to construct a second-order accurate integrator:\n$$\ne^{h\\hat{L}_H} \\approx e^{\\frac{h}{2}\\hat{L}_V} e^{h\\hat{L}_T} e^{\\frac{h}{2}\\hat{L}_V}\n$$\nThis operator sequence translates into a concrete algorithm known as the leapfrog integrator, specifically in its \"kick-drift-kick\" (KDK) form. A single step from time $t_n$ to $t_{n+1} = t_n + h$ proceeds as follows:\n\n$1$. **First Kick (half-step):** Update the momenta based on the force at the current position. This corresponds to the action of $e^{\\frac{h}{2}\\hat{L}_V}$. The evolution under $\\hat{L}_V$ alone corresponds to $\\dot{\\mathbf{q}}=0, \\dot{\\mathbf{p}} = -\\nabla V(\\mathbf{q})$.\n$$\n\\mathbf{p}_{n+1/2} = \\mathbf{p}_n - \\frac{h}{2} \\nabla V(\\mathbf{q}_n)\n$$\n\n$2$. **Drift (full-step):** Update the positions using the new intermediate momenta. This corresponds to the action of $e^{h\\hat{L}_T}$. The evolution under $\\hat{L}_T$ alone corresponds to $\\dot{\\mathbf{q}}=\\mathbf{p}/M, \\dot{\\mathbf{p}}=0$, where $M$ is the diagonal mass matrix.\n$$\n\\mathbf{q}_{n+1} = \\mathbf{q}_n + h M^{-1}\\mathbf{p}_{n+1/2}\n$$\n\n$3$. **Second Kick (half-step):** Update the momenta again, this time using the force at the *new* position $\\mathbf{q}_{n+1}$. This is the second application of $e^{\\frac{h}{2}\\hat{L}_V}$.\n$$\n\\mathbf{p}_{n+1} = \\mathbf{p}_{n+1/2} - \\frac{h}{2} \\nabla V(\\mathbf{q}_{n+1})\n$$\n\nThis three-step sequence advances the state from $(\\mathbf{q}_n, \\mathbf{p}_n)$ to $(\\mathbf{q}_{n+1}, \\mathbf{p}_{n+1})$. The process is repeated $N$ times to integrate the system up to time $T = Nh$.\n\nFor evaluation, we calculate the initial Hamiltonian $H_0 = H(\\mathbf{q}_0, \\mathbf{p}_0)$ and the final Hamiltonian $H_N = H(\\mathbf{q}_N, \\mathbf{p}_N)$. The relative Hamiltonian drift is then computed as $\\Delta_{\\mathrm{rel}} = (H_N - H_0) / H_0$. For the case where $N=0$, no integration is performed, so $(\\mathbf{q}_N, \\mathbf{p}_N) = (\\mathbf{q}_0, \\mathbf{p}_0)$ and $\\Delta_{\\mathrm{rel}}$ is trivially $0$.\n\nThe implementation will handle arbitrary dimensionality $d$ by representing $\\mathbf{q}$, $\\mathbf{p}$, and $\\mathbf{m}$ as `numpy` arrays, which allows for efficient vectorized operations. Each test case will be configured with its specific potential function $V(\\mathbf{q})$, its gradient $\\nabla V(\\mathbf{q})$, and its set of physical and numerical parameters.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n\n    def leapfrog_integrate(q0, p0, masses, h, N, grad_V):\n        \"\"\"\n        Advances canonical variables using the leapfrog (KDK) symplectic integrator.\n\n        Args:\n            q0 (np.ndarray): Initial positions.\n            p0 (np.ndarray): Initial momenta.\n            masses (np.ndarray): Particle masses.\n            h (float): Time step.\n            N (int): Number of steps.\n            grad_V (callable): Function for the gradient of the potential, grad_V(q).\n\n        Returns:\n            tuple: Final positions and momenta (q_N, p_N).\n        \"\"\"\n        if N == 0:\n            return q0, p0\n\n        q = q0.copy()\n        p = p0.copy()\n        inv_masses = 1.0 / masses\n\n        for _ in range(N):\n            # Kick (half-step)\n            p -= (h / 2.0) * grad_V(q)\n            # Drift (full-step)\n            q += h * p * inv_masses\n            # Kick (half-step)\n            p -= (h / 2.0) * grad_V(q)\n        \n        return q, p\n\n    def get_hamiltonian(q, p, masses, V_func):\n        \"\"\"Calculates the Hamiltonian of the system.\"\"\"\n        T = np.sum(p**2 / (2.0 * masses))\n        V = V_func(q)\n        return T + V\n\n    test_cases = [\n        # Test A: 1D harmonic oscillator\n        {\n            \"d\": 1,\n            \"masses\": np.array([1.0]),\n            \"q0\": np.array([1.0]),\n            \"p0\": np.array([0.0]),\n            \"h\": 0.1,\n            \"N\": 1000,\n            \"V\": lambda q: 0.5 * q[0]**2,\n            \"grad_V\": lambda q: q,\n        },\n        # Test B: 2D anisotropic oscillator\n        {\n            \"d\": 2,\n            \"masses\": np.array([1.0, 2.0]),\n            \"q0\": np.array([1.0, 0.5]),\n            \"p0\": np.array([0.0, 1.0]),\n            \"h\": 0.05,\n            \"N\": 2000,\n            \"V\": lambda q: 0.5 * np.sum((np.array([1.0, 1.5]) * q)**2),\n            \"grad_V\": lambda q: np.array([1.0, 1.5])**2 * q,\n        },\n        # Test C: 3D weakly coupled anharmonic potential\n        {\n            \"d\": 3,\n            \"masses\": np.array([1.0, 1.0, 1.0]),\n            \"q0\": np.array([0.2, -0.1, 0.15]),\n            \"p0\": np.array([0.0, 0.05, -0.02]),\n            \"h\": 0.01,\n            \"N\": 5000,\n            \"V\": lambda q: (0.5 * 0.7**2 * np.sum(q**2)) + (0.1 * q[0] * q[1] * q[2]),\n            \"grad_V\": lambda q: (0.7**2 * q) + (0.1 * np.array([q[1]*q[2], q[0]*q[2], q[0]*q[1]])),\n        },\n        # Test D: 5D quartic potential, N=0\n        {\n            \"d\": 5,\n            \"masses\": np.array([1.0, 1.0, 1.0, 1.0, 1.0]),\n            \"q0\": np.array([0.1, -0.2, 0.3, -0.4, 0.5]),\n            \"p0\": np.array([0.2, 0.1, -0.1, 0.0, -0.3]),\n            \"h\": 0.2,\n            \"N\": 0,\n            \"V\": lambda q: 0.25 * np.sum(q**4),\n            \"grad_V\": lambda q: q**3,\n        },\n        # Test E: 1D harmonic oscillator near stability limit\n        {\n            \"d\": 1,\n            \"masses\": np.array([1.0]),\n            \"q0\": np.array([1.0]),\n            \"p0\": np.array([0.0]),\n            \"h\": 1.9,\n            \"N\": 100,\n            \"V\": lambda q: 0.5 * q[0]**2,\n            \"grad_V\": lambda q: q,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        # Define parameters for the current case\n        q0 = case[\"q0\"].astype(np.float64)\n        p0 = case[\"p0\"].astype(np.float64)\n        masses = case[\"masses\"].astype(np.float64)\n        h = float(case[\"h\"])\n        N = int(case[\"N\"])\n        V_func = case[\"V\"]\n        grad_V_func = case[\"grad_V\"]\n\n        # Calculate initial Hamiltonian\n        H0 = get_hamiltonian(q0, p0, masses, V_func)\n\n        # Run the integrator\n        qN, pN = leapfrog_integrate(q0, p0, masses, h, N, grad_V_func)\n\n        # Calculate final Hamiltonian\n        HN = get_hamiltonian(qN, pN, masses, V_func)\n\n        # Calculate relative Hamiltonian drift\n        # If H0 is zero, drift is undefined. Handle this case if it arises.\n        if H0 == 0.0:\n            # If HN is also 0, drift is 0. Otherwise, it's infinite.\n            # In this problem set, H0 is never zero, but this is robust.\n            delta_rel = 0.0 if HN == 0.0 else np.inf\n        else:\n            delta_rel = (HN - H0) / H0\n        \n        results.append(delta_rel)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}