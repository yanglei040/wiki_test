{
    "hands_on_practices": [
        {
            "introduction": "理论是一回事，但算法的真正考验在于实践。对于像天体物理学中那样需要长期模拟的保守系统，并非所有数值方法都能胜任。本练习将让时间可逆的辛积分器（速度-Verlet算法）与一个高阶但非辛的主力方法（四阶龙格-库塔法）在一场经典的轨道模拟中展开对决，目的是亲眼见证哪种方法能够在成千上万个轨道周期中更好地遵守能量守恒这一定律。",
            "id": "2446756",
            "problem": "实现并比较两种用于平面内牛顿二体运动的数值积分器，一种是时间可逆且辛的（速度Verlet），另一种是显式的四阶但非时间可逆的（四阶龙格—库塔法(RK4)）。考虑一个质量为 $m=1\\ \\mathrm{kg}$ 的测试粒子，在一个固定的中心天体的引力场中运动，该中心天体的标准引力参数为 $\\mu = G M = 1.32712440018\\times 10^{20}\\ \\mathrm{m^3/s^2}$。运动方程为以下一阶系统：\n$$\n\\dot{\\mathbf{r}}(t) = \\mathbf{v}(t),\\qquad \\dot{\\mathbf{v}}(t) = -\\frac{\\mu}{\\|\\mathbf{r}(t)\\|^3}\\,\\mathbf{r}(t),\n$$\n其总比机械能为\n$$\nE(t) = \\frac{1}{2}\\,\\|\\mathbf{v}(t)\\|^2 - \\frac{\\mu}{\\|\\mathbf{r}(t)\\|},\n$$\n在连续动力学中，该能量是精确守恒的。使用初始位置 $\\mathbf{r}_0 = (r_0,0)$（其中 $r_0 = 1.495978707\\times 10^{11}\\ \\mathrm{m}$）和初始速度 $\\mathbf{v}_0 = (0, v_{\\mathrm{init}})$（如各测试用例中所指定）。半径为 $r_0$ 的圆形轨道的速度为 $v_{\\mathrm{circ}} = \\sqrt{\\mu/r_0}$。\n\n对下述的每个测试用例，使用两种积分器在二维空间中模拟该运动。对于每次模拟，以大小为 $\\Delta t$ 的均匀时间步长推进，直至总时间 $T$。将步数定义为 $N=\\left\\lfloor T/\\Delta t \\right\\rfloor$，并精确推进 $N$ 步。按如下公式计算比能的绝对相对漂移：\n$$\n\\varepsilon = \\left|\\frac{E_N - E_0}{|E_0|}\\right|,\n$$\n其中 $E_0$ 是初始比能，$E_N$ 是 $N$ 步后的比能。报告速度 Verlet 和四阶龙格—库塔 (RK4) 两种方法的 $\\varepsilon$ 值。\n\n全程使用国际单位制（SI），距离单位为 $\\mathrm{m}$，时间单位为 $\\mathrm{s}$，能量单位为 $\\mathrm{J/kg}$（比能）。角度（如果在内部出现）应以弧度为单位。最终输出为无量纲数。\n\n测试套件：\n- 用例 1（圆形轨道，小步长）：$v_{\\mathrm{init}} = v_{\\mathrm{circ}}$，$\\Delta t = 86400\\ \\mathrm{s}$，$T = 50\\times 365.25\\times 86400\\ \\mathrm{s}$。\n- 用例 2（圆形轨道，大步长）：$v_{\\mathrm{init}} = v_{\\mathrm{circ}}$，$\\Delta t = 5\\times 86400\\ \\mathrm{s}$，$T = 200\\times 365.25\\times 86400\\ \\mathrm{s}$。\n- 用例 3（椭圆轨道，较大偏心率）：$v_{\\mathrm{init}} = 0.7\\, v_{\\mathrm{circ}}$，$\\Delta t = 86400\\ \\mathrm{s}$，$T = 100\\times 365.25\\times 86400\\ \\mathrm{s}$。\n\n您的程序必须产生单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，六个数字按以下顺序排列：$[\\varepsilon_{\\mathrm{Verlet,1}}, \\varepsilon_{\\mathrm{RK4,1}}, \\varepsilon_{\\mathrm{Verlet,2}}, \\varepsilon_{\\mathrm{RK4,2}}, \\varepsilon_{\\mathrm{Verlet,3}}, \\varepsilon_{\\mathrm{RK4,3}}]$。每个数字用标准浮点表示法表示；也接受科学记数法。结果为无量纲实数。",
            "solution": "该问题陈述已经过严格验证，被认为是具有科学依据、适定且客观的。它是计算物理学和天体力学中的一个标准练习，所有必要的参数和条件都已明确指定。其中没有逻辑不一致、事实错误或含糊之处。因此，我们将着手提供一个完整的解决方案。\n\n该问题要求实现并比较两种用于平面内经典牛顿二体问题的数值积分方案。所考虑的系统是一个测试粒子绕一个固定的中心质量体运行。其动力学由以下一阶常微分方程组控制：\n$$\n\\dot{\\mathbf{r}}(t) = \\mathbf{v}(t)\n$$\n$$\n\\dot{\\mathbf{v}}(t) = \\mathbf{a}(\\mathbf{r}(t)) = -\\frac{\\mu}{\\|\\mathbf{r}(t)\\|^3}\\,\\mathbf{r}(t)\n$$\n此处，$\\mathbf{r}(t)$ 是位置矢量，$\\mathbf{v}(t)$ 是速度矢量，$\\mu$ 是中心天体的标准引力参数。在精确的连续动力学中，一个关键的守恒量是比机械能：\n$$\nE = \\frac{1}{2}\\,\\|\\mathbf{v}\\|^2 - \\frac{\\mu}{\\|\\mathbf{r}\\|}\n$$\n数值积分器不会精确地使这个量守恒。我们的目标是量化两种不同方法的数值误差：速度 Verlet 算法和经典的四阶龙格—库塔法。经过 $N$ 个积分步后，误差通过绝对相对能量漂移 $\\varepsilon = \\left|\\frac{E_N - E_0}{|E_0|}\\right|$ 来衡量。\n\n让我们将离散时间点定义为 $t_n = n \\Delta t$，其中 $\\Delta t$ 是恒定的时间步长。系统在时间 $t_n$ 的状态为 $(\\mathbf{r}_n, \\mathbf{v}_n)$。\n\n**1. 速度 Verlet 积分器**\n\n速度 Verlet 算法是几何积分器家族的一员。它被专门设计为辛的和时间可逆的，这使得它对于如此处所考虑的哈密顿系统具有出色的长期稳定性。它不精确守恒能量，但能量误差保持有界，并在初始值附近振荡，不显示长期漂移（secular drift）。该算法具有二阶精度。\n\n给定状态 $(\\mathbf{r}_n, \\mathbf{v}_n)$，计算 $(\\mathbf{r}_{n+1}, \\mathbf{v}_{n+1})$ 的一个速度 Verlet 算法步骤如下：\n1.  计算当前位置的加速度：$\\mathbf{a}_n = \\mathbf{a}(\\mathbf{r}_n)$。\n2.  将速度更新半步：$\\mathbf{v}_{n+1/2} = \\mathbf{v}_n + \\frac{\\Delta t}{2} \\mathbf{a}_n$。\n3.  使用此中间速度将位置更新一整步：$\\mathbf{r}_{n+1} = \\mathbf{r}_n + \\Delta t \\, \\mathbf{v}_{n+1/2}$。\n4.  计算新位置的加速度：$\\mathbf{a}_{n+1} = \\mathbf{a}(\\mathbf{r}_{n+1})$。\n5.  将速度更新剩余的半步：$\\mathbf{v}_{n+1} = \\mathbf{v}_{n+1/2} + \\frac{\\Delta t}{2} \\mathbf{a}_{n+1}$。\n\n为了实现，这些步骤通常组合成以下形式：\n$$\n\\mathbf{r}_{n+1} = \\mathbf{r}_n + \\mathbf{v}_n \\Delta t + \\frac{1}{2} \\mathbf{a}(\\mathbf{r}_n) \\Delta t^2\n$$\n$$\n\\mathbf{v}_{n+1} = \\mathbf{v}_n + \\frac{1}{2} (\\mathbf{a}(\\mathbf{r}_n) + \\mathbf{a}(\\mathbf{r}_{n+1})) \\Delta t\n$$\n\n**2. 四阶龙格—库塔 (RK4) 积分器**\n\n经典的四阶龙格—库塔法是一种广泛使用的显式积分器，以其在给定步长下的高精度而闻名。其局部截断误差为 $O(\\Delta t^5)$ 阶，全局误差为 $O(\\Delta t^4)$ 阶。然而，RK4 不是辛的。因此，对于哈密顿系统，它通常会引入能量的系统性或长期（secular）漂移，这种漂移会随着长时间的积分而累积。\n\n对于我们的系统 $\\dot{\\mathbf{r}}=\\mathbf{v}$ 和 $\\dot{\\mathbf{v}}=\\mathbf{a}(\\mathbf{r})$，我们定义状态向量 $\\mathbf{y} = (\\mathbf{r}, \\mathbf{v})$ 和函数 $\\mathbf{f}(\\mathbf{y}) = (\\mathbf{v}, \\mathbf{a}(\\mathbf{r}))$。从 $\\mathbf{y}_n$ 到 $\\mathbf{y}_{n+1}$ 的 RK4 更新为：\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{\\Delta t}{6} (\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n$$\n中间阶段 $\\mathbf{k}_i = (\\mathbf{k}_{ri}, \\mathbf{k}_{vi})$（其中 $i=1, 2, 3, 4$）的计算如下：\n- 阶段 1：\n$$ \\mathbf{k}_{r1} = \\mathbf{v}_n \\qquad \\mathbf{k}_{v1} = \\mathbf{a}(\\mathbf{r}_n) $$\n- 阶段 2：\n$$ \\mathbf{k}_{r2} = \\mathbf{v}_n + \\frac{\\Delta t}{2} \\mathbf{k}_{v1} \\qquad \\mathbf{k}_{v2} = \\mathbf{a}\\left(\\mathbf{r}_n + \\frac{\\Delta t}{2} \\mathbf{k}_{r1}\\right) $$\n- 阶段 3：\n$$ \\mathbf{k}_{r3} = \\mathbf{v}_n + \\frac{\\Delta t}{2} \\mathbf{k}_{v2} \\qquad \\mathbf{k}_{v3} = \\mathbf{a}\\left(\\mathbf{r}_n + \\frac{\\Delta t}{2} \\mathbf{k}_{r2}\\right) $$\n- 阶段 4：\n$$ \\mathbf{k}_{r4} = \\mathbf{v}_n + \\Delta t \\, \\mathbf{k}_{v3} \\qquad \\mathbf{k}_{v4} = \\mathbf{a}\\left(\\mathbf{r}_n + \\Delta t \\, \\mathbf{k}_{r3}\\right) $$\n然后通过组合这些阶段来计算位置和速度的最终更新：\n$$\n\\mathbf{r}_{n+1} = \\mathbf{r}_n + \\frac{\\Delta t}{6} (\\mathbf{k}_{r1} + 2\\mathbf{k}_{r2} + 2\\mathbf{k}_{r3} + \\mathbf{k}_{r4})\n$$\n$$\n\\mathbf{v}_{n+1} = \\mathbf{v}_n + \\frac{\\Delta t}{6} (\\mathbf{k}_{v1} + 2\\mathbf{k}_{v2} + 2\\mathbf{k}_{v3} + \\mathbf{k}_{v4})\n$$\n\n**3. 测试用例的执行**\n\n对于每个指定的测试用例，我们执行以下步骤：\n1.  确定物理和模拟参数：$\\mu = 1.32712440018 \\times 10^{20}\\ \\mathrm{m^3/s^2}$，$r_0 = 1.495978707 \\times 10^{11}\\ \\mathrm{m}$，以及针对特定用例的 $v_{\\mathrm{init}}$、$\\Delta t$ 和 $T$ 的值。\n2.  计算圆形轨道速度 $v_{\\mathrm{circ}} = \\sqrt{\\mu/r_0}$ 和初始速度 $\\mathbf{v}_0 = (0, v_{\\mathrm{init}})$。初始位置为 $\\mathbf{r}_0 = (r_0, 0)$。\n3.  计算初始比能 $E_0 = E(\\mathbf{r}_0, \\mathbf{v}_0)$。对于束缚轨道，有 $E_0  0$。\n4.  确定积分步数 $N = \\lfloor T/\\Delta t \\rfloor$。\n5.  运行两个独立的模拟，一个使用速度 Verlet，另一个使用 RK4。每个模拟都从 $(\\mathbf{r}_0, \\mathbf{v}_0)$ 开始，并精确运行 $N$ 步。\n6.  经过 $N$ 步后，获得最终状态 $(\\mathbf{r}_{N,\\text{Verlet}}, \\mathbf{v}_{N,\\text{Verlet}})$ 和 $(\\mathbf{r}_{N,\\text{RK4}}, \\mathbf{v}_{N,\\text{RK4}})$。\n7.  计算最终能量 $E_{N,\\text{Verlet}}$ 和 $E_{N,\\text{RK4}}$。\n8.  为每种方法计算绝对相对能量漂移 $\\varepsilon$ 并存储结果。\n\n该比较将凸显辛积分器和非辛积分器在哈密顿系统的长期模拟中的根本差异。预计速度 Verlet 积分器将在多个轨道周期内表现出卓越的能量守恒特性，即使其局部误差比 RK4 更大；而 RK4 的高阶精度可能会因能量中长期误差的累积而被削弱。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and compares Velocity Verlet and RK4 integrators for the\n    Newtonian two-body problem, reporting the relative energy drift.\n    \"\"\"\n    # Physical and astronomical constants\n    MU_SUN = 1.32712440018e20  # Standard gravitational parameter of the Sun (m^3/s^2)\n    R0_EARTH = 1.495978707e11   # 1 Astronomical Unit (m)\n    DAY_S = 86400.0            # Seconds in one mean solar day\n    YEAR_S = 365.25 * DAY_S    # Seconds in one Julian year\n\n    # --- Core Physics and Numerical Functions ---\n\n    def acceleration(r_vec):\n        \"\"\"Computes gravitational acceleration vector.\"\"\"\n        dist = np.linalg.norm(r_vec)\n        if dist == 0:\n            # Avoid division by zero at the singularity, though it should not be reached.\n            return np.zeros_like(r_vec)\n        return -MU_SUN * r_vec / dist**3\n\n    def specific_energy(r_vec, v_vec):\n        \"\"\"Computes specific mechanical energy.\"\"\"\n        dist = np.linalg.norm(r_vec)\n        if dist == 0:\n            return np.inf\n        return 0.5 * np.dot(v_vec, v_vec) - MU_SUN / dist\n\n    def velocity_verlet_step(r, v, dt):\n        \"\"\"Performs a single step of the Velocity Verlet integration.\"\"\"\n        a_current = acceleration(r)\n        r_new = r + v * dt + 0.5 * a_current * dt**2\n        a_new = acceleration(r_new)\n        v_new = v + 0.5 * (a_current + a_new) * dt\n        return r_new, v_new\n\n    def rk4_step(r, v, dt):\n        \"\"\"Performs a single step of the RK4 integration.\"\"\"\n        # k1\n        k1_r = v\n        k1_v = acceleration(r)\n\n        # k2\n        r2 = r + 0.5 * dt * k1_r\n        k2_r = v + 0.5 * dt * k1_v\n        k2_v = acceleration(r2)\n\n        # k3\n        r3 = r + 0.5 * dt * k2_r\n        k3_r = v + 0.5 * dt * k2_v\n        k3_v = acceleration(r3)\n\n        # k4\n        r4 = r + dt * k3_r\n        k4_r = v + dt * k3_v\n        k4_v = acceleration(r4)\n\n        # Combine stages\n        r_new = r + (dt / 6.0) * (k1_r + 2*k2_r + 2*k3_r + k4_r)\n        v_new = v + (dt / 6.0) * (k1_v + 2*k2_v + 2*k3_v + k4_v)\n        return r_new, v_new\n\n    # --- Test Suite Setup ---\n    v_circ = np.sqrt(MU_SUN / R0_EARTH)\n\n    test_cases = [\n        # Case 1 (circular, fine step)\n        {'v_init_factor': 1.0, 'dt': 1.0 * DAY_S, 'T': 50.0 * YEAR_S},\n        # Case 2 (circular, coarse step)\n        {'v_init_factor': 1.0, 'dt': 5.0 * DAY_S, 'T': 200.0 * YEAR_S},\n        # Case 3 (elliptical, more eccentric)\n        {'v_init_factor': 0.7, 'dt': 1.0 * DAY_S, 'T': 100.0 * YEAR_S},\n    ]\n\n    results = []\n\n    for case in test_cases:\n        # --- Simulation Setup for the current case ---\n        v_init = case['v_init_factor'] * v_circ\n        dt = case['dt']\n        T = case['T']\n        \n        # Initial conditions\n        r0 = np.array([R0_EARTH, 0.0])\n        v0 = np.array([0.0, v_init])\n        \n        num_steps = int(T / dt) # As per problem spec: N = floor(T/dt)\n        \n        # Initial energy\n        E0 = specific_energy(r0, v0)\n\n        # --- Velocity Verlet Simulation ---\n        r_v, v_v = r0.copy(), v0.copy()\n        for _ in range(num_steps):\n            r_v, v_v = velocity_verlet_step(r_v, v_v, dt)\n        \n        E_N_verlet = specific_energy(r_v, v_v)\n        epsilon_verlet = abs((E_N_verlet - E0) / E0)\n        results.append(epsilon_verlet)\n        \n        # --- RK4 Simulation ---\n        r_rk, v_rk = r0.copy(), v0.copy()\n        for _ in range(num_steps):\n            r_rk, v_rk = rk4_step(r_rk, v_rk, dt)\n\n        E_N_rk4 = specific_energy(r_rk, v_rk)\n        epsilon_rk4 = abs((E_N_rk4 - E0) / E0)\n        results.append(epsilon_rk4)\n\n    # --- Final Output ---\n    # Convert results to string representation for printing\n    result_str = [f\"{res:.10e}\" for res in results]\n    print(f\"[{','.join(result_str)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在见证了Verlet算法的威力之后，我们现在将目光聚焦于一个微妙但至关重要的实现细节。位置-Verlet算法的递推关系需要一个特殊的第一步来“引导”启动，一个不恰当的选择可能会破坏该方法出色的长期稳定性。本练习将通过比较不同的引导技术对轨道精度和能量守恒的影响，揭示从第一步开始就维持积分器数学结构完整性的重要性。",
            "id": "2446800",
            "problem": "构建一个完整的、可运行的程序，用于比较在使用时间可逆的位置 Verlet 积分器传播一维经典谐振子时，第一步构建（引导）方法的选择如何影响其长期数值轨迹。考虑一个质量为 $m$ 的质点在势 $V(x) = \\tfrac{1}{2} k x^{2}$ 中运动，因此其加速度为 $a(x) = -\\tfrac{k}{m} x$。精确的角频率为 $\\omega = \\sqrt{\\tfrac{k}{m}}$，对于初始条件 $x(0)=x_{0}$ 和 $v(0)=v_{0}$，其精确解为\n$$\nx_{\\mathrm{exact}}(t) = x_{0} \\cos(\\omega t) + \\frac{v_{0}}{\\omega} \\sin(\\omega t),\n\\qquad\nv_{\\mathrm{exact}}(t) = -x_{0}\\,\\omega \\sin(\\omega t) + v_{0} \\cos(\\omega t).\n$$\n所有角度必须以弧度为单位。所有物理量必须使用国际单位制（SI）表示：位置单位为米，速度单位为米/秒，质量单位为千克，刚度单位为牛顿/米，时间单位为秒。时刻 $t$ 的机械能为\n$$\nE(t) = \\tfrac{1}{2} m\\, v(t)^{2} + \\tfrac{1}{2} k\\, x(t)^{2}.\n$$\n对于具有固定时间步长 $\\Delta t$ 的离散时间 $t_{n} = n\\,\\Delta t$，使用位置 Verlet 递推关系：\n$$\nx_{n+1} = 2\\,x_{n} - x_{n-1} + a(x_{n})\\,(\\Delta t)^{2}, \\quad \\text{其中 } a(x_{n}) = -\\frac{k}{m}\\,x_{n}.\n$$\n此更新在给定 $x_{0}$ 和 $v_{0}$ 的情况下需要计算第一步的 $x_{1}$。请比较以下两种第一步构建方法：\n- 欧拉引导法：$x_{1}^{\\mathrm{E}} = x_{0} + v_{0}\\,\\Delta t$。\n- 二阶泰勒引导法：$x_{1}^{\\mathrm{T}} = x_{0} + v_{0}\\,\\Delta t + \\tfrac{1}{2}\\,a(x_{0})\\,(\\Delta t)^{2}$。\n\n对于一组给定的参数，使用每种引导方法模拟 $N$ 步至时间 $T = N\\,\\Delta t$，并为每种引导方法计算以下两个无量纲诊断指标：\n- 最终相对位置误差，定义为\n$$\n\\varepsilon_{x} = \\frac{\\left|x_{N} - x_{\\mathrm{exact}}(T)\\right|}{A}, \\quad \\text{其中 } A = \\sqrt{x_{0}^{2} + \\left(\\frac{v_{0}}{\\omega}\\right)^{2}}.\n$$\n- 整个轨迹上的最大相对能量偏差，定义为\n$$\n\\varepsilon_{E}^{\\max} = \\max_{1 \\le n \\le N-1} \\frac{\\left|E_{n} - E_{0}\\right|}{E_{0}},\n$$\n其中 $E_{0} = \\tfrac{1}{2} m\\, v_{0}^{2} + \\tfrac{1}{2} k\\, x_{0}^{2}$ 且 $E_{n} = \\tfrac{1}{2} m\\, v_{n}^{2} + \\tfrac{1}{2} k\\, x_{n}^{2}$，$v_{n}$ 对于 $1 \\le n \\le N-1$ 通过中心有限差分 $v_{n} = \\dfrac{x_{n+1} - x_{n-1}}{2\\,\\Delta t}$ 获得。如果 $E_{0} = 0$，则定义 $\\varepsilon_{E}^{\\max} = 0$。\n\n你的程序必须实现此设置，并为以下参数集测试套件生成结果，每个参数均以国际单位制（SI）表示：\n- 测试集 A（理想路径）：$m = 1$, $k = 1$, $x_{0} = 1$, $v_{0} = 0$, $\\Delta t = 0.1$, $N = 10000$。\n- 测试集 B（离散格式的近稳定性边界）：$m = 1$, $k = 25$, $x_{0} = 1$, $v_{0} = 0.5$, $\\Delta t = 0.39$, $N = 8000$。\n- 测试集 C（纯动能起始）：$m = 1$, $k = 1$, $x_{0} = 0$, $v_{0} = 1$, $\\Delta t = 0.05$, $N = 20000$。\n\n对于每个测试集，按以下顺序输出一个包含四个数字的列表：\n$[\\varepsilon_{x}^{\\mathrm{E}}, \\varepsilon_{x}^{\\mathrm{T}}, \\varepsilon_{E,\\mathrm{E}}^{\\max}, \\varepsilon_{E,\\mathrm{T}}^{\\max}]$，其中上标 $\\mathrm{E}$ 和 $\\mathrm{T}$ 分别指代欧拉和泰勒引导法。\n最终的程序输出必须是单行文本，包含所有三个测试集的结果，格式为这些列表的逗号分隔列表，不含空格，例如：\n$[[a_{1},a_{2},a_{3},a_{4}],[b_{1},b_{2},b_{3},b_{4}],[c_{1},c_{2},c_{3},c_{4}]]$.\n每个数字必须以至少 6 位有效数字的小数形式打印。所有报告的诊断指标都是无量纲的，必须以小数形式打印（不要使用百分号）。",
            "solution": "问题陈述已经过验证，被认定为科学上合理、问题定义明确且无歧义。它构成了计算物理学中的一个标准练习，适合进行严谨的分析。我们现在开始解答。\n\n该问题要求对应用于一维谐振子的位置 Verlet 积分器的两种引导方法进行比较研究。该系统由一个质量为 $m$ 的物体在势 $V(x) = \\frac{1}{2} k x^2$ 中定义，其运动方程为 $\\ddot{x} = -\\frac{k}{m} x$。该动力学系统的特征是其固有角频率 $\\omega = \\sqrt{k/m}$。\n\n位置 Verlet 算法是一种二阶、时间可逆且辛的积分器。其对于离散时间步 $t_n = n \\Delta t$ 的递推关系由下式给出\n$$\nx_{n+1} = 2 x_n - x_{n-1} + a(x_n) (\\Delta t)^2,\n$$\n其中 $x_n \\approx x(t_n)$ 且 $a(x_n) = -\\frac{k}{m} x_n$ 是在位置 $x_n$ 处的加速度。这是一个三项递推关系，意味着计算第 $n+1$ 步的位置 $x_{n+1}$ 需要前两步的位置 $x_n$ 和 $x_{n-1}$。为启动积分过程，我们在 $t=0$ 时给定初始状态 $(x_0, v_0)$。由此我们得到 $x_0$，但要开始对 $n \\ge 1$ 的迭代过程，我们需要一个 $x_1$ 的值。$x_1$ 的选择即为引导问题。\n\n问题提出了两种确定 $x_1$ 的方法：\n\n1.  **欧拉引导法**：$x_1^{\\mathrm{E}} = x_0 + v_0 \\Delta t$。这是对位置的一阶前向欧拉步。\n2.  **二阶泰勒引导法**：$x_1^{\\mathrm{T}} = x_0 + v_0 \\Delta t + \\frac{1}{2} a(x_0) (\\Delta t)^2$。这对应于位置 $x(\\Delta t)$ 的二阶泰勒级数展开。\n\nVerlet 积分器的理论基础在于围绕时间 $t_n$ 的两个泰勒级数展开式的和：\n$$\nx(t_n + \\Delta t) = x(t_n) + \\dot{x}(t_n)\\Delta t + \\frac{1}{2}\\ddot{x}(t_n)(\\Delta t)^2 + \\frac{1}{6}\\dddot{x}(t_n)(\\Delta t)^3 + \\mathcal{O}((\\Delta t)^4)\n$$\n$$\nx(t_n - \\Delta t) = x(t_n) - \\dot{x}(t_n)\\Delta t + \\frac{1}{2}\\ddot{x}(t_n)(\\Delta t)^2 - \\frac{1}{6}\\dddot{x}(t_n)(\\Delta t)^3 + \\mathcal{O}((\\Delta t)^4)\n$$\n将这两个方程相加可以消除奇次幂的导数项，得到：\n$$\nx(t_n + \\Delta t) + x(t_n - \\Delta t) = 2x(t_n) + \\ddot{x}(t_n)(\\Delta t)^2 + \\mathcal{O}((\\Delta t)^4)\n$$\n将 $x_{n \\pm 1}$ 对应于 $x(t_n \\pm \\Delta t)$ 并将 $a(x_n)$ 对应于 $\\ddot{x}(t_n)$，我们便恢复了位置 Verlet 公式。该方法的局部截断误差为 $\\mathcal{O}((\\Delta t)^4)$，从而导致全局误差为 $\\mathcal{O}((\\Delta t)^2)$。\n\n至关重要的是，该推导揭示了方法的准确性及其理想特性（如时间可逆性）都依赖于这种对称结构。必须谨慎选择引导步骤，以免破坏此结构。\n\n用于 $x_1$ 的二阶泰勒引导法，\n$$\nx_1^\\mathrm{T} = x_0 + v_0 \\Delta t + \\frac{1}{2}a(x_0)(\\Delta t)^2,\n$$\n是直接从 $x(\\Delta t)$ 的二阶泰勒展开式推导出来的。这与 Verlet 积分器本身的阶数相一致。\n\n相比之下，欧拉引导法，\n$$\nx_1^\\mathrm{E} = x_0 + v_0 \\Delta t,\n$$\n仅为一阶近似。它在第一步就引入了量级为 $\\frac{1}{2}a(x_0)(\\Delta t)^2$ 的误差。这个初始误差的阶数低于与积分器相一致的阶数，它会在整个模拟过程中传播，并预计会降低整体准确性，尤其是长期的能量守恒性。Verlet 方法因其出色的长期能量稳定性而备受推崇（数值能量不会系统性漂移，而是在真实值附近振荡）。不一致的引导法会破坏这一特性。\n\n对于初始位置在平衡点 $x_0=0$ 的特殊情况，初始加速度也为零，$a(x_0)=0$。在这种情况下，项 $\\frac{1}{2} a(x_0) (\\Delta t)^2$ 为零，两种引导方法将产生相同的结果：$x_1^{\\mathrm{E}} = x_1^{\\mathrm{T}} = v_0 \\Delta t$。因此，对于 $x_0=0$ 的测试集 C，两种引导方法的数值轨迹和所有派生的诊断指标必须完全相同。\n\n实现将按以下步骤进行：将构建一个通用函数，使用位置 Verlet 算法传播轨迹 $N$ 步。此函数将接受物理参数（$m, k, x_0, v_0, \\Delta t, N$）和一个用于选择引导方法的标志。对于三个测试集中的每一个，此模拟将运行两次，每种引导方法各运行一次。\n\n在每次生成位置轨迹 $\\{x_n\\}_{n=0}^N$ 的模拟运行之后，将计算所需的诊断指标。\n- 最终相对位置误差 $\\varepsilon_x$ 需要计算在时间 $T = N \\Delta t$ 时的精确位置，该位置由 $x_{\\mathrm{exact}}(T) = x_0 \\cos(\\omega T) + \\frac{v_0}{\\omega} \\sin(\\omega T)$ 给出，以及振幅 $A = \\sqrt{x_0^2 + (v_0/\\omega)^2}$。误差则为 $\\varepsilon_x = |x_N - x_{\\mathrm{exact}}(T)| / A$。\n- 最大相对能量偏差 $\\varepsilon_E^{\\max}$ 需要计算在 $n \\in [1, N-1]$ 范围内的数值速度 $v_n$ 和能量 $E_n$。速度使用中心差分公式 $v_n = \\frac{x_{n+1} - x_{n-1}}{2 \\Delta t}$ 计算，这与 Verlet 方案的时间可逆性相一致。每一步的能量为 $E_n = \\frac{1}{2}mv_n^2 + \\frac{1}{2}kx_n^2$。然后通过取轨迹上 $|E_n - E_0|/E_0$ 的最大值来得到该诊断指标，其中 $E_0 = \\frac{1}{2}mv_0^2 + \\frac{1}{2}kx_0^2$。\n\n每个测试集的这些计算结果将按照指定格式进行格式化和呈现。预期的结果是，泰勒引导法将始终产生更小的误差，尤其是在能量偏差方面，除了像测试集 C 那样两种方法在数学上等效的情况。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run simulations for all test cases and print results.\n    \"\"\"\n\n    # Test cases are defined as tuples: (m, k, x0, v0, dt, N)\n    test_cases = [\n        # Test set A (happy path)\n        (1.0, 1.0, 1.0, 0.0, 0.1, 10000),\n        # Test set B (near-stability edge)\n        (1.0, 25.0, 1.0, 0.5, 0.39, 8000),\n        # Test set C (purely kinetic start)\n        (1.0, 1.0, 0.0, 1.0, 0.05, 20000),\n    ]\n\n    all_results = []\n    for params in test_cases:\n        m, k, x0, v0, dt, N = params\n        \n        # Run with Euler bootstrap\n        x_euler = propagate_trajectory(m, k, x0, v0, dt, N, 'euler')\n        eps_x_euler, eps_E_max_euler = compute_diagnostics(m, k, x0, v0, dt, N, x_euler)\n\n        # Run with Taylor bootstrap\n        x_taylor = propagate_trajectory(m, k, x0, v0, dt, N, 'taylor')\n        eps_x_taylor, eps_E_max_taylor = compute_diagnostics(m, k, x0, v0, dt, N, x_taylor)\n        \n        case_results = [eps_x_euler, eps_x_taylor, eps_E_max_euler, eps_E_max_taylor]\n        all_results.append(case_results)\n\n    # Format the final output string as specified\n    formatted_case_results = []\n    for res_list in all_results:\n        # Use scientific notation to ensure at least 6 significant digits\n        formatted_list = [f\"{v:.15e}\" for v in res_list]\n        formatted_case_results.append(f\"[{','.join(formatted_list)}]\")\n    \n    final_output = f\"[{','.join(formatted_case_results)}]\"\n    print(final_output)\n\ndef propagate_trajectory(m, k, x0, v0, dt, N, bootstrap_method):\n    \"\"\"\n    Generates a trajectory using the position Verlet integrator.\n\n    Args:\n        m (float): Mass.\n        k (float): Spring constant.\n        x0 (float): Initial position.\n        v0 (float): Initial velocity.\n        dt (float): Time step.\n        N (int): Number of steps.\n        bootstrap_method (str): 'euler' or 'taylor'.\n\n    Returns:\n        np.array: Array of positions [x_0, x_1, ..., x_N].\n    \"\"\"\n    x = np.zeros(N + 1)\n    x[0] = x0\n    \n    # Acceleration function\n    accel_factor = -k / m\n    def a(pos):\n        return accel_factor * pos\n\n    # First step (bootstrapping)\n    if bootstrap_method == 'euler':\n        x[1] = x0 + v0 * dt\n    elif bootstrap_method == 'taylor':\n        a0 = a(x0)\n        x[1] = x0 + v0 * dt + 0.5 * a0 * dt**2\n    else:\n        raise ValueError(\"Invalid bootstrap method specified.\")\n\n    # Main integration loop\n    dt_sq = dt**2\n    for n in range(1, N):\n        x[n+1] = 2 * x[n] - x[n-1] + a(x[n]) * dt_sq\n        \n    return x\n\ndef compute_diagnostics(m, k, x0, v0, dt, N, x_trajectory):\n    \"\"\"\n    Computes final position error and max energy deviation.\n\n    Args:\n        m (float): Mass.\n        k (float): Spring constant.\n        x0 (float): Initial position.\n        v0 (float): Initial velocity.\n        dt (float): Time step.\n        N (int): Number of steps.\n        x_trajectory (np.array): Position trajectory.\n\n    Returns:\n        tuple: (eps_x, eps_E_max)\n    \"\"\"\n    omega = np.sqrt(k / m)\n\n    # 1. Final relative position error (eps_x)\n    T = N * dt\n    x_exact_T = x0 * np.cos(omega * T) + (v0 / omega) * np.sin(omega * T)\n    \n    amp_sq_term_v = v0 / omega\n    amplitude = np.sqrt(x0**2 + amp_sq_term_v**2)\n    \n    x_N = x_trajectory[N]\n    \n    if amplitude == 0.0:\n        # Trivial case: x0=0, v0=0. System is static.\n        eps_x = 0.0\n    else:\n        eps_x = np.abs(x_N - x_exact_T) / amplitude\n\n    # 2. Maximum relative energy deviation (eps_E_max)\n    E0 = 0.5 * m * v0**2 + 0.5 * k * x0**2\n    \n    if E0 == 0.0:\n        return eps_x, 0.0\n\n    max_rel_E_dev = 0.0\n    # Loop from n=1 to N-1\n    for n in range(1, N):\n        # Centered difference for velocity v_n\n        v_n = (x_trajectory[n+1] - x_trajectory[n-1]) / (2 * dt)\n        \n        # Energy E_n\n        E_n = 0.5 * m * v_n**2 + 0.5 * k * x_trajectory[n]**2\n        \n        rel_E_dev = np.abs(E_n - E0) / E0\n        if rel_E_dev > max_rel_E_dev:\n            max_rel_E_dev = rel_E_dev\n            \n    eps_E_max = max_rel_E_dev\n    \n    return eps_x, eps_E_max\n\nsolve()\n\n```"
        },
        {
            "introduction": "最后的这个练习是一个至关重要的警示故事：即使是优越的算法也有其局限性。在这里，我们将研究时间步长 $\\Delta t$ 的选择如何与系统的固有频率发生“数值共振”，导致即使是稳定的Verlet积分器也会产生灾难性的、非物理的结果。这个练习旨在教授计算物理学中一个关键的教训：理解所选算法的稳定域与算法本身同样重要。",
            "id": "2446795",
            "problem": "设计并实现一个完整的程序，该程序针对哈密顿量为 $H(x,p)=\\dfrac{p^2}{2m}+\\dfrac{1}{2}m\\omega^2 x^2$ 的一维经典谐振子，检测会降低时间可逆积分器性能的离散时间步长共振。请使用无量纲单位，设 $m=1$，并以不带物理单位的形式表示所有量。角度和角频率必须以弧度为单位，时间单位与角频率的单位相同，也为无量纲单位（因此 $\\omega$ 的单位是弧度/单位时间）。该谐振子遵循哈密顿方程 $\\dot{x}=p/m$ 和 $\\dot{p}=-m\\omega^2 x$。\n\n为了在不同实现中产生一致且可测试的结果，请在均匀时间网格 $t_n=n\\,\\Delta t$ 上演化系统，并使用以下关于位置的时间可逆二阶差分方程：\n$$\nx_{n+1}=2x_n-x_{n-1}-(\\omega\\Delta t)^2\\,x_n,\n$$\n初始数据在 $t_0=0$ 时指定为 $x_0=x(0)$ 和 $v_0=\\dot{x}(0)$。通过以下方式初始化序列：\n$$\nx_1=x_0+\\Delta t\\,v_0-\\tfrac{1}{2}(\\omega\\Delta t)^2\\,x_0.\n$$\n在每个网格索引 $n\\ge 1$ 处，通过中心差分定义离散速度：\n$$\nv_n=\\frac{x_{n+1}-x_{n-1}}{2\\Delta t}.\n$$\n定义索引 $n$ 处的离散能量为：\n$$\nE_n=\\dfrac{1}{2}v_n^2+\\dfrac{1}{2}\\omega^2 x_n^2,\n$$\n并通过精确的初始值定义参考能量 $E_0$：\n$$\nE_0=\\dfrac{1}{2}v_0^2+\\dfrac{1}{2}\\omega^2 x_0^2.\n$$\n对于固定的最终时间 $T_{\\mathrm{final}}$，将序列推进到满足 $N\\,\\Delta t\\le T_{\\mathrm{final}}$ 的最大整数索引 $N$。在索引 $n=1,2,\\ldots,N-1$ 上，测量最大相对能量偏差：\n$$\n\\varepsilon_{\\max}=\\max_{1\\le n\\le N-1}\\frac{|E_n-E_0|}{E_0}.\n$$\n为了稳健地检测由时间步长共振引起的数值不稳定性，请采用以下发散约定：如果在任何步骤 $n$ 中，大小 $|x_n|$ 超过 $10^6$，则终止积分，并报告标量值 $10^6$ 作为该测试用例的 $\\varepsilon_{\\max}$。\n\n您的程序必须为以下测试套件评估 $\\varepsilon_{\\max}$，该套件固定了谐振子参数，仅改变时间步长：\n- 自然频率 $\\omega=1$。\n- 初始条件 $x_0=1$ 和 $v_0=0$。\n- 最终时间 $T_{\\mathrm{final}}=200\\cdot 2\\pi$。\n- 时间步长 $\\Delta t$ 在集合 $\\{\\;0.1,\\;1.0,\\;1.9,\\;2.0,\\;2.1\\;\\}$ 中。\n\n您的程序应产生单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，结果的顺序与所列时间步长的顺序相对应。每个列出的数字必须是十进制浮点值，四舍五入到 $6$ 位有效数字，并根据需要使用定点或科学记数法。对于触发发散约定的情况，请按规定输出四舍五入到 $6$ 位有效数字的 $10^6$。输出格式必须严格为\n[res_0,res_1,res_2,res_3,res_4]\n不含空格，且顺序与上述时间步长相同。",
            "solution": "问题陈述是有效的。这是一个在计算物理学中提法恰当、有科学依据的练习，它研究了用于经典谐振子的时间可逆积分器的数值稳定性。所有参数、方程和评估标准都以足够的清晰度和精确度给出，从而能够得到唯一且可验证的解。\n\n所考虑的系统是一个一维谐振子，其哈密顿量为 $H(x,p)=\\dfrac{p^2}{2m}+\\dfrac{1}{2}m\\omega^2 x^2$。在无量纲单位且质量 $m=1$ 的情况下，哈密顿方程简化为 $\\dot{x}=p$ 和 $\\dot{p}=-\\omega^2 x$，它们结合起来得到标准的二阶常微分方程 $\\ddot{x} + \\omega^2 x = 0$。\n\n数值积分方案由时间 $t_n = n\\Delta t$ 处位置 $x_n$ 的二阶差分方程指定：\n$$\nx_{n+1}=2x_n-x_{n-1}-(\\omega\\Delta t)^2\\,x_n\n$$\n这是一种标准的显式、时间可逆积分器，称为 Størmer-Verlet 方法（位置 Verlet 形式）。它的主要优点是对一个伪哈密顿量的优异的长期守恒性，这使得稳定振荡的能量误差有界，这与像 Runge-Kutta 这样的非辛方法经常表现出的长期漂移形成对比。\n\n这个线性差分格式的稳定性至关重要。我们可以通过代入 $x_n = z^n$ 形式的试探解来分析它，这会得到特征方程：\n$$\nz^2 - \\left(2 - (\\omega\\Delta t)^2\\right) z + 1 = 0\n$$\n为使数值解保持有界，这个二次方程的根 $z$ 必须位于复平面的单位圆上，也就是 $|z|=1$。根由下式给出：\n$$\nz_{\\pm} = \\frac{\\left(2 - (\\omega\\Delta t)^2\\right) \\pm \\sqrt{\\left(2 - (\\omega\\Delta t)^2\\right)^2 - 4}}{2}\n$$\n条件 $|z|=1$ 要求判别式为非正：\n$$\n\\left(2 - (\\omega\\Delta t)^2\\right)^2 - 4 \\le 0 \\implies -2 \\le 2 - (\\omega\\Delta t)^2 \\le 2\n$$\n这可以简化为 $(\\omega\\Delta t)^2 \\le 4$，即 Verlet 方法著名的稳定性条件：\n$$\n|\\omega \\Delta t| \\le 2\n$$\n当 $|\\omega \\Delta t| > 2$ 时，其中一个根的模大于1，导致数值解指数发散。$|\\omega \\Delta t| = 2$ 的情况是数值共振。此时，特征方程在 $z=-1$ 处有一个二重根，通解的形式为 $x_n = (A + Bn)(-1)^n$，预示着振幅会线性增长。\n\n问题要求对 $\\omega=1$ 和几个不同的 $\\Delta t$ 值进行评估：\n1.  $\\Delta t \\in \\{0.1, 1.0, 1.9\\}$：在这里，$|\\omega \\Delta t|  2$，所以积分处于稳定区域。我们预期离散能量 $E_n$ 会有有界的振荡误差。随着 $\\Delta t$ 的增大，这个误差的幅度预计会增长。\n2.  $\\Delta t = 2.0$：在这里，$|\\omega \\Delta t| = 2$，这是共振条件。然而，给定的特定初始化方法 $x_1=x_0+\\Delta t\\,v_0-\\tfrac{1}{2}(\\omega\\Delta t)^2\\,x_0$，结合初始条件 $x_0=1, v_0=0$，导致结果为 $x_1 = 1 - \\frac{1}{2}(1 \\cdot 2)^2(1) = 1-2 = -1$。随后的序列变为 $x_n = (-1)^n$。对于这个特殊的非一般性轨迹，离散速度 $v_n = (x_{n+1}-x_{n-1})/(2\\Delta t)$ 始终为零，离散能量 $E_n$ 始终精确地等于初始能量 $E_0$。因此，最大相对能量偏差 $\\varepsilon_{\\max}$ 将精确为零。\n3.  $\\Delta t = 2.1$：在这里，$|\\omega \\Delta t| > 2$，所以积分是不稳定的。位置 $x_n$ 将会指数级增长，并且模拟预计会因触发发散条件 $|x_n| > 10^6$ 而终止。\n\n解决方案是通过直接转换给定算法来实现的。对于每个指定的 $\\Delta t$，过程如下：\n- 使用给定参数初始化系统：$\\omega=1, x_0=1, v_0=0$。\n- 计算总步数 $N = \\lfloor T_{\\mathrm{final}} / \\Delta t \\rfloor$，其中 $T_{\\mathrm{final}}=400\\pi$。\n- 计算参考能量 $E_0 = \\frac{1}{2}v_0^2+\\frac{1}{2}\\omega^2 x_0^2 = 0.5$。\n- 根据问题说明初始化前两个位置 $x_0$ 和 $x_1$。\n- 从 $n=1$ 迭代到 $N-1$：\n    - 使用 Verlet 更新规则计算下一个位置 $x_{n+1}$。\n    - 检查是否发散。如果 $|x_n| > 10^6$，则此 $\\Delta t$ 的误差设置为 $10^6$，并终止该情况的模拟。\n    - 使用中心差分公式计算离散速度 $v_n$。\n    - 计算离散能量 $E_n$。\n    - 更新到目前为止观察到的最大相对能量偏差 $\\varepsilon_{\\max}$。\n    - 为下一次迭代更新位置。\n- 存储当前 $\\Delta t$ 的 $\\varepsilon_{\\max}$ 最终值。\n然后按要求格式化最终结果列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef format_num(n):\n    \"\"\"\n    Formats a number to 6 significant figures, with special handling\n    for the divergence value 1.0e6 to ensure it is represented\n    with 6 significant figures in scientific notation.\n    \"\"\"\n    if n == 1.0e6:\n        return \"1.00000e+06\"\n    return f\"{n:.6g}\"\n\ndef solve():\n    \"\"\"\n    Solves the problem of detecting time-step resonance for a harmonic oscillator\n    integrated with the Størmer-Verlet method.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [0.1, 1.0, 1.9, 2.0, 2.1]\n\n    # Fixed parameters for the oscillator\n    omega = 1.0\n    x0 = 1.0\n    v0 = 0.0\n    T_final = 200.0 * 2.0 * np.pi\n    divergence_threshold = 1.0e6\n\n    results = []\n\n    # Calculate exact initial energy\n    E0 = 0.5 * v0**2 + 0.5 * omega**2 * x0**2\n    # Prevent division by zero if E0 is zero, although not the case here.\n    if E0 == 0:\n        E0 = 1.0 \n\n    for dt in test_cases:\n        # Determine the total number of steps\n        N = int(T_final / dt)\n\n        # Initialize variables for the simulation\n        max_rel_err = 0.0\n        diverged = False\n\n        # Set initial positions\n        x_prev = x0\n        \n        # Calculate x1 using the specified second-order initialization\n        wdt2 = (omega * dt)**2\n        x_curr = x0 + dt * v0 - 0.5 * wdt2 * x0\n\n        # Time-stepping loop from n=1 to N-1 to compute E_n up to E_{N-1}\n        for n in range(1, N):\n            # Check for divergence\n            if abs(x_curr) > divergence_threshold:\n                max_rel_err = divergence_threshold\n                diverged = True\n                break\n            \n            # Calculate next position using the Verlet update rule\n            x_next = (2.0 - wdt2) * x_curr - x_prev\n            \n            # Calculate discrete velocity and energy at step n\n            # v_n is defined by the centered difference at time t_n\n            v_n = (x_next - x_prev) / (2.0 * dt)\n            E_n = 0.5 * v_n**2 + 0.5 * omega**2 * x_curr**2\n            \n            # Calculate relative energy deviation and update the maximum\n            rel_err = abs(E_n - E0) / E0\n            if rel_err > max_rel_err:\n                max_rel_err = rel_err\n            \n            # Update positions for the next step\n            x_prev = x_curr\n            x_curr = x_next\n        \n        if not diverged and N > 0 and abs(x_curr) > divergence_threshold:\n            # Final check in case the last computed step diverged\n            max_rel_err = divergence_threshold\n\n        results.append(max_rel_err)\n\n    # Format results to 6 significant figures\n    formatted_results = [format_num(r) for r in results]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}