{
    "hands_on_practices": [
        {
            "introduction": "副本交换蒙特卡洛方法的有效性取决于副本在整个温度阶梯上穿梭的速度。这个扩散过程可以被描述为一个马尔可夫链，其基本的收敛速率由其转移矩阵的本征值谱决定。本练习  深入探讨了这一概念，要求您构建副本移动的转移矩阵并计算其弛豫时间，从而为温度阶梯的混合效率提供一个深刻的定量度量。",
            "id": "2434344",
            "problem": "考虑一个在逆温阶梯上进行的副本交换蒙特卡洛（REMC）过程。一个单独的标记副本占据 $K$ 个离散逆温能级中的一个，能级由 $i \\in \\{0,1,\\dots,K-1\\}$ 索引，并与逆温 $\\{\\beta_0,\\beta_1,\\dots,\\beta_{K-1}\\}$ 相关联，其中每个 $\\beta_i$ 都是一个正实数。时间是离散的，步长为单位尺寸（无量纲）。在每一步中，从 $K-1$ 个可能的相邻对中均匀随机地选择一个相邻对 $(m,m+1)$，并提议交换这两个能级上的副本。与当前处于这两个能级的两个副本相关联的能量 $E_m$ 和 $E_{m+1}$ 是独立的随机变量，分别从其各自逆温下的正则系综中抽取。对于经典的单自由度谐振子，在逆温 $\\beta$ 下的正则能量分布是指数分布，其密度函数为：当 $E\\ge 0$ 时，$f(E;\\beta)=\\beta e^{-\\beta E}$，否则为零。该交换以 Metropolis 准则给出的概率被接受，$p_{\\text{acc}}=\\min\\{1,\\exp[(\\beta_m-\\beta_{m+1})(E_m-E_{m+1})]\\}$. 仅当所选的相邻对包含其当前能级时，标记副本的状态才会演化；否则它将保持在当前能级。通过对相关逆温下的能量分布进行单步动力学平均，定义标记副本的马尔可夫链的 $K\\times K$ 转移矩阵 $P$。也就是说，对于每个相邻对 $(i,i+1)$，非对角线元 $P_{i,i+1}$ 和 $P_{i+1,i}$ 是该对的选择概率与交换这两个能级的 Metropolis 接受概率的期望值（相对于正则能量分布）的乘积，并且设置每个对角线元以使 $P$ 的每一行之和为 $1$。对于下面测试套件中指定的每个逆温列表，构建转移矩阵 $P$，计算 $P$ 的完整本征谱，然后提取以下三个量：(1) 实数本征值 $\\lambda_\\star$，其绝对值是严格小于 $1$ 的最大值；(2) 绝对值 $r_\\star=|\\lambda_\\star|$；以及 (3) 相关的离散时间 e-折弛豫时间 $\\tau_\\star=-1/\\ln(r_\\star)$（无量纲，因为时间是以步数计算的）。报告每个测试用例的所有三个量，四舍五入到六位小数。如果存在由数值舍入引起的任何歧义，则将虚部绝对值小于 $10^{-10}$ 的任何复本征值通过取其实部视为实数。要使用的测试套件是：\n- 测试用例 A: $K=2$, $\\boldsymbol{\\beta}=[1.0,\\,0.3]$.\n- 测试用例 B: $K=2$, $\\boldsymbol{\\beta}=[1.0,\\,0.9]$.\n- 测试用例 C: $K=5$, $\\boldsymbol{\\beta}=[1.5,\\,1.1,\\,0.85,\\,0.66,\\,0.5]$.\n- 测试用例 D: $K=4$, $\\boldsymbol{\\beta}=[1.0,\\,1.0,\\,1.0,\\,1.0]$.\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个元素本身是一个包含三个浮点数 $[\\lambda_\\star,r_\\star,\\tau_\\star]$ 的列表，顺序与测试套件相同，例如 $[[\\lambda_\\star^{(A)},r_\\star^{(A)},\\tau_\\star^{(A)}],[\\lambda_\\star^{(B)},r_\\star^{(B)},\\tau_\\star^{(B)}],[\\lambda_\\star^{(C)},r_\\star^{(C)},\\tau_\\star^{(C)}],[\\lambda_\\star^{(D)},r_\\star^{(D)},\\tau_\\star^{(D)}]]$. 所有输出都是无量纲的。",
            "solution": "用户要求对一个标记副本的副本交换蒙特卡洛（REMC）过程进行分析。问题的核心是为描述副本在 $K$ 个逆温 $\\{\\beta_0, \\beta_1, \\dots, \\beta_{K-1}\\}$ 阶梯上移动的马尔可夫链构建转移矩阵 $P$，然后从其本征谱计算其弛豫时间。\n\n首先，我们验证问题陈述。\n**第1步：提取已知条件**\n- **系统：** 在具有 $K$ 个温度能级的 REMC 模拟中的单个标记副本。\n- **索引：** 能级由 $i \\in \\{0, 1, \\dots, K-1\\}$ 索引。\n- **逆温：** 一组正实数 $\\{\\beta_0, \\beta_1, \\dots, \\beta_{K-1}\\}$。\n- **动力学：** 在每个离散时间步，从 $K-1$ 个可能的对中均匀随机选择一个相邻能级对 $(m, m+1)$。提议进行一次交换。\n- **能量分布：** 在逆温为 $\\beta$ 的能级上的能量 $E$ 是一个来自指数分布的随机变量，其概率密度函数为 $f(E;\\beta) = \\beta e^{-\\beta E}$（当 $E \\ge 0$ 时）。这对应于经典的单自由度谐振子。\n- **接受概率：** 能量为 $E_m$ 和 $E_{m+1}$ 的能级 $m$ 和 $m+1$ 之间的交换以概率 $p_{\\text{acc}} = \\min\\{1, \\exp[(\\beta_m - \\beta_{m+1})(E_m - E_{m+1})]\\}$ 被接受。\n- **转移矩阵 $P$：** 一个 $K \\times K$ 矩阵，其元素是对能量分布进行平均得到的。\n  - 相邻能级 $(i, i+1)$ 的非对角线元：$P_{i,i+1}$ 和 $P_{i+1,i}$ 是对选择概率 ($1/(K-1)$) 和期望接受概率 $\\langle p_{\\text{acc}} \\rangle$ 的乘积。\n  - 所有其他非对角线元均为零。\n  - 对角线元 $P_{i,i}$ 的设置使得每行之和为 $1$。\n- **待计算量：** 对于每个测试用例，求出：\n  1. $\\lambda_\\star$：绝对值严格小于 $1$ 的最大实数本征值。\n  2. $r_\\star = |\\lambda_\\star|$。\n  3. $\\tau_\\star = -1/\\ln(r_\\star)$。\n- **数值精度：** 将结果四舍五入到六位小数。将虚部绝对值小于 $10^{-10}$ 的复本征值视为实数。\n- **测试用例：**\n  A: $K=2$, $\\boldsymbol{\\beta}=[1.0, 0.3]$.\n  B: $K=2$, $\\boldsymbol{\\beta}=[1.0, 0.9]$.\n  C: $K=5$, $\\boldsymbol{\\beta}=[1.5, 1.1, 0.85, 0.66, 0.5]$.\n  D: $K=4$, $\\boldsymbol{\\beta}=[1.0, 1.0, 1.0, 1.0]$.\n\n**第2步：使用提取的已知条件进行验证**\n该问题具有科学依据，描述了计算统计力学中的一个标准模型。它是一个适定问题，提供了构建转移矩阵和计算所需量的所有必要定义和数据。使用平均转移矩阵是分析此类系统长时行为的有效技术。所要求的量（$\\lambda_\\star, r_\\star, \\tau_\\star$）是衡量马尔可夫链收敛性的标准指标。问题是客观的，不包含任何矛盾。\n\n**第3步：结论和行动**\n问题有效。我们继续进行求解。\n\n求解过程分三个阶段进行：\n1. 推导平均交换接受概率。\n2. 构建转移矩阵 $P$。\n3. 数值计算本征值和所要求的量。\n\n**1. 平均交换接受概率**\n相邻能级 $i$ 和 $i+1$ 之间的转移概率取决于这些能级间交换的平均接受概率 $\\langle p_{\\text{acc}} \\rangle$。这需要将 Metropolis 接受概率对两个副本的正则能量分布进行积分。\n设两个逆温为 $\\beta_i$ 和 $\\beta_{i+1}$。能量 $E_i$ 和 $E_{i+1}$ 是独立的随机变量，其分布分别为 $f(E_i;\\beta_i) = \\beta_i e^{-\\beta_i E_i}$ 和 $f(E_{i+1};\\beta_{i+1}) = \\beta_{i+1} e^{-\\beta_{i+1} E_{i+1}}$。期望接受概率为：\n$$ \\langle p_{\\text{acc}} \\rangle = \\int_0^\\infty \\int_0^\\infty p_{\\text{acc}}(E_i, E_{i+1}) f(E_i;\\beta_i) f(E_{i+1};\\beta_{i+1}) dE_i dE_{i+1} $$\n其中 $p_{\\text{acc}}(E_i, E_{i+1}) = \\min\\{1, \\exp[(\\beta_i - \\beta_{i+1})(E_i - E_{i+1})]\\}$。\n\n为了计算这个积分，我们根据指数中参数的符号来划分积分域。不失一般性，假设 $\\beta_i > \\beta_{i+1}$。那么 $(\\beta_i - \\beta_{i+1}) > 0$。\n- 如果 $E_i > E_{i+1}$，则指数为正，所以 $p_{\\text{acc}}=1$。\n- 如果 $E_i \\le E_{i+1}$，则指数为非正，所以 $p_{\\text{acc}}=\\exp[(\\beta_i - \\beta_{i+1})(E_i - E_{i+1})]$。\n\n该积分成为两部分之和，$J_1$ 和 $J_2$：\n$$ J_1 = \\int_0^\\infty dE_i \\int_0^{E_i} dE_{i+1} (\\beta_i e^{-\\beta_i E_i})(\\beta_{i+1} e^{-\\beta_{i+1} E_{i+1}}) \\cdot 1 $$\n$$ J_2 = \\int_0^\\infty dE_i \\int_{E_i}^\\infty dE_{i+1} (\\beta_i e^{-\\beta_i E_i})(\\beta_{i+1} e^{-\\beta_{i+1} E_{i+1}}) e^{(\\beta_i - \\beta_{i+1})(E_i - E_{i+1})} $$\n计算 $J_1$：\n$$ J_1 = \\int_0^\\infty \\beta_i e^{-\\beta_i E_i} \\left[ \\int_0^{E_i} \\beta_{i+1} e^{-\\beta_{i+1} E_{i+1}} dE_{i+1} \\right] dE_i $$\n内部积分为 $[-e^{-\\beta_{i+1}E_{i+1}}]_0^{E_i} = 1 - e^{-\\beta_{i+1}E_i}$。\n$$ J_1 = \\int_0^\\infty \\beta_i e^{-\\beta_i E_i} (1 - e^{-\\beta_{i+1}E_i}) dE_i = \\int_0^\\infty (\\beta_i e^{-\\beta_i E_i} - \\beta_i e^{-(\\beta_i+\\beta_{i+1})E_i}) dE_i $$\n$$ J_1 = \\left[ -e^{-\\beta_i E_i} + \\frac{\\beta_i}{\\beta_i+\\beta_{i+1}}e^{-(\\beta_i+\\beta_{i+1})E_i} \\right]_0^\\infty = (0-0) - (-1 + \\frac{\\beta_i}{\\beta_i+\\beta_{i+1}}) = 1 - \\frac{\\beta_i}{\\beta_i+\\beta_{i+1}} = \\frac{\\beta_{i+1}}{\\beta_i+\\beta_{i+1}} $$\n计算 $J_2$：\n$J_2$ 中的被积函数简化为 $\\beta_i \\beta_{i+1} e^{-\\beta_{i+1}E_i}e^{-\\beta_i E_{i+1}}$。\n$$ J_2 = \\int_0^\\infty \\beta_i\\beta_{i+1} e^{-\\beta_{i+1}E_i} \\left[ \\int_{E_i}^\\infty e^{-\\beta_i E_{i+1}} dE_{i+1} \\right] dE_i $$\n内部积分为 $[-\\frac{1}{\\beta_i}e^{-\\beta_i E_{i+1}}]_{E_i}^\\infty = \\frac{1}{\\beta_i}e^{-\\beta_i E_i}$。\n$$ J_2 = \\int_0^\\infty \\beta_i\\beta_{i+1} e^{-\\beta_{i+1}E_i} \\left( \\frac{1}{\\beta_i}e^{-\\beta_i E_i} \\right) dE_i = \\int_0^\\infty \\beta_{i+1} e^{-(\\beta_i+\\beta_{i+1})E_i} dE_i $$\n$$ J_2 = \\beta_{i+1} \\left[ -\\frac{1}{\\beta_i+\\beta_{i+1}}e^{-(\\beta_i+\\beta_{i+1})E_i} \\right]_0^\\infty = \\frac{\\beta_{i+1}}{\\beta_i+\\beta_{i+1}} $$\n因此，对于 $\\beta_i > \\beta_{i+1}$，$\\langle p_{\\text{acc}} \\rangle = J_1 + J_2 = \\frac{2\\beta_{i+1}}{\\beta_i+\\beta_{i+1}}$。这个表达式取决于两个温度中较低的那个。我们可以为任意一对逆温 $\\beta_a$ 和 $\\beta_b$ 写出一个通用公式：\n$$ \\langle p_{\\text{acc}} \\rangle (\\beta_a, \\beta_b) = \\frac{2 \\min(\\beta_a, \\beta_b)}{\\beta_a + \\beta_b} $$\n\n**2. 构建转移矩阵**\n转移矩阵 $P$ 是一个 $K \\times K$ 矩阵。由于交换只在相邻能级之间发生，所以 $P$ 是三对角矩阵。非对角线元素为：\n$$ P_{i, i+1} = P_{i+1, i} = \\frac{1}{K-1} \\langle p_{\\text{acc}} \\rangle (\\beta_i, \\beta_{i+1}) = \\frac{1}{K-1} \\frac{2 \\min(\\beta_i, \\beta_{i+1})}{\\beta_i + \\beta_{i+1}} $$\n对于 $i \\in \\{0, \\dots, K-2\\}$。由于 $P_{i,j}=P_{j,i}$，矩阵 $P$ 是对称的。对角线元素 $P_{i,i}$ 由每行必须总和为 $1$ 的随机条件确定：\n$$ P_{i,i} = 1 - \\sum_{j \\neq i} P_{i,j} $$\n具体来说：\n- $P_{0,0} = 1 - P_{0,1}$\n- $P_{K-1,K-1} = 1 - P_{K-1,K-2}$\n- $P_{i,i} = 1 - P_{i,i-1} - P_{i,i+1}$ for $i \\in \\{1, \\dots, K-2\\}$\n\n**3. 本征值分析**\n对于每个测试用例，我们按照所述构建矩阵 $P$。然后我们计算其本征值。由于 $P$ 是一个实对称随机矩阵：\n- 其所有本征值都是实数。\n- 所有本征值 $\\lambda$ 满足 $|\\lambda| \\le 1$。\n- 最大的本征值恰好为 $1$，对应于均匀平稳分布。\n\n我们寻找的是 $\\lambda_\\star$，即绝对值严格小于 $1$ 的最大本征值。这对应于 $P$ 的第二大本征值。一旦找到 $\\lambda_\\star$，我们就计算 $r_\\star = |\\lambda_\\star|$ 和弛豫时间 $\\tau_\\star = -1/\\ln(r_\\star)$。下面的程序实现了这个过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Replica Exchange Monte Carlo problem for a series of test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case A\n        {'K': 2, 'betas': [1.0, 0.3]},\n        # Test case B\n        {'K': 2, 'betas': [1.0, 0.9]},\n        # Test case C\n        {'K': 5, 'betas': [1.5, 1.1, 0.85, 0.66, 0.5]},\n        # Test case D\n        {'K': 4, 'betas': [1.0, 1.0, 1.0, 1.0]},\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        K = case['K']\n        betas = np.array(case['betas'])\n        \n        if K == 1:\n            # The problem context implies K >= 2, but handle this for completeness.\n            # No exchanges possible, no relaxation dynamics to analyze.\n            # Eigenvalues would just be [1.0].\n            # There is no eigenvalue with magnitude strictly less than 1.\n            # We set results to zero as a placeholder.\n            results.append([0.0, 0.0, float('inf')])\n            continue\n            \n        # Initialize the K x K transition matrix P\n        P = np.zeros((K, K))\n        \n        # Pair selection probability\n        pair_selection_prob = 1.0 / (K - 1)\n        \n        # Calculate off-diagonal elements for adjacent levels\n        for i in range(K - 1):\n            beta_i = betas[i]\n            beta_i_plus_1 = betas[i+1]\n            \n            # Calculate average acceptance probability\n            avg_acc_prob = (2.0 * min(beta_i, beta_i_plus_1)) / (beta_i + beta_i_plus_1)\n            \n            # Calculate transition probability\n            p_ij = pair_selection_prob * avg_acc_prob\n            \n            P[i, i + 1] = p_ij\n            P[i + 1, i] = p_ij\n            \n        # Calculate diagonal elements to make rows sum to 1\n        for i in range(K):\n            P[i, i] = 1.0 - np.sum(P[i, :])\n            \n        # Compute eigenvalues. Since P is real and symmetric, eigh is most stable\n        # and guarantees real eigenvalues.\n        eigenvalues = np.linalg.eigh(P)[0]\n\n        # The problem states to filter for real eigenvalues from eigvals,\n        # but for a symmetric matrix, all eigenvalues are real.\n        # We can directly work with the output of eigh.\n        \n        # Sort eigenvalues by magnitude in descending order\n        eigenvalues = sorted(eigenvalues, key=abs, reverse=True)\n        \n        # Find lambda_star: the eigenvalue with the largest magnitude strictly less than 1.\n        lambda_star = 0.0\n        # The largest eigenvalue of a stochastic matrix is 1. We search for the next one.\n        for val in eigenvalues:\n            if abs(val)  1.0 - 1e-12: # Use tolerance for float comparison\n                lambda_star = val\n                break\n        \n        # Calculate r_star and tau_star\n        r_star = abs(lambda_star)\n        \n        # The relaxation time in steps\n        if r_star > 0:\n            tau_star = -1.0 / np.log(r_star)\n        else:\n            # If r_star is 0, relaxation is instantaneous, tau is 0 or undefined.\n            # In this physical system, r_star > 0 for K > 1.\n            tau_star = float('inf') \n\n        # Append rounded results for the current test case\n        results.append([\n            round(lambda_star, 6),\n            round(r_star, 6),\n            round(tau_star, 6)\n        ])\n\n    # Final print statement in the exact required format.\n    # str(list) automatically adds spaces, so we build the string manually.\n    result_str = \",\".join([f\"[{r[0]},{r[1]},{r[2]}]\" for r in results])\n    print(f\"[{result_str}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "在模拟效率这一概念的基础上，一个关键的实践问题是确定在给定的温度范围内最优的副本数量。使用过少的副本会导致交换接受率低下和扩散缓慢，而使用过多的副本则会增加计算成本却带不来成比例的收益。本练习  将引导您通过第一性原理推导出一个成本函数来找到这个最佳点，从而在每个周期的计算工作量与副本完成一次往返所需的时间之间取得平衡。",
            "id": "2434293",
            "problem": "考虑一个一维并行退火（也称为副本交换蒙特卡洛）设置，其中包含$M$个副本，其逆温分别为$\\beta_0, \\beta_1, \\dots, \\beta_{M-1}$，分布在一个固定的区间$[\\beta_{\\min}, \\beta_{\\max}]$内，其中$\\beta_{\\max} > \\beta_{\\min}$。假设逆温在$\\beta$上均匀分布，因此相邻间距为$\\Delta \\beta = (\\beta_{\\max} - \\beta_{\\min})/(M-1)$。在每次尝试最近邻交换之间，假设每个副本进行一次局部马尔可夫链蒙特卡洛扫描，因此一个“周期”包括对$M$个副本中的每一个进行一次局部扫描，然后是一整套最近邻交换尝试。一个周期的计算成本与$M$成正比。\n\n您将研究为在最冷副本上达到固定的绝对统计误差所需的总计算时间如何随$M$变化，并确定是否存在一个最优的$M$。仅使用第一性原理论证和标准的、广泛使用的近似方法。您的推导必须从以下基础出发：\n\n- 正则系综和满足细致平衡的Metropolis接受准则：对于在逆温$\\beta_i$和$\\beta_j$的副本之间交换构型$x_i$和$x_j$的提议，Metropolis接受率为$\\exp\\left((\\beta_i - \\beta_j)(E(x_i) - E(x_j))\\right)$。\n- 正则系综的涨落-耗散关系：$\\dfrac{d \\langle E \\rangle}{d \\beta} = -\\mathrm{Var}(E)$。\n- 中心极限定理和有效样本量概念：对于一个具有积分自相关时间$\\tau_{\\mathrm{int}}$的平稳时间序列，经过长时间$t$后样本均值的方差按$\\sigma_A^2 \\, (2 \\tau_{\\mathrm{int}}/t)$缩放，相当于拥有$N_{\\mathrm{eff}} \\approx t/(2 \\tau_{\\mathrm{int}})$个独立样本。\n- 随机游走首次穿越标度：无偏一维随机游走穿越长度为$L$的区间的平均首次穿越时间按$L^2/D$缩放，其中$D$是扩散系数。\n\n在以下建模假设下进行工作，您必须在推导中明确引用并论证每一个假设：\n\n- 在温度阶梯上，相邻副本的能量涨落近似为高斯分布，并且在$\\Delta \\beta$范围内对温度的依赖性较弱，具有代表阶梯中部的共同能量标准差$\\sigma_E$。\n- 为了估计单个副本温度索引的长时间扩散，相邻交换尝试在周期之间是统计独立的。\n- 为了用计算功来衡量最冷副本误差的标度，主导相关尺度是标记副本的温度往返时间（从最冷端到最热端再返回），并且一次往返在最冷温度下产生一个有效独立样本。\n\n任务：\n\n1) 仅使用所述基础，推导出一个关于由$\\Delta \\beta$分隔的副本之间平均最近邻交换接受概率$p_{\\mathrm{acc}}(\\Delta \\beta, \\sigma_E)$的近似表达式。您的推导必须从Metropolis接受准则开始，对相邻副本的联合高斯能量涨落进行平均，并使用涨落-耗散关系将平均能量差在$\\Delta \\beta$上线性化。\n\n2) 将单个副本的温度索引运动建模为在整数段$\\{0,1,\\dots,M-1\\}$上的无偏一维随机游走，具有反射边界，在每个交换周期以与接受概率$p_{\\mathrm{acc}}$成比例的概率走一个单位步长。从随机游走首次穿越标度出发，推导出平均往返时间$\\tau_{\\mathrm{rt}}(M)$的标度关系，形式为$M$和$p_{\\mathrm{acc}}$的函数，直到一个与$M$无关的乘法常数。\n\n3) 设为在最冷副本上达到固定的目标绝对误差所需的总计算功与每周期成本和获得固定数量的有效独立样本所需的周期数的乘积成正比。使用第1部分和第2部分的结论，论证形式为\n$$\nW(M) = \\frac{M\\,(M-1)^2}{p_{\\mathrm{acc}}(M)}\n$$\n的成本函数，在忽略一个与$M$无关的总体乘法常数的情况下，捕捉了所需计算功对$M$的依赖性，其中$p_{\\mathrm{acc}}(M)$是在均匀间距$\\Delta \\beta = (\\beta_{\\max} - \\beta_{\\min})/(M-1)$下计算的$p_{\\mathrm{acc}}$。\n\n4) 实现一个完整的、可运行的程序，对于以下每个测试用例，计算在$2 \\le M \\le M_{\\max}$范围内使成本$W(M)$最小化的整数$M$，并返回最小化$M$和最小化成本值$W_{\\min}$。您的实现必须使用您在第1部分中推导出的接受概率表达式，并采用如上所述的$\\beta$均匀间距。如果为了数值稳定性需要，您可以将零接受率视为无限成本。\n\n测试套件（每个用例为$(\\beta_{\\min}, \\beta_{\\max}, \\sigma_E, M_{\\max})$）：\n\n- 用例 A: $(\\beta_{\\min}, \\beta_{\\max}, \\sigma_E, M_{\\max}) = (\\,0.5,\\,1.0,\\,10.0,\\,100\\,)$.\n- 用例 B: $(\\beta_{\\min}, \\beta_{\\max}, \\sigma_E, M_{\\max}) = (\\,0.9,\\,1.0,\\,20.0,\\,100\\,)$.\n- 用例 C: $(\\beta_{\\min}, \\beta_{\\max}, \\sigma_E, M_{\\max}) = (\\,0.1,\\,2.1,\\,30.0,\\,150\\,)$.\n- 用例 D: $(\\beta_{\\min}, \\beta_{\\max}, \\sigma_E, M_{\\max}) = (\\,0.95,\\,0.96,\\,5.0,\\,50\\,)$.\n\n单位：在本问题中，所有量在所采用的建模假设下都是无量纲的，因此不需要进行单位转换。\n\n最终输出规范：您的程序应生成单行输出，包含一个逗号分隔的列表，用方括号括起来，其中每个测试用例贡献一个双元素列表$[M_{\\mathrm{opt}}, W_{\\min}]$，$M_{\\mathrm{opt}}$为整数，$W_{\\min}$为浮点数。例如，总体格式必须类似于$[[M_1,W_1],[M_2,W_2],[M_3,W_3],[M_4,W_4]]$，不含多余文本或空格。",
            "solution": "该问题经过验证，被认为是科学上可靠、适定且客观的。它代表了计算统计物理学中一个关于优化副本交换蒙特卡洛（REMC）算法的标准理论练习。所有提供的原理和假设在该领域都是标准的，并为所要求的推导构成了连贯的基础。该问题是有效的，下面提供了解决方案。\n\n推导按要求分为三部分进行，最终得到成本函数$W(M)$，该函数将在最后的程序中被实现和最小化。\n\n**1. 交换接受概率 $p_{\\mathrm{acc}}$ 的推导**\n\n我们首先考虑两个相邻副本（索引为$i$和$i+1$）之间交换构型，它们分别处于逆温$\\beta_i$和$\\beta_{i+1}$。设它们当前构型的能量为$E_i$和$E_{i+1}$。温度间距是均匀的，$\\Delta\\beta = \\beta_{i+1} - \\beta_i$。交换构型的Metropolis接受准则由下式给出：\n$$\nA(E_i, E_{i+1}) = \\min\\left(1, \\exp\\left((\\beta_i - \\beta_{i+1})(E_i - E_{i+1})\\right)\\right) = \\min\\left(1, \\exp\\left(-\\Delta\\beta(E_i - E_{i+1})\\right)\\right)\n$$\n平均接受概率$p_{\\mathrm{acc}}$是$A(E_i, E_{i+1})$在两个副本的平衡能量分布上的期望值。我们定义能量差$\\delta E = E_i - E_{i+1}$。构型是从独立的正则系综中抽样的，因此$E_i$和$E_{i+1}$是独立的随机变量。\n\n我们引用第一个建模假设：能量分布近似为高斯分布，并且对于相邻副本，共享一个共同的方差$\\sigma_E^2$。因此，$E_i \\sim \\mathcal{N}(\\langle E \\rangle_i, \\sigma_E^2)$且$E_{i+1} \\sim \\mathcal{N}(\\langle E \\rangle_{i+1}, \\sigma_E^2)$。能量差$\\delta E$也是一个高斯随机变量，其均值为$\\mu_{\\delta E}$，方差为$\\sigma_{\\delta E}^2$：\n$$\n\\mu_{\\delta E} = \\langle E_i \\rangle - \\langle E_{i+1} \\rangle = \\langle E \\rangle(\\beta_i) - \\langle E \\rangle(\\beta_{i+1})\n$$\n$$\n\\sigma_{\\delta E}^2 = \\mathrm{Var}(E_i) + \\mathrm{Var}(E_{i+1}) = \\sigma_E^2 + \\sigma_E^2 = 2\\sigma_E^2\n$$\n为了计算$\\mu_{\\delta E}$，我们使用涨落-耗散关系，$\\frac{d\\langle E \\rangle}{d\\beta} = -\\mathrm{Var}(E) = -\\sigma_E^2$。对于一个小的间距$\\Delta\\beta$，我们可以在$\\beta_i$附近线性化$\\langle E \\rangle(\\beta_{i+1})$：\n$$\n\\langle E \\rangle(\\beta_{i+1}) = \\langle E \\rangle(\\beta_i + \\Delta\\beta) \\approx \\langle E \\rangle(\\beta_i) + \\frac{d\\langle E \\rangle}{d\\beta}\\bigg|_{\\beta_i} \\Delta\\beta = \\langle E \\rangle(\\beta_i) - \\sigma_E^2 \\Delta\\beta\n$$\n将此代入$\\mu_{\\delta E}$的表达式中：\n$$\n\\mu_{\\delta E} \\approx \\langle E \\rangle(\\beta_i) - (\\langle E \\rangle(\\beta_i) - \\sigma_E^2 \\Delta\\beta) = \\sigma_E^2 \\Delta\\beta\n$$\n所以，$\\delta E \\sim \\mathcal{N}(\\sigma_E^2 \\Delta\\beta, 2\\sigma_E^2)$。我们将接受准则中的指数定义为一个随机变量$X = -\\Delta\\beta \\cdot \\delta E$。作为高斯变量的线性变换，$X$也是高斯分布的。它的均值$\\mu_X$和方差$\\sigma_X^2$是：\n$$\n\\mu_X = \\mathbb{E}[X] = -\\Delta\\beta \\cdot \\mathbb{E}[\\delta E] = -\\Delta\\beta (\\sigma_E^2 \\Delta\\beta) = -(\\sigma_E \\Delta\\beta)^2\n$$\n$$\n\\sigma_X^2 = \\mathrm{Var}(X) = (-\\Delta\\beta)^2 \\cdot \\mathrm{Var}(\\delta E) = (\\Delta\\beta)^2 (2\\sigma_E^2) = 2(\\sigma_E \\Delta\\beta)^2\n$$\n平均接受概率是$p_{\\mathrm{acc}} = \\mathbb{E}[\\min(1, e^X)]$，其中$X \\sim \\mathcal{N}(\\mu_X, \\sigma_X^2)$。这个期望可以计算为：\n$$\np_{\\mathrm{acc}} = \\int_{-\\infty}^{\\infty} \\min(1, e^x) f_X(x) dx = \\int_{-\\infty}^{0} e^x f_X(x) dx + \\int_{0}^{\\infty} f_X(x) dx\n$$\n其中$f_X(x)$是$X$的概率密度函数。对于这个积分，一个已知的结果是（可以通过在第一项的指数中配方法推导得出）：\n$$\np_{\\mathrm{acc}} = \\exp\\left(\\mu_X + \\frac{\\sigma_X^2}{2}\\right) \\Phi\\left(\\frac{-\\mu_X - \\sigma_X^2}{\\sigma_X}\\right) + 1 - \\Phi\\left(\\frac{-\\mu_X}{\\sigma_X}\\right)\n$$\n其中$\\Phi(z)$是标准正态分布的累积分布函数。代入我们对$\\mu_X$和$\\sigma_X^2$的表达式：\n$$\n\\mu_X + \\frac{\\sigma_X^2}{2} = -(\\sigma_E \\Delta\\beta)^2 + \\frac{2(\\sigma_E \\Delta\\beta)^2}{2} = 0\n$$\n第一项的预因子是$\\exp(0)=1$。$\\Phi$的参数变为：\n$$\n\\frac{-\\mu_X - \\sigma_X^2}{\\sigma_X} = \\frac{(\\sigma_E \\Delta\\beta)^2 - 2(\\sigma_E \\Delta\\beta)^2}{\\sqrt{2} \\sigma_E \\Delta\\beta} = \\frac{-(\\sigma_E \\Delta\\beta)^2}{\\sqrt{2} \\sigma_E \\Delta\\beta} = -\\frac{\\sigma_E \\Delta\\beta}{\\sqrt{2}}\n$$\n$$\n\\frac{-\\mu_X}{\\sigma_X} = \\frac{(\\sigma_E \\Delta\\beta)^2}{\\sqrt{2} \\sigma_E \\Delta\\beta} = \\frac{\\sigma_E \\Delta\\beta}{\\sqrt{2}}\n$$\n利用对称性$\\Phi(-z) = 1 - \\Phi(z)$，第二项变为$1 - \\Phi(\\frac{\\sigma_E \\Delta\\beta}{\\sqrt{2}}) = \\Phi(-\\frac{\\sigma_E \\Delta\\beta}{\\sqrt{2}})$。因此，\n$$\np_{\\mathrm{acc}} = \\Phi\\left(-\\frac{\\sigma_E \\Delta\\beta}{\\sqrt{2}}\\right) + \\Phi\\left(-\\frac{\\sigma_E \\Delta\\beta}{\\sqrt{2}}\\right) = 2 \\Phi\\left(-\\frac{\\sigma_E \\Delta\\beta}{\\sqrt{2}}\\right)\n$$\n利用$\\Phi(z)$和互补误差函数$\\mathrm{erfc}(z) = 2 \\Phi(-z\\sqrt{2})$之间的关系，我们设$z = \\sigma_E \\Delta\\beta / 2$：\n$$\np_{\\mathrm{acc}}(\\Delta\\beta, \\sigma_E) = \\mathrm{erfc}\\left(\\frac{\\sigma_E \\Delta\\beta}{2}\\right)\n$$\n这是平均最近邻交换接受概率的最终表达式。\n\n**2. 往返时间 $\\tau_{\\mathrm{rt}}(M)$ 的标度关系**\n\n标记副本的温度索引$i \\in \\{0, 1, \\dots, M-1\\}$在一个长度为$L = M-1$的一维格点上进行随机游走。根据问题假设，这是一个具有反射边界（在$i=0$和$i=M-1$处）的无偏游走。REMC模拟的一个周期对应于这个随机游走的一个时间步。一次移动（成功的交换）发生的概率与$p_{\\mathrm{acc}}$有关。随机游走的扩散系数$D$与单位时间的均方位移成正比。在一个周期中，索引为$i$的副本尝试与邻居交换，成功移动一步的概率是$p_{\\mathrm{acc}}$。因此，温度索引空间中的扩散系数标度为$D \\propto p_{\\mathrm{acc}}$。\n\n问题提供了穿越长度为$L$的区间的平均首次穿越时间的标度关系为$\\tau_{\\mathrm{passage}} \\propto L^2/D$。一个副本的往返过程包括从最冷端（$i=0$）移动到最热端（$i=M-1$）再返回。这个过程的平均时间是两次平均首次穿越时间之和。\n$$\n\\tau_{\\mathrm{rt}} = \\tau_{0 \\to M-1} + \\tau_{M-1 \\to 0}\n$$\n当$L=M-1$时，每次单程旅行所需的时间与$(M-1)^2/D$成正比。\n$$\n\\tau_{\\mathrm{rt}}(M) \\propto \\frac{(M-1)^2}{D} + \\frac{(M-1)^2}{D} \\propto \\frac{(M-1)^2}{D}\n$$\n代入扩散系数的标度关系$D \\propto p_{\\mathrm{acc}}$，我们得到以模拟周期为单位的平均往返时间的标度关系：\n$$\n\\tau_{\\mathrm{rt}}(M) \\propto \\frac{(M-1)^2}{p_{\\mathrm{acc}}}\n$$\n\n**3. 计算成本函数 $W(M)$ 的推导**\n\n目标是在最冷副本上为一个可观测量达到固定的绝对统计误差。根据相关时间序列的中心极限定理，在$N_{\\mathrm{cycles}}$个周期的模拟之后，样本均值的方差$\\mathrm{Var}(\\bar{A})$与有效独立样本数$N_{\\mathrm{eff}}$成反比：\n$$\n\\mathrm{Var}(\\bar{A}) \\propto \\frac{1}{N_{\\mathrm{eff}}}\n$$\n问题指出$N_{\\mathrm{eff}} \\approx N_{\\mathrm{cycles}} / (2 \\tau_{\\mathrm{int}})$，其中$\\tau_{\\mathrm{int}}$是以周期为单位的积分自相关时间。要达到固定的误差（即固定的$\\mathrm{Var}(\\bar{A})$），我们需要固定数量的有效样本，$N_{\\mathrm{eff}} = \\mathrm{const}$。这意味着：\n$$\nN_{\\mathrm{cycles}} \\propto \\tau_{\\mathrm{int}}\n$$\n第三个建模假设指出，主导相关尺度是温度往返时间，使得一次往返产生一个有效独立样本。这意味着$\\tau_{\\mathrm{int}}$与$\\tau_{\\mathrm{rt}}$成正比。\n$$\n\\tau_{\\mathrm{int}} \\propto \\tau_{\\mathrm{rt}}(M) \\propto \\frac{(M-1)^2}{p_{\\mathrm{acc}}(M)}\n$$\n因此，达到目标精度所需的周期数标度为：\n$$\nN_{\\mathrm{cycles}} \\propto \\frac{(M-1)^2}{p_{\\mathrm{acc}}(M)}\n$$\n总计算功$W(M)$是每周期功与总周期数的乘积。问题指定每周期成本与副本数$M$成正比。\n$$\nW(M) = (\\text{每周期成本}) \\times N_{\\mathrm{cycles}} \\propto M \\cdot N_{\\mathrm{cycles}}\n$$\n结合这些结果，得到总功的最终标度关系：\n$$\nW(M) \\propto M \\cdot \\frac{(M-1)^2}{p_{\\mathrm{acc}}(M)}\n$$\n这证明了使用成本函数$W(M) = k \\frac{M(M-1)^2}{p_{\\mathrm{acc}}(M)}$是合理的，其中$k$是一个与$M$无关的常数。对于最小化问题，这个常数可以忽略。接受概率$p_{\\mathrm{acc}}(M)$通过温度间距$\\Delta\\beta = \\frac{\\beta_{\\max} - \\beta_{\\min}}{M-1}$依赖于$M$。\n$$\np_{\\mathrm{acc}}(M) = \\mathrm{erfc}\\left( \\frac{\\sigma_E (\\beta_{\\max} - \\beta_{\\min})}{2(M-1)} \\right)\n$$\n任务是找到在$2 \\le M \\le M_{\\max}$范围内使该成本函数$W(M)$最小化的整数$M$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import erfc\n\ndef solve():\n    \"\"\"\n    Solves the replica exchange optimization problem for the given test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is (beta_min, beta_max, sigma_E, M_max)\n    test_cases = [\n        (0.5, 1.0, 10.0, 100),\n        (0.9, 1.0, 20.0, 100),\n        (0.1, 2.1, 30.0, 150),\n        (0.95, 0.96, 5.0, 50),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        beta_min, beta_max, sigma_E, M_max = case\n        \n        # We need to find the integer M in [2, M_max] that minimizes W(M).\n        min_cost = np.inf\n        opt_M = -1\n        \n        # M is the number of replicas, M >= 2.\n        M_range = range(2, M_max + 1)\n\n        for M in M_range:\n            M = float(M) # Use floats for calculation precision\n            \n            # 1. Calculate the acceptance probability p_acc(M)\n            # Delta beta = (beta_max - beta_min) / (M - 1)\n            delta_beta_range = beta_max - beta_min\n            m_minus_1 = M - 1.0\n            \n            # Argument for the complementary error function\n            # arg = (sigma_E * delta_beta) / 2\n            arg = (sigma_E * delta_beta_range) / (2.0 * m_minus_1)\n            \n            p_acc = erfc(arg)\n            \n            # 2. Calculate the cost function W(M)\n            # W(M) = M * (M - 1)^2 / p_acc\n            \n            # Handle the case where p_acc is zero to avoid division by zero.\n            # This corresponds to infinite cost as per the problem description.\n            if p_acc == 0.0:\n                cost = np.inf\n            else:\n                cost = M * (m_minus_1)**2 / p_acc\n\n            # 3. Check if this is the minimum cost found so far\n            if cost  min_cost:\n                min_cost = cost\n                opt_M = int(M)\n                \n        results.append([opt_M, min_cost])\n\n    # Format the final output string exactly as specified.\n    # e.g., [[M1,W1],[M2,W2],[M3,W3],[M4,W4]]\n    # No extra spaces.\n    string_results = [f\"[{m},{w}]\" for m, w in results]\n    final_output = f\"[{','.join(string_results)}]\"\n    \n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "除了优化速度，确保结果的准确性也至关重要。REMC模拟中的一个常见陷阱是在所有副本在其各自的温度下完全达到平衡之前就尝试进行交换，这会引入难以察觉的系统误差。本练习  通过一个简单而有效的双态模型，要求您量化当高温副本未处于平衡态时，对低温可观测量引入的偏差，从而阐明了这个问题。",
            "id": "2434345",
            "problem": "考虑一个双态系统，其状态为 $A$ 和 $B$，能量分别为 $E(A)=0$ 和 $E(B)=\\Delta$，其中 $\\Delta>0$ 是一个无量纲的能量尺度（玻尔兹曼常数设为 $k_{B}=1$）。在两个逆温 $\\beta_{L}$（低温）和 $\\beta_{H}$（高温）下模拟了两个副本，其中 $\\beta_{L}>\\beta_{H}>0$。在逆温 $\\beta$ 下，状态 $B$ 的平衡概率为 $\\pi_{\\beta}(B)=\\dfrac{e^{-\\beta \\Delta}}{1+e^{-\\beta \\Delta}}$。低温副本初始时根据其平衡分布 $\\pi_{\\beta_{L}}$ 进行分布。高温副本初始时未达到平衡：其处于状态 $B$ 的初始概率为 $q_{B}=(1-\\eta)\\,\\pi_{\\beta_{H}}(B)+\\eta\\,\\theta$，其中 $0\\le \\eta \\le 1$ 和 $\\theta\\in\\{0,1\\}$ 是描述偏离平衡程度的给定参数。根据副本交换蒙特卡洛（REMC）接受准则，在两个副本之间进行一次交换尝试：对于当前状态 $s_{L}\\in\\{A,B\\}$ 和 $s_{H}\\in\\{A,B\\}$，提议的交换以概率 $P_{\\mathrm{acc}}(s_{L},s_{H})=\\min\\left\\{1,\\exp\\big((\\beta_{L}-\\beta_{H})\\left(E(s_{L})-E(s_{H})\\right)\\big)\\right\\}$ 被接受。在这次交换尝试之后（无论交换被接受还是拒绝），将低温期望能量定义为 $\\langle E\\rangle_{\\mathrm{after}}=\\Delta\\,\\mathbb{P}\\{\\text{低温状态在尝试后为 }B\\}$。尝试前的平衡低温期望能量为 $\\langle E\\rangle_{\\mathrm{eq}}=\\Delta\\,\\pi_{\\beta_{L}}(B)$。因在高温平衡前尝试交换而产生的系统误差为 $\\varepsilon=\\langle E\\rangle_{\\mathrm{after}}-\\langle E\\rangle_{\\mathrm{eq}}$。所有量都是无量纲的，且不涉及角度。对于以下参数集 $(\\Delta,\\beta_{L},\\beta_{H},\\eta,\\theta)$ 的测试套件，计算 $\\varepsilon$ 并将每个结果报告为精确到 $12$ 位小数的浮点数。测试套件：$1.$ $(\\Delta,\\beta_{L},\\beta_{H},\\eta,\\theta)=(1.0,2.0,0.5,0.5,1)$，$2.$ $(\\Delta,\\beta_{L},\\beta_{H},\\eta,\\theta)=(1.0,2.0,0.5,0.0,1)$，$3.$ $(\\Delta,\\beta_{L},\\beta_{H},\\eta,\\theta)=(2.0,3.0,0.2,1.0,0)$，$4.$ $(\\Delta,\\beta_{L},\\beta_{H},\\eta,\\theta)=(0.0,1.5,0.7,0.6,0)$。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，“[x1,x2,x3,x4]”）。",
            "solution": "问题陈述具有科学依据、问题明确、客观且自成体系。尽管一般描述假定 $\\Delta0$，但一个测试用例使用了 $\\Delta=0$。这不是一个致命的缺陷，因为物理和数学模型对于这种极限情况仍然是完全明确定义的。因此，该问题被认为是有效的，并将提供一个解决方案。\n\n目标是计算系统误差 $\\varepsilon = \\langle E\\rangle_{\\mathrm{after}} - \\langle E\\rangle_{\\mathrm{eq}}$。我们已知平衡期望能量为 $\\langle E\\rangle_{\\mathrm{eq}} = \\Delta\\,\\pi_{\\beta_{L}}(B)$。问题的核心是计算交换尝试后的期望能量 $\\langle E\\rangle_{\\mathrm{after}} = \\Delta\\,\\mathbb{P}\\{\\text{低温状态在尝试后为 }B\\}$。我们将尝试后低温副本处于状态 $B$ 的概率表示为 $P_{\\text{final}}(B)$。那么误差为 $\\varepsilon = \\Delta \\left( P_{\\text{final}}(B) - \\pi_{\\beta_{L}}(B) \\right)$。\n\n两个副本状态 $s_L$ 和 $s_H$ 的初始概率是独立的。\n对于低温副本（$L$），它在逆温 $\\beta_L$ 下处于平衡状态：\n- $\\mathbb{P}\\{s_L=B\\} = \\pi_{\\beta_L}(B) = \\frac{e^{-\\beta_L \\Delta}}{1+e^{-\\beta_L \\Delta}}$\n- $\\mathbb{P}\\{s_L=A\\} = \\pi_{\\beta_L}(A) = 1 - \\pi_{\\beta_L}(B) = \\frac{1}{1+e^{-\\beta_L \\Delta}}$\n\n对于高温副本（$H$），它不处于平衡状态：\n- $\\mathbb{P}\\{s_H=B\\} = q_B = (1-\\eta)\\pi_{\\beta_H}(B) + \\eta\\theta$\n- $\\mathbb{P}\\{s_H=A\\} = q_A = 1 - q_B$\n其中 $\\pi_{\\beta_H}(B) = \\frac{e^{-\\beta_H \\Delta}}{1+e^{-\\beta_H \\Delta}}$。\n\n尝试进行一次交换。设低温副本的最终状态为 $s'_L$。$s'_L$ 的值取决于初始状态 $(s_L, s_H)$ 以及交换是否被接受。通过对 $(s_L, s_H)$ 的所有四种可能的初始构型求和，可以找到 $s'_L$ 为状态 $B$ 的概率：\n$$P_{\\text{final}}(B) = \\sum_{s_L,s_H \\in \\{A,B\\}} \\mathbb{P}\\{s'_L=B | s_L,s_H\\} \\mathbb{P}\\{s_L=s_L\\} \\mathbb{P}\\{s_H=s_H\\}$$\n条件概率 $\\mathbb{P}\\{s'_L=B | s_L,s_H\\}$ 由交换动力学决定。以接受概率 $P_{\\mathrm{acc}}(s_L,s_H)$，最终的低温状态为 $s'_L=s_H$；否则，它保持为 $s'_L=s_L$。因此，$\\mathbb{P}\\{s'_L=B | s_L,s_H\\} = P_{\\mathrm{acc}}(s_L,s_H)\\mathbb{I}(s_H=B) + (1-P_{\\mathrm{acc}}(s_L,s_H))\\mathbb{I}(s_L=B)$，其中 $\\mathbb{I}(\\cdot)$ 是指示函数。\n\n我们评估每种初始状态的贡献：\n1. $(s_L, s_H) = (A, A)$: $\\Delta E = E(A)-E(A)=0$。$P_{\\mathrm{acc}}(A,A) = \\min\\{1, e^0\\}=1$。交换被接受，$s'_L$ 变为 $A$。对 $P_{\\text{final}}(B)$ 的贡献为 $0$。\n2. $(s_L, s_H) = (A, B)$: $\\Delta E = E(A)-E(B)=-\\Delta$。$P_{\\mathrm{acc}}(A,B) = \\min\\{1, e^{(\\beta_L-\\beta_H)(-\\Delta)}\\}$。由于 $\\beta_L\\beta_H$ 且 $\\Delta\\ge 0$，指数为非正，因此 $P_{\\mathrm{acc}}(A,B) = e^{-(\\beta_L-\\beta_H)\\Delta}$。如果接受，则 $s'_L=B$；如果拒绝，则 $s'_L=A$。$s'_L=B$ 的概率是 $P_{\\mathrm{acc}}(A,B)$。总贡献为 $\\pi_{\\beta_L}(A) q_B P_{\\mathrm{acc}}(A,B)$。\n3. $(s_L, s_H) = (B, A)$: $\\Delta E = E(B)-E(A)=\\Delta$。$P_{\\mathrm{acc}}(B,A) = \\min\\{1, e^{(\\beta_L-\\beta_H)\\Delta}\\}$。指数为非负，因此 $P_{\\mathrm{acc}}(B,A)=1$。交换被接受，$s'_L$ 变为 $A$。对 $P_{\\text{final}}(B)$ 的贡献为 $0$。\n4. $(s_L, s_H) = (B, B)$: $\\Delta E = E(B)-E(B)=0$。$P_{\\mathrm{acc}}(B,B) = 1$。交换被接受，$s'_L$ 变为 $B$。$s'_L=B$ 的概率是 $1$。总贡献为 $\\pi_{\\beta_L}(B) q_B \\cdot 1$。\n\n将这些贡献相加得到总概率：\n$$P_{\\text{final}}(B) = \\pi_{\\beta_L}(A) q_B e^{-(\\beta_L-\\beta_H)\\Delta} + \\pi_{\\beta_L}(B) q_B = q_B \\left( \\pi_{\\beta_L}(A) e^{-(\\beta_L-\\beta_H)\\Delta} + \\pi_{\\beta_L}(B) \\right)$$\n系统误差为 $\\varepsilon = \\Delta ( P_{\\text{final}}(B) - \\pi_{\\beta_L}(B) )$。\n一个关键的洞见来自于考虑高温副本也处于平衡的情况，即 $\\eta=0$ 且 $q_B=\\pi_{\\beta_H}(B)$。在这种情况下，低温副本的分布必须是稳态的，意味着 $P_{\\text{final}}(B) = \\pi_{\\beta_L}(B)$ 且 $\\varepsilon=0$。这蕴含了以下恒等式：\n$$\\pi_{\\beta_L}(B) = \\pi_{\\beta_H}(B) \\left( \\pi_{\\beta_L}(A) e^{-(\\beta_L-\\beta_H)\\Delta} + \\pi_{\\beta_L}(B) \\right)$$\n由此，我们可以简化括号中的项：\n$$\\left( \\pi_{\\beta_L}(A) e^{-(\\beta_L-\\beta_H)\\Delta} + \\pi_{\\beta_L}(B) \\right) = \\frac{\\pi_{\\beta_L}(B)}{\\pi_{\\beta_H}(B)}$$\n现在，我们将其代回 $P_{\\text{final}}(B)$ 的一般表达式中：\n$$P_{\\text{final}}(B) = q_B \\frac{\\pi_{\\beta_L}(B)}{\\pi_{\\beta_H}(B)}$$\n那么系统误差为：\n$$\\varepsilon = \\Delta \\left( q_B \\frac{\\pi_{\\beta_L}(B)}{\\pi_{\\beta_H}(B)} - \\pi_{\\beta_L}(B) \\right) = \\Delta \\pi_{\\beta_L}(B) \\left( \\frac{q_B}{\\pi_{\\beta_H}(B)} - 1 \\right) = \\Delta \\frac{\\pi_{\\beta_L}(B)}{\\pi_{\\beta_H}(B)} (q_B - \\pi_{\\beta_H}(B))$$\n代入 $q_B - \\pi_{\\beta_H}(B) = \\eta(\\theta - \\pi_{\\beta_H}(B))$，我们得到：\n$$\\varepsilon = \\Delta \\cdot \\eta \\cdot (\\theta - \\pi_{\\beta_H}(B)) \\cdot \\frac{\\pi_{\\beta_L}(B)}{\\pi_{\\beta_H}(B)}$$\n为简化计算，我们代入定义：$\\pi_{\\beta}(B) = \\frac{e^{-\\beta\\Delta}}{1+e^{-\\beta\\Delta}} = \\frac{1}{1+e^{\\beta\\Delta}}$。\n概率之比变为 $\\frac{\\pi_{\\beta_L}(B)}{\\pi_{\\beta_H}(B)} = \\frac{1+e^{\\beta_H\\Delta}}{1+e^{\\beta_L\\Delta}}$。\n项 $(\\theta - \\pi_{\\beta_H}(B))$ 变为 $\\theta - \\frac{1}{1+e^{\\beta_H\\Delta}} = \\frac{\\theta(1+e^{\\beta_H\\Delta})-1}{1+e^{\\beta_H\\Delta}}$。\n合并这些项得到误差的最终表达式：\n$$\\varepsilon = \\Delta \\cdot \\eta \\cdot \\left( \\frac{\\theta(1+e^{\\beta_H\\Delta})-1}{1+e^{\\beta_H\\Delta}} \\right) \\cdot \\left( \\frac{1+e^{\\beta_H\\Delta}}{1+e^{\\beta_L\\Delta}} \\right) = \\Delta \\cdot \\eta \\cdot \\frac{\\theta(1+e^{\\beta_H\\Delta})-1}{1+e^{\\beta_L\\Delta}}$$\n这个简化的公式用于计算给定测试套件的结果。对于 $\\Delta=0$ 的特殊情况，该公式正确地得出 $\\varepsilon=0$。对于 $\\eta=0$ 的情况，它也正确地得出 $\\varepsilon=0$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Replica Exchange Monte Carlo systematic error problem.\n    \"\"\"\n    test_cases = [\n        (1.0, 2.0, 0.5, 0.5, 1),\n        (1.0, 2.0, 0.5, 0.0, 1),\n        (2.0, 3.0, 0.2, 1.0, 0),\n        (0.0, 1.5, 0.7, 0.6, 0),\n    ]\n\n    results = []\n    for case in test_cases:\n        delta, beta_l, beta_h, eta, theta = case\n\n        # The derived formula for the systematic error epsilon is:\n        # epsilon = Delta * eta * (theta * (1 + exp(beta_H * Delta)) - 1) / (1 + exp(beta_L * Delta))\n        # This formula is robust and handles the Delta=0 case correctly, resulting in epsilon=0\n        # due to the Delta factor at the front.\n\n        if delta == 0.0 or eta == 0.0:\n            epsilon = 0.0\n        else:\n            numerator = delta * eta * (theta * (1 + np.exp(beta_h * delta)) - 1)\n            denominator = 1 + np.exp(beta_l * delta)\n            epsilon = numerator / denominator\n        \n        # Format the result to exactly 12 decimal places.\n        results.append(f\"{epsilon:.12f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}