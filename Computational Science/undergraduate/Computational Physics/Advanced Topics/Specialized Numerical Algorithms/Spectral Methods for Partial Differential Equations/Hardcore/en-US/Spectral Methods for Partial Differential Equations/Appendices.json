{
    "hands_on_practices": [
        {
            "introduction": "The elegance of Fourier spectral methods lies in their ability to transform complex differential operators into simple algebraic multipliers. This practice provides a quintessential example by tasking you with solving the two-dimensional biharmonic equation on a periodic domain. By leveraging the Fast Fourier Transform (FFT), you will see firsthand how a high-order partial differential equation can be solved with remarkable efficiency and accuracy, a cornerstone technique in fields like fluid dynamics and elasticity theory .",
            "id": "2440935",
            "problem": "Consider the two-dimensional biharmonic equation on a periodic square domain,\n$$\\nabla^4 u(x,y) = f(x,y), \\quad (x,y) \\in [0,1)\\times[0,1),$$\nwith periodic boundary conditions in both spatial directions. Assume the forcing $f$ has zero spatial average, which is necessary for solvability under periodic boundary conditions. You will construct a numerical solver based on spectral methods to recover $u$ from a given $f$.\n\nUse the following fundamental base.\n- Represent sufficiently smooth periodic functions by their Fourier series. On a periodic domain, differentiation in physical space corresponds to multiplication by the angular wave number in Fourier space: if $\\widehat{u}(\\kappa_x,\\kappa_y)$ denotes the Fourier coefficient at angular wave numbers $(\\kappa_x,\\kappa_y)$, then applying a spatial derivative $\\partial/\\partial x$ corresponds to multiplication by $i\\kappa_x$, and similarly for $\\partial/\\partial y$. Consequently, the Laplacian satisfies $\\widehat{\\nabla^2 u}(\\kappa_x,\\kappa_y) = -(\\kappa_x^2+\\kappa_y^2)\\widehat{u}(\\kappa_x,\\kappa_y)$.\n- The Discrete Fourier Transform (DFT), efficiently implemented by the Fast Fourier Transform (FFT), approximates these operations on a uniform grid by mapping grid values to discrete Fourier coefficients. Use the standard Discrete Fourier Transform conventions consistent with widely used numerical libraries. Angles are in radians.\n\nDesign and implement a program that:\n- Discretizes $[0,1)\\times[0,1)$ on a uniform $N\\times N$ grid with points $x_j = j/N$ and $y_k = k/N$ for integers $j,k \\in \\{0,1,\\dots,N-1\\}$.\n- Uses the Discrete Fourier Transform to move to Fourier space, applies the Laplacian operator twice in Fourier space, and inverts back to physical space to approximate $u$. Enforce the zero-mean solution by setting the zero Fourier mode of $u$ to zero. Handle the zero-wave-number division carefully in a mathematically consistent way.\n- Computes the root-mean-square error,\n$$\\mathrm{RMS}(u_{\\mathrm{num}},u_{\\mathrm{exact}})=\\sqrt{\\frac{1}{N^2}\\sum_{j=0}^{N-1}\\sum_{k=0}^{N-1}\\left(u_{\\mathrm{num}}(x_j,y_k)-u_{\\mathrm{exact}}(x_j,y_k)\\right)^2},$$\nfor each test case below.\n\nTest suite. For each case, construct $f$ analytically from the specified exact solution $u_{\\mathrm{exact}}$. Let $\\pi$ denote the usual circular constant and use the convention that $\\sin$ and $\\cos$ take arguments in radians. Define the angular wavenumbers by $\\kappa_x = 2\\pi n_x$ and $\\kappa_y = 2\\pi n_y$ where $n_x$ and $n_y$ are the integer mode numbers in the $x$ and $y$ directions, respectively. For a pure Fourier mode with mode numbers $(n_x,n_y)$, the biharmonic operator multiplies that mode by $(\\kappa_x^2+\\kappa_y^2)^2$.\n\n- Case A (happy path): $N = 32$, $u_{\\mathrm{exact}}(x,y) = \\sin(2\\pi x)\\sin(2\\pi y)$. Then\n$$f(x,y) = \\left(\\big(2\\pi\\big)^2\\big(1^2+1^2\\big)\\right)^2\\,u_{\\mathrm{exact}}(x,y).$$\n- Case B (resolution change): $N = 64$, $u_{\\mathrm{exact}}(x,y) = \\sin(2\\pi x)\\sin(2\\pi y)$. Same $f$ formula as Case A.\n- Case C (superposition of distinct modes): $N = 32$, $u_{\\mathrm{exact}}(x,y) = \\cos(2\\pi x) + \\cos(4\\pi y)$. Then\n$$f(x,y) = \\left(\\big(2\\pi\\big)^2\\big(1^2+0^2\\big)\\right)^2\\cos(2\\pi x) \\;+\\; \\left(\\big(2\\pi\\big)^2\\big(0^2+2^2\\big)\\right)^2\\cos(4\\pi y).$$\n- Case D (odd $N$ and mixed higher modes): $N = 33$, $u_{\\mathrm{exact}}(x,y) = \\sin(6\\pi x)\\sin(2\\pi y) - 2\\cos(2\\pi x)\\cos(6\\pi y)$. Here both $(n_x,n_y)=(3,1)$ and $(n_x,n_y)=(1,3)$ have $n_x^2+n_y^2 = 10$, so\n$$f(x,y) = \\left(\\big(2\\pi\\big)^2\\cdot 10\\right)^2\\sin(6\\pi x)\\sin(2\\pi y) \\;-\\; 2\\left(\\big(2\\pi\\big)^2\\cdot 10\\right)^2\\cos(2\\pi x)\\cos(6\\pi y).$$\n- Case E (edge case with zero forcing): $N = 40$, $u_{\\mathrm{exact}}(x,y) \\equiv 0$, so $f(x,y)\\equiv 0$.\n\nYour program should compute the numerical solution $u_{\\mathrm{num}}$ for each test case and output the corresponding root-mean-square errors as floating-point numbers. Final output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,r_3,r_4,r_5]$), where $r_i$ is the root-mean-square error for Case $i$. No extra text should be printed.",
            "solution": "The problem statement is scrutinized and found to be valid. It presents a well-posed mathematical problem from computational physics, grounded in established principles of partial differential equations and spectral analysis. All data and conditions are sufficient for the derivation of a unique, verifiable numerical solution. I will therefore proceed with a complete solution.\n\nThe problem is to solve the two-dimensional biharmonic equation,\n$$ \\nabla^4 u(x,y) = f(x,y) $$\non a periodic domain $(x,y) \\in [0,1) \\times [0,1)$. The operator $\\nabla^4$ is the bi-Laplacian, defined as $\\nabla^2(\\nabla^2 u)$. The periodicity of the domain makes the Fourier series an ideal choice of basis for representing the solution $u(x,y)$ and the forcing term $f(x,y)$.\n\nA sufficiently smooth, periodic function $g(x,y)$ on this domain can be represented by its complex Fourier series:\n$$ g(x,y) = \\sum_{n_x=-\\infty}^{\\infty} \\sum_{n_y=-\\infty}^{\\infty} \\widehat{g}_{n_x,n_y} e^{i 2\\pi (n_x x + n_y y)} $$\nwhere $n_x$ and $n_y$ are integer wavenumbers, and $\\widehat{g}_{n_x,n_y}$ are the complex Fourier coefficients. A fundamental property of the Fourier series is that spatial differentiation transforms into algebraic multiplication in the Fourier domain. Applying the Laplacian operator $\\nabla^2 = \\frac{\\partial^2}{\\partial x^2} + \\frac{\\partial^2}{\\partial y^2}$ to the function $u(x,y)$ yields:\n$$ \\nabla^2 u(x,y) = \\sum_{n_x,n_y} \\left( (i 2\\pi n_x)^2 + (i 2\\pi n_y)^2 \\right) \\widehat{u}_{n_x,n_y} e^{i 2\\pi (n_x x + n_y y)} = \\sum_{n_x,n_y} -(2\\pi)^2(n_x^2 + n_y^2) \\widehat{u}_{n_x,n_y} e^{i 2\\pi (n_x x + n_y y)} $$\nThe Fourier coefficients of $\\nabla^2 u$ are thus related to those of $u$ by $\\widehat{\\nabla^2 u}_{n_x,n_y} = -K^2 \\widehat{u}_{n_x,n_y}$, where $K^2 = (2\\pi n_x)^2 + (2\\pi n_y)^2 = \\kappa_x^2 + \\kappa_y^2$ is the squared magnitude of the wavevector.\n\nApplying the Laplacian twice, we find the action of the biharmonic operator in Fourier space:\n$$ \\widehat{\\nabla^4 u}_{n_x,n_y} = (-\\kappa_x^2 - \\kappa_y^2)^2 \\widehat{u}_{n_x,n_y} = (\\kappa_x^2 + \\kappa_y^2)^2 \\widehat{u}_{n_x,n_y} $$\nThe original partial differential equation $\\nabla^4 u = f$ thus transforms into a set of algebraic equations for the Fourier coefficients:\n$$ (\\kappa_x^2 + \\kappa_y^2)^2 \\widehat{u}_{n_x,n_y} = \\widehat{f}_{n_x,n_y} $$\nWe can solve for $\\widehat{u}_{n_x,n_y}$:\n$$ \\widehat{u}_{n_x,n_y} = \\frac{\\widehat{f}_{n_x,n_y}}{(\\kappa_x^2 + \\kappa_y^2)^2} = \\frac{\\widehat{f}_{n_x,n_y}}{(2\\pi)^4(n_x^2 + n_y^2)^2} $$\nThis expression is valid for all wavenumbers $(n_x, n_y)$ except for the zero-wavenumber mode $(0,0)$. For this mode, the denominator is zero. The corresponding numerator, $\\widehat{f}_{0,0}$, represents the spatial average of the forcing function $f(x,y)$ over the domain. A necessary condition for the solvability of the biharmonic equation on a periodic domain is that this average must be zero, $\\widehat{f}_{0,0} = 0$. This leads to an indeterminate form $0/0$ for $\\widehat{u}_{0,0}$. The value of $\\widehat{u}_{0,0}$, which is the spatial average of the solution $u(x,y)$, is not determined by the equation. To ensure a unique solution, we enforce the problem's constraint that the solution has a zero mean, which is equivalent to setting $\\widehat{u}_{0,0} = 0$.\n\nThe numerical algorithm implements a discrete analogue of this procedure using the Discrete Fourier Transform (DFT), which is efficiently computed via the Fast Fourier Transform (FFT).\n\nThe algorithm proceeds as follows:\n$1$. The domain $[0,1) \\times [0,1)$ is discretized on a uniform $N \\times N$ grid, with points $(x_j, y_k) = (j/N, k/N)$ for $j, k \\in \\{0, 1, \\dots, N-1\\}$. The forcing function $f(x,y)$ is evaluated on this grid to produce a matrix $F_{jk} = f(x_j, y_k)$.\n\n$2$. A 2D FFT of the matrix $F$ is computed to obtain the discrete Fourier coefficients, $\\widehat{F}$. This is an approximation of $\\widehat{f}_{n_x,n_y}$.\n$$ \\widehat{F} = \\mathrm{FFT2D}(F) $$\n\n$3$. A corresponding $N \\times N$ grid of discrete integer wavenumbers $(n_x, n_y)$ is generated. For a domain of length $1$ discretized with $N$ points, the integer wavenumbers corresponding to the FFT output array are given by the sequence $[0, 1, \\dots, N/2-1, -N/2, \\dots, -1]$ for even $N$ (or a similar sequence for odd $N$), which can be generated using a library function like `numpy.fft.fftfreq`.\n\n$4$. The biharmonic operator is applied in the Fourier domain by dividing the coefficients $\\widehat{F}_{n_x,n_y}$ by the discrete version of the operator symbol, $L_{n_x,n_y} = \\left( (2\\pi n_x)^2 + (2\\pi n_y)^2 \\right)^2$. The zero-wavenumber mode is handled separately.\n$$ \\widehat{U}_{n_x,n_y} = \\begin{cases} \\widehat{F}_{n_x,n_y} / L_{n_x,n_y} & \\text{if } (n_x, n_y) \\neq (0,0) \\\\ 0 & \\text{if } (n_x, n_y) = (0,0) \\end{cases} $$\nThis step correctly handles the singularity and enforces the zero-mean solution constraint.\n\n$5$. The numerical solution on the grid, $U_{\\mathrm{num}}$, is recovered by applying the inverse $2$D FFT to the matrix of coefficients $\\widehat{U}$.\n$$ U_{\\mathrm{num}} = \\mathrm{real}(\\mathrm{IFFT2D}(\\widehat{U})) $$\nThe real part is taken to discard negligible imaginary components arising from floating-point inaccuracies.\n\n$6$. Finally, the root-mean-square error is calculated by comparing the numerical solution $U_{\\mathrm{num}}$ with the exact solution $U_{\\mathrm{exact}}$ evaluated on the grid:\n$$ \\mathrm{RMS} = \\sqrt{\\frac{1}{N^2}\\sum_{j=0}^{N-1}\\sum_{k=0}^{N-1}\\left( (U_{\\mathrm{num}})_{jk} - (U_{\\mathrm{exact}})_{jk} \\right)^2} $$\nThis procedure is applied to each test case to yield the required error values. Since all exact solutions are composed of low-wavenumber sinusoids that are perfectly represented on the specified grids, the expected error is on the order of machine floating-point precision.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 2D biharmonic equation on a periodic domain using a spectral method\n    and calculates the RMS error for several test cases.\n    \"\"\"\n    pi = np.pi\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            'N': 32,\n            'u_exact': lambda x, y: np.sin(2*pi*x) * np.sin(2*pi*y),\n            'f': lambda x, y: ((2*pi)**2 * (1**2 + 1**2))**2 * (np.sin(2*pi*x) * np.sin(2*pi*y))\n        },\n        {\n            'N': 64,\n            'u_exact': lambda x, y: np.sin(2*pi*x) * np.sin(2*pi*y),\n            'f': lambda x, y: ((2*pi)**2 * (1**2 + 1**2))**2 * (np.sin(2*pi*x) * np.sin(2*pi*y))\n        },\n        {\n            'N': 32,\n            'u_exact': lambda x, y: np.cos(2*pi*x) + np.cos(4*pi*y),\n            'f': lambda x, y: ((2*pi)**2 * (1**2 + 0**2))**2 * np.cos(2*pi*x) + \\\n                              ((2*pi)**2 * (0**2 + 2**2))**2 * np.cos(4*pi*y)\n        },\n        {\n            'N': 33,\n            'u_exact': lambda x, y: np.sin(6*pi*x)*np.sin(2*pi*y) - 2*np.cos(2*pi*x)*np.cos(6*pi*y),\n            'f': lambda x, y: ((2*pi)**2 * 10)**2 * np.sin(6*pi*x)*np.sin(2*pi*y) - \\\n                              2*((2*pi)**2 * 10)**2 * np.cos(2*pi*x)*np.cos(6*pi*y)\n        },\n        {\n            'N': 40,\n            'u_exact': lambda x, y: 0.0 * x, # Ensures correct shape (N, N) with all zeros\n            'f': lambda x, y: 0.0 * x\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        N = case['N']\n        u_exact_func = case['u_exact']\n        f_func = case['f']\n\n        # 1. Discretize domain and create grid\n        grid_pts = np.arange(N) / N\n        X, Y = np.meshgrid(grid_pts, grid_pts, indexing='xy')\n\n        # 2. Evaluate exact solution and forcing term on the grid\n        u_exact = u_exact_func(X, Y)\n        f_grid = f_func(X, Y)\n\n        # 3. Solve the PDE using the spectral method\n        \n        # 3a. Forward FFT of the forcing term\n        f_hat = np.fft.fft2(f_grid)\n\n        # 3b. Define discrete integer wavenumbers (modes) n_x, n_y\n        # Using d=1/N in fftfreq scales the result to be the integer mode number.\n        nx = np.fft.fftfreq(N, d=1/N)\n        ny = np.fft.fftfreq(N, d=1/N)\n        NX, NY = np.meshgrid(nx, ny, indexing='xy')\n\n        # 3c. Construct the biharmonic operator symbol in Fourier space\n        # L_hat = ( (2*pi*n_x)^2 + (2*pi*n_y)^2 )^2\n        op_fourier = ((2*pi*NX)**2 + (2*pi*NY)**2)**2\n\n        # 3d. Solve for u_hat, handling the zero-wavenumber mode\n        u_hat = np.zeros_like(f_hat, dtype=complex)\n        \n        # Create a mask for non-zero frequencies to avoid division by zero.\n        # The operator is zero only at the (0,0) frequency.\n        nonzero_mask = op_fourier != 0\n        u_hat[nonzero_mask] = f_hat[nonzero_mask] / op_fourier[nonzero_mask]\n\n        # The zero-mean constraint on u is enforced by setting u_hat[0,0] = 0.\n        # This is already implicitly true because f has zero mean (f_hat[0,0]~0),\n        # but setting it explicitly ensures robustness.\n        u_hat[0, 0] = 0.0\n        \n        # 3e. Inverse FFT to get numerical solution in physical space\n        u_num = np.real(np.fft.ifft2(u_hat))\n\n        # 4. Compute the root-mean-square error\n        rms_error = np.sqrt(np.mean((u_num - u_exact)**2))\n        results.append(rms_error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While Fourier series provide spectrally accurate approximations for smooth periodic functions, they exhibit a significant drawback when dealing with discontinuities, known as the Gibbs phenomenon. This exercise explores this challenge and its practical solution by asking you to apply a Lanczos spectral filter to the Fourier series of a square wave. You will quantify the trade-off between suppressing spurious oscillations and preserving the sharpness of the discontinuity, a crucial skill in signal processing and numerical simulations of shock waves .",
            "id": "2440900",
            "problem": "You are asked to design and evaluate a Lanczos spectral filter for the Fourier representation of a discontinuous function in order to suppress the Gibbs phenomenon while quantifying the trade-off between oscillation reduction and spatial resolution. Consider the square wave $s(x)$ defined on the periodic domain $\\left[-\\pi,\\pi\\right)$ by\n$$\ns(x) =\n\\begin{cases}\n1, & x \\in (0,\\pi),\\\\\n-1, & x \\in (-\\pi,0),\\\\\n\\end{cases}\n$$\nwith $s(0)$ and $s(\\pm \\pi)$ defined by periodicity. Let $s(x)$ have the standard Fourier series representation\n$$\ns(x) = \\frac{a_0}{2} + \\sum_{n=1}^{\\infty} \\left(a_n \\cos(nx) + b_n \\sin(nx)\\right),\n$$\nwith coefficients given by the integrals\n$$\na_n = \\frac{1}{\\pi}\\int_{-\\pi}^{\\pi} s(x)\\cos(nx)\\,dx, \\quad b_n = \\frac{1}{\\pi}\\int_{-\\pi}^{\\pi} s(x)\\sin(nx)\\,dx.\n$$\nFor a given positive integer truncation level $N$, define the unfiltered truncated series\n$$\nS_N(x) = \\frac{a_0}{2} + \\sum_{n=1}^{N} \\left(a_n \\cos(nx) + b_n \\sin(nx)\\right).\n$$\nDefine the Lanczos-filtered truncated series of order $p \\in \\mathbb{N}_0$ (nonnegative integer) by applying the multiplicative spectral factors\n$$\n\\sigma_n^{(p)} = \\left(\\mathrm{sinc}\\!\\left(\\frac{n}{N+1}\\right)\\right)^{p}, \\quad \\mathrm{sinc}(u) = \\begin{cases}\n\\frac{\\sin(\\pi u)}{\\pi u}, & u \\neq 0,\\\\\n1, & u=0,\n\\end{cases}\n$$\nto obtain\n$$\nS_{N,p}^{\\text{(LZ)}}(x) = \\frac{a_0}{2}\\,\\sigma_0^{(p)} + \\sum_{n=1}^{N} \\sigma_n^{(p)}\\left(a_n \\cos(nx) + b_n \\sin(nx)\\right),\n$$\nwhere $\\sigma_0^{(p)} \\equiv 1$. All angles are to be interpreted in radians.\n\nYour task is to compute, for each specified pair $(N,p)$ in the provided test suite, the following two quantitative diagnostics for $S_{N,p}^{\\text{(LZ)}}(x)$ sampled on a uniform grid of $M$ points:\n- The oscillation amplitude near the discontinuity (overshoot magnitude), defined as\n$$\n\\mathcal{O}(N,p) = \\max\\left\\{\\,\\max_{x \\in (0,w_{\\text{ov}}]} \\left(S_{N,p}^{\\text{(LZ)}}(x) - 1\\right),\\ \\max_{x \\in [-w_{\\text{ov}},0)} \\left(-\\big(S_{N,p}^{\\text{(LZ)}}(x)+1\\big)\\right),\\ 0\\,\\right\\},\n$$\nwhich measures the largest positive excursion above the upper plateau or below the lower plateau within a symmetric window of half-width $w_{\\text{ov}}$ around the jump at $x=0$.\n- The effective transition width, defined by the reciprocal of the maximum slope in a neighborhood to the right of the jump,\n$$\n\\mathcal{W}(N,p) = \\frac{2}{\\displaystyle \\max_{x \\in [0,w_{\\text{sl}}]} \\left|\\frac{d}{dx} S_{N,p}^{\\text{(LZ)}}(x)\\right|},\n$$\nwhich quantifies the distance, in radians, required to traverse a unit step height of $2$ at the steepest point near the discontinuity.\n\nUse a uniform grid $x_j = -\\pi + j \\Delta x$ with $j=0,1,\\dots,M-1$, $\\Delta x = \\frac{2\\pi}{M}$, and $M = 16384$. Use $w_{\\text{ov}} = \\frac{\\pi}{4}$ and $w_{\\text{sl}} = \\frac{\\pi}{8}$. When evaluating $\\mathcal{W}(N,p)$, compute the derivative exactly by termwise differentiation of the truncated filtered series, that is,\n$$\n\\frac{d}{dx} S_{N,p}^{\\text{(LZ)}}(x) = -\\sum_{n=1}^{N} \\sigma_n^{(p)} a_n\\, n \\sin(nx) + \\sum_{n=1}^{N} \\sigma_n^{(p)} b_n\\, n \\cos(nx).\n$$\n\nTest suite. Evaluate the ordered list of $(N,p)$ pairs\n$$\n\\big[(9,0),\\ (9,1),\\ (63,0),\\ (63,1),\\ (63,2),\\ (255,1)\\big].\n$$\n\nAnswer specification and units. For each $(N,p)$, produce a pair $[\\mathcal{O}(N,p),\\ \\mathcal{W}(N,p)]$ with both entries expressed as real numbers in radians for $\\mathcal{W}(N,p)$ and dimensionless for $\\mathcal{O}(N,p)$. Round each real number to $6$ decimal places.\n\nFinal output format. Your program should produce a single line of output containing a list of $6$ pairs, each pair formatted as $[\\text{overshoot},\\text{width}]$, and the list enclosed in square brackets, with pairs separated by commas and no additional spaces or text. The final output must therefore have the form\n$$\n\\big[[\\mathcal{O}(N_1,p_1),\\mathcal{W}(N_1,p_1)],\\dots,[\\mathcal{O}(N_6,p_6),\\mathcal{W}(N_6,p_6)]\\big],\n$$\nwith all numbers rounded to $6$ decimal places, and angles in radians.",
            "solution": "The problem statement is subjected to validation and is found to be scientifically sound, well-posed, objective, and self-contained. It presents a standard exercise in computational physics and applied mathematics concerning the application of spectral filters to mitigate the Gibbs phenomenon in Fourier series representations of discontinuous functions. All necessary parameters, definitions, and evaluation metrics are provided unambiguously. Therefore, we may proceed with the solution.\n\nThe core of the problem is to analyze the Fourier series of a square wave and to quantify the effects of a Lanczos spectral filter on its partial sum. The solution involves three primary steps: first, determining the analytical form of the Fourier coefficients; second, constructing the truncated and filtered series representations; and third, numerically evaluating the specified diagnostics for overshoot and transition width.\n\n**1. Fourier Coefficients of the Square Wave**\n\nThe function $s(x)$ is defined on the interval $[-\\pi, \\pi)$ as:\n$$\ns(x) =\n\\begin{cases}\n1, & x \\in (0,\\pi),\\\\\n-1, & x \\in (-\\pi,0).\n\\end{cases}\n$$\nThis is an odd function, satisfying $s(-x) = -s(x)$. The Fourier series is given by\n$$\ns(x) = \\frac{a_0}{2} + \\sum_{n=1}^{\\infty} \\left(a_n \\cos(nx) + b_n \\sin(nx)\\right).\n$$\nFor an odd function integrated over a symmetric interval $[-\\pi, \\pi]$, the cosine coefficients $a_n$ are identically zero. The integrand for $a_n$, which is $s(x)\\cos(nx)$, is an odd function (odd $\\times$ even), and its integral over $[-\\pi, \\pi]$ is zero.\n$$\na_n = \\frac{1}{\\pi}\\int_{-\\pi}^{\\pi} s(x)\\cos(nx)\\,dx = 0, \\quad \\text{for all } n \\ge 0.\n$$\nThe sine coefficients $b_n$ are non-zero. The integrand $s(x)\\sin(nx)$ is an even function (odd $\\times$ odd), so the integral can be simplified:\n$$\nb_n = \\frac{1}{\\pi}\\int_{-\\pi}^{\\pi} s(x)\\sin(nx)\\,dx = \\frac{2}{\\pi}\\int_{0}^{\\pi} s(x)\\sin(nx)\\,dx.\n$$\nSubstituting $s(x) = 1$ for $x \\in (0, \\pi)$:\n$$\nb_n = \\frac{2}{\\pi}\\int_{0}^{\\pi} \\sin(nx)\\,dx = \\frac{2}{\\pi} \\left[-\\frac{\\cos(nx)}{n}\\right]_{0}^{\\pi} = \\frac{2}{n\\pi} \\left(-\\cos(n\\pi) + \\cos(0)\\right).\n$$\nUsing the identity $\\cos(n\\pi) = (-1)^n$, we get:\n$$\nb_n = \\frac{2}{n\\pi}(1 - (-1)^n).\n$$\nThese coefficients are zero for even $n$ and non-zero for odd $n$:\n$$\nb_n =\n\\begin{cases}\n\\frac{4}{n\\pi}, & \\text{if } n \\text{ is odd},\\\\\n0, & \\text{if } n \\text{ is even}.\n\\end{cases}\n$$\n\n**2. Lanczos-Filtered Truncated Series**\n\nSince $a_n=0$ for all $n$, the truncated Fourier series $S_N(x)$ and its Lanczos-filtered version $S_{N,p}^{\\text{(LZ)}}(x)$ simplify to sums of sine terms only:\n$$\nS_{N,p}^{\\text{(LZ)}}(x) = \\sum_{n=1}^{N} \\sigma_n^{(p)} b_n \\sin(nx),\n$$\nwhere the Lanczos filter factors are given by $\\sigma_n^{(p)} = \\left(\\mathrm{sinc}\\!\\left(\\frac{n}{N+1}\\right)\\right)^{p}$. The purpose of these factors is to smoothly reduce the magnitude of the coefficients $b_n$ as $n$ approaches the truncation level $N$, thereby damping the high-frequency oscillations that cause the Gibbs phenomenon. For $p=0$, $\\sigma_n^{(0)}=1$, corresponding to the unfiltered series. For $p > 0$, the filter becomes progressively more aggressive.\n\nThe derivative of the filtered series is required for calculating the transition width. It is obtained by term-by-term differentiation:\n$$\n\\frac{d}{dx} S_{N,p}^{\\text{(LZ)}}(x) = \\sum_{n=1}^{N} \\sigma_n^{(p)} b_n\\, n \\cos(nx).\n$$\n\n**3. Numerical Evaluation and Diagnostics**\n\nWe will evaluate the series and its derivative on a fine uniform grid of $M=16384$ points spanning the domain $[-\\pi, \\pi)$. Let the grid points be $x_j = -\\pi + j(2\\pi/M)$ for $j = 0, 1, \\dots, M-1$.\n\nFor each pair $(N,p)$ from the test suite, we perform the following computations:\n\n**a) Overshoot Amplitude $\\mathcal{O}(N,p)$:**\nThe overshoot is the maximum deviation from the plateau values of $\\pm 1$ near the discontinuity at $x=0$. It is calculated as:\n$$\n\\mathcal{O}(N,p) = \\max\\left\\{\\,\\max_{x_j \\in (0,w_{\\text{ov}}]} \\left(S_{N,p}^{\\text{(LZ)}}(x_j) - 1\\right),\\ \\max_{x_j \\in [-w_{\\text{ov}},0)} \\left(-\\big(S_{N,p}^{\\text{(LZ)}}(x_j)+1\\big)\\right),\\ 0\\,\\right\\},\n$$\nwith $w_{\\text{ov}} = \\pi/4$. We identify the grid points falling within the two windows $(0, \\pi/4]$ and $[-\\pi/4, 0)$, evaluate the series $S_{N,p}^{\\text{(LZ)}}(x_j)$ at these points, and compute the maximum deviations. By symmetry of the problem, the overshoot above the top plateau and below the bottom plateau will be equal.\n\n**b) Effective Transition Width $\\mathcal{W}(N,p)$:**\nThe transition width quantifies the \"steepness\" of the series as it crosses the discontinuity. A smaller width implies a sharper transition, which is desirable. It is defined as the reciprocal of the maximum slope near the jump, scaled by the total jump height of $2$:\n$$\n\\mathcal{W}(N,p) = \\frac{2}{\\displaystyle \\max_{x_j \\in [0,w_{\\text{sl}}]} \\left|\\frac{d}{dx} S_{N,p}^{\\text{(LZ)}}(x_j)\\right|},\n$$\nwith $w_{\\text{sl}} = \\pi/8$. We evaluate the derivative on the grid points within the window $[0, \\pi/8]$, find the maximum absolute value, and compute the width $\\mathcal{W}$. An increase in filtering ($p>0$) is expected to decrease the maximum slope, thus increasing the transition width $\\mathcal{W}$, demonstrating the trade-off between oscillation suppression and spatial resolution.\n\nThe numerical implementation will be vectorized for efficiency. For each $(N,p)$, we pre-compute the arrays of coefficients $b_n$ and $\\sigma_n^{(p)}$. The series and its derivative can then be evaluated at all grid points $x_j$ using matrix multiplication between the coefficient vectors and matrices of trigonometric function values, $\\sin(nx_j)$ and $\\cos(nx_j)$.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes Lanczos-filtered Fourier series diagnostics for a square wave.\n    \"\"\"\n    # Problem parameters\n    M = 16384\n    w_ov = np.pi / 4\n    w_sl = np.pi / 8\n    test_cases = [\n        (9, 0),\n        (9, 1),\n        (63, 0),\n        (63, 1),\n        (63, 2),\n        (255, 1)\n    ]\n\n    # Create the uniform grid for x\n    delta_x = 2 * np.pi / M\n    x = np.arange(M) * delta_x - np.pi\n\n    final_results = []\n\n    for N, p in test_cases:\n        # Array of mode numbers from 1 to N\n        n = np.arange(1, N + 1)\n\n        # 1. Compute Fourier and filter coefficients\n        # Fourier coefficients b_n for the square wave\n        b_n = np.zeros(N)\n        odd_indices = (n % 2) != 0\n        n_odd = n[odd_indices]\n        b_n[odd_indices] = 4 / (n_odd * np.pi)\n\n        # Lanczos filter coefficients sigma_n\n        if p == 0:\n            sigma_n = np.ones(N)\n        else:\n            # np.sinc(u) calculates sin(pi*u)/(pi*u)\n            u = n / (N + 1)\n            sigma_n = np.sinc(u)**p\n\n        # Combined coefficients for the series and its derivative\n        # For S(x): c_n = sigma_n * b_n\n        c_n = sigma_n * b_n\n        # For dS/dx(x): d_n = c_n * n\n        d_n = c_n * n\n\n        # 2. Evaluate the series and its derivative on the grid\n        # Reshape for broadcasting (n as column, x as row)\n        n_col = n.reshape(-1, 1)\n        x_row = x.reshape(1, -1)\n\n        # S(x) = sum(c_n * sin(n*x))\n        sin_matrix = np.sin(n_col * x_row)\n        S_x = c_n @ sin_matrix\n\n        # dS/dx(x) = sum(d_n * cos(n*x))\n        cos_matrix = np.cos(n_col * x_row)\n        S_prime_x = d_n @ cos_matrix\n        \n        # 3. Calculate diagnostics\n        \n        # --- Overshoot O(N, p) ---\n        # Window for upper overshoot: (0, w_ov]\n        idx_upper = (x > 0)  (x = w_ov)\n        overshoot_upper = np.max(S_x[idx_upper] - 1) if np.any(idx_upper) else -np.inf\n\n        # Window for lower overshoot: [-w_ov, 0)\n        idx_lower = (x >= -w_ov)  (x  0)\n        overshoot_lower = np.max(-(S_x[idx_lower] + 1)) if np.any(idx_lower) else -np.inf\n\n        O = np.max([overshoot_upper, overshoot_lower, 0.0])\n\n        # --- Transition Width W(N, p) ---\n        # Window for slope: [0, w_sl]\n        idx_slope = (x >= 0)  (x = w_sl)\n        \n        max_slope = 0.0\n        if np.any(idx_slope):\n            max_slope = np.max(np.abs(S_prime_x[idx_slope]))\n        \n        W = 2.0 / max_slope if max_slope > 0 else np.inf\n\n        final_results.append((O, W))\n\n    # 4. Format the output string as per problem specification\n    formatted_pairs = []\n    for O, W in final_results:\n        # Round each value to 6 decimal places before formatting\n        O_rounded = round(O, 6)\n        W_rounded = round(W, 6)\n        formatted_pairs.append(f\"[{O_rounded:.6f},{W_rounded:.6f}]\")\n    \n    print(f\"[{','.join(formatted_pairs)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Many physical problems are defined on bounded, non-periodic domains, where Fourier methods are not directly applicable. This practice introduces the powerful Chebyshev spectral collocation method to tackle such boundary-value problems. By solving the 2D Poisson equation on a rectangular domain, you will learn to use Chebyshev differentiation matrices and implement the machinery for handling general non-periodic boundary conditions, significantly expanding your computational toolkit .",
            "id": "2440925",
            "problem": "Consider the two-dimensional Poisson equation on a rectangle,\n$$\\nabla^2 u(x,y) = f(x,y), \\quad (x,y)\\in [a_x,b_x]\\times [a_y,b_y],$$\nsubject to Dirichlet boundary conditions\n$$u(x,y) = g(x,y) \\quad \\text{for } (x,y) \\in \\partial([a_x,b_x]\\times [a_y,b_y]),$$\nwhere $\\nabla^2$ denotes the Laplacian with respect to the physical coordinates $x$ and $y$. For each test case below, the exact solution $u(x,y)$ is specified; use it to define the boundary condition $g(x,y)$ on the boundary and the source function $f(x,y) = \\nabla^2 u(x,y)$ in the interior.\n\nYour task is to write a complete, runnable program that, for each test case, computes a numerical approximation to $u(x,y)$ on a tensor-product grid of size $N_x \\times N_y$ including boundary points, and returns the maximum pointwise absolute error between the numerical approximation and the exact solution over all grid points in the domain.\n\nTest suite (each line is one case, providing the rectangle, grid sizes, and exact solution):\n- Case $1$: $[a_x,b_x]=[-1,1]$, $[a_y,b_y]=[-1,1]$, $N_x=24$, $N_y=24$, exact solution\n  $$u(x,y) = \\sin(\\pi x)\\sin(\\pi y).$$\n- Case $2$: $[a_x,b_x]=[0,1]$, $[a_y,b_y]=[0,2]$, $N_x=30$, $N_y=28$, exact solution\n  $$u(x,y) = x(1-x)\\,y(2-y).$$\n- Case $3$: $[a_x,b_x]=[-2,3]$, $[a_y,b_y]=[-1,1]$, $N_x=22$, $N_y=18$, exact solution\n  $$u(x,y) = e^{x}\\,(1-y^2).$$\n- Case $4$: $[a_x,b_x]=[-1,1]$, $[a_y,b_y]=[-1,1]$, $N_x=8$, $N_y=8$, exact solution\n  $$u(x,y) = 0.$$\n\nFor each case, compute $f(x,y)=\\nabla^2 u(x,y)$ in the physical coordinates $(x,y)$ and impose the Dirichlet boundary values from $u(x,y)$ on all sides of the rectangle.\n\nRequired final output format: Your program should produce a single line of output containing a list of the maximum absolute errors for the $4$ cases, formatted as a comma-separated list of decimal numbers in scientific notation with $10$ significant digits, enclosed in square brackets. For example,\n$$[1.2345678900e-06,3.2100000000e-08,9.9900000000e-10,0.0000000000e+00].$$\n\nAll quantities are dimensionless, and there are no physical units to report. Angles, if any appear in intermediate expressions, must be interpreted in radians. The final answers must be dimensionless real numbers as specified above.",
            "solution": "The user has provided a valid problem statement. The task is to solve the two-dimensional Poisson equation with Dirichlet boundary conditions on a rectangular domain using a numerical method. The problem is well-posed, scientifically sound, and all necessary parameters are provided for each of the four test cases.\n\nThe chosen method is a Chebyshev spectral collocation method, renowned for its high accuracy for problems with smooth solutions. The methodology involves the following steps:\n\n1.  **Domain Mapping and Discretization**: The physical rectangular domain $[a_x,b_x]\\times[a_y,b_y]$ is mapped to the canonical computational domain $[-1,1]\\times[-1,1]$. This computational domain is then discretized using a tensor-product grid of Chebyshev-Gauss-Lobatto points. The grid dimensions are $N_x \\times N_y$ as specified for each test case. The affine mapping is defined as:\n    $$x(\\xi) = \\frac{b_x - a_x}{2} \\xi + \\frac{b_x + a_x}{2}$$\n    $$y(\\eta) = \\frac{b_y - a_y}{2} \\eta + \\frac{b_y + a_y}{2}$$\n    where $(\\xi, \\eta) \\in [-1,1]\\times[-1,1]$ are the computational coordinates. The grid points are $\\xi_i = \\cos(\\frac{i\\pi}{N_x-1})$ and $\\eta_j = \\cos(\\frac{j\\pi}{N_y-1})$.\n\n2.  **Transformed Equation**: The Laplacian operator is transformed into the computational coordinates $(\\xi, \\eta)$. The chain rule gives:\n    $$\\nabla^2 u = \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2} = \\left(\\frac{2}{b_x-a_x}\\right)^2 \\frac{\\partial^2 u}{\\partial \\xi^2} + \\left(\\frac{2}{b_y-a_y}\\right)^2 \\frac{\\partial^2 u}{\\partial \\eta^2}$$\n    Letting $c_x = (2/(b_x-a_x))^2$ and $c_y = (2/(b_y-a_y))^2$, the PDE becomes $c_x u_{\\xi\\xi} + c_y u_{\\eta\\eta} = f$.\n\n3.  **Spectral Operator Discretization**: The partial derivatives with respect to $\\xi$ and $\\eta$ are approximated using Chebyshev differentiation matrices. Let $U$ be the $N_x \\times N_y$ matrix representing the solution at the grid points. The discrete form of the PDE is:\n    $$c_x D_{xx} U + c_y U D_{yy}^T = F$$\n    where $D_{xx}$ and $D_{yy}$ are the second-order Chebyshev differentiation matrices for the $x$ and $y$ directions, respectively, and $F$ is the matrix of the source function evaluated at the grid points.\n\n4.  **Linear System Formulation**: To employ a standard linear solver, the matrix equation is converted into a large linear system $\\mathcal{L}\\vec{u} = \\vec{f}$ by flattening the $N_x \\times N_y$ matrices into vectors of size $N_x N_y$. Using the row-major `flatten` operation and the Kronecker product, the operator matrix $\\mathcal{L}$ is constructed as:\n    $$\\mathcal{L} = c_x(D_{xx} \\otimes I_y) + c_y(I_x \\otimes D_{yy})$$\n    where $I_x$ and $I_y$ are identity matrices of appropriate sizes.\n\n5.  **Imposition of Boundary Conditions**: The Dirichlet boundary conditions specify the values of $u$ on the boundary of the domain. These conditions are enforced directly into the linear system. For each boundary grid point, the corresponding row in the matrix $\\mathcal{L}$ is modified to represent an identity equation, and the corresponding entry in the right-hand-side vector $\\vec{f}$ is set to the known boundary value from the exact solution.\n\n6.  **Solution and Error Analysis**: The resulting linear system is solved for the unknown grid point values $\\vec{u}$. The solution vector is reshaped back into an $N_x \\times N_y$ matrix, $U_{\\text{num}}$. The accuracy of the numerical solution is quantified by computing the maximum pointwise absolute error against the exact solution, $U_{\\text{exact}}$, evaluated on the same grid:\n    $$\\text{Error} = \\max_{i,j} |(U_{\\text{num}})_{ij} - (U_{\\text{exact}})_{ij}|$$\n\nFor each test case, the source function $f(x,y)$ is derived by analytically computing the Laplacian of the given exact solution $u(x,y)$:\n-   Case $1$: $u(x,y) = \\sin(\\pi x)\\sin(\\pi y) \\implies \\nabla^2 u = -2\\pi^2\\sin(\\pi x)\\sin(\\pi y)$.\n-   Case $2$: $u(x,y) = x(1-x)y(2-y) \\implies \\nabla^2 u = -2y(2-y) - 2x(1-x)$.\n-   Case $3$: $u(x,y) = e^{x}(1-y^2) \\implies \\nabla^2 u = e^x(1-y^2) - 2e^x = -e^x(1+y^2)$.\n-   Case $4$: $u(x,y) = 0 \\implies \\nabla^2 u = 0$.\n\nThe following program implements this strategy for each of the specified cases.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef chebyshev_diff_matrix(N):\n    \"\"\"\n    Computes the first-order Chebyshev differentiation matrix on N points.\n    \n    Args:\n        N (int): The number of collocation points.\n\n    Returns:\n        np.ndarray: The (N, N) differentiation matrix.\n    \"\"\"\n    if N = 1:\n        return np.array([[0.0]])\n\n    x = np.cos(np.pi * np.arange(N) / (N - 1))\n    c = np.ones(N)\n    c[0] = 2.0\n    c[-1] = 2.0\n\n    # Create a broadcast-ready version of x and c\n    x_col = x[:, np.newaxis]\n    c_col = c[:, np.newaxis]\n    \n    # Compute off-diagonal elements\n    dX = x_col - x\n    D = (c_col / c) * ((-1)**(np.arange(N)[:, np.newaxis] + np.arange(N))) / (dX + np.eye(N))\n    np.fill_diagonal(D, 0.0)\n\n    # Compute diagonal elements\n    D[np.diag_indices_from(D)] = -np.sum(D, axis=1)\n\n    return D\n\ndef solve_poisson_2d(params):\n    \"\"\"\n    Solves the 2D Poisson equation on a rectangular domain using a Chebyshev spectral method.\n    \n    Args:\n        params (tuple): A tuple containing (ax, bx, ay, by, Nx, Ny, u_exact_func, f_source_func).\n\n    Returns:\n        float: The maximum pointwise absolute error.\n    \"\"\"\n    ax, bx, ay, by, Nx, Ny, u_exact_func, f_source_func = params\n    \n    # 1. Coordinate transformation factors\n    dx = bx - ax\n    dy = by - ay\n    cx = (2.0 / dx)**2\n    cy = (2.0 / dy)**2\n\n    # 2. Chebyshev differentiation matrices\n    Dx = chebyshev_diff_matrix(Nx)\n    Dxx = Dx @ Dx\n    Dy = chebyshev_diff_matrix(Ny)\n    Dyy = Dy @ Dy\n\n    # 3. Construct the 2D operator matrix using Kronecker products (row-major)\n    Ix = np.identity(Nx)\n    Iy = np.identity(Ny)\n    L_op = cx * np.kron(Dxx, Iy) + cy * np.kron(Ix, Dyy)\n\n    # 4. Create the physical grid\n    xi = np.cos(np.pi * np.arange(Nx) / (Nx - 1))\n    eta = np.cos(np.pi * np.arange(Ny) / (Ny - 1))\n    \n    # Map from computational [-1, 1] to physical [a, b]\n    # Note: xi and eta run from 1 down to -1.\n    x_1d = (bx - ax) / 2.0 * xi + (ax + bx) / 2.0\n    y_1d = (by - ay) / 2.0 * eta + (ay + by) / 2.0\n    \n    # Create a meshgrid consistent with matrix indexing ('ij')\n    X, Y = np.meshgrid(x_1d, y_1d, indexing='ij')\n\n    # 5. Evaluate source term and exact solution on the grid\n    F = f_source_func(X, Y)\n    U_exact = u_exact_func(X, Y)\n\n    # 6. Flatten RHS and prepare for boundary condition imposition\n    f_flat = F.flatten() # Row-major\n    u_exact_flat = U_exact.flatten()\n\n    # 7. Identify boundary points\n    is_bnd = np.zeros_like(X, dtype=bool)\n    is_bnd[0, :] = True\n    is_bnd[-1, :] = True\n    is_bnd[:, 0] = True\n    is_bnd[:, -1] = True\n    bnd_indices = np.where(is_bnd.flatten())[0]\n\n    # 8. Impose Dirichlet boundary conditions\n    for k in bnd_indices:\n        L_op[k, :] = 0.0\n        L_op[k, k] = 1.0\n        f_flat[k] = u_exact_flat[k]\n        \n    # 9. Solve the linear system\n    u_num_flat = np.linalg.solve(L_op, f_flat)\n    \n    # 10. Reshape solution and calculate error\n    U_num = u_num_flat.reshape((Nx, Ny))\n    max_error = np.max(np.abs(U_num - U_exact))\n    \n    return max_error\n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        (-1.0, 1.0, -1.0, 1.0, 24, 24,\n         lambda x, y: np.sin(np.pi * x) * np.sin(np.pi * y),\n         lambda x, y: -2 * np.pi**2 * np.sin(np.pi * x) * np.sin(np.pi * y)),\n        \n        # Case 2\n        (0.0, 1.0, 0.0, 2.0, 30, 28,\n         lambda x, y: x * (1 - x) * y * (2 - y),\n         lambda x, y: -2 * y * (2 - y) - 2 * x * (1 - x)),\n        \n        # Case 3\n        (-2.0, 3.0, -1.0, 1.0, 22, 18,\n         lambda x, y: np.exp(x) * (1 - y**2),\n         lambda x, y: -np.exp(x) * (1 + y**2)),\n        \n        # Case 4\n        (-1.0, 1.0, -1.0, 1.0, 8, 8,\n         lambda x, y: 0.0 * x * y,\n         lambda x, y: 0.0 * x * y)\n    ]\n\n    results = []\n    for case in test_cases:\n        error = solve_poisson_2d(case)\n        results.append(f\"{error:.10e}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}