{
    "hands_on_practices": [
        {
            "introduction": "所有有限差分格式的基础是泰勒级数展开。这个练习将指导你通过“待定系数法”，从零开始为一个前向差分格式推导其权重系数。掌握这项技能，你就能揭开那些看似任意的系数数字背后的数学原理，这是成为一名合格的计算科学家的关键一步。",
            "id": "2401286",
            "problem": "考虑一个足够光滑的函数 $f$，它定义在一个包含均匀网格节点 $x_i, x_{i+1}, x_{i+2}, x_{i+3}, x_{i+4}$ 的区间上。该网格的间距为 $h > 0$，其中 $x_{j} = x_{0} + j h$。假设 $f$ 在 $[x_i, x_{i+4}]$ 上至少有5阶连续导数。仅使用 $f(x_i)$, $f(x_{i+1})$, $f(x_{i+2})$, $f(x_{i+3})$ 和 $f(x_{i+4})$ 的值，构造一个关于一阶导数 $f'(x_i)$ 的向前差分近似，其精度达到 $h^{4}$ 阶（即，截断误差为 $\\mathcal{O}(h^{4})$ 阶）。\n\n确定唯一的系数 $a_0, a_1, a_2, a_3, a_4 \\in \\mathbb{R}$，使得\n$$\nf'(x_i) \\approx \\frac{1}{h}\\sum_{k=0}^{4} a_k\\, f(x_{i+k})\n$$\n达到四阶精度，并以单个解析表达式的形式给出最终的闭式近似。\n\n答案规格：\n- 以 $f(x_{i+k})$ 和 $h$ 表示的、关于 $f'(x_i)$ 近似的单个闭式解析表达式的形式提供最终结果。\n- 无需四舍五入。",
            "solution": "给定问题是数值分析领域中一个标准且适定的练习，具体涉及有限差分公式的推导。该问题在科学上是合理的，逻辑上是一致的，并且所有必需的信息都已提供。因此，该问题是有效的，我将着手解决它。\n\n目标是找到近似公式\n$$\nf'(x_i) \\approx \\frac{1}{h}\\sum_{k=0}^{4} a_k f(x_{i+k})\n$$\n的系数 $a_0, a_1, a_2, a_3, a_4$，使得截断误差为 $\\mathcal{O}(h^4)$ 阶。这是使用泰勒级数展开的待定系数法的直接应用。\n\n函数 $f$ 被假设为足够光滑，这使我们能够将每一项 $f(x_{i+k})$ 在点 $x_i$ 附近进行泰勒级数展开。展开式如下：\n$$\nf(x_{i+k}) = f(x_i + kh) = \\sum_{j=0}^{\\infty} \\frac{(kh)^j}{j!} f^{(j)}(x_i)\n$$\n其中 $f^{(j)}(x_i)$ 表示 $f$ 在 $x_i$ 处的 $j$ 阶导数。\n\n将此展开式代入有限差分公式，我们得到：\n$$\n\\frac{1}{h}\\sum_{k=0}^{4} a_k f(x_{i+k}) = \\frac{1}{h}\\sum_{k=0}^{4} a_k \\left( \\sum_{j=0}^{\\infty} \\frac{(kh)^j}{j!} f^{(j)}(x_i) \\right)\n$$\n通过交换求和顺序（在此是允许的），我们得到：\n$$\n\\frac{1}{h}\\sum_{j=0}^{\\infty} \\frac{h^j f^{(j)}(x_i)}{j!} \\left( \\sum_{k=0}^{4} k^j a_k \\right)\n$$\n我们希望这个表达式能够以 $\\mathcal{O}(h^4)$ 的截断误差近似 $f'(x_i)$。这意味着当我们将表达式按 $h$ 的幂次展开时，$f'(x_i)$ 的系数必须为 $1$，而 $f(x_i)$, $f''(x_i)$, $f'''(x_i)$ 和 $f^{(4)}(x_i)$ 的系数必须为 $0$。\n\n让我们考察 $j=0, 1, 2, 3, 4$ 时的各项：\n\\begin{itemize}\n    \\item 当 $j=0$ 时：该项为 $\\frac{1}{h} \\frac{h^0 f^{(0)}(x_i)}{0!} \\left( \\sum_{k=0}^{4} a_k \\right) = \\frac{f(x_i)}{h} \\sum_{k=0}^{4} a_k$。为了消去此项，我们必须有：\n    $$ \\sum_{k=0}^{4} a_k = 0 $$\n    \\item 当 $j=1$ 时：该项为 $\\frac{1}{h} \\frac{h^1 f^{(1)}(x_i)}{1!} \\left( \\sum_{k=0}^{4} k a_k \\right) = f'(x_i) \\sum_{k=0}^{4} k a_k$。为了使其等于 $f'(x_i)$，我们要求：\n    $$ \\sum_{k=0}^{4} k a_k = 1 $$\n    \\item 当 $j=2$ 时：该项为 $\\frac{1}{h} \\frac{h^2 f^{(2)}(x_i)}{2!} \\left( \\sum_{k=0}^{4} k^2 a_k \\right) = \\frac{h f''(x_i)}{2} \\sum_{k=0}^{4} k^2 a_k$。为了消去 $\\mathcal{O}(h)$ 阶误差项，我们必须有：\n    $$ \\sum_{k=0}^{4} k^2 a_k = 0 $$\n    \\item 当 $j=3$ 时：该项为 $\\frac{1}{h} \\frac{h^3 f^{(3)}(x_i)}{3!} \\left( \\sum_{k=0}^{4} k^3 a_k \\right) = \\frac{h^2 f'''(x_i)}{6} \\sum_{k=0}^{4} k^3 a_k$。为了消去 $\\mathcal{O}(h^2)$ 阶误差项：\n    $$ \\sum_{k=0}^{4} k^3 a_k = 0 $$\n    \\item 当 $j=4$ 时：该项为 $\\frac{1}{h} \\frac{h^4 f^{(4)}(x_i)}{4!} \\left( \\sum_{k=0}^{4} k^4 a_k \\right) = \\frac{h^3 f^{(4)}(x_i)}{24} \\sum_{k=0}^{4} k^4 a_k$。为了消去 $\\mathcal{O}(h^3)$ 阶误差项：\n    $$ \\sum_{k=0}^{4} k^4 a_k = 0 $$\n\\end{itemize}\n截断误差的首项将是 $j=5$ 时的项，其阶数为 $\\mathcal{O}(h^4)$，这符合题目的要求。\n\n这五个条件给出了关于五个未知系数 $a_0, a_1, a_2, a_3, a_4$ 的五元线性方程组：\n\\begin{align*}\n    a_0 + a_1 + a_2 + a_3 + a_4 = 0 \\\\\n    0 \\cdot a_0 + 1 \\cdot a_1 + 2 \\cdot a_2 + 3 \\cdot a_3 + 4 \\cdot a_4 = 1 \\\\\n    0^2 a_0 + 1^2 a_1 + 2^2 a_2 + 3^2 a_3 + 4^2 a_4 = 0 \\\\\n    0^3 a_0 + 1^3 a_1 + 2^3 a_2 + 3^3 a_3 + 4^3 a_4 = 0 \\\\\n    0^4 a_0 + 1^4 a_1 + 2^4 a_2 + 3^4 a_3 + 4^4 a_4 = 0\n\\end{align*}\n该方程组可以写成矩阵形式：\n$$\n\\begin{pmatrix}\n1  1  1  1  1 \\\\\n0  1  2  3  4 \\\\\n0  1  4  9  16 \\\\\n0  1  8  27  64 \\\\\n0  1  16  81  256\n\\end{pmatrix}\n\\begin{pmatrix} a_0 \\\\ a_1 \\\\ a_2 \\\\ a_3 \\\\ a_4 \\end{pmatrix}\n=\n\\begin{pmatrix} 0 \\\\ 1 \\\\ 0 \\\\ 0 \\\\ 0 \\end{pmatrix}\n$$\n关于 $a_1, a_2, a_3, a_4$ 的子系统涉及一个范德蒙型矩阵。求解这个 $4 \\times 4$ 的系统，然后用第一个方程求出 $a_0$ 是一个直接但繁琐的过程。该系统的唯一解是：\n$$ a_0 = -\\frac{25}{12}, \\quad a_1 = 4, \\quad a_2 = -3, \\quad a_3 = \\frac{4}{3}, \\quad a_4 = -\\frac{1}{4} $$\n为了便于得到一个更简洁的最终表达式，我们可以将这些系数写成以 12 为公分母的形式：\n$$ a_0 = -\\frac{25}{12}, \\quad a_1 = \\frac{48}{12}, \\quad a_2 = -\\frac{36}{12}, \\quad a_3 = \\frac{16}{12}, \\quad a_4 = -\\frac{3}{12} $$\n将这些系数代入近似公式：\n$$\nf'(x_i) \\approx \\frac{1}{h} \\left( -\\frac{25}{12}f(x_i) + \\frac{48}{12}f(x_{i+1}) - \\frac{36}{12}f(x_{i+2}) + \\frac{16}{12}f(x_{i+3}) - \\frac{3}{12}f(x_{i+4}) \\right)\n$$\n提取公分母 12，得到一阶导数的四阶精度向前差分近似的最终闭式表达式：\n$$\nf'(x_i) \\approx \\frac{1}{12h} \\left( -25f(x_i) + 48f(x_{i+1}) - 36f(x_{i+2}) + 16f(x_{i+3}) - 3f(x_{i+4}) \\right)\n$$\n推导至此完成。",
            "answer": "$$\\boxed{\\frac{1}{12h} \\left( -25f(x_i) + 48f(x_{i+1}) - 36f(x_{i+2}) + 16f(x_{i+3}) - 3f(x_{i+4}) \\right)}$$"
        },
        {
            "introduction": "在掌握了显式格式的推导后，我们将探索性能更优越的隐式或“紧致”格式。此练习不仅要求你推导并实现一个四阶紧致格式（这需要求解一个循环线性方程组），还将引导你完成两个至关重要的分析步骤：通过数值实验验证其理论精度，并分析其谱特性（即色散关系）。这个从理论推导到实现分析的完整流程，将让你深刻理解紧致格式为何在处理波现象时通常更受欢迎。",
            "id": "2401303",
            "problem": "实现一种在周期性均匀网格上近似一阶导数的紧致有限差分法，并仅使用可从泰勒级数和傅里叶分析推导出的原理来分析其谱特性。\n\n您必须从以下基本依据出发：\n- 对于一个足够光滑的函数 $f$ ，其在点 $x$ 处的一阶导数定义为 $f^{\\prime}(x) = \\lim_{h \\to 0} \\frac{f(x+h) - f(x)}{h}$。\n- 一个光滑函数在点 $x$ 附近的泰勒级数为 $f(x \\pm h) = f(x) \\pm h f^{\\prime}(x) + \\frac{h^{2}}{2} f^{\\prime\\prime}(x) \\pm \\frac{h^{3}}{6} f^{(3)}(x) + \\frac{h^{4}}{24} f^{(4)}(x) \\pm \\frac{h^{5}}{120} f^{(5)}(x) + \\cdots$。\n- 在间距为 $h$ 的周期性均匀网格 $x_{j} = x_{0} + j h$ 上，一个离散傅里叶模为 $e^{i k x_{j}}$，其中 $i$ 是虚数单位，$k$ 是波数。无量纲波数为 $\\theta = k h$（单位为弧度）。\n\n任务 A（紧致格式系数的推导）：\n- 假设一阶导数采用形式为 $\\alpha f^{\\prime}_{i-1} + f^{\\prime}_{i} + \\alpha f^{\\prime}_{i+1} = \\frac{\\beta}{h} \\left(f_{i+1} - f_{i-1}\\right)$ 的隐式、三点、对称紧致Padé格式，其中 $\\alpha$ 和 $\\beta$ 是与 $h$ 和索引 $i$ 无关的常数。\n- 利用关于 $x_i$ 点的泰勒级数相容性，确定 $\\alpha$ 和 $\\beta$ 的值，使得截断误差为 $h^{4}$ 阶，即该格式达到四阶精度。\n\n任务 B（在周期性网格上的实现）：\n- 在具有周期性边界条件的定义域 $[0,1)$ 上，使用任务 A 中推导出的系数 $(\\alpha,\\beta)$，构建由紧致格式所蕴含的线性系统，以根据均匀网格上 $N$ 个点的采样函数值 $\\boldsymbol{f}$ 计算离散导数向量 $\\boldsymbol{d}$。\n- 由于周期性，作用于 $\\boldsymbol{d}$ 的矩阵是带有回卷（循环）项的三对角矩阵。\n\n任务 C（观测精度阶测试）：\n- 使用函数 $f(x) = \\sin(2 \\pi x)$ 及其精确导数 $f^{\\prime}(x) = 2 \\pi \\cos(2 \\pi x)$，在定义域 $[0,1)$ 上，对 $N \\in \\{32, 64, 128\\}$ 的情况，计算离散导数与精确导数之间的最大范数误差 $E_{\\infty}(N)$。\n- 计算观测阶数 $p_{32 \\to 64} = \\log_{2}\\left( \\frac{E_{\\infty}(32)}{E_{\\infty}(64)} \\right)$ 和 $p_{64 \\to 128} = \\log_{2}\\left( \\frac{E_{\\infty}(64)}{E_{\\infty}(128)} \\right)$。\n\n任务 D（谱色散与耗散分析）：\n- 对于一个周期性、线性、位移不变的离散导数算子，傅里叶模 $e^{i k x}$ 是一个特征函数：应用该算子会得到 $i \\tilde{k} e^{i k x}$，其中 $\\tilde{k}$ 是某个修正波数。定义无量纲修正波数为 $\\tilde{\\theta} = \\tilde{k} h$。\n- 对紧致格式进行傅里叶分析，将 $\\tilde{\\theta}$ 表示为 $\\theta$ 和 $(\\alpha,\\beta)$ 的函数。然后，对于测试角度 $\\theta \\in \\{0.1, 0.5, 1.0, 1.5, 2.5\\}$（均以弧度为单位），计算绝对色散误差 $|\\tilde{\\theta} - \\theta|$ 并按给定顺序以列表形式报告。\n- 通过在 $[0,\\pi]$（含边界）上以弧度为单位均匀采样一组密集的角度 $\\theta$，并计算样本上 $\\tilde{\\theta}$ 虚部的最大绝对值来评估数值耗散。将此最大值报告为单个浮点数。\n\n测试套件和要求的最终输出：\n- 您的程序必须按顺序运行以下测试套件并汇总结果：\n  1. 计算任务 C 中的 $p_{32 \\to 64}$。\n  2. 计算任务 C 中的 $p_{64 \\to 128}$。\n  3. 计算任务 D 中，对于 $\\theta \\in \\{0.1, 0.5, 1.0, 1.5, 2.5\\}$（以弧度为单位）的绝对色散误差列表。\n  4. 计算任务 D 中的最大耗散度量，定义为在 $[0,\\pi]$ 上包含 1001 个点的均匀 $\\theta$ 值网格上，$\\tilde{\\theta}$ 虚部的最大绝对值。\n- 您的程序应生成单行输出，其中包含以逗号分隔的列表形式的结果，并用方括号括起来，第三项本身也是一个列表，即采用以下精确格式：\"[p32_64,p64_128,[e_theta0.1,e_theta0.5,e_theta1.0,e_theta1.5,e_theta2.5],max_dissipation]\"。\n- 所有角度均以弧度为单位。本问题不涉及物理单位。\n\n您的实现必须是完全自包含的，使用周期性边界条件，并且不得依赖任何外部数据或用户输入。数值线性代数必须仅使用允许的库来执行，并且您的输出值必须是浮点数。通过从泰勒相容性推导系数 $(\\alpha,\\beta)$ 并通过对所实现格式的傅里叶分析来计算修正波数，而不是通过导入任何预先制表的公式，来确保科学真实性。",
            "solution": "所提出的问题是计算物理学中一个标准的、适定的练习，涉及高阶有限差分格式的推导、实现和分析。所有提供的信息都是自包含的、有科学依据的和客观的。各项任务逻辑结构清晰，并导向一个唯一的、可验证的解。因此，该问题被认为是有效的，并将提供完整的解决方案。\n\n目标是构建并分析一种用于周期性均匀网格上一阶导数的四阶紧致有限差分格式。分析将按指定的四个部分进行：系数推导、实现细节、精度的数值验证以及色散和耗散特性的谱分析。\n\n**A部分：紧致格式系数的推导**\n\n给定一个用于一阶导数 $f'_{i} \\approx d_{i}$ 的对称、三点紧致格式：\n$$\n\\alpha d_{i-1} + d_{i} + \\alpha d_{i+1} = \\frac{\\beta}{h} \\left(f_{i+1} - f_{i-1}\\right)\n$$\n其中 $f_i = f(x_i)$，$d_i = f'(x_i)$，$h$ 是均匀网格间距。为了找到能产生四阶精度格式的系数 $\\alpha$ 和 $\\beta$，我们使用在点 $x_i$ 附近的泰勒级数展开来强制相容性。\n格式中的各项展开如下：\n$$\nf_{i\\pm1} = f(x_i \\pm h) = f_i \\pm h f'_i + \\frac{h^2}{2} f''_i \\pm \\frac{h^3}{6} f^{(3)}_i + \\frac{h^4}{24} f^{(4)}_i \\pm \\frac{h^5}{120} f^{(5)}_i + O(h^6)\n$$\n$$\nd_{i\\pm1} = f'(x_i \\pm h) = f'_i \\pm h f''_i + \\frac{h^2}{2} f^{(3)}_i \\pm \\frac{h^3}{6} f^{(4)}_i + \\frac{h^4}{24} f^{(5)}_i + O(h^5)\n$$\n将这些展开式代入格式方程，我们分别分析左侧（LHS）和右侧（RHS）。\n\n左侧（LHS）：\n\\begin{align*}\n\\alpha d_{i-1} + d_{i} + \\alpha d_{i+1} = \\alpha \\left(f'_i - h f''_i + \\frac{h^2}{2} f^{(3)}_i - \\frac{h^3}{6} f^{(4)}_i + \\frac{h^4}{24} f^{(5)}_i\\right) + f'_i \\\\\n\\quad+ \\alpha \\left(f'_i + h f''_i + \\frac{h^2}{2} f^{(3)}_i + \\frac{h^3}{6} f^{(4)}_i + \\frac{h^4}{24} f^{(5)}_i\\right) + O(h^5) \\\\\n= (1+2\\alpha)f'_i + \\alpha h^2 f^{(3)}_i + \\frac{\\alpha h^4}{12} f^{(5)}_i + O(h^6)\n\\end{align*}\n\n右侧（RHS）：\n\\begin{align*}\n\\frac{\\beta}{h} (f_{i+1} - f_{i-1}) = \\frac{\\beta}{h} \\left( (f_i + h f'_i + \\frac{h^2}{2}f''_i + \\frac{h^3}{6}f^{(3)}_i + \\frac{h^4}{24}f^{(4)}_i + \\frac{h^5}{120}f^{(5)}_i) \\right. \\\\\n\\quad \\left. - (f_i - h f'_i + \\frac{h^2}{2}f''_i - \\frac{h^3}{6}f^{(3)}_i + \\frac{h^4}{24}f^{(4)}_i - \\frac{h^5}{120}f^{(5)}_i) \\right) + O(h^5) \\\\\n= \\frac{\\beta}{h} \\left( 2h f'_i + \\frac{2h^3}{6}f^{(3)}_i + \\frac{2h^5}{120}f^{(5)}_i \\right) + O(h^5) \\\\\n= 2\\beta f'_i + \\frac{\\beta h^2}{3} f^{(3)}_i + \\frac{\\beta h^4}{60} f^{(5)}_i + O(h^5)\n\\end{align*}\n\n为了达到尽可能高的精度阶数，我们令左侧和右侧相应导数项的系数相等。\n\\begin{itemize}\n    \\item $f'_i$ 的系数： $1+2\\alpha = 2\\beta$\n    \\item $f^{(3)}_i$ 的系数： $\\alpha = \\frac{\\beta}{3}$\n\\end{itemize}\n这构成了关于 $\\alpha$ 和 $\\beta$ 的两个线性方程组。将第二个方程代入第一个方程得到：\n$$\n1 + 2\\alpha = 2(3\\alpha) = 6\\alpha \\implies 1 = 4\\alpha \\implies \\alpha = \\frac{1}{4}\n$$\n由此，我们求得 $\\beta$：\n$$\n\\beta = 3\\alpha = 3 \\left(\\frac{1}{4}\\right) = \\frac{3}{4}\n$$\n该格式由 $\\alpha = 1/4$ 和 $\\beta = 3/4$ 定义。\n\n截断误差的主项 $\\tau$ 是第一个未被抵消的项，它涉及 $f^{(5)}_i$：\n$$\n\\tau = \\left( \\frac{\\beta h^4}{60} - \\frac{\\alpha h^4}{12} \\right) f^{(5)}_i = h^4 \\left( \\frac{3/4}{60} - \\frac{1/4}{12} \\right) f^{(5)}_i = h^4 \\left( \\frac{3}{240} - \\frac{5}{240} \\right) f^{(5)}_i = -\\frac{2h^4}{240} f^{(5)}_i = -\\frac{h^4}{120} f^{(5)}_i\n$$\n局部截断误差为 $O(h^4)$，因此该格式是四阶精度的。\n\n**B部分：在周期性网格上的实现**\n\n对于定义域 $[0,1)$ 上具有 $N$ 个点 $x_j = j h$（其中 $j=0, \\dots, N-1$ 且 $h=1/N$）的网格，该紧致格式为离散导数向量 $\\boldsymbol{d} = [d_0, d_1, \\dots, d_{N-1}]^T$ 定义了一个线性系统。在每个网格点 $j$ 处的方程为：\n$$\n\\frac{1}{4}d_{j-1} + d_j + \\frac{1}{4}d_{j+1} = \\frac{3}{4h}(f_{j+1} - f_{j-1})\n$$\n由于周期性边界条件，索引按模 $N$ 计算。该系统可以写成矩阵形式 $A \\boldsymbol{d} = \\boldsymbol{b}$，其中：\n\\begin{itemize}\n    \\item $A$ 是一个 $N \\times N$ 的循环矩阵，由其第一行 $[\\text{1}, \\alpha, 0, \\dots, 0, \\alpha]$ 定义：\n    $$\n    A = \\begin{pmatrix}\n    1  \\alpha  0  \\cdots  0  \\alpha \\\\\n    \\alpha  1  \\alpha  \\cdots  0  0 \\\\\n    0  \\alpha  1  \\cdots  0  0 \\\\\n    \\vdots  \\vdots  \\vdots  \\ddots  \\vdots  \\vdots \\\\\n    0  0  0  \\cdots  1  \\alpha \\\\\n    \\alpha  0  0  \\cdots  \\alpha  1\n    \\end{pmatrix}\n    $$\n    \\item $\\boldsymbol{b}$ 是右侧向量，其元素为 $b_j = \\frac{\\beta}{h}(f_{j+1} - f_{j-1})$。\n\\end{itemize}\n这个循环线性系统可以被高效地求解，以找到数值导数 $\\boldsymbol{d}$。\n\n**C部分：精度的数值验证**\n\n为了验证理论上的四阶精度，我们在 $[0,1)$ 上计算 $f(x) = \\sin(2\\pi x)$ 的数值导数，其精确导数为 $f'(x) = 2\\pi\\cos(2\\pi x)$。我们使用网格尺寸 $N \\in \\{32, 64, 128\\}$。误差在最大范数下度量：\n$$\nE_{\\infty}(N) = \\max_{j=0,\\dots,N-1} |d_j - f'(x_j)|\n$$\n在两种网格分辨率 $N_1$ 和 $N_2=2N_1$ 之间计算观测精度阶数 $p$ 如下：\n$$\np = \\log_2 \\left( \\frac{E_{\\infty}(N_1)}{E_{\\infty}(N_2)} \\right)\n$$\n对于一个四阶格式，我们期望 $p \\approx 4$。\n\n**D部分：谱分析**\n\n离散算子的谱特性通过将其应用于单个傅里叶模 $f_j = e^{ikx_j} = e^{i\\theta j}$ 来分析，其中 $\\theta=kh$ 是无量纲波数。数值微分算子 $\\mathcal{D}$ 将该模变换为 $\\mathcal{D}(e^{i\\theta j}) = i\\tilde{k} e^{i\\theta j} = \\frac{i\\tilde{\\theta}}{h} e^{i\\theta j}$，其中 $\\tilde{\\theta} = \\tilde{k}h$ 是修正波数。精确导数给出 $ik e^{ikx_j} = \\frac{i\\theta}{h}e^{i\\theta j}$。\n\n将 $f_j = e^{i\\theta j}$ 和 $d_j = \\frac{i\\tilde{\\theta}}{h} e^{i\\theta j}$ 代入格式方程：\n$$\n\\alpha \\frac{i\\tilde{\\theta}}{h} e^{i\\theta(j-1)} + \\frac{i\\tilde{\\theta}}{h} e^{i\\theta j} + \\alpha \\frac{i\\tilde{\\theta}}{h} e^{i\\theta(j+1)} = \\frac{\\beta}{h} \\left( e^{i\\theta(j+1)} - e^{i\\theta(j-1)} \\right)\n$$\n两边同除以 $\\frac{i}{h}e^{i\\theta j}$ 得到：\n$$\n\\tilde{\\theta}(\\alpha e^{-i\\theta} + 1 + \\alpha e^{i\\theta}) = \\frac{\\beta}{i} (e^{i\\theta} - e^{-i\\theta})\n$$\n使用欧拉恒等式 $e^{i\\theta} + e^{-i\\theta} = 2\\cos\\theta$ 和 $e^{i\\theta} - e^{-i\\theta} = 2i\\sin\\theta$：\n$$\n\\tilde{\\theta}(1 + 2\\alpha\\cos\\theta) = \\frac{\\beta}{i}(2i\\sin\\theta) = 2\\beta\\sin\\theta\n$$\n求解修正波数 $\\tilde{\\theta}$：\n$$\n\\tilde{\\theta}(\\theta) = \\frac{2\\beta \\sin\\theta}{1 + 2\\alpha \\cos\\theta}\n$$\n代入 $\\alpha = 1/4$ 和 $\\beta = 3/4$：\n$$\n\\tilde{\\theta}(\\theta) = \\frac{2(3/4) \\sin\\theta}{1 + 2(1/4) \\cos\\theta} = \\frac{3/2 \\sin\\theta}{1 + 1/2 \\cos\\theta} = \\frac{3 \\sin\\theta}{2 + \\cos\\theta}\n$$\n\n数值色散误差是修正波数与精确波数之差，即 $|\\tilde{\\theta} - \\theta|$。我们为指定的 $\\theta$ 值计算此误差。\n\n数值耗散与修正波数的虚部 $\\text{Im}(\\tilde{\\theta})$ 有关。对于一个具有实系数的对称格式，当作用于实数 $\\theta$ 时，得到的 $\\tilde{\\theta}$ 是纯实数。这一点从其解析形式中可以明显看出。因此，对于所有 $\\theta \\in [0, \\pi]$，$\\text{Im}(\\tilde{\\theta}) = 0$。这表明该格式是非耗散的，意味着它不会人为地衰减波幅。在给定范围内计算虚部最大绝对值将通过得到一个 0.0 的值来证实这一点。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import solve_circulant\n\ndef solve():\n    \"\"\"\n    Derives, implements, and analyzes a fourth-order compact finite difference scheme.\n    \"\"\"\n    # Task A: Coefficients derived from Taylor series analysis.\n    # alpha * f'_{i-1} + f'_{i} + alpha * f'_{i+1} = (beta/h) * (f_{i+1} - f_{i-1})\n    # For fourth-order accuracy, alpha = 1/4 and beta = 3/4.\n    alpha = 1.0 / 4.0\n    beta = 3.0 / 4.0\n\n    # Task C: Observed order of accuracy test\n    grid_sizes = [32, 64, 128]\n    errors = {}\n\n    for N in grid_sizes:\n        # Construct grid on [0, 1)\n        h = 1.0 / N\n        x = np.arange(N) * h\n\n        # Test function and its exact derivative\n        f_vals = np.sin(2 * np.pi * x)\n        d_exact = 2 * np.pi * np.cos(2 * np.pi * x)\n\n        # Task B: Construct and solve the linear system\n        # A * d = b, where A is a circulant matrix\n        \n        # Construct the right-hand side vector b\n        # b_j = (beta/h) * (f_{j+1} - f_{j-1})\n        f_plus_1 = np.roll(f_vals, -1)\n        f_minus_1 = np.roll(f_vals, 1)\n        b = (beta / h) * (f_plus_1 - f_minus_1)\n\n        # The matrix A is circulant. Its first column defines it completely.\n        # First column of A is [1, alpha, 0, ..., 0, alpha]\n        A_col = np.zeros(N)\n        A_col[0] = 1.0\n        A_col[1] = alpha\n        A_col[-1] = alpha\n        \n        # Solve the circulant system A * d = b for the numerical derivative d\n        d_numerical = solve_circulant(A_col, b)\n\n        # Compute the maximum-norm error\n        errors[N] = np.max(np.abs(d_numerical - d_exact))\n\n    # Compute observed orders of accuracy\n    p32_64 = np.log2(errors[32] / errors[64])\n    p64_128 = np.log2(errors[64] / errors[128])\n\n    # Task D: Spectral dispersion and dissipation analysis\n    # Modified wavenumber function derived analytically\n    def modified_wavenumber(theta):\n        # With alpha=1/4 and beta=3/4, tilde_theta = (3*sin(theta)) / (2 + cos(theta))\n        return (3.0 * np.sin(theta)) / (2.0 + np.cos(theta))\n\n    # Compute dispersion errors\n    thetas_test = np.array([0.1, 0.5, 1.0, 1.5, 2.5])\n    mod_thetas_test = modified_wavenumber(thetas_test)\n    dispersion_errors = np.abs(mod_thetas_test - thetas_test).tolist()\n\n    # Compute maximum dissipation\n    # The scheme is non-dissipative, so Im(tilde_theta) is analytically zero.\n    # The calculation is performed as requested by the problem statement.\n    thetas_dissipation = np.linspace(0, np.pi, 1001)\n    mod_thetas_dissipation = modified_wavenumber(thetas_dissipation)\n    # The imaginary part is zero due to the analytical form (real inputs, real outputs).\n    # np.imag is used for formal correctness.\n    max_dissipation = np.max(np.abs(np.imag(mod_thetas_dissipation)))\n\n    # Final assembly of results in the required format\n    # The third item is a list, which needs to be stringified without spaces.\n    disp_err_str = str(dispersion_errors).replace(\" \", \"\")\n    \n    # The f-string will use the string representation of each element.\n    # The final list of results printed will have the required format.\n    final_results = [p32_64, p64_128, disp_err_str, max_dissipation]\n    \n    print(f\"[{final_results[0]},{final_results[1]},{final_results[2]},{final_results[3]}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "一个数值格式的最终考验是其在长期物理模拟中的表现。本练习将目光投向物理学中的基石——一维波动方程，要求你比较一个显式高阶格式与一个紧致高阶格式在模拟中的能量守恒能力。通过将空间离散格式与保持几何结构的辛时间积分器相结合，你将亲眼见证一个格式的谱精度如何深刻影响模拟的物理保真度，并理解为何仅有高阶的理论收敛阶数并不足以保证模拟的长期稳定性。",
            "id": "2401227",
            "problem": "考虑一个周期性域上的一维线性波动方程，\n$$\nu_{tt}(x,t) = c^2\\,u_{xx}(x,t), \\quad x \\in [0,L], \\quad t \\ge 0,\n$$\n其具有周期性边界条件 $u(0,t) = u(L,t)$ 和给定的初始数据 $u(x,0)$ 和 $u_t(x,0)$。其连续能量为\n$$\nE(t) \\;=\\; \\int_0^L \\left(\\tfrac{1}{2}\\,u_t(x,t)^2 \\;+\\; \\tfrac{1}{2}\\,c^2\\,u_x(x,t)^2\\right)\\,dx.\n$$\n在本问题中，您将在一个均匀的周期性网格上，比较 $u_{xx}$ 的两种高阶有限差分空间离散化方法的离散对应能量 $E(t)$ 的守恒性。这两种方法均使用相同的显式二阶精度时间积分器进行时间推进。\n\n使用以下无量纲设置：\n- 域长度 $L = 2\\pi$ (以弧度为单位)，波速 $c = 1$ (无量纲)。\n- 均匀网格，包含 $N$ 个点，位置为 $x_j = j\\,\\Delta x$，其中 $j=0,1,\\dots,N-1$，且 $\\Delta x = L/N$。\n- 时间步长 $\\Delta t = \\mathrm{CFL}\\cdot \\Delta x/c$，其中 $\\mathrm{CFL}$ 表示 Courant–Friedrichs–Lewy (CFL) 数。为确保在最终时间 $T$ 精确结束，使用整数步数 $N_t = \\mathrm{round}(T/\\Delta t)$ 并重置 $\\Delta t \\leftarrow T/N_t$。\n- 初始条件\n$$\nu(x,0) = \\sin(kx) + \\tfrac{1}{2}\\sin(2kx), \\qquad u_t(x,0) = 0.3\\cos(kx) - 0.2\\cos(2kx),\n$$\n其中 $x$ 以弧度为单位。\n\n待比较的 $u_{xx}$ 空间离散化方法：\n1) 显式四阶中心有限差分 (五点) 格式：\n$$\n(D_{xx}^{\\mathrm{E4}} u)_j \\;=\\; \\frac{-u_{j+2} + 16u_{j+1} - 30u_j + 16u_{j-1} - u_{j-2}}{12\\,\\Delta x^2},\n$$\n对所有 $j$ 使用周期性索引。\n\n2) 用于二阶导数的六阶三对角紧致有限差分，由以下方程隐式定义\n$$\n\\alpha\\, (D_{xx}^{\\mathrm{C6}} u)_{j-1} \\;+\\; (D_{xx}^{\\mathrm{C6}} u)_j \\;+\\; \\alpha\\, (D_{xx}^{\\mathrm{C6}} u)_{j+1}\n\\;=\\;\n\\frac{1}{\\Delta x^2}\\left(\\frac{6}{5}\\,(u_{j+1} - 2u_j + u_{j-1}) \\;+\\; \\frac{1}{10}\\,(u_{j+2} - 2u_j + u_{j-2})\\right),\n$$\n对所有 $j$ 使用周期性索引，其中 $\\alpha = 1/10$。\n\n使用相同的显式二阶精度、时间可逆的辛积分器 (Störmer–Verlet 方法) 对两个半离散系统进行时间推进，该方法以 $u$ 和 $v=u_t$ 的形式表示：\n- 通过在网格上对 $u(x,0)$ 进行采样来初始化 $u^0$，通过在网格上对 $u_t(x,0)$ 进行采样来初始化 $v^0$。\n- 对于 $n = 0,1,\\dots,N_t-1$：\n  - $v^{n+\\tfrac{1}{2}} = v^n + \\tfrac{1}{2}\\,\\Delta t\\,c^2\\,D_{xx} u^n$,\n  - $u^{n+1} = u^n + \\Delta t\\,v^{n+\\tfrac{1}{2}}$,\n  - $v^{n+1} = v^{n+\\tfrac{1}{2}} + \\tfrac{1}{2}\\,\\Delta t\\,c^2\\,D_{xx} u^{n+1}$,\n其中 $D_{xx}$ 是 $D_{xx}^{\\mathrm{E4}}$ 或 $D_{xx}^{\\mathrm{C6}}$。\n\n为测量能量守恒性，使用网格上的梯形法则近似计算时间步 $n$ 处的能量：\n$$\nE^n \\;=\\; \\sum_{j=0}^{N-1} \\left( \\tfrac{1}{2}\\,(v^n_j)^2 \\;+\\; \\tfrac{1}{2}\\,c^2\\,\\big( (D_x^{\\mathrm{E4}} u^n)_j \\big)^2 \\right)\\,\\Delta x,\n$$\n其中能量中的空间导数总是使用显式四阶中心五点格式计算\n$$\n(D_x^{\\mathrm{E4}} u)_j \\;=\\; \\frac{-u_{j+2} + 8u_{j+1} - 8u_{j-1} + u_{j-2}}{12\\,\\Delta x},\n$$\n使用周期性索引。将在最终时间 $T$ 的相对能量误差定义为\n$$\n\\varepsilon \\;=\\; \\frac{|E^{N_t} - E^0|}{E^0}.\n$$\n\n测试套件：\n对于下方的每个参数集 $(N,\\mathrm{CFL},T,k)$，计算两个数：分别对应 $D_{xx}^{\\mathrm{E4}}$ 和 $D_{xx}^{\\mathrm{C6}}$ 的相对能量误差 $\\varepsilon$。\n\n- 情况 A (理想路径)：$(N,\\mathrm{CFL},T,k) = (64,\\,0.2,\\,5.0,\\,3)$。\n- 情况 B (更接近稳定性边界)：$(N,\\mathrm{CFL},T,k) = (64,\\,0.45,\\,5.0,\\,3)$。\n- 情况 C (更粗的网格)：$(N,\\mathrm{CFL},T,k) = (32,\\,0.2,\\,5.0,\\,5)$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个由列表组成的列表，用逗号分隔。每个内部列表对应一种情况，并按 $[\\varepsilon_{\\mathrm{E4}}, \\varepsilon_{\\mathrm{C6}}]$ 的顺序排列。每个浮点数必须以科学记数法打印，小数点后恰好有 $8$ 位数字。例如，最终输出必须如下所示：\n$$\n[[a_1,b_1],[a_2,b_2],[a_3,b_3]],\n$$\n其中每个 $a_i$ 和 $b_i$ 的格式都如 $1.23456789e-06$ 所示 (科学记数法，小数点后恰好有 $8$ 位数字)。不应打印任何其他文本。",
            "solution": "所提出的问题是计算物理学中一个适定且科学上合理的练习。它要求比较一维线性波动方程的两种高阶有限差分格式，并基于离散能量守恒性对其进行评估。所有参数、方程和数值方法都已足够严谨地指定，从而可以得到唯一且可验证的解。该问题是有效的。\n\n求解过程如下。首先，对连续问题在空间上进行半离散化，得到一个常微分方程组 (ODEs)。其次，使用指定的 Störmer-Verlet 方法对该常微分方程组进行时间积分。实现过程需要仔细构建空间导数算子，特别是隐式紧致格式。最后，通过监视离散能量来评估每种数值格式的守恒性质。\n\n令向量 $\\mathbf{u}(t) = [u_0(t), u_1(t), \\dots, u_{N-1}(t)]^T$ 表示网格点 $x_j = j \\Delta x$ ($j=0, \\dots, N-1$) 上的解。波动方程 $u_{tt} = c^2 u_{xx}$ 的半离散化是一个二阶常微分方程组：\n$$\n\\frac{d^2\\mathbf{u}}{dt^2} = c^2 \\mathbf{D}_{xx} \\mathbf{u}\n$$\n其中 $\\mathbf{D}_{xx}$ 是一个表示空间二阶导数算子的矩阵。我们定义 $\\mathbf{v}(t) = d\\mathbf{u}/dt$。\n\n该问题为算子 $\\mathbf{D}_{xx}$ 指定了两种形式。\n\n1.  **显式四阶格式 ($D_{xx}^{\\mathrm{E4}}$):**\n    算子 $(D_{xx}^{\\mathrm{E4}} u)_j$ 对应于与一个循环矩阵 $\\mathbf{D}_{xx}^{\\mathrm{E4}}$ 相乘。由于问题的周期性边界条件，该矩阵由五点格式系数 $\\frac{1}{12\\,\\Delta x^2}\\{-1, 16, -30, 16, -1\\}$ 构建。将此算子应用于向量 $\\mathbf{u}$ 可以通过使用与周期性索引相对应的向量移位操作来高效实现。对于网格点 $j$，\n    $$\n    (\\mathbf{D}_{xx}^{\\mathrm{E4}} \\mathbf{u})_j = \\frac{-u_{j+2} + 16u_{j+1} - 30u_j + 16u_{j-1} - u_{j-2}}{12\\,\\Delta x^2}\n    $$\n    其中索引是对 $N$ 取模。\n\n2.  **紧致六阶格式 ($D_{xx}^{\\mathrm{C6}}$):**\n    该算子是隐式定义的。令 $\\mathbf{y} = \\mathbf{D}_{xx}^{\\mathrm{C6}} \\mathbf{u}$。其定义关系为：\n    $$\n    \\alpha\\, y_{j-1} \\;+\\; y_j \\;+\\; \\alpha\\, y_{j+1} \\;=\\; (\\mathbf{r})_j\n    $$\n    其中右侧项 $(\\mathbf{r})_j$ 由下式给出\n    $$\n    (\\mathbf{r})_j = \\frac{1}{\\Delta x^2}\\left(\\frac{6}{5}\\,(u_{j+1} - 2u_j + u_{j-1}) \\;+\\; \\frac{1}{10}\\,(u_{j+2} - 2u_j + u_{j-2})\\right)\n    $$\n    且 $\\alpha = 1/10$。以矩阵形式表示为 $\\mathbf{M} \\mathbf{y} = \\mathbf{r}$，其中对于某个显式算子矩阵 $\\mathbf{R}$，有 $\\mathbf{r} = \\mathbf{R} \\mathbf{u}$。矩阵 $\\mathbf{M}$ 是一个对称三对角循环矩阵，其第一行为 $[1, \\alpha, 0, \\dots, 0, \\alpha]$。为计算 $\\mathbf{y} = \\mathbf{D}_{xx}^{\\mathrm{C6}} \\mathbf{u}$，必须在每次求值时求解该线性系统以得到 $\\mathbf{y}$。由于 $\\mathbf{M}$ 是一个循环矩阵，该系统可以使用快速傅里叶变换 (FFT) 在 $\\mathcal{O}(N \\log N)$ 次运算内非常高效地求解，或者通过使用专门的循环矩阵求解器。形式上，解为 $\\mathbf{D}_{xx}^{\\mathrm{C6}} = \\mathbf{M}^{-1} \\mathbf{R}$。\n\n该常微分方程组使用 Störmer-Verlet 方法进行时间推进，这是一种二阶精度、辛和时间可逆的积分器。给定在时间 $t_n = n\\Delta t$ 时的 $\\mathbf{u}^n$ 和 $\\mathbf{v}^n$，在 $t_{n+1}$ 的状态通过以下方式计算：\n$$\n\\begin{align*}\n\\mathbf{a}^n = c^2 \\mathbf{D}_{xx} \\mathbf{u}^n \\\\\n\\mathbf{v}^{n+\\tfrac{1}{2}} = \\mathbf{v}^n + \\tfrac{1}{2}\\,\\Delta t\\,\\mathbf{a}^n \\\\\n\\mathbf{u}^{n+1} = \\mathbf{u}^n + \\Delta t\\,\\mathbf{v}^{n+\\tfrac{1}{2}} \\\\\n\\mathbf{a}^{n+1} = c^2 \\mathbf{D}_{xx} \\mathbf{u}^{n+1} \\\\\n\\mathbf{v}^{n+1} = \\mathbf{v}^{n+\\tfrac{1}{2}} + \\tfrac{1}{2}\\,\\Delta t\\,\\mathbf{a}^{n+1}\n\\end{align*}\n$$\n此算法对于 $\\mathbf{D}_{xx}$ 的两种选择都同样适用。\n\n计算离散能量 $E^n$ 以监视守恒性。它是对连续能量 $E(t) = \\int_0^L \\left(\\tfrac{1}{2}\\,u_t^2 + \\tfrac{1}{2}\\,c^2\\,u_x^2\\right)\\,dx$ 的近似，使用梯形法则进行积分：\n$$\nE^n \\;=\\; \\sum_{j=0}^{N-1} \\left( \\tfrac{1}{2}\\,(v^n_j)^2 \\;+\\; \\tfrac{1}{2}\\,c^2\\,\\big( (\\mathbf{D}_x^{\\mathrm{E4}} \\mathbf{u}^n)_j \\big)^2 \\right)\\,\\Delta x\n$$\n$u$ 的空间导数，记作 $(\\mathbf{D}_x^{\\mathrm{E4}} \\mathbf{u})_j$，始终使用一阶导数的显式四阶格式进行计算，无论时间积分中二阶导数使用的是哪种格式。这确保了公平的比较。该格式由下式给出：\n$$\n(\\mathbf{D}_x^{\\mathrm{E4}} \\mathbf{u})_j = \\frac{-u_{j+2} + 8u_{j+1} - 8u_{j-1} + u_{j-2}}{12\\,\\Delta x}\n$$\n相对能量误差随后计算为 $\\varepsilon = |E^{N_t} - E^0|/E^0$。Störmer-Verlet 方法是辛的，这意味着它能精确地守恒一个邻近的“影子”哈密顿量。原始半离散系统的能量 $E^n$ 并非精确守恒，但应表现出有界振荡。这些振荡的幅度是衡量该格式质量的一个标准。一个更优越的空间离散化，例如六阶紧致格式，提供了对连续算子谱性质更准确的近似，这通常会导致离散能量 $E^n$ 的守恒性显著提高。因此我们预期 $\\varepsilon_{\\mathrm{C6}}  \\varepsilon_{\\mathrm{E4}}$。\n\n总体步骤是：从给定的解析初始条件初始化 $\\mathbf{u}^0$ 和 $\\mathbf{v}^0$，计算初始能量 $E^0$，运行时间步进循环 $N_t$ 步，计算最终能量 $E^{N_t}$，最后为每个测试用例和两种指定的导数算子中的每一种计算相对误差 $\\varepsilon$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_circulant\n\ndef solve():\n    \"\"\"\n    Solves the 1D wave equation using two different high-order finite difference\n    schemes and compares their energy conservation.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        (64, 0.2, 5.0, 3),  # Case A\n        (64, 0.45, 5.0, 3), # Case B\n        (32, 0.2, 5.0, 5),  # Case C\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        N, CFL, T, k = case\n        case_results = []\n        for scheme_type in ['E4', 'C6']:\n            # Non-dimensional parameters\n            L = 2.0 * np.pi\n            c = 1.0\n\n            # Grid setup\n            dx = L / N\n            x = np.arange(N) * dx\n\n            # Time step setup\n            dt_initial = CFL * dx / c\n            Nt = int(round(T / dt_initial))\n            dt = T / Nt\n\n            # Initial conditions\n            u0 = np.sin(k * x) + 0.5 * np.sin(2 * k * x)\n            v0 = 0.3 * np.cos(k * x) - 0.2 * np.cos(2 * k * x)\n\n            # Derivative operators\n            def d_xx_e4(u_vec, dx_val):\n                \"\"\"Explicit 4th-order centered difference for the second derivative.\"\"\"\n                u_jm2 = np.roll(u_vec, 2)\n                u_jm1 = np.roll(u_vec, 1)\n                u_jp1 = np.roll(u_vec, -1)\n                u_jp2 = np.roll(u_vec, -2)\n                num = -u_jp2 + 16.0 * u_jp1 - 30.0 * u_vec + 16.0 * u_jm1 - u_jm2\n                den = 12.0 * dx_val**2\n                return num / den\n\n            def d_xx_c6(u_vec, dx_val):\n                \"\"\"Compact 6th-order centered difference for the second derivative.\"\"\"\n                alpha = 1.0 / 10.0\n                \n                # Right-hand side of the implicit system\n                u_jm2 = np.roll(u_vec, 2)\n                u_jm1 = np.roll(u_vec, 1)\n                u_jp1 = np.roll(u_vec, -1)\n                u_jp2 = np.roll(u_vec, -2)\n                \n                term1 = (6.0 / 5.0) * (u_jp1 - 2.0 * u_vec + u_jm1)\n                term2 = (1.0 / 10.0) * (u_jp2 - 2.0 * u_vec + u_jm2)\n                rhs = (term1 + term2) / dx_val**2\n\n                # Left-hand side operator (circulant matrix)\n                # First column of the circulant matrix M\n                circ_col = np.zeros(N)\n                circ_col[0] = 1.0\n                circ_col[1] = alpha\n                circ_col[-1] = alpha\n\n                # Solve the circulant system M * y = rhs\n                return solve_circulant(circ_col, rhs)\n\n            def d_x_e4(u_vec, dx_val):\n                \"\"\"Explicit 4th-order centered difference for the first derivative.\"\"\"\n                u_jm2 = np.roll(u_vec, 2)\n                u_jm1 = np.roll(u_vec, 1)\n                u_jp1 = np.roll(u_vec, -1)\n                u_jp2 = np.roll(u_vec, -2)\n                num = -u_jp2 + 8.0 * u_jp1 - 8.0 * u_jm1 + u_jm2\n                den = 12.0 * dx_val\n                return num / den\n\n            # Energy calculation\n            def calculate_energy(u_vec, v_vec, dx_val, c_val):\n                du_dx = d_x_e4(u_vec, dx_val)\n                kinetic_energy_density = 0.5 * v_vec**2\n                potential_energy_density = 0.5 * c_val**2 * du_dx**2\n                total_energy = np.sum(kinetic_energy_density + potential_energy_density) * dx_val\n                return total_energy\n\n            # Choose the second derivative operator\n            if scheme_type == 'E4':\n                d_xx = d_xx_e4\n            else:  # 'C6'\n                d_xx = d_xx_c6\n\n            # Time integration using Störmer-Verlet\n            u = u0.copy()\n            v = v0.copy()\n\n            E0 = calculate_energy(u, v, dx, c)\n            \n            for n in range(Nt):\n                # Störmer-Verlet steps\n                acc_n = c**2 * d_xx(u, dx)\n                v_half = v + 0.5 * dt * acc_n\n                u_next = u + dt * v_half\n                acc_n1 = c**2 * d_xx(u_next, dx)\n                v_next = v_half + 0.5 * dt * acc_n1\n                \n                u, v = u_next, v_next\n                \n            E_final = calculate_energy(u, v, dx, c)\n            \n            # Relative energy error\n            rel_error = np.abs(E_final - E0) / E0\n            case_results.append(rel_error)\n\n        all_results.append(case_results)\n\n    # Format the final output string\n    # e.g., [[1.23e-04, 4.56e-05], [..], [..]]\n    output_str = \"[\" + \",\".join(\n        \"[\" + \",\".join([f\"{val:.8e}\" for val in res_pair]) + \"]\"\n        for res_pair in all_results\n    ) + \"]\"\n    \n    print(output_str)\n\nsolve()\n```"
        }
    ]
}