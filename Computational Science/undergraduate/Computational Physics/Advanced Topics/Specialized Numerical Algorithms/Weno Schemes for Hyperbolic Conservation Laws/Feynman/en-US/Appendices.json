{
    "hands_on_practices": [
        {
            "introduction": "This first practice will guide you to computationally verify the core principle of Weighted Essentially Non-Oscillatory (WENO) schemes. By implementing the Jiang-Shu weight calculation for a simple step function, you will directly observe how the scheme automatically identifies and down-weights stencils that cross a discontinuity, a key feature for producing sharp, non-oscillatory shock profiles. This exercise provides concrete, numerical insight into the \"smart\" stencil selection that makes WENO a powerful shock-capturing tool .",
            "id": "2450629",
            "problem": "Consider the scalar hyperbolic conservation law $u_{t} + f(u)_{x} = 0$ with linear advection flux $f(u) = a u$, where $a > 0$ is a constant advection speed. You will analyze the behavior of the nonlinear weights $\\omega_{k}$ in the fifth-order Weighted Essentially Non-Oscillatory (WENO) reconstruction of Jiang–Shu for the left-biased interface value, applied to a discontinuous initial condition. The purpose is to determine how $\\omega_{k}$ behave as a function of the grid resolution $\\Delta x$ as the mesh is refined across a discontinuity.\n\nYou must use the following fundamental setup and assumptions, which are standard in computational physics for hyperbolic conservation laws:\n- Use the scalar advection equation $u_{t} + a u_{x} = 0$ with $a > 0$ and the left-biased fifth-order WENO reconstruction (the Jiang–Shu formulation) for the interfacial state at $x_{i+\\frac{1}{2}}$.\n- The nonlinear weights $\\omega_{k}$ are computed from smoothness indicators that penalize stencils crossing discontinuities and favor stencils that are locally smooth, with a small positive parameter $\\varepsilon$ to avoid division by zero and an exponent $p$ to control sensitivity.\n- The linear weights $d_{k}$ sum to $1$ and correspond to the optimal linear fifth-order scheme in smooth regions.\n\nDefine the initial data to be a Riemann step:\n- $u(x) = 0$ for $x < 0$, $u(x) = 1$ for $x > 0$, and $u(0) = \\tfrac{1}{2}$.\n\nAdopt a uniform nodal grid defined by\n- $x_{j} = \\left(j + \\tfrac{1}{2}\\right)\\Delta x$, where $j \\in \\mathbb{Z}$ and $\\Delta x > 0$, so that interfaces are located at $x = m \\Delta x$ for any integer $m$.\n- For each chosen interface location $x = m \\Delta x$, reconstruct the left-biased fifth-order WENO value at that interface using the five-point stencil $\\{u_{i-2}, u_{i-1}, u_{i}, u_{i+1}, u_{i+2}\\}$ with $i = m - 1$ so that the interface is $x_{i+\\frac{1}{2}} = (i+1)\\Delta x = m \\Delta x$.\n- Assume $a > 0$, so the left-biased reconstruction applies. Use point values $u_{j} = u(x_{j})$.\n\nUse the standard parameters for the WENO-JS weights:\n- Linear weights $d_{0} = 0.1$, $d_{1} = 0.6$, $d_{2} = 0.3$.\n- Small parameter $\\varepsilon = 10^{-6}$.\n- Exponent $p = 2$.\n\nYour task:\n- For each test case specified below, compute the nonlinear weight vector $\\left[\\omega_{0}, \\omega_{1}, \\omega_{2}\\right]$ at the specified interface. Each $\\omega_{k}$ must be returned as a floating-point number rounded to $6$ decimal places.\n\nTest suite:\n- Use the following grid spacings $\\Delta x \\in \\{0.5, 0.25, 0.125\\}$ and interface offsets $m \\in \\{-2, 0, 1\\}$.\n- This yields $9$ test cases in the order listed below:\n    1. $(\\Delta x, m) = (0.5, -2)$\n    2. $(\\Delta x, m) = (0.25, -2)$\n    3. $(\\Delta x, m) = (0.125, -2)$\n    4. $(\\Delta x, m) = (0.5, 0)$\n    5. $(\\Delta x, m) = (0.25, 0)$\n    6. $(\\Delta x, m) = (0.125, 0)$\n    7. $(\\Delta x, m) = (0.5, 1)$\n    8. $(\\Delta x, m) = (0.25, 1)$\n    9. $(\\Delta x, m) = (0.125, 1)$\n\nImplementation notes:\n- Treat the scalar field values as pointwise samples $u_{j} = u(x_{j})$ of the discontinuous function defined above. In particular, $u(0) = \\tfrac{1}{2}$ is specified for completeness, but with $x_{j} = \\left(j + \\tfrac{1}{2}\\right)\\Delta x$ no grid node lies exactly at $x = 0$ for these test cases.\n- Use the canonical fifth-order WENO-JS smoothness indicators and weight definitions associated with the three substencils of size $3$. Do not introduce alternative smoothness indicators or mapped weights; use the original Jiang–Shu form.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets.\n- Each entry must be the list $\\left[\\omega_{0}, \\omega_{1}, \\omega_{2}\\right]$ for the corresponding test case, with each weight rounded to $6$ decimal places.\n- Concretely, the output should look like a single Python-style list of lists, for example: $[[\\omega_{0}^{(1)},\\omega_{1}^{(1)},\\omega_{2}^{(1)}],[\\omega_{0}^{(2)},\\omega_{1}^{(2)},\\omega_{2}^{(2)}],\\dots,[\\omega_{0}^{(9)},\\omega_{1}^{(9)},\\omega_{2}^{(9)}]]$.\n\nNo physical units are involved; report pure numbers. Angles are not used. Percentages are not used. The final output must be exactly one line as described above, with no additional text.",
            "solution": "We analyze the nonlinear weights $\\omega_{k}$ of the fifth-order Weighted Essentially Non-Oscillatory (WENO) scheme of Jiang–Shu for a scalar hyperbolic conservation law with linear advection. The fundamental base includes: the scalar advection equation $u_{t} + a u_{x} = 0$ with $a > 0$ (a hyperbolic conservation law), and the core definition of WENO-JS nonlinear weights computed from smoothness indicators that measure local variation on substencils and blend linear weights accordingly.\n\nPrinciple and definitions:\n- For $a > 0$, the left-biased reconstruction provides an approximation at interface $x_{i+\\frac{1}{2}}$ based on the five nodal values $\\{u_{i-2}, u_{i-1}, u_{i}, u_{i+1}, u_{i+2}\\}$.\n- The fifth-order WENO-JS method forms three third-degree polynomials on three substencils $S_{0} = \\{i-2,i-1,i\\}$, $S_{1} = \\{i-1,i,i+1\\}$, $S_{2} = \\{i,i+1,i+2\\}$, with associated linear weights $d_{0} = 0.1$, $d_{1} = 0.6$, $d_{2} = 0.3$ which sum to $1$.\n- The Jiang–Shu smoothness indicators $\\beta_{k}$ quantify the local smoothness on each substencil via discrete approximations of squared derivatives. The nonlinear weights are defined by\n$$\n\\alpha_{k} = \\frac{d_{k}}{(\\varepsilon + \\beta_{k})^{p}}, \\quad \\omega_{k} = \\frac{\\alpha_{k}}{\\alpha_{0} + \\alpha_{1} + \\alpha_{2}},\n$$\nwith $\\varepsilon = 10^{-6}$ and $p = 2$.\n\nGrid geometry and sampling:\n- The nodes are $x_{j} = \\left(j + \\tfrac{1}{2}\\right)\\Delta x$, hence interfaces are at $x = m \\Delta x$ for integer $m$, with $x_{i+\\frac{1}{2}} = (i+1)\\Delta x$ corresponding to $i = m - 1$.\n- The initial condition is the Riemann step $u(x) = 0$ for $x < 0$, $u(x) = 1$ for $x > 0$, and $u(0) = \\tfrac{1}{2}$. For the chosen nodes $x_{j} = \\left(j + \\tfrac{1}{2}\\right)\\Delta x$, no node lies exactly at $x=0$, so $u(0)$ is not sampled.\n\nBehavior near the discontinuity from first principles:\n- The WENO mechanism increases the weight $\\omega_{k}$ for substencils where the solution is smooth (small $\\beta_{k}$) and decreases it for substencils crossing a discontinuity (large $\\beta_{k}$). This behavior is independent of the precise flux, provided the reconstruction direction is fixed by the sign of $a$.\n- Consider the interface at $x = 0$ corresponding to $m = 0$ and $i = -1$. The five nodes involved are at positions $x_{-3} = (-2.5)\\Delta x$, $x_{-2} = (-1.5)\\Delta x$, $x_{-1} = (-0.5)\\Delta x$, $x_{0} = (0.5)\\Delta x$, $x_{1} = (1.5)\\Delta x$. The samples are $u_{-3} = 0$, $u_{-2} = 0$, $u_{-1} = 0$, $u_{0} = 1$, $u_{1} = 1$. The leftmost substencil $S_{0} = \\{-3,-2,-1\\}$ is strictly on the left, where the data are constant; hence its smoothness indicator satisfies $\\beta_{0} = 0$. The other substencils $S_{1}$ and $S_{2}$ cross the discontinuity, and their smoothness indicators are $O(1)$ constants depending on the jump amplitude, but not on $\\Delta x$, because the samples are piecewise constant across the jump.\n- With $\\varepsilon$ fixed and very small, this yields $\\alpha_{0} = d_{0}/\\varepsilon^{p}$, which is extremely large compared to $\\alpha_{1}$ and $\\alpha_{2}$, and therefore $\\omega_{0} \\approx 1$, $\\omega_{1} \\approx 0$, $\\omega_{2} \\approx 0$. Importantly, this conclusion is independent of $\\Delta x$ because the indicators on stencils crossing the jump remain $O(1)$ under refinement and the smooth stencil indicator remains $0$ for this sampling.\n- Consider the interface at $x = \\Delta x$ corresponding to $m = 1$ and $i = 0$. The five nodes are at $x_{-2} = (-1.5)\\Delta x$, $x_{-1} = (-0.5)\\Delta x$, $x_{0} = (0.5)\\Delta x$, $x_{1} = (1.5)\\Delta x$, $x_{2} = (2.5)\\Delta x$ with samples $u_{-2} = 0$, $u_{-1} = 0$, $u_{0} = 1$, $u_{1} = 1$, $u_{2} = 1$. Now the rightmost substencil $S_{2} = \\{0,1,2\\}$ is strictly on the right smooth side; hence $\\beta_{2} = 0$ and $\\omega_{2} \\approx 1$, $\\omega_{0}, \\omega_{1} \\approx 0$, again independent of $\\Delta x$.\n- Consider a fully smooth left region at an interface far enough from the discontinuity, e.g., $x = -2\\Delta x$ with $m = -2$ and $i = -3$. The five nodes are strictly on the left of the discontinuity, so all samples are $0$ and every smoothness indicator satisfies $\\beta_{k} = 0$. In that case, the nonlinear weights reduce to the linear weights exactly:\n$$\n\\alpha_{k} = \\frac{d_{k}}{\\varepsilon^{p}}, \\quad \\sum_{k=0}^{2} \\alpha_{k} = \\frac{1}{\\varepsilon^{p}} \\sum_{k=0}^{2} d_{k} = \\frac{1}{\\varepsilon^{p}},\n$$\nso $\\omega_{k} = d_{k}$ for $k \\in \\{0,1,2\\}$, again independent of $\\Delta x$.\n\nTherefore, the theoretical expectation is that for this discontinuous initial condition and nodal sampling:\n- At $m = 0$ (interface at the discontinuity), $\\omega_{0} \\to 1$ and $\\omega_{1}, \\omega_{2} \\to 0$ independent of $\\Delta x$.\n- At $m = 1$ (interface one cell to the right), $\\omega_{2} \\to 1$ and $\\omega_{0}, \\omega_{1} \\to 0$ independent of $\\Delta x$.\n- At $m = -2$ (interface two cells to the left in a smooth region), $\\omega_{k} = d_{k}$ for all $k$, independent of $\\Delta x$.\n\nAlgorithmic design to compute the test suite:\n- For each test case $(\\Delta x, m)$, set $i = m - 1$. Form the five-point vector $\\{u_{i-2},u_{i-1},u_{i},u_{i+1},u_{i+2}\\}$ by sampling $u_{j} = u(x_{j})$ with $x_{j} = \\left(j + \\tfrac{1}{2}\\right)\\Delta x$ and the piecewise constant step $u(x)$ as defined.\n- Compute the Jiang–Shu smoothness indicators $(\\beta_{0},\\beta_{1},\\beta_{2})$ on the substencils $S_{0},S_{1},S_{2}$ using the standard discrete formulas based on undivided differences. These indicators are nonnegative and vanish exactly on constant data.\n- Form $\\alpha_{k} = d_{k}/(\\varepsilon + \\beta_{k})^{p}$ with $d_{0} = 0.1$, $d_{1} = 0.6$, $d_{2} = 0.3$, $\\varepsilon = 10^{-6}$, $p = 2$, then normalize to $\\omega_{k} = \\alpha_{k}/\\sum_{j=0}^{2}\\alpha_{j}$.\n- Round each $\\omega_{k}$ to $6$ decimal places for reporting.\n\nQualitative outcome and numerical values:\n- For $(\\Delta x, m) = (0.5, -2)$, $(0.25, -2)$, $(0.125, -2)$, all five points lie on the left smooth side with $u_{j} = 0$, hence $(\\omega_{0},\\omega_{1},\\omega_{2}) = (0.1, 0.6, 0.3)$ exactly after normalization, so the reported values are $[0.1, 0.6, 0.3]$.\n- For $(\\Delta x, m) = (0.5, 0)$, $(0.25, 0)$, $(0.125, 0)$, only the leftmost substencil is smooth; thus $(\\omega_{0},\\omega_{1},\\omega_{2}) \\approx (1, 0, 0)$; rounding to $6$ decimals yields $[1.0, 0.0, 0.0]$.\n- For $(\\Delta x, m) = (0.5, 1)$, $(0.25, 1)$, $(0.125, 1)$, only the rightmost substencil is smooth; thus $(\\omega_{0},\\omega_{1},\\omega_{2}) \\approx (0, 0, 1)$; rounding to $6$ decimals yields $[0.0, 0.0, 1.0]$.\n\nThese results confirm, from first principles and computation, that across a discontinuity the WENO-JS nonlinear weights saturate to those stencils that remain entirely within the smooth side, and this saturation is effectively independent of $\\Delta x$ for the given nodal sampling and fixed $\\varepsilon$. In fully smooth regions, the weights reduce to the linear weights, also independent of $\\Delta x$.",
            "answer": "```python\nimport numpy as np\n\ndef weno_js_weights(u_im2, u_im1, u_i, u_ip1, u_ip2, eps=1e-6, p=2):\n    \"\"\"\n    Compute WENO-JS (5th order, left-biased) nonlinear weights at an interface\n    using point values u_{i-2},...,u_{i+2}. Returns [omega0, omega1, omega2].\n    \"\"\"\n    # Smoothness indicators (Jiang–Shu) for left-biased reconstruction\n    beta0 = (13.0/12.0)*(u_im2 - 2.0*u_im1 + u_i)**2 + 0.25*(u_im2 - 4.0*u_im1 + 3.0*u_i)**2\n    beta1 = (13.0/12.0)*(u_im1 - 2.0*u_i + u_ip1)**2 + 0.25*(u_im1 - u_ip1)**2\n    beta2 = (13.0/12.0)*(u_i - 2.0*u_ip1 + u_ip2)**2 + 0.25*(3.0*u_i - 4.0*u_ip1 + u_ip2)**2\n\n    d0, d1, d2 = 0.1, 0.6, 0.3\n\n    alpha0 = d0 / (eps + beta0)**p\n    alpha1 = d1 / (eps + beta1)**p\n    alpha2 = d2 / (eps + beta2)**p\n\n    asum = alpha0 + alpha1 + alpha2\n    omega0 = alpha0 / asum\n    omega1 = alpha1 / asum\n    omega2 = alpha2 / asum\n    return [omega0, omega1, omega2]\n\ndef step_ic(x):\n    # u(x) = 0 for x<0, 1 for x>0, 0.5 for x==0\n    if x > 0.0:\n        return 1.0\n    elif x < 0.0:\n        return 0.0\n    else:\n        return 0.5\n\ndef weights_for_case(dx, m):\n    \"\"\"\n    Nodes: x_j = (j + 0.5) * dx\n    Interface at x = m * dx corresponds to i = m - 1, interface is between i and i+1.\n    Left-biased WENO uses stencil u_{i-2},...,u_{i+2}.\n    \"\"\"\n    i = m - 1\n    # Collect nodal values u_{i-2} ... u_{i+2}\n    us = []\n    for j in range(i-2, i+3):\n        xj = (j + 0.5) * dx\n        us.append(step_ic(xj))\n    omega = weno_js_weights(us[0], us[1], us[2], us[3], us[4])\n    # Round to 6 decimals as required\n    omega = [float(f\"{w:.6f}\") for w in omega]\n    return omega\n\ndef solve():\n    # Define the test cases from the problem statement: 9 cases\n    dxs = [0.5, 0.25, 0.125]\n    ms = [-2, 0, 1]\n    test_cases = []\n    # Order: for each m in [-2,0,1], sweep dxs in order listed to match the problem ordering\n    # The problem lists in blocks: (dx,-2) for all dxs, then (dx,0), then (dx,1).\n    for m in [-2, 0, 1]:\n        for dx in [0.5, 0.25, 0.125]:\n            test_cases.append((dx, m))\n\n    results = []\n    for dx, m in test_cases:\n        omega = weights_for_case(dx, m)\n        results.append(omega)\n\n    # Final print statement: a single line list of lists\n    # Format exactly as a Python-style list of lists with commas.\n    inner = \",\".join(\"[\" + \",\".join(str(v) for v in trip) + \"]\" for trip in results)\n    print(f\"[{inner}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "A robust numerical scheme must perform well in both smooth and discontinuous regions. This practice shifts our focus to the behavior of the fifth-order WENO scheme in a smooth flow, where it simplifies to its optimal linear form. You will perform a Fourier analysis to derive the scheme's numerical dispersion relation, which quantifies how accurately waves of different lengths are propagated, providing a deeper understanding of the scheme's inherent accuracy and error characteristics .",
            "id": "2450656",
            "problem": "Consider the linear advection equation $u_{t}+u_{x}=0$ on a periodic domain discretized on a uniform grid $x_{i}=i\\,\\Delta x$ with cell-centered values $u_{i}(t)$. In a smooth region, the fifth-order Weighted Essentially Non-Oscillatory (WENO) scheme (WENO-$5$) with positive advection speed reduces to its linear optimal form. In this linearized setting, define the numerical flux at the interface $x_{i+1/2}$ by\n$$\n\\widehat{f}_{i+1/2}=\\frac{1}{60}\\left(2 f_{i-2}-13 f_{i-1}+47 f_{i}+27 f_{i+1}-3 f_{i+2}\\right),\n$$\nwith $f=u$, and approximate the spatial derivative by the conservative flux difference\n$$\n\\left(u_{x}\\right)_{i}\\approx \\frac{1}{\\Delta x}\\left(\\widehat{f}_{i+1/2}-\\widehat{f}_{i-1/2}\\right).\n$$\nLet the semi-discrete scheme be $u_{i}'(t)+\\left(u_{x}\\right)_{i}=0$. For the discrete Fourier mode $u_{i}(t)=\\exp\\!\\left(i\\left(i\\,\\theta-\\omega t\\right)\\right)$ with nondimensional wavenumber $\\theta\\in[0,\\pi]$ (in radians), the exact dispersion relation for $u_{t}+u_{x}=0$ is $\\omega=k$ with $k=\\theta/\\Delta x$. Define the numerical phase speed $c_{\\text{num}}(\\theta)$ by the real part of the numerical angular frequency, $c_{\\text{num}}(\\theta)=\\Re(\\omega_{\\text{num}})/k$, and let $c_{\\text{exact}}=1$ denote the exact phase speed.\n\nUsing only the statements above, determine the exact closed-form expression for the ratio $c_{\\text{num}}/c_{\\text{exact}}$ at the nondimensional wavenumber $\\theta=\\pi/3$. Provide your final answer as a single analytic expression. No rounding is required, and no units should be included in the final answer.",
            "solution": "The problem requires the determination of the numerical phase speed of a fifth-order linear upwind scheme for the linear advection equation. We begin with the problem statement's given data.\n\nThe semi-discrete form of the advection equation $u_t+u_x=0$ is given by\n$$u_{i}'(t)+\\left(u_{x}\\right)_{i}=0$$\nwhere $u_i'(t)$ is the time derivative of the cell-averaged value $u_i(t)$, and the spatial derivative is approximated by a conservative flux difference:\n$$\\left(u_{x}\\right)_{i} = \\frac{1}{\\Delta x}\\left(\\widehat{f}_{i+1/2}-\\widehat{f}_{i-1/2}\\right)$$\nHere, $\\Delta x$ is the uniform grid spacing. The numerical flux for $f=u$ is\n$$\\widehat{f}_{i+1/2}=\\frac{1}{60}\\left(2 u_{i-2}-13 u_{i-1}+47 u_{i}+27 u_{i+1}-3 u_{i+2}\\right)$$\nTo analyze the behavior of this scheme, we perform a von Neumann stability analysis by substituting the discrete Fourier mode $u_{j}(t)=\\exp(i(j\\theta-\\omega_{\\text{num}} t))$ into the semi-discrete equation. Here, $\\theta = k \\Delta x$ is the nondimensional wavenumber, $k$ is the wavenumber, and $\\omega_{\\text{num}}$ is the numerical angular frequency.\n\nThe time derivative of the Fourier mode is:\n$$u_{i}'(t) = \\frac{d}{dt} \\exp(i(i\\theta-\\omega_{\\text{num}} t)) = -i\\omega_{\\text{num}} \\exp(i(i\\theta-\\omega_{\\text{num}} t)) = -i\\omega_{\\text{num}} u_{i}(t)$$\nNext, we evaluate the spatial derivative term. The flux at interface $x_{i-1/2}$ is obtained by shifting the index $i$ to $i-1$ in the formula for $\\widehat{f}_{i+1/2}$:\n$$\\widehat{f}_{i-1/2}=\\frac{1}{60}\\left(2 u_{i-3}-13 u_{i-2}+47 u_{i-1}+27 u_{i}-3 u_{i+1}\\right)$$\nThe flux difference is then\n\\begin{align*} \\widehat{f}_{i+1/2} - \\widehat{f}_{i-1/2} &= \\frac{1}{60} \\left[ (0-2)u_{i-3} + (2 - (-13))u_{i-2} + (-13 - 47)u_{i-1} \\right. \\\\ & \\qquad \\left. + (47 - 27)u_{i} + (27 - (-3))u_{i+1} + (-3 - 0)u_{i+2} \\right] \\\\ &= \\frac{1}{60} \\left( -2u_{i-3} + 15u_{i-2} - 60u_{i-1} + 20u_{i} + 30u_{i+1} - 3u_{i+2} \\right)\\end{align*}\nTo evaluate this expression for the Fourier mode, we use the property $u_{i+j} = u_i e^{ij\\theta}$. Substituting this yields:\n\\begin{align*} \\left(u_{x}\\right)_{i} &= \\frac{1}{60\\Delta x} \\left( -2u_{i}e^{-3i\\theta} + 15u_{i}e^{-2i\\theta} - 60u_{i}e^{-i\\theta} + 20u_{i} + 30u_{i}e^{i\\theta} - 3u_{i}e^{2i\\theta} \\right) \\\\ &= \\frac{u_{i}(t)}{60\\Delta x} \\left( -2e^{-3i\\theta} + 15e^{-2i\\theta} - 60e^{-i\\theta} + 20 + 30e^{i\\theta} - 3e^{2i\\theta} \\right) \\end{align*}\nLet $Q(\\theta)$ represent the polynomial in the parentheses:\n$$Q(\\theta) = -2e^{-3i\\theta} + 15e^{-2i\\theta} - 60e^{-i\\theta} + 20 + 30e^{i\\theta} - 3e^{2i\\theta}$$\nThe spatial derivative term becomes $\\left(u_{x}\\right)_{i} = \\frac{u_i(t)}{60\\Delta x} Q(\\theta)$.\n\nNow, we substitute the expressions for the time and space derivatives back into the semi-discrete equation $u_{i}'(t) = -\\left(u_{x}\\right)_{i}$:\n$$-i\\omega_{\\text{num}} u_{i}(t) = -\\frac{u_{i}(t)}{60\\Delta x} Q(\\theta)$$\nSolving for $\\omega_{\\text{num}}$, we obtain the numerical dispersion relation:\n$$\\omega_{\\text{num}}(\\theta) = \\frac{1}{60 i \\Delta x} Q(\\theta) = \\frac{-i}{60 \\Delta x} Q(\\theta)$$\nThe numerical phase speed is defined as $c_{\\text{num}}(\\theta) = \\Re(\\omega_{\\text{num}})/k$. To find this, we first need the real part of $\\omega_{\\text{num}}$.\n$$\\Re(\\omega_{\\text{num}}) = \\Re\\left(\\frac{-i}{60 \\Delta x} Q(\\theta)\\right) = \\Re\\left(\\frac{-i}{60 \\Delta x} (\\Re(Q(\\theta)) + i\\Im(Q(\\theta)))\\right) = \\frac{1}{60 \\Delta x} \\Im(Q(\\theta))$$\nWe calculate the imaginary part of $Q(\\theta)$ using Euler's formula, $e^{i\\phi}=\\cos\\phi+i\\sin\\phi$:\n\\begin{align*} \\Im(Q(\\theta)) &= \\Im \\left( -2(\\cos(3\\theta)-i\\sin(3\\theta)) + 15(\\cos(2\\theta)-i\\sin(2\\theta)) - 60(\\cos\\theta-i\\sin\\theta) \\right. \\\\ & \\qquad \\left. + 20 + 30(\\cos\\theta+i\\sin\\theta) - 3(\\cos(2\\theta)+i\\sin(2\\theta)) \\right) \\\\ &= -2(-\\sin(3\\theta)) + 15(-\\sin(2\\theta)) - 60(-\\sin\\theta) + 30\\sin\\theta - 3\\sin(2\\theta) \\\\ &= 2\\sin(3\\theta) - 15\\sin(2\\theta) + 60\\sin\\theta + 30\\sin\\theta - 3\\sin(2\\theta) \\\\ &= 90\\sin\\theta - 18\\sin(2\\theta) + 2\\sin(3\\theta) \\end{align*}\nNow we can write the expression for the real part of $\\omega_{\\text{num}}$:\n$$\\Re(\\omega_{\\text{num}}) = \\frac{1}{60\\Delta x} \\left( 90\\sin\\theta - 18\\sin(2\\theta) + 2\\sin(3\\theta) \\right)$$\nThe numerical phase speed is $c_{\\text{num}}(\\theta) = \\Re(\\omega_{\\text{num}})/k$. With $k=\\theta/\\Delta x$, we have:\n$$c_{\\text{num}}(\\theta) = \\frac{\\frac{1}{60\\Delta x} (90\\sin\\theta - 18\\sin(2\\theta) + 2\\sin(3\\theta))}{\\theta/\\Delta x} = \\frac{90\\sin\\theta - 18\\sin(2\\theta) + 2\\sin(3\\theta)}{60\\theta}$$\nThe problem asks for the ratio $c_{\\text{num}}/c_{\\text{exact}}$ at $\\theta=\\pi/3$. Given $c_{\\text{exact}}=1$, this ratio is simply $c_{\\text{num}}(\\pi/3)$. We evaluate the expression at $\\theta=\\pi/3$:\n$$c_{\\text{num}}\\left(\\frac{\\pi}{3}\\right) = \\frac{90\\sin(\\pi/3) - 18\\sin(2\\pi/3) + 2\\sin(3\\pi/3)}{60(\\pi/3)}$$\nWe use the trigonometric identities:\n$\\sin(\\pi/3) = \\frac{\\sqrt{3}}{2}$\n$\\sin(2\\pi/3) = \\sin(\\pi-\\pi/3) = \\sin(\\pi/3) = \\frac{\\sqrt{3}}{2}$\n$\\sin(\\pi) = 0$\nSubstituting these values:\n$$c_{\\text{num}}\\left(\\frac{\\pi}{3}\\right) = \\frac{90\\left(\\frac{\\sqrt{3}}{2}\\right) - 18\\left(\\frac{\\sqrt{3}}{2}\\right) + 2(0)}{20\\pi} = \\frac{45\\sqrt{3} - 9\\sqrt{3}}{20\\pi} = \\frac{36\\sqrt{3}}{20\\pi}$$\nSimplifying the fraction gives the final result for the ratio:\n$$\\frac{c_{\\text{num}}}{c_{\\text{exact}}} = \\frac{9\\sqrt{3}}{5\\pi}$$",
            "answer": "$$\\boxed{\\frac{9\\sqrt{3}}{5\\pi}}$$"
        },
        {
            "introduction": "A complete numerical solver requires coupling a spatial discretization with a time-integration method, and the choice of the latter is critical for stability. This final exercise explores the crucial interaction between a WENO spatial discretization and various Runge-Kutta time steppers by examining the evolution of the discrete total variation, $\\mathrm{TV}(u)$, of the solution. You will discover why Strong-Stability-Preserving (SSP) methods are essential for ensuring that the combined scheme remains non-oscillatory when solving problems with shocks, a vital concept for building reliable shock-capturing codes .",
            "id": "2450643",
            "problem": "Consider the one-dimensional scalar hyperbolic conservation law given by the inviscid Burgers equation\n$$\nu_t + \\left(\\tfrac{1}{2}u^2\\right)_x = 0,\n$$\nposed on the periodic spatial domain $[-1,1]$ with initial data\n$$\nu(x,0) = \\begin{cases}\n1, & x < 0,\\\\\n0, & x \\ge 0.\n\\end{cases}\n$$\nLet the spatial grid be uniform with $N=400$ points covering $[-1,1)$, yielding grid spacing $\\Delta x = 2/N$. Use periodic boundary conditions. For spatial discretization, use a fifth-order Weighted Essentially Non-Oscillatory (WENO) reconstruction. With global Lax–Friedrichs flux splitting that employs the bound $\\alpha=\\max_i |u_i|$ at the current stage state. Define the semi-discrete operator $L(u)$ to approximate $- \\partial_x f(u)$ using this WENO flux at the cell nodes, where $f(u)=\\tfrac{1}{2}u^2$. Advance in time using explicit Runge–Kutta (RK) methods. Consider the following explicit time integrators: Forward Euler (FE), second-order Strong-Stability-Preserving Runge–Kutta (SSPRK2), third-order Strong-Stability-Preserving Runge–Kutta (SSPRK3), and classical fourth-order Runge–Kutta (RK4). The Strong-Stability-Preserving (SSP) property is evaluated by the monotonicity of the discrete total variation in time.\n\nDefine the discrete total variation of a state $u\\in\\mathbb{R}^N$ by\n$$\n\\mathrm{TV}(u) = \\sum_{i=0}^{N-1} \\left|u_{i+1}-u_i\\right|,\n$$\nwith periodic indexing $u_N \\equiv u_0$. Let the time step be determined at the beginning of each full time step by the Courant–Friedrichs–Lewy number $\\mathrm{CFL}$ according to\n$$\n\\Delta t = \\mathrm{CFL}\\,\\frac{\\Delta x}{\\max_i |u_i|},\n$$\nand clipped to not exceed the remaining time to the final time $T$. Use a fixed final time $T=0.2$. For each full time step, record the sequence of $\\mathrm{TV}$ values at every intermediate RK stage state and at the end-of-step state, in chronological order. A run is declared nonincreasing-in-$\\mathrm{TV}$ if this recorded sequence is monotonically nonincreasing within a tolerance $\\varepsilon=10^{-8}$ at every comparison, that is, if for every consecutive pair in the recorded sequence, the latter is less than or equal to the former plus $\\varepsilon$.\n\nImplement a program that for each test case integrates from $t=0$ to $t=T$ and returns a boolean indicating whether the recorded total variation sequence is monotonically nonincreasing as defined above. Use the following test suite, where each test case is a pair $(\\text{method name}, \\mathrm{CFL})$ and the method name is one of the strings \"FE\", \"SSPRK2\", \"SSPRK3\", \"RK4\":\n- $($\"SSPRK3\", $0.4)$,\n- $($\"SSPRK2\", $0.8)$,\n- $($\"FE\", $0.4)$,\n- $($\"RK4\", $0.8)$,\n- $($\"RK4\", $0.9)$,\n- $($\"SSPRK3\", $0.9)$,\n- $($\"FE\", $0.9)$.\n\nYour program should produce a single line of output containing the results for the test cases, in the same order as listed, formatted as a comma-separated list of boolean literals enclosed in square brackets, with no spaces. For example, the output should look like\n$$\n[\\text{True},\\text{False},\\dots]\n$$\nalthough the actual boolean values should be those computed by your program for the specified test suite.",
            "solution": "The problem requires the numerical solution of the one-dimensional inviscid Burgers' equation, a canonical example of a scalar hyperbolic conservation law:\n$$\n\\frac{\\partial u}{\\partial t} + \\frac{\\partial}{\\partial x}\\left(\\frac{1}{2}u^2\\right) = 0\n$$\nThe equation is defined on a periodic spatial domain $x \\in [-1, 1]$, with initial data given by a step function:\n$$\nu(x,0) = \\begin{cases} 1, & x < 0, \\\\ 0, & x \\ge 0. \\end{cases}\n$$\nWe are to investigate the total variation (TV) stability property of several explicit Runge-Kutta time integration schemes when coupled with a high-order spatial discretization.\n\nThe problem is first discretized in space using a finite volume method on a uniform grid of $N=400$ cells, with grid spacing $\\Delta x = 2/N$. This yields a system of ordinary differential equations (ODEs):\n$$\n\\frac{du_i}{dt} = -\\frac{1}{\\Delta x}(\\hat{f}_{i+1/2} - \\hat{f}_{i-1/2}) \\equiv L(u)_i\n$$\nwhere $u_i(t)$ is the cell-averaged solution in the $i$-th cell, and $\\hat{f}_{i+1/2}$ is the numerical flux at the interface between cells $i$ and $i+1$.\n\nThe numerical flux $\\hat{f}_{i+1/2}$ is constructed using a fifth-order Weighted Essentially Non-Oscillatory (WENO) method combined with a global Lax-Friedrichs flux splitting. The flux function $f(u) = \\frac{1}{2}u^2$ is split into its positive and negative parts:\n$$\nf^+(u) = \\frac{1}{2}(f(u) + \\alpha u), \\quad f^-(u) = \\frac{1}{2}(f(u) - \\alpha u)\n$$\nwhere $\\alpha = \\max_i |f'(u_i)| = \\max_i |u_i|$ is a global estimate of the maximum characteristic speed. The numerical flux is then the sum of the reconstructions of these split fluxes:\n$$\n\\hat{f}_{i+1/2} = \\hat{f}^+_{i+1/2} + \\hat{f}^-_{i+1/2}\n$$\nThe split flux component $\\hat{f}^+_{i+1/2}$ is reconstructed from the cell-averaged values $\\{f^+(u_j)\\}$ using a left-biased stencil, as its corresponding characteristic speeds are non-negative. Conversely, $\\hat{f}^-_{i+1/2}$ is reconstructed from $\\{f^-(u_j)\\}$ using a right-biased stencil, as its characteristic speeds are non-positive. This constitutes an upwind discretization.\n\nThe fifth-order WENO reconstruction of a value at an interface $x_{i+1/2}$ is a nonlinear convex combination of three third-order polynomial reconstructions. For the left-biased case, used for $\\hat{f}^+_{i+1/2}$, the value is derived from stencils over cells $\\{i-2, i-1, i\\}$, $\\{i-1, i, i+1\\}$, and $\\{i, i+1, i+2\\}$. The combination weights, denoted $\\omega_k$, are computed based on smoothness indicators $\\beta_k$ for each stencil. These indicators measure the oscillatory content of the reconstruction polynomial on each stencil. For a generic set of values $\\{v_j\\}$, the smoothness indicators are given by:\n$$\n\\begin{aligned}\n\\beta_0 &= \\frac{13}{12}(v_{i-2} - 2v_{i-1} + v_i)^2 + \\frac{1}{4}(v_{i-2} - 4v_{i-1} + 3v_i)^2 \\\\\n\\beta_1 &= \\frac{13}{12}(v_{i-1} - 2v_i + v_{i+1})^2 + \\frac{1}{4}(v_{i-1} - v_{i+1})^2 \\\\\n\\beta_2 &= \\frac{13}{12}(v_i - 2v_{i+1} + v_{i+2})^2 + \\frac{1}{4}(3v_i - 4v_{i+1} + v_{i+2})^2\n\\end{aligned}\n$$\nThe nonlinear weights are then $\\omega_k = \\gamma_k / (\\beta_k + \\varepsilon)^2$, where $\\{\\gamma_k\\} = \\{0.1, 0.6, 0.3\\}$ are the optimal linear weights and $\\varepsilon$ is a small parameter to avoid division by zero. After normalization, $\\tilde{\\omega}_k = \\omega_k / \\sum_j \\omega_j$, the final reconstructed value is $\\sum_k \\tilde{\\omega}_k p_k$, where $p_k$ is the value of the reconstruction polynomial from stencil $k$ evaluated at the interface. The right-biased reconstruction for $\\hat{f}^-_{i+1/2}$ is implemented by exploiting the symmetry of the scheme on a reversed data array.\n\nThe resulting semi-discrete system $\\frac{du}{dt} = L(u)$ is integrated in time using one of four explicit Runge-Kutta methods:\n1.  **Forward Euler (FE):** A first-order method, $u^{n+1} = u^n + \\Delta t L(u^n)$.\n2.  **SSPRK2:** A second-order Strong-Stability-Preserving method.\n    $$\n    \\begin{aligned}\n    u^{(1)} &= u^n + \\Delta t L(u^n) \\\\\n    u^{n+1} &= \\frac{1}{2}u^n + \\frac{1}{2}(u^{(1)} + \\Delta t L(u^{(1)}))\n    \\end{aligned}\n    $$\n3.  **SSPRK3:** A third-order Strong-Stability-Preserving method.\n    $$\n    \\begin{aligned}\n    u^{(1)} &= u^n + \\Delta t L(u^n) \\\\\n    u^{(2)} &= \\frac{3}{4}u^n + \\frac{1}{4}(u^{(1)} + \\Delta t L(u^{(1)})) \\\\\n    u^{n+1} &= \\frac{1}{3}u^n + \\frac{2}{3}(u^{(2)} + \\Delta t L(u^{(2)}))\n    \\end{aligned}\n    $$\n4.  **Classical RK4:** The classical fourth-order Runge-Kutta method, which is not generally SSP.\n    $$\n    \\begin{aligned}\n    k_1 &= L(u^n) \\\\\n    u^{(1)} &= u^n + \\frac{\\Delta t}{2} k_1 \\\\\n    k_2 &= L(u^{(1)}) \\\\\n    u^{(2)} &= u^n + \\frac{\\Delta t}{2} k_2 \\\\\n    k_3 &= L(u^{(2)}) \\\\\n    u^{(3)} &= u^n + \\Delta t k_3 \\\\\n    k_4 &= L(u^{(3)}) \\\\\n    u^{n+1} &= u^n + \\frac{\\Delta t}{6}(k_1 + 2k_2 + 2k_3 + k_4)\n    \\end{aligned}\n    $$\nThe time step $\\Delta t$ is determined by a Courant-Friedrichs-Lewy (CFL) condition: $\\Delta t = \\mathrm{CFL} \\frac{\\Delta x}{\\max_i |u_i|}$.\n\nThe core of the problem is to assess the \"nonincreasing-in-TV\" property of these schemes. The discrete total variation is defined as $\\mathrm{TV}(u) = \\sum_{i=0}^{N-1} |u_{i+1} - u_i|$, with periodic index $u_N \\equiv u_0$. For each full time step, we must record the TV of the solution at the beginning of the step, at each intermediate RK stage, and at the end of the step. A simulation run for a given method and CFL number is deemed \"nonincreasing-in-TV\" if and only if for every pair of consecutive recorded values in this sequence, $TV_{k+1} \\le TV_k + \\varepsilon$, where $\\varepsilon=10^{-8}$ is a small tolerance. This check is performed for every time step until the final time $T=0.2$. The non-SSP nature of classical RK4, for instance, may lead to intermediate stages whose TV exceeds that of the previous stage, thus violating this condition, especially at larger CFL numbers. The SSP methods are designed specifically to prevent this behavior, provided the CFL number is within the method's SSP limit.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for the specified test suite.\n    \"\"\"\n    # Problem Constants\n    N = 400\n    DOMAIN_START = -1.0\n    DOMAIN_END = 1.0\n    T_FINAL = 0.2\n    TV_TOLERANCE = 1e-8\n    WENO_EPS = 1e-40\n\n    DX = (DOMAIN_END - DOMAIN_START) / N\n    x = np.linspace(DOMAIN_START, DOMAIN_END, N, endpoint=False)\n\n    # Test cases from the problem statement.\n    test_cases = [\n        (\"SSPRK3\", 0.4),\n        (\"SSPRK2\", 0.8),\n        (\"FE\", 0.4),\n        (\"RK4\", 0.8),\n        (\"RK4\", 0.9),\n        (\"SSPRK3\", 0.9),\n        (\"FE\", 0.9),\n    ]\n\n    # --- WENO5 Implementation ---\n    # Based on the formulation by Jiang and Shu (1996)\n    \n    # Precompute constants for vectorized WENO flux calculation\n    C_p0 = np.array([1./3., -7./6., 11./6.])\n    C_p1 = np.array([-1./6., 5./6., 1./3.])\n    C_p2 = np.array([1./3., 5./6., -1./6.])\n    D_L = np.array([0.1, 0.6, 0.3])\n\n    def weno5_flux_reconstruction(v):\n        \"\"\"\n        Computes the 5th-order left-biased WENO flux reconstruction.\n        This is a vectorized implementation for performance.\n        \"\"\"\n        v_padded = np.pad(v, (3, 3), 'wrap')\n        \n        v_m2 = v_padded[1:-5]\n        v_m1 = v_padded[2:-4]\n        v_0  = v_padded[3:-3]\n        v_p1 = v_padded[4:-2]\n        v_p2 = v_padded[5:-1]\n\n        # Smoothness indicators (beta)\n        beta0 = 13./12. * (v_m2 - 2*v_m1 + v_0)**2 + 0.25 * (v_m2 - 4*v_m1 + 3*v_0)**2\n        beta1 = 13./12. * (v_m1 - 2*v_0 + v_p1)**2 + 0.25 * (v_m1 - v_p1)**2\n        beta2 = 13./12. * (v_0 - 2*v_p1 + v_p2)**2 + 0.25 * (3*v_0 - 4*v_p1 + v_p2)**2\n        \n        # Nonlinear weights (alpha -> omega)\n        alpha0 = D_L[0] / (WENO_EPS + beta0)**2\n        alpha1 = D_L[1] / (WENO_EPS + beta1)**2\n        alpha2 = D_L[2] / (WENO_EPS + beta2)**2\n        sum_alpha = alpha0 + alpha1 + alpha2\n        \n        w0 = alpha0 / sum_alpha\n        w1 = alpha1 / sum_alpha\n        w2 = alpha2 / sum_alpha\n        \n        # Reconstructed fluxes from each sub-stencil\n        p0 = C_p0[0]*v_m2 + C_p0[1]*v_m1 + C_p0[2]*v_0\n        p1 = C_p1[0]*v_m1 + C_p1[1]*v_0  + C_p1[2]*v_p1\n        p2 = C_p2[0]*v_0  + C_p2[1]*v_p1  + C_p2[2]*v_p2\n        \n        return w0*p0 + w1*p1 + w2*p2\n\n    def spatial_operator_L(u):\n        \"\"\"\n        Computes the semi-discrete operator L(u) = -d/dx(f(u)).\n        \"\"\"\n        alpha = np.max(np.abs(u))\n        \n        f = 0.5 * u**2\n        f_plus = 0.5 * (f + alpha * u)\n        f_minus = 0.5 * (f - alpha * u)\n        \n        # Reconstruct positive flux (left-biased)\n        f_hat_plus = weno5_flux_reconstruction(f_plus)\n        \n        # Reconstruct negative flux (right-biased) using symmetry\n        f_minus_rev = f_minus[::-1]\n        f_hat_minus_rev = weno5_flux_reconstruction(f_minus_rev)\n        f_hat_minus = f_hat_minus_rev[::-1]\n        \n        # Total numerical flux at interfaces i+1/2\n        f_hat = f_hat_plus + f_hat_minus\n        \n        # Finite volume difference\n        f_hat_im12 = np.roll(f_hat, 1)\n        \n        return -(f_hat - f_hat_im12) / DX\n\n    def total_variation(u):\n        \"\"\"Computes the total variation of a state vector.\"\"\"\n        return np.sum(np.abs(u - np.roll(u, -1)))\n\n    # --- Time Stepper Implementations ---\n    def step_fe(u, dt, L_op):\n        tv0 = total_variation(u)\n        u_next = u + dt * L_op(u)\n        tv1 = total_variation(u_next)\n        return u_next, [tv0, tv1]\n\n    def step_ssprk2(u, dt, L_op):\n        tv0 = total_variation(u)\n        u1 = u + dt * L_op(u)\n        tv1 = total_variation(u1)\n        u_next = 0.5 * u + 0.5 * (u1 + dt * L_op(u1))\n        tv2 = total_variation(u_next)\n        return u_next, [tv0, tv1, tv2]\n\n    def step_ssprk3(u, dt, L_op):\n        tv0 = total_variation(u)\n        u1 = u + dt * L_op(u)\n        tv1 = total_variation(u1)\n        u2 = 0.75 * u + 0.25 * (u1 + dt * L_op(u1))\n        tv2 = total_variation(u2)\n        u_next = (1./3.) * u + (2./3.) * (u2 + dt * L_op(u2))\n        tv3 = total_variation(u_next)\n        return u_next, [tv0, tv1, tv2, tv3]\n\n    def step_rk4(u, dt, L_op):\n        tv0 = total_variation(u)\n        k1 = L_op(u)\n        stage1 = u + dt/2. * k1\n        tv1 = total_variation(stage1)\n        k2 = L_op(stage1)\n        stage2 = u + dt/2. * k2\n        tv2 = total_variation(stage2)\n        k3 = L_op(stage2)\n        stage3 = u + dt * k3\n        tv3 = total_variation(stage3)\n        k4 = L_op(stage3)\n        u_next = u + dt/6. * (k1 + 2*k2 + 2*k3 + k4)\n        tv4 = total_variation(u_next)\n        return u_next, [tv0, tv1, tv2, tv3, tv4]\n\n    stepper_map = {\n        \"FE\": step_fe,\n        \"SSPRK2\": step_ssprk2,\n        \"SSPRK3\": step_ssprk3,\n        \"RK4\": step_rk4,\n    }\n\n    results = []\n    for method_name, cfl in test_cases:\n        # Initial condition\n        u = np.where(x < 0, 1.0, 0.0)\n        \n        t = 0.0\n        is_tv_nonincreasing = True\n        stepper = stepper_map[method_name]\n\n        while t < T_FINAL:\n            max_u_abs = np.max(np.abs(u))\n            # Prevent division by zero if u is all zero\n            if max_u_abs < 1e-12: \n                break \n            \n            dt = cfl * DX / max_u_abs\n            dt = min(dt, T_FINAL - t)\n            \n            u_next, tv_sequence = stepper(u, dt, spatial_operator_L)\n            \n            for i in range(len(tv_sequence) - 1):\n                if tv_sequence[i+1] > tv_sequence[i] + TV_TOLERANCE:\n                    is_tv_nonincreasing = False\n                    break\n            \n            if not is_tv_nonincreasing:\n                break\n                \n            u = u_next\n            t += dt\n            \n        results.append(is_tv_nonincreasing)\n\n    # Format the final output string\n    output_str = f\"[{','.join(map(str, results))}]\".replace(\"True\", \"true\").replace(\"False\", \"false\")\n    print(output_str)\n\n# Run the simulation\nsolve()\n```"
        }
    ]
}