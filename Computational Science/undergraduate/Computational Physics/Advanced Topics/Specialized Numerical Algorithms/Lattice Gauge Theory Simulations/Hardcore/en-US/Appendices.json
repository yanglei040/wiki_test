{
    "hands_on_practices": [
        {
            "introduction": "The Wilson-Dirac operator is a cornerstone of lattice simulations involving quarks. This exercise demystifies this fundamental object by guiding you to construct its matrix representation from first principles in a simplified two-dimensional model. By calculating its eigenvalues, you will also investigate \"exceptional configurations,\" a critical numerical artifact related to the operator's spectrum that can affect the stability of simulations.",
            "id": "2407358",
            "problem": "Consider a two-dimensional lattice formulation of Wilson fermions in a simplified, quenched Quantum Chromodynamics (QCD) toy model with gauge group $U(1)$ to illustrate the mechanism of \"exceptional configurations\" that lead to unphysically small quark masses. Work on a square lattice of linear extent $L$ with periodic boundary conditions and lattice spacing $a=1$ (dimensionless lattice units). Use the Wilson parameter $r=1$ and a two-component Euclidean spinor with gamma matrices given by $\\gamma_1=\\sigma_1$, $\\gamma_2=\\sigma_2$, and $\\gamma_5=\\sigma_3$, where $\\sigma_i$ are Pauli matrices.\n\nLet lattice sites be labeled by $x=(x_1,x_2)$ with $x_\\mu \\in \\{0,1,\\dots,L-1\\}$ and unit vectors $\\hat{\\mu}$ for $\\mu \\in \\{1,2\\}$. The gauge links are $U_\\mu(x) \\in U(1)$, represented as complex phases $U_\\mu(x)=e^{i \\theta_\\mu(x)}$. The two-dimensional Wilson-Dirac operator $D_W(m_0)$ of bare mass $m_0$ acts on spinor fields $\\psi(x)$ as\n$$\n\\left[D_W(m_0)\\psi\\right](x) \\;=\\; \\left(m_0 + 2 d r\\right)\\psi(x) \\;-\\; \\frac{1}{2}\\sum_{\\mu=1}^{2} \\left\\{ \\left(r - \\gamma_\\mu\\right) U_\\mu(x)\\,\\psi(x+\\hat{\\mu}) \\;+\\; \\left(r + \\gamma_\\mu\\right) U_\\mu^\\dagger(x-\\hat{\\mu})\\,\\psi(x-\\hat{\\mu}) \\right\\},\n$$\nwith $d=2$ and periodic boundary conditions understood in the neighbor indices. Define the Hermitian Wilson-Dirac operator $H_W(m_0)$ as\n$$\nH_W(m_0) \\;=\\; \\gamma_5 \\, D_W(m_0).\n$$\nA configuration is deemed \"exceptional\" at a given bare mass $m_0$ if the smallest absolute eigenvalue of $H_W(m_0)$ is strictly less than a specified positive threshold $\\lambda_{\\text{thr}}$, that is,\n$$\n\\min_j \\left|\\lambda_j\\left(H_W(m_0)\\right)\\right| \\;<\\; \\lambda_{\\text{thr}}.\n$$\nHere the $\\lambda_j\\left(H_W(m_0)\\right)$ are the real eigenvalues of the Hermitian matrix $H_W(m_0)$. All quantities are dimensionless; any angle must be expressed in radians.\n\nGauge backgrounds to be considered:\n- \"free\": $U_\\mu(x)=1$ for all $x$ and $\\mu$.\n- \"dislocation\": $U_\\mu(x)=1$ for all $x$ and $\\mu$ except for a single forward link at a specified site and direction set to a nontrivial phase $U_{\\mu^\\star}(x^\\star)=e^{i\\phi}$, with $x^\\star=(0,0)$, $\\mu^\\star=1$, and angle $\\phi$ in radians.\n\nYour task is to write a complete program that, for each test case, constructs $H_W(m_0)$ on the specified lattice and gauge background, computes $\\min_j |\\lambda_j(H_W(m_0))|$, and returns a boolean indicating whether the configuration is exceptional under the strict inequality above.\n\nTest suite (angles are in radians):\n- Case $1$: $L=4$, gauge \"free\", $m_0=-1.90$, $\\lambda_{\\text{thr}}=0.04$.\n- Case $2$: $L=4$, gauge \"free\", $m_0=-1.97$, $\\lambda_{\\text{thr}}=0.04$.\n- Case $3$: $L=4$, gauge \"free\", $m_0=-1.96$, $\\lambda_{\\text{thr}}=0.04$.\n- Case $4$: $L=4$, gauge \"dislocation\" with $\\phi=\\pi$, $m_0=-1.90$, $\\lambda_{\\text{thr}}=0.10$.\n\nFinal output format:\nYour program should produce a single line of output containing the boolean results for the cases in the order listed above as a comma-separated list enclosed in square brackets. For example, an output with four results must look like\n$$\n[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4].\n$$",
            "solution": "The problem presented is a well-defined task in computational physics, specifically in the domain of lattice gauge theory. It requires the numerical analysis of the Wilson-Dirac operator in a simplified two-dimensional $U(1)$ gauge model. The problem statement is scientifically sound, all parameters and definitions are provided, and the task is computationally feasible. Therefore, the problem is valid.\n\nThe solution requires constructing the matrix representation of the Hermitian Wilson-Dirac operator, $H_W(m_0) = \\gamma_5 D_W(m_0)$, and then numerically determining its eigenvalues. An 'exceptional configuration' is identified if the smallest absolute eigenvalue falls below a given threshold, $\\lambda_{\\text{thr}}$.\n\nLet us first formalize the construction of the matrix $H_W(m_0)$. The total Hilbert space is a tensor product of the space of lattice sites and the spinor space. For a lattice of size $L \\times L$, there are $N_s = L^2$ sites. With two-component spinors, the total dimension of the vector space is $N_{dim} = 2 \\times N_s$. We can establish a mapping from a site $x=(x_1, x_2)$ and spinor index $\\alpha \\in \\{0, 1\\}$ to a single matrix index. A common choice is a lexicographical ordering, where the composite index for $(\\,(x_1, x_2), \\alpha\\,)$ is $k = 2(x_1 L + x_2) + \\alpha$.\n\nThe operator $H_W(m_0)$ is built from the Wilson-Dirac operator $D_W(m_0)$ given by:\n$$\n\\left[D_W(m_0)\\psi\\right](x) \\;=\\; \\left(m_0 + 2 d r\\right)\\psi(x) \\;-\\; \\frac{1}{2}\\sum_{\\mu=1}^{2} \\left\\{ \\left(r - \\gamma_\\mu\\right) U_\\mu(x)\\,\\psi(x+\\hat{\\mu}) \\;+\\; \\left(r + \\gamma_\\mu\\right) U_\\mu^\\dagger(x-\\hat{\\mu})\\,\\psi(x-\\hat{\\mu}) \\right\\}\n$$\nWith parameters $d=2$ and $r=1$, the on-site term is $(m_0+4)\\psi(x)$. The operator $D_W$ is represented by a matrix whose elements $D_{(x',\\alpha'),(x,\\alpha)}$ describe the coupling from a spinor component $\\alpha$ at site $x$ to a component $\\alpha'$ at site $x'$. From the expression above, we can identify these matrix elements:\n1.  **On-site term**: The term $(m_0+4)\\psi(x)$ contributes to the diagonal blocks of the matrix. It couples spinor components at the same site $x$.\n    $$ D_{(x,\\alpha'),(x,\\alpha)} = (m_0+4)\\delta_{\\alpha'\\alpha} $$\n2.  **Forward hopping term**: The term $-\\frac{1}{2}(r - \\gamma_\\mu) U_\\mu(x)\\psi(x+\\hat{\\mu})$ couples site $x+\\hat{\\mu}$ to site $x$.\n    $$ D_{(x,\\alpha'),(x+\\hat{\\mu},\\alpha)} = -\\frac{1}{2} (r-\\gamma_\\mu)_{\\alpha'\\alpha} U_\\mu(x) $$\n3.  **Backward hopping term**: The term $-\\frac{1}{2}(r + \\gamma_\\mu) U_\\mu^\\dagger(x-\\hat{\\mu})\\psi(x-\\hat{\\mu})$ couples site $x-\\hat{\\mu}$ to site $x$.\n    $$ D_{(x,\\alpha'),(x-\\hat{\\mu},\\alpha)} = -\\frac{1}{2} (r+\\gamma_\\mu)_{\\alpha'\\alpha} U_\\mu^\\dagger(x-\\hat{\\mu}) $$\nAll other matrix elements of $D_W$ are zero. Periodic boundary conditions are applied to find neighboring sites. For a site $x=(x_1,x_2)$, its neighbor in the $+\\hat{1}$ direction is $((x_1+1) \\pmod L, x_2)$, and so on.\n\nThe Hermitian operator $H_W(m_0)$ is defined as $H_W(m_0) = \\gamma_5 D_W(m_0)$. In matrix form, this corresponds to a left-multiplication of each $2 \\times 2$ spinor block of the $D_W$ matrix by the $\\gamma_5$ matrix. The blocks of $H_W$ are:\n1.  **On-site block**: $H_{x,x} = \\gamma_5 D_{x,x} = (m_0+4)\\gamma_5$\n2.  **Forward hopping block**: $H_{x,x+\\hat{\\mu}} = \\gamma_5 D_{x,x+\\hat{\\mu}} = -\\frac{1}{2}\\gamma_5(r-\\gamma_\\mu)U_\\mu(x)$\n3.  **Backward hopping block**: $H_{x,x-\\hat{\\mu}} = \\gamma_5 D_{x,x-\\hat{\\mu}} = -\\frac{1}{2}\\gamma_5(r+\\gamma_\\mu)U_\\mu^\\dagger(x-\\hat{\\mu})$\n\nThe gamma matrices specified are the Pauli matrices: $\\gamma_1=\\sigma_1$, $\\gamma_2=\\sigma_2$, $\\gamma_5=\\sigma_3$. These satisfy the necessary anticommutation relation $\\{\\gamma_\\mu, \\gamma_5\\} = 0$ for $\\mu=1,2$, which ensures the $\\gamma_5$-hermiticity of $D_W$ and thus the hermiticity of $H_W$.\n\nThe algorithm to solve the problem is as follows:\n1.  For each test case, define the parameters $L$, $m_0$, and $\\lambda_{\\text{thr}}$.\n2.  Generate the gauge field configuration $\\{U_\\mu(x)\\}$ for all sites $x$ and directions $\\mu$. For the \"free\" case, all $U_\\mu(x)=1$. For the \"dislocation\" case, $U_1((0,0)) = e^{i\\phi}$ and all other links are $1$.\n3.  Initialize an $N_{dim} \\times N_{dim}$ zero matrix with complex entries for $H_W$.\n4.  Iterate through each lattice site $x=(x_1,x_2)$ from $(0,0)$ to $(L-1,L-1)$. For each site, compute the corresponding $2 \\times 2$ blocks of $H_W$ and place them in the matrix.\n    -   The diagonal block $H_{x,x}$ is placed at the matrix indices corresponding to site $x$ for both row and column.\n    -   For each direction $\\mu \\in \\{1,2\\}$, compute the forward neighbor $x_{fwd} = x+\\hat{\\mu}$ and the backward neighbor $x_{bwd} = x-\\hat{\\mu}$.\n    -   Place the forward hopping block $H_{x,x+\\hat{\\mu}}$ at the row block for $x$ and column block for $x_{fwd}$.\n    -   Place the backward hopping block $H_{x,x-\\hat{\\mu}}$ at the row block for $x$ and column block for $x_{bwd}$.\n5.  Once the full matrix $H_W$ is constructed, its eigenvalues are computed. Since $H_W$ is Hermitian, its eigenvalues are real, and we can use a specialized numerical routine like `numpy.linalg.eigvalsh`.\n6.  Find the minimum value of $|\\lambda_j|$ over all eigenvalues $\\lambda_j$.\n7.  Compare this minimum absolute eigenvalue with the threshold $\\lambda_{\\text{thr}}$. If $\\min_j|\\lambda_j| < \\lambda_{\\text{thr}}$, the configuration is exceptional (True); otherwise, it is not (False).\n\nThis procedure is implemented for each test case to produce the final boolean results. For the free case, the results can be verified analytically by Fourier transforming the operator, which reveals that the eigenvalues are given by $\\lambda = \\pm \\sqrt{(m_0+4 - \\cos p_1 - \\cos p_2)^2 + \\sin^2 p_1 + \\sin^2 p_2}$ for momenta $p_\\mu = \\frac{2\\pi k_\\mu}{L}$. The minimum absolute eigenvalue corresponds to the momentum mode that minimizes this expression. For our parameters, this occurs at $p=(0,0)$ where $|\\lambda| = |m_0+2|$. For the dislocation case, such a simplification is not possible, and a full numerical diagonalization is required.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function to run all test cases provided in the problem.\n    \"\"\"\n    test_cases = [\n        # Case 1: L=4, free, m0=-1.90, thr=0.04\n        (4, ('free',), -1.90, 0.04),\n        # Case 2: L=4, free, m0=-1.97, thr=0.04\n        (4, ('free',), -1.97, 0.04),\n        # Case 3: L=4, free, m0=-1.96, thr=0.04\n        (4, ('free',), -1.96, 0.04),\n        # Case 4: L=4, dislocation, m0=-1.90, thr=0.10\n        (4, ('dislocation', np.pi), -1.90, 0.10)\n    ]\n\n    results = []\n    for case in test_cases:\n        L, gauge_config, m0, lambda_thr = case\n        is_exc = is_exceptional(L, gauge_config, m0, lambda_thr)\n        results.append(is_exc)\n\n    # The final output must be lowercase boolean values.\n    print(f\"[{','.join(map(str, results)).lower()}]\")\n\ndef is_exceptional(L, gauge_config, m0, lambda_thr):\n    \"\"\"\n    Determines if a given lattice configuration is exceptional.\n\n    This function constructs the Hermitian Wilson-Dirac operator H_W, computes its\n    eigenvalues, and then checks if the smallest absolute eigenvalue is strictly\n    less than the specified threshold.\n    \n    Args:\n        L (int): The linear extent of the square lattice.\n        gauge_config (tuple): Specifies the gauge field background.\n                              e.g., ('free',) or ('dislocation', phi).\n        m0 (float): The bare mass parameter.\n        lambda_thr (float): The eigenvalue threshold for the exceptional condition.\n\n    Returns:\n        bool: True if the configuration is exceptional, False otherwise.\n    \"\"\"\n    # Construct the full matrix for the operator H_W.\n    Hw = build_hw_matrix(L, m0, gauge_config)\n    \n    # Eigenvalues of a Hermitian matrix are real.\n    # We use numpy's specialized solver for Hermitian matrices.\n    eigenvalues = np.linalg.eigvalsh(Hw)\n    \n    # Find the minimum of the absolute values of the eigenvalues.\n    min_abs_eigenvalue = np.min(np.abs(eigenvalues))\n    \n    # Check the strict inequality for the exceptional condition.\n    return min_abs_eigenvalue < lambda_thr\n\ndef build_hw_matrix(L, m0, gauge_config):\n    \"\"\"\n    Constructs the matrix for the Hermitian Wilson-Dirac operator H_W = gamma_5 * D_W.\n    \n    Args:\n        L (int): The linear extent of the lattice.\n        m0 (float): The bare mass.\n        gauge_config (tuple): The gauge field configuration.\n\n    Returns:\n        numpy.ndarray: The complex matrix representing H_W.\n    \"\"\"\n    N_sites = L * L\n    dim = 2 * N_sites\n    Hw = np.zeros((dim, dim), dtype=np.complex128)\n    \n    # Parameters from problem statement\n    r = 1.0\n    d = 2\n\n    # Gamma matrices (in 2D, these are the Pauli matrices)\n    gamma1 = np.array([[0, 1], [1, 0]], dtype=np.complex128)\n    gamma2 = np.array([[0, -1j], [1j, 0]], dtype=np.complex128)\n    gamma5 = np.array([[1, 0], [0, -1]], dtype=np.complex128)\n    gamma = {1: gamma1, 2: gamma2}\n    I2 = np.identity(2, dtype=np.complex128)\n\n    # Generate the gauge link configuration U_mu(x) as a dictionary.\n    links_U = {}\n    config_type = gauge_config[0]\n    for x1 in range(L):\n        for x2 in range(L):\n            links_U[(x1, x2, 1)] = 1.0 + 0.0j\n            links_U[(x1, x2, 2)] = 1.0 + 0.0j\n    \n    if config_type == \"dislocation\":\n        # Introduce a non-trivial link at x*=(0,0), mu*=1 with angle phi\n        phi = gauge_config[1]\n        links_U[(0, 0, 1)] = np.exp(1j * phi)\n\n    # Prefactor for the mass term from the definition: (m_0 + 2*d*r)\n    mass_term_prefactor = m0 + 2 * d * r\n\n    # Iterate over all lattice sites x (defining the matrix's row blocks)\n    for x1 in range(L):\n        for x2 in range(L):\n            x_idx = x1 * L + x2  # Row-major site index\n            \n            # --- Diagonal Block: connects site x to itself ---\n            # This block is H_{x,x} = gamma_5 * (m_0 + 2*d*r) * I_2\n            diag_block = mass_term_prefactor * gamma5\n            Hw[2*x_idx : 2*x_idx+2, 2*x_idx : 2*x_idx+2] = diag_block\n            \n            # --- Off-diagonal (hopping) blocks ---\n            for mu in [1, 2]:\n                # --- Forward hop: connects site x+mu to x ---\n                # This contributes to matrix block H_{x, x+mu}\n                x_fwd_1 = (x1 + 1) % L if mu == 1 else x1\n                x_fwd_2 = (x2 + 1) % L if mu == 2 else x2\n                x_fwd_idx = x_fwd_1 * L + x_fwd_2\n                \n                U_mu_x = links_U[(x1, x2, mu)]\n                # The block is -1/2 * gamma_5 * (r*I_2 - gamma_mu) * U_mu(x)\n                fwd_hop_block = -0.5 * (gamma5 @ (r * I2 - gamma[mu])) * U_mu_x\n                Hw[2*x_idx : 2*x_idx+2, 2*x_fwd_idx : 2*x_fwd_idx+2] = fwd_hop_block\n                \n                # --- Backward hop: connects site x-mu to x ---\n                # This contributes to matrix block H_{x, x-mu}\n                x_bwd_1 = (x1 - 1 + L) % L if mu == 1 else x1\n                x_bwd_2 = (x2 - 1 + L) % L if mu == 2 else x2\n                x_bwd_idx = x_bwd_1 * L + x_bwd_2\n\n                # The formula requires the link U_mu(x-mu)\n                U_mu_x_minus_mu = links_U[(x_bwd_1, x_bwd_2, mu)]\n                # The block is -1/2 * gamma_5 * (r*I_2 + gamma_mu) * U_mu(x-mu)^dagger\n                bwd_hop_block = -0.5 * (gamma5 @ (r * I2 + gamma[mu])) * np.conj(U_mu_x_minus_mu)\n                Hw[2*x_idx : 2*x_idx+2, 2*x_bwd_idx : 2*x_bwd_idx+2] = bwd_hop_block\n                \n    return Hw\n\n# Execute the solver\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "A key prediction of QCD is quark confinement, which is characterized by the linear rise of the static potential $V(r)$ between a quark-antiquark pair. Lattice simulations provide a powerful tool to compute this potential from the expectation values of Wilson loops. This practice introduces one of the most important data analysis techniques in the field: extracting a ground-state energy by identifying the \"plateau\" in the effective mass plotted against Euclidean time.",
            "id": "2407364",
            "problem": "Consider a pure gauge theory in Euclidean space-time discretized on a hypercubic lattice with lattice spacing $a$. All quantities are to be expressed in lattice units, i.e., set $a = 1$, so that all distances and times are dimensionless. In Euclidean Lattice Gauge Theory (LGT), the expectation value of a rectangular Wilson loop $\\langle W(r, t) \\rangle$ encodes the energy of a static quark-antiquark pair separated by spatial distance $r$ propagated for Euclidean time extent $t$. From the transfer-matrix construction, the large-$t$ decay of $\\langle W(r, t) \\rangle$ is governed by the lowest energy state compatible with the static sources at separation $r$. This lowest energy is the static potential $V(r)$ in lattice units. Your task is to implement a principled numerical estimator for $V(r)$ from provided synthetic measurements of $\\langle W(r, t) \\rangle$ as a function of $t$ for several fixed values of $r$. Work entirely with the provided data below and produce numerical answers in lattice units.\n\nDesign your program to:\n- Use only the late-time behavior implied by the transfer-matrix formalism, starting from the general principle that a Euclidean-time correlator is a sum of decaying exponentials dominated at large $t$ by the lowest energy.\n- Construct from $\\log \\langle W(r, t) \\rangle$ a discrete-time effective decay rate based on successive time slices, and detect a ground-state plateau in that effective rate using a stability threshold $\\delta$ and a minimum plateau length $L_{\\min}$.\n- If no plateau of length at least $L_{\\min}$ is found, perform a least-squares linear fit to $\\log \\langle W(r, t) \\rangle$ over the last $K$ time slices with $K = \\max(L_{\\min}+1, \\lfloor T/2 \\rfloor)$, where $T$ is the number of available time slices for that case.\n- Return one estimate per case, each rounded to three decimals.\n\nPlateau detection rule:\n- Let $\\delta = 0.02$ and $L_{\\min} = 3$.\n- Identify the longest contiguous window in the discrete effective decay-rate sequence where successive changes have absolute value smaller than $\\delta$. Among ties, prefer the window with the smallest sample variance. Estimate $V(r)$ by the mean value over that window.\n\nData to analyze (synthetic, self-consistent, and strictly positive to avoid any issues taking logarithms). For each case, $t$ runs over integer slices listed explicitly; all numbers are given to six decimal places. The separation $r$ is provided for context but does not enter the estimator beyond identifying the case.\n\nCase $1$ (separation $r = 2$, $t \\in \\{1,2,3,4,5,6,7,8\\}$):\n- $\\langle W(2, t) \\rangle = [0.885200, 0.683800, 0.529500, 0.409900, 0.319400, 0.249000, 0.193900, 0.151200]$\n\nCase $2$ (separation $r = 3$, $t \\in \\{1,2,3,4,5,6,7,8\\}$):\n- $\\langle W(3, t) \\rangle = [0.784200, 0.553600, 0.392000, 0.278800, 0.198600, 0.141700, 0.101100, 0.072150]$\n\nCase $3$ (separation $r = 1$, $t \\in \\{1,2,3,4,5\\}$):\n- $\\langle W(1, t) \\rangle = [0.860708, 0.740818, 0.637628, 0.548812, 0.472367]$\n\nCase $4$ (separation $r = 4$, $t \\in \\{1,2,3,4,5,6,7,8\\}$):\n- $\\langle W(4, t) \\rangle = [0.756250, 0.465500, 0.289700, 0.182200, 0.115400, 0.073050, 0.046930, 0.030016]$\n\nNumerical and output requirements:\n- All outputs must be expressed in lattice units (dimensionless).\n- For each case, return a single real number equal to your estimate of $V(r)$, rounded to three decimals.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the cases above. For example, the output must look like $[v_1,v_2,v_3,v_4]$ with each $v_i$ shown with exactly three digits after the decimal point.\n\nTest suite and coverage:\n- Case $1$ is a standard “happy path” with mild excited-state contamination and a clear late-time plateau.\n- Case $2$ tests a steeper decay with a longer time series and a well-defined plateau.\n- Case $3$ is a boundary case with a short time range and nearly pure single-exponential decay.\n- Case $4$ is a challenging case with stronger contamination at early times; the estimator must rely on late-time stability.\n\nYour program must be complete and runnable as given, require no user input, and adhere strictly to the final output format.",
            "solution": "The problem requires the estimation of the static quark-antiquark potential, denoted $V(r)$, from synthetic data for the expectation value of a rectangular Wilson loop, $\\langle W(r, t) \\rangle$. The analysis is performed within the framework of Euclidean Lattice Gauge Theory, with all quantities expressed in dimensionless lattice units where the lattice spacing $a$ is set to $1$.\n\nThe fundamental principle underlying this problem is derived from the transfer-matrix formalism of lattice field theory. A Euclidean-time correlator, such as $\\langle W(r, t) \\rangle$, can be expressed as a sum over energy eigenstates of the system's Hamiltonian:\n$$\n\\langle W(r, t) \\rangle = \\sum_{n=0}^{\\infty} |\\langle n | \\hat{W}(r) | \\Omega \\rangle|^2 e^{-E_n(r) t}\n$$\nwhere $|\\Omega\\rangle$ is the vacuum state, $\\hat{W}(r)$ is the operator creating the Wilson loop of spatial size $r$ at time $t=0$, and $|n\\rangle$ are the energy eigenstates of the system containing the static quark-antiquark sources, with corresponding energies $E_n(r)$. For large Euclidean time $t$, the sum is dominated by the term with the lowest energy, the ground state $E_0(r)$, which is by definition the static potential $V(r)$. Thus, for sufficiently large $t$, we have the approximation:\n$$\n\\langle W(r, t) \\rangle \\approx C \\cdot e^{-V(r)t}\n$$\nwhere $C = |\\langle 0 | \\hat{W}(r) | \\Omega \\rangle|^2$ is a constant overlap factor.\n\nTo extract $V(r)$, we can analyze the logarithm of the Wilson loop data:\n$$\n\\log \\langle W(r, t) \\rangle \\approx \\log(C) - V(r)t\n$$\nThis shows that $\\log \\langle W(r, t) \\rangle$ is approximately a linear function of $t$ with a slope of $-V(r)$. A standard method to estimate this slope locally is to compute the discrete derivative, which defines an effective potential or effective mass, $V_{\\text{eff}}(t)$. It is defined for a discrete time step of $\\Delta t = 1$ as:\n$$\nV_{\\text{eff}}(t) = -\\frac{\\log \\langle W(r, t+1) \\rangle - \\log \\langle W(r, t) \\rangle}{(t+1) - t} = -\\log\\left(\\frac{\\langle W(r, t+1) \\rangle}{\\langle W(r, t) \\rangle}\\right)\n$$\nAs $t$ becomes large, the contributions from excited states with $E_n(r) > V(r)$ become negligible, and $V_{\\text{eff}}(t)$ approaches the true potential $V(r)$, forming a \"plateau\" in a plot of $V_{\\text{eff}}$ versus $t$. The task is to identify this plateau and extract an estimate for $V(r)$.\n\nThe prescribed algorithm for this task is as follows:\n\n1.  For each dataset of $\\langle W(r, t) \\rangle$ values, calculate the sequence of effective potentials $V_{\\text{eff}}(t)$. A dataset with $T$ time slices will yield a sequence of $T-1$ values for $V_{\\text{eff}}$.\n\n2.  Search for a plateau in the $V_{\\text{eff}}(t)$ sequence. A contiguous subsequence (window) of $V_{\\text{eff}}$ values is considered a plateau if the absolute difference between any two successive values in the window is less than a stability threshold, $\\delta = 0.02$.\n\n3.  From all such identified plateaus, select the one that meets the criteria:\n    a. It must have a length of at least $L_{\\min} = 3$.\n    b. Among all plateaus satisfying (a), we choose the one with the maximum length.\n    c. If there is a tie for the maximum length, the tie is broken by selecting the window with the smallest sample variance.\n\n4.  If a unique best plateau is found by this procedure, the estimate for $V(r)$ is the arithmetic mean of the $V_{\\text{eff}}$ values within that plateau window.\n\n5.  If no plateau of length at least $L_{\\min}=3$ is found, a fallback procedure is used. A least-squares linear fit is performed on the last $K$ points of the $\\log \\langle W(r, t) \\rangle$ versus $t$ data. The number of points for the fit is given by $K = \\max(L_{\\min}+1, \\lfloor T/2 \\rfloor)$. The estimate for the potential is then $V(r) = -m$, where $m$ is the slope of the fitted line.\n\nLet us illustrate with Case $4$ ($r=4, T=8$):\nThe data for $\\langle W(4, t) \\rangle$ are given. First, we compute the natural logarithm:\n$\\log \\langle W(4, t) \\rangle = [-0.27941, -0.76461, -1.23891, -1.70261, -2.15951, -2.61641, -2.99720, -3.50600]$\nNext, we calculate the effective potential sequence $V_{\\text{eff}}(t) = -(\\log \\langle W(4, t+1) \\rangle - \\log \\langle W(4, t) \\rangle)$:\n$V_{\\text{eff}} = [0.48520, 0.47430, 0.46370, 0.45690, 0.45690, 0.38079, 0.50880]$\nThis sequence has $T-1 = 7$ values. We search for plateaus with $\\delta=0.02$. The absolute differences between successive values are:\n$|\\Delta V_{\\text{eff}}| = [0.01090, 0.01060, 0.00680, 0.00000, 0.07611, 0.12801]$\nThe first four differences are less than $\\delta = 0.02$. This allows us to identify all possible plateau windows. The longest such window has length $5$ and corresponds to the first five values of $V_{\\text{eff}}$:\n$P_1 = [0.48520, 0.47430, 0.46370, 0.45690, 0.45690]$.\nOther valid plateaus of length at least $L_{\\min}=3$ exist (e.g., $[0.48520, 0.47430, 0.46370]$), but they are shorter. The maximum length found is $5$, which is greater than or equal to $L_{\\min}=3$. Since there is only one plateau of this maximal length, it is selected. The potential $V(4)$ is estimated as the mean of this window:\n$V(4) \\approx \\text{mean}(P_1) = \\frac{0.48520 + 0.47430 + 0.46370 + 0.45690 + 0.45690}{5} = 0.46738$\nRounding to three decimal places gives $0.467$. This procedure is applied to all four cases to obtain the final set of results.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to process all test cases and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: r=2\n        [0.885200, 0.683800, 0.529500, 0.409900, 0.319400, 0.249000, 0.193900, 0.151200],\n        # Case 2: r=3\n        [0.784200, 0.553600, 0.392000, 0.278800, 0.198600, 0.141700, 0.101100, 0.072150],\n        # Case 3: r=1\n        [0.860708, 0.740818, 0.637628, 0.548812, 0.472367],\n        # Case 4: r=4\n        [0.756250, 0.465500, 0.289700, 0.182200, 0.115400, 0.073050, 0.046930, 0.030016]\n    ]\n\n    delta = 0.02\n    L_min = 3\n\n    results = []\n    for w_vals in test_cases:\n        result = estimate_potential(w_vals, delta, L_min)\n        results.append(result)\n\n    # Format the final output string with results rounded to three decimal places.\n    formatted_results = [f\"{r:.3f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef estimate_potential(w_vals, delta, l_min):\n    \"\"\"\n    Estimates the static potential V(r) from Wilson loop data for a single case.\n    \"\"\"\n    w_vals = np.array(w_vals)\n    T = len(w_vals)\n    \n    # Calculate log of Wilson loops and the effective potential\n    log_w = np.log(w_vals)\n    v_eff = -np.diff(log_w)\n    \n    # --- Plateau Detection ---\n    all_plateaus = []\n    for i in range(len(v_eff)):\n        for j in range(i, len(v_eff)):\n            window = v_eff[i:j+1]\n            if len(window) > 1:\n                is_plateau = np.all(np.abs(np.diff(window)) < delta)\n            else:\n                is_plateau = True # A single point is a trivial plateau\n            \n            if is_plateau:\n                all_plateaus.append(window)\n\n    valid_plateaus = [p for p in all_plateaus if len(p) >= l_min]\n\n    if valid_plateaus:\n        # Find the longest valid plateau(s)\n        max_len = max(len(p) for p in valid_plateaus)\n        longest_plateaus = [p for p in valid_plateaus if len(p) == max_len]\n        \n        best_plateau = None\n        if len(longest_plateaus) == 1:\n            best_plateau = longest_plateaus[0]\n        else:\n            # Tie-breaking with minimum sample variance\n            min_var = np.inf\n            for p in longest_plateaus:\n                # Use ddof=1 for sample variance. If len is 1, variance is 0.\n                var = np.var(p, ddof=1) if len(p) > 1 else 0\n                if var < min_var:\n                    min_var = var\n                    best_plateau = p\n        \n        # Estimate potential from the mean of the best plateau\n        return np.mean(best_plateau)\n    else:\n        # --- Fallback: Linear Fit ---\n        # No plateau of length L_min found, perform a fit\n        K = max(l_min + 1, T // 2)\n        \n        # time slices are 1, 2, ..., T\n        t_slices = np.arange(1, T + 1)\n        \n        # Select last K points for the fit\n        t_fit = t_slices[-K:]\n        log_w_fit = log_w[-K:]\n        \n        # Perform linear regression: log_w = m*t + c\n        # The potential V is -m (the negative of the slope)\n        slope, _ = np.polyfit(t_fit, log_w_fit, 1)\n        \n        return -slope\n\n# Execute the solver\nsolve()\n```"
        },
        {
            "introduction": "To study certain physical phenomena more efficiently, simulations are often performed on anisotropic lattices where the temporal lattice spacing $a_t$ differs from the spatial one $a_s$. The ratio $\\xi = a_s / a_t$, known as the anisotropy, must be precisely calibrated. This exercise demonstrates how to \"tune\" a simulation by fitting the measured energy-momentum dispersion relation to its theoretical form, a common and essential practice for ensuring the accuracy of simulation results.",
            "id": "2407396",
            "problem": "Consider a relativistic single-particle excitation measured in a Euclidean lattice simulation of a gauge theory on an anisotropic hypercubic lattice with spatial lattice spacing $a_s$ and temporal lattice spacing $a_t$. Define the anisotropy parameter $\\xi$ by $\\xi = a_s / a_t$. In natural units where $c = \\hbar = 1$, the continuum dispersion relation is $E_{\\text{phys}}^2 = m_{\\text{phys}}^2 + \\mathbf{p}_{\\text{phys}}^2$. Expressed in lattice units where energies and masses are multiplied by $a_t$ and momenta are multiplied by $a_s$, the long-wavelength dispersion relation becomes\n$$\nE^2 = m^2 + \\frac{1}{\\xi^2}\\,p^2,\n$$\nwhere $E$ and $m$ are in temporal lattice units ($a_t$ units) and $p = \\lVert \\mathbf{p} \\rVert$ is the magnitude of the momentum in spatial lattice units ($a_s$ units). For a set of measurements $\\{(p_i, E_i)\\}_{i=1}^N$ and a known $m$, define the measured anisotropy $\\widehat{\\xi}$ to be the nonnegative real number that minimizes the sum of squared deviations from the dispersion relation in these units:\n$$\n\\widehat{\\xi} = \\operatorname*{arg\\,min}_{\\xi \\ge 0} \\sum_{i=1}^N \\left(E_i^2 - m^2 - \\frac{1}{\\xi^2} p_i^2\\right)^2.\n$$\nYour task is to write a complete program that, for each of the following independent test cases, computes $\\widehat{\\xi}$ from the given $(p_i, E_i)$ data and the given $m$, and reports all results in the required final output format.\n\nAll energies $E_i$ and masses $m$ are given in temporal lattice units ($a_t$ units), and all momenta $p_i$ are given in spatial lattice units ($a_s$ units). No other physical units are involved.\n\nTest Suite (each case specifies $m$, the list $\\{p_i\\}$, and the corresponding list $\\{E_i\\}$):\n\n- Case $1$:\n  - $m = 0.5$\n  - $\\{p_i\\} = [\\,0.0,\\,0.2,\\,0.4,\\,0.6\\,]$\n  - $\\{E_i\\} = [\\,0.5,\\,0.5099019513592785,\\,0.5385164807134505,\\,0.58309518948453\\,]$\n\n- Case $2$:\n  - $m = 0.3$\n  - $\\{p_i\\} = [\\,0.0,\\,0.3,\\,0.6,\\,0.9\\,]$\n  - $\\{E_i\\} = [\\,0.3,\\,0.4242640687119285,\\,0.6708203932499369,\\,0.9486832980505138\\,]$\n\n- Case $3$:\n  - $m = 0.0$\n  - $\\{p_i\\} = [\\,0.0,\\,0.1,\\,0.3,\\,0.7\\,]$\n  - $\\{E_i\\} = [\\,0.0,\\,0.06666666666666667,\\,0.2,\\,0.4666666666666667\\,]$\n\nFinal Output Format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the same order as the cases above, with each $\\widehat{\\xi}$ rounded to exactly $6$ decimal places (for example, $[2.000000,1.000000,1.500000]$). No other text should be printed.",
            "solution": "The problem presented is a straightforward exercise in parameter estimation via the method of least squares, situated in the context of lattice gauge theory. We are tasked with determining the lattice anisotropy parameter, denoted $\\widehat{\\xi}$, from a set of simulated energy-momentum data points. The problem is well-defined and requires a standard analytical approach.\n\nThe fundamental relationship provided is the long-wavelength dispersion relation for a particle on an anisotropic lattice:\n$$\nE^2 = m^2 + \\frac{1}{\\xi^2} p^2\n$$\nHere, $E$ is the energy in temporal lattice units ($a_t$ units), $m$ is the mass in the same units, and $p$ is the momentum magnitude in spatial lattice units ($a_s$ units). The parameter $\\xi = a_s/a_t$ quantifies the anisotropy between spatial and temporal lattice spacings.\n\nWe are given a set of $N$ measurements, $\\{(p_i, E_i)\\}_{i=1}^N$, and a known mass $m$. The task is to find the value of $\\xi$, which we denote $\\widehat{\\xi}$, that minimizes the sum of the squared differences between the measured energies and the theoretical model. This is formally expressed as an optimization problem:\n$$\n\\widehat{\\xi} = \\operatorname*{arg\\,min}_{\\xi \\ge 0} S(\\xi) = \\operatorname*{arg\\,min}_{\\xi \\ge 0} \\sum_{i=1}^N \\left(E_i^2 - m^2 - \\frac{1}{\\xi^2} p_i^2\\right)^2\n$$\nTo solve this, we simplify the expression. The term being minimized is quadratic in $1/\\xi^2$. It is therefore prudent to introduce a new parameter, $\\alpha = 1/\\xi^2$. Since the problem statement requires $\\xi \\ge 0$, we must have $\\alpha \\ge 0$. The cost function $S$ can be rewritten as a function of $\\alpha$:\n$$\nS(\\alpha) = \\sum_{i=1}^N \\left( (E_i^2 - m^2) - \\alpha p_i^2 \\right)^2\n$$\nThis is a standard linear least squares problem. To find the value of $\\alpha$ that minimizes $S(\\alpha)$, which we will call $\\widehat{\\alpha}$, we must find the root of its first derivative with respect to $\\alpha$.\n$$\n\\frac{dS}{d\\alpha} = \\sum_{i=1}^N \\frac{d}{d\\alpha} \\left( (E_i^2 - m^2) - \\alpha p_i^2 \\right)^2 = \\sum_{i=1}^N 2 \\left( (E_i^2 - m^2) - \\alpha p_i^2 \\right) (-p_i^2) = 0\n$$\nSimplifying this expression, we have:\n$$\n-2 \\sum_{i=1}^N \\left( p_i^2(E_i^2 - m^2) - \\alpha p_i^4 \\right) = 0\n$$\n$$\n\\sum_{i=1}^N p_i^2(E_i^2 - m^2) = \\widehat{\\alpha} \\sum_{i=1}^N p_i^4\n$$\nSolving for $\\widehat{\\alpha}$ yields:\n$$\n\\widehat{\\alpha} = \\frac{\\sum_{i=1}^N p_i^2 (E_i^2 - m^2)}{\\sum_{i=1}^N p_i^4}\n$$\nThis solution is valid provided the denominator, $\\sum_{i=1}^N p_i^4$, is non-zero. This is guaranteed as long as at least one momentum measurement $p_i$ is non-zero, a condition met by all test cases provided.\n\nTo confirm that this value corresponds to a minimum, we evaluate the second derivative:\n$$\n\\frac{d^2S}{d\\alpha^2} = \\frac{d}{d\\alpha} \\left( -2\\sum_{i=1}^N p_i^2(E_i^2 - m^2) + 2\\alpha\\sum_{i=1}^N p_i^4 \\right) = 2\\sum_{i=1}^N p_i^4\n$$\nSince $p_i$ are real numbers, $p_i^4 \\ge 0$. As at least one $p_i \\neq 0$, the sum $\\sum_{i=1}^N p_i^4$ is strictly positive. A positive second derivative confirms that $\\widehat{\\alpha}$ is indeed a minimum.\n\nFrom the physics of the problem, we expect $E_i \\ge m$, with $E_i > m$ for any non-zero momentum $p_i > 0$. Therefore, the term $E_i^2 - m^2$ is non-negative. This ensures that the numerator of $\\widehat{\\alpha}$, $\\sum_{i=1}^N p_i^2 (E_i^2 - m^2)$, is also non-negative. For the given data, it will be strictly positive, thus yielding $\\widehat{\\alpha} > 0$. This aligns with the constraint $\\alpha \\ge 0$.\n\nHaving found the optimal parameter $\\widehat{\\alpha}$, we can recover the anisotropy $\\widehat{\\xi}$ from the original substitution $\\widehat{\\alpha} = 1/\\widehat{\\xi}^2$:\n$$\n\\widehat{\\xi}^2 = \\frac{1}{\\widehat{\\alpha}} \\implies \\widehat{\\xi} = \\sqrt{\\frac{1}{\\widehat{\\alpha}}} = \\left( \\frac{\\sum_{i=1}^N p_i^4}{\\sum_{i=1}^N p_i^2(E_i^2 - m^2)} \\right)^{1/2}\n$$\nWe take the positive root for $\\widehat{\\xi}$ as per its physical definition as a ratio of positive lattice spacings.\n\nThis analytical formula provides a direct and exact method for computing $\\widehat{\\xi}$ for each test case. The implementation will involve a straightforward application of this formula to the provided data sets.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the measured lattice anisotropy parameter xi for a series of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"m\": 0.5,\n            \"p\": [0.0, 0.2, 0.4, 0.6],\n            \"E\": [0.5, 0.5099019513592785, 0.5385164807134505, 0.58309518948453]\n        },\n        {\n            \"m\": 0.3,\n            \"p\": [0.0, 0.3, 0.6, 0.9],\n            \"E\": [0.3, 0.4242640687119285, 0.6708203932499369, 0.9486832980505138]\n        },\n        {\n            \"m\": 0.0,\n            \"p\": [0.0, 0.1, 0.3, 0.7],\n            \"E\": [0.0, 0.06666666666666667, 0.2, 0.4666666666666667]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        m = case[\"m\"]\n        p = np.array(case[\"p\"])\n        E = np.array(case[\"E\"])\n        \n        # We need to find xi that minimizes Sum( (E_i^2 - m^2 - p_i^2/xi^2)^2 ).\n        # Let alpha = 1/xi^2. The problem becomes a linear least squares fit\n        # for alpha, fitting y_i = alpha * x_i where y_i = E_i^2 - m^2 and x_i = p_i^2.\n        # The analytical solution for alpha is Sum(x_i * y_i) / Sum(x_i^2).\n        \n        p_sq = p**2\n        p_quad = p**4\n        E_sq_minus_m_sq = E**2 - m**2\n        \n        numerator = np.sum(p_sq * E_sq_minus_m_sq)\n        denominator = np.sum(p_quad)\n        \n        # Handle the case where all momenta are zero to avoid division by zero.\n        # Although not the case for the given test problems.\n        if denominator == 0:\n            # If all p_i are 0, xi is undefined. This can be represented\n            # as infinity or NaN depending on context. Here, we assume it valid.\n            # In physics, if all p_i are 0, anisotropy cannot be determined.\n            # We follow the calculation which will lead to a valid result for the given cases.\n            pass\n\n        alpha = numerator / denominator\n        \n        # Since xi = 1/sqrt(alpha)\n        xi_hat = np.sqrt(1 / alpha)\n        \n        results.append(f\"{xi_hat:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}