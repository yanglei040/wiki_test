{
    "hands_on_practices": [
        {
            "introduction": "This first practice is your entry into building a complete level set solver. You will implement the core components for evolving an interface under a constant normal velocity, which is the simplest form of motion. By using a complex Lissajous curve as the initial shape, this exercise immediately highlights the power of the level set method to handle intricate geometries and topological changes—such as the merging of separate regions—without any special case handling. ",
            "id": "2408424",
            "problem": "You are asked to implement a complete numerical solver for the motion of a planar interface represented by a level set under a constant inward normal velocity. The interface is initially given by a Lissajous curve and evolves via a Hamilton–Jacobi equation. Your implementation must be a single, self-contained program that constructs the initial level set, evolves it in time using a stable monotone scheme, periodically reinitializes the level set to a signed distance function, and reports simple topological metrics at specified times.\n\nStart from the following foundational base:\n- The level set method represents a moving interface as the zero contour of a scalar field $\\phi(x,y,t)$, with the interface defined by $\\{\\,(x,y): \\phi(x,y,t) = 0\\,\\}$ and the interior by $\\{\\,(x,y): \\phi(x,y,t) < 0\\,\\}$.\n- For motion by a constant normal speed $F$, the level set function satisfies the Hamilton–Jacobi equation $\\phi_t + F \\lvert \\nabla \\phi \\rvert = 0$.\n- The signed distance function $d(x,y)$ to a curve satisfies $\\lvert \\nabla d \\rvert = 1$ where it is smooth.\n- The Sussman reinitialization equation $\\phi_\\tau + \\operatorname{sgn}(\\phi_0) \\left(\\lvert \\nabla \\phi \\rvert - 1\\right) = 0$ converges to a signed distance function with the same zero level set as $\\phi_0$.\n\nInterface and initialization:\n- The initial interface $\\Gamma_0$ is the Lissajous curve parameterized by $x(t) = \\sin(p\\,t + \\delta)$, $y(t) = \\sin(q\\,t)$ for $t \\in [0,2\\pi]$, where $p$ and $q$ are positive integers and $\\delta$ is a phase in radians. Sample the curve densely into a polyline to approximate its geometry.\n- Construct $\\phi(x,y,0)$ as a signed distance to $\\Gamma_0$ with negative sign in the interior. Because Lissajous curves can self-intersect, define the interior by the even–odd rule: a point is inside if a ray to $+\\infty$ in $x$ crosses the polyline an odd number of times. Use this parity to assign the sign of the signed distance.\n- Use radians for all trigonometric evaluations and angles.\n\nEvolution:\n- Evolve $\\phi$ on a uniform Cartesian grid with $N \\times N$ points on a square domain $[x_{\\min},x_{\\max}] \\times [y_{\\min},y_{\\max}]$ using an explicit forward Euler time discretization for the Hamilton–Jacobi equation and a first-order monotone Godunov upwind scheme for the gradient magnitude, consistent with the sign of $F$.\n- Impose homogeneous Neumann boundary conditions (zero normal derivative) by extrapolating boundary values.\n- Use a Courant–Friedrichs–Lewy (CFL) limited time step $\\Delta t = \\text{CFL} \\cdot \\min(\\Delta x, \\Delta y) / \\lvert F \\rvert$ with $\\text{CFL} \\in (0,1]$.\n- Periodically reinitialize $\\phi$ by integrating the Sussman reinitialization equation in a pseudo-time $\\tau$ for a fixed number of iterations using a stable Godunov discretization of $\\lvert \\nabla \\phi \\rvert$, with a pseudo-time step $\\Delta \\tau$ satisfying $\\Delta \\tau \\le c \\min(\\Delta x,\\Delta y)$ for some constant $c \\in (0,1)$.\n\nTopological metrics:\n- At specified physical times $t$, compute:\n  1. The number of connected components of the interior set $\\{\\phi < 0\\}$ using $8$-connectivity on the grid.\n  2. The area of the interior set $\\{\\phi < 0\\}$ approximated by counting grid points where $\\phi < 0$ times the cell area $\\Delta x \\Delta y$.\n\nAll quantities are nondimensional; there are no physical units. All angles must be in radians. All requested outputs are dimensionless numbers.\n\nTest suite and parameters:\n- Use a square computational domain $[x_{\\min},x_{\\max}] \\times [y_{\\min},y_{\\max}] = [-1.2, 1.2] \\times [-1.2, 1.2]$ with $N = 201$ points in each direction, so that $\\Delta x = \\Delta y = (x_{\\max}-x_{\\min})/(N-1)$. Use $\\text{CFL} = 0.5$ and homogeneous Neumann boundaries.\n- Use a constant inward normal speed $F = -1$.\n- For initialization, sample the Lissajous curve with $M = 8000$ points uniformly in $t \\in [0, 2\\pi]$ to form the polyline.\n- Reinitialize every $K = 10$ physical time steps, performing $J = 20$ pseudo-time iterations with $\\Delta \\tau = 0.3 \\min(\\Delta x,\\Delta y)$.\n\nDefine the following test cases; in each case, report the number of connected components at three times and the final area at the largest time. Angles are in radians:\n- Case A: $p = 3$, $q = 2$, $\\delta = 0$. Report at times $t \\in \\{0.0, 0.25, 0.5\\}$.\n- Case B: $p = 5$, $q = 4$, $\\delta = 0$. Report at times $t \\in \\{0.0, 0.2, 0.4\\}$.\n- Case C: $p = 2$, $q = 1$, $\\delta = 0$. Report at times $t \\in \\{0.0, 0.15, 0.3\\}$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case result must itself be a list of four values: three integers for the connected component counts at the specified times (in the order listed), followed by one floating-point number for the final area at the largest time, rounded to six digits after the decimal point.\n- Concretely, the program must output a single line in the form $[\\,[n_{A,1},n_{A,2},n_{A,3},A_{A}],\\,[n_{B,1},n_{B,2},n_{B,3},A_{B}],\\,[n_{C,1},n_{C,2},n_{C,3},A_{C}]\\,]$ with no extra whitespace. Here $n_{A,i}$ are integers and $A_{A}$ is a decimal with six digits after the decimal point, and similarly for the other cases.",
            "solution": "The problem presented is a well-defined computational physics task concerning the evolution of a planar interface using the level set method. It is scientifically sound, internally consistent, and provides all necessary parameters for a numerical solution. The problem is therefore deemed valid.\n\nThe solution involves simulating the Hamilton-Jacobi equation that governs the motion of the level set function $\\phi(x,y,t)$. The interface is the zero-contour of $\\phi$, $\\{\\,(x,y) : \\phi(x,y,t) = 0\\,\\}$, which moves with a constant inward normal velocity.\n\n**1. Governing Equations**\n\nThe evolution of the level set function $\\phi$ for an interface moving with normal velocity $F$ is described by the Hamilton-Jacobi equation:\n$$ \\phi_t + F |\\nabla \\phi| = 0 $$\nFor this problem, the velocity is a constant inward speed, so $F = -1$.\n\nTo prevent the level set function from becoming too steep or too flat during evolution, which would degrade numerical accuracy, $\\phi$ is periodically reinitialized to be a signed distance function. A signed distance function $d$ satisfies $|\\nabla d| = 1$. This is achieved by solving the Sussman reinitialization equation to a steady state in a pseudo-time $\\tau$:\n$$ \\phi_\\tau + \\operatorname{sgn}(\\phi_0) (|\\nabla \\phi| - 1) = 0 $$\nHere, $\\phi_0$ is the level set function before reinitialization, and $\\operatorname{sgn}(\\phi_0)$ is a sign function that is fixed during the pseudo-time evolution.\n\n**2. Numerical Implementation**\n\nThe simulation is performed on a uniform Cartesian grid.\n\n**2.1. Initialization**\nThe initial level set function $\\phi(x,y,0)$ must represent the signed distance to the initial interface, a Lissajous curve $\\Gamma_0$.\nThe process is as follows:\n- **Curve Discretization**: The Lissajous curve, given by the parameterization $x(t_{param}) = \\sin(p\\,t_{param} + \\delta)$ and $y(t_{param}) = \\sin(q\\,t_{param})$, is densely sampled with $M=8000$ points to form a polyline that accurately approximates its geometry.\n- **Distance Calculation**: The absolute distance from each grid point to the interface is approximated by computing the minimum Euclidean distance to the set of sampled curve points. This is computationally efficient using matrix-based distance calculations.\n- **Sign Determination**: The sign of $\\phi$ distinguishes the interior ($\\phi < 0$) from the exterior ($\\phi > 0$). The sign is determined using the even-odd rule (a ray-casting algorithm). For each grid point, a ray is cast in the positive $x$-direction. If the ray intersects the polyline an odd number of times, the point is inside; otherwise, it is outside. This method correctly handles complex, self-intersecting geometries. The final initial function is the product of the sign and the distance: $\\phi(x,y,0) = \\text{sign}(x,y) \\times \\text{distance}(x,y)$.\n\n**2.2. Time Evolution**\nThe evolution equation is discretized using the method of lines.\n- **Temporal Discretization**: A simple and explicit Forward Euler scheme is used for the time derivative:\n$$ \\frac{\\phi^{n+1}_{i,j} - \\phi^n_{i,j}}{\\Delta t} = -F |\\nabla \\phi|^n_{i,j} $$\n- **Spatial Discretization**: The non-linear term $|\\nabla \\phi|$ is treated using a first-order Godunov upwind scheme, which is a stable, monotone scheme suitable for hyperbolic conservation laws. The specific form of the numerical Hamiltonian depends on the sign of the velocity $F$. For $F = -1 < 0$, information propagates from the exterior to the interior. The scheme is:\n$$ |\\nabla \\phi|_{i,j} \\approx \\sqrt{ \\left(\\max(D_x^+ \\phi_{i,j}, 0)\\right)^2 + \\left(\\min(D_x^- \\phi_{i,j}, 0)\\right)^2 + \\left(\\max(D_y^+ \\phi_{i,j}, 0)\\right)^2 + \\left(\\min(D_y^- \\phi_{i,j}, 0)\\right)^2 } $$\nwhere $D^\\pm$ are the forward and backward finite difference operators. This scheme selects the appropriate upwind direction at each grid point based on the local flow of information.\n- **Stability**: The explicit time integration is subject to a Courant-Friedrichs-Lewy (CFL) condition for stability. The time step $\\Delta t$ is chosen as $\\Delta t = \\text{CFL} \\cdot \\min(\\Delta x, \\Delta y) / |F|$, with $\\text{CFL} = 0.5$.\n- **Boundary Conditions**: Homogeneous Neumann boundary conditions ($\\partial \\phi / \\partial n = 0$) are imposed by padding the grid with ghost cells whose values are copies of the boundary cells. This ensures that finite differences at the boundary are computed correctly, simulating a zero-flux condition.\n\n**2.3. Reinitialization**\nEvery $K = 10$ physical time steps, the function $\\phi$ is reinitialized for $J = 20$ pseudo-time steps. The reinitialization equation $\\phi_\\tau + S(\\phi_0)(|\\nabla\\phi|-1) = 0$ is solved, where $S(\\phi_0) = \\operatorname{sgn}(\\phi_{\\text{before reinit}})$.\nThe numerical scheme for this step is similar to the evolution step: Forward Euler in pseudo-time $\\tau$ with a Godunov-type upwind scheme for $|\\nabla \\phi|$. The upwinding direction depends on the sign of $S(\\phi_0)$:\n- Where $S(\\phi_0) > 0$ (outside the interface, information propagates away from the interface):\n$$ |\\nabla \\phi|_{i,j} \\approx \\sqrt{ (\\max(D_x^-\\phi, 0))^2 + (\\min(D_x^+\\phi, 0))^2 + (\\max(D_y^-\\phi, 0))^2 + (\\min(D_y^+\\phi, 0))^2 } $$\n- Where $S(\\phi_0)  0$ (inside the interface, information also propagates away from the interface):\n$$ |\\nabla \\phi|_{i,j} \\approx \\sqrt{ (\\max(D_x^+\\phi, 0))^2 + (\\min(D_x^-\\phi, 0))^2 + (\\max(D_y^+\\phi, 0))^2 + (\\min(D_y^-\\phi, 0))^2 } $$\nThe update step is $\\phi^{\\nu+1} = \\phi^\\nu - \\Delta \\tau \\left( S(\\phi_0)(|\\nabla \\phi|_\\text{num} - 1) \\right)$, with a pseudo-timestep $\\Delta \\tau = 0.3 \\min(\\Delta x, \\Delta y)$.\n\n**3. Metric Calculation**\nAt specified times, two metrics are computed from the discrete level set field $\\phi_{i,j}$:\n- **Number of Connected Components**: The interior region $\\{\\phi  0\\}$ is identified on the grid. The number of distinct connected components within this region is computed using a standard labeling algorithm based on $8$-connectivity, as provided by `scipy.ndimage.label`.\n- **Area of Interior**: The area is approximated by summing the areas of all grid cells identified as being in the interior: $A = (\\text{count of } \\{i,j\\} \\text{ s.t. } \\phi_{i,j}0) \\times (\\Delta x \\Delta y)$.",
            "answer": "```python\nimport numpy as np\nfrom scipy.ndimage import label\nfrom scipy.spatial.distance import cdist\nimport math\n\nclass LevelSetSolver:\n    \"\"\"\n    Solves the level set equation for interface motion under constant normal velocity.\n    \"\"\"\n    def __init__(self, p, q, delta, domain_params, sim_params):\n        self.p, self.q, self.delta = p, q, delta\n        \n        self.xmin, self.xmax = domain_params['x_range']\n        self.ymin, self.ymax = domain_params['y_range']\n        self.N = domain_params['N']\n        \n        self.F = sim_params['F']\n        self.CFL = sim_params['CFL']\n        self.M = sim_params['M_samples']\n        self.reinit_K = sim_params['reinit_K']\n        self.reinit_J = sim_params['reinit_J']\n        self.dtau_coeff = sim_params['dtau_coeff']\n        \n        self.dx = (self.xmax - self.xmin) / (self.N - 1)\n        self.dy = (self.ymax - self.ymin) / (self.N - 1)\n        \n        self.dt = self.CFL * min(self.dx, self.dy) / abs(self.F)\n        self.dtau = self.dtau_coeff * min(self.dx, self.dy)\n        \n        x = np.linspace(self.xmin, self.xmax, self.N)\n        y = np.linspace(self.ymin, self.ymax, self.N)\n        self.X, self.Y = np.meshgrid(x, y)\n        \n        self.phi = self._initialize_phi()\n\n    def _initialize_phi(self):\n        # 1. Sample Lissajous curve\n        t_param = np.linspace(0, 2 * np.pi, self.M, endpoint=False)\n        x_c = np.sin(self.p * t_param + self.delta)\n        y_c = np.sin(self.q * t_param)\n        curve_pts = np.stack([x_c, y_c], axis=1)\n\n        # 2. Calculate distance field\n        grid_pts = np.stack([self.X.ravel(), self.Y.ravel()], axis=1)\n        dists = cdist(grid_pts, curve_pts)\n        phi_abs = np.min(dists, axis=1).reshape(self.N, self.N)\n\n        # 3. Determine sign using even-odd rule (ray casting)\n        signs = np.ones((self.N, self.N))\n        p1x, p1y = x_c, y_c\n        p2x, p2y = np.roll(x_c, -1), np.roll(y_c, -1)\n        \n        for i in range(self.N):\n            for j in range(self.N):\n                px, py = self.X[i, j], self.Y[i, j]\n                # Vectorized check for crossings against all segments\n                cond1 = (p1y = py)  (p2y  py)\n                cond2 = (p2y = py)  (p1y  py)\n                # Avoid division by zero for horizontal segments.\n                # Such segments are correctly ignored by the y-range check.\n                with np.errstate(divide='ignore', invalid='ignore'):\n                    x_intersect = (p2x - p1x) * (py - p1y) / (p2y - p1y) + p1x\n                \n                crossings = np.sum((cond1 | cond2)  (px  x_intersect))\n                if crossings % 2 == 1:\n                    signs[i, j] = -1.0\n                    \n        return phi_abs * signs\n\n    def _apply_bc(self, phi_grid):\n        \"\"\"Apply homogeneous Neumann boundary conditions.\"\"\"\n        padded_phi = np.pad(phi_grid, 1, mode='edge')\n        return padded_phi\n\n    def _get_derivatives(self, phi_grid):\n        \"\"\"Compute one-sided derivatives on a padded grid.\"\"\"\n        dphimx = (phi_grid[1:-1, 1:-1] - phi_grid[1:-1, 0:-2]) / self.dx\n        dphipx = (phi_grid[1:-1, 2:] - phi_grid[1:-1, 1:-1]) / self.dx\n        dphimy = (phi_grid[1:-1, 1:-1] - phi_grid[0:-2, 1:-1]) / self.dy\n        dphipy = (phi_grid[2:, 1:-1] - phi_grid[1:-1, 1:-1]) / self.dy\n        return dphimx, dphipx, dphimy, dphipy\n\n    def evolve(self):\n        \"\"\"Evolve phi by one time step dt.\"\"\"\n        padded_phi = self._apply_bc(self.phi)\n        dphimx, dphipx, dphimy, dphipy = self._get_derivatives(padded_phi)\n        \n        # Godunov scheme for F  0\n        grad_mag_sq = (np.maximum(dphipx, 0)**2 + np.minimum(dphimx, 0)**2 +\n                       np.maximum(dphipy, 0)**2 + np.minimum(dphimy, 0)**2)\n        grad_mag = np.sqrt(grad_mag_sq)\n        \n        dphi_dt = -self.F * grad_mag\n        self.phi += self.dt * dphi_dt\n    \n    def reinitialize(self):\n        \"\"\"Reinitialize phi to a signed distance function.\"\"\"\n        S0 = np.sign(self.phi)\n        \n        for _ in range(self.reinit_J):\n            padded_phi = self._apply_bc(self.phi)\n            dphimx, dphipx, dphimy, dphipy = self._get_derivatives(padded_phi)\n            \n            # Upwind scheme based on sign of S0\n            # grad_mag_pos_sq for S0 > 0 (outside interface)\n            grad_mag_pos_sq = (np.maximum(dphimx, 0)**2 + np.minimum(dphipx, 0)**2 +\n                               np.maximum(dphimy, 0)**2 + np.minimum(dphipy, 0)**2)\n\n            # grad_mag_neg_sq for S0  0 (inside interface)\n            grad_mag_neg_sq = (np.maximum(dphipx, 0)**2 + np.minimum(dphimx, 0)**2 +\n                               np.maximum(dphipy, 0)**2 + np.minimum(dphimy, 0)**2)\n            \n            grad_mag_num = np.zeros_like(self.phi)\n            mask_pos = S0  0\n            mask_neg = S0  0\n            \n            grad_mag_num[mask_pos] = np.sqrt(grad_mag_pos_sq[mask_pos])\n            grad_mag_num[mask_neg] = np.sqrt(grad_mag_neg_sq[mask_neg])\n\n            # Update rule is for phi_tau + S0(|nabla phi| - 1) = 0\n            self.phi -= self.dtau * S0 * (grad_mag_num - 1)\n\n    def get_metrics(self):\n        \"\"\"Compute area and number of connected components.\"\"\"\n        interior = self.phi  0\n        \n        # Area\n        area = np.sum(interior) * self.dx * self.dy\n        \n        # Connected components (8-connectivity by default)\n        structure = np.ones((3, 3))\n        _, num_components = label(interior, structure=structure)\n        \n        return num_components, area\n\ndef solve():\n    domain_params = {\n        'x_range': [-1.2, 1.2],\n        'y_range': [-1.2, 1.2],\n        'N': 201,\n    }\n    sim_params = {\n        'F': -1.0,\n        'CFL': 0.5,\n        'M_samples': 8000,\n        'reinit_K': 10,\n        'reinit_J': 20,\n        'dtau_coeff': 0.3,\n    }\n    \n    test_cases = [\n        {'p': 3, 'q': 2, 'delta': 0.0, 'times': [0.0, 0.25, 0.5]},\n        {'p': 5, 'q': 4, 'delta': 0.0, 'times': [0.0, 0.2, 0.4]},\n        {'p': 2, 'q': 1, 'delta': 0.0, 'times': [0.0, 0.15, 0.3]},\n    ]\n    \n    all_results = []\n\n    for case in test_cases:\n        solver = LevelSetSolver(case['p'], case['q'], case['delta'], domain_params, sim_params)\n        \n        report_times = sorted(case['times'])\n        case_results = []\n        \n        t = 0.0\n        step = 0\n        \n        final_time = report_times[-1]\n\n        # Handle t=0\n        if 0.0 in report_times:\n            num_comp, _ = solver.get_metrics()\n            case_results.append(num_comp)\n            report_times.pop(0)\n\n        while t  final_time:\n            if step  0 and step % solver.reinit_K == 0:\n                solver.reinitialize()\n            \n            solver.evolve()\n            t += solver.dt\n            step += 1\n            \n            if report_times and t = report_times[0]:\n                num_comp, _ = solver.get_metrics()\n                case_results.append(num_comp)\n                report_times.pop(0)\n\n        # Final area\n        _, final_area = solver.get_metrics()\n        case_results.append(f\"{final_area:.6f}\")\n        \n        # Convert numeric results to required types\n        final_case_results = [int(v) for v in case_results[:-1]] + [float(case_results[-1])]\n        all_results.append(final_case_results)\n\n    # Format output as specified\n    result_str = \",\".join([str(res).replace(\" \", \"\") for res in all_results])\n    print(f\"[{result_str}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "Building upon the constant-velocity solver, this exercise introduces a spatially dependent speed function, $F(x,y)$. This represents a critical step towards modeling more realistic physical systems where external fields or local conditions cause the interface to move at different speeds at different locations. You will simulate the 'pinching' and splitting of an elliptical shape, a process analogous to cell division and a classic demonstration of the level set method's ability to manage topological separation. ",
            "id": "2408442",
            "problem": "You are asked to implement a Level Set Method (LSM) simulation to model the splitting of a closed interface that initially coincides with an ellipse. The evolution is governed by a spatially dependent normal speed. You must derive a stable, monotone, first-order upwind (Godunov-type) discretization of the Hamilton–Jacobi Partial Differential Equation (PDE) and implement it in code. The objective is to test whether the evolving interface undergoes topological change (splitting), quantified as the number of connected components of the interior phase at the end of the simulation. All quantities here are dimensionless; no physical units are required.\n\nThe evolution of the level set function is given by the PDE\n$$\n\\phi_t + F(x,y)\\lvert \\nabla \\phi \\rvert = 0,\n$$\nwhere $\\phi(x,y,t)$ is a scalar field such that the evolving interface is the zero isocontour $\\{\\phi = 0\\}$ and the interior is $\\{\\phi \\le 0\\}$. The speed field is spatially dependent and is prescribed as\n$$\nF(x,y) = \\beta - \\alpha \\exp\\!\\left(-\\frac{y^2}{s^2}\\right).\n$$\nHere, $\\alpha$, $\\beta$, and $s$ are strictly positive parameters. The domain is the square $[-1,1] \\times [-1,1]$ discretized on a uniform Cartesian grid.\n\nInitial condition:\n- The initial interface is an ellipse given implicitly by\n$$\n\\frac{x^2}{a^2} + \\frac{y^2}{b^2} = 1,\n$$\nand the initial level set field $\\phi(x,y,0)$ must be constructed so that $\\phi \\le 0$ inside the ellipse and $\\phi  0$ outside. For numerical stability, you must reinitialize $\\phi$ to a signed distance function at $t=0$ and periodically during the simulation. Reinitialization can be done by any consistent method that produces a field approximating the signed distance to the zero level set; a common approach uses the Euclidean Distance Transform (EDT) computed on the binary interior mask $\\{\\phi \\le 0\\}$.\n\nDiscretization and stability requirements:\n- Derive and implement a first-order monotone upwind (Godunov) approximation of $\\lvert \\nabla \\phi \\rvert$ that is consistent with the sign of $F(x,y)$, using one-sided finite differences on a uniform grid with spacings $\\Delta x$ and $\\Delta y$.\n- Use an explicit forward Euler time integrator with a time step $\\Delta t$ satisfying a Courant–Friedrichs–Lewy (CFL) stability constraint derived from the characteristic speed of the Hamilton–Jacobi PDE. You must choose\n$$\n\\Delta t = \\mathrm{CFL} \\times \\frac{\\min(\\Delta x, \\Delta y)}{\\max\\limits_{x,y}\\lvert F(x,y)\\rvert},\n$$\nwith a constant $\\mathrm{CFL}$ such that $0  \\mathrm{CFL} \\le 1$.\n- Apply homogeneous Neumann boundary conditions (zero normal derivative) numerically by using appropriate one-sided differences or value replication at the boundary.\n\nTopological query:\n- At the end of each simulation, compute the number of connected components of the interior set $\\{\\phi \\le 0\\}$ using $4$-connectivity on the grid.\n\nYour program must implement the following and produce the required outputs for the specified test suite. No user input is allowed; all parameters are embedded in the code.\n\nImplementation requirements:\n- Construct the uniform grid on $[-1,1] \\times [-1,1]$ with $N \\times N$ nodes, $N \\ge 5$, with grid spacings $\\Delta x = \\Delta y = \\frac{2}{N-1}$.\n- Initialize $\\phi(x,y,0)$ from the ellipse with semi-axes $a$ and $b$ so that $\\phi \\le 0$ inside. Then, reinitialize to a signed-distance field at $t=0$.\n- Evolve $\\phi$ using the PDE $\\phi_t + F(x,y)\\lvert \\nabla \\phi \\rvert = 0$, a monotone upwind Godunov discretization of $\\lvert \\nabla \\phi \\rvert$, and forward Euler time integration with stable $\\Delta t$ determined from the CFL condition.\n- Reinitialize $\\phi$ periodically during time stepping to maintain $\\lvert \\nabla \\phi \\rvert \\approx 1$ near the interface.\n- After the final time step, compute the number of connected components of $\\{\\phi \\le 0\\}$ with $4$-connectivity.\n\nTest suite:\nRun the simulation for each of the following parameter sets; report the number of connected interior components at the final time for each case.\n\n- Case A (intended to split into two): $N = 101$, $a = 0.7$, $b = 0.3$, $\\alpha = 1.1$, $\\beta = 0.25$, $s = 0.2$, $\\mathrm{CFL} = 0.5$, number of Euler steps $= 220$, reinitialization every $\\;5\\;$ steps.\n- Case B (intended to remain one component): $N = 101$, $a = 0.7$, $b = 0.3$, $\\alpha = 0.1$, $\\beta = 0.25$, $s = 0.2$, $\\mathrm{CFL} = 0.5$, number of Euler steps $= 220$, reinitialization every $\\;5\\;$ steps.\n- Case C (borderline, insufficient time to split): $N = 101$, $a = 0.7$, $b = 0.3$, $\\alpha = 0.35$, $\\beta = 0.25$, $s = 0.2$, $\\mathrm{CFL} = 0.5$, number of Euler steps $= 100$, reinitialization every $\\;5\\;$ steps.\n- Case D (strong splitting): $N = 101$, $a = 0.7$, $b = 0.3$, $\\alpha = 1.3$, $\\beta = 0.20$, $s = 0.2$, $\\mathrm{CFL} = 0.5$, number of Euler steps $= 260$, reinitialization every $\\;5\\;$ steps.\n\nFinal output specification:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the same order as the test cases above. Each entry is an integer equal to the number of connected interior components. For example, a valid output would be of the form\n$\n[\\;n_A, n_B, n_C, n_D\\;]\n$\nwhere $n_A$, $n_B$, $n_C$, and $n_D$ are integers.\n\nConstraints and notes:\n- You must not use any external data or user input.\n- All variables, functions, operators, and numbers appearing as mathematics in this specification are written in LaTeX.\n- The algorithm must be derived from core definitions of the Level Set Method, Hamilton–Jacobi equations, monotone upwind discretization, and the Courant–Friedrichs–Lewy condition.",
            "solution": "The problem presented is a well-posed initial boundary value problem in computational physics, requiring the simulation of a moving interface using the Level Set Method. The problem is scientifically grounded, formally specified, and objective. It contains all necessary information to proceed with a numerical solution. Therefore, the problem is deemed valid.\n\nThe task is to solve the Level Set equation, which is a type of Hamilton-Jacobi Partial Differential Equation (PDE):\n$$\n\\phi_t + F(x,y)\\lvert \\nabla \\phi \\rvert = 0\n$$\nThe function $\\phi(x,y,t)$ is the level set function, whose zero isocontour $\\phi=0$ represents the moving interface. The region where $\\phi \\le 0$ is defined as the \"interior\" of the closed interface. The function $F(x,y)$ is the speed of the interface in the direction of its outward normal.\n\nThe solution involves discretizing this PDE in space and time and evolving an initial condition.\n\n1.  **Domain and Grid Discretization**\n    The computational domain is a square $[-1,1] \\times [-1,1]$. We introduce a uniform Cartesian grid with $N \\times N$ nodes. The coordinates of the grid nodes $(x_i, y_j)$ are given by:\n    $$\n    x_i = -1 + i \\Delta x, \\quad i = 0, \\ldots, N-1\n    $$\n    $$\n    y_j = -1 + j \\Delta y, \\quad j = 0, \\ldots, N-1\n    $$\n    where the grid spacings are $\\Delta x = \\Delta y = \\frac{2}{N-1}$. The level set function is represented by its values $\\phi_{i,j}(t) \\approx \\phi(x_i, y_j, t)$ on this grid.\n\n2.  **Initial Condition and Reinitialization**\n    The initial interface is an ellipse defined by $\\frac{x^2}{a^2} + \\frac{y^2}{b^2} = 1$. A simple choice for the initial level set function is $\\phi(x,y,0) = \\frac{x^2}{a^2} + \\frac{y^2}{b^2} - 1$.\n    For numerical stability and accuracy, the level set function should ideally be a signed distance function (SDF), meaning it satisfies $|\\nabla\\phi| = 1$. The initial function is not an SDF. Therefore, we must reinitialize it at $t=0$ and periodically thereafter.\n    Reinitialization is performed as follows:\n    - Create a binary mask distinguishing the interior ($\\phi \\le 0$) from the exterior ($\\phi  0$).\n    - Compute the Euclidean distance from every grid point to the nearest point of the opposite region. This is done using a fast Euclidean Distance Transform (EDT) algorithm.\n    - The new $\\phi$ is constructed by assigning negative distances to interior points and positive distances to exterior points. Specifically, $\\phi_{\\text{new}} = \\text{dist}_{\\text{out}} - \\text{dist}_{\\text{in}}$, where $\\text{dist}_{\\text{in}}$ is the distance to the exterior for points in the interior, and $\\text{dist}_{\\text{out}}$ is the distance to the interior for points in the exterior.\n\n3.  **Spatial Discretization: First-Order Godunov Scheme**\n    The PDE is a Hamilton-Jacobi equation of the form $\\phi_t + H(\\nabla \\phi) = 0$, with Hamiltonian $H(\\nabla \\phi) = F(x,y)|\\nabla \\phi|$. Such equations can develop shocks or corners in the solution, requiring a numerical scheme that correctly handles the direction of information propagation (upwinding). A Godunov-type scheme achieves this by using a numerical Hamiltonian that is monotone.\n    For the Hamiltonian $H(p,q) = F\\sqrt{p^2+q^2}$, where $p=\\phi_x$ and $q=\\phi_y$, the Godunov numerical Hamiltonian $H_{num}$ for a grid function $\\phi_{i,j}$ takes the form:\n    $$\n    H_{num} = F_{i,j}^+ \\sqrt{D_x^{\\text{upw},+}{}^2 + D_y^{\\text{upw},+}{}^2} + F_{i,j}^- \\sqrt{D_x^{\\text{upw},-}{}^2 + D_y^{\\text{upw},-}{}^2}\n    $$\n    where $F_{i,j}^+ = \\max(F_{i,j}, 0)$ and $F_{i,j}^- = \\min(F_{i,j}, 0)$. The terms $D$ represent squared norms of upwind gradients.\n    - If $F > 0$ (expansion), information propagates from the interior ($\\phi0$) to the exterior ($\\phi0$). The scheme must look \"upwind\" into the interior.\n    - If $F  0$ (contraction), information propagates from the exterior to the interior. The scheme must look \"upwind\" into the exterior.\n\n    Let $\\phi_x^- = (\\phi_{i,j} - \\phi_{i-1,j})/\\Delta x$ be the backward difference and $\\phi_x^+ = (\\phi_{i+1,j} - \\phi_{i,j})/\\Delta x$ be the forward difference, and similarly for $y$. The Godunov scheme is expressed as:\n    $$\n    H_{num}(\\phi_{i,j}) = \\max(F_{i,j}, 0) \\sqrt{A} + \\min(F_{i,j}, 0) \\sqrt{B}\n    $$\n    with\n    $$\n    A = [\\max(\\phi_x^-, 0)]^2 + [\\min(\\phi_x^+, 0)]^2 + [\\max(\\phi_y^-, 0)]^2 + [\\min(\\phi_y^+, 0)]^2\n    $$\n    $$\n    B = [\\max(\\phi_x^+, 0)]^2 + [\\min(\\phi_x^-, 0)]^2 + [\\max(\\phi_y^+, 0)]^2 + [\\min(\\phi_y^-, 0)]^2\n    $$\n    This formulation correctly selects the difference directions based on the sign of the local derivatives and the sign of the speed field $F$.\n\n4.  **Time Discretization and Stability**\n    We use an explicit forward Euler scheme to update the solution in time:\n    $$\n    \\frac{\\phi_{i,j}^{n+1} - \\phi_{i,j}^n}{\\Delta t} + H_{num}(\\phi_{i,j}^n) = 0 \\implies \\phi_{i,j}^{n+1} = \\phi_{i,j}^n - \\Delta t \\cdot H_{num}(\\phi_{i,j}^n)\n    $$\n    This scheme is stable only if the time step $\\Delta t$ satisfies the Courant-Friedrichs-Lewy (CFL) condition. For this Hamilton-Jacobi equation, the characteristic speed is $\\max_{x,y}|F(x,y)|$. The CFL condition is:\n    $$\n    \\Delta t \\le \\frac{\\min(\\Delta x, \\Delta y)}{\\max\\limits_{x,y}\\lvert F(x,y)\\rvert}\n    $$\n    The problem specifies using a CFL number, $0  \\mathrm{CFL} \\le 1$, such that:\n    $$\n    \\Delta t = \\mathrm{CFL} \\times \\frac{\\min(\\Delta x, \\Delta y)}{\\max\\limits_{x,y}\\lvert F(x,y)\\rvert}\n    $$\n\n5.  **Boundary Conditions**\n    Homogeneous Neumann boundary conditions, $\\frac{\\partial \\phi}{\\partial n} = 0$, are applied, where $n$ is the outward normal to the domain boundary. For a first-order scheme, this can be implemented by setting the value in a \"ghost cell\" outside the domain equal to the value at the boundary cell adjacent to it. This effectively makes the one-sided finite difference across the boundary equal to zero. Numerically, this is achieved by padding the $\\phi$ grid with the edge values before computing spatial derivatives.\n\n6.  **Topological Analysis**\n    After the final time step, the topology of the evolved interface is determined. This is done by analyzing the interior set $S = \\{(i,j) | \\phi_{i,j} \\le 0\\}$. We count the number of connected components in this set using a standard labeling algorithm with 4-connectivity (considering only up, down, left, right neighbors as connected). This requires specifying a \"cross-shaped\" connectivity structure to the labeling algorithm, as the default behavior typically corresponds to 8-connectivity.\n\nThe implementation will follow these steps for each test case provided in the problem statement.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import ndimage\n\ndef solve():\n    \"\"\"\n    Main function to run the Level Set Method simulations for the given test cases.\n    \"\"\"\n    test_cases = [\n        # Case A: (N, a, b, alpha, beta, s, CFL, num_steps, reinit_freq)\n        (101, 0.7, 0.3, 1.1, 0.25, 0.2, 0.5, 220, 5),\n        # Case B:\n        (101, 0.7, 0.3, 0.1, 0.25, 0.2, 0.5, 220, 5),\n        # Case C:\n        (101, 0.7, 0.3, 0.35, 0.25, 0.2, 0.5, 100, 5),\n        # Case D:\n        (101, 0.7, 0.3, 1.3, 0.20, 0.2, 0.5, 260, 5),\n    ]\n\n    results = []\n    for params in test_cases:\n        result = run_simulation(*params)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_simulation(N, a, b, alpha, beta, s, CFL, num_steps, reinit_freq):\n    \"\"\"\n    Executes a single LSM simulation for a given set of parameters.\n    \"\"\"\n    # 1. Grid setup\n    domain_size = 2.0\n    dx = domain_size / (N - 1)\n    dy = dx  # Square grid\n    x = np.linspace(-1.0, 1.0, N)\n    y = np.linspace(-1.0, 1.0, N)\n    X, Y = np.meshgrid(x, y)\n\n    # 2. Initial condition: Ellipse\n    phi = (X**2 / a**2) + (Y**2 / b**2) - 1.0\n\n    # 3. Reinitialization to Signed Distance Function (SDF)\n    def reinitialize(p, grid_spacing):\n        mask_in = p = 0\n        dist_in = ndimage.distance_transform_edt(mask_in, sampling=[grid_spacing, grid_spacing])\n        dist_out = ndimage.distance_transform_edt(~mask_in, sampling=[grid_spacing, grid_spacing])\n        return dist_out - dist_in\n    \n    phi = reinitialize(phi, dx)\n    \n    # 4. Speed field F(x,y)\n    F = beta - alpha * np.exp(-(Y**2) / s**2)\n    max_F_abs = np.max(np.abs(F))\n\n    # 5. Time step from CFL condition\n    dt = CFL * dx / max_F_abs\n\n    # 6. Main evolution loop\n    for step in range(num_steps):\n        # Apply Neumann boundary conditions via padding\n        phi_padded = np.pad(phi, pad_width=1, mode='edge')\n\n        # Compute one-sided differences on the interior grid\n        # These correspond to derivatives on the original phi grid\n        phi_x_m = (phi_padded[1:-1, 1:-1] - phi_padded[1:-1, :-2]) / dx\n        phi_x_p = (phi_padded[1:-1, 2:]   - phi_padded[1:-1, 1:-1]) / dx\n        phi_y_m = (phi_padded[1:-1, 1:-1] - phi_padded[:-2, 1:-1]) / dy\n        phi_y_p = (phi_padded[2:,   1:-1] - phi_padded[1:-1, 1:-1]) / dy\n\n        # Godunov numerical Hamiltonian H\n        F_pos = np.maximum(F, 0)\n        F_neg = np.minimum(F, 0)\n        \n        # Gradient term for F  0 (upwind from interior)\n        grad_norm_sq_up = (np.maximum(phi_x_m, 0)**2 + \n                           np.minimum(phi_x_p, 0)**2 + \n                           np.maximum(phi_y_m, 0)**2 + \n                           np.minimum(phi_y_p, 0)**2)\n        \n        # Gradient term for F  0 (upwind from exterior)\n        grad_norm_sq_down = (np.maximum(phi_x_p, 0)**2 + \n                             np.minimum(phi_x_m, 0)**2 + \n                             np.maximum(phi_y_p, 0)**2 + \n                             np.minimum(phi_y_m, 0)**2)\n\n        H = F_pos * np.sqrt(grad_norm_sq_up) + F_neg * np.sqrt(grad_norm_sq_down)\n\n        # Forward Euler time update\n        phi -= dt * H\n\n        # Periodic reinitialization\n        if (step + 1) % reinit_freq == 0:\n            phi = reinitialize(phi, dx)\n\n    # 7. Topological query: count connected components\n    # The set {phi = 0} represents the interior\n    interior_mask = phi = 0\n    # Structure for 4-connectivity\n    structure = np.array([[0, 1, 0], [1, 1, 1], [0, 1, 0]])\n    _, num_components = ndimage.label(interior_mask, structure=structure)\n    \n    return num_components\n\nsolve()\n```"
        },
        {
            "introduction": "In this advanced practice, we move from prescribed velocities to an intrinsic geometric flow, where the interface motion is driven by its own curvature. This type of evolution, governed by the equation $V_n = -\\sigma \\kappa$, is fundamental to physical phenomena dominated by surface tension, such as the behavior of soap films or the coalescence of liquid droplets. This exercise will challenge you to compute second-order spatial derivatives to find the curvature, adding a new layer of numerical complexity and deepening your understanding of physically-motivated geometric PDEs. ",
            "id": "2408479",
            "problem": "You are asked to formulate, discretize, and implement a two-dimensional level set method to simulate the curvature-driven evolution of moving interfaces that represent fluid droplets under surface tension. The computational setting is purely mathematical and dimensionless. Your task is to derive the governing equation from core definitions, propose a stable numerical scheme, and implement a complete, runnable program that solves the problem for a given set of test cases. The goal is to demonstrate that a level set method naturally handles topological change, including coalescence after contact and extinction.\n\nStart from the following foundational base:\n- The interface at time $t$ is the zero contour of a level set function $ \\phi(\\mathbf{x}, t) $, with $ \\mathbf{x} = (x, y) $, and the interior (fluid) region is $ \\{ \\mathbf{x} : \\phi(\\mathbf{x}, t)  0 \\} $. The outward unit normal to the interface is $ \\mathbf{n} = \\nabla \\phi / \\lvert \\nabla \\phi \\rvert $.\n- The curvature (in two dimensions) is defined as $ \\kappa = \\nabla \\cdot \\mathbf{n} $.\n- Under surface tension-driven motion, the normal velocity is proportional to curvature with a minus sign, that is $ V_n = - \\sigma \\, \\kappa $, where $ \\sigma  0 $ is a constant capillary coefficient.\n\nTask 1. Derive, from these definitions, the evolution equation for the level set function $ \\phi(\\mathbf{x}, t) $ that follows from normal motion with velocity $ V_n $ along the normal $ \\mathbf{n} $. Express the equation in terms of $ \\phi $, $ \\kappa $, and spatial derivatives of $ \\phi $ only. Then express $ \\kappa $ explicitly in terms of $ \\phi $.\n\nTask 2. Design a stable and consistent explicit finite difference scheme to solve the derived evolution equation on a uniform Cartesian grid covering the unit square. Your design constraints:\n- Use a uniform grid with $ N \\times N $ points over $ [0,1] \\times [0,1] $ with $ N $ specified below in the test suite.\n- Use central differences to approximate spatial derivatives needed to compute curvature $ \\kappa $ as a divergence of the normalized gradient of $ \\phi $.\n- Use an upwind Godunov numerical Hamiltonian to approximate $ \\lvert \\nabla \\phi \\rvert $ in the advective term of the Hamilton–Jacobi equation $ \\phi_t + V_n \\lvert \\nabla \\phi \\rvert = 0 $.\n- Enforce a Courant–Friedrichs–Lewy (CFL) condition based on the parabolic scaling of curvature-driven motion. Choose a time step $ \\Delta t $ that satisfies a stability restriction of the form $ \\Delta t \\le C \\, \\min(\\Delta x, \\Delta y)^2 / \\sigma $, with a dimensionless constant $ C $ chosen for stability.\n- Impose homogeneous Neumann boundary conditions (zero normal derivative) for $ \\phi $ on all sides of the unit square.\n- Periodically reinitialize $ \\phi $ toward a signed distance function by integrating a suitable artificial-time Hamilton–Jacobi equation for a few pseudo-time steps, using an upwind discretization and a regularized sign function built from the current $ \\phi $. You must state the reinitialization equation you use and how you discretize it.\n\nTask 3. Initialization and test suite. Implement the following initial interfaces and run the simulation until the specified final times. All quantities are dimensionless. The capillary coefficient is $ \\sigma = 1 $. The grid resolution is $ N = 128 $, uniformly spaced over $ [0,1] \\times [0,1] $. For each case, construct $ \\phi(\\mathbf{x}, 0) $ as the signed distance to the union of the specified disks, with negative values inside the union. Each disk is defined by its center $ (x_c, y_c) $ and radius $ R $ via the Euclidean distance. For the union of two disks, set the initial level set as the pointwise minimum of the signed distances to each disk.\n- Case A (overlapping two-droplet coalescence after contact): two identical disks with centers $ (0.35, 0.50) $ and $ (0.65, 0.50) $ and radius $ R = 0.18 $, final time $ T = 0.006 $. These disks overlap initially, representing two droplets that have just contacted; surface tension should smooth the neck into a single connected droplet.\n- Case B (separated two droplets): two identical disks with centers $ (0.25, 0.50) $ and $ (0.75, 0.50) $ and radius $ R = 0.18 $, final time $ T = 0.006 $. The disks are initially disjoint; without external forcing, they should remain disjoint during curvature-driven evolution over this time horizon.\n- Case C (single small droplet extinction): one disk with center $ (0.50, 0.50) $ and radius $ R = 0.07 $, final time $ T = 0.003 $. Under curvature-driven flow, a sufficiently small circle should shrink to extinction by the final time.\n\nTask 4. Post-processing and measurable outputs. At the final time of each case, compute the number of connected components of the set $ \\{ \\mathbf{x} : \\phi(\\mathbf{x}, T)  0 \\} $ using $4$-connectivity on the grid. Your program must produce a single line of output containing the numbers of connected components for the three cases, in order A, B, C, as a comma-separated list enclosed in square brackets, for example $ [n_A, n_B, n_C] $. The output values must be integers.\n\nAngle units do not apply. All variables are dimensionless, so no physical unit conversion is required.\n\nYour program must be fully self-contained, deterministic, and must not require any user input. It must adhere to the execution environment specified later and produce exactly one line of output in the specified format. The design choices for discretization, time stepping, boundary conditions, and reinitialization must be consistent with your derivation in Task 1 and the constraints above, and they must be documented in code comments within your program.",
            "solution": "The problem posed is a well-defined computational physics task grounded in the established principles of the level set method and the physical model of curvature-driven interface motion. All parameters, conditions, and objectives are specified with sufficient clarity and rigor to permit a unique and verifiable solution. The problem is therefore deemed valid and I shall proceed with its resolution.\n\nThe solution is structured according to the four tasks outlined in the problem statement.\n\nTask 1: Derivation of the Governing Equation\n\nThe interface is defined as the zero level set of a function $ \\phi(\\mathbf{x}, t) $, where $ \\mathbf{x} \\in \\mathbb{R}^2 $.\nFor any point $ \\mathbf{x}(t) $ that remains on the interface, we have $ \\phi(\\mathbf{x}(t), t) = 0 $. Differentiating this with respect to time $ t $ using the material derivative gives:\n$$\n\\frac{d}{dt}\\phi(\\mathbf{x}(t), t) = \\frac{\\partial \\phi}{\\partial t} + \\nabla \\phi \\cdot \\frac{d\\mathbf{x}}{dt} = 0\n$$\nThe velocity of the point on the interface is $ \\mathbf{v} = d\\mathbf{x}/dt $. The problem states that the interface moves only in its normal direction with a specified normal velocity $ V_n $. The velocity vector is thus $ \\mathbf{v} = V_n \\mathbf{n} $. Substituting this into the previous equation yields:\n$$\n\\phi_t + \\nabla \\phi \\cdot (V_n \\mathbf{n}) = 0\n$$\nwhere $ \\phi_t $ is the partial derivative of $ \\phi $ with respect to $ t $. The outward unit normal vector $ \\mathbf{n} $ is defined as $ \\mathbf{n} = \\nabla \\phi / |\\nabla \\phi| $. Substituting this expression for $ \\mathbf{n} $ gives:\n$$\n\\phi_t + V_n \\nabla \\phi \\cdot \\frac{\\nabla \\phi}{|\\nabla \\phi|} = 0 \\implies \\phi_t + V_n \\frac{|\\nabla \\phi|^2}{|\\nabla \\phi|} = 0\n$$\nThis simplifies to the general level set equation for an interface moving with normal velocity $ V_n $:\n$$\n\\phi_t + V_n |\\nabla \\phi| = 0\n$$\nThe problem specifies curvature-driven motion, where the normal velocity is proportional to the local curvature $ \\kappa $, given by $ V_n = -\\sigma \\kappa $. Substituting this into the level set equation provides the evolution equation for $ \\phi $:\n$$\n\\phi_t - \\sigma \\kappa |\\nabla \\phi| = 0\n$$\nThis is the required evolution equation.\n\nNext, we express the curvature $ \\kappa $ in terms of the level set function $ \\phi $. The curvature is the divergence of the unit normal vector: $ \\kappa = \\nabla \\cdot \\mathbf{n} $.\n$$\n\\kappa = \\nabla \\cdot \\left( \\frac{\\nabla \\phi}{|\\nabla \\phi|} \\right) = \\nabla \\cdot \\left( \\frac{(\\phi_x, \\phi_y)}{\\sqrt{\\phi_x^2 + \\phi_y^2}} \\right)\n$$\nwhere subscripts denote partial differentiation. Applying the divergence operator yields the explicit expression for curvature in two dimensions:\n$$\n\\kappa = \\frac{\\partial}{\\partial x}\\left(\\frac{\\phi_x}{|\\nabla\\phi|}\\right) + \\frac{\\partial}{\\partial y}\\left(\\frac{\\phi_y}{|\\nabla\\phi|}\\right)\n$$\nExpanding this using the quotient rule for differentiation results in:\n$$\n\\kappa = \\frac{\\phi_{xx}\\phi_y^2 - 2\\phi_x\\phi_y\\phi_{xy} + \\phi_{yy}\\phi_x^2}{(\\phi_x^2 + \\phi_y^2)^{3/2}}\n$$\nThis completes the derivation.\n\nTask 2: Design of a Numerical Scheme\n\nWe discretize the domain $ [0,1] \\times [0,1] $ with a uniform Cartesian grid of $ N \\times N $ points, such that $ x_i = i h, y_j = j h $ for $ i, j = 0, \\dots, N-1 $, with grid spacing $ h = 1/(N-1) $. Let $ \\phi^n_{i,j} $ denote the numerical approximation of $ \\phi(x_i, y_j, n\\Delta t) $.\n\nThe evolution equation $ \\phi_t - \\sigma \\kappa |\\nabla \\phi| = 0 $ is advanced in time using an explicit forward Euler method. The equation is treated as a Hamilton-Jacobi equation $ \\phi_t + V_{ij} |\\nabla\\phi|_{ij} = 0 $, where the effective velocity is $ V_{ij} = -\\sigma\\kappa_{ij} $. As stipulated, we use a hybrid scheme:\n1.  **Curvature $ \\kappa $**: This term involves second derivatives and is computed using central differences for stability. Numerically, it is more robust to compute $ \\kappa $ as the divergence of the normal field rather than using the fully expanded formula with second derivatives directly.\n    First, we compute the components of the gradient $ \\nabla\\phi $ using second-order central differences:\n    $$\n    (\\phi_x)_{i,j} \\approx \\frac{\\phi_{i+1,j} - \\phi_{i-1,j}}{2h}, \\quad (\\phi_y)_{i,j} \\approx \\frac{\\phi_{i,j+1} - \\phi_{i,j-1}}{2h}\n    $$\n    The normal vector components $ (n_x, n_y) $ are then computed:\n    $$\n    (n_x)_{i,j} = \\frac{(\\phi_x)_{i,j}}{\\sqrt{(\\phi_x)^2_{i,j} + (\\phi_y)^2_{i,j} + \\epsilon^2}}, \\quad (n_y)_{i,j} = \\frac{(\\phi_y)_{i,j}}{\\sqrt{(\\phi_x)^2_{i,j} + (\\phi_y)^2_{i,j} + \\epsilon^2}}\n    $$\n    where $ \\epsilon $ is a small regularization parameter (e.g., $ \\epsilon=h $) to prevent division by zero. Finally, the curvature $ \\kappa $ is computed as the divergence of the normal field, again using central differences:\n    $$\n    \\kappa_{i,j} = \\frac{(n_x)_{i+1,j} - (n_x)_{i-1,j}}{2h} + \\frac{(n_y)_{i,j+1} - (n_y)_{i,j-1}}{2h}\n    $$\n2.  **Advective Term $ V_n |\\nabla \\phi| $**: The term $ |\\nabla \\phi| $ is discretized using a first-order upwind Godunov-type scheme. The update rule for $ \\phi $ is:\n    $$\n    \\frac{\\phi^{n+1}_{i,j} - \\phi^n_{i,j}}{\\Delta t} = - \\left( \\max(V^n_{i,j}, 0)\\nabla^+_{i,j} + \\min(V^n_{i,j}, 0)\\nabla^-_{i,j} \\right)\n    $$\n    where $ V^n_{i,j} = -\\sigma \\kappa^n_{i,j} $. The upwinded gradient magnitudes, $ \\nabla^+ $ and $ \\nabla^- $, are given by:\n    $$\n    \\nabla^+_{i,j} = \\left[ \\max(D_x^-\\phi, 0)^2 + \\min(D_x^+\\phi, 0)^2 + \\max(D_y^-\\phi, 0)^2 + \\min(D_y^+\\phi, 0)^2 \\right]^{1/2}\n    $$\n    $$\n    \\nabla^-_{i,j} = \\left[ \\max(D_x^+\\phi, 0)^2 + \\min(D_x^-\\phi, 0)^2 + \\max(D_y^+\\phi, 0)^2 + \\min(D_y^-\\phi, 0)^2 \\right]^{1/2}\n    $$\n    where $ D_x^\\pm, D_y^\\pm $ are the standard forward and backward first-order finite differences. For example, $ D_x^+\\phi_{i,j} = (\\phi_{i+1,j} - \\phi_{i,j})/h $.\n3.  **Boundary Conditions**: Homogeneous Neumann conditions ($ \\partial\\phi/\\partial\\mathbf{n}_{\\text{bdy}} = 0 $) are enforced using ghost cells. A common implementation for schemes involving central differences is to use symmetric padding, where `phi[-1] = phi[1]`, which ensures a zero gradient is computed at the boundary.\n4.  **Time Step**: Motion by mean curvature is a stiff, parabolic-like problem. An explicit scheme requires a stringent time step constraint for stability, which scales with the square of the grid spacing:\n    $$\n    \\Delta t \\le C \\frac{h^2}{\\sigma}\n    $$\n    where $ h = \\min(\\Delta x, \\Delta y) $. A conservative stability constant $ C=0.2 $ is chosen.\n5.  **Reinitialization**: The level set function can become distorted over time. To maintain its signed distance property ($ |\\nabla\\phi|=1 $), it is periodically reinitialized. This is done by solving the following Hamilton-Jacobi equation to steady-state in a pseudo-time $ \\tau $:\n    $$\n    \\phi_{\\tau} + \\text{sgn}(\\phi_0) (|\\nabla \\phi| - 1) = 0\n    $$\n    where $ \\phi_0 $ is the level set function before reinitialization. The sign function is regularized as $ \\text{sgn}(\\phi_0) \\approx \\phi_0 / \\sqrt{\\phi_0^2 + h^2} $. This equation is solved for a few pseudo-time steps using a forward Euler method and the same upwind scheme for $ |\\nabla\\phi| $ as in the main evolution, with a pseudo-time step $ \\Delta \\tau $ satisfying its own CFL condition, $ \\Delta\\tau \\le h $.\n\nTask 3  4: Implementation, Test Cases, and Post-processing\n\nThe numerical scheme described above is implemented in Python using the `numpy` and `scipy` libraries. The initial conditions for each test case are constructed by defining $ \\phi(\\mathbf{x}, 0) $ as the signed distance to the specified geometric shapes. The simulation is run for the specified duration. At the final time $ T $, the set of points where $ \\phi(\\mathbf{x}, T)  0 $ is identified. The number of connected components within this set is determined using a labeling algorithm from `scipy.ndimage` with $ 4 $-connectivity.\n\n- Case A (Overlapping): The two initial disks overlap, forming a single connected region. Curvature-driven flow will smooth the \"neck\" between them, causing the shape to become more compact and elliptical. The number of connected components is expected to be $ 1 $ throughout.\n- Case B (Separated): The two disks are initially separate. Under curvature flow, both will shrink in place. As they are sufficiently far apart, they will not merge within the given time. The number of connected components is expected to remain $ 2 $.\n- Case C (Extinction): A single small circular droplet shrinks under curvature. The analytical solution for the radius of a circle evolving under mean curvature flow is $ R(t) = \\sqrt{R_0^2 - 2\\sigma t} $. For $ R_0=0.07 $ and $ \\sigma=1 $, the extinction time is $ t_{\\text{ext}} = R_0^2/(2\\sigma) = 0.07^2/2 = 0.00245 $. Since the final time $ T=0.003 $ is greater than $ t_{\\text{ext}} $, the droplet is expected to vanish completely. The number of connected components will be $ 0 $.\n\nThe expected output based on this analysis is the list `[1, 2, 0]`. The following implementation will verify this numerically.",
            "answer": "```python\nimport numpy as np\nfrom scipy.ndimage import label\n\ndef solve():\n    \"\"\"\n    Solves the curvature-driven flow problem using the level set method.\n    \"\"\"\n\n    # --- Simulation parameters ---\n    N = 128  # Grid resolution\n    SIGMA = 1.0  # Capillary coefficient\n    DOMAIN_SIZE = 1.0\n    CFL_C = 0.2  # CFL constant for main evolution\n    REINIT_FREQ = 25  # Reinitialization frequency (in time steps)\n    REINIT_STEPS = 5  # Number of pseudo-time steps for reinitialization\n\n    # --- Grid setup ---\n    h = DOMAIN_SIZE / (N - 1)\n    x = np.linspace(0, DOMAIN_SIZE, N)\n    y = np.linspace(0, DOMAIN_SIZE, N)\n    xx, yy = np.meshgrid(x, y, indexing='ij')\n    \n    # --- Time step calculation ---\n    # Parabolic scaling for curvature flow: dt ~ h^2\n    dt = CFL_C * h**2 / SIGMA\n\n    # --- Test cases as defined in the problem ---\n    test_cases = [\n        {\n            'name': 'A',\n            'T_final': 0.006,\n            'shapes': [\n                {'type': 'disk', 'center': (0.35, 0.50), 'radius': 0.18},\n                {'type': 'disk', 'center': (0.65, 0.50), 'radius': 0.18}\n            ]\n        },\n        {\n            'name': 'B',\n            'T_final': 0.006,\n            'shapes': [\n                {'type': 'disk', 'center': (0.25, 0.50), 'radius': 0.18},\n                {'type': 'disk', 'center': (0.75, 0.50), 'radius': 0.18}\n            ]\n        },\n        {\n            'name': 'C',\n            'T_final': 0.003,\n            'shapes': [\n                {'type': 'disk', 'center': (0.50, 0.50), 'radius': 0.07}\n            ]\n        }\n    ]\n\n    results = []\n\n    # --- Helper functions for numerical scheme ---\n\n    def apply_neumann(phi_grid):\n        \"\"\"Applies homogeneous Neumann boundary conditions using ghost cells.\"\"\"\n        # This implementation reflects values across the boundary, which is\n        # equivalent to setting the normal derivative to zero for a central\n        # difference scheme. phi[-1] = phi[1], phi[N] = phi[N-2]\n        padded = np.pad(phi_grid, 1, mode='symmetric')\n        return padded\n\n    def reinitialize(phi):\n        \"\"\"\n        Reinitializes the level set function phi to be a signed distance function.\n        Solves phi_tau + sgn(phi_0) * ( |grad(phi)| - 1 ) = 0.\n        \"\"\"\n        phi_0 = phi.copy()\n        # Regularized sign function\n        sign = phi_0 / np.sqrt(phi_0**2 + h**2)\n        \n        # CFL for reinitialization (hyperbolic)\n        dt_reinit = 0.5 * h\n        \n        phi_reinit = phi.copy()\n\n        for _ in range(REINIT_STEPS):\n            padded_phi = apply_neumann(phi_reinit)\n            \n            # First-order upwind/downwind stencils\n            dx_p = (padded_phi[1:-1, 2:] - padded_phi[1:-1, 1:-1]) / h\n            dx_m = (padded_phi[1:-1, 1:-1] - padded_phi[1:-1, :-2]) / h\n            dy_p = (padded_phi[1:-1, 2:] - padded_phi[1:-1, 1:-1]) / h\n            dy_m = (padded_phi[1:-1, 1:-1] - padded_phi[1:-1, :-2]) / h\n\n            # Godunov scheme for gradient magnitude\n            grad_norm_p = np.sqrt(np.maximum(dx_m, 0)**2 + np.minimum(dx_p, 0)**2 +\n                                  np.maximum(dy_m, 0)**2 + np.minimum(dy_p, 0)**2)\n            grad_norm_m = np.sqrt(np.maximum(dx_p, 0)**2 + np.minimum(dx_m, 0)**2 +\n                                  np.maximum(dy_p, 0)**2 + np.minimum(dy_m, 0)**2)\n\n            # Update based on sign\n            update = - (np.maximum(sign, 0) * (grad_norm_p - 1) + \n                        np.minimum(sign, 0) * (grad_norm_m - 1))\n            \n            phi_reinit += dt_reinit * update\n\n        return phi_reinit\n\n    for case in test_cases:\n        # --- Initialization ---\n        phi_list = []\n        for shape in case['shapes']:\n            if shape['type'] == 'disk':\n                xc, yc = shape['center']\n                R = shape['radius']\n                phi_disk = np.sqrt((xx - xc)**2 + (yy - yc)**2) - R\n                phi_list.append(phi_disk)\n        \n        # For multiple shapes, the initial phi is the minimum of individual signed distances\n        phi = np.min(np.array(phi_list), axis=0) if len(phi_list)  1 else phi_list[0]\n        \n        # --- Time evolution loop ---\n        t = 0.0\n        step_count = 0\n        while t  case['T_final']:\n            # Reinitialize periodically\n            if step_count % REINIT_FREQ == 0:\n                phi = reinitialize(phi)\n\n            padded_phi = apply_neumann(phi)\n\n            # --- Calculate curvature k ---\n            # Central differences for gradient\n            phi_x = (padded_phi[2:, 1:-1] - padded_phi[:-2, 1:-1]) / (2 * h)\n            phi_y = (padded_phi[1:-1, 2:] - padded_phi[1:-1, :-2]) / (2 * h)\n            \n            # Regularized gradient magnitude\n            magn_grad = np.sqrt(phi_x**2 + phi_y**2 + h**2)\n\n            # Normal vector field\n            nx = phi_x / magn_grad\n            ny = phi_y / magn_grad\n            \n            padded_nx = apply_neumann(nx)\n            padded_ny = apply_neumann(ny)\n\n            # Divergence of the normal field (curvature)\n            nx_x = (padded_nx[2:, 1:-1] - padded_nx[:-2, 1:-1]) / (2 * h)\n            ny_y = (padded_ny[1:-1, 2:] - padded_ny[1:-1, :-2]) / (2 * h)\n            kappa = nx_x + ny_y\n\n            # --- Calculate upwind gradient norms for the advection term ---\n            # Using the main phi grid for this\n            dx_p = (padded_phi[2:, 1:-1] - padded_phi[1:-1, 1:-1]) / h\n            dx_m = (padded_phi[1:-1, 1:-1] - padded_phi[:-2, 1:-1]) / h\n            dy_p = (padded_phi[1:-1, 2:] - padded_phi[1:-1, 1:-1]) / h\n            dy_m = (padded_phi[1:-1, 1:-1] - padded_phi[1:-1, :-2]) / h\n\n            grad_norm_p = np.sqrt(np.maximum(dx_m, 0)**2 + np.minimum(dx_p, 0)**2 +\n                                  np.maximum(dy_m, 0)**2 + np.minimum(dy_p, 0)**2)\n            grad_norm_m = np.sqrt(np.maximum(dx_p, 0)**2 + np.minimum(dx_m, 0)**2 +\n                                  np.maximum(dy_p, 0)**2 + np.minimum(dy_m, 0)**2)\n\n            # --- Update phi ---\n            # Effective velocity for Hamilton-Jacobi formulation\n            V = -SIGMA * kappa\n            \n            # The problem is phi_t + V * |nabla phi| = 0\n            # Update is phi_new = phi_old - dt * (V * |nabla phi|)\n            # So phi_t = -V * |nabla phi|\n            update_term = - (np.maximum(V, 0) * grad_norm_p + np.minimum(V, 0) * grad_norm_m)\n\n            phi += dt * update_term\n\n            t += dt\n            step_count += 1\n            \n        # --- Post-processing: Count connected components ---\n        mask = phi  0\n        # 4-connectivity structure\n        structure = np.array([[0, 1, 0], [1, 1, 1], [0, 1, 0]])\n        _, num_components = label(mask, structure=structure)\n        results.append(num_components)\n\n    # --- Final Output ---\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}