{
    "hands_on_practices": [
        {
            "introduction": "我们的第一个练习是一个基础热身。在深入研究复杂的数值代码之前，通过一个可以解析求解的案例来建立直觉至关重要。我们将分析一个简单圆形界面的演化，这使我们能够直接求解水平集方程，并理解法向速度 $F$ 等参数如何影响最终结果 。这为验证更复杂的数值模拟提供了坚实的基础和基准。",
            "id": "2408430",
            "problem": "考虑一个在二维空间中运动的封闭界面，该界面由水平集方法（Level Set Method, LSM）隐式表示。在时间 $t$ 的界面是函数 $\\phi(x,y,t)$ 的零水平集，该函数根据偏微分方程（Partial Differential Equation, PDE）演化\n$$\\phi_t + F \\lvert \\nabla \\phi \\rvert = 0,$$\n其中 $F$ 是一个在空间和时间上恒定的法向速度，单位为米/秒。初始条件是到以原点为中心、半径为 $R_0$ 的圆的有向距离，\n$$\\phi(x,y,0) = \\sqrt{x^2 + y^2} - R_0,$$\n因此初始零水平集 $\\{\\phi=0\\}$ 是半径为 $R_0$ 的圆。距离单位为米，时间单位为秒，$F$ 的单位为米/秒。\n\n对于由参数 $(R_0, F, t)$ 指定的每个测试用例：\n- 计算在时间 $t$ 时零水平集的半径 $R(t)$，单位为米。\n- 计算在时间 $t$ 时零水平集所包围的面积 $A(t)$，单位为平方米，定义为 $A(t) = \\pi \\, R(t)^2$。\n- 计算坍缩时间 $T_c$，单位为秒，定义为半径变为零的最早时间 $t \\ge 0$。如果界面永不坍缩（例如，如果 $F \\ge 0$），则为 $T_c$ 返回 $-1.0$。如果 $R_0 = 0$，则定义 $T_c = 0.0$。\n\n所有输出必须以指定的单位表示，并四舍五入到六位小数。要求的最终输出格式是单行字符串，其中包含一个用方括号括起来的、由逗号分隔的各测试用例结果列表，每个测试用例的结果本身是一个形式为 $[R(t), A(t), T_c]$ 的列表。\n\n使用以下测试套件：\n- 测试 1 (收缩，坍缩前): $(R_0, F, t) = (1.0, -0.2, 3.0)$。\n- 测试 2 (收缩，恰好在坍缩时): $(R_0, F, t) = (1.0, -0.5, 2.0)$。\n- 测试 3 (收缩，坍缩后): $(R_0, F, t) = (0.75, -3.0, 1.0)$。\n- 测试 4 (扩张，不坍缩): $(R_0, F, t) = (0.6, 0.05, 10.0)$。\n- 测试 5 (初始时已坍缩): $(R_0, F, t) = (0.0, -1.0, 0.5)$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，例如：\n\"[ [R1,A1,Tc1],[R2,A2,Tc2],...[R5,A5,Tc5] ]\"\n每个数值都四舍五入到六位小数。",
            "solution": "该问题要求对由水平集方程控制的圆形界面演化进行解析求解。问题陈述在科学上是合理的、适定的，并包含了所有必要信息。这是一个水平集方法的标准应用，可以推导出其解析解。因此，该问题是有效的。\n\n水平集函数 $\\phi(x,y,t)$ 的演化由哈密顿-雅可比偏微分方程描述：\n$$ \\phi_t + F |\\nabla \\phi| = 0 $$\n其中 $\\phi_t = \\frac{\\partial \\phi}{\\partial t}$，$\\nabla \\phi$ 是 $\\phi$ 关于空间变量 $(x,y)$ 的梯度。$F$ 是一个恒定的法向速度。\n\n初始条件将界面指定为以原点为中心、半径为 $R_0$ 的圆。函数 $\\phi(x,y,0)$ 被给出为到该圆的有向距离函数：\n$$ \\phi(x,y,0) = \\sqrt{x^2 + y^2} - R_0 $$\n零水平集 $\\{\\phi=0\\}$ 确实是圆 $x^2 + y^2 = R_0^2$。\n\n由于初始条件的径向对称性以及恒定且空间均匀的速度 $F$，演化中的界面在所有时间 $t \\ge 0$ 都将保持为圆形。这个圆的半径，我们称之为 $R(t)$，将是时间的函数。因此，我们可以为解 $\\phi(x,y,t)$ 提出一个拟设，该拟设保留了到时变半径 $R(t)$ 的圆的有向距离函数形式：\n$$ \\phi(x,y,t) = \\sqrt{x^2 + y^2} - R(t) $$\n为了与初始条件一致，我们必须有 $R(0) = R_0$。\n\n现在我们将这个拟设代入偏微分方程。首先，我们计算必要的导数。令 $r = \\sqrt{x^2+y^2}$。则 $\\phi(r, t) = r - R(t)$。\n关于时间 $t$ 的偏导数是：\n$$ \\phi_t = \\frac{\\partial}{\\partial t} \\left( \\sqrt{x^2 + y^2} - R(t) \\right) = - \\frac{dR}{dt} = -R'(t) $$\n$\\phi$ 的梯度是：\n$$ \\nabla \\phi = \\left( \\frac{\\partial \\phi}{\\partial x}, \\frac{\\partial \\phi}{\\partial y} \\right) = \\left( \\frac{x}{\\sqrt{x^2+y^2}}, \\frac{y}{\\sqrt{x^2+y^2}} \\right) = \\left( \\frac{x}{r}, \\frac{y}{r} \\right) $$\n梯度的模是：\n$$ |\\nabla \\phi| = \\sqrt{\\left(\\frac{x}{r}\\right)^2 + \\left(\\frac{y}{r}\\right)^2} = \\sqrt{\\frac{x^2+y^2}{r^2}} = 1 $$\n这是有向距离函数的一个基本性质：其梯度的模为单位长度（除了在原点这个单点）。\n\n将 $\\phi_t$ 和 $|\\nabla \\phi|$ 的表达式代入水平集方程，得到：\n$$ -R'(t) + F(1) = 0 $$\n$$ R'(t) = F $$\n这是一个关于 $R(t)$ 的简单一阶常微分方程。我们可以通过对时间从 $0$ 到 $t$ 积分来求解它：\n$$ \\int_0^t R'(\\tau) d\\tau = \\int_0^t F d\\tau $$\n$$ R(t) - R(0) = F t $$\n使用初始条件 $R(0) = R_0$，我们得到半径演化的解：\n$$ R(t) = R_0 + F t $$\n物理半径不能为负。如果 $R_0 + F t$ 变为负值，则表示界面已经坍缩并消失。在这种情况下，（现已不存在的）零水平集的半径为 $0$。因此，在时间 $t$ 时界面的物理正确半径是：\n$$ R(t) = \\max(0, R_0 + F t) $$\n\n有了 $R(t)$ 的这个解析解，我们就可以确定其他所需的量。\n\n1.  **半径 $R(t)$**：在时间 $t$ 的半径（单位为米）由 $R(t) = \\max(0, R_0 + F t)$ 给出。\n\n2.  **面积 $A(t)$**：由圆形界面包围的面积（单位为平方米）是 $A(t) = \\pi R(t)^2$。\n\n3.  **坍缩时间 $T_c$**：这是使 $R(t)=0$ 的最早时间 $t \\ge 0$。\n    我们设 $R_0 + F t = 0$，得到 $t = -R_0/F$。\n    这个计算必须根据给定的规则进行解释：\n    -   若 $R_0=0$，则圆已经坍缩。问题规定 $T_c = 0.0$。\n    -   若 $R_0  0$ 且 $F \\ge 0$，则半径不减，永远不会达到 $0$。问题规定 $T_c = -1.0$。\n    -   若 $R_0  0$ 且 $F  0$，则圆在收缩。坍缩将发生在正时间 $T_c = -R_0/F$。\n\n现在将这些推导出的公式应用于每个测试用例。\n- **测试 1**：$(R_0, F, t) = (1.0, -0.2, 3.0)$。\n  $R(3.0) = \\max(0, 1.0 + (-0.2)(3.0)) = \\max(0, 0.4) = 0.4$ 米。\n  $A(3.0) = \\pi (0.4)^2 = 0.16\\pi \\approx 0.502655$ 米$^2$。\n  $T_c = -1.0 / (-0.2) = 5.0$ 秒。\n\n- **测试 2**：$(R_0, F, t) = (1.0, -0.5, 2.0)$。\n  $R(2.0) = \\max(0, 1.0 + (-0.5)(2.0)) = \\max(0, 0.0) = 0.0$ 米。\n  $A(2.0) = \\pi (0.0)^2 = 0.0$ 米$^2$。\n  $T_c = -1.0 / (-0.5) = 2.0$ 秒。\n\n- **测试 3**：$(R_0, F, t) = (0.75, -3.0, 1.0)$。\n  $T_c = -0.75 / (-3.0) = 0.25$ 秒。\n  由于 $t=1.0  T_c=0.25$，圆已经坍缩。\n  $R(1.0) = \\max(0, 0.75 + (-3.0)(1.0)) = \\max(0, -2.25) = 0.0$ 米。\n  $A(1.0) = \\pi (0.0)^2 = 0.0$ 米$^2$。\n\n- **测试 4**：$(R_0, F, t) = (0.6, 0.05, 10.0)$。\n  $R(10.0) = \\max(0, 0.6 + (0.05)(10.0)) = \\max(0, 1.1) = 1.1$ 米。\n  $A(10.0) = \\pi (1.1)^2 = 1.21\\pi \\approx 3.801327$ 米$^2$。\n  由于 $F \\ge 0$，界面永不坍缩，所以 $T_c = -1.0$ 秒。\n\n- **测试 5**：$(R_0, F, t) = (0.0, -1.0, 0.5)$。\n  由于 $R_0=0$，问题规定 $T_c=0.0$ 秒。\n  $R(0.5) = \\max(0, 0.0 + (-1.0)(0.5)) = \\max(0, -0.5) = 0.0$ 米。\n  $A(0.5) = \\pi (0.0)^2 = 0.0$ 米$^2$。\n\n实现部分将把这些分析结果编写成代码。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the level set problem for a circular interface.\n\n    The problem describes a circular interface evolving with a constant normal\n    speed F. The radius R(t) of the circle at time t can be found by\n    solving the ODE R'(t) = F with initial condition R(0) = R0.\n    This gives R_candidate(t) = R0 + F*t.\n\n    The physical radius cannot be negative, so R(t) = max(0, R0 + F*t).\n    The area is A(t) = pi * R(t)^2.\n    The collapse time Tc is the time when R(t) first becomes 0.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (R0, F, t)\n        (1.0, -0.2, 3.0),  # Test 1: shrinking, before collapse\n        (1.0, -0.5, 2.0),  # Test 2: shrinking, exactly at collapse\n        (0.75, -3.0, 1.0), # Test 3: shrinking, after collapse\n        (0.6, 0.05, 10.0), # Test 4: expanding, no collapse\n        (0.0, -1.0, 0.5),  # Test 5: already collapsed initially\n    ]\n\n    results = []\n    for case in test_cases:\n        R0, F, t = case\n\n        # 1. Compute the radius R(t)\n        # The radius evolution is R(t) = R0 + F*t, but physical radius is non-negative.\n        R_t = max(0.0, R0 + F * t)\n\n        # 2. Compute the area A(t)\n        A_t = np.pi * R_t**2\n\n        # 3. Compute the collapse time T_c\n        # As per problem definition:\n        # If R0 = 0, Tc = 0.0\n        # If R0 > 0 and F >= 0, never collapses, Tc = -1.0\n        # If R0 > 0 and F  0, collapses at Tc = -R0 / F\n        if R0 == 0.0:\n            T_c = 0.0\n        elif F >= 0.0:\n            T_c = -1.0\n        else: # R0 > 0 and F  0\n            T_c = -R0 / F\n\n        # Round all results to six decimal places\n        R_t_rounded = round(R_t, 6)\n        A_t_rounded = round(A_t, 6)\n        T_c_rounded = round(T_c, 6)\n\n        # Format the result for a single case as requested: [R,A,Tc]\n        # with no spaces.\n        case_result_str = (\n            f\"[{R_t_rounded},{A_t_rounded},{T_c_rounded}]\"\n        )\n        results.append(case_result_str)\n\n    # Final print statement in the exact required format:\n    # \"[ [R1,A1,Tc1],[R2,A2,Tc2],... ]\"\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在解析解的基础上，本实践将进入完整的数值模拟领域。你将实现一个完整的水平集求解器，以模拟一个以空间变化的速场 $F(x,y)$ 移动的界面，这是一个比恒定速度更贴近现实的场景。这个练习  尤其有价值，因为它展示了水平集方法的关键优势之一：无需任何特殊逻辑即可自然地处理拓扑变化，例如一个物体分裂成两个。",
            "id": "2408442",
            "problem": "要求您实现一个水平集方法 (Level Set Method, LSM) 模拟，来模拟一个初始为椭圆的封闭界面的分裂过程。该演化过程由一个空间相关的法向速度控制。您必须推导出一个稳定、单调、一阶迎风（Godunov 型）的 Hamilton–Jacobi 偏微分方程 (PDE) 离散格式，并用代码实现。目标是测试演化中的界面是否发生拓扑变化（分裂），这一变化通过模拟结束时内部相的连通分量数量来量化。此处所有量均为无量纲；不需要物理单位。\n\n水平集函数的演化由以下 PDE 给出\n$$\n\\phi_t + F(x,y)\\lvert \\nabla \\phi \\rvert = 0,\n$$\n其中 $\\phi(x,y,t)$ 是一个标量场，演化中的界面是其零等值线 $\\{\\phi = 0\\}$，而内部区域为 $\\{\\phi \\le 0\\}$。速度场是空间相关的，其形式规定为\n$$\nF(x,y) = \\beta - \\alpha \\exp\\!\\left(-\\frac{y^2}{s^2}\\right).\n$$\n这里，$\\alpha$、$\\beta$ 和 $s$ 是严格为正的参数。计算域为方形区域 $[-1,1] \\times [-1,1]$，并在均匀的笛卡尔网格上进行离散。\n\n初始条件：\n- 初始界面是一个由以下方程隐式定义的椭圆\n$$\n\\frac{x^2}{a^2} + \\frac{y^2}{b^2} = 1,\n$$\n初始水平集场 $\\phi(x,y,0)$ 的构建必须满足在椭圆内部 $\\phi \\le 0$，在外部 $\\phi  0$。为保证数值稳定性，您必须在 $t=0$ 时以及在模拟过程中周期性地将 $\\phi$ 重新初始化为符号距离函数。重新初始化可以通过任何能够生成近似于到零水平集符号距离的场的一致方法来完成；一种常用方法是在二元内部掩码 $\\{\\phi \\le 0\\}$ 上计算欧几里得距离变换 (Euclidean Distance Transform, EDT)。\n\n离散化与稳定性要求：\n- 推导并实现一个 $\\lvert \\nabla \\phi \\rvert$ 的一阶单调迎风 (Godunov) 近似，该近似与 $F(x,y)$ 的符号一致，使用在间距为 $\\Delta x$ 和 $\\Delta y$ 的均匀网格上的单边有限差分。\n- 使用显式前向欧拉时间积分器，其时间步长 $\\Delta t$ 满足 Courant–Friedrichs–Lewy (CFL) 稳定性约束。您必须选择\n$$\n\\Delta t = \\mathrm{CFL} \\times \\frac{\\min(\\Delta x, \\Delta y)}{\\max\\limits_{x,y}\\lvert F(x,y)\\rvert},\n$$\n其中 $\\mathrm{CFL}$ 是一个满足 $0  \\mathrm{CFL} \\le 1$ 的常数。\n- 通过在边界处使用适当的单边差分或值复制来数值地施加齐次 Neumann 边界条件（法向导数为零）。\n\n拓扑查询：\n- 在每次模拟结束时，使用网格上的 4-连通性计算内部集合 $\\{\\phi \\le 0\\}$ 的连通分量数量。\n\n您的程序必须实现以下内容，并为指定的测试套件生成所需输出。不允许用户输入；所有参数都嵌入代码中。\n\n实现要求：\n- 在 $[-1,1] \\times [-1,1]$ 上构建一个包含 $N \\times N$ 个节点的均匀网格，其中 $N \\ge 5$，网格间距为 $\\Delta x = \\Delta y = \\frac{2}{N-1}$。\n- 根据半轴为 $a$ 和 $b$ 的椭圆初始化 $\\phi(x,y,0)$，使其内部满足 $\\phi \\le 0$。然后，在 $t=0$ 时将其重新初始化为符号距离场。\n- 使用 PDE $\\phi_t + F(x,y)\\lvert \\nabla \\phi \\rvert = 0$、$\\lvert \\nabla \\phi \\rvert$ 的单调迎风 Godunov 离散格式，以及由 CFL 条件决定的稳定时间步长 $\\Delta t$ 的前向欧拉时间积分来演化 $\\phi$。\n- 在时间步进过程中周期性地重新初始化 $\\phi$，以在界面附近维持 $\\lvert \\nabla \\phi \\rvert \\approx 1$。\n- 在最后一个时间步之后，用 4-连通性计算 $\\{\\phi \\le 0\\}$ 的连通分量数量。\n\n测试套件：\n为以下各组参数运行模拟；报告每种情况下最终时刻的内部连通分量数量。\n\n- 情况 A（预期分裂为两个）：$N = 101$, $a = 0.7$, $b = 0.3$, $\\alpha = 1.1$, $\\beta = 0.25$, $s = 0.2$, $\\mathrm{CFL} = 0.5$, 欧拉步数 $= 220$, 每 $\\;5\\;$ 步重新初始化一次。\n- 情况 B（预期保持一个分量）：$N = 101$, $a = 0.7$, $b = 0.3$, $\\alpha = 0.1$, $\\beta = 0.25$, $s = 0.2$, $\\mathrm{CFL} = 0.5$, 欧拉步数 $= 220$, 每 $\\;5\\;$ 步重新初始化一次。\n- 情况 C（临界情况，分裂时间不足）：$N = 101$, $a = 0.7$, $b = 0.3$, $\\alpha = 0.35$, $\\beta = 0.25$, $s = 0.2$, $\\mathrm{CFL} = 0.5$, 欧拉步数 $= 100$, 每 $\\;5\\;$ 步重新初始化一次。\n- 情况 D（强分裂）：$N = 101$, $a = 0.7$, $b = 0.3$, $\\alpha = 1.3$, $\\beta = 0.20$, $s = 0.2$, $\\mathrm{CFL} = 0.5$, 欧拉步数 $= 260$, 每 $\\;5\\;$ 步重新初始化一次。\n\n最终输出规范：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，顺序与上述测试用例相同。每个条目都是一个等于内部连通分量数量的整数。例如，一个有效的输出形式如下\n$\n[\\;n_A, n_B, n_C, n_D\\;]\n$\n其中 $n_A$、$n_B$、$n_C$ 和 $n_D$ 是整数。\n\n约束与说明：\n- 您不得使用任何外部数据或用户输入。\n- 本规范中所有以数学形式出现的变量、函数、运算符和数字均用 LaTeX 书写。\n- 该算法必须从水平集方法、Hamilton–Jacobi 方程、单调迎风离散和 Courant–Friedrichs–Lewy 条件的核心定义推导而来。",
            "solution": "所提出的问题是计算物理学中一个适定的初边值问题，要求使用水平集方法模拟移动界面。该问题具有科学依据，形式明确且客观。它包含了进行数值求解所需的所有必要信息。因此，该问题被认为是有效的。\n\n任务是求解水平集方程，这是一种 Hamilton-Jacobi 偏微分方程 (PDE)：\n$$\n\\phi_t + F(x,y)\\lvert \\nabla \\phi \\rvert = 0\n$$\n函数 $\\phi(x,y,t)$ 是水平集函数，其零等值线 $\\phi=0$ 代表移动界面。$\\phi \\le 0$ 的区域被定义为封闭界面的“内部”。函数 $F(x,y)$ 是界面在其外法线方向上的速度。\n\n求解过程包括在空间和时间上离散化此 PDE，并对初始条件进行演化。\n\n1.  **域和网格离散化**\n    计算域为方形区域 $[-1,1] \\times [-1,1]$。我们引入一个具有 $N \\times N$ 个节点的均匀笛卡尔网格。网格节点 $(x_i, y_j)$ 的坐标由下式给出：\n    $$\n    x_i = -1 + i \\Delta x, \\quad i = 0, \\ldots, N-1\n    $$\n    $$\n    y_j = -1 + j \\Delta y, \\quad j = 0, \\ldots, N-1\n    $$\n    其中网格间距为 $\\Delta x = \\Delta y = \\frac{2}{N-1}$。水平集函数由其在此网格上的值 $\\phi_{i,j}(t) \\approx \\phi(x_i, y_j, t)$ 表示。\n\n2.  **初始条件与重新初始化**\n    初始界面是由 $\\frac{x^2}{a^2} + \\frac{y^2}{b^2} = 1$ 定义的椭圆。初始水平集函数的一个简单选择是 $\\phi(x,y,0) = \\frac{x^2}{a^2} + \\frac{y^2}{b^2} - 1$。\n    为了数值稳定性和准确性，水平集函数理想情况下应为符号距离函数 (signed distance function, SDF)，即满足 $|\\nabla\\phi| = 1$。初始函数不是 SDF。因此，我们必须在 $t=0$ 时以及之后周期性地对其进行重新初始化。\n    重新初始化的执行方式如下：\n    - 创建一个二元掩码，区分内部 ($\\phi \\le 0$) 和外部 ($\\phi  0$)。\n    - 计算每个网格点到相对区域最近点的欧几里得距离。这通过使用快速欧几里得距离变换 (EDT) 算法来完成。\n    - 新的 $\\phi$ 通过为内部点分配负距离、为外部点分配正距离来构建。具体来说，$\\phi_{\\text{new}} = \\text{dist}_{\\text{out}} - \\text{dist}_{\\text{in}}$，其中对于内部点，$\\text{dist}_{\\text{in}}$ 是到外部的距离，而对于外部点，$\\text{dist}_{\\text{out}}$ 是到内部的距离。\n\n3.  **空间离散化：一阶 Godunov 格式**\n    该 PDE 是一个形式为 $\\phi_t + H(\\nabla \\phi) = 0$ 的 Hamilton-Jacobi 方程，其哈密顿量为 $H(\\nabla \\phi) = F(x,y)|\\nabla \\phi|$。此类方程的解可能会出现激波或尖角，需要一种能正确处理信息传播方向（迎风）的数值格式。Godunov 型格式通过使用单调的数值哈密顿量来实现这一点。\n    对于哈密顿量 $H(p,q) = F\\sqrt{p^2+q^2}$（其中 $p=\\phi_x$ 且 $q=\\phi_y$），针对网格函数 $\\phi_{i,j}$ 的 Godunov 数值哈密顿量 $H_{num}$ 具有以下形式：\n    $$\n    H_{num} = F_{i,j}^+ \\sqrt{D_x^{\\text{upw},+}{}^2 + D_y^{\\text{upw},+}{}^2} + F_{i,j}^- \\sqrt{D_x^{\\text{upw},-}{}^2 + D_y^{\\text{upw},-}{}^2}\n    $$\n    其中 $F_{i,j}^+ = \\max(F_{i,j}, 0)$ 且 $F_{i,j}^- = \\min(F_{i,j}, 0)$。项 $D$ 代表迎风梯度的平方范数。\n    - 如果 $F  0$（扩张），信息从内部 ($\\phi0$) 传播到外部 ($\\phi0$)。格式必须向“迎风”方向，即内部，寻找信息。\n    - 如果 $F  0$（收缩），信息从外部传播到内部。格式必须向“迎风”方向，即外部，寻找信息。\n\n    令 $\\phi_x^- = (\\phi_{i,j} - \\phi_{i-1,j})/\\Delta x$ 为后向差分，$\\phi_x^+ = (\\phi_{i+1,j} - \\phi_{i,j})/\\Delta x$ 为前向差分，$y$ 方向同理。Godunov 格式表示为：\n    $$\n    H_{num}(\\phi_{i,j}) = \\max(F_{i,j}, 0) \\sqrt{A} + \\min(F_{i,j}, 0) \\sqrt{B}\n    $$\n    其中\n    $$\n    A = [\\max(\\phi_x^-, 0)]^2 + [\\min(\\phi_x^+, 0)]^2 + [\\max(\\phi_y^-, 0)]^2 + [\\min(\\phi_y^+, 0)]^2\n    $$\n    $$\n    B = [\\max(\\phi_x^+, 0)]^2 + [\\min(\\phi_x^-, 0)]^2 + [\\max(\\phi_y^+, 0)]^2 + [\\min(\\phi_y^-, 0)]^2\n    $$\n    该公式根据局部导数的符号和速度场 $F$ 的符号正确选择差分方向。\n\n4.  **时间离散化与稳定性**\n    我们使用显式前向欧拉格式来在时间上更新解：\n    $$\n    \\frac{\\phi_{i,j}^{n+1} - \\phi_{i,j}^n}{\\Delta t} + H_{num}(\\phi_{i,j}^n) = 0 \\implies \\phi_{i,j}^{n+1} = \\phi_{i,j}^n - \\Delta t \\cdot H_{num}(\\phi_{i,j}^n)\n    $$\n    该格式仅在时间步长 $\\Delta t$ 满足 Courant-Friedrichs-Lewy (CFL) 条件时才是稳定的。对于这个 Hamilton-Jacobi 方程，特征速度是 $\\max_{x,y}|F(x,y)|$。CFL 条件为：\n    $$\n    \\Delta t \\le \\frac{\\min(\\Delta x, \\Delta y)}{\\max\\limits_{x,y}\\lvert F(x,y)\\rvert}\n    $$\n    问题指定使用一个 CFL 数，满足 $0  \\mathrm{CFL} \\le 1$，使得：\n    $$\n    \\Delta t = \\mathrm{CFL} \\times \\frac{\\min(\\Delta x, \\Delta y)}{\\max\\limits_{x,y}\\lvert F(x,y)\\rvert}\n    $$\n\n5.  **边界条件**\n    应用齐次 Neumann 边界条件 $\\frac{\\partial \\phi}{\\partial n} = 0$，其中 $n$ 是计算域边界的外法线。对于一阶格式，这可以通过将域外“虚拟单元”中的值设置为与其相邻的边界单元的值相等来实现。这有效地使跨边界的单边有限差分等于零。在数值上，这是通过在计算空间导数之前用边界值填充 $\\phi$ 网格来实现的。\n\n6.  **拓扑分析**\n    在最后一个时间步之后，确定演化后界面的拓扑结构。这通过分析内部集合 $S = \\{(i,j) | \\phi_{i,j} \\le 0\\}$ 来完成。我们使用标准的标记算法，以 4-连通性（仅考虑上、下、左、右邻居为连通）来计算此集合中连通分量的数量。分配的不同标签的数量对应于独立对象的数量。\n\n实现将针对问题陈述中提供的每个测试用例遵循这些步骤。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import ndimage\n\ndef solve():\n    \"\"\"\n    Main function to run the Level Set Method simulations for the given test cases.\n    \"\"\"\n    test_cases = [\n        # Case A: (N, a, b, alpha, beta, s, CFL, num_steps, reinit_freq)\n        (101, 0.7, 0.3, 1.1, 0.25, 0.2, 0.5, 220, 5),\n        # Case B:\n        (101, 0.7, 0.3, 0.1, 0.25, 0.2, 0.5, 220, 5),\n        # Case C:\n        (101, 0.7, 0.3, 0.35, 0.25, 0.2, 0.5, 100, 5),\n        # Case D:\n        (101, 0.7, 0.3, 1.3, 0.20, 0.2, 0.5, 260, 5),\n    ]\n\n    results = []\n    for params in test_cases:\n        result = run_simulation(*params)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_simulation(N, a, b, alpha, beta, s, CFL, num_steps, reinit_freq):\n    \"\"\"\n    Executes a single LSM simulation for a given set of parameters.\n    \"\"\"\n    # 1. Grid setup\n    domain_size = 2.0\n    dx = domain_size / (N - 1)\n    dy = dx  # Square grid\n    x = np.linspace(-1.0, 1.0, N)\n    y = np.linspace(-1.0, 1.0, N)\n    X, Y = np.meshgrid(x, y)\n\n    # 2. Initial condition: Ellipse\n    phi = (X**2 / a**2) + (Y**2 / b**2) - 1.0\n\n    # 3. Reinitialization to Signed Distance Function (SDF)\n    def reinitialize(p, grid_spacing):\n        mask_in = p = 0\n        dist_in = ndimage.distance_transform_edt(mask_in, sampling=[grid_spacing, grid_spacing])\n        dist_out = ndimage.distance_transform_edt(~mask_in, sampling=[grid_spacing, grid_spacing])\n        return dist_out - dist_in\n    \n    phi = reinitialize(phi, dx)\n    \n    # 4. Speed field F(x,y)\n    F = beta - alpha * np.exp(-(Y**2) / s**2)\n    max_F_abs = np.max(np.abs(F))\n\n    # 5. Time step from CFL condition\n    dt = CFL * dx / max_F_abs\n\n    # 6. Main evolution loop\n    for step in range(num_steps):\n        # Apply Neumann boundary conditions via padding\n        phi_padded = np.pad(phi, pad_width=1, mode='edge')\n\n        # Compute one-sided differences on the interior grid\n        # These correspond to derivatives on the original phi grid\n        phi_x_m = (phi_padded[1:-1, 1:-1] - phi_padded[1:-1, :-2]) / dx\n        phi_x_p = (phi_padded[1:-1, 2:]   - phi_padded[1:-1, 1:-1]) / dx\n        phi_y_m = (phi_padded[1:-1, 1:-1] - phi_padded[:-2, 1:-1]) / dy\n        phi_y_p = (phi_padded[2:,   1:-1] - phi_padded[1:-1, 1:-1]) / dy\n\n        # Godunov numerical Hamiltonian H\n        F_pos = np.maximum(F, 0)\n        F_neg = np.minimum(F, 0)\n        \n        # Gradient term for F > 0 (upwind from interior)\n        grad_norm_sq_up = (np.maximum(phi_x_m, 0)**2 + \n                           np.minimum(phi_x_p, 0)**2 + \n                           np.maximum(phi_y_m, 0)**2 + \n                           np.minimum(phi_y_p, 0)**2)\n        \n        # Gradient term for F  0 (upwind from exterior)\n        grad_norm_sq_down = (np.maximum(phi_x_p, 0)**2 + \n                             np.minimum(phi_x_m, 0)**2 + \n                             np.maximum(phi_y_p, 0)**2 + \n                             np.minimum(phi_y_m, 0)**2)\n\n        H = F_pos * np.sqrt(grad_norm_sq_up) + F_neg * np.sqrt(grad_norm_sq_down)\n\n        # Forward Euler time update\n        phi -= dt * H\n\n        # Periodic reinitialization\n        if (step + 1) % reinit_freq == 0:\n            phi = reinitialize(phi, dx)\n\n    # 7. Topological query: count connected components\n    # The set {phi = 0} represents the interior\n    interior_mask = phi = 0\n    # ndimage.label default structure gives 4-connectivity for 2D\n    _, num_components = ndimage.label(interior_mask)\n    \n    return num_components\n\nsolve()\n```"
        },
        {
            "introduction": "我们最后的实践将探索一个更高级、物理意义更重大的应用：曲率驱动流。在这里，界面的速度 $V_n$ 不再是外部给定的，而是取决于其自身的几何形状，特别是它的曲率 $\\kappa$——这是表面张力等现象背后的驱动力。这个关于液滴合并与消失的模拟  将挑战你实现更复杂的数值微分，并展示水平集方法在模拟拓扑与几何动态协同演化的真实物理系统方面的强大能力。",
            "id": "2408479",
            "problem": "要求您构建、离散化并实现一个二维水平集方法，以模拟代表表面张力作用下流体液滴的移动界面的曲率驱动演化。计算环境是纯数学和无量纲的。您的任务是从核心定义推导出控制方程，提出一个稳定的数值格式，并实现一个完整的、可运行的程序，以解决给定的一组测试用例的问题。目标是证明水平集方法能自然地处理拓扑变化，包括接触后的合并和消失。\n\n从以下基础出发：\n- 在时间 $t$ 的界面是水平集函数 $ \\phi(\\mathbf{x}, t) $ 的零等值线，其中 $ \\mathbf{x} = (x, y) $，内部（流体）区域为 $ \\{ \\mathbf{x} : \\phi(\\mathbf{x}, t)  0 \\} $。界面的外法向单位向量为 $ \\mathbf{n} = \\nabla \\phi / \\lvert \\nabla \\phi \\rvert $。\n- 曲率（在二维中）定义为 $ \\kappa = \\nabla \\cdot \\mathbf{n} $。\n- 在表面张力驱动的运动下，法向速度与曲率成正比并带一个负号，即 $ V_n = - \\sigma \\, \\kappa $，其中 $ \\sigma  0 $ 是一个常数毛细系数。\n\n任务1. 从这些定义出发，推导水平集函数 $ \\phi(\\mathbf{x}, t) $ 的演化方程，该方程遵循沿法线 $ \\mathbf{n} $ 以速度 $ V_n $ 进行的法向运动。仅用 $ \\phi $、$ \\kappa $ 和 $ \\phi $ 的空间导数来表示该方程。然后，用 $ \\phi $ 显式地表示 $ \\kappa $。\n\n任务2. 设计一个稳定且相容的显式有限差分格式，在覆盖单位正方形的均匀笛卡尔网格上求解推导出的演化方程。您的设计约束如下：\n- 在 $ [0,1] \\times [0,1] $ 上使用 $ N \\times N $ 个点的均匀网格，其中 $ N $ 在下面的测试套件中指定。\n- 使用中心差分来近似计算曲率 $ \\kappa $ 所需的空间导数，其中 $ \\kappa $ 为 $ \\phi $ 的归一化梯度的散度。\n- 在哈密顿-雅可比方程 $ \\phi_t + V_n \\lvert \\nabla \\phi \\rvert = 0 $ 的平流项中，使用迎风 Godunov 数值哈密顿量来近似 $ \\lvert \\nabla \\phi \\rvert $。\n- 基于曲率驱动运动的抛物线标度，强制执行 Courant–Friedrichs–Lewy (CFL) 条件。选择一个时间步长 $ \\Delta t $，使其满足形式为 $ \\Delta t \\le C \\, \\min(\\Delta x, \\Delta y)^2 / \\sigma $ 的稳定性限制，其中 $ C $ 是为保证稳定性而选择的无量纲常数。\n- 在单位正方形的所有边界上对 $ \\phi $ 施加齐次诺伊曼边界条件（法向导数为零）。\n- 通过对一个合适的伪时间哈密顿-雅可比方程积分几个伪时间步，周期性地将 $ \\phi $ 重新初始化为有符号距离函数。此过程使用迎风离散化和由当前 $ \\phi $ 构建的正则化符号函数。您必须说明您使用的重新初始化方程及其离散化方法。\n\n任务3. 初始化和测试套件。实现以下初始界面，并运行模拟直到指定的最终时间。所有量均为无量纲。毛细系数为 $ \\sigma = 1 $。网格分辨率为 $ N = 128 $，在 $ [0,1] \\times [0,1] $ 上均匀分布。对于每种情况，将 $ \\phi(\\mathbf{x}, 0) $ 构建为到指定圆盘并集的有符号距离，并集内部的值为负。每个圆盘由其中心 $ (x_c, y_c) $ 和半径 $ R $ 通过欧几里得距离定义。对于两个圆盘的并集，将初始水平集设置为到每个圆盘的有符号距离的逐点最小值。\n- 情况A（重叠双液滴接触后合并）：两个相同的圆盘，中心分别为 $ (0.35, 0.50) $ 和 $ (0.65, 0.50) $，半径 $ R = 0.18 $，最终时间 $ T = 0.006 $。这些圆盘初始重叠，代表两个刚刚接触的液滴；表面张力应将颈部平滑成单个连通的液滴。\n- 情况B（分离的双液滴）：两个相同的圆盘，中心分别为 $ (0.25, 0.50) $ 和 $ (0.75, 0.50) $，半径 $ R = 0.18 $，最终时间 $ T = 0.006 $。圆盘初始不相交；在此时间范围内，没有外力作用下，它们在曲率驱动演化过程中应保持不相交。\n- 情况C（单个小液滴消失）：一个圆盘，中心为 $ (0.50, 0.50) $，半径 $ R = 0.07 $，最终时间 $ T = 0.003 $。在曲率驱动流下，一个足够小的圆应在最终时间之前收缩至消失。\n\n任务4. 后处理和可测量的输出。在每种情况的最终时间，使用网格上的4-连通性计算集合 $ \\{ \\mathbf{x} : \\phi(\\mathbf{x}, T)  0 \\} $ 的连通分量数量。您的程序必须生成单行输出，其中包含三种情况（按A、B、C的顺序）的连通分量数，格式为用方括号括起来的逗号分隔列表，例如 $ [n_A, n_B, n_C] $。输出值必须是整数。\n\n角度单位不适用。所有变量都是无量纲的，因此不需要进行物理单位转换。\n\n您的程序必须是完全自包含、确定性的，并且不得需要任何用户输入。它必须遵守稍后指定的执行环境，并严格按照指定格式产生一行输出。离散化、时间步进、边界条件和重新初始化的设计选择必须与您在任务1中的推导以及上述约束一致，并且必须在程序内的代码注释中进行记录。",
            "solution": "所提出的问题是一个定义明确的计算物理任务，它基于水平集方法的既定原理和曲率驱动界面运动的物理模型。所有参数、条件和目标都以足够的清晰度和严谨性被指定，从而允许一个独特且可验证的解决方案。因此，该问题被认为是有效的，我将着手解决它。\n\n解决方案根据问题陈述中概述的四个任务进行组织。\n\n任务1：控制方程的推导\n\n界面被定义为函数 $ \\phi(\\mathbf{x}, t) $ 的零水平集，其中 $ \\mathbf{x} \\in \\mathbb{R}^2 $。\n对于任何保持在界面上的点 $ \\mathbf{x}(t) $，我们有 $ \\phi(\\mathbf{x}(t), t) = 0 $。使用物质导数对时间 $ t $ 求导，得到：\n$$\n\\frac{d}{dt}\\phi(\\mathbf{x}(t), t) = \\frac{\\partial \\phi}{\\partial t} + \\nabla \\phi \\cdot \\frac{d\\mathbf{x}}{dt} = 0\n$$\n界面上点的速度为 $ \\mathbf{v} = d\\mathbf{x}/dt $。问题指出，界面仅在其法线方向上以指定的法向速度 $ V_n $ 移动。因此，速度向量为 $ \\mathbf{v} = V_n \\mathbf{n} $。将此代入前一个方程得到：\n$$\n\\phi_t + \\nabla \\phi \\cdot (V_n \\mathbf{n}) = 0\n$$\n其中 $ \\phi_t $ 是 $ \\phi $ 关于 $ t $ 的偏导数。外法向单位向量 $ \\mathbf{n} $ 定义为 $ \\mathbf{n} = \\nabla \\phi / |\\nabla \\phi| $。代入此 $ \\mathbf{n} $ 的表达式，得到：\n$$\n\\phi_t + V_n \\nabla \\phi \\cdot \\frac{\\nabla \\phi}{|\\nabla \\phi|} = 0 \\implies \\phi_t + V_n \\frac{|\\nabla \\phi|^2}{|\\nabla \\phi|} = 0\n$$\n这简化为界面以法向速度 $ V_n $ 移动的一般水平集方程：\n$$\n\\phi_t + V_n |\\nabla \\phi| = 0\n$$\n问题指定了曲率驱动运动，其中法向速度与局部曲率 $ \\kappa $ 成正比，由 $ V_n = -\\sigma \\kappa $ 给出。将此代入水平集方程，得到 $ \\phi $ 的演化方程：\n$$\n\\phi_t - \\sigma \\kappa |\\nabla \\phi| = 0\n$$\n这是所要求的演化方程。\n\n接下来，我们用水平集函数 $ \\phi $ 来表示曲率 $ \\kappa $。曲率是单位法向量的散度：$ \\kappa = \\nabla \\cdot \\mathbf{n} $。\n$$\n\\kappa = \\nabla \\cdot \\left( \\frac{\\nabla \\phi}{|\\nabla \\phi|} \\right) = \\nabla \\cdot \\left( \\frac{(\\phi_x, \\phi_y)}{\\sqrt{\\phi_x^2 + \\phi_y^2}} \\right)\n$$\n其中下标表示偏微分。应用散度算子，得到二维曲率的显式表达式：\n$$\n\\kappa = \\frac{\\partial}{\\partial x}\\left(\\frac{\\phi_x}{|\\nabla\\phi|}\\right) + \\frac{\\partial}{\\partial y}\\left(\\frac{\\phi_y}{|\\nabla\\phi|}\\right)\n$$\n使用商法则对微分进行展开，得到：\n$$\n\\kappa = \\frac{\\phi_{xx}\\phi_y^2 - 2\\phi_x\\phi_y\\phi_{xy} + \\phi_{yy}\\phi_x^2}{(\\phi_x^2 + \\phi_y^2)^{3/2}}\n$$\n至此推导完成。\n\n任务2：数值格式的设计\n\n我们将域 $ [0,1] \\times [0,1] $ 离散化为一个 $ N \\times N $ 个点的均匀笛卡尔网格，使得 $ x_i = i h, y_j = j h $，对于 $ i, j = 0, \\dots, N-1 $，网格间距为 $ h = 1/(N-1) $。令 $ \\phi^n_{i,j} $ 表示 $ \\phi(x_i, y_j, n\\Delta t) $ 的数值近似。\n\n演化方程 $ \\phi_t - \\sigma \\kappa |\\nabla \\phi| = 0 $ 使用显式前向欧拉法进行时间推进。该方程被视为一个哈密顿-雅可比方程 $ \\phi_t + V_{ij} |\\nabla\\phi|_{ij} = 0 $，其中有效速度为 $ V_{ij} = -\\sigma\\kappa_{ij} $。按照规定，我们使用混合格式：\n1.  **曲率 $ \\kappa $**：该项涉及二阶导数，并使用中心差分进行计算以保证稳定性。在数值上，将 $ \\kappa $ 计算为法向量场的散度，比直接使用带有二阶导数的完全展开公式更为稳健。\n    首先，我们使用二阶中心差分计算梯度 $ \\nabla\\phi $ 的分量：\n    $$\n    (\\phi_x)_{i,j} \\approx \\frac{\\phi_{i+1,j} - \\phi_{i-1,j}}{2h}, \\quad (\\phi_y)_{i,j} \\approx \\frac{\\phi_{i,j+1} - \\phi_{i,j-1}}{2h}\n    $$\n    然后计算法向量分量 $ (n_x, n_y) $：\n    $$\n    (n_x)_{i,j} = \\frac{(\\phi_x)_{i,j}}{\\sqrt{(\\phi_x)^2_{i,j} + (\\phi_y)^2_{i,j} + \\epsilon^2}}, \\quad (n_y)_{i,j} = \\frac{(\\phi_y)_{i,j}}{\\sqrt{(\\phi_x)^2_{i,j} + (\\phi_y)^2_{i,j} + \\epsilon^2}}\n    $$\n    其中 $ \\epsilon $ 是一个小的正则化参数（例如 $ \\epsilon=h $），以防止除以零。最后，再次使用中心差分将曲率 $ \\kappa $ 计算为法向量场的散度：\n    $$\n    \\kappa_{i,j} = \\frac{(n_x)_{i+1,j} - (n_x)_{i-1,j}}{2h} + \\frac{(n_y)_{i,j+1} - (n_y)_{i,j-1}}{2h}\n    $$\n2.  **平流项 $ V_n |\\nabla \\phi| $**：项 $ |\\nabla \\phi| $ 使用一阶迎风 Godunov 型格式进行离散化。$ \\phi $ 的更新规则是：\n    $$\n    \\frac{\\phi^{n+1}_{i,j} - \\phi^n_{i,j}}{\\Delta t} = - \\left( \\max(V^n_{i,j}, 0)\\nabla^+_{i,j} + \\min(V^n_{i,j}, 0)\\nabla^-_{i,j} \\right)\n    $$\n    其中 $ V^n_{i,j} = -\\sigma \\kappa^n_{i,j} $。迎风梯度模 $ \\nabla^+ $ 和 $ \\nabla^- $ 由下式给出：\n    $$\n    \\nabla^+_{i,j} = \\sqrt{ \\max((D_x^-\\phi)^2, (D_x^+\\phi)^2) + \\max((D_y^-\\phi)^2, (D_y^+\\phi)^2) } (\\text{简化版本})\n    $$\n    一个更标准的 Godunov 格式是：\n    $$\n    \\nabla^+_{i,j} = \\left[ \\max(D_x^-\\phi, 0)^2 + \\min(D_x^+\\phi, 0)^2 + \\max(D_y^-\\phi, 0)^2 + \\min(D_y^+\\phi, 0)^2 \\right]^{1/2}\n    $$\n    $$\n    \\nabla^-_{i,j} = \\left[ \\max(D_x^+\\phi, 0)^2 + \\min(D_x^-\\phi, 0)^2 + \\max(D_y^+\\phi, 0)^2 + \\min(D_y^-\\phi, 0)^2 \\right]^{1/2}\n    $$\n    其中 $ D_x^\\pm, D_y^\\pm $ 是标准的一阶前向和后向有限差分。例如，$ D_x^+\\phi_{i,j} = (\\phi_{i+1,j} - \\phi_{i,j})/h $。\n3.  **边界条件**：齐次诺伊曼条件 ($ \\partial\\phi/\\partial\\mathbf{n}_{\\text{bdy}} = 0 $) 使用鬼点来实施。对于边界点（例如 $ i=0 $）的中心差分模板，设置鬼点值以强制满足该条件。对于 $ (\\phi_x)_{0,j} = (\\phi_{1,j} - \\phi_{-1,j})/(2h) = 0 $，我们设置 $ \\phi_{-1,j} = \\phi_{1,j} $。\n4.  **时间步长**：平均曲率运动是一个刚性的类抛物线问题。显式格式要求一个严格的时间步长约束以保证稳定性，该约束与网格间距的平方成比例：\n    $$\n    \\Delta t \\le C \\frac{h^2}{\\sigma}\n    $$\n    其中 $ h = \\min(\\Delta x, \\Delta y) $。选择一个保守的稳定性常数 $ C=0.2 $。\n5.  **重新初始化**：水平集函数可能随时间变得扭曲。为了维持其有符号距离属性 ($ |\\nabla\\phi|=1 $)，需要周期性地对其进行重新初始化。这是通过在伪时间 $ \\tau $ 中求解以下哈密顿-雅可比方程至稳态来完成的：\n    $$\n    \\phi_{\\tau} + \\text{sgn}(\\phi_0) (|\\nabla \\phi| - 1) = 0\n    $$\n    其中 $ \\phi_0 $ 是重新初始化前的水平集函数。符号函数被正则化为 $ \\text{sgn}(\\phi_0) \\approx \\phi_0 / \\sqrt{\\phi_0^2 + h^2} $。该方程使用前向欧拉法和与主演化中相同的 $ |\\nabla\\phi| $ 迎风格式进行求解，伪时间步长 $ \\Delta \\tau $ 满足其自身的 CFL 条件，$ \\Delta\\tau \\le h $。\n\n任务3和4：实现、测试用例和后处理\n\n上述数值格式使用 Python 的 `numpy` 和 `scipy` 库实现。每个测试用例的初始条件是通过将 $ \\phi(\\mathbf{x}, 0) $ 定义为到指定几何形状的有符号距离来构建的。模拟运行指定的时长。在最终时间 $ T $，识别出 $ \\phi(\\mathbf{x}, T)  0 $ 的点集。此集合内的连通分量数量是使用 `scipy.ndimage` 中的标记算法和 $ 4 $-连通性来确定的。\n\n- 情况A（重叠）：两个初始圆盘重叠，形成单个连通区域。曲率驱动的流将平滑它们之间的“颈部”，使形状变得更紧凑和椭圆化。连通分量的数量预计始终为 $ 1 $。\n- 情况B（分离）：两个圆盘初始是分离的。在曲率流的作用下，两者都将在原地收缩。由于它们相距足够远，在给定时间内不会合并。连通分量的数量预计保持为 $ 2 $。\n- 情况C（消失）：一个小的圆形液滴在曲率作用下收缩。在平均曲率流下演化的圆的半径的解析解是 $ R(t) = \\sqrt{R_0^2 - 2\\sigma t} $。对于 $ R_0=0.07 $ 和 $ \\sigma=1 $，消失时间为 $ t_{\\text{ext}} = R_0^2/(2\\sigma) = 0.07^2/2 = 0.00245 $。由于最终时间 $ T=0.003 $ 大于 $ t_{\\text{ext}} $，液滴预计将完全消失。连通分量的数量将为 $ 0 $。\n\n基于此分析，预期输出为列表 `[1, 2, 0]`。下面的实现将对此进行数值验证。",
            "answer": "```python\nimport numpy as np\nfrom scipy.ndimage import label\n\ndef solve():\n    \"\"\"\n    Solves the curvature-driven flow problem using the level set method.\n    \"\"\"\n\n    # --- Simulation parameters ---\n    N = 128  # Grid resolution\n    SIGMA = 1.0  # Capillary coefficient\n    DOMAIN_SIZE = 1.0\n    CFL_C = 0.2  # CFL constant for main evolution\n    REINIT_FREQ = 25  # Reinitialization frequency (in time steps)\n    REINIT_STEPS = 5  # Number of pseudo-time steps for reinitialization\n\n    # --- Grid setup ---\n    h = DOMAIN_SIZE / (N - 1)\n    x = np.linspace(0, DOMAIN_SIZE, N)\n    y = np.linspace(0, DOMAIN_SIZE, N)\n    xx, yy = np.meshgrid(x, y, indexing='ij')\n    \n    # --- Time step calculation ---\n    # Parabolic scaling for curvature flow: dt ~ h^2\n    dt = CFL_C * h**2 / SIGMA\n\n    # --- Test cases as defined in the problem ---\n    test_cases = [\n        {\n            'name': 'A',\n            'T_final': 0.006,\n            'shapes': [\n                {'type': 'disk', 'center': (0.35, 0.50), 'radius': 0.18},\n                {'type': 'disk', 'center': (0.65, 0.50), 'radius': 0.18}\n            ]\n        },\n        {\n            'name': 'B',\n            'T_final': 0.006,\n            'shapes': [\n                {'type': 'disk', 'center': (0.25, 0.50), 'radius': 0.18},\n                {'type': 'disk', 'center': (0.75, 0.50), 'radius': 0.18}\n            ]\n        },\n        {\n            'name': 'C',\n            'T_final': 0.003,\n            'shapes': [\n                {'type': 'disk', 'center': (0.50, 0.50), 'radius': 0.07}\n            ]\n        }\n    ]\n\n    results = []\n\n    # --- Helper functions for numerical scheme ---\n\n    def apply_neumann(phi_grid):\n        \"\"\"Applies homogeneous Neumann boundary conditions using ghost cells.\"\"\"\n        # This implementation reflects values across the boundary, which is\n        # equivalent to setting the normal derivative to zero for a central\n        # difference scheme. phi[-1] = phi[1], phi[N] = phi[N-2]\n        padded = np.pad(phi_grid, 1, mode='symmetric')\n        return padded\n\n    def reinitialize(phi):\n        \"\"\"\n        Reinitializes the level set function phi to be a signed distance function.\n        Solves phi_tau + sgn(phi_0) * ( |grad(phi)| - 1 ) = 0.\n        \"\"\"\n        phi_0 = phi.copy()\n        # Regularized sign function\n        sign = phi_0 / np.sqrt(phi_0**2 + h**2)\n        \n        # CFL for reinitialization (hyperbolic)\n        dt_reinit = 0.5 * h\n        \n        phi_reinit = phi.copy()\n\n        for _ in range(REINIT_STEPS):\n            padded_phi = apply_neumann(phi_reinit)\n            \n            # First-order upwind/downwind stencils\n            dx_p = (padded_phi[2:, 1:-1] - padded_phi[1:-1, 1:-1]) / h\n            dx_m = (padded_phi[1:-1, 1:-1] - padded_phi[:-2, 1:-1]) / h\n            dy_p = (padded_phi[1:-1, 2:] - padded_phi[1:-1, 1:-1]) / h\n            dy_m = (padded_phi[1:-1, 1:-1] - padded_phi[1:-1, :-2]) / h\n\n            # Godunov scheme for gradient magnitude\n            grad_norm_p = np.sqrt(np.maximum(dx_m, 0)**2 + np.minimum(dx_p, 0)**2 +\n                                  np.maximum(dy_m, 0)**2 + np.minimum(dy_p, 0)**2)\n            grad_norm_m = np.sqrt(np.maximum(dx_p, 0)**2 + np.minimum(dx_m, 0)**2 +\n                                  np.maximum(dy_p, 0)**2 + np.minimum(dy_m, 0)**2)\n\n            # Update based on sign\n            update = - (np.maximum(sign, 0) * (grad_norm_p - 1) + \n                        np.minimum(sign, 0) * (grad_norm_m - 1))\n            \n            phi_reinit += dt_reinit * update\n\n        return phi_reinit\n\n    for case in test_cases:\n        # --- Initialization ---\n        phi_list = []\n        for shape in case['shapes']:\n            if shape['type'] == 'disk':\n                xc, yc = shape['center']\n                R = shape['radius']\n                phi_disk = np.sqrt((xx - xc)**2 + (yy - yc)**2) - R\n                phi_list.append(phi_disk)\n        \n        # For multiple shapes, the initial phi is the minimum of individual signed distances\n        phi = np.min(np.array(phi_list), axis=0) if len(phi_list) > 1 else phi_list[0]\n        \n        # --- Time evolution loop ---\n        t = 0.0\n        step_count = 0\n        while t  case['T_final']:\n            # Reinitialize periodically\n            if step_count % REINIT_FREQ == 0:\n                phi = reinitialize(phi)\n\n            padded_phi = apply_neumann(phi)\n\n            # --- Calculate curvature k ---\n            # Central differences for gradient\n            phi_x = (padded_phi[2:, 1:-1] - padded_phi[:-2, 1:-1]) / (2 * h)\n            phi_y = (padded_phi[1:-1, 2:] - padded_phi[1:-1, :-2]) / (2 * h)\n            \n            # Regularized gradient magnitude\n            magn_grad = np.sqrt(phi_x**2 + phi_y**2 + h**2)\n\n            # Normal vector field\n            nx = phi_x / magn_grad\n            ny = phi_y / magn_grad\n            \n            padded_nx = apply_neumann(nx)\n            padded_ny = apply_neumann(ny)\n\n            # Divergence of the normal field (curvature)\n            nx_x = (padded_nx[2:, 1:-1] - padded_nx[:-2, 1:-1]) / (2 * h)\n            ny_y = (padded_ny[1:-1, 2:] - padded_ny[1:-1, :-2]) / (2 * h)\n            kappa = nx_x + ny_y\n\n            # --- Calculate upwind gradient norms for the advection term ---\n            # Using the main phi grid for this\n            dx_p = (padded_phi[2:, 1:-1] - padded_phi[1:-1, 1:-1]) / h\n            dx_m = (padded_phi[1:-1, 1:-1] - padded_phi[:-2, 1:-1]) / h\n            dy_p = (padded_phi[1:-1, 2:] - padded_phi[1:-1, 1:-1]) / h\n            dy_m = (padded_phi[1:-1, 1:-1] - padded_phi[1:-1, :-2]) / h\n\n            grad_norm_p = np.sqrt(np.maximum(dx_m, 0)**2 + np.minimum(dx_p, 0)**2 +\n                                  np.maximum(dy_m, 0)**2 + np.minimum(dy_p, 0)**2)\n            grad_norm_m = np.sqrt(np.maximum(dx_p, 0)**2 + np.minimum(dx_m, 0)**2 +\n                                  np.maximum(dy_p, 0)**2 + np.minimum(dy_m, 0)**2)\n\n            # --- Update phi ---\n            # Effective velocity for Hamilton-Jacobi formulation\n            V = -SIGMA * kappa\n            \n            # The problem is phi_t + V * |nabla phi| = 0\n            # Update is phi_new = phi_old - dt * (V * |nabla phi|)\n            update_term = - (np.maximum(V, 0) * grad_norm_p + np.minimum(V, 0) * grad_norm_m)\n\n            phi += dt * update_term\n\n            t += dt\n            step_count += 1\n            \n        # --- Post-processing: Count connected components ---\n        mask = phi  0\n        # 4-connectivity structure\n        structure = np.array([[0, 1, 0], [1, 1, 1], [0, 1, 0]])\n        _, num_components = label(mask, structure=structure)\n        results.append(num_components)\n\n    # --- Final Output ---\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}