{
    "hands_on_practices": [
        {
            "introduction": "在量化不确定性的旅程中，我们首先从一个基础问题开始。本练习将探讨一个经典的物理模型——单摆，分析其长度 $L$ 和当地重力加速度 $g$ 的不确定性如何传递到对周期的计算中。通过这个练习，你将实践不确定性传播的基本方法，即基于泰勒级数展开的一阶近似法，这是许多分析误差研究的基石。",
            "id": "2448343",
            "problem": "编写一个完整的程序，对于一个理想的小角度单摆，当摆长和当地重力加速度联合不确定且相关时，量化其振荡周期的不确定性。周期由映射 $T:\\mathbb{R}_{>0}^{2}\\to\\mathbb{R}_{>0}$ 建模，定义为 $T(L,g)=2\\pi\\sqrt{L/g}$。假设输入向量 $(L,g)$ 服从联合正态分布，其均值向量为 $(\\mu_L,\\mu_g)$，标准差为 $(\\sigma_L,\\sigma_g)$，相关系数为 $\\rho\\in[-1,1]$。对于每组参数，通过将 $T$ 在 $(\\mu_L,\\mu_g)$ 附近线性化，确定平均周期的一阶近似值及其相应的一阶标准差。所有周期值和标准差均以秒为单位表示，并四舍五入到6位小数。\n\n使用以下测试套件，其中 $L$ 的单位是米，$g$ 的单位是米每平方秒，每个元组为 $(\\mu_L,\\sigma_L,\\mu_g,\\sigma_g,\\rho)$：\n- 测试 $1$：$(1.000,0.005,9.80665,0.020,0.000)$。\n- 测试 $2$：$(2.000,0.010,9.81000,0.050,0.900)$。\n- 测试 $3$：$(0.500,0.002,9.78000,0.030,-0.900)$。\n- 测试 $4$：$(1.500,0.000001,9.81000,0.000001,0.000)$。\n\n你的程序应该生成单行输出，包含一个用方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果本身必须是一个双元素列表，包含近似的平均周期和相应的一阶标准差，两者均以秒为单位并四舍五入到6位小数。例如，整体输出格式必须为 $[[\\mu_{T,1},\\sigma_{T,1}],[\\mu_{T,2},\\sigma_{T,2}],[\\mu_{T,3},\\sigma_{T,3}],[\\mu_{T,4},\\sigma_{T,4}]]$，不得包含任何额外文本。",
            "solution": "问题陈述已经过严格验证，并被认为是科学上合理、良定且客观的。它为使用既定的物理学和统计学原理进行不确定性量化提供了一个完整且一致的框架。因此，我们可以着手求解。\n\n该问题要求量化单摆周期 $T$ 的不确定性，其中 $T$ 是摆长 $L$ 和当地重力加速度 $g$ 的非线性函数。该映射由下式给出：\n$$\nT(L, g) = 2\\pi\\sqrt{\\frac{L}{g}}\n$$\n输入参数 $(L, g)$ 被视为一个二元随机变量，服从联合正态分布，其均值向量为 $\\boldsymbol{\\mu} = (\\mu_L, \\mu_g)^T$，协方差矩阵为 $\\Sigma$。协方差矩阵由标准差 $\\sigma_L$ 和 $\\sigma_g$ 以及相关系数 $\\rho$ 定义：\n$$\n\\Sigma = \\begin{pmatrix} \\sigma_L^2  \\rho \\sigma_L \\sigma_g \\\\ \\rho \\sigma_L \\sigma_g  \\sigma_g^2 \\end{pmatrix}\n$$\n我们的任务是找到周期 $T$ 的均值 $\\mu_T$ 和标准差 $\\sigma_T$ 的一阶近似值。这可以通过应用不确定性传播定律来实现，该定律基于函数 $T(L, g)$ 在均值 $(\\mu_L, \\mu_g)$ 附近的一阶泰勒级数展开。\n\n首先，输出均值 $\\mu_T$ 的一阶近似值就是将函数在输入的均值处进行求值。这是期望值泰勒展开中的零阶项。在这种一阶方法中，涉及函数Hessian矩阵的高阶项被忽略。\n$$\n\\mu_T \\approx T(\\mu_L, \\mu_g) = 2\\pi\\sqrt{\\frac{\\mu_L}{\\mu_g}}\n$$\n让我们将这个在均值处的求值表示为 $T_0 = T(\\mu_L, \\mu_g)$。\n\n接下来，我们确定输出方差 $\\sigma_T^2$ 的一阶近似值。对于一个一般函数 $Y = f(X_1, X_2)$，其方差由下式给出：\n$$\n\\sigma_Y^2 \\approx \\left(\\frac{\\partial f}{\\partial X_1}\\right)^2 \\sigma_{X_1}^2 + \\left(\\frac{\\partial f}{\\partial X_2}\\right)^2 \\sigma_{X_2}^2 + 2 \\left(\\frac{\\partial f}{\\partial X_1}\\right) \\left(\\frac{\\partial f}{\\partial X_2}\\right) \\text{Cov}(X_1, X_2)\n$$\n其中偏导数是在均值 $(\\mu_{X_1}, \\mu_{X_2})$ 处计算的。\n\n对于我们的特定函数 $T(L, g) = 2\\pi L^{1/2} g^{-1/2}$，我们必须计算关于 $L$ 和 $g$ 的偏导数。\n关于 $L$ 的偏导数是：\n$$\n\\frac{\\partial T}{\\partial L} = 2\\pi \\left(\\frac{1}{2} L^{-1/2} g^{-1/2}\\right) = \\pi \\frac{1}{\\sqrt{Lg}}\n$$\n关于 $g$ 的偏导数是：\n$$\n\\frac{\\partial T}{\\partial g} = 2\\pi L^{1/2} \\left(-\\frac{1}{2} g^{-3/2}\\right) = -\\pi \\frac{\\sqrt{L}}{g\\sqrt{g}} = -\\pi \\frac{\\sqrt{L}}{\\sqrt{g^3}}\n$$\n在均值点 $(\\mu_L, \\mu_g)$ 处计算这些导数，可以通过将它们与 $T_0$ 关联来简化：\n$$\n\\left. \\frac{\\partial T}{\\partial L} \\right|_{(\\mu_L, \\mu_g)} = \\pi \\frac{1}{\\sqrt{\\mu_L \\mu_g}} = \\left(2\\pi\\sqrt{\\frac{\\mu_L}{\\mu_g}}\\right) \\left(\\frac{1}{2\\mu_L}\\right) = \\frac{T_0}{2\\mu_L}\n$$\n$$\n\\left. \\frac{\\partial T}{\\partial g} \\right|_{(\\mu_L, \\mu_g)} = -\\pi \\frac{\\sqrt{\\mu_L}}{\\sqrt{\\mu_g^3}} = \\left(2\\pi\\sqrt{\\frac{\\mu_L}{\\mu_g}}\\right) \\left(-\\frac{1}{2\\mu_g}\\right) = -\\frac{T_0}{2\\mu_g}\n$$\n现在，将这些灵敏度系数代入方差传播公式。协方差项为 $\\text{Cov}(L, g) = \\rho\\sigma_L\\sigma_g$。\n$$\n\\sigma_T^2 \\approx \\left(\\frac{T_0}{2\\mu_L}\\right)^2 \\sigma_L^2 + \\left(-\\frac{T_0}{2\\mu_g}\\right)^2 \\sigma_g^2 + 2\\left(\\frac{T_0}{2\\mu_L}\\right)\\left(-\\frac{T_0}{2\\mu_g}\\right)(\\rho\\sigma_L\\sigma_g)\n$$\n提取公因式后得到：\n$$\n\\sigma_T^2 \\approx \\frac{T_0^2}{4} \\left[ \\frac{\\sigma_L^2}{\\mu_L^2} + \\frac{\\sigma_g^2}{\\mu_g^2} - 2\\rho\\frac{\\sigma_L\\sigma_g}{\\mu_L\\mu_g} \\right]\n$$\n这个表达式可以使用相对标准差（变异系数）$c_L = \\sigma_L/\\mu_L$ 和 $c_g = \\sigma_g/\\mu_g$ 更简洁地写出：\n$$\n\\sigma_T^2 \\approx \\frac{T_0^2}{4} \\left[ c_L^2 + c_g^2 - 2\\rho c_L c_g \\right]\n$$\n一阶标准差 $\\sigma_T$ 是方差的平方根：\n$$\n\\sigma_T \\approx \\sqrt{\\sigma_T^2} = \\frac{T_0}{2} \\sqrt{ \\left(\\frac{\\sigma_L}{\\mu_L}\\right)^2 + \\left(\\frac{\\sigma_g}{\\mu_g}\\right)^2 - 2\\rho \\left(\\frac{\\sigma_L}{\\mu_L}\\right) \\left(\\frac{\\sigma_g}{\\mu_g}\\right) }\n$$\n这个最终公式提供了所需的振荡周期的一阶标准差。实现算法如下：\n$1$. 对于每个测试用例 $(\\mu_L, \\sigma_L, \\mu_g, \\sigma_g, \\rho)$，首先计算近似平均周期 $T_0 = 2\\pi\\sqrt{\\mu_L/\\mu_g}$。\n$2$. 计算 $L$ 和 $g$ 的相对标准差。\n$3$. 将这些值代入推导出的 $\\sigma_T$ 公式中。\n$4$. 将 $T_0$ 和 $\\sigma_T$ 都四舍五入到指定的6位小数。\n将对所有提供的测试用例实施此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes first-order approximations for the mean and standard deviation\n    of a pendulum's period given uncertain inputs.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each tuple is (mu_L, sigma_L, mu_g, sigma_g, rho).\n    test_cases = [\n        (1.000, 0.005, 9.80665, 0.020, 0.000),\n        (2.000, 0.010, 9.81000, 0.050, 0.900),\n        (0.500, 0.002, 9.78000, 0.030, -0.900),\n        (1.500, 0.000001, 9.81000, 0.000001, 0.000),\n    ]\n\n    results = []\n    for case in test_cases:\n        mu_L, sigma_L, mu_g, sigma_g, rho = case\n\n        # Step 1: Calculate the first-order approximation for the mean period (T_0)\n        # mu_T is approximated by T(mu_L, mu_g)\n        mu_T = 2 * np.pi * np.sqrt(mu_L / mu_g)\n\n        # Step 2: Calculate the first-order standard deviation of the period\n        # Formula derived from first-order Taylor expansion (propagation of uncertainty)\n        # sigma_T = (T_0 / 2) * sqrt( (sigma_L/mu_L)^2 + (sigma_g/mu_g)^2 - 2*rho*(sigma_L/mu_L)*(sigma_g/mu_g) )\n        \n        # Avoid division by zero, though problem constraints ensure mu_L and mu_g > 0\n        if mu_L == 0 or mu_g == 0:\n            # This case is not expected based on the problem description\n            sigma_T = float('inf')\n        else:\n            rel_std_L = sigma_L / mu_L\n            rel_std_g = sigma_g / mu_g\n            \n            variance_term = (rel_std_L**2) + (rel_std_g**2) - (2 * rho * rel_std_L * rel_std_g)\n            \n            # The term inside sqrt must be non-negative.\n            # It represents the variance of a linear combination of correlated variables\n            # and is guaranteed to be non-negative.\n            if variance_term  0:\n                # This could happen due to floating point inaccuracies, clamp to 0\n                variance_term = 0\n\n            sigma_T = (mu_T / 2) * np.sqrt(variance_term)\n\n        # Step 3: Round results to 6 decimal places\n        mu_T_rounded = round(mu_T, 6)\n        sigma_T_rounded = round(sigma_T, 6)\n        \n        results.append([mu_T_rounded, sigma_T_rounded])\n\n    # Final print statement in the exact required format.\n    # Convert the list of lists to the specified string format\n    # e.g., [[val1, val2],[val3, val4]]\n    result_str = \",\".join(map(str, results))\n    print(f\"[{result_str}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "虽然线性化方法在许多情况下很有效，但它本质上是一种局部近似，对于复杂的非线性模型可能无法捕捉全局影响。本练习引入了一种更强大的计算技术——基于方差的全局敏感性分析，以确定哪些不确定性输入对模型输出的影响最大。我们将对一个实际的多相流问题应用蒙特卡洛模拟，量化并比较不同不确定性来源对压降预测的贡献。",
            "id": "2448383",
            "problem": "一个水平、等温、稳定、不可压缩、充分发展的两种不互溶牛顿流体在圆形管道中的流动，通过均相混合物近似进行建模。设流体 $1$ 的密度为 $\\rho_1$，动力粘度为 $\\mu_1$；流体 $2$ 的密度为 $\\rho_2$，动力粘度为 $\\mu_2$。管道长度为 $L$，直径为 $D$，内部绝对粗糙度均匀，为 $\\varepsilon$。体积流量为 $Q$，流体 $1$ 的体积分数为 $\\phi \\in [0,1]$（因此流体 $2$ 的体积分数为 $1-\\phi$）。重力和加速度效应被忽略。目标是对于给定的参数集和不确定性，量化分析是粘度的不确定性还是粗糙度的不确定性对压降不确定性的贡献更大。\n\n使用的模型定义：\n- 混合物密度：$\\rho_m = \\phi \\,\\rho_1 + (1-\\phi)\\,\\rho_2$。\n- 混合物动力粘度（线性体积混合）：$\\mu_m = \\phi \\,\\mu_1 + (1-\\phi)\\,\\mu_2$。\n- 平均速度：$U_m = \\dfrac{4Q}{\\pi D^2}$。\n- 雷诺数：$\\mathrm{Re} = \\dfrac{\\rho_m U_m D}{\\mu_m}$。\n- 达西-魏斯巴赫摩擦系数 $f$：\n  - 层流区：如果 $\\mathrm{Re}  2300$，则 $f = \\dfrac{64}{\\mathrm{Re}}$。\n  - 湍流区：如果 $\\mathrm{Re} \\ge 2300$，使用 Haaland 相关式\n    $$\\frac{1}{\\sqrt{f}} = -1.8 \\log_{10}\\!\\left[\\left(\\frac{\\varepsilon/D}{3.7}\\right)^{1.11} + \\frac{6.9}{\\mathrm{Re}}\\right].$$\n- 压降：$$\\Delta P = f \\,\\frac{L}{D}\\,\\frac{\\rho_m U_m^2}{2}.$$\n\n不确定性输入：\n- $\\mu_1 \\sim \\text{Uniform}([0.02,\\,0.10])$，单位为 $\\mathrm{Pa\\cdot s}$。\n- $\\mu_2 \\sim \\text{Uniform}([0.0008,\\,0.0015])$，单位为 $\\mathrm{Pa\\cdot s}$。\n- $\\varepsilon \\sim \\text{Uniform}([10^{-5},\\,10^{-3}])$，单位为 $\\mathrm{m}$。\n假设 $\\mu_1$、$\\mu_2$ 和 $\\varepsilon$ 是相互独立的。\n\n所有其他参数都是确定性的，并在下文的每个测试用例中指定。热物理性质固定为 $\\rho_1 = 850\\,\\mathrm{kg/m^3}$ 和 $\\rho_2 = 1000\\,\\mathrm{kg/m^3}$。\n\n待比较的灵敏度量：\n- 令 $Y = \\Delta P(\\mu_1,\\mu_2,\\varepsilon)$ 为模型计算的压降。对于输入子集 $S$，定义一阶方差贡献\n  $$C_S = \\frac{\\mathrm{Var}\\!\\left(\\mathbb{E}[Y \\mid S]\\right)}{\\mathrm{Var}(Y)},$$\n  其中方差和期望是关于 $(\\mu_1,\\mu_2,\\varepsilon)$ 的联合分布计算的。\n- 定义 $C_{\\text{visc}}$（其中 $S = \\{\\mu_1,\\mu_2\\}$）和 $C_{\\text{rough}}$（其中 $S = \\{\\varepsilon\\}$）。\n\n任务：\n对于每个测试用例，计算 $C_{\\text{visc}}$ 和 $C_{\\text{rough}}$，并返回一个布尔值，指示 $C_{\\text{visc}} > C_{\\text{rough}}$ 是否成立。\n\n测试套件（所有量都必须使用国际单位制）：\n- 用例 1：$L=100$ $\\mathrm{m}$，$D=0.05$ $\\mathrm{m}$，$Q=0.002$ $\\mathrm{m^3/s}$，$\\phi=0.5$。\n- 用例 2：$L=150$ $\\mathrm{m}$，$D=0.15$ $\\mathrm{m}$，$Q=0.03$ $\\mathrm{m^3/s}$，$\\phi=0.5$。\n- 用例 3：$L=200$ $\\mathrm{m}$，$D=0.20$ $\\mathrm{m}$，$Q=0.12$ $\\mathrm{m^3/s}$，$\\phi=0.2$。\n- 用例 4：$L=80$ $\\mathrm{m}$，$D=0.04$ $\\mathrm{m}$，$Q=0.0004$ $\\mathrm{m^3/s}$，$\\phi=0.8$。\n\n要求的最终输出格式：\n您的程序应生成单行输出，其中包含一个由方括号括起来的布尔值逗号分隔列表，且不含空格。如果第 $i$ 个测试用例满足 $C_{\\text{visc}} > C_{\\text{rough}}$，则第 $i$ 个条目必须为 True，否则为 False。例如，一个有效的输出格式是“[True,False,True,False]”。",
            "solution": "问题陈述已经过验证，并被认定为有效。它在科学上基于流体力学和不确定性量化的既定原则，问题提法适定、规格完整且客观。所有模型、参数和分布都已明确定义，从而允许一个唯一且可验证的数值解。因此，我将继续提供完整解答。\n\n该问题要求比较粘度参数 $(\\mu_1, \\mu_2)$ 和管道粗糙度参数 $(\\varepsilon)$ 对计算所得压降 $\\Delta P$ 总不确定性的贡献。这是一个基于方差的全局灵敏度分析问题。待比较的量 $C_{\\text{visc}}$ 和 $C_{\\text{rough}}$ 分别是粘度参数组 $S_{\\text{visc}} = \\{\\mu_1, \\mu_2\\}$ 和粗糙度参数 $S_{\\text{rough}} = \\{\\varepsilon\\}$ 的一阶 Sobol' 指数。\n\n压降模型 $Y = \\Delta P(\\mu_1, \\mu_2, \\varepsilon)$ 是其输入的非线性函数，涉及层流和湍流区之间的条件切换，以及湍流摩擦系数的隐式非线性相关式（Haaland 方程）。直接通过解析积分来计算所需的方差和条件期望是不可行的。因此，数值蒙特卡洛（MC）方法是合适的工具。\n\n任务的核心是计算条件期望的方差 $V_S = \\mathrm{Var}(\\mathbb{E}[Y \\mid S])$，针对两组输入参数 $S = S_{\\text{visc}}$ 和 $S = S_{\\text{rough}}$。比较 $C_{\\text{visc}} > C_{\\text{rough}}$ 等同于比较分子 $V_{\\text{visc}} > V_{\\text{rough}}$，因为它们共享相同的分母，即总方差 $\\mathrm{Var}(Y)$。\n\n我们将采用一个稳健且高效的蒙特卡洛估计器来计算 $V_S$。步骤如下：\n1.  生成两个独立的 $N \\times 3$ 随机样本矩阵 $\\mathbf{A}$ 和 $\\mathbf{B}$，其中每一行都是从其指定的均匀分布中抽取的 $(\\mu_1, \\mu_2, \\varepsilon)$ 的一个样本。$N$ 是样本数量，选择足够大的值以确保收敛（例如，$N=2^{18}$）。\n2.  对矩阵 $\\mathbf{A}$ 中的样本评估正向模型 $\\Delta P = \\text{model}(\\mu_1, \\mu_2, \\varepsilon)$，得到输出向量 $\\mathbf{Y}_A$。该向量的均值 $\\hat{\\mathbb{E}}[Y] = \\frac{1}{N}\\sum_{j=1}^N \\mathbf{Y}_{A,j}$ 提供了压降期望值的估计。我们将此估计值的平方表示为 $f_0^2$。\n3.  为了估计 $V_{\\text{rough}} = \\mathrm{Var}(\\mathbb{E}[Y \\mid \\varepsilon])$，我们构建第三个矩阵 $\\mathbf{C}_{\\text{rough}}$，其 $\\mu_1$ 和 $\\mu_2$ 列取自矩阵 $\\mathbf{B}$，而 $\\varepsilon$ 列取自矩阵 $\\mathbf{A}$。\n4.  对 $\\mathbf{C}_{\\text{rough}}$ 进行模型评估以获得输出向量 $\\mathbf{Y}_{C_{\\text{rough}}}$。然后，方差估计如下：\n    $$V_{\\text{rough}} \\approx \\frac{1}{N} \\sum_{j=1}^N \\mathbf{Y}_{A,j} \\cdot \\mathbf{Y}_{C_{\\text{rough}},j} - f_0^2$$\n    当 $N \\to \\infty$ 时，此估计器收敛于 $\\mathrm{Var}(\\mathbb{E}[Y \\mid \\varepsilon])$。\n5.  为了估计 $V_{\\text{visc}} = \\mathrm{Var}(\\mathbb{E}[Y \\mid \\mu_1, \\mu_2])$，我们构建第四个矩阵 $\\mathbf{C}_{\\text{visc}}$，其 $\\mu_1$ 和 $\\mu_2$ 列取自矩阵 $\\mathbf{A}$，而 $\\varepsilon$ 列取自矩阵 $\\mathbf{B}$。\n6.  对 $\\mathbf{C}_{\\text{visc}}$ 进行模型评估以获得 $\\mathbf{Y}_{C_{\\text{visc}}}$。然后，方差估计如下：\n    $$V_{\\text{visc}} \\approx \\frac{1}{N} \\sum_{j=1}^N \\mathbf{Y}_{A,j} \\cdot \\mathbf{Y}_{C_{\\text{visc}},j} - f_0^2$$\n    此估计器收敛于 $\\mathrm{Var}(\\mathbb{E}[Y \\mid \\mu_1, \\mu_2])$。\n7.  对于每个测试用例，我们计算 $V_{\\text{visc}}$ 和 $V_{\\text{rough}}$ 并判断是否 $V_{\\text{visc}} > V_{\\text{rough}}$。\n\n正向模型实现 $\\Delta P(\\mu_1, \\mu_2, \\varepsilon)$ 是使用 NumPy 构建的向量化函数，以提高计算效率。它首先计算混合物性质（$\\rho_m, \\mu_m$）和雷诺数（$\\mathrm{Re}$）。对 $\\mathrm{Re}$ 的条件检查将流动分为层流（$\\mathrm{Re}  2300$）和湍流（$\\mathrm{Re} \\ge 2300$）区。相应地计算达西摩擦系数 $f$。对于湍流区，Haaland 相关式以可显式求解 $f$ 的形式给出，避免了迭代数值求根过程：\n$$f = \\left(\\frac{1}{-1.8 \\log_{10}\\!\\left[\\left(\\frac{\\varepsilon/D}{3.7}\\right)^{1.11} + \\frac{6.9}{\\mathrm{Re}}\\right]}\\right)^2$$\n最后，使用达西-魏斯巴赫方程计算压降 $\\Delta P$。对四个指定的测试用例中的每一个都重复此整个过程。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the uncertainty quantification problem for the given test cases.\n    \"\"\"\n\n    # Define deterministic physical constants\n    RHO1 = 850.0  # kg/m^3\n    RHO2 = 1000.0 # kg/m^3\n    RE_TRANSITION = 2300.0\n\n    # Define uncertain parameter distributions (Uniform)\n    MU1_RANGE = [0.02, 0.10]    # Pa.s\n    MU2_RANGE = [0.0008, 0.0015] # Pa.s\n    EPS_RANGE = [1e-5, 1e-3]   # m\n\n    def evaluate_model(mu1_samples, mu2_samples, eps_samples, L, D, Q, phi):\n        \"\"\"\n        Vectorized evaluation of the pressure drop model.\n        \n        Args:\n            mu1_samples (np.array): Samples for viscosity of fluid 1.\n            mu2_samples (np.array): Samples for viscosity of fluid 2.\n            eps_samples (np.array): Samples for pipe roughness.\n            L (float): Pipe length.\n            D (float): Pipe diameter.\n            Q (float): Volumetric flow rate.\n            phi (float): Volume fraction of fluid 1.\n            \n        Returns:\n            np.array: Calculated pressure drop for each sample.\n        \"\"\"\n        # Mixture properties. rho_m is constant for a given case.\n        rho_m = phi * RHO1 + (1.0 - phi) * RHO2\n        mu_m = phi * mu1_samples + (1.0 - phi) * mu2_samples\n        \n        # Flow properties. U_m is constant for a given case.\n        U_m = (4.0 * Q) / (np.pi * D**2)\n        Re = rho_m * U_m * D / mu_m\n        \n        # Darcy friction factor\n        f = np.empty_like(Re)\n        \n        # Laminar flow regime\n        laminar_mask = Re  RE_TRANSITION\n        if np.any(laminar_mask):\n            f[laminar_mask] = 64.0 / Re[laminar_mask]\n            \n        # Turbulent flow regime\n        turbulent_mask = ~laminar_mask\n        if np.any(turbulent_mask):\n            eps_D_ratio = eps_samples[turbulent_mask] / D\n            Re_turb = Re[turbulent_mask]\n            \n            # Haaland correlation solved explicitly for f\n            log_term = np.log10((eps_D_ratio / 3.7)**1.11 + 6.9 / Re_turb)\n            f[turbulent_mask] = (-1.8 * log_term)**-2.0\n            \n        # Pressure drop (Darcy-Weisbach equation)\n        delta_P = f * (L / D) * (rho_m * U_m**2) / 2.0\n        \n        return delta_P\n\n    def compute_variances(params, N, rng):\n        \"\"\"\n        Computes the variance components V_visc and V_rough using Monte Carlo.\n        \"\"\"\n        L, D, Q, phi = params\n        \n        # Generate two independent sets of uniform random numbers in [0, 1]\n        A_uniform = rng.random(size=(N, 3))\n        B_uniform = rng.random(size=(N, 3))\n        \n        # Helper to scale uniform samples to their physical ranges\n        def scale_samples(uniform_samples):\n            mu1 = MU1_RANGE[0] + uniform_samples[:, 0] * (MU1_RANGE[1] - MU1_RANGE[0])\n            mu2 = MU2_RANGE[0] + uniform_samples[:, 1] * (MU2_RANGE[1] - MU2_RANGE[0])\n            eps = EPS_RANGE[0] + uniform_samples[:, 2] * (EPS_RANGE[1] - EPS_RANGE[0])\n            return mu1, mu2, eps\n\n        # Create physical sample matrices A and B\n        mu1_A, mu2_A, eps_A = scale_samples(A_uniform)\n        mu1_B, mu2_B, eps_B = scale_samples(B_uniform)\n\n        # Evaluate model for matrix A to estimate the mean\n        Y_A = evaluate_model(mu1_A, mu2_A, eps_A, L, D, Q, phi)\n        f0_sq = np.mean(Y_A)**2\n        \n        # Construct C matrices and evaluate model outputs\n        # C_rough matrix: mu from B, eps from A. Used to estimate V_rough.\n        Y_C_rough = evaluate_model(mu1_B, mu2_B, eps_A, L, D, Q, phi)\n        # C_visc matrix: mu from A, eps from B. Used to estimate V_visc.\n        Y_C_visc = evaluate_model(mu1_A, mu2_A, eps_B, L, D, Q, phi)\n        \n        # Estimate the variance of conditional expectations\n        V_rough = np.mean(Y_A * Y_C_rough) - f0_sq\n        V_visc = np.mean(Y_A * Y_C_visc) - f0_sq\n        \n        return V_visc, V_rough\n\n    # Define the test cases from the problem statement\n    test_cases = [\n        # (L, D, Q, phi)\n        (100.0, 0.05, 0.002, 0.5),\n        (150.0, 0.15, 0.03, 0.5),\n        (200.0, 0.20, 0.12, 0.2),\n        (80.0, 0.04, 0.0004, 0.8),\n    ]\n\n    results = []\n    # N must be large enough for convergence of the MC estimators\n    N = 2**18\n    # Use a fixed seed for reproducible results\n    rng = np.random.default_rng(seed=123)\n    \n    for case in test_cases:\n        V_visc, V_rough = compute_variances(case, N, rng)\n        results.append(V_visc > V_rough)\n        \n    # Format the final output as a comma-separated list of booleans\n    # The map(str,...) is used to convert boolean True/False to string \"True\"/\"False\"\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "蒙特卡洛方法的一个主要挑战是其计算成本，特别是当物理模型本身（如许多第一性原理计算）运行缓慢时。本练习旨在解决这一问题，介绍一种关键策略：构建“代理模型”。我们将创建一个简单的多项式代理模型来模拟一个来自凝聚态物理的复杂计算，并利用这个快速运行的代理模型高效地执行不确定性分析。",
            "id": "2448322",
            "problem": "创建一个完整的程序，为二维晶体材料在小平面内应变下的狄拉克点能量位移构建并验证一个快速代理模型，并用它来传播输入不确定性。在低应变范围内工作，其中应变的影响可以通过独立的小应变张量分量的平滑函数来捕捉。使用以下基于物理的参考模型（作为要模拟的高成本基准真相模型）来计算狄拉克点能量位移：\n$$\n\\Delta E_{\\mathrm{ref}}(\\varepsilon_{xx},\\varepsilon_{yy},\\varepsilon_{xy}) \\;=\\; D\\,(\\varepsilon_{xx}+\\varepsilon_{yy}) \\;+\\; \\alpha\\,(\\varepsilon_{xx}-\\varepsilon_{yy})^{2} \\;+\\; \\beta\\,\\varepsilon_{xy}^{2},\n$$\n其中 $D = 5.0$ 电子伏特，$\\alpha = 15.0$ 电子伏特，$\\beta = 10.0$ 电子伏特。应变分量 $\\varepsilon_{xx}$、$\\varepsilon_{yy}$ 和 $\\varepsilon_{xy}$ 是无量纲的，并假设其量级很小。\n\n从最小二乘回归和蒙特卡洛估计的定义出发，实现以下步骤，不使用任何针对该问题的快捷公式：\n\n- 构建一个关于变量 $(\\varepsilon_{xx},\\varepsilon_{yy},\\varepsilon_{xy})$ 的 $\\Delta E_{\\mathrm{ref}}$ 的二阶多项式代理模型，方法是使用普通最小二乘法，在最高为2次的所有单项式的完整集合中拟合一个线性模型。具体来说，表示为\n$$\n\\widehat{\\Delta E}(\\boldsymbol{\\varepsilon}) \\;=\\; w_{0} \\;+\\; w_{1}\\,\\varepsilon_{xx} \\;+\\; w_{2}\\,\\varepsilon_{yy} \\;+\\; w_{3}\\,\\varepsilon_{xy} \\;+\\; w_{4}\\,\\varepsilon_{xx}^{2} \\;+\\; w_{5}\\,\\varepsilon_{yy}^{2} \\;+\\; w_{6}\\,\\varepsilon_{xy}^{2} \\;+\\; w_{7}\\,\\varepsilon_{xx}\\varepsilon_{yy} \\;+\\; w_{8}\\,\\varepsilon_{xx}\\varepsilon_{xy} \\;+\\; w_{9}\\,\\varepsilon_{yy}\\varepsilon_{xy},\n$$\n并通过在训练集上最小化残差平方和来确定系数 $w_{j}$。\n\n- 生成一个训练集，方法是从立方体 $[-s,s]^{3}$ 中均匀抽取 $M$ 个独立的 $(\\varepsilon_{xx},\\varepsilon_{yy},\\varepsilon_{xy})$ 样本，其中 $M = 2000$ 且 $s = 0.02$，在这些样本上评估 $\\Delta E_{\\mathrm{ref}}$，并计算最小二乘拟合。\n\n- 对于下述每个测试用例，使用代理模型 $\\widehat{\\Delta E}$ 来传播应变中的输入不确定性。在每个案例中，应变向量被建模为一个高斯随机向量 $\\boldsymbol{\\varepsilon} \\sim \\mathcal{N}(\\boldsymbol{\\mu},\\boldsymbol{\\Sigma})$，其均值 $\\boldsymbol{\\mu}$ 和协方差矩阵 $\\boldsymbol{\\Sigma}$ 已提供；三个分量按顺序对应于 $(\\varepsilon_{xx},\\varepsilon_{yy},\\varepsilon_{xy})$。使用蒙特卡洛样本量 $N = 100000$ 来估计：\n    - 均值 $\\mathbb{E}[\\widehat{\\Delta E}]$，单位为电子伏特，\n    - 标准差 $\\sqrt{\\mathrm{Var}[\\widehat{\\Delta E}]}$，单位为电子伏特，以及\n    - 超出概率 $\\mathbb{P}\\left(|\\widehat{\\Delta E}| > T\\right)$，以小数形式表示，阈值 $T = 0.02$ 电子伏特。\n\n如果 $\\boldsymbol{\\Sigma}$ 是零矩阵，则将分布视为在 $\\boldsymbol{\\mu}$ 处的确定性分布。所有能量必须以电子伏特表示，所有概率必须以小数（而非百分比）表示。报告所有输出，四舍五入到六位小数。\n\n用于评估程序的测试套件：\n\n- 案例 $1$ (具有小的独立不确定性的各向同性均值)：\n    - $\\boldsymbol{\\mu}_{1} = [0.005,\\, 0.005,\\, 0.0]$\n    - $\\boldsymbol{\\Sigma}_{1} = \\mathrm{diag}([0.001^{2},\\, 0.001^{2},\\, 0.0005^{2}])$\n- 案例 $2$ (纯剪切均值，$\\varepsilon_{xx}$ 和 $\\varepsilon_{yy}$ 之间存在相关性)：\n    - $\\boldsymbol{\\mu}_{2} = [0.0,\\, 0.0,\\, 0.005]$\n    - 相关矩阵\n      $$\n      \\mathbf{R}_{2} \\;=\\; \\begin{bmatrix}\n      1  -0.5  0 \\\\\n      -0.5  1  0 \\\\\n      0  0  1\n      \\end{bmatrix}\n      $$\n      标准差为 $[0.001,\\, 0.001,\\, 0.001]$，所以\n      $$\n      \\boldsymbol{\\Sigma}_{2} \\;=\\; \\mathrm{diag}([0.001,\\,0.001,\\,0.001])\\;\\mathbf{R}_{2}\\;\\mathrm{diag}([0.001,\\,0.001,\\,0.001]).\n      $$\n- 案例 $3$ (确定性的各向异性均值，零不确定性)：\n    - $\\boldsymbol{\\mu}_{3} = [0.01,\\, 0.0,\\, 0.0]$\n    - $\\boldsymbol{\\Sigma}_{3} = \\mathbf{0}$ (3x3 的零矩阵)\n- 案例 $4$ (相关的各向异性均值和不确定性)：\n    - $\\boldsymbol{\\mu}_{4} = [0.003,\\, 0.007,\\, -0.002]$\n    - 相关矩阵\n      $$\n      \\mathbf{R}_{4} \\;=\\; \\begin{bmatrix}\n      1  0.7  -0.3 \\\\\n      0.7  1  0.2 \\\\\n      -0.3  0.2  1\n      \\end{bmatrix}\n      $$\n      标准差为 $[0.002,\\, 0.0025,\\, 0.0015]$，所以\n      $$\n      \\boldsymbol{\\Sigma}_{4} \\;=\\; \\mathrm{diag}([0.002,\\, 0.0025,\\, 0.0015])\\;\\mathbf{R}_{4}\\;\\mathrm{diag}([0.002,\\, 0.0025,\\, 0.0015]).\n      $$\n\n程序要求和最终输出格式：\n\n- 程序必须是独立完整的，并使用指定的 $M$、$s$、$N$、$D$、$\\alpha$、$\\beta$ 和 $T$ 为上述四个案例生成结果。\n- 使用固定的随机种子以确保可复现性。\n- 您的程序应生成单行输出，包含结果，格式为一个包含四个列表的逗号分隔列表，每个内部列表按 $[\\text{以 eV 为单位的均值},\\, \\text{以 eV 为单位的标准差},\\, \\text{以小数表示的概率}]$ 的顺序排列，并四舍五入到六位小数，不含多余空格。例如：\"[[a,b,c],[d,e,f],[g,h,i],[j,k,l]]\" 其中 a 到 l 表示四舍五入到六位小数的浮点数。",
            "solution": "提交分析的问题陈述被认为是有效的。其科学基础在于计算材料科学和统计学的原理，在数学上是适定的，并且定义客观、明确且精确。为获得一个唯一且可验证的解所需的所有必要参数、模型和条件均已提供。该问题是一个涉及代理建模和 Monte Carlo 模拟的不确定性量化标准练习。我们将着手解决此问题。\n\n任务是为给定的物理函数构建一个多项式代理模型，然后使用该代理模型执行不确定性传播。该过程分为两个主要阶段：代理模型构建和不确定性分析。\n\n**1. 代理模型构建**\n\n作为应变张量分量 $\\boldsymbol{\\varepsilon} = (\\varepsilon_{xx}, \\varepsilon_{yy}, \\varepsilon_{xy})$ 函数的狄拉克点能量位移 $\\Delta E_{\\mathrm{ref}}$ 的基准真相模型由下式给出：\n$$\n\\Delta E_{\\mathrm{ref}}(\\varepsilon_{xx},\\varepsilon_{yy},\\varepsilon_{xy}) = D\\,(\\varepsilon_{xx}+\\varepsilon_{yy}) + \\alpha\\,(\\varepsilon_{xx}-\\varepsilon_{yy})^{2} + \\beta\\,\\varepsilon_{xy}^{2}\n$$\n其中常数为 $D = 5.0\\, \\text{eV}$，$\\alpha = 15.0\\, \\text{eV}$，以及 $\\beta = 10.0\\, \\text{eV}$。\n\n我们的任务是构建一个二阶多项式代理模型 $\\widehat{\\Delta E}(\\boldsymbol{\\varepsilon})$，其形式为：\n$$\n\\widehat{\\Delta E}(\\boldsymbol{\\varepsilon}) = \\mathbf{x}(\\boldsymbol{\\varepsilon})^T \\mathbf{w}\n$$\n其中 $\\mathbf{w} = [w_0, w_1, \\dots, w_9]^T$ 是待确定的系数向量，$\\mathbf{x}(\\boldsymbol{\\varepsilon})$ 是最高为2次的多项式基函数（单项式）向量：\n$$\n\\mathbf{x}(\\boldsymbol{\\varepsilon})^T = [1, \\varepsilon_{xx}, \\varepsilon_{yy}, \\varepsilon_{xy}, \\varepsilon_{xx}^{2}, \\varepsilon_{yy}^{2}, \\varepsilon_{xy}^{2}, \\varepsilon_{xx}\\varepsilon_{yy}, \\varepsilon_{xx}\\varepsilon_{xy}, \\varepsilon_{yy}\\varepsilon_{xy}]\n$$\n这些系数 $\\mathbf{w}$ 使用普通最小二乘 (OLS) 回归来找到。首先，通过从立方体 $[-s, s]^3$ 中独立且均匀地抽取应变向量 $\\boldsymbol{\\varepsilon}^{(i)}$，生成一个包含 $M=2000$ 个点的训练集，其中 $s=0.02$。计算相应的能量位移 $y^{(i)} = \\Delta E_{\\mathrm{ref}}(\\boldsymbol{\\varepsilon}^{(i)})$。\n\n这构成一个线性系统 $\\mathbf{y} \\approx \\mathbf{X}\\mathbf{w}$，其中 $\\mathbf{y}$ 是 $M$ 个计算出的能量位移的列向量，$\\mathbf{X}$ 是 $M \\times 10$ 的设计矩阵，其每行为 $\\mathbf{x}(\\boldsymbol{\\varepsilon}^{(i)})^T$。OLS 通过最小化残差平方和 $\\|\\mathbf{y} - \\mathbf{X}\\mathbf{w}\\|_2^2$ 来确定 $\\mathbf{w}$。解由正规方程给出：\n$$\n\\mathbf{w} = (\\mathbf{X}^T\\mathbf{X})^{-1}\\mathbf{X}^T\\mathbf{y}\n$$\n在数值上，这可以通过诸如 QR 分解之类的方法稳健地求解，正如标准线性代数软件（例如 `numpy.linalg.lstsq`）中所实现的。\n\n为了验证代理模型，我们可以展开 $\\Delta E_{\\mathrm{ref}}$ 的解析形式：\n$$\n\\Delta E_{\\mathrm{ref}} = 5\\varepsilon_{xx} + 5\\varepsilon_{yy} + 15(\\varepsilon_{xx}^2 - 2\\varepsilon_{xx}\\varepsilon_{yy} + \\varepsilon_{yy}^2) + 10\\varepsilon_{xy}^2\n$$\n$$\n\\Delta E_{\\mathrm{ref}} = 5\\varepsilon_{xx} + 5\\varepsilon_{yy} + 15\\varepsilon_{xx}^2 + 15\\varepsilon_{yy}^2 + 10\\varepsilon_{xy}^2 - 30\\varepsilon_{xx}\\varepsilon_{yy}\n$$\n与代理模型的函数形式进行比较，理论系数为：\n- $w_0 = 0$ (常数项)\n- $w_1 = 5$ ($\\varepsilon_{xx}$ 项)\n- $w_2 = 5$ ($\\varepsilon_{yy}$ 项)\n- $w_3 = 0$ ($\\varepsilon_{xy}$ 项)\n- $w_4 = 15$ ($\\varepsilon_{xx}^2$ 项)\n- $w_5 = 15$ ($\\varepsilon_{yy}^2$ 项)\n- $w_6 = 10$ ($\\varepsilon_{xy}^2$ 项)\n- $w_7 = -30$ ($\\varepsilon_{xx}\\varepsilon_{yy}$ 项)\n- $w_8 = 0$ ($\\varepsilon_{xx}\\varepsilon_{xy}$ 项)\n- $w_9 = 0$ ($\\varepsilon_{yy}\\varepsilon_{xy}$ 项)\n从训练数据上的最小二乘拟合中获得的系数必须与这些理论值紧密匹配，这证实了代理模型构建的正确性。\n\n**2. 通过蒙特卡洛模拟进行不确定性传播**\n\n有了已验证的代理模型 $\\widehat{\\Delta E}$，我们将不确定性从输入应变分量传播到输出能量位移。对于每个测试用例，应变 $\\boldsymbol{\\varepsilon}$ 是一个服从多元正态分布 $\\boldsymbol{\\varepsilon} \\sim \\mathcal{N}(\\boldsymbol{\\mu}, \\boldsymbol{\\Sigma})$ 的随机向量。\n\n我们使用样本量为 $N=100000$ 的 Monte Carlo 模拟。步骤如下：\n1. 从指定的分布 $\\mathcal{N}(\\boldsymbol{\\mu}, \\boldsymbol{\\Sigma})$ 中生成 $N$ 个随机样本 $\\boldsymbol{\\varepsilon}^{(j)}$。\n2. 对每个样本，评估代理模型以获得能量位移：$\\widehat{y}^{(j)} = \\widehat{\\Delta E}(\\boldsymbol{\\varepsilon}^{(j)})$。\n3. 使用得到的输出样本总体 $\\{\\widehat{y}^{(1)}, \\dots, \\widehat{y}^{(N)}\\}$ 来估计所需的统计量：\n   - 均值: $\\mathbb{E}[\\widehat{\\Delta E}] \\approx \\bar{y} = \\frac{1}{N}\\sum_{j=1}^{N} \\widehat{y}^{(j)}$\n   - 标准差: $\\sqrt{\\mathrm{Var}[\\widehat{\\Delta E}]} \\approx \\sqrt{\\frac{1}{N}\\sum_{j=1}^{N} (\\widehat{y}^{(j)} - \\bar{y})^2}$\n   - 超出概率: $\\mathbb{P}(|\\widehat{\\Delta E}| > T) \\approx \\frac{1}{N} \\sum_{j=1}^{N} \\mathbf{1}_{|\\widehat{y}^{(j)}| > T}$，其中 $T=0.02\\, \\text{eV}$ 且 $\\mathbf{1}$ 是指示函数。\n\n对于测试案例3，其中协方差矩阵 $\\boldsymbol{\\Sigma}_3$ 是零矩阵，分布是确定性的。应变固定在其均值 $\\boldsymbol{\\varepsilon} = \\boldsymbol{\\mu}_3$ 上。在这种情况下，能量位移是一个单一值 $\\widehat{\\Delta E}(\\boldsymbol{\\mu}_3)$，标准差精确为 $0$，超出概率为 $1$ 或 $0$，取决于 $|\\widehat{\\Delta E}(\\boldsymbol{\\mu}_3)|$ 是否超过阈值 $T$。\n\n最终答案中的代码实现了这整个过程，从数据生成和模型拟合到针对所有四个指定测试用例的不确定性分析，并按要求格式化输出。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs a polynomial surrogate for Dirac-point energy shift and uses it\n    for uncertainty quantification.\n    \"\"\"\n    # 1. Define constants and setup\n    D = 5.0  # eV\n    alpha = 15.0  # eV\n    beta = 10.0  # eV\n    M = 2000  # Number of training samples\n    s = 0.02  # Range for uniform sampling of strain\n    N = 100000  # Number of Monte Carlo samples for UQ\n    T = 0.02  # Threshold for exceedance probability (eV)\n    SEED = 42  # Fixed seed for reproducibility\n    rng = np.random.default_rng(SEED)\n\n    # 2. Reference (ground-truth) model\n    def delta_E_ref(eps_samples):\n        # eps_samples is an array of shape (n_samples, 3) for [exx, eyy, exy]\n        exx, eyy, exy = eps_samples[:, 0], eps_samples[:, 1], eps_samples[:, 2]\n        return D * (exx + eyy) + alpha * (exx - eyy)**2 + beta * exy**2\n\n    # 3. Generate training data\n    train_eps = rng.uniform(low=-s, high=s, size=(M, 3))\n    train_y = delta_E_ref(train_eps)\n\n    # 4. Construct surrogate model via Ordinary Least Squares\n    def build_design_matrix(eps_samples):\n        # eps_samples is an array of shape (n_samples, 3)\n        n_samples = eps_samples.shape[0]\n        exx, eyy, exy = eps_samples[:, 0], eps_samples[:, 1], eps_samples[:, 2]\n        # Basis: 1, exx, eyy, exy, exx^2, eyy^2, exy^2, exx*eyy, exx*exy, eyy*exy\n        X = np.stack([\n            np.ones(n_samples),\n            exx,\n            eyy,\n            exy,\n            exx**2,\n            eyy**2,\n            exy**2,\n            exx * eyy,\n            exx * exy,\n            eyy * exy,\n        ], axis=1)\n        return X\n\n    X_train = build_design_matrix(train_eps)\n    \n    # Solve for weights w using numpy's numerically stable lstsq solver\n    w, residuals, rank, svals = np.linalg.lstsq(X_train, train_y, rcond=None)\n\n    # Define the surrogate model function\n    def delta_E_hat(eps_samples, weights):\n        # eps_samples can be shape (3,) or (n_samples, 3)\n        if eps_samples.ndim == 1:\n            eps_samples = eps_samples.reshape(1, -1)\n        X = build_design_matrix(eps_samples)\n        return X @ weights\n\n    # 5. Define test cases\n    test_cases_params = [\n        {\n            \"mu\": np.array([0.005, 0.005, 0.0]),\n            \"Sigma\": np.diag([0.001**2, 0.001**2, 0.0005**2])\n        },\n        {\n            \"mu\": np.array([0.0, 0.0, 0.005]),\n            \"Sigma\": np.diag([0.001, 0.001, 0.001]) @ \n                     np.array([[1, -0.5, 0], [-0.5, 1, 0], [0, 0, 1]]) @ \n                     np.diag([0.001, 0.001, 0.001])\n        },\n        {\n            \"mu\": np.array([0.01, 0.0, 0.0]),\n            \"Sigma\": np.zeros((3, 3))\n        },\n        {\n            \"mu\": np.array([0.003, 0.007, -0.002]),\n            \"Sigma\": np.diag([0.002, 0.0025, 0.0015]) @ \n                     np.array([[1, 0.7, -0.3], [0.7, 1, 0.2], [-0.3, 0.2, 1]]) @ \n                     np.diag([0.002, 0.0025, 0.0015])\n        }\n    ]\n\n    all_results = []\n\n    # 6. Propagate uncertainty for each case\n    for case in test_cases_params:\n        mu, Sigma = case[\"mu\"], case[\"Sigma\"]\n\n        # Handle the deterministic case separately for correctness\n        if np.all(Sigma == 0):\n            y_hat_val = delta_E_hat(mu, w)[0]\n            mean_val = y_hat_val\n            std_val = 0.0\n            exceed_prob = 1.0 if np.abs(y_hat_val) > T else 0.0\n        else:\n            # Generate MC samples from the input distribution\n            mc_eps_samples = rng.multivariate_normal(mu, Sigma, size=N)\n            # Evaluate the surrogate on these samples\n            y_hat_samples = delta_E_hat(mc_eps_samples, w)\n\n            # Estimate statistics\n            mean_val = np.mean(y_hat_samples)\n            std_val = np.std(y_hat_samples)\n            exceed_prob = np.sum(np.abs(y_hat_samples) > T) / N\n        \n        all_results.append([mean_val, std_val, exceed_prob])\n\n    # 7. Format and print the final output\n    formatted_results = []\n    for res_list in all_results:\n        # Format each number to 6 decimal places as a string\n        formatted_sublist = [f\"{val:.6f}\" for val in res_list]\n        # Create the string representation of the sublist\n        formatted_results.append(f\"[{','.join(formatted_sublist)}]\")\n    \n    # Create the final string representation of the list of lists\n    final_output_str = f\"[{','.join(formatted_results)}]\"\n    print(final_output_str)\n\nsolve()\n```"
        }
    ]
}