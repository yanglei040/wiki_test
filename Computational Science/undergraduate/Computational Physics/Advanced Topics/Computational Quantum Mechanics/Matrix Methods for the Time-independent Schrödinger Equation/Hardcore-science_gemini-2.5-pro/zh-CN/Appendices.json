{
    "hands_on_practices": [
        {
            "introduction": "掌握矩阵方法的第一步是将其应用于一维系统。这个练习提供了一个理想的场景：一个解析解难以处理的非平凡势场。通过将薛定谔方程离散化并构建哈密顿量矩阵，您可以直接计算能谱，从而对有限差分法获得具体的理解。请注意，使用圆周率数字来定义势垒是为本练习创建一个复杂但定义明确的势场而设计的假设情景，其目的是为了突显数值方法的强大功能。",
            "id": "2411985",
            "problem": "考虑一个有限域上具有齐次狄利克雷边界条件的一维、不含时的薛定谔方程 $-\\dfrac{\\hbar^2}{2m}\\dfrac{d^2\\psi(x)}{dx^2} + V(x)\\psi(x) = E\\psi(x)$。在 $\\hbar^2/(2m) = 1$ 的无量纲单位下，该方程变为 $-\\dfrac{d^2\\psi(x)}{dx^2} + V(x)\\psi(x) = E\\psi(x)$。设势函数为一个分段常数函数，由数学常数 $\\pi$ 的十进制数字构造而成，具体如下：对于每个整数 $i \\in \\{0,1,2,\\dots\\}$，定义 $V(x) = \\pi_i$ 当 $x \\in [i,i+1)$，其中 $\\pi_i$ 表示序列 $(3,1,4,1,5,9,2,6,5,3,\\dots)$ 中的第 $i$ 个数字，从 $i=0$ 处的整数部分 $3$ 开始。将域截断为 $x \\in [0,L]$，其中 $L = N$，$N$ 是所用数字的个数。\n\n你的任务是从不含时薛定谔方程的定义出发，使用均匀空间离散化和二阶导数的二阶中心差分近似，构建哈密顿算符的矩阵表示。施加齐次狄利克雷边界条件 $\\psi(0)=0$ 和 $\\psi(L)=0$。势函数必须根据上述分段常数定义进行一致采样：对于每个网格点 $x_j$，赋值 $V_j = \\pi_{\\lfloor x_j \\rfloor}$，并约定区间 $[i,i+1)$ 为左闭右开。全部计算在 $\\hbar^2/(2m)=1$ 的单位下进行，因此能量 $E$ 是无量纲的，并以与 $V(x)$ 相同的单位表示。\n\n算法要求：\n- 使用均匀网格，每单位长度有 $r$ 个子区间，即网格间距 $h = 1/r$。这会将网格点置于 $x_j = jh$（$j$ 为整数）。在 $x \\in [0,L]$ 上，且在 $x=0$ 和 $x=L$ 处有狄利克雷边界条件的情况下，内部网格点的数量为 $M = Lr - 1$。你必须在这 $M$ 个内部点上，使用二阶导数的标准三点差分格式构建哈密顿矩阵，并加上采样势值的对角矩阵。\n- 通过求解得到的对称矩阵本征值问题，计算出最低的 $k$ 个能量本征值，并按升序排列。\n\n物理和数值单位：\n- 所有能量 $E$ 均以 $\\hbar^2/(2m)=1$ 定义的无量纲单位报告。\n- 将返回的每个能量值四舍五入到 $6$ 位小数。\n\n测试套件和答案规范：\n对于下面的每个参数集，计算并返回最低的 $k$ 个本征值，形式为四舍五入到 $6$ 位小数的浮点数列表。$\\pi$ 数字势必须由初始数字 $(3,1,4,1,5,9,2,6,5,3,5,8,9,7,9,3,2,3,8,4,6,2,6,4,3,3,8,3,2,7,9,5,0,2,8,8,4,1,9,7,1,6,9,3,9,9,3,7,5,1,0,\\dots)$ 构成，忽略小数点，并仅使用每个测试用例所需的数字数量：\n- 情况 $1$ (正常路径)：$N=4$，$r=51$ (即每个单位区间有 $50$ 个内部点)，$k=3$。\n- 情况 $2$ (边界条件和常数势检验)：$N=1$，$r=61$，$k=2$。\n- 情况 $3$ (更长的域，中等分辨率)：$N=8$，$r=41$，$k=4$。\n- 情况 $4$ (更粗糙的分辨率，更长的域)：$N=12$，$r=31$，$k=3$。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含结果，格式为用方括号括起来的、无空格的、逗号分隔的列表的列表。每个内部列表对应于上面给出的一个测试用例，并包含该用例的最低 $k$ 个能量。例如，格式必须与 $[[e_{1,1},e_{1,2},\\dots],[e_{2,1},e_{2,2},\\dots],\\dots]$ 完全一样，其中每个 $e_{i,j}$ 是一个四舍五入到 $6$ 位小数的浮点数。",
            "solution": "该问题要求计算有限域上一维不含时薛定谔方程 (TISE) 的最低能量本征值。在 $\\hbar^2/(2m)=1$ 的无量纲单位下，其控制方程为：\n$$\n-\\frac{d^2\\psi(x)}{dx^2} + V(x)\\psi(x) = E\\psi(x)\n$$\n这构成了哈密顿算符 $\\hat{H} = -\\frac{d^2}{dx^2} + V(x)$ 的一个本征值问题，其中本征值 $E$ 对应于系统的量子化能级，而 $\\psi(x)$ 是相应的能量本征函数（定态）。该系统被限制在空间域 $x \\in [0, L]$ 内，域的长度 $L$ 被指定为整数 $N$。在域的边界上施加了齐次狄利克雷边界条件，即 $\\psi(0)=0$ 和 $\\psi(L)=0$。这样的配置是一个标准的 Sturm-Liouville 问题，它保证了存在一个有下界的、离散的、实值的能谱。\n\n为了找到本征值，我们必须求解这个微分方程。我们将采用有限差分法，这是一种用于近似微分算符的稳健数值技术。第一步是将连续空间域 $[0, L]$ 离散化为一个均匀网格。网格间距定义为 $h=1/r$，其中 $r$ 是一个给定的分辨率参数，表示单位长度内的子区间数量。网格点位于 $x_j = jh$ 的位置，其中整数索引 $j=0, 1, 2, \\dots, Lr$。然后，波函数 $\\psi(x)$ 由其在这些离散点上的值 $\\psi_j = \\psi(x_j)$ 来近似。边界条件直接意味着 $\\psi_0 = 0$ 和 $\\psi_{Lr} = 0$。我们的任务是确定 $M = Lr-1$ 个内部网格点上的 $\\psi_j$ 值，其中 $j$ 的范围是从 $1$ 到 $M$。\n\n哈密顿算符中的二阶导数项 $\\frac{d^2\\psi}{dx^2}$ 在每个内部网格点 $x_j$ 处使用二阶精度的中心差分公式进行近似：\n$$\n\\left. \\frac{d^2\\psi}{dx^2} \\right|_{x=x_j} \\approx \\frac{\\psi(x_{j+1}) - 2\\psi(x_j) + \\psi(x_{j-1})}{h^2} = \\frac{\\psi_{j+1} - 2\\psi_j + \\psi_{j-1}}{h^2}\n$$\n通过将此近似代入每个内部点 $x_j$ 的 TISE 中，我们将单个微分方程转换为一个包含 $M$ 个耦合代数方程的方程组：\n$$\n-\\frac{\\psi_{j+1} - 2\\psi_j + \\psi_{j-1}}{h^2} + V_j \\psi_j = E \\psi_j\n$$\n此处，$V_j = V(x_j)$ 是在网格点 $x_j$ 处采样的势。这个方程可以重新整理，以分离出给定网格点 $j$ 的各项：\n$$\n-\\frac{1}{h^2}\\psi_{j-1} + \\left(\\frac{2}{h^2} + V_j\\right)\\psi_j - \\frac{1}{h^2}\\psi_{j+1} = E\\psi_j\n$$\n这个由 $M$ 个线性方程组成的系统等价于一个矩阵本征值方程 $\\mathbf{H}\\vec{\\psi} = E\\vec{\\psi}$。在此表述中，$\\vec{\\psi} = (\\psi_1, \\psi_2, \\dots, \\psi_M)^T$ 是内部点上波函数值的列向量，而 $\\mathbf{H}$ 是哈密顿算符的 $M \\times M$ 矩阵表示。\n\n哈密顿矩阵 $\\mathbf{H}$ 是动能矩阵 $\\mathbf{T}$ 和势能矩阵 $\\mathbf{V}$ 的和。矩阵 $\\mathbf{T}$ 是算符 $-\\frac{d^2}{dx^2}$ 的离散表示。它是一个三对角矩阵，其元素由中心差分公式导出：\n$$\nT_{ij} = \\frac{1}{h^2} \\begin{cases} 2  \\text{if } i=j \\\\ -1  \\text{if } |i-j|=1 \\\\ 0  \\text{otherwise} \\end{cases}\n$$\n当只考虑内部点时，边界条件 $\\psi_0=0$ 和 $\\psi_{M+1}=0$ 被此结构隐式地处理。势能矩阵 $\\mathbf{V}$ 是一个对角矩阵，其对角元素是每个相应内部网格点上的势值：$V_{ij} = V_i \\delta_{ij}$。势函数 $V(x)$ 被指定为由 $\\pi$ 的十进制数字构成的分段常数函数。具体来说，$V(x) = \\pi_i$ 当 $x \\in [i, i+1)$，其中 $\\pi_i$ 是 $\\pi$ 的第 $i$ 个数字，从 $\\pi_0=3$ 开始。因此，一个网格点 $x_j$ 处的势由采样规则 $V_j = V(x_j) = \\pi_{\\lfloor x_j \\rfloor}$ 给出。\n\n因此，完整的哈密顿矩阵 $\\mathbf{H} = \\mathbf{T} + \\mathbf{V}$ 是一个实对称三对角矩阵，其元素为：\n$$\nH_{ij} = \\begin{cases} \\frac{2}{h^2} + V_i  \\text{if } i=j \\\\ -\\frac{1}{h^2}  \\text{if } |i-j|=1 \\\\ 0  \\text{otherwise} \\end{cases}\n$$\n(注意矩阵索引 $i,j$ 从 $1$ 到 $M$）。寻找允许能量 $E$ 的问题现在简化为寻找这个矩阵 $\\mathbf{H}$ 的本征值。\n\n对于每个指定的测试用例 $(N, r, k)$，计算算法如下：\n$1$. 设置物理和网格参数：域长度 $L=N$，网格间距 $h=1/r$，以及内部网格点数量 $M=Nr-1$。\n$2$. 生成包含 $M$ 个元素的势值向量。对于每个内部网格索引 $j=1, \\dots, M$，计算网格点坐标 $x_j = jh$，并使用提供的 $\\pi$ 数字序列找到势 $V_j = \\pi_{\\lfloor x_j \\rfloor}$。\n$3$. 构建哈密顿矩阵 $\\mathbf{H}$ 的主对角线和次对角线。主对角线元素为 $\\frac{2}{h^2} + V_j$，次对角线元素均为 $-\\frac{1}{h^2}$。\n$4$. 求解得到的矩阵本征值问题。由于 $\\mathbf{H}$ 是对称三对角矩阵，可以使用专门且高效的数值方法。我们将按要求只计算最低的 $k$ 个本征值，使用为此目的优化的函数，例如 `scipy.linalg.eigh_tridiagonal`。\n$5$. 计算出的本征值是最低 $k$ 个能级的数值近似。然后将这些值四舍五入到 $6$ 位小数，并按要求格式化。\n这整个过程为解决所提出的问题提供了一个系统且计算上可靠的方法。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh_tridiagonal\n\ndef solve():\n    \"\"\"\n    Solves the 1D time-independent Schrödinger equation for a piecewise-constant potential\n    derived from the digits of pi, using a finite difference matrix method.\n    \"\"\"\n    # The sequence of pi digits to be used for the potential, starting from the integer part.\n    pi_digits = (\n        3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9, 7, 9, 3, 2, 3, 8, 4, 6, 2, 6, 4, 3, 3, 8, 3, 2, 7, 9, 5,\n        0, 2, 8, 8, 4, 1, 9, 7, 1, 6, 9, 3, 9, 9, 3, 7, 5, 1, 0\n    )\n\n    # Define the test cases from the problem statement.\n    # Each tuple is (N, r, k)\n    # N: number of pi digits used, defines the domain length L=N\n    # r: number of subintervals per unit length, defines grid spacing h=1/r\n    # k: number of lowest eigenvalues to compute\n    test_cases = [\n        (4, 51, 3),  # Case 1\n        (1, 61, 2),  # Case 2\n        (8, 41, 4),  # Case 3\n        (12, 31, 3), # Case 4\n    ]\n\n    all_results = []\n    for N, r, k in test_cases:\n        # 1. Set up grid parameters\n        L = float(N)\n        h = 1.0 / r\n        # Number of interior grid points\n        M = N * r - 1\n\n        # 2. Construct the potential vector for interior points\n        # Grid indices for interior points run from 1 to M\n        grid_indices = np.arange(1, M + 1)\n        # Coordinates of interior grid points\n        x_coords = grid_indices * h\n        # Potential at each grid point, V_j = pi_floor(x_j)\n        potential_indices = np.floor(x_coords).astype(int)\n        potential_values = np.array([pi_digits[idx] for idx in potential_indices])\n\n        # 3. Construct the Hamiltonian matrix diagonals\n        # The kinetic energy term -d^2/dx^2 is discretized as a tridiagonal matrix.\n        # Diagonal elements: 2/h^2\n        # Off-diagonal elements: -1/h^2\n        h_sq_inv = 1.0 / (h * h)\n        main_diag = (2.0 * h_sq_inv) + potential_values\n        off_diag = (-1.0 * h_sq_inv) * np.ones(M - 1)\n\n        # 4. Solve the eigenvalue problem\n        # We need the lowest k eigenvalues. eigh_tridiagonal is efficient for this.\n        # 'select='i'' with 'select_range=(0, k-1)' computes eigenvalues with indices 0 to k-1.\n        # The eigenvalues are sorted in ascending order by default.\n        eigenvalues = eigh_tridiagonal(\n            main_diag,\n            off_diag,\n            select='i',\n            select_range=(0, k - 1)\n        )[0]\n\n        # 5. Format and store the results\n        # Round each eigenvalue to 6 decimal places.\n        rounded_eigenvalues = np.round(eigenvalues, 6).tolist()\n        all_results.append(rounded_eigenvalues)\n\n    # Final print statement in the exact required format.\n    # The format is a list of lists, represented as a string with no spaces.\n    # e.g., [[val1,val2],[val3,val4]]\n    results_as_strings = []\n    for res_list in all_results:\n        # Format each number to 6 decimal places and join into a comma-separated string\n        formatted_numbers = [f\"{num:.6f}\" for num in res_list]\n        results_as_strings.append(f\"[{','.join(formatted_numbers)}]\")\n    \n    final_output_string = f\"[{','.join(results_as_strings)}]\"\n    print(final_output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "在一维案例的基础上，下一个挑战是解决二维问题，这更能代表真实世界的物理系统。本实践探讨了限制在L形区域内的粒子，这是一个经典的量子问题，其边界的几何形状破坏了对称性，使得变量分离法不再适用。这个练习将指导您完成二维域的离散化，处理复杂的边界条件，并使用稀疏矩阵有效地找到能量本征值，从而将量子态在更复杂的几何结构中可视化。",
            "id": "2412057",
            "problem": "考虑一个质量为$m$的非相对论性粒子，被限制在一个有界二维区域$\\Omega \\subset \\mathbb{R}^2$内，区域外存在无限深势垒。在$\\Omega$内部，波函数$\\psi$满足不含时薛定谔方程 (TISE)\n$$\n-\\frac{\\hbar^2}{2m}\\Delta \\psi(x,y) = E\\psi(x,y),\\quad (x,y)\\in \\Omega,\n$$\n并带有狄利克雷边界条件\n$$\n\\psi(x,y) = 0,\\quad (x,y)\\in \\partial\\Omega.\n$$\n在由$\\hbar^2/(2m)=1$和特征长度$L=1$定义的无量纲单位下进行计算，本征值问题简化为\n$$\n-\\Delta \\psi(x,y) = E\\psi(x,y),\\quad \\psi|_{\\partial\\Omega}=0,\n$$\n且能量$E$是无量纲的，以$\\hbar^2/(2mL^2)$为单位。\n\n设$\\Omega_c$为从单位正方形中移除一个右上角正方形后得到的L形区域：\n$$\n\\Omega_c = (0,1)\\times(0,1)\\setminus\\Big([1-c,1]\\times[1-c,1]\\Big),\n$$\n其中$c\\in[0,1)$是一个控制所移除角部大小的无量纲参数。狄利克雷边界条件施加在整个边界$\\partial\\Omega_c$上。\n\n对于给定的正整数$n$，在$(0,1)\\times(0,1)$上定义一个均匀网格，沿每个轴的间距为$h=1/(n+1)$，并使用任何随着$n$增大能收敛到狄利克雷谱的一致性矩阵方法来近似$\\Omega_c$上的狄利克雷拉普拉斯算子本征值问题。使用分辨率为$n$的离散问题来近似$\\Omega_c$上狄利克雷拉普拉斯算子的最低$k$个不同本征值$E_1\\le E_2\\le\\cdots\\le E_k$。您的程序必须返回这$k$个数​​值近似值，按非递减顺序排序，并四舍五入到六位小数。\n\n测试套件：\n- 情况1：$c=0.5$, $n=40$, $k=6$。\n- 情况2：$c=0.0$, $n=40$, $k=6$。\n- 情况3：$c=0.75$, $n=36$, $k=6$。\n\n输出规范：\n- 对于每种情况，计算一个包含$k$个浮点数的列表，对应于按升序排列的最低$k$个本征值，每个值都四舍五入到六位小数。\n- 将这三个列表按上述情况的相同顺序聚合到一个列表的列表中。\n- 您的程序应生成单行输出，其中包含聚合结果，格式为方括号括起来的逗号分隔列表，内部列表也用方括号括起来。例如，要求的格式是\n[[E_{1,1},E_{1,2},\\dots,E_{1,6}],[E_{2,1},\\dots,E_{2,6}],[E_{3,1},\\dots,E_{3,6}]].\n不应打印任何其他文本。\n\n所有能量必须以指定的无量纲单位表示，并四舍五入到六位小数。此问题不涉及角度。此问题不涉及百分比。最终输出必须严格遵守上述单行格式。",
            "solution": "问题的核心是找到在二维区域$\\Omega_c$上带有狄利克雷边界条件的负拉普拉斯算子$-\\Delta$的本征值。我们将通过离散化算子和区域来解决这个问题，这将偏微分方程转化为一个矩阵本征值问题。\n\n**1. 通过有限差分法进行离散化**\n我们在均匀网格上采用有限差分法 (FDM)。网格点定义为$(x_i, y_j) = (ih, jh)$，其中$h=1/(n+1)$是网格间距，而$i, j$是从$1$到$n$的整数。网格点上的波函数表示为$\\psi_{i,j} = \\psi(x_i, y_j)$。\n\n拉普拉斯算子$\\Delta = \\frac{\\partial^2}{\\partial x^2} + \\frac{\\partial^2}{\\partial y^2}$在每个内部网格点$(x_i, y_j)$处使用一个五点差分格式进行近似，该格式由中心差分推导得出：\n$$\n\\Delta\\psi\\big|_{(x_i,y_j)} \\approx \\frac{\\psi_{i+1,j} + \\psi_{i-1,j} + \\psi_{i,j+1} + \\psi_{i,j-1} - 4\\psi_{i,j}}{h^2}\n$$\n将此代入无量纲的TISE，$-\\Delta\\psi = E\\psi$，得到：\n$$\n-\\frac{\\psi_{i+1,j} + \\psi_{i-1,j} + \\psi_{i,j+1} + \\psi_{i,j-1} - 4\\psi_{i,j}}{h^2} = E \\psi_{i,j}\n$$\n重新整理此方程，得到关于所有内部网格点上的值$\\psi_{i,j}$的线性方程组：\n$$\n4\\psi_{i,j} - \\psi_{i-1,j} - \\psi_{i+1,j} - \\psi_{i,j-1} - \\psi_{i,j+1} = (h^2 E) \\psi_{i,j}\n$$\n这是一个标准的矩阵本征值问题，$H\\vec{\\psi} = \\lambda\\vec{\\psi}$。此处，$\\vec{\\psi}$是通过将网格值$\\psi_{i,j}$展平而形成的向量，$H$是代表该差分格式的离散哈密顿矩阵，而$\\lambda = h^2 E$是$H$的本征值。能量本征值则可通过$E = \\lambda / h^2$恢复。\n\n**2. L形区域的矩阵构造**\n矩阵$H$必须为位于区域$\\Omega_c$内部的特定网格点集构建。\n一个网格点$(x_i, y_j) = (ih, jh)$在$\\Omega_c$内，如果它不在被移除的角部正方形中。一个点位于被移除区域$[1-c, 1]\\times[1-c, 1]$的条件是$x_i \\ge 1-c$且$y_j \\ge 1-c$。用网格索引表示，即$i \\ge (n+1)(1-c)$且$j \\ge (n+1)(1-c)$。\n\n构造矩阵H的算法如下：\n1.  识别所有满足$1 \\le i, j \\le n$且不在被移除角部内的有效内部网格点$(i, j)$。设这类点的总数为$N_{domain}$。\n2.  为每个有效的坐标对$(i, j)$创建一个到唯一线性索引$p \\in \\{0, 1, \\dots, N_{domain}-1\\}$的映射。\n3.  构建一个$N_{domain} \\times N_{domain}$的稀疏矩阵$H$。对于每个对应于$(i, j)$的点$p$：\n    -   对角元素$H_{p,p}$设为$4$。\n    -   对于$(i, j)$的四个邻点$(i', j')$中的每一个：如果邻点也是一个线性索引为$p'$的内部点，则非对角元素$H_{p,p'}$设为$-1$。\n如果一个邻点位于边界$\\partial\\Omega_c$上，根据狄利克雷条件，波函数值为零，因此它对点$(i, j)$的方程没有贡献。通过只考虑同为内部点的邻点，可以正确处理这种情况。\n\n**3. 本征值计算**\n得到的矩阵$H$是实对称且稀疏的。我们寻求其最低的$k$个本征值。对此最有效的方法是迭代本征求解器，例如`scipy.sparse.linalg.eigsh`中实现的Lanczos算法。该函数专为大型稀疏对称矩阵设计，可以指定从谱的一端（本例中为最小模，`'SM'`）寻找指定数量的本征值。\n\n一旦找到H的本征值$\\lambda_1, \\lambda_2, \\dots, \\lambda_k$，就可以使用关系式$E_m = \\lambda_m / h^2 = \\lambda_m (n+1)^2$计算出相应的物理能量本征值。\n\n**4. 特殊情况：单位正方形 ($c=0$)**\n对于$c=0$，区域$\\Omega_c$成为单位正方形$(0,1)\\times(0,1)$。对于这种高度对称的情况，离散拉普拉斯矩阵$H$的本征值可以解析地确定，无需显式构造和对角化该矩阵。本征值由下式给出：\n$$ \\lambda_{p,q} = 4 - 2\\cos\\left(\\frac{p\\pi}{n+1}\\right) - 2\\cos\\left(\\frac{q\\pi}{n+1}\\right) \\quad \\text{for } p,q \\in \\{1, 2, \\dots, n\\}. $$\n相应的能量本征值为$E_{p,q} = \\lambda_{p,q} / h^2$。为找到最低的k个本征值，我们计算所有$n^2$个可能的值，将它们按非递减顺序排序，并取前k个值。这为这种特殊情况下的离散系统提供了更直接和准确的结果。\n\n最终的程序将为每个测试用例实现这一逻辑，对于$c > 0$使用通用的稀疏矩阵方法，对于$c=0$使用解析公式，并按规定格式化结果。",
            "answer": "```python\nimport numpy as np\nfrom scipy.sparse import csr_matrix\nfrom scipy.sparse.linalg import eigsh\n\ndef compute_eigenvalues(c, n, k):\n    \"\"\"\n    Computes the k lowest eigenvalues of the Dirichlet Laplacian on an L-shaped domain.\n\n    The problem is discretized using a 5-point finite difference stencil, leading\n    to a matrix eigenvalue problem H*psi = lambda*psi, where E = lambda / h^2.\n\n    Args:\n        c (float): Parameter defining the L-shaped domain. c=0 is a full square.\n        n (int): Number of interior grid points along one dimension of the unit square.\n        k (int): Number of lowest eigenvalues to compute.\n\n    Returns:\n        list: A list of the k lowest eigenvalues, rounded to 6 decimal places.\n    \"\"\"\n    h = 1.0 / (n + 1)\n    h_sq = h**2\n\n    if c == 0.0:\n        # For the square domain (c=0), eigenvalues of the discrete Laplacian\n        # can be calculated analytically.\n        lambdas = []\n        for p in range(1, n + 1):\n            for q in range(1, n + 1):\n                lambda_pq = 4.0 - 2.0 * np.cos(p * np.pi * h) - 2.0 * np.cos(q * np.pi * h)\n                lambdas.append(lambda_pq)\n        \n        lambdas.sort()\n        lowest_lambdas = lambdas[:k]\n        energies = [lam / h_sq for lam in lowest_lambdas]\n        return [round(e, 6) for e in energies]\n\n    # General case for the L-shaped domain (c > 0).\n    # We construct the sparse matrix H.\n\n    # Determine the grid points inside the L-shaped domain.\n    # A point (i, j) is removed if it's in the top-right corner.\n    cutoff = (n + 1) * (1.0 - c)\n\n    domain_points = []\n    # Grid indices i, j run from 1 to n.\n    for j in range(1, n + 1):  # y-axis\n        for i in range(1, n + 1):  # x-axis\n            if not (i >= cutoff and j >= cutoff):\n                domain_points.append((i, j))\n    \n    N_domain = len(domain_points)\n    coord_to_idx = {point: i for i, point in enumerate(domain_points)}\n\n    row_ind = []\n    col_ind = []\n    data = []\n\n    # Populate the lists for constructing the sparse matrix H.\n    for idx, (i, j) in enumerate(domain_points):\n        # Diagonal element is 4.\n        row_ind.append(idx)\n        col_ind.append(idx)\n        data.append(4.0)\n\n        # Off-diagonal elements are -1 for neighbors inside the domain.\n        neighbors = [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]\n        for neighbor_coord in neighbors:\n            if neighbor_coord in coord_to_idx:\n                neighbor_idx = coord_to_idx[neighbor_coord]\n                row_ind.append(idx)\n                col_ind.append(neighbor_idx)\n                data.append(-1.0)\n    \n    # Construct the sparse matrix in CSR format for efficiency.\n    H = csr_matrix((data, (row_ind, col_ind)), shape=(N_domain, N_domain))\n    \n    # Find the k smallest eigenvalues using SciPy's sparse eigensolver for\n    # symmetric matrices. 'SM' means smallest magnitude. Since H is positive\n    # definite, these are the smallest positive eigenvalues.\n    # The solver returns eigenvalues in ascending order.\n    lambdas, _ = eigsh(H, k=k, which='SM', tol=1e-9)\n    \n    # Convert matrix eigenvalues to energy eigenvalues.\n    energies = lambdas / h_sq\n    \n    return [round(e, 6) for e in energies]\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    test_cases = [\n        # (c, n, k)\n        (0.5, 40, 6),\n        (0.0, 40, 6),\n        (0.75, 36, 6)\n    ]\n\n    results = []\n    for c, n, k in test_cases:\n        energies = compute_eigenvalues(c, n, k)\n        results.append(energies)\n    \n    # The final output must be a string representation of the list of lists,\n    # with no spaces.\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```"
        },
        {
            "introduction": "在学习了如何计算本征值和本征向量之后，计算科学的一个关键方面是评估数值结果的质量和可靠性。这最后一个练习旨在验证一个基本的理论性质：像哈密顿量这样的厄米算符，其本征向量应具有正交性。通过为一个简单的系统实施检查，并观察数值误差如何随着矩阵尺寸的增加而累积，您将对物理理论与有限精度计算的实际限制之间的相互作用有更深刻的认识。",
            "id": "2412055",
            "problem": "考虑一个质量为 $m$ 的粒子被限制在区间 $[0,L]$ 上的一维无限深方势阱中，其满足一维不含时薛定谔方程 (TISE)，边界条件为狄利克雷边界条件 $\\psi(0)=\\psi(L)=0$，且阱内势能 $V(x)=0$。在无量纲单位制下进行计算，使得约化普朗克常数 $\\hbar$ 等于 $1$，质量 $m$ 等于 $1$，长度 $L$ 等于 $1$。\n\n通过将空间域离散化为一个包含 $M$ 个内部点的均匀网格，并对这些内部点上的二阶导数使用标准的二阶中心有限差分表示，将哈密顿算符\n$$\n\\hat{H} = -\\frac{\\hbar^2}{2m}\\frac{d^2}{dx^2} + V(x)\n$$\n表示为一个实对称矩阵 $H \\in \\mathbb{R}^{M\\times M}$。将均匀网格间距记为 $a = \\frac{L}{M+1}$，并使用通常的三点格式来定义满足狄利克雷边界条件的离散拉普拉斯算子。\n\n设 $Q \\in \\mathbb{R}^{M\\times M}$ 是一个矩阵，其列向量是通过对 $H$ 进行完全特征分解得到的归一化特征向量。将正交性偏差定义为格拉姆矩阵与单位矩阵之差的弗罗贝尼乌斯范数，\n$$\ns(M) = \\left\\| Q^{\\mathsf{T}} Q - I_M \\right\\|_F,\n$$\n其中 $I_M$ 是 $M\\times M$ 的单位矩阵，$\\|\\cdot\\|_F$ 表示弗罗贝尼乌斯范数。\n\n您的任务是编写一个完整的、可运行的程序，该程序能够：\n- 对每个给定的 $M$，完全按照上述说明构建 $H$。\n- 计算 $H$ 的所有特征向量，并使用标准对称特征求解器返回的归一化列向量构成 $Q$。\n- 对每个 $M$ 计算 $s(M)$。\n\n测试组：\n- 使用 $M \\in \\{8,32,128,256\\}$。\n- 对于集合中的每个 $M$，计算 $s(M)$ 作为一个浮点数。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含按 $M=8, M=32, M=128, M=256$ 顺序排列的四个 $s(M)$ 值，以逗号分隔并用方括号括起来（例如，`[x1,x2,x3,x4]`）。由于 $s(M)$ 是无量纲的，输出中不需要物理单位。这些值应以十进制浮点数的形式打印。",
            "solution": "任务是计算离散化哈密顿量的特征向量的数值正交性误差的一种度量。该系统是一个质量为 $m$ 的粒子，处于长度为 $L$ 的一维无限深方势阱中。不含时薛定谔方程 (TISE) 由下式给出：\n$$\n\\hat{H}\\psi(x) = E\\psi(x)\n$$\n其中哈密顿算符 $\\hat{H}$ 为：\n$$\n\\hat{H} = -\\frac{\\hbar^2}{2m}\\frac{d^2}{dx^2} + V(x)\n$$\n问题指定了无量纲单位，其中 $\\hbar=1$，$m=1$，$L=1$。阱内势能 $V(x)$ 为 $0$，其区间为 $[0, 1]$。边界条件为 $\\psi(0) = \\psi(1) = 0$。在这些条件下，哈密顿算符简化为：\n$$\n\\hat{H} = -\\frac{1}{2}\\frac{d^2}{dx^2}\n$$\n\n为了将此算符表示为矩阵，我们将空间域 $[0, 1]$ 离散化。我们定义一个包含 $M$ 个内部点 $x_i = i \\cdot a$（$i=1, 2, \\dots, M$）的均匀网格。网格间距为 $a = \\frac{L}{M+1} = \\frac{1}{M+1}$。边界点为 $x_0 = 0$ 和 $x_{M+1} = 1$。波函数 $\\psi(x)$ 由一个向量 $\\vec{\\psi}$ 表示，其分量是波函数在内部网格点上的值，即 $\\psi_i = \\psi(x_i)$。边界条件要求 $\\psi_0 = \\psi(x_0) = 0$ 和 $\\psi_{M+1} = \\psi(x_{M+1}) = 0$。\n\n二阶导数算子 $\\frac{d^2}{dx^2}$ 在每个内部点 $x_i$ 处使用二阶中心有限差分公式进行近似：\n$$\n\\left. \\frac{d^2\\psi}{dx^2} \\right|_{x_i} \\approx \\frac{\\psi(x_i+a) - 2\\psi(x_i) + \\psi(x_i-a)}{a^2} = \\frac{\\psi_{i+1} - 2\\psi_i + \\psi_{i-1}}{a^2}\n$$\n将此近似代入每个点 $x_i$ 的不含时薛定谔方程中：\n$$\n-\\frac{1}{2} \\left( \\frac{\\psi_{i+1} - 2\\psi_i + \\psi_{i-1}}{a^2} \\right) = E\\psi_i\n$$\n重新整理各项，我们得到一个线性方程组：\n$$\n-\\frac{1}{2a^2}\\psi_{i-1} + \\frac{1}{a^2}\\psi_i - \\frac{1}{2a^2}\\psi_{i+1} = E\\psi_i\n$$\n该方程组可以表示为矩阵形式 $H\\vec{\\psi} = E\\vec{\\psi}$，其中 $H$ 是一个 $M \\times M$ 的矩阵。$H$ 的元素由上述方程确定。对于第 $i$ 行：\n- 对角元素 ($j=i$) 为 $H_{ii} = \\frac{1}{a^2}$。\n- 次对角元素 ($j=i \\pm 1$) 为 $H_{i,i-1} = H_{i,i+1} = -\\frac{1}{2a^2}$。\n- 所有其他元素均为零。\n\n最终得到的哈密顿矩阵 $H$ 是一个实对称三对角矩阵：\n$$\nH = \\frac{1}{2a^2}\n\\begin{pmatrix}\n2  -1  0  \\cdots  0 \\\\\n-1  2  -1  \\cdots  0 \\\\\n0  -1  2  \\ddots  \\vdots \\\\\n\\vdots  \\vdots  \\ddots  \\ddots  -1 \\\\\n0  0  \\cdots  -1  2\n\\end{pmatrix}\n$$\n对每个指定的 $M$ 值构建此矩阵。\n\n下一步是对 $H$ 进行特征分解。由于 $H$ 是一个实对称矩阵，根据谱定理，它保证有 $M$ 个实数特征值和一组对应的 $M$ 个特征向量，这些特征向量构成了 $\\mathbb{R}^M$ 的一个标准正交基。我们使用一个为对称矩阵设计的标准数值特征求解器来找到特征值和特征向量。这类求解器返回一个矩阵 $Q \\in \\mathbb{R}^{M\\times M}$，其列是 $H$ 的归一化特征向量。理论上，这些特征向量是完全标准正交的，这意味着矩阵 $Q$ 是正交的，满足 $Q^{\\mathsf{T}}Q = I_M$，其中 $I_M$ 是 $M \\times M$ 的单位矩阵。\n\n由于有限精度浮点运算，数值计算得到的特征向量矩阵（我们也用 $Q$ 表示）将仅是近似正交的。问题要求我们量化这种与完美正交性之间的数值偏差。指定的度量是正交性偏差 $s(M)$，定义为格拉姆矩阵 $Q^{\\mathsf{T}}Q$ 与单位矩阵 $I_M$ 之差的弗罗贝尼乌斯范数：\n$$\ns(M) = \\left\\| Q^{\\mathsf{T}} Q - I_M \\right\\|_F\n$$\n一个矩阵 $A$ 的弗罗贝尼乌斯范数由 $\\|A\\|_F = \\sqrt{\\sum_{i,j} |A_{ij}|^2}$ 给出。\n\n对于每个 $M \\in \\{8, 32, 128, 256\\}$，计算步骤如下：\n1.  计算网格间距 $a = \\frac{1}{M+1}$。\n2.  构建 $M \\times M$ 的哈密顿矩阵 $H$，其对角元素为 $H_{ii} = \\frac{1}{a^2}$，次对角元素为 $H_{i, i \\pm 1} = -\\frac{1}{2a^2}$。\n3.  使用针对对称矩阵的数值例程（例如 `numpy.linalg.eigh`）来计算 $H$ 的归一化特征向量矩阵 $Q$。\n4.  计算格拉姆矩阵 $G = Q^{\\mathsf{T}}Q$。\n5.  计算偏差矩阵 $D = G - I_M$。\n6.  计算弗罗贝尼乌斯范数 $s(M) = \\|D\\|_F$。\n\n对所有指定的 $M$ 值执行此过程，并报告所得的 $s(M)$ 值。这些值代表了特征求解器算法在强制执行正交性约束时累积的浮点误差。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of calculating the orthogonality deviation for eigenvectors\n    of a discretized Hamiltonian for an infinite square well.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [8, 32, 128, 256]\n\n    results = []\n    for M in test_cases:\n        # Step 1: Define parameters based on the problem statement.\n        # hbar = 1, m = 1, L = 1.\n        # Grid spacing 'a'.\n        a = 1.0 / (M + 1.0)\n        \n        # Step 2: Construct the Hamiltonian matrix H.\n        # H is a real symmetric tridiagonal matrix.\n        # Diagonal elements are 1/a^2 (from the -2*psi_i term).\n        # Off-diagonal elements are -1/(2*a^2) (from psi_{i-1} and psi_{i+1} terms).\n        # The overall factor of -hbar^2/(2m) = -1/2 is included.\n        diag_val = 1.0 / (a**2)\n        offdiag_val = -0.5 / (a**2)\n        \n        # An efficient and clear way to build the tridiagonal matrix H.\n        # It's constructed from its diagonal and two off-diagonal vectors.\n        H = (np.diag(np.full(M, diag_val)) + \n             np.diag(np.full(M - 1, offdiag_val), k=1) + \n             np.diag(np.full(M - 1, offdiag_val), k=-1))\n        \n        # Step 3: Compute eigenvectors of H.\n        # numpy.linalg.eigh is used for symmetric/Hermitian matrices.\n        # It returns eigenvalues and a matrix Q of orthonormal eigenvectors.\n        # We only need the eigenvectors, so eigenvalues are discarded ('_').\n        _, Q = np.linalg.eigh(H)\n        \n        # Step 4: Compute the orthogonality deviation s(M).\n        # The definition is s(M) = ||Q^T Q - I||_F (Frobenius norm).\n        \n        # Compute the Gram matrix G = Q^T Q.\n        # In theory, for an orthogonal matrix Q, G should be the identity matrix.\n        gram_matrix = Q.T @ Q\n        \n        # Create the identity matrix of size M x M.\n        identity_matrix = np.identity(M)\n        \n        # Compute the difference matrix.\n        deviation_matrix = gram_matrix - identity_matrix\n        \n        # Compute the Frobenius norm of the difference.\n        s_M = np.linalg.norm(deviation_matrix, 'fro')\n        \n        results.append(s_M)\n\n    # Final print statement in the exact required format.\n    # The format is a comma-separated list of float values enclosed in brackets.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}