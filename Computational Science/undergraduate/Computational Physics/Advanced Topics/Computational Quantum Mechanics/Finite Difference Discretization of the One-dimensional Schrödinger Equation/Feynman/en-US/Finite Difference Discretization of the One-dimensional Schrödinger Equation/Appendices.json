{
    "hands_on_practices": [
        {
            "introduction": "Our first practice lays the essential groundwork for solving the Schrödinger equation numerically. We will start with the classic 'particle in a box' and build the discrete Hamiltonian matrix $H$ from first principles using the finite difference method. This exercise  is not just about getting an answer; its core lesson is in verification, as you will systematically analyze how the numerical error decreases with grid refinement, a fundamental skill for validating any scientific simulation.",
            "id": "2960274",
            "problem": "Implement a program that models the one-dimensional infinite potential well (also known as the particle-in-a-box) on the interval $[0,L]$ by discretizing the time-independent Schrödinger equation using a second-order central finite difference approximation of the second derivative with Dirichlet boundary conditions at $x=0$ and $x=L$. From first principles, start from the time-independent Schrödinger equation and the definition of the infinite potential well. Construct the discrete Hamiltonian operator, compute its eigenvalues for a sequence of grid spacings, and compare the computed energy level $E_n$ with the exact continuous solution derived from the underlying differential equation. Quantitatively analyze the discretization error as a function of grid spacing and estimate the convergence rate exponent.\n\nRequirements:\n- Physical model:\n  - The time-independent Schrödinger equation on $[0,L]$ for a particle of mass $m$ in an infinite potential well is to be used as the fundamental starting point. The boundary conditions are $\\psi(0)=0$ and $\\psi(L)=0$.\n  - The continuous energy levels $E_n$ used for reference must be obtained by solving this boundary value problem from first principles, not by invoking any unmotivated shortcut formulas in your reasoning. Your program may use the resulting analytical expression once you have established it in your derivation.\n- Discretization:\n  - Use a uniform grid of $M$ interior points with spacing $h=L/(M+1)$.\n  - Apply the standard second-order central finite difference approximation for the second derivative on the interior points and enforce the Dirichlet boundary conditions implicitly by omitting the boundary nodes from the unknown vector.\n  - Construct the discrete Hamiltonian matrix $H$ corresponding to the kinetic energy operator on the interior nodes.\n- Numerical computation:\n  - For each specified set of parameters, compute the $n$-th discrete energy $E_n^{(h)}$ as the $n$-th eigenvalue (in ascending order) of the discrete Hamiltonian $H$.\n  - Compute the absolute error $|E_n^{(h)}-E_n|$ where $E_n$ is the exact continuous energy for the same $n$, $L$, and $m$.\n  - For each test case, vary the grid spacing $h$ over a list of values by changing $M$, and estimate the exponent $p$ in the empirical relation $|E_n^{(h)}-E_n|\\approx C\\,h^p$ via a least-squares fit of $\\log |E_n^{(h)}-E_n|$ versus $\\log h$. Report the fitted slope $p$.\n- Units:\n  - All calculations must be performed in the International System of Units (SI). Use $L$ in meters, $m$ in kilograms, and energies in joules.\n  - Use the reduced Planck constant value $\\hbar = 1.054571817\\times 10^{-34}\\ \\mathrm{J\\cdot s}$ and the electron mass $m_e=9.1093837015\\times 10^{-31}\\ \\mathrm{kg}$.\n  - When $L$ is specified in nanometers in the test suite, convert using $1\\ \\mathrm{nm}=1.0\\times 10^{-9}\\ \\mathrm{m}$.\n- Output:\n  - Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, e.g., $[r_1,r_2,r_3]$, where each $r_i$ is the fitted slope $p$ for test case $i$, rounded to three decimal places.\n\nTest suite:\n- Use the following cases, each specified as a tuple $\\left(L_{\\mathrm{nm}}, n, [M_1,M_2,M_3,M_4]\\right)$ where $L_{\\mathrm{nm}}$ is in nanometers and must be converted to meters in the computation:\n  - Case $1$: $\\left(1.0,\\,1,\\,[20,\\,40,\\,80,\\,160]\\right)$.\n  - Case $2$: $\\left(0.5,\\,5,\\,[50,\\,100,\\,200,\\,400]\\right)$.\n  - Case $3$: $\\left(2.0,\\,1,\\,[3,\\,6,\\,12,\\,24]\\right)$.\n- For all cases, use $m=m_e$.\n- Final output format:\n  - A single line with the list $[r_1,r_2,r_3]$ of the three fitted slopes, each rounded to three decimal places, with no additional text.",
            "solution": "The problem statement is evaluated and determined to be valid. It presents a standard, well-posed problem in computational quantum mechanics that is scientifically sound, self-contained, and objective. It is free of contradictions or ambiguities. I will therefore proceed with a full derivation and solution.\n\nThe task is to numerically solve the one-dimensional time-independent Schrödinger equation for a particle in an infinite potential well, analyze the discretization error, and determine the empirical order of convergence of the numerical method.\n\n**1. Analytical Solution of the Continuous Problem**\n\nThe first principle is the time-independent Schrödinger equation for a particle of mass $m$ in a potential $V(x)$:\n$$\n\\hat{H}\\psi(x) = \\left[-\\frac{\\hbar^2}{2m}\\frac{d^2}{dx^2} + V(x)\\right]\\psi(x) = E\\psi(x)\n$$\nFor an infinite potential well of length $L$, the potential $V(x)$ is defined on the domain $[0, L]$ as:\n$$\nV(x) = \\begin{cases} 0  \\text{if } 0  x  L \\\\ \\infty  \\text{otherwise} \\end{cases}\n$$\nThe infinite potential at the boundaries implies that the particle cannot exist outside the interval $(0, L)$. The continuity of the wavefunction $\\psi(x)$ therefore imposes the Dirichlet boundary conditions:\n$$\n\\psi(0) = 0 \\quad \\text{and} \\quad \\psi(L) = 0\n$$\nInside the well, where $V(x)=0$, the Schrödinger equation simplifies to:\n$$\n-\\frac{\\hbar^2}{2m}\\frac{d^2\\psi(x)}{dx^2} = E\\psi(x)\n$$\nThis equation is rearranged into the form of a classical simple harmonic oscillator equation:\n$$\n\\frac{d^2\\psi(x)}{dx^2} + k^2\\psi(x) = 0, \\quad \\text{where } k = \\frac{\\sqrt{2mE}}{\\hbar}\n$$\nThe general solution to this second-order ordinary differential equation is:\n$$\n\\psi(x) = A\\sin(kx) + B\\cos(kx)\n$$\nApplying the first boundary condition, $\\psi(0) = 0$:\n$$\n\\psi(0) = A\\sin(0) + B\\cos(0) = B = 0\n$$\nThus, the solution must be of the form $\\psi(x) = A\\sin(kx)$. Applying the second boundary condition, $\\psi(L) = 0$:\n$$\n\\psi(L) = A\\sin(kL) = 0\n$$\nA non-trivial solution requires $A \\neq 0$, which implies that $\\sin(kL)$ must be zero. This condition is met when $kL$ is an integer multiple of $\\pi$:\n$$\nkL = n\\pi, \\quad \\text{for } n = 1, 2, 3, \\ldots\n$$\nThe quantum number $n$ must be a positive integer, as $n=0$ would lead to $k=0$ and a trivial wavefunction $\\psi(x)=0$. This quantizes the wave number $k_n = \\frac{n\\pi}{L}$. Substituting this into the definition of $k$:\n$$\n\\left(\\frac{n\\pi}{L}\\right)^2 = \\frac{2mE_n}{\\hbar^2}\n$$\nSolving for the energy $E_n$ gives the exact, quantized energy levels for the particle in a one-dimensional infinite potential well:\n$$\nE_n = \\frac{n^2\\pi^2\\hbar^2}{2mL^2}\n$$\nThis analytical expression for $E_n$ will serve as the exact reference against which the numerical results are compared.\n\n**2. Discretization of the Schrödinger Equation**\n\nTo solve the problem numerically, we discretize the spatial domain $[0, L]$ into a uniform grid. We define $M$ interior points, such that the total number of points is $M+2$. The grid spacing is $h = \\frac{L}{M+1}$, and the grid points are $x_i = i \\cdot h$ for $i=0, 1, \\dots, M+1$. The wavefunction at these discrete points is denoted $\\psi_i = \\psi(x_i)$. The boundary conditions are explicitly $\\psi_0=0$ and $\\psi_{M+1}=0$.\n\nThe second derivative operator, $\\frac{d^2}{dx^2}$, is approximated using a second-order central finite difference scheme at each interior point $x_i$:\n$$\n\\left.\\frac{d^2\\psi}{dx^2}\\right|_{x=x_i} \\approx \\frac{\\psi(x_i+h) - 2\\psi(x_i) + \\psi(x_i-h)}{h^2} = \\frac{\\psi_{i+1} - 2\\psi_i + \\psi_{i-1}}{h^2}\n$$\nSubstituting this approximation into the Schrödinger equation for an interior point $i$ (where $i=1, \\dots, M$):\n$$\n-\\frac{\\hbar^2}{2m} \\left( \\frac{\\psi_{i-1} - 2\\psi_i + \\psi_{i+1}}{h^2} \\right) = E^{(h)}\\psi_i\n$$\nHere, $E^{(h)}$ denotes the numerical approximation of the energy eigenvalue, which depends on the grid spacing $h$. Rearranging this expression, we get:\n$$\n\\left(-\\frac{\\hbar^2}{2mh^2}\\right)\\psi_{i-1} + \\left(\\frac{\\hbar^2}{mh^2}\\right)\\psi_i + \\left(-\\frac{\\hbar^2}{2mh^2}\\right)\\psi_{i+1} = E^{(h)}\\psi_i\n$$\nThis represents a system of $M$ coupled linear equations for the unknown values $\\psi_1, \\dots, \\psi_M$.\n\n**3. The Discrete Hamiltonian Matrix**\n\nThe system of equations from the discretization can be cast into a matrix eigenvalue problem, $\\mathbf{H}\\vec{\\psi} = E^{(h)}\\vec{\\psi}$. The vector $\\vec{\\psi}$ is $(\\psi_1, \\psi_2, \\dots, \\psi_M)^T$, and $\\mathbf{H}$ is the $M \\times M$ matrix representation of the Hamiltonian operator, known as the discrete Hamiltonian.\n\nLet us define the kinetic energy scaling factor $T = \\frac{\\hbar^2}{2mh^2}$. The equation for each node $i$ becomes:\n$$\n-T\\psi_{i-1} + 2T\\psi_i - T\\psi_{i+1} = E^{(h)}\\psi_i\n$$\nUsing the boundary conditions $\\psi_0 = 0$ and $\\psi_{M+1}=0$, the system for $i=1, \\dots, M$ gives rise to a symmetric tridiagonal matrix $\\mathbf{H}$:\n$$\n\\mathbf{H} = \\begin{pmatrix}\n2T  -T  0  \\cdots  0 \\\\\n-T  2T  -T  \\cdots  0 \\\\\n0  -T  2T  \\ddots  \\vdots \\\\\n\\vdots  \\vdots  \\ddots  \\ddots  -T \\\\\n0  0  \\cdots  -T  2T\n\\end{pmatrix}\n$$\nThe eigenvalues of this matrix $\\mathbf{H}$ correspond to the discrete energy levels $E_n^{(h)}$. The $n$-th eigenvalue (sorted in ascending order) is the numerical approximation for the $n$-th energy level, $E_n$.\n\n**4. Convergence Analysis**\n\nThe central difference scheme has a truncation error of order $O(h^2)$. For self-adjoint eigenvalue problems like this, the error in the eigenvalues is predicted to exhibit the same order of convergence. Thus, we expect the absolute error between the numerical and exact energies to scale with the grid spacing $h$ as:\n$$\n|E_n^{(h)} - E_n| \\approx C h^p\n$$\nwhere $p$ is the convergence rate exponent, which we expect to be $2$. To find $p$ empirically, we take the natural logarithm of the error equation:\n$$\n\\ln\\left(|E_n^{(h)} - E_n|\\right) \\approx \\ln(C) + p \\ln(h)\n$$\nThis reveals a linear relationship between $\\ln(\\text{error})$ and $\\ln(h)$. By computing the error for a sequence of decreasing grid spacings $h$ (corresponding to increasing $M$) and performing a linear least-squares fit on the $(\\ln(h), \\ln(\\text{error}))$ data, the slope of the resulting line provides an estimate for $p$. This procedure is implemented in the provided code to satisfy the problem requirements.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D particle-in-a-box problem numerically and analyzes convergence.\n    \"\"\"\n    # Define physical constants in SI units\n    HBAR = 1.054571817e-34  # Reduced Planck constant in J*s\n    M_E = 9.1093837015e-31   # Electron mass in kg\n    NM_TO_M = 1.0e-9         # Nanometer to meter conversion factor\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (L_nm, n, [M_1, M_2, M_3, M_4])\n    test_cases = [\n        (1.0, 1, [20, 40, 80, 160]),\n        (0.5, 5, [50, 100, 200, 400]),\n        (2.0, 1, [3, 6, 12, 24]),\n    ]\n\n    results = []\n    \n    # Process each test case\n    for case in test_cases:\n        L_nm, n, M_list = case\n        \n        # Set parameters for the current case\n        L = L_nm * NM_TO_M  # Convert box length to meters\n        m = M_E             # Set mass to electron mass\n\n        # Calculate the exact analytical energy for level n\n        E_n_exact = (n**2 * np.pi**2 * HBAR**2) / (2 * m * L**2)\n\n        log_h_vals = []\n        log_error_vals = []\n\n        # Iterate over the specified numbers of interior grid points (M)\n        for M in M_list:\n            # Calculate grid spacing h\n            h = L / (M + 1)\n\n            # Construct the discrete Hamiltonian matrix H\n            # T is the kinetic energy scaling factor: hbar^2 / (2*m*h^2)\n            T = HBAR**2 / (2 * m * h**2)\n            \n            # The matrix H has 2T on the main diagonal and -T on the adjacent diagonals\n            main_diag = np.full(M, 2 * T)\n            off_diag = np.full(M - 1, -T)\n            H = np.diag(main_diag) + np.diag(off_diag, k=1) + np.diag(off_diag, k=-1)\n\n            # Compute eigenvalues of the symmetric matrix H.\n            # np.linalg.eigh is efficient and returns sorted eigenvalues.\n            eigenvalues = np.linalg.eigh(H)[0]\n            \n            # The numerical energy E_n is the n-th eigenvalue (0-indexed)\n            E_n_h = eigenvalues[n - 1]\n\n            # Calculate the absolute error and store its logarithm\n            error = np.abs(E_n_h - E_n_exact)\n            log_error_vals.append(np.log(error))\n            \n            # Store the logarithm of the grid spacing\n            log_h_vals.append(np.log(h))\n\n        # Perform a linear least-squares fit on the log-log data.\n        # log(error) = p * log(h) + log(C)\n        # np.polyfit with degree 1 returns the slope (p) and intercept (log(C)).\n        p, _ = np.polyfit(log_h_vals, log_error_vals, 1)\n        results.append(p)\n\n    # Format the results to three decimal places as required.\n    rounded_results = [round(r, 3) for r in results]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, rounded_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Having established a reliable numerical method, we can now use it as a computational laboratory to explore deeper physical principles. This practice  investigates the connection between a symmetric potential, like that of the quantum harmonic oscillator, and the parity of its energy eigenfunctions. You will numerically confirm the theoretical prediction that these states must be either even or odd, and also discover how subtle choices in discretization can introduce small, quantifiable numerical errors that break this perfect symmetry.",
            "id": "2393165",
            "problem": "Consider the time-independent one-dimensional Schrödinger equation for a particle of mass $m$ in a potential $V(x)$,\n$$\\hat{H}\\,\\psi(x) \\equiv \\left(-\\frac{\\hbar^2}{2m}\\frac{d^2}{dx^2} + V(x)\\right)\\psi(x) = E\\,\\psi(x).$$\nIf the potential is symmetric, i.e., $V(-x)=V(x)$, then the Hamiltonian $\\hat{H}$ commutes with the parity operator $\\hat{\\Pi}$ defined by $(\\hat{\\Pi}\\psi)(x) = \\psi(-x)$. Consequently, each exact energy eigenfunction can be chosen to have definite parity (either even or odd), and for nondegenerate spectra the parity is fixed up to an overall sign.\n\nWork in dimensionless units where $\\hbar=1$, $m=1$, and the angular frequency is $\\omega=1$. Use the harmonic oscillator potential\n$$V(x) = \\frac{1}{2}\\,x^2.$$\nRestrict the configuration space to the finite interval $[-L,L]$ with $L = 8$, and impose homogeneous Dirichlet boundary conditions $\\psi(-L) = \\psi(L) = 0$. On this interval, approximate the Hamiltonian by a finite difference discretization on a uniform grid with $N$ interior points. Let $\\Delta x$ be the uniform grid spacing. For each test case, compute the lowest $K$ energy eigenpairs $(E_j,\\psi_j)$ with $j \\in \\{0,1,\\dots,K-1\\}$ ordered by increasing $E_j$. Normalize each discrete eigenvector to the continuum norm such that\n$$\\sum_{i=1}^{N} \\left|\\psi_j(x_i)\\right|^2\\,\\Delta x = 1.$$\nFor each normalized eigenvector, define the discrete parity overlap\n$$P_j \\equiv \\sum_{i=1}^{N} \\psi_j(x_i)\\,\\psi_j(-x_i)\\,\\Delta x,$$\nwhere by construction of the uniform grid on $[-L,L]$ with $N$ interior points, the point $-x_i$ coincides with a grid point and the sum is evaluated by pairing mirrored indices. In exact arithmetic for a symmetric Hamiltonian, one expects $P_j = +1$ for even-parity eigenfunctions and $P_j = -1$ for odd-parity eigenfunctions. Define the parity-breaking error for state $j$ as\n$$\\varepsilon_j \\equiv 1 - |P_j|,$$\nand for a given test case define\n$$\\varepsilon_{\\max} \\equiv \\max_{0 \\le j \\le K-1} \\varepsilon_j.$$\nAlso define a boolean indicator $A$ that is true if and only if the sequence of signs $\\mathrm{sgn}(P_j)$ alternates $+1,-1,+1,-1,\\dots$ for $j=0,1,\\dots,K-1$.\n\nWrite a complete program that performs the above computations using a second-order finite difference discretization on a uniform grid for the following test suite (with $K=4$ fixed for all cases):\n- Test case $1$: $N=101$.\n- Test case $2$: $N=100$.\n- Test case $3$: $N=1200$.\n\nAll computations must be performed in the stated dimensionless units. Your program must produce a single line of output containing the aggregated results as a comma-separated list enclosed in square brackets and ordered as\n$$[\\;A_1,\\ \\varepsilon_{\\max,1},\\ A_2,\\ \\varepsilon_{\\max,2},\\ A_3,\\ \\varepsilon_{\\max,3}\\;],$$\nwhere $A_t$ and $\\varepsilon_{\\max,t}$ denote, respectively, the alternation boolean and the maximum parity-breaking error for test case $t \\in \\{1,2,3\\}$. The booleans must be literal values and the errors must be real numbers. No additional text should be printed.",
            "solution": "The posed problem requires the numerical solution of the one-dimensional, time-independent Schrödinger equation for a quantum harmonic oscillator. The governing equation is\n$$ \\hat{H}\\,\\psi(x) = \\left(-\\frac{\\hbar^2}{2m}\\frac{d^2}{dx^2} + V(x)\\right)\\psi(x) = E\\,\\psi(x) $$\nWe operate in a dimensionless system where $\\hbar=1$ and $m=1$. The potential is the harmonic oscillator potential $V(x) = \\frac{1}{2}x^2$. The problem is defined on a finite interval $x \\in [-L, L]$ with $L=8$, and subject to homogeneous Dirichlet boundary conditions $\\psi(-L) = \\psi(L) = 0$.\n\nThe primary task is to discretize this continuous problem using a second-order finite difference method on a uniform grid and analyze the parity properties of the resulting numerical eigenfunctions. A uniform grid with $N$ interior points is constructed on the interval $[-L, L]$. Including the two boundary points, the grid consists of $N+2$ points, and the grid spacing is $\\Delta x = \\frac{2L}{N+1}$. The interior grid points are located at $x_i = -L + i\\Delta x$ for $i \\in \\{1, 2, \\dots, N\\}$.\n\nThe second derivative of the wavefunction at a grid point $x_i$ is approximated by the second-order central difference formula:\n$$ \\frac{d^2\\psi}{dx^2}\\bigg|_{x_i} \\approx \\frac{\\psi(x_{i-1}) - 2\\psi(x_i) + \\psi(x_{i+1})}{(\\Delta x)^2} $$\nSubstituting this into the Schrödinger equation and letting $\\psi_i = \\psi(x_i)$, we obtain a system of linear equations for the interior points:\n$$ -\\frac{1}{2(\\Delta x)^2} (\\psi_{i-1} - 2\\psi_i + \\psi_{i+1}) + V(x_i)\\psi_i = E\\psi_i $$\nThis system can be expressed as a matrix eigenvalue problem, $H\\vec{\\psi} = E\\vec{\\psi}$, where $\\vec{\\psi}$ is the column vector of wavefunction values $(\\psi_1, \\psi_2, \\dots, \\psi_N)^T$. The $N \\times N$ discretized Hamiltonian matrix $H$ is a real, symmetric, tridiagonal matrix with elements:\n$$\nH_{ij} =\n\\begin{cases}\n\\frac{1}{(\\Delta x)^2} + V(x_i)  \\text{if } i=j \\\\\n-\\frac{1}{2(\\Delta x)^2}  \\text{if } |i-j|=1 \\\\\n0  \\text{otherwise}\n\\end{cases}\n$$\nThe boundary conditions $\\psi_0 = \\psi(-L) = 0$ and $\\psi_{N+1} = \\psi(L) = 0$ are incorporated into the equations for $i=1$ and $i=N$.\n\nThis eigenvalue problem is solved numerically to find the lowest $K=4$ eigenpairs $(E_j, \\vec{\\psi}_j)$. The standard numerical eigensolvers for symmetric matrices, such as `scipy.linalg.eigh`, return eigenvectors that are normalized according to the Euclidean L2-norm, i.e., $\\sum_{i=1}^{N} |v_{j,i}|^2 = 1$. The problem requires normalization to the continuum norm, $\\sum_{i=1}^{N} |\\psi_{j,i}|^2 \\Delta x = 1$. If $v_j$ is the eigenvector from the solver, the correctly normalized eigenvector is $\\psi_j = v_j / \\sqrt{\\Delta x}$.\n\nWith the normalized eigenvectors, we compute the discrete parity overlap, $P_j$. The grid has been constructed such that for any point $x_i$, its reflection $-x_i$ is also a grid point, specifically $-x_i = x_{N+1-i}$. The overlap is defined as:\n$$ P_j = \\sum_{i=1}^{N} \\psi_j(x_i)\\,\\psi_j(-x_i)\\,\\Delta x = \\sum_{i=1}^{N} \\psi_{j,i}\\,\\psi_{j,N+1-i}\\,\\Delta x $$\nSubstituting the normalization $\\psi_{j,i} = v_{j,i}/\\sqrt{\\Delta x}$, we get a simpler expression for calculation:\n$$ P_j = \\sum_{i=1}^{N} \\frac{v_{j,i}}{\\sqrt{\\Delta x}}\\frac{v_{j,N+1-i}}{\\sqrt{\\Delta x}}\\Delta x = \\sum_{i=1}^{N} v_{j,i}\\,v_{j,N+1-i} $$\nThis is the dot product of the solver's eigenvector $v_j$ with its reversed version.\n\nFor a true eigenfunction of a symmetric potential, the parity is definite, meaning $P_j$ would be exactly $+1$ (even) or $-1$ (odd). Numerical discretization, especially on a grid that is not point-symmetric about the origin (which occurs when $N$ is even), can introduce errors that break this symmetry. The parity-breaking error is quantified by $\\varepsilon_j = 1 - |P_j|$. We compute the maximum such error, $\\varepsilon_{\\max}$, over the first $K=4$ states.\n\nFinally, we determine the boolean indicator $A$, which is true if and only if the signs of the parity overlaps for the first $K=4$ states follow the expected alternating sequence for the harmonic oscillator: $\\mathrm{sgn}(P_0)=+1$, $\\mathrm{sgn}(P_1)=-1$, $\\mathrm{sgn}(P_2)=+1$, $\\mathrm{sgn}(P_3)=-1$.\n\nThe algorithm is executed for three test cases: $N=101$ (odd number of points, grid includes the origin), $N=100$ (even), and $N=1200$ (even). The results $[A, \\varepsilon_{\\max}]$ for each case are aggregated into a single output list.",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    test_cases = [101, 100, 1200]\n    L = 8.0\n    K = 4\n    \n    all_results = []\n\n    for N in test_cases:\n        # Step 1: Set up the grid and potential\n        dx = (2 * L) / (N + 1)\n        x_interior = np.linspace(-L + dx, L - dx, N)\n        V_interior = 0.5 * x_interior**2\n\n        # Step 2: Construct the Hamiltonian matrix H\n        diag_elements = 1.0 / (dx**2) + V_interior\n        off_diag_element = -1.0 / (2 * dx**2)\n        \n        H = np.diag(diag_elements)\n        H += np.diag(np.full(N - 1, off_diag_element), k=1)\n        H += np.diag(np.full(N - 1, off_diag_element), k=-1)\n\n        # Step 3: Solve the eigenvalue problem\n        # eigh is for Hermitian matrices and returns sorted eigenvalues\n        # and corresponding eigenvectors as columns.\n        # Eigenvectors are L2-normalized: sum(v_i^2) = 1.\n        eigenvalues, eigenvectors = eigh(H)\n\n        parities = []\n        errors = []\n\n        # Step 4: Analyze the lowest K eigenvectors\n        for j in range(K):\n            # v_j is the eigenvector from the solver\n            v_j = eigenvectors[:, j]\n\n            # As derived, P_j = sum(v_j * reversed(v_j))\n            # The indexing v_j[::-1] reverses the vector.\n            P_j = np.sum(v_j * v_j[::-1])\n            parities.append(P_j)\n\n            # Calculate the parity-breaking error\n            error_j = 1.0 - np.abs(P_j)\n            errors.append(error_j)\n\n        # Step 5: Calculate aggregated results for the test case\n        eps_max = np.max(errors)\n        \n        # Check for the specific alternating sign sequence +1, -1, +1, -1...\n        signs = np.sign(parities)\n        expected_signs = np.array([(-1)**j for j in range(K)])\n        \n        A = np.array_equal(signs, expected_signs)\n\n        all_results.extend([A, eps_max])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While direct diagonalization is effective for small systems, it becomes computationally prohibitive for realistic problems with many degrees of freedom. This advanced practice  introduces a powerful and efficient alternative: the inverse iteration algorithm. You will implement this method to find a specific, high-energy eigenstate of the Hamiltonian without needing to compute the entire spectrum, a technique essential for tackling large-scale eigenvalue problems in computational physics.",
            "id": "2393207",
            "problem": "You are asked to compute a specific high-energy bound-state eigenvalue of the one-dimensional stationary Schrödinger Hamiltonian using finite difference discretization and the inverse iteration algorithm with a shift, without full diagonalization. Work entirely in dimensionless units so that the time-independent Schrödinger equation reads $-\\frac{d^{2}\\psi}{dx^{2}} + V(x)\\,\\psi(x) = E\\,\\psi(x)$ with Dirichlet boundary conditions at the domain endpoints. Your task is to: (i) derive a consistent second-order central finite difference discretization on a uniform grid that yields a real-symmetric tridiagonal Hamiltonian matrix, (ii) implement the inverse iteration algorithm with a real shift to target a particular high-energy eigenpair of interest, and (iii) apply your implementation to the test suite below and report the requested numerical values.\n\nBegin from the following foundational base: the time-independent Schrödinger equation $-\\frac{d^{2}\\psi}{dx^{2}} + V(x)\\,\\psi(x) = E\\,\\psi(x)$ in dimensionless units, the definition of Dirichlet boundary conditions $\\psi(x_{\\min})=\\psi(x_{\\max})=0$, and the standard central finite difference idea that second derivatives are approximated by a linear combination of nearby grid-point values on a uniform mesh of spacing $h$. Do not assume any pre-derived discrete Hamiltonian; instead, derive it explicitly from these principles and definitions. You must explain how to impose the boundary conditions in the discrete system.\n\nImplement the inverse iteration method with a scalar shift $\\,\\sigma\\,$ to target one eigenpair $(E,\\psi)$ nearest to $\\,\\sigma\\,$ as follows: choose an initial nonzero vector, repeatedly solve the linear system $(H-\\sigma I)\\,y^{(k)} = x^{(k)}$, normalize $x^{(k+1)} = y^{(k)}/\\|y^{(k)}\\|_{2}$, and estimate the eigenvalue at each iteration by the Rayleigh quotient $\\rho^{(k)} = \\frac{(x^{(k)})^{T} H x^{(k)}}{(x^{(k)})^{T} x^{(k)}}$. Use the residual norm $\\|H x^{(k)} - \\rho^{(k)} x^{(k)}\\|_{2}$ as a stopping criterion. Your implementation must exploit that $H$ is sparse and tridiagonal.\n\nYou must apply your program to the following test suite. In each case, use a uniform grid of $N$ interior points on the closed interval $[x_{\\min},x_{\\max}]$ with Dirichlet boundary conditions. Construct $V(x)$ pointwise on the interior grid. Use the indicated shift $\\,\\sigma\\,$, and return the converged Rayleigh quotient as the numerical eigenvalue estimate $\\widehat{E}$.\n\n- Test A (particle in a box, analytic spectrum): $[x_{\\min},x_{\\max}] = [0,1]$, $N = 600$, $V(x) \\equiv 0$, target quantum index $n = 30$, shift $\\sigma = \\left(\\frac{n\\pi}{x_{\\max}-x_{\\min}}\\right)^{2}$. The exact continuum energy is $E_{n} = \\left(\\frac{n\\pi}{x_{\\max}-x_{\\min}}\\right)^{2}$. Report two numbers for this test: the numerical eigenvalue $\\widehat{E}_{\\mathrm{box}}$ and the absolute error $|\\widehat{E}_{\\mathrm{box}}-E_{n}|$.\n- Test B (harmonic oscillator, analytic spectrum): $[x_{\\min},x_{\\max}] = [-8,8]$, $N = 800$, $V(x) = x^{2}$, target quantum index $n = 25$, shift $\\sigma = 2n+1$. The exact continuum energy is $E_{n} = 2n+1$. Report two numbers: the numerical eigenvalue $\\widehat{E}_{\\mathrm{ho}}$ and the absolute error $|\\widehat{E}_{\\mathrm{ho}}-E_{n}|$.\n- Test C (double well, no analytic spectrum required): $[x_{\\min},x_{\\max}] = [-6,6]$, $N = 800$, $V(x) = (x^{2}-4)^{2}$, shift $\\sigma = 30$. Report one number: the numerical eigenvalue $\\widehat{E}_{\\mathrm{dw}}$.\n\nYour program must output a single line containing a comma-separated Python-style list with the results in the following order:\n$[\\widehat{E}_{\\mathrm{box}},\\ |\\widehat{E}_{\\mathrm{box}}-E_{n}|,\\ \\widehat{E}_{\\mathrm{ho}},\\ |\\widehat{E}_{\\mathrm{ho}}-E_{n}|,\\ \\widehat{E}_{\\mathrm{dw}}]$.\nAll five entries must be real numbers. No physical units are required because the problem is fully nondimensionalized. The final line must be printed exactly as text representing the list (for example, $[1.0,2.0,3.0,4.0,5.0]$).",
            "solution": "The problem presented is a standard exercise in computational quantum mechanics and is well-posed, scientifically grounded, and internally consistent. We shall proceed with its solution by first deriving the necessary discrete formalism from fundamental principles, and then outlining the numerical algorithm for implementation.\n\nThe objective is to find a numerical approximation to a specific eigenpair $(E, \\psi)$ of the one-dimensional, time-independent Schrödinger equation in dimensionless units:\n$$\n-\\frac{d^2\\psi}{dx^2} + V(x)\\psi(x) = E\\psi(x)\n$$\nThe wavefunction $\\psi(x)$ is subject to Dirichlet boundary conditions, $\\psi(x_{\\min}) = 0$ and $\\psi(x_{\\max}) = 0$.\n\n**Part 1: Finite Difference Discretization of the Hamiltonian**\n\nWe first transform the continuous differential operator, the Hamiltonian $H = -\\frac{d^2}{dx^2} + V(x)$, into a discrete matrix representation. We define a uniform grid on the domain $[x_{\\min}, x_{\\max}]$. Let there be $N$ interior grid points. This divides the interval into $N+1$ subintervals of equal width $h$. The grid spacing is thus $h = (x_{\\max} - x_{\\min})/(N+1)$. The grid points are located at $x_j = x_{\\min} + j \\cdot h$ for $j = 0, 1, \\dots, N+1$. The interior points, where we seek to find the wavefunction, are $x_1, \\dots, x_N$. The value of the wavefunction at a grid point $x_j$ is denoted by $\\psi_j \\equiv \\psi(x_j)$. The boundary conditions impose $\\psi_0 = 0$ and $\\psi_{N+1} = 0$.\n\nThe second derivative operator $\\frac{d^2}{dx^2}$ is approximated using a second-order central difference formula. This formula is derived from the Taylor series expansion of $\\psi(x)$ around a point $x_j$:\n$$\n\\psi(x_j \\pm h) = \\psi(x_j) \\pm h\\frac{d\\psi}{dx}\\bigg|_{x_j} + \\frac{h^2}{2!}\\frac{d^2\\psi}{dx^2}\\bigg|_{x_j} \\pm \\frac{h^3}{3!}\\frac{d^3\\psi}{dx^3}\\bigg|_{x_j} + O(h^4)\n$$\nSumming the expressions for $\\psi(x_j+h)$ and $\\psi(x_j-h)$ causes the odd-order derivative terms to cancel:\n$$\n\\psi(x_j+h) + \\psi(x_j-h) = 2\\psi(x_j) + h^2\\frac{d^2\\psi}{dx^2}\\bigg|_{x_j} + O(h^4)\n$$\nRearranging for the second derivative, we obtain the approximation:\n$$\n\\frac{d^2\\psi}{dx^2}\\bigg|_{x_j} = \\frac{\\psi(x_{j+1}) - 2\\psi(x_j) + \\psi(x_{j-1})}{h^2} + O(h^2)\n$$\nThis is a second-order accurate approximation. Substituting this into the Schrödinger equation for each interior grid point $x_j$ (where $j=1, \\dots, N$):\n$$\n-\\frac{\\psi_{j+1} - 2\\psi_j + \\psi_{j-1}}{h^2} + V(x_j)\\psi_j = E\\psi_j\n$$\nRearranging this equation isolates the terms associated with the linear operator on the left-hand side:\n$$\n-\\frac{1}{h^2}\\psi_{j-1} + \\left(\\frac{2}{h^2} + V_j\\right)\\psi_j - \\frac{1}{h^2}\\psi_{j+1} = E\\psi_j\n$$\nwhere we have defined $V_j \\equiv V(x_j)$. This system of $N$ linear equations can be written in matrix eigenvalue form, $H\\vec{\\psi} = E\\vec{\\psi}$, where $\\vec{\\psi} = [\\psi_1, \\psi_2, \\dots, \\psi_N]^T$ is the vector of wavefunction values at the interior points.\n\nLet us examine the equations for the boundary-adjacent points:\nFor $j=1$: $-\\frac{1}{h^2}\\psi_0 + (\\frac{2}{h^2} + V_1)\\psi_1 - \\frac{1}{h^2}\\psi_2 = E\\psi_1$. With $\\psi_0=0$, this becomes $(\\frac{2}{h^2} + V_1)\\psi_1 - \\frac{1}{h^2}\\psi_2 = E\\psi_1$.\nFor $j=N$: $-\\frac{1}{h^2}\\psi_{N-1} + (\\frac{2}{h^2} + V_N)\\psi_N - \\frac{1}{h^2}\\psi_{N+1} = E\\psi_N$. With $\\psi_{N+1}=0$, this becomes $-\\frac{1}{h^2}\\psi_{N-1} + (\\frac{2}{h^2} + V_N)\\psi_N = E\\psi_N$.\n\nThese equations define the elements of the $N \\times N$ discrete Hamiltonian matrix $H$:\n-   Diagonal elements: $H_{j,j} = \\frac{2}{h^2} + V_j$ for $j=1, \\dots, N$.\n-   Off-diagonal elements: $H_{j,j+1} = H_{j+1,j} = -\\frac{1}{h^2}$ for $j=1, \\dots, N-1$.\n-   All other elements are zero.\n\nThe resulting matrix $H$ is a real, symmetric, and tridiagonal matrix, as required.\n\n**Part 2: The Shifted Inverse Iteration Algorithm**\n\nTo find a specific eigenpair $(E, \\vec{\\psi})$ whose eigenvalue $E$ is closest to a given real shift $\\sigma$, we employ the inverse iteration algorithm with shift. This is a powerful technique that avoids the computationally expensive full diagonalization of the matrix $H$. The method is equivalent to applying the power method to the matrix $(H - \\sigma I)^{-1}$. The eigenvalues of $(H - \\sigma I)^{-1}$ are $(\\lambda_i - \\sigma)^{-1}$, where $\\lambda_i$ are the eigenvalues of $H$. The eigenvector corresponding to the eigenvalue $(\\lambda_k - \\sigma)^{-1}$ with the largest magnitude is the same as the eigenvector of $H$ corresponding to the eigenvalue $\\lambda_k$ that is closest to $\\sigma$.\n\nThe algorithm proceeds as follows:\n1.  Choose an initial, nonzero random vector $\\vec{x}^{(0)}$ of size $N$. Normalize it: $\\vec{x}^{(0)} \\leftarrow \\vec{x}^{(0)}/\\|\\vec{x}^{(0)}\\|_2$.\n2.  For $k=0, 1, 2, \\dots$ until convergence:\n    a. Solve the linear system $(H - \\sigma I)\\vec{y}^{(k)} = \\vec{x}^{(k)}$ for the vector $\\vec{y}^{(k)}$.\n    b. Normalize the resulting vector to obtain the next approximation of the eigenvector: $\\vec{x}^{(k+1)} = \\vec{y}^{(k)}/\\|\\vec{y}^{(k)}\\|_2$.\n3.  The sequence of vectors $\\vec{x}^{(k)}$ converges to the desired eigenvector.\n\nThe matrix $A = H - \\sigma I$ is also tridiagonal and symmetric. The critical step, solving $A\\vec{y}^{(k)} = \\vec{x}^{(k)}$, can be performed very efficiently in $O(N)$ operations using a specialized tridiagonal solver, such as the Thomas algorithm, rather than general $O(N^3)$ matrix inversion.\n\nAt each iteration $k$, the corresponding eigenvalue $E$ is estimated using the Rayleigh quotient:\n$$\n\\rho^{(k+1)} = \\frac{(\\vec{x}^{(k+1)})^T H \\vec{x}^{(k+1)}}{(\\vec{x}^{(k+1)})^T \\vec{x}^{(k+1)}} = (\\vec{x}^{(k+1)})^T H \\vec{x}^{(k+1)}\n$$\nThe second equality holds because $\\vec{x}^{(k+1)}$ is unit-normalized.\n\nConvergence is achieved when the state ceases to change significantly. A robust stopping criterion is that the norm of the residual vector falls below a small tolerance $\\epsilon$:\n$$\n\\|H\\vec{x}^{(k+1)} - \\rho^{(k+1)}\\vec{x}^{(k+1)}\\|_2  \\epsilon\n$$\nFor the implementation, a tolerance on the order of $\\epsilon = 10^{-12}$ is appropriate.\n\n**Part 3: Application to Test Cases**\n\nThe derived methodology is now applied to the three specified test cases. For each case, we construct the grid, potential vector $V_j$, and the tridiagonal Hamiltonian $H$. Then, using the provided shift $\\sigma$, we execute the inverse iteration algorithm to find the converged Rayleigh quotient, which is our numerical eigenvalue estimate $\\widehat{E}$. For tests A and B, this numerical result is compared against the known analytical energy to compute the absolute error. The implementation will use library functions optimized for tridiagonal systems to ensure computational efficiency.",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef compute_eigenvalue(\n    x_min: float,\n    x_max: float,\n    N: int,\n    V_func,\n    sigma: float,\n    max_iter: int = 100,\n    tolerance: float = 1e-12,\n):\n    \"\"\"\n    Computes an eigenvalue of the 1D Schrödinger equation near a shift sigma.\n\n    Args:\n        x_min: Minimum of the spatial domain.\n        x_max: Maximum of the spatial domain.\n        N: Number of interior grid points.\n        V_func: A function that takes a numpy array of x values and returns the potential.\n        sigma: The energy shift for the inverse iteration.\n        max_iter: Maximum number of iterations.\n        tolerance: Convergence tolerance for the residual norm.\n\n    Returns:\n        The converged eigenvalue estimate.\n    \"\"\"\n    # 1. Set up the grid\n    h = (x_max - x_min) / (N + 1)\n    x_grid = np.linspace(x_min, x_max, N + 2)[1:-1] # Interior points\n\n    # 2. Construct the Hamiltonian matrix H's diagonals\n    V_values = V_func(x_grid)\n    main_diag_H = 2.0 / h**2 + V_values\n    off_diag_H_val = -1.0 / h**2\n\n    # 3. Set up the matrix for the linear system in inverse iteration: A = H - sigma*I\n    # Scipy's solve_banded requires the matrix in a specific banded format.\n    # For a symmetric tridiagonal matrix (l=1, u=1), the 'ab' array has shape (2, N).\n    # ab[0, 1:] is the upper diagonal, ab[1, :] is the main diagonal.\n    # Since our matrix H - sigma*I is symmetric, we can represent it this way.\n    # However, for clarity and generality, we use the (l+u+1, N) format where l=1, u=1.\n    ab_shifted = np.zeros((3, N))\n    ab_shifted[0, 1:] = off_diag_H_val  # Super-diagonal\n    ab_shifted[1, :]  = main_diag_H - sigma  # Main diagonal\n    ab_shifted[2, :-1] = off_diag_H_val  # Sub-diagonal\n    \n    # 4. Inverse Iteration\n    # Initialize a random normalized vector\n    x_k = np.random.rand(N)\n    x_k /= np.linalg.norm(x_k)\n\n    converged_eigenvalue = 0.0\n    for _ in range(max_iter):\n        # a. Solve (H - sigma*I) * y_k = x_k\n        y_k = solve_banded((1, 1), ab_shifted, x_k)\n\n        # b. Normalize to get the next eigenvector approximation\n        norm_y = np.linalg.norm(y_k)\n        if norm_y == 0:\n            # This should not happen with a proper shift\n            raise RuntimeError(\"Norm of iterate is zero, cannot normalize.\")\n        x_k_plus_1 = y_k / norm_y\n        \n        # c. Calculate Rayleigh quotient for the eigenvalue estimate\n        # H*x can be calculated efficiently without forming the full matrix H\n        Hx = np.zeros(N)\n        Hx[1:-1] = (off_diag_H_val * x_k_plus_1[:-2] +\n                    main_diag_H[1:-1] * x_k_plus_1[1:-1] +\n                    off_diag_H_val * x_k_plus_1[2:])\n        Hx[0] = main_diag_H[0] * x_k_plus_1[0] + off_diag_H_val * x_k_plus_1[1]\n        Hx[-1] = off_diag_H_val * x_k_plus_1[-2] + main_diag_H[-1] * x_k_plus_1[-1]\n        \n        rho = np.dot(x_k_plus_1, Hx)\n        converged_eigenvalue = rho\n\n        # d. Check for convergence using the residual norm\n        residual_norm = np.linalg.norm(Hx - rho * x_k_plus_1)\n        if residual_norm  tolerance:\n            break\n\n        x_k = x_k_plus_1\n    \n    return converged_eigenvalue\n\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    results = []\n\n    # Test A: Particle in a box\n    x_min_a, x_max_a = 0.0, 1.0\n    N_a = 600\n    n_a = 30\n    V_a = lambda x: 0.0 * x  # Potential is zero everywhere\n    L_a = x_max_a - x_min_a\n    E_analytic_a = (n_a * np.pi / L_a)**2\n    sigma_a = E_analytic_a\n    \n    E_hat_box = compute_eigenvalue(x_min_a, x_max_a, N_a, V_a, sigma_a)\n    error_box = abs(E_hat_box - E_analytic_a)\n    results.append(E_hat_box)\n    results.append(error_box)\n    \n    # Test B: Harmonic oscillator\n    x_min_b, x_max_b = -8.0, 8.0\n    N_b = 800\n    n_b = 25\n    V_b = lambda x: x**2\n    E_analytic_b = 2.0 * n_b + 1.0\n    sigma_b = E_analytic_b\n    \n    E_hat_ho = compute_eigenvalue(x_min_b, x_max_b, N_b, V_b, sigma_b)\n    error_ho = abs(E_hat_ho - E_analytic_b)\n    results.append(E_hat_ho)\n    results.append(error_ho)\n\n    # Test C: Double well potential\n    x_min_c, x_max_c = -6.0, 6.0\n    N_c = 800\n    V_c = lambda x: (x**2 - 4.0)**2\n    sigma_c = 30.0\n\n    E_hat_dw = compute_eigenvalue(x_min_c, x_max_c, N_c, V_c, sigma_c)\n    results.append(E_hat_dw)\n    \n    # Print the final result in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}