{
    "hands_on_practices": [
        {
            "introduction": "我们的实践之旅将从量子散射中最经典的模型——矩形势垒开始。尽管这个模型很简单，但它却是理解量子隧穿、反射和透射等核心概念的基石。这个练习将引导你计算透射概率 $T$ 和一个重要的物理量——相移 $\\phi$。由于该问题存在精确的解析解，因此它是检验你的代码、建立物理直觉的绝佳起点 。",
            "id": "2432157",
            "problem": "一个质量为 $m$ 的非相对论性量子粒子从一维分段常数势发生弹性散射。在无量纲单位下进行计算，使得 $\\hbar = 1$ 且 $\\frac{\\hbar^{2}}{2m} = 1$，因此定态薛定谔方程为\n$$\n-\\frac{d^{2}\\psi(x)}{dx^{2}} + V(x)\\,\\psi(x) = E\\,\\psi(x),\n$$\n其中总能量 $E > 0$。考虑以下势：\n$$\nV(x) = \\begin{cases}\nV_{0},   0 \\le x \\le L, \\\\\n0,   \\text{otherwise},\n\\end{cases}\n$$\n其中 $V_{0}$ 和 $L$ 是实数参数，并且 $E - V_{0} > 0$，以确保该区域内的波数为实数。设一个单位振幅的平面波从左侧 ($x \\to -\\infty$) 入射，通过在 $x \\to +\\infty$ 处的渐近透射波 $\\psi(x) \\sim t\\,e^{i k x}$ 来定义复透射振幅 $t$，其中 $k = \\sqrt{E}$ 是自由区域中的波数。\n\n定义透射概率 $T$ 为透射振幅的模平方，\n$$\nT = |t|^{2}.\n$$\n定义透射波相对于在长度为 $L$ 的区间上自由传播的相移 $\\phi$ 为\n$$\n\\phi = \\operatorname{Arg}(t) + k L,\n$$\n其中 $\\operatorname{Arg}(\\cdot)$ 表示复数辐角的主值。要求的角度单位是弧度，并且 $\\phi$ 必须在其主值范围 $(-\\pi,\\pi]$ 内报告。\n\n您的任务是编写一个完整的程序，对于下面测试套件中的每个参数三元组 $(E, V_{0}, L)$，根据上述势的精确定态散射解计算 $T$ 和 $\\phi$。所有计算都应在指定的无量纲单位下进行。\n\n测试套件（每行为一个三元组 $(E, V_{0}, L)$）：\n- $(1.0, 0.0, 10.0)$\n- $(1.0, 0.01, 100.0)$\n- $(0.5, 0.001, 500.0)$\n- $(1.0, -0.02, 200.0)$\n- $(2.0, 10^{-6}, 10^{-3})$\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的浮点数逗号分隔列表，没有空格，顺序为 $[T_{1},\\phi_{1},T_{2},\\phi_{2},\\dots]$，与上面列出的测试套件相对应。每个 $\\phi_{j}$ 必须以弧度表示，并在主值范围 $(-\\pi,\\pi]$ 内。",
            "solution": "该问题是有效的。这是一维量子散射理论中的一个标准练习，基于量子力学的基本原理。所有用于计算的参数和量都已精确定义且科学上合理。我们着手解决它。\n\n分析始于无量纲单位下的不含时薛定谔方程（$\\hbar = 1, \\hbar^2/(2m) = 1$）：\n$$\n-\\frac{d^2\\psi(x)}{dx^2} + V(x)\\psi(x) = E\\psi(x)\n$$\n势 $V(x)$ 是一个矩形势垒：\n$$\nV(x) = \\begin{cases}\nV_{0},   0 \\le x \\le L \\\\\n0,   \\text{otherwise}\n\\end{cases}\n$$\n我们在三个不同的空间区域求解这个方程：区域 I ($x  0$)、区域 II ($0 \\le x \\le L$) 和区域 III ($x > L$) 。\n\n在区域 I 和 III 中，势 $V(x) = 0$。薛定谔方程变为 $\\frac{d^2\\psi}{dx^2} = -E\\psi$。根据定义 $k = \\sqrt{E}$，解是平面波。\n- 在区域 I 中，我们有一个从 $x \\to -\\infty$ 入射的单位振幅波和一个向左移动的反射波。波函数是：\n$$\n\\psi_I(x) = e^{ikx} + r e^{-ikx}\n$$\n其中 $r$ 是复反射振幅。\n- 在区域 III 中，只有一个向右移动的透射波。波函数是：\n$$\n\\psi_{III}(x) = t e^{ikx}\n$$\n其中 $t$ 是我们寻求的复透射振幅。\n\n在区域 II 中，势为 $V(x) = V_0$。薛定谔方程为 $\\frac{d^2\\psi}{dx^2} = -(E - V_0)\\psi$。问题规定 $E - V_0 > 0$，因此我们定义一个实波数 $q = \\sqrt{E - V_0}$。通解是：\n$$\n\\psi_{II}(x) = F e^{iqx} + G e^{-iqx}\n$$\n\n为了确定未知振幅 $r, t, F, G$，我们应用边界条件，即波函数 $\\psi(x)$ 及其导数 $\\psi'(x)$ 在边界 $x=0$ 和 $x=L$ 处必须连续。\n1. $\\psi_I(0) = \\psi_{II}(0) \\implies 1 + r = F + G$\n2. $\\psi'_I(0) = \\psi'_{II}(0) \\implies ik(1 - r) = iq(F - G)$\n3. $\\psi_{II}(L) = \\psi_{III}(L) \\implies F e^{iqL} + G e^{-iqL} = t e^{ikL}$\n4. $\\psi'_{II}(L) = \\psi'_{III}(L) \\implies iq(F e^{iqL} - G e^{-iqL}) = ik(t e^{ikL})$\n\n求解这个包含四个未知数的四元线性方程组，可以得到透射振幅 $t$。一个系统的方法，例如使用传输矩阵法，会得出以下 $t$ 的表达式：\n$$\nt = \\frac{e^{-ikL}}{\\cos(qL) - i \\frac{k^2+q^2}{2kq} \\sin(qL)}\n$$\n只要 $E-V_0 > 0$，该公式对任何实数 $V_0$ 都有效。在 $V_0 = 0$ 的特殊情况下，我们有 $q=k$，表达式正确地简化为 $t=1$，表示没有散射。\n\n有了 $t$ 的表达式，我们就可以计算所需的物理量。透射概率 $T$ 定义为 $T = |t|^2$。\n$$\nT = |t|^2 = \\frac{|e^{-ikL}|^2}{\\left|\\cos(qL) - i \\frac{k^2+q^2}{2kq} \\sin(qL)\\right|^2} = \\frac{1}{\\cos^2(qL) + \\left(\\frac{k^2+q^2}{2kq}\\right)^2 \\sin^2(qL)}\n$$\n使用恒等式 $\\cos^2\\theta = 1 - \\sin^2\\theta$ 和代数运算，这可以表示为更常见的形式：\n$$\nT = \\left( 1 + \\left(\\frac{k^2-q^2}{2kq}\\right)^2 \\sin^2(qL) \\right)^{-1}\n$$\n代入 $k^2 = E$ 和 $q^2 = E-V_0$，这变为：\n$$\nT = \\left( 1 + \\frac{V_0^2}{4E(E-V_0)} \\sin^2(L\\sqrt{E-V_0}) \\right)^{-1}\n$$\n\n相移 $\\phi$ 在问题中明确定义为 $\\phi = \\operatorname{Arg}(t) + kL$，其中 $\\operatorname{Arg}(\\cdot)$ 是复数辐角的主值。这个定义代表了量 $t e^{ikL}$ 的相位。我们计算这个量：\n$$\nt e^{ikL} = \\left( \\frac{e^{-ikL}}{\\cos(qL) - i \\frac{k^2+q^2}{2kq} \\sin(qL)} \\right) e^{ikL} = \\frac{1}{\\cos(qL) - i \\frac{k^2+q^2}{2kq} \\sin(qL)}\n$$\n设分母为 $Z = \\cos(qL) - i \\frac{k^2+q^2}{2kq} \\sin(qL)$。那么 $t e^{ikL} = 1/Z$。\n因此相移为：\n$$\n\\phi = \\operatorname{Arg}\\left(\\frac{1}{Z}\\right) = -\\operatorname{Arg}(Z)\n$$\n$\\phi$ 的值必须在主值范围 $(-\\pi, \\pi]$ 内报告。\n为便于计算，$Z$ 是一个复数 $X+iY$，其中 $X = \\cos(qL)$，$Y = -\\frac{k^2+q^2}{2kq}\\sin(qL)$。相位 $\\phi$ 计算为 $-\\operatorname{atan2}(Y, X)$，这会自动产生一个在正确范围内的结果。\n\n程序的算法如下：对于每个参数集 $(E, V_0, L)$：\n1. 计算波数 $k = \\sqrt{E}$ 和 $q = \\sqrt{E-V_0}$。\n2. 如果 $V_0=0.0$，则 $T=1.0$。复数 $Z$ 变为 $e^{-ikL}$，因此 $\\phi = -\\operatorname{Arg}(e^{-ikL})$。这等效于将 $kL$ 映射到范围 $(-\\pi, \\pi]$。\n3. 如果 $V_0 \\neq 0.0$，使用其推导出的公式计算 $T$。\n4. 计算如上定义的复数 $Z$ 的实部和虚部。\n5. 将 $\\phi$ 计算为 $Z$ 的主辐角的负值。\n然后将结果格式化为单个逗号分隔的列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the transmission probability T and phase shift phi for a quantum particle\n    scattering from a one-dimensional rectangular potential barrier.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1.0, 0.0, 10.0),\n        (1.0, 0.01, 100.0),\n        (0.5, 0.001, 500.0),\n        (1.0, -0.02, 200.0),\n        (2.0, 1e-6, 1e-3)\n    ]\n\n    results = []\n    for E, V0, L in test_cases:\n        # Per dimensionless units, ħ²/2m = 1.\n        # Wavenumber in free regions (V=0): k = sqrt(E).\n        k = np.sqrt(E)\n\n        # Handle the trivial case of no potential barrier.\n        if V0 == 0.0:\n            T = 1.0\n            # From the problem definition, phi = Arg(t) + kL.\n            # For V0=0, t=1, so phi = Arg(1) + kL = kL.\n            # We must map this to the principal value range (-pi, pi].\n            # This is equivalent to taking the angle of the complex exponential exp(i*k*L).\n            phi = np.angle(np.exp(1j * k * L))\n        else:\n            # The condition E - V0 > 0 is guaranteed by the problem statement.\n            # Wavenumber inside the potential region: q = sqrt(E - V0).\n            q_squared = E - V0\n            q = np.sqrt(q_squared)\n            \n            # --- Calculate Transmission Probability T ---\n            # Formula is T = (1 + (V0^2 * sin^2(qL)) / (4*E*(E-V0)))^-1\n            sin_qL = np.sin(q * L)\n            T_inv = 1.0 + (V0**2 * sin_qL**2) / (4.0 * E * q_squared)\n            T = 1.0 / T_inv\n\n            # --- Calculate Phase Shift phi ---\n            # The problem defines phi = Arg(t) + kL, which is equivalent to phi = Arg(t * exp(i*k*L)).\n            # The derived expression for t * exp(i*k*L) is 1/Z, where\n            # Z = cos(qL) - i * (k^2+q^2)/(2*k*q) * sin(qL).\n            # Therefore, phi = Arg(1/Z) = -Arg(Z).\n            cos_qL = np.cos(q * L)\n            \n            # Real and imaginary parts of the complex number Z\n            real_part_z = cos_qL\n            imag_part_z = - (k**2 + q_squared) / (2 * k * q) * sin_qL\n            \n            z = complex(real_part_z, imag_part_z)\n            phi = -np.angle(z)\n\n        results.append(T)\n        results.append(phi)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了基础的矩形势垒后，我们将更进一步，处理任意形状的复杂势垒。当势垒形状复杂、没有简单的解析解时，我们需要一种更普适的数值方法。“传输矩阵法”就是这样一种强大的工具。在这个练习中，你将通过将一个连续变化的势垒切分成许多微小的矩形薄片，并“链接”它们各自的散射效应，来计算总的透射率 。",
            "id": "2432228",
            "problem": "一维空间中一个质量为 $m$ 的非相对论量子粒子，由不含时薛定谔方程描述，从一个长度为 $L$ 的有限势垒区域散射。在该区域内，势能是一个高度为 $V_0$ 的基础势垒上叠加了一个正弦波纹。势垒占据 $x \\in [0,L]$ 区间，其势为 $V(x) = V_0 + A \\sin(k x)$，而在势垒外部，即 $x  0$ 和 $x > L$ 时，势为零 $V(x) = 0$。使用由 $\\hbar^2/(2m) = 1$ 定义的无量纲单位，从而能量和长度均为无量纲，且局域波数满足 $q(x) = \\sqrt{E - V(x)}$，对于经典禁区，使用复数平方根的主支。粒子以能量 $E > 0$ 从左侧入射，我们关心的物理量是透射系数 $T(E)$，其定义为远离势垒处透射概率流与入射概率流之比。\n\n从不含时薛定谔方程\n$$\n-\\frac{d^2\\psi(x)}{dx^2} + V(x)\\,\\psi(x) = E\\,\\psi(x),\n$$\n以及概率流 $J(x)$ 的定义、波函数 $\\psi(x)$ 及其一阶导数 $d\\psi/dx$ 在常数势区域之间界面处的连续性出发，推导一种数值稳定的计算方法，以获得给定势垒的透射系数 $T(E)$。你的推导必须从这些基本要素开始，最终得出一个算法，该算法通过组合势垒的许多薄均匀切片效应来连接左右两侧的渐近波幅，并强制仅从左侧入射。使用复值局域波数处理经典禁戒切片，并确保渐近区域之间正确的流量归一化。你必须采用一种数值上稳健的程序来处理转折点的存在，该程序能在切片边界处 $E \\approx V(x)$ 时避免奇点。\n\n将你的方法实现为一个完整、可运行的程序，该程序：\n- 将势垒 $[0,L]$ 离散化为 $N$ 个等宽的薄切片，并在每个切片中将 $V(x)$ 近似为常数（在切片中心计算 $V(x)$）。\n- 组合 $2\\times 2$ 传输操作，这些操作强制跨切片界面的连续性和切片内的传播，以获得入射和出射平面波振幅之间的总映射。\n- 通过适当的流归一化，从组合的映射中计算透射系数 $T(E)$。在局域波数的数值计算中，向能量 $E$ 添加一个微小的正虚数调节子 $+\\mathrm{i}\\eta$（其中 $\\eta$ 为严格正数且 $\\eta \\ll 1$），以避免在 $E \\approx V(x)$ 处的奇点，并实现正确的出射波条件。\n- 使用固定的势垒长度 $L = 1$。\n- 使用足够精细的离散化 $N$ 来解析测试套件中最大 $k$ 值的波纹，同时保持数值稳定性。为所有测试用例选择一个单一的 $N$ 值。\n\n你的程序必须计算下面指定测试套件中每个能量的 $T(E)$，并将每个报告的透射系数四舍五入到 $6$ 位小数。\n\n测试套件（每个测试用例是在上述单位下的一个元组 $(V_0,A,k,L,\\{E\\text{ 列表}\\})$；此处所有情况下 $L=1$）：\n- 案例 1（理想情况，中等波纹）：$(V_0,A,k,L,\\{E\\}) = (\\,0.5\\,,\\,0.1\\,,\\,16\\pi\\,,\\,1\\,,\\,\\{0.2, 0.5, 0.8, 1.2\\}\\,)$。\n- 案例 2（边界情况，无波纹简化为方势垒）：$(V_0,A,k,L,\\{E\\}) = (\\,0.6\\,,\\,0.0\\,,\\,6\\pi\\,,\\,1\\,,\\,\\{0.2, 0.61, 1.0\\}\\,)$。\n- 案例 3（边缘情况，快速波纹）：$(V_0,A,k,L,\\{E\\}) = (\\,0.4\\,,\\,0.2\\,,\\,40\\pi\\,,\\,1\\,,\\,\\{0.3, 0.7\\}\\,)$。\n- 案例 4（边缘情况，无基础势垒的波纹）：$(V_0,A,k,L,\\{E\\}) = (\\,0.0\\,,\\,0.3\\,,\\,8\\pi\\,,\\,1\\,,\\,\\{0.05, 0.2, 0.5\\}\\,)$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素对应一个测试用例，其本身是该案例中各能量的透射系数列表，顺序与上文所列相同。例如，输出必须看起来像\n$[[$t_{1,1}$,$t_{1,2}$,\\dots],[$t_{2,1}$,\\dots],\\dots]$,\n其中每个 $t_{i,j}$ 是一个四舍五入到 $6$ 位小数的浮点数。",
            "solution": "所提出的问题是一维量子散射理论中的一个标准练习，其表述在科学上是合理的、提法是恰当且完整的。因此，它被认为是一个有效的问题。我们按规定，基于传输矩阵法对数值解进行严格推导。\n\n我们的出发点是质量为 $m$、能量为 $E$ 的粒子在势 $V(x)$ 中的不含时薛定谔方程：\n$$\n-\\frac{\\hbar^2}{2m} \\frac{d^2\\psi(x)}{dx^2} + V(x)\\,\\psi(x) = E\\,\\psi(x)\n$$\n使用指定的无量纲单位，其中 $\\hbar^2/(2m) = 1$，方程简化为：\n$$\n-\\frac{d^2\\psi(x)}{dx^2} + V(x)\\,\\psi(x) = E\\,\\psi(x) \\quad \\implies \\quad \\frac{d^2\\psi(x)}{dx^2} + (E - V(x))\\,\\psi(x) = 0\n$$\n我们定义局域波数 $q(x) = \\sqrt{E - V(x)}$。问题指定使用一个微小的正虚数调节子 $\\eta$，因此我们将 $E$ 替换为复能量 $E_{comp} = E + i\\eta$。这确保了局域波数 $q(x) = \\sqrt{E_{comp} - V(x)}$ 永远不为零，从而解决了在经典转折点 $E = V(x)$ 处可能出现的奇点问题。这里使用复数平方根的主支。\n\n该数值方法的核心是将势垒区域 $x \\in [0, L]$ 离散化为 $N$ 个等宽 $\\Delta x = L/N$ 的连续切片。在每个从 $x_j = j\\Delta x$ 延伸到 $x_{j+1} = (j+1)\\Delta x$ 的切片 $j$ 内，我们将势 $V(x)$ 近似为一个常数 $V_j$，该常数在切片中点计算：$V_j = V(x_j + \\Delta x/2)$。因此，局域波数在每个切片内也是恒定的，记为 $q_j = \\sqrt{E_{comp} - V_j}$。\n\n在势为常数的切片 $j$ 中，薛定谔方程是一个简谐振子方程：\n$$\n\\frac{d^2\\psi(x)}{dx^2} + q_j^2\\,\\psi(x) = 0\n$$\n该切片内 $\\psi(x)$ 的通解是振荡函数或指数函数的线性组合，可以用切片起始点 $x_j$ 的初始条件来表示。系统在任意点 $x$ 的状态可以用一个包含波函数及其导数的矢量来描述：$\\vec{\\Psi}(x) = \\begin{pmatrix} \\psi(x) \\\\ \\psi'(x) \\end{pmatrix}$。\n\n给定切片起始点 $x_j$ 的状态，切片内任意点 $x$ 处的解为：\n$$\n\\psi(x) = \\psi(x_j)\\cos(q_j(x-x_j)) + \\frac{\\psi'(x_j)}{q_j}\\sin(q_j(x-x_j))\n$$\n$$\n\\psi'(x) = -q_j\\psi(x_j)\\sin(q_j(x-x_j)) + \\psi'(x_j)\\cos(q_j(x-x_j))\n$$\n在切片末端 $x = x_{j+1} = x_j + \\Delta x$ 处计算，我们得到切片边界处状态矢量之间的线性关系：$\\vec{\\Psi}(x_{j+1}) = P_j \\vec{\\Psi}(x_j)$。矩阵 $P_j$ 是切片 $j$ 的传播矩阵或传输矩阵：\n$$\nP_j = \\begin{pmatrix} \\cos(q_j \\Delta x)  \\frac{\\sin(q_j \\Delta x)}{q_j} \\\\ -q_j \\sin(q_j \\Delta x)  \\cos(q_j \\Delta x) \\end{pmatrix}\n$$\n使用复数调节子 $\\eta$ 确保 $q_j \\neq 0$，因此项 $\\sin(q_j \\Delta x)/q_j$ 总是良定义的。\n\n由于波函数 $\\psi(x)$ 及其导数 $\\psi'(x)$ 必须处处连续，状态矢量 $\\vec{\\Psi}(x)$ 在切片之间的边界上是连续的。因此，要找到 $x=0$ 和 $x=L$ 处状态之间的关系，我们只需按顺序组合所有切片的传输矩阵：\n$$\n\\vec{\\Psi}(L) = P_{N-1} P_{N-2} \\cdots P_1 P_0 \\vec{\\Psi}(0)\n$$\n设势垒的总传输矩阵为 $M = P_{N-1} P_{N-2} \\cdots P_0$。则 $\\vec{\\Psi}(L) = M \\vec{\\Psi}(0)$。每个 $P_j$ 的行列式为 $\\cos^2(q_j \\Delta x) + \\sin^2(q_j \\Delta x) = 1$，因此总矩阵 $M$ 也是幺模的，即 $\\det(M)=1$。\n\n接下来，我们将势垒边界处的状态矢量与渐近平面波解联系起来。粒子从左侧入射。\n对于 $x  0$ (I区)，$V(x)=0$。波函数是入射波和反射波的叠加：\n$\\psi_I(x) = A e^{i k_0 x} + B e^{-i k_0 x}$，其中 $k_0 = \\sqrt{E_{comp}}$。\n对于 $x > L$ (III区)，$V(x)=0$。波函数只包含透射波：\n$\\psi_{III}(x) = C e^{i k_0 (x-L)}$。为方便起见，在 $x=L$ 处选择此相位。\n\n根据这些形式，我们计算在 $x=0$ 和 $x=L$ 处的状态矢量：\n在 $x=0$ 处：$\\psi(0) = A+B$ 和 $\\psi'(0) = i k_0 (A-B)$。\n在 $x=L$ 处：$\\psi(L) = C$ 和 $\\psi'(L) = i k_0 C$。\n\n现在我们可以通过对总传输矩阵关系式 $\\vec{\\Psi}(0) = M^{-1} \\vec{\\Psi}(L)$ 求逆，用透射振幅 $C$ 来表示渐近振幅 $(A, B)$。由于 $\\det(M)=1$，逆矩阵很简单：\n$M^{-1} = \\begin{pmatrix} M_{22}  -M_{12} \\\\ -M_{21}  M_{11} \\end{pmatrix}$。\n代入边界条件：\n$$\n\\begin{pmatrix} A+B \\\\ i k_0 (A-B) \\end{pmatrix} = \\begin{pmatrix} M_{22}  -M_{12} \\\\ -M_{21}  M_{11} \\end{pmatrix} \\begin{pmatrix} C \\\\ i k_0 C \\end{pmatrix}\n$$\n这得到了两个线性方程：\n1) $\\: A+B = (M_{22} - i k_0 M_{12}) C$\n2) $\\: A-B = \\frac{1}{i k_0}(-M_{21} + i k_0 M_{11}) C$\n\n将这两个方程相加可以消去 $B$，并得到 $2A$ 的表达式：\n$$\n2A = \\left( (M_{11} + M_{22}) - i k_0 M_{12} - \\frac{M_{21}}{i k_0} \\right) C\n$$\n透射系数 $T$ 是透射概率流与入射概率流之比。对于平面波 $e^{ikx}$，概率流与 $k$ 成正比。由于入射区和透射区的波数 $k_0$ 相同，$T$ 简化为振幅平方之比：$T = |C/A|^2$。从 $2A$ 的表达式中，我们得到 $C/A$：\n$$\n\\frac{C}{A} = \\frac{2}{M_{11} + M_{22} - i k_0 M_{12} + i \\frac{M_{21}}{k_0}}\n$$\n因此，透射系数为：\n$$\nT(E) = \\left| \\frac{2}{M_{11} + M_{22} - i k_0 M_{12} + i M_{21}/k_0} \\right|^2\n$$\n这个公式，结合计算总传输矩阵 $M$ 的过程，提供了一个完整且数值稳定的算法，用于计算任何给定能量 $E$ 的透射系数。\n\n实现该算法的步骤如下：\n1. 对于一组给定的参数 $(V_0, A, k, L, E)$，设置数值常数 $N$（切片数）和 $\\eta$（调节子）。$N=1000$ 的值足以解析势中最快的振荡，而 $\\eta=10^{-8}$ 是一个合适的调节子。\n2. 创建 $N$ 个切片中点的网格，并为每个切片计算势 $V_j$。\n3. 对于每个能量 $E$，计算 $E_{comp} = E + i\\eta$ 以及所有切片对应的波数 $k_0$ 和 $q_j$。\n4. 将总传输矩阵 $M$ 初始化为 $2 \\times 2$ 单位矩阵。\n5. 从 $j=0$ 迭代到 $N-1$，使用公式计算切片矩阵 $P_j$，并通过左乘更新总矩阵：$M_{new} = P_j \\cdot M_{old}$。这能正确计算出乘积 $M = P_{N-1} \\cdots P_0$。\n6. 使用最终矩阵 $M$ 的元素和波数 $k_0$，根据推导出的公式计算 $T(E)$。\n7. 对测试用例中的所有能量重复此过程。\n8. 按要求格式化结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the quantum scattering problem for the specified test cases.\n    \"\"\"\n    \n    # Test suite from the problem statement.\n    test_cases = [\n        (0.5, 0.1, 16.0 * np.pi, 1.0, [0.2, 0.5, 0.8, 1.2]),\n        (0.6, 0.0, 6.0 * np.pi, 1.0, [0.2, 0.61, 1.0]),\n        (0.4, 0.2, 40.0 * np.pi, 1.0, [0.3, 0.7]),\n        (0.0, 0.3, 8.0 * np.pi, 1.0, [0.05, 0.2, 0.5]),\n    ]\n    \n    # Global numerical parameters\n    N = 1000  # Number of slices for discretization\n    eta = 1e-8  # Small imaginary regulator for energy\n\n    all_results = []\n    for V0, A, k_ripple, L, E_list in test_cases:\n        case_results = []\n        dx = L / N\n        x_centers = (np.arange(N) + 0.5) * dx\n        V_slices = V0 + A * np.sin(k_ripple * x_centers)\n\n        for E in E_list:\n            E_comp = E + 1j * eta\n            \n            # Wavenumber in asymptotic regions (V=0)\n            k0 = np.sqrt(E_comp)\n            \n            # Wavenumbers in each slice of the barrier\n            q_slices = np.sqrt(E_comp - V_slices)\n            \n            # Initialize total transfer matrix as the identity matrix\n            M_total = np.identity(2, dtype=np.complex128)\n            \n            # Compose the total transfer matrix by multiplying slice matrices\n            # M_total = P_{N-1} * ... * P_1 * P_0\n            for j in range(N):\n                qj = q_slices[j]\n                \n                # Pre-calculate cos and sin for the slice propagation matrix\n                cos_qdx = np.cos(qj * dx)\n                sin_qdx = np.sin(qj * dx)\n                \n                # Propagation matrix for slice j\n                # Pj = [[cos(qj*dx), sin(qj*dx)/qj],\n                #       [-qj*sin(qj*dx), cos(qj*dx)]]\n                Pj = np.array([\n                    [cos_qdx, sin_qdx / qj],\n                    [-qj * sin_qdx, cos_qdx]\n                ], dtype=np.complex128)\n                \n                # Left-multiply to build up the total matrix P_{j} * ... * P_{0}\n                M_total = Pj @ M_total\n            \n            # Extract elements of the total transfer matrix M\n            M11, M12, M21, M22 = M_total[0, 0], M_total[0, 1], M_total[1, 0], M_total[1, 1]\n            \n            # Calculate C/A using the derived formula\n            # C/A = 2 / (M11 + M22 - i*k0*M12 + i*M21/k0)\n            C_over_A = 2.0 / (M11 + M22 - 1j * k0 * M12 + 1j * M21 / k0)\n            \n            # Transmission coefficient T = |C/A|^2\n            transmission = np.abs(C_over_A)**2\n            \n            case_results.append(transmission)\n            \n        all_results.append(case_results)\n    \n    # Format the final output string as specified\n    # Example: [[0.123456,0.789012],[0.456789,...]]\n    outer_list_str = []\n    for res_list in all_results:\n        inner_list_str = ','.join([f\"{t:.6f}\" for t in res_list])\n        outer_list_str.append(f\"[{inner_list_str}]\")\n    \n    final_output = f\"[{','.join(outer_list_str)}]\"\n    \n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "最后，我们将从静态的散射图像转向生动的动态演化过程。我们将不再只计算一个固定能量的粒子最终的透射概率，而是要亲眼观察一个代表粒子的波包如何随时间演化。在这个挑战性的练习中，你将通过求解含时薛定谔方程，设计一个随时间变化的“量子回旋镖”势阱，它能抓住一个运动的波包并使其返回原点 。这项实践不仅能让你掌握如“分裂算符-傅里叶变换法”等高级数值技巧，更能为你提供一个关于量子动力学的直观而深刻的理解。",
            "id": "2432194",
            "problem": "您必须编写一个完整的、可运行的程序，数值模拟一维空间中含时势的量子散射，并评估一个设计的势场是否能像“量子回旋镖”一样，捕获一个波包并将其送回其初始位置。从一维非相对论粒子的含时薛定谔方程出发，\n$$\ni \\hbar \\,\\frac{\\partial}{\\partial t} \\psi(x,t) \\;=\\; \\left[ -\\frac{\\hbar^2}{2m}\\,\\frac{\\partial^2}{\\partial x^2} + V(x,t) \\right] \\psi(x,t).\n$$\n使用无量纲化的自然单位制，其中约化普朗克常数 $\\hbar = 1$，质量 $m = 1$，此时方程变为\n$$\ni \\,\\frac{\\partial}{\\partial t} \\psi(x,t) \\;=\\; \\left[ -\\frac{1}{2}\\,\\frac{\\partial^2}{\\partial x^2} + V(x,t) \\right] \\psi(x,t).\n$$\n计算区域是长度为 $L$ 的周期性区域，其中 $x \\in [-L/2, L/2)$ 在一个包含 $N_x$ 个点的均匀网格上离散化，空间步长为 $\\Delta x = L/N_x$，时间步长为 $\\Delta t$。使用基于在 $\\Delta t$ 上二阶有效的算符分解的分裂算符 (Strang) 方法：\n$$\ne^{-i \\Delta t \\,\\left(T+V\\right)} \\;\\approx\\; e^{-i \\frac{\\Delta t}{2} V(t+\\Delta t/2)} \\; e^{-i \\Delta t \\, T} \\; e^{-i \\frac{\\Delta t}{2} V(t+\\Delta t/2)},\n$$\n其中动能算符为 $T = -\\frac{1}{2}\\,\\partial_x^2$，势能算符为乘以 $V(x,t)$。在傅里叶空间中，使用波数网格 $k_n = \\frac{2\\pi}{L} n$（其中 $n \\in \\{-N_x/2,\\dots,N_x/2-1\\}$，这与标准快速傅里叶变换定义返回的一致）来实现 $e^{-i \\Delta t \\, T}$，使得平面波按相位 $e^{-i \\Delta t \\, k^2 / 2}$ 演化。为避免周期性边界带来的非物理性环绕效应，通过在 $V(x,t)$ 中添加一个虚势 $-i \\eta(x)$，在计算区域的两端附近设置一个弱复吸收层。其中 $\\eta(x) \\ge 0$ 是一个光滑函数，仅在靠近 $x \\approx \\pm L/2$ 的宽度为 $L_{\\text{abs}}$ 的边界层内非零。\n\n初始状态必须是归一化的高斯波包，\n$$\n\\psi(x,0) \\;=\\; \\left(\\frac{1}{\\pi \\sigma_0^2}\\right)^{1/4} \\exp\\!\\left( -\\frac{(x-x_0)^2}{2\\sigma_0^2} \\right) \\exp\\!\\left( i k_0 (x-x_0) \\right),\n$$\n参数如下文所述。设所设计的含时势为一个移动的谐振子阱，旨在捕获并将波包带回：\n$$\nV(x,t) \\;=\\; \\frac{1}{2}\\,\\Omega^2 \\, \\big(x - x_c(t)\\big)^2 \\, A(t) \\;-\\; i\\,\\eta(x).\n$$\n此处 $\\Omega$ 是阱的角频率（控制束缚强度），$x_c(t)$ 是阱的中心，$A(t)$ 是一个平滑地开启和关闭势阱的包络。将阱中心定义为一条分段线性轨迹，首先与初始波包一同移动，然后反向，将其带回初始位置附近：\n$$\nx_c(t) \\;=\\;\n\\begin{cases}\nx_0 + k_0 \\, t,  0 \\le t \\le t_{\\text{turn}},\\\\\nx_0 + k_0 \\, t_{\\text{turn}} \\;-\\; u_{\\text{return}}\\,\\big(t - t_{\\text{turn}}\\big),  t > t_{\\text{turn}}.\n\\end{cases}\n$$\n将平滑的开关包络定义为独立的上升和下降斜坡的乘积，\n$$\nA(t) \\;=\\; R_{\\text{on}}(t)\\,R_{\\text{off}}(t),\n$$\n其中\n$$\nR_{\\text{on}}(t) \\;=\\;\n\\begin{cases}\n0,  t  t_{\\text{on}},\\\\\n\\sin^2\\!\\Big( \\dfrac{\\pi}{2} \\,\\dfrac{t - t_{\\text{on}}}{\\Delta_{\\text{on}}} \\Big),  t_{\\text{on}} \\le t \\le t_{\\text{on}} + \\Delta_{\\text{on}},\\\\\n1,  t > t_{\\text{on}} + \\Delta_{\\text{on}},\n\\end{cases}\n\\qquad\nR_{\\text{off}}(t) \\;=\\;\n\\begin{cases}\n1,  t  t_{\\text{off,start}},\\\\\n\\cos^2\\!\\Big( \\dfrac{\\pi}{2} \\,\\dfrac{t - t_{\\text{off,start}}}{\\Delta_{\\text{off}}} \\Big),  t_{\\text{off,start}} \\le t \\le t_{\\text{off,start}} + \\Delta_{\\text{off}},\\\\\n0,  t > t_{\\text{off,start}} + \\Delta_{\\text{off}}.\n\\end{cases}\n$$\n吸收剖面必须是\n$$\n\\eta(x) \\;=\\; \\eta_0 \\left[ \\Theta\\!\\big(x_L - x\\big)\\,\\left(\\frac{x_L-x}{L_{\\text{abs}}}\\right)^m + \\Theta\\!\\big(x - x_R\\big)\\,\\left(\\frac{x - x_R}{L_{\\text{abs}}}\\right)^m \\right],\n$$\n其中 $x_L = -\\frac{L}{2} + L_{\\text{abs}}$，$x_R = \\frac{L}{2} - L_{\\text{abs}}$，$\\Theta$ 是亥维赛德阶跃函数，$m \\in \\mathbb{N}$ 是一个偶数。\n\n您必须模拟直到最终时间 $T$ 的时间演化，并对每个指定的参数集，计算在最终时刻位于固定阈值位置 $x_{\\text{th}}$ 左侧的概率分数：\n$$\nP_{\\text{left}} \\;=\\; \\frac{\\displaystyle \\int_{-\\frac{L}{2}}^{x_{\\text{th}}}\\! |\\psi(x,T)|^2 \\, dx}{\\displaystyle \\int_{-\\frac{L}{2}}^{\\frac{L}{2}}\\! |\\psi(x,T)|^2 \\, dx}.\n$$\n将 $P_{\\text{left}}$ 解释为一个诊断量：接近 1 的值表示成功地“回旋”返回初始位置附近，而接近 0 的值表示未能返回。\n\n对所有运行使用以下固定的数值参数，均采用上述无量纲单位：区域长度 $L = 200$，网格大小 $N_x = 1024$，时间步长 $\\Delta t = 0.03$，最终时间 $T = 45$，吸收层宽度 $L_{\\text{abs}} = 30$，吸收强度 $\\eta_0 = 0.01$，吸收幂次 $m = 2$，阈值 $x_{\\text{th}} = -20$。初始波包参数：中心 $x_0 = -30$，宽度 $\\sigma_0 = 2$，波数 $k_0 = 1$。\n\n实现以下三个测试案例。除非明确说明，所有参数均为上述共享值。每个案例指定了势阱参数 $(\\Omega, t_{\\text{on}}, \\Delta_{\\text{on}}, t_{\\text{turn}}, u_{\\text{return}}, t_{\\text{off,start}}, \\Delta_{\\text{off}})$：\n\n- 情况 A（预期成功，绝热捕获并返回）：$\\Omega = 0.5$, $t_{\\text{on}} = 2$, $\\Delta_{\\text{on}} = 10$, $t_{\\text{turn}} = 24$, $u_{\\text{return}} = 1.2$, $t_{\\text{off,start}} = 35$, $\\Delta_{\\text{off}} = 10$。\n\n- 情况 B（弱势阱，预期捕获失败）：$\\Omega = 0.05$, $t_{\\text{on}} = 2$, $\\Delta_{\\text{on}} = 10$, $t_{\\text{turn}} = 24$, $u_{\\text{return}} = 1.2$, $t_{\\text{off,start}} = 35$, $\\Delta_{\\text{off}} = 10$。\n\n- 情况 C（强但突变的势阱，预期部分/非绝热捕获）：$\\Omega = 0.5$, $t_{\\text{on}} = 2$, $\\Delta_{\\text{on}} = 1$, $t_{\\text{turn}} = 24$, $u_{\\text{return}} = 1.2$, $t_{\\text{off,start}} = 44$, $\\Delta_{\\text{off}} = 1$。\n\n您的程序必须计算每种情况的 $P_{\\text{left}}$，并生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，顺序为 [情况 A, 情况 B, 情况 C]，每个值都四舍五入到小数点后六位，并以小数形式表示（而非百分比）。例如，输出格式必须类似于 $[0.812345,0.012300,0.456700]$。",
            "solution": "所提出的问题是计算量子力学中一个有效且适定的练习。它要求对一维含时薛定谔方程（TDSE）进行数值求解，以模拟量子波包与时变势相互作用的动力学过程。该问题具有科学依据，提供了精确的数学公式、一个标准且稳健的数值方法（分裂算符 FFT），以及一套完整的实现参数。问题中没有矛盾、歧义或缺失的信息。我现在将详细描述求解方法。\n\n控制方程是在无量纲单位制下的 TDSE，其中 $\\hbar=1$ 且粒子质量 $m=1$：\n$$ i \\,\\frac{\\partial}{\\partial t} \\psi(x,t) \\;=\\; \\hat{H}(t) \\psi(x,t) \\;=\\; \\left[ -\\frac{1}{2}\\,\\frac{\\partial^2}{\\partial x^2} + V(x,t) \\right] \\psi(x,t) $$\n此处，$\\hat{H}(t)$ 是含时哈密顿量，是动能算符 $\\hat{T} = -\\frac{1}{2}\\partial_x^2$ 和势能算符 $\\hat{V}(t)$（乘以 $V(x,t)$）之和。\n\n在一个微小时间步长 $\\Delta t$ 内的正式解由时间演化算符的作用给出，$\\psi(t+\\Delta t) = \\hat{U}(t+\\Delta t, t) \\psi(t)$。由于 $\\hat{T}$ 和 $\\hat{V}(t)$ 不对易，并且 $\\hat{H}(t)$ 是含时的，我们使用 $\\hat{U}$ 的一个近似。问题指定了二阶对称 Strang 分裂法，它将演化算符近似为：\n$$ \\hat{U}(t+\\Delta t, t) \\approx e^{-i \\frac{\\Delta t}{2} \\hat{V}(t+\\frac{\\Delta t}{2})} \\; e^{-i \\Delta t \\, \\hat{T}} \\; e^{-i \\frac{\\Delta t}{2} \\hat{V}(t+\\frac{\\Delta t}{2})} $$\n该公式规定了将波函数 $\\psi(x)$ 从时间 $t_n$ 传播到 $t_{n+1} = t_n + \\Delta t$ 的算法：\n1.  **第一个势能步骤：**施加半个时间步长的势能算符。这在位置空间中是一个乘法操作。为保持二阶精度，势能在时间区间的中点 $t_n + \\Delta t/2$ 处求值。\n    $$ \\psi'(x) = e^{-i \\frac{\\Delta t}{2} V(x, t_n + \\frac{\\Delta t}{2})} \\psi(x, t_n) $$\n2.  **动能步骤：**施加一个完整时间步长的动能算符。此操作在傅里叶（动量）空间中执行效率最高。动能算符 $\\hat{T} = -\\frac{1}{2}\\partial_x^2$ 在傅里叶域中变为简单的乘以 $\\frac{k^2}{2}$。过程如下：\n    a.  计算波函数的正向快速傅里叶变换 (FFT)：$\\tilde{\\psi}'(k) = \\mathcal{F}[\\psi'(x)]$。\n    b.  乘以动能相位因子：$\\tilde{\\psi}''(k) = e^{-i \\Delta t \\frac{k^2}{2}} \\tilde{\\psi}'(k)$。\n    c.  计算逆 FFT：$\\psi''(x) = \\mathcal{F}^{-1}[\\tilde{\\psi}''(k)]$。\n3.  **第二个势能步骤：**使用与第一步中相同的中心点势，施加第二个半时间步长的势能算符。\n    $$ \\psi(x, t_{n+1}) = e^{-i \\frac{\\Delta t}{2} V(x, t_n + \\frac{\\Delta t}{2})} \\psi''(x) $$\n这个三步序列构成一次时间演化迭代。从 $t=0$ 重复到最终时间 $T$。\n\n模拟在离散网格上执行。空间域 $x \\in [-L/2, L/2)$ 被离散化为 $N_x$ 个点，间距为 $\\Delta x = L/N_x$。用于 FFT 的相应波数网格由 $k_n = \\frac{2\\pi}{L} n$ 给出，其中整数 $n \\in \\{-N_x/2, \\dots, N_x/2-1\\}$，这可以方便地使用像 `numpy.fft.fftfreq` 这样的标准数值库函数生成。\n\n模拟的各组成部分构建如下：\n- **初始状态：**$t=0$ 时的初始波函数是一个高斯波包：\n  $$ \\psi(x,0) \\;=\\; \\left(\\frac{1}{\\pi \\sigma_0^2}\\right)^{1/4} \\exp\\!\\left( -\\frac{(x-x_0)^2}{2\\sigma_0^2} \\right) \\exp\\!\\left( i k_0 (x-x_0) \\right) $$\n  在离散空间网格 `x` 上对此函数求值以初始化模拟。\n- **含时势：**势 $V(x,t)$ 有两部分：代表移动谐振子阱的实部和用于吸收边界的虚部。\n  $$ V(x,t) \\;=\\; \\underbrace{\\frac{1}{2}\\,\\Omega^2 \\, \\big(x - x_c(t)\\big)^2 \\, A(t)}_{V_{\\text{trap}}(x,t)} \\;-\\; i\\,\\underbrace{\\eta(x)}_{\\text{absorber}} $$\n  吸收体 $\\eta(x)$ 是静态的，被设计成一个多项式函数，在区域边缘 $x = \\pm L/2$ 附近平滑开启，以防止周期性边界产生非物理反射。势阱部分需要在每个时间步计算阱中心 $x_c(t)$ 和振幅 $A(t)$，它们由问题陈述中指定的分段函数定义。将实现这些函数以在所需时间 $t_n + \\Delta t/2$ 处计算它们的值。\n\n最后，在将系统演化到最终时间 $T$ 后，计算我们感兴趣的量 $P_{\\text{left}}$。这是 $x  x_{\\text{th}}$ 区域的积分概率密度与整个区域上的总积分概率密度之比。\n$$ P_{\\text{left}} \\;=\\; \\frac{\\displaystyle \\int_{-\\frac{L}{2}}^{x_{\\text{th}}}\\! |\\psi(x,T)|^2 \\, dx}{\\displaystyle \\int_{-\\frac{L}{2}}^{\\frac{L}{2}}\\! |\\psi(x,T)|^2 \\, dx} $$\n积分通过在离散网格点上进行数值求和来近似。分母是时间 $T$ 时波函数的总范数，由于虚势的吸收，该值将小于其初始值 1。分子是一个类似的求和，但仅限于网格点 $x_j  x_{\\text{th}}$。\n\n程序的结构将是为三个测试案例中的每一个执行此模拟，收集每个案例计算出的 $P_{\\text{left}}$。最终输出将是这些值的格式化列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the quantum boomerang problem by simulating the Time-Dependent\n    Schrödinger Equation using the split-operator method.\n    \"\"\"\n\n    # --- Fixed Numerical and Physical Parameters ---\n    L = 200.0         # Domain length\n    Nx = 1024         # Number of grid points\n    dt = 0.03         # Time step\n    T_final = 45.0    # Final time\n    L_abs = 30.0      # Absorber width\n    eta0 = 0.01       # Absorber strength\n    m_abs = 2         # Absorber power (must be even integer)\n    x_th = -20.0      # Threshold position for P_left calculation\n\n    # --- Initial Wave Packet Parameters ---\n    x0 = -30.0        # Initial position\n    sigma0 = 2.0      # Initial width\n    k0 = 1.0          # Initial wave number\n\n    # --- Test Cases ---\n    # Parameters: (Omega, t_on, Delta_on, t_turn, u_return, t_off_start, Delta_off)\n    test_cases = [\n        # Case A: Intended success\n        (0.5, 2.0, 10.0, 24.0, 1.2, 35.0, 10.0),\n        # Case B: Weak trap, intended failure\n        (0.05, 2.0, 10.0, 24.0, 1.2, 35.0, 10.0),\n        # Case C: Abrupt trap, partial capture\n        (0.5, 2.0, 1.0, 24.0, 1.2, 44.0, 1.0),\n    ]\n\n    # --- Spatial and Wave Number Grids ---\n    dx = L / Nx\n    x = np.linspace(-L / 2, L / 2, Nx, endpoint=False)\n    k = 2 * np.pi * np.fft.fftfreq(Nx, d=dx)\n\n    # --- Kinetic Energy Operator in Fourier Space ---\n    T_op_fourier = np.exp(-1j * (k**2 / 2.0) * dt)\n    \n    # --- Helper Functions for Time-Dependent Potential ---\n    \n    def get_trap_center(t, t_turn, u_return):\n        if t = t_turn:\n            return x0 + k0 * t\n        else:\n            return x0 + k0 * t_turn - u_return * (t - t_turn)\n\n    def get_envelope_A(t, t_on, Delta_on, t_off_start, Delta_off):\n        # On-ramp\n        if t  t_on:\n            R_on = 0.0\n        elif t = t_on + Delta_on:\n            R_on = np.sin(0.5 * np.pi * (t - t_on) / Delta_on)**2\n        else:\n            R_on = 1.0\n        \n        # Off-ramp\n        if t  t_off_start:\n            R_off = 1.0\n        elif t = t_off_start + Delta_off:\n            R_off = np.cos(0.5 * np.pi * (t - t_off_start) / Delta_off)**2\n        else:\n            R_off = 0.0\n            \n        return R_on * R_off\n\n    # --- Absorber Potential ---\n    xL = -L / 2 + L_abs\n    xR = L / 2 - L_abs\n    eta = np.zeros_like(x)\n    \n    left_mask = x  xL\n    eta[left_mask] = eta0 * ((xL - x[left_mask]) / L_abs)**m_abs\n\n    right_mask = x > xR\n    eta[right_mask] = eta0 * ((x[right_mask] - xR) / L_abs)**m_abs\n\n    V_absorber = -1j * eta\n\n    results = []\n    \n    for case_params in test_cases:\n        Omega, t_on, Delta_on, t_turn, u_return, t_off_start, Delta_off = case_params\n\n        # --- Initial Wave Function ---\n        norm_factor = (1.0 / (np.pi * sigma0**2))**0.25\n        psi = norm_factor * np.exp(-(x - x0)**2 / (2 * sigma0**2)) * np.exp(1j * k0 * (x-x0))\n        \n        # --- Time Evolution Loop ---\n        num_steps = int(T_final / dt)\n        for i in range(num_steps):\n            t_mid = (i + 0.5) * dt\n            \n            # --- Construct Potential at Mid-Step Time ---\n            xc_t = get_trap_center(t_mid, t_turn, u_return)\n            A_t = get_envelope_A(t_mid, t_on, Delta_on, t_off_start, Delta_off)\n            V_trap = 0.5 * Omega**2 * (x - xc_t)**2 * A_t\n            V_total = V_trap + V_absorber\n            \n            V_op = np.exp(-1j * V_total * dt / 2.0)\n            \n            # --- Split-Operator Steps ---\n            # 1. Half-step in potential\n            psi = V_op * psi\n            \n            # 2. Full-step in kinetic energy (in Fourier space)\n            psi_f = np.fft.fft(psi)\n            psi_f = T_op_fourier * psi_f\n            psi = np.fft.ifft(psi_f)\n            \n            # 3. Second half-step in potential\n            psi = V_op * psi\n            \n        # --- Calculate P_left ---\n        prob_density = np.abs(psi)**2\n        total_prob = np.sum(prob_density) * dx\n        \n        left_region_mask = x  x_th\n        left_prob = np.sum(prob_density[left_region_mask]) * dx\n        \n        p_left = left_prob / total_prob if total_prob > 1e-12 else 0.0\n        results.append(f\"{p_left:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}