{
    "hands_on_practices": [
        {
            "introduction": "将微分方程转化为矩阵问题是计算物理学中的一种核心策略。本练习将指导你应用有限差分法，将一维定态薛定谔方程离散化为一个矩阵本征值问题。通过求解这个矩阵，我们可以一次性得到多个能级和对应的波函数，从而全面地理解一个给定量子系统的谱结构。这个实践  是掌握求解任意势阱问题的基础，同时它还引入了对波函数对称性的分析，将数值结果与量子力学的基本原理联系起来。",
            "id": "2388919",
            "problem": "要求您计算在形似字母“W”的双阱势中运动的一维量子粒子的低能级能量本征值，并判断相应本征函数的对称性。目标是从定态薛定谔方程出发，实现一个数值计算程序，并设计该程序，使其能为一小组参数值的测试集输出明确指定的量化结果。\n\n从质量为 $m$、约化普朗克常数为 $\\hbar$ 的粒子的定态薛定谔方程开始：\n$$\n-\\frac{\\hbar^2}{2m}\\frac{d^2 \\psi(x)}{dx^2} + V(x)\\,\\psi(x) = E\\,\\psi(x),\n$$\n并在无量纲单位（其中 $\\hbar^2/(2m) = 1$）下进行计算，因此方程变为：\n$$\n-\\,\\psi''(x) + V(x)\\,\\psi(x) = E\\,\\psi(x).\n$$\n在有限区间 $x\\in[-L,L]$ 上施加齐次狄利克雷边界条件 $\\psi(-L)=\\psi(L)=0$。该区间需足够大，以使束缚态波函数在边界处衰减至可忽略的值。在 $[-L,L]$ 上构建一个均匀网格，并使用标准的中心差分近似法来近似二阶导数，从而推导出离散矩阵本征值问题。求解所得的对称三对角矩阵本征问题，以获得最低的几个本征值 $E$ 和相应的归一化本征矢量 $\\psi$。确保对于给定的参数，该数值方法是稳定且收敛的。\n\n将“W”形势定义为一个四次双阱，并带有一个可选的微小线性倾斜：\n$$\nV(x) = a\\,(x^2 - b^2)^2 + \\varepsilon\\,x,\n$$\n当 $\\varepsilon=0$ 时，该势在 $x=\\pm b$ 处有两个极小值点，并在 $x=0$ 处有一个中心势垒。使用一个关于 $x=0$ 对称的网格，以便可以直接检验宇称性。\n\n为分析每个本征函数 $\\psi(x)$ 的对称性，可通过宇称算符 $\\hat{P}$（定义为 $(\\hat{P}\\psi)(x)=\\psi(-x)$）的期望值来表征，即：\n$$\n\\langle \\hat{P} \\rangle = \\frac{\\int_{-L}^{L}\\psi(x)\\,\\psi(-x)\\,dx}{\\int_{-L}^{L}|\\psi(x)|^2\\,dx}.\n$$\n对于一个完美的偶函数本征函数，$\\langle \\hat{P} \\rangle = +1$；对于一个完美的奇函数本征函数，$\\langle \\hat{P} \\rangle = -1$；对于对称性破缺的态，$\\langle \\hat{P} \\rangle$ 的值将偏离 $\\pm 1$。在一个具有对称节点和归一化本征矢量的均匀网格上，通过计算本征矢量与其反转副本的离散内积（经过适当归一化）来近似这个期望值。\n\n所有能量必须以所选的无量纲单位（其中 $\\hbar^2/(2m)=1$）报告，并且所有最终数值结果必须四舍五入到 $6$ 位小数。\n\n实现一个完整的程序，该程序能够：\n1. 在内部网格点上，根据在 $x=\\pm L$ 处的齐次狄利克雷边界条件，构建与离散化算符 $-\\,d^2/dx^2 + V(x)$ 对应的三对角哈密顿矩阵。\n2. 计算最低的 $4$ 个本征值和归一化的本征矢量。\n3. 按上述方法为这 $4$ 个本征矢量计算宇称期望值 $\\langle \\hat{P} \\rangle$。\n4. 为每个测试用例生成一行输出，按指定格式汇总结果。\n\n使用以下三个测试用例，每个用例均采用相同的数值离散化参数：\n- 区域半长度 $L = 6$，内部网格点数 $N = 1200$（在 $[-L, L]$ 上的均匀网格，离散算符中不包括边界）。\n- 势函数参数 $(a,b,\\varepsilon)$:\n  1. $(a,b,\\varepsilon)=(1.0,\\,1.0,\\,0.0)$，对称双阱。\n  2. $(a,b,\\varepsilon)=(1.0,\\,1.0,\\,0.05)$，弱倾斜双阱。\n  3. $(a,b,\\varepsilon)=(0.5,\\,1.5,\\,0.0)$，更宽更软的对称双阱。\n\n对于每个测试用例，您的程序必须计算最低的 $4$ 个能量值和对应的 $4$ 个宇称期望值。将所有报告的数字四舍五入到 $6$ 位小数。您的程序应生成单行输出，其中包含一个由列表组成的逗号分隔列表，每个内部列表首先包含 $4$ 个能量值，然后是 $4$ 个宇称期望值，例如：\n[[E0,E1,E2,E3,P0,P1,P2,P3],[...for case 2...],[...for case 3...]]\n其中每个 $E_k$ 和 $P_k$ 都是四舍五入到 $6$ 位小数的浮点数。所有能量均采用 $\\hbar^2/(2m)=1$ 所定义的无量纲单位。",
            "solution": "我们从一维粒子的定态薛定谔方程出发：\n$$\n-\\frac{\\hbar^2}{2m}\\frac{d^2 \\psi(x)}{dx^2} + V(x)\\,\\psi(x) = E\\,\\psi(x).\n$$\n采用无量纲约定 $\\hbar^2/(2m)=1$，方程简化为：\n$$\n-\\,\\psi''(x) + V(x)\\,\\psi(x) = E\\,\\psi(x).\n$$\n我们将计算限制在有限区间 $x\\in[-L,L]$ 内，并施加齐次狄利克雷边界条件 $\\psi(-L)=\\psi(L)=0$。对于足够强的束缚势，束缚态波函数会快速衰减，因此选择一个较大的 $L$ 可以确保边界误差可忽略不计。\n\n为了离散化，我们在 $[-L,L]$ 上设置一个包含 $N$ 个内部点的均匀网格，不包括端点以直接强制 $\\psi(\\pm L)=0$。设网格间距为 $\\Delta x = 2L/(N+1)$，内部节点为：\n$$\nx_i = -L + i\\,\\Delta x,\\quad i=1,2,\\dots,N.\n$$\n使用标准的中心差分（二阶精度）近似来处理二阶导数：\n$$\n\\psi''(x_i) \\approx \\frac{\\psi_{i+1} - 2\\psi_i + \\psi_{i-1}}{(\\Delta x)^2},\n$$\n微分算符 $-\\,d^2/dx^2$ 映射为一个三对角矩阵，其主对角线元素为 $2/(\\Delta x)^2$，非对角线元素为 $-1/(\\Delta x)^2$。势 $V(x)$ 作为 $V(x_i)$ 加性地贡献给主对角线。因此，作用于矢量 $\\boldsymbol{\\psi} = (\\psi_1,\\dots,\\psi_N)^\\top$ 的离散哈密顿量是 $N\\times N$ 的对称三对角矩阵：\n$$\nH = T + U,\\quad T = \\frac{1}{(\\Delta x)^2}\\,\\mathrm{tridiag}(-1,\\,2,\\,-1),\\quad U=\\mathrm{diag}\\big(V(x_1),\\dots,V(x_N)\\big).\n$$\n离散本征问题：\n$$\nH\\,\\boldsymbol{\\psi} = E\\,\\boldsymbol{\\psi}\n$$\n近似了连续谱的束缚态问题。因为对于束缚势 $V(x)$，$H$ 是实对称且严格对角占优的，所以其谱是实的，最低的本征对近似了真实的能量和本征函数。我们使用三对角本征求解器计算最低的 $4$ 个本征值，以获得高效率和数值稳定性。\n\n我们选择“W”形势为：\n$$\nV(x) = a\\,(x^2 - b^2)^2 + \\varepsilon\\,x,\n$$\n其参数 $(a,b,\\varepsilon)$ 由每个测试用例指定。当 $\\varepsilon=0$ 时，势是偶函数，支持具有确定宇称（偶或奇）的本征函数。当 $\\varepsilon\\neq 0$ 时，宇称对称性被打破，本征函数既非纯偶也非纯奇。\n\n为量化对称性，我们计算宇称算符 $\\hat{P}$（定义为 $(\\hat{P}\\psi)(x)=\\psi(-x)$）的期望值：\n$$\n\\langle \\hat{P} \\rangle = \\frac{\\int_{-L}^{L} \\psi(x)\\,\\psi(-x)\\,dx}{\\int_{-L}^{L}|\\psi(x)|^2\\,dx}.\n$$\n在一个具有节点 $\\{x_i\\}_{i=1}^N$ 的对称均匀网格上，对于在欧几里得意义上归一化（即 $\\sum_i |\\psi_i|^2 = 1$）的本征矢量分量 $\\{\\psi_i\\}_{i=1}^N$，离散近似使用反转的索引来实现 $x\\mapsto -x$。由于分子和分母都带有相同的均匀求积权重 $\\Delta x$，该因子在比值中被约去。因此，我们计算：\n$$\n\\langle \\hat{P} \\rangle \\approx \\sum_{i=1}^{N} \\psi_i\\,\\psi_{N+1-i},\n$$\n对于一个精确的偶态，该值等于 $+1$；对于一个精确的奇态，该值等于 $-1$；随着对称性逐渐破缺或数值误差累积，该值会向 $0$ 偏离。标准对称本征求解器返回的本征矢量在欧几里得范数下是标准正交的，这确保了分母为 $1$。\n\n算法总结：\n1. 选择 $L$ 和 $N$；计算 $\\Delta x = 2L/(N+1)$ 和内部网格点 $x_i$。\n2. 对于每个测试用例，计算 $V(x_i)$ 并组装主对角线 $d_i = 2/(\\Delta x)^2 + V(x_i)$ 和非对角线元素 $e_i = -1/(\\Delta x)^2$。\n3. 使用一个三对角对称本征求解器计算最低的 $4$ 个本征对 $\\{(E_k,\\boldsymbol{\\psi}^{(k)})\\}_{k=0}^3$。\n4. 对于每个本征矢量，计算宇称期望值 $\\langle \\hat{P} \\rangle_k \\approx \\sum_i \\psi^{(k)}_i \\psi^{(k)}_{N+1-i}$。\n5. 将所有的 $E_k$ 和 $\\langle \\hat{P} \\rangle_k$ 四舍五入到 $6$ 位小数。\n6. 输出一行，其中包含一个由三个列表组成的列表，每个测试用例一个列表，格式为 [E0,E1,E2,E3,P0,P1,P2,P3]。\n\n数值参数和测试集：\n- 所有用例均使用 $L=6$ 和 $N=1200$。\n- 三种势 $(a,b,\\varepsilon)$:\n  1. $(1.0,\\,1.0,\\,0.0)$ 对称双阱。\n  2. $(1.0,\\,1.0,\\,0.05)$ 弱倾斜阱。\n  3. $(0.5,\\,1.5,\\,0.0)$ 对称、更宽的阱。\n\n所有输出均为无量纲能量和宇称期望值，单位为 $\\hbar^2/(2m)=1$，并四舍五入到 $6$ 位小数。最终程序构建哈密顿量，求解最低的 $4$ 个本征对，计算宇称诊断指标，并按指定的汇总格式将结果打印为单行输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Execution environment: Python 3.12, numpy 1.23.5, scipy 1.11.4\nimport numpy as np\nfrom scipy.linalg import eigh_tridiagonal\n\ndef solve():\n    \"\"\"\n    Main driver function to solve the problem for all test cases.\n    \"\"\"\n\n    def compute_spectrum_and_parity(a, b, eps, L=6.0, N=1200, k=4):\n        \"\"\"\n        Computes the lowest k eigenvalues and eigenvectors for a given potential\n        and calculates the parity expectation value for each eigenvector.\n        \"\"\"\n        # Uniform grid setup: N interior points between -L and L\n        dx = 2.0 * L / (N + 1)\n        x = np.linspace(-L + dx, L - dx, N)\n\n        # Define the W-shaped double-well potential with optional tilt\n        V = a * (x**2 - b**2)**2 + eps * x\n\n        # Build tridiagonal Hamiltonian H = T + V\n        # T main diagonal: 2/dx^2, off-diagonals: -1/dx^2\n        # H main diagonal: 2/dx^2 + V(x)\n        d = (2.0 / dx**2) + V\n        e = (-1.0 / dx**2) * np.ones(N - 1)\n\n        # Solve for the lowest k eigenpairs of the symmetric tridiagonal matrix\n        # eigh_tridiagonal returns eigenvalues in ascending order\n        # and eigenvectors as columns of v.\n        eigenvalues, eigenvectors = eigh_tridiagonal(d, e, select='i', select_range=(0, k - 1))\n\n        # Compute parity expectation for each eigenvector\n        parities = []\n        for i in range(k):\n            vec = eigenvectors[:, i]\n            # For a symmetric grid, psi(-x) corresponds to reversing the vector.\n            # The eigenvectors are already normalized (L2 norm = 1), so the\n            # denominator in the parity formula is 1.\n            parity_exp = np.sum(vec * vec[::-1])\n            parities.append(parity_exp)\n        \n        return eigenvalues, np.array(parities)\n\n    # Define the test cases from the problem statement\n    test_cases = [\n        (1.0, 1.0, 0.0),    # Case 1: Symmetric double-well\n        (1.0, 1.0, 0.05),   # Case 2: Tilted double-well\n        (0.5, 1.5, 0.0),    # Case 3: Wider, softer symmetric well\n    ]\n    \n    all_results_formatted = []\n    for params in test_cases:\n        a, b, eps = params\n        energies, parities = compute_spectrum_and_parity(a, b, eps)\n        \n        # Combine energies and parities, then round to 6 decimal places\n        combined_results = np.concatenate((energies, parities))\n        formatted_list = [f\"{val:.6f}\" for val in combined_results]\n        all_results_formatted.append(f\"[{','.join(formatted_list)}]\")\n        \n    # Print the final output in the required single-line format\n    print(f\"[{','.join(all_results_formatted)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "除了矩阵方法，打靶法为求解本征值问题提供了另一种强大而灵活的思路。它巧妙地将寻找能量本征值的问题，转化为一个寻找函数根点的数值问题。在本练习  中，你将学习如何结合常微分方程（ODE）数值积分器（如龙格-库塔法）与求根算法（如割线法），精确地“射击”并锁定非谐振子的特定能级。这种方法在只需要求解少数几个能级时尤其高效。",
            "id": "2422745",
            "problem": "考虑一个质量为 $m$ 的粒子在非谐势 $V(x) = \\tfrac{1}{2} m \\omega^2 x^2 + \\tfrac{1}{4} \\lambda x^4$ 中运动的一维、不含时的薛定谔方程。其基本定律为\n$$\n-\\frac{\\hbar^2}{2 m} \\frac{d^2 \\psi}{d x^2} + V(x)\\,\\psi(x) = E\\,\\psi(x),\n$$\n其中 $\\hbar$ 是约化普朗克常数，$\\psi(x)$ 是束缚态波函数，而 $E$ 是能量本征值。采用标准谐振子的标度进行无量纲化：长度 $x_0 = \\sqrt{\\hbar/(m \\omega)}$ 和能量 $E_0 = \\hbar \\omega$。定义无量纲坐标 $\\xi = x / x_0$、无量纲能量 $\\varepsilon = E / E_0$ 以及无量纲非谐性参数 $\\alpha = \\lambda \\hbar /(m^2 \\omega^3)$。证明薛定谔方程可简化为如下无量纲形式\n$$\n-\\frac{1}{2}\\,\\frac{d^2 \\psi}{d \\xi^2} + \\left(\\tfrac{1}{2}\\,\\xi^2 + \\tfrac{1}{4}\\,\\alpha\\,\\xi^4\\right)\\psi(\\xi) = \\varepsilon\\,\\psi(\\xi),\n$$\n并等价地写成初值形式\n$$\n\\frac{d \\psi}{d \\xi} = \\phi,\\qquad \\frac{d \\phi}{d \\xi} = \\left(\\xi^2 + \\tfrac{1}{2}\\,\\alpha\\,\\xi^4 - 2 \\varepsilon\\right)\\psi,\n$$\n其中 $\\phi = d\\psi/d\\xi$。\n\n利用偶势中束缚态的物理宇称性来设置 $\\xi = 0$ 处的初始条件。对于最低的偶数态，设 $\\psi(0) = 1$ 和 $\\phi(0) = 0$。对于最低的奇数态，设 $\\psi(0) = 0$ 和 $\\phi(0) = 1$。在这两种情况下，总归一化是任意的，不影响能量本征值。\n\n您的任务是计算两个最低的束缚态能量，即最低的偶数态和最低的奇数态。这需要实现一种打靶法，将 $\\varepsilon$ 视为未知参数，并使用一个开放求根方案来强制满足在有限域截断处的边界条件。具体而言：\n\n- 在上述系统上，使用固定的均匀步长 $h = 0.005$，从 $\\xi = 0$ 积分到有限边界 $\\xi = L$（其中 $L = 10$）。使用一个标准的、尊重平滑性的显式数值积分器（例如，四阶 Runge–Kutta 方法）来为给定的试探 $\\varepsilon$ 和宇称性生成 $\\psi(L;\\varepsilon)$。\n- 将打靶残差定义为 $F(\\varepsilon) = \\psi(L;\\varepsilon)$（对于给定的宇称性）。正确的本征值满足 $F(\\varepsilon) = 0$，因为一个可归一化的束缚态会衰减，使得 $\\psi$ 在一个足够大但有限的 $L$ 处小到可以忽略不计。\n- 使用一种开放求根方法，特别是割线法（仅使用函数值），来求解 $F(\\varepsilon) = 0$ 以得到 $\\varepsilon$。不要使用区间法。当 $|\\Delta \\varepsilon|  10^{-10}$ 或 $|F(\\varepsilon)|  10^{-8}$ 或达到最大迭代次数 $50$ 次时，终止割线法迭代。\n\n所有能量均以无量纲单位 $E_0 = \\hbar \\omega$ 报告，即直接报告 $\\varepsilon$。将每个报告的能量四舍五入到 6 位小数。\n\n测试套件和覆盖范围：\n- 在 $\\hbar = 1$ 的无量纲化条件下，使用以下三组参数 $(m,\\omega,\\lambda)$ 来定义 $\\alpha = \\lambda \\hbar /(m^2 \\omega^3)$。\n  - 情况 A（谐振子极限，边界情况）：$(m,\\omega,\\lambda) = (1,1,0)$。\n  - 情况 B（弱非谐性，正常路径）：$(m,\\omega,\\lambda) = (1,1,0.2)$。\n  - 情况 C（中等非谐性）：$(m,\\omega,\\lambda) = (1,1,0.5)$。\n对于每种情况，计算并返回以 $E_0$ 为单位的最低偶数态能量和最低奇数态能量。因此，程序对每种情况产生 2 个数字，总共 6 个数字。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，顺序为：[even_A, odd_A, even_B, odd_B, even_C, odd_C]，其中每个条目是相应计算出的、四舍五入到 6 位小数的 $\\varepsilon$。\n- 不允许有其他输出。",
            "solution": "所给问题是计算量子力学中一个标准的、适定的练习。它在科学上是合理的，内部是一致的，并包含确定唯一解所需的所有必要信息。首要任务是验证所提供的薛定谔方程的无量纲化过程。在详细阐述数值解法之前，我将首先进行此推导。\n\n**1. 薛定谔方程的无量纲化**\n\n出发点是一个质量为 $m$ 的粒子在势 $V(x)$ 中的一维、不含时薛定谔方程：\n$$\n-\\frac{\\hbar^2}{2m} \\frac{d^2 \\psi}{d x^2} + \\left(\\frac{1}{2} m \\omega^2 x^2 + \\frac{1}{4} \\lambda x^4\\right)\\psi(x) = E\\,\\psi(x)\n$$\n我们给定了长度的特征标度 $x_0 = \\sqrt{\\hbar/(m \\omega)}$ 和能量的特征标度 $E_0 = \\hbar \\omega$。我们引入无量纲变量 $\\xi = x/x_0$ 和 $\\varepsilon = E/E_0$。\n\n根据链式法则，我们得到导数的变换：\n$$\n\\frac{d}{dx} = \\frac{d\\xi}{dx} \\frac{d}{d\\xi} = \\frac{1}{x_0} \\frac{d}{d\\xi}\n$$\n$$\n\\frac{d^2}{dx^2} = \\frac{d}{dx}\\left(\\frac{1}{x_0} \\frac{d}{d\\xi}\\right) = \\frac{1}{x_0^2} \\frac{d^2}{d\\xi^2}\n$$\n将 $x = \\xi x_0$、$E = \\varepsilon E_0$ 以及二阶导数代入原方程，得到：\n$$\n-\\frac{\\hbar^2}{2m} \\left(\\frac{1}{x_0^2} \\frac{d^2 \\psi}{d\\xi^2}\\right) + \\left(\\frac{1}{2} m \\omega^2 (x_0 \\xi)^2 + \\frac{1}{4} \\lambda (x_0 \\xi)^4\\right)\\psi = (\\varepsilon E_0)\\psi\n$$\n为简化起见，我们将整个方程除以能量标度 $E_0 = \\hbar \\omega$：\n$$\n-\\frac{\\hbar^2}{2m E_0 x_0^2} \\frac{d^2 \\psi}{d\\xi^2} + \\left(\\frac{m \\omega^2 x_0^2}{2 E_0} \\xi^2 + \\frac{\\lambda x_0^4}{4 E_0} \\xi^4\\right)\\psi = \\varepsilon\\psi\n$$\n现在，我们使用 $x_0$ 和 $E_0$ 的定义来计算各项系数：\n- 二阶导数项的系数：\n$$\n-\\frac{\\hbar^2}{2m (\\hbar\\omega) (\\hbar/(m\\omega))} = -\\frac{\\hbar^2 m \\omega}{2m \\hbar^2 \\omega} = -\\frac{1}{2}\n$$\n- $\\xi^2$ 项的系数：\n$$\n\\frac{m \\omega^2 (\\hbar/(m\\omega))}{2 (\\hbar\\omega)} = \\frac{m \\omega^2 \\hbar}{2 m \\omega \\hbar \\omega} = \\frac{1}{2}\n$$\n- $\\xi^4$ 项的系数：\n$$\n\\frac{\\lambda x_0^4}{4 E_0} = \\frac{\\lambda (\\hbar/(m\\omega))^2}{4 (\\hbar\\omega)} = \\frac{\\lambda \\hbar^2}{4 m^2 \\omega^2 \\hbar \\omega} = \\frac{\\lambda \\hbar}{4 m^2 \\omega^3} = \\frac{1}{4} \\alpha\n$$\n其中 $\\alpha = \\lambda \\hbar / (m^2 \\omega^3)$ 是无量纲非谐性参数。\n\n将这些系数组合起来，我们便得到了所要求的无量纲方程，其有效性得到证实：\n$$\n-\\frac{1}{2}\\,\\frac{d^2 \\psi}{d \\xi^2} + \\left(\\frac{1}{2}\\,\\xi^2 + \\frac{1}{4}\\,\\alpha\\,\\xi^4\\right)\\psi(\\xi) = \\varepsilon\\,\\psi(\\xi)\n$$\n为了将这个二阶常微分方程（ODE）转换为一阶常微分方程组，我们首先分离出二阶导数：\n$$\n\\frac{d^2 \\psi}{d \\xi^2} = 2 \\left(\\frac{1}{2}\\,\\xi^2 + \\frac{1}{4}\\,\\alpha\\,\\xi^4 - \\varepsilon\\right)\\psi = \\left(\\xi^2 + \\frac{1}{2}\\,\\alpha\\,\\xi^4 - 2\\varepsilon\\right)\\psi\n$$\n通过定义 $\\phi(\\xi) = d\\psi/d\\xi$，我们得到方程组：\n$$\n\\frac{d\\psi}{d\\xi} = \\phi(\\xi)\n$$\n$$\n\\frac{d\\phi}{d\\xi} = \\left(\\xi^2 + \\frac{1}{2}\\,\\alpha\\,\\xi^4 - 2\\varepsilon\\right)\\psi(\\xi)\n$$\n此方程组也得到证实。\n\n**2. 数值方法**\n\n问题在于找到能量本征值 $\\varepsilon$，使得波函数 $\\psi(\\xi)$ 在物理上是可接受的，即可归一化。这要求当 $\\xi \\to \\pm\\infty$ 时，$\\psi(\\xi) \\to 0$。该问题使用打靶法求解。\n\n势 $V(x)$ 是一个偶函数，因此其本征函数必须具有确定的宇称（偶宇称或奇宇称）。我们可以利用这种对称性，从 $\\xi=0$ 开始向外积分。\n- 对于**偶数态**，$\\psi(-\\xi) = \\psi(\\xi)$，这意味着在原点的导数为零：$\\phi(0) = d\\psi/d\\xi|_{\\xi=0} = 0$。由于薛定谔方程的线性性质，我们可以设置 $\\psi(0) = 1$。\n- 对于**奇数态**，$\\psi(-\\xi) = -\\psi(\\xi)$，这意味着 $\\psi(0)=0$。为了获得非平凡解，我们必须有一个非零的斜率，因此我们设置导数 $\\phi(0) = 1$。\n\n打靶法将能量 $\\varepsilon$ 视为一个可变参数。对于一个试探的 $\\varepsilon$ 值，我们求解从 $\\xi=0$ 到一个足够大的边界 $\\xi=L$ 的初值问题。物理条件 $\\psi(\\xi \\to \\infty) = 0$ 被数值条件 $\\psi(L) = 0$ 所近似。因此，我们定义一个残差函数 $F(\\varepsilon) = \\psi(L; \\varepsilon)$，问题就简化为求解 $F(\\varepsilon) = 0$ 的根。\n\n算法如下：\n1.  **定义 ODE 系统**：一个函数将代表状态向量 $\\mathbf{y} = [\\psi, \\phi]^T$ 的一阶方程组的右侧。\n    $$ \\frac{d\\mathbf{y}}{d\\xi} = f(\\xi, \\mathbf{y}; \\varepsilon, \\alpha) = \\begin{bmatrix} \\phi \\\\ (\\xi^2 + \\frac{1}{2}\\alpha\\xi^4 - 2\\varepsilon)\\psi \\end{bmatrix} $$\n2.  **积分 ODE**：该问题需要一个显式数值积分器。标准的四阶 Runge-Kutta (RK4) 方法是合适的，并将被实现。从基于所需宇称的初始状态 $\\mathbf{y}(0)$ 开始，系统以步长 $h=0.005$ 从 $\\xi=0$ 积分到 $\\xi=L=10$。此积分的结果是所选 $\\varepsilon$ 对应的 $\\psi(L)$ 的值。这个函数 $\\varepsilon \\mapsto \\psi(L; \\varepsilon)$ 就是我们的打靶函数 $F(\\varepsilon)$。\n3.  **求根**：问题指定使用割线法（一种开放求根方案）来求解 $F(\\varepsilon) = 0$。给定能量的两个初始猜测值 $\\varepsilon_{k-1}$ 和 $\\varepsilon_k$，下一个近似值 $\\varepsilon_{k+1}$ 通过以下递推关系找到：\n    $$ \\varepsilon_{k+1} = \\varepsilon_k - F(\\varepsilon_k) \\frac{\\varepsilon_k - \\varepsilon_{k-1}}{F(\\varepsilon_k) - F(\\varepsilon_{k-1})} $$\n    迭代过程持续进行，直到满足指定的收敛标准之一：$|\\varepsilon_{k+1} - \\varepsilon_k|  10^{-10}$、$|F(\\varepsilon_{k+1})|  10^{-8}$，或超过最大迭代次数 $50$ 次。$\\varepsilon$ 的初始猜测值必须审慎选择。对于谐振子情况（$\\alpha=0$），精确的本征值为 $\\varepsilon_n = n + 1/2$。最低的偶数态对应于 $n=0$（$\\varepsilon_0=0.5$），最低的奇数态对应于 $n=1$（$\\varepsilon_1=1.5$）。这些值是我们进行猜测的绝佳起点。当 $\\alpha > 0$ 时，势阱变得更陡，这会使能级升高。因此，非谐情况的初始猜测值应选择比其对应的谐振子情况稍高的值。\n\n4.  **计算所有情况**：对测试用例中导出的三个 $\\alpha$ 值以及偶宇称和奇宇称两种情况，重复整个过程，以找到所需的六个能量本征值。\n\n实现将包含一个主驱动函数，该函数循环遍历参数集和宇称。此函数将调用一个割线法求解器，该求解器又会反复调用一个 RK4 积分程序来评估打靶函数 $F(\\varepsilon)$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the two lowest bound-state energies for an anharmonic oscillator\n    using a shooting method with a secant root-finder.\n    \"\"\"\n    \n    # Problem Constants\n    L = 10.0\n    h = 0.005\n    \n    # Secant Method Parameters\n    MAX_ITER = 50\n    TOL_EPS = 1e-10\n    TOL_F = 1e-8\n\n    def get_derivatives(xi, state, epsilon, alpha):\n        \"\"\"\n        Computes the derivatives for the ODE system.\n        state = [psi, phi], where phi = d(psi)/d(xi)\n        \"\"\"\n        psi, phi = state\n        d_psi_d_xi = phi\n        d_phi_d_xi = (xi**2 + 0.5 * alpha * xi**4 - 2.0 * epsilon) * psi\n        return np.array([d_psi_d_xi, d_phi_d_xi])\n\n    def solve_ode_rk4(initial_state, epsilon, alpha):\n        \"\"\"\n        Solves the ODE system from xi=0 to xi=L using RK4.\n        Returns the final value of psi(L).\n        This is the shooting function F(epsilon).\n        \"\"\"\n        state = np.array(initial_state, dtype=float)\n        num_steps = int(L / h)\n        \n        for i in range(num_steps):\n            xi = i * h\n            \n            k1 = h * get_derivatives(xi, state, epsilon, alpha)\n            k2 = h * get_derivatives(xi + 0.5 * h, state + 0.5 * k1, epsilon, alpha)\n            k3 = h * get_derivatives(xi + 0.5 * h, state + 0.5 * k2, epsilon, alpha)\n            k4 = h * get_derivatives(xi + h, state + k3, epsilon, alpha)\n            \n            state += (k1 + 2.0 * k2 + 2.0 * k3 + k4) / 6.0\n            \n        return state[0] # Return psi(L)\n\n    def find_energy_secant(initial_state, e_guesses, alpha):\n        \"\"\"\n        Finds the energy eigenvalue using the secant method.\n        \"\"\"\n        e_prev, e_curr = e_guesses\n        f_prev = solve_ode_rk4(initial_state, e_prev, alpha)\n        f_curr = solve_ode_rk4(initial_state, e_curr, alpha)\n\n        for _ in range(MAX_ITER):\n            if abs(f_curr)  TOL_F:\n                return e_curr\n            \n            delta_e = e_curr - e_prev\n            if abs(delta_e)  TOL_EPS:\n                return e_curr\n            \n            # Avoid division by zero or a very small number\n            if abs(f_curr - f_prev)  1e-15:\n                # If function values are too close, the method may fail.\n                # This indicates either convergence or a problem.\n                # For this problem, it's likely convergence.\n                return e_curr\n            \n            e_next = e_curr - f_curr * delta_e / (f_curr - f_prev)\n            \n            e_prev, e_curr = e_curr, e_next\n            f_prev, f_curr = f_curr, solve_ode_rk4(initial_state, e_curr, alpha)\n            \n        return e_curr\n\n    # Define the test cases from the problem statement.\n    # We set hbar = 1, so alpha = lambda / (m^2 * omega^3)\n    test_cases = [\n        # Case A: (m, omega, lambda) = (1, 1, 0)\n        (1.0, 1.0, 0.0),\n        # Case B: (m, omega, lambda) = (1, 1, 0.2)\n        (1.0, 1.0, 0.2),\n        # Case C: (m, omega, lambda) = (1, 1, 0.5)\n        (1.0, 1.0, 0.5),\n    ]\n\n    results = []\n    \n    # Initial conditions for even and odd states\n    ic_even = [1.0, 0.0]  # psi(0)=1, phi(0)=0\n    ic_odd = [0.0, 1.0]   # psi(0)=0, phi(0)=1\n\n    # Initial guesses for energy eigenvalues (e_prev, e_curr)\n    # Based on QHO energies (0.5, 1.5) and perturbation theory\n    # (energy increases with alpha)\n    guesses = {\n        'A': {'even': (0.4, 0.6), 'odd': (1.4, 1.6)},\n        'B': {'even': (0.5, 0.7), 'odd': (1.6, 1.8)},\n        'C': {'even': (0.6, 0.8), 'odd': (1.7, 1.9)},\n    }\n    case_labels = ['A', 'B', 'C']\n\n    for i, case in enumerate(test_cases):\n        m, omega, lamb = case\n        case_label = case_labels[i]\n        \n        # In the problem, hbar=1 for test cases\n        alpha = lamb / (m**2 * omega**3)\n        \n        # Lowest even state energy\n        e_guesses_even = guesses[case_label]['even']\n        even_energy = find_energy_secant(ic_even, e_guesses_even, alpha)\n        results.append(f\"{even_energy:.6f}\")\n        \n        # Lowest odd state energy\n        e_guesses_odd = guesses[case_label]['odd']\n        odd_energy = find_energy_secant(ic_odd, e_guesses_odd, alpha)\n        results.append(f\"{odd_energy:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "掌握了求解给定势阱中能谱的方法后，我们可以挑战一个更具创造性的任务：逆向设计一个具有特定量子性质的势阱。这类“逆向问题”在量子工程和材料设计中至关重要。本练习  将引导你使用更高级的数值工具，例如用于高效计数本征值数目的斯特姆序列法，并通过二分法自动调节势阱深度，以精确地获得预设数量的束缚态。这让你从一个问题解决者，转变为一个量子系统设计者。",
            "id": "2388915",
            "problem": "设计并实现一个程序，该程序利用量子力学和数值分析的第一性原理，构建一个单参数的一维“漏斗”势阱族，并自动调节深度参数以产生指定数量的束缚态。在无量纲单位下进行计算，其中 $\\hbar^{2}/(2m)=1$，此时定态薛定谔方程为\n$$\n- \\frac{d^{2}\\psi(x)}{dx^{2}} + V(x)\\,\\psi(x) = E\\,\\psi(x).\n$$\n假设当 $|x|\\to\\infty$ 时 $V(x)\\to 0$，则束缚态被定义为能量本征值 $E  0$ 的状态。考虑光滑的“漏斗”势阱族\n$$\nV(x;V_{0},b,p) = -\\frac{V_{0}}{1+\\left(\\frac{|x|}{b}\\right)^{p}},\n$$\n其中深度参数 $V_{0}0$，宽度尺度 $b0$，形状参数 $p0$。在有限区间 $[-L,L]$（其中 $L\\gg b$）上，施加齐次狄利克雷边界条件 $\\psi(-L)=\\psi(L)=0$，并使用标准的中心二阶有限差分近似来离散化二阶导数，从而在间距为 $h$ 的均匀网格上离散化算符。这将产生一个实的对称三对角哈密顿矩阵，其对角线元素为 $a_{i} = 2/h^{2} + V(x_{i})$，非对角线元素为 $-1/h^{2}$。使用 Sylvester 惯性定理和针对对称三对角矩阵的施图姆序列特性，对于给定的 $V_{0}$，计算严格低于阈值 $\\lambda=0$ 的本征值数量。然后，仅利用能谱相对于势阱深度 $V_{0}$ 的单调性，实现一个稳健的二分法程序，以找到使 $E0$ 的本征值数量等于目标值 $N_{\\mathrm{target}}$ 的最小 $V_{0}$。\n\n您可以使用的基本原理包括：定态薛定谔方程、对于在无穷远处趋于零的势阱其束缚态定义为 $E0$、有限差分近似，以及用于计算低于某个平移值的本征值数量的施图姆序列/惯性方法。\n\n物理单位：由于选择了 $\\hbar^{2}/(2m)=1$，所有量均视为无量纲。程序必须报告无量纲的 $V_{0}$ 值，并四舍五入到六位小数。\n\n离散化要求：\n- 选择 $L$ 为 $L=\\alpha\\,b$，其中 $\\alpha$ 是一个固定的足够大的值，以近似 $|x|\\to\\infty$ 的边界；选择 $h$ 为 $h=\\beta\\,b$，其中 $\\beta$ 是一个固定的足够小的值，以解析束缚态的波函数。对于本任务，使用 $\\alpha = 20$ 和 $\\beta = 0.01$。\n- 在构建具有狄利克雷边界条件（在 $x=\\pm L$ 处）的三对角哈密顿矩阵时，仅使用内部网格点。\n\n算法要求：\n- 实现一个函数，给定主对角线数组 $a_{i}$ 和恒定的非对角线元素大小 $|b_{\\mathrm{FD}}|=1/h^{2}$，使用施图姆递归\n$$\nd_{1} = a_{1}-\\lambda,\\quad d_{k} = (a_{k}-\\lambda) - \\frac{b_{\\mathrm{FD}}^{2}}{d_{k-1}}\\quad\\text{对于 }k\\ge 2,\n$$\n返回严格小于 $\\lambda=0$ 的本征值数量，并通过计数有多少个 $d_{k}$ 为负数来实现。在 $|d_{k-1}|$ 变得非常小时，实施数值保护措施以防除法运算出错，同时避免不必要地改变符号。\n- 在 $V_{0}$ 上实现一个二分法程序，该程序先确定区间，然后分离出使得小于 $0$ 的本征值数量等于 $N_{\\mathrm{target}}$ 的最小 $V_{0}$。从 $V_{0,\\mathrm{low}}=0$ 开始，并将 $V_{0,\\mathrm{high}}$ 以 $2$ 的倍数增加，直到满足区间条件。当区间宽度小于容差 $\\varepsilon_{V}$ 时终止；对于本任务，使用 $\\varepsilon_{V}=10^{-8}$。\n\n测试套件和要求输出：\n- 使用以下测试用例，每个用例由 $(N_{\\mathrm{target}}, b, p)$ 指定，所有单位均为无量纲：\n    - 用例 A (happy path): $(5, 1.0, 2.0)$。\n    - 用例 B (宽漏斗): $(5, 2.0, 2.0)$。\n    - 用例 C (陡峭核心): $(5, 1.0, 6.0)$。\n    - 用例 D (窄漏斗): $(5, 0.5, 2.0)$。\n- 对于每种情况，根据上述程序计算并返回能够产生恰好 $N_{\\mathrm{target}}$ 个束缚态的最小 $V_{0}$，其中使用 $L=\\alpha\\,b$（$\\alpha=20$）和 $h=\\beta\\,b$（$\\beta=0.01$）。最终的程序输出必须是单行文本，包含一个由逗号分隔的四个 $V_{0}$ 值的列表，每个值四舍五入到六位小数，并用方括号括起来，例如，“[vA,vB,vC,vD]”。",
            "solution": "所提出的问题是计算量子力学中一个明确定义的练习，要求确定一个势参数 $V_0$，使其能产生特定数量的束缚态。该问题具有科学依据，内部逻辑一致，并且不需要超出所提供信息的任何额外信息。因此，它是有效的，并允许进行严格求解。\n\n物理基础是一维定态薛定谔方程，在指定的无量纲单位 $\\hbar^2/(2m)=1$ 下，其形式为：\n$$\n- \\frac{d^{2}\\psi(x)}{dx^{2}} + V(x)\\,\\psi(x) = E\\,\\psi(x)\n$$\n所考虑的势阱是“漏斗”势 $V(x; V_0, b, p) = -V_0 / (1 + (|x|/b)^p)$。束缚态是能量本征值 $E  0$ 的解。对于任意势阱，求解此本征值问题需要数值方法。指定的方法涉及在有限空间域上离散化问题。\n\n变量 $x$ 的连续域被替换为有限区间 $[-L, L]$，其中 $L$ 被选择得足够大（$L = \\alpha b$，$\\alpha=20$）以近似无限域。施加齐次狄利克雷边界条件 $\\psi(-L) = \\psi(L) = 0$。该区间被离散化为一个均匀网格，间距为 $h = \\beta b$（$\\beta=0.01$）。网格点为 $x_i = -L + i \\cdot h$，其中 $i=0, 1, \\dots, N_{\\mathrm{grid}}$，$N_{\\mathrm{grid}} = 2L/h$。解 $\\psi(x)$ 在 $M = N_{\\mathrm{grid}}-1$ 个内部点上求解。\n\n二阶导数算符使用二阶中心差分格式进行近似：\n$$\n\\frac{d^2\\psi}{dx^2}\\bigg|_{x=x_i} \\approx \\frac{\\psi_{i+1} - 2\\psi_i + \\psi_{i-1}}{h^2}\n$$\n其中 $\\psi_i \\equiv \\psi(x_i)$。将此代入薛定谔方程，将微分方程转换为矩阵本征值方程 $H\\vec{\\psi} = E\\vec{\\psi}$。此处，$H$ 是一个大小为 $M \\times M$ 的实对称三对角矩阵，其元素为：\n-   对角线：$a_i = \\frac{2}{h^2} + V(x_i)$，其中 $i=1, \\dots, M$。\n-   非对角线：$b_{i, i\\pm 1} = -\\frac{1}{h^2}$。\n\n目标是找到哈密顿矩阵 $H$ 小于 $0$ 的本征值数量。问题没有采用计算成本高昂的完全对角化方法，而是指定使用施图姆序列法。该方法基于 Sylvester 惯性定理，能在 $O(M)$ 次操作内确定对称三对角矩阵低于给定平移值 $\\lambda$ 的本征值数量。小于 $\\lambda$ 的本征值数量等于通过以下递推关系计算的序列 $\\{d_k\\}_{k=1}^M$ 中负项的数量：\n$$\nd_1 = a_1 - \\lambda\n$$\n$$\nd_k = (a_k - \\lambda) - \\frac{b_{\\mathrm{FD}}^2}{d_{k-1}}, \\quad \\text{对于 } k=2, \\dots, M\n$$\n其中 $b_{\\mathrm{FD}} = -1/h^2$ 是非对角线元素。对于本问题，平移值为 $\\lambda=0$。为处理项 $d_{k-1}$ 在数值上为零的情况，将其替换为一个小的正数，以防止除以零，同时不会错误地改变符号计数。此过程为给定的势阱深度 $V_0$ 提供了束缚态的数量 $N(V_0)$。\n\n束缚态的数量 $N(V_0)$ 是 $V_0$ 的单调不减函数，这是量子力学变分原理的一个推论。这一关键性质允许使用二分搜索算法来高效地找到使 $N(V_0) = N_{\\mathrm{target}}$ 成立的最小 $V_0$。搜索过程如下：\n1.  **确定区间**：找到一个包含目标 $V_0$ 的区间 $[V_{0,\\mathrm{low}}, V_{0,\\mathrm{high}}]$。我们从 $V_{0,\\mathrm{low}} = 0$ 开始，此时 $N(0)=0$。上界 $V_{0,\\mathrm{high}}$ 通过从一个猜测值（例如，$V_{0,\\mathrm{high}}=1.0$）开始，并反复将其加倍，直到 $N(V_{0,\\mathrm{high}}) \\ge N_{\\mathrm{target}}$ 为止。\n2.  **二分法**：迭代地细化区间。在每一步，测试中点 $V_{0,\\mathrm{mid}} = (V_{0,\\mathrm{low}} + V_{0,\\mathrm{high}})/2$。如果 $N(V_{0,\\mathrm{mid}})  N_{\\mathrm{target}}$，则势阱还不够深，因此我们更新 $V_{0,\\mathrm{low}} = V_{0,\\mathrm{mid}}$。如果 $N(V_{0,\\mathrm{mid}}) \\ge N_{\\mathrm{target}}$，则势阱足够深，因此我们更新 $V_{0,\\mathrm{high}} = V_{0,\\mathrm{mid}}$ 以继续搜索最小值。\n重复此过程，直到区间宽度 $(V_{0,\\mathrm{high}} - V_{0,\\mathrm{low}})$ 小于指定的容差 $\\varepsilon_V = 10^{-8}$。最终答案是得到的上界 $V_{0,\\mathrm{high}}$。\n\n该算法被实现以处理提供的每个测试用例 $(N_{\\mathrm{target}}, b, p)$，并以要求的格式报告计算出的 $V_0$ 值（四舍五入到六位小数）。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    It orchestrates the calculation of V0 for each case and prints the final result.\n    \"\"\"\n\n    # Global constants defined in the problem statement\n    ALPHA = 20.0\n    BETA = 0.01\n    EPSILON_V = 1e-8\n    # Small number to safeguard against division by zero in the Sturm sequence.\n    STURM_SAFEGUARD = 1e-30\n\n    def sturm_count_eigenvalues_below_shift(diag, off_diag_sq, shift):\n        \"\"\"\n        Counts the number of eigenvalues of a symmetric tridiagonal matrix\n        that are strictly less than a given shift.\n\n        Args:\n            diag (np.ndarray): The main diagonal of the matrix.\n            off_diag_sq (float): The square of the constant off-diagonal element.\n            shift (float): The energy threshold for counting eigenvalues.\n\n        Returns:\n            int: The number of eigenvalues less than the shift.\n        \"\"\"\n        count = 0\n        \n        # Initialize the first term of the Sturm sequence\n        d_prev = diag[0] - shift\n        if d_prev  0:\n            count += 1\n        \n        # Safeguard for d_prev being numerically zero\n        if abs(d_prev)  STURM_SAFEGUARD:\n            d_prev = STURM_SAFEGUARD\n        \n        # Iterate through the rest of the sequence\n        for i in range(1, len(diag)):\n            d_k = (diag[i] - shift) - off_diag_sq / d_prev\n            if d_k  0:\n                count += 1\n            \n            # Safeguard for d_k being numerically zero\n            if abs(d_k)  STURM_SAFEGUARD:\n                d_k = STURM_SAFEGUARD\n            \n            d_prev = d_k\n            \n        return count\n\n    def get_bound_state_count(V0, b, p):\n        \"\"\"\n        Sets up the discrete Hamiltonian and counts the number of bound states (E  0).\n\n        Args:\n            V0 (float): The depth parameter of the potential.\n            b (float): The width parameter of the potential.\n            p (float): The shape parameter of the potential.\n\n        Returns:\n            int: The number of bound states for the given potential.\n        \"\"\"\n        # 1. Define discretization parameters based on b\n        L = ALPHA * b\n        h = BETA * b\n        \n        # 2. Set up the spatial grid (interior points only)\n        num_interior_points = int(round(2 * L / h)) - 1\n        x = np.linspace(-L + h, L - h, num_interior_points)\n        \n        # 3. Calculate the potential on the grid\n        V = -V0 / (1.0 + (np.abs(x) / b)**p)\n        \n        # 4. Define the Hamiltonian matrix elements\n        h_sq = h * h\n        diagonal = 2.0 / h_sq + V\n        off_diagonal_squared = (1.0 / h_sq)**2\n        \n        # 5. Count eigenvalues below the bound state threshold (E=0)\n        return sturm_count_eigenvalues_below_shift(diagonal, off_diagonal_squared, 0.0)\n\n    def find_minimal_V0(N_target, b, p):\n        \"\"\"\n        Finds the smallest V0 that produces at least N_target bound states\n        using a bisection search algorithm.\n\n        Args:\n            N_target (int): The target number of bound states.\n            b (float): The width parameter of the potential.\n            p (float): The shape parameter of the potential.\n\n        Returns:\n            float: The minimal V0 value.\n        \"\"\"\n        # Phase 1: Bracket the solution\n        V_low = 0.0\n        \n        # For N_target=0, V0=0 is the trivial solution.\n        # For N_target > 0, V0=0 gives 0 states.\n        if N_target == 0:\n            return 0.0\n\n        # Start with a reasonable guess for V_high and expand until it's large enough.\n        V_high = 1.0\n        while get_bound_state_count(V_high, b, p)  N_target:\n            V_low = V_high\n            V_high *= 2.0\n            # Safety break to prevent an infinite loop in unforeseen circumstances.\n            if V_high > 1e6:\n                raise RuntimeError(\"Bracketing search for V0 failed to converge.\")\n\n        # Phase 2: Bisection to find the precise V0\n        while (V_high - V_low) > EPSILON_V:\n            V_mid = V_low + (V_high - V_low) / 2.0\n            \n            # Prevent getting stuck if precision limit is reached\n            if V_mid == V_low or V_mid == V_high:\n                break\n            \n            num_states = get_bound_state_count(V_mid, b, p)\n            \n            if num_states  N_target:\n                # Potential well is not deep enough\n                V_low = V_mid\n            else: # num_states >= N_target\n                # Potential is deep enough, this could be the answer, or a smaller V0 works\n                V_high = V_mid\n                \n        # V_high is the upper bound of the final interval, representing the smallest V0\n        # that yields N_target states.\n        return V_high\n\n    # Test suite from the problem statement\n    test_cases = [\n        # (N_target, b, p)\n        (5, 1.0, 2.0),  # Case A: happy path\n        (5, 2.0, 2.0),  # Case B: wide funnel\n        (5, 1.0, 6.0),  # Case C: steep core\n        (5, 0.5, 2.0),  # Case D: narrow funnel\n    ]\n\n    results = []\n    for case in test_cases:\n        N_target, b, p = case\n        V0_result = find_minimal_V0(N_target, b, p)\n        results.append(V0_result)\n\n    # Format and print the final output as a single line\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\nsolve()\n```"
        }
    ]
}