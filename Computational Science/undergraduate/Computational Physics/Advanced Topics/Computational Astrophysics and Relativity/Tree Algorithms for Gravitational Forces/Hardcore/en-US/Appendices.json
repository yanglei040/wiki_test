{
    "hands_on_practices": [
        {
            "introduction": "This foundational practice guides you through the complete construction of a two-dimensional N-body gravitational simulator. By implementing a Barnes-Hut quadtree and a symplectic leapfrog integrator, you will model the dynamics of a protoplanetary disk around a central star . The exercise culminates in analyzing the conservation of angular momentum, a key diagnostic for assessing the accuracy and stability of your numerical scheme, providing a comprehensive, hands-on understanding of how tree codes are applied in astrophysical simulations.",
            "id": "2447325",
            "problem": "Implement a two-dimensional gravitational $N$-body simulator using a Barnes–Hut (BH) quadtree to approximate forces in a rotating protoplanetary disk and track the total angular momentum over time to analyze its conservation. Work entirely in dimensionless \"code units\" with gravitational constant $G=1$, so no physical units are required. All angular measures must be in radians. Your task is to design and implement the complete algorithm from first principles, beginning from fundamental laws and core definitions, without relying on any prepackaged $N$-body routines.\n\nThe simulation domain consists of a central star and a surrounding disk of particles:\n- The central star has mass $M_{\\star}$ placed initially at the origin.\n- The disk has total mass $M_{\\mathrm{disk}}$ distributed among $N_{\\mathrm{disk}}$ equal-mass particles sampled in an annulus with inner radius $r_{\\min}$ and outer radius $r_{\\max}$, with radial probability density proportional to $r$ on $[r_{\\min}, r_{\\max}]$ and uniform angle in $[0,2\\pi)$.\n- The initial velocity of each disk particle is tangential and set to the circular speed generated by the central star alone, so that $v(r) = \\sqrt{G M_{\\star} / r}$ with direction perpendicular to the radius vector, consistent with prograde rotation. The star’s initial velocity is zero.\n\nFundamental base:\n- Newton’s second law: $m_i \\, d^2 \\mathbf{r}_i/dt^2 = \\mathbf{F}_i$.\n- Newton’s law of universal gravitation for point masses with Plummer softening: for particles $i \\neq j$, the acceleration on $i$ due to $j$ is\n$$\n\\mathbf{a}_{i\\leftarrow j} = G \\, m_j \\, \\frac{\\mathbf{r}_j - \\mathbf{r}_i}{\\left(\\lVert \\mathbf{r}_j - \\mathbf{r}_i \\rVert^2 + \\epsilon^2\\right)^{3/2}} \\, .\n$$\n- Total angular momentum about the origin in two dimensions (the $z$-component) is\n$$\nL_z = \\sum_{i=1}^{N} m_i \\, (x_i v_{y,i} - y_i v_{x,i}) \\, .\n$$\n\nAlgorithmic requirements:\n- Use a Barnes–Hut quadtree (define acronym on first use) in two dimensions. Each tree node stores total mass and center of mass. Use the geometric acceptance criterion that treats a node of side length $s$ at center-of-mass distance $d$ from the target particle as a single source when $s/d  \\theta$, where $\\theta$ is the opening angle parameter. If not accepted, recurse into children. For leaf nodes, sum direct pairwise softened contributions, excluding self-interaction.\n- Use a symplectic leapfrog (kick–drift–kick) time integrator with fixed time step $\\Delta t$:\n  $$\n  \\mathbf{v}^{n+\\frac{1}{2}} = \\mathbf{v}^n + \\frac{\\Delta t}{2}\\,\\mathbf{a}(\\mathbf{r}^n), \\quad\n  \\mathbf{r}^{n+1} = \\mathbf{r}^n + \\Delta t\\,\\mathbf{v}^{n+\\frac{1}{2}}, \\quad\n  \\mathbf{v}^{n+1} = \\mathbf{v}^{n+\\frac{1}{2}} + \\frac{\\Delta t}{2}\\,\\mathbf{a}(\\mathbf{r}^{n+1}) \\, .\n  $$\n- Track the initial angular momentum $L_z(0)$ and the final angular momentum $L_z(T)$ at the end of the integration interval $T = n_{\\mathrm{steps}} \\, \\Delta t$. Report the relative drift (dimensionless) defined by\n$$\n\\delta_L = \\frac{\\lvert L_z(T) - L_z(0) \\rvert}{\\lvert L_z(0) \\rvert} \\, .\n$$\n\nImplementation details and constraints:\n- Use a deterministic random number generator seed for initial condition generation so that results are reproducible.\n- Construct the root quadtree cell to enclose all particles, and subdivide as needed. Prevent pathological infinite subdivision by allowing a small maximum depth and switching to direct summation within an over-refined leaf.\n- Ensure that the tree is rebuilt at each time step when computing forces.\n- The program must not read input. It must generate the specified test cases internally and print the results.\n\nTest suite:\nCommon parameters for all tests:\n- $G = 1$, $M_{\\star} = 10$, $M_{\\mathrm{disk}} = 1$, $N_{\\mathrm{disk}} = 128$, $r_{\\min} = 0.5$, $r_{\\max} = 2.5$, deterministic seed $= 42$, total number of particles $N = N_{\\mathrm{disk}} + 1$.\n- The initial conditions must be regenerated identically for each test so that only algorithmic parameters differ.\n\nEach test case specifies $(\\theta, \\Delta t, n_{\\mathrm{steps}}, \\epsilon)$:\n- Test $1$ (happy path): $(\\theta = 0.5, \\ \\Delta t = 0.01, \\ n_{\\mathrm{steps}} = 40, \\ \\epsilon = 0.02)$.\n- Test $2$ (stricter opening; boundary toward direct summation): $(\\theta = 0.2, \\ \\Delta t = 0.01, \\ n_{\\mathrm{steps}} = 40, \\ \\epsilon = 0.02)$.\n- Test $3$ (looser opening; larger approximation error): $(\\theta = 1.0, \\ \\Delta t = 0.01, \\ n_{\\mathrm{steps}} = 40, \\ \\epsilon = 0.02)$.\n- Test $4$ (coarser time step; integrator stress test): $(\\theta = 0.5, \\ \\Delta t = 0.02, \\ n_{\\mathrm{steps}} = 40, \\ \\epsilon = 0.02)$.\n\nFor each test, compute the scalar $\\delta_L$ defined above. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[0.00123,0.00045,0.00321,0.00456]$), in the order of Tests $1$ through $4$. The outputs are dimensionless real numbers. Angles must be in radians throughout. No additional text may be printed.",
            "solution": "We design the solution from first principles. Begin with Newton’s second law $m_i \\, d^2 \\mathbf{r}_i/dt^2 = \\mathbf{F}_i$. For a system of $N$ point masses interacting gravitationally, Newton’s law of universal gravitation gives the pairwise force $\\mathbf{F}_{ij}$ on $i$ by $j$. Dividing by $m_i$ yields the acceleration\n$$\n\\mathbf{a}_{i\\leftarrow j} = G \\, m_j \\, \\frac{\\mathbf{r}_j - \\mathbf{r}_i}{\\left(\\lVert \\mathbf{r}_j - \\mathbf{r}_i \\rVert^2 + \\epsilon^2\\right)^{3/2}} \\, ,\n$$\nwhere $\\epsilon$ is a small Plummer softening length introduced to regularize the singularity at zero separation and to model finite-sized mass elements. Summing over all $j \\neq i$ yields the net acceleration $\\mathbf{a}_i$.\n\nDefine the total angular momentum about the origin for a two-dimensional system by its $z$-component:\n$$\nL_z = \\sum_{i=1}^{N} m_i \\, (x_i v_{y,i} - y_i v_{x,i}) = \\sum_{i=1}^{N} m_i \\, (\\mathbf{r}_i \\times \\mathbf{v}_i)_z \\, .\n$$\nTaking a time derivative gives\n$$\n\\frac{dL_z}{dt} = \\sum_{i=1}^{N} m_i \\, (\\mathbf{r}_i \\times \\mathbf{a}_i)_z \\, .\n$$\nFor exact Newtonian gravity with pairwise central forces, internal torques cancel in pairs by Newton’s third law (equal and opposite forces along the line of centers), implying $\\frac{dL_z}{dt} = 0$ and conservation of total angular momentum in the absence of external torques. Numerical approximations can introduce violations of action–reaction symmetry and time integration error, leading to small drifts $\\delta_L$.\n\nDirect summation of all pairwise interactions costs $\\mathcal{O}(N^2)$ per force evaluation. The Barnes–Hut (BH) algorithm organizes particles into a hierarchical quadtree in two dimensions. Each node represents a square region and stores the total mass and center of mass of the particles inside. For a target particle at position $\\mathbf{r}$ and a tree node of side length $s$ whose center of mass is at distance $d$ from $\\mathbf{r}$, the monopole approximation treats the entire node as a single pseudo-particle located at its center of mass when\n$$\n\\frac{s}{d}  \\theta \\, ,\n$$\nwhere $\\theta$ is the opening angle parameter controlling accuracy–efficiency trade-off. If the criterion is not satisfied, the node is “opened” and we recurse into its children. For a leaf, we compute direct softened contributions from its contained particles, excluding self-interaction. The monopole truncation error scales as $\\mathcal{O}\\!\\left((s/d)^2\\right)$ for well-separated groups, so decreasing $\\theta$ improves accuracy and reduces systematic force asymmetries that can cause angular momentum drift.\n\nTime integration uses the symplectic leapfrog (kick–drift–kick) method, which is time-reversible and exhibits superior long-term conservation properties for Hamiltonian systems. Given time step $\\Delta t$, the update is:\n$$\n\\mathbf{v}^{n+\\frac{1}{2}} = \\mathbf{v}^n + \\frac{\\Delta t}{2}\\,\\mathbf{a}(\\mathbf{r}^n), \\quad\n\\mathbf{r}^{n+1} = \\mathbf{r}^n + \\Delta t\\,\\mathbf{v}^{n+\\frac{1}{2}}, \\quad\n\\mathbf{v}^{n+1} = \\mathbf{v}^{n+\\frac{1}{2}} + \\frac{\\Delta t}{2}\\,\\mathbf{a}(\\mathbf{r}^{n+1}) \\, .\n$$\nThis scheme requires one force evaluation at the beginning and one per step thereafter. We evaluate forces with the BH tree using the chosen $\\theta$ and softening $\\epsilon$.\n\nInitial conditions model a protoplanetary disk in code units. The central star of mass $M_{\\star}$ is at the origin with zero velocity. The disk of total mass $M_{\\mathrm{disk}}$ is represented by $N_{\\mathrm{disk}}$ equal-mass particles sampled in an annulus $[r_{\\min}, r_{\\max}]$, with radial probability density proportional to $r$ to achieve an area-uniform distribution in the annulus. A sample can be drawn by transforming a uniform variate $u \\in [0,1]$ into radius\n$$\nr = \\sqrt{u \\, (r_{\\max}^2 - r_{\\min}^2) + r_{\\min}^2} \\, ,\n$$\nand angle $\\phi$ uniform on $[0, 2\\pi)$. Each disk particle begins on a circular orbit around the star with speed $v(r) = \\sqrt{G M_{\\star}/r}$ in the tangential direction $\\hat{\\boldsymbol{\\phi}} = (-\\sin \\phi, \\cos \\phi)$, so that the initial state approximates a cold, near-Keplerian disk. The star’s initial velocity is zero; by symmetry, total linear momentum is near zero for a sufficiently isotropic sample.\n\nNumerical design details:\n- Tree construction: compute a bounding square containing all positions, with center and half-size slightly padded. Recursively subdivide nodes into four children (quadtree) as needed. To avoid pathological infinite subdivision for nearly coincident points, enforce a maximum depth (for example, $d_{\\max}$) and permit a leaf to store multiple bodies once the limit is reached; such leaves are summed by direct interaction.\n- Mass and center-of-mass computation: after all insertions, perform a post-order traversal to compute each node’s total mass and center of mass from its children or contained bodies.\n- Force evaluation: for a target particle, traverse the tree, applying the acceptance criterion $s/d  \\theta$. For accepted nodes, add the softened monopole acceleration. For leaves or rejected nodes, recurse or sum directly, skipping self-interaction. Use $\\epsilon$ to compute softened distances via $(r^2 + \\epsilon^2)^{3/2}$.\n- Angular momentum tracking: compute $L_z(0)$ from initial positions and velocities. Run the leapfrog integrator for $n_{\\mathrm{steps}}$ steps. After performing the final half-kick, compute $L_z(T)$ and the relative drift\n$$\n\\delta_L = \\frac{\\lvert L_z(T) - L_z(0) \\rvert}{\\lvert L_z(0) \\rvert} \\, .\n$$\n\nTest suite rationale:\n- Test $1$ ($\\theta = 0.5$, $\\Delta t = 0.01$, $n_{\\mathrm{steps}} = 40$, $\\epsilon = 0.02$) is a balanced configuration expected to yield small $\\delta_L$.\n- Test $2$ ($\\theta = 0.2$) tightens the opening angle, bringing the BH forces closer to direct summation; $\\delta_L$ should not exceed Test $1$ and typically decreases.\n- Test $3$ ($\\theta = 1.0$) loosens the criterion, increasing approximation error; $\\delta_L$ is expected to be larger than in Tests $1$–$2$.\n- Test $4$ (coarser $\\Delta t = 0.02$) stresses the time integrator, likely increasing $\\delta_L$ even with the same $\\theta$ as Test $1$.\n\nThe program regenerates identical initial conditions for each test (same seed) and runs the simulation with the specified parameters, computing the four $\\delta_L$ values. It prints a single line formatted as a Python-style list $[x_1,x_2,x_3,x_4]$, where each $x_k$ is the corresponding $\\delta_L$ for Test $k$. All outputs are dimensionless real numbers and angles are in radians throughout.",
            "answer": "```python\n# Barnes–Hut angular momentum conservation analysis in a rotating disk\n# Execution environment: Python 3.12, numpy 1.23.5, scipy 1.11.4 (not used)\nimport numpy as np\n\n# ----------------------------\n# Utility: angular momentum\n# ----------------------------\ndef angular_momentum_z(m, r, v):\n    # Lz = sum m_i (x_i v_yi - y_i v_xi)\n    return float(np.sum(m * (r[:, 0] * v[:, 1] - r[:, 1] * v[:, 0])))\n\n# ----------------------------\n# Quadtree implementation\n# ----------------------------\nclass QuadNode:\n    __slots__ = (\n        \"cx\", \"cy\", \"h\", \"children\", \"bodies\", \"mass\", \"comx\", \"comy\", \"depth\"\n    )\n\n    def __init__(self, cx, cy, h, depth=0):\n        self.cx = float(cx)\n        self.cy = float(cy)\n        self.h = float(h)  # half-size\n        self.children = None  # list of 4 QuadNode or None\n        self.bodies = []      # list of indices if leaf\n        self.mass = 0.0\n        self.comx = 0.0\n        self.comy = 0.0\n        self.depth = depth\n\n    def subdivide(self):\n        hh = 0.5 * self.h\n        d = self.depth + 1\n        self.children = [\n            QuadNode(self.cx - hh, self.cy - hh, hh, d),  # SW\n            QuadNode(self.cx + hh, self.cy - hh, hh, d),  # SE\n            QuadNode(self.cx - hh, self.cy + hh, hh, d),  # NW\n            QuadNode(self.cx + hh, self.cy + hh, hh, d),  # NE\n        ]\n\n    def which_child(self, x, y):\n        east = x > self.cx\n        north = y > self.cy\n        if not east and not north:\n            return 0  # SW\n        if east and not north:\n            return 1  # SE\n        if not east and north:\n            return 2  # NW\n        return 3  # NE\n\n    def insert(self, idx, pos, max_bucket, max_depth):\n        # Insert body index idx at position pos[idx]\n        if self.children is None:\n            # Leaf: store body\n            self.bodies.append(idx)\n            # If exceeds bucket and can subdivide, split and reinsert\n            if len(self.bodies) > max_bucket and self.depth  max_depth:\n                self.subdivide()\n                old = self.bodies\n                self.bodies = []\n                for j in old:\n                    child = self.which_child(pos[j, 0], pos[j, 1])\n                    self.children[child].insert(j, pos, max_bucket, max_depth)\n        else:\n            # Internal: insert into appropriate child\n            child = self.which_child(pos[idx, 0], pos[idx, 1])\n            self.children[child].insert(idx, pos, max_bucket, max_depth)\n\n    def finalize_mass_com(self, m, pos):\n        if self.children is None:\n            if len(self.bodies) == 0:\n                self.mass = 0.0\n                self.comx = self.cx\n                self.comy = self.cy\n            elif len(self.bodies) == 1:\n                j = self.bodies[0]\n                self.mass = float(m[j])\n                self.comx = float(pos[j, 0])\n                self.comy = float(pos[j, 1])\n            else:\n                # Aggregate\n                mm = 0.0\n                cx = 0.0\n                cy = 0.0\n                for j in self.bodies:\n                    mj = float(m[j])\n                    mm += mj\n                    cx += mj * float(pos[j, 0])\n                    cy += mj * float(pos[j, 1])\n                self.mass = mm\n                if mm > 0.0:\n                    self.comx = cx / mm\n                    self.comy = cy / mm\n                else:\n                    self.comx = self.cx\n                    self.comy = self.cy\n        else:\n            mm = 0.0\n            cx = 0.0\n            cy = 0.0\n            for ch in self.children:\n                ch.finalize_mass_com(m, pos)\n                mm += ch.mass\n                cx += ch.mass * ch.comx\n                cy += ch.mass * ch.comy\n            self.mass = mm\n            if mm > 0.0:\n                self.comx = cx / mm\n                self.comy = cy / mm\n            else:\n                self.comx = self.cx\n                self.comy = self.cy\n\n    def acc_on(self, i, pos, m, G, theta, eps2):\n        ax = 0.0\n        ay = 0.0\n        if self.mass == 0.0:\n            return 0.0, 0.0\n\n        # Distance from particle i to node COM\n        dx = self.comx - pos[i, 0]\n        dy = self.comy - pos[i, 1]\n        d2 = dx * dx + dy * dy\n\n        if self.children is None:\n            # Leaf: direct sum over contained bodies excluding self\n            for j in self.bodies:\n                if j == i:\n                    continue\n                rx = pos[j, 0] - pos[i, 0]\n                ry = pos[j, 1] - pos[i, 1]\n                r2 = rx * rx + ry * ry + eps2\n                invr3 = 1.0 / (r2 * np.sqrt(r2))\n                s = G * float(m[j]) * invr3\n                ax += s * rx\n                ay += s * ry\n            return ax, ay\n\n        # Internal node: apply BH acceptance criterion\n        # side length s = 2h\n        if d2 > 0.0:\n            s_over_d = (2.0 * self.h) / np.sqrt(d2)\n        else:\n            s_over_d = np.inf\n\n        if s_over_d  theta:\n            # Accept node as single source\n            r2 = d2 + eps2\n            invr3 = 1.0 / (r2 * np.sqrt(r2))\n            s = G * self.mass * invr3\n            ax += s * dx\n            ay += s * dy\n        else:\n            # Recurse into children\n            for ch in self.children:\n                cx, cy = ch.acc_on(i, pos, m, G, theta, eps2)\n                ax += cx\n                ay += cy\n        return ax, ay\n\n# ----------------------------\n# Force computation via BH\n# ----------------------------\ndef compute_accelerations(pos, m, theta, eps, max_bucket=1, max_depth=20):\n    N = pos.shape[0]\n    # Build bounding square\n    xmin = float(np.min(pos[:, 0]))\n    xmax = float(np.max(pos[:, 0]))\n    ymin = float(np.min(pos[:, 1]))\n    ymax = float(np.max(pos[:, 1]))\n    cx = 0.5 * (xmin + xmax)\n    cy = 0.5 * (ymin + ymax)\n    half = max(xmax - xmin, ymax - ymin) * 0.5\n    if half = 0.0:\n        half = 1.0\n    half *= 1.05  # small padding\n\n    root = QuadNode(cx, cy, half, depth=0)\n    for i in range(N):\n        root.insert(i, pos, max_bucket, max_depth)\n    root.finalize_mass_com(m, pos)\n\n    G = 1.0\n    eps2 = float(eps) * float(eps)\n    acc = np.zeros_like(pos)\n    for i in range(N):\n        ax, ay = root.acc_on(i, pos, m, G, theta, eps2)\n        acc[i, 0] = ax\n        acc[i, 1] = ay\n    return acc\n\n# ----------------------------\n# Leapfrog integrator (KDK)\n# ----------------------------\ndef leapfrog_bh(pos0, vel0, m, dt, nsteps, theta, eps):\n    pos = pos0.copy()\n    vel = vel0.copy()\n\n    # Initial angular momentum (using velocities at integer time)\n    L0 = angular_momentum_z(m, pos, vel)\n\n    # Initial acceleration and half kick\n    acc = compute_accelerations(pos, m, theta, eps)\n    vel += 0.5 * dt * acc\n\n    # Time stepping\n    for step in range(nsteps):\n        pos += dt * vel\n        acc = compute_accelerations(pos, m, theta, eps)\n        if step != nsteps - 1:\n            vel += dt * acc\n\n    # Final half kick\n    vel += 0.5 * dt * acc\n\n    Lf = angular_momentum_z(m, pos, vel)\n    rel_drift = abs(Lf - L0) / max(1e-16, abs(L0))\n    return rel_drift\n\n# ----------------------------\n# Initial conditions: rotating disk + central star\n# ----------------------------\ndef generate_initial_conditions(seed, N_disk, M_star, M_disk, rmin, rmax):\n    rng = np.random.default_rng(seed)\n    # Star at origin\n    pos_star = np.array([[0.0, 0.0]])\n    vel_star = np.array([[0.0, 0.0]])\n    m_star = np.array([M_star], dtype=float)\n\n    # Disk sampling: radial PDF ∝ r on [rmin, rmax]\n    u = rng.random(N_disk)\n    radii = np.sqrt(u * (rmax * rmax - rmin * rmin) + rmin * rmin)\n    phi = rng.random(N_disk) * (2.0 * np.pi)\n    x = radii * np.cos(phi)\n    y = radii * np.sin(phi)\n    pos_disk = np.column_stack((x, y))\n\n    # Tangential velocity for circular orbit due to star alone\n    G = 1.0\n    v_mag = np.sqrt(G * M_star / np.maximum(radii, 1e-12))\n    vx = -v_mag * np.sin(phi)\n    vy =  v_mag * np.cos(phi)\n    vel_disk = np.column_stack((vx, vy))\n\n    # Masses\n    m_disk = np.full(N_disk, M_disk / N_disk, dtype=float)\n\n    # Combine star + disk\n    pos = np.vstack((pos_star, pos_disk))\n    vel = np.vstack((vel_star, vel_disk))\n    m = np.concatenate((m_star, m_disk))\n    return pos, vel, m\n\n# ----------------------------\n# Main solve function\n# ----------------------------\ndef solve():\n    # Common parameters\n    G = 1.0  # code units\n    M_star = 10.0\n    M_disk = 1.0\n    N_disk = 128\n    rmin = 0.5\n    rmax = 2.5\n    seed = 42\n\n    # Test suite: (theta, dt, nsteps, eps)\n    test_cases = [\n        (0.5, 0.01, 40, 0.02),  # Test 1: happy path\n        (0.2, 0.01, 40, 0.02),  # Test 2: stricter opening\n        (1.0, 0.01, 40, 0.02),  # Test 3: looser opening\n        (0.5, 0.02, 40, 0.02),  # Test 4: coarser time step\n    ]\n\n    # Generate identical initial conditions for each test\n    pos0, vel0, m = generate_initial_conditions(seed, N_disk, M_star, M_disk, rmin, rmax)\n\n    results = []\n    for theta, dt, nsteps, eps in test_cases:\n        # Copy initial conditions so each test starts identically\n        pos = pos0.copy()\n        vel = vel0.copy()\n        rel_drift = leapfrog_bh(pos, vel, m, dt, nsteps, theta, eps)\n        # format with reasonable precision\n        results.append(rel_drift)\n\n    # Print in the exact required format\n    # Use repr-like formatting for clarity without extra text\n    print(f\"[{','.join(f'{x:.8g}' for x in results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "Moving beyond just calculating the net force, this exercise delves into the finer details of the gravitational field by computing the tidal tensor, $T_{ij} = \\partial a_i / \\partial x_j$. You will extend a tree-code framework to approximate this tensor and compare its accuracy against a direct-sum calculation . Because higher-order derivatives are more sensitive to approximation errors, this practice offers a more rigorous test of the multipole expansion and provides insight into the differential forces responsible for phenomena like galactic tides and stellar disruption.",
            "id": "2447281",
            "problem": "You are given a three-dimensional system of $N$ point masses at positions $\\{\\mathbf{r}_k\\}_{k=1}^N \\subset \\mathbb{R}^3$ with positive masses $\\{m_k\\}_{k=1}^N$. Work in code units with gravitational constant $G = 1$ and use Plummer softening with softening length $\\varepsilon > 0$. The gravitational potential at position $\\mathbf{x} \\in \\mathbb{R}^3$ is\n$$\n\\Phi(\\mathbf{x}) \\;=\\; -\\sum_{k=1}^N \\frac{m_k}{\\sqrt{\\|\\mathbf{x}-\\mathbf{r}_k\\|^2 + \\varepsilon^2}} \\, .\n$$\nDefine the gravitational force per unit test mass (acceleration) by $\\mathbf{a}(\\mathbf{x}) = -\\nabla \\Phi(\\mathbf{x})$, and define the tidal tensor by $T(\\mathbf{x}) = \\nabla \\mathbf{a}(\\mathbf{x})$, i.e., the Jacobian matrix with components $T_{ij}(\\mathbf{x}) = \\partial a_i(\\mathbf{x})/\\partial x_j$.\n\nConsider the following approximation rule for grouping sources. For any subset $S \\subset \\{1,\\dots,N\\}$, let $M_S = \\sum_{k \\in S} m_k$ be its total mass, let $\\mathbf{c}_S = \\left(\\sum_{k \\in S} m_k \\mathbf{r}_k\\right) / M_S$ be its center of mass, and let $L_S > 0$ be the side length of an axis-aligned cubic bounding box that contains $\\{\\mathbf{r}_k\\}_{k \\in S}$. For a target $\\mathbf{x}$ and an opening parameter $\\theta \\in (0,1)$, the contribution of $S$ may be approximated by treating the subset as a single point mass $M_S$ at $\\mathbf{c}_S$ if and only if\n$$\n\\frac{L_S}{\\|\\mathbf{x} - \\mathbf{c}_S\\|} \\;\\le\\; \\theta \\, .\n$$\nOtherwise, $S$ must be partitioned into disjoint proper subsets, and the same rule applied recursively until every contributing subset satisfies the acceptance inequality or consists of a single source.\n\nYour task is to write a complete, runnable program that, for each test case specified below:\n- computes the exact (direct-sum) $\\mathbf{a}(\\mathbf{x})$ and $T(\\mathbf{x})$ at each listed target $\\mathbf{x}$,\n- computes the approximate grouped-sum $\\mathbf{a}(\\mathbf{x})$ and $T(\\mathbf{x})$ at each listed target $\\mathbf{x}$ according to the acceptance rule above, and\n- reports, for each test case, two real numbers:\n  1. the maximum relative error over the provided targets in the acceleration, measured as $\\max_{\\mathbf{x}} \\|\\mathbf{a}_{\\mathrm{approx}}(\\mathbf{x}) - \\mathbf{a}_{\\mathrm{exact}}(\\mathbf{x})\\|_2 \\,/\\, \\|\\mathbf{a}_{\\mathrm{exact}}(\\mathbf{x})\\|_2$,\n  2. the maximum relative error over the provided targets in the tidal tensor, measured as $\\max_{\\mathbf{x}} \\|T_{\\mathrm{approx}}(\\mathbf{x}) - T_{\\mathrm{exact}}(\\mathbf{x})\\|_F \\,/\\, \\|T_{\\mathrm{exact}}(\\mathbf{x})\\|_F$, where $\\|\\cdot\\|_F$ is the Frobenius norm.\n\nAll computations are dimensionless in these code units; report the final errors as pure real numbers (no units). Angles do not appear. There are no percentages; all results are real numbers.\n\nUse the following test suite. For each test case, the program must use the given opening parameter $\\theta$ and softening length $\\varepsilon$, evaluate at the listed targets, and use the exact same source data.\n\nTest case $1$ (cluster at cube corners; general case):\n- Sources: masses and positions\n  - $m = [\\,1.0,\\, 2.0,\\, 3.0,\\, 4.0,\\, 1.5,\\, 0.5,\\, 0.8,\\, 2.5\\,]$,\n  - $\\mathbf{r} = [\\,(-1.0,-1.0,-1.0),\\; (1.0,-1.0,-1.0),\\; (-1.0,1.0,-1.0),\\; (1.0,1.0,-1.0),\\; (-1.0,-1.0,1.0),\\; (1.0,-1.0,1.0),\\; (-1.0,1.0,1.0),\\; (1.0,1.0,1.0)\\,]$.\n- Targets:\n  - $\\mathbf{x}_1 = (\\,0.3,\\, 0.2,\\, 0.1\\,)$,\n  - $\\mathbf{x}_2 = (\\,-0.4,\\, 0.5,\\, -0.2\\,)$,\n  - $\\mathbf{x}_3 = (\\,0.7,\\, -0.6,\\, 0.4\\,)$.\n- Parameters: $\\theta = 0.5$, $\\varepsilon = 0.01$.\n\nTest case $2$ (compact cluster; far-field targets):\n- Sources: masses and positions\n  - $m = [\\,5.0,\\, 3.0,\\, 4.0,\\, 2.0\\,]$,\n  - $\\mathbf{r} = [\\,(0.02,\\,-0.01,\\,0.03),\\; (-0.03,\\,0.01,\\,-0.02),\\; (0.01,\\,0.02,\\,-0.01),\\; (-0.02,\\,-0.02,\\,0.02)\\,]$.\n- Targets:\n  - $\\mathbf{x}_1 = (\\,10.0,\\, -9.0,\\, 8.0\\,)$,\n  - $\\mathbf{x}_2 = (\\,15.0,\\, 15.0,\\, -20.0\\,)$.\n- Parameters: $\\theta = 0.7$, $\\varepsilon = 0.001$.\n\nTest case $3$ (near-field and cancellation-sensitive geometry):\n- Sources: masses and positions\n  - $m = [\\,1.0,\\, 1.0,\\, 0.3\\,]$,\n  - $\\mathbf{r} = [\\,(-0.2,\\, 0.0,\\, 0.0),\\; (0.2,\\, 0.0,\\, 0.0),\\; (0.05,\\, 0.04,\\, 0.0)\\,]$.\n- Targets:\n  - $\\mathbf{x}_1 = (\\,0.05,\\, 0.0,\\, 0.0\\,)$,\n  - $\\mathbf{x}_2 = (\\,0.0,\\, 0.05,\\, 0.0\\,)$.\n- Parameters: $\\theta = 0.3$, $\\varepsilon = 0.05$.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain $6$ floating-point numbers ordered as\n$$\n[\\;E^{(1)}_{\\mathrm{acc}},\\; E^{(1)}_{\\mathrm{tid}},\\; E^{(2)}_{\\mathrm{acc}},\\; E^{(2)}_{\\mathrm{tid}},\\; E^{(3)}_{\\mathrm{acc}},\\; E^{(3)}_{\\mathrm{tid}}\\;] \\, ,\n$$\nwhere $E^{(t)}_{\\mathrm{acc}}$ is the maximum relative error in acceleration for test case $t$ and $E^{(t)}_{\\mathrm{tid}}$ is the maximum relative error in the tidal tensor for test case $t$. Each number in the output must be rounded to exactly $6$ digits after the decimal point. For example, a valid output would look like\n$$\n[\\,0.001234,0.045678,0.000012,0.000345,0.056789,0.012345\\,] \\, .\n$$",
            "solution": "The problem is scientifically grounded, objective, and well-posed, contingent on a standard interpretation of the recursive partitioning scheme. I will proceed with the solution under the assumption that the partitioning of a set of sources within an axis-aligned cubic bounding box is achieved via a standard octree decomposition, where the box is subdivided into eight equal cubic octants. This is the canonical approach for tree algorithms in three dimensions and is strongly suggested by the problem's reference to a cubic bounding box and recursive partitioning.\n\nThe problem requires the computation of gravitational acceleration and the tidal tensor for a system of $N$ point masses, both exactly via direct summation and approximately using a tree-based algorithm.\n\nFirst, we establish the analytical expressions for the required physical quantities. The gravitational potential with Plummer softening is given as:\n$$\n\\Phi(\\mathbf{x}) = -\\sum_{k=1}^N \\frac{m_k}{\\sqrt{\\|\\mathbf{x}-\\mathbf{r}_k\\|^2 + \\varepsilon^2}}\n$$\nwhere $m_k$ is the mass of the $k$-th particle, $\\mathbf{r}_k$ is its position, $\\mathbf{x}$ is the evaluation point, and $\\varepsilon$ is the softening length. For brevity, let $\\Delta\\mathbf{r}_k = \\mathbf{x} - \\mathbf{r}_k$ and let $d_k = \\sqrt{\\|\\Delta\\mathbf{r}_k\\|^2 + \\varepsilon^2}$.\n\nThe gravitational acceleration $\\mathbf{a}(\\mathbf{x})$ is the negative gradient of the potential:\n$$\n\\mathbf{a}(\\mathbf{x}) = -\\nabla\\Phi(\\mathbf{x}) = -\\sum_{k=1}^N \\nabla\\left(-\\frac{m_k}{d_k}\\right) = \\sum_{k=1}^N m_k \\nabla(d_k^{-1})\n$$\nThe gradient of $d_k^{-1}$ is $\\nabla(d_k^{-1}) = -d_k^{-2} \\nabla d_k$. Since $\\nabla d_k = d_k^{-1} \\Delta\\mathbf{r}_k$, this simplifies to $\\nabla(d_k^{-1}) = -d_k^{-3} \\Delta\\mathbf{r}_k$.\nThus, the acceleration is:\n$$\n\\mathbf{a}(\\mathbf{x}) = -\\sum_{k=1}^N m_k \\frac{\\mathbf{x} - \\mathbf{r}_k}{\\left(\\|\\mathbf{x} - \\mathbf{r}_k\\|^2 + \\varepsilon^2\\right)^{3/2}}\n$$\n\nThe tidal tensor $T(\\mathbf{x})$ is the Jacobian of the acceleration, $T_{ij}(\\mathbf{x}) = \\partial a_i(\\mathbf{x}) / \\partial x_j$. This is equivalent to the negative Hessian of the potential, $T_{ij}(\\mathbf{x}) = -\\partial^2\\Phi(\\mathbf{x}) / \\partial x_i \\partial x_j$.\nWe compute the components $T_{ij}^{(k)}$ for a single particle $k$:\n$$\nT_{ij}^{(k)}(\\mathbf{x}) = -\\frac{\\partial}{\\partial x_j} \\left( -m_k \\frac{(\\Delta r_k)_i}{d_k^3} \\right) = m_k \\frac{\\partial}{\\partial x_j} \\left( (\\Delta r_k)_i d_k^{-3} \\right)\n$$\nUsing the product rule:\n$$\nT_{ij}^{(k)} = m_k \\left( \\frac{\\partial (\\Delta r_k)_i}{\\partial x_j} d_k^{-3} + (\\Delta r_k)_i \\frac{\\partial d_k^{-3}}{\\partial x_j} \\right) = m_k \\left( \\delta_{ij} d_k^{-3} - 3 (\\Delta r_k)_i d_k^{-5} (\\Delta r_k)_j \\right)\n$$\nwhere $\\delta_{ij}$ is the Kronecker delta. The total tidal tensor is $T(\\mathbf{x}) = \\sum_k T^{(k)}(\\mathbf{x})$. In matrix form, the contribution from particle $k$ is:\n$$\nT^{(k)}(\\mathbf{x}) = \\frac{m_k}{d_k^5} \\left( d_k^2 I - 3 (\\Delta\\mathbf{r}_k \\otimes \\Delta\\mathbf{r}_k) \\right)\n$$\nThis expression is incorrect; the sign is reversed from the derivation of the acceleration. Let's re-verify. $\\mathbf{a}=-\\nabla\\Phi$. $T=\\nabla\\mathbf{a} = -\\nabla\\nabla\\Phi$.\n$a_i = -\\partial_i\\Phi$. $T_{ij} = \\partial_j a_i = -\\partial_j\\partial_i\\Phi$.\n$-\\partial_j\\partial_i\\Phi = -\\partial_j (m_k d_k^{-3}(\\Delta r_k)_i) = -m_k [ \\delta_{ij}d_k^{-3} + (\\Delta r_k)_i (-3 d_k^{-5})(\\Delta r_k)_j ] = m_k[ 3 d_k^{-5} (\\Delta r_k)_i (\\Delta r_k)_j - d_k^{-3}\\delta_{ij}]$.\nIn matrix notation:\n$$\nT^{(k)}(\\mathbf{x}) = \\frac{m_k}{d_k^5} \\left( 3 (\\Delta\\mathbf{r}_k \\otimes \\Delta\\mathbf{r}_k) - d_k^2 I \\right)\n$$\nwhere $I$ is the $3 \\times 3$ identity matrix and $\\otimes$ denotes the outer product. This is the correct form.\n\nThe exact calculation involves summing these contributions for all $N$ particles for each target point $\\mathbf{x}$.\n\nThe approximate calculation is based on a tree-code method. An octree data structure is built to spatially organize the particles.\n1.  **Tree Construction**: An initial cubic bounding box enclosing all particles is defined. This forms the root node of the octree. Each particle is then inserted recursively. When a particle is inserted into a node that already contains a particle, the node becomes an internal node, its cell is subdivided into eight octants (children), and both the old and new particles are passed down to the appropriate children. This process continues until each leaf node contains exactly one particle. During this process, each internal node stores the total mass $M_S$ and center of mass $\\mathbf{c}_S$ of all particles contained within its subtree.\n\n2.  **Force  Tide Approximation**: For a given target point $\\mathbf{x}$, the tree is traversed starting from the root. At each node $S$, the monopole acceptance criterion (MAC) is evaluated:\n    $$\n    \\frac{L_S}{\\|\\mathbf{x} - \\mathbf{c}_S\\|} \\le \\theta\n    $$\n    Here, $L_S$ is the side length of the node's cubic cell and $\\theta$ is the opening parameter.\n    -   If the criterion is met, the gravitational contribution of the entire group of particles $S$ is approximated by a single-particle interaction using the node's total mass $M_S$ and center of mass $\\mathbf{c}_S$. The traversal does not proceed to its children.\n    -   If the criterion is not met, the node is \"opened,\" and the traversal continues recursively to each of its children.\n    -   If a leaf node is reached (which cannot be opened further), its contribution is calculated exactly using the single particle it contains.\n\nThis adaptive method ensures that distant groups of particles are approximated, while nearby particles are resolved individually, balancing accuracy and computational cost.\n\nThe error is quantified by the maximum relative error over all targets for a given test case. For acceleration, the metric is the relative L2-norm error. For the tidal tensor, it is the relative Frobenius norm error:\n$$\nE_{\\mathrm{acc}} = \\max_{\\mathbf{x}} \\frac{\\|\\mathbf{a}_{\\mathrm{approx}}(\\mathbf{x}) - \\mathbf{a}_{\\mathrm{exact}}(\\mathbf{x})\\|_2}{\\|\\mathbf{a}_{\\mathrm{exact}}(\\mathbf{x})\\|_2}\n$$\n$$\nE_{\\mathrm{tid}} = \\max_{\\mathbf{x}} \\frac{\\|T_{\\mathrm{approx}}(\\mathbf{x}) - T_{\\mathrm{exact}}(\\mathbf{x})\\|_F}{\\|T_{\\mathrm{exact}}(\\mathbf{x})\\|_F}\n$$\n\nThe provided code implements this entire procedure. It defines a `Node` class for the octree, functions for tree construction, and functions for calculating exact and approximate interactions. It iterates through each test case, builds the tree, evaluates forces and tides at each target point, computes the errors, and reports the final results in the specified format.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# No other library imports are permitted.\n\nclass Node:\n    \"\"\"A node in the octree.\"\"\"\n    def __init__(self, center, size):\n        self.center = center  # Geometric center of the node's cube\n        self.size = size      # Side length of the node's cube\n        \n        # Aggregate properties for monopole approximation\n        self.mass = 0.0\n        self.com = np.zeros(3)  # Center of mass\n        \n        # Children nodes (for internal nodes)\n        self.children = None\n        \n        # Particle index (for leaf nodes)\n        self.particle_index = -1\n\n    def is_leaf(self):\n        return self.children is None\n\ndef _get_octant(position, center):\n    \"\"\"Determine which of the 8 octants a position belongs to.\"\"\"\n    octant = 0\n    if position[0] >= center[0]: octant |= 1  # x-axis\n    if position[1] >= center[1]: octant |= 2  # y-axis\n    if position[2] >= center[2]: octant |= 4  # z-axis\n    return octant\n\ndef _insert_particle(node, particle_pos, particle_mass, particle_idx, positions, masses):\n    \"\"\"Recursively insert a particle into the octree.\"\"\"\n    # Update aggregate properties of the node\n    new_total_mass = node.mass + particle_mass\n    node.com = (node.com * node.mass + particle_pos * particle_mass) / new_total_mass\n    node.mass = new_total_mass\n\n    # If node is an internal node, pass particle down to the correct child\n    if not node.is_leaf():\n        octant = _get_octant(particle_pos, node.center)\n        _insert_particle(node.children[octant], particle_pos, particle_mass, particle_idx, positions, masses)\n        return\n\n    # If node is empty, it becomes a leaf with the new particle\n    if node.particle_index == -1:\n        node.particle_index = particle_idx\n        return\n\n    # If node is a leaf with an existing particle, it must become an internal node\n    # Create children\n    node.children = [Node(node.center + 0.5 * node.size * octant_vec, node.size * 0.5) for octant_vec in [\n        np.array([-1,-1,-1]), np.array([1,-1,-1]), np.array([-1,1,-1]), np.array([1,1,-1]),\n        np.array([-1,-1,1]), np.array([1,-1,1]), np.array([-1,1,1]), np.array([1,1,1])\n    ]]\n    \n    # Move the original particle to its new child node\n    old_particle_idx = node.particle_index\n    old_particle_pos = positions[old_particle_idx]\n    old_particle_mass = masses[old_particle_idx]\n    octant_old = _get_octant(old_particle_pos, node.center)\n    _insert_particle(node.children[octant_old], old_particle_pos, old_particle_mass, old_particle_idx, positions, masses)\n    \n    # Insert the new particle into its child node\n    octant_new = _get_octant(particle_pos, node.center)\n    _insert_particle(node.children[octant_new], particle_pos, particle_mass, particle_idx, positions, masses)\n\n    # The node is now an internal node, so clear its particle_index\n    node.particle_index = -1\n\ndef _calc_interaction(mass, pos, target_pos, epsilon):\n    \"\"\"Calculate acceleration and tidal tensor contribution from a single source.\"\"\"\n    delta_r = target_pos - pos\n    dist_sq = np.dot(delta_r, delta_r)\n    d_sq = dist_sq + epsilon**2\n    d = np.sqrt(d_sq)\n    \n    if d == 0:\n        return np.zeros(3), np.zeros((3,3))\n\n    d_inv3 = d**-3\n    accel = -mass * delta_r * d_inv3\n\n    d_inv5 = d_inv3 / d_sq\n    tidal = mass * d_inv5 * (3 * np.outer(delta_r, delta_r) - d_sq * np.eye(3))\n    \n    return accel, tidal\n\ndef compute_exact(positions, masses, target_pos, epsilon):\n    \"\"\"Compute exact acceleration and tidal tensor via direct summation.\"\"\"\n    total_accel = np.zeros(3)\n    total_tidal = np.zeros((3, 3))\n    for i in range(len(masses)):\n        accel, tidal = _calc_interaction(masses[i], positions[i], target_pos, epsilon)\n        total_accel += accel\n        total_tidal += tidal\n    return total_accel, total_tidal\n\ndef compute_approx(root, positions, masses, target_pos, epsilon, theta):\n    \"\"\"Compute approximate acceleration and tidal tensor using the octree.\"\"\"\n    total_accel = np.zeros(3)\n    total_tidal = np.zeros((3, 3))\n    \n    stack = [root]\n    \n    while stack:\n        node = stack.pop()\n        if node.mass == 0:\n            continue\n            \n        is_leaf = node.is_leaf()\n        if is_leaf:\n            # If leaf, always compute interaction directly with the particle\n            accel, tidal = _calc_interaction(node.mass, node.com, target_pos, epsilon)\n            total_accel += accel\n            total_tidal += tidal\n            continue\n        \n        # For internal nodes, apply the monopole acceptance criterion (MAC)\n        dist_to_com = np.linalg.norm(target_pos - node.com)\n        \n        if dist_to_com == 0: # Target is at center of mass, must open node\n            mac_ratio = np.inf\n        else:\n            mac_ratio = node.size / dist_to_com\n\n        if mac_ratio = theta:\n            # Node is far enough, approximate as a single point mass\n            accel, tidal = _calc_interaction(node.mass, node.com, target_pos, epsilon)\n            total_accel += accel\n            total_tidal += tidal\n        else:\n            # Node is too close, push children onto stack to resolve further\n            for child in node.children:\n                stack.append(child)\n                \n    return total_accel, total_tidal\n\ndef solve():\n    test_cases = [\n        # Test case 1\n        {\n            \"masses\": np.array([1.0, 2.0, 3.0, 4.0, 1.5, 0.5, 0.8, 2.5]),\n            \"positions\": np.array([\n                [-1.0, -1.0, -1.0], [1.0, -1.0, -1.0], [-1.0, 1.0, -1.0], [1.0, 1.0, -1.0],\n                [-1.0, -1.0, 1.0], [1.0, -1.0, 1.0], [-1.0, 1.0, 1.0], [1.0, 1.0, 1.0]\n            ]),\n            \"targets\": np.array([\n                [0.3, 0.2, 0.1], [-0.4, 0.5, -0.2], [0.7, -0.6, 0.4]\n            ]),\n            \"theta\": 0.5, \"epsilon\": 0.01\n        },\n        # Test case 2\n        {\n            \"masses\": np.array([5.0, 3.0, 4.0, 2.0]),\n            \"positions\": np.array([\n                [0.02, -0.01, 0.03], [-0.03, 0.01, -0.02],\n                [0.01, 0.02, -0.01], [-0.02, -0.02, 0.02]\n            ]),\n            \"targets\": np.array([\n                [10.0, -9.0, 8.0], [15.0, 15.0, -20.0]\n            ]),\n            \"theta\": 0.7, \"epsilon\": 0.001\n        },\n        # Test case 3\n        {\n            \"masses\": np.array([1.0, 1.0, 0.3]),\n            \"positions\": np.array([\n                [-0.2, 0.0, 0.0], [0.2, 0.0, 0.0], [0.05, 0.04, 0.0]\n            ]),\n            \"targets\": np.array([\n                [0.05, 0.0, 0.0], [0.0, 0.05, 0.0]\n            ]),\n            \"theta\": 0.3, \"epsilon\": 0.05\n        }\n    ]\n\n    final_results = []\n\n    for case in test_cases:\n        masses = case[\"masses\"]\n        positions = case[\"positions\"]\n        targets = case[\"targets\"]\n        theta = case[\"theta\"]\n        epsilon = case[\"epsilon\"]\n\n        # 1. Build the Octree\n        # Find root bounding box\n        min_coords = np.min(positions, axis=0)\n        max_coords = np.max(positions, axis=0)\n        box_center = (min_coords + max_coords) / 2.0\n        box_size = np.max(max_coords - min_coords)\n        \n        # Add a small buffer to handle particles on the boundary\n        box_size *= 1.0001 \n        \n        root = Node(box_center, box_size)\n        \n        for i in range(len(masses)):\n            _insert_particle(root, positions[i], masses[i], i, positions, masses)\n\n        # 2. Compute errors for each target\n        accel_errors = []\n        tidal_errors = []\n\n        for target_pos in targets:\n            # Exact calculation\n            a_exact, T_exact = compute_exact(positions, masses, target_pos, epsilon)\n            \n            # Approximate calculation\n            a_approx, T_approx = compute_approx(root, positions, masses, target_pos, epsilon, theta)\n\n            # Calculate norms\n            norm_a_exact = np.linalg.norm(a_exact)\n            norm_T_exact = np.linalg.norm(T_exact, 'fro')\n\n            # Avoid division by zero if exact field is zero (e.g., at a symmetry point)\n            if norm_a_exact > 0:\n                err_a = np.linalg.norm(a_approx - a_exact) / norm_a_exact\n                accel_errors.append(err_a)\n            else: # If exact is 0, error is 0 only if approx is also 0\n                accel_errors.append(np.linalg.norm(a_approx))\n                \n            if norm_T_exact > 0:\n                err_T = np.linalg.norm(T_approx - T_exact, 'fro') / norm_T_exact\n                tidal_errors.append(err_T)\n            else:\n                tidal_errors.append(np.linalg.norm(T_approx, 'fro'))\n\n        # 3. Find max error for this test case\n        max_err_a = max(accel_errors) if accel_errors else 0.0\n        max_err_T = max(tidal_errors) if tidal_errors else 0.0\n        \n        final_results.extend([max_err_a, max_err_T])\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join([f'{r:.6f}' for r in final_results])}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The power of an algorithm is often revealed by its adaptability to new contexts. This advanced practice challenges you to generalize the Barnes-Hut method from its standard Cartesian setting to a system of particles constrained to the surface of a sphere . You will need to rethink core concepts like cell size and separation distance in terms of angular quantities, developing a 'spherical quadtree' to handle this non-Euclidean geometry. This exercise demonstrates the fundamental principles that make tree algorithms versatile tools for problems in fields ranging from astrophysics to geophysics.",
            "id": "2447291",
            "problem": "Consider a finite set of point masses constrained to lie on the surface of the unit sphere in three-dimensional Euclidean space. Each point mass has a position represented by a Cartesian unit vector $\\mathbf{r}_j \\in \\mathbb{R}^3$ with $\\|\\mathbf{r}_j\\|_2 = 1$ and a scalar mass $m_j > 0$. The gravitational acceleration at a target position $\\mathbf{r}_i$ induced by all other masses is the Newtonian inverse-square sum\n$$\n\\mathbf{a}_{\\mathrm{direct}}(\\mathbf{r}_i) \\;=\\; \\sum_{j \\neq i} G\\,m_j\\,\\frac{\\mathbf{r}_j - \\mathbf{r}_i}{\\left(\\|\\mathbf{r}_j - \\mathbf{r}_i\\|_2^2 + \\varepsilon^2\\right)^{3/2}},\n$$\nwhere $G$ is the gravitational constant and $\\varepsilon$ is a small softening length. Throughout this problem, adopt nondimensional units with $G = 1$, unit sphere radius, and use a fixed softening length $\\varepsilon = 10^{-3}$.\n\nYour task is to compute an approximation to $\\mathbf{a}_{\\mathrm{direct}}(\\mathbf{r}_i)$ by aggregating contributions using a hierarchical partition of the sphere. Define a spherical quadtree as follows. Work in spherical coordinates $(\\lambda,\\phi)$ with longitude $\\lambda \\in [-\\pi,\\pi]$ and latitude $\\phi \\in [-\\pi/2,\\pi/2]$, where $\\mathbf{r}(\\lambda,\\phi) = (\\cos\\phi\\cos\\lambda,\\cos\\phi\\sin\\lambda,\\sin\\phi)$. The root cell covers the full domain $[\\lambda_{\\min},\\lambda_{\\max}] = [-\\pi,\\pi]$ and $[\\phi_{\\min},\\phi_{\\max}] = [-\\pi/2,\\pi/2]$. Any cell with bounds $[\\lambda_{\\min},\\lambda_{\\max}]\\times[\\phi_{\\min},\\phi_{\\max}]$ is subdivided into four children by splitting at the mid-longitude $\\lambda_{\\mathrm{mid}} = (\\lambda_{\\min}+\\lambda_{\\max})/2$ and the mid-latitude $\\phi_{\\mathrm{mid}} = (\\phi_{\\min}+\\phi_{\\max})/2$, yielding four subcells: $[\\lambda_{\\min},\\lambda_{\\mathrm{mid}}]\\times[\\phi_{\\min},\\phi_{\\mathrm{mid}}]$, $[\\lambda_{\\mathrm{mid}},\\lambda_{\\max}]\\times[\\phi_{\\min},\\phi_{\\mathrm{mid}}]$, $[\\lambda_{\\min},\\lambda_{\\mathrm{mid}}]\\times[\\phi_{\\mathrm{mid}},\\phi_{\\max}]$, $[\\lambda_{\\mathrm{mid}},\\lambda_{\\max}]\\times[\\phi_{\\mathrm{mid}},\\phi_{\\max}]$. Recursively subdivide until each leaf contains at most $C$ particles or until a maximum depth $D$ is reached. Use $C = 1$ and $D = 12$.\n\nFor each cell, define its total mass $M = \\sum_{j \\in \\mathrm{cell}} m_j$, its mass centroid vector $\\mathbf{R}_{\\mathrm{cm}} = \\sum_{j \\in \\mathrm{cell}} m_j\\,\\mathbf{r}_j$, and its centroid position $\\mathbf{r}_{\\mathrm{cm}} = \\mathbf{R}_{\\mathrm{cm}}/M$. Also define a geometric center direction $\\mathbf{c}$ as the unit vector at the midpoint angles $\\mathbf{c} = \\mathbf{r}(\\lambda_{\\mathrm{mid}},\\phi_{\\mathrm{mid}})$. Let the cell’s angular radius $\\alpha$ be the maximum spherical angular distance between $\\mathbf{c}$ and any of the four corner directions of the cell; explicitly, if $\\{\\mathbf{q}_k\\}_{k=1}^4$ are the unit vectors at the corners, then\n$$\n\\alpha \\;=\\; \\max_{k \\in \\{1,2,3,4\\}} \\arccos\\!\\left(\\mathrm{clip}\\!\\left(\\mathbf{c}\\cdot \\mathbf{q}_k,-1,1\\right)\\right).\n$$\nFor a target direction $\\mathbf{u} = \\mathbf{r}_i/\\|\\mathbf{r}_i\\|_2$ and a cell with geometric center $\\mathbf{c}$, define the separation angle $\\delta = \\arccos\\!\\left(\\mathrm{clip}\\!\\left(\\mathbf{u}\\cdot \\mathbf{c},-1,1\\right)\\right)$. A cell’s aggregate is admissible if and only if it does not contain the target index $i$ and satisfies the angular opening inequality\n$$\n\\frac{\\alpha}{\\delta} \\;\\le\\; \\theta,\n$$\nwhere $\\theta > 0$ is the opening parameter. If admissible, approximate the contribution of all particles in the cell by a single monopole located at $\\mathbf{r}_{\\mathrm{cm}}$ with mass $M$. Otherwise, if the cell is a leaf, sum the exact pairwise contributions for its particles; if not a leaf, recurse into its children. In all cases, exclude the self-interaction $j=i$.\n\nFor each test case below, compute the approximate acceleration vector $\\mathbf{a}_{\\mathrm{tree}}(\\mathbf{r}_i)$ at the specified target index using the above rules, and also compute the direct sum $\\mathbf{a}_{\\mathrm{direct}}(\\mathbf{r}_i)$ using the full pairwise expression. Report the relative error as the Euclidean norm ratio\n$$\n\\mathrm{err} \\;=\\; \\frac{\\left\\|\\mathbf{a}_{\\mathrm{tree}}(\\mathbf{r}_i)-\\mathbf{a}_{\\mathrm{direct}}(\\mathbf{r}_i)\\right\\|_2}{\\left\\|\\mathbf{a}_{\\mathrm{direct}}(\\mathbf{r}_i)\\right\\|_2}.\n$$\nUse angles in radians. Use the same softening $\\varepsilon = 10^{-3}$ in both the approximate and direct computations. All masses are equal to $1$ unless otherwise specified. The sphere’s radius is $1$.\n\nTest suite. For each case, the particle set is given as Cartesian unit vectors, the target index $i_{\\mathrm{target}}$ is specified, and the opening parameter $\\theta$ is specified.\n\n- Case A (balanced configuration, “happy path”):\n  - Particles: $\\{(1,0,0),(-1,0,0),(0,1,0),(0,-1,0),(0,0,1),(0,0,-1)\\}$.\n  - Target: $i_{\\mathrm{target}} = 0$ (the particle at $(1,0,0)$).\n  - Opening: $\\theta = 0.6$.\n\n- Case B (ring on the equator, many near-equal separations):\n  - Particles: for $k \\in \\{0,1,2,3,4,5,6,7\\}$, $(\\cos(0)\\cos(k\\pi/4),\\cos(0)\\sin(k\\pi/4),\\sin(0))$; that is, $8$ points at longitudes $k\\pi/4$ and latitude $0$.\n  - Target: $i_{\\mathrm{target}} = 0$ (longitude $0$).\n  - Opening: $\\theta = 0.6$.\n\n- Case C (cluster near a pole plus distant masses, tests small angular radii and near-singular geometry):\n  - Particles: five near the north pole with latitudes $\\phi = \\pi/2 - \\delta$ where $\\delta \\in \\{10^{-2},2\\cdot10^{-2},3\\cdot10^{-2},4\\cdot10^{-2},5\\cdot10^{-2}\\}$ and longitudes $\\lambda = 2k\\pi/5$ for $k \\in \\{0,1,2,3,4\\}$, plus three on the equator at longitudes $0$, $2\\pi/3$, and $4\\pi/3$ (latitude $0$).\n  - Target: $i_{\\mathrm{target}} = 0$ (the particle with $\\delta = 10^{-2}$ and $\\lambda = 0$).\n  - Opening: $\\theta = 0.5$.\n\n- Case D (longitude seam edge case, tests partition boundaries):\n  - Particles: three points on the equator at longitudes $\\lambda = \\pi - 10^{-3}$, $\\lambda = -\\pi + 2\\cdot 10^{-3}$, and $\\lambda = 0$ (latitude $0$).\n  - Target: $i_{\\mathrm{target}} = 2$ (the particle at longitude $0$).\n  - Opening: $\\theta = 0.7$.\n\nFinal output format. Your program should produce a single line of output containing the four relative errors, for Cases A, B, C, and D in that order, as a comma-separated list enclosed in square brackets, for example, $[\\mathrm{err}_A,\\mathrm{err}_B,\\mathrm{err}_C,\\mathrm{err}_D]$. No other output should be produced. Angles must be interpreted in radians, and all computations must use the nondimensional choices and parameters stated above. The output values are floats. No user input is required or permitted.",
            "solution": "We model $N$ point masses on the unit sphere in three-dimensional Euclidean space. The direct gravitational acceleration at a target $\\mathbf{r}_i$ with softening $\\varepsilon$ and gravitational constant $G$ equal to $1$ is\n$$\n\\mathbf{a}_{\\mathrm{direct}}(\\mathbf{r}_i) \\;=\\; \\sum_{j \\neq i} m_j\\,\\frac{\\mathbf{r}_j - \\mathbf{r}_i}{\\left(\\|\\mathbf{r}_j - \\mathbf{r}_i\\|_2^2 + \\varepsilon^2\\right)^{3/2}}.\n$$\nThe hierarchical approximation replaces groups of sources by a single aggregate when the group is sufficiently far from the target compared to the group’s extent. On a plane, a standard opening criterion in the Barnes–Hut (BH) method compares a characteristic size $s$ of a cell to its Euclidean distance $d$ from the target, admitting an aggregate if $s/d \\le \\theta$. On a sphere, the natural geometry suggests using angular quantities. Let a cell cover a region on the sphere with geometric center direction $\\mathbf{c}$ and angular radius $\\alpha$, defined as the maximum great-circle distance from $\\mathbf{c}$ to any corner direction of the cell. For a target unit direction $\\mathbf{u}$, the separation is measured by the great-circle angle $\\delta = \\arccos(\\mathrm{clip}(\\mathbf{u}\\cdot\\mathbf{c},-1,1))$. The chord distance between points at angular separation $\\gamma$ on the unit sphere is $d_{\\mathrm{chord}} = 2\\sin(\\gamma/2)$, which is strictly increasing with $\\gamma$ on $\\gamma \\in [0,\\pi]$. Therefore, the ratio $s/d$ on the embedded unit sphere can be replaced by the ratio of angular scales $\\alpha/\\delta$, since for small angles $\\sin(\\alpha/2)\\approx \\alpha/2$ and $\\sin(\\delta/2)\\approx \\delta/2$, and for general angles the monotonicity preserves ordering. We thus accept a cell’s monopole approximation if and only if $\\alpha/\\delta \\le \\theta$.\n\nThe spherical quadtree partition is defined by recursively bisecting the longitude and latitude ranges of a cell into four children. Starting from the root covering $[\\lambda_{\\min},\\lambda_{\\max}] = [-\\pi,\\pi]$ and $[\\phi_{\\min},\\phi_{\\max}] = [-\\pi/2,\\pi/2]$, we split at $\\lambda_{\\mathrm{mid}} = (\\lambda_{\\min}+\\lambda_{\\max})/2$ and $\\phi_{\\mathrm{mid}} = (\\phi_{\\min}+\\phi_{\\max})/2$, forming four children. We continue until a leaf contains at most $C$ particles or a maximum depth $D$ is reached. Each cell stores:\n- Its total mass $M = \\sum_{j \\in \\mathrm{cell}} m_j$.\n- Its mass centroid vector $\\mathbf{R}_{\\mathrm{cm}} = \\sum_{j \\in \\mathrm{cell}} m_j\\,\\mathbf{r}_j$, and centroid position $\\mathbf{r}_{\\mathrm{cm}} = \\mathbf{R}_{\\mathrm{cm}}/M$.\n- Its geometric center direction $\\mathbf{c} = \\mathbf{r}(\\lambda_{\\mathrm{mid}},\\phi_{\\mathrm{mid}})$.\n- Its angular radius $\\alpha = \\max_k \\arccos(\\mathrm{clip}(\\mathbf{c}\\cdot \\mathbf{q}_k,-1,1))$, where $\\mathbf{q}_k$ are the unit vectors at the four corner coordinates.\n\nTo evaluate the approximate acceleration at target index $i$, we traverse the tree from the root:\n- If a cell contains the target index $i$, then it is never admissible regardless of the ratio $\\alpha/\\delta$; we must traverse into its children or, if it is a leaf, perform direct summation over its particles excluding $i$.\n- If the cell does not contain $i$ and the opening criterion $\\alpha/\\delta \\le \\theta$ holds, we approximate the contributions of all particles in the cell by a monopole at $\\mathbf{r}_{\\mathrm{cm}}$ with mass $M$, adding\n$$\n\\Delta \\mathbf{a} \\;=\\; M\\,\\frac{\\mathbf{r}_{\\mathrm{cm}} - \\mathbf{r}_i}{\\left(\\|\\mathbf{r}_{\\mathrm{cm}} - \\mathbf{r}_i\\|_2^2 + \\varepsilon^2\\right)^{3/2}}.\n$$\n- If not admissible and not a leaf, we recurse into the children and sum their contributions; if it is a leaf, we add the exact pairwise contributions from its particles, omitting $j=i$.\n\nThis rule ensures there is no self-interaction and that the aggregate approximation is only used when the cell’s angular size $\\alpha$ is small relative to its separation $\\delta$ from the target. The choice of using geometric center $\\mathbf{c}$ and corner-based $\\alpha$ provides a conservative angular bound on the cell’s footprint. The mass centroid location $\\mathbf{r}_{\\mathrm{cm}}$ provides the first-order (monopole) multipole approximation consistent with Newton’s law in the embedding space. Since the sphere’s radius is $1$ and $G=1$, no additional scaling is required.\n\nNumerical stability is maintained by the softening parameter $\\varepsilon = 10^{-3}$ applied identically to the approximate and direct computations. This avoids singularities when two positions are very close. The longitude and latitude ranges are bisected in a way that avoids wrap-around within any cell after the initial split at $\\lambda=0$, and corner directions are computed from the cell bounds. Membership of particles in each child is determined by testing their longitude and latitude values against the child’s bounds, using half-open interval conventions to avoid duplication, with the parent’s upper bounds included in the uppermost children to ensure coverage.\n\nFor each test case, we:\n- Construct the particle set as specified. For Case B, we take $8$ equatorial points at longitudes $k\\pi/4$ with $k \\in \\{0,\\ldots,7\\}$ and latitude $0$. For Case C, we include $5$ near-polar points at latitudes $\\pi/2 - \\delta$ with $\\delta \\in \\{10^{-2},2\\cdot10^{-2},3\\cdot10^{-2},4\\cdot10^{-2},5\\cdot10^{-2}\\}$ and longitudes $\\lambda = 2k\\pi/5$ for $k \\in \\{0,\\ldots,4\\}$, plus $3$ equatorial points at longitudes $0$, $2\\pi/3$, and $4\\pi/3$. For Cases A and D, the Cartesian positions are listed explicitly. All masses are $1$.\n- Build the spherical quadtree with $C=1$ and $D=12$.\n- Compute $\\mathbf{a}_{\\mathrm{tree}}(\\mathbf{r}_i)$ using the traversal and opening parameter $\\theta$ given per case.\n- Compute $\\mathbf{a}_{\\mathrm{direct}}(\\mathbf{r}_i)$ by direct summation with the same softening.\n- Report $\\mathrm{err} = \\|\\mathbf{a}_{\\mathrm{tree}}-\\mathbf{a}_{\\mathrm{direct}}\\|_2/\\|\\mathbf{a}_{\\mathrm{direct}}\\|_2$.\n\nThe method is grounded in first principles: the exact gravitational law, the embedding of the spherical manifold in $\\mathbb{R}^3$, and a conservative angular opening criterion derived from great-circle geometry. The acceptance test compares two dimensionless angles, ensuring invariance to the unit sphere’s radius. The test suite exercises symmetric (Case A), quasi-uniform angular spacing (Case B), small angular radii and cluster behavior (Case C), and longitude boundary handling (Case D). The program produces a single line with the four floating-point relative errors in the prescribed order and format.",
            "answer": "```python\nimport numpy as np\n\n# Constants in nondimensional units\nG = 1.0\nEPS = 1e-3  # softening\nCAPACITY = 1\nMAX_DEPTH = 12\n\ndef cart_from_latlon(lat, lon):\n    c = np.cos(lat)\n    return np.array([c*np.cos(lon), c*np.sin(lon), np.sin(lat)], dtype=float)\n\ndef latlon_from_cart(r):\n    x, y, z = r\n    lat = np.arcsin(np.clip(z, -1.0, 1.0))\n    lon = np.arctan2(y, x)\n    return lat, lon\n\ndef ang_between(u, v):\n    # u and v are unit vectors\n    dot = float(np.dot(u, v))\n    dot = max(-1.0, min(1.0, dot))\n    return np.arccos(dot)\n\nclass SphNode:\n    __slots__ = (\"lam_min\",\"lam_max\",\"phi_min\",\"phi_max\",\"indices\",\"mass\",\"com_vec\",\n                 \"center_dir\",\"alpha\",\"children\",\"is_leaf\",\"index_set\",\"depth\")\n    def __init__(self, lam_min, lam_max, phi_min, phi_max, indices, positions, masses, lats, lons, depth):\n        self.lam_min = lam_min\n        self.lam_max = lam_max\n        self.phi_min = phi_min\n        self.phi_max = phi_max\n        self.indices = indices\n        self.index_set = set(indices)\n        self.depth = depth\n        # mass and center of mass vector\n        if len(indices) > 0:\n            m = masses[indices]\n            r = positions[indices]\n            self.mass = float(np.sum(m))\n            self.com_vec = np.sum((m[:, None] * r), axis=0) if self.mass > 0 else np.zeros(3)\n        else:\n            self.mass = 0.0\n            self.com_vec = np.zeros(3)\n        # geometric center direction\n        lam_mid = 0.5*(lam_min + lam_max)\n        phi_mid = 0.5*(phi_min + phi_max)\n        self.center_dir = cart_from_latlon(phi_mid, lam_mid)\n        # angular radius via corners\n        corners = [\n            cart_from_latlon(phi_min, lam_min),\n            cart_from_latlon(phi_min, lam_max),\n            cart_from_latlon(phi_max, lam_min),\n            cart_from_latlon(phi_max, lam_max),\n        ]\n        self.alpha = max(ang_between(self.center_dir, q) for q in corners) if len(corners) > 0 else 0.0\n        self.children = []\n        self.is_leaf = True  # will change if subdivision happens\n\ndef build_tree(lam_min, lam_max, phi_min, phi_max, indices, positions, masses, lats, lons, depth=0):\n    node = SphNode(lam_min, lam_max, phi_min, phi_max, indices, positions, masses, lats, lons, depth)\n    if depth >= MAX_DEPTH or len(indices) = CAPACITY:\n        node.is_leaf = True\n        return node\n    # compute midpoints\n    lam_mid = 0.5*(lam_min + lam_max)\n    phi_mid = 0.5*(phi_min + phi_max)\n    # Partition indices into 4 children; use half-open intervals to avoid duplication,\n    # and include the parent's maxima in the upper intervals.\n    idxs = indices\n    lam = lons[idxs]\n    phi = lats[idxs]\n\n    # child bounds: (lam_lo, lam_hi, phi_lo, phi_hi, include_lam_max, include_phi_max)\n    child_bounds = [\n        (lam_min, lam_mid, phi_min, phi_mid, False, False),\n        (lam_mid, lam_max, phi_min, phi_mid, True,  False),\n        (lam_min, lam_mid, phi_mid, phi_max, False, True),\n        (lam_mid, lam_max, phi_mid, phi_max, True,  True),\n    ]\n\n    child_indices = []\n    for (l0, l1, p0, p1, inc_lmax, inc_pmax) in child_bounds:\n        # Determine membership\n        if inc_lmax:\n            lam_mask = (lam >= l0)  (lam = l1)\n        else:\n            lam_mask = (lam >= l0)  (lam   l1)\n        if inc_pmax:\n            phi_mask = (phi >= p0)  (phi = p1)\n        else:\n            phi_mask = (phi >= p0)  (phi   p1)\n        mask = lam_mask  phi_mask\n        child_indices.append(idxs[mask])\n\n    # If subdivision is ineffective (all points in one child), stop subdividing.\n    sizes = [len(ci) for ci in child_indices]\n    if max(sizes) == len(indices):\n        node.is_leaf = True\n        return node\n\n    # Create children\n    node.is_leaf = False\n    for k, ci in enumerate(child_indices):\n        if k == 0:\n            l0, l1, p0, p1, inc_lmax, inc_pmax = child_bounds[k]\n            child = build_tree(l0, l1, p0, p1, ci, positions, masses, lats, lons, depth+1)\n        elif k == 1:\n            l0, l1, p0, p1, inc_lmax, inc_pmax = child_bounds[k]\n            child = build_tree(l0, l1, p0, p1, ci, positions, masses, lats, lons, depth+1)\n        elif k == 2:\n            l0, l1, p0, p1, inc_lmax, inc_pmax = child_bounds[k]\n            child = build_tree(l0, l1, p0, p1, ci, positions, masses, lats, lons, depth+1)\n        else:\n            l0, l1, p0, p1, inc_lmax, inc_pmax = child_bounds[k]\n            child = build_tree(l0, l1, p0, p1, ci, positions, masses, lats, lons, depth+1)\n        node.children.append(child)\n    return node\n\ndef approx_accel_from_node(node, target_idx, r_target, u_target, positions, masses, theta):\n    if node.mass == 0.0 or len(node.indices) == 0:\n        return np.zeros(3, dtype=float)\n    # If node contains the target index, never approximate at this node\n    contains_target = (target_idx in node.index_set)\n    if not contains_target:\n        # Compute separation angle delta\n        delta = ang_between(u_target, node.center_dir)\n        # If admissible by angular opening criterion and not a leaf, or leaf (allowed)\n        if delta > 0.0 and (node.alpha / delta) = theta:\n            # monopole contribution from center-of-mass position\n            r_cm = node.com_vec / node.mass\n            dr = r_cm - r_target\n            dist2 = float(np.dot(dr, dr)) + EPS*EPS\n            inv32 = dist2 ** (-1.5)\n            return node.mass * dr * inv32\n        # If delta == 0, the target lies exactly at the geometric center; not admissible.\n    # If leaf: sum exact contributions (excluding self)\n    if node.is_leaf:\n        acc = np.zeros(3, dtype=float)\n        for j in node.indices:\n            if j == target_idx:\n                continue\n            dr = positions[j] - r_target\n            dist2 = float(np.dot(dr, dr)) + EPS*EPS\n            inv32 = dist2 ** (-1.5)\n            acc += masses[j] * dr * inv32\n        return acc\n    # Else recurse\n    acc = np.zeros(3, dtype=float)\n    for ch in node.children:\n        acc += approx_accel_from_node(ch, target_idx, r_target, u_target, positions, masses, theta)\n    return acc\n\ndef direct_accel(target_idx, positions, masses):\n    r_i = positions[target_idx]\n    acc = np.zeros(3, dtype=float)\n    for j in range(len(positions)):\n        if j == target_idx:\n            continue\n        dr = positions[j] - r_i\n        dist2 = float(np.dot(dr, dr)) + EPS*EPS\n        inv32 = dist2 ** (-1.5)\n        acc += masses[j] * dr * inv32\n    return acc\n\ndef build_lats_lons(positions):\n    lats = np.empty(len(positions), dtype=float)\n    lons = np.empty(len(positions), dtype=float)\n    for idx, r in enumerate(positions):\n        lat, lon = latlon_from_cart(r)\n        lats[idx] = lat\n        lons[idx] = lon\n    return lats, lons\n\ndef run_case(positions, masses, target_idx, theta):\n    positions = np.array(positions, dtype=float)\n    masses = np.array(masses, dtype=float)\n    # Normalize positions to unit length (defensive, though inputs are unit vectors)\n    norms = np.linalg.norm(positions, axis=1)\n    positions = positions / norms[:, None]\n    lats, lons = build_lats_lons(positions)\n    # Build spherical quadtree\n    root = build_tree(-np.pi, np.pi, -0.5*np.pi, 0.5*np.pi, np.arange(len(positions)), positions, masses, lats, lons, depth=0)\n    # Compute approximate and direct accelerations\n    r_t = positions[target_idx]\n    u_t = r_t / np.linalg.norm(r_t)\n    a_tree = approx_accel_from_node(root, target_idx, r_t, u_t, positions, masses, theta)\n    a_dir = direct_accel(target_idx, positions, masses)\n    num = np.linalg.norm(a_tree - a_dir)\n    den = np.linalg.norm(a_dir)\n    if den == 0.0:\n        # If direct acceleration happens to be numerically zero, define error as norm of approx\n        err = np.linalg.norm(a_tree)\n    else:\n        err = num / den\n    return float(err)\n\ndef case_A():\n    positions = [\n        np.array([1.0, 0.0, 0.0]),\n        np.array([-1.0, 0.0, 0.0]),\n        np.array([0.0, 1.0, 0.0]),\n        np.array([0.0, -1.0, 0.0]),\n        np.array([0.0, 0.0, 1.0]),\n        np.array([0.0, 0.0, -1.0]),\n    ]\n    masses = [1.0]*6\n    target_idx = 0\n    theta = 0.6\n    return run_case(positions, masses, target_idx, theta)\n\ndef case_B():\n    positions = []\n    masses = []\n    for k in range(8):\n        lon = k * (np.pi/4.0)\n        lat = 0.0\n        positions.append(cart_from_latlon(lat, lon))\n        masses.append(1.0)\n    target_idx = 0\n    theta = 0.6\n    return run_case(positions, masses, target_idx, theta)\n\ndef case_C():\n    positions = []\n    masses = []\n    # five near-polar points\n    deltas = [1e-2, 2e-2, 3e-2, 4e-2, 5e-2]\n    for k, delta in enumerate(deltas):\n        lat = 0.5*np.pi - delta\n        lon = 2.0 * k * np.pi / 5.0\n        positions.append(cart_from_latlon(lat, lon))\n        masses.append(1.0)\n    # three equatorial points at 0, 2pi/3, 4pi/3\n    for lon in [0.0, 2.0*np.pi/3.0, 4.0*np.pi/3.0]:\n        positions.append(cart_from_latlon(0.0, lon))\n        masses.append(1.0)\n    target_idx = 0  # the first near-polar point\n    theta = 0.5\n    return run_case(positions, masses, target_idx, theta)\n\ndef case_D():\n    positions = []\n    masses = []\n    # three equatorial points at longitudes pi-1e-3, -pi+2e-3, and 0\n    positions.append(cart_from_latlon(0.0, np.pi - 1e-3))\n    positions.append(cart_from_latlon(0.0, -np.pi + 2e-3))\n    positions.append(cart_from_latlon(0.0, 0.0))\n    masses = [1.0, 1.0, 1.0]\n    target_idx = 2  # the one at longitude 0\n    theta = 0.7\n    return run_case(positions, masses, target_idx, theta)\n\ndef solve():\n    results = []\n    results.append(case_A())\n    results.append(case_B())\n    results.append(case_C())\n    results.append(case_D())\n    # Print in required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}