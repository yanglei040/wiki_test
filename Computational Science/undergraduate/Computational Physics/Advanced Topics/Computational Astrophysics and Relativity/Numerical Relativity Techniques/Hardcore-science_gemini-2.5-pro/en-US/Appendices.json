{
    "hands_on_practices": [
        {
            "introduction": "To simulate dramatic astrophysical events like the merger of neutron stars, we must accurately model the behavior of matter moving at relativistic speeds. This practice introduces a core algorithm for this task: a Riemann solver for the equations of special relativistic hydrodynamics (SRHD). You will implement the Harten-Lax-van Leer (HLL) scheme, a powerful and widely used method for solving the hyperbolic conservation laws that govern relativistic fluids . Mastering this technique provides a foundational component for building more advanced finite-volume simulation codes and deepens your understanding of how matter is evolved in the extreme settings of numerical relativity.",
            "id": "2420558",
            "problem": "Construct a complete, runnable program that computes the intercell numerical flux for one-dimensional special relativistic hydrodynamics in flat spacetime for a set of prescribed left and right primitive states. Use natural units in which the speed of light is $c = 1$, so all quantities are dimensionless. The program must implement the conservation of baryon number and energy-momentum for an ideal fluid with a gamma-law equation of state, and return the conservative numerical flux at the interface located at $x = 0$ at an initial time with a discontinuity between a left state and a right state. The program must treat each test case independently and output the result for each as a list of three floating-point numbers representing the flux components in the order $[F_D, F_S, F_\\tau]$. The final output must be presented as a single line containing a list of these per-test-case lists.\n\nThe system is defined as follows. Let the primitive variables be rest-mass density $\\rho$, pressure $p$, and fluid velocity $v$ along the $x$-direction. The Lorentz factor is $W = 1/\\sqrt{1 - v^2}$. The specific internal energy is $\\epsilon$, and the ideal gamma-law equation of state relates pressure and internal energy by $p = (\\Gamma - 1)\\,\\rho\\,\\epsilon$, where $\\Gamma$ is the adiabatic index. The specific enthalpy is $h = 1 + \\epsilon + p/\\rho$, which, using the equation of state, can also be written as $h = 1 + \\Gamma\\,p/((\\Gamma - 1)\\,\\rho)$.\n\nDefine the conservative variables as\n- $D = \\rho\\,W$,\n- $S = \\rho\\,h\\,W^2\\,v$,\n- $\\tau = \\rho\\,h\\,W^2 - p - D$.\n\nThe corresponding physical fluxes in the $x$-direction are\n- $F_D = D\\,v$,\n- $F_S = S\\,v + p$,\n- $F_\\tau = S - D\\,v$.\n\nLet the relativistic sound speed be $c_s$, defined by $c_s^2 = \\Gamma\\,p / (\\rho\\,h)$, and assume $0 \\le c_s < 1$. The characteristic speeds in the laboratory frame for one-dimensional flow are\n- $\\lambda_+ = (v + c_s)/(1 + v\\,c_s)$,\n- $\\lambda_- = (v - c_s)/(1 - v\\,c_s)$,\n- $\\lambda_0 = v$.\n\nFor the two-signal approximation to the intercell numerical flux at the interface between a left state and a right state, define the left and right bounding signal speeds as\n- $S_L = \\min\\{\\lambda_-^{(L)}, \\lambda_-^{(R)}\\}$,\n- $S_R = \\max\\{\\lambda_+^{(L)}, \\lambda_+^{(R)}\\}$,\nwhere the superscripts $(L)$ and $(R)$ denote the quantities computed from the left and right primitive states, respectively. The intercell numerical flux $\\mathbf{F}^\\ast$ is then the upwind flux if all signals move in one direction, and otherwise given by the two-signal formula:\n- If $S_L \\ge 0$, then $\\mathbf{F}^\\ast = \\mathbf{F}(\\mathbf{U}_L)$.\n- Else if $S_R \\le 0$, then $\\mathbf{F}^\\ast = \\mathbf{F}(\\mathbf{U}_R)$.\n- Else,\n$$\n\\mathbf{F}^\\ast = \\frac{S_R\\,\\mathbf{F}(\\mathbf{U}_L) - S_L\\,\\mathbf{F}(\\mathbf{U}_R) + S_L\\,S_R\\,(\\mathbf{U}_R - \\mathbf{U}_L)}{S_R - S_L}.\n$$\nHere $\\mathbf{U} = [D, S, \\tau]$ and $\\mathbf{F}(\\mathbf{U}) = [F_D, F_S, F_\\tau]$.\n\nYour program must compute $\\mathbf{F}^\\ast$ for each of the following test cases. All quantities are dimensionless, consistent with $c = 1$. Angles do not appear, so no angle unit is required. The required outputs are floating-point numbers. The final output format must be a single line containing a list of sublists, one per test case, with each sublist equal to $[F_D, F_S, F_\\tau]$ computed from the definitions above.\n\nTest suite (each case specifies $(\\Gamma; \\rho_L, p_L, v_L; \\rho_R, p_R, v_R)$):\n- Case $1$: $(\\Gamma = 5/3;\\ \\rho_L = 1.0,\\ p_L = 1.0,\\ v_L = 0.0;\\ \\rho_R = 0.125,\\ p_R = 0.1,\\ v_R = 0.0)$.\n- Case $2$: $(\\Gamma = 5/3;\\ \\rho_L = 1.0,\\ p_L = 1000.0,\\ v_L = 0.0;\\ \\rho_R = 1.0,\\ p_R = 0.01,\\ v_R = 0.0)$.\n- Case $3$: $(\\Gamma = 5/3;\\ \\rho_L = 1.0,\\ p_L = 1.0,\\ v_L = 0.5;\\ \\rho_R = 1.0,\\ p_R = 1.0,\\ v_R = -0.5)$.\n- Case $4$: $(\\Gamma = 4/3;\\ \\rho_L = 1.0,\\ p_L = 1.0,\\ v_L = 0.2;\\ \\rho_R = 1.0,\\ p_R = 1.0,\\ v_R = 0.2)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each entry is a sublist of three floats $[F_D, F_S, F_\\tau]$ in the order of the test suite cases, for example: $[[f_{D,1}, f_{S,1}, f_{\\tau,1}],[f_{D,2}, f_{S,2}, f_{\\tau,2}],\\dots]$.",
            "solution": "The problem statement has been analyzed and is deemed valid. It presents a well-posed, scientifically grounded problem in computational physics, specifically in the domain of special relativistic hydrodynamics. The provided equations, definitions, and test cases are self-contained, consistent, and drawn from established theory. The task is to implement a standard numerical algorithm, the two-signal (or HLL) approximate Riemann solver, for a specified physical system.\n\nThe solution is constructed by implementing the following sequence of calculations for each test case, which consists of a left state $(\\rho_L, p_L, v_L)$ and a right state $(\\rho_R, p_R, v_R)$ at an interface, with a given adiabatic index $\\Gamma$.\n\nFirst, for any given state with primitive variables $(\\rho, p, v)$, we must compute a set of derived quantities.\nThe Lorentz factor $W$ is given by\n$$W = \\frac{1}{\\sqrt{1 - v^2}}$$\nThe specific enthalpy $h$ for a gamma-law gas is\n$$h = 1 + \\epsilon + \\frac{p}{\\rho} = 1 + \\frac{p}{(\\Gamma - 1)\\rho} + \\frac{p}{\\rho} = 1 + \\frac{\\Gamma p}{(\\Gamma - 1)\\rho}$$\nThe relativistic sound speed $c_s$ is determined from its square\n$$c_s^2 = \\frac{\\Gamma p}{\\rho h}$$\nThe characteristic wave speeds $\\lambda_{\\pm}$ for one-dimensional flow are given by the relativistic addition of velocities:\n$$\\lambda_+ = \\frac{v + c_s}{1 + v c_s}, \\quad \\lambda_- = \\frac{v - c_s}{1 - v c_s}$$\n\nSecond, using these quantities, we compute the vector of conservative variables $\\mathbf{U}$ and the corresponding flux vector $\\mathbf{F}$.\nThe conservative variables are defined as:\n- $D = \\rho W$ (conservative rest-mass density)\n- $S = \\rho h W^2 v$ (momentum density in the $x$-direction)\n- $\\tau = \\rho h W^2 - p - D$ (total energy density minus rest-mass density)\nSo, the state vector is $\\mathbf{U} = [D, S, \\tau]^T$.\n\nThe physical flux vector in the $x$-direction is:\n- $F_D = D v$\n- $F_S = S v + p$\n- $F_\\tau = S - D v$\nSo, the flux vector is $\\mathbf{F}(\\mathbf{U}) = [F_D, F_S, F_\\tau]^T$.\n\nThis procedure is applied to both the left state, denoted by superscript $(L)$, and the right state, superscript $(R)$, to obtain the state vectors $\\mathbf{U}_L, \\mathbf{U}_R$ and flux vectors $\\mathbf{F}_L, \\mathbf{F}_R$. We also compute the characteristic speeds for each state, $\\lambda_{\\pm}^{(L)}$ and $\\lambda_{\\pm}^{(R)}$.\n\nThird, the HLL-type numerical flux $\\mathbf{F}^\\ast$ across the interface is calculated. This requires the estimation of the minimum and maximum signal velocities, $S_L$ and $S_R$, that bound the Riemann fan. These are defined as:\n$$S_L = \\min\\left\\{\\lambda_-^{(L)}, \\lambda_-^{(R)}\\right\\}$$\n$$S_R = \\max\\left\\{\\lambda_+^{(L)}, \\lambda_+^{(R)}\\right\\}$$\n\nThe numerical flux $\\mathbf{F}^\\ast$ is then given by one of three cases:\n1. If all signals propagate to the right ($S_L \\ge 0$), the flux is determined by the left state (upwinding):\n$$ \\mathbf{F}^\\ast = \\mathbf{F}(\\mathbf{U}_L) $$\n2. If all signals propagate to the left ($S_R \\le 0$), the flux is determined by the right state:\n$$ \\mathbf{F}^\\ast = \\mathbf{F}(\\mathbf{U}_R) $$\n3. If signals propagate in both directions ($S_L < 0 < S_R$), the flux is a weighted average of states and fluxes:\n$$ \\mathbf{F}^\\ast = \\frac{S_R \\mathbf{F}(\\mathbf{U}_L) - S_L \\mathbf{F}(\\mathbf{U}_R) + S_L S_R (\\mathbf{U}_R - \\mathbf{U}_L)}{S_R - S_L} $$\n\nThe program must execute this complete algorithm for each test case provided in the problem statement and format the output as specified. The implementation will use vector operations for efficiency where applicable.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the intercell numerical flux for 1D special relativistic hydrodynamics.\n    \"\"\"\n    # Test cases: (gamma; rho_L, p_L, v_L; rho_R, p_R, v_R)\n    test_cases = [\n        (5.0/3.0, 1.0, 1.0, 0.0, 0.125, 0.1, 0.0),\n        (5.0/3.0, 1.0, 1000.0, 0.0, 1.0, 0.01, 0.0),\n        (5.0/3.0, 1.0, 1.0, 0.5, 1.0, 1.0, -0.5),\n        (4.0/3.0, 1.0, 1.0, 0.2, 1.0, 1.0, 0.2),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        gamma, rho_l, p_l, v_l, rho_r, p_r, v_r = case\n        \n        # This function encapsulates the conversion from primitive to conservative variables\n        # and calculation of characteristic speeds.\n        def get_state_quantities(rho, p, v, g):\n            if v*v >= 1.0:\n                raise ValueError(\"Velocity must be less than the speed of light (1).\")\n\n            # Lorentz factor\n            W_sq = 1.0 / (1.0 - v*v)\n            W = np.sqrt(W_sq)\n            \n            # Specific enthalpy\n            h = 1.0 + g * p / ((g - 1.0) * rho)\n            \n            # Conservative variables U = [D, S, tau]\n            D = rho * W\n            S = rho * h * W_sq * v\n            tau = rho * h * W_sq - p - D\n            U = np.array([D, S, tau])\n            \n            # Physical fluxes F = [F_D, F_S, F_tau]\n            F_D = D * v\n            F_S = S * v + p\n            F_tau = S - D * v\n            F = np.array([F_D, F_S, F_tau])\n            \n            # Sound speed squared and characteristic speeds\n            cs_sq = g * p / (rho * h)\n            if cs_sq >= 1.0:\n                # This check ensures physical sound speed.\n                # It should not be triggered by the problem's EOS definition for p, rho > 0.\n                raise ValueError(\"Sound speed squared must be less than 1.\")\n            cs = np.sqrt(cs_sq)\n            \n            lambda_p = (v + cs) / (1.0 + v * cs)\n            lambda_m = (v - cs) / (1.0 - v * cs)\n            \n            return U, F, lambda_p, lambda_m\n\n        # Calculate quantities for left and right states\n        U_l, F_l, lambda_p_l, lambda_m_l = get_state_quantities(rho_l, p_l, v_l, gamma)\n        U_r, F_r, lambda_p_r, lambda_m_r = get_state_quantities(rho_r, p_r, v_r, gamma)\n        \n        # Determine bounding signal speeds\n        S_L = min(lambda_m_l, lambda_m_r)\n        S_R = max(lambda_p_l, lambda_p_r)\n        \n        # Calculate numerical flux F_star\n        if S_L >= 0.0:\n            F_star = F_l\n        elif S_R = 0.0:\n            F_star = F_r\n        else:\n            # Check for S_R - S_L being zero to avoid division by zero\n            # This would only happen if S_R=S_L=0, a very specific case\n            # not expected in these problems, as it would imply cs=0 and v=0 for both states.\n            denom = S_R - S_L\n            if abs(denom)  1e-15: # Safety check for division by zero\n                 # If S_R = S_L, the upwind/downwind conditions should have caught it.\n                 # If S_R = S_L and S_L  0  S_R is false.\n                 # This branch should not be taken in a consistent setup.\n                 # A possible edge case is S_R = S_L = 0.\n                 # In SRHD, for waves to have zero speed, v=cs=0.\n                 # This would imply F_L=F_R=[0, p, 0].\n                 # We can simply take the average or one of them. For instance F_L.\n                 F_star = F_l\n            else:\n                 F_star = (S_R * F_l - S_L * F_r + S_L * S_R * (U_r - U_l)) / denom\n\n        results.append(F_star.tolist())\n\n    # Format the final output string as required\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While modeling relativistic matter is crucial, the heart of numerical relativity is the evolution of spacetime geometry itself by solving Einstein's equations. This practice brings you to the forefront of this challenge by simulating a Gowdy cosmology, a simplified \"toy universe\" that is nonetheless rich enough to exhibit complex, nonlinear gravitational dynamics. You will use the method of lines and finite differencing to evolve a system of coupled wave equations representing the fabric of spacetime . This exercise offers direct experience in evolving the metric fields and provides an opportunity to connect numerical results with theoretical predictions about the formation of \"spiky\" features near cosmological singularities.",
            "id": "2420532",
            "problem": "Consider the vacuum Gowdy cosmologies on a three-torus, which admit a metric reduction to two coupled scalar fields depending on a dimensionless time coordinate $\\tau$ and a single spatial coordinate $x \\in [0,2\\pi)$ with periodic boundary conditions. The reduced Einstein vacuum equations for the non-polarized case can be written as a coupled hyperbolic system for $P(\\tau,x)$ and $Q(\\tau,x)$,\n$$\nP_{\\tau\\tau} - e^{-2\\tau} P_{xx} \\;=\\; e^{2P} \\left(Q_{\\tau}^2 - e^{-2\\tau} Q_x^2\\right),\n$$\n$$\nQ_{\\tau\\tau} - e^{-2\\tau} Q_{xx} \\;+\\; 2\\left(P_{\\tau} Q_{\\tau} - e^{-2\\tau} P_x Q_x\\right) \\;=\\; 0,\n$$\nwith all spatial derivatives taken with respect to $x$ and periodicity in $x$. These equations are written in areal time gauge and provide a well-tested model to study approach-to-singularity behavior, including the development of narrow, high-curvature structures informally called spiky features. Angles must be treated in radians.\n\nYour task is to design and implement a numerical method that evolves this system and detects the emergence of spiky features in the solution as $\\tau$ increases. The method must be derived from fundamental base concepts as follows.\n\n1. Begin from the given partial differential equations and convert them into a first-order system in $\\tau$ by introducing auxiliary variables $A(\\tau,x) = P_{\\tau}(\\tau,x)$ and $B(\\tau,x) = Q_{\\tau}(\\tau,x)$. Derive explicit expressions for $P_{\\tau}$, $Q_{\\tau}$, $A_{\\tau}$, and $B_{\\tau}$ in terms of $P$, $Q$, $A$, $B$, and their spatial derivatives. Do not assume any additional constraints beyond periodicity in $x$.\n\n2. Discretize the spatial domain $[0,2\\pi)$ using a uniform grid of $N$ points with spacing $\\Delta x = 2\\pi/N$, and impose periodic boundary conditions. Use second-order centered finite differences to approximate the spatial derivatives $P_x$, $Q_x$, $P_{xx}$, and $Q_{xx}$ at grid points.\n\n3. Use the method of lines to reduce the problem to a system of ordinary differential equations in $\\tau$ for the grid functions. Integrate in $\\tau$ using an explicit Strong Stability Preserving Runge–Kutta method of order $3$ with stage times chosen appropriately for a nonautonomous right-hand side that depends on $\\tau$. Use a Courant–Friedrichs–Lewy (CFL) type time step restriction tied to the characteristic speed $c(\\tau) = e^{-\\tau}$ through $\\Delta \\tau \\le C \\,\\Delta x \\, e^{\\tau}$ with a user-specified constant $C \\in (0,1)$, and additionally cap the time step by a user-specified maximum to control accuracy. Ensure all angles are interpreted in radians.\n\n4. Initialize the fields at $\\tau_0 = 0$ with smooth, periodic data specified by five parameters: a cosine mode for $P$ with amplitude $p_{\\text{amp}}$ and wavenumber $k$, and a localized Gaussian for $Q$ with amplitude $q_{\\text{amp}}$, center $x_0$, and width $\\sigma$. Set the initial $\\tau$-derivatives to zero, $A(\\tau_0,x)=0$ and $B(\\tau_0,x)=0$. Explicitly:\n$$\nP(\\tau_0,x) \\;=\\; p_0 + p_{\\text{amp}} \\cos(k x), \\quad Q(\\tau_0,x) \\;=\\; q_{\\text{amp}} \\exp\\!\\left(-\\frac{d(x;x_0)^2}{2\\sigma^2}\\right),\n$$\nwhere $p_0$ is a constant offset and $d(x;x_0)$ is the $2\\pi$-periodic distance defined by $d(x;x_0)=\\mathrm{mod}(x-x_0+\\pi,\\, 2\\pi)-\\pi$ so that the Gaussian wraps periodically. Use $p_0=0$ unless otherwise specified.\n\n5. Define a quantitative spike indicator $\\mathcal{S}$ at a final time $\\tau_{\\text{end}}$ as follows. For any grid function $F$, define its discrete second derivative $\\Delta_2 F_i = (F_{i+1}-2F_i+F_{i-1})/\\Delta x^2$ using periodic indexing, and define\n$$\nS(F) \\;=\\; \\frac{\\max_i |\\Delta_2 F_i|}{\\frac{1}{N}\\sum_{i=0}^{N-1} |\\Delta_2 F_i| + \\varepsilon},\n$$\nwith $\\varepsilon = 10^{-12}$. Let $v(\\tau,x) = A(\\tau,x) = P_{\\tau}(\\tau,x)$ denote the asymptotic velocity field surrogate, and compute $S(P)$, $S(Q)$, and $S(v)$ at $\\tau_{\\text{end}}$. Declare that a spike has been detected if $\\max\\{S(P),S(Q),S(v)\\} \\ge \\Theta$, where $\\Theta$ is a user-specified threshold.\n\nImplement the above and apply it to the following test suite. Each test is a tuple of parameters $(N,\\ \\tau_{\\text{end}},\\ C,\\ \\Delta\\tau_{\\max},\\ k,\\ p_{\\text{amp}},\\ q_{\\text{amp}},\\ x_0,\\ \\sigma,\\ \\Theta)$:\n\n- Test A (baseline polarized, no spikes expected): $(N=\\;128,\\ \\tau_{\\text{end}}=\\;4.0,\\ C=\\;0.4,\\ \\Delta\\tau_{\\max}=\\;0.05,\\ k=\\;1,\\ p_{\\text{amp}}=\\;0.1,\\ q_{\\text{amp}}=\\;0.0,\\ x_0=\\;\\pi,\\ \\sigma=\\;0.2,\\ \\Theta=\\;6.0)$.\n\n- Test B (non-polarized, likely to develop spikes): $(N=\\;256,\\ \\tau_{\\text{end}}=\\;6.0,\\ C=\\;0.4,\\ \\Delta\\tau_{\\max}=\\;0.05,\\ k=\\;1,\\ p_{\\text{amp}}=\\;0.1,\\ q_{\\text{amp}}=\\;0.5,\\ x_0=\\;\\pi,\\ \\sigma=\\;0.2,\\ \\Theta=\\;6.0)$.\n\n- Test C (under-resolved variant, likely missed spikes): $(N=\\;64,\\ \\tau_{\\text{end}}=\\;6.0,\\ C=\\;0.4,\\ \\Delta\\tau_{\\max}=\\;0.05,\\ k=\\;1,\\ p_{\\text{amp}}=\\;0.1,\\ q_{\\text{amp}}=\\;0.5,\\ x_0=\\;\\pi,\\ \\sigma=\\;0.2,\\ \\Theta=\\;12.0)$.\n\n- Test D (weakly non-polarized, no spikes expected): $(N=\\;128,\\ \\tau_{\\text{end}}=\\;6.0,\\ C=\\;0.4,\\ \\Delta\\tau_{\\max}=\\;0.05,\\ k=\\;1,\\ p_{\\text{amp}}=\\;0.1,\\ q_{\\text{amp}}=\\;0.01,\\ x_0=\\;\\pi,\\ \\sigma=\\;0.2,\\ \\Theta=\\;6.0)$.\n\nYour program must implement the evolution and spike detection exactly as specified. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the order of tests $\\mathrm{A}$ through $\\mathrm{D}$, where each entry is a boolean indicating whether a spike was detected, for example, \"[True,False,True,False]\". No other output is permitted. Angles must be in radians; there are no physical units to report for this problem. All floating-point constants in the tests are in standard dimensionless form and must be used as given.",
            "solution": "The problem statement has been critically examined and is found to be valid. It is a well-posed initial-boundary value problem for a hyperbolic system of partial differential equations, derived from a known model in general relativity (Gowdy cosmologies). The problem is scientifically grounded, internally consistent, and provides all necessary information to construct a unique numerical solution. The objective is clearly and quantitatively defined. We may therefore proceed with the solution.\n\nThe task is to numerically evolve a system of two coupled nonlinear wave equations and detect the formation of sharp gradients, termed \"spiky features\". The method is constructed by following the prescribed steps.\n\n**1. Formulation as a First-Order System in Time**\n\nThe given system of second-order partial differential equations (PDEs) is:\n$$\nP_{\\tau\\tau} - e^{-2\\tau} P_{xx} \\;=\\; e^{2P} \\left(Q_{\\tau}^2 - e^{-2\\tau} Q_x^2\\right)\n$$\n$$\nQ_{\\tau\\tau} - e^{-2\\tau} Q_{xx} \\;+\\; 2\\left(P_{\\tau} Q_{\\tau} - e^{-2\\tau} P_x Q_x\\right) \\;=\\; 0\n$$\nTo convert this into a first-order system in the time coordinate $\\tau$, we introduce auxiliary fields $A(\\tau,x)$ and $B(\\tau,x)$ defined as the first time derivatives of $P$ and $Q$:\n$$\nA(\\tau,x) \\equiv P_{\\tau} = \\frac{\\partial P}{\\partial \\tau}\n$$\n$$\nB(\\tau,x) \\equiv Q_{\\tau} = \\frac{\\partial Q}{\\partial \\tau}\n$$\nThe time evolution of $A$ and $B$ is given by the second time derivatives, $A_{\\tau} = P_{\\tau\\tau}$ and $B_{\\tau} = Q_{\\tau\\tau}$. We rearrange the original PDEs to solve for these terms:\n$$\nA_{\\tau} = P_{\\tau\\tau} = e^{-2\\tau} P_{xx} + e^{2P} \\left(Q_{\\tau}^2 - e^{-2\\tau} Q_x^2\\right)\n$$\n$$\nB_{\\tau} = Q_{\\tau\\tau} = e^{-2\\tau} Q_{xx} - 2\\left(P_{\\tau} Q_{\\tau} - e^{-2\\tau} P_x Q_x\\right)\n$$\nSubstituting the definitions of $A$ and $B$ into these expressions, we arrive at a system of four first-order PDEs for the state vector $(P, Q, A, B)$:\n$$\n\\frac{\\partial P}{\\partial \\tau} = A\n$$\n$$\n\\frac{\\partial Q}{\\partial \\tau} = B\n$$\n$$\n\\frac{\\partial A}{\\partial \\tau} = e^{-2\\tau} P_{xx} + e^{2P} \\left(B^2 - e^{-2\\tau} Q_x^2\\right)\n$$\n$$\n\\frac{\\partial B}{\\partial \\tau} = e^{-2\\tau} Q_{xx} - 2\\left(AB - e^{-2\\tau} P_x Q_x\\right)\n$$\nThis system is now in the required form $\\frac{\\partial \\mathbf{U}}{\\partial \\tau} = \\mathbf{F}(\\tau, \\mathbf{U}, \\partial_x \\mathbf{U}, \\partial_{xx} \\mathbf{U})$, where $\\mathbf{U} = (P, Q, A, B)^T$.\n\n**2. Spatial Discretization**\n\nWe discretize the spatial domain $x \\in [0, 2\\pi)$ onto a uniform grid of $N$ points $x_i = i \\Delta x$ for $i = 0, 1, \\dots, N-1$, where the grid spacing is $\\Delta x = 2\\pi/N$. The fields are represented by their values on this grid, e.g., $P_i(\\tau) = P(\\tau, x_i)$. Spatial derivatives are approximated using second-order accurate centered finite differences. For any grid function $F_i$, the first and second derivatives at point $x_i$ are:\n$$\n(F_x)_i \\approx \\frac{F_{i+1} - F_{i-1}}{2 \\Delta x}\n$$\n$$\n(F_{xx})_i \\approx \\frac{F_{i+1} - 2F_i + F_{i-1}}{(\\Delta x)^2}\n$$\nPeriodic boundary conditions are imposed by ensuring that indices are evaluated modulo $N$. For example, at $i=0$, the index $i-1$ corresponds to grid point $N-1$, and at $i=N-1$, the index $i+1$ corresponds to grid point $0$.\n\n**3. Time Integration: Method of Lines and SSP-RK3**\n\nBy applying the spatial discretization to the first-order system, we obtain a large system of coupled ordinary differential equations (ODEs) for the grid values $\\{P_i(\\tau), Q_i(\\tau), A_i(\\tau), B_i(\\tau)\\}_{i=0}^{N-1}$. This technique is the method of lines. The system has the form $\\frac{d\\mathbf{Y}}{d\\tau} = \\mathbf{F}(\\tau, \\mathbf{Y})$, where $\\mathbf{Y}$ is a vector containing all grid values.\n\nWe integrate this ODE system using the explicit third-order Strong Stability Preserving Runge–Kutta (SSP-RK3) method. For a nonautonomous ODE $\\frac{dy}{dt} = f(t,y)$, the update from time $t_n$ to $t_{n+1} = t_n + \\Delta t$ is computed in three stages:\n$$\ny^{(1)} = y_n + \\Delta t \\, f(t_n, y_n)\n$$\n$$\ny^{(2)} = \\frac{3}{4} y_n + \\frac{1}{4} \\left( y^{(1)} + \\Delta t \\, f(t_n + \\Delta t, y^{(1)}) \\right)\n$$\n$$\ny_{n+1} = \\frac{1}{3} y_n + \\frac{2}{3} \\left( y^{(2)} + \\Delta t \\, f(t_n + \\frac{1}{2}\\Delta t, y^{(2)}) \\right)\n$$\nThis scheme is applied to the entire vector $\\mathbf{Y}$ of state variables. The time step $\\Delta \\tau$ is adaptive, governed by a Courant–Friedrichs–Lewy (CFL) condition. The characteristic speed of the system is $c(\\tau) = e^{-\\tau}$. The CFL condition requires the numerical domain of dependence to contain the physical one. This leads to a time step restriction $\\Delta \\tau \\le C \\frac{\\Delta x}{c(\\tau)} = C \\Delta x e^{\\tau}$ for some constant $C  1$. We also cap the time step by a maximum value $\\Delta\\tau_{\\max}$ to maintain accuracy. Thus, at each step, the time step is chosen as:\n$$\n\\Delta \\tau = \\min\\left( C \\Delta x e^{\\tau}, \\Delta\\tau_{\\max} \\right)\n$$\n\n**4. Initial Conditions**\n\nThe evolution starts at $\\tau_0 = 0$. The initial state of the fields on the grid is specified as follows:\n$$\nP_i(0) = p_{\\text{amp}} \\cos(k x_i)\n$$\n$$\nQ_i(0) = q_{\\text{amp}} \\exp\\!\\left(-\\frac{d(x_i;x_0)^2}{2\\sigma^2}\\right)\n$$\n$$\nA_i(0) = 0\n$$\n$$\nB_i(0) = 0\n$$\nThe constant offset $p_0$ is set to $0$. The function $d(x; x_0)$ computes the shortest distance between $x$ and $x_0$ on the periodic domain $[0, 2\\pi)$, given by $d(x;x_0) = \\mathrm{mod}(x-x_0+\\pi,\\, 2\\pi)-\\pi$. This ensures the Gaussian initial profile for $Q$ is centered at $x_0$ and respects the periodic boundary conditions. The parameters $p_{\\text{amp}}, k, q_{\\text{amp}}, x_0, \\sigma$ are provided for each test case.\n\n**5. Spike Detection**\n\nAt the final time $\\tau = \\tau_{\\text{end}}$, we analyze the spatial structure of the fields $P$, $Q$, and the velocity surrogate $v=A=P_{\\tau}$ to detect spikes. A spike is characterized by a high concentration of curvature. We quantify this using the indicator $\\mathcal{S}(F)$ for a generic grid function $F_i$. First, we compute the discrete second derivative (Laplacian) at each grid point:\n$$\n\\Delta_2 F_i = \\frac{F_{i+1} - 2F_i + F_{i-1}}{(\\Delta x)^2}\n$$\nThe indicator $\\mathcal{S}(F)$ is the ratio of the maximum absolute value of the Laplacian to its spatial average, with a small regularization parameter $\\varepsilon = 10^{-12}$ to prevent division by zero:\n$$\n\\mathcal{S}(F) = \\frac{\\max_i |\\Delta_2 F_i|}{\\frac{1}{N}\\sum_{i=0}^{N-1} |\\Delta_2 F_i| + \\varepsilon}\n$$\nA large value of $\\mathcal{S}(F)$ indicates that the second derivative is highly localized, which is the defining characteristic of a spike. A spike is formally detected if the maximum of the indicators for the fields of interest exceeds a given threshold $\\Theta$:\n$$\n\\max\\{\\mathcal{S}(P), \\mathcal{S}(Q), \\mathcal{S}(v)\\} \\ge \\Theta\n$$\nThe result of this test (True or False) is the output for each simulation.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for Gowdy cosmology simulations.\n    \"\"\"\n\n    test_cases = [\n        # (N, τ_end, C, Δτ_max, k, p_amp, q_amp, x_0, σ, Θ)\n        (128, 4.0, 0.4, 0.05, 1, 0.1, 0.0, np.pi, 0.2, 6.0),  # Test A\n        (256, 6.0, 0.4, 0.05, 1, 0.1, 0.5, np.pi, 0.2, 6.0),  # Test B\n        (64,  6.0, 0.4, 0.05, 1, 0.1, 0.5, np.pi, 0.2, 12.0), # Test C\n        (128, 6.0, 0.4, 0.05, 1, 0.1, 0.01, np.pi, 0.2, 6.0), # Test D\n    ]\n\n    results = []\n    for params in test_cases:\n        spike_detected = run_simulation(*params)\n        results.append(spike_detected)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef run_simulation(N, tau_end, C, dt_max, k, p_amp, q_amp, x0, sigma, Theta):\n    \"\"\"\n    Performs a single simulation of the Gowdy equations and detects spikes.\n    \"\"\"\n    \n    # 1. Spatial Grid Setup\n    dx = 2.0 * np.pi / N\n    x = np.linspace(0, 2.0 * np.pi, N, endpoint=False)\n\n    # 2. Initial Conditions\n    def periodic_distance(x, x0):\n        # Computes the shortest distance on a circle of circumference 2*pi\n        return (x - x0 + np.pi) % (2.0 * np.pi) - np.pi\n\n    P = p_amp * np.cos(k * x)\n    Q = q_amp * np.exp(-periodic_distance(x, x0)**2 / (2.0 * sigma**2))\n    A = np.zeros(N)  # A = P_tau\n    B = np.zeros(N)  # B = Q_tau\n\n    tau = 0.0\n\n    # 3. RHS of the first-order system\n    def rhs(tau, P, Q, A, B, dx):\n        # Calculate spatial derivatives using 2nd-order centered differences\n        # np.roll provides periodic boundary conditions\n        Px = (np.roll(P, -1) - np.roll(P, 1)) / (2.0 * dx)\n        Qx = (np.roll(Q, -1) - np.roll(Q, 1)) / (2.0 * dx)\n        Pxx = (np.roll(P, -1) - 2.0 * P + np.roll(P, 1)) / (dx**2)\n        Qxx = (np.roll(Q, -1) - 2.0 * Q + np.roll(Q, 1)) / (dx**2)\n\n        exp_m2tau = np.exp(-2.0 * tau)\n\n        # Equations of motion for the first-order system\n        dP_dtau = A\n        dQ_dtau = B\n        dA_dtau = exp_m2tau * Pxx + np.exp(2.0 * P) * (B**2 - exp_m2tau * Qx**2)\n        dB_dtau = exp_m2tau * Qxx - 2.0 * (A * B - exp_m2tau * Px * Qx)\n        \n        return dP_dtau, dQ_dtau, dA_dtau, dB_dtau\n\n    # 4. Time Evolution Loop (Method of Lines with SSP-RK3)\n    while tau  tau_end:\n        # Time step selection based on CFL condition and max step size\n        dt = min(C * dx * np.exp(tau), dt_max)\n        if tau + dt > tau_end:\n            dt = tau_end - tau\n\n        # --- SSP-RK3 Integrator ---\n        # Stage 1\n        k0P, k0Q, k0A, k0B = rhs(tau, P, Q, A, B, dx)\n        P1 = P + dt * k0P\n        Q1 = Q + dt * k0Q\n        A1 = A + dt * k0A\n        B1 = B + dt * k0B\n\n        # Stage 2\n        k1P, k1Q, k1A, k1B = rhs(tau + dt, P1, Q1, A1, B1, dx)\n        P2 = 0.75 * P + 0.25 * (P1 + dt * k1P)\n        Q2 = 0.75 * Q + 0.25 * (Q1 + dt * k1Q)\n        A2 = 0.75 * A + 0.25 * (A1 + dt * k1A)\n        B2 = 0.75 * B + 0.25 * (B1 + dt * k1B)\n        \n        # Stage 3\n        k2P, k2Q, k2A, k2B = rhs(tau + 0.5 * dt, P2, Q2, A2, B2, dx)\n        P = (1.0/3.0) * P + (2.0/3.0) * (P2 + dt * k2P)\n        Q = (1.0/3.0) * Q + (2.0/3.0) * (Q2 + dt * k2Q)\n        A = (1.0/3.0) * A + (2.0/3.0) * (A2 + dt * k2A)\n        B = (1.0/3.0) * B + (2.0/3.0) * (B2 + dt * k2B)\n\n        tau += dt\n\n    # 5. Spike Detection\n    def calculate_spike_indicator(F, dx):\n        eps = 1e-12\n        # Discrete second derivative (Laplacian)\n        lap_F = (np.roll(F, -1) - 2.0 * F + np.roll(F, 1)) / (dx**2)\n        abs_lap_F = np.abs(lap_F)\n        \n        max_lap = np.max(abs_lap_F)\n        avg_lap = np.mean(abs_lap_F)\n        \n        return max_lap / (avg_lap + eps)\n\n    S_P = calculate_spike_indicator(P, dx)\n    S_Q = calculate_spike_indicator(Q, dx)\n    v = A  # v is the velocity surrogate P_tau\n    S_v = calculate_spike_indicator(v, dx)\n    \n    spike_value = max(S_P, S_Q, S_v)\n    \n    return spike_value >= Theta\n\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "A successful numerical relativity simulation produces vast amounts of data describing the evolving spacetime geometry, but the ultimate goal is to extract concrete physical insights. This practice focuses on a key analysis task: measuring the properties of black holes formed in a simulation. You will implement a diagnostic to calculate the dimensionless spin parameter, $\\chi$, of a black hole by applying the isolated horizon formalism, a powerful quasi-local framework from general relativity . This hands-on exercise demonstrates how to translate an abstract theoretical concept—a surface integral over the black hole's horizon—into a practical numerical computation, bridging the gap between raw data and measurable physical observables.",
            "id": "2420583",
            "problem": "You must write a complete, self-contained program that implements a quasi-local black hole spin diagnostic using the isolated horizon formalism in geometrized units where $G=c=1$. Consider individual black holes whose apparent horizons are axisymmetric topological spheres with areal radius $R$, so that the spherical surface area is $A=4\\pi R^2$ and the area element is $\\mathrm{d}A = R^2 \\sin\\theta\\,\\mathrm{d}\\theta\\,\\mathrm{d}\\phi$, where the spherical angles are $\\theta\\in[0,\\pi]$ and $\\phi\\in[0,2\\pi)$ in radians. The spin angular momentum associated with an axisymmetry vector field is defined by the isolated horizon integral\n$$\nJ \\equiv \\frac{1}{8\\pi}\\int_{S} \\omega_a \\,\\phi^a\\,\\mathrm{d}A,\n$$\nwhere the contraction $\\omega_a \\phi^a$ is a given scalar function on the horizon. Define the irreducible mass by the area relation\n$$\nM_{\\mathrm{irr}} \\equiv \\sqrt{\\frac{A}{16\\pi}},\n$$\nand the Christodoulou mass by\n$$\nM^2 \\equiv M_{\\mathrm{irr}}^2 + \\frac{J^2}{4 M_{\\mathrm{irr}}^2}.\n$$\nThe dimensionless spin parameter is\n$$\n\\chi \\equiv \\frac{|J|}{M^2}.\n$$\nAll quantities are dimensionless in these units.\n\nYour program must, for each test case below, numerically evaluate the integral for $J$ using the specified $\\omega_a \\phi^a$ on the spherical surface, compute $M_{\\mathrm{irr}}$ and $M$, and output the corresponding $\\chi$. Angles $\\theta$ and $\\phi$ must be interpreted in radians. The final results must be rounded to six decimal places.\n\nTest suite. For each case, use the given areal radius $R$ and the specified scalar function $f(\\theta,\\phi)\\equiv \\omega_a \\phi^a$:\n- Case $1$: $R=1$, $f(\\theta,\\phi)=\\alpha$ with $\\alpha=1$.\n- Case $2$: $R=3$, $f(\\theta,\\phi)=0$.\n- Case $3$: $R=2$, $f(\\theta,\\phi)=\\alpha\\sin^2\\theta$ with $\\alpha=\\tfrac{3}{4}$.\n- Case $4$: $R=\\tfrac{3}{2}$, $f(\\theta,\\phi)=\\alpha\\sin^2\\theta\\cos(2\\phi)$ with $\\alpha=2$.\n\nRequired final output format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each entry being the value of $\\chi$ for the corresponding case in order, rounded to six decimal places. For example, an acceptable format is $[\\chi_1,\\chi_2,\\chi_3,\\chi_4]$ where each $\\chi_i$ is a float with six digits after the decimal point.",
            "solution": "The problem statement has been analyzed and is determined to be valid. It is scientifically grounded in the principles of general relativity, specifically the isolated horizon formalism used for quasi-local characterization of black holes. The definitions provided for spin angular momentum, irreducible mass, and Christodoulou mass are standard in this context. The problem is well-posed, with all necessary data and equations provided to arrive at a unique, meaningful solution for each test case. The language is objective and precise.\n\nThe core of the problem is to compute the dimensionless spin parameter $\\chi$ for a series of axisymmetric black hole apparent horizons. This requires a multi-step calculation starting from the given areal radius $R$ and a scalar function $f(\\theta,\\phi) \\equiv \\omega_a \\phi^a$ on the horizon surface.\n\nThe fundamental quantities are defined as follows:\nThe surface area of the spherical horizon is $A = 4\\pi R^2$.\nThe irreducible mass, $M_{\\mathrm{irr}}$, is defined in terms of the area:\n$$ M_{\\mathrm{irr}} \\equiv \\sqrt{\\frac{A}{16\\pi}} $$\nSubstituting the expression for $A$, we obtain a simpler relation:\n$$ M_{\\mathrm{irr}} = \\sqrt{\\frac{4\\pi R^2}{16\\pi}} = \\sqrt{\\frac{R^2}{4}} = \\frac{R}{2} $$\nThis simplification is useful. The irreducible mass represents the portion of the black hole's mass-energy that cannot be extracted via Penrose processes.\n\nThe spin angular momentum, $J$, is given by the surface integral:\n$$ J \\equiv \\frac{1}{8\\pi}\\int_{S} f(\\theta,\\phi)\\,\\mathrm{d}A $$\nwhere $f(\\theta,\\phi) = \\omega_a \\phi^a$. The area element in spherical coordinates is $\\mathrm{d}A = R^2 \\sin\\theta\\,\\mathrm{d}\\theta\\,\\mathrm{d}\\phi$. The integral becomes:\n$$ J = \\frac{1}{8\\pi} \\int_{0}^{2\\pi} \\int_{0}^{\\pi} f(\\theta, \\phi) R^2 \\sin\\theta \\, \\mathrm{d}\\theta \\, \\mathrm{d}\\phi = \\frac{R^2}{8\\pi} \\int_{0}^{2\\pi} \\mathrm{d}\\phi \\int_{0}^{\\pi} f(\\theta, \\phi) \\sin\\theta \\, \\mathrm{d}\\theta $$\nThis integral will be computed numerically as specified by the problem.\n\nThe Christodoulou mass, $M$, which represents the total mass-energy of the black hole as measured at infinity, is defined by the Christodoulou-Ruffini mass formula:\n$$ M^2 \\equiv M_{\\mathrm{irr}}^2 + \\frac{J^2}{4 M_{\\mathrm{irr}}^2} $$\nSubstituting our expression for $M_{\\mathrm{irr}}$:\n$$ M^2 = \\left(\\frac{R}{2}\\right)^2 + \\frac{J^2}{4 \\left(\\frac{R}{2}\\right)^2} = \\frac{R^2}{4} + \\frac{J^2}{R^2} $$\n\nFinally, the dimensionless spin parameter, $\\chi$, is calculated as:\n$$ \\chi \\equiv \\frac{|J|}{M^2} $$\nA value of $\\chi=0$ corresponds to a non-rotating (Schwarzschild-like) black hole, while $\\chi=1$ corresponds to a maximally rotating (extremal Kerr-like) black hole within this theoretical framework.\n\nThe computational procedure for each test case is as follows:\n1.  Define the integrand function for the numerical integration of $J$. Let this be $I(\\theta, \\phi) = f(\\theta, \\phi)\\sin\\theta$.\n2.  Numerically evaluate the double integral $\\mathcal{I} = \\int_{0}^{2\\pi} \\mathrm{d}\\phi \\int_{0}^{\\pi} I(\\theta, \\phi) \\, \\mathrm{d}\\theta$ using the `scipy.integrate.dblquad` function. The call will be structured as `dblquad(lambda theta, phi: I(theta, phi), 0, 2*pi, 0, pi)`.\n3.  Calculate $J = \\frac{R^2}{8\\pi} \\mathcal{I}$.\n4.  Calculate $M^2 = \\frac{R^2}{4} + \\frac{J^2}{R^2}$.\n5.  Calculate $\\chi = \\frac{|J|}{M^2}$. Note that if $R=0$, both $M^2$ and the denominator in the $J^2$ term would be zero, but all given test cases have $R > 0$. Similarly, if $M^2=0$, it implies $R=0$ and $J=0$, which is a trivial case not present here.\n6.  The final value of $\\chi$ is rounded to six decimal places for output.\n\nWe now apply this procedure to each test case.\n\n**Case 1:** $R=1$, $f(\\theta,\\phi)=1$.\n- $J_1 = \\frac{1^2}{8\\pi} \\int_0^{2\\pi} \\mathrm{d}\\phi \\int_0^{\\pi} (1) \\sin\\theta \\, \\mathrm{d}\\theta = \\frac{1}{8\\pi} \\cdot (2\\pi) \\cdot (2) = \\frac{4\\pi}{8\\pi} = \\frac{1}{2}$.\n- $M_1^2 = \\frac{1^2}{4} + \\frac{(1/2)^2}{1^2} = \\frac{1}{4} + \\frac{1}{4} = \\frac{1}{2}$.\n- $\\chi_1 = \\frac{|1/2|}{1/2} = 1$. Result: $1.000000$.\n\n**Case 2:** $R=3$, $f(\\theta,\\phi)=0$.\n- The integrand is zero, so the integral is zero. Thus, $J_2 = 0$.\n- This corresponds to a non-rotating black hole.\n- $M_2^2 = \\frac{3^2}{4} + \\frac{0^2}{3^2} = \\frac{9}{4}$.\n- $\\chi_2 = \\frac{0}{9/4} = 0$. Result: $0.000000$.\n\n**Case 3:** $R=2$, $f(\\theta,\\phi)=\\frac{3}{4}\\sin^2\\theta$.\n- $J_3 = \\frac{2^2}{8\\pi} \\int_0^{2\\pi} \\mathrm{d}\\phi \\int_0^{\\pi} \\frac{3}{4}\\sin^2\\theta \\sin\\theta \\, \\mathrm{d}\\theta = \\frac{4}{8\\pi} \\frac{3}{4} \\int_0^{2\\pi} \\mathrm{d}\\phi \\int_0^{\\pi} \\sin^3\\theta \\, \\mathrm{d}\\theta$.\n- The integral $\\int_0^{\\pi} \\sin^3\\theta\\,\\mathrm{d}\\theta = 4/3$. The integral $\\int_0^{2\\pi} \\mathrm{d}\\phi = 2\\pi$.\n- $J_3 = \\frac{3}{8\\pi} \\cdot (2\\pi) \\cdot (4/3) = 1$.\n- $M_3^2 = \\frac{2^2}{4} + \\frac{1^2}{2^2} = 1 + \\frac{1}{4} = \\frac{5}{4} = 1.25$.\n- $\\chi_3 = \\frac{|1|}{5/4} = \\frac{4}{5} = 0.8$. Result: $0.800000$.\n\n**Case 4:** $R=\\frac{3}{2}$, $f(\\theta,\\phi)=2\\sin^2\\theta\\cos(2\\phi)$.\n- $J_4 = \\frac{(3/2)^2}{8\\pi} \\int_0^{2\\pi} \\int_0^{\\pi} 2\\sin^2\\theta\\cos(2\\phi) \\sin\\theta \\, \\mathrm{d}\\theta \\, \\mathrm{d}\\phi$.\n- The integral is separable: $J_4 \\propto \\left(\\int_0^{\\pi} \\sin^3\\theta \\, \\mathrm{d}\\theta \\right) \\left(\\int_0^{2\\pi} \\cos(2\\phi) \\, \\mathrm{d}\\phi \\right)$.\n- The integral over $\\phi$ is $\\int_0^{2\\pi} \\cos(2\\phi) \\, \\mathrm{d}\\phi = \\left[\\frac{\\sin(2\\phi)}{2}\\right]_0^{2\\pi} = 0$.\n- Therefore, $J_4 = 0$.\n- $\\chi_4 = 0$. Result: $0.000000$.\n\nThe provided program implements this logic precisely using numerical integration.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import dblquad\n\ndef solve():\n    \"\"\"\n    Solves for the dimensionless spin parameter for a set of black hole test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (R, f_func) where R is the areal radius and\n    # f_func is the scalar function f(theta, phi) = omega_a * phi^a.\n    test_cases = [\n        (1.0, lambda theta, phi: 1.0),\n        (3.0, lambda theta, phi: 0.0),\n        (2.0, lambda theta, phi: (3.0/4.0) * np.sin(theta)**2),\n        (1.5, lambda theta, phi: 2.0 * np.sin(theta)**2 * np.cos(2*phi))\n    ]\n\n    results = []\n    for R, f_func in test_cases:\n        # Main logic to calculate the result for one case goes here.\n        chi = calculate_spin_parameter(R, f_func)\n        results.append(chi)\n\n    # Format the final results as strings with six decimal places.\n    results_str = [f\"{res:.6f}\" for res in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_str)}]\")\n\ndef calculate_spin_parameter(R, f_func):\n    \"\"\"\n    Calculates the dimensionless spin parameter chi for a given black hole horizon.\n\n    Args:\n        R (float): The areal radius of the apparent horizon.\n        f_func (callable): A function f(theta, phi) representing the scalar omega_a * phi^a.\n\n    Returns:\n        float: The dimensionless spin parameter chi.\n    \"\"\"\n    if R = 0:\n        # Physical radius must be positive.\n        return 0.0\n\n    # 1. Calculate Spin Angular Momentum J\n    # J = (1 / 8*pi) * integral_S(f * dA)\n    # dA = R^2 * sin(theta) * d(theta) * d(phi)\n    # J = (R^2 / 8*pi) * integral_{phi=0}^{2pi} integral_{theta=0}^{pi} f(theta, phi) * sin(theta) d(theta) d(phi)\n    \n    # Define the integrand for the numerical integration.\n    # dblquad integrates func(y, x), where y is the first argument.\n    # Here, y = theta, x = phi.\n    integrand = lambda theta, phi: f_func(theta, phi) * np.sin(theta)\n\n    # Perform the numerical double integration.\n    # Outer integral (phi) from 0 to 2*pi.\n    # Inner integral (theta) from 0 to pi.\n    integral_val, _ = dblquad(integrand, 0, 2*np.pi, 0, np.pi)\n    \n    J = (R**2 / (8 * np.pi)) * integral_val\n\n    # 2. Calculate Irreducible Mass M_irr\n    # M_irr = sqrt(A / 16*pi), where A = 4*pi*R^2\n    # This simplifies to M_irr = R / 2\n    M_irr = R / 2.0\n\n    # 3. Calculate Christodoulou Mass M\n    # M^2 = M_irr^2 + J^2 / (4 * M_irr^2)\n    try:\n        M_squared = M_irr**2 + J**2 / (4 * M_irr**2)\n    except ZeroDivisionError:\n        # This case happens if M_irr is zero, which means R is zero.\n        # For J=0, M^2=0, chi is undefined. For J!=0, M-squared is infinite.\n        # We handle R=0 at the start. So this should not be reached.\n        return np.nan\n\n    # 4. Calculate Dimensionless Spin Parameter chi\n    # chi = |J| / M^2\n    if M_squared == 0:\n        # M_squared is zero only if R=0 and J=0.\n        # A non-rotating point mass has chi=0.\n        return 0.0\n\n    chi = np.abs(J) / M_squared\n    \n    return chi\n\nsolve()\n```"
        }
    ]
}