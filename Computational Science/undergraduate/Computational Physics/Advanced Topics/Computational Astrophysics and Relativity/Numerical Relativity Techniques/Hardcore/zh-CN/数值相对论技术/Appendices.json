{
    "hands_on_practices": [
        {
            "introduction": "动手实践的第一步是构建一个简化的数值相对论模拟程序。这个练习将指导你创建一个二维“平面世界”中的引力模型，虽然它是一个简化的玩具模型，但它完美地捕捉了复杂代码的核心工作流程：在网格上表示物质，求解引力势的场方程，并利用该场来演化物质的运动。通过这个练习 ()，你将亲身体验粒子-网格（PM）方法和快速傅里叶变换（FFT）等核心计算技术，为理解更高级的模拟奠定坚实基础。",
            "id": "2420566",
            "problem": "要求您实现一个完全可运行的程序，该程序在一个周期性方形区域内对一个简化的弱场 $2+1$ 维引力玩具模型进行数值演化，捕捉由均匀网格上的平滑高斯源所代表的两个局部“点质量”之间的有效相互作用。目标是使用受数值相对论启发的技巧来模拟迎头相遇和掠过相遇，并根据计算出的轨迹，判断在指定的邻近阈值下这两个质量是否会碰撞。所有计算都必须在无量纲的几何化单位中执行，其中引力耦合和光速被归一化，最终输出中不需要进行物理单位转换。\n\n起点和建模假设：\n- 在弱场、慢运动极限下使用 Einstein 场方程，并采用空间度规的共形平坦拟设和一个小引力势。在此极限下，以及在引力辐射可忽略的 $2+1$ 维中，场方程简化为一个与面质量密度 $\\rho$ 耦合的标量势 $\\Phi$ 的泊松型约束。这产生如下形式的椭圆型约束\n$$\n\\nabla^2 \\Phi = \\kappa \\,\\rho,\n$$\n其中 $\\kappa$ 是一个您应视为固定的正无量纲耦合常数。假设一个边长为 $L$ 的周期性方形区域，并采用与周期性边界条件一致的谱方法在每个时间步求解此椭圆型约束。\n- 每个“点质量”由一个宽度为 $\\sigma$ 的归一化高斯函数表示，中心位于其瞬时位置 $\\boldsymbol{x}_p(t)$，因此积分质量等于预设的 $m_p$。用以下方程近似慢运动的测地线方程\n$$\n\\frac{d \\boldsymbol{v}}{dt} = -\\nabla \\Phi,\\qquad \\frac{d \\boldsymbol{x}}{dt} = \\boldsymbol{v},\n$$\n这与此机制下的线性化引力是一致的。使用二阶精度的辛（蛙跳）积分器来演化粒子的位置和速度。\n\n数值方法要求：\n- 将方形区域离散化为间距为 $\\Delta x = L/N$ 的均匀 $N\\times N$ 网格。\n- 在每一步，将 $\\rho(\\boldsymbol{x})$ 构建为两个总质量为 $m_1$ 和 $m_2$、宽度均为 $\\sigma$ 的高斯函数之和：\n$$\n\\rho(\\boldsymbol{x}) = \\sum_{p=1}^{2} \\frac{m_p}{2\\pi \\sigma^2}\\exp\\left(-\\frac{\\|\\boldsymbol{x}-\\boldsymbol{x}_p\\|_{\\text{per}}^2}{2\\sigma^2}\\right),\n$$\n其中 $\\|\\cdot\\|_{\\text{per}}$ 表示周期性边界下的最小镜像范数。\n- 使用快速傅里叶变换 (FFT) 在傅里叶空间中求解椭圆型约束：对于波矢量 $\\boldsymbol{k}=(k_x,k_y)$，\n$$\n-|\\boldsymbol{k}|^2 \\,\\widehat{\\Phi}(\\boldsymbol{k}) = \\kappa\\, \\widehat{\\rho}(\\boldsymbol{k})\\quad\\Rightarrow\\quad \\widehat{\\Phi}(\\boldsymbol{k}) = -\\kappa \\frac{\\widehat{\\rho}(\\boldsymbol{k})}{|\\boldsymbol{k}|^2},\n$$\n其中零模设置为满足 $\\widehat{\\Phi}(\\boldsymbol{0})=0$（势的定义允许相差一个常数）。使用以下方法获得加速度场：\n$$\n\\boldsymbol{a}(\\boldsymbol{x}) = -\\nabla \\Phi(\\boldsymbol{x}),\\quad \\text{通过谱方法实现为}\\quad \\widehat{\\partial_i \\Phi} = i\\,k_i\\,\\widehat{\\Phi}。\n$$\n- 使用与周期性环绕一致的双线性插值，将加速度 $\\boldsymbol{a}$ 从网格插值到粒子位置。\n\n时间积分：\n- 使用蛙跳格式 (kick-drift-kick)：\n  1. 根据当前粒子位置，通过上述场求解计算 $\\boldsymbol{a}^n = \\boldsymbol{a}(\\boldsymbol{x}^n)$。\n  2. 半步踢：$\\boldsymbol{v}^{n+\\tfrac{1}{2}} = \\boldsymbol{v}^n + \\tfrac{\\Delta t}{2}\\,\\boldsymbol{a}^n$。\n  3. 漂移：$\\boldsymbol{x}^{n+1} = \\boldsymbol{x}^n + \\Delta t\\,\\boldsymbol{v}^{n+\\tfrac{1}{2}}$（应用周期性环绕以保持在区域内）。\n  4. 在 $\\boldsymbol{x}^{n+1}$ 处重新计算场以获得 $\\boldsymbol{a}^{n+1}$ 并完成踢：$\\boldsymbol{v}^{n+1} = \\boldsymbol{v}^{n+\\tfrac{1}{2}} + \\tfrac{\\Delta t}{2}\\,\\boldsymbol{a}^{n+1}$。\n- 在整个演化过程中，使用周期性区域的最小镜像约定来追踪瞬时粒子间距：\n$$\nd(t) = \\left\\|\\left[\\boldsymbol{x}_1(t)-\\boldsymbol{x}_2(t)\\right]_{\\text{per}}\\right\\|_2.\n$$\n如果在模拟区间内 $\\min_t d(t)  2\\sigma$，则定义为发生“碰撞”。\n\n测试套件规范：\n使用以下三个测试案例，全部采用无量纲的几何化单位，具有相同的全局数值参数 $N$、$L$、$\\sigma$ 和 $\\kappa$，但粒子质量和初始条件不同。对于每个案例，演化固定的步数并判断是否发生碰撞，返回一个布尔值。\n\n所有案例的全局数值参数：\n- 网格大小：$N = 64$。\n- 区域大小：$L = 1.0$。\n- 高斯宽度：$\\sigma = 0.02$。\n- 耦合常数：$\\kappa = 0.1$。\n- 时间步长：$\\Delta t = 0.002$。\n- 步数：$n_{\\text{steps}} = 300$。\n\n案例 A（迎头相撞，等质量）：\n- 质量：$m_1 = 0.5$, $m_2 = 0.5$。\n- 初始位置：$\\boldsymbol{x}_1(0) = (0.3,\\,0.5)$, $\\boldsymbol{x}_2(0) = (0.7,\\,0.5)$。\n- 初始速度：$\\boldsymbol{v}_1(0) = (0.08,\\,0.0)$, $\\boldsymbol{v}_2(0) = (-0.08,\\,0.0)$。\n\n案例 B（掠过，等质量，较大撞击参数）：\n- 质量：$m_1 = 0.5$, $m_2 = 0.5$。\n- 初始位置：$\\boldsymbol{x}_1(0) = (0.3,\\,0.4)$, $\\boldsymbol{x}_2(0) = (0.7,\\,0.6)$。\n- 初始速度：$\\boldsymbol{v}_1(0) = (0.08,\\,0.0)$, $\\boldsymbol{v}_2(0) = (-0.08,\\,0.0)$。\n\n案例 C（迎头相撞，极小质量）：\n- 质量：$m_1 = 0.02$, $m_2 = 0.02$。\n- 初始位置：$\\boldsymbol{x}_1(0) = (0.3,\\,0.5)$, $\\boldsymbol{x}_2(0) = (0.7,\\,0.5)$。\n- 初始速度：$\\boldsymbol{v}_1(0) = (0.08,\\,0.0)$, $\\boldsymbol{v}_2(0) = (-0.08,\\,0.0)$。\n\n答案规范和输出格式：\n- 对于每个测试案例，计算由最小间距是否满足 $\\min_t d(t)  2\\sigma$ 定义的布尔碰撞指示符。\n- 您的程序应生成单行输出，其中包含按 A、B、C 顺序排列的三个案例的结果，形式为用方括号括起来的逗号分隔列表（例如，\"[True,False,False]\"）。由于这些是布尔值，它们是无单位的，必须打印为纯布尔值。",
            "solution": "问题陈述是有效的。它提出了一个定义明确的计算物理任务，该任务基于经典场论和数值分析的既定原则。该模型虽然经过简化，却是引力动力学研究中的一个标准玩具问题，通常被称为粒子-网格 (PM) 模拟。所有参数、初始条件、方程和数值方法都以足够的清晰度和精确度指定，从而可以得出一个唯一的、可验证的解。我们将着手构建算法。\n\n问题的核心是在自生引力场下模拟 N 体问题（此处 $N=2$ 个粒子）。力不是通过直接成对求和计算，而是通过场介导方法计算。模拟循环通过大小为 $\\Delta t$ 的离散时间步来推进系统状态——粒子 $p=1, 2$ 的位置 $\\boldsymbol{x}_p(t)$ 和速度 $\\boldsymbol{v}_p(t)$。每个时间步包括两个主要阶段：首先，根据粒子当前位置计算作用在粒子上的力；其次，使用这些力来更新它们的位置和速度。\n\n首先，我们处理加速度场 $\\boldsymbol{a} = -\\nabla \\Phi$ 的计算。这需要在边长为 $L$ 的周期性方形区域上求解二维泊松方程，\n$$\n\\nabla^2 \\Phi(\\boldsymbol{x}) = \\kappa \\,\\rho(\\boldsymbol{x}),\n$$\n源项 $\\rho(\\boldsymbol{x})$ 是由两个粒子产生的面质量密度。问题指定了使用一个包含 $N \\times N$ 个点的均匀网格的基于网格的方法。\n\n密度场是通过将每个粒子的质量分布到网格上来构建的。每个粒子是一个平滑的高斯分布，而非真正的点质量，以避免奇点。任意点 $\\boldsymbol{x}$ 处的密度由下式给出\n$$\n\\rho(\\boldsymbol{x}) = \\sum_{p=1}^{2} \\frac{m_p}{2\\pi \\sigma^2}\\exp\\left(-\\frac{\\|\\boldsymbol{x}-\\boldsymbol{x}_p\\|_{\\text{per}}^2}{2\\sigma^2}\\right).\n$$\n这里，$\\|\\boldsymbol{x}-\\boldsymbol{x}_p\\|_{\\text{per}}$ 是在最小镜像约定下的距离，它正确地处理了区域的周期性。为了实现这一点，对于每个网格点 $\\boldsymbol{x}_{ij}$，我们计算它到每个粒子 $\\boldsymbol{x}_p$ 的最短距离，并对高斯贡献求和。对于一个分离矢量 $\\Delta\\boldsymbol{x} = \\boldsymbol{x}_{ij}-\\boldsymbol{x}_p$，其周期性对应项是通过将其每个分量 $\\Delta x_k$ 映射到区间 $[-L/2, L/2]$ 来找到的。\n\n在网格上离散化密度场 $\\rho_{ij}$ 后，我们求解势 $\\Phi$。周期性边界条件的使用使得基于快速傅里叶变换 (FFT) 的谱方法异常高效。我们将泊松方程变换到傅里叶空间。拉普拉斯算子的傅里叶变换是 $\\mathcal{F}\\{\\nabla^2 f\\} = -|\\boldsymbol{k}|^2 \\widehat{f}(\\boldsymbol{k})$，其中 $\\boldsymbol{k}=(k_x, k_y)$ 是波矢量。对于大小为 $N$、区域长度为 $L$ 的网格，离散波矢量由 $k_i = 2\\pi n_i/L$ 给出，其中 $n_i$ 是从 $-N/2$ 到 $N/2-1$ 的整数。场方程在傅里叶空间中对每个模式 $\\boldsymbol{k}$ 变成一个代数方程：\n$$\n-|\\boldsymbol{k}|^2 \\,\\widehat{\\Phi}(\\boldsymbol{k}) = \\kappa\\, \\widehat{\\rho}(\\boldsymbol{k}).\n$$\n由此解出势的傅里叶系数：\n$$\n\\widehat{\\Phi}(\\boldsymbol{k}) = -\\kappa \\frac{\\widehat{\\rho}(\\boldsymbol{k})}{|\\boldsymbol{k}|^2}.\n$$\n对于零频模式 $\\boldsymbol{k}=\\boldsymbol{0}$，分母 $|\\boldsymbol{k}|^2$ 为零。这个奇点反映了势的定义仅允许相差一个任意常数。问题指定了物理选择 $\\widehat{\\Phi}(\\boldsymbol{0}) = 0$，这将势的空间平均值设为零。对于所有其他模式，该除法是明确定义的。\n\n一旦知道了 $\\widehat{\\Phi}(\\boldsymbol{k})$，我们就可以找到加速度场 $\\boldsymbol{a} = -\\nabla\\Phi$。在傅里叶空间中，梯度算符 $\\nabla$ 对应于乘以 $i\\boldsymbol{k}$。因此，加速度矢量的傅里叶变换是\n$$\n\\widehat{\\boldsymbol{a}}(\\boldsymbol{k}) = -i\\boldsymbol{k}\\,\\widehat{\\Phi}(\\boldsymbol{k}).\n$$\n对分量 $\\widehat{a}_x(\\boldsymbol{k})$ 和 $\\widehat{a}_y(\\boldsymbol{k})$ 应用二维逆 FFT，即可得到离散网格上的加速度场分量 $a_x(\\boldsymbol{x})$ 和 $a_y(\\boldsymbol{x})$。\n\n然而，粒子并不位于网格点上。为了找到粒子连续位置 $\\boldsymbol{x}_p$ 处的加速度，我们必须从网格中插值加速度场。按照规定，使用双线性插值。此方法使用包围 $\\boldsymbol{x}_p$ 的单元格的四个最近网格点上的值的加权平均来近似 $\\boldsymbol{x}_p$ 处的值。这种插值还必须尊重周期性边界条件，这可以通过使用诸如 `scipy.ndimage.map_coordinates` 的周期性环绕模式等库函数来稳健地处理。\n\n有了一种在任意时间步 $n$ 计算加速度 $\\boldsymbol{a}(\\boldsymbol{x}^n)$ 的方法后，我们使用指定的二阶蛙跳积分器（kick-drift-kick 变体）来演化粒子动力学。这种辛格式非常适合哈密顿系统，因为它表现出良好的长期守恒性质。更新过程如下：\n1. 计算初始加速度：$\\boldsymbol{a}^n = \\boldsymbol{a}(\\boldsymbol{x}^n)$。\n2. 速度半步踢：$\\boldsymbol{v}^{n+\\frac{1}{2}} = \\boldsymbol{v}^n + \\frac{\\Delta t}{2}\\,\\boldsymbol{a}^n$。\n3. 位置全步漂移：$\\boldsymbol{x}^{n+1} = \\boldsymbol{x}^n + \\Delta t\\,\\boldsymbol{v}^{n+\\frac{1}{2}}$。然后使用模运算符将位置环绕回区域 $[0, L) \\times [0, L)$ 中。\n4. 在新位置重新计算加速度：$\\boldsymbol{a}^{n+1} = \\boldsymbol{a}(\\boldsymbol{x}^{n+1})$。\n5. 速度第二次半步踢：$\\boldsymbol{v}^{n+1} = \\boldsymbol{v}^{n+\\frac{1}{2}} + \\frac{\\Delta t}{2}\\,\\boldsymbol{a}^{n+1}$。\n\n这就构成了一个完整的时间步。该过程重复 $n_{\\text{steps}}$ 次迭代。在整个模拟过程中，我们监测两个粒子之间的分离距离 $d(t) = \\|\\boldsymbol{x}_1(t)-\\boldsymbol{x}_2(t)\\|_{\\text{per}}$。如果在整个演化过程中观察到的最小距离 $\\min_t d(t)$ 低于 $2\\sigma$ 的阈值，则记录为发生“碰撞”。最终输出是针对每个测试案例的一个布尔值，指示此条件是否被满足。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.ndimage import map_coordinates\n\ndef solve():\n    \"\"\"\n    Main function to run the simulations for all test cases and print results.\n    \"\"\"\n\n    # Global numerical parameters for all cases\n    N = 64\n    L = 1.0\n    sigma = 0.02\n    kappa = 0.1\n    dt = 0.002\n    n_steps = 300\n    collision_threshold = 2.0 * sigma\n\n    test_cases = [\n        # Case A: Head-on, equal masses\n        {\n            'masses': np.array([0.5, 0.5]),\n            'positions': np.array([[0.3, 0.5], [0.7, 0.5]]),\n            'velocities': np.array([[0.08, 0.0], [-0.08, 0.0]])\n        },\n        # Case B: Grazing, equal masses\n        {\n            'masses': np.array([0.5, 0.5]),\n            'positions': np.array([[0.3, 0.4], [0.7, 0.6]]),\n            'velocities': np.array([[0.08, 0.0], [-0.08, 0.0]])\n        },\n        # Case C: Head-on, very small masses\n        {\n            'masses': np.array([0.02, 0.02]),\n            'positions': np.array([[0.3, 0.5], [0.7, 0.5]]),\n            'velocities': np.array([[0.08, 0.0], [-0.08, 0.0]])\n        }\n    ]\n\n    results = []\n    \n    # Memoize grid and wavenumber calculations as they are constant for all runs\n    grid_coords = np.linspace(0, L, N, endpoint=False)\n    xx, yy = np.meshgrid(grid_coords, grid_coords)\n    k_freq = np.fft.fftfreq(N, d=L / N) * 2 * np.pi\n    kx, ky = np.meshgrid(k_freq, k_freq)\n    ksq = kx**2 + ky**2\n    ksq[0, 0] = 1.0  # Placeholder to avoid division-by-zero warning\n\n    for case in test_cases:\n        collided = run_simulation(\n            case, N, L, sigma, kappa, dt, n_steps, collision_threshold,\n            xx, yy, kx, ky, ksq\n        )\n        results.append(collided)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_acceleration(positions, masses, N, L, sigma, kappa, xx, yy, kx, ky, ksq):\n    \"\"\"\n    Computes acceleration on particles using a particle-mesh FFT method.\n    \"\"\"\n    # 1. Deposit mass density onto the grid\n    rho = np.zeros((N, N), dtype=float)\n    for p_idx in range(len(masses)):\n        pos = positions[p_idx]\n        mass = masses[p_idx]\n        \n        # Calculate periodic distance from each grid point to the particle\n        dx = xx - pos[0]\n        dy = yy - pos[1]\n        dx -= L * np.round(dx / L)\n        dy -= L * np.round(dy / L)\n        dist_sq = dx**2 + dy**2\n        \n        normalization = mass / (2 * np.pi * sigma**2)\n        rho += normalization * np.exp(-dist_sq / (2 * sigma**2))\n\n    # 2. Solve for potential in Fourier space\n    rho_hat = np.fft.fft2(rho)\n    phi_hat = -kappa * rho_hat / ksq\n    phi_hat[0, 0] = 0.0  # Set zero mode of potential to zero\n\n    # 3. Compute acceleration field in Fourier space and transform back\n    ax_hat = -1j * kx * phi_hat\n    ay_hat = -1j * ky * phi_hat\n    ax_grid = np.real(np.fft.ifft2(ax_hat))\n    ay_grid = np.real(np.fft.ifft2(ay_hat))\n\n    # 4. Interpolate acceleration to particle positions using bilinear interpolation\n    # with periodic wrapping\n    # map_coordinates requires coordinates in index space (not world space)\n    # and in (row, col) which corresponds to (y, x) order.\n    particle_coords_idx = positions / (L / N)\n    coords = particle_coords_idx.T[::-1, :]\n    \n    ax_interp = map_coordinates(ax_grid, coords, order=1, mode='wrap')\n    ay_interp = map_coordinates(ay_grid, coords, order=1, mode='wrap')\n    \n    return np.vstack((ax_interp, ay_interp)).T\n\ndef get_periodic_distance(pos1, pos2, L_domain):\n    \"\"\"Calculates the minimum-image distance.\"\"\"\n    delta = pos1 - pos2\n    delta -= L_domain * np.round(delta / L_domain)\n    return np.linalg.norm(delta)\n\ndef run_simulation(case, N, L, sigma, kappa, dt, n_steps, threshold, xx, yy, kx, ky, ksq):\n    \"\"\"\n    Evolves the system for a single test case.\n    \"\"\"\n    positions = case['positions'].copy()\n    velocities = case['velocities'].copy()\n    masses = case['masses']\n    \n    min_dist = get_periodic_distance(positions[0], positions[1], L)\n\n    # Compute initial acceleration to start the leapfrog integrator\n    accel_n = compute_acceleration(positions, masses, N, L, sigma, kappa, xx, yy, kx, ky, ksq)\n\n    for _ in range(n_steps):\n        # 1. Half-kick for velocity\n        vel_half = velocities + (dt / 2.0) * accel_n\n        \n        # 2. Full drift for position\n        positions_n1 = positions + dt * vel_half\n        positions_n1 %= L  # Apply periodic boundary conditions\n\n        # 3. Recompute acceleration at new positions\n        accel_n1 = compute_acceleration(positions_n1, masses, N, L, sigma, kappa, xx, yy, kx, ky, ksq)\n        \n        # 4. Second half-kick for velocity\n        velocities_n1 = vel_half + (dt / 2.0) * accel_n1\n\n        # Update state for the next iteration\n        positions = positions_n1\n        velocities = velocities_n1\n        accel_n = accel_n1\n\n        # Track minimum distance\n        dist = get_periodic_distance(positions[0], positions[1], L)\n        if dist  min_dist:\n            min_dist = dist\n\n    return min_dist  threshold\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "在掌握了基本的模拟框架后，下一步是深入研究一个关键的物理模块：相对论流体动力学。许多天体物理现象，如中子星并合或吸积盘，都涉及以接近光速运动的流体。这个练习 () 聚焦于构建一个相对论黎曼求解器，这是一个基础的数值工具，用于精确捕捉这些流体中的激波和不连续性，是开发完整广义相对论流体动力学代码的关键一步。",
            "id": "2420558",
            "problem": "构建一个完整、可运行的程序，用于在一组给定的左右原始状态下，计算平直时空中一维狭义相对论流体动力学的单元间数值通量。使用自然单位制，其中光速 $c = 1$，因此所有量均为无量纲。程序必须实现理想流体在gamma-律状态方程下重子数和能量-动量的守恒，并返回在初始时刻 $x = 0$ 处界面上的守恒数值通量，该界面存在左右状态之间的间断。程序必须独立处理每个测试用例，并为每个用例输出一个包含三个浮点数的列表，分别代表通量分量 $[F_D, F_S, F_\\tau]$。最终输出必须呈现为单行，其中包含一个由这些按测试用例排列的列表组成的列表。\n\n系统定义如下。设原始变量为静止质量密度 $\\rho$、压强 $p$ 和沿x方向的流体速度 $v$。洛伦兹因子为 $W = 1/\\sqrt{1 - v^2}$。比内能为 $\\epsilon$，理想gamma-律状态方程通过 $p = (\\Gamma - 1)\\,\\rho\\,\\epsilon$ 关联压强和内能，其中 $\\Gamma$ 是绝热指数。比焓为 $h = 1 + \\epsilon + p/\\rho$，使用状态方程，也可写为 $h = 1 + \\Gamma\\,p/((\\Gamma - 1)\\,\\rho)$。\n\n定义守恒变量如下：\n- $D = \\rho\\,W$，\n- $S = \\rho\\,h\\,W^2\\,v$，\n- $\\tau = \\rho\\,h\\,W^2 - p - D$。\n\nx方向上对应的物理通量为：\n- $F_D = D\\,v$，\n- $F_S = S\\,v + p$，\n- $F_\\tau = S - D\\,v$。\n\n设相对论声速为 $c_s$，由 $c_s^2 = \\Gamma\\,p / (\\rho\\,h)$ 定义，并假设 $0 \\le c_s  1$。实验室参考系中一维流动的特征速度为：\n- $\\lambda_+ = (v + c_s)/(1 + v\\,c_s)$，\n- $\\lambda_- = (v - c_s)/(1 - v\\,c_s)$，\n- $\\lambda_0 = v$。\n\n对于左右状态之间界面的单元间数值通量的双信号近似，定义左右边界信号速度为：\n- $S_L = \\min\\{\\lambda_-^{(L)}, \\lambda_-^{(R)}\\}$，\n- $S_R = \\max\\{\\lambda_+^{(L)}, \\lambda_+^{(R)}\\}$，\n其中上标 $(L)$ 和 $(R)$ 分别表示从左、右原始状态计算出的量。单元间数值通量 $\\mathbf{F}^\\ast$ 在所有信号都向一个方向移动时为迎风通量，否则由双信号公式给出：\n- 如果 $S_L \\ge 0$，则 $\\mathbf{F}^\\ast = \\mathbf{F}(\\mathbf{U}_L)$。\n- 否则，如果 $S_R \\le 0$，则 $\\mathbf{F}^\\ast = \\mathbf{F}(\\mathbf{U}_R)$。\n- 否则，\n$$\n\\mathbf{F}^\\ast = \\frac{S_R\\,\\mathbf{F}(\\mathbf{U}_L) - S_L\\,\\mathbf{F}(\\mathbf{U}_R) + S_L\\,S_R\\,(\\mathbf{U}_R - \\mathbf{U}_L)}{S_R - S_L}.\n$$\n这里 $\\mathbf{U} = [D, S, \\tau]$ 且 $\\mathbf{F}(\\mathbf{U}) = [F_D, F_S, F_\\tau]$。\n\n您的程序必须为以下每个测试用例计算 $\\mathbf{F}^\\ast$。所有量均为无量纲，与 $c = 1$ 一致。没有出现角度，因此不需要角度单位。所需输出为浮点数。最终输出格式必须是单行，包含一个子列表的列表，每个子列表对应一个测试用例，且等于根据上述定义计算的 $[F_D, F_S, F_\\tau]$。\n\n测试套件（每个用例指定 $(\\Gamma; \\rho_L, p_L, v_L; \\rho_R, p_R, v_R)$）：\n- 用例 1：$(\\Gamma = 5/3;\\ \\rho_L = 1.0,\\ p_L = 1.0,\\ v_L = 0.0;\\ \\rho_R = 0.125,\\ p_R = 0.1,\\ v_R = 0.0)$。\n- 用例 2：$(\\Gamma = 5/3;\\ \\rho_L = 1.0,\\ p_L = 1000.0,\\ v_L = 0.0;\\ \\rho_R = 1.0,\\ p_R = 0.01,\\ v_R = 0.0)$。\n- 用例 3：$(\\Gamma = 5/3;\\ \\rho_L = 1.0,\\ p_L = 1.0,\\ v_L = 0.5;\\ \\rho_R = 1.0,\\ p_R = 1.0,\\ v_R = -0.5)$。\n- 用例 4：$(\\Gamma = 4/3;\\ \\rho_L = 1.0,\\ p_L = 1.0,\\ v_L = 0.2;\\ \\rho_R = 1.0,\\ p_R = 1.0,\\ v_R = 0.2)$。\n\n您的程序应生成单行输出，其中包含一个以逗号分隔的列表，列表被方括号包围，其中每个条目是按测试套件用例顺序排列的三个浮点数的子列表 $[F_D, F_S, F_\\tau]$，例如：$[[f_{D,1}, f_{S,1}, f_{\\tau,1}],[f_{D,2}, f_{S,2}, f_{\\tau,2}],\\dots]$。",
            "solution": "问题陈述已经过分析，并被认为是有效的。它提出了一个在计算物理领域中，特别是在狭义相对论流体动力学领域，定义明确且具有科学依据的问题。所提供的方程、定义和测试用例是自洽、一致的，并且源于已建立的理论。任务是为一个指定的物理系统实现一个标准的数值算法，即双信号（或HLL）近似黎曼求解器。\n\n解决方案是通过为每个测试用例实现以下计算序列来构建的，每个测试用例包含一个界面处的左状态 $(\\rho_L, p_L, v_L)$ 和右状态 $(\\rho_R, p_R, v_R)$，以及给定的绝热指数 $\\Gamma$。\n\n首先，对于任何给定的具有原始变量 $(\\rho, p, v)$ 的状态，我们必须计算一组导出量。\n洛伦兹因子 $W$ 由下式给出\n$$W = \\frac{1}{\\sqrt{1 - v^2}}$$\ngamma律气体的比焓 $h$ 为\n$$h = 1 + \\epsilon + \\frac{p}{\\rho} = 1 + \\frac{p}{(\\Gamma - 1)\\rho} + \\frac{p}{\\rho} = 1 + \\frac{\\Gamma p}{(\\Gamma - 1)\\rho}$$\n相对论声速 $c_s$ 由其平方确定\n$$c_s^2 = \\frac{\\Gamma p}{\\rho h}$$\n一维流动的特征波速 $\\lambda_{\\pm}$ 由速度的相对论合成给出：\n$$\\lambda_+ = \\frac{v + c_s}{1 + v c_s}, \\quad \\lambda_- = \\frac{v - c_s}{1 - v c_s}$$\n\n其次，使用这些量，我们计算守恒变量向量 $\\mathbf{U}$ 和相应的通量向量 $\\mathbf{F}$。\n守恒变量定义为：\n- $D = \\rho W$ (守恒静止质量密度)\n- $S = \\rho h W^2 v$ (x方向上的动量密度)\n- $\\tau = \\rho h W^2 - p - D$ (总能量密度减去静止质量密度)\n所以，状态向量为 $\\mathbf{U} = [D, S, \\tau]^T$。\n\nx方向上的物理通量向量为：\n- $F_D = D v$\n- $F_S = S v + p$\n- $F_\\tau = S - D v$\n所以，通量向量为 $\\mathbf{F}(\\mathbf{U}) = [F_D, F_S, F_\\tau]^T$。\n\n此过程应用于左状态（用上标 $(L)$ 表示）和右状态（用上标 $(R)$ 表示），以获得状态向量 $\\mathbf{U}_L, \\mathbf{U}_R$ 和通量向量 $\\mathbf{F}_L, \\mathbf{F}_R$。我们还为每个状态计算特征速度 $\\lambda_{\\pm}^{(L)}$ 和 $\\lambda_{\\pm}^{(R)}$。\n\n第三，计算跨界面的HLL型数值通量 $\\mathbf{F}^\\ast$。这需要估计界定黎曼扇的最小和最大信号速度 $S_L$ 和 $S_R$。它们定义为：\n$$S_L = \\min\\left\\{\\lambda_-^{(L)}, \\lambda_-^{(R)}\\right\\}$$\n$$S_R = \\max\\left\\{\\lambda_+^{(L)}, \\lambda_+^{(R)}\\right\\}$$\n\n数值通量 $\\mathbf{F}^\\ast$ 随后由以下三种情况之一给出：\n1. 如果所有信号都向右传播 ($S_L \\ge 0$)，通量由左状态决定（迎风格式）：\n$$ \\mathbf{F}^\\ast = \\mathbf{F}(\\mathbf{U}_L) $$\n2. 如果所有信号都向左传播 ($S_R \\le 0$)，通量由右状态决定：\n$$ \\mathbf{F}^\\ast = \\mathbf{F}(\\mathbf{U}_R) $$\n3. 如果信号向两个方向传播 ($S_L  0  S_R$)，通量是状态和通量的加权平均：\n$$ \\mathbf{F}^\\ast = \\frac{S_R \\mathbf{F}(\\mathbf{U}_L) - S_L \\mathbf{F}(\\mathbf{U}_R) + S_L S_R (\\mathbf{U}_R - \\mathbf{U}_L)}{S_R - S_L} $$\n\n程序必须为问题陈述中提供的每个测试用例执行这个完整的算法，并按指定格式化输出。在适用的情况下，实现将使用向量运算以提高效率。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the intercell numerical flux for 1D special relativistic hydrodynamics.\n    \"\"\"\n    # Test cases: (gamma; rho_L, p_L, v_L; rho_R, p_R, v_R)\n    test_cases = [\n        (5.0/3.0, 1.0, 1.0, 0.0, 0.125, 0.1, 0.0),\n        (5.0/3.0, 1.0, 1000.0, 0.0, 1.0, 0.01, 0.0),\n        (5.0/3.0, 1.0, 1.0, 0.5, 1.0, 1.0, -0.5),\n        (4.0/3.0, 1.0, 1.0, 0.2, 1.0, 1.0, 0.2),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        gamma, rho_l, p_l, v_l, rho_r, p_r, v_r = case\n        \n        # This function encapsulates the conversion from primitive to conservative variables\n        # and calculation of characteristic speeds.\n        def get_state_quantities(rho, p, v, g):\n            if v*v >= 1.0:\n                raise ValueError(\"Velocity must be less than the speed of light (1).\")\n\n            # Lorentz factor\n            W_sq = 1.0 / (1.0 - v*v)\n            W = np.sqrt(W_sq)\n            \n            # Specific enthalpy\n            h = 1.0 + g * p / ((g - 1.0) * rho)\n            \n            # Conservative variables U = [D, S, tau]\n            D = rho * W\n            S = rho * h * W_sq * v\n            tau = rho * h * W_sq - p - D\n            U = np.array([D, S, tau])\n            \n            # Physical fluxes F = [F_D, F_S, F_tau]\n            F_D = D * v\n            F_S = S * v + p\n            F_tau = S - D * v\n            F = np.array([F_D, F_S, F_tau])\n            \n            # Sound speed squared and characteristic speeds\n            cs_sq = g * p / (rho * h)\n            if cs_sq >= 1.0:\n                # This check ensures physical sound speed.\n                # It should not be triggered by the problem's EOS definition for p, rho > 0.\n                raise ValueError(\"Sound speed squared must be less than 1.\")\n            cs = np.sqrt(cs_sq)\n            \n            lambda_p = (v + cs) / (1.0 + v * cs)\n            lambda_m = (v - cs) / (1.0 - v * cs)\n            \n            return U, F, lambda_p, lambda_m\n\n        # Calculate quantities for left and right states\n        U_l, F_l, lambda_p_l, lambda_m_l = get_state_quantities(rho_l, p_l, v_l, gamma)\n        U_r, F_r, lambda_p_r, lambda_m_r = get_state_quantities(rho_r, p_r, v_r, gamma)\n        \n        # Determine bounding signal speeds\n        S_L = min(lambda_m_l, lambda_m_r)\n        S_R = max(lambda_p_l, lambda_p_r)\n        \n        # Calculate numerical flux F_star\n        if S_L >= 0.0:\n            F_star = F_l\n        elif S_R = 0.0:\n            F_star = F_r\n        else:\n            # Check for S_R - S_L being zero to avoid division by zero\n            # This would only happen if S_R=S_L=0, a very specific case\n            # not expected in these problems, as it would imply cs=0 and v=0 for both states.\n            denom = S_R - S_L\n            if abs(denom)  1e-15: # Safety check for division by zero\n                 # If S_R = S_L, the upwind/downwind conditions should have caught it.\n                 # If S_R = S_L and S_L  0  S_R is false.\n                 # This branch should not be taken in a consistent setup.\n                 # A possible edge case is S_R = S_L = 0.\n                 # In SRHD, for waves to have zero speed, v=cs=0.\n                 # This would imply F_L=F_R=[0, p, 0].\n                 # We can simply take the average or one of them. For instance F_L.\n                 F_star = F_l\n            else:\n                 F_star = (S_R * F_l - S_L * F_r + S_L * S_R * (U_r - U_l)) / denom\n\n        results.append(F_star.tolist())\n\n    # Format the final output string as required\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "运行模拟只是成功的一半，另一半是从海量数据中提取有意义的物理信息。本练习将向你介绍一种强大的后处理技术，它源于孤立视界形式主义，用于计算黑洞的自旋——这是一个关键的物理属性。这项实践 () 填补了模拟中演化的抽象几何量与天体物理对象（如黑洞）的具体可观测量之间的鸿沟，让你学会如何从模拟结果中“读取”宇宙的奥秘。",
            "id": "2420583",
            "problem": "你必须编写一个完整的、自包含的程序，使用孤立视界形式体系在 $G=c=1$ 的几何化单位中实现一个准局域黑洞自旋诊断。考虑单个黑洞，其视界面是轴对称的拓扑球面，面积半径为 $R$，因此球面面积为 $A=4\\pi R^2$，面积元为 $\\mathrm{d}A = R^2 \\sin\\theta\\,\\mathrm{d\\theta}\\,\\mathrm{d\\phi}$，其中球坐标角 $\\theta\\in[0,\\pi]$ 和 $\\phi\\in[0,2\\pi)$ 以弧度为单位。与轴对称矢量场相关的自旋角动量由孤立视界积分定义：\n$$\nJ \\equiv \\frac{1}{8\\pi}\\int_{S} \\omega_a \\,\\phi^a\\,\\mathrm{d}A,\n$$\n其中缩并 $\\omega_a \\phi^a$ 是视界上的一个给定标量函数。通过面积关系定义不可约化质量：\n$$\nM_{\\mathrm{irr}} \\equiv \\sqrt{\\frac{A}{16\\pi}},\n$$\n并通过以下公式定义 Christodoulou 质量：\n$$\nM^2 \\equiv M_{\\mathrm{irr}}^2 + \\frac{J^2}{4 M_{\\mathrm{irr}}^2}.\n$$\n无量纲自旋参数为：\n$$\n\\chi \\equiv \\frac{|J|}{M^2}.\n$$\n在这些单位中，所有量都是无量纲的。\n\n对于下面的每个测试用例，你的程序必须使用指定的 $\\omega_a \\phi^a$ 在球面上数值计算 $J$ 的积分，计算 $M_{\\mathrm{irr}}$ 和 $M$，并输出相应的 $\\chi$。角度 $\\theta$ 和 $\\phi$ 必须解释为弧度。最终结果必须四舍五入到六位小数。\n\n测试套件。对于每个用例，使用给定的面积半径 $R$ 和指定的标量函数 $f(\\theta,\\phi)\\equiv \\omega_a \\phi^a$：\n- 用例 1：$R=1$, $f(\\theta,\\phi)=\\alpha$，其中 $\\alpha=1$。\n- 用例 2：$R=3$, $f(\\theta,\\phi)=0$。\n- 用例 3：$R=2$, $f(\\theta,\\phi)=\\alpha\\sin^2\\theta$，其中 $\\alpha=\\tfrac{3}{4}$。\n- 用例 4：$R=\\tfrac{3}{2}$, $f(\\theta,\\phi)=\\alpha\\sin^2\\theta\\cos(2\\phi)$，其中 $\\alpha=2$。\n\n要求的最终输出格式。你的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，每个条目是对应案例的 $\\chi$ 值，按顺序排列，四舍五入到六位小数。例如，一个可接受的格式是 $[\\chi_1,\\chi_2,\\chi_3,\\chi_4]$，其中每个 $\\chi_i$ 是一个小数点后有六位数字的浮点数。",
            "solution": "问题陈述已经过分析并被确定为有效。它在科学上基于广义相对论的原理，特别是用于黑洞准局域表征的孤立视界形式体系。所提供的自旋角动量、不可约化质量和 Christodoulou 质量的定义在此背景下是标准的。问题陈述清晰，提供了所有必要的数据和方程，以便为每个测试用例得出唯一且有意义的解。语言客观而精确。\n\n问题的核心是为一系列轴对称黑洞的视界面计算无量纲自旋参数 $\\chi$。这需要从给定的面积半径 $R$ 和视界面上的标量函数 $f(\\theta,\\phi) \\equiv \\omega_a \\phi^a$ 开始进行多步计算。\n\n基本量的定义如下：\n球形视界的表面积为 $A = 4\\pi R^2$。\n不可约化质量 $M_{\\mathrm{irr}}$ 由面积定义：\n$$ M_{\\mathrm{irr}} \\equiv \\sqrt{\\frac{A}{16\\pi}} $$\n代入 $A$ 的表达式，我们得到一个更简单的关系：\n$$ M_{\\mathrm{irr}} = \\sqrt{\\frac{4\\pi R^2}{16\\pi}} = \\sqrt{\\frac{R^2}{4}} = \\frac{R}{2} $$\n这个简化很有用。不可约化质量代表了黑洞质能中无法通过 Penrose 过程提取的部分。\n\n自旋角动量 $J$ 由曲面积分给出：\n$$ J \\equiv \\frac{1}{8\\pi}\\int_{S} f(\\theta,\\phi)\\,\\mathrm{d}A $$\n其中 $f(\\theta,\\phi) = \\omega_a \\phi^a$。在球坐标系中，面积元为 $\\mathrm{d}A = R^2 \\sin\\theta\\,\\mathrm{d}\\theta\\,\\mathrm{d\\phi}$。积分变为：\n$$ J = \\frac{1}{8\\pi} \\int_{0}^{2\\pi} \\int_{0}^{\\pi} f(\\theta, \\phi) R^2 \\sin\\theta \\, \\mathrm{d}\\theta \\, \\mathrm{d}\\phi = \\frac{R^2}{8\\pi} \\int_{0}^{2\\pi} \\mathrm{d}\\phi \\int_{0}^{\\pi} f(\\theta, \\phi) \\sin\\theta \\, \\mathrm{d}\\theta $$\n根据问题的规定，这个积分将进行数值计算。\n\nChristodoulou 质量 $M$ 代表了在无穷远处测量的黑洞总质能，由 Christodoulou-Ruffini 质量公式定义：\n$$ M^2 \\equiv M_{\\mathrm{irr}}^2 + \\frac{J^2}{4 M_{\\mathrm{irr}}^2} $$\n代入我们关于 $M_{\\mathrm{irr}}$ 的表达式：\n$$ M^2 = \\left(\\frac{R}{2}\\right)^2 + \\frac{J^2}{4 \\left(\\frac{R}{2}\\right)^2} = \\frac{R^2}{4} + \\frac{J^2}{R^2} $$\n\n最后，无量纲自旋参数 $\\chi$ 计算如下：\n$$ \\chi \\equiv \\frac{|J|}{M^2} $$\n在此理论框架内，$\\chi=0$ 对应于一个不旋转的（类史瓦西）黑洞，而 $\\chi=1$ 对应于一个最大旋转的（极端类克尔）黑洞。\n\n每个测试用例的计算过程如下：\n1.  为 $J$ 的数值积分定义被积函数。设其为 $I(\\theta, \\phi) = f(\\theta, \\phi)\\sin\\theta$。\n2.  使用 `scipy.integrate.dblquad` 函数数值计算二重积分 $\\mathcal{I} = \\int_{0}^{2\\pi} \\mathrm{d}\\phi \\int_{0}^{\\pi} I(\\theta, \\phi) \\, \\mathrm{d}\\theta$。调用结构将是 `dblquad(lambda theta, phi: I(theta, phi), 0, 2*pi, 0, pi)`。\n3.  计算 $J = \\frac{R^2}{8\\pi} \\mathcal{I}$。\n4.  计算 $M^2 = \\frac{R^2}{4} + \\frac{J^2}{R^2}$。\n5.  计算 $\\chi = \\frac{|J|}{M^2}$。请注意，如果 $R=0$，则 $M^2$ 和 $J^2$ 项中的分母都将为零，但所有给定的测试用例都有 $R > 0$。类似地，如果 $M^2=0$，则意味着 $R=0$ 和 $J=0$，这是一个此处不存在的平凡情况。\n6.  最终的 $\\chi$ 值四舍五入到六位小数以供输出。\n\n我们现在将此过程应用于每个测试用例。\n\n**用例 1：** $R=1$, $f(\\theta,\\phi)=1$。\n- $J_1 = \\frac{1^2}{8\\pi} \\int_0^{2\\pi} \\mathrm{d}\\phi \\int_0^{\\pi} (1) \\sin\\theta \\, \\mathrm{d}\\theta = \\frac{1}{8\\pi} \\cdot (2\\pi) \\cdot (2) = \\frac{4\\pi}{8\\pi} = \\frac{1}{2}$。\n- $M_1^2 = \\frac{1^2}{4} + \\frac{(1/2)^2}{1^2} = \\frac{1}{4} + \\frac{1}{4} = \\frac{1}{2}$。\n- $\\chi_1 = \\frac{|1/2|}{1/2} = 1$。结果：$1.000000$。\n\n**用例 2：** $R=3$, $f(\\theta,\\phi)=0$。\n- 被积函数为零，因此积分为零。因此，$J_2 = 0$。\n- 这对应于一个不旋转的黑洞。\n- $M_2^2 = \\frac{3^2}{4} + \\frac{0^2}{3^2} = \\frac{9}{4}$。\n- $\\chi_2 = \\frac{0}{9/4} = 0$。结果：$0.000000$。\n\n**用例 3：** $R=2$, $f(\\theta,\\phi)=\\frac{3}{4}\\sin^2\\theta$。\n- $J_3 = \\frac{2^2}{8\\pi} \\int_0^{2\\pi} \\mathrm{d}\\phi \\int_0^{\\pi} \\frac{3}{4}\\sin^2\\theta \\sin\\theta \\, \\mathrm{d}\\theta = \\frac{4}{8\\pi} \\frac{3}{4} \\int_0^{2\\pi} \\mathrm{d}\\phi \\int_0^{\\pi} \\sin^3\\theta \\, \\mathrm{d}\\theta$。\n- 积分 $\\int_0^{\\pi} \\sin^3\\theta\\,\\mathrm{d}\\theta = 4/3$。积分 $\\int_0^{2\\pi} \\mathrm{d}\\phi = 2\\pi$。\n- $J_3 = \\frac{3}{8\\pi} \\cdot (2\\pi) \\cdot (4/3) = 1$。\n- $M_3^2 = \\frac{2^2}{4} + \\frac{1^2}{2^2} = 1 + \\frac{1}{4} = \\frac{5}{4} = 1.25$。\n- $\\chi_3 = \\frac{|1|}{5/4} = \\frac{4}{5} = 0.8$。结果：$0.800000$。\n\n**用例 4：** $R=\\frac{3}{2}$, $f(\\theta,\\phi)=2\\sin^2\\theta\\cos(2\\phi)$。\n- $J_4 = \\frac{(3/2)^2}{8\\pi} \\int_0^{2\\pi} \\int_0^{\\pi} 2\\sin^2\\theta\\cos(2\\phi) \\sin\\theta \\, \\mathrm{d}\\theta \\, \\mathrm{d}\\phi$。\n- 积分是可分离的：$J_4 \\propto \\left(\\int_0^{\\pi} \\sin^3\\theta \\, \\mathrm{d}\\theta \\right) \\left(\\int_0^{2\\pi} \\cos(2\\phi) \\, \\mathrm{d}\\phi \\right)$。\n- 对 $\\phi$ 的积分为 $\\int_0^{2\\pi} \\cos(2\\phi) \\, \\mathrm{d}\\phi = \\left[\\frac{\\sin(2\\phi)}{2}\\right]_0^{2\\pi} = 0$。\n- 因此，$J_4 = 0$。\n- $\\chi_4 = 0$。结果：$0.000000$。\n\n所提供的程序使用数值积分精确地实现了这一逻辑。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import dblquad\n\ndef solve():\n    \"\"\"\n    Solves for the dimensionless spin parameter for a set of black hole test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (R, f_func) where R is the areal radius and\n    # f_func is the scalar function f(theta, phi) = omega_a * phi^a.\n    test_cases = [\n        (1.0, lambda theta, phi: 1.0),\n        (3.0, lambda theta, phi: 0.0),\n        (2.0, lambda theta, phi: (3.0/4.0) * np.sin(theta)**2),\n        (1.5, lambda theta, phi: 2.0 * np.sin(theta)**2 * np.cos(2*phi))\n    ]\n\n    results = []\n    for R, f_func in test_cases:\n        # Main logic to calculate the result for one case goes here.\n        chi = calculate_spin_parameter(R, f_func)\n        results.append(chi)\n\n    # Format the final results as strings with six decimal places.\n    results_str = [f\"{res:.6f}\" for res in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_str)}]\")\n\ndef calculate_spin_parameter(R, f_func):\n    \"\"\"\n    Calculates the dimensionless spin parameter chi for a given black hole horizon.\n\n    Args:\n        R (float): The areal radius of the apparent horizon.\n        f_func (callable): A function f(theta, phi) representing the scalar omega_a * phi^a.\n\n    Returns:\n        float: The dimensionless spin parameter chi.\n    \"\"\"\n    if R = 0:\n        # Physical radius must be positive.\n        return 0.0\n\n    # 1. Calculate Spin Angular Momentum J\n    # J = (1 / 8*pi) * integral_S(f * dA)\n    # dA = R^2 * sin(theta) * d(theta) * d(phi)\n    # J = (R^2 / 8*pi) * integral_{phi=0}^{2pi} integral_{theta=0}^{pi} f(theta, phi) * sin(theta) d(theta) d(phi)\n    \n    # Define the integrand for the numerical integration.\n    # dblquad integrates func(y, x), where y is the first argument.\n    # Here, y = theta, x = phi.\n    integrand = lambda theta, phi: f_func(theta, phi) * np.sin(theta)\n\n    # Perform the numerical double integration.\n    # Outer integral (phi) from 0 to 2*pi.\n    # Inner integral (theta) from 0 to pi.\n    integral_val, _ = dblquad(integrand, 0, 2*np.pi, 0, np.pi)\n    \n    J = (R**2 / (8 * np.pi)) * integral_val\n\n    # 2. Calculate Irreducible Mass M_irr\n    # M_irr = sqrt(A / 16*pi), where A = 4*pi*R^2\n    # This simplifies to M_irr = R / 2\n    M_irr = R / 2.0\n\n    # 3. Calculate Christodoulou Mass M\n    # M^2 = M_irr^2 + J^2 / (4 * M_irr^2)\n    try:\n        M_squared = M_irr**2 + J**2 / (4 * M_irr**2)\n    except ZeroDivisionError:\n        # This case happens if M_irr is zero, which means R is zero.\n        # For J=0, M^2=0, chi is undefined. For J!=0, M-squared is infinite.\n        # We handle R=0 at the start. So this should not be reached.\n        return np.nan\n\n    # 4. Calculate Dimensionless Spin Parameter chi\n    # chi = |J| / M^2\n    if M_squared == 0:\n        # M_squared is zero only if R=0 and J=0.\n        # A non-rotating point mass has chi=0.\n        return 0.0\n\n    chi = np.abs(J) / M_squared\n    \n    return chi\n\nsolve()\n```"
        }
    ]
}