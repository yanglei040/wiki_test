{
    "hands_on_practices": [
        {
            "introduction": "理论学习之后，最好的检验方式就是亲自动手实践。第一个练习将引导你实现基础的 QR 算法，并用它来数值验证线性代数中的一个基本定理：矩阵的行列式等于其所有特征值的乘积。通过这个练习 ，你不仅能掌握 QR 迭代的核心实现，还能加深对特征值与行列式内在联系的理解。",
            "id": "2431464",
            "problem": "实现一个完整的程序，通过一个小型实数矩阵测试套件，数值上验证从方阵派生的两个独立计算的标量之间的等价性：直接从矩阵计算的行列式，以及通过迭代正交三角（QR）算法近似的特征值计算的乘积。您的实现必须遵守以下要求。\n\n任务的基本依据：\n- 对于实方阵 $ A \\in \\mathbb{R}^{n \\times n} $，使用通过特征方程 $ \\det(A - \\lambda I) = 0 $ 定义的特征值。\n- 使用行列式和相似变换的基本性质，包括如果 $ A = Q R $ 是满足 $ Q^\\mathsf{T} Q = I $ 的正交三角（QR）分解，则正交相似变换 $ A_{k+1} = R Q $ 在迭代正交三角算法中保持 $ A $ 的谱不变，同时增强其三角性。\n- 使用标准的数值线性代数事实：正交变换是保范的，并且通常是良态的；上三角矩阵的特征值等于其对角线元素。\n\n算法约束：\n- 实现正交三角（QR）算法，不得调用任何内置的特征值求解器。具体来说，对于一个实方阵 $ A $，迭代 $ A_{k+1} = R_k Q_k $，其中 $ A_k = Q_k R_k $ 是在第 $ k $ 次迭代时的QR分解。对于对称输入，使用基于严格非对角线元素范数的停止准则。对于在数值容差范围内精确为上三角的矩阵，直接从对角线读取特征值。\n- 对于对称输入，应用未平移的正交三角迭代，当严格非对角线元素的弗罗贝尼乌斯范数小于 $ \\varepsilon \\, \\|A\\|_F $ 时，宣告收敛，其中 $ \\varepsilon = 10^{-12} $。\n- 不要使用任何专门的平移策略；对于本测试套件中的小矩阵，未平移的迭代是可以接受的。\n\n误差度量和通过/失败准则：\n- 对于每个测试矩阵 $ A $，计算 $ P $（由您的正交三角算法返回的近似特征值的乘积），并使用稳定的直接例程计算 $ D = \\det(A) $。\n- 误差定义如下。如果 $ |D| \\ge 10^{-12} $，使用相对误差 $ e = |P - D| / |D| $。否则，使用绝对误差 $ e = |P - D| $。\n- 如果 $ e \\le 10^{-8} $，则测试通过。\n\n角度单位要求：\n- 用于构造测试矩阵的任何角度都必须以弧度为单位。\n\n测试套件：\n构造以下五个实数矩阵。设 $ \\cos(\\cdot) $ 和 $ \\sin(\\cdot) $ 表示输入为弧度的余弦和正弦。定义 $ 3 \\times 3 $ 旋转矩阵\n$$\nR_z(\\theta) =\n\\begin{bmatrix}\n\\cos\\theta  & -\\sin\\theta & 0 \\\\\n\\sin\\theta & \\cos\\theta & 0 \\\\\n0 & 0 & 1\n\\end{bmatrix}, \\quad\nR_y(\\phi) =\n\\begin{bmatrix}\n\\cos\\phi & 0 & \\sin\\phi \\\\\n0 & 1 & 0 \\\\\n-\\sin\\phi & 0 & \\cos\\phi\n\\end{bmatrix}, \\quad\nR_x(\\psi) =\n\\begin{bmatrix}\n1 & 0 & 0 \\\\\n0 & \\cos\\psi & -\\sin\\psi \\\\\n0 & \\sin\\psi & \\cos\\psi\n\\end{bmatrix}.\n$$\n使用以下五个案例：\n- 案例 1（对称正定，稠密）：设 $ \\theta = \\pi/6 $，$ \\phi = \\pi/5 $，$ Q_1 = R_z(\\theta) R_y(\\phi) $，以及 $ D_1 = \\mathrm{diag}(2.5, 1.2, 0.7) $。令 $ A_1 = Q_1 D_1 Q_1^\\mathsf{T} $。\n- 案例 2（对称不定，稠密）：设 $ \\psi = \\pi/7 $，$ \\varphi = \\pi/8 $，$ Q_2 = R_x(\\psi) R_z(\\varphi) $，以及 $ D_2 = \\mathrm{diag}(3.0, -1.0, 0.5) $。令 $ A_2 = Q_2 D_2 Q_2^\\mathsf{T} $。\n- 案例 3（上三角，非对称）：定义 $ 4 \\times 4 $ 矩阵\n$$\nA_3 =\n\\begin{bmatrix}\n1.0 & 0.3 & -0.2 & 0.1 \\\\\n0.0 & 2.0 & -0.1 & 0.25 \\\\\n0.0 & 0.0 & 3.0 & 0.05 \\\\\n0.0 & 0.0 & 0.0 & 4.0\n\\end{bmatrix}.\n$$\n- 案例 4（对角，近奇异）：设 $ A_4 = \\mathrm{diag}(10^{-8}, 1.0, 2.0) $。\n- 案例 5（标量边界）：设 $ A_5 = [5.0] $。\n\n程序输出格式：\n- 对于每个案例 $ i \\in \\{1,2,3,4,5\\} $，计算如上定义的通过/失败布尔值。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，例如 $ [\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5] $。\n\n附加约束：\n- 您的程序必须是自包含的，不得读取任何输入，也不得访问外部文件或网络。\n- 不得调用任何内置的特征值求解器；要求实现基于重复正交三角分解的方法。",
            "solution": "我们从基本定义和事实开始。对于一个实方阵 $ A \\in \\mathbb{R}^{n \\times n} $，如果存在一个非零向量 $ v \\in \\mathbb{C}^n $ 使得 $ A v = \\lambda v $，则标量 $ \\lambda \\in \\mathbb{C} $ 是一个特征值。等价地，$ \\lambda $ 是特征多项式 $ p_A(\\lambda) = \\det(A - \\lambda I) $ 的一个根。行列式 $ \\det(A) $ 是方阵上的一个标量泛函，它在矩阵乘法下是乘性的，并在相似变换下保持不变。对于上三角矩阵，行列式等于对角线元素的乘积，且其特征值与这些对角线元素重合。\n\n正交三角（QR）算法是一种近似特征值的迭代方法，其根源在于观察到正交相似变换在保持谱不变的同时能改善矩阵的三角结构。在第 $ k $ 次迭代中，计算QR分解 $ A_k = Q_k R_k $，其中 $ Q_k^\\mathsf{T} Q_k = I $ 且 $ R_k $ 是上三角矩阵，然后形成正交相似变换\n$$\nA_{k+1} = R_k Q_k = Q_k^\\mathsf{T} A_k Q_k.\n$$\n因为 $ A_{k+1} $ 与 $ A_k $ 正交相似，所以它们具有相同的特征值。重复此过程会使 $ A_k $ 趋向于一个上三角（舒尔）形式，当 $ A $ 是对称矩阵时，则趋向于一个对角形式。在对称情况下，由于对称矩阵是正交可对角化的，对于小矩阵，未平移算法的非对角线元素收敛到零是一种标准且稳健的行为。\n\n为了设计一个数值上稳健的停止准则，我们监控严格非对角线元素的弗罗贝尼乌斯范数。设 $ \\mathrm{off}(A) $ 表示将 $ A $ 的对角线元素置零后得到的矩阵。当满足以下条件时，我们宣告收敛\n$$\n\\|\\mathrm{off}(A_k)\\|_F \\le \\varepsilon \\, \\|A_k\\|_F,\n$$\n其中 $ \\varepsilon = 10^{-12} $。对于在数值容差范围内精确为上三角的矩阵，其特征值可以直接从对角线读取，因为上三角矩阵已经是实舒尔形式。对于一个 $ 1 \\times 1 $ 矩阵 $ [\\alpha] $，唯一的特征值是 $ \\alpha $。\n\n在使用正交三角迭代近似测试矩阵 $ A $ 的特征值 $ \\{\\lambda_i\\}_{i=1}^n $ 之后，我们计算标量\n$$\nP = \\prod_{i=1}^n \\lambda_i,\n$$\n并独立地使用一个稳定的直接例程计算行列式 $ D = \\det(A) $。为了量化这两个独立计算的量之间的数值一致性，我们使用一个尺度敏感的误差定义：\n- 如果 $ |D| \\ge 10^{-12} $，使用相对误差 $ e = \\frac{|P - D|}{|D|} $。\n- 否则，使用绝对误差 $ e = |P - D| $。\n如果 $ e \\le 10^{-8} $，我们则宣告该矩阵的测试成功。\n\n我们构建一个测试套件来探究几个方面：一个稠密的对称正定矩阵 $ A_1 $，一个稠密的对称不定矩阵 $ A_2 $，一个上三角非对称矩阵 $ A_3 $，一个近奇异的对角矩阵 $ A_4 $，以及一个标量矩阵 $ A_5 $。稠密的对称情况是通过正交相似变换 $ A = Q D Q^\\mathsf{T} $ 形成的，其中正交矩阵 $ Q $ 由绕坐标轴旋转的矩阵乘积给出：\n$$\nR_z(\\theta) =\n\\begin{bmatrix}\n\\cos\\theta  & -\\sin\\theta & 0 \\\\\n\\sin\\theta & \\cos\\theta & 0 \\\\\n0 & 0 & 1\n\\end{bmatrix}, \\quad\nR_y(\\phi) =\n\\begin{bmatrix}\n\\cos\\phi & 0 & \\sin\\phi \\\\\n0 & 1 & 0 \\\\\n-\\sin\\phi & 0 & \\cos\\phi\n\\end{bmatrix}, \\quad\nR_x(\\psi) =\n\\begin{bmatrix}\n1 & 0 & 0 \\\\\n0 & \\cos\\psi & -\\sin\\psi \\\\\n0 & \\sin\\psi & \\cos\\psi\n\\end{bmatrix},\n$$\n角度以弧度为单位。具体来说，我们使用：\n- $ A_1 = Q_1 D_1 Q_1^\\mathsf{T} $，其中 $ Q_1 = R_z(\\pi/6) R_y(\\pi/5) $ 且 $ D_1 = \\mathrm{diag}(2.5, 1.2, 0.7) $。\n- $ A_2 = Q_2 D_2 Q_2^\\mathsf{T} $，其中 $ Q_2 = R_x(\\pi/7) R_z(\\pi/8) $ 且 $ D_2 = \\mathrm{diag}(3.0, -1.0, 0.5) $。\n- $ A_3 $ 是一个显式给出的 $ 4 \\times 4 $ 上三角矩阵，其对角线元素为正，因此其特征值就是其对角线元素。\n- $ A_4 $ 是一个对角矩阵，包含一个非常小的元素 $ 10^{-8} $，用于测试近奇异情况的处理。\n- $ A_5 $ 是一个 $ 1 \\times 1 $ 矩阵，用于测试边界情况。\n\n实现细节：\n- 对于对称矩阵，我们应用未平移的正交三角迭代，直到满足非对角范数准则或达到最大迭代次数上限（例如，$ 10^4 $ 次迭代），这对于此处使用的小尺寸矩阵是足够的。\n- 对于由 $\\|\\mathrm{strict\\_lower}(A)\\|_{\\max} \\le 10^{-14} $ 检测为上三角的矩阵，我们返回其对角线元素作为特征值。\n- 我们使用标准的直接例程计算行列式，然后使用上述误差度量将其与近似特征值的乘积进行比较。\n\n最终程序构造这五个矩阵，按规定运行正交三角特征值近似算法，计算 $ P $ 和 $ D $，评估每个案例的通过/失败布尔值，并打印包含列表 $ [\\text{bool}_1,\\text{bool}_2,\\text{bool}_3,\\text{bool}_4,\\text{bool}_5] $ 的单行输出。只要实现遵循算法和数值规范，所有五个案例都将在规定的容差内通过，从而在数值上证明，通过正交三角算法获得的特征值计算出的乘积与直接计算的行列式在规定的误差范围内是一致的。",
            "answer": "```python\nimport numpy as np\n\ndef rotation_matrices():\n    # Define rotation matrices about z, y, x axes with angle in radians\n    def Rz(theta):\n        c, s = np.cos(theta), np.sin(theta)\n        return np.array([[c, -s, 0.0],\n                         [s,  c, 0.0],\n                         [0.0, 0.0, 1.0]], dtype=float)\n\n    def Ry(phi):\n        c, s = np.cos(phi), np.sin(phi)\n        return np.array([[ c, 0.0,  s],\n                         [0.0, 1.0, 0.0],\n                         [-s, 0.0,  c]], dtype=float)\n\n    def Rx(psi):\n        c, s = np.cos(psi), np.sin(psi)\n        return np.array([[1.0, 0.0, 0.0],\n                         [0.0,  c, -s],\n                         [0.0,  s,  c]], dtype=float)\n    return Rz, Ry, Rx\n\ndef is_symmetric(a, tol=1e-14):\n    return np.allclose(a, a.T, atol=tol, rtol=0.0)\n\ndef is_upper_triangular(a, tol=1e-14):\n    return np.all(np.abs(np.tril(a, -1)) = tol)\n\ndef qr_eigvals_symmetric(a, tol=1e-12, max_iter=10000):\n    \"\"\"\n    Unshifted QR iteration for symmetric matrices.\n    Returns approximate eigenvalues as the diagonal of the iterated matrix.\n    \"\"\"\n    n = a.shape[0]\n    ak = a.copy().astype(float)\n    # Iterate until off-diagonal Frobenius norm is small\n    for _ in range(max_iter):\n        # Compute off-diagonal Frobenius norm\n        off = ak - np.diag(np.diag(ak))\n        off_norm = np.linalg.norm(off, ord='fro')\n        total_norm = np.linalg.norm(ak, ord='fro')\n        # Avoid division by zero in case of zero matrix\n        scale = max(1.0, total_norm)\n        if off_norm = tol * scale:\n            break\n        q, r = np.linalg.qr(ak)\n        ak = r @ q\n    return np.diag(ak)\n\ndef eigenvalues_via_qr(a):\n    \"\"\"\n    Compute eigenvalues via QR algorithm under the constraints:\n    - If symmetric (within tolerance), use unshifted QR iteration until convergence.\n    - If upper triangular (within tolerance), return diagonal entries.\n    - If 1x1, return the single entry.\n    For this test suite, these branches suffice.\n    \"\"\"\n    n, m = a.shape\n    if n != m:\n        raise ValueError(\"Matrix must be square.\")\n    if n == 1:\n        return np.array([a[0, 0]], dtype=float)\n    if is_symmetric(a):\n        return qr_eigvals_symmetric(a)\n    if is_upper_triangular(a):\n        return np.diag(a).copy()\n    # Fallback: for robustness (not used in provided tests), attempt generic unshifted QR\n    # without claiming convergence to diagonal; will return diagonal of iterates.\n    ak = a.copy().astype(float)\n    for _ in range(5000):\n        q, r = np.linalg.qr(ak)\n        ak = r @ q\n        # If subdiagonal is sufficiently small, we can read diagonal as eigenvalues\n        if np.all(np.abs(np.tril(ak, -1)) = 1e-12):\n            break\n    return np.diag(ak)\n\ndef build_test_matrices():\n    Rz, Ry, Rx = rotation_matrices()\n    # Case 1: Symmetric positive definite (3x3), dense\n    theta = np.pi / 6.0\n    phi = np.pi / 5.0\n    Q1 = Rz(theta) @ Ry(phi)\n    D1 = np.diag([2.5, 1.2, 0.7])\n    A1 = Q1 @ D1 @ Q1.T\n\n    # Case 2: Symmetric indefinite (3x3), dense\n    psi = np.pi / 7.0\n    varphi = np.pi / 8.0\n    Q2 = Rx(psi) @ Rz(varphi)\n    D2 = np.diag([3.0, -1.0, 0.5])\n    A2 = Q2 @ D2 @ Q2.T\n\n    # Case 3: Upper triangular (4x4), non-symmetric\n    A3 = np.array([\n        [1.0, 0.3, -0.2, 0.1],\n        [0.0, 2.0, -0.1, 0.25],\n        [0.0, 0.0, 3.0, 0.05],\n        [0.0, 0.0, 0.0, 4.0]\n    ], dtype=float)\n\n    # Case 4: Diagonal nearly singular (3x3)\n    A4 = np.diag([1e-8, 1.0, 2.0])\n\n    # Case 5: Scalar boundary (1x1)\n    A5 = np.array([[5.0]], dtype=float)\n\n    return [A1, A2, A3, A4, A5]\n\ndef compare_product_vs_det(a, rel_tol=1e-8, abs_thresh=1e-12):\n    eigs = eigenvalues_via_qr(a)\n    P = float(np.prod(eigs))\n    D = float(np.linalg.det(a))\n    diff = abs(P - D)\n    if abs(D) >= abs_thresh:\n        err = diff / abs(D)\n    else:\n        err = diff\n    return err = rel_tol\n\ndef solve():\n    test_matrices = build_test_matrices()\n    results = [compare_product_vs_det(A) for A in test_matrices]\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "任何算法都有其适用范围和局限性。在成功实现基础 QR 算法后，下一个关键步骤是探索其失效的场景。本练习  揭示了朴素 QR 算法的一个典型“陷阱”：当矩阵的特征值模长相等时，算法可能不会收敛到上三角形式，而是陷入循环。理解这种失效模式，将帮助你认识到为何需要引入“位移”等高级策略来构建一个稳健的特征值求解器。",
            "id": "2431496",
            "problem": "给定实数方阵和以下基于正交上三角 (QR) 分解的迭代映射。对于给定的实数矩阵 $A^{(0)} \\in \\mathbb{R}^{n \\times n}$，按以下规则定义序列 $\\{A^{(k)}\\}_{k=0}^{\\infty}$：对于每个迭代索引 $k \\ge 0$，计算正交上三角 (QR) 分解 $A^{(k)} = Q^{(k)} R^{(k)}$，其中 $Q^{(k)}$ 是正交矩阵，$R^{(k)}$ 是对角线元素为正的上三角矩阵，然后设置\n$$\nA^{(k+1)} = R^{(k)} Q^{(k)}.\n$$\n考虑以下针对 $2 \\times 2$ 实数矩阵的决策问题：使用容差 $\\tau = 10^{-12}$ 和最大迭代次数 $k_{\\max} = 100$ 运行上述迭代。使用以下互斥规则对序列的行为进行分类：\n- 收敛到上三角：如果对于某个 $k \\le k_{\\max}$， $A^{(k)}$ 的严格下三角部分的弗罗贝尼乌斯范数满足 $\\lVert \\operatorname{tril}(A^{(k)}, -1) \\rVert_{F} \\le \\tau$，则报告整数代码 $0$。\n- 检测到长度为 $1$ 的循环：如果对于某个 $k \\le k_{\\max}$，有 $\\lVert A^{(k)} - A^{(k-1)} \\rVert_{F} \\le \\tau$，则报告整数代码 $1$。\n- 检测到长度为 $2$ 的循环：如果对于某个 $k \\le k_{\\max}$，有 $\\lVert A^{(k)} - A^{(k-2)} \\rVert_{F} \\le \\tau$，则报告整数代码 $2$。\n- 其他情况：如果在 $k_{\\max}$ 次迭代内未满足上述任何条件，则报告整数代码 $3$。\n\n这里 $\\lVert \\cdot \\rVert_{F}$ 表示弗罗贝尼乌斯范数，$\\operatorname{tril}(\\cdot,-1)$ 提取严格下三角部分，并且必须在每一步强制执行对 $R^{(k)}$ 的对角线为正的约束。\n\n使用此决策问题来研究迭代在以下测试矩阵套件上的行为：\n- 测试 $1$ (翻转矩阵): \n$$\nA^{(1)} = \\begin{bmatrix} 0  1 \\\\ 1  0 \\end{bmatrix}.\n$$\n- 测试 $2$ (具有不同特征值的对称矩阵): \n$$\nA^{(2)} = \\begin{bmatrix} 2  1 \\\\ 1  2 \\end{bmatrix}.\n$$\n- 测试 $3$ (单位矩阵): \n$$\nA^{(3)} = \\begin{bmatrix} 1  0 \\\\ 0  1 \\end{bmatrix}.\n$$\n- 测试 $4$ (对角线为正的上三角矩阵): \n$\nA^{(4)} = \\begin{bmatrix} 1  10 \\\\ 0  1 \\end{bmatrix}.\n$\n\n对于上述 $4$ 个测试中的每一个，你的程序必须从 $A^{(0)} = A^{(j)}$ (对于 $j \\in \\{1,2,3,4\\}$) 开始运行迭代，并根据上述规则返回相应的整数代码。\n\n最终输出格式：你的程序应生成单行输出，其中包含用方括号括起来的 $4$ 个整数代码的逗号分隔列表（例如，$[c_1,c_2,c_3,c_4]$）。不应打印任何其他文本。此问题不涉及任何物理单位或角度；所有输出都是无单位的整数。",
            "solution": "问题陈述已经过验证。\n\n**步骤 1：提取给定信息**\n- **迭代映射**：对于一个实数矩阵 $A^{(0)} \\in \\mathbb{R}^{n \\times n}$，序列 $\\{A^{(k)}\\}_{k=0}^{\\infty}$ 定义如下：\n  1. $A^{(k)} = Q^{(k)} R^{(k)}$，其中 $Q^{(k)}$ 是正交矩阵，$R^{(k)}$ 是对角线元素为正的上三角矩阵。\n  2. $A^{(k+1)} = R^{(k)} Q^{(k)}$。\n- **$2 \\times 2$ 矩阵的决策问题参数**：\n  - 容差：$\\tau = 10^{-12}$。\n  - 最大迭代次数：$k_{\\max} = 100$。\n- **分类规则**：\n  1.  **代码 0 (收敛到上三角)**：对于某个 $k \\in [0, k_{\\max}]$，$\\lVert \\operatorname{tril}(A^{(k)}, -1) \\rVert_{F} \\le \\tau$。\n  2.  **代码 1 (长度为 1 的循环)**：对于某个 $k \\in [1, k_{\\max}]$，$\\lVert A^{(k)} - A^{(k-1)} \\rVert_{F} \\le \\tau$。\n  3.  **代码 2 (长度为 2 的循环)**：对于某个 $k \\in [2, k_{\\max}]$，$\\lVert A^{(k)} - A^{(k-2)} \\rVert_{F} \\le \\tau$。\n  4.  **代码 3 (其他情况)**：未满足上述任何条件。\n- **定义**：\n  - $\\lVert \\cdot \\rVert_{F}$ 是弗罗贝尼乌斯范数。\n  - $\\operatorname{tril}(\\cdot, -1)$ 是矩阵的严格下三角部分。\n- **测试矩阵 ($A^{(0)}$)**：\n  1.  $A^{(1)} = \\begin{bmatrix} 0  1 \\\\ 1  0 \\end{bmatrix}$\n  2.  $A^{(2)} = \\begin{bmatrix} 2  1 \\\\ 1  2 \\end{bmatrix}$\n  3.  $A^{(3)} = \\begin{bmatrix} 1  0 \\\\ 0  1 \\end{bmatrix}$\n  4.  $A^{(4)} = \\begin{bmatrix} 1  10 \\\\ 0  1 \\end{bmatrix}$\n\n**步骤 2：使用提取的给定信息进行验证**\n- **科学依据**：该问题描述了纯（无位移）QR算法，这是数值线性代数中用于计算特征值的一个基本且成熟的方法。所描述的行为和分类规则是分析此类迭代方法收敛性的标准测试。该问题在科学上是合理的。\n- **适定性**：迭代映射是确定性的。上三角矩阵 $R^{(k)}$ 必须具有正对角线元素的条件确保了对于任何非奇异矩阵 $A^{(k)}$，QR 分解是唯一的。所有初始测试矩阵都是非奇异的，并且由于迭代 $A^{(k+1)} = (Q^{(k)})^T A^{(k)} Q^{(k)}$ 是一个相似变换，所有后续矩阵 $A^{(k)}$ 也将是非奇异的。分类规则是在每次迭代时执行的条件检查。为确保规则的“互斥”性质，必须按特定的优先顺序检查它们。自然且合乎逻辑的顺序是所呈现的顺序：$0, 1, 2, 3$。这使得问题是适定的。\n- **客观性**：该问题使用精确的数学语言陈述，具有明确定义的量、条件和数值。它没有歧义和主观性。\n\n**步骤 3：结论与行动**\n问题是**有效的**。将提供一个解决方案。\n\nQR 迭代由序列 $A^{(k+1)} = R^{(k)}Q^{(k)}$ 定义，其中 $A^{(k)} = Q^{(k)}R^{(k)}$。将 $R^{(k)} = (Q^{(k)})^T A^{(k)}$（因为 $Q^{(k)}$ 是正交的）代入更新规则，得到 $A^{(k+1)} = (Q^{(k)})^T A^{(k)} Q^{(k)}$。这表明每个 $A^{(k)}$ 都与其前一个矩阵正交相似，因此序列 $\\{A^{(k)}\\}$ 中的所有矩阵都与初始矩阵 $A^{(0)}$ 具有相同的特征值。\n\n已知该算法在特定条件下会收敛到上三角（或对于复特征值为准三角）的舒尔型。具体来说，对于一个具有不同模值的特征值 $\\{\\lambda_i\\}$（即 $|\\lambda_1|  |\\lambda_2|  \\dots  |\\lambda_n|$）的实数矩阵，序列 $A^{(k)}$ 会收敛到一个上三角矩阵，其对角线元素是 $A^{(0)}$ 的特征值。分类规则旨在测试这种收敛性或识别其他行为，如不动点或循环，当特征值模值条件不满足时，这些行为可能会发生。在每次从 $0$ 到 $k_{max}$ 的迭代 $k$ 中，规则按 $0, 1, 2$ 的顺序进行检查。\n\n**测试用例分析：**\n\n**测试 1：** $A^{(0)} = \\begin{bmatrix} 0  1 \\\\ 1  0 \\end{bmatrix}$。\n该矩阵是对称的。其特征方程为 $\\lambda^2 - 1 = 0$，得到特征值 $\\lambda_1 = 1$ 和 $\\lambda_2 = -1$。特征值的模相等，即 $|\\lambda_1| = |\\lambda_2| = 1$，这违反了简单 QR 算法的标准收敛条件。\n为了确定其行为，我们计算第一次迭代。我们需要唯一的 QR 分解 $A^{(0)} = Q^{(0)}R^{(0)}$，其中 $R^{(0)}$ 的对角线元素为正。对于 $A^{(0)}$，这个分解是 $Q^{(0)} = \\begin{bmatrix} 0  1 \\\\ 1  0 \\end{bmatrix}$ 和 $R^{(0)} = \\begin{bmatrix} 1  0 \\\\ 0  1 \\end{bmatrix} = I$。$Q^{(0)}$ 是正交的且 $R^{(0)}$ 是对角线为正的上三角矩阵这两个条件都满足。\n下一个迭代是 $A^{(1)} = R^{(0)}Q^{(0)} = I Q^{(0)} = Q^{(0)} = A^{(0)}$。该序列是常数：对于所有 $k \\ge 0$，$A^{(k)} = A^{(0)}$。这是迭代的一个不动点。\n我们现在应用分类规则：\n- 在 $k=0$ 时：$A^{(0)}$ 是上三角矩阵吗？不是，因为元素 $A_{21}^{(0)} = 1 \\neq 0$。范数 $\\lVert \\operatorname{tril}(A^{(0)},-1)\\rVert_F = 1$，不小于 $\\tau = 10^{-12}$。规则 $0$ 不满足。\n- 在 $k=1$ 时：我们有 $A^{(1)} = A^{(0)}$。\n  - 规则 $0$：$A^{(1)}$ 是上三角矩阵吗？不是。\n  - 规则 $1$：$\\lVert A^{(1)} - A^{(0)} \\rVert_F \\le \\tau$ 吗？是的，因为 $\\lVert A^{(0)} - A^{(0)} \\rVert_F = 0 \\le \\tau$。\n过程终止并报告代码 $1$。\n\n**测试 2：** $A^{(0)} = \\begin{bmatrix} 2  1 \\\\ 1  2 \\end{bmatrix}$。\n这是一个对称矩阵。其特征方程是 $(2-\\lambda)^2 - 1 = 0$，得到特征值 $\\lambda_1 = 3$ 和 $\\lambda_2 = 1$。特征值是实数且具有不同的模，即 $|3|  |1|$。QR 算法的理论预测，对于这样的矩阵，序列 $A^{(k)}$ 将收敛到一个包含按模排序的特征值的对角矩阵：$A^{(k)} \\to \\begin{pmatrix} 3  0 \\\\ 0  1 \\end{pmatrix}$。对角矩阵是上三角矩阵的一个特例。因此，$A^{(k)}$ 的严格下三角部分将收敛到零。对于某个足够大的 $k \\le k_{\\max}$，条件 $\\lVert \\operatorname{tril}(A^{(k)},-1)\\rVert_F \\le \\tau$ 将被满足。分类将是代码 $0$。\n\n**测试 3：** $A^{(0)} = \\begin{bmatrix} 1  0 \\\\ 0  1 \\end{bmatrix}$。\n初始矩阵是单位矩阵。它已经是上三角（实际上是对角）形式。我们在第一步，$k=0$ 时就应用分类规则：\n- 规则 $0$：$\\lVert \\operatorname{tril}(A^{(0)},-1)\\rVert_F \\le \\tau$ 吗？单位矩阵的严格下三角部分是零矩阵，所以其弗罗贝尼乌斯范数为 $0$。条件 $0 \\le \\tau$ 满足。\n过程立即终止并报告代码 $0$。\n\n**测试 4：** $A^{(0)} = \\begin{bmatrix} 1  10 \\\\ 0  1 \\end{bmatrix}$。\n初始矩阵已经是上三角形式。这是一个具有重复特征值 $\\lambda_1=\\lambda_2=1$ 的不可对角化的若尔当块。与测试 3 类似，我们在 $k=0$ 时检查条件：\n- 规则 $0$：$\\lVert \\operatorname{tril}(A^{(0)},-1)\\rVert_F \\le \\tau$ 吗？该矩阵是上三角矩阵，所以其严格下三角部分为零。范数为 $0$。条件 $0 \\le \\tau$ 满足。\n过程终止并报告代码 $0$。\n它也是迭代的一个不动点，因为 $A^{(0)}$ 是对角线为正的上三角矩阵，这使得 $Q^{(0)}=I$ 和 $R^{(0)}=A^{(0)}$，所以 $A^{(1)} = R^{(0)}Q^{(0)} = A^{(0)}I = A^{(0)}$。然而，收敛到上三角形式的规则具有更高的优先级，并且在 $k=0$ 时就已满足。\n\n预测的分类代码是 $[1, 0, 0, 0]$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the QR iteration classification problem for a suite of test matrices.\n    \"\"\"\n\n    def classify_qr_behavior(A0, k_max, tau):\n        \"\"\"\n        Runs the QR iteration and classifies the behavior of the sequence A^(k).\n\n        Args:\n            A0 (np.ndarray): The initial 2x2 real matrix.\n            k_max (int): The maximum number of iterations.\n            tau (float): The tolerance for convergence/cycle detection.\n\n        Returns:\n            int: The integer classification code (0, 1, 2, or 3).\n        \"\"\"\n        # A sliding window of the last three matrices in the sequence: [A^(k-2), A^(k-1), A^(k)]\n        A_hist = [\n            np.full_like(A0, np.nan, dtype=float),\n            np.full_like(A0, np.nan, dtype=float),\n            A0.astype(float)\n        ]\n\n        # Default result if no condition is met within k_max iterations.\n        result_code = 3\n\n        for k in range(k_max + 1):\n            A_k = A_hist[2]\n\n            # Rule 0: Converged to upper triangular.\n            # This check has the highest precedence.\n            if np.linalg.norm(np.tril(A_k, -1), 'fro')  tau:\n                result_code = 0\n                break\n\n            # Rule 1: Detected a cycle of length 1 (fixed point).\n            # This check requires k >= 1 to have a previous matrix A^(k-1).\n            if k >= 1:\n                if np.linalg.norm(A_k - A_hist[1], 'fro')  tau:\n                    result_code = 1\n                    break\n            \n            # Rule 2: Detected a cycle of length 2.\n            # This check requires k >= 2 to have A^(k-2).\n            if k >= 2:\n                if np.linalg.norm(A_k - A_hist[0], 'fro')  tau:\n                    result_code = 2\n                    break\n            \n            # If the loop reaches its final iteration, break and return the default code 3.\n            if k == k_max:\n                break\n\n            # Compute the next matrix in the sequence, A^(k+1).\n            Q, R = np.linalg.qr(A_k)\n            \n            # Enforce the problem constraint: R must have positive diagonal entries.\n            # The QR decomposition is unique for non-singular matrices under this constraint.\n            signs = np.sign(np.diag(R))\n            # Handle potential zero on the diagonal (though not expected for these test cases).\n            signs[signs == 0] = 1.0\n            S = np.diag(signs)\n            \n            Q_corr = Q @ S\n            R_corr = S @ R\n            \n            A_next = R_corr @ Q_corr\n\n            # Update the history by sliding the window.\n            A_hist = [A_hist[1], A_hist[2], A_next]\n            \n        return result_code\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        np.array([[0., 1.], [1., 0.]]),    # Test 1\n        np.array([[2., 1.], [1., 2.]]),    # Test 2\n        np.array([[1., 0.], [0., 1.]]),    # Test 3\n        np.array([[1., 10.], [0., 1.]])   # Test 4\n    ]\n    \n    # Parameters for the decision problem.\n    tau = 1e-12\n    k_max = 100\n\n    results = []\n    for A0 in test_cases:\n        code = classify_qr_behavior(A0, k_max, tau)\n        results.append(code)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "为了克服基础算法的局限性，并高效处理具有复数特征值的实矩阵（同时避免复数运算），现代 QR 算法普遍采用 Francis 隐式双步位移策略。这个练习将带你深入该算法的核心，实现一个完整的隐式双步位移步骤。通过动手实现“凸起追逐”（bulge-chasing）这一精妙的技巧 ，你将具体地理解工业级特征值求解器是如何兼顾计算速度与算法稳定性的。",
            "id": "2431491",
            "problem": "您必须实现、测试并运行一个针对实上海森堡（Hessenberg）形式矩阵的单次隐式双步位移正交三角 (QR) 步，以处理末尾子块具有共轭复特征值对的情况。您的程序必须是一个完整的、可运行的程序。目标是实现一个 Francis 隐式双步位移步，作为对一个实上海森堡矩阵的正交相似变换。实现必须通过使用由末尾 $2\\times 2$ 子块构建的实数二次位移来避免任何复数运算。\n\n从基本定义和事实开始：\n- 矩阵 $A$ 的一个特征对是一个标量 $\\,\\lambda\\,$ 和一个非零向量 $\\,v\\,$，满足 $\\,A v = \\lambda v\\,$。\n- 相似变换 $\\,\\widetilde{A} = S^{-1} A S\\,$ 保持特征多项式不变，因此也保持所有特征值不变。如果 $\\,S\\,$ 是正交的，那么 $\\,\\widetilde{A} = S^{\\mathsf{T}} A S\\,$ 会保持内积和弗罗贝尼乌斯（Frobenius）范数。\n- 任何方阵 $\\,A\\in\\mathbb{R}^{n\\times n}\\,$ 都可以通过正交相似变换化约为（上）海森堡形式 $\\,H\\,$，其中对于所有 $\\,i  j+1\\,$，$\\,H_{ij} = 0\\,$。\n- 一个双步位移 QR 步利用上海森堡矩阵的末尾 $\\,2\\times 2\\,$ 子块构造一个二次多项式位移。如果末尾子块是 $\\,T = \\begin{bmatrix} t_{11}  t_{12}\\\\ t_{21}  t_{22}\\end{bmatrix}\\,$，那么位移多项式为 $\\,q(x) = x^2 - s x + p\\,$，其中 $\\,s = t_{11} + t_{22}\\,$ 且 $\\,p = t_{11} t_{22} - t_{12} t_{21}\\,$。该多项式等于 $\\, (x - \\mu_1)(x - \\mu_2)\\,$，其中 $\\,\\mu_1, \\mu_2\\,$ 是 $\\,T\\,$ 的（可能为复数的）特征值，这确保了多项式系数为实数。根据隐式正交三角定理（Implicit Q Theorem），可以应用从 $\\,q(H)\\,$ 构造的一系列正交变换，以实现与两个连续的单步位移步骤相同的效果，而无需显式地构造 $\\,q(H)\\,$。\n\n您的任务：\n- 实现一个函数，对一个实上海森堡矩阵 $\\,H \\in \\mathbb{R}^{n\\times n}\\,$ 执行一次实数隐式双步位移 QR 步，生成 $\\,\\widehat{H} = Q^{\\mathsf{T}} H Q\\,$，其中 $\\,Q\\,$ 是正交矩阵。您必须：\n  - 全程只使用实数运算（无复数类型）。\n  - 使用如上所述的来自末尾 $\\,2\\times 2\\,$ 子块的二次位移系数 $\\,s\\,$ 和 $\\,p\\,$。\n  - 通过 $\\,\\left(H^2 - s H + p I\\right) e_1\\,$ 的首向量来初始化变换，其中 $\\,e_1\\,$ 是第一个标准基向量，然后使用 Householder 反射进行凸起追逐（bulge-chasing）以保持海森堡结构。\n  - 通过对每个 Householder 反射进行左乘和右乘应用来保持正交性。\n  - 通过正交变换消除第一副对角线下方的填充元素，并将任何小于数值上合理容差的残留项置零，以保持上海森堡形式。\n\n- 您不得使用任何预打包的特征值例程、复数算术或执行 QR 算法的黑盒函数。允许使用线性代数原语，如矩阵向量乘积和 Householder 反射，但它们必须根据正交变换的基本原理从头构建。\n\n测试套件：\n将您的实现应用于以下四个实上海森堡矩阵（所有条目均为实数，每个矩阵都已明确给出）：\n1) 情况 A ($\\,4\\times 4\\,$):\n$$\nH_A =\n\\begin{bmatrix}\n1.0  2.0  0.0  0.0\\\\\n3.0  4.0  5.0  0.0\\\\\n0.0  6.0  0.5  2.0\\\\\n0.0  0.0  -3.0  0.5\n\\end{bmatrix}.\n$$\n2) 情况 B ($\\,5\\times 5\\,$):\n$$\nH_B =\n\\begin{bmatrix}\n2.0  -1.0  4.0  0.0  0.0\\\\\n5.0  3.0  -2.0  1.0  0.0\\\\\n0.0  -3.0  1.0  2.0  4.0\\\\\n0.0  0.0  1.5  0.0  2.0\\\\\n0.0  0.0  0.0  -2.5  0.0\n\\end{bmatrix}.\n$$\n3) 情况 C ($\\,3\\times 3\\,$):\n$$\nH_C =\n\\begin{bmatrix}\n0.0  2.0  1.0\\\\\n-10.0  0.0  3.0\\\\\n0.0  -4.0  1.0\n\\end{bmatrix}.\n$$\n4) 情况 D ($\\,2\\times 2\\,$):\n$$\nH_D =\n\\begin{bmatrix}\n0.0  5.0\\\\\n-4.0  0.0\n\\end{bmatrix}.\n$$\n\n在对每个案例执行一次双步位移 $\\,H \\mapsto \\widehat{H}\\,$ 后，需要计算的验证指标：\n- $\\,b_1\\,$: 在 $\\,\\widehat{H}\\,$ 中保持上海森堡结构（布尔值；如果在容差范围内，对所有 $\\,i  j+1\\,$ 都有 $\\,\\widehat{H}_{ij} = 0\\,$，则为真）。\n- $\\,b_2\\,$: 迹保持不变，即 $\\,|\\mathrm{tr}(\\widehat{H}) - \\mathrm{tr}(H)|\\,$ 在指定的微小容差范围内（布尔值）。\n- $\\,b_3\\,$: 弗罗贝尼乌斯范数保持不变，即 $\\,\\| \\widehat{H} \\|_F\\,$ 与 $\\,\\|H\\|_F\\,$ 在一个微小容差范围内相等（布尔值）。\n- $\\,b_4\\,$: 遵守实数运算规则（布尔值；如果 $\\,\\widehat{H}\\,$ 没有任何复数项，则为真）。\n\n数值容差：\n- 对迹的保持使用 $\\,10^{-10}\\,$ 的相对容差。\n- 对弗罗贝尼乌斯范数的保持使用 $\\,10^{-12}\\,$ 的相对容差。\n- 在检查海森堡结构时，将满足 $\\,i  j+1\\,$ 且其绝对值小于 $\\,10^{-12} \\cdot \\left(|\\widehat{H}_{i-1,i-1}| + |\\widehat{H}_{ii}|\\right)\\,$ 的元素 $\\,\\widehat{H}_{ij}\\,$ 视为零。\n\n最终输出格式：\n- 您的程序必须按顺序 $\\,\\{H_A,H_B,H_C,H_D\\}\\,$ 运行这四个案例，为每个案例计算布尔值 $\\,b_1, b_2, b_3, b_4\\,$，并生成一行输出，其中包含一个由 $\\,16\\,$ 个布尔值组成的逗号分隔列表，该列表用方括号括起来，顺序如下\n$$\n[b_{1,A}, b_{2,A}, b_{3,A}, b_{4,A},\\; b_{1,B}, b_{2,B}, b_{3,B}, b_{4,B},\\; b_{1,C}, b_{2,C}, b_{3,C}, b_{4,C},\\; b_{1,D}, b_{2,D}, b_{3,D}, b_{4,D}].\n$$\n不涉及角度或物理单位。输出元素是布尔值。程序必须是自包含的，并且不需要用户输入。",
            "solution": "问题陈述已经过严格审查，并被确定为有效。它在数值线性代数的成熟理论中有科学依据，特别是用于计算特征值的 Francis 隐式双步位移 QR 算法。该问题是适定的，提供了所有必要的数据、约束和验证指标。它是客观的，没有歧义或矛盾。因此，我们可以着手解决。\n\n任务是为一个实上海森堡矩阵 $\\,H \\in \\mathbb{R}^{n\\times n}\\,$ 实现单步的 Francis 隐式双步位移 QR 算法。该算法是非对称特征值求解器的基石，旨在使用纯实数运算来寻找包括共轭复数对在内的特征值。\n\n特征值计算的一个基本原理是使用相似变换 $\\,\\hat{H} = Q^{-1}HQ\\,$，这种变换能保持 $\\,H\\,$ 的特征值。当 $\\,Q\\,$ 是一个正交矩阵（$\\,Q^{-1}=Q^{\\mathsf{T}}\\,$）时，该变换是数值稳定的。QR 算法迭代地应用此类变换，将矩阵驱动到一种可以轻松提取特征值的形式，通常是上三角（舒尔）形式。\n\n一个带有实数位移 $\\,\\mu\\,$ 的简单 QR 步包括分解 $\\,H - \\mu I = QR\\,$ 并构造 $\\,\\hat{H} = R Q + \\mu I = Q^{\\mathsf{T}}HQ\\,$。然而，如果 $\\,H\\,$ 具有共轭复特征值，仅使用实数位移可能会导致收敛缓慢或失败。一个更稳健的策略是使用两个位移 $\\,\\mu_1\\,$ 和 $\\,\\mu_2\\,$，它们对应于某个末尾子矩阵的一对共轭复特征值。直接应用两个带有复数位移 $\\,\\mu_1\\,$ 和 $\\,\\mu_2\\,$ 的 QR 步将需要复数运算。\n\n隐式双步位移法，或称 Francis 步，通过仅使用实数运算同时应用这两个步骤来规避此问题。这两个位移产生一个实系数的二次多项式 $\\,q(x) = (x-\\mu_1)(x-\\mu_2) = x^2 - (\\mu_1+\\mu_2)x + \\mu_1\\mu_2 = x^2 - sx + p\\,$。系数 $\\,s\\,$（迹）和 $\\,p\\,$（行列式）是根据 $\\,H\\,$ 的末尾 $\\,2 \\times 2\\,$ 子矩阵计算的，该子矩阵的特征值被用作位移 $\\,\\mu_1, \\mu_2\\,$。这确保了 $\\,s\\,$ 和 $\\,p\\,$ 是实数。\n\n然后，算法利用隐式 Q 定理（Implicit Q Theorem）隐式地进行。该定理本质上指出，如果一个正交相似变换 $\\,Q^{\\mathsf{T}}HQ\\,$ 将 $\\,H\\,$ 化约为一个未约化的上海森堡矩阵 $\\,\\hat{H}\\,$，并且 $\\,Q\\,$ 的第一列是固定的，那么矩阵 $\\,Q\\,$ 和 $\\,\\hat{H}\\,$ 就被唯一确定。我们只需要为我们的总变换矩阵 $\\,Q\\,$ 构建正确的第一列，其余部分通过强制维持海森堡结构即可得出。\n\n所需变换矩阵 $\\,Q\\,$ 的第一列与在 $\\,H\\,$ 上计算的矩阵 $\\,(H^2 - sH + pI)\\,$ 的第一列成比例。设 $\\,\\mathbf{v} = (H^2 - sH + pI)\\mathbf{e}_1\\,$，其中 $\\,\\mathbf{e}_1\\,$ 是第一个标准基向量。对于一个上海森堡矩阵 $\\,H\\,$，这个向量 $\\,\\mathbf{v}\\,$ 只有其前三个分量 $\\,v_0, v_1, v_2\\,$ 可能为非零。\n\n算法如下：\n\n1.  **位移计算**：对于一个大小为 $\\,n \\times n\\,$ 且 $\\,n \\geq 2\\,$ 的矩阵 $\\,H\\,$，计算其末尾 $\\,2 \\times 2\\,$ 子块 $\\,H[n-2:n, n-2:n]\\,$ 的迹 $\\,s\\,$ 和行列式 $\\,p\\,$。对于 $n2$ 的情况不适用，但题目约束保证了最小尺寸。\n2.  **引发凸起**：计算 $\\,\\mathbf{v} = (H^2 - sH + pI)\\mathbf{e}_1\\,$ 的前三个分量。构建一个作用于前三行/列的 Householder 反射器 $\\,P_0\\,$，将这个三分量向量映射到 $\\,\\mathbf{e}_1\\,$ 的倍数。相似变换 $\\,H \\leftarrow P_0 H P_0\\,$ 会产生一个“凸起”——破坏海森堡结构的不需要的非零元，通常从位置 $\\,(2,0)\\,$ 或 $\\,(3,1)\\,$ 开始。\n\n3.  **凸起追逐**：生成一系列 Householder 反射器 $\\,P_1, P_2, \\ldots, P_{n-3}\\,$，以将凸起沿副对角线向下追逐并移出矩阵。每个反射器 $\\,P_k\\,$ 被设计为作用于行和列 $\\,k+1\\,$到 $\\,k+3\\,$，以恢复列 $\\,k\\,$ 中的海森堡结构。这是通过从列向量 $\\,H[k+1:k+4, k]\\,$ 构造一个反射器来实现的，以消除副对角线以下的元素。应用相似变换 $\\,H \\leftarrow P_k H P_k\\,$ 会恢复列 $\\,k\\,$，但在列 $\\,k+1\\,$ 中产生一个新的凸起。重复此过程，直到凸起被追逐出矩阵。\n\n4.  **最终化**：循环终止后，矩阵 $\\,\\hat{H}\\,$ 在浮点精度下恢复为上海森堡形式。副对角线下方的微小伪影项必须根据数值容差设置为零。然而，这一步是一种近似。对迹和弗罗贝尼乌斯范数保持性的验证（指标 $\\,b_2, b_3\\,$）必须在进行此置零操作*之前*的矩阵上进行，因为纯正交变换会精确地保持这些量。对实数运算的检查（$\\,b_4\\,$）通过构造即可满足。\n\n对于 $\\,n  3\\,$ 的矩阵，双步位移步不适用；矩阵将原样返回。\n\n实现将构建一个执行这些步骤的函数。Householder 反射器使用标准的数值稳定方法构建。对于每个反射器，依次应用左乘和右乘矩阵以实现相似变换。\n\n然后计算验证指标：\n- $\\,b_1\\,$：在应用指定的清理容差后，检查是否对于所有 $\\,i  j+1\\,$ 都有 $\\,\\hat{H}_{ij} = 0\\,$。\n- $\\,b_2\\,$：确认迹的保持性，即 $\\,|\\mathrm{tr}(\\hat{H}) - \\mathrm{tr}(H)| \\le 10^{-10} |\\mathrm{tr}(H)|\\,$。\n- $\\,b_3\\,$：确认弗罗贝尼乌斯范数的保持性，即 $\\,\\|\\hat{H}\\|_F\\,$ 和 $\\,\\|H\\|_F\\,$ 在相对容差 $\\,10^{-12}\\,$ 内相等。\n- $\\,b_4\\,$：确认结果矩阵的元素均为实数。",
            "answer": "```python\nimport numpy as np\n\ndef _create_householder_vector(x):\n    \"\"\"\n    Creates a Householder vector u from a given vector x.\n    The reflector P = I - 2*u*u.T transforms x into [alpha, 0, ..., 0].T.\n    Returns the vector u and the scalar alpha.\n    \"\"\"\n    if len(x) == 0:\n        return np.array([]), 0.0\n    \n    # Use copysign for numerical stability\n    alpha = np.linalg.norm(x)\n    signed_alpha = np.copysign(alpha, x[0])\n    \n    u = x.copy()\n    u[0] += signed_alpha\n    \n    norm_u = np.linalg.norm(u)\n    if norm_u  1e-15:  # Vector is already close to zero or e_1 aligned\n        return np.zeros_like(u), -signed_alpha\n        \n    u /= norm_u\n    return u, -signed_alpha\n\ndef francis_double_shift_qr_step(H):\n    \"\"\"\n    Performs a single implicit double-shift QR step on a real upper Hessenberg matrix H.\n    \"\"\"\n    n = H.shape[0]\n    if n  3:\n        return H.copy()\n\n    H_new = H.copy()\n\n    # 1. Calculate shift parameters s (trace) and p (determinant)\n    # from the trailing 2x2 block.\n    s = H_new[n-2, n-2] + H_new[n-1, n-1]\n    p = H_new[n-2, n-2] * H_new[n-1, n-1] - H_new[n-2, n-1] * H_new[n-1, n-2]\n\n    # 2. Compute the first column of (H^2 - sH + pI).\n    # This vector determines the first Householder transformation.\n    # Only the first 3 components are non-zero for a Hessenberg matrix.\n    h00, h10, h01 = H_new[0, 0], H_new[1, 0], H_new[0, 1]\n    h11, h21 = H_new[1, 1], H_new[2, 1]\n\n    v0 = h00 * (h00 - s) + h01 * h10 + p\n    v1 = h10 * (h00 + h11 - s)\n    v2 = h10 * h21\n    \n    v = np.array([v0, v1, v2])\n\n    # 3. Bulge-chasing loop\n    for k in range(n - 2):\n        # Determine the size of the reflector and the part of H to operate on.\n        # Window size is 3, but shrinks near the end of the matrix.\n        m = min(k + 3, n)\n        \n        # Get the vector for the Householder reflector.\n        # For k=0, it's the initial vector v calculated above.\n        # For k>0, it's part of the k-1 column of the current matrix,\n        # which contains the bulge from the previous step.\n        if k == 0:\n            sub_vector = v\n        else:\n            sub_vector = H_new[k:m, k-1]\n\n        # Create Householder reflector P = I - 2*u*u.T\n        if np.linalg.norm(sub_vector)  1e-15:\n            continue\n        \n        u, _ = _create_householder_vector(sub_vector)\n        \n        if np.linalg.norm(u)  1e-15:\n            continue\n\n        # Apply the transformation P from the left: H_new - P H_new\n        # This acts on rows k to m-1.\n        sub_matrix_left = H_new[k:m, k:]\n        tau_left = 2 * (u.T @ sub_matrix_left)\n        H_new[k:m, k:] -= np.outer(u, tau_left)\n\n        # Apply the transformation P from the right: H_new - H_new P\n        # This acts on columns k to m-1.\n        sub_matrix_right = H_new[:, k:m]\n        tau_right = 2 * (sub_matrix_right @ u)\n        H_new[:, k:m] -= np.outer(tau_right, u)\n\n    return H_new\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        np.array([\n            [1.0, 2.0, 0.0, 0.0],\n            [3.0, 4.0, 5.0, 0.0],\n            [0.0, 6.0, 0.5, 2.0],\n            [0.0, 0.0, -3.0, 0.5]\n        ]),\n        np.array([\n            [2.0, -1.0, 4.0, 0.0, 0.0],\n            [5.0, 3.0, -2.0, 1.0, 0.0],\n            [0.0, -3.0, 1.0, 2.0, 4.0],\n            [0.0, 0.0, 1.5, 0.0, 2.0],\n            [0.0, 0.0, 0.0, -2.5, 0.0]\n        ]),\n        np.array([\n            [0.0, 2.0, 1.0],\n            [-10.0, 0.0, 3.0],\n            [0.0, -4.0, 1.0]\n        ]),\n        np.array([\n            [0.0, 5.0],\n            [-4.0, 0.0]\n        ])\n    ]\n\n    results = []\n    \n    for H_orig in test_cases:\n        n = H_orig.shape[0]\n        \n        # Run one step of the algorithm\n        H_raw = francis_double_shift_qr_step(H_orig)\n\n        # Create a cleaned version for the Hessenberg structure check\n        H_clean = H_raw.copy()\n        for i in range(n):\n            for j in range(n):\n                if i > j + 1:\n                    # Tolerance from problem description\n                    tol_clean = 1e-12 * (np.abs(H_clean[i-1, i-1]) + np.abs(H_clean[i, i])) if i > 0 else 1e-12 * np.abs(H_clean[i,i])\n                    if np.abs(H_clean[i, j])  tol_clean:\n                        H_clean[i, j] = 0.0\n        \n        # --- Verification Metrics ---\n        # b1: Upper Hessenberg structure preserved\n        b1 = True\n        for i in range(n):\n            for j in range(n):\n                if i > j + 1 and H_clean[i, j] != 0.0:\n                    b1 = False\n                    break\n            if not b1:\n                break\n\n        # b2: Trace preserved (use raw matrix)\n        trace_orig = np.trace(H_orig)\n        trace_new = np.trace(H_raw)\n        b2 = np.isclose(trace_orig, trace_new, rtol=1e-10, atol=1e-12)\n\n        # b3: Frobenius norm preserved (use raw matrix)\n        norm_orig = np.linalg.norm(H_orig, 'fro')\n        norm_new = np.linalg.norm(H_raw, 'fro')\n        b3 = np.isclose(norm_orig, norm_new, rtol=1e-12, atol=1e-14)\n\n        # b4: Real arithmetic respected\n        b4 = not np.iscomplexobj(H_raw)\n\n        results.extend([b1, b2, b3, b4])\n    \n    # Format the final output as a comma-separated list of booleans\n    # Python's str(True) is 'True', which is a standard representation.\n    output_str = f\"[{','.join(map(str, results))}]\"\n    output_str = output_str.replace(\"True\", \"true\").replace(\"False\", \"false\") # Match lowercase example\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}