{
    "hands_on_practices": [
        {
            "introduction": "掌握雅可比方法的最好方式莫过于亲手实现它。这项实践将指导你编写一个完整的程序，使用雅可比旋转来迭代对角化一个对称矩阵。这不仅仅是一个计算练习；通过验证谱定理和计算得到的特征向量的正交性，你将深入理解该算法的数值特性和理论基础，这是计算科学中的一项核心技能。",
            "id": "2405358",
            "problem": "您需要编写一个完整的程序，使用雅可比旋转来验证实对称矩阵的谱定理，并定量地检查所得特征向量的正交性。对于每个测试用例，按如下方式构造一个实对称矩阵 $A \\in \\mathbb{R}^{n \\times n}$：给定一个整数种子 $s$ 和实数边界 $a_{\\min}$ 与 $a_{\\max}$，使用以种子 $s$ 初始化的伪随机数生成器，生成一个 $n \\times n$ 矩阵 $M$，其元素独立地从区间 $\\left[a_{\\min}, a_{\\max}\\right]$ 上的连续均匀分布中抽样。然后定义 $A = \\dfrac{1}{2}\\left(M + M^{\\mathsf{T}}\\right)$，以确保 $A$ 是实对称矩阵。您的任务是计算一个正交矩阵 $Q \\in \\mathbb{R}^{n \\times n}$ 和一个对角矩阵 $\\Lambda \\in \\mathbb{R}^{n \\times n}$，使得 $A \\approx Q \\Lambda Q^{\\mathsf{T}}$。对于 $Q^{\\mathsf{T}} A Q$ 的非对角部分的弗罗贝尼乌斯范数，使用 $\\varepsilon = 10^{-10}$ 的收敛容差，并强制执行最多 $10^{6}$ 次相似旋转的硬性上限。如果在内部计算了任何旋转角度，它们必须以弧度为单位。对于每个测试用例，报告以下三个实数：\n- $r_{\\mathrm{off}} = \\left\\| \\mathrm{offdiag}\\left(Q^{\\mathsf{T}} A Q\\right) \\right\\|_{F}$，其中 $\\mathrm{offdiag}(X)$ 表示将矩阵 $X$ 的对角线元素置零后的矩阵，$\\|\\cdot\\|_{F}$ 表示弗罗贝尼乌斯范数，\n- $r_{\\mathrm{rec}} = \\left\\| A - Q \\Lambda Q^{\\mathsf{T}} \\right\\|_{F}$，\n- $r_{\\mathrm{orth}} = \\left\\| Q^{\\mathsf{T}} Q - I \\right\\|_{F}$，其中 $I$ 是 $\\mathbb{R}^{n \\times n}$ 中的单位矩阵。\n\n所有这三个量都必须以浮点数形式报告，并采用科学记数法格式，小数点后精确到 $10$ 位。\n\n测试套件由以下参数集 $(n, s, a_{\\min}, a_{\\max})$ 组成：\n- $(n, s, a_{\\min}, a_{\\max}) = (1, 1, -1, 1)$,\n- $(n, s, a_{\\min}, a_{\\max}) = (2, 2, -1, 1)$,\n- $(n, s, a_{\\min}, a_{\\max}) = (5, 7, -1, 1)$,\n- $(n, s, a_{\\min}, a_{\\max}) = (6, 11, -10, 10)$。\n\n您的程序应生成单行输出，其中包含一个逗号分隔的列表，列表内容为每个测试用例的三元组结果，每个三元组按 $\\left[r_{\\mathrm{off}}, r_{\\mathrm{rec}}, r_{\\mathrm{orth}}\\right]$ 的顺序列出，且整个集合用方括号括起来。例如，包含两个用例的输出应如下所示：$[[x_{1},y_{1},z_{1}],[x_{2},y_{2},z_{2}]]$，其中每个符号 $x_{i}, y_{i}, z_{i}$ 表示一个指定格式的浮点数。请确保您的确切输出格式为单行，不含任何附加文本，每个数字均使用科学记数法，小数点后精确到 $10$ 位。",
            "solution": "该问题要求使用雅可比特征值算法对实对称矩阵的谱定理进行数值验证。谱定理指出，对于任意实对称矩阵 $A \\in \\mathbb{R}^{n \\times n}$，存在一个正交矩阵 $Q \\in \\mathbb{R}^{n \\times n}$ 和一个实对角矩阵 $\\Lambda \\in \\mathbb{R}^{n \\times n}$，使得 $A = Q \\Lambda Q^{\\mathsf{T}}$。$Q$ 的列是 $A$ 的标准正交特征向量，$\\Lambda$ 的对角线元素是相应的实特征值。\n\n我们的方法是实现雅可比旋转法，为给定的对称矩阵 $A$ 计算矩阵 $Q$ 和 $\\Lambda$。矩阵 $A$ 由一个伪随机矩阵 $M$ 构造而成，其元素从均匀分布 $U(a_{\\min}, a_{\\max})$ 中抽样，通过定义 $A = \\frac{1}{2}(M + M^{\\mathsf{T}})$ 来确保其对称性。\n\n雅可比方法是一种迭代算法，通过一系列相似变换，逐步将 $A$ 的非对角元素的量级减小至零。每次变换都是一次吉文斯旋转，旨在将特定的非对角元素 $a_{pq}$ 置零。\n单次雅可比旋转是一种形式为 $A' = J^{\\mathsf{T}} A J$ 的相似变换，其中 $J \\equiv J(p, q, \\theta)$ 是在 $(p, q)$ 平面上的旋转矩阵。矩阵 $J$ 是一个单位矩阵，除了四个元素外：\n$$\nJ_{pp} = \\cos\\theta, \\quad J_{qq} = \\cos\\theta \\\\\nJ_{pq} = \\sin\\theta, \\quad J_{qp} = -\\sin\\theta\n$$\n选择旋转角 $\\theta$ 以使变换后矩阵 $A'$ 的元素 $a'_{pq}$ 变为零。该条件导出方程：\n$$\n\\cot(2\\theta) = \\frac{a_{qq} - a_{pp}}{2 a_{pq}}\n$$\n为了数值稳定性和效率，我们避免直接计算 $\\theta$。而是计算 $t = \\tan\\theta$。令 $\\tau = \\frac{a_{qq} - a_{pp}}{2 a_{pq}}$。关于 $t$ 的方程是 $t^2 + 2\\tau t - 1 = 0$。我们选择绝对值较小的根以确保 $|\\theta| \\le \\pi/4$，这可以增强稳定性。这个根由下式给出：\n$$\nt = \\frac{\\operatorname{sgn}(\\tau)}{|\\tau| + \\sqrt{1 + \\tau^2}}\n$$\n对于 $\\tau \\neq 0$。如果 $\\tau = 0$（即 $a_{pp} = a_{qq}$），则 $\\theta = \\pi/4$ 且 $t=1$。由 $t$，我们得到 $c = \\cos\\theta = 1/\\sqrt{1+t^2}$ 和 $s = \\sin\\theta = t \\cdot c$。\n\n算法流程如下：\n1.  将特征向量矩阵 $Q$ 初始化为单位矩阵 $I \\in \\mathbb{R}^{n \\times n}$。\n2.  迭代应用旋转。我们使用循环雅可比方法，在每一次“扫描”（sweep）中，遍历所有唯一的非对角元素对 $(p, q)$（其中 $p  q$）。\n3.  对于每一对 $(p, q)$，如果 $a_{pq}$ 在数值上不为零，我们计算 $c$ 和 $s$ 并更新矩阵 $A$ 和 $Q$：\n    -   $A \\leftarrow J^{\\mathsf{T}} A J$\n    -   $Q \\leftarrow Q J$\n    这些更新仅影响相应矩阵的第 $p$ 行/列和第 $q$ 行/列。特征向量矩阵 $Q$ 累积了所有旋转矩阵的乘积。\n4.  当 $A$ 的非对角部分的弗罗贝尼乌斯范数（定义为 $S = \\sqrt{\\sum_{i \\neq j} a_{ij}^2}$）低于指定的容差 $\\varepsilon = 10^{-10}$，或达到最大旋转次数（$10^6$）时，过程终止。\n\n收敛后，矩阵 $A$ 被变换为一个近似的对角矩阵 $\\Lambda_{\\text{approx}}$，其对角线元素即为特征值。最终的矩阵 $Q$ 包含相应的特征向量作为其列。\n\n为了验证计算出的分解，我们计算三个误差度量：\n1.  非对角误差，$r_{\\mathrm{off}} = \\left\\| \\mathrm{offdiag}(Q^{\\mathsf{T}} A Q) \\right\\|_{F}$。这衡量了变换后的矩阵与完美对角矩阵的接近程度。\n2.  重构误差，$r_{\\mathrm{rec}} = \\left\\| A - Q \\Lambda Q^{\\mathsf{T}} \\right\\|_{F}$，其中 $\\Lambda$ 是由 $Q^{\\mathsf{T}} A Q$ 的对角线元素构成的纯对角矩阵。这量化了计算出的特征值和特征向量重构原始矩阵 $A$ 的效果。\n3.  正交性误差，$r_{\\mathrm{orth}} = \\left\\| Q^{\\mathsf{T}} Q - I \\right\\|_{F}$。这衡量了计算出的特征向量矩阵 $Q$ 与正交矩阵的接近程度。\n\n对于 $n=1$ 的平凡情况，矩阵 $A = [a_{11}]$ 已经是对角矩阵。我们有 $Q=[1]$ 和 $\\Lambda=[a_{11}]$，所有三个误差度量都精确为 $0$。对于所有其他情况，则应用雅可比算法。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the eigenvalues and eigenvectors of real symmetric matrices\n    using the Jacobi rotation method and verifies the spectral theorem.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (n, s, a_min, a_max)\n        (1, 1, -1, 1),\n        (2, 2, -1, 1),\n        (5, 7, -1, 1),\n        (6, 11, -10, 10),\n    ]\n    \n    TOLERANCE = 1e-10\n    MAX_ROTATIONS = 1_000_000\n\n    results_all_cases = []\n    for n, s, a_min, a_max in test_cases:\n        \n        # Handle the trivial case n=1\n        if n == 1:\n            results_all_cases.append([0.0, 0.0, 0.0])\n            continue\n            \n        # 1. Construct the real symmetric matrix A\n        rng = np.random.default_rng(seed=s)\n        M = rng.uniform(low=a_min, high=a_max, size=(n, n))\n        A = 0.5 * (M + M.T)\n        A_orig = A.copy()\n        \n        # Initialize eigenvector matrix Q to identity\n        Q = np.identity(n, dtype=np.float64)\n\n        # 2. Jacobi Iteration\n        rotation_count = 0\n        max_sweeps = 100 # A generous limit for sweeps\n        \n        for sweep in range(max_sweeps):\n            # Calculate sum of squares of off-diagonal elements\n            off_diag_sq_sum = np.sum(A**2) - np.sum(np.diag(A)**2)\n            \n            # Check for convergence\n            if np.sqrt(off_diag_sq_sum)  TOLERANCE:\n                break\n            \n            # Perform a sweep through all off-diagonal elements\n            for p in range(n):\n                for q in range(p + 1, n):\n                    if rotation_count >= MAX_ROTATIONS:\n                        break\n\n                    apq = A[p, q]\n                    # Skip rotation if element is already numerically zero\n                    if abs(apq)  1e-20:\n                        continue\n\n                    # Calculate rotation parameters c and s\n                    app = A[p, p]\n                    aqq = A[q, q]\n                    tau = (aqq - app) / (2.0 * apq)\n                    \n                    if tau == 0:\n                        t = 1.0\n                    else:\n                        t = np.sign(tau) / (abs(tau) + np.sqrt(1.0 + tau**2))\n                    \n                    c = 1.0 / np.sqrt(1.0 + t**2)\n                    s = c * t\n\n                    # Apply rotation to A (transform A -> J^T * A * J)\n                    app_old = A[p, p]\n                    aqq_old = A[q, q]\n                    A[p, p] = c*c*app_old - 2*c*s*apq + s*s*aqq_old\n                    A[q, q] = s*s*app_old + 2*c*s*apq + c*c*aqq_old\n                    A[p, q] = 0.0\n                    A[q, p] = 0.0\n\n                    for i in range(n):\n                        if i != p and i != q:\n                            aip_old = A[i, p]\n                            aiq_old = A[i, q]\n                            A[i, p] = c * aip_old - s * aiq_old\n                            A[p, i] = A[i, p]\n                            A[i, q] = s * aip_old + c * aiq_old\n                            A[q, i] = A[i, q]\n\n                    # Apply rotation to Q (transform Q -> Q * J)\n                    Q_col_p = Q[:, p].copy()\n                    Q_col_q = Q[:, q].copy()\n                    Q[:, p] = c * Q_col_p - s * Q_col_q\n                    Q[:, q] = s * Q_col_p + c * Q_col_q\n                    \n                    rotation_count += 1\n\n                if rotation_count >= MAX_ROTATIONS:\n                    break\n            \n            if rotation_count >= MAX_ROTATIONS:\n                break\n\n        # 3. Calculate final metrics\n        A_diag = A\n        \n        # r_off: Frobenius norm of the off-diagonal part of Q^T A Q\n        off_diag_part = A_diag - np.diag(np.diag(A_diag))\n        r_off = np.linalg.norm(off_diag_part, 'fro')\n\n        # r_rec: Frobenius norm of A - Q Lambda Q^T\n        Lambda = np.diag(np.diag(A_diag))\n        reconstruction = Q @ Lambda @ Q.T\n        r_rec = np.linalg.norm(A_orig - reconstruction, 'fro')\n        \n        # r_orth: Frobenius norm of Q^T Q - I\n        identity = np.identity(n, dtype=np.float64)\n        ortho_check = Q.T @ Q - identity\n        r_orth = np.linalg.norm(ortho_check, 'fro')\n        \n        results_all_cases.append([r_off, r_rec, r_orth])\n    \n    # Format and print the final results\n    output_str = \"[\"\n    for i, case_results in enumerate(results_all_cases):\n        res_str = f\"[{case_results[0]:.10e},{case_results[1]:.10e},{case_results[2]:.10e}]\"\n        output_str += res_str\n        if i  len(results_all_cases) - 1:\n            output_str += \",\"\n    output_str += \"]\"\n    \n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了标准的对角化过程后，让我们来挑战一个“逆向工程”问题。给定一个对角矩阵 $\\Lambda$ 和一系列旋转变换，你的任务是重构出原始的密集对称矩阵 $A$ 。这项练习将加深你对谱分解 $A = Q \\Lambda Q^{\\mathsf{T}}$ 的理解，让你从另一个角度审视特征值和特征向量是如何共同构成一个矩阵的。",
            "id": "2405315",
            "problem": "本题给出了用于对称特征问题的经典雅可比方法的一个逆向表述。在正向雅可比过程中，一个实对称矩阵通过一系列正交平面旋转（雅可比旋转）被对角化。在这个逆向问题中，给定一个对角矩阵和一系列指定的雅可比旋转，你必须重构出那个通过正向应用这些旋转而被对角化的稠密对称矩阵。\n\n基本原理：\n- 一个实方阵 $Q$ 是正交的，如果 $Q^{\\mathsf{T}}Q=I$，其中 $I$ 是单位矩阵，${\\mathsf{T}}$ 表示转置。正交相似变换将对称矩阵映射到对称矩阵，并保持特征值不变。\n- 在由索引 $p$ 和 $q$ 的标准基向量张成的坐标平面中的一次雅可比旋转，是一个正交矩阵。该矩阵除了在行和列 $(p,q)$ 上的 $2\\times 2$ 子块外，与单位矩阵完全相同，该子块等于一个角度为 $\\theta$ 的旋转。\n\n本问题的定义和约定：\n- 角度以弧度为单位。\n- 索引 $p$ 和 $q$ 是从零开始的整数，满足 $0\\le pqn$，其中 $n$ 是矩阵的维度。\n- 对于给定的 $n$，基本雅可比旋转 $G(p,q,\\theta)\\in\\mathbb{R}^{n\\times n}$ 定义为单位矩阵，但以下元素除外：\n  $$\n  G_{pp}=\\cos\\theta,\\quad G_{qq}=\\cos\\theta,\\quad G_{pq}=\\sin\\theta,\\quad G_{qp}=-\\sin\\theta,\n  $$\n  并且在行或列 $p$ 和 $q$ 中的所有其他非对角线元素 $G_{ij}=0$。这定义了嵌入在 $\\mathbb{R}^n$ 中的标准平面旋转。\n- 给定一个包含 $k$ 次旋转的序列 $\\{(p_1,q_1,\\theta_1),\\ldots,(p_k,q_k,\\theta_k)\\}$，构造正交矩阵\n  $$\n  Q \\equiv G(p_1,q_1,\\theta_1)\\,G(p_2,q_2,\\theta_2)\\,\\cdots\\,G(p_k,q_k,\\theta_k).\n  $$\n- 设 $\\Lambda=\\mathrm{diag}(\\lambda_0,\\ldots,\\lambda_{n-1})$ 为一个实对角矩阵。你的任务是，仅利用 $\\Lambda$ 和旋转序列，重构出那个在使用给定旋转的正向雅可比过程中被对角化的对称矩阵 $A$。你必须仅使用上述定义和正交相似变换的一般性质，从第一性原理推导出计算 $A$ 的方法。\n\n程序要求：\n- 实现一个程序，对下面的每个测试用例，根据旋转序列构造指定的 $Q$，并按行主序返回重构矩阵 $A$ 的上三角元素，包括对角线。例如，对于 $n=3$，返回列表 $[A_{00},A_{01},A_{02},A_{11},A_{12},A_{22}]$。\n- 为了数值报告，将返回的每个数字四舍五入到 $10^{-6}$，并格式化为小数点后恰好六位数字。\n- 最终输出必须是单行，包含一个列表，该列表拼接了每个测试用例的上三角输出，形式为用方括号括起来的逗号分隔列表，不含空格。\n\n测试套件（角度单位为弧度，索引从零开始）：\n- 测试用例 1（边界情况：空旋转序列）：$n=3$，$\\Lambda=\\mathrm{diag}(1.5,-0.5,2.5)$，旋转序列 $\\varnothing$。\n- 测试用例 2（单次旋转）：$n=3$，$\\Lambda=\\mathrm{diag}(1,2,4)$，旋转序列 $\\{(0,1,\\pi/6)\\}$。\n- 测试用例 3（具有共享索引的多次旋转）：$n=4$，$\\Lambda=\\mathrm{diag}(0.5,1.5,2.5,3.5)$，旋转序列 $\\{(0,2,\\pi/4),(1,3,\\pi/3),(0,1,-\\pi/8)\\}$。\n- 测试用例 4（角度包含零）：$n=3$，$\\Lambda=\\mathrm{diag}(3,1,2)$，旋转序列 $\\{(0,2,0),(0,2,\\pi/2),(1,2,0)\\}$。\n\n你的程序应产生单行输出，包含拼接后的结果，形式为逗号分隔的列表并用方括号括起来（例如，$\\big[$result$1,$result$2,\\ldots\\big]$）。不应打印任何额外文本。",
            "solution": "该问题要求从一个实对称矩阵 $A$ 的对角形式 $\\Lambda$ 和产生此对角化的一系列雅可比旋转来重构矩阵 $A$。这是雅可比特征值算法的逆过程。我们将首先从线性代数的基本原理推导出重构公式，然后开发一个算法来计算它。\n\n谱理论的一个基本结果指出，任何实对称矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 都可以通过正交相似变换进行对角化。也就是说，存在一个正交矩阵 $P \\in \\mathbb{R}^{n \\times n}$ 和一个对角矩阵 $\\Lambda \\in \\mathbb{R}^{n \\times n}$，使得：\n$$ \\Lambda = P^{\\mathsf{T}} A P $$\n在这里，$\\Lambda$ 的对角线元素是 $A$ 的特征值，而 $P$ 的列是相应的标准正交特征向量。这个关系可以被逆转，以根据其特征值和特征向量来表示 $A$。由于 $P$ 是正交的，其转置就是其逆，即 $P^{\\mathsf{T}} = P^{-1}$。通过左乘 $P$ 和右乘 $P^{\\mathsf{T}}$，我们得到：\n$$ P \\Lambda P^{\\mathsf{T}} = P (P^{\\mathsf{T}} A P) P^{\\mathsf{T}} = (P P^{\\mathsf{T}}) A (P P^{\\mathsf{T}}) = I A I = A $$\n因此，重构公式为 $A = P \\Lambda P^{\\mathsf{T}}$。\n\n问题指出，正向雅可比过程使用 $k$ 次基本旋转的序列 $\\{(p_1,q_1,\\theta_1), \\ldots, (p_k,q_k,\\theta_k)\\}$ 来对角化 $A$。一次基本雅可比旋转是由矩阵 $G(p,q,\\theta)$ 表示的正交变换。正向过程将这些旋转作为一系列相似变换来应用。设 $A_0 = A$。该序列为：\n$$ A_1 = G(p_1,q_1,\\theta_1)^{\\mathsf{T}} A_0 G(p_1,q_1,\\theta_1) $$\n$$ A_2 = G(p_2,q_2,\\theta_2)^{\\mathsf{T}} A_1 G(p_2,q_2,\\theta_2) $$\n$$ \\vdots $$\n$$ \\Lambda = A_k = G(p_k,q_k,\\theta_k)^{\\mathsf{T}} A_{k-1} G(p_k,q_k,\\theta_k) $$\n通过递归代入，我们找到 $A$ 和 $\\Lambda$ 之间的关系：\n$$ \\Lambda = \\left(G_k^{\\mathsf{T}} \\cdots G_2^{\\mathsf{T}} G_1^{\\mathsf{T}}\\right) A \\left(G_1 G_2 \\cdots G_k\\right) $$\n其中我们使用简写 $G_i = G(p_i,q_i,\\theta_i)$。利用属性 $(AB)^{\\mathsf{T}} = B^{\\mathsf{T}}A^{\\mathsf{T}}$，上式可简化为：\n$$ \\Lambda = (G_1 G_2 \\cdots G_k)^{\\mathsf{T}} A (G_1 G_2 \\cdots G_k) $$\n问题将总变换矩阵 $Q$ 定义为基本旋转的有序乘积：\n$$ Q \\equiv G_1 G_2 \\cdots G_k $$\n将此定义与 $\\Lambda$ 的表达式进行比较，我们发现标准谱分解中的变换矩阵 $P$ 正好对应于 $Q$。\n$$ \\Lambda = Q^{\\mathsf{T}} A Q $$\n因此，重构 $A$ 的公式是：\n$$ A = Q \\Lambda Q^{\\mathsf{T}} $$\n由于每个 $G_i$ 都是正交矩阵，它们的乘积 $Q$ 也是一个正交矩阵，这验证了此推导的正确性。\n\n解决该问题的算法如下：\n1. 对每个测试用例，给定维度 $n$、特征值列表 $(\\lambda_0, \\ldots, \\lambda_{n-1})$ 以及旋转序列 $\\{(p_1,q_1,\\theta_1), \\ldots, (p_k,q_k,\\theta_k)\\}$。\n2. 构造对角矩阵 $\\Lambda = \\mathrm{diag}(\\lambda_0, \\ldots, \\lambda_{n-1})$。\n3. 构造总旋转矩阵 $Q$。这可以通过首先初始化一个矩阵，然后按指定顺序将其与每个基本雅可比旋转矩阵 $G_i = G(p_i,q_i,\\theta_i)$ 相乘来完成。\n    - 如果旋转序列为空 ($k=0$)，$Q$ 是大小为 $n \\times n$ 的单位矩阵 $I$。\n    - 如果序列不为空，计算 $Q = G_1 G_2 \\cdots G_k$。这可以迭代完成：从 $Q=G_1$ 开始，然后计算 $Q \\leftarrow Q G_2$，依此类推，直到 $Q \\leftarrow Q G_k$。一个基本旋转矩阵 $G(p,q,\\theta)$ 是一个 $n \\times n$ 的单位矩阵，除了四个元素外：\n    $$ G_{pp}=\\cos\\theta, \\quad G_{qq}=\\cos\\theta, \\quad G_{pq}=\\sin\\theta, \\quad G_{qp}=-\\sin\\theta $$\n4. 使用推导出的公式 $A = Q \\Lambda Q^{\\mathsf{T}}$ 计算对称矩阵 $A$。\n5. 按行主序提取 $A$ 的上三角元素，包括主对角线。这些是满足 $0 \\le i \\le j  n$ 的元素 $A_{ij}$。\n6. 将每个提取的元素四舍五入到 $10^{-6}$，并以小数点后恰好六位数字的形式呈现。将所有测试用例的所有结果拼接成一个单一列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the reverse Jacobi rotation problem for a suite of test cases.\n    \"\"\"\n    # Test suite (angles in radians, indices zero-based):\n    # - Case 1: n=3, Lambda=diag(1.5,-0.5,2.5), sequence []\n    # - Case 2: n=3, Lambda=diag(1,2,4), sequence [(0,1,pi/6)]\n    # - Case 3: n=4, Lambda=diag(0.5,1.5,2.5,3.5), sequence [(0,2,pi/4),(1,3,pi/3),(0,1,-pi/8)]\n    # - Case 4: n=3, Lambda=diag(3,1,2), sequence [(0,2,0),(0,2,pi/2),(1,2,0)]\n    test_cases = [\n        {'n': 3, 'lambdas': [1.5, -0.5, 2.5], 'rotations': []},\n        {'n': 3, 'lambdas': [1, 2, 4], 'rotations': [(0, 1, np.pi / 6)]},\n        {'n': 4, 'lambdas': [0.5, 1.5, 2.5, 3.5], 'rotations': [(0, 2, np.pi / 4), (1, 3, np.pi / 3), (0, 1, -np.pi / 8)]},\n        {'n': 3, 'lambdas': [3, 1, 2], 'rotations': [(0, 2, 0), (0, 2, np.pi / 2), (1, 2, 0)]}\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        n = case['n']\n        lambdas = case['lambdas']\n        rotations = case['rotations']\n\n        # Step 1: Construct the diagonal matrix Lambda\n        Lambda_mat = np.diag(lambdas)\n\n        # Step 2: Construct the orthogonal matrix Q from the sequence of rotations\n        if not rotations:\n            Q_mat = np.identity(n)\n        else:\n            # Initialize Q with the first rotation matrix G_1\n            p, q, theta = rotations[0]\n            c, s = np.cos(theta), np.sin(theta)\n            G = np.identity(n)\n            G[p, p], G[q, q] = c, c\n            G[p, q], G[q, p] = s, -s\n            Q_mat = G\n\n            # Accumulate the product Q = G_1 * G_2 * ... * G_k\n            for i in range(1, len(rotations)):\n                p, q, theta = rotations[i]\n                c, s = np.cos(theta), np.sin(theta)\n                G = np.identity(n)\n                G[p, p], G[q, q] = c, c\n                G[p, q], G[q, p] = s, -s\n                Q_mat = Q_mat @ G\n        \n        # Step 3: Reconstruct matrix A using A = Q * Lambda * Q^T\n        A_mat = Q_mat @ Lambda_mat @ Q_mat.T\n\n        # Step 4: Extract the upper-triangular entries in row-major order\n        case_results = []\n        for i in range(n):\n            for j in range(i, n):\n                # Format to 6 decimal places, including trailing zeros\n                formatted_val = f\"{A_mat[i, j]:.6f}\"\n                case_results.append(formatted_val)\n        \n        all_results.extend(case_results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "现在，让我们将雅可比方法应用于一个重要的物理问题：求解一维定态薛定谔方程。通过将空间离散化，我们可以把寻找量子系统能级的微分方程问题，转化为一个矩阵的本征值问题 。这项实践清晰地展示了抽象的数值算法如何成为解决具体物理问题的强大工具，为你连接理论与实际应用架起一座桥梁。",
            "id": "2405321",
            "problem": "给定无量纲形式的一维不含时薛定谔特征值问题\n$$\n\\left(-\\frac{d^2}{dx^2} + V(x)\\right)\\psi(x) = E\\,\\psi(x),\n$$\n该问题定义在闭区间 $[x_{\\min},x_{\\max}]$ 上，边界条件为狄利克雷（Dirichlet）边界条件 $\\psi(x_{\\min})=0$ 和 $\\psi(x_{\\max})=0$，其中，无量纲单位的选择使得 $\\hbar^2/(2m)=1$。你需要计算几种给定势函数 $V(x)$ 下的最低几个特征值 $E$ 的近似值。空间域和采样分辨率由 $[x_{\\min},x_{\\max}]$ 上的一个包含 $N$ 个点的均匀网格指定。每个案例所求的输出是最低的 $k$ 个特征值，以无量纲实数表示。\n\n对于每个测试用例，程序必须：\n- 将 $[x_{\\min},x_{\\max}]$ 解释为空间域。\n- 在 $[x_{\\min},x_{\\max}]$ 上使用一个包含 $N$ 个点的均匀网格。\n- 施加狄利克雷边界条件 $\\psi(x_{\\min})=0$ 和 $\\psi(x_{\\max})=0$。\n- 将下文为每个案例给出的 $V(x)$ 作为势函数。\n- 返回该案例的最低 $k$ 个特征值 $E$（按升序排列），每个值都四舍五入到恰好 $6$ 位小数。\n\n测试套件：\n1. 案例 A（谐振子）：$V(x) = \\tfrac{1}{2}\\,\\omega^2 x^2$，其中 $\\omega=1$。域：$[x_{\\min},x_{\\max}] = [-8,8]$。网格大小：$N=81$。返回最低的 $k=3$ 个特征值。\n2. 案例 B（箱中粒子）：$V(x) = 0$。域：$[x_{\\min},x_{\\max}] = [0,1]$。网格大小：$N=81$。返回最低的 $k=3$ 个特征值。\n3. 案例 C（对称双势阱）：$V(x) = a\\,(x^2-b^2)^2$，其中 $a=25$ 且 $b=1$。域：$[x_{\\min},x_{\\max}] = [-2,2]$。网格大小：$N=81$。返回最低的 $k=2$ 个特征值。\n4. 案例 D（谐振子，粗糙网格）：$V(x) = \\tfrac{1}{2}\\,\\omega^2 x^2$，其中 $\\omega=0.5$。域：$[x_{\\min},x_{\\max}] = [-6,6]$。网格大小：$N=41$。返回最低的 $k=1$ 个特征值。\n\n最终输出格式：\n你的程序必须生成单行输出，包含一个类似JSON的浮点数列表的列表，不含任何空格。每个内部列表按 A、B、C、D 的顺序对应一个测试用例，并包含该案例的 $k$ 个特征值，每个值都四舍五入到恰好 $6$ 位小数。例如，格式必须严格如下：\n$[\\,[e_{A,1},e_{A,2},e_{A,3}],\\,[e_{B,1},e_{B,2},e_{B,3}],\\,[e_{C,1},e_{C,2}],\\,[e_{D,1}]\\,]$\n但使用数值，且不含任何空格，例如：\n$[[0.123456,0.234567,0.345678],[...],[...],[...]]$.\n\n所有返回的值都是无量纲的；不报告任何物理单位。问题不涉及角度，因此不需要角度单位。程序必须是自包含的，并且不需要用户输入。",
            "solution": "该问题要求计算一维不含时薛定谔方程的最低几个特征值，方程如下：\n$$\n\\hat{H}\\psi(x) = \\left(-\\frac{d^2}{dx^2} + V(x)\\right)\\psi(x) = E\\,\\psi(x)\n$$\n对于几种不同的势函数 $V(x)$，该方程定义在有限域 $[x_{\\min}, x_{\\max}]$上，并满足狄利克雷边界条件 $\\psi(x_{\\min})=0$ 和 $\\psi(x_{\\max})=0$。所给方程的形式意味着在一个单位制中 $\\hbar^2/(2m)=1$。\n\n为了数值求解此特征值问题，我们采用有限差分法。连续空间域 $[x_{\\min}, x_{\\max}]$ 被离散化为一个包含 $N$ 个点的均匀网格，记为 $x_i = x_{\\min} + i \\cdot \\Delta x$，其中 $i = 0, 1, \\dots, N-1$。网格间距为 $\\Delta x = (x_{\\max} - x_{\\min})/(N-1)$。连续波函数 $\\psi(x)$ 由其在这些网格点上的值 $\\psi_i = \\psi(x_i)$ 来近似。\n\n狄利克雷边界条件规定了 $\\psi_0 = \\psi(x_0) = 0$ 和 $\\psi_{N-1} = \\psi(x_{N-1}) = 0$。这使得波函数剩下 $M=N-2$ 个未知值，对应于内部点 $x_1, \\dots, x_{N-2}$。\n\n二阶导数算符 $d^2/dx^2$ 在每个内部网格点 $x_i$ 处使用二阶中心差分公式进行近似：\n$$\n\\frac{d^2\\psi}{dx^2}\\bigg|_{x=x_i} \\approx \\frac{\\psi(x_{i+1}) - 2\\psi(x_i) + \\psi(x_{i-1})}{(\\Delta x)^2} = \\frac{\\psi_{i+1} - 2\\psi_i + \\psi_{i-1}}{(\\Delta x)^2}\n$$\n将此近似代入内部点 $x_i$ 的薛定谔方程，得到一个线性代数方程组：\n$$\n-\\frac{\\psi_{i+1} - 2\\psi_i + \\psi_{i-1}}{(\\Delta x)^2} + V(x_i)\\psi_i = E \\psi_i\n$$\n对于每个 $i \\in \\{1, 2, \\dots, M\\}$，该方程可以重新排列为：\n$$\n-\\frac{1}{(\\Delta x)^2}\\psi_{i-1} + \\left(\\frac{2}{(\\Delta x)^2} + V(x_i)\\right)\\psi_i - \\frac{1}{(\\Delta x)^2}\\psi_{i+1} = E \\psi_i\n$$\n这个包含 $M$ 个方程的方程组可以写成一个矩阵特征值问题 $\\mathbf{H}\\vec{\\psi} = E\\vec{\\psi}$，其中 $\\vec{\\psi} = (\\psi_1, \\psi_2, \\dots, \\psi_M)^T$ 是波函数在内部点上的值构成的向量，而 $\\mathbf{H}$ 是一个代表离散化哈密顿算符的 $M \\times M$ 矩阵。\n\n矩阵 $\\mathbf{H}$ 是实对称三对角矩阵。其元素由下式给出：\n$$\nH_{ij} = \\begin{cases} \\frac{2}{(\\Delta x)^2} + V(x_i)  \\text{if } i=j \\\\ -\\frac{1}{(\\Delta x)^2}  \\text{if } |i-j|=1 \\\\ 0  \\text{otherwise} \\end{cases}\n$$\n此处，索引 $i$ 和 $j$ 的取值范围是从 $1$ 到 $M=N-2$。势函数 $V(x_i)$ 在内部网格点上取值。\n\n寻找能量特征值 $E$ 的问题被转化为了寻找矩阵 $\\mathbf{H}$ 的特征值的问题。由于 $\\mathbf{H}$ 是一个实对称矩阵，其特征值均为实数，这与能量特征值必须是实数的物理要求相符。我们使用标准的数值线性代数库，例如 NumPy 的 `linalg.eigh` 函数，来高效地计算这些特征值。该函数专为厄米（或实对称）矩阵设计，并返回按升序排列的特征值。\n\n对于每个测试用例，我们根据给定的势函数 $V(x)$、域 $[x_{\\min}, x_{\\max}]$ 和网格大小 $N$ 来构建相应的哈密顿矩阵 $\\mathbf{H}$。然后我们计算其特征值，并按要求选出最低的 $k$ 个值，将它们四舍五入到指定的精度。这个过程为量子系统的低能级提供了精确的数值近似。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D time-independent Schrödinger equation for a set of test cases\n    using the finite difference method.\n    \"\"\"\n\n    def solve_case(V_func, domain, N, k):\n        \"\"\"\n        Solves the 1D Schrödinger equation for a single given potential.\n        \n        Args:\n            V_func (callable): The potential function V(x).\n            domain (list or tuple): The spatial domain [xmin, xmax].\n            N (int): The number of grid points.\n            k (int): The number of lowest eigenvalues to return.\n            \n        Returns:\n            list: The lowest k eigenvalues, rounded to 6 decimal places.\n        \"\"\"\n        xmin, xmax = domain\n        \n        # Grid spacing\n        dx = (xmax - xmin) / (N - 1)\n        \n        # The number of interior points defines the matrix size\n        M = N - 2\n        \n        # Discretize the domain for interior points\n        x_interior = np.linspace(xmin + dx, xmax - dx, num=M, dtype=float)\n        \n        # Evaluate the potential at interior points\n        V_interior = V_func(x_interior)\n        \n        # Construct the Hamiltonian matrix H\n        # The kinetic energy part contributes to the main and off-diagonals.\n        # Main diagonal elements\n        diag = (2.0 / (dx**2)) + V_interior\n        \n        # Off-diagonal elements (constant for a uniform grid)\n        offdiag_val = -1.0 / (dx**2)\n        offdiag = np.full(M - 1, offdiag_val)\n        \n        # Create the tridiagonal matrix\n        H_matrix = np.diag(diag) + np.diag(offdiag, k=1) + np.diag(offdiag, k=-1)\n        \n        # Find eigenvalues. numpy.linalg.eigh is efficient for Hermitian (real symmetric)\n        # matrices and returns sorted eigenvalues and corresponding eigenvectors.\n        # We only need the eigenvalues, which are the first element of the returned tuple.\n        eigenvalues = np.linalg.eigh(H_matrix)[0]\n        \n        # Select the lowest k eigenvalues\n        lowest_k_eigenvalues = eigenvalues[:k]\n        \n        # Round the results to the specified precision\n        return [round(e, 6) for e in lowest_k_eigenvalues]\n\n    # Definition of the test suite as per the problem statement\n    test_cases = [\n        # Case A: Harmonic oscillator, V(x) = 0.5 * omega^2 * x^2, omega=1\n        {\n            \"V_func\": lambda x: 0.5 * (1.0**2) * x**2,\n            \"domain\": [-8.0, 8.0],\n            \"N\": 81,\n            \"k\": 3\n        },\n        # Case B: Particle in a box, V(x) = 0\n        {\n            \"V_func\": lambda x: np.zeros_like(x),\n            \"domain\": [0.0, 1.0],\n            \"N\": 81,\n            \"k\": 3\n        },\n        # Case C: Symmetric double well, V(x) = a * (x^2 - b^2)^2, a=25, b=1\n        {\n            \"V_func\": lambda x, a=25.0, b=1.0: a * (x**2 - b**2)**2,\n            \"domain\": [-2.0, 2.0],\n            \"N\": 81,\n            \"k\": 2\n        },\n        # Case D: Harmonic oscillator, coarse grid, V(x) = 0.5 * omega^2 * x^2, omega=0.5\n        {\n            \"V_func\": lambda x: 0.5 * (0.5**2) * x**2,\n            \"domain\": [-6.0, 6.0],\n            \"N\": 41,\n            \"k\": 1\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result = solve_case(case[\"V_func\"], case[\"domain\"], case[\"N\"], case[\"k\"])\n        all_results.append(result)\n\n    # Format the final output string into a JSON-like list of lists with no spaces\n    # Example: [[valA1,valA2],[valB1],[valC1,valC2,valC3]]\n    output_str = '[' + ','.join(['[' + ','.join(map(str, res)) + ']' for res in all_results]) + ']'\n    \n    print(output_str)\n\nsolve()\n```"
        }
    ]
}