{
    "hands_on_practices": [
        {
            "introduction": "在计算物理中，一个基本问题是如何从有瑕疵的随机源中提取出高质量的随机性。即使我们的物理随机源是有偏的（例如，一枚不均匀的硬币），我们仍然可以生成完全无偏的随机比特流。这项实践将指导你实现经典的冯·诺伊曼技巧 (von Neumann trick)，这是一个理论洞见解决实际问题的绝佳范例，然后你将亲手验证其输出序列的随机性质量 。",
            "id": "2442648",
            "problem": "给定一个无穷的独立同分布硬币投掷序列，每次投掷结果为正面的概率为 $p$，为反面的概率为 $1 - p$。将正面表示为 $1$，反面表示为 $0$。定义 von Neumann 提取器如下：将原始投掷序列划分为不相交的连续对，并根据以下规则映射每一对：\n- $(1, 0) \\mapsto 1$，\n- $(0, 1) \\mapsto 0$，\n- $(0, 0)$ 和 $(1, 1)$ 不产生输出，\n继续此过程，直到恰好产生 $N$ 个输出比特。\n\n仅使用原始投掷序列独立性的假设，从有偏源生成长度为 $N$ 的 von Neumann 提取输出序列，并使用以下三种测试评估所得输出的统计质量，每种测试都产生一个双边 $p$-值：\n1. 频率（单比特）测试：如果 $N$ 个输出比特中有 $k$ 个为 $1$，则在零假设 $H_0\\!:\\, \\Pr(1)=0.5$ 下，计算精确的双边二项式 $p$-值。\n2. 非重叠相邻对比特的串行测试：使用输出的前 $2 \\lfloor N/2 \\rfloor$ 个比特，形成 $\\lfloor N/2 \\rfloor$ 个非重叠对，并统计 $(0,0)$、$(0,1)$、$(1,0)$、$(1,1)$ 的出现次数。在独立公平比特的零假设下，每种对比特出现的预期比例为 $1/4$。计算具有 $3$ 个自由度的卡方拟合优度 $p$-值。\n3. 二进制序列独立性游程检验，其中 $\\Pr(1)=\\Pr(0)=1/2$：设 $n_1$ 和 $n_0$ 分别表示 $N$ 个输出比特中 1 和 0 的计数，而 $R$ 为相同比特组成的游程总数。在 $n_1$ 和 $n_0$ 固定的独立性零假设下，使用均值\n$$\\mu_R \\,=\\, 1 \\,+\\, \\frac{2 n_1 n_0}{N}$$\n和方差\n$$\\sigma_R^2 \\,=\\, \\frac{2 n_1 n_0 \\left(2 n_1 n_0 - N\\right)}{N^2 (N-1)}$$\n来构建正态近似统计量\n$$Z \\,=\\, \\frac{R - \\mu_R}{\\sigma_R},$$\n并计算相应的双边 $p$-值。\n\n为保证可复现性，对于产生原始有偏投掷序列的伪随机数生成器，请使用固定的整数种子 $s$。对于测试用例索引 $i$（从 $0$ 开始），使用种子 $s + i$。\n\n测试套件。对于下面的每个参数对 $(p, N)$，生成 von Neumann 提取的输出，并计算上述三个 $p$-值：\n- 用例 $0$：$(p, N) = (0.30, 8000)$，\n- 用例 $1$：$(p, N) = (0.49, 12000)$，\n- 用例 $2$：$(p, N) = (0.90, 6000)$，\n- 用例 $3$：$(p, N) = (0.50, 10000)$，\n基础种子 $s = 20240913$。\n\n最终输出格式。您的程序应产生单行输出，其中包含一个方括号括起来的、由四个项目组成的逗号分隔列表。每个项目对应一个测试用例，其本身是一个包含三个十进制数的列表，这三个数分别为频率测试 $p$-值、串行测试 $p$-值和游程检验 $p$-值，每个值都四舍五入到六位小数。例如，整体格式必须为\n$[[p_{0,1},p_{0,2},p_{0,3}],[p_{1,1},p_{1,2},p_{1,3}],[p_{2,1},p_{2,2},p_{2,3}],[p_{3,1},p_{3,2},p_{3,3}]]$,\n其中 $p_{i,j}$ 表示第 $i$ 个用例的第 $j$ 个测试的 $p$-值。不应打印任何额外文本。",
            "solution": "问题陈述经评估有效。它具有科学依据，定义明确且客观。该任务是计算统计学中的一个标准练习，具体涉及通过一种公认的随机性提取技术生成的随机数的质量评估。所有参数、方法和检验统计量都得到了清晰且正确的定义。\n\n解决方案分三个阶段展开：首先，使用 von Neumann 提取器生成一个去偏的二进制序列；其次，对该序列应用三种不同的统计检验；第三，为指定的测试用例实现此过程。\n\n**1. Von Neumann 提取器**\n\n此问题的基础是 von Neumann 随机性提取器。它接受一个独立同分布 (i.i.d.) 的有偏比特序列 $X_i$，其中 1 的概率为 $\\Pr(X_i=1)=p$，0 的概率为 $\\Pr(X_i=0)=1-p$，且 $p \\in (0,1)$。该提取器通过提取不重叠的比特对 $(X_{2j-1}, X_{2j})$ 来处理输入流。\n\n操作规则如下：\n-   如果比特对是 $(1,0)$，则输出一个 $1$。\n-   如果比特对是 $(0,1)$，则输出一个 $0$。\n-   如果比特对是 $(0,0)$ 或 $(1,1)$，则不产生输出并处理下一对。\n\n该方法有效性的理论依据基于简单的概率论。生成输出的比特对的概率为 $\\Pr(1,0) = p(1-p)$ 和 $\\Pr(0,1) = (1-p)p$。这两个概率是相等的。一对被丢弃的概率为 $\\Pr(0,0) + \\Pr(1,1) = (1-p)^2 + p^2$。\n\n在生成一个输出比特的条件下，产生一个 $1$ 的条件概率是：\n$$ \\Pr(\\text{output}=1 | \\text{output is generated}) = \\frac{\\Pr(1,0)}{\\Pr(1,0) + \\Pr(0,1)} = \\frac{p(1-p)}{p(1-p) + (1-p)p} = \\frac{1}{2} $$\n同样，产生一个 $0$ 的条件概率也是 $1/2$。因此，输出序列是完全无偏的。此外，由于输入比特是独立同分布的，不重叠的比特对也是独立的，这确保了最终的输出比特彼此之间也是独立的。因此，该过程将一个有偏的独立同分布源转换为了一个无偏的独立同分布源，它应该能通过随机性的统计检验。\n\n该模拟通过创建一个带有偏差 $p$ 的伪随机比特流，按照规则成对处理它们，并收集输出，直到形成所需长度 $N$ 的序列，来生成这些输出比特。为保证可复现性，对于测试用例索引 $i$，伪随机数生成器使用种子 $s+i$ 进行播种，其中基础种子为 $s=20240913$。\n\n**2. 统计质量评估**\n\n生成的 $N$-比特序列的质量通过三种标准的统计检验进行评估。每种检验都评估一个与理想随机性相关的特定零假设 ($H_0$)，并得出一个 $p$-值。$p$-值表示在假设 $H_0$ 为真的情况下，观测到至少与实测结果一样极端的结果的概率。\n\n**2.1. 频率（单比特）测试**\n此测试检验无偏二进制序列最基本的属性：平均而言，0 和 1 的数量相等。\n-   $H_0$：1 的概率为 $1/2$。\n-   设 $k$ 是 $N$-比特序列中 1 的数量。在 $H_0$ 下，$k$ 服从二项分布 $B(N, 0.5)$。\n-   双边 $p$-值是观测到 1 的计数与期望均值 $N/2$ 的偏离程度等于或大于 $k$ 的偏离程度的概率。这是使用精确的二项概率质量函数计算的。\n\n**2.2. 比特对串行测试**\n此测试通过检查相邻比特是否独立来检验短期相关性。\n-   $H_0$：比特是独立且公平的。这意味着四种可能的非重叠对比特——$(0,0)$、$(0,1)$、$(1,0)$、$(1,1)$——应以相等的概率 $1/4$ 出现。\n-   前 $2 \\lfloor N/2 \\rfloor$ 个比特被构造成 $M = \\lfloor N/2 \\rfloor$ 个比特对。统计每种比特对类型（$c_{00}, c_{01}, c_{10}, c_{11}$）的出现次数。\n-   执行卡方（$\\chi^2$）拟合优度检验，以比较观测到的计数与每种比特对的期望计数 $M/4$。$\\chi^2$ 统计量为：\n$$ \\chi^2 = \\sum_{ij \\in \\{00,01,10,11\\}} \\frac{(c_{ij} - M/4)^2}{M/4} $$\n-   将此统计量与自由度为 $4-1=3$ 的 $\\chi^2$ 分布进行比较，以获得 $p$-值。\n\n**2.3. 游程检验**\n此测试通过分析序列中的“游程”数量来检验独立性，其中游程是相同值的最大连续子序列。游程数量异常可能表示聚类（游程太少）或快速振荡（游程太多）。\n-   $H_0$：序列是独立的，其中 1 的计数 ($n_1$) 和 0 的计数 ($n_0$) 是固定的。\n-   设 $R$ 是观测到的游程总数。对于大的 $N$，$R$ 的分布可以用具有指定均值 $\\mu_R = 1 + \\frac{2 n_1 n_0}{N}$ 和方差 $\\sigma_R^2 = \\frac{2 n_1 n_0 (2 n_1 n_0 - N)}{N^2 (N-1)}$ 的正态分布来近似。\n-   计算检验统计量 $Z = (R - \\mu_R) / \\sigma_R$。\n-   双边 $p$-值由标准正态分布导出，为 $2 \\times \\Phi(-|Z|)$，其中 $\\Phi$ 是标准正态累积分布函数。\n\n这三个测试的实现将为每个测试用例产生三个 $p$-值，然后按要求进行格式化。",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import binomtest, chisquare, norm\n\ndef generate_von_neumann_sequence(p, N, seed):\n    \"\"\"\n    Generates a sequence of N unbiased bits from a biased source using the\n    von Neumann extractor.\n\n    Args:\n        p (float): The probability of '1' in the source sequence.\n        N (int): The desired length of the output sequence.\n        seed (int): The seed for the random number generator.\n\n    Returns:\n        np.ndarray: A numpy array of length N containing the unbiased bits.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    output_list = []\n    \n    # Heuristic for chunk size to generate raw bits.\n    # A larger chunk is more efficient than many small ones.\n    # 20000 raw bits = 10000 pairs.\n    chunk_size = 20000\n\n    while len(output_list)  N:\n        # Generate a chunk of biased bits (True for 1, False for 0).\n        raw_bits = rng.random(size=chunk_size)  p\n        \n        for i in range(0, chunk_size, 2):\n            b1, b2 = raw_bits[i], raw_bits[i+1]\n            \n            # Check for (1,0) or (0,1) pairs.\n            if b1 != b2:\n                # Map (1,0) to 1 and (0,1) to 0.\n                output_list.append(1 if b1 else 0)\n                if len(output_list) == N:\n                    break\n    \n    return np.array(output_list, dtype=np.int8)\n\ndef frequency_test(sequence):\n    \"\"\"\n    Performs the frequency (monobit) test.\n    \n    Args:\n        sequence (np.ndarray): The binary sequence to test.\n        \n    Returns:\n        float: The two-sided p-value.\n    \"\"\"\n    N = len(sequence)\n    if N == 0:\n        return 1.0\n    k = np.sum(sequence)\n    # The binomtest function computes the exact two-sided binomial test p-value.\n    result = binomtest(k, n=N, p=0.5, alternative='two-sided')\n    return result.pvalue\n\ndef serial_test(sequence):\n    \"\"\"\n    Performs the serial test on non-overlapping adjacent pairs.\n    \n    Args:\n        sequence (np.ndarray): The binary sequence to test.\n        \n    Returns:\n        float: The chi-squared p-value.\n    \"\"\"\n    N = len(sequence)\n    M = N // 2\n    if M == 0:\n        return 1.0 # Not enough data for pairs.\n\n    # Form non-overlapping pairs from the first 2*M bits.\n    seq_pairs = sequence[:2*M].reshape(M, 2)\n    \n    # A mapping to count pairs: (0,0)-0, (0,1)-1, (1,0)-2, (1,1)-3\n    pair_values = 2 * seq_pairs[:, 0] + seq_pairs[:, 1]\n    observed_counts = np.bincount(pair_values, minlength=4)\n    \n    # Under H0, expected count for each pair is M/4.\n    expected_count = M / 4.0\n    \n    if expected_count == 0:\n        return 1.0\n        \n    # The chisquare test compares observed vs expected frequencies.\n    # Degrees of freedom is k-1 = 4-1 = 3 by default.\n    _, p_value = chisquare(f_obs=observed_counts, f_exp=[expected_count]*4)\n    return p_value\n\ndef runs_test(sequence):\n    \"\"\"\n    Performs the runs test for independence.\n    \n    Args:\n        sequence (np.ndarray): The binary sequence to test.\n        \n    Returns:\n        float: The normal approximation p-value.\n    \"\"\"\n    N = len(sequence)\n    n1 = np.sum(sequence)\n    n0 = N - n1\n\n    # If the sequence is monolithic, the test is not applicable.\n    # This implies extreme non-randomness. p-value should be 0.\n    if n1 == 0 or n0 == 0:\n        return 0.0\n\n    # Count the number of runs R.\n    R = np.sum(sequence[:-1] != sequence[1:]) + 1\n    \n    # Calculate mean and variance under the null hypothesis.\n    mu_R = 1 + (2.0 * n1 * n0) / N\n    \n    numerator_sigma2 = 2.0 * n1 * n0 * (2.0 * n1 * n0 - N)\n    denominator_sigma2 = float(N**2) * (N - 1)\n    \n    # Variance can be non-positive only in extreme cases not expected here.\n    if denominator_sigma2 == 0 or numerator_sigma2 = 0:\n        return 0.0\n        \n    sigma2_R = numerator_sigma2 / denominator_sigma2\n    sigma_R = np.sqrt(sigma2_R)\n    \n    # Calculate Z-score and two-sided p-value from standard normal distribution.\n    Z = (R - mu_R) / sigma_R\n    p_value = 2 * norm.sf(abs(Z)) # sf is the survival function, 1-cdf\n    \n    return p_value\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        (0.30, 8000),\n        (0.49, 12000),\n        (0.90, 6000),\n        (0.50, 10000),\n    ]\n    base_seed = 20240913\n\n    all_results = []\n    for i, (p, N) in enumerate(test_cases):\n        seed = base_seed + i\n        \n        # 1. Generate the sequence\n        sequence = generate_von_neumann_sequence(p, N, seed)\n        \n        # 2. Run the statistical tests\n        p_freq = frequency_test(sequence)\n        p_serial = serial_test(sequence)\n        p_runs = runs_test(sequence)\n        \n        all_results.append([p_freq, p_serial, p_runs])\n\n    # 3. Format the output as specified\n    formatted_cases = []\n    for pvals in all_results:\n        formatted_pvals = [f\"{p:.6f}\" for p in pvals]\n        formatted_cases.append(f'[{\",\".join(formatted_pvals)}]')\n    \n    print(f'[{\",\".join(formatted_cases)}]')\n\nsolve()\n```"
        },
        {
            "introduction": "一个常见的陷阱是，认为一个通过了基本统计检验的随机数生成器就足以胜任任何应用。这项实践是一个强有力的反例 。你将构建一个在一维上看起来完美，但在一个简单的二维蒙特卡洛模拟中却会灾难性失败的生成器，从而凸显出检验多维相关性的至关重要性。这个练习揭示了为什么仅仅依赖一维测试（如卡方检验或KS检验）可能具有误导性，以及为什么对多维应用的生成器必须进行多维评估。",
            "id": "2442681",
            "problem": "您需要构建并分析一个确定性伪随机数生成器 (PRNG)，对于每个给定的种子，该生成器会产生一个位于开区间 $(0,1)$ 内的有限实数序列。这个序列需要通过指定的统计检验集，同时在一个简单的蒙特卡洛 (MC) 物理模拟中产生系统性错误的结果。您编写的程序必须实现该生成器，应用这些检验，运行模拟，并为每个测试用例报告一个布尔值结果。所有定义和阈值如下所述。\n\n一个种子为 $s$ 的 PRNG 产生一个序列 $\\{x_n\\}_{n=1}^N$，其中每个 $x_n \\in (0,1)$。对于一个固定的种子 $s$，在序列是独立同分布 (i.i.d.) 且共同分布为 $\\mathrm{Uniform}(0,1)$ 的零假设 $\\mathcal{H}_0$ 下，定义三个假设检验：\n\n- 单样本 Kolmogorov–Smirnov (KS) 检验：设 $F_N(x)$ 表示序列 $\\{x_n\\}_{n=1}^N$ 的经验分布函数， $F(x)=x$ 表示 $\\mathrm{Uniform}(0,1)$ 的累积分布函数。定义 KS 统计量 $D_N=\\sup_{x\\in[0,1]} \\left| F_N(x) - F(x) \\right|$。相关的 $p$ 值在 $\\mathcal{H}_0$ 下计算。\n\n- 等宽区间卡方检验：将 $(0,1)$ 划分为 $B$ 个等宽的区间。设 $O_j$ 为区间 $j$ 的观测频数（$j=1,\\dots,B$），并设 $E_j=N/B$ 为在 $\\mathcal{H}_0$ 下的期望频数。卡方统计量为 $\\chi^2=\\sum_{j=1}^B \\frac{(O_j-E_j)^2}{E_j}$。相关的 $p$ 值在 $\\mathcal{H}_0$ 下，根据自由度为 $B-1$ 的卡方分布计算。\n\n- 样本均值检验：设 $\\bar{X}=\\frac{1}{N}\\sum_{n=1}^N x_n$。在 $\\mathcal{H}_0$ 下，根据中心极限定理，$Z=\\sqrt{12N}\\,(\\bar{X}-\\tfrac{1}{2})$ 近似服从标准正态分布。双边 $p$ 值从标准正态分布计算。\n\n定义一个通过标准阈值 $\\varepsilon$，其中 $0  \\varepsilon  \\frac{1}{2}$。如果且仅当所有三个 $p$ 值都严格位于开区间 $(\\varepsilon,1-\\varepsilon)$ 内，我们称统计检验集通过。\n\n独立于上述检验，通过在单位正方形上使用经典的投镖法，定义一个受物理学启发的 $\\pi$ 的 MC 估计量。使用相同的 PRNG 和相同的种子 $s$，从一个流 $(x_1,x_2,\\dots)$ 中构造 $M$ 个连续数对 $(x_{2k-1},x_{2k})$，其中 $k=1,\\dots,M$。定义\n$$\n\\widehat{\\pi} = 4\\, \\frac{1}{M}\\sum_{k=1}^M \\mathbf{1}\\!\\left\\{ x_{2k-1}^2 + x_{2k}^2 \\le 1 \\right\\},\n$$\n其中 $\\mathbf{1}\\{\\cdot\\}$ 是指示函数。给定一个绝对误差容限 $\\tau>0$，如果且仅当 $|\\widehat{\\pi} - \\pi| > \\tau$，则声明 MC 模拟失败。所有涉及的角度均通过 $\\pi$ 隐式地表示为弧度；程序不计算任何具体的角度值。\n\n您的程序必须实现您自行设计的单个确定性 PRNG，并在以下测试套件上对其进行评估。对于每个测试用例，程序必须计算一个布尔值，该值为真的条件是当且仅当 PRNG 通过了统计检验集并且 MC 模拟失败，否则为假。\n\n测试套件包含以下参数集 $(s, N, B, M, \\varepsilon, \\tau)$:\n\n- 用例 1: $(s, N, B, M, \\varepsilon, \\tau) = (123456789, 100000, 100, 50000, 10^{-9}, 10^{-2})$。\n- 用例 2: $(s, N, B, M, \\varepsilon, \\tau) = (0, 50000, 50, 20000, 10^{-9}, 10^{-2})$。\n- 用例 3: $(s, N, B, M, \\varepsilon, \\tau) = (987654321098765432, 120000, 200, 60000, 10^{-9}, 10^{-2})$。\n\n您的程序应产生单行输出，其中包含上述用例的三个布尔结果，形式为用方括号括起来的逗号分隔列表（例如，`[True,False,True]`）。不应产生其他任何输出。所有报告的值都是无单位的；输出中不需要物理单位。所有内部计算必须是确定性的，且不需要用户输入。",
            "solution": "所述问题是有效的。这是一个定义明确且具有科学依据的计算物理学练习，它探讨了伪随机数序列一维和多维属性之间的关键区别。一套简单的一维统计检验不足以证明一个生成器可用于如蒙特卡洛模拟等多维应用。我们将构建一个在二维上被刻意设计为有缺陷，但其一维边际分布保持均匀的生成器，从而满足所述标准。\n\n问题的核心是设计一个确定性伪随机数生成器 (PRNG)，对于给定的种子 $s$，它能生成一个序列 $\\{x_n\\}$，该序列同时满足：\n1.  通过包含三个检验（Kolmogorov-Smirnov、卡方、样本均值）的统计检验集，即每个检验的 $p$ 值都落在区间 $(\\varepsilon, 1-\\varepsilon)$ 内。\n2.  在 $\\pi$ 的蒙特卡洛 (MC) 估计中失败，即估计值 $\\widehat{\\pi}$ 与真实值 $\\pi$ 的差异超过容限 $\\tau$。\n\n我们将构建一个 PRNG，其相邻数字之间具有特定的、致命的相关性。让一个高质量的、密码学安全的 PRNG，例如 `numpy` 库提供的 PCG64 生成器，作为基础随机源。让这个基础生成器使用给定的整数种子 $s$ 进行播种，以产生一个来自 $\\mathrm{Uniform}(0,1)$ 分布的 i.i.d. 值序列 $\\{u_k\\}$。\n\n我们有缺陷的 PRNG 将通过构造数对来构建目标序列 $\\{x_n\\}$：\n$$ x_{2k-1} = u_k $$\n$$ x_{2k} = 1 - u_k $$\n对于 $k = 1, 2, 3, \\dots$。\n\n我们来分析这个序列 $\\{x_n\\}$ 的属性。\n\n首先，考虑一维统计属性。序列 $\\{x_n\\}$ 是两个序列 $\\{u_k\\}$ 和 $\\{1-u_k\\}$ 的混合。如果 $u_k \\sim \\mathrm{Uniform}(0,1)$，那么根据概率论的一个基本结论，变换后的变量 $1-u_k$ 也服从 $\\mathrm{Uniform}(0,1)$ 分布。因此，组合序列 $\\{x_n\\}$ 的边际累积分布函数是均匀分布 CDF 与自身的等权重平均，这结果就是均匀分布 CDF 本身。因此，$\\{x_n\\}$ 的边际分布是 $\\mathrm{Uniform}(0,1)$。所以，对于任何一维检验来说，它都预期表现出均匀性。\n- **Kolmogorov-Smirnov 检验**将 $\\{x_n\\}_{n=1}^N$ 的经验 CDF 与均匀分布 CDF $F(x)=x$ 进行比较。由于边际分布是均匀的，经验 CDF 将收敛于真实的 CDF，因此该检验预期会以高 $p$ 值通过。\n- **卡方检验**检验落入 $B$ 个区间内的数字的频率。均匀的边际分布意味着频数应该是均匀分布的，所以这个检验也预期会通过。\n- **样本均值检验**依赖于序列的均值。其期望值为 $E[x_n] = \\frac{1}{2} E[u_k] + \\frac{1}{2} E[1-u_k] = \\frac{1}{2}(\\frac{1}{2}) + \\frac{1}{2}(1-\\frac{1}{2}) = \\frac{1}{2}$。样本均值 $\\bar{X}$ 将收敛于 $\\frac{1}{2}$，而检验统计量 $Z=\\sqrt{12N}\\,(\\bar{X}-\\tfrac{1}{2})$ 将接近 0，从而得到一个接近 1 的 $p$ 值。\n鉴于 $\\varepsilon=10^{-9}$ 这个极其宽松的通过-失败阈值，几乎可以肯定所有三个统计检验都将通过。\n\n其次，考虑二维蒙特卡洛模拟。该方法通过在单位正方形中抽样点 $(x,y)$ 并找出落在单位圆内的点的比例来估计 $\\pi$。我们的生成器产生数对 $(x_{2k-1}, x_{2k}) = (u_k, 1-u_k)$。这些点并非均匀分布在单位正方形中；它们全都完美地落在 $x \\in (0,1)$ 的线段 $y=1-x$ 上。这是二维均匀性的灾难性失败。\n\nMC 估计量是 $\\widehat{\\pi} = 4\\, \\frac{1}{M}\\sum_{k=1}^M \\mathbf{1}\\!\\left\\{ x_{2k-1}^2 + x_{2k}^2 \\le 1 \\right\\}$。代入我们的相关数对，指示函数内部的条件变为：\n$$ u_k^2 + (1-u_k)^2 \\le 1 $$\n展开表达式得到：\n$$ u_k^2 + 1 - 2u_k + u_k^2 \\le 1 $$\n$$ 2u_k^2 - 2u_k \\le 0 $$\n$$ 2u_k(u_k - 1) \\le 0 $$\n由于基础生成器产生 $u_k \\in [0,1)$，项 $u_k$ 是非负的，而项 $(u_k-1)$ 是非正的。因此它们的乘积总是非正的，该不等式恒成立。\n\n生成的每一个数对 $(x_{2k-1}, x_{2k})$ 都将被计为圆内的“命中点”。估计量中的和变为 $\\sum_{k=1}^M 1 = M$。因此，$\\pi$ 的估计量将是：\n$$ \\widehat{\\pi} = 4 \\frac{M}{M} = 4 $$\n如果 $|\\widehat{\\pi} - \\pi| > \\tau$，则 MC 模拟失败。在我们的情况下，这是 $|4 - \\pi| > 10^{-2}$。由于 $\\pi \\approx 3.14159$，绝对误差是 $|4 - \\pi| \\approx 0.8584$，这远大于容限 $\\tau=10^{-2}$。因此，MC 模拟保证会失败。\n\n每个测试用例的最终布尔值结果为真，当且仅当统计检验集通过（正如我们所预期的）并且 MC 模拟失败（这是必然的）。实现将按如下步骤进行：如上所述生成序列，使用 `scipy.stats` 库的函数应用指定的统计检验，并计算 MC 模拟结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import kstest, chisquare, norm\n\ndef solve():\n    \"\"\"\n    Implements a flawed PRNG, evaluates it against a statistical battery and a\n    Monte Carlo simulation, and reports the combined outcome for several test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (s, N, B, M, epsilon, tau)\n        (123456789, 100000, 100, 50000, 1e-9, 1e-2),\n        (0, 50000, 50, 20000, 1e-9, 1e-2),\n        (987654321098765432, 120000, 200, 60000, 1e-9, 1e-2),\n    ]\n\n    results = []\n    for s, N, B, M, epsilon, tau in test_cases:\n        # Step 0: Determine total sequence length required.\n        # Length must be sufficient for both tests and MC simulation, and be even for pairing.\n        L = max(N, 2 * M)\n        if L % 2 != 0:\n            L += 1\n\n        # Step 1: Implement the PRNG with a 2D flaw.\n        # Use numpy's default PRNG (PCG64) as the base generator.\n        rng = np.random.default_rng(s)\n        # Generate L/2 base numbers.\n        base_rands = rng.random(size=L // 2)\n        # Construct the flawed sequence x_n where x_2k = 1 - x_{2k-1}.\n        x_sequence = np.empty(L, dtype=np.float64)\n        x_sequence[0::2] = base_rands\n        x_sequence[1::2] = 1.0 - base_rands\n\n        # Step 2: Perform the statistical battery on the first N numbers.\n        x_for_tests = x_sequence[:N]\n\n        # 2a: One-sample Kolmogorov–Smirnov test.\n        # Test against the standard uniform distribution on (0,1).\n        ks_result = kstest(x_for_tests, 'uniform')\n        p_ks = ks_result.pvalue\n\n        # 2b: Chi-square test for equal-probability bins.\n        observed_counts, _ = np.histogram(x_for_tests, bins=B, range=(0.0, 1.0))\n        # With f_exp not provided, chisquare computes it as sum(f_obs)/len(f_obs),\n        # which is N/B, as required.\n        chi2_result = chisquare(f_obs=observed_counts)\n        p_chi2 = chi2_result.pvalue\n\n        # 2c: Sample mean test.\n        mean_val = np.mean(x_for_tests)\n        z_stat = np.sqrt(12.0 * N) * (mean_val - 0.5)\n        # Two-sided p-value from standard normal survival function.\n        p_mean = 2.0 * norm.sf(np.abs(z_stat))\n\n        # Check if the statistical battery passes.\n        stat_pass = (p_ks > epsilon and p_ks  1.0 - epsilon) and \\\n                    (p_chi2 > epsilon and p_chi2  1.0 - epsilon) and \\\n                    (p_mean > epsilon and p_mean  1.0 - epsilon)\n\n        # Step 3: Perform the Monte Carlo simulation on the first 2M numbers.\n        x_for_mc = x_sequence[:(2 * M)]\n        x_coords = x_for_mc[0::2]\n        y_coords = x_for_mc[1::2]\n\n        # Count \"hits\" inside the unit circle.\n        hits = np.sum(x_coords**2 + y_coords**2 = 1.0)\n        # Calculate pi estimate.\n        pi_estimate = 4.0 * hits / M\n\n        # Check if the MC simulation fails.\n        mc_fail = np.abs(pi_estimate - np.pi) > tau\n\n        # Step 4: Determine the final boolean result for the case.\n        # The result is True iff the battery passes AND the simulation fails.\n        final_result = stat_pass and mc_fail\n        results.append(final_result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "并非所有“随机”数都是生而平等的。伪随机序列旨在模仿真正的随机性，而准随机序列（如 Sobol 序列）则被刻意设计得比真随机更均匀，以加速数值积分等应用的收敛速度。这项练习挑战你设计一个专门的统计检验，用以识别这种“过度均匀性”，这是一个区分这两种序列的微妙但关键的特性 。通过实现一个左尾卡方检验，你将学会如何量化一个点集何时“好得不真实”，并将其与真正的随机样本区分开来。",
            "id": "2442662",
            "problem": "如果一个在$d$维单位超立方体$[0,1)^d$中的点样本与来自$[0,1)^d$上连续均匀分布的独立同分布样本的零假设模型一致，则称该样本对于蒙特卡洛积分是高质量的。考虑这样一种决策规则：它作用于一个包含$n$个点的集合，将其映射到一个布尔输出，该输出指示该集合是否因对于零假设模型而言“过于规则”而被拒绝。您的任务是实现一个测试，在精心选择的参数下，该测试能拒绝像Sobol序列这样的低差异数字网格序列，同时以高概率接受独立同分布的均匀样本。\n\n设 $m \\in \\mathbb{N}$，$d \\in \\mathbb{N}$，并定义 $K = m^d$。通过将每个坐标轴划分为$m$个相等的子区间，将$[0,1)^d$划分为$K$个等体积的轴对齐超立方体。对于一个包含$n$个点的集合 $X = \\{\\mathbf{x}_i\\}_{i=1}^n \\subset [0,1)^d$，定义占有数 $\\{C_j\\}_{j=1}^K$，其中$C_j$是$X$中落入第$j$个子立方体的点的数量。在 $\\mathbf{x}_i$ 是$[0,1)^d$上独立同分布的均匀随机变量这一零假设模型下，向量 $(C_1,\\dots,C_K)$ 服从多项分布 Multinomial$(n; 1/K,\\dots,1/K)$。\n\n定义皮尔逊统计量\n$$\nX^2 \\;=\\; \\sum_{j=1}^{K} \\frac{(C_j - n/K)^2}{n/K}.\n$$\n在零假设模型下，对于较大的$n$和$K$，$X^2$的分布可以由自由度为$K-1$的卡方分布很好地近似。考虑一个固定的显著性水平 $\\alpha \\in (0,1)$，并用$q_{\\alpha}$表示自由度为$K-1$的卡方分布的下$\\alpha$-分位数。在水平$\\alpha$下的一个左尾拒绝规则是：如果 $X^2  q_{\\alpha}$，则拒绝。此外，当$n=K$时，每个子立方体恰好包含一个点（即对所有$j$都有$C_j \\equiv 1$）这一事件，与零假设模型下的典型行为不相容，并且是基数为2的数字$(t,m,d)$-网格的特征（例如，一个$d$维Sobol序列的前$2^m$个点），在这种情况下$X^2$恒等于0。为了使测试对此类低差异网格特别敏感，定义一个复合决策规则：如果 $X^2  q_{\\alpha}$ 或者对所有$j$都有 $C_j \\equiv n/K$，则拒绝。\n\n实现一个程序，该程序在给定一组参数的情况下，构建点集，计算$X^2$，并对每种情况返回一个布尔值，以指示样本是否被上述定义的复合规则所拒绝。为保证可复现性，请使用以下测试套件，其中所有角度均无关，且不涉及任何物理单位。显著性水平必须使用纯小数（而非百分比）。\n\n测试套件：\n- 案例1（$d=2$维的独立同分布均匀样本）：$d=2$, $m=8$, $K=64$, $n=64$, $\\alpha=10^{-6}$，由以$20240527$为种子的伪随机数生成器生成。\n- 案例2（$d=2$维的无置乱Sobol序列）：$d=2$, $m=8$, $K=64$, $n=64$, $\\alpha=10^{-6}$，使用无置乱Sobol序列的前$64$个点。\n- 案例3（$d=2$维的带Owen置乱的Sobol序列）：$d=2$, $m=8$, $K=64$, $n=64$, $\\alpha=10^{-6}$，使用带Owen置乱的Sobol序列的前$64$个点，置乱种子为$123$。\n\n您的程序应生成单行输出，其中包含按上述案例顺序排列、用方括号括起并以逗号分隔的结果列表。每个结果必须是字面布尔值True或False。例如，输出可能看起来像“[False,True,True]”。",
            "solution": "零假设模型假定点 $\\mathbf{x}_i \\in [0,1)^d$ 是根据$[0,1)^d$上的均匀分布进行独立同分布的。如果我们将$[0,1)^d$划分为$K = m^d$个全等的轴对齐子立方体，那么对于一个大小为$n$的样本，其占有向量 $\\mathbf{C} = (C_1,\\dots,C_K)$ 服从多项分布 Multinomial$(n; 1/K,\\dots,1/K)$。从第一性原理出发，这是独立性和同分布的直接结果：每个点落入任意一个子立方体的概率均为$1/K$，且所有子立方体的计数总和为$n$，从而得到多项分布。\n\n为了量化在“过于均匀”占有（这是低差异序列的一个特征）方向上与零假设模型的偏差，我们考虑皮尔逊统计量\n$$\nX^2 \\;=\\; \\sum_{j=1}^{K} \\frac{(C_j - n/K)^2}{n/K}.\n$$\n该统计量以多项分布模型下各单元格计数的期望方差为单位，度量了实际计数值与期望计数值 $n/K$ 之间的偏差。在零假设模型下，且当$n$和$K$足够大时，$X^2$近似服从自由度为$K-1$的卡方分布。这是由多项分布的中心极限定理以及定义皮尔逊统计量的二次型得出的。该卡方分布的均值为$K-1$，方差为$2(K-1)$。\n\n诸如基数为2的Sobol序列等低差异数字网格具有一个定义性属性：对于$d$维空间中的$n=2^m$个点（其中$m$相对于$d$足够大，以至于存在一个具有较小$t$值的$(t,m,d)$-网格），每个体积为$2^{-m}$的二进基本区间都恰好包含$2^t$个点。在$t=0$的特殊情况下（这在许多中等维度下的Sobol构造中成立），并且当划分与二进边界对齐，每个轴被划分为$m$个相等的子区间，使得$K = 2^{md} = n$时，K个单元格中的每一个都恰好包含一个点。由此可得\n$$\nC_j \\equiv 1 \\quad \\text{for all } j \\in \\{1,\\dots,K\\},\n$$\n从中可以推断出\n$$\nX^2 \\;=\\; \\sum_{j=1}^{K} \\frac{(1 - 1)^2}{1} \\;=\\; 0.\n$$\n该值位于卡方分布的极左尾部，并且确实严格小于任何对于$\\alpha \\in (0,1)$的正下分位数$q_{\\alpha}$。因此，一个在$X^2  q_{\\alpha}$时拒绝的左尾测试将会拒绝此类Sobol样本。然而，为了在不依赖渐近近似的情况下保证对精确网格行为的拒绝，我们还加入了一个显式的精确分层拒绝条件：如果$n=K$且所有$C_j$都等于$n/K$，我们拒绝。在零假设模型下，$C_j \\equiv n/K$这一事件的概率为\n$$\n\\mathbb{P}(C_1 = \\cdots = C_K = n/K) \\;=\\; \\frac{n!}{\\prod_{j=1}^K (n/K)!} \\left(\\frac{1}{K}\\right)^n,\n$$\n当$n=K$时，该式简化为\n$$\n\\frac{K!}{K^K},\n$$\n即使对于中等大小的$K$，这个值也是天文数字般地小（例如，当$K=64$时，根据斯特林近似，其数量级约为$\\sqrt{2\\pi K}\\,e^{-K}$）。因此，在任何实际的显著性水平下，添加这个显式拒绝事件都不会实质性地增加检验犯第一类错误的概率，但它确保了对那些在$n=K$时表现出精确“每单元格一个点”占有率的数字网格进行确定性拒绝。\n\n因此，复合决策规则如下：\n- 根据$[0,1)^d$的$m \\times \\cdots \\times m$划分上的占有数计算$X^2$。\n- 设$q_{\\alpha}$为$\\chi^2_{K-1}$分布的下$\\alpha$-分位数。\n- 如果$X^2  q_{\\alpha}$或对所有$j$都有$C_j \\equiv n/K$，则拒绝。\n\n对于给定的测试套件：\n- 案例1：$d=2, m=8$，因此$K=64$且$n=64$。对于一个使用固定种子的独立同分布均匀样本，$X^2$的分布集中在$K-1 = 63$附近。使用$\\alpha = 10^{-6}$，下分位数$q_{\\alpha}$远低于此均值，在零假设模型下，$X^2  q_{\\alpha}$的概率渐近地恰好为$\\alpha$；显式的精确分层事件不会发生。因此，对于一个固定的种子，结果有极大概率是不拒绝。\n- 案例2：$d=2, m=8, K=64, n=64$，无置乱的Sobol序列。该样本是一个与二进划分对齐的基数为2的数字网格，因此$C_j \\equiv 1$且$X^2 = 0$。复合规则会拒绝。\n- 案例3：$d=2, m=8, K=64, n=64$，带Owen置乱的Sobol序列。Owen置乱保留了每个二进单元格恰好包含一个点的网格属性，尽管单元格内的点的位置是随机化的。因此，$C_j \\equiv 1$和$X^2 = 0$仍然成立，复合规则会拒绝。\n\n程序根据规范构建三个点集，计算占有数和皮尔逊统计量，从自由度为$K-1$的卡方分布中获取$q_{\\alpha}$，应用复合决策规则，并按规定顺序打印一个包含三个布尔值的列表的单行。鉴于上述推理以及在$d=2$下，$n=64$和$m=8$的Sobol网格的确定性属性，对于按问题中顺序排列的案例，预期输出为[False,True,True]。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import chi2\nfrom scipy.stats import qmc\n\ndef chi_square_left_tail_with_exact_stratification(points: np.ndarray, m: int, alpha: float) -> bool:\n    \"\"\"\n    Composite test:\n    - Partition [0,1)^d into m^d equal cells.\n    - Compute Pearson chi-square statistic against uniform counts.\n    - Reject if statistic is in the lower alpha tail of chi-square(df=K-1),\n      OR if all cell counts are exactly equal (which is n/K per cell).\n    \"\"\"\n    n, d = points.shape\n    # Number of cells\n    K = m ** d\n\n    # Assign each point to a cell index along each dimension\n    # Ensure indices are in [0, m-1]\n    idx_per_dim = np.floor(points * m).astype(int)\n    # Numerical safety: any point exactly equal to 1.0 gets mapped to m-1\n    np.clip(idx_per_dim, 0, m - 1, out=idx_per_dim)\n\n    # Convert multi-indices to linear indices\n    # Shape (d, n) is expected for ravel_multi_index\n    linear_idx = np.ravel_multi_index(idx_per_dim.T, dims=(m,) * d, mode='clip')\n\n    # Cell counts\n    counts = np.bincount(linear_idx, minlength=K)\n\n    # Expected count per cell\n    expected = n / K\n\n    # Pearson chi-square statistic\n    # Avoid division by zero: if expected is zero (which only happens if n=0), define statistic 0.\n    if expected == 0:\n        stat = 0.0\n    else:\n        diff = counts - expected\n        stat = np.sum((diff * diff) / expected)\n\n    # Degrees of freedom\n    df = K - 1 if K > 0 else 0\n\n    # Lower-tail chi-square threshold\n    if df > 0 and alpha > 0.0:\n        threshold = chi2.ppf(alpha, df)\n        chi_left_reject = stat  threshold\n    else:\n        chi_left_reject = False\n\n    # Exact stratification: reject if all counts are equal to expected and expected is integer\n    # This detects exact one-per-cell when n == K, but also handles general n divisible by K.\n    exact_strat_reject = False\n    if expected.is_integer():\n        exact_strat_reject = np.all(counts == int(expected))\n\n    return bool(chi_left_reject or exact_strat_reject)\n\ndef generate_points(case: dict) -> np.ndarray:\n    d = case[\"d\"]\n    n = case[\"n\"]\n    seq_type = case[\"seq\"]\n    seed = case.get(\"seed\", None)\n    if seq_type == \"iid\":\n        rng = np.random.default_rng(seed)\n        pts = rng.random((n, d))\n        return pts\n    elif seq_type == \"sobol\":\n        scramble = case.get(\"scramble\", False)\n        # Prefer base-2 length when available\n        # We assume n is a power of two in these cases (as per test suite)\n        m_exp = int(round(np.log2(n)))\n        if 2 ** m_exp != n:\n            # Fallback to arbitrary n\n            engine = qmc.Sobol(d=d, scramble=scramble, seed=seed)\n            pts = engine.random(n)\n        else:\n            engine = qmc.Sobol(d=d, scramble=scramble, seed=seed)\n            pts = engine.random_base2(m_exp)\n        return pts\n    else:\n        raise ValueError(\"Unknown sequence type\")\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: IID uniform, d=2, m=8, n=64, alpha=1e-6, seed=20240527\n        {\"d\": 2, \"m\": 8, \"n\": 64, \"alpha\": 1e-6, \"seq\": \"iid\", \"seed\": 20240527},\n        # Case 2: Sobol unscrambled, d=2, m=8, n=64, alpha=1e-6\n        {\"d\": 2, \"m\": 8, \"n\": 64, \"alpha\": 1e-6, \"seq\": \"sobol\", \"scramble\": False},\n        # Case 3: Sobol scrambled, d=2, m=8, n=64, alpha=1e-6, seed=123\n        {\"d\": 2, \"m\": 8, \"n\": 64, \"alpha\": 1e-6, \"seq\": \"sobol\", \"scramble\": True, \"seed\": 123},\n    ]\n\n    results = []\n    for case in test_cases:\n        d = case[\"d\"]\n        m = case[\"m\"]\n        n = case[\"n\"]\n        alpha = case[\"alpha\"]\n        pts = generate_points(case)\n        # Safety check: shape must be (n, d)\n        assert pts.shape == (n, d), \"Generated point set has incorrect shape\"\n        reject = chi_square_left_tail_with_exact_stratification(pts, m=m, alpha=alpha)\n        results.append(reject)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}